protected boolean [ ] dataset Integrity ( boolean nominal Predictor , boolean numeric Predictor , boolean string Predictor , boolean date Predictor , boolean relational Predictor , boolean multi Instance , int class Type , boolean predictor Missing , boolean class Missing ) { print ( _ STR ) ; print Attribute Summary ( nominal Predictor , numeric Predictor , string Predictor , date Predictor , relational Predictor , multi Instance , class Type ) ; print ( _ STR ) ; int num Train = get Num Instances ( ) , num Test = get Num Instances ( ) , num Classes = _ NUM , missing Level = _ NUM ; boolean [ ] result = new boolean [ _ NUM ] ;  Instances train = null ;  Instances test = null ;  Classifier classifier = null ;  Evaluation evaluation = null ; boolean built = _ BOOL ; try { train = make Test Dataset ( _ NUM , num Train , nominal Predictor ? get Num Nominal ( ) : _ NUM , numeric Predictor ? get Num Numeric ( ) : _ NUM , string Predictor ? get Num String ( ) : _ NUM , date Predictor ? get Num Date ( ) : _ NUM , relational Predictor ? get Num Relational ( ) : _ NUM , num Classes , class Type , multi Instance ) ; test = make Test Dataset ( _ NUM , num Test , nominal Predictor ? get Num Nominal ( ) : _ NUM , numeric Predictor ? get Num Numeric ( ) : _ NUM , string Predictor ? get Num String ( ) : _ NUM , date Predictor ? get Num Date ( ) : _ NUM , relational Predictor ? get Num Relational ( ) : _ NUM , num Classes , class Type , multi Instance ) ; if ( missing Level > _ NUM ) { add Missing ( train , missing Level , predictor Missing , class Missing ) ; add Missing ( test ,  Math . min ( missing Level , _ NUM ) , predictor Missing , class Missing ) ; } classifier =  Abstract Classifier . make Copies ( get Classifier ( ) , _ NUM ) [ _ NUM ] ; evaluation = new  Evaluation ( train ) ; } catch (  Exception ex ) { throw new  Error ( _ STR + ex . get Message ( ) ) ; } try {  Instances train Copy = new  Instances ( train ) ;  Instances test Copy = new  Instances ( test ) ; classifier . build Classifier ( train Copy ) ; compare Datasets ( train , train Copy ) ; built = _ BOOL ; test WRTZero R ( classifier , evaluation , train Copy , test Copy ) ; compare Datasets ( test , test Copy ) ; println ( _ STR ) ; result [ _ NUM ] = _ BOOL ; } catch (  Exception ex ) { println ( _ STR ) ; result [ _ NUM ] = _ BOOL ; if ( m_ Debug ) { println ( _ STR ) ; print ( _ STR ) ; if ( built ) { print ( _ STR ) ; } else { print ( _ STR ) ; } println ( _ STR + ex . get Message ( ) + _ STR ) ; println ( _ STR ) ; println ( _ STR + train . to String ( ) + _ STR ) ; println ( _ STR + test . to String ( ) + _ STR ) ; } } return result ; }
public static int intersection Size ( long [ ] x , long [ ] y ) { final int lx = x . length , ly = y . length ; final int min = ( lx < ly ) ? lx : ly ; int res = _ NUM ; for ( int i = _ NUM ; i < min ; i ++ ) { res +=  Long . bit Count ( x [ i ] & y [ i ] ) ; } return res ; }
public void test Reverse Order2 ( ) throws  Exception {  UUID id =  UUID . random UUID ( ) ;  Grid Cache Adapter <  String ,  String > cache = grid . internal Cache ( ) ;  Grid Cache Context <  String ,  String > ctx = cache . context ( ) ;  Grid Cache Test Entry Ex entry1 = new  Grid Cache Test Entry Ex ( ctx , _ STR ) ;  Grid Cache Test Entry Ex entry2 = new  Grid Cache Test Entry Ex ( ctx , _ STR ) ;  Grid Cache Version ver1 = version ( _ NUM ) ;  Grid Cache Version ver2 = version ( _ NUM ) ;  Grid Cache Version ver3 = version ( _ NUM ) ;  Grid Cache Mvcc Candidate v3k1 = entry1 . add Local ( _ NUM , ver3 , _ NUM , _ BOOL , _ BOOL ) ;  Grid Cache Mvcc Candidate v3k2 = entry2 . add Local ( _ NUM , ver3 , _ NUM , _ BOOL , _ BOOL ) ; link Candidates ( ctx , v3k1 , v3k2 ) ; entry1 . ready Local ( v3k1 ) ; check Local ( v3k1 , ver3 , _ BOOL , _ BOOL , _ BOOL ) ; check Local ( v3k2 , ver3 , _ BOOL , _ BOOL , _ BOOL ) ;  Grid Cache Mvcc Candidate v2k1 = entry1 . add Remote ( id , _ NUM , ver2 , _ NUM , _ BOOL , _ BOOL ) ;  Grid Cache Mvcc Candidate v2k2 = entry2 . add Remote ( id , _ NUM , ver2 , _ NUM , _ BOOL , _ BOOL ) ; check Remote ( v2k1 , ver2 , _ BOOL , _ BOOL ) ; check Remote ( v2k2 , ver2 , _ BOOL , _ BOOL ) ;  Grid Cache Mvcc Candidate v1k1 = entry1 . add Local ( _ NUM , ver1 , _ NUM , _ BOOL , _ BOOL ) ;  Grid Cache Mvcc Candidate v1k2 = entry2 . add Local ( _ NUM , ver1 , _ NUM , _ BOOL , _ BOOL ) ; link Candidates ( ctx , v1k1 , v1k2 ) ; entry1 . ready Local ( v1k1 ) ; entry2 . ready Local ( v1k2 ) ; check Local ( v1k1 , ver1 , _ BOOL , _ BOOL , _ BOOL ) ; check Local ( v1k2 , ver1 , _ BOOL , _ BOOL , _ BOOL ) ; check Local ( v3k2 , ver3 , _ BOOL , _ BOOL , _ BOOL ) ; entry2 . ready Local ( v3k2 ) ; check Local ( v3k2 , ver3 , _ BOOL , _ BOOL , _ BOOL ) ; check Local ( v1k1 , ver1 , _ BOOL , _ BOOL , _ BOOL ) ; check Local ( v1k2 , ver1 , _ BOOL , _ BOOL , _ BOOL ) ; }
protected void initialize ( ) {  List <  Add User Fields .  Attribute Spec > specs = m_filter . get Attribute Specs ( ) ; m_list Model = new  Default List Model ( ) ; m_list . set Model ( m_list Model ) ; if ( specs . size ( ) > _ NUM ) { m_up But . set Enabled ( _ BOOL ) ; m_down But . set Enabled ( _ BOOL ) ; for (  Add User Fields .  Attribute Spec s : specs ) {  Add User Fields .  Attribute Spec spec Copy = new  Add User Fields .  Attribute Spec ( s . to String Internal ( ) ) ; m_list Model . add Element ( spec Copy ) ; } m_list . repaint ( ) ; } else { m_name Field . set Enabled ( _ BOOL ) ; m_type Field . set Enabled ( _ BOOL ) ; m_date Format Field . set Enabled ( _ BOOL ) ; m_value Field . set Enabled ( _ BOOL ) ; } }
public  String attributes To String ( ) {  String Buffer text = new  String Buffer ( ) ; int j = _ NUM ; for ( int i = _ NUM ; i < m_attributes . length ; i ++ ) { if ( m_attributes [ i ] ) { if ( is Gaussian ( ) ) { text . append ( _ STR + i ) ; text . append ( _ STR + m_mean Value [ j ] ) ; text . append ( _ STR + m_stddev Value [ j ] + _ STR ) ; } else { text . append ( _ STR + i ) ; text . append ( _ STR + m_min Value [ j ] ) ; text . append ( _ STR + m_max Value [ j ] + _ STR ) ; } j ++ ; } } return text . to String ( ) ; }
public  String value To String ( double value ) { return  String . value Of ( value ) ; }
@  Override public  String initialize ( ) { m_ Current = _ NUM ; for (  File dataset : m_ Datasets ) { if ( ! dataset . exists ( ) ) return _ STR + dataset ; if ( dataset . is Directory ( ) ) return _ STR + dataset ; } return null ; }
public synchronized void init Task Scheduler If Not ( ) { if ( scheduler == null ) { scheduler =  Executors . new Single Thread Scheduled Executor (  Daemon Thread Factory . get Instance ( ) ) ;  Capacity Aware Task Scheduler runner = new  Capacity Aware Task Scheduler ( ) ; scheduler . schedule At Fixed Rate ( runner ,  Parallec Global Config . scheduler Init Delay ,  Parallec Global Config . scheduler Check Interval ,  Time Unit .  MILLISECONDS ) ; logger . info ( _ STR ) ; } }
public boolean equals (  Object t ) { return ( ( t instanceof  Ref Type ) && class Name . equals ( ( (  Ref Type ) t ) . class Name ) ) ; }
public  Entry create Root (  User user ,  String id ,  String type ,  String notebook Id ,  Long mod Time ,  Long create Time ,  Errors errors ) { if ( user == null ) {  Errors . add ( errors , error Messages . error User Is Null ( ) ) ; return null ; } if ( mod Time == null ) {  Errors . add ( errors , error Messages . error Mod Time Is Null ( ) ) ; return null ; } if ( create Time == null ) {  Errors . add ( errors , error Messages . error Create Time Is Null ( ) ) ; return null ; } if ( id != null && ! id Generator . is Id Well Formed ( id ) ) {  Errors . add ( errors , error Messages . error Id Is Invalid ( ) ) ; return null ; } if ( notebook Id != null && ! id Generator . is Id Well Formed ( notebook Id ) ) {  Errors . add ( errors , error Messages . error Notebook Id Is Invalid ( ) ) ; return null ; } if ( create Time . long Value ( ) > mod Time . long Value ( ) ) { mod Time = create Time ; }  Entry root = new  Entry ( ) ; root . set Db ( db ) ; if ( id == null ) { id = id Generator . get Another Id ( ) ; } root . set Id ( id ) ; root . set Create Time ( create Time ) ; root . set Mod Time ( mod Time ) ; root . set Type ( type ) ; root . set User Id ( user . get Id ( ) ) ; root . set Notebook Id ( notebook Id ) ; db . persist Entry ( root ) ; return root ; }
private void validate Jdbc Statements (  List <  Jdbc Statement > jdbc Statements ) {  Assert . not Null ( jdbc Statements , _ STR ) ;  Assert . is True ( ! jdbc Statements . is Empty ( ) , _ STR ) ;  Integer jdbc Max Statements = configuration Helper . get Property (  Configuration Value .  JDBC_ MAX_ STATEMENTS ,  Integer . class ) ; if ( jdbc Max Statements != null ) {  Assert . is True ( jdbc Statements . size ( ) <= jdbc Max Statements , _ STR + jdbc Max Statements + _ STR ) ; } for ( int i = _ NUM ; i < jdbc Statements . size ( ) ; i ++ ) {  Jdbc Statement jdbc Statement = jdbc Statements . get ( i ) ; validate Jdbc Statement ( jdbc Statement , i ) ; } }
public static  Integer [ ] values Of ( int [ ] array ) {  Integer [ ] dest = new  Integer [ array . length ] ; for ( int i = _ NUM ; i < array . length ; i ++ ) { dest [ i ] =  Integer . value Of ( array [ i ] ) ; } return dest ; }
@  Override public boolean is Debug Enabled ( ) { return logger . is Loggable (  Level .  FINE ) ; }
protected boolean is Item Bound To Other Player ( final  Player player , final  RPObject object ) { if ( object instanceof  Item ) { final  Item item = (  Item ) object ; if ( item . is Bound ( ) && ! player . is Bound To ( item ) ) { player . send Private Text ( _ STR + item . get Name ( ) + _ STR + item . get Bound To ( ) + _ STR ) ; return _ BOOL ; } } return _ BOOL ; }
public  Base Matcher ( final  Network Config config ) { if ( config == null ) { throw new  Null Pointer Exception ( _ STR ) ; } else { this . config = config ; } }
private  Log Level log4j To Generic Log Level (  Level level ) {  Log Level log Level =  Log Level .  ALL ; if ( level . equals (  Level .  OFF ) ) { log Level =  Log Level .  OFF ; } else if ( level . equals (  Level .  FATAL ) ) { log Level =  Log Level .  FATAL ; } else if ( level . equals (  Level .  ERROR ) ) { log Level =  Log Level .  ERROR ; } else if ( level . equals (  Level .  WARN ) ) { log Level =  Log Level .  WARN ; } else if ( level . equals (  Level .  INFO ) ) { log Level =  Log Level .  INFO ; } else if ( level . equals (  Level .  DEBUG ) ) { log Level =  Log Level .  DEBUG ; } else if ( level . equals (  Level .  TRACE ) ) { log Level =  Log Level .  TRACE ; } else if ( level . equals (  Level .  ALL ) ) { log Level =  Log Level .  ALL ; } else {  LOGGER . warn ( _ STR + level . to String ( ) + _ STR ) ; } return log Level ; }
synchronized  String create Local Id ( ) { long local Id Number = random . next Long ( ) ;  String local Id = _ STR +  Long . to Hex String ( local Id Number ) ; if ( ! is Local Id ( local Id ) ) { throw new  Illegal State Exception ( _ STR + local Id + _ STR + _ STR ) ; } return local Id ; }
public static void e (  String msg ,  Object ... args ) { if ( ! allow E ) return ;  Stack Trace Element caller = get Caller Stack Trace Element ( ) ;  String tag = generate Tag ( caller ) ; if ( s Level >  LEVEL_ ERROR ) { return ; } if ( args . length > _ NUM ) { msg =  String . format ( msg , args ) ; }  Log . e ( tag , msg ) ; }
public void add Leaf (  String name ,  String path ) {  Named Icon icon =  Named Icon . get Icon By Name ( path ) ; if ( icon == null ) { log . warn ( _ STR + path + _ STR ) ; return ; } int h = icon . get Icon Height ( ) ; for ( int i = _ NUM ; i < _leaves . size ( ) ; i ++ ) {  Catalog Tree Leaf leaf = _leaves . get ( i ) ; if ( h < leaf . get Size ( ) ) { _leaves . add ( i + _ NUM , new  Catalog Tree Leaf ( name , path , h ) ) ; return ; } } _leaves . add ( new  Catalog Tree Leaf ( name , path , h ) ) ; }
public  String to String ( ) {  String Builder s = new  String Builder ( ) ; for ( int i = _ NUM ; i < d ; i ++ ) s . append ( data [ i ] + _ STR ) ; return s . to String ( ) ; }
protected boolean prevalidate ( final  String component , final  Bit Set disallowed ) { if ( component == null ) { return _ BOOL ; } final char [ ] target = component . to Char Array ( ) ; for ( int i = _ NUM ; i < target . length ; i ++ ) { if ( disallowed . get ( target [ i ] ) ) { return _ BOOL ; } } return _ BOOL ; }
public void add Shutdown Hook (  Thread hook ) {  Security Manager sm =  System . get Security Manager ( ) ; if ( sm != null ) { sm . check Permission (  Runtime Permission Collection .  SHUTDOWN_ HOOKS_ PERMISSION ) ; } if ( hook == null ) throw new  Null Pointer Exception ( _ STR ) ; if ( hook . get State ( ) !=  Thread .  State .  NEW ) { throw new  Illegal Argument Exception ( ) ; } if (  VMState > _ NUM ) { throw new  Illegal State Exception ( ) ; } synchronized ( hooks List ) { if ( hooks List . contains ( hook ) ) { throw new  Illegal Argument Exception ( ) ; } hooks List . add ( hook ) ; } }
@  Override public void run ( ) { while ( ! stop Hide ) { print ( _ STR ) ; try {  Thread . sleep ( _ NUM ) ; } catch (  Interrupted Exception e ) { } } }
public boolean bound Scroll Raw ( ) { float cur Scroll = get Stack Scroll ( ) ; float new Scroll = get Bounded Stack Scroll ( cur Scroll ) ; if (  Float . compare ( new Scroll , cur Scroll ) != _ NUM ) { set Stack Scroll Raw ( new Scroll ) ; return _ BOOL ; } return _ BOOL ; }
public  String evaluation Metric Tip Text ( ) { return _ STR ; }
public  Request add (  Request request ) { request . set Request Queue ( this ) ; synchronized ( m Current Requests ) { m Current Requests . add ( request ) ; } request . set Sequence ( get Sequence Number ( ) ) ; request . add Marker ( _ STR ) ; if ( ! request . should Cache ( ) ) { m Network Queue . add ( request ) ; return request ; } synchronized ( m Waiting Requests ) {  String cache Key = request . get Cache Key ( ) ; if ( m Waiting Requests . contains Key ( cache Key ) ) {  Queue <  Request > staged Requests = m Waiting Requests . get ( cache Key ) ; if ( staged Requests == null ) { staged Requests = new  Linked List <  Request > ( ) ; } staged Requests . add ( request ) ; m Waiting Requests . put ( cache Key , staged Requests ) ; if (  Volley Log .  DEBUG ) {  Volley Log . v ( _ STR , cache Key ) ; } } else { m Waiting Requests . put ( cache Key , null ) ; m Cache Queue . add ( request ) ; } return request ; } }
protected void process Start Arg ( final  String key , final  String value , final  Map <  String ,  Object > options , final  List <  String > vm Args , final  Properties props ) throws  Exception { props . set Property ( key , value ) ; }
public static  String correct File Name (  String f ) { f = f . replace ( _ STR , _ STR ) ; if ( f . starts With ( _ STR ) ) { f = f . substring ( _ NUM ) ; } return f ; }
public void paint ( final  Graphics g ) { g . draw Image ( image , _ NUM , _ NUM , this ) ; synchronized ( this ) { if ( ! paint Called ) { paint Called = _ BOOL ; notify All ( ) ; } } }
@  Override public boolean connection Allowed (  String event Name ) { if ( m_listenees . contains Key ( event Name ) ) { return _ BOOL ; } if ( m_listenees . contains Key ( _ STR ) && ( event Name . compare To ( _ STR ) == _ NUM || event Name . compare To ( _ STR ) == _ NUM || event Name . compare To ( _ STR ) == _ NUM ) ) { return _ BOOL ; } if ( ( m_listenees . contains Key ( _ STR ) || m_listenees . contains Key ( _ STR ) ) && ( event Name . compare To ( _ STR ) == _ NUM || event Name . compare To ( _ STR ) == _ NUM ) ) { return _ BOOL ; } if ( m_listenees . contains Key ( _ STR ) && ( event Name . compare To ( _ STR ) == _ NUM || event Name . compare To ( _ STR ) == _ NUM || event Name . compare To ( _ STR ) == _ NUM ) ) { return _ BOOL ; } if ( event Name . compare To ( _ STR ) == _ NUM && ! ( m_ Filter instanceof  Streamable Filter ) ) { return _ BOOL ; } return _ BOOL ; }
public boolean is Prefixed ( ) { return tag . index Of ( _ STR ) >= _ NUM ; }
private void close Connection (  Connection connection ) throws  SQLException { if ( connection != null ) { try { connection . close ( ) ; } catch (  SQLException e ) { throw new  SQLException ( _ STR , e ) ; } } }
public  Quick Action View remove Actions ( ) { m Actions . clear ( ) ; return this ; }
@  Safe Varargs protected <  T extends  Abstract Option Value < ? , ? > >  Abstract Options (  Function <  T ,  T > value Filter ,  Abstract Options base Options ,  T ... values ) { require Non Null ( base Options , _ STR ) ; require Non Null ( value Filter , _ STR ) ; require Non Null ( values , _ STR ) ; value Map = new  Identity Hash Map < > ( base Options . value Map ) ; put All ( value Filter ,  Stream . of ( values ) ) ; }
public static  Char Seq of (  String str ) { return new  Char Seq ( str ) ; }
public void handle Button Download Cert Request (  Request Invocation Event event ) throws  Model Control Exception {  Request Context req Context = event . get Request Context ( ) ;  Http Servlet Response resp = req Context . get Response ( ) ;  String cert = (  String ) ps Model . get Value ( _ STR ) ;  Servlet Output Stream op = null ; try { int length = _ NUM ; op = resp . get Output Stream ( ) ; resp . set Content Type ( _ STR ) ; resp . set Content Length ( cert . length ( ) ) ; resp . set Header ( _ STR , _ STR + _ STR + _ STR ) ; int  BUFSIZE = cert . length ( ) ; byte [ ] bbuf = new byte [  BUFSIZE ] ;  Input Stream is = new  Byte Array Input Stream ( cert . get Bytes ( ) ) ;  Data Input Stream in = new  Data Input Stream ( is ) ; while ( ( in != null ) && ( ( length = in . read ( bbuf ) ) != - _ NUM ) ) { op . write ( bbuf , _ NUM , length ) ; } in . close ( ) ; op . flush ( ) ; } catch (  IOException ex ) { debug . error ( _ STR , ex ) ; set Inline Alert Message (  CCAlert .  TYPE_ ERROR , _ STR , ex . get Message ( ) ) ; } finally { if ( op != null ) { try { op . close ( ) ; } catch (  IOException ex ) { debug . error ( _ STR , ex ) ; set Inline Alert Message (  CCAlert .  TYPE_ ERROR , _ STR , ex . get Message ( ) ) ; } } } }
protected boolean compare And Set State (  State Type old State ,  State Type new State ) { if ( state . compare And Set ( old State , new State ) ) { after State Changed ( new State ) ; return _ BOOL ; } else return _ BOOL ; }
private void format And Log Throwable (  Logging Level level ,  String msg ,  Throwable t ) { if (  Photon Logger . level . id < level . id ) { return ; }  Local Date Time date Time =  Local Date Time . now ( ) ;  String formatted = format Log Line ( level , date Time , msg ) ;  Logging Service . log Throwable ( date Time , t , formatted ) ; }
public static  String construct Job Id Redis Key (  String queue Name ,  String shard Name ) { return  String . format ( _ STR ,  PINLATER_ JOB_ ID_ KEY_ PREFIX , shard Name , queue Name ) ; }
public static boolean is Ascii (  String s ) { if ( s == null ) { return _ BOOL ; } try { if ( ! s . equals ( new  String ( s . get Bytes (  ASCII_ CHARSET ) ,  ASCII_ CHARSET ) ) ) { return _ BOOL ; } } catch ( java . io .  Unsupported Encoding Exception uee ) { return _ BOOL ; } return _ BOOL ; }
public void add Permitted Domain (  String domain Name ) { if (  String Utils . is Empty ( domain Name ) ) { return ; } if ( permitted Domains == null ) { permitted Domains = new  Array List < > ( ) ; } permitted Domains . add ( domain Name ) ; }
public  Stoppable Write Lock (  Read Write Lock lock ,  Cancel Criterion stopper ) { this . lock = lock . write Lock ( ) ; this . stopper = stopper ; }
private long compute Method Hash ( ) { long hash = _ NUM ;  Byte Array Output Stream sink = new  Byte Array Output Stream ( _ NUM ) ; try {  Message Digest md =  Message Digest . get Instance ( _ STR ) ;  Data Output Stream out = new  Data Output Stream ( new  Digest Output Stream ( sink , md ) ) ;  String method String = name And Descriptor ( ) ; out . write UTF ( method String ) ; out . flush ( ) ; byte hash Array [ ] = md . digest ( ) ; for ( int i = _ NUM ; i <  Math . min ( _ NUM , hash Array . length ) ; i ++ ) { hash += ( ( long ) ( hash Array [ i ] & _ NUM ) ) << ( i * _ NUM ) ; } } catch (  IOException e ) { throw new  Assertion Error ( e ) ; } catch (  No Such Algorithm Exception e ) { throw new  Assertion Error ( e ) ; } return hash ; }
private final  String _decode Short Unicode Name ( int len ) throws  IOException { int out Ptr = _ NUM ; char [ ] out Buf = _text Buffer . empty And Get Current Segment ( ) ; int in Ptr = _input Ptr ; _input Ptr += len ; final int [ ] codes =  Smile Constants . s Utf8 Unit Lengths ; final byte [ ] in Buf = _input Buffer ; for ( int end = in Ptr + len ; in Ptr < end ; ) { int i = in Buf [ in Ptr ++ ] & _ NUM ; int code = codes [ i ] ; if ( code != _ NUM ) { switch ( code ) { case _ NUM : i = ( ( i & _ NUM ) << _ NUM ) | ( in Buf [ in Ptr ++ ] & _ NUM ) ; break ; case _ NUM : i = ( ( i & _ NUM ) << _ NUM ) | ( ( in Buf [ in Ptr ++ ] & _ NUM ) << _ NUM ) | ( in Buf [ in Ptr ++ ] & _ NUM ) ; break ; case _ NUM : i = ( ( i & _ NUM ) << _ NUM ) | ( ( in Buf [ in Ptr ++ ] & _ NUM ) << _ NUM ) | ( ( in Buf [ in Ptr ++ ] & _ NUM ) << _ NUM ) | ( in Buf [ in Ptr ++ ] & _ NUM ) ; i -= _ NUM ; out Buf [ out Ptr ++ ] = ( char ) ( _ NUM | ( i > > _ NUM ) ) ; i = _ NUM | ( i & _ NUM ) ; break ; default : _report Error ( _ STR +  Integer . to Hex String ( i ) + _ STR ) ; } } out Buf [ out Ptr ++ ] = ( char ) i ; } _text Buffer . set Current Length ( out Ptr ) ; return _text Buffer . contents As String ( ) ; }
private void listener Dropped (  Array List drops ,  Array List notifies ) {  Service Registrar [ ] proxys = new  Service Registrar [ drops . size ( ) ] ; drops . to Array ( proxys ) ; listener Dropped ( proxys , notifies ) ; }
public  String to String ( ) {  Object val = get Value ( ) ; if ( val != null ) return val . to String ( ) ; return _ STR ; }
public static boolean is Enabled ( ) { return logger Impl . is Enabled ( ) ; }
public void add Nodes In Doc Order (  Node Iterator iterator ,  XPath Context support ) { if ( ! m_mutable ) throw new  Runtime Exception (  XSLMessages . create XPATHMessage (  XPATHError Resources .  ER_ NODESET_ NOT_ MUTABLE , null ) ) ;  Node node ; while ( null != ( node = iterator . next Node ( ) ) ) { add Node In Doc Order ( node , support ) ; } }
private void update ( ) { final long now =  System . current Time Millis ( ) ; update ( ( int ) ( now - last Update ) ) ; last Update = now ; }
public static  String extract Last Name (  String qualified Name ) { int i = qualified Name . last Index Of ( _ STR ) ; if ( i == - _ NUM ) return qualified Name ; return qualified Name . substring ( i + _ NUM ) ; }
public void handle Request (  Request Context rc ) throws  CLIException { super . handle Request ( rc ) ; ldap Login ( ) ;  SSOToken admin SSOToken = get Admin SSOToken ( ) ;  IOutput output Writer = get Output Writer ( ) ;  String realm = get String Option Value (  IArgument .  REALM_ NAME ) ;  String pattern Type = get String Option Value (  IArgument .  AGENT_ TYPE ) ;  String filter = get String Option Value (  IArgument .  FILTER ) ; if ( pattern Type == null ) { pattern Type = _ STR ; } if ( ( filter == null ) || ( filter . length ( ) == _ NUM ) ) { filter = _ STR ; }  String [ ] params = { realm , pattern Type , filter } ; write Log (  Log Writer .  LOG_ ACCESS ,  Level .  INFO , _ STR , params ) ; try {  AMIdentity Repository amir = new  AMIdentity Repository ( admin SSOToken , realm ) ;  Id Search Results isr = amir . search Identities (  Id Type .  AGENTGROUP , filter , new  Id Search Control ( ) ) ;  Set results = isr . get Search Results ( ) ; if ( ( results != null ) && ! results . is Empty ( ) ) { for (  Iterator i = results . iterator ( ) ; i . has Next ( ) ; ) {  AMIdentity amid = (  AMIdentity ) i . next ( ) ; if ( ! match Type ( amid , pattern Type ) ) { i . remove ( ) ; } } } if ( ( results != null ) && ! results . is Empty ( ) ) { for (  Iterator i = results . iterator ( ) ; i . has Next ( ) ; ) {  AMIdentity amid = (  AMIdentity ) i . next ( ) ;  Object [ ] args = { amid . get Name ( ) , amid . get Universal Id ( ) } ; output Writer . println Message (  Message Format . format ( get Resource String ( _ STR ) , args ) ) ; } } else { output Writer . println Message ( get Resource String ( _ STR ) ) ; } write Log (  Log Writer .  LOG_ ACCESS ,  Level .  INFO , _ STR , params ) ; } catch (  Id Repo Exception e ) {  String [ ] args = { realm , pattern Type , filter , e . get Message ( ) } ; debug Error ( _ STR , e ) ; write Log (  Log Writer .  LOG_ ERROR ,  Level .  INFO , _ STR , args ) ; throw new  CLIException ( e ,  Exit Codes .  REQUEST_ CANNOT_ BE_ PROCESSED ) ; } catch (  SSOException e ) {  String [ ] args = { realm , pattern Type , filter , e . get Message ( ) } ; debug Error ( _ STR , e ) ; write Log (  Log Writer .  LOG_ ERROR ,  Level .  INFO , _ STR , args ) ; throw new  CLIException ( e ,  Exit Codes .  REQUEST_ CANNOT_ BE_ PROCESSED ) ; } }
public static byte [ ] to Byte Array (  Input Stream in ) throws  IOException {  Byte Array Output Stream out = new  Byte Array Output Stream ( ) ; copy ( in , out ) ; return out . to Byte Array ( ) ; }
public static void check Field Value From Enum ( final  String value , final  String field Name ,  Class < ? extends  Enum > enum Type ) { if ( value != null ) { check Field Value From Enum ( value , field Name ,  Enum Set . all Of ( enum Type ) ) ; } }
@  Override public void close ( ) throws  IOException {  Output Stream stream = get Stream ( ) ; if ( stream == null ) { return ; } synchronized ( stream ) { stream . flush ( ) ; } }
static public  List <  Export Mask > sort Masks By Eligibility (  Map <  Export Mask ,  Export Mask Policy > mask Map ,  Export Group export Group ) {  List <  Export Mask Comparator Container > export Mask Container List = new  Array List <  Export Mask Comparator Container > ( ) ; for (  Map .  Entry <  Export Mask ,  Export Mask Policy > entry : mask Map . entry Set ( ) ) { export Mask Container List . add ( new  Export Mask Comparator Container ( entry . get Key ( ) , entry . get Value ( ) , export Group ) ) ; }  Collections . sort ( export Mask Container List , new  Export Mask Comparator ( ) ) ;  List <  Export Mask > sorted Masks = new  Array List <  Export Mask > ( ) ; for (  Export Mask Comparator Container container : export Mask Container List ) {  Export Mask Policy policy = container . policy ;  Export Mask mask = container . mask ; _log . info (  String . format ( _ STR , mask . get Mask Name ( ) , policy . is Simple Mask ( ) , policy . get Ig Type ( ) , policy . get Export Type ( ) , policy . local Tier Policy ,  Common Transformer Functions . collection To String ( policy . get Tier Policies ( ) ) ) ) ; sorted Masks . add ( container . mask ) ; } return sorted Masks ; }
public synchronized void add (  K obj ) { int len = array . length ; array =  Arrays . copy Of ( array , len + _ NUM ) ; array [ len ] = obj ; }
public void write (  Image c ,  Component i ) { if ( page == null ) { newpage ( ) ; } int x = x0 + width - ( c . get Width ( null ) * _ NUM / _ NUM + charwidth ) ; int y = y0 + ( linenum * lineheight ) + lineascent ; if ( page != null && pagenum >= pr First ) { page . draw Image ( c , x , y , c . get Width ( null ) * _ NUM / _ NUM , c . get Height ( null ) * _ NUM / _ NUM , null ) ; } }
public void copy (  File in ,  File out ) throws  IOException {  Input Stream is = null ;  Output Stream os = null ; try { is = new  Buffered File Input Stream ( in ) ; os = new  Buffered File Output Stream ( out ) ; } catch (  IOException ioe ) { close EL ( is , os ) ; throw ioe ; } copy ( is , os , _ BOOL , _ BOOL ) ; }
public void stop ( ) { this . fade Out = _ BOOL ; }
private void correct Too Low ( int child Count ) { if ( m First Position == _ NUM && child Count > _ NUM ) { final int first Top = get Scroll Child Top ( ) ; final int start = m List Padding . top ; final int end = ( get Bottom ( ) - get Top ( ) ) - m List Padding . bottom ; int top Offset = first Top - start ; final int last Bottom = get Scroll Child Bottom ( ) ; int last Position = m First Position + child Count - _ NUM ; if ( top Offset > _ NUM ) { if ( last Position < m Item Count - _ NUM || last Bottom > end ) { if ( last Position == m Item Count - _ NUM ) { top Offset =  Math . min ( top Offset , last Bottom - end ) ; } try Offset Children Top And Bottom ( - top Offset ) ; if ( last Position < m Item Count - _ NUM ) { fill Down ( last Position + _ NUM , get Fill Child Top ( ) + m Divider Height ) ; adjust Views Up Or Down ( ) ; } } else if ( last Position == m Item Count - _ NUM ) { adjust Views Up Or Down ( ) ; } } } }
public static void initialize Properties (  Properties properties ) { if ( system Properties != null ) { system Properties . initialize Properties ( properties ) ; } }
public void write Binary (  Byte Buffer bin ) throws  TException { int length = bin . limit ( ) - bin . position ( ) ; write Binary ( bin . array ( ) , bin . position ( ) + bin . array Offset ( ) , length ) ; }
protected void add New Event (  Object event Key ,  T event ) { if ( unwritten Events == null ) { unwritten Events =  Maps . new Hash Map ( ) ; }  List <  T > list Events = unwritten Events . get ( event Key ) ; if ( list Events == null ) { unwritten Events . put ( event Key ,  Lists . new Array List ( event ) ) ; } else { list Events . add ( event ) ; } }
@  Override public int read ( ) throws  IOException { int b0 = f Input Stream . read ( ) ; if ( b0 >= _ NUM ) { throw new  Malformed Byte Sequence Exception ( f Formatter , f Locale ,  XMLMessage Formatter .  XML_ DOMAIN , _ STR , new  Object [ ] {  Integer . to String ( b0 ) } ) ; } return b0 ; }
protected void create_y_axis ( int i ,  String y , int size ) { float ver_height = ( ( graphheight / size ) * i ) + border ;  Log . e ( _ STR , i + _ STR + size + _ STR + height + _ STR + graphheight + _ STR + ver_height ) ; if ( i == size ) canvas . draw Line ( horstart , ver_height , width - ( border ) , ver_height , paint ) ; else canvas . draw Line ( horstart , ver_height , border , ver_height , paint ) ; paint . set Color (  Color .  BLACK ) ; paint . set Text Align (  Paint .  Align .  RIGHT ) ; canvas . draw Text ( y + _ STR , horstart - _ NUM , ver_height - _ NUM , paint ) ; paint . set Text Align (  Paint .  Align .  LEFT ) ; }
public final long add And Get ( long delta ) { return unsafe . get And Add Long ( this , value Offset , delta ) + delta ; }
static void check Access (  Management Permission p ) throws  Security Exception {  Security Manager sm =  System . get Security Manager ( ) ; if ( sm != null ) { sm . check Permission ( p ) ; } }
public boolean is In Sight ( final  Entity other ) { if ( other != null ) { if ( other . get Zone ( ) == get Zone ( ) ) { if ( (  Math . abs ( other . get X ( ) - x ) <= _ NUM ) && (  Math . abs ( other . get Y ( ) - y ) <= _ NUM ) ) { return _ BOOL ; } } } return _ BOOL ; }
@  Override public  String to String ( ) {  String pattern = printer Parser . to String ( ) ; pattern = pattern . starts With ( _ STR ) ? pattern : pattern . substring ( _ NUM , pattern . length ( ) - _ NUM ) ; return pattern ; }
public void close (  Result Set rs ) { if ( rs != null ) { try { rs . close ( ) ; } catch (  SQLException e ) { } } }
public  Snippet Input ( final  Class < ? extends  Throwable > p Expected , final  Object ... parameters ) { if ( parameters == null ) { params = new  Object [ _ NUM ] ; } else { params = new  Object [ parameters . length ] ;  System . arraycopy ( parameters , _ NUM , params , _ NUM , parameters . length ) ; } expected = p Expected ; }
void add Annotation ( @  Non Null  Annotation annotation ) { annotations . put ( annotation . annotation Type ( ) , annotation ) ; }
public boolean resource Exist (  Integer id ) { if ( id == null ) { return _ BOOL ; } return resource Exist ( id . int Value ( ) ) ; }
public  Create Window Clause add View (  String namespace ,  String name ,  List <  Expression > parameters ) { views . add (  View . create ( namespace , name , parameters ) ) ; return this ; }
public static java . sql .  Timestamp now Timestamp ( ) { return get Timestamp (  System . current Time Millis ( ) ) ; }
private  String real Key (  String key ) { return key . contains ( _ STR ) ? key . substring ( key . last Index Of ( _ STR ) + _ NUM , key . length ( ) ) : key ; }
public  Stream Impl open Read Impl (  Path Impl path ) throws  IOException {  String path Name = path . get Path ( ) ; return open Read Impl ( path Name ) ; }
@  Override public void on Reset ( ) { close Dialog ( ) ; }
public synchronized  OMGraphic List prepare ( ) { if ( spatial Indexes == null || spatial Indexes . is Empty ( ) ) { logger . fine ( get Name ( ) + _ STR ) ; return new  OMGraphic List ( ) ; }  Projection projection = get Projection ( ) ; if ( projection == null ) { logger . fine ( get Name ( ) + _ STR ) ; return new  OMGraphic List ( ) ; }  Point2 D ul = projection . get Upper Left ( ) ;  Point2 D lr = projection . get Lower Right ( ) ; double ul Lat = ul . get Y ( ) ; double ul Lon = ul . get X ( ) ; double lr Lat = lr . get Y ( ) ; double lr Lon = lr . get X ( ) ;  OMGraphic List master List = new  OMGraphic List ( ) ;  OMGraphic List list = null ; if (  Proj Math . is Crossing Dateline ( ul Lon , lr Lon , projection . get Scale ( ) ) ) { if ( logger . is Loggable (  Level .  FINE ) ) { logger . fine ( get Name ( ) + _ STR ) ; } double ymin =  Math . min ( ul Lat , lr Lat ) ; double ymax =  Math . max ( ul Lat , lr Lat ) ;  Iterator <  Spatial Index Handler > sii = spatial Indexes . iterator ( ) ; while ( sii . has Next ( ) ) {  Spatial Index Handler sih = (  Spatial Index Handler ) sii . next ( ) ; if ( ! sih . enabled ) continue ; try { list = sih . get Graphics ( ul Lon , ymin , _ NUM , ymax , list , projection ) ; list = sih . get Graphics ( - _ NUM , ymin , lr Lon , ymax , list , projection ) ; } catch ( java . io .  IOException ex ) { ex . print Stack Trace ( ) ; } catch (  Format Exception fe ) { fe . print Stack Trace ( ) ; } master List . add ( list ) ; } } else { double xmin = ( double )  Math . min ( ul Lon , lr Lon ) ; double xmax = ( double )  Math . max ( ul Lon , lr Lon ) ; double ymin = ( double )  Math . min ( ul Lat , lr Lat ) ; double ymax = ( double )  Math . max ( ul Lat , lr Lat ) ;  Iterator <  Spatial Index Handler > sii = spatial Indexes . iterator ( ) ; while ( sii . has Next ( ) ) {  Spatial Index Handler sih = (  Spatial Index Handler ) sii . next ( ) ; if ( ! sih . enabled ) continue ; if ( logger . is Loggable (  Level .  FINE ) ) { logger . fine ( get Name ( ) + _ STR + sih . pretty Name + _ STR ) ; } try { list = sih . get Graphics ( xmin , ymin , xmax , ymax , list , projection ) ; } catch ( java . io .  IOException ex ) { ex . print Stack Trace ( ) ; } catch (  Format Exception fe ) { fe . print Stack Trace ( ) ; } master List . add ( list ) ; } } return master List ; }
private boolean exposed ( int modifiers ) { return _ NUM != ( modifiers & (  Modifier .  PUBLIC |  Modifier .  PROTECTED ) ) ; }
public void test Divide Round Up Pos ( ) {  String a = _ STR ; int a Scale = - _ NUM ;  String b = _ STR ; int b Scale = _ NUM ;  String c = _ STR ; int res Scale = - _ NUM ;  Big Decimal a Number = new  Big Decimal ( new  Big Integer ( a ) , a Scale ) ;  Big Decimal b Number = new  Big Decimal ( new  Big Integer ( b ) , b Scale ) ;  Big Decimal result = a Number . divide ( b Number , res Scale ,  Big Decimal .  ROUND_ UP ) ; assert Equals ( _ STR , c , result . to String ( ) ) ; assert Equals ( _ STR , res Scale , result . scale ( ) ) ; }
public boolean restore Ms Word List Format For User (  String user Id ,  Input Stream Reader stream Reader , boolean is Admin ,  Errors errors ) { boolean result = really Restore Ms Word List Format For User ( user Id , stream Reader , is Admin , errors ) ; if ( ! result ) { rollback ( ) ; } else { commit ( ) ; } return result ; }
public static boolean is Empty (  Char Sequence cs ) { return cs == null || cs . length ( ) == _ NUM ; }
public void read (  Buffered Reader reader ) throws  Exception {  String line ; clear ( ) ; while ( ( line = reader . read Line ( ) ) != null ) { line = line . trim ( ) ; if ( line . starts With ( _ STR ) ) { continue ; } add ( line ) ; } reader . close ( ) ; }
private int measure Width ( int measure Spec ) { int result = _ NUM ; int spec Mode =  Measure Spec . get Mode ( measure Spec ) ; int spec Size =  Measure Spec . get Size ( measure Spec ) ; if ( spec Mode ==  Measure Spec .  EXACTLY ) { result = spec Size ; } else { result = ( int ) m Text Paint . measure Text ( m Text ) + get Padding Left ( ) + get Padding Right ( ) ; if ( spec Mode ==  Measure Spec .  AT_ MOST ) { result =  Math . min ( result , spec Size ) ; } } return result ; }
public void test_get Put Byte Array With Offset And Length ( ) { final int capacity = _ NUM ; final  Byte Array Buffer buf = new  Byte Array Buffer ( capacity ) ; assert Equals ( ( byte ) _ NUM , buf . get Byte ( _ NUM ) ) ; assert Equals ( ( byte ) _ NUM , buf . get Byte ( capacity - _ NUM ) ) ; final int pos = _ NUM ; for ( int i = _ NUM ; i <  LIMIT ; i ++ ) { final byte [ ] expected = new byte [ r . next Int ( capacity - _ NUM ) ] ; final int off = ( expected . length / _ NUM == _ NUM ? _ NUM : r . next Int ( expected . length / _ NUM ) ) ; final int len = ( expected . length == _ NUM ? _ NUM : r . next Int ( expected . length - off ) ) ; r . next Bytes ( expected ) ; buf . put ( pos , expected , off , len ) ; assert Equals ( _ NUM ,  Bytes Util . compare Bytes With Len And Offset ( off , len , expected , pos , len , buf . array ( ) ) ) ; final int dstoff = r . next Int ( _ NUM ) ; final byte [ ] actual = new byte [ expected . length + dstoff ] ; buf . get ( pos , actual , dstoff , expected . length ) ; assert Equals ( _ NUM ,  Bytes Util . compare Bytes With Len And Offset ( off , len , expected , dstoff , len , actual ) ) ; } assert Equals ( ( byte ) _ NUM , buf . get Byte ( _ NUM ) ) ; assert Equals ( ( byte ) _ NUM , buf . get Byte ( pos + capacity - _ NUM ) ) ; }
public boolean equals (  Object object ) { if ( this == object ) { return _ BOOL ; } else if ( object == null || get Class ( ) != object . get Class ( ) ) { return _ BOOL ; } return principal . equals ( object . to String ( ) ) ; }
protected  String url String ( ) throws  Parse Exception {  String Builder retval = new  String Builder ( ) ; lexer . select Lexer ( _ STR ) ; while ( lexer . has More Chars ( ) ) { char la = lexer . look Ahead ( _ NUM ) ; if ( la == _ STR || la == _ STR || la == _ STR || la == _ STR || la == _ STR ) break ; lexer . consume ( _ NUM ) ; retval . append ( la ) ; } return retval . to String ( ) ; }
public static void slide In From Bottom Animator ( @  Non Null  List <  Animator > animators , @  Non Null  View view ,  Recycler View recycler View ) { alpha Animator ( animators , view , _ NUM ) ; animators . add (  Object Animator . of Float ( view , _ STR , recycler View . get Measured Height ( ) > > _ NUM , _ NUM ) ) ; if (  Flexible Adapter .  DEBUG )  Log . v (  TAG , _ STR ) ; }
private static  Big Integer value Of ( int val [ ] ) { return ( val [ _ NUM ] > _ NUM ? new  Big Integer ( val , _ NUM ) : new  Big Integer ( val ) ) ; }
@  Request Mapping ( value = _ STR ) public void slo Error (  Locale locale , @  Path Variable ( value = _ STR )  String tenant ,  Http Servlet Response response ) throws  IOException { logger . info ( _ STR + locale . to String ( ) + _ STR + tenant ) ; slo Default Tenant Binding Error ( locale , response ) ; }
public  Schematic Reader (  NBTInput Stream input Stream ) { check Not Null ( input Stream ) ; this . input Stream = input Stream ; }
public  Commit Time Index ( final  IRaw Store store , final  Checkpoint checkpoint , final  Index Metadata metadata , boolean read Only ) { super ( store , checkpoint , metadata , read Only ) ; }
public boolean is Closed ( ) throws  SQLException { return this . is Closed ; }
private static void insert Value Using If Not Empty ( final  Map <  String ,  List <  String > > params Map , final  String param Val , final  String parameter Name ) { if (  String Utils . is Not Empty ( param Val ) ) {  List <  String > list = new  Array List < > ( ) ; list . add ( param Val ) ; params Map . put ( parameter Name , list ) ; } }
public  Dimension maximum Layout Size (  Container target ) {  Dimension size ; synchronized ( this ) { check Container ( target ) ; check Requests ( ) ; size = new  Dimension ( x Total . maximum , y Total . maximum ) ; }  Insets insets = target . get Insets ( ) ; size . width = ( int )  Math . min ( ( long ) size . width + ( long ) insets . left + ( long ) insets . right ,  Integer .  MAX_ VALUE ) ; size . height = ( int )  Math . min ( ( long ) size . height + ( long ) insets . top + ( long ) insets . bottom ,  Integer .  MAX_ VALUE ) ; return size ; }
public  Fixed Parameter ( double param ) { this . param = param ; }
private boolean select Item ( int position ) { dis Miss Or Update Popup Window ( ) ; if ( position >= _ NUM && m Cache Data List . size ( ) > position ) { set Text ( m Cache Data List . get ( position ) ) ; return _ BOOL ; } return _ BOOL ; }
public static void substitute Properties (  Node node ,  Properties properties ) {  Node child ;  Node next = node . get First Child ( ) ; while ( ( child = next ) != null ) { next = child . get Next Sibling ( ) ; if ( child . get Node Type ( ) ==  Node .  TEXT_ NODE ) { child . set Node Value (  Properties Util . substitute Property ( child . get Node Value ( ) , properties ) ) ; } else if ( child . get Node Type ( ) ==  Node .  ELEMENT_ NODE ) {  Named Node Map attributes = child . get Attributes ( ) ; for ( int i = _ NUM ; i < attributes . get Length ( ) ; i ++ ) {  Node attribute = attributes . item ( i ) ; attribute . set Node Value (  Properties Util . substitute Property ( attribute . get Node Value ( ) , properties ) ) ; } substitute Properties ( child , properties ) ; } } }
public  Text Editor ( ) { this ( _ BOOL ) ; }
public boolean add (  Solution solution ) { return data . add ( solution ) ; }
static long read Millis (  Data Input in ) throws  IOException { int v = in . read Unsigned Byte ( ) ; switch ( v > > _ NUM ) { case _ NUM : default : v = ( v << ( _ NUM - _ NUM ) ) > > ( _ NUM - _ NUM ) ; return v * ( _ NUM * _ NUM ) ; case _ NUM : v = ( v << ( _ NUM - _ NUM ) ) > > ( _ NUM - _ NUM ) ; v |= ( in . read Unsigned Byte ( ) ) << _ NUM ; v |= ( in . read Unsigned Byte ( ) ) << _ NUM ; v |= ( in . read Unsigned Byte ( ) ) ; return v * _ NUM ; case _ NUM : long w = ( ( ( long ) v ) << ( _ NUM - _ NUM ) ) > > ( _ NUM - _ NUM ) ; w |= ( in . read Unsigned Byte ( ) ) << _ NUM ; w |= ( in . read Unsigned Byte ( ) ) << _ NUM ; w |= ( in . read Unsigned Byte ( ) ) << _ NUM ; w |= ( in . read Unsigned Byte ( ) ) ; return w * _ NUM ; case _ NUM : return in . read Long ( ) ; } }
public void add Notification (  Notification notification ) { notification Vector . add Element ( notification ) ; }
public static  Object [ ] [ ] form Object Array ( double [ ] [ ] data ) {  Object [ ] [ ] object = new  Double [ data . length ] [ data [ _ NUM ] . length ] ; for ( int i = _ NUM ; i < object . length ; i ++ ) { for ( int j = _ NUM ; j < object [ i ] . length ; j ++ ) { object [ i ] [ j ] = new  Double ( data [ i ] [ j ] ) ; } } return object ; }
public grammaticality Estimator (  Set  File Names , int i Min Char , int i Max Char , int i Min Word , int i Max Word , int i Neighbourhood Window ) { i Min Char NGram = i Min Char ; i Max Char NGram = i Max Char ; i Min Word NGram = i Min Word ; i Max Word NGram = i Max Word ;  Distro Docs = new  Tree Map <  Integer ,  Distribution Document > ( ) ;  Distro Word Docs = new  Tree Map <  Integer ,  Distribution Word Document > ( ) ;  String Buffer sb = new  String Buffer ( ) ;  Iterator i Texts =  File Names . iterator ( ) ; while ( i Texts . has Next ( ) ) {  String s File = (  String ) i Texts . next ( ) ; try {  Buffered Reader bf = new  Buffered Reader ( new  File Reader ( s File ) ) ;  String s Tmp ; while ( ( s Tmp = bf . read Line ( ) ) != null ) sb . append ( s Tmp ) ; bf . close ( ) ; } catch (  File Not Found Exception ex ) { ex . print Stack Trace (  System . err ) ; } catch (  IOException ex ) { ex . print Stack Trace (  System . err ) ; } sb . append ( ( char ) _ NUM ) ; }  Full Text Data String = sb . to String ( ) ; for ( int i Cnt = i Min Char NGram ; i Cnt <= i Max Char NGram ; i Cnt ++ ) {  Distro Docs . put ( i Cnt , new  Distribution Document ( i Neighbourhood Window , i Cnt ) ) ; } for ( int i Cnt = i Min Word NGram ; i Cnt <= i Max Word NGram ; i Cnt ++ ) {  Distro Word Docs . put ( i Cnt , new  Distribution Word Document ( i Neighbourhood Window , i Cnt ) ) ; } }
public final static int skip Spaces ( final  String in , final int start ) { int pos = start ; while ( pos < in . length ( ) && ( in . char At ( pos ) == _ STR || in . char At ( pos ) == _ STR ) ) { pos ++ ; } return pos < in . length ( ) ? pos : - _ NUM ; }
public static double mean ( double [ ] data , int opt ) { if ( opt == _ NUM ) { int num Data = _ NUM ; double mean = _ NUM ; for ( int i = _ NUM ; i < data . length ; i ++ ) { if ( !  Double . is Na N ( data [ i ] ) ) { mean += data [ i ] ; num Data ++ ; } } mean /= num Data ; return mean ; } else { int num Data = _ NUM ; double mean = _ NUM ; for ( int i = _ NUM ; i < data . length ; i ++ ) { if ( !  Double . is Na N ( data [ i ] ) ) { mean +=  Math . log ( data [ i ] ) ; num Data ++ ; } } mean = mean / num Data ; return  Math . exp ( mean ) ; } }
private void draw Mouse World Axis ( ) {  Vector3 v = cursor World Position ; if ( !  Float . is Na N ( v . x + v . y + v . z ) ) { shape Renderer . begin ( ) ; shape Renderer . line ( v . x , v . y , v . z , v . x + _ NUM , v . y , v . z ,  Color .  RED ,  Color .  RED ) ; shape Renderer . line ( v . x , v . y , v . z , v . x , v . y + _ NUM , v . z ,  Color .  GREEN ,  Color .  GREEN ) ; shape Renderer . line ( v . x , v . y , v . z , v . x , v . y , v . z + _ NUM ,  Color .  BLUE ,  Color .  BLUE ) ; shape Renderer . end ( ) ; } }
public void add Connection Listener (  Connection Listener l ) { m_ Connection Listeners . add ( l ) ; }
public  Percentiles percentiles (  Constant Range range ) {  Sorted Set <  Constant > sorted = values ( ) ;  Sorted Set <  Constant > contained = new  Tree Set <  Constant > ( ) ;  Constant prev = null ; for (  Constant pct : sorted ) { if ( range . contains ( pct ) ) { contained . add ( pct ) ; } else if ( contained . is Empty ( ) ) prev = pct ; } if ( contained . is Empty ( ) ) return null ; double prev Percent = prev == null ? _ NUM : pcts . get ( prev ) ; double total Percent = pcts . get ( contained . last ( ) ) - prev Percent ;  Map <  Constant ,  Double > new Pcts = new  Hash Map <  Constant ,  Double > ( ) ; for (  Constant p : contained ) new Pcts . put ( p , ( pcts . get ( p ) - prev Percent ) / total Percent ) ; return new  Percentiles ( new Pcts ) ; }
private static void close Safe (  Closeable closeable ) { if ( closeable != null ) { try { closeable . close ( ) ; } catch (  IOException ignored ) { } } }
public void validate ( ) { if ( pc < _ NUM || pc >= instructions . size ( ) ) { pc = _ NUM ; } }
public static byte [ ] duplicate ( final byte [ ] src ) { final byte [ ] result = new byte [ src . length ] ;  System . arraycopy ( src , _ NUM , result , _ NUM , src . length ) ; return result ; }
protected void add Class Pathes ( final  Groovy Class Loader class Loader ) { if ( classpath != null ) { for ( int i = _ NUM ; i < classpath . list ( ) . length ; i ++ ) { class Loader . add Classpath ( classpath . list ( ) [ i ] ) ; } } }
@  Override public boolean equals ( final  Object o ) { if ( this == o ) return _ BOOL ; if ( ! ( o instanceof  Header ) ) { return _ BOOL ; } return name . equals ( ( (  Header ) o ) . name ) ; }
public final static  Name Value Pair [ ] parse Parameters ( final  String value ,  Header Value Parser parser ) throws  Parse Exception { if ( value == null ) { throw new  Illegal Argument Exception ( _ STR ) ; } if ( parser == null ) parser =  Save Header Value Parser .  DEFAULT ;  Char Array Buffer buffer = new  Char Array Buffer ( value . length ( ) ) ; buffer . append ( value ) ;  Save Parser Cursor cursor = new  Save Parser Cursor ( _ NUM , value . length ( ) ) ; return parser . parse Parameters ( buffer , cursor ) ; }
private static int  Dist (  PCal Location loc A ,  PCal Location loc B ) { return _ NUM *  Math . abs ( loc A . get Line ( ) - loc B . get Line ( ) ) +  Math . abs ( loc A . get Column ( ) - loc B . get Column ( ) ) ; }
private void close Writer (  Writer writer ) { if ( writer != null ) { try { writer . close ( ) ; } catch (  IOException e ) { log . error ( e ) ; } } }
public static boolean is Domain Or Sub Domain (  String domain Name ,  List <  String > domain Names ) { if (  Collection Utils . is Empty ( domain Names ) ) { return _ BOOL ; } for (  String domain To Check : domain Names ) { if ( domain Name . equals ( domain To Check ) || ( domain Name . ends With ( domain To Check ) && domain Name . ends With ( _ STR + domain To Check ) ) ) { return _ BOOL ; } } return _ BOOL ; }
public  Document create Document ( ) { return builder . new Document ( ) ; }
private void split Current Label (  Label alternate Successor ,  List <  Label > catch Labels ) {  Label new Label = new  Label ( ) ; adopt ( new Label ) ; current Label . primary Successor = new Label ; current Label . alternate Successor = alternate Successor ; current Label . catch Labels = catch Labels ; current Label = new Label ; current Label . marked = _ BOOL ; }
public  Exception Entry (  Throwable exception ) { super ( ) ; this . exception = exception ; this . message =  String Utils . abbreviate ( exception . get Message ( ) ,  MAX_ MESSAGE_ LENGTH ) ; }
private void read Object ( final  Object Input Stream in ) throws  IOException ,  Class Not Found Exception { in . default Read Object ( ) ; init ( ) ; }
private void paint Foreground Pressed (  Graphics2 D g , int width , int height ) {  Shape s = decode Arrow Path ( width , height ) ; g . set Paint ( pressed Color ) ; g . fill ( s ) ; }
public  Key Change (  String new Key Data ,  DSAPublic Key change Key , boolean allows Unsigned Changes , boolean allows Public Visibility , byte [ ] msg , byte [ ] sig , long epoch , long counter ) { this . new Key Data = new Key Data ; this . new Change Key = change Key ; this . allows Unsigned Changes = allows Unsigned Changes ; this . allows Public Visibility = allows Public Visibility ; this . msg = msg == null ? null :  Arrays . copy Of ( msg , msg . length ) ; this . sig = sig == null ? null :  Arrays . copy Of ( sig , sig . length ) ; this . epoch = epoch ; this . counter = counter ;  Logging . log ( _ STR +  Arrays . to String ( this . sig ) ) ; }
public boolean is Menu Popup ( ) { return menu Popup ; }
private boolean take Task ( ) { int size = tasks . size ( ) ; for ( int i = first Pending ; i < size ; i ++ ) {  Task t = tasks . get ( i ) ; if ( ! run After ( t , i ) ) { if ( i > first Pending ) { tasks . remove ( i ) ; tasks . add ( first Pending , t ) ; } first Pending ++ ; task = t ; return _ BOOL ; } } return _ BOOL ; }
public  String to String ( boolean header ) {  String Buffer temp = new  String Buffer ( ) ; if ( m_canopies == null ) { return _ STR ; } if ( header ) { temp . append ( _ STR ) ; temp . append ( _ STR + m_canopies . num Instances ( ) ) ; } temp . append ( _ STR +  String . format ( _ STR , m_t2 ) ) ; temp . append ( _ STR +  String . format ( _ STR , m_t1 ) ) ; temp . append ( _ STR ) ; temp . append ( print Canopy Assignments ( m_canopies , m_cluster Canopies ) ) ; temp . append ( _ STR ) ; return temp . to String ( ) ; }
private static void check Package Access (  Class type ) {  Security Manager sm =  System . get Security Manager ( ) ; if ( sm != null ) {  String name = type . get Name ( ) ; int i = name . last Index Of ( _ STR ) ; if ( i != - _ NUM ) { sm . check Package Access ( name . substring ( _ NUM , i ) ) ; } } }
Rules (  Workspace workspace ) { this . root = workspace . get Root ( ) ; this . team Hook = workspace . get Team Hook ( ) ; workspace . add Lifecycle Listener ( this ) ; }
public void clear ( ) { synchronized ( lock ) { if ( items == null ) { return ; } items . clear ( ) ; } if ( notify On Change ) { notify Data Set Changed ( ) ; } }
public void show Status (  String msg ) { if ( ( msg == null ) || msg . is Empty ( ) ) msg = _ STR ; m_ Label Text . set Text ( msg ) ; }
protected int parse And Add Node (  Xml Resource Parser parser ,  Hash Map <  String ,  Tag Parser > tag Parser Map ,  Array List <  Long > screen Ids ) throws  Xml Pull Parser Exception ,  IOException { if (  TAG_ INCLUDE . equals ( parser . get Name ( ) ) ) { final int res Id = get Attribute Resource Value ( parser ,  ATTR_ WORKSPACE , _ NUM ) ; if ( res Id != _ NUM ) { return parse Layout ( res Id , screen Ids ) ; } else { return _ NUM ; } } m Values . clear ( ) ; parse Container And Screen ( parser , m Temp ) ; final long container = m Temp [ _ NUM ] ; final long screen Id = m Temp [ _ NUM ] ; m Values . put (  Launcher Settings .  Favorites .  CONTAINER , container ) ; m Values . put (  Launcher Settings .  Favorites .  SCREEN , screen Id ) ; m Values . put (  Launcher Settings .  Favorites .  CELLX , get Attribute Value ( parser ,  ATTR_ X ) ) ; m Values . put (  Launcher Settings .  Favorites .  CELLY , get Attribute Value ( parser ,  ATTR_ Y ) ) ;  Tag Parser tag Parser = tag Parser Map . get ( parser . get Name ( ) ) ; if ( tag Parser == null ) { if (  LOGD )  Log . d (  TAG , _ STR + parser . get Name ( ) ) ; return _ NUM ; } long new Element Id = tag Parser . parse And Add ( parser ) ; if ( new Element Id >= _ NUM ) { if ( ! screen Ids . contains ( screen Id ) && container ==  Launcher Settings .  Favorites .  CONTAINER_ DESKTOP ) { screen Ids . add ( screen Id ) ; } return _ NUM ; } return _ NUM ; }
boolean skip Object ( ) throws  IOException { int ch = read ( ) ; int len ; switch ( ch ) { case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : skip ( ch - _ NUM ) ; return _ BOOL ; case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : skip ( ch - _ NUM ) ; return _ BOOL ; case _ NUM : case _ NUM : case _ NUM : case _ NUM : len = _ NUM * ( ch - _ NUM ) + read ( ) ; skip ( len ) ; return _ BOOL ; case _ NUM : case _ NUM : case _ NUM : case _ NUM : len = _ NUM * ( ch - _ NUM ) + read ( ) ; skip ( len ) ; return _ BOOL ; case _ NUM : case _ NUM : case _ NUM : case _ NUM : skip ( _ NUM ) ; return _ BOOL ; case _ NUM : len = read Short ( ) ; skip ( len ) ; return skip Object ( ) ; case _ NUM : len = read Short ( ) ; skip ( len ) ; return _ BOOL ; case _ NUM : scan Object Def ( ) ; return skip Object ( ) ; case _ NUM : skip ( _ NUM ) ; return _ BOOL ; case _ NUM : throw new  Illegal State Exception ( _ STR ) ; case _ NUM : return _ BOOL ; case _ NUM : skip Object ( ) ; skip Object ( ) ; return _ BOOL ; case _ NUM : { skip Map ( ) ; return _ BOOL ; } case _ NUM : skip ( _ NUM ) ; return _ BOOL ; case _ NUM : skip ( _ NUM ) ; return _ BOOL ; case _ NUM : skip ( _ NUM ) ; return _ BOOL ; case _ NUM : skip ( _ NUM ) ; return _ BOOL ; case _ NUM : { skip Object ( ) ; skip Map ( ) ; return _ BOOL ; } case _ NUM : return _ BOOL ; case _ NUM : { int type = scan Int ( ) ;  String [ ] def = _class Defs . get ( type ) ; len = def . length - _ NUM ; for ( int i = _ NUM ; i < len ; i ++ ) { skip Object ( ) ; } return _ BOOL ; } case _ NUM : skip Object ( ) ; skip Object ( ) ; return _ BOOL ; case _ NUM : skip Object ( ) ; return _ BOOL ; case _ NUM : len = read Short ( ) ; skip ( len ) ; return skip Object ( ) ; case _ NUM : len = read Short ( ) ; skip ( len ) ; return _ BOOL ; case _ NUM : return _ BOOL ; case _ NUM : read Type ( ) ; while ( skip Object ( ) ) { } return _ BOOL ; case _ NUM : read Type ( ) ; len = scan Int ( ) ; for ( int i = _ NUM ; i < len ; i ++ ) { skip Object ( ) ; } return _ BOOL ; case _ NUM : while ( skip Object ( ) ) { } return _ BOOL ; case _ NUM : len = scan Int ( ) ; for ( int i = _ NUM ; i < len ; i ++ ) { skip Object ( ) ; } return _ BOOL ; case _ NUM : skip ( _ NUM ) ; return _ BOOL ; case _ NUM : return _ BOOL ; case _ NUM : case _ NUM : return _ BOOL ; case _ NUM : skip ( _ NUM ) ; return _ BOOL ; case _ NUM : skip ( _ NUM ) ; return _ BOOL ; case _ NUM : return skip Object ( ) ; case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : { int type = ch - _ NUM ;  String [ ] def = _class Defs . get ( type ) ; len = def . length - _ NUM ; for ( int i = _ NUM ; i < len ; i ++ ) { skip Object ( ) ; } return _ BOOL ; } case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : skip Object ( ) ; len = ch - _ NUM ; for ( int i = _ NUM ; i < len ; i ++ ) { skip Object ( ) ; } return _ BOOL ; case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : len = ch - _ NUM ; for ( int i = _ NUM ; i < len ; i ++ ) { skip Object ( ) ; } return _ BOOL ; case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : return _ BOOL ; case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : skip ( _ NUM ) ; return _ BOOL ; case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : skip ( _ NUM ) ; return _ BOOL ; case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : return _ BOOL ; case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : skip ( _ NUM ) ; return _ BOOL ; default : throw new  Unsupported Operation Exception ( _ STR +  Integer . to Hex String ( ch ) ) ; } }
public void test Scalar Arrays ( ) throws  Exception {  Object Mapper m = new  Object Mapper ( ) ; m . enable Default Typing (  Object Mapper .  Default Typing .  JAVA_ LANG_ OBJECT ) ;  Object [ ] input = new  Object [ ] { _ STR , new  Date ( _ NUM ) , null ,  Integer . value Of ( _ NUM ) } ;  String json = m . write Value As String ( input ) ; assert Equals ( _ STR , json ) ;  Object [ ] output = m . read Value ( json ,  Object [ ] . class ) ; assert Array Equals ( input , output ) ; }
public boolean is Expired (  Repository Proxy Cache proxy Cache ) { long method Cache Time = proxy Cache . get Cache Time ( ) ; boolean unlimited Cache = method Cache Time <= _ NUM ;  File cache File = build File ( proxy Cache . get Cache Dir ( ) , proxy Cache . get File Name ( ) ,  DEFAULT_ FILE_ NAME ) ; if ( is Cached ( cache File ) ) { if ( unlimited Cache ) { return _ BOOL ; } long last Modified Time = file Manager . get Last Modified Time ( cache File ) ; boolean expired =  System . current Time Millis ( ) > ( last Modified Time + method Cache Time ) ; if ( expired ) { evict ( proxy Cache ) ; } return expired ; } return _ BOOL ; }
void add ( final  Profile profile ) { profiles . remove ( profile ) ; profiles . add ( profile ) ; }
public synchronized void open Write ( ) throws  Replicator Exception ,  Interrupted Exception { if ( ! file . exists ( ) ) { throw new  THLException ( _ STR + file . get Name ( ) ) ; } try {  Buffered File Data Input bfdi = new  Buffered File Data Input ( file , buffer Size ) ; check File Header ( bfdi ) ; bfdi . close ( ) ; data Output = new  Buffered File Data Output ( file , buffer Size ) ; } catch (  IOException e ) { throw new  THLException ( _ STR + file . get Name ( ) , e ) ; } mode =  Access Mode . write ; if ( log Flush Task != null ) log Flush Task . add Log File ( this ) ; }
public float maximum Absolute ( ) { if (  Math . abs ( m Left ) >  Math . abs ( m Right ) ) { return  Math . abs ( m Left ) ; } else { return  Math . abs ( m Right ) ; } }
private double determine Alpha Max ( int n , double [ ] alpha_max ,  Hyper Bounding Box interval ) { double alpha_n = extremum_alpha_n ( n , alpha_max ) ; double lower = interval . get Min ( n ) ; double upper = interval . get Max ( n ) ; double [ ] alpha_extreme = new double [ alpha_max . length ] ;  System . arraycopy ( alpha_max , n , alpha_extreme , n , alpha_extreme . length - n ) ; alpha_extreme [ n ] = alpha_n ;  Extremum Type type = extremum Type ( n , alpha_extreme , interval ) ; if ( type . equals (  Extremum Type .  MINIMUM ) || type . equals (  Extremum Type .  CONSTANT ) ) { if ( lower <= alpha_n && alpha_n <= upper ) { if ( alpha_n - lower <= upper - alpha_n ) { return upper ; } else { return lower ; } } else if ( alpha_n < lower ) { return upper ; } else { if ( alpha_n <= upper ) { throw new  Illegal State Exception ( _ STR ) ; } return lower ; } } else { if ( lower <= alpha_n && alpha_n <= upper ) { return alpha_n ; } else if ( alpha_n < lower ) { return lower ; } else { if ( alpha_n <= upper ) { throw new  Illegal State Exception ( _ STR ) ; } return upper ; } } }
public static  String map2 OID (  String alg Name ) { check Cache Version ( ) ;  String result = alg2 Oid Map . get ( alg Name . to Upper Case (  Locale .  US ) ) ; if ( result != null ) { return result ; }  Alg Name Mapper Source s = source ; if ( s != null ) { return s . map Name To Oid ( alg Name ) ; } return null ; }
@  Override public  Generator <  IMulti Point > construct (  String [ ] args ) { return new  Uniform Generator (  Integer . value Of ( args [ _ NUM ] ) ,  Double . value Of ( args [ _ NUM ] ) ) ; }
protected void process Mouse Motion Event (  Mouse Event e ) { boolean dispatch = _ BOOL ; if ( autoscrolls && e . get ID ( ) ==  Mouse Event .  MOUSE_ DRAGGED ) { dispatch = !  Autoscroller . is Running ( this ) ;  Autoscroller . process Mouse Dragged ( e ) ; } if ( dispatch ) { super . process Mouse Motion Event ( e ) ; } }
protected int wait For ( int counter ) { if ( counter > _ NUM ) -- counter ; else if ( counter > _ NUM ) { -- counter ;  Thread . yield ( ) ; } else {  Lock Support . park Nanos ( _ NUM ) ; } return counter ; }
@  Override public double [ ] distribution For Instance (  Instance instance ) throws  Exception { instance = (  Instance ) instance . copy ( ) ; instance . set Dataset ( m_numeric Data Header ) ; return probs ( get Fs ( instance ) ) ; }
@  Override public void on Bind View Holder (  K holder , int position ) { holder . bind Item ( items . get ( position ) ) ; }
private void modify Selected Line ( ) { if ( lines List . get Selected Indices ( ) . length > _ NUM ) { return ; }  Axis Parallel Line Configuration line = lines List . get Selected Value ( ) ; if ( line != null ) { if ( modify Line Dialog == null ) { modify Line Dialog = new  Edit Parallel Line Dialog ( ) ; } modify Line Dialog . set Line ( line , _ BOOL ) ; modify Line Dialog . show Dialog ( ) ; } }
public void filled Rectangle ( double x , double y , double half Width , double half Height ) { if ( half Width < _ NUM ) throw new  Illegal Argument Exception ( _ STR ) ; if ( half Height < _ NUM ) throw new  Illegal Argument Exception ( _ STR ) ; double xs = scale X ( x ) ; double ys = scale Y ( y ) ; double ws = factor X ( _ NUM * half Width ) ; double hs = factor Y ( _ NUM * half Height ) ; if ( ws <= _ NUM && hs <= _ NUM ) pixel ( x , y ) ; else offscreen . fill ( new  Rectangle2 D .  Double ( xs - ws / _ NUM , ys - hs / _ NUM , ws , hs ) ) ; draw ( ) ; }
public void prepend Split Element (  Fragment a Split ) { splits . add ( _ NUM , a Split ) ; }
private void start Item List Item (  String Builder result ,  String root Id ,  String item Id ) { result . append ( _ STR ) ; result . append ( _ STR + item Id + _ STR + root Id + _ STR + item Id + _ STR ) ; }
public int num Records ( ) { return super . num Records ( ) ; }
@  Override public void mouse Clicked (  Mouse Event e ) { if ( mouse Clicked Listener != null && e . get Click Count ( ) == _ NUM && ! e . is Alt Down ( ) && ! e . is Alt Graph Down ( ) ) { mouse Clicked Listener . mouse Clicked ( ) ; } }
List <  File > add Collection Files (  File new Basedir ) throws  IOException { final  Directory Scanner ds = new  Directory Scanner ( ) ; ds . set Basedir ( new Basedir ) ; if ( this . includes != null && this . includes . length > _ NUM ) { ds . set Includes ( this . includes ) ; } else { ds . set Includes (  DEFAULT_ INCLUDES ) ; } ds . set Excludes ( this . excludes ) ; ds . add Default Excludes ( ) ; ds . set Case Sensitive ( _ BOOL ) ; ds . set Follow Symlinks ( _ BOOL ) ; ds . scan ( ) ;  List <  File > found Files = new  Array List < > ( ) ; for (  String filename : ds . get Included Files ( ) ) { found Files . add ( new  File ( new Basedir , filename ) ) ; } return found Files ; }
public int size ( ) { return m Selected Widgets . size ( ) ; }
public  String normalize Uri (  String uri ) { if ( uri != null && ! uri . ends With ( _ STR ) ) { uri += _ STR ; } return uri ; }
public boolean to Boolean (  Element el ,  String attribute Name ) { return  Caster . to Boolean Value ( el . get Attribute ( attribute Name ) , _ BOOL ) ; }
private static boolean is Appropriate Property Name For Getter ( @  Not Null  Psi Method getter , @  Not Null  String imported Name For Getter , @  Not Null  String property Name ) { property Name =  Groovy Property Utils . decapitalize ( property Name ) ; return property Name . equals ( get Property Name By Getter ( getter , imported Name For Getter ) ) ; }
public void close ( ) { for (  Entry entry : entry List ) { entry . close ( ) ; } entry List . clear ( ) ; }
public  String search ( ) throws  Exception { execute Query ( ) ; return  SUCCESS ; }
public boolean meta URI ( ) { return endpoint != null && ( endpoint . index Of ( _ STR ) != - _ NUM || endpoint . ends With ( _ STR ) || endpoint . index Of ( _ STR ) != - _ NUM ) ; }
@  Suppress Warnings ( _ STR ) public static void register (  String algorithm URI ,  String implementing Class ) throws  Algorithm Already Registered Exception ,  Class Not Found Exception ,  XMLSignature Exception {  Java Utils . check Register Permission ( ) ; if ( log . is Loggable ( java . util . logging .  Level .  FINE ) ) { log . log ( java . util . logging .  Level .  FINE , _ STR + algorithm URI + _ STR + implementing Class ) ; }  Class < ? extends  Signature Algorithm Spi > registered Class = algorithm Hash . get ( algorithm URI ) ; if ( registered Class != null ) {  Object ex Args [ ] = { algorithm URI , registered Class } ; throw new  Algorithm Already Registered Exception ( _ STR , ex Args ) ; } try {  Class < ? extends  Signature Algorithm Spi > clazz = (  Class < ? extends  Signature Algorithm Spi > )  Class Loader Utils . load Class ( implementing Class ,  Signature Algorithm . class ) ; algorithm Hash . put ( algorithm URI , clazz ) ; } catch (  Null Pointer Exception ex ) {  Object ex Args [ ] = { algorithm URI , ex . get Message ( ) } ; throw new  XMLSignature Exception ( _ STR , ex Args , ex ) ; } }
public void load (  Path settings Path ) { m Loading Settings = _ BOOL ; if (  Files . exists ( settings Path ) ) { m Log . info ( _ STR + settings Path . to String ( ) + _ STR ) ;  JAXBContext context = null ;  Input Stream in = null ; try { in = new  File Input Stream ( settings Path . to String ( ) ) ; try { context =  JAXBContext . new Instance (  Settings . class ) ;  Unmarshaller m = context . create Unmarshaller ( ) ; m Settings = (  Settings ) m . unmarshal ( in ) ; } catch (  JAXBException e ) { m Log . error ( _ STR + _ STR , e ) ; } } catch (  Exception e ) { m Log . error ( _ STR + _ STR + settings Path . to String ( ) + _ STR , e ) ; } finally { if ( in != null ) { try { in . close ( ) ; } catch (  IOException e ) { m Log . error ( _ STR + _ STR , e ) ; } } } } else { m Log . info ( _ STR + settings Path . to String ( ) + _ STR ) ; } if ( m Settings == null ) { m Settings = new  Settings ( ) ; } load Tuner Configuration Model ( ) ; m Loading Settings = _ BOOL ; }
public boolean contains Explicit Char ( final @  Non Null  Char Sequence input ) { if ( !  Text Utils . is Empty ( input ) ) { for ( int i = _ NUM ; i < input . length ( ) ; i ++ ) { char c = input . char At ( i ) ; if ( is Explicit Char ( c ) ) { return _ BOOL ; } } } return _ BOOL ; }
private void check Collapses ( ) { for (  Iterator i = seg Strings . iterator ( ) ; i . has Next ( ) ; ) {  Segment String ss = (  Segment String ) i . next ( ) ; check Collapses ( ss ) ; } }
private <  T >  Unary Operator <  T > chain Operators (  Stream <  Unary Operator <  T > > operators ) { return operators . reduce (  Unary Operator . identity ( ) , null ) ; }
public void add Attribute Spec (  String spec ) {  Attribute Spec new Spec = new  Attribute Spec ( spec ) ; m_attribute Specs . add ( new Spec ) ; }
public static  String convert To Java Class Name (  String name ) { int dot Index = name . index Of ( _ STR ) ; if ( dot Index >= _ NUM ) { name = name . substring ( _ NUM , dot Index ) ; }  String [ ] split = name . split ( _ STR ) ;  String Builder out = new  String Builder ( ) ; for (  String section : split ) { out . append (  String Util . capitalize ( section ) ) ; } return out . to String ( ) ; }
public final boolean delete (  String where ) {  SQLite Database execute = get Writer ( ) ;  String sql = _ STR + get Table Name ( ) + _ STR + where ; try { execute . exec SQL ( sql ) ; return _ BOOL ; } catch (  SQLException e ) { return _ BOOL ; } finally { close Writer ( execute ) ; } }
public boolean is Done ( ) { return _is Done . get ( ) ; }
private void create Migration Group Page ( ) {  Migration Group Editor migration Group Editor = new  Migration Group Editor ( migration Task , get Container ( ) , this ) ; int index = add Page ( migration Group Editor . get Control ( ) ) ; set Page Text ( index , _ STR ) ; task Listeners . add ( migration Group Editor ) ; }
private  String next (  Pattern pattern ) throws  Decode Exception {  Matcher matcher = pattern . matcher ( gser Value . substring ( pos , length ) ) ; if ( matcher . find ( ) && matcher . group Count ( ) >= _ NUM ) { pos += matcher . end ( _ NUM ) ; return matcher . group ( _ NUM ) ; } else { final  Localizable Message msg =  WARN_ GSER_ PATTERN_ NO_ MATCH . get ( pattern . pattern ( ) , gser Value . substring ( pos , length ) ) ; throw  Decode Exception . error ( msg ) ; } }
private void throw Ex Int Param (  Method Visitor mv ,  Class < ? > ex Cls ) {  String ex Sig =  Type . get Internal Name ( ex Cls ) ; mv . visit Type Insn (  NEW , ex Sig ) ; mv . visit Insn (  DUP ) ; mv . visit Ldc Insn ( _ STR + this . class Name + _ STR ) ; mv . visit Var Insn (  ILOAD , _ NUM ) ; mv . visit Method Insn (  INVOKESTATIC , _ STR , _ STR , _ STR ) ; mv . visit Method Insn (  INVOKEVIRTUAL , _ STR , _ STR , _ STR ) ; mv . visit Method Insn (  INVOKESPECIAL , ex Sig , _ STR , _ STR ) ; mv . visit Insn (  ATHROW ) ; }
public  String attributes Tip Text ( ) { return _ STR + _ STR + _ STR + _ STR + _ STR + _ STR ; }
public void add ( int position ,  T item ) { items . add ( position , item ) ; notify Item Inserted ( position ) ; }
public  List <  String > split String With Default Delimiter (  String input String ) {  List <  String > split String = new  Array List < > ( ) ; if ( input String != null ) {  String Tokenizer string Tokenizer = new  String Tokenizer ( input String , configuration Helper . get Property (  Configuration Value .  FIELD_ DATA_ DELIMITER ) ) ; while ( string Tokenizer . has More Elements ( ) ) { split String . add ( string Tokenizer . next Token ( ) ) ; } } return split String ; }
protected final boolean read Available Non Blocking ( ) throws  IOException { char [ ] buffer = my Buffer ;  String Builder token = my Text Buffer ; token . set Length ( _ NUM ) ; boolean read = _ BOOL ; while ( my Reader . ready ( ) ) { int n = my Reader . read ( buffer ) ; if ( n <= _ NUM ) break ; read = _ BOOL ; process Line ( buffer , token , n ) ; } submit Token ( ) ; return read ; }
public  Obligation Policy Database Entry add Parameter Deletes Obligation Database Entry (  XMethod xmethod ,  Obligation obligation ,  Obligation Policy Database Entry Type entry Type ) {  Obligation Policy Database Entry entry = new  Match Method Entry ( xmethod ,  Obligation Policy Database Action Type .  DEL , entry Type , obligation ) ; add Entry ( entry ) ; return entry ; }
private static  Content Impl parse Content (  Ole Blob Impl blob ) throws  IOException {  Byte Buffer bb =  Page Channel . wrap ( blob . get Bytes ( ) ) ; if ( ( bb . remaining ( ) < _ NUM ) || ( bb . get Short ( ) !=  PACKAGE_ SIGNATURE ) ) { return new  Unknown Content Impl ( blob ) ; } int header Size = bb . get Short ( ) ; bb . get Int ( ) ; int pretty Name Len = bb . get Short ( ) ; int class Name Len = bb . get Short ( ) ; int pretty Name Off = bb . get Short ( ) ; int class Name Off = bb . get Short ( ) ; bb . get Int ( ) ;  String pretty Name = read Str ( bb , pretty Name Off , pretty Name Len ) ;  String class Name = read Str ( bb , class Name Off , class Name Len ) ; bb . position ( header Size ) ; int ole Ver = bb . get Int ( ) ; bb . get Int ( ) ; if ( ole Ver !=  OLE_ VERSION ) { return new  Unknown Content Impl ( blob ) ; } int type Name Len = bb . get Int ( ) ;  String type Name = read Str ( bb , bb . position ( ) , type Name Len ) ; bb . get Long ( ) ; int data Block Len = bb . get Int ( ) ; int data Block Pos = bb . position ( ) ; if (  SIMPLE_ PACKAGE_ TYPE . equals Ignore Case ( type Name ) ) { return create Simple Package Content ( blob , pretty Name , class Name , type Name , bb , data Block Len ) ; } if ( (  COMPOUND_ FACTORY != null ) && ( bb . remaining ( ) >=  COMPOUND_ STORAGE_ SIGNATURE . length ) &&  Byte Util . matches Range ( bb , bb . position ( ) ,  COMPOUND_ STORAGE_ SIGNATURE ) ) { return  COMPOUND_ FACTORY . create Compound Package Content ( blob , pretty Name , class Name , type Name , bb , data Block Len ) ; } return new  Other Content Impl ( blob , pretty Name , class Name , type Name , data Block Pos , data Block Len ) ; }
public static void pack ( int [ ] n ,  String s ) { for ( int i = _ NUM ; i < n . length ; i ++ ) { n [ i ] = _ NUM ; } int idx = n . length - _ NUM ; for ( int i = s . length ( ) - _ NUM ; i >= _ NUM ; i -- ) { n [ idx -- ] = s . char At ( i ) - _ STR ; } }
protected boolean has Result (  Map <  String ,  String > results ,  String result ) { if ( results != null ) { for (  String str : results . values ( ) ) { if ( str . starts With ( result ) ) { return _ BOOL ; } } } return _ BOOL ; }
private  Number parse Int (  String value ) {  Long l =  Long . value Of ( value ) ; if ( l . int Value ( ) == l ) { return l . int Value ( ) ; } return l ; }
public  Statement in (  Object ... values ) { statement . append ( _ STR ) ; for ( int i = _ NUM ; i < values . length ; i ++ ) { if ( i > _ NUM ) statement . append ( _ STR ) ; append ( values [ i ] ) ; } statement . append ( _ STR ) ; return this ; }
public  Data Buffer ( final byte [ ] buffer , final int offset , final int length ) { byte Buffer =  Byte Buffer . wrap ( buffer ) ; byte Buffer . order (  Byte Order .  LITTLE_ ENDIAN ) ; byte Buffer . position ( offset ) ; }
public static long firsttick (  Geo Time Serie gts ) { if ( is Bucketized ( gts ) ) { return gts . lastbucket - ( gts . bucketcount - _ NUM ) * gts . bucketspan ; } else { long firsttick =  Long .  MAX_ VALUE ; if ( gts . sorted && gts . values > _ NUM ) { if ( ! gts . reversed ) { firsttick = gts . ticks [ _ NUM ] ; } else { firsttick = gts . ticks [ gts . values - _ NUM ] ; } } else { for ( int i = _ NUM ; i < gts . values ; i ++ ) { if ( gts . ticks [ i ] < firsttick ) { firsttick = gts . ticks [ i ] ; } } } return firsttick ; } }
@  Override public boolean has Property (  String field Name ,  String value ) {  String [ ] fields = doc . get Values ( field Name ) ; if ( fields != null ) { for (  String field : fields ) { if ( value . equals ( field ) ) { return _ BOOL ; } } } return _ BOOL ; }
public static <  T >  Completion Stage <  T > dereference (  Completion Stage < ? extends  Completion Stage <  T > > stage ) { return stage . then Compose (  Function . identity ( ) ) ; }
public void prepare ( ) throws  Replicator Exception ,  Interrupted Exception { }
public void test Pos Neg First Shorter ( ) { byte a Bytes [ ] = { - _ NUM , - _ NUM , - _ NUM , - _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM } ; byte b Bytes [ ] = { - _ NUM , _ NUM , _ NUM , _ NUM , - _ NUM , - _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , - _ NUM , _ NUM , _ NUM , - _ NUM , _ NUM , _ NUM , - _ NUM , - _ NUM } ; int a Sign = _ NUM ; int b Sign = - _ NUM ; byte r Bytes [ ] = { _ NUM , - _ NUM , - _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM } ;  Big Integer a Number = new  Big Integer ( a Sign , a Bytes ) ;  Big Integer b Number = new  Big Integer ( b Sign , b Bytes ) ;  Big Integer result = a Number . and ( b Number ) ; byte res Bytes [ ] = new byte [ r Bytes . length ] ; res Bytes = result . to Byte Array ( ) ; for ( int i = _ NUM ; i < res Bytes . length ; i ++ ) { assert True ( res Bytes [ i ] == r Bytes [ i ] ) ; } assert Equals ( _ STR , _ NUM , result . signum ( ) ) ; }
public  Stream Status Writer (  String path ,  Twitch Api api ) { this . path = path ; this . api = api ; }
public static  Sentence new Conjunction (  Sentence ... conjuncts ) { return new Conjunction (  Arrays . as List ( conjuncts ) ) ; }
public boolean is Name ( ) { return type String . contains (  SUFFIX_ NAME ) ; }
protected void append Byte Type (  String Builder sb ,  Field Type field Type , int field Width ) { sb . append ( _ STR ) ; }
public static  Vector tokenize String (  String source , char separator ) {  Vector tokenized = new  Vector ( ) ; int len = source . length ( ) ; boolean last Separator = _ BOOL ;  String Builder buf = new  String Builder ( ) ; for ( int iter = _ NUM ; iter < len ; iter ++ ) { char current = source . char At ( iter ) ; if ( current == separator ) { if ( last Separator ) { buf . append ( separator ) ; last Separator = _ BOOL ; continue ; } last Separator = _ BOOL ; if ( buf . length ( ) > _ NUM ) { tokenized . add Element ( buf . to String ( ) ) ; buf = new  String Builder ( ) ; } } else { last Separator = _ BOOL ; buf . append ( current ) ; } } if ( buf . length ( ) > _ NUM ) { tokenized . add Element ( buf . to String ( ) ) ; } return tokenized ; }
private void backup Favorites (  Backup Data Output data ) throws  IOException {  Content Resolver cr = m Context . get Content Resolver ( ) ;  Cursor cursor = cr . query (  Favorites .  CONTENT_ URI ,  FAVORITE_ PROJECTION , get User Selection Arg ( ) , null , null ) ; try { cursor . move To Position ( - _ NUM ) ; while ( cursor . move To Next ( ) ) { final long id = cursor . get Long (  ID_ INDEX ) ; final long update Time = cursor . get Long (  ID_ MODIFIED ) ;  Key key = get Key (  Key .  FAVORITE , id ) ; m Keys . add ( key ) ; final  String backup Key = key To Backup Key ( key ) ; if ( ! m Existing Keys . contains ( backup Key ) || update Time >= m Last Backup Restore Time || restored Backup Version < _ NUM ) { write Row To Backup ( key , pack Favorite ( cursor ) , data ) ; } else { if (  DEBUG )  Log . d (  TAG , _ STR + id ) ; } } } finally { cursor . close ( ) ; } }
public void add Elapsed Time From ( long start Time ) { add (  System . nano Time ( ) - start Time ) ; }
public void add Instance Field (  Encoded Field field ) { if ( field == null ) { throw new  Null Pointer Exception ( _ STR ) ; } instance Fields . add ( field ) ; }
private static void create Key Store ( ) throws  Key Store Exception ,  IOException { if ( s Key Store != null ) { return ; } try { s Key Store =  Key Store . get Instance ( get Keystore Type ( ) ) ; synchronized (  Key Store Manager . class ) { s Key Store . load ( null ,  KEYSTORE_ PASSWORD . to Char Array ( ) ) ; } save Key Store To File ( s Key Store ) ; } catch (  No Such Algorithm Exception e ) { throw new  Key Store Exception ( _ STR , e ) ; } catch (  Certificate Exception e ) { throw new  Key Store Exception ( _ STR , e ) ; } }
public  Repeat Iterator ( @  Not Null  List <  T > master ) { this . master = master ; this . source = master . iterator ( ) ; }
public static double normalize ( double value ) throws  Illegal Argument Exception { if ( value < _ NUM ) { throw new  Illegal Argument Exception ( _ STR ) ; } if (  Double . is Infinite ( value ) ) { return _ NUM ; } return value / ( _ NUM + value ) ; }
public static  List <  String > split (  String str ,  String delim ) {  List <  String > split List = null ;  String Tokenizer st = null ; if ( str == null ) return split List ; if ( delim != null ) st = new  String Tokenizer ( str , delim ) ; else st = new  String Tokenizer ( str ) ; if ( st != null && st . has More Tokens ( ) ) { split List = new  Linked List <  String > ( ) ; while ( st . has More Tokens ( ) ) split List . add ( st . next Token ( ) ) ; } return split List ; }
protected void add Space ( ) { add ( new  JLabel ( _ STR ) ) ; }
public void hide GUI ( ) { if ( frame != null ) { frame . set Visible ( _ BOOL ) ; } }
public static  Mosaic Definition create Mosaic Definition ( final  Account creator , final  Mosaic Levy levy ) { return create Mosaic Definition ( creator ,  Utils . create Mosaic Id ( _ STR , _ STR ) , create Mosaic Properties ( ) , levy ) ; }
static int exec Sql (  SQLite Database db ,  String label ,  String final Sql ,  Object [ ] arg Array ) throws  SQLException { try { db . exec SQL ( final Sql , arg Array ) ; } catch ( android . database .  SQLException e ) { throw  Sql Exception Util . create ( _ STR + label + _ STR + final Sql , e ) ; } int result ;  SQLite Statement stmt = null ; try { stmt = db . compile Statement ( _ STR ) ; result = ( int ) stmt . simple Query For Long ( ) ; } catch ( android . database .  SQLException e ) { result = _ NUM ; } finally { if ( stmt != null ) { stmt . close ( ) ; } } logger . trace ( _ STR , label , result , final Sql ) ; return result ; }
private static  SSLContext create Easy SSLContext ( ) {  SSLContext context ; try { context =  SSLContext . get Instance ( _ STR ) ; context . init ( null , _trust Managers , new  Secure Random ( ) ) ;  Https URLConnection . set Default SSLSocket Factory ( context . get Socket Factory ( ) ) ; } catch ( final  General Security Exception gse ) { throw new  Illegal State Exception ( gse . get Message ( ) ) ; } return context ; }
protected void add (  Object component ) { if ( component == null ) { return ; } components . add ( component ) ; }
public  Configure Hash Collision Dialog_ NB (  Hash Collision hash Collision ) { this . hash Collision = hash Collision ; init Components ( ) ; cb DJBX31 A . add Change Listener ( cb Change Listener ) ; cb DJBX33 A . add Change Listener ( cb Change Listener ) ; cb DJBX33 X . add Change Listener ( cb Change Listener ) ; cb Ruby . add Change Listener ( cb Change Listener ) ; cb True . add Change Listener ( cb Change Listener ) ; cb False . add Change Listener ( cb Change Listener ) ; final  Collision Interface [ ] collision Generators = hash Collision . get Collision Generators ( ) ; for (  Collision Interface collision : collision Generators ) { if ( collision instanceof  Collision DJBX31 A ) { cb DJBX31 A . set Selected ( _ BOOL ) ; } if ( collision instanceof  Collision DJBX33 A ) { cb DJBX33 A . set Selected ( _ BOOL ) ; } if ( collision instanceof  Collision DJBX33 X ) { cb DJBX33 X . set Selected ( _ BOOL ) ; } if ( collision instanceof  Collision DJBX ) { cb Ruby . set Selected ( _ BOOL ) ; } } final  Boolean [ ] use Namespace = hash Collision . get Use Namespace ( ) ; for (  Boolean b : use Namespace ) { if ( b ) { cb True . set Selected ( _ BOOL ) ; } if ( ! b ) { cb False . set Selected ( _ BOOL ) ; } } final  Iterate Model number Of Attributes Iterator = hash Collision . get Number Of Collisions Iterator ( ) ; configure Iterate Model_ NB2 . set Start At (  String . value Of ( number Of Attributes Iterator . get Start At ( ) ) ) ; configure Iterate Model_ NB2 . set Stop At (  String . value Of ( number Of Attributes Iterator . get Stop At ( ) ) ) ; configure Iterate Model_ NB2 . set Increment (  String . value Of ( number Of Attributes Iterator . get Increment ( ) ) ) ; configure Iterate Model_ NB2 . set Iterate Strategie ( number Of Attributes Iterator . get Iterate Strategie ( ) ) ; }
public static long run Multi Threaded (  Callable < ? > call , int thread Num ,  String thread Name ) throws  Exception {  List <  Callable < ? > > calls =  Collections . <  Callable < ? > > n Copies ( thread Num , call ) ; return run Multi Threaded ( calls , thread Name ) ; }
private void bcopy ( int cidx , int bidx ) { int length = m Ch Idx - cidx ; if ( ( bidx + length + _ NUM ) >= m Buff . length ) { char buff [ ] = new char [ m Buff . length + length ] ;  System . arraycopy ( m Buff , _ NUM , buff , _ NUM , m Buff . length ) ; m Buff = buff ; }  System . arraycopy ( m Chars , cidx , m Buff , bidx , length ) ; m Buff Idx += length ; }
protected  Charset Provider ( ) {  Security Manager sm =  System . get Security Manager ( ) ; if ( sm != null ) sm . check Permission ( new  Runtime Permission ( _ STR ) ) ; }
public  Node remove (  Coordinate pt ) { return (  Node ) node Map . remove ( pt ) ; }
public long time ( ) { return  System . current Time Millis ( ) ; }
public static void unset Value (  Project project ,  Virtual File root ,  String key ) throws  Vcs Exception {  Git Simple Handler h = new  Git Simple Handler ( project , root ,  Git Command .  CONFIG ) ; h . set Silent ( _ BOOL ) ; h . ignore Error Code ( _ NUM ) ; h . add Parameters ( _ STR , key ) ; h . run ( ) ; }
public int compute (  String line ) { this . line = line ; int count = _ NUM ; if ( attempt First Word ) { int a = _ NUM ; while ( a < line . length ( ) ) { if ( line . char At ( a ) == _ STR ||  Character . is Whitespace ( line . char At ( a ) ) ) a ++ ; else break ; } int b = a + _ NUM ; while ( b < line . length ( ) ) { int ch = line . char At ( b ) ; if (  Character . is Letter Or Digit ( ch ) || ch == _ STR || ch == _ STR ) b ++ ; else break ; } if ( b - a > _ NUM ) { pairs [ count ] [ _ NUM ] = a ; pairs [ count ++ ] [ _ NUM ] = b ; } } if ( id Tags . length > _ NUM ) { for (  String tag : id Tags ) { int b ; for ( int a = line . index Of ( tag ) ; a != - _ NUM ; a = line . index Of ( tag , b + _ NUM ) ) { a += tag . length ( ) ; b = a + _ NUM ; while ( b < line . length ( ) && (  Character . is Letter Or Digit ( line . char At ( b ) ) || line . char At ( b ) == _ STR ) ) b ++ ; if ( b > a ) { if ( count == pairs . length ) pairs =  Multi Words . grow ( pairs ) ; pairs [ count ] [ _ NUM ] = a ; pairs [ count ++ ] [ _ NUM ] = b ; } } } } return count ; }
private void toggle Remove Selection (  Tree Path path ) {  Stack <  Tree Path > stack = new  Stack <  Tree Path > ( ) ;  Tree Path parent = path . get Parent Path ( ) ; while ( parent != null && ! is Path Selected ( parent ) ) { stack . push ( parent ) ; parent = parent . get Parent Path ( ) ; } if ( parent != null ) stack . push ( parent ) ; else { super . remove Selection Paths ( new  Tree Path [ ] { path } ) ; return ; } while ( ! stack . is Empty ( ) ) {  Tree Path temp = (  Tree Path ) stack . pop ( ) ;  Tree Path peek Path = stack . is Empty ( ) ? path : (  Tree Path ) stack . peek ( ) ;  Object node = temp . get Last Path Component ( ) ;  Object peek Node = peek Path . get Last Path Component ( ) ; int child Count = model . get Child Count ( node ) ; for ( int i = _ NUM ; i < child Count ; i ++ ) {  Object child Node = model . get Child ( node , i ) ; if ( child Node != peek Node ) {  Tree Path path By Adding Child = temp . path By Adding Child ( child Node ) ; super . add Selection Paths ( new  Tree Path [ ] { path By Adding Child } ) ; } } } super . remove Selection Paths ( new  Tree Path [ ] { parent } ) ; }
public boolean can Read ( ) { return file . can Read ( ) ; }
public  T remove ( int position ) {  T removed = items . remove ( position ) ; notify Item Removed ( position ) ; return removed ; }
public double standard Deviation ( ) { return  Math . sqrt ( variance ( ) ) ; }
private static void split All Live Ranges (  Instruction s , java . util .  Hash Map <  Register ,  Register > new Map ,  IR ir , boolean root Only ) { for (  Enumeration <  Operand > u = root Only ? s . get Root Uses ( ) : s . get Uses ( ) ; u . has More Elements ( ) ; ) {  Operand use = u . next Element ( ) ; if ( use . is Register ( ) ) {  Register Operand r Use = use . as Register ( ) ;  Register Operand temp = find Or Create Temp ( r Use , new Map , ir ) ; insert Move Before ( temp , r Use . copy RO ( ) , s ) ; } } for (  Enumeration <  Operand > d = s . get Defs ( ) ; d . has More Elements ( ) ; ) {  Operand def = d . next Element ( ) ; if ( def . is Register ( ) ) {  Register Operand r Def = def . as Register ( ) ;  Register Operand temp = find Or Create Temp ( r Def , new Map , ir ) ; insert Move After ( r Def . copy RO ( ) , temp , s ) ; } } for (  Enumeration <  Operand > ops = root Only ? s . get Root Operands ( ) : s . get Operands ( ) ; ops . has More Elements ( ) ; ) {  Operand op = ops . next Element ( ) ; if ( op . is Register ( ) ) {  Register Operand r Op = op . as Register ( ) ;  Register r = r Op . get Register ( ) ;  Register new R = new Map . get ( r ) ; if ( new R != null ) { r Op . set Register ( new R ) ; } } } }
public void fire Annotation Misc Changed (  Workflow Annotation anno ) {  List <  Workflow Annotation > list = new  Linked List < > ( ) ; list . add ( anno ) ; fire Annotations Changed (  Annotation Event .  MISC_ CHANGED , list ) ; }
public boolean update Stats And Return Whether Allowed ( ) { long now =  System Clock . elapsed Realtime ( ) ; long delta Ms = now - m Last Request Ms ; if ( delta Ms < m Delay Ms ) return _ BOOL ; m Last Request Ms = now ; if ( delta Ms < _ NUM * m Delay Ms ) { m Delay Ms =  Math . min (  MAX_ DELAY , m Delay Ms * _ NUM ) ; } else { m Delay Ms =  MIN_ DELAY ; } return _ BOOL ; }
public  Big Integer calculate Client Evidence Message ( ) throws  Crypto Exception { if ( ( this .  A == null ) || ( this .  B == null ) || ( this .  S == null ) ) { throw new  Crypto Exception ( _ STR + _ STR ) ; } this .  M1 =  SRP6 Util . calculate M1 ( digest ,  N ,  A ,  B ,  S ) ; return  M1 ; }
public boolean handle Keyword (  String keyword ) {  String item ; boolean ignore Group If Unknown Keyword Save = ignore Group If Unknown Keyword ; if ( skipping Characters > _ NUM ) { skipping Characters -- ; return _ BOOL ; } ignore Group If Unknown Keyword = _ BOOL ; if ( ( item = text Keywords . get ( keyword ) ) != null ) { handle Text ( item ) ; return _ BOOL ; } if ( keyword . equals ( _ STR ) ) { set RTFDestination ( new  Fonttbl Destination ( ) ) ; return _ BOOL ; } if ( keyword . equals ( _ STR ) ) { set RTFDestination ( new  Colortbl Destination ( ) ) ; return _ BOOL ; } if ( keyword . equals ( _ STR ) ) { set RTFDestination ( new  Stylesheet Destination ( ) ) ; return _ BOOL ; } if ( keyword . equals ( _ STR ) ) { set RTFDestination ( new  Info Destination ( ) ) ; return _ BOOL ; } if ( keyword . equals ( _ STR ) ) { set Character Set ( _ STR ) ; return _ BOOL ; } if ( keyword . equals ( _ STR ) ) { if ( use Ne XTFor Ansi ) set Character Set ( _ STR ) ; else set Character Set ( _ STR ) ; return _ BOOL ; } if ( keyword . equals ( _ STR ) ) { set Character Set ( _ STR ) ; return _ BOOL ; } if ( keyword . equals ( _ STR ) ) { set Character Set ( _ STR ) ; return _ BOOL ; } if ( keyword . equals ( _ STR ) ) { set Character Set ( _ STR ) ; return _ BOOL ; } if ( keyword . equals ( _ STR ) ) { ignore Group If Unknown Keyword = _ BOOL ; return _ BOOL ; } if ( rtf Destination != null ) { if ( rtf Destination . handle Keyword ( keyword ) ) return _ BOOL ; } if ( keyword . equals ( _ STR ) || keyword . equals ( _ STR ) || keyword . equals ( _ STR ) || keyword . equals ( _ STR ) || keyword . equals ( _ STR ) || keyword . equals ( _ STR ) || keyword . equals ( _ STR ) || keyword . equals ( _ STR ) || keyword . equals ( _ STR ) || keyword . equals ( _ STR ) || keyword . equals ( _ STR ) || keyword . equals ( _ STR ) || keyword . equals ( _ STR ) || keyword . equals ( _ STR ) || keyword . equals ( _ STR ) || keyword . equals ( _ STR ) || keyword . equals ( _ STR ) || keyword . equals ( _ STR ) || keyword . equals ( _ STR ) || keyword . equals ( _ STR ) || keyword . equals ( _ STR ) || keyword . equals ( _ STR ) || keyword . equals ( _ STR ) || keyword . equals ( _ STR ) || keyword . equals ( _ STR ) || keyword . equals ( _ STR ) || keyword . equals ( _ STR ) || keyword . equals ( _ STR ) || keyword . equals ( _ STR ) || keyword . equals ( _ STR ) || keyword . equals ( _ STR ) || keyword . equals ( _ STR ) || keyword . equals ( _ STR ) || keyword . equals ( _ STR ) || keyword . equals ( _ STR ) || keyword . equals ( _ STR ) || keyword . equals ( _ STR ) || keyword . equals ( _ STR ) || keyword . equals ( _ STR ) || keyword . equals ( _ STR ) || keyword . equals ( _ STR ) || keyword . equals ( _ STR ) || keyword . equals ( _ STR ) || keyword . equals ( _ STR ) || keyword . equals ( _ STR ) || keyword . equals ( _ STR ) || keyword . equals ( _ STR ) || keyword . equals ( _ STR ) || keyword . equals ( _ STR ) ) { ignore Group If Unknown Keyword Save = _ BOOL ; } if ( ignore Group If Unknown Keyword Save ) { set RTFDestination ( new  Discarding Destination ( ) ) ; } return _ BOOL ; }
protected void notify Modified ( ) { if ( update Counter . get ( ) > _ NUM ) { return ; } if ( modified ) { update Version ( ) ; last Modified =  System . current Time Millis ( ) ; } if ( modified && storage != null ) { if ( ! storage . save ( this ) ) { log . error ( _ STR ) ; } } send Updates ( ) ; modified = _ BOOL ; }
private static boolean is Valueless Attribute (  String attrib Name ) { boolean valueless =  VALUELESS_ ATTRIB_ NAMES . contains (  Strings . lower ( attrib Name ) ) ; return valueless ; }
public  Input Builder <  T > emit (  T record ) { if ( record == null ) { throw new  Illegal Argument Exception ( _ STR ) ; } input . add ( record ) ; return this ; }
public  Object invoke (  Object proxy ,  Method method ,  Object [ ] args ) throws  Throwable { return invoke ( proxy , new  Standard Method ( method ) , args ) ; }
public void test Zero Pos ( ) { byte a Bytes [ ] = { _ NUM } ; byte b Bytes [ ] = { - _ NUM , - _ NUM , - _ NUM , - _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM } ; int a Sign = _ NUM ; int b Sign = _ NUM ; byte r Bytes [ ] = { _ NUM , - _ NUM , - _ NUM , - _ NUM , - _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM } ;  Big Integer a Number = new  Big Integer ( a Sign , a Bytes ) ;  Big Integer b Number = new  Big Integer ( b Sign , b Bytes ) ;  Big Integer result = a Number . or ( b Number ) ; byte res Bytes [ ] = new byte [ r Bytes . length ] ; res Bytes = result . to Byte Array ( ) ; for ( int i = _ NUM ; i < res Bytes . length ; i ++ ) { assert True ( res Bytes [ i ] == r Bytes [ i ] ) ; } assert Equals ( _ STR , _ NUM , result . signum ( ) ) ; }
public  Metadata .  Builder clear ( ) {  Metadata_ Builder _defaults = new  Metadata .  Builder ( ) ; type = _defaults . type ; interface Type = _defaults . interface Type ; optional Builder = _defaults . optional Builder ; builder Factory = _defaults . builder Factory ; generated Builder = _defaults . generated Builder ; value Type = _defaults . value Type ; partial Type = _defaults . partial Type ; visible Nested Types . clear ( ) ; property Enum = _defaults . property Enum ; properties . clear ( ) ; standard Method Underrides . clear ( ) ; builder Serializable = _defaults . builder Serializable ; generated Builder Annotations . clear ( ) ; value Type Annotations . clear ( ) ; value Type Visibility = _defaults . value Type Visibility ; nested Classes . clear ( ) ; _unset Properties . clear ( ) ; _unset Properties . add All ( _defaults . _unset Properties ) ; return (  Metadata .  Builder ) this ; }
public float distance ( vec3 b ) { float x = this . m [ _ NUM ] - b . m [ _ NUM ] ; float y = this . m [ _ NUM ] - b . m [ _ NUM ] ; float z = this . m [ _ NUM ] - b . m [ _ NUM ] ; float result = ( float )  Math . sqrt ( x * x + y * y + z * z ) ; return result ; }
public void make Backup File (  String name ) {  File file = find File ( name ) ; if ( file == null ) { log . info ( _ STR + name + _ STR ) ; } else if ( file . can Write ( ) ) {  String backup Name = backup File Name ( file . get Absolute Path ( ) ) ;  File backup File = find File ( backup Name ) ; if ( backup File != null ) { if ( backup File . delete ( ) ) { log . debug ( _ STR + backup Name ) ; } } if ( file . rename To ( new  File ( backup Name ) ) ) { log . debug ( _ STR + backup Name ) ; } else { log . error ( _ STR + backup Name ) ; } } }
public static  String escape (  String string ) { char c ;  String s = string . trim ( ) ;  String Builder sb = new  String Builder ( ) ; int len = s . length ( ) ; for ( int i = _ NUM ; i < len ; i += _ NUM ) { c = s . char At ( i ) ; if ( c < _ STR || c == _ STR || c == _ STR || c == _ STR || c == _ STR ) { sb . append ( _ STR ) ; sb . append (  Character . for Digit ( ( char ) ( ( c > > > _ NUM ) & _ NUM ) , _ NUM ) ) ; sb . append (  Character . for Digit ( ( char ) ( c & _ NUM ) , _ NUM ) ) ; } else { sb . append ( c ) ; } } return sb . to String ( ) ; }
public static void assert Equals Ignore Newline (  String expected ,  String received ) {  String expected Clean = remove Newline ( expected ) ;  String received Clean = remove Newline ( received ) ; if ( ! expected Clean . equals ( received Clean ) ) { log . error ( _ STR + expected Clean ) ; log . error ( _ STR + received Clean ) ;  Scope Test Helper . assert Equals ( _ STR , expected , received ) ; } }
public int size ( ) { return set . size ( ) ; }
public  String to Upper Case ( ) { return to Upper Case (  Locale . get Default ( ) ) ; }
public static  Node [ ] to Node Array (  Document doc ,  Object o ) throws  Page Exception { if ( o instanceof  Node ) return new  Node [ ] { (  Node ) o } ; if ( o instanceof  Node [ ] ) { return (  Node [ ] ) o ; } else if ( o instanceof  Collection ) {  Collection coll = (  Collection ) o ;  Iterator <  Object > it = coll . value Iterator ( ) ;  List <  Node > nodes = new  Array List <  Node > ( ) ; while ( it . has Next ( ) ) { nodes . add ( to Node ( doc , it . next ( ) , _ BOOL ) ) ; } return nodes . to Array ( new  Node [ nodes . size ( ) ] ) ; }  Node [ ] nodes = _to Node Array ( doc , o ) ; if ( nodes != null ) return nodes ; try { return new  Node [ ] { to Node ( doc , o , _ BOOL ) } ; } catch (  Expression Exception e ) { throw new  XMLException ( _ STR +  Caster . to Class Name ( o ) + _ STR ) ; } }
protected void check Lock ( ) {  Reentrant Lock lock =  Bridge . get Lock ( ) ; if ( lock . is Held By Current Thread ( ) == _ BOOL ) { throw new  Illegal State Exception ( _ STR ) ; } if ( s Current Context != m Context ) { throw new  Illegal State Exception ( _ STR ) ; } }
private boolean is Empty (  String text ) { return text == null || text . length ( ) == _ NUM ; }
public void clear Drop Item List ( ) { drops Items = new  Array List <  Drop Item > ( ) ; drop Item Instances . clear ( ) ; }
public static <  E extends  Identifiable >  E find By Primary Key (  Entity Manager em ,  Big Integer id ,  Class <  E > type ) { require Argument ( em != null , _ STR ) ; require Argument ( id != null && id . compare To (  ZERO ) > _ NUM , _ STR ) ; require Argument ( type != null , _ STR ) ;  Typed Query <  E > query = em . create Named Query ( _ STR , type ) ; query . set Hint ( _ STR , _ STR ) ; try { query . set Parameter ( _ STR , id ) ; query . set Parameter ( _ STR , _ BOOL ) ; return query . get Single Result ( ) ; } catch (  No Result Exception ex ) { return null ; } }
private static int hash (  Object x ) { int h = x . hash Code ( ) ; return ( ( h << _ NUM ) - h + ( h > > > _ NUM ) + ( h > > > _ NUM ) ) ; }
public static boolean verify ( byte [ ] data , byte [ ] signature , byte [ ] pub ) throws  Assert Fail Exception {  Preconditions . check Argument ( data . length == _ NUM && signature . length <= _ NUM && pub . length <= _ NUM ) ;  Byte Buffer byte Buff = native ECDSABuffer . get ( ) ; if ( byte Buff == null || byte Buff . capacity ( ) < _ NUM ) { byte Buff =  Byte Buffer . allocate Direct ( _ NUM ) ; byte Buff . order (  Byte Order . native Order ( ) ) ; native ECDSABuffer . set ( byte Buff ) ; } byte Buff . rewind ( ) ; byte Buff . put ( data ) ; byte Buff . put ( signature ) ; byte Buff . put ( pub ) ; r . lock ( ) ; try { return secp256k1_ecdsa_verify ( byte Buff ,  Secp256k1 Context . get Context ( ) , signature . length , pub . length ) == _ NUM ; } finally { r . unlock ( ) ; } }
static public void assert Same Iteration Any Order ( final  Resource [ ] expected , final  Closeable Iteration < ? , ? extends  Exception > actual ) throws  Exception { assert Same Iteration Any Order ( _ STR , expected , actual ) ; }
protected void update Search Bar Text Opacity ( float percentage ) { float overlap Percentage = _ NUM ; float fading Out Percentage =  Math . max ( _ NUM - ( percentage / overlap Percentage ) , _ NUM ) ; float fading In Percentage =  Math . max ( percentage - ( _ NUM - overlap Percentage ) , _ NUM ) / overlap Percentage ; m Search Bar Context Opacity = fading Out Percentage ; m Search Bar Term Opacity = fading In Percentage ; }
private static  String apply RFC2732 (  String hostname ) { if ( hostname . index Of ( _ STR ) != - _ NUM ) { return _ STR + hostname + _ STR ; } return hostname ; }
private  String read Line Trim Comments (  Buffered Reader br ) throws  IOException {  String line = br . read Line ( ) ; if ( line != null ) { line = line . trim ( ) ; if ( line . index Of ( _ STR ) == _ NUM ) { line = _ STR ; } } return line ; }
private static  String add IDPPPrefix (  String expression ) { if ( expression == null || expression . length ( ) == _ NUM ) { return expression ; } if ( expression . index Of ( _ STR ) == - _ NUM ) { debug . error ( _ STR ) ; return expression ; }  String Buffer sb = new  String Buffer ( _ NUM ) ;  String Tokenizer st = new  String Tokenizer ( expression , _ STR ) ; while ( st . has More Tokens ( ) ) {  String temp = (  String ) st . next Token ( ) ;  String prefixed Str = _ STR + idpp Prefix + _ STR + temp ; sb . append ( prefixed Str ) ; } return sb . to String ( ) ; }
protected  N build Tree ( int [ ] msg , int cur , int parent ,  Array List <  N > nodes ) { int c = _ NUM ; for ( int i = _ NUM ; i < msg . length ; i += _ NUM ) { if ( msg [ i ] == cur && msg [ i + _ NUM ] != parent ) { c ++ ; } if ( msg [ i + _ NUM ] == cur && msg [ i ] != parent ) { c ++ ; } }  List <  N > children ; if ( c > _ NUM ) { children = new  Array List < > ( c ) ; } else { children =  Collections . empty List ( ) ; } for ( int i = _ NUM ; i < msg . length ; i += _ NUM ) { if ( msg [ i ] == cur && msg [ i + _ NUM ] != parent ) { c -- ; children . add ( build Tree ( msg , msg [ i + _ NUM ] , cur , nodes ) ) ; } if ( msg [ i + _ NUM ] == cur && msg [ i ] != parent ) { c -- ; children . add ( build Tree ( msg , msg [ i ] , cur , nodes ) ) ; } } assert ( c == _ NUM ) ;  N node = make Node ( cur , children ) ; nodes . set ( cur , node ) ; return node ; }
public static  String to Bits ( final long x ) { final  String Builder sb = new  String Builder ( ) ; long t = x ; boolean first = _ BOOL ; for ( int i = _ NUM ; i < _ NUM ; i ++ ) { if ( t < _ NUM ) { sb . append ( _ STR ) ; first = _ BOOL ; } else if ( first ) { sb . append ( _ STR ) ; } t = t << _ NUM ; } assert t == _ NUM ; return sb . to String ( ) ; }
public static  Result from Content (  String content ,  String format ) throws  Illegal Argument Exception { if ( content == null ) { throw new  Illegal Argument Exception ( _ STR ) ; } if ( format == null ) { throw new  Illegal Argument Exception ( _ STR ) ; } try { return from Content ( new  Input Stream Reader ( new  Byte Array Input Stream ( content . get Bytes ( _ STR ) ) , _ STR ) , format ) ; } catch (  IOException e ) { throw new  Illegal Argument Exception ( e . get Message ( ) ) ; } }
public  Topological Node ( int node ID ) { this . node ID = node ID ; node Name =  String . value Of ( node ID ) ; }
private void log Pose (  Tango Pose Data pose ) {  String Builder string Builder = new  String Builder ( ) ; float translation [ ] = pose . get Translation As Floats ( ) ; float orientation [ ] = pose . get Rotation As Floats ( ) ; string Builder . append (  String . format ( _ STR , translation [ _ NUM ] , translation [ _ NUM ] , translation [ _ NUM ] ) ) ; string Builder . append (  String . format ( _ STR , orientation [ _ NUM ] , orientation [ _ NUM ] , orientation [ _ NUM ] , orientation [ _ NUM ] ) ) ; log . call ( string Builder . to String ( ) ) ; }
public void lock UI (  Process Info pi ) { set Cursor (  Cursor . get Predefined Cursor (  Cursor .  WAIT_ CURSOR ) ) ; set Enabled ( _ BOOL ) ; }
public void add Event First (  Sim Event new Event ) { new Event . set Serial ( _ NUM ) ; sorted Set . add ( new Event ) ; }
public  String to String Summary ( ) {  String result ;  String titles ; int resultset Length ; int i ; int j ;  String content ; if ( m_ Non Sig Wins == null ) return _ STR ; result = _ STR ; titles = _ STR ; resultset Length = _ NUM +  Math . max ( ( int ) (  Math . log ( get Col Count ( ) ) /  Math . log ( _ NUM ) ) , ( int ) (  Math . log ( get Row Count ( ) ) /  Math . log ( _ NUM ) ) ) ; for ( i = _ NUM ; i < get Col Count ( ) ; i ++ ) { if ( get Col Hidden ( i ) ) continue ; titles += _ STR + get Summary Title ( i ) + _ STR ; } result += titles + _ STR ; for ( i = _ NUM ; i < get Col Count ( ) ; i ++ ) { if ( get Col Hidden ( i ) ) continue ; result += _ STR ; for ( j = _ NUM ; j < get Col Count ( ) ; j ++ ) { if ( get Col Hidden ( j ) ) continue ; if ( j == i ) content =  Utils . pad Left ( _ STR , resultset Length * _ NUM + _ NUM ) ; else content =  Utils . pad Left ( _ STR + m_ Non Sig Wins [ i ] [ j ] + _ STR + m_ Wins [ i ] [ j ] + _ STR , resultset Length * _ NUM + _ NUM ) ; result += _ STR + content . replace All ( _ STR , _ STR ) + _ STR ; } result += _ STR + get Summary Title ( i ) + _ STR + remove Filter Name ( m_ Col Names [ i ] ) + _ STR ; } result += _ STR ; return result ; }
public static  File make Temp Dir ( ) throws  IOException {  File temp =  File . create Temp File ( _ STR , null ) ; if ( ! temp . delete ( ) ) return null ; if ( ! temp . mkdir ( ) ) return null ; return temp ; }
public void hrule ( double value ,  Paint color ,  String legend ,  Basic Stroke stroke ) {  Legend Text legend Text = new  Legend Text ( color , legend ) ; comments . add ( legend Text ) ; plot Elements . add ( new  HRule ( value , color , legend Text , stroke ) ) ; }
public  State Interactive extent_to_whole_connected_sets ( ) {  Set <  Brd Item > new_selected_items = new  Tree Set <  Brd Item > ( ) ; for (  Brd Item curr_item : items_list ) { if ( curr_item instanceof  Brd Connectable ) { new_selected_items . add All ( curr_item . get_connected_set ( - _ NUM ) ) ; } } if ( new_selected_items . is Empty ( ) ) return return_state ; items_list = new_selected_items ; actlog_start_scope (  Logfile Scope .  EXTEND_ TO_ WHOLE_ CONNECTED_ SETS ) ; filter ( ) ; i_brd . repaint ( ) ; return this ; }
public  Collated Term Attribute Impl (  Collator collator ) { this . collator = (  Collator ) collator . clone ( ) ; }
public  Properties add Prefix (  Properties props ) {  Properties result = new  Properties ( ) ; for (  String name : props . string Property Names ( ) ) {  String val = props . get Property ( name ) ; name = add Prefix ( name ) ; result . set Property ( name , val ) ; } return result ; }
public void test Bug33734 ( ) throws  Exception {  Connection test Conn = get Connection With Props ( _ STR ) ; try { test Conn . prepare Statement ( _ STR ) ; } finally { test Conn . close ( ) ; } }
@  Override public void add Relations (  Task task ,  Iterable <  Object Id > project Ids ,  String field Name ) {  List <  Project > new Project List = new  Linked List < > ( ) ;  Iterable <  Project > projects To Add = project Repository . find All ( project Ids , null ) ; projects To Add . for Each ( null ) ; try { if (  Property Utils . get Property ( task , field Name ) != null ) {  Iterable <  Project > projects = (  Iterable <  Project > )  Property Utils . get Property ( task , field Name ) ; projects . for Each ( null ) ; } } catch (  Exception e ) { throw new  Runtime Exception ( e ) ; } try {  Property Utils . set Property ( task , field Name , new Project List ) ; } catch (  Exception e ) { throw new  Runtime Exception ( e ) ; } task Repository . save ( task ) ; }
private boolean check Board ( ) { for (  Nine Switches Game Switch game Switch : switches ) { if ( game Switch . get State ( ) == _ NUM ) { return _ BOOL ; } } return _ BOOL ; }
public void sleep ( long millis ) { try {  Thread . sleep ( millis ) ; } catch (  Interrupted Exception e ) { } }
public void test_concurrent_modification_update ( ) { final  BTree btree ; { btree =  BTree . create ( new  Simple Memory Raw Store ( ) , new  Index Metadata (  UUID . random UUID ( ) ) ) ; btree . insert ( _ NUM , _ STR ) ; btree . insert ( _ NUM , _ STR ) ; btree . insert ( _ NUM , _ STR ) ; } {  ITuple Cursor2 <  String > cursor = new Cursor ( btree ) ; assert Equals ( new  Test Tuple <  String > ( _ NUM , _ STR ) , cursor . seek ( _ NUM ) ) ; assert Equals ( new  Test Tuple <  String > ( _ NUM , _ STR ) , cursor . tuple ( ) ) ; btree . insert ( _ NUM , _ STR ) ; assert Equals ( new  Test Tuple <  String > ( _ NUM , _ STR ) , cursor . tuple ( ) ) ; } }
private static double round ( final double d ) { return ( ( int ) ( _ NUM * d ) ) / _ NUM ; }
public void mouse Released (  Mouse Event e ) { if ( log . is Debug Enabled ( ) ) { log . debug ( _ STR + ( e . get Modifiers ( ) &  Mouse Event .  BUTTON1_ MASK ) + _ STR + e . is Popup Trigger ( ) + _ STR + ( e . get Modifiers ( ) & (  Mouse Event .  ALT_ MASK +  Input Event .  META_ MASK +  Mouse Event .  CTRL_ MASK ) ) ) ; } if ( e . is Popup Trigger ( ) ) { try { _menu . show ( e . get Component ( ) , e . get X ( ) , e . get Y ( ) ) ; } catch ( java . awt .  Illegal Component State Exception cs ) { } e . consume ( ) ; } }
private static  String fmt ( double double Value ) { if ( double Value == ( long ) double Value ) { return  String . format ( _ STR , ( long ) double Value ) ; } else { return  String . format ( _ STR , double Value ) ; } }
public  Byte String Builder append Bytes ( final byte [ ] bytes , final int offset , final int length ) {  Byte String . check Array Bounds ( bytes , offset , length ) ; if ( length != _ NUM ) { ensure Additional Capacity ( length ) ;  System . arraycopy ( bytes , offset , buffer , this . length , length ) ; this . length += length ; } return this ; }
public void remove Rtcp Listener (  Rtcp Event Listener listener ) { listeners . remove Element ( listener ) ; }
@  Override protected void ensure Number Of Columns ( int number Of Columns ) { if ( data . length >= number Of Columns ) { return ; } int [ ] new Data = new int [ number Of Columns ] ;  System . arraycopy ( data , _ NUM , new Data , _ NUM , data . length ) ; data = new Data ; }
public void warning (  SAXParse Exception e ) throws  SAXException { add Validation Exception ( e ) ; }
public  Trace Logger ( final  ITrace List Provider trace Provider , final  IDebugger debugger ) { this . trace Provider =  Preconditions . check Not Null ( trace Provider , _ STR ) ; this . debugger =  Preconditions . check Not Null ( debugger , _ STR ) ; breakpoint Manager = debugger . get Breakpoint Manager ( ) ; }
@  Override public void close ( ) throws  IOException { if ( ! access . equals ( _ STR ) ) { if ( data Stream != null ) { data Stream . close ( ) ; data Stream = null ; } if ( output Stream != null ) { output Stream . close ( ) ; output Stream = null ; } } else if ( i Stream != null ) { i Stream . close ( ) ; } }
private  String create File Name ( ) {  String file Name = url . get Path ( ) ; if ( file Name . starts With ( _ STR ) ) { file Name = file Name . substring ( _ NUM ) ; } else if ( file Name . starts With ( _ STR ) ) { file Name = file Name . substring ( _ NUM ) ; } return file Name ; }
public static  Value parse Value (  String n Triples Value ,  Value Factory value Factory ) throws  Illegal Argument Exception { if ( n Triples Value . starts With ( _ STR ) ) { return parse URI ( n Triples Value , value Factory ) ; } else if ( n Triples Value . starts With ( _ STR ) ) { return parse BNode ( n Triples Value , value Factory ) ; } else if ( n Triples Value . starts With ( _ STR ) ) { return parse Literal ( n Triples Value , value Factory ) ; } else { throw new  Illegal Argument Exception ( _ STR + n Triples Value ) ; } }
public void reset Control Rolls ( ) { control Rolls . remove All Elements ( ) ; }
public static void sort ( int [ ] array ) {  Dual Pivot Quicksort . sort ( array ) ; }
synchronized void remove ( int id ) { for ( int i = _ NUM ; i < cache . size ( ) ; i ++ ) { if ( cache . get ( i ) == id ) { cache . remove ( i ) ; break ; } } }
private void stretch View Horizontally (  View view , int cross Size ) {  Layout Params lp = (  Layout Params ) view . get Layout Params ( ) ; int new Width = cross Size - lp . left Margin - lp . right Margin ; new Width =  Math . max ( new Width , _ NUM ) ; view . measure (  Measure Spec . make Measure Spec ( new Width ,  Measure Spec .  EXACTLY ) ,  Measure Spec . make Measure Spec ( view . get Measured Height ( ) ,  Measure Spec .  EXACTLY ) ) ; }
private  String read Node Address ( ) {  String addr = _ STR ; addr = (  String ) node Addr Field . get Selected Item ( ) ; if ( addr == null || addr . equals ( _ STR ) || addr . equals ( _ STR ) ) { addr = (  String ) node Addr64 Field . get Selected Item ( ) ; if ( addr == null ) throw new  Illegal Argument Exception ( _ STR ) ; } return ( addr ) ; }
public double read Double ( ) throws  IOException { return dis . read Double ( ) ; }
public void append Bar (  Bar Data bar ) { bar Vector . add ( bar ) ; }
static void check Method Desc ( final  String desc ) { if ( desc == null || desc . length ( ) == _ NUM ) { throw new  Illegal Argument Exception ( _ STR ) ; } if ( desc . char At ( _ NUM ) != _ STR || desc . length ( ) < _ NUM ) { throw new  Illegal Argument Exception ( _ STR + desc ) ; } int start = _ NUM ; if ( desc . char At ( start ) != _ STR ) { do { if ( desc . char At ( start ) == _ STR ) { throw new  Illegal Argument Exception ( _ STR + desc ) ; } start = check Desc ( desc , start , _ BOOL ) ; } while ( start < desc . length ( ) && desc . char At ( start ) != _ STR ) ; } start = check Desc ( desc , start + _ NUM , _ BOOL ) ; if ( start != desc . length ( ) ) { throw new  Illegal Argument Exception ( _ STR + desc ) ; } }
protected  Date compute ( double value ,  String locale String ) { if (  Double . is Na N ( value ) || locale String == null ) { return null ; }  Locale locale = new  Locale ( locale String ) ; long date Long = ( long ) value ;  Date date = new  Date ( date Long ) ;  Calendar cal =  Calendar . get Instance ( locale ) ; cal . set Time ( date ) ; return cal . get Time ( ) ; }
public void connect Pan (  Bluetooth Adapter adapter ,  Bluetooth Device device ) { connect Pan Or Incoming Pan Connection ( adapter , device , _ BOOL ) ; }
private  Cuboid (  String world Name , int x1 , int y1 , int z1 , int x2 , int y2 , int z2 ) { this . world Name = world Name ; this . x1 =  Math . min ( x1 , x2 ) ; this . x2 =  Math . max ( x1 , x2 ) ; this . y1 =  Math . min ( y1 , y2 ) ; this . y2 =  Math . max ( y1 , y2 ) ; this . z1 =  Math . min ( z1 , z2 ) ; this . z2 =  Math . max ( z1 , z2 ) ; }
private  Workflow .  Method create Meta Volumes Method (  URI system URI ,  URI pool URI ,  List <  URI > volume URIs ,  Virtual Pool Capability Values Wrapper capabilities ) { return new  Workflow .  Method ( _ STR , system URI , pool URI , volume URIs , capabilities ) ; }
public  String parameterize (  String command ,  Map <  String ,  String > parameters ) { for (  String key : parameters . key Set ( ) ) {  String value = parameters . get ( key ) ; command = command . replace ( key , value ) ; } return command ; }
public void next Page (  Gui Manual Herblore manual ) { if ( current Page + _ NUM <= visible Pages . size ( ) ) { set Page ( current Page + _ NUM , manual ) ; } }
public final double sample Active Count Max ( ) { return _active Count Max . get And Set ( _active Count . get ( ) ) ; }
public void handle (  Throwable throwable ,  Context context ,  Request request ,  Response response ) { if ( throwable . get Cause ( ) instanceof  OAuth2 Restlet Exception ) { final  OAuth2 Restlet Exception e = (  OAuth2 Restlet Exception ) throwable . get Cause ( ) ; handle ( e , context , request , response ) ; } else { final  Server Exception server Exception = new  Server Exception ( throwable ) ; final  OAuth2 Restlet Exception exception = new  OAuth2 Restlet Exception ( server Exception . get Status Code ( ) , server Exception . get Error ( ) , server Exception . get Message ( ) , null ) ; handle ( exception , context , request , response ) ; } }
public void test Missing Mission Name Handling ( ) {  String xml = _ STR ; xml += _ STR + _ STR ; xml += create End Mission Xml ( ) ;  Input Stream mission Input Stream = new  Byte Array Input Stream ( xml . get Bytes ( ) ) ; boolean did Mission Name Parse Fail = _ BOOL ; try {  Mission Parser . get Mission Name ( mission Input Stream ) ; } catch (  Mission Parse Exception e ) { did Mission Name Parse Fail = _ BOOL ; }  Assert . assert Equals ( _ BOOL , did Mission Name Parse Fail ) ; }
public long convert Geodetic To Transverse Mercator ( double  Latitude , double  Longitude ) { double c ; double c2 ; double c3 ; double c5 ; double c7 ; double dlam ; double eta ; double eta2 ; double eta3 ; double eta4 ; double s ; double sn ; double t ; double tan2 ; double tan3 ; double tan4 ; double tan5 ; double tan6 ; double t1 ; double t2 ; double t3 ; double t4 ; double t5 ; double t6 ; double t7 ; double t8 ; double t9 ; double tmd ; double tmdo ; long  Error_ Code =  TRANMERC_ NO_ ERROR ; double temp_ Origin ; double temp_ Long ; if ( (  Latitude < -  MAX_ LAT ) || (  Latitude >  MAX_ LAT ) ) {  Error_ Code |=  TRANMERC_ LAT_ ERROR ; } if (  Longitude >  PI )  Longitude -= ( _ NUM *  PI ) ; if ( (  Longitude < (  Tran Merc_ Origin_ Long -  MAX_ DELTA_ LONG ) ) || (  Longitude > (  Tran Merc_ Origin_ Long +  MAX_ DELTA_ LONG ) ) ) { if (  Longitude < _ NUM ) temp_ Long =  Longitude + _ NUM *  PI ; else temp_ Long =  Longitude ; if (  Tran Merc_ Origin_ Long < _ NUM ) temp_ Origin =  Tran Merc_ Origin_ Long + _ NUM *  PI ; else temp_ Origin =  Tran Merc_ Origin_ Long ; if ( ( temp_ Long < ( temp_ Origin -  MAX_ DELTA_ LONG ) ) || ( temp_ Long > ( temp_ Origin +  MAX_ DELTA_ LONG ) ) )  Error_ Code |=  TRANMERC_ LON_ ERROR ; } if (  Error_ Code ==  TRANMERC_ NO_ ERROR ) { dlam =  Longitude -  Tran Merc_ Origin_ Long ; if (  Math . abs ( dlam ) > ( _ NUM *  PI / _ NUM ) ) {  Error_ Code |=  TRANMERC_ LON_ WARNING ; } if ( dlam >  PI ) dlam -= ( _ NUM *  PI ) ; if ( dlam < -  PI ) dlam += ( _ NUM *  PI ) ; if (  Math . abs ( dlam ) < _ NUM ) dlam = _ NUM ; s =  Math . sin (  Latitude ) ; c =  Math . cos (  Latitude ) ; c2 = c * c ; c3 = c2 * c ; c5 = c3 * c2 ; c7 = c5 * c2 ; t =  Math . tan (  Latitude ) ; tan2 = t * t ; tan3 = tan2 * t ; tan4 = tan3 * t ; tan5 = tan4 * t ; tan6 = tan5 * t ; eta =  Tran Merc_ebs * c2 ; eta2 = eta * eta ; eta3 = eta2 * eta ; eta4 = eta3 * eta ; sn =  Tran Merc_a /  Math . sqrt ( _ NUM -  Tran Merc_es *  Math . pow (  Math . sin (  Latitude ) , _ NUM ) ) ; tmd =  Tran Merc_ap *  Latitude -  Tran Merc_bp *  Math . sin ( _ NUM *  Latitude ) +  Tran Merc_cp *  Math . sin ( _ NUM *  Latitude ) -  Tran Merc_dp *  Math . sin ( _ NUM *  Latitude ) +  Tran Merc_ep *  Math . sin ( _ NUM *  Latitude ) ; tmdo =  Tran Merc_ap *  Tran Merc_ Origin_ Lat -  Tran Merc_bp *  Math . sin ( _ NUM *  Tran Merc_ Origin_ Lat ) +  Tran Merc_cp *  Math . sin ( _ NUM *  Tran Merc_ Origin_ Lat ) -  Tran Merc_dp *  Math . sin ( _ NUM *  Tran Merc_ Origin_ Lat ) +  Tran Merc_ep *  Math . sin ( _ NUM *  Tran Merc_ Origin_ Lat ) ; t1 = ( tmd - tmdo ) *  Tran Merc_ Scale_ Factor ; t2 = sn * s * c *  Tran Merc_ Scale_ Factor / _ NUM ; t3 = sn * s * c3 *  Tran Merc_ Scale_ Factor * ( _ NUM - tan2 + _ NUM * eta + _ NUM * eta2 ) / _ NUM ; t4 = sn * s * c5 *  Tran Merc_ Scale_ Factor * ( _ NUM - _ NUM * tan2 + tan4 + _ NUM * eta - _ NUM * tan2 * eta + _ NUM * eta2 + _ NUM * eta3 - _ NUM * tan2 * eta2 + _ NUM * eta4 - _ NUM * tan2 * eta3 - _ NUM * tan2 * eta4 ) / _ NUM ; t5 = sn * s * c7 *  Tran Merc_ Scale_ Factor * ( _ NUM - _ NUM * tan2 + _ NUM * tan4 - tan6 ) / _ NUM ;  Northing =  Tran Merc_ False_ Northing + t1 +  Math . pow ( dlam , _ NUM ) * t2 +  Math . pow ( dlam , _ NUM ) * t3 +  Math . pow ( dlam , _ NUM ) * t4 +  Math . pow ( dlam , _ NUM ) * t5 ; t6 = sn * c *  Tran Merc_ Scale_ Factor ; t7 = sn * c3 *  Tran Merc_ Scale_ Factor * ( _ NUM - tan2 + eta ) / _ NUM ; t8 = sn * c5 *  Tran Merc_ Scale_ Factor * ( _ NUM - _ NUM * tan2 + tan4 + _ NUM * eta - _ NUM * tan2 * eta + _ NUM * eta2 + _ NUM * eta3 - _ NUM * tan2 * eta2 - _ NUM * tan2 * eta3 ) / _ NUM ; t9 = sn * c7 *  Tran Merc_ Scale_ Factor * ( _ NUM - _ NUM * tan2 + _ NUM * tan4 - tan6 ) / _ NUM ;  Easting =  Tran Merc_ False_ Easting + dlam * t6 +  Math . pow ( dlam , _ NUM ) * t7 +  Math . pow ( dlam , _ NUM ) * t8 +  Math . pow ( dlam , _ NUM ) * t9 ; } return (  Error_ Code ) ; }
public void close ( ) throws  IOException { m Output Stream . close ( ) ; }
@  Override public  Resource create Relative (  String relative Path ) throws  Malformed URLException { if ( relative Path . starts With ( _ STR ) ) { relative Path = relative Path . substring ( _ NUM ) ; } return new  Url Resource ( new  URL ( this . url , relative Path ) ) ; }
public  String reload ( ) { reload Source Values ( ) ; return  SUCCESS ; }
protected void add Message Processor (  Message Processor new Message Processor ) throws  IOException { synchronized ( message Processors ) { message Processors . add ( new Message Processor ) ; } }
public boolean is Revoked (  Certificate cert ) { if ( revoked Map . is Empty ( ) || ( ! ( cert instanceof  X509 Certificate ) ) ) { return _ BOOL ; }  X509 Certificate xcert = (  X509 Certificate ) cert ;  X509 Issuer Serial issuer Serial = new  X509 Issuer Serial ( xcert ) ; return revoked Map . contains Key ( issuer Serial ) ; }
private void add To Set (  Object Xml Persist persist ,  IFile file ,  String set Name ) throws  IOException ,  Core Exception {  Collection <  Relation Set Descriptor > update Set = load Relation Sets ( persist , file ) ; persist Updated Bundle ( persist , file , update Set , set Name ) ; }
public void put Len Bytes ( byte [ ] bytes ) { ensure Capacity ( _ NUM + bytes . length ) ; put Field Length ( bytes . length ) ;  System . arraycopy ( bytes , _ NUM , this . byte Buffer , this . position , bytes . length ) ; this . position += bytes . length ; }
private static  String list (  String [ ] arr , int from , int len ) {  String Buffer sb = new  String Buffer ( ) ; for ( int i = from ; i < len ; i ++ ) { sb . append ( arr [ i ] ) ; if ( i + _ NUM != arr . length ) sb . append ( _ STR ) ; } return sb . to String ( ) ; }
public static void fill Rectange (  Graphics2 D g2 D ,  JComponent c , boolean round ) {  Compiere Color cc = null ; boolean std CC = c . get Client Property (  Compiere Look And Feel .  BACKGROUND_ FILL ) != null ; try { cc = (  Compiere Color ) c . get Client Property (  Compiere Look And Feel .  BACKGROUND ) ; } catch (  Exception e ) { std CC = _ BOOL ; } if ( std CC ) cc =  Compiere Color . get Default Background ( ) ; if ( cc != null ) { cc . paint ( g2 D , c ) ; } else {  Paint paint = c . get Background ( ) ; g2 D . set Paint ( paint ) ;  Rectangular Shape rec = null ; if ( round ) rec = new  Round Rectangle2 D .  Float ( _ NUM , _ NUM , c . get Width ( ) , c . get Height ( ) , _ NUM , _ NUM ) ; else rec = new  Rectangle ( _ NUM , _ NUM , c . get Width ( ) , c . get Height ( ) ) ; g2 D . fill ( rec ) ; } }
public static int java New ( int lua State ,  Class clazz ) throws  Lua Exception {  Lua State  L =  Lua State Factory . get Existing State ( lua State ) ; synchronized (  L ) {  Object ret = get Obj Instance (  L , clazz ) ;  L . push Java Object ( ret ) ; return _ NUM ; } }
public void or (  Capabilities c ) { if ( do Not Check Capabilities ( ) ) { return ; } for (  Capability cap :  Capability . values ( ) ) { if ( handles ( cap ) || c . handles ( cap ) ) { m_ Capabilities . add ( cap ) ; } else { m_ Capabilities . remove ( cap ) ; } if ( has Dependency ( cap ) || c . has Dependency ( cap ) ) { m_ Dependencies . add ( cap ) ; } else { m_ Dependencies . remove ( cap ) ; } } if ( c . get Minimum Number Instances ( ) < get Minimum Number Instances ( ) ) { set Minimum Number Instances ( c . get Minimum Number Instances ( ) ) ; } }
protected void reopen ( ) throws  IOException { if ( input Stream != null ) {  Debug . message ( _ STR , _ STR ) ; input Stream . close ( ) ; } input Stream Count = _ NUM ; }
public void shutdown ( ) { final long begin =  System . current Time Millis ( ) ; log . info ( _ STR ) ; log . info ( _ STR + get Task Count ( scheduled Pool ) + _ STR ) ; log . info ( _ STR + get Task Count ( instant Pool ) + _ STR ) ; log . info ( _ STR + get Task Count ( long Running Pool ) + _ STR ) ; scheduled Pool . shutdown ( ) ; instant Pool . shutdown ( ) ; long Running Pool . shutdown ( ) ; boolean success = _ BOOL ; try { success = await Termination ( _ NUM ) ; scheduled Pool . set Execute Existing Delayed Tasks After Shutdown Policy ( _ BOOL ) ; scheduled Pool . set Continue Existing Periodic Tasks After Shutdown Policy ( _ BOOL ) ; success |= await Termination ( _ NUM ) ; } catch (  Interrupted Exception e ) { e . print Stack Trace ( ) ; } log . info ( _ STR + success + _ STR + (  System . current Time Millis ( ) - begin ) + _ STR ) ; log . info ( _ STR + get Task Count ( scheduled Pool ) + _ STR ) ; log . info ( _ STR + get Task Count ( instant Pool ) + _ STR ) ; log . info ( _ STR + get Task Count ( long Running Pool ) + _ STR ) ; }
public static boolean is Loopback (  Object host ) { if ( host instanceof  Inet Address ) { return  LOOPBACK . equals ( host ) ; } else { return is Loopback (  Inet Address Util . to Inet Address ( host . to String ( ) ) ) ; } }
public static  String unescape CString (  String s ) { if ( s . index Of ( _ STR ) < _ NUM ) { return s ; }  String Builder sb = new  String Builder ( ) ; int len = s . length ( ) ; for ( int i = _ NUM ; i < len ; ) { char c = s . char At ( i ++ ) ; if ( c == _ STR && ( i < len ) ) { c = s . char At ( i ++ ) ; switch ( c ) { case _ STR : c = _ STR ; break ; case _ STR : c = _ STR ; break ; case _ STR : c = _ STR ; break ; case _ STR : c = _ STR ; break ; case _ STR : c = _ STR ; break ; case _ STR : c = _ STR ; break ; case _ STR : c = _ STR ; break ; case _ STR : c = _ STR ; break ; case _ STR : c = _ STR ; break ; case _ STR : c = _ STR ; break ; case _ STR : c = _ STR ; break ; default : { if ( ( c == _ STR ) && ( i < len ) && is Hex ( s . char At ( i ) ) ) { int v = hex Value ( s . char At ( i ++ ) ) ; if ( ( i < len ) && is Hex ( s . char At ( i ) ) ) { v = v * _ NUM + hex Value ( s . char At ( i ++ ) ) ; } c = ( char ) v ; } else if ( is Octal ( c ) ) { int v = ( c - _ STR ) ; if ( ( i < len ) && is Octal ( s . char At ( i ) ) ) { v = v * _ NUM + ( s . char At ( i ++ ) - _ STR ) ; } if ( ( i < len ) && is Octal ( s . char At ( i ) ) ) { v = v * _ NUM + ( s . char At ( i ++ ) - _ STR ) ; } c = ( char ) v ; } else { sb . append ( _ STR ) ; } break ; } } } sb . append ( c ) ; } return sb . to String ( ) ; }
public final int count Categories ( ) { return m Categories != null ? m Categories . size ( ) : _ NUM ; }
String encode ( ) {  String Builder sbuf ; sbuf = new  String Builder ( ) ; sbuf . append ( get Host ( ) ) ; sbuf . append ( _ STR ) ; sbuf . append ( get User ( ) ) ; sbuf . append ( _ STR ) ; sbuf . append ( get Password ( ) ) ; sbuf . append ( _ STR ) ; sbuf . append ( get Port ( ) ) ; sbuf . append ( _ STR ) ; sbuf . append ( _ BOOL ) ; return sbuf . to String ( ) ; }
private  Collection <  Var > migrate Columns (  SQLTable table ,  Result Set row ,  Var instance ) throws  SQLException {  String table Type = table . get Entity Type ( ) ;  Map <  String ,  Resource Type .  Data Type > columns = table . get Columns ( ) ;  Map <  String ,  String > foreign = table . get Foreign Key Columns ( ) ;  Result Set Meta Data metadata = row . get Meta Data ( ) ;  List <  Var > vars = new  Array List < > ( ) ; for ( int i = _ NUM ; i <= metadata . get Column Count ( ) ; i ++ ) {  String column Name = metadata . get Column Name ( i ) ;  Object column Value = row . get Object ( column Name ) ;  Resource Type .  Data Type data Type = columns . get ( column Name ) ;  String foreign Key = foreign . get ( column Name ) ; if ( foreign Key != null ) { vars . add All ( migrate Column Value As Relation ( instance , column Name , foreign Key , column Value ) ) ; } else { vars . add All ( migrate Column Value As Resource ( instance , column Name , cast ( data Type , column Name , row ) , table Type ) ) ; } } return vars ; }
public void close (  Result Set rs ) { if ( rs != null ) { try { rs . close ( ) ; } catch (  SQLException e ) { } } }
@  Override public synchronized void remove Attribute ( int index ) {  Attribute a = attributes . get ( index ) ; if ( a == null ) { return ; } attributes . set ( index , null ) ; unused Column List . add ( index ) ; }
default  B with (  String key , boolean value ) { return with ( key ,  Boolean . to String ( value ) ) ; }
public static void sort (  Object [ ] array ) { if ( array . length > _ NUM ) {  Arrays . sort ( array ,  INSTANCE ) ; } }
public  SIPServer Transaction create Server Transaction (  Message Channel encapsulated Message Channel ) { if ( unlimited Server Transaction Table Size ) { return new  SIPServer Transaction ( this , encapsulated Message Channel ) ; } else { float threshold = ( ( float ) ( server Transaction Table . size ( ) - server Transaction Table Lowater Mark ) ) / ( ( float ) ( server Transaction Table Highwater Mark - server Transaction Table Lowater Mark ) ) ; boolean decision =  Math . random ( ) > _ NUM - threshold ; if ( decision ) { return null ; } else { return new  SIPServer Transaction ( this , encapsulated Message Channel ) ; } } }
public static int read Fully (  Input Stream in Str , byte [ ] buf , int off , int len ) throws  IOException { int total Read = _ NUM ; while ( total Read < len ) { int num Read = in Str . read ( buf , off + total Read , len - total Read ) ; if ( num Read < _ NUM ) { break ; } total Read += num Read ; } return total Read ; }
public static void assume False (  Boolean Supplier assumption Supplier ,  Supplier <  String > message Supplier ) throws  Test Aborted Exception { if ( assumption Supplier . get As Boolean ( ) ) { throw Test Aborted Exception ( message Supplier . get ( ) ) ; } }
public static  String add To Cart Bulk Requirements (  Http Servlet Request request ,  Http Servlet Response response ) {  Shopping Cart cart = get Cart Object ( request ) ;  Delegator delegator = (  Delegator ) request . get Attribute ( _ STR ) ;  Local Dispatcher dispatcher = (  Local Dispatcher ) request . get Attribute ( _ STR ) ;  Shopping Cart Helper cart Helper = new  Shopping Cart Helper ( delegator , dispatcher , cart ) ;  String control Directive ;  Map <  String ,  Object > result ;  Map <  String ,  Object > param Map =  Util Http . get Parameter Map ( request ) ;  String catalog Id =  Catalog Worker . get Current Catalog Id ( request ) ; result = cart Helper . add To Cart Bulk Requirements ( catalog Id , param Map ) ; control Directive = process Result ( result , request ) ; if ( control Directive . equals (  ERROR ) ) { return _ STR ; } else { return _ STR ; } }
private void shrink Value Set ( int max Size ) { if ( value Set != null ) { if ( value Set . size ( ) > max Size ) {  Set <  String > new Set = new  Tree Set <  String > ( ) ;  Iterator <  String > i = value Set . iterator ( ) ; int count = _ NUM ; while ( i . has Next ( ) && count < max Size ) { new Set . add ( i . next ( ) ) ; count ++ ; } this . value Set = new Set ; value Set Relation = value Set Relation . merge (  Set Relation .  SUPERSET ) ; if ( owner != null ) { owner . set Nominal Data Was Shrinked ( _ BOOL ) ; } } } }
public long skip ( long bytes ) throws  IOException { long bytes Skipped = buffered Input . skip ( bytes ) ; offset += bytes Skipped ; available -= bytes Skipped ; return bytes Skipped ; }
protected  Workflow .  Method create Add Volumes To CGMethod (  URI vplex URI ,  URI cg URI ,  List <  URI > vplex Volume URIs ) { return new  Workflow .  Method (  ADD_ VOLUMES_ TO_ CG_ METHOD_ NAME , vplex URI , cg URI , vplex Volume URIs ) ; }
@  Suppress Warnings ( _ STR ) public  Url Critter add Url (  String url ,  Context context ) {  List <  String > urls = url Manager . get Urls ( context ) ; if ( ! urls . contains ( url ) ) { urls . add ( url ) ; url Manager . save Urls ( context , urls ) ; } return this ; }
private boolean has Items (  Collection < ? extends  Object > col ) { return col != null && ! col . is Empty ( ) ; }
public static  String replace (  String in String ,  String old Pattern ,  String new Pattern ) { if ( in String == null ) { return null ; } if ( old Pattern == null || new Pattern == null ) { return in String ; }  String Builder sbuf = new  String Builder ( ) ; int pos = _ NUM ; int index = in String . index Of ( old Pattern ) ; int pat Len = old Pattern . length ( ) ; while ( index >= _ NUM ) { sbuf . append ( in String . substring ( pos , index ) ) ; sbuf . append ( new Pattern ) ; pos = index + pat Len ; index = in String . index Of ( old Pattern , pos ) ; } sbuf . append ( in String . substring ( pos ) ) ; return sbuf . to String ( ) ; }
public  String generate Call Identifier (  String address ) { long random = rand . next Long ( ) ; int hash = ( int )  Math . abs ( random % digester Pools Size ) ;  Message Digest md = digester Pool [ hash ] ; synchronized ( md ) {  String date =  Long . to String (  System . nano Time ( ) +  System . current Time Millis ( ) + call IDCounter ++ + random ) ; byte cid [ ] = md . digest ( date . get Bytes ( ) ) ;  String cid String =  Utils . to Hex String ( cid ) ; return cid String + _ STR + address ; } }
public synchronized void add (  Object obj ) { obj = copy ( obj ) ; if ( m_ History . contains ( obj ) ) { m_ History . remove ( obj ) ; } m_ History . insert Element At ( obj , _ NUM ) ; while ( m_ History . size ( ) >  MAX_ HISTORY_ COUNT ) { m_ History . remove ( m_ History . size ( ) - _ NUM ) ; } }
public  Reference Binding find Super Type Originating From ( int well Known Original ID , boolean original Is Class ) { if ( ! ( this instanceof  Reference Binding ) ) return null ;  Reference Binding reference = (  Reference Binding ) this ; if ( reference . id == well Known Original ID || ( original ( ) . id == well Known Original ID ) ) return reference ;  Reference Binding current Type = reference ; if ( original Is Class ) { while ( ( current Type = current Type . superclass ( ) ) != null ) { if ( current Type . id == well Known Original ID ) return current Type ; if ( current Type . original ( ) . id == well Known Original ID ) return current Type ; } return null ; }  Reference Binding [ ] interfaces To Visit = null ; int next Position = _ NUM ; do {  Reference Binding [ ] its Interfaces = current Type . super Interfaces ( ) ; if ( its Interfaces != null && its Interfaces !=  Binding .  NO_ SUPERINTERFACES ) { if ( interfaces To Visit == null ) { interfaces To Visit = its Interfaces ; next Position = interfaces To Visit . length ; } else { int its Length = its Interfaces . length ; if ( next Position + its Length >= interfaces To Visit . length )  System . arraycopy ( interfaces To Visit , _ NUM , interfaces To Visit = new  Reference Binding [ next Position + its Length + _ NUM ] , _ NUM , next Position ) ; next Interface : for ( int a = _ NUM ; a < its Length ; a ++ ) {  Reference Binding next = its Interfaces [ a ] ; for ( int b = _ NUM ; b < next Position ; b ++ ) if ( next == interfaces To Visit [ b ] ) continue next Interface ; interfaces To Visit [ next Position ++ ] = next ; } } } } while ( ( current Type = current Type . superclass ( ) ) != null ) ; for ( int i = _ NUM ; i < next Position ; i ++ ) { current Type = interfaces To Visit [ i ] ; if ( current Type . id == well Known Original ID ) return current Type ; if ( current Type . original ( ) . id == well Known Original ID ) return current Type ;  Reference Binding [ ] its Interfaces = current Type . super Interfaces ( ) ; if ( its Interfaces != null && its Interfaces !=  Binding .  NO_ SUPERINTERFACES ) { int its Length = its Interfaces . length ; if ( next Position + its Length >= interfaces To Visit . length )  System . arraycopy ( interfaces To Visit , _ NUM , interfaces To Visit = new  Reference Binding [ next Position + its Length + _ NUM ] , _ NUM , next Position ) ; next Interface : for ( int a = _ NUM ; a < its Length ; a ++ ) {  Reference Binding next = its Interfaces [ a ] ; for ( int b = _ NUM ; b < next Position ; b ++ ) if ( next == interfaces To Visit [ b ] ) continue next Interface ; interfaces To Visit [ next Position ++ ] = next ; } } } return null ; }
@  Override protected void on Draw (  Canvas canvas ) { super . on Draw ( canvas ) ; if ( m Shader == null ) return ; float radius = m Center X <= m Center Y ? m Center X - _ NUM : m Center Y - _ NUM ; canvas . rotate ( m Rotate Degrees , m Center X , m Center Y ) ; canvas . draw Circle ( m Center X , m Center Y , radius , m Paint Cover ) ; canvas . rotate ( - m Rotate Degrees , m Center X , m Center Y ) ; canvas . draw Circle ( m Center X , m Center Y , m Button Radius , m Paint Button ) ; canvas . draw Bitmap ( is Rotating ( ) ? m Bitmap Pause : m Bitmap Play , m Center X - m Bitmap Pause . get Width ( ) / _ NUM , m Center Y - m Bitmap Pause . get Height ( ) / _ NUM , m Paint Play Pause ) ; if ( m Progress Visibility ) { canvas . draw Arc ( rect F , _ NUM , _ NUM , _ BOOL , m Paint Progress Empty ) ; canvas . draw Arc ( rect F , _ NUM , calculate Past Progress Degree ( ) , _ BOOL , m Paint Progress Loaded ) ;  String left Time = seconds To Time ( calculate Left Seconds ( ) ) ; m Paint Time . get Text Bounds ( left Time , _ NUM , left Time . length ( ) , m Rect Text ) ; canvas . draw Text ( left Time , ( float ) ( m Center X *  Math . cos (  Math . to Radians ( _ NUM ) ) ) + m Width / _ NUM - m Rect Text . width ( ) / _ NUM , ( float ) ( m Center X *  Math . sin (  Math . to Radians ( _ NUM ) ) ) + m Height / _ NUM + m Rect Text . height ( ) + _ NUM , m Paint Time ) ;  String passed Time = seconds To Time ( calculate Passed Seconds ( ) ) ; m Paint Time . get Text Bounds ( passed Time , _ NUM , passed Time . length ( ) , m Rect Text ) ; canvas . draw Text ( passed Time , ( float ) ( m Center X * -  Math . cos (  Math . to Radians ( _ NUM ) ) ) + m Width / _ NUM - m Rect Text . width ( ) / _ NUM , ( float ) ( m Center X *  Math . sin (  Math . to Radians ( _ NUM ) ) ) + m Height / _ NUM + m Rect Text . height ( ) + _ NUM , m Paint Time ) ; } }
public void add To Forward List (  Entry Point ep ) { if ( ep != null ) { m Forward Entry Points . add ( ep ) ; } }
public void request Seconds Until Password Reset Lockout ( ) { operations . add (  Password Policy State Operation Type .  GET_ SECONDS_ UNTIL_ PASSWORD_ RESET_ LOCKOUT ) ; }
public  Session State Lite (  String cmd ,  Hive Operation command Type ,  Hive Conf conf ) { this . cmd = cmd ; this . command Type = command Type . name ( ) ; this . conf = new  Hive Conf ( conf ) ; this . query Id = null ; this . map Red Stats = null ; }
public void test Neg Neg First Shorter ( ) { byte a Bytes [ ] = { - _ NUM , - _ NUM , - _ NUM , - _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM } ; byte b Bytes [ ] = { - _ NUM , _ NUM , _ NUM , _ NUM , - _ NUM , - _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , - _ NUM , _ NUM , _ NUM , - _ NUM , _ NUM , _ NUM , - _ NUM , - _ NUM } ; int a Sign = - _ NUM ; int b Sign = - _ NUM ; byte r Bytes [ ] = { - _ NUM , _ NUM , _ NUM , - _ NUM , - _ NUM , - _ NUM , - _ NUM , - _ NUM , - _ NUM , - _ NUM , - _ NUM , - _ NUM , - _ NUM , - _ NUM , - _ NUM } ;  Big Integer a Number = new  Big Integer ( a Sign , a Bytes ) ;  Big Integer b Number = new  Big Integer ( b Sign , b Bytes ) ;  Big Integer result = a Number . or ( b Number ) ; byte res Bytes [ ] = new byte [ r Bytes . length ] ; res Bytes = result . to Byte Array ( ) ; for ( int i = _ NUM ; i < res Bytes . length ; i ++ ) { assert True ( res Bytes [ i ] == r Bytes [ i ] ) ; } assert Equals ( _ STR , - _ NUM , result . signum ( ) ) ; }
public static  String correct File Name (  String f ) { f = f . replace ( _ STR , _ STR ) ; if ( f . starts With ( _ STR ) ) { f = f . substring ( _ NUM ) ; } return f ; }
public static  Document new Document ( ) { return document Builder . new Document ( ) ; }
public void add Arg ( final  BOp new Arg ) { if ( new Arg == null ) throw new  Illegal Argument Exception ( ) ; if ( new Arg == this ) throw new  Illegal Argument Exception ( ) ; args . add ( new Arg ) ; mutation ( ) ; }
public boolean try Lock ( ) { return locker . compare And Set ( _ BOOL , _ BOOL ) ; }
public  Unicast Server Ref ( ) { }
private static int last Index Of (  Object o ,  Object [ ] elements , int index ) { if ( o == null ) { for ( int i = index ; i >= _ NUM ; i -- ) if ( elements [ i ] == null ) return i ; } else { for ( int i = index ; i >= _ NUM ; i -- ) if ( o . equals ( elements [ i ] ) ) return i ; } return - _ NUM ; }
private  Byte Buffer ensure Buffer ( int size ,  Byte Buffer buffer ,  Writable Byte Channel output ) throws  IOException { if ( buffer . remaining ( ) >= size ) { return buffer ; } flush Buffer ( buffer , output ) ; if ( buffer . remaining ( ) >= size ) { return buffer ; } return  Byte Buffer . allocate Direct (  Math . max ( buffer . capacity ( ) << _ NUM , buffer . capacity ( ) + size ) ) ; }
public int compare Source Lines (  Bug Collection lhs Collection ,  Bug Collection rhs Collection ,  Source Line Annotation lhs ,  Source Line Annotation rhs ) { if ( lhs == null || rhs == null ) { return compare Null Elements ( lhs , rhs ) ; } int cmp = compare Classes By Name ( lhs Collection , rhs Collection , lhs . get Class Name ( ) , rhs . get Class Name ( ) ) ; if ( cmp != _ NUM ) { return cmp ; } return _ NUM ; }
private synchronized void block ( boolean tf ) { if ( tf ) { try { if ( m_build Thread . is Alive ( ) && m_state !=  IDLE ) { wait ( ) ; } } catch (  Interrupted Exception ex ) { } } else { notify All ( ) ; } }
public void move (  Mouse Event e ) {  Point2 D pnt = get Projection Point ( e ) ; int x = ( int ) pnt . get X ( ) ; int y = ( int ) pnt . get Y ( ) ; if ( line . get Render Type ( ) ==  OMGraphic .  RENDERTYPE_ OFFSET ) { gpm = new  Offset Grab Point ( x , y ) ; gpm . add Grab Point ( gp1 ) ; gpm . add Grab Point ( gp2 ) ; } else { gpm = gpo ; gpm . set ( x , y ) ; gpm . update Offsets ( ) ; } moving Point = gpm ; }
public static boolean is In Range (  String ip ,  String ip Range ) { if ( ip == null || ip Range == null ) return _ BOOL ;  String [ ] cidr String = ip Range . split ( _ STR ) ; if ( cidr String . length == _ NUM ) return _ BOOL ;  String network = cidr String [ _ NUM ] ;  String cidr Mask = _ STR ; if ( cidr String . length > _ NUM ) { cidr Mask = cidr String [ _ NUM ] ; }  String net Mask = cidr Mask To Net Mask ( cidr Mask ) ;  Inet Address masked IP = apply Mask ( ip , net Mask ) ;  Inet Address masked Network = apply Mask ( network , net Mask ) ; if ( masked IP == null || masked Network == null ) return _ BOOL ; return masked IP . equals ( masked Network ) ; }
protected static  Boolean try Lock (  String service Name ,  Object name ,  Long wait ) {  DLock Service service =  DLock Service . get Internal Service Named ( service Name ) ; boolean locked = service . lock ( name , wait . long Value ( ) , - _ NUM , _ BOOL ) ; return  Boolean . value Of ( locked ) ; }
public void enable Cookie ( ) { is Enable Cookie = _ BOOL ; if ( m Cookie Manager == null ) { m Cookie Manager = new  Cookie Manager ( new  Persistent Cookie Store ( m Context ) ,  Cookie Policy .  ACCEPT_ ALL ) ;  Cookie Handler . set Default ( m Cookie Manager ) ; } }
private  File select Export File ( final  String title ,  File Name Extension Filter file Name Extension Filter ) { if (  Boolean . parse Boolean (  System . get Property ( _ STR ,  Boolean . to String (  OSType . is Mac ( ) ) ) ) ) {  File Dialog export Dialog = file Dialogs . get ( title ) ; if ( export Dialog == null ) { export Dialog = new  File Dialog ( this , title ,  File Dialog .  SAVE ) ; file Dialogs . put ( title , export Dialog ) ; } export Dialog . set File ( options . file Name Stem + _ STR ) ; export Dialog . set Visible ( _ BOOL ) ; if ( export Dialog . get File ( ) != null ) { return new  File ( export Dialog . get Directory ( ) , export Dialog . get File ( ) ) ; } } else {  JFile Chooser export Chooser = file Choosers . get ( title ) ; if ( export Chooser == null ) { export Chooser = new  JFile Chooser (  Utils . get CWD ( ) ) ; export Chooser = new  JFile Chooser (  Utils . get CWD ( ) ) ; export Chooser . set File Filter ( file Name Extension Filter ) ; export Chooser . set Dialog Title ( title ) ; file Choosers . put ( title , export Chooser ) ; } export Chooser . set Selected File ( new  File ( options . file Name Stem + _ STR ) ) ; final int return Val = export Chooser . show Save Dialog ( this ) ; if ( return Val ==  JFile Chooser .  APPROVE_ OPTION ) {  File file = export Chooser . get Selected File ( ) ; int n =  JOption Pane .  YES_ OPTION ; if ( file . exists ( ) ) { n =  JOption Pane . show Confirm Dialog ( this , file . get Name ( ) , _ STR ,  JOption Pane .  YES_ NO_ OPTION ) ; } if ( n ==  JOption Pane .  YES_ OPTION ) { return file ; } } } return null ; }
public  GT_ Meta Generated_ Item_ X01 (  String a Unlocalized ,  Ore Prefixes a Generated Prefix , int a Icon Set Index ) { super ( a Unlocalized , ( short ) _ NUM , ( short ) _ NUM ) ; m Prefix = a Generated Prefix ; m Icon Set Index = a Icon Set Index >= _ NUM ? a Icon Set Index : a Generated Prefix . m Texture Index >= _ NUM ? a Generated Prefix . m Texture Index : _ NUM ; for ( int i = _ NUM ; i <  Greg Tech_ API . s Generated Materials . length ; i ++ ) {  Ore Prefixes t Prefix = m Prefix ; if ( t Prefix == null ) continue ;  Materials t Material =  Greg Tech_ API . s Generated Materials [ i ] ; if ( t Material == null ) continue ; if ( m Prefix . do Generate Item ( t Material ) ) {  Item Stack t Stack = new  Item Stack ( this , _ NUM , i ) ;  GT_ Language Manager . add String Localization ( get Unlocalized Name ( t Stack ) + _ STR , get Default Localization ( t Prefix , t Material , i ) ) ;  GT_ Language Manager . add String Localization ( get Unlocalized Name ( t Stack ) + _ STR , t Material . get Tool Tip ( t Prefix . m Material Amount /  M ) ) ;  String t Ore Name = get Ore Dict String ( t Prefix , t Material ) ; t Prefix =  Ore Prefixes . get Ore Prefix ( t Ore Name ) ; if ( t Prefix != null && t Prefix . m Is Unificatable ) {  GT_ Ore Dict Unificator . set ( t Prefix ,  Ore Prefixes . get Material ( t Ore Name , t Prefix ) , t Stack ) ; } else {  GT_ Ore Dict Unificator . register Ore ( t Ore Name , t Stack ) ; } } } }
@  Override public  Enumeration <  Option > list Options ( ) {  Vector <  Option > new Vector = new  Vector <  Option > ( _ NUM ) ; new Vector . add Element ( new  Option ( _ STR , _ STR , _ NUM , _ STR ) ) ; new Vector . add Element ( new  Option ( _ STR + _ STR , _ STR , _ NUM , _ STR ) ) ; new Vector . add Element ( new  Option ( _ STR + _ STR , _ STR , _ NUM , _ STR ) ) ; new Vector . add Element ( new  Option ( _ STR , _ STR , _ NUM , _ STR ) ) ; new Vector . add Element ( new  Option ( _ STR + _ STR + _ STR , _ STR , _ NUM , _ STR ) ) ; new Vector . add Element ( new  Option ( _ STR , _ STR , _ NUM , _ STR ) ) ; new Vector . add Element ( new  Option ( _ STR + num Execution Slots Tip Text ( ) + _ STR , _ STR , _ NUM , _ STR ) ) ; new Vector . add Element ( new  Option ( _ STR , _ STR , _ NUM , _ STR ) ) ; return new Vector . elements ( ) ; }
public static  Parsed Sql parse Sql Statement (  String sql ) { if ( sql == null ) new  Illegal Argument Exception ( _ STR ) ;  Set <  String > named Parameters = new  Hash Set <  String > ( ) ;  Parsed Sql parsed Sql = new  Parsed Sql ( sql ) ; char [ ] statement = sql . to Char Array ( ) ; int named Parameter Count = _ NUM ; int unnamed Parameter Count = _ NUM ; int total Parameter Count = _ NUM ; int i = _ NUM ; while ( i < statement . length ) { int skip To Position = skip Comments And Quotes ( statement , i ) ; if ( i != skip To Position ) { if ( skip To Position >= statement . length ) { break ; } i = skip To Position ; } char c = statement [ i ] ; if ( c == _ STR || c == _ STR || c == _ STR || c == _ STR ) { int j = i + _ NUM ; if ( j < statement . length && statement [ j ] == _ STR && c == _ STR ) { i = i + _ NUM ; continue ; } while ( j < statement . length && ! is Parameter Separator ( statement [ j ] ) ) { j ++ ; } if ( j - i > _ NUM ) {  String parameter = sql . substring ( i + _ NUM , j ) ; if ( ! named Parameters . contains ( parameter ) ) { named Parameters . add ( parameter ) ; named Parameter Count ++ ; }  String removed Prefix And Suffix Parameter = remove Prefix And Suffix ( c , parameter , sql ) ; parsed Sql . add Named Parameter ( removed Prefix And Suffix Parameter , c + parameter , i , j ) ; total Parameter Count ++ ; } i = j - _ NUM ; } else { if ( c == _ STR ) { unnamed Parameter Count ++ ; total Parameter Count ++ ; } } i ++ ; } parsed Sql . set Named Parameter Count ( named Parameter Count ) ; parsed Sql . set Unnamed Parameter Count ( unnamed Parameter Count ) ; parsed Sql . set Total Parameter Count ( total Parameter Count ) ; return parsed Sql ; }
final void put Double ( int offset , double value ) { unsafe . put Double ( offset + address , value ) ; }
private void append Request Id (  String request Id ) { if ( is Not Valid Request Id ( request Id ) ) { return ; }  Request Log . add Id Prefix ( request Id ) ; }
public static  String gensalt ( int log_rounds ,  Secure Random random ) {  String Builder rs = new  String Builder ( ) ; byte rnd [ ] = new byte [  BCRYPT_ SALT_ LEN ] ; random . next Bytes ( rnd ) ; rs . append ( _ STR ) ; if ( log_rounds < _ NUM ) rs . append ( _ STR ) ; if ( log_rounds > _ NUM ) { throw new  Illegal Argument Exception ( _ STR ) ; } rs . append (  Integer . to String ( log_rounds ) ) ; rs . append ( _ STR ) ; rs . append ( encode_base64 ( rnd , rnd . length ) ) ; return rs . to String ( ) ; }
public static  Number convert To Number (  String str ) { if ( str == null ) { return null ; } str = str . trim ( ) ; if ( str . length ( ) == _ NUM ) { return null ; } if ( str . index Of ( _ STR ) >= _ NUM || str . index Of ( _ STR ) >= _ NUM || str . index Of ( _ STR ) >= _ NUM ) { return  Double . value Of ( str ) ; } try { long lval =  Long . parse Long ( str ) ; if ( lval == ( int ) lval ) { return new  Integer ( ( int ) lval ) ; } return new  Long ( lval ) ; } catch (  Number Format Exception ee ) { return new java . math .  Big Integer ( str , _ NUM ) ; } }
@  Override protected  Script create Output Script ( ) { return  Script Builder . create P2 SHOutput Script ( create P2 SHRedeem Script ( ) ) ; }
public static void check Finite ( final double x ) throws  Math Illegal Argument Exception { if (  Double . is Infinite ( x ) ||  Double . is Na N ( x ) ) { throw new  Math Illegal Argument Exception (  Localized Core Formats .  NOT_ FINITE_ NUMBER , x ) ; } }
@  Override public void on Create (  Bundle saved Instance State ) { super . on Create ( saved Instance State ) ; m Handler = new  Handler ( ) ; set Content View (  R . layout . voice_recognition ) ;  Button speak Button = (  Button ) find View By Id (  R . id . btn_speak ) ; m List = (  List View ) find View By Id (  R . id . list ) ; m Supported Language View = (  Spinner ) find View By Id (  R . id . supported_languages ) ;  Package Manager pm = get Package Manager ( ) ;  List <  Resolve Info > activities = pm . query Intent Activities ( new  Intent (  Recognizer Intent .  ACTION_ RECOGNIZE_ SPEECH ) , _ NUM ) ; if ( activities . size ( ) != _ NUM ) { speak Button . set On Click Listener ( this ) ; } else { speak Button . set Enabled ( _ BOOL ) ; speak Button . set Text ( _ STR ) ; } refresh Voice Settings ( ) ; }
public static boolean is Auto Commit (  Properties ctx , int  Window No ) { if ( ctx == null ) throw new  Illegal Argument Exception ( _ STR ) ;  String s = get Context ( ctx ,  Window No , _ STR , _ BOOL ) ; if ( s != null ) { if ( s . equals ( _ STR ) ) return _ BOOL ; else return _ BOOL ; } return is Auto Commit ( ctx ) ; }
@  Nullable public  Virtual File find File By Relative Path ( @  Not Null @  Non Nls  String rel Path ) { if ( rel Path . is Empty ( ) ) return this ; rel Path =  String Util . trim Start ( rel Path , _ STR ) ; int index = rel Path . index Of ( _ STR ) ; if ( index < _ NUM ) index = rel Path . length ( ) ;  String name = rel Path . substring ( _ NUM , index ) ;  Virtual File child ; if ( name . equals ( _ STR ) ) { child = this ; } else if ( name . equals ( _ STR ) ) { if ( is (  VFile Property .  SYMLINK ) ) { final  Virtual File canonical File = get Canonical File ( ) ; child = canonical File != null ? canonical File . get Parent ( ) : null ; } else { child = get Parent ( ) ; } } else { child = find Child ( name ) ; } if ( child == null ) return null ; if ( index < rel Path . length ( ) ) { return child . find File By Relative Path ( rel Path . substring ( index + _ NUM ) ) ; } return child ; }
public  String global Info ( ) { return _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR ; }
public void add Leaking Resource (  Leaking Resource resource ) { synchronized ( leaking Resources ) { leaking Resources . add ( resource ) ; } }
public void test Neg Neg First Longer ( ) { byte a Bytes [ ] = { - _ NUM , _ NUM , _ NUM , _ NUM , - _ NUM , - _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , - _ NUM , _ NUM , _ NUM , - _ NUM , _ NUM , _ NUM , - _ NUM , - _ NUM } ; byte b Bytes [ ] = { - _ NUM , - _ NUM , - _ NUM , - _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM } ; int a Sign = - _ NUM ; int b Sign = - _ NUM ; byte r Bytes [ ] = { - _ NUM , _ NUM , - _ NUM , - _ NUM , - _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , - _ NUM , - _ NUM , _ NUM , - _ NUM , - _ NUM , _ NUM , - _ NUM , - _ NUM , _ NUM , _ NUM } ;  Big Integer a Number = new  Big Integer ( a Sign , a Bytes ) ;  Big Integer b Number = new  Big Integer ( b Sign , b Bytes ) ;  Big Integer result = a Number . and ( b Number ) ; byte res Bytes [ ] = new byte [ r Bytes . length ] ; res Bytes = result . to Byte Array ( ) ; for ( int i = _ NUM ; i < res Bytes . length ; i ++ ) { assert True ( res Bytes [ i ] == r Bytes [ i ] ) ; } assert Equals ( _ STR , - _ NUM , result . signum ( ) ) ; }
public static  String generate String Of Length ( int length ) {  String Builder sb = new  String Builder ( ) ; while ( -- length >= _ NUM ) { sb . append ( ( char ) ( random . next Int ( _ NUM ) + _ NUM ) ) ; } return sb . to String ( ) ; }
public void stop ( ) { throw new  Unsupported Operation Exception ( _ STR ) ; }
public void remove Attributes (  Attribute Set attributes ) { if ( attributes == this ) { table . clear ( ) ; } else {  Enumeration names = attributes . get Attribute Names ( ) ; while ( names . has More Elements ( ) ) {  Object name = names . next Element ( ) ;  Object value = attributes . get Attribute ( name ) ; if ( value . equals ( get Attribute ( name ) ) ) remove Attribute ( name ) ; } } }
public void delete (  Key key ) { if ( key == null ) throw new  Null Pointer Exception ( _ STR ) ; set . remove ( key ) ; }
public static void surface Sql Exception (  SQLException e ) { boolean chained = _ BOOL ;  String logger Msg ; while ( e != null ) { if ( chained ) { logger Msg =  String . format ( _ STR , e . get SQLState ( ) , e . get Error Code ( ) , e . get Message ( ) , stack Trace To String ( e ) ) ; } else { logger Msg =  String . format ( _ STR , e . get SQLState ( ) , e . get Error Code ( ) , e . get Message ( ) , stack Trace To String ( e ) ) ; chained = _ BOOL ; } e = e . get Next Exception ( ) ; logger . error ( logger Msg ) ; } }
private void fill Declared Prefixes (  XMLStream Reader reader ) { f Declared Prefixes . clear ( ) ; final int len = reader . get Namespace Count ( ) ; for ( int i = _ NUM ; i < len ; ++ i ) {  String prefix = reader . get Namespace Prefix ( i ) ; f Declared Prefixes . add ( prefix != null ? prefix : _ STR ) ; } }
public void add Get Time Nanos ( long duration ) { get Time Nanos . add And Get ( duration ) ; if ( delegate != null ) delegate . add Get Time Nanos ( duration ) ; }
public  Bloom Filter ( byte [ ] data , int hash Functions , int tweak ,  Update Mode update ) { filter =  Arrays . clone ( data ) ; this . hash Functions =  Math . min ( hash Functions ,  MAX_ HASH_ FUNCS ) ; this . tweak = tweak ; this . update = update ; }
@  Request Processing ( value = _ STR , method =  HTTPRequest Method .  GET ) @  Before ( advice Class = {  Stopwatch Start Advice . class ,  Anonymous View Check . class ,  User Block Check . class } ) @  After ( advice Class =  Stopwatch End Advice . class ) public void show Home Following Users ( final  HTTPRequest Context context , final  Http Servlet Request request , final  Http Servlet Response response , final  String user Name ) throws  Exception { final  JSONObject user = (  JSONObject ) request . get Attribute (  User .  USER ) ; request . set Attribute (  Keys .  TEMAPLTE_ DIR_ NAME ,  Symphonys . get ( _ STR ) ) ; final  Abstract Free Marker Renderer renderer = new  Skin Renderer ( ) ; context . set Renderer ( renderer ) ; renderer . set Template Name ( _ STR ) ; final  Map <  String ,  Object > data Model = renderer . get Data Model ( ) ; filler . fill Header And Footer ( request , response , data Model ) ;  String page Num Str = request . get Parameter ( _ STR ) ; if (  Strings . is Empty Or Null ( page Num Str ) || !  Strings . is Numeric ( page Num Str ) ) { page Num Str = _ STR ; } final int page Num =  Integer . value Of ( page Num Str ) ; final int page Size =  Symphonys . get Int ( _ STR ) ; final int window Size =  Symphonys . get Int ( _ STR ) ; fill Home User ( data Model , user ) ; final  String following Id = user . opt String (  Keys .  OBJECT_ ID ) ; data Model . put (  Follow .  FOLLOWING_ ID , following Id ) ; avatar Query Service . fill User Avatar URL ( user ) ; final  JSONObject following Users Result = follow Query Service . get Following Users ( following Id , page Num , page Size ) ; final  List <  JSONObject > following Users = (  List <  JSONObject > ) following Users Result . opt (  Keys .  RESULTS ) ; data Model . put (  Common .  USER_ HOME_ FOLLOWING_ USERS , following Users ) ; final boolean is Logged In = (  Boolean ) data Model . get (  Common .  IS_ LOGGED_ IN ) ; if ( is Logged In ) { final  JSONObject current User = (  JSONObject ) data Model . get (  Common .  CURRENT_ USER ) ; final  String follower Id = current User . opt String (  Keys .  OBJECT_ ID ) ; final boolean is Following = follow Query Service . is Following ( follower Id , following Id ) ; data Model . put (  Common .  IS_ FOLLOWING , is Following ) ; for ( final  JSONObject following User : following Users ) { final  String home User Following User Id = following User . opt String (  Keys .  OBJECT_ ID ) ; following User . put (  Common .  IS_ FOLLOWING , follow Query Service . is Following ( follower Id , home User Following User Id ) ) ; } } user . put (  User Ext .  USER_ T_ CREATE_ TIME , new  Date ( user . get Long (  Keys .  OBJECT_ ID ) ) ) ; final int following User Cnt = following Users Result . opt Int (  Pagination .  PAGINATION_ RECORD_ COUNT ) ; final int page Count = ( int )  Math . ceil ( ( double ) following User Cnt / ( double ) page Size ) ; final  List <  Integer > page Nums =  Paginator . paginate ( page Num , page Size , page Count , window Size ) ; if ( ! page Nums . is Empty ( ) ) { data Model . put (  Pagination .  PAGINATION_ FIRST_ PAGE_ NUM , page Nums . get ( _ NUM ) ) ; data Model . put (  Pagination .  PAGINATION_ LAST_ PAGE_ NUM , page Nums . get ( page Nums . size ( ) - _ NUM ) ) ; } data Model . put (  Pagination .  PAGINATION_ CURRENT_ PAGE_ NUM , page Num ) ; data Model . put (  Pagination .  PAGINATION_ PAGE_ COUNT , page Count ) ; data Model . put (  Pagination .  PAGINATION_ PAGE_ NUMS , page Nums ) ; }
public int interp Elevation At ( float lat , float lon ) { if ( frame_is_valid == _ BOOL ) { if ( lat >= dsi . sw_lat && lat <= dsi . ne_lat && lon >= dsi . sw_lon && lon <= dsi . ne_lon ) { float lat_index = ( lat - dsi . sw_lat ) * _ NUM / uhl . lat_post_interval ; float lon_index = ( lon - dsi . sw_lon ) * _ NUM / uhl . lon_post_interval ; int lflon_index = ( int )  Math . floor ( lon_index ) ; int lclon_index = ( int )  Math . ceil ( lon_index ) ; int lclat_index = ( int )  Math . ceil ( lat_index ) ; if ( elevations [ lflon_index ] == null ) read Data Record ( lflon_index ) ; if ( elevations [ lclon_index ] == null ) read Data Record ( lclon_index ) ; int ul = elevations [ lflon_index ] [ lclat_index ] ; int ur = elevations [ lclon_index ] [ lclat_index ] ; int ll = elevations [ lflon_index ] [ lclat_index ] ; int lr = elevations [ lclon_index ] [ lclat_index ] ; float answer = resolve Four Points ( ul , ur , lr , ll , lat_index , lon_index ) ; return  Math . round ( answer ) ; } } return - _ NUM ; }
public synchronized void remove Observed Object (  Object Name object ) { if ( object == null ) return ; final  Observed Object o = get Observed Object ( object ) ; if ( o != null ) { observed Objects . remove ( o ) ; create Already Notified ( ) ; } }
protected void add (  Object component ) { if ( component == null ) { return ; } components . add ( component ) ; }
public  State Interactive extent_to_whole_components ( ) {  Set <  Integer > curr_group_no_set = new  Tree Set <  Integer > ( ) ;  Iterator <  Brd Item > it = items_list . iterator ( ) ; while ( it . has Next ( ) ) {  Brd Item curr_item = it . next ( ) ; if ( curr_item . get_component_no ( ) > _ NUM ) { curr_group_no_set . add ( curr_item . get_component_no ( ) ) ; } }  Set <  Brd Item > new_selected_items = new  Tree Set <  Brd Item > ( ) ; new_selected_items . add All ( items_list ) ;  Iterator <  Integer > it2 = curr_group_no_set . iterator ( ) ; while ( it2 . has Next ( ) ) { int curr_group_no = it2 . next ( ) ; new_selected_items . add All ( r_brd . get_component_items ( curr_group_no ) ) ; } if ( new_selected_items . is Empty ( ) ) { return return_state ; } items_list = new_selected_items ; actlog_start_scope (  Logfile Scope .  EXTEND_ TO_ WHOLE_ COMPONENTS ) ; i_brd . repaint ( ) ; return this ; }
public void add Point (  Location location ) { points . add ( location ) ; }
private static  String pad Left (  String s , int min Length ) { return  String . format ( _ STR + min Length + _ STR , s ) ; }
protected synchronized void on Send Accepted (  Record Buffer <  R > buffer ) { logger . trace ( _ STR , name ( ) , buffer ) ; throttler . on Send Accepted ( ) ; active Send Tasks . increment And Get ( ) ; }
public void add Add Delete Buttons ( ) {  JButton delete Button = new  JButton ( _ STR ) ; delete Button . set Action (  Raster Plot Actions . get Remove Source Action ( this ) ) ;  JButton add Button = new  JButton ( _ STR ) ; add Button . set Action (  Raster Plot Actions . get Add Source Action ( this ) ) ; button Panel . add ( delete Button ) ; button Panel . add ( add Button ) ; }
Key Set Validator (  Set <  Integer Key > keys ) { if ( keys == null ) throw new  Illegal Argument Exception ( ) ; this . keys = keys ; }
public static void consolidate (  Properties ctx ) {  String sql = _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR ;  Prepared Statement pstmt = null ;  Result Set rs = null ; int success = _ NUM ; int errors = _ NUM ; try { pstmt =  DB . prepare Statement ( sql , null ) ; pstmt . set Int ( _ NUM ,  Env . get AD_ Client_ ID ( ctx ) ) ; rs = pstmt . execute Query ( ) ; while ( rs . next ( ) ) {  MMatch PO po1 = new  MMatch PO ( ctx , rs , null ) ; if ( rs . next ( ) ) {  MMatch PO po2 = new  MMatch PO ( ctx , rs , null ) ; if ( po1 . get M_ In Out Line_ ID ( ) != _ NUM && po1 . get C_ Invoice Line_ ID ( ) == _ NUM && po2 . get M_ In Out Line_ ID ( ) == _ NUM && po2 . get C_ Invoice Line_ ID ( ) != _ NUM ) {  String s1 = _ STR + po2 . get C_ Invoice Line_ ID ( ) + _ STR + po1 . get M_ Match PO_ ID ( ) ; int no1 =  DB . execute Update ( s1 , null ) ; if ( no1 != _ NUM ) { errors ++ ; s_log . warning ( _ STR + po1 . get M_ Match PO_ ID ( ) ) ; continue ; }  String s2 = _ STR ; int no2 =  DB . execute Update ( s2 , po2 . get M_ Match PO_ ID ( ) , null ) ;  String s3 = _ STR ; int no3 =  DB . execute Update ( s3 , po2 . get M_ Match PO_ ID ( ) , null ) ; if ( no2 == _ NUM && no3 == _ NUM ) success ++ ; else { s_log . warning ( _ STR + po2 . get M_ Match PO_ ID ( ) + _ STR + no2 + _ STR + no3 ) ; errors ++ ; } } } } } catch (  Exception e ) { s_log . log (  Level .  SEVERE , sql , e ) ; } finally {  DB . close ( rs , pstmt ) ; rs = null ; pstmt = null ; } if ( errors == _ NUM && success == _ NUM ) ; else s_log . info ( _ STR + success + _ STR + errors ) ; }
public  Integer Interleaved Raster (  Sample Model sample Model ,  Data Buffer data Buffer ,  Point origin ) { this ( sample Model , data Buffer , new  Rectangle ( origin . x , origin . y , sample Model . get Width ( ) , sample Model . get Height ( ) ) , origin , null ) ; }
@  Override public boolean long Click (  Selector obj ,  String corner ) throws  Ui Object Not Found Exception { return long Click ( device . find Object ( obj . to Ui Selector ( ) ) , corner ) ; }
public static boolean is Numeric (  String s ) { try {  Double . parse Double ( s ) ; return _ BOOL ; } catch (  Exception e ) { return _ BOOL ; } }
public void add Listener ( final  IDebugger Chooser Panel Listener listener ) { m_listeners . add Listener ( listener ) ; }
public void inserts (  String ext File ,  String orig File Name ,  String tag ) throws  IOException {  String content = get Matched ( ext File ) ; if ( content . length ( ) > _ NUM ) { content += _ STR + tag ;  String orig = get File Content ( orig File Name ) ; orig =  String Utils . str Replace All ( orig , tag , content ) ; write To File ( orig File Name , orig ) ; } }
@  GET @  Produces ( {  Media Type .  TEXT_ PLAIN } ) @  Path ( _ STR ) public  String check Vdc Stable ( ) { return  String . value Of ( is Cluster Stable ( ) ) ; }
public static  FSize calc Text Size (  Paint paint ,  String demo Text ) {  Rect r = new  Rect ( ) ; paint . get Text Bounds ( demo Text , _ NUM , demo Text . length ( ) , r ) ; return new  FSize ( r . width ( ) , r . height ( ) ) ; }
protected void perform Update ( final boolean update Input ) { perform Update ( update Input , null ) ; }
public static void write ( float lt , float ln ,  Image image , int image_width , int image_height ,  Link Properties properties ,  Data Output Stream dos ) throws  IOException ,  Interrupted Exception { int [ ] pixels = new int [ image_width * image_height ] ;  Pixel Grabber pixelgrabber = new  Pixel Grabber ( image , _ NUM , _ NUM , image_width , image_height , pixels , _ NUM , image_width ) ; pixelgrabber . grab Pixels ( ) ;  Link Raster . write ( lt , ln , image_width , image_height , pixels , properties , dos ) ; }
private static void force Init (  Class < ? > cls ) { try {  Class . for Name ( cls . get Name ( ) , _ BOOL , cls . get Class Loader ( ) ) ; } catch (  Class Not Found Exception e ) { throw new  Illegal Argument Exception ( _ STR + cls , e ) ; } }
void save Offset In External Store (  String topic , int partition , long offset ) { try {  File Writer writer = new  File Writer ( storage Name ( topic , partition ) , _ BOOL ) ;  Buffered Writer buffered Writer = new  Buffered Writer ( writer ) ; buffered Writer . write ( offset + _ STR ) ; buffered Writer . flush ( ) ; buffered Writer . close ( ) ; } catch (  Exception e ) { e . print Stack Trace ( ) ; throw new  Runtime Exception ( e ) ; } }
public  Status create Status ( ) {  Status s = new  Status ( ) ; statuses . add ( s ) ; return s ; }
public static void add Servers To Site (  SSOToken sso Token ,  String site Name ,  Collection server Instance Names ) throws  SMSException ,  SSOException ,  Configuration Exception {  String site Id = get Site Id ( sso Token , site Name ) ; if ( site Id != null ) { for (  Iterator i = server Instance Names . iterator ( ) ; i . has Next ( ) ; ) {  String svr = (  String ) i . next ( ) ;  Server Configuration . add To Site ( sso Token , svr , site Name ) ; } } }
public int show Open Dialog (  Component parent ) throws  Headless Exception { set Dialog Type (  OPEN_ DIALOG ) ; return show Dialog ( parent , null ) ; }
private  String preprocess SLD (  Styled Layer Descriptor sld ) { if ( sld == null ) { return null ; }  SLDWriter Interface sld Writer =  SLDWriter Factory . create Writer ( null ) ;  Duplicating Style Visitor duplicator = new  Duplicating Style Visitor ( ) ; sld . accept ( duplicator ) ;  Styled Layer Descriptor sld Copy = (  Styled Layer Descriptor ) duplicator . get Copy ( ) ; for (  Styled Layer styled Layer : sld Copy . layers ( ) ) { if ( styled Layer instanceof  User Layer ) {  User Layer Impl user Layer = (  User Layer Impl ) styled Layer ; user Layer . set Inline Feature Datastore ( null ) ; user Layer . set Inline Feature Type ( null ) ; } }  String sld Contents = sld Writer . encode SLD ( null , sld Copy ) ; return sld Contents ; }
public void run Finalization ( ) { return ; }
private void display All String Defined In String Xml ( ) {  Simple Icon Font Text View text View = (  Simple Icon Font Text View ) find View By Id (  R . id . text_view_2 ) ;  List <  String > list = new  Array List < > ( ) ; list . add ( get String (  R . string . cubeicon_gems_logo ) ) ; list . add ( get String (  R . string . cubeicon_android ) ) ; list . add ( get String (  R . string . cubeicon_heart ) ) ;  String text =  Text Utils . join ( _ STR , list ) ; text View . set Text ( text ) ; }
private static  String wrap Line (  String log Content , int max Length Per Line ) { assert log Content != null ; if ( log Content . is Empty ( ) ) { return log Content ; } int current Index = _ NUM ;  String Builder sb = new  String Builder ( log Content . length ( ) + log Content . length ( ) / max Length Per Line ) ; while ( current Index < log Content . length ( ) ) { int current Line Length =  Math . min ( m Config . get Max Length Per Line ( ) , log Content . length ( ) - current Index ) ;  String sub Line ; int newline Index = log Content . index Of ( _ STR , current Index ) ; int this Line End = current Index + current Line Length ; if ( newline Index != - _ NUM && newline Index < this Line End ) { sub Line = log Content . substring ( current Index , newline Index ) ; current Index = newline Index + _ NUM ; } else { sub Line = log Content . substring ( current Index , this Line End ) ; current Index = this Line End ; } sb . append ( sub Line ) ; if ( current Index < log Content . length ( ) ) { sb . append ( _ STR ) ; } } return sb . to String ( ) ; }
protected void build Field Types (  Abstract Session session ) { for (  Field Definition field : get Fields ( ) ) { if ( field . get Foreign Key Field Name ( ) != null ) { add Foreign Key Constraint ( build Foreign Key Constraint ( field , session . get Platform ( ) ) ) ; } } }
public void add Notification (  Notification notification ) { notification Vector . add Element ( notification ) ; }
public static  Map <  String ,  Map <  String ,  Map <  String ,  Object > > > prepare Field (  Map <  String , ? > input Fields ,  Map <  String ,  Object > query String Map ,  Map <  String ,  List <  Object [ ] > > orig Value Map ) {  Map <  String ,  Map <  String ,  Map <  String ,  Object > > > normalized Fields = new  Linked Hash Map <  String ,  Map <  String ,  Map <  String ,  Object > > > ( ) ; for (  String field Name Raw : input Fields . key Set ( ) ) {  String field Name Root = null ;  String field Pair = null ;  Object field Value = null ; int i Pos = - _ NUM ; int i Pos2 = - _ NUM ;  Map <  String ,  Map <  String ,  Object > > sub Map = null ;  Map <  String ,  Object > sub Map2 = null ;  String field Mode = null ; field Value = input Fields . get ( field Name Raw ) ; if (  Object Type . is Empty ( field Value ) ) { continue ; } query String Map . put ( field Name Raw , field Value ) ; i Pos = field Name Raw . index Of ( _ STR ) ; if ( i Pos >= _ NUM ) {  String suffix = field Name Raw . substring ( i Pos + _ NUM ) ; i Pos2 = suffix . index Of ( _ STR ) ; if ( i Pos2 == _ NUM ) { continue ; } } if ( i Pos < _ NUM ) { field Name Root = field Name Raw ; field Pair = _ STR ; field Mode = _ STR ; } else { field Name Root = field Name Raw . substring ( _ NUM , i Pos ) ;  String suffix = field Name Raw . substring ( i Pos + _ NUM ) ; i Pos2 = suffix . index Of ( _ STR ) ; if ( i Pos2 < _ NUM ) { if ( suffix . starts With ( _ STR ) ) { field Pair = suffix ; field Mode = _ STR ; } else { field Pair = _ STR ; field Mode = suffix ; } } else {  String tkn0 = suffix . substring ( _ NUM , i Pos2 ) ;  String tkn1 = suffix . substring ( i Pos2 + _ NUM ) ; if ( tkn0 . starts With ( _ STR ) ) { field Pair = tkn0 ; field Mode = tkn1 ; } else { field Pair = tkn1 ; field Mode = tkn0 ; } } } sub Map = normalized Fields . get ( field Name Root ) ; if ( sub Map == null ) { sub Map = new  Linked Hash Map <  String ,  Map <  String ,  Object > > ( ) ; normalized Fields . put ( field Name Root , sub Map ) ; } sub Map2 = sub Map . get ( field Pair ) ; if ( sub Map2 == null ) { sub Map2 = new  Linked Hash Map <  String ,  Object > ( ) ; sub Map . put ( field Pair , sub Map2 ) ; } sub Map2 . put ( field Mode , field Value ) ;  List <  Object [ ] > orig List = orig Value Map . get ( field Name Root ) ; if ( orig List == null ) { orig List = new  Linked List <  Object [ ] > ( ) ; orig Value Map . put ( field Name Root , orig List ) ; }  Object [ ] orig Values = { field Name Raw , field Value } ; orig List . add ( orig Values ) ; } return normalized Fields ; }
public void deselect All ( final boolean should Fire Events ) { check Widget ( ) ; items . add All ( selection ) ; final  List <  DLItem > deselected Items = new  Array List <  DLItem > ( ) ; for ( final  DLItem item : selection ) { item . set Last Action (  LAST_ ACTION .  DESELECTION ) ; deselected Items . add ( item ) ; if ( should Fire Events ) { fire Selection Event ( item ) ; } } fire Selection Change Event ( deselected Items ) ; selection . clear ( ) ; redraw Tables ( ) ; }
public void trim Tree ( ) { boolean needs Trim = m_root != null ; while ( needs Trim ) { needs Trim = _ BOOL ;  Enumeration en = m_root . preorder Enumeration ( ) ; while ( m_root . get Child Count ( ) > _ NUM && en . has More Elements ( ) ) {  MTree Node nd = (  MTree Node ) en . next Element ( ) ; if ( nd . is Summary ( ) && nd . get Child Count ( ) == _ NUM ) { nd . remove From Parent ( ) ; needs Trim = _ BOOL ; } } } }
public void add Listener (  Tap Listener listener ) { if ( ! m Listeners . contains ( listener ) ) { m Listeners . add ( listener ) ; } }
@  Override public boolean equals (  Object obj ) { return ( obj instanceof  String Compare ) ; }
public static double [ ] udary ( int n ) { double d [ ] = new double [ n ] ; for ( int i = _ NUM ; i < n ; i ++ ) { d [ i ] =  R . next Double ( ) ; } return d ; }
public void store (  Table metadata ) {  String key = generate Key ( metadata . get Schema ( ) , metadata . get Name ( ) ) ; cache . put ( key , metadata ) ; }
public void current Task Session (  Compute Task Session ses ) { curr Sess . set ( ses ) ; }
final protected  Outgoing Batch requery If Enough Time Has Passed ( long ts ,  Outgoing Batch current Batch ) { if (  System . current Time Millis ( ) - ts >  MS_ PASSED_ BEFORE_ BATCH_ REQUERIED ) { current Batch = outgoing Batch Service . find Outgoing Batch ( current Batch . get Batch Id ( ) , current Batch . get Node Id ( ) ) ; } return current Batch ; }
public static  Redeem Data of (  ECKey key ,  Script program ) { check Argument ( program . is Sent To Address ( ) || program . is Sent To Raw Pub Key ( ) ) ; return key != null ? new  Redeem Data (  Collections . singleton List ( key ) , program ) : null ; }
@  Override public void clear ( ) { from List . clear ( ) ; }
public  Comparable find (  Comparable x ) { null Node . element = x ; current = header . right ; for ( ; ; ) { if ( x . compare To ( current . element ) < _ NUM ) current = current . left ; else if ( x . compare To ( current . element ) > _ NUM ) current = current . right ; else if ( current != null Node ) return current . element ; else return null ; } }
int fp1 ( int level ) {  Object x = null ; if ( level > _ NUM ) x = new  Object ( ) ; if ( level > _ NUM ) return x . hash Code ( ) ; return _ NUM ; }
private static int to Digit ( final char ch , final int index ) { final int digit =  Character . digit ( ch , _ NUM ) ; if ( digit == - _ NUM ) { throw new  Runtime Exception ( _ STR + ch + _ STR + index ) ; } return digit ; }
public  JSONObject to JSON ( ) throws  JSONException {  JSONObject json = new  JSONObject ( ) ; if ( entries . size ( ) > _ NUM ) {  JSONObject history = new  JSONObject ( ) ; for (  Entry e : entries ) { history . put ( e . push Id , e . timestamp ) ; } json . put ( _ STR , history ) ; } json . put Opt ( _ STR , last Time ) ; return json ; }
public static  Key Store create (  Key Store Type key Store Type ) throws  Crypto Exception ,  IOException { if ( ! key Store Type . is File Based ( ) ) { throw new  Crypto Exception (  Message Format . format ( res . get String ( _ STR ) , key Store Type . jce ( ) ) ) ; }  Key Store key Store = get Key Store Instance ( key Store Type ) ; try { key Store . load ( null , null ) ; } catch (  Certificate Exception ex ) { throw new  Crypto Exception (  Message Format . format ( res . get String ( _ STR ) , key Store Type ) , ex ) ; } catch (  No Such Algorithm Exception ex ) { throw new  Crypto Exception (  Message Format . format ( res . get String ( _ STR ) , key Store Type ) , ex ) ; } return key Store ; }
public static void init (  Context context ) {  Shared Preferences prefs =  Preference Manager . get Default Shared Preferences ( context ) ; prefs . register On Shared Preference Change Listener ( null ) ; }
@  Override protected void initialize ( ) { super . initialize ( ) ; m_ Words = new  Hash Set <  String > ( ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; m_ Words . add ( _ STR ) ; }
public  Principal Entry (  String principal Class ,  String principal Name ) { if ( principal Class == null || principal Name == null ) throw new  Null Pointer Exception (  Resources Mgr . get String ( _ STR ) ) ; this . principal Class = principal Class ; this . principal Name = principal Name ; }
public boolean is Valid ( ) { try { my Certificate . check Validity ( ) ; return _ BOOL ; } catch (  Exception e ) { return _ BOOL ; } }
private boolean read Line (  Input Stream in ,  String Buffer buf ) throws  IOException { while ( _ BOOL ) { int c = in . read ( ) ; if ( c < _ NUM ) return ( buf . length ( ) > _ NUM ) ; if ( c == _ STR ) { in . mark ( _ NUM ) ; c = in . read ( ) ; if ( c != _ STR ) in . reset ( ) ; return ( _ BOOL ) ; } if ( c == _ STR ) return ( _ BOOL ) ; buf . append ( ( char ) c ) ; } }
private void convert Outer Join ( final  String Builder target , final  Char Sequence outer Join ) throws  FBSQLParse Exception { target . append ( outer Join ) ; }
public  Input Stream read ( ) { return new  Byte Array Input Stream ( data ) ; }
private  Diff Part decode Replace ( final int block Size_ S , final int block Size_ E , final int block Size_ L ) throws  Unsupported Encoding Exception ,  Decoding Exception { if ( block Size_ S < _ NUM || block Size_ E < _ NUM || block Size_ L < _ NUM ) { throw new  Decoding Exception ( _ STR + block Size_ S + _ STR + block Size_ E + _ STR + block Size_ L ) ; } int s = r . read ( block Size_ S ) ; int e = r . read ( block Size_ E ) ; int l = r . read ( block Size_ L ) ;  Byte Array Output Stream output = new  Byte Array Output Stream ( ) ; for ( int i = _ NUM ; i < l ; i ++ ) { output . write ( r . read Byte ( ) ) ; }  Diff Part part = new  Diff Part (  Diff Action .  REPLACE ) ; part . set Start ( s ) ; part . set Length ( e ) ; part . set Text ( output . to String (  WIKIPEDIA_ ENCODING ) ) ; return part ; }
public void do Prepare ( ) { synchronized (  LAYERWORKER_ LOCK ) { if ( layer Worker Queue ) { return ; }  ISwing Worker <  OMGraphic List > current Layer Worker = layer Worker ; if ( current Layer Worker != null ) { layer Worker Queue = _ BOOL ; if ( interruptable ) { current Layer Worker . interrupt ( ) ; } return ; } set Layer Worker ( create Layer Worker ( ) ) ; } }
protected void fill ( ) throws  IOException { check Closed ( ) ; if ( ( len = in . read ( buf ) ) > _ NUM ) { inf . set Input ( buf , _ NUM , len ) ; } }
protected  String s (  Object obj ) { return obj . to String ( ) ; }
public final void go To Last Page ( ) { view Pager . set Current Item ( pages . size ( ) - _ NUM ) ; }
public  List <  Class < ? > > parameter List ( ) { return  Collections . unmodifiable List (  Arrays . as List ( ptypes . clone ( ) ) ) ; }
private static void add Rules (  List <  String > batch List ,  List <  Rule > rules To Add ) {  String add Statement = _ STR +  RULES_ TABLE + _ STR + _ STR + _ STR + _ STR + _ STR ; for (  Rule rule : rules To Add ) { batch List . add (  String . format ( add Statement , rule . get Name ( ) , rule . get Description ( ) , rule . get Membership Rule ( ) ) ) ; } }
private synchronized void perform ( ) { if ( done ) return ; while ( my Elements . has Next ( ) ) {  Object element = my Elements . next ( ) ; if ( ! is Visited ( element ) ) { visit ( element , _ NUM ) ; } } }
private  Client create Server Client ( ) {  Client client = new  Client ( ) ; client . name = _ STR ; client . registration Token =  SENDER_ ID + _ STR ; client . profile Picture Url = _ STR ; return client ; }
public static <  T >  Completable Future <  T > exceptional Future (  Throwable t ) {  Completable Future <  T > future = new  Completable Future < > ( ) ; future . complete Exceptionally ( t ) ; return future ; }
protected void update Numeric Scores ( double [ ] predicted , double [ ] actual , double weight ) { double diff ; double sum Err = _ NUM , sum Abs Err = _ NUM , sum Sqr Err = _ NUM ; double sum Prior Abs Err = _ NUM , sum Prior Sqr Err = _ NUM ; for ( int i = _ NUM ; i < m_ Num Classes ; i ++ ) { diff = predicted [ i ] - actual [ i ] ; sum Err += diff ; sum Abs Err +=  Math . abs ( diff ) ; sum Sqr Err += diff * diff ; diff = ( m_ Class Priors [ i ] / m_ Class Priors Sum ) - actual [ i ] ; sum Prior Abs Err +=  Math . abs ( diff ) ; sum Prior Sqr Err += diff * diff ; } m_ Sum Err += weight * sum Err / m_ Num Classes ; m_ Sum Abs Err += weight * sum Abs Err / m_ Num Classes ; m_ Sum Sqr Err += weight * sum Sqr Err / m_ Num Classes ; m_ Sum Prior Abs Err += weight * sum Prior Abs Err / m_ Num Classes ; m_ Sum Prior Sqr Err += weight * sum Prior Sqr Err / m_ Num Classes ; }
public boolean check Modifiers (  Mouse Event e ) { return ( e . get Modifiers ( ) & modifiers ) != _ NUM ; }
public void test Shared Name Simple ( ) throws  Exception {  Byte Array Output Stream out = new  Byte Array Output Stream ( ) ;  Smile Generator gen = smile Generator ( out , _ BOOL ) ; gen . write Start Array ( ) ; gen . write Start Object ( ) ; gen . write Number Field ( _ STR , _ NUM ) ; gen . write End Object ( ) ; gen . write Start Object ( ) ; gen . write Number Field ( _ STR , _ NUM ) ; gen . write End Object ( ) ; gen . write End Array ( ) ; gen . close ( ) ; byte [ ] result = out . to Byte Array ( ) ; assert Equals ( _ NUM , result . length ) ; }
public void lazy KBest Extract On HG (  Hyper Graph hg , int top N ,  Buffered Writer out ) throws  IOException { reset State ( ) ; if ( null == hg . goal Node ) return ; for ( int k = _ NUM ; k <= top N ; k ++ ) {  String hyp Str = get Kth Hyp ( hg . goal Node , k ) ; if ( null == hyp Str ) break ; out . write ( hyp Str ) ; out . write ( _ STR ) ; out . flush ( ) ; } }
private void migrate Block Snapshots ( ) { log . info ( _ STR ) ;  Db Client db Client = get Db Client ( ) ;  List <  URI > block Snapshot URIs = db Client . query By Type (  Block Snapshot . class , _ BOOL ) ;  Iterator <  Block Snapshot > block Snapshots = db Client . query Iterative Objects (  Block Snapshot . class , block Snapshot URIs , _ BOOL ) ;  List <  Block Object > block Objects = new  Array List <  Block Object > ( ) ; while ( block Snapshots . has Next ( ) ) { block Objects . add ( block Snapshots . next ( ) ) ; } migrate Block Objects ( block Objects ) ; }
private  String post RPChange Vpool Steps (  Workflow workflow ,  String wait For ,  List <  Volume Descriptor > volume Descriptors ,  String task Id ) {  List <  Volume Descriptor > rp Volume Descriptors =  Volume Descriptor . filter By Type ( volume Descriptors , new  Volume Descriptor .  Type [ ] {  Volume Descriptor .  Type .  RP_ EXISTING_ SOURCE } , null ) ; if ( rp Volume Descriptors . is Empty ( ) ) { return wait For ; }  List <  Volume Descriptor > migrated Block Data Descriptors = new  Array List <  Volume Descriptor > ( ) ;  List <  URI > volumes With Migration = new  Array List <  URI > ( ) ; if ( volume Descriptors != null ) {  List <  Volume Descriptor > migrate Descriptors =  Volume Descriptor . filter By Type ( volume Descriptors , new  Volume Descriptor .  Type [ ] {  Volume Descriptor .  Type .  VPLEX_ MIGRATE_ VOLUME } , null ) ; if ( migrate Descriptors != null && ! migrate Descriptors . is Empty ( ) ) { s_logger . info ( _ STR ) ;  Iterator <  Volume Descriptor > migration Iter = migrate Descriptors . iterator ( ) ; while ( migration Iter . has Next ( ) ) {  Volume Descriptor migration Desc = migration Iter . next ( ) ;  Migration migration = s_db Client . query Object (  Migration . class , migration Desc . get Migration Id ( ) ) ; volumes With Migration . add ( migration . get Source ( ) ) ;  Volume migrated Volume = s_db Client . query Object (  Volume . class , migration . get Volume ( ) ) ;  Volume Descriptor migrated Block Data Desc = new  Volume Descriptor (  Volume Descriptor .  Type .  BLOCK_ DATA , migrated Volume . get Storage Controller ( ) , migrated Volume . get Id ( ) , null , migrated Volume . get Consistency Group ( ) , migration Desc . get Capabilities Values ( ) ) ; migrated Block Data Descriptors . add ( migrated Block Data Desc ) ; } } }  List <  Volume Descriptor > block Data Descriptors = new  Array List <  Volume Descriptor > ( ) ; for (  Volume Descriptor descr : rp Volume Descriptors ) {  Volume rp Existing Source = s_db Client . query Object (  Volume . class , descr . get Volume URI ( ) ) ; if (  RPHelper . is VPlex Volume ( rp Existing Source , s_db Client ) ) { s_logger . info (  String . format ( _ STR , rp Existing Source . get Label ( ) ) ) ; if ( null != rp Existing Source . get Associated Volumes ( ) ) { for (  String assoc Volume Id : rp Existing Source . get Associated Volumes ( ) ) {  Volume assoc Volume = s_db Client . query Object (  Volume . class ,  URI . create ( assoc Volume Id ) ) ; if ( volumes With Migration . contains ( assoc Volume . get Id ( ) ) ) { s_logger . info (  String . format ( _ STR , assoc Volume . get Label ( ) ) ) ; continue ; } if (  Null Column Value Getter . is Not Null Value ( assoc Volume . get Replication Group Instance ( ) ) ) {  Volume Descriptor block Data Desc = new  Volume Descriptor (  Volume Descriptor .  Type .  BLOCK_ DATA , assoc Volume . get Storage Controller ( ) , assoc Volume . get Id ( ) , null , rp Existing Source . get Consistency Group ( ) , descr . get Capabilities Values ( ) ) ; block Data Descriptors . add ( block Data Desc ) ; assoc Volume . set Consistency Group ( rp Existing Source . get Consistency Group ( ) ) ; s_db Client . update Object ( assoc Volume ) ; s_logger . info (  String . format ( _ STR , assoc Volume . get Label ( ) , rp Existing Source . get Consistency Group ( ) , assoc Volume . get Storage Controller ( ) ) ) ; } } } } } if ( ! block Data Descriptors . is Empty ( ) ) { wait For = _block Device Controller . add Steps For Create Consistency Group ( workflow , wait For , block Data Descriptors , _ STR ) ; wait For = _block Device Controller . add Steps For Update Consistency Group ( workflow , wait For , block Data Descriptors , null ) ; } block Data Descriptors . add All ( migrated Block Data Descriptors ) ; s_logger . info ( _ STR ) ; wait For = _replica Device Controller . add Steps For Create Volumes ( workflow , wait For , block Data Descriptors , task Id ) ; return wait For ; }
private  String strip Tags (  String string ) { return string . replace All ( _ STR , _ STR ) ; }
public static double pdf ( double val , double alpha , double beta ) { if ( alpha <= _ NUM || beta <= _ NUM ||  Double . is Na N ( alpha ) ||  Double . is Na N ( beta ) ||  Double . is Na N ( val ) ) { return  Double .  Na N ; } if ( val < _ NUM || val > _ NUM ) { return _ NUM ; } if ( val == _ NUM ) { return ( alpha > _ NUM ) ? _ NUM : ( alpha < _ NUM ) ?  Double .  POSITIVE_ INFINITY : beta ; } if ( val == _ NUM ) { return ( beta > _ NUM ) ? _ NUM : ( beta < _ NUM ) ?  Double .  POSITIVE_ INFINITY : alpha ; } return  Math . exp ( - log Beta ( alpha , beta ) +  Math . log ( val ) * ( alpha - _ NUM ) +  Math . log1p ( - val ) * ( beta - _ NUM ) ) ; }
public static  ECKey signed Message To Key (  String message ,  String signature Base64 ) throws  Signature Exception { byte [ ] signature Encoded ; try { signature Encoded =  Base64 . decode ( signature Base64 ) ; } catch (  Runtime Exception e ) { throw new  Signature Exception ( _ STR , e ) ; } if ( signature Encoded . length < _ NUM ) throw new  Signature Exception ( _ STR + signature Encoded . length ) ; int header = signature Encoded [ _ NUM ] & _ NUM ; if ( header < _ NUM || header > _ NUM ) throw new  Signature Exception ( _ STR + header ) ;  Big Integer r = new  Big Integer ( _ NUM ,  Arrays . copy Of Range ( signature Encoded , _ NUM , _ NUM ) ) ;  Big Integer s = new  Big Integer ( _ NUM ,  Arrays . copy Of Range ( signature Encoded , _ NUM , _ NUM ) ) ;  ECDSASignature sig = new  ECDSASignature ( r , s ) ; byte [ ] message Bytes =  Utils . format Message For Signing ( message ) ;  Sha256 Hash message Hash =  Sha256 Hash . twice Of ( message Bytes ) ; boolean compressed = _ BOOL ; if ( header >= _ NUM ) { compressed = _ BOOL ; header -= _ NUM ; } int rec Id = header - _ NUM ;  ECKey key =  ECKey . recover From Signature ( rec Id , sig , message Hash , compressed ) ; if ( key == null ) throw new  Signature Exception ( _ STR ) ; return key ; }
private static  Grid Uri Deployment File Processor Result process No Descriptor File (  File file ,  String uri ,  Ignite Logger log ) throws  Ignite Spi Exception {  Class Loader cls Ldr =  Grid Uri Deployment Class Loader Factory . create (  U . grid Class Loader ( ) , file , log ) ;  Set <  Class < ? extends  Compute Task < ? , ? > > > clss =  Grid Uri Deployment Discovery . get Classes ( cls Ldr , file ) ;  Grid Uri Deployment File Processor Result res = new  Grid Uri Deployment File Processor Result ( ) ; res . set File ( file ) ; res . set Class Loader ( cls Ldr ) ; if ( clss != null ) {  List <  Class < ? extends  Compute Task < ? , ? > > > valid Tasks = new  Array List < > ( clss . size ( ) ) ; for (  Class < ? extends  Compute Task < ? , ? > > cls : clss ) { if ( is Allowed Task Class ( cls ) ) { if ( log . is Debug Enabled ( ) ) log . debug ( _ STR + cls . get Name ( ) ) ; valid Tasks . add ( cls ) ; } } if ( ! valid Tasks . is Empty ( ) ) res . set Task Classes ( valid Tasks ) ; else if ( log . is Debug Enabled ( ) ) log . debug ( _ STR + file . get Absolute Path ( ) + _ STR +  U . hide Password ( uri ) + _ STR ) ; } return res ; }
public void test Get Servlet Run As Role ( ) throws  Exception {  String xml =  WEBAPP_ TEST_ HEADER + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR ;  Web Xml web Xml =  Web Xml Io . parse Web Xml ( new  Byte Array Input Stream ( xml . get Bytes ( _ STR ) ) , get Entity Resolver ( ) ) ;  String role Name =  Web Xml Utils . get Servlet Run As Role Name ( web Xml , _ STR ) ; assert Equals ( _ STR , role Name ) ; }
protected void add (  String field ) { record . add (  Objects . require Non Null ( field ) ) ; }
public static void print (  Object message ) { if ( ! is Disabled ( ) ) { print (  String . value Of ( message ) ) ; } }
private void read Object (  Object Input Stream s ) throws  Invalid Object Exception { throw new  Invalid Object Exception ( _ STR ) ; }
public int hash Code ( ) { if (  Thread . interrupted ( ) ) throw new  Runtime Exception ( ) ; int acc = _ NUM ; int c = _ NUM ; c = op . ordinal ( ) ; acc = acc * _ NUM + c ; c = low ; acc = acc * _ NUM + c ; c = high ; acc = acc * _ NUM + c ; if ( lit == null ) { acc *= _ NUM ; } else { acc = acc * _ NUM + lit . hash Code ( ) ; } if ( unary Arg == null ) { acc *= _ NUM ; } else { acc = acc * _ NUM + unary Arg . hash Code ( ) ; } if ( cats == null ) { acc *= _ NUM ; } else { acc = acc * _ NUM + cats . hash Code ( ) ; } if ( alts == null ) { acc *= _ NUM ; } else { acc = acc * _ NUM + alts . hash Code ( ) ; } if ( str Op == null ) { acc *= _ NUM ; } else { acc = acc * _ NUM + str Op . hash Code ( ) ; } return acc ; }
public void add Member (  Stream member ) { member Set . add ( member ) ; }
public static  String date To String (  Date date ) {  Simple Date Format formatter = new  Simple Date Format (  ISO_ DATE_ FORMAT ) ; formatter . set Time Zone (  Time Zone . get Time Zone ( _ STR ) ) ; return formatter . format ( date ) ; }
public  String app_source_path (  String app_class ) {  String filename = app_class . replace ( _ STR , _ STR ) ; filename = filename . replace First ( _ STR , _ STR ) ; if ( filename . index Of ( _ STR ) > _ NUM ) { filename = filename . substring ( _ NUM , filename . index Of ( _ STR ) ) ; } return _ STR + filename + _ STR ; }
public void destination (  Object destination ) { this . destination =  Objects . require Non Null ( destination ) ; }
private  Boot Util ( ) { throw new  Assertion Error ( _ STR ) ; }
private static  String as Http Date ( long date ) {  Simple Date Format date Format = new  Simple Date Format ( _ STR ,  Locale .  US ) ; return date Format . format ( new  Date ( date ) ) ; }
public  List <  Element > find (  String selector ) {  String [ ] ss = selector . split ( _ STR ) ;  List <  Element > list = new  Array List <  Element > ( ) ; list . add ( d ) ; for (  String s : ss ) { if (  X . is Empty ( s ) ) { continue ; } list = _find ( list , s ) ; } return list ; }
public  Respoke Client create Client (  Context app Context ) { context = app Context ;  Respoke Client new Client = new  Respoke Client ( ) ; instances . add ( new Client ) ; return new Client ; }
@  Override public synchronized void parse (  Input Stream in ,  String base URI ) throws  IOException ,  RDFParse Exception ,  RDFHandler Exception { if ( in == null ) { throw new  Illegal Argument Exception ( _ STR ) ; } if ( base URI == null ) { throw new  Illegal Argument Exception ( _ STR ) ; }  Input Source input Source = new  Input Source ( new  BOMInput Stream ( in , _ BOOL ) ) ; input Source . set System Id ( base URI ) ; parse ( input Source ) ; }
public static  Date parse Date (  String date Value ,  Collection date Formats ,  Date start Date ) throws  Date Parse Exception { if ( date Value == null ) { throw new  Illegal Argument Exception ( _ STR ) ; } if ( date Formats == null ) { date Formats =  DEFAULT_ PATTERNS ; } if ( start Date == null ) { start Date =  DEFAULT_ TWO_ DIGIT_ YEAR_ START ; } if ( date Value . length ( ) > _ NUM && date Value . starts With ( _ STR ) && date Value . ends With ( _ STR ) ) { date Value = date Value . substring ( _ NUM , date Value . length ( ) - _ NUM ) ; }  Simple Date Format date Parser = null ;  Iterator format Iter = date Formats . iterator ( ) ; while ( format Iter . has Next ( ) ) {  String format = (  String ) format Iter . next ( ) ; if ( date Parser == null ) { date Parser = new  Simple Date Format ( format ,  Locale .  US ) ; date Parser . set Time Zone (  Time Zone . get Time Zone ( _ STR ) ) ; date Parser . set2 Digit Year Start ( start Date ) ; } else { date Parser . apply Pattern ( format ) ; } try { return date Parser . parse ( date Value ) ; } catch (  Parse Exception pe ) { } } throw new  Date Parse Exception ( _ STR + date Value ) ; }
public  Json Object remove (  String name ) { if ( name == null ) { throw new  Null Pointer Exception ( _ STR ) ; } int index = index Of ( name ) ; if ( index != - _ NUM ) { table . remove ( index ) ; names . remove ( index ) ; values . remove ( index ) ; } return this ; }
public static  Map <  String ,  List <  Table Block Info > > combine Node Block Maps (  List <  Map <  String ,  List <  Table Block Info > > > maps Of Node Block Mapping ) {  Map <  String ,  List <  Table Block Info > > combined Map = new  Hash Map <  String ,  List <  Table Block Info > > (  Carbon Common Constants .  DEFAULT_ COLLECTION_ SIZE ) ; for (  Map <  String ,  List <  Table Block Info > > each Map : maps Of Node Block Mapping ) { for (  Map .  Entry <  String ,  List <  Table Block Info > > each Entry : each Map . entry Set ( ) ) {  String node = each Entry . get Key ( ) ;  List <  Table Block Info > blocks = each Entry . get Value ( ) ; if ( null != combined Map . get ( node ) ) {  List <  Table Block Info > blocks Already Present = combined Map . get ( node ) ; blocks Already Present . add All ( blocks ) ; } else { combined Map . put ( node , blocks ) ; } } } return combined Map ; }
public int read ( ) throws  IOException { synchronized ( lock ) { char [ ] char Array = new char [ _ NUM ] ; if ( read ( char Array , _ NUM , _ NUM ) != - _ NUM ) { return char Array [ _ NUM ] ; } return - _ NUM ; } }
protected  Print Writer test Output ( ) { return writer ; }
private  JCheck Box Menu Item create Check Item (  Container c ,  String txt , boolean selected ,  String setting ) {  Settings s = new  Settings ( gui .  Main Window .  GUI_ NS ) ;  JCheck Box Menu Item i = new  JCheck Box Menu Item ( txt ) ; if ( setting == null ) { i . set Selected ( selected ) ; } else { i . set Selected ( s . get Boolean ( setting , selected ) ) ; } i . add Action Listener ( this ) ; c . add ( i ) ; return i ; }
public static final  Color string To Color (  String str ) { if ( ( str == null ) || str . is Empty ( ) ) { return ( null ) ; } int [ ] col = string To Int Array ( str ) ; if ( col . length < _ NUM ) { return ( null ) ; } if ( col . length == _ NUM ) { return ( new  Color ( col [ _ NUM ] , col [ _ NUM ] , col [ _ NUM ] ) ) ; } else { return ( new  Color ( col [ _ NUM ] , col [ _ NUM ] , col [ _ NUM ] , col [ _ NUM ] ) ) ; } }
public void world To Spherical (  Vector3 vec ) { if ( pj Unprojected == null ) {  String proj Str = _ STR + proj Info . get Semi Major Axis ( ) + _ STR + proj Info . get Semi Minor Axis ( ) + _ STR ; pj Unprojected =  Proj4 . new Instance ( proj Str ) ; } if ( pj Projected == null ) { pj Projected =  Proj4 . new Instance ( proj4 String ) ; } try { vec . to Array ( coord ) ; pj Projected . transform ( pj Unprojected , coord ) ; vec . set X (  Math . to Degrees ( coord [ _ NUM ] ) ) ; vec . set Y (  Math . to Degrees ( coord [ _ NUM ] ) ) ; } catch (  Exception e ) { e . print Stack Trace ( ) ; } }
public static byte [ ] encode String ( final  String str ) { return  Dna Utils . encode Array ( str . get Bytes ( ) ) ; }
public void draw Rendered Image (  Rendered Image img ,  Affine Transform xform ) { m Graphics . draw Rendered Image ( img , xform ) ; }
public boolean read Bit ( ) throws  IOException { if ( bit Field == - _ NUM ) { bit Field = in . read ( ) ; if ( bit Field == - _ NUM ) { throw new  EOFException ( ) ; } mask = _ NUM ; } boolean bit = ( bit Field & mask ) != _ NUM ; if ( ( mask <<= _ NUM ) == _ NUM ) { bit Field = - _ NUM ; } return bit ; }
protected void load Schemas (  File [ ] files ) { for (  File file : files ) {  File Reader file Reader = null ;  Buffered Reader reader = null ; try { file Reader = new  File Reader ( file ) ; reader = new  Buffered Reader ( file Reader ) ; load Schema From Reader ( reader ) ; } catch (  IOException exception ) { log . warn ( _ STR , exception ) ; } finally { try { if ( reader != null ) { reader . close ( ) ; } if ( file Reader != null ) { file Reader . close ( ) ; } } catch (  IOException exception ) { log . warn ( _ STR , exception ) ; } } } }
@  Override public void add Property Change Listener (  String property Name ,  Property Change Listener listener ) { property Change Support . add Property Change Listener ( property Name , listener ) ; }
public  File create New Folder (  File containing Dir ) throws  IOException { if ( containing Dir == null ) { throw new  IOException ( _ STR ) ; }  File new Folder ; new Folder = create File Object ( containing Dir , new Folder String ) ; int i = _ NUM ; while ( new Folder . exists ( ) && i < _ NUM ) { new Folder = create File Object ( containing Dir ,  Message Format . format ( new Folder Next String , new  Integer ( i ) ) ) ; i ++ ; } if ( new Folder . exists ( ) ) { throw new  IOException ( _ STR + new Folder . get Absolute Path ( ) ) ; } else { new Folder . mkdirs ( ) ; } return new Folder ; }
public  Resources Poet add String Array (  String name , @  Not Null  List <  String > values ) {  Element element = document . create Element ( _ STR ) ; element . set Attribute ( _ STR , name ) ; for (  String value : values ) {  Element value Element = document . create Element ( _ STR ) ; value Element . append Child ( document . create Text Node ( value ) ) ; element . append Child ( value Element ) ; } resource Element . append Child ( element ) ; return this ; }
public  Builder add Action (  String action Type ,  Action action ) { m Actions . add ( new  Action Pair ( action Type , action ) ) ; return this ; }
void fill Delta Entries (  Set <  Page Leaf Entry > entries ,  Row row , int tail ) { int row Offset = _row Head ; byte [ ] buffer = _buffer ; while ( row Offset < tail ) { int code = buffer [ row Offset ] &  CODE_ MASK ; int len = get Length ( code , row ) ; if ( code ==  INSERT || code ==  REMOVE ) {  Page Leaf Entry entry = new  Page Leaf Entry ( this , row , row Offset , len , code ) ; entries . add ( entry ) ; } row Offset += len ; } }
void read LOG ( ) throws  IOException { while ( _ BOOL ) {  String  S = isr . read Line ( ) ; if (  S == null ) return ; if (  S . starts With ( _ STR ) ) return ; } }
private void populate Db Options (  String db Product ,  Element db Options Element ,  Map <  String ,  String > db Options Map ) {  Node List db Options = db Options Element . get Elements By Tag Name ( _ STR ) ; for ( int i = _ NUM ; i < db Options . get Length ( ) ; i ++ ) {  Element db Option = (  Element ) db Options . item ( i ) ; if ( ! db Product . equals Ignore Case ( db Option . get Attribute ( _ STR ) ) ) { continue ; } db Options Map . put ( db Option . get Attribute ( _ STR ) , db Option . get Attribute ( _ STR ) ) ; } }
public  Image Transferable (  Image image ) { this . image = image ; }
public  Sequence Resource (  String mimetype ,  Resource ... resources ) { this ( mimetype ,  Arrays . as List ( resources ) ) ; }
private boolean is Named Param (  String arg ) { return arg . starts With ( _ STR ) && ( arg . index Of ( _ STR ) > _ NUM && valid First Char ( arg . char At ( _ NUM ) ) ) ; }
private boolean validate Folder (  File default Fingerprint Folder ) { return default Fingerprint Folder . exists ( ) && default Fingerprint Folder . can Read ( ) && default Fingerprint Folder . can Write ( ) ; }
private double lin To Mel Freq ( double input Freq ) { return ( _ NUM * (  Math . log ( _ NUM + input Freq / _ NUM ) /  Math . log ( _ NUM ) ) ) ; }
public void on Update From Close To Peek ( float percentage ) { if ( ! is Visible ( ) ) return ; m Height Px =  Math . round ( m Default Height Px ) ; }
public static byte [ ] random Bytes ( int length ) { byte [ ] bytes = new byte [ length ] ;  SEEDED_ RANDOM . next Bytes ( bytes ) ; return bytes ; }
@  Override public  String to String ( ) {  String Buffer  Bf String = new  String Buffer ( ) ;  Bf String . append ( _ STR ) ; if ( m_starting == null ) {  Bf String . append ( _ STR ) ; } else {  Bf String . append ( start Set To String ( ) + _ STR ) ; }  Bf String . append ( _ STR ) ; if ( m_search Direction ==  SELECTION_ BACKWARD ) {  Bf String . append ( _ STR ) ; } else { if ( m_search Direction ==  SELECTION_ FORWARD ) {  Bf String . append ( _ STR ) ; } else {  Bf String . append ( _ STR ) ; } }  Bf String . append ( _ STR + m_max Stale + _ STR ) ;  Bf String . append ( _ STR + m_total Evals + _ STR ) ;  Bf String . append ( _ STR +  Utils . double To String (  Math . abs ( m_best Merit ) , _ NUM , _ NUM ) + _ STR ) ; return  Bf String . to String ( ) ; }
public synchronized void return Buf ( byte [ ] buf ) { if ( buf == null || buf . length > m Size Limit ) { return ; } m Buffers By Last Use . add ( buf ) ; int pos =  Collections . binary Search ( m Buffers By Size , buf ,  BUF_ COMPARATOR ) ; if ( pos < _ NUM ) { pos = - pos - _ NUM ; } m Buffers By Size . add ( pos , buf ) ; m Current Size += buf . length ; trim ( ) ; }
public long time ( ) { return  System . current Time Millis ( ) ; }
public void select ( int position , boolean fire Event , boolean consider Selectable Flag ) {  Item item = get Item ( position ) ; if ( item == null ) { return ; } if ( consider Selectable Flag && ! item . is Selectable ( ) ) { return ; } item . with Set Selected ( _ BOOL ) ; if ( m Position Based State Management ) { m Selections . add ( position ) ; } notify Item Changed ( position ) ; if ( m Selection Listener != null ) m Selection Listener . on Selection Changed ( item , _ BOOL ) ; if ( m On Click Listener != null && fire Event ) { m On Click Listener . on Click ( null , get Adapter ( position ) , item , position ) ; } }
public  Big Decimal invoke (  MDepreciation Workfile assetwk ,  MAsset Acct asset Acct , int  A_ Current_ Period ,  Big Decimal  Accum_ Dep ) {  String depreciation Type = get Depreciation Type ( ) ;  Big Decimal ret Value = null ; if (  CLog Mgt . is Level Finest ( ) ) { log . fine ( _ STR + depreciation Type + _ STR + assetwk + _ STR + asset Acct + _ STR +  A_ Current_ Period + _ STR +  Accum_ Dep ) ; } if ( ! can Invoke ( assetwk , asset Acct ,  A_ Current_ Period ,  Accum_ Dep ) ) { return  Big Decimal .  ZERO ; } if ( depreciation Type . equals Ignore Case ( _ STR ) ) { ret Value = apply_ SL ( assetwk , asset Acct ,  A_ Current_ Period ,  Accum_ Dep ) ; } else if ( depreciation Type . equals Ignore Case ( _ STR ) ) { ret Value = apply_ ARH_ VAR ( assetwk , asset Acct ,  A_ Current_ Period ,  Accum_ Dep ) ; } else if ( depreciation Type . equals Ignore Case ( _ STR ) ) { ret Value = apply_ ARH_ AD1 ( assetwk , asset Acct ,  A_ Current_ Period ,  Accum_ Dep ) ; } else if ( depreciation Type . equals Ignore Case ( _ STR ) ) { ret Value = apply_ ARH_ AD2 ( assetwk , asset Acct ,  A_ Current_ Period ,  Accum_ Dep ) ; } else if ( depreciation Type . equals Ignore Case ( _ STR ) ) { ret Value = apply_ ARH_ ZERO ( assetwk , asset Acct ,  A_ Current_ Period ,  Accum_ Dep ) ; } else { throw new  Asset Not Supported Exception (  COLUMNNAME_ Depreciation Type , depreciation Type ) ; } if ( ret Value == null ) { ret Value =  Big Decimal .  ZERO ; } ret Value = ret Value . set Scale ( get Precision ( ) ,  Rounding Mode .  HALF_ UP ) ; if (  CLog Mgt . is Level Finest ( ) ) log . fine ( _ STR + ret Value ) ; return ret Value ; }
private void read Affix File (  Input Stream affix Stream ,  Charset Decoder decoder ) throws  IOException ,  Parse Exception {  Tree Map <  String ,  List <  Integer > > prefixes = new  Tree Map < > ( ) ;  Tree Map <  String ,  List <  Integer > > suffixes = new  Tree Map < > ( ) ;  Map <  String ,  Integer > seen Patterns = new  Hash Map < > ( ) ; seen Patterns . put ( _ STR , _ NUM ) ; patterns . add ( null ) ;  Map <  String ,  Integer > seen Strips = new  Linked Hash Map < > ( ) ; seen Strips . put ( _ STR , _ NUM ) ;  Line Number Reader reader = new  Line Number Reader ( new  Input Stream Reader ( affix Stream , decoder ) ) ;  String line = null ; while ( ( line = reader . read Line ( ) ) != null ) { if ( reader . get Line Number ( ) == _ NUM && line . starts With ( _ STR ) ) { line = line . substring ( _ NUM ) ; } if ( line . starts With (  ALIAS_ KEY ) ) { parse Alias ( line ) ; } else if ( line . starts With (  MORPH_ ALIAS_ KEY ) ) { parse Morph Alias ( line ) ; } else if ( line . starts With (  PREFIX_ KEY ) ) { parse Affix ( prefixes , line , reader ,  PREFIX_ CONDITION_ REGEX_ PATTERN , seen Patterns , seen Strips ) ; } else if ( line . starts With (  SUFFIX_ KEY ) ) { parse Affix ( suffixes , line , reader ,  SUFFIX_ CONDITION_ REGEX_ PATTERN , seen Patterns , seen Strips ) ; } else if ( line . starts With (  FLAG_ KEY ) ) { flag Parsing Strategy = get Flag Parsing Strategy ( line ) ; } else if ( line . equals (  COMPLEXPREFIXES_ KEY ) ) { complex Prefixes = _ BOOL ; } else if ( line . starts With (  CIRCUMFIX_ KEY ) ) {  String parts [ ] = line . split ( _ STR ) ; if ( parts . length != _ NUM ) { throw new  Parse Exception ( _ STR , reader . get Line Number ( ) ) ; } circumfix = flag Parsing Strategy . parse Flag ( parts [ _ NUM ] ) ; } else if ( line . starts With (  KEEPCASE_ KEY ) ) {  String parts [ ] = line . split ( _ STR ) ; if ( parts . length != _ NUM ) { throw new  Parse Exception ( _ STR , reader . get Line Number ( ) ) ; } keepcase = flag Parsing Strategy . parse Flag ( parts [ _ NUM ] ) ; } else if ( line . starts With (  NEEDAFFIX_ KEY ) || line . starts With (  PSEUDOROOT_ KEY ) ) {  String parts [ ] = line . split ( _ STR ) ; if ( parts . length != _ NUM ) { throw new  Parse Exception ( _ STR , reader . get Line Number ( ) ) ; } needaffix = flag Parsing Strategy . parse Flag ( parts [ _ NUM ] ) ; } else if ( line . starts With (  ONLYINCOMPOUND_ KEY ) ) {  String parts [ ] = line . split ( _ STR ) ; if ( parts . length != _ NUM ) { throw new  Parse Exception ( _ STR , reader . get Line Number ( ) ) ; } onlyincompound = flag Parsing Strategy . parse Flag ( parts [ _ NUM ] ) ; } else if ( line . starts With (  IGNORE_ KEY ) ) {  String parts [ ] = line . split ( _ STR ) ; if ( parts . length != _ NUM ) { throw new  Parse Exception ( _ STR , reader . get Line Number ( ) ) ; } ignore = parts [ _ NUM ] . to Char Array ( ) ;  Arrays . sort ( ignore ) ; needs Input Cleaning = _ BOOL ; } else if ( line . starts With (  ICONV_ KEY ) || line . starts With (  OCONV_ KEY ) ) {  String parts [ ] = line . split ( _ STR ) ;  String type = parts [ _ NUM ] ; if ( parts . length != _ NUM ) { throw new  Parse Exception ( _ STR + type + _ STR , reader . get Line Number ( ) ) ; } int num =  Integer . parse Int ( parts [ _ NUM ] ) ;  FST <  Chars Ref > res = parse Conversions ( reader , num ) ; if ( type . equals ( _ STR ) ) { iconv = res ; needs Input Cleaning |= iconv != null ; } else { oconv = res ; needs Output Cleaning |= oconv != null ; } } else if ( line . starts With (  FULLSTRIP_ KEY ) ) { full Strip = _ BOOL ; } else if ( line . starts With (  LANG_ KEY ) ) { language = line . substring (  LANG_ KEY . length ( ) ) . trim ( ) ; alternate Casing = _ STR . equals ( language ) || _ STR . equals ( language ) ; } } this . prefixes = affix FST ( prefixes ) ; this . suffixes = affix FST ( suffixes ) ; int total Chars = _ NUM ; for (  String strip : seen Strips . key Set ( ) ) { total Chars += strip . length ( ) ; } strip Data = new char [ total Chars ] ; strip Offsets = new int [ seen Strips . size ( ) + _ NUM ] ; int current Offset = _ NUM ; int current Index = _ NUM ; for (  String strip : seen Strips . key Set ( ) ) { strip Offsets [ current Index ++ ] = current Offset ; strip . get Chars ( _ NUM , strip . length ( ) , strip Data , current Offset ) ; current Offset += strip . length ( ) ; } assert current Index == seen Strips . size ( ) ; strip Offsets [ current Index ] = current Offset ; }
public void add Change Listener (  Property Change Listener new Listener ) { listener . add ( new Listener ) ; }
@  Override public  Iterator iterator ( ) { return new  Entry Iterator ( set . iterator ( ) ) ; }
private boolean ends With Space (  String str ) { return str . length ( ) != _ NUM && str . char At ( str . length ( ) - _ NUM ) == _ STR ; }
private boolean key Match (  String key ,  Lazy Node token ) { if ( token . type ==  Lazy Node .  EFIELD ) {  String field = token . get String Value ( cbuf ) ; return field . equals ( key ) ; } else { int length = key . length ( ) ; if ( token . end Index - token . start Index != length ) { return _ BOOL ; } for ( int i = _ NUM ; i < length ; i ++ ) { char c = key . char At ( i ) ; if ( c != cbuf [ token . start Index + i ] ) { return _ BOOL ; } } return _ BOOL ; } }
public boolean mouse Pressed (  Mouse Event e ) { if ( show_plot_ && graph != null ) { int x = e . get X ( ) ; int y = e . get Y ( ) ; if ( ( x >= plot X ) && ( x <= plot X + plot Width ) && ( y >= plot Y ) && ( y <= plot Y + plot Width ) ) { grabbed_plot_graphics_ = _ BOOL ; prev X = x ; prev Y = y ; } } return _ BOOL ; }
public void load (  General Names general Names ) {  General Name [ ] general Names Array = general Names . get Names ( ) ; data = new  Array List <  General Name > (  Arrays . as List ( general Names Array ) ) ;  Collections . sort ( data , new  General Name Comparator ( ) ) ; fire Table Data Changed ( ) ; }
public boolean exists ( ) { return in != null ; }
public static void append To File ( final  File file , final  String contents ) throws  IOException { try (  File Output Stream fos = new  File Output Stream ( file , _ BOOL ) ) { fos . write ( contents . get Bytes ( ) ) ; } }
public void put (  String key ,  Array List <  String > value ) {  Iterator <  Pair <  String ,  Array List <  String > > > it = store . iterator ( ) ; while ( it . has Next ( ) ) {  Pair <  String ,  Array List <  String > > pair = it . next ( ) ; if ( key . equals ( pair . first ) ) { pair . second = value ; return ; } } store . add ( new  Pair < > ( key , value ) ) ; }
public double angle ( ) { return  Math . atan2 ( p1 . y - p0 . y , p1 . x - p0 . x ) ; }
public  Key Store Table Model ( ) { column Names = new  String [ _ NUM ] ; column Names [ _ NUM ] = res . get String ( _ STR ) ; column Names [ _ NUM ] = res . get String ( _ STR ) ; column Names [ _ NUM ] = res . get String ( _ STR ) ; column Names [ _ NUM ] = res . get String ( _ STR ) ; column Names [ _ NUM ] = res . get String ( _ STR ) ; column Names [ _ NUM ] = res . get String ( _ STR ) ; column Names [ _ NUM ] = res . get String ( _ STR ) ; column Names [ _ NUM ] = res . get String ( _ STR ) ; data = new  Object [ _ NUM ] [ _ NUM ] ; }
@  Override public boolean is Enabled ( ) { if ( ( attribute Selection Panel != null ) && ! is Value Only ( ) ) { return attribute Selection Panel . is Enabled ( ) ; } else { if ( text Field != null ) { return text Field . is Enabled ( ) ; } } return _ BOOL ; }
private void draw Anno Drag Indicators ( final  Graphics2 D g , final  Workflow Annotation anno , final  Rectangle2 D loc , final boolean printing ) { if ( printing ) { return ; }  Annotation Drag Helper dragged = model . get Dragged ( ) ; if ( dragged . get Hovered Operator ( ) == null ) { return ; }  Graphics2 D g2 = (  Graphics2 D ) g . create ( ) ; int padding = _ NUM ;  Rectangle2 D op Rect = renderer Model . get Operator Rect ( dragged . get Hovered Operator ( ) ) ; op Rect = new  Rectangle2 D .  Double ( op Rect . get X ( ) , op Rect . get Y ( ) , op Rect . get Width ( ) , op Rect . get Height ( ) ) ;  Rectangle2 D shadow Rect = new  Rectangle2 D .  Double ( op Rect . get X ( ) - padding - _ NUM , op Rect . get Y ( ) - padding - _ NUM , op Rect . get Width ( ) + _ NUM * padding + _ NUM , op Rect . get Height ( ) + _ NUM * padding + _ NUM ) ; g2 . set Color (  DRAG_ LINK_ COLOR ) ; g2 . set Stroke (  DRAG_ BORDER_ STROKE ) ; g2 . draw ( shadow Rect ) ; g2 . dispose ( ) ; }
private boolean is In Transaction ( ) { return transaction != null ; }
public void start ( ) { runner = new  Thread ( this , get Shell Name ( ) ) ; runner . start ( ) ; }
private int create Folder ( ) { if ( m New Directory Name != null && m Selected Dir != null && m Selected Dir . can Write ( ) ) {  File new Dir = new  File ( m Selected Dir , m New Directory Name ) ; if ( ! new Dir . exists ( ) ) { boolean result = new Dir . mkdir ( ) ; if ( result ) { change Directory ( new Dir ) ; return  R . string . create_folder_success ; } else { return  R . string . create_folder_error ; } } else { return  R . string . create_folder_error_already_exists ; } } else if ( m Selected Dir != null && ! m Selected Dir . can Write ( ) ) { return  R . string . create_folder_error_no_write_access ; } else { return  R . string . create_folder_error ; } }
private void process Non Control Characters ( char character ) {  String Buffer buffer = new  String Buffer ( ) ; buffer . append ( character ) ; while ( has Next Char ( ) ) { character = get Next Char ( ) ; if ( character == _ STR || character == _ STR || character == _ STR || character == _ STR || character == _ STR || character == _ STR || character == _ STR ) { push Back Char ( character ) ; break ; } buffer . append ( character ) ; } display New Text ( buffer . to String ( ) ) ; }
public  Adaptable List (  IAdaptable [ ] new Children ) { this ( new Children . length ) ; for ( int i = _ NUM ; i < new Children . length ; i ++ ) { children . add ( new Children [ i ] ) ; } }
private void clear Messages ( ) { messages . clear ( ) ; }
protected void add Field Config (  Field Config Base field Config ) { field Config List . add ( field Config ) ; }
public final  String to String ( ) {  String Builder sb = new  String Builder ( _ NUM ) ; append Desc ( sb ) ; return sb . to String ( ) ; }
public void read (  Data Input Stream in ) throws  IOException { if ( in . read Int ( ) !=  FILE_ VERSION ) { }  String [ ] names = new  String [ in . read Short ( ) ] ; for ( int i = _ NUM ; i < names . length ; i ++ ) { names [ i ] = in . read UTF ( ) ; } int num = in . read Short ( ) ; for ( int i = _ NUM ; i < num ; i ++ ) { short name Id = in . read Short ( ) ; int type = in . read Byte ( ) ;  String name = in . read UTF ( ) ; def Entity ( names [ name Id ] , type |  GENERAL , name ) ; } num = in . read Short ( ) ; for ( int i = _ NUM ; i < num ; i ++ ) { short name Id = in . read Short ( ) ; int type = in . read Byte ( ) ; byte flags = in . read Byte ( ) ;  Content Model m = read Content Model ( in , names ) ;  String [ ] exclusions = read Name Array ( in , names ) ;  String [ ] inclusions = read Name Array ( in , names ) ;  Attribute List atts = read Attribute List ( in , names ) ; def Element ( names [ name Id ] , type , ( ( flags & _ NUM ) != _ NUM ) , ( ( flags & _ NUM ) != _ NUM ) , m , exclusions , inclusions , atts ) ; } }
public static double logpdf ( double x , double mu , double sigma , double xi ) { x = ( x - mu ) / sigma ; if ( x < _ NUM || ( xi < _ NUM && x > - _ NUM / xi ) ) { return  Double .  NEGATIVE_ INFINITY ; } if ( xi == _ NUM ) { return  Double .  POSITIVE_ INFINITY ; } return ( ( xi == - _ NUM ) ? _ NUM :  Math . log ( _ NUM + xi * x ) * ( - _ NUM / xi - _ NUM ) ) -  Math . log ( sigma ) ; }
public  Sdp Exception (  String message ,  Throwable root Cause ) { super ( root Cause . get Message ( ) +  Separators .  SEMICOLON + message ) ; }
@  Override public void add Property Change Listener (  String property Name ,  Property Change Listener listener ) { property Change Support . add Property Change Listener ( property Name , listener ) ; }
public static boolean is Valid Template (  String template ) { template = template . trim ( ) ; if ( template . index Of ( _ STR ) == - _ NUM ) { return _ BOOL ; }  String s = template . trim ( ) ; if ( s . last Index Of ( _ STR ) != s . length ( ) - _ NUM ) { return _ BOOL ; } if ( get Method Signature ( template ) == null ) { return _ BOOL ; } if ( get Method Body ( template ) == null ) { return _ BOOL ; } return _ BOOL ; }
public int num Attributes ( ) { return m_ Attributes . size ( ) ; }
public static  Dmn Rest Url Builder using Base Url (  String base Url ) { if ( base Url == null ) throw new  Activiti Dmn Illegal Argument Exception ( _ STR ) ; if ( base Url . ends With ( _ STR ) ) base Url = base Url . substring ( _ NUM , base Url . length ( ) - _ NUM ) ; return new  Dmn Rest Url Builder ( base Url ) ; }
public void start ( ) throws  Exception {  System . set Property ( _ STR , config ) ; if ( jmx Server != null ) { jmx Server . start ( ) ; } service = new  Cassandra Daemon ( ) ; service . init ( null ) ; service . start ( ) ; }
public boolean is Complete ( ) { return complete ; }
public  Byte Matrix encode (  String contents ) throws  Writer Exception { if ( contents == null || contents . length ( ) == _ NUM ) { throw new  Illegal Argument Exception ( _ STR ) ; } code =  Encoder . encode ( contents ,  Error Correction Level .  L ) ; return render Result ( code ,  QR_ CODE_ ELEMENT_ MULTIPLE ) ; }
public  Request cookie (  String key ,  String value ) {  Objects . require Non Null ( key ) ;  Objects . require Non Null ( value ) ; _cookies . put ( key , value ) ; return this ; }
protected void install Defaults ( ) { list . set Layout ( null ) ;  Look And Feel . install Border ( list , _ STR ) ;  Look And Feel . install Colors And Font ( list , _ STR , _ STR , _ STR ) ;  Look And Feel . install Property ( list , _ STR ,  Boolean .  TRUE ) ; if ( list . get Cell Renderer ( ) == null ) { list . set Cell Renderer ( (  List Cell Renderer ) (  UIManager . get ( _ STR ) ) ) ; }  Color sbg = list . get Selection Background ( ) ; if ( sbg == null || sbg instanceof  UIResource ) { list . set Selection Background (  UIManager . get Color ( _ STR ) ) ; }  Color sfg = list . get Selection Foreground ( ) ; if ( sfg == null || sfg instanceof  UIResource ) { list . set Selection Foreground (  UIManager . get Color ( _ STR ) ) ; }  Long l = (  Long )  UIManager . get ( _ STR ) ; time Factor = ( l != null ) ? l . long Value ( ) : _ NUM ; update Is File List ( ) ; }
public static void generate Extension Manager (  File root Folder ) throws  IOException {  File out File = new  File ( root Folder ,  REGISTRY_ PATH ) ;  String Builder builder = new  String Builder ( ) ; builder . append ( _ STR + _ STR ) ; generate Imports ( builder ) ; generate Class ( builder ) ;  File Utils . write String To File ( out File , builder . to String ( ) ) ; }
public <  T >  Future <  T > submit (  Callable <  T > task ) { return executor . submit ( task ) ; }
static void check Internal Name ( final  String name , final  String msg ) { if ( name == null || name . length ( ) == _ NUM ) { throw new  Illegal Argument Exception ( _ STR + msg + _ STR ) ; } if ( name . char At ( _ NUM ) == _ STR ) { check Desc ( name , _ BOOL ) ; } else { check Internal Name ( name , _ NUM , - _ NUM , msg ) ; } }
private boolean is Authorized (  Application User application User ,  String namespace ,  Namespace Permission Enum ... permissions ) { if ( application User != null && application User . get Namespace Authorizations ( ) != null ) { for (  Namespace Authorization current User Authorization : application User . get Namespace Authorizations ( ) ) {  List <  Namespace Permission Enum > current User Namespace Permissions = current User Authorization . get Namespace Permissions ( ) ; if ( current User Namespace Permissions == null ) { current User Namespace Permissions =  Collections . empty List ( ) ; } if (  String Utils . equals Ignore Case ( current User Authorization . get Namespace ( ) , namespace ) && current User Namespace Permissions . contains All (  Arrays . as List ( permissions ) ) ) { return _ BOOL ; } } } return _ BOOL ; }
public static  String to String Never Null (  Object o ) { return o == null ? _ STR : o . to String ( ) ; }
public void calculate Derived ( ) { x Stats . calculate Derived ( ) ; y Stats . calculate Derived ( ) ; differences Stats . calculate Derived ( ) ; correlation =  Double .  Na N ; if ( !  Double . is Na N ( x Stats . std Dev ) && !  Double . is Na N ( y Stats . std Dev ) && !  Utils . eq ( x Stats . std Dev , _ NUM ) ) { double slope = ( xy Sum - x Stats . sum * y Stats . sum / count ) / ( x Stats . sum Sq - x Stats . sum * x Stats . mean ) ; if ( !  Utils . eq ( y Stats . std Dev , _ NUM ) ) { correlation = slope * x Stats . std Dev / y Stats . std Dev ; } else { correlation = _ NUM ; } } if (  Utils . gr ( differences Stats . std Dev , _ NUM ) ) { double tval = differences Stats . mean /  Math . sqrt ( ( _ NUM / count + m_test Train Ratio ) * differences Stats . std Dev * differences Stats . std Dev ) ; if ( count > _ NUM ) { differences Probability =  Statistics .  FProbability ( tval * tval , _ NUM , ( int ) count - _ NUM ) ; } else differences Probability = _ NUM ; } else { if ( differences Stats . sum Sq == _ NUM ) { differences Probability = _ NUM ; } else { differences Probability = _ NUM ; } } differences Significance = _ NUM ; if ( differences Probability <= sig Level ) { if ( x Stats . mean > y Stats . mean ) { differences Significance = _ NUM ; } else { differences Significance = - _ NUM ; } } }
public  Driver Task create Consistency Group Clone (  Volume Consistency Group consistency Group ,  List <  Volume Clone > clones ,  List <  Capability Instance > capabilities ,  Driver Task task ,  Registry driver Registry ) { _log . info ( _ STR , consistency Group . get Storage System Id ( ) , consistency Group . get Display Name ( ) , consistency Group . get Native Id ( ) ) ;  String  VVset Name For Clone = consistency Group . get Display Name ( ) ;  Volume Details Command Result vol Result = null ;  Hash Map <  String ,  Volume Clone > clones Map = new  Hash Map <  String ,  Volume Clone > ( ) ; try {  Boolean save Snapshot = _ BOOL ;  HP3 PARApi hp3par Api = hp3par Util . get HP3 PARDevice From Native Id ( consistency Group . get Storage System Id ( ) , driver Registry ) ; for (  Volume Clone clone : clones ) { _log . info ( _ STR , clone . get Parent Id ( ) , clone . get Display Name ( ) ) ;  String generated Clone Name = clone . get Display Name ( ) ;  VVset Name For Clone = generated Clone Name . substring ( _ NUM , generated Clone Name . last Index Of ( _ STR ) ) ; _log . info ( _ STR ,  VVset Name For Clone ) ; clones Map . put ( clone . get Parent Id ( ) , clone ) ; } _log . info ( _ STR , clones Map . to String ( ) ) ;  VVSet Volume Clone [ ] result = hp3par Api . create VVset Physical Copy ( consistency Group . get Native Id ( ) ,  VVset Name For Clone , clones , save Snapshot ) ; _log . info ( _ STR , result . to String ( ) ) ; for (  VVSet Volume Clone clone Created : result ) {  Volume Clone clone = clones Map . get ( clone Created . get Parent ( ) ) ; _log . info ( _ STR , clone Created . get Values ( ) , clone . get Native Id ( ) , clone . get Parent Id ( ) ) ; vol Result = hp3par Api . get Volume Details ( clone Created . get Child ( ) ) ; _log . info ( _ STR , vol Result . get All Values ( ) ) ; clone . set Wwn ( vol Result . get Wwn ( ) ) ; clone . set Native Id ( vol Result . get Id ( ) ) ; clone . set Device Label ( vol Result . get Name ( ) ) ; clone . set Display Name ( vol Result . get Name ( ) ) ; clone . set Replication State (  Volume Clone .  Replication State .  SYNCHRONIZED ) ; clone . set Provisioned Capacity ( clone . get Requested Capacity ( ) ) ; clone . set Allocated Capacity ( clone . get Requested Capacity ( ) ) ; } task . set Status (  Driver Task .  Task Status .  READY ) ; _log . info ( _ STR , consistency Group . get Storage System Id ( ) , consistency Group . get Display Name ( ) , consistency Group . get Native Id ( ) ) ; } catch (  Exception e ) {  String msg =  String . format ( _ STR ,  VVset Name For Clone , consistency Group . get Native Id ( ) , consistency Group . get Storage System Id ( ) , e . get Message ( ) ) ; _log . error ( msg ) ; task . set Message ( msg ) ; task . set Status (  Driver Task .  Task Status .  PARTIALLY_ FAILED ) ; e . print Stack Trace ( ) ; } return task ; }
public  Amqp Message receive ( ) throws  Exception { check Closed ( ) ; return prefetch . take ( ) ; }
private boolean zz Refill ( ) throws java . io .  IOException { if ( zz Start Read > _ NUM ) {  System . arraycopy ( zz Buffer , zz Start Read , zz Buffer , _ NUM , zz End Read - zz Start Read ) ; zz End Read -= zz Start Read ; zz Current Pos -= zz Start Read ; zz Marked Pos -= zz Start Read ; zz Pushback Pos -= zz Start Read ; zz Start Read = _ NUM ; } if ( zz Current Pos >= zz Buffer . length ) { char new Buffer [ ] = new char [ zz Current Pos * _ NUM ] ;  System . arraycopy ( zz Buffer , _ NUM , new Buffer , _ NUM , zz Buffer . length ) ; zz Buffer = new Buffer ; } int num Read = zz Reader . read ( zz Buffer , zz End Read , zz Buffer . length - zz End Read ) ; if ( num Read < _ NUM ) { return _ BOOL ; } else { zz End Read += num Read ; return _ BOOL ; } }
public void send Delete Entity ( int id ) {  Array List <  Integer > ids = new  Array List <  Integer > ( _ NUM ) ; ids . add ( id ) ; send Delete Entities ( ids ) ; }
public  Server Configuration kill Bookie ( int index ) throws  Exception { if ( index >= bs . size ( ) ) { throw new  IOException ( _ STR ) ; }  Bookie Server server = bs . get ( index ) ; server . shutdown ( ) ; stop Auto Recovery Service ( server ) ; bs . remove ( server ) ; return bs Confs . remove ( index ) ; }
public void add Selections (  Set <  Entity > items ) { for (  Entity item : items ) { set Selection ( item , _ BOOL ) ; } }
public static  Array List <  String > file Lines (  String fin ) {  File file = new  File ( fin ) ;  Buffered Reader br ;  File Reader fr ;  Array List <  String > lines = new  Array List <  String > ( ) ; try { fr = new  File Reader ( file ) ; br = new  Buffered Reader ( fr ) ;  String line ; try { while ( ( line = br . read Line ( ) ) != null ) { if ( line . length ( ) > _ NUM ) { lines . add ( line ) ; } } } catch (  IOException ex ) { } } catch (  File Not Found Exception ex ) { } return lines ; }
public boolean delete Load Name (  String load ) { if ( ! _load List . contains ( load ) ) { return _ BOOL ; } _load List . remove ( load ) ; log . debug ( _ STR , get Name ( ) , load ) ; set Dirty And Fire Property Change (  LOADS_ CHANGED_ PROPERTY , _load List . size ( ) + _ NUM , _load List . size ( ) ) ; return _ BOOL ; }
private void validate Removal Of Public Network Interface (  String instance Id , int desired Network Interface State Count ) throws  Throwable { if ( this . is Aws Client Mock ) { return ; }  Compute State stopped Compute State = get Compute By AWSId ( this . host , instance Id ) ; assert Not Null ( stopped Compute State ) ; for (  String network Link : stopped Compute State . network Interface Links ) { assert False ( network Link . contains (  PUBLIC_ INTERFACE ) ) ; } validate Network Interface Count ( desired Network Interface State Count ) ; }
public final void to String (  String Builder builder ) { builder . append ( get Name ( ) ) ; }
public void add Arg If Absent ( final  BOp arg ) { if ( arg == null ) throw new  Illegal Argument Exception ( ) ; if ( arg == this ) throw new  Illegal Argument Exception ( ) ; if ( ! args . contains ( arg ) ) { add Arg ( arg ) ; } }
public  String storage Policy Key And Version To String (  Storage Policy Key storage Policy Key ,  Integer storage Policy Version ) { return  String . format ( _ STR , storage Policy Key . get Namespace ( ) , storage Policy Key . get Storage Policy Name ( ) , storage Policy Version ) ; }
public long value ( int i ) { return  Array . get Long ( values , i ) ; }
private void recompute Seperation ( double [ ] [ ] means , double [ ] [ ] cdist , int [ ] [ ] cnum ,  Long Statistic diststat ) { final int k = means . length ; for ( int i = _ NUM ; i < k ; i ++ ) {  Double Vector mi =  Double Vector . wrap ( means [ i ] ) ; for ( int j = _ NUM ; j < i ; j ++ ) { cdist [ i ] [ j ] = cdist [ j ] [ i ] = distance Function . distance ( mi ,  Double Vector . wrap ( means [ j ] ) ) ; } } double [ ] buf = new double [ k - _ NUM ] ; for ( int i = _ NUM ; i < k ; i ++ ) {  System . arraycopy ( cdist [ i ] , _ NUM , buf , _ NUM , i ) ;  System . arraycopy ( cdist [ i ] , i + _ NUM , buf , i , k - i - _ NUM ) ; for ( int j = _ NUM ; j < buf . length ; j ++ ) { cnum [ i ] [ j ] = j < i ? j : ( j + _ NUM ) ; }  Double Integer Array Quick Sort . sort ( buf , cnum [ i ] , k - _ NUM ) ; } if ( diststat != null ) { diststat . increment ( ( k * ( k - _ NUM ) ) > > _ NUM ) ; } }
private  String double To String ( double input , boolean is Integer ) { if (  Double . is Na N ( input ) ) { return null ; } if ( is Integer && input == ( int ) input ) { return _ STR + ( int ) input ; } else { return _ STR + input ; } }
private  Element create Organization (  String name ,  String displ Name ,  String url ,  String lang Str ) throws  Exception {  Element org Ele = doc . create Element (  SAMLNames .  ORGANIZATION ) ;  Element name Ele = doc . create Element (  SAMLNames .  ORGANIZATIONNAME ) ; name Ele . set Attribute (  SAMLNames .  XMLLANG ,  SAMLNames .  ENGLISH ) ; name Ele . append Child ( doc . create Text Node ( name ) ) ; org Ele . append Child ( name Ele ) ;  Element display Name Ele = doc . create Element (  SAMLNames .  ORGANIZATIONDISPLAYNAME ) ; display Name Ele . set Attribute (  SAMLNames .  XMLLANG ,  SAMLNames .  ENGLISH ) ; display Name Ele . append Child ( doc . create Text Node ( displ Name ) ) ; org Ele . append Child ( display Name Ele ) ;  String url Str = idm Client . get Entity ID ( tenant Name ) ; if ( url Str == null ) { url Str = tenant Name ; }  Element url Ele = doc . create Element (  SAMLNames .  ORGANIZATIONURL ) ; url Ele . set Attribute (  SAMLNames .  XMLLANG , lang Str ) ; url Ele . append Child ( doc . create Text Node ( url ) ) ; org Ele . append Child ( url Ele ) ; return org Ele ; }
public void add Process Listener (  Process Listener l ) { listener List . add ( l ) ; }
public  String root ( ) { return root ; }
public  Str Builder replace All ( final  String search Str , final  String replace Str ) { final int search Len = ( search Str == null ? _ NUM : search Str . length ( ) ) ; if ( search Len > _ NUM ) { final int replace Len = ( replace Str == null ? _ NUM : replace Str . length ( ) ) ; int index = index Of ( search Str , _ NUM ) ; while ( index >= _ NUM ) { replace Impl ( index , index + search Len , search Len , replace Str , replace Len ) ; index = index Of ( search Str , index + replace Len ) ; } } return this ; }
protected abstract void internal Run ( ) throws  Exception ;
private static  JCheck Box configure Check Box (  JCheck Box check Box ) { check Box . set Horizontal Alignment (  JCheck Box .  LEFT ) ; check Box . set Font (  UIManager . get Font ( _ STR ) ) ; check Box . set Border Painted ( _ BOOL ) ; check Box . set Focus Painted ( _ BOOL ) ; check Box . set Focusable ( _ BOOL ) ; check Box . set Opaque ( _ BOOL ) ; return check Box ; }
@  Override protected void remove Range ( int start , int end ) { if ( start < _ NUM ) { throw new  Index Out Of Bounds Exception ( _ STR + start ) ; } else if ( end > size ) { throw new  Index Out Of Bounds Exception ( _ STR + end + _ STR + size ) ; } else if ( start > end ) { throw new  Index Out Of Bounds Exception ( _ STR + start + _ STR + end ) ; } if ( start == end ) { return ; } if ( end == size ) {  Arrays . fill ( array , first Index + start , first Index + size , null ) ; } else if ( start == _ NUM ) {  Arrays . fill ( array , first Index , first Index + end , null ) ; first Index += end ; } else {  System . arraycopy ( array , first Index + end , array , first Index + start , size - end ) ; int last Index = first Index + size ; int new Last = last Index + start - end ;  Arrays . fill ( array , new Last , last Index , null ) ; } size -= end - start ; mod Count ++ ; }
public  CAddress Space Configuration ( final  CAddress Space address Space , final  Address Space Configuration Backend provider , final int address Space Id , final  String name , final  String description , final  Date creation Date , final  Date modification Date , final  Debugger Template debugger Template ) { m_address Space = address Space ; m_provider = provider ; m_id = address Space Id ; m_name = name ; m_description = description ; m_creation Date = new  Date ( creation Date . get Time ( ) ) ; m_modification Date = new  Date ( modification Date . get Time ( ) ) ; m_debugger Template = debugger Template ; }
public static <  T >  Parallel Flux <  T > from (  Publisher < ? extends  T > source , int parallelism , int prefetch ,  Supplier <  Queue <  T > > queue Supplier ) { if ( parallelism <= _ NUM ) { throw new  Illegal Argument Exception ( _ STR + parallelism ) ; } if ( prefetch <= _ NUM ) { throw new  Illegal Argument Exception ( _ STR + prefetch ) ; }  Objects . require Non Null ( queue Supplier , _ STR ) ;  Objects . require Non Null ( source , _ STR ) ; return on Assembly ( new  Parallel Unordered Source < > ( source , parallelism , prefetch , queue Supplier ) ) ; }
private void on Ball In Pipe ( ) { m Sound Pool . play ( m Sound Ball In Machine , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM ) ; m Game Balls Left -- ; m Number Collected ++ ; change Indicator ( ) ; m Match Score += _ NUM *  Math . max ( _ NUM , ( m Current Level Num - m Count Level Ball Respawns ) ) ; m View Score . set Text (  String . value Of ( m Match Score ) ) ; if ( m Game Balls Left == _ NUM && m View Play Again Background . get Visibility ( ) !=  View .  VISIBLE ) { m Current Level Num ++ ; m Level Number Text . set Level Number ( m Current Level Num ) ; m Level Number Text . start Animation ( m Animation Level Scale Up ) ; m End Level Circle . start Animation ( m Animation Scale Level Down ) ; } }
public final double sample Count ( ) { long count = _count . get ( ) ; long last Count = _last Count . get And Set ( count ) ; return count - last Count ; }
void add Channel (  Notification Channel channel ) { channels . add ( channel ) ; }
public  Pla Point Float [ ] tangential_points (  Pla Point Float p_to_point , double p_distance ) { double dx =  Math . abs ( v_x - p_to_point . v_x ) ; double dy =  Math . abs ( v_y - p_to_point . v_y ) ; boolean situation_turned = ( dy > dx ) ;  Pla Point Float pole ;  Pla Point Float circle_center ; if ( situation_turned ) { pole = new  Pla Point Float ( - v_y , v_x ) ; circle_center = new  Pla Point Float ( - p_to_point . v_y , p_to_point . v_x ) ; } else { pole = this ; circle_center = p_to_point ; } dx = pole . v_x - circle_center . v_x ; dy = pole . v_y - circle_center . v_y ; double dx_square = dx * dx ; double dy_square = dy * dy ; double dist_square = dx_square + dy_square ; double radius_square = p_distance * p_distance ; double discriminant = radius_square * dy_square - ( radius_square - dx_square ) * dist_square ; if ( discriminant <= _ NUM ) { return new  Pla Point Float [ _ NUM ] ; } double square_root =  Math . sqrt ( discriminant ) ;  Pla Point Float [ ] result = new  Pla Point Float [ _ NUM ] ; double a1 = radius_square * dy ; double dy1 = ( a1 + p_distance * square_root ) / dist_square ; double dy2 = ( a1 - p_distance * square_root ) / dist_square ; double first_point_y = dy1 + circle_center . v_y ; double first_point_x = ( radius_square - dy * dy1 ) / dx + circle_center . v_x ; double second_point_y = dy2 + circle_center . v_y ; double second_point_x = ( radius_square - dy * dy2 ) / dx + circle_center . v_x ; if ( situation_turned ) { result [ _ NUM ] = new  Pla Point Float ( first_point_y , - first_point_x ) ; result [ _ NUM ] = new  Pla Point Float ( second_point_y , - second_point_x ) ; } else { result [ _ NUM ] = new  Pla Point Float ( first_point_x , first_point_y ) ; result [ _ NUM ] = new  Pla Point Float ( second_point_x , second_point_y ) ; } return result ; }
void read Checkpoint Delta (  Table Kelp table ,  Page Service Impl page Actor ,  Read Stream is , int length ) throws  IOException {  Row row = table . row ( ) ; int remove Length = row . remove Length ( ) ; int row Length = row . length ( ) ;  Block Leaf block = _blocks [ _ NUM ] ; long end Position = is . position ( ) + length ; int row Head = block . row Head ( ) ; int blob Tail = block . get Blob Tail ( ) ; long pos ; while ( ( pos = is . position ( ) ) < end Position ) { int code = is . read ( ) ; is . unread ( ) ; code = code &  CODE_ MASK ; if ( code ==  REMOVE ) { row Head -= remove Length ; if ( row Head < blob Tail ) { block = extend Blocks ( ) ; row Head =  BLOCK_ SIZE - remove Length ; blob Tail = _ NUM ; } is . read All ( block . get Buffer ( ) , row Head , remove Length ) ; } else if ( code ==  INSERT ) { row Head -= row Length ; while ( ( blob Tail = row . read Checkpoint ( is , block . get Buffer ( ) , row Head , blob Tail ) ) < _ NUM ) { is . position ( pos ) ; block = extend Blocks ( ) ; row Head =  BLOCK_ SIZE - row Length ; blob Tail = _ NUM ; } } else { throw new  Illegal State Exception (  L . l ( _ STR , this , pos , code ) ) ; } block . row Head ( row Head ) ; block . set Blob Tail ( blob Tail ) ; } clear Dirty ( ) ; validate ( table ) ; }
public boolean is Visited (  String uri ) { if ( uri == null ) return _ BOOL ; uri = resolve URI ( uri ) ; return history . contains ( uri ) ; }
private  Id Range parse Range (  String range ) throws  Decoding Exception { int pos = range . index Of ( _ STR ) ; try { if ( pos == - _ NUM ) { if ( range . length ( ) == _ NUM && range . char At ( _ NUM ) == _ STR ) { return new  Id Range (  Long .  MAX_ VALUE ,  Long .  MAX_ VALUE ) ; } else { long value = parse Unsigned Integer ( range ) ; return new  Id Range ( value ) ; } } else { long val1 = parse Unsigned Integer ( range . substring ( _ NUM , pos ) ) ; long val2 = parse Unsigned Integer ( range . substring ( pos + _ NUM ) ) ; if ( val1 ==  Long .  MAX_ VALUE && val2 ==  Long .  MAX_ VALUE ) { return new  Id Range (  Long .  MAX_ VALUE ,  Long .  MAX_ VALUE ) ; } else if ( val1 <= val2 ) { return new  Id Range ( val1 , val2 ) ; } else if ( val1 ==  Long .  MAX_ VALUE ) { return new  Id Range ( val2 ,  Long .  MAX_ VALUE ) ; } else { return new  Id Range ( val2 , val1 ) ; } } } catch (  Number Format Exception e ) { throw new  Decoding Exception (  Human Readable Text .  INVALID_ MESSAGESET , _ STR , e ) ; } }
public static double distance Point Line (  Coordinate p ,  Coordinate  A ,  Coordinate  B ) { if (  A . x ==  B . x &&  A . y ==  B . y ) return p . distance (  A ) ; double len2 = (  B . x -  A . x ) * (  B . x -  A . x ) + (  B . y -  A . y ) * (  B . y -  A . y ) ; double r = ( ( p . x -  A . x ) * (  B . x -  A . x ) + ( p . y -  A . y ) * (  B . y -  A . y ) ) / len2 ; if ( r <= _ NUM ) return p . distance (  A ) ; if ( r >= _ NUM ) return p . distance (  B ) ; double s = ( (  A . y - p . y ) * (  B . x -  A . x ) - (  A . x - p . x ) * (  B . y -  A . y ) ) / len2 ; return  Math . abs ( s ) *  Math . sqrt ( len2 ) ; }
public  String build Id ( ) { return properties . get Property ( _ STR ) ; }
public void write ( byte [ ] b ) throws java . io .  IOException { write ( b , _ NUM , b . length ) ; }
private void init Panel ( ) { final  JPanel main Panel = new  JPanel ( new  Border Layout ( ) ) ; main Panel . set Border ( new  Titled Border ( _ STR ) ) ; final  JPanel operator Panel = new  JPanel ( new  Border Layout ( ) ) ; operator Panel . set Border ( new  Empty Border ( _ NUM , _ NUM , _ NUM , _ NUM ) ) ; final  JPanel input Panel = new  JPanel ( new  Border Layout ( ) ) ; input Panel . set Border ( new  Empty Border ( _ NUM , _ NUM , _ NUM , _ NUM ) ) ; operator Panel . add ( m_operator Box ,  Border Layout .  CENTER ) ; input Panel . add ( m_input Field ,  Border Layout .  CENTER ) ; final  JPanel container Panel = new  JPanel ( new  Border Layout ( ) ) ; container Panel . add ( operator Panel ,  Border Layout .  WEST ) ; container Panel . add ( input Panel ,  Border Layout .  CENTER ) ; main Panel . add ( container Panel ,  Border Layout .  NORTH ) ; add ( main Panel ,  Border Layout .  CENTER ) ; }
@  Target Api (  Build .  VERSION_ CODES .  JELLY_ BEAN ) private void dequeue Output Buffer (  Media Codec codec ,  Byte Buffer [ ] output Buffers , int index ,  Media Codec .  Buffer Info info ) { if (  Build .  VERSION .  SDK_ INT >=  Build .  VERSION_ CODES .  JELLY_ BEAN ) {  Byte Buffer buffer = output Buffers [ index ] ;  Log . i ( _ STR + info . size + _ STR + buffer . remaining ( ) ) ; if ( info . size <= buffer . remaining ( ) ) { final byte [ ] buffer Copied = new byte [ info . size ] ; buffer . get ( buffer Copied ) ; codec . release Output Buffer ( index , _ BOOL ) ; add Encoded ( buffer Copied ) ; if (  Log .  DEBUG ) {  Audio Utils . show Some Bytes ( _ STR , buffer Copied ) ; } } else {  Log . e ( _ STR ) ; codec . release Output Buffer ( index , _ BOOL ) ; } } }
public static double log Bin Coeff ( int n , int k ) { if ( k > n ) throw new  Illegal Argument Exception ( _ STR + n + _ STR + k + _ STR ) ; else if ( k == _ NUM || k == n ) return  Math . log ( _ NUM ) ; double r = _ NUM ; for ( int d = _ NUM ; d <= k ; d ++ ) r +=  Math . log ( n - ( k - d ) ) -  Math . log ( d ) ; return r ; }
private void notify Lines ( final  Key output Type , final  Iterator <  String > lines , final  String Builder line Builder ) { if ( ! lines . has Next ( ) ) return ; if ( line Builder . length ( ) > _ NUM ) { line Builder . append ( lines . next ( ) ) ; if ( lines . has Next ( ) ) { final  String line = line Builder . to String ( ) ; notify Line ( line , output Type ) ; line Builder . set Length ( _ NUM ) ; } } while ( _ BOOL ) {  String line = null ; if ( lines . has Next ( ) ) { line = lines . next ( ) ; } if ( lines . has Next ( ) ) { notify Line ( line , output Type ) ; } else { if ( line != null && line . length ( ) > _ NUM ) { line Builder . append ( line ) ; } break ; } } }
private void remove Old Jar ( ) throws  IOException { if ( output File . exists ( ) ) { if ( output File . is Directory ( ) ) { if ( !  File Utils . recursive Delete ( output File ) ) { throw new  IOException ( _ STR + output File . get Absolute Path ( ) + _ STR ) ; } } else { if ( ! output File . delete ( ) ) { throw new  IOException ( _ STR + output File . get Absolute Path ( ) + _ STR ) ; } } } }
public void add List Listener (  Action Listener a ) { listeners . add ( a ) ; }
public double calculate Log Likelihood ( ) { double log L = _ NUM ; for (  Statistic statistic : data List ) { for ( int j = _ NUM ; j < statistic . get Dimension ( ) ; j ++ ) { log L -= _ NUM *  Math . log ( statistic . get Statistic Value ( j ) ) ; } } return log L ; }
public static boolean has Dead States To Accept (  Automaton a ) {  Bit Set reachable From Initial = get Live States From Initial ( a ) ;  Bit Set reachable From Accept = get Live States To Accept ( a ) ; reachable From Accept . and Not ( reachable From Initial ) ; return reachable From Accept . is Empty ( ) == _ BOOL ; }
public  Decimal add (  Decimal decimal ) { assert Defined ( ) ; if ( null == m_value ) { if ( null == decimal . get Big Decimal Value ( ) ) { return new  Decimal (  SCALE ) ; } else { return new  Decimal ( decimal . get Big Decimal Value ( ) ,  SCALE ) ; } }  Big Decimal value = m_value . add ( decimal . get Big Decimal Value ( ) ) ; return new  Decimal ( value ,  SCALE ) ; }
public boolean equals (  Object object ) { if ( this == object ) { return _ BOOL ; } else if ( object == null || get Class ( ) != object . get Class ( ) ) { return _ BOOL ; } return principal . equals ( object . to String ( ) ) ; }
private void groovy Expression (  Reader reader ,  String Writer sw ) throws  IOException { sw . write ( _ STR ) ; int c ; while ( ( c = reader . read ( ) ) != - _ NUM ) { if ( c == _ STR ) { c = reader . read ( ) ; if ( c != _ STR ) { sw . write ( _ STR ) ; } else { break ; } } if ( c != _ STR && c != _ STR ) { sw . write ( c ) ; } } sw . write ( _ STR ) ; }
public static boolean is Data Uri (  Uri uri ) { return  DATA_ SCHEME . equals ( get Scheme Or Null ( uri ) ) ; }
public static  List <  Byte Buffer > base64 String To Byte Buffer (  String ... base64 Encoded Keys ) {  List <  Byte Buffer > byte Buffers = new  Array List < > ( base64 Encoded Keys . length ) ; for (  String base64 Encoded Key : base64 Encoded Keys ) { byte Buffers . add ( base64 String To Byte Buffer ( base64 Encoded Key ) ) ; } return byte Buffers ; }
public void update ( long dt Ms ) { m Current Time += dt Ms ; m Current Time =  Math . min ( m Current Time , m Duration + m Start Delay ) ; if ( m Delay Start Value && m Current Time < m Start Delay ) { return ; } long relative Time =  Math . max ( _ NUM ,  Math . min ( m Current Time - m Start Delay , m Duration ) ) ; set Property ( m Start + ( m End - m Start ) * m Interpolator . get Interpolation ( ( float ) relative Time / ( float ) m Duration ) ) ; }
public  String next String ( char quote ) throws  JSONException { char c ;  String Buffer sb = new  String Buffer ( ) ; for ( ; ; ) { c = next ( ) ; switch ( c ) { case _ NUM : case _ STR : case _ STR : throw syntax Error ( _ STR ) ; case _ STR : c = next ( ) ; switch ( c ) { case _ STR : sb . append ( _ STR ) ; break ; case _ STR : sb . append ( _ STR ) ; break ; case _ STR : sb . append ( _ STR ) ; break ; case _ STR : sb . append ( _ STR ) ; break ; case _ STR : sb . append ( _ STR ) ; break ; case _ STR : try { sb . append ( ( char )  Integer . parse Int ( next ( _ NUM ) , _ NUM ) ) ; } catch (  Number Format Exception e ) { throw new  JSONException ( _ STR ) ; } break ; case _ STR : case _ STR : case _ STR : case _ STR : sb . append ( c ) ; break ; default : throw syntax Error ( _ STR ) ; } break ; default : if ( c == quote ) { return sb . to String ( ) ; } sb . append ( c ) ; } } }
public void incorporate Signature Dom ( ) { signature Dom = document Dom . create Element NS (  XMLNS ,  DS_ SIGNATURE ) ; signature Dom . set Attribute (  XMLNS_ DS ,  XMLNS ) ; signature Dom . set Attribute (  ID , deterministic Id ) ; final  Node parent Node Of Signature = get Parent Node Of Signature ( ) ; parent Node Of Signature . append Child ( signature Dom ) ; }
@  Suppress Warnings ( { _ STR , _ STR } ) private static  Pipeline Op distinct Term Scan Join ( final  Pipeline Op left , final  List <  NV > anns ,  Predicate pred , final  Dataset Node dataset , final  Long cutoff Limit Is Ignored , final  Var Node distinct Term Scan Var , final  Properties query Hints , final  AST2 BOp Context ctx ) { final  IVariable distinct Var = distinct Term Scan Var . get Value Expression ( ) ; anns . add ( new  NV (  Distinct Term Scan Op .  Annotations .  DISTINCT_ VAR , distinct Var ) ) ; final  Constant <  IV > mock Const = new  Constant <  IV > (  Term Id . mock IV (  VTE .  URI ) ) ; final  IPredicate mock Pred = pred . as Bound ( distinct Var , mock Const ) ; final  SPOKey Order key Order =  SPOKey Order . get Key Order ( mock Pred , ctx . is Quads ( ) ? _ NUM : _ NUM ) ; pred = (  Predicate ) pred . set Property (  IPredicate .  Annotations .  KEY_ ORDER , key Order ) ; anns . add ( new  NV (  Pipeline Join .  Annotations .  PREDICATE , pred ) ) ; return apply Query Hints ( new  Distinct Term Scan Op ( left Or Empty ( left ) ,  NV . as Map ( anns . to Array ( new  NV [ anns . size ( ) ] ) ) ) , query Hints , ctx ) ; }
private  String parse Name ( ) throws  Jasper Exception { char ch = ( char ) reader . peek Char ( ) ; if (  Character . is Letter ( ch ) || ch == _ STR || ch == _ STR ) {  String Builder buf = new  String Builder ( ) ; buf . append ( ch ) ; reader . next Char ( ) ; ch = ( char ) reader . peek Char ( ) ; while (  Character . is Letter ( ch ) ||  Character . is Digit ( ch ) || ch == _ STR || ch == _ STR || ch == _ STR || ch == _ STR ) { buf . append ( ch ) ; reader . next Char ( ) ; ch = ( char ) reader . peek Char ( ) ; } return buf . to String ( ) ; } return null ; }
public  String to String ( int level ) {  String Builder sb = new  String Builder ( ) ; for ( int i = _ NUM ; i < level ; i ++ ) { sb . append ( to String ( ) ) ; } return sb . to String ( ) ; }
public  Sample Set (  Byte Buffer bb ) throws  IOException { int num Samples ; sample Info = new  Sample Info ( bb ) ; num Samples = bb . get Int ( ) ; this . samples = new  Sample [ num Samples ] ; for ( int i = _ NUM ; i < num Samples ; i ++ ) { samples [ i ] =  Sample . load Binary ( bb ) ; } }
private void update IPAddress (  String ip Address ,  Storage Port port ) { if ( null != ip Address && ! ip Address . equals Ignore Case ( port . get Port Network Id ( ) ) ) { port . set Ip Address ( ip Address ) ; } }
public void test Remove Non Comparable From Empty Map ( ) { tm = new  Tree Map ( ) ; try { tm . remove ( new  Object ( ) ) ; } catch (  Class Cast Exception expected ) { } }
boolean hide Namespace (  String namespace ,  String namespaces ) { if ( namespace == null || namespace . equals ( _ STR ) ) { return _ BOOL ; } else if ( namespaces . index Of ( _ STR + namespace + _ STR ) != - _ NUM ) { return ( namespaces . index Of ( _ STR + namespace + _ STR ) != - _ NUM ) ; } else if ( namespace . equals ( _ STR ) ) { return _ BOOL ; } else if ( namespace . equals ( _ STR ) ) { return _ BOOL ; } else if ( namespace . equals ( _ STR ) ) { return _ BOOL ; } else if ( namespace . equals ( _ STR ) ) { return _ BOOL ; } else { return _ BOOL ; } }
public void test Timed Invoke Any3 ( ) throws  Throwable {  Count Down Latch latch = new  Count Down Latch ( _ NUM ) ;  Executor Service e = new  Fork Join Pool ( _ NUM ) ;  Pool Cleaner cleaner = null ; try { cleaner = cleaner ( e ) ;  List <  Callable <  String > > l = new  Array List <  Callable <  String > > ( ) ; l . add ( latch Awaiting String Task ( latch ) ) ; l . add ( null ) ; try { e . invoke Any ( l ,  MEDIUM_ DELAY_ MS ,  MILLISECONDS ) ; should Throw ( ) ; } catch (  Null Pointer Exception success ) { } latch . count Down ( ) ; } finally { if ( cleaner != null ) { cleaner . close ( ) ; } } }
public static void tql2 ( int n , double [ ] d , double [ ] e , double [ ] [ ]  V ) { for ( int i = _ NUM ; i < n ; i ++ ) { e [ i - _ NUM ] = e [ i ] ; } e [ n - _ NUM ] = _ NUM ; double f = _ NUM ; double tst1 = _ NUM ; double eps =  Math . pow ( _ NUM , - _ NUM ) ; for ( int l = _ NUM ; l < n ; l ++ ) { tst1 =  Math . max ( tst1 ,  Math . abs ( d [ l ] ) +  Math . abs ( e [ l ] ) ) ; int m = l ; while ( m < n ) { if (  Math . abs ( e [ m ] ) <= eps * tst1 ) { break ; } m ++ ; } if ( m > l ) { int iter = _ NUM ; do { iter = iter + _ NUM ; double g = d [ l ] ; double p = ( d [ l + _ NUM ] - g ) / ( _ NUM * e [ l ] ) ; double r = hypot ( p , _ NUM ) ; if ( p < _ NUM ) { r = - r ; } d [ l ] = e [ l ] / ( p + r ) ; d [ l + _ NUM ] = e [ l ] * ( p + r ) ; double dl1 = d [ l + _ NUM ] ; double h = g - d [ l ] ; for ( int i = l + _ NUM ; i < n ; i ++ ) { d [ i ] -= h ; } f = f + h ; p = d [ m ] ; double c = _ NUM ; double c2 = c ; double c3 = c ; double el1 = e [ l + _ NUM ] ; double s = _ NUM ; double s2 = _ NUM ; for ( int i = m - _ NUM ; i >= l ; i -- ) { c3 = c2 ; c2 = c ; s2 = s ; g = c * e [ i ] ; h = c * p ; r = hypot ( p , e [ i ] ) ; e [ i + _ NUM ] = s * r ; s = e [ i ] / r ; c = p / r ; p = c * d [ i ] - s * g ; d [ i + _ NUM ] = h + s * ( c * g + s * d [ i ] ) ; for ( int k = _ NUM ; k < n ; k ++ ) { h =  V [ k ] [ i + _ NUM ] ;  V [ k ] [ i + _ NUM ] = s *  V [ k ] [ i ] + c * h ;  V [ k ] [ i ] = c *  V [ k ] [ i ] - s * h ; } } p = - s * s2 * c3 * el1 * e [ l ] / dl1 ; e [ l ] = s * p ; d [ l ] = c * p ; } while (  Math . abs ( e [ l ] ) > eps * tst1 ) ; } d [ l ] = d [ l ] + f ; e [ l ] = _ NUM ; } for ( int i = _ NUM ; i < n - _ NUM ; i ++ ) { int k = i ; double p = d [ i ] ; for ( int j = i + _ NUM ; j < n ; j ++ ) { if ( d [ j ] < p ) { k = j ; p = d [ j ] ; } } if ( k != i ) { d [ k ] = d [ i ] ; d [ i ] = p ; for ( int j = _ NUM ; j < n ; j ++ ) { p =  V [ j ] [ i ] ;  V [ j ] [ i ] =  V [ j ] [ k ] ;  V [ j ] [ k ] = p ; } } } }
void update Pressed (  Action Event e , boolean new Signal Group , boolean close ) { if ( cur Signal Group == null ) { if ( ! check New Names OK ( ) ) { return ; } } if ( ! check Valid Signal Mast ( ) ) { return ; }  String u Name = _user Name . get Text ( ) ;  Signal Group g = check Names OK ( ) ; if ( g == null ) { return ; } cur Signal Group = g ; g . set User Name ( u Name ) ; initialize Included List ( ) ; set Signal Information ( g ) ; set Mast Appearance Information ( g ) ; g . set Signal Mast ( (  Signal Mast ) main Signal . get Selected Bean ( ) , main Signal . get Selected Display Name ( ) ) ;  Signal Group Dirty = _ BOOL ; if ( close ) { finish Update ( ) ; } }
private  Hash Map add Attr (  Svc Reg reg ,  Entry Class eclass , int fldidx ,  Object value ) {  Hash Map [ ] attr Maps = (  Hash Map [ ] ) service By Attr . get ( eclass ) ; if ( attr Maps == null ) { attr Maps = new  Hash Map [ eclass . get Num Fields ( ) ] ; service By Attr . put ( eclass , attr Maps ) ; }  Hash Map map = attr Maps [ fldidx ] ; if ( map == null ) { map = new  Hash Map ( _ NUM ) ; attr Maps [ fldidx ] = map ; }  Array List regs = (  Array List ) map . get ( value ) ; if ( regs == null ) { regs = new  Array List ( _ NUM ) ; map . put ( value , regs ) ; } else if ( regs . contains ( reg ) ) return map ; regs . add ( reg ) ; return map ; }
public  Query String Decoder Util (  String uri ) { this ( uri ,  Charset . default Charset ( ) ) ; }
void show Error Box (  String error Message ) { show Error Box ( new  Runtime Exception ( error Message ) ) ; }
public void on Destroy ( ) { }
private static  Windows File Attributes from File Attribute Data ( long address , int reparse Tag ) { int file Attrs = unsafe . get Int ( address +  OFFSETOF_ FILE_ ATTRIBUTE_ DATA_ ATTRIBUTES ) ; long creation Time = unsafe . get Long ( address +  OFFSETOF_ FILE_ ATTRIBUTE_ DATA_ CREATETIME ) ; long last Access Time = unsafe . get Long ( address +  OFFSETOF_ FILE_ ATTRIBUTE_ DATA_ LASTACCESSTIME ) ; long last Write Time = unsafe . get Long ( address +  OFFSETOF_ FILE_ ATTRIBUTE_ DATA_ LASTWRITETIME ) ; long size = ( ( long ) ( unsafe . get Int ( address +  OFFSETOF_ FILE_ ATTRIBUTE_ DATA_ SIZEHIGH ) ) << _ NUM ) + ( unsafe . get Int ( address +  OFFSETOF_ FILE_ ATTRIBUTE_ DATA_ SIZELOW ) & _ NUM ) ; return new  Windows File Attributes ( file Attrs , creation Time , last Access Time , last Write Time , size , reparse Tag , _ NUM , _ NUM , _ NUM ) ; }
public static final void write Map Xml (  Map val ,  Xml Serializer out ,  Write Map Callback callback ) throws  Xml Pull Parser Exception , java . io .  IOException { if ( val == null ) { return ; }  Set s = val . entry Set ( ) ;  Iterator i = s . iterator ( ) ; while ( i . has Next ( ) ) {  Map .  Entry e = (  Map .  Entry ) i . next ( ) ; write Value Xml ( e . get Value ( ) , (  String ) e . get Key ( ) , out , callback ) ; } }
public final void fire Event (  Event event ) { event Handlers . fire Event ( event ) ; }
public boolean in Test Set (  String source Side ) { if ( ! source Side . equals ( last Source Side ) ) { last Source Side = source Side ; accepted Last Source Side = filter . permits ( source Side ) ; } else { cached ++ ; } return accepted Last Source Side ; }
public static  String create Resource Name (  String resource ,  Locale locale , boolean remove Extension ) {  String resource Name = resource ; if ( remove Extension ) { if ( resource Name . ends With ( _ STR ) ) { resource Name = resource Name . replace ( _ STR , _ STR ) ; } else if ( resource Name . ends With ( _ STR ) ) { resource Name = resource Name . replace ( _ STR , _ STR ) ; } } if ( locale != null ) { if (  Util Validate . is Not Empty ( locale . to String ( ) ) ) { resource Name = resource Name + _ STR + locale ; } } return resource Name ; }
public int write Annotation Set (  Annotation Set annotation Set ) { int off = data . position ( ) ; write Int ( annotation Set . annotation Offsets . length ) ; for ( int annotation Offset : annotation Set . annotation Offsets ) { write Int ( annotation Offset ) ; } return off ; }
public boolean ping (  Host Address address , int timeout ) throws  Host Exception { notes = _ STR ;  Inet Address inet Address = address . get Inet Address ( ) ; try { return inet Address . is Reachable ( timeout ) ; } catch (  IOException e ) { throw new  Host Exception ( _ STR , e ) ; } }
public boolean revision Contains Template Names ( int rev Id ,  List <  String > template Names ) throws  Wiki Api Exception {  List <  String > tpl List = get Template Names From Revision ( rev Id ) ; for (  String tpl : tpl List ) { for (  String template Name : template Names ) { if ( tpl . equals Ignore Case ( template Name ) ) { return _ BOOL ; } } } return _ BOOL ; }
public  List <  Generic Entry > retrieve All Mailbox Dump Requests (  Date from Date ) throws  Apps For Your Domain Exception ,  Malformed URLException ,  IOException ,  Service Exception {  String url =  BASE_ URL + _ STR + domain ; if ( from Date != null ) { url += _ STR +  DATE_ FORMAT . format ( from Date ) ; } return get All Pages ( new  URL ( url ) ,  Generic Feed . class ) ; }
protected void draw Actor ( int x , int y , int w , int h ,  Color fill Color ,  Paint fill Paint ,  Color pen Color , boolean shadow ) { float width = w * _ NUM / _ NUM ;  General Path path = new  General Path ( ) ; path . move To ( x , y + h ) ; path . curve To ( x , y + _ NUM * h / _ NUM , x , y + _ NUM * h / _ NUM , x + w / _ NUM , y + _ NUM * h / _ NUM ) ; path . curve To ( x + w / _ NUM - width , y + _ NUM * h / _ NUM , x + w / _ NUM - width , y , x + w / _ NUM , y ) ; path . curve To ( x + w / _ NUM + width , y , x + w / _ NUM + width , y + _ NUM * h / _ NUM , x + w / _ NUM , y + _ NUM * h / _ NUM ) ; path . curve To ( x + w , y + _ NUM * h / _ NUM , x + w , y + _ NUM * h / _ NUM , x + w , y + h ) ; path . close Path ( ) ; draw Path ( path , fill Color , fill Paint , pen Color , shadow ) ; }
public static  List <  Date > parse Date List (  List <  String > date List ) {  List <  Date > new List = new  Array List <  Date > ( ) ; if ( date List == null ) return new List ; for (  String value : date List ) new List . add ( parse Date ( value ) ) ; return new List ; }
public void dispatch To Events ( int node Handle , org . xml . sax .  Content Handler ch ) throws org . xml . sax .  SAXException {  Tree Walker tree Walker = m_walker ;  Content Handler prev CH = tree Walker . get Content Handler ( ) ; if ( null != prev CH ) { tree Walker = new  Tree Walker ( null ) ; } tree Walker . set Content Handler ( ch ) ; try {  Node node = get Node ( node Handle ) ; tree Walker . traverse Fragment ( node ) ; } finally { tree Walker . set Content Handler ( null ) ; } }
public  Word Definition (  String s Word ) {  Word = new  String ( s Word . to Lower Case ( ) ) ;  Hash = hash Word ( s Word ) ; }
public  String app_source_path (  String app_class ) {  String filename = app_class . replace ( _ STR , _ STR ) ; filename = filename . replace First ( _ STR , _ STR ) ; if ( filename . index Of ( _ STR ) > _ NUM ) { filename = filename . substring ( _ NUM , filename . index Of ( _ STR ) ) ; } return _ STR + filename + _ STR ; }
public void add Title Prefix (  String prfx ) { if ( ! title Prefix . contains ( prfx ) ) { title Prefix . add ( prfx ) ; fire Property Change (  TITLE_ PREFIX , null , title Prefix ) ; } }
public void send (  Set recipients , boolean multicast ) throws  Interrupted Exception ,  Reply Exception { if (  Thread . interrupted ( ) ) { throw new  Interrupted Exception ( ) ; } this . op = operation Type .  DRAIN_ POOL ;  Set recips = new  Hash Set ( recipients ) ;  Distributed Member me = origin Dm . get Distribution Manager Id ( ) ; if ( recips . contains ( me ) ) { recips . remove ( me ) ; } rp = new  Reply Processor21 ( origin Dm , recips ) ; processor Id = rp . get Processor Id ( ) ; set Recipients ( recips ) ; set Multicast ( multicast ) ; origin Dm . put Outgoing ( this ) ; rp . wait For Replies ( ) ; }
private void remove Flag File (  String flag Name ) {  File flag File = new  File ( db Dir , flag Name ) ; if ( flag File . exists ( ) ) { flag File . delete ( ) ; } }
public int find Engine By Road Number (  String road Number ) { if ( sys List != null ) { if ( ! road Number . equals ( _road Number ) ) { return get Index ( _ NUM , road Number ) ; } int index = get Index ( _index , road Number ) ; if ( index > _ NUM ) { return index ; } return get Index ( _ NUM , road Number ) ; } return - _ NUM ; }
@  Dotted Class Name @  Suppress FBWarnings ( _ STR ) public static  String to Dotted Class Name ( @  Slashed Class Name ( when =  When .  UNKNOWN )  String class Name ) { if ( class Name . index Of ( _ STR ) >= _ NUM ) { return  Descriptor Factory . canonicalize String ( class Name . replace ( _ STR , _ STR ) ) ; } return class Name ; }
public static final int [ ] to Int Array (  Instance x , int  L ) { int y [ ] = new int [  L ] ; for ( int j = _ NUM ; j <  L ; j ++ ) { if ( x . is Missing ( j ) ) { y [ j ] = - _ NUM ; } else { y [ j ] = ( int )  Math . round ( x . value ( j ) ) ; } } return y ; }
public void register (  Location location ) {  Integer old Size =  Integer . value Of ( _location Hash Table . size ( ) ) ; _location Hash Table . put ( location . get Id ( ) , location ) ; int id =  Integer . parse Int ( location . get Id ( ) ) ; if ( id > _id ) { _id = id ; } set Dirty And Fire Property Change (  LISTLENGTH_ CHANGED_ PROPERTY , old Size ,  Integer . value Of ( _location Hash Table . size ( ) ) ) ; }
@  Override public void close ( ) throws  IOException { if ( closed . compare And Set ( _ BOOL , _ BOOL ) ) { close ( _ BOOL ) ; } }
public static  String [ ] create JVisual Vm Command (  String jmx Service Url ,  String java Home Dir ) {  List <  String > command Array = new  Array List <  String > ( _ NUM ) ; if ( java Home Dir == null ) { java Home Dir = calculate Java Home ( ) ; } if ( java Home Dir != null ) { command Array . add ( java Home Dir +  File . separator + _ STR +  File . separator + _ STR ) ; } else { command Array . add ( _ STR ) ; } command Array . add ( _ STR ) ; command Array . add ( jmx Service Url ) ; command Array . add ( _ STR ) ; if ( _logger . is Loggable (  Level .  FINE ) ) { _logger . log (  Level .  FINE , _ STR + command Array ) ; } return command Array . to Array ( new  String [ command Array . size ( ) ] ) ; }
@  Override public boolean connection Allowed (  String event Name ) { return event Name . equals ( _ STR ) || event Name . equals ( _ STR ) ; }
public static  Vector2 abs (  Vector2 o ) { return new  Vector2 (  Math . abs ( o . x ) ,  Math . abs ( o . z ) ) ; }
public static  Object invoke Static (  String clazz ,  String method Name ) throws  No Such Method Exception { try { return invoke Static (  Class . for Name ( clazz ) , method Name ) ; } catch (  Class Not Found Exception e ) { throw new  No Such Method Exception ( _ STR + clazz + _ STR ) ; } }
public int read ( ) throws  IOException { if ( stream != null ) { return stream . read ( ) ; } else { return reader . read ( ) ; } }
private int rd Hex Digit ( ) { int b = _ NUM ; try { b = buff In . read ( ) ; if ( ( b >= _ STR ) && ( b <= _ STR ) ) { b = b - _ STR ; } else if ( ( b >= _ STR ) && ( b <= _ STR ) ) { b = b - _ STR + _ NUM ; } else if ( ( b >= _ STR ) && ( b <= _ STR ) ) { b = b - _ STR + _ NUM ; } else {  JOption Pane . show Message Dialog ( this , _ STR + line No , _ STR ,  JOption Pane .  ERROR_ MESSAGE ) ; log . error ( _ STR + line No ) ; b = _ NUM ; } } catch (  IOException e ) {  JOption Pane . show Message Dialog ( this , _ STR , _ STR ,  JOption Pane .  ERROR_ MESSAGE ) ; log . error ( _ STR + e . to String ( ) ) ; } return ( byte ) b ; }
public void add Mapping (  Matcher <  Request > request Matcher ,  Response Source response Source ) { mappings . add First ( new  Matcher Response Source Pair ( request Matcher , response Source ) ) ; }
private static void parse Property Assignments (  Properties p ,  String [ ] assignments ) { for (  String assignment : assignments ) { int split = assignment . index Of ( _ STR ) ;  String key = assignment . substring ( _ NUM , split ) ;  String value = assignment . substring ( split + _ NUM ) ; p . put ( key , value ) ; } }
@  Suppress Warnings ( _ STR ) public static  String [ ] split (  String original ,  String separator ) { nodes . remove All Elements ( ) ; int index = original . index Of ( separator ) ; while ( index >= _ NUM ) { nodes . add Element ( original . substring ( _ NUM , index ) ) ; original = original . substring ( index + separator . length ( ) ) ; index = original . index Of ( separator ) ; } nodes . add Element ( original ) ;  String [ ] result = new  String [ nodes . size ( ) ] ; if ( nodes . size ( ) > _ NUM ) { for ( int loop = _ NUM ; loop < nodes . size ( ) ; loop ++ ) { result [ loop ] = (  String ) nodes . element At ( loop ) ; } } return result ; }
public void move To End (  Instruction inst ) {  Iterator <  GCIRMap Element > iter = list . iterator ( ) ; while ( iter . has Next ( ) ) {  GCIRMap Element new Ptr = iter . next ( ) ; if ( new Ptr . get Instruction ( ) == inst ) { iter . remove ( ) ; list . add ( new Ptr ) ; return ; } } throw new  Optimizing Compiler Exception ( _ STR + inst + _ STR ) ; }
public static java . lang .  Integer value Of ( java . lang .  String s ) throws java . lang .  Number Format Exception { return new  Integer ( parse Int ( s ) ) ; }
public static  String join (  String separator ,  List <  String > strings ) {  String Builder sb = new  String Builder ( ) ; for (  Iterator <  String > iter = strings . iterator ( ) ; iter . has Next ( ) ; ) {  String s = iter . next ( ) ; sb . append ( s ) ; if ( iter . has Next ( ) ) sb . append ( separator ) ; } return sb . to String ( ) ; }
private static void initialize Params ( ) {  String cache Size =  System Properties . get (  CACHE_ MAX_ SIZE_ KEY , _ STR ) ; try { max Size =  Integer . parse Int ( cache Size ) ; if ( max Size < _ NUM ) { max Size = _ NUM ; } if ( debug . message Enabled ( ) ) { debug . message ( _ STR + _ STR + max Size ) ; } } catch (  Number Format Exception ne ) { max Size = _ NUM ; debug . warning ( _ STR + _ STR + _ STR + max Size ) ; } }
private void schedule Settings Save ( ) { if ( ! m Loading Settings ) { if ( m Settings Save Pending . compare And Set ( _ BOOL , _ BOOL ) ) { m Thread Pool Manager . schedule Once ( new  Settings Save Task ( ) , _ NUM ,  Time Unit .  SECONDS ) ; } } }
public boolean is To Write ( ) {  Iterator <  Variable Value > i = variables . iterator ( ) ; while ( i . has Next ( ) ) {  Variable Value v = i . next ( ) ; if ( v . is To Write ( ) ) { return _ BOOL ; } } return _ BOOL ; }
@  Override public void action Performed (  Action Event ev ) { }
public  String to String ( ) {  String Buffer text = new  String Buffer ( ) ; text . append ( _ STR ) ; return text . to String ( ) ; }
public static  Integer to Ref ( int i ) { return  Integer . value Of ( i ) ; }
private static void extract Directive (  String key , byte [ ] value ,  String [ ] key Table , byte [ ] [ ] value Table ,  List < byte [ ] > realm Choices , int realm Index ) throws  Sasl Exception { for ( int i = _ NUM ; i < key Table . length ; i ++ ) { if ( key . equals Ignore Case ( key Table [ i ] ) ) { if ( value Table [ i ] == null ) { value Table [ i ] = value ; if ( logger . is Loggable (  Level .  FINE ) ) { logger . log (  Level .  FINE , _ STR , new  Object [ ] { key Table [ i ] , new  String ( value Table [ i ] ) } ) ; } } else if ( realm Choices != null && i == realm Index ) { if ( realm Choices . is Empty ( ) ) { realm Choices . add ( value Table [ i ] ) ; } realm Choices . add ( value ) ; } else { throw new  Sasl Exception ( _ STR + key + _ STR + new  String ( value ) ) ; } break ; } } }
@  Override public void put All (  Map < ? extends  K , ? extends  V > m ) { try Presize ( m . size ( ) ) ; for (  Map .  Entry < ? extends  K , ? extends  V > e : m . entry Set ( ) ) put Val ( e . get Key ( ) , e . get Value ( ) , _ BOOL ) ; }
void clear Presence ( ) {  String Builder where = new  String Builder ( ) ; where . append (  Imps .  Presence .  CONTACT_ ID ) ; where . append ( _ STR ) ; where . append (  Imps .  Contacts .  ACCOUNT ) ; where . append ( _ STR ) ; where . append ( m Conn . get Account Id ( ) ) ; where . append ( _ STR ) ; m Resolver . delete (  Imps .  Presence .  CONTENT_ URI , where . to String ( ) , null ) ; }
public void sent Data ( ) { has Sent Data = _ BOOL ; last Send Time =  System . current Time Millis ( ) ; }
@  Override public void close ( ) throws  IOException {  Output Stream output = m_streams . get ( ) ; if ( null != output ) { output . close ( ) ; } }
public static void create Federated Namespace (  URI namespace ,  Zoo Keeper Client zkc ) throws  Interrupted Exception ,  Zoo Keeper Client .  Zoo Keeper Connection Exception ,  Keeper Exception {  String zk Sub Namespaces Path = namespace . get Path ( ) + _ STR +  ZNODE_ SUB_ NAMESPACES ;  Utils . zk Create Full Path Optimistic ( zkc , zk Sub Namespaces Path , new byte [ _ NUM ] , zkc . get Default ACL ( ) ,  Create Mode .  PERSISTENT ) ; }
public void inverse Transform ( double [ ] src , int src Off , double [ ] dst , int dst Off , int length ) throws  Noninvertible Transform Exception { double det = get Determinant ( ) ; if (  Math . abs ( det ) <  ZERO ) { throw new  Noninvertible Transform Exception ( _ STR ) ; } while ( -- length >= _ NUM ) { double x = src [ src Off ++ ] - m02 ; double y = src [ src Off ++ ] - m12 ; dst [ dst Off ++ ] = ( x * m11 - y * m01 ) / det ; dst [ dst Off ++ ] = ( y * m00 - x * m10 ) / det ; } }
private static void fill Change Log ( ) {  Array List <  Integer > list = new  Array List <  Integer > ( _ NUM ) ;  String sql = _ STR + _ STR + _ STR + _ STR + _ STR ;  Prepared Statement pstmt = null ;  Result Set rs = null ; try { pstmt =  DB . prepare Statement ( sql , null ) ; rs = pstmt . execute Query ( ) ; while ( rs . next ( ) ) list . add ( new  Integer ( rs . get Int ( _ NUM ) ) ) ; } catch (  Exception e ) { s_log . log (  Level .  SEVERE , sql , e ) ; } finally {  DB . close ( rs , pstmt ) ; rs = null ; pstmt = null ; } s_change Log = new int [ list . size ( ) ] ; for ( int i = _ NUM ; i < s_change Log . length ; i ++ ) {  Integer id = (  Integer ) list . get ( i ) ; s_change Log [ i ] = id . int Value ( ) ; } s_log . info ( _ STR + s_change Log . length ) ; }
@  Override public  List <  Work Order > search WOFor MB ( final  Map <  String ,  Object > criteria Map ) { logger . info ( _ STR ) ; final  List <  Work Order > filtered List = new  Array List <  Work Order > ( ) ; criteria Map . put (  ACTION_ FLAG , _ STR ) ; for ( final  Work Order workorder : search WO ( criteria Map ) ) if ( ! is Approval Limit Reached For WO ( workorder . get Id ( ) ) ) filtered List . add ( workorder ) ; return filtered List ; }
public  Day (  Date time ,  Time Zone zone ,  Locale locale ) {  Param Checks . null Not Permitted ( time , _ STR ) ;  Param Checks . null Not Permitted ( zone , _ STR ) ;  Param Checks . null Not Permitted ( locale , _ STR ) ;  Calendar calendar =  Calendar . get Instance ( zone , locale ) ; calendar . set Time ( time ) ; int d = calendar . get (  Calendar .  DAY_ OF_ MONTH ) ; int m = calendar . get (  Calendar .  MONTH ) + _ NUM ; int y = calendar . get (  Calendar .  YEAR ) ; this . serial Date =  Serial Date . create Instance ( d , m , y ) ; peg ( calendar ) ; }
void drop Resource ( final  R resource ) { final  Thread tx =  Thread . current Thread ( ) ; synchronized ( resource Queues ) { final  Resource Queue <  R ,  Thread > resource Queue = resource Queues . get ( resource ) ; if ( resource Queue == null ) { throw new  Illegal Argument Exception ( _ STR + resource ) ; } resource Queue . clear ( tx ) ; resource Queues . remove ( resource ) ; } }
public  Email subject (  String subject ) { if ( subject == null ) throw new  Illegal Argument Exception ( _ STR ) ; this . subject = subject ; return this ; }
public void schedule At Fixed Rate (  Timer Task task ,  Date when , long period ) { if ( period <= _ NUM || when . get Time ( ) < _ NUM ) { throw new  Illegal Argument Exception ( ) ; } long delay = when . get Time ( ) -  System . current Time Millis ( ) ; schedule Impl ( task , delay , period , _ BOOL ) ; }
protected void stop Output Test ( ) { if ( test Running && out Test ) { out Timer . stop ( ) ; status Text1 . set Text ( _ STR +  Integer . to String ( num Iterations ) + _ STR ) ; status Text1 . set Visible ( _ BOOL ) ; status Text2 . set Text ( _ STR ) ; status Text2 . set Visible ( _ BOOL ) ; } }
public void insert Row ( int row Index ,  Row Spec row Spec ) { if ( row Index < _ NUM || row Index > get Row Count ( ) ) { throw new  Index Out Of Bounds Exception ( _ STR + row Index + _ STR + get Row Count ( ) + _ STR ) ; } row Specs . add ( row Index - _ NUM , row Spec ) ; shift Components Vertically ( row Index , _ BOOL ) ; adjust Group Indices ( row Group Indices , row Index , _ BOOL ) ; }
private void nuke Symbols ( ) { _count = _ NUM ;  Arrays . fill ( _main Hash , _ NUM ) ;  Arrays . fill ( _main Names , null ) ;  Arrays . fill ( _coll List , null ) ; _coll Count = _ NUM ; _coll End = _ NUM ; }
public  Name join (  Name rhs ) {  List <  Name Piece > new Piece List = new  Array List < > ( ) ; new Piece List . add All ( name Pieces ) ; new Piece List . add All ( rhs . name Pieces ) ; return new  Name ( new Piece List ) ; }
public static  String format Date Time (  Date date ) { return m Simple Date Time Format . format ( date ) ; }
public static  String unquote (  String string ) { if ( string . starts With ( _ STR ) && string . ends With ( _ STR ) ) { string = string . substring ( _ NUM , string . length ( ) - _ NUM ) ; if ( ( string . index Of ( _ STR ) != - _ NUM ) || ( string . index Of ( _ STR ) != - _ NUM ) || ( string . index Of ( _ STR ) != - _ NUM ) || ( string . index Of ( _ STR ) != - _ NUM ) || ( string . index Of ( _ STR ) != - _ NUM ) || ( string . index Of ( _ STR ) != - _ NUM ) || ( string . index Of ( _ STR ) != - _ NUM ) || ( string . index Of ( _ STR ) != - _ NUM ) ) { string = unback Quote Chars ( string ) ; } } return string ; }
static boolean is Str White Space Char ( int c ) { switch ( c ) { case _ STR : case _ STR : case _ STR : case _ STR : case _ STR : case _ STR : case _ STR : case _ STR : case _ STR : case _ STR : return _ BOOL ; default : return  Character . get Type ( c ) ==  Character .  SPACE_ SEPARATOR ; } }
public static void remove Log Filter (  Log Filter filter ) { if ( filter == null || filters == null || filters . is Empty ( ) ) { return ; } if ( filters . contains ( filter ) ) { filters . remove ( filter ) ; } }
protected void remove Datasets ( int [ ] indices ) { int i ; if ( indices == null ) { m_ Model Datasets . remove All Elements ( ) ; } else { for ( i = indices . length - _ NUM ; i >= _ NUM ; i -- ) m_ Model Datasets . remove ( indices [ i ] ) ; } set Modified ( _ BOOL ) ; }
public void dispose ( ) { if ( p_data != null ) p_data . clear ( ) ; p_data = null ; m_selected Object = null ; m_temp Data = null ; m_loaded = _ BOOL ; }
public void remove Assigned Virtual Arrays (  Set <  String > virtual Array URIs ) { if ( ( virtual Array URIs != null ) && ( ! virtual Array URIs . is Empty ( ) ) && ( _assigned Virtual Arrays != null ) ) {  Hash Set <  String > remove Virtual Arrays = new  Hash Set <  String > ( ) ; remove Virtual Arrays . add All ( virtual Array URIs ) ; _assigned Virtual Arrays . remove All ( remove Virtual Arrays ) ; update Virtual Array Tags ( ) ; } }
@  Override public  Env Var add New Env Var (  String name ,  Class < ? > type ,  String value ) {  Env Var env Var = null ; if ( ! exist ( name ) ) { env Var = new  Env Var ( name , type , _ BOOL ) ; env Var . set Value ( value ) ; env Var List . add ( env Var ) ; } return env Var ; }
private void deactivate Block ( ) { if ( ( m Block Listener != null ) && ( block != null ) ) { block . remove Property Change Listener ( m Block Listener ) ; } m Block Listener = null ; }
public static <  T >  List <  T > as List (  T ... values ) { if ( values == null ) { return new  Array List <  T > ( _ NUM ) ; } else { return new  Array List <  T > (  Arrays . as List ( values ) ) ; } }
public  Collection <  Graph Node > compute Successor Nodes ( ) {  Collection <  Graph Node > result =  Lists . new Array List ( ) ; for (  Graph Edge edge : get Forward Edges ( ) ) { result . add ( edge . get Tail ( ) ) ; } for (  Graph Edge edge : get Reverse Edges ( ) ) { result . add ( edge . get Head ( ) ) ; } return result ; }
@  Non Null protected static  String sortable Title ( @  Nullable  String title ) { if ( title == null ) { return _ STR ; } title = title . to Lower Case ( ) ; if ( title . starts With ( _ STR ) ) { return title . substring ( _ NUM ) ; } else if ( title . starts With ( _ STR ) ) { return title . substring ( _ NUM ) ; } else { return title ; } }
public  Pooled Executor With DMStats (  Blocking Queue <  Runnable > q , int pool Size ,  Thread Factory tf ) { this ( q , pool Size , null , tf ) ; }
public  Request body (  String body ) {  Objects . require Non Null ( body ) ; _body = body . get Bytes ( ) ; return this ; }
void add Child Tab (  Tab child ) { if ( m Children == null ) { m Children = new  Vector <  Tab > ( ) ; } m Children . add ( child ) ; child . set Parent ( this ) ; }
public boolean run (  String allowed ,  String option ) { if ( ! has Option ( option ) ) { return _ BOOL ; }  String selection = get Option Value ( option ) ;  String [ ] selection List = selection . split ( _ STR ) ; for (  String selection Item : selection List ) { if ( selection Item . equals ( allowed ) ) { return _ BOOL ; } } return _ BOOL ; }
public void add Muted Mac ( final  String mac , final  Date mute Till ) { if ( is Mac Muted ( mac ) ) { remove Muted Mac ( mac ) ; }  Timestamp mute Till Ts = null ; if ( mute Till != null ) { mute Till Ts = new  Timestamp ( mute Till . get Time ( ) ) ; } s_logger . fine ( _ STR + mac ) ; final  Connection con =  Database . get Connection ( ) ; try { final  Prepared Statement ps = con . prepare Statement ( _ STR ) ; ps . set String ( _ NUM , mac ) ; ps . set Timestamp ( _ NUM , mute Till Ts ) ; ps . execute ( ) ; ps . close ( ) ; con . commit ( ) ; } catch ( final  SQLException sqle ) { if ( sqle . get Error Code ( ) == _ NUM ) { s_logger . info ( _ STR + mac + _ STR + sqle . get Message ( ) ) ; return ; } s_logger . log (  Level .  SEVERE , _ STR + mac , sqle ) ; throw new  Illegal State Exception ( sqle . get Message ( ) ) ; } finally {  Db Util . close Connection ( con ) ; } }
public void consume All ( long timeout ,  Time Unit unit ) throws  Timeout Exception { final long stop Time =  System . current Time Millis ( ) + unit . to Millis ( timeout ) ; while (  System . current Time Millis ( ) < stop Time ) {  Event next Event = queue . poll ( ) ; if ( next Event != null ) {  Testing . print ( _ STR + next Event ) ; consumed Events . accept ( next Event ) ; } } }
public boolean is Text Field Valid ( ) { return is Text Valid ( date Text Field . get Text ( ) ) ; }
public static int rand Exponential ( final int mean ) { return ( int ) ( - mean *  Math . log ( rand . next Double ( ) ) ) ; }
public  OVector ( int c ) { vector = new  Object [  Math . max ( default Capacity , c ) ] ; }
public void process Invite (  Request Event request Event ,  Server Transaction server Transaction ) { final  Request request = request Event . get Request ( ) ; final  Sip Provider sip Provider = (  Sip Provider ) request Event . get Source ( ) ;  Server Transaction st = server Transaction ; try { if ( st == null ) { st = sip Provider . get New Server Transaction ( request ) ; } sip Provider . get New Dialog ( st ) ; final  String to Tag = _ STR +  System . nano Time ( ) ;  Response response = message Factory . create Response (  Response .  RINGING , request ) ;  To Header to Header = (  To Header ) response . get Header (  To Header .  NAME ) ; to Header . set Tag ( to Tag ) ; st . send Response ( response ) ; response = message Factory . create Response (  Response .  OK , request ) ; final  Address address = address Factory . create Address ( _ STR + my Address + _ STR + my Port + _ STR ) ; final  Contact Header contact Header = header Factory . create Contact Header ( address ) ; response . add Header ( contact Header ) ; to Header = (  To Header ) response . get Header (  To Header .  NAME ) ; to Header . set Tag ( to Tag ) ; st . send Response ( response ) ; } catch (  Exception ex ) { ex . print Stack Trace ( ) ; } }
private void check Log (  Ignite Logger log ) { assert ! log . is Debug Enabled ( ) ; assert log . is Info Enabled ( ) ; log . debug ( _ STR ) ; log . info ( _ STR ) ; log . warning ( _ STR ) ; log . warning ( _ STR , new  Exception ( _ STR ) ) ; log . error ( _ STR ) ; log . error ( _ STR , new  Exception ( _ STR ) ) ; }
protected boolean read Send Delay ( ) { try { send Delay =  Integer . parse Int ( send Delay Field . get Text ( ) ) ; } catch (  Exception e ) { status Text1 . set Text ( rb . get String ( _ STR ) ) ; status Text1 . set Visible ( _ BOOL ) ; send Delay = _ NUM ; error In Status1 = _ BOOL ; reset Notes2 ( ) ; return ( _ BOOL ) ; } if ( send Delay < _ NUM ) { status Text1 . set Text ( rb . get String ( _ STR ) ) ; status Text1 . set Visible ( _ BOOL ) ; send Delay = _ NUM ; error In Status1 = _ BOOL ; reset Notes2 ( ) ; return ( _ BOOL ) ; } if ( send Delay > _ NUM ) { status Text1 . set Text ( rb . get String ( _ STR ) ) ; status Text1 . set Visible ( _ BOOL ) ; send Delay = _ NUM ; error In Status1 = _ BOOL ; reset Notes2 ( ) ; return ( _ BOOL ) ; } return _ BOOL ; }
private  String Builder create Indent ( ) {  String Builder one Indent = new  String Builder ( ) ; one Indent . append ( _ STR ) ; return one Indent ; }
private static  Integer parse Int ( final  String value ) { try { return  Integer . parse Int ( value ) ; } catch (  Number Format Exception e ) { return null ; } }
public void mouse Pressed ( final  Mouse Event mouse Event ) {  Point last Clicked Point = mouse Event . get Point ( ) ; if ( mouse Event . is Control Down ( ) || ( mouse Event . get Button ( ) ==  Mouse Event .  BUTTON3 ) ) { context Menu . show ( frame , ( int ) last Clicked Point . get X ( ) +  MENU_ X_ OFFSET , ( int ) last Clicked Point . get Y ( ) +  MENU_ Y_ OFFSET ) ; } }
private boolean unseen Node (  Node candidate ) { if ( candidate != null && ! already Seen . contains ( candidate ) ) { current = candidate ; already Seen . add ( current ) ; return _ BOOL ; } return _ BOOL ; }
private void pull Event ( ) { final int new Scroll Value ; final int item Dimension ; final float initial Motion Value , last Motion Value ; switch ( get Pull To Refresh Scroll Direction ( ) ) { case  HORIZONTAL : initial Motion Value = m Initial Motion X ; last Motion Value = m Last Motion X ; break ; case  VERTICAL : default : initial Motion Value = m Initial Motion Y ; last Motion Value = m Last Motion Y ; break ; } switch ( m Current Mode ) { case  PULL_ FROM_ END : new Scroll Value =  Math . round (  Math . max ( initial Motion Value - last Motion Value , _ NUM ) /  FRICTION ) ; item Dimension = get Footer Size ( ) ; break ; case  PULL_ FROM_ START : default : new Scroll Value =  Math . round (  Math . min ( initial Motion Value - last Motion Value , _ NUM ) /  FRICTION ) ; item Dimension = get Header Size ( ) ; break ; } set Header Scroll ( new Scroll Value ) ; if ( new Scroll Value != _ NUM && ! is Refreshing ( ) ) { float scale =  Math . abs ( new Scroll Value ) / ( float ) item Dimension ; switch ( m Current Mode ) { case  PULL_ FROM_ END : m Footer Layout . on Pull ( scale ) ; break ; case  PULL_ FROM_ START : default : m Header Layout . on Pull ( scale ) ; break ; } if ( m State !=  State .  PULL_ TO_ REFRESH && item Dimension >=  Math . abs ( new Scroll Value ) ) { set State (  State .  PULL_ TO_ REFRESH ) ; } else if ( m State ==  State .  PULL_ TO_ REFRESH && item Dimension <  Math . abs ( new Scroll Value ) ) { set State (  State .  RELEASE_ TO_ REFRESH ) ; } } }
public synchronized void add Batch Clusterer Listener (  Batch Clusterer Listener cl ) { m_batch Clusterer Listeners . add Element ( cl ) ; }
public  Held Locks Token refresh ( long expiration Date Ms ) { return new  Held Locks Token ( token Id , client , creation Date Ms , expiration Date Ms , lock Map , lock Timeout , version Id ) ; }
void add Known Object (  Parse Object object ) { synchronized ( mutex ) { known Objects . add ( object ) ; } }
static  Bytes Store < ? ,  Byte Buffer > wrap ( @  Not Null  Byte Buffer bb ) { return bb . is Direct ( ) ?  Native Bytes Store . wrap ( bb ) :  Heap Bytes Store . wrap ( bb ) ; }
public static  File generate Content Path (  Context context ,  String type ) { if ( context == null ) { return null ; }  File base = context . get External Files Dir ( type ) ; if ( base == null ) { return null ; } if ( ! base . exists ( ) ) { if ( ! base . mkdirs ( ) ) { return null ; } } return base ; }
public void before Insert ( int index , boolean element ) { if ( index > size || index < _ NUM ) throw new  Index Out Of Bounds Exception ( _ STR + index + _ STR + size ) ; ensure Capacity ( size + _ NUM ) ;  System . arraycopy ( elements , index , elements , index + _ NUM , size - index ) ; elements [ index ] = element ; size ++ ; }
public void clear ( ) {  Grid Unsafe . copy Memory ( spine Empty ,  INT_ ARR_ OFF , spine ,  INT_ ARR_ OFF , spine Empty . length << _ NUM ) ;  Grid Unsafe . copy Memory ( next Empty ,  INT_ ARR_ OFF , next ,  INT_ ARR_ OFF , next Empty . length << _ NUM ) ;  Arrays . fill ( objs , null ) ; size = _ NUM ; }
public  Sided Plane ( final  Vector p , final  Vector  A , final  Vector  B ) { super (  A ,  B ) ; sig Num =  Math . signum ( evaluate ( p ) ) ; if ( sig Num == _ NUM ) throw new  Illegal Argument Exception ( _ STR ) ; }
public void clear ( ) { clear ( _ BOOL ) ; }
public static  String null Format ( final  Object obj ) { return obj == null ? _ STR : obj . to String ( ) ; }
public static void assert End Of Output Expected To Contain (  String end Marker ,  String expected String ,  File log ) {  String r = read Logfile ( log ) ; int idx = r . index Of ( end Marker ) ; if ( idx == - _ NUM ) fail ( _ STR + end Marker + _ STR + expected String + _ STR ) ;  String x = r . substring ( idx ) ; assert Expected Output Contains ( expected String , x ) ; }
public boolean add (  String classname ) {  String pkgname ;  Hash Set <  String > names ; classname = clean Up ( classname ) ; pkgname = extract Package ( classname ) ; if ( ! m_ Cache . contains Key ( pkgname ) ) { m_ Cache . put ( pkgname , new  Hash Set <  String > ( ) ) ; } names = m_ Cache . get ( pkgname ) ; return names . add ( classname ) ; }
public void test Completed Stage ( ) {  Atomic Integer x = new  Atomic Integer ( _ NUM ) ;  Atomic Reference <  Throwable > r = new  Atomic Reference <  Throwable > ( ) ;  Completion Stage <  Integer > f =  Completable Future . completed Stage ( _ NUM ) ; f . when Complete ( null ) ; assert Equals ( x . get ( ) , _ NUM ) ; assert Null ( r . get ( ) ) ; }
@  Override public void print Component (  Graphics gr ) {  Graphics2 D g = (  Graphics2 D ) gr ; g . set Rendering Hint (  Rendering Hints .  KEY_ ALPHA_ INTERPOLATION ,  Rendering Hints .  VALUE_ ALPHA_ INTERPOLATION_ QUALITY ) ; g . set Rendering Hint (  Rendering Hints .  KEY_ ANTIALIASING ,  Rendering Hints .  VALUE_ ANTIALIAS_ ON ) ; g . set Rendering Hint (  Rendering Hints .  KEY_ STROKE_ CONTROL ,  Rendering Hints .  VALUE_ STROKE_ NORMALIZE ) ; g . set Rendering Hint (  Rendering Hints .  KEY_ FRACTIONALMETRICS ,  Rendering Hints .  VALUE_ FRACTIONALMETRICS_ ON ) ; g . set Rendering Hint (  Rendering Hints .  KEY_ INTERPOLATION ,  Rendering Hints .  VALUE_ INTERPOLATION_ BICUBIC ) ; g . set Rendering Hint (  Rendering Hints .  KEY_ RENDERING ,  Rendering Hints .  VALUE_ RENDER_ QUALITY ) ; g . set Rendering Hint (  Rendering Hints .  KEY_ TEXT_ ANTIALIASING ,  Rendering Hints .  VALUE_ TEXT_ ANTIALIAS_ ON ) ; draw Drawing ( g ) ; }
public void class Loader Destroy (  Dynamic Class Loader loader ) {  Object resource = _resource Ref . get ( ) ; if ( resource == null ) return ;  Method destroy =  Close Listener . get Destroy Method ( resource . get Class ( ) ) ; if ( destroy == null ) return ; try { destroy . invoke ( resource , (  Object [ ] ) null ) ; } catch (  Throwable e ) { log . log (  Level .  WARNING , e . to String ( ) , e ) ; } }
public boolean delete Attachment Point ( long sw , short port ) {  Attachment Point ap = new  Attachment Point ( sw , port , _ NUM ) ; if ( this . old APs != null ) {  Array List <  Attachment Point > ap List = new  Array List <  Attachment Point > ( ) ; ap List . add All ( this . old APs ) ; int index = ap List . index Of ( ap ) ; if ( index > _ NUM ) { ap List . remove ( index ) ; this . old APs = ap List ; } } if ( this . attachment Points != null ) {  Array List <  Attachment Point > ap List = new  Array List <  Attachment Point > ( ) ; ap List . add All ( this . attachment Points ) ; int index = ap List . index Of ( ap ) ; if ( index > _ NUM ) { ap List . remove ( index ) ; this . attachment Points = ap List ; return _ BOOL ; } } return _ BOOL ; }
public static  String remove (  String original ,  String to Be Removed , boolean ignore Case ) {  String this Result = null ; if ( ! to Be Removed . equals ( _ STR ) && to Be Removed != null ) { this Result = replace ( original , to Be Removed , _ STR , ignore Case , _ BOOL ) ; } return this Result ; }
public synchronized long total Recover Bytes ( ) { long total = _ NUM ; for (  File file : file Details . values ( ) ) { if ( file . reused ( ) == _ BOOL ) { total += file . length ( ) ; } } return total ; }
@  Override @  Timed public  Assignment assign User (  Assignment assignment ,  Experiment experiment ,  Date date ) {  Assignment new_assignment = null ; if ( assign User To Old ) { new_assignment = assign User To Old ( assignment , date ) ; } if ( assign User To New ) { new_assignment = assign User To Look Up ( assignment , date ) ; } boolean count Up = _ BOOL ; assignments Count Executor . execute ( new  Assignment Count Envelope ( assignments Repository , experiment Repository , db Repository , experiment , assignment , count Up , event Log , date , assign User To Export , assign Bucket Count ) ) ; index User To Experiment ( assignment ) ; index User To Bucket ( assignment ) ; index Experiments To User ( assignment ) ; return new_assignment ; }
public static  String format (  Object obj ) { if ( obj instanceof  Number ) { return format ( (  Number ) obj ) ; } else { return obj . to String ( ) ; } }
public static void add Plugin (  View Dump Plugin view Dump Plugin ) { s Plugins . add ( view Dump Plugin ) ; }
private void check Stop ( ) { if ( m Can Process Audio && m Output . is Running ( ) && m Output . available ( ) >= m Buffer Stop Threshold ) { m Output . drain ( ) ; m Output . stop ( ) ; } }
public static  Property Filter value Of (  String filter String ) { if ( filter String == null || filter String . length ( ) == _ NUM ||  ALL . equals ( filter String = filter String . trim ( ) ) ) { return  ALL_ FILTER ; } else if ( filter String . equals Ignore Case (  NONE ) ) { return  NONE_ FILTER ; } return new  Property Filter ( filter String ) ; }
@  Deprecated public boolean is Http Url OK (  String url String ) { try {  URL e = new  URL ( url String ) ;  Http URLConnection url Connection = (  Http URLConnection ) e . open Connection ( ) ; url Connection . set Request Method ( _ STR ) ; int response Code = url Connection . get Response Code ( ) ; if ( response Code == _ NUM ) { return _ BOOL ; } else { return _ BOOL ; } } catch (  Exception e ) { return _ BOOL ; } }
public static void consolidate (  Properties ctx ) {  String sql = _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR ;  Prepared Statement pstmt = null ;  Result Set rs = null ; int success = _ NUM ; int errors = _ NUM ; try { pstmt =  DB . prepare Statement ( sql , null ) ; pstmt . set Int ( _ NUM ,  Env . get AD_ Client_ ID ( ctx ) ) ; rs = pstmt . execute Query ( ) ; while ( rs . next ( ) ) {  MMatch PO po1 = new  MMatch PO ( ctx , rs , null ) ; if ( rs . next ( ) ) {  MMatch PO po2 = new  MMatch PO ( ctx , rs , null ) ; if ( po1 . get M_ In Out Line_ ID ( ) != _ NUM && po1 . get C_ Invoice Line_ ID ( ) == _ NUM && po2 . get M_ In Out Line_ ID ( ) == _ NUM && po2 . get C_ Invoice Line_ ID ( ) != _ NUM ) {  String s1 = _ STR + po2 . get C_ Invoice Line_ ID ( ) + _ STR + po1 . get M_ Match PO_ ID ( ) ; int no1 =  DB . execute Update ( s1 , null ) ; if ( no1 != _ NUM ) { errors ++ ; s_log . warning ( _ STR + po1 . get M_ Match PO_ ID ( ) ) ; continue ; }  String s2 = _ STR ; int no2 =  DB . execute Update ( s2 , po2 . get M_ Match PO_ ID ( ) , null ) ;  String s3 = _ STR ; int no3 =  DB . execute Update ( s3 , po2 . get M_ Match PO_ ID ( ) , null ) ; if ( no2 == _ NUM && no3 == _ NUM ) success ++ ; else { s_log . warning ( _ STR + po2 . get M_ Match PO_ ID ( ) + _ STR + no2 + _ STR + no3 ) ; errors ++ ; } } } } } catch (  Exception e ) { s_log . log (  Level .  SEVERE , sql , e ) ; } finally {  DB . close ( rs , pstmt ) ; rs = null ; pstmt = null ; } if ( errors == _ NUM && success == _ NUM ) ; else s_log . info ( _ STR + success + _ STR + errors ) ; }
public static  String check Path Ending (  String path ) { path . replace ( _ STR , _ STR ) ; if ( path . ends With ( _ STR ) ) return path ; else return path + _ STR ; }
public void add Notifier ( final  DSSNotifier dss Notifier ) { if ( ! notifiers . contains ( dss Notifier ) ) {  LOG . trace ( _ STR + dss Notifier ) ; notifiers . add ( dss Notifier ) ; } }
private void create The User For Single User Mode ( ) { if ( ! is In Single User Mode ( ) ) { return ; } try { final  User user = db Logic . get Or Create User ( single User Name ) ; if ( user == null ) { logger . log (  Level .  SEVERE , _ STR ) ; return ; } if ( ! user . get Is Single User ( ) ) { user . set Is Single User ( _ BOOL ) ; } if ( ! user . get Is Admin ( ) ) { user . set Is Admin ( _ BOOL ) ; } db Logic . commit ( ) ; } catch ( final  Persistence Exception e ) { logger . log (  Level .  SEVERE , _ STR , e ) ; } }
public  String app_source_path (  String app_class ) {  String filename = app_class . replace ( _ STR , _ STR ) ; filename = filename . replace First ( _ STR , _ STR ) ; if ( filename . index Of ( _ STR ) > _ NUM ) { filename = filename . substring ( _ NUM , filename . index Of ( _ STR ) ) ; } return _ STR + filename + _ STR ; }
private void need New Buffer ( int newcount ) { if ( current Buffer Index < buffers . size ( ) - _ NUM ) { filled Buffer Sum += current Buffer . length ; current Buffer Index ++ ; current Buffer = buffers . get ( current Buffer Index ) ; } else { int new Buffer Size ; if ( current Buffer == null ) { new Buffer Size = newcount ; filled Buffer Sum = _ NUM ; } else { new Buffer Size =  Math . max ( current Buffer . length << _ NUM , newcount - filled Buffer Sum ) ; filled Buffer Sum += current Buffer . length ; } current Buffer Index ++ ; current Buffer = new byte [ new Buffer Size ] ; buffers . add ( current Buffer ) ; } }
public  String clean Text Value (  String text ) { if ( text != null ) { return text . trim ( ) ; } else { return text ; } }
public  Input Stream read ( ) { return new  Byte Array Input Stream ( data ) ; }
private final  Styled String append Parameter Signature (  Styled String buffer , char [ ] [ ] parameter Types , char [ ] [ ] parameter Names ) { if ( parameter Types != null ) { for ( int i = _ NUM ; i < parameter Types . length ; i ++ ) { if ( i > _ NUM ) { buffer . append ( _ STR ) ; buffer . append ( _ STR ) ; } buffer . append ( parameter Types [ i ] ) ; if ( parameter Names != null && parameter Names [ i ] != null ) { buffer . append ( _ STR ) ; buffer . append ( parameter Names [ i ] ) ; } } } return buffer ; }
public void start Heartbeat (  Database database ,  String name ) throws  SQLException {  Array List <  Column > where Clause = new  Array List <  Column > ( ) ;  Array List <  Column > values = new  Array List <  Column > ( ) ;  Timestamp now = new  Timestamp (  System . current Time Millis ( ) ) ; if ( logger . is Debug Enabled ( ) ) logger . debug ( _ STR + name + _ STR + now ) ; hb Id . set Value (  KEY ) ; where Clause . add ( hb Id ) ; hb Source Tstamp . set Value ( now ) ; hb Salt . set Value ( salt Value . get And Increment ( ) ) ; hb Name . set Value ( name ) ; values . add ( hb Source Tstamp ) ; values . add ( hb Salt ) ; values . add ( hb Name ) ; database . update ( hb Table , where Clause , values ) ; }
public int process Packet ( byte [ ] in , int in Off , int in Len , byte [ ] output , int out Off ) throws  Illegal State Exception ,  Invalid Cipher Text Exception ,  Data Length Exception { if ( key Param == null ) { throw new  Illegal State Exception ( _ STR ) ; } int n = nonce . length ; int q = _ NUM - n ; if ( q < _ NUM ) { int limit Len = _ NUM << ( _ NUM * q ) ; if ( in Len >= limit Len ) { throw new  Illegal State Exception ( _ STR ) ; } } byte [ ] iv = new byte [ block Size ] ; iv [ _ NUM ] = ( byte ) ( ( q - _ NUM ) & _ NUM ) ;  System . arraycopy ( nonce , _ NUM , iv , _ NUM , nonce . length ) ;  Block Cipher ctr Cipher = new  SICBlock Cipher ( cipher ) ; ctr Cipher . init ( for Encryption , new  Parameters With IV ( key Param , iv ) ) ; int output Len ; int in Index = in Off ; int out Index = out Off ; if ( for Encryption ) { output Len = in Len + mac Size ; if ( output . length < ( output Len + out Off ) ) { throw new  Output Length Exception ( _ STR ) ; } calculate Mac ( in , in Off , in Len , mac Block ) ; ctr Cipher . process Block ( mac Block , _ NUM , mac Block , _ NUM ) ; while ( in Index < ( in Off + in Len - block Size ) ) { ctr Cipher . process Block ( in , in Index , output , out Index ) ; out Index += block Size ; in Index += block Size ; } byte [ ] block = new byte [ block Size ] ;  System . arraycopy ( in , in Index , block , _ NUM , in Len + in Off - in Index ) ; ctr Cipher . process Block ( block , _ NUM , block , _ NUM ) ;  System . arraycopy ( block , _ NUM , output , out Index , in Len + in Off - in Index ) ;  System . arraycopy ( mac Block , _ NUM , output , out Off + in Len , mac Size ) ; } else { if ( in Len < mac Size ) { throw new  Invalid Cipher Text Exception ( _ STR ) ; } output Len = in Len - mac Size ; if ( output . length < ( output Len + out Off ) ) { throw new  Output Length Exception ( _ STR ) ; }  System . arraycopy ( in , in Off + output Len , mac Block , _ NUM , mac Size ) ; ctr Cipher . process Block ( mac Block , _ NUM , mac Block , _ NUM ) ; for ( int i = mac Size ; i != mac Block . length ; i ++ ) { mac Block [ i ] = _ NUM ; } while ( in Index < ( in Off + output Len - block Size ) ) { ctr Cipher . process Block ( in , in Index , output , out Index ) ; out Index += block Size ; in Index += block Size ; } byte [ ] block = new byte [ block Size ] ;  System . arraycopy ( in , in Index , block , _ NUM , output Len - ( in Index - in Off ) ) ; ctr Cipher . process Block ( block , _ NUM , block , _ NUM ) ;  System . arraycopy ( block , _ NUM , output , out Index , output Len - ( in Index - in Off ) ) ; byte [ ] calculated Mac Block = new byte [ block Size ] ; calculate Mac ( output , out Off , output Len , calculated Mac Block ) ; if ( !  Arrays . constant Time Are Equal ( mac Block , calculated Mac Block ) ) { throw new  Invalid Cipher Text Exception ( _ STR ) ; } } return output Len ; }
public  Public Key load Public Key ( int id ) throws  Exception { if ( default Keys ) { return get Public Key From String (  RSAKey Loader .  DEFAULT_ UKEY ) ; }  File Reader f = new  File Reader ( path + _ STR + id ) ;  Buffered Reader r = new  Buffered Reader ( f ) ;  String tmp = _ STR ;  String key = _ STR ; while ( ( tmp = r . read Line ( ) ) != null ) { key = key + tmp ; } f . close ( ) ; r . close ( ) ;  Public Key ret = get Public Key From String ( key ) ; return ret ; }
public void add Categories Listener (  Snapshot Categories Listener listener ) { listeners . add ( listener ) ; }
public  Daily Time Interval Schedule Builder on Days Of The Week (  Integer ... on Days Of Week ) {  Set <  Integer > days As Set = new  Hash Set <  Integer > ( _ NUM ) ;  Collections . add All ( days As Set , on Days Of Week ) ; return on Days Of The Week ( days As Set ) ; }
public static int [ ] string To Int Array (  String str ) { if ( str == null ) { return ( null ) ; }  String [ ] array = str . split ( _ STR ) ; if ( array . length == _ NUM ) { array = new  String [ ] { str . trim ( ) } ; } int [ ] n Array = new int [ array . length ] ; for ( int i = _ NUM ; i < n Array . length ; ++ i ) { n Array [ i ] =  Integer . parse Int ( array [ i ] ) ; } return ( n Array ) ; }
private boolean is Lockout Enabled ( ) { if ( _max Authn Login Attemts Count == _ NUM || _max Authn Login Attemts Life Time In Mins == _ NUM ) { return _ BOOL ; } return _ BOOL ; }
public int size ( ) { return urls . size ( ) ; }
public void inline Image (  Rendered Image image ,  Color bkg ,  String encode ) throws  IOException {  Image Bytes bytes = new  Image Bytes ( image , bkg ,  Image Constants .  JPG ,  Image Constants .  COLOR_ MODEL_ RGB ) ; println ( _ STR ) ; image Info ( _ STR , image . get Width ( ) ) ; image Info ( _ STR , image . get Height ( ) ) ; image Info ( _ STR , pdf . name ( _ STR ) ) ; image Info ( _ STR , _ NUM ) ; image Info ( _ STR , get Filter Name ( bytes . get Format ( ) ) ) ; print ( _ STR ) ; write ( bytes . get Bytes ( ) ) ; println ( _ STR ) ; }
public void vertex ( float [ ] v ) { vertex Check ( ) ; curve Vertex Count = _ NUM ; float [ ] vertex = vertices [ vertex Count ] ;  System . arraycopy ( v , _ NUM , vertex , _ NUM ,  VERTEX_ FIELD_ COUNT ) ; vertex Count ++ ; }
private void configure Auth (  Client Builder client Builder ) { if ( conf . client . auth Type ==  Authentication Type .  OAUTH ) { auth Token =  Jersey Client Util . configure OAuth1 ( conf . client . oauth , client Builder ) ; } else if ( conf . client . auth Type !=  Authentication Type .  NONE ) {  Jersey Client Util . configure Password Auth ( conf . client . auth Type , conf . client . basic Auth , client Builder ) ; } }
private static int index Of ( int from Index ,  Char Sequence csq ) { if ( csq == null ) return _ NUM ; int length = csq . length ( ) ; int j = from Index ; int i = ( j < length ) ?  Character . to Upper Case ( csq . char At ( j ++ ) ) : _ NUM ; i <<= _ NUM ; i |= ( j < length ) ?  Character . to Upper Case ( csq . char At ( j ++ ) ) : _ NUM ; return i ; }
protected  Size Requirements calculate Minor Axis Requirements ( int axis ,  Size Requirements r ) { if ( r == null ) { r = new  Size Requirements ( ) ; } float pref = layout Pool . get Preferred Span ( axis ) ; float min = layout Pool . get Minimum Span ( axis ) ; r . minimum = ( int ) min ; r . preferred =  Math . max ( r . minimum , ( int ) pref ) ; r . maximum =  Integer .  MAX_ VALUE ; r . alignment = _ NUM ; return r ; }
public static  String trim Trailing Spaces (  String string ) { if ( string == null ) { return null ; } for ( int i = string . length ( ) - _ NUM ; i >= _ NUM ; i -- ) { if ( string . char At ( i ) == _ STR || string . char At ( i ) == _ STR || string . char At ( i ) == _ STR || string . char At ( i ) == _ STR ) { continue ; } else { string = string . substring ( _ NUM , i + _ NUM ) ; return string ; } } return string ; }
public static  Function from String (  String name ) { if ( name != null ) { for (  Function func :  Function . values ( ) ) { if ( name . equals Ignore Case ( func . get Name ( ) ) ) { return func ; } } } throw new  Illegal Argument Exception ( name ) ; }
public  String global Info ( ) { return _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR ; }
public int index Of Column Name (  String column Name ) { return column Name List . index Of ( column Name . to Lower Case ( ) ) ; }
private double [ ] project Sparse (  Sparse Number Vector in , double [ ] ret ) {  Arrays . fill ( ret , _ NUM ) ; for ( int iter = in . iter ( ) ; in . iter Valid ( iter ) ; iter = in . iter Advance ( iter ) ) { final int i = in . iter Dim ( iter ) ; final double val = in . iter Double Value ( iter ) ; for ( int o = _ NUM ; o < ret . length ; o ++ ) { ret [ o ] += val * matrix [ o ] [ i ] ; } } return ret ; }
protected  Array List < float [ ] > _forward Poly ( double [ ] rawllpts , int ltype , int nsegs , boolean is Filled ) { boolean  DEBUG =  Debug . debugging ( _ STR ) ; int len = rawllpts . length > > > _ NUM ; if ( len < _ NUM ) return new  Array List < float [ ] > ( _ NUM ) ; if ( is Complicated Line Type ( ltype ) ) return do Poly Dispatch ( rawllpts , ltype , nsegs , is Filled ) ; int invalid_count = _ NUM ; boolean curr_invalid , prev_invalid = _ BOOL ;  Point temp = new  Point ( ) ;  Azimuth Var az_first = null , az_save = null , az Var = new  Azimuth Var ( ) ;  Array List <  Azimuth Var > sections = new  Array List <  Azimuth Var > ( _ NUM ) ; float [ ] x_ , xs = new float [ len ] ; float [ ] y_ , ys = new float [ len ] ; _forward ( rawllpts [ _ NUM ] , rawllpts [ _ NUM ] , temp , az Var ) ; xs [ _ NUM ] = temp . x ; ys [ _ NUM ] = temp . y ; prev_invalid = az Var . invalid_forward ; if ( prev_invalid ) { ++ invalid_count ; } else { az Var . index = _ NUM ; az Var . current_azimuth = ( float )  Great Circle . spherical Azimuth ( center Y , center X , rawllpts [ _ NUM ] , rawllpts [ _ NUM ] ) ; if ( ! is Filled ) { sections . add ( az Var ) ; } else { az_first = az Var ; } az Var = new  Azimuth Var ( ) ; } int i = _ NUM , j = _ NUM ; for ( i = _ NUM , j = _ NUM ; i < len ; i ++ , j += _ NUM ) { az Var . invalid_forward = _ BOOL ; _forward ( rawllpts [ j ] , rawllpts [ j + _ NUM ] , temp , az Var ) ; curr_invalid = az Var . invalid_forward ; xs [ i ] = temp . x ; ys [ i ] = temp . y ; if ( ! curr_invalid && prev_invalid ) { az Var . index = i - _ NUM ; az Var . current_azimuth = ( float )  Great Circle . spherical Azimuth ( center Y , center X , rawllpts [ j - _ NUM ] , rawllpts [ j - _ NUM ] ) ; sections . add ( az Var ) ; az Var = new  Azimuth Var ( ) ; } else if ( curr_invalid ) { if ( ! prev_invalid ) { az Var . index = i ; if ( is Filled && ( invalid_count == _ NUM ) ) { az_save = az Var ; } else { sections . add ( az Var ) ; } az Var = new  Azimuth Var ( ) ; } ++ invalid_count ; } prev_invalid = curr_invalid ; } if ( invalid_count == _ NUM ) {  Array List < float [ ] > ret_val = new  Array List < float [ ] > ( _ NUM ) ; ret_val . add ( xs ) ; ret_val . add ( ys ) ; return ret_val ; } if ( invalid_count == len ) { return new  Array List < float [ ] > ( _ NUM ) ; } if ( ! prev_invalid ) { if ( is Filled && ( az_save != null ) ) { int l = az_save . index ; x_ = new float [ len + l ] ; y_ = new float [ len + l ] ;  System . arraycopy ( xs , _ NUM , x_ , _ NUM , len ) ;  System . arraycopy ( ys , _ NUM , y_ , _ NUM , len ) ;  System . arraycopy ( xs , _ NUM , x_ , len , l ) ;  System . arraycopy ( ys , _ NUM , y_ , len , l ) ; az_save . index = len + l ; sections . add ( az_save ) ; xs = x_ ; ys = y_ ; } else { if (  DEBUG && is Filled && ( az_save == null ) ) {  Debug . output ( _ STR ) ; } az Var . index = i ; j = rawllpts . length ; az Var . current_azimuth = ( float )  Great Circle . spherical Azimuth ( center Y , center X , rawllpts [ j - _ NUM ] , rawllpts [ j - _ NUM ] ) ; sections . add ( az Var ) ; } } else if ( az_save != null ) { if (  DEBUG )  Debug . output ( _ STR ) ; sections . add ( az_first ) ; sections . add ( az_save ) ; } int size = sections . size ( ) ;  Array List < float [ ] > ret_val = new  Array List < float [ ] > ( size ) ; if ( is Filled && ( len > _ NUM ) ) { generate Filled Poly ( xs , ys , sections , ret_val ) ; return ret_val ; } for ( j = _ NUM ; j < size ; j += _ NUM ) {  Azimuth Var az1 = (  Azimuth Var ) sections . get ( j ) ;  Azimuth Var az2 = (  Azimuth Var ) sections . get ( j + _ NUM ) ; int off1 = az1 . index ; int off2 = az2 . index ; int l = off2 - off1 ; x_ = new float [ l ] ; y_ = new float [ l ] ;  System . arraycopy ( xs , off1 , x_ , _ NUM , l ) ;  System . arraycopy ( ys , off1 , y_ , _ NUM , l ) ; ret_val . add ( x_ ) ; ret_val . add ( y_ ) ; } return ret_val ; }
public static synchronized  Period Type for Fields (  Duration Field Type [ ] types ) { if ( types == null || types . length == _ NUM ) { throw new  Illegal Argument Exception ( _ STR ) ; } for ( int i = _ NUM ; i < types . length ; i ++ ) { if ( types [ i ] == null ) { throw new  Illegal Argument Exception ( _ STR ) ; } }  Map <  Period Type ,  Object > cache = c Types ; if ( cache . is Empty ( ) ) { cache . put ( standard ( ) , standard ( ) ) ; cache . put ( year Month Day Time ( ) , year Month Day Time ( ) ) ; cache . put ( year Month Day ( ) , year Month Day ( ) ) ; cache . put ( year Week Day Time ( ) , year Week Day Time ( ) ) ; cache . put ( year Week Day ( ) , year Week Day ( ) ) ; cache . put ( year Day Time ( ) , year Day Time ( ) ) ; cache . put ( year Day ( ) , year Day ( ) ) ; cache . put ( day Time ( ) , day Time ( ) ) ; cache . put ( time ( ) , time ( ) ) ; cache . put ( years ( ) , years ( ) ) ; cache . put ( months ( ) , months ( ) ) ; cache . put ( weeks ( ) , weeks ( ) ) ; cache . put ( days ( ) , days ( ) ) ; cache . put ( hours ( ) , hours ( ) ) ; cache . put ( minutes ( ) , minutes ( ) ) ; cache . put ( seconds ( ) , seconds ( ) ) ; cache . put ( millis ( ) , millis ( ) ) ; }  Period Type in Part Type = new  Period Type ( null , types , null ) ;  Object cached = cache . get ( in Part Type ) ; if ( cached instanceof  Period Type ) { return (  Period Type ) cached ; } if ( cached != null ) { throw new  Illegal Argument Exception ( _ STR + cached ) ; }  Period Type type = standard ( ) ;  List <  Duration Field Type > list = new  Array List <  Duration Field Type > (  Arrays . as List ( types ) ) ; if ( list . remove (  Duration Field Type . years ( ) ) == _ BOOL ) { type = type . with Years Removed ( ) ; } if ( list . remove (  Duration Field Type . months ( ) ) == _ BOOL ) { type = type . with Months Removed ( ) ; } if ( list . remove (  Duration Field Type . weeks ( ) ) == _ BOOL ) { type = type . with Weeks Removed ( ) ; } if ( list . remove (  Duration Field Type . days ( ) ) == _ BOOL ) { type = type . with Days Removed ( ) ; } if ( list . remove (  Duration Field Type . hours ( ) ) == _ BOOL ) { type = type . with Hours Removed ( ) ; } if ( list . remove (  Duration Field Type . minutes ( ) ) == _ BOOL ) { type = type . with Minutes Removed ( ) ; } if ( list . remove (  Duration Field Type . seconds ( ) ) == _ BOOL ) { type = type . with Seconds Removed ( ) ; } if ( list . remove (  Duration Field Type . millis ( ) ) == _ BOOL ) { type = type . with Millis Removed ( ) ; } if ( list . size ( ) > _ NUM ) { cache . put ( in Part Type , list ) ; throw new  Illegal Argument Exception ( _ STR + list ) ; }  Period Type check Part Type = new  Period Type ( null , type . i Types , null ) ;  Period Type checked Type = (  Period Type ) cache . get ( check Part Type ) ; if ( checked Type != null ) { cache . put ( check Part Type , checked Type ) ; return checked Type ; } cache . put ( check Part Type , type ) ; return type ; }
public void add (  String text ) { if ( errors == null ) { errors = new  Array List <  String > ( ) ; } errors . add ( text ) ; }
protected void smart Indent After New Line (  IDocument document ,  Document Command command ) { int doc Length = document . get Length ( ) ; if ( command . offset == - _ NUM || doc Length == _ NUM ) { return ; } try { int p = ( command . offset == doc Length ? command . offset - _ NUM : command . offset ) ; int line = document . get Line Of Offset ( p ) ;  String Buffer buf = new  String Buffer ( command . text ) ; if ( command . offset < doc Length && document . get Char ( command . offset ) == _ STR ) { int ind Line = find Matching Open Bracket ( document , line , command . offset , _ NUM ) ; if ( ind Line == - _ NUM ) { ind Line = line ; } buf . append ( get Indent Of Line ( document , ind Line ) ) ; } else { int start = document . get Line Offset ( line ) ; int whiteend = find End Of White Space ( document , start , command . offset ) ; buf . append ( document . get ( start , whiteend - start ) ) ; if ( get Bracket Count ( document , start , command . offset , _ BOOL ) > _ NUM ) { buf . append ( get Indent Token ( ) ) ; } } command . text = buf . to String ( ) ; } catch (  Bad Location Exception e ) {  GWTPlugin Log . log Error ( e ) ; } }
private  String input Accrued National Number ( ) { int length Of National Number = national Number . length ( ) ; if ( length Of National Number > _ NUM ) {  String temp National Number = _ STR ; for ( int i = _ NUM ; i < length Of National Number ; i ++ ) { temp National Number = input Digit Helper ( national Number . char At ( i ) ) ; } return able To Format ? append National Number ( temp National Number ) : accrued Input . to String ( ) ; } else { return prefix Before National Number . to String ( ) ; } }
private boolean dyn Init ( ) {  Vector <  String > column Names = new  Vector <  String > ( ) ; column Names . add (  Msg . translate (  Env . get Ctx ( ) , m_ C_ BPartner_ ID == _ NUM ? _ STR : _ STR ) ) ; column Names . add (  Msg . translate (  Env . get Ctx ( ) , _ STR ) ) ; column Names . add (  Msg . translate (  Env . get Ctx ( ) , _ STR ) ) ; column Names . add (  Msg . translate (  Env . get Ctx ( ) , _ STR ) ) ; column Names . add (  Msg . translate (  Env . get Ctx ( ) , _ STR ) ) ; column Names . add (  Msg . translate (  Env . get Ctx ( ) , _ STR ) ) ; column Names . add (  Msg . translate (  Env . get Ctx ( ) , _ STR ) ) ;  Vector <  Vector <  Object > > data = null ; if ( m_ C_ BPartner_ ID == _ NUM ) data = query BPartner ( ) ; else data = query Product ( ) ; m_model Price = new  Default Table Model ( data , column Names ) ; m_table Price . set Model ( m_model Price ) ; m_table Price . set Column Class ( _ NUM ,  String . class , _ BOOL ) ; m_table Price . set Column Class ( _ NUM ,  Double . class , _ BOOL ) ; m_table Price . set Column Class ( _ NUM ,  Double . class , _ BOOL ) ; m_table Price . set Column Class ( _ NUM ,  Big Decimal . class , _ BOOL ) ; m_table Price . set Column Class ( _ NUM ,  String . class , _ BOOL ) ; m_table Price . set Column Class ( _ NUM ,  Timestamp . class , _ BOOL ) ; m_table Price . set Column Class ( _ NUM ,  String . class , _ BOOL ) ; m_table Price . auto Size ( ) ; return data . size ( ) != _ NUM ; }
@  Override protected  Field Config Base create Copy (  Field Config Base field Config Base ) {  Field Config String copy = null ; if ( field Config Base != null ) { copy = new  Field Config String ( field Config Base . get Common Data ( ) , this . button Text ) ; } return copy ; }
private void draw Overflow Indicator ( final  Workflow Annotation anno , final  Graphics2 D g , final  Rectangle2 D loc , final boolean printing ) { if ( printing ) { return ; }  Graphics2 D g2 = (  Graphics2 D ) g . create ( ) ; int size = _ NUM ; int x Offset = _ NUM ; int y Offset = _ NUM ; int step Size = size / _ NUM ; int dot Size = _ NUM ; int x = ( int ) loc . get Max X ( ) - size - x Offset ; int y = ( int ) loc . get Max Y ( ) - size - y Offset ;  Gradient Paint gp = new  Gradient Paint ( x , y ,  Color .  WHITE , x , y + size * _ NUM ,  Color .  LIGHT_ GRAY ) ; g2 . set Paint ( gp ) ; g2 . fill Rect ( x , y , size , size ) ; g2 . set Color (  Color .  BLACK ) ; g2 . draw Rect ( x , y , size , size ) ; g2 . fill Oval ( x + step Size , y + step Size * _ NUM , dot Size , dot Size ) ; g2 . fill Oval ( x + step Size * _ NUM , y + step Size * _ NUM , dot Size , dot Size ) ; g2 . fill Oval ( x + step Size * _ NUM , y + step Size * _ NUM , dot Size , dot Size ) ; g2 . dispose ( ) ; }
private boolean is Redundant (  Coordinate pt ) { if ( pt List . size ( ) < _ NUM ) return _ BOOL ;  Coordinate last Pt = (  Coordinate ) pt List . get ( pt List . size ( ) - _ NUM ) ; double pt Dist = pt . distance ( last Pt ) ; if ( pt Dist < minimim Vertex Distance ) return _ BOOL ; return _ BOOL ; }
public static  Configuration load (  Input Stream stream ) throws  IOException { try {  Properties properties = new  Properties ( ) ; properties . load ( stream ) ; return from ( properties ) ; } finally { stream . close ( ) ; } }
public void add (  T item ) { items . add ( item ) ; }
private static  Element add Bean (  Document doc ,  Node parent ,  Class < ? > cls ) {  Element elem = doc . create Element ( _ STR ) ; elem . set Attribute ( _ STR , cls . get Name ( ) ) ; parent . append Child ( elem ) ; return elem ; }
@  Override public final boolean read Boolean ( ) throws  IOException { return dis . read Boolean ( ) ; }
@  Override public  Enumeration <  String > enumerate Measures ( ) {  Vector <  String > new Vector = new  Vector <  String > ( _ NUM ) ; new Vector . add Element ( _ STR ) ; return new Vector . elements ( ) ; }
@  Override public  Instances define Data Format ( ) throws  Exception {  Array List <  Attribute > atts ; m_ Random = new  Random ( get Seed ( ) ) ; m_ Noise Random = new  Random ( get Seed ( ) ) ; set Num Examples Act ( get Num Examples ( ) ) ; atts = new  Array List <  Attribute > ( ) ; atts . add ( new  Attribute ( _ STR ) ) ; atts . add ( new  Attribute ( _ STR ) ) ; m_ Dataset Format = new  Instances ( get Relation Name To Use ( ) , atts , _ NUM ) ; return m_ Dataset Format ; }
public static double tile2lon ( int x , int z ) { return x /  Math . pow ( _ NUM , z ) * _ NUM - _ NUM ; }
public  DAbout (  JFrame parent ,  String title ,  String license Notice ,  Image about Img ,  Object [ ] ticker Items ) { super ( parent , title ,  Modality Type .  DOCUMENT_ MODAL ) ; init Components ( about Img , license Notice , ticker Items ) ; }
public double eval ( int id1 , int id2 ,  Instance inst1 ) throws  Exception { double div =  Math . sqrt ( super . eval ( id1 , id1 , inst1 ) * ( ( m_keys != null ) ? super . eval ( id2 , id2 , m_data . instance ( id2 ) ) : super . eval ( - _ NUM , - _ NUM , m_data . instance ( id2 ) ) ) ) ; if ( div != _ NUM ) { return super . eval ( id1 , id2 , inst1 ) / div ; } else { return _ NUM ; } }
Action Map create Action Map ( ) {  Action Map map = new  Action Map UIResource ( ) ; map . put ( _ STR , new  Show System Menu Action ( _ BOOL ) ) ; map . put ( _ STR , new  Show System Menu Action ( _ BOOL ) ) ; return map ; }
public  Text Editor ( ) { this ( _ BOOL ) ; }
public boolean equals ( java . lang .  Object obj ) { return obj != null && obj . get Class ( ) == get Class ( ) && ( (  Integer ) obj ) . value == value ; }
private static  Buffer concat (  List <  Buffer > buffers ) { int total Length = _ NUM ;  Buffer largest Buffer = null ; for (  Buffer buffer : buffers ) { total Length += buffer . length ; if ( largest Buffer == null || buffer . array . length > largest Buffer . array . length ) { largest Buffer = buffer ; } } if ( largest Buffer == null ) { return new  Buffer ( _ NUM ) ; } int [ ] docs = largest Buffer . array ; if ( docs . length < total Length + _ NUM ) { docs =  Arrays . copy Of ( docs , total Length + _ NUM ) ; } total Length = largest Buffer . length ; for (  Buffer buffer : buffers ) { if ( buffer != largest Buffer ) {  System . arraycopy ( buffer . array , _ NUM , docs , total Length , buffer . length ) ; total Length += buffer . length ; } } return new  Buffer ( docs , total Length ) ; }
public static void copy ( final  JText Area area ) { final  String selected Text = area . get Selected Text ( ) ; if ( selected Text == null ) {  Clipboard Helpers . copy To Clipboard ( area . get Text ( ) ) ; } else {  Clipboard Helpers . copy To Clipboard ( selected Text ) ; } }
public static  String format Cpu Percent ( float percent ) { return cpu Format . format ( percent ) + _ STR ; }
final private  String class Def2 Object Desc (  Attributes attrs ) throws  Naming Exception {  String Buffer object Desc = new  String Buffer ( _ STR ) ;  Attribute attr = null ; int count = _ NUM ; attr = attrs . get (  NUMERICOID_ ID ) ; if ( attr != null ) { object Desc . append ( write Numeric OID ( attr ) ) ; count ++ ; } else { throw new  Configuration Exception ( _ STR + _ STR ) ; } attr = attrs . get (  NAME_ ID ) ; if ( attr != null ) { object Desc . append ( write QDescrs ( attr ) ) ; count ++ ; } attr = attrs . get (  DESC_ ID ) ; if ( attr != null ) { object Desc . append ( write QDString ( attr ) ) ; count ++ ; } attr = attrs . get (  OBSOLETE_ ID ) ; if ( attr != null ) { object Desc . append ( write Boolean ( attr ) ) ; count ++ ; } attr = attrs . get (  SUP_ ID ) ; if ( attr != null ) { object Desc . append ( write OIDs ( attr ) ) ; count ++ ; } attr = attrs . get (  ABSTRACT_ ID ) ; if ( attr != null ) { object Desc . append ( write Boolean ( attr ) ) ; count ++ ; } attr = attrs . get (  STRUCTURAL_ ID ) ; if ( attr != null ) { object Desc . append ( write Boolean ( attr ) ) ; count ++ ; } attr = attrs . get (  AUXILARY_ ID ) ; if ( attr != null ) { object Desc . append ( write Boolean ( attr ) ) ; count ++ ; } attr = attrs . get (  MUST_ ID ) ; if ( attr != null ) { object Desc . append ( write OIDs ( attr ) ) ; count ++ ; } attr = attrs . get (  MAY_ ID ) ; if ( attr != null ) { object Desc . append ( write OIDs ( attr ) ) ; count ++ ; } if ( count < attrs . size ( ) ) {  String attr Id = null ; for (  Naming Enumeration < ? extends  Attribute > ae = attrs . get All ( ) ; ae . has More Elements ( ) ; ) { attr = ae . next ( ) ; attr Id = attr . get ID ( ) ; if ( attr Id . equals (  NUMERICOID_ ID ) || attr Id . equals (  NAME_ ID ) || attr Id . equals (  SUP_ ID ) || attr Id . equals (  MAY_ ID ) || attr Id . equals (  MUST_ ID ) || attr Id . equals (  STRUCTURAL_ ID ) || attr Id . equals (  DESC_ ID ) || attr Id . equals (  AUXILARY_ ID ) || attr Id . equals (  ABSTRACT_ ID ) || attr Id . equals (  OBSOLETE_ ID ) ) { continue ; } else { object Desc . append ( write QDStrings ( attr ) ) ; } } } object Desc . append ( _ STR ) ; return object Desc . to String ( ) ; }
public static <  T > void remove All (  Collection <  T > collection ,  Collection <  T > elements ) { if (  Collection Utils . is Empty ( collection ) ||  Collection Utils . is Empty ( elements ) ) { return ; } for (  T element : elements ) { collection . remove ( element ) ; } }
public  Image base For (  IHex hex ) { return hex Tileset . get Base ( hex , boardview ) ; }
public static  Date parse (  String date Str ) { try { return m Simple Date Time Format . parse ( date Str ) ; } catch (  Parse Exception e ) { e . print Stack Trace ( ) ; throw new  Runtime Exception ( _ STR ) ; } }
public void close ( ) { if ( log . is Loggable (  Level .  FINEST ) ) { log . finest ( _ STR + node + _ STR + client ) ; } if ( client != null ) { client . close ( ) ; client = null ; } if ( node != null ) { node . stop ( ) ; node = null ; } }
public void remove (  String key ) {  Iterator <  Pair <  String ,  Array List <  String > > > it = store . iterator ( ) ; while ( it . has Next ( ) ) {  String this Key = it . next ( ) . first ; if ( key . equals ( this Key ) ) { it . remove ( ) ; break ; } } }
public void add Edge ( final  Edge Type edge ) {  Preconditions . check Not Null ( edge , _ STR ) ; m_edges . add ( edge ) ; update Node To Edge Mapping ( edge ) ; }
public void delete Entity Config (  String realm ,  String entity Id ) throws  SAML2 Meta Exception { if ( entity Id == null ) { return ; } if ( realm == null ) { realm = _ STR ; }  String [ ] objs = { entity Id , realm } ; try {  Map old Attrs = config Inst . get Configuration ( realm , entity Id ) ;  Set old Values = (  Set ) old Attrs . get (  ATTR_ ENTITY_ CONFIG ) ; if ( old Values == null || old Values . is Empty ( ) ) {  Log Util . error (  Level .  INFO ,  Log Util .  NO_ ENTITY_ DESCRIPTOR_ DELETE_ ENTITY_ CONFIG , objs , null ) ; throw new  SAML2 Meta Exception ( _ STR , objs ) ; } remove From Circle Of Trust ( realm , entity Id ) ;  Set attr = new  Hash Set ( ) ; attr . add (  ATTR_ ENTITY_ CONFIG ) ; config Inst . delete Configuration ( realm , entity Id , attr ) ;  Log Util . access (  Level .  INFO ,  Log Util .  ENTITY_ CONFIG_ DELETED , objs , null ) ;  SAML2 Meta Cache . put Entity Config ( realm , entity Id , null ) ; } catch (  Configuration Exception e ) { debug . error ( _ STR , e ) ;  String [ ] data = { e . get Message ( ) , entity Id , realm } ;  Log Util . error (  Level .  INFO ,  Log Util .  CONFIG_ ERROR_ DELETE_ ENTITY_ CONFIG , data , null ) ; throw new  SAML2 Meta Exception ( e ) ; } }
public static synchronized  Data Source Window Manager shared Instance ( ) { if ( shared Instance == null ) shared Instance = new  Data Source Window Manager ( ) ; return shared Instance ; }
public static final  String color To String (  Color color ) { return ( color . get Red ( ) + _ STR + color . get Green ( ) + _ STR + color . get Blue ( ) + _ STR + color . get Alpha ( ) ) ; }
public static  String format Exception (  Exception exc ) {  String Writer string Writer = new  String Writer ( ) ;  Print Writer print Writer = new  Print Writer ( string Writer ) ; exc . print Stack Trace ( print Writer ) ; try { string Writer . close ( ) ; } catch (  IOException ex ) { } return string Writer . to String ( ) ; }
public static synchronized  String generate Id ( ) { if ( id ==  Long .  MAX_ VALUE ) { id = _ NUM ; } else { id ++ ; } return  Long . to Hex String ( id ) ; }
private static byte [ ] expand ( byte [ ] d ) {  Inflater inflater = new  Inflater ( ) ; inflater . set Input ( d ) ;  Byte Array Output Stream out = new  Byte Array Output Stream ( d . length ) ; byte [ ] buffer = new byte [ _ NUM ] ; try { while ( ! inflater . finished ( ) ) { int count = inflater . inflate ( buffer ) ; out . write ( buffer , _ NUM , count ) ; } inflater . end ( ) ; } catch (  Exception e ) { throw new  Illegal Argument Exception ( e ) ; } return out . to Byte Array ( ) ; }
public void poll ( final  Snmp Udp Statistics Handler snmp Udp Statistics Handler ) { this . statistics Handler = snmp Udp Statistics Handler ; try { file Loader . load ( ) ; final  Byte Buffer buffer = file Loader . get Buffer ( ) ; line Parser . reset ( ) ; line Parser . handle Token ( buffer , buffer . position ( ) , buffer . limit ( ) ) ; } finally { this . statistics Handler = null ; } }
@  Override public int compare To (  Byte Buffer other Buffer ) { int compare Remaining = ( remaining ( ) < other Buffer . remaining ( ) ) ? remaining ( ) : other Buffer . remaining ( ) ; int this Pos = position ; int other Pos = other Buffer . position ; byte this Byte , other Byte ; while ( compare Remaining > _ NUM ) { this Byte = get ( this Pos ) ; other Byte = other Buffer . get ( other Pos ) ; if ( this Byte != other Byte ) { return this Byte < other Byte ? - _ NUM : _ NUM ; } this Pos ++ ; other Pos ++ ; compare Remaining -- ; } return remaining ( ) - other Buffer . remaining ( ) ; }
public  Urbansim Cell Based Accessibility CSVWriter V2 (  String matsim Output Directory ,  String mode Name ) { try { log . info ( _ STR ) ; accessibility Data Writer =  IOUtils . get Buffered Writer ( matsim Output Directory + _ STR +  ACCESSIBILITY_ INDICATORS + _ STR + mode Name + _ STR ) ; accessibility Data Writer . write ( _ STR + _ STR + _ STR + _ STR + _ STR ) ; accessibility Data Writer . new Line ( ) ; log . info ( _ STR ) ; } catch (  Exception e ) { e . print Stack Trace ( ) ; throw new  Runtime Exception ( _ STR ) ; } }
@  Override public void agg (  Object new Val ) { if ( first Time ) { agg Val = (  Big Decimal ) new Val ; first Time = _ BOOL ; } else { agg Val = agg Val . add ( (  Big Decimal ) new Val ) ; } }
public void add Notification (  Notification notification ) { notification Vector . add Element ( notification ) ; }
Log create Log From Class Name (  String class Label ) throws  Exception {  Class < ? > clazz =  Class . for Name ( log Class Name ) ; @  Suppress Warnings ( _ STR )  Constructor <  Log > constructor = (  Constructor <  Log > ) clazz . get Constructor (  String . class ) ; return constructor . new Instance ( class Label ) ; }
private static final  String decode Field Name ( final  String p Xml Field Name ) {  String Buffer str = new  String Buffer ( ) ; int field Name Length = p Xml Field Name . length ( ) ; char current Char ; for ( int i = _ NUM ; i < field Name Length ; i ++ ) { current Char = p Xml Field Name . char At ( i ) ; if ( current Char == _ STR ) { str . append (  Character . to Upper Case ( p Xml Field Name . char At ( ++ i ) ) ) ; } else { str . append ( current Char ) ; } } return str . to String ( ) ; }
public boolean is Valid ( ) { return ( host != null ) && ( user != null ) && ( password != null ) && ! host . equals ( _ STR ) && ! user . equals ( _ STR ) && ! password . equals ( _ STR ) ; }
public  Builder add Content Item (  Content Item content Item ) { if ( content Items == null ) { content Items = new  Array List <  Content Item > ( ) ; content Type =  Http Media Type .  APPLICATION_ JSON ; } content Items . add ( content Item ) ; return this ; }
void add Test Class (  String classname ) { if ( classname . length ( ) > _ NUM ) { set Option ( _ STR , classname ) ; classnames . add ( classname ) ; } else { throw new  Illegal Argument Exception ( _ STR ) ; } }
public  Time Duration ( final  Date date , final long milliseconds ) { this ( date . get Time ( ) , milliseconds ) ; }
@  Override @  Side Effect Free public  String format Annotation String (  Collection < ? extends  Annotation Mirror > annos , boolean print Invisible ) {  String Builder sb = new  String Builder ( ) ; for (  Annotation Mirror obj : annos ) { if ( obj == null ) {  Error Reporter . error Abort ( _ STR ) ; } if ( is Invisible Qualified ( obj ) && ! print Invisible ) { continue ; } format Annotation Mirror ( obj , sb ) ; sb . append ( _ STR ) ; } return sb . to String ( ) ; }
public void queue Now (  Job job ) throws  Invalid Job Exception { job . queue ( ) ; try { executor . execute ( job ) ; } catch (  Exception e ) { job . de Queue ( ) ; } }
public static double [ ] lpc2lsf ( double [ ] one Minus A , int type ) { int order = one Minus A . length - _ NUM ; double [ ] g1 = new double [ _ NUM ] ; double [ ] g2 = new double [ _ NUM ] ; double [ ] g1r = new double [ _ NUM ] ; double [ ] g2r = new double [ _ NUM ] ; boolean even ; int g1_order , g2_order ; int orderd2 ; int i , j ; int swap ; double  Factor ; even = ( order & _ NUM ) == _ NUM ; if ( even ) g1_order = g2_order = order / _ NUM ; else { g1_order = ( order + _ NUM ) / _ NUM ; g2_order = g1_order - _ NUM ; throw new  Illegal Argument Exception ( _ STR ) ; } orderd2 = ( order + _ NUM ) / _ NUM ; g1 [ orderd2 ] = one Minus A [ _ NUM ] ; for ( i = _ NUM ; i <= orderd2 ; i ++ ) g1 [ g1_order - i ] = one Minus A [ i ] + one Minus A [ order + _ NUM - i ] ; g2 [ orderd2 ] = one Minus A [ _ NUM ] ; for ( i = _ NUM ; i <= orderd2 ; i ++ ) g2 [ orderd2 - i ] = one Minus A [ i ] - one Minus A [ order + _ NUM - i ] ; if ( even ) { for ( i = _ NUM ; i <= orderd2 ; i ++ ) g1 [ orderd2 - i ] -= g1 [ orderd2 - i + _ NUM ] ; for ( i = _ NUM ; i <= orderd2 ; i ++ ) g2 [ orderd2 - i ] += g2 [ orderd2 - i + _ NUM ] ; } else { for ( i = _ NUM ; i <= orderd2 ; i ++ ) g2 [ orderd2 - i ] += g2 [ orderd2 - i + _ NUM ] ; } if ( type == _ NUM ) { cheby1 ( g1 , g1_order ) ; cheby1 ( g2 , g2_order ) ;  Factor = _ NUM ; } else if ( type == _ NUM ) { cheby2 ( g1 , g1_order ) ; cheby2 ( g2 , g2_order ) ;  Factor = _ NUM ; } else if ( type == _ NUM ) { cheby3 ( g1 , g1_order ) ; cheby3 ( g2 , g2_order ) ;  Factor = _ NUM ; } else if ( type == _ NUM ) { kw ( g1 , g1_order ) ; kw ( g2 , g2_order ) ;  Factor = _ NUM ; } else { throw new  Illegal Argument Exception ( _ STR ) ; } cacm283 ( g1 , g1_order , g1r ) ; cacm283 ( g2 , g2_order , g2r ) ; double [ ] lsp = new double [ order ] ; for ( i = _ NUM , j = _ NUM ; ; ) { lsp [ j ++ ] =  Math . acos (  Factor * g1r [ i ] ) /  Math Utils .  TWOPI ; if ( j >= order ) break ; lsp [ j ++ ] =  Math . acos (  Factor * g2r [ i ] ) /  Math Utils .  TWOPI ; if ( j >= order ) break ; i ++ ; } return lsp ; }
@  Override public  Iterator <  Field Info > iterator ( ) { return values . iterator ( ) ; }
public void add Pass Through Condition (  Pass Through Or Generate Rule Condition condition ) { pass Through Conditions . add ( condition ) ; }
private static void create Thread Pool ( ) { if ( m Thread Pool Size <= _ NUM ) { m Executor Service =  Executors . new Cached Thread Pool ( ) ; } else { m Executor Service =  Executors . new Fixed Thread Pool ( m Thread Pool Size ) ; } }
private float compute Overscroll Percent ( ) { if ( m Over Scroll Offset >= _ NUM ) { return m Over Scroll Offset / m Max Over Scroll ; } else { return m Over Scroll Offset / m Max Under Scroll ; } }
private void retrieve Tracks (  Search Query query ,  Array List <  Track > tracks ) {  String query Like Selection = _ STR + query . text Query + _ STR ;  String [ ] track Selection Args = new  String [ ] { query Like Selection , query Like Selection , query Like Selection } ;  Cursor cursor = null ; try { cursor = provider Utils . get Track Cursor (  TRACK_ SELECTION_ QUERY , track Selection Args ,  TRACK_ SELECTION_ ORDER ) ; if ( cursor != null ) { tracks . ensure Capacity ( cursor . get Count ( ) ) ; while ( cursor . move To Next ( ) ) { tracks . add ( provider Utils . create Track ( cursor ) ) ; } } } finally { if ( cursor != null ) { cursor . close ( ) ; } } }
public boolean loading ( ) { return loading . get ( ) ; }
public void insert (  String name , long cnt ) { if ( _values == null ) { _values = new  Array List < > ( _ NUM ) ; } _values . add ( _ NUM , new  Count ( this , name , cnt ) ) ; }
@  Override public void on Reset ( ) { close Dialog ( ) ; }
public static void add Params ( final  Map <  String ,  String > params , final  String Builder uri ) { if ( params == null || params . is Empty ( ) ) return ; for (  Entry <  String ,  String > param : params . entry Set ( ) ) add Param ( param . get Key ( ) , param . get Value ( ) , uri ) ; }
public  Create Event (  JSONObject json ) throws  JSONException { super (  TYPE_ CREATE , json ) ; if ( m Block Id == null ) { throw new  JSONException (  JSON_ BLOCK_ ID + _ STR ) ; } m Xml = json . get String (  JSON_ XML ) ;  JSONArray json Ids = json . get JSONArray ( _ STR ) ; int count = json Ids . length ( ) ;  List <  String > ids = new  Array List < > ( count ) ; for ( int i = _ NUM ; i < count ; ++ i ) { ids . add ( json Ids . get String ( i ) ) ; } m Ids =  Collections . unmodifiable List ( ids ) ; }
public static boolean is Full Copy Resynchronizable (  Volume volume ,  Db Client db Client ) { boolean result = _ BOOL ;  String replica State = volume . get Replica State ( ) ; if ( is Volume Full Copy ( volume , db Client ) && replica State != null && ! replica State . is Empty ( ) ) {  Replication State state =  Replication State . get Enum Value ( replica State ) ; if ( state != null && state ==  Replication State .  SYNCHRONIZED ) { result = _ BOOL ; } } return result ; }
private static void read ( final  Input Stream istream , final byte [ ] bytes ) throws  IOException { int pos = _ NUM ; while ( pos < bytes . length ) { int read = istream . read ( bytes , pos , bytes . length - pos ) ; if ( read < _ NUM ) { throw new  Runtime Exception ( _ STR ) ; } pos += read ; } }
private void return Buffer (  Byte Buffer buf ) { if ( buf != null ) { buf . clear ( ) ; buffer Pool . add ( buf ) ; } }
public static boolean needs Recalculation ( long query Start Time , long last Modified Time ) { return  ENABLE_ UPDATE_ IN_ PROGRESS_ INDEX_ CALCULATION && query Start Time <=  SAFE_ QUERY_ TIME . get ( ) - query Start Time + last Modified Time ; }
public void add Response Listener (  Response Listener listener ) { m Response Listeners . add ( listener ) ; }
public static boolean test Save Location Exists ( ) {  String s DCard Status =  Environment . get External Storage State ( ) ; boolean status ; if ( s DCard Status . equals (  Environment .  MEDIA_ MOUNTED ) ) { status = _ BOOL ; } else { status = _ BOOL ; } return status ; }
public static  String plnoun Creature ( final int quantity , final  String noun ) { if ( noun . equals ( _ STR ) ) { if ( quantity == _ NUM ) { return _ STR ; } else { return _ STR ; } } return plnoun ( quantity , noun ) ; }
public boolean verify XMLSignature (  Document doc ,  String cert Alias ) throws  XMLSignature Exception { return verify XMLSignature (  SOAPBinding Constants .  WSF_10_ VERSION , cert Alias , doc ) ; }
public void read Modes ( final int [ ] columns Indices , final  Buffered Reader reader ) throws  IOException {  String line = reader . read Line ( ) ; while ( line != null && line . length ( ) > _ NUM ) { line = reader . read Line ( ) ; } }
public  Component Config Builder add Item In Fieldset (  String fieldset Label ,  String item Type ,  String item Label ,  String value ) {  String type =  String . format ( _ STR , item Type ) ;  String label =  String . format ( _ STR , fieldset Label , item Label ) ; config . add ( new  Configuration Entry ( current Tab , type , label , value ) ) ; return this ; }
public  Snippet Input ( final  Class < ? extends  Throwable > p Expected , final  Object ... parameters ) { if ( parameters == null ) { params = new  Object [ _ NUM ] ; } else { params = new  Object [ parameters . length ] ;  System . arraycopy ( parameters , _ NUM , params , _ NUM , parameters . length ) ; } expected = p Expected ; }
public boolean is Session Token (  String site ,  String token ) { if ( ! site . contains ( _ STR ) ) { site = site + ( _ STR ) ; }  Http Session Tokens Set site Tokens = session Tokens . get ( site ) ; if ( site Tokens == null ) return _ BOOL ; return site Tokens . is Session Token ( token ) ; }
public void populate Table By Distribution Set ( final  Distribution Set distribution Set ) { remove All Items ( ) ; if ( distribution Set == null ) { return ; }  Container data Source = get Container Data Source ( ) ;  List <  Target Filter Query > filters = distribution Set . get Auto Assign Filters ( ) ; filters . for Each ( null ) ; }
private double screen To Normalized ( float screen Coord ) { int width = get Width ( ) ; if ( width <= _ NUM * padding ) { return _ NUM ; } else { double result = ( screen Coord - padding ) / ( width - _ NUM * padding ) ; return  Math . min ( _ NUM ,  Math . max ( _ NUM , result ) ) ; } }
public boolean send Via Data Socket (  String string ) { try { byte [ ] bytes = string . get Bytes ( encoding ) ;  Log . d (  TAG , _ STR + encoding ) ; return send Via Data Socket ( bytes , bytes . length ) ; } catch (  Unsupported Encoding Exception e ) {  Log . e (  TAG , _ STR ) ; return _ BOOL ; } }
protected void push Write Context (  Context c ) { write Context Stack_ . push ( write Context_ ) ; write Context_ = c ; }
void extras ( ) { }
public  CART load (  String file Name ) throws  IOException ,  Mary Configuration Exception {  File Input Stream fis = new  File Input Stream ( file Name ) ; try { return load From Stream ( fis ) ; } finally { fis . close ( ) ; } }
public static boolean double Array Equals ( double [ ] x , double [ ] y , double tol ) { for ( int i = _ NUM ; i < x . length ; i += _ NUM ) { if ( x [ i ] == _ NUM ) { return y [ i ] == _ NUM ; } if (  Math . abs ( ( y [ i ] - x [ i ] ) / x [ i ] ) > tol ) { return _ BOOL ; } } return _ BOOL ; }
public void add Point (  Location location ) { points . add ( location ) ; }
public  Console format (  String format ,  Object ... args ) {  Formatter f = new  Formatter ( writer ) ; f . format ( format , args ) ; f . flush ( ) ; return this ; }
public double end ( ) { assure Right State ( _ STR , _ BOOL ) ; last Time = elapsed ( ) ; lapped . add ( last Time ) ; time = - _ NUM ; return last Time ; }
public double pruned Wide (  Prior prior ,  Likelihood likelihood ) throws  Operator Failed Exception { final int node Count = tree . get Node Count ( ) ; final  Node Ref root = tree . get Root ( ) ;  Node Ref i ; int index I ; do { index I =  Math Utils . next Int ( node Count ) ; i = tree . get Node ( index I ) ; } while ( root == i || ( tree . get Parent ( i ) == root && tree . get Node Height ( i ) > tree . get Node Height ( get Other Child ( tree , tree . get Parent ( i ) , i ) ) ) ) ;  List <  Integer > second Node Indices = new  Array List <  Integer > ( ) ;  List <  Double > probabilities = new  Array List <  Double > ( ) ;  Node Ref j , j P ;  Node Ref i P = tree . get Parent ( i ) ; double height IP = tree . get Node Height ( i P ) ; double height I = tree . get Node Height ( i ) ; double sum = _ NUM ; double backward = calculate Tree Likelihood ( prior , likelihood , tree ) ; int offset = ( int ) - backward ; backward =  Math . exp ( backward + offset ) ; for ( int n = _ NUM ; n < node Count ; n ++ ) { j = tree . get Node ( n ) ; if ( j != root ) { j P = tree . get Parent ( j ) ; if ( ( i P != j P ) && ( tree . get Node Height ( j ) < height IP ) && ( height I < tree . get Node Height ( j P ) ) && get Node Distance ( i P , j P ) <=  MAX_ DISTANCE ) { second Node Indices . add ( n ) ; swap ( tree , i , j , i P , j P ) ; double prob =  Math . exp ( calculate Tree Likelihood ( prior , likelihood , tree ) + offset ) ; probabilities . add ( prob ) ; swap ( tree , i , j , j P , i P ) ; sum += prob ; } } } if ( sum <= _ NUM ) { throw new  Operator Failed Exception ( _ STR ) ; } double ran =  Math . random ( ) * sum ; int index = _ NUM ; while ( ran > _ NUM ) { ran -= probabilities . get ( index ) ; index ++ ; } index -- ; j = tree . get Node ( second Node Indices . get ( index ) ) ; j P = tree . get Parent ( j ) ; double height JP = tree . get Node Height ( j P ) ; double height J = tree . get Node Height ( j ) ; double sum Forward2 = _ NUM ;  Node Ref k , k P ; for ( int n = _ NUM ; n < node Count ; n ++ ) { k = tree . get Node ( n ) ; if ( k != root ) { k P = tree . get Parent ( k ) ; if ( ( j P != k P ) && ( tree . get Node Height ( k ) < height JP ) && ( height J < tree . get Node Height ( k P ) ) && get Node Distance ( k P , j P ) <=  MAX_ DISTANCE ) { swap ( tree , j , k , j P , k P ) ; double prob =  Math . exp ( calculate Tree Likelihood ( prior , likelihood , tree ) + offset ) ; sum Forward2 += prob ; swap ( tree , j , k , k P , j P ) ; } } } swap ( tree , i , j , i P , j P ) ; double forward = probabilities . get ( index ) ; i P = j P ; height IP = height JP ; double sum Backward = _ NUM ; for ( int n = _ NUM ; n < node Count ; n ++ ) { j = tree . get Node ( n ) ; if ( j != root ) { j P = tree . get Parent ( j ) ; if ( ( i P != j P ) && ( tree . get Node Height ( j ) < height IP ) && ( height I < tree . get Node Height ( j P ) ) && get Node Distance ( i P , j P ) <=  MAX_ DISTANCE ) { swap ( tree , i , j , i P , j P ) ; double prob =  Math . exp ( calculate Tree Likelihood ( prior , likelihood , tree ) + offset ) ; sum Backward += prob ; swap ( tree , i , j , j P , i P ) ; } } } double sum Backward2 = _ NUM ; j = tree . get Node ( second Node Indices . get ( index ) ) ; j P = tree . get Parent ( j ) ; height JP = tree . get Node Height ( j P ) ; height J = tree . get Node Height ( j ) ; for ( int n = _ NUM ; n < node Count ; n ++ ) { k = tree . get Node ( n ) ; if ( k != root ) { k P = tree . get Parent ( k ) ; if ( ( j P != k P ) && ( tree . get Node Height ( k ) < height JP ) && ( height J < tree . get Node Height ( k P ) ) && get Node Distance ( k P , j P ) <=  MAX_ DISTANCE ) { swap ( tree , j , k , j P , k P ) ; double prob =  Math . exp ( calculate Tree Likelihood ( prior , likelihood , tree ) + offset ) ; sum Backward2 += prob ; swap ( tree , j , k , k P , j P ) ; } } } double forward Prob = ( forward / sum ) + ( forward / sum Forward2 ) ; double backward Prob = ( backward / sum Backward ) + ( backward / sum Backward2 ) ; double hastings Ratio =  Math . log ( backward Prob / forward Prob ) ; return hastings Ratio ; }
public boolean is Output Column Name Allowed (  String column Name ) { if ( column Name == null || column Name . length ( ) == _ NUM ) return _ BOOL ; get Output Column Names ( _ BOOL ) ; for ( int i = _ NUM ; i < m_outputcolumnnames . length ; i ++ ) { if ( column Name . equals ( m_outputcolumnnames [ i ] ) ) return _ BOOL ; } return _ BOOL ; }
public void test Set String ( ) throws  Exception { connection . set Auto Commit ( _ BOOL ) ;  Prepared Statement stmt = connection . prepare Statement ( _ STR ) ; try { stmt . set Int ( _ NUM , _ NUM ) ; stmt . set String ( _ NUM ,  TEST_ TEXT ) ; stmt . execute Update ( ) ; connection . commit ( ) ; stmt . set Int ( _ NUM , _ NUM ) ; stmt . set String ( _ NUM ,  TEST_ TEXT ) ; stmt . execute Update ( ) ; connection . commit ( ) ; stmt . set Int ( _ NUM , _ NUM ) ; stmt . set String ( _ NUM ,  TEST_ TEXT ) ; stmt . execute Update ( ) ; connection . commit ( ) ; } finally { stmt . close ( ) ; } connection . set Auto Commit ( _ BOOL ) ; }
private synchronized void rebuild Journal ( ) throws  IOException { if ( journal Writer != null ) { journal Writer . close ( ) ; }  Writer writer = new  Buffered Writer ( new  Output Stream Writer ( new  File Output Stream ( journal File Tmp ) ,  Util .  US_ ASCII ) ) ; try { writer . write (  MAGIC ) ; writer . write ( _ STR ) ; writer . write (  VERSION_1 ) ; writer . write ( _ STR ) ; writer . write (  Integer . to String ( app Version ) ) ; writer . write ( _ STR ) ; writer . write (  Integer . to String ( value Count ) ) ; writer . write ( _ STR ) ; writer . write ( _ STR ) ; for (  Entry entry : lru Entries . values ( ) ) { if ( entry . current Editor != null ) { writer . write (  DIRTY + _ STR + entry . key + _ STR ) ; } else { writer . write (  CLEAN + _ STR + entry . key + entry . get Lengths ( ) + _ STR ) ; } } } finally { writer . close ( ) ; } if ( journal File . exists ( ) ) { rename To ( journal File , journal File Backup , _ BOOL ) ; } rename To ( journal File Tmp , journal File , _ BOOL ) ; journal File Backup . delete ( ) ; journal Writer = new  Buffered Writer ( new  Output Stream Writer ( new  File Output Stream ( journal File , _ BOOL ) ,  Util .  US_ ASCII ) ) ; }
@  Suppress Warnings ( _ STR ) public void load History (  String filename ) throws  Exception {  File Input Stream fis = new  File Input Stream ( filename ) ;  Object Input Stream ois = new  Object Input Stream ( fis ) ; set History ( (  Map <  Double ,  Double > ) ois . read Object ( ) ) ; ois . close ( ) ; }
private void release Wait Latch ( ) { wait Latch . count Down ( ) ; }
private void blackman Harris4s ( int size ) { int start = ( window Function . length - size ) / _ NUM ; int stop = ( window Function . length + size ) / _ NUM ; double scale = _ NUM / ( double ) size / _ NUM ; for ( int i = _ NUM ; start < stop ; start ++ , i ++ ) window Function [ i ] = scale * ( _ NUM - _ NUM *  Math . cos ( two PI * i / size ) + _ NUM *  Math . cos ( _ NUM * two PI * i / size ) - _ NUM *  Math . cos ( _ NUM * two PI * i / size ) ) ; }
public int hash Code ( ) { return value . hash Code ( ) ; }
synchronized protected void xn Tcp Set Pending Packets ( int s ) { pending Packets += s ; if ( pending Packets < _ NUM ) { pending Packets = _ NUM ; } }
public  Sentence parse ( final  Conversation Context ctx ) { if ( context . equals ( ctx ) ) { return this ; } else { return  Conversation Parser . parse ( original Text , ctx ) ; } }
public void tear Down (  Proxy Test Case test Case ) throws  Exception { if ( _ BOOL && data Dir . exists ( ) && data Dir . is Directory ( ) ) { recursive Delete ( data Dir ) ; } }
protected boolean check Special Position (  Element current Rule Part ,  String special Position Type ) {  Named Node Map att Nodes = current Rule Part . get Attributes ( ) ; for ( int z = _ NUM ; z < att Nodes . get Length ( ) ; z ++ ) {  Node el = att Nodes . item ( z ) ;  String current Att = el . get Node Name ( ) ;  String current Val = el . get Node Value ( ) ; if ( current Att . equals ( _ STR ) ) { if ( ! current Val . starts With ( _ STR ) ) { if ( ! special Position Type . equals ( current Val ) ) return _ BOOL ; } else { current Val = current Val . substring ( _ NUM , current Val . length ( ) ) ; if ( special Position Type . equals ( current Val ) ) return _ BOOL ; } } } return _ BOOL ; }
private static void log Hierarchy (  String prefix ,  Class Loader class Loader ) { if ( ! is Diagnostics Enabled ( ) ) { return ; }  Class Loader system Class Loader ; if ( class Loader != null ) { final  String class Loader String = class Loader . to String ( ) ; log Diagnostic ( prefix + object Id ( class Loader ) + _ STR + class Loader String + _ STR ) ; } try { system Class Loader =  Class Loader . get System Class Loader ( ) ; } catch (  Security Exception ex ) { log Diagnostic ( prefix + _ STR ) ; return ; } if ( class Loader != null ) {  String Buffer buf = new  String Buffer ( prefix + _ STR ) ; for ( ; ; ) { buf . append ( object Id ( class Loader ) ) ; if ( class Loader == system Class Loader ) { buf . append ( _ STR ) ; } try { class Loader = class Loader . get Parent ( ) ; } catch (  Security Exception ex ) { buf . append ( _ STR ) ; break ; } buf . append ( _ STR ) ; if ( class Loader == null ) { buf . append ( _ STR ) ; break ; } } log Diagnostic ( buf . to String ( ) ) ; } }
public  Set create Sub Group Containers (  Set group Container Names ) throws  AMException ,  SSOException {  Iterator iter = group Container Names . iterator ( ) ;  Set group Containers = new  Hash Set ( ) ; while ( iter . has Next ( ) ) {  String group Container DN =  AMNaming Attr Manager . get Naming Attr (  GROUP_ CONTAINER ) + _ STR + ( (  String ) iter . next ( ) ) + _ STR + entry DN ;  AMGroup Container Impl group Container Impl = new  AMGroup Container Impl ( token , group Container DN ) ; group Container Impl . create ( ) ; group Containers . add ( group Container Impl ) ; } return group Containers ; }
public void schedule (  Timer Task task ,  Date when , long period ) { if ( period <= _ NUM || when . get Time ( ) < _ NUM ) { throw new  Illegal Argument Exception ( ) ; } long delay = when . get Time ( ) -  System . current Time Millis ( ) ; schedule Impl ( task , delay < _ NUM ? _ NUM : delay , period , _ BOOL ) ; }
public  Compiler Error (  Exception e ) { super ( e . get Message ( ) ) ; this . e = e ; }
protected static native void initialize ( ) ;
public static byte [ ] object To Bytes (  Object obj ) throws java . io .  IOException {  Byte Array Output Stream bos = new  Byte Array Output Stream ( ) ;  Object Output Stream oos = new  Object Output Stream ( bos ) ; oos . write Object ( obj ) ; oos . flush ( ) ; oos . close ( ) ; bos . close ( ) ; byte [ ] data = bos . to Byte Array ( ) ; return data ; }
public static boolean is Legal Identifier (  String name ) { if ( name . is Empty ( ) ) { return _ BOOL ; } if ( !  Character . is Java Identifier Start ( name . char At ( _ NUM ) ) ) { return _ BOOL ; } int i = _ NUM ; while ( i < name . length ( ) ) { if ( !  Character . is Java Identifier Part ( name . char At ( i ) ) ) { return _ BOOL ; } i = i + _ NUM ; } return _ BOOL ; }
static boolean less Than Unsigned ( long x1 , long x2 ) { return ( x1 +  Long .  MIN_ VALUE ) < ( x2 +  Long .  MIN_ VALUE ) ; }
public static double distance ( double delta X , double delta Y ) { return  Math . sqrt ( ( delta X * delta X ) + ( delta Y * delta Y ) ) ; }
private void determine Hosts As Property ( ) { if ( hosts . starts With ( _ STR ) && hosts . ends With ( _ STR ) ) {  String hosts Property = hosts . substring ( _ NUM , hosts . length ( ) - _ NUM ) ; hosts =  Property Util . get Property ( hosts Property ) ; if ( hosts == null ) { throw new  Illegal Argument Exception ( _ STR + hosts Property + _ STR ) ; } } }
public  Chat Builder add Email (  String email ) { emails . add ( email ) ; return this ; }
public static  Hash Provider best (  Hash Parameters params ,  Enum Set <  Hash Support > required ) {  Hash Provider result = null ;  Enum Set <  Hash Support > result Support = null ; for ( final  Hash Provider provider :  ALL_ PROVIDERS ) { final  Enum Set <  Hash Support > support = provider . query Support ( params ) ; if ( support . contains All ( required ) && ( result == null ||  Hash Support . compare ( support , result Support ) < _ NUM ) ) { result = provider ; result Support = support ; } } if ( result == null ) throw new  Unsupported Operation Exception ( ) ; return result ; }
public byte [ ] read Raw Bytes ( final int size ) throws  IOException { if ( size < _ NUM ) { throw  Invalid Protocol Buffer Exception . negative Size ( ) ; } if ( total Bytes Retired + buffer Pos + size > current Limit ) { skip Raw Bytes ( current Limit - total Bytes Retired - buffer Pos ) ; throw  Invalid Protocol Buffer Exception . truncated Message ( ) ; } if ( size <= buffer Size - buffer Pos ) { final byte [ ] bytes = new byte [ size ] ;  System . arraycopy ( buffer , buffer Pos , bytes , _ NUM , size ) ; buffer Pos += size ; return bytes ; } else if ( size <  BUFFER_ SIZE ) { final byte [ ] bytes = new byte [ size ] ; int pos = buffer Size - buffer Pos ;  System . arraycopy ( buffer , buffer Pos , bytes , _ NUM , pos ) ; buffer Pos = buffer Size ; refill Buffer ( _ BOOL ) ; while ( size - pos > buffer Size ) {  System . arraycopy ( buffer , _ NUM , bytes , pos , buffer Size ) ; pos += buffer Size ; buffer Pos = buffer Size ; refill Buffer ( _ BOOL ) ; }  System . arraycopy ( buffer , _ NUM , bytes , pos , size - pos ) ; buffer Pos = size - pos ; return bytes ; } else { final int original Buffer Pos = buffer Pos ; final int original Buffer Size = buffer Size ; total Bytes Retired += buffer Size ; buffer Pos = _ NUM ; buffer Size = _ NUM ; int size Left = size - ( original Buffer Size - original Buffer Pos ) ; final  List < byte [ ] > chunks = new  Array List < byte [ ] > ( ) ; while ( size Left > _ NUM ) { final byte [ ] chunk = new byte [  Math . min ( size Left ,  BUFFER_ SIZE ) ] ; int pos = _ NUM ; while ( pos < chunk . length ) { final int n = ( input == null ) ? - _ NUM : input . read ( chunk , pos , chunk . length - pos ) ; if ( n == - _ NUM ) { throw  Invalid Protocol Buffer Exception . truncated Message ( ) ; } total Bytes Retired += n ; pos += n ; } size Left -= chunk . length ; chunks . add ( chunk ) ; } final byte [ ] bytes = new byte [ size ] ; int pos = original Buffer Size - original Buffer Pos ;  System . arraycopy ( buffer , original Buffer Pos , bytes , _ NUM , pos ) ; for ( final byte [ ] chunk : chunks ) {  System . arraycopy ( chunk , _ NUM , bytes , pos , chunk . length ) ; pos += chunk . length ; } return bytes ; } }
static boolean pair Diff ( int ar [ ] , int x ) {  Arrays . sort ( ar ) ; int len = ar . length ; for ( int i = _ NUM , j = _ NUM ; i < len && j < len ; ) { if ( i != j && ar [ j ] - ar [ i ] == x ) { return _ BOOL ; } else if ( ar [ j ] - ar [ i ] < x ) { j ++ ; } else { i ++ ; } } return _ BOOL ; }
public synchronized void import From File ( ) {  Path file =  Paths . get ( import File Name ) ; try (  Buffered Reader reader =  Files . new Buffered Reader ( file ,  CHARSET ) ) {  LOGGER . info ( _ STR + file . to Absolute Path ( ) ) ;  String line ; while ( ( line = reader . read Line ( ) ) != null ) {  String result = command ( line ) ;  LOGGER . info (  String . format ( _ STR , result , line ) ) ; } } catch (  IOException ex ) {  LOGGER . warning ( _ STR + ex ) ; } }
public double local Score ( int i , int ... parents ) {  Conditional Gaussian Likelihood .  Ret ret = likelihood . get Likelihood Ratio ( i , parents ) ; int  N = data Set . get Num Rows ( ) ; double lik = ret . get Lik ( ) ; int k = ret . get Dof ( ) ; double prior = get Structure Prior ( parents ) ; return _ NUM * lik - k *  Math . log (  N ) + prior ; }
public boolean add ( final  T item ) { final  Adapter Transaction add Transaction = new  Add Transaction < > ( this , item ) ; final boolean success = add Transaction . perform ( ) ; m Transactions . offer ( add Transaction ) ; return success ; }
private  List <  Type > parse Type List (  List <  Map <  String ,  Object > > types ,  List <  Type Parameter > type Params ) {  List <  Type > ts = new  Array List <  Type > ( types . size ( ) ) ; for (  Map <  String ,  Object > st : types ) { ts . add ( get Type From Json ( st , null , type Params ) ) ; } return ts ; }
public void clear ( ) { clear ( _ BOOL ) ; }
public void build (  String code ,  JSONObject data ) { try { result . put ( resources . get String (  R . string . intent_extra_status ) , resources . get String (  R . string . shared_pref_default_status ) ) ; result . put ( resources . get String (  R . string . intent_extra_code ) , code ) ; if ( data != null ) { result . put ( resources . get String (  R . string . intent_extra_data ) , data ) ; } operation List Result . put ( result ) ; } catch (  JSONException e ) {  Log . e (  TAG , _ STR + e . to String ( ) ) ; } }
private  String map Table Types (  String table Type ) { if ( table Type . equals ( _ STR ) ) { return _ STR ; } return table Type ; }
public long signal ( ) { return  Long . parse Long ( fields [ _ NUM ] ) ; }
public static void delete Realm Privileges (  SSOToken token ,  String realm Name ) throws  SSOException ,  Delegation Exception {  Delegation Manager dm = new  Delegation Manager ( token , realm Name ) ;  Set privs = dm . get Privileges ( ) ; if ( ( privs == null ) || privs . is Empty ( ) ) { return ; }  Iterator it = privs . iterator ( ) ; while ( it . has Next ( ) ) {  Delegation Privilege dp = (  Delegation Privilege ) it . next ( ) ;  String priv Name = dp . get Name ( ) ; dm . remove Privilege ( priv Name ) ; if ( debug . message Enabled ( ) ) { debug . message ( _ STR + priv Name + _ STR + realm Name ) ; } } }
@  Override public boolean equals (  Object o ) { if ( o == this ) return _ BOOL ; if ( ! ( o instanceof  Record ) ) return _ BOOL ;  Record other = (  Record ) o ; return ( name == null ? other . name == null : name . equals ( other . name ) ) && ( type == null ? other . type == null : type . equals ( other . type ) ) && ( location == null ? other . location == null : location . equals ( other . location ) ) && ( metadata == null ? other . metadata == null : metadata . equals ( other . metadata ) ) && ( registration == null ? other . registration == null : registration . equals ( other . registration ) ) && ( status == null ? other . status == null : status . equals ( other . status ) ) ; }
@  Override public boolean is Armed ( ) { boolean b = should Act Like Button ( ) || ( pressed When Popup Visible && combo Box . is Popup Visible ( ) ) ; return b ? is Pressed ( ) : super . is Armed ( ) ; }
public  Encoder Test Suite Builder encoded ( int min , int max ) { _encoded . set ( min , max + _ NUM ) ; _valid . clear ( min , max + _ NUM ) ; _invalid . clear ( min , max + _ NUM ) ; return this ; }
private  List <  Recommendation > create Metro Point Recommendations (  Virtual Array src Varray ,  List <  Virtual Array > tgt Varrays ,  Virtual Pool src Vpool ,  Virtual Array ha Varray ,  Virtual Pool ha Vpool ,  Project project ,  Virtual Pool Capability Values Wrapper capabilities ,  List <  Storage Pool > candidate Primary Pools ,  List <  Storage Pool > candidate Secondary Pools ,  Volume vpool Change Volume ) {  List <  Recommendation > recommendations = new  Array List <  Recommendation > ( ) ;  RPProtection Recommendation rp Protection Recommendaton = null ;  Map <  Virtual Array ,  List <  Storage Pool > > tgt Varray Storage Pools Map = get Vplex Target Matching Pools ( tgt Varrays , src Vpool , project , capabilities , vpool Change Volume ) ; rp Protection Recommendaton = create RPProtection Recommendation For Metro Point ( src Varray , tgt Varrays , src Vpool , ha Varray , ha Vpool , capabilities , candidate Primary Pools , candidate Secondary Pools , tgt Varray Storage Pools Map , vpool Change Volume , project ) ; _log . info (  String . format ( _ STR , rp Protection Recommendaton . get Resource Count ( ) ) ) ; recommendations . add ( rp Protection Recommendaton ) ; return recommendations ; }
public static  String clear Last Viewed Categories (  Http Servlet Request request ,  Http Servlet Response response ) {  Http Session session = request . get Session ( ) ; if ( session != null ) { session . set Attribute ( _ STR ,  Fast List . new Instance ( ) ) ; } return _ STR ; }
public boolean equals (  Object obj ) { if ( this == obj ) return _ BOOL ; if ( obj instanceof  ECField F2m ) { return ( ( m == ( (  ECField F2m ) obj ) . m ) && (  Arrays . equals ( ks , ( (  ECField F2m ) obj ) . ks ) ) ) ; } return _ BOOL ; }
private static  String  H (  String data ) { try {  Message Digest digest =  Message Digest . get Instance ( _ STR ) ; return to Hex String ( digest . digest ( data . get Bytes ( ) ) ) ; } catch (  No Such Algorithm Exception ex ) { throw new  Runtime Exception ( _ STR , ex ) ; } }
public static  Document new XMLDocument ( ) {  Document Builder Factory factory =  Document Builder Factory . new Instance ( ) ; try {  Document Builder builder = factory . new Document Builder ( ) ; builder . set Error Handler ( new  XMLError Handler ( ) ) ;  Document doc = builder . new Document ( ) ; return doc ; } catch (  Parser Configuration Exception e ) { log . warning ( e . get Message ( ) ) ; throw new  Runtime Exception ( _ STR ) ; } }
public  Str Builder insert ( int index ,  Object obj ) { if ( obj == null ) { return insert ( index , null Text ) ; } return insert ( index , obj . to String ( ) ) ; }
@  Override public void handle Mouse Pressed (  Chart Canvas canvas ,  Mouse Event e ) { this . mouse Pressed Point = new  Point2 D .  Double ( e . get X ( ) , e . get Y ( ) ) ; }
public static void concat (  Iterable <  File > to Merge ,  File dst ) throws  IOException { try (  File Channel dst Channel =  File Channel . open ( dst . to Path ( ) ,  Standard Open Option .  CREATE ,  Standard Open Option .  TRUNCATE_ EXISTING ,  Standard Open Option .  WRITE ) ) { for (  File file : to Merge ) { try (  Random Access File raf = new  Random Access File ( file , _ STR ) ) {  File Channel channel = raf . get Channel ( ) ; dst Channel . write ( channel . map (  File Channel .  Map Mode .  READ_ ONLY , _ NUM , raf . length ( ) ) ) ; } } } }
public static  List < ? extends  Block Object > fetch (  Db Client db Client ,  List <  URI > block URIs ) {  List < ? extends  Block Object > block Objects = null ; if (  URIUtil . is Type ( block URIs . get ( _ NUM ) ,  Volume . class ) ) { block Objects = db Client . query Object (  Volume . class , block URIs ) ; } else if (  URIUtil . is Type ( block URIs . get ( _ NUM ) ,  Block Snapshot . class ) ) { block Objects = db Client . query Object (  Block Snapshot . class , block URIs ) ; } else if (  URIUtil . is Type ( block URIs . get ( _ NUM ) ,  Block Mirror . class ) ) { block Objects = db Client . query Object (  Block Mirror . class , block URIs ) ; } return block Objects ; }
public static  Lat Lon great Circle End Position (  Lat Lon p , double great Circle Azimuth Radians , double path Length Radians ) { if ( p == null ) { throw new  Illegal Argument Exception ( _ STR ) ; } return great Circle End Position ( p ,  Angle . from Radians ( great Circle Azimuth Radians ) ,  Angle . from Radians ( path Length Radians ) ) ; }
public  Dimension maximum Layout Size (  Container target ) {  Dimension size ; synchronized ( this ) { check Container ( target ) ; check Requests ( ) ; size = new  Dimension ( x Total . maximum , y Total . maximum ) ; }  Insets insets = target . get Insets ( ) ; size . width = ( int )  Math . min ( ( long ) size . width + ( long ) insets . left + ( long ) insets . right ,  Integer .  MAX_ VALUE ) ; size . height = ( int )  Math . min ( ( long ) size . height + ( long ) insets . top + ( long ) insets . bottom ,  Integer .  MAX_ VALUE ) ; return size ; }
private  String read Fully (  Input Stream input ) throws  IOException { if ( input == null ) { throw new  File Not Found Exception ( ) ; } final  Buffered Reader in = new  Buffered Reader ( new  Input Stream Reader ( input , charset ) ) ; try {  String Builder sb = new  String Builder ( ) ;  String line ; while ( ( line = in . read Line ( ) ) != null ) { if ( sb . length ( ) > _ NUM ) { sb . append ( _ STR ) ; } sb . append ( line ) ; } return sb . to String ( ) ; } finally { in . close ( ) ; } }
private void cancel Lease (  Lease lease ) { try { lease Renewal Mgr . cancel ( lease ) ; } catch (  Exception e ) { logger . log (  Level .  FINER , _ STR + _ STR , e ) ; } }
private static int estimate Filter Order ( int sample Rate , int frequency1 , int frequency2 , double pass Band Ripple , double stop Band Ripple ) { double df =  Math . abs ( frequency2 - frequency1 ) / ( double ) sample Rate ; double ddp =  Math . log10 ( stop Band Ripple <= pass Band Ripple ? pass Band Ripple : stop Band Ripple ) ; double dds =  Math . log10 ( stop Band Ripple <= pass Band Ripple ? stop Band Ripple : pass Band Ripple ) ; double a1 = _ NUM ; double a2 = _ NUM ; double a3 = - _ NUM ; double a4 = - _ NUM ; double a5 = - _ NUM ; double a6 = - _ NUM ; double b1 = _ NUM ; double b2 = _ NUM ; double t1 = a1 * ddp * ddp ; double t2 = a2 * ddp ; double t3 = a4 * ddp * ddp ; double t4 = a5 * ddp ; double dinf = ( ( t1 + t2 + a3 ) * dds ) + ( t3 + t4 + a6 ) ; double ff = b1 + b2 * ( ddp - dds ) ; double n = dinf / df - ff * df + _ NUM ; return ( int )  Math . ceil ( n ) ; }
protected final void write S (  String text , int size ) { if ( text == null ) { buf . put ( new byte [ size ] ) ; } else { final int len = text . length ( ) ; for ( int i = _ NUM ; i < len ; i ++ ) { buf . put Char ( text . char At ( i ) ) ; } buf . put ( new byte [ size - ( len * _ NUM ) ] ) ; } }
@  Override public void on Draw Frame (  GL10 gl10 ) {  GLES20 . gl Clear Color ( _ NUM , _ NUM , _ NUM , _ NUM ) ;  GLES20 . gl Clear (  GLES20 .  GL_ COLOR_ BUFFER_ BIT |  GLES20 .  GL_ DEPTH_ BUFFER_ BIT ) ;  GLES20 . gl Enable (  GLES20 .  GL_ DEPTH_ TEST ) ;  GLES20 . gl Enable (  GLES20 .  GL_ CULL_ FACE ) ; long current Time Millis =  System . current Time Millis ( ) ; update With Delta ( current Time Millis - last Time Millis ) ; last Time Millis = current Time Millis ; }
public int num Records ( ) { return super . num Records ( ) ; }
@  Override public boolean equals ( final  Object o ) { if ( this == o ) return _ BOOL ; if ( ! ( o instanceof  Header ) ) { return _ BOOL ; } return name . equals ( ( (  Header ) o ) . name ) ; }
public  Message Version (  String version ) { this . version = version ; try { get Version Parts ( ) ; } catch (  Number Format Exception e ) { throw new  Illegal Argument Exception (  String . format ( _ STR , version ) , e ) ; } }
public void write ( byte [ ] vector ) { check ( vector . length ) ;  System . arraycopy ( vector , _ NUM , buffer , write_pos , vector . length ) ; write_pos += vector . length ; }
public boolean is Name ( ) { return type String . contains (  SUFFIX_ NAME ) ; }
public void read Leaf Block (  Block Id blk ) { lock Tbl . s Lock ( blk , tx Num ) ; read Index Blks . add ( blk ) ; }
public  PShape find Child (  String target ) { if ( parent == null ) { return get Child ( target ) ; } else { return parent . find Child ( target ) ; } }
public void add Observer (  App Menu Observer observer ) { m Observers . add ( observer ) ; }
public void not ( ) { mv . visit Insn (  Opcodes .  ICONST_1 ) ; mv . visit Insn (  Opcodes .  IXOR ) ; }
@  Override public  Page Format default Page (  Page Format page ) {  Page Format new Page = (  Page Format ) page . clone ( ) ; get Default Page ( new Page ) ; return new Page ; }
protected  String create Error Message (  String message ) { return  String . format (  Locale .  US , _ STR , locator . get Line Number ( ) , locator . get Column Number ( ) , message ) ; }
public  Run Panel ( ) { m_ Start But . add Action Listener ( this ) ; m_ Stop But . add Action Listener ( this ) ; m_ Start But . set Enabled ( _ BOOL ) ; m_ Stop But . set Enabled ( _ BOOL ) ; m_ Start But . set Mnemonic ( _ STR ) ; m_ Stop But . set Mnemonic ( _ STR ) ; m_ Log . status Message (  NOT_ RUNNING ) ;  JPanel controls = new  JPanel ( ) ;  Grid Bag Layout gb = new  Grid Bag Layout ( ) ;  Grid Bag Constraints constraints = new  Grid Bag Constraints ( ) ; controls . set Border (  Border Factory . create Empty Border ( _ NUM , _ NUM , _ NUM , _ NUM ) ) ; controls . set Layout ( gb ) ; constraints . gridx = _ NUM ; constraints . gridy = _ NUM ; constraints . weightx = _ NUM ; constraints . fill =  Grid Bag Constraints .  HORIZONTAL ; constraints . gridwidth = _ NUM ; constraints . gridheight = _ NUM ; constraints . insets = new  Insets ( _ NUM , _ NUM , _ NUM , _ NUM ) ; controls . add ( m_ Start But , constraints ) ; constraints . gridx = _ NUM ; constraints . gridy = _ NUM ; constraints . weightx = _ NUM ; constraints . gridwidth = _ NUM ; constraints . gridheight = _ NUM ; controls . add ( m_ Stop But , constraints ) ; set Layout ( new  Border Layout ( ) ) ; add ( controls ,  Border Layout .  NORTH ) ; add ( m_ Log ,  Border Layout .  CENTER ) ; }
public static void fill Repo Links ( final  Channel Information channel , final  List <  Menu Entry > links , final  String base Name , final int base Priority , final  String prefix , final int priority Offset , final  Function <  String ,  Link Target > target Function ) {  Objects . require Non Null ( channel , _ STR ) ;  Objects . require Non Null ( links , _ STR ) ;  Objects . require Non Null ( base Name , _ STR ) ;  Objects . require Non Null ( prefix , _ STR ) ;  Objects . require Non Null ( target Function , _ STR ) ; links . add ( new  Menu Entry ( base Name , base Priority , prefix + _ STR , priority Offset , target Function . apply ( channel . get Id ( ) ) ,  Modifier .  LINK , null ) ) ; int i = _ NUM ; for ( final  String name : channel . get Names ( ) ) { final  Link Target target = target Function . apply ( name ) ; if ( target != null ) { links . add ( new  Menu Entry ( base Name , base Priority ,  String . format ( _ STR , prefix , name ) , priority Offset + i , target ,  Modifier .  LINK , null ) ) ; } i ++ ; } }
public static  String to Hex String ( byte [ ] value ) { if ( value == null ) { return null ; }  String Buffer buffer = new  String Buffer ( _ NUM * value . length ) ; int single ; for ( int i = _ NUM ; i < value . length ; i ++ ) { single = value [ i ] & _ NUM ; if ( single < _ NUM ) { buffer . append ( _ STR ) ; } buffer . append (  Integer . to String ( single , _ NUM ) ) ; } return buffer . to String ( ) ; }
public  List <  String > field Property Comment (  Field field ) {  String comment Type = field Type Cardinality Comment ( field ) ;  String field Name = property Name ( field ) ; return convert To Commented Block ( field Comment (  String . format ( _ STR , comment Type , field Name ) , null , field ) ) ; }
private boolean may Skip ASI (  Common Token last Token ,  Observable Xtext Token Stream tokens ) { int count Down From = last Token . get Token Index ( ) ; for ( int i = count Down From - _ NUM ; i >= _ NUM ; i -- ) {  Token prev Token = tokens . get ( i ) ; if ( prev Token . get Channel ( ) ==  Token .  DEFAULT_ CHANNEL ) { if ( mandatory ASI . get ( prev Token . get Type ( ) ) ) { return _ BOOL ; } return _ BOOL ; } } return _ BOOL ; }
public static double ceil ( double x ) { double y ; if (  Double . is Na N ( x ) ) { return x ; } y = floor ( x ) ; if ( y == x ) { return y ; } y += _ NUM ; if ( y == _ NUM ) { return x * y ; } return y ; }
public  Dictionary (  Directory temp Dir ,  String temp File Name Prefix ,  Input Stream affix ,  Input Stream dictionary ) throws  IOException ,  Parse Exception { this ( temp Dir , temp File Name Prefix , affix ,  Collections . singleton List ( dictionary ) , _ BOOL ) ; }
public  Building Target (  Coords coords ,  IBoard board , int n Type ) { init ( coords , board , n Type ) ; }
@  Rpc Method public void detach Disks (  String vm Id ,  List <  String > disk Ids ,  Async Method Callback <  Host .  Async Client . detach_disks_call > handler ) throws  Rpc Exception { ensure Client ( ) ;  Vm Disks Detach Request vm Disks Detach Request = new  Vm Disks Detach Request ( vm Id , disk Ids ) ; client Proxy . set Timeout (  DETACH_ DISKS_ TIMEOUT_ MS ) ; logger . info ( _ STR , vm Id , disk Ids , get Host Ip ( ) , vm Disks Detach Request ) ; try { client Proxy . detach_disks ( vm Disks Detach Request , handler ) ; } catch (  TException e ) { throw new  Rpc Exception ( e . get Message ( ) ) ; } }
public void reply (  Z21 Reply msg ) { if ( msg . is XPress Net Tunnel Message ( ) ) {  XNet Reply reply = msg . get XNet Reply ( ) ; log . debug ( _ STR , msg , reply ) ; for ( int i = _ NUM ; i < reply . get Num Data Elements ( ) ; i ++ ) { try { outpipe . write Byte ( reply . get Element ( i ) ) ; } catch ( java . io .  IOException ioe ) { log . error ( _ STR ) ; } } } }
public  Tab add Item (  Item item ) { m Items . add ( item ) ; return this ; }
protected void notify Modified ( ) { if ( update Counter . get ( ) > _ NUM ) { return ; } if ( modified ) { update Version ( ) ; last Modified =  System . current Time Millis ( ) ; } if ( modified && storage != null ) { if ( ! storage . save ( this ) ) { log . error ( _ STR ) ; } } send Updates ( ) ; modified = _ BOOL ; }
public void redo ( ) { if ( ! redo Stack . is Empty ( ) ) {  Undoable Action redo Event = redo Stack . pop ( ) ; redo Event . redo ( ) ; undo Stack . push ( redo Event ) ; } }
public  Matrix ( final double [ ] [ ] data , final  Set <  Address .  Flags > flags ) { super ( data . length , data [ _ NUM ] . length , null ) ; this . addr = new  Direct Matrix Address ( this . $ , _ NUM , data . length , null , _ NUM , data [ _ NUM ] . length , flags , _ BOOL , data . length , data [ _ NUM ] . length ) ; for ( int row = _ NUM ; row < data . length ; row ++ ) {  System . arraycopy ( data [ row ] , _ NUM , this . $ , row * this . cols , this . cols ) ; } }
private void update UDPCache (  Ping Data pd ) { if ( set Ping Data == null && ! warning Logged ) { find Ping Data Method ( ) ; } if ( set Ping Data != null ) { try { set Ping Data . invoke ( transport , new  Object [ ] { pd } ) ; } catch (  Invocation Target Exception |  Illegal Access Exception e ) { if ( ! warning Logged ) { log . warn ( _ STR , e ) ; warning Logged = _ BOOL ; } } } }
public  String Builder encode Body (  String Builder buffer ) { return buffer . append ( priority ) ; }
private void close ( ) { try { in . close ( ) ; } catch (  Exception e ) { } try { out . close ( ) ; } catch (  Exception e ) { } }
public  Email subject (  String subject ) { if ( subject == null ) throw new  Illegal Argument Exception ( _ STR ) ; this . subject = subject ; return this ; }
protected void going Inactive (  OBlock block ) { if ( _run Mode ==  MODE_ NONE ) { return ; } if ( !  Threading Util . is Layout Thread ( ) ) log . error ( _ STR , new  Exception ( _ STR ) ) ; int idx = get Index Of Block ( block , _idx Last Order ) ; if ( log . is Debug Enabled ( ) ) { log . debug ( _ STR + block . get Display Name ( ) + _ STR + idx + _ STR + _idx Current Order + _ STR + get Display Name ( ) ) ; } if ( idx < _idx Current Order ) { release Block ( block , idx ) ; } else if ( idx == _idx Current Order ) { if ( _idx Current Order + _ NUM < _orders . size ( ) ) {  OBlock next Block = get Block At ( _idx Current Order + _ NUM ) ; if ( ( next Block . get State ( ) &  OBlock .  DARK ) != _ NUM ) { if ( _engineer != null ) { going Active ( next Block ) ; release Block ( block , idx ) ; } else { if ( _run Mode ==  MODE_ LEARN ) { _idx Current Order ++ ; fire Property Change ( _ STR , block , next Block ) ; } else if ( _run Mode ==  MODE_ RUN ) { control Run Train (  ABORT ) ; } } } else { if ( log . is Debug Enabled ( ) ) { log . debug ( _ STR + block . get Display Name ( ) + _ STR + get Display Name ( ) ) ; } fire Property Change ( _ STR , block , null ) ; if ( _engineer != null ) { _engineer . set Halt ( _ BOOL ) ; } else { control Run Train (  ABORT ) ; } return ; } } else { abort Warrant ( _ STR + get Display Name ( ) + _ STR + block . get Display Name ( ) + _ STR ) ; } } else if ( idx == _idx Current Order + _ NUM ) { restart ( ) ; move Into Next Block (  END ) ; } else { block . allocate ( this ) ; } }
public void add Custom Sash Form Listener (  ICustom Sash Form Listener listener ) { if ( custom Sash Form Listeners == null ) custom Sash Form Listeners = new  Array List ( ) ; custom Sash Form Listeners . add ( listener ) ; }
@  Override public void close ( ) throws  IOException { if ( ! m Seen Eof ) { m Thread . interrupt ( ) ; try { m Thread . join ( ) ; } catch ( final  Interrupted Exception e ) { throw new  IOException ( _ STR ) ; } finally { super . close ( ) ; } } check Exception ( ) ; }
public static  UUID parse String As UUID (  String in ) throws  Index Parse Field Exception { try { return  UUID . from String ( in ) ; } catch (  Illegal Argument Exception e ) { throw new  Index Parse Field Exception ( in , e ) ; } }
public void write All ( java . sql .  Result Set rs , boolean include Column Names , boolean trim ) throws  SQLException ,  IOException { if ( include Column Names ) { write Column Names ( rs ) ; } while ( rs . next ( ) ) { write Next ( result Service . get Column Values ( rs , trim ) ) ; } }
Zone Offset Transition Rule ( int month , int day Of Month Indicator , int day Of Week ,  Local Time time , boolean time End Of Day ,  Time Definition time Defnition ,  Zone Offset standard Offset ,  Zone Offset offset Before ,  Zone Offset offset After ) {  Objects . require Non Null ( time , _ STR ) ;  Objects . require Non Null ( time Defnition , _ STR ) ;  Objects . require Non Null ( standard Offset , _ STR ) ;  Objects . require Non Null ( offset Before , _ STR ) ;  Objects . require Non Null ( offset After , _ STR ) ; if ( month < _ NUM || month > _ NUM ) { throw new  Illegal Argument Exception ( _ STR ) ; } if ( day Of Month Indicator < - _ NUM || day Of Month Indicator > _ NUM || day Of Month Indicator == _ NUM ) { throw new  Illegal Argument Exception ( _ STR ) ; } if ( time End Of Day && time . equals (  Local Time .  MIDNIGHT ) == _ BOOL ) { throw new  Illegal Argument Exception ( _ STR ) ; } this . month = month ; this . dom = ( byte ) day Of Month Indicator ; this . dow = day Of Week ; this . time = time ; this . time End Of Day = time End Of Day ; this . time Definition = time Defnition ; this . standard Offset = standard Offset ; this . offset Before = offset Before ; this . offset After = offset After ; }
private  String concat (  List <  ILine Segment > list ) {  String Builder res = new  String Builder ( ) ;  Node <  ILine Segment > n = list . head ( ) ; while ( n != null ) { res . append ( n . value ( ) ) ; n = n . next ( ) ; if ( n != null ) { res . append ( _ STR ) ; } } return res . to String ( ) ; }
private static void recalc Font Size ( final float scale , final int rotate , final  Form Object form Object , final  Component cur Comp ) { final int size =  GUIData . get Font Size ( form Object , rotate , scale ) ; final  Font reset Font = cur Comp . get Font ( ) ; final  Font new Font = new  Font ( reset Font . get Font Name ( ) , reset Font . get Style ( ) , size ) ; cur Comp . set Font ( new Font ) ; }
public  Set <  State > post Event (  Event Data event Data ,  Long state Machine Instance Id ,  String correlation Id ) {  State Machine state Machine = null ; if ( state Machine Instance Id != null ) { state Machine = retrieve State Machine ( state Machine Instance Id ) ; } else if ( correlation Id != null ) { state Machine = retrieve State Machine By Correlation Id ( correlation Id ) ; state Machine Instance Id = ( state Machine == null ) ? null : state Machine . get Id ( ) ; } if ( state Machine == null ) throw new  Unknown State Machine ( _ STR + state Machine Instance Id + _ STR + correlation Id + _ STR ) ;  Event event = events DAO . find By SMId And Name ( state Machine Instance Id , event Data . get Name ( ) ) ; if ( event == null ) throw new  Illegal Event Exception ( _ STR + state Machine Instance Id + _ STR + event Data . get Name ( ) + _ STR ) ; event . set Status (  Event .  Event Status . triggered ) ; event . set Event Data ( event Data . get Data ( ) ) ; event . set Event Source ( event Data . get Event Source ( ) ) ; events DAO . update Event ( event ) ;  Context context = new  RAMContext (  System . current Time Millis ( ) , null , state Machine ) ; final  Set <  State > dependant States = context . get Dependant States ( event Data . get Name ( ) ) ; logger . debug ( _ STR , dependant States , event Data . get Name ( ) ) ;  Set <  State > executable States = get Executable States ( dependant States , state Machine Instance Id ) ; logger . debug ( _ STR , executable States , event Data . get Name ( ) ) ; execute States ( state Machine Instance Id , executable States ) ; return executable States ; }
protected void write Blob ( int test Id , byte [ ] test Bytes ,  Fb Database db ,  Blob Parameter Buffer blob Parameter Buffer ) throws  SQLException { final  Simple Statement Listener listener = new  Simple Statement Listener ( ) ; final  Fb Transaction transaction = get Transaction ( db ) ; try { final  Fb Statement statement = db . create Statement ( transaction ) ; statement . add Statement Listener ( listener ) ; final  Fb Blob blob = db . create Blob For Output ( transaction , blob Parameter Buffer ) ; blob . open ( ) ; int bytes Written = _ NUM ; while ( bytes Written < test Bytes . length ) { byte [ ] buffer = new byte [  Math . min ( blob . get Maximum Segment Size ( ) , test Bytes . length - bytes Written ) ] ;  System . arraycopy ( test Bytes , bytes Written , buffer , _ NUM , buffer . length ) ; blob . put Segment ( buffer ) ; bytes Written += buffer . length ; } blob . close ( ) ; statement . prepare (  INSERT_ BLOB_ TABLE ) ; final  Datatype Coder datatype Coder = db . get Datatype Coder ( ) ;  Field Value param1 = new  Field Value ( datatype Coder . encode Int ( test Id ) ) ;  Field Value param2 = new  Field Value ( datatype Coder . encode Long ( blob . get Blob Id ( ) ) ) ; statement . execute (  Row Value . of ( param1 , param2 ) ) ; statement . close ( ) ; } finally { transaction . commit ( ) ; } }
public static double copy Sign ( final double magnitude , final double sign ) { return  Double . long Bits To Double (  Double . double To Raw Long Bits ( sign ) &  Long .  MIN_ VALUE |  Double . double To Raw Long Bits ( magnitude ) &  Long .  MAX_ VALUE ) ; }
public void add Near Key (  Key Cache Object key ,  Grid Cache Shared Context ctx ) throws  Ignite Checked Exception { if ( near Keys == null ) near Keys = new  Array List < > ( ) ; near Keys . add ( key ) ; }
public static  Class < ? > class For Name (  String class Name ) { try { return  Class . for Name ( class Name ) ; } catch (  Class Not Found Exception |  Verify Error e ) { return null ; } }
public void add Debugger ( final  IDebugger debugger ) { debuggers . add (  Preconditions . check Not Null ( debugger , _ STR ) ) ; for ( final  Debugger Provider Listener listener : m_listeners ) { try { listener . debugger Added ( this , debugger ) ; } catch ( final  Exception exception ) {  CUtility Functions . log Exception ( exception ) ; } } }
public static boolean delete (  File file , boolean delete On Exit ) { if ( file == null ) throw new  Null Pointer Exception ( _ STR ) ; if ( ! file . exists ( ) ) return _ BOOL ; if ( file . is Directory ( ) ) {  File [ ] files = file . list Files ( ) ; for ( int i = _ NUM ; i < files . length ; i ++ ) delete ( files [ i ] , delete On Exit ) ; } if ( ! file . delete ( ) ) { if (  Utilities . is Windows ( ) && file . is File ( ) ) { for ( int i = _ NUM ; i < _ NUM ; i ++ ) {  System . gc ( ) ; if ( file . delete ( ) ) return _ BOOL ; } } if ( delete On Exit ) file . delete On Exit ( ) ; return _ BOOL ; } return _ BOOL ; }
public static  String find Edit Table (  String tables ) { if ( !  Text Utils . is Empty ( tables ) ) { int spacepos = tables . index Of ( _ STR ) ; int commapos = tables . index Of ( _ STR ) ; if ( spacepos > _ NUM && ( spacepos < commapos || commapos < _ NUM ) ) { return tables . substring ( _ NUM , spacepos ) ; } else if ( commapos > _ NUM && ( commapos < spacepos || spacepos < _ NUM ) ) { return tables . substring ( _ NUM , commapos ) ; } return tables ; } else { throw new  Illegal State Exception ( _ STR ) ; } }
public void write Operations Engine File ( ) { make Backup File ( default Operations Filename ( ) ) ; try { if ( ! check File ( default Operations Filename ( ) ) ) { java . io .  File file = new java . io .  File ( default Operations Filename ( ) ) ; java . io .  File parent Dir = file . get Parent File ( ) ; if ( ! parent Dir . exists ( ) ) { if ( ! parent Dir . mkdir ( ) ) { log . error ( _ STR ) ; } } if ( file . create New File ( ) ) { log . debug ( _ STR ) ; } } write File ( default Operations Filename ( ) ) ; } catch (  Exception e ) { log . error ( _ STR + e ) ; } }
public  Follower Info (  Follower .  Type type ,  String stream ,  List <  Follower > followers , int total ) { this . type = type ; this . followers = followers ; this . total = total ; this . time =  System . current Time Millis ( ) ; this . stream = stream ; this . request Error = _ BOOL ; this . request Error Description = null ; }
private static  String latitude Ref ( double latitude ) { return latitude < _ NUM ? _ STR : _ STR ; }
void fire Property Change (  Property Change Event evt ) { for (  Property Change Listener l : listener List . get Listeners (  Property Change Listener . class ) ) { l . property Change ( evt ) ; } }
public static void sort Methods (  Method Binding [ ] sorted Methods , int left , int right ) {  Arrays . sort ( sorted Methods , left , right ,  METHOD_ COMPARATOR ) ; }
private void draw Background ( final  Graphics g ) { g . set Color ( m_bg Color Offset ) ; g . fill Rect ( - m_first Column * m_char Width , _ NUM , m_offset View Width , get Height ( ) ) ; g . set Color ( m_bg Color Hex ) ; g . fill Rect ( ( - m_first Column * m_char Width ) + m_offset View Width , _ NUM , m_hex View Width , get Height ( ) ) ; g . set Color ( m_bg Color Ascii ) ; g . fill Rect ( ( - m_first Column * m_char Width ) + m_hex View Width + m_offset View Width , _ NUM , ( ( m_first Column * m_char Width ) + get Width ( ) ) - ( m_hex View Width + m_offset View Width ) - m_scrollbar . get Width ( ) , get Height ( ) - m_horizontal Scrollbar . get Height ( ) ) ; g . set Color (  Color .  BLACK ) ; g . draw Line ( ( - m_first Column * m_char Width ) + m_offset View Width , _ NUM , ( - m_first Column * m_char Width ) + m_offset View Width , get Height ( ) ) ; g . draw Line ( ( - m_first Column * m_char Width ) + m_offset View Width + m_hex View Width , _ NUM , ( - m_first Column * m_char Width ) + m_offset View Width + m_hex View Width , get Height ( ) ) ; }
public boolean is Attr Name Valid ( ) { return attr Name == null || ! attr Name Patterns . is Empty ( ) ; }
private static  Create Vm Response check Create Vm Response (  Create Vm Response create Vm Response ) throws  Rpc Exception { logger . info ( _ STR , create Vm Response ) ; switch ( create Vm Response . get Result ( ) ) { case  OK : break ; case  DISK_ NOT_ FOUND : throw new  Disk Not Found Exception ( create Vm Response . get Error ( ) ) ; case  IMAGE_ NOT_ FOUND : throw new  Image Not Found Exception ( create Vm Response . get Error ( ) ) ; case  INVALID_ RESERVATION : throw new  Invalid Reservation Exception ( create Vm Response . get Error ( ) ) ; case  NETWORK_ NOT_ FOUND : throw new  Network Not Found Exception ( create Vm Response . get Error ( ) ) ; case  SYSTEM_ ERROR : throw new  System Error Exception ( create Vm Response . get Error ( ) ) ; default : throw new  Rpc Exception (  String . format ( _ STR , create Vm Response . get Result ( ) ) ) ; } return create Vm Response ; }
default  Literal to Literal ( final  Object value ) { final  Value Factory vf =  Defaults .  VF ; if ( value instanceof  Float ) { return vf . create Literal ( (  Float ) value ) ; } else if ( value instanceof  Double ) { return vf . create Literal ( (  Double ) value ) ; } else if ( value instanceof  Integer ) { return vf . create Literal ( (  Integer ) value ) ; } else if ( value instanceof  Long ) { return vf . create Literal ( (  Long ) value ) ; } else if ( value instanceof  Boolean ) { return vf . create Literal ( (  Boolean ) value ) ; } else if ( value instanceof  Short ) { return vf . create Literal ( (  Short ) value ) ; } else if ( value instanceof  Byte ) { return vf . create Literal ( (  Byte ) value ) ; } else if ( value instanceof  String ) { return vf . create Literal ( (  String ) value ) ; } else { throw new  Illegal Argument Exception (  String . format ( _ STR , value ) ) ; } }
public  Authorization Code (  Json Value token ) throws  Invalid Grant Exception { super ( token ) ; if ( !  OAUTH_ CODE_ TYPE . equals ( get Token Name ( ) ) ) { throw new  Invalid Grant Exception ( _ STR + get Token Id ( ) ) ; } }
private static int convert Style (  Format Style style ) { if ( style == null ) { return - _ NUM ; } return style . ordinal ( ) ; }
public static  String clean Virtual Host (  String host ) { host = substring Before ( host , _ STR ) ; if ( host . ends With ( _ STR ) ) { host = host . substring ( _ NUM , host . length ( ) - _ NUM ) ; } return host ; }
public static <  T >  Future W <  T > of Error ( final  Throwable error ) { final  Completable Future <  T > cf = new  Completable Future < > ( ) ; cf . complete Exceptionally ( error ) ; return  Future W . <  T > of ( cf ) ; }
public static boolean is Numeric Type Specifier ( char c , boolean is Decimal ) { if ( is Decimal ) { switch ( c ) { case _ STR : case _ STR : case _ STR : case _ STR : case _ STR : case _ STR : return _ BOOL ; } } else { switch ( c ) { case _ STR : case _ STR : case _ STR : case _ STR : case _ STR : case _ STR : return _ BOOL ; } } return _ BOOL ; }
public static byte [ ] to Byte Array (  Input Stream in ) throws  IOException {  Byte Array Output Stream out = new  Byte Array Output Stream ( ) ; copy ( in , out ) ; return out . to Byte Array ( ) ; }
public void toggle Pause ( ) { mplayer . toggle Pause ( ) ; notify State ( get State ( ) ) ; }
public  String to String ( ) {  String Builder s = new  String Builder ( ) ; for (  String key : this ) s . append ( key + _ STR ) ; if ( s . length ( ) > _ NUM ) s . delete Char At ( s . length ( ) - _ NUM ) ; return s . to String ( ) ; }
public void test Encoding Decoding Fullness ( ) { for (  Grid Client Cache Flag f :  Grid Client Cache Flag . values ( ) ) { if ( f ==  KEEP_ BINARIES ) continue ; int bits =  Grid Client Connection . encode Cache Flags (  Collections . singleton ( f ) ) ; assert True ( bits != _ NUM ) ; boolean out =  Grid Cache Command Handler . parse Cache Flags ( bits ) ; assert Equals ( out , _ BOOL ) ; } }
public void add (  Data Source source ) { sources . add ( source ) ; }
public void add Value ( double value , double weight ) { m_ Weighted Sum += value * weight ; m_ Weighted Sum Squared += value * value * weight ; m_ Sum Of Weights += weight ; }
public static  String format Date (  Date date ) { return m Simple Date Format . format ( date ) ; }
private static void throw Bounds ( ) { throw new  Index Out Of Bounds Exception ( _ STR ) ; }
private static void compute Gapped Sequence Blast P (  String read Name ,  String read Sequence ,  String text ,  Collection <  Pair <  Integer ,  String > > insertions , boolean show Insertions ,  Single < char [ ] > reference Sequence ,  Alignment alignment ) throws  IOException { int length =  Basic . parse Int ( grab Next ( text , _ STR , _ STR ) ) ; if ( length == _ NUM ) length = _ NUM ; if ( reference Sequence . get ( ) == null ) reference Sequence . set ( new char [ length ] ) ; int start Query =  Basic . parse Int ( grab Next ( text , _ STR , _ STR ) ) ; int end Query =  Basic . parse Int ( grab Last In Line Passed Score ( text , _ STR ) ) ; if ( read Sequence == null ) throw new  IOException ( _ STR + read Name + _ STR ) ; if ( read Sequence . length ( ) <  Math . max ( start Query , end Query ) ) { throw new  IOException ( _ STR + read Name + _ STR + read Sequence . length ( ) + _ STR +  Math . max ( start Query , end Query ) ) ; } int start Subject =  Basic . parse Int ( grab Next ( text , _ STR , _ STR ) ) ; int end Subject =  Basic . parse Int ( grab Last In Line Passed Score ( text , _ STR ) ) ;  String query String = grab Query String ( text ) ;  String subject String = grab Subject String ( text ) ; int p = start Subject ; for ( int i = _ NUM ; i < subject String . length ( ) ; i ++ ) { if ( subject String . char At ( i ) != _ STR ) { reference Sequence . get ( ) [ p - _ NUM ] = subject String . char At ( i ) ; p ++ ; } } int align Pos = ( start Subject - _ NUM ) ;  Pair <  Integer ,  String > insertion = null ; final  String Writer w = new  String Writer ( ) ; for ( int m Pos = _ NUM ; m Pos < query String . length ( ) ; m Pos ++ ) { char ch = query String . char At ( m Pos ) ; if ( ch == _ STR ) { if ( insertion != null ) { insertion = null ; } w . write ( _ STR ) ; align Pos += _ NUM ; } else if ( subject String . char At ( m Pos ) == _ STR ) { if ( show Insertions ) { if ( insertion == null ) { insertion = new  Pair < > ( align Pos - _ NUM , query String . substring ( m Pos , m Pos + _ NUM ) ) ; insertions . add ( insertion ) ; } else { insertion . set Second ( insertion . get Second ( ) + read Sequence . substring ( m Pos , m Pos + _ NUM ) ) ; } } align Pos += _ NUM ; } else { if ( insertion != null ) { insertion = null ; } w . write ( ch ) ; align Pos += _ NUM ; } }  String block = w . to String ( ) ; int leading Gaps = start Subject - _ NUM ; int trailing Gaps = length - end Subject ;  String unaligned Prefix = read Sequence . substring ( _ NUM , start Query ) ;  String unaligned Suffix = read Sequence . substring ( end Query , read Sequence . length ( ) ) ; alignment . add Sequence ( read Name , text , null , unaligned Prefix , leading Gaps , block , trailing Gaps , unaligned Suffix ) ; }
@  Override public void schema Changed (  String service Name ,  String version ) { }
private  Collection <  Process Error State Info > launch Activity (  String package Name ) {  Intent home Intent = new  Intent (  Intent .  ACTION_ MAIN ) ; home Intent . add Category (  Intent .  CATEGORY_ HOME ) ; home Intent . add Flags (  Intent .  FLAG_ ACTIVITY_ NEW_ TASK ) ;  Intent intent = m Package Manager . get Launch Intent For Package ( package Name ) ; if ( intent == null ) {  Log . d (  TAG , _ STR + package Name + _ STR ) ; return null ; } final  Collection <  Process Error State Info > pre Err = m Activity Manager . get Processes In Error State ( ) ; m Context . start Activity ( intent ) ; try {  Thread . sleep ( m App Launch Timeout ) ; } catch (  Interrupted Exception e ) { } m Context . start Activity ( home Intent ) ; try {  Thread . sleep ( m Workspace Launch Timeout ) ; } catch (  Interrupted Exception e ) { } final  Collection <  Process Error State Info > post Err = m Activity Manager . get Processes In Error State ( ) ; if ( pre Err != null && post Err != null ) { post Err . remove All ( pre Err ) ; } return post Err ; }
public long count ( ) { return count . get ( ) ; }
protected void write String (  String s ) throws  IOException { for ( int i = _ NUM ; i < s . length ( ) ; i ++ ) { out . write ( ( byte ) s . char At ( i ) ) ; } }
public static void write (  String filename ,  Object o ) throws  Exception { write ( new  File Output Stream ( filename ) , o ) ; }
public void add Footer View (  View v ,  Object data , boolean is Selectable ) {  Fixed View Info info = new  Fixed View Info ( ) ; info . view = v ; info . data = data ; info . is Selectable = is Selectable ; m Footer View Infos . add ( info ) ; if ( m Data Set Observer != null ) { m Data Set Observer . on Changed ( ) ; } }
public  String process Filename (  String filename ) { if ( ! filename . starts With ( get Dir ( ) ) ) filename = get Dir ( ) + filename ; return filename ; }
public static  Player create Player (  String type , char mark ) {  Player player = null ; if ( type . equals (  Random ) ) { player = new  Random Player ( mark ) ; } else { return null ; } player . score ( new  Board Evaluation ( ) ) ; return player ; }
public static void remove Breakpoints ( final  Set <  Breakpoint Address > addresses , final  Breakpoint Manager manager ) {  Preconditions . check Not Null ( manager , _ STR ) ;  Preconditions . check Not Null ( addresses , _ STR ) ; final  Set <  Breakpoint Address > addresses To Remove From Manager = new  Hash Set <  Breakpoint Address > ( ) ; final  Set <  Breakpoint Address > addresses To Remove From Debugger = new  Hash Set <  Breakpoint Address > ( ) ; for ( final  Breakpoint Address address : addresses ) { final  Breakpoint Status status = manager . get Breakpoint Status ( address ,  Breakpoint Type .  REGULAR ) ; if ( ( status ==  Breakpoint Status .  BREAKPOINT_ DISABLED ) || ( status ==  Breakpoint Status .  BREAKPOINT_ INACTIVE ) ) { addresses To Remove From Manager . add ( address ) ; } if ( status !=  Breakpoint Status .  BREAKPOINT_ DELETING ) { addresses To Remove From Debugger . add ( address ) ; } } if ( addresses To Remove From Manager . size ( ) != _ NUM ) { manager . remove Breakpoints (  Breakpoint Type .  REGULAR , addresses To Remove From Manager ) ; } if ( addresses To Remove From Debugger . size ( ) != _ NUM ) { manager . set Breakpoint Status ( addresses To Remove From Debugger ,  Breakpoint Type .  REGULAR ,  Breakpoint Status .  BREAKPOINT_ DELETING ) ; } }
public void interrupt ( ) { future . cancel ( _ BOOL ) ; }
private static  String map To Text ( ) { final  String Buffer buffer = new  String Buffer ( ) ; for ( final  Map .  Entry <  Long ,  Integer > entry : m_count Map . entry Set ( ) ) { buffer . append (  String . format ( _ STR , entry . get Key ( ) , entry . get Value ( ) ) ) ; } return buffer . to String ( ) ; }
public static  Map <  String ,  Set <  String > > clone Map (  Map <  String ,  Set <  String > > map ) {  Map <  String ,  Set <  String > > clone = new  Hash Map <  String ,  Set <  String > > ( ) ; for (  String key : map . key Set ( ) ) {  Set <  String > set = new  Hash Set <  String > ( ) ;  Set <  String > orig = (  Set <  String > ) map . get ( key ) ; set . add All ( orig ) ; clone . put ( key , set ) ; } return clone ; }
public void test Find Spring Attributes Open Ldap ( ) {  Ldap Proxy proxy = get Ldap Open Ldap ( ) ;  List result = null ; try { result = proxy . find ( get Ldap Search VO ( _ STR ,  Ldap Constants .  NO_ SEARCH_ LIMIT , null , null , new  String [ ] { _ STR } ,  Ldap Scope Constants .  SCOPE_ SUBTREE ) ) ; } catch (  Exception e ) { } assert Not Null ( result ) ; assert Equals ( _ NUM , result . size ( ) ) ; }
public  Map read (  SSOToken token ,  String dn ) throws  SMSException ,  SSOException { if ( dn == null || dn . length ( ) == _ NUM ) { debug . error ( _ STR + dn ) ; throw new  SMSException ( _ STR , _ STR ) ; } if ( !  LDAPUtils . is DN ( dn ) ) { debug . warning ( _ STR + dn ) ;  String [ ] args = { dn } ; throw new  SMSException (  IUMSConstants .  UMS_ BUNDLE_ NAME , _ STR , args ) ; } if (  SMSNotification Manager . is Cache Enabled ( ) && entries Not Present . contains ( dn ) ) { if ( debug . message Enabled ( ) ) { debug . message ( _ STR + dn + _ STR ) ; } return ( null ) ; }  Search Request request =  Requests . new Search Request (  DN . value Of ( dn ) ,  Search Scope .  BASE_ OBJECT ,  Search Filter . object Class Present ( ) , sms Attributes . to Array ( new  String [ sms Attributes . size ( ) ] ) ) ;  Internal Search Operation iso = ic Conn . process Search ( request ) ;  Result Code result Code = iso . get Result Code ( ) ; if ( result Code ==  Result Code .  SUCCESS ) {  Linked List search Result = iso . get Search Entries ( ) ; if ( ! search Result . is Empty ( ) ) {  Search Result Entry entry = (  Search Result Entry ) search Result . get ( _ NUM ) ;  List attributes = entry . get Attributes ( ) ; return  Embedded Search Result Iterator . convert LDAPAttribute Set To Map ( attributes ) ; } else { return null ; } } else if ( result Code ==  Result Code .  NO_ SUCH_ OBJECT ) { object Changed ( dn ,  DELETE ) ; if ( debug . message Enabled ( ) ) { debug . message ( _ STR + _ STR + dn ) ; } return null ; } else { if ( debug . warning Enabled ( ) ) { debug . warning ( _ STR + _ STR + dn + _ STR + result Code ) ; } throw new  SMSException ( _ STR , _ STR ) ; } }
private static <  T extends  Abstract Block Base <  T > > void compute Code Emitting Order (  List <  T > order ,  Priority Queue <  T > worklist ,  Bit Set visited Blocks ) { while ( ! worklist . is Empty ( ) ) {  T next Important Path = worklist . poll ( ) ; add Path To Code Emitting Order ( next Important Path , order , worklist , visited Blocks ) ; } }
public void add Role (  Role Entity role ) { roles . add ( role ) ; }
private static  JCheck Box configure Check Box (  JCheck Box check Box ) { check Box . set Horizontal Alignment (  JCheck Box .  LEFT ) ; check Box . set Font (  UIManager . get Font ( _ STR ) ) ; check Box . set Border Painted ( _ BOOL ) ; check Box . set Focus Painted ( _ BOOL ) ; check Box . set Focusable ( _ BOOL ) ; check Box . set Opaque ( _ BOOL ) ; return check Box ; }
public  QDate (  Time Zone zone ) { _time Zone = zone ; if ( zone == _gmt Time Zone ) { _std Name = _gmt Std Name ; _dst Name = _gmt Dst Name ; } else if ( zone == _local Time Zone ) { _std Name = _local Std Name ; _dst Name = _local Dst Name ; } else { _std Name = _time Zone . get Display Name ( _ BOOL ,  Time Zone .  SHORT ) ; _dst Name = _time Zone . get Display Name ( _ BOOL ,  Time Zone .  SHORT ) ; } _calendar = new  Gregorian Calendar ( _time Zone ) ; set Local Time (  Current Time . current Time ( ) ) ; }
public void add Response (  Response response ) { response Vector . add Element ( response ) ; }
protected void finalize (  List <  Snapshot Files > snapshots , int file List Generation ,  Map <  String ,  Blob Meta Data > blobs ) {  Blob Store Index Shard Snapshots new Snapshots = new  Blob Store Index Shard Snapshots ( snapshots ) ;  List <  String > blobs To Delete = new  Array List < > ( ) ; for (  String blob Name : blobs . key Set ( ) ) { if ( index Shard Snapshots Format . is Temp Blob Name ( blob Name ) || blob Name . starts With (  SNAPSHOT_ INDEX_ PREFIX ) ) { blobs To Delete . add ( blob Name ) ; } } try { blob Container . delete Blobs ( blobs To Delete ) ; } catch (  IOException e ) { throw new  Index Shard Snapshot Failed Exception ( shard Id , _ STR + e . get Message ( ) , e ) ; } blobs To Delete = new  Array List < > ( ) ; for (  String blob Name : blobs . key Set ( ) ) { if ( blob Name . starts With (  DATA_ BLOB_ PREFIX ) ) { if ( new Snapshots . find Name File (  File Info . canonical Name ( blob Name ) ) == null ) { blobs To Delete . add ( blob Name ) ; } } } try { blob Container . delete Blobs ( blobs To Delete ) ; } catch (  IOException e ) { logger . debug ( _ STR , e , snapshot Id , shard Id , blobs To Delete ) ; } if ( snapshots . size ( ) > _ NUM ) { try { index Shard Snapshots Format . write Atomic ( new Snapshots , blob Container ,  Integer . to String ( file List Generation ) ) ; } catch (  IOException e ) { throw new  Index Shard Snapshot Failed Exception ( shard Id , _ STR , e ) ; } } }
public void read From (  Channel Buffer data ) { this . wildcards = data . read Int ( ) ; this . input Port = data . read Short ( ) ; this . data Layer Source = new byte [ _ NUM ] ; data . read Bytes ( this . data Layer Source ) ; this . data Layer Destination = new byte [ _ NUM ] ; data . read Bytes ( this . data Layer Destination ) ; this . data Layer Virtual Lan = data . read Short ( ) ; this . data Layer Virtual Lan Priority Code Point = data . read Byte ( ) ; data . read Byte ( ) ; this . data Layer Type = data . read Short ( ) ; this . network Type Of Service = data . read Byte ( ) ; this . network Protocol = data . read Byte ( ) ; data . read Byte ( ) ; data . read Byte ( ) ; this . network Source = data . read Int ( ) ; this . network Destination = data . read Int ( ) ; this . transport Source = data . read Short ( ) ; this . transport Destination = data . read Short ( ) ; }
@  Override public boolean is Armed ( ) { boolean b = should Act Like Button ( ) || ( pressed When Popup Visible && combo Box . is Popup Visible ( ) ) ; return b ? is Pressed ( ) : super . is Armed ( ) ; }
static  String canonical Name (  String element Or Attrib Name ) { return element Or Attrib Name . index Of ( _ STR ) >= _ NUM ? element Or Attrib Name :  Strings . to Lower Case ( element Or Attrib Name ) ; }
Sparse Array (  Class <  L > linear Array Type , int [ ] linear Indices , int [ ] row Indices , int [ ] col Indices ,  L real ,  L imag , int num Rows , int num Cols ) { _num Rows = num Rows ; _num Cols = num Cols ; _base Component Type = linear Array Type . get Component Type ( ) ; _output Array Type = (  Class <  L [ ] > )  Array Utils . get Array Class ( _base Component Type , _ NUM ) ; _linear Indices = linear Indices ; _row Indices = row Indices ; _col Indices = col Indices ; _real Values = linear Array Type . cast ( real ) ; _imag Values = linear Array Type . cast ( imag ) ; }
protected void update Radio Links ( ) { m_ Set Test But . set Enabled ( m_ Test Split But . is Selected ( ) ) ; if ( ( m_ Set Test Frame != null ) && ( ! m_ Test Split But . is Selected ( ) ) ) { m_ Set Test Frame . set Visible ( _ BOOL ) ; } m_ CVText . set Enabled ( m_ CVBut . is Selected ( ) ) ; m_ CVLab . set Enabled ( m_ CVBut . is Selected ( ) ) ; m_ Percent Text . set Enabled ( m_ Percent But . is Selected ( ) ) ; m_ Percent Lab . set Enabled ( m_ Percent But . is Selected ( ) ) ; }
public double eval ( int id1 , int id2 ,  Instance inst1 ) throws  Exception { double div =  Math . sqrt ( super . eval ( id1 , id1 , inst1 ) * ( ( m_keys != null ) ? super . eval ( id2 , id2 , m_data . instance ( id2 ) ) : super . eval ( - _ NUM , - _ NUM , m_data . instance ( id2 ) ) ) ) ; if ( div != _ NUM ) { return super . eval ( id1 , id2 , inst1 ) / div ; } else { return _ NUM ; } }
private int [ ] process Hits ( int hits ,  Int Buffer buffer ) { if ( hits == _ NUM ) { return  EMPTY_ HIT_ LIST ; } if ( hits < _ NUM ) { logger . warning ( _ STR + _ STR + buffer . capacity ( ) ) ; return  EMPTY_ HIT_ LIST ; } int [ ] hits Results = new int [ hits ] ; int offset = _ NUM ; int names ; for ( int i = _ NUM ; i < hits ; i ++ ) { names = buffer . get ( offset ) ; offset ++ ; offset ++ ; offset ++ ; for ( int j = _ NUM ; j < names ; j ++ ) { if ( j == ( names - _ NUM ) ) { hits Results [ i ] = buffer . get ( offset ) ; } offset ++ ; } } logger . fine ( _ STR + hits + _ STR + offset ) ; return hits Results ; }
public void test Default String To Type Convert ( ) {  Date Time Converter converter = make Converter ( ) ; converter . set Use Locale Format ( _ BOOL ) ; try { converter . convert ( get Expected Type ( ) , _ STR ) ; fail ( _ STR ) ; } catch (  Conversion Exception e ) { } }
private void create Filter List (  Filter Node node ,  List <  Filter > filter List ) { for ( int index = _ NUM ; index < node . get Child Count ( ) ; index ++ ) {  Filter Node filter Node = (  Filter Node ) node . get Child At ( index ) ;  Filter filter = add Filter ( filter Node ) ; filter List . add ( filter ) ; } }
private static double distance ( double x1 , double y1 , double x2 , double y2 ) { return  Math . sqrt ( ( y2 - y1 ) * ( y2 - y1 ) + ( x2 - x1 ) * ( x2 - x1 ) ) ; }
@  Override public  Object annotation Button ( final  Form Object form ) { final int subtype = form . get Parameter Constant (  Pdf Dictionary .  Subtype ) ; if ( subtype ==  Pdf Dictionary .  Popup ) { return create Annotation Popup ( form ) ; } if ( ! form . is Appearance Used ( ) ) { switch ( subtype ) { case  Pdf Dictionary .  Text : return create Annotation Text ( form ) ; case  Pdf Dictionary .  Free Text : return create Annotation Free Text ( form ) ; case  Pdf Dictionary .  Highlight : return create Anntoation Highlight ( form ) ; case  Pdf Dictionary .  Underline : return create Annotation Underline ( form ) ; case  Pdf Dictionary .  Ink : return create Annotation Ink ( form ) ; case  Pdf Dictionary .  Strick Out : return create Annotation Strike Out ( form ) ; } } return setup Annotation Button ( form ) ; }
protected static  List <  String > is Valid Git Version ( final  String git Response ) {  Trace . write Line ( _ STR ) ;  Trace . write Line ( _ STR + git Response ) ; final  String  Git Not Found = _ STR ; final  List <  String > result = new  Array List <  String > ( ) ; if ( git Response != null ) {  Version version = null ; try { version =  Version . parse Version ( git Response ) ; } catch ( final  Illegal Argument Exception ignored ) {  Trace . write Line ( _ STR + ignored . get Message ( ) ) ; result . add (  Git Not Found ) ; } if ( version != null ) { if ( version . get Major ( ) < _ NUM || ( version . get Major ( ) == _ NUM && version . get Minor ( ) < _ NUM ) ) { result . add ( _ STR + version . get Major ( ) + _ STR + version . get Minor ( ) + _ STR ) ; } } } else { result . add (  Git Not Found ) ; } return result ; }
public static  Vector2 max (  Vector2 o1 ,  Vector2 o2 ) { return new  Vector2 (  Math . max ( o1 . x , o2 . x ) ,  Math . max ( o1 . z , o2 . z ) ) ; }
public void accept (  Context context ) { if ( null != call Reference ) {  Respoke Call call = call Reference . get ( ) ; if ( null != call ) { call . direct Connection Did Accept ( context ) ; } } }
public void serialize (  Managed Object Path Serializer serializer ) { for (  Element < ? , ? > element : elements ) { element . serialize ( serializer ) ; } }
private void update Block Mirror Consistency Group ( ) { log . info ( _ STR ) ;  Db Client db Client = get Db Client ( ) ;  List <  URI > block Mirror URIs = db Client . query By Type (  Block Mirror . class , _ BOOL ) ;  Iterator <  Block Mirror > block Mirrors = db Client . query Iterative Objects (  Block Mirror . class , block Mirror URIs ) ;  List <  Block Object > block Objects = new  Array List <  Block Object > ( ) ; while ( block Mirrors . has Next ( ) ) { block Objects . add ( block Mirrors . next ( ) ) ; } migrate ( block Objects ) ; }
public static int calc RWCount ( int lvl ) { return ( int )  Math . ceil (  Math . log10 ( _ NUM + rand . next Int ( lvl * lvl + _ NUM ) ) ) + rand . next Int ( _ NUM ) ; }
private  Element create Organization (  String name ,  String displ Name ,  String url ,  String lang Str ) throws  Exception {  Element org Ele = doc . create Element (  SAMLNames .  ORGANIZATION ) ;  Element name Ele = doc . create Element (  SAMLNames .  ORGANIZATIONNAME ) ; name Ele . set Attribute (  SAMLNames .  XMLLANG ,  SAMLNames .  ENGLISH ) ; name Ele . append Child ( doc . create Text Node ( name ) ) ; org Ele . append Child ( name Ele ) ;  Element display Name Ele = doc . create Element (  SAMLNames .  ORGANIZATIONDISPLAYNAME ) ; display Name Ele . set Attribute (  SAMLNames .  XMLLANG ,  SAMLNames .  ENGLISH ) ; display Name Ele . append Child ( doc . create Text Node ( displ Name ) ) ; org Ele . append Child ( display Name Ele ) ;  String url Str = idm Client . get Entity ID ( tenant Name ) ; if ( url Str == null ) { url Str = tenant Name ; }  Element url Ele = doc . create Element (  SAMLNames .  ORGANIZATIONURL ) ; url Ele . set Attribute (  SAMLNames .  XMLLANG , lang Str ) ; url Ele . append Child ( doc . create Text Node ( url ) ) ; org Ele . append Child ( url Ele ) ; return org Ele ; }
public void clear ( ) { info Queue . clear ( ) ; allocator . release ( data Queue . to Array ( new  Allocation [ data Queue . size ( ) ] ) ) ; data Queue . clear ( ) ; total Bytes Dropped = _ NUM ; total Bytes Written = _ NUM ; last Allocation = null ; last Allocation Offset = allocation Length ; }
public static final void push Transform (  GL2 gl ) { gl . gl Push Matrix ( ) ; }
public static  Result Set simple Result Set ( ) {  Simple Result Set rs = new  Simple Result Set ( ) ; rs . add Column ( _ STR ,  Types .  INTEGER , _ NUM , _ NUM ) ; rs . add Column ( _ STR ,  Types .  VARCHAR , _ NUM , _ NUM ) ; rs . add Row ( _ NUM , _ STR ) ; return rs ; }
private void verify VPlex Volume Results ( ) throws  Exception { for (  URI volume URI : vplex Test Volume URIs ) {  Volume volume = _db Client . query Object (  Volume . class , volume URI ) ;  Assert . assert Not Null (  String . format ( _ STR , volume URI ) , volume ) ;  String Set associated Volumes = volume . get Associated Volumes ( ) ; if ( ( associated Volumes != null ) && ( ! associated Volumes . is Empty ( ) ) ) {  Assert . assert False ( _ STR , volume . check Internal Flags (  Flag .  INTERNAL_ OBJECT ) ) ; } else {  Assert . assert True ( _ STR , volume . check Internal Flags (  Flag .  INTERNAL_ OBJECT ) ) ; } } }
public static  File Channel create Temp File (  String prefix ,  String suffix ) throws  IOException { return create Temp File (  TMPDIR , prefix , suffix ) ; }
private  Method Type remove Wrapper (  Method Type target Type ) {  Class [ ] types = target Type . parameter Array ( ) ; for ( int i = _ NUM ; i < types . length ; i ++ ) { if ( types [ i ] ==  Wrapper . class ) { target Type = target Type . change Parameter Type ( i ,  Object . class ) ; } } return target Type ; }
Block Id append (  String file Name ,  Io Buffer buffer ) { try {  Io Channel file Channel = get File Channel ( file Name ) ; buffer . rewind ( ) ; long new Size = file Channel . append ( buffer ) ; return new  Block Id ( file Name , new Size /  BLOCK_ SIZE - _ NUM ) ; } catch (  IOException e ) { e . print Stack Trace ( ) ; return null ; } }
public static  String amount In Words ( final  Big Decimal amount ) { return  Number To Word . amount In Words ( amount . double Value ( ) ) ; }
public void pop Template Folder ( ) { my Last Template Folders . pop ( ) ; }
public  JTool Tip create Tool Tip ( ) { return new  JMulti Line Tool Tip ( ) ; }
public void update (  List <  String > new Items ) { items . clear ( ) ; for (  String item : new Items ) { if ( item != null && ! item . is Empty ( ) ) { items . add ( new  Highlight Item ( item ) ) ; } } }
public void save ( final  Path path ) throws  IOException { try (  Output Stream os = new  Buffered Output Stream (  Files . new Output Stream ( path ) ) ) { save ( new  Output Stream Data Output ( os ) ) ; } }
public long signal ( ) { return  Long . parse Long ( fields [ _ NUM ] ) ; }
private static byte [ ] generate Seed ( ) { try {  Byte Array Output Stream seed Buffer = new  Byte Array Output Stream ( ) ;  Data Output Stream seed Buffer Out = new  Data Output Stream ( seed Buffer ) ; seed Buffer Out . write Long (  System . current Time Millis ( ) ) ; seed Buffer Out . write Long (  System . nano Time ( ) ) ; seed Buffer Out . write Int (  Process . my Pid ( ) ) ; seed Buffer Out . write Int (  Process . my Uid ( ) ) ; seed Buffer Out . write (  BUILD_ FINGERPRINT_ AND_ DEVICE_ SERIAL ) ; seed Buffer Out . close ( ) ; return seed Buffer . to Byte Array ( ) ; } catch (  IOException e ) { throw new  Security Exception ( _ STR , e ) ; } }
public void add Filter (  Value Expr the Expr ) { m Filters . add ( the Expr ) ; }
public void start Sampling ( ) { if ( m Sampling Counter . get And Increment ( ) == _ NUM ) { m Handler . start Sampling Thread ( ) ; m Last Time Reading =  System Clock . elapsed Realtime ( ) ; } }
public  DSign Csr (  JFrame parent ,  Spkac spkac Csr ,  File csr File ,  Private Key sign Private Key ,  Key Pair Type sign Key Pair Type ,  X509 Certificate verification Certificate ,  Provider provider ) throws  Crypto Exception { super ( parent ,  Dialog .  Modality Type .  DOCUMENT_ MODAL ) ; this . spkac Csr = spkac Csr ; this . csr File = csr File ; this . sign Private Key = sign Private Key ; this . sign Key Pair Type = sign Key Pair Type ; this . verification Certificate = verification Certificate ; this . provider = provider ; set Title ( res . get String ( _ STR ) ) ; init Components ( ) ; }
public  Host Scsi Disk find Scsi Disk (  Host System host ,  Cluster Compute Resource cluster ,  Block Object Rest Rep volume ) { if (  String Utils . is Blank ( volume . get Wwn ( ) ) ) {  String volume Id =  Resource Utils . string Id ( volume ) ;  String volume Name =  Resource Utils . name ( volume ) ;  Execution Utils . fail ( _ STR , new  Object [ ] { volume Id } , new  Object [ ] { volume Name } ) ; }  Host Scsi Disk disk = execute ( new  Find Host Scsi Disk For Lun ( host , volume ) ) ; if ( cluster != null ) {  Host System [ ] hosts = cluster . get Hosts ( ) ; if ( hosts == null ) { throw new  Illegal State Exception ( _ STR + cluster . get Name ( ) + _ STR ) ; }  Map <  Host System ,  Host Scsi Disk > disks =  Maps . new Hash Map ( ) ; disks . put ( host , disk ) ; for (  Host System other Host : hosts ) { if (  String Utils . equals ( host . get Name ( ) , other Host . get Name ( ) ) ) { continue ; }  Host Scsi Disk other Disk = execute ( new  Find Host Scsi Disk For Lun ( other Host , volume ) ) ; disks . put ( other Host , other Disk ) ; } } return disk ; }
protected  String handle Time (  Time time ) { return time == null ? null : time . to String ( ) ; }
public static  String left (  String s , int width , char fill Char ) { if ( s . length ( ) >= width ) { return s ; }  String Buffer sb = new  String Buffer ( width ) ; sb . append ( s ) ; for ( int i = width - s . length ( ) ; -- i >= _ NUM ; ) { sb . append ( fill Char ) ; } return sb . to String ( ) ; }
public synchronized boolean add All (  Collection c ) { mod Count ++ ;  Object [ ] a = c . to Array ( ) ; int num New = a . length ; ensure Capacity Helper ( element Count + num New ) ;  System . arraycopy ( a , _ NUM , element Data , element Count , num New ) ; element Count += num New ; return num New != _ NUM ; }
public void update (  CSTState state ) { new Checkpoint ( state . get Serialized State ( ) , state . get State Hash ( ) , state . get Checkpoint CID ( ) ) ; set Last Checkpoint CID ( state . get Checkpoint CID ( ) ) ; }
public void put (  String key ,  Array List <  String > value ) {  Iterator <  Pair <  String ,  Array List <  String > > > it = store . iterator ( ) ; while ( it . has Next ( ) ) {  Pair <  String ,  Array List <  String > > pair = it . next ( ) ; if ( key . equals ( pair . first ) ) { pair . second = value ; return ; } } store . add ( new  Pair < > ( key , value ) ) ; }
public void remove Message Observer ( final  Message Observer observer ) { if ( observer == null ) { throw new  Null Pointer Exception ( ) ; } else if ( message Observers != null ) { message Observers . remove ( observer ) ; } }
private void init Contents (  Composite main ) { if ( null != initial Name ) { name Box . set Text ( initial Name ) ; } if ( null != initial Measurement ) { measurement Box . set Text ( initial Measurement ) ; } if ( null != initial Field ) { field Box . set Text ( initial Field ) ; } if ( null != initial Tags ) { for (  Entry <  String ,  String > tag : initial Tags . entry Set ( ) ) {  Tag Key Value UIComponent tag Component = new  Tag Key Value UIComponent ( main , tag . get Key ( ) , tag . get Value ( ) ) ; tag Components . add ( tag Component ) ; } } }
public static  String hash To String ( byte [ ] hash ) {  String Builder buf = new  String Builder ( ) ; for ( byte b : hash ) { buf . append (  HEX_ CHARS [ ( b > > _ NUM ) & _ NUM ] ) ; buf . append (  HEX_ CHARS [ b & _ NUM ] ) ; } return buf . to String ( ) ; }
public  E remove ( int index ) { range Check ( index ) ; mod Count ++ ;  E old Value = element Data ( index ) ; int num Moved = size - index - _ NUM ; if ( num Moved > _ NUM )  System . arraycopy ( element Data , index + _ NUM , element Data , index , num Moved ) ; element Data [ -- size ] = null ; return old Value ; }
public static  Double Vector rchisq ( int n , double ncp ,  Random random ) {  Double Vector v = new  Double Vector ( n ) ; double mean =  Math . sqrt ( ncp ) ; double x ; for ( int i = _ NUM ; i < n ; i ++ ) { x = random . next Gaussian ( ) + mean ; v . set ( i , x * x ) ; } return v ; }
public final  Pdf Object read Reference Table ( final  Pdf Object linear Obj , final  Pdf File Reader current Pdf File , final  Object Reader object Reader ) throws  Pdf Exception { int pointer = - _ NUM ; final int eof = ( int ) this . eof ; boolean islinearized Compressed = _ BOOL ; if ( linear Obj == null ) { pointer = read First Start Ref ( ) ; } else { final byte [ ] data = pdf_datafile . get Pdf Buffer ( ) ; final int count = data . length ; int ptr = _ NUM ; for ( int i = _ NUM ; i < count ; i ++ ) { if ( data [ i ] == _ STR && data [ i + _ NUM ] == _ STR && data [ i + _ NUM ] == _ STR && data [ i + _ NUM ] == _ STR && data [ i + _ NUM ] == _ STR && data [ i + _ NUM ] == _ STR ) { ptr = i + _ NUM ; } if ( data [ i ] == _ STR && data [ i + _ NUM ] == _ STR && data [ i + _ NUM ] == _ STR && data [ i + _ NUM ] == _ STR ) { pointer = i ; i = count ; } else if ( data [ i ] == _ STR && data [ i + _ NUM ] == _ STR && data [ i + _ NUM ] == _ STR && data [ i + _ NUM ] == _ STR ) { islinearized Compressed = _ BOOL ; pointer = ptr ; while ( data [ pointer ] == _ NUM || data [ pointer ] == _ NUM || data [ pointer ] == _ NUM ) { pointer ++ ; } i = count ; } } } offset . add Xref ( pointer ) ;  Pdf Object root Obj = null ; if ( pointer >= eof || pointer == _ NUM ) {  Log Writer . write Log ( _ STR ) ; offset . set Ref Table Invalid ( _ BOOL ) ; try { root Obj = new  Page Object (  Broken Ref Table . find Offsets ( pdf_datafile , offset ) ) ; } catch (  Error err ) { throw new  Pdf Exception ( err . get Message ( ) + _ STR ) ; } current Pdf File . read Object ( root Obj ) ; return root Obj ; } else if ( islinearized Compressed || is Compressed Stream ( pointer , eof ) ) { return read Compressed Stream ( root Obj , pointer , current Pdf File , object Reader , linear Obj ) ; } else { return read Legacy Reference Table ( root Obj , pointer , eof , current Pdf File ) ; } }
void warning Occurred ( int code ) { cb Lock . lock ( ) ; try { if ( ( code < _ NUM ) || ( code >  MAX_ WARNING ) ) { throw new  Internal Error ( _ STR ) ; } process Warning Occurred ( current Image , _ STR ,  Integer . to String ( code ) ) ; } finally { cb Lock . unlock ( ) ; } }
public void add Sub Action (  Sub Action sub ) { list . add ( sub ) ; }
private void fill Stored Fields ( int doc ID ) throws  IOException ,  Aborting Exception { while ( last Stored Doc ID < doc ID ) { start Stored Fields ( ) ; finish Stored Fields ( ) ; } }
public void clear2 Lead Search Light ( int bit ) { if ( node Type !=  SMINI ) { log . error ( _ STR ) ; return ; } if ( ( bit < _ NUM ) || ( bit > _ NUM ) ) { log . error ( _ STR +  Integer . to String ( bit ) ) ; return ; } if ( ( loc Search Light Bits [ bit ] != _ NUM ) || ( loc Search Light Bits [ bit + _ NUM ] != _ NUM ) ) { log . error ( _ STR +  Integer . to String ( bit ) ) ; return ; } loc Search Light Bits [ bit ] = _ NUM ; loc Search Light Bits [ bit + _ NUM ] = _ NUM ; num2 LSearch Lights -- ; }
public void calc Min Tick ( ) { if ( min Data == _ NUM ) min Tick = _ NUM ; else min Tick =  Math . floor ( min Data / major Tick ) * major Tick ; }
void add Attribute Value (  String attribute ,  String value ) { if ( attribute . equals (  OMA_ TYPE ) ) { m Types . add ( value ) ; } else { m Description . put ( attribute , value ) ; } }
private  Upstream Queue State monitor Upstream Queue And Pause Traffic ( ) { if ( get Upstream Queue Status ( ) ==  Upstream Queue State .  FULL ) { if ( m_paused . compare And Set ( _ BOOL , _ BOOL ) ) { pause Traffic ( ) ; } return  Upstream Queue State .  FULL ; } return  Upstream Queue State .  EMPTY ; }
protected double apply Operator ( double first , double second ) { switch ( m_operator ) { case _ STR : return ( first + second ) ; case _ STR : return ( first - second ) ; case _ STR : return ( first * second ) ; case _ STR : return ( first / second ) ; case _ STR : return  Math . pow ( first , second ) ; } return  Double .  Na N ; }
protected  String parse (  Reader reader ) throws  IOException { if ( ! reader . mark Supported ( ) ) { reader = new  Buffered Reader ( reader ) ; }  String Writer sw = new  String Writer ( ) ; start Script ( sw ) ; int c ; while ( ( c = reader . read ( ) ) != - _ NUM ) { if ( c == _ STR ) { reader . mark ( _ NUM ) ; c = reader . read ( ) ; if ( c != _ STR ) { sw . write ( _ STR ) ; reader . reset ( ) ; } else { reader . mark ( _ NUM ) ; c = reader . read ( ) ; if ( c == _ STR ) { groovy Expression ( reader , sw ) ; } else { reader . reset ( ) ; groovy Section ( reader , sw ) ; } } continue ; } if ( c == _ STR ) { reader . mark ( _ NUM ) ; c = reader . read ( ) ; if ( c != _ STR ) { sw . write ( _ STR ) ; reader . reset ( ) ; } else { reader . mark ( _ NUM ) ; sw . write ( _ STR ) ; process GSstring ( reader , sw ) ; } continue ; } if ( c == _ STR ) { sw . write ( _ STR ) ; } if ( c == _ STR || c == _ STR ) { if ( c == _ STR ) { reader . mark ( _ NUM ) ; c = reader . read ( ) ; if ( c != _ STR ) { reader . reset ( ) ; } } sw . write ( _ STR ) ; continue ; } sw . write ( c ) ; } end Script ( sw ) ; return sw . to String ( ) ; }
public  Shape straight Line Shape ( ) {  General Path path = null ; if ( llpts != null && llpts . length >= _ NUM && llpts . length % _ NUM == _ NUM ) { double y1 = llpts [ _ NUM ] ; double x1 = llpts [ _ NUM ] ; path = new  General Path (  General Path .  WIND_ EVEN_ ODD , llpts . length / _ NUM ) ; if ( return Degrees ) { path . move To (  Proj Math . rad To Deg ( x1 ) ,  Proj Math . rad To Deg ( y1 ) ) ; } else { path . move To ( x1 , y1 ) ; } for ( int i = _ NUM ; i < llpts . length - _ NUM ; i += _ NUM ) { x1 = llpts [ i + _ NUM ] ; y1 = llpts [ i ] ; if ( return Degrees ) { path . line To (  Proj Math . rad To Deg ( x1 ) ,  Proj Math . rad To Deg ( y1 ) ) ; } else { path . line To ( x1 , y1 ) ; } } } return path ; }
protected  Handshake Message (  Inet Socket Address peer Address ) { super ( peer Address ) ; }
protected static  Vector convert To Vector ( final  Object [ ] [ ] an Array ) { if ( an Array == null ) { return null ; } final  Vector v = new  Vector ( an Array . length ) ; for ( final  Object [ ] element : an Array ) { v . add Element ( convert To Vector ( element ) ) ; } return v ; }
synchronized protected void timeout ( ) {  Sprog Version v ; switch ( state ) { case  CRSENT : log . debug ( _ STR ) ; state =  Query State .  IDLE ; v = new  Sprog Version ( new  Sprog Type (  Sprog Type .  TIMEOUT ) ) ; notify Version ( v ) ; break ; case  QUERYSENT : log . debug ( _ STR ) ; state =  Query State .  IDLE ; v = new  Sprog Version ( new  Sprog Type (  Sprog Type .  NOT_ A_ SPROG ) ) ; notify Version ( v ) ; break ; case  DONE : case  IDLE : log . error ( _ STR + state ) ; break ; } }
protected void reject Drop ( ) {  Drop Target Context Peer peer = get Drop Target Context Peer ( ) ; if ( peer != null ) { peer . reject Drop ( ) ; } }
public void add Capabilities Filter Listener (  Capabilities Filter Change Listener l ) { m_ Capabilities Filter Change Listeners . add ( l ) ; }
protected void process Nodes After Add Instance (  Ball Node node ) { node . m_ Start ++ ; node . m_ End ++ ; if ( node . m_ Left != null && node . m_ Right != null ) { process Nodes After Add Instance ( node . m_ Left ) ; process Nodes After Add Instance ( node . m_ Right ) ; } }
public long file Size (  String path ) throws  Illegal State Exception ,  IOException ,  FTPIllegal Reply Exception ,  FTPException { synchronized ( lock ) { if ( ! connected ) { throw new  Illegal State Exception ( _ STR ) ; } if ( ! authenticated ) { throw new  Illegal State Exception ( _ STR ) ; } communication . send FTPCommand ( _ STR ) ;  FTPReply r = communication . read FTPReply ( ) ; touch Auto Noop Timer ( ) ; if ( ! r . is Success Code ( ) ) { throw new  FTPException ( r ) ; } communication . send FTPCommand ( _ STR + path ) ; r = communication . read FTPReply ( ) ; touch Auto Noop Timer ( ) ; if ( ! r . is Success Code ( ) ) { throw new  FTPException ( r ) ; }  String [ ] messages = r . get Messages ( ) ; if ( messages . length != _ NUM ) { throw new  FTPIllegal Reply Exception ( ) ; } else { try { return  Long . parse Long ( messages [ _ NUM ] ) ; } catch (  Throwable t ) { throw new  FTPIllegal Reply Exception ( ) ; } } } }
public boolean import Type Selected ( ) { return import Type Selected ; }
public  Phase One Result process (  Tree Path body Path ,  Processing Environment env ,  Underlying AST underlying AST ,  Label exceptional Exit Label ,  Tree Builder tree Builder ,  Annotation Provider annotation Provider ) { this . env = env ; this . try Stack = new  Try Stack ( exceptional Exit Label ) ; this . tree Builder = tree Builder ; this . annotation Provider = annotation Provider ; elements = env . get Element Utils ( ) ; types = env . get Type Utils ( ) ; tree Lookup Map = new  Identity Hash Map < > ( ) ; converted Tree Lookup Map = new  Identity Hash Map < > ( ) ; node List = new  Array List < > ( ) ; bindings = new  Hash Map < > ( ) ; leaders = new  Hash Set < > ( ) ; break Labels = new  Hash Map < > ( ) ; continue Labels = new  Hash Map < > ( ) ; return Nodes = new  Array List < > ( ) ; scan ( body Path , null ) ; node List . add ( new  Unconditional Jump ( regular Exit Label ) ) ; return new  Phase One Result ( underlying AST , tree Lookup Map , converted Tree Lookup Map , node List , bindings , leaders , return Nodes ) ; }
public boolean is Fusion ( ) { if ( ( engine Type ==  COMBUSTION_ ENGINE ) || ( engine Type ==  FISSION ) || ( engine Type ==  FUEL_ CELL ) || ( engine Type ==  NONE ) || ( engine Type ==  BATTERY ) || ( engine Type ==  SOLAR ) || ( engine Type ==  STEAM ) || ( engine Type ==  MAGLEV ) ) { return _ BOOL ; } return _ BOOL ; }
private double [ ] calculate B ( ) { int length = m Extremal Indices . size ( ) ; double [ ] b = new double [ length ] ; for ( int k = _ NUM ; k < length ; k ++ ) { b [ k ] = _ NUM ; double xk = m Grid . get Cosine Frequency Grid ( ) [ m Extremal Indices . get ( k ) ] ; for ( int i = _ NUM ; i < length ; i ++ ) { if ( i != k ) { double xi = m Grid . get Cosine Frequency Grid ( ) [ m Extremal Indices . get ( i ) ] ; double denominator = xk - xi ; if (  Math . abs ( denominator ) < _ NUM ) { denominator = _ NUM ; } b [ k ] *= _ NUM / denominator ; } } } return b ; }
public static  String trim Right (  String src ) { int len = src . length ( ) ; int count = len ; while ( ( len > _ NUM ) && (  Char Util . is Whitespace ( src . char At ( len - _ NUM ) ) ) ) { len -- ; } return ( len < count ) ? src . substring ( _ NUM , len ) : src ; }
public void test File File ( ) throws  Exception {  Properties properties = load Properties ( _ STR ) ; assert Equals ( _ STR , properties . get Property ( _ STR ) ) ; }
public static  Map <  String ,  Map <  String ,  Map <  String ,  Object > > > prepare Field (  Map <  String , ? > input Fields ,  Map <  String ,  Object > query String Map ,  Map <  String ,  List <  Object [ ] > > orig Value Map ) {  Map <  String ,  Map <  String ,  Map <  String ,  Object > > > normalized Fields = new  Linked Hash Map <  String ,  Map <  String ,  Map <  String ,  Object > > > ( ) ; for (  String field Name Raw : input Fields . key Set ( ) ) {  String field Name Root = null ;  String field Pair = null ;  Object field Value = null ; int i Pos = - _ NUM ; int i Pos2 = - _ NUM ;  Map <  String ,  Map <  String ,  Object > > sub Map = null ;  Map <  String ,  Object > sub Map2 = null ;  String field Mode = null ; field Value = input Fields . get ( field Name Raw ) ; if (  Object Type . is Empty ( field Value ) ) { continue ; } query String Map . put ( field Name Raw , field Value ) ; i Pos = field Name Raw . index Of ( _ STR ) ; if ( i Pos >= _ NUM ) {  String suffix = field Name Raw . substring ( i Pos + _ NUM ) ; i Pos2 = suffix . index Of ( _ STR ) ; if ( i Pos2 == _ NUM ) { continue ; } } if ( i Pos < _ NUM ) { field Name Root = field Name Raw ; field Pair = _ STR ; field Mode = _ STR ; } else { field Name Root = field Name Raw . substring ( _ NUM , i Pos ) ;  String suffix = field Name Raw . substring ( i Pos + _ NUM ) ; i Pos2 = suffix . index Of ( _ STR ) ; if ( i Pos2 < _ NUM ) { if ( suffix . starts With ( _ STR ) ) { field Pair = suffix ; field Mode = _ STR ; } else { field Pair = _ STR ; field Mode = suffix ; } } else {  String tkn0 = suffix . substring ( _ NUM , i Pos2 ) ;  String tkn1 = suffix . substring ( i Pos2 + _ NUM ) ; if ( tkn0 . starts With ( _ STR ) ) { field Pair = tkn0 ; field Mode = tkn1 ; } else { field Pair = tkn1 ; field Mode = tkn0 ; } } } sub Map = normalized Fields . get ( field Name Root ) ; if ( sub Map == null ) { sub Map = new  Linked Hash Map <  String ,  Map <  String ,  Object > > ( ) ; normalized Fields . put ( field Name Root , sub Map ) ; } sub Map2 = sub Map . get ( field Pair ) ; if ( sub Map2 == null ) { sub Map2 = new  Linked Hash Map <  String ,  Object > ( ) ; sub Map . put ( field Pair , sub Map2 ) ; } sub Map2 . put ( field Mode , field Value ) ;  List <  Object [ ] > orig List = orig Value Map . get ( field Name Root ) ; if ( orig List == null ) { orig List = new  Linked List <  Object [ ] > ( ) ; orig Value Map . put ( field Name Root , orig List ) ; }  Object [ ] orig Values = { field Name Raw , field Value } ; orig List . add ( orig Values ) ; } return normalized Fields ; }
@  Suppress Warnings ( _ STR ) public <  U >  Lazy Future Stream <  U > from ( final  Iterator <  U > iterator ) { return from Stream (  Stream Support . stream (  Spliterators . spliterator Unknown Size ( iterator ,  Spliterator .  ORDERED ) , _ BOOL ) ) ; }
boolean skip Object ( ) throws  IOException { int ch = read ( ) ; int len ; switch ( ch ) { case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : skip ( ch - _ NUM ) ; return _ BOOL ; case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : skip ( ch - _ NUM ) ; return _ BOOL ; case _ NUM : case _ NUM : case _ NUM : case _ NUM : len = _ NUM * ( ch - _ NUM ) + read ( ) ; skip ( len ) ; return _ BOOL ; case _ NUM : case _ NUM : case _ NUM : case _ NUM : len = _ NUM * ( ch - _ NUM ) + read ( ) ; skip ( len ) ; return _ BOOL ; case _ NUM : case _ NUM : case _ NUM : case _ NUM : skip ( _ NUM ) ; return _ BOOL ; case _ NUM : len = read Short ( ) ; skip ( len ) ; return skip Object ( ) ; case _ NUM : len = read Short ( ) ; skip ( len ) ; return _ BOOL ; case _ NUM : scan Object Def ( ) ; return skip Object ( ) ; case _ NUM : skip ( _ NUM ) ; return _ BOOL ; case _ NUM : throw new  Illegal State Exception ( _ STR ) ; case _ NUM : return _ BOOL ; case _ NUM : skip Object ( ) ; skip Object ( ) ; return _ BOOL ; case _ NUM : { skip Map ( ) ; return _ BOOL ; } case _ NUM : skip ( _ NUM ) ; return _ BOOL ; case _ NUM : skip ( _ NUM ) ; return _ BOOL ; case _ NUM : skip ( _ NUM ) ; return _ BOOL ; case _ NUM : skip ( _ NUM ) ; return _ BOOL ; case _ NUM : { skip Object ( ) ; skip Map ( ) ; return _ BOOL ; } case _ NUM : return _ BOOL ; case _ NUM : { int type = scan Int ( ) ;  String [ ] def = _class Defs . get ( type ) ; len = def . length - _ NUM ; for ( int i = _ NUM ; i < len ; i ++ ) { skip Object ( ) ; } return _ BOOL ; } case _ NUM : skip Object ( ) ; skip Object ( ) ; return _ BOOL ; case _ NUM : skip Object ( ) ; return _ BOOL ; case _ NUM : len = read Short ( ) ; skip ( len ) ; return skip Object ( ) ; case _ NUM : len = read Short ( ) ; skip ( len ) ; return _ BOOL ; case _ NUM : return _ BOOL ; case _ NUM : read Type ( ) ; while ( skip Object ( ) ) { } return _ BOOL ; case _ NUM : read Type ( ) ; len = scan Int ( ) ; for ( int i = _ NUM ; i < len ; i ++ ) { skip Object ( ) ; } return _ BOOL ; case _ NUM : while ( skip Object ( ) ) { } return _ BOOL ; case _ NUM : len = scan Int ( ) ; for ( int i = _ NUM ; i < len ; i ++ ) { skip Object ( ) ; } return _ BOOL ; case _ NUM : skip ( _ NUM ) ; return _ BOOL ; case _ NUM : return _ BOOL ; case _ NUM : case _ NUM : return _ BOOL ; case _ NUM : skip ( _ NUM ) ; return _ BOOL ; case _ NUM : skip ( _ NUM ) ; return _ BOOL ; case _ NUM : return skip Object ( ) ; case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : { int type = ch - _ NUM ;  String [ ] def = _class Defs . get ( type ) ; len = def . length - _ NUM ; for ( int i = _ NUM ; i < len ; i ++ ) { skip Object ( ) ; } return _ BOOL ; } case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : skip Object ( ) ; len = ch - _ NUM ; for ( int i = _ NUM ; i < len ; i ++ ) { skip Object ( ) ; } return _ BOOL ; case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : len = ch - _ NUM ; for ( int i = _ NUM ; i < len ; i ++ ) { skip Object ( ) ; } return _ BOOL ; case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : return _ BOOL ; case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : skip ( _ NUM ) ; return _ BOOL ; case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : skip ( _ NUM ) ; return _ BOOL ; case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : return _ BOOL ; case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : skip ( _ NUM ) ; return _ BOOL ; default : throw new  Unsupported Operation Exception ( _ STR +  Integer . to Hex String ( ch ) ) ; } }
@  Override public void read External (  Object Input in ) throws  IOException { m = in . read Double ( ) ; t = in . read Double ( ) ; }
public  Interval XYItem Label Generator ( ) { this (  DEFAULT_ ITEM_ LABEL_ FORMAT ,  Number Format . get Number Instance ( ) ,  Number Format . get Number Instance ( ) ) ; }
public double adjusted Log10 ( double val ) { boolean neg Flag = ( val < _ NUM ) ; if ( neg Flag ) { val = - val ; } if ( val < _ NUM ) { val += ( _ NUM - val ) / _ NUM ; } double res =  Math . log ( val ) /  LOG10_ VALUE ; return neg Flag ? ( - res ) : res ; }
public boolean is Last Invoice ( ) {  String cm = get Costing Method ( ) ; return cm != null && cm . equals (  COSTINGMETHOD_ Last Invoice ) &&  COSTELEMENTTYPE_ Material . equals ( get Cost Element Type ( ) ) ; }
public static  String build Cluster Cg Name (  String cluster Name ,  String cg Name ) { return  String . format ( _ STR +  SPLITTER + _ STR , cluster Name , cg Name ) ; }
private void fetch Users Service Cards From Server (  String user Id ) {  Retro Callback retro Callback ; retro Callback = new  Retro Callback ( this ) ; retro Callback . set Request Id (  Api Response Codes .  GET_ USERS_ SERVICES ) ; retro Callback List . add ( retro Callback ) ; m Yelo Api . get Users Service Cards ( user Id , retro Callback ) ; }
public  DView Public Key (  JFrame parent ,  String title ,  Public Key public Key ) throws  Crypto Exception { super ( parent , title ,  Dialog .  Modality Type .  DOCUMENT_ MODAL ) ; this . public Key = public Key ; init Components ( ) ; }
public  List <  Colour Change > sample Conditional Migration Events ( int parent Colour , double parent Height , int child Colour , double child Height , double [ ] m ) {  List <  Colour Change > colour Changes = new  Array List <  Colour Change > ( ) ; int current Colour ; double current Height ; do { colour Changes . clear ( ) ; current Colour = parent Colour ; current Height = parent Height ; do { double total Rate = m [ _ NUM - current Colour ] ; double  U =  Math Utils . next Double ( ) ; if ( ( parent Colour != child Colour ) && ( colour Changes . size ( ) == _ NUM ) ) { double min U =  Math . exp ( - total Rate * ( parent Height - child Height ) ) ;  U = min U +  U * ( _ NUM - min U ) ; } double time = -  Math . log (  U ) / total Rate ; current Height -= time ; if ( current Height > child Height ) { current Colour = _ NUM - current Colour ; colour Changes . add ( new  Colour Change ( current Height , current Colour ) ) ; } } while ( current Height > child Height ) ; } while ( current Colour != child Colour ) ; reverse Colour Change List ( colour Changes , parent Colour ) ; return colour Changes ; }
private boolean exists (  Object obj ) { if ( obj == null ) { return _ BOOL ; } if ( obj instanceof  String &&  String Utils . is Empty ( (  String ) obj ) ) { return _ BOOL ; } return _ BOOL ; }
@  Deprecated public void write ( byte b [ ] , int off , int len ) { if ( len < _ NUM ) throw new  Array Index Out Of Bounds Exception ( len ) ; for ( int i = _ NUM ; i < len ; ++ i ) write ( b [ off + i ] ) ; }
public void remove Operator From Selection (  Operator selected Operator ) {  List <  Operator > new List = new  Array List < > ( get Selected Operators ( ) ) ; new List . remove ( selected Operator ) ; this . selected Operators =  Collections . unmodifiable List ( new List ) ; }
public synchronized void remove Property Change Listener (  Property Change Listener listener ) { listener List . remove ( listener ) ; }
public static void open Share Dialog (  Context context ,  String title , @  Suppress Warnings ( _ STR )  String uri ,  String share Text ,  String share Subject ) {  Intent share = new  Intent (  Intent .  ACTION_ SEND ) ; share . set Type ( _ STR ) ; share . put Extra (  Intent .  EXTRA_ TEXT , share Text ) ; share . put Extra (  Intent .  EXTRA_ SUBJECT , share Subject ) ; if ( !  Text Utils . is Empty ( uri ) ) { share . set Type ( _ STR ) ; share . put Extra (  Intent .  EXTRA_ STREAM ,  Uri . parse ( uri ) ) ; } context . start Activity (  Intent . create Chooser ( share , title ) ) ; }
@  Caller Sensitive public static <  U >  Atomic Integer Field Updater <  U > new Updater (  Class <  U > tclass ,  String field Name ) { return new  Atomic Integer Field Updater Impl <  U > ( tclass , field Name ,  Reflection . get Caller Class ( ) ) ; }
void purge ( int n , int ll , double [ ] r , double [ ] q , double [ ] ra , double [ ] qa , double [ ] wrk , double [ ] eta , double [ ] oldeta , int step , double [ ] rnmp , double tol ) { double t , tq , tr , reps1 ; double rnm = rnmp [ _ NUM ] ; int k , iteration , i ; boolean flag ; if ( step < ll + _ NUM ) return ; k = svd_idamax ( step - ( ll + _ NUM ) , eta , ll , _ NUM ) + ll ; if (  Math . abs ( eta [ k ] ) > reps ) { reps1 = eps1 / reps ; iteration = _ NUM ; flag = _ BOOL ; while ( iteration < _ NUM && flag ) { if ( rnm > tol ) { tq = _ NUM ; tr = _ NUM ; for ( i = ll ; i < step ; i ++ ) { store ( n ,  RETRQ , i , wrk ) ; t = - svd_ddot ( n , qa , _ NUM , wrk , _ NUM ) ; tq +=  Math . abs ( t ) ; svd_daxpy ( n , t , wrk , _ NUM , q , _ NUM ) ; t = - svd_ddot ( n , ra , _ NUM , wrk , _ NUM ) ; tr +=  Math . abs ( t ) ; svd_daxpy ( n , t , wrk , _ NUM , r , _ NUM ) ; } svd_dcopy ( n , q , _ NUM , qa , _ NUM ) ; t = - svd_ddot ( n , r , _ NUM , qa , _ NUM ) ; tr +=  Math . abs ( t ) ; svd_daxpy ( n , t , q , _ NUM , r , _ NUM ) ; svd_dcopy ( n , r , _ NUM , ra , _ NUM ) ; rnm =  Math . sqrt ( svd_ddot ( n , ra , _ NUM , r , _ NUM ) ) ; if ( tq <= reps1 && tr <= reps1 * rnm ) flag = _ BOOL ; } iteration ++ ; } for ( i = ll ; i <= step ; i ++ ) { eta [ i ] = eps1 ; oldeta [ i ] = eps1 ; } } rnmp [ _ NUM ] = rnm ; return ; }
private static  Pair <  String ,  String > pre Indexed LSR ( final long offset , final  ITranslation Environment environment , final  List <  Reil Instruction > instructions , final  String register Node Value1 , final  String register Node Value2 , final  String immediate Node Value ) { final  String address = environment . get Next Variable String ( ) ; final  String tmp Var1 = environment . get Next Variable String ( ) ; final  String tmp Var2 = environment . get Next Variable String ( ) ; final  String index = environment . get Next Variable String ( ) ; long base Offset = offset ; instructions . add (  Reil Helpers . create Bsh ( base Offset ++ , dw , register Node Value2 , dw , _ STR + immediate Node Value , qw , tmp Var1 ) ) ; instructions . add (  Reil Helpers . create And ( base Offset ++ , qw , tmp Var1 , dw , d Word Bit Mask , dw , index ) ) ; instructions . add (  Reil Helpers . create Add ( base Offset ++ , dw , register Node Value1 , dw , index , dw , tmp Var2 ) ) ; instructions . add (  Reil Helpers . create And ( base Offset ++ , dw , tmp Var2 , dw , d Word Bit Mask , dw , address ) ) ; instructions . add (  Reil Helpers . create Str ( base Offset ++ , dw , address , dw , register Node Value1 ) ) ; return new  Pair <  String ,  String > ( address , register Node Value1 ) ; }
@  Override public final  K acquire ( ) {  K ctx = null ;  Reference <  K > ref = null ; while ( ( ctx == null ) && ( ( ref = ctx Queue . poll ( ) ) != null ) ) { ctx = ref . get ( ) ; } if ( ctx == null ) { ctx = new Context ( ) ; ctx . usage =  USAGE_ CLQ ; } return ctx ; }
public final int last_common_layer (  Brd Item p_other ) { int max_first_layer =  Math . max ( first_layer ( ) , p_other . first_layer ( ) ) ; int min_last_layer =  Math . min ( last_layer ( ) , p_other . last_layer ( ) ) ; if ( max_first_layer > min_last_layer ) return - _ NUM ; return min_last_layer ; }
public  Item Stack add Item (  Item Stack drive ,  Item Stack item ) { if ( get Max Kilobits ( drive ) == - _ NUM ) { if ( get Partitioning Mode ( drive ) ==  Partitioning Mode .  NONE || find Data Index For Prototype ( drive , create Prototype ( item ) ) != - _ NUM ) { item . stack Size = _ NUM ; return null ; } else { return item ; } } int bits Free = get Kilobits Free For ( drive , item ) ; int amount Taken =  Math . min ( item . stack Size , bits Free ) ; int current = get Amount Stored ( drive , item ) ; if ( amount Taken > _ NUM ) { set Amount Stored ( drive , item , current + amount Taken ) ; item . stack Size -= amount Taken ; mark Dirty ( drive ) ; } if ( item . stack Size <= _ NUM ) { return null ; } else { return item ; } }
private static void extract Directive (  String key , byte [ ] value ,  String [ ] key Table , byte [ ] [ ] value Table ,  List < byte [ ] > realm Choices , int realm Index ) throws  Sasl Exception { for ( int i = _ NUM ; i < key Table . length ; i ++ ) { if ( key . equals Ignore Case ( key Table [ i ] ) ) { if ( value Table [ i ] == null ) { value Table [ i ] = value ; if ( logger . is Loggable (  Level .  FINE ) ) { logger . log (  Level .  FINE , _ STR , new  Object [ ] { key Table [ i ] , new  String ( value Table [ i ] ) } ) ; } } else if ( realm Choices != null && i == realm Index ) { if ( realm Choices . is Empty ( ) ) { realm Choices . add ( value Table [ i ] ) ; } realm Choices . add ( value ) ; } else { throw new  Sasl Exception ( _ STR + key + _ STR + new  String ( value ) ) ; } break ; } } }
public void add Item (  Artist artist ) { if ( artist == null ) throw new  Null Pointer Exception ( _ STR ) ; artists . add ( artist ) ; notify Item Inserted ( get Item Count ( ) - _ NUM ) ; }
protected void process Get Command (  String cmd ) throws  IOException {  String location = cmd . substring ( _ NUM ) ; int location End = location . index Of ( _ STR ) ; location = location . substring ( _ NUM , location End ) ;  String content Type ; if ( location . ends With ( _ STR ) || location . ends With ( _ STR ) ) { content Type =  CONTENT_ GIF ; } else if ( location . ends With ( _ STR ) || location . ends With ( _ STR ) || location . ends With ( _ STR ) || location . ends With ( _ STR ) ) { content Type =  CONTENT_ HTML ; } else if ( location . ends With ( _ STR ) || location . ends With ( _ STR ) || location . ends With ( _ STR ) || location . ends With ( _ STR ) ) { content Type =  CONTENT_ JPEG ; } else if ( location . ends With ( _ STR ) || location . ends With ( _ STR ) ) { content Type =  CONTENT_ MOV ; } else if ( location . index Of ( _ STR ) != - _ NUM ) { content Type = null ; } else { content Type =  CONTENT_ PLAIN ; }  Http Request Event event = server . fire Http Request Event ( location , out ) ; if ( event . is Writer Used ( ) ) {  Writer writer = event . get Writer ( ) ;  String result = writer . to String ( ) ; write Http Response ( out , content Type , result ) ; } out . flush ( ) ; close ( ) ; }
public static void store Location (  Context context ,  Lat Lng location ) {  Shared Preferences prefs =  Preference Manager . get Default Shared Preferences ( context ) ;  Shared Preferences .  Editor editor = prefs . edit ( ) ; editor . put Long (  PREFERENCES_ LAT ,  Double . double To Raw Long Bits ( location . latitude ) ) ; editor . put Long (  PREFERENCES_ LNG ,  Double . double To Raw Long Bits ( location . longitude ) ) ; editor . apply ( ) ; }
public void encode (  Output Stream out ) throws  IOException {  Der Output Stream tmp = new  Der Output Stream ( ) ; if ( this . extension Value == null ) { this . extension Id =  PKIXExtensions .  Name Constraints_ Id ; this . critical = _ BOOL ; encode This ( ) ; } super . encode ( tmp ) ; out . write ( tmp . to Byte Array ( ) ) ; }
public  Driver Task create Volumes (  List <  Storage Volume > volumes ,  Storage Capabilities storage Capabilities ) {  Driver Task task = new  Dell SCDriver Task ( _ STR ) ;  String Builder err Buffer = new  String Builder ( ) ; int volumes Created = _ NUM ; for (  Storage Volume volume : volumes ) {  LOG . debug ( _ STR , volume . get Display Name ( ) , volume . get Storage System Id ( ) ) ;  String ssn = volume . get Storage System Id ( ) ; try {  Storage Center API api = connection Manager . get Connection ( ssn ) ;  Sc Volume sc Vol = api . create Volume ( ssn , volume . get Display Name ( ) , volume . get Storage Pool Id ( ) ,  Size Util . byte To Meg ( volume . get Requested Capacity ( ) ) , volume . get Consistency Group ( ) ) ; volume . set Provisioned Capacity (  Size Util . size Str To Bytes ( sc Vol . configured Size ) ) ; volume . set Allocated Capacity ( _ NUM ) ; volume . set Wwn ( sc Vol . device Id ) ; volume . set Native Id ( sc Vol . instance Id ) ; volume . set Device Label ( sc Vol . name ) ; volume . set Access Status (  Access Status .  READ_ WRITE ) ; volumes Created ++ ;  LOG . info ( _ STR , sc Vol . name ) ; } catch (  Storage Center APIException |  Dell SCDriver Exception dex ) {  String error =  String . format ( _ STR , volume . get Display Name ( ) , dex ) ;  LOG . error ( error ) ; err Buffer . append (  String . format ( _ STR , error ) ) ; } } task . set Message ( err Buffer . to String ( ) ) ; if ( volumes Created == volumes . size ( ) ) { task . set Status (  Task Status .  READY ) ; } else if ( volumes Created == _ NUM ) { task . set Status (  Task Status .  FAILED ) ; } else { task . set Status (  Task Status .  PARTIALLY_ FAILED ) ; } return task ; }
public void create Project Async (  String tenant Id ,  Project Create Spec project Create Spec , final  Future Callback <  Task > response Callback ) throws  IOException {  String path =  String . format ( _ STR , get Base Path ( ) , tenant Id ) ; create Object Async ( path , serialize Object As Json ( project Create Spec ) , response Callback ) ; }
public int int Value ( ) { return value ; }
public static void write Unsafe (  Packet Output Stream out ,  Input Stream is , boolean no Backslash Escapes ) throws  IOException { out . write Unsafe (  QUOTE ) ; byte [ ] buffer = new byte [ _ NUM ] ; int len ; while ( ( len = is . read ( buffer ) ) >= _ NUM ) { write Bytes Escaped Unsafe ( out , buffer , len , no Backslash Escapes ) ; } out . write Unsafe (  QUOTE ) ; }
public void position ( final long position ) throws  IOException { this . position =  Math . min ( position , length ( ) ) ; }
protected byte [ ] parse Bytes ( ) throws  IOException {  Byte Array Output Stream bos = new  Byte Array Output Stream ( ) ; parse Bytes ( bos ) ; return bos . to Byte Array ( ) ; }
protected boolean run Test If Sys Prop Defined (  String prop Name ) {  String prop =  System . get Property ( prop Name ) ; return ( prop != null ) && ( prop . length ( ) > _ NUM ) ; }
public static <  T > int compare (  Comparable <  T > object1 ,  T object2 ) { if ( ( null != object1 ) && ( null != object2 ) ) { return object1 . compare To ( object2 ) ; } else if ( null != object1 ) { return _ NUM ; } else if ( null != object2 ) { return - _ NUM ; } else { return _ NUM ; } }
protected void pre Collection ( ) { }
private void log OData Perf (  String query , long delta_time ) {  LOGGER . debug ( _ STR + get Id ( ) + _ STR + query + _ STR + delta_time + _ STR ) ; }
public static  Object convert String To Wrapper (  String str ,  Class < ? > wrapper ) { log . trace ( _ STR , str , wrapper ) ; if ( wrapper . equals (  String . class ) ) { return str ; } else if ( wrapper . equals (  Boolean . class ) ) { return  Boolean . value Of ( str ) ; } else if ( wrapper . equals (  Double . class ) ) { return  Double . value Of ( str ) ; } else if ( wrapper . equals (  Long . class ) ) { return  Long . value Of ( str ) ; } else if ( wrapper . equals (  Float . class ) ) { return  Float . value Of ( str ) ; } else if ( wrapper . equals (  Integer . class ) ) { return  Integer . value Of ( str ) ; } else if ( wrapper . equals (  Short . class ) ) { return  Short . value Of ( str ) ; } else if ( wrapper . equals (  Byte . class ) ) { return  Byte . value Of ( str ) ; } return null ; }
public static void send SLORequests To Other Participants (  String tenant ,  Logout State logout State ) throws  IOException { log . info ( _ STR ) ;  Locale locale = logout State . get Locale ( ) ;  Http Servlet Response response = logout State . get Response ( ) ;  Validate . not Null ( response ) ;  Collection <  String > saml Request Urls = logout State . generate Request Urls For Tenant ( tenant , logout State . get Message Source ( ) , locale ) ; if ( saml Request Urls == null ) return ; for (  String request Url : saml Request Urls ) { log . info ( _ STR + request Url ) ; if ( request Url != null ) {  Throwable exception = null ; try { send SLORequest To Other Participant ( request Url ) ; } catch (  URISyntax Exception e ) { exception = e ; } catch (  IOException e ) { exception = e ; } catch (  Key Management Exception e ) { exception = e ; } catch (  No Such Algorithm Exception e ) { exception = e ; } catch (  Key Store Exception e ) { exception = e ; } if ( exception != null ) { log . error ( _ STR + request Url , exception ) ; } } else {  Saml Service Impl . send Logout Error ( locale , response , logout State , logout State . get Message Source ( ) ) ; } } }
public static void assert Label (  String name ,  String text ) { if ( verbose ) { log ( _ STR + name + _ STR + text + _ STR ) ; }  Label l = (  Label ) find By Name ( name ) ; assert Bool ( l != null , _ STR + text ) ; assert Bool ( text == l . get Text ( ) || text . equals ( l . get Text ( ) ) , name + _ STR + text ) ; }
public static boolean is Equivalent (  Array List <  Path Parser .  Path Data Node > original ,  Array List <  Path Parser .  Path Data Node > alternative ) { int inner Start = _ NUM ; for (  Path Parser .  Path Data Node o : original ) { boolean found = _ BOOL ; for ( int i = inner Start ; i < alternative . size ( ) && ! found ; i ++ ) {  Path Parser .  Path Data Node n = alternative . get ( i ) ; if ( ( o . type == n . type &&  Arrays . equals ( o . params , n . params ) ) || ( ( o . type == _ STR || o . type == _ STR ) && n . type == _ STR ) ) { found = _ BOOL ; inner Start = i + _ NUM ; } } if ( ! found ) return _ BOOL ; } return _ BOOL ; }
private  Stream Tokenizer make Arff Tokenizer (  Buffered Reader br ) {  Stream Tokenizer tokenizer = new  Stream Tokenizer ( br ) ; { tokenizer . reset Syntax ( ) ; tokenizer . whitespace Chars ( _ NUM , _ STR ) ; tokenizer . ordinary Chars ( _ STR , _ STR ) ; tokenizer . ordinary Char ( _ STR ) ; tokenizer . ordinary Char ( _ STR ) ; tokenizer . word Chars ( _ STR + _ NUM , _ STR ) ; tokenizer . whitespace Chars ( _ STR , _ STR ) ; tokenizer . comment Char ( _ STR ) ; tokenizer . quote Char ( _ STR ) ; tokenizer . quote Char ( _ STR ) ; tokenizer . ordinary Char ( _ STR ) ; tokenizer . ordinary Char ( _ STR ) ; tokenizer . eol Is Significant ( _ BOOL ) ; } return tokenizer ; }
protected void close All Activities ( ) throws  Exception { try { for ( int i = _ NUM ; i < _ NUM ; i ++ ) { press Back ( ) ;  Thread . sleep ( _ NUM ) ; } } catch (  No Activity Resumed Exception |  Interrupted Exception e ) { } }
static  String check Valid Data ( final  String data ) {  String temp Data = data ; if ( temp Data == null || temp Data . length ( ) == _ NUM ) { temp Data =  Easy Device Info . not Found Val ; } return temp Data ; }
@  Override public boolean lock ( ) { try { if ( !  File Factory . is File Exist ( location ,  File Factory . get File Type ( tmp Path ) ) ) {  File Factory . mkdirs ( location ,  File Factory . get File Type ( tmp Path ) ) ; } lock File Path = location +  Carbon Common Constants .  FILE_ SEPARATOR + lock File ; if ( !  File Factory . is File Exist ( lock File Path ,  File Factory . get File Type ( location ) ) ) {  File Factory . create New Lock File ( lock File Path ,  File Factory . get File Type ( location ) ) ; } file Output Stream = new  File Output Stream ( lock File Path ) ; channel = file Output Stream . get Channel ( ) ; try { file Lock = channel . try Lock ( ) ; } catch (  Overlapping File Lock Exception e ) { return _ BOOL ; } if ( null != file Lock ) { return _ BOOL ; } else { return _ BOOL ; } } catch (  IOException e ) { return _ BOOL ; } }
public  Script add Script ( final  Script Details script Details ) { final  File script File = new  File ( script Details . get File ( ) ) ; final  Script script = new  Script ( ) ; create File Based Script ( script , script File , script Details ) ; logger . info ( _ STR , script . get Name ( ) , script File . get Absolute Path ( ) ) ; scripts . put ( script File . get Absolute Path ( ) , script ) ; return script ; }
public void enable (  Rich Formatter Feature feature ) { features . add ( feature ) ; }
public void add Event Listener (  ZWave Event Listener event Listener ) { synchronized ( zwave Event Listeners ) { if ( zwave Event Listeners . contains ( event Listener ) ) { logger . debug ( _ STR , event Listener ) ; return ; } zwave Event Listeners . add ( event Listener ) ; } }
protected long current Time ( ) { return  System . current Time Millis ( ) ; }
public  Change Set add All To Collection (  String path ,  Serializable ... new Items ) { return add All To Collection ( path ,  Arrays . as List ( new Items ) ) ; }
public static  String quote (  String name ) { return  JVMModule Util . quote ( name ) ; }
public  Trigger perform (  Table Statement ... statements ) {  Collections . add All ( this . statements , statements ) ; return this ; }
public static boolean is Valid Import String (  String s ) { if ( s . equals ( _ STR ) ) return _ BOOL ; boolean valid = _ BOOL ;  String t = s ; int index = t . index Of ( _ STR ) ; if ( index != - _ NUM ) { if ( index == t . length ( ) - _ NUM ) { if ( index - _ NUM >= _ NUM ) { valid = t . char At ( index - _ NUM ) == _ STR ; t = t . substring ( _ NUM , t . length ( ) - _ NUM ) ; } } else return _ BOOL ; } if ( valid ) {  String [ ] java Ids = t . split ( _ STR , t . length ( ) + _ NUM ) ; for (  String java Id : java Ids ) valid &=  Source Version . is Identifier ( java Id ) ; } return valid ; }
@  HLEFunction ( nid = _ NUM , version = _ NUM ) public int sce Rtc Get Tick (  Sce Psp Date Time time ,  TPointer64 ticks Addr ) {  Calendar cal = new  Gregorian Calendar ( time . year , time . month - _ NUM , time . day , time . hour , time . minute , time . second ) ; cal . set (  Calendar .  MILLISECOND , time . microsecond / _ NUM ) ; cal . set Time Zone (  Sce Psp Date Time .  GMT ) ; long ticks = rtc Magic Offset + ( cal . get Time In Millis ( ) * _ NUM ) + ( time . microsecond % _ NUM ) ; ticks Addr . set Value ( ticks ) ; if ( log . is Debug Enabled ( ) ) { log . debug (  String . format ( _ STR , ticks ) ) ; } return _ NUM ; }
private void populate Nav Drawer ( ) { m Nav Drawer Items . clear ( ) ; m Nav Drawer Items . add (  NAVDRAWER_ ITEM_ HOME ) ; m Nav Drawer Items . add (  NAVDRAWER_ ITEM_ WEBVIEW ) ; m Nav Drawer Items . add (  NAVDRAWER_ ITEM_ TSTB ) ; m Nav Drawer Items . add (  NAVDRAWER_ ITEM_ VOICE_ COMMANDS ) ; m Nav Drawer Items . add (  NAVDRAWER_ ITEM_ PALETTE ) ; m Nav Drawer Items . add (  NAVDRAWER_ ITEM_ SEPARATOR_ SPECIAL ) ; m Nav Drawer Items . add (  NAVDRAWER_ ITEM_ ABOUT ) ; m Nav Drawer Items . add (  NAVDRAWER_ ITEM_ BUG_ REPORT ) ; m Nav Drawer Items . add (  NAVDRAWER_ ITEM_ REQUEST ) ; create Nav Drawer Items ( ) ; }
void bind If Not Bound (  String mod Name ,  Module Pointer mod Pointer ) { if ( context . get ( mod Name ) == null ) context . put ( mod Name , mod Pointer ) ; }
public  String replace ( char old Char , char new Char ) { int index = index Of ( old Char , _ NUM ) ; if ( index == - _ NUM ) { return this ; } char [ ] buffer = new char [ count ] ;  System . arraycopy ( value , offset , buffer , _ NUM , count ) ; do { buffer [ index ++ ] = new Char ; } while ( ( index = index Of ( old Char , index ) ) != - _ NUM ) ; return new  String ( _ NUM , count , buffer ) ; }
public static byte [ ] values (  Byte [ ] array ) { byte [ ] dest = new byte [ array . length ] ; for ( int i = _ NUM ; i < array . length ; i ++ ) {  Byte v = array [ i ] ; if ( v != null ) { dest [ i ] = v . byte Value ( ) ; } } return dest ; }
public void audit Config (  Operation Type Enum audit Type ,  String operational Status ,  String description ,  Object ... descparams ) { _audit Mgr . record Audit Log ( null , null ,  EVENT_ SERVICE_ TYPE , audit Type ,  System . current Time Millis ( ) , operational Status , description , descparams ) ; }
public static double mean ( double [ ] data , int start Index , int end Index ) { double mean = _ NUM ; int total = _ NUM ; start Index =  Math . max ( start Index , _ NUM ) ; start Index =  Math . min ( start Index , data . length - _ NUM ) ; end Index =  Math . max ( end Index , _ NUM ) ; end Index =  Math . min ( end Index , data . length - _ NUM ) ; if ( start Index > end Index ) start Index = end Index ; for ( int i = start Index ; i <= end Index ; i ++ ) { if (  Double . is Na N ( data [ i ] ) ) throw new  Illegal Argument Exception ( _ STR ) ; mean += data [ i ] ; total ++ ; } mean /= total ; return mean ; }
public void add Elapsed Time From ( long start Time ) { add (  System . nano Time ( ) - start Time ) ; }
public  Media Types merge ( final  Media Types types ) { final  Sorted Set <  Media Type > set = new  Tree Set < > ( ) ; set . add All ( this . list ) ; set . add All ( types . list ) ; return new  Media Types ( set ) ; }
public void paint Value (  Graphics g ,  Rectangle box ) {  Color old Color = g . get Color ( ) ;  Font old Font = g . get Font ( ) ; g . set Color (  Color . blue ) ; g . set Font ( new  Font ( old Font . get Font Name ( ) ,  Font .  BOLD , old Font . get Size ( ) ) ) ; g . draw Rect ( box . x - _ NUM , box . y + _ NUM , box . width - _ NUM , box . height - _ NUM ) ; g . set Color (  Color . white ) ; g . draw String ( _ STR , box . x + _ NUM , box . y + box . height / _ NUM + _ NUM ) ; g . set Font ( old Font ) ; g . set Color ( old Color ) ; }
public int [ ] value Array ( int [ ] array ) { if ( array == null || array . length != size ( ) ) { array = new int [ count ] ; }  System . arraycopy ( values , _ NUM , array , _ NUM , count ) ; return array ; }
public void test Invoke Any2 ( ) throws  Throwable {  Executor Service e = new  Fork Join Pool ( _ NUM ) ;  Pool Cleaner cleaner = null ; try { cleaner = cleaner ( e ) ; try { e . invoke Any ( new  Array List <  Callable <  String > > ( ) ) ; should Throw ( ) ; } catch (  Illegal Argument Exception success ) { } } finally { if ( cleaner != null ) { cleaner . close ( ) ; } } }
public static void ensure Directory (  String ... file Paths ) { if ( file Paths != null ) {  File file ; for (  String file Path : file Paths ) { file = new  File ( file Path ) ; if ( file . exists ( ) && ! file . is Directory ( ) ) { throw new  Illegal Argument Exception ( _ STR + file . get Absolute Path ( ) ) ; } else if ( ! file . exists ( ) ) { if ( ! file . mkdirs ( ) ) { throw new  Illegal State Exception ( _ STR + file . get Absolute Path ( ) ) ; } } } } }
@  Override public boolean equals (  Object obj ) { if ( obj == this ) { return _ BOOL ; } if ( ! ( obj instanceof  Text Title ) ) { return _ BOOL ; }  Text Title that = (  Text Title ) obj ; if ( !  Object Utilities . equal ( this . text , that . text ) ) { return _ BOOL ; } if ( !  Object Utilities . equal ( this . font , that . font ) ) { return _ BOOL ; } if ( !  Paint Utilities . equal ( this . paint , that . paint ) ) { return _ BOOL ; } if ( this . text Alignment != that . text Alignment ) { return _ BOOL ; } if ( !  Paint Utilities . equal ( this . background Paint , that . background Paint ) ) { return _ BOOL ; } if ( this . maximum Lines To Display != that . maximum Lines To Display ) { return _ BOOL ; } if ( this . expand To Fit Space != that . expand To Fit Space ) { return _ BOOL ; } if ( !  Object Utilities . equal ( this . tool Tip Text , that . tool Tip Text ) ) { return _ BOOL ; } if ( !  Object Utilities . equal ( this . url Text , that . url Text ) ) { return _ BOOL ; } return super . equals ( obj ) ; }
private void parse Unit (  Element unit Node ,  Vector <  Entity > list ) {  Node List nl = unit Node . get Child Nodes ( ) ; for ( int i = _ NUM ; i < nl . get Length ( ) ; i ++ ) {  Node curr Node = nl . item ( i ) ; if ( curr Node . get Parent Node ( ) != unit Node ) { continue ; } int node Type = curr Node . get Node Type ( ) ; if ( node Type ==  Node .  ELEMENT_ NODE ) {  String node Name = curr Node . get Node Name ( ) ; if ( node Name . equals Ignore Case (  ENTITY ) ) { parse Entity ( (  Element ) curr Node , list ) ; } else if ( node Name . equals Ignore Case (  PILOT ) ) { parse Pilot ( (  Element ) curr Node ) ; } } else { continue ; } } }
public synchronized  Combo Box <  V > remote Item ( int index ) { items . remove ( index ) ; if ( index < selected Index ) { set Selected Index ( selected Index - _ NUM ) ; } else if ( index == selected Index ) { set Selected Index ( - _ NUM ) ; } invalidate ( ) ; return this ; }
public int size ( ) { return count . get ( ) ; }
public void check Permission (  Object object ,  Namespace Permission Enum [ ] permissions ) {  List <  Access Denied Exception > access Denied Exceptions = new  Array List < > ( ) ; check Permission ( object , permissions , access Denied Exceptions ) ; if ( ! access Denied Exceptions . is Empty ( ) ) { throw get Access Denied Exception ( access Denied Exceptions ) ; } }
private static  Intent create Call Activity Intent (  Context context ,  URLSpan [ ] url Spans ) {  Telephony Manager tm = (  Telephony Manager ) context . get System Service (  Context .  TELEPHONY_ SERVICE ) ; if ( tm . get Phone Type ( ) ==  Telephony Manager .  PHONE_ TYPE_ NONE ) { return null ; } for ( int span_i = _ NUM ; span_i < url Spans . length ; span_i ++ ) {  URLSpan url Span = url Spans [ span_i ] ;  String url String = url Span . get URL ( ) ; if ( url String . starts With (  TEL_ PREFIX ) ) {  Intent call Intent = new  Intent (  Intent .  ACTION_ DIAL ,  Uri . parse ( url String ) ) ; call Intent . add Flags (  Intent .  FLAG_ ACTIVITY_ NEW_ TASK ) ; return call Intent ; } } return null ; }
public static  Property Filter value Of (  String filter String ) { if ( filter String == null || filter String . length ( ) == _ NUM ||  ALL . equals ( filter String = filter String . trim ( ) ) ) { return  ALL_ FILTER ; } else if ( filter String . equals Ignore Case (  NONE ) ) { return  NONE_ FILTER ; } return new  Property Filter ( filter String ) ; }
private  String pre Process Signature (  String signature ) { int index ; if ( ( index = signature . index Of ( _ STR ) ) > _ NUM ) { signature = signature . substring ( _ NUM , index ) ; } while ( ( index = signature . index Of ( _ STR ) ) > _ NUM ) { signature = signature . substring ( _ NUM , index ) + signature . substring ( index + _ NUM , signature . length ( ) ) ; } return signature ; }
public static void clear Image (  Buffered Image image ,  Color bg Color ) {  Graphics2 D g2d = (  Graphics2 D ) image . get Graphics ( ) ; g2d . set Color ( bg Color ) ; g2d . fill Rect ( _ NUM , _ NUM , image . get Width ( ) , image . get Height ( ) ) ; g2d . dispose ( ) ; }
public static  List <  Long > to Long List ( @  Nullable long [ ] arr ) { if ( arr == null || arr . length == _ NUM ) return  Collections . empty List ( ) ;  List <  Long > ret = new  Array List < > ( arr . length ) ; for ( long l : arr ) ret . add ( l ) ; return ret ; }
public static void show Center Window (  Window parent ,  Window window ) { position Center Window ( parent , window ) ; show Window ( window ) ; }
private static  Array List <  Constraint Widget Container > gather Containers (  Constraint Widget Container container ) {  Array List <  Constraint Widget Container > containers = new  Array List < > ( ) ; for (  Constraint Widget widget : container . get Children ( ) ) { if ( widget instanceof  Constraint Widget Container ) { containers . add ( (  Constraint Widget Container ) widget ) ; } } return containers ; }
public final void print Quoted Symbol (  Char Sequence text ) throws  IOException { if ( text == null ) { append Ascii ( _ STR ) ; } else if ( text . length ( ) == _ NUM ) { throw new  Empty Symbol Exception ( ) ; } else { append Ascii ( _ STR ) ; print Code Points ( text ,  SYMBOL_ ESCAPE_ CODES ) ; append Ascii ( _ STR ) ; } }
@  Override public  String to String ( ) {  Map <  Value ,  Double > sorted Table =  Inference Utils . get NBest ( table ,  Math . max ( table . size ( ) , _ NUM ) ) ;  String str = _ STR ; for (  Entry <  Value ,  Double > entry : sorted Table . entry Set ( ) ) {  String prob =  String Utils . get Short Form ( entry . get Value ( ) ) ; str += _ STR + variable + _ STR + entry . get Key ( ) + _ STR + prob + _ STR ; } return ( str . length ( ) > _ NUM ) ? str . substring ( _ NUM , str . length ( ) - _ NUM ) : str ; }
private void update Border ( ) { m_table Border . set Title ( get Border Text ( ) ) ; update UI ( ) ; }
public static  Type [ ] to Types (  Class < ? > [ ] classes ) { if ( classes == null || classes . length == _ NUM ) return new  Type [ _ NUM ] ;  Type [ ] types = new  Type [ classes . length ] ; for ( int i = _ NUM ; i < classes . length ; i ++ ) { types [ i ] =  Type . get Type ( classes [ i ] ) ; } return types ; }
@  Override public void reset References ( ) { _refs . clear ( ) ; }
public  Core Attributes Model Impl (  Http Servlet Request req ,  String service Name ,  Map map ) throws  AMConsole Exception { super ( req , service Name , map ) ; current Realm = (  String ) map . get (  AMAdmin Constants .  CURRENT_ REALM ) ; if ( current Realm == null ) { debug . warning ( _ STR ) ; current Realm = _ STR ; } }
protected  Date Time Data parse (  String str ) throws  Schema Date Time Exception {  Date Time Data date = new  Date Time Data ( str , this ) ; int len = str . length ( ) ; date . year =  YEAR ; if ( str . char At ( _ NUM ) != _ STR || str . char At ( _ NUM ) != _ STR ) { throw new  Schema Date Time Exception ( _ STR + str ) ; } date . month = parse Int ( str , _ NUM , _ NUM ) ; int start = _ NUM ; if ( str . char At ( start ++ ) != _ STR ) { throw new  Schema Date Time Exception ( _ STR + str ) ; } date . day = parse Int ( str , start , start + _ NUM ) ; if (  MONTHDAY_ SIZE < len ) { if ( ! is Next Char UTCSign ( str ,  MONTHDAY_ SIZE , len ) ) { throw new  Schema Date Time Exception ( _ STR + str ) ; } else { get Time Zone ( str , date ,  MONTHDAY_ SIZE , len ) ; } } validate Date Time ( date ) ; save Unnormalized ( date ) ; if ( date . utc != _ NUM && date . utc != _ STR ) { normalize ( date ) ; } date . position = _ NUM ; return date ; }
public int size ( ) { return serial Queue . size ( ) ; }
public  Search Source Builder query (  String query String ) { return query ( query String . get Bytes (  Charsets .  UTF_8 ) ) ; }
@  Override public final void write Char ( int v ) throws  IOException { work [ _ NUM ] = ( byte ) v ; work [ _ NUM ] = ( byte ) ( v > > _ NUM ) ; dis . write ( work , _ NUM , _ NUM ) ; }
final public void println ( int v ) {  Writer out = this . out ; if ( out == null ) return ; print ( v ) ; try { out . write ( _newline , _ NUM , _newline . length ) ; } catch (  IOException e ) { log . log (  Level .  FINE , e . to String ( ) , e ) ; } }
public  Builder add Service (  Action Service service ) { if ( service == null ) { throw new  Illegal Argument Exception ( _ STR ) ; } if ( service . get Supported Annotation Type ( ) == null ) { throw new  Illegal Argument Exception ( _ STR ) ; } services . add ( service ) ; return this ; }
public  Writable Raster create Compatible Writable Raster ( int w , int h ) { if ( w <= _ NUM || h <= _ NUM ) { throw new  Raster Format Exception ( _ STR + ( ( w <= _ NUM ) ? _ STR : _ STR ) ) ; }  Sample Model sm = sample Model . create Compatible Sample Model ( w , h ) ; return new  Byte Component Raster ( sm , new  Point ( _ NUM , _ NUM ) ) ; }
protected void add Error (  String error ) { if ( error != null && error . length ( ) > _ NUM ) { if ( error Message == null ) error Message = _ STR ; else error Message += _ STR ; error Message += error ; } }
public void show Status (  String msg ) { if ( ( msg == null ) || msg . is Empty ( ) ) msg = _ STR ; m_ Label Text . set Text ( msg ) ; }
public  List <  String > extract Tokens (  String query String ) {  List <  String > tokens = new  Array List <  String > ( ) ;  Matcher matcher = token Pattern . matcher ( query String ) ; while ( matcher . find ( ) ) {  String orig Token = matcher . group ( _ NUM ) ; tokens . add ( orig Token ) ; } return tokens ; }
public boolean load Properties (  Properties props ,  URL url ) { try {  Input Stream props In = url . open Stream ( ) ; props . load ( props In ) ; return _ BOOL ; } catch ( java . io .  IOException e ) {  Debug . error ( _ STR + url ) ; return _ BOOL ; } }
public  Builder put (  Properties properties ) { for (  Map .  Entry entry : properties . entry Set ( ) ) { map . put ( (  String ) entry . get Key ( ) , (  String ) entry . get Value ( ) ) ; } return this ; }
private void restart Proximity Browsing ( ) { m_last Shown = new  Hash Set < > ( ) ; final  Collection <  Node Type > selected Nodes =  Selected Visible Filter . filter ( m_graph . get Selected Nodes ( ) ) ; if ( ! selected Nodes . is Empty ( ) ) { final  List <  Node Type > all Nodes =  Graph Helpers . get Nodes ( m_graph ) ; all Nodes . remove All ( selected Nodes ) ; m_graph . show Nodes ( selected Nodes , all Nodes ) ; update Views ( ) ; } }
protected int [ ] determine Indices ( int num Attributes ) throws  Exception { int [ ] result ;  Vector <  Integer > list ; int i ;  String Tokenizer tok ;  String token ;  String [ ] range ; int from ; int to ; list = new  Vector <  Integer > ( ) ; tok = new  String Tokenizer ( m_ New Order Cols , _ STR ) ; while ( tok . has More Tokens ( ) ) { token = tok . next Token ( ) ; if ( token . index Of ( _ STR ) > - _ NUM ) { range = token . split ( _ STR ) ; if ( range . length != _ NUM ) { throw new  Illegal Argument Exception ( _ STR + token + _ STR ) ; } from = determine Index ( range [ _ NUM ] , num Attributes ) ; to = determine Index ( range [ _ NUM ] , num Attributes ) ; if ( from <= to ) { for ( i = from ; i <= to ; i ++ ) { list . add ( i ) ; } } else { for ( i = from ; i >= to ; i -- ) { list . add ( i ) ; } } } else { list . add ( determine Index ( token , num Attributes ) ) ; } } result = new int [ list . size ( ) ] ; for ( i = _ NUM ; i < list . size ( ) ; i ++ ) { result [ i ] = list . get ( i ) ; } return result ; }
private static double distance ( double x1 , double y1 , double x2 , double y2 ) { return  Math . sqrt ( ( y2 - y1 ) * ( y2 - y1 ) + ( x2 - x1 ) * ( x2 - x1 ) ) ; }
private static  Locale strip (  Locale locale ) {  String language = locale . get Language ( ) ;  String country = locale . get Country ( ) ;  String variant = locale . get Variant ( ) ; if ( ! variant . is Empty ( ) ) { variant = _ STR ; } else if ( ! country . is Empty ( ) ) { country = _ STR ; } else if ( ! language . is Empty ( ) ) { language = _ STR ; } else { return null ; } return new  Locale ( language , country , variant ) ; }
protected  String handle Integer (  Result Set rs , int column Index ) throws  SQLException { int i = rs . get Int ( column Index ) ; return rs . was Null ( ) ? _ STR :  Integer . to String ( i ) ; }
@  Override public boolean equals (  Object obj ) { if ( obj == this ) { return _ BOOL ; } if ( obj == null ) { return _ BOOL ; } if ( ! ( get Class ( ) == obj . get Class ( ) ) ) { return _ BOOL ; } return super . equals ( obj ) ; }
public  Single Connection Transaction Manager ( @  Not Null  Connection connection , boolean inside Foreign Transaction ) { this . connection = require Non Null ( connection ) ; current Transaction = inside Foreign Transaction ?  Optional . of ( new  Default Transaction ( connection ) ) :  Optional . empty ( ) ; }
private void create Gui ( final  List <  INavi View > views ) { set Layout ( new  Border Layout ( ) ) ; final  JText Area field = new  JText Area ( _ STR ) ; field . set Editable ( _ BOOL ) ; add ( field ,  Border Layout .  NORTH ) ; m_table = new  JTable ( new  CGraph Selection Table Model ( views ) ) ; m_table . add Mouse Listener ( m_listener ) ; add ( new  JScroll Pane ( m_table ) ,  Border Layout .  CENTER ) ; final  CPanel Two Buttons panel = new  CPanel Two Buttons ( m_listener , _ STR , _ STR ) ; add ( panel ,  Border Layout .  SOUTH ) ; set Size ( _ NUM , _ NUM ) ; }
public static boolean create Folder (  File target Folder ) { if ( target Folder . exists ( ) ) { if ( target Folder . is Directory ( ) ) return _ BOOL ; target Folder . delete ( ) ; } return target Folder . mkdirs ( ) ; }
protected static  String normalize Url Ending (  String link ) { if ( link . index Of ( _ STR ) > - _ NUM ) link = link . substring ( _ NUM , link . index Of ( _ STR ) ) ; if ( link . ends With ( _ STR ) ) link = link . substring ( _ NUM , link . length ( ) - _ NUM ) ; if ( link . ends With ( _ STR ) ) link = link . substring ( _ NUM , link . length ( ) - _ NUM ) ; return link ; }
public static  Reference Detector load Manifest (  Input Stream reference Manifest ) throws  IOException { try ( final  Reference Manifest Parser parser = new  Reference Manifest Parser ( reference Manifest ) ) { parser . parse ( ) ; return parser . get Reference Detector ( ) ; } }
public  Reference Binding find Super Type Originating From ( int well Known Original ID , boolean original Is Class ) { if ( ! ( this instanceof  Reference Binding ) ) return null ;  Reference Binding reference = (  Reference Binding ) this ; if ( reference . id == well Known Original ID || ( original ( ) . id == well Known Original ID ) ) return reference ;  Reference Binding current Type = reference ; if ( original Is Class ) { while ( ( current Type = current Type . superclass ( ) ) != null ) { if ( current Type . id == well Known Original ID ) return current Type ; if ( current Type . original ( ) . id == well Known Original ID ) return current Type ; } return null ; }  Reference Binding [ ] interfaces To Visit = null ; int next Position = _ NUM ; do {  Reference Binding [ ] its Interfaces = current Type . super Interfaces ( ) ; if ( its Interfaces != null && its Interfaces !=  Binding .  NO_ SUPERINTERFACES ) { if ( interfaces To Visit == null ) { interfaces To Visit = its Interfaces ; next Position = interfaces To Visit . length ; } else { int its Length = its Interfaces . length ; if ( next Position + its Length >= interfaces To Visit . length )  System . arraycopy ( interfaces To Visit , _ NUM , interfaces To Visit = new  Reference Binding [ next Position + its Length + _ NUM ] , _ NUM , next Position ) ; next Interface : for ( int a = _ NUM ; a < its Length ; a ++ ) {  Reference Binding next = its Interfaces [ a ] ; for ( int b = _ NUM ; b < next Position ; b ++ ) if ( next == interfaces To Visit [ b ] ) continue next Interface ; interfaces To Visit [ next Position ++ ] = next ; } } } } while ( ( current Type = current Type . superclass ( ) ) != null ) ; for ( int i = _ NUM ; i < next Position ; i ++ ) { current Type = interfaces To Visit [ i ] ; if ( current Type . id == well Known Original ID ) return current Type ; if ( current Type . original ( ) . id == well Known Original ID ) return current Type ;  Reference Binding [ ] its Interfaces = current Type . super Interfaces ( ) ; if ( its Interfaces != null && its Interfaces !=  Binding .  NO_ SUPERINTERFACES ) { int its Length = its Interfaces . length ; if ( next Position + its Length >= interfaces To Visit . length )  System . arraycopy ( interfaces To Visit , _ NUM , interfaces To Visit = new  Reference Binding [ next Position + its Length + _ NUM ] , _ NUM , next Position ) ; next Interface : for ( int a = _ NUM ; a < its Length ; a ++ ) {  Reference Binding next = its Interfaces [ a ] ; for ( int b = _ NUM ; b < next Position ; b ++ ) if ( next == interfaces To Visit [ b ] ) continue next Interface ; interfaces To Visit [ next Position ++ ] = next ; } } } return null ; }
void add Column (  Column column ) { columns . add ( column ) ; }
public  Container remove Child ( @  Non Null  Display Object display Object ) { display Object . disable ( ) ; m Display List . remove ( display Object ) ; return this ; }
static public float angle Between (  PVector v1 ,  PVector v2 ) { if ( v1 . x == _ NUM && v1 . y == _ NUM ) return _ NUM ; if ( v2 . x == _ NUM && v2 . y == _ NUM ) return _ NUM ; double dot = v1 . x * v2 . x + v1 . y * v2 . y + v1 . z * v2 . z ; double v1mag =  Math . sqrt ( v1 . x * v1 . x + v1 . y * v1 . y + v1 . z * v1 . z ) ; double v2mag =  Math . sqrt ( v2 . x * v2 . x + v2 . y * v2 . y + v2 . z * v2 . z ) ; double amt = dot / ( v1mag * v2mag ) ; if ( amt <= - _ NUM ) { return  PConstants .  PI ; } else if ( amt >= _ NUM ) { return _ NUM ; } return ( float )  Math . acos ( amt ) ; }
public void add Listener ( final  IRunning Query Listener l ) { if ( l == null ) throw new  Illegal Argument Exception ( ) ; listeners . add ( l ) ; }
private void build Contact Data ( ) {  Context context = get Application Context ( ) ;  App Contact Service app Contact Service = new  App Contact Service ( context ) ; if ( ! app Contact Service . is Contact Exists ( _ STR ) ) {  List <  Contact > contact List = new  Array List <  Contact > ( ) ;  Contact contact = new  Contact ( ) ; contact . set User Id ( _ STR ) ; contact . set Full Name ( _ STR ) ; contact . set Image URL ( _ STR ) ; contact List . add ( contact ) ;  Contact contact Raj = new  Contact ( ) ; contact Raj . set User Id ( _ STR ) ; contact Raj . set Full Name ( _ STR ) ; contact Raj . set Image URL ( _ STR ) ; contact List . add ( contact Raj ) ;  Contact contact2 = new  Contact ( ) ; contact2 . set User Id ( _ STR ) ; contact2 . set Full Name ( _ STR ) ; contact2 . set Image URL ( _ STR ) ; contact List . add ( contact2 ) ;  Contact contact3 = new  Contact ( ) ; contact3 . set User Id ( _ STR ) ; contact3 . set Full Name ( _ STR ) ; contact3 . set Image URL ( _ STR ) ; contact List . add ( contact3 ) ;  Contact contact4 = new  Contact ( ) ; contact4 . set User Id ( _ STR ) ; contact4 . set Full Name ( _ STR ) ; contact4 . set Image URL ( _ STR ) ; contact List . add ( contact4 ) ;  Contact contact6 = new  Contact ( ) ; contact6 . set User Id ( _ STR ) ; contact6 . set Full Name ( _ STR ) ; contact6 . set Image URL ( _ STR ) ; contact List . add ( contact6 ) ;  Contact contact7 = new  Contact ( ) ; contact7 . set User Id ( _ STR ) ; contact7 . set Full Name ( _ STR ) ; contact7 . set Image URL ( _ STR ) ; contact List . add ( contact7 ) ; app Contact Service . add All ( contact List ) ; } }
@  Nullable public  Grid Cache Mvcc Candidate add Entry (  Grid Dht Cache Entry entry ) throws  Grid Cache Entry Removed Exception ,  Grid Distributed Lock Cancelled Exception { if ( log . is Debug Enabled ( ) ) log . debug ( _ STR + entry ) ; if ( entry == null ) return null ; if ( timed Out ) return null ;  Grid Cache Mvcc Candidate c = entry . add Dht Local ( near Node Id , near Lock Ver , top Ver , thread Id , lock Ver , null , null , timeout , _ BOOL , in Tx ( ) , implicit Single ( ) ) ; if ( c == null && timeout < _ NUM ) { if ( log . is Debug Enabled ( ) ) log . debug ( _ STR + entry ) ; on Failed ( _ BOOL ) ; return null ; } synchronized ( sync ) { entries . add ( c == null || c . reentry ( ) ? null : entry ) ; if ( c != null && ! c . reentry ( ) ) pending Locks . add ( entry . key ( ) ) ; } if ( timed Out ) { entry . remove Lock ( lock Ver ) ; return null ; } return c ; }
protected void add (  Edge edge ) { edges . add ( edge ) ; add ( edge . get Dir Edge ( _ NUM ) ) ; add ( edge . get Dir Edge ( _ NUM ) ) ; }
protected void assert Same Join Order ( final int [ ] expected , final  Test Helper helper ) throws  Exception { assert Same Join Order (  Collections . singleton List ( expected ) , helper ) ; }
public static void delete File ( final  File file ) { delete File ( file , _ BOOL ) ; }
public void delete Group Member (  Gitlab Group group ,  Gitlab User user ) throws  IOException { delete Group Member ( group . get Id ( ) , user . get Id ( ) ) ; }
private synchronized void init Resource Bundle (  String resource Bundle Name ) {  String current = this . resource Bundle Name ; if ( current != null ) { if ( current . equals ( resource Bundle Name ) ) { return ; } else { throw new  Illegal Argument Exception ( _ STR + resource Bundle Name + _ STR + current + _ STR ) ; } } if ( resource Bundle Name != null ) { this . resource Bundle = load Resource Bundle ( resource Bundle Name ) ; this . resource Bundle Name = resource Bundle Name ; } }
@  Override public void increment ( double coord , int val ) { int bin = get Bin Nr ( coord ) ; if ( bin < _ NUM ) { if ( size - bin > data . length ) { int [ ] tmpdata = new int [ grow Size ( data . length , size - bin ) ] ;  System . arraycopy ( data , _ NUM , tmpdata , - bin , size ) ; data = tmpdata ; } else {  System . arraycopy ( data , _ NUM , data , - bin , size ) ;  Arrays . fill ( data , _ NUM , - bin , _ NUM ) ; } data [ _ NUM ] = val ; assert ( data . length >= size - bin ) ; offset -= bin ; size -= bin ; } else if ( bin >= data . length ) { int [ ] tmpdata = new int [ grow Size ( data . length , bin + _ NUM ) ] ;  System . arraycopy ( data , _ NUM , tmpdata , _ NUM , size ) ; tmpdata [ bin ] = val ; data = tmpdata ; size = bin + _ NUM ; max =  Double .  MAX_ VALUE ; } else { if ( bin >= size ) { size = bin + _ NUM ; } data [ bin ] += val ; } }
public  Builder put (  Properties properties ) { for (  Map .  Entry entry : properties . entry Set ( ) ) { map . put ( (  String ) entry . get Key ( ) , (  String ) entry . get Value ( ) ) ; } return this ; }
public static double logpdf ( double x , double mu , double sigma , double xi ) { x = ( x - mu ) / sigma ; if ( x < _ NUM || ( xi < _ NUM && x > - _ NUM / xi ) ) { return  Double .  NEGATIVE_ INFINITY ; } if ( xi == _ NUM ) { return  Double .  POSITIVE_ INFINITY ; } return ( ( xi == - _ NUM ) ? _ NUM :  Math . log ( _ NUM + xi * x ) * ( - _ NUM / xi - _ NUM ) ) -  Math . log ( sigma ) ; }
private static <  T >  Load Result <  T > validate Loaded Plugins ( final  Load Result <  T > result ) { final  Hash Set <  Long > guids = new  Hash Set < > ( ) ; final  Array List <  Pair < com . google . security . zynamics . binnavi . api2 . plugins .  IPlugin <  T > ,  Plugin Status > > validated Plugins = new  Array List < > ( ) ; for ( final  Pair < com . google . security . zynamics . binnavi . api2 . plugins .  IPlugin <  T > ,  Plugin Status > plugin Pair : result . get Loaded Plugins ( ) ) { final com . google . security . zynamics . binnavi . api2 . plugins .  IPlugin <  T > plugin = plugin Pair . first ( ) ; final  String name = plugin . get Name ( ) ; final long guid = plugin . get Guid ( ) ; if ( ( name == null ) && ( guid == _ NUM ) ) { validated Plugins . add ( new  Pair < com . google . security . zynamics . binnavi . api2 . plugins .  IPlugin <  T > ,  Plugin Status > ( plugin ,  Plugin Status .  Invalid Name Guid ) ) ; } else if ( name == null ) { validated Plugins . add ( new  Pair < com . google . security . zynamics . binnavi . api2 . plugins .  IPlugin <  T > ,  Plugin Status > ( plugin ,  Plugin Status .  Invalid Name ) ) ; } else if ( guid == _ NUM ) { validated Plugins . add ( new  Pair < com . google . security . zynamics . binnavi . api2 . plugins .  IPlugin <  T > ,  Plugin Status > ( plugin ,  Plugin Status .  Invalid Guid ) ) ; } else if ( guids . contains ( guid ) ) { validated Plugins . add ( new  Pair < com . google . security . zynamics . binnavi . api2 . plugins .  IPlugin <  T > ,  Plugin Status > ( plugin ,  Plugin Status .  Duplicate Guid ) ) ; } else { validated Plugins . add ( new  Pair < com . google . security . zynamics . binnavi . api2 . plugins .  IPlugin <  T > ,  Plugin Status > ( plugin ,  Plugin Status .  Valid ) ) ; } guids . add ( guid ) ; } return new  Load Result <  T > ( validated Plugins , result . get Failed Plugins ( ) ) ; }
public synchronized void stop ( ) { m Run = _ BOOL ; if ( m Process != null ) { m Process . destroy ( ) ; m Process = null ; } try { m Thread . join ( ) ; } catch (  Interrupted Exception e ) { } m Thread = null ; m Callback = null ; }
public static  Graph Request new Upload Video Request (  Access Token access Token ,  File file ,  Callback callback ) throws  File Not Found Exception {  Parcel File Descriptor descriptor =  Parcel File Descriptor . open ( file ,  Parcel File Descriptor .  MODE_ READ_ ONLY ) ;  Bundle parameters = new  Bundle ( _ NUM ) ; parameters . put Parcelable ( file . get Name ( ) , descriptor ) ; return new  Graph Request ( access Token ,  MY_ VIDEOS , parameters ,  Http Method .  POST , callback ) ; }
Socket create Socket ( ) throws  IOException {  Socket sock ; if ( is Ssl Enabled ( ) ) sock = ssl Sock Factory . create Socket ( ) ; else sock = new  Socket ( ) ; sock . bind ( new  Inet Socket Address ( loc Host , _ NUM ) ) ; sock . set Tcp No Delay ( _ BOOL ) ; return sock ; }
public void destination (  Object destination ) { this . destination =  Objects . require Non Null ( destination ) ; }
@  Override public  Meta Data check For New Meta Data (  Long expected Version ) throws  No Persisted Meta Data Exception {  Meta Data local Meta Data = read Meta Data As Row (  Consistency Level .  ONE ) ; if ( local Meta Data != null && local Meta Data . version ( ) >= expected Version ) { return local Meta Data ; } if ( local Meta Data == null ) { throw new  No Persisted Meta Data Exception ( _ STR + this . elastic Admin Keyspace Name ) ; }  Meta Data quorum Meta Data = read Meta Data As Row ( this . metadata Read CL ) ; if ( quorum Meta Data . version ( ) >= expected Version ) { return quorum Meta Data ; } return null ; }
private static void pipe (  Input Stream source ,  Output Stream dest ) throws  IOException { byte [ ] buf = new byte [ _ NUM ] ; int read = _ NUM ; while ( ( read = source . read ( buf ) ) >= _ NUM ) { if ( null != dest ) dest . write ( buf , _ NUM , read ) ; } if ( null != dest ) dest . flush ( ) ; }
void replace Member (  Relation Member existing ,  Relation Member new Member ) { int idx ; while ( ( idx = members . index Of ( existing ) ) != - _ NUM ) { members . set ( idx , new Member ) ; } }
private static void recalc Font Size ( final float scale , final int rotate , final  Form Object form Object , final  Component cur Comp ) { final int size =  GUIData . get Font Size ( form Object , rotate , scale ) ; final  Font reset Font = cur Comp . get Font ( ) ; final  Font new Font = new  Font ( reset Font . get Font Name ( ) , reset Font . get Style ( ) , size ) ; cur Comp . set Font ( new Font ) ; }
public boolean is Loaded (  String name ) {  Plugin Holder <  T > result = registry . get ( name ) ; if ( result == null ) return _ BOOL ; return result . is Loaded ( ) ; }
@  Override public boolean has Property (  String field Name ,  String value ) {  String [ ] fields = doc . get Values ( field Name ) ; if ( fields != null ) { for (  String field : fields ) { if ( value . equals ( field ) ) { return _ BOOL ; } } } return _ BOOL ; }
public  Repository Changed update Existing Repository (  String repo Name ,  String repo Remote Location ,  String repo User Name ,  String repo Password ,  String repo Locations ,  String repo Branch , boolean use Credentials ) { return null ; }
private void write Root Block ( final boolean is Root Block0 , final  IRoot Block View root Block ) throws  IOException { if ( root Block == null ) throw new  Illegal Argument Exception ( ) ; final long position = is Root Block0 ?  OFFSET_ ROOT_ BLOCK0 :  OFFSET_ ROOT_ BLOCK1 ;  File Channel Utility . write All ( reopener , root Block . as Read Only Buffer ( ) , position ) ; if ( ha Log . is Debug Enabled ( ) ) ha Log . debug ( _ STR + root Block ) ; }
public  Entity List Iterator select List Iterator By Condition (  Delegator delegator ,  Model Entity model Entity ,  Entity Condition where Entity Condition ,  Entity Condition having Entity Condition ,  Collection <  String > fields To Select ,  List <  String > order By ,  Entity Find Options find Options ) throws  Generic Entity Exception { if ( model Entity == null ) { return null ; }  Model View Entity model View Entity = null ; if ( model Entity instanceof  Model View Entity ) { model View Entity = (  Model View Entity ) model Entity ; } if ( find Options == null ) find Options = new  Entity Find Options ( ) ; boolean verbose On =  Debug . verbose On ( ) ; if ( verbose On ) {  Debug . log Verbose ( _ STR + where Entity Condition , module ) ; }  List <  Model Field > select Fields = new  Linked List <  Model Field > ( ) ; if (  Util Validate . is Not Empty ( fields To Select ) ) {  Set <  String > temp Keys = new  Hash Set <  String > ( ) ; temp Keys . add All ( fields To Select ) ;  Set <  String > field Sets To Include = new  Hash Set <  String > ( ) ;  Set <  String > added Fields = new  Hash Set <  String > ( ) ; for (  String field To Select : fields To Select ) { if ( temp Keys . contains ( field To Select ) ) {  Model Field cur Field = model Entity . get Field ( field To Select ) ; if ( cur Field != null ) { field Sets To Include . add ( cur Field . get Field Set ( ) ) ; select Fields . add ( cur Field ) ; temp Keys . remove ( field To Select ) ; added Fields . add ( field To Select ) ; } } } if ( temp Keys . size ( ) > _ NUM ) { throw new  Generic Model Exception ( _ STR + temp Keys . to String ( ) ) ; } field Sets To Include . remove ( _ STR ) ; if ( verbose On ) {  Debug . log Info ( _ STR + model Entity . get Entity Name ( ) + _ STR + field Sets To Include , module ) ; } if (  Util Validate . is Not Empty ( field Sets To Include ) ) {  Iterator <  Model Field > field Iter = model Entity . get Fields Iterator ( ) ;  Set <  String > extra Fields = new  Hash Set <  String > ( ) ;  Set <  String > reason Sets = new  Hash Set <  String > ( ) ; while ( field Iter . has Next ( ) ) {  Model Field cur Field = field Iter . next ( ) ;  String field Set = cur Field . get Field Set ( ) ; if (  Util Validate . is Empty ( field Set ) ) { continue ; } if ( ! field Sets To Include . contains ( field Set ) ) { continue ; }  String field Name = cur Field . get Name ( ) ; if ( added Fields . contains ( field Name ) ) { continue ; } reason Sets . add ( field Set ) ; extra Fields . add ( field Name ) ; added Fields . add ( field Name ) ; select Fields . add ( cur Field ) ; } if ( verbose On ) {  Debug . log Info ( _ STR + model Entity . get Entity Name ( ) + _ STR + extra Fields , module ) ;  Debug . log Info ( _ STR + model Entity . get Entity Name ( ) + _ STR + reason Sets , module ) ; } } } else { select Fields = model Entity . get Fields Unmodifiable ( ) ; }  String Builder sql Buffer = new  String Builder ( _ STR ) ; if ( find Options . get Distinct ( ) ) { sql Buffer . append ( _ STR ) ; } if ( select Fields . size ( ) > _ NUM ) { model Entity . col Name String ( select Fields , sql Buffer , _ STR , _ STR , _ STR , datasource . get Alias View Columns ( ) ) ; } else { sql Buffer . append ( _ STR ) ; }  List <  Entity Condition > view Where Conditions = null ;  List <  Entity Condition > view Having Conditions = null ;  List <  String > view Order By List = null ; if ( model View Entity != null ) { view Where Conditions = new  Linked List <  Entity Condition > ( ) ; view Having Conditions = new  Linked List <  Entity Condition > ( ) ; view Order By List = new  Linked List <  String > ( ) ; model View Entity . populate View Entity Condition Information ( model Field Type Reader , view Where Conditions , view Having Conditions , view Order By List , null ) ; } sql Buffer . append (  Sql Jdbc Util . make From Clause ( model Entity , model Field Type Reader , datasource ) ) ;  List <  Entity Condition Param > where Entity Condition Params = new  Linked List <  Entity Condition Param > ( ) ; make Condition Where String ( sql Buffer , _ STR , model Entity , where Entity Condition , view Where Conditions , where Entity Condition Params ) ; if ( model View Entity != null ) { model View Entity . col Name String ( model View Entity . get Group Bys Copy ( select Fields ) , sql Buffer , _ STR , _ STR , _ STR , _ BOOL ) ; }  List <  Entity Condition Param > having Entity Condition Params = new  Linked List <  Entity Condition Param > ( ) ; make Condition Having String ( sql Buffer , _ STR , model Entity , having Entity Condition , view Having Conditions , having Entity Condition Params ) ;  List <  String > order By Expanded = new  Linked List <  String > ( ) ; if ( order By != null ) { order By Expanded . add All ( order By ) ; } if ( view Order By List != null ) { order By Expanded . add All ( view Order By List ) ; } sql Buffer . append (  Sql Jdbc Util . make Order By Clause ( model Entity , order By Expanded , datasource ) ) ; make Offset String ( sql Buffer , find Options ) ;  String sql = sql Buffer . to String ( ) ;  SQLProcessor sql P = new  SQLProcessor ( delegator , helper Info ) ; sql P . prepare Statement ( sql , find Options . get Specify Type And Concur ( ) , find Options . get Result Set Type ( ) , find Options . get Result Set Concurrency ( ) , find Options . get Fetch Size ( ) , find Options . get Max Rows ( ) ) ; if ( verbose On ) {  Debug . log Verbose ( _ STR + where Entity Condition Params , module ) ; } for (  Entity Condition Param where Entity Condition Param : where Entity Condition Params ) {  Sql Jdbc Util . set Value ( sql P , where Entity Condition Param . get Model Field ( ) , model Entity . get Entity Name ( ) , where Entity Condition Param . get Field Value ( ) , model Field Type Reader ) ; } if ( verbose On ) {  Debug . log Verbose ( _ STR + having Entity Condition Params , module ) ; } for (  Entity Condition Param having Entity Condition Param : having Entity Condition Params ) {  Sql Jdbc Util . set Value ( sql P , having Entity Condition Param . get Model Field ( ) , model Entity . get Entity Name ( ) , having Entity Condition Param . get Field Value ( ) , model Field Type Reader ) ; } long query Start Time = _ NUM ; if (  Debug . timing On ( ) ) { query Start Time =  System . current Time Millis ( ) ; } sql P . execute Query ( ) ; if (  Debug . timing On ( ) ) { long query End Time =  System . current Time Millis ( ) ; long query Total Time = query End Time - query Start Time ; if ( query Total Time > _ NUM ) {  Debug . log Timing ( _ STR + query Total Time + _ STR + _ STR + model Entity . get Entity Name ( ) + _ STR + sql + _ STR + where Entity Condition Params , module ) ; } } return new  Entity List Iterator ( sql P , model Entity , select Fields , model Field Type Reader , this , where Entity Condition , having Entity Condition , find Options . get Distinct ( ) ) ; }
@  Suppress Warnings ( _ STR ) public static  Class < ? extends  Enum < ? > > find Enum Type (  Class < ? > cls ) { if ( cls . get Superclass ( ) !=  Enum . class ) { cls = cls . get Superclass ( ) ; } return (  Class < ? extends  Enum < ? > > ) cls ; }
public  Zone Info Provider (  File file Dir ) throws  IOException { if ( file Dir == null ) { throw new  Illegal Argument Exception ( _ STR ) ; } if ( ! file Dir . exists ( ) ) { throw new  IOException ( _ STR + file Dir ) ; } if ( ! file Dir . is Directory ( ) ) { throw new  IOException ( _ STR + file Dir ) ; } i File Dir = file Dir ; i Resource Path = null ; i Loader = null ; i Zone Info Map = load Zone Info Map ( open Resource ( _ STR ) ) ; }
public final boolean skip Any (  Char Set char Set ,  Char Sequence csq ) { int i = index ; int n = csq . length ( ) ; for ( ; ( i < n ) && char Set . contains ( csq . char At ( i ) ) ; i ++ ) { } if ( i == index ) return _ BOOL ; index = i ; return _ BOOL ; }
private void generate Gaussian Examples (  Instances format , int num Instances ,  Random random ,  Subspace Cluster Definition cl ,  String c Name ) { boolean make Integer = cl . is Integer ( ) ;  Instance example = null ; int num Atts = m_ Num Attributes ; if ( get Class Flag ( ) ) { num Atts ++ ; } example = new  Dense Instance ( num Atts ) ; example . set Dataset ( format ) ; boolean [ ] attributes = cl . get Attributes ( ) ; double [ ] mean Value = cl . get Mean Value ( ) ; double [ ] stddev Value = cl . get Stddev Value ( ) ; for ( int j = _ NUM ; j < num Instances ; j ++ ) { int num = - _ NUM ; for ( int i = _ NUM ; i < m_ Num Attributes ; i ++ ) { if ( attributes [ i ] ) { num ++ ; double value = mean Value [ num ] + ( random . next Gaussian ( ) * stddev Value [ num ] ) ; if ( make Integer ) { value =  Math . round ( value ) ; } example . set Value ( i , value ) ; } else { example . set Missing ( i ) ; } } if ( get Class Flag ( ) ) { example . set Class Value ( c Name ) ; } format . add ( example ) ; } }
public synchronized boolean retain All (  Collection c ) {  Object [ ] elements = get Array ( ) ; int len = elements . length ; if ( len != _ NUM ) { int newlen = _ NUM ;  Object [ ] temp = new  Object [ len ] ; for ( int i = _ NUM ; i < len ; ++ i ) {  Object element = elements [ i ] ; if ( c . contains ( element ) ) temp [ newlen ++ ] = element ; } if ( newlen != len ) { set Array ( copy Of Range ( temp , _ NUM , newlen ,  Object [ ] . class ) ) ; return _ BOOL ; } } return _ BOOL ; }
protected  String de Stress (  String phone ) {  String ret Phone = phone ; if ( is Stressed ( phone ) ) { ret Phone = phone . substring ( _ NUM , phone . length ( ) - _ NUM ) ; } return ret Phone ; }
public static  String escape (  String string ) { if ( string == null || string . equals ( _ STR ) ) { return string ; }  String prefix = _ STR ; if ( string . index Of ( _ STR ) != - _ NUM ) { prefix = string . substring ( _ NUM , string . index Of ( _ STR ) + _ NUM ) ; string = string . replace First ( prefix , _ STR ) ; } string = string . replace All ( _ STR , _ STR ) ; if ( string . starts With ( _ STR ) ) { string = _ STR + string . replace All ( _ STR , _ STR ) ; } else { string = string . replace All ( _ STR , _ STR ) ; } return prefix . concat ( string ) ; }
private void reload Cache With New Value ( final  Long new Value ) { final long new Value As Primitive = new Value == null ? get Cache Update Period ( ) : new Value ;  LOG . debug ( _ STR , cache Update Period Listeners . size ( ) ) ; for ( final  Property Change Listener listener : cache Update Period Listeners ) { final  Property Change Event event = new  Property Change Event ( this , _ STR , get Cache Update Period ( ) , new Value As Primitive ) ; listener . property Change ( event ) ; } }
public static void write Chars To Writer ( char [ ] chars ,  Writer writer ) throws  IOException {  Buffered Writer bw = new  Buffered Writer ( writer ) ; try { bw . write ( chars ) ; } finally { bw . close ( ) ; } }
public boolean dec Ref Count ( ) { int rc = ref Count Updater . decrement And Get ( this ) ; if ( rc < _ NUM ) { throw new  Illegal State Exception ( _ STR + rc ) ; } return rc == _ NUM ; }
public static boolean is Self Issued (  X509 Certificate cert ) {  X500 Principal subject = cert . get Subject X500 Principal ( ) ;  X500 Principal issuer = cert . get Issuer X500 Principal ( ) ; return subject . equals ( issuer ) ; }
private void check Search (  String input Graph ,  String output Graph ) {  Graph graph =  Graph Converter . convert ( input Graph ) ;  Independence Test independence = new  Ind Test DSep ( graph ) ;  Pc pc = new  Pc ( independence ) ;  Graph result Graph = pc . search ( new  Fas Stable Concurrent ( independence ) , independence . get Variables ( ) ) ;  Graph true Graph =  Graph Converter . convert ( output Graph ) ; result Graph =  Graph Utils . replace Nodes ( result Graph , true Graph . get Nodes ( ) ) ; assert True ( result Graph . equals ( true Graph ) ) ; }
public  Compiere Color (  String type ) { if ( type == null ) throw new java . lang .  Illegal Argument Exception (  EXCEPTION_ TEXT ) ; if ( type . equals (  TYPE_ FLAT ) || type . equals (  TYPE_ GRADIENT ) || type . equals (  TYPE_ TEXTURE ) || type . equals (  TYPE_ LINES ) ) { m_type = type ; } else throw new java . lang .  Illegal Argument Exception ( _ STR ) ; }
public  Deferred Subscription Subscriber (  Subscriber < ? super  O > subscriber ) { this . subscriber =  Objects . require Non Null ( subscriber , _ STR ) ; }
@  Override public void parse (  String a Line ) throws  IOException {  String [ ] tokens = a Line . split ( _ STR ) ; if ( tokens . length == _ NUM ) { clear ( ) ; query Name = tokens [ _ NUM ] ; } else { query Name = tokens [ _ NUM ] ; ref Name = tokens [ _ NUM ] ; bit Score =  Basic . parse Int ( tokens [ _ NUM ] ) ; expected =  Basic . parse Float ( tokens [ _ NUM ] ) ; percent Identity =  Basic . parse Int ( tokens [ _ NUM ] ) ; } }
private static void exit ( @  Nullable  String err Msg , boolean show Usage , int exit Code ) { if ( err Msg != null )  X . error ( err Msg ) ;  String runner =  System . get Property (  IGNITE_ PROG_ NAME , _ STR ) ; int space = runner . index Of ( _ STR ) ; runner = runner . substring ( _ NUM , space == - _ NUM ? runner . length ( ) : space ) ; if ( show Usage ) { boolean ignite = runner . contains ( _ STR ) ;  X . error ( _ STR , _ STR + runner + ( ignite ? _ STR : _ STR ) , _ STR , _ STR , _ STR , _ STR , _ STR ) ; if ( ignite ) {  X . error ( _ STR , _ STR , _ STR , _ STR , _ STR , _ STR , _ STR ) ; } }  System . exit ( exit Code ) ; }
@  Override public int compare To (  New Split Emitted Term term2 ) { int result ; if ( ( result = term . compare To ( term2 . get Term ( ) ) ) != _ NUM ) return result ; if ( ( result = splitno - term2 . get Splitno ( ) ) != _ NUM ) return result ; return flushno - term2 . get Flushno ( ) ; }
static int clamp ( int i , int min , int max ) { return  Math . max ( min ,  Math . min ( i , max ) ) ; }
private static void ensure Packages (  File pkg ) throws  IOException { if ( ! pkg . exists ( ) && ! pkg . mkdirs ( ) ) throw new  IOException ( _ STR + pkg ) ; }
private void handle Channel (  String [ ] args ,  Buffered Reader reader ) throws  IOException {  Tuple <  String ,  String > initial Payload = new  Tuple < > ( args [ _ NUM ] , args [ _ NUM ] ) ; if ( args . length == _ NUM ) { request Channel Fail . add ( initial Payload ) ; }  String line = reader . read Line ( ) ;  List <  String > commands = new  Array List < > ( ) ; while ( ! line . equals ( _ STR ) ) { commands . add ( line ) ; line = reader . read Line ( ) ; } request Channel Commands . put ( initial Payload , commands ) ; }
public void update Configuration ( @  Not Null  Configuration configuration ) { my Configuration = configuration ; invalidate Graphics Renderer ( ) ; }
protected void thread Start ( ) { if ( thread != null ) { return ; } thread Done = _ BOOL ; thread = new  Thread ( this , thread Name ) ; thread . set Daemon ( _ BOOL ) ; thread . start ( ) ; }
public static void tred2 ( int n , double [ ] [ ]  V , double [ ] d , double [ ] e ) { for ( int j = _ NUM ; j < n ; j ++ ) { d [ j ] =  V [ n - _ NUM ] [ j ] ; } for ( int i = n - _ NUM ; i > _ NUM ; i -- ) { double scale = _ NUM ; double h = _ NUM ; for ( int k = _ NUM ; k < i ; k ++ ) { scale = scale +  Math . abs ( d [ k ] ) ; } if ( scale == _ NUM ) { e [ i ] = d [ i - _ NUM ] ; for ( int j = _ NUM ; j < i ; j ++ ) { d [ j ] =  V [ i - _ NUM ] [ j ] ;  V [ i ] [ j ] = _ NUM ;  V [ j ] [ i ] = _ NUM ; } } else { for ( int k = _ NUM ; k < i ; k ++ ) { d [ k ] /= scale ; h += d [ k ] * d [ k ] ; } double f = d [ i - _ NUM ] ; double g =  Math . sqrt ( h ) ; if ( f > _ NUM ) { g = - g ; } e [ i ] = scale * g ; h = h - f * g ; d [ i - _ NUM ] = f - g ; for ( int j = _ NUM ; j < i ; j ++ ) { e [ j ] = _ NUM ; } for ( int j = _ NUM ; j < i ; j ++ ) { f = d [ j ] ;  V [ j ] [ i ] = f ; g = e [ j ] +  V [ j ] [ j ] * f ; for ( int k = j + _ NUM ; k <= i - _ NUM ; k ++ ) { g +=  V [ k ] [ j ] * d [ k ] ; e [ k ] +=  V [ k ] [ j ] * f ; } e [ j ] = g ; } f = _ NUM ; for ( int j = _ NUM ; j < i ; j ++ ) { e [ j ] /= h ; f += e [ j ] * d [ j ] ; } double hh = f / ( h + h ) ; for ( int j = _ NUM ; j < i ; j ++ ) { e [ j ] -= hh * d [ j ] ; } for ( int j = _ NUM ; j < i ; j ++ ) { f = d [ j ] ; g = e [ j ] ; for ( int k = j ; k <= i - _ NUM ; k ++ ) {  V [ k ] [ j ] -= ( f * e [ k ] + g * d [ k ] ) ; } d [ j ] =  V [ i - _ NUM ] [ j ] ;  V [ i ] [ j ] = _ NUM ; } } d [ i ] = h ; } for ( int i = _ NUM ; i < n - _ NUM ; i ++ ) {  V [ n - _ NUM ] [ i ] =  V [ i ] [ i ] ;  V [ i ] [ i ] = _ NUM ; double h = d [ i + _ NUM ] ; if ( h != _ NUM ) { for ( int k = _ NUM ; k <= i ; k ++ ) { d [ k ] =  V [ k ] [ i + _ NUM ] / h ; } for ( int j = _ NUM ; j <= i ; j ++ ) { double g = _ NUM ; for ( int k = _ NUM ; k <= i ; k ++ ) { g +=  V [ k ] [ i + _ NUM ] *  V [ k ] [ j ] ; } for ( int k = _ NUM ; k <= i ; k ++ ) {  V [ k ] [ j ] -= g * d [ k ] ; } } } for ( int k = _ NUM ; k <= i ; k ++ ) {  V [ k ] [ i + _ NUM ] = _ NUM ; } } for ( int j = _ NUM ; j < n ; j ++ ) { d [ j ] =  V [ n - _ NUM ] [ j ] ;  V [ n - _ NUM ] [ j ] = _ NUM ; }  V [ n - _ NUM ] [ n - _ NUM ] = _ NUM ; e [ _ NUM ] = _ NUM ; }
void add Column (  Column column ) { columns . add ( column ) ; }
private void create Plugin Manifest ( int i ,  String p Folder Path ) throws  IOException {  File Writer out = new  File Writer ( p Folder Path +  File . separator + _ STR ) ;  String xml = _ STR + _ STR + _ STR + i + _ STR + i + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR ; out . write ( xml ) ; out . flush ( ) ; out . close ( ) ; }
private  Segment Commit Info copy Segment As Is (  Segment Commit Info info ,  String seg Name ,  IOContext context ) throws  IOException {  Segment Info new Info = new  Segment Info ( directory Orig , info . info . get Version ( ) , seg Name , info . info . max Doc ( ) , info . info . get Use Compound File ( ) , info . info . get Codec ( ) , info . info . get Diagnostics ( ) , info . info . get Id ( ) , info . info . get Attributes ( ) , info . info . get Index Sort ( ) ) ;  Segment Commit Info new Info Per Commit = new  Segment Commit Info ( new Info , info . get Del Count ( ) , info . get Del Gen ( ) , info . get Field Infos Gen ( ) , info . get Doc Values Gen ( ) ) ; new Info . set Files ( info . files ( ) ) ; boolean success = _ BOOL ;  Set <  String > copied Files = new  Hash Set < > ( ) ; try { for (  String file : info . files ( ) ) { final  String new File Name = new Info . named For This Segment ( file ) ; directory . copy From ( info . info . dir , file , new File Name , context ) ; copied Files . add ( new File Name ) ; } success = _ BOOL ; } finally { if ( ! success ) { delete New Files ( copied Files ) ; } } assert copied Files . equals ( new Info Per Commit . files ( ) ) ; return new Info Per Commit ; }
@  Override public void add Scanned Result (  Result scanned Result ) throws  Query Execution Exception { synchronized ( this . lock Object ) { scanned Result List . add ( scanned Result ) ; if ( ( scanned Result List . size ( ) > max Number Of Scanned Result List ) ) {  List <  Result > local Result = scanned Result List ; scanned Result List = new  Array List <  Result > (  Carbon Common Constants .  DEFAULT_ COLLECTION_ SIZE ) ; exec Service . submit ( new  Merger Thread ( local Result ) ) ; } } }
@  Override public int hash Code ( ) { return value . hash Code ( ) ; }
private void refresh Account Schema ( ) { if ( m_acct Schema == null ) { m_acct Schema = new  MAcct Schema (  Env . get Ctx ( ) , m_ C_ Acct Schema_ ID , null ) ; } return ; }
public void add Model (  Model model ) { models . add ( model ) ; }
public  Partitions prune Partitions (  Set <  String > valid Partitions ) { if ( valid Partitions != null && ! valid Partitions . is Empty ( ) ) { partitions . retain All ( valid Partitions ) ; } return this ; }
private boolean is Word ( final  String str ) { if ( str == null || str . length ( ) == _ NUM ) { return _ BOOL ; } for ( int i = _ NUM ; i < str . length ( ) ; i ++ ) { if ( !  Character . is Java Identifier Part ( str . char At ( i ) ) ) { return _ BOOL ; } } return _ BOOL ; }
public static int put Short ( byte [ ] bytes , int offset , short val ) { if ( little Endian ) { val =  Short . reverse Bytes ( val ) ; } the Unsafe . put Short ( bytes , offset +  BYTE_ ARRAY_ BASE_ OFFSET , val ) ; return offset +  Bytes .  SIZEOF_ SHORT ; }
public void add Label (  Label label ) { assert Not Null ( label ) ; labels . add ( label ) ; label . set Parent ( this ) ; }
public static  String wrap In Tag (  String line ,  String tag ,  String css Class ) {  String Builder tag Builder = new  String Builder ( ) ; tag Builder . append ( _ STR ) ; tag Builder . append ( tag ) ; if ( css Class != null ) { tag Builder . append ( _ STR ) ; tag Builder . append ( css Class ) ; tag Builder . append ( _ STR ) ; } tag Builder . append ( _ STR ) ;  String start Tag = tag Builder . to String ( ) ; tag Builder . delete ( _ NUM , tag Builder . length ( ) ) ; tag Builder . append ( _ STR ) ; tag Builder . append ( tag ) ; tag Builder . append ( _ STR ) ;  String end Tag = tag Builder . to String ( ) ; return start Tag + line + end Tag ; }
public static  Class Delegate class Delegate ( ) { return _database Class Delegate . get ( ) ; }
private void convert Outer Join ( final  String Builder target , final  Char Sequence outer Join ) throws  FBSQLParse Exception { target . append ( outer Join ) ; }
private static final  Set <  File > encode (  String src ) { if ( src == null || src . length ( ) == _ NUM ) return new  Hash Set <  File > ( ) ;  String Tokenizer tokenizer = new  String Tokenizer ( src , _ STR ) ; int size = tokenizer . count Tokens ( ) ;  Set <  File > set = new  Hash Set <  File > ( ) ; for ( int i = _ NUM ; i < size ; i ++ ) set . add ( new  File ( tokenizer . next Token ( ) ) ) ; return set ; }
public  E poll ( long timeout ,  Time Unit unit ) throws  Interrupted Exception { long nanos = unit . to Nanos ( timeout ) ; final  Reentrant Lock lock = this . lock ; lock . lock Interruptibly ( ) ; try { for ( ; ; ) {  E first = q . peek ( ) ; if ( first == null ) { if ( nanos <= _ NUM ) return null ; else nanos = available . await Nanos ( nanos ) ; } else { long delay = first . get Delay (  NANOSECONDS ) ; if ( delay <= _ NUM ) return q . poll ( ) ; if ( nanos <= _ NUM ) return null ; first = null ; if ( nanos < delay || leader != null ) nanos = available . await Nanos ( nanos ) ; else {  Thread this Thread =  Thread . current Thread ( ) ; leader = this Thread ; try { long time Left = available . await Nanos ( delay ) ; nanos -= delay - time Left ; } finally { if ( leader == this Thread ) leader = null ; } } } } } finally { if ( leader == null && q . peek ( ) != null ) available . signal ( ) ; lock . unlock ( ) ; } }
public int size ( ) { return set . size ( ) ; }
private void add Update Menu Item (  Model Menu Item model Menu Item ,  List <  Model Menu Item > menu Item List ,  Map <  String ,  Model Menu Item > menu Item Map ) {  Model Menu Item existing Menu Item = menu Item Map . get ( model Menu Item . get Name ( ) ) ; if ( existing Menu Item != null ) {  Model Menu Item merged Menu Item = existing Menu Item . merge Override Model Menu Item ( model Menu Item ) ; int existing Item Index = menu Item List . index Of ( existing Menu Item ) ; menu Item List . set ( existing Item Index , merged Menu Item ) ; menu Item Map . put ( model Menu Item . get Name ( ) , merged Menu Item ) ; } else { menu Item List . add ( model Menu Item ) ; menu Item Map . put ( model Menu Item . get Name ( ) , model Menu Item ) ; } }
public static void write Short Integer (  Output Stream the Os , int the Value ) throws  IOException { the Os . write ( ( byte ) ( the Value | ( byte ) _ NUM ) ) ; }
public void add Header (  Header header ) { if ( header == null ) { return ; } headers . add ( header ) ; }
public  String create Message (  Sso Exception e ) { return create Message ( e . get Message Key ( ) , e . get Message Details ( ) , e . get Message ( ) ) ; }
public static int create Type Instance ( final  Connection connection , final int module Id , final  String name , final  Integer comment Id , final int type Id , final int section Id , final long section Offset ) throws  Couldnt Save Data Exception {  Preconditions . check Not Null ( connection , _ STR ) ;  Preconditions . check Argument ( module Id > _ NUM , _ STR ) ;  Preconditions . check Not Null ( name , _ STR ) ;  Preconditions . check Argument ( type Id >= _ NUM , _ STR ) ;  Preconditions . check Argument ( section Id >= _ NUM , _ STR ) ;  Preconditions . check Argument ( section Offset >= _ NUM , _ STR ) ; try { final  String query = _ STR ; final  Callable Statement procedure = connection . prepare Call ( query ) ; try { procedure . register Out Parameter ( _ NUM ,  Types .  INTEGER ) ; procedure . set Int ( _ NUM , module Id ) ; procedure . set String ( _ NUM , name ) ; if ( comment Id == null ) { procedure . set Null ( _ NUM ,  Types .  INTEGER ) ; } else { procedure . set Int ( _ NUM , comment Id ) ; } procedure . set Int ( _ NUM , type Id ) ; procedure . set Int ( _ NUM , section Id ) ; procedure . set Long ( _ NUM , section Offset ) ; procedure . execute ( ) ; final int type Instance Id = procedure . get Int ( _ NUM ) ; if ( procedure . was Null ( ) ) { throw new  Couldnt Save Data Exception ( _ STR ) ; } return type Instance Id ; } finally { procedure . close ( ) ; } } catch ( final  SQLException exception ) { throw new  Couldnt Save Data Exception ( exception ) ; } }
public static void sort ( int [ ] a ) { do Sort ( a , _ NUM , a . length - _ NUM ) ; }
public  String to String ( ) { return _ STR + format . format ( x ) + _ STR + format . format ( y ) + _ STR ; }
public  Optional <  T > first ( ) {  Iterator <  T > iterator = iterator ( ) ; return iterator . has Next ( ) ?  Optional . of ( iterator . next ( ) ) :  Optional . <  T > empty ( ) ; }
public void sleep ( long millis ) { try {  Thread . sleep ( millis ) ; } catch (  Interrupted Exception e ) { } }
static boolean is Package Access ( int modifiers ) { return ( modifiers &  ACCESS_ TEST ) == _ NUM ; }
private void save Window State (  Window window ) { if ( ! location Set . contains ( window ) && window != primary Window ) { return ; }  State Item item = windows . get ( window ) ;  Point location = window . get Location ( ) ;  String state = location . x + _ STR + location . y ;  Dimension size = window . get Size ( ) ; state += _ STR + size . width + _ STR + size . height ; state += _ STR + ( window . is Visible ( ) ? _ STR : _ STR ) ; settings . map Put (  SETTING , item . id , state ) ; }
public  Partitioned Region Rebalance Op (  Partitioned Region region , boolean simulate ,  Rebalance Director director , boolean replace Offline Data , boolean is Rebalance ) { this ( region , simulate , director , replace Offline Data , is Rebalance , new  Atomic Boolean ( ) , null ) ; }
@  Override public void add SLDOutput Listener (  SLDOutput Interface sld Output ) { sld Output List . add ( sld Output ) ; }
public  Builder put (  Properties properties ) { for (  Map .  Entry entry : properties . entry Set ( ) ) { map . put ( (  String ) entry . get Key ( ) , (  String ) entry . get Value ( ) ) ; } return this ; }
public static void change Font (  JComponent comp , double scale Factor , int style ) {  Font font = comp . get Font ( ) ; font = scale ( font , scale Factor ) ; comp . set Font ( font . derive Font ( style ) ) ; }
public boolean draw Image (  Image img , int x , int y ,  Color bg ,  Image Observer observer ) { if ( img == null ) { return _ BOOL ; } if ( is Hi DPIImage ( img ) ) { final int img W = img . get Width ( null ) ; final int img H = img . get Height ( null ) ; return draw Hi DPIImage ( img , x , y , x + img W , y + img H , _ NUM , _ NUM , img W , img H , bg , observer ) ; } try { return imagepipe . copy Image ( this , img , x , y , bg , observer ) ; } catch (  Invalid Pipe Exception e ) { try { revalidate All ( ) ; return imagepipe . copy Image ( this , img , x , y , bg , observer ) ; } catch (  Invalid Pipe Exception e2 ) { return _ BOOL ; } } finally { surface Data . mark Dirty ( ) ; } }
public static void write Line (  Buffered Writer writer ,  String line ) throws  IOException { writer . write ( line ) ; writer . new Line ( ) ; }
public void add On Central Position Changed Listener (  On Central Position Changed Listener listener ) { m On Central Position Changed Listeners . add ( listener ) ; }
public static  Object invoke Static (  Class clazz ,  String method Name ,  Class [ ] types ,  Object [ ] values ) throws  No Such Method Exception { try {  Method method = clazz . get Method ( method Name , types ) ;  Object result = method . invoke ( null , values ) ; return result ; } catch (  Illegal Access Exception e ) { throw new  No Such Method Exception ( method Name + _ STR ) ; } catch (  Invocation Target Exception e ) { throw new  Internal Error ( e . get Message ( ) ) ; } }
public static _ Fields find By Thrift Id ( int field Id ) { switch ( field Id ) { case _ NUM : return  NOTE_ ID ; case _ NUM : return  PARAGRAPH_ ID ; case _ NUM : return  RESOURCE_ NAME ; default : return null ; } }
static  String string From Packet (  Datagram Packet packet ) { return new  String ( packet . get Data ( ) , _ NUM , packet . get Length ( ) ) ; }
public void execute Action ( final  String js Code ) { actions Executed = _ BOOL ; if ( disable Javascript ) { return ; } js Parser . execute Functions ( js Code , null ) ; }
public static boolean is Current Version Equal To (  Integer expected Version ) {  String [ ] parsed Version = parse Version ( get Current Version ( ) ) ; if ( parsed Version == null ) { return _ BOOL ; } return expected Version . equals (  Integer . value Of ( parsed Version [ _ NUM ] ) ) ; }
public void clear (  Faces Context faces Context ,  Map <  String ,  Object > view Map ) { if (  LOGGER . is Loggable (  Level .  FINEST ) ) {  LOGGER . log (  Level .  FINEST , _ STR , view Map ) ; } if ( context Manager != null ) { context Manager . clear ( faces Context , view Map ) ; } destroy Beans ( faces Context , view Map ) ; }
@  Override public  Table View format Table (  Logical Table logical Table ,  Uri Info uri Info ) {  Table View result Row = new  Table View ( ) ; result Row . put ( _ STR , logical Table . get Name ( ) ) ; result Row . put ( _ STR , logical Table . get Long Name ( ) ) ; result Row . put ( _ STR , logical Table . get Description ( ) ) ; result Row . put ( _ STR , logical Table . get Category ( ) ) ; return result Row ; }
public void read Process ( final  Reader in ) throws  XMLException ,  IOException { read Process ( in , null ) ; }
@  Override public boolean accepts URL (  String url ) { if ( url != null ) { if ( url . starts With (  Constants .  START_ URL ) ) { return _ BOOL ; } else if ( url . equals (  DEFAULT_ URL ) ) { return  DEFAULT_ CONNECTION . get ( ) != null ; } } return _ BOOL ; }
@  Override public  String to String ( ) { final  String Builder sb = new  String Builder ( ) ; sb . append ( _ STR ) ; sb . append ( get Request ID ( ) ) ; sb . append ( _ STR ) ; sb . append ( timestamp ) ; sb . append ( _ STR ) ; sb . append ( get Request ( ) ) ; sb . append ( _ STR ) ; return sb . to String ( ) ; }
public void skip To ( int desired Position ) { desired Position =  Math . max ( _ NUM , desired Position ) ; for ( int i = _ NUM ; i < desired Position ; i ++ ) skip ( ) ; }
static int derive ARGB (  Color color1 ,  Color color2 , float mid Point ) { int r = color1 . get Red ( ) +  Math . round ( ( color2 . get Red ( ) - color1 . get Red ( ) ) * mid Point ) ; int g = color1 . get Green ( ) +  Math . round ( ( color2 . get Green ( ) - color1 . get Green ( ) ) * mid Point ) ; int b = color1 . get Blue ( ) +  Math . round ( ( color2 . get Blue ( ) - color1 . get Blue ( ) ) * mid Point ) ; int a = color1 . get Alpha ( ) +  Math . round ( ( color2 . get Alpha ( ) - color1 . get Alpha ( ) ) * mid Point ) ; return ( ( a & _ NUM ) << _ NUM ) | ( ( r & _ NUM ) << _ NUM ) | ( ( g & _ NUM ) << _ NUM ) | ( b & _ NUM ) ; }
public  Audio Module (  Dialogue System system ) { this . system = system ; }
public static  Buffered Image to Buffered Image (  Image img ) { if ( img instanceof  Buffered Image ) { return (  Buffered Image ) img ; }  Buffered Image bimage = new  Buffered Image ( img . get Width ( null ) , img . get Height ( null ) ,  Buffered Image .  TYPE_ INT_ ARGB ) ;  Graphics2 D b Gr = bimage . create Graphics ( ) ; b Gr . draw Image ( img , _ NUM , _ NUM , null ) ; b Gr . dispose ( ) ; return bimage ; }
public static  String hypen To Camel Notation (  String str ) { if ( is Empty ( str ) ) return str ;  String Builder sb = new  String Builder ( ) ; int len = str . length ( ) ; char c ; for ( int i = _ NUM ; i < str . length ( ) ; i ++ ) { c = str . char At ( i ) ; if ( c == _ STR ) { if ( len > ++ i ) sb . append (  Character . to Upper Case ( str . char At ( i ) ) ) ; } else sb . append ( c ) ; } return sb . to String ( ) ; }
public void add Sensor Selection Listener ( final  Sensor Selection Listener listener ) { listener List . add (  Sensor Selection Listener . class , listener ) ; }
public void write ( char c ) throws  IOException { if ( _output == null ) throw new  IOException ( _ STR ) ; _output . append ( c ) ; }
public void unregister (  Grid Cache Ttl Manager mgr ) { synchronized ( mux ) { mgrs . remove ( mgr ) ; if ( mgrs . is Empty ( ) ) stop Cleanup Worker ( ) ; } }
private void check Log (  Ignite Logger log ) { assert ! log . is Debug Enabled ( ) ; assert log . is Info Enabled ( ) ; log . debug ( _ STR ) ; log . info ( _ STR ) ; log . warning ( _ STR ) ; log . warning ( _ STR , new  Exception ( _ STR ) ) ; log . error ( _ STR ) ; log . error ( _ STR , new  Exception ( _ STR ) ) ; }
public  Object rotate (  Object image , int degrees ) { int width = get Image Width ( image ) ; int height = get Image Height ( image ) ; int [ ] arr = new int [ width * height ] ; int [ ] dest = new int [ arr . length ] ; get RGB ( image , arr , _ NUM , _ NUM , _ NUM , width , height ) ; int center X = width / _ NUM ; int center Y = height / _ NUM ; double radians =  Math . to Radians ( - degrees ) ; double cos Deg =  Math . cos ( radians ) ; double sin Deg =  Math . sin ( radians ) ; for ( int x = _ NUM ; x < width ; x ++ ) { for ( int y = _ NUM ; y < height ; y ++ ) { int x2 = round ( cos Deg * ( x - center X ) - sin Deg * ( y - center Y ) + center X ) ; int y2 = round ( sin Deg * ( x - center X ) + cos Deg * ( y - center Y ) + center Y ) ; if ( ! ( x2 < _ NUM || y2 < _ NUM || x2 >= width || y2 >= height ) ) { int dest Offset = x2 + y2 * width ; if ( dest Offset >= _ NUM && dest Offset < dest . length ) { dest [ x + y * width ] = arr [ dest Offset ] ; } } } } return create Image ( dest , width , height ) ; }
public static  String clean Stacking Markers (  String filename ) { if ( !  String Utils . is Empty ( filename ) ) {  Matcher m = stacking Pattern1 . matcher ( filename ) ; if ( m . matches ( ) ) { return m . group ( _ NUM ) + m . group ( _ NUM ) ; } m = stacking Pattern2 . matcher ( filename ) ; if ( m . matches ( ) ) { return m . group ( _ NUM ) + m . group ( _ NUM ) ; } m = stacking Pattern3 . matcher ( filename ) ; if ( m . matches ( ) ) { return m . group ( _ NUM ) + m . group ( _ NUM ) ; } m = stacking Pattern4 . matcher ( filename ) ; if ( m . matches ( ) ) { return m . group ( _ NUM ) + m . group ( _ NUM ) ; } } return filename ; }
private void add Service (  Svc Reg reg ) { service By ID . put ( reg . item . service ID , reg ) ; service By Time . put ( reg , reg ) ; add Service By Types ( reg . item . service Type , reg ) ;  Entry Rep [ ] entries = reg . item . attribute Sets ; for ( int i = entries . length ; -- i >= _ NUM ; ) { add Attrs ( reg , entries [ i ] ) ; } compute Max Leases ( ) ; }
protected final boolean is List State ( ) { return state Text Types . char At ( state ) == _ STR ; }
public int write (  Protein protein ) throws  IOException { int sequence Length = protein . get Sequence Length ( ) ;  String md5 = protein . get Md5 ( ) ;  String date = dmy Format . format ( new  Date ( ) ) ;  Set <  Match > matches = protein . get Matches ( ) ;  String protein Id For GFF = null ;  List <  String > protein Ids From Get Orf = get Protein Accessions ( protein ) ; for (  String protein Id From Getorf : protein Ids From Get Orf ) { if ( matches . size ( ) > _ NUM ) { protein Id From Getorf = get Valid GFF3 Seq Id ( protein Id From Getorf ) ; write Sequence Region Part ( protein , sequence Length , md5 , protein Id From Getorf ) ; process Matches ( matches , protein Id For GFF , date , protein , get Nucleotide Id ( ) ) ; } } return _ NUM ; }
public void println (  Writer writer ) throws  IOException { print ( writer ) ; writer . write ( _ STR ) ; }
public int hash Code ( ) { return value . hash Code ( ) ^ locale . hash Code ( ) ; }
@  Override public void end DTD (  Augmentations augs ) throws  XNIException { f In DTD = _ BOOL ; try { if ( f Lexical Handler != null ) { f Lexical Handler . end DTD ( ) ; } } catch (  SAXException e ) { throw new  XNIException ( e ) ; } if ( f Declared Attrs != null ) { f Declared Attrs . clear ( ) ; } }
public  Db (  Connection conn ) { try { this . conn = conn ; stat = conn . create Statement ( ) ; } catch (  SQLException e ) { throw convert ( e ) ; } }
public boolean has Arg Name ( ) { return arg Name != null && arg Name . length ( ) > _ NUM ; }
public static boolean has Mime Type (  String mime Type ) { if ( mime Type == null || mime Type . is Empty ( ) ) { return _ BOOL ; } return mime Type To Extension Map . contains Key ( mime Type ) ; }
private  String replace Meta Chars (  String input ) {  String result = input . replace All ( _ STR , _ STR ) ; result = result . replace All (  Pattern . quote ( _ STR ) , _ STR ) ; result = result . replace All (  Pattern . quote ( _ STR ) , _ STR ) ; result = result . replace All (  Pattern . quote ( _ STR ) , _ STR ) ; result = result . replace All (  Pattern . quote ( _ STR ) , _ STR ) ; result = result . replace All (  Pattern . quote ( _ STR ) , _ STR ) ; result = result . replace All (  Pattern . quote ( _ STR ) , _ STR ) ; result = result . replace All (  Pattern . quote ( _ STR ) , _ STR ) ; result = result . replace All (  Pattern . quote ( _ STR ) , _ STR ) ; result = result . replace All (  Pattern . quote ( _ STR ) , _ STR ) ; result = result . replace All (  Pattern . quote ( _ STR ) , _ STR ) ; result = result . replace All (  Pattern . quote ( _ STR ) , _ STR ) ; result = result . replace All (  Pattern . quote ( _ STR ) , _ STR ) ; result = result . replace All (  Pattern . quote ( _ STR ) , _ STR ) ; result = result . replace All (  Pattern . quote ( _ STR ) , _ STR ) ; return result ; }
static public  String encode ( final byte [ ] bytes ) { int i = _ NUM , index = _ NUM , digit = _ NUM ; int curr Byte , next Byte ;  String Buffer base32 = new  String Buffer ( ( bytes . length + _ NUM ) * _ NUM / _ NUM ) ; while ( i < bytes . length ) { curr Byte = ( bytes [ i ] >= _ NUM ) ? bytes [ i ] : ( bytes [ i ] + _ NUM ) ; if ( index > _ NUM ) { if ( ( i + _ NUM ) < bytes . length ) { next Byte = ( bytes [ i + _ NUM ] >= _ NUM ) ? bytes [ i + _ NUM ] : ( bytes [ i + _ NUM ] + _ NUM ) ; } else { next Byte = _ NUM ; } digit = curr Byte & ( _ NUM > > index ) ; index = ( index + _ NUM ) % _ NUM ; digit <<= index ; digit |= next Byte > > ( _ NUM - index ) ; i ++ ; } else { digit = ( curr Byte > > ( _ NUM - ( index + _ NUM ) ) ) & _ NUM ; index = ( index + _ NUM ) % _ NUM ; if ( index == _ NUM ) i ++ ; } base32 . append ( base32 Chars . char At ( digit ) ) ; } return base32 . to String ( ) ; }
final public void print ( float v ) {  Writer out = this . out ; if ( out == null ) return ; try {  String s =  String . value Of ( v ) ; out . write ( s , _ NUM , s . length ( ) ) ; } catch (  IOException e ) { log . log (  Level .  FINE , e . to String ( ) , e ) ; } }
@  Override public  String to String ( ) {  String Buffer result ; if ( m_ Model == null ) { result = new  String Buffer ( _ STR ) ; } else { result = new  String Buffer ( ) ; result . append ( _ STR ) ; result . append ( _ STR ) ; result . append ( _ STR + get Model File ( ) + _ STR ) ; result . append ( m_ Model . to String ( ) ) ; } return result . to String ( ) ; }
public static boolean check Chroot Path (  String zk Host , boolean create ) throws  Keeper Exception ,  Interrupted Exception { if ( !  Solr Zk Client . contains Chroot ( zk Host ) ) { return _ BOOL ; } log . trace ( _ STR ) ;  String chroot Path = zk Host . substring ( zk Host . index Of ( _ STR ) , zk Host . length ( ) ) ;  Solr Zk Client tmp Client = new  Solr Zk Client ( zk Host . substring ( _ NUM , zk Host . index Of ( _ STR ) ) , _ NUM , _ NUM , null , null , null ) ; boolean exists = tmp Client . exists ( chroot Path , _ BOOL ) ; if ( ! exists && create ) { tmp Client . make Path ( chroot Path , _ BOOL , _ BOOL ) ; exists = _ BOOL ; } tmp Client . close ( ) ; return exists ; }
static void create (  SQLite Database db ) { create ( db , _ BOOL ) ; add Association ( db , _ BOOL ) ; }
@  Override public int hash Code ( ) { int result = bucket Name . hash Code ( ) ; result = _ NUM * result + name . hash Code ( ) ; result = _ NUM * result + created Time . hash Code ( ) ; result = _ NUM * result + ( int ) ( length ^ ( length > > > _ NUM ) ) ; result = _ NUM * result + etag . hash Code ( ) ; result = _ NUM * result + content Type . hash Code ( ) ; return result ; }
public boolean add Entry (  File file ) { if ( file == null ) { log . warning ( _ STR ) ; return _ BOOL ; } if ( ! file . exists ( ) || file . is Directory ( ) || ! file . can Read ( ) ) { log . warning ( _ STR + file + _ STR + file . exists ( ) + _ STR + file . is Directory ( ) ) ; return _ BOOL ; } log . fine ( _ STR + file ) ;  String name = file . get Name ( ) ; byte [ ] data = null ;  File Input Stream fis = null ;  Byte Array Output Stream os = null ; try { fis = new  File Input Stream ( file ) ; os = new  Byte Array Output Stream ( ) ; byte [ ] buffer = new byte [ _ NUM * _ NUM ] ; int length = - _ NUM ; while ( ( length = fis . read ( buffer ) ) != - _ NUM ) os . write ( buffer , _ NUM , length ) ; data = os . to Byte Array ( ) ; } catch (  IOException ioe ) { log . log (  Level .  SEVERE , _ STR , ioe ) ; } finally { if ( fis != null ) { try { fis . close ( ) ; } catch (  IOException ex ) { log . log (  Level .  SEVERE , _ STR , ex ) ; } ; } if ( os != null ) { try { os . close ( ) ; } catch (  IOException ex ) { log . log (  Level .  SEVERE , _ STR , ex ) ; } ; } } return add Entry ( name , data ) ; }
public  Debugger Exception ( final  String exception Name , final long exception Code , final  Debugger Exception Handling Action exception Action ) {  Preconditions . check Argument ( ! exception Name . is Empty ( ) , _ STR ) ; this . name =  Preconditions . check Not Null ( exception Name , _ STR ) ; this . exception Code = exception Code ; this . exception Action =  Preconditions . check Not Null ( exception Action , _ STR ) ; }
@  Override public boolean contains (  String identifier ) { return blacklist . contains ( identifier ) ; }
static private  String  INT_ Max_ Plus ( ) { long temp Value =  Integer .  MAX_ VALUE + _ NUM ; return  String . value Of ( temp Value ) ; }
public static  String make Compliant Name (  String value ) { value = value . replace ( _ STR , _ STR ) ; value = value . replace ( _ STR , _ STR ) ; value = value . replace ( _ STR , _ STR ) ; value = value . replace ( _ STR , _ STR ) ; value = value . replace ( _ STR , _ STR ) ; if ( value . length ( ) < _ NUM ) { value = _ STR ; } return value ; }
public  Storage Unit Entity create Database Entities For Business Object Data Ddl Testing (  String partition Value ) { if ( partition Value != null ) {  String s3 Key Prefix =  Abstract Service Test . get Expected S3 Key Prefix (  Abstract Service Test .  NAMESPACE ,  Abstract Service Test .  DATA_ PROVIDER_ NAME ,  Abstract Service Test .  BDEF_ NAME ,  Abstract Service Test .  FORMAT_ USAGE_ CODE ,  File Type Entity .  TXT_ FILE_ TYPE ,  Abstract Service Test .  FORMAT_ VERSION ,  Abstract Service Test .  FIRST_ PARTITION_ COLUMN_ NAME , partition Value , null , null ,  Abstract Service Test .  DATA_ VERSION ) ; return create Database Entities For Business Object Data Ddl Testing ( partition Value , s3 Key Prefix ) ; } else { return create Database Entities For Business Object Data Ddl Testing ( null , null ) ; } }
private void do Shader (  PDFObject shader Obj ) throws  IOException { }
public static  Map append Element To Map (  String key ,  Set values ,  Map to Map ) { if ( ( key != null ) && ( values != null ) && ( ! values . is Empty ( ) ) && ( to Map != null ) ) {  Set previous Values = (  Set ) to Map . get ( key ) ; if ( ( previous Values != null ) && ( ! previous Values . is Empty ( ) ) ) { previous Values . add All ( values ) ; } else { to Map . put ( key , values ) ; } } return to Map ; }
Usage Configuration (  File config File ) throws  IOException { m Prop = new  Properties ( ) ; try (  Input Stream is =  File Utils . create Input Stream ( config File , _ BOOL ) ) { m Prop . load ( is ) ; } m Prop . set Property (  ENABLE_ USAGE , _ STR ) ; }
public void read (  Buffered Reader reader ) throws  Exception {  String line ; clear ( ) ; while ( ( line = reader . read Line ( ) ) != null ) { line = line . trim ( ) ; if ( line . starts With ( _ STR ) ) { continue ; } add ( line ) ; } reader . close ( ) ; }
public  Packet Output Stream write Time Length ( final  Calendar calendar , final boolean fractional Seconds ) { if ( fractional Seconds ) { assure Buffer Capacity ( _ NUM ) ; buffer . put ( ( byte ) _ NUM ) ; buffer . put ( ( byte ) _ NUM ) ; buffer . put Int ( _ NUM ) ; buffer . put ( ( byte ) calendar . get (  Calendar .  HOUR_ OF_ DAY ) ) ; buffer . put ( ( byte ) calendar . get (  Calendar .  MINUTE ) ) ; buffer . put ( ( byte ) calendar . get (  Calendar .  SECOND ) ) ; buffer . put Int ( calendar . get (  Calendar .  MILLISECOND ) * _ NUM ) ; } else { assure Buffer Capacity ( _ NUM ) ; buffer . put ( ( byte ) _ NUM ) ; buffer . put ( ( byte ) _ NUM ) ; buffer . put Int ( _ NUM ) ; buffer . put ( ( byte ) calendar . get (  Calendar .  HOUR_ OF_ DAY ) ) ; buffer . put ( ( byte ) calendar . get (  Calendar .  MINUTE ) ) ; buffer . put ( ( byte ) calendar . get (  Calendar .  SECOND ) ) ; } return this ; }
public  String to String ( ) {  String Buffer text = new  String Buffer ( ) ; text . append ( _ STR ) ; return text . to String ( ) ; }
public static  Print Writer open Print Writer To File (  File file , boolean verbose ) throws  Ade Usage Exception { try { if ( verbose ) { logger . info ( _ STR + file . get Path ( ) ) ; } return new  Print Writer ( file ,  FILE_ ENCODING ) ; } catch (  File Not Found Exception e ) { throw new  Ade Usage Exception ( _ STR + file . get Path ( ) , e ) ; } catch (  Unsupported Encoding Exception e ) { throw new  Ade Usage Exception ( _ STR +  FILE_ ENCODING , e ) ; } }
public  Shape create Arrow Left ( final double x , final double y , final double w , final double h ) { path . reset ( ) ; path . move To ( x + w , y ) ; path . line To ( x , y + h / _ NUM ) ; path . line To ( x + w , y + h ) ; path . close Path ( ) ; return path ; }
private synchronized void cleanup State ( ) { source Ids = null ; targets = null ; if ( executor != null ) { executor . shutdown ( ) ; executor = null ; } }
protected void copy Selected Bean ( ) { if (  Debug . debugging ( _ STR ) )  Debug . output ( _ STR ) ; if ( selected Bean == null || selected Bean Location == null ) { clear Selection ( ) ; if (  Debug . debugging ( _ STR ) )  Debug . output ( _ STR + selected Bean ) ; if (  Debug . debugging ( _ STR ) )  Debug . output ( _ STR + selected Bean Location ) ; return ; } try { ser Bean = new  Byte Array Output Stream ( ) ;  Object Output Stream oos = new  Object Output Stream ( ser Bean ) ; oos . write Object ( selected Bean ) ; } catch (  Exception e ) { e . print Stack Trace ( ) ; clear Selection ( ) ; if (  Debug . debugging ( _ STR ) )  Debug . output ( _ STR ) ; return ; } cut Bean = null ; if (  Debug . debugging ( _ STR ) )  Debug . output ( _ STR ) ; }
public void component Hidden ( final  Component Event e ) { final  Object source = e . get Source ( ) ; if ( ! ( source instanceof  JMenu Item ) ) return ; set Child Visible ( (  JMenu Item ) source , _ BOOL ) ; }
void add Log Entry (  Log Entry log Entry ) { log Entries . add ( log Entry ) ; }
public void keep (  Object obj ) { if ( children == null ) children = new  Linked List ( ) ; children . add ( obj ) ; }
public static  String player Id To Name (  UUID uuid ) { long least Sig Bits = uuid . get Least Significant Bits ( ) ; long most Sig Bits = uuid . get Most Significant Bits ( ) ; byte [ ] bytes = to Array ( most Sig Bits , least Sig Bits ) ; bytes = remove Zeroes At End ( bytes ) ; return new  String ( bytes ,  Standard Charsets .  UTF_8 ) ; }
public static void add Handler ( final  Handler handler ) { log . add Handler ( handler ) ; }
public  String to String ( ) {  String Builder sb = new  String Builder ( ) ; to String ( sb , _ NUM , this ) ; return ( sb . to String ( ) ) ; }
public  Follower Info (  Follower .  Type type ,  String stream ,  List <  Follower > followers , int total ) { this . type = type ; this . followers = followers ; this . total = total ; this . time =  System . current Time Millis ( ) ; this . stream = stream ; this . request Error = _ BOOL ; this . request Error Description = null ; }
public static int execute Update (  Connection connection ,  String raw Sql Query ,  Object ... parameters ) throws  SQLException {  Prepared Statement stmt = null ; try { stmt = connection . prepare Statement ( raw Sql Query ) ; for ( int index = _ NUM ; index < parameters . length ; index ++ ) {  Jdbc Utils . bind Parameter ( stmt , index + _ NUM , parameters [ index ] ) ; } return stmt . execute Update ( ) ; } finally {  Jdbc Utils . close Statement ( stmt ) ; } }
public  Future <  Sync Reply > send Request ( int xid ,  Sync Message request ) throws  Remote Store Exception { ensure Connected ( ) ;  Remote Sync Future future = new  Remote Sync Future ( xid , connection Generation ) ; future Map . put (  Integer . value Of ( xid ) , future ) ; if ( future Map . size ( ) >  MAX_ PENDING_ REQUESTS ) { synchronized ( future Notify ) { while ( future Map . size ( ) >  MAX_ PENDING_ REQUESTS ) { try { future Notify . wait ( ) ; } catch (  Interrupted Exception e ) { throw new  Remote Store Exception ( _ STR , e ) ; } } } } channel . write ( request ) ; return future ; }
public static boolean is Empty (  String str ) { return ( str == null || str . length ( ) == _ NUM ) ; }
public void enable (  Capability c ) { if ( do Not Check Capabilities ( ) ) { return ; } if ( c ==  Capability .  NOMINAL_ ATTRIBUTES ) { enable (  Capability .  BINARY_ ATTRIBUTES ) ; } else if ( c ==  Capability .  BINARY_ ATTRIBUTES ) { enable (  Capability .  UNARY_ ATTRIBUTES ) ; } else if ( c ==  Capability .  UNARY_ ATTRIBUTES ) { enable (  Capability .  EMPTY_ NOMINAL_ ATTRIBUTES ) ; } else if ( c ==  Capability .  NOMINAL_ CLASS ) { enable (  Capability .  BINARY_ CLASS ) ; } m_ Capabilities . add ( c ) ; }
public boolean supports Session Variables ( ) { return _ BOOL ; }
public  Resources Poet add Dimension (  String name ,  String value ) {  Element bool = document . create Element ( _ STR ) ; bool . set Attribute ( _ STR , name ) ; bool . append Child ( document . create Text Node ( value ) ) ; resource Element . append Child ( bool ) ; return this ; }
public void abort ( ) {  Process next Sub Process = sub Process ; sub Process = null ; if ( next Sub Process != null ) { next Sub Process . destroy ( ) ; } }
public long time ( ) { return  System . current Time Millis ( ) ; }
public static final boolean is Ignorable IOException (  Exception e ) { if ( e instanceof  Closed Channel Exception ) { return _ BOOL ; }  String msg = e . get Message ( ) ; if ( msg == null ) { msg = e . to String ( ) ; } msg = msg . to Lower Case ( ) ; return ( msg . index Of ( _ STR ) >= _ NUM ) || ( msg . index Of ( _ STR ) >= _ NUM ) || ( msg . index Of ( _ STR ) >= _ NUM ) ; }
public boolean zone Export Masks Delete (  List <  Network Zoning Param > zoning Params ,  Collection <  URI > volume URIs ,  String step Id ) {  Network Zoning Param zoning Param = zoning Params . get ( _ NUM ) ; _log . info (  String . format ( _ STR , zoning Param . get Export Group Display ( ) ) ) ; return do Zone Export Masks Delete ( zoning Params , volume URIs , step Id ) ; }
protected int alignment Code (  String alignment ) { if ( alignment . equals (  LEFT ) ) return - _ NUM ; else if ( alignment . equals (  CENTER ) ) return _ NUM ; else if ( alignment . equals (  RIGHT ) ) return _ NUM ; else if ( alignment . equals (  DECIMAL ) ) return _ NUM ; else throw new  Illegal Argument Exception ( _ STR + alignment ) ; }
@  Suppress Warnings ( _ STR ) @  Override public void paint Icon (  Component c ,  Graphics g , int x , int y ) {  Sea Glass Painter painter = (  Sea Glass Painter )  UIManager . get ( prefix + _ STR + key ) ; if ( painter != null ) {  JComponent jc = ( c instanceof  JComponent ) ? (  JComponent ) c : null ;  Graphics2 D gfx = (  Graphics2 D ) g ; gfx . translate ( x , y ) ; painter . paint ( gfx , jc , width , height ) ; gfx . translate ( - x , - y ) ; } }
static  List <  Map <  String ,  Object > > query (  Result Set rs ) throws  SQLException {  List <  Map <  String ,  Object > > list = new  Array List <  Map <  String ,  Object > > ( ) ;  Result Set Meta Data meta = rs . get Meta Data ( ) ; int column Count = meta . get Column Count ( ) ; while ( rs . next ( ) ) {  Hash Map <  String ,  Object > map = new  Hash Map <  String ,  Object > ( ) ; for ( int i = _ NUM ; i < column Count ; i ++ ) { map . put ( meta . get Column Label ( i + _ NUM ) , rs . get Object ( i + _ NUM ) ) ; } list . add ( map ) ; } return list ; }
public static boolean is Quoted (  String name ) { return name != null && name . length ( ) != _ NUM && ( ( name . char At ( _ NUM ) == _ STR && name . char At ( name . length ( ) - _ NUM ) == _ STR ) || ( name . char At ( _ NUM ) == _ STR && name . char At ( name . length ( ) - _ NUM ) == _ STR ) ) ; }
public void add Scroll View Listener (  WXScroll View Listener scroll View Listener ) { if ( ! m Scroll View Listeners . contains ( scroll View Listener ) ) { m Scroll View Listeners . add ( scroll View Listener ) ; } }
boolean update (  Input Stream in ,  Output Stream out ,  Input Stream new Manifest ,  Jar Index jar Index ) throws  IOException {  Zip Input Stream zis = new  Zip Input Stream ( in ) ;  Zip Output Stream zos = new  Jar Output Stream ( out ) ;  Zip Entry e = null ; boolean found Manifest = _ BOOL ; boolean update Ok = _ BOOL ; if ( jar Index != null ) { add Index ( jar Index , zos ) ; } while ( ( e = zis . get Next Entry ( ) ) != null ) {  String name = e . get Name ( ) ; boolean is Manifest Entry = equals Ignore Case ( name ,  MANIFEST_ NAME ) ; if ( ( jar Index != null && equals Ignore Case ( name ,  INDEX_ NAME ) ) || (  Mflag && is Manifest Entry ) ) { continue ; } else if ( is Manifest Entry && ( ( new Manifest != null ) || ( ename != null ) ) ) { found Manifest = _ BOOL ; if ( new Manifest != null ) {  File Input Stream fis = new  File Input Stream ( mname ) ; boolean ambiguous = is Ambiguous Main Class ( new  Manifest ( fis ) ) ; fis . close ( ) ; if ( ambiguous ) { return _ BOOL ; } }  Manifest old = new  Manifest ( zis ) ; if ( new Manifest != null ) { old . read ( new Manifest ) ; } if ( ! update Manifest ( old , zos ) ) { return _ BOOL ; } } else { if ( ! entry Map . contains Key ( name ) ) {  Zip Entry e2 = new  Zip Entry ( name ) ; e2 . set Method ( e . get Method ( ) ) ; e2 . set Time ( e . get Time ( ) ) ; e2 . set Comment ( e . get Comment ( ) ) ; e2 . set Extra ( e . get Extra ( ) ) ; if ( e . get Method ( ) ==  Zip Entry .  STORED ) { e2 . set Size ( e . get Size ( ) ) ; e2 . set Crc ( e . get Crc ( ) ) ; } zos . put Next Entry ( e2 ) ; copy ( zis , zos ) ; } else {  File f = entry Map . get ( name ) ; add File ( zos , f ) ; entry Map . remove ( name ) ; entries . remove ( f ) ; } } } for (  File f : entries ) { add File ( zos , f ) ; } if ( ! found Manifest ) { if ( new Manifest != null ) {  Manifest m = new  Manifest ( new Manifest ) ; update Ok = ! is Ambiguous Main Class ( m ) ; if ( update Ok ) { if ( ! update Manifest ( m , zos ) ) { update Ok = _ BOOL ; } } } else if ( ename != null ) { if ( ! update Manifest ( new  Manifest ( ) , zos ) ) { update Ok = _ BOOL ; } } } zis . close ( ) ; zos . close ( ) ; return update Ok ; }
public void remove Movie Set (  Movie Set movie Set ) { synchronized ( root ) {  Movie Set Tree Node node = (  Movie Set Tree Node ) node Map . get ( movie Set ) ; int index = root . get Index ( node ) ; movie Set . remove Property Change Listener ( property Change Listener ) ; node Map . remove ( movie Set ) ; for (  Movie movie : movie Set . get Movies ( ) ) { node Map . remove ( movie ) ; movie . remove Property Change Listener ( property Change Listener ) ; } node . remove All Children ( ) ; node . remove From Parent ( ) ;  Tree Model Event event = new  Tree Model Event ( this , root . get Path ( ) , new int [ ] { index } , new  Object [ ] { node } ) ; for (  Tree Model Listener listener : listeners ) { listener . tree Nodes Removed ( event ) ; } } }
public static double prob To Log Odds ( double prob ) { if ( gr ( prob , _ NUM ) || ( sm ( prob , _ NUM ) ) ) { throw new  Illegal Argument Exception ( _ STR + _ STR + prob ) ; } double p =  SMALL + ( _ NUM - _ NUM *  SMALL ) * prob ; return  Math . log ( p / ( _ NUM - p ) ) ; }
public byte [ ] create Jar From Class Content ( final  String class Name , final  String content ) throws  IOException {  Byte Array Output Stream byte Array Output Stream = new  Byte Array Output Stream ( ) ; write Jar From Content ( class Name , content , byte Array Output Stream ) ; return byte Array Output Stream . to Byte Array ( ) ; }
public boolean restore Accessibility Focus (  Calendar Day day ) { if ( ( day . year != m Year ) || ( day . month != m Month ) || ( day . day > m Num Cells ) ) { return _ BOOL ; } m Touch Helper . set Focused Virtual View ( day . day ) ; return _ BOOL ; }
public  List <  V > values ( ) {  Array List <  V > list = new  Array List <  V > ( ) ; for ( long k : key Set ( ) ) {  V value = find ( k ) . value ; if ( value != null ) { list . add ( value ) ; } } return list ; }
public void message Item Details (  String str Class ,  String item ,  String description ,  String [ ] msg Option , int [ ] msg Number , int default Option ) {  Hash Map <  Integer ,  String > options = new  Hash Map <  Integer ,  String > ( msg Option . length ) ; for ( int i = _ NUM ; i < msg Option . length ; i ++ ) { options . put ( msg Number [ i ] , msg Option [ i ] ) ; } message Item Details ( str Class , description , item , options , default Option ) ; }
public void add Listener (  Search Listener listener ) { listeners . add ( listener ) ; }
protected double compute PLOFs (  Relation <  O > relation ,  KNNQuery <  O > knn ,  Writable Double Data Store pdists ,  Writable Double Data Store plofs ) {  Finite Progress progress PLOFs =  LOG . is Verbose ( ) ? new  Finite Progress ( _ STR , relation . size ( ) ,  LOG ) : null ; double nplof = _ NUM ; for (  DBIDIter iditer = relation . iter DBIDs ( ) ; iditer . valid ( ) ; iditer . advance ( ) ) { final  KNNList neighbors = knn . get KNNFor DBID ( iditer , kcomp + _ NUM ) ; int ks = _ NUM ; double sum = _ NUM ; for (  DBIDIter neighbor = neighbors . iter ( ) ; neighbor . valid ( ) && ks < kcomp ; neighbor . advance ( ) ) { if (  DBIDUtil . equal ( neighbor , iditer ) ) { continue ; } sum += pdists . double Value ( neighbor ) ; ks ++ ; } double plof =  Math Util . max ( pdists . double Value ( iditer ) * ks / sum , _ NUM ) ; if (  Double . is Na N ( plof ) ||  Double . is Infinite ( plof ) ) { plof = _ NUM ; } plofs . put Double ( iditer , plof ) ; nplof += ( plof - _ NUM ) * ( plof - _ NUM ) ;  LOG . increment Processed ( progress PLOFs ) ; }  LOG . ensure Completed ( progress PLOFs ) ; nplof = lambda *  Math . sqrt ( nplof / relation . size ( ) ) ; if (  LOG . is Debugging Fine ( ) ) {  LOG . debug Fine ( _ STR + nplof ) ; } return nplof > _ NUM ? nplof : _ NUM ; }
private void do Wait For (  Process process ) { start Read Stream Thread ( process . get Input Stream ( ) ) ; start Read Stream Thread ( process . get Error Stream ( ) ) ; try { process . wait For ( ) ; } catch (  Interrupted Exception e ) { log . warn ( _ STR , e ) ; } }
public static  String decode From Redirect ( final  String str ) { final  String class Method = _ STR ; if (  String Utils . is Empty ( str ) ) { debug . error ( class Method + _ STR ) ; return null ; } if ( debug . message Enabled ( ) ) { debug . message ( class Method + _ STR + str . length ( ) ) ; debug . message ( class Method + _ STR + str + _ STR ) ; } byte [ ] input =  Base64 . decode ( remove New Line Chars ( str ) ) ; if ( input == null || input . length == _ NUM ) { debug . error ( class Method + _ STR ) ; return null ; } input =  Arrays . copy Of ( input , input . length + _ NUM ) ; int buffer Length = _ NUM ; try { if ( buffer Len != null && ! buffer Len . is Empty ( ) ) { buffer Length =  Integer . parse Int ( buffer Len ) ; } } catch (  Number Format Exception nfe ) { debug . error ( class Method + _ STR , nfe ) ; }  Inflater inflater = new  Inflater ( _ BOOL ) ;  Inflater Input Stream inflater Input Stream = new  Inflater Input Stream ( new  Byte Array Input Stream ( input ) , inflater ) ;  Byte Array Output Stream bout = new  Byte Array Output Stream ( buffer Length ) ; try { int b = inflater Input Stream . read ( ) ; while ( b != - _ NUM ) { bout . write ( b ) ; b = inflater Input Stream . read ( ) ; } } catch (  IOException e ) { debug . error ( class Method + _ STR , e ) ; return null ; } finally {  IOUtils . close If Not Null ( inflater Input Stream ) ; }  String result ; try { result = bout . to String ( _ STR ) ; } catch (  Unsupported Encoding Exception uee ) { debug . error ( class Method + _ STR , uee ) ; return null ; } if ( debug . message Enabled ( ) ) { debug . message ( class Method + _ STR + result ) ; } return result ; }
public void and With (  Query Predicate predicate ) { children . add ( predicate ) ; }
public  MMRoll (  MMRandom rng , int count , int start , int keep ) { super ( count , start ) ; this . total = rng . random Int ( this . faces ) + this . min ; all . add Element ( this . total ) ; this . keep = keep ; }
private static boolean evaluate Options Rules (  List req Options ,  List reg Options ) { if ( req Options == null || reg Options == null || ( req Options . size ( ) == _ NUM ) ) { return _ BOOL ; }  Iterator i = req Options . iterator ( ) ; while ( i . has Next ( ) ) {  String option = (  String ) i . next ( ) ; if ( reg Options . contains ( option ) ) { return _ BOOL ; } } return _ BOOL ; }
public static void close Quietly (  Closeable closeable ) { if ( closeable != null ) { try { closeable . close ( ) ; } catch (  Runtime Exception rethrown ) { throw rethrown ; } catch (  Exception ignored ) { } } }
public void put One Data Point ( double value ) { try { queue . put ( value ) ; } catch (  Interrupted Exception e ) { throw new  Runtime Exception ( _ STR , e ) ; } }
public static int  Integer ( int min , int max ) { return random . next Int ( max - min + _ NUM ) + min ; }
public void test_simple Close On End ( ) {  Striterator iter = new  Striterator ( m_data . iterator ( ) ) ; assert True ( iter . is Open ( ) ) ; while ( iter . has Next ( ) ) { iter . next ( ) ; assert True ( iter . is Open ( ) ) ; } assert True ( ! iter . is Open ( ) ) ; }
public void push Draw List Head (  Psp Ge List list ) { synchronized ( draw List Queue ) { int array Size = draw List Queue . size ( ) ; if ( array Size > _ NUM ) {  Psp Ge List [ ] array = draw List Queue . to Array ( new  Psp Ge List [ array Size ] ) ;  Concurrent Linked Queue <  Psp Ge List > new Queue = new  Concurrent Linked Queue <  Psp Ge List > ( ) ;  Psp Ge List [ ] new Array = new  Psp Ge List [ array Size + _ NUM ] ; new Array [ _ NUM ] = list ; for ( int i = _ NUM ; i < array Size ; i ++ ) { new Array [ i + _ NUM ] = array [ i ] ; new Queue . add ( new Array [ i ] ) ; } draw List Queue = new Queue ; } else { draw List Queue . add ( list ) ; } } }
public  Driver Task split Volume Mirror (  List <  Volume Mirror > mirrors ) {  LOG . info ( _ STR ) ;  Dell SCDriver Task task = new  Dell SCDriver Task ( _ STR ) ;  String Builder err Buffer = new  String Builder ( ) ; int mirror Split = _ NUM ; for (  Volume Mirror mirror : mirrors ) { try {  Storage Center API api = connection Manager . get Connection ( mirror . get Storage System Id ( ) ) ; api . delete Mirror ( mirror . get Native Id ( ) ) ; task . set Status (  Task Status .  READY ) ; mirror Split ++ ; } catch (  Storage Center APIException |  Dell SCDriver Exception dex ) {  String error =  String . format ( _ STR , mirror . get Display Name ( ) , dex ) ;  LOG . error ( error ) ; err Buffer . append (  String . format ( _ STR , error ) ) ; } } task . set Message ( err Buffer . to String ( ) ) ; if ( mirror Split == mirrors . size ( ) ) { task . set Status (  Task Status .  READY ) ; } else if ( mirror Split == _ NUM ) { task . set Status (  Task Status .  FAILED ) ; } else { task . set Status (  Task Status .  PARTIALLY_ FAILED ) ; } return task ; }
public  String class Name Tip Text ( ) { return _ STR ; }
public void add Listener (  Search Listener listener ) { listeners . add ( listener ) ; }
public void close ( ) { if ( null != input Stream Reader ) {  Carbon Util . close Streams ( input Stream Reader ) ; } }
public double longing (  F f , int  N ) { return  Math . pow ( _ NUM - p ( f ) ,  N ) ; }
public  Default Wind Dataset (  String [ ] series Names ,  Object [ ] [ ] [ ] data ) { this (  Arrays . as List ( series Names ) , data ) ; }
public synchronized int read ( byte b [ ] , int off , int len ) throws  IOException { ensure Open ( ) ; if ( ( off < _ NUM ) || ( off > b . length ) || ( len < _ NUM ) || ( ( off + len ) > b . length ) || ( ( off + len ) < _ NUM ) ) { throw new  Index Out Of Bounds Exception ( ) ; } else if ( len == _ NUM ) { return _ NUM ; } int avail = chunk Count - chunk Pos ; if ( avail <= _ NUM ) { if ( state ==  STATE_ READING_ CHUNK ) { return fast Read ( b , off , len ) ; } avail = read Ahead ( _ BOOL ) ; if ( avail < _ NUM ) { return - _ NUM ; } } int cnt = ( avail < len ) ? avail : len ;  System . arraycopy ( chunk Data , chunk Pos , b , off , cnt ) ; chunk Pos += cnt ; return cnt ; }
private static void expand Number At (  String number String , int start Index ,  Word Relation word Relation ,  Item token Item ) { expand Number ( number String . substring ( start Index , number String . length ( ) ) , word Relation , token Item ) ; }
public final void open Fallback Output Stream ( ) throws  Data Fallback Exception { if ( output == null ) { if (  LOG . is Debug Enabled ( ) )  LOG . debug ( _ STR + data File . get Name ( ) + _ STR ) ; try { output = new  Buffered Writer ( new  File Writer ( data File , _ BOOL ) ) ; } catch (  IOException e ) { throw new  Data Fallback Exception ( e . get Message ( ) ) ; } } }
public void notify Destroy Viewer ( ) throws  Canceled Exception { synchronized ( director Listeners ) { while ( director Listeners . size ( ) > _ NUM ) {  IDirector Listener director Listener = director Listeners . get ( _ NUM ) ; if ( director Listener != this ) director Listener . destroy View ( ) ; if ( director Listeners . size ( ) > _ NUM && director Listeners . get ( _ NUM ) == director Listener ) director Listeners . remove ( _ NUM ) ; } } while ( viewers . size ( ) > _ NUM ) { remove Viewer ( viewers . get ( _ NUM ) ) ; } if ( projects Changed Listener != null )  Project Manager . remove Projects Changed Listener ( projects Changed Listener ) ; if ( future != null && ! future . is Done ( ) ) { try { future . cancel ( _ BOOL ) ; } catch (  Exception ex ) { } future = null ; } }
public boolean is Accept ( int state ) { return is Accept . get ( state ) ; }
public  Web Resource create Request (  Client client ,  URI base URI ,  URI request Path ) {  URI full URI = base URI . resolve ( request Path ) ; return client . resource ( full URI ) ; }
public static final boolean is Ignorable IOException (  Exception e ) { if ( e instanceof  Closed Channel Exception ) { return _ BOOL ; }  String msg = e . get Message ( ) ; if ( msg == null ) { msg = e . to String ( ) ; } msg = msg . to Lower Case ( ) ; return ( msg . index Of ( _ STR ) >= _ NUM ) || ( msg . index Of ( _ STR ) >= _ NUM ) || ( msg . index Of ( _ STR ) >= _ NUM ) ; }
public boolean retain All (  Abstract Byte List other ) { if ( other . size ( ) == _ NUM ) { if ( size == _ NUM ) return _ BOOL ; set Size ( _ NUM ) ; return _ BOOL ; } int limit = other . size ( ) - _ NUM ; int j = _ NUM ; for ( int i = _ NUM ; i < size ; i ++ ) { if ( other . index Of From To ( get Quick ( i ) , _ NUM , limit ) >= _ NUM ) set Quick ( j ++ , get Quick ( i ) ) ; } boolean modified = ( j != size ) ; set Size ( j ) ; return modified ; }
public static boolean contains All Uuids (  Parcel Uuid [ ] uuid A ,  Parcel Uuid [ ] uuid B ) { if ( uuid A == null && uuid B == null ) return _ BOOL ; if ( uuid A == null ) { return uuid B . length == _ NUM ? _ BOOL : _ BOOL ; } if ( uuid B == null ) return _ BOOL ;  Hash Set <  Parcel Uuid > uuid Set = new  Hash Set <  Parcel Uuid > (  Arrays . as List ( uuid A ) ) ; for (  Parcel Uuid uuid : uuid B ) { if ( ! uuid Set . contains ( uuid ) ) return _ BOOL ; } return _ BOOL ; }
public  Compute State create Instance ( ) throws  Exception {  Managed Object Reference vm ; if ( is Ovf Deploy ( ) ) { vm = deploy Ovf ( ) ; this . vm = vm ; } else { vm = create Vm ( ) ; if ( vm == null ) { return null ; } this . vm = vm ; }  Compute State state = new  Compute State ( ) ; state . resource Pool Link =  Vim Utils . first Non Null ( this . state . resource Pool Link , this . parent . resource Pool Link ) ; return state ; }
private void apply To (  Class Visitor v ,  Method m ) { if (  Log . is Logging On ( ) ) {  Log . log Line (  String . format ( _ STR , m . to Generic String ( ) ) ) ; } v . visit ( m ) ; }
public void test Compare To Equal Pos ( ) { byte a Bytes [ ] = { _ NUM , _ NUM , _ NUM , - _ NUM , - _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , - _ NUM , _ NUM , _ NUM , _ NUM , _ NUM } ; byte b Bytes [ ] = { _ NUM , _ NUM , _ NUM , - _ NUM , - _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , - _ NUM , _ NUM , _ NUM , _ NUM , _ NUM } ; int a Sign = _ NUM ; int b Sign = _ NUM ;  Big Integer a Number = new  Big Integer ( a Sign , a Bytes ) ;  Big Integer b Number = new  Big Integer ( b Sign , b Bytes ) ; assert Equals ( _ NUM , a Number . compare To ( b Number ) ) ; }
public void add Observer (  Observer observer ) { if ( observer == null ) { throw new  Null Pointer Exception ( ) ; } synchronized ( this ) { if ( ! observers . contains ( observer ) ) observers . add ( observer ) ; } }
public void rollback Link Block Snapshot Session Target (  URI system URI ,  URI snap Session URI ,  URI snapshot URI ,  String step Id ) {  Block Snapshot Session snap Session = _db Client . query Object (  Block Snapshot Session . class , snap Session URI ) ;  String Set linked Targets = snap Session . get Linked Targets ( ) ; if ( ( linked Targets == null ) || ( ! linked Targets . contains ( snapshot URI . to String ( ) ) ) ) { unlink Block Snapshot Session Target ( system URI , snap Session URI , snapshot URI ,  Boolean .  TRUE , step Id ) ; } else {  Workflow Step Completer . step Succeded ( step Id ) ; } }
public  List delete Cut Edges ( ) { compute Next CWEdges ( ) ; find Labeled Edge Rings ( dir Edges ) ;  List cut Lines = new  Array List ( ) ; for (  Iterator i = dir Edges . iterator ( ) ; i . has Next ( ) ; ) {  Polygonize Directed Edge de = (  Polygonize Directed Edge ) i . next ( ) ; if ( de . is Marked ( ) ) continue ;  Polygonize Directed Edge sym = (  Polygonize Directed Edge ) de . get Sym ( ) ; if ( de . get Label ( ) == sym . get Label ( ) ) { de . set Marked ( _ BOOL ) ; sym . set Marked ( _ BOOL ) ;  Polygonize Edge e = (  Polygonize Edge ) de . get Edge ( ) ; cut Lines . add ( e . get Line ( ) ) ; } } return cut Lines ; }
@  Override public void write ( char [ ] chr ) throws  IOException { out . write ( chr ) ; }
public void add All (  T [ ] items ) { if ( m Event Delegate != null ) m Event Delegate . add Data ( items == null ? _ NUM : items . length ) ; if ( items != null && items . length != _ NUM ) { synchronized ( m Lock ) {  Collections . add All ( m Objects , items ) ; } } int data Count = items == null ? _ NUM : items . length ; if ( m Observer != null ) m Observer . on Item Range Inserted ( get Count ( ) - data Count + _ NUM , data Count ) ; if ( m Notify On Change ) notify Item Range Inserted ( headers . size ( ) + get Count ( ) - data Count + _ NUM , data Count ) ; log ( _ STR + ( ( headers . size ( ) + get Count ( ) - data Count + _ NUM ) + _ STR + ( data Count ) ) ) ; }
public  String documentation Wiki Url ( ) { return properties . get Property ( _ STR ) ; }
public static void copy File (  File source File ,  File dest File ) throws  IOException { if ( ! source File . exists ( ) ) { throw new  IOException ( _ STR + source File . get Absolute Path ( ) ) ; } copy File ( new  File Input Stream ( source File ) , new  File Output Stream ( dest File ) ) ; }
public void remove Selection Listener ( final  Selection Listener listener ) { check Widget ( ) ; if ( listener == null ) {  SWT . error (  SWT .  ERROR_ NULL_ ARGUMENT ) ; } selection Listeners . remove ( listener ) ; }
public void push (  Class Node type ) { stack . add ( type ) ; }
public void handle Button1 Request (  Request Invocation Event event ) throws  Model Control Exception { submit Cycle = _ BOOL ;  Entities Model model = (  Entities Model ) get Model ( ) ;  AMProperty Sheet prop = (  AMProperty Sheet ) get Child (  PROPERTY_ ATTRIBUTE ) ;  String entity Type = (  String ) get Page Session Attribute (  ENTITY_ TYPE ) ;  String entity Name = (  String ) property Sheet Model . get Value (  ENTITY_ NAME ) ; entity Name = entity Name . trim ( ) ; try {  Map default Values = model . get Default Attribute Values ( entity Type , null , _ BOOL ) ;  Map values = prop . get Attribute Values ( default Values . key Set ( ) ) ;  String realm Name = (  String ) get Page Session Attribute (  AMAdmin Constants .  CURRENT_ REALM ) ; model . create Entity ( realm Name , entity Name , entity Type , values ) ; forward To Entities View Bean ( ) ; } catch (  AMConsole Exception e ) { set Inline Alert Message (  CCAlert .  TYPE_ ERROR , _ STR , e . get Message ( ) ) ; forward To ( ) ; } }
private static  Double compute Angle ( final  Geo Point point , final double sin Latitude , final double cos Latitude , final double sin Longitude , final double cos Longitude ) { final double x1 = point . x * cos Longitude + point . y * sin Longitude ; final double y1 = - point . x * sin Longitude + point . y * cos Longitude ; final double z1 = point . z ; final double y2 = y1 ; final double z2 = - x1 * sin Latitude + z1 * cos Latitude ; if (  Math . sqrt ( y2 * y2 + z2 * z2 ) <  Vector .  MINIMUM_ RESOLUTION ) { return null ; } return  Math . atan2 ( z2 , y2 ) ; }
private  Node rotate Left (  Node x ) {  Node y = x . right ; x . right = y . left ; y . left = x ; y . size = x . size ; x . size = _ NUM + size ( x . left ) + size ( x . right ) ; x . height = _ NUM +  Math . max ( height ( x . left ) , height ( x . right ) ) ; y . height = _ NUM +  Math . max ( height ( y . left ) , height ( y . right ) ) ; return y ; }
protected void on Result ( ) { }
public boolean add Agent (  IMoving Agent agent ) { if ( ! agents . contains ( agent ) ) { agents . add ( agent ) ; if ( agent instanceof  Hive ) { hives . add ( (  Hive ) agent ) ; } if ( agent instanceof  Food Source ) { food Sources . add ( (  Food Source ) agent ) ; } if ( agent instanceof  Obstacle ) obstacles . add ( (  Obstacle ) agent ) ; double r = agent . get Sphere Radius ( ) ; if ( r > max Agent Sphere Radius ) max Agent Sphere Radius = r ; return _ BOOL ; } return _ BOOL ; }
public  Day (  Date time ) { this ( time ,  Time Zone . get Default ( ) ,  Locale . get Default ( ) ) ; }
public void add Attribute (  Attribute attr ) { attrs . add Element ( attr ) ; }
public  Binary Out (  Socket socket ) { try {  Output Stream os = socket . get Output Stream ( ) ; out = new  Buffered Output Stream ( os ) ; } catch (  IOException e ) { e . print Stack Trace ( ) ; } }
public static boolean create File (  File target File ) { if ( target File . exists ( ) ) { if ( target File . is File ( ) ) return _ BOOL ; target File . delete ( ) ; } try { return target File . create New File ( ) ; } catch (  IOException e ) { return _ BOOL ; } }
public void test Zero Zero ( ) { byte a Bytes [ ] = { _ NUM } ; byte b Bytes [ ] = { _ NUM } ; int a Sign = _ NUM ; int b Sign = _ NUM ; byte r Bytes [ ] = { _ NUM } ;  Big Integer a Number = new  Big Integer ( a Sign , a Bytes ) ;  Big Integer b Number = new  Big Integer ( b Sign , b Bytes ) ;  Big Integer result = a Number . or ( b Number ) ; byte res Bytes [ ] = new byte [ r Bytes . length ] ; res Bytes = result . to Byte Array ( ) ; for ( int i = _ NUM ; i < res Bytes . length ; i ++ ) { assert True ( res Bytes [ i ] == r Bytes [ i ] ) ; } assert Equals ( _ STR , _ NUM , result . signum ( ) ) ; }
protected int execute Prepare (  Table table ,  List <  Column > columns ,  String  SQL , boolean keep , int type ) throws  SQLException { int bind No = _ NUM ;  Prepared Statement statement = null ; int affected Rows = _ NUM ; try { statement = db Conn . prepare Statement (  SQL ) ; for (  Column c : columns ) { set Column Value ( statement , bind No , c ) ; bind No ++ ; } affected Rows = statement . execute Update ( ) ; } finally { if ( statement != null && ! keep ) { statement . close ( ) ; statement = null ; } } if ( keep && type > - _ NUM ) table . set Statement ( type , statement ) ; return affected Rows ; }
public  Ldap User Token (  Authentication auth ,  String default Authority ) { this ( auth , new  Granted Authority Impl ( default Authority ) ) ; }
public static void check Not Null Or Empty (  String string ,  String message ) { if ( string == null || string . is Empty ( ) ) { throw new  Illegal Argument Exception ( message ) ; } }
public void shutdown Now ( ) { if ( pool Running ( ) ) { try {  Thread . sleep ( _ NUM ) ; } catch (  Exception e ) { } } if ( image Download Executor != null && ! image Download Executor . is Terminated ( ) ) { image Download Executor . shutdown Now ( ) ; } if ( unnamed Task Executor != null && ! unnamed Task Executor . is Terminated ( ) ) { unnamed Task Executor . shutdown Now ( ) ; } if ( download Executor != null && ! download Executor . is Terminated ( ) ) { download Executor . shutdown Now ( ) ; } if ( main Task Executor != null && ! main Task Executor . is Terminated ( ) ) { main Task Executor . shutdown Now ( ) ; } if ( scheduler != null && ! scheduler . is Terminated ( ) ) { scheduler . shutdown Now ( ) ; } }
private char read Escape Character ( ) throws  IOException { if ( pos == limit && ! fill Buffer ( _ NUM ) ) { throw syntax Error ( _ STR ) ; } char escaped = buffer [ pos ++ ] ; switch ( escaped ) { case _ STR : if ( pos + _ NUM > limit && ! fill Buffer ( _ NUM ) ) { throw syntax Error ( _ STR ) ; }  String hex = string Pool . get ( buffer , pos , _ NUM ) ; pos += _ NUM ; return ( char )  Integer . parse Int ( hex , _ NUM ) ; case _ STR : return _ STR ; case _ STR : return _ STR ; case _ STR : return _ STR ; case _ STR : return _ STR ; case _ STR : return _ STR ; case _ STR : case _ STR : case _ STR : default : return escaped ; } }
private void fix Spanned With Spaces (  Spannable String Builder builder , int width Measure Spec , int height Measure Spec ) { long start Fix =  System . current Time Millis ( ) ;  Fixing Result result = add Spaces Around Spans Until Fixed ( builder , width Measure Spec , height Measure Spec ) ; if ( result . fixed ) { remove Unneeded Spaces ( width Measure Spec , height Measure Spec , builder , result ) ; } else { fallback To String ( width Measure Spec , height Measure Spec ) ; } if (  Build Config .  DEBUG ) { long fix Duration =  System . current Time Millis ( ) - start Fix ;  Log . d (  Html Text View .  TAG , _ STR + fix Duration ) ; } }
public  Count Integration Test ( ) { set Response Log Length Limit ( _ NUM ) ; date Format = new  Simple Date Format ( _ STR ) ;  Calendar cal =  Calendar . get Instance ( ) ; cal . add (  Calendar .  DATE , - _ NUM ) ; yesterday = date Format . format ( cal . get Time ( ) ) ; yesterday += _ STR ; cal =  Calendar . get Instance ( ) ; cal . add (  Calendar .  DATE , _ NUM ) ; today = date Format . format ( cal . get Time ( ) ) ; today += _ STR ; cal =  Calendar . get Instance ( ) ; cal . add (  Calendar .  DATE , _ NUM ) ; tomorrow = date Format . format ( cal . get Time ( ) ) ; tomorrow += _ STR ; cal =  Calendar . get Instance ( ) ; cal . add (  Calendar .  DATE , _ NUM ) ; tomorrow Plus3 = date Format . format ( cal . get Time ( ) ) ; tomorrow Plus3 += _ STR ; cal =  Calendar . get Instance ( ) ; cal . add (  Calendar .  DATE , _ NUM ) ; tomorrow Plus2 = date Format . format ( cal . get Time ( ) ) ; tomorrow Plus2 += _ STR ; cal =  Calendar . get Instance ( ) ; cal . add (  Calendar .  DATE , _ NUM ) ; tomorrow Plus1 = date Format . format ( cal . get Time ( ) ) ; tomorrow Plus1 += _ STR ; cal =  Calendar . get Instance ( ) ; cal . add (  Calendar .  DATE , - _ NUM ) ; yesterday Minus3 = date Format . format ( cal . get Time ( ) ) ; yesterday Minus3 += _ STR ; experiment =  Experiment Factory . create Experiment ( ) ; experiment . start Time = yesterday ; experiment . end Time = tomorrow Plus3 ; experiment . sampling Percent = _ NUM ; experiment . label = _ STR ; experiment . application Name =  QBO +  UUID . random UUID ( ) ;  Default Name Exclusion Strategy experiment Comparison Strategy = new  Default Name Exclusion Strategy ( _ STR , _ STR , _ STR ) ; experiment . set Serialization Strategy ( experiment Comparison Strategy ) ; }
protected  Metric reduce (  List <  Metric > metrics ) {  System Assert . require Argument ( metrics != null , _ STR ) ;  Metric Distiller distiller = new  Metric Distiller ( ) ; distiller . distill ( metrics ) ;  Map <  Long ,  List <  String > > collated = collate ( metrics ) ;  Map <  Long ,  String > min Datapoints = reduce ( collated , metrics ) ;  String new Metric Name = distiller . get Metric ( ) == null ? default Metric Name : distiller . get Metric ( ) ;  Metric new Metric = new  Metric ( default Scope , new Metric Name ) ; new Metric . set Display Name ( distiller . get Display Name ( ) ) ; new Metric . set Units ( distiller . get Units ( ) ) ; new Metric . set Tags ( distiller . get Tags ( ) ) ; new Metric . set Datapoints ( min Datapoints ) ; return new Metric ; }
@  Override public boolean is Inside (  Point point ) { return entity Rect . contains ( point . x , point . y ) ; }
@  Suppress Warnings ( _ STR ) private static void load Extensions ( final  Class Loader class Loader ) { for ( final  Map .  Entry <  Class ,  Set <  Class > > entry : definition Map . entry Set ( ) ) { final  Service Loader < ? > service Loader =  Service Loader . load ( entry . get Key ( ) , class Loader ) ; for ( final  Object o : service Loader ) { register Service Class ( o . get Class ( ) , extension Classloader Lookup , class Loader , entry . get Value ( ) ) ; } } }
public static synchronized  Collection <  String > all Local Ips ( ) {  List <  String > ips = new  Array List < > ( _ NUM ) ; try {  Enumeration <  Network Interface > itfs =  Network Interface . get Network Interfaces ( ) ; if ( itfs != null ) { for (  Network Interface itf : as Iterable ( itfs ) ) { if ( ! itf . is Loopback ( ) ) {  Enumeration <  Inet Address > addrs = itf . get Inet Addresses ( ) ; for (  Inet Address addr : as Iterable ( addrs ) ) {  String host Addr = addr . get Host Address ( ) ; if ( ! addr . is Loopback Address ( ) && ! ips . contains ( host Addr ) ) ips . add ( host Addr ) ; } } } } } catch (  Socket Exception ignore ) { return  Collections . empty List ( ) ; }  Collections . sort ( ips ) ; return ips ; }
private  Bitmap compress (  String image Path , int width , int height ) {  Bitmap Factory .  Options options = new  Bitmap Factory .  Options ( ) ; options . in Just Decode Bounds = _ BOOL ;  Bitmap Factory . decode File ( image Path , options ) ; int out H = options . out Height ; int out W = options . out Width ; int in Sample Size = _ NUM ; if ( out H > height || out W > width ) { int half H = out H / _ NUM ; int half W = out W / _ NUM ; while ( ( half H / in Sample Size ) > height && ( half W / in Sample Size ) > width ) { in Sample Size *= _ NUM ; } } options . in Sample Size = in Sample Size ; options . in Just Decode Bounds = _ BOOL ; int height Ratio = ( int )  Math . ceil ( options . out Height / ( float ) height ) ; int width Ratio = ( int )  Math . ceil ( options . out Width / ( float ) width ) ; if ( height Ratio > _ NUM || width Ratio > _ NUM ) { if ( height Ratio > width Ratio ) { options . in Sample Size = height Ratio ; } else { options . in Sample Size = width Ratio ; } } options . in Just Decode Bounds = _ BOOL ; return  Bitmap Factory . decode File ( image Path , options ) ; }
public static boolean is Sync Status (  Context context ,  String status ) { if (  Text Utils . is Empty ( status ) ) { return _ BOOL ; }  String [ ] statuses = get Sync Statuses ( context ) ; if ( statuses == null ) { return _ BOOL ; } for (  String s : statuses ) { if ( s . equals ( status ) ) { return _ BOOL ; } } return _ BOOL ; }
@  Override public final boolean is Magic Word (  String in ) { return in . matches ( _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR ) ; }
public void remove Channel Map (  Channel Map channel Map ) { if ( m Channel Maps . contains ( channel Map ) ) { int index = m Channel Maps . index Of ( channel Map ) ; m Channel Maps . remove ( channel Map ) ; fire Interval Removed ( this , index , index ) ; broadcast ( new  Channel Map Event ( channel Map ,  Event .  DELETE ) ) ; } }
@  Override public boolean add (  E o ) { return offer ( o ) ; }
public  Object put (  Object key ,  Object value ) { process Queue ( ) ; return map . put (  Key . create ( key , queue ) , value ) ; }
public  Id Range [ ] parse Id Range (  Imap Session session ) throws  Decoding Exception { if ( session != null ) { char c = next Word Char ( ) ; if ( c == _ STR ) { consume ( ) ; return  Search Res Util . get Saved Sequence Set ( session ) ; } }  Character Validator validator = new  Message Set Char Validator ( ) ;  String next Word = consume Word ( validator , _ BOOL ) ; int comma Pos = next Word . index Of ( _ STR ) ; if ( comma Pos == - _ NUM ) { return new  Id Range [ ] { parse Range ( next Word ) } ; }  Array List <  Id Range > range List = new  Array List <  Id Range > ( ) ; int pos = _ NUM ; while ( comma Pos != - _ NUM ) {  String range = next Word . substring ( pos , comma Pos ) ;  Id Range set = parse Range ( range ) ; range List . add ( set ) ; pos = comma Pos + _ NUM ; comma Pos = next Word . index Of ( _ STR , pos ) ; }  String range = next Word . substring ( pos ) ; range List . add ( parse Range ( range ) ) ;  List <  Id Range > merged =  Id Range . merge Ranges ( range List ) ; return (  Id Range [ ] ) merged . to Array ( new  Id Range [ merged . size ( ) ] ) ; }
public static  String to String (  Object value ) { if ( value == null ) { return null ; } return value . to String ( ) ; }
public boolean add Main Task (  Tmm Thread Pool new Task ) { boolean result = _ BOOL ; new Task . add Listener ( this ) ; new Task . set State (  Task State .  QUEUED ) ; main Task Executor . execute ( new Task ) ; return result ; }
private static boolean create Zynamics Directory ( ) { final  File dir = new  File (  Config Helper . get Zynamics Directory (  Constants .  COMPANY_ NAME ) ) ; return dir . exists ( ) || dir . mkdir ( ) ; }
public void update Button Action Performed ( ) { node Type = node Type Box . get Selected Index ( ) ; log . debug ( _ STR + cur Node . get Node Type ( ) + _ STR + node Type ) ; if ( cur Node . get Node Type ( ) != node Type ) { cur Node . set Node Type ( node Type ) ; } set Node Parameters ( ) ; changed Node = _ BOOL ; edit Mode = _ BOOL ; cur Node = null ; add Button . set Visible ( _ BOOL ) ; edit Button . set Visible ( _ BOOL ) ; delete Button . set Visible ( _ BOOL ) ; done Button . set Visible ( _ BOOL ) ; update Button . set Visible ( _ BOOL ) ; cancel Button . set Visible ( _ BOOL ) ; node Addr Field . set Visible ( _ BOOL ) ; node Addr Static . set Visible ( _ BOOL ) ; status Text2 . set Text ( std Status2 ) ; status Text3 . set Text ( std Status3 ) ; status Text1 . set Text ( rb . get String ( _ STR ) + _ STR +  Integer . to String ( node Address ) ) ; error In Status1 = _ BOOL ; }
public  Iterator <  String > file Name Iterator ( ) { return result List . iterator ( ) ; }
public void invalidate ( long new File Size ) { if ( new File Size < file Size ) { file Size = new File Size ; counters . clear ( ) ; block Size = calc Block Size ( file Size ) ; } else if ( new File Size > file Size ) compact ( new File Size ) ; }
protected  Snmp Cached Data update Cached Datas (  Object user Data ) { final  String [ ] path =  Jvm Runtime Impl . get Boot Class Path ( user Data ) ; final long time =  System . current Time Millis ( ) ; final int len = path . length ;  Snmp Oid indexes [ ] = new  Snmp Oid [ len ] ; for ( int i = _ NUM ; i < len ; i ++ ) { indexes [ i ] = new  Snmp Oid ( i + _ NUM ) ; } return new  Snmp Cached Data ( time , indexes , path ) ; }
public  DUpgrade Crypto Strength (  JFrame parent ) { super ( parent , res . get String ( _ STR ) ,  Dialog .  Modality Type .  DOCUMENT_ MODAL ) ; init Components ( ) ; }
public static  String join Objects (  String sep ,  Iterable < ? > l ) { return sep List ( sep , l , - _ NUM ) ; }
public void remove ( final  T object ) { synchronized ( m Lock ) { m List . remove ( object ) ; } notify Data Set Changed ( ) ; }
public boolean verify Signature ( byte [ ] signature ) { content Digest . do Final ( m Dash , m Dash . length - h Len - s Len ) ; try { byte [ ] b = cipher . process Block ( signature , _ NUM , signature . length ) ;  System . arraycopy ( b , _ NUM , block , block . length - b . length , b . length ) ; } catch (  Exception e ) { return _ BOOL ; } if ( block [ block . length - _ NUM ] != trailer ) { clear Block ( block ) ; return _ BOOL ; } byte [ ] db Mask = mask Generator Function1 ( block , block . length - h Len - _ NUM , h Len , block . length - h Len - _ NUM ) ; for ( int i = _ NUM ; i != db Mask . length ; i ++ ) { block [ i ] ^= db Mask [ i ] ; } block [ _ NUM ] &= ( _ NUM > > ( ( block . length * _ NUM ) - em Bits ) ) ; for ( int i = _ NUM ; i != block . length - h Len - s Len - _ NUM ; i ++ ) { if ( block [ i ] != _ NUM ) { clear Block ( block ) ; return _ BOOL ; } } if ( block [ block . length - h Len - s Len - _ NUM ] != _ NUM ) { clear Block ( block ) ; return _ BOOL ; }  System . arraycopy ( block , block . length - s Len - h Len - _ NUM , m Dash , m Dash . length - s Len , s Len ) ; content Digest . update ( m Dash , _ NUM , m Dash . length ) ; content Digest . do Final ( m Dash , m Dash . length - h Len ) ; for ( int i = block . length - h Len - _ NUM , j = m Dash . length - h Len ; j != m Dash . length ; i ++ , j ++ ) { if ( ( block [ i ] ^ m Dash [ j ] ) != _ NUM ) { clear Block ( m Dash ) ; clear Block ( block ) ; return _ BOOL ; } } clear Block ( m Dash ) ; clear Block ( block ) ; return _ BOOL ; }
protected double optimal Bandwidth ( int dim ) { double hopt = _ NUM *  Gamma Distribution . gamma ( dim / _ NUM + _ NUM ) * ( dim + _ NUM ) *  Math Util . powi ( _ NUM , dim ) ; return hopt *  Math . pow ( relation . size ( ) , ( - _ NUM / ( dim + _ NUM ) ) ) ; }
public static void open Imdb For Person (  Context context ,  String name ) { if ( context == null ||  Text Utils . is Empty ( name ) ) { return ; }  Intent intent = new  Intent (  Intent .  ACTION_ VIEW ,  Uri . parse (  String . format (  IMDB_ APP_ PERSON_ SEARCH_ URI , name ) ) ) ; intent . add Flags (  Intent .  FLAG_ ACTIVITY_ CLEAR_ WHEN_ TASK_ RESET ) ; if ( !  Utils . try Start Activity ( context , intent ) ) { intent = new  Intent (  Intent .  ACTION_ VIEW ,  Uri . parse (  String . format (  IMDB_ PERSON_ SEARCH_ URL , name ) ) ) ; intent . add Flags (  Intent .  FLAG_ ACTIVITY_ CLEAR_ WHEN_ TASK_ RESET ) ; context . start Activity ( intent ) ; } }
public static int round ( final float x ) { final int bits =  Float . float To Raw Int Bits ( x ) ; final int biased Exp = ( bits > > _ NUM ) & _ NUM ; final int shift = ( _ NUM - _ NUM +  Float .  MAX_ EXPONENT ) - biased Exp ; if ( ( shift & - _ NUM ) == _ NUM ) { int extended Mantissa = _ NUM | ( bits & _ NUM ) ; if ( bits < _ NUM ) { extended Mantissa = - extended Mantissa ; } return ( ( extended Mantissa > > shift ) + _ NUM ) > > _ NUM ; } else { return ( int ) x ; } }
public static  Plain Text plain ( byte text ) { return plain (  Integer . to String ( text ) ) ; }
public final void to String (  String Builder builder ) { builder . append ( get Name ( ) ) ; }
public static synchronized void fit (  String description ,  Unsafe Block block ) { fit ( description , identity ( ) , block ) ; }
public static boolean make Dirs For File ( final  File file ) { if ( file == null ) return _ BOOL ;  Log . d ( _ STR , _ STR + file + _ STR + file . is Directory ( ) ) ; final  String file Parent Dir = file . get Parent ( ) ; final  File file Dir =  Text Utils . is Empty ( file Parent Dir ) ? null : new  File ( file . get Parent ( ) ) ; boolean is Succeed = file Dir == null || file Dir . exists ( ) ; if ( is Succeed )  Log . d ( _ STR , _ STR + file Dir + _ STR + is Succeed ) ; if ( ! is Succeed && file Dir != null ) { is Succeed = file Dir . mkdirs ( ) ;  Log . d ( _ STR , _ STR + file Dir + _ STR + is Succeed ) ; } return is Succeed ; }
public  String to String ( ) { return to String ( null ) ; }
private void add Id Repo (  String org Name ,  String name ) throws  Id Repo Exception ,  SSOException { if ( debug . message Enabled ( ) ) { debug . message ( _ STR + org Name + _ STR + name ) ; }  Map config Map = null ; try {  Service Config sc = id Repo Service Config Manager . get Organization Config ( org Name , null ) ; if ( sc == null ) { debug . error ( _ STR + org Name + _ STR ) ;  Object [ ] args = { org Name } ; throw new  Id Repo Exception (  Id Repo Bundle .  BUNDLE_ NAME ,  Id Repo Error Code .  REALM_ DOESNT_ EXIST , args ) ; } sc = sc . get Sub Config ( name ) ; if ( sc == null ) { debug . error ( _ STR + org Name + _ STR + name ) ;  Object [ ] args = { org Name + _ STR + name } ; throw new  Id Repo Exception (  Id Repo Bundle .  BUNDLE_ NAME ,  Id Repo Error Code .  REALM_ DOESNT_ EXIST , args ) ; } config Map = sc . get Attributes ( ) ; } catch (  SMSException smse ) { if ( debug . warning Enabled ( ) ) { debug . warning ( _ STR + _ STR + org Name + _ STR + name , smse ) ; } return ; }  Id Repo repo = construct Id Repo Plugin ( org Name , config Map , name ) ; org Name =  DNUtils . normalize DN ( org Name ) ; synchronized ( idrepo Plugins ) { clear Read Only Plugins ( org Name ) ;  Map repos = (  Map ) idrepo Plugins . get ( org Name ) ; boolean add Internal Repos = _ BOOL ; if ( repos == null ) { repos = new  Linked Hash Map ( ) ; idrepo Plugins . put ( org Name , repos ) ; add Internal Repos = _ BOOL ; } repos . put ( name , repo ) ; if ( add Internal Repos ) { add Internal Repo ( repos , org Name ) ; } } }
public void read (  Byte Code Parser in ) throws  IOException { int length = in . read Int ( ) ; int exn Count = in . read Short ( ) ; for ( int i = _ NUM ; i < exn Count ; i ++ ) { int index = in . read Short ( ) ; if ( index == _ NUM ) { _methods . add ( null ) ; } } }
void add String ( int c ) { if ( strpos == str . length ) { char newstr [ ] = new char [ str . length * _ NUM ] ;  System . arraycopy ( str , _ NUM , newstr , _ NUM , str . length ) ; str = newstr ; } str [ strpos ++ ] = ( char ) c ; }
public final void compute Index ( ) { if ( index Computed ) { return ; }  List <  Long > cell List =  Lists . new Array List ( ) ;  List <  Integer > edge List =  Lists . new Array List ( ) ; for ( int i = _ NUM ; i < get Num Edges ( ) ; ++ i ) {  S2 Point from = edge From ( i ) ;  S2 Point to = edge To ( i ) ;  Array List <  S2 Cell Id > cover =  Lists . new Array List ( ) ; int level = get Covering ( from , to , _ BOOL , cover ) ; minimum S2 Level Used =  Math . min ( minimum S2 Level Used , level ) ; for (  S2 Cell Id cell Id : cover ) { cell List . add ( cell Id . id ( ) ) ; edge List . add ( i ) ; } } cells = new long [ cell List . size ( ) ] ; edges = new int [ edge List . size ( ) ] ; for ( int i = _ NUM ; i < cells . length ; i ++ ) { cells [ i ] = cell List . get ( i ) ; edges [ i ] = edge List . get ( i ) ; } sort Index ( ) ; index Computed = _ BOOL ; }
public static _ Fields find By Thrift Id ( int field Id ) { switch ( field Id ) { case _ NUM : return  NAME ; case _ NUM : return  VALUE ; default : return null ; } }
public void add (  Repository Location repository Location ) { repository Locations . add ( repository Location ) ; }
double add Limited Delta ( double prev Val , double current Val , double delta ) { if ( delta == _ NUM ) return current Val ; double old Delta = current Val - prev Val ; if ( old Delta != _ NUM &&  Math . signum ( old Delta ) !=  Math . signum ( delta ) ) return current Val ; if ( delta > _ NUM ) { return prev Val +  Math . max ( delta , old Delta ) ; } else { return prev Val +  Math . min ( delta , old Delta ) ; } }
@  Override public  String to String ( ) { return this ; }
public boolean is Empty ( ) { return hmap . is Empty ( ) ; }
private int normalize ( final int coordinate , final int dialog Size , final int maximum ) { if ( coordinate + dialog Size > maximum ) { return maximum - dialog Size - _ NUM ; } else { return coordinate ; } }
public  String class Name Tip Text ( ) { return _ STR ; }
private static  String read Line (  String filename ) throws  IOException {  Buffered Reader reader = new  Buffered Reader ( new  File Reader ( filename ) , _ NUM ) ; try { return reader . read Line ( ) ; } finally { reader . close ( ) ; } }
public static int parse Int Default ( final  String s , final int def ) { if ( s == null ) { return def ; } int r ; try { r =  Integer . parse Int ( s ) ; } catch ( final  Number Format Exception e ) { r = def ; } return r ; }
protected void profile Created (  Profile profile ) { }
private void print UC ( int c ) { if ( c > _ NUM ) { out . print ( _ STR ) ; if ( c < _ NUM ) out . print ( _ STR ) ; out . print (  Integer . to Hex String ( c ) ) ; } else { out . print ( _ STR ) ; out . print (  Integer . to Octal String ( c ) ) ; } }
public static void create Views (  List <  Block > blocks ,  Block View Factory view Factory ,  Connection Manager connection Manager ,  Workspace View workspace View ) { for ( int i = _ NUM ; i < blocks . size ( ) ; i ++ ) { workspace View . add View ( view Factory . build Block Group Tree ( blocks . get ( i ) , connection Manager , null ) ) ; } }
protected void clear All Data (  SSOToken ID token ID ) { boolean removed = _ BOOL ;  String key = token ID . to String ( ) ; synchronized ( map Token IDs ) { removed = ( map Token IDs . remove ( key ) != null ) ; } }
public  DNetscape Revocation Url (  JDialog parent , byte [ ] value ) throws  IOException { super ( parent ) ; set Title ( res . get String ( _ STR ) ) ; init Components ( ) ; prepopulate With Value ( value ) ; }
public  File Operation Failed Exception (  String operation ,  String entity ,  String name ) { super (  String . format ( _error Message , operation , entity , name ) ) ; }
public void close ( ) { if ( null != input Stream Reader ) {  Carbon Util . close Streams ( input Stream Reader ) ; } }
public static  String encode ( byte [ ] a ) { if ( a == null || a . length == _ NUM ) { return _ STR ; } int [ ] cnt = new int [ _ NUM ] ; for ( int i = _ NUM ; i < a . length ; i ++ ) { cnt [ a [ i ] & _ NUM ] ++ ; } int shift = _ NUM ; int n Escapes = a . length ; for ( int i = _ NUM ; i < _ NUM ; i ++ ) { if ( i == _ STR ) { continue ; } int sum = cnt [ i ] + cnt [ ( i + _ NUM ) & _ NUM ] + cnt [ ( i + _ STR ) & _ NUM ] ; if ( sum < n Escapes ) { n Escapes = sum ; shift = i ; if ( n Escapes == _ NUM ) { break ; } } } int out Len = a . length + n Escapes + _ NUM ;  String Buffer out = new  String Buffer ( out Len ) ; out . append ( ( char ) shift ) ; for ( int i = _ NUM ; i < a . length ; i ++ ) { char c = ( char ) ( ( a [ i ] - shift ) & _ NUM ) ; if ( c == _ NUM ) { out . append ( ( char ) _ NUM ) ; out . append ( ( char ) _ NUM ) ; } else if ( c == _ NUM ) { out . append ( ( char ) _ NUM ) ; out . append ( ( char ) _ NUM ) ; } else if ( c == _ STR ) { out . append ( ( char ) _ NUM ) ; out . append ( ( char ) _ NUM ) ; } else { out . append ( c ) ; } } return out . to String ( ) ; }
public  SIPHeader parse SIPHeader (  String header ) throws  Parse Exception { int start = _ NUM ; int end = header . length ( ) - _ NUM ; try { while ( header . char At ( start ) <= _ NUM ) start ++ ; while ( header . char At ( end ) <= _ NUM ) end -- ; } catch (  Array Index Out Of Bounds Exception e ) { throw new  Parse Exception ( _ STR , _ NUM ) ; }  String Buffer buffer = new  String Buffer ( end + _ NUM ) ; int i = start ; int line Start = start ; boolean end Of Line = _ BOOL ; while ( i <= end ) { char c = header . char At ( i ) ; if ( c == _ STR || c == _ STR ) { if ( ! end Of Line ) { buffer . append ( header . substring ( line Start , i ) ) ; end Of Line = _ BOOL ; } } else { if ( end Of Line ) { end Of Line = _ BOOL ; if ( c == _ STR || c == _ STR ) { buffer . append ( _ STR ) ; line Start = i + _ NUM ; } else { line Start = i ; } } } i ++ ; } buffer . append ( header . substring ( line Start , i ) ) ; buffer . append ( _ STR ) ;  Header Parser hp =  Parser Factory . create Parser ( buffer . to String ( ) ) ; if ( hp == null ) throw new  Parse Exception ( _ STR , _ NUM ) ; return hp . parse ( ) ; }
private static int convert Linear RGBto SRGB ( int color ) { float input , output ; input = color / _ NUM ; if ( input <= _ NUM ) { output = input * _ NUM ; } else { output = ( _ NUM * ( ( float )  Math . pow ( input , ( _ NUM / _ NUM ) ) ) ) - _ NUM ; } return  Math . round ( output * _ NUM ) ; }
public void record End ( long metric , boolean success ) { final  String msg = _ STR + m Module Name + _ STR + m Run Id + _ STR + metric + _ STR + success ; m Usage Messages . add ( msg ) ;  Diagnostic . developer Log ( msg ) ; m Client . record End ( metric , m Module Name , m Run Id , success ) ; }
static float rotate X ( float p X , float p Y , float c X , float c Y , float angle In Degrees ) { double angle =  Math . to Radians ( angle In Degrees ) ; return ( float ) (  Math . cos ( angle ) * ( p X - c X ) -  Math . sin ( angle ) * ( p Y - c Y ) + c X ) ; }
public boolean is Pronounceable (  String word ) {  String lower Case Word = word . to Lower Case ( ) ; if ( prefix FSM == null || suffix FSM == null ) { throw new  Error ( _ STR ) ; } else { return ( prefix FSM . accept ( lower Case Word ) && suffix FSM . accept ( lower Case Word ) ) ; } }
public void compute Edge Ends (  Edge edge ,  List l ) {  Edge Intersection List ei List = edge . get Edge Intersection List ( ) ; ei List . add Endpoints ( ) ;  Iterator it = ei List . iterator ( ) ;  Edge Intersection ei Prev = null ;  Edge Intersection ei Curr = null ; if ( ! it . has Next ( ) ) return ;  Edge Intersection ei Next = (  Edge Intersection ) it . next ( ) ; do { ei Prev = ei Curr ; ei Curr = ei Next ; ei Next = null ; if ( it . has Next ( ) ) ei Next = (  Edge Intersection ) it . next ( ) ; if ( ei Curr != null ) { create Edge End For Prev ( edge , l , ei Curr , ei Prev ) ; create Edge End For Next ( edge , l , ei Curr , ei Next ) ; } } while ( ei Curr != null ) ; }
public boolean is Expired (  Repository Proxy Cache proxy Cache ) { long method Cache Time = proxy Cache . get Cache Time ( ) ; boolean unlimited Cache = method Cache Time <= _ NUM ;  File cache File = build File ( proxy Cache . get Cache Dir ( ) , proxy Cache . get File Name ( ) ,  DEFAULT_ FILE_ NAME ) ; if ( is Cached ( cache File ) ) { if ( unlimited Cache ) { return _ BOOL ; } long last Modified Time = file Manager . get Last Modified Time ( cache File ) ; boolean expired =  System . current Time Millis ( ) > ( last Modified Time + method Cache Time ) ; if ( expired ) { evict ( proxy Cache ) ; } return expired ; } return _ BOOL ; }
int adjust Text Width ( int width ) { max Text Width =  Math . max ( max Text Width , width ) ; return max Text Width ; }
public void enable Export ( boolean b ) { export Item . set Enabled ( b ) ; }
public void mouse Exited (  Mouse Event e ) { if (  Debug . debugging ( _ STR ) ) {  Debug . output ( get ID ( ) + _ STR ) ; } super . mouse Exited ( e ) ; if ( the Map == e . get Source ( ) ) { auto Zoom = _ BOOL ; point2 = null ; the Map . repaint ( ) ; } }
private byte [ ] read Page Header (  Page page ) { return page . read Bytes ( _ NUM , this . page Header Size ) ; }
public  Ids Query Builder add Ids (  Collection <  String > ids ) { values . add All ( ids ) ; return this ; }
private void skip (  Http Servlet Request request ,  Http Servlet Response response ) throws  IOException {  Print Writer out = response . get Writer ( ) ;  String label = request . get Parameter ( _ STR ) ;  Monitor mon = remove Mon ( label , null ,  DEFAULT_ UNITS ) ; if ( mon == null ) { out . println (  ERROR + _ STR ) ; } else { mon . skip ( ) ; out . println (  OK + _ STR + mon ) ; } }
public static  String base Uri Of ( final  Http Servlet Request request ) { final  String Buffer request Url = request . get Request URL ( ) ; return request Url != null ? request Url . substring ( _ NUM , request Url . index Of ( request . get Servlet Path ( ) ) ) : _ STR ; }
public  Hessian Debug Output Stream (  Output Stream os ,  Print Writer dbg ) { _os = os ; _state = new  Hessian Debug State ( dbg ) ; }
public void commit ( ) throws  JMSException { ensure Open ( ) ; ensure TX ( ) ; if ( _logger . is Loggable (  Level .  FINE ) ) { _logger . fine ( _ STR + _tx ) ; } try { send Messages ( this . sent Messages , _tx ) ; if ( _logger . is Loggable (  Level .  FINE ) ) { _logger . fine ( _ STR + _tx ) ; } commit Local Transaction ( ) ; renew Transaction ( ) ; } catch (  JMSException mf E ) { if ( _logger . is Loggable (  Level .  SEVERE ) ) { _logger . log (  Level .  SEVERE , _ STR , mf E ) ; _logger . log (  Level .  SEVERE , _ STR + _tx ) ; } try { rollback ( ) ; } catch (  JMSException e ) { if ( _logger . is Loggable (  Level .  SEVERE ) ) { _logger . log (  Level .  SEVERE , _ STR + _tx , e ) ; } }  Transaction Rolled Back Exception t E = new  Transaction Rolled Back Exception ( _ STR ) ; t E . set Linked Exception ( mf E ) ; throw t E ; } catch (  Transaction Exception te ) { if ( _logger . is Loggable (  Level .  SEVERE ) ) { _logger . log (  Level .  SEVERE , _ STR , te ) ; _logger . log (  Level .  SEVERE , _ STR + _tx ) ; } try { rollback ( ) ; } catch (  JMSException e ) { if ( _logger . is Loggable (  Level .  SEVERE ) ) { _logger . log (  Level .  SEVERE , _ STR + _tx , e ) ; } }  Transaction Rolled Back Exception e = new  Transaction Rolled Back Exception ( _ STR ) ; e . set Linked Exception ( te ) ; throw e ; } catch (  Remote Exception re ) { if ( _logger . is Loggable (  Level .  SEVERE ) ) { _logger . log (  Level .  SEVERE , _ STR , re ) ; _logger . log (  Level .  SEVERE , _ STR + _tx ) ; } try { rollback ( ) ; } catch (  JMSException e ) { }  Transaction Rolled Back Exception e = new  Transaction Rolled Back Exception ( _ STR ) ; e . set Linked Exception ( re ) ; throw e ; } catch (  Commit Failed Exception cfe ) { if ( _logger . is Loggable (  Level .  SEVERE ) ) { _logger . log (  Level .  SEVERE , _ STR , cfe . orig ) ; _logger . log (  Level .  SEVERE , _ STR + _tx ) ; } try { rollback ( ) ; } catch (  JMSException e ) { if ( _logger . is Loggable (  Level .  SEVERE ) ) { _logger . log (  Level .  SEVERE , _ STR + _tx , e ) ; } }  Transaction Rolled Back Exception e = new  Transaction Rolled Back Exception ( _ STR + _tx + _ STR ) ; e . set Linked Exception ( cfe . orig ) ; throw e ; } catch (  Transaction Create Exception tce ) { if ( _logger . is Loggable (  Level .  SEVERE ) ) { _logger . log (  Level .  SEVERE , _ STR , tce . orig ) ; _logger . log (  Level .  SEVERE , _ STR + _tx ) ; }  JMSException e = new  JMSException ( _ STR ) ; e . set Linked Exception ( tce . orig ) ; throw e ; } finally { sent Messages . clear ( ) ; unacked Messages . clear ( ) ; } }
public void close ( ) { for (  Entry entry : entry List ) { entry . close ( ) ; } entry List . clear ( ) ; }
public  List <  Boundary > populate Locations ( final  Long area Id ) {  List <  Boundary > location List = new  Linked List <  Boundary > ( ) ; try { location List = boundary Service . get Child Boundaries By Boundary Id ( area Id ) ; } catch ( final  Exception e ) {  LOGGER . error ( _ STR + e . get Message ( ) ) ; throw new  Application Runtime Exception ( _ STR , e ) ; }  LOGGER . info ( _ STR + location List . to String ( ) ) ; return location List ; }
private static  String read Name ( byte data [ ] , int offset ,  Hash Set <  Integer > jumps ) throws  IOException { int c = data [ offset ] & _ NUM ; if ( ( c & _ NUM ) == _ NUM ) { c = ( ( c & _ NUM ) << _ NUM ) + ( data [ offset + _ NUM ] & _ NUM ) ; if ( jumps . contains ( c ) ) { throw new  Dns Exception ( _ STR , _ STR ) ; } jumps . add ( c ) ; return read Name ( data , c , jumps ) ; } if ( c == _ NUM ) { return _ STR ; }  String s = new  String ( data , offset + _ NUM , c ) ;  String t = read Name ( data , offset + _ NUM + c , jumps ) ; if ( t . length ( ) > _ NUM ) { s = s + _ STR + t ; } return s ; }
public static byte [ ] copy ( byte [ ] bytes ) { if ( bytes == null ) return null ; byte [ ] result = new byte [ bytes . length ] ;  System . arraycopy ( bytes , _ NUM , result , _ NUM , bytes . length ) ; return result ; }
public static boolean is Expression Tree (  Tree tree ) { return tree instanceof  Expression Tree ; }
public int size ( ) { return nodes . size ( ) ; }
public void add To Global Blacklist (  String host , long timeout ) { if ( is Global Blacklist Enabled ( ) ) { synchronized ( global Blacklist ) { global Blacklist . put ( host , timeout ) ; } } }
public boolean has Node ( final  Node node ) { return nodes . contains ( node ) ; }
public static double standard Normal Pdf ( double x ) { double a = _ NUM / (  Math . sqrt ( _ NUM *  Math .  PI ) ) ; double b = - ( x ) * ( x ) / ( _ NUM ) ; return a *  Math . exp ( b ) ; }
private boolean replace Bad Entry (  KBucket Entry entry ) {  List <  KBucket Entry > entries Ref = entries ; for ( int i = _ NUM , n = entries Ref . size ( ) ; i < n ; i ++ ) {  KBucket Entry e = entries Ref . get ( i ) ; if ( e . needs Replacement ( ) ) { modify Main Bucket ( e , entry ) ; return _ BOOL ; } } return _ BOOL ; }
@  Override public void draw String (  String str , int x , int y ) { set State To Local ( ) ; m_printstream . println ( x Transform ( x Scale ( x ) ) + _ STR + y Transform ( y Scale ( y ) ) + _ STR + _ STR + escape ( str ) + _ STR ) ; }
public static boolean is Supported RPRemove Protection Virtual Pool Change (  Volume volume ,  Virtual Pool current Vpool ,  Virtual Pool new Vpool ,  Db Client db Client ,  String Buffer not Supp Reason Buff ) { s_logger . info (  String . format ( _ STR , current Vpool . get Label ( ) , new Vpool . get Label ( ) ) ) ; if ( is Same Virtual Pool ( current Vpool , new Vpool , not Supp Reason Buff ) ) { return _ BOOL ; } if ( volume . check For Rp ( ) &&  Virtual Pool . v Pool Specifies Protection ( current Vpool ) && !  Virtual Pool . v Pool Specifies Protection ( new Vpool ) ) {  List <  String > excluded = new  Array List <  String > ( ) ;  String [ ] exclude = new  String [ ] {  PROTECTION_ VARRAY_ SETTINGS ,  RP_ RPO_ VALUE ,  RP_ RPO_ TYPE ,  RP_ COPY_ MODE ,  ARRAY_ INFO ,  DRIVE_ TYPE ,  JOURNAL_ SIZE ,  JOURNAL_ VARRAY ,  JOURNAL_ VPOOL ,  MULTI_ VOLUME_ CONSISTENCY ,  METROPOINT ,  STANDBY_ JOURNAL_ VARRAY ,  STANDBY_ JOURNAL_ VPOOL } ; excluded . add All (  Arrays . as List ( exclude ) ) ; excluded . add All (  Arrays . as List (  GENERALLY_ EXCLUDED ) ) ;  Map <  String ,  Change > changes = analyze Changes ( current Vpool , new Vpool , null , excluded . to Array ( exclude ) , null ) ; if ( ! changes . is Empty ( ) ) { not Supp Reason Buff . append ( _ STR ) ; fill In Not Supported Reasons ( changes , not Supp Reason Buff ) ; s_logger . info ( _ STR + _ STR , not Supp Reason Buff . to String ( ) ) ; return _ BOOL ; } } else { s_logger . warn ( _ STR ) ; return _ BOOL ; } s_logger . info ( _ STR ) ; return _ BOOL ; }
private void write Object (  Object Output Stream oos ) throws  IOException { oos . write Object ( i Instant ) ; oos . write Object ( i Field . get Type ( ) ) ; }
public void add Included Tax (  Big Decimal amt ) { m_included Tax = m_included Tax . add ( amt ) ; }
public static double volume Union Scaled (  Spatial Comparable box1 ,  Spatial Comparable box2 , double scale ) { final int dim = assert Same Dimensionality ( box1 , box2 ) ; double volume = _ NUM ; for ( int i = _ NUM ; i < dim ; i ++ ) { final double min =  Math . min ( box1 . get Min ( i ) , box2 . get Min ( i ) ) ; final double max =  Math . max ( box1 . get Max ( i ) , box2 . get Max ( i ) ) ; volume *= ( max - min ) * scale ; } return volume ; }
void add Item ( final  Rounded Tool Item rounded Tool Item ) { items . add ( rounded Tool Item ) ; }
protected final void _load To Have At Least ( int min Available ) throws  IOException { if ( _input Stream == null ) { throw _construct Error ( _ STR + min Available + _ STR ) ; } int amount = _input End - _input Ptr ; if ( amount > _ NUM && _input Ptr > _ NUM ) { _curr Input Processed += _input Ptr ;  System . arraycopy ( _input Buffer , _input Ptr , _input Buffer , _ NUM , amount ) ; _input End = amount ; } else { _input End = _ NUM ; } _input Ptr = _ NUM ; while ( _input End < min Available ) { int count = _input Stream . read ( _input Buffer , _input End , _input Buffer . length - _input End ) ; if ( count < _ NUM ) { _close Input ( ) ; if ( count == _ NUM ) { throw new  IOException ( _ STR + amount + _ STR ) ; } throw _construct Error ( _ STR + min Available + _ STR + min Available + _ STR ) ; } _input End += count ; } }
public  Serial Message ( byte [ ] a , int l ) { super (  String . value Of ( a ) ) ; set Response Length ( l ) ; set Binary ( _ BOOL ) ; }
private void populate Method Cache ( ) {  String Buffer method Key ;  Method [ ] methods = get Accessible Methods ( clazz ) ; for ( int i = _ NUM ; i < methods . length ; i ++ ) {  Method method = methods [ i ] ;  Method public Method = get Public Method ( method ) ; if ( public Method != null ) { method Map . add ( public Method ) ; method Cache . put ( make Method Key ( public Method ) , public Method ) ; } } }
public static  String unify Line Separators (  String s ) { return unify Line Separators ( s ,  System . get Property ( _ STR ) ) ; }
public boolean outer Class Has Annotation (  Annotation annotation ) {  Class < ? > outer = type . get Declaring Class ( ) ; while ( outer != null ) {  Annotation Accessor accessor = new  Annotation Accessor ( supported Annotations , outer , ignore Annotation Failure ) ; if ( accessor . type Has ( annotation ) ) { return _ BOOL ; } outer = outer . get Declaring Class ( ) ; } return _ BOOL ; }
private  String build Tool Tip ( final  List <  Navi Node > nodes ) { final  String Builder tooltip = new  String Builder ( _ STR ) ; boolean first = _ BOOL ; for ( final  Navi Node graph Node : nodes ) { if ( ! first ) { tooltip . append ( _ STR ) ; } tooltip . append (  CNodes Display String . get Display String ( graph Node ) ) ; first = _ BOOL ; } return tooltip + _ STR ; }
public int [ ] read Labels ( ) throws  Exception { int labels [ ] = new int [ data Num ] ;  Buffered Reader tr Users = new  Buffered Reader ( new  Input Stream Reader ( new  File Input Stream ( label File ) ) ) ;  String line = _ STR ; while ( ( line = tr Users . read Line ( ) ) != null ) {  String [ ] strs = line . split ( _ STR ) ; labels [  Integer . value Of ( strs [ _ NUM ] ) ] =  Integer . value Of ( strs [ _ NUM ] ) ; } tr Users . close ( ) ; return labels ; }
public boolean add On Item Click Listener (  On Item Click Listener item Click Listener ) { return click Listeners . add ( item Click Listener ) ; }
@  Override int look For Selectable Position ( int position , boolean look Down ) { final  List Adapter adapter = m Adapter ; if ( adapter == null || is In Touch Mode ( ) ) { return  INVALID_ POSITION ; } final int count = adapter . get Count ( ) ; if ( ! m Are All Items Selectable ) { if ( look Down ) { position =  Math . max ( _ NUM , position ) ; while ( position < count && ! adapter . is Enabled ( position ) ) { position ++ ; } } else { position =  Math . min ( position , count - _ NUM ) ; while ( position >= _ NUM && ! adapter . is Enabled ( position ) ) { position -- ; } } if ( position < _ NUM || position >= count ) { return  INVALID_ POSITION ; } return position ; } else { if ( position < _ NUM || position >= count ) { return  INVALID_ POSITION ; } return position ; } }
public static  String pad Left ( final  String s , final int length ) { final int pad = length - s . length ( ) ; return pad > _ NUM ? get Space String ( pad ) + s : s ; }
public  Localized Text (  String text ,  Locale locale ) { this . text = text ; this . locale = ( locale == null ? null : locale . to String ( ) ) ; }
public static boolean is Cache Safe (  Class < ? > clazz ,  Class Loader class Loader ) {  Assert . not Null ( clazz , _ STR ) ; try {  Class Loader target = clazz . get Class Loader ( ) ; if ( target == null ) { return _ BOOL ; }  Class Loader cur = class Loader ; if ( cur == target ) { return _ BOOL ; } while ( cur != null ) { cur = cur . get Parent ( ) ; if ( cur == target ) { return _ BOOL ; } } return _ BOOL ; } catch (  Security Exception ex ) { return _ BOOL ; } }
public void write (  Print Stream out ) { out . println ( _ STR ) ; write ( out , first Capitalized ) ; out . println ( _ STR ) ; write ( out , not First Capitalized ) ; out . println ( _ STR ) ; write ( out , table ) ; }
public  Period normalized ( ) { long total Months = to Total Months ( ) ; long split Years = total Months / _ NUM ; int split Months = ( int ) ( total Months % _ NUM ) ; if ( split Years == years && split Months == months ) { return this ; } return create (  Math . to Int Exact ( split Years ) , split Months , days ) ; }
private void scan Identifier ( ) throws  IOException { count = _ NUM ; while ( _ BOOL ) { putc ( ch ) ; switch ( ch = in . read ( ) ) { case _ STR : case _ STR : case _ STR : case _ STR : case _ STR : case _ STR : case _ STR : case _ STR : case _ STR : case _ STR : case _ STR : case _ STR : case _ STR : case _ STR : case _ STR : case _ STR : case _ STR : case _ STR : case _ STR : case _ STR : case _ STR : case _ STR : case _ STR : case _ STR : case _ STR : case _ STR : case _ STR : case _ STR : case _ STR : case _ STR : case _ STR : case _ STR : case _ STR : case _ STR : case _ STR : case _ STR : case _ STR : case _ STR : case _ STR : case _ STR : case _ STR : case _ STR : case _ STR : case _ STR : case _ STR : case _ STR : case _ STR : case _ STR : case _ STR : case _ STR : case _ STR : case _ STR : case _ STR : case _ STR : case _ STR : case _ STR : case _ STR : case _ STR : case _ STR : case _ STR : case _ STR : case _ STR : case _ STR : case _ STR : break ; default : if ( !  Character . is Java Letter Or Digit ( ( char ) ch ) ) { id Value =  Identifier . lookup ( buffer String ( ) ) ; token = id Value . get Type ( ) ; return ; } } } }
public static void register Local Time MBean (  String container Name ) {  MBean Server m Bean Server = get MBean Server ( container Name ) ; if ( m Bean Server == null ) return ;  Local Time MBean local Time MBean = new  Local Time ( ) ;  Object Name obj Name =  Local Time Constants .  MBEAN_ NAME ; if ( ! m Bean Server . is Registered ( obj Name ) ) { try { m Bean Server . register MBean ( local Time MBean , obj Name ) ; } catch (  Instance Already Exists Exception e ) { } catch (  Not Compliant MBean Exception e ) { if ( _logger . is Loggable (  Level .  WARNING ) ) { _logger . log (  Level .  SEVERE , failed Local Time MBean Registration Message Prefix + container Name + _ STR , e ) ; } } catch (  MBean Registration Exception e ) { if ( _logger . is Loggable (  Level .  SEVERE ) ) { _logger . log (  Level .  SEVERE , failed Local Time MBean Registration Message Prefix + container Name + _ STR , e ) ; } } if ( _logger . is Loggable (  Level .  CONFIG ) ) { _logger . config ( successful Transport MBean Registration Message + container Name + _ STR ) ; } } }
@  Override void check After Unmarshalled ( ) { super . check After Unmarshalled ( ) ; assert Equals ( short Val . short Value ( ) , _ NUM ) ; assert Equals ( long Val , _ NUM ) ; assert Null ( a Arr ) ; assert Equals ( double Val , _ NUM ) ; }
@  Override public <  R ,  A >  Completable Future <  R > collect ( final  Collector < ? super  T ,  A ,  R > collector ) { return  Completable Future . supply Async ( null ) ; }
@  Suppress Warnings ( _ STR ) private  Object from Reflection Type ( final  Object value ) {  Field Descriptor descriptor = get Descriptor ( ) ; if ( descriptor . is Repeated ( ) ) { if ( descriptor . get Java Type ( ) ==  Field Descriptor .  Java Type .  MESSAGE || descriptor . get Java Type ( ) ==  Field Descriptor .  Java Type .  ENUM ) { final  List result = new  Array List ( ) ; for ( final  Object element : (  List ) value ) { result . add ( singular From Reflection Type ( element ) ) ; } return result ; } else { return value ; } } else { return singular From Reflection Type ( value ) ; } }
@  Override public  Foo fetch By Uuid_ C_ Last (  String uuid , long company Id ,  Order By Comparator <  Foo > order By Comparator ) { int count = count By Uuid_ C ( uuid , company Id ) ; if ( count == _ NUM ) { return null ; }  List <  Foo > list = find By Uuid_ C ( uuid , company Id , count - _ NUM , count , order By Comparator ) ; if ( ! list . is Empty ( ) ) { return list . get ( _ NUM ) ; } return null ; }
public static void show ( final  Window parent , final  INavi Instruction instruction ) throws  Internal Translation Exception { final  Reil Translator <  INavi Instruction > translator = new  Reil Translator <  INavi Instruction > ( ) ; final  Reil Graph reil Graph = translator . translate ( new  Standard Environment ( ) , instruction ) ; final  String text = reil Graph To Text ( reil Graph ) ; final  String title =  String . format ( _ STR , instruction . to String ( ) ) ; final  CReil Instruction Dialog dialog = new  CReil Instruction Dialog ( parent , title , text ) ;  Gui Helper . center Child To Parent ( parent , dialog , _ BOOL ) ; dialog . set Visible ( _ BOOL ) ; }
public static  String to String (  Reader reader , boolean buffered ) throws  IOException {  String Writer sw = new  String Writer ( _ NUM ) ; if ( buffered ) copy ( to Buffered Reader ( reader ) , sw , - _ NUM ) ; else copy ( reader , sw , - _ NUM ) ; sw . close ( ) ; return sw . to String ( ) ; }
private int compute Number Of Letters In Perfect Overlap (  Lane i Lane ,  Lane j Lane ) { final int first Coordinate =  Math . max ( i Lane . get First Non Gap Position ( ) , j Lane . get First Non Gap Position ( ) ) ; final int last Coordinate =  Math . min ( i Lane . get Last Non Gap Position ( ) , j Lane . get Last Non Gap Position ( ) ) ; int count = _ NUM ; for ( int i = first Coordinate ; i < last Coordinate ; i ++ ) { char i Char =  Character . to Lower Case ( i Lane . char At ( i ) ) ; char j Char =  Character . to Lower Case ( j Lane . char At ( i ) ) ; if ( i Char != j Char && i Char != _ STR && j Char != _ STR ) return _ NUM ; else if (  Character . is Letter ( i Char ) ) count ++ ; } return count ; }
public void force ( boolean metadata ) { mapped Buffer . force ( ) ; super . force ( metadata ) ; }
public  String prep Operand (  String label ,  Data Type dt ,  Value Type vt ) {  String Builder sb = new  String Builder ( ) ; sb . append ( label ) ; sb . append (  Lop .  DATATYPE_ PREFIX ) ; sb . append ( dt ) ; sb . append (  Lop .  VALUETYPE_ PREFIX ) ; sb . append ( vt ) ; return sb . to String ( ) ; }
public static  List <  Point2 D > divide Conquer Brownian Bridge ( double  D ,  Point2 D t0y0 ,  Point2 D t1y1 , int depth ,  Space Time Rejector1 D rejector ) {  List <  Point2 D > points = new  Linked List <  Point2 D > ( ) ; points . add ( t0y0 ) ; points . add ( t1y1 ) ; divide Conquer Brownian Bridge (  D , _ NUM , points , depth , rejector ) ; return points ; }
protected void print Doc Type (  Writer out ,  Doc Type doc Type ) throws  IOException {  String public ID = doc Type . get Public ID ( ) ;  String system ID = doc Type . get System ID ( ) ;  String internal Subset = doc Type . get Internal Subset ( ) ; boolean has Public = _ BOOL ; out . write ( _ STR ) ; out . write ( doc Type . get Element Name ( ) ) ; if ( public ID != null ) { out . write ( _ STR ) ; out . write ( public ID ) ; out . write ( _ STR ) ; has Public = _ BOOL ; } if ( system ID != null ) { if ( ! has Public ) { out . write ( _ STR ) ; } out . write ( _ STR ) ; out . write ( system ID ) ; out . write ( _ STR ) ; } if ( ( internal Subset != null ) && ( ! internal Subset . equals ( _ STR ) ) ) { out . write ( _ STR ) ; out . write ( line Separator ) ; out . write ( doc Type . get Internal Subset ( ) ) ; out . write ( _ STR ) ; } out . write ( _ STR ) ; }
private  List <  Double > to List ( double [ ] x ) {  List <  Double > result = new  Array List <  Double > ( ) ; for ( int i = _ NUM ; i < x . length ; i ++ ) { result . add ( x [ i ] ) ; } return result ; }
protected void accepted List Item (  Object selected ) { if ( selected == null || selected ==  ITEM_ More ) { set User Object ( null ) ; return ; } set User Object ( selected ) ; text Box . set Text ( convert User Object For Text Field ( selected ) ) ; }
public void handle Button1 Request (  Request Invocation Event event ) throws  Model Control Exception {  FSAuth Domains Model model = (  FSAuth Domains Model ) get Model ( ) ;  String name = (  String ) get Display Field Value ( model .  TF_ NAME ) ;  AMProperty Sheet ps = (  AMProperty Sheet ) get Child (  PROPERTY_ ATTRIBUTE ) ; try {  String realm = model . get Realm ( name ) ;  Map values = ps . get Attribute Values ( model . get Data Map ( ) , _ BOOL , model ) ; model . set Attribute Values ( realm , name , values ) ;  Serialized Field sz Cache = (  Serialized Field ) get Child (  SZ_ CACHE ) ;  Federation View Bean vb = (  Federation View Bean ) get View Bean (  Federation View Bean . class ) ;  CCAdd Remove add Remove List = (  CCAdd Remove ) get Child (  ADD_ REMOVE_ PROVIDERS ) ; add Remove List . restore State Data ( ) ;  CCAdd Remove Model add Remove Model = (  CCAdd Remove Model ) add Remove List . get Model ( ) ;  List list = new  Array List ( get Selected Values ( add Remove Model ) ) ; model . add Providers ( realm , name , list ) ; set Inline Alert Message (  CCAlert .  TYPE_ INFO , _ STR , _ STR ) ; forward To ( ) ; } catch (  AMConsole Exception e ) { set Inline Alert Message (  CCAlert .  TYPE_ ERROR , _ STR , e . get Message ( ) ) ; forward To ( ) ; } }
private  String abbreviate Description (  String description ) { if ( description == null ) { return null ; } if ( description . length ( ) <= _ NUM ) { return description ; } return description . substring ( _ NUM , _ NUM ) + _ STR ; }
public void test_ UTCIIIIII ( ) { assert True ( _ STR ,  Date .  UTC ( _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM ) == ( long ) _ NUM ) ; assert True ( _ STR ,  Date .  UTC ( _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM ) == ( long ) _ NUM * _ NUM * _ NUM * _ NUM * _ NUM ) ; }
public  ISO9796d2 Signer (  Asymmetric Block Cipher cipher ,  Digest digest , boolean implicit ) { this . cipher = cipher ; this . digest = digest ; if ( implicit ) { trailer =  TRAILER_ IMPLICIT ; } else {  Integer trailer Obj = (  Integer ) trailer Map . get ( digest . get Algorithm Name ( ) ) ; if ( trailer Obj != null ) { trailer = trailer Obj . int Value ( ) ; } else { throw new  Illegal Argument Exception ( _ STR ) ; } } }
public static byte [ ] decode (  String data ) throws  Coder Exception { byte [ ] array = new byte [ data . length ( ) * _ NUM / _ NUM ] ; char [ ] block = new char [ _ NUM ] ; int length = _ NUM ; data = data . trim ( ) ; final int len = data . length ( ) ; if ( len == _ NUM ) return new byte [ _ NUM ] ; if ( len % _ NUM != _ NUM || len < _ NUM ) throw new  Coder Exception ( _ STR + print String ( data ) + _ STR ) ; for ( int position = _ NUM ; position < len ; ) { int p ; for ( p = _ NUM ; p < _ NUM && position < data . length ( ) ; position ++ ) { char c = data . char At ( position ) ; if ( !  Character . is Whitespace ( c ) ) { block [ p ] = c ; p ++ ; } } if ( p == _ NUM ) break ; int l = decode Group ( block , array , length ) ; length += l ; if ( l < _ NUM ) break ; } return  Arrays . copy Of ( array , length ) ; }
public static <  T >  Set <  T > as Set (  T ... values ) { if ( values == null ) { return new  Hash Set <  T > ( _ NUM ) ; } else { return new  Hash Set <  T > (  Arrays . as List ( values ) ) ; } }
public static boolean is Samsung ( ) { return s Build Model . starts With ( _ STR ) || s Build Model . contains ( _ STR ) || s Build Model . starts With ( _ STR ) || s Build Model . starts With ( _ STR ) || s Build Model . starts With ( _ STR ) ; }
public static int last Index Of (  String orig ,  String string ) { return orig . last Index Of ( string , orig . length ( ) ) ; }
private  Concurrent Skip List Map .  Node <  K ,  V > lo Node ( ) { if ( lo == null ) return m . find First ( ) ; else if ( lo Inclusive ) return m . find Near ( lo ,  GT |  EQ ) ; else return m . find Near ( lo ,  GT ) ; }
public int size ( ) { return set . size ( ) ; }
public static boolean float Array Equals ( float [ ] x , float [ ] y , float tol ) { for ( int i = _ NUM ; i < x . length ; i += _ NUM ) { if ( x [ i ] == _ NUM ) { return y [ i ] == _ NUM ; } if (  Math . abs ( ( y [ i ] - x [ i ] ) / x [ i ] ) > tol ) { return _ BOOL ; } } return _ BOOL ; }
protected int map Drag Operation From Modifiers (  Mouse Event e ) { int mods = e . get Modifiers Ex ( ) ; int btns = mods &  Button Mask ; if ( ! ( btns ==  Input Event .  BUTTON1_ DOWN_ MASK || btns ==  Input Event .  BUTTON2_ DOWN_ MASK || btns ==  Input Event .  BUTTON3_ DOWN_ MASK ) ) { return  Dn DConstants .  ACTION_ NONE ; } return  Sun Drag Source Context Peer . convert Modifiers To Drop Action ( mods , get Source Actions ( ) ) ; }
public  On Update Clause add Assignment (  Expression expression ) { assignments . add ( new  Assignment ( expression ) ) ; return this ; }
public static  String layout Compound Label (  Font Metrics fm ,  String text ,  Icon icon , int vertical Alignment , int horizontal Alignment , int vertical Text Position , int horizontal Text Position ,  Rectangle view R ,  Rectangle icon R ,  Rectangle text R , int text Icon Gap ) { if ( icon != null ) { icon R . width = icon . get Icon Width ( ) ; icon R . height = icon . get Icon Height ( ) ; } else { icon R . width = icon R . height = _ NUM ; } boolean text Is Empty = ( text == null ) || ( text . equals ( _ STR ) ) ;  String rettext = _ STR ; if ( text Is Empty ) { text R . width = text R . height = _ NUM ; } else {  Dimension dim = new  Dimension (  Swing Utilities . compute String Width ( fm , text ) , fm . get Height ( ) ) ; text R . width = dim . width ; text R . height = dim . height ; } int gap = ( text Is Empty || ( icon == null ) ) ? _ NUM : text Icon Gap ; if ( ! text Is Empty ) { int avail Text Width ; if ( horizontal Text Position ==  CENTER ) { avail Text Width = view R . width ; } else { avail Text Width = view R . width - ( icon R . width + gap ) ; } if ( text R . width > avail Text Width ) {  String clip String = _ STR ; int total Width =  Swing Utilities . compute String Width ( fm , clip String ) ; int n Chars ; rettext = _ STR ; for ( n Chars = text . length ( ) - _ NUM ; n Chars >= _ NUM ; n Chars -- ) { total Width += fm . char Width ( text . char At ( n Chars ) ) ; if ( total Width > avail Text Width ) { break ; } rettext = text . char At ( n Chars ) + rettext ; } rettext = clip String + rettext ; text R . width =  Swing Utilities . compute String Width ( fm , rettext ) ; } } if ( vertical Text Position ==  TOP ) { if ( horizontal Text Position !=  CENTER ) { text R . y = _ NUM ; } else { text R . y = - ( text R . height + gap ) ; } } else if ( vertical Text Position ==  CENTER ) { text R . y = ( icon R . height / _ NUM ) - ( text R . height / _ NUM ) ; } else { if ( horizontal Text Position !=  CENTER ) { text R . y = icon R . height - text R . height ; } else { text R . y = ( icon R . height + gap ) ; } } if ( horizontal Text Position ==  LEFT ) { text R . x = - ( text R . width + gap ) ; } else if ( horizontal Text Position ==  CENTER ) { text R . x = ( icon R . width / _ NUM ) - ( text R . width / _ NUM ) ; } else { text R . x = ( icon R . width + gap ) ; } int label R_x =  Math . min ( icon R . x , text R . x ) ; int label R_width =  Math . max ( icon R . x + icon R . width , text R . x + text R . width ) - label R_x ; int label R_y =  Math . min ( icon R . y , text R . y ) ; int label R_height =  Math . max ( icon R . y + icon R . height , text R . y + text R . height ) - label R_y ; int dx , dy ; if ( vertical Alignment ==  TOP ) { dy = view R . y - label R_y ; } else if ( vertical Alignment ==  CENTER ) { dy = ( view R . y + ( view R . height / _ NUM ) ) - ( label R_y + ( label R_height / _ NUM ) ) ; } else { dy = ( view R . y + view R . height ) - ( label R_y + label R_height ) ; } if ( horizontal Alignment ==  LEFT ) { dx = view R . x - label R_x ; } else if ( horizontal Alignment ==  RIGHT ) { dx = ( view R . x + view R . width ) - ( label R_x + label R_width ) ; } else { dx = ( view R . x + ( view R . width / _ NUM ) ) - ( label R_x + ( label R_width / _ NUM ) ) ; } text R . x += dx ; text R . y += dy ; icon R . x += dx ; icon R . y += dy ; return rettext ; }
public  Abstract Network Connection Config (  Network Port Adapter p ) { adapter = p ; }
protected final void run On Ui Thread ( @  Non Null  Runnable runnable ) { if (  Looper . my Looper ( ) ==  Looper . get Main Looper ( ) ) { runnable . run ( ) ; } else { m Poster . post ( runnable ) ; } }
private  Attr Set combine OCs (  Creation Template ct ,  Attr Set a Set ) {  Attr attr = a Set . get Attribute ( _ STR ) ;  Attr def Attr = ct . get Attribute ( _ STR ) ;  Set add OCs = ( attr != null ) ?  Common Utils . string Array To Set ( attr . get String Values ( ) ) : new  Hash Set ( ) ;  Set ct OCs =  Common Utils . string Array To Set ( def Attr . get String Values ( ) ) ;  Set final OCs =  Common Utils . combine OCs ( add OCs , ct OCs ) ; a Set . remove ( _ STR ) ;  Attr final OCAttr = new  Attr ( _ STR , (  String [ ] ) final OCs . to Array ( new  String [ final OCs . size ( ) ] ) ) ; a Set . add ( final OCAttr ) ; return a Set ; }
public void remove NXWarrant (  Warrant w ) { w . remove Property Change Listener ( this ) ; _war List . remove ( w ) ; _war NX . remove ( w ) ; _manager . deregister ( w ) ; w . dispose ( ) ; }
public void remove Overflow Command (  Command cmd ) { overflow Commands . remove ( cmd ) ; }
public boolean connect ( final  String address ) { if ( m Bluetooth Adapter == null || address == null ) {  Log . w (  TAG , _ STR ) ; return _ BOOL ; } if ( m Bluetooth Device Address != null && address . equals ( m Bluetooth Device Address ) && m Bluetooth Gatt != null ) {  Log . d (  TAG , _ STR ) ; if ( m Bluetooth Gatt . connect ( ) ) { m Connection State =  STATE_ CONNECTING ; return _ BOOL ; } else { return _ BOOL ; } } final  Bluetooth Device device = m Bluetooth Adapter . get Remote Device ( address ) ; if ( device == null ) {  Log . d (  TAG , _ STR ) ; return _ BOOL ; } m Bluetooth Gatt = device . connect Gatt ( this , _ BOOL , m Gatt Callback ) ;  Log . d (  TAG , _ STR ) ; m Bluetooth Device Address = address ; m Connection State =  STATE_ CONNECTING ; return _ BOOL ; }
private double log Normal Dens ( double x , double mean , double std Dev ) { double diff = x - mean ; return - ( diff * diff / ( _ NUM * std Dev * std Dev ) ) - m_norm Const -  Math . log ( std Dev ) ; }
public  Shape inverse Transform (  Shape shape ) {  General Path new Path = new  General Path ( ) ; float [ ] coords = new float [ _ NUM ] ; for (  Path Iterator iterator = shape . get Path Iterator ( null ) ; iterator . is Done ( ) == _ BOOL ; iterator . next ( ) ) { int type = iterator . current Segment ( coords ) ; switch ( type ) { case  Path Iterator .  SEG_ MOVETO :  Point2 D p = inverse Transform ( new  Point2 D .  Float ( coords [ _ NUM ] , coords [ _ NUM ] ) ) ; new Path . move To ( ( float ) p . get X ( ) , ( float ) p . get Y ( ) ) ; break ; case  Path Iterator .  SEG_ LINETO : p = inverse Transform ( new  Point2 D .  Float ( coords [ _ NUM ] , coords [ _ NUM ] ) ) ; new Path . line To ( ( float ) p . get X ( ) , ( float ) p . get Y ( ) ) ; break ; case  Path Iterator .  SEG_ QUADTO : p = inverse Transform ( new  Point2 D .  Float ( coords [ _ NUM ] , coords [ _ NUM ] ) ) ;  Point2 D q = inverse Transform ( new  Point2 D .  Float ( coords [ _ NUM ] , coords [ _ NUM ] ) ) ; new Path . quad To ( ( float ) p . get X ( ) , ( float ) p . get Y ( ) , ( float ) q . get X ( ) , ( float ) q . get Y ( ) ) ; break ; case  Path Iterator .  SEG_ CUBICTO : p = inverse Transform ( new  Point2 D .  Float ( coords [ _ NUM ] , coords [ _ NUM ] ) ) ; q = inverse Transform ( new  Point2 D .  Float ( coords [ _ NUM ] , coords [ _ NUM ] ) ) ;  Point2 D r = inverse Transform ( new  Point2 D .  Float ( coords [ _ NUM ] , coords [ _ NUM ] ) ) ; new Path . curve To ( ( float ) p . get X ( ) , ( float ) p . get Y ( ) , ( float ) q . get X ( ) , ( float ) q . get Y ( ) , ( float ) r . get X ( ) , ( float ) r . get Y ( ) ) ; break ; case  Path Iterator .  SEG_ CLOSE : new Path . close Path ( ) ; break ; } } return new Path ; }
private void clear Context (  Context context ) throws  Naming Exception { for (  Naming Enumeration e = context . list Bindings ( _ STR ) ; e . has More Elements ( ) ; ) {  Binding binding = (  Binding ) e . next Element ( ) ; if ( binding . get Object ( ) instanceof  Context ) { clear Context ( (  Context ) binding . get Object ( ) ) ; } context . unbind ( binding . get Name ( ) ) ; } }
public void start ( final  Input Stream in ) throws  SAXException ,  IOException ,  Parser Configuration Exception {  SAXParser Factory factory =  SAXParser Factory . new Instance ( ) ;  SAXParser sax Parser = factory . new SAXParser ( ) ; sax Parser . parse ( in , this ) ; }
private void next Stream ( ) throws  IOException { if ( in != null ) { in . close ( ) ; } if ( e . has More Elements ( ) ) { in = e . next Element ( ) ; if ( in == null ) { throw new  Null Pointer Exception ( _ STR ) ; } } else { in = null ; } }
public static byte [ ] base64 Decode String (  String base64 String ) { try { return  Base64 . decode Base64 ( base64 String . get Bytes ( _ STR ) ) ; } catch (  Exception e ) { throw new  Runtime Exception ( _ STR + base64 String ) ; } }
protected void handle Premove Drop ( int from Square , int to Square ) {  Premove Info premove Info = new  Premove Info ( ) ; premove Info . is Premove Drop = _ BOOL ; premove Info . to Square = to Square ; premove Info . from Square = from Square ; premove Info . from Piece =  Chess Board Utils . piece Jail Square To Piece ( from Square ) ; premoves . add ( premove Info ) ; adjust Premove Label Highlights And Arrows ( ) ; board . unhide Pieces ( ) ; refresh Board ( ) ; }
public static int abs (  Number number ) { return  Math . abs ( number . int Value ( ) ) ; }
public final void stop ( ) { stop ( _ BOOL ) ; }
public void update Dirty ( ) { memory . update Dirty ( ) ; reg . update Dirty ( ) ; }
@  Override public  Enumeration <  Option > list Options ( ) {  Vector <  Option > new Vector = new  Vector <  Option > ( _ NUM ) ; new Vector . add Element ( new  Option ( _ STR , _ STR , _ NUM , _ STR ) ) ; new Vector . add Element ( new  Option ( _ STR + _ STR , _ STR , _ NUM , _ STR ) ) ; new Vector . add Element ( new  Option ( _ STR , _ STR , _ NUM , _ STR ) ) ; new Vector . add Element ( new  Option ( _ STR , _ STR , _ NUM , _ STR ) ) ; return new Vector . elements ( ) ; }
protected  String find Upper Limit (  String prefix ) { if ( prefix . is Empty ( ) ) { return _ STR ; } if ( prefix . length ( ) == _ NUM ) { char c = prefix . char At ( _ NUM ) ; return c < _ STR ?  Character . to String ( ( char ) ( c + _ NUM ) ) : _ STR ; } char last Char = prefix . char At ( prefix . length ( ) - _ NUM ) ; if ( last Char < _ STR ) { return prefix . substring ( _ NUM , prefix . length ( ) - _ NUM ) +  Character . to String ( ( char ) ( last Char + _ NUM ) ) ; } return find Upper Limit ( prefix . substring ( _ NUM , prefix . length ( ) - _ NUM ) ) ; }
public static java . lang .  String to Hex String ( int i ) { return int To Hex String ( i , _ NUM ) ; }
public static double sample Kurtosis Standard Error ( int size ) { int n = size ; return  Math . sqrt ( _ NUM * n * ( n - _ NUM ) * ( n - _ NUM ) / ( ( n - _ NUM ) * ( n - _ NUM ) * ( n + _ NUM ) * ( n + _ NUM ) ) ) ; }
public static  String to String (  Policy Qualifier Info policy Qualifier Info ) throws  IOException {  String Buffer sb Policy Qualifier = new  String Buffer ( ) ;  ASN1 Object Identifier policy Qualifier Id = policy Qualifier Info . get Policy Qualifier Id ( ) ;  Certificate Policy Qualifier Type certificate Policy Qualifier Type =  Certificate Policy Qualifier Type . resolve Oid ( policy Qualifier Id . get Id ( ) ) ; if ( certificate Policy Qualifier Type ==  PKIX_ CPS_ POINTER_ QUALIFIER ) {  DERIA5 String cps Pointer = ( (  DERIA5 String ) policy Qualifier Info . get Qualifier ( ) ) ; sb Policy Qualifier . append (  Message Format . format ( res . get String ( _ STR ) , cps Pointer ) ) ; } else if ( certificate Policy Qualifier Type ==  PKIX_ USER_ NOTICE_ QUALIFIER ) {  ASN1 Encodable user Notice Obj = policy Qualifier Info . get Qualifier ( ) ;  User Notice user Notice =  User Notice . get Instance ( user Notice Obj ) ; sb Policy Qualifier . append (  Message Format . format ( res . get String ( _ STR ) , to String ( user Notice ) ) ) ; } return sb Policy Qualifier . to String ( ) ; }
public void start Transaction ( ) throws  SQLException { final boolean is Auto Commit = m_connection . get Auto Commit ( ) ; if ( is Auto Commit ) { m_connection . set Auto Commit ( _ BOOL ) ; m_return Auto Commit = _ BOOL ; } }
public final double do Operation ( ) throws  Operator Failed Exception {  Node Ref root = tree . get Root ( ) ;  List <  Node Ref > candidates = new  Array List <  Node Ref > ( ) ; for ( int i = _ NUM ; i < tree . get Node Count ( ) ; i ++ ) {  Node Ref node = tree . get Node ( i ) ; if ( node != root && tree . get Parent ( node ) != root ) {  Node Ref parent = tree . get Parent ( node ) ; int sum = rate Change ( tree , node ) + rate Change ( tree , parent ) ; if ( sum == _ NUM ) candidates . add ( node ) ; } } if ( candidates . size ( ) == _ NUM ) throw new  Operator Failed Exception ( _ STR ) ;  Node Ref node = candidates . get (  Math Utils . next Int ( candidates . size ( ) ) ) ;  Node Ref parent = tree . get Parent ( node ) ; double node Trait , parent Trait ; double node Rate , parent Rate ; node Trait = tree . get Node Trait ( node , indicator Trait ) ; parent Trait = tree . get Node Trait ( parent , indicator Trait ) ; tree . set Node Trait ( node , indicator Trait , parent Trait ) ; tree . set Node Trait ( parent , indicator Trait , node Trait ) ; if ( trait2 != null ) { node Trait = tree . get Node Trait ( node , trait2 ) ; parent Trait = tree . get Node Trait ( parent , trait2 ) ; tree . set Node Trait ( node , trait2 , parent Trait ) ; tree . set Node Trait ( parent , trait2 , node Trait ) ; } else { node Rate = tree . get Node Rate ( node ) ; parent Rate = tree . get Node Rate ( parent ) ; tree . set Node Rate ( node , parent Rate ) ; tree . set Node Rate ( parent , node Rate ) ; } return _ NUM ; }
private int find Marker Segment Position (  Class cls , boolean first ) { if ( first ) {  List Iterator iter = marker Sequence . list Iterator ( ) ; for ( int i = _ NUM ; iter . has Next ( ) ; i ++ ) {  Marker Segment seg = (  Marker Segment ) iter . next ( ) ; if ( cls . is Instance ( seg ) ) { return i ; } } } else {  List Iterator iter = marker Sequence . list Iterator ( marker Sequence . size ( ) ) ; for ( int i = marker Sequence . size ( ) - _ NUM ; iter . has Previous ( ) ; i -- ) {  Marker Segment seg = (  Marker Segment ) iter . previous ( ) ; if ( cls . is Instance ( seg ) ) { return i ; } } } return - _ NUM ; }
default  Array add All (  Value ... values ) { if ( values != null ) { add All (  Stream . of ( values ) ) ; } return this ; }
public  String read Line ( ) throws  IOException { boolean got CR = _ BOOL , got LF = _ BOOL ; pos = _ NUM ; line Buf = new  String Buffer ( ) ; while ( ! got LF ) { int c = is . read ( ) ; if ( c == - _ NUM ) { return null ; } if ( got CR ) { if ( c ==  LF ) { got LF = _ BOOL ; } else { got CR = _ BOOL ; consume (  CR ) ; consume ( c ) ; } } else { if ( c ==  CR ) { got CR = _ BOOL ; } else { consume ( c ) ; } } } line Buf . append ( buf , _ NUM , pos ) ; return new  String ( line Buf ) ; }
private void cancel Timer ( ) { if ( timer != null ) { timer . cancel ( ) ; timer . purge ( ) ; timer = null ; } }
public static  Uri add Message To Uri (  Content Resolver resolver ,  Uri uri ,  String address ,  String body ,  String subject ,  Long date , boolean read , boolean delivery Report ) { return add Message To Uri ( resolver , uri , address , body , subject , date , read , delivery Report , - _ NUM ) ; }
public void calc Auto Scale ( ) { double max No Of Major Ticks = _ NUM ; double max No Of Minor Ticks = _ NUM ; double nice Range = (  Helper . calc Nice Number ( get Range ( ) , _ BOOL ) ) ; set Major Tick Space (  Helper . calc Nice Number ( nice Range / ( max No Of Major Ticks - _ NUM ) , _ BOOL ) ) ; double nice Min Value = (  Math . floor ( get Min Value ( ) / get Major Tick Space ( ) ) * get Major Tick Space ( ) ) ; double nice Max Value = (  Math . ceil ( get Max Value ( ) / get Major Tick Space ( ) ) * get Major Tick Space ( ) ) ; set Minor Tick Space (  Helper . calc Nice Number ( get Major Tick Space ( ) / ( max No Of Minor Ticks - _ NUM ) , _ BOOL ) ) ; set Min Value ( nice Min Value ) ; set Max Value ( nice Max Value ) ; }
final  V replace Node ( int key ,  V value ,  Object cv ) { int hash = spread ( key ) ; for (  Node <  V > [ ] tab = table ; ; ) {  Node <  V > f ; int n , i , fh ; if ( tab == null || ( n = tab . length ) == _ NUM || ( f = tab At ( tab , i = ( n - _ NUM ) & hash ) ) == null ) { break ; } else if ( ( fh = f . hash ) ==  MOVED ) { tab = help Transfer ( tab , f ) ; } else {  V old Val = null ; boolean validated = _ BOOL ; synchronized ( f ) { if ( tab At ( tab , i ) == f ) { if ( fh >= _ NUM ) { validated = _ BOOL ; for (  Node <  V > e = f , pred = null ; ; ) { if ( ( e . key == key ) ) {  V ev = e . val ; if ( cv == null || cv == ev || ( ev != null && cv . equals ( ev ) ) ) { old Val = ev ; if ( value != null ) { e . val = value ; } else if ( pred != null ) { pred . next = e . next ; } else { set Tab At ( tab , i , e . next ) ; } } break ; } pred = e ; if ( ( e = e . next ) == null ) { break ; } } } else if ( f instanceof  Tree Bin ) { validated = _ BOOL ;  Tree Bin <  V > t = (  Tree Bin <  V > ) f ;  Tree Node <  V > r , p ; if ( ( r = t . root ) != null && ( p = r . find Tree Node ( hash , key ) ) != null ) {  V pv = p . val ; if ( cv == null || cv == pv || ( pv != null && cv . equals ( pv ) ) ) { old Val = pv ; if ( value != null ) { p . val = value ; } else if ( t . remove Tree Node ( p ) ) { set Tab At ( tab , i , untreeify ( t . first ) ) ; } } } } } } if ( validated ) { if ( old Val != null ) { if ( value == null ) { add Count ( - _ NUM , - _ NUM ) ; } return old Val ; } break ; } } } return null ; }
private static final boolean copy Header (  String name ,  String from Req ,  String Builder buf ) { int start = from Req . index Of ( name ) ; if ( start != - _ NUM ) { int end = from Req . index Of ( _ STR , start ) ; if ( end != - _ NUM ) { buf . append ( from Req . sub Sequence ( start - _ NUM , end ) ) ; return _ BOOL ; } } return _ BOOL ; }
public void send Exception ( final  Exception exception , final  Map <  String ,  String > properties ) { final  Property Map Builder builder = new  Property Map Builder ( properties ) ; logger . debug (  String . format ( _ STR , exception . get Message ( ) , builder . to String ( ) ) ) ; if ( telemetry Client != null ) { telemetry Client . track Exception ( exception , builder . build ( ) , null ) ; } }
public  Field Analysis Request add Field Name (  String field Name ) { if ( field Names == null ) { field Names = new  Linked List < > ( ) ; } field Names . add ( field Name ) ; return this ; }
public  URL find Resource (  String name , boolean check ) {  Loader loader ; int [ ] cache = get Lookup Cache ( name ) ; for ( int i = _ NUM ; ( loader = get Next Loader ( cache , i ) ) != null ; i ++ ) {  URL url = loader . find Resource ( name , check ) ; if ( url != null ) { return url ; } } return null ; }
public  String to EPL ( ) {  String Writer writer = new  String Writer ( ) ; to EPL ( new  EPStatement Formatter ( _ BOOL ) , writer ) ; return writer . to String ( ) ; }
public  Str Builder delete All (  String str ) { int len = ( str == null ? _ NUM : str . length ( ) ) ; if ( len > _ NUM ) { int index = index Of ( str , _ NUM ) ; while ( index >= _ NUM ) { delete Impl ( index , index + len , len ) ; index = index Of ( str , index ) ; } } return this ; }
public void archive List ( ) { }
public void bind (  Inet Address host , int port ) throws  IOException { if ( socket != null ) socket . close ( ) ;  Inet Socket Address new Addr = new  Inet Socket Address ( host . get Host Address ( ) , port ) ; this . socket = new  Datagram Socket ( new Addr ) ; }
public void write ( long file Offset , byte [ ] buffer , int offset , int length ) throws  IOException { _file . seek ( file Offset ) ; _file . write ( buffer , offset , length ) ; }
public  Tag use (  String class Name ,  String tag Bundle Name ,  String tag Bundle Version ,  Identification id ) throws  Page Exception {  Queue <  Tag > queue = get Queue ( to Id ( class Name , tag Bundle Name , tag Bundle Version ) ) ;  Tag tag = queue . poll ( ) ; if ( tag != null ) return tag ; return load Tag ( class Name , tag Bundle Name , tag Bundle Version , id ) ; }
public void shutdown ( ) { shutdown ( _ BOOL ) ; }
private void expand Tree ( ) { if ( tree Expand . is Selected ( ) ) { for ( int row = _ NUM ; row < tree . get Row Count ( ) ; row ++ ) tree . expand Row ( row ) ; } else { for ( int row = tree . get Row Count ( ) ; row > _ NUM ; row -- ) tree . collapse Row ( row ) ; } }
public  String to String ( ) {  String Buffer s = new  String Buffer ( ) ; boolean colon = _ BOOL ; s . append ( _ STR ) ; for (  Type Node type Node : type Node List ) { if ( colon ) { s . append ( _ STR ) ; } else { colon = _ BOOL ; } s . append ( type Node ) ; } s . append ( _ STR ) ; return s . to String ( ) ; }
public void add (  String method ,  Object ... args ) {  Object [ ] args Copy = new  Object [ args . length ] ;  System . arraycopy ( args , _ NUM , args Copy , _ NUM , args . length ) ; methods . add ( method ) ; arg Lists . add ( args Copy ) ; }
public void draw ( final  Graphics g , final int x , final int y , final int height ) {  Preconditions . check Not Null ( g , _ STR ) ; if ( is Visible ( ) ) { final  Color old Color = g . get Color ( ) ; g . set Color ( m_caret Color ) ; g . draw Line ( x , y , x , ( y + height ) - _ NUM ) ; g . set Color ( old Color ) ; } }
public static final  Collection <  Race > find Races (  String stream ,  Collection <  Race > races ) {  Collection <  Race > result = new  Array List < > ( ) ; for (  Race r : races ) { for (  Entrant e : r . get Entrants ( ) ) { if ( stream . equals Ignore Case ( e . twitch ) ) { result . add ( r ) ; } } } return result ; }
public  Enum Set <  Metadata > metadata ( ) { return _parameter Metadata . clone ( ) ; }
public boolean has Receiver ( ) { return ! receiver Nodes . is Empty ( ) ; }
public void install (  Scriptable scope ) {  Scriptable Object . put Property ( scope , _ STR , this ) ; }
public void add Biome Type (  Biome Dictionary .  Type type ) {  Array List <  Biome Gen Base > entry List = new  Array List <  Biome Gen Base > ( ) ; entry List . add All (  Arrays . as List (  Biome Dictionary . get Biomes For Type ( type ) ) ) ; entry List . remove (  Biome Gen Base . hell ) ; entry List . remove (  Biome Gen Base . sky ) ;  Iterator <  Biome Gen Base > iter = entry List . iterator ( ) ; while ( iter . has Next ( ) ) {  Biome Gen Base nextbiome = iter . next ( ) ; for (  Biome Entry entry : allowed Biomes ) { if (  Biome Dictionary . are Biomes Equivalent ( entry . biome , nextbiome ) ) iter . remove ( ) ; } } allowed Biomes . add All ( get Biomes Entries ( entry List ) ) ; }
protected  Size Requirements calculate Minor Axis Requirements ( int axis ,  Size Requirements r ) { long min = _ NUM ; long pref = _ NUM ; long max = _ NUM ; multi Row Cells = _ BOOL ; int n = get View Count ( ) ; for ( int i = _ NUM ; i < n ; i ++ ) {  View v = get View ( i ) ; if ( get Rows Occupied ( v ) > _ NUM ) { multi Row Cells = _ BOOL ; max =  Math . max ( ( int ) v . get Maximum Span ( axis ) , max ) ; } else { min =  Math . max ( ( int ) v . get Minimum Span ( axis ) , min ) ; pref =  Math . max ( ( int ) v . get Preferred Span ( axis ) , pref ) ; max =  Math . max ( ( int ) v . get Maximum Span ( axis ) , max ) ; } } if ( r == null ) { r = new  Size Requirements ( ) ; r . alignment = _ NUM ; } r . preferred = ( int ) pref ; r . minimum = ( int ) min ; r . maximum = ( int ) max ; return r ; }
public static void write Padded Integer (  Writer out , int value , int size ) throws  IOException { if ( value < _ NUM ) { out . write ( _ STR ) ; if ( value !=  Integer .  MIN_ VALUE ) { value = - value ; } else { for ( ; size > _ NUM ; size -- ) { out . write ( _ STR ) ; } out . write ( _ STR + - ( long )  Integer .  MIN_ VALUE ) ; return ; } } if ( value < _ NUM ) { for ( ; size > _ NUM ; size -- ) { out . write ( _ STR ) ; } out . write ( value + _ STR ) ; } else if ( value < _ NUM ) { for ( ; size > _ NUM ; size -- ) { out . write ( _ STR ) ; } int d = ( ( value + _ NUM ) * _ NUM ) > > _ NUM ; out . write ( d + _ STR ) ; out . write ( value - ( d << _ NUM ) - ( d << _ NUM ) + _ STR ) ; } else { int digits ; if ( value < _ NUM ) { digits = _ NUM ; } else if ( value < _ NUM ) { digits = _ NUM ; } else { digits = ( int ) (  Math . log ( value ) /  LOG_10 ) + _ NUM ; } for ( ; size > digits ; size -- ) { out . write ( _ STR ) ; } out . write (  Integer . to String ( value ) ) ; } }
public static void remove Log Filter (  Log Filter filter ) { if ( filter == null || filters == null || filters . is Empty ( ) ) { return ; } if ( filters . contains ( filter ) ) { filters . remove ( filter ) ; } }
public void blob ( byte [ ] blob ) throws  IOException { print ( _ STR , null ) ; printer . println ( ) ; }
void define Labels ( ) { labels Values = calc Labels ( ) ; if ( handle Values ) labels = get Labels From Values ( ) ; else labels = get Labels From Data ( ) ; n Labels = labels . size ( ) ; }
public  List <  Interval > insert B (  List <  Interval > intervals ,  Interval new Interval ) { int i = _ NUM ; while ( i < intervals . size ( ) && intervals . get ( i ) . end < new Interval . start ) { i ++ ; } while ( i < intervals . size ( ) && intervals . get ( i ) . start <= new Interval . end ) { new Interval = new  Interval (  Math . min ( intervals . get ( i ) . start , new Interval . start ) ,  Math . max ( intervals . get ( i ) . end , new Interval . end ) ) ; intervals . remove ( i ) ; } intervals . add ( i , new Interval ) ; return intervals ; }
public static  String take While (  GString self , @  Closure Params ( value =  From String . class , conflict Resolution Strategy =  Pick First Resolver . class , options = { _ STR , _ STR } )  Closure condition ) { return take While ( self . to String ( ) , condition ) ; }
@  Override public void visit Map Node (  Map Node node ) { node Buffer . add ( node ) ; }
public void print Text (  String text ,  String color ) { view . print ( text , text . ends With ( _ STR ) , color ) ; for (  Action Delegate action Delegate : action Delegates ) { action Delegate . on Console Output ( this ) ; } }
protected int wait For ( int counter ) { if ( counter > _ NUM ) -- counter ; else if ( counter > _ NUM ) { -- counter ;  Thread . yield ( ) ; } else {  Lock Support . park Nanos ( _ NUM ) ; } return counter ; }
public static int [ ] sub Array ( final int [ ] input , final int start , final int end ) { int [ ] result = new int [ end - start ] ;  System . arraycopy ( input , start , result , _ NUM , end - start ) ; return result ; }
void assert Thread Stays Alive (  Thread thread , long millis ) { try { delay ( millis ) ; assert True ( thread . is Alive ( ) ) ; } catch (  Interrupted Exception fail ) { thread Fail ( _ STR ) ; } }
public  System Manager (  String id ) { this ( id , (  Class Loader ) null ) ; }
public static byte [ ] from Base64 (  String data ) { if ( data == null ) { return null ; } int len = data . length ( ) ; if ( len == _ NUM ) { return new byte [ _ NUM ] ; } char [ ] chars = new char [ len ] ; data . get Chars ( _ NUM , len , chars , _ NUM ) ; int olen = _ NUM * ( len / _ NUM ) ; if ( chars [ len - _ NUM ] == _ STR ) { -- olen ; } if ( chars [ len - _ NUM ] == _ STR ) { -- olen ; } byte [ ] bytes = new byte [ olen ] ; int iidx = _ NUM ; int oidx = _ NUM ; while ( iidx < len ) { int c0 = base64 Values [ chars [ iidx ++ ] & _ NUM ] ; int c1 = base64 Values [ chars [ iidx ++ ] & _ NUM ] ; int c2 = base64 Values [ chars [ iidx ++ ] & _ NUM ] ; int c3 = base64 Values [ chars [ iidx ++ ] & _ NUM ] ; int c24 = ( c0 << _ NUM ) | ( c1 << _ NUM ) | ( c2 << _ NUM ) | c3 ; bytes [ oidx ++ ] = ( byte ) ( c24 > > _ NUM ) ; if ( oidx == olen ) { break ; } bytes [ oidx ++ ] = ( byte ) ( c24 > > _ NUM ) ; if ( oidx == olen ) { break ; } bytes [ oidx ++ ] = ( byte ) c24 ; } return bytes ; }
public boolean check_trace (  Shape Tile p_shape , int p_layer ,  Net Nos List p_net_no_arr , int p_cl_class ,  Set <  Brd Abit Pin > p_contact_pins ) { if ( ! p_shape . is_contained_in ( bounding_box ) ) return _ BOOL ;  Awtree Shape Search default_tree = search_tree_manager . get_default_tree ( ) ;  Collection <  Awtree Find Entry > tree_entries = default_tree . find_overlap_tree_entries_with_clearance ( p_shape , p_layer ,  Net Nos List .  EMPTY , p_cl_class ) ; for (  Awtree Find Entry curr_tree_entry : tree_entries ) { if ( ! ( curr_tree_entry . object instanceof  Brd Item ) ) continue ;  Brd Item curr_item = (  Brd Item ) curr_tree_entry . object ; if ( p_contact_pins != null ) { if ( p_contact_pins . contains ( curr_item ) ) continue ; if ( curr_item instanceof  Brd Abit Pin ) { return _ BOOL ; } } boolean is_obstacle = p_net_no_arr . is_trace_obstacle ( curr_item ) ; if ( is_obstacle && ( curr_item instanceof  Brd Tracep ) && p_contact_pins != null ) {  Shape Tile intersection = null ; for (  Brd Abit Pin curr_contact_pin : p_contact_pins ) { if ( curr_contact_pin . net_count ( ) <= _ NUM || ! curr_contact_pin . shares_net ( curr_item ) ) continue ; if ( intersection == null ) {  Shape Tile obstacle_trace_shape = curr_item . tile_shape_get ( curr_tree_entry . shape_index_in_object ) ; intersection = p_shape . intersection ( obstacle_trace_shape ) ; }  Shape Tile pin_shape = curr_contact_pin . get_tile_shape_on_layer ( p_layer ) ; if ( pin_shape . contains_approx ( intersection ) ) { is_obstacle = _ BOOL ; break ; } } } if ( is_obstacle ) return _ BOOL ; } return _ BOOL ; }
public static  String [ ] from List (  String url List ) throws  Naming Exception {  String [ ] urls = new  String [ ( url List . length ( ) + _ NUM ) / _ NUM ] ; int i = _ NUM ;  String Tokenizer st = new  String Tokenizer ( url List , _ STR ) ; while ( st . has More Tokens ( ) ) { urls [ i ++ ] = st . next Token ( ) ; }  String [ ] trimmed = new  String [ i ] ;  System . arraycopy ( urls , _ NUM , trimmed , _ NUM , i ) ; return trimmed ; }
private char [ ] f Format Digits ( double x ) {  String sx , sx Out ; int i , j , k ; int n1 In , n2 In ; int expon = _ NUM ; boolean minus Sign = _ BOOL ; if ( x > _ NUM ) sx =  Double . to String ( x ) ; else if ( x < _ NUM ) { sx =  Double . to String ( - x ) ; minus Sign = _ BOOL ; } else { sx =  Double . to String ( x ) ; if ( sx . char At ( _ NUM ) == _ STR ) { minus Sign = _ BOOL ; sx = sx . substring ( _ NUM ) ; } } int e Pos = sx . index Of ( _ STR ) ; int r Pos = sx . index Of ( _ STR ) ; if ( r Pos != - _ NUM ) n1 In = r Pos ; else if ( e Pos != - _ NUM ) n1 In = e Pos ; else n1 In = sx . length ( ) ; if ( r Pos != - _ NUM ) { if ( e Pos != - _ NUM ) n2 In = e Pos - r Pos - _ NUM ; else n2 In = sx . length ( ) - r Pos - _ NUM ; } else n2 In = _ NUM ; if ( e Pos != - _ NUM ) { int ie = e Pos + _ NUM ; expon = _ NUM ; if ( sx . char At ( ie ) == _ STR ) { for ( ++ ie ; ie < sx . length ( ) ; ie ++ ) if ( sx . char At ( ie ) != _ STR ) break ; if ( ie < sx . length ( ) ) expon = -  Integer . parse Int ( sx . substring ( ie ) ) ; } else { if ( sx . char At ( ie ) == _ STR ) ++ ie ; for ( ; ie < sx . length ( ) ; ie ++ ) if ( sx . char At ( ie ) != _ STR ) break ; if ( ie < sx . length ( ) ) expon =  Integer . parse Int ( sx . substring ( ie ) ) ; } } int p ; if ( precision Set ) p = precision ; else p = default Digits - _ NUM ; char [ ] ca1 = sx . to Char Array ( ) ; char [ ] ca2 = new char [ n1 In + n2 In ] ; char [ ] ca3 , ca4 , ca5 ; for ( j = _ NUM ; j < n1 In ; j ++ ) ca2 [ j ] = ca1 [ j ] ; i = j + _ NUM ; for ( k = _ NUM ; k < n2 In ; j ++ , i ++ , k ++ ) ca2 [ j ] = ca1 [ i ] ; if ( n1 In + expon <= _ NUM ) { ca3 = new char [ - expon + n2 In ] ; for ( j = _ NUM , k = _ NUM ; k < ( - n1 In - expon ) ; k ++ , j ++ ) ca3 [ j ] = _ STR ; for ( i = _ NUM ; i < ( n1 In + n2 In ) ; i ++ , j ++ ) ca3 [ j ] = ca2 [ i ] ; } else ca3 = ca2 ; boolean carry = _ BOOL ; if ( p < - expon + n2 In ) { if ( expon < _ NUM ) i = p ; else i = p + n1 In ; carry = check For Carry ( ca3 , i ) ; if ( carry ) carry = start Symbolic Carry ( ca3 , i - _ NUM , _ NUM ) ; } if ( n1 In + expon <= _ NUM ) { ca4 = new char [ _ NUM + p ] ; if ( ! carry ) ca4 [ _ NUM ] = _ STR ; else ca4 [ _ NUM ] = _ STR ; if ( alternate Form || ! precision Set || precision != _ NUM ) { ca4 [ _ NUM ] = _ STR ; for ( i = _ NUM , j = _ NUM ; i <  Math . min ( p , ca3 . length ) ; i ++ , j ++ ) ca4 [ j ] = ca3 [ i ] ; for ( ; j < ca4 . length ; j ++ ) ca4 [ j ] = _ STR ; } } else { if ( ! carry ) { if ( alternate Form || ! precision Set || precision != _ NUM ) ca4 = new char [ n1 In + expon + p + _ NUM ] ; else ca4 = new char [ n1 In + expon ] ; j = _ NUM ; } else { if ( alternate Form || ! precision Set || precision != _ NUM ) ca4 = new char [ n1 In + expon + p + _ NUM ] ; else ca4 = new char [ n1 In + expon + _ NUM ] ; ca4 [ _ NUM ] = _ STR ; j = _ NUM ; } for ( i = _ NUM ; i <  Math . min ( n1 In + expon , ca3 . length ) ; i ++ , j ++ ) ca4 [ j ] = ca3 [ i ] ; for ( ; i < n1 In + expon ; i ++ , j ++ ) ca4 [ j ] = _ STR ; if ( alternate Form || ! precision Set || precision != _ NUM ) { ca4 [ j ] = _ STR ; j ++ ; for ( k = _ NUM ; i < ca3 . length && k < p ; i ++ , j ++ , k ++ ) ca4 [ j ] = ca3 [ i ] ; for ( ; j < ca4 . length ; j ++ ) ca4 [ j ] = _ STR ; } } int n Zeros = _ NUM ; if ( ! left Justify && leading Zeros ) { int x Thousands = _ NUM ; if ( thousands ) { int xlead = _ NUM ; if ( ca4 [ _ NUM ] == _ STR || ca4 [ _ NUM ] == _ STR || ca4 [ _ NUM ] == _ STR ) xlead = _ NUM ; int xdp = xlead ; for ( ; xdp < ca4 . length ; xdp ++ ) if ( ca4 [ xdp ] == _ STR ) break ; x Thousands = ( xdp - xlead ) / _ NUM ; } if ( field Width Set ) n Zeros = field Width - ca4 . length ; if ( ( ! minus Sign && ( leading Sign || leading Space ) ) || minus Sign ) n Zeros -- ; n Zeros -= x Thousands ; if ( n Zeros < _ NUM ) n Zeros = _ NUM ; } j = _ NUM ; if ( ( ! minus Sign && ( leading Sign || leading Space ) ) || minus Sign ) { ca5 = new char [ ca4 . length + n Zeros + _ NUM ] ; j ++ ; } else ca5 = new char [ ca4 . length + n Zeros ] ; if ( ! minus Sign ) { if ( leading Sign ) ca5 [ _ NUM ] = _ STR ; if ( leading Space ) ca5 [ _ NUM ] = _ STR ; } else ca5 [ _ NUM ] = _ STR ; for ( i = _ NUM ; i < n Zeros ; i ++ , j ++ ) ca5 [ j ] = _ STR ; for ( i = _ NUM ; i < ca4 . length ; i ++ , j ++ ) ca5 [ j ] = ca4 [ i ] ; int lead = _ NUM ; if ( ca5 [ _ NUM ] == _ STR || ca5 [ _ NUM ] == _ STR || ca5 [ _ NUM ] == _ STR ) lead = _ NUM ; int dp = lead ; for ( ; dp < ca5 . length ; dp ++ ) if ( ca5 [ dp ] == _ STR ) break ; int n Thousands = ( dp - lead ) / _ NUM ; if ( dp < ca5 . length ) ca5 [ dp ] = dfs . get Decimal Separator ( ) ; char [ ] ca6 = ca5 ; if ( thousands && n Thousands > _ NUM ) { ca6 = new char [ ca5 . length + n Thousands + lead ] ; ca6 [ _ NUM ] = ca5 [ _ NUM ] ; for ( i = lead , k = lead ; i < dp ; i ++ ) { if ( i > _ NUM && ( dp - i ) % _ NUM == _ NUM ) { ca6 [ k ] = dfs . get Grouping Separator ( ) ; ca6 [ k + _ NUM ] = ca5 [ i ] ; k += _ NUM ; } else { ca6 [ k ] = ca5 [ i ] ; k ++ ; } } for ( ; i < ca5 . length ; i ++ , k ++ ) { ca6 [ k ] = ca5 [ i ] ; } } return ca6 ; }
public int y To Line ( int y ) {  Font Metrics fm = painter . get Font Metrics ( ) ; int height = fm . get Height ( ) ; return  Math . max ( _ NUM ,  Math . min ( get Line Count ( ) - _ NUM , y / height + first Line ) ) ; }
public  Pla Point Int round_to_the_right (  Pla Direction p_dir ) {  Pla Point Float dir = p_dir . to_float ( ) ; double rounded_x ; if ( dir . v_y > _ NUM ) { rounded_x =  Math . ceil ( v_x ) ; } else if ( dir . v_y < _ NUM ) { rounded_x =  Math . floor ( v_x ) ; } else { rounded_x =  Math . round ( v_x ) ; } double rounded_y ; if ( dir . v_x > _ NUM ) { rounded_y =  Math . floor ( v_y ) ; } else if ( dir . v_x < _ NUM ) { rounded_y =  Math . ceil ( v_y ) ; } else { rounded_y =  Math . round ( v_y ) ; } return new  Pla Point Int ( rounded_x , rounded_y ) ; }
public static void copy File (  File in ,  File out ) throws  IOException {  File Input Stream fis = new  File Input Stream ( in ) ;  File Output Stream fos = new  File Output Stream ( out ) ; try { copy Stream ( fis , fos ) ; } finally { fis . close ( ) ; fos . close ( ) ; } }
public boolean is Valid Username (  String username ) { return  Pattern . matches ( _ STR , username ) ; }
static void append Columns (  String Builder s ,  String [ ] columns ) { for ( int i = _ NUM ; i < columns . length ; i ++ ) { if ( i > _ NUM ) { s . append ( _ STR ) ; } s . append (  String Utils . quote Identifier ( columns [ i ] ) ) ; } }
public static void register MBean (  Object mbean ,  Class < ? > mbean Interface ,  String mbean Name , boolean ignored ) {  MBean Server mbs =  Management Factory . get Platform MBean Server ( ) ; try { if ( logger . is Debug Enabled ( ) ) logger . debug ( _ STR + mbean . get Class ( ) ) ;  Object Name name = generate MBean Object Name ( mbean Interface . get Name ( ) , mbean Name ) ; if ( mbs . is Registered ( name ) ) mbs . unregister MBean ( name ) ; mbs . register MBean ( mbean , name ) ; } catch (  Exception e ) { throw new  Server Runtime Exception ( _ STR + mbean . get Class ( ) + _ STR + mbean Interface + _ STR + mbean Name , e ) ; } }
public static  Set <  String > to String Set (  Template Collection Model coll Model ) throws  Template Model Exception {  Set <  String > set = new  Hash Set <  String > ( ) ;  Template Model Iterator model It = coll Model . iterator ( ) ; while ( model It . has Next ( ) ) { set . add ( get As String Non Escaping ( (  Template Scalar Model ) model It . next ( ) ) ) ; } return set ; }
public  Open SAMLTest (  String test Name ) throws  Key Store Exception ,  File Not Found Exception ,  Certificate Exception ,  IOException ,  No Such Algorithm Exception { super ( test Name ) ;  Property Configurator . configure (  LOG_ FILE ) ; ks =  Key Store . get Instance ( _ STR ) ;  Input Stream is = new  File Input Stream ( new  File ( path ) ) ; try { ks . load ( is , password ) ; } finally { if ( is != null ) { is . close ( ) ; } } }
private static int  Dist (  PCal Location loc A ,  PCal Location loc B ) { return _ NUM *  Math . abs ( loc A . get Line ( ) - loc B . get Line ( ) ) +  Math . abs ( loc A . get Column ( ) - loc B . get Column ( ) ) ; }
void parse ( ) {  Byte Buffer bb = byte Buffer ; bb . clear ( ) ; size = bb . get Short ( ) ; if ( size > buffer . length ) { throw new  Illegal State Exception ( _ STR + size + _ STR + buffer . length ) ; } bb . limit ( size ) ; type = bb . get ( ) ; from Member Id = bb . get Short ( ) ; term = bb . get Int ( ) ; command Size = _ NUM ; num Commands = _ NUM ; timestamp = _ NUM ; switch ( type ) { case  TYPE_ APPEND_ ENTRY_ REQ : prev Rid . set ( bb . get Int ( ) , bb . get Int ( ) ) ; commit Index = bb . get Int ( ) ; entry Term = bb . get Int ( ) ; is Heartbeat = entry Term == _ NUM ; command Size = bb . get Short ( ) ; buffer Offset = bb . position ( ) ; if ( message Tracing ) { if ( is Heartbeat ) { if ( heartbeat Tracing ) { tracing Info =  String . format ( _ STR , term , prev Rid . term , prev Rid . index , commit Index ) ; } } else { tracing Info =  String . format ( _ STR , term , prev Rid . term , entry Term , prev Rid . index + _ NUM , commit Index , size - overhead [  TYPE_ APPEND_ ENTRY_ REQ ] ) ; } } num Commands = _ NUM ; int s = overhead [  TYPE_ APPEND_ ENTRY_ REQ ] + command Size ; int bo = buffer Offset ; int cs = command Size ; while ( s < size ) { num Commands ++ ; bo += cs ; cs = ( _ NUM & buffer [ bo ] ) << _ NUM | ( _ NUM & buffer [ bo + _ NUM ] ) ; bo += _ NUM ; s += cs + _ NUM ; } break ; case  TYPE_ APPEND_ ENTRY_ REP : mn Index = bb . get Int ( ) ; success = bb . get ( ) == _ NUM ; is Heartbeat = bb . get ( ) == _ NUM ; if ( message Tracing && ( heartbeat Tracing || ! is Heartbeat ) ) { tracing Info =  String . format ( _ STR , is Heartbeat ? _ STR : _ STR , term , success ? _ STR : _ STR , mn Index , success ? _ STR : _ STR ) ; } break ; case  TYPE_ REQUEST_ VOTE_ REQ : is Prevote = bb . get ( ) == _ NUM ; prev Rid . set ( bb . get Int ( ) , bb . get Int ( ) ) ; if ( message Tracing ) { tracing Info =  String . format ( _ STR , term , prev Rid . term , prev Rid . index , is Prevote ? _ STR : _ STR ) ; } break ; case  TYPE_ REQUEST_ VOTE_ REP : is Prevote = bb . get ( ) == _ NUM ; vote Granted = bb . get ( ) == _ NUM ; if ( message Tracing ) { tracing Info =  String . format ( _ STR , term , vote Granted ? _ STR : _ STR , is Prevote ? _ STR : _ STR ) ; } break ; default : throw new  Illegal State Exception ( _ STR + type ) ; } }
public static  XPath Expression compile XPath (  XPath xpath ,  String expr ) { try { return xpath . compile ( expr ) ; } catch (  XPath Expression Exception e ) { throw new  Xml Exception ( e ) ; } }
public static  Http2 Headers to Netty Http2 (  Http Headers input Headers ) { final  Http2 Headers output Headers = new  Default Http2 Headers ( _ BOOL , input Headers . size ( ) ) ; output Headers . set ( input Headers ) ; output Headers . remove (  Http Header Names .  CONNECTION ) ; output Headers . remove (  Http Header Names .  TRANSFER_ ENCODING ) ; output Headers . remove (  Http Header Names .  TRAILER ) ; return output Headers ; }
public boolean write ( byte [ ] audio Data ) { return write ( audio Data , _ NUM , audio Data . length ) ; }
void init Program ( ) { gl Use Program ( this . program ) ; view Matrix Uniform = gl Get Uniform Location ( this . program , _ STR ) ; proj Matrix Uniform = gl Get Uniform Location ( this . program , _ STR ) ; viewport Size Uniform = gl Get Uniform Location ( this . program , _ STR ) ; gl Use Program ( _ NUM ) ; }
public void test Float Value Pos ( ) {  String a = _ STR ;  Big Decimal a Number = new  Big Decimal ( a ) ; float result = _ NUM ; assert True ( _ STR , a Number . float Value ( ) == result ) ; }
public static  Key Store create Empty Key Store (  String key Store Type ,  String provider ) { if ( key Store Type == null ) { key Store Type = _ STR ; }  Key Store key Store ; try { if ( provider == null ) { key Store =  Key Store . get Instance ( key Store Type ) ; } else { key Store =  Key Store . get Instance ( key Store Type , provider ) ; } key Store . load ( null , null ) ; } catch (  Key Store Exception |  Certificate Exception |  No Such Algorithm Exception |  No Such Provider Exception |  IOException e ) { throw new  Key Store Access Exception ( _ STR + key Store Type , e ) ; } return key Store ; }
protected  Connection try Messages To Connections (  List <  Message > messages ,  List <  Connection > connections ) { for ( int i = _ NUM , n = connections . size ( ) ; i < n ; i ++ ) {  Connection con = connections . get ( i ) ;  Message started = try All Messages ( con , messages ) ; if ( started != null ) { return con ; } } return null ; }
public boolean contains Instruction (  Instruction Handle handle ) { return instruction Set . get ( handle . get Position ( ) ) ; }
public  Memorizing Trust Manager (  Context m ,  X509 Trust Manager default Trust Manager ) { init ( m ) ; this . app Trust Manager = get Trust Manager ( app Key Store ) ; this . default Trust Manager = default Trust Manager ; }
public  Poolable Thread (  Thread Pool pool ) { super ( pool . get Thread Group ( ) , _ STR ) ; this . pool = pool ; synchronized (  Poolable Thread . class ) { thread ID = next Thread ID ++ ; } set Name ( pool . get Identifier ( ) + _ STR + thread ID ) ; }
public final void remove Helper Text Color ( @  Color Int final int color ) { int index = helper Text Colors . index Of ( color ) ; if ( index != - _ NUM ) { helper Text Colors . remove ( index ) ; verify Password Strength ( ) ; } }
@  Override public boolean equals (  Object obj ) { if ( obj == this ) { return _ BOOL ; } if ( ! ( obj instanceof  Minute ) ) { return _ BOOL ; }  Minute that = (  Minute ) obj ; if ( this . minute != that . minute ) { return _ BOOL ; } if ( this . hour != that . hour ) { return _ BOOL ; } return _ BOOL ; }
List Based Token Stream (  List <  Attribute Source > tokens ) { this . tokens = tokens ; token Iterator = tokens . iterator ( ) ; }
private  Class < ? > read New Class ( boolean unshared ) throws  Class Not Found Exception ,  IOException {  Object Stream Class class Desc = read Class Desc ( ) ; if ( class Desc == null ) { throw missing Class Descriptor ( ) ; }  Class < ? > local Class = class Desc . for Class ( ) ; if ( local Class != null ) { register Object Read ( local Class , next Handle ( ) , unshared ) ; } return local Class ; }
public static int find ( byte [ ] a , int from Index , int to Index , byte key ) { int result = - _ NUM ; if ( from Index < _ NUM ) { from Index = _ NUM ; } to Index =  Math . min ( to Index , a . length ) ; for ( int i = from Index ; from Index < to Index && result == - _ NUM && i < to Index ; i ++ ) { if ( a [ i ] == key ) { result = i ; } } return result ; }
private void check Search (  String input Graph ,  String output Graph ) {  Graph graph =  Graph Converter . convert ( input Graph ) ;  Independence Test independence = new  Ind Test DSep ( graph ) ;  Pc pc = new  Pc ( independence ) ;  Graph result Graph = pc . search ( new  Fas Stable Concurrent ( independence ) , independence . get Variables ( ) ) ;  Graph true Graph =  Graph Converter . convert ( output Graph ) ; result Graph =  Graph Utils . replace Nodes ( result Graph , true Graph . get Nodes ( ) ) ; assert True ( result Graph . equals ( true Graph ) ) ; }
public  State Machine (  State [ ] s ) { for ( int i = _ NUM ; i < s . length ; i ++ ) states . add Element ( s [ i ] ) ; }
private static int [ ]  Windows Reg Create Key Ex1 ( int h Key , byte [ ] sub Key ) { int [ ] result =  Windows Reg Create Key Ex ( h Key , sub Key ) ; if ( result [  ERROR_ CODE ] ==  ERROR_ SUCCESS ) { return result ; } else { long sleep Time =  INIT_ SLEEP_ TIME ; for ( int i = _ NUM ; i <  MAX_ ATTEMPTS ; i ++ ) { try {  Thread . sleep ( sleep Time ) ; } catch (  Interrupted Exception e ) { return result ; } sleep Time *= _ NUM ; result =  Windows Reg Create Key Ex ( h Key , sub Key ) ; if ( result [  ERROR_ CODE ] ==  ERROR_ SUCCESS ) { return result ; } } } return result ; }
public  Tasker add UITask (  Task task ) { tasks . add ( task ) ; task . set Run Type (  THREAD_ TYPE .  UI ) ; last Added Task = task ; return this ; }
private void init Compute Program ( ) { gl Use Program ( compute Program ) ;  Int Buffer work Group Size =  Buffer Utils . create Int Buffer ( _ NUM ) ; gl Get Programiv ( compute Program ,  GL_ COMPUTE_ WORK_ GROUP_ SIZE , work Group Size ) ; work Group Size X = work Group Size . get ( _ NUM ) ; work Group Size Y = work Group Size . get ( _ NUM ) ; time Uniform = gl Get Uniform Location ( compute Program , _ STR ) ; blend Factor Uniform = gl Get Uniform Location ( compute Program , _ STR ) ; bounce Count Uniform = gl Get Uniform Location ( compute Program , _ STR ) ; int boxes Resource Index = gl Get Program Resource Index ( compute Program ,  GL_ SHADER_ STORAGE_ BLOCK , _ STR ) ;  Int Buffer props =  Buffer Utils . create Int Buffer ( _ NUM ) ;  Int Buffer params =  Buffer Utils . create Int Buffer ( _ NUM ) ; props . put ( _ NUM ,  GL_ BUFFER_ BINDING ) ; gl Get Program Resourceiv ( compute Program ,  GL_ SHADER_ STORAGE_ BLOCK , boxes Resource Index , props , null , params ) ; boxes Ssbo Binding = params . get ( _ NUM ) ; int loc = gl Get Uniform Location ( compute Program , _ STR ) ; gl Get Uniformiv ( compute Program , loc , params ) ; framebuffer Image Binding = params . get ( _ NUM ) ; loc = gl Get Uniform Location ( compute Program , _ STR ) ; gl Get Uniformiv ( compute Program , loc , params ) ; world Position Image Binding = params . get ( _ NUM ) ; loc = gl Get Uniform Location ( compute Program , _ STR ) ; gl Get Uniformiv ( compute Program , loc , params ) ; world Normal Image Binding = params . get ( _ NUM ) ; gl Use Program ( _ NUM ) ; }
public void sort ( ) { if ( ! sorted ) {  Collections . sort ( samples ) ; sorted = _ BOOL ; } }
public static  Object object From Byte Buffer ( byte [ ] buffer ) throws  Exception { if ( buffer == null ) return null ;  Byte Array Input Stream in Stream = new  Byte Array Input Stream ( buffer ) ;  Object Input Stream in = new  Object Input Stream ( in Stream ) ;  Object retval = in . read Object ( ) ; in . close ( ) ; return retval ; }
public  String generate Group Name (  Set <  String > existing Group Names ,  String storage Group Name ) {  String storage Group Name Temp = storage Group Name . replace All (  Constants .  SMIS_ PLUS_ REGEX ,  Constants .  HYPHEN ) ; _log . info ( _ STR , storage Group Name , storage Group Name Temp ) ;  String result = storage Group Name Temp ; if ( existing Group Names . contains ( storage Group Name Temp . to Lower Case ( ) ) ) { int size = existing Group Names . size ( ) ; for ( int index = _ NUM ; index <= size ; index ++ ) { result =  String . format ( _ STR , storage Group Name Temp , index ) ; if ( ! existing Group Names . contains ( result . to Lower Case ( ) ) ) { break ; } } } _log . info (  String . format ( _ STR , existing Group Names . size ( ) , storage Group Name Temp , result ) ) ; return result ; }
public  Toggle Button Group (  Action ... actions ) { this ( null , actions ) ; }
public void revert Row ( int row ) { changed Rows . remove ( row ) ; fire Table Rows Updated ( row , row ) ; }
@  Override protected void on Measure ( int width Measure Spec , int height Measure Spec ) { int width Size =  Measure Spec . get Size ( width Measure Spec ) ; int width Mode =  Measure Spec . get Mode ( width Measure Spec ) ; int width ; int height Size =  Measure Spec . get Size ( height Measure Spec ) ; int height Mode =  Measure Spec . get Mode ( height Measure Spec ) ; int height ; final int count = get Child Count ( ) ; int max Child Width = _ NUM ; for ( int i = _ NUM ; i < count ; i ++ ) {  View child = get Child At ( i ) ; measure Child ( child , width Measure Spec , height Measure Spec ) ; } for ( int i = _ NUM ; i < m Menu Items . size ( ) ; i ++ ) {  Floating Action Button fab = m Menu Items . get ( i ) ;  Text View label = m Menu Item Labels . get ( i ) ; max Child Width =  Math . max ( max Child Width , label . get Measured Width ( ) + fab . get Measured Width ( ) ) ; } max Child Width =  Math . max ( m Menu Button . get Measured Width ( ) , max Child Width ) ; if ( width Mode ==  Measure Spec .  EXACTLY ) { width = width Size ; } else { width = max Child Width + _ NUM ; } if ( height Mode ==  Measure Spec .  EXACTLY ) { height = height Size ; } else { int height Sum = _ NUM ; for ( int i = _ NUM ; i < count ; i ++ ) {  View child = get Child At ( i ) ; height Sum += child . get Measured Height ( ) ; } height = height Sum + _ NUM ; } set Measured Dimension ( resolve Size ( width , width Measure Spec ) , resolve Size ( height , height Measure Spec ) ) ; }
public  Char Buffer ( int capacity ) { if ( capacity < _ NUM ) throw new  Illegal Argument Exception ( ) ; capacity =  Math . max ( capacity ,  MIN_ CAPACITY ) ; init ( new char [ capacity ] , _ NUM , _ NUM ) ; }
public static <  K ,  V >  Collector <  Entry <  K ,  V > , ? ,  Map <  K ,  V > > to Map ( ) { return  Collectors . to Map ( null , null ) ; }
@  Override public boolean connection Allowed (  String event Name ) { if ( ! event Name . equals ( _ STR ) && ! event Name . equals ( _ STR ) && ! event Name . equals ( _ STR ) && ! event Name . equals ( _ STR ) ) { return _ BOOL ; } if ( m_listenee != null ) { return _ BOOL ; } return _ BOOL ; }
protected  String read Word (  Reader r ) throws  IOException {  String Buffer buf = new  String Buffer ( ) ; char c = skip All Whitespace ( r ) ; while ( c != ( char ) - _ NUM && !  Character . is Whitespace ( c ) ) { buf . append ( c ) ; c = ( char ) r . read ( ) ; } if ( c == ( char ) - _ NUM ) { set Done ( _ BOOL ) ; } return buf . to String ( ) ; }
public  Map <  String ,  String > parse ( final  String str , char separator ) { if ( str == null ) { return new  Hash Map <  String ,  String > ( ) ; } return parse ( str . to Char Array ( ) , separator ) ; }
public static void add Sub Schema (  String service Name ,  String sub Schema ,  String schema Type ,  String file Name ) throws  Upgrade Exception {  String class Method = _ STR ; if ( debug . message Enabled ( ) ) { debug . message ( class Method + _ STR + file Name + _ STR + service Name ) ; } try {  Service Schema ss = get Service Schema ( service Name , sub Schema , schema Type ) ; ss . add Sub Schema ( new  File Input Stream ( file Name ) ) ; } catch (  IOException ioe ) { throw new  Upgrade Exception ( _ STR ) ; } catch (  SSOException ssoe ) { throw new  Upgrade Exception ( _ STR ) ; } catch (  SMSException ssoe ) { throw new  Upgrade Exception ( _ STR ) ; } }
private long acquire Read ( boolean interruptible , long deadline ) {  WNode node = null , p ; for ( int spins = - _ NUM ; ; ) {  WNode h ; if ( ( h = whead ) == ( p = wtail ) ) { for ( long m , s , ns ; ; ) { if ( ( m = ( s = state ) &  ABITS ) <  RFULL ?  U . compare And Swap Long ( this ,  STATE , s , ns = s +  RUNIT ) : ( m <  WBIT && ( ns = try Inc Reader Overflow ( s ) ) != _ NUM ) ) return ns ; else if ( m >=  WBIT ) { if ( spins > _ NUM ) { if (  Lock Support . next Secondary Seed ( ) >= _ NUM ) -- spins ; } else { if ( spins == _ NUM ) {  WNode nh = whead , np = wtail ; if ( ( nh == h && np == p ) || ( h = nh ) != ( p = np ) ) break ; } spins =  SPINS ; } } } } if ( p == null ) {  WNode hd = new  WNode (  WMODE , null ) ; if (  U . compare And Swap Object ( this ,  WHEAD , null , hd ) ) wtail = hd ; } else if ( node == null ) node = new  WNode (  RMODE , p ) ; else if ( h == p || p . mode !=  RMODE ) { if ( node . prev != p ) node . prev = p ; else if (  U . compare And Swap Object ( this ,  WTAIL , p , node ) ) { p . next = node ; break ; } } else if ( !  U . compare And Swap Object ( p ,  WCOWAIT , node . cowait = p . cowait , node ) ) node . cowait = null ; else { for ( ; ; ) {  WNode pp , c ;  Thread w ; if ( ( h = whead ) != null && ( c = h . cowait ) != null &&  U . compare And Swap Object ( h ,  WCOWAIT , c , c . cowait ) && ( w = c . thread ) != null )  U . unpark ( w ) ; if ( h == ( pp = p . prev ) || h == p || pp == null ) { long m , s , ns ; do { if ( ( m = ( s = state ) &  ABITS ) <  RFULL ?  U . compare And Swap Long ( this ,  STATE , s , ns = s +  RUNIT ) : ( m <  WBIT && ( ns = try Inc Reader Overflow ( s ) ) != _ NUM ) ) return ns ; } while ( m <  WBIT ) ; } if ( whead == h && p . prev == pp ) { long time ; if ( pp == null || h == p || p . status > _ NUM ) { node = null ; break ; } if ( deadline == _ NUM ) time = _ NUM ; else if ( ( time = deadline -  System . nano Time ( ) ) <= _ NUM ) return cancel Waiter ( node , p , _ BOOL ) ;  Thread wt =  Thread . current Thread ( ) ;  U . put Object ( wt ,  PARKBLOCKER , this ) ; node . thread = wt ; if ( ( h != pp || ( state &  ABITS ) ==  WBIT ) && whead == h && p . prev == pp )  U . park ( _ BOOL , time ) ; node . thread = null ;  U . put Object ( wt ,  PARKBLOCKER , null ) ; if ( interruptible &&  Thread . interrupted ( ) ) return cancel Waiter ( node , p , _ BOOL ) ; } } } } for ( int spins = - _ NUM ; ; ) {  WNode h , np , pp ; int ps ; if ( ( h = whead ) == p ) { if ( spins < _ NUM ) spins =  HEAD_ SPINS ; else if ( spins <  MAX_ HEAD_ SPINS ) spins <<= _ NUM ; for ( int k = spins ; ; ) { long m , s , ns ; if ( ( m = ( s = state ) &  ABITS ) <  RFULL ?  U . compare And Swap Long ( this ,  STATE , s , ns = s +  RUNIT ) : ( m <  WBIT && ( ns = try Inc Reader Overflow ( s ) ) != _ NUM ) ) {  WNode c ;  Thread w ; whead = node ; node . prev = null ; while ( ( c = node . cowait ) != null ) { if (  U . compare And Swap Object ( node ,  WCOWAIT , c , c . cowait ) && ( w = c . thread ) != null )  U . unpark ( w ) ; } return ns ; } else if ( m >=  WBIT &&  Lock Support . next Secondary Seed ( ) >= _ NUM && -- k <= _ NUM ) break ; } } else if ( h != null ) {  WNode c ;  Thread w ; while ( ( c = h . cowait ) != null ) { if (  U . compare And Swap Object ( h ,  WCOWAIT , c , c . cowait ) && ( w = c . thread ) != null )  U . unpark ( w ) ; } } if ( whead == h ) { if ( ( np = node . prev ) != p ) { if ( np != null ) ( p = np ) . next = node ; } else if ( ( ps = p . status ) == _ NUM )  U . compare And Swap Int ( p ,  WSTATUS , _ NUM ,  WAITING ) ; else if ( ps ==  CANCELLED ) { if ( ( pp = p . prev ) != null ) { node . prev = pp ; pp . next = node ; } } else { long time ; if ( deadline == _ NUM ) time = _ NUM ; else if ( ( time = deadline -  System . nano Time ( ) ) <= _ NUM ) return cancel Waiter ( node , node , _ BOOL ) ;  Thread wt =  Thread . current Thread ( ) ;  U . put Object ( wt ,  PARKBLOCKER , this ) ; node . thread = wt ; if ( p . status < _ NUM && ( p != h || ( state &  ABITS ) ==  WBIT ) && whead == h && node . prev == p )  U . park ( _ BOOL , time ) ; node . thread = null ;  U . put Object ( wt ,  PARKBLOCKER , null ) ; if ( interruptible &&  Thread . interrupted ( ) ) return cancel Waiter ( node , node , _ BOOL ) ; } } } }
@  Override public void init ( ) { }
public static void write File ( final  File destination , final  List <  String > contents ) throws  IOException { final  Buffered Writer bw = new  Buffered Writer ( new  File Writer ( destination ) ) ; try { for (  String line : contents ) { bw . write ( line ) ; bw . new Line ( ) ; } bw . flush ( ) ; } finally { bw . close ( ) ; } }
public static  File create Container Schema File (  String schema Prefix File Name ,  String container Schema File Path ) throws  Remote Exception {  File default Schema File = null ; try {  String schema File Path =  Constants .  Container .  CONTAINER_ CONFIG_ DIRECTORY + _ STR +  Constants .  Schemas .  SCHEMAS_ FOLDER + _ STR +  Constants .  Schemas .  DEFAULT_ SCHEMA +  Constants .  Schemas .  CONTAINER_ SCHEMA_ FILE_ SUFFIX ;  Input Stream schema Input Stream =  Resource Loader . get Resource Stream ( schema File Path ) ;  String folder Owner Path = container Schema File Path . substring ( _ NUM , container Schema File Path . last Index Of (  File . separator ) ) ;  File folder Owner Instance = new  File ( folder Owner Path ) ; if ( ! folder Owner Instance . exists ( ) ) { folder Owner Instance . mkdirs ( ) ; } default Schema File = new  File ( container Schema File Path ) ;  File Output Stream fos = new  File Output Stream ( default Schema File ) ; int read = _ NUM ; while ( read > _ NUM ) { byte [ ] read Bytes Array = new byte [ schema Input Stream . available ( ) ] ; read = schema Input Stream . read ( read Bytes Array ) ; fos . write ( read Bytes Array ) ; } fos . flush ( ) ; fos . close ( ) ; schema Input Stream . close ( ) ;  Replace In File Utils file = new  Replace In File Utils ( container Schema File Path ) ; file . replace In File ( _ STR +  Constants .  Schemas .  DEFAULT_ SCHEMA + _ STR , _ STR + schema Prefix File Name + _ STR ) ; file . replace In File ( _ STR +  Constants .  Schemas .  DEFAULT_ SCHEMA + _ STR , _ STR + schema Prefix File Name + _ STR ) ; file . close ( ) ; } catch (  Exception ex ) { throw new  Remote Exception ( _ STR , ex ) ; } return default Schema File ; }
public boolean is Aborted ( ) { return  STATE_ Aborted . equals ( m_state ) ; }
public void append ( int key ,  Double value ) { if ( m Size != _ NUM && key <= m Keys [ m Size - _ NUM ] ) { put ( key , value ) ; return ; } if ( m Garbage && m Size >= m Keys . length ) { gc ( ) ; } int pos = m Size ; if ( pos >= m Keys . length ) { int n = ideal Int Array Size ( pos + _ NUM ) ; int [ ] nkeys = new int [ n ] ;  Arrays . fill ( nkeys , - _ NUM ) ;  Double [ ] nvalues = new  Double [ n ] ;  System . arraycopy ( m Keys , _ NUM , nkeys , _ NUM , m Keys . length ) ;  System . arraycopy ( m Values , _ NUM , nvalues , _ NUM , m Values . length ) ; m Keys = nkeys ; m Values = nvalues ; } m Keys [ pos ] = key ; m Values [ pos ] = value ; m Size = pos + _ NUM ; }
@  Nullable private  Ipc Shared Memory Server Endpoint reset Shmem Server ( ) throws  Ignite Checked Exception { if ( bound Tcp Shmem Port >= _ NUM ) throw new  Ignite Checked Exception ( _ STR + bound Tcp Shmem Port ) ; if ( shmem Port == - _ NUM ||  U . is Windows ( ) ) return null ;  Ignite Checked Exception last Ex = null ; for ( int port = shmem Port ; port < shmem Port + loc Port Range ; port ++ ) { try {  Ipc Shared Memory Server Endpoint srv = new  Ipc Shared Memory Server Endpoint ( log . get Logger (  Ipc Shared Memory Server Endpoint . class ) , loc Proc Desc . process Id ( ) , grid Name ) ; srv . set Port ( port ) ; srv . omit Out Of Resources Warning ( _ BOOL ) ; srv . start ( ) ; bound Tcp Shmem Port = port ; if ( log . is Info Enabled ( ) ) log . info ( _ STR + bound Tcp Shmem Port + _ STR + loc Host + _ STR ) ; return srv ; } catch (  Ignite Checked Exception e ) { last Ex = e ; if ( log . is Debug Enabled ( ) ) log . debug ( _ STR + port + _ STR + loc Host + _ STR ) ; } } throw new  Ignite Checked Exception ( _ STR + loc Port + _ STR + loc Port Range + _ STR + loc Host + _ STR , last Ex ) ; }
public static void close ( ) throws  SQLException { if ( connection != null ) { connection . close ( ) ; } }
public  Version remove Qualifier (  String qualifier ) {  List <  String > new Qualifiers = new  Array List < > ( this . qualifiers ) ; new Qualifiers . remove ( qualifier ) ; return new  Version ( major , minor , patch , new Qualifiers . to Array ( new  String [ new Qualifiers . size ( ) ] ) ) ; }
public int load Signed16 ( int addr ) { return ( load Signed8 ( addr ) << _ NUM ) | load Unsigned8 ( addr + _ NUM ) ; }
public static  String to Hex String ( byte [ ] array ) { return to Hex String (  Byte Buffer . wrap ( array ) , _ NUM , array . length ) ; }
public static void register Baggage Handler (  Baggage Handler handler ) { handlers . add ( handler ) ; }
private double fix To Range ( double x , double min X , double max X ) { if ( min X > max X ) { throw new  Illegal Argument Exception ( _ STR ) ; } if ( x < min X ) { return min X ; } else if ( x > max X ) { return max X ; } else { return x ; } }
protected void check Order ( int [ ] expected ,  String [ ] node IDs ,  List <  String > actual ) {  Assert . assert Equals ( expected . length , actual . size ( ) ) ; for ( int i = _ NUM ; i < expected . length ; i ++ ) {  Assert . assert Equals ( _ STR + i , node IDs [ expected [ i ] ] , actual . get ( i ) ) ; } }
public  Text Component (  String text ) { this . text = text ; }
void add Annotation ( @  Non Null  Annotation annotation ) { annotations . put ( annotation . annotation Type ( ) , annotation ) ; }
public  Node parse Text (  String text ) throws  IOException ,  SAXException { return parse ( new  String Reader ( text ) ) ; }
public void remove Tick Mark Section ( final  Section  SECTION ) { if ( null ==  SECTION ) return ; tick Mark Sections . remove (  SECTION ) ;  Collections . sort ( tick Mark Sections , new  Section Comparator ( ) ) ; fire Update Event (  REDRAW_ EVENT ) ; }
public static double pdf ( double x , double lambda ) { if ( x < _ NUM ) return _ NUM ; return lambda *  Math . exp ( - lambda * x ) ; }
public void flush ( ) { flush ( _ BOOL ) ; }
public  Char Buffer replace ( int start , int end , char [ ] buffer , int offset , int len ) { int length = length ( ) ; if ( start < _ NUM || end < start || length < start ) throw new  String Index Out Of Bounds Exception ( ) ; ensure Capacity ( len + length - ( end - start ) ) ; char [ ] this Buffer = buffer ( ) ; if ( len < end - start ) { int tail = length - end ; for ( int i = _ NUM ; i < tail ; i ++ ) this Buffer [ start + len + i ] = this Buffer [ end + i ] ; } else { int tail = length - end ; for ( int i = tail - _ NUM ; i >= _ NUM ; i -- ) this Buffer [ end + i ] = this Buffer [ start + len + i ] ; }  System . arraycopy ( buffer , offset , this Buffer , start , len ) ; length ( length + len - ( end - start ) ) ; return this ; }
public void add Listener (  Search Listener listener ) { listeners . add ( listener ) ; }
public final void remove (  Action action To Remove ) { int index ; for (  Action action : action List ) { if ( action . equals ( action To Remove ) ) { index = action List . index Of ( action ) ; action List . remove ( action ) ; constraints List . remove ( index ) ; need Sorting = _ BOOL ; return ; } } }
public static <  T >  String encode To Base64 (  Coder <  T > coder ,  T value ) throws  Coder Exception { byte [ ] raw Value = encode To Byte Array ( coder , value ) ; return  Base64 . encode Base64 URLSafe String ( raw Value ) ; }
public synchronized void add All (  Collection c ) { for (  Iterator iter = c . iterator ( ) ; iter . has Next ( ) ; ) { add Internal ( (  Task ) iter . next ( ) ) ; } }
public  String subtract (  Object ... values ) { double result =  Function Handler . get Double ( values [ _ NUM ] ) ; for ( int i = _ NUM ; i < values . length ; i ++ ) { result -=  Function Handler . get Double ( values [ i ] ) ; } return  Double . to String ( result ) ; }
public  DBInstance Info retrieve DBInfo (  String db Group Name ,  String host Name ) {  Connection conn = null ; try { conn = create Connection ( _ BOOL ) ; return retrieve DBInfo ( conn , db Group Name , host Name ) ; } catch (  Exception ex ) { logger . log (  Level .  SEVERE , _ STR , ex ) ; } finally {  DBUtils . close ( conn ) ; } return null ; }
public static  String quote (  String input ) {  String output = _ STR ; for ( int i = _ NUM ; i < input . length ( ) ; i ++ ) { output += _ STR + input . char At ( i ) ; } return output ; }
public int compare (  String o1 ,  String o2 ) { return o1 . compare To Ignore Case ( o2 ) ; }
public void add Apply Action Listener (  Action Listener al ) { apply Button . add Action Listener ( al ) ; }
public  Float Half Band Filter (  Filters filter , float gain ) { m Coefficients = filter . get Coefficients ( ) ; m Buffer = new  Array List <  Float > ( ) ; m Buffer Size = m Coefficients . length ; for ( int x = _ NUM ; x < m Coefficients . length ; x ++ ) { m Buffer . add ( _ NUM ) ; } generate Index Map ( m Coefficients . length ) ; m Gain = gain ; }
@  Override public  String to String ( ) {  String Buffer sb = new  String Buffer ( _ STR ) ; sb . append ( this . label ) ; sb . append ( _ STR ) ; sb . append ( this . value ) ; sb . append ( _ STR ) ; return ( sb . to String ( ) ) ; }
public static void copy Memory Field By Field ( long src Address ,  Object dest ) {  Class clazz = dest . get Class ( ) ; while ( clazz !=  Object . class ) { for (  Field f : clazz . get Declared Fields ( ) ) { if ( ( f . get Modifiers ( ) &  Modifier .  STATIC ) == _ NUM ) { final  Class type = f . get Type ( ) ;  Preconditions . check Argument ( type . is Primitive ( ) , _ STR ) ; final long offset = unsafe . object Field Offset ( f ) ; final long src = src Address + offset ; if ( type == int . class ) { unsafe . put Int ( dest , offset , unsafe . get Int ( src ) ) ; } else if ( type == long . class ) { unsafe . put Long ( dest , offset , unsafe . get Long ( src ) ) ; } else { throw new  Illegal Argument Exception ( _ STR + type ) ; } } } clazz = clazz . get Superclass ( ) ; } }
public final  V remove ( int index ) { if (  GWT . is Script ( ) ) {  V ret = js Array . get ( index ) ; js Array . remove ( index ) ; return ret ; } else { return java Array . remove ( index ) ; } }
@  Override public void action Performed (  Action Event event ) {  String command = event . get Action Command ( ) ; if ( command . equals ( _ STR ) ) { attempt Background Paint Selection ( ) ; } else if ( command . equals ( _ STR ) ) { attempt Outline Stroke Selection ( ) ; } else if ( command . equals ( _ STR ) ) { attempt Outline Paint Selection ( ) ; } else if ( command . equals ( _ STR ) ) { attempt Orientation Selection ( ) ; } else if ( command . equals ( _ STR ) ) { attempt Draw Lines Selection ( ) ; } else if ( command . equals ( _ STR ) ) { attempt Draw Shapes Selection ( ) ; } }
public static boolean create Server Instance (  SSOToken sso Token ,  String instance Name ,  String instance Id ,  Set values ,  String server Config XML ) throws  SMSException ,  SSOException ,  Configuration Exception ,  Unknown Property Name Exception { boolean created = _ BOOL ; if ( ! instance Name . equals (  DEFAULT_ SERVER_ CONFIG ) ) { validate Property ( sso Token , values ) ; }  Service Config sc = get Root Server Config With Retry ( sso Token ) ; if ( sc != null ) { if ( ! instance Name . equals (  DEFAULT_ SERVER_ CONFIG ) ) { try { new  URL ( instance Name ) ; } catch (  Malformed URLException ex ) {  String [ ] param = { instance Name } ; throw new  Configuration Exception ( _ STR , param ) ; } }  Map server Values = new  Hash Map ( _ NUM ) ;  Set set Server Id = new  Hash Set ( _ NUM ) ; set Server Id . add ( instance Id ) ; server Values . put (  ATTR_ SERVER_ ID , set Server Id ) ; if ( values . is Empty ( ) ) { values = new  Hash Set ( _ NUM ) ; } values . add (  Constants .  PROPERTY_ NAME_ LB_ COOKIE_ VALUE + _ STR + instance Id ) ;  Set set Server Config XML = new  Hash Set ( _ NUM ) ; set Server Config XML . add ( server Config XML ) ; server Values . put (  ATTR_ SERVER_ CONFIG_ XML , set Server Config XML ) ; server Values . put (  ATTR_ SERVER_ CONFIG , values ) ; if ( ! instance Name . equals (  DEFAULT_ SERVER_ CONFIG ) ) { set Protocol Host Port URI ( server Values , instance Name ) ; } sc . add Sub Config ( instance Name ,  SUBSCHEMA_ SERVER , _ NUM , server Values ) ; created = _ BOOL ; } if ( created && ! instance Name . equals (  DEFAULT_ SERVER_ CONFIG ) ) { update Organization Alias ( sso Token , instance Name , _ BOOL ) ; } return created ; }
public static  Object load Instance (  Class clazz ) throws  Class Exception { try { return clazz . new Instance ( ) ; } catch (  Instantiation Exception e ) { throw new  Class Exception ( _ STR + clazz . get Name ( ) + _ STR ) ; } catch (  Illegal Access Exception e ) { throw new  Class Exception ( _ STR ) ; } }
public  Generic Sip Rtp Session create Rtp Session (  Contact Id contact ,  String feature Tag ,  String encoding ) { if ( s Logger . is Activated ( ) ) { s Logger . info ( _ STR + contact ) ; } return new  Originating Sip Rtp Session ( this , contact , feature Tag , m Rcs Settings ,  System . current Time Millis ( ) , m Contact Manager , encoding ) ; }
protected  Paint create Horizontal Gradient (  Shape s ,  Four Colors colors ) {  Rectangle2 D bounds = s . get Bounds2 D ( ) ; float x = ( float ) bounds . get X ( ) ; float y = ( float ) bounds . get Y ( ) ; float w = ( float ) bounds . get Width ( ) ; float h = ( float ) bounds . get Height ( ) ; return create Gradient ( x , ( _ NUM * h ) + y , x + w , ( _ NUM * h ) + y , new float [ ] { _ NUM , _ NUM , _ NUM , _ NUM } , new  Color [ ] { colors . top , colors . upper Mid , colors . lower Mid , colors . bottom } ) ; }
public void component Hidden (  Component Event e ) { if ( logger . is Loggable (  Level .  FINE ) ) { logger . fine ( _ STR + layer . get Name ( ) + _ STR ) ; }  Component comp = e . get Component ( ) ; if ( comp == layer ) { if ( is Layer On ( ) != _ BOOL ) { set Layer On ( _ BOOL ) ; if ( logger . is Loggable (  Level .  FINE ) ) { logger . fine ( _ STR + layer . get Name ( ) + _ STR ) ; } } } else if ( comp == layer . get Palette ( ) ) { set Palette On ( _ BOOL ) ; } else if ( comp == null ) { if ( logger . is Loggable (  Level .  FINE ) ) { logger . fine ( _ STR + layer . get Name ( ) + _ STR ) ; } } }
public  String to Hex String ( byte [ ] block ) {  String Buffer buf = new  String Buffer ( ) ; int len = block . length ; for ( int i = _ NUM ; i < len ; i ++ ) { bytetohex ( ( byte ) ( block [ i ] + _ NUM ) , buf ) ; if ( i < len - _ NUM ) { buf . append ( _ STR ) ; } } return buf . to String ( ) ; }
public void add Label (  Label label ) { assert Not Null ( label ) ; labels . add ( label ) ; label . set Parent ( this ) ; }
public void write ( byte [ ] b , int offset , int length ) throws java . io .  IOException { out . write ( b , offset , length ) ; written += length ; }
public double len ( ) { return  Math . sqrt ( x * x + y * y ) ; }
@  Override public int clamp View Position Horizontal (  View child , int left , int dx ) { int left Bound = _ NUM ; int right Bound = _ NUM ; switch ( dragger View . get Drag Position ( ) ) { case  RIGHT : if ( left > _ NUM ) { left Bound = dragger View . get Padding Left ( ) ; right Bound = ( int ) dragger Listener . drag Horizontal Drag Range ( ) ; } break ; case  LEFT : if ( left < _ NUM ) { left Bound = ( int ) - dragger Listener . drag Horizontal Drag Range ( ) ; right Bound = dragger View . get Padding Left ( ) ; } break ; default : break ; } return  Math . min (  Math . max ( left , left Bound ) , right Bound ) ; }
@  Override public void on Login Failure (  Map request Params Map ,  Http Servlet Request request ,  Http Servlet Response response ) { }
public static  String convert To Box (  String s ) {  String temp = s . replace All ( _ STR , _ STR ) ; if ( temp . ends With ( _ STR ) ) { temp = temp . substring ( _ NUM , temp . length ( ) - _ NUM ) + _ STR ; } temp = temp . replace All ( _ STR , _ STR ) ; return  Word Utils . capitalize Fully ( temp ) ; }
public byte [ ] handle Request (  String request ) throws  IOException ,  Map Request Format Exception {  Properties request Properties = convert Request To Props ( request ) ;  String request Type = request Properties . get Property (  REQUEST ) ; if ( request Type != null ) { if ( request Type . equals Ignore Case (  MAP ) ) {  Debug . message ( _ STR , _ STR ) ; return handle Map Request ( request Properties ) ; } else { throw new  Map Request Format Exception ( _ STR + request Type ) ; } } else { throw new  Map Request Format Exception ( _ STR + request ) ; } }
public void test Set String ( ) throws  Exception { connection . set Auto Commit ( _ BOOL ) ;  Prepared Statement stmt = connection . prepare Statement ( _ STR ) ; try { stmt . set Int ( _ NUM , _ NUM ) ; stmt . set String ( _ NUM ,  TEST_ TEXT ) ; stmt . execute Update ( ) ; connection . commit ( ) ; stmt . set Int ( _ NUM , _ NUM ) ; stmt . set String ( _ NUM ,  TEST_ TEXT ) ; stmt . execute Update ( ) ; connection . commit ( ) ; stmt . set Int ( _ NUM , _ NUM ) ; stmt . set String ( _ NUM ,  TEST_ TEXT ) ; stmt . execute Update ( ) ; connection . commit ( ) ; } finally { stmt . close ( ) ; } connection . set Auto Commit ( _ BOOL ) ; }
public static long read UINT64 (  Input Stream stream ) throws  IOException { long result = _ NUM ; for ( int i = _ NUM ; i <= _ NUM ; i += _ NUM ) { result |= ( long ) stream . read ( ) << i ; } return result ; }
public  Generic URI uri Reference ( boolean in Brackets ) throws  Parse Exception { if ( debug ) dbg_enter ( _ STR ) ;  Generic URI retval = null ;  Token [ ] tokens = lexer . peek Next Token ( _ NUM ) ;  Token t1 = (  Token ) tokens [ _ NUM ] ;  Token t2 = (  Token ) tokens [ _ NUM ] ; try { if ( t1 . get Token Type ( ) ==  Token Types .  SIP || t1 . get Token Type ( ) ==  Token Types .  SIPS ) { if ( t2 . get Token Type ( ) == _ STR ) retval = sip URL ( in Brackets ) ; else throw create Parse Exception ( _ STR ) ; } else if ( t1 . get Token Type ( ) ==  Token Types .  TEL ) { if ( t2 . get Token Type ( ) == _ STR ) { retval = tel URL ( in Brackets ) ; } else throw create Parse Exception ( _ STR ) ; } else {  String url String = uric String ( ) ; try { retval = new  Generic URI ( url String ) ; } catch (  Parse Exception ex ) { throw create Parse Exception ( ex . get Message ( ) ) ; } } } finally { if ( debug ) dbg_leave ( _ STR ) ; } return retval ; }
private  CSVRecord (  List <  String > record ) { this . record =  Objects . require Non Null ( record ) ; }
private void schedule Send ( final int queue Size ) { if ( pending ) { return ; } if ( queue Size >= batch Size ) { enqueue Send ( ) ; return ; } if ( scheduled . compare And Set ( _ BOOL , _ BOOL ) ) { try { scheduler . schedule ( null , max Latency Ms ,  MILLISECONDS ) ; scheduler Queue Size . increment And Get ( ) ; } catch (  Rejected Execution Exception ignore ) { } } }
public static  String join ( int [ ] self ,  String separator ) {  String Builder buffer = new  String Builder ( ) ; boolean first = _ BOOL ; if ( separator == null ) separator = _ STR ; for ( int next : self ) { if ( first ) { first = _ BOOL ; } else { buffer . append ( separator ) ; } buffer . append ( next ) ; } return buffer . to String ( ) ; }
private <  T >  Binding Amp <  T > find Binding (  Key <  T > key ) {  Binding Set <  T > set = (  Binding Set ) _binding Set Map . get ( key . raw Class ( ) ) ; if ( set != null ) {  Binding Amp <  T > binding = set . find ( key ) ; if ( binding != null ) { return binding ; } } return null ; }
private void init Compute Program ( ) { gl Use Program ( compute Program ) ;  Int Buffer work Group Size =  Buffer Utils . create Int Buffer ( _ NUM ) ; gl Get Programiv ( compute Program ,  GL_ COMPUTE_ WORK_ GROUP_ SIZE , work Group Size ) ; work Group Size X = work Group Size . get ( _ NUM ) ; work Group Size Y = work Group Size . get ( _ NUM ) ; time Uniform = gl Get Uniform Location ( compute Program , _ STR ) ; blend Factor Uniform = gl Get Uniform Location ( compute Program , _ STR ) ; bounce Count Uniform = gl Get Uniform Location ( compute Program , _ STR ) ; int boxes Resource Index = gl Get Program Resource Index ( compute Program ,  GL_ SHADER_ STORAGE_ BLOCK , _ STR ) ;  Int Buffer props =  Buffer Utils . create Int Buffer ( _ NUM ) ;  Int Buffer params =  Buffer Utils . create Int Buffer ( _ NUM ) ; props . put ( _ NUM ,  GL_ BUFFER_ BINDING ) ; gl Get Program Resourceiv ( compute Program ,  GL_ SHADER_ STORAGE_ BLOCK , boxes Resource Index , props , null , params ) ; boxes Ssbo Binding = params . get ( _ NUM ) ; int loc = gl Get Uniform Location ( compute Program , _ STR ) ; gl Get Uniformiv ( compute Program , loc , params ) ; framebuffer Image Binding = params . get ( _ NUM ) ; loc = gl Get Uniform Location ( compute Program , _ STR ) ; gl Get Uniformiv ( compute Program , loc , params ) ; world Position Image Binding = params . get ( _ NUM ) ; loc = gl Get Uniform Location ( compute Program , _ STR ) ; gl Get Uniformiv ( compute Program , loc , params ) ; world Normal Image Binding = params . get ( _ NUM ) ; gl Use Program ( _ NUM ) ; }
public void add Response (  Response response ) { response Vector . add Element ( response ) ; }
public void space Vertical (  Array List <  Integer > nodes ) { if ( m_b Needs Undo Action ) { add Undo Action ( new space Vertical Action ( nodes ) ) ; } int n Min Y = - _ NUM ; int n Max Y = - _ NUM ; for ( int i Node = _ NUM ; i Node < nodes . size ( ) ; i Node ++ ) { int n Y = get Position Y ( nodes . get ( i Node ) ) ; if ( n Y < n Min Y || i Node == _ NUM ) { n Min Y = n Y ; } if ( n Y > n Max Y || i Node == _ NUM ) { n Max Y = n Y ; } } for ( int i Node = _ NUM ; i Node < nodes . size ( ) ; i Node ++ ) { int n Node = nodes . get ( i Node ) ; m_n Position Y . set ( n Node , ( int ) ( n Min Y + i Node * ( n Max Y - n Min Y ) / ( nodes . size ( ) - _ NUM ) ) ) ; } }
public  Text Component (  String text ) { this . text = text ; }
@  Override public void on Create (  Bundle saved Instance State ) { super . on Create ( saved Instance State ) ; set Retain Instance ( _ BOOL ) ; m Thread . start ( ) ; }
public  Minute ( int minute ,  Hour hour ) {  Param Checks . null Not Permitted ( hour , _ STR ) ; this . minute = ( byte ) minute ; this . hour = ( byte ) hour . get Hour ( ) ; this . day = hour . get Day ( ) ; peg (  Calendar . get Instance ( ) ) ; }
public void fill Combo Box ( boolean restore ) { if ( restore && m_temp Data != null ) {  Object obj = m_selected Object ; p_data . clear ( ) ; p_data = new  Array List <  Object > ( m_temp Data . length ) ; for ( int i = _ NUM ; i < m_temp Data . length ; i ++ ) p_data . add ( m_temp Data [ i ] ) ; m_temp Data = null ; if ( obj == null && p_data . size ( ) > _ NUM ) obj = p_data . get ( _ NUM ) ; set Selected Item ( obj ) ; fire Contents Changed ( this , _ NUM , p_data . size ( ) ) ; return ; } if ( p_data != null ) fill Combo Box ( is Mandatory ( ) , _ BOOL , _ BOOL , _ BOOL ) ; }
public static boolean is Network Connected (  Context context ) { if ( context == null ) { return _ BOOL ; }  Connectivity Manager cm = (  Connectivity Manager ) context . get System Service (  Context .  CONNECTIVITY_ SERVICE ) ;  Network Info network Info = cm . get Active Network Info ( ) ; return ( network Info != null && network Info . is Connected ( ) ) ; }
@  Override public void flush ( ) throws  IOException { if ( writer != null ) { writer . flush ( ) ; } }
public static  String read String (  File file ) throws  IOException {  File Input Stream in = new  File Input Stream ( file ) ; try { return read String ( in ) ; } finally { in . close ( ) ; } }
public static  String extract Music IDFrom Media ID (  String media ID ) { int pos = media ID . index Of (  LEAF_ SEPARATOR ) ; if ( pos >= _ NUM ) { return media ID . substring ( pos + _ NUM ) ; } return null ; }
public static int [ ] values (  Integer [ ] array ) { int [ ] dest = new int [ array . length ] ; for ( int i = _ NUM ; i < array . length ; i ++ ) {  Integer v = array [ i ] ; if ( v != null ) { dest [ i ] = v . int Value ( ) ; } } return dest ; }
public void read (  Buffered Reader reader ) throws  Exception {  String line ; clear ( ) ; while ( ( line = reader . read Line ( ) ) != null ) { line = line . trim ( ) ; if ( line . starts With ( _ STR ) ) { continue ; } add ( line ) ; } reader . close ( ) ; }
boolean verify String (  String str ) { if ( ( str . length ( ) > max Length ) || ( str . length ( ) < min Length ) ) { return _ BOOL ; } int i = _ NUM ;  Enumeration e = format Constraints . elements ( ) ; if ( ! str . equals ( _ STR ) ) { char c = str . char At ( i ) ; for ( ; e . has More Elements ( ) ; ) {  Format Constraint constraint = (  Format Constraint ) e . next Element ( ) ; if ( constraint . count ==  Format Constraint .  COUNT_ EXACTLY_ ONE ) { if ( ! verify Char ( c , constraint . type ) ) { return _ BOOL ; } i ++ ; if ( i < str . length ( ) ) { c = str . char At ( i ) ; } else { break ; } } else { int char Num = _ NUM ; while ( ( i < str . length ( ) ) && ( char Num < constraint . count ) ) { if ( ! verify Char ( c , constraint . type ) ) { break ; } i ++ ; char Num ++ ; if ( i < str . length ( ) ) { c = str . char At ( i ) ; } else { break ; } } if ( i >= str . length ( ) ) { break ; } } } if ( i < str . length ( ) ) { return _ BOOL ; } } while ( e . has More Elements ( ) ) {  Format Constraint constraint = (  Format Constraint ) e . next Element ( ) ; if ( constraint . count ==  Format Constraint .  COUNT_ EXACTLY_ ONE ) { return _ BOOL ; } } return _ BOOL ; }
public void read Data (  Data Input din ) throws  IOException { function = din . read Unsigned Short ( ) ; data = ( short ) ( din . read Short ( ) & _ NUM ) ; }
protected  String to String (  Trie Node node ) {  String Buffer result ; int i ;  String Buffer indentation ; result = new  String Buffer ( ) ; indentation = new  String Buffer ( ) ; for ( i = _ NUM ; i < node . get Level ( ) ; i ++ ) { indentation . append ( _ STR ) ; } result . append ( indentation . to String ( ) ) ; if ( node . get Char ( ) == null ) { result . append ( _ STR ) ; } else if ( node . get Char ( ) ==  Trie Node .  STOP ) { result . append ( _ STR ) ; } else { result . append ( _ STR + node . get Char ( ) + _ STR ) ; } result . append ( _ STR ) ; for ( i = _ NUM ; i < node . get Child Count ( ) ; i ++ ) { result . append ( to String ( (  Trie Node ) node . get Child At ( i ) ) ) ; } return result . to String ( ) ; }
public long capacity ( ) { return capacity . get ( ) ; }
protected static token do_id ( ) throws java . io .  IOException {  String Buffer result = new  String Buffer ( ) ;  String result_str ;  Integer keyword_num ; char buffer [ ] = new char [ _ NUM ] ; buffer [ _ NUM ] = ( char ) next_char ; result . append ( buffer , _ NUM , _ NUM ) ; advance ( ) ; while ( id_char ( next_char ) ) { buffer [ _ NUM ] = ( char ) next_char ; result . append ( buffer , _ NUM , _ NUM ) ; advance ( ) ; } result_str = result . to String ( ) ; keyword_num = (  Integer ) keywords . get ( result_str ) ; if ( keyword_num != null ) return new token ( keyword_num . int Value ( ) ) ; return new str_token ( sym .  ID , result_str ) ; }
public static int  Integer ( int min , int max ) { return random . next Int ( max - min + _ NUM ) + min ; }
public void test_concurrent_modification_insert_split_root_leaf ( ) { final  BTree btree ; {  Index Metadata md = new  Index Metadata (  UUID . random UUID ( ) ) ; md . set Branching Factor ( _ NUM ) ; btree =  BTree . create ( new  Simple Memory Raw Store ( ) , md ) ; btree . insert ( _ NUM , _ STR ) ; btree . insert ( _ NUM , _ STR ) ; btree . insert ( _ NUM , _ STR ) ; } {  ITuple Cursor2 <  String > cursor = new Cursor ( btree ) ; assert Equals ( new  Test Tuple <  String > ( _ NUM , _ STR ) , cursor . seek ( _ NUM ) ) ; assert Equals ( new  Test Tuple <  String > ( _ NUM , _ STR ) , cursor . tuple ( ) ) ; btree . insert ( _ NUM , _ STR ) ; assert Equals (  Test Key Builder . as Sort Key ( _ NUM ) , cursor . current Key ( ) ) ; assert Equals ( new  Test Tuple <  String > ( _ NUM , _ STR ) , cursor . tuple ( ) ) ; assert Equals ( new  Test Tuple <  String > ( _ NUM , _ STR ) , cursor . prior ( ) ) ; assert Equals ( new  Test Tuple <  String > ( _ NUM , _ STR ) , cursor . tuple ( ) ) ; btree . remove ( _ NUM ) ; assert Equals (  Test Key Builder . as Sort Key ( _ NUM ) , cursor . current Key ( ) ) ; assert Equals ( null , cursor . tuple ( ) ) ; assert Equals ( new  Test Tuple <  String > ( _ NUM , _ STR ) , cursor . next ( ) ) ; btree . remove ( _ NUM ) ; assert Equals (  Test Key Builder . as Sort Key ( _ NUM ) , cursor . current Key ( ) ) ; assert Equals ( null , cursor . tuple ( ) ) ; btree . insert ( _ NUM , _ STR ) ; assert Equals (  Test Key Builder . as Sort Key ( _ NUM ) , cursor . current Key ( ) ) ; assert Equals ( null , cursor . tuple ( ) ) ; assert Equals ( new  Test Tuple <  String > ( _ NUM , _ STR ) , cursor . next ( ) ) ; assert Equals ( new  Test Tuple <  String > ( _ NUM , _ STR ) , cursor . tuple ( ) ) ; } }
public static  String relative File (  Iterable < ? extends  File > paths ,  String file ) {  File path = select Path ( paths , file ) ;  File rel File = relative File ( path , new  File ( file ) ) ; return rel File . get Path ( ) ; }
public void remove Repository (  Repository repository ) { repository . pre Remove ( ) ; repository . remove Repository Listener ( repository Listener ) ; repositories . remove ( repository ) ; fire Update ( null ) ; }
public  Session Id ( byte [ ] session Id ) { if ( session Id == null ) { throw new  Null Pointer Exception ( _ STR ) ; } this . id =  Arrays . copy Of ( session Id , session Id . length ) ; }
void run (  String driver ,  String url ,  String user ,  String password ) throws  Exception {  Class . for Name ( driver ) ; conn =  Driver Manager . get Connection ( url , user , password ) ; stat = conn . create Statement ( ) ; try { stat . execute ( _ STR ) ; } catch (  SQLException e ) { } stat . execute ( _ STR + _ STR ) ; stat . execute ( _ STR ) ; stat . execute ( _ STR ) ; stat . execute ( _ STR ) ; login By Name Insecure ( ) ; if ( url . starts With ( _ STR ) ) { login Stored Procedure Insecure ( ) ; limit Row Access ( ) ; } login By Name Secure ( ) ; if ( url . starts With ( _ STR ) ) { stat . execute ( _ STR ) ; stat . execute ( _ STR ) ; stat . execute ( _ STR ) ; } login By Id Insecure ( ) ; login By Id Secure ( ) ; try { stat . execute ( _ STR ) ; } catch (  SQLException e ) { } stat . execute ( _ STR + _ STR ) ; stat . execute ( _ STR ) ; stat . execute ( _ STR ) ; stat . execute ( _ STR ) ; stat . execute ( _ STR ) ; stat . execute ( _ STR ) ; list Active Items ( ) ; if ( url . starts With ( _ STR ) ) { stat . execute ( _ STR ) ; stat . execute ( _ STR ) ; stat . execute ( _ STR ) ; stat . execute ( _ STR ) ; list Active Items Using Constants ( ) ; } list Items Sorted Insecure ( ) ; list Items Sorted Secure ( ) ; if ( url . starts With ( _ STR ) ) { list Items Sorted Secure Param ( ) ; store Password Hash With Salt ( ) ; } conn . close ( ) ; }
public int size ( ) { return count . get ( ) ; }
public void test Create Element NS1 ( ) throws  Throwable {  Document doc ;  Element element ;  String namespace URI = _ STR ;  String qualified Name = _ STR ;  String node Name ;  String ns URI ;  String local Name ;  String prefix ;  String tag Name ; doc = (  Document ) load ( _ STR , builder ) ; element = doc . create Element NS ( namespace URI , qualified Name ) ; node Name = element . get Node Name ( ) ; ns URI = element . get Namespace URI ( ) ; local Name = element . get Local Name ( ) ; prefix = element . get Prefix ( ) ; tag Name = element . get Tag Name ( ) ; assert Equals ( _ STR , _ STR , node Name ) ; assert Equals ( _ STR , _ STR , ns URI ) ; assert Equals ( _ STR , _ STR , local Name ) ; assert Equals ( _ STR , _ STR , prefix ) ; assert Equals ( _ STR , _ STR , tag Name ) ; }
public static  String read File To String (  Path file ) throws  IOException { byte [ ] file Array =  Files . read All Bytes ( file ) ; return new  String ( file Array ,  Standard Charsets .  UTF_8 ) ; }
public  Point2 D forward ( double lat , double lon ,  Point2 D p , boolean is Radian ) { if ( ! is Radian ) { lat =  Proj Math . deg To Rad ( lat ) ; lon =  Proj Math . deg To Rad ( lon ) ; } lat = normalize Latitude ( lat ) ; lon = wrap Longitude ( lon ) ; double x = ( scaled_radius * wrap Longitude ( lon - center X ) ) + wx ; double y = hy - ( scaled_radius * (  More Math . asinh (  Math . tan ( lat ) ) - asinh_of_tan Ctr Lat ) ) ; p . set Location ( x , y ) ; return p ; }
public boolean delete Panel ( ) { log . debug ( _ STR ) ; int selected Value =  JOption Pane . show Option Dialog ( _target Panel ,  Bundle . get Message ( _ STR ) + _ STR +  Bundle . get Message ( _ STR ) ,  Bundle . get Message ( _ STR ) ,  JOption Pane .  YES_ NO_ OPTION ,  JOption Pane .  QUESTION_ MESSAGE , null , new  Object [ ] {  Bundle . get Message ( _ STR ) ,  Bundle . get Message ( _ STR ) } ,  Bundle . get Message ( _ STR ) ) ; return ( selected Value ==  JOption Pane .  YES_ OPTION ) ; }
public int [ ] [ ] from File (  File file ) throws  IOException {  Buffered Image image =  Image IO . read ( file ) ; image = scaling If Need ( image , _ BOOL ) ; return to Int Array Array ( image ) ; }
int write Queue Size ( ) { return queue Size . get ( ) ; }
public  DGet Password (  JFrame parent ,  String title ) { super ( parent , title ,  Modality Type .  DOCUMENT_ MODAL ) ; init Components ( ) ; }
private void add Mitre Join (  Coordinate p ,  Line Segment offset0 ,  Line Segment offset1 , double distance ) { boolean is Mitre Within Limit = _ BOOL ;  Coordinate int Pt = null ; try { int Pt =  HCoordinate . intersection ( offset0 . p0 , offset0 . p1 , offset1 . p0 , offset1 . p1 ) ; double mitre Ratio = distance <= _ NUM ? _ NUM : int Pt . distance ( p ) /  Math . abs ( distance ) ; if ( mitre Ratio > buf Params . get Mitre Limit ( ) ) is Mitre Within Limit = _ BOOL ; } catch (  Not Representable Exception ex ) { int Pt = new  Coordinate ( _ NUM , _ NUM ) ; is Mitre Within Limit = _ BOOL ; } if ( is Mitre Within Limit ) { seg List . add Pt ( int Pt ) ; } else { add Limited Mitre Join ( offset0 , offset1 , distance , buf Params . get Mitre Limit ( ) ) ; } }
public void test Multiply Diff Scale Neg Pos ( ) {  String a = _ STR ; int a Scale = - _ NUM ;  String b = _ STR ; int b Scale = _ NUM ;  String c = _ STR ; int c Scale = - _ NUM ;  Big Decimal a Number = new  Big Decimal ( new  Big Integer ( a ) , a Scale ) ;  Big Decimal b Number = new  Big Decimal ( new  Big Integer ( b ) , b Scale ) ;  Big Decimal result = a Number . multiply ( b Number ) ; assert Equals ( _ STR , c , result . to String ( ) ) ; assert Equals ( _ STR , c Scale , result . scale ( ) ) ; }
public static  String format Simple Decimal With Zeros ( double d ) { return simple Format Force Zero . format ( d ) ; }
protected  Abstract Category Item Label Generator (  String label Format ,  Number Format formatter ) { this ( label Format , formatter ,  Number Format . get Percent Instance ( ) ) ; }
public void add Item (  String item , int i ) { int old Max Length = max Length ; boolean hsb Was Vis = hsb Vis ; boolean vsb Was Vis = vsb Vis ; int added Index = _ NUM ; if ( i < _ NUM || i >= items . size ( ) ) { i = - _ NUM ; } current Index = - _ NUM ; if ( i == - _ NUM ) { items . add Element ( item ) ; i = _ NUM ; added Index = items . size ( ) - _ NUM ; } else { items . insert Element At ( item , i ) ; added Index = i ; for ( int j = _ NUM ; j < selected . length ; j ++ ) { if ( selected [ j ] >= i ) { selected [ j ] += _ NUM ; } } } if ( log . is Loggable (  Platform Logger .  Level .  FINER ) ) { log . finer ( _ STR + item + _ STR + added Index ) ; } boolean repaint Items = ! is Item Hidden ( added Index ) ; max Length =  Math . max ( max Length , get Item Width ( added Index ) ) ; layout ( ) ; int options = _ NUM ; if ( vsb Vis != vsb Was Vis || hsb Vis != hsb Was Vis ) { options =  PAINT_ ALL ; } else { options = ( repaint Items ? (  PAINT_ ITEMS ) : _ NUM ) | ( ( max Length != old Max Length || ( hsb Was Vis ^ hsb Vis ) ) ? (  PAINT_ HSCROLL ) : _ NUM ) | ( ( vsb . needs Repaint ( ) ) ? (  PAINT_ VSCROLL ) : _ NUM ) ; } if ( log . is Loggable (  Platform Logger .  Level .  FINEST ) ) { log . finest ( _ STR + get Last Visible Item ( ) + _ STR + ( hsb Was Vis ^ hsb Vis ) + _ STR + repaint Items ) ; } repaint ( added Index , get Last Visible Item ( ) , options ) ; }
synchronized int allocate (  Glow Entity entity ) { if ( entity . id != _ NUM ) { throw new  Illegal State Exception ( _ STR ) ; } int started At = last Id ; for ( int id = last Id + _ NUM ; id != started At ; ++ id ) { if ( id == - _ NUM || id == _ NUM ) continue ; if ( used Ids . add ( id ) ) { entity . id = id ; last Id = id ; return id ; } } throw new  Illegal State Exception ( _ STR ) ; }
public void clear Cache ( int cache Size ) { param Cache = new  Parameters [ cache Size ] ; command Cache = new  Jasmin Command [ cache Size ] ; cached = new boolean [ cache Size ] ; }
public void read (  Reader policy ) throws  Parsing Exception ,  IOException { if ( ! ( policy instanceof  Buffered Reader ) ) { policy = new  Buffered Reader ( policy ) ; } st = new  Stream Tokenizer ( policy ) ; st . reset Syntax ( ) ; st . word Chars ( _ STR , _ STR ) ; st . word Chars ( _ STR , _ STR ) ; st . word Chars ( _ STR , _ STR ) ; st . word Chars ( _ STR , _ STR ) ; st . word Chars ( _ STR , _ STR ) ; st . word Chars ( _ STR , _ STR ) ; st . word Chars ( _ NUM + _ NUM , _ NUM ) ; st . whitespace Chars ( _ NUM , _ STR ) ; st . comment Char ( _ STR ) ; st . quote Char ( _ STR ) ; st . quote Char ( _ STR ) ; st . lower Case Mode ( _ BOOL ) ; st . ordinary Char ( _ STR ) ; st . slash Slash Comments ( _ BOOL ) ; st . slash Star Comments ( _ BOOL ) ; lookahead = st . next Token ( ) ;  Grant Entry ge = null ; while ( lookahead !=  Stream Tokenizer .  TT_ EOF ) { if ( peek ( _ STR ) ) { ge = parse Grant Entry ( ) ; if ( ge != null ) add ( ge ) ; } else if ( peek ( _ STR ) && key Store Url String == null ) { parse Key Store Entry ( ) ; } else if ( peek ( _ STR ) && store Pass URL == null ) { parse Store Pass URL ( ) ; } else if ( ge == null && key Store Url String == null && store Pass URL == null && peek ( _ STR ) ) { if ( domain Entries == null ) { domain Entries = new  Tree Map < > ( ) ; }  Domain Entry de = parse Domain Entry ( ) ; if ( de != null ) {  String domain Name = de . get Name ( ) ; if ( ! domain Entries . contains Key ( domain Name ) ) { domain Entries . put ( domain Name , de ) ; } else {  Message Format form = new  Message Format (  Resources Mgr . get String ( _ STR ) ) ;  Object [ ] source = { domain Name } ; throw new  Parsing Exception ( form . format ( source ) ) ; } } } else { } match ( _ STR ) ; } if ( key Store Url String == null && store Pass URL != null ) { throw new  Parsing Exception (  Resources Mgr . get String ( _ STR ) ) ; } }
protected void inject Into Volume Characterstic Container (  Map <  String ,  String > volume Characterstic ,  String characterstic Key ,  String alt Char Key ,  CIMInstance volume Instance ) {  Object value = get CIMProperty Value ( volume Instance , characterstic Key ) ; if ( null == value ) { value = get CIMProperty Value ( volume Instance , alt Char Key ) ; }  String characterstic Name =  Supported Volume Characterstics . get Volume Characterstic ( characterstic Key ) ; if ( null != value && null != characterstic Name ) { volume Characterstic . put ( characterstic Name , value . to String ( ) ) ; } }
@  Override @  Ui Thread public void on Detached From Recycler View ( @  Non Null  Recycler View recycler View ) { super . on Detached From Recycler View ( recycler View ) ; m Attached Recycler View Pool . remove ( recycler View ) ; }
private void load File (  String filename ,  Abstract File Loader ... loaders ) {  Data Sorted Table Model model ; this . m_ Filename = filename ; create Title ( ) ; if ( filename . equals ( _ STR ) ) { model = null ; } else { model = new  Data Sorted Table Model ( filename , loaders ) ; model . set Show Attribute Index ( get Show Attribute Index ( ) ) ; } m_ Table Data . set Model ( model ) ; set Changed ( _ BOOL ) ; create Name ( ) ; }
protected void display Results ( ) {  Result result ; if ( m_ Result History List . get Selected Index ( ) == - _ NUM ) { m_ Text Area Results . set Text ( _ STR ) ; return ; } result = m_ Result History List . get Result At ( m_ Result History List . get Selected Index ( ) ) ; if ( result == null ) return ; m_ Text Area Results . set Text ( result . to String ( ) ) ; }
public static boolean is Gzip File (  Input Stream in ) throws  IOException { if ( ! in . mark Supported ( ) ) { throw new  Illegal Argument Exception ( _ STR ) ; } in . mark ( _ NUM ) ; try { final byte [ ] b = new byte [ _ NUM ] ;  IOUtils . read Fully ( in , b , _ NUM , _ NUM ) ; final int magic = ( ( ( int ) b [ _ NUM ] & _ NUM ) << _ NUM ) | ( ( int ) b [ _ NUM ] & _ NUM ) ; return magic ==  GZIPInput Stream .  GZIP_ MAGIC ; } finally { in . reset ( ) ; } }
@  Override public int hash Code ( ) { return value . hash Code ( ) ; }
public static int prefix Length To Netmask Int ( int prefix Length ) throws  Illegal Argument Exception { if ( prefix Length < _ NUM || prefix Length > _ NUM ) { throw new  Illegal Argument Exception ( _ STR ) ; } int value = _ NUM << ( _ NUM - prefix Length ) ; return  Integer . reverse Bytes ( value ) ; }
public void add Subject (  String subject Name ,  Subject subject ) throws  Name Already Exists Exception ,  Invalid Name Exception ,  Policy Exception ,  SSOException { add Subject ( subject Name , subject , _ BOOL ) ; }
protected void expand For ( int index , int d ) { if ( index < size ) return ; int old Size = size , capacity = vector . length ; size = index + _ NUM ; if ( capacity >= size ) return ; while ( capacity < size ) capacity *= _ NUM ; int [ ] t = new int [ capacity ] ;  System . arraycopy ( vector , _ NUM , t , _ NUM , old Size ) ; if ( d != _ NUM )  Arrays . fill ( t , old Size , size , d ) ; vector = t ; }
private  List <  String > build Command Line ( ) {  List <  String > command Line = new  Array List <  String > ( ) ; command Line . add ( executable ) ; command Line . add All ( jvm Arguments ) ; command Line . add All ( system Properties ) ; if ( classpath != null && jar Path == null ) { command Line . add ( _ STR ) ; command Line . add ( classpath ) ; } if ( jar Path != null ) { command Line . add ( _ STR ) ; command Line . add ( jar Path ) ; } if ( jar Path == null ) { command Line . add ( main Class ) ; } command Line . add All ( application Arguments ) ; return command Line ; }
public  Image base For (  IHex hex ) { return hex Tileset . get Base ( hex , boardview ) ; }
public static  Address from Encoded ( final  String encoded ) { if ( null == encoded ) { throw new  Illegal Argument Exception ( _ STR ) ; } return new  Address ( encoded . to Upper Case ( ) ) ; }
private void write Java Parameter Spec (  Java Parameter Spec spec ,  Document document ,  Element parent Element ) {  Element parameter = document . create Element ( _ STR ) ; parent Element . append Child ( parameter ) ; parameter . set Attribute ( _ STR , spec . get Package Name ( ) ) ; parameter . set Attribute ( _ STR , spec . get Class Name ( ) ) ; parameter . set Attribute ( _ STR , spec . get Half Signature ( ) ) ; parameter . set Attribute ( _ STR ,  Integer . to String ( spec . get Param Idx ( ) ) ) ; }
private synchronized void read Object ( java . io .  Object Input Stream s ) throws  IOException ,  Class Not Found Exception { s . default Read Object ( ) ; init ( get Mask ( actions ) ) ; }
@  Override public synchronized void parse (  Input Stream in ,  String base URI ) throws  IOException ,  RDFParse Exception ,  RDFHandler Exception { if ( in == null ) { throw new  Illegal Argument Exception ( _ STR ) ; } if ( base URI == null ) { throw new  Illegal Argument Exception ( _ STR ) ; }  Input Source input Source = new  Input Source ( new  BOMInput Stream ( in , _ BOOL ) ) ; input Source . set System Id ( base URI ) ; parse ( input Source ) ; }
public static int convert To Utf32 (  String text , int idx ) { return ( text . char At ( idx ) - _ NUM ) * _ NUM + text . char At ( idx + _ NUM ) - _ NUM + _ NUM ; }
public static  File file (  String s ) {  File f = new  File ( s ) ; return f ; }
public void insert Row ( int row Index ,  Row Spec row Spec ) { if ( row Index < _ NUM || row Index > get Row Count ( ) ) { throw new  Index Out Of Bounds Exception ( _ STR + row Index + _ STR + get Row Count ( ) + _ STR ) ; } row Specs . add ( row Index - _ NUM , row Spec ) ; shift Components Vertically ( row Index , _ BOOL ) ; adjust Group Indices ( row Group Indices , row Index , _ BOOL ) ; }
public void put (  Double Min Max val ) { min = val . min < min ? val . min : min ; max = val . max > max ? val . max : max ; }
public  Int Buffer minor Version Buffer ( ) { int [ ] holder = new int [ _ NUM ] ; holder [ _ NUM ] = get Minor Version ( ) ;  Int Buffer ib =  Int Buffer . wrap ( holder ) ; ib . limit ( _ NUM ) ; return ib ; }
public  Create Snapshot Request source ( byte [ ] source ) { return source ( source , _ NUM , source . length ) ; }
public static byte [ ] double Digest ( byte [ ] input , int offset , int length ) { synchronized ( digest ) { digest . reset ( ) ; digest . update ( input , offset , length ) ; byte [ ] first = digest . digest ( ) ; return digest . digest ( first ) ; } }
private boolean is Modified ( ) { long uid List Modified = uid File . last Modified ( ) ; long cur Modified = cur Folder . last Modified ( ) ; long new Modified = new Folder . last Modified ( ) ; if ( cur Modified >= uid List Modified || new Modified >= uid List Modified ) { return _ BOOL ; } return _ BOOL ; }
public  Local File (  File file ) { this . file = file ; this . file Path = file . get Absolute Path ( ) ; }
public static  Object demux Array (  Object src , int [ ] dims ,  Class < ? > component Type ) {  Object dst = null ; if ( component Type != byte . class ) { dst =  Array . new Instance ( component Type , dims ) ; } else { int [ ] dims Temp = new int [ dims . length + _ NUM ] ;  System . arraycopy ( dims , _ NUM , dims Temp , _ NUM , dims . length ) ; dims Temp [ dims . length ] = _ NUM ; dst =  Array . new Instance ( component Type , dims Temp ) ; } _fill Demux ( _ NUM , dims , src , _ NUM , dst ) ; return dst ; }
protected void on Exception ( final  Exception e ) {  LOG . info ( _ STR , e . get Message ( ) ) ;  LOG . debug ( _ STR , e ) ; }
public  String request Statistics ( ) { if ( interval > _ NUM ) { synchronized ( sbmutex ) { return sb . to String ( ) ; } } else { sb . set Length ( _ NUM ) ; make String Buffer ( sb ) ; return sb . to String ( ) ; } }
private long hash ( final int x , final int k ) { return ( ( ( a [ k ] * x ) ^ b [ k ] ) & _ NUM ) % m ; }
@  Override public void key Pressed (  Key Event e ) { synchronized ( key Lock ) { keys Down . add ( e . get Key Code ( ) ) ; } for (  Draw Listener listener : listeners ) listener . key Pressed ( e . get Key Code ( ) ) ; }
public static  String slurp URLNo Exceptions (  URL u ) { try { return slurp URL ( u ) ; } catch (  Exception e ) { e . print Stack Trace ( ) ; return null ; } }
public static  Create Participant [ ] load Create Participants (  Refactoring Status status ,  Refactoring Processor processor ,  Object element ,  Create Arguments arguments ,  IParticipant Descriptor Filter filter ,  String affected Natures [ ] ,  Sharable Participants shared ) {  Refactoring Participant [ ] participants = fg Create Instance . get Participants ( status , processor , element , arguments , filter , affected Natures , shared ) ;  Create Participant [ ] result = new  Create Participant [ participants . length ] ;  System . arraycopy ( participants , _ NUM , result , _ NUM , participants . length ) ; return result ; }
public void add Neighbor (  Individual neighbor ) { neighbors . add ( neighbor ) ; }
private void paint Foreground Pressed (  Graphics2 D g , int width , int height ) {  Shape s = decode Arrow Path ( width , height ) ; g . set Paint ( pressed Color ) ; g . fill ( s ) ; }
private void create The User For Single User Mode ( ) { if ( ! is In Single User Mode ( ) ) { return ; } try { final  User user = db Logic . get Or Create User ( single User Name ) ; if ( user == null ) { logger . log (  Level .  SEVERE , _ STR ) ; return ; } if ( ! user . get Is Single User ( ) ) { user . set Is Single User ( _ BOOL ) ; } if ( ! user . get Is Admin ( ) ) { user . set Is Admin ( _ BOOL ) ; } db Logic . commit ( ) ; } catch ( final  Persistence Exception e ) { logger . log (  Level .  SEVERE , _ STR , e ) ; } }
@  Override public void close ( ) throws  XMLStream Exception { log . log (  Level .  FINE , _ STR ) ; stream . close ( ) ; }
public static void close ( ) throws  SQLException { if ( connection != null ) { connection . close ( ) ; } }
public void validate (  Object obj ) {  Class clazz = obj . get Class ( ) ;  Validator validator = _input Type Map . get ( clazz ) ; if ( validator == null ) { validator = new  Validator ( clazz ) ; _input Type Map . put If Absent ( clazz , validator ) ; } validator . validate ( obj ) ; }
void cross Over (  Bayes Net Representation other ) { boolean [ ] bits = new boolean [ m_bits . length ] ; for ( int i = _ NUM ; i < m_bits . length ; i ++ ) { bits [ i ] = m_bits [ i ] ; } int i Cross Over Point = m_bits . length ; do { for ( int i = i Cross Over Point ; i < m_bits . length ; i ++ ) { m_bits [ i ] = bits [ i ] ; } i Cross Over Point = m_random . next Int ( m_bits . length ) ; for ( int i = i Cross Over Point ; i < m_bits . length ; i ++ ) { m_bits [ i ] = other . m_bits [ i ] ; } } while ( has Cycles ( ) ) ; calc Score ( ) ; }
public byte [ ] digest ( ) { byte [ ] result = engine Digest ( ) ; state =  INITIAL ; return result ; }
public void show Perspective ( final  String perspective Name ) { show Perspective ( model . get Perspective ( perspective Name ) ) ; }
public static double phred To Prob ( double phred ) { return  Math . pow ( _ NUM , - phred / _ NUM ) ; }
@  Suppress Warnings ( { _ STR , _ STR } ) @  No Inline @  Pure private static  Object make Argument Compatible (  RVMType expected Type ,  Object arg ) { if ( expected Type . is Primitive Type ( ) ) { if ( arg instanceof java . lang .  Byte ) { if ( expected Type . is Byte Type ( ) ) return arg ; if ( expected Type . is Short Type ( ) ) return  Short . value Of ( (  Byte ) arg ) ; if ( expected Type . is Int Type ( ) ) return  Integer . value Of ( (  Byte ) arg ) ; if ( expected Type . is Long Type ( ) ) return  Long . value Of ( (  Byte ) arg ) ; } else if ( arg instanceof java . lang .  Short ) { if ( expected Type . is Short Type ( ) ) return arg ; if ( expected Type . is Int Type ( ) ) return  Integer . value Of ( (  Short ) arg ) ; if ( expected Type . is Long Type ( ) ) return  Long . value Of ( (  Short ) arg ) ; } else if ( arg instanceof java . lang .  Character ) { if ( expected Type . is Char Type ( ) ) return arg ; if ( expected Type . is Int Type ( ) ) return  Integer . value Of ( (  Character ) arg ) ; if ( expected Type . is Long Type ( ) ) return  Long . value Of ( (  Character ) arg ) ; } else if ( arg instanceof java . lang .  Integer ) { if ( expected Type . is Int Type ( ) ) return arg ; if ( expected Type . is Long Type ( ) ) return  Long . value Of ( (  Integer ) arg ) ; } else if ( arg instanceof java . lang .  Float ) { if ( expected Type . is Double Type ( ) ) return  Double . value Of ( (  Float ) arg ) ; } } return arg ; }
public void test Set String ( ) throws  Exception { connection . set Auto Commit ( _ BOOL ) ;  Prepared Statement stmt = connection . prepare Statement ( _ STR ) ; try { stmt . set Int ( _ NUM , _ NUM ) ; stmt . set String ( _ NUM ,  TEST_ TEXT ) ; stmt . execute Update ( ) ; connection . commit ( ) ; stmt . set Int ( _ NUM , _ NUM ) ; stmt . set String ( _ NUM ,  TEST_ TEXT ) ; stmt . execute Update ( ) ; connection . commit ( ) ; stmt . set Int ( _ NUM , _ NUM ) ; stmt . set String ( _ NUM ,  TEST_ TEXT ) ; stmt . execute Update ( ) ; connection . commit ( ) ; } finally { stmt . close ( ) ; } connection . set Auto Commit ( _ BOOL ) ; }
public  Eg Demand Details insert Advance Collection ( final  String demand Reason , final  Big Decimal advance Collection Amount , final  Installment installment ) {  Eg Demand Details demand Detail = null ; if ( advance Collection Amount != null && advance Collection Amount . compare To (  Big Decimal .  ZERO ) > _ NUM ) { final  Eg Demand Reason Master eg Demand Reason Master = demand Generic DAO . get Demand Reason Master By Code (  Water Tax Constants .  DEMANDRSN_ CODE_ ADVANCE , module ( ) ) ; if ( eg Demand Reason Master == null ) throw new  Application Runtime Exception ( _ STR ) ; final  Eg Demand Reason eg Demand Reason = demand Generic DAO . get Dmd Reason By Dmd Reason Mster Install And Mod ( eg Demand Reason Master , installment , module ( ) ) ; if ( eg Demand Reason == null ) throw new  Application Runtime Exception ( _ STR ) ; demand Detail = create Demand Details ( eg Demand Reason , advance Collection Amount ,  Big Decimal .  ZERO ) ; } return demand Detail ; }
private void load Database Header (  Byte Buffer bb ) throws  IOException { if ( bb . get Int ( ) !=  MAGIC ) { throw new  Error ( _ STR ) ; } if ( bb . get Int ( ) !=  VERSION ) { throw new  Error ( _ STR ) ; } sample Rate = bb . get Int ( ) ; num Channels = bb . get Int ( ) ; lpc Min = bb . get Float ( ) ; lpc Range = bb . get Float ( ) ; }
public void handle Periodic Maintenance (  Operation post ) { post . complete ( ) ; }
public <  T >  T time (  Callable <  T > event ) throws  Exception { final long start Time = clock . get Tick ( ) ; try { return event . call ( ) ; } finally { update ( clock . get Tick ( ) - start Time ) ; } }
public static boolean is Post JDK5 (  String bytecode Version ) { return  JDK5 . equals ( bytecode Version ) ||  JDK6 . equals ( bytecode Version ) ||  JDK7 . equals ( bytecode Version ) ||  JDK8 . equals ( bytecode Version ) ; }
public  Create Index Request mapping (  String type ,  Object ... source ) { mapping ( type ,  Put Mapping Request . build From Simplified Def ( type , source ) ) ; return this ; }
public static  Buffered Input Stream new Input Stream (  File file ) throws  File Not Found Exception { return new  Buffered Input Stream ( new  File Input Stream ( file ) ) ; }
public void remove Listener (  Circular Progress View Listener listener ) { listeners . remove ( listener ) ; }
public boolean is Status Check ( ) { return check Status ; }
public int add Glyph (  Font Definition .  Glyph glyph ) { int idx = glyphs . size ( ) ; if ( glyph . get Code ( ) > _ NUM ) {  Integer code I = new  Integer ( glyph . get Code ( ) ) ; indices . put ( code I , new  Integer ( idx ) ) ; glyphs . put ( code I , glyph ) ; } glyph List . add ( glyph ) ; return idx ; }
public void log (  S retained ,  S discarded ) { if ( discarded == null ) return ;  List <  S > retained List = history Map . get ( retained ) ; if ( retained List == null ) { retained List = new  Array List < > ( ) ; history Map . put ( retained , retained List ) ; }  List <  S > discarded List = history Map . get Or Default ( discarded ,  Collections . empty List ( ) ) ; history Map . remove ( discarded ) ; retained List . add All ( discarded List ) ; retained List . add ( discarded ) ; }
public final static boolean is Main Context (  App Context ctx ) { return ( ctx != null && ctx == main App Context ) ; }
private  List <  String > pick Table Names From Table Models ( ) {  List <  String > table Names = new  Array List <  String > ( ) ; for (  Table Model table Model : m Table Models ) { table Names . add ( table Model . get Table Name ( ) ) ; } return table Names ; }
public void train (  Map  Category Values ,  String s Suggested Category ,  String s Final Category ) { if (  Category Values == null )  Category Values = new  Hash Map ( ) ; if (  Category Values . size ( ) > _ NUM ) v Previous Decisions . add ( new  Decision Support (  Category Values , s Suggested Category , s Final Category ) ) ; }
private void unmark Removed Default Session Token (  String site ,  String token ) { if ( removed Default Tokens == null ) return ;  Hash Set <  String > removed = removed Default Tokens . get ( site ) ; if ( removed == null ) return ; removed . remove ( token ) ; }
public  Map <  URI ,  List <  URI > > add Target Volume Snapshots ( ) {  List <  URI > block Snapshots =  Lists . new Array List ( ) ;  Map <  URI ,  List <  URI > > snapshots Map = new  Hash Map < > ( ) ;  URI target CG = null ; for (  URI volume Id : uris ( volume Ids ) ) {  List <  URI > targets = get Targets ( volume Id ) ; for (  URI target : targets ) { if ( target CG == null ) { target CG = get Consistency Group ( target ) ; }  List <  URI > snapshots = get Snapshots ( target ) ; block Snapshots . add All ( snapshots ) ; snapshots Map . put ( target , snapshots ) ; } } if ( ! block Snapshots . is Empty ( ) && target CG != null ) {  Block Storage Utils . add Volumes To Consistency Group ( target CG , block Snapshots ) ; } return snapshots Map ; }
public  Twitch Api Request (  Twitch Api origin ,  Request Type type ,  String url ) { this ( origin , type , url , null ) ; }
public void add Time To Bounds ( long time Stamp ) { long old Start Time = start Time ; long old End Time = end Time ; add Time ( time Stamp ) ; if ( old Start Time != start Time || old End Time != end Time ) { fire Update Time Bounds ( new  Time Bounds Event ( this , new  Time Bounds ( old Start Time , old End Time ) , new  Time Bounds ( start Time , end Time ) ) ) ; } }
public void add Address (  Address Entity address ) { addresses . add ( address ) ; }
public  Deployer Servlet (  Server server ) { this . config Home =  System . get Property ( _ STR ) ; if ( this . config Home == null ) { this . config Home =  System . get Property ( _ STR ) ; } if ( this . config Home == null ) { this . config Home =  System . get Property ( _ STR ) ; } if ( this . config Home == null ) { throw new  Illegal State Exception ( _ STR ) ; } this . web App Directory = new  File ( this . config Home , _ STR ) ;  Handler [ ] handles = server . get Child Handlers ( ) ; for (  Handler handle : handles ) { if ( handle instanceof  Context Handler Collection ) { chc = (  Context Handler Collection ) handle ; break ; } } }
static synchronized  String format (  String key ,  Object [ ] arguments ) { if ( message Format == null ) { message Format = new  Message Format ( text Resources . get String ( key ) ) ; } else { message Format . apply Pattern ( text Resources . get String ( key ) ) ; } return ( message Format . format ( arguments ) ) ; }
private int accent Prominence Rule (  Element segment ) { int return Value = _ NUM ;  Element syllable = get Syllable ( segment ) ; if ( has Accent ( syllable ) ) {  Element prosody = (  Element )  Dom Utils . get Ancestor ( segment ,  Mary XML .  PROSODY ) ; if ( prosody != null ) {  Prosodic Settings settings = (  Prosodic Settings ) prosody Map . get ( prosody ) ; if ( settings != null ) { int accent Prominence = settings . accent Prominence ( ) ; if ( accent Prominence != _ NUM ) { if ( is In Nucleus ( segment ) ) { return Value = accent Prominence ; }  String vq = segment . get Attribute ( _ STR ) ; if ( accent Prominence >= _ NUM ) { if ( vq . equals ( _ STR ) || vq . equals ( _ STR ) || vq . equals ( _ STR ) ) vq = _ STR ; } else if ( accent Prominence >= _ NUM ) { if ( vq . equals ( _ STR ) ) { vq = _ STR ; } else if ( vq . equals ( _ STR ) || vq . equals ( _ STR ) ) { vq = _ STR ; } } if ( ! vq . equals ( segment . get Attribute ( _ STR ) ) ) { segment . set Attribute ( _ STR , vq ) ; } } } } } return return Value ; }
@  Suppress Warnings ( _ STR )  Set <  String > find Resource Names From File System (  String class Path Root On Disk ,  String scan Root Location ,  File folder ) throws  IOException {  LOG . debug ( _ STR + folder . get Path ( ) + _ STR + scan Root Location + _ STR ) ;  Set <  String > resource Names = new  Tree Set <  String > ( ) ;  File [ ] files = folder . list Files ( ) ; for (  File file : files ) { if ( file . can Read ( ) ) { if ( file . is Directory ( ) ) { resource Names . add All ( find Resource Names From File System ( class Path Root On Disk , scan Root Location , file ) ) ; } else { resource Names . add ( to Resource Name On Classpath ( class Path Root On Disk , file ) ) ; } } } return resource Names ; }
private void check Protocol Already Exists (  Set <  String > protocols ,  String protocol Type ) { if ( ! protocols . contains ( protocol Type ) ) { protocols . add ( protocol Type ) ; } }
public void put ( final  Long key ) { key List . add ( key ) ; }
public  Custom Configuration Builder (  Class Loader cl ,  String resource ) throws  Configuration Exception { this ( ) ;  Input Stream is = cl . get Resource As Stream ( resource ) ; if ( is == null ) throw new  Configuration Exception ( _ STR + resource + _ STR ) ; try { try { load ( is ) ; loaded On Instantiation = _ BOOL ; } finally { is . close ( ) ; } } catch (  IOException e ) { throw new  Configuration Exception ( e ) ; } }
public  Log Message read Log Batch (  Log Message start Log ,  List <  Log Message > log Batch ) throws  IOException ,  Compressor Exception { long batch Time = start Log . get Time ( ) ; log Batch . add ( start Log ) ;  Log Message msg ; while ( ( msg = read Next Merged Log Message ( ) ) != null ) { if ( msg . get Time ( ) == batch Time ) { log Batch . add ( msg ) ; } else { return msg ; } } return null ; }
protected  Size2 D draw Horizontal (  Graphics2 D g2 ,  Rectangle2 D chart Area ) { double start Y ; double top Space ; double bottom Space ; double left Space ; double right Space ; double w = get Width ( ) ; double h = get Height ( ) ;  Rectangle Insets padding = get Padding ( ) ; top Space = padding . calculate Top Outset ( h ) ; bottom Space = padding . calculate Bottom Outset ( h ) ; left Space = padding . calculate Left Outset ( w ) ; right Space = padding . calculate Right Outset ( w ) ; if ( get Position ( ) ==  Rectangle Edge .  TOP ) { start Y = chart Area . get Y ( ) + top Space ; } else { start Y = chart Area . get Y ( ) + chart Area . get Height ( ) - bottom Space - h ; }  Horizontal Alignment horizontal Alignment = get Horizontal Alignment ( ) ; double start X = _ NUM ; if ( horizontal Alignment ==  Horizontal Alignment .  CENTER ) { start X = chart Area . get X ( ) + left Space + chart Area . get Width ( ) / _ NUM - w / _ NUM ; } else if ( horizontal Alignment ==  Horizontal Alignment .  LEFT ) { start X = chart Area . get X ( ) + left Space ; } else if ( horizontal Alignment ==  Horizontal Alignment .  RIGHT ) { start X = chart Area . get X ( ) + chart Area . get Width ( ) - right Space - w ; } g2 . draw Image ( this . image , ( int ) start X , ( int ) start Y , ( int ) w , ( int ) h , null ) ; return new  Size2 D ( chart Area . get Width ( ) + left Space + right Space , h + top Space + bottom Space ) ; }
private final  Public Key construct Public Key ( byte [ ] encoded Key ,  String encoded Key Algorithm ) throws  Invalid Key Exception ,  No Such Algorithm Exception {  Public Key key = null ; try {  Key Factory key Factory =  Key Factory . get Instance ( encoded Key Algorithm ,  Sun JCE . get Instance ( ) ) ;  X509 Encoded Key Spec key Spec = new  X509 Encoded Key Spec ( encoded Key ) ; key = key Factory . generate Public ( key Spec ) ; } catch (  No Such Algorithm Exception nsae ) { try {  Key Factory key Factory =  Key Factory . get Instance ( encoded Key Algorithm ) ;  X509 Encoded Key Spec key Spec = new  X509 Encoded Key Spec ( encoded Key ) ; key = key Factory . generate Public ( key Spec ) ; } catch (  No Such Algorithm Exception nsae2 ) { throw new  No Such Algorithm Exception ( _ STR + _ STR + encoded Key Algorithm + _ STR ) ; } catch (  Invalid Key Spec Exception ikse2 ) { } } catch (  Invalid Key Spec Exception ikse ) { } return key ; }
public boolean in Test Set (  String source Side ) { if ( ! source Side . equals ( last Source Side ) ) { last Source Side = source Side ; accepted Last Source Side = filter . permits ( source Side ) ; } else { cached ++ ; } return accepted Last Source Side ; }
@  Override public  Completable Future <  Optional <  T > > min ( final  Comparator < ? super  T > comparator ) { return  Completable Future . supply Async ( null , exec ) ; }
final public void println ( int v ) {  Writer out = this . out ; if ( out == null ) return ; print ( v ) ; try { out . write ( _newline , _ NUM , _newline . length ) ; } catch (  IOException e ) { log . log (  Level .  FINE , e . to String ( ) , e ) ; } }
public void write ( final  IRaw Store store ) { if ( addr Metadata != _ NUM ) { throw new  Illegal State Exception ( _ STR ) ; } if ( index UUID == null ) { throw new  Illegal State Exception ( _ STR ) ; } this . addr Metadata = store . write (  Byte Buffer . wrap (  Serializer Util . serialize ( this ) ) ) ; }
protected  Map <  Object ,  Object > create Attribute Map ( ) { return  Collections . synchronized Map ( new  Linked Hash Map <  Object ,  Object > ( ) ) ; }
private static int line Wrap Index (  String line , int max Width ) { for ( int i = max Width ; i > _ NUM ; i -- ) { if ( is Line Wrap Char ( line . char At ( i ) ) ) { return i ; } } for ( int i = max Width + _ NUM ; i < line . length ( ) ; i ++ ) { if ( is Line Wrap Char ( line . char At ( i ) ) ) { return i ; } } return line . length ( ) ; }
@  Override public boolean adjust Entry (  Mk App Entry entry ,  DBID routing Object ID , double parent Distance ,  Abstract MTree <  O ,  Mk App Tree Node <  O > ,  Mk App Entry , ? > m Tree ) { super . adjust Entry ( entry , routing Object ID , parent Distance , m Tree ) ; return _ BOOL ; }
private static  String do Normalize (  String filename , char separator , boolean keep Separator ) { if ( filename == null ) return null ; int size = filename . length ( ) ; if ( size == _ NUM ) return filename ; int prefix = get Prefix Length ( filename ) ; if ( prefix < _ NUM ) return null ; char [ ] array = new char [ size + _ NUM ] ; filename . get Chars ( _ NUM , filename . length ( ) , array , _ NUM ) ; char other Separator = separator ==  SYSTEM_ SEPARATOR ?  OTHER_ SEPARATOR :  SYSTEM_ SEPARATOR ; for ( int i = _ NUM ; i < array . length ; i ++ ) { if ( array [ i ] == other Separator ) array [ i ] = separator ; } boolean last Is Directory = _ BOOL ; if ( array [ size - _ NUM ] != separator ) { array [ size ++ ] = separator ; last Is Directory = _ BOOL ; } for ( int i = prefix + _ NUM ; i < size ; i ++ ) { if ( array [ i ] == separator && array [ i - _ NUM ] == separator ) {  System . arraycopy ( array , i , array , i - _ NUM , size - i ) ; size -- ; i -- ; } } for ( int i = prefix + _ NUM ; i < size ; i ++ ) { if ( array [ i ] == separator && array [ i - _ NUM ] == _ STR && ( i == prefix + _ NUM || array [ i - _ NUM ] == separator ) ) { if ( i == size - _ NUM ) last Is Directory = _ BOOL ;  System . arraycopy ( array , i + _ NUM , array , i - _ NUM , size - i ) ; size -= _ NUM ; i -- ; } } outer : for ( int i = prefix + _ NUM ; i < size ; i ++ ) { if ( array [ i ] == separator && array [ i - _ NUM ] == _ STR && array [ i - _ NUM ] == _ STR && ( i == prefix + _ NUM || array [ i - _ NUM ] == separator ) ) { if ( i == prefix + _ NUM ) return null ; if ( i == size - _ NUM ) last Is Directory = _ BOOL ; int j ; for ( j = i - _ NUM ; j >= prefix ; j -- ) { if ( array [ j ] == separator ) {  System . arraycopy ( array , i + _ NUM , array , j + _ NUM , size - i ) ; size -= i - j ; i = j + _ NUM ; continue outer ; } }  System . arraycopy ( array , i + _ NUM , array , prefix , size - i ) ; size -= i + _ NUM - prefix ; i = prefix + _ NUM ; } } if ( size <= _ NUM ) { return _ STR ; } if ( size <= prefix ) { return new  String ( array , _ NUM , size ) ; } if ( last Is Directory && keep Separator ) return new  String ( array , _ NUM , size ) ; return new  String ( array , _ NUM , size - _ NUM ) ; }
public  String encode (  String p String ,  String charset ) throws  Unsupported Encoding Exception { if ( p String == null ) { return null ; } return new  String ( encode ( p String . get Bytes ( charset ) ) ,  String Encodings .  US_ ASCII ) ; }
public void slide ( ) { int position = _ NUM ; if ( items != null ) { position = items . size ( ) / _ NUM ; } slide ( position ) ; }
public boolean is Debugging Finer ( ) { return logger . is Loggable (  Level .  FINER ) ; }
private static void sort1 ( byte [ ] x , int off , int len ) { if ( len < _ NUM ) { for ( int i = off ; i < len + off ; i ++ ) for ( int j = i ; j > off && x [ j - _ NUM ] > x [ j ] ; j -- ) swap ( x , j , j - _ NUM ) ; return ; } int m = off + ( len > > _ NUM ) ; if ( len > _ NUM ) { int l = off ; int n = off + len - _ NUM ; if ( len > _ NUM ) { int s = len / _ NUM ; l = med3 ( x , l , l + s , l + _ NUM * s ) ; m = med3 ( x , m - s , m , m + s ) ; n = med3 ( x , n - _ NUM * s , n - s , n ) ; } m = med3 ( x , l , m , n ) ; } byte v = x [ m ] ; int a = off , b = a , c = off + len - _ NUM , d = c ; while ( _ BOOL ) { while ( b <= c && x [ b ] <= v ) { if ( x [ b ] == v ) swap ( x , a ++ , b ) ; b ++ ; } while ( c >= b && x [ c ] >= v ) { if ( x [ c ] == v ) swap ( x , c , d -- ) ; c -- ; } if ( b > c ) break ; swap ( x , b ++ , c -- ) ; } int s , n = off + len ; s =  Math . min ( a - off , b - a ) ; vecswap ( x , off , b - s , s ) ; s =  Math . min ( d - c , n - d - _ NUM ) ; vecswap ( x , b , n - s , s ) ; if ( ( s = b - a ) > _ NUM ) sort1 ( x , off , s ) ; if ( ( s = d - c ) > _ NUM ) sort1 ( x , n - s , s ) ; }
private boolean is Android Namespace (  String ns ) { if ( ns == null ) return _ BOOL ; ns = ns . trim ( ) ; if ( ns . starts With ( _ STR ) ) ns = ns . substring ( _ NUM ) ; if ( ! ns . equals ( _ STR ) ) return _ BOOL ; return _ BOOL ; }
@  Layoutlib Delegate static float cos ( float angle ) { return ( float )  Math . cos ( angle ) ; }
@  Override public  Object annotation Button ( final  Form Object form ) { final int subtype = form . get Parameter Constant (  Pdf Dictionary .  Subtype ) ; if ( subtype ==  Pdf Dictionary .  Popup ) { return create Annotation Popup ( form ) ; } if ( ! form . is Appearance Used ( ) ) { switch ( subtype ) { case  Pdf Dictionary .  Text : return create Annotation Text ( form ) ; case  Pdf Dictionary .  Free Text : return create Annotation Free Text ( form ) ; case  Pdf Dictionary .  Highlight : return create Anntoation Highlight ( form ) ; case  Pdf Dictionary .  Underline : return create Annotation Underline ( form ) ; case  Pdf Dictionary .  Ink : return create Annotation Ink ( form ) ; case  Pdf Dictionary .  Strick Out : return create Annotation Strike Out ( form ) ; } } return setup Annotation Button ( form ) ; }
private static byte [ ] create Blob ( byte [ ] target Information , byte [ ] client Nonce , long time ) { byte [ ] blob Signature = new byte [ ] { ( byte ) _ NUM , ( byte ) _ NUM , ( byte ) _ NUM , ( byte ) _ NUM } ; byte [ ] reserved = new byte [ ] { ( byte ) _ NUM , ( byte ) _ NUM , ( byte ) _ NUM , ( byte ) _ NUM } ; byte [ ] unknown1 = new byte [ ] { ( byte ) _ NUM , ( byte ) _ NUM , ( byte ) _ NUM , ( byte ) _ NUM } ; byte [ ] unknown2 = new byte [ ] { ( byte ) _ NUM , ( byte ) _ NUM , ( byte ) _ NUM , ( byte ) _ NUM } ; time += _ NUM ; time *= _ NUM ; byte [ ] timestamp = new byte [ _ NUM ] ; for ( int i = _ NUM ; i < _ NUM ; i ++ ) { timestamp [ i ] = ( byte ) time ; time >>>= _ NUM ; } byte [ ] blob = new byte [ blob Signature . length + reserved . length + timestamp . length + client Nonce . length + unknown1 . length + target Information . length + unknown2 . length ] ; int offset = _ NUM ;  System . arraycopy ( blob Signature , _ NUM , blob , offset , blob Signature . length ) ; offset += blob Signature . length ;  System . arraycopy ( reserved , _ NUM , blob , offset , reserved . length ) ; offset += reserved . length ;  System . arraycopy ( timestamp , _ NUM , blob , offset , timestamp . length ) ; offset += timestamp . length ;  System . arraycopy ( client Nonce , _ NUM , blob , offset , client Nonce . length ) ; offset += client Nonce . length ;  System . arraycopy ( unknown1 , _ NUM , blob , offset , unknown1 . length ) ; offset += unknown1 . length ;  System . arraycopy ( target Information , _ NUM , blob , offset , target Information . length ) ; offset += target Information . length ;  System . arraycopy ( unknown2 , _ NUM , blob , offset , unknown2 . length ) ; return blob ; }
public  Creation Tool (  Figure prototype ) { this ( prototype , null , null ) ; }
static  Automaton reverse (  Automaton a ,  Set <  Integer > initial States ) { if (  Operations . is Empty ( a ) ) { return new  Automaton ( ) ; } int num States = a . get Num States ( ) ;  Automaton .  Builder builder = new  Automaton .  Builder ( ) ; builder . create State ( ) ; for ( int s = _ NUM ; s < num States ; s ++ ) { builder . create State ( ) ; } builder . set Accept ( _ NUM , _ BOOL ) ;  Transition t = new  Transition ( ) ; for ( int s = _ NUM ; s < num States ; s ++ ) { int num Transitions = a . get Num Transitions ( s ) ; a . init Transition ( s , t ) ; for ( int i = _ NUM ; i < num Transitions ; i ++ ) { a . get Next Transition ( t ) ; builder . add Transition ( t . dest + _ NUM , s + _ NUM , t . min , t . max ) ; } }  Automaton result = builder . finish ( ) ; int s = _ NUM ;  Bit Set accept States = a . get Accept States ( ) ; while ( s < num States && ( s = accept States . next Set Bit ( s ) ) != - _ NUM ) { result . add Epsilon ( _ NUM , s + _ NUM ) ; if ( initial States != null ) { initial States . add ( s + _ NUM ) ; } s ++ ; } result . finish State ( ) ; return result ; }
public static double [ ]  Ga To LLa (  Geo [ ] ga , double [ ] lla ) { if ( lla == null ) { lla = new double [ _ NUM * ga . length ] ; } for ( int i = _ NUM ; i < ga . length ; i ++ ) {  Geo g = ga [ i ] ; lla [ i * _ NUM ] = g . get Latitude ( ) ; lla [ i * _ NUM + _ NUM ] = g . get Longitude ( ) ; } return lla ; }
private boolean equals Null (  String c1 ,  String c2 ) { if ( c1 == null ) c1 = _ STR ; if ( c2 == null ) c2 = _ STR ; return c1 . equals Ignore Case ( c2 ) ; }
public boolean check Root By Super User Apk ( ) {  File su Apk = new  File (  SU_ APK ) ; if ( su Apk . exists ( ) ) { if (  Constants .  DEBUG_ MODE_ ENABLED ) {  Log . d (  TAG , _ STR ) ; } return _ BOOL ; } return _ BOOL ; }
private boolean check If Expression Contains Column (  Expression expression ) { if ( expression instanceof  Column Expression ) { return _ BOOL ; } for (  Expression child : expression . get Children ( ) ) { if ( check If Expression Contains Column ( child ) ) { return _ BOOL ; } } return _ BOOL ; }
public synchronized  Iterator <  E > iterator ( ) {  Array List <  E > v = new  Array List <  E > ( this ) ; return v . iterator ( ) ; }
public void add Component (  Multiblock Component component ) { if ( get Component For Location ( component . get Relative Position ( ) ) != null ) throw new  Illegal Argument Exception ( _ STR ) ; components . add ( component ) ; change Axis For New Component ( component . get Relative Position ( ) ) ; calculate Cost For New Component ( component ) ; add Component To Location Cache ( component ) ; }
public  Template find Template (  String name ) { return find Template ( name , null ) ; }
public void write Field ( final  String name , final boolean value ) throws java . io .  IOException { write Field ( name ,  Boolean . to String ( value ) ) ; }
private void extract Row Key And Data (  String line ,  Default Category Dataset dataset ,  List column Keys ) {  Comparable row Key = null ; int field Index = _ NUM ; int start = _ NUM ; for ( int i = _ NUM ; i < line . length ( ) ; i ++ ) { if ( line . char At ( i ) == this . field Delimiter ) { if ( field Index == _ NUM ) {  String key = line . substring ( start , i ) ; row Key = remove String Delimiters ( key ) ; } else {  Double value =  Double . value Of ( remove String Delimiters ( line . substring ( start , i ) ) ) ; dataset . add Value ( value , row Key , (  Comparable ) column Keys . get ( field Index - _ NUM ) ) ; } start = i + _ NUM ; field Index ++ ; } }  Double value =  Double . value Of ( remove String Delimiters ( line . substring ( start , line . length ( ) ) ) ) ; dataset . add Value ( value , row Key , (  Comparable ) column Keys . get ( field Index - _ NUM ) ) ; }
protected void draw Actor ( int x , int y , int w , int h ,  Color fill Color ,  Paint fill Paint ,  Color pen Color , boolean shadow ) { float width = w * _ NUM / _ NUM ;  General Path path = new  General Path ( ) ; path . move To ( x , y + h ) ; path . curve To ( x , y + _ NUM * h / _ NUM , x , y + _ NUM * h / _ NUM , x + w / _ NUM , y + _ NUM * h / _ NUM ) ; path . curve To ( x + w / _ NUM - width , y + _ NUM * h / _ NUM , x + w / _ NUM - width , y , x + w / _ NUM , y ) ; path . curve To ( x + w / _ NUM + width , y , x + w / _ NUM + width , y + _ NUM * h / _ NUM , x + w / _ NUM , y + _ NUM * h / _ NUM ) ; path . curve To ( x + w , y + _ NUM * h / _ NUM , x + w , y + _ NUM * h / _ NUM , x + w , y + h ) ; path . close Path ( ) ; draw Path ( path , fill Color , fill Paint , pen Color , shadow ) ; }
Class < ? > load Class (  String class Name ,  Class Loader cl ) throws  Class Not Found Exception {  Class < ? > cls =  Class . for Name ( class Name , _ BOOL , cl ) ; return cls ; }
protected void rotate Orthogonal ( ) { for ( int i = _ NUM ; i < entries . size ( ) ; i ++ ) {  Named Icon icon = entries . get ( i ) . icon ; icon . set Rotation ( icon . get Rotation ( ) + _ NUM , this ) ; } inactive . set Rotation ( inactive . get Rotation ( ) + _ NUM , this ) ; unknown . set Rotation ( unknown . get Rotation ( ) + _ NUM , this ) ; inconsistent . set Rotation ( inconsistent . get Rotation ( ) + _ NUM , this ) ; display State ( ) ; repaint ( ) ; }
public static  String abbreviate Name (  String str ,  Font Metrics fm , int width ) { if ( fm . string Width ( str ) > width ) str = abbreviate Name ( str , _ BOOL ) ; if ( fm . string Width ( str ) > width ) str = abbreviate Name ( str , _ BOOL ) ; return str ; }
private void fill Text (  Input Node from ) throws  Exception {  Event Node event = reader . peek ( ) ; if ( event . is Text ( ) ) {  String data = event . get Value ( ) ; text . append ( data ) ; } }
public void clear Palette ( ) { current Palette List . remove All Elements ( ) ; }
public static  Local Date to Date (  String data ) { return  Local Date . parse ( data , formatter ( _ STR ) ) ; }
@  Suppress Warnings ( _ STR ) @  Json Creator public static  Client Detail Response V2 from Parts ( @  Json Property ( _ STR )  String name , @  Json Property ( _ STR )  String description , @  Json Property ( _ STR ) long created At Seconds , @  Json Property ( _ STR ) long updated At Seconds , @  Json Property ( _ STR )  String created By , @  Json Property ( _ STR )  String updated By , @  Json Property ( _ STR )  Optional <  Long > last Seen Seconds ) { return new  Auto Value_ Client Detail Response V2 ( name , description , created At Seconds , updated At Seconds , created By , updated By , last Seen Seconds ) ; }
public void remove Email (  Email Entity email ) { emails . remove ( email ) ; }
public void close Server ( ) throws  IOException { if ( ! server Is Open ( ) ) { return ; } server Socket . close ( ) ; server Socket = null ; server Input = null ; server Output = null ; }
private void add (  String world ,  Permission Holder holder ,  String permission ) { try { if ( world != null && ! world . equals ( _ STR ) ) { holder . set Permission ( permission , _ BOOL , server , world ) ; } else { holder . set Permission ( permission , _ BOOL , server ) ; } } catch (  Object Already Has Exception ignored ) { } save ( holder ) ; }
public void calculate Max ( double max ) { this . max =  Math . max ( this . max , max ) ; }
public boolean is Site (  String server Or Site Id ) { return  Webtop Naming . is Site ( server Or Site Id ) ; }
@  Override public void open Element (  String tag Name ) {  Element new Element = document . create Element ( tag Name ) ; current . append Child ( new Element ) ; current = new Element ; }
public  Format (  String p Format String ) {  String l Format Vars [ ] = p Format String . split ( _ STR ) ; m Id =  Integer . parse Int ( l Format Vars [ _ NUM ] ) ; }
protected void update (  IInterval interval ) { if ( intervals == null ) { intervals = new  Array List <  IInterval > ( ) ; } intervals . add ( interval ) ; }
public static  URL make URL (  String path ) { try { return new  URL ( path ) ; } catch (  Exception e ) { return null ; } }
public boolean add Main Task (  Tmm Thread Pool new Task ) { boolean result = _ BOOL ; new Task . add Listener ( this ) ; new Task . set State (  Task State .  QUEUED ) ; main Task Executor . execute ( new Task ) ; return result ; }
public  Commit Time Index ( final  IRaw Store store , final  Checkpoint checkpoint , final  Index Metadata metadata , boolean read Only ) { super ( store , checkpoint , metadata , read Only ) ; }
public static  Instruction save Replace Thread ID (  Instruction inst ,  String pattern ,  String replacement ) throws  DMLRuntime Exception { if ( inst instanceof  MRJob Instruction ) {  MRJob Instruction mrinst = (  MRJob Instruction ) inst ; mrinst . update Instruction Thread ID ( pattern , replacement ) ; } else if ( inst instanceof  Variable CPInstruction ) { inst . update Instruction Thread ID ( pattern , replacement ) ; } return inst ; }
public static synchronized void redirect Platform Loggers ( ) { if ( logging Enabled || !  Logging Support . is Available ( ) ) return ; logging Enabled = _ BOOL ; for (  Map .  Entry <  String ,  Weak Reference <  Platform Logger > > entry : loggers . entry Set ( ) ) {  Weak Reference <  Platform Logger > ref = entry . get Value ( ) ;  Platform Logger plog = ref . get ( ) ; if ( plog != null ) { plog . redirect To Java Logger Proxy ( ) ; } } }
private void parse Last Consonant ( ) { if ( ! valid Vi Syll ) return ; if ( i Cur Pos > str Syllable . length ( ) ) str Last Consonant =  ZERO ;  String str Con = str Syllable . substring ( i Cur Pos , str Syllable . length ( ) ) ; if ( str Con . length ( ) > _ NUM ) { valid Vi Syll = _ BOOL ; return ; }  Iterator iter = al Last Consonants . iterator ( ) ; while ( iter . has Next ( ) ) {  String temp Last Con = (  String ) iter . next ( ) ; if ( str Con . equals ( temp Last Con ) ) { str Last Consonant = temp Last Con ; i Cur Pos += str Last Consonant . length ( ) ; return ; } } str Last Consonant =  ZERO ; if ( i Cur Pos >= str Syllable . length ( ) ) valid Vi Syll = _ BOOL ; else valid Vi Syll = _ BOOL ; return ; }
private void init ( ) { main Panel = new  JPanel ( ) ; main Panel . set Layout ( new  Box Layout ( main Panel ,  Box Layout .  Y_ AXIS ) ) ; main Panel . add ( connection Panel ) ; properties Panel =  Connection Synapse Properties Panel . create Synapse Properties Panel ( this ) ; main Panel . add ( properties Panel ) ; eir Panel =  Synapse Polarity And Randomizer Panel . create Polarity Ratio Panel ( this ) ; main Panel . add ( eir Panel ) ; fill Frame ( ) ; }
private void remove Gaps ( int nodes Level [ ] ) { int temp = m_nodes . size ( ) ; int temp2 = graph Matrix [ _ NUM ] . length , temp Cnt = _ NUM ; for ( int n = _ NUM ; n < temp ; n ++ ) { for ( int i = _ NUM ; i < temp2 ; i ++ ) { int len = graph Matrix . length ; if ( graph Matrix [ n ] [ i ] > _ NUM ) { if ( nodes Level [ i ] > nodes Level [ n ] + _ NUM ) { int temp Matrix [ ] [ ] = new int [ graph Matrix . length + ( nodes Level [ i ] - nodes Level [ n ] - _ NUM ) ] [ graph Matrix . length + ( nodes Level [ i ] - nodes Level [ n ] - _ NUM ) ] ; int level = nodes Level [ n ] + _ NUM ; copy Matrix ( graph Matrix , temp Matrix ) ;  String s1 = new  String ( _ STR + temp Cnt ++ ) ; m_nodes . add ( new  Graph Node ( s1 , s1 ,  SINGULAR_ DUMMY ) ) ; int temp3 [ ] = new int [ node Levels [ level ] . length + _ NUM ] ;  System . arraycopy ( node Levels [ level ] , _ NUM , temp3 , _ NUM , node Levels [ level ] . length ) ; temp3 [ temp3 . length - _ NUM ] = m_nodes . size ( ) - _ NUM ; node Levels [ level ] = temp3 ; level ++ ; int k ; for ( k = len ; k < len + nodes Level [ i ] - nodes Level [ n ] - _ NUM - _ NUM ; k ++ ) {  String s2 = new  String ( _ STR + temp Cnt ) ; m_nodes . add ( new  Graph Node ( s2 , s2 ,  SINGULAR_ DUMMY ) ) ; temp3 = new int [ node Levels [ level ] . length + _ NUM ] ;  System . arraycopy ( node Levels [ level ] , _ NUM , temp3 , _ NUM , node Levels [ level ] . length ) ; temp3 [ temp3 . length - _ NUM ] = m_nodes . size ( ) - _ NUM ; node Levels [ level ++ ] = temp3 ; temp Matrix [ k ] [ k + _ NUM ] = temp Matrix [ n ] [ i ] ; temp Cnt ++ ; if ( k > len ) { temp Matrix [ k ] [ k - _ NUM ] = - _ NUM * temp Matrix [ n ] [ i ] ; } } temp Matrix [ k ] [ i ] = temp Matrix [ n ] [ i ] ; temp Matrix [ n ] [ len ] = temp Matrix [ n ] [ i ] ; temp Matrix [ len ] [ n ] = - _ NUM * temp Matrix [ n ] [ i ] ; temp Matrix [ i ] [ k ] = - _ NUM * temp Matrix [ n ] [ i ] ; if ( k > len ) { temp Matrix [ k ] [ k - _ NUM ] = - _ NUM * temp Matrix [ n ] [ i ] ; } temp Matrix [ n ] [ i ] = _ NUM ; temp Matrix [ i ] [ n ] = _ NUM ; graph Matrix = temp Matrix ; } else { graph Matrix [ i ] [ n ] = - _ NUM * graph Matrix [ n ] [ i ] ; } } } } }
byte [ ] javac Compile (  String package Name ,  String class Name ,  String source ) {  File dir = new  File (  COMPILE_ DIR ) ; if ( package Name != null ) { dir = new  File ( dir , package Name . replace ( _ STR , _ STR ) ) ;  File Utils . create Directories ( dir . get Absolute Path ( ) ) ; }  File java File = new  File ( dir , class Name + _ STR ) ;  File class File = new  File ( dir , class Name + _ STR ) ; try {  Output Stream f =  File Utils . new Output Stream ( java File . get Absolute Path ( ) , _ BOOL ) ;  Writer out =  IOUtils . get Buffered Writer ( f ) ; class File . delete ( ) ; out . write ( source ) ; out . close ( ) ; if (  JAVAC_ SUN != null ) { javac Sun ( java File ) ; } else { javac Process ( java File ) ; } byte [ ] data = new byte [ ( int ) class File . length ( ) ] ;  Data Input Stream in = new  Data Input Stream ( new  File Input Stream ( class File ) ) ; in . read Fully ( data ) ; in . close ( ) ; return data ; } catch (  Exception e ) { throw  Db Exception . convert ( e ) ; } finally { java File . delete ( ) ; class File . delete ( ) ; } }
public synchronized void register (  Platform platform ) { check Not Null ( platform ) ; logger . log (  Level .  FINE , _ STR + platform . get Class ( ) + _ STR + super . to String ( ) + _ STR ) ; platforms . add ( platform ) ; if ( first Seen Version != null ) { if ( ! first Seen Version . equals ( platform . get Version ( ) ) ) { logger . log (  Level .  WARNING , _ STR + _ STR , new  Object [ ] { first Seen Version , platform . get Version ( ) } ) ; } } else { first Seen Version = platform . get Version ( ) ; } }
public  Action Request Helper depends On (  Action Request Helper dependency , boolean terminate On Failure ) { dependency . terminate On Failure ( terminate On Failure ) ; m Dependencies . add ( dependency ) ; return this ; }
public boolean equals ( java . lang .  Object obj ) { return obj != null && obj . get Class ( ) == get Class ( ) && ( (  Integer ) obj ) . value == value ; }
public static void to Xml ( final  Config to Convert , final  Output Stream stream ,  Boolean pretty Xml ) throws  JAXBException {  Marshaller var Marshaller = get Marshaller ( pretty Xml ) ; var Marshaller . marshal ( to Convert , stream ) ; }
public static final  List <  Vector2 > cleanse (  List <  Vector2 > points ) { if ( points == null ) throw new  Null Pointer Exception (  Messages . get String ( _ STR ) ) ; int size = points . size ( ) ; if ( size == _ NUM ) return points ;  List <  Vector2 > result = new  Array List <  Vector2 > ( size ) ; double winding = _ NUM ; for ( int i = _ NUM ; i < size ; i ++ ) {  Vector2 point = points . get ( i ) ;  Vector2 prev = points . get ( i - _ NUM < _ NUM ? size - _ NUM : i - _ NUM ) ;  Vector2 next = points . get ( i + _ NUM == size ? _ NUM : i + _ NUM ) ; if ( point == null || prev == null || next == null ) throw new  Null Pointer Exception (  Messages . get String ( _ STR ) ) ;  Vector2 diff = point . difference ( next ) ; if ( diff . is Zero ( ) ) { continue ; }  Vector2 prev To Point = prev . to ( point ) ;  Vector2 point To Next = point . to ( next ) ; if ( ! prev To Point . is Zero ( ) ) { double cross = prev To Point . cross ( point To Next ) ; if (  Math . abs ( cross ) <=  Epsilon .  E ) { continue ; } } winding += point . cross ( next ) ; result . add ( point ) ; } if ( winding < _ NUM ) {  Geometry . reverse Winding ( result ) ; } return result ; }
private void heapify Up ( int twopos ,  Comparable <  Object > cur ) { while ( twopos > _ NUM ) { final int parent = ( twopos - _ NUM ) > > > _ NUM ;  Comparable <  Object > par = twoheap [ parent ] ; if ( cur . compare To ( par ) >= _ NUM ) { break ; } twoheap [ twopos ] = par ; twopos = parent ; } twoheap [ twopos ] = cur ; }
public void insert (  String key , char val ) { int len = key . length ( ) + _ NUM ; if ( freenode + len > eq . length ) { redim Node Arrays ( eq . length +  BLOCK_ SIZE ) ; } char [ ] strkey = new char [ len -- ] ; key . get Chars ( _ NUM , len , strkey , _ NUM ) ; strkey [ len ] = _ NUM ; root = insert ( root , strkey , _ NUM , val ) ; }
void write (  Environment env ,  Data Output Stream out ,  Constant Pool tab ) throws  IOException { out . write Byte (  CONSTANT_ CLASS ) ; out . write Short ( tab . index ( name ) ) ; }
public void initialize Properties (  Properties properties ) {  Properties new Props = new  Properties ( ) ; new Props . put All ( system Config Props ) ; new Props . put All ( properties ) ; system Config Props = new Props ; }
public void add Listener (  Key Combo Listener listener ) { m Listeners . add ( listener ) ; }
public static void append Content Prefix (  Http Servlet Request request ,  String Builder url Buffer ) { try { append Content Prefix ( request , (  Appendable ) url Buffer ) ; } catch (  IOException e ) { throw  Util Misc . init Cause ( new  Internal Error ( e . get Message ( ) ) , e ) ; } }
public void remove Error Listener ( final  Error Listener error Listener ) { if ( error Listeners != null ) { error Listeners . remove ( error Listener ) ; } }
protected  Logger (  String class Name ) { this . class Name = class Name ; int index = class Name . last Index Of ( _ STR ) ; if ( index != - _ NUM ) { this . simple Class Name = class Name . substring ( index + _ NUM ) ; } }
public static void import Expression Types ( final  CConnection connection , final int raw Module Id , final int module Id ) throws  SQLException { final  String query = _ STR +  CTable Names .  EXPRESSION_ TYPES_ TABLE + _ STR + module Id + _ STR + _ STR +  String . format (  CTable Names .  RAW_ EXPRESSION_ TYPES_ TABLE , raw Module Id ) ; connection . execute Update ( query , _ BOOL ) ; }
public  Object read Cost Matrix Old (  Element node ) throws  Exception { weka . classifiers .  Cost Matrix matrix ; weka . core . matrix .  Matrix matrix New ;  String Writer writer ; if (  DEBUG ) { trace ( new  Throwable ( ) , node . get Attribute (  ATT_ NAME ) ) ; } m_ Current Node = node ; matrix New = ( weka . core . matrix .  Matrix ) read Matrix ( node ) ; writer = new  String Writer ( ) ; matrix New . write ( writer ) ; matrix = new weka . classifiers .  Cost Matrix ( new  String Reader ( writer . to String ( ) ) ) ; return matrix ; }
public void record Volume Operation (  Db Client db Client ,  Operation Type Enum op Type ,  Operation .  Status status ,  Object ... ext Param ) { try { boolean op Status = (  Operation .  Status . ready == status ) ? _ BOOL : _ BOOL ;  String ev Type ; ev Type = op Type . get Ev Type ( op Status ) ;  String ev Desc = op Type . get Description ( ) ;  String op Stage =  Audit Log Manager .  AUDITOP_ END ; _logger . info ( _ STR , op Type . to String ( ) , ev Type . to String ( ) + _ STR + ev Desc ) ;  URI uri = (  URI ) ext Param [ _ NUM ] ; record Bourne Volume Event ( db Client , ev Type , status , ev Desc , uri ) ;  String id = uri . to String ( ) ;  Audit Block Util . audit Block ( db Client , op Type , op Status , op Stage , id ) ; } catch (  Exception e ) { _logger . error ( _ STR , op Type . to String ( ) , e ) ; } }
public  Rest Exception ( int error Code ) { this . error Code = error Code ; this . message = get Localized Message (  Locale . get Default ( ) ) ; }
public  DView Certificate (  Window parent ,  String title ,  X509 Certificate [ ] certs ,  Kse Frame kse Frame , int import Export ) throws  Crypto Exception { super ( parent , title ,  Dialog .  Modality Type .  DOCUMENT_ MODAL ) ; this . kse Frame = kse Frame ; this . import Export = import Export ; init Components ( certs ) ; }
public void test Compute Classpath For Library ( ) throws  Core Exception ,  Unsupported Encoding Exception { final  IPath project Relative Jar Path = new  Path ( _ STR ) ; final  String folder Name = _ STR ; add And Create Jar Library Entry ( java Project A , project Relative Jar Path ) ; add And Create Folder Library Entry ( java Project A , folder Name ) ;  List <  File > actual Cp = get List Of Files (  GWTCompile Runner . compute Classpath ( java Project A ) ) ;  List <  File > expected Cp = new  Array List <  File > ( ) ; expected Cp . add ( get File ( java Project A . get Project ( ) , project Relative Jar Path . to OSString ( ) ) ) ; expected Cp . add ( get File ( java Project A . get Project ( ) , folder Name ) ) ; assert Equals ( expected Cp , actual Cp ) ; }
public static  String add To Number String (  String number String , long add Amount ) { if ( number String == null ) return null ; int orig Length = number String . length ( ) ; long number =  Long . parse Long ( number String ) ; return pad Number String (  Long . to String ( number + add Amount ) , orig Length ) ; }
private void tred2 ( ) { for ( int j = _ NUM ; j < n ; j ++ ) d [ j ] =  V . get ( n - _ NUM , j ) ; for ( int i = n - _ NUM ; i > _ NUM ; i -- ) { double scale = _ NUM ; double h = _ NUM ; for ( int k = _ NUM ; k < i ; k ++ ) { scale = scale + abs ( d [ k ] ) ; } if ( scale == _ NUM ) { e [ i ] = d [ i - _ NUM ] ; for ( int j = _ NUM ; j < i ; j ++ ) { d [ j ] =  V . get ( i - _ NUM , j ) ;  V . set ( i , j , _ NUM ) ;  V . set ( j , i , _ NUM ) ; } } else { for ( int k = _ NUM ; k < i ; k ++ ) { d [ k ] /= scale ; h += d [ k ] * d [ k ] ; } double f = d [ i - _ NUM ] ; double g = sqrt ( h ) ; if ( f > _ NUM ) g = - g ; e [ i ] = scale * g ; h -= f * g ; d [ i - _ NUM ] = f - g ;  Arrays . fill ( e , _ NUM , i , _ NUM ) ; for ( int j = _ NUM ; j < i ; j ++ ) { f = d [ j ] ;  V . set ( j , i , f ) ; g = e [ j ] +  V . get ( j , j ) * f ; for ( int k = j + _ NUM ; k <= i - _ NUM ; k ++ ) { g +=  V . get ( k , j ) * d [ k ] ; e [ k ] +=  V . get ( k , j ) * f ; } e [ j ] = g ; } f = _ NUM ; for ( int j = _ NUM ; j < i ; j ++ ) { e [ j ] /= h ; f += e [ j ] * d [ j ] ; } double hh = f / ( h + h ) ; for ( int j = _ NUM ; j < i ; j ++ ) { e [ j ] -= hh * d [ j ] ; } for ( int j = _ NUM ; j < i ; j ++ ) { f = d [ j ] ; g = e [ j ] ; for ( int k = j ; k <= i - _ NUM ; k ++ ) {  V . increment ( k , j , - ( f * e [ k ] + g * d [ k ] ) ) ; } d [ j ] =  V . get ( i - _ NUM , j ) ;  V . set ( i , j , _ NUM ) ; } } d [ i ] = h ; } for ( int i = _ NUM ; i < n - _ NUM ; i ++ ) {  V . set ( n - _ NUM , i ,  V . get ( i , i ) ) ;  V . set ( i , i , _ NUM ) ; double h = d [ i + _ NUM ] ; if ( h != _ NUM ) { for ( int k = _ NUM ; k <= i ; k ++ ) { d [ k ] =  V . get ( k , i + _ NUM ) / h ; } for ( int j = _ NUM ; j <= i ; j ++ ) { double g = _ NUM ; for ( int k = _ NUM ; k <= i ; k ++ ) { g +=  V . get ( k , i + _ NUM ) *  V . get ( k , j ) ; }  Row Column Ops . add Mult Col (  V , j , _ NUM , i + _ NUM , - g , d ) ; } }  Row Column Ops . fill Col (  V , i + _ NUM , _ NUM , i + _ NUM , _ NUM ) ; } for ( int j = _ NUM ; j < n ; j ++ ) { d [ j ] =  V . get ( n - _ NUM , j ) ;  V . set ( n - _ NUM , j , _ NUM ) ; }  V . set ( n - _ NUM , n - _ NUM , _ NUM ) ; e [ _ NUM ] = _ NUM ; }
public  Channel Change Listener (  String group Name ,  Sound Group group ) { this . group = group ; this . group Name = group Name ; }
public void add Group Listener ( final  Group Listener listener ) { group Listeners . add ( listener ) ; }
public void add Task (  Future task ) { task Set . add ( task ) ; }
private  String real Key (  String key ) { return key . contains ( _ STR ) ? key . substring ( key . last Index Of ( _ STR ) + _ NUM , key . length ( ) ) : key ; }
@  Suppress Warnings ( _ STR ) public static <  E > void transform String Collection (  Collection <  String > original ,  Collection <  E > collection ,  Class <  E > element Class ) throws  Preference Exception {  Method parse Method = find Parse Method ( element Class ) ; if ( null != parse Method ) { for (  String to Transform : original ) { try {  Object transformed = parse Method . invoke ( null , to Transform ) ; if ( element Class . is Assignable From ( transformed . get Class ( ) ) ) { collection . add ( (  E ) transformed ) ; } } catch (  Exception e ) { throw new  Preference Exception ( _ STR + element Class . get Name ( ) + _ STR , e ) ; } } } else { throw new  Preference Exception ( _ STR + element Class . get Name ( ) + _ STR + element Class . get Name ( ) + _ STR ) ; } }
protected boolean sync Enclosed ( ) { try {  Offset Grab Point gb0 = (  Offset Grab Point ) poly Grab Points . get ( _ NUM ) ;  Offset Grab Point ogb = (  Offset Grab Point ) poly Grab Points . get ( poly Grab Points . size ( ) - _ NUM ) ; if ( gb0 . get X ( ) == ogb . get X ( ) && gb0 . get Y ( ) == ogb . get Y ( ) ) { gb0 . add Grab Point ( ogb ) ; ogb . add Grab Point ( gb0 ) ; return _ BOOL ; } } catch (  Class Cast Exception cce ) { } catch (  Index Out Of Bounds Exception ioobe ) { } return _ BOOL ; }
public  Component Manager ( ) { gral Components = new  Sequence Collection ( ) ; gral Seeds =  Collections . unmodifiable Set (  Collections . <  Sequence > empty Set ( ) ) ; }
public static byte [ ] to Byte Array (  Input Stream input ) throws  IOException {  Byte Array Output Stream output = new  Byte Array Output Stream ( ) ; stream ( input , output ) ; return output . to Byte Array ( ) ; }
private byte [ ] check Owner Password ( byte [ ] owner Password , byte [ ] first Doc Id Value , int key Bit Length , int revision , byte [ ] o Value , byte [ ] u Value , int p Value , boolean encrypt Metadata ) throws  General Security Exception ,  Encryption Unsupported By Product Exception ,  PDFParse Exception { final byte [ ] rc4 Key Bytes = get Initial Owner Password Key Bytes ( owner Password , key Bit Length , revision ) ; final  Cipher rc4 = create RC4 Cipher ( ) ; init Decryption ( rc4 , create RC4 Key ( rc4 Key Bytes ) ) ; final byte [ ] possible User Password ; if ( revision == _ NUM ) { possible User Password = crypt ( rc4 , o Value ) ; } else if ( revision >= _ NUM ) { possible User Password = new byte [ _ NUM ] ;  System . arraycopy ( o Value , _ NUM , possible User Password , _ NUM , possible User Password . length ) ; rc4unshuffle ( rc4 , possible User Password , rc4 Key Bytes ) ; } else { throw new  Encryption Unsupported By Product Exception ( _ STR + revision ) ; } return check User Password ( possible User Password , first Doc Id Value , key Bit Length , revision , o Value , u Value , p Value , encrypt Metadata ) ; }
public  Logger logger ( ) { return logger ; }
public static final byte [ ] inflate ( byte [ ] in ) throws  IOException {  Byte Array Output Stream out Stream = new  Byte Array Output Stream (  EXPECTED_ COMPRESSION_ RATIO * in . length ) ;  Inflater Input Stream in Stream = new  Inflater Input Stream ( new  Byte Array Input Stream ( in ) ) ; byte [ ] buf = new byte [  BUF_ SIZE ] ; while ( _ BOOL ) { int size = in Stream . read ( buf ) ; if ( size <= _ NUM ) break ; out Stream . write ( buf , _ NUM , size ) ; } out Stream . close ( ) ; return out Stream . to Byte Array ( ) ; }
private void populate Function Combo Box ( ) { if ( env Var Combo Box != null ) {  Default Combo Box Model <  String > model = new  Default Combo Box Model <  String > ( ) ; model . add Element ( _ STR ) ; for (  String name : env Var Map . key Set ( ) ) { model . add Element ( name ) ; } env Var Combo Box . set Model ( model ) ; } }
public static void output (  String output String ) { try { if ( output Log != null ) { output Log . write Bytes ( output String ) ; output Log . write Bytes ( _ STR ) ; } } catch (  IOException ioe ) { notify Out = _ BOOL ; out =  System . out ; error ( _ STR + output String + _ STR + ioe ) ; return ; } if ( notify Out ) { out . println ( output String ) ; } }
public void test_huffman Codec Stress ( ) { final int ntrials = _ NUM ; final  Random r = new  Random ( ) ; for ( int trial = _ NUM ; trial < ntrials ; trial ++ ) { final int [ ] frequency = new int [ r . next Int ( _ NUM ) + _ NUM ] ; for ( int i = _ NUM ; i < frequency . length ; i ++ ) { if ( r . next Float ( ) < _ NUM ) { frequency [ i ] = _ NUM ; } else { frequency [ i ] = r . next Int ( _ NUM ) ; } } do Round Trip Test ( frequency ) ; } }
public  Set key Set ( ) { return map . key Set ( ) ; }
private  Camel Streamer <  Integer ,  String > create Camel Streamer (  Ignite Data Streamer <  Integer ,  String > data Streamer ) {  Camel Streamer <  Integer ,  String > streamer = new  Camel Streamer < > ( ) ; streamer . set Ignite ( grid ( ) ) ; streamer . set Streamer ( data Streamer ) ; streamer . set Endpoint Uri ( _ STR + url ) ; data Streamer . allow Overwrite ( _ BOOL ) ; data Streamer . auto Flush Frequency ( _ NUM ) ; return streamer ; }
@  Suppress Warnings ( _ STR ) public  Composite Transaction Adaptor (  Stack <  Composite Transaction > lineage ,  String tid , boolean serial ,  Recovery Coordinator adaptor ) { super ( tid , (  Stack <  Composite Transaction > ) lineage . clone ( ) , serial ) ; adaptor For Replay Requests_ = adaptor ;  Stack <  Composite Transaction > tmp = (  Stack <  Composite Transaction > ) lineage . clone ( ) ;  Composite Transaction parent = null ; while ( ! tmp . empty ( ) ) { parent = tmp . pop ( ) ; } root_ = parent . get Tid ( ) ; }
public  Request cookie (  String key ,  String value ) {  Objects . require Non Null ( key ) ;  Objects . require Non Null ( value ) ; _cookies . put ( key , value ) ; return this ; }
public void indent ( ) { indent . append ( _ STR ) ; }
private  Calendar trim To Midnight (  Calendar calendar ) { calendar . set (  Calendar .  HOUR_ OF_ DAY , _ NUM ) ; calendar . set (  Calendar .  MINUTE , _ NUM ) ; calendar . set (  Calendar .  SECOND , _ NUM ) ; calendar . set (  Calendar .  MILLISECOND , _ NUM ) ; return calendar ; }
public static  String cut Suffix (  String string ,  String suffix ) { if ( string . ends With ( suffix ) ) { string = string . substring ( _ NUM , string . length ( ) - suffix . length ( ) ) ; } return string ; }
private  Coordinate [ ] reduce (  Coordinate [ ] input Pts ) {  Coordinate [ ] poly Pts = compute Oct Ring ( input Pts ) ; if ( poly Pts == null ) return input Pts ;  Tree Set reduced Set = new  Tree Set ( ) ; for ( int i = _ NUM ; i < poly Pts . length ; i ++ ) { reduced Set . add ( poly Pts [ i ] ) ; } for ( int i = _ NUM ; i < input Pts . length ; i ++ ) { if ( !  CGAlgorithms . is Point In Ring ( input Pts [ i ] , poly Pts ) ) { reduced Set . add ( input Pts [ i ] ) ; } }  Coordinate [ ] reduced Pts =  Coordinate Arrays . to Coordinate Array ( reduced Set ) ; if ( reduced Pts . length < _ NUM ) return pad Array3 ( reduced Pts ) ; return reduced Pts ; }
public static  String to String ( int [ ] values ) {  String result = _ STR ; for ( int value : values ) { result += value + _ STR ; } if (  String Utils . is Not Blank ( result ) ) { result = result . substring ( _ NUM , result . length ( ) - _ NUM ) ; } return result ; }
void add Non Expiring Session (  Internal Session session ) { if ( session . will Expire ( ) ) { throw new  Illegal State Exception ( _ STR ) ; } session . set Max Session Time (  NON_ EXPIRING_ SESSION_ LENGTH_ MINUTES ) ; session . set Max Idle Time ( refresh Period In Minutes * _ NUM ) ; update Session ( session ) ; non Expiring Sessions . add ( session . get ID ( ) ) ; }
public  Cipher Parameters encrypt ( byte [ ] out , int key Len ) { return encrypt ( out , _ NUM , key Len ) ; }
public  String build Os ( ) { return properties . get Property ( _ STR ) ; }
public  String encrypt (  String input ) { if ( input == null || input . length ( ) == _ NUM ) { return input ; } byte [ ] input Bytes = input . get Bytes (  UTF_8 ) ; byte [ ] output Bytes = encrypt ( input Bytes ) ; return new  String ( output Bytes ,  UTF_8 ) ; }
public static  String generate Native Guid (  Compute System device ) { return  String . format ( _ STR , _device Type Map . get ( device . get System Type ( ) ) , device . get Ip Address ( ) , device . get Port Number ( ) ) ; }
public void test Get Servlet Names For Jsp File With Single Servlet ( ) throws  Exception {  String xml =  WEBAPP_ TEST_ HEADER + _ STR + _ STR + _ STR + _ STR + _ STR ;  Web Xml web Xml =  Web Xml Io . parse Web Xml ( new  Byte Array Input Stream ( xml . get Bytes ( _ STR ) ) , get Entity Resolver ( ) ) ;  List <  String > servlet Names =  Web Xml Utils . get Servlet Names For Jsp File ( web Xml , _ STR ) ; assert Equals ( _ NUM , servlet Names . size ( ) ) ; assert Equals ( _ STR , servlet Names . get ( _ NUM ) ) ; }
@  Override public final boolean equals (  Object other ) { return ( equals Msg ( other ) == null ) ; }
@  Deprecated public static void debug (  Object msg ) {  X . error ( debug Prefix ( ) + msg ) ; }
public void remove Event Listener (  SIPDialog Event Listener old Listener ) { event Listeners . remove ( old Listener ) ; }
private void load Environment ( ) {  Map <  String ,  String > env =  System . getenv ( ) ; for (  String env Name : env . key Set ( ) ) { set Parameter ( env Name , env . get ( env Name ) ) ; } }
public  String type ( ) { return type ; }
@  Action ( value = _ STR ) public  String report ( ) { final  Report Request report Input = new  Report Request (  CASH_ COLLECTION_ TEMPLATE , crit Params ,  Report Data Source Type .  SQL ) ; final  Report Output report Output = report Service . create Report ( report Input ) ; report Id = report Viewer Util . add Report To Temp Cache ( report Output ) ; return  REPORT ; }
public static boolean starts With ( char s [ ] , int len ,  String prefix ) { final int prefix Len = prefix . length ( ) ; if ( prefix Len > len ) return _ BOOL ; for ( int i = _ NUM ; i < prefix Len ; i ++ ) if ( s [ i ] != prefix . char At ( i ) ) return _ BOOL ; return _ BOOL ; }
void check Type ( int type ) { if ( ! type Set . contains ( type ) ) { trace ( _ STR + type ) ; } }
public boolean fire Map Mouse Entered (  Mouse Event evt ) { if (  DEBUG ) { logger . fine ( _ STR ) ; } boolean consumed = _ BOOL ; if ( proxy == null || evt . is Shift Down ( ) || ( proxy Distribution Mask &  PROXY_ DISTRIB_ MOUSE_ ENTERED ) > _ NUM ) { evt = new  Map Mouse Event ( get Parent Mode ( ) , evt ) ; for (  Map Mouse Listener listener : this ) { listener . mouse Entered ( evt ) ; consumed = _ BOOL ; } } if ( proxy != null && ! evt . is Shift Down ( ) ) { proxy . mouse Entered ( evt ) ; consumed = _ BOOL ; } return consumed ; }
public void delete Value Subkeyed (  Connection connection ,  Object keys [ ] ) {  String Builder builder = new  String Builder ( ) ; builder . append ( _ STR ) ; builder . append ( table Name ) ; builder . append ( _ STR ) ;  String delimiter = _ STR ; for ( int i = _ NUM ; i < keys . length ; i ++ ) { builder . append ( delimiter ) ; builder . append ( key Field Names [ i ] ) ; builder . append ( _ STR ) ; delimiter = _ STR ; }  String query = builder . to String ( ) ;  Prepared Statement statement = null ; try { if ( (  Execution Path Debug Log . is Debug Enabled ) && ( log . is Debug Enabled ( ) ) ) { log . debug ( _ STR + query + _ STR + print ( keys ) + _ STR ) ; } statement = connection . prepare Statement ( query ) ; for ( int i = _ NUM ; i < keys . length ; i ++ ) { statement . set Object ( i + _ NUM , keys [ i ] ) ; } int rows = statement . execute Update ( ) ; if ( (  Execution Path Debug Log . is Debug Enabled ) && ( log . is Debug Enabled ( ) ) ) { log . debug ( _ STR + rows + _ STR ) ; } } catch (  SQLException ex ) {  String message = _ STR + query + _ STR + ex . get Message ( ) ; log . error ( message , ex ) ; store Exception Handler . handle ( message , ex ) ; throw new  Store Exception DBRel ( message , ex ) ; } finally { try { if ( statement != null ) statement . close ( ) ; } catch (  SQLException e ) { } } }
@  Override void to XML (  String Builder xml , int level ) { indent ( xml , level ) ; xml . append ( _ STR ) ; for ( int i = _ NUM ; i < bytes . length ; i ++ ) { byte b = bytes [ i ] ; if ( b < _ NUM ) xml . append ( _ STR ) ; xml . append (  Integer . to Hex String ( b ) ) ; } xml . append ( _ STR ) ; }
protected void paint Content Border Right Edge (  Graphics g , int x , int y , int w , int h , boolean draw Broken ,  Rectangle sel Rect , boolean is Content Border Painted ) { if ( is Content Border Painted ) { g . set Color ( dark Shadow ) ; g . fill Rect ( x + w - _ NUM , y , _ NUM , h ) ; } }
private void write Final Results (  String output Dir , double total TT , double [ ] total Route TTs , double [ ] avg Route TTs , int [ ] route Users , int number Of Stucked Agents ) {  Print Stream stream ;  String filename = output Dir + _ STR ; try { stream = new  Print Stream ( new  File ( filename ) ) ; } catch (  File Not Found Exception e ) { e . print Stack Trace ( ) ; return ; } log . info ( _ STR + total TT ) ;  String header = _ STR ;  String Buffer result Line = new  String Buffer ( ) ; result Line . append ( total TT ) ;  String latex Format = _ STR + ( int ) total TT ; log . info ( _ STR ) ; for ( int route Nr = _ NUM ; route Nr < number Of Routes ; route Nr ++ ) { log . info ( _ STR + route Nr + _ STR + route Users [ route Nr ] ) ; header += _ STR + route Nr ; result Line . append ( _ STR + route Users [ route Nr ] ) ; latex Format += _ STR + route Users [ route Nr ] ; } log . info ( _ STR ) ; for ( int route Nr = _ NUM ; route Nr < number Of Routes ; route Nr ++ ) { log . info ( _ STR + route Nr + _ STR + avg Route TTs [ route Nr ] ) ; header += _ STR + route Nr ; result Line . append ( _ STR + avg Route TTs [ route Nr ] ) ; latex Format += _ STR + (  Double . is Na N ( avg Route TTs [ route Nr ] ) ? _ STR : ( int ) avg Route TTs [ route Nr ] ) ; } log . info ( _ STR + number Of Stucked Agents ) ; header += _ STR ; result Line . append ( _ STR + number Of Stucked Agents ) ; latex Format += _ STR ; log . info ( _ STR + latex Format ) ; stream . println ( header ) ; stream . println ( result Line . to String ( ) ) ; stream . close ( ) ; log . info ( _ STR + filename ) ; }
public static int execute Update (  String sql ) { return execute Update ( sql , null , _ BOOL , null ) ; }
@  Layoutlib Delegate static long current Thread Time Micro ( ) { return  System . current Time Millis ( ) * _ NUM ; }
public static  List <  Entry > make Entries (  List <  String > ldif Lines ) { return make Entries ( ldif Lines . to Array ( new  String [ ldif Lines . size ( ) ] ) ) ; }
public int format ( long val , byte [ ] buf , int off , int len ) { if ( val ==  Long .  MIN_ VALUE ) { if ( len >  MAX_ LONG_ LENGTH ) { return format ( _ STR , buf , off , len ) ; } else { truncation Filler ( buf , off , len ) ; return off + len ; } } long pos =  Math . abs ( val ) ; int ndig = _ NUM ; long dmax =  Byte Formatter .  NUMBER_ BASE ; while ( ndig <  MAX_ LONG_ LENGTH && pos >= dmax ) { ndig ++ ; dmax *=  Byte Formatter .  NUMBER_ BASE ; } if ( val < _ NUM ) { ndig ++ ; } if ( ndig > len || ndig > buf . length - off ) { truncation Filler ( buf , off , len ) ; return off + len ; } off += ndig ; int xoff = off - _ NUM ; buf [ xoff ] = ( byte ) _ STR ; boolean last = pos == _ NUM ; while ( ! last ) { int giga = ( int ) ( pos %  LONG_ TO_ INT_ MODULO ) ; pos /=  LONG_ TO_ INT_ MODULO ; last = pos == _ NUM ; for ( int i = _ NUM ; i <  MAXIMUM_ SINGLE_ DIGIT_ INTEGER ; i ++ ) { buf [ xoff ] =  Byte Formatter .  DIGITS [ giga %  Byte Formatter .  NUMBER_ BASE ] ; xoff -- ; giga /=  Byte Formatter .  NUMBER_ BASE ; if ( last && giga == _ NUM ) { break ; } } } if ( val < _ NUM ) { buf [ xoff ] = ( byte ) _ STR ; } return off ; }
public void write ( int c ) { buffer . append ( ( char ) c ) ; }
private static void collect All Interfaces ( final  Class Node node , final  Set <  Class Node > out ) { if ( node == null ) return ;  Set <  Class Node > all Interfaces = node . get All Interfaces ( ) ; out . add All ( all Interfaces ) ; collect All Interfaces ( node . get Super Class ( ) , out ) ; }
private void compute Handler Live Set ( ) { if ( ir . get Handler Liveness Computed ( ) && current Block . has Exception Handlers ( ) ) {  Enumeration <  Basic Block > e = current Block . get Exceptional Out ( ) ; while ( e . has More Elements ( ) ) {  Exception Handler Basic Block handler Block = (  Exception Handler Basic Block ) e . next Element ( ) ; handler Live Set . add ( handler Block . get Live Set ( ) ) ; } } }
public int checksum_ts ( ) { return calculate Checksum ( compile_checksum . to String ( ) + compile_checksum_ts . to String ( ) ) ; }
public boolean check Label ( final  String a Label ) { if ( a Label == null || a Label . equals ( _ STR ) ) { logger . debug ( _ STR ) ; return _ BOOL ; } return a Label . equals ( this . label ) ; }
public boolean on Machine Activated (  World world , int x , int y , int z ,  Entity Player entity Player , int side , float hit X , float hit Y , float hit Z ) { return _ BOOL ; }
public sun . net . ftp .  Ftp Client login (  String user , char [ ] password ,  String account ) throws sun . net . ftp .  Ftp Protocol Exception ,  IOException { if ( ! is Connected ( ) ) { throw new sun . net . ftp .  Ftp Protocol Exception ( _ STR ,  Ftp Reply Code .  BAD_ SEQUENCE ) ; } if ( user == null || user . length ( ) == _ NUM ) { throw new  Illegal Argument Exception ( _ STR ) ; } try Login ( user , password ) ; if ( last Reply Code ==  Ftp Reply Code .  NEED_ ACCOUNT ) { issue Command Check ( _ STR + account ) ; }  String Buffer sb = new  String Buffer ( ) ; if ( server Response != null ) { for (  String l : server Response ) { if ( l != null ) { if ( l . length ( ) >= _ NUM && l . starts With ( _ STR ) ) { l = l . substring ( _ NUM ) ; } sb . append ( l ) ; } } } welcome Msg = sb . to String ( ) ; logged In = _ BOOL ; return this ; }
public static boolean install Normal (  Context context ,  String file Path ) {  Intent i = new  Intent (  Intent .  ACTION_ VIEW ) ;  File file = new  File ( file Path ) ; if ( file == null || ! file . exists ( ) || ! file . is File ( ) || file . length ( ) <= _ NUM ) { return _ BOOL ; } i . set Data And Type (  Uri . parse ( _ STR + file Path ) , _ STR ) ; i . add Flags (  Intent .  FLAG_ ACTIVITY_ NEW_ TASK ) ; context . start Activity ( i ) ; return _ BOOL ; }
private  List <  IItem > create Insert List (  List <  IItem > item Drag List ) {  List <  IItem > temp List = new  Array List <  IItem > ( ) ;  List <  IItem > insert List = new  Array List <  IItem > ( ) ; int depth = _ NUM ; int removed = _ NUM ; for (  IItem item : item Drag List ) { create Insert List ( item , temp List , insert List , depth , removed ) ; } this . number Of Controls = temp List . size ( ) - removed ; return insert List ; }
public final  Pdf Object read Reference Table ( final  Pdf Object linear Obj , final  Pdf File Reader current Pdf File , final  Object Reader object Reader ) throws  Pdf Exception { int pointer = - _ NUM ; final int eof = ( int ) this . eof ; boolean islinearized Compressed = _ BOOL ; if ( linear Obj == null ) { pointer = read First Start Ref ( ) ; } else { final byte [ ] data = pdf_datafile . get Pdf Buffer ( ) ; final int count = data . length ; int ptr = _ NUM ; for ( int i = _ NUM ; i < count ; i ++ ) { if ( data [ i ] == _ STR && data [ i + _ NUM ] == _ STR && data [ i + _ NUM ] == _ STR && data [ i + _ NUM ] == _ STR && data [ i + _ NUM ] == _ STR && data [ i + _ NUM ] == _ STR ) { ptr = i + _ NUM ; } if ( data [ i ] == _ STR && data [ i + _ NUM ] == _ STR && data [ i + _ NUM ] == _ STR && data [ i + _ NUM ] == _ STR ) { pointer = i ; i = count ; } else if ( data [ i ] == _ STR && data [ i + _ NUM ] == _ STR && data [ i + _ NUM ] == _ STR && data [ i + _ NUM ] == _ STR ) { islinearized Compressed = _ BOOL ; pointer = ptr ; while ( data [ pointer ] == _ NUM || data [ pointer ] == _ NUM || data [ pointer ] == _ NUM ) { pointer ++ ; } i = count ; } } } offset . add Xref ( pointer ) ;  Pdf Object root Obj = null ; if ( pointer >= eof || pointer == _ NUM ) {  Log Writer . write Log ( _ STR ) ; offset . set Ref Table Invalid ( _ BOOL ) ; try { root Obj = new  Page Object (  Broken Ref Table . find Offsets ( pdf_datafile , offset ) ) ; } catch (  Error err ) { throw new  Pdf Exception ( err . get Message ( ) + _ STR ) ; } current Pdf File . read Object ( root Obj ) ; return root Obj ; } else if ( islinearized Compressed || is Compressed Stream ( pointer , eof ) ) { return read Compressed Stream ( root Obj , pointer , current Pdf File , object Reader , linear Obj ) ; } else { return read Legacy Reference Table ( root Obj , pointer , eof , current Pdf File ) ; } }
public void add Push ( int k ) { if ( ( byte ) k == k ) { if ( k == - _ NUM ) { add (  Byte Code .  ICONST_ M1 ) ; } else if ( _ NUM <= k && k <= _ NUM ) { add ( ( byte ) (  Byte Code .  ICONST_0 + k ) ) ; } else { add (  Byte Code .  BIPUSH , ( byte ) k ) ; } } else if ( ( short ) k == k ) { add (  Byte Code .  SIPUSH , ( short ) k ) ; } else { add Load Constant ( k ) ; } }
public  One Must Be Set Global Constraint (  Parameter < ? > ... params ) { parameters =  Arrays . as List ( params ) ; }
public  Rhythm Overlay inflate Overlay (  String config String , @  Non Null  Map <  String ,  String > vars ) {  List <  String > config Strings =  Arrays . as List ( config String . split ( _ STR ) ) ; return inflate Overlay Internal ( config Strings , vars , _ NUM ) ; }
public static  String relative File (  Iterable < ? extends  File > paths ,  String file ) {  File path = select Path ( paths , file ) ;  File rel File = relative File ( path , new  File ( file ) ) ; return rel File . get Path ( ) ; }
public void flip (  WComponent Peer peer ,  Component target ,  Volatile Image back Buffer , int x1 , int y1 , int x2 , int y2 ,  Buffer Capabilities .  Flip Contents flip Action ) { if ( flip Action ==  Buffer Capabilities .  Flip Contents .  COPIED || flip Action ==  Buffer Capabilities .  Flip Contents .  UNDEFINED ) {  Graphics g = peer . get Graphics ( ) ; try { g . draw Image ( back Buffer , x1 , y1 , x2 , y2 , x1 , y1 , x2 , y2 , null ) ; } finally { g . dispose ( ) ; } } else if ( flip Action ==  Buffer Capabilities .  Flip Contents .  BACKGROUND ) {  Graphics g = back Buffer . get Graphics ( ) ; try { g . set Color ( target . get Background ( ) ) ; g . fill Rect ( _ NUM , _ NUM , back Buffer . get Width ( ) , back Buffer . get Height ( ) ) ; } finally { g . dispose ( ) ; } } }
protected void load Value (  String s Value ) { try { value =  Integer . parse Int ( s Value . trim ( ) ) ; } catch (  Number Format Exception nfe ) { revert To Default ( ) ; } }
public static  List <  SOAPElement > input Needed (  SOAPElement ele ) {  List <  SOAPElement > l = new  Array List <  SOAPElement > ( ) ; log . trace ( _ STR + ele . get Node Name ( ) ) ; input Needed ( ele , l ) ; log . trace ( _ STR + l ) ; return l ; }
public  Shape star ( float x , float y , float height ) { float s = ( float ) ( height / ( _ NUM *  Math . sin (  Math . to Radians ( _ NUM ) ) ) ) ; float short Side = ( float ) ( height / ( _ NUM *  Math . tan (  Math . to Radians ( _ NUM ) ) ) ) ; float medium Side = ( float ) ( s *  Math . sin (  Math . to Radians ( _ NUM ) ) ) ; float long Side = ( float ) ( s *  Math . cos (  Math . to Radians ( _ NUM ) ) ) ; float inner Long Side = ( float ) ( s / ( _ NUM *  Math . cos (  Math . to Radians ( _ NUM ) ) ) ) ; float inner Short Side = inner Long Side * ( float )  Math . sin (  Math . to Radians ( _ NUM ) ) ; float inner Medium Side = inner Long Side * ( float )  Math . cos (  Math . to Radians ( _ NUM ) ) ; m_path . reset ( ) ; m_path . move To ( x , y + short Side ) ; m_path . line To ( ( x + inner Long Side ) , ( y + short Side ) ) ; m_path . line To ( ( x + height / _ NUM ) , y ) ; m_path . line To ( ( x + height - inner Long Side ) , ( y + short Side ) ) ; m_path . line To ( ( x + height ) , ( y + short Side ) ) ; m_path . line To ( ( x + height - inner Medium Side ) , ( y + short Side + inner Short Side ) ) ; m_path . line To ( ( x + height - medium Side ) , ( y + height ) ) ; m_path . line To ( ( x + height / _ NUM ) , ( y + short Side + long Side - inner Short Side ) ) ; m_path . line To ( ( x + medium Side ) , ( y + height ) ) ; m_path . line To ( ( x + inner Medium Side ) , ( y + short Side + inner Short Side ) ) ; m_path . close Path ( ) ; return m_path ; }
protected void stop Output Test ( ) { if ( test Running && out Test ) { out Timer . stop ( ) ; status Text1 . set Text ( _ STR +  Integer . to String ( num Iterations ) + _ STR ) ; status Text1 . set Visible ( _ BOOL ) ; status Text2 . set Text ( _ STR ) ; status Text2 . set Visible ( _ BOOL ) ; } }
@  HLEFunction ( nid = _ NUM , version = _ NUM , check Inside Interrupt = _ BOOL ) public int sce Net Adhoc Init ( ) { log . info (  String . format ( _ STR , sce Net . convert Mac Address To String (  Wlan . get Mac Address ( ) ) , sce Utility . get System Param Nickname ( ) ) ) ; if ( is Initialized ) { return  Sce Kernel Errors .  ERROR_ NET_ ADHOC_ ALREADY_ INITIALIZED ; } is Initialized = _ BOOL ; return _ NUM ; }
public static void clear Cache ( ) { cached Networks . clear ( ) ; }
public static void copy File (  File source File ,  File dest File ) throws  IOException { if ( ! source File . exists ( ) ) { throw new  IOException ( _ STR + source File . get Absolute Path ( ) ) ; } copy File ( new  File Input Stream ( source File ) , new  File Output Stream ( dest File ) ) ; }
private synchronized void rebuild Journal ( ) throws  IOException { if ( journal Writer != null ) { journal Writer . close ( ) ; }  Writer writer = new  Buffered Writer ( new  File Writer ( journal File Tmp ) ,  IO_ BUFFER_ SIZE ) ; writer . write (  MAGIC ) ; writer . write ( _ STR ) ; writer . write (  VERSION_1 ) ; writer . write ( _ STR ) ; writer . write (  Integer . to String ( app Version ) ) ; writer . write ( _ STR ) ; writer . write (  Integer . to String ( value Count ) ) ; writer . write ( _ STR ) ; writer . write ( _ STR ) ; for (  Entry entry : lru Entries . values ( ) ) { if ( entry . current Editor != null ) { writer . write (  DIRTY + _ STR + entry . key + _ STR ) ; } else { writer . write (  CLEAN + _ STR + entry . key + entry . get Lengths ( ) + _ STR ) ; } } writer . close ( ) ; journal File Tmp . rename To ( journal File ) ; journal Writer = new  Buffered Writer ( new  File Writer ( journal File , _ BOOL ) ,  IO_ BUFFER_ SIZE ) ; }
public static  File save File (  String log Data ) {  File dir = get Log Dir ( ) ; if ( dir == null ) { return null ; }  File Writer file Writer = null ;  File output = null ; try { output = new  File ( dir , get Log File Name ( ) ) ; file Writer = new  File Writer ( output , _ BOOL ) ; file Writer . write ( log Data ) ; } catch (  IOException e ) { e . print Stack Trace ( ) ; } finally { if ( file Writer != null ) { try { file Writer . close ( ) ; } catch (  IOException e ) { e . print Stack Trace ( ) ; } } } return output ; }
public  List <  Allocation Command > commands ( ) { return this . commands ; }
public long current ( ) { return _sequence . get ( ) ; }
private  Map <  UUID ,  Collection <  Hadoop Input Split > > mappers (  Collection <  Cluster Node > top ,  Collection <  UUID > top Ids ,  Iterable <  Hadoop Input Split > splits ) throws  Ignite Checked Exception {  Map <  UUID ,  Collection <  Hadoop Input Split > > mappers = new  Hash Map < > ( ) ;  Map <  String ,  Collection <  UUID > > nodes = group By Host ( top ) ;  Map <  UUID ,  Integer > node Loads = new  Hash Map < > ( top . size ( ) , _ NUM ) ; for (  UUID node Id : top Ids ) node Loads . put ( node Id , _ NUM ) ; for (  Hadoop Input Split split : splits ) {  UUID node Id = node For Split ( split , top Ids , nodes , node Loads ) ; if ( log . is Debug Enabled ( ) ) log . debug ( _ STR + split + _ STR + node Id + _ STR ) ;  Collection <  Hadoop Input Split > node Splits = mappers . get ( node Id ) ; if ( node Splits == null ) { node Splits = new  Array List < > ( ) ; mappers . put ( node Id , node Splits ) ; } node Splits . add ( split ) ; node Loads . put ( node Id , node Loads . get ( node Id ) + _ NUM ) ; } return mappers ; }
public byte [ ] handle Request (  String request ) throws  IOException ,  Map Request Format Exception {  Properties request Properties = convert Request To Props ( request ) ;  String request Type = request Properties . get Property (  REQUEST ) ; if ( request Type != null ) { if ( request Type . equals Ignore Case (  MAP ) ) {  Debug . message ( _ STR , _ STR ) ; return handle Map Request ( request Properties ) ; } else { throw new  Map Request Format Exception ( _ STR + request Type ) ; } } else { throw new  Map Request Format Exception ( _ STR + request ) ; } }
public  String format ( int val ) {  Decimal Format df = get Int Format ( ) ; if ( df != null ) { return df . format ( val ) ; } return  Integer . to String ( val ) ; }
private void delete Selected Items ( ) {  Sparse Boolean Array positions = list View . get Checked Item Positions ( ) ;  List <  Todo > deletions = new  Array List <  Todo > ( ) ; if ( positions . size ( ) == _ NUM ) { deletions . add ( adapter . get Item ( positions . key At ( _ NUM ) ) ) ; } else { for ( int i = _ NUM ; i < positions . size ( ) ; i ++ ) { int key = positions . key At ( i ) ; if ( positions . get ( key ) ) { deletions . add ( adapter . get Item ( key ) ) ; } } } for (  Todo item : deletions ) {  Todo Helper . delete Todo ( get Content Resolver ( ) , item ) ; } adapter . clear Selections ( ) ; }
private void paint Check Icon Enabled (  Graphics2 D g , int width , int height ) { g . set Paint ( icon Enabled ) ; g . draw Round Rect ( _ NUM , _ NUM , width - _ NUM , height - _ NUM , _ NUM , _ NUM ) ; }
public  List <  Colour Change > sample Conditional Migration Events ( int parent Colour , double parent Height , int child Colour , double child Height , double [ ] m ) {  List <  Colour Change > colour Changes = new  Array List <  Colour Change > ( ) ; int current Colour ; double current Height ; do { colour Changes . clear ( ) ; current Colour = parent Colour ; current Height = parent Height ; do { double total Rate = m [ _ NUM - current Colour ] ; double  U =  Math Utils . next Double ( ) ; if ( ( parent Colour != child Colour ) && ( colour Changes . size ( ) == _ NUM ) ) { double min U =  Math . exp ( - total Rate * ( parent Height - child Height ) ) ;  U = min U +  U * ( _ NUM - min U ) ; } double time = -  Math . log (  U ) / total Rate ; current Height -= time ; if ( current Height > child Height ) { current Colour = _ NUM - current Colour ; colour Changes . add ( new  Colour Change ( current Height , current Colour ) ) ; } } while ( current Height > child Height ) ; } while ( current Colour != child Colour ) ; reverse Colour Change List ( colour Changes , parent Colour ) ; return colour Changes ; }
public final  Array List <  Move > variations ( ) { if ( current Node . verify Children ( current Pos ) ) update Listener ( ) ;  Array List <  Move > ret = new  Array List <  Move > ( ) ; for (  Node child : current Node . children ) ret . add ( child . move ) ; return ret ; }
public static boolean contains Modifiable Variable Modification (  Protocol Message object ) { for (  Modifiable Variable Holder holder : object . get All Modifiable Variable Holders ( ) ) { for (  Field f : holder . get All Modifiable Variable Fields ( ) ) { if ( contains Modifiable Variable Modification ( holder , f ) ) { return _ BOOL ; } } } return _ BOOL ; }
protected void append (  String s ) {  Buffered Writer writer ; if ( m_ Log File == null ) return ; try { writer = new  Buffered Writer ( new  File Writer ( m_ Log File , _ BOOL ) ) ; writer . write ( s ) ; writer . flush ( ) ; writer . close ( ) ; } catch (  Exception e ) { } }
public static  String read File To String (  File file ) { if ( file == null ) { return null ; }  Buffered Reader reader = null ; try { reader = new  Buffered Reader ( new  File Reader ( file ) ) ;  String Builder file Contents = new  String Builder ( _ STR ) ; boolean is First Line = _ BOOL ;  String current Line = reader . read Line ( ) ; while ( current Line != null ) { if ( is First Line ) is First Line = _ BOOL ; else file Contents . append (  System . line Separator ( ) ) ; file Contents . append ( current Line ) ; current Line = reader . read Line ( ) ; } return file Contents . to String ( ) ; } catch (  Exception e ) { logger . debug ( e . to String ( ) +  System . line Separator ( ) +  Stack Trace . get String From Stack Trace ( e ) ) ; return null ; } finally { try { if ( reader != null ) { reader . close ( ) ; } } catch (  Exception e ) { logger . debug ( e . to String ( ) +  System . line Separator ( ) +  Stack Trace . get String From Stack Trace ( e ) ) ; } } }
public final double do Operation ( ) throws  Operator Failed Exception {  Node Ref root = tree . get Root ( ) ;  List <  Node Ref > candidates = new  Array List <  Node Ref > ( ) ; for ( int i = _ NUM ; i < tree . get Node Count ( ) ; i ++ ) {  Node Ref node = tree . get Node ( i ) ; if ( node != root && tree . get Parent ( node ) != root ) {  Node Ref parent = tree . get Parent ( node ) ; int sum = rate Change ( tree , node ) + rate Change ( tree , parent ) ; if ( sum == _ NUM ) candidates . add ( node ) ; } } if ( candidates . size ( ) == _ NUM ) throw new  Operator Failed Exception ( _ STR ) ;  Node Ref node = candidates . get (  Math Utils . next Int ( candidates . size ( ) ) ) ;  Node Ref parent = tree . get Parent ( node ) ; double node Trait , parent Trait ; double node Rate , parent Rate ; node Trait = tree . get Node Trait ( node , indicator Trait ) ; parent Trait = tree . get Node Trait ( parent , indicator Trait ) ; tree . set Node Trait ( node , indicator Trait , parent Trait ) ; tree . set Node Trait ( parent , indicator Trait , node Trait ) ; if ( trait2 != null ) { node Trait = tree . get Node Trait ( node , trait2 ) ; parent Trait = tree . get Node Trait ( parent , trait2 ) ; tree . set Node Trait ( node , trait2 , parent Trait ) ; tree . set Node Trait ( parent , trait2 , node Trait ) ; } else { node Rate = tree . get Node Rate ( node ) ; parent Rate = tree . get Node Rate ( parent ) ; tree . set Node Rate ( node , parent Rate ) ; tree . set Node Rate ( parent , node Rate ) ; } return _ NUM ; }
private void close Internal ( ) { final  Bigdata Sail Repository Connection cxn = tl Tx . get ( ) ; if ( cxn != null ) { close ( cxn ) ; } }
private void read Central Dir ( ) throws  IOException { long scan Offset = ras . length ( ) -  ENDHDR ; if ( scan Offset < _ NUM ) { throw new  Zip Exception ( _ STR + ras . length ( ) ) ; } ras . set Position ( _ NUM ) ; final int header Magic = ras . read S32_ LE ( ) ; if ( header Magic !=  LOCSIG ) { throw new  Zip Exception ( _ STR ) ; } long stop Offset = scan Offset - _ NUM ; if ( stop Offset < _ NUM ) { stop Offset = _ NUM ; } while ( _ BOOL ) { ras . set Position ( scan Offset ) ; if ( ras . read S32_ LE ( ) ==  ENDSIG ) { break ; } scan Offset -- ; if ( scan Offset < stop Offset ) { throw new  Zip Exception ( _ STR ) ; } } byte [ ] eocd = ras . read Bytes (  ENDHDR - _ NUM ) ;  Buffer Iterator it =  Heap Buffer Iterator . iterator ( eocd , _ NUM , eocd . length ,  Byte Order .  LITTLE_ ENDIAN ) ; int disk Number = it . read Short ( ) & _ NUM ; int disk With Central Dir = it . read Short ( ) & _ NUM ; int num Entries = it . read Short ( ) & _ NUM ; int total Num Entries = it . read Short ( ) & _ NUM ; long central Dir Size = ( ( long ) it . read Int ( ) ) & _ NUM ; long central Dir Offset = ( ( long ) it . read Int ( ) ) & _ NUM ; int comment Length = it . read Short ( ) & _ NUM ; if ( num Entries != total Num Entries || disk Number != _ NUM || disk With Central Dir != _ NUM ) { throw new  Zip Exception ( _ STR ) ; } if ( comment Length > _ NUM ) { byte [ ] comment Bytes = ras . read Bytes ( comment Length ) ; comment = new  String ( comment Bytes , _ NUM , comment Bytes . length ,  Standard Charsets .  UTF_8 ) ; }  RASlice slice = ras . slice ( central Dir Offset , central Dir Offset + central Dir Size ) ; byte [ ] hdr Buf = new byte [  CENHDR ] ; for ( int i = _ NUM ; i < num Entries ; ++ i ) {  Zip Entry new Entry = new  Zip Entry ( hdr Buf , slice . create Input Stream ( ) ) ; if ( new Entry . local Header Rel Offset >= central Dir Offset ) { throw new  Zip Exception ( _ STR ) ; }  String entry Name = new Entry . get Name ( ) ; if ( entries . put ( entry Name , new Entry ) != null ) { throw new  Zip Exception ( _ STR + entry Name ) ; } } }
private  List <  Object > create Object List (  Object object ,  List <  Object > object List ) { if ( are Filters Passed ( object ) && ! get Expanded State ( object ) ) { if ( children Loaded ( object ) ) { expand To Level ( object , _ NUM ) ; } else { if ( object List == null ) { object List = new  Array List < > ( ) ; } object List . add ( object ) ; } }  Object parent = get Parent Element ( object ) ; if ( null != parent ) { create Object List ( parent , object List ) ; } return object List ; }
@  Suppress Warnings ( _ STR ) public static void create Project Guideline (  Zip File zip ,  Project a Project ,  Repository Service a Repository ) throws  IOException { for (  Enumeration zip Enumerate = zip . entries ( ) ; zip Enumerate . has More Elements ( ) ; ) {  Zip Entry entry = (  Zip Entry ) zip Enumerate . next Element ( ) ;  String entry Name = normalize Entry Name ( entry ) ; if ( entry Name . starts With (  GUIDELINE ) ) {  String filename =  Filename Utils . get Name ( entry . get Name ( ) ) ;  File guideline Dir = a Repository . get Guidelines File ( a Project ) ;  File Utils . force Mkdir ( guideline Dir ) ;  File Utils . copy Input Stream To File ( zip . get Input Stream ( entry ) , new  File ( guideline Dir , filename ) ) ;  LOG . info ( _ STR + filename + _ STR + a Project . get Name ( ) + _ STR + a Project . get Id ( ) + _ STR ) ; } } }
public  Block Transform Extent (  Extent extent ,  Transform transform ,  Block Registry block Registry ) { super ( extent ) ; check Not Null ( transform ) ; check Not Null ( block Registry ) ; this . transform = transform ; this . block Registry = block Registry ;  BLOCK_ TRANSFORM = new  Base Block [  Fawe Cache .  CACHE_ BLOCK . length ] ;  BLOCK_ TRANSFORM_ INVERSE = new  Base Block [  Fawe Cache .  CACHE_ BLOCK . length ] ;  Transform inverse = transform . inverse ( ) ; for ( int i = _ NUM ; i <  BLOCK_ TRANSFORM . length ; i ++ ) {  Base Block block =  Fawe Cache .  CACHE_ BLOCK [ i ] ; if ( block != null ) {  BLOCK_ TRANSFORM [ i ] = transform ( new  Base Block ( block ) , transform , block Registry ) ;  BLOCK_ TRANSFORM_ INVERSE [ i ] = transform ( new  Base Block ( block ) , inverse , block Registry ) ; } } }
public static <  S >  Service Loader <  S > load Installed (  Class <  S > service ) {  Class Loader cl =  Class Loader . get System Class Loader ( ) ; if ( cl != null ) { while ( cl . get Parent ( ) != null ) { cl = cl . get Parent ( ) ; } } return  Service Loader . load ( service , cl ) ; }
private static int convert Style (  Format Style style ) { if ( style == null ) { return - _ NUM ; } return style . ordinal ( ) ; }
private  Size parse Size (  String token ) { if ( token . starts With ( _ STR ) && token . ends With ( _ STR ) ) { return parse Bounded Size ( token ) ; } if ( token . starts With ( _ STR ) && token . ends With ( _ STR ) ) { return parse Old Bounded Size ( token , _ BOOL ) ; } if ( token . starts With ( _ STR ) && token . ends With ( _ STR ) ) { return parse Old Bounded Size ( token , _ BOOL ) ; } return parse Atomic Size ( token ) ; }
Builder add Query Parameter (  String name ,  String value ) { if ( name == null ) throw new  Illegal Argument Exception ( _ STR ) ; if ( encoded Query Names And Values == null ) encoded Query Names And Values = new  Array List < > ( ) ; encoded Query Names And Values . add ( canonicalize ( name ,  QUERY_ COMPONENT_ ENCODE_ SET , _ BOOL , _ BOOL ) ) ; encoded Query Names And Values . add ( value != null ? canonicalize ( value ,  QUERY_ COMPONENT_ ENCODE_ SET , _ BOOL , _ BOOL ) : null ) ; return this ; }
private static img create Image (  String  AD_ Language ,  String name ,  String js_command , boolean enabled , boolean pressed ) {  String Buffer img Name = new  String Buffer ( name ) ; if ( ! enabled ) img Name . append ( _ STR ) ; else if ( pressed ) img Name . append ( _ STR ) ; img Name . append ( _ STR ) ; img img = new img (  Web Env . get Image Directory ( img Name . to String ( ) ) , name ) ; if ( enabled ) img . set Alt (  Msg . get Msg (  AD_ Language , name ) ) ; if ( ! pressed || ! enabled ) img . set ID ( _ STR ) ; else img . set ID ( _ STR ) ; img . set Height ( _ NUM ) ; img . set Width ( _ NUM ) ; img . set Border ( _ NUM ) ; img . set Title ( name ) ; return img ; }
public  Set <  Json User > load Known Users ( ) throws  Interrupted Exception ,  Execution Exception ,  Remote Exception ,  Operation Application Exception {  Set <  Json User > users = get Users From Db ( ) ; if ( users . is Empty ( ) ) {  LOG . i ( _ STR ) ; users = sync Known Users ( ) ; }  LOG . i (  String . format ( _ STR , users . size ( ) ) ) ; return users ; }
public final long decrement And Get ( ) { return unsafe . get And Add Long ( this , value Offset , - _ NUM ) - _ NUM ; }
public static float rotate X ( float p X , float p Y , float c X , float c Y , float angle In Degrees ) { double angle =  Math . to Radians ( angle In Degrees ) ; return ( float ) (  Math . cos ( angle ) * ( p X - c X ) -  Math . sin ( angle ) * ( p Y - c Y ) + c X ) ; }
public final void add (  V value ) { if (  GWT . is Script ( ) ) { js Array . add ( value ) ; } else { java Array . add ( value ) ; } }
@  Override public synchronized void clear ( ) {  File [ ] files = m Root Directory . list Files ( ) ; if ( files != null ) { for (  File file : files ) { file . delete ( ) ; } } m Entries . clear ( ) ; m Total Size = _ NUM ;  Volley Log . d ( _ STR ) ; }
public  String product Publication Date ( ) { return properties . get Property ( _ STR ) ; }
private void use Our UIs ( ) { for (  String ui Name :  UI_ LIST ) { ui Name = ui Name + _ STR ; ui Defaults . put ( ui Name ,  UI_ PACKAGE_ PREFIX + ui Name ) ; } }
public void make Immutable ( ) { super . make Immutable ( ) ; }
public  KNNDistance Order Result run (  Database database ,  Relation <  O > relation ) { final  Distance Query <  O > distance Query = database . get Distance Query ( relation , get Distance Function ( ) ) ; final  KNNQuery <  O > knn Query = database . get KNNQuery ( distance Query , k + _ NUM ) ; final int size = ( int ) ( ( sample <= _ NUM ) ?  Math . ceil ( relation . size ( ) * sample ) : sample ) ;  DBIDs sample =  DBIDUtil . random Sample ( relation . get DBIDs ( ) , size , rnd ) ;  Finite Progress prog =  LOG . is Verbose ( ) ? new  Finite Progress ( _ STR , size ,  LOG ) : null ; double [ ] knn Distances = new double [ size ] ; int i = _ NUM ; for (  DBIDIter iditer = sample . iter ( ) ; iditer . valid ( ) ; iditer . advance ( ) , i ++ ) { final  KNNList neighbors = knn Query . get KNNFor DBID ( iditer , k + _ NUM ) ; knn Distances [ i ] = neighbors . get KNNDistance ( ) ;  LOG . increment Processed ( prog ) ; }  LOG . ensure Completed ( prog ) ; return new  KNNDistance Order Result ( knn Distances , k ) ; }
public static  Sparse Int Array adjust Position (  Sparse Int Array positions , int start Position , int end Position , int adjust By ) {  Sparse Int Array new Positions = new  Sparse Int Array ( ) ; for ( int i = _ NUM , size = positions . size ( ) ; i < size ; i ++ ) { int position = positions . key At ( i ) ; if ( position < start Position || position > end Position ) { new Positions . put ( position , positions . value At ( i ) ) ; } else if ( adjust By > _ NUM ) { new Positions . put ( position + adjust By , positions . value At ( i ) ) ; } else if ( adjust By < _ NUM ) { if ( position > start Position + adjust By && position <= start Position ) { ; } else { new Positions . put ( position + adjust By , positions . value At ( i ) ) ; } } } return new Positions ; }
private  Resolved Migration create Available Migration (  String version ) {  Resolved Migration migration = new  Resolved Migration ( ) ; migration . set Version (  Migration Version . from Version ( version ) ) ; migration . set Description ( _ STR ) ; migration . set Script ( _ STR ) ; migration . set Type (  Migration Type .  CQL ) ; return migration ; }
public boolean draw Image (  Image img , int x , int y , int width , int height ,  Color bg ,  Image Observer observer ) { if ( img == null ) { return _ BOOL ; } if ( ( width == _ NUM ) || ( height == _ NUM ) ) { return _ BOOL ; } final int img W = img . get Width ( null ) ; final int img H = img . get Height ( null ) ; if ( is Hi DPIImage ( img ) ) { return draw Hi DPIImage ( img , x , y , x + width , y + height , _ NUM , _ NUM , img W , img H , bg , observer ) ; } if ( width == img W && height == img H ) { return copy Image ( img , x , y , _ NUM , _ NUM , width , height , bg , observer ) ; } try { return imagepipe . scale Image ( this , img , x , y , width , height , bg , observer ) ; } catch (  Invalid Pipe Exception e ) { try { revalidate All ( ) ; return imagepipe . scale Image ( this , img , x , y , width , height , bg , observer ) ; } catch (  Invalid Pipe Exception e2 ) { return _ BOOL ; } } finally { surface Data . mark Dirty ( ) ; } }
public void begin Display (  Display Event event ) throws  Model Control Exception { super . begin Display ( event ) ;  Server Site Model model = (  Server Site Model ) get Model ( ) ;  String server Name = (  String ) get Page Session Attribute (  PG_ ATTR_ SERVER_ NAME ) ;  Object [ ] param = { server Name } ; pt Model . set Page Title Text (  Message Format . format ( model . get Localized String ( _ STR ) , param ) ) ; set Display Field Value ( _ STR ,  Message Format . format ( model . get Localized String ( _ STR ) , param ) ) ; }
void dispose ( ) { reverse . dispose ( ) ; if (  DO_ CLEAN_ DIRTY ) {  Arrays . fill ( offset0 , _ NUM ) ;  Arrays . fill ( offset1 , _ NUM ) ;  Arrays . fill ( offset2 , _ NUM ) ;  Arrays . fill ( miter , _ NUM ) ;  Arrays . fill ( middle , _ NUM ) ;  Arrays . fill ( lp , _ NUM ) ;  Arrays . fill ( rp , _ NUM ) ;  Arrays . fill ( subdiv Ts , _ NUM ) ; } }
public  Builder add (  String name ,  String value ) { check Name And Value ( name , value ) ; return add Lenient ( name , value ) ; }
public int size ( ) { return set . size ( ) ; }
void refresh Preferred Countries ( ) { if ( country Preference == null || country Preference . length ( ) == _ NUM ) { preferred Countries = null ; } else {  List <  Country > local Country List = new  Array List < > ( ) ; for (  String name Code : country Preference . split ( _ STR ) ) {  Country country =  Country . get Country For Name Code From Custom Master List ( custom Master Countries List , custom Language , name Code ) ; if ( country != null ) { if ( ! is Already In List ( country , local Country List ) ) { local Country List . add ( country ) ; } } } if ( local Country List . size ( ) == _ NUM ) { preferred Countries = null ; } else { preferred Countries = local Country List ; } } if ( preferred Countries != null ) { for (  Country country : preferred Countries ) { country . log ( ) ; } } else { } }
public void remove Pause Listener (  Animator Pause Listener listener ) { if ( m Pause Listeners == null ) { return ; } m Pause Listeners . remove ( listener ) ; if ( m Pause Listeners . size ( ) == _ NUM ) { m Pause Listeners = null ; } }
public static  String format (  Attributes attrs ) throws  Naming Exception { if ( attrs == null || attrs . size ( ) == _ NUM ) { return _ STR ; }  String answer ; answer = _ STR ;  Attribute attr ; for (  Naming Enumeration < ? extends  Attribute > e = attrs . get All ( ) ; e . has More ( ) ; ) { attr = e . next ( ) ; if ( attr . size ( ) == _ NUM || ( attr . size ( ) == _ NUM && attr . get ( ) == null ) ) { answer += _ STR + attr . get ID ( ) + _ STR + _ STR ; } else { for (  Naming Enumeration < ? > ve = attr . get All ( ) ; ve . has More ( ) ; ) {  String val = get Encoded String Rep ( ve . next ( ) ) ; if ( val != null ) { answer += _ STR + attr . get ID ( ) + _ STR + val + _ STR ; } } } } answer += _ STR ; return answer ; }
public static  Buffered Input Stream new Input Stream (  File file ) throws  File Not Found Exception { return new  Buffered Input Stream ( new  File Input Stream ( file ) ) ; }
protected void add (  Object component ) { if ( component == null ) { return ; } components . add ( component ) ; }
public static  Optional <  Input Stream > open Stream ( final  URI uri ) { try { return  Url Streams . open Stream ( uri . to URL ( ) ) ; } catch ( final  Malformed URLException e ) { throw new  Illegal State Exception ( _ STR + uri , e ) ; } }
public  Short Banded Raster (  Sample Model sample Model ,  Point origin ) { this ( sample Model , sample Model . create Data Buffer ( ) , new  Rectangle ( origin . x , origin . y , sample Model . get Width ( ) , sample Model . get Height ( ) ) , origin , null ) ; }
public void delete (  Job Notification current Notification ) { for ( int i = notifications . size ( ) ; -- i >= _ NUM ; ) { if ( notifications . get ( i ) == current Notification ) { notifications . remove ( i ) ; break ; } } }
public  Windows XP ( ) { int procs = _ NUM ;  String info = _ STR ; try {  Runtime rt =  Runtime . get Runtime ( ) ;  Process proc = rt . exec ( _ STR ) ;  Buffered Reader reader = new  Buffered Reader ( new  Input Stream Reader ( proc . get Input Stream ( ) ) ) ;  String num Procs = reader . read Line ( ) ; proc = rt . exec ( _ STR ) ; reader = new  Buffered Reader ( new  Input Stream Reader ( proc . get Input Stream ( ) ) ) ; info = reader . read Line ( ) ; procs =  Integer . parse Int ( num Procs ) ; } catch (  Exception e ) { } m_processors = procs ; m_cpu Info = info ; }
public void do Post (  Http Servlet Request request ,  Http Servlet Response response ) throws  Servlet Exception ,  IOException { do Get ( request , response ) ; }
public  String is Valid Operand (  Full Argument operand , boolean execute Now ) { if ( operand . address . type ==  Op .  ERROR ) { return _ STR ; } if ( ( operand . address . type &  Op .  MEM ) != _ NUM ) { return is Valid Address ( operand . arg , operand . address . size , execute Now ) ; } return null ; }
public static  QName value Of (  String s ) { if ( ( s == null ) || s . equals ( _ STR ) ) { throw new  Illegal Argument Exception ( _ STR ) ; } if ( s . char At ( _ NUM ) == _ STR ) { int i = s . index Of ( _ STR ) ; if ( i == - _ NUM ) { throw new  Illegal Argument Exception ( _ STR ) ; } if ( i == s . length ( ) - _ NUM ) { throw new  Illegal Argument Exception ( _ STR ) ; } else { return new  QName ( s . substring ( _ NUM , i ) , s . substring ( i + _ NUM ) ) ; } } else { return new  QName ( s ) ; } }
public  String generate Challan ( final  Receipt Header receipt , final boolean flag ) { final  List <  Bill Receipt Info > receipt List = new  Array List <  Bill Receipt Info > ( _ NUM ) ; receipt List . add ( new  Bill Receipt Info Impl ( receipt , egov Common , new  Receipt Header ( ) , chart Of Accounts Hibernate DAO , persistence Service ) ) ; final  String template Name =  Collection Constants .  CHALLAN_ TEMPLATE_ NAME ; final  Map <  String ,  Object > report Params = new  Hash Map <  String ,  Object > ( _ NUM ) ; report Params . put ( _ STR , egov Common ) ; final  Report Request report Input = new  Report Request ( template Name , receipt List , report Params ) ; report Input . set Print Dialog On Open Report ( flag ) ; return report Viewer Util . add Report To Temp Cache ( collections Util . create Report ( report Input ) ) ; }
public long skip ( long count ) throws  IOException { long remaining = count ; while ( remaining > _ NUM ) { int skip =  Math . max (  Integer .  MAX_ VALUE , ( int ) remaining ) ; skip ( skip ) ; remaining -= skip ; } return count ; }
public void test_concurrent_modification_insert_split_root_leaf ( ) { final  BTree btree ; {  Index Metadata md = new  Index Metadata (  UUID . random UUID ( ) ) ; md . set Branching Factor ( _ NUM ) ; btree =  BTree . create ( new  Simple Memory Raw Store ( ) , md ) ; btree . insert ( _ NUM , _ STR ) ; btree . insert ( _ NUM , _ STR ) ; btree . insert ( _ NUM , _ STR ) ; } {  ITuple Cursor2 <  String > cursor = new Cursor ( btree ) ; assert Equals ( new  Test Tuple <  String > ( _ NUM , _ STR ) , cursor . seek ( _ NUM ) ) ; assert Equals ( new  Test Tuple <  String > ( _ NUM , _ STR ) , cursor . tuple ( ) ) ; btree . insert ( _ NUM , _ STR ) ; assert Equals (  Test Key Builder . as Sort Key ( _ NUM ) , cursor . current Key ( ) ) ; assert Equals ( new  Test Tuple <  String > ( _ NUM , _ STR ) , cursor . tuple ( ) ) ; assert Equals ( new  Test Tuple <  String > ( _ NUM , _ STR ) , cursor . prior ( ) ) ; assert Equals ( new  Test Tuple <  String > ( _ NUM , _ STR ) , cursor . tuple ( ) ) ; btree . remove ( _ NUM ) ; assert Equals (  Test Key Builder . as Sort Key ( _ NUM ) , cursor . current Key ( ) ) ; assert Equals ( null , cursor . tuple ( ) ) ; assert Equals ( new  Test Tuple <  String > ( _ NUM , _ STR ) , cursor . next ( ) ) ; btree . remove ( _ NUM ) ; assert Equals (  Test Key Builder . as Sort Key ( _ NUM ) , cursor . current Key ( ) ) ; assert Equals ( null , cursor . tuple ( ) ) ; btree . insert ( _ NUM , _ STR ) ; assert Equals (  Test Key Builder . as Sort Key ( _ NUM ) , cursor . current Key ( ) ) ; assert Equals ( null , cursor . tuple ( ) ) ; assert Equals ( new  Test Tuple <  String > ( _ NUM , _ STR ) , cursor . next ( ) ) ; assert Equals ( new  Test Tuple <  String > ( _ NUM , _ STR ) , cursor . tuple ( ) ) ; } }
private synchronized void stop Ims Connection (  Termination Reason reason Code ) throws  Payload Exception ,  Network Exception ,  Contact Manager Exception { if ( m Ims Polling Thread Id == - _ NUM ) { return ; } if ( s Logger . is Activated ( ) ) { s Logger . info ( _ STR ) ; } m Ims Polling Thread Id = - _ NUM ; m Ims Polling Thread . interrupt ( ) ; m Ims Polling Thread = null ; if ( m Ims Services Started ) { m Ims Module . stop Ims Services ( reason Code ) ; m Ims Services Started = _ BOOL ; } }
public void copy String (  String encoding ,  String s ) throws  Unsupported Encoding Exception { super . set Content Encoding ( encoding ) ; content = s . get Bytes ( encoding ) ; }
private  List <  Column Dictionary Chunk > read Dictionary File ( long dictionary Start Offset , int dictionary Chunk Count To Be Read ) throws  IOException {  List <  Column Dictionary Chunk > dictionary Chunks = new  Array List <  Column Dictionary Chunk > ( dictionary Chunk Count To Be Read ) ; dictionary File Reader . set Read Offset ( dictionary Start Offset ) ; while ( dictionary File Reader . has Next ( ) && dictionary Chunks . size ( ) != dictionary Chunk Count To Be Read ) { dictionary Chunks . add ( (  Column Dictionary Chunk ) dictionary File Reader . read ( ) ) ; } return dictionary Chunks ; }
public boolean has Argument (  String arg ) { return arguments . contains ( arg ) ; }
public static boolean rename File ( final  File from File , final  File to File ) {  File to File2 = to File ; if ( from File . rename To ( to File ) ) { return _ BOOL ; } if ( ! from File . exists ( ) ) { return _ BOOL ; } if ( ! from File . can Read ( ) ) { return _ BOOL ; } if ( to File . is Directory ( ) ) { to File2 = new  File ( to File , from File . get Name ( ) ) ; } if ( to File2 . exists ( ) ) { return _ BOOL ; }  String parent = to File2 . get Parent ( ) ; if ( parent == null ) parent =  System . get Property ( _ STR ) ;  File dir = new  File ( parent ) ; if ( ! dir . exists ( ) ) { return _ BOOL ; } if ( ! dir . can Write ( ) ) { return _ BOOL ; } try { copy File ( from File , to File2 ) ; } catch (  Unchecked IOException e ) { if ( to File2 . exists ( ) ) to File2 . delete ( ) ; return _ BOOL ; } from File . delete ( ) ; return _ BOOL ; }
public void on Destroy ( ) { m Listener = null ; if ( m Is Internal Executor ) { m Async Executor . shutdown ( ) ; } }
public static int count ( final  String text ) { return text . length ( ) ; }
protected static @  Not Null  String convert Map To Groovy Source ( @  Not Null  Map <  String ,  Object > map ) {  String Builder sb = new  String Builder ( ) ; for (  Map .  Entry <  String ,  Object > entry : map . entry Set ( ) ) { if ( sb . length ( ) > _ NUM ) { sb . append ( _ STR ) ; } sb . append ( entry . get Key ( ) ) ; sb . append ( _ STR ) ; sb . append ( convert Value To Groovy Source ( entry . get Value ( ) ) ) ; } return sb . to String ( ) ; }
private void configure Charset Properties ( ) throws  SQLException { if ( get Encoding ( ) != null ) { try {  String test String = _ STR ;  String Utils . get Bytes ( test String , get Encoding ( ) ) ; } catch (  Unsupported Encoding Exception  UE ) {  String old Encoding = get Encoding ( ) ; try { set Encoding (  Charset Mapping . get Java Encoding For Mysql Charset ( old Encoding ) ) ; } catch (  Runtime Exception ex ) {  SQLException sql Ex =  SQLError . create SQLException ( ex . to String ( ) ,  SQLError .  SQL_ STATE_ ILLEGAL_ ARGUMENT , null ) ; sql Ex . init Cause ( ex ) ; throw sql Ex ; } if ( get Encoding ( ) == null ) { throw  SQLError . create SQLException ( _ STR + old Encoding + _ STR ,  SQLError .  SQL_ STATE_ INVALID_ CONNECTION_ ATTRIBUTE , get Exception Interceptor ( ) ) ; } try {  String test String = _ STR ;  String Utils . get Bytes ( test String , get Encoding ( ) ) ; } catch (  Unsupported Encoding Exception encoding Ex ) { throw  SQLError . create SQLException ( _ STR + get Encoding ( ) + _ STR ,  SQLError .  SQL_ STATE_ INVALID_ CONNECTION_ ATTRIBUTE , get Exception Interceptor ( ) ) ; } } } }
protected  Buffered Image create Buffered Image ( int width , int height ) {  Buffered Image image =  Image Util . create Compatible Buffered Image ( width , height ,  Buffered Image .  TYPE_ INT_ RGB ) ;  Image Util . clear Image ( image ) ; return image ; }
public void start ( ) { start Time =  System . current Time Millis ( ) ; }
public void next (  Controller Animator animator ) { if ( animator == null ) throw new  Null Pointer Exception ( _ STR ) ; if ( iterator . has Next ( ) ) {  View current View = iterator . next ( ) ; if ( is Using Default Listener ( ) ) current View . set On Click Listener ( null ) ; if ( iterator . next Index ( ) < m Views . size ( ) ) {  View next View = m Views . get ( iterator . next Index ( ) ) ; if ( is Using Default Listener ( ) ) next View . set On Click Listener ( listener ) ; animator . set Old View ( current View ) ; animator . set New View ( next View ) ; current View . start Animation ( animator ) ; if ( iterator . next Index ( ) == m Views . size ( ) - _ NUM ) if ( has Controller Listener ( ) ) m Listener . on End Reached ( ) ; } else { if ( m Loop ) { iterator = m Views . list Iterator ( ) ;  View next View = m Views . get ( _ NUM ) ; if ( m Use Default Listener ) next View . set On Click Listener ( listener ) ; animator . set Old View ( current View ) ; animator . set New View ( next View ) ; current View . start Animation ( animator ) ; } } } }
private static  Method find Overloaded Method (  Class base Class ,  String method Name ,  Class [ ] types , boolean public Only ) { if (  Interpreter .  DEBUG )  Interpreter . debug ( _ STR +  String Util . method String ( method Name , types ) + _ STR + base Class . get Name ( ) + _ STR ) ;  Method [ ] methods = get Candidate Methods ( base Class , method Name , types . length , public Only ) ; if (  Interpreter .  DEBUG )  Interpreter . debug ( _ STR + method Name ) ;  Method method = find Most Specific Method ( types , methods ) ; return method ; }
public static  Map <  String ,  String > convert Object Map To String Map (  Object obj ) { final  Map <  Object ,  Object > map = (  Map <  Object ,  Object > ) obj ; final  Map <  String ,  String > metadata = new  Hash Map < > ( ) ; for (  Map .  Entry <  Object ,  Object > entry : map . entry Set ( ) ) { metadata . put (  String . value Of ( entry . get Key ( ) ) ,  String . value Of ( entry . get Value ( ) ) ) ; } return metadata ; }
@  Override public void close ( ) throws  IOException { if ( ! access . equals ( _ STR ) ) { if ( data Stream != null ) { data Stream . close ( ) ; data Stream = null ; } if ( output Stream != null ) { output Stream . close ( ) ; output Stream = null ; } } else if ( i Stream != null ) { i Stream . close ( ) ; } }
protected void remove Item ( int index ) { if ( nodes != null && index < nodes . size ( ) ) { nodes . remove ( index ) ; } }
String char To String ( char c ) { if ( c < _ STR || c > _ NUM ) { return _ STR + ( int ) c ; } return  String . value Of ( c ) ; }
public  GTSEncoder ( long base Timestamp , byte [ ] key ) { this . base Timestamp = base Timestamp ; this . stream = new  Byte Array Output Stream ( ) ; this . wrapping Key = null == key ? null :  Arrays . copy Of ( key , key . length ) ; }
public static  Location convert Lat Lng (  Lat Lng location ) { return convert Lat Lng ( location . latitude , location . longitude ) ; }
public  Attribute Weights ( ) { }
public void close ( ) { flush ( ) ; if ( writer != null ) { try { writer . close ( ) ; } catch (  IOException e ) {  Debug . error ( file Name + _ STR , e ) ; } } stop Buffer Timer ( ) ; }
public boolean contains ( byte [ ] bytes ) { int [ ] hashes = create Hashes ( bytes , k , get New Digest Function ( ) ) ; for ( int hash : hashes ) { if ( ! bitset . get (  Math . abs ( hash % bit Set Size ) ) ) { return _ BOOL ; } } return _ BOOL ; }
public void put String (  String s ) { ensure Capacity ( ( s . length ( ) * _ NUM ) + _ NUM ) ;  System . arraycopy ( s . get Bytes ( ) , _ NUM , this . byte Buffer , this . position , s . length ( ) ) ; this . position += s . length ( ) ; this . byte Buffer [ this . position ++ ] = _ NUM ; }
private boolean is Valid Region Code (  String region Code ) { return region Code != null && supported Regions . contains ( region Code ) ; }
public  String normalize Uri (  String uri ) { if ( uri != null && ! uri . ends With ( _ STR ) ) { uri += _ STR ; } return uri ; }
static public void sync Classification Block2 Summary ( int data Set Id , int total Data Sets ,  IClassification Block classification Block ,  Data Table table ) { final  Map <  Integer ,  Integer [ ] > class Id2count = new  Hash Map < > ( ) ; table . set Class2 Counts ( classification Block . get Name ( ) , class Id2count ) ; for (  Integer class Id : classification Block . get Key Set ( ) ) { int sum = classification Block . get Weighted Sum ( class Id ) ; if ( sum > _ NUM ) { if ( class Id2count . get ( class Id ) == null ) class Id2count . put ( class Id , new  Integer [ total Data Sets ] ) ;  Integer total = class Id2count . get ( class Id ) [ data Set Id ] ; if ( total != null ) class Id2count . get ( class Id ) [ data Set Id ] = total + sum ; else class Id2count . get ( class Id ) [ data Set Id ] = sum ; } } if ( table . get Additional Reads ( ) > _ NUM ) { if ( class Id2count . get (  Id Mapper .  NOHITS_ ID ) == null ) class Id2count . put (  Id Mapper .  NOHITS_ ID , new  Integer [ total Data Sets ] ) ;  Integer total = class Id2count . get (  Id Mapper .  NOHITS_ ID ) [ data Set Id ] ; if ( total != null ) class Id2count . get (  Id Mapper .  NOHITS_ ID ) [ data Set Id ] = total + ( int ) table . get Additional Reads ( ) ; else class Id2count . get (  Id Mapper .  NOHITS_ ID ) [ data Set Id ] = ( int ) table . get Additional Reads ( ) ; } }
public static  String convert To ARGB ( int color ) {  String alpha =  Integer . to Hex String (  Color . alpha ( color ) ) ;  String red =  Integer . to Hex String (  Color . red ( color ) ) ;  String green =  Integer . to Hex String (  Color . green ( color ) ) ;  String blue =  Integer . to Hex String (  Color . blue ( color ) ) ; if ( alpha . length ( ) == _ NUM ) { alpha = _ STR + alpha ; } if ( red . length ( ) == _ NUM ) { red = _ STR + red ; } if ( green . length ( ) == _ NUM ) { green = _ STR + green ; } if ( blue . length ( ) == _ NUM ) { blue = _ STR + blue ; } return _ STR + alpha + red + green + blue ; }
public final void stop ( ) { stop ( _ BOOL ) ; }
protected  Date Time Data parse (  String str ) throws  Schema Date Time Exception {  Date Time Data date = new  Date Time Data ( str , this ) ; int len = str . length ( ) ; date . year =  YEAR ; if ( str . char At ( _ NUM ) != _ STR || str . char At ( _ NUM ) != _ STR ) { throw new  Schema Date Time Exception ( _ STR + str ) ; } date . month = parse Int ( str , _ NUM , _ NUM ) ; int start = _ NUM ; if ( str . char At ( start ++ ) != _ STR ) { throw new  Schema Date Time Exception ( _ STR + str ) ; } date . day = parse Int ( str , start , start + _ NUM ) ; if (  MONTHDAY_ SIZE < len ) { if ( ! is Next Char UTCSign ( str ,  MONTHDAY_ SIZE , len ) ) { throw new  Schema Date Time Exception ( _ STR + str ) ; } else { get Time Zone ( str , date ,  MONTHDAY_ SIZE , len ) ; } } validate Date Time ( date ) ; save Unnormalized ( date ) ; if ( date . utc != _ NUM && date . utc != _ STR ) { normalize ( date ) ; } date . position = _ NUM ; return date ; }
public synchronized void transition (  State new State ) throws  Illegal State Exception { if ( transitions . contains Entry ( current State , new State ) ) { current State = new State ; } else { throw new  Illegal State Exception (  String . format (  Locale .  US , _ STR , current State , new State ) ) ; } }
public boolean equals (  Object object ) { if ( this == object ) { return _ BOOL ; } else if ( object == null || get Class ( ) != object . get Class ( ) ) { return _ BOOL ; } return principal . equals ( object . to String ( ) ) ; }
void on Exception (  JMSException j E ) { if ( error Handler != null ) { if ( _logger . is Loggable (  Level .  FINE ) ) { _logger . fine ( _ STR + cnx Key ) ; } error Handler . on Exception ( j E ) ; } else { if ( _logger . is Loggable (  Level .  FINE ) ) { _logger . fine ( _ STR + cnx Key ) ; } } }
public void terminate ( ) throws  IOException { try { try { synchronized ( m Jobs ) { while ( m Busy || ! m Jobs . is Empty ( ) ) { m Jobs . wait (  NOT_ DONE_ SLEEP_ TIME ) ; } } } catch ( final  Interrupted Exception e ) {  Program State . set Abort ( ) ; } finally { shutdown ( ) ; } rethrow ( ) ; } finally {  Program State . clear Abort ( ) ; try { synchronized ( m Queue Thread ) { while ( ! m Queue Done ) { m Queue Thread . wait (  NOT_ DONE_ SLEEP_ TIME ) ; } } } catch ( final  Interrupted Exception e ) { } } }
public  Text Component ( ) { }
public  Str Builder insert ( int index , final boolean value ) { validate Index ( index ) ; if ( value ) { ensure Capacity ( size + _ NUM ) ;  System . arraycopy ( buffer , index , buffer , index + _ NUM , size - index ) ; buffer [ index ++ ] = _ STR ; buffer [ index ++ ] = _ STR ; buffer [ index ++ ] = _ STR ; buffer [ index ] = _ STR ; size += _ NUM ; } else { ensure Capacity ( size + _ NUM ) ;  System . arraycopy ( buffer , index , buffer , index + _ NUM , size - index ) ; buffer [ index ++ ] = _ STR ; buffer [ index ++ ] = _ STR ; buffer [ index ++ ] = _ STR ; buffer [ index ++ ] = _ STR ; buffer [ index ] = _ STR ; size += _ NUM ; } return this ; }
public static int dial Down Heat (  Mounted weapon ,  Weapon Type wtype ) { return  Compute . dial Down Heat ( weapon , wtype , _ NUM ) ; }
public  String encoded ( ) {  String Builder buf = new  String Builder ( ) ; buf . append ( get Name ( ) ) ; buf . append ( _ STR ) ; buf . append ( get Value ( ) ) ; if ( get Operator ( ) !=  Operator .  HAS ) { buf . append ( _ STR ) ; buf . append ( get Operator ( ) ) ; } return buf . to String ( ) ; }
final  V do Remove (  Object key ,  Object value ) { if ( key == null ) throw new  Null Pointer Exception ( ) ;  Comparator < ? super  K > cmp = comparator ; outer : for ( ; ; ) { for (  Node <  K ,  V > b = find Predecessor ( key , cmp ) , n = b . next ; ; ) {  Object v ; int c ; if ( n == null ) break outer ;  Node <  K ,  V > f = n . next ; if ( n != b . next ) break ; if ( ( v = n . value ) == null ) { n . help Delete ( b , f ) ; break ; } if ( b . value == null || v == n ) break ; if ( ( c = cpr ( cmp , key , n . key ) ) < _ NUM ) break outer ; if ( c > _ NUM ) { b = n ; n = f ; continue ; } if ( value != null && ! value . equals ( v ) ) break outer ; if ( ! n . cas Value ( v , null ) ) break ; if ( ! n . append Marker ( f ) || ! b . cas Next ( n , f ) ) find Node ( key ) ; else { find Predecessor ( key , cmp ) ; if ( head . right == null ) try Reduce Level ( ) ; } @  Suppress Warnings ( _ STR )  V vv = (  V ) v ; return vv ; } } return null ; }
public static final  Index create Test Index All Field Types ( ) {  Index index = new  Index ( _ STR ) ; index . set Table (  DB , _ STR ) ;  Array List <  Index Field > fields = new  Array List < > ( ) ; fields . add ( new  Index Field ( _ STR ,  Field Data Type .  UUID ) ) ; fields . add ( new  Index Field ( _ STR ,  Field Data Type .  TEXT ) ) ; fields . add ( new  Index Field ( _ STR ,  Field Data Type .  INTEGER ) ) ; fields . add ( new  Index Field ( _ STR ,  Field Data Type .  DOUBLE ) ) ; fields . add ( new  Index Field ( _ STR ,  Field Data Type .  BINARY ) ) ; fields . add ( new  Index Field ( _ STR ,  Field Data Type .  BOOLEAN ) ) ; fields . add ( new  Index Field ( _ STR ,  Field Data Type .  DATE_ TIME ) ) ; fields . add ( new  Index Field ( _ STR ,  Field Data Type .  LONG ) ) ; index . set Fields ( fields ) ; index . is Unique ( _ BOOL ) ; return index ; }
public void open ( ) { open ( new  Config ( ) ) ; }
public static  String hex To String ( final  String data ) throws  Conversion Exception { try { return  Conversion Utils . array To String (  Hex . decode Hex ( data . to Char Array ( ) ) ) ; } catch (  Decoder Exception e ) { throw new  Conversion Exception ( _ STR , e ) ; } }
private boolean advance Api Between Or Later (  Tree Set <  Area Panel Info > sorted Api Tree ,  Area Panel Info api , int min Time , int max Time , int end Time ) { sorted Api Tree . remove ( api ) ;  Area Panel ap = api . ap ( ) ;  Time Tree root Tt = ap . get Time Tree ( ) ;  Time Tree tt = root Tt . get Encompassig Time Tree Or Max Time Tree Before Time ( max Time , _ BOOL ) ; if ( tt == null || tt . get Min Time Secs ( ) < min Time ) { tt = root Tt . get Encompassig Time Tree Or Min Time Tree After Time ( max Time , _ BOOL ) ; if ( api . set Tt ( tt , end Time ) ) { sorted Api Tree . add ( api ) ; } return _ BOOL ; } else { if ( api . set Tt ( tt , end Time ) ) sorted Api Tree . add ( api ) ; return _ BOOL ; } }
@  Request Mapping ( value = { _ STR , _ STR } , method =  Request Method .  POST ) @  Response Body public  Rest Wrapper update ( @  Model Attribute ( _ STR ) @  Valid  Process Type process Type ,  Binding Result binding Result ,  Principal principal ) {  Rest Wrapper rest Wrapper = null ; if ( binding Result . has Errors ( ) ) {  Binding Result Error binding Result Error = new  Binding Result Error ( ) ; return binding Result Error . error Message ( binding Result ) ; } try { com . wipro . ats . bdre . md . dao . jpa .  Process Type jpa Process Type = new com . wipro . ats . bdre . md . dao . jpa .  Process Type ( ) ; jpa Process Type . set Process Type Id ( process Type . get Process Type Id ( ) ) ; jpa Process Type . set Parent Process Type Id ( process Type . get Parent Process Type Id ( ) ) ; jpa Process Type . set Process Type Name ( process Type . get Process Type Name ( ) ) ; process Type DAO . update ( jpa Process Type ) ; rest Wrapper = new  Rest Wrapper ( process Type ,  Rest Wrapper .  OK ) ;  LOGGER . info ( _ STR + process Type . get Process Type Id ( ) + _ STR + principal . get Name ( ) + process Type ) ; } catch (  Metadata Exception e ) {  LOGGER . error ( e ) ; rest Wrapper = new  Rest Wrapper ( e . get Message ( ) ,  Rest Wrapper .  ERROR ) ; } return rest Wrapper ; }
private void send Request Option ( ) throws  IOException {  String request = _ STR + m Parameters . host + _ STR + m Parameters . port + m Parameters . path + _ STR + add Headers ( ) ;  Log . i (  TAG , request . substring ( _ NUM , request . index Of ( _ STR ) ) ) ; m Output Stream . write ( request . get Bytes ( _ STR ) ) ; m Output Stream . flush ( ) ;  Response . parse Response ( m Buffered Reader ) ; }
@  Override public  Result do Comparison Test ( final  Properties properties ) throws  Exception { final long timeout =  Long . parse Long ( properties . get Property (  Test Options .  TIMEOUT ) ) ; final int nclients =  Integer . parse Int ( properties . get Property (  Test Options .  NCLIENTS ) ) ; final int ntrials =  Integer . parse Int ( properties . get Property (  Test Options .  NTRIALS ) ) ; final int key Len =  Integer . parse Int ( properties . get Property (  Test Options .  KEYLEN ) ) ; final int nops =  Integer . parse Int ( properties . get Property (  Test Options .  NOPS ) ) ; final double abort Rate =  Double . parse Double ( properties . get Property (  Test Options .  ABORT_ RATE ) ) ; final  Result result = do Concurrent Client Test ( journal , timeout , nclients , ntrials , key Len , nops , abort Rate ) ; return result ; }
public static void thread Dump ( ) {  LOG . error ( _ STR ) ; final  Thread MXBean threads =  Management Factory . get Thread MXBean ( ) ; long [ ] thread Ids = threads . get All Thread Ids ( ) ;  Print Writer print Writer = null ; try { print Writer = new  Print Writer ( new  File Writer (  THREAD_ DUMP_ FILE_ PATH , _ BOOL ) ) ; print Writer . println ( _ STR + new  Date ( ) ) ; for ( long thread Id : thread Ids ) {  Thread Info thread Info = threads . get Thread Info ( thread Id , _ NUM ) ; print Writer . println ( _ STR + thread Info . get Thread Name ( ) + _ STR + thread Info . get Blocked Time ( ) + _ STR + thread Info . get Blocked Count ( ) + _ STR + thread Info . get Lock Name ( ) + _ STR + thread Info . get Waited Count ( ) + _ STR + thread Info . get Waited Time ( ) + _ STR + thread Info . is Suspended ( ) ) ;  Stack Trace Element [ ] stack Trace = thread Info . get Stack Trace ( ) ; for (  Stack Trace Element element : stack Trace ) { print Writer . println ( element ) ; } } } catch (  IOException ioe ) { ioe . print Stack Trace ( ) ; } finally { if ( print Writer != null ) { try { print Writer . flush ( ) ; print Writer . close ( ) ; } catch (  Exception e2 ) { } } } }
public void add Delete (  IResource delete ) { if ( f Delete == null ) f Delete = new  Array List ( _ NUM ) ; f Delete . add ( delete ) ; if ( f Ignore Count == _ NUM ) { internal Add ( new  Delete Description ( delete ) ) ; } }
public static double min ( final double a , final double b ) { if ( a > b ) { return b ; } if ( a < b ) { return a ; } if ( a != b ) { return  Double .  Na N ; } long bits =  Double . double To Raw Long Bits ( a ) ; if ( bits == _ NUM ) { return a ; } return b ; }
@  Override public void write External (  Object Output out ) throws  IOException { super . write External ( out ) ; out . write Object ( knn Distance ) ; }
public void add (  String method Name ,  List <  Expression > parameters , boolean is Property ) { chain . add ( new  Dot Expression Item ( method Name , parameters , is Property ) ) ; }
public static void reset ( ) { thread Local . remove ( ) ; }
private void commercial Button Clicked (  String command ) { int length =  Integer . parse Int ( command ) ;  JToggle Button button = commercial Buttons . get ( length ) ; if ( button . is Selected ( ) ) { if ( scheduled Commercial Time == _ NUM ) { run Commercial ( length ) ; } else { scheduled Commercial Length = length ; update ( ) ; } } else { scheduled Commercial Time = _ NUM ; set Commercial Result ( _ STR ) ; } }
public static int hash ( double value ) { long bits =  Double . double To Long Bits ( value ) ; return ( int ) ( bits ^ ( bits > > > _ NUM ) ) ; }
public void subscribe (  AWSIot Message message ) throws  AWSIot Exception { try { subscribe Topic ( message ) ; } catch (  Aws Iot Retryable Exception e ) { if ( client . get Max Offline Queue Size ( ) > _ NUM && subscribe Queue . size ( ) < client . get Max Offline Queue Size ( ) ) { subscribe Queue . add ( message ) ; } else {  LOGGER . info ( _ STR + message . get Topic ( ) ) ; throw new  AWSIot Exception ( e ) ; } } }
public static boolean is Solaris ( ) { return os Name . index Of ( _ STR ) > - _ NUM || os Name . index Of ( _ STR ) > - _ NUM ; }
public static void close Silently (  Connection conn ) { if ( conn != null ) { try { conn . close ( ) ; } catch (  SQLException e ) { } } }
public boolean ends With (  Name n ) { if ( n instanceof  Composite Name ) { return ( impl . ends With ( n . size ( ) , n . get All ( ) ) ) ; } else { return _ BOOL ; } }
private int calculate Total Width ( float star Size , int number Of Stars , float stars Separation , boolean padding ) { return  Math . round ( star Size * number Of Stars + stars Separation * ( number Of Stars - _ NUM ) ) + ( padding ? get Padding Left ( ) + get Padding Right ( ) : _ NUM ) ; }
@  Suppress Warnings ( { _ STR , _ STR } ) public static boolean is Regex (  String s , int groups ) {  Pattern p ; try { p =  Pattern . compile ( s ) ; } catch (  Pattern Syntax Exception e ) { return _ BOOL ; } return get Group Count ( p ) >= groups ; }
public void flush ( ) { clear Buffer ( ) ; try { out . flush ( ) ; } catch (  IOException e ) { e . print Stack Trace ( ) ; } }
public final void to String (  String Builder builder ) { builder . append ( get Name ( ) ) ; }
public static  Structured Translation from Empty Output ( final  Sentence source Sentence ) { return new  Structured Translation ( source Sentence , _ STR , empty List ( ) , _ NUM , empty List ( ) , empty Map ( ) , _ NUM ) ; }
public void remove Temporary Maps (  Bit Field object Ids ) { for (  String map Name : store . get Map Names ( ) ) { if ( map Name . starts With ( _ STR ) ) {  MVMap < ? , ? > map = store . open Map ( map Name ) ; store . remove Map ( map ) ; } else if ( map Name . starts With ( _ STR ) || map Name . starts With ( _ STR ) ) { int id =  Integer . parse Int ( map Name . substring ( _ NUM + map Name . index Of ( _ STR ) ) ) ; if ( ! object Ids . get ( id ) ) {  Value Data Type key Type = new  Value Data Type ( null , null , null ) ;  Value Data Type value Type = new  Value Data Type ( null , null , null ) ;  Transaction t = transaction Store . begin ( ) ;  Transaction Map < ? , ? > m = t . open Map ( map Name , key Type , value Type ) ; transaction Store . remove Map ( m ) ; t . commit ( ) ; } } } }
public  Builder histogram Quantiles ( double ... quantiles ) { histogram Percentiles = new  Hash Set < > ( ) ; for ( double q : quantiles ) { histogram Percentiles . add ( new  Percentile ( q ) ) ; } return this ; }
@  Override protected  Date Time Data parse (  String str ) throws  Schema Date Time Exception {  Date Time Data date = new  Date Time Data ( str , this ) ; int len = str . length ( ) ; int end = get Date ( str , _ NUM , len , date ) ; parse Time Zone ( str , end , len , date ) ; validate Date Time ( date ) ; save Unnormalized ( date ) ; if ( date . utc != _ NUM && date . utc != _ STR ) { normalize ( date ) ; } return date ; }
public static  Map append Element To Map (  String key ,  Set values ,  Map to Map ) { if ( ( key != null ) && ( values != null ) && ( ! values . is Empty ( ) ) && ( to Map != null ) ) {  Set previous Values = (  Set ) to Map . get ( key ) ; if ( ( previous Values != null ) && ( ! previous Values . is Empty ( ) ) ) { previous Values . add All ( values ) ; } else { to Map . put ( key , values ) ; } } return to Map ; }
public static  Commit Version Info build (  Index Commit commit ) { long generation = commit . get Generation ( ) ; long version = _ NUM ; try { final  Map <  String ,  String > commit Data = commit . get User Data ( ) ;  String commit Time = commit Data . get (  Solr Index Writer .  COMMIT_ TIME_ MSEC_ KEY ) ; if ( commit Time != null ) { try { version =  Long . parse Long ( commit Time ) ; } catch (  Number Format Exception e ) {  LOG . warn ( _ STR + commit Time , e ) ; } } } catch (  IOException e ) {  LOG . warn ( _ STR + commit , e ) ; } return new  Commit Version Info ( generation , version ) ; }
public void add Sequence Element (  Sequence Element elem ) { for (  Fragment comment : open Fragments ) { comment . add Element ( elem ) ; } for (  Fragment comment : closing Fragments ) { comment . add Element ( elem ) ; } }
private final void _write String Segments ( char [ ] cbuf , int offset , int total Len ) throws  IOException ,  Json Generation Exception { do { int len =  Math . min ( _output Max Contiguous , total Len ) ; if ( ( _output Tail + len ) > _output End ) { _flush Buffer ( ) ; } _write String Segment ( cbuf , offset , len ) ; offset += len ; total Len -= len ; } while ( total Len > _ NUM ) ; }
public final boolean has Tag (  Tag t ) { return all Tags . contains ( t ) ; }
public double do Operation ( ) throws  Operator Failed Exception { double logq ; final double delta = get Delta ( ) ; final  Node Ref root = tree . get Root ( ) ;  Node Ref node ; do { node = tree . get Node (  Math Utils . next Int ( tree . get Node Count ( ) ) ) ; } while ( node == root ) ; final  Node Ref parent = tree . get Parent ( node ) ; final  Node Ref sibling = get Other Child ( tree , parent , node ) ; final  Node Ref grand Parent = tree . get Parent ( parent ) ; final  Map <  Node Ref ,  Double > destinations = get Destinations ( node , parent , sibling , delta ) ; final  List <  Node Ref > destination Nodes = new  Array List <  Node Ref > ( destinations . key Set ( ) ) ; int r =  Math Utils . next Int ( destinations . size ( ) ) ; double forward Probability = _ NUM / destinations . size ( ) ; final  Node Ref j = destination Nodes . get ( r ) ; final double new Height = destinations . get ( j ) ; final  Node Ref j Parent = tree . get Parent ( j ) ; if ( j Parent != null && new Height > tree . get Node Height ( j Parent ) ) { throw new  Illegal Argument Exception ( _ STR ) ; } if ( new Height < tree . get Node Height ( j ) ) { throw new  Illegal Argument Exception ( _ STR ) ; } tree . begin Tree Edit ( ) ; if ( j == parent || j Parent == parent ) { } else { if ( grand Parent == null ) { tree . remove Child ( parent , sibling ) ; tree . set Root ( sibling ) ; } else { tree . remove Child ( parent , sibling ) ; tree . remove Child ( grand Parent , parent ) ; tree . add Child ( grand Parent , sibling ) ; } if ( j Parent == null ) { tree . add Child ( parent , j ) ; tree . set Root ( parent ) ; } else { tree . remove Child ( j Parent , j ) ; tree . add Child ( parent , j ) ; tree . add Child ( j Parent , parent ) ; } } tree . end Tree Edit ( ) ; tree . set Node Height ( parent , new Height ) ; if ( tree . get Parent ( parent ) != null && new Height > tree . get Node Height ( tree . get Parent ( parent ) ) ) { throw new  Illegal Argument Exception ( _ STR ) ; } if ( new Height < tree . get Node Height ( node ) ) { throw new  Illegal Argument Exception ( _ STR ) ; } if ( new Height < tree . get Node Height ( get Other Child ( tree , parent , node ) ) ) { throw new  Illegal Argument Exception ( _ STR ) ; } final  Map <  Node Ref ,  Double > reverse Destinations = get Destinations ( node , parent , get Other Child ( tree , parent , node ) , delta ) ; double reverse Probability = _ NUM / reverse Destinations . size ( ) ; logq =  Math . log ( reverse Probability ) -  Math . log ( forward Probability ) ; return logq ; }
public static  String to String ( int [ ] values ) {  String result = _ STR ; for ( int value : values ) { result += value + _ STR ; } if (  String Utils . is Not Blank ( result ) ) { result = result . substring ( _ NUM , result . length ( ) - _ NUM ) ; } return result ; }
public boolean is Set Status ( ) { return __isset_bit_vector . get ( __ STATUS_ ISSET_ ID ) ; }
public void add Capabilities Listener (  Set <  Contact Id > contacts ,  Capabilities Listener listener ) throws  Rcs Service Not Available Exception ,  Rcs Generic Exception { if ( m Api == null ) { throw new  Rcs Service Not Available Exception ( ) ; } if ( contacts == null || contacts . is Empty ( ) ) { throw new  Rcs Illegal Argument Exception ( _ STR ) ; } try {  ICapabilities Listener rcs Listener = new  Capabilities Listener Impl ( listener ) ; m Capabilities Listeners . put ( listener , new  Weak Reference < > ( rcs Listener ) ) ; for (  Contact Id contact : contacts ) { m Api . add Capabilities Listener2 ( contact , rcs Listener ) ; } } catch (  Exception e ) {  Rcs Illegal Argument Exception . assert Exception ( e ) ; throw new  Rcs Generic Exception ( e ) ; } }
String char To String ( char c ) { if ( c < _ STR || c > _ NUM ) { return _ STR + ( int ) c ; } return  String . value Of ( c ) ; }
public static final  Index Created Event create Test Index Creation Status ( ) {  Index Created Event to Return = new  Index Created Event (  UUID . random UUID ( ) , new  Date ( ) , new  Date ( ) , create Test Index One Field ( ) , _ NUM , _ NUM ) ; to Return . calculate Values ( ) ; return to Return ; }
public void add (  Rule rule ) { rules . add ( rule ) ; }
@  Override public boolean event Generatable (  String event Name ) { if ( event Name . equals ( _ STR ) ) { return _ BOOL ; } return _ BOOL ; }
byte [ ] generate Secure Random Bytes ( int size ) {  Secure Random secure Random = new  Secure Random ( ) ; byte [ ] random Bytes = new byte [ size ] ; secure Random . next Bytes ( random Bytes ) ; return random Bytes ; }
@  Override public int hash Code ( ) { int hash = ( ( time . to Second Of Day ( ) + ( time End Of Day ? _ NUM : _ NUM ) ) << _ NUM ) + ( month . ordinal ( ) << _ NUM ) + ( ( dom + _ NUM ) << _ NUM ) + ( ( dow == null ? _ NUM : dow . ordinal ( ) ) << _ NUM ) + ( time Definition . ordinal ( ) ) ; return hash ^ standard Offset . hash Code ( ) ^ offset Before . hash Code ( ) ^ offset After . hash Code ( ) ; }
public void draw Bars On Graph (  Graphics2 D g2d ,  Array List <  Comparable Label > ordered Date Set ,  Hash Map <  Comparable Label ,  Integer [ ] > bar Data Points , long y Max Mark ) { int section Width = this . graph Width / ordered Date Set . size ( ) ; int x Offset = section Width / _ NUM ; int y Value ; float y Offset Perc ; int number Of Bars = bar Data Points . get ( ordered Date Set . get ( _ NUM ) ) . length ; int bar Width = section Width / ( number Of Bars + _ NUM ) ; for ( int date Pos = _ NUM ; date Pos < ordered Date Set . size ( ) ; date Pos ++ ) { for ( int bar Number = _ NUM ; bar Number < number Of Bars ; bar Number ++ ) { y Value = bar Data Points . get ( ordered Date Set . get ( date Pos ) ) [ bar Number ] ; y Offset Perc = y Value / ( float ) y Max Mark ; int x Left Bar = this . graph Left + date Pos * section Width + bar Width / _ NUM + bar Width * bar Number ; draw Bar ( g2d ,  Math . round ( this . graph Height * y Offset Perc ) , bar Width , x Left Bar , this . graph Bottom , this . bar Colors [ bar Number ] ) ; if (  Math . round ( this . graph Height * y Offset Perc ) == _ NUM && y Value != _ NUM ) { g2d . set Color ( this . bar Colors [ bar Number ] ) ; g2d . draw Line ( x Left Bar , this . graph Bottom , x Left Bar + bar Width , this . graph Bottom ) ; } } } }
final public void println (  Object v ) {  Writer out = this . out ; if ( out == null ) return ; try { if ( v == null ) out . write ( _null Chars , _ NUM , _null Chars . length ) ; else {  String s = v . to String ( ) ; out . write ( s , _ NUM , s . length ( ) ) ; } out . write ( _newline , _ NUM , _newline . length ) ; } catch (  IOException e ) { log . log (  Level .  FINE , e . to String ( ) , e ) ; } }
private  URI canonicalize (  String uri String ) throws  URISyntax Exception { if ( ( uri String == null ) || ( uri String . compare To ( _ STR ) == _ NUM ) ) { uri String = _ STR ; return new  URI ( uri String ) ; }  URI u = new  URI ( uri String ) ; if ( u . is Absolute ( ) ) { if ( u . is Opaque ( ) ) {  String scheme = u . get Scheme ( ) ;  String ssp = u . get Scheme Specific Part ( ) ;  String frag = u . get Fragment ( ) ;  URI u2 = null ; int c1index = uri String . index Of ( _ STR ) ; int c2index = uri String . last Index Of ( _ STR ) ; if ( c2index != c1index ) { if ( frag == null ) { u2 = new  URI ( scheme + _ STR + ssp ) ; } else { u2 = new  URI ( scheme + _ STR + ssp + _ STR + frag ) ; } return u2 ; } u2 = new  URI ( _ STR + uri String ) ; return u2 ; } else { return u ; } } else {  String ssp = u . get Scheme Specific Part ( ) ; if ( ssp . starts With ( _ STR ) ) { return u ; } else { return new  URI ( _ STR + uri String ) ; } } }
private  Rect calc Bounds ( int index ,  Paint paint ) {  Rect bounds = new  Rect ( ) ;  Char Sequence title = get Title ( index ) ; bounds . right = ( int ) paint . measure Text ( title , _ NUM , title . length ( ) ) ; bounds . bottom = ( int ) ( paint . descent ( ) - paint . ascent ( ) ) ; return bounds ; }
public void write To (  Output Stream os ) throws  IOException {  Data Output Stream dos = new  Data Output Stream ( os ) ; dos . write Int (  N ) ; dos . write Int ( q ) ; dos . write Int ( d ) ; dos . write Int ( d1 ) ; dos . write Int ( d2 ) ; dos . write Int ( d3 ) ; dos . write Int (  B ) ; dos . write Double ( beta ) ; dos . write Double ( norm Bound ) ; dos . write Int ( sign Fail Tolerance ) ; dos . write Int ( bits F ) ; dos . write UTF ( hash Alg . get Algorithm Name ( ) ) ; }
public void add Import ( @  Not Null  Psi Element importable , @  Not Null  Psi File System Item file , @  Nullable  Qualified Name path ) { my Imports . add ( new  Import Candidate Holder ( importable , file , null , path ) ) ; }
private static void draw Triangle Up (  Graphics gx , double x , double y , int size ) { gx . draw Line ( ( int ) ( x ) , ( int ) ( y - size ) , ( int ) ( x - size ) , ( int ) ( y + size ) ) ; gx . draw Line ( ( int ) ( x - size ) , ( int ) ( y + size ) , ( int ) ( x + size ) , ( int ) ( y + size ) ) ; gx . draw Line ( ( int ) ( x + size ) , ( int ) ( y + size ) , ( int ) ( x ) , ( int ) ( y - size ) ) ; }
public  Weak Loader Listener (  Env Loader Listener listener ) { _listener Ref = new  Weak Reference < > ( listener ) ; }
private  Object [ ] unmarshal Parameters Unchecked (  Method method ,  Object Input in ) throws  IOException ,  Class Not Found Exception {  Class < ? > [ ] types = method . get Parameter Types ( ) ;  Object [ ] params = new  Object [ types . length ] ; for ( int i = _ NUM ; i < types . length ; i ++ ) { params [ i ] = unmarshal Value ( types [ i ] , in ) ; } return params ; }
private void load Data From Service ( ) {  List <  Invocation Sequence Data > invoc Data ; if ( ! auto Update ) { if ( template . get Method Ident ( ) !=  Id Definition .  ID_ NOT_ USED ) { invoc Data = data Access Service . get Invocation Sequence Overview ( template . get Platform Ident ( ) , template . get Method Ident ( ) , limit , from Date , to Date , result Comparator ) ; } else { invoc Data = data Access Service . get Invocation Sequence Overview ( template . get Platform Ident ( ) , limit , from Date , to Date , result Comparator ) ; } } else { if ( template . get Method Ident ( ) !=  Id Definition .  ID_ NOT_ USED ) { invoc Data = data Access Service . get Invocation Sequence Overview ( template . get Platform Ident ( ) , template . get Method Ident ( ) , limit , result Comparator ) ; } else { invoc Data = data Access Service . get Invocation Sequence Overview ( template . get Platform Ident ( ) , limit , result Comparator ) ; } } invocation Sequence Data . clear ( ) ; if ( ! invoc Data . is Empty ( ) ) { invocation Sequence Data . add All ( invoc Data ) ; } }
void draw Letter (  Graphics g , char letter , int ax , int ay , int aw , int ah , float align , int index ) {  String str = format Item Num ( index , letter ) ; str = is Left To Right ? str + _ STR : _ STR + str ;  Font Metrics fm =  Swing Utilities2 . get Font Metrics ( null , g ) ; int stringwidth =  Swing Utilities2 . string Width ( null , fm , str ) ; int gap = is Left To Right ? - ( stringwidth + bulletgap ) : ( aw + bulletgap ) ; int x = ax + gap ; int y =  Math . max ( ay + fm . get Ascent ( ) , ay + ( int ) ( ah * align ) ) ;  Swing Utilities2 . draw String ( null , g , str , x , y ) ; }
public int sync (  String entity Id ,  Collection <  Statement > statements ,  Collection <  String > value List ) { long start =  System . current Time Millis ( ) ; int modified = execute ( _ STR ,  UPDATE_ COUNT_ RESPONSE , get Sync Query ( entity Id , statements , value List ) ) ; log . debug ( _ STR , entity Id ,  System . current Time Millis ( ) - start , modified ) ; return modified ; }
public static  Properties read Properties (  Class clazz ) { return read Properties ( clazz . get Name ( ) ) ; }
public static  Buffered Image resize Image (  Image image ) {  Buffered Image result = new  Buffered Image ( _ NUM , _ NUM ,  Buffered Image .  TYPE_ INT_ ARGB ) ;  Graphics2 D graphics = result . create Graphics ( ) ; graphics . draw Image ( image , _ NUM , _ NUM , _ NUM , _ NUM , null ) ; graphics . dispose ( ) ; return result ; }
public final boolean is Cancelled ( ) { return cancelled ; }
public void add (  Directed Edge de ) { out Edges . add ( de ) ; sorted = _ BOOL ; }
@  Override protected void on Message On Producer Thread (  T msg ) { synchronized ( _lock ) { if ( _pending == null ) { _pending = new  Array List < > ( ) ; _queue . schedule ( _flush Runnable , _interval , _time Unit ) ; } _pending . add ( msg ) ; } }
public static  String format Date (  Date date ) { return m Simple Date Format . format ( date ) ; }
private boolean is In Thumb Range ( float touch X , double normalized Thumb Value ) { return  Math . abs ( touch X - normalized To Screen ( normalized Thumb Value ) ) <= thumb Half Width ; }
public boolean cleanup ( ) throws  IOException {  File System file System =  File System . get ( config ) ; boolean success = _ BOOL ; for (  Path file : files ) { success &= file System . delete ( file , _ BOOL ) ; } return success ; }
public boolean can Be Negative ( ) { boolean negative = _ BOOL ; return negative ; }
private  Dispatcher Task dequeue Next Task (  String queue Name ) { synchronized ( sync Root ) {  Queue <  Dispatcher Task > queue = task Queues Map . get ( queue Name ) ; if ( queue == null ) { return null ; }  Dispatcher Task dispatcher Task = queue . poll ( ) ; if ( queue . is Empty ( ) ) { task Queues Map . remove ( queue Name ) ; } return dispatcher Task ; } }
public void dump (  Writer writer ) {  Decimal Format number Format = new  Decimal Format ( ) ; number Format . set Maximum Fraction Digits ( _ NUM ) ; number Format . set Minimum Fraction Digits ( _ NUM ) ;  Print Writer pw = new  Print Writer ( new  Buffered Writer ( writer ) ) ; if ( get Number Of Frames ( ) == _ NUM ) { pw . println ( _ STR ) ; pw . println ( _ STR + get Number Of Frames ( ) ) ; pw . flush ( ) ; return ; } pw . println ( _ STR ) ; pw . println ( _ STR + get Number Of Frames ( ) ) ; pw . println ( _ STR + get Number Of Channels ( ) ) ; pw . println ( _ STR + get Number Of Samples ( ) ) ; pw . println ( _ STR + sample Rate ) ; pw . println ( _ STR + number Format . format ( lpc Minimum ) ) ; pw . println ( _ STR + number Format . format ( lpc Range ) ) ; pw . println ( _ STR + residual Fold ) ; pw . println ( _ STR + number Format . format (  POST_ EMPHASIS ) ) ; int i ; pw . print ( _ STR ) ; for ( i = _ NUM ; i < get Number Of Frames ( ) ; i ++ ) { pw . print ( times [ i ] + _ STR ) ; } pw . print ( _ STR ) ; for ( i = _ NUM ; i < get Number Of Frames ( ) ; i ++ ) { short [ ] frame = get Frame ( i ) ; for ( int j = _ NUM ; j < frame . length ; j ++ ) { pw . print ( ( ( ( int ) frame [ j ] ) + _ NUM ) + _ STR ) ; } } pw . print ( _ STR ) ; for ( i = _ NUM ; i < get Number Of Frames ( ) ; i ++ ) { pw . print ( sizes [ i ] + _ STR ) ; } pw . print ( _ STR ) ; for ( i = _ NUM ; i < get Number Of Samples ( ) ; i ++ ) { if ( residuals [ i ] == _ NUM ) { pw . print ( _ NUM ) ; } else { pw . print ( ( ( ( int ) residuals [ i ] ) + _ NUM ) ) ; } pw . print ( _ STR ) ; pw . flush ( ) ; } pw . flush ( ) ; }
public boolean declares Field (  Field field ) { try { type . get Declared Field ( field . get Name ( ) ) ; return _ BOOL ; } catch (  No Such Field Exception e ) { return _ BOOL ; } }
public abstract  Shape Tile [ ] cutout (  Shape Tile p_shape ) ;
static double compute Desired Ellipsoid Magnitude ( final  Planet Model planet Model , final double z ) { return _ NUM /  Math . sqrt ( ( _ NUM - z * z ) * planet Model . inverse Ab Squared + z * z * planet Model . inverse CSquared ) ; }
private static  String quote Param (  String param ) { if ( param . contains ( _ STR ) || param . contains ( _ STR ) ) { throw new  Illegal Argument Exception ( _ STR ) ; } return _ STR + param + _ STR ; }
public void create Accrual Based Journal Entries And Reversals For Loan ( final  Office office , final  String currency Code , final  Integer account Type To Be Debited , final  Integer account Type To Be Credited , final  Long loan Product Id , final  Long payment Type Id , final  Long loan Id , final  String transaction Id , final  Date transaction Date , final  Big Decimal amount , final  Boolean is Reversal ) { int account Type To Debit Id = account Type To Be Debited ; int account Type To Credit Id = account Type To Be Credited ; if ( is Reversal ) { account Type To Debit Id = account Type To Be Credited ; account Type To Credit Id = account Type To Be Debited ; } create Journal Entries For Loan ( office , currency Code , account Type To Debit Id , account Type To Credit Id , loan Product Id , payment Type Id , loan Id , transaction Id , transaction Date , amount ) ; }
private void remove_concave_corners_at_close ( ) { add_corner_for_snap_angle ( ) ; if ( corner_list . size ( ) < _ NUM ) { return ; }  Pla Point Int [ ] corner_arr = new  Pla Point Int [ corner_list . size ( ) ] ;  Iterator <  Pla Point Int > it = corner_list . iterator ( ) ; for ( int i = _ NUM ; i < corner_arr . length ; ++ i ) { corner_arr [ i ] = it . next ( ) ; } int new_length = corner_arr . length ;  Pla Point Int first_corner = corner_arr [ _ NUM ] ;  Pla Point Int second_corner = corner_arr [ _ NUM ] ; while ( new_length > _ NUM ) {  Pla Point Int last_corner = corner_arr [ new_length - _ NUM ] ; if ( last_corner . side_of ( second_corner , first_corner ) !=  Pla Side .  ON_ THE_ LEFT ) { break ; } -- new_length ; } if ( new_length != corner_arr . length ) { corner_list = new java . util .  Linked List <  Pla Point Int > ( ) ; for ( int i = _ NUM ; i < new_length ; ++ i ) { corner_list . add ( corner_arr [ i ] ) ; } add_corner_for_snap_angle ( ) ; } }
public  Sensor create New Sensor (  String system Name ,  String user Name ) {  Sensor s ;  String s Name =  Serial Address . normalize System Name ( system Name ) ; if ( s Name . equals ( _ STR ) ) { log . error ( _ STR + system Name ) ; return null ; } s = get By System Name ( s Name ) ; if ( s != null ) { log . error ( _ STR + system Name ) ; return null ; }  String alt Name =  Serial Address . convert System Name To Alternate ( s Name ) ; s = get By System Name ( alt Name ) ; if ( s != null ) { log . error ( _ STR + system Name + _ STR + alt Name + _ STR ) ; return null ; } int bit =  Serial Address . get Bit From System Name ( s Name ) ; if ( ( bit <= _ NUM ) || ( bit >=  SENSORSPERNODE ) ) { log . error ( _ STR +  Integer . to String ( bit ) + _ STR +  Integer . to String (  SENSORSPERNODE - _ NUM ) ) ; return null ; } if ( user Name == null ) { s = new  Serial Sensor ( s Name ) ; } else { s = new  Serial Sensor ( s Name , user Name ) ; }  Serial Node node =  Serial Address . get Node From System Name ( s Name ) ; if ( node == null ) { log . warn ( _ STR + s Name + _ STR ) ; return s ; } node . register Sensor ( s , bit - _ NUM ) ; return s ; }
public static double [ ] logs2probs ( double [ ] a ) { double max = a [ max Index ( a ) ] ; double sum = _ NUM ; double [ ] result = new double [ a . length ] ; for ( int i = _ NUM ; i < a . length ; i ++ ) { result [ i ] =  Math . exp ( a [ i ] - max ) ; sum += result [ i ] ; } normalize ( result , sum ) ; return result ; }
public void draw (  Pla Point Float [ ] p_points , double p_half_width ,  Color p_color ,  Graphics p_g , double p_translucency_factor ) { if ( p_color == null ) return ;  Graphics2 D g2 = (  Graphics2 D ) p_g ;  Rectangle clip_shape = (  Rectangle ) p_g . get Clip ( ) ;  Shape Tile Box clip_box = coordinate_transform . screen_to_board ( clip_shape ) ; double scaled_width = coordinate_transform . board_to_screen ( p_half_width ) ; init_draw_graphics ( g2 , p_color , ( float ) scaled_width * _ NUM ) ; set_translucency ( g2 , p_translucency_factor ) ;  General Path draw_path = null ; if ( ! show_line_segments ) { draw_path = new  General Path ( ) ; } for ( int i = _ NUM ; i < ( p_points . length - _ NUM ) ; i ++ ) { if ( line_outside_update_box ( p_points [ i ] , p_points [ i + _ NUM ] , p_half_width + update_offset , clip_box ) ) { continue ; }  Point2 D p1 = coordinate_transform . board_to_screen ( p_points [ i ] ) ;  Point2 D p2 = coordinate_transform . board_to_screen ( p_points [ i + _ NUM ] ) ;  Line2 D line = new  Line2 D .  Double ( p1 , p2 ) ; if ( show_line_segments ) { g2 . draw ( line ) ; } else { draw_path . append ( line , _ BOOL ) ; } } if ( ! show_line_segments ) { g2 . draw ( draw_path ) ; } }
public void move To Next Date ( ) { if ( disable Auto Date Selection && user Selected Item == null ) return ; if ( selected Date Item != null ) {  Calendar cal =  Calendar . get Instance ( ) ; cal . set ( selected Date Item . get Year ( ) , selected Date Item . get Month ( ) , selected Date Item . get Day ( ) ) ; cal . add (  Calendar .  DATE , _ NUM ) ; if ( selected Date Item . get Month ( ) != cal . get (  Calendar .  MONTH ) ) { move To Next Month ( ) ; } else { selected Date Item . set Day ( cal . get (  Calendar .  DAY_ OF_ MONTH ) ) ; selected Date Item . set Month ( cal . get (  Calendar .  MONTH ) ) ; selected Date Item . set Year ( cal . get (  Calendar .  YEAR ) ) ; month View Pager Adapter . set Selected Item ( selected Date Item ) ; } } }
public boolean is Valid ( ) { return is Valid ( _ BOOL ) ; }
public void stop ( ) { throw new  Unsupported Operation Exception ( _ STR ) ; }
public static double magnitude ( final double x , final double y , final double z ) { return  Math . sqrt ( x * x + y * y + z * z ) ; }
public static boolean is Available ( ) { try { return create ( ) != null ; } catch (  Exception e ) { log . log (  Level .  FINEST , e . to String ( ) , e ) ; return _ BOOL ; } }
void bracket ( ) throws  RESyntax Exception { if ( idx >= len || pattern . char At ( idx ++ ) != _ STR ) { internal Error ( ) ; } if ( idx >= len || !  Character . is Digit ( pattern . char At ( idx ) ) ) { syntax Error ( _ STR ) ; }  String Buffer number = new  String Buffer ( ) ; while ( idx < len &&  Character . is Digit ( pattern . char At ( idx ) ) ) { number . append ( pattern . char At ( idx ++ ) ) ; } try { bracket Min =  Integer . parse Int ( number . to String ( ) ) ; } catch (  Number Format Exception e ) { syntax Error ( _ STR ) ; } if ( idx >= len ) { syntax Error ( _ STR ) ; } if ( pattern . char At ( idx ) == _ STR ) { idx ++ ; bracket Opt = _ NUM ; return ; } if ( idx >= len || pattern . char At ( idx ++ ) != _ STR ) { syntax Error ( _ STR ) ; } if ( idx >= len ) { syntax Error ( _ STR ) ; } if ( pattern . char At ( idx ) == _ STR ) { idx ++ ; bracket Opt = bracket Unbounded ; return ; } if ( idx >= len || !  Character . is Digit ( pattern . char At ( idx ) ) ) { syntax Error ( _ STR ) ; } number . set Length ( _ NUM ) ; while ( idx < len &&  Character . is Digit ( pattern . char At ( idx ) ) ) { number . append ( pattern . char At ( idx ++ ) ) ; } try { bracket Opt =  Integer . parse Int ( number . to String ( ) ) - bracket Min ; } catch (  Number Format Exception e ) { syntax Error ( _ STR ) ; } if ( bracket Opt < _ NUM ) { syntax Error ( _ STR ) ; } if ( idx >= len || pattern . char At ( idx ++ ) != _ STR ) { syntax Error ( _ STR ) ; } }
@  Override public void draw Item (  Graphics2 D g2 ,  Category Item Renderer State state ,  Rectangle2 D data Area ,  Category Plot plot ,  Category Axis domain Axis ,  Value Axis range Axis ,  Category Dataset dataset , int row , int column , int pass ) { int visible Row = state . get Visible Series Index ( row ) ; if ( visible Row < _ NUM ) { return ; }  Number data Value = dataset . get Value ( row , column ) ; if ( data Value == null ) { return ; } double value = data Value . double Value ( ) ;  Rectangle2 D adjusted = new  Rectangle2 D .  Double ( data Area . get X ( ) , data Area . get Y ( ) + get YOffset ( ) , data Area . get Width ( ) - get XOffset ( ) , data Area . get Height ( ) - get YOffset ( ) ) ;  Plot Orientation orientation = plot . get Orientation ( ) ; double bar W0 = calculate Bar W0 ( plot , orientation , adjusted , domain Axis , state , visible Row , column ) ; double [ ] bar L0 L1 = calculate Bar L0 L1 ( value ) ; if ( bar L0 L1 == null ) { return ; }  Rectangle Edge edge = plot . get Range Axis Edge ( ) ; double trans L0 = range Axis . value To Java2 D ( bar L0 L1 [ _ NUM ] , adjusted , edge ) ; double trans L1 = range Axis . value To Java2 D ( bar L0 L1 [ _ NUM ] , adjusted , edge ) ; double bar L0 =  Math . min ( trans L0 , trans L1 ) ; double bar Length =  Math . abs ( trans L1 - trans L0 ) ;  Rectangle2 D bar ; if ( orientation . is Horizontal ( ) ) { bar = new  Rectangle2 D .  Double ( bar L0 , bar W0 , bar Length , state . get Bar Width ( ) ) ; } else { bar = new  Rectangle2 D .  Double ( bar W0 , bar L0 , state . get Bar Width ( ) , bar Length ) ; } if ( state . get Element Hinting ( ) ) { begin Element Group ( g2 , dataset . get Row Key ( row ) , dataset . get Column Key ( column ) ) ; }  Paint item Paint = get Item Paint ( row , column ) ; g2 . set Paint ( item Paint ) ; g2 . fill ( bar ) ; double x0 = bar . get Min X ( ) ; double x1 = x0 + get XOffset ( ) ; double x2 = bar . get Max X ( ) ; double x3 = x2 + get XOffset ( ) ; double y0 = bar . get Min Y ( ) - get YOffset ( ) ; double y1 = bar . get Min Y ( ) ; double y2 = bar . get Max Y ( ) - get YOffset ( ) ; double y3 = bar . get Max Y ( ) ;  General Path bar3d Right = null ;  General Path bar3d Top ; if ( bar Length > _ NUM ) { bar3d Right = new  General Path ( ) ; bar3d Right . move To ( ( float ) x2 , ( float ) y3 ) ; bar3d Right . line To ( ( float ) x2 , ( float ) y1 ) ; bar3d Right . line To ( ( float ) x3 , ( float ) y0 ) ; bar3d Right . line To ( ( float ) x3 , ( float ) y2 ) ; bar3d Right . close Path ( ) ; g2 . set Paint (  Paint Alpha . darker ( item Paint ) ) ; g2 . fill ( bar3d Right ) ; } bar3d Top = new  General Path ( ) ; bar3d Top . move To ( ( float ) x0 , ( float ) y1 ) ; bar3d Top . line To ( ( float ) x1 , ( float ) y0 ) ; bar3d Top . line To ( ( float ) x3 , ( float ) y0 ) ; bar3d Top . line To ( ( float ) x2 , ( float ) y1 ) ; bar3d Top . close Path ( ) ; g2 . fill ( bar3d Top ) ; if ( is Draw Bar Outline ( ) && state . get Bar Width ( ) >  BAR_ OUTLINE_ WIDTH_ THRESHOLD ) { g2 . set Stroke ( get Item Outline Stroke ( row , column ) ) ; g2 . set Paint ( get Item Outline Paint ( row , column ) ) ; g2 . draw ( bar ) ; if ( bar3d Right != null ) { g2 . draw ( bar3d Right ) ; } g2 . draw ( bar3d Top ) ; } if ( state . get Element Hinting ( ) ) { end Element Group ( g2 ) ; }  Category Item Label Generator generator = get Item Label Generator ( row , column ) ; if ( generator != null && is Item Label Visible ( row , column ) ) { draw Item Label ( g2 , dataset , row , column , plot , generator , bar , ( value < _ NUM ) ) ; }  Entity Collection entities = state . get Entity Collection ( ) ; if ( entities != null ) {  General Path bar Outline = new  General Path ( ) ; bar Outline . move To ( ( float ) x0 , ( float ) y3 ) ; bar Outline . line To ( ( float ) x0 , ( float ) y1 ) ; bar Outline . line To ( ( float ) x1 , ( float ) y0 ) ; bar Outline . line To ( ( float ) x3 , ( float ) y0 ) ; bar Outline . line To ( ( float ) x3 , ( float ) y2 ) ; bar Outline . line To ( ( float ) x2 , ( float ) y3 ) ; bar Outline . close Path ( ) ; add Item Entity ( entities , dataset , row , column , bar Outline ) ; } }
private  List <  String > build Command Line ( ) {  List <  String > command Line = new  Array List <  String > ( ) ; command Line . add ( executable ) ; command Line . add All ( jvm Arguments ) ; command Line . add All ( system Properties ) ; if ( classpath != null && jar Path == null ) { command Line . add ( _ STR ) ; command Line . add ( classpath ) ; } if ( jar Path != null ) { command Line . add ( _ STR ) ; command Line . add ( jar Path ) ; } if ( jar Path == null ) { command Line . add ( main Class ) ; } command Line . add All ( application Arguments ) ; return command Line ; }
public static boolean is Network Connected (  Context context ) { if ( context == null ) { return _ BOOL ; }  Connectivity Manager cm = (  Connectivity Manager ) context . get System Service (  Context .  CONNECTIVITY_ SERVICE ) ;  Network Info network Info = cm . get Active Network Info ( ) ; return ( network Info != null && network Info . is Connected ( ) ) ; }
private void init From Auth Header (  String auth Header ) { this . auth Header = auth Header ; if ( auth Header == null ) throw new  Null Pointer Exception ( _ STR ) ;  Matcher auth Matcher =  SCHEME_ PATTERN . matcher ( auth Header ) ; if ( ! auth Matcher . matches ( ) ) { throw new  Illegal State Exception ( _ STR + auth Header ) ; } scheme = auth Matcher . group ( _ NUM ) ; if ( auth Matcher . group Count ( ) > _ NUM ) {  Matcher param Matcher =  PARAM_ PATTERN . matcher ( auth Matcher . group ( _ NUM ) ) ; while ( param Matcher . find ( ) ) {  String value = param Matcher . group ( _ NUM ) ; if ( value == null ) { value = param Matcher . group ( _ NUM ) ; } parameters . put ( param Matcher . group ( _ NUM ) , value ) ; } } }
public final synchronized void close (  Aion Server Packet close Packet , boolean forced ) { if ( is Write Disabled ( ) ) { return ; } log . info ( _ STR + close Packet + _ STR ) ; pending Close = _ BOOL ; is Forced Closing = forced ; send Msg Queue . clear ( ) ; send Msg Queue . add Last ( close Packet ) ; enable Write Interest ( ) ; }
public void replace ( final  List <  Edge > remove List , final  Edge new Edge ) { final  Edge previous = previous Edges . get ( remove List . get ( _ NUM ) ) ; final  Edge next = next Edges . get ( remove List . get ( remove List . size ( ) - _ NUM ) ) ; edges . add ( new Edge ) ; previous Edges . put ( new Edge , previous ) ; next Edges . put ( previous , new Edge ) ; previous Edges . put ( next , new Edge ) ; next Edges . put ( new Edge , next ) ; for ( final  Edge edge : remove List ) { if ( edge == one Edge ) { one Edge = new Edge ; } edges . remove ( edge ) ; previous Edges . remove ( edge ) ; next Edges . remove ( edge ) ; } }
public static void use Internal Frames (  JRoot Pane root Pane ) { if ( root Pane != null ) { use Internal Frames ( root Pane . get Layered Pane ( ) ) ; } else { use Internal Frames ( (  JLayered Pane ) null ) ; } }
public void write Byte ( int value ) throws  IOException { check Write Primitive Types ( ) ; primitive Types . write Byte ( value ) ; }
private synchronized void update Container XML ( ) throws  IOException ,  Parser Configuration Exception { synchronized ( _lock ) { if ( _container Entry == null ) return ; } if ( m_ Container File != null && ! m_ Container File . exists ( ) ) { m_ Container File . create New File ( ) ; if ( _logger . is Loggable (  Level .  FINE ) ) { _logger . fine ( _ STR + m_ Container File + _ STR + _container Name + _ STR ) ; } }  Document Builder Factory factory =  Document Builder Factory . new Instance ( ) ;  Document Builder builder = factory . new Document Builder ( ) ; m_container File Document = builder . new Document ( ) ; m_root Container Element = m_container File Document . create Element ( _container Name ) ; m_root Space Element = m_container File Document . create Element (  SPACE_ TAG ) ; m_root Container Element . append Child ( m_root Space Element ) ; synchronized ( _lock ) { if ( _container Entry != null ) update Container XMLTree ( _container Entry . get Name ( ) , _container Entry . get Space Attributes ( ) ) ; } save State ( ) ; }
public static  List <  String > expand Wildcards (  File dir ,  List <  String > modules ,  Backend for Backend ) {  List <  File > dirs = new  Array List <  File > ( ) ; dirs . add ( dir ) ; return expand Wildcards ( dirs , modules , for Backend ) ; }
public  Hex ( final  String charset Name ) { this (  Charset . for Name ( charset Name ) ) ; }
private static  String fmt ( double double Value ) { if ( double Value == ( long ) double Value ) { return  String . format ( _ STR , ( long ) double Value ) ; } else { return  String . format ( _ STR , double Value ) ; } }
public static  Throwable sanitize (  Throwable t ) { if ( !  Boolean . get Boolean ( _ STR ) ) {  Stack Trace Element [ ] trace = t . get Stack Trace ( ) ;  List <  Stack Trace Element > new Trace = new  Array List <  Stack Trace Element > ( ) ; for (  Stack Trace Element stack Trace Element : trace ) { if ( is Application Class ( stack Trace Element . get Class Name ( ) ) ) { new Trace . add ( stack Trace Element ) ; } }  STACK_ LOG . log (  Level .  WARNING , _ STR , t ) ;  Stack Trace Element [ ] clean = new  Stack Trace Element [ new Trace . size ( ) ] ; new Trace . to Array ( clean ) ; t . set Stack Trace ( clean ) ; } return t ; }
@  Override public boolean e Is Set ( int feature ID ) { switch ( feature ID ) { case  Eip Package .  METADATA__ KEY : return  KEY_ EDEFAULT == null ? key != null : !  KEY_ EDEFAULT . equals ( key ) ; case  Eip Package .  METADATA__ VALUES : return values != null && ! values . is Empty ( ) ; } return super . e Is Set ( feature ID ) ; }
public static void load Library (  String libname ) throws  IOException {  File lib = jni Extractor . extract Jni ( libname ) ;  System . load ( lib . get Absolute Path ( ) ) ; }
@  Override public boolean has (  Pattern pattern ) { final  Matcher matcher = pattern . matcher ( rest ( ) ) ; return matcher . find ( ) && matcher . start ( ) == _ NUM ; }
private void fill Ordinal To Block Mapping For Dimension ( ) { int block Ordinal = - _ NUM ;  Carbon Dimension dimension = null ; int index = _ NUM ; int prvcolumn Group Id = - _ NUM ; while ( index < dimensions . size ( ) ) { dimension = dimensions . get ( index ) ; if ( dimension . is Columnar ( ) || dimension . column Group Id ( ) != prvcolumn Group Id ) { block Ordinal ++ ; } dimension Ordinal To Block Mapping . put ( dimension . get Ordinal ( ) , block Ordinal ) ; prvcolumn Group Id = dimension . column Group Id ( ) ; index ++ ; } index = _ NUM ; while ( index < complex Dimensions . size ( ) ) { dimension = complex Dimensions . get ( index ) ; dimension Ordinal To Block Mapping . put ( dimension . get Ordinal ( ) , ++ block Ordinal ) ; block Ordinal = fill Complex Dimension Child Block Index ( block Ordinal , dimension ) ; index ++ ; } fill Block To Dimension Ordinal Mapping ( ) ; }
public static  Field find Field (  Class < ? > type ,  String name ) throws  No Such Field Exception { if ( name == null ) { throw new  Illegal Argument Exception ( _ STR ) ; }  Field field = type . get Field ( name ) ; if ( !  Modifier . is Public ( field . get Modifiers ( ) ) ) { throw new  No Such Field Exception ( _ STR + name + _ STR ) ; } type = field . get Declaring Class ( ) ; if ( !  Modifier . is Public ( type . get Modifiers ( ) ) || ! is Package Accessible ( type ) ) { throw new  No Such Field Exception ( _ STR + name + _ STR ) ; } return field ; }
@  Suppress Warnings ( _ STR ) protected void  Build New LGSubrs ( int  Font ) throws java . io .  IOException { if ( fonts [  Font ] . is CID ) { h Subrs Used = new  Generic Array < > ( fonts [  Font ] . fdprivate Offsets . length ) ; l Subrs Used = new  Generic Array < > ( fonts [  Font ] . fdprivate Offsets . length ) ;  New LSubrs Index = new byte [ fonts [  Font ] . fdprivate Offsets . length ] [ ] ; fonts [  Font ] .  Private Subrs Offset = new int [ fonts [  Font ] . fdprivate Offsets . length ] ; fonts [  Font ] .  Private Subrs Offsets Array = new int [ fonts [  Font ] . fdprivate Offsets . length ] [ ] ;  List <  Integer >  FDIn List = new  Array List < > (  FDArray Used ) ; for ( int j = _ NUM ; j <  FDIn List . size ( ) ; j ++ ) { int  FD = ( int )  FDIn List . get ( j ) ; h Subrs Used . set (  FD , new  Hash Map <  Integer , int [ ] > ( ) ) ; l Subrs Used . set (  FD , new  Array List <  Integer > ( ) ) ;  Build FDSubrs Offsets (  Font ,  FD ) ; if ( fonts [  Font ] .  Private Subrs Offset [  FD ] >= _ NUM ) {  Build Subr Used (  Font ,  FD , fonts [  Font ] .  Private Subrs Offset [  FD ] , fonts [  Font ] .  Private Subrs Offsets Array [  FD ] , h Subrs Used . get (  FD ) , l Subrs Used . get (  FD ) ) ;  New LSubrs Index [  FD ] =  Build New Index ( fonts [  Font ] .  Private Subrs Offsets Array [  FD ] , h Subrs Used . get (  FD ) ,  RETURN_ OP ) ; } } } else if ( fonts [  Font ] . private Subrs >= _ NUM ) { fonts [  Font ] .  Subrs Offsets = get Index ( fonts [  Font ] . private Subrs ) ;  Build Subr Used (  Font , - _ NUM , fonts [  Font ] . private Subrs , fonts [  Font ] .  Subrs Offsets , h Subrs Used Non CID , l Subrs Used Non CID ) ; }  Build GSubrs Used (  Font ) ; if ( fonts [  Font ] . private Subrs >= _ NUM )  New Subrs Index Non CID =  Build New Index ( fonts [  Font ] .  Subrs Offsets , h Subrs Used Non CID ,  RETURN_ OP ) ;  New GSubrs Index =  Build New Index ( gsubr Offsets , h GSubrs Used ,  RETURN_ OP ) ; }
public int swap ( ) { if ( ! m Egl . egl Swap Buffers ( m Egl Display , m Egl Surface ) ) { return m Egl . egl Get Error ( ) ; } return  EGL10 .  EGL_ SUCCESS ; }
public static final void store Default Parameters (  Configuration Parameters params ) { default Parameters . set ( params ) ; }
public void add Line (  String line ) { int index = line . index Of ( _ STR , _ NUM ) ; if ( index != - _ NUM ) { add Lenient ( line . substring ( _ NUM , index ) , line . substring ( index + _ NUM ) ) ; } else if ( line . starts With ( _ STR ) ) { add Lenient ( _ STR , line . substring ( _ NUM ) ) ; } else { add Lenient ( _ STR , line ) ; } }
public static void merge Nodes (  Tree Node master ,  Tree Node slave ) {  Default Mutable Tree Node master Node = (  Default Mutable Tree Node ) master ;  Default Mutable Tree Node slave Node = (  Default Mutable Tree Node ) slave ; int master Cnt = master Node . get Child Count ( ) ; while ( slave Node . get Child Count ( ) > _ NUM ) {  Default Mutable Tree Node slave Node Child = (  Default Mutable Tree Node ) slave Node . get First Child ( ) ; for ( int m = _ NUM ; m < master Cnt ; m ++ ) {  Default Mutable Tree Node master At M = (  Default Mutable Tree Node ) master Node . get Child At ( m ) ; if ( do Custom Merge ( slave Node Child , master At M ) ) { slave Node Child = null ; break ; } if (  Merge Help Utilities . compare Names ( master At M , slave Node Child ) == _ NUM ) { if (  Merge Help Utilities . have Equal ID ( master At M , slave Node Child ) ) {  Merge Help Utilities . merge Nodes (  DEFAULT_ MERGE_ TYPE , master At M , slave Node Child ) ; slave Node Child . remove From Parent ( ) ; slave Node Child = null ; break ; }  Merge Help Utilities . mark Nodes ( master At M , slave Node Child ) ; master Node . add ( slave Node Child ) ;  Merge Help Utilities . merge Node Children (  DEFAULT_ MERGE_ TYPE , slave Node Child ) ; slave Node Child = null ; break ; } } if ( slave Node Child != null ) { master Node . add ( slave Node Child ) ;  Merge Help Utilities . merge Node Children (  DEFAULT_ MERGE_ TYPE , slave Node Child ) ; } } slave Node . remove From Parent ( ) ; slave Node = null ; }
public void test Negate Positive ( ) {  String a = _ STR ; int a Scale = _ NUM ;  String c = _ STR ; int c Scale = _ NUM ;  Big Decimal a Number = new  Big Decimal ( new  Big Integer ( a ) , a Scale ) ;  Big Decimal c Number = new  Big Decimal ( new  Big Integer ( c ) , c Scale ) ; assert Equals ( _ STR , c Number , a Number . negate ( ) ) ; }
private static void bind List (  Class < ? > item Type ,  Object target ,  Field field ,  Parameter Access parameters ) {  String field Name = field . get Name ( ) ;  Class < ? > field Type = field . get Type ( ) ;  List <  Parameter Access > item Parameters = create Item Parameters ( item Type , parameters ) ;  Object array =  Array . new Instance ( item Type , item Parameters . size ( ) ) ; for ( int i = _ NUM ; i < item Parameters . size ( ) ; i ++ ) {  Object item Value = create And Bind Item ( item Parameters . get ( i ) , item Type ) ;  Array . set ( array , i , item Value ) ; }  Object target Value = convert Array ( array , field Type , item Type ) ; try { field . set Accessible ( _ BOOL ) ; field . set ( target , target Value ) ; } catch (  Exception e ) {  String message =  String . format ( _ STR , field Name ) ; throw new  Binding Exception ( message , e ) ; } }
public  Algorithm List Panel (  Experiment exp ) { this ( ) ; set Experiment ( exp ) ; }
private void parse Arguments (  String [ ] args ) throws  IOException { for ( int i = _ NUM ; i < args . length ; i ++ ) {  String arg = args [ i ] ; if ( arg . equals ( _ STR ) ) { i ++ ; if ( args . length <= i ) { parsing Error ( arg + _ STR ) ; } indirectory = new  File ( args [ i ] ) ; if ( ! indirectory . exists ( ) ) { parsing Error ( args [ i ] + _ STR ) ; } } else if ( arg . equals ( _ STR ) ) { i ++ ; if ( args . length <= i ) { parsing Error ( arg + _ STR ) ; } outdirectory = new  File ( args [ i ] ) ; } else if ( arg . equals ( _ STR ) ) { i ++ ; if ( args . length <= i ) { parsing Error ( arg + _ STR ) ; }  File config = new  File ( args [ i ] ) ; if ( ! config . exists ( ) ) { parsing Error ( arg + _ STR + args [ i ] + _ STR ) ; } ner Annotator =  Ner Annotator Manager . build Ner Annotator ( new  Resource Manager ( args [ i ] ) ,  View Names .  NER_ CONLL ) ; } else if ( arg . equals ( _ STR ) ) { i ++ ; try { max =  Integer . parse Int ( args [ i ] ) ; } catch (  Number Format Exception nfe ) { parsing Error ( _ STR + args [ i ] + _ STR ) ; } } else { parsing Error ( _ STR + arg + _ STR ) ; } } if ( ner Annotator == null ) { parsing Error ( _ STR ) ; } if ( outdirectory != null && ! outdirectory . exists ( ) ) { if ( indirectory == null ) outdirectory . create New File ( ) ; else if ( indirectory . is Directory ( ) ) { outdirectory . mkdirs ( ) ; } else { outdirectory . create New File ( ) ; } } }
public static  Network lookup Network Full (  Db Client db Client ,  Storage Protocol .  Transport transport Type ,  String endpoint ) { _log . info (  String . format ( _ STR , transport Type . name ( ) , endpoint ) ) ; try { return  Network Util . get Endpoint Network ( endpoint , db Client ) ; } catch (  Database Exception e ) { _log . error ( _ STR , endpoint ) ; } _log . info ( _ STR ) ; return null ; }
public void minus (  Set x ) { if ( size ( ) > x . size ( ) ) {  Enumeration elements = x . elements ( ) ; while ( elements . has More Elements ( ) ) remove ( elements . next Element ( ) ) ; } else {  Enumeration elements = elements ( ) ;  Object a ; while ( elements . has More Elements ( ) ) { a = elements . next Element ( ) ; if ( x . in ( a ) ) remove ( a ) ; } } }
public boolean has Name Value (  String name ) { return hmap . contains Key ( name . to Lower Case ( ) ) ; }
public boolean starts With ( java . lang .  String prefix ) { return starts With ( prefix , _ NUM ) ; }
public boolean is First Window (  Accessibility Window Info base Window , int window Type ) { int index = get Window Index ( base Window ) ; if ( index <= _ NUM ) { return _ BOOL ; } for ( int i = index - _ NUM ; i > _ NUM ; i -- ) {  Accessibility Window Info window = m Windows . get ( i ) ; if ( window != null && window . get Type ( ) == window Type ) { return _ BOOL ; } } return _ BOOL ; }
public void fire Property Change (  String property Name , long old Value , long new Value ) { if ( change Support == null || old Value == new Value ) { return ; } fire Property Change ( property Name ,  Long . value Of ( old Value ) ,  Long . value Of ( new Value ) ) ; }
public  Abstract Surface Object ( ) { this . visible = _ BOOL ; this . unique Id = next Unique Id ( ) ; this . last Modified Time =  System . current Time Millis ( ) ; this . enable Batch Picking = _ BOOL ; }
public  String parse ( ) throws  Query Exception { return ( parse ( _ BOOL ) ) ; }
private  String create New Review (  Task Data task Data ,  Appraise Plugin Review Client client ) throws  Core Exception { boolean can Request Review = client . can Request Review ( task Data ) ; if ( ! can Request Review ) { throw new  Core Exception (  Status .  CANCEL_ STATUS ) ; }  String task Id = null ; try {  Review review = build Review From Task Data ( task Data ) ; review . set Timestamp (  System . current Time Millis ( ) / _ NUM ) ;  String review Commit Hash = get Review Commit Hash ( task Data ) ; task Id = client . write Review ( review Commit Hash , review ) ; if ( task Id == null ) { throw new  Core Exception (  Status .  CANCEL_ STATUS ) ; } } catch (  Git Client Exception e ) { throw new  Core Exception ( new  Status (  IStatus .  ERROR ,  Appraise Connector Plugin .  PLUGIN_ ID , _ STR , e ) ) ; } return task Id ; }
public  Voice ( ) { }
byte dir Type Forward ( ) { last Char = text . char At ( char Index ) ; if (  Character . is High Surrogate ( last Char ) ) { int code Point =  Character . code Point At ( text , char Index ) ; char Index +=  Character . char Count ( code Point ) ; return  Character . get Directionality ( code Point ) ; } char Index ++ ; byte dir Type = get Cached Directionality ( last Char ) ; if ( is Html ) { if ( last Char == _ STR ) { dir Type = skip Tag Forward ( ) ; } else if ( last Char == _ STR ) { dir Type = skip Entity Forward ( ) ; } } return dir Type ; }
public  Schedule new Schedule (  String name ) {  Schedule schedule = get Schedule By Name ( name ) ; if ( schedule == null ) { _id ++ ; schedule = new  Schedule (  Integer . to String ( _id ) , name ) ;  Integer old Size =  Integer . value Of ( _schedule Hash Table . size ( ) ) ; _schedule Hash Table . put ( schedule . get Id ( ) , schedule ) ; set Dirty And Fire Property Change (  LISTLENGTH_ CHANGED_ PROPERTY , old Size ,  Integer . value Of ( _schedule Hash Table . size ( ) ) ) ; } return schedule ; }
public static  Color Own for String (  String color String , int transparency ) { boolean error = _ BOOL ;  Color Own return Color = null ; if ( color String == null ) { error = _ BOOL ; } else { for (  Entry <  String ,  Color Own > c :  COLOR_ MAP . entry Set ( ) ) { if ( color String . equals Ignore Case ( c . get Key ( ) ) ) { return Color = c . get Value ( ) ; break ; } } if ( return Color == null ) { try { return Color = new  Color Own ( color String ) ; } catch (  Number Format Exception e ) { error = _ BOOL ; } } if ( return Color != null ) { return Color = return Color . transparency ( transparency ) ; } } if ( error ) { throw new  Style Exception ( _ STR +  EXAMPLE_ TEXT ) ; } return return Color ; }
private static  Linked List <  Mary Module > modules Required For Processing (  Mary Data Type source Type ,  Mary Data Type target Type ,  Locale locale ,  Voice voice ,  Linked List <  Mary Data Type > seen Types ) { if ( source Type . equals ( target Type ) ) {  Log . d (  Mary .  LOG , _ STR ) ; return new  Linked List <  Mary Module > ( ) ; }  List <  Mary Module > candidates = null ; if ( voice != null ) candidates = voice . get Preferred Modules Accepting Type ( source Type ) ; if ( candidates == null || candidates . is Empty ( ) ) { candidates = get ( source Type , locale , voice ) ; } if ( candidates == null || candidates . is Empty ( ) ) { return null ; } for (  Iterator <  Mary Module > it = candidates . iterator ( ) ; it . has Next ( ) ; ) {  Mary Module candidate = it . next ( ) ;  Mary Data Type output Type = candidate . output Type ( ) ; if ( ! seen Types . contains ( output Type ) ) { seen Types . add ( output Type ) ;  Log . d (  Mary .  LOG , _ STR + candidate . name ( ) + _ STR + source Type . name ( ) + _ STR + output Type + _ STR + locale + _ STR + voice + _ STR ) ;  Linked List <  Mary Module > path = modules Required For Processing ( output Type , target Type , locale , voice , seen Types ) ; if ( path != null ) { path . add First ( candidate ) ; return path ; } seen Types . remove Last ( ) ; } } return null ; }
public double length ( ) { return  Math . sqrt (  Number Conversions . square ( x ) +  Number Conversions . square ( y ) +  Number Conversions . square ( z ) ) ; }
public long time ( ) { return  System . current Time Millis ( ) ; }
public  Flat Buffer Builder init (  Byte Buffer existing_bb ) { bb = existing_bb ; bb . clear ( ) ; bb . order (  Byte Order .  LITTLE_ ENDIAN ) ; minalign = _ NUM ; space = bb . capacity ( ) ; vtable_in_use = _ NUM ; nested = _ BOOL ; finished = _ BOOL ; object_start = _ NUM ; num_vtables = _ NUM ; vector_num_elems = _ NUM ; return this ; }
private  Map <  String ,  String > produce Stream (  String topic ) {  List <  Integer > subnet = new  Array List < > ( ) ; for ( int i = _ NUM ; i <=  CNT ; i ++ ) subnet . add ( i ) ;  Collections . shuffle ( subnet ) ;  List <  Producer Record <  String ,  String > > messages = new  Array List < > (  CNT ) ;  Map <  String ,  String > key Val Map = new  Hash Map < > ( ) ; for ( int evt = _ NUM ; evt <  CNT ; evt ++ ) { long runtime =  System . current Time Millis ( ) ;  String ip =  KEY_ PREFIX + subnet . get ( evt ) ;  String msg = runtime +  VALUE_ URL + ip ; messages . add ( new  Producer Record < > ( topic , ip , msg ) ) ; key Val Map . put ( ip , msg ) ; } embedded Broker . send Messages ( messages ) ; return key Val Map ; }
private static  String string Of Char ( char ch , int len ) {  String Buffer buf = new  String Buffer ( ) ; for ( int i = _ NUM ; i < len ; i ++ ) { buf . append ( ch ) ; } return buf . to String ( ) ; }
public  Connection put Connection (  Connection connection ) { return connections . put ( connection . get Identifier ( ) , connection ) ; }
public void trim (  String a Text , int [ ] a Span ) { int begin = a Span [ _ NUM ] ; int end = a Span [ _ NUM ] - _ NUM ;  String data = a Text ; while ( ( begin < ( data . length ( ) - _ NUM ) ) && trim Char ( data . char At ( begin ) ) ) { begin ++ ; } while ( ( end > _ NUM ) && trim Char ( data . char At ( end ) ) ) { end -- ; } end ++ ; a Span [ _ NUM ] = begin ; a Span [ _ NUM ] = end ; }
public void remove Script Finished Listener (  Script Execution Listener l ) { m_ Finished Listeners . remove ( l ) ; }
public void test_get Put Byte Array With Offset And Length ( ) { final int capacity = _ NUM ; final  Byte Array Buffer buf = new  Byte Array Buffer ( capacity ) ; assert Equals ( ( byte ) _ NUM , buf . get Byte ( _ NUM ) ) ; assert Equals ( ( byte ) _ NUM , buf . get Byte ( capacity - _ NUM ) ) ; final int pos = _ NUM ; for ( int i = _ NUM ; i <  LIMIT ; i ++ ) { final byte [ ] expected = new byte [ r . next Int ( capacity - _ NUM ) ] ; final int off = ( expected . length / _ NUM == _ NUM ? _ NUM : r . next Int ( expected . length / _ NUM ) ) ; final int len = ( expected . length == _ NUM ? _ NUM : r . next Int ( expected . length - off ) ) ; r . next Bytes ( expected ) ; buf . put ( pos , expected , off , len ) ; assert Equals ( _ NUM ,  Bytes Util . compare Bytes With Len And Offset ( off , len , expected , pos , len , buf . array ( ) ) ) ; final int dstoff = r . next Int ( _ NUM ) ; final byte [ ] actual = new byte [ expected . length + dstoff ] ; buf . get ( pos , actual , dstoff , expected . length ) ; assert Equals ( _ NUM ,  Bytes Util . compare Bytes With Len And Offset ( off , len , expected , dstoff , len , actual ) ) ; } assert Equals ( ( byte ) _ NUM , buf . get Byte ( _ NUM ) ) ; assert Equals ( ( byte ) _ NUM , buf . get Byte ( pos + capacity - _ NUM ) ) ; }
private  Object [ ] ensure Capacity ( int min Capacity ) { if ( tmp . length < min Capacity ) { int new Size = min Capacity ; new Size |= new Size > > _ NUM ; new Size |= new Size > > _ NUM ; new Size |= new Size > > _ NUM ; new Size |= new Size > > _ NUM ; new Size |= new Size > > _ NUM ; new Size ++ ; if ( new Size < _ NUM ) new Size = min Capacity ; else new Size =  Math . min ( new Size , a . length > > > _ NUM ) ;  Object [ ] new Array = new  Object [ new Size ] ; tmp = new Array ; } return tmp ; }
public void  CL ( int session Number ,  String client Line ) { this . max Session Number =  Math . max ( this . max Session Number , session Number ) ; test Elements . add ( new  Client Request ( session Number , client Line ) ) ; }
private  Point2 D compute Center (  Array List <  Point2 D > points ) { final  Point center = new  Point ( _ NUM , _ NUM ) ; if ( points . size ( ) > _ NUM ) { for (  Point2 D a Pt : points ) { center . x += ( int ) a Pt . get X ( ) ; center . y += ( int ) a Pt . get Y ( ) ; } center . x /= points . size ( ) ; center . y /= points . size ( ) ; } return center ; }
private static int count Gaps Dash Dot (  String sequence ) { int count = _ NUM ; for ( int i = _ NUM ; i < sequence . length ( ) ; i ++ ) { int a = sequence . char At ( i ) ; if ( a == _ STR || a == _ STR ) count ++ ; } return count ; }
public  CRLNumber Extension ( int crl Num ) throws  IOException { this (  PKIXExtensions .  CRLNumber_ Id , _ BOOL ,  Big Integer . value Of ( crl Num ) ,  NAME ,  LABEL ) ; }
static private double calc Log Prob At Mu ( double mu ) { final double sigma = calc Sigma From Mu ( mu ) ; return ( - s_log Sqrt Two Pi -  Math . log ( sigma ) ) ; }
static public boolean is Zero ( float value , float tolerance ) { return  Math . abs ( value ) <= tolerance ; }
protected final void drag Exit ( final int x , final int y ) {  Drag Source Event event = new  Drag Source Event ( get Drag Source Context ( ) , x , y ) ;  Event Dispatcher dispatcher = new  Event Dispatcher (  DISPATCH_ EXIT , event ) ;  Sun Toolkit . invoke Later On App Context (  Sun Toolkit . target To App Context ( get Component ( ) ) , dispatcher ) ; start Secondary Event Loop ( ) ; }
protected static  String extract Bucket (  String s3uri ) { return s3uri . substring ( s3uri . index Of ( _ STR ) + _ NUM , s3uri . index Of ( _ STR , s3uri . index Of ( _ STR ) ) ) ; }
public  Mail Message add Recipient To (  String address ) { if ( address != null ) { to . add ( address ) ; } return this ; }
public boolean is Safe Class (  Soot Class clz ) { return safe Classes . contains ( clz . get Name ( ) ) ; }
public void update Download ( ) {  Array List <  Download Info Runnable > ongoing Downloads = get Ongoing Downloads ( ) ; if ( ! ongoing Downloads . is Empty ( ) ) { update Progress ( ) ; } else { timer . cancel ( ) ; timer . purge ( ) ; stop Self ( ) ; m Builder = null ; stop Foreground ( _ BOOL ) ; is Stopped = _ BOOL ; } }
public boolean is Running ( ) { return running ; }
static private  String read From Stdin ( ) throws  IOException { final  Line Number Reader r = new  Line Number Reader ( new  Input Stream Reader (  System . in ) ) ; try { final  String Builder sb = new  String Builder ( ) ;  String s ; while ( ( s = r . read Line ( ) ) != null ) { if ( r . get Line Number ( ) > _ NUM ) sb . append ( _ STR ) ; sb . append ( s ) ; } return sb . to String ( ) ; } finally { r . close ( ) ; } }
@  Override public  String to String ( ) { final  String Builder sb = new  String Builder ( ) ; sb . append ( _ STR ) ; sb . append ( get Request ID ( ) ) ; sb . append ( _ STR ) ; sb . append ( timestamp ) ; sb . append ( _ STR ) ; sb . append ( get Request ( ) ) ; sb . append ( _ STR ) ; return sb . to String ( ) ; }
public void test_empty Journal ( ) throws  IOException ,  Interrupted Exception ,  Execution Exception { final  File out =  File . create Temp File ( get Name ( ) ,  Options .  JNL ) ; try { final  Journal src = get Store ( get Properties ( ) ) ; try { try { final  Future <  Journal > f = src . compact ( out ) ; final  Journal new Journal = f . get ( ) ; try { new Journal . destroy ( ) ; } finally { fail ( _ STR +  Illegal Argument Exception . class ) ; } } catch (  Illegal Argument Exception ex ) { log . info ( _ STR + ex ) ; } } finally { src . destroy ( ) ; } } finally { out . delete ( ) ; } }
private  String remove Trailing Period (  String val ) { if ( val . char At ( val . length ( ) - _ NUM ) == _ STR ) { val = val . substring ( _ NUM , val . length ( ) - _ NUM ) ; } return val ; }
public static double pow ( double value , double power ) { if (  USE_ JDK_ MATH ) { return  STRICT_ MATH ?  Strict Math . pow ( value , power ) :  Math . pow ( value , power ) ; } if ( power == _ NUM ) { return _ NUM ; } else if ( power == _ NUM ) { return value ; } if ( value <= _ NUM ) { int power Info ; if (  Math . abs ( power ) >= (  TWO_ POW_52 * _ NUM ) ) { power Info = _ NUM ; } else { if (  Math . abs ( power ) <= ( double )  Integer .  MAX_ VALUE ) { int power As Int = ( int ) power ; if ( power == ( double ) power As Int ) { power Info = ( ( power As Int & _ NUM ) == _ NUM ) ? _ NUM : - _ NUM ; } else { power Info = _ NUM ; } } else { long power As Long = ( long ) power ; if ( power == ( double ) power As Long ) { power Info = ( ( power As Long & _ NUM ) == _ NUM ) ? _ NUM : - _ NUM ; } else { if ( power != power ) { return  Double .  Na N ; } power Info = _ NUM ; } } } if ( value == _ NUM ) { if ( power < _ NUM ) { return ( power Info < _ NUM ) ? _ NUM / value :  Double .  POSITIVE_ INFINITY ; } else { return ( power Info < _ NUM ) ? value : _ NUM ; } } else { if ( value ==  Double .  NEGATIVE_ INFINITY ) { if ( power Info < _ NUM ) { return ( power < _ NUM ) ? - _ NUM :  Double .  NEGATIVE_ INFINITY ; } else { return ( power < _ NUM ) ? _ NUM :  Double .  POSITIVE_ INFINITY ; } } else { return ( power Info != _ NUM ) ? power Info *  Fast Math . exp ( power *  Fast Math . log ( - value ) ) :  Double .  Na N ; } } } else { return  Fast Math . exp ( power *  Fast Math . log ( value ) ) ; } }
public static  Class < ? > resolve Primitive If Necessary (  Class < ? > clazz ) {  Assert . not Null ( clazz , _ STR ) ; return ( clazz . is Primitive ( ) && clazz != void . class ? primitive Type To Wrapper Map . get ( clazz ) : clazz ) ; }
public  POSBase Line Feature Extractor (  String view Name ,  String json ) { this . view Name = view Name ; this . counter =  POSBase Line Counter . read ( json ) ; }
private  Map <  String ,  Annotation Mirror > annos In Type (  Type Element type Element ) { return create Imported Annotations Map (  Element Filter . types In ( type Element . get Enclosed Elements ( ) ) ) ; }
public void replace Node ( final  Node node ) {  List <  Way > ways = current Storage . get Ways ( node ) ; if ( ways . size ( ) > _ NUM ) {  Node new Node = factory . create Node With New Id ( node . lat , node . lon ) ; insert Element Unsafe ( new Node ) ; dirty = _ BOOL ; for (  Way way : ways ) { replace Node In Way ( node , new Node , way ) ; } } }
void update Cursor ( ) { if ( model . get Hovering Operator ( ) != null || model . get Hovering Port ( ) != null ) { set Cursor (  Cursor . get Predefined Cursor (  Cursor .  HAND_ CURSOR ) ) ; } else { set Cursor (  Cursor . get Default Cursor ( ) ) ; } }
public static boolean is Middle Mouse Button (  Mouse Event an Event ) { return ( an Event . get Modifiers Ex ( ) &  Input Event .  BUTTON2_ DOWN_ MASK ) > _ NUM ; }
Message ( ) { }
protected boolean is Stopped ( ) { return this . _is Stopped ; }
protected void reopen ( ) throws  IOException { if ( input Stream != null ) {  Debug . message ( _ STR , _ STR ) ; input Stream . close ( ) ; } input Stream Count = _ NUM ; }
private static int [ ] [ ] find References ( final  List <  Vector3 D > vertices , final  List < int [ ] > facets ) { final int [ ] nb Facets = new int [ vertices . size ( ) ] ; int max Facets = _ NUM ; for ( final int [ ] facet : facets ) { if ( facet . length < _ NUM ) { throw new  Math Illegal Argument Exception (  Localized Core Formats .  WRONG_ NUMBER_ OF_ POINTS , _ NUM , facet . length , _ BOOL ) ; } for ( final int index : facet ) { max Facets =  Fast Math . max ( max Facets , ++ nb Facets [ index ] ) ; } } final int [ ] [ ] references = new int [ vertices . size ( ) ] [ max Facets ] ; for ( int [ ] r : references ) {  Arrays . fill ( r , - _ NUM ) ; } for ( int f = _ NUM ; f < facets . size ( ) ; ++ f ) { for ( final int v : facets . get ( f ) ) { int k = _ NUM ; while ( k < max Facets && references [ v ] [ k ] >= _ NUM ) { ++ k ; } references [ v ] [ k ] = f ; } } return references ; }
protected  String resolve Language (  List <  Detected Language > languages ,  String fallback Lang ) {  String lang Str ; if ( languages . size ( ) == _ NUM ) { log . debug ( _ STR , fallback Lang ) ; lang Str = fallback Lang ; } else {  Detected Language lang = languages . get ( _ NUM ) ;  String normalized Lang = normalize Lang Code ( lang . get Lang Code ( ) ) ; if ( lang Whitelist . is Empty ( ) || lang Whitelist . contains ( normalized Lang ) ) { log . debug ( _ STR , normalized Lang , lang . get Certainty ( ) ) ; if ( lang . get Certainty ( ) >= threshold ) { lang Str = normalized Lang ; } else { log . debug ( _ STR , threshold , fallback Lang ) ; lang Str = fallback Lang ; } } else { log . debug ( _ STR , lang . get Lang Code ( ) , fallback Lang ) ; lang Str = fallback Lang ; } } if ( lang Str == null || lang Str . length ( ) == _ NUM ) { log . warn ( _ STR ) ; lang Str = _ STR ; } return lang Str ; }
public  Entity Bomb add Time ( int time ) { fuse Time =  Math . max ( fuse Time + time , fuse Time ) ; return this ; }
protected  Smp ( int max Threads ) { max Threads =  Math . max ( _ NUM , max Threads ) ; this . max Threads = max Threads ; if ( max Threads > _ NUM ) { this . task Group = new  FJTask Runner Group ( max Threads ) ; } else { this . task Group = null ; } }
protected long current Time ( ) { return  System . current Time Millis ( ) ; }
public static  Number cos (  Number a ) { return  Math . cos ( a . double Value ( ) ) ; }
@  Deprecated public static  Source Data Tag Quality from XML (  Element dom Element ) {  Node List fields = dom Element . get Child Nodes ( ) ; int fields Count = fields . get Length ( ) ;  String field Name ;  String field Value String ;  Node field Node ;  Source Data Tag Quality result = new  Source Data Tag Quality ( ) ; for ( int i = _ NUM ; i != fields Count ; i ++ ) { field Node = fields . item ( i ) ; if ( field Node . get Node Type ( ) ==  Node .  ELEMENT_ NODE ) { field Name = field Node . get Node Name ( ) ;  Node field Value Node = field Node . get First Child ( ) ; if ( field Value Node != null ) { field Value String = field Value Node . get Node Value ( ) ; } else { field Value String = _ STR ; } if ( field Name . equals (  XML_ ELEMENT_ QUALITY_ CODE ) ) { short code =  Short . parse Short ( field Value String ) ; result . quality Code =  Source Data Tag Quality Code . get Enum ( code ) ; } else if ( field Name . equals (  XML_ ELEMENT_ QUALITY_ DESC ) ) { result . description = field Value String ; } } } return result ; }
public boolean is Annotation Present (  Class < ? extends  Annotation > annotation Class ) { return param . is Annotation Present ( annotation Class ) ; }
public static  Boolean verify JWT ( final  String jwt , final  String secret ) throws  Hmac Exception { try {  Signed JWT signed JWT =  Signed JWT . parse ( jwt ) ;  JWSVerifier jws Verifier = new  MACVerifier ( secret ) ; return signed JWT . verify ( jws Verifier ) ; } catch (  Parse Exception |  JOSEException ex ) { throw new  Hmac Exception ( _ STR , ex ) ; } }
public void clear Exports ( ) { if ( exported Symbols != null ) { exported Symbols . clear ( ) ; } }
@  Override public synchronized void add Data Source Listener (  Data Source Listener dsl ) { m_data Listeners . add Element ( dsl ) ; }
protected static void lub Primaries (  Map <  Annotation Mirror ,  Annotation Mirror > lub Of Primaries ,  Map <  Annotation Mirror ,  Set <  Annotation Mirror > > subtype Annos ,  Set < ? extends  Annotation Mirror > tops ,  Qualifier Hierarchy qualifier Hierarchy ) { lub Of Primaries . clear ( ) ; for ( final  Annotation Mirror top : tops ) { final  Set <  Annotation Mirror > annos In Hierarchy = subtype Annos . get ( top ) ; if ( annos In Hierarchy != null && ! annos In Hierarchy . is Empty ( ) ) { lub Of Primaries . put ( top , least Upper Bound ( annos In Hierarchy , qualifier Hierarchy ) ) ; } } }
public boolean to Active ( ) {  Lifecycle State state ; synchronized ( this ) { state = _state ; if ( state . is After Active ( ) && ! state . is Stopped ( ) ) { return _ BOOL ; } _state =  ACTIVE ; _last Change Time =  Current Time . current Time ( ) ; } if ( _log != null && _log . is Loggable ( _level ) ) _log . log ( _level , _ STR + _name ) ; notify Listeners ( state ,  ACTIVE ) ; return _ BOOL ; }
public static int read Amount (  Input Stream is , byte [ ] buf , int offset , int length ) throws  IOException { int read = _ NUM ; int len ; while ( read < length && ( len = is . read ( buf , offset + read , length - read ) ) > _ NUM ) { read += len ; } return read ; }
public double evaluate (  Vector Instance x ,  Vector Instance y ) throws  Exception { double dot Prod = x . dot Product ( y ) ; double z = m_gamma * dot Prod + m_coef0 ; double a =  Math . exp ( z ) ; double b =  Math . exp ( - z ) ; return ( ( a - b ) / ( a + b ) ) ; }
void cancel Included Only ( ) { if ( ! show All ) { all Button . do Click ( ) ; } }
public  Watermark Disk Quota Policy (  List <  Entry > entries ) { entries = new  Array List < > ( entries ) ;  Collections . sort ( entries ,  POLICY_ COMPARATOR ) ; this . entries =  Collections . unmodifiable List ( entries ) ; double last High Water Mark = _ NUM ; double last Work Factor =  Throttleable .  MAX_ WORK_ FACTOR ; for ( int i = _ NUM ; i < entries . size ( ) ; ++ i ) { final  Entry entry = entries . get ( i ) ; if ( last High Water Mark < entry . get High Water Mark Percent ( ) ) { throw new  Illegal Argument Exception ( _ STR + i + _ STR + entry . get High Water Mark Percent ( ) + _ STR + last High Water Mark + _ STR + dump Policy Entries ( entries ) ) ; } if ( last Work Factor < entry . get Work Factor ( ) ) { throw new  Illegal Argument Exception ( _ STR + i + _ STR + entry . get Work Factor ( ) + _ STR + last Work Factor + _ STR + dump Policy Entries ( entries ) ) ; } if ( entry . get Work Factor ( ) <  Throttleable .  MIN_ WORK_ FACTOR ) { throw new  Illegal Argument Exception ( _ STR + i + _ STR + entry . get Work Factor ( ) + _ STR +  Throttleable .  MIN_ WORK_ FACTOR + _ STR + dump Policy Entries ( entries ) ) ; } last High Water Mark = entry . get High Water Mark Percent ( ) ; last Work Factor = entry . get Work Factor ( ) ; } log . info ( _ STR , entries . is Empty ( ) ? _ STR : dump Policy Entries ( entries ) ) ; }
private  String create Unique Name (  String base Name ) { int r = random . next Int ( ) ;  String suffix =  Integer . to String ( r ) ; if ( suffix . char At ( _ NUM ) == _ STR ) { suffix = suffix . replace ( _ STR , _ STR ) ; } return base Name + suffix ; }
@  Override public void parse (  String a Line ) throws  IOException {  String [ ] tokens = a Line . split ( _ STR ) ; if ( tokens . length == _ NUM ) { clear ( ) ; query Name = tokens [ _ NUM ] ; } else { query Name = tokens [ _ NUM ] ; ref Name = tokens [ _ NUM ] ; bit Score =  Basic . parse Int ( tokens [ _ NUM ] ) ; expected =  Basic . parse Float ( tokens [ _ NUM ] ) ; percent Identity =  Basic . parse Int ( tokens [ _ NUM ] ) ; } }
protected void draw Actor ( int x , int y , int w , int h ,  Color fill Color ,  Paint fill Paint ,  Color pen Color , boolean shadow ) { float width = w * _ NUM / _ NUM ;  General Path path = new  General Path ( ) ; path . move To ( x , y + h ) ; path . curve To ( x , y + _ NUM * h / _ NUM , x , y + _ NUM * h / _ NUM , x + w / _ NUM , y + _ NUM * h / _ NUM ) ; path . curve To ( x + w / _ NUM - width , y + _ NUM * h / _ NUM , x + w / _ NUM - width , y , x + w / _ NUM , y ) ; path . curve To ( x + w / _ NUM + width , y , x + w / _ NUM + width , y + _ NUM * h / _ NUM , x + w / _ NUM , y + _ NUM * h / _ NUM ) ; path . curve To ( x + w , y + _ NUM * h / _ NUM , x + w , y + _ NUM * h / _ NUM , x + w , y + h ) ; path . close Path ( ) ; draw Path ( path , fill Color , fill Paint , pen Color , shadow ) ; }
protected  String s (  Object obj ) { return obj . to String ( ) ; }
public static  Persistent Search Request Control new Control ( final boolean is Critical , final boolean changes Only , final boolean return ECs , final  Collection <  Persistent Search Change Type > change Types ) {  Reject . if Null ( change Types ) ; final  Set <  Persistent Search Change Type > copy Of Change Types =  Enum Set . none Of (  Persistent Search Change Type . class ) ; copy Of Change Types . add All ( change Types ) ; return new  Persistent Search Request Control ( is Critical , changes Only , return ECs ,  Collections . unmodifiable Set ( copy Of Change Types ) ) ; }
public static boolean test Recurrence (  List <  Neuron > source Neurons ,  List <  Neuron > target Neurons ) { if ( source Neurons . size ( ) != target Neurons . size ( ) ) { return _ BOOL ; } else { for ( int i = _ NUM ; i < source Neurons . size ( ) ; i ++ ) { if ( source Neurons . get ( i ) != target Neurons . get ( i ) ) { return _ BOOL ; } } } return _ BOOL ; }
public static  Number multiply (  Character left ,  Number right ) { return  Number Number Multiply . multiply (  Integer . value Of ( left ) , right ) ; }
public static  String unicode Escape (  String s ) { if ( all Ascii ( s ) ) { return s ; }  String Builder sb = new  String Builder ( s . length ( ) ) ; int len = s . length ( ) ; for ( int i = _ NUM ; i < len ; ++ i ) { char ch = s . char At ( i ) ; if ( ch <= _ NUM ) { sb . append ( ch ) ; } else { sb . append ( _ STR ) ;  String hex String =  Integer . to Hex String ( ch ) ; int num Zeros To Pad = _ NUM - hex String . length ( ) ; for ( int j = _ NUM ; j < num Zeros To Pad ; ++ j ) { sb . append ( _ STR ) ; } sb . append ( hex String ) ; } } return sb . to String ( ) ; }
public void add Time Change Listener (  Time Change Listener listener ) { time Change Listeners . add ( listener ) ; }
public long save ( ) { if ( m_is Saved ) { throw new  Illegal State Exception (  ERR_ ALREADY_ SAVED ) ; } if ( m_store == null ) { return _ NUM ; } if ( m_count == _ NUM ) { m_is Saved = _ BOOL ; return _ NUM ; } int addr = ( int ) m_store . alloc ( m_buf , m_count , m_context ) ; if ( m_blob Header != null ) { try { m_writing Hdr = _ BOOL ; m_blob Header . add ( addr ) ; m_count = _ NUM ; try { final int hdr Buf Size = _ NUM * ( m_blob Header . size ( ) + _ NUM ) ; final  Byte Array Output Stream hdrbuf = new  Byte Array Output Stream ( hdr Buf Size ) ; final  Data Output Stream hdrout = new  Data Output Stream ( hdrbuf ) ; hdrout . write Int ( m_blob Header . size ( ) ) ; for ( int i = _ NUM ; i < m_blob Header . size ( ) ; i ++ ) { hdrout . write Int ( m_blob Header . get ( i ) ) ; } hdrout . flush ( ) ; final byte [ ] outbuf = hdrbuf . to Byte Array ( ) ; addr = ( int ) m_store . alloc ( outbuf , hdr Buf Size , m_context ) ; } catch (  IOException e ) { throw new  Runtime Exception ( e ) ; } } finally { m_writing Hdr = _ BOOL ; } } m_is Saved = _ BOOL ; return addr ; }
public  Weak Close Listener (  Object resource ) { _resource Ref = new  Weak Reference <  Object > ( resource ) ; }
static public <  T > void shuffle (  List <  T > list ,  Random rand , int last Index ) { int i , j , size = last Index - _ NUM ; for ( i = _ NUM ; i < size ; i ++ ) { j = rand . next Int ( size - i ) + i + _ NUM ; swap ( list , i , j ) ; } }
public static long [ ] append Long ( long [ ] cur , long val ) { if ( cur == null ) { return new long [ ] { val } ; } final int  N = cur . length ; for ( int i = _ NUM ; i <  N ; i ++ ) { if ( cur [ i ] == val ) { return cur ; } } long [ ] ret = new long [  N + _ NUM ] ;  System . arraycopy ( cur , _ NUM , ret , _ NUM ,  N ) ; ret [  N ] = val ; return ret ; }
public void tear Down ( ) throws  Exception {  Throwable t = thread Failure . get And Set ( null ) ; if ( t != null ) { if ( t instanceof  Error ) throw (  Error ) t ; else if ( t instanceof  Runtime Exception ) throw (  Runtime Exception ) t ; else if ( t instanceof  Exception ) throw (  Exception ) t ; else {  Assertion Failed Error afe = new  Assertion Failed Error ( t . to String ( ) ) ; afe . init Cause ( t ) ; throw afe ; } } }
public static double sqrt ( double x ) { return  Math . sqrt ( x ) ; }
public void trim To Size ( ) { if ( count < value . length ) { char [ ] new Value = new char [ count ] ;  System . arraycopy ( value , _ NUM , new Value , _ NUM , count ) ; value = new Value ; } }
public void insert Separator ( int index ) { synchronized ( get Tree Lock ( ) ) { if ( index < _ NUM ) { throw new  Illegal Argument Exception ( _ STR ) ; } int nitems = get Item Count ( ) ;  Vector <  Menu Item > temp Items = new  Vector < > ( ) ; for ( int i = index ; i < nitems ; i ++ ) { temp Items . add Element ( get Item ( index ) ) ; remove ( index ) ; } add Separator ( ) ; for ( int i = _ NUM ; i < temp Items . size ( ) ; i ++ ) { add ( temp Items . element At ( i ) ) ; } } }
public static  String [ ] split On Char With Quoting (  String s , char split Char , char quote Char , char escape Char ) {  List <  String > result = new  Array List < > ( ) ; int i = _ NUM ; int length = s . length ( ) ;  String Builder b = new  String Builder ( ) ; while ( i < length ) { char curr = s . char At ( i ) ; if ( curr == split Char ) { if ( b . length ( ) > _ NUM ) { result . add ( b . to String ( ) ) ; b = new  String Builder ( ) ; } i ++ ; } else if ( curr == quote Char ) { i ++ ; while ( i < length ) { curr = s . char At ( i ) ; if ( curr == escape Char ) { b . append ( s . char At ( i + _ NUM ) ) ; i += _ NUM ; } else if ( curr == quote Char ) { i ++ ; break ; } else { b . append ( s . char At ( i ) ) ; i ++ ; } } } else { b . append ( curr ) ; i ++ ; } } if ( b . length ( ) > _ NUM ) { result . add ( b . to String ( ) ) ; } return result . to Array ( new  String [ _ NUM ] ) ; }
protected static void establish Mirror ( ) { if ( m_offline ) { return ; } try {  String mirror List URL = _ STR ;  URLConnection conn = null ;  URL conn URL = new  URL ( mirror List URL ) ; if (  PACKAGE_ MANAGER . set Proxy Authentication ( conn URL ) ) { conn = conn URL . open Connection (  PACKAGE_ MANAGER . get Proxy ( ) ) ; } else { conn = conn URL . open Connection ( ) ; } conn . set Connect Timeout ( _ NUM ) ; conn . set Read Timeout ( _ NUM ) ;  Buffered Reader bi = new  Buffered Reader ( new  Input Stream Reader ( conn . get Input Stream ( ) ) ) ;  REP_ MIRROR = bi . read Line ( ) ; bi . close ( ) ; if (  REP_ MIRROR != null &&  REP_ MIRROR . length ( ) > _ NUM ) { if ( !  REP_ MIRROR . equals (  PRIMARY_ REPOSITORY ) && !  USER_ SET_ REPO ) { log ( weka . core . logging .  Logger .  Level .  INFO , _ STR +  REP_ MIRROR ) ;  REP_ URL = new  URL (  REP_ MIRROR ) ; } } } catch (  Exception ex ) { log ( weka . core . logging .  Logger .  Level .  WARNING , _ STR + _ STR + ex . get Message ( ) + _ STR ) ; } }
public  Concurrent Hash Map (  Map < ? extends  K , ? extends  V > m ) { this (  Math . max ( ( int ) ( m . size ( ) /  DEFAULT_ LOAD_ FACTOR ) + _ NUM ,  DEFAULT_ INITIAL_ CAPACITY ) ,  DEFAULT_ LOAD_ FACTOR ,  DEFAULT_ CONCURRENCY_ LEVEL ) ; put All ( m ) ; }
public void handle Selector (  String selector ) { if ( ! ( selector . starts With ( _ STR ) || selector . starts With ( _ STR ) ) ) { selector = selector . to Lower Case ( ) ; } int length = selector . length ( ) ; if ( selector . ends With ( _ STR ) ) { if ( length > _ NUM ) { selector = selector . substring ( _ NUM , length - _ NUM ) ; selector Tokens . add Element ( selector ) ; } add Selector ( ) ; } else if ( length > _ NUM ) { selector Tokens . add Element ( selector ) ; } }
public void add Chunk ( byte [ ] data ) { cache . write ( data , _ NUM , data . length ) ; current Size += data . length ; }
public void load (  List <  Policy Information > policy Information ) {  Policy Information [ ] policy Information Array = policy Information . to Array ( new  Policy Information [ policy Information . size ( ) ] ) ;  Arrays . sort ( policy Information Array , new  Policy Information Comparator ( ) ) ; data = new  Object [ policy Information . size ( ) ] [ _ NUM ] ; int i = _ NUM ; for (  Policy Information policy Info : policy Information Array ) { data [ i ] [ _ NUM ] = policy Info ; i ++ ; } fire Table Data Changed ( ) ; }
private  OMGraphic List plot Data Sources (  GLOBETemp Data temperature_data ) {  Debug . message ( _ STR , _ STR ) ; int num_graphics = _ NUM ;  OMGraphic List graphics = new  OMGraphic List ( ) ; graphics . set Traverse Mode (  OMGraphic List .  LAST_ ADDED_ ON_ TOP ) ;  Enumeration site_enum = temperature_data . get All Sites ( ) ; while ( site_enum . has More Elements ( ) ) {  GLOBESite site = (  GLOBESite ) site_enum . next Element ( ) ; graphics . add ( site . get Graphic ( ) ) ; num_graphics ++ ; }  Debug . message ( _ STR , _ STR + num_graphics + _ STR ) ; return graphics ; }
public boolean matches ( ) { return regex Matcher . matches ( ) ; }
public static  String clean Virtual Host (  String host ) { host = substring Before ( host , _ STR ) ; if ( host . ends With ( _ STR ) ) { host = host . substring ( _ NUM , host . length ( ) - _ NUM ) ; } return host ; }
Map .  Entry <  K ,  V > do Remove First Entry ( ) { for ( ; ; ) {  Node <  K ,  V > b = head . node ;  Node <  K ,  V > n = b . next ; if ( n == null ) return null ;  Node <  K ,  V > f = n . next ; if ( n != b . next ) continue ;  Object v = n . value ; if ( v == null ) { n . help Delete ( b , f ) ; continue ; } if ( ! n . cas Value ( v , null ) ) continue ; if ( ! n . append Marker ( f ) || ! b . cas Next ( n , f ) ) find First ( ) ; clear Index To First ( ) ; return new  Abstract Map .  Simple Immutable Entry <  K ,  V > ( n . key , (  V ) v ) ; } }
public  Compute Task Cancelled Checked Exception (  Throwable cause ) { this ( cause . get Message ( ) , cause ) ; }
protected int normalize ( char [ ] src , int src Start , int src Limit , char [ ] dest , int dest Start , int dest Limit ,  Unicode Set nx ) { int src Len = ( src Limit - src Start ) ; int dest Len = ( dest Limit - dest Start ) ; if ( src Len > dest Len ) { return src Len ; }  System . arraycopy ( src , src Start , dest , dest Start , src Len ) ; return src Len ; }
@  Non Null private  List <  String > map Obsolete Elements (  List <  String > names ) {  List <  String > elements To Remove = new  Array List < > ( names . size ( ) ) ; for (  String name : names ) { if ( name . starts With ( _ STR ) ) continue ; elements To Remove . add ( name ) ; } return elements To Remove ; }
@  Override @  Side Effect Free public  String format Annotation String (  Collection < ? extends  Annotation Mirror > annos , boolean print Invisible ) {  String Builder sb = new  String Builder ( ) ; for (  Annotation Mirror obj : annos ) { if ( obj == null ) {  Error Reporter . error Abort ( _ STR ) ; } if ( is Invisible Qualified ( obj ) && ! print Invisible ) { continue ; } format Annotation Mirror ( obj , sb ) ; sb . append ( _ STR ) ; } return sb . to String ( ) ; }
public void remove Action (  Update Action action ) { action List . remove ( action ) ; for (  Update Manager Listener listener : listeners ) { listener . action Removed ( action ) ; } }
public static double pareto ( double alpha ) { if ( ! ( alpha > _ NUM ) ) throw new  Illegal Argument Exception ( _ STR ) ; return  Math . pow ( _ NUM - uniform ( ) , - _ NUM / alpha ) - _ NUM ; }
public  Pair <  String ,  String > next ( ) { current Header Position = next Header Position ;  Pair <  String ,  String > result = new  Pair < > ( next Header , next Sequence ) ; next Header = next Next Header ; next Header Position = next Next Header Position ; next Sequence = null ; next Next Header = null ; if ( next Header != null ) {  String a Line ; try { while ( ( a Line = r . read Line ( ) ) != null ) { if ( a Line . starts With ( _ STR ) ) { next Next Header = a Line ; next Next Header Position = position ; position += a Line . length ( ) + end Of Line Bytes ; break ; } else { position += a Line . length ( ) + end Of Line Bytes ; parts . add ( a Line ) ; } } number Of Sequences Read ++ ; } catch (  IOException e ) {  Basic . caught ( e ) ; } next Sequence =  Basic . concatenate And Remove White Spaces ( parts ) ; parts . clear ( ) ; } else try { close ( ) ; } catch (  IOException ex ) {  Basic . caught ( ex ) ; } return result ; }
private void process Non Control Characters ( char character ) {  String Buffer buffer = new  String Buffer ( ) ; buffer . append ( character ) ; while ( has Next Char ( ) ) { character = get Next Char ( ) ; if ( character == _ STR || character == _ STR || character == _ STR || character == _ STR || character == _ STR || character == _ STR || character == _ STR ) { push Back Char ( character ) ; break ; } buffer . append ( character ) ; } display New Text ( buffer . to String ( ) ) ; }
public  Group ( ) { }
protected  Storage Port check Port Exists In DB (  String native Guid ) {  Storage Port port = null ;  List <  Storage Port > port In DB =  Custom Query Utility . get Active Storage Port By Native Guid ( _db Client , native Guid ) ; if ( port In DB != null && ! port In DB . is Empty ( ) ) { port = port In DB . get ( _ NUM ) ; } return port ; }
public void prepend Split Element (  Fragment a Split ) { splits . add ( _ NUM , a Split ) ; }
public  Map Mouse Event (  Map Mouse Mode mode ,  Mouse Event me ) { super ( (  Component ) me . get Source ( ) , me . get ID ( ) , me . get When ( ) , me . get Modifiers ( ) , me . get X ( ) , me . get Y ( ) , me . get Click Count ( ) , me . is Popup Trigger ( ) ) ; if ( me . get Source ( ) instanceof  Map Bean ) { map = (  Map Bean ) me . get Source ( ) ; } map Mouse Mode = mode ; }
public void close ( ) throws  IOException { out . close ( ) ; }
protected  Connection new Connection ( ) { return new  Connection ( stream Provider ) ; }
private  String input Accrued National Number ( ) { int length Of National Number = national Number . length ( ) ; if ( length Of National Number > _ NUM ) {  String temp National Number = _ STR ; for ( int i = _ NUM ; i < length Of National Number ; i ++ ) { temp National Number = input Digit Helper ( national Number . char At ( i ) ) ; } return able To Format ? append National Number ( temp National Number ) : accrued Input . to String ( ) ; } else { return prefix Before National Number . to String ( ) ; } }
public static  String cutpoints To String ( double [ ] cut Points , boolean [ ] cut And Left ) {  String Buffer text = new  String Buffer ( _ STR ) ; if ( cut Points == null ) { text . append ( _ STR ) ; } else { text . append ( _ STR + cut Points . length + _ STR ) ; for ( int i = _ NUM ; i < cut Points . length ; i ++ ) { text . append ( _ STR + cut Points [ i ] + _ STR ) ; text . append ( _ STR + cut And Left [ i ] + _ STR ) ; } text . append ( _ STR ) ; } return text . to String ( ) ; }
public  JCaret ( final int blink Period , final  Color caret Color ) {  Preconditions . check Argument ( blink Period >= _ NUM , _ STR ) ;  Preconditions . check Not Null ( caret Color , _ STR ) ; m_caret Timer = new  Timer ( blink Period , m_listener ) ; m_caret Timer . set Repeats ( _ BOOL ) ; m_caret Timer . start ( ) ; }
public void release ( ) { }
public void cmd (  String cmd ) { cmd ( new  File (  System . get Property ( _ STR ) ) , cmd ) ; }
public void transform Point (  Object native Transform , float [ ] in , float [ ] out ) {  Affine Transform t = (  Affine Transform ) native Transform ; t . transform ( in , _ NUM , out , _ NUM , _ NUM ) ; clamp ( out ) ; }
public void test Signum Negative ( ) {  String a = _ STR ; int a Scale = _ NUM ;  Big Decimal a Number = new  Big Decimal ( new  Big Integer ( a ) , a Scale ) ; assert Equals ( _ STR , - _ NUM , a Number . signum ( ) ) ; }
public  Painter Chain add Painter (  Painter p ) { if ( chain . length != _ NUM ) {  Painter [ ] new Chain = new  Painter [ chain . length + _ NUM ] ;  System . arraycopy ( chain , _ NUM , new Chain , _ NUM , chain . length ) ; new Chain [ chain . length ] = p ; return new  Painter Chain ( new Chain ) ; } return new  Painter Chain ( new  Painter [ ] { p } ) ; }
List Based Token Stream (  List <  Attribute Source > tokens ) { this . tokens = tokens ; token Iterator = tokens . iterator ( ) ; }
@  Override public boolean swipe (  Selector obj ,  String dir , float percent , int steps ) throws  Ui Object Not Found Exception { if ( obj . to Ui Object2 ( ) == null ) { return swipe ( device . find Object ( obj . to Ui Selector ( ) ) , dir , steps ) ; } return swipe ( obj . to Ui Object2 ( ) , dir , percent , steps ) ; }
public void request Cursor ( java . awt .  Cursor cursor ) { if ( cursor == null ) { if ( show Wait Cursor && ! waiting For Layers ) reset Cursor ( ) ; current Map Bean Cursor = null ; } else if ( this . map != null ) {  Cursor new Cursor ; if ( show Wait Cursor && waiting For Layers ) { new Cursor =  Cursor . get Predefined Cursor (  Cursor .  WAIT_ CURSOR ) ; current Map Bean Cursor = cursor ; } else new Cursor = cursor ; map . set Cursor ( new Cursor ) ; } }
public static  String format Exception (  Exception exc ) {  String Writer string Writer = new  String Writer ( ) ;  Print Writer print Writer = new  Print Writer ( string Writer ) ; exc . print Stack Trace ( print Writer ) ; try { string Writer . close ( ) ; } catch (  IOException ex ) { } return string Writer . to String ( ) ; }
private  Utils ( ) { }
public static  String render (  Tree tree ) {  String Builder sb = new  String Builder ( ) ; render Tree ( tree , _ NUM , _ BOOL , _ BOOL , _ BOOL , _ BOOL , sb ) ; sb . append ( _ STR ) ; return sb . to String ( ) ; }
public  Text Editor replace All (  String regex ,  String replacement ) { if ( text . length ( ) > _ NUM ) { final  String r = replacement ;  Pattern p =  Pattern . compile ( regex ,  Pattern .  MULTILINE ) ;  Matcher m = p . matcher ( text ) ;  String Buffer sb = new  String Buffer ( ) ; while ( m . find ( ) ) { m . append Replacement ( sb , r ) ; } m . append Tail ( sb ) ; text = new  String Builder ( sb . to String ( ) ) ; } return this ; }
public boolean matches Ignore Case (  String sa ) { if ( _length != sa . length ( ) ) return _ BOOL ; char [ ] buffer = _buffer ; int offset = _offset ; for ( int i = _length - _ NUM ; i >= _ NUM ; i -- ) { char ca = buffer [ offset + i ] ; char cb = sa . char At ( i ) ; if ( ca != cb &&  Character . to Lower Case ( ca ) !=  Character . to Lower Case ( cb ) ) return _ BOOL ; } return _ BOOL ; }
protected synchronized long numchunks ( ) throws  IOException { if ( backing Random Access File . length ( ) <= f Header . header Size ( ) ) { return _ NUM ; } else { long len = backing Random Access File . length ( ) - f Header . header Size ( ) ; return ( ( ( len %  CHUNK_ ENC_ SIZE ) == _ NUM ) ? ( len /  CHUNK_ ENC_ SIZE ) : ( ( len /  CHUNK_ ENC_ SIZE ) + _ NUM ) ) ; } }
public  Dsn Layer Structure (  Collection <  Dsn Layer > p_layer_list ) { arr = new  Dsn Layer [ p_layer_list . size ( ) ] ;  Iterator <  Dsn Layer > it = p_layer_list . iterator ( ) ; for ( int i = _ NUM ; i < arr . length ; ++ i ) { arr [ i ] = it . next ( ) ; } }
public boolean is Local Server (  String server ID ) { return local Server ID . equals ( server ID ) ; }
protected  String Buffer parse String (  String Buffer sbuf ) throws  IOException { int ch = read ( ) ; for ( ; ch >= _ NUM && ch != _ STR ; ch = read ( ) ) { if ( ch == _ STR ) { ch = read ( ) ; if ( ch == _ STR ) { ch = read ( ) ; if ( ch >= _ STR && ch <= _ STR ) { int v = _ NUM ; for ( ; ch >= _ STR && ch <= _ STR ; ch = read ( ) ) { v = _ NUM * v + ch - _ STR ; } sbuf . append ( ( char ) v ) ; } } else {  String Buffer entity Buffer = new  String Buffer ( ) ; for ( ; ch >= _ STR && ch <= _ STR ; ch = read ( ) ) entity Buffer . append ( ( char ) ch ) ;  String entity = entity Buffer . to String ( ) ; if ( entity . equals ( _ STR ) ) sbuf . append ( _ STR ) ; else if ( entity . equals ( _ STR ) ) sbuf . append ( _ STR ) ; else if ( entity . equals ( _ STR ) ) sbuf . append ( _ STR ) ; else if ( entity . equals ( _ STR ) ) sbuf . append ( _ STR ) ; else if ( entity . equals ( _ STR ) ) sbuf . append ( _ STR ) ; else throw new  Burlap Protocol Exception ( _ STR + entity + _ STR + ( char ) ch + _ STR ) ; } if ( ch != _ STR ) throw expected Char ( _ STR , ch ) ; } else if ( ch < _ NUM ) sbuf . append ( ( char ) ch ) ; else if ( ( ch & _ NUM ) == _ NUM ) { int ch1 = read ( ) ; int v = ( ( ch & _ NUM ) << _ NUM ) + ( ch1 & _ NUM ) ; sbuf . append ( ( char ) v ) ; } else if ( ( ch & _ NUM ) == _ NUM ) { int ch1 = read ( ) ; int ch2 = read ( ) ; int v = ( ( ch & _ NUM ) << _ NUM ) + ( ( ch1 & _ NUM ) << _ NUM ) + ( ch2 & _ NUM ) ; sbuf . append ( ( char ) v ) ; } else throw new  Burlap Protocol Exception ( _ STR ) ; } peek = ch ; return sbuf ; }
public  String to Plain ( ) {  String Buffer sb = new  String Buffer ( ) ; int length = size ( ) ; for ( int i = _ NUM ; i <= length ; i ++ ) { sb . append ( i ) ; sb . append ( _ STR ) ; sb . append ( get ( i - _ NUM , null ) ) ; sb . append ( _ STR ) ; } return sb . to String ( ) ; }
public static  Required Graph Model serializable Instance ( ) { return new  Required Graph Model ( new  Parameters ( ) ,  Graph Wrapper . serializable Instance ( ) ) ; }
void drop ( ) ;
private  Segment create Mapped Segment (  Segment Descriptor descriptor ) {  File segment File =  Segment File . create Segment File ( name , storage . directory ( ) , descriptor . id ( ) , descriptor . version ( ) ) ;  Buffer buffer =  Mapped Buffer . allocate ( segment File ,  Math . min (  DEFAULT_ BUFFER_ SIZE , descriptor . max Segment Size ( ) ) ,  Integer .  MAX_ VALUE ) ; descriptor . copy To ( buffer ) ;  Segment segment = new  Segment ( new  Segment File ( segment File ) , buffer . slice ( ) , descriptor , create Index ( descriptor ) , new  Offset Predicate ( ) , serializer . clone ( ) , this ) ;  LOGGER . debug ( _ STR , segment ) ; return segment ; }
public void add Person (  Id person ) { boarding At Facility . add ( person ) ; if ( rule . gets Seat On Enter ( person , vehicle , sitting Persons . size ( ) , standing Persons . size ( ) ) ) { add Sitting ( person ) ; } else { add Standing ( person ) ; } }
public synchronized boolean retain All (  Collection c ) {  Object [ ] elements = get Array ( ) ; int len = elements . length ; if ( len != _ NUM ) { int newlen = _ NUM ;  Object [ ] temp = new  Object [ len ] ; for ( int i = _ NUM ; i < len ; ++ i ) {  Object element = elements [ i ] ; if ( c . contains ( element ) ) temp [ newlen ++ ] = element ; } if ( newlen != len ) { set Array ( copy Of Range ( temp , _ NUM , newlen ,  Object [ ] . class ) ) ; return _ BOOL ; } } return _ BOOL ; }
private double max Ignore Na N ( double a , double b ) { if (  Double . is Na N ( a ) ) { return b ; } if (  Double . is Na N ( b ) ) { return a ; } return  Math . max ( a , b ) ; }
public void crab Down Dir Block For Read (  Block Id blk ) { lock Tbl . s Lock ( blk , tx Num ) ; read Index Blks . add ( blk ) ; }
public  Connection put Connection (  Connection connection ) { return connections . put ( connection . get Identifier ( ) , connection ) ; }
public static boolean is Letter Or Digit ( char c ) { return  Character . is Letter Or Digit ( c ) ; }
public void jump To State ( @  Nonnull  State new State ) { m State Lock . lock ( ) ; try { if ( new State . equals ( m State ) ) {  Log . d (  TAG , _ STR ) ; } else {  Log . d (  TAG , _ STR + m State + _ STR + new State ) ; m State . on Leave ( ) ; m State = new State ;  Optional <  State > next State = m State . on Enter ( ) ; while ( next State . is Present ( ) ) {  Log . d (  TAG , _ STR + m State + _ STR + next State . get ( ) ) ; m State . on Leave ( ) ; m State = next State . get ( ) ; next State = m State . on Enter ( ) ; } m State Changed Condition . signal All ( ) ; } } finally { m State Lock . unlock ( ) ; } }
public void generate (  Batch Environment env ,  Class Doc input Class ,  File dest Dir ) {  Remote Class remote Class =  Remote Class . for Class ( env , input Class ) ; if ( remote Class == null ) { return ; }  Stub Skeleton Writer writer = new  Stub Skeleton Writer ( env , remote Class , version ) ;  File stub File = source File For Class ( writer . stub Class Name ( ) , dest Dir ) ; try {  Indenting Writer out = new  Indenting Writer ( new  Output Stream Writer ( new  File Output Stream ( stub File ) ) ) ; writer . write Stub ( out ) ; out . close ( ) ; if ( env . verbose ( ) ) { env . output (  Resources . get Text ( _ STR , stub File . get Path ( ) ) ) ; } env . add Generated File ( stub File ) ; } catch (  IOException e ) { env . error ( _ STR , stub File . to String ( ) ) ; return ; }  File skeleton File = source File For Class ( writer . skeleton Class Name ( ) , dest Dir ) ; if ( version ==  Stub Version .  V1_1 || version ==  Stub Version .  VCOMPAT ) { try {  Indenting Writer out = new  Indenting Writer ( new  Output Stream Writer ( new  File Output Stream ( skeleton File ) ) ) ; writer . write Skeleton ( out ) ; out . close ( ) ; if ( env . verbose ( ) ) { env . output (  Resources . get Text ( _ STR , skeleton File . get Path ( ) ) ) ; } env . add Generated File ( skeleton File ) ; } catch (  IOException e ) { env . error ( _ STR , skeleton File . to String ( ) ) ; return ; } } else {  File skeleton Class File = class File For Class ( writer . skeleton Class Name ( ) , dest Dir ) ; skeleton File . delete ( ) ; skeleton Class File . delete ( ) ; } }
public void add Point ( final  T point ) { points . add ( point ) ; }
public  Exif Util (  Exif Interface exif ) { m Exif = exif ; }
public static int bytes To Int ( final byte [ ] bytes ) { final  Byte Buffer buffer =  Byte Buffer . allocate ( _ NUM ) ; buffer . put ( bytes , _ NUM , _ NUM ) ; buffer . flip ( ) ; return buffer . get Int ( ) ; }
@  Override public void mouse Released (  Mouse Event evt ) { delegate . mouse Moved ( evt ) ; }
public static  String remove Formatting (  String line ) { int length = line . length ( ) ;  String Buffer buffer = new  String Buffer ( ) ; for ( int i = _ NUM ; i < length ; i ++ ) { char ch = line . char At ( i ) ; if ( ch == _ STR || ch == _ STR || ch == _ STR || ch == _ STR ) { } else { buffer . append ( ch ) ; } } return buffer . to String ( ) ; }
private  Priority Queue <  Facility Charging Price > update Charging Price (  Priority Queue <  Facility Charging Price > charging Price ) { while ( last Charging Price Parking Index < max Chargable Energy . size ( ) && get Minimum Energy That Needs To Be Charged ( ) <= _ NUM ) { charging Price = add New Parking Charging Prices ( last Charging Price Parking Index , charging Price ) ; last Charging Price Parking Index ++ ; } return charging Price ; }
public boolean is Empty ( ) { return list . is Empty ( ) ; }
public void add Exception Context (  Exception Context exception Context ) {  Exception Message most Recent ; most Recent = m_exception Messages . last Element ( ) ; if ( null != most Recent ) { most Recent . add Exception Context ( exception Context ) ; } else { m_exception Contexts . add Element ( exception Context ) ; } if ( null != m_nested Exception ) {  Enumeration < ? > enumeration ; enumeration = m_nested Exception . get All Exception Messages ( ) ;  Exception Message exception Message ; while ( enumeration . has More Elements ( ) ) { exception Message = (  Exception Message ) enumeration . next Element ( ) ; exception Message . add Exception Context ( exception Context ) ; } } }
public  Service Config create Global Config (  Map attrs ) throws  SMSException ,  SSOException { validate SSM ( ) ;  Service Schema Impl ss = ssm . get Schema (  Schema Type .  GLOBAL ) ; if ( ss == null ) {  String [ ] args = { service Name } ; throw ( new  SMSException (  IUMSConstants .  UMS_ BUNDLE_ NAME , _ STR , args ) ) ; }  String org DN = scm . construct Service Config DN (  SMSUtils .  DEFAULT ,  Create Service Config .  GLOBAL_ CONFIG_ NODE , null ) ; try {  Create Service Config . create Sub Config Entry ( token , org DN , ss , null , null , attrs ,  SMSEntry . base DN ) ; } catch (  Service Already Exists Exception slee ) { } return ( get Global Config ( null ) ) ; }
public void delete Circle Of Trust (  String realm ,  String cot Name ) throws  COTException {  String class Method = _ STR ; if ( realm == null ) { realm = _ STR ; }  String [ ] data = { cot Name , realm } ; is Valid COTName ( realm , cot Name ) ; try {  Set trust Providers = null ;  Map attrs = config Inst . get Configuration ( realm , cot Name ) ; if ( attrs != null ) {  Circle Of Trust Descriptor cot Desc = new  Circle Of Trust Descriptor ( cot Name , realm , attrs ) ; trust Providers = cot Desc . get Trusted Providers ( ) ; } if ( attrs == null || trust Providers == null || trust Providers . is Empty ( ) ) { config Inst . delete Configuration ( realm , cot Name , null ) ;  Log Util . access (  Level .  INFO ,  Log Util .  COT_ DESCRIPTOR_ DELETED , data ) ; } else { debug . error ( class Method + _ STR + _ STR ) ;  Log Util . error (  Level .  INFO ,  Log Util .  HAS_ ENTITIES_ DELETE_ COT_ DESCRIPTOR , data ) ;  String [ ] args = { cot Name , realm } ; throw new  COTException ( _ STR , args ) ; } } catch (  Configuration Exception e ) { debug . error ( class Method , e ) ;  String [ ] args = { e . get Message ( ) , cot Name , realm } ;  Log Util . error (  Level .  INFO ,  Log Util .  CONFIG_ ERROR_ DELETE_ COT_ DESCRIPTOR , args ) ; throw new  COTException ( e ) ; } }
protected void add Source Code Remark On Attribute (  Test Solution test Solution ,  Element element ,  String message Code ,  String attribute Name ) { if ( attribute Name != null ) {  Collection <  Evidence Element > evidence Element List = new  Array List < > ( ) ;  Evidence Element ee = get Evidence Element (  Evidence Store .  TARGETTED_ ELEMENT_ FROM_ SCOPE_ EE , attribute Name ) ; evidence Element List . add ( ee ) ; process Remark Service . add Source Code Remark On Element ( test Solution , element , message Code , evidence Element List ) ; } }
public  Builder add Action (  String action Type ,  Action action ) { m Actions . add ( new  Action Pair ( action Type , action ) ) ; return this ; }
public  Future <  Void > update Table Entity Async (  Table Entity table Entity , boolean commit ) { update Table Entity ( table Entity , commit ) ; return new  Async Result <  Void > ( null ) ; }
private  Environment Logger build Parent Tree (  String child Name ) { if ( child Name == null || child Name . equals ( _ STR ) ) return null ; int p = child Name . last Index Of ( _ STR ) ;  String parent Name ; if ( p > _ NUM ) parent Name = child Name . substring ( _ NUM , p ) ; else parent Name = _ STR ;  Environment Logger parent = null ;  Soft Reference <  Environment Logger > parent Ref = _env Loggers . get ( parent Name ) ; if ( parent Ref != null ) parent = parent Ref . get ( ) ; if ( parent != null ) return parent ; else { parent = new  Environment Logger ( parent Name , null ) ; _env Loggers . put ( parent Name , new  Soft Reference <  Environment Logger > ( parent ) ) ;  Environment Logger grandparent = build Parent Tree ( parent Name ) ; if ( grandparent != null ) parent . set Parent ( grandparent ) ; return parent ; } }
public void add On Tag Select Listener (  Tags Select Listener listener ) { if ( select Listeners == null ) { select Listeners = new  Array List < > ( ) ; } select Listeners . add ( listener ) ; }
private  String rate Labels2 Relative Values (  String rate Attribute ) { if ( rate Attribute . equals ( _ STR ) ) { return _ STR ; } else if ( rate Attribute . equals ( _ STR ) ) { return _ STR ; } else if ( rate Attribute . equals ( _ STR ) ) { return _ STR ; } else if ( rate Attribute . equals ( _ STR ) ) { return _ STR ; } else if ( rate Attribute . equals ( _ STR ) ) { return _ STR ; } return _ STR ; }
public void start ( ) throws  IOException { this . is Running = _ BOOL ;  Thread thread = new  Thread ( this ) ; thread . set Daemon ( _ BOOL ) ; thread . set Name ( _ STR ) ; thread . set Priority (  Thread .  MAX_ PRIORITY ) ; thread . start ( ) ; }
public static synchronized byte [ ] generate Nonce ( int length ) throws  No Such Algorithm Exception { if ( random == null ) { random =  Secure Random . get Instance ( _ STR ) ; } byte [ ] temp = new byte [ length ] ; random . next Bytes ( temp ) ; return temp ; }
public <  T >  T to Nova (  Object native Object ) {  Objects . require Non Null ( native Object ) ;  Native Converter converter = find Converter ( native Converters , native Object ) ; if ( converter == null ) { throw new  Native Exception ( _ STR + native Object + _ STR + native Object . get Class ( ) + _ STR ) ; } return (  T ) converter . to Nova ( native Object ) ; }
protected static  String serialize DOMSource (  DOMSource dom Source ) { try {  String Writer writer = new  String Writer ( ) ;  Stream Result result = new  Stream Result ( writer ) ;  Transformer Factory tf =  Transformer Factory . new Instance ( ) ;  Transformer transformer = tf . new Transformer ( ) ; transformer . set Output Property (  Output Keys .  ENCODING ,  DEFAULT_ ENCODING ) ; transformer . set Output Property (  Output Keys .  INDENT ,  DEFAULT_ INDENT ) ; transformer . transform ( dom Source , result ) ; writer . flush ( ) ; return writer . to String ( ) ; } catch (  Throwable e ) { log . log (  Level .  SEVERE , _ STR , e ) ; } return null ; }
public  List <  Server Address > addresses ( ) { return addresses ; }
public static boolean is Boolean (  String str ) { return str . equals ( _ STR ) || str . equals ( _ STR ) || str . equals ( _ STR ) || str . equals ( _ STR ) ; }
public static byte [ ] instrument ( byte [ ] original Bytes ,  String recorder Class ,  String recorder Method ,  Class Loader loader ) { try {  Class Reader cr = new  Class Reader ( original Bytes ) ;  Class Writer cw = new  Static Class Writer ( cr ,  Class Writer .  COMPUTE_ FRAMES , loader ) ;  Verifying Class Adapter vcw = new  Verifying Class Adapter ( cw , original Bytes , cr . get Class Name ( ) ) ;  Class Visitor adapter = new  Allocation Class Adapter ( vcw , recorder Class , recorder Method ) ; cr . accept ( adapter ,  Class Reader .  SKIP_ FRAMES ) ; return vcw . to Byte Array ( ) ; } catch (  Runtime Exception e ) { logger . log (  Level .  WARNING , _ STR , e ) ; throw e ; } catch (  Error e ) { logger . log (  Level .  WARNING , _ STR , e ) ; throw e ; } }
public boolean use Addresses ( ) { boolean use Addr = _ BOOL ;  String value = get ( _ STR , _ STR ) ; use Addr = ( value != null && value . equals Ignore Case ( _ STR ) ) ; if ( use Addr == _ BOOL ) { value = get ( _ STR , _ STR ) ; use Addr = ( value != null && value . equals Ignore Case ( _ STR ) ) ; } return use Addr ; }
public static void main (  String [ ] args ) { main ( suite ( ) , args ) ; }
public  Feature Definition subset (  String [ ] feature Names To Drop ) {  List <  Integer > feature Indices To Drop = new  Array List <  Integer > ( ) ; for (  String feature Name : feature Names To Drop ) { int feature Index ; try { feature Index = get Feature Index ( feature Name ) ; feature Indices To Drop . add ( feature Index ) ; } catch (  Illegal Argument Exception e ) {  System . err . println ( _ STR + feature Name + _ STR ) ; } }  Feature Definition sub Definition = null ; try {  Byte Array Output Stream to Memory = new  Byte Array Output Stream ( ) ;  Data Output output = new  Data Output Stream ( to Memory ) ; write Binary To ( output , feature Indices To Drop ) ; byte [ ] memory = to Memory . to Byte Array ( ) ;  Byte Array Input Stream from Memory = new  Byte Array Input Stream ( memory ) ;  Data Input input = new  Data Input Stream ( from Memory ) ; sub Definition = new  Feature Definition ( input ) ; } catch (  IOException e ) { e . print Stack Trace ( ) ; } assert this . contains ( sub Definition ) ; return sub Definition ; }
public boolean is Shutdown ( ) { return shutdown . get ( ) ; }
public static  Buffered Image create Image (  Image Producer producer ) {  Pixel Grabber pg = new  Pixel Grabber ( producer , _ NUM , _ NUM , - _ NUM , - _ NUM , null , _ NUM , _ NUM ) ; try { pg . grab Pixels ( ) ; } catch (  Interrupted Exception e ) { throw new  Runtime Exception ( _ STR ) ; } if ( ( pg . status ( ) &  Image Observer .  ABORT ) != _ NUM ) throw new  Runtime Exception ( _ STR ) ; if ( ( pg . status ( ) &  Image Observer .  ERROR ) != _ NUM ) throw new  Runtime Exception ( _ STR ) ;  Buffered Image p = new  Buffered Image ( pg . get Width ( ) , pg . get Height ( ) ,  Buffered Image .  TYPE_ INT_ ARGB ) ; p . set RGB ( _ NUM , _ NUM , pg . get Width ( ) , pg . get Height ( ) , ( int [ ] ) pg . get Pixels ( ) , _ NUM , pg . get Width ( ) ) ; return p ; }
private static short  Call Nonvirtual Short Method V (  JNIEnvironment env , int obj JREF , int class JREF , int method ID ,  Address arg Address ) throws  Exception { if ( trace JNI )  VM . sys Write ( _ STR ) ;  Runtime Entrypoints . check JNICount Down To GC ( ) ; try {  Object obj = env . get JNIRef ( obj JREF ) ;  Object return Obj =  JNIHelpers . invoke With Var Arg ( obj , method ID , arg Address ,  Type Reference .  Short , _ BOOL ) ; return  Reflection . unwrap Short ( return Obj ) ; } catch (  Throwable unexpected ) { if ( trace JNI ) unexpected . print Stack Trace (  System . err ) ; env . record Exception ( unexpected ) ; return _ NUM ; } }
public static int [ ] minus ( int y1 [ ] , int y2 [ ] ) { int keep [ ] = new int [  Math . max ( y1 . length , y2 . length ) ] ; int i = _ NUM , j = _ NUM , k = _ NUM ; while ( j < y1 . length && k < y2 . length ) { if ( y1 [ j ] == y2 [ k ] ) { j ++ ; k ++ ; } else if ( y1 [ j ] < y2 [ k ] ) { keep [ i ++ ] = y1 [ j ] ; j ++ ; } else { k ++ ; } } while ( j < y1 . length ) { keep [ i ++ ] = y1 [ j ++ ] ; } return  Arrays . copy Of ( keep , i ) ; }
public  Segment ( int marker ) throws  IOException { this . marker = marker ; if ( marker != _ NUM ) { out . write Short ( marker ) ; offset = get Stream Position ( ) ; if ( ! standalone Markers . contains ( marker ) ) { out . write Short ( _ NUM ) ; } } }
int parse Tr Block Content ( int current Offset , char open Quote , char close Quote ) { int block Start Offset = current Offset ;  Char Sequence buffer = get Buffer ( ) ; int buffer End = get Buffer End ( ) ; boolean is Escaped = _ BOOL ; boolean is Quote Differs = open Quote != close Quote ; int quotes Level = _ NUM ; while ( current Offset < buffer End ) { char current Char = buffer . char At ( current Offset ) ; if ( ! is Escaped && quotes Level == _ NUM && current Char == close Quote ) { if ( current Offset > block Start Offset ) { push Preparsed Token ( block Start Offset , current Offset ,  STRING_ CONTENT ) ; } break ; } if ( is Quote Differs && ! is Escaped ) { if ( current Char == open Quote ) { quotes Level ++ ; } else if ( current Char == close Quote ) { quotes Level -- ; } } is Escaped = ( current Char == _ STR && ! is Escaped ) ; current Offset ++ ; } return current Offset ; }
public static  String value Of ( int value ) { return  Integer . to String ( value ) ; }
private  String split Name Without Gzip Extension (  String split ) throws  IOException { if ( split == null ) { throw new  IOException ( _ STR ) ; } if ( split . ends With ( _ STR ) ) { return split . substring ( _ NUM , split . length ( ) - _ NUM ) ; } return split ; }
public void initialize (  Context context ,  Haptic Feedback Controller haptic Feedback Controller , int initial Hours Of Day , int initial Minutes , boolean is24 Hour Mode ) { if ( m Time Initialized ) {  Log . e (  TAG , _ STR ) ; return ; } m Haptic Feedback Controller = haptic Feedback Controller ; m Is24 Hour Mode = is24 Hour Mode ; m Hide Am Pm = m Accessibility Manager . is Touch Exploration Enabled ( ) || m Is24 Hour Mode ; m Circle View . initialize ( context , m Hide Am Pm ) ; m Circle View . invalidate ( ) ; if ( ! m Hide Am Pm ) { m Am Pm Circles View . initialize ( context , initial Hours Of Day < _ NUM ?  AM :  PM ) ; m Am Pm Circles View . invalidate ( ) ; }  Resources res = context . get Resources ( ) ; int [ ] hours = { _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM } ; int [ ] hours_24 = { _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM } ; int [ ] minutes = { _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM } ;  String [ ] hours Texts = new  String [ _ NUM ] ;  String [ ] inner Hours Texts = new  String [ _ NUM ] ;  String [ ] minutes Texts = new  String [ _ NUM ] ; for ( int i = _ NUM ; i < _ NUM ; i ++ ) { hours Texts [ i ] =  Language Utils . get Persian Numbers ( is24 Hour Mode ?  String . format ( _ STR , hours_24 [ i ] ) :  String . format ( _ STR , hours [ i ] ) ) ; inner Hours Texts [ i ] =  Language Utils . get Persian Numbers (  String . format ( _ STR , hours [ i ] ) ) ; minutes Texts [ i ] =  Language Utils . get Persian Numbers (  String . format ( _ STR , minutes [ i ] ) ) ; } m Hour Radial Texts View . initialize ( res , hours Texts , ( is24 Hour Mode ? inner Hours Texts : null ) , m Hide Am Pm , _ BOOL ) ; m Hour Radial Texts View . set Selection ( is24 Hour Mode ? initial Hours Of Day : initial Hours Of Day % _ NUM ) ; m Hour Radial Texts View . invalidate ( ) ; m Minute Radial Texts View . initialize ( res , minutes Texts , null , m Hide Am Pm , _ BOOL ) ; m Minute Radial Texts View . set Selection ( initial Minutes ) ; m Minute Radial Texts View . invalidate ( ) ; set Value For Item (  HOUR_ INDEX , initial Hours Of Day ) ; set Value For Item (  MINUTE_ INDEX , initial Minutes ) ; int hour Degrees = ( initial Hours Of Day % _ NUM ) *  HOUR_ VALUE_ TO_ DEGREES_ STEP_ SIZE ; m Hour Radial Selector View . initialize ( context , m Hide Am Pm , is24 Hour Mode , _ BOOL , hour Degrees , is Hour Inner Circle ( initial Hours Of Day ) ) ; int minute Degrees = initial Minutes *  MINUTE_ VALUE_ TO_ DEGREES_ STEP_ SIZE ; m Minute Radial Selector View . initialize ( context , m Hide Am Pm , _ BOOL , _ BOOL , minute Degrees , _ BOOL ) ; m Time Initialized = _ BOOL ; }
protected void linear Layout (  Visual Table labels ) {  Rectangle2 D b = get Layout Bounds ( ) ; double breadth = get Breadth ( b ) ; double span = m_hi - m_lo ; double pspan = m_prevhi - m_prevlo ; double vlo = _ NUM ; if ( m_lo >= _ NUM ) { vlo =  Math . pow ( _ NUM ,  Math . floor (  Math Lib . log10 ( m_lo ) ) ) ; } else { vlo = -  Math . pow ( _ NUM , _ NUM +  Math . floor (  Math Lib . log10 ( - m_lo ) ) ) ; }  Iterator iter = labels . tuples ( ) ; while ( iter . has Next ( ) ) {  Visual Item item = (  Visual Item ) iter . next ( ) ; reset ( item ) ; double v = item . get Double (  VALUE ) ; double x = span == _ NUM ? _ NUM : ( ( v - m_lo ) / span ) * breadth ; set ( item , x , b ) ; }  Index index = labels . index (  VALUE ) ; double step = get Linear Step ( span , span == _ NUM ? _ NUM : breadth / span ) ; if ( step == _ NUM ) step = _ NUM ; int r ; for ( double x , v = vlo ; v <= m_hi ; v += step ) { x = ( ( v - m_lo ) / span ) * breadth ; if ( x < - _ NUM ) { continue ; } else if ( ( r = index . get ( v ) ) >= _ NUM ) {  Visual Item item = labels . get Item ( r ) ; item . set Visible ( _ BOOL ) ; item . set End Visible ( _ BOOL ) ; } else {  Visual Item item = labels . add Item ( ) ; item . set (  LABEL , m_nf . format ( v ) ) ; item . set Double (  VALUE , v ) ; double f = pspan == _ NUM ? _ NUM : ( ( v - m_prevlo ) / pspan ) ; if ( f <= _ NUM || f >= _ NUM ) item . set Start Visible ( _ BOOL ) ; set ( item , f * breadth , b ) ; set ( item , x , b ) ; } } }
public  Template find Template (  String name ) { return find Template ( name , null ) ; }
Cache Key (  String field ,  Object custom ) { this . field = field ; this . custom = custom ; }
public static  Map <  String ,  Map <  String ,  Map <  String ,  Object > > > prepare Field (  Map <  String , ? > input Fields ,  Map <  String ,  Object > query String Map ,  Map <  String ,  List <  Object [ ] > > orig Value Map ) {  Map <  String ,  Map <  String ,  Map <  String ,  Object > > > normalized Fields = new  Linked Hash Map <  String ,  Map <  String ,  Map <  String ,  Object > > > ( ) ; for (  String field Name Raw : input Fields . key Set ( ) ) {  String field Name Root = null ;  String field Pair = null ;  Object field Value = null ; int i Pos = - _ NUM ; int i Pos2 = - _ NUM ;  Map <  String ,  Map <  String ,  Object > > sub Map = null ;  Map <  String ,  Object > sub Map2 = null ;  String field Mode = null ; field Value = input Fields . get ( field Name Raw ) ; if (  Object Type . is Empty ( field Value ) ) { continue ; } query String Map . put ( field Name Raw , field Value ) ; i Pos = field Name Raw . index Of ( _ STR ) ; if ( i Pos >= _ NUM ) {  String suffix = field Name Raw . substring ( i Pos + _ NUM ) ; i Pos2 = suffix . index Of ( _ STR ) ; if ( i Pos2 == _ NUM ) { continue ; } } if ( i Pos < _ NUM ) { field Name Root = field Name Raw ; field Pair = _ STR ; field Mode = _ STR ; } else { field Name Root = field Name Raw . substring ( _ NUM , i Pos ) ;  String suffix = field Name Raw . substring ( i Pos + _ NUM ) ; i Pos2 = suffix . index Of ( _ STR ) ; if ( i Pos2 < _ NUM ) { if ( suffix . starts With ( _ STR ) ) { field Pair = suffix ; field Mode = _ STR ; } else { field Pair = _ STR ; field Mode = suffix ; } } else {  String tkn0 = suffix . substring ( _ NUM , i Pos2 ) ;  String tkn1 = suffix . substring ( i Pos2 + _ NUM ) ; if ( tkn0 . starts With ( _ STR ) ) { field Pair = tkn0 ; field Mode = tkn1 ; } else { field Pair = tkn1 ; field Mode = tkn0 ; } } } sub Map = normalized Fields . get ( field Name Root ) ; if ( sub Map == null ) { sub Map = new  Linked Hash Map <  String ,  Map <  String ,  Object > > ( ) ; normalized Fields . put ( field Name Root , sub Map ) ; } sub Map2 = sub Map . get ( field Pair ) ; if ( sub Map2 == null ) { sub Map2 = new  Linked Hash Map <  String ,  Object > ( ) ; sub Map . put ( field Pair , sub Map2 ) ; } sub Map2 . put ( field Mode , field Value ) ;  List <  Object [ ] > orig List = orig Value Map . get ( field Name Root ) ; if ( orig List == null ) { orig List = new  Linked List <  Object [ ] > ( ) ; orig Value Map . put ( field Name Root , orig List ) ; }  Object [ ] orig Values = { field Name Raw , field Value } ; orig List . add ( orig Values ) ; } return normalized Fields ; }
public static boolean is Extension (  String filename ,  Collection <  String > extensions ) { if ( filename == null ) { return _ BOOL ; } if ( extensions == null || extensions . is Empty ( ) ) { return index Of Extension ( filename ) == - _ NUM ; }  String file Ext = get Extension ( filename ) ; for (  String extension : extensions ) { if ( file Ext . equals ( extension ) ) { return _ BOOL ; } } return _ BOOL ; }
public void post (  String path ) throws  IOException ,  Http Response Exception { post ( path , null , null ) ; }
public void close ( ) { try { file . close ( ) ; } catch (  IOException ignore ) { } }
private  Optional <  Class < ? > > unwrap (  Object page Object ) {  Class < ? > wrapped Class = page Object . get Class ( ) ; while ( wrapped Class != null && ! wrapped Class . is Annotation Present (  Page Object . class ) ) { wrapped Class = wrapped Class . get Superclass ( ) ; } return  Optional . of Nullable ( wrapped Class ) ; }
private boolean is Ready To Be Executed Locked (  Job Status job ) { final boolean job Ready = job . is Ready ( ) ; final boolean job Pending = m Pending Jobs . contains ( job ) ; final boolean job Active = is Currently Active Locked ( job ) ; final boolean user Running = m Started Users . contains ( job . get User Id ( ) ) ; return user Running && job Ready && ! job Pending && ! job Active ; }
public void text ( int [ ] glyph Indices , int [ ] glyph Advances ) { int [ ] codes = ( int [ ] ) font Codes . get ( font Id ) ; if ( codes == null ) { return ; } char [ ] chars = new char [ glyph Indices . length ] ; for ( int i = _ NUM ; i < chars . length ; i ++ ) { int index = glyph Indices [ i ] ; if ( index >= codes . length ) { chars [ i ] = ( char ) index ; } else { chars [ i ] = ( char ) ( codes [ index ] ) ; } } output . print ( chars ) ; }
public int count ( ) { int count = _ NUM ; @  Suppress Warnings ( _ STR )  List <  Long > counts = find ( _ STR + entity Class . get Name ( ) ) ; if ( counts != null ) for (  Long c : counts ) count += c ; return count ; }
public void remove Method (  Soot Method m ) { check Level (  SIGNATURES ) ; if ( ! m . is Declared ( ) || m . get Declaring Class ( ) != this ) throw new  Runtime Exception ( _ STR + m . get Name ( ) ) ; if ( sub Sig To Methods . get ( m . get Numbered Sub Signature ( ) ) == null ) { throw new  Runtime Exception ( _ STR + m . get Sub Signature ( ) + _ STR + this ) ; } sub Sig To Methods . put ( m . get Numbered Sub Signature ( ) , null ) ; method List . remove ( m ) ; m . set Declared ( _ BOOL ) ; }
protected void test Get ( ) throws  Throwable {  Operation op =  Operation . create Get (  URI . create ( echo Service Uri ) ) ; test Echo Operation ( op ) ; }
public  Cache Object load (  Object key , int x , int y , int zoom Level ,  Projection proj ) { if ( key instanceof  String ) {  String image Path = (  String ) key ; if ( verbose ) { logger . fine ( _ STR + image Path ) ; } try {  URL image URL =  Prop Utils . get Resource Or File Or URL ( image Path ) ; if ( image URL != null ) {  Buffered Image bi =  Buffered Image Helper . get Buffered Image ( image URL ) ;  OMGraphic raster = create OMGraphic From Buffered Image ( bi , x , y , zoom Level , proj ) ; if ( raster != null ) { return new  Cache Object ( image Path , raster ) ; } } else { logger . fine ( _ STR + image Path ) ; } } catch (  Malformed URLException e ) { logger . fine ( _ STR + image Path ) ; } catch (  Interrupted Exception e ) { logger . fine ( _ STR + image Path ) ; } catch (  Exception fnfe ) { logger . fine ( _ STR + image Path ) ; } } return null ; }
protected int decode Line Prefix (  Pushback Input Stream in Stream ,  Output Stream out Stream ) throws  IOException { int c ; c = in Stream . read ( ) ; if ( c == _ STR ) { c = in Stream . read ( ) ; c = in Stream . read ( ) ; if ( ( c != _ STR ) && ( c != - _ NUM ) ) in Stream . unread ( c ) ; throw new  CEStream Exhausted ( ) ; } else if ( c == - _ NUM ) { throw new  CEFormat Exception ( _ STR ) ; } c = ( c - _ STR ) & _ NUM ; if ( c > bytes Per Line ( ) ) { throw new  CEFormat Exception ( _ STR ) ; } return ( c ) ; }
public  SIPServer Transaction create Server Transaction (  Message Channel encapsulated Message Channel ) { if ( unlimited Server Transaction Table Size ) { return new  SIPServer Transaction ( this , encapsulated Message Channel ) ; } else { float threshold = ( ( float ) ( server Transaction Table . size ( ) - server Transaction Table Lowater Mark ) ) / ( ( float ) ( server Transaction Table Highwater Mark - server Transaction Table Lowater Mark ) ) ; boolean decision =  Math . random ( ) > _ NUM - threshold ; if ( decision ) { return null ; } else { return new  SIPServer Transaction ( this , encapsulated Message Channel ) ; } } }
public void remove Method (  Soot Method method ) { methods . remove ( method ) ; }
public static  QName value Of (  Char Sequence name ) {  QName q Name = (  QName )  FULL_ NAME_ TO_ QNAME . get ( name ) ; return ( q Name != null ) ? q Name :  QName . create No Namespace ( name . to String ( ) ) ; }
public boolean is Item ( ) { if ( m_is Item != null ) return m_is Item . boolean Value ( ) ; m_is Item =  Boolean .  FALSE ; if ( get M_ Product_ ID ( ) != _ NUM ) {  MProduct product =  MProduct . get (  Env . get Ctx ( ) , get M_ Product_ ID ( ) ) ; if ( product . get_ ID ( ) == get M_ Product_ ID ( ) && product . is Item ( ) ) m_is Item =  Boolean .  TRUE ; } return m_is Item . boolean Value ( ) ; }
private void rewrite Save File (  Iterable <  Track Point > data ) {  File Output Stream file Output = null ;  Data Output Stream out = null ; try { file Output = ctx . open File Output (  SAVEFILE ,  Context .  MODE_ PRIVATE ) ; out = new  Data Output Stream ( new  Buffered Output Stream ( file Output ) ) ; out . write Int (  Track Point .  FORMAT_ VERSION ) ; for (  Track Point point : data ) { point . to Stream ( out ) ; } } catch (  Exception e ) { mark Saving Broken ( _ STR , e ) ; } finally {  Saving Helper . close ( out ) ; } }
public static  Commit Version Info build (  Index Commit commit ) { long generation = commit . get Generation ( ) ; long version = _ NUM ; try { final  Map <  String ,  String > commit Data = commit . get User Data ( ) ;  String commit Time = commit Data . get (  Solr Index Writer .  COMMIT_ TIME_ MSEC_ KEY ) ; if ( commit Time != null ) { try { version =  Long . parse Long ( commit Time ) ; } catch (  Number Format Exception e ) {  LOG . warn ( _ STR + commit Time , e ) ; } } } catch (  IOException e ) {  LOG . warn ( _ STR + commit , e ) ; } return new  Commit Version Info ( generation , version ) ; }
@  Override public void stop ( ) { }
protected int read (  Input Stream input Stream , byte [ ] buffer , char [ ] divider ) throws  IOException { int index = _ NUM ; int divider Index = _ NUM ; do { byte read Byte = ( byte ) ( _ NUM & input Stream . read ( ) ) ; if ( read Byte == - _ NUM ) { return index ; } if ( read Byte == divider [ divider Index ] ) { divider Index ++ ; } if ( divider Index == divider . length ) { index -= divider Index - _ NUM ; for ( int i = index ; i < index + divider Index ; i ++ ) { if ( i >= buffer . length ) { break ; } buffer [ i ] = _ NUM ; } return index ; } buffer [ index ] = read Byte ; index ++ ; } while ( index < buffer . length ) ; return index ; }
private static void generate Graph File (  Trans Meta trans Meta ,  String graph File ) throws  Graph Generator Exception {  Data Output Stream dos = null ; try {  String xml = trans Meta . get XML ( ) ; dos = new  Data Output Stream ( new  File Output Stream ( new  File ( graph File ) ) ) ; dos . write ( xml . get Bytes ( _ STR ) ) ; } catch (  Kettle Exception kettel Exception ) { throw new  Graph Generator Exception ( _ STR , kettel Exception ) ; } catch (  File Not Found Exception e ) { throw new  Graph Generator Exception ( _ STR , e ) ; } catch (  Unsupported Encoding Exception ue ) { throw new  Graph Generator Exception ( _ STR , ue ) ; } catch (  IOException ioe ) { throw new  Graph Generator Exception ( _ STR , ioe ) ; } finally { if ( dos != null ) { try { dos . close ( ) ; } catch (  IOException e ) { e . get Message ( ) ; } } } }
protected boolean should Select (  Transaction tx ) { if ( tx != null ) { return is Selectable ( tx ) ; } return _ BOOL ; }
public static void update Provider Key Info (  String realm ,  String entity ID ,  String cert Alias , boolean is IDP ) throws  WSFederation Meta Exception {  WSFederation Meta Manager meta Manager = new  WSFederation Meta Manager ( ) ;  Federation Config Element config = meta Manager . get Entity Config ( realm , entity ID ) ; if ( ! config . is Hosted ( ) ) {  String [ ] args = { entity ID , realm } ; throw new  WSFederation Meta Exception ( _ STR , args ) ; }  Federation Element desp = meta Manager . get Entity Descriptor ( realm , entity ID ) ; if ( is IDP ) {  IDPSSOConfig Element idp Config = meta Manager . get IDPSSOConfig ( realm , entity ID ) ; if ( ( idp Config == null ) || ( desp == null ) ) {  String [ ] args = { entity ID , realm } ; throw new  WSFederation Meta Exception ( _ STR , args ) ; } if ( ( cert Alias == null ) || ( cert Alias . length ( ) == _ NUM ) ) { remove Key Descriptor ( desp ) ; set Extended Attribute Value ( idp Config ,  SAML2 Constants .  SIGNING_ CERT_ ALIAS , null ) ; } else {  Token Signing Key Info Element kde = get Key Descriptor ( cert Alias ) ; update Key Descriptor ( desp , kde ) ;  Set value = new  Hash Set ( ) ; value . add ( cert Alias ) ; set Extended Attribute Value ( idp Config ,  SAML2 Constants .  SIGNING_ CERT_ ALIAS , value ) ; } } else {  SPSSOConfig Element sp Config = meta Manager . get SPSSOConfig ( realm , entity ID ) ; if ( ( sp Config == null ) || ( desp == null ) ) {  String [ ] args = { entity ID , realm } ; throw new  WSFederation Meta Exception ( _ STR , args ) ; } if ( ( cert Alias == null ) || ( cert Alias . length ( ) == _ NUM ) ) { remove Key Descriptor ( desp ) ; set Extended Attribute Value ( sp Config ,  SAML2 Constants .  SIGNING_ CERT_ ALIAS , null ) ; } else {  Token Signing Key Info Element kde = get Key Descriptor ( cert Alias ) ; update Key Descriptor ( desp , kde ) ;  Set value = new  Hash Set ( ) ; value . add ( cert Alias ) ; set Extended Attribute Value ( sp Config ,  SAML2 Constants .  SIGNING_ CERT_ ALIAS , value ) ; } } meta Manager . set Federation ( realm , desp ) ; meta Manager . set Entity Config ( realm , config ) ; }
public static  Image create Image (  Object native Image ) { return new  Image ( native Image ) ; }
@  Override protected void process Component Key Event ( final  Key Event e ) { if ( e . get Key Code ( ) ==  Key Event .  VK_ SPACE || e . get Key Code ( ) ==  Key Event .  VK_ ENTER ) { e . consume ( ) ; notify Action Listeners ( ) ; } }
public boolean spans (  String other ) { return spans ( other , _ BOOL ) ; }
public static java . sql .  Timestamp to Timestamp (  String month Str ,  String day Str ,  String year Str ,  String hour Str ,  String minute Str ,  String second Str ) { java . util .  Date new Date = to Date ( month Str , day Str , year Str , hour Str , minute Str , second Str ) ; if ( new Date != null ) { return new java . sql .  Timestamp ( new Date . get Time ( ) ) ; } else { return null ; } }
protected boolean schedule New Task (  String task Id ) {  LOG . info (  String . format ( _ STR , task Id ) ) ; int container Index =  Task Utils . get Container Index For Task Id ( task Id ) ; tasks Id . put ( container Index , task Id ) ; to Schedule Tasks . add ( task Id ) ;  LOG . info (  String . format ( _ STR , task Id ) ) ; return _ BOOL ; }
private void apply Ltp (  Single Channel Element sce ) {  Long Term Prediction ltp = sce . ics . ltp ; final int offsets [ ] = sce . ics . swb Offset ; if ( sce . ics . window Sequence [ _ NUM ] !=  EIGHT_ SHORT_ SEQUENCE ) { final float pred Time [ ] = sce . ret ; final float pred Freq [ ] = ac . buf Mdct ; int num Samples = _ NUM ; if ( ltp . lag < _ NUM ) { num Samples = ltp . lag + _ NUM ; } for ( int i = _ NUM ; i < num Samples ; i ++ ) { pred Time [ i ] = sce . ltp State [ i + _ NUM - ltp . lag ] * ltp . coef ; }  Arrays . fill ( pred Time , num Samples , _ NUM , _ NUM ) ; windowing And Mdct Ltp ( pred Freq , pred Time , sce . ics ) ; if ( sce . tns . present ) { apply Tns ( pred Freq , sce . tns , sce . ics , _ BOOL ) ; } for ( int sfb = _ NUM ; sfb <  Math . min ( sce . ics . max Sfb ,  MAX_ LTP_ LONG_ SFB ) ; sfb ++ ) { if ( ltp . used [ sfb ] ) { for ( int i = offsets [ sfb ] ; i < offsets [ sfb + _ NUM ] ; i ++ ) { sce . coeffs [ i ] += pred Freq [ i ] ; } } } } }
public  Config Xml Provider (  File config File ) throws  Xml Parsing Exception ,  File Not Found Exception { if ( ! config File . is File ( ) ) { throw new  File Not Found Exception (  String . format ( _ STR , config File . get Absolute Path ( ) ) ) ; } this . config =  Xml Parser . parse ( config File , new  String [ ] {  CONFIG_ XSD } ,  CONFIG_ PACKAGE ,  Config Type . class ) ; }
public void draw Range Marker (  Graphics2 D g2 ,  Contour Plot plot ,  Value Axis range Axis ,  Marker marker ,  Rectangle2 D data Area ) { if ( marker instanceof  Value Marker ) {  Value Marker vm = (  Value Marker ) marker ; double value = vm . get Value ( ) ;  Range range = range Axis . get Range ( ) ; if ( ! range . contains ( value ) ) { return ; } double y = range Axis . value To Java2 D ( value , data Area ,  Rectangle Edge .  LEFT ) ;  Line2 D line = new  Line2 D .  Double ( data Area . get Min X ( ) , y , data Area . get Max X ( ) , y ) ;  Paint paint = marker . get Outline Paint ( ) ;  Stroke stroke = marker . get Outline Stroke ( ) ; g2 . set Paint ( paint != null ? paint :  Plot .  DEFAULT_ OUTLINE_ PAINT ) ; g2 . set Stroke ( stroke != null ? stroke :  Plot .  DEFAULT_ OUTLINE_ STROKE ) ; g2 . draw ( line ) ; } }
private boolean verify (  String value , int allowed Mask , char [ ] allowed Chars , int min Length , int max Length ) { if ( ( min Length != - _ NUM ) && ( value . length ( ) < min Length ) ) { return _ BOOL ; } if ( ( max Length != - _ NUM ) && ( value . length ( ) > max Length ) ) { return _ BOOL ; } int i = _ NUM ; while ( i < value . length ( ) ) { boolean found = _ BOOL ; char ch = value . char At ( i ) ; if ( ( allowed Mask &  HEX ) != _ NUM ) { if ( ( ( ch >= _ STR ) && ( ch <= _ STR ) ) || ( ( ch >= _ STR ) && ( ch <= _ STR ) ) || ( ( ch >= _ STR ) && ( ch <= _ STR ) ) ) { found = _ BOOL ; } } if ( ( allowed Mask &  DIGITS ) != _ NUM ) { if ( ( ( ch >= _ STR ) && ( ch <= _ STR ) ) ) { found = _ BOOL ; } else if ( ( i == _ NUM ) && ( ( ch == _ STR ) || ( ch == _ STR ) ) ) { found = _ BOOL ; } } if ( ( ! found ) && ( ( allowed Mask &  ABC ) != _ NUM ) ) { if ( ( ( ch >= _ STR ) && ( ch <= _ STR ) ) || ( ( ch >= _ STR ) && ( ch <= _ STR ) ) ) { found = _ BOOL ; } } if ( ( ! found ) && ( allowed Chars != null ) ) { int c = _ NUM ; while ( ( ! found ) && ( c < allowed Chars . length ) ) { if ( ch == allowed Chars [ c ] ) { found = _ BOOL ; } else { c ++ ; } } } if ( ! found ) { return _ BOOL ; } i ++ ; } return _ BOOL ; }
@  Override public boolean on Preference Tree Click (  Preference Screen preference Screen ,  Preference preference ) { log ( _ STR + preference ) ; if ( preference == m Airplane Mode Preference &&  Boolean . parse Boolean (  System Properties . get (  Telephony Properties .  PROPERTY_ INECM_ MODE ) ) ) { start Activity For Result ( new  Intent (  Telephony Intents .  ACTION_ SHOW_ NOTICE_ ECM_ BLOCK_ OTHERS , null ) ,  REQUEST_ CODE_ EXIT_ ECM ) ; return _ BOOL ; } else if ( preference == find Preference (  KEY_ MANAGE_ MOBILE_ PLAN ) ) { on Manage Mobile Plan Click ( ) ; } return super . on Preference Tree Click ( preference Screen , preference ) ; }
private void parse Header ( final  String header ) {  LOG . debug ( _ STR , header ) ; final  String header Name = header . substring ( _ NUM , header . index Of ( _ STR ) ) ; if ( ! headers Map . contains Key ( header Name ) ) { final  String value = header . substring ( header . index Of ( _ STR ) + _ NUM ) ; headers Map . put ( header Name ,  String Utils . trim ( value ) ) ; } }
public static  Boolean value Of (  String value ) { return value != null ?  Boolean . value Of ( value ) : null ; }
protected void consume Message (  Message message ,  List <  Message > message List ) { if ( verbose ) {  LOG . info ( _ STR + message ) ; } message List . add ( message ) ; if ( message List . size ( ) >= data . length ) { synchronized ( lock ) { lock . notify All ( ) ; } } }
public void delete Sites (  Set sites ) throws  AMConsole Exception {  String site Name = null ; try { if ( ( sites != null ) && ! sites . is Empty ( ) ) {  SSOToken token = get User SSOToken ( ) ; for (  Iterator i = sites . iterator ( ) ; i . has Next ( ) ; ) { site Name = (  String ) i . next ( ) ;  String [ ] param = { site Name } ; log Event ( _ STR , param ) ;  Site Configuration . delete Site ( token , site Name ) ; log Event ( _ STR , param ) ; } } } catch (  Configuration Exception e ) {  String [ ] params = { site Name , e . get Message ( ) } ; log Event ( _ STR , params ) ; throw new  AMConsole Exception ( get Error String ( e ) ) ; } catch (  SMSException e ) {  String [ ] params = { site Name , e . get Message ( ) } ; log Event ( _ STR , params ) ; throw new  AMConsole Exception ( get Error String ( e ) ) ; } catch (  SSOException e ) {  String [ ] params = { site Name , e . get Message ( ) } ; log Event ( _ STR , params ) ; throw new  AMConsole Exception ( get Error String ( e ) ) ; } }
public boolean draw Image (  Image img ,  Affine Transform xform ,  Image Observer obs ) { if ( img == null ) { return _ BOOL ; } m Drawing Area . add Infinite ( ) ; m Print Metrics . draw Image ( this , img ) ; return m Graphics . draw Image ( img , xform , obs ) ; }
public void to Native Array ( int [ ] dest , int offset , int len ) { if ( len == _ NUM ) { return ; } if ( offset < _ NUM || offset >= _pos ) { throw new  Array Index Out Of Bounds Exception ( offset ) ; }  System . arraycopy ( _data , offset , dest , _ NUM , len ) ; }
public boolean delete Owner (  Principal caller ,  Principal owner ) throws  Not Owner Exception ,  Last Owner Exception { if ( ! owner List . contains ( caller ) ) throw new  Not Owner Exception ( ) ; if ( ! owner List . contains ( owner ) ) { return _ BOOL ; } else { if ( owner List . size ( ) == _ NUM ) throw new  Last Owner Exception ( ) ; owner List . remove Element ( owner ) ; return _ BOOL ; } }
public static double tan ( double radians ) { return  Math . tan ( radians ) ; }
public boolean is Option Checked ( int index ) { if ( index >= checkbox Panel . get Components ( ) . length ) { return _ BOOL ; }  JCheck Box checkbox = (  JCheck Box ) checkbox Panel . get Component ( index ) ; if ( checkbox . is Selected ( ) ) { return _ BOOL ; } else { return _ BOOL ; } }
private void paint Check Icon Disabled And Selected (  Graphics2 D g , int width , int height ) {  Shape s = shape Generator . create Check Mark ( _ NUM , _ NUM , width , height ) ; g . set Paint ( icon Disabled Selected ) ; g . fill ( s ) ; }
public void ensure Index (  String idx Name ,  Query Index Type idx Type ) {  Query Index idx = idxs . get ( idx Name ) ; if ( idx == null ) { idx = new  Query Index ( ) ; idx . set Name ( idx Name ) ; idx . set Index Type ( idx Type ) ; idxs . put ( idx Name , idx ) ; } else throw new  Illegal Argument Exception ( _ STR + _ STR + idx Name + _ STR + idx . get Index Type ( ) + _ STR + idx Type + _ STR ) ; }
public void disable ( ) throws  IOException { assert m_writer != null ; m_writer . close ( ) ; }
public final int count Data Paths ( ) { return m Data Paths != null ? m Data Paths . size ( ) : _ NUM ; }
@  Override public void internal Entity Decl (  String name ,  XMLString text ,  XMLString non Normalized Text ,  Augmentations augs ) throws  XNIException { int entity Index = get Entity Decl Index ( name ) ; if ( entity Index == - _ NUM ) { entity Index = create Entity Decl ( ) ; boolean is PE = name . starts With ( _ STR ) ; boolean in External = ( f Reading External DTD || f PEDepth > _ NUM ) ;  XMLEntity Decl entity Decl = new  XMLEntity Decl ( ) ; entity Decl . set Values ( name , null , null , null , null , text . to String ( ) , is PE , in External ) ; set Entity Decl ( entity Index , entity Decl ) ; } }
private void grow Spine ( ) { int size = ( spine . length << _ NUM ) + _ NUM ; spine = new int [ size ] ; spine Empty = new int [ size ] ; threshold = ( int ) ( spine . length * load Factor ) ;  Arrays . fill ( spine Empty , - _ NUM ) ;  Grid Unsafe . copy Memory ( spine Empty ,  INT_ ARR_ OFF , spine ,  INT_ ARR_ OFF , spine Empty . length << _ NUM ) ; for ( int i = _ NUM ; i < this . size ; i ++ ) {  Object obj = objs [ i ] ; int idx = hash ( obj ) % spine . length ; insert ( objs [ i ] , i , idx ) ; } }
public void close ( ) {  Thread current = thread ; thread = null ; if ( current != null ) { current . interrupt ( ) ; try { current . join ( ) ; } catch (  Interrupted Exception e ) { log . error ( e . get Message ( ) , e ) ; } } try { buffer . close ( ) ; } catch (  IOException e ) { log . error ( e . get Message ( ) , e ) ; } }
protected  Collection <  T > sort (  Collection <  T > records ) { return records ; }
public static void dump (  Result Set rs ) throws  SQLException {  Result Set Meta Data md = rs . get Meta Data ( ) ; for ( int i = _ NUM ; i < md . get Column Count ( ) ; i ++ ) { int index = i + _ NUM ;  String info = md . get Column Label ( index ) ;  String name = md . get Column Name ( index ) ; if ( info == null ) info = name ; else if ( name != null && ! name . equals ( info ) ) info += _ STR + name + _ STR ; info += _ STR + rs . get String ( index ) ; info += _ STR + md . get Column Type Name ( index ) + _ STR + md . get Precision ( index ) ; if ( md . get Scale ( index ) != _ NUM ) info += _ STR + md . get Scale ( index ) ; info += _ STR ; log . fine ( info ) ; } }
void bind With ( final  Circle circle ) { circles . add ( circle ) ; }
public void add Argument ( final  Argument arg ) { args . add ( arg ) ; }
public  Animated Picking Graph Mouse Plugin ( int selection Modifiers ) { super ( selection Modifiers ) ; this . cursor =  Cursor . get Predefined Cursor (  Cursor .  HAND_ CURSOR ) ; }
public double [ ] breadth First Search ( double intial Value , double first Value ,  IBFSTraversable <  N > traversable ,  IDouble Bfs Next Level Value Iterator <  N > next Value Iterator ,  List <  Integer > sources ) { double [ ] results = new double [ nodes . length ] ;  Arrays . fill ( results , intial Value ) ; boolean [ ] already Scanned = new boolean [ nodes . length ] ;  Arrays . fill ( already Scanned , _ BOOL ) ;  Set <  Integer > current Nodes Index = new  Hash Set < > ( sources ) ; iterative Double Breadth First Search ( results , already Scanned , current Nodes Index , first Value , _ NUM , traversable , next Value Iterator ) ; return results ; }
public  View Ref Render (  View Render <  T > view ) {  Objects . require Non Null ( view ) ; _view = view ; _type = type Of ( view ) ; _priority = priority Of ( view ) ; }
public boolean has Resources ( ) { return ( disco Data != null ) && ! disco Data . is Empty ( ) ; }
public void add Property Change Listener (  Property Change Listener listener ) { if ( property Change Support == null ) { property Change Support = new  Property Change Support ( this ) ; } property Change Support . add Property Change Listener ( listener ) ; }
private static void update Embedded Id Repo (  String org Name ,  String config Name ,  String entry ) throws  SMSException ,  SSOException {  SSOToken token =  Access Controller . do Privileged (  Admin Token Action . get Instance ( ) ) ;  Service Config Manager scm = new  Service Config Manager ( token ,  Id Constants .  REPO_ SERVICE , _ STR ) ;  Service Config sc = scm . get Organization Config ( org Name , null ) ; if ( sc != null ) {  Service Config sub Config = sc . get Sub Config ( config Name ) ; if ( sub Config != null ) {  Map <  String ,  Set <  String > > config Map = sub Config . get Attributes ( ) ;  Set <  String > vals = config Map . get ( _ STR ) ; vals . add ( entry ) ;  Hash Map <  String ,  Set <  String > > mp = new  Hash Map <  String ,  Set <  String > > ( _ NUM ) ; mp . put ( _ STR , vals ) ; sub Config . set Attributes ( mp ) ; } } }
public static  Block Snapshot validate Snapshot (  URI snapshot URI ,  Uri Info uri Info ,  Db Client db Client ) {  Arg Validator . check Uri ( snapshot URI ) ;  Block Snapshot snapshot = db Client . query Object (  Block Snapshot . class , snapshot URI ) ;  Arg Validator . check Entity ( snapshot , snapshot URI ,  Block Service Utils . is Id Embedded In URL ( snapshot URI , uri Info ) , _ BOOL ) ; return snapshot ; }
public static long convert String To Time Millis (  String time ) { long result = _ NUM ; if ( time . ends With ( _ STR ) ) { long hours To Add =  Integer . value Of (  String Utils . remove ( time , _ STR ) ) ; result = ( ( _ NUM * _ NUM ) * _ NUM ) * hours To Add ; } else if ( time . ends With ( _ STR ) ) { long mins To Add =  Integer . value Of (  String Utils . remove ( time , _ STR ) ) ; result = ( _ NUM * _ NUM ) * mins To Add ; } else if ( time . ends With ( _ STR ) ) { long secs To Add =  Integer . value Of (  String Utils . remove ( time , _ STR ) ) ; result = _ NUM * secs To Add ; } return result ; }
public void detach ( ) { activity . clear ( ) ; }
public  Builder add Action (  String action Type ,  Action action ) { m Actions . add ( new  Action Pair ( action Type , action ) ) ; return this ; }
public void remove From Active List (  Download Info Runnable download Info Runnable ) { m Active List . remove ( download Info Runnable ) ; }
private void end Current Line Of TLA ( ) { if ( tlacode Next Line . length ( ) != _ NUM ) { tlacode . add Element ( tlacode Next Line ) ; mapping Vector . add Element ( mapping Vector Next Line ) ; tlacode Next Line = _ STR ; mapping Vector Next Line = new  Vector ( ) ; } else { if ( mapping Vector Next Line . size ( ) != _ NUM ) {  Vector last Line = (  Vector ) mapping Vector . element At ( mapping Vector . size ( ) - _ NUM ) ; for ( int i = _ NUM ; i < mapping Vector Next Line . size ( ) ; i ++ ) {  Mapping Object obj = (  Mapping Object ) mapping Vector Next Line . element At ( i ) ; if ( obj . get Type ( ) ==  Mapping Object .  RIGHT_ PAREN || obj . get Type ( ) ==  Mapping Object .  LEFT_ PAREN || obj . get Type ( ) ==  Mapping Object .  BREAK ) { last Line . add ( obj ) ; } else {  Pcal Debug .  Report Bug ( _ STR ) ; } mapping Vector Next Line = new  Vector ( ) ; } } } }
public static boolean is Variable (  String s ) { for ( int i = _ NUM ; i < s . length ( ) ; i ++ ) { if ( !  Character . is Upper Case ( s . char At ( i ) ) ) { return _ BOOL ; } } return _ BOOL ; }
private static int index Of Non Digit (  String string , int offset ) { for ( int i = offset ; i < string . length ( ) ; i ++ ) { char c = string . char At ( i ) ; if ( c < _ STR || c > _ STR ) return i ; } return string . length ( ) ; }
public static  String sanitize App Identifier (  String app Identifier ) throws  Illegal Argument Exception { if ( app Identifier == null ) { throw new  Illegal Argument Exception ( _ STR ) ; }  String s App Identifier = app Identifier . trim ( ) ; if ( s App Identifier . length ( ) !=  APP_ IDENTIFIER_ LENGTH ) { throw new  Illegal Argument Exception ( _ STR +  APP_ IDENTIFIER_ LENGTH + _ STR ) ; } return s App Identifier ; }
static void remove Duplicate Affix (  List <  String > str List , boolean is Suffix ) {  Hash Set <  String > str Set = new  Hash Set <  String > ( str List ) ; str List . clear ( ) ; str List . add All ( str Set ) ; if ( is Suffix ) {  Collections . sort ( str List , null ) ; } else {  Collections . sort ( str List , null ) ; } }
public static double next Double ( ) {  Random random = get Random ( ) ; double value = random . next Double ( ) ; if ( ! _is Test ) _free Random List . free ( random ) ; return value ; }
protected void init ( ) { m Selected Day = new  Calendar Day (  System . current Time Millis ( ) ) ; }
public void store Last PVPAction Time ( ) { put ( _ STR ,  System . current Time Millis ( ) ) ; }
public int current Index ( ) { return contents . size ( ) ; }
public static int [ ] oid Str To Ints (  String oid ) throws  IOException { int length = oid . length ( ) ; if ( oid . char At ( length - _ NUM ) == _ STR ) { throw new  IOException ( _ STR + oid ) ; } int [ ] result = new int [ length / _ NUM + _ NUM ] ; int number = _ NUM ; for ( int i = _ NUM ; i < length ; i ++ ) { int value = _ NUM ; int pos = i ; for ( ; i < length ; i ++ ) { char ch = oid . char At ( i ) ; if ( ( ch < _ STR ) || ( ch > _ STR ) ) { break ; } value = _ NUM * value + ( ch - _ STR ) ; } if ( i == pos ) { throw new  IOException ( _ STR + oid ) ; } result [ number ++ ] = value ; if ( i == length ) { break ; } char ch = oid . char At ( i ) ; if ( ch != _ STR ) { throw new  IOException ( _ STR + oid ) ; } } if ( number < _ NUM ) { throw new  IOException ( _ STR + oid ) ; } return  Arrays . copy Of Range ( result , _ NUM , number ) ; }
public  Object visit (  Id filter ,  Object extra Data ) { final  List <  String > id List = new  Array List < > ( ) ; for ( final  Identifier id : filter . get Identifiers ( ) ) { id List . add ( id . to String ( ) ) ; } ids = id List . to Array ( new  String [ id List . size ( ) ] ) ; return extra Data ; }
public final double root Mean Prior Squared Error ( ) { if ( m_ No Priors ) { return  Double .  Na N ; } return  Math . sqrt ( m_ Sum Prior Sqr Err / m_ With Class ) ; }
public boolean accept (  File f ) { if ( f != null ) { if ( f . is Directory ( ) ) { return _ BOOL ; }  String extension = get Extension ( f ) ; if ( ( extension != null ) && ( filters . get ( get Extension ( f ) ) != null ) ) { return _ BOOL ; } } return _ BOOL ; }
@  Override public  Poll Result start Poll (  Poll Controller conn ) { try { boolean is New = conn . enable Keepalive If New ( this ) ; if ( ! enable Keepalive ( conn , is New ) ) { return  Poll Result .  CLOSED ; } if ( conn . to Keepalive Start ( ) ) { _active Count . increment And Get ( ) ; return  Poll Result .  START ; } else { return  Poll Result .  DATA ; } } catch (  IOException e ) { conn . on Poll Read Close ( ) ; throw new  Illegal State Exception ( e ) ; } }
private void init Space Startup State Manager ( ) throws  Create Exception {  List <  String > target Names = _cluster Policy . m_ Replication Policy . m_ Replication Group Members Names ;  String space Name = _cluster Policy . m_ Replication Policy . m_ Own Member Name ; _startup Manager = new  Replication Startup Manager ( space Name ) ; for (  String name : target Names ) { if ( name . equals ( space Name ) ) continue ; } try { if ( _startup Manager . should Wait ( target Names ) ) { _logger . info ( _ STR ) ; _startup Manager . wait For Last Space ( ) ; } } catch (  Interrupted Exception e ) { throw new  Create Exception ( _ STR , e ) ; } }
public static boolean assert Equals ( final double a , final double b ) { if (  Double . is Na N ( a ) &&  Double . is Na N ( b ) ) { return _ BOOL ; } if ( a == b ) { return _ BOOL ; } throw new  Exam Exception ( a + _ STR + b ) ; }
public  Configure Xml Element Count Dialog_ NB (  Xml Element Count xml Element Count ) { this . xml Element Count = xml Element Count ; init Components ( ) ; configure String List_ NB1 . set Validator ( new  XMLElement Validator ( ) ) ; final  Iterate Model number Of Tags Iterator = xml Element Count . get Number Of Elements Iterator ( ) ; configure Iterate Model_ NB2 . set Start At (  String . value Of ( number Of Tags Iterator . get Start At ( ) ) ) ; configure Iterate Model_ NB2 . set Stop At (  String . value Of ( number Of Tags Iterator . get Stop At ( ) ) ) ; configure Iterate Model_ NB2 . set Increment (  String . value Of ( number Of Tags Iterator . get Increment ( ) ) ) ; configure Iterate Model_ NB2 . set Iterate Strategie ( number Of Tags Iterator . get Iterate Strategie ( ) ) ;  List <  String > elements =  Arrays . as List ( xml Element Count . get Elements ( ) ) ; configure String List_ NB1 . set String List ( elements ) ; }
public final static int log Base2 ( double number ) { int log = _ NUM ; while ( number > _ NUM ) { number =  Math . floor ( number / _ NUM ) ; ++ log ; } return log ; }
public  Entry create Root (  User user ,  String id ,  String type ,  String notebook Id ,  Long mod Time ,  Long create Time ,  Errors errors ) { if ( user == null ) {  Errors . add ( errors , error Messages . error User Is Null ( ) ) ; return null ; } if ( mod Time == null ) {  Errors . add ( errors , error Messages . error Mod Time Is Null ( ) ) ; return null ; } if ( create Time == null ) {  Errors . add ( errors , error Messages . error Create Time Is Null ( ) ) ; return null ; } if ( id != null && ! id Generator . is Id Well Formed ( id ) ) {  Errors . add ( errors , error Messages . error Id Is Invalid ( ) ) ; return null ; } if ( notebook Id != null && ! id Generator . is Id Well Formed ( notebook Id ) ) {  Errors . add ( errors , error Messages . error Notebook Id Is Invalid ( ) ) ; return null ; } if ( create Time . long Value ( ) > mod Time . long Value ( ) ) { mod Time = create Time ; }  Entry root = new  Entry ( ) ; root . set Db ( db ) ; if ( id == null ) { id = id Generator . get Another Id ( ) ; } root . set Id ( id ) ; root . set Create Time ( create Time ) ; root . set Mod Time ( mod Time ) ; root . set Type ( type ) ; root . set User Id ( user . get Id ( ) ) ; root . set Notebook Id ( notebook Id ) ; db . persist Entry ( root ) ; return root ; }
public  Parameter Type File (  String key ,  String description , boolean optional ,  String [ ] extensions ) { super ( key , description , null ) ; set Optional ( optional ) ; this . extensions = extensions ; }
protected int read Block ( ) { block Size = read ( ) ; int n = _ NUM ; if ( block Size > _ NUM ) { try { int count = _ NUM ; while ( n < block Size ) { count = in . read ( block , n , block Size - n ) ; if ( count == - _ NUM ) break ; n += count ; } } catch (  IOException e ) { } if ( n < block Size ) { status =  STATUS_ FORMAT_ ERROR ; } } return n ; }
public void destroy ( ) { for ( int i = _ NUM ; i < runs . size ( ) ; i ++ ) { final  Run run = (  Run ) runs . get ( i ) ; run . destroy ( ) ; } }
public static void register Dynamic Type Converter (  Java Dynamic Type Converter the Converter ) { if ( ! m_dyn Converters . contains ( the Converter ) ) { m_dyn Converters . add Element ( the Converter ) ; } }
private boolean init Default Sensor ( ) { if ( proximity Sensor != null ) { return _ BOOL ; } proximity Sensor = sensor Manager . get Default Sensor (  Sensor .  TYPE_ PROXIMITY ) ; if ( proximity Sensor == null ) { return _ BOOL ; } log Proximity Sensor Info ( ) ; return _ BOOL ; }
@  Override public int read ( byte [ ] buf , int offset , int length ) throws  IOException { try {  Socket Channel s = _s ; if ( s == null ) { return - _ NUM ; } int remaining = _read Buffer . remaining ( ) ; if ( remaining <= _ NUM ) { _read Buffer . clear ( ) ; if ( s . read ( _read Buffer ) < _ NUM ) { _read Buffer . flip ( ) ; return - _ NUM ; } _read Buffer . flip ( ) ; remaining = _read Buffer . remaining ( ) ; } int sublen =  Math . min ( remaining , length ) ; _read Buffer . get ( buf , offset , sublen ) ; int read Length = sublen ; if ( read Length >= _ NUM ) { _total Read Bytes += read Length ; } return read Length ; } catch (  Interrupted IOException e ) { if ( _throw Read Interrupts ) throw e ; log . log (  Level .  FINEST , e . to String ( ) , e ) ; } catch (  IOException e ) { if ( _throw Read Interrupts ) { throw e ; } if ( log . is Loggable (  Level .  FINEST ) ) { log . log (  Level .  FINEST , e . to String ( ) , e ) ; } else { log . finer ( e . to String ( ) ) ; } } return - _ NUM ; }
public void skip ( ) {  Timber . i ( _ STR ) ; if ( ! m Media Player . is Complete ( ) ) { log Play ( ) ; } set Multi Repeat ( _ NUM ) ; if ( m Media Player . get Queue Index ( ) < m Queue . size ( ) - _ NUM || m Repeat ==  REPEAT_ ALL ) { m Media Player . skip ( ) ; } }
public void if Present (  Int Consumer consumer ) { if ( is Present ) consumer . accept ( value ) ; }
protected void send Intensity ( double intensity ) { if ( log . is Debug Enabled ( ) ) { log . debug ( _ STR + intensity + _ STR + _ STR + last Output Step + _ STR + max Dim Step ) ; } int new Step = ( int )  Math . round ( intensity * max Dim Step ) ; if ( ( new Step < _ NUM ) || ( new Step > max Dim Step ) ) { log . error ( _ STR + new Step + _ STR + intensity ) ; } if ( new Step == last Output Step ) { if ( log . is Debug Enabled ( ) ) { log . debug ( _ STR + intensity + _ STR ) ; } return ; } if ( log . is Debug Enabled ( ) ) { log . debug ( _ STR + intensity ) ; }  Insteon Sequence out = new  Insteon Sequence ( ) ; out . add Function ( idhighbyte , idmiddlebyte , idlowbyte ,  Constants .  FUNCTION_ REQ_ STD ,  Constants .  FLAG_ STD ,  Constants .  CMD_ LIGHT_ CHG , new Step ) ; tc . send Insteon Sequence ( out , null ) ; if ( log . is Debug Enabled ( ) ) { log . debug ( _ STR + intensity + _ STR + idhighbyte + idmiddlebyte + idlowbyte + _ STR + new Step ) ; } last Output Step = new Step ; }
public void close Server ( ) throws  IOException { if ( ! server Is Open ( ) ) { return ; } server Socket . close ( ) ; server Socket = null ; server Input = null ; server Output = null ; }
public void delete ( ) throws  IOException { close ( ) ; delete Contents ( directory ) ; }
@  Override public boolean execute ( @  Not Null  Psi Element pe , @  Not Null  Resolve State state ) { if ( pe instanceof  Psi Variable ) { final  Psi Variable pvar = (  Psi Variable ) pe ; final  String pvar_name = pvar . get Name ( ) ; if ( pvar_name . starts With ( my Prefix ) ) { if ( ! my Static Sensitive Flag || ( ! my Static Scope Flag || pvar . has Modifier Property (  Psi Modifier .  STATIC ) ) ) { my Result List . add ( pvar ) ; } } } return _ BOOL ; }
private void write Esc ( char ch [ ] , int start , int length , boolean is Att Val ) throws  SAXException { for ( int i = start ; i < start + length ; i ++ ) { switch ( ch [ i ] ) { case _ STR : write ( _ STR ) ; break ; case _ STR : write ( _ STR ) ; break ; case _ STR : write ( _ STR ) ; break ; case _ STR : if ( is Att Val ) { write ( _ STR ) ; } else { write ( _ STR ) ; } break ; default : if ( ! unicode Mode && ch [ i ] > _ STR ) { write ( _ STR ) ; write (  Integer . to String ( ch [ i ] ) ) ; write ( _ STR ) ; } else { write ( ch [ i ] ) ; } } } }
private static void validate ( int hours , int minutes , int seconds ) { if ( hours < - _ NUM || hours > _ NUM ) { throw new  Date Time Exception ( _ STR + hours + _ STR ) ; } if ( hours > _ NUM ) { if ( minutes < _ NUM || seconds < _ NUM ) { throw new  Date Time Exception ( _ STR ) ; } } else if ( hours < _ NUM ) { if ( minutes > _ NUM || seconds > _ NUM ) { throw new  Date Time Exception ( _ STR ) ; } } else if ( ( minutes > _ NUM && seconds < _ NUM ) || ( minutes < _ NUM && seconds > _ NUM ) ) { throw new  Date Time Exception ( _ STR ) ; } if (  Math . abs ( minutes ) > _ NUM ) { throw new  Date Time Exception ( _ STR +  Math . abs ( minutes ) + _ STR ) ; } if (  Math . abs ( seconds ) > _ NUM ) { throw new  Date Time Exception ( _ STR +  Math . abs ( seconds ) + _ STR ) ; } if (  Math . abs ( hours ) == _ NUM && (  Math . abs ( minutes ) > _ NUM ||  Math . abs ( seconds ) > _ NUM ) ) { throw new  Date Time Exception ( _ STR ) ; } }
@  Override public  IChat Message send Message (  String message ) throws  Remote Exception { if (  Text Utils . is Empty ( message ) ) { throw new  Server Api Illegal Argument Exception ( _ STR ) ; } int message Length = message . length ( ) ; int max Message Length = m Rcs Settings . get Max Chat Message Length ( ) ; if ( message Length > max Message Length ) { throw new  Server Api Illegal Argument Exception ( _ STR + message Length + _ STR + max Message Length + _ STR ) ; } if ( s Logger . is Activated ( ) ) { s Logger . debug ( _ STR ) ; } try { m Im Service . remove One To One Chat Composing Status ( m Contact ) ; long timestamp =  System . current Time Millis ( ) ; final  Chat Message msg =  Chat Utils . create Text Message ( m Contact , message , timestamp , timestamp ) ;  Chat Message Persisted Storage Accessor persisted Storage = new  Chat Message Persisted Storage Accessor ( m Messaging Log , msg . get Message Id ( ) , msg . get Remote Contact ( ) , message , msg . get Mime Type ( ) , m Contact . to String ( ) ,  Direction .  OUTGOING ) ; add Outgoing Chat Message ( msg ,  Status .  QUEUED ) ; m Im Service . try To Dequeue One To One Chat Messages ( m Contact ) ; return new  Chat Message Impl ( persisted Storage ) ; } catch (  Server Api Base Exception e ) { if ( ! e . should Not Be Logged ( ) ) { s Logger . error (  Exception Util . get Full Stack Trace ( e ) ) ; } throw e ; } catch (  Exception e ) { s Logger . error (  Exception Util . get Full Stack Trace ( e ) ) ; throw new  Server Api Generic Exception ( e ) ; } }
synchronized void remove (  Pg Server Thread t ) { running . remove ( t ) ; }
public void associate (  Node node ) { if ( this . node == null ) { this . node = node ; } }
private  Log Source ( ) { }
@  Nullable public  Codenvy License load ( ) throws  License Exception {  String license Text ; try { license Text = new  String (  Files . read All Bytes ( license File ) ,  UTF_8 ) ; } catch (  No Such File Exception e ) { throw new  License Not Found Exception ( _ STR ) ; } catch (  IOException e ) { throw new  License Exception ( e . get Message ( ) , e ) ; } if ( is Null Or Empty ( license Text ) ) { throw new  License Not Found Exception ( _ STR ) ; } return license Factory . create ( license Text ) ; }
public static boolean is Network Available ( ) { return is Network Available (  Net Type .  Any ) ; }
public  String read String ( ) throws  IOException { return dis . read UTF ( ) ; }
public  Rect update Fast Scroller Bounds ( int last Touch Y ) { m Invalidate Rect . set ( m Bg Bounds ) ; if ( is Visible ( ) ) { int edge Padding = m Rv . get Max Scrollbar Width ( ) ; int bg Padding = ( m Bg Original Size - m Text Bounds . height ( ) ) / _ NUM ; int bg Height = m Bg Original Size ; int bg Width =  Math . max ( m Bg Original Size , m Text Bounds . width ( ) + ( _ NUM * bg Padding ) ) ; if (  Utilities . is Rtl ( m Res ) ) { m Bg Bounds . left = m Rv . get Background Padding ( ) . left + ( _ NUM * m Rv . get Max Scrollbar Width ( ) ) ; m Bg Bounds . right = m Bg Bounds . left + bg Width ; } else { m Bg Bounds . right = m Rv . get Width ( ) - m Rv . get Background Padding ( ) . right - ( _ NUM * m Rv . get Max Scrollbar Width ( ) ) ; m Bg Bounds . left = m Bg Bounds . right - bg Width ; } m Bg Bounds . top = last Touch Y - ( int ) (  FAST_ SCROLL_ OVERLAY_ Y_ OFFSET_ FACTOR * bg Height ) ; m Bg Bounds . top =  Math . max ( edge Padding ,  Math . min ( m Bg Bounds . top , m Rv . get Height ( ) - edge Padding - bg Height ) ) ; m Bg Bounds . bottom = m Bg Bounds . top + bg Height ; } else { m Bg Bounds . set Empty ( ) ; } m Invalidate Rect . union ( m Bg Bounds ) ; return m Invalidate Rect ; }
public  DNetscape Ca Revocation Url (  JDialog parent ) { super ( parent ) ; set Title ( res . get String ( _ STR ) ) ; init Components ( ) ; }
public boolean textbox Key Typed ( char p_146201_1_ , int p_146201_2_ ) { if ( ! field_146213_o ) return _ BOOL ; else switch ( p_146201_1_ ) { case _ NUM : func_146202_e ( ) ; func_146199_i ( _ NUM ) ; return _ BOOL ; case _ NUM :  Gui Screen . set Clipboard String ( func_146207_c ( ) ) ; return _ BOOL ; case _ NUM : if ( field_146226_p ) func_146191_b (  Gui Screen . get Clipboard String ( ) ) ; return _ BOOL ; case _ NUM :  Gui Screen . set Clipboard String ( func_146207_c ( ) ) ; if ( field_146226_p ) func_146191_b ( _ STR ) ; return _ BOOL ; default : switch ( p_146201_2_ ) { case _ NUM : if (  Gui Screen . is Ctrl Key Down ( ) ) { if ( field_146226_p ) func_146177_a ( - _ NUM ) ; } else if ( field_146226_p ) func_146175_b ( - _ NUM ) ; return _ BOOL ; case _ NUM : if (  Gui Screen . is Shift Key Down ( ) ) func_146199_i ( _ NUM ) ; else func_146196_d ( ) ; return _ BOOL ; case _ NUM : if (  Gui Screen . is Shift Key Down ( ) ) { if (  Gui Screen . is Ctrl Key Down ( ) ) func_146199_i ( func_146183_a ( - _ NUM , func_146186_n ( ) ) ) ; else func_146199_i ( func_146186_n ( ) - _ NUM ) ; } else if (  Gui Screen . is Ctrl Key Down ( ) ) func_146190_e ( func_146187_c ( - _ NUM ) ) ; else func_146182_d ( - _ NUM ) ; return _ BOOL ; case _ NUM : if (  Gui Screen . is Shift Key Down ( ) ) { if (  Gui Screen . is Ctrl Key Down ( ) ) func_146199_i ( func_146183_a ( _ NUM , func_146186_n ( ) ) ) ; else func_146199_i ( func_146186_n ( ) + _ NUM ) ; } else if (  Gui Screen . is Ctrl Key Down ( ) ) func_146190_e ( func_146187_c ( _ NUM ) ) ; else func_146182_d ( _ NUM ) ; return _ BOOL ; case _ NUM : if (  Gui Screen . is Shift Key Down ( ) ) func_146199_i ( field_146216_j . length ( ) ) ; else func_146202_e ( ) ; return _ BOOL ; case _ NUM : if (  Gui Screen . is Ctrl Key Down ( ) ) { if ( field_146226_p ) func_146177_a ( _ NUM ) ; } else if ( field_146226_p ) func_146175_b ( _ NUM ) ; return _ BOOL ; default : if (  Chat Allowed Characters . is Allowed Character ( p_146201_1_ ) ) { if ( field_146226_p ) func_146191_b (  Character . to String ( p_146201_1_ ) ) ; return _ BOOL ; } else return _ BOOL ; } } }
public boolean is Parent (  File folder ,  File file ) { if ( folder == null || file == null ) { return _ BOOL ; } else if ( folder instanceof  Shell Folder ) {  File parent = file . get Parent File ( ) ; if ( parent != null && parent . equals ( folder ) ) { return _ BOOL ; }  File [ ] children = get Files ( folder , _ BOOL ) ; for (  File child : children ) { if ( file . equals ( child ) ) { return _ BOOL ; } } return _ BOOL ; } else { return folder . equals ( file . get Parent File ( ) ) ; } }
public static boolean is Windows7 ( ) { return os Name . index Of ( _ STR ) > - _ NUM && os Version . equals ( _ STR ) ; }
private void specialised Functions ( ) {  Function <  Integer ,  Employee > emp Function = null ;  Int Function <  Employee > emp Function2 = null ;  Double Function <  String > double Function = null ; double Function . apply ( _ NUM ) ;  Long Function <  Patient > long Function = null ; long Function . apply ( _ NUM ) ; }
private void recycle Children (  Recycler View .  Recycler recycler , int start Index , int end Index ) { if ( start Index == end Index ) { return ; } if (  DEBUG ) {  Log . d (  TAG , _ STR +  Math . abs ( start Index - end Index ) + _ STR ) ; } if ( end Index > start Index ) { for ( int i = end Index - _ NUM ; i >= start Index ; i -- ) { remove And Recycle View At ( i , recycler ) ; } } else { for ( int i = start Index ; i > end Index ; i -- ) { remove And Recycle View At ( i , recycler ) ; } } }
@  Override public  List <  Proxy > select (  URI uri ) {  Array List <  Proxy > proxies = new  Array List <  Proxy > ( ) ; proxies . add (  Proxy .  NO_ PROXY ) ; return proxies ; }
public void add Externs (  String [ ] definitions ) { add Strings (  EXTERNS , definitions ) ; add Strings ( linker_more ,  EXTERNS , definitions ) ; new Linker Options After Compile . add (  EXTERNS ) ; }
public  Vcf Record next ( ) throws  IOException { if ( m Current . size ( ) == _ NUM ) { throw new  Illegal State Exception ( _ STR ) ; } final  Vcf Record rec = m Current . poll ( ) ; set Next ( ) ; return rec ; }
public  LDIFEntry Writer ( final  List <  String > ldif Lines ) { super ( ldif Lines ) ; }
Completion Stage <  Person > person Async (  Person p ) { return completed Future ( person Direct ( p ) ) ; }
@  Nullable public  Codenvy License load ( ) throws  License Exception {  String license Text ; try { license Text = new  String (  Files . read All Bytes ( license File ) ,  UTF_8 ) ; } catch (  No Such File Exception e ) { throw new  License Not Found Exception ( _ STR ) ; } catch (  IOException e ) { throw new  License Exception ( e . get Message ( ) , e ) ; } if ( is Null Or Empty ( license Text ) ) { throw new  License Not Found Exception ( _ STR ) ; } return license Factory . create ( license Text ) ; }
public void translate Cell (  Object cell , double dx , double dy ) { mx Geometry geo = model . get Geometry ( cell ) ; if ( geo != null ) { geo = ( mx Geometry ) geo . clone ( ) ; geo . translate ( dx , dy ) ; if ( ! geo . is Relative ( ) && model . is Vertex ( cell ) && ! is Allow Negative Coordinates ( ) ) { geo . set X (  Math . max ( _ NUM , geo . get X ( ) ) ) ; geo . set Y (  Math . max ( _ NUM , geo . get Y ( ) ) ) ; } if ( geo . is Relative ( ) && ! model . is Edge ( cell ) ) { if ( geo . get Offset ( ) == null ) { geo . set Offset ( new mx Point ( dx , dy ) ) ; } else { mx Point offset = geo . get Offset ( ) ; offset . set X ( offset . get X ( ) + dx ) ; offset . set Y ( offset . get Y ( ) + dy ) ; } } model . set Geometry ( cell , geo ) ; } }
public static  Geo Time Serie b SAX (  Geo Time Serie gts , int alphabet Size , int word Len , int window Len , boolean standardize PAA ) throws  Warp Script Exception { if ( !  GTSHelper . is Bucketized ( gts ) || (  TYPE .  DOUBLE != gts . type &&  TYPE .  LONG != gts . type ) ) { throw new  Warp Script Exception ( _ STR ) ; } if ( window Len % word Len != _ NUM ) { throw new  Warp Script Exception ( _ STR ) ; } int levels = _ NUM ; if ( _ NUM == alphabet Size ) { throw new  Warp Script Exception ( _ STR ) ; } while ( _ NUM == ( alphabet Size & _ NUM ) ) { levels ++ ; alphabet Size >>>= _ NUM ; } if ( _ NUM != alphabet Size ) { throw new  Warp Script Exception ( _ STR ) ; } if ( levels < _ NUM || levels >  SAXUtils .  SAX_ MAX_ LEVELS ) { throw new  Warp Script Exception ( _ STR +  SAXUtils .  SAX_ MAX_ LEVELS ) ; } int paa Len = window Len / word Len ;  GTSHelper . sort ( gts ) ;  Geo Time Serie sax GTS = new  Geo Time Serie ( gts . lastbucket , gts . bucketcount , gts . bucketspan , gts . values ) ; sax GTS . set Metadata ( gts . get Metadata ( ) ) ; int [ ] symbols = new int [ word Len ] ; double paa Sum [ ] = new double [ word Len ] ; for ( int i = _ NUM ; i < gts . values - window Len + _ NUM ; i ++ ) { double sum = _ NUM ; double sumsq = _ NUM ; for ( int w = _ NUM ; w < word Len ; w ++ ) { paa Sum [ w ] = _ NUM ; for ( int k = _ NUM ; k < paa Len ; k ++ ) { paa Sum [ w ] +=  TYPE .  LONG == gts . type ? gts . long Values [ i + w * paa Len + k ] : gts . double Values [ i + w * paa Len + k ] ; } if ( ! standardize PAA ) { continue ; } double mean = paa Sum [ w ] / paa Len ; sum += mean ; sumsq += mean * mean ; } double mu = _ NUM ; double variance = _ NUM ; double sigma = _ NUM ; if ( standardize PAA ) { mu = sum / word Len ; variance = ( sumsq / word Len ) - ( sum * sum ) / ( ( double ) word Len * ( double ) word Len ) ; if ( word Len > _ NUM ) { variance = variance * word Len / ( word Len - _ NUM ) ; } sigma =  Math . sqrt ( variance ) ; } for ( int w = _ NUM ; w < word Len ; w ++ ) { if ( standardize PAA ) { symbols [ w ] =  SAXUtils .  SAX ( levels , sigma != _ NUM ? ( ( paa Sum [ w ] / paa Len ) - mu ) / sigma : ( ( paa Sum [ w ] / paa Len ) - mu ) ) ; } else { symbols [ w ] =  SAXUtils .  SAX ( levels , paa Sum [ w ] / paa Len ) ; } }  String word = new  String (  Order Preserving Base64 . encode (  SAXUtils . b SAX ( levels , symbols ) ) ,  Charsets .  US_ ASCII ) ;  GTSHelper . set Value ( sax GTS , gts . ticks [ i ] , word ) ; } return sax GTS ; }
private final  String msg Stack To String (  Parse Exception e ) {  String Buffer msg ; msg = new  String Buffer ( _ STR ) ; if ( ! expecting . equals ( empty String ) ) { msg . append ( _ STR ) ; msg . append ( expecting ) ; msg . append ( _ STR ) ; } msg . append ( e . get Short Message ( ) ) ; msg . append ( _ STR ) ; int last = msg Stack Current Size - _ NUM ; if ( last < _ NUM ) last = _ NUM ; for ( int lvi = msg Stack Current Size ; lvi > last ; lvi -= _ NUM ) { msg . append ( (  String ) msg Stack [ lvi - _ NUM ] ) ; msg . append ( _ STR ) ;  Token t = (  Token ) msg Stack [ lvi - _ NUM ] ; msg . append ( t . begin Line ) ; msg . append ( _ STR ) ; msg . append ( t . begin Column ) ; msg . append ( _ STR ) ; } return msg . to String ( ) ; }
public static final void write Int Array Xml ( int [ ] val ,  String name ,  Xml Serializer out ) throws  Xml Pull Parser Exception , java . io .  IOException { if ( val == null ) { out . start Tag ( null , _ STR ) ; out . end Tag ( null , _ STR ) ; return ; } out . start Tag ( null , _ STR ) ; if ( name != null ) { out . attribute ( null , _ STR , name ) ; } final int  N = val . length ; out . attribute ( null , _ STR ,  Integer . to String (  N ) ) ; for ( int i = _ NUM ; i <  N ; i ++ ) { out . start Tag ( null , _ STR ) ; out . attribute ( null , _ STR ,  Integer . to String ( val [ i ] ) ) ; out . end Tag ( null , _ STR ) ; } out . end Tag ( null , _ STR ) ; }
protected  Rewritten Outbound Url process Encode URL (  Http Servlet Response hs Response ,  Http Servlet Request hs Request , boolean encode Url Has Been Run ,  String outbound Url ) { if ( log . is Debug Enabled ( ) ) { log . debug ( _ STR + outbound Url ) ; } if ( outbound Url == null ) { return new  Rewritten Outbound Url ( null , _ BOOL ) ; } boolean final Encode Outbound Url = _ BOOL ;  String final To Url = outbound Url ; final  List outbound Rules = conf . get Outbound Rules ( ) ; try { for ( int i = _ NUM ; i < outbound Rules . size ( ) ; i ++ ) { final  Outbound Rule outbound Rule = (  Outbound Rule ) outbound Rules . get ( i ) ; if ( ! encode Url Has Been Run && outbound Rule . is Encode First ( ) ) { continue ; } if ( encode Url Has Been Run && ! outbound Rule . is Encode First ( ) ) { continue ; } final  Rewritten Outbound Url rewritten Url = outbound Rule . execute ( final To Url , hs Request , hs Response ) ; if ( rewritten Url != null ) { if ( log . is Debug Enabled ( ) ) { log . debug ( _ STR + outbound Rule . get Display Name ( ) + _ STR ) ; } final To Url = rewritten Url . get Target ( ) ; final Encode Outbound Url = rewritten Url . is Encode ( ) ; if ( outbound Rule . is Last ( ) ) { log . debug ( _ STR ) ; break ; } } } } catch (  Invocation Target Exception e ) { try { handle Invocation Target Exception ( hs Request , hs Response , e ) ; } catch (  Servlet Exception e1 ) { log . error ( e1 ) ; } catch (  IOException e1 ) { log . error ( e1 ) ; } } return new  Rewritten Outbound Url ( final To Url , final Encode Outbound Url ) ; }
public  Account Creator ( final  String username , final  String password , final  String email ) { this . username = username . trim ( ) ; this . password = password . trim ( ) ; this . email = email . trim ( ) ; }
public  String encode Flags (  Flags flags ) {  String Builder local Flags String = new  String Builder ( _ STR ) ; if ( flags . contains (  Flags .  Flag .  DRAFT ) ) local Flags String . append (  FLAG_ DRAFT ) ; if ( flags . contains (  Flags .  Flag .  FLAGGED ) ) local Flags String . append (  FLAG_ FLAGGED ) ; if ( flags . contains (  Flags .  Flag .  ANSWERED ) ) local Flags String . append (  FLAG_ ANSWERD ) ; if ( flags . contains (  Flags .  Flag .  SEEN ) ) local Flags String . append (  FLAG_ SEEN ) ; if ( flags . contains (  Flags .  Flag .  DELETED ) ) local Flags String . append (  FLAG_ DELETED ) ; return local Flags String . to String ( ) ; }
public static boolean contains Key (  Key Store key Store ) throws  Crypto Exception { try {  Enumeration <  String > aliases = key Store . aliases ( ) ; while ( aliases . has More Elements ( ) ) {  String alias = aliases . next Element ( ) ; if ( is Key Entry ( alias , key Store ) ) { return _ BOOL ; } } return _ BOOL ; } catch (  Key Store Exception ex ) { throw new  Crypto Exception ( res . get String ( _ STR ) , ex ) ; } }
void purge Orphaned Articles ( ) { if ( ! is DBAvailable ( ) ) return ; long time =  System . current Time Millis ( ) ; safely Delete Articles ( _ STR +  TABLE_ FEEDS + _ STR , null ) ;  Log . d (  TAG , _ STR + (  System . current Time Millis ( ) - time ) + _ STR ) ; }
public void reclaim Views (  List <  View > views ) { int child Count = get Child Count ( ) ;  Recycler Listener listener = m Recycler . m Recycler Listener ; for ( int i = _ NUM ; i < child Count ; i ++ ) {  View child = get Child At ( i ) ;  PLA_ Abs List View .  Layout Params lp = (  PLA_ Abs List View .  Layout Params ) child . get Layout Params ( ) ; if ( lp != null && m Recycler . should Recycle View Type ( lp . view Type ) ) { views . add ( child ) ; if ( listener != null ) { listener . on Moved To Scrap Heap ( child ) ; } } } m Recycler . reclaim Scrap Views ( views ) ; remove All Views In Layout ( ) ; }
public static void check Proxy Method (  Object proxy ,  Method method ) { if ( proxy == null || !  Proxy . is Proxy Class ( proxy . get Class ( ) ) ) { throw new  Illegal Argument Exception ( _ STR ) ; } if (  Modifier . is Static ( method . get Modifiers ( ) ) ) { throw new  Illegal Argument Exception ( _ STR ) ; }  Class < ? > c = method . get Declaring Class ( ) ; if ( c ==  Object . class ) {  String name = method . get Name ( ) ; if ( name . equals ( _ STR ) || name . equals ( _ STR ) || name . equals ( _ STR ) ) { return ; } } if ( is Super Interface ( proxy . get Class ( ) , c ) ) { return ; } throw new  Illegal Argument Exception ( _ STR + method ) ; }
@  Override public void paint (  Graphics g ) { super . paint ( g ) ; paint Empty Rows ( g ) ; }
private boolean before ( long a , long b ) { return a < b ^ a - b > (  MAXIMUM_ KEY / _ NUM ) ; }
private boolean serialize Compact RDFAttr Props (  XMPNode parent Node , int indent ) throws  IOException { boolean all Are Attrs = _ BOOL ; for (  Iterator it = parent Node . iterate Children ( ) ; it . has Next ( ) ; ) {  XMPNode prop = (  XMPNode ) it . next ( ) ; if ( can Be RDFAttr Prop ( prop ) ) { write Newline ( ) ; write Indent ( indent ) ; write ( prop . get Name ( ) ) ; write ( _ STR ) ; append Node Value ( prop . get Value ( ) , _ BOOL ) ; write ( _ STR ) ; } else { all Are Attrs = _ BOOL ; } } return all Are Attrs ; }
public boolean is Option Checked ( int index ) { if ( index >= checkbox Panel . get Components ( ) . length ) { return _ BOOL ; }  JCheck Box checkbox = (  JCheck Box ) checkbox Panel . get Component ( index ) ; if ( checkbox . is Selected ( ) ) { return _ BOOL ; } else { return _ BOOL ; } }
public void pop ( ) { state = (  Graphics State ) stack . pop ( ) ; set Transform ( state . xform ) ; set Clip ( state . cliprgn ) ; }
public static void drop Index (  Connection conn ,  String schema ,  String table ) throws  SQLException { init ( conn ) ;  Prepared Statement prep = conn . prepare Statement ( _ STR +  SCHEMA + _ STR ) ; prep . set String ( _ NUM , schema ) ; prep . set String ( _ NUM , table ) ; int row Count = prep . execute Update ( ) ; if ( row Count == _ NUM ) { return ; } reindex ( conn ) ; }
public synchronized int index Of (  IAudio Processor processor ) { return processors . index Of ( processor ) ; }
public static byte [ ] remove MAC ( byte [ ] key , byte [ ] data ) { long hash =  Sip Hash Inline . hash24_palindromic ( key , data , _ NUM , data . length - _ NUM ) ; long mac =  Longs . from Byte Array (  Arrays . copy Of Range ( data , data . length - _ NUM , data . length ) ) ; if ( mac == hash ) { return  Arrays . copy Of ( data , data . length - _ NUM ) ; } else { return null ; } }
public void initialize (  Map config Params ) {  String delimiter Config = (  String ) config Params . get (  Policy Config .  RESOURCE_ COMPARATOR_ DELIMITER ) ; if ( delimiter Config != null ) { this . delimiter = delimiter Config ; }  String case Config = (  String ) config Params . get (  Policy Config .  RESOURCE_ COMPARATOR_ CASE_ SENSITIVE ) ; if ( case Config != null ) { if ( case Config . equals ( _ STR ) ) { this . case Sensitive = _ BOOL ; } else if ( case Config . equals ( _ STR ) ) { this . case Sensitive = _ BOOL ; } else { this . case Sensitive = _ BOOL ; } }  String wildcard Config = (  String ) config Params . get (  Policy Config .  RESOURCE_ COMPARATOR_ WILDCARD ) ; if ( wildcard Config != null ) { this . wildcard = wildcard Config ; } return ; }
public static boolean is SSH (  String uri ) { return uri != null && uri . starts With ( _ STR ) ; }
protected boolean compare And Set State (  State Type old State ,  State Type new State ) { if ( state . compare And Set ( old State , new State ) ) { after State Changed ( new State ) ; return _ BOOL ; } else return _ BOOL ; }
public int length ( ) { return m Label . length ( ) + m Suffix . length ( ) ; }
private static void insert Comments In Cu (  Compilation Unit cu ,  Comments Collection comments Collection ) { if ( comments Collection . size ( ) == _ NUM ) return ;  List <  Comment > comments = comments Collection . get All ( ) ;  Position Utils . sort By Begin Position ( comments ) ;  List <  Node > children = cu . get Children Nodes ( ) ;  Position Utils . sort By Begin Position ( children ) ; if ( cu . get Package ( ) != null && ( children . size ( ) == _ NUM ||  Position Utils . are In Order ( comments . get ( _ NUM ) , children . get ( _ NUM ) ) ) ) { cu . set Comment ( comments . get ( _ NUM ) ) ; comments . remove ( _ NUM ) ; } insert Comments In Node ( cu , comments ) ; }
public static  String Buffer read From File (  String file Path ) { return read From File ( new  File ( file Path ) ) ; }
public synchronized void check Access (  License Checker Callback callback ) { if ( m Policy . allow Access ( ) ) {  Log . i (  TAG , _ STR ) ; callback . allow (  Policy .  LICENSED ) ; } else {  License Validator validator = new  License Validator ( m Policy , new  Null Device Limiter ( ) , callback , generate Nonce ( ) , m Package Name , m Version Code ) ; if ( m Service == null ) {  Log . i (  TAG , _ STR ) ; try { boolean bind Result = m Context . bind Service ( new  Intent ( _ STR ) , this ,  Context .  BIND_ AUTO_ CREATE ) ; if ( bind Result ) { m Pending Checks . offer ( validator ) ; } else {  Log . e (  TAG , _ STR ) ; handle Service Connection Error ( validator ) ; } } catch (  Exception e ) { callback . application Error (  License Checker Callback .  ERROR_ MISSING_ PERMISSION ) ; } } else { m Pending Checks . offer ( validator ) ; run Checks ( ) ; } } }
public static boolean save String To File (  String save File Path And Name ,  String save String ) { if ( ( save File Path And Name == null ) || save File Path And Name . is Empty ( ) || ( save String == null ) || save String . is Empty ( ) ) { return _ BOOL ; }  Buffered Writer writer = null ; try {  File output File = new  File ( save File Path And Name ) ; writer = new  Buffered Writer ( new  File Writer ( output File ) ) ; writer . write ( save String ) ; return _ BOOL ; } catch (  Exception e ) { logger . debug ( e . to String ( ) +  System . line Separator ( ) +  Stack Trace . get String From Stack Trace ( e ) ) ; return _ BOOL ; } finally { try { if ( writer != null ) { writer . close ( ) ; } } catch (  Exception e ) { logger . debug ( e . to String ( ) +  System . line Separator ( ) +  Stack Trace . get String From Stack Trace ( e ) ) ; } } }
protected static  String [ ] split String By Delimiter Points (  String s Str ,  Integer [ ] i Res ) {  Array List al Res = new  Array List ( ) ; for ( int i Cnt = _ NUM ; i Cnt < i Res . length ; i Cnt ++ ) { if ( i Cnt == _ NUM ) al Res . add ( s Str . substring ( _ NUM , i Res [ i Cnt ] ) ) ; else al Res . add ( s Str . substring ( i Res [ i Cnt - _ NUM ] , i Res [ i Cnt ] ) ) ; } if ( i Res . length > _ NUM ) al Res . add ( s Str . substring ( i Res [ i Res . length - _ NUM ] ) ) ; else al Res . add ( s Str ) ;  String [ ] s Res = new  String [ al Res . size ( ) ] ; al Res . to Array ( s Res ) ; return s Res ; }
public static boolean [ ] convert String To Boolean Arr (  String no Dictionary Col Mapping ) {  String [ ] splitted Value = null != no Dictionary Col Mapping ? no Dictionary Col Mapping . split (  Carbon Common Constants .  COMA_ SPC_ CHARACTER ) : new  String [ _ NUM ] ; boolean [ ] no Dictionary Mapping = new boolean [ splitted Value . length ] ; int index = _ NUM ; for (  String str : splitted Value ) { no Dictionary Mapping [ index ++ ] =  Boolean . parse Boolean ( str ) ; } return no Dictionary Mapping ; }
public void clear Results ( ) { m_ Results . clear ( ) ; m_ Model . clear ( ) ; m_ Objs . clear ( ) ;  System . gc ( ) ; }
public static int desaturate ( int c ) { int a = c & _ NUM ; float r = ( ( c & _ NUM ) > > _ NUM ) ; float g = ( ( c & _ NUM ) > > _ NUM ) ; float b = ( c & _ NUM ) ; r *= _ NUM ; g *= _ NUM ; b *= _ NUM ; int gray =  Math . min ( ( ( int ) ( r + g + b ) ) , _ NUM ) & _ NUM ; return a | ( gray << _ NUM ) | ( gray << _ NUM ) | gray ; }
public synchronized void join ( ) throws  Interrupted Exception { int n Threads = runners . size ( ) ; if ( n Threads == _ NUM ) return ; if ( ! started ) start ( ) ; semaphore . acquire ( n Threads ) ; semaphore . release ( n Threads ) ; }
public  Serial Message ( byte [ ] a ) { super (  String . value Of ( a ) ) ; }
@  Override @  Suppress Warnings ( _ STR ) public void completed ( int bytes Transferred , boolean can Invoke Direct ) { update Buffers ( bytes Transferred ) ; release Buffers ( ) ; synchronized ( result ) { if ( result . is Done ( ) ) return ; enable Writing ( ) ; if ( gathering Write ) { result . set Result ( (  V )  Long . value Of ( bytes Transferred ) ) ; } else { result . set Result ( (  V )  Integer . value Of ( bytes Transferred ) ) ; } } if ( can Invoke Direct ) {  Invoker . invoke Unchecked ( result ) ; } else {  Invoker . invoke ( result ) ; } }
public void write Golomb ( int divisor , int value ) throws  IOException { int q = value / divisor ; for ( int i = _ NUM ; i < q ; i ++ ) { write Bit ( _ BOOL ,  MAX_ PROBABILITY / _ NUM ) ; } write Bit ( _ BOOL ,  MAX_ PROBABILITY / _ NUM ) ; int r = value - q * divisor ; int bit = _ NUM -  Integer . number Of Leading Zeros ( divisor - _ NUM ) ; if ( r < ( ( _ NUM << bit ) - divisor ) ) { bit -- ; } else { r += ( _ NUM << bit ) - divisor ; } for ( ; bit >= _ NUM ; bit -- ) { write Bit ( ( ( r > > > bit ) & _ NUM ) == _ NUM ,  MAX_ PROBABILITY / _ NUM ) ; } }
private static  Metric Value duration_to_metricvalue_ (  Duration duration ) { return  Metric Value . from Int Value ( duration . get Millis ( ) ) ; }
public  Span trim (  Char Sequence src ) { if ( start < end ) while ( src . char At ( end - _ NUM ) == _ NUM ) { end -- ; if ( start == end ) break ; } if ( start < end ) while ( src . char At ( start ) == _ NUM ) { start ++ ; if ( start == end ) break ; } return this ; }
private static long mix K1 ( long k1 ) { k1 *=  C1 ; k1 =  Long . rotate Left ( k1 , _ NUM ) ; k1 *=  C2 ; return k1 ; }
protected void prepare ( ) { for (  Process Info Parameter para : get Parameter ( ) ) {  String name = para . get Parameter Name ( ) ; if ( para . get Parameter ( ) == null ) ; else if ( name . equals (  X_ M_ Product .  COLUMNNAME_ M_ Product_ ID ) ) { p_ M_ Product_ ID = para . get Parameter As Int ( ) ; } else if ( name . equals (  X_ M_ Warehouse .  COLUMNNAME_ M_ Warehouse_ ID ) ) { p_ M_ Warehouse_ ID = para . get Parameter As Int ( ) ; } else if ( name . equals ( _ STR ) ) { p_ Date Trx = (  Timestamp ) para . get Parameter ( ) ; } else if ( name . equals (  X_ PP_ Order_ BOMLine .  COLUMNNAME_ Qty Required ) ) { p_ Qty Requiered = (  Big Decimal ) para . get Parameter ( ) ; } else if ( name . equals (  X_ PP_ Product_ BOMLine .  COLUMNNAME_ Backflush Group ) ) { p_ Backflush Group = (  String ) para . get Parameter ( ) ; } else if ( name . equals (  X_ T_ BOMLine .  COLUMNNAME_ Level No ) ) { p_ Level No = para . get Parameter As Int ( ) ; } else log . log (  Level .  SEVERE , _ STR + name ) ; } }
public static boolean is Http (  String url ) { return url != null && url . length ( ) > _ NUM && url . starts With ( _ STR ) && url . char At ( _ NUM ) != _ STR ; }
private static void  Release String UTFChars (  JNIEnvironment env , int obj JREF ,  Address buf Address ) { if ( trace JNI )  VM . sys Write ( _ STR ) ;  Runtime Entrypoints . check JNICount Down To GC ( ) ; try { sys Call . sys Free ( buf Address ) ; } catch (  Throwable unexpected ) { if ( trace JNI ) unexpected . print Stack Trace (  System . err ) ; env . record Exception ( unexpected ) ; } }
public void make Backup File (  String name ) {  File file = find File ( name ) ; if ( file == null ) { log . info ( _ STR + name + _ STR ) ; } else if ( file . can Write ( ) ) {  String backup Name = backup File Name ( file . get Absolute Path ( ) ) ;  File backup File = find File ( backup Name ) ; if ( backup File != null ) { if ( backup File . delete ( ) ) { log . debug ( _ STR + backup Name ) ; } } if ( file . rename To ( new  File ( backup Name ) ) ) { log . debug ( _ STR + backup Name ) ; } else { log . error ( _ STR + backup Name ) ; } } }
public static boolean add Files To Existing Zip Aapt (  File temp Apk ,  Array List <  File > classes Files ) {  Array List <  String > rm Cmd = new  Array List <  String > ( ) ; rm Cmd . add (  S . get Aapt ( ) ) ; rm Cmd . add ( _ STR ) ; rm Cmd . add ( _ STR ) ; rm Cmd . add ( temp Apk . get Absolute Path ( ) ) ; for (  File f : classes Files ) rm Cmd . add ( f . get Name ( ) ) ;  String [ ] cmd Rm = new  String [ rm Cmd . size ( ) ] ; for ( int i = _ NUM ; i < rm Cmd . size ( ) ; i ++ ) cmd Rm [ i ] = rm Cmd . get ( i ) ;  Cmd Utils . run Command ( cmd Rm ) ;  Array List <  String > cmds = new  Array List <  String > ( ) ; cmds . add (  S . get Aapt ( ) ) ; cmds . add ( _ STR ) ; cmds . add ( _ STR ) ; cmds . add ( temp Apk . get Absolute Path ( ) ) ; for (  File f : classes Files ) cmds . add ( f . get Absolute Path ( ) ) ;  String [ ] cmd = new  String [ cmds . size ( ) ] ; for ( int i = _ NUM ; i < cmds . size ( ) ; i ++ ) cmd [ i ] = cmds . get ( i ) ; boolean sucess = (  Cmd Utils . run Command ( cmd ) == _ NUM ) ; if ( ! sucess ) { sucess = _ BOOL ; for (  File f : classes Files ) { try { sucess = sucess &&  Zip Tools . is Filein Zip ( f . get Name ( ) , new  Zip File ( temp Apk ) ) ; } catch (  Zip Exception e ) { e . print Stack Trace ( ) ; } } } return sucess ; }
void add Label (  Component label ) { if ( labels == null ) { labels = new  Vector ( ) ; } labels . add Element ( label ) ; }
private void init App Settings ( ) { log . debug ( _ STR ) ;  Game Settings local Settings = new  Game Settings ( ) ; init Settings ( local Settings ) ; settings = local Settings . to Read Only ( ) ; log . debug ( _ STR + settings . to String ( ) ) ; }
public void add Region (  Region r ) { regions . add ( r ) ; }
public static void silent Close Input Stream (  Input Stream is ) { try { if ( is != null ) { is . close ( ) ; } } catch (  IOException e ) {  Log . w (  LOG_ TAG , _ STR , e ) ; } }
@  Override public void start Element (  String uri ,  String name ,  String q Name ,  Attributes attributes ) { inside = q Name ; this . attributes = attributes ; if ( q Name . equals ( _ STR ) ) start Tag ( ) ; else if ( q Name . equals ( _ STR ) ) start Att ( ) ; else if ( q Name . equals ( _ STR ) ) start Script ( ) ; }
public void stop ( int timeout ) throws  Interrupted Exception { if ( ! isclosed . compare And Set ( _ BOOL , _ BOOL ) ) { return ; }  List <  Web Socket > sockets To Close = null ; synchronized ( connections ) { sockets To Close = new  Array List <  Web Socket > ( connections ) ; } for (  Web Socket ws : sockets To Close ) { ws . close (  Close Frame .  GOING_ AWAY ) ; } synchronized ( this ) { if ( selectorthread != null && selectorthread !=  Thread . current Thread ( ) ) { selector . wakeup ( ) ; selectorthread . interrupt ( ) ; selectorthread . join ( timeout ) ; } } }
public void validate Storage Files (  List <  Storage File > expected Storage Files ,  List <  Storage File > actual Storage Files ) { assert Equals ( expected Storage Files . size ( ) , actual Storage Files . size ( ) ) ; for ( int i = _ NUM ; i < expected Storage Files . size ( ) ; i ++ ) {  Storage File expected Storage File = expected Storage Files . get ( i ) ;  Storage File actual Storage File = actual Storage Files . get ( i ) ; assert Equals ( expected Storage File . get File Path ( ) , actual Storage File . get File Path ( ) ) ; assert Equals ( expected Storage File . get File Size Bytes ( ) , actual Storage File . get File Size Bytes ( ) ) ; assert Equals ( expected Storage File . get Row Count ( ) , actual Storage File . get Row Count ( ) ) ; } }
protected void calculate Bar Width (  Category Plot plot ,  Rectangle2 D data Area , int renderer Index ,  Category Item Renderer State state ) {  Category Axis domain Axis = get Domain Axis ( plot , renderer Index ) ;  Category Dataset dataset = plot . get Dataset ( renderer Index ) ; if ( dataset != null ) { int columns = dataset . get Column Count ( ) ; int rows = state . get Visible Series Count ( ) >= _ NUM ? state . get Visible Series Count ( ) : dataset . get Row Count ( ) ; double space = _ NUM ;  Plot Orientation orientation = plot . get Orientation ( ) ; if ( orientation ==  Plot Orientation .  HORIZONTAL ) { space = data Area . get Height ( ) ; } else if ( orientation ==  Plot Orientation .  VERTICAL ) { space = data Area . get Width ( ) ; } double max Width = space * get Maximum Bar Width ( ) ; double category Margin = _ NUM ; double current Item Margin = _ NUM ; if ( columns > _ NUM ) { category Margin = domain Axis . get Category Margin ( ) ; } if ( rows > _ NUM ) { current Item Margin = get Item Margin ( ) ; } double used = space * ( _ NUM - domain Axis . get Lower Margin ( ) - domain Axis . get Upper Margin ( ) - category Margin - current Item Margin ) ; if ( ( rows * columns ) > _ NUM ) { state . set Bar Width (  Math . min ( used / ( rows * columns ) , max Width ) ) ; } else { state . set Bar Width (  Math . min ( used , max Width ) ) ; } } }
@  Requires Permission (  Manifest . permission .  CAMERA ) public  Camera Source start ( ) throws  IOException { synchronized ( m Camera Lock ) { if ( m Camera != null ) { return this ; } m Camera = create Camera ( ) ; if (  Build .  VERSION .  SDK_ INT >=  Build .  VERSION_ CODES .  HONEYCOMB ) { m Dummy Surface Texture = new  Surface Texture (  DUMMY_ TEXTURE_ NAME ) ; m Camera . set Preview Texture ( m Dummy Surface Texture ) ; } else { m Dummy Surface View = new  Surface View ( m Context ) ; m Camera . set Preview Display ( m Dummy Surface View . get Holder ( ) ) ; } m Camera . start Preview ( ) ; m Processing Thread = new  Thread ( m Frame Processor ) ; m Frame Processor . set Active ( _ BOOL ) ; m Processing Thread . start ( ) ; } return this ; }
public void remove Breakpoint Listener ( final  Breakpoint Listener listener ) { breakpoint Listeners . remove ( listener ) ; }
public void update ( final  Graphics g ) { paint ( g ) ; }
public static void print Stack Trace (  Throwable t ) { print Stack Trace ( t , null ) ; }
@  Override public  Void visit Variable (  Variable Element e ,  Void p ) { if ( ! check For Serial ( e ) ) { if ( e . get Kind ( ) ==  ENUM_ CONSTANT || e . get Constant Value ( ) != null || heuristically Constant ( e ) ) check All Caps ( e ) ; else check Camel Case ( e , _ BOOL ) ; } return null ; }
protected boolean is Equal Key (  Abstract Hashed Map .  Hash Entry entry ,  Object key1 ,  Object key2 ) {  Multi Key multi = (  Multi Key ) entry . get Key ( ) ; return multi . size ( ) == _ NUM && ( key1 == null ? multi . get Key ( _ NUM ) == null : key1 . equals ( multi . get Key ( _ NUM ) ) ) && ( key2 == null ? multi . get Key ( _ NUM ) == null : key2 . equals ( multi . get Key ( _ NUM ) ) ) ; }
static double f ( double x ) { return x *  Math . sin ( x ) - _ NUM * x -  Math . cos ( x ) ; }
public boolean in Test Set (  String source Side ) { if ( ! source Side . equals ( last Source Side ) ) { last Source Side = source Side ; accepted Last Source Side = filter . permits ( source Side ) ; } else { cached ++ ; } return accepted Last Source Side ; }
void add Channel (  Notification Channel channel ) { channels . add ( channel ) ; }
public static final boolean create File Parent Dir (  String file Path ) {  File file = new  File ( file Path ) ; if ( file != null ) { if ( file . exists ( ) ) { return _ BOOL ; } else {  File parent File = file . get Parent File ( ) ; if ( parent File != null ) { if ( parent File . exists ( ) ) { return _ BOOL ; } else { return parent File . mkdirs ( ) ; } } } } return _ BOOL ; }
public  E take ( ) throws  Interrupted Exception { final  Reentrant Lock lock = this . lock ; lock . lock Interruptibly ( ) ; try { for ( ; ; ) {  E first = q . peek ( ) ; if ( first == null ) available . await ( ) ; else { long delay = first . get Delay (  NANOSECONDS ) ; if ( delay <= _ NUM ) return q . poll ( ) ; first = null ; if ( leader != null ) available . await ( ) ; else {  Thread this Thread =  Thread . current Thread ( ) ; leader = this Thread ; try { available . await Nanos ( delay ) ; } finally { if ( leader == this Thread ) leader = null ; } } } } } finally { if ( leader == null && q . peek ( ) != null ) available . signal ( ) ; lock . unlock ( ) ; } }
public boolean submit Action (  Action0 action ) { boolean submitted = _ BOOL ;  Thread current Thread =  Thread . current Thread ( ) ; if ( current Thread . equals ( duty Thread ) ) { action . call ( ) ; } else { submitted = actions . offer ( action ) ; } return submitted ; }
CSSElement (  String name ) { set Tag Id (  TAG_ CSS_ SELECTOR ) ; int index = name . index Of ( _ STR ) ;  String tag Name = name ; if ( index != - _ NUM ) { tag Name = name . substring ( _ NUM , index ) ; if (  HTMLComponent .  PROCESS_ HTML_ MP1_ ONLY ) { set Tag Id (  TAG_ CSS_ ILLEGAL_ SELECTOR ) ; } else { while ( index != - _ NUM ) { int end Index = name . index Of ( _ STR ) ; if ( ( end Index != - _ NUM ) && ( end Index > index + _ NUM ) ) {  String str = name . substring ( index + _ NUM , end Index ) ; add Attribute Selection ( str ) ; } else { set Tag Id (  TAG_ CSS_ ILLEGAL_ SELECTOR ) ; break ; } name = name . substring ( end Index + _ NUM ) ; index = name . index Of ( _ STR ) ; } } } set Tag Name ( tag Name ) ; for ( int i = _ NUM ; i <=  LAST_ CSS_ PROPERTY_ INDEX ; i ++ ) { attr Vals [ i ] = - _ NUM ; } }
public void add Value (  Value value ) { action Values . add ( value ) ; action Values As Array = null ; }
@  Override public void channel Open (  Channel Handler Context channel Handler Context ,  Channel State Event channel State Event ) throws  Exception { total_conns . increment And Get ( ) ; curr_conns . increment And Get ( ) ; channel Group . add ( channel Handler Context . get Channel ( ) ) ; }
private boolean are New Patch Files Available ( ) throws  IOException {  String remote Head = git Wrapper . get Remote Head ( binary Patch Repo Directory ) ;  String local Head = git Wrapper . get Local Head ( binary Patch Repo Directory ) ; boolean needs Patching = ! local Head . equals ( remote Head ) ; if ( needs Patching ) { logger . info ( _ STR , remote Head ) ; } else { logger . info ( _ STR , remote Head ) ; } return needs Patching ; }
public static boolean is Next Window (  URI id ) { return  NEXT . equals ( id ) ; }
public  Queue Event offer ( byte [ ] data , long timeout ) throws  Keeper Exception ,  Interrupted Exception {  Timer Context time = stats . time ( dir + _ STR ) ; try {  String path = create Data ( dir + _ STR + prefix , data ,  Create Mode .  PERSISTENT_ SEQUENTIAL ) ;  String watch ID = create Data ( dir + _ STR + response_prefix + path . substring ( path . last Index Of ( _ STR ) + _ NUM ) , null ,  Create Mode .  EPHEMERAL ) ;  Object lock = new  Object ( ) ;  Latch Child Watcher watcher = new  Latch Child Watcher ( lock ) ; synchronized ( lock ) { if ( zookeeper . exists ( watch ID , watcher , _ BOOL ) != null ) { watcher . await ( timeout ) ; } } byte [ ] bytes = zookeeper . get Data ( watch ID , null , null , _ BOOL ) ; zookeeper . delete ( watch ID , - _ NUM , _ BOOL ) ; return new  Queue Event ( watch ID , bytes , watcher . get Watched Event ( ) ) ; } finally { time . stop ( ) ; } }
public  Property XMLBuilder (  String service Name ,  AMModel model ,  Set attribute Schemas ,  Schema Type schema Type ) throws  SMSException ,  SSOException { this . model = model ; this . service Name = service Name ; svc Schema Manager = new  Service Schema Manager ( service Name , model . get User SSOToken ( ) ) ; if ( schema Type != null ) { if ( load Section Order ( ) ) { schema Types = new  Hash Set <  Schema Type > ( ) ; schema Types . add ( schema Type ) ; get Sections For Type ( ) ; } } get Service Resource Bundle ( ) ; if ( service Bundle != null ) { map Type To Attribute Schema = new  Hash Map ( attribute Schemas . size ( ) * _ NUM ) ; map Type To Attribute Schema . put (  NULL_ TYPE , attribute Schemas ) ; } }
private boolean is Named Param (  String arg ) { return arg . starts With ( _ STR ) && ( arg . index Of ( _ STR ) > _ NUM && valid First Char ( arg . char At ( _ NUM ) ) ) ; }
public static  List <  String > to List (  String [ ] array ) {  List <  String > list = new  Array List <  String > ( ) ; if ( ( array != null ) && ( array . length > _ NUM ) ) { for ( int i = _ NUM ; i < array . length ; i ++ ) { list . add ( array [ i ] ) ; } } return list ; }
private void show Next Super Toast ( ) { if ( super Toast Priority Queue . is Empty ( ) ) return ; final  Super Toast super Toast = super Toast Priority Queue . peek ( ) ; if ( ! super Toast . is Showing ( ) ) { final  Message message = obtain Message (  Messages .  DISPLAY_ SUPERTOAST ) ; message . obj = super Toast ; send Message ( message ) ; } }
public void test_vmstat_header_and_data_parse ( ) { final  Pattern pattern =  VMStat Collector . pattern ; final  String h0 = _ STR ; final  String h1 = _ STR ; final  String d1 = _ STR ; { final  String [ ] fields = pattern . split ( h0 . trim ( ) , _ NUM ) ; for ( int i = _ NUM ; i < fields . length ; i ++ ) { if ( log . is Info Enabled ( ) ) log . info ( _ STR + i + _ STR + fields [ i ] + _ STR ) ; } assert Field ( h0 , fields , _ NUM , _ STR ) ; assert Field ( h0 , fields , _ NUM , _ STR ) ; } { final  String [ ] fields = pattern . split ( h1 . trim ( ) , _ NUM ) ; for ( int i = _ NUM ; i < fields . length ; i ++ ) { if ( log . is Info Enabled ( ) ) log . info ( _ STR + i + _ STR + fields [ i ] + _ STR ) ; } assert Field ( h1 , fields , _ NUM , _ STR ) ; assert Field ( h1 , fields , _ NUM , _ STR ) ; assert Field ( h1 , fields , _ NUM , _ STR ) ; assert Field ( h1 , fields , _ NUM , _ STR ) ; assert Field ( h1 , fields , _ NUM , _ STR ) ; assert Field ( h1 , fields , _ NUM , _ STR ) ; assert Field ( h1 , fields , _ NUM , _ STR ) ; assert Field ( h1 , fields , _ NUM , _ STR ) ; assert Field ( h1 , fields , _ NUM , _ STR ) ; assert Field ( h1 , fields , _ NUM , _ STR ) ; assert Field ( h1 , fields , _ NUM , _ STR ) ; } { final  String [ ] fields = pattern . split ( d1 . trim ( ) , _ NUM ) ; assert Field ( d1 , fields , _ NUM , _ STR ) ; assert Field ( d1 , fields , _ NUM , _ STR ) ; assert Field ( d1 , fields , _ NUM , _ STR ) ; assert Field ( d1 , fields , _ NUM , _ STR ) ; assert Field ( d1 , fields , _ NUM , _ STR ) ; assert Field ( d1 , fields , _ NUM , _ STR ) ; assert Field ( d1 , fields , _ NUM , _ STR ) ; assert Field ( d1 , fields , _ NUM , _ STR ) ; assert Field ( d1 , fields , _ NUM , _ STR ) ; assert Field ( d1 , fields , _ NUM , _ STR ) ; assert Field ( d1 , fields , _ NUM , _ STR ) ; } }
public static boolean is Auth NAssertion (  Assertion assertion ) { if ( assertion == null ) { return _ BOOL ; } if ( ( ! assertion . is Time Valid ( ) ) || ( ! assertion . is Signature Valid ( ) ) ) { return _ BOOL ; }  Set statements = assertion . get Statement ( ) ;  Statement statement = null ;  Iterator iterator = statements . iterator ( ) ; while ( iterator . has Next ( ) ) { statement = (  Statement ) iterator . next ( ) ; if ( statement . get Statement Type ( ) ==  Statement .  AUTHENTICATION_ STATEMENT ) { return _ BOOL ; } } return _ BOOL ; }
@  Override public void run ( ) { try { while ( running ) { step ( ) ; try {  Thread . sleep ( step Pause ) ; } catch (  Interrupted Exception e ) { e . print Stack Trace ( ) ; } } } catch (  Null Pointer Exception e ) { robot Gui . notify Initialize ( ) ; } catch (  Robot Exception e ) { } try { running Lock . acquire ( ) ; } catch (  Interrupted Exception e ) { e . print Stack Trace ( ) ; } running = _ BOOL ; gui . enable Buttons ( gui . button State Normal ) ; button . set Text ( gui . auto Locate Title ) ; running Lock . release ( ) ; }
public boolean is Attacked By ( final  IEntity attacker ) { return attackers . contains ( attacker ) ; }
public void vertex ( float [ ] v ) { vertex Check ( ) ; curve Vertex Count = _ NUM ; float [ ] vertex = vertices [ vertex Count ] ;  System . arraycopy ( v , _ NUM , vertex , _ NUM ,  VERTEX_ FIELD_ COUNT ) ; vertex Count ++ ; }
public void wait For Ready ( long how_long ) throws  IOException { long since =  System . current Time Millis ( ) ; synchronized ( state_mutex ) { while ( _ BOOL ) { if ( state ==  State .  DEMO ) { return ; } else if ( state ==  State .  ERROR || state ==  State .  DISCONNECTED ) { throw new  IOException ( _ STR ) ; } else if ( (  System . current Time Millis ( ) - since ) >= how_long ) { try { disconnect ( ) ; } catch (  IOException e ) { } throw new  IOException ( _ STR ) ; } long p =  Math . min ( how_long - (  System . current Time Millis ( ) - since ) , how_long ) ; if ( p > _ NUM ) { try { state_mutex . wait ( p ) ; } catch (  Interrupted Exception e ) { } } } } }
public static boolean is Fully Active (  Set <  String > live Nodes ,  Doc Collection collection State , int expected Shards , int expected Replicas ) {  Objects . require Non Null ( live Nodes ) ; if ( collection State == null ) return _ BOOL ; int active Shards = _ NUM ; for (  Slice slice : collection State ) { int active Replicas = _ NUM ; for (  Replica replica : slice ) { if ( replica . is Active ( live Nodes ) == _ BOOL ) return _ BOOL ; active Replicas ++ ; } if ( active Replicas != expected Replicas ) return _ BOOL ; active Shards ++ ; } return active Shards == expected Shards ; }
default  Type Declaration as Type ( ) { throw new  Unsupported Operation Exception (  String . format ( _ STR , this ) ) ; }
public static  String str Map To Str (  Map <  String ,  String > map ) {  String Builder sb = new  String Builder ( ) ; if ( map == null || map . is Empty ( ) ) return sb . to String ( ) ; for (  Entry <  String ,  String > entry : map . entry Set ( ) ) { sb . append ( _ STR + entry . get Key ( ) + _ STR + entry . get Value ( ) + _ STR ) ; } return sb . to String ( ) ; }
public void upload Image (  Multipart File file ,  Long cheque ID ,  String username ) { if ( ! file . is Empty ( ) ) {  Photo photo = new  Photo ( ) ; try { photo . set Bytes ( file . get Bytes ( ) ) ; } catch (  IOException e ) { e . print Stack Trace ( ) ; } photo . set Name ( file . get Original Filename ( ) ) ; photo . set Content Type ( file . get Content Type ( ) ) ; photo . set Cheque Id ( cheque ID . to String ( ) ) ; photo . set Username ( username ) ; photo . set Add Date (  Offset Date Time . now ( ) ) ; photo Repository . save ( photo ) ; } }
@  Override public double conf ( double total Weight , double delta ) { double inverse Normal = inverse Normal ( _ NUM - delta / _ NUM ) ; return  Math . sqrt ( inverse Normal / ( _ NUM *  Math . sqrt ( total Weight ) ) ) + inverse Normal / ( _ NUM *  Math . sqrt ( total Weight ) ) +  Math . pow ( inverse Normal / ( _ NUM *  Math . sqrt ( total Weight ) ) , _ NUM ) ; }
public  Expression next Valid ( final  Iterator <  Expression > it ) { while ( it . has Next ( ) ) { final  Expression expr = it . next ( ) ; if ( ! is Ignorable ( expr ) ) { return expr ; } } return null ; }
public void add Get Time Nanos ( long duration ) { get Time Nanos . add And Get ( duration ) ; if ( delegate != null ) delegate . add Get Time Nanos ( duration ) ; }
private float check Valid ( final float val ) { float tempval = val ; if ( val > _ NUM ) { tempval = _ NUM ; } if ( val < _ NUM ) { tempval = _ NUM ; } return tempval ; }
public boolean is Selected (  Object cell ) { return ( cell == null ) ? _ BOOL : cells . contains ( cell ) ; }
protected void build Substitutable Properties ( ) { for (  String prop Name : core Properties . string Property Names ( ) ) {  String prop Value = core Properties . get Property ( prop Name ) ; if ( ! is User Defined Property ( prop Name ) ) prop Name =  SOLR_ CORE_ PROP_ PREFIX + prop Name ; substitutable Properties . set Property ( prop Name , prop Value ) ; } }
public static  Process create And Start Process Intern (  File log ,  String target ,  String ... args ) throws  IOException {  Process Builder pb = new  Process Builder ( args ) ; pb . directory ( new  File ( target ) ) ;  Environment Variable Utils . inherit Node Js Path Env Variable Utils ( pb ) ; pb . redirect Error Stream ( _ BOOL ) ; pb . redirect Output (  Redirect . to ( log ) ) ;  Process p = pb . start ( ) ; assert pb . redirect Input ( ) ==  Redirect .  PIPE ; assert pb . redirect Output ( ) . file ( ) == log ; assert p . get Input Stream ( ) . read ( ) == - _ NUM ; return p ; }
@  Override public  Selectable Channel selectable Channel ( ) { if ( _s != null ) { return _s . get Channel ( ) ; } else { return null ; } }
public final void to String (  String Builder builder ) { builder . append ( get Name ( ) ) ; }
@  Override public void action Performed (  Action Event e ) {  File Dialog chooser = new  File Dialog ( frame , _ STR ,  File Dialog .  SAVE ) ; chooser . set Visible ( _ BOOL ) ; if ( chooser . get File ( ) != null ) { save ( chooser . get Directory ( ) +  File . separator + chooser . get File ( ) ) ; } }
private static int  Windows Reg Set Value Ex1 ( int h Key , byte [ ] value Name , byte [ ] value ) { int result =  Windows Reg Set Value Ex ( h Key , value Name , value ) ; if ( result ==  ERROR_ SUCCESS ) { return result ; } else { long sleep Time =  INIT_ SLEEP_ TIME ; for ( int i = _ NUM ; i <  MAX_ ATTEMPTS ; i ++ ) { try {  Thread . sleep ( sleep Time ) ; } catch (  Interrupted Exception e ) { return result ; } sleep Time *= _ NUM ; result =  Windows Reg Set Value Ex ( h Key , value Name , value ) ; if ( result ==  ERROR_ SUCCESS ) { return result ; } } } return result ; }
protected  Date Time Data parse (  String str ) throws  Schema Date Time Exception {  Date Time Data date = new  Date Time Data ( str , this ) ; int len = str . length ( ) ; date . year =  YEAR ; date . month =  MONTH ; date . day = _ NUM ; get Time ( str , _ NUM , len , date ) ; validate Date Time ( date ) ; save Unnormalized ( date ) ; if ( date . utc != _ NUM && date . utc != _ STR ) { normalize ( date ) ; date . day = _ NUM ; } date . position = _ NUM ; return date ; }
private void sort ( int column Index , int sort Count ) {  Sort Order order =  Sort Order . values ( ) [ sort Count % _ NUM ] ;  List <  Row Sorter .  Sort Key > sort Keys = new  Array List < > ( ) ; if ( column Index != _ NUM ) { sort Keys . add ( new  Row Sorter .  Sort Key ( _ NUM ,  Sort Order .  DESCENDING ) ) ; } sort Keys . add ( new  Row Sorter .  Sort Key ( column Index , order ) ) ; sorter . set Sort Keys ( sort Keys ) ; this . sort Count = sort Count ; sorted Column = column Index ; }
public void add Column (  String header ) { if ( get Model ( ) instanceof  Default Table Model ) {  Default Table Model model = (  Default Table Model ) get Model ( ) ; model . add Column (  Util . clean Amp ( header ) ) ; } else throw new  Illegal Argument Exception ( _ STR ) ; }
public boolean is Annotation Present (  Class < ? extends  Annotation > annotation Type ) { return get Annotation ( annotation Type ) != null ; }
private  String retrieve Full ID (  String resource ID ,  String object ID ) { return resource ID + _ STR + object ID ; }
static void create Directory ( final  String directory ) throws  IOException {  File dir = new  File ( directory ) ; if ( ! dir . exists ( ) ) { if ( ! dir . mkdirs ( ) ) { throw new  IOException ( _ STR + directory ) ; } } }
public void override Current Time ( long time ) { start Time =  System . current Time Millis ( ) ; current Time = _ NUM ; stored Time = time ; }
final public void println ( double v ) {  String s =  String . value Of ( v ) ; write ( s , _ NUM , s . length ( ) ) ; println ( ) ; }
public static void move And Mask ( final  ITranslation Environment environment , final long offset , final  Operand Size value Size , final  String value , final  String sub Register , final  List <  Reil Instruction > instructions ) throws  Illegal Argument Exception ,  Internal Translation Exception ,  Illegal Argument Exception {  Preconditions . check Not Null ( environment , _ STR ) ;  Preconditions . check Not Null ( value , _ STR ) ;  Preconditions . check Not Null ( sub Register , _ STR ) ;  Preconditions . check Not Null ( value Size , _ STR ) ;  Preconditions . check Not Null ( instructions , _ STR ) ; final  String parent Register = get Parent Register ( sub Register ) ; final  Operand Size register Size = get Register Size ( sub Register ) ; final  Operand Size parent Register Size = get Register Size ( parent Register ) ; final  Operand Size arch Size = environment . get Architecture Size ( ) ; if ( register Size . get Byte Size ( ) >= arch Size . get Byte Size ( ) ) { throw new  Internal Translation Exception ( _ STR ) ; } if ( value Size . get Byte Size ( ) >= arch Size . get Byte Size ( ) ) { throw new  Internal Translation Exception ( _ STR ) ; } if ( value Size . get Byte Size ( ) >= parent Register Size . get Byte Size ( ) ) { throw new  Internal Translation Exception ( _ STR ) ; } final  String mask =  String . value Of ( get Negative Mask ( sub Register ) ) ; if ( is Higher8 Bit Register ( sub Register ) ) { final  String shifted Value = environment . get Next Variable String ( ) ; final  String masked Value = environment . get Next Variable String ( ) ; instructions . add (  Reil Helpers . create Bsh ( offset , value Size , value , value Size , _ STR , arch Size , shifted Value ) ) ; instructions . add (  Reil Helpers . create And ( offset + _ NUM , arch Size , parent Register , arch Size , mask , arch Size , masked Value ) ) ; instructions . add (  Reil Helpers . create Or ( offset + _ NUM , arch Size , shifted Value , arch Size , masked Value , arch Size , parent Register ) ) ; } else { final  String masked Value = environment . get Next Variable String ( ) ; instructions . add (  Reil Helpers . create And ( offset , arch Size , parent Register , arch Size , mask , arch Size , masked Value ) ) ; instructions . add (  Reil Helpers . create Or ( offset + _ NUM , value Size , value , arch Size , masked Value , arch Size , parent Register ) ) ; } }
public void clear Interceptors ( ) { clear Request Interceptors ( ) ; clear Response Interceptors ( ) ; }
@  Override public  String to String ( ) { final  String Builder sb = new  String Builder ( ) ; sb . append ( _ STR ) ; sb . append ( get Request ID ( ) ) ; sb . append ( _ STR ) ; sb . append ( timestamp ) ; sb . append ( _ STR ) ; sb . append ( get Request ( ) ) ; sb . append ( _ STR ) ; return sb . to String ( ) ; }
@  Suppress Warnings ( _ STR ) public boolean can Run (  Class script Class ,  Groovy Class Loader loader ) { boolean is Test = _ BOOL ; try { try {  Class test Annotation Class = loader . load Class ( _ STR ) ;  Annotation annotation = script Class . get Annotation ( test Annotation Class ) ; if ( annotation != null ) { is Test = _ BOOL ; } else {  Method [ ] methods = script Class . get Methods ( ) ; for (  Method method : methods ) { annotation = method . get Annotation ( test Annotation Class ) ; if ( annotation != null ) { is Test = _ BOOL ; break ; } } } } catch (  Class Not Found Exception e ) { } } catch (  Throwable e ) { } return is Test ; }
static void clean Up (  IR ir ) { for (  Enumeration <  Instruction > e = ir . forward Instr Enumerator ( ) ; e . has More Elements ( ) ; ) {  Instruction s = e . next Element ( ) ; if ( s . operator ( ) ==  PI ) {  Register Operand result =  Guarded Unary . get Result ( s ) ;  Operator mv =  IRTools . get Move Op ( result . get Type ( ) ) ;  Operand val =  Guarded Unary . get Val ( s ) ;  Move . mutate ( s , mv , result , val ) ; } } ir . actual SSAOptions = null ; }
public void add (  Test test ) { tests . add ( test ) ; }
Mysql Savepoint (  Exception Interceptor exception Interceptor ) throws  SQLException { this ( get Unique Id ( ) , exception Interceptor ) ; }
private boolean check GMLFootprint (  String footprint ) { try {  Configuration configuration = new  GMLConfiguration ( ) ;  Parser parser = new  Parser ( configuration ) ; parser . parse ( new  Input Source ( new  String Reader ( footprint ) ) ) ; return _ BOOL ; } catch (  Exception e ) {  LOGGER . error ( _ STR + e . get Message ( ) ) ; return _ BOOL ; } }
public static double quantile ( double p , double k , double theta , double shift ) { return  Math . log (  Gamma Distribution . quantile ( p , k , theta ) ) + shift ; }
public  Text Editor Init ( final  Text Editor Configuration configuration , final  Event Bus general Event Bus , final  Code Assistant Factory code Assistant Factory , final  Quick Assist Assistant quick Assist , final  Text Editor Presenter <  T > text Editor ) { this . configuration = configuration ; this . general Event Bus = general Event Bus ; this . code Assistant Factory = code Assistant Factory ; this . quick Assist = quick Assist ; this . text Editor = text Editor ; }
final void put Double ( int offset , double value ) { unsafe . put Double ( offset + address , value ) ; }
public final void add Validation Errors (  Iterable <  String > errors ) { for (  String error : errors ) { validation Errors . add ( error ) ; } }
public static int option Length (  String option ) { if ( option . equals ( _ STR ) ) { return _ NUM ; } else { return _ NUM ; } }
public  Big Integer calculate Secret (  Big Integer client A ) throws  Crypto Exception { this .  A =  SRP6 Util . validate Public Value (  N , client A ) ; this . u =  SRP6 Util . calculate U ( digest ,  N ,  A ,  B ) ; this .  S = calculate S ( ) ; return  S ; }
public void reload (  Solr Core core ,  Solr Index Searcher searcher ) throws  IOException {  LOG . info ( _ STR + name + _ STR ) ; if ( dictionary == null && store Dir != null ) {  File lookup File = get Store File ( ) ; if ( lookup File . exists ( ) ) {  File Input Stream is = new  File Input Stream ( lookup File ) ; try { if ( lookup . load ( is ) ) { return ; } } finally {  IOUtils . close While Handling Exception ( is ) ; } } else {  LOG . info ( _ STR ) ; } } }
protected void cancel ( ) { clear Images ( ) ; if ( callbacks != null ) { for (  Guided Tour Life Cycle guided Tour Life Cycle : callbacks ) { guided Tour Life Cycle . end ( ) ; } } }
private void connect ( ) throws  IOException {  JMXService URL jmx Url = new  JMXService URL (  String . format (  FMTURL , host , host , port ) ) ;  Map <  String ,  Object > env = new  Hash Map <  String ,  Object > ( ) ; if ( username != null ) {  String [ ] creds = { username , password } ; env . put (  JMXConnector .  CREDENTIALS , creds ) ; } jmxc =  JMXConnector Factory . connect ( jmx Url , env ) ; mbean Server Conn = jmxc . get MBean Server Connection ( ) ; try {  Object Name name = new  Object Name (  SSOBJNAME ) ; ss Proxy =  JMX . new MBean Proxy ( mbean Server Conn , name ,  Storage Service MBean . class ) ; snitch Proxy =  JMX . new MBean Proxy ( mbean Server Conn , new  Object Name ( _ STR ) ,  Endpoint Snitch Info MBean . class ) ; internode Auth Proxy =  JMX . new MBean Proxy ( mbean Server Conn , new  Object Name (  Geo Internode Authenticator MBean .  MBEAN_ NAME ) ,  Geo Internode Authenticator MBean . class ) ; db Mgr Ops = new  Db Manager Ops ( mbean Server Conn ) ; } catch (  Malformed Object Name Exception e ) { throw new  Runtime Exception ( _ STR , e ) ; } }
protected  String convert Word (  String word ) { word = word . to Upper Case ( ) ; if ( ignore List . contains ( word ) ) { return null ; } return word ; }
public static  String to String (  Timestamp timestamp ) { if ( timestamp == null ) return null ; else return timestamp . to String ( ) ; }
public  State (  Plot Rendering Info info ) { super ( info ) ; }
public  Escape Tokenizer (  String source ) { this . source = source ; this . source Length = source . length ( ) ; this . pos = _ NUM ; }
@  Override public  String to String ( ) {  String Builder risul = new  String Builder ( _ NUM ) ; risul . append ( classname ) ; risul . append ( _ STR ) ; return risul . to String ( ) ; }
public void write ( byte [ ] vector ) { check ( vector . length ) ;  System . arraycopy ( vector , _ NUM , buffer , write_pos , vector . length ) ; write_pos += vector . length ; }
private void update Params For Auth (  String [ ] auth Names ,  List <  Pair > query Params ,  Map <  String ,  String > header Params ) { for (  String auth Name : auth Names ) {  Authentication auth = authentications . get ( auth Name ) ; if ( auth == null ) throw new  Runtime Exception ( _ STR + auth Name ) ; auth . apply To Params ( query Params , header Params ) ; } }
public static  Element create Element In Encryption11 Space (  Document doc ,  String element Name ) { if ( doc == null ) { throw new  Runtime Exception ( _ STR ) ; } if ( ( xenc11 Prefix == null ) || ( xenc11 Prefix . length ( ) == _ NUM ) ) { return doc . create Element NS (  Encryption Constants .  Encryption Spec11 NS , element Name ) ; } return doc . create Element NS (  Encryption Constants .  Encryption Spec11 NS , xenc11 Prefix + _ STR + element Name ) ; }
public boolean equals Default ( ) { return (  Float . float To Int Bits ( value ) == _ NUM ) ; }
public static  Collection <  File > list Files And Dirs (  File directory ,  IOFile Filter file Filter ,  IOFile Filter dir Filter ) { validate List Files Parameters ( directory , file Filter ) ;  IOFile Filter eff File Filter = set Up Effective File Filter ( file Filter ) ;  IOFile Filter eff Dir Filter = set Up Effective Dir Filter ( dir Filter ) ;  Collection <  File > files = new java . util .  Linked List <  File > ( ) ; if ( directory . is Directory ( ) ) { files . add ( directory ) ; } inner List Files ( files , directory ,  File Filter Utils . or ( eff File Filter , eff Dir Filter ) , _ BOOL ) ; return files ; }
public void add Tele Missile Attack (  Attack Action ea ) { pending Tele Missile Attacks . add Element ( ea ) ; process Game Event ( new  Game New Action Event ( this , ea ) ) ; }
public void clear Commands ( ) { synchronized ( commands ) { commands . clear ( ) ; } update Images ( ) ; }
public  String to String ( ) {  String Buffer sb = new  String Buffer ( ) ; char [ ] separator = { _ STR , _ STR } ; for ( int i = _ NUM ; i < components . length ; i ++ ) { sb . append ( separator ) ; sb . append ( components [ i ] ) ; separator [ _ NUM ] = _ STR ; } sb . append ( _ STR ) ; return sb . to String ( ) ; }
public void add First (  Statement Sequence statements ) { if ( statements != null ) { sequence . add All ( _ NUM , statements . sequence ) ; } }
private void remove ( int hash Code ) { synchronized ( m Records ) {  Iterator <  Record > iterator = m Records . iterator ( ) ; while ( iterator . has Next ( ) ) {  Record record = (  Record ) iterator . next ( ) ; if ( record . m Hash Code == hash Code ) { iterator . remove ( ) ; } } } }
public double elasticity Forward ( ) { final double val = value ( ) ; final double del = delta Forward ( ) ; if ( val >  Constants .  QL_ EPSILON ) return del / val * forward ; else if (  Math . abs ( del ) <  Constants .  QL_ EPSILON ) return _ NUM ; else if ( del > _ NUM ) return  Double .  MAX_ VALUE ; else return  Double .  MIN_ VALUE ; }
private byte [ ] entity To Bytes (  Http Entity entity ) throws  IOException ,  Server Error {  Pooling Byte Array Output Stream bytes = new  Pooling Byte Array Output Stream ( m Pool , ( int ) entity . get Content Length ( ) ) ; byte [ ] buffer = null ; try {  Input Stream in = entity . get Content ( ) ; if ( in == null ) { throw new  Server Error ( ) ; } buffer = m Pool . get Buf ( _ NUM ) ; int count ; while ( ( count = in . read ( buffer ) ) != - _ NUM ) { bytes . write ( buffer , _ NUM , count ) ; } return bytes . to Byte Array ( ) ; } finally { try { entity . consume Content ( ) ; } catch (  IOException e ) {  Volley Log . v ( _ STR ) ; } m Pool . return Buf ( buffer ) ; bytes . close ( ) ; } }
public static float round Float ( float value , int after Decimal Point ) { float mask = ( float )  Math . pow ( _ NUM , ( float ) after Decimal Point ) ; return ( float ) (  Math . round ( value * mask ) ) / mask ; }
@  Not Null public  Runner add Runner ( @  Not Null  Application Process Descriptor process Descriptor ) {  Run Options run Options = dto Factory . create Dto (  Run Options . class ) ;  Runner runner = models Factory . create Runner ( run Options ) ;  String environment Id = process Descriptor . get Environment Id ( ) ; if ( environment Id != null && environment Id . starts With (  PROJECT_ PREFIX ) ) { runner . set Scope (  PROJECT ) ; } runners Id . add ( process Descriptor . get Process Id ( ) ) ; runner . set Process Descriptor ( process Descriptor ) ; runner . set RAM ( process Descriptor . get Memory Size ( ) ) ; runner . set Status (  Runner .  Status .  DONE ) ; runner . reset Creation Time ( ) ; history . add Runner ( runner ) ; on Selection Changed (  RUNNER ) ; runner Timer . schedule (  ONE_ SEC . get Value ( ) ) ;  Launch Action launch Action = action Factory . create Launch ( ) ; runner Actions . put ( runner , launch Action ) ; launch Action . perform ( runner ) ; select History Tab ( ) ; return runner ; }
public static boolean is Windows Xp ( ) { return os Name . index Of ( _ STR ) > - _ NUM && os Version . equals ( _ STR ) ; }
private  String boolean To String (  Boolean input ) { if ( input == null ) { return null ; } else { return input . to String ( ) ; } }
private static int [ ] maximum Sizes (  Container container ,  List form Specs ,  List [ ] component Lists ,  Measure min Measure ,  Measure pref Measure ,  Measure default Measure ) {  Form Spec form Spec ; int size = form Specs . size ( ) ; int [ ] result = new int [ size ] ; for ( int i = _ NUM ; i < size ; i ++ ) { form Spec = (  Form Spec ) form Specs . get ( i ) ; result [ i ] = form Spec . maximum Size ( container , component Lists [ i ] , min Measure , pref Measure , default Measure ) ; } return result ; }
private static boolean check File Parent Exists ( final  String file ) {  String file Name =  Path Utils . remove Slash From End ( file ) ;  File dir = new  File ( file Name . substring ( _ NUM , file Name . last Index Of ( _ STR ) + _ NUM ) ) ; return dir . exists ( ) && dir . is Directory ( ) ; }
private boolean is Position On Line ( final float x , final float y , final float node1 X , final float node1 Y , final float node2 X , final float node2 Y ) { float tolerance =  Data Style . get Current ( ) . way Tolerance Value / _ NUM ; if (  Geo Math . is Between ( x , node1 X , node2 X , tolerance ) &&  Geo Math . is Between ( y , node1 Y , node2 Y , tolerance ) ) { return (  Geo Math . get Line Distance ( x , y , node1 X , node1 Y , node2 X , node2 Y ) < tolerance ) ; } return _ BOOL ; }
public  Log Message read Log Batch (  Log Message start Log ,  List <  Log Message > log Batch ) throws  IOException ,  Compressor Exception { long batch Time = start Log . get Time ( ) ; log Batch . add ( start Log ) ;  Log Message msg ; while ( ( msg = read Next Merged Log Message ( ) ) != null ) { if ( msg . get Time ( ) == batch Time ) { log Batch . add ( msg ) ; } else { return msg ; } } return null ; }
Database Cluster Unit (  Data Input Stream is ) throws  IOException { this . type = is . read Int ( ) ; this . phone = is . read Int ( ) ; this . start = is . read Int ( ) ; this . end = is . read Int ( ) ; this . prev = is . read Int ( ) ; this . next = is . read Int ( ) ; }
private  Number parse Int (  String value ) {  Long l =  Long . value Of ( value ) ; if ( l . int Value ( ) == l ) { return l . int Value ( ) ; } return l ; }
public void make Immutable ( ) { mutable = _ BOOL ; if ( authn Context Class Ref != null ) { authn Context Class Ref =  Collections . unmodifiable List ( authn Context Class Ref ) ; } if ( authn Context Decl Ref != null ) { authn Context Decl Ref =  Collections . unmodifiable List ( authn Context Decl Ref ) ; } return ; }
public static  File make Temp Dir ( ) throws  IOException {  File temp =  File . create Temp File ( _ STR , null ) ; if ( ! temp . delete ( ) ) return null ; if ( ! temp . mkdir ( ) ) return null ; return temp ; }
public  Selection Input Dialog (  Window owner ,  String key , boolean editable ,  Collection <  T > selection Values ,  T initial Selection Value ,  Input Validator <  T > input Validator ,  Object ... key Arguments ) { this ( owner , key , selection Values , initial Selection Value , input Validator , key Arguments ) ; combo Box . set Editable ( editable ) ; }
public void reload (  Solr Core core ,  Solr Index Searcher searcher ) throws  IOException {  LOG . info ( _ STR + name + _ STR ) ; if ( dictionary == null && store Dir != null ) {  File lookup File = get Store File ( ) ; if ( lookup File . exists ( ) ) {  File Input Stream is = new  File Input Stream ( lookup File ) ; try { if ( lookup . load ( is ) ) { return ; } } finally {  IOUtils . close While Handling Exception ( is ) ; } } else {  LOG . info ( _ STR ) ; } } }
public synchronized byte to Byte Array ( ) [ ] { return  Arrays . copy Of ( buf , count ) ; }
public void create Vm Async ( final  String project Id , final  Vm Create Spec vm Create Spec , final  Future Callback <  Task > response Callback ) throws  IOException { final  String path =  String . format ( _ STR , get Base Path ( ) , project Id ) ; create Object Async ( path , serialize Object As Json ( vm Create Spec ) , response Callback ) ; }
@  Override public boolean domain Match ( final  String host , final  String domain ) { final boolean match = host . equals ( domain ) || ( domain . starts With ( _ STR ) && host . ends With ( domain ) ) ; return match ; }
public synchronized void enable Attribute (  String name ) throws java . lang .  Illegal Argument Exception { if ( name == null ) { throw new java . lang .  Illegal Argument Exception ( _ STR ) ; } if ( ! enabled Attributes . contains ( name ) ) { enabled Attributes . add Element ( name ) ; } }
public void push ( final long value ) { if ( value == _ NUM || value == _ NUM ) { mv . visit Insn (  Opcodes .  LCONST_0 + ( int ) value ) ; } else { mv . visit Ldc Insn ( value ) ; } }
private  String real Key (  String key ) { return key . contains ( _ STR ) ? key . substring ( key . last Index Of ( _ STR ) + _ NUM , key . length ( ) ) : key ; }
private static void assert Change Events (  Collection <  Port Change Event > early Events ,  Collection <  Port Change Event > late Events ,  Collection <  Port Change Event > anytime Events ,  Collection <  Port Change Event > actual Events ) {  String input Desc =  String . format ( _ STR + _ STR , early Events . to String ( ) , late Events . to String ( ) , anytime Events . to String ( ) , actual Events . to String ( ) ) ;  Collection <  Port Change Event > early = new  Array List <  Port Change Event > ( early Events ) ;  Collection <  Port Change Event > late = new  Array List <  Port Change Event > ( late Events ) ;  Collection <  Port Change Event > any = new  Array List <  Port Change Event > ( anytime Events ) ; for (  Port Change Event ev : early ) { assert False ( _ STR , late . contains ( ev ) ) ; assert False ( _ STR , any . contains ( ev ) ) ; } for (  Port Change Event ev : late ) { assert False ( _ STR , early . contains ( ev ) ) ; assert False ( _ STR , any . contains ( ev ) ) ; } for (  Port Change Event ev : any ) { assert False ( _ STR , early . contains ( ev ) ) ; assert False ( _ STR , late . contains ( ev ) ) ; } for (  Port Change Event a : actual Events ) { if ( early . remove ( a ) ) { continue ; } if ( any . remove ( a ) ) { continue ; } if ( late . remove ( a ) ) { if ( ! early . is Empty ( ) ) { fail ( a + _ STR + _ STR + input Desc ) ; } else { continue ; } } fail ( a + _ STR + input Desc ) ; } if ( ! early . is Empty ( ) ) fail ( _ STR + early + _ STR + input Desc ) ; if ( ! late . is Empty ( ) ) fail ( _ STR + late + _ STR + input Desc ) ; if ( ! any . is Empty ( ) ) fail ( _ STR + any + _ STR + input Desc ) ; }
public void write (  String s ) { for ( int i = _ NUM ; i < s . length ( ) ; i ++ ) write ( s . char At ( i ) ) ; }
private void toggle Components (  Container container ) { }
public static  String to String (  Byte Buffer bb ) { return bb == null ? null : to String ( bb . array ( ) , bb . array Offset ( ) + bb . position ( ) , bb . remaining ( ) ) ; }
public  Array Field Vector (  T [ ] v1 ,  Field Vector <  T > v2 ) throws  Null Argument Exception {  Math Utils . check Not Null ( v1 ) ;  Math Utils . check Not Null ( v2 ) ; field = v2 . get Field ( ) ; final  T [ ] v2 Data = ( v2 instanceof  Array Field Vector ) ? ( (  Array Field Vector <  T > ) v2 ) . data : v2 . to Array ( ) ; data =  Math Arrays . build Array ( field , v1 . length + v2 Data . length ) ;  System . arraycopy ( v1 , _ NUM , data , _ NUM , v1 . length ) ;  System . arraycopy ( v2 Data , _ NUM , data , v1 . length , v2 Data . length ) ; }
public void stop ( ) { if ( s Logger . is Activated ( ) ) { s Logger . info ( _ STR ) ; } m Check Handler . remove Messages (  CHECK_ MESSAGE ) ; if ( m Observer Is Registered ) { m Contacts Contract Cursor . unregister Content Observer ( m Contacts Contract Observer ) ; m Observer Is Registered = _ BOOL ; m Contacts Contract Cursor . close ( ) ; } m Cleanup Executor . shutdown Now ( ) ; }
protected final void fire Vetoable Change (  String property Name , float old Value , float new Value ) throws  Property Veto Exception { fire Vetoable Change ( property Name ,  Float . value Of ( old Value ) ,  Float . value Of ( new Value ) ) ; }
public void test LMJelinek Mercer ( ) throws  IOException { float p = ( _ NUM - _ NUM ) *  FREQ /  DOC_ LEN + _ NUM * (  TOTAL_ TERM_ FREQ + _ NUM ) / (  NUMBER_ OF_ FIELD_ TOKENS + _ NUM ) ; float gold = ( float ) (  Math . log ( p / ( _ NUM * (  TOTAL_ TERM_ FREQ + _ NUM ) / (  NUMBER_ OF_ FIELD_ TOKENS + _ NUM ) ) ) ) ; correctness Test Core ( new  LMJelinek Mercer Similarity ( _ NUM ) , gold ) ; }
public int heat Sinks ( ) { return heat Sinks ( _ BOOL ) ; }
public boolean has Provider (  Class < ? > dto Interface ) { return dto Interface2 Providers . get ( dto Interface ) != null ; }
@  Override public void write External Index Drop Stmt (  Table table ,  IIndex index ,  String Builder ddl ) { ddl . append ( _ STR ) ; print Identifier ( get Index Name ( index ) , ddl ) ; print End Of Statement ( ddl ) ; }
public void obtain ( ) throws  IOException { if ( file Lock != null && file Lock . is Valid ( ) ) { return ; } file Lock = file To Lock . lock ( ) ; }
@  Override public boolean equals ( final  Object o ) { if ( this == o ) return _ BOOL ; if ( ! ( o instanceof  Header ) ) { return _ BOOL ; } return name . equals ( ( (  Header ) o ) . name ) ; }
public static boolean open Editors ( @  Not Null  Project project , @  Not Null  Collection <  File > files , boolean select ) { if ( files . size ( ) > _ NUM ) { boolean result = _ BOOL ;  Virtual File last = null ; for (  File file : files ) { if ( file . exists ( ) ) {  Virtual File v File =  Vfs Util . find File By Io File ( file , _ BOOL ) ; if ( v File != null ) { result &= open Editor ( project , v File ) ; last = v File ; } else { result = _ BOOL ; } } } if ( select && last != null ) { select Editor ( project , last ) ; } return result ; } return _ BOOL ; }
private void update Tick Visibility ( ) { tick Visibilities . clear ( ) ; for ( int i = _ NUM ; i < tick Label Positions . size ( ) ; i ++ ) { tick Visibilities . add (  Boolean .  TRUE ) ; } if ( tick Label Positions . size ( ) == _ NUM ) { return ; } int previous Position = _ NUM ;  String previous Label = null ; for ( int i = _ NUM ; i < tick Label Positions . size ( ) ; i ++ ) { boolean has Space To Draw = _ BOOL ; if ( i != _ NUM ) { has Space To Draw = has Space To Draw ( previous Position , tick Label Positions . get ( i ) , previous Label , tick Labels . get ( i ) ) ; }  String current Label = tick Labels . get ( i ) ; boolean is Repeat Same Tick And Not End = current Label . equals ( previous Label ) && ( i != _ NUM && i != tick Label Positions . size ( ) - _ NUM ) ; boolean is Major Tick Or End = _ BOOL ; if ( scale . is Log Scale Enabled ( ) ) { is Major Tick Or End = is Major Tick ( tick Label Values . get ( i ) ) || i == _ NUM || i == tick Label Positions . size ( ) - _ NUM ; } if ( ! has Space To Draw || is Repeat Same Tick And Not End || ! is Major Tick Or End ) { tick Visibilities . set ( i ,  Boolean .  FALSE ) ; } else { previous Position = tick Label Positions . get ( i ) ; previous Label = current Label ; } } }
public  String next Token ( ) { current Position = ( new Position >= _ NUM && ! delims Changed ) ? new Position : skip Delimiters ( current Position ) ; delims Changed = _ BOOL ; new Position = - _ NUM ; if ( current Position >= max Position ) throw new  No Such Element Exception ( ) ; int start = current Position ; current Position = scan Token ( current Position ) ; return str . substring ( start , current Position ) ; }
public static  Native Distinct Filter new Instance ( final  SPOKey Order index Key Order ) { return new  Native Distinct Filter (  BOp .  NOARGS ,  Collections . singleton Map (  Annotations .  KEY_ ORDER , (  Object ) index Key Order ) ) ; }
public boolean has Badge ( @  Id Res final int item Id ) { return map . contains ( item Id ) ; }
public  Options put (  String option ,  Boolean value ) { if ( value == null ) { return remove ( option ) ; } options . put ( option ,  Boolean . to String ( value ) ) ; return this ; }
@  Override public  Page Format default Page (  Page Format page ) {  Page Format new Page = (  Page Format ) page . clone ( ) ; get Default Page ( new Page ) ; return new Page ; }
protected  String form (  Double Matrix1 D matrix , int index ,  Former formatter ) { return formatter . form ( matrix . get ( index ) ) ; }
public void enable (  Bluetooth Adapter adapter ) { int mask = (  Bluetooth Receiver .  STATE_ TURNING_ ON_ FLAG |  Bluetooth Receiver .  STATE_ ON_ FLAG |  Bluetooth Receiver .  SCAN_ MODE_ CONNECTABLE_ FLAG ) ; long start = - _ NUM ;  Bluetooth Receiver receiver = get Bluetooth Receiver ( mask ) ; int state = adapter . get State ( ) ; switch ( state ) { case  Bluetooth Adapter .  STATE_ ON : assert True ( adapter . is Enabled ( ) ) ; remove Receiver ( receiver ) ; return ; case  Bluetooth Adapter .  STATE_ TURNING_ ON : assert False ( adapter . is Enabled ( ) ) ; mask = _ NUM ; break ; case  Bluetooth Adapter .  STATE_ OFF : assert False ( adapter . is Enabled ( ) ) ; start =  System . current Time Millis ( ) ; assert True ( adapter . enable ( ) ) ; break ; case  Bluetooth Adapter .  STATE_ TURNING_ OFF : start =  System . current Time Millis ( ) ; assert True ( adapter . enable ( ) ) ; break ; default : remove Receiver ( receiver ) ; fail (  String . format ( _ STR , state ) ) ; } long s =  System . current Time Millis ( ) ; while (  System . current Time Millis ( ) - s <  ENABLE_ DISABLE_ TIMEOUT ) { state = adapter . get State ( ) ; if ( state ==  Bluetooth Adapter .  STATE_ ON && ( receiver . get Fired Flags ( ) & mask ) == mask ) { assert True ( adapter . is Enabled ( ) ) ; long finish = receiver . get Completed Time ( ) ; if ( start != - _ NUM && finish != - _ NUM ) { write Output (  String . format ( _ STR , ( finish - start ) ) ) ; } else { write Output ( _ STR ) ; } remove Receiver ( receiver ) ; return ; } sleep (  POLL_ TIME ) ; } int fired Flags = receiver . get Fired Flags ( ) ; remove Receiver ( receiver ) ; fail (  String . format ( _ STR , state ,  Bluetooth Adapter .  STATE_ ON , fired Flags , mask ) ) ; }
public static  String join ( int [ ] self ,  String separator ) {  String Builder buffer = new  String Builder ( ) ; boolean first = _ BOOL ; if ( separator == null ) separator = _ STR ; for ( int next : self ) { if ( first ) { first = _ BOOL ; } else { buffer . append ( separator ) ; } buffer . append ( next ) ; } return buffer . to String ( ) ; }
public void force ( boolean metadata ) { mapped Buffer . force ( ) ; super . force ( metadata ) ; }
public boolean starts With (  String str ) { if ( str == null ) { return _ BOOL ; } int len = str . length ( ) ; if ( len == _ NUM ) { return _ BOOL ; } if ( len > size ) { return _ BOOL ; } for ( int i = _ NUM ; i < len ; i ++ ) { if ( buffer [ i ] != str . char At ( i ) ) { return _ BOOL ; } } return _ BOOL ; }
private static void add Entries For Infrequent Blocks (  IR ir ,  Live Analysis live ,  Hash Map <  Basic Block Pair ,  Hash Set <  Register > > result ) { for (  Enumeration <  Basic Block > e = ir . get Basic Blocks ( ) ; e . has More Elements ( ) ; ) {  Basic Block bb = e . next Element ( ) ; boolean bb Infrequent = bb . get Infrequent ( ) ; for (  Enumeration <  Basic Block > out = bb . get Normal Out ( ) ; out . has More Elements ( ) ; ) {  Basic Block dest = out . next Element ( ) ; boolean dest Infrequent = dest . get Infrequent ( ) ; if ( bb Infrequent ^ dest Infrequent ) {  Hash Set <  Register > live Registers = live . get Live Registers On Edge ( bb , dest ) ; for (  Register r : live Registers ) { if ( r . is Symbolic ( ) ) {  Hash Set <  Register > s = find Or Create Split Set ( result , bb , dest ) ; s . add ( r ) ; } } } } } }
public void test Split And Join Multiple Properties On Semicolon ( ) {  Properties inner =  Property Utils . split Properties On Delimiter (  ONE_ SEMI_ TWO , _ STR ) ; assert Equals ( _ STR , inner . get Property ( _ STR ) ) ; assert Equals ( _ STR , inner . get Property ( _ STR ) ) ; assert Equals ( _ NUM , inner . size ( ) ) ; try { assert Equals (  ONE_ SEMI_ TWO ,  Property Utils . join On Semicolon (  Property Utils . to Map ( inner ) ) ) ; } catch (  Comparison Failure e ) { assert Equals (  TWO_ SEMI_ ONE ,  Property Utils . join On Semicolon (  Property Utils . to Map ( inner ) ) ) ; } }
public static void insert Object At Offset (  Object [ ] source Array ,  Object [ ] destination Array , int offset ,  Object o ) { if ( offset == _ NUM ) { destination Array [ _ NUM ] = o ;  System . arraycopy ( source Array , _ NUM , destination Array , _ NUM , source Array . length ) ; } else { if ( offset == source Array . length ) {  System . arraycopy ( source Array , _ NUM , destination Array , _ NUM , source Array . length ) ; destination Array [ source Array . length ] = o ; } else {  System . arraycopy ( source Array , _ NUM , destination Array , _ NUM , offset ) ; destination Array [ offset ] = o ;  System . arraycopy ( source Array , offset , destination Array , offset + _ NUM , source Array . length - offset ) ; } } }
private void create From Assets (  String db Name ,  File dbfile ,  Input Stream asset File Input Stream ) {  Output Stream out = null ; try {  Log . v ( _ STR , _ STR ) ;  String db Path = dbfile . get Absolute Path ( ) ; db Path = db Path . substring ( _ NUM , db Path . last Index Of ( _ STR ) + _ NUM ) ;  File db Path File = new  File ( db Path ) ; if ( ! db Path File . exists ( ) ) db Path File . mkdirs ( ) ;  File new Db File = new  File ( db Path + db Name ) ; out = new  File Output Stream ( new Db File ) ; byte [ ] buf = new byte [ _ NUM ] ; int len ; while ( ( len = asset File Input Stream . read ( buf ) ) > _ NUM ) out . write ( buf , _ NUM , len ) ;  Log . v ( _ STR , _ STR + new Db File . get Absolute Path ( ) ) ; } catch (  IOException e ) {  Log . v ( _ STR , _ STR + e . get Message ( ) ) ; } finally { if ( out != null ) { try { out . close ( ) ; } catch (  IOException ignored ) { } } } }
public  Input Stream stream ( ) throws  Http Request Exception {  Input Stream stream ; if ( code ( ) <  HTTP_ BAD_ REQUEST ) try { stream = connection . get Input Stream ( ) ; } catch (  IOException e ) { throw new  Http Request Exception ( e ) ; } else { stream = connection . get Error Stream ( ) ; if ( stream == null ) try { stream = connection . get Input Stream ( ) ; } catch (  IOException e ) { throw new  Http Request Exception ( e ) ; } } if ( ! uncompress || !  ENCODING_ GZIP . equals ( content Encoding ( ) ) ) return stream ; else try { return new  GZIPInput Stream ( stream ) ; } catch (  IOException e ) { throw new  Http Request Exception ( e ) ; } }
public  Local File (  File file ) { this . file = file ; this . file Path = file . get Absolute Path ( ) ; }
public static boolean is Empty Or Whitespace (  String s ) { s = make Safe ( s ) ; for ( int i = _ NUM , n = s . length ( ) ; i < n ; i ++ ) { if ( !  Character . is Whitespace ( s . char At ( i ) ) ) { return _ BOOL ; } } return _ BOOL ; }
public short read Short ( ) throws  IOException { return dis . read Short ( ) ; }
public void print ( ) { print (  System . out ) ; }
public static void copy To Clipboard ( final  Zy Graph Node < ? > node ) {  Preconditions . check Not Null ( node , _ STR ) ; final  IZy Node Realizer realizer = node . get Realizer ( ) ; final  Zy Label Content content = realizer . get Node Content ( ) ; if ( content . is Selectable ( ) ) { final  Zy Label Content zy Content = content ; final  String Builder text Builder = new  String Builder ( ) ; for ( final  Zy Line Content zy Line Content : zy Content ) { text Builder . append ( zy Line Content . get Text ( ) ) ; text Builder . append ( _ STR ) ; }  Clipboard Helpers . copy To Clipboard ( text Builder . to String ( ) ) ; } }
private boolean check Zoning Required (  String token ,  URI varray URI ) { if ( ! is Zoning Required ( varray URI ) ) {  Workflow Step Completer . step Succeded ( token ) ; return _ BOOL ; } else {  Workflow Step Completer . step Executing ( token ) ; return _ BOOL ; } }
public void add Frame (  CCSprite Frame frame ) { frames_ . add ( frame ) ; }
private void update Selection ( ) {  Tree Path selection Path = tree . get Selection Path ( ) ; if ( selection Path != null ) {  Entry selected Entry = (  Entry ) selection Path . get Last Path Component ( ) ; if ( ! ( selected Entry instanceof  Folder ) ) { tree . set Selection Path ( selection Path . get Parent Path ( ) ) ; } } }
public  Messages (  String name ) { this ( (  Messages ) null , name ) ; }
public int swap ( ) { if ( ! m Egl . egl Swap Buffers ( m Egl Display , m Egl Surface ) ) { return m Egl . egl Get Error ( ) ; } return  EGL10 .  EGL_ SUCCESS ; }
public static  List <  Window > windows (  Input Stream words , int window Size ) {  Tokenizer tokenizer = new  Default Stream Tokenizer ( words ) ;  List <  String > list = new  Array List < > ( ) ; while ( tokenizer . has More Tokens ( ) ) list . add ( tokenizer . next Token ( ) ) ; return windows ( list , window Size ) ; }
protected void draw Center Text (  Canvas c ) {  String center Text = m Chart . get Center Text ( ) ; if ( m Chart . is Draw Center Text Enabled ( ) && center Text != null ) {  Point F center = m Chart . get Center Circle Box ( ) ;  String [ ] lines = center Text . split ( _ STR ) ; float maxlineheight = _ NUM ; for (  String line : lines ) { float cur Height =  Utils . calc Text Height ( m Center Text Paint , line ) ; if ( cur Height > maxlineheight ) maxlineheight = cur Height ; } float linespacing = maxlineheight * _ NUM ; float totalheight = maxlineheight * lines . length - linespacing * ( lines . length - _ NUM ) ; int cnt = lines . length ; float y = center . y ; for ( int i = _ NUM ; i < lines . length ; i ++ ) {  String line = lines [ lines . length - i - _ NUM ] ; c . draw Text ( line , center . x , y + maxlineheight * cnt - totalheight / _ NUM , m Center Text Paint ) ; cnt -- ; y -= linespacing ; } } }
public  List <  Frame Descriptor > diff (  Frame Path to ) {  List <  Frame Descriptor > to Frames = to . get Frames ( ) ;  List <  Frame Descriptor > diff = new  Array List < > ( ) ; if ( is Subpath ( to ) ) { for ( int i = frames . size ( ) ; i < to Frames . size ( ) ; i ++ ) { diff . add ( to Frames . get ( i ) ) ; } } else { diff . add (  Default Frame .  INSTANCE ) ; diff . add All ( to Frames ) ; } return diff ; }
private static  Object add ( final  Object array , final int index , final  Object element , final  Class < ? > clss ) { if ( array == null ) { if ( index != _ NUM ) { throw new  Index Out Of Bounds Exception ( _ STR + index + _ STR ) ; } final  Object joined Array =  Array . new Instance ( clss , _ NUM ) ;  Array . set ( joined Array , _ NUM , element ) ; return joined Array ; } final int length =  Array . get Length ( array ) ; if ( index > length || index < _ NUM ) { throw new  Index Out Of Bounds Exception ( _ STR + index + _ STR + length ) ; } final  Object result =  Array . new Instance ( clss , length + _ NUM ) ;  System . arraycopy ( array , _ NUM , result , _ NUM , index ) ;  Array . set ( result , index , element ) ; if ( index < length ) {  System . arraycopy ( array , index , result , index + _ NUM , length - index ) ; } return result ; }
private static  String fmt ( double double Value ) { if ( double Value == ( long ) double Value ) { return  String . format ( _ STR , ( long ) double Value ) ; } else { return  String . format ( _ STR , double Value ) ; } }
public  String to Matlab ( ) {  String Buffer result ; int i ; int n ; result = new  String Buffer ( ) ; result . append ( _ STR ) ; for ( i = _ NUM ; i < m_size ; i ++ ) { if ( i > _ NUM ) { result . append ( _ STR ) ; } for ( n = _ NUM ; n < m_size ; n ++ ) { if ( n > _ NUM ) { result . append ( _ STR ) ; } result . append ( get Cell ( i , n ) ) ; } } result . append ( _ STR ) ; return result . to String ( ) ; }
public  File Input Reader (  String f ) throws  IOException { if (  Debug . debugging ( _ STR ) ) {  Debug . output ( _ STR + f ) ; }  File file = new  File ( f ) ; name = file . get Name ( ) ; absolute Path = file . get Absolute Path ( ) ; input File = init ( file ) ; }
public static  Buffered Output Stream new Output Stream (  Path self ) throws  IOException { return new  Buffered Output Stream (  Files . new Output Stream ( self ) ) ; }
public synchronized  Set <  K > key Set ( ) {  Hash Set <  K > set = new  Hash Set <  K > ( ) ; for (  Segment <  K ,  V > s : segments ) { set . add All ( s . key Set ( ) ) ; } return set ; }
public  Builder certificate Info (  Certificate Info certificate Info ) { this . certificate Info = certificate Info ; return this ; }
public static void add Security Policy (  Security Policy policy ) { policies . put ( policy . policy Uri , policy ) ; }
public boolean code Matches (  String query Code ) { if ( code Position != null && code != null ) { int start Index = code Position . start Index ; int length = code . index Of ( _ STR ) ; if ( length == - _ NUM ) { length = code . length ( ) ; } if (  Debug . debugging ( _ STR ) ) {  Debug . output ( _ STR + query Code + _ STR + code + _ STR + start Index + _ STR + length ) ; } return query Code . region Matches ( _ BOOL , start Index , code , _ NUM , length ) ; } return _ BOOL ; }
List <  INavi Module > initialize Raw Modules ( final  List <  INavi Module > modules , final  List <  INavi Raw Module > raw Modules ) { final  List <  INavi Module > new Modules = new  Array List <  INavi Module > ( ) ; for ( final  INavi Raw Module raw Module : raw Modules ) { if ( ! has Module ( modules , raw Module ) ) { try { new Modules . add ( create Module ( raw Module ) ) ; } catch (  Couldnt Load Data Exception |  Couldnt Save Data Exception e ) {  CUtility Functions . log Exception ( e ) ; } } } return new Modules ; }
private  List <  String > default Args ( ) {  List <  String > args = new  Array List <  String > ( ) ; args . add ( _ STR ) ; args . add ( _ STR ) ; args . add ( _ STR ) ; return args ; }
@  Override public  Japanese Date date ( int proleptic Year , int month , int day Of Month ) { return new  Japanese Date (  Local Date . of ( proleptic Year , month , day Of Month ) ) ; }
private  Pair <  Key , char [ ] > recover Key (  String alias , char [ ] store Pass , char [ ] key Pass ) throws  Exception {  Key key = null ; if ( key Store . contains Alias ( alias ) == _ BOOL ) {  Message Format form = new  Message Format ( rb . get String ( _ STR ) ) ;  Object [ ] source = { alias } ; throw new  Exception ( form . format ( source ) ) ; } if ( ! key Store . entry Instance Of ( alias ,  Key Store .  Private Key Entry . class ) && ! key Store . entry Instance Of ( alias ,  Key Store .  Secret Key Entry . class ) ) {  Message Format form = new  Message Format ( rb . get String ( _ STR ) ) ;  Object [ ] source = { alias } ; throw new  Exception ( form . format ( source ) ) ; } if ( key Pass == null ) { try { key = key Store . get Key ( alias , store Pass ) ; key Pass = store Pass ; passwords . add ( key Pass ) ; } catch (  Unrecoverable Key Exception e ) { if ( ! token ) { key Pass = get Key Passwd ( alias , null , null ) ; key = key Store . get Key ( alias , key Pass ) ; } else { throw e ; } } } else { key = key Store . get Key ( alias , key Pass ) ; } return  Pair . of ( key , key Pass ) ; }
protected final  Configuration Loader build Configuration Loader ( ) {  Dimension Loader dimension Loader = get Dimension Loader ( ) ;  Table Loader table Loader = get Table Loader ( ) ;  Metric Loader metric Loader = get Metric Loader ( ) ; return build Configuration Loader ( dimension Loader , metric Loader , table Loader ) ; }
public  Simple Message Listener Adapter (  Simple Message Listener listener ) { this (  Collections . singleton ( listener ) ,  DEFAULT_ DATA_ DEFERRED_ SIZE ) ; }
public static <  T >  T [ ] concat ( @  Nullable  T [ ] arr ,  T ... obj ) {  T [ ] new Arr ; if ( arr == null || arr . length == _ NUM ) new Arr = obj ; else { new Arr =  Arrays . copy Of ( arr , arr . length + obj . length ) ;  System . arraycopy ( obj , _ NUM , new Arr , arr . length , obj . length ) ; } return new Arr ; }
public void pedestal Camera ( float size ) { move To Position ( - ( float ) ( target Xoff + ( size *  Math . sin (  Math . to Radians ( zrot ) ) ) ) , - ( float ) ( target Yoff + ( size *  Math . cos (  Math . to Radians ( zrot ) ) ) ) ) ; }
public static byte [ ] decode2 Bytes (  String encoded ) { if ( encoded == null ) { return null ; } char [ ] base64 Data = encoded . to Char Array ( ) ; int len = remove White Space ( base64 Data ) ; if ( len %  FOURBYTE != _ NUM ) { return null ; } int number Quadruple = ( len /  FOURBYTE ) ; if ( number Quadruple == _ NUM ) { return new byte [ _ NUM ] ; } byte decoded Data [ ] = null ; byte b1 = _ NUM , b2 = _ NUM , b3 = _ NUM , b4 = _ NUM ; char d1 = _ NUM , d2 = _ NUM , d3 = _ NUM , d4 = _ NUM ; int i = _ NUM ; int encoded Index = _ NUM ; int data Index = _ NUM ; decoded Data = new byte [ ( number Quadruple ) * _ NUM ] ; for ( ; i < number Quadruple - _ NUM ; i ++ ) { if ( ! is Data ( ( d1 = base64 Data [ data Index ++ ] ) ) || ! is Data ( ( d2 = base64 Data [ data Index ++ ] ) ) || ! is Data ( ( d3 = base64 Data [ data Index ++ ] ) ) || ! is Data ( ( d4 = base64 Data [ data Index ++ ] ) ) ) { return null ; } b1 = base64 Alphabet [ d1 ] ; b2 = base64 Alphabet [ d2 ] ; b3 = base64 Alphabet [ d3 ] ; b4 = base64 Alphabet [ d4 ] ; decoded Data [ encoded Index ++ ] = ( byte ) ( b1 << _ NUM | b2 > > _ NUM ) ; decoded Data [ encoded Index ++ ] = ( byte ) ( ( ( b2 & _ NUM ) << _ NUM ) | ( ( b3 > > _ NUM ) & _ NUM ) ) ; decoded Data [ encoded Index ++ ] = ( byte ) ( b3 << _ NUM | b4 ) ; } if ( ! is Data ( ( d1 = base64 Data [ data Index ++ ] ) ) || ! is Data ( ( d2 = base64 Data [ data Index ++ ] ) ) ) { return null ; } b1 = base64 Alphabet [ d1 ] ; b2 = base64 Alphabet [ d2 ] ; d3 = base64 Data [ data Index ++ ] ; d4 = base64 Data [ data Index ++ ] ; if ( ! is Data ( ( d3 ) ) || ! is Data ( ( d4 ) ) ) { if ( is Pad ( d3 ) && is Pad ( d4 ) ) { if ( ( b2 & _ NUM ) != _ NUM ) { return null ; } byte [ ] tmp = new byte [ i * _ NUM + _ NUM ] ;  System . arraycopy ( decoded Data , _ NUM , tmp , _ NUM , i * _ NUM ) ; tmp [ encoded Index ] = ( byte ) ( b1 << _ NUM | b2 > > _ NUM ) ; return tmp ; } else if ( ! is Pad ( d3 ) && is Pad ( d4 ) ) { b3 = base64 Alphabet [ d3 ] ; if ( ( b3 & _ NUM ) != _ NUM ) { return null ; } byte [ ] tmp = new byte [ i * _ NUM + _ NUM ] ;  System . arraycopy ( decoded Data , _ NUM , tmp , _ NUM , i * _ NUM ) ; tmp [ encoded Index ++ ] = ( byte ) ( b1 << _ NUM | b2 > > _ NUM ) ; tmp [ encoded Index ] = ( byte ) ( ( ( b2 & _ NUM ) << _ NUM ) | ( ( b3 > > _ NUM ) & _ NUM ) ) ; return tmp ; } else { return null ; } } else { b3 = base64 Alphabet [ d3 ] ; b4 = base64 Alphabet [ d4 ] ; decoded Data [ encoded Index ++ ] = ( byte ) ( b1 << _ NUM | b2 > > _ NUM ) ; decoded Data [ encoded Index ++ ] = ( byte ) ( ( ( b2 & _ NUM ) << _ NUM ) | ( ( b3 > > _ NUM ) & _ NUM ) ) ; decoded Data [ encoded Index ++ ] = ( byte ) ( b3 << _ NUM | b4 ) ; } return decoded Data ; }
@  Override public void shutdown Now ( ) { if ( ! is Open ( ) ) return ; open = _ BOOL ; if ( log . is Info Enabled ( ) ) log . info ( _ STR ) ; final long begin =  System . current Time Millis ( ) ; tx Write Service . shutdown Now ( ) ; read Service . shutdown Now ( ) ; write Service . shutdown Now ( ) ; if ( sample Service != null ) sample Service . shutdown Now ( ) ; final long elapsed =  System . current Time Millis ( ) - begin ; if ( log . is Info Enabled ( ) ) log . info ( _ STR + elapsed + _ STR ) ; }
public static int deflate ( byte [ ] previous , int previous Length , byte [ ] current , int current Length , byte [ ] result ) { if ( previous == null ) {  System . arraycopy ( current , _ NUM , result , _ NUM , current Length ) ; return current Length ; } int length = _ NUM ; int start1 = _ NUM ; int start2 = _ NUM ; while ( start1 < previous Length && start2 < current Length ) { int end1 = start1 ; int end2 = start2 ; while ( end1 <= previous Length && end2 <= current Length ) { byte c1 = ( end1 < previous Length ? previous [ end1 ] : ( byte ) _ STR ) ; byte c2 = ( end2 < current Length ? current [ end2 ] : ( byte ) _ STR ) ; if ( c1 == c2 ) { if ( c1 == _ STR ) { result [ length ++ ] = _ STR ; break ; } else { end1 ++ ; end2 ++ ; } } else { while ( end1 < previous Length && previous [ end1 ] != _ STR ) { end1 ++ ; } while ( end2 < current Length && current [ end2 ] != _ STR ) { end2 ++ ; } for ( int i = start2 ; i < end2 ; i ++ ) result [ length ++ ] = current [ i ] ; break ; } } start1 = end1 + _ NUM ; start2 = end2 + _ NUM ; if ( start2 < current Length ) result [ length ++ ] = _ STR ; } return length ; }
public <  S extends  T >  Iterable <  S > save (  Iterable <  S > entities ) {  List <  S > saved = new  Array List <  S > ( ) ; for (  S entity : entities ) { saved . add ( save ( entity ) ) ; } return saved ; }
public static synchronized void remove Property Change Listener (  Property Change Listener l ) { if ( listeners . contains ( l ) ) { listeners . remove ( l ) ; } }
public static boolean is Directory (  String path ) {  File f = new  File ( path ) ; return f . is Directory ( ) ; }
public void commit If Prepared (  Ignite Internal Tx tx ,  Set <  UUID > failed Node Ids ) { assert tx instanceof  Grid Dht Tx Local || tx instanceof  Grid Dht Tx Remote : tx ; assert !  F . is Empty ( tx . transaction Nodes ( ) ) : tx ; assert tx . near Xid Version ( ) != null : tx ;  Grid Cache Tx Recovery Future fut = new  Grid Cache Tx Recovery Future ( cctx , tx , failed Node Ids , tx . transaction Nodes ( ) ) ; cctx . mvcc ( ) . add Future ( fut , fut . future Id ( ) ) ; if ( log . is Debug Enabled ( ) ) log . debug ( _ STR + tx + _ STR + fut + _ STR ) ; fut . prepare ( ) ; }
public static  Artifact Coordinates from String (  String string ) { final  Matcher matcher =  VALID_ PATTERN . matcher ( string ) ; if ( matcher . matches ( ) ) { if ( matcher . group ( _ NUM ) != null ) { return new  Artifact Coordinates ( matcher . group ( _ NUM ) , matcher . group ( _ NUM ) , matcher . group ( _ NUM ) , matcher . group ( _ NUM ) ) ; } else { return new  Artifact Coordinates ( matcher . group ( _ NUM ) , matcher . group ( _ NUM ) , matcher . group ( _ NUM ) ) ; } } else { throw new  Illegal Argument Exception ( string ) ; } }
public @  Override void characters ( char [ ] ch , int start , int length ) throws  SAXException { m String Builder . append ( ch , start , length ) ; }
private void tred2 ( ) { for ( int j = _ NUM ; j < n ; j ++ ) d [ j ] =  V . get ( n - _ NUM , j ) ; for ( int i = n - _ NUM ; i > _ NUM ; i -- ) { double scale = _ NUM ; double h = _ NUM ; for ( int k = _ NUM ; k < i ; k ++ ) { scale = scale + abs ( d [ k ] ) ; } if ( scale == _ NUM ) { e [ i ] = d [ i - _ NUM ] ; for ( int j = _ NUM ; j < i ; j ++ ) { d [ j ] =  V . get ( i - _ NUM , j ) ;  V . set ( i , j , _ NUM ) ;  V . set ( j , i , _ NUM ) ; } } else { for ( int k = _ NUM ; k < i ; k ++ ) { d [ k ] /= scale ; h += d [ k ] * d [ k ] ; } double f = d [ i - _ NUM ] ; double g = sqrt ( h ) ; if ( f > _ NUM ) g = - g ; e [ i ] = scale * g ; h -= f * g ; d [ i - _ NUM ] = f - g ;  Arrays . fill ( e , _ NUM , i , _ NUM ) ; for ( int j = _ NUM ; j < i ; j ++ ) { f = d [ j ] ;  V . set ( j , i , f ) ; g = e [ j ] +  V . get ( j , j ) * f ; for ( int k = j + _ NUM ; k <= i - _ NUM ; k ++ ) { g +=  V . get ( k , j ) * d [ k ] ; e [ k ] +=  V . get ( k , j ) * f ; } e [ j ] = g ; } f = _ NUM ; for ( int j = _ NUM ; j < i ; j ++ ) { e [ j ] /= h ; f += e [ j ] * d [ j ] ; } double hh = f / ( h + h ) ; for ( int j = _ NUM ; j < i ; j ++ ) { e [ j ] -= hh * d [ j ] ; } for ( int j = _ NUM ; j < i ; j ++ ) { f = d [ j ] ; g = e [ j ] ; for ( int k = j ; k <= i - _ NUM ; k ++ ) {  V . increment ( k , j , - ( f * e [ k ] + g * d [ k ] ) ) ; } d [ j ] =  V . get ( i - _ NUM , j ) ;  V . set ( i , j , _ NUM ) ; } } d [ i ] = h ; } for ( int i = _ NUM ; i < n - _ NUM ; i ++ ) {  V . set ( n - _ NUM , i ,  V . get ( i , i ) ) ;  V . set ( i , i , _ NUM ) ; double h = d [ i + _ NUM ] ; if ( h != _ NUM ) { for ( int k = _ NUM ; k <= i ; k ++ ) { d [ k ] =  V . get ( k , i + _ NUM ) / h ; } for ( int j = _ NUM ; j <= i ; j ++ ) { double g = _ NUM ; for ( int k = _ NUM ; k <= i ; k ++ ) { g +=  V . get ( k , i + _ NUM ) *  V . get ( k , j ) ; }  Row Column Ops . add Mult Col (  V , j , _ NUM , i + _ NUM , - g , d ) ; } }  Row Column Ops . fill Col (  V , i + _ NUM , _ NUM , i + _ NUM , _ NUM ) ; } for ( int j = _ NUM ; j < n ; j ++ ) { d [ j ] =  V . get ( n - _ NUM , j ) ;  V . set ( n - _ NUM , j , _ NUM ) ; }  V . set ( n - _ NUM , n - _ NUM , _ NUM ) ; e [ _ NUM ] = _ NUM ; }
public static void initialize Properties (  Properties properties ) { if ( system Properties != null ) { system Properties . initialize Properties ( properties ) ; } }
public int remove ( int index ) { check Range ( index ) ; int oldval = array [ index ] ; int numtomove = size - index - _ NUM ; if ( numtomove > _ NUM ) {  System . arraycopy ( array , index + _ NUM , array , index , numtomove ) ; } size -- ; return oldval ; }
private boolean check Sufficient Stores ( final  Set all Stores , final boolean logged Insufficent Stores ) { if ( ! logged Insufficent Stores ) { if ( all Stores . size ( ) == _ NUM ) { insufficient Stores ( all Stores ,  Collections .  EMPTY_ LIST , _ BOOL ) ; return _ BOOL ; } } else { if ( all Stores . size ( ) > _ NUM ) { final  String Id log Str =  Localized Strings .  PRHARRedundancy Provider_0_ IN_ THE_ PARTITIONED_ REGION_ REGION_ NAME_1 ; final  Object [ ] log Args = new  Object [ ] {  SUFFICIENT_ STORES_ MSG . to Localized String ( ) , pr Region . get Full Path ( ) } ; if (  TEST_ MODE ) { logger . fatal (  Localized Message . create ( log Str , log Args ) ) ; } else { logger . info (  Localized Message . create ( log Str , log Args ) ) ; } return _ BOOL ; } else { insufficient Stores ( all Stores ,  Collections .  EMPTY_ LIST , _ BOOL ) ; } } return logged Insufficent Stores ; }
public static int prefix Length To Netmask Int ( int prefix Length ) throws  Illegal Argument Exception { if ( prefix Length < _ NUM || prefix Length > _ NUM ) { throw new  Illegal Argument Exception ( _ STR ) ; } int value = _ NUM << ( _ NUM - prefix Length ) ; return  Integer . reverse Bytes ( value ) ; }
public <  T >  String make String Value (  T value ) { return value . to String ( ) ; }
public  Key Pair generate Key Pair ( ) throws  Key Store Exception {  Key Pair key Pair ; try {  Key Pair Generator generator =  Key Pair Generator . get Instance ( _ STR ) ; generator . initialize ( _ NUM ) ; key Pair = generator . generate Key Pair ( ) ; } catch (  No Such Algorithm Exception e ) { throw new  Key Store Exception ( _ STR , e ) ; } return key Pair ; }
private void parse Menu (  Xml Pull Parser parser ,  Attribute Set attrs ,  Icon Data menu ) throws  Xml Pull Parser Exception ,  IOException {  Menu State menu State = new  Menu State ( menu ) ; int event Type = parser . get Event Type ( ) ;  String tag Name ; boolean looking For End Of Unknown Tag = _ BOOL ;  String unknown Tag Name = null ; do { if ( event Type ==  Xml Pull Parser .  START_ TAG ) { tag Name = parser . get Name ( ) ; if ( tag Name . equals (  XML_ MENU ) ) { event Type = parser . next ( ) ; break ; } throw new  Runtime Exception ( _ STR + tag Name ) ; } event Type = parser . next ( ) ; } while ( event Type !=  Xml Pull Parser .  END_ DOCUMENT ) ; boolean reached End Of Menu = _ BOOL ; while ( ! reached End Of Menu ) { switch ( event Type ) { case  Xml Pull Parser .  START_ TAG : if ( looking For End Of Unknown Tag ) { break ; } tag Name = parser . get Name ( ) ; if ( tag Name . equals (  XML_ GROUP ) ) { menu State . read Group ( attrs ) ; } else if ( tag Name . equals (  XML_ ITEM ) ) { menu State . read Item ( attrs ) ; } else if ( tag Name . equals (  XML_ MENU ) ) {  Icon Data sub Menu = menu State . add Sub Menu Item ( ) ; parse Menu ( parser , attrs , sub Menu ) ; } else { looking For End Of Unknown Tag = _ BOOL ; unknown Tag Name = tag Name ; } break ; case  Xml Pull Parser .  END_ TAG : tag Name = parser . get Name ( ) ; if ( looking For End Of Unknown Tag && tag Name . equals ( unknown Tag Name ) ) { looking For End Of Unknown Tag = _ BOOL ; unknown Tag Name = null ; } else if ( tag Name . equals (  XML_ GROUP ) ) { menu State . reset Group ( ) ; } else if ( tag Name . equals (  XML_ ITEM ) ) { if ( ! menu State . has Added Item ( ) ) { menu State . add Item ( ) ; } } else if ( tag Name . equals (  XML_ MENU ) ) { reached End Of Menu = _ BOOL ; } break ; case  Xml Pull Parser .  END_ DOCUMENT : throw new  Runtime Exception ( _ STR ) ; } event Type = parser . next ( ) ; } }
public static double cross Track Distance Rad ( double lat1 , double lon1 , double lat2 , double lon2 , double lat Q , double lon Q , double dist1 Q ) { final double dlon12 = lon2 - lon1 ; final double dlon1 Q = lon Q - lon1 ; final double slat1 =  Math . sin ( lat1 ) , clat1 =  Math Util . sin To Cos ( lat1 , slat1 ) ; final double slat Q =  Math . sin ( lat Q ) , clat Q =  Math Util . sin To Cos ( lat Q , slat Q ) ; final double slat2 =  Math . sin ( lat2 ) , clat2 =  Math Util . sin To Cos ( lat2 , slat2 ) ; final double sdlon12 =  Math . sin ( dlon12 ) , cdlon12 =  Math Util . sin To Cos ( dlon12 , sdlon12 ) ; final double sdlon1 Q =  Math . sin ( dlon1 Q ) , cdlon1 Q =  Math Util . sin To Cos ( dlon1 Q , sdlon1 Q ) ; final double y E = sdlon12 * clat2 ; final double y Q = sdlon1 Q * clat Q ; final double x E = clat1 * slat2 - slat1 * clat2 * cdlon12 ; final double x Q = clat1 * slat Q - slat1 * clat Q * cdlon1 Q ; final double crs12 =  Math . atan2 ( y E , x E ) ; final double crs1 Q =  Math . atan2 ( y Q , x Q ) ; return  Math . asin (  Math . sin ( dist1 Q ) *  Math . sin ( crs1 Q - crs12 ) ) ; }
@  Override public  String choose Server Alias ( final  String key Type , final  Principal [ ] issuers , final  Socket socket ) { if ( key Manager != null ) { return key Manager . choose Server Alias ( key Type , issuers , socket ) ; } return null ; }
public static double log Pdf ( double x , double shape , double scale , double factor ) { if ( x <= _ NUM ) return  Double .  NEGATIVE_ INFINITY ; return factor + shape *  Math . log ( scale ) - ( shape + _ NUM ) *  Math . log ( x ) - ( scale / x ) -  Gamma Function . ln Gamma ( shape ) ; }
public  String charge (  Properties ctx , int  Window No ,  Grid Tab m Tab ,  Grid Field m Field ,  Object value ) {  Integer  C_ Charge_ ID = (  Integer ) value ; if (  C_ Charge_ ID == null ||  C_ Charge_ ID . int Value ( ) == _ NUM ) return _ STR ; if ( m Tab . get Value ( _ STR ) != null ) { m Tab . set Value ( _ STR , null ) ; return _ STR ; } m Tab . set Value ( _ STR , null ) ; m Tab . set Value ( _ STR , null ) ; m Tab . set Value ( _ STR , new  Integer ( _ NUM ) ) ;  Env . set Context ( ctx ,  Window No , _ STR , _ STR ) ;  String sql = _ STR ;  Prepared Statement pstmt = null ;  Result Set rs = null ; try { pstmt =  DB . prepare Statement ( sql , null ) ; pstmt . set Int ( _ NUM ,  C_ Charge_ ID . int Value ( ) ) ; rs = pstmt . execute Query ( ) ; if ( rs . next ( ) ) { m Tab . set Value ( _ STR , rs . get Big Decimal ( _ NUM ) ) ; m Tab . set Value ( _ STR , rs . get Big Decimal ( _ NUM ) ) ; m Tab . set Value ( _ STR ,  Env .  ZERO ) ; m Tab . set Value ( _ STR ,  Env .  ZERO ) ; m Tab . set Value ( _ STR ,  Env .  ZERO ) ; } } catch (  SQLException e ) { log . log (  Level .  SEVERE , sql , e ) ; return e . get Localized Message ( ) ; } finally {  DB . close ( rs , pstmt ) ; rs = null ; pstmt = null ; } return tax ( ctx ,  Window No , m Tab , m Field , value ) ; }
private void process Tag ( final  String Builder builder ) { boolean started = _ BOOL ; while ( template Reader . has Next Character ( ) ) { final char tag Character = template Reader . next Character ( ) ; if ( ! started &&  Strings . is Whitespace ( tag Character ) ) { continue ; } started = _ BOOL ; if ( tag Character == syntax . get Argument Opening ( ) ) { process Argument ( ) ; } else if ( tag Character == syntax . get Tag Opening ( ) && is Next Character Comment Opening ( ) ) { process Comment ( ) ; } else if ( tag Character == syntax . get Tag Closing ( ) ) { process Tag Entity ( builder ) ; return ; } else { builder . append ( tag Character ) ; } } throw Error ( _ STR + builder . to String ( ) ) ; }
public void test BAand BCbroker Network ( ) throws  Exception { bridge Brokers ( _ STR , _ STR ) ; bridge Brokers ( _ STR , _ STR ) ; start All Brokers ( ) ;  Destination dest = create Destination ( _ STR , _ BOOL ) ;  Message Consumer client A = create Consumer ( _ STR , dest ) ;  Message Consumer client B = create Consumer ( _ STR , dest ) ;  Message Consumer client C = create Consumer ( _ STR , dest ) ;  Thread . sleep ( _ NUM ) ; send Messages ( _ STR , dest ,  MESSAGE_ COUNT ) ; send Messages ( _ STR , dest ,  MESSAGE_ COUNT ) ; send Messages ( _ STR , dest ,  MESSAGE_ COUNT ) ;  Message Id List msgs A = get Consumer Messages ( _ STR , client A ) ;  Message Id List msgs B = get Consumer Messages ( _ STR , client B ) ;  Message Id List msgs C = get Consumer Messages ( _ STR , client C ) ; msgs A . wait For Messages To Arrive (  MESSAGE_ COUNT * _ NUM ) ; msgs B . wait For Messages To Arrive (  MESSAGE_ COUNT ) ; msgs C . wait For Messages To Arrive (  MESSAGE_ COUNT * _ NUM ) ; assert Equals (  MESSAGE_ COUNT * _ NUM , msgs A . get Message Count ( ) ) ; assert Equals (  MESSAGE_ COUNT , msgs B . get Message Count ( ) ) ; assert Equals (  MESSAGE_ COUNT * _ NUM , msgs C . get Message Count ( ) ) ; }
protected void write Netscape Ext ( ) throws  IOException { out . write ( _ NUM ) ; out . write ( _ NUM ) ; out . write ( _ NUM ) ; write String ( _ STR + _ STR ) ; out . write ( _ NUM ) ; out . write ( _ NUM ) ; write Short ( repeat ) ; out . write ( _ NUM ) ; }
public static void start ( ) { current . remove ( ) ; }
public static synchronized  Token Info create Token (  Token Type token Type ) {  Token token = new  Token ( token Type . get Module Type ( ) , token Type . get Id ( ) ) ; token . set Module Id ( token Type . get Module Type ( ) ) ; token . set Read Only ( token Type . is Read Only ( ) ) ; token . set Serial Number ( token Type . get Serial Number ( ) ) ; token . set Label ( token Type . get Label ( ) ) ; token . set Slot Index ( token Type . get Slot Index ( ) ) ; token . set Friendly Name ( get Default Friendly Name ( token Type ) ) ; token . set Batch Signing Enabled ( token Type . is Batch Signing Enabled ( ) ) ; token . set Available ( _ BOOL ) ; current Tokens . add ( token ) ; return token . to DTO ( ) ; }
private final boolean validate Client Packet (  Byte Buffer buf ) { return buf . get Short ( _ NUM ) == ~ buf . get Short ( _ NUM ) && buf . get ( _ NUM ) == static Client Packet Code ; }
private boolean matches ( final  Path path , final  Array Deque <  Path Matcher > matchers ) { for (  Path Matcher matcher : matchers ) { if ( matcher . matches ( path ) ) { return _ BOOL ; } } return _ BOOL ; }
public static  Integer parse Int (  String s ) { return ( s == null ) ? (  Integer ) null :  Integer . parse Int ( s ) ; }
public static  Request Security Token Response parse XML (  Input Stream is ) throws  WSFederation Exception {  Document doc =  XMLUtils . to DOMDocument ( is , debug ) ;  Element root = doc . get Document Element ( ) ; return new  Request Security Token Response ( root ) ; }
@  Override public void cancel Resource Request (  Samza Resource Request request ) { log . info ( _ STR , request ) ; synchronized ( lock ) {  AMRMClient .  Container Request container Request = requests Map . get ( request ) ; if ( container Request == null ) { log . info ( _ STR , container Request ) ; return ; } requests Map . remove ( request ) ; am Client . remove Container Request ( container Request ) ; } }
public static  String enumerate Collection With Hash ( final  Collection <  String > collection ) { if ( collection == null ) { return _ STR ; } final  List <  String > result = new  Array List <  String > ( collection . size ( ) ) ; for (  String entry : collection ) { result . add ( _ STR + entry ) ; } return enumerate Collection ( result ) ; }
private  String print DFormat (  String sx ) { int n Leading Zeros = _ NUM ; int n Blanks = _ NUM , n = _ NUM ; int i = _ NUM , j First = _ NUM ; boolean neg = sx . char At ( _ NUM ) == _ STR ; if ( sx . equals ( _ STR ) && precision Set && precision == _ NUM ) sx = _ STR ; if ( ! neg ) { if ( precision Set && sx . length ( ) < precision ) n Leading Zeros = precision - sx . length ( ) ; } else { if ( precision Set && ( sx . length ( ) - _ NUM ) < precision ) n Leading Zeros = precision - sx . length ( ) + _ NUM ; } if ( n Leading Zeros < _ NUM ) n Leading Zeros = _ NUM ; if ( field Width Set ) { n Blanks = field Width - n Leading Zeros - sx . length ( ) ; if ( ! neg && ( leading Sign || leading Space ) ) n Blanks -- ; } if ( n Blanks < _ NUM ) n Blanks = _ NUM ; if ( leading Sign ) n ++ ; else if ( leading Space ) n ++ ; n += n Blanks ; n += n Leading Zeros ; n += sx . length ( ) ; char [ ] ca = new char [ n ] ; if ( left Justify ) { if ( neg ) ca [ i ++ ] = _ STR ; else if ( leading Sign ) ca [ i ++ ] = _ STR ; else if ( leading Space ) ca [ i ++ ] = _ STR ; char [ ] csx = sx . to Char Array ( ) ; j First = neg ? _ NUM : _ NUM ; for ( int j = _ NUM ; j < n Leading Zeros ; i ++ , j ++ ) ca [ i ] = _ STR ; for ( int j = j First ; j < csx . length ; j ++ , i ++ ) ca [ i ] = csx [ j ] ; for ( int j = _ NUM ; j < n Blanks ; i ++ , j ++ ) ca [ i ] = _ STR ; } else { if ( ! leading Zeros ) { for ( i = _ NUM ; i < n Blanks ; i ++ ) ca [ i ] = _ STR ; if ( neg ) ca [ i ++ ] = _ STR ; else if ( leading Sign ) ca [ i ++ ] = _ STR ; else if ( leading Space ) ca [ i ++ ] = _ STR ; } else { if ( neg ) ca [ i ++ ] = _ STR ; else if ( leading Sign ) ca [ i ++ ] = _ STR ; else if ( leading Space ) ca [ i ++ ] = _ STR ; for ( int j = _ NUM ; j < n Blanks ; j ++ , i ++ ) ca [ i ] = _ STR ; } for ( int j = _ NUM ; j < n Leading Zeros ; j ++ , i ++ ) ca [ i ] = _ STR ; char [ ] csx = sx . to Char Array ( ) ; j First = neg ? _ NUM : _ NUM ; for ( int j = j First ; j < csx . length ; j ++ , i ++ ) ca [ i ] = csx [ j ] ; } return new  String ( ca ) ; }
private boolean is Interface Allowed (  Network Interface ni ) throws  Socket Exception { return ! ni . is Loopback ( ) && ! ni . is Point To Point ( ) && ! ni . is Virtual ( ) && ni . is Up ( ) ; }
public void remove ( symbol sym ) throws internal_error { not_null ( sym ) ; _all . remove ( sym . name ( ) ) ; }
public final void add (  V value ) { if (  GWT . is Script ( ) ) { js Array . add ( value ) ; } else { java Array . add ( value ) ; } }
public  Geo Complex Polygon ( final  Planet Model planet Model , final  List <  List <  Geo Point > > points List , final  Geo Point test Point , final boolean test Point In Set ) { super ( planet Model ) ; this . test Point In Set = test Point In Set ; this . test Point = test Point ; this . test Point Fixed YPlane = new  Plane ( _ NUM , _ NUM , _ NUM , - test Point . y ) ; this . test Point Fixed XPlane = new  Plane ( _ NUM , _ NUM , _ NUM , - test Point . x ) ; this . test Point Fixed ZPlane = new  Plane ( _ NUM , _ NUM , _ NUM , - test Point . z ) ; this . test Point Fixed YAbove Plane = new  Plane ( test Point Fixed YPlane , _ BOOL ) ; this . test Point Fixed YBelow Plane = new  Plane ( test Point Fixed YPlane , _ BOOL ) ; this . test Point Fixed XAbove Plane = new  Plane ( test Point Fixed XPlane , _ BOOL ) ; this . test Point Fixed XBelow Plane = new  Plane ( test Point Fixed XPlane , _ BOOL ) ; this . test Point Fixed ZAbove Plane = new  Plane ( test Point Fixed ZPlane , _ BOOL ) ; this . test Point Fixed ZBelow Plane = new  Plane ( test Point Fixed ZPlane , _ BOOL ) ; this . edge Points = new  Geo Point [ points List . size ( ) ] ; this . shape Start Edges = new  Edge [ points List . size ( ) ] ; final  Array List <  Edge > all Edges = new  Array List < > ( ) ; int edge Point Index = _ NUM ; for ( final  List <  Geo Point > shape Points : points List ) { all Edges . ensure Capacity ( all Edges . size ( ) + shape Points . size ( ) ) ;  Geo Point last Geo Point = shape Points . get ( shape Points . size ( ) - _ NUM ) ; edge Points [ edge Point Index ] = last Geo Point ;  Edge last Edge = null ;  Edge first Edge = null ; for ( final  Geo Point this Geo Point : shape Points ) { final  Edge edge = new  Edge ( planet Model , last Geo Point , this Geo Point ) ; all Edges . add ( edge ) ; if ( first Edge == null ) { first Edge = edge ; } if ( last Edge != null ) { last Edge . next = edge ; edge . previous = last Edge ; } last Edge = edge ; last Geo Point = this Geo Point ; } first Edge . previous = last Edge ; last Edge . next = first Edge ; shape Start Edges [ edge Point Index ] = first Edge ; edge Point Index ++ ; } x Tree = new  XTree ( all Edges ) ; y Tree = new  YTree ( all Edges ) ; z Tree = new  ZTree ( all Edges ) ; }
public static  String trim Leading And Trailing Slashes ( final  String in ) { if ( null == in ) return in ;  String out = in ; if ( out . starts With ( _ STR ) ) { out = out . substring ( _ NUM ) ; } if ( out . ends With ( _ STR ) ) { out = out . substring ( _ NUM , out . length ( ) - _ NUM ) ; } return out ; }
public void end ( ) throws  IOException { print ( _ STR , null ) ; printer . println ( ) ; }
public static long parse Timestamp From Hdfs Path (  String hdfs Path ) { int index = hdfs Path . last Index Of ( _ STR ) ; if ( index >= _ NUM ) { return  Long . parse Long ( hdfs Path . substring ( index + _ NUM ) ) ; } else { return  Long . parse Long ( hdfs Path ) ; } }
public void reset Model Names (  Object page Key ) { if ( page Key != null ) { page Storage . put ( page Key , new  Hashtable ( ) ) ; } }
private void unwrap Data ( ) throws  Ignite Checked Exception ,  SSLException { if ( log . is Debug Enabled ( ) ) log . debug ( _ STR + ses ) ; in Net Buf . flip ( ) ;  SSLEngine Result res = unwrap0 ( ) ; in Net Buf . compact ( ) ; check Status ( res ) ; renegotiate If Needed ( res ) ; }
private void check Alter Interval Converters ( ) throws  Security Exception {  Security Manager sm =  System . get Security Manager ( ) ; if ( sm != null ) { sm . check Permission ( new  Joda Time Permission ( _ STR ) ) ; } }
public void save Shared State Attributes ( ) { if ( shared State != null ) { for (  String shared State Key :  SHARED_ STATE_ ATTRIBUTES ) { request Map . put ( shared State Key , (  String ) shared State . get ( shared State Key ) ) ; } } }
public final void add Child Node (  Query Plan Node child Node ) { child Nodes . add ( child Node ) ; }
boolean await Termination ( long timeout ,  Time Unit unit ) throws  Interrupted Exception { return scheduler Service . await Termination ( timeout , unit ) ; }
public static <  T > boolean add All (  Collection < ? super  T > c ,  T ... a ) { boolean modified = _ BOOL ; for ( int i = _ NUM ; i < a . length ; i ++ ) { modified |= c . add ( a [ i ] ) ; } return modified ; }
private static int _index Of Starting From (  List < ? > list , int start Index ,  Object search Value ) { int item Count = list . size ( ) ; boolean found = _ BOOL ; for ( int curr Index = start Index ; curr Index < item Count ; curr Index ++ ) {  Object curr Id = list . get ( curr Index ) ; if ( ( search Value == curr Id ) || ( ( search Value != null ) && search Value . equals ( curr Id ) ) ) { return curr Index ; } } if ( start Index > _ NUM ) { for ( int curr Index = _ NUM ; curr Index < start Index ; curr Index ++ ) {  Object curr Id = list . get ( curr Index ) ; if ( ( search Value == curr Id ) || ( ( search Value != null ) && search Value . equals ( curr Id ) ) ) { return curr Index ; } } } return - _ NUM ; }
public void add Failed Key (  Key Cache Object key ,  Throwable e ) { if ( failed Keys == null ) failed Keys = new  Array List < > ( ) ; failed Keys . add ( key ) ; if ( err == null ) err = new  Ignite Checked Exception ( _ STR ) ; err . add Suppressed ( e ) ; }
private void do Post Helper (  Http Servlet Request request ,  Http Servlet Response response ) throws  Servlet Exception ,  IOException { logger . log (  Level .  INFO , _ STR + request . get Request URI ( ) ) ; final  Request And Response request And Response = new  Request And Response ( request , response ) ; standard Response Stuff ( request And Response ) ; final  String uri = request . get Request URI ( ) ; request And Response . set Override Uri ( uri ) ; if ( uri . equals ( _ STR ) ) { handle Json Create Quotation ( request And Response ) ; } else if ( uri . equals ( _ STR ) ) { handle Html Make Notebook ( request And Response ) ; } else if ( uri . equals ( _ STR ) ) { handle Json Move Notes ( request And Response ) ; } else if ( uri . equals ( _ STR ) ) { handle Json Note Op ( request And Response ) ; } else if ( uri . equals ( _ STR ) ) { handle Json Get Notebook Path ( request And Response ) ; } else if ( uri . equals ( _ STR ) ) { handle Json Make Children ( request And Response ) ; } else if ( uri . equals ( _ STR ) ) { handle Json Make Siblings ( request And Response ) ; } else if ( uri . equals ( _ STR ) ) { handle Json Sign In ( request And Response ) ; } else if ( uri . equals ( _ STR ) ) { handle Json Sign Out ( request And Response ) ; } else if ( uri . equals ( _ STR ) ) { handle Json Create Account ( request And Response ) ; } else if ( uri . starts With ( _ STR ) ) { handle Html Do User Restore ( request And Response ) ; } else if ( uri . starts With ( _ STR ) ) { handle Html Do Offline Db Backup ( request And Response ) ; } else if ( uri . starts With ( _ STR ) ) { handle Html Do Online Db Backup ( request And Response ) ; } else if ( uri . starts With ( _ STR ) ) { handle Html Do Clear ( request And Response ) ; } else if ( uri . starts With ( _ STR ) ) { handle Html Do User Backup ( request And Response ) ; } else if ( uri . starts With ( _ STR ) ) { handle Html Do Shutdown ( request And Response ) ; } else if ( uri . starts With ( _ STR ) ) { handle Html Do Check For Errors ( request And Response ) ; } else if ( uri . starts With ( _ STR ) ) { handle Html Change Password ( request And Response ) ; } else if ( uri . starts With ( _ STR ) ) { handle Html Change Account ( request And Response ) ; } else if ( uri . starts With ( _ STR ) ) { handle Html Close Account ( request And Response ) ; } else if ( uri . equals ( _ STR ) ) { handle Json Save Options ( request And Response ) ; } else if ( uri . starts With ( _ STR ) ) { handle Html Do Export ( request And Response ) ; } else { return Html404 ( request And Response ) ; } }
public  Document create Document ( ) { return builder . new Document ( ) ; }
public  Iterator <  Edge > removed Edge Iterator ( ) { return removed Edge List != null ? removed Edge List . iterator ( ) : new  Null Iterator <  Edge > ( ) ; }
public void press ( int key ) { controller . key Press ( key ) ; }
public boolean has Descendant (  Set <  String > variables ) {  Queue <  BNode > nodes To Process = new  Linked List <  BNode > ( ) ; nodes To Process . add ( this ) ; while ( ! nodes To Process . is Empty ( ) ) {  BNode current Node = nodes To Process . poll ( ) ; for (  BNode descendant Node : current Node . get Output Nodes ( ) ) { if ( variables . contains ( descendant Node . get Id ( ) ) ) { return _ BOOL ; } if ( ! nodes To Process . contains ( descendant Node ) ) { nodes To Process . add ( descendant Node ) ; } } } return _ BOOL ; }
private  List Resource Bundle load Resource Bundle (  String resource Bundle ) throws  Missing Resource Exception { m_resource Bundle Name = resource Bundle ;  Locale locale = get Locale ( ) ;  List Resource Bundle lrb ; try {  Resource Bundle rb =  Resource Bundle . get Bundle ( m_resource Bundle Name , locale ) ; lrb = (  List Resource Bundle ) rb ; } catch (  Missing Resource Exception e ) { try { lrb = (  List Resource Bundle )  Resource Bundle . get Bundle ( m_resource Bundle Name , new  Locale ( _ STR , _ STR ) ) ; } catch (  Missing Resource Exception e2 ) { throw new  Missing Resource Exception ( _ STR + m_resource Bundle Name , m_resource Bundle Name , _ STR ) ; } } m_resource Bundle = lrb ; return lrb ; }
public static boolean is Cglib Proxy Class (  Class < ? > clazz ) { return ( clazz != null && is Cglib Proxy Class Name ( clazz . get Name ( ) ) ) ; }
public void test Bug27412 ( ) throws  Exception {  Properties props = new  Properties ( ) ; props . put ( _ STR , _ STR ) ; props . put ( _ STR , _ STR ) ; props . put ( _ STR , _ STR ) ;  Connection conn2 = get Connection With Props ( props ) ;  Prepared Statement pstm = conn2 . prepare Statement ( _ STR ) ; try { assert True ( pstm . execute ( ) ) ; } finally { pstm . close ( ) ; conn2 . close ( ) ; } }
public static boolean equals ( int [ ] field1 , int [ ] field2 ) { if ( field1 == null || field1 . length == _ NUM ) { return field2 == null || field2 . length == _ NUM ; } else { return  Arrays . equals ( field1 , field2 ) ; } }
public void to Back ( final  Workflow Annotation anno ) { if ( anno == null ) { throw new  Illegal Argument Exception ( _ STR ) ; } synchronized ( lock ) { if ( annotations Draw Order . remove ( anno ) ) { annotations Draw Order . add ( _ NUM , anno ) ; } if ( annotations Event Order . remove ( anno ) ) { annotations Event Order . add ( annotations Event Order . size ( ) , anno ) ; } } }
public static  Duration parse Duration (  String s ) { return dt Factory . new Duration ( s ) ; }
@  Override public  String to String ( ) {  String Builder builder = new  String Builder ( ) ; try { append To ( builder ) ; } catch (  IOException e ) { throw new  Runtime Exception ( e ) ; } return builder . to String ( ) ; }
public static boolean is File Upload Available ( ) { return is File Upload Available ( _ BOOL ) ; }
boolean close Outbound ( ) throws  SSLException { if ( ssl Engine == null || ssl Engine . is Outbound Done ( ) ) { return _ BOOL ; } ssl Engine . close Outbound ( ) ; create Out Net Buffer ( _ NUM ) ;  SSLEngine Result result ; for ( ; ; ) { result = ssl Engine . wrap ( empty Buffer . buf ( ) , out Net Buffer . buf ( ) ) ; if ( result . get Status ( ) ==  Status .  BUFFER_ OVERFLOW ) { out Net Buffer . capacity ( out Net Buffer . capacity ( ) << _ NUM ) ; out Net Buffer . limit ( out Net Buffer . capacity ( ) ) ; } else { break ; } } if ( result . get Status ( ) !=  Status .  CLOSED ) { throw new  SSLException ( _ STR + result ) ; } out Net Buffer . flip ( ) ; return _ BOOL ; }
protected static  Bitmap create Bitmap And Gc If Necessary ( int width , int height ) { try { return  Bitmap . create Bitmap ( width , height ,  Bitmap .  Config .  ARGB_8888 ) ; } catch (  Out Of Memory Error e ) {  System . gc ( ) ; return  Bitmap . create Bitmap ( width , height ,  Bitmap .  Config .  ARGB_8888 ) ; } }
private void write Output File (  String Builder builder ) throws  IOException {  Print Writer writer = new  Print Writer ( get Output File ( ) , _ STR ) ; writer . write ( builder . to String ( ) ) ; writer . flush ( ) ; writer . close ( ) ; }
public void insert (  Event Bean the Event ) { events . add ( the Event ) ;  Event Bean [ ] old Events = null ; if ( events . size ( ) > depth ) { old Events = new  Event Bean [ ] { events . remove ( _ NUM ) } ; } for (  View child : child Views ) { child . update ( new  Event Bean [ ] { the Event } , old Events ) ; } }
public void encode (  Der Output Stream out ) throws  IOException {  Der Value der Value = new  Der Value ( name Value ) ; out . put Der Value ( der Value ) ; }
public  String detect ( ) throws  Lang Detect Exception {  Array List <  Language > probabilities = get Probabilities ( ) ; if ( probabilities . size ( ) > _ NUM ) return probabilities . get ( _ NUM ) . lang ; return  UNKNOWN_ LANG ; }
private void type Alphabetic ( char c ) { if (  Character . is Upper Case ( c ) ) { controller . key Press (  Key Event .  VK_ SHIFT ) ; } controller . key Press (  Character . to Upper Case ( c ) ) ; controller . key Release (  Character . to Upper Case ( c ) ) ; if (  Character . is Upper Case ( c ) ) { controller . key Release (  Key Event .  VK_ SHIFT ) ; } }
private static boolean eq (  Object o1 ,  Object o2 ) { return o1 == null ? o2 == null : o1 . equals ( o2 ) ; }
public void delete (  Job Notification current Notification ) { for ( int i = notifications . size ( ) ; -- i >= _ NUM ; ) { if ( notifications . get ( i ) == current Notification ) { notifications . remove ( i ) ; break ; } } }
@  Override public boolean equals (  Object obj ) { if ( obj == this ) { return _ BOOL ; } if ( obj == null ) { return _ BOOL ; } if ( ! ( get Class ( ) == obj . get Class ( ) ) ) { return _ BOOL ; } return super . equals ( obj ) ; }
protected final void write F (  Byte Buffer buf , float value ) { buf . put Float ( value ) ; }
public void add Item (  T item ) { model . add Item ( item ) ; }
protected void paint Content Border Right Edge (  Graphics g , int x , int y , int w , int h , boolean draw Broken ,  Rectangle sel Rect , boolean is Content Border Painted ) { if ( is Content Border Painted ) { g . set Color ( dark Shadow ) ; g . fill Rect ( x + w - _ NUM , y , _ NUM , h ) ; } }
public static byte [ ] convert DEREncoded Signature To JWSConcatenated ( final byte [ ] der Encoded Signature Value ) throws  IOException { final  ASN1 Input Stream asn1 Input Stream = new  ASN1 Input Stream ( der Encoded Signature Value ) ; final  ASN1 Primitive asn1 Primitive = asn1 Input Stream . read Object ( ) ; asn1 Input Stream . close ( ) ; final  ASN1 Sequence asn1 Sequence = (  ASN1 Sequence . get Instance ( asn1 Primitive ) ) ; final  ASN1 Integer r ASN1 = (  ASN1 Integer ) asn1 Sequence . get Object At ( _ NUM ) ; final  ASN1 Integer s ASN1 = (  ASN1 Integer ) asn1 Sequence . get Object At ( _ NUM ) ; final  X9 Integer Converter x9 Integer Converter = new  X9 Integer Converter ( ) ; final byte [ ] r = x9 Integer Converter . integer To Bytes ( r ASN1 . get Value ( ) , _ NUM ) ; final byte [ ] s = x9 Integer Converter . integer To Bytes ( s ASN1 . get Value ( ) , _ NUM ) ; final byte [ ] concatenated Signature Value = new byte [ _ NUM ] ;  System . arraycopy ( r , _ NUM , concatenated Signature Value , _ NUM , _ NUM ) ;  System . arraycopy ( s , _ NUM , concatenated Signature Value , _ NUM , _ NUM ) ; return concatenated Signature Value ; }
public static <  T >  Parallel Flowable <  T > from (  Publisher < ? extends  T > source , int parallelism ) { return from ( source , parallelism ,  Flowable . buffer Size ( ) ) ; }
public final void add To Tiers By Var Names (  List <  String > var Names ) { if ( ! variables . contains All ( var Names ) ) { for (  String var Name : var Names ) { add Variable ( var Name ) ; } } for (  Object var Name : var Names ) {  String node = (  String ) var Name ; int index = node . last Index Of ( _ STR ) ; if ( index != - _ NUM ) {  String substring = node . substring ( index + _ NUM ) ; add To Tier ( new  Integer ( substring ) , node ) ; } } }
public static  URL make URL (  String path ) { try { return new  URL ( path ) ; } catch (  Exception e ) { return null ; } }
@  Request Processing ( value = _ STR , method =  HTTPRequest Method .  GET ) @  Before ( advice Class = {  Stopwatch Start Advice . class ,  Anonymous View Check . class ,  User Block Check . class } ) @  After ( advice Class =  Stopwatch End Advice . class ) public void show Home ( final  HTTPRequest Context context , final  Http Servlet Request request , final  Http Servlet Response response , final  String user Name ) throws  Exception { final  JSONObject user = (  JSONObject ) request . get Attribute (  User .  USER ) ;  String page Num Str = request . get Parameter ( _ STR ) ; if (  Strings . is Empty Or Null ( page Num Str ) || !  Strings . is Numeric ( page Num Str ) ) { page Num Str = _ STR ; } final int page Num =  Integer . value Of ( page Num Str ) ; request . set Attribute (  Keys .  TEMAPLTE_ DIR_ NAME ,  Symphonys . get ( _ STR ) ) ; final  Abstract Free Marker Renderer renderer = new  Skin Renderer ( ) ; context . set Renderer ( renderer ) ; final  Map <  String ,  Object > data Model = renderer . get Data Model ( ) ; filler . fill Header And Footer ( request , response , data Model ) ; final  String following Id = user . opt String (  Keys .  OBJECT_ ID ) ; data Model . put (  Follow .  FOLLOWING_ ID , following Id ) ; renderer . set Template Name ( _ STR ) ; data Model . put (  User .  USER , user ) ; fill Home User ( data Model , user ) ; avatar Query Service . fill User Avatar URL ( user ) ; final boolean is Logged In = (  Boolean ) data Model . get (  Common .  IS_ LOGGED_ IN ) ; if ( is Logged In ) { final  JSONObject current User = (  JSONObject ) data Model . get (  Common .  CURRENT_ USER ) ; final  String follower Id = current User . opt String (  Keys .  OBJECT_ ID ) ; final boolean is Following = follow Query Service . is Following ( follower Id , following Id ) ; data Model . put (  Common .  IS_ FOLLOWING , is Following ) ; } user . put (  User Ext .  USER_ T_ CREATE_ TIME , new  Date ( user . get Long (  Keys .  OBJECT_ ID ) ) ) ; final int page Size =  Symphonys . get Int ( _ STR ) ; final int window Size =  Symphonys . get Int ( _ STR ) ; final  List <  JSONObject > user Articles = article Query Service . get User Articles ( user . opt String (  Keys .  OBJECT_ ID ) , page Num , page Size ) ; data Model . put (  Common .  USER_ HOME_ ARTICLES , user Articles ) ; final int article Cnt = user . opt Int (  User Ext .  USER_ ARTICLE_ COUNT ) ; final int page Count = ( int )  Math . ceil ( ( double ) article Cnt / ( double ) page Size ) ; final  List <  Integer > page Nums =  Paginator . paginate ( page Num , page Size , page Count , window Size ) ; if ( ! page Nums . is Empty ( ) ) { data Model . put (  Pagination .  PAGINATION_ FIRST_ PAGE_ NUM , page Nums . get ( _ NUM ) ) ; data Model . put (  Pagination .  PAGINATION_ LAST_ PAGE_ NUM , page Nums . get ( page Nums . size ( ) - _ NUM ) ) ; } data Model . put (  Pagination .  PAGINATION_ CURRENT_ PAGE_ NUM , page Num ) ; data Model . put (  Pagination .  PAGINATION_ PAGE_ COUNT , page Count ) ; data Model . put (  Pagination .  PAGINATION_ PAGE_ NUMS , page Nums ) ; final  JSONObject current User =  Sessions . current User ( request ) ; if ( null == current User ) { data Model . put (  Common .  IS_ MY_ ARTICLE , _ BOOL ) ; } else { data Model . put (  Common .  IS_ MY_ ARTICLE , user Name . equals ( current User . opt String (  User .  USER_ NAME ) ) ) ; } }
public static int [ ] sort Values (  Matrix m ) { double [ ] v = new double [ m . get Column Dimension ( ) ] ; int [ ] index = new int [ v . length ] ; for ( int i = _ NUM ; i < v . length ; i ++ ) { v [ i ] = m . get ( i , i ) ; index [ i ] = i ; } for ( int i = _ NUM ; i < v . length ; i ++ ) { for ( int j = i + _ NUM ; j < v . length ; j ++ ) { if (  Math . abs ( v [ i ] ) <  Math . abs ( v [ j ] ) ) { double tmp Value = v [ j ] ; v [ j ] = v [ i ] ; v [ i ] = tmp Value ; int tmp Index = index [ j ] ; index [ j ] = index [ i ] ; index [ i ] = tmp Index ; } } } return index ; }
private int measure Height ( int measure Spec ) { float result ; int spec Mode =  Measure Spec . get Mode ( measure Spec ) ; int spec Size =  Measure Spec . get Size ( measure Spec ) ; if ( spec Mode ==  Measure Spec .  EXACTLY ) { result = spec Size ; } else { result = m Paint Selected . get Stroke Width ( ) + get Padding Top ( ) + get Padding Bottom ( ) ; if ( spec Mode ==  Measure Spec .  AT_ MOST ) { result =  Math . min ( result , spec Size ) ; } } return ( int )  Math . ceil ( result ) ; }
public void layout (  Container container ) {  Map <  Location ,  Drawable > comps = get Components By Location ( container ) ;  Drawable north = comps . get (  Location .  NORTH ) ;  Drawable north East = comps . get (  Location .  NORTH_ EAST ) ;  Drawable east = comps . get (  Location .  EAST ) ;  Drawable south East = comps . get (  Location .  SOUTH_ EAST ) ;  Drawable south = comps . get (  Location .  SOUTH ) ;  Drawable south West = comps . get (  Location .  SOUTH_ WEST ) ;  Drawable west = comps . get (  Location .  WEST ) ;  Drawable north West = comps . get (  Location .  NORTH_ WEST ) ;  Drawable center = comps . get (  Location .  CENTER ) ; double width West = get Max Width ( north West , west , south West ) ; double width East = get Max Width ( north East , east , south East ) ; double height North = get Max Height ( north West , north , north East ) ; double height South = get Max Height ( south West , south , south East ) ; double gap West = ( width West > _ NUM && center != null ) ? get Gap X ( ) : _ NUM ; double gap East = ( width East > _ NUM && center != null ) ? get Gap X ( ) : _ NUM ; double gap North = ( height North > _ NUM && center != null ) ? get Gap Y ( ) : _ NUM ; double gap South = ( height South > _ NUM && center != null ) ? get Gap Y ( ) : _ NUM ;  Rectangle2 D bounds = container . get Bounds ( ) ;  Insets2 D insets = container . get Insets ( ) ; if ( insets == null ) { insets = new  Insets2 D .  Double ( ) ; } double x West = bounds . get Min X ( ) + insets . get Left ( ) ; double x Center = x West + width West + gap West ; double x East = bounds . get Max X ( ) - insets . get Right ( ) - width East ; double y North = bounds . get Min Y ( ) + insets . get Top ( ) ; double y Center = y North + height North + gap North ; double y South = bounds . get Max Y ( ) - insets . get Bottom ( ) - height South ; double width All = width West + width East ; double height All = height North + height South ; double gap HAll = gap West + gap East ; double gap VAll = gap North - gap South ; layout Component ( north West , x West , y North , width West , height North ) ; layout Component ( north , x Center , y North , bounds . get Width ( ) - insets . get Horizontal ( ) - width All - gap HAll , height North ) ; layout Component ( north East , x East , y North , width East , height North ) ; layout Component ( east , x East , y Center , width East , bounds . get Height ( ) - insets . get Vertical ( ) - height All - gap VAll ) ; layout Component ( south East , x East , y South , width East , height South ) ; layout Component ( south , x Center , y South , bounds . get Width ( ) - insets . get Horizontal ( ) - width All - gap HAll , height South ) ; layout Component ( south West , x West , y South , width West , height South ) ; layout Component ( west , x West , y Center , width West , bounds . get Height ( ) - insets . get Vertical ( ) - height All - gap VAll ) ; layout Component ( center , x Center , y Center , bounds . get Width ( ) - insets . get Left ( ) - width All - insets . get Right ( ) - gap HAll , bounds . get Height ( ) - insets . get Top ( ) - height All - insets . get Bottom ( ) - gap VAll ) ; }
public void append ( byte [ ] buffer , int offset , int length ) { if ( _length + length >= _capacity ) ensure Capacity ( _length + length ) ;  System . arraycopy ( buffer , offset , _buffer , _length , length ) ; _length += length ; }
private static  Vector  Parenthesize (  Vector vec ) { if (  Needs Parentheses ( vec ) ) { vec . set Element At ( _ STR + ( (  String ) vec . element At ( _ NUM ) ) , _ NUM ) ; for ( int i = _ NUM ; i < vec . size ( ) ; i ++ ) { vec . set Element At ( _ STR + ( (  String ) vec . element At ( i ) ) , i ) ; } ; int cur Line Num = vec . size ( ) - _ NUM ; vec . set Element At ( ( (  String ) vec . element At ( cur Line Num ) ) + _ STR , cur Line Num ) ; } ; return vec ; }
protected void draw Value (  Canvas c ,  String value , float x Pos , float y Pos ) { c . draw Text ( value , x Pos , y Pos , m Value Paint ) ; }
private void update Data Type State ( ) { boolean is Sync Enabled = m Sync Switch Preference . is Checked ( ) ; boolean sync Everything = m Sync Everything . is Checked ( ) ; boolean password Sync Configurable = m Profile Sync Service . is Sync Initialized ( ) && m Profile Sync Service . is Cryptographer Ready ( ) ; for (  Check Box Preference pref : m All Types ) { boolean can Sync Type = pref != m Sync Passwords || password Sync Configurable ; if ( ! is Sync Enabled ) { pref . set Checked ( _ BOOL ) ; } else if ( sync Everything ) { pref . set Checked ( can Sync Type ) ; } pref . set Enabled ( is Sync Enabled && ! sync Everything && can Sync Type ) ; } if ( is Sync Enabled && ! sync Everything ) {  Set <  Integer > sync Types = m Profile Sync Service . get Preferred Data Types ( ) ; m Sync Autofill . set Checked ( sync Types . contains (  Model Type .  AUTOFILL ) ) ; m Sync Bookmarks . set Checked ( sync Types . contains (  Model Type .  BOOKMARKS ) ) ; m Sync Omnibox . set Checked ( sync Types . contains (  Model Type .  TYPED_ URLS ) ) ; m Sync Passwords . set Checked ( password Sync Configurable && sync Types . contains (  Model Type .  PASSWORDS ) ) ; m Sync Recent Tabs . set Checked ( sync Types . contains (  Model Type .  PROXY_ TABS ) ) ; m Sync Settings . set Checked ( sync Types . contains (  Model Type .  PRIORITY_ PREFERENCES ) ) ; } }
public static boolean equals (  Object a ,  Object b ) { return ( a == b ) || ( a != null && a . equals ( b ) ) ; }
private  Etcd Keys Response handle Etcd Watch Errors (  Etcd Exception exception ) { if ( exception . error Code ==  ETCD_ EVENT_ INDEX_ CLEARED_ CODE ) { initial Set All Flagz ( ) ; return null ; } else if ( exception . error Code ==  ETCD_ WATCHER_ CLEARED_ CODE ) { try {  Thread . sleep ( reelection Backoff Ms . get ( ) ) ; } catch (  Interrupted Exception e1 ) { } return null ; } else { throw new  Etcd Flag Field Updater Exception .  Etcd Fetching Failed ( exception ) ; } }
public final static void close EL ( final  Input Stream is ) { try { if ( is != null ) is . close ( ) ; } catch ( final  Throwable e ) { } }
public static void monitor Signal ( final  Object monitor ) { synchronized ( monitor ) { monitor . notify All ( ) ; } }
private static  String string Of Char ( char ch , int len ) {  String Buffer buf = new  String Buffer ( ) ; for ( int i = _ NUM ; i < len ; i ++ ) { buf . append ( ch ) ; } return buf . to String ( ) ; }
private static  String generate Timestamp ( ) {  Simple Date Format sdf = new  Simple Date Format ( _ STR ,  Locale .  US ) ; return sdf . format ( new  Date ( ) ) ; }
boolean is Disjoint (  Type Declaration td ) { if ( this instanceof  Union Type ) { return _ BOOL ; } if ( this instanceof  Class Or Interface && td instanceof  Class Or Interface && equals ( td ) ) { return _ BOOL ; } if ( this instanceof  Type Parameter && td instanceof  Type Parameter && equals ( td ) ) { return _ BOOL ; }  List <  Type > sts = get Satisfied Types ( ) ; for ( int i = _ NUM , s = sts . size ( ) ; i < s ; i ++ ) {  Type st = sts . get ( i ) ; if ( is Disjoint ( td , st ) ) { return _ BOOL ; } }  Type et = get Extended Type ( ) ; if ( et != null ) { if ( is Disjoint ( td , et ) ) { return _ BOOL ; } } return _ BOOL ; }
public void offer Busy Box (  Activity activity ) {  Root Tools . log ( _ STR ) ;  Intent i = new  Intent (  Intent .  ACTION_ VIEW ,  Uri . parse ( _ STR ) ) ; activity . start Activity ( i ) ; }
public final void wait ( long timeout ) throws java . lang .  Interrupted Exception { wait ( timeout , _ NUM ) ; }
private static boolean is Appropriate Property Name For Getter ( @  Not Null  Psi Method getter , @  Not Null  String imported Name For Getter , @  Not Null  String property Name ) { property Name =  Groovy Property Utils . decapitalize ( property Name ) ; return property Name . equals ( get Property Name By Getter ( getter , imported Name For Getter ) ) ; }
private void do Wait For (  Process process ) { start Read Stream Thread ( process . get Input Stream ( ) ) ; start Read Stream Thread ( process . get Error Stream ( ) ) ; try { process . wait For ( ) ; } catch (  Interrupted Exception e ) { log . warn ( _ STR , e ) ; } }
private void remove Old Jar ( ) throws  IOException { if ( output File . exists ( ) ) { if ( output File . is Directory ( ) ) { if ( !  File Utils . recursive Delete ( output File ) ) { throw new  IOException ( _ STR + output File . get Absolute Path ( ) + _ STR ) ; } } else { if ( ! output File . delete ( ) ) { throw new  IOException ( _ STR + output File . get Absolute Path ( ) + _ STR ) ; } } } }
protected final void append Int ( final int number ) { for ( int i = _ NUM ; i >= _ NUM ; -- i ) { byte Data . add (  Byte . value Of ( ( byte ) ( number > > _ NUM * i & _ NUM ) ) ) ; } }
public boolean contains All (  Collection <  Taxon > taxa ) { for (  Taxon taxon : taxa ) { if ( ! taxa . contains ( taxon ) ) { return _ BOOL ; } } return _ BOOL ; }
protected int draw Label Text ( int text Decoration , boolean rtl , boolean is Ticker Running , boolean ends With3 Points ,  Object native Font , int txt W , int text Space W , int shift Text ,  String text , int x , int y , int font Height ) { if ( ( ! is Ticker Running ) || rtl ) { if ( txt W > text Space W && text Space W > _ NUM ) { if ( rtl ) { if ( ( ! is Ticker Running ) && ends With3 Points ) {  String points = _ STR ; int points W = impl . string Width ( native Font , points ) ; draw String ( native Font , points , shift Text + x , y , text Decoration , font Height ) ; clip Rect ( points W + shift Text + x , y , text Space W - points W , font Height ) ; } x = x - txt W + text Space W ; } else if ( ends With3 Points ) {  String points = _ STR ; int index = _ NUM ; int widest = impl . char Width ( native Font , _ STR ) ; int points W = impl . string Width ( native Font , points ) ; while ( fast Char Width Check ( text , index , text Space W - points W , widest , native Font ) && index < text . length ( ) ) { index ++ ; } text = text . substring ( _ NUM ,  Math . min ( text . length ( ) ,  Math . max ( _ NUM , index - _ NUM ) ) ) + points ; txt W = impl . string Width ( native Font , text ) ; } } } draw String ( native Font , text , shift Text + x , y , text Decoration , font Height ) ; return  Math . min ( txt W , text Space W ) ; }
public void apply Interpolated Radii ( ) {  Assert . is True ( map Objects != null ) ;  Assert . is True ( map Objects . size ( ) > _ NUM ) ;  Internal Map Object min = null , max = null ; for (  Internal Map Object map Object : map Objects ) { if ( min == null || map Object . get Value ( ) < min . get Value ( ) ) { min = map Object ; } if ( max == null || map Object . get Value ( ) > max . get Value ( ) ) { max = map Object ; } } for (  Internal Map Object map Object : map Objects ) { double factor = ( map Object . get Value ( ) - min . get Value ( ) ) / ( max . get Value ( ) - min . get Value ( ) ) ; int radius =  Map Utils . lerp ( radius Low , radius High , factor ) ; map Object . set Radius ( radius ) ; } }
public final void add Action (  String action ) { if ( ! m Actions . contains ( action ) ) { m Actions . add ( action . intern ( ) ) ; } }
public void dump ( ) { dump ( this ) ; }
public int add Aggregate (  Aggregate Function Expression aggregate ) { int position = group By . size ( ) + aggregates . size ( ) ; aggregates . add ( aggregate ) ; options . add ( aggregate . get Option ( ) ) ; return position ; }
public  Dimension preferred Layout Size (  Container target ) { synchronized ( target . get Tree Lock ( ) ) {  Dimension dim = new  Dimension ( _ NUM , _ NUM ) ; if ( ( chart != null ) && chart . is Visible ( ) ) {  Dimension d = chart . get Preferred Size ( ) ; dim . width = d . width ; dim . height = d . height ; } if ( ( x Label != null ) && x Label . is Visible ( ) ) {  Dimension d = x Label . get Preferred Size ( ) ; dim . width =  Math . max ( d . width , dim . width ) ; dim . height += d . height + vgap ; } if ( ( y Label != null ) && y Label . is Visible ( ) ) {  Dimension d = y Label . get Preferred Size ( ) ; dim . width += d . width + hgap ; dim . height =  Math . max ( d . height , dim . height ) ; } if ( ( title != null ) && title . is Visible ( ) ) {  Dimension d = title . get Preferred Size ( ) ; dim . width =  Math . max ( d . width , dim . width ) ; dim . height += d . height + vgap ; }  Insets insets = target . get Insets ( ) ; dim . width += insets . left + insets . right ; dim . height += insets . top + insets . bottom ; return dim ; } }
protected  Resource load Resource (  String resource Name , int resource Type ,  String encoding ) throws  Resource Not Found Exception ,  Parse Error Exception ,  Exception {  Resource resource =  Resource Factory . get Resource ( resource Name , resource Type ) ; resource . set Runtime Services ( rsvc ) ; resource . set Name ( resource Name ) ; resource . set Encoding ( encoding ) ; long how Old It Was = _ NUM ;  Resource Loader resource Loader = null ; for ( int i = _ NUM ; i < resource Loaders . size ( ) ; i ++ ) { resource Loader = (  Resource Loader ) resource Loaders . get ( i ) ; resource . set Resource Loader ( resource Loader ) ; try { if ( resource . process ( ) ) { if ( log When Found ) { rsvc . info ( _ STR + resource Name + _ STR + resource Loader . get Class Name ( ) ) ; } how Old It Was = resource Loader . get Last Modified ( resource ) ; break ; } } catch (  Resource Not Found Exception rnfe ) { } } if ( resource . get Data ( ) == null ) { throw new  Resource Not Found Exception ( _ STR + resource Name + _ STR ) ; } resource . set Last Modified ( how Old It Was ) ; resource . set Modification Check Interval ( resource Loader . get Modification Check Interval ( ) ) ; resource . touch ( ) ; return resource ; }
public javax . sip . address .  Tel URL create Tel URL (  String uri ) throws  Parse Exception { if ( uri == null ) throw new  Null Pointer Exception ( _ STR ) ;  String tel Url = null ; if ( uri . starts With ( _ STR ) ) { tel Url = uri ; } else { tel Url = _ STR + uri ; } try {  String Msg Parser smp = new  String Msg Parser ( ) ;  Tel URLImpl timp = (  Tel URLImpl ) smp . parse Url ( tel Url ) ; return (  Tel URL ) timp ; } catch (  Parse Exception ex ) { throw new  Parse Exception ( ex . get Message ( ) , _ NUM ) ; } }
public  Kernel Logistic Regression Model (  Example Set example Set ,  List <  Support Vector > support Vectors ,  Kernel kernel , double bias ) { super ( example Set ,  Example Set Utilities .  Sets Compare Option .  ALLOW_ SUPERSET ,  Example Set Utilities .  Types Compare Option .  ALLOW_ SAME_ PARENTS ) ; this . support Vectors = support Vectors ; if ( support Vectors == null || support Vectors . size ( ) == _ NUM ) { throw new  Illegal Argument Exception ( _ STR ) ; } this . kernel = kernel ; this . bias = bias ; }
public boolean remove Update ( final  Password password ) throws  IOException ,  Servlet Exception { if ( ! singelton . can (  CFMLEngine .  CAN_ UPDATE , password ) ) throw new  IOException ( _ STR ) ; return remove Update ( ) ; }
public  Property Sheet Panel ( ) { set Border (  Border Factory . create Empty Border ( _ NUM , _ NUM , _ NUM , _ NUM ) ) ; m_env =  Environment . get System Wide ( ) ; }
public static double logpdf ( double x , double mu , double sigma , double k ) { if ( x ==  Double .  POSITIVE_ INFINITY || x ==  Double .  NEGATIVE_ INFINITY ) { return  Double .  NEGATIVE_ INFINITY ; } x = ( x - mu ) / sigma ; if ( k > _ NUM || k < _ NUM ) { if ( k * x > _ NUM ) { return  Double .  NEGATIVE_ INFINITY ; } double t =  Math . log ( _ NUM - k * x ) ; return t ==  Double .  NEGATIVE_ INFINITY ? -  Math . log ( sigma ) : t ==  Double .  POSITIVE_ INFINITY ?  Double .  NEGATIVE_ INFINITY : ( _ NUM - k ) * t / k -  Math . exp ( t / k ) -  Math . log ( sigma ) ; } else { return - x -  Math . exp ( - x ) -  Math . log ( sigma ) ; } }
public static  Format generate Format (  String codec ) { return s Supported Codexs . get ( codec . to Lower Case ( ) ) ; }
public  Optional Int min By Int (  Int Unary Operator key Extractor ) { int [ ] result = collect ( null , null , null ) ; return result [ _ NUM ] == _ NUM ?  Optional Int . of ( result [ _ NUM ] ) :  Optional Int . empty ( ) ; }
public void add ( final  T entry ) { if ( entry == null ) throw new  Illegal Argument Exception ( ) ; final long commit Time = entry . get Commit Time ( ) ; if ( commit Time == _ NUM ) throw new  Illegal Argument Exception ( ) ; final  Lock lock = write Lock ( ) ; lock . lock ( ) ; try { final byte [ ] key = get Key ( commit Time ) ; if ( super . contains ( key ) ) { throw new  Illegal Argument Exception ( _ STR + commit Time ) ; } super . insert ( key , entry ) ; } finally { lock . unlock ( ) ; } }
public static  String format Exception (  Exception exc ) {  String Writer string Writer = new  String Writer ( ) ;  Print Writer print Writer = new  Print Writer ( string Writer ) ; exc . print Stack Trace ( print Writer ) ; try { string Writer . close ( ) ; } catch (  IOException ex ) { } return string Writer . to String ( ) ; }
public final void add To Tiers By Var Names (  List <  String > var Names ) { if ( ! variables . contains All ( var Names ) ) { for (  String var Name : var Names ) { add Variable ( var Name ) ; } } for (  Object var Name : var Names ) {  String node = (  String ) var Name ; int index = node . last Index Of ( _ STR ) ; if ( index != - _ NUM ) {  String substring = node . substring ( index + _ NUM ) ; add To Tier ( new  Integer ( substring ) , node ) ; } } }
@  Override public void on Thread End ( ) { _thread Count . get And Decrement ( ) ; wake ( ) ; }
public static void register Local Time MBean (  String container Name ) {  MBean Server m Bean Server = get MBean Server ( container Name ) ; if ( m Bean Server == null ) return ;  Local Time MBean local Time MBean = new  Local Time ( ) ;  Object Name obj Name =  Local Time Constants .  MBEAN_ NAME ; if ( ! m Bean Server . is Registered ( obj Name ) ) { try { m Bean Server . register MBean ( local Time MBean , obj Name ) ; } catch (  Instance Already Exists Exception e ) { } catch (  Not Compliant MBean Exception e ) { if ( _logger . is Loggable (  Level .  WARNING ) ) { _logger . log (  Level .  SEVERE , failed Local Time MBean Registration Message Prefix + container Name + _ STR , e ) ; } } catch (  MBean Registration Exception e ) { if ( _logger . is Loggable (  Level .  SEVERE ) ) { _logger . log (  Level .  SEVERE , failed Local Time MBean Registration Message Prefix + container Name + _ STR , e ) ; } } if ( _logger . is Loggable (  Level .  CONFIG ) ) { _logger . config ( successful Transport MBean Registration Message + container Name + _ STR ) ; } } }
final public static int insert Table (  V sets ,  Class < ? extends  Bean > t ) {  Table mapping = (  Table ) t . get Annotation (  Table . class ) ; if ( mapping == null ) { if ( log . is Error Enabled ( ) ) log . error ( _ STR + t + _ STR ) ; return - _ NUM ; } if ( !  X . is Empty ( mapping . name ( ) ) ) { return insert Table ( mapping . name ( ) , sets ) ; } return - _ NUM ; }
public boolean stop Rendering ( ) { if ( m Timer != null ) { m Timer . shutdown Now ( ) ; m Timer = null ; return _ BOOL ; } return _ BOOL ; }
public boolean remove Listener (  Listener listener ) { return listeners . remove ( listener ) ; }
public static synchronized void add From Properties (  Input Stream props Stream ) throws  Exception {  Properties exp Props = new  Properties ( ) ; exp Props . load ( props Stream ) ; props Stream . close ( ) ; props Stream = null ; add From Properties ( exp Props ) ; }
public void clear (  Absolute Table Identifier absolute Table Identifier ) { table Lock Map . remove ( absolute Table Identifier ) ; table Segment Map . remove ( absolute Table Identifier ) ; }
protected void finish (  Qualifier Hierarchy qual Hierarchy ,  Map <  Annotation Mirror ,  Set <  Annotation Mirror > > full Map ,  Map <  Annotation Mirror ,  Annotation Mirror > poly Qualifiers ,  Set <  Annotation Mirror > tops ,  Set <  Annotation Mirror > bottoms ,  Object ... args ) { }
public void task Soon Main ( final  Runnable r , boolean async ) { if ( async ) { async ( r ) ; } else { task ( r ) ; } }
public void move ( int from , int to , int count ) { if ( ! valid ( ) ) { return ; } invalidate Line Map After (  Math . min ( from , to ) ) ;  Point [ ] items To Move = new  Point [ count ] ; for ( int i = from ; i < from + count ; i ++ ) { items To Move [ i - from ] = size Map . get ( i ) ; } boolean moving Forward = from - to > _ NUM ; int items To Shift =  Math . abs ( from - to ) ; if ( ! moving Forward ) { items To Shift -= count ; } int shift Index = moving Forward ? from - _ NUM : from + count ; int shift Index Step = moving Forward ? - _ NUM : _ NUM ; int shifted = _ NUM ; while ( shifted < items To Shift ) { size Map . put ( shift Index - ( shift Index Step ) * count , size Map . get ( shift Index ) ) ; shift Index += shift Index Step ; shifted ++ ; } int set Index = to ; if ( ! moving Forward ) { set Index = from + items To Shift ; } for (  Point item : items To Move ) { size Map . put ( set Index ++ , item ) ; } refresh Line Map ( ) ; }
private  Connection open Connection ( boolean autocommit ) throws  SQLException {  Connection conn = data Src != null ? data Src . get Connection ( ) :  Driver Manager . get Connection ( conn Url , user , passwd ) ; if ( test Mode ) opened . increment ( ) ; conn . set Auto Commit ( autocommit ) ; return conn ; }
public static boolean is Left Click (  Mouse Event e ) { return ( ( e . get Button ( ) ==  Mouse Event .  BUTTON1 ) && ( e . get Click Count ( ) == _ NUM ) ) ; }
public  RDFParse Exception (  Throwable t , long line No , long column No ) { super ( t . get Message ( ) + get Location String ( line No , column No ) , t ) ; this . line No = line No ; this . column No = column No ; }
public  Set key Set ( ) { if ( key Set == null ) key Set = new  Synchronized Set ( new  Key Set ( ) , this ) ; return key Set ; }
public void list (  Print Writer out ) { properties . list ( out ) ; }
public static void dump (  String file Name , boolean details ) { dump ( file Name , new  Print Writer (  System . out ) , details ) ; }
private static int [ ] mult256 ( int [ ] a , int [ ] b ) { int [ ] result = new int [ _ NUM ] ; int [ ] a0 = new int [ _ NUM ] ;  System . arraycopy ( a , _ NUM , a0 , _ NUM ,  Math . min ( _ NUM , a . length ) ) ; int [ ] a1 = new int [ _ NUM ] ; if ( a . length > _ NUM ) {  System . arraycopy ( a , _ NUM , a1 , _ NUM ,  Math . min ( _ NUM , a . length - _ NUM ) ) ; } int [ ] b0 = new int [ _ NUM ] ;  System . arraycopy ( b , _ NUM , b0 , _ NUM ,  Math . min ( _ NUM , b . length ) ) ; int [ ] b1 = new int [ _ NUM ] ; if ( b . length > _ NUM ) {  System . arraycopy ( b , _ NUM , b1 , _ NUM ,  Math . min ( _ NUM , b . length - _ NUM ) ) ; } if ( a1 [ _ NUM ] == _ NUM && a1 [ _ NUM ] == _ NUM && b1 [ _ NUM ] == _ NUM && b1 [ _ NUM ] == _ NUM ) { if ( a1 [ _ NUM ] == _ NUM && b1 [ _ NUM ] == _ NUM ) { if ( a1 [ _ NUM ] != _ NUM || b1 [ _ NUM ] != _ NUM ) { int [ ] c = mult32 ( a1 [ _ NUM ] , b1 [ _ NUM ] ) ; result [ _ NUM ] ^= c [ _ NUM ] ; result [ _ NUM ] ^= c [ _ NUM ] ; result [ _ NUM ] ^= c [ _ NUM ] ; result [ _ NUM ] ^= c [ _ NUM ] ; } } else { int [ ] c = mult64 ( a1 , b1 ) ; result [ _ NUM ] ^= c [ _ NUM ] ; result [ _ NUM ] ^= c [ _ NUM ] ; result [ _ NUM ] ^= c [ _ NUM ] ; result [ _ NUM ] ^= c [ _ NUM ] ; result [ _ NUM ] ^= c [ _ NUM ] ; result [ _ NUM ] ^= c [ _ NUM ] ; result [ _ NUM ] ^= c [ _ NUM ] ; result [ _ NUM ] ^= c [ _ NUM ] ; } } else { int [ ] c = mult128 ( a1 , b1 ) ; result [ _ NUM ] ^= c [ _ NUM ] ; result [ _ NUM ] ^= c [ _ NUM ] ; result [ _ NUM ] ^= c [ _ NUM ] ; result [ _ NUM ] ^= c [ _ NUM ] ; result [ _ NUM ] ^= c [ _ NUM ] ^ c [ _ NUM ] ; result [ _ NUM ] ^= c [ _ NUM ] ^ c [ _ NUM ] ; result [ _ NUM ] ^= c [ _ NUM ] ^ c [ _ NUM ] ; result [ _ NUM ] ^= c [ _ NUM ] ^ c [ _ NUM ] ; result [ _ NUM ] ^= c [ _ NUM ] ; result [ _ NUM ] ^= c [ _ NUM ] ; result [ _ NUM ] ^= c [ _ NUM ] ; result [ _ NUM ] ^= c [ _ NUM ] ; } a1 [ _ NUM ] ^= a0 [ _ NUM ] ; a1 [ _ NUM ] ^= a0 [ _ NUM ] ; a1 [ _ NUM ] ^= a0 [ _ NUM ] ; a1 [ _ NUM ] ^= a0 [ _ NUM ] ; b1 [ _ NUM ] ^= b0 [ _ NUM ] ; b1 [ _ NUM ] ^= b0 [ _ NUM ] ; b1 [ _ NUM ] ^= b0 [ _ NUM ] ; b1 [ _ NUM ] ^= b0 [ _ NUM ] ; int [ ] d = mult128 ( a1 , b1 ) ; result [ _ NUM ] ^= d [ _ NUM ] ; result [ _ NUM ] ^= d [ _ NUM ] ; result [ _ NUM ] ^= d [ _ NUM ] ; result [ _ NUM ] ^= d [ _ NUM ] ; result [ _ NUM ] ^= d [ _ NUM ] ; result [ _ NUM ] ^= d [ _ NUM ] ; result [ _ NUM ] ^= d [ _ NUM ] ; result [ _ NUM ] ^= d [ _ NUM ] ; int [ ] e = mult128 ( a0 , b0 ) ; result [ _ NUM ] ^= e [ _ NUM ] ; result [ _ NUM ] ^= e [ _ NUM ] ; result [ _ NUM ] ^= e [ _ NUM ] ; result [ _ NUM ] ^= e [ _ NUM ] ; result [ _ NUM ] ^= e [ _ NUM ] ^ e [ _ NUM ] ; result [ _ NUM ] ^= e [ _ NUM ] ^ e [ _ NUM ] ; result [ _ NUM ] ^= e [ _ NUM ] ^ e [ _ NUM ] ; result [ _ NUM ] ^= e [ _ NUM ] ^ e [ _ NUM ] ; result [ _ NUM ] ^= e [ _ NUM ] ; result [ _ NUM ] ^= e [ _ NUM ] ; result [ _ NUM ] ^= e [ _ NUM ] ; result [ _ NUM ] ^= e [ _ NUM ] ; return result ; }
@  Override public  Enumeration <  Option > list Options ( ) {  Vector <  Option > result = enum To Vector ( super . list Options ( ) ) ; result . add Element ( new  Option ( _ STR + default Num Attributes ( ) + _ STR , _ STR , _ NUM , _ STR ) ) ; result . add Element ( new  Option ( _ STR + default Num Classes ( ) + _ STR , _ STR , _ NUM , _ STR ) ) ; result . add Element ( new  Option ( _ STR + default Max Rule Size ( ) + _ STR , _ STR , _ NUM , _ STR ) ) ; result . add Element ( new  Option ( _ STR + default Min Rule Size ( ) + _ STR , _ STR , _ NUM , _ STR ) ) ; result . add Element ( new  Option ( _ STR + default Num Irrelevant ( ) + _ STR , _ STR , _ NUM , _ STR ) ) ; result . add Element ( new  Option ( _ STR + default Num Numeric ( ) + _ STR , _ STR , _ NUM , _ STR ) ) ; result . add Element ( new  Option ( _ STR , _ STR , _ NUM , _ STR ) ) ; return result . elements ( ) ; }
@  Override public  String to String ( ) { final  String Builder sb = new  String Builder ( ) ; sb . append ( _ STR ) ; sb . append ( get Request ID ( ) ) ; sb . append ( _ STR ) ; sb . append ( timestamp ) ; sb . append ( _ STR ) ; sb . append ( get Request ( ) ) ; sb . append ( _ STR ) ; return sb . to String ( ) ; }
public  Crl Client Online (  Certificate [ ] chain ) { for ( int i = _ NUM ; i < chain . length ; i ++ ) {  X509 Certificate cert = (  X509 Certificate ) chain [ i ] ;  LOGGER . info ( _ STR + cert . get Subject DN ( ) ) ; try { add Url (  Certificate Util . get CRLURL ( cert ) ) ; } catch (  Certificate Parsing Exception e ) {  LOGGER . info ( _ STR ) ; } } }
@  Override public  Enumeration <  Option > list Options ( ) {  Vector <  Option > new Vector = new  Vector <  Option > ( ) ; new Vector . add Element ( new  Option ( _ STR , _ STR , _ NUM , _ STR ) ) ; return new Vector . elements ( ) ; }
public int load Data ( int size ) {  List <  String > list = new  Array List < > ( ) ; for ( int i = _ NUM ; i < size ; i ++ ) list . add ( _ STR + size ) ; return list . size ( ) ; }
public void add Class To Display (  Method Ident method Ident ) { classes . add ( method Ident ) ; }
private static boolean compare Strings ( final  String s1 , final  String s2 ) { if ( s1 == s2 ) { return _ BOOL ; } if ( s1 == null ) { return _ BOOL ; } return s1 . equals ( s2 ) ; }
private static void load Package Data (  Context context ) { if ( context != null ) { try {  Package Manager package Manager = context . get Package Manager ( ) ;  Package Info package Info = package Manager . get Package Info ( context . get Package Name ( ) , _ NUM ) ;  Constants .  APP_ PACKAGE = package Info . package Name ;  Constants .  APP_ VERSION = _ STR + package Info . version Code ;  Constants .  APP_ VERSION_ NAME = package Info . version Name ; int build Number = load Build Number ( context , package Manager ) ; if ( ( build Number != _ NUM ) && ( build Number > package Info . version Code ) ) {  Constants .  APP_ VERSION = _ STR + build Number ; } } catch (  Exception e ) {  Log . e (  TAG , _ STR ) ; e . print Stack Trace ( ) ; } } }
public static  Left Indexed Power Law Multi Segment Bipartite Graph build Random Multi Segment Bipartite Graph ( int max Num Segments , int max Num Edges Per Segment , int left Size , int right Size , double edge Probability ,  Random random ) {  Left Indexed Power Law Multi Segment Bipartite Graph multi Segment Left Indexed Power Law Bipartite Graph = new  Left Indexed Power Law Multi Segment Bipartite Graph ( max Num Segments , max Num Edges Per Segment , left Size / _ NUM , ( int ) ( right Size * edge Probability / _ NUM ) , _ NUM , right Size / _ NUM , new  Identity Edge Type Mask ( ) , new  Null Stats Receiver ( ) ) ; for ( int i = _ NUM ; i < left Size ; i ++ ) { for ( int j = _ NUM ; j < right Size ; j ++ ) { if ( random . next Double ( ) < edge Probability ) { multi Segment Left Indexed Power Law Bipartite Graph . add Edge ( i , j , ( byte ) _ NUM ) ; } } } return multi Segment Left Indexed Power Law Bipartite Graph ; }
public byte [ ] handle Request (  String request ) throws  IOException ,  Map Request Format Exception {  Properties request Properties = convert Request To Props ( request ) ;  String request Type = request Properties . get Property (  REQUEST ) ; if ( request Type != null ) { if ( request Type . equals Ignore Case (  MAP ) ) {  Debug . message ( _ STR , _ STR ) ; return handle Map Request ( request Properties ) ; } else { throw new  Map Request Format Exception ( _ STR + request Type ) ; } } else { throw new  Map Request Format Exception ( _ STR + request ) ; } }
public boolean is Power Of Three ( int n ) { if ( n <= _ NUM ) return _ BOOL ; while ( n > _ NUM && n % _ NUM == _ NUM ) { n /= _ NUM ; } return n == _ NUM ; }
public  Array List <  Entry > process (  File input File Or Dir ,  File output Root ) throws  Exception { if ( ! input File Or Dir . exists ( ) ) throw new  Illegal Argument Exception ( _ STR + input File Or Dir . get Absolute Path ( ) ) ; if ( input File Or Dir . is File ( ) ) return process ( new  File [ ] { input File Or Dir } , output Root ) ; else return process ( input File Or Dir . list Files ( ) , output Root ) ; }
public static  File locate Replicator Conf Dir ( ) { if ( replicator Conf Dir == null ) {  String replicator Conf =  System . get Property (  CONF_ DIR ) ; if ( replicator Conf == null ) replicator Conf Dir = new  File ( locate Replicator Home Dir ( ) , _ STR ) ; else replicator Conf Dir = new  File ( replicator Conf ) ; if ( ! replicator Conf Dir . is Directory ( ) ) { throw new  Server Runtime Exception ( _ STR + replicator Conf Dir ) ; } } return replicator Conf Dir ; }
public static byte [ ] as Byte Array ( final  List <  Byte > l ) { final byte [ ] a = new byte [ l . size ( ) ] ; for ( int i = _ NUM ; i < a . length ; i ++ ) { a [ i ] = l . get ( i ) ; } return a ; }
public  CNode Menu Builder ( final  JCriterium Tree Node node , final  CCriterium Tree ctree , final  List <  ICriterium Creator > criteria ) { m_criterium Node = node ; final  CCriterium Tree Node clicked Criterium =  CCriterium Functions . find Node ( ctree . get Root ( ) , node . get Criterium ( ) ) ; m_append And = new  JMenu Item ( new  CAppend And Operator Action ( ctree , clicked Criterium ) ) ; m_append Or = new  JMenu Item ( new  CAppend Or Operator Action ( ctree , clicked Criterium ) ) ; m_append Not = new  JMenu Item ( new  CAppend Not Operator Action ( ctree , clicked Criterium ) ) ; m_popup . add ( m_append And ) ; m_popup . add ( m_append Or ) ; m_popup . add ( m_append Not ) ; m_popup . add ( new  JSeparator ( ) ) ; m_insert And = new  JMenu Item ( new  CInsert And Operator Action ( ctree , clicked Criterium ) ) ; m_insert Or = new  JMenu Item ( new  CInsert Or Operator Action ( ctree , clicked Criterium ) ) ; m_insert Not = new  JMenu Item ( new  CInsert Not Operator Action ( ctree , clicked Criterium ) ) ; m_popup . add ( m_insert And ) ; m_popup . add ( m_insert Or ) ; m_popup . add ( m_insert Not ) ; m_popup . add ( new  JSeparator ( ) ) ; m_condition Submenu = new  JMenu ( _ STR ) ; for ( final  ICriterium Creator condition : criteria ) { m_condition Submenu . add ( new  JMenu Item ( new  CAdd Condition Action ( ctree , clicked Criterium , condition ) ) ) ; } m_popup . add ( m_condition Submenu ) ; m_popup . add ( new  JSeparator ( ) ) ; m_remove = new  JMenu Item ( new  CRemove Action ( ctree , clicked Criterium ) ) ; m_popup . add ( m_remove ) ; m_popup . add ( new  JSeparator ( ) ) ; m_remove All = new  JMenu Item ( new  CRemove All Action ( ctree ) ) ; m_popup . add ( m_remove All ) ; }
public void test Store Failure ( ) throws  Exception { delegate . set Should Fail ( _ BOOL ) ; init Store ( _ NUM ) ;  Set <  Integer > exp ; try { exp = run Put Get Remove Multithreaded ( _ NUM , _ NUM ) ;  U . sleep (  FLUSH_ FREQUENCY ) ; info ( _ STR + store . get Write Behind Error Retry Count ( ) + _ STR ) ; delegate . set Should Fail ( _ BOOL ) ;  U . sleep ( _ NUM ) ; } finally { shutdown Store ( ) ; }  Map <  Integer ,  String > map = delegate . get Map ( ) ;  Collection <  Integer > extra = new  Hash Set < > ( map . key Set ( ) ) ; extra . remove All ( exp ) ; assert True ( _ STR + extra , extra . is Empty ( ) ) ;  Collection <  Integer > missing = new  Hash Set < > ( exp ) ; missing . remove All ( map . key Set ( ) ) ; assert True ( _ STR + missing , missing . is Empty ( ) ) ; for (  Integer key : exp ) assert Equals ( _ STR + key , _ STR + key , map . get ( key ) ) ; }
static  String list To Comma Delimited String (  List <  String > list ) {  String Builder result = new  String Builder ( ) ; for (  String str : list ) { if ( result . length ( ) > _ NUM ) { result . append ( _ STR ) ; } result . append ( str ) ; } return result . to String ( ) ; }
public void remove Notification Listener (  Notification Listener listener ) throws  Listener Not Found Exception { broadcaster . remove Notification Listener ( listener ) ; }
public int compare (  File file1 ,  File file2 ) { long size1 = _ NUM ; if ( file1 . is Directory ( ) ) { size1 = sum Directory Contents && file1 . exists ( ) ?  File Utils . size Of Directory ( file1 ) : _ NUM ; } else { size1 = file1 . length ( ) ; } long size2 = _ NUM ; if ( file2 . is Directory ( ) ) { size2 = sum Directory Contents && file2 . exists ( ) ?  File Utils . size Of Directory ( file2 ) : _ NUM ; } else { size2 = file2 . length ( ) ; } long result = size1 - size2 ; if ( result < _ NUM ) { return - _ NUM ; } else if ( result > _ NUM ) { return _ NUM ; } else { return _ NUM ; } }
private static void d_ucummxx ( double [ ] a , double [ ] agg , double [ ] c , int m , int n , double init ,  Builtin builtin , int rl , int ru ) { double [ ] cmxx = ( agg != null ) ? agg : new double [ n ] ; if ( agg == null )  Arrays . fill ( cmxx , init ) ; for ( int i = rl , aix = rl * n ; i < ru ; i ++ , aix += n ) { builtin Agg ( a , cmxx , aix , n , builtin ) ;  System . arraycopy ( cmxx , _ NUM , c , aix , n ) ; } }
public static  List <  String > expand Wildcards (  File dir ,  List <  String > modules ,  Backend for Backend ) {  List <  File > dirs = new  Array List <  File > ( ) ; dirs . add ( dir ) ; return expand Wildcards ( dirs , modules , for Backend ) ; }
private void $$$setup UI$$$ ( ) { my Content Panel = new  JPanel ( ) ; my Content Panel . set Layout ( new  Grid Layout Manager ( _ NUM , _ NUM , new  Insets ( _ NUM , _ NUM , _ NUM , _ NUM ) , - _ NUM , - _ NUM ) ) ; final  JPanel panel1 = new  JPanel ( ) ; panel1 . set Layout ( new  Grid Layout Manager ( _ NUM , _ NUM , new  Insets ( _ NUM , _ NUM , _ NUM , _ NUM ) , - _ NUM , - _ NUM ) ) ; my Content Panel . add ( panel1 , new  Grid Constraints ( _ NUM , _ NUM , _ NUM , _ NUM ,  Grid Constraints .  ANCHOR_ CENTER ,  Grid Constraints .  FILL_ BOTH ,  Grid Constraints .  SIZEPOLICY_ CAN_ SHRINK |  Grid Constraints .  SIZEPOLICY_ CAN_ GROW ,  Grid Constraints .  SIZEPOLICY_ CAN_ SHRINK |  Grid Constraints .  SIZEPOLICY_ CAN_ GROW , null , null , null , _ NUM , _ BOOL ) ) ; my Accept Yours Button = new  JButton ( ) ; my Accept Yours Button . set Enabled ( _ BOOL ) ; my Accept Yours Button . set Text ( _ STR ) ; my Accept Yours Button . set Mnemonic ( _ STR ) ; my Accept Yours Button . set Displayed Mnemonic Index ( _ NUM ) ; panel1 . add ( my Accept Yours Button , new  Grid Constraints ( _ NUM , _ NUM , _ NUM , _ NUM ,  Grid Constraints .  ANCHOR_ CENTER ,  Grid Constraints .  FILL_ HORIZONTAL ,  Grid Constraints .  SIZEPOLICY_ CAN_ SHRINK |  Grid Constraints .  SIZEPOLICY_ CAN_ GROW ,  Grid Constraints .  SIZEPOLICY_ FIXED , null , null , null , _ NUM , _ BOOL ) ) ; final  Spacer spacer1 = new  Spacer ( ) ; panel1 . add ( spacer1 , new  Grid Constraints ( _ NUM , _ NUM , _ NUM , _ NUM ,  Grid Constraints .  ANCHOR_ CENTER ,  Grid Constraints .  FILL_ VERTICAL , _ NUM ,  Grid Constraints .  SIZEPOLICY_ WANT_ GROW , null , null , null , _ NUM , _ BOOL ) ) ; my Accept Theirs Button = new  JButton ( ) ; my Accept Theirs Button . set Enabled ( _ BOOL ) ; my Accept Theirs Button . set Text ( _ STR ) ; my Accept Theirs Button . set Mnemonic ( _ STR ) ; my Accept Theirs Button . set Displayed Mnemonic Index ( _ NUM ) ; panel1 . add ( my Accept Theirs Button , new  Grid Constraints ( _ NUM , _ NUM , _ NUM , _ NUM ,  Grid Constraints .  ANCHOR_ CENTER ,  Grid Constraints .  FILL_ HORIZONTAL ,  Grid Constraints .  SIZEPOLICY_ CAN_ SHRINK |  Grid Constraints .  SIZEPOLICY_ CAN_ GROW ,  Grid Constraints .  SIZEPOLICY_ FIXED , null , null , null , _ NUM , _ BOOL ) ) ; my Merge Button = new  JButton ( ) ; my Merge Button . set Enabled ( _ BOOL ) ; my Merge Button . set Text ( _ STR ) ; my Merge Button . set Mnemonic ( _ STR ) ; my Merge Button . set Displayed Mnemonic Index ( _ NUM ) ; panel1 . add ( my Merge Button , new  Grid Constraints ( _ NUM , _ NUM , _ NUM , _ NUM ,  Grid Constraints .  ANCHOR_ CENTER ,  Grid Constraints .  FILL_ HORIZONTAL ,  Grid Constraints .  SIZEPOLICY_ CAN_ SHRINK |  Grid Constraints .  SIZEPOLICY_ CAN_ GROW ,  Grid Constraints .  SIZEPOLICY_ FIXED , null , null , null , _ NUM , _ BOOL ) ) ; final  JBScroll Pane j BScroll Pane1 = new  JBScroll Pane ( ) ; my Content Panel . add ( j BScroll Pane1 , new  Grid Constraints ( _ NUM , _ NUM , _ NUM , _ NUM ,  Grid Constraints .  ANCHOR_ CENTER ,  Grid Constraints .  FILL_ BOTH ,  Grid Constraints .  SIZEPOLICY_ CAN_ SHRINK |  Grid Constraints .  SIZEPOLICY_ WANT_ GROW ,  Grid Constraints .  SIZEPOLICY_ CAN_ SHRINK |  Grid Constraints .  SIZEPOLICY_ WANT_ GROW , null , null , null , _ NUM , _ BOOL ) ) ; my Items Table = new  JBTable ( ) ; my Items Table . put Client Property ( _ STR ,  Boolean .  FALSE ) ; j BScroll Pane1 . set Viewport View ( my Items Table ) ; }
public void test Run All Activities ( ) throws  Exception { final  Set <  Process Error > err Set = new  Linked Hash Set <  Process Error > ( ) ; for (  Resolve Info app : get Launcher Activities ( m Package Manager ) ) { final  Collection <  Process Error > err Procs = run One Activity ( app ) ; if ( err Procs != null ) { err Set . add All ( err Procs ) ; } } if ( ! err Set . is Empty ( ) ) { fail (  String . format ( _ STR , err Set . size ( ) , report Wrapped List Contents ( err Set ) ) ) ; } }
public  Known Arguments Info ( @  Not Null final  Collection <  Argument > arguments , final int min Arguments , final int max Arguments ) {  Preconditions . check Argument ( ! arguments . is Empty ( ) , _ STR ) ; my Arguments . add All ( arguments ) ; my Min Arguments = min Arguments ; my Max Arguments = max Arguments ; }
public void update (  CSTState state ) { new Checkpoint ( state . get Serialized State ( ) , state . get State Hash ( ) , state . get Checkpoint CID ( ) ) ; set Last Checkpoint CID ( state . get Checkpoint CID ( ) ) ; }
@  Override public  Connection Pool Data Source create Connection Pool Data Source (  Properties properties ) throws  SQLException {  Properties properties Copy = new  Properties ( ) ; if ( properties != null ) { properties Copy . put All ( properties ) ; } reject Unsupported Options ( properties Copy ) ; reject Pooling Options ( properties Copy ) ;  Jdbc Data Source data Source = new  Jdbc Data Source ( ) ; setup H2 Data Source ( data Source , properties Copy ) ; return data Source ; }
public static double to Radians ( double x ) { if (  Double . is Infinite ( x ) || x == _ NUM ) { return x ; } final double facta = _ NUM ; final double factb = _ NUM ; double xa = double High Part ( x ) ; double xb = x - xa ; double result = xb * factb + xb * facta + xa * factb + xa * facta ; if ( result == _ NUM ) { result *= x ; } return result ; }
public void test_ Big Decimal0 ( ) { final  Big Decimal [ ] a = new  Big Decimal [ ] { new  Big Decimal ( _ STR ) , new  Big Decimal ( _ STR ) , new  Big Decimal ( _ STR ) , new  Big Decimal ( _ STR ) , new  Big Decimal ( _ STR ) , new  Big Decimal ( _ STR ) , new  Big Decimal ( _ STR ) } ; for (  Big Decimal i : a ) { i = i . strip Trailing Zeros ( ) ; if ( log . is Info Enabled ( ) ) log . info ( _ STR + i + _ STR + i . scale ( ) + _ STR + i . precision ( ) + _ STR + dump Big Decimal ( i ) ) ; } for (  Big Decimal i : a ) { do Encode Decode Test ( i ) ; } for ( int i = _ NUM ; i < a . length ; i ++ ) { for ( int j = _ NUM ; j < a . length ; j ++ ) { do Compare Test ( a [ i ] , a [ j ] ,  Compare Enum .  EQ ) ; } } }
protected int num Specifiers ( ) { return m_ Specifiers . size ( ) ; }
public static void format Line (  String format ,  Object ... args ) { if ( ! is Disabled ( ) ) { print Line (  String . format ( format , args ) ) ; } }
public void write Tag (  String tag ,  File value ) { write Tag ( tag , value . get Path ( ) ) ; }
public  Builder port ( int port ) { this . port =  Integer . to String ( port ) ; return this ; }
@  Override public  Instances define Data Format ( ) throws  Exception {  Array List <  Attribute > atts ; atts = new  Array List <  Attribute > ( ) ; atts . add ( new  Attribute ( _ STR ) ) ; m_ Raw Data = new  Instances ( get Relation Name To Use ( ) , atts , _ NUM ) ; m_ Filter = new  Add Expression ( ) ; m_ Filter . set Name ( _ STR ) ; m_ Filter . set Expression ( get Expression ( ) ) ; m_ Filter . set Input Format ( m_ Raw Data ) ; return super . define Data Format ( ) ; }
public void paint Circle (  Point2 D pt1 ,  Point2 D pt2 ) { if ( display Circle ) { if ( pt1 != null && pt2 != null ) { double radphi1 =  Proj Math . deg To Rad ( pt1 . get Y ( ) ) ; double radlambda0 =  Proj Math . deg To Rad ( pt1 . get X ( ) ) ; double radphi =  Proj Math . deg To Rad ( pt2 . get Y ( ) ) ; double radlambda =  Proj Math . deg To Rad ( pt2 . get X ( ) ) ; double d Rad =  Great Circle . spherical Distance ( radphi1 , radlambda0 , radphi , radlambda ) ; double rad =  Proj Math . rad To Deg ( d Rad ) ;  OMCircle circle = new  OMCircle ( pt1 . get Y ( ) , pt1 . get X ( ) , rad ) ;  Projection proj = the Map . get Projection ( ) ; circle . generate ( proj ) ; distance List . add ( circle ) ; } } }
public void enable Cookie ( ) { is Enable Cookie = _ BOOL ; if ( m Cookie Manager == null ) { m Cookie Manager = new  Cookie Manager ( new  Persistent Cookie Store ( m Context ) ,  Cookie Policy .  ACCEPT_ ALL ) ;  Cookie Handler . set Default ( m Cookie Manager ) ; } }
public static  List parse Values (  String file Name ) throws  CLIException {  Buffered Reader in = null ;  List values = new  Array List ( ) ; try { in = new  Buffered Reader ( new  File Reader ( file Name ) ) ;  String line = in . read Line ( ) ; while ( line != null ) { line = line . trim ( ) ; if ( line . length ( ) > _ NUM ) { values . add ( line ) ; } line = in . read Line ( ) ; } } catch (  IOException e ) { throw new  CLIException ( e ,  Exit Codes .  IO_ EXCEPTION ) ; } finally { if ( in != null ) { try { in . close ( ) ; } catch (  IOException e ) { } } } return values ; }
public static  Test suite ( ) { return suite (  Test Mode . triples ) ; }
public static  Element to Element (  Document doc ,  Object o ) throws  Page Exception { if ( o instanceof  Element ) return (  Element ) o ; else if ( o instanceof  Node ) throw new  Expression Exception ( _ STR +  Caster . to Class Name ( o ) + _ STR ) ; return doc . create Element (  Caster . to String ( o ) ) ; }
public  OMRaster ( double lt , double ln ,  Image Icon ii ) { this ( lt , ln , ii . get Image ( ) ) ; }
synchronized void discard Queue ( ) { queue . remove All Elements ( ) ; for (  Enumeration e = running . elements ( ) ; e . has More Elements ( ) ; ) {  Resource Thread t = (  Resource Thread ) e . next Element ( ) ; t . cancel ( ) ; } running . remove All Elements ( ) ; bg Image Comps Selected . remove All Elements ( ) ; bg Image Comps Unselected . remove All Elements ( ) ; bg Image Comps Pressed . remove All Elements ( ) ; thread Count = _ NUM ; css Count = - _ NUM ; started = _ BOOL ; }
@  Override protected void property Change (  Property Change Event evt ) { super . property Change ( evt ) ;  String name = evt . get Property Name ( ) ; if ( name . equals ( _ STR ) ) { update Foreground ( (  Color ) evt . get New Value ( ) ) ; } else if ( name . equals ( _ STR ) ) { update Font ( (  Font ) evt . get New Value ( ) ) ; } else if ( name . equals ( _ STR ) ) {  JComponent comp = get Component ( ) ; update Foreground ( comp . get Foreground ( ) ) ; update Font ( comp . get Font ( ) ) ; } }
public static <  T > int compare (  Comparable <  T > object1 ,  T object2 ) { if ( ( null != object1 ) && ( null != object2 ) ) { return object1 . compare To ( object2 ) ; } else if ( null != object1 ) { return _ NUM ; } else if ( null != object2 ) { return - _ NUM ; } else { return _ NUM ; } }
private static  String format SQL (  String sql ) { if ( ! sql . ends With ( _ STR ) ) sql += _ STR ; return sql ; }
public void change View Position (  View child , int new Index ) { int current Index = index Of Child ( child ) ; if ( child != null && child . get Parent ( ) == this && current Index != new Index ) { m Change Position In Progress = _ BOOL ; remove View ( child ) ; add View ( child , new Index ) ; m Change Position In Progress = _ BOOL ; if ( m Is Expanded && m Animations Enabled && child . get Visibility ( ) !=  View .  GONE ) { m Children Changing Positions . add ( child ) ; m Needs Animation = _ BOOL ; } } }
public void compile Projects (  List <  File > projects ) throws  N4 JSCompile Exception { compile Projects (  Arrays . as List ( new  File ( _ STR ) ) , projects ,  Collections . empty List ( ) , new  Dismissing Issue Acceptor ( ) ) ; }
protected final void print_clearance_violation_info (  Object Info Panel p_window , java . util .  Locale p_locale ) {  Collection <  Brd Item Violation > clearance_violations = clearance_violations ( ) ; if ( clearance_violations . is Empty ( ) ) return ;  Gui Resources resources = r_board . new Gui Resources ( _ STR ) ; p_window . append ( _ STR ) ;  Integer violation_count = clearance_violations . size ( ) ;  Collection <  Printable Info > violations = new java . util .  Linked List <  Printable Info > ( ) ; violations . add All ( clearance_violations ) ; p_window . append_objects ( violation_count . to String ( ) , resources . get String ( _ STR ) , violations ) ; if ( violation_count == _ NUM ) { p_window . append ( _ STR + resources . get String ( _ STR ) ) ; } else { p_window . append ( _ STR + resources . get String ( _ STR ) ) ; } }
@  Suppress Warnings ( _ STR ) public  Promise <  Result ,  Progress > reject (  Exception ex ) {  List <  Fail Callback > fail Callbacks ;  List <  Always Callback > always Callbacks ; synchronized ( this ) { validate In Pending State ( ) ; m State =  STATE_ REJECTED ; print State Changed ( _ STR ) ; m Exception = ex ; fail Callbacks = m Callbacks . clone Fail Callbacks ( ) ; always Callbacks = m Callbacks . clone Always Callbacks ( ) ; clear Callbacks ( ) ; } if ( fail Callbacks . size ( ) > _ NUM || always Callbacks . size ( ) > _ NUM ) { trigger All Fails ( fail Callbacks ) ; trigger All Always ( always Callbacks ) ; } return this ; }
public static  Block Snapshot validate Snapshot (  URI snapshot URI ,  Uri Info uri Info ,  Db Client db Client ) {  Arg Validator . check Uri ( snapshot URI ) ;  Block Snapshot snapshot = db Client . query Object (  Block Snapshot . class , snapshot URI ) ;  Arg Validator . check Entity ( snapshot , snapshot URI ,  Block Service Utils . is Id Embedded In URL ( snapshot URI , uri Info ) , _ BOOL ) ; return snapshot ; }
public  Generator (  Properties props ) { this . props = (  Properties ) props . clone ( ) ; }
public static int len (  String list , char delimiter , boolean ignore Empty ) { int len =  String Util . length ( list ) ; if ( len == _ NUM ) return _ NUM ; int count = _ NUM ; int last = _ NUM ; for ( int i = _ NUM ; i < len ; i ++ ) { if ( list . char At ( i ) == delimiter ) { if ( ! ignore Empty || last < i ) count ++ ; last = i + _ NUM ; } } if ( ! ignore Empty || last < len ) count ++ ; return count ; }
public static void dispose Graphics Config ( long p Config Info ) {  D3 DRender Queue rq = get Instance ( ) ; rq . lock ( ) ; try {  Render Buffer buf = rq . get Buffer ( ) ; rq . ensure Capacity And Alignment ( _ NUM , _ NUM ) ; buf . put Int (  DISPOSE_ CONFIG ) ; buf . put Long ( p Config Info ) ; rq . flush Now ( ) ; } finally { rq . unlock ( ) ; } }
void render Normal ( ) { gl Enable (  GL_ DEPTH_ TEST ) ; gl Use Program ( this . normal Program ) ; gl Uniform Matrix4fv ( view Matrix Uniform , _ BOOL , view Matrix . get ( matrix Buffer ) ) ; gl Uniform Matrix4fv ( proj Matrix Uniform , _ BOOL , proj Matrix . get ( matrix Buffer ) ) ; gl Uniform Matrix3fv ( normal Matrix Uniform , _ BOOL , normal Matrix . get ( matrix Buffer ) ) ; gl Bind Framebuffer EXT (  GL_ FRAMEBUFFER_ EXT , fbo ) ; gl Clear (  GL_ COLOR_ BUFFER_ BIT |  GL_ DEPTH_ BUFFER_ BIT ) ; gl Bind Buffer (  GL_ ARRAY_ BUFFER , this . cube Vbo ) ; gl Enable Vertex Attrib Array ( _ NUM ) ; gl Vertex Attrib Pointer ( _ NUM , _ NUM ,  GL_ FLOAT , _ BOOL , _ NUM , _ NUM ) ; gl Enable Vertex Attrib Array ( _ NUM ) ; gl Vertex Attrib Pointer ( _ NUM , _ NUM ,  GL_ FLOAT , _ BOOL , _ NUM , this . normals Offset ) ; gl Draw Arrays (  GL_ TRIANGLES , _ NUM , this . num Vertices ) ; gl Disable Vertex Attrib Array ( _ NUM ) ; gl Disable Vertex Attrib Array ( _ NUM ) ; gl Bind Buffer (  GL_ ARRAY_ BUFFER , _ NUM ) ; gl Bind Framebuffer EXT (  GL_ FRAMEBUFFER_ EXT , _ NUM ) ; gl Use Program ( _ NUM ) ; }
private <  T extends  CWLResource >  T look For Resource (  CWLResource Type type ,  Class <  T > clazz ) {  List <  T > resources = look For Resources ( type , clazz ) ; return resources != null && resources . size ( ) > _ NUM ? resources . get ( _ NUM ) : null ; }
protected int decrement Thread Count ( ) { return thread Count . decrement And Get ( ) ; }
@  Override public int hash Code ( ) { int result = _ NUM ;  Iterator < ? > it = iterator ( ) ; while ( it . has Next ( ) ) {  Object next = it . next ( ) ; result += next == null ? _ NUM : next . hash Code ( ) ; } return result ; }
protected  Rectangle calculate BBox (  List <  Point > points ) { double min X =  Double .  MAX_ VALUE ; double min Y =  Double .  MAX_ VALUE ; double max X = -  Double .  MAX_ VALUE ; double max Y = -  Double .  MAX_ VALUE ; for (  Point p : points ) { min X =  Math . min ( p . get X ( ) , min X ) ; min Y =  Math . min ( p . get Y ( ) , min Y ) ; max X =  Math . max ( p . get X ( ) , max X ) ; max Y =  Math . max ( p . get Y ( ) , max Y ) ; } return new  Rectangle ( ( float ) min X , ( float ) min Y , ( float ) ( max X - min X ) , ( float ) ( max Y - min Y ) ) ; }
public void read From (  Stream Input in ) throws  IOException { node Id = in . read Optional String ( ) ; state =  State . from Value ( in . read Byte ( ) ) ; reason = in . read Optional String ( ) ; }
public static boolean is Numeric (  String datatype URI ) { return numeric Datatype URIs . contains ( datatype URI ) ; }
String char To String ( char c ) { if ( c < _ STR || c > _ NUM ) { return _ STR + ( int ) c ; } return  String . value Of ( c ) ; }
public void add Foreign Key (  Foreign Key foreign Key ) { if ( foreign Key != null ) { foreign Keys . add ( foreign Key ) ; } }
public static void force Delete On Exit (  File file ) throws  IOException { if ( file . is Directory ( ) ) { delete Directory On Exit ( file ) ; } else { file . delete On Exit ( ) ; } }
public void remove Written ( byte [ ] value ) { write Set Lock . lock ( ) ;  Set <  Timestamp Value Pair > temp = (  Hash Set <  Timestamp Value Pair > ) write Set . clone ( ) ; for (  Timestamp Value Pair rv : temp ) { if (  Arrays . equals ( rv . get Value ( ) , value ) ) write Set . remove ( rv ) ; } write Set Lock . unlock ( ) ; }
@  Override public void load (  Entity unit , boolean check False ) throws  Illegal Argument Exception { if ( ! can Load ( unit ) ) { throw new  Illegal Argument Exception ( _ STR + unit . get Short Name ( ) + _ STR ) ; } if ( unit instanceof  Fighter Squadron ) { fighters . add All ( ( (  Fighter Squadron ) unit ) . fighters ) ; } else { fighters . add Element ( unit . get Id ( ) ) ; } if ( game . get Phase ( ) !=  Phase .  PHASE_ LOUNGE ) { compute Squadron Bomb Loadout ( ) ; } else { update Weapon Groups ( ) ; load All Weapons ( ) ; } update Skills ( ) ; }
public void finish ( ) throws  IOException { if ( ! def . finished ( ) ) { def . finish ( ) ; while ( ! def . finished ( ) ) { int len = def . deflate ( buf , _ NUM , buf . length ) ; if ( def . finished ( ) && len <= buf . length -  TRAILER_ SIZE ) { write Trailer ( buf , len ) ; len = len +  TRAILER_ SIZE ; total Length +=  TRAILER_ SIZE ; out . write ( buf , _ NUM , len ) ; return ; } if ( len > _ NUM ) { out . write ( buf , _ NUM , len ) ; } } byte [ ] trailer = new byte [  TRAILER_ SIZE ] ; write Trailer ( trailer , _ NUM ) ; out . write ( trailer ) ; total Length +=  TRAILER_ SIZE ; } }
public boolean free (  T obj ) { int top = _top . get ( ) ; if ( top < _free Stack . length ( ) ) { boolean is Free = _free Stack . compare And Set ( top , null , obj ) ; _top . compare And Set ( top , top + _ NUM ) ; return is Free ; } else return _ BOOL ; }
private <  T >  Binding Amp <  T > find Binding (  Key <  T > key ) {  Binding Set <  T > set = (  Binding Set ) _binding Set Map . get ( key . raw Class ( ) ) ; if ( set != null ) {  Binding Amp <  T > binding = set . find ( key ) ; if ( binding != null ) { return binding ; } } return null ; }
private void start Replication Service (  Tungsten Properties repl Props ) throws  Replicator Exception {  String service Name = repl Props . get String (  Replicator Conf .  SERVICE_ NAME ) ;  String service Type = repl Props . get String (  Replicator Conf .  SERVICE_ TYPE ) ; boolean is Detached = repl Props . get Boolean (  Replicator Conf .  DETACHED ) ;  Open Replicator Manager MBean orm = null ; try { if ( is Detached ) { throw new  Replicator Exception ( _ STR ) ; } else { orm = create Internal Service ( service Name ) ; } replicators . put ( service Name , orm ) ; orm . start ( repl Props . get Boolean (  Replicator Conf .  FORCE_ OFFLINE ) ) ; int listen Port = orm . get Master Listen Port ( ) ; if ( listen Port > master Listen Port Max ) master Listen Port Max = listen Port ; logger . info (  String . format ( _ STR , ( is Detached ? _ STR : _ STR ) , service Type , service Name ) ) ; } catch (  Exception e ) { logger . error (  String . format ( _ STR , service Name ) , e ) ; } }
public static boolean is Directory (  File dir ) { return dir . exists ( ) && dir . is Directory ( ) ; }
void clear Cached Decisions For Service (  String service Name ) { if ( debug . message Enabled ( ) ) { debug . message ( _ STR + _ STR + _ STR + service Name ) ; } synchronized ( result Cache ) { result Cache . remove ( service Name ) ; } }
@  Override public int last Index Of (  Object o ) { if ( o == null ) { for ( int i = end - _ NUM ; i >= start ; i -- ) { if ( buffer [ i ] == null ) { return i - start ; } } } else { for ( int i = end - _ NUM ; i >= start ; i -- ) { if ( o . equals ( buffer [ i ] ) ) { return i - start ; } } } return - _ NUM ; }
public static void put Short LE ( long addr , short val ) { if (  UNALIGNED )  UNSAFE . put Short ( addr ,  Short . reverse Bytes ( val ) ) ; else put Short By Byte ( addr , val , _ BOOL ) ; }
public static byte [ ] hash ( byte [ ] input , int offset , int length ) {  Message Digest digest = new Digest ( ) ; digest . update ( input , offset , length ) ; return digest . digest ( ) ; }
public void scan Class (  Input Stream bits ) throws  IOException {  Data Input Stream dstream = new  Data Input Stream ( new  Buffered Input Stream ( bits ) ) ;  Class File cf = null ; try { cf = new  Class File ( dstream ) ; class Index . put ( cf . get Name ( ) , new  Hash Set <  String > ( ) ) ; scan Class ( cf ) ; if ( scan Method Annotations || scan Parameter Annotations ) { scan Methods ( cf ) ; } if ( scan Field Annotations ) { scan Fields ( cf ) ; } if ( cf . get Interfaces ( ) != null ) {  Set <  String > intfs = new  Hash Set <  String > ( ) ; for (  String intf : cf . get Interfaces ( ) ) { intfs . add ( intf ) ; } implements Index . put ( cf . get Name ( ) , intfs ) ; } } finally { dstream . close ( ) ; bits . close ( ) ; } }
private char [ ] apply Float Padding ( char [ ] ca4 , boolean no Digits ) { char [ ] ca5 = ca4 ; if ( field Width Set ) { int i , j , n Blanks ; if ( left Justify ) { n Blanks = field Width - ca4 . length ; if ( n Blanks > _ NUM ) { ca5 = new char [ ca4 . length + n Blanks ] ; for ( i = _ NUM ; i < ca4 . length ; i ++ ) ca5 [ i ] = ca4 [ i ] ; for ( j = _ NUM ; j < n Blanks ; j ++ , i ++ ) ca5 [ i ] = _ STR ; } } else if ( ! leading Zeros || no Digits ) { n Blanks = field Width - ca4 . length ; if ( n Blanks > _ NUM ) { ca5 = new char [ ca4 . length + n Blanks ] ; for ( i = _ NUM ; i < n Blanks ; i ++ ) ca5 [ i ] = _ STR ; for ( j = _ NUM ; j < ca4 . length ; i ++ , j ++ ) ca5 [ i ] = ca4 [ j ] ; } } else if ( leading Zeros ) { n Blanks = field Width - ca4 . length ; if ( n Blanks > _ NUM ) { ca5 = new char [ ca4 . length + n Blanks ] ; i = _ NUM ; j = _ NUM ; if ( ca4 [ _ NUM ] == _ STR ) { ca5 [ _ NUM ] = _ STR ; i ++ ; j ++ ; } for ( int k = _ NUM ; k < n Blanks ; i ++ , k ++ ) ca5 [ i ] = _ STR ; for ( ; j < ca4 . length ; i ++ , j ++ ) ca5 [ i ] = ca4 [ j ] ; } } } return ca5 ; }
public void make Immutable ( ) { mutable = _ BOOL ; if ( authn Context Class Ref != null ) { authn Context Class Ref =  Collections . unmodifiable List ( authn Context Class Ref ) ; } if ( authn Context Decl Ref != null ) { authn Context Decl Ref =  Collections . unmodifiable List ( authn Context Decl Ref ) ; } return ; }
public  Builder add Generator Loader (  Generator Loader g Loader ) { if ( loaders == null ) { loaders = new  Array List <  Generator Loader > ( ) ; } if ( g Loader != null ) { loaders . add ( g Loader ) ; } return this ; }
public void add Component Listener ( final  Component Update Listener listener ) { component Listeners . add ( listener ) ; }
public static _ Fields find By Thrift Id ( int field Id ) { switch ( field Id ) { case _ NUM : return  SEQUENCE_ ID ; case _ NUM : return  STATUS ; case _ NUM : return  MESSAGE ; default : return null ; } }
private boolean is Empty (  String text ) { return text == null || text . length ( ) == _ NUM ; }
public void test_metric_heartbeat_uint32 ( ) { final  IGanglia Metadata Message decl = new  Ganglia Metadata Message ( _ STR , _ STR , _ BOOL ,  Ganglia Message Type Enum .  UINT32 , _ STR , _ STR ,  Ganglia Slope Enum . unspecified , _ NUM , _ NUM ,  Abstract Metrics . get Map (  IGanglia Attributes .  GROUP_ CORE , _ STR , _ STR ) ) ; assert Encode Decode ( null , decl ) ; final  IGanglia Metric Message expected = new  Ganglia Metric Message (  Ganglia Message Type Enum .  UINT32 , _ STR , _ STR , _ BOOL , _ STR ,  Long . value Of ( _ NUM ) ) ; final byte [ ] actual Data = assert Encode Decode ( decl , expected ) ; final byte [ ] expected Data = new byte [ ] { _ NUM , _ NUM , _ NUM , - _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , - _ NUM } ; if ( !  Arrays . equals ( expected Data , actual Data ) ) { fail ( _ STR +  Arrays . to String ( expected Data ) + _ STR +  Arrays . to String ( actual Data ) ) ; } }
protected boolean is Relevant (  String term ) { return term . length ( ) >= _ NUM && matches ( character Pattern , term ) ; }
private void send Response (  String status ,  String mime ,  Properties header ,  Input Stream data ) { try { if ( status == null ) throw new  Error ( _ STR ) ;  Output Stream out = my Socket . get Output Stream ( ) ;  Print Writer pw = new  Print Writer ( out ) ; pw . print ( _ STR + status + _ STR ) ; if ( mime != null ) pw . print ( _ STR + mime + _ STR ) ; if ( header == null || header . get Property ( _ STR ) == null ) pw . print ( _ STR + gmt Frmt . format ( new  Date ( ) ) + _ STR ) ; if ( header != null ) {  Enumeration < ? > e = header . keys ( ) ; while ( e . has More Elements ( ) ) {  String key = (  String ) e . next Element ( ) ;  String value = header . get Property ( key ) ; pw . print ( key + _ STR + value + _ STR ) ; } } pw . print ( _ STR ) ; pw . flush ( ) ; if ( data != null ) { int pending = data . available ( ) ; byte [ ] buff = new byte [ the Buffer Size ] ; while ( pending > _ NUM ) { int read = data . read ( buff , _ NUM , ( ( pending > the Buffer Size ) ? the Buffer Size : pending ) ) ; if ( read <= _ NUM ) break ; out . write ( buff , _ NUM , read ) ; pending -= read ; } } out . flush ( ) ; out . close ( ) ; if ( data != null ) data . close ( ) ; } catch (  IOException ioe ) { try { my Socket . close ( ) ; } catch (  Exception t ) { } } }
private static boolean is Access Permitted ( ) { try {  ISSecurity Permission isp = new  ISSecurity Permission ( _ STR , _ STR ) ; if ( security Manager != null ) { security Manager . check Permission ( isp ) ; } return _ BOOL ; } catch (  Security Exception e ) {  Debug debug =  Debug . get Instance ( _ STR ) ; debug . error ( _ STR + _ STR , e ) ; } return _ BOOL ; }
protected void wait For Shutdown Signal ( ) throws  Interrupted Exception { if ( mutex Waiting == null ) { mutex Waiting = new  Object ( ) ; } try { synchronized ( mutex Waiting ) { mutex Waiting . wait ( ) ; } } catch (  Interrupted Exception e ) { if ( ! shutdown ) { throw e ; } } }
public void remove Connection (  Connection connection ) { if ( connection == null ) throw new  Illegal Argument Exception ( _ STR ) ; connection . remove Listener ( invoke Listener ) ; synchronized ( connections Lock ) {  Array List <  Connection > temp = new  Array List (  Arrays . as List ( connections ) ) ; temp . remove ( connection ) ; connections = temp . to Array ( new  Connection [ temp . size ( ) ] ) ; } if (  TRACE ) trace ( _ STR , _ STR + connection ) ; }
private boolean is Redundant (  Coordinate pt ) { if ( pt List . size ( ) < _ NUM ) return _ BOOL ;  Coordinate last Pt = (  Coordinate ) pt List . get ( pt List . size ( ) - _ NUM ) ; double pt Dist = pt . distance ( last Pt ) ; if ( pt Dist < minimim Vertex Distance ) return _ BOOL ; return _ BOOL ; }
String display Value (  Object value , int trim ) { if ( value == null ) { return _ STR ; } return trim ( value . to String ( ) , trim ) ; }
public static <  T >  Iterable <  T > synchronized Create Iterable (  Collection <  T > collection ) {  Iterable <  T > iterable ; synchronized ( collection ) { iterable = new  Array List <  T > ( collection ) ; } return iterable ; }
private void update State View (  Object state ) {  Platform . run Later ( null ) ; sim Pane Ctrl . wait After Step ( ) ; }
public int port ( ) { return address . get Port ( ) ; }
@  Override public void evict All ( ) {  File [ ] files = cache Directory . list Files ( ) ; if ( null != files ) { for (  File file : files ) { if ( file != null ) file . delete ( ) ; } } }
public  Audio Module (  Dialogue System system ) { this . system = system ; }
private static  List <  Result > query Recent Locations (  Content Resolver resolver ,  String input ,  Context context ) {  String filter = input == null ? _ STR : input + _ STR ; if ( filter . is Empty ( ) ) { return null ; } if (  Build .  VERSION .  SDK_ INT >= _ NUM &&  Context Compat . check Self Permission ( context ,  Manifest . permission .  READ_ CALENDAR ) !=  Package Manager .  PERMISSION_ GRANTED ) {  Log . d (  TAG , _ STR ) ; return null ; }  Cursor c = resolver . query (  Events .  CONTENT_ URI ,  EVENT_ PROJECTION ,  LOCATION_ WHERE , new  String [ ] { _ STR , filter } ,  Events . _ ID + _ STR ) ; try {  List <  Result > recent Locations = null ; if ( c != null ) { recent Locations = process Locations Query Results ( c ) ; } return recent Locations ; } finally { if ( c != null ) { c . close ( ) ; } } }
@  Override default  Completable Future <  Optional Double > max Double ( final  To Double Function < ? super  T > fn ) { return  Completable Future . supply Async ( null , get Exec ( ) ) ; }
private boolean to Next State (  Lifecycle State new State ) {  Lifecycle State state ; synchronized ( this ) { state = _state ; if ( new State . ordinal ( ) <= state . ordinal ( ) ) { return _ BOOL ; } _state = new State ; _last Change Time =  Current Time . current Time ( ) ; } if ( _log != null && _log . is Loggable ( _low Level ) ) { _log . log ( _low Level , new State + _ STR + _name ) ; } notify Listeners ( state , new State ) ; return _ BOOL ; }
public boolean init ( ) { if (  MODE ==  MODE_ HORIZONTAL ) { center Panel . set Layout ( new  ALayout ( ) ) ; } if (  MODE ==  MODE_ VERTICAL ) { gbc . anchor =  Grid Bag Constraints .  NORTHWEST ; gbc . weightx = _ NUM ; gbc . weighty = _ NUM ; gbc . gridy = m_line ++ ; gbc . gridx = _ NUM ; gbc . gridwidth = _ NUM ; gbc . insets = null Inset ; gbc . fill =  Grid Bag Constraints .  HORIZONTAL ; center Panel . add (  Box . create Vertical Strut ( _ NUM ) , gbc ) ; } log . config ( _ STR ) ;  MClient client =  MClient . get (  Env . get Ctx ( ) ) ;  String  ASPFilter = _ STR ; if ( client . is Use ASP ( ) )  ASPFilter = _ STR + _ STR + _ STR + _ STR + _ STR + client . get AD_ Client_ ID ( ) + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + client . get AD_ Client_ ID ( ) + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + client . get AD_ Client_ ID ( ) + _ STR + _ STR + _ STR + _ STR + _ STR ;  String sql = null ; if (  Env . is Base Language (  Env . get Ctx ( ) , _ STR ) ) sql = _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR +  ASPFilter + _ STR ; else sql = _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR +  Env . get AD_ Language (  Env . get Ctx ( ) ) + _ STR + _ STR +  ASPFilter + _ STR ; int cols = _ NUM ; int col = _ NUM ; int row = _ NUM ; boolean has Fields = _ BOOL ;  Prepared Statement pstmt = null ;  Result Set rs = null ; try { pstmt =  DB . prepare Statement ( sql , null ) ; pstmt . set Int ( _ NUM , m_process Info . get AD_ Process_ ID ( ) ) ; rs = pstmt . execute Query ( ) ; while ( rs . next ( ) ) { has Fields = _ BOOL ; if (  MODE ==  MODE_ HORIZONTAL ) { create Field ( rs , row , cols ) ; cols = cols + col ; if ( cols >= _ NUM ) { cols = _ NUM ; row ++ ; } } if (  MODE ==  MODE_ VERTICAL ) { create Field ( rs ) ; } } } catch (  SQLException e ) { throw new  DBException ( e , sql ) ; } finally {  DB . close ( rs , pstmt ) ; rs = null ; pstmt = null ; } if ( m_m Fields . size ( ) != m_m Fields2 . size ( ) || m_m Fields . size ( ) != m_v Editors . size ( ) || m_m Fields2 . size ( ) != m_v Editors2 . size ( ) ) log . log (  Level .  SEVERE , _ STR ) ; if ( has Fields ) { if (  MODE ==  MODE_ VERTICAL ) { gbc . gridy = m_line ++ ; center Panel . add (  Box . create Vertical Strut ( _ NUM ) , gbc ) ; gbc . gridx = _ NUM ; center Panel . add (  Box . create Horizontal Strut ( _ NUM ) , gbc ) ; } dynamic Display ( ) ; } else dispose ( ) ; return has Fields ; }
@  Override protected  String date To String (  Date Time Data date ) {  String Buffer message = new  String Buffer ( _ NUM ) ; message . append ( _ STR ) ; message . append ( _ STR ) ; append ( message , date . month , _ NUM ) ; message . append ( _ STR ) ; append ( message , date . day , _ NUM ) ; append ( message , ( char ) date . utc , _ NUM ) ; return message . to String ( ) ; }
private  Instance update Decision List (  Random random ,  Instance example ) throws  Exception {  Array List <  Test >  Test List ;  Instances format = get Dataset Format ( ) ; if ( format == null ) { throw new  Exception ( _ STR ) ; }  Test List = generate Test List ( random , example ) ; int max Size = get Max Rule Size ( ) <  Test List . size ( ) ? get Max Rule Size ( ) :  Test List . size ( ) ; int rule Size = ( ( int ) ( random . next Double ( ) * ( max Size - get Min Rule Size ( ) ) ) ) + get Min Rule Size ( ) ;  Rule List new Rule = new  Rule List ( ) ; for ( int i = _ NUM ; i < rule Size ; i ++ ) { int test Index = ( int ) ( random . next Double ( ) *  Test List . size ( ) ) ;  Test test =  Test List . get ( test Index ) ; new Rule . add Test ( test ) ;  Test List . remove ( test Index ) ; } double new Class Value = _ NUM ; if ( m_ Decision List . size ( ) > _ NUM ) {  Rule List r = ( m_ Decision List . get ( m_ Decision List . size ( ) - _ NUM ) ) ; double old Class Value = ( r . get Class Value ( ) ) ; new Class Value = ( double ) ( ( int ) old Class Value + _ NUM ) % get Num Classes ( ) ; } new Rule . set Class Value ( new Class Value ) ; m_ Decision List . add ( new Rule ) ; example = (  Instance ) example . copy ( ) ; example . set Dataset ( format ) ; example . set Class Value ( new Class Value ) ; return example ; }
public static double next Random ( double k , double theta ,  Random random ) { final double q1 = _ NUM , q2 = _ NUM , q3 = _ NUM ; final double q4 = _ NUM , q5 = - _ NUM , q6 = _ NUM ; final double q7 = _ NUM , q8 = - _ NUM , q9 = _ NUM ; final double a1 = _ NUM , a2 = - _ NUM , a3 = _ NUM ; final double a4 = - _ NUM , a5 = _ NUM , a6 = - _ NUM ; final double a7 = _ NUM , a8 = - _ NUM , a9 = _ NUM ; final double e1 = _ NUM , e2 = _ NUM , e3 = _ NUM ; final double e4 = _ NUM , e5 = _ NUM , e6 = _ NUM ; final double e7 = _ NUM ; if ( k < _ NUM ) { final double b = _ NUM + _ NUM * k ; while ( _ BOOL ) { final double p = b * random . next Double ( ) ; if ( p <= _ NUM ) { final double gds =  Math . exp (  Math . log ( p ) / k ) ; if (  Math . log ( random . next Double ( ) ) <= - gds ) { return ( gds / theta ) ; } } else { final double gds = -  Math . log ( ( b - p ) / k ) ; if (  Math . log ( random . next Double ( ) ) <= ( ( k - _ NUM ) *  Math . log ( gds ) ) ) { return ( gds / theta ) ; } } } } else { final double ss , s , d ; if ( k != - _ NUM ) { ss = k - _ NUM ; s =  Math . sqrt ( ss ) ; d = _ NUM - _ NUM * s ; } else { ss = _ NUM ; s = _ NUM ; d = _ NUM ; } final double v1 , v12 ; { double tv1 , tv2 , tv12 ; do { tv1 = _ NUM * random . next Double ( ) - _ NUM ; tv2 = _ NUM * random . next Double ( ) - _ NUM ; tv12 = tv1 * tv1 + tv2 * tv2 ; } while ( tv12 > _ NUM ) ; v1 = tv1 ; v12 = tv12 ; } final double b , c , si , q0 ; { final double t = v1 *  Math . sqrt ( - _ NUM *  Math . log ( v12 ) / v12 ) ; final double x = s + _ NUM * t ; final double gds = x * x ; if ( t >= _ NUM ) { return ( gds / theta ) ; } final double un = random . next Double ( ) ; if ( d * un <= t * t * t ) { return ( gds / theta ) ; } if ( k != - _ NUM ) { final double r = _ NUM / k ; q0 = ( ( ( ( ( ( ( ( q9 * r + q8 ) * r + q7 ) * r + q6 ) * r + q5 ) * r + q4 ) * r + q3 ) * r + q2 ) * r + q1 ) * r ; if ( k > _ NUM ) { if ( k > _ NUM ) { b = _ NUM ; si = _ NUM ; c = _ NUM / s ; } else { b = _ NUM + _ NUM * ss ; si = _ NUM / s + _ NUM ; c = _ NUM / s + _ NUM ; } } else { b = _ NUM + s - _ NUM * ss ; si = _ NUM ; c = _ NUM / s - _ NUM + _ NUM * s ; } } else { b = _ NUM ; c = _ NUM ; si = _ NUM ; q0 = _ NUM ; } if ( x > _ NUM ) { final double v = t / ( s + s ) ; final double q ; if (  Math . abs ( v ) > _ NUM ) { q = q0 - s * t + _ NUM * t * t + ( ss + ss ) *  Math . log ( _ NUM + v ) ; } else { q = q0 + _ NUM * t * t * ( ( ( ( ( ( ( ( a9 * v + a8 ) * v + a7 ) * v + a6 ) * v + a5 ) * v + a4 ) * v + a3 ) * v + a2 ) * v + a1 ) * v ; } if (  Math . log ( _ NUM - un ) <= q ) { return ( gds / theta ) ; } } } while ( _ BOOL ) { double e , u , sign_u , t ; do { e = -  Math . log ( random . next Double ( ) ) ; u = random . next Double ( ) ; u = u + u - _ NUM ; sign_u = ( u > _ NUM ) ? _ NUM : - _ NUM ; t = b + ( e * si ) * sign_u ; } while ( t <= - _ NUM ) ; final double v = t / ( s + s ) ; final double q ; if (  Math . abs ( v ) > _ NUM ) { q = q0 - s * t + _ NUM * t * t + ( ss + ss ) *  Math . log ( _ NUM + v ) ; } else { q = q0 + _ NUM * t * t * ( ( ( ( ( ( ( ( a9 * v + a8 ) * v + a7 ) * v + a6 ) * v + a5 ) * v + a4 ) * v + a3 ) * v + a2 ) * v + a1 ) * v ; } if ( q <= _ NUM ) { continue ; } final double w ; if ( q > _ NUM ) { w =  Math . exp ( q ) - _ NUM ; } else { w = ( ( ( ( ( ( e7 * q + e6 ) * q + e5 ) * q + e4 ) * q + e3 ) * q + e2 ) * q + e1 ) * q ; } if ( c * u * sign_u <= w *  Math . exp ( e - _ NUM * t * t ) ) { final double x = s + _ NUM * t ; return ( x * x / theta ) ; } } } }
public static void swap (  List list , int i , int j ) {  Object tmp = list . get ( i ) ; list . set ( i , list . get ( j ) ) ; list . set ( j , tmp ) ; }
public static  List <  Name Value Pair > to Name Value Pair (  Object parent ,  Map <  String ,  String > map ) {  List <  Name Value Pair > list = new  Array List <  Name Value Pair > ( ) ; for (  String key : map . key Set ( ) ) {  Name Value Pair nvp = new  Name Value Pair ( parent , key , map . get ( key ) ) ; list . add ( nvp ) ; } return list ; }
public static <  T ,  U extends  Auto Closeable >  T with Auto Closeable (  U self , @  Closure Params ( value =  First Param . class )  Closure <  T > action ) throws  Exception { try {  T result = action . call ( self ) ;  Auto Closeable temp = self ; self = null ; temp . close ( ) ; return result ; } finally { close With Warning ( self ) ; } }
private static int parse Or0 (  Matcher m ,  String group ) {  String matched = m . group ( group ) ; if ( matched == null ) { return _ NUM ; } return parse Int ( matched ) ; }
public synchronized void remove Server (  Server Location location ) {  String [ ] groups = (  String [ ] ) server Group Map . remove ( location ) ; if ( groups != null ) { remove From Map ( connection Load Map , groups , location ) ; remove From Map ( queue Load Map , groups , location ) ; } }
public void add Leaf (  String name ,  String path ) {  Named Icon icon =  Named Icon . get Icon By Name ( path ) ; if ( icon == null ) { log . warn ( _ STR + path + _ STR ) ; return ; } int h = icon . get Icon Height ( ) ; for ( int i = _ NUM ; i < _leaves . size ( ) ; i ++ ) {  Catalog Tree Leaf leaf = _leaves . get ( i ) ; if ( h < leaf . get Size ( ) ) { _leaves . add ( i + _ NUM , new  Catalog Tree Leaf ( name , path , h ) ) ; return ; } } _leaves . add ( new  Catalog Tree Leaf ( name , path , h ) ) ; }
public static long plus ( long tstamp , long microseconds ) { long microsmask = ( long )  UMASK ; long newmicros = tstamp & microsmask ; if ( ( newmicros + microseconds ) <=  MAX_ MICROS ) { tstamp += microseconds ; } else { int [ ] pieces = new int [  NUMIDX ] ;  Component Time . unpack Bits ( tstamp , pieces ) ; int year = pieces [  YIDX ] ; int month = pieces [  MIDX ] ; int day = pieces [  DIDX ] ; int hour = pieces [  HIDX ] ; int minute = pieces [  IIDX ] ; int second = pieces [  SIDX ] ; newmicros += microseconds ; int overseconds = ( int ) ( newmicros / _ NUM ) ; newmicros = ( newmicros % _ NUM ) ;  Gregorian Calendar cal = new  Gregorian Calendar ( year , month - _ NUM , day , hour , minute , second ) ; cal . add (  Calendar .  SECOND , overseconds ) ; second = cal . get (  Calendar .  SECOND ) ; minute = cal . get (  Calendar .  MINUTE ) ; hour = cal . get (  Calendar .  HOUR_ OF_ DAY ) ; day = cal . get (  Calendar .  DAY_ OF_ MONTH ) ; month = cal . get (  Calendar .  MONTH ) + _ NUM ; year = cal . get (  Calendar .  YEAR ) ; tstamp = newmicros ; tstamp |= ( ( long ) year ) <<  YPOS ; tstamp |= ( ( long ) month ) <<  MPOS ; tstamp |= ( ( long ) day ) <<  DPOS ; tstamp |= ( ( long ) hour ) <<  HPOS ; tstamp |= ( ( long ) minute ) <<  IPOS ; tstamp |= ( ( long ) second ) <<  SPOS ; } return ( tstamp ) ; }
public  Http Request content Length ( final  String content Length ) { return content Length (  Integer . parse Int ( content Length ) ) ; }
public  VNXe Command Result modify Lun Sync (  Lun Modify Param param ,  String resource Id ) {  String Builder url Bld = new  String Builder (  URL_ RESOURCE ) ; url Bld . append ( resource Id ) ; url Bld . append (  URL_ LUN_ MODIFY_ ACTION ) ; _url = url Bld . to String ( ) ;  VNXe Command Result result = post Request Sync ( param ) ; result . set Success ( _ BOOL ) ; return result ; }
public  String replace (  Char Sequence target ,  Char Sequence replacement ) { if ( target == null ) { throw new  Null Pointer Exception ( _ STR ) ; } if ( replacement == null ) { throw new  Null Pointer Exception ( _ STR ) ; }  String target String = target . to String ( ) ; int match Start = index Of ( target String , _ NUM ) ; if ( match Start == - _ NUM ) { return this ; }  String replacement String = replacement . to String ( ) ; int target Length = target String . length ( ) ; if ( target Length == _ NUM ) { int result Length = count + ( count + _ NUM ) * replacement String . length ( ) ;  String Builder result = new  String Builder ( result Length ) ; result . append ( replacement String ) ; int end = offset + count ; for ( int i = offset ; i != end ; ++ i ) { result . append ( value [ i ] ) ; result . append ( replacement String ) ; } return result . to String ( ) ; }  String Builder result = new  String Builder ( count ) ; int search Start = _ NUM ; do { result . append ( value , offset + search Start , match Start - search Start ) ; result . append ( replacement String ) ; search Start = match Start + target Length ; } while ( ( match Start = index Of ( target String , search Start ) ) != - _ NUM ) ; result . append ( value , offset + search Start , count - search Start ) ; return result . to String ( ) ; }
public void load Concept Data (  String locale ) { synchronized ( s Loading Lock ) { if ( ! locale . equals ( s Loaded Locale ) ) { s Concept Names = new  Hash Map < > ( ) ; try (  Cursor c = m Content Resolver . query (  Concept Names .  CONTENT_ URI , new  String [ ] {  Concept Names .  CONCEPT_ UUID ,  Concept Names .  NAME } ,  Concept Names .  LOCALE + _ STR , new  String [ ] { locale } , null ) ) { while ( c . move To Next ( ) ) { s Concept Names . put ( c . get String ( _ NUM ) , c . get String ( _ NUM ) ) ; } } s Concept Types = new  Hash Map < > ( ) ; try (  Cursor c = m Content Resolver . query (  Concepts .  CONTENT_ URI , new  String [ ] {  Concepts .  UUID ,  Concepts .  CONCEPT_ TYPE } , null , null , null ) ) { while ( c . move To Next ( ) ) { try { s Concept Types . put ( c . get String ( _ NUM ) ,  Concept Type . value Of ( c . get String ( _ NUM ) ) ) ; } catch (  Illegal Argument Exception e ) { } } } s Concept Types . put (  Concept Uuids .  ADMISSION_ DATE_ UUID ,  Concept Type .  DATE ) ; s Loaded Locale = locale ; } } }
public static  Google Analytics initialise Google Analytics (  Context context ,  String tracker Id , final  Exception Parser callback ) { m Analytics =  Google Analytics . get Instance ( context ) ; m Analytics . set Local Dispatch Period ( _ NUM ) ; m Tracker = m Analytics . new Tracker ( tracker Id ) ; m Tracker . enable Exception Reporting ( _ BOOL ) ; m Tracker . enable Auto Activity Tracking ( _ BOOL ) ;  Thread .  Uncaught Exception Handler handler =  Thread . get Default Uncaught Exception Handler ( ) ; if ( handler != null && handler instanceof  Exception Reporter ) {  Exception Reporter exception Reporter = (  Exception Reporter ) handler ; exception Reporter . set Exception Parser ( callback ) ;  Thread . set Default Uncaught Exception Handler ( exception Reporter ) ;  Log . d (  LOG_ TAG , _ STR ) ; } else {  Log . e (  LOG_ TAG , _ STR ) ; } return m Analytics ; }
public void remove Like (  Song song ) { remove Liking Impl ( song ,  PREF_ LIKED_ ENTRIES ) ; }
@  Not Null public  Psi Query siblings ( @  Not Null final  Class < ? extends  Psi Named Element > clazz , @  Not Null final  String name ) { final  List <  Psi Element > result = new  Array List <  Psi Element > ( ) ; for ( final  Psi Element element : my Psi Elements ) { final  Psi Element parent = element . get Parent ( ) ; for ( final  Psi Named Element named Sibling :  Psi Tree Util . find Children Of Type ( parent , clazz ) ) { if ( ( ! named Sibling . equals ( element ) ) && ( name . equals ( named Sibling . get Name ( ) ) ) ) { result . add ( named Sibling ) ; } } } return new  Psi Query ( result . to Array ( new  Psi Element [ result . size ( ) ] ) ) ; }
@  Override public int compare To (  Value o ) { return hash Code ( ) - o . hash Code ( ) ; }
public  Attributed String (  Attributed Character Iterator text , int begin Index , int end Index ,  Attribute [ ] attributes ) { if ( text == null ) { throw new  Null Pointer Exception ( ) ; } int text Begin Index = text . get Begin Index ( ) ; int text End Index = text . get End Index ( ) ; if ( begin Index < text Begin Index || end Index > text End Index || begin Index > end Index ) throw new  Illegal Argument Exception ( _ STR ) ;  String Buffer text Buffer = new  String Buffer ( ) ; text . set Index ( begin Index ) ; for ( char c = text . current ( ) ; text . get Index ( ) < end Index ; c = text . next ( ) ) text Buffer . append ( c ) ; this . text = text Buffer . to String ( ) ; if ( begin Index == end Index ) return ;  Hash Set <  Attribute > keys = new  Hash Set < > ( ) ; if ( attributes == null ) { keys . add All ( text . get All Attribute Keys ( ) ) ; } else { for ( int i = _ NUM ; i < attributes . length ; i ++ ) keys . add ( attributes [ i ] ) ; keys . retain All ( text . get All Attribute Keys ( ) ) ; } if ( keys . is Empty ( ) ) return ;  Iterator <  Attribute > itr = keys . iterator ( ) ; while ( itr . has Next ( ) ) {  Attribute attribute Key = itr . next ( ) ; text . set Index ( text Begin Index ) ; while ( text . get Index ( ) < end Index ) { int start = text . get Run Start ( attribute Key ) ; int limit = text . get Run Limit ( attribute Key ) ;  Object value = text . get Attribute ( attribute Key ) ; if ( value != null ) { if ( value instanceof  Annotation ) { if ( start >= begin Index && limit <= end Index ) { add Attribute ( attribute Key , value , start - begin Index , limit - begin Index ) ; } else { if ( limit > end Index ) break ; } } else { if ( start >= end Index ) break ; if ( limit > begin Index ) { if ( start < begin Index ) start = begin Index ; if ( limit > end Index ) limit = end Index ; if ( start != limit ) { add Attribute ( attribute Key , value , start - begin Index , limit - begin Index ) ; } } } } text . set Index ( limit ) ; } } }
public static double mean ( double [ ] data , int start Index , int end Index ) { double mean = _ NUM ; int total = _ NUM ; start Index =  Math . max ( start Index , _ NUM ) ; start Index =  Math . min ( start Index , data . length - _ NUM ) ; end Index =  Math . max ( end Index , _ NUM ) ; end Index =  Math . min ( end Index , data . length - _ NUM ) ; if ( start Index > end Index ) start Index = end Index ; for ( int i = start Index ; i <= end Index ; i ++ ) { if (  Double . is Na N ( data [ i ] ) ) throw new  Illegal Argument Exception ( _ STR ) ; mean += data [ i ] ; total ++ ; } mean /= total ; return mean ; }
public static void remove Permission Recursive (  Path path ,  Posix File Permission permission ) throws  IOException { change Permissions Recursive ( path ,  Permission Change .  REMOVE ,  Collections . singleton ( permission ) ) ; }
@  Override public void run ( ) { while ( ! stop Hide ) { print ( _ STR ) ; try {  Thread . sleep ( _ NUM ) ; } catch (  Interrupted Exception e ) { } } }
public void test Neg Pos ( ) { byte a Bytes [ ] = { - _ NUM , - _ NUM , - _ NUM , - _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM } ; byte b Bytes [ ] = { _ NUM } ; int a Sign = - _ NUM ; int b Sign = _ NUM ; byte r Bytes [ ] = { - _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , - _ NUM , - _ NUM , - _ NUM , - _ NUM , - _ NUM , - _ NUM , - _ NUM , - _ NUM , - _ NUM , - _ NUM } ;  Big Integer a Number = new  Big Integer ( a Sign , a Bytes ) ;  Big Integer b Number = new  Big Integer ( b Sign , b Bytes ) ;  Big Integer result = a Number . or ( b Number ) ; byte res Bytes [ ] = new byte [ r Bytes . length ] ; res Bytes = result . to Byte Array ( ) ; for ( int i = _ NUM ; i < res Bytes . length ; i ++ ) { assert True ( res Bytes [ i ] == r Bytes [ i ] ) ; } assert Equals ( _ STR , - _ NUM , result . signum ( ) ) ; }
private  Action Button create Toolbar Button (  Action action ) { return new  Action Button ( action , action Manager , presentation Factory . get Presentation ( action ) , manager Provider . get ( ) , toolbar Resources ) ; }
public static boolean contains Back Ref (  String to ) {  Matcher back Ref Matcher = back Ref Pattern . matcher ( to ) ; return back Ref Matcher . find ( ) ; }
public  Attribute Weights ( ) { }
private  String create File Name ( ) {  String file Name = url . get Path ( ) ; if ( file Name . starts With ( _ STR ) ) { file Name = file Name . substring ( _ NUM ) ; } else if ( file Name . starts With ( _ STR ) ) { file Name = file Name . substring ( _ NUM ) ; } return file Name ; }
public static byte [ ] decode (  String s ) { byte [ ] bytes ; try { bytes = s . get Bytes (  PREFERRED_ ENCODING ) ; } catch ( java . io .  Unsupported Encoding Exception uee ) { bytes = s . get Bytes ( ) ; } bytes = decode ( bytes , _ NUM , bytes . length ) ; if ( bytes != null && bytes . length >= _ NUM ) { int head = ( ( int ) bytes [ _ NUM ] & _ NUM ) | ( ( bytes [ _ NUM ] << _ NUM ) & _ NUM ) ; if ( java . util . zip .  GZIPInput Stream .  GZIP_ MAGIC == head ) { java . io .  Byte Array Input Stream bais = null ; java . util . zip .  GZIPInput Stream gzis = null ; java . io .  Byte Array Output Stream baos = null ; byte [ ] buffer = new byte [ _ NUM ] ; int length = _ NUM ; try { baos = new java . io .  Byte Array Output Stream ( ) ; bais = new java . io .  Byte Array Input Stream ( bytes ) ; gzis = new java . util . zip .  GZIPInput Stream ( bais ) ; while ( ( length = gzis . read ( buffer ) ) >= _ NUM ) { baos . write ( buffer , _ NUM , length ) ; } bytes = baos . to Byte Array ( ) ; } catch ( java . io .  IOException e ) { } finally { try { baos . close ( ) ; } catch (  Exception e ) { } try { gzis . close ( ) ; } catch (  Exception e ) { } try { bais . close ( ) ; } catch (  Exception e ) { } } } } return bytes ; }
public static boolean enough Space On Sd Card ( long update Size ) {  String status =  Environment . get External Storage State ( ) ; if ( ! status . equals (  Environment .  MEDIA_ MOUNTED ) ) return _ BOOL ; return ( update Size < get Real Size On Sdcard ( ) ) ; }
public static void append Property (  String property Name ,  String value ) {  String old Value = props . get Property ( property Name ) ; if ( old Value != null && ! old Value . equals ( _ STR ) ) { old Value += _ STR + value ; } else { old Value = value ; } props . set Property ( property Name , old Value ) ; }
public void add Nodes In Doc Order (  Node Iterator iterator ,  XPath Context support ) { if ( ! m_mutable ) throw new  Runtime Exception (  XSLMessages . create XPATHMessage (  XPATHError Resources .  ER_ NODESET_ NOT_ MUTABLE , null ) ) ;  Node node ; while ( null != ( node = iterator . next Node ( ) ) ) { add Node In Doc Order ( node , support ) ; } }
@  Override public  String to String ( ) {  String Builder buffer = new  String Builder ( ) ; to String ( buffer ) ; return buffer . to String ( ) ; }
@  Override public  Trie reduce (  Reduce by ) {  List <  Trie > h = new  Array List < > ( ) ; for (  Trie trie : tries ) h . add ( trie . reduce ( by ) ) ;  Multi Trie m = new  Multi Trie ( forward ) ; m . tries = h ; return m ; }
public void reset (  Dialogue State state ) { record State ( state ,  CURRENT ) ; list Box . set Selected Index ( _ NUM ) ; while ( list Model . size ( ) > _ NUM ) {  String name = list Model . remove ( _ NUM ) ; states . remove ( name ) ; } visualisation . show Bayesian Network ( state ) ; }
public void write Bytes ( final byte [ ] bytes , final int off , final int len ) { if ( len > remaining ( ) ) { write Bytes Slow ( bytes , off , len ) ; return ; } final  Block block = current ;  System . arraycopy ( bytes , off , block . data , block . limit , len ) ; block . limit += len ; }
private void populate Connection Combo Box ( ) { connection Combo Box . remove All Items ( ) ; if ( geo Server Connection Manager != null ) {  List <  Geo Server Connection > connection List = geo Server Connection Manager . get Connection List ( ) ; for (  Geo Server Connection connection : connection List ) { connection Combo Box . add Item ( connection . get Connection Name ( ) ) ; connection Map . put ( connection . get Connection Name ( ) , connection ) ; } } }
protected  Connection State TLS (  SSLSession Impl session ) { try {  Cipher Suite cipher Suite = session . cipher Suite ; hash_size = cipher Suite . get MACLength ( ) ; boolean is_exportabe = cipher Suite . is Exportable ( ) ; int key_size = ( is_exportabe ) ? cipher Suite . key Material : cipher Suite . expanded Key Material ; int iv_size = cipher Suite . iv Size ; block_size = cipher Suite . get Block Size ( ) ;  String alg Name = cipher Suite . get Bulk Encryption Algorithm ( ) ;  String mac Name = cipher Suite . get Hmac Name ( ) ; if ( logger != null ) { logger . println ( _ STR ) ; logger . println ( _ STR + cipher Suite . get Name ( ) ) ; logger . println ( _ STR + alg Name ) ; logger . println ( _ STR + mac Name ) ; logger . println ( _ STR + hash_size ) ; logger . println ( _ STR + block_size ) ; logger . println ( _ STR + iv_size ) ; logger . println ( _ STR + key_size ) ; } byte [ ] client Random = session . client Random ; byte [ ] server Random = session . server Random ; byte [ ] key_block = new byte [ _ NUM * hash_size + _ NUM * key_size + _ NUM * iv_size ] ; byte [ ] seed = new byte [ client Random . length + server Random . length ] ;  System . arraycopy ( server Random , _ NUM , seed , _ NUM , server Random . length ) ;  System . arraycopy ( client Random , _ NUM , seed , server Random . length , client Random . length ) ;  PRF . compute PRF ( key_block , session . master_secret ,  KEY_ EXPANSION_ LABEL , seed ) ; byte [ ] client_mac_secret = new byte [ hash_size ] ; byte [ ] server_mac_secret = new byte [ hash_size ] ; byte [ ] client_key = new byte [ key_size ] ; byte [ ] server_key = new byte [ key_size ] ; boolean is_client = ! session . is Server ;  System . arraycopy ( key_block , _ NUM , client_mac_secret , _ NUM , hash_size ) ;  System . arraycopy ( key_block , hash_size , server_mac_secret , _ NUM , hash_size ) ;  System . arraycopy ( key_block , _ NUM * hash_size , client_key , _ NUM , key_size ) ;  System . arraycopy ( key_block , _ NUM * hash_size + key_size , server_key , _ NUM , key_size ) ;  Iv Parameter Spec client IV = null ;  Iv Parameter Spec server IV = null ; if ( is_exportabe ) {  System . arraycopy ( client Random , _ NUM , seed , _ NUM , client Random . length ) ;  System . arraycopy ( server Random , _ NUM , seed , client Random . length , server Random . length ) ; byte [ ] final_client_key = new byte [ cipher Suite . expanded Key Material ] ; byte [ ] final_server_key = new byte [ cipher Suite . expanded Key Material ] ;  PRF . compute PRF ( final_client_key , client_key ,  CLIENT_ WRITE_ KEY_ LABEL , seed ) ;  PRF . compute PRF ( final_server_key , server_key ,  SERVER_ WRITE_ KEY_ LABEL , seed ) ; client_key = final_client_key ; server_key = final_server_key ; if ( block_size != _ NUM ) { byte [ ] iv_block = new byte [ _ NUM * iv_size ] ;  PRF . compute PRF ( iv_block , null ,  IV_ BLOCK_ LABEL , seed ) ; client IV = new  Iv Parameter Spec ( iv_block , _ NUM , iv_size ) ; server IV = new  Iv Parameter Spec ( iv_block , iv_size , iv_size ) ; } } else if ( block_size != _ NUM ) { client IV = new  Iv Parameter Spec ( key_block , _ NUM * ( hash_size + key_size ) , iv_size ) ; server IV = new  Iv Parameter Spec ( key_block , _ NUM * ( hash_size + key_size ) + iv_size , iv_size ) ; } if ( logger != null ) { logger . println ( _ STR + is_exportabe ) ; logger . println ( _ STR ) ; logger . print ( session . master_secret ) ; logger . println ( _ STR ) ; logger . print ( client Random ) ; logger . println ( _ STR ) ; logger . print ( server Random ) ; logger . println ( _ STR ) ; logger . print ( client_mac_secret ) ; logger . println ( _ STR ) ; logger . print ( server_mac_secret ) ; logger . println ( _ STR ) ; logger . print ( client_key ) ; logger . println ( _ STR ) ; logger . print ( server_key ) ; if ( client IV == null ) { logger . println ( _ STR ) ; } else { logger . println ( _ STR ) ; logger . print ( client IV . get IV ( ) ) ; logger . println ( _ STR ) ; logger . print ( server IV . get IV ( ) ) ; } } if ( alg Name == null ) { enc Cipher = new  Null Cipher ( ) ; dec Cipher = new  Null Cipher ( ) ; } else { enc Cipher =  Cipher . get Instance ( alg Name ) ; dec Cipher =  Cipher . get Instance ( alg Name ) ; if ( is_client ) { enc Cipher . init (  Cipher .  ENCRYPT_ MODE , new  Secret Key Spec ( client_key , alg Name ) , client IV ) ; dec Cipher . init (  Cipher .  DECRYPT_ MODE , new  Secret Key Spec ( server_key , alg Name ) , server IV ) ; } else { enc Cipher . init (  Cipher .  ENCRYPT_ MODE , new  Secret Key Spec ( server_key , alg Name ) , server IV ) ; dec Cipher . init (  Cipher .  DECRYPT_ MODE , new  Secret Key Spec ( client_key , alg Name ) , client IV ) ; } } enc Mac =  Mac . get Instance ( mac Name ) ; dec Mac =  Mac . get Instance ( mac Name ) ; if ( is_client ) { enc Mac . init ( new  Secret Key Spec ( client_mac_secret , mac Name ) ) ; dec Mac . init ( new  Secret Key Spec ( server_mac_secret , mac Name ) ) ; } else { enc Mac . init ( new  Secret Key Spec ( server_mac_secret , mac Name ) ) ; dec Mac . init ( new  Secret Key Spec ( client_mac_secret , mac Name ) ) ; } } catch (  Exception e ) { e . print Stack Trace ( ) ; throw new  Alert Exception (  Alert Protocol .  INTERNAL_ ERROR , new  SSLProtocol Exception ( _ STR ) ) ; } }
long cleanup ( long now ) { int in Use Connection Count = _ NUM ; int idle Connection Count = _ NUM ;  Real Connection longest Idle Connection = null ; long longest Idle Duration Ns =  Long .  MIN_ VALUE ; synchronized ( this ) { for (  Iterator <  Real Connection > i = connections . iterator ( ) ; i . has Next ( ) ; ) {  Real Connection connection = i . next ( ) ; if ( prune And Get Allocation Count ( connection , now ) > _ NUM ) { in Use Connection Count ++ ; continue ; } idle Connection Count ++ ; long idle Duration Ns = now - connection . idle At Nanos ; if ( idle Duration Ns > longest Idle Duration Ns ) { longest Idle Duration Ns = idle Duration Ns ; longest Idle Connection = connection ; } } if ( longest Idle Duration Ns >= this . keep Alive Duration Ns || idle Connection Count > this . max Idle Connections ) { connections . remove ( longest Idle Connection ) ; } else if ( idle Connection Count > _ NUM ) { return keep Alive Duration Ns - longest Idle Duration Ns ; } else if ( in Use Connection Count > _ NUM ) { return keep Alive Duration Ns ; } else { return - _ NUM ; } }  Util . close Quietly ( longest Idle Connection . get Socket ( ) ) ; return _ NUM ; }
public synchronized void transition (  State new State ) throws  Illegal State Exception { if ( transitions . contains Entry ( current State , new State ) ) { current State = new State ; } else { throw new  Illegal State Exception (  String . format (  Locale .  US , _ STR , current State , new State ) ) ; } }
static boolean contains (  Object enum Value ,  Object [ ] expected Values ) { for ( final  Object expected : expected Values ) { if ( enum Value . equals ( expected ) ) { return _ BOOL ; } } return _ BOOL ; }
protected void do Random Round Trip Test ( final  IRaba Coder data Coder , final int size , final int capacity ) throws  IOException { assert capacity >= size ; if ( data Coder . is Value Coder ( ) ) { final byte [ ] [ ] data = new byte [ capacity ] [ ] ; for ( int i = _ NUM ; i < size ; i ++ ) { final boolean is Null = r . next Float ( ) < _ NUM ; if ( is Null ) { data [ i ] = null ; } else { data [ i ] = get Random Value ( data Coder ) ; } } final  IRaba raba = new  Read Only Values Raba ( _ NUM , size , capacity , data ) ; do Round Trip Test ( data Coder , raba ) ; } if ( data Coder . is Key Coder ( ) ) { final byte [ ] [ ] data = new byte [ capacity ] [ ] ; final int nominal Inc Range = _ NUM ; long last Key = r . next Long ( ) ; int nactual = _ NUM ; for ( int i = _ NUM ; i < size ; i ++ , nactual ++ ) { data [ i ] =  Test Key Builder . as Sort Key ( last Key ) ; final long remainder =  Long .  MAX_ VALUE - last Key ; if ( remainder == _ NUM ) { break ; } final int inc Range = ( int )  Math . max ( nominal Inc Range ,  Math . min ( nominal Inc Range , remainder ) ) ; final int inc = r . next Int ( inc Range ) + _ NUM ; last Key += inc ; } final  IRaba raba = new  Read Only Keys Raba ( _ NUM , nactual , capacity , data ) ; do Round Trip Test ( data Coder , raba ) ; } }
private boolean is Authorized (  Application User application User ,  String namespace ,  Namespace Permission Enum ... permissions ) { if ( application User != null && application User . get Namespace Authorizations ( ) != null ) { for (  Namespace Authorization current User Authorization : application User . get Namespace Authorizations ( ) ) {  List <  Namespace Permission Enum > current User Namespace Permissions = current User Authorization . get Namespace Permissions ( ) ; if ( current User Namespace Permissions == null ) { current User Namespace Permissions =  Collections . empty List ( ) ; } if (  String Utils . equals Ignore Case ( current User Authorization . get Namespace ( ) , namespace ) && current User Namespace Permissions . contains All (  Arrays . as List ( permissions ) ) ) { return _ BOOL ; } } } return _ BOOL ; }
public boolean is Header ( ) { return is Header ( this . my Header ) ; }
public void draw Text (  String text , int x , int y ,  Paint p ) { m Drawable List . add ( new  CText ( text , x , y , p ) ) ; invalidate ( ) ; }
public boolean is Greater Then Or Equal To (  Percent  Percent ) { assert Defined ( ) ;  Big Decimal this Value = not Null ( this ) ;  Big Decimal parameter = not Null (  Percent ) ; return ( this Value . compare To ( parameter ) >= _ NUM ) ; }
private void adjust Column Widths (  JTable table ) {  Table Column Model model = table . get Column Model ( ) ; for ( int column = _ NUM ; column < table . get Column Count ( ) ; column ++ ) {  Table Column tc = model . get Column ( column ) ; int width = tc . get Width ( ) ; for ( int row = _ NUM ; row < table . get Row Count ( ) ; row ++ ) {  Component comp = table . prepare Renderer ( table . get Cell Renderer ( row , column ) , row , column ) ; width =  Math . max ( width , comp . get Preferred Size ( ) . width ) ; } tc . set Preferred Width ( width ) ; } }
void add Folder (  Folder folder ) throws  Repository Exception { acquire Write Lock ( ) ; try { folders . add ( folder ) ; } finally { release Write Lock ( ) ; } }
public static  Workflow .  Method rollback Create Volumes Method (  URI system URI ,  List <  URI > volume URIs ) { return new  Workflow .  Method ( _ STR , system URI , volume URIs ) ; }
public  Foreground Action (  String nm ,  Color fg ) { super ( nm ) ; this . fg = fg ; }
public static final byte [ ] inflate ( byte [ ] in ) throws  IOException {  Byte Array Output Stream out Stream = new  Byte Array Output Stream (  EXPECTED_ COMPRESSION_ RATIO * in . length ) ;  Inflater Input Stream in Stream = new  Inflater Input Stream ( new  Byte Array Input Stream ( in ) ) ; byte [ ] buf = new byte [  BUF_ SIZE ] ; while ( _ BOOL ) { int size = in Stream . read ( buf ) ; if ( size <= _ NUM ) break ; out Stream . write ( buf , _ NUM , size ) ; } out Stream . close ( ) ; return out Stream . to Byte Array ( ) ; }
static public byte encode Byte ( final int v ) { int i = v ; if ( i < _ NUM ) { i = i - _ NUM ; } else { i = i + _ NUM ; } return ( byte ) ( i & _ NUM ) ; }
public  Server Socket bind ( ) throws  IOException ,  General Security Exception ,  Configuration Exception { if ( use SSL ) {  SSLSocket Factory Generator ssl Factory Generator = new  SSLSocket Factory Generator ( this . keystore Alias , this . security Info ) ;  SSLServer Socket Factory sslserver Socket Factory = ssl Factory Generator . get SSLServer Socket Factory ( ) ; server Socket = (  SSLServer Socket ) sslserver Socket Factory . create Server Socket ( ) ; } else {  Server Socket Channel server Channel =  Server Socket Channel . open ( ) ; server Socket = server Channel . socket ( ) ; } server Socket . set Reuse Address ( _ BOOL ) ; server Socket . bind ( address ) ; server Socket . set So Timeout ( accept Timeout ) ; return server Socket ; }
private int convert Binary Float To Int ( byte [ ] data ) { if ( data == null || data . length != _ NUM ) return _ NUM ; int value ; if ( ( _ NUM & data [ _ NUM ] ) == _ NUM ) { value = ( ( _ NUM & data [ _ NUM ] ) << _ NUM | ( _ NUM & data [ _ NUM ] ) << _ NUM | ( _ NUM & data [ _ NUM ] ) << _ NUM | ( _ NUM & data [ _ NUM ] ) ) ; } else { value = ~ ( ( ( _ NUM & data [ _ NUM ] ) << _ NUM | ( _ NUM & data [ _ NUM ] ) << _ NUM | ( _ NUM & data [ _ NUM ] ) << _ NUM | ( _ NUM & data [ _ NUM ] ) ) ) ; } return value ; }
public void update VVset (  String volume CGName ,  String vol Name , int action Value ) throws  Exception { _log . info ( _ STR ) ;  Client Response client Resp = null ; final  String path =  Message Format . format (  URI_ UPDATE_ CG , volume CGName ) ;  String payload = _ STR + action Value + _ STR + vol Name + _ STR ; _log . info ( _ STR , path , payload ) ; try { client Resp = put ( path , payload ) ; if ( client Resp == null ) { _log . error ( _ STR ) ; throw new  HP3 PARException ( _ STR ) ; } else if ( client Resp . get Status ( ) != _ NUM ) {  String err Resp = get Response Details ( client Resp ) ; throw new  HP3 PARException ( err Resp ) ; } else { _log . info ( _ STR ) ; } } catch (  Exception e ) { throw e ; } finally { if ( client Resp != null ) { client Resp . close ( ) ; } _log . info ( _ STR ) ; } }
private boolean is Valid State (  String key ) { if ( key == null ) { return _ BOOL ; } if ( key . equals ( rbean . get String ( _ STR ) ) || key . equals ( rbean . get String ( _ STR ) ) ) { if ( log . is Debug Enabled ( ) ) { log . debug ( key + _ STR ) ; } return _ BOOL ; } for ( int i = _ NUM ; i < _valid Key . length ; i ++ ) { if ( key . equals ( _valid Key [ i ] ) ) { if ( log . is Debug Enabled ( ) ) { log . debug ( key + _ STR ) ; } return _ BOOL ; } } if ( log . is Debug Enabled ( ) ) { log . debug ( key + _ STR ) ; } return _ BOOL ; }
public boolean is Expired ( final  Date now ) { return ( cookie Expiry Date != null && cookie Expiry Date . get Time ( ) <= now . get Time ( ) ) ; }
public void on Update From Close To Peek ( float percentage ) { if ( ! is Visible ( ) ) return ; m Height Px =  Math . round ( m Default Height Px ) ; }
public void fetch Entries (  Hash Map <  Integer ,  Hash Set > bucket Keys ,  Versioned Object List values ,  Server Connection serv Conn ) throws  IOException { int retry Attempts = calc Retry ( ) ;  Retry Time Keeper retry Time = null ;  Hash Map <  Integer ,  Hash Set > failures = new  Hash Map <  Integer ,  Hash Set > ( bucket Keys ) ;  Hash Map <  Internal Distributed Member ,  Hash Map <  Integer ,  Hash Set > > node To Buckets = new  Hash Map <  Internal Distributed Member ,  Hash Map <  Integer ,  Hash Set > > ( ) ; while ( -- retry Attempts >= _ NUM && ! failures . is Empty ( ) ) { node To Buckets . clear ( ) ; update Node To Bucket Map ( node To Buckets , failures ) ; failures . clear ( ) ;  Hash Map <  Integer ,  Hash Set > local Buckets = node To Buckets . remove ( get My Id ( ) ) ; if ( local Buckets != null && ! local Buckets . is Empty ( ) ) {  Set keys = new  Hash Set ( ) ; for (  Integer id : local Buckets . key Set ( ) ) { keys . add All ( local Buckets . get ( id ) ) ; } if ( ! keys . is Empty ( ) ) {  Base Command . append New Register Interest Response Chunk From Local ( this , values , _ STR , keys , serv Conn ) ; } }  Set <  Integer > failed Set = handle Old Nodes ( node To Buckets , values , serv Conn ) ; if ( ! failed Set . is Empty ( ) ) { for (  Integer b Id : failed Set ) { failures . put ( b Id , bucket Keys . get ( b Id ) ) ; } update Node To Bucket Map ( node To Buckets , failures ) ; failures . clear ( ) ; } fetch Remote Entries ( node To Buckets , failures , values , serv Conn ) ; if ( ! failures . is Empty ( ) ) { if ( retry Time == null ) { retry Time = new  Retry Time Keeper ( this . retry Timeout ) ; } if ( ! wait For Fetch Remote Entries Retry ( retry Time ) ) { break ; } } } if ( ! failures . is Empty ( ) ) { throw new  Internal Gem Fire Exception ( _ STR + failures . size ( ) + _ STR + get Name ( ) + _ STR ) ; } }
public  Generator (  Properties props ) { this . props = (  Properties ) props . clone ( ) ; }
public long next ID ( ) { return id . get And Increment ( ) ; }
private void close Connection (  Http URLConnection connection ) { if ( connection != null ) { connection . disconnect ( ) ; } }
public static  Pair <  String ,  String > parse Title And Date In Brackets (  String title ) { if ( title == null ) return new  Pair < > ( null , null ) ;  Pattern p =  Pattern . compile ( _ STR ,  Pattern .  CASE_ INSENSITIVE ) ;  Matcher m = p . matcher ( title ) ; if ( m . find ( ) ) { return new  Pair < > ( m . group ( _ NUM ) , m . group ( _ NUM ) ) ; } return new  Pair < > ( title , null ) ; }
public static void mark Text (  JText Component pane , int start , int end ,  Simple Marker marker ) { try {  Highlighter hiliter = pane . get Highlighter ( ) ; int sel Start = pane . get Selection Start ( ) ; int sel End = pane . get Selection End ( ) ; if ( sel Start == sel End || end < sel Start || start > sel Start ) { hiliter . add Highlight ( start , end , marker ) ; return ; } if ( sel Start > start && sel Start < end ) { hiliter . add Highlight ( start , sel Start , marker ) ; } if ( sel End > start && sel End < end ) { hiliter . add Highlight ( sel End , end , marker ) ; } } catch (  Bad Location Exception ex ) {  LOG . log (  Level .  SEVERE , null , ex ) ; } }
@  Override public void component Resized (  Component Event e ) { if ( e . get Component ( ) == component ) { double new Ratio = get Current Ratio ( ) ; if (  Math . abs ( new Ratio - active Ratio ) > threshold ) { active Ratio = new Ratio ; execute Resize ( new Ratio ) ; } } }
public void root Modified (  ISVNRepository Location root ) {  Iterator it = listeners . iterator ( ) ; while ( it . has Next ( ) ) {  IRepository Listener listener = (  IRepository Listener ) it . next ( ) ; listener . repository Modified ( root ) ; } }
public void add Buffer (  Buffer buf ) { synchronized ( queue ) { if ( queue . size ( ) ==  QUEUE_ SIZE ) { logger . info ( _ STR ) ; if ( queue Statistics != null ) { queue Statistics . remove (  System . current Time Millis ( ) ) ; } queue . poll ( ) ; } queue . offer ( buf ) ; if ( queue Statistics != null ) { queue Statistics . add (  System . current Time Millis ( ) ) ; } queue . notify All ( ) ; } }
Message ( ) { }
public  String global Info ( ) { return _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR ; }
private  Iterable < ? extends  Document Score > evaluate Query (  Query Spec query ) {  Iterable < ? extends  Document Score > hits = null ; try {  String s Query = query . get Query String ( ) ; if ( ! s Query . is Empty ( ) ) { boolean highlight = ( query . get Snippet Variable Name ( ) != null || query . get Property Variable Name ( ) != null ) ; hits = query ( query . get Subject ( ) , query . get Query String ( ) , query . get Property URI ( ) , highlight ) ; } else { hits = null ; } } catch (  Exception e ) { logger . error ( _ STR + query . get Query String ( ) + _ STR + query . get Property URI ( ) + _ STR , e ) ; } return hits ; }
private void append Indentation ( int level ,  String Builder result ) { for ( int i = _ NUM ; i < level ; ++ i ) result . append ( _ STR ) ; }
public int size ( ) { return set . size ( ) ; }
public void load Tree (  Input Stream tree Stream ) throws  IOException ,  Mary Configuration Exception {  Mary CARTReader cart Reader = new  Mary CARTReader ( ) ; this . tree = cart Reader . load From Stream ( tree Stream ) ; this . feature Definition = tree . get Feature Definition ( ) ; this . index Predicted Feature = feature Definition . get Feature Index (  PREDICTED_ STRING_ FEATURENAME ) ; this . convert To Lowercase = _ BOOL ;  Properties props = tree . get Properties ( ) ; if ( props == null ) throw new  Illegal Argument Exception ( _ STR ) ; convert To Lowercase =  Boolean . parse Boolean ( props . get Property ( _ STR ) ) ; context =  Integer . parse Int ( props . get Property ( _ STR ) ) ; }
public void remove All Listeners ( ) { listeners . clear ( ) ; }
public  String decrypt String (  String s Cipher Text ) { int n Len = ( s Cipher Text . length ( ) > > _ NUM ) & ~ _ NUM ; if ( n Len <  Blowfish ECB .  BLOCKSIZE ) return null ; byte [ ] cbciv = new byte [  Blowfish ECB .  BLOCKSIZE ] ; int n Num Of Bytes =  Bin Converter . bin Hex To Bytes ( s Cipher Text , cbciv , _ NUM , _ NUM ,  Blowfish ECB .  BLOCKSIZE ) ; if ( n Num Of Bytes <  Blowfish ECB .  BLOCKSIZE ) return null ; m_bfish . set CBCIV ( cbciv ) ; n Len -=  Blowfish ECB .  BLOCKSIZE ; if ( n Len == _ NUM ) return _ STR ; byte [ ] buf = new byte [ n Len ] ; n Num Of Bytes =  Bin Converter . bin Hex To Bytes ( s Cipher Text , buf ,  Blowfish ECB .  BLOCKSIZE * _ NUM , _ NUM , n Len ) ; if ( n Num Of Bytes < n Len ) return null ; m_bfish . decrypt ( buf ) ; int n Pad Byte = buf [ buf . length - _ NUM ] & _ NUM ; if ( ( n Pad Byte > _ NUM ) || ( n Pad Byte < _ NUM ) ) n Pad Byte = _ NUM ; n Num Of Bytes -= n Pad Byte ; if ( n Num Of Bytes < _ NUM ) return _ STR ; return  Bin Converter . byte Array To UNCString ( buf , _ NUM , n Num Of Bytes ) ; }
public static final int [ ] to Int Array (  Instance x , int  L ) { int y [ ] = new int [  L ] ; for ( int j = _ NUM ; j <  L ; j ++ ) { if ( x . is Missing ( j ) ) { y [ j ] = - _ NUM ; } else { y [ j ] = ( int )  Math . round ( x . value ( j ) ) ; } } return y ; }
@  Override public void insert All (  DBIDs ids ) { if ( ids . is Empty ( ) || ( ids . size ( ) == _ NUM ) ) { return ; } if ( can Bulk Load ( ) ) {  List <  Spatial Entry > leafs = new  Array List < > ( ids . size ( ) ) ; for (  DBIDIter iter = ids . iter ( ) ; iter . valid ( ) ; iter . advance ( ) ) { leafs . add ( create New Leaf Entry ( iter ) ) ; } bulk Load ( leafs ) ; } else { for (  DBIDIter iter = ids . iter ( ) ; iter . valid ( ) ; iter . advance ( ) ) { insert (  DBIDUtil . deref ( iter ) ) ; } } do Extra Integrity Checks ( ) ; }
public static void append Attribute ( final  String Buffer log Message , final  String attribute Name , final  String attribute Value ) { log Message . append ( _ STR + attribute Name + _ STR + attribute Value + _ STR ) ; }
public final void increase Idle Count (  Idle Status status , long current Time ) { if ( status ==  Idle Status .  BOTH_ IDLE ) { idle Count For Both . increment And Get ( ) ; last Idle Time For Both = current Time ; } else if ( status ==  Idle Status .  READER_ IDLE ) { idle Count For Read . increment And Get ( ) ; last Idle Time For Read = current Time ; } else if ( status ==  Idle Status .  WRITER_ IDLE ) { idle Count For Write . increment And Get ( ) ; last Idle Time For Write = current Time ; } else { throw new  Illegal Argument Exception ( _ STR + status ) ; } }
protected void calculate Fitness And Sort Population ( ) { logger . debug ( _ STR + population . size ( ) + _ STR ) ;  Iterator <  T > iterator = population . iterator ( ) ; while ( iterator . has Next ( ) ) {  T c = iterator . next ( ) ; if ( is Finished ( ) ) { if ( c . is Changed ( ) ) iterator . remove ( ) ; } else { for (  Fitness Function <  T > fitness Function : fitness Functions ) { fitness Function . get Fitness ( c ) ; notify Evaluation ( c ) ; } } } sort Population ( ) ; }
public  Session ( ) { long uptime =  System . current Time Millis ( ) ;  Handler Thread thread = new  Handler Thread ( _ STR ) ; thread . start ( ) ; m Handler = new  Handler ( thread . get Looper ( ) ) ; m Main Handler = new  Handler (  Looper . get Main Looper ( ) ) ; m Timestamp = ( uptime / _ NUM ) << _ NUM & ( ( ( uptime - ( ( uptime / _ NUM ) * _ NUM ) ) > > _ NUM ) / _ NUM ) ; m Origin = _ STR ; }
public  List <  Local > listar ( ) {  List <  Local > dados = new  Array List < > ( ) ; try {  String sql = _ STR ; stm = conector . prepare Statement ( sql ) ; rs = stm . execute Query ( sql ) ; while ( rs . next ( ) ) {  Setor setor = new  Setor ( rs . get Int ( _ NUM ) , rs . get String ( _ NUM ) ) ;  Local local = new  Local ( rs . get Int ( _ NUM ) , rs . get String ( _ NUM ) , rs . get String ( _ NUM ) , setor ) ; dados . add ( local ) ; } stm . close ( ) ; rs . close ( ) ; } catch (  SQLException ex ) {  Mensagem . erro ( _ STR + ex ) ; } return dados ; }
public  Instruction Iterator instruction Iterator ( ) { return new  Instruction Iterator ( first Instruction , last Instruction ) ; }
public int [ ] array ( int [ ] array ) { if ( array == null || array . length != count ) { array = new int [ count ] ; }  System . arraycopy ( data , _ NUM , array , _ NUM , count ) ; return array ; }
@  Override public final boolean is Magic Word (  String in ) { return in . matches ( _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR ) ; }
private double [ ] find And Evaluate Threshold (  Double Dynamic Histogram histogram ) { int n = histogram . get Num Bins ( ) ; double [ ] p1 = new double [ n ] ; double [ ] p2 = new double [ n ] ; double [ ] mu1 = new double [ n ] ; double [ ] mu2 = new double [ n ] ; double [ ] sigma1 = new double [ n ] ; double [ ] sigma2 = new double [ n ] ; double [ ] jt = new double [ n ] ; {  Mean Variance mv = new  Mean Variance ( ) ;  Double Histogram .  Iter forward = histogram . iter ( ) ; for ( int i = _ NUM ; forward . valid ( ) ; i ++ , forward . advance ( ) ) { p1 [ i ] = forward . get Value ( ) + ( ( i > _ NUM ) ? p1 [ i - _ NUM ] : _ NUM ) ; mv . put ( i , forward . get Value ( ) ) ; mu1 [ i ] = mv . get Mean ( ) ; sigma1 [ i ] = mv . get Naive Stddev ( ) ; } } {  Mean Variance mv = new  Mean Variance ( ) ;  Double Histogram .  Iter backwards = histogram . iter ( ) ; backwards . seek ( histogram . get Num Bins ( ) - _ NUM ) ; for ( int j = n - _ NUM ; backwards . valid ( ) ; j -- , backwards . retract ( ) ) { p2 [ j ] = backwards . get Value ( ) + ( ( j + _ NUM < n ) ? p2 [ j + _ NUM ] : _ NUM ) ; mv . put ( j , backwards . get Value ( ) ) ; mu2 [ j ] = mv . get Mean ( ) ; sigma2 [ j ] = mv . get Naive Stddev ( ) ; } } for ( int i = _ NUM ; i < n ; i ++ ) { jt [ i ] = _ NUM + _ NUM * ( p1 [ i ] * (  Math . log ( sigma1 [ i ] ) -  Math . log ( p1 [ i ] ) ) + p2 [ i ] * (  Math . log ( sigma2 [ i ] ) -  Math . log ( p2 [ i ] ) ) ) ; } int bestpos = - _ NUM ; double bestgoodness =  Double .  NEGATIVE_ INFINITY ; double dev Prev = jt [ _ NUM ] - jt [ _ NUM ] ; for ( int i = _ NUM ; i < jt . length - _ NUM ; i ++ ) { double dev Cur = jt [ i + _ NUM ] - jt [ i ] ; if ( dev Cur >= _ NUM && dev Prev <= _ NUM ) { double lowest Maxima =  Double .  POSITIVE_ INFINITY ; for ( int j = i - _ NUM ; j > _ NUM ; j -- ) { if ( jt [ j - _ NUM ] < jt [ j ] ) { lowest Maxima =  Math . min ( lowest Maxima , jt [ j ] ) ; break ; } } for ( int j = i + _ NUM ; j < n - _ NUM ; j ++ ) { if ( jt [ j + _ NUM ] < jt [ j ] ) { lowest Maxima =  Math . min ( lowest Maxima , jt [ j ] ) ; break ; } } double local Depth = lowest Maxima - jt [ i ] ; final double mud = mu1 [ i ] - mu2 [ i ] ; double discriminability = mud * mud / ( sigma1 [ i ] * sigma1 [ i ] + sigma2 [ i ] * sigma2 [ i ] ) ; if (  Double . is Na N ( discriminability ) ) { discriminability = - _ NUM ; } double goodness = local Depth * discriminability ; if ( goodness > bestgoodness ) { bestgoodness = goodness ; bestpos = i ; } } dev Prev = dev Cur ; }  Iter iter = histogram . iter ( ) ; iter . seek ( bestpos ) ; return new double [ ] { iter . get Right ( ) , bestgoodness } ; }
public void wait For Frame ( int frame Number ,  String jump Label ) throws  IOException { print ( _ STR , new  String [ ] {  Integer . to String ( frame Number ) , _ STR + jump Label + _ STR } ) ; }
public void delete (  String name ) throws  IOException { if ( name . equals Ignore Case (  ISSUER_ NAME ) ) { names = null ; } else { throw new  IOException ( _ STR + _ STR ) ; } encode This ( ) ; }
public  Geo Distance Builder add Unbounded To (  String key , double to ) { ranges . add ( new  Range ( key , null , to ) ) ; return this ; }
public synchronized void add Reply (  Reply reply ) { if ( ! ignore Reply ( reply ) ) { repliedlist_ . add ( reply . get Participant ( ) ) ; replies_ . push ( reply ) ; number Of Missing Replies_ -- ; notify All ( ) ; } }
public static  String unescape HTML (  String str ) {  String Builder rtn = new  String Builder ( ) ; int pos Start = - _ NUM ; int pos Finish = - _ NUM ; while ( ( pos Start = str . index Of ( _ STR , pos Start ) ) != - _ NUM ) { int last = pos Finish + _ NUM ; pos Finish = str . index Of ( _ STR , pos Start ) ; if ( pos Finish == - _ NUM ) break ; rtn . append ( str . substring ( last , pos Start ) ) ; if ( pos Start + _ NUM < pos Finish ) { rtn . append ( unescape HTMLEntity ( str . substring ( pos Start + _ NUM , pos Finish ) ) ) ; } else { rtn . append ( _ STR ) ; } pos Start = pos Finish + _ NUM ; } rtn . append ( str . substring ( pos Finish + _ NUM ) ) ; return rtn . to String ( ) ; }
public  Base Matcher ( final  Network Config config ) { if ( config == null ) { throw new  Null Pointer Exception ( _ STR ) ; } else { this . config = config ; } }
protected void on Started ( ) throws  Exo Playback Exception { }
public long signal ( ) { return  Long . parse Long ( fields [ _ NUM ] ) ; }
public  Edge Effect (  Context context ) { m Paint . set Anti Alias ( _ BOOL ) ; final int theme Color =  Color .  RED ; m Paint . set Color ( ( theme Color & _ NUM ) | _ NUM ) ; m Paint . set Style (  Paint .  Style .  FILL ) ; m Paint . set Xfermode ( new  Porter Duff Xfermode (  Porter Duff .  Mode .  SRC_ ATOP ) ) ; m Interpolator = new  Decelerate Interpolator ( ) ; }
private  GBDevice to GBDevice (  Device db Device ) {  Device Type device Type =  Device Type . from Key ( db Device . get Type ( ) ) ;  GBDevice gb Device = new  GBDevice ( db Device . get Identifier ( ) , db Device . get Name ( ) , device Type ) ;  List <  Device Attributes > device Attributes List = db Device . get Device Attributes List ( ) ; if ( device Attributes List . size ( ) > _ NUM ) { gb Device . set Model ( db Device . get Model ( ) ) ;  Device Attributes attrs = device Attributes List . get ( _ NUM ) ; gb Device . set Firmware Version ( attrs . get Firmware Version1 ( ) ) ; gb Device . set Firmware Version2 ( attrs . get Firmware Version2 ( ) ) ; } return gb Device ; }
public  Profiler start Collecting ( ) { thread = new  Thread ( this , _ STR ) ; thread . set Daemon ( _ BOOL ) ; thread . start ( ) ; return this ; }
double scale ( final int pixels , final int total ) { double distance =  Math . max ( upper - lower , _ NUM ) ; double fraction = ( ( double ) pixels ) / total ;  LOGGER . debug ( _ STR + pixels + _ STR + total + _ STR + fraction * distance ) ; return fraction * distance ; }
public  String next CDATA ( ) throws  JSONException { char c ; int i ;  String Buffer sb = new  String Buffer ( ) ; for ( ; ; ) { c = next ( ) ; if ( end ( ) ) { throw syntax Error ( _ STR ) ; } sb . append ( c ) ; i = sb . length ( ) - _ NUM ; if ( i >= _ NUM && sb . char At ( i ) == _ STR && sb . char At ( i + _ NUM ) == _ STR && sb . char At ( i + _ NUM ) == _ STR ) { sb . set Length ( i ) ; return sb . to String ( ) ; } } }
public static double magnitude ( final double x , final double y , final double z ) { return  Math . sqrt ( x * x + y * y + z * z ) ; }
public static  Map <  String ,  String > json To Map (  String json String ) {  Map <  String ,  String > json Map = new  Tree Map <  String ,  String > ( ) ; try {  Gf Json Object json Object = new  Gf Json Object ( json String ) ;  Iterator <  String > keys = json Object . keys ( ) ; while ( keys . has Next ( ) ) {  String key = keys . next ( ) ; json Map . put ( key , json Object . get String ( key ) ) ; } } catch (  Gf Json Exception e ) { throw new  Illegal Argument Exception ( _ STR + json String + _ STR ) ; } return json Map ; }
private static  Properties create Properties1 ( ) {  Properties props = new  Properties ( ) ; props . set Property (  MCAST_ PORT , _ STR ) ; props . set Property (  LOCATORS , _ STR ) ; return props ; }
public  Host List Panel ( ) { m_ List = new  JList ( ) ; m_ List . set Model ( new  Default List Model ( ) ) ; m_ Delete But . set Enabled ( _ BOOL ) ; m_ Delete But . add Action Listener ( this ) ; m_ Host Field . add Action Listener ( this ) ; set Layout ( new  Border Layout ( ) ) ; set Border (  Border Factory . create Titled Border ( _ STR ) ) ;  JPanel top Lab = new  JPanel ( ) ;  Grid Bag Layout gb = new  Grid Bag Layout ( ) ;  Grid Bag Constraints constraints = new  Grid Bag Constraints ( ) ; top Lab . set Border (  Border Factory . create Empty Border ( _ NUM , _ NUM , _ NUM , _ NUM ) ) ; top Lab . set Layout ( gb ) ; constraints . gridx = _ NUM ; constraints . gridy = _ NUM ; constraints . weightx = _ NUM ; constraints . fill =  Grid Bag Constraints .  HORIZONTAL ; constraints . gridwidth = _ NUM ; constraints . gridheight = _ NUM ; constraints . insets = new  Insets ( _ NUM , _ NUM , _ NUM , _ NUM ) ; top Lab . add ( m_ Delete But , constraints ) ; constraints . gridx = _ NUM ; constraints . gridy = _ NUM ; constraints . weightx = _ NUM ; constraints . gridwidth = _ NUM ; constraints . gridheight = _ NUM ; top Lab . add ( m_ Host Field , constraints ) ; add ( top Lab ,  Border Layout .  NORTH ) ; add ( new  JScroll Pane ( m_ List ) ,  Border Layout .  CENTER ) ; }
public static double [ ] [ ] randn ( int rows , int cols ,  Random r ) { double  X [ ] [ ] = new double [ rows ] [ cols ] ; for ( int i = _ NUM ; i < rows ; i ++ ) { for ( int j = _ NUM ; j < cols ; j ++ ) {  X [ i ] [ j ] = r . next Gaussian ( ) ; } } return  X ; }
private  Utils ( ) { }
public void add Photo (  Photo Entity photo ) { photos . add ( photo ) ; }
private static int write Matches ( char separator ,  String read Name ,  IRead Block read Block ,  Writer w ) throws  IOException { int count Matches = _ NUM ; if ( read Block . get Number Of Available Match Blocks ( ) == _ NUM ) w . write (  String . format ( _ STR , read Name , separator ) ) ; else { w . write ( read Name ) ; for (  IMatch Block match Block : read Block . get Match Blocks ( ) ) { w . write (  String . format ( _ STR , separator , match Block . get Taxon Id ( ) , separator , match Block . get Bit Score ( ) ) ) ; count Matches ++ ; } w . write ( _ STR ) ; } return count Matches ; }
public static boolean assert Sorted ( final double [ ] a ) { for ( int i = _ NUM ; i < a . length ; i ++ ) {  Exam . assert True ( _ STR +  Arrays . to String ( a ) , a [ i - _ NUM ] < a [ i ] ) ; } return _ BOOL ; }
public void mark Failed ( ) { failures = _ BOOL ; for (  Test Rule Mark Failure next : chained ) { next . mark Failed ( ) ; } }
public void dump_stack ( ) { if ( stack == null ) { debug_message ( _ STR ) ; return ; } debug_message ( _ STR ) ; for ( int i = _ NUM ; i < stack . size ( ) ; i ++ ) { debug_message ( _ STR + ( (  Symbol ) stack . element At ( i ) ) . sym + _ STR + ( (  Symbol ) stack . element At ( i ) ) . parse_state ) ; } debug_message ( _ STR ) ; }
public static  Map <  String ,  Set <  String > > clone Map (  Map <  String ,  Set <  String > > map ) {  Map <  String ,  Set <  String > > clone = new  Hash Map <  String ,  Set <  String > > ( ) ; for (  String key : map . key Set ( ) ) {  Set <  String > set = new  Hash Set <  String > ( ) ;  Set <  String > orig = (  Set <  String > ) map . get ( key ) ; set . add All ( orig ) ; clone . put ( key , set ) ; } return clone ; }
public void download (  String remote File Name ,  File local File , long restart At ,  FTPData Transfer Listener listener ) throws  Illegal State Exception ,  File Not Found Exception ,  IOException ,  FTPIllegal Reply Exception ,  FTPException ,  FTPData Transfer Exception ,  FTPAborted Exception {  Output Stream output Stream = null ; try { output Stream = new  File Output Stream ( local File , restart At > _ NUM ) ; } catch (  IOException e ) { throw new  FTPData Transfer Exception ( e ) ; } try { download ( remote File Name , output Stream , restart At , listener ) ; } catch (  Illegal State Exception e ) { throw e ; } catch (  IOException e ) { throw e ; } catch (  FTPIllegal Reply Exception e ) { throw e ; } catch (  FTPException e ) { throw e ; } catch (  FTPData Transfer Exception e ) { throw e ; } catch (  FTPAborted Exception e ) { throw e ; } finally { if ( output Stream != null ) { try { output Stream . close ( ) ; } catch (  Throwable t ) { ; } } } }
public  IOException check Certificate ( ) {  SSLSocket Factory factory = context . get Socket Factory ( ) ; try {  SSLSocket socket = (  SSLSocket ) factory . create Socket ( host , port ) ; socket . set So Timeout ( _ NUM ) ; socket . start Handshake ( ) ; socket . close ( ) ; return null ; } catch (  IOException e ) { return e ; } }
private  String format Node (  Binary Node <  T > node ) {  Binary Node <  T > n ;  String Builder response = new  String Builder ( _ STR ) ; if ( ( n = node . get Left Son ( ) ) != null ) { response . append ( format Node ( n ) ) ; } response . append ( node . to String ( ) ) ; if ( ( n = node . get Right Son ( ) ) != null ) { response . append ( format Node ( n ) ) ; } response . append ( _ STR ) ; return response . to String ( ) ; }
public static void unregister MBean (  Class < ? > mbean Interface ,  String mbean Name ) {  MBean Server mbs =  Management Factory . get Platform MBean Server ( ) ; try {  Object Name name = generate MBean Object Name ( mbean Interface . get Name ( ) , mbean Name ) ; if ( mbs . is Registered ( name ) ) { logger . info ( _ STR + name . to String ( ) ) ; mbs . unregister MBean ( name ) ; } else { logger . warn ( _ STR + name . to String ( ) ) ; } } catch (  Exception e ) { throw new  Server Runtime Exception ( _ STR + mbean Interface + _ STR + mbean Name , e ) ; } }
public  Conversion Exception (  Throwable cause ) { super ( cause . get Message ( ) ) ; this . cause = cause ; }
public  Json Array add (  String value ) { values . add ( value Of ( value ) ) ; return this ; }
private static  String to String ( double [ ] [ ] m ,  Number Format nf ,  List <  String > variables ) {  String result ; if ( nf == null ) { throw new  Null Pointer Exception ( _ STR ) ; } if ( variables == null ) { variables = new  Array List < > ( ) ; for ( int i = _ NUM ; i < m [ _ NUM ] . length ; i ++ ) { variables . add ( _ STR + ( i + _ NUM ) ) ; } } if ( m == null ) { result = null Message ( ) ; } else {  Text Table text Table = new  Text Table ( m . length + _ NUM , m [ _ NUM ] . length ) ; for ( int i = _ NUM ; i < variables . size ( ) ; i ++ ) { text Table . set Token ( _ NUM , i , variables . get ( i ) ) ; } for ( int i = _ NUM ; i < m . length ; i ++ ) { for ( int j = _ NUM ; j < m [ _ NUM ] . length ; j ++ ) { text Table . set Token ( i + _ NUM , j , m [ i ] [ j ] == _ NUM ? _ STR : nf . format ( m [ i ] [ j ] ) ) ; } } result = _ STR + text Table . to String ( ) ; } return result ; }
@  HLEUnimplemented @  HLEFunction ( nid = _ NUM , version = _ NUM ) public int sce Usb Cam Setup Video ( psp Usb Cam Setup Video Param usb Cam Setup Video Param ,  TPointer work Area , int work Area Size ) { this . work Area = work Area . get Address ( ) ; this . work Area Size = work Area Size ; resolution = usb Cam Setup Video Param . resolution ; frame Rate = usb Cam Setup Video Param . framerate ; white Balance = usb Cam Setup Video Param . wb ; saturation = usb Cam Setup Video Param . saturation ; brightness = usb Cam Setup Video Param . brightness ; contrast = usb Cam Setup Video Param . contrast ; sharpness = usb Cam Setup Video Param . sharpness ; image Effect Mode = usb Cam Setup Video Param . effectmode ; frame Size = usb Cam Setup Video Param . framesize ; ev Level = usb Cam Setup Video Param . evlevel ; if ( ! setup Video ( ) ) { log . warn (  String . format ( _ STR ) ) ; return  Sce Kernel Errors .  ERROR_ USBCAM_ NOT_ READY ; } return _ NUM ; }
public  List <  Completion > load All Deep From Cursor (  Cursor cursor ) { int count = cursor . get Count ( ) ;  List <  Completion > list = new  Array List <  Completion > ( count ) ; if ( cursor . move To First ( ) ) { if ( identity Scope != null ) { identity Scope . lock ( ) ; identity Scope . reserve Room ( count ) ; } try { do { list . add ( load Current Deep ( cursor , _ BOOL ) ) ; } while ( cursor . move To Next ( ) ) ; } finally { if ( identity Scope != null ) { identity Scope . unlock ( ) ; } } } return list ; }
public static  String convert Date To ISO8601 (  Date date ) {  Date Format date Format = new  Simple Date Format ( _ STR ) ; return date Format . format ( date ) ; }
public static  Document create DOM (  String str XML ) throws  Parser Configuration Exception ,  SAXException ,  IOException {  Document Builder Factory dbf =  Document Builder Factory . new Instance ( ) ; dbf . set Validating ( _ BOOL ) ; dbf . set Ignoring Comments ( _ BOOL ) ; dbf . set Ignoring Element Content Whitespace ( _ BOOL ) ; dbf . set Namespace Aware ( _ BOOL ) ; dbf . set Feature (  XMLConstants .  FEATURE_ SECURE_ PROCESSING , _ BOOL ) ; dbf . set Feature (  DISALLOW_ DOCTYPE_ DECL , _ BOOL ) ; dbf . set Feature (  EXTERNAL_ GENERAL_ ENTITIES , _ BOOL ) ; dbf . set Feature (  EXTERNAL_ PARAMETER_ ENTITIES , _ BOOL ) ; dbf . set Feature (  LOAD_ EXTERNAL_ DTD , _ BOOL ) ;  Document Builder db = null ; db = dbf . new Document Builder ( ) ; db . set Entity Resolver ( new  Null Resolver ( ) ) ; db . set Error Handler ( new  Saml Parser Error Handler ( ) ) ;  Input Source source XML = new  Input Source ( new  String Reader ( str XML ) ) ;  Document xml Doc = db . parse ( source XML ) ; return xml Doc ; }
public void reset ( ) { last Mtd = null ; map . clear ( ) ; put Cnt . set ( _ NUM ) ; put All Cnt . set ( _ NUM ) ; rmv Cnt . set ( _ NUM ) ; rmv All Cnt . set ( _ NUM ) ; ts =  System . current Time Millis ( ) ; }
void decode Attribute Body ( byte [ ] attribute Value , char offset , char length ) throws  Stun Exception { data = new byte [ length ] ;  System . arraycopy ( attribute Value , offset , data , _ NUM , length ) ; }
public static  String internal Stock Fish Name ( ) {  String abi =  Build .  CPU_ ABI ; boolean no PIE =  Build .  VERSION .  SDK_ INT < _ NUM ; if ( abi . equals ( _ STR ) ) { } else if ( abi . equals ( _ STR ) ) { no PIE = _ BOOL ; } else if ( abi . equals ( _ STR ) ) { } else if ( abi . equals ( _ STR ) ) { no PIE = _ BOOL ; } else if ( abi . equals ( _ STR ) ) { } else if ( abi . equals ( _ STR ) ) { no PIE = _ BOOL ; } else { abi = _ STR ; } return _ STR + abi + ( no PIE ? _ STR : _ STR ) ; }
@  Override public boolean equals (  Object obj ) { if ( obj == null ) { return _ BOOL ; } if ( get Class ( ) != obj . get Class ( ) ) { return _ BOOL ; } final  Name For Request other = (  Name For Request ) obj ; if ( !  Objects . equals ( this . name , other . name ) ) { return _ BOOL ; } return _ BOOL ; }
public static void spooky4 ( final long [ ] triple , final long seed , final long [ ] tuple ) { long h0 , h1 , h2 , h3 ; h0 = seed ; h1 =  ARBITRARY_ BITS + triple [ _ NUM ] ; h2 =  ARBITRARY_ BITS + triple [ _ NUM ] ; h3 =  ARBITRARY_ BITS + triple [ _ NUM ] ; h2 =  Long . rotate Left ( h2 , _ NUM ) ; h2 += h3 ; h0 ^= h2 ; h3 =  Long . rotate Left ( h3 , _ NUM ) ; h3 += h0 ; h1 ^= h3 ; h0 =  Long . rotate Left ( h0 , _ NUM ) ; h0 += h1 ; h2 ^= h0 ; h1 =  Long . rotate Left ( h1 , _ NUM ) ; h1 += h2 ; h3 ^= h1 ; h2 =  Long . rotate Left ( h2 , _ NUM ) ; h2 += h3 ; h0 ^= h2 ; h3 =  Long . rotate Left ( h3 , _ NUM ) ; h3 += h0 ; h1 ^= h3 ; h0 =  Long . rotate Left ( h0 , _ NUM ) ; h0 += h1 ; h2 ^= h0 ; h1 =  Long . rotate Left ( h1 , _ NUM ) ; h1 += h2 ; h3 ^= h1 ; h2 =  Long . rotate Left ( h2 , _ NUM ) ; h2 += h3 ; h0 ^= h2 ; h3 =  Long . rotate Left ( h3 , _ NUM ) ; h3 += h0 ; h1 ^= h3 ; h0 =  Long . rotate Left ( h0 , _ NUM ) ; h0 += h1 ; h2 ^= h0 ; h1 =  Long . rotate Left ( h1 , _ NUM ) ; h1 += h2 ; h3 ^= h1 ; switch ( tuple . length ) { case _ NUM : tuple [ _ NUM ] = h3 ; case _ NUM : tuple [ _ NUM ] = h2 ; case _ NUM : tuple [ _ NUM ] = h1 ; case _ NUM : tuple [ _ NUM ] = h0 ; } }
@  Override protected void register New Selector ( ) throws  IOException { synchronized ( selector ) {  Set <  Selection Key > keys = selector . keys ( ) ;  Selector new Selector = null ; if ( selector Provider == null ) { new Selector =  Selector . open ( ) ; } else { new Selector = selector Provider . open Selector ( ) ; } for (  Selection Key key : keys ) {  Selectable Channel ch = key . channel ( ) ;  Nio Session session = (  Nio Session ) key . attachment ( ) ;  Selection Key new Key = ch . register ( new Selector , key . interest Ops ( ) , session ) ; session . set Selection Key ( new Key ) ; } selector . close ( ) ; selector = new Selector ; } }
public void add (  WXDom Object child , int index ) { if ( child == null || index < - _ NUM || s Destroy . get ( ) ) { return ; } if ( children == null ) { children = new  Array List < > ( ) ; } int count = children . size ( ) ; index = index >= count ? - _ NUM : index ; if ( index == - _ NUM ) { children . add ( child ) ; super . add Child At ( child , super . get Child Count ( ) ) ; } else { children . add ( index , child ) ; super . add Child At ( child , index ) ; } child . parent = this ; }
private void paint (  Sea Glass Painter p ,  Synth Context ctx ,  Graphics g , int x , int y , int w , int h ,  Affine Transform transform ) { if ( p != null ) { if ( g instanceof  Graphics2 D ) {  Graphics2 D gfx = (  Graphics2 D ) g ; if ( transform != null ) { gfx . transform ( transform ) ; } gfx . translate ( x , y ) ; p . paint ( gfx , ctx . get Component ( ) , w , h ) ; gfx . translate ( - x , - y ) ; if ( transform != null ) { try { gfx . transform ( transform . create Inverse ( ) ) ; } catch (  Noninvertible Transform Exception e ) { e . print Stack Trace ( ) ; } } } else {  Buffered Image img = new  Buffered Image ( w , h ,  Buffered Image .  TYPE_ INT_ ARGB ) ;  Graphics2 D gfx = img . create Graphics ( ) ; if ( transform != null ) { gfx . transform ( transform ) ; } p . paint ( gfx , ctx . get Component ( ) , w , h ) ; gfx . dispose ( ) ; g . draw Image ( img , x , y , null ) ; img = null ; } } }
@  Override public void evict All ( ) {  File [ ] files = cache Directory . list Files ( ) ; if ( null != files ) { for (  File file : files ) { if ( file != null ) file . delete ( ) ; } } }
public static <  T extends  Throwable > void throw If Instance Of (  Throwable t ,  Class <  T > cls ) throws  T { if ( cls . is Instance ( t ) ) { throw cls . cast ( t ) ; } }
public static void write Var Long (  Output Stream out , long x ) throws  IOException { while ( ( x & ~ _ NUM ) != _ NUM ) { out . write ( ( byte ) ( _ NUM | ( x & _ NUM ) ) ) ; x >>>= _ NUM ; } out . write ( ( byte ) x ) ; }
protected void engine Update ( byte b ) throws  Signature Exception { msg Digest . update ( b ) ; }
public static boolean check If Initiators For RP (  Db Client db Client ,  String Set initiator List ) { if ( db Client == null || initiator List == null ) { return _ BOOL ; }  List <  Initiator > initiators = new  Array List <  Initiator > ( ) ; for (  String initiator Id : initiator List ) {  Initiator initiator = db Client . query Object (  Initiator . class ,  URI . create ( initiator Id ) ) ; if ( initiator != null ) { initiators . add ( initiator ) ; } } return check If Initiators For RP ( initiators ) ; }
public void message (  Serial Message m ) { }
private  Execution Context execute Using Simplified Compilation Chain (  String dml Script File Path , boolean is File ,  Map <  String ,  String > arg Vals , boolean parse Py DML ,  String [ ] inputs ,  String [ ] outputs ,  Local Variable Map input Symbol Table ,  String config File Path ) throws  IOException ,  DMLException {  DMLConfig config = ( config File Path == null ) ? new  DMLConfig ( ) : new  DMLConfig ( config File Path ) ; for (  Entry <  String ,  String > param : _additional Configs . entry Set ( ) ) { config . set Text Value ( param . get Key ( ) , param . get Value ( ) ) ; }  Configuration Manager . set Global Config ( config ) ;  Compiler Config cconf = new  Compiler Config ( ) ; cconf . set (  Config Type .  IGNORE_ UNSPECIFIED_ ARGS , _ BOOL ) ; cconf . set (  Config Type .  REJECT_ READ_ WRITE_ UNKNOWNS , _ BOOL ) ; cconf . set (  Config Type .  ALLOW_ CSE_ PERSISTENT_ READS , _ BOOL ) ;  Configuration Manager . set Global Config ( cconf ) ;  String dml Script Str =  DMLScript . read DMLScript ( is File ? _ STR : _ STR , dml Script File Path ) ; if ( _monitor Utils != null ) { _monitor Utils . set DMLString ( dml Script Str ) ; } _rtprog = null ;  AParser Wrapper parser =  AParser Wrapper . create Parser ( parse Py DML ) ;  DMLProgram prog ; if ( is File ) { prog = parser . parse ( dml Script File Path , null , arg Vals ) ; } else { prog = parser . parse ( null , dml Script Str , arg Vals ) ; }  DMLTranslator dmlt = new  DMLTranslator ( prog ) ; dmlt . live Variable Analysis ( prog ) ; dmlt . validate Parse Tree ( prog ) ; dmlt . construct Hops ( prog ) ; dmlt . rewrite Hops DAG ( prog ) ;  Explain . explain ( prog ) ; if ( input Symbol Table != null ) {  Rewrite Remove Persistent Read Write rewrite = new  Rewrite Remove Persistent Read Write ( inputs , outputs , input Symbol Table ) ;  Program Rewriter rewriter2 = new  Program Rewriter ( rewrite ) ; rewriter2 . rewrite Program Hop DAGs ( prog ) ; } dmlt . construct Lops ( prog ) ; _rtprog = prog . get Runtime Program ( config ) ; if (  Optimizer Utils . is Opt Level (  Optimization Level .  O4_ GLOBAL_ TIME_ MEMORY ) ) { _rtprog =  Global Optimizer Wrapper . optimize Program ( prog , _rtprog ) ; }  Explain Counts counts =  Explain . count Distributed Operations ( _rtprog ) ;  Statistics . reset No Of Compiled Jobs ( counts . num Jobs ) ;  DMLScript . init Hadoop Execution ( config ) ;  JMLCUtils . cleanup Runtime Program ( _rtprog , outputs ) ;  Execution Context ec =  Execution Context Factory . create Context ( _rtprog ) ; if ( input Symbol Table != null ) { ec . set Variables ( input Symbol Table ) ; } _rtprog . execute ( ec ) ; if ( _monitor Utils != null ) _monitor Utils . set Explain Output (  Explain . explain ( _rtprog ) ) ; return ec ; }
default  B with Default (  String key , boolean value ) { return with Default ( key ,  Boolean . to String ( value ) ) ; }
public void write (  Input Stream stream ) { if ( is Final ) { log . warning ( _ STR ) ; return ; } try { int n Read ; byte [ ] buffer = new byte [ _ NUM * _ NUM ] ; while ( ( n Read = stream . read ( buffer , _ NUM , buffer . length ) ) != - _ NUM ) { byte [ ] new Data = new byte [ data . length + n Read ] ;  System . arraycopy ( data , _ NUM , new Data , _ NUM , data . length ) ;  System . arraycopy ( buffer , _ NUM , new Data , data . length , n Read ) ; data = new Data ; } } catch (  IOException e ) { log . warning ( _ STR ) ; } }
public void action Performed (  Action Event e ) {  Graphics Environment . get Local Graphics Environment ( ) ; if ( !  Graphics Environment . is Headless ( ) ) { if (  UI == null ) {  UI = new  User Interface ( ) ; } else {  UI . set Visible ( _ BOOL ) ; } } else { new  Faceless Server ( ) ; } }
protected  Monitor poll For (  Map <  String ,  Monitor > map ,  String name , long time Limit ) throws  Monitor Exception {  Monitor monitor = null ; log ( _ STR + lvmid + _ STR + name + _ STR ) ; poll For Entry = next Entry ; while ( ( monitor = map . get ( name ) ) == null ) { log ( _ STR ) ; try {  Thread . sleep ( _ NUM ) ; } catch (  Interrupted Exception e ) { } long t =  System . current Time Millis ( ) ; if ( ( t > time Limit ) || ( overflow . int Value ( ) > _ NUM ) ) { lognl ( _ STR + lvmid + _ STR + name ) ; dump All ( map , lvmid ) ; throw new  Monitor Exception ( _ STR ) ; } get New Monitors ( map ) ; } lognl ( _ STR + lvmid + _ STR + name ) ; return monitor ; }
protected void calculate Offset (  T entity , final int swidth , final int sheight ) { final  Rectangle2 D area = entity . get Area ( ) ; calculate Offset ( swidth , sheight , ( int ) (  IGame Screen .  SIZE_ UNIT_ PIXELS * area . get Width ( ) ) , ( int ) (  IGame Screen .  SIZE_ UNIT_ PIXELS * area . get Height ( ) ) ) ; }
@  Override public boolean is Component Enabled (  Resolve Info resolve Info ) { if ( resolve Info != null && resolve Info . service Info != null && !  Text Utils . is Empty ( resolve Info . service Info . package Name ) ) { if ( m Permitted Package Names == null || is System App ( resolve Info . service Info . application Info ) ) { return _ BOOL ; } else { return m Permitted Package Names . contains ( resolve Info . service Info . package Name ) ; } } return _ BOOL ; }
private static  Pair <  String ,  String > pre Indexed LSR ( final long offset , final  ITranslation Environment environment , final  List <  Reil Instruction > instructions , final  String register Node Value1 , final  String register Node Value2 , final  String immediate Node Value ) { final  String address = environment . get Next Variable String ( ) ; final  String tmp Var1 = environment . get Next Variable String ( ) ; final  String tmp Var2 = environment . get Next Variable String ( ) ; final  String index = environment . get Next Variable String ( ) ; long base Offset = offset ; instructions . add (  Reil Helpers . create Bsh ( base Offset ++ , dw , register Node Value2 , dw , _ STR + immediate Node Value , qw , tmp Var1 ) ) ; instructions . add (  Reil Helpers . create And ( base Offset ++ , qw , tmp Var1 , dw , d Word Bit Mask , dw , index ) ) ; instructions . add (  Reil Helpers . create Add ( base Offset ++ , dw , register Node Value1 , dw , index , dw , tmp Var2 ) ) ; instructions . add (  Reil Helpers . create And ( base Offset ++ , dw , tmp Var2 , dw , d Word Bit Mask , dw , address ) ) ; instructions . add (  Reil Helpers . create Str ( base Offset ++ , dw , address , dw , register Node Value1 ) ) ; return new  Pair <  String ,  String > ( address , register Node Value1 ) ; }
public int ref Count ( ) { return ref Counter . ref Count ( ) ; }
public static boolean has Property (  String name ) { return get Property ( name ) != null ; }
public  Head Rule Map (  Input Stream in ) {  Buffered Reader reader =  IOUtils . create Buffered Reader ( in ) ;  String line , p Tag , dir , rule ;  String [ ] tmp ; try { while ( ( line = reader . read Line ( ) ) != null ) { tmp =  P_ COLUMN . split ( line ) ; p Tag = tmp [ _ NUM ] ; dir = tmp [ _ NUM ] ; rule = tmp [ _ NUM ] ; put ( p Tag , new  Head Rule ( dir , rule ) ) ; } } catch (  IOException e ) { e . print Stack Trace ( ) ; } }
public void test Pos Neg First Shorter ( ) { byte a Bytes [ ] = { - _ NUM , - _ NUM , - _ NUM , - _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM } ; byte b Bytes [ ] = { - _ NUM , _ NUM , _ NUM , _ NUM , - _ NUM , - _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , - _ NUM , _ NUM , _ NUM , - _ NUM , _ NUM , _ NUM , - _ NUM , - _ NUM } ; int a Sign = _ NUM ; int b Sign = - _ NUM ; byte r Bytes [ ] = { _ NUM , - _ NUM , - _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM } ;  Big Integer a Number = new  Big Integer ( a Sign , a Bytes ) ;  Big Integer b Number = new  Big Integer ( b Sign , b Bytes ) ;  Big Integer result = a Number . and ( b Number ) ; byte res Bytes [ ] = new byte [ r Bytes . length ] ; res Bytes = result . to Byte Array ( ) ; for ( int i = _ NUM ; i < res Bytes . length ; i ++ ) { assert True ( res Bytes [ i ] == r Bytes [ i ] ) ; } assert Equals ( _ STR , _ NUM , result . signum ( ) ) ; }
public <  T >  Future <  T > submit (  Callable <  T > task ) { return executor . submit ( task ) ; }
public void test Subtract Math Context Diff Scale Neg Pos ( ) {  String a = _ STR ; int a Scale = - _ NUM ;  String b = _ STR ; int b Scale = _ NUM ;  String c = _ STR ; int c Scale = - _ NUM ;  Big Decimal a Number = new  Big Decimal ( new  Big Integer ( a ) , a Scale ) ;  Big Decimal b Number = new  Big Decimal ( new  Big Integer ( b ) , b Scale ) ;  Math Context mc = new  Math Context ( _ NUM ,  Rounding Mode .  HALF_ DOWN ) ;  Big Decimal result = a Number . subtract ( b Number , mc ) ; assert Equals ( _ STR , c , result . to String ( ) ) ; assert Equals ( _ STR , c Scale , result . scale ( ) ) ; }
public void expand All ( ) { int row = _ NUM ; while ( row < get Row Count ( ) ) { expand Row ( row ) ; row ++ ; } }
public boolean read Bit ( ) throws  IOException { if ( bit Field == - _ NUM ) { bit Field = in . read ( ) ; if ( bit Field == - _ NUM ) { throw new  EOFException ( ) ; } mask = _ NUM ; } boolean bit = ( bit Field & mask ) != _ NUM ; if ( ( mask <<= _ NUM ) == _ NUM ) { bit Field = - _ NUM ; } return bit ; }
public static boolean is Empty (  String string ) { return string == null || string . is Empty ( ) ; }
public  Enumeration unused ( ) {  Vector un Used = new  Vector ( ) ;  Enumeration names = used . keys ( ) ; while ( names . has More Elements ( ) ) {  String name = (  String ) names . next Element ( ) ;  Boolean is Used = (  Boolean ) used . get ( name ) ; if ( ! is Used . boolean Value ( ) ) un Used . add Element ( name ) ; } return un Used . elements ( ) ; }
public  Point translate Java2 DTo Screen (  Point2 D java2 DPoint ) {  Insets insets = get Insets ( ) ; int x = ( int ) ( java2 DPoint . get X ( ) * this . scale X + insets . left ) ; int y = ( int ) ( java2 DPoint . get Y ( ) * this . scale Y + insets . top ) ; return new  Point ( x , y ) ; }
public void action Performed (  Action Event ev ) {  String font Name =  Program Properties . get ( _ STR , _ STR ) ; font Name =  JOption Pane . show Input Dialog ( _ STR , font Name ) ; if ( font Name != null ) { execute ( _ STR + font Name + _ STR ) ;  Program Properties . put ( _ STR , font Name ) ; } }
private void clear Old Traffic ( ) {  List <  Air Map Traffic > old All Traffic = new  Array List < > ( ) ; for (  Air Map Traffic traffic : all Traffic ) { if ( traffic Expired ( traffic ) ) { old All Traffic . add ( traffic ) ; all Traffic . remove ( traffic ) ; } } notify Removed ( old All Traffic ) ; }
public void print Stack Trace (  Print Stream output ) { synchronized ( output ) { super . print Stack Trace ( output ) ;  Throwable throwable = get Exception ( ) ; if ( throwable != null ) { output . print ( _ STR ) ; throwable . print Stack Trace ( output ) ; } } }
protected void paint Image (  Graphics g , int x , int y ) { if ( bg Image != null ) { do { int rc = bg Image . validate ( null ) ; if ( rc ==  Volatile Image .  IMAGE_ RESTORED ) { render Image ( bg Image . get Width ( ) , bg Image . get Height ( ) , get Scaling Hint ( ) ) ; } g . draw Image ( bg Image , x , y , null ) ; } while ( bg Image . contents Lost ( ) ) ; } }
public boolean on Menu Item Click (  Menu Item item ) ;
public void test Sub List And Non Structural Changes ( ) {  Copy On Write Array List <  String > list = new  Copy On Write Array List <  String > ( ) ; list . add All (  Arrays . as List ( _ STR , _ STR , _ STR , _ STR , _ STR ) ) ;  List <  String > bcd = list . sub List ( _ NUM , _ NUM ) ; list . set ( _ NUM , _ STR ) ; try { bcd . get ( _ NUM ) ; fail ( ) ; } catch (  Concurrent Modification Exception expected ) { } }
public void init ( ) { if ( ! _initialized ) { super . init ( ) ; _detect Panel = new  Detection Panel ( this ) ;  JPanel panel = new  JPanel ( ) ; panel . set Layout ( new  Box Layout ( panel ,  Box Layout .  Y_ AXIS ) ) ; panel . add (  Box . create Vertical Glue ( ) ) ; panel . add ( _detect Panel ) ; add ( panel , _ NUM ) ; } }
public  Set search Users (  String wildcard ) throws  AMException ,  SSOException { if ( ( wildcard == null ) || ( wildcard . length ( ) == _ NUM ) ) { throw new  AMException (  AMSDKBundle . get String ( _ STR , super . locale ) , _ STR ) ; }  Set <  String > result Set ;  Set <  String > users Set = get User DNs ( ) ; if ( wildcard . length ( ) == _ NUM ) { if ( wildcard . equals ( _ STR ) ) { result Set = users Set ; } else { throw new  AMException (  AMSDKBundle . get String ( _ STR , super . locale ) , _ STR ) ; } } else { result Set = new  Hash Set < > ( ) ; if ( wildcard . starts With ( _ STR ) ) {  String pattern = wildcard . substring ( _ NUM ) ; extract User DNs ( pattern , users Set , result Set ) ; } else if ( wildcard . ends With ( _ STR ) ) {  String pattern = wildcard . substring ( _ NUM , wildcard . length ( ) - _ NUM ) ; extract User DNs ( pattern , users Set , result Set ) ; } else { throw new  AMException (  AMSDKBundle . get String ( _ STR , super . locale ) , _ STR ) ; } } return result Set ; }
@  PUT @  Path ( _ STR ) @  Produces ( {  Media Type .  APPLICATION_ XML ,  Media Type .  APPLICATION_ JSON } ) @  Check Permission ( roles = {  Role .  TENANT_ ADMIN } ) public  Ip Interface Rest Rep update Ip Interface ( @  Path Param ( _ STR )  URI id ,  Ip Interface Update Param update Param ) throws  Database Exception {  Ip Interface ip Interface = query Object (  Ip Interface . class , id , _ BOOL ) ; _host Service . validate Ip Interface Data ( update Param , ip Interface ) ; _host Service . populate Ip Interface ( update Param , ip Interface ) ; _db Client . persist Object ( ip Interface ) ; audit Op (  Operation Type Enum .  UPDATE_ HOST_ IPINTERFACE , _ BOOL , null , ip Interface . audit Parameters ( ) ) ; return map ( query Object (  Ip Interface . class , id , _ BOOL ) ) ; }
protected  IContent Proposal [ ] content Proposals From (  List <  IEdit Proposal > edit Proposals ) {  IContent Proposal [ ] content Proposals = new  IContent Proposal [ edit Proposals . size ( ) ] ; for ( int i = _ NUM ; i < edit Proposals . size ( ) ; i ++ ) { content Proposals [ i ] = new  Edit Proposal Wrapper ( edit Proposals . get ( i ) ) ; } return content Proposals ; }
public  Extension Query (  String extension Point Name ,  String attribute Name ) {  Preconditions . check Argument ( extension Point Name . contains ( _ STR ) , _ STR ) ; this . plugin Id = null ; this . extension Point Name = extension Point Name ; this . attribute Name = attribute Name ; }
public  Image add Image (  String location ,  Image image ) { if ( m_max Image Width > - _ NUM || m_max Image Height > - _ NUM ) { image = get Scaled Image ( image ) ; image . get Width ( null ) ; } image Cache . put ( location , image ) ; return image ; }
public  String to String ( ) { if ( m_ Filtered Instances == null ) { return _ STR ; }  String result = _ STR + get Classifier Spec ( ) + _ STR + get Filter Spec ( ) + _ STR + m_ Filtered Instances . to String ( ) + _ STR + m_ Classifier . to String ( ) ; return result ; }
private double compute Correlation Coefficient ( int [ ] x , double [ ] y , int n ) { double sum X = _ NUM ; double sum Y = _ NUM ; double sum XY = _ NUM ; double sum X2 = _ NUM ; double sum Y2 = _ NUM ; for ( int i = _ NUM ; i < n ; i ++ ) { sum X += x [ i ] ; sum Y += y [ i ] ; sum XY += x [ i ] * y [ i ] ; sum X2 += x [ i ] * x [ i ] ; sum Y2 += y [ i ] * y [ i ] ; } final double bottom =  Math . sqrt ( ( n * sum X2 - sum X * sum X ) * ( n * sum Y2 - sum Y * sum Y ) ) ; if ( bottom == _ NUM ) return _ NUM ; final double top = n * sum XY - sum X * sum Y ; return top / bottom ; }
private static int [ ] validate Coordinates ( int x1 , int y1 , int x2 , int y2 ) { if ( ( x1 > x2 ) | ( y1 < y2 ) ) { if ( x1 > x2 ) { final int temp = x1 ; x1 = x2 ; x2 = temp ;  Log Writer . write Log ( _ STR ) ; } if ( y1 < y2 ) { final int temp = y1 ; y1 = y2 ; y2 = temp ;  Log Writer . write Log ( _ STR ) ; } } return new int [ ] { x1 , y1 , x2 , y2 } ; }
public synchronized  Panel remove All Components ( ) { for (  Component component : new  Array List <  Component > ( components ) ) { remove Component ( component ) ; } return this ; }
private int tailing Non Newline (  String str , int off , int len ) { for ( int cnt = _ NUM ; cnt < len ; cnt ++ ) { final int pos = off + ( len - _ NUM ) - cnt ; if ( str . char At ( pos ) ==  Output Stream Logger .  UNIX_ NEWLINE ) { return cnt ; } } return len ; }
@  Override public  String to String ( ) {  String Builder sb = new  String Builder ( name ) ; if ( has Description ( ) ) { sb . append ( _ STR ) ; sb . append ( description ) ; sb . append ( _ STR ) ; } return sb . to String ( ) ; }
public void test Signer ( ) {  Signer s = new  Signer Stub ( ) ; assert Not Null ( s ) ; assert Null ( s . get Private Key ( ) ) ; }
@  Safe Varargs public static <  K >  Map <  K , ? > map Of (  Map .  Entry <  K , ? > ... entries ) {  Hash Map <  K ,  Object > map = new  Hash Map < > ( ) ; for (  Map .  Entry <  K , ? > entry : entries ) { map . put ( entry . get Key ( ) , entry . get Value ( ) ) ; } return  Collections . unmodifiable Map ( map ) ; }
public static void sleep ( long sleep Time ) { try {  Thread . sleep ( sleep Time ) ; } catch (  Interrupted Exception e ) {  LOG . error ( _ STR ) ; } }
public static void mute Current Out And Err Stream ( ) { if ( already Muted ) { return ; }  Byte Array Output Stream byte Stream = new  Byte Array Output Stream ( ) ;  Print Stream out Stream = new  Print Stream ( byte Stream ) ; latest Out =  System . out ; latest Err =  System . err ;  System . set Out ( out Stream ) ;  System . set Err ( out Stream ) ; already Muted = _ BOOL ; }
public static  Big Integer [ ] convert List To Array (  List <  Big Integer > list ) {  Big Integer [ ] result = new  Big Integer [ list . size ( ) ] ; for ( int i = _ NUM ; i < list . size ( ) ; i ++ ) { result [ i ] = list . get ( i ) ; } return result ; }
private int measure Height ( int measure Spec ) { int result ; int spec Mode =  Measure Spec . get Mode ( measure Spec ) ; int spec Size =  Measure Spec . get Size ( measure Spec ) ; m Ascent = ( int ) m Text Paint . ascent ( ) ; if ( spec Mode ==  Measure Spec .  EXACTLY ) { result = spec Size ; } else { result = ( int ) ( - m Ascent + m Text Paint . descent ( ) ) + get Padding Top ( ) + get Padding Bottom ( ) ; if ( spec Mode ==  Measure Spec .  AT_ MOST ) { result =  Math . min ( result , spec Size ) ; } } return result ; }
public void test Zero Pos ( ) { byte a Bytes [ ] = { _ NUM } ; byte b Bytes [ ] = { - _ NUM , - _ NUM , - _ NUM , - _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM } ; int a Sign = _ NUM ; int b Sign = _ NUM ; byte r Bytes [ ] = { _ NUM , - _ NUM , - _ NUM , - _ NUM , - _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM } ;  Big Integer a Number = new  Big Integer ( a Sign , a Bytes ) ;  Big Integer b Number = new  Big Integer ( b Sign , b Bytes ) ;  Big Integer result = a Number . or ( b Number ) ; byte res Bytes [ ] = new byte [ r Bytes . length ] ; res Bytes = result . to Byte Array ( ) ; for ( int i = _ NUM ; i < res Bytes . length ; i ++ ) { assert True ( res Bytes [ i ] == r Bytes [ i ] ) ; } assert Equals ( _ STR , _ NUM , result . signum ( ) ) ; }
public  Query Task wait For Query Task (  URI uri ,  Task State .  Task Stage expected Stage ) {  List <  Task State .  Task Stage > final Task Stages =  Arrays . as List (  Task State .  Task Stage .  CANCELLED ,  Task State .  Task Stage .  FAILED ,  Task State .  Task Stage .  FINISHED , expected Stage ) ;  String error =  String . format ( _ STR , expected Stage ) ;  Object [ ] r = new  Object [ _ NUM ] ; final  URI final Uri = uri ; wait For ( error , null ) ; return (  Query Task ) r [ _ NUM ] ; }
@  Override public  String first Chunk (  List <  String > chunks ) { if ( chunks == null || chunks . size ( ) == _ NUM ) { return null ; } return chunks . get ( _ NUM ) ; }
void insert Function3 (  Byte Buffer bb ) { int base Sec = ( int ) ( window Id > > _ NUM ) ; bb . put Int ( base Sec ) ; short win Id = ( short ) ( window Id & _ NUM ) ; bb . put Short ( win Id ) ;  Integer oper Id = operator Id ; for ( int i = _ NUM ; i < _ NUM ; i ++ ) { byte num = ( byte ) ( oper Id > > _ NUM * ( _ NUM - i ) ) ; bb . put ( num ) ; } for ( int i = _ NUM ; i < _ NUM ; i ++ ) { byte num = ( byte ) ( tuple Id > > _ NUM * ( _ NUM - i ) ) ; bb . put ( num ) ; } }
static float distance (  Rectangle a ,  Rectangle b ) { float ax1 , ax2 , ay1 , ay2 ; float bx1 , bx2 , by1 , by2 ; ax1 = a . x ; ax2 = a . x + a . width ; ay1 = a . y ; ay2 = a . y + a . height ; bx1 = b . x ; bx2 = b . x + b . width ; by1 = b . y ; by2 = b . y + b . height ; float xdiff11 =  Math . abs ( ax1 - bx1 ) ; float xdiff12 =  Math . abs ( ax1 - bx2 ) ; float xdiff21 =  Math . abs ( ax2 - bx1 ) ; float xdiff22 =  Math . abs ( ax2 - bx2 ) ; float ydiff11 =  Math . abs ( ay1 - by1 ) ; float ydiff12 =  Math . abs ( ay1 - by2 ) ; float ydiff21 =  Math . abs ( ay2 - by1 ) ; float ydiff22 =  Math . abs ( ay2 - by2 ) ; float xmin =  Math . min (  Math . min ( xdiff11 , xdiff12 ) ,  Math . min ( xdiff21 , xdiff22 ) ) ; float ymin =  Math . min (  Math . min ( ydiff11 , ydiff12 ) ,  Math . min ( ydiff21 , ydiff22 ) ) ; boolean y Overlap = ay1 <= by2 && by1 <= ay2 ; boolean x Overlap = ax1 <= bx2 && bx1 <= ax2 ; float x Return = ( y Overlap ) ? xmin : ( float )  Math . hypot ( xmin , ymin ) ; float y Return = ( x Overlap ) ? ymin : ( float )  Math . hypot ( xmin , ymin ) ; return  Math . min ( x Return , y Return ) ; }
public boolean next Tile ( ) throws  Model Control Exception { boolean moved To Row = super . next Tile ( ) ; if ( moved To Row ) { cur Tile = get Tile Index ( ) ; set Display Field Value (  TXT_ INDEX ,  Integer . to String ( cur Tile ) ) ; set Display Field Value (  TXT_ BUTTON , buttons [ cur Tile ] ) ; set Display Field Value (  TXT_ CLASS , cur Tile == _ NUM ? _ STR : _ STR ) ; } return moved To Row ; }
public boolean has Working Misc (  Big Integer flag ) { return has Working Misc ( flag , - _ NUM ) ; }
private boolean is Voice Available ( ) {  Package Manager package Manager = m Context . get Package Manager ( ) ;  List <  Resolve Info > activities = package Manager . query Intent Activities ( new  Intent (  Recognizer Intent .  ACTION_ RECOGNIZE_ SPEECH ) , _ NUM ) ; return activities . size ( ) > _ NUM ; }
public static  String extract Server Url (  String url String ) { try {  URL url = new  URL ( url String ) ;  String result = url . get Protocol ( ) + _ STR + url . get Host ( ) ; if ( url . get Port ( ) != - _ NUM ) { result += _ STR + url . get Port ( ) ; } return result ; } catch (  Malformed URLException e ) { throw new  Illegal Argument Exception ( e ) ; } }
public static byte [ ] cert Hash (  X509 Certificate cert ) throws  Exception { return cert Hash ( cert . get Encoded ( ) ) ; }
@  Request Mapping ( value = { _ STR , _ STR } , method =  Request Method .  PUT ) @  Response Body public  Rest Wrapper insert ( @  Model Attribute ( _ STR ) @  Valid  Process Type process Type ,  Binding Result binding Result ,  Principal principal ) {  Rest Wrapper rest Wrapper = null ; if ( binding Result . has Errors ( ) ) {  Binding Result Error binding Result Error = new  Binding Result Error ( ) ; return binding Result Error . error Message ( binding Result ) ; } try { com . wipro . ats . bdre . md . dao . jpa .  Process Type jpa Process Type = new com . wipro . ats . bdre . md . dao . jpa .  Process Type ( ) ; jpa Process Type . set Process Type Id ( process Type . get Process Type Id ( ) ) ; jpa Process Type . set Parent Process Type Id ( process Type . get Parent Process Type Id ( ) ) ; jpa Process Type . set Process Type Name ( process Type . get Process Type Name ( ) ) ; process Type DAO . insert ( jpa Process Type ) ; rest Wrapper = new  Rest Wrapper ( process Type ,  Rest Wrapper .  OK ) ;  LOGGER . info ( _ STR + process Type . get Process Type Id ( ) + _ STR + principal . get Name ( ) + process Type ) ; } catch (  Metadata Exception e ) {  LOGGER . error ( e ) ; rest Wrapper = new  Rest Wrapper ( e . get Message ( ) ,  Rest Wrapper .  ERROR ) ; } return rest Wrapper ; }
public  Set <  Word Token > nearest Words ( final int distance ,  Predicate <  Dependency > predicate , final  Word Token ... start ) { return nearest Words ( distance , predicate ,  Arrays . as List ( start ) ) ; }
public  String generate Pair Name (  Block Object source ,  Block Object target ) {  String Builder pair Name = new  String Builder ( ) ; pair Name . append ( source . get Native Id ( ) ) ; pair Name . append (  HDSConstants .  UNDERSCORE_ OPERATOR ) ; pair Name . append ( target . get Native Id ( ) ) ; pair Name . append (  HDSConstants .  UNDERSCORE_ OPERATOR ) ; pair Name . append (  HDSConstants .  SI ) ; return pair Name . to String ( ) ; }
public  List <  Interval > insert (  List <  Interval > intervals ,  Interval new Interval ) {  List <  Interval > res = new  Array List < > ( ) ; res . add ( new Interval ) ; if ( intervals == null || intervals . size ( ) == _ NUM ) { return res ; } for (  Interval i : intervals ) { int start = res . get ( res . size ( ) - _ NUM ) . start ; int end = res . get ( res . size ( ) - _ NUM ) . end ; if ( i . end < start ) { res . add ( res . size ( ) - _ NUM , i ) ; } else if ( end < i . start ) { res . add ( i ) ; } else { start =  Math . min ( start , i . start ) ; end =  Math . max ( end , i . end ) ; res . set ( res . size ( ) - _ NUM , new  Interval ( start , end ) ) ; } } return res ; }
private static  String parse Version Number (  String line ) {  String Tokenizer tokenizer = new  String Tokenizer ( line , _ STR ) ; if ( ! expect ( tokenizer , _ STR ) || ! expect ( tokenizer , _ STR ) || ! tokenizer . has More Tokens ( ) ) { return null ; } return tokenizer . next Token ( ) ; }
public static  Key Store Handler create ( final  File key Store File , final char [ ] password ) throws  IOException ,  Key Store Exception { if ( key Store File == null ) { throw new  File Not Found Exception ( null ) ; } else if ( key Store File . exists ( ) ) { throw new  File Already Exists Exception ( key Store File . get Absolute Path ( ) ) ; } final  Key Store ks =  Key Store . get Instance (  Key Store Handler .  KEYSTORE_ TYPE ) ; try { ks . load ( null , password ) ; } catch ( final  No Such Algorithm Exception |  Certificate Exception ex ) { throw new  Illegal State Exception ( _ STR , ex ) ; } final  Secret Key Factory skf =  Key Store Handler . get Secret Key Factory ( ) ; final  Key Store Handler ksh = new  Key Store Handler ( ks , password , key Store File , skf , _ BOOL ) ; ksh . save ( ) ; return ksh ; }
public  State (  Plot Rendering Info info ) { super ( info ) ; }
public void register Drop Controller (  Drop Controller drop Controller ) { drop Controller List . add ( drop Controller ) ; }
private static  JCheck Box configure Check Box (  JCheck Box check Box ) { check Box . set Horizontal Alignment (  JCheck Box .  LEFT ) ; check Box . set Font (  UIManager . get Font ( _ STR ) ) ; check Box . set Border Painted ( _ BOOL ) ; check Box . set Focus Painted ( _ BOOL ) ; check Box . set Focusable ( _ BOOL ) ; check Box . set Opaque ( _ BOOL ) ; return check Box ; }
protected void process Window Event (  Window Event e ) { if ( e . get ID ( ) ==  Window Event .  WINDOW_ CLOSING ) { cancel ( ) ; } super . process Window Event ( e ) ; }
public void add Parameter ( final  String param Name , final  String param Value ) throws  Illegal Argument Exception {  LOG . trace ( _ STR ) ; if ( ( param Name == null ) || ( param Value == null ) ) { throw new  Illegal Argument Exception ( _ STR ) ; } super . clear Request Body ( ) ; params . add ( new  Name Value Pair ( param Name , param Value ) ) ; }
public abstract boolean handle Error ( @  Not Null  List <  String > message , @  Not Null  External System Exception error , @  Not Null  Notification Data notification , @  Not Null  Project project ) ;
public void engine Delete Entry (  String alias ) throws  Key Store Exception { permission Check ( ) ; synchronized ( entries ) {  Object entry = entries . remove ( alias . to Lower Case ( ) ) ; deleted Entries . put ( alias . to Lower Case ( ) , entry ) ; } }
public  Array Deque ( int num Elements ) { allocate Elements ( num Elements ) ; }
public final void print Initial Clustering Changes (  File file ,  List <  Cluster Data > cluster Data , int [ ] mat Index To Msg Internal Id ) throws  Ade Usage Exception { if ( m_initial Clusters == null ) { return ; } final  Print Writer out =  File Utils . open Print Writer To File ( file , _ BOOL ) ; if ( m_final Clusters == null ) { update Clusters ( cluster Data , mat Index To Msg Internal Id ) ; } int count No Change = _ NUM ; int count Contained = _ NUM ; for (  Map .  Entry <  String ,  Array List <  Integer > > entry : m_initial Clusters . entry Set ( ) ) { final  String name = entry . get Key ( ) ; final  Array List <  Integer > members = entry . get Value ( ) ; out . printf ( _ STR , name , members ) ; int count C = _ NUM ; boolean split Flag = _ BOOL ; final  Array List <  String > names = new  Array List <  String > ( ) ; for (  Map .  Entry <  String ,  Collection <  Integer > > new Entry : m_final Clusters . entry Set ( ) ) { final  Collection <  Integer > new Members = new Entry . get Value ( ) ; final  String new Name = new Entry . get Key ( ) ; int count M = _ NUM ; boolean update C = _ BOOL ; for ( int m : new Members ) { if ( members . contains ( mat Index To Msg Internal Id [ m ] ) ) { if ( update C ) { count C ++ ; update C = _ BOOL ; names . add ( new Name ) ; } count M ++ ; } } if ( count M == members . size ( ) ) { split Flag = _ BOOL ; if ( members . size ( ) == new Members . size ( ) ) { out . printf ( _ STR ) ; count No Change ++ ; } else { out . printf ( _ STR , new Name ) ; count Contained ++ ; } break ; } } if ( split Flag ) { out . printf ( _ STR , count C , names ) ; } } out . printf ( _ STR , count No Change , count Contained , m_initial Clusters . size ( ) - count No Change - count Contained ) ; out . close ( ) ; }
protected void add To GUI (  JPanel gui ,  Abstract Button b ,  String cmd ) { b . set Action Command ( cmd ) ; b . add Action Listener ( this ) ; gui . add ( b ) ; }
public void add (  String field Name ,  String value ) { if ( field Name == null ) throw new  Illegal Argument Exception ( _ STR ) ; if ( value == null ) throw new  Illegal Argument Exception ( _ STR ) ; if ( field Name . length ( ) == _ NUM || field Name . index Of ( _ STR ) != - _ NUM || value . index Of ( _ STR ) != - _ NUM ) { throw new  Illegal Argument Exception ( _ STR + field Name + _ STR + value ) ; } add Lenient ( field Name , value ) ; }
protected  Shape Tile offset_shape (  Polyline p_polyline , int p_half_width , int p_no ) { return p_polyline . offset_shape ( p_half_width , p_no ) ; }
public static void delete (  File file Or Folder ) { if ( file Or Folder != null ) delete ( file Or Folder . to Path ( ) ) ; }
public static double [ ] string Array To Double Array ( final  String [ ] line ) { double [ ] ret = new double [ line . length ] ; for ( int i = _ NUM ; i < line . length ; i ++ ) { ret [ i ] =  Double . parse Double ( line [ i ] ) ; } return ret ; }
@  Bean  Local Container Entity Manager Factory Bean entity Manager Factory (  Data Source data Source ,  Environment env ) {  Local Container Entity Manager Factory Bean entity Manager Factory Bean = new  Local Container Entity Manager Factory Bean ( ) ; entity Manager Factory Bean . set Data Source ( data Source ) ; entity Manager Factory Bean . set Jpa Vendor Adapter ( new  Hibernate Jpa Vendor Adapter ( ) ) ; entity Manager Factory Bean . set Packages To Scan (  ENTITY_ PACKAGES ) ;  Properties jpa Properties = new  Properties ( ) ; jpa Properties . put (  PROPERTY_ NAME_ HIBERNATE_ DIALECT , env . get Required Property (  PROPERTY_ NAME_ HIBERNATE_ DIALECT ) ) ; jpa Properties . put (  PROPERTY_ NAME_ HIBERNATE_ HBM2 DDL_ AUTO , env . get Required Property (  PROPERTY_ NAME_ HIBERNATE_ HBM2 DDL_ AUTO ) ) ; jpa Properties . put (  PROPERTY_ NAME_ HIBERNATE_ NAMING_ STRATEGY , env . get Required Property (  PROPERTY_ NAME_ HIBERNATE_ NAMING_ STRATEGY ) ) ; jpa Properties . put (  PROPERTY_ NAME_ HIBERNATE_ SHOW_ SQL , env . get Required Property (  PROPERTY_ NAME_ HIBERNATE_ SHOW_ SQL ) ) ; jpa Properties . put (  PROPERTY_ NAME_ HIBERNATE_ FORMAT_ SQL , env . get Required Property (  PROPERTY_ NAME_ HIBERNATE_ FORMAT_ SQL ) ) ; entity Manager Factory Bean . set Jpa Properties ( jpa Properties ) ; return entity Manager Factory Bean ; }
protected double decode ( int value , double lower , double upper , int nbits ) { int maxval = ( int ) (  Math . pow ( _ NUM , nbits ) - _ NUM ) ; return value * ( ( upper - lower ) / ( maxval - _ NUM ) ) + lower ; }
public int read ( byte b [ ] , int off , int len ) throws  IOException { if ( input Stream == null ) { throw new  IOException ( _ STR ) ; } int gotsofar = _ NUM ; while ( gotsofar < len ) { int read = input Stream . read ( b , off + gotsofar , len - gotsofar ) ; if ( read == - _ NUM ) { if ( gotsofar > _ NUM ) { count ( gotsofar ) ; return gotsofar ; } else { return read ; } } else { gotsofar += read ; } } count ( gotsofar ) ; return gotsofar ; }
public void handle Tbl DSAttribute Map List Button Add Request (  Request Invocation Event event ) throws  Model Control Exception { try {  Map values = get Values ( ) ; on Before Save Profile ( values ) ; set Page Session Attribute (  PROPERTY_ ATTRIBUTE , (  Hash Map ) values ) ;  WSPPService DSAttribute Map List Add View Bean vb = (  WSPPService DSAttribute Map List Add View Bean ) get View Bean (  WSPPService DSAttribute Map List Add View Bean . class ) ; unlock Page Trail ( ) ; pass Pg Session Map ( vb ) ; vb . forward To ( get Request Context ( ) ) ; } catch (  AMConsole Exception e ) { set Inline Alert Message (  CCAlert .  TYPE_ ERROR , _ STR , e . get Message ( ) ) ; forward To ( ) ; } }
final  V do Remove (  Object key ,  Object value ) { if ( key == null ) throw new  Null Pointer Exception ( ) ;  Comparator < ? super  K > cmp = comparator ; outer : for ( ; ; ) { for (  Node <  K ,  V > b = find Predecessor ( key , cmp ) , n = b . next ; ; ) {  Object v ; int c ; if ( n == null ) break outer ;  Node <  K ,  V > f = n . next ; if ( n != b . next ) break ; if ( ( v = n . value ) == null ) { n . help Delete ( b , f ) ; break ; } if ( b . value == null || v == n ) break ; if ( ( c = cpr ( cmp , key , n . key ) ) < _ NUM ) break outer ; if ( c > _ NUM ) { b = n ; n = f ; continue ; } if ( value != null && ! value . equals ( v ) ) break outer ; if ( ! n . cas Value ( v , null ) ) break ; if ( ! n . append Marker ( f ) || ! b . cas Next ( n , f ) ) find Node ( key ) ; else { find Predecessor ( key , cmp ) ; if ( head . right == null ) try Reduce Level ( ) ; } @  Suppress Warnings ( _ STR )  V vv = (  V ) v ; return vv ; } } return null ; }
void handle Swf Unloaded Event (  Swf Unloaded Event e ) { dump Swf Unloaded Line ( e ) ; }
@  Deprecated public  DCCpp Reply (  String message ) { super ( ) ; set Binary ( _ BOOL ) ; my Reply = new  String Builder ( message ) ; _n Data Chars = my Reply . length ( ) ; _data Chars = new int [ _n Data Chars ] ; }
@  Override protected synchronized void read ( long offset , byte [ ] b ) throws  IOException { if ( byte Buffer != null ) { byte Buffer . position ( ( int ) offset ) ; byte Buffer . get ( b ) ; } else { throw new  IOException ( _ STR + get Path ( ) + _ STR ) ; } }
@  Override public int hash Code ( ) { return  System . identity Hash Code ( this ) ; }
public void fill (  View view ) { validate Not Nullable View ( view ) ; try { if ( view instanceof  View Group ) {  View Group view Group = (  View Group ) view ; for ( int i = _ NUM ; i < view Group . get Child Count ( ) ; i ++ ) {  View child = view Group . get Child At ( i ) ; fill ( child ) ; } } else { if ( m Ids == null ) { fill View ( view ) ; } else if ( m Ids . contains ( view . get Id ( ) ) ) { fill View ( view ) ; } } } catch (  Exception e ) { e . print Stack Trace ( ) ; } finally { m Faker = null ; } }
public void clear Info Text ( int state ) throws  Auth Login Exception { if ( debug . message Enabled ( ) ) { debug . message ( _ STR + state ) ; } if ( state > state Length ) { throw new  Auth Login Exception ( bundle Name , _ STR , new  Object [ ] { new  Integer ( state ) } ) ; }  Callback [ ] ext = get Callback ( state ) ; if ( ext . length <= _ NUM ) { throw new  Auth Login Exception ( bundle Name , _ STR , null ) ; }  Page Properties Callback pc = (  Page Properties Callback ) ( (  Callback [ ] ) internal . get ( state - _ NUM ) ) [ _ NUM ] ;  List <  String > info Texts = pc . get Info Text ( ) ; for ( int i = _ NUM ; i < info Texts . size ( ) ; i ++ ) { info Texts . set ( i ,  EMPTY_ STRING ) ; } pc . set Info Text ( info Texts ) ; }
private  Calendar trim To Midnight (  Calendar calendar ) { calendar . set (  Calendar .  HOUR_ OF_ DAY , _ NUM ) ; calendar . set (  Calendar .  MINUTE , _ NUM ) ; calendar . set (  Calendar .  SECOND , _ NUM ) ; calendar . set (  Calendar .  MILLISECOND , _ NUM ) ; return calendar ; }
public boolean remove ( int location ,  Image Info object ) { final boolean removed = data . remove ( object ) ; notify Item Range Removed ( location , data . size ( ) ) ; return removed ; }
protected  List <  String > list User Names ( ) throws  Users Repository Exception {  Collection <  User > users = get All Users ( ) ;  List <  String > user Names = new  Array List <  String > ( users . size ( ) ) ; for (  User user : users ) { user Names . add ( user . get User Name ( ) ) ; } users . clear ( ) ; return user Names ; }
void delete Local Device (  Volume Info device Info ) throws  VPlex Api Exception {  String device Name =  VPlex Api Constants .  DEVICE_ PREFIX + device Info . get Volume Name ( ) ; delete Local Device ( device Name ) ; }
public static  String read String (  Data Input in ) throws  IOException { int length =  Writable Utils . read VInt ( in ) ; byte [ ] bytes = new byte [ length ] ; in . read Fully ( bytes , _ NUM , length ) ; return decode ( bytes ) ; }
public void interrupt ( ) {  Thread t = thread Var . get ( ) ; if ( t != null ) { t . interrupt ( ) ; } thread Var . clear ( ) ; }
private int show Has Changed Dialog ( ) {  Object [ ] options = { _ STR , _ STR , _ STR } ; return  JOption Pane . show Option Dialog ( frame , _ STR + _ STR , _ STR ,  JOption Pane .  YES_ NO_ OPTION ,  JOption Pane .  WARNING_ MESSAGE , null , options , options [ _ NUM ] ) ; }
public  Tv Show Update Datasource Task2 (  String datasource ) { super (  BUNDLE . get String ( _ STR ) + _ STR + datasource + _ STR ) ; tv Show List =  Tv Show List . get Instance ( ) ; data Sources = new  Array List < > ( _ NUM ) ; data Sources . add ( datasource ) ; }
protected  String read Response Line ( ) throws  IOException {  String line = read Line ( ) ; if ( line != null ) { int n = line . index Of ( _ STR ) ; if ( n != - _ NUM ) { line = _ STR + line . substring ( n ) ; } } return line ; }
public void add ( final  Sensor sensor ) {  Set <  Sensor > old Selection = new  Hash Set <  Sensor > ( selection ) ; boolean rv = selection . add ( sensor ) ; if ( rv ) { fire Selection Changed ( old Selection , selection ) ; } }
public static  File absolute File (  File file ) { if ( file != null ) { try { file = file . get Canonical File ( ) ; } catch (  IOException e ) { file = file . get Absolute File ( ) ; } } return file ; }
public synchronized void close ( ) { if ( socket != null && ! socket . is Closed ( ) ) { try { socket . close ( ) ; } catch (  IOException e ) { logger . warn ( e . get Message ( ) ) ; } } }
public  Message Tokenizer (  IMessage message ) { this ( message . get Client ( ) , message . get Content ( ) ) ; }
public  Hash ( byte [ ] hash ) { if ( hash . length != _ NUM ) { throw new  Illegal Argument Exception ( _ STR ) ; } this . bytes = new byte [ _ NUM ] ;  System . arraycopy ( hash , _ NUM , this . bytes , _ NUM , _ NUM ) ; }
public void label (  Way way ,  Enum Set <  Edge Store .  Edge Flag > forward Flags ,  Enum Set <  Edge Store .  Edge Flag > back Flags ) { if ( ! forward Flags . contains (  Edge Store .  Edge Flag .  ALLOWS_ CAR ) && ! back Flags . contains (  Edge Store .  Edge Flag .  ALLOWS_ CAR ) ) { forward Flags . add (  Edge Store .  Edge Flag .  BIKE_ LTS_1 ) ; back Flags . add (  Edge Store .  Edge Flag .  BIKE_ LTS_1 ) ; return ; } if ( way . has Tag ( _ STR , _ STR ) ) return ; if ( way . has Tag ( _ STR , _ STR ) || way . has Tag ( _ STR , _ STR ) ) { forward Flags . add (  Edge Store .  Edge Flag .  BIKE_ LTS_1 ) ; back Flags . add (  Edge Store .  Edge Flag .  BIKE_ LTS_1 ) ; return ; } boolean has Forward Lane = _ BOOL ; boolean has Backward Lane = _ BOOL ; if ( way . has Tag ( _ STR , _ STR ) ) { has Forward Lane = has Backward Lane = _ BOOL ; } if ( way . has Tag ( _ STR , _ STR ) || way . has Tag ( _ STR , _ STR ) || way . has Tag ( _ STR , _ STR ) ) { has Backward Lane = _ BOOL ; } if ( way . has Tag ( _ STR , _ STR ) || way . has Tag ( _ STR , _ STR ) ) { has Forward Lane = _ BOOL ; } double max Speed =  Double .  Na N ; if ( way . has Tag ( _ STR ) ) { max Speed = get Speed Kmh ( way . get Tag ( _ STR ) ) ; if (  Double . is Na N ( max Speed ) ) {  LOG . warn ( _ STR , way . get Tag ( _ STR ) ) ; } } int lanes =  Integer .  MAX_ VALUE ; if ( way . has Tag ( _ STR ) ) { try { lanes =  Integer . parse Int ( way . get Tag ( _ STR ) ) ; } catch (  Number Format Exception e ) {  LOG . warn ( _ STR , way . get Tag ( _ STR ) ) ; } }  Edge Store .  Edge Flag default Lts =  Edge Store .  Edge Flag .  BIKE_ LTS_3 ; if ( lanes <= _ NUM && max Speed <= _ NUM * _ NUM ) default Lts =  Edge Store .  Edge Flag .  BIKE_ LTS_2 ; if ( lanes ==  Integer .  MAX_ VALUE && max Speed <= _ NUM * _ NUM ) default Lts =  Edge Store .  Edge Flag .  BIKE_ LTS_2 ; if ( way . has Tag ( _ STR , _ STR ) || way . has Tag ( _ STR , _ STR ) || way . has Tag ( _ STR , _ STR ) ) { if ( lanes <= _ NUM &&  Double . is Na N ( max Speed ) ) default Lts =  Edge Store .  Edge Flag .  BIKE_ LTS_2 ; if ( has Forward Lane ) { forward Flags . add (  Edge Store .  Edge Flag .  BIKE_ LTS_2 ) ; } else { forward Flags . add ( default Lts ) ; } if ( has Backward Lane ) { back Flags . add (  Edge Store .  Edge Flag .  BIKE_ LTS_2 ) ; } else { back Flags . add ( default Lts ) ; } } else { if ( has Forward Lane ) { forward Flags . add ( default Lts ) ; } if ( has Backward Lane ) { back Flags . add ( default Lts ) ; } } if ( ! forward Flags . contains (  Edge Store .  Edge Flag .  BIKE_ LTS_1 ) && ! forward Flags . contains (  Edge Store .  Edge Flag .  BIKE_ LTS_2 ) && ! forward Flags . contains (  Edge Store .  Edge Flag .  BIKE_ LTS_3 ) && ! forward Flags . contains (  Edge Store .  Edge Flag .  BIKE_ LTS_4 ) ) forward Flags . add (  Edge Store .  Edge Flag .  BIKE_ LTS_4 ) ; if ( ! back Flags . contains (  Edge Store .  Edge Flag .  BIKE_ LTS_1 ) && ! back Flags . contains (  Edge Store .  Edge Flag .  BIKE_ LTS_2 ) && ! back Flags . contains (  Edge Store .  Edge Flag .  BIKE_ LTS_3 ) && ! back Flags . contains (  Edge Store .  Edge Flag .  BIKE_ LTS_4 ) ) back Flags . add (  Edge Store .  Edge Flag .  BIKE_ LTS_4 ) ; }
public void begin Display (  Display Event event ) throws  Model Control Exception { super . begin Display ( event ) ;  Server Site Model model = (  Server Site Model ) get Model ( ) ;  String server Name = (  String ) get Page Session Attribute (  PG_ ATTR_ SERVER_ NAME ) ;  Object [ ] param = { server Name } ; pt Model . set Page Title Text (  Message Format . format ( model . get Localized String ( _ STR ) , param ) ) ; set Display Field Value ( _ STR ,  Message Format . format ( model . get Localized String ( _ STR ) , param ) ) ; }
private static byte [ ] read Class ( final  Input Stream is ) throws  IOException { if ( is == null ) { throw new  IOException ( _ STR ) ; } byte [ ] b = new byte [ is . available ( ) ] ; int len = _ NUM ; while ( _ BOOL ) { int n = is . read ( b , len , b . length - len ) ; if ( n == - _ NUM ) { if ( len < b . length ) { byte [ ] c = new byte [ len ] ;  System . arraycopy ( b , _ NUM , c , _ NUM , len ) ; b = c ; } return b ; } len += n ; if ( len == b . length ) { byte [ ] c = new byte [ b . length + _ NUM ] ;  System . arraycopy ( b , _ NUM , c , _ NUM , len ) ; b = c ; } } }
public  String class Name Tip Text ( ) { return _ STR ; }
public  Joiner join (  Class < ? extends  Data Object > clazz ,  String alias ,  Data Object ... objs ) { return join ( clazz , alias , new  Array List <  Data Object > (  Arrays . as List ( objs ) ) ) ; }
public void close ( ) { }
public  Map <  Integer ,  Set <  String > > show Topology ( ) throws  Network Device Controller Exception {  Map <  Integer ,  Set <  String > > peer Devices Map = new  Hash Map <  Integer ,  Set <  String > > ( ) ;  SSHPrompt [ ] prompts = {  SSHPrompt .  POUND ,  SSHPrompt .  GREATER_ THAN } ;  String Builder buf = new  String Builder ( ) ; send Wait For (  MDSDialog Properties . get String ( _ STR ) , _ NUM , prompts , buf ) ;  String [ ] lines = get Lines ( buf ) ;  Integer vsan Id = null ;  String [ ] regex = {  MDSDialog Properties . get String ( _ STR ) ,  MDSDialog Properties . get String ( _ STR ) } ;  String [ ] groups = new  String [ _ NUM ] ; for (  String line : lines ) { int index = match ( line , regex , groups ) ; switch ( index ) { case _ NUM : vsan Id = new  Integer ( groups [ _ NUM ] ) ; break ; case _ NUM :  Set <  String > peer Devices Ip Addr = peer Devices Map . get ( vsan Id ) ; if ( peer Devices Ip Addr == null ) { peer Devices Ip Addr =  Sets . new Hash Set ( ) ; peer Devices Map . put ( vsan Id , peer Devices Ip Addr ) ; }  String peer Device = groups [ _ NUM ] + groups [ _ NUM ] ; peer Devices Ip Addr . add ( peer Device ) ; break ; } } return peer Devices Map ; }
public void reset ( ) { set Service (  OBD_ SVC_ NONE , _ BOOL ) ; cmd Queue . clear ( ) ; pid Supported . clear ( ) ; reset Fixed Pid ( ) ;  Pid Pvs . clear ( ) ; t Codes . clear ( ) ;  Vid Pvs . clear ( ) ; }
public  Quad Edge locate From Edge (  Vertex v ,  Quad Edge start Edge ) { int iter = _ NUM ; int max Iter = quad Edges . size ( ) ;  Quad Edge e = start Edge ; while ( _ BOOL ) { iter ++ ; if ( iter > max Iter ) { throw new  Locate Failure Exception ( e . to Line Segment ( ) ) ; } if ( ( v . equals ( e . orig ( ) ) ) || ( v . equals ( e . dest ( ) ) ) ) { break ; } else if ( v . right Of ( e ) ) { e = e . sym ( ) ; } else if ( ! v . right Of ( e . o Next ( ) ) ) { e = e . o Next ( ) ; } else if ( ! v . right Of ( e . d Prev ( ) ) ) { e = e . d Prev ( ) ; } else { break ; } } return e ; }
public void sort ( ) {  Collections . sort ( this . labels ) ; }
default  B with (  String key , boolean value ) { return with ( key ,  Boolean . to String ( value ) ) ; }
private void list Directory (  File directory ,  Relative Directory subdirectory ,  Set <  Java File Object .  Kind > file Kinds , boolean recurse ,  List Buffer <  Java File Object > result List ) {  File d = subdirectory . get File ( directory ) ; if ( ! case Map Check ( d , subdirectory ) ) return ;  File [ ] files = d . list Files ( ) ; if ( files == null ) return ; if ( sort Files != null )  Arrays . sort ( files , sort Files ) ; for (  File f : files ) {  String fname = f . get Name ( ) ; if ( f . is Directory ( ) ) { if ( recurse && is Valid Directory ( fname ) ) { list Directory ( directory , new  Relative Directory ( subdirectory , fname ) , file Kinds , recurse , result List ) ; } } else { if ( is Valid File ( fname , file Kinds ) ) {  Java File Object fe = new  Regular File Object ( this , fname , new  File ( d , fname ) ) ; result List . append ( fe ) ; } } } }
private  Shape decode Shadow ( int width , int height ) { path . reset ( ) ; path . move To ( width - _ NUM , _ NUM ) ; path . line To ( width - _ NUM , height - _ NUM ) ; path . line To ( width - _ NUM , height - _ NUM ) ; path . line To ( _ NUM , height - _ NUM ) ; path . line To ( _ NUM , height - _ NUM ) ; return path ; }
public static int test ( int a ) { return  Math . abs ( a ) ; }
public static  String create Resource Name (  String resource ,  Locale locale , boolean remove Extension ) {  String resource Name = resource ; if ( remove Extension ) { if ( resource Name . ends With ( _ STR ) ) { resource Name = resource Name . replace ( _ STR , _ STR ) ; } else if ( resource Name . ends With ( _ STR ) ) { resource Name = resource Name . replace ( _ STR , _ STR ) ; } } if ( locale != null ) { if (  Util Validate . is Not Empty ( locale . to String ( ) ) ) { resource Name = resource Name + _ STR + locale ; } } return resource Name ; }
@  Override public void read External (  Object Input in ) throws  IOException ,  Class Not Found Exception { super . read External ( in ) ; this . parent Distance = in . read Double ( ) ; }
public  Listener Id Map ( ) { this ( _ NUM , _ NUM ) ; }
public static  Connection Factory new Failover Connection Factory (  Set <  LDAPURL > servers ,  String username , char [ ] password , int heart Beat Interval ,  String heart Beat Time Unit ,  Options ldap Options ) {  List <  Connection Factory > factories = new  Array List <  Connection Factory > ( servers . size ( ) ) ; for (  LDAPURL ldapurl : servers ) { factories . add ( new Connection Factory ( ldapurl , username , password , heart Beat Interval , heart Beat Time Unit , ldap Options ) ) ; } return load Balance Factories ( factories ) ; }
public void add Arg ( final  BOp new Arg ) { if ( new Arg == null ) throw new  Illegal Argument Exception ( ) ; if ( new Arg == this ) throw new  Illegal Argument Exception ( ) ; args . add ( new Arg ) ; mutation ( ) ; }
boolean is Any State (  Element element ,  State ... states ) {  String ordinal Str = element . get Attribute (  ATTR_ STATE ) ; if ( ordinal Str == null ) { return _ BOOL ; } int ordinal = - _ NUM ; try { ordinal =  Integer . parse Int ( ordinal Str ) ; } catch (  Number Format Exception e ) { return _ BOOL ; } for (  State state : states ) { if ( ordinal == state . ordinal ( ) ) { return _ BOOL ; } } return _ BOOL ; }
public void paint Graph (  Graphics g ) { if ( graph Component != null ) {  Graphics2 D g2 = (  Graphics2 D ) g ;  Affine Transform tx = g2 . get Transform ( ) ; try { g2 . translate ( translate . x , translate . y ) ; g2 . scale ( scale , scale ) ; graph Component . paint Graph ( g2 , draw Labels ) ; } finally { g2 . set Transform ( tx ) ; } } }
public static  Abstract File Output Operator checkpoint (  Abstract File Output Operator writer , long window Id ) { if ( window Id >=  Stateless .  WINDOW_ ID ) { writer . before Checkpoint ( window Id ) ; }  Kryo kryo = new  Kryo ( ) ;  Byte Array Output Stream bos = new  Byte Array Output Stream ( ) ;  Output loutput = new  Output ( bos ) ; kryo . write Object ( loutput , writer ) ; loutput . close ( ) ;  Input l Input = new  Input ( bos . to Byte Array ( ) ) ; @  Suppress Warnings ( _ STR )  Abstract File Output Operator check Pointed Writer = kryo . read Object ( l Input , writer . get Class ( ) ) ; l Input . close ( ) ; return check Pointed Writer ; }
private static  String apply RFC2732 (  String hostname ) { if ( hostname . index Of ( _ STR ) != - _ NUM ) { return _ STR + hostname + _ STR ; } return hostname ; }
public  CAddress Space Configuration ( final  CAddress Space address Space , final  Address Space Configuration Backend provider , final int address Space Id , final  String name , final  String description , final  Date creation Date , final  Date modification Date , final  Debugger Template debugger Template ) { m_address Space = address Space ; m_provider = provider ; m_id = address Space Id ; m_name = name ; m_description = description ; m_creation Date = new  Date ( creation Date . get Time ( ) ) ; m_modification Date = new  Date ( modification Date . get Time ( ) ) ; m_debugger Template = debugger Template ; }
public  Shape screen To Chart Shape (  Shape s ) {  General Path p = new  General Path ( ) ;  Transform t =  Transform . make Identity ( ) ; if ( current Transform != null ) { t . concatenate ( current Transform . get Inverse ( ) ) ; } t . translate ( - get Absolute X ( ) , - get Absolute Y ( ) ) ; p . append ( s . get Path Iterator ( t ) , _ BOOL ) ; return p ; }
public static void load Window Properties (  Window window ) { on Load Position ( window ) ; }
public  Performance Logger (  String title ) { time1 =  System . current Time Millis ( ) ; }
private  String [ ] split Tfvc Collection Url ( final  String collection Url ) { final  String [ ] result = new  String [ _ NUM ] ; if (  String Utils . is Empty ( collection Url ) ) { return result ; } final  String trimmed Url =  Url Helper . trim Trailing Separators ( collection Url ) ; final int index = trimmed Url . last Index Of (  Url Helper .  URL_ SEPARATOR ) ; if ( index >= _ NUM ) { result [ _ NUM ] = trimmed Url . substring ( _ NUM , index + _ NUM ) ; result [ _ NUM ] = trimmed Url . substring ( index + _ NUM ) ; } else { result [ _ NUM ] = collection Url ; result [ _ NUM ] =  String Utils .  EMPTY ; } return result ; }
public static  Description describe ( final char [ ] pin ) { if ( pin == null || pin . length == _ NUM ) { return new  Description ( _ NUM ,  Enum Set . none Of (  Character Class . class ) ) ; }  Enum Set <  Character Class > classes =  Enum Set . none Of (  Character Class . class ) ; for ( char ch : pin ) { classes . add (  Character Class . of ( ch ) ) ; } return new  Description ( pin . length , classes ) ; }
public  String resolve Relative Uri (  String uri ) { if ( uri . starts With ( _ STR ) || uri . starts With (  File . separator ) ) { return uri ; } else { return base URI + uri ; } }
private boolean ends With Space (  String str ) { return str . length ( ) != _ NUM && str . char At ( str . length ( ) - _ NUM ) == _ STR ; }
public boolean enter ( ) throws  Keeper Exception ,  Interrupted Exception { zoo Keeper . create ( root Path + _ STR + name , new byte [ _ NUM ] ,  Ids .  OPEN_ ACL_ UNSAFE ,  Create Mode .  EPHEMERAL ) ; while ( _ BOOL ) { synchronized ( mutex ) {  List <  String > list = zoo Keeper . get Children ( root Path , _ BOOL ) ; if ( list . size ( ) < size ) { mutex . wait ( ) ; } else { return _ BOOL ; } } } }
public  Select Clause add (  Expression expression ,  String as Name ) { select List . add ( new  Select Clause Expression ( expression , as Name ) ) ; return this ; }
public void add Interface (  Soot Class interface Class ) { check Level (  HIERARCHY ) ; if ( implements Interface ( interface Class . get Name ( ) ) ) throw new  Runtime Exception ( _ STR + interface Class . get Name ( ) ) ; interfaces . add ( interface Class ) ; }
public static  String cut To Index Of (  String string ,  String substring ) { int i = string . index Of ( substring ) ; if ( i != - _ NUM ) { string = string . substring ( _ NUM , i ) ; } return string ; }
public static  Process Registry locate Registry ( int port ) throws  Registry Exception { try {  Registry registry =  Locate Registry . get Registry ( port ) ;  Process Registry process Registry = new  Process Registry ( port , registry ) ; return process Registry ; } catch (  Remote Exception e ) { throw new  Registry Exception ( _ STR + port + _ STR , e ) ; } }
public void test Iterator Ordering ( ) { final  Linked Blocking Queue q = new  Linked Blocking Queue ( _ NUM ) ; q . add ( one ) ; q . add ( two ) ; q . add ( three ) ; assert Equals ( _ NUM , q . remaining Capacity ( ) ) ; int k = _ NUM ; for (  Iterator it = q . iterator ( ) ; it . has Next ( ) ; ) { assert Equals ( ++ k , it . next ( ) ) ; } assert Equals ( _ NUM , k ) ; }
private boolean is Authorized (  Application User application User ,  String namespace ,  Namespace Permission Enum ... permissions ) { if ( application User != null && application User . get Namespace Authorizations ( ) != null ) { for (  Namespace Authorization current User Authorization : application User . get Namespace Authorizations ( ) ) {  List <  Namespace Permission Enum > current User Namespace Permissions = current User Authorization . get Namespace Permissions ( ) ; if ( current User Namespace Permissions == null ) { current User Namespace Permissions =  Collections . empty List ( ) ; } if (  String Utils . equals Ignore Case ( current User Authorization . get Namespace ( ) , namespace ) && current User Namespace Permissions . contains All (  Arrays . as List ( permissions ) ) ) { return _ BOOL ; } } } return _ BOOL ; }
private void add Tv Show (  Tv Show tv Show ) { synchronized ( root ) {  Default Mutable Tree Node tv Show Node = new  Tv Show Tree Node ( tv Show ) ; root . add ( tv Show Node ) ; node Map . put ( tv Show , tv Show Node ) ; for (  Tv Show Season season : new  Array List < > ( tv Show . get Seasons ( ) ) ) {  Tv Show Season Tree Node season Node = (  Tv Show Season Tree Node ) node Map . get ( season ) ; if ( season Node == null ) { add Tv Show Season ( season , tv Show ) ; } for (  Tv Show Episode episode : new  Array List < > ( season . get Episodes ( ) ) ) { add Tv Show Episode ( episode , season ) ; } } int index = get Index Of Child ( root , tv Show Node ) ; if ( index > - _ NUM ) {  Tree Model Event event = new  Tree Model Event ( this , root . get Path ( ) , new int [ ] { index } , new  Object [ ] { tv Show } ) ; for (  Tree Model Listener listener : listeners ) { try { listener . tree Nodes Inserted ( event ) ; } catch (  Null Pointer Exception |  Array Index Out Of Bounds Exception ignored ) { } } } } tv Show . add Property Change Listener ( property Change Listener ) ; }
public  Compliance Feature check Policy State ( org . wso2 . emm . agent . beans .  Operation operation ) throws  Android Agent Exception { policy = new  Compliance Feature ( ) ; policy . set Feature Code ( operation . get Code ( ) ) ; switch ( operation . get Code ( ) ) { case  Constants .  Operation .  CAMERA : return check Camera Policy ( operation ) ; case  Constants .  Operation .  INSTALL_ APPLICATION : return check Install App Policy ( operation ) ; case  Constants .  Operation .  UNINSTALL_ APPLICATION : return check Uninstall App Policy ( operation ) ; case  Constants .  Operation .  ENCRYPT_ STORAGE : return check Encrypt Policy ( operation ) ; case  Constants .  Operation .  PASSCODE_ POLICY : return check Password Policy ( ) ; case  Constants .  Operation .  WIFI : return check Wifi Policy ( operation ) ; case  Constants .  Operation .  WORK_ PROFILE : return check Work Profile Policy ( operation ) ; case  Constants .  Operation .  DISALLOW_ ADJUST_ VOLUME : case  Constants .  Operation .  DISALLOW_ CONFIG_ BLUETOOTH : case  Constants .  Operation .  DISALLOW_ CONFIG_ CELL_ BROADCASTS : case  Constants .  Operation .  DISALLOW_ CONFIG_ CREDENTIALS : case  Constants .  Operation .  DISALLOW_ CONFIG_ MOBILE_ NETWORKS : case  Constants .  Operation .  DISALLOW_ CONFIG_ TETHERING : case  Constants .  Operation .  DISALLOW_ CONFIG_ VPN : case  Constants .  Operation .  DISALLOW_ CONFIG_ WIFI : case  Constants .  Operation .  DISALLOW_ APPS_ CONTROL : case  Constants .  Operation .  DISALLOW_ CREATE_ WINDOWS : case  Constants .  Operation .  DISALLOW_ CROSS_ PROFILE_ COPY_ PASTE : case  Constants .  Operation .  DISALLOW_ DEBUGGING_ FEATURES : ; case  Constants .  Operation .  DISALLOW_ FACTORY_ RESET : case  Constants .  Operation .  DISALLOW_ ADD_ USER : case  Constants .  Operation .  DISALLOW_ INSTALL_ APPS : case  Constants .  Operation .  DISALLOW_ INSTALL_ UNKNOWN_ SOURCES : case  Constants .  Operation .  DISALLOW_ MODIFY_ ACCOUNTS : case  Constants .  Operation .  DISALLOW_ MOUNT_ PHYSICAL_ MEDIA : case  Constants .  Operation .  DISALLOW_ NETWORK_ RESET : case  Constants .  Operation .  DISALLOW_ OUTGOING_ BEAM : case  Constants .  Operation .  DISALLOW_ OUTGOING_ CALLS : case  Constants .  Operation .  DISALLOW_ REMOVE_ USER : case  Constants .  Operation .  DISALLOW_ SAFE_ BOOT : case  Constants .  Operation .  DISALLOW_ SHARE_ LOCATION : case  Constants .  Operation .  DISALLOW_ SMS : case  Constants .  Operation .  DISALLOW_ UNINSTALL_ APPS : case  Constants .  Operation .  DISALLOW_ UNMUTE_ MICROPHONE : case  Constants .  Operation .  DISALLOW_ USB_ FILE_ TRANSFER : case  Constants .  Operation .  ALLOW_ PARENT_ PROFILE_ APP_ LINKING : case  Constants .  Operation .  ENSURE_ VERIFY_ APPS : case  Constants .  Operation .  AUTO_ TIME : case  Constants .  Operation .  ENABLE_ ADMIN : case  Constants .  Operation .  SET_ SCREEN_ CAPTURE_ DISABLED : case  Constants .  Operation .  SET_ STATUS_ BAR_ DISABLED : if ( application Manager . is Package Installed (  Constants .  SERVICE_ PACKAGE_ NAME ) ) {  Common Utils . call System App ( context , operation . get Code ( ) ,  Boolean . to String ( operation . is Enabled ( ) ) , null ) ; policy . set Compliance ( _ BOOL ) ; return policy ; } else { throw new  Android Agent Exception ( _ STR ) ; } case  Constants .  Operation .  APP_ RESTRICTION : return check App Restriction Policy ( operation ) ; default : throw new  Android Agent Exception ( _ STR ) ; } }
public static boolean is Uniform Collection (  Collection < ? > c ,  Class < ? > e ) { if ( e == null ) { throw new  Illegal Argument Exception ( _ STR ) ; } if ( c == null ) { throw new  Illegal Argument Exception ( _ STR ) ; } if ( c . is Empty ( ) ) { return _ BOOL ; } for (  Object o : c ) { if ( o == null || ! e . is Assignable From ( o . get Class ( ) ) ) { return _ BOOL ; } } return _ BOOL ; }
public void close ( ) { if ( datagram Socket != null ) { datagram Socket . close ( ) ; } }
private boolean check Board ( ) { for (  Nine Switches Game Switch game Switch : switches ) { if ( game Switch . get State ( ) == _ NUM ) { return _ BOOL ; } } return _ BOOL ; }
public boolean are Nodes Reachable (  List <  Vdc Config > vdc List , boolean is All Not Reachable ) { if ( vdc List == null || vdc List . is Empty ( ) ) { throw new  Illegal State Exception ( _ STR ) ; } for (  Vdc Config vdc : vdc List ) { if ( ! are Nodes Reachable ( vdc . get Short Id ( ) , vdc . get Host IPv4 Addresses Map ( ) , vdc . get Host IPv6 Addresses Map ( ) , is All Not Reachable ) ) { return _ BOOL ; } } return _ BOOL ; }
public void add Handler (  String target ,  Synchronous Callback handler ) { handlers . put ( target , handler ) ; }
protected char [ ] normalize ( final char [ ] path ) throws  URIException { if ( path == null ) { return null ; }  String normalized = new  String ( path ) ; if ( normalized . starts With ( _ STR ) ) { normalized = normalized . substring ( _ NUM ) ; } else if ( normalized . starts With ( _ STR ) ) { normalized = normalized . substring ( _ NUM ) ; } else if ( normalized . starts With ( _ STR ) ) { normalized = normalized . substring ( _ NUM ) ; } int index = - _ NUM ; while ( ( index = normalized . index Of ( _ STR ) ) != - _ NUM ) { normalized = normalized . substring ( _ NUM , index ) + normalized . substring ( index + _ NUM ) ; } if ( normalized . ends With ( _ STR ) ) { normalized = normalized . substring ( _ NUM , normalized . length ( ) - _ NUM ) ; } int start Index = _ NUM ; while ( ( index = normalized . index Of ( _ STR , start Index ) ) != - _ NUM ) { final int slash Index = normalized . last Index Of ( _ STR , index - _ NUM ) ; if ( slash Index >= _ NUM ) { normalized = normalized . substring ( _ NUM , slash Index ) + normalized . substring ( index + _ NUM ) ; } else { start Index = index + _ NUM ; } } if ( normalized . ends With ( _ STR ) ) { final int slash Index = normalized . last Index Of ( _ STR , normalized . length ( ) - _ NUM ) ; if ( slash Index >= _ NUM ) { normalized = normalized . substring ( _ NUM , slash Index + _ NUM ) ; } } while ( ( index = normalized . index Of ( _ STR ) ) != - _ NUM ) { final int slash Index = normalized . last Index Of ( _ STR , index - _ NUM ) ; if ( slash Index >= _ NUM ) { break ; } else { normalized = normalized . substring ( index + _ NUM ) ; } } if ( normalized . ends With ( _ STR ) ) { final int slash Index = normalized . last Index Of ( _ STR , normalized . length ( ) - _ NUM ) ; if ( slash Index < _ NUM ) { normalized = _ STR ; } } return normalized . to Char Array ( ) ; }
private void sync Setting (  Web Settings settings ) { settings . set Geolocation Enabled ( enable Geolocation ( ) ) ; settings . set Java Script Enabled ( enable Javascript ( ) ) ; settings . set Light Touch Enabled ( enable Light Touch ( ) ) ; settings . set Nav Dump ( enable Nav Dump ( ) ) ; settings . set Default Text Encoding Name ( get Default Text Encoding ( ) ) ; settings . set Minimum Font Size ( get Minimum Font Size ( ) ) ; settings . set Minimum Logical Font Size ( get Minimum Font Size ( ) ) ; settings . set Text Zoom ( get Text Zoom ( ) ) ; settings . set Layout Algorithm ( get Layout Algorithm ( ) ) ; settings . set Java Script Can Open Windows Automatically ( ! block Popup Windows ( ) ) ; settings . set Loads Images Automatically ( load Images ( ) ) ; settings . set Load With Overview Mode ( load Page In Overview Mode ( ) ) ; settings . set Save Password ( remember Passwords ( ) ) ; settings . set Use Wide View Port ( is Wide Viewport ( ) ) ; settings . set Do Not Track ( do Not Track ( ) ) ; settings . set Night Mode Enabled ( is Night Mode Enabled ( ) ) ; settings . set Media Playback Requires User Gesture ( _ BOOL ) ;  Web Settings settings Classic = (  Web Settings ) settings ; settings Classic . set Hardware Accel Skia Enabled ( is Skia Hardware Accelerated ( ) ) ; settings Classic . set Show Visual Indicator ( enable Visual Indicator ( ) ) ; settings Classic . set Force User Scalable ( force Enable User Scalable ( ) ) ; settings Classic . set Double Tap Zoom ( get Double Tap Zoom ( ) ) ; settings Classic . set Auto Fill Enabled ( is Autofill Enabled ( ) ) ; boolean use Inverted = use Inverted Rendering ( ) ; settings Classic . set Property (  Web View Properties . gfx Inverted Screen , use Inverted ? _ STR : _ STR ) ; if ( use Inverted ) { settings Classic . set Property (  Web View Properties . gfx Inverted Screen Contrast ,  Float . to String ( get Inverted Contrast ( ) ) ) ; } if ( is Debug Enabled ( ) ) { settings Classic . set Property (  Web View Properties . gfx Enable Cpu Upload Path , enable Cpu Upload Path ( ) ? _ STR : _ STR ) ; } settings Classic . set Link Prefetch Enabled ( m Link Prefetch Allowed ) ; }
public void remove Web Event Listener (  String type ,  Action Listener listener ) {  Event Dispatcher e = get Event Dispatcher ( type , _ BOOL ) ; if ( e != null ) { e . remove Listener ( listener ) ; if ( ! e . has Listeners ( ) ) { listeners . remove ( type ) ; } } }
public int pixel For ( int rgb ) { return surface Type . pixel For ( rgb , color Model ) ; }
private boolean check For Carry ( char [ ] ca1 , int icarry ) { boolean carry = _ BOOL ; if ( icarry < ca1 . length ) { if ( ca1 [ icarry ] == _ STR || ca1 [ icarry ] == _ STR || ca1 [ icarry ] == _ STR || ca1 [ icarry ] == _ STR ) carry = _ BOOL ; else if ( ca1 [ icarry ] == _ STR ) { int ii = icarry + _ NUM ; for ( ; ii < ca1 . length ; ii ++ ) if ( ca1 [ ii ] != _ STR ) break ; carry = ii < ca1 . length ; if ( ! carry && icarry > _ NUM ) { carry = ( ca1 [ icarry - _ NUM ] == _ STR || ca1 [ icarry - _ NUM ] == _ STR || ca1 [ icarry - _ NUM ] == _ STR || ca1 [ icarry - _ NUM ] == _ STR || ca1 [ icarry - _ NUM ] == _ STR ) ; } } } return carry ; }
public  Text Component ( ) { }
public static void ensure Directory (  String ... file Paths ) { if ( file Paths != null ) {  File file ; for (  String file Path : file Paths ) { file = new  File ( file Path ) ; if ( file . exists ( ) && ! file . is Directory ( ) ) { throw new  Illegal Argument Exception ( _ STR + file . get Absolute Path ( ) ) ; } else if ( ! file . exists ( ) ) { if ( ! file . mkdirs ( ) ) { throw new  Illegal State Exception ( _ STR + file . get Absolute Path ( ) ) ; } } } } }
public static void create Dir If Not Exists (  File dir ) throws  IOException { if ( ! dir . exists ( ) && ! dir . mkdirs ( ) ) { throw new  IOException ( _ STR + dir . to String ( ) ) ; } }
public static boolean is Empty (  Char Sequence cs ) { return cs == null || cs . length ( ) == _ NUM ; }
private boolean done (  Type type ) { return visited . contains ( type ) ; }
public void register Text Flavor Properties (  String nat ,  String charset ,  String eoln ,  String terminators ) {  Long format = get Format For Native As Long ( nat ) ; text Natives . add ( format ) ; native Charsets . put ( format , ( charset != null && charset . length ( ) != _ NUM ) ? charset : get Default Text Charset ( ) ) ; if ( eoln != null && eoln . length ( ) != _ NUM && ! eoln . equals ( _ STR ) ) { native EOLNs . put ( format , eoln ) ; } if ( terminators != null && terminators . length ( ) != _ NUM ) {  Integer i Terminators =  Integer . value Of ( terminators ) ; if ( i Terminators . int Value ( ) > _ NUM ) { native Terminators . put ( format , i Terminators ) ; } } }
protected void shift Gap ( int new Gap Start ) { if ( new Gap Start == g0 ) { return ; } int old Gap Start = g0 ; int dg = new Gap Start - old Gap Start ; int old Gap End = g1 ; int new Gap End = old Gap End + dg ; int gap Size = old Gap End - old Gap Start ; g0 = new Gap Start ; g1 = new Gap End ; if ( dg > _ NUM ) {  System . arraycopy ( array , old Gap End , array , old Gap Start , dg ) ; } else if ( dg < _ NUM ) {  System . arraycopy ( array , new Gap Start , array , new Gap End , - dg ) ; } }
public static  String pad ( int padding ) { if ( padding > _ NUM ) {  String Buffer sb = new  String Buffer ( padding ) ; for ( int i = _ NUM ; i < padding ; i ++ ) { sb . append ( _ STR ) ; } return sb . to String ( ) ; } else { return _ STR ; } }
public static void draw Angled String (  Graphics g ,  String text , int x , int y , double angle ) {  Graphics2 D g2 D = (  Graphics2 D ) g ;  Affine Transform old At = g2 D . get Transform ( ) ;  Affine Transform at = new  Affine Transform ( old At ) ; at . rotate ( angle , x , y ) ; g2 D . set Transform ( at ) ; g2 D . draw String ( text , x , y ) ; g2 D . set Transform ( old At ) ; }
public void add Listener (  Tracking Listener listener ) { listeners . add ( listener ) ; }
public void add Muted Mac ( final  String mac , final  Date mute Till ) { if ( is Mac Muted ( mac ) ) { remove Muted Mac ( mac ) ; }  Timestamp mute Till Ts = null ; if ( mute Till != null ) { mute Till Ts = new  Timestamp ( mute Till . get Time ( ) ) ; } s_logger . fine ( _ STR + mac ) ; final  Connection con =  Database . get Connection ( ) ; try { final  Prepared Statement ps = con . prepare Statement ( _ STR ) ; ps . set String ( _ NUM , mac ) ; ps . set Timestamp ( _ NUM , mute Till Ts ) ; ps . execute ( ) ; ps . close ( ) ; con . commit ( ) ; } catch ( final  SQLException sqle ) { if ( sqle . get Error Code ( ) == _ NUM ) { s_logger . info ( _ STR + mac + _ STR + sqle . get Message ( ) ) ; return ; } s_logger . log (  Level .  SEVERE , _ STR + mac , sqle ) ; throw new  Illegal State Exception ( sqle . get Message ( ) ) ; } finally {  Db Util . close Connection ( con ) ; } }
private  Response <  Bitmap > do Parse (  Network Response response ) { byte [ ] data = response . data ;  Bitmap Factory .  Options decode Options = new  Bitmap Factory .  Options ( ) ;  Bitmap bitmap = null ; if ( m Max Width == _ NUM && m Max Height == _ NUM ) { decode Options . in Preferred Config = m Decode Config ; bitmap =  Bitmap Factory . decode Byte Array ( data , _ NUM , data . length , decode Options ) ; } else { decode Options . in Just Decode Bounds = _ BOOL ;  Bitmap Factory . decode Byte Array ( data , _ NUM , data . length , decode Options ) ; int actual Width = decode Options . out Width ; int actual Height = decode Options . out Height ; int desired Width = get Resized Dimension ( m Max Width , m Max Height , actual Width , actual Height ) ; int desired Height = get Resized Dimension ( m Max Height , m Max Width , actual Height , actual Width ) ; decode Options . in Just Decode Bounds = _ BOOL ; decode Options . in Sample Size = find Best Sample Size ( actual Width , actual Height , desired Width , desired Height ) ;  Bitmap temp Bitmap =  Bitmap Factory . decode Byte Array ( data , _ NUM , data . length , decode Options ) ; if ( temp Bitmap != null && ( temp Bitmap . get Width ( ) > desired Width || temp Bitmap . get Height ( ) > desired Height ) ) { bitmap =  Bitmap . create Scaled Bitmap ( temp Bitmap , desired Width , desired Height , _ BOOL ) ; temp Bitmap . recycle ( ) ; } else { bitmap = temp Bitmap ; } } if ( bitmap == null ) { return  Response . error ( new  Parse Error ( response ) ) ; } else { return  Response . success ( bitmap ,  Http Header Parser . parse Cache Headers ( response ) ) ; } }
public boolean is Empty ( ) { return list . is Empty ( ) ; }
@  Override public void close ( ) throws  IOException { if ( ! closed ) { finish ( ) ; inf . end ( ) ; out . close ( ) ; closed = _ BOOL ; } }
public static void to Parcelable Collection (  Collection < ? > source ,  Collection <  Parcelable > target ) { for (  Object o : source ) { target . add ( as Parcelable ( o ) ) ; } }
public void next Bytes ( byte [ ] bytes ) { final int length = bytes . length ; for ( int i = _ NUM ; i < length ; ) { for ( int rnd = next Int ( ) , n =  Math . min ( length - i ,  INTEGER_ SIZE /  BYTE_ SIZE ) ; n -- > _ NUM ; rnd >>=  BYTE_ SIZE ) { bytes [ i ++ ] = ( byte ) rnd ; } } }
private void draw Low Far Out ( double a Radius ,  Graphics2 D g2 , double xx , double m ) { double side = a Radius * _ NUM ; g2 . draw ( new  Line2 D .  Double ( xx - side , m - side , xx + side , m - side ) ) ; g2 . draw ( new  Line2 D .  Double ( xx - side , m - side , xx , m ) ) ; g2 . draw ( new  Line2 D .  Double ( xx + side , m - side , xx , m ) ) ; }
private  Set <  Object Instance > object Instances From Filtered Named Objects (  Set <  Named Object > list ,  Query Exp query ) {  Set <  Object Instance > result = new  Hash Set <  Object Instance > ( ) ; if ( query == null ) { for (  Named Object no : list ) { final  Dynamic MBean obj = no . get Object ( ) ; final  String class Name = safe Get Class Name ( obj ) ; result . add ( new  Object Instance ( no . get Name ( ) , class Name ) ) ; } } else {  MBean Server old Server =  Query Eval . get MBean Server ( ) ; query . set MBean Server ( server ) ; try { for (  Named Object no : list ) { final  Dynamic MBean obj = no . get Object ( ) ; boolean res ; try { res = query . apply ( no . get Name ( ) ) ; } catch (  Exception e ) { res = _ BOOL ; } if ( res ) {  String class Name = safe Get Class Name ( obj ) ; result . add ( new  Object Instance ( no . get Name ( ) , class Name ) ) ; } } } finally { query . set MBean Server ( old Server ) ; } } return result ; }
private  Element create Indexed End Point (  String name ,  String attr Binding ,  String attr Location ,  String attr Response Location , int index ,  Boolean is Default ) throws  DOMException { if ( name == null ) { throw new  Illegal Argument Exception ( _ STR ) ; } if ( attr Binding == null ) { throw new  Illegal Argument Exception ( _ STR ) ; } if ( attr Location == null ) { throw new  Illegal Argument Exception ( _ STR ) ; }  Element indexed End Pt = doc . create Element ( name ) ; indexed End Pt . set Attribute (  SAMLNames .  BINDING , attr Binding ) ; indexed End Pt . set Attribute (  SAMLNames .  LOCATION , attr Location ) ; if ( attr Response Location != null ) { indexed End Pt . set Attribute (  SAMLNames .  RESPLOC , attr Response Location ) ; } indexed End Pt . set Attribute (  SAMLNames .  INDEX ,  String . value Of ( index ) ) ; if ( is Default != null ) { indexed End Pt . set Attribute (  SAMLNames .  ISDEFAULT , is Default . to String ( ) ) ; } return indexed End Pt ; }
public static void copy File (  String src Path ,  String dest Path ) throws  Exception {  File src File = new  File ( src Path ) ;  File dest File = new  File ( dest Path ) ; if ( ! src File . exists ( ) ) { throw new  Exception ( _ STR ) ; }  String src File Location = src File . get Absolute Path ( ) ;  String dest File Location = dest File . get Absolute Path ( ) ; if ( src File Location . equals ( dest File Location ) ) { throw new  Exception ( _ STR ) ; }  Input Stream input = new  File Input Stream ( src File ) ;  Output Stream output = new  File Output Stream ( dest File ) ; byte [ ] buf = new byte [ _ NUM ] ; int length ; while ( ( length = input . read ( buf ) ) > _ NUM ) { output . write ( buf , _ NUM , length ) ; } input . close ( ) ; output . close ( ) ; }
public  String to String ( ) {  String Buffer buffer = new  String Buffer ( ) ; buffer . append ( to String ( get Class ( ) ) ) ; buffer . append ( _ STR ) ; buffer . append ( is Use Default ( ) ) ; buffer . append ( _ STR ) ; buffer . append ( element Converter . to String ( ) ) ; buffer . append ( _ STR ) ; return buffer . to String ( ) ; }
public void test_multiple Resource Locking_resources10_locktries10_predeclare Locks ( ) throws  Exception {  Properties properties = new  Properties ( ) ; properties . set Property (  Test Options .  NTHREADS , _ STR ) ; properties . set Property (  Test Options .  NTASKS , _ STR ) ; properties . set Property (  Test Options .  NRESOURCES , _ STR ) ; properties . set Property (  Test Options .  MIN_ LOCKS , _ STR ) ; properties . set Property (  Test Options .  MAX_ LOCKS , _ STR ) ; properties . set Property (  Test Options .  MAX_ LOCK_ TRIES , _ STR ) ; properties . set Property (  Test Options .  PREDECLARE_ LOCKS , _ STR ) ; properties . set Property (  Test Options .  SORT_ LOCK_ REQUESTS , _ STR ) ;  Result result = do Comparison Test ( properties ) ; assert Equals ( _ STR , _ STR , result . get ( _ STR ) ) ; }
public static byte [ ] flatten Bitmap (  Bitmap bitmap ) { int size = bitmap . get Width ( ) * bitmap . get Height ( ) * _ NUM ;  Byte Array Output Stream out = new  Byte Array Output Stream ( size ) ; try { bitmap . compress (  Bitmap .  Compress Format .  PNG , _ NUM , out ) ; out . flush ( ) ; out . close ( ) ; return out . to Byte Array ( ) ; } catch (  IOException e ) {  Log . w (  TAG , _ STR ) ; return null ; } }
public static  String generate String From Template (  File template File ,  Map <  String ,  Object > parameters ) { try {  Template template = get Template ( template File ) ;  Writable finished Template = template . make ( parameters ) ; return finished Template . to String ( ) ; } catch (  Exception e ) {  Doc Reporter . print Error ( _ STR + template File ) ;  Doc Reporter . print Error ( e . get Message ( ) ) ; throw new  Runtime Exception ( e ) ; } }
@  Override public  Enumeration <  Option > list Options ( ) {  Vector <  Option > new Vector = new  Vector <  Option > ( _ NUM ) ; new Vector . add Element ( new  Option ( _ STR , _ STR , _ NUM , _ STR ) ) ; new Vector . add Element ( new  Option ( _ STR + _ STR , _ STR , _ NUM , _ STR ) ) ; new Vector . add Element ( new  Option ( _ STR , _ STR , _ NUM , _ STR ) ) ; new Vector . add Element ( new  Option ( _ STR , _ STR , _ NUM , _ STR ) ) ; return new Vector . elements ( ) ; }
public void add (  Node node ) { available Nodes . add ( node ) ; }
public static int [ ] expand ( int [ ] field , int new Size , boolean keep Data ) { if ( field == null || field . length < new Size ) { int [ ] new Array = new int [ new Size ] ; if ( keep Data && field != null ) {  System . arraycopy ( field , _ NUM , new Array , _ NUM , field . length ) ; } return new Array ; } return field ; }
public void add Module (  Module module ) { module . setup Module ( new  Module Context Impl ( ) ) ; modules . add ( module ) ; }
private static void expand2 Digit Number (  String number String ,  Word Relation word Relation ) { if ( number String . char At ( _ NUM ) == _ STR ) { if ( number String . char At ( _ NUM ) == _ STR ) { } else {  String number = digit2num [ number String . char At ( _ NUM ) - _ STR ] ; word Relation . add Word ( number ) ; } } else if ( number String . char At ( _ NUM ) == _ STR ) {  String number = digit2enty [ number String . char At ( _ NUM ) - _ STR ] ; word Relation . add Word ( number ) ; } else if ( number String . char At ( _ NUM ) == _ STR ) {  String number = digit2teen [ number String . char At ( _ NUM ) - _ STR ] ; word Relation . add Word ( number ) ; } else {  String enty = digit2enty [ number String . char At ( _ NUM ) - _ STR ] ; word Relation . add Word ( enty ) ; expand Digits ( number String . substring ( _ NUM , number String . length ( ) ) , word Relation ) ; } }
public static void put Range (  Byte Buffer buffer , int start , int end , byte b ) { for ( int i = start ; i < end ; ++ i ) { buffer . put ( i , b ) ; } }
@  Override public boolean is Enabled ( ) { if ( ( attribute Selection Panel != null ) && ! is Value Only ( ) ) { return attribute Selection Panel . is Enabled ( ) ; } else { if ( this . check Box != null ) { return check Box . is Enabled ( ) ; } } return _ BOOL ; }
public double pdf ( double x ) { double diff = x - mean ; return  SQRT_ INV *  Math . exp ( - ( diff * diff ) / ( _ NUM * variance ) ) ; }
boolean is User ALocal Admin Or Not Closed (  Request And Response request And Response ) throws  IOException { if ( is User ALocal Admin ( request And Response ) ) { return _ BOOL ; } if ( ! is User Signed In ( request And Response ) ) { request And Response . print ( servlet Text . error Requires Sign In ( _ BOOL ) ) ; return _ BOOL ; } else if ( is Users Account Closed ( request And Response ) ) { request And Response . print ( servlet Text . error Account Is Closed ( ) ) ; return _ BOOL ; } return _ BOOL ; }
public void add Point (  Location location ) { points . add ( location ) ; }
public boolean add Soft Wrap Change Listener ( @  Not Null  Soft Wrap Change Listener listener ) { return my Listeners . add ( listener ) ; }
static public  Input Stream find Cluster XSLSchema (  String _cluster XSLSchema ) throws  Cluster Configuration Exception {  String schema Name To Be Used = _cluster XSLSchema ; if ( schema Name To Be Used . equals Ignore Case (  Cluster XML .  CLUSTER_ SCHEMA_ NAME_ PARTITIONED_ SYNC2 BACKUP ) ) schema Name To Be Used =  Cluster XML .  CLUSTER_ SCHEMA_ NAME_ PARTITIONED ;  Input Stream schema Input Stream ;  String schema File Path =  Constants .  Container .  CONTAINER_ CONFIG_ DIRECTORY + _ STR +  Constants .  Schemas .  SCHEMAS_ FOLDER + _ STR + schema Name To Be Used +  Cluster XML .  CLUSTER_ SCHEMA_ XSL_ FILE_ SUFFIX ; schema Input Stream = get Resource Stream ( schema File Path ) ; if ( schema Input Stream != null ) { if ( _logger . is Loggable (  Level .  FINE ) ) { _logger . fine ( _ STR + get Resource URL ( schema File Path ) + _ STR ) ; } return schema Input Stream ; } else {  String missing Schema Msg = _ STR + _cluster XSLSchema ; throw new  Cluster Configuration Exception ( missing Schema Msg ) ; } }
public static  Async World wrap (  World world ) { if ( world instanceof  Async World ) { return (  Async World ) world ; } return new  Async World ( world , _ BOOL ) ; }
public void clear ( ) {  Arrays . fill ( ritems , _ NUM , rsize , null ) ;  Arrays . fill ( pitems , _ NUM , psize , null ) ; rsize = _ NUM ; psize = _ NUM ; psorted = _ BOOL ; }
public void position ( long pos ) { set Current Position ( pos ) ; }
public void print String (  String v , int str Offset , int length ) throws  IOException { int offset = _offset ; byte [ ] buffer = _buffer ; for ( int i = _ NUM ; i < length ; i ++ ) { if (  SIZE <= offset + _ NUM ) { _offset = offset ; flush Buffer ( ) ; offset = _offset ; } char ch = v . char At ( i + str Offset ) ; if ( ch < _ NUM ) buffer [ offset ++ ] = ( byte ) ( ch ) ; else if ( ch < _ NUM ) { buffer [ offset ++ ] = ( byte ) ( _ NUM + ( ( ch > > _ NUM ) & _ NUM ) ) ; buffer [ offset ++ ] = ( byte ) ( _ NUM + ( ch & _ NUM ) ) ; } else { buffer [ offset ++ ] = ( byte ) ( _ NUM + ( ( ch > > _ NUM ) & _ NUM ) ) ; buffer [ offset ++ ] = ( byte ) ( _ NUM + ( ( ch > > _ NUM ) & _ NUM ) ) ; buffer [ offset ++ ] = ( byte ) ( _ NUM + ( ch & _ NUM ) ) ; } } _offset = offset ; }
protected  String generate Label String (  Category Dataset dataset , int row , int column ) {  Param Checks . null Not Permitted ( dataset , _ STR ) ;  String result ;  Object [ ] items = create Item Array ( dataset , row , column ) ; result =  Message Format . format ( this . label Format , items ) ; return result ; }
abstract protected void do Fade Out ( ) ;
public static  Command Result exec Command (  List <  String > commands , boolean is Root ,  String path ) { return exec Command ( commands == null ? null : commands . to Array ( new  String [ ] { } ) , is Root , _ BOOL , path ) ; }
public void load (  File file ) throws  IOException {  Input Stream in Stream = new  File Input Stream ( file ) ; properties . load ( in Stream ) ; }
@  Override public  String [ ] apply (  String [ ] words ) { if ( ! is Applicable ( ) ) return words ; for ( int i = _ NUM ; i < _col List . length ; i ++ ) { int col ID = _col List [ i ] ; try { double val =  Util Functions . parse To Double ( words [ col ID - _ NUM ] ) ; int binid = _ NUM ; double tmp = _min [ i ] + _bin Widths [ i ] ; while ( val > tmp && binid < _num Bins [ i ] ) { tmp += _bin Widths [ i ] ; binid ++ ; } words [ col ID - _ NUM ] =  Integer . to String ( binid ) ; } catch (  Number Format Exception e ) { throw new  Runtime Exception ( _ STR + words [ col ID - _ NUM ] + _ STR + col ID + _ STR + words [ col ID - _ NUM ] + _ STR ) ; } } return words ; }
public boolean is Empty ( ) { synchronized ( actions ) { if ( allow To Change ) { return actions . is Empty ( ) ; } } return _ BOOL ; }
public int count ( ) { return dict . size ( ) ; }
public static  Object [ ] [ ] form Object Array ( double [ ] [ ] data ) {  Object [ ] [ ] object = new  Double [ data . length ] [ data [ _ NUM ] . length ] ; for ( int i = _ NUM ; i < object . length ; i ++ ) { for ( int j = _ NUM ; j < object [ i ] . length ; j ++ ) { object [ i ] [ j ] = new  Double ( data [ i ] [ j ] ) ; } } return object ; }
protected void on Exception ( final  Exception e ) {  LOG . info ( _ STR , e . get Message ( ) ) ;  LOG . debug ( _ STR , e ) ; }
public int session ( ) { return  Integer . parse Int ( fields [ _ NUM ] ) ; }
public static void move File ( final  File src , final  File dst ) throws  IOException { copy File ( src , dst ) ; src . delete ( ) ; }
public  Map (  Pokemon Go api ) { this . api = api ; cached Map Objects = new  Map Objects ( api ) ; last Map Update = _ NUM ; }
public void test Sorts According Number Of Children ( ) throws  Exception {  Xpp Dom dom1 =  Xpp Factory . build Dom ( _ STR ) ;  Xpp Dom dom2 =  Xpp Factory . build Dom ( _ STR ) ; assert Equals ( - _ NUM , comparator . compare ( dom1 , dom2 ) ) ; assert Equals ( _ STR , xpath . get ( ) ) ; assert Equals ( _ NUM , comparator . compare ( dom2 , dom1 ) ) ; assert Equals ( _ STR , xpath . get ( ) ) ; }
public static void keep Alive ( final boolean keep Alive ) { set Property ( _ STR ,  Boolean . to String ( keep Alive ) ) ; }
private  Method Type remove Wrapper (  Method Type target Type ) {  Class [ ] types = target Type . parameter Array ( ) ; for ( int i = _ NUM ; i < types . length ; i ++ ) { if ( types [ i ] ==  Wrapper . class ) { target Type = target Type . change Parameter Type ( i ,  Object . class ) ; } } return target Type ; }
public void remove Values (  Set <  Object > values ) { action Values . remove All ( values ) ; }
private void sort ( int column Index , int sort Count ) {  Sort Order order =  Sort Order . values ( ) [ sort Count % _ NUM ] ;  List <  Row Sorter .  Sort Key > sort Keys = new  Array List < > ( ) ; if ( column Index != _ NUM ) { sort Keys . add ( new  Row Sorter .  Sort Key ( _ NUM ,  Sort Order .  DESCENDING ) ) ; } sort Keys . add ( new  Row Sorter .  Sort Key ( column Index , order ) ) ; sorter . set Sort Keys ( sort Keys ) ; this . sort Count = sort Count ; sorted Column = column Index ; }
private void upload ( ) throws  Exception { final  String zookeeper Url = topology Properties . get Property (  Kafka With ZKComponent .  ZOOKEEPER_ PROPERTY ) ; try (  Curator Framework client = get Client ( zookeeper Url ) ) { client . start ( ) ; upload Global Config ( client ) ; upload Profiler Config ( client ) ; } }
public void add Cell ( final  String cell Content ) { tool Tip . append ( _ STR ) ; tool Tip . append ( cell Content ) ; tool Tip . append ( _ STR ) ; }
public static void copy Properties (  Properties from ,  Properties to ) {  Enumeration <  Object > keys = from . keys ( ) ; while ( keys . has More Elements ( ) ) {  String key = (  String ) keys . next Element ( ) ; to . put ( key , from . get Property ( key ) ) ; } }
@  Override public void close ( ) throws  IOException { if ( in != null ) { in . close ( ) ; in = null ; buf = null ; } }
private static  SSLSocket Factory trust All Hosts (  Https URLConnection connection ) {  SSLSocket Factory old Factory = connection . get SSLSocket Factory ( ) ; try {  SSLContext sc =  SSLContext . get Instance ( _ STR ) ; sc . init ( null , trust All Certs , new java . security .  Secure Random ( ) ) ;  SSLSocket Factory new Factory = sc . get Socket Factory ( ) ; connection . set SSLSocket Factory ( new Factory ) ; } catch (  Exception e ) {  Log . e (  LOG_ TAG , e . get Message ( ) , e ) ; } return old Factory ; }
private float over Scroll Up ( int delta Y , int range ) { delta Y =  Math . max ( delta Y , _ NUM ) ; float current Top Amount = get Current Over Scroll Amount ( _ BOOL ) ; float new Top Amount = current Top Amount - delta Y ; if ( current Top Amount > _ NUM ) { set Over Scroll Amount ( new Top Amount , _ BOOL , _ BOOL ) ; } float scroll Amount = new Top Amount < _ NUM ? - new Top Amount : _ NUM ; float new Scroll Y = m Own Scroll Y + scroll Amount ; if ( new Scroll Y > range ) { if ( ! m Expanded In This Motion ) { float current Bottom Pixels = get Current Over Scrolled Pixels ( _ BOOL ) ; set Over Scrolled Pixels ( current Bottom Pixels + new Scroll Y - range , _ BOOL , _ BOOL ) ; } m Own Scroll Y = range ; scroll Amount = _ NUM ; } return scroll Amount ; }
public void test Creation Ambiguous ( ) {  Instances data ;  Array List <  Attribute > atts ;  String rel Name ; rel Name = _ STR ; atts = new  Array List <  Attribute > ( ) ; atts . add ( new  Attribute ( _ STR ) ) ; atts . add ( new  Attribute ( _ STR ) ) ; atts . add ( new  Attribute ( _ STR , _ STR ) ) ; atts . add ( new  Attribute ( _ STR , new  Array List <  String > (  Arrays . as List ( new  String [ ] { _ STR , _ STR , _ STR } ) ) ) ) ; atts . add ( new  Attribute ( _ STR , new  Array List <  String > (  Arrays . as List ( new  String [ ] { _ STR , _ STR } ) ) ) ) ; atts . add ( new  Attribute ( _ STR , (  Array List <  String > ) null ) ) ; try { data = new  Instances ( rel Name , atts , _ NUM ) ; } catch (  Illegal Argument Exception e ) { data = null ; } assert Null ( _ STR , data ) ; }
private void init Panel ( ) { final  JPanel main Panel = new  JPanel ( new  Border Layout ( ) ) ; main Panel . set Border ( new  Titled Border ( _ STR ) ) ; final  JPanel input Panel = new  JPanel ( new  Border Layout ( ) ) ; input Panel . set Border ( new  Empty Border ( _ NUM , _ NUM , _ NUM , _ NUM ) ) ; m_input Field . set Preferred Size ( new  Dimension ( m_input Field . get Preferred Size ( ) . width , _ NUM ) ) ; input Panel . add ( m_input Field ,  Border Layout .  NORTH ) ; final  JPanel checkboxes Panel = new  JPanel ( new  Grid Layout ( _ NUM , _ NUM ) ) ; checkboxes Panel . set Border ( new  Empty Border ( _ NUM , _ NUM , _ NUM , _ NUM ) ) ; checkboxes Panel . add ( m_case Sensitive Box ) ; checkboxes Panel . add ( m_reg Ex Box ) ; input Panel . add ( checkboxes Panel ,  Border Layout .  CENTER ) ; main Panel . add ( input Panel ,  Border Layout .  NORTH ) ; add ( main Panel ,  Border Layout .  CENTER ) ; }
public byte [ ] generate ( ) {  Dex Options options = new  Dex Options ( ) ; options . target Api Level =  Dex Format .  API_ NO_ EXTENDED_ OPCODES ;  Dex File output Dex = new  Dex File ( options ) ; for (  Type Declaration type Declaration : types . values ( ) ) { output Dex . add ( type Declaration . to Class Def Item ( ) ) ; } try { return output Dex . to Dex ( null , _ BOOL ) ; } catch (  IOException e ) { throw new  Runtime Exception ( e ) ; } }
public  String add Highlight (  String channel ,  String comment ) { if ( channel == null || channel . is Empty ( ) || !  Helper . is Regular Channel ( channel ) ) { return _ STR ; }  Stream Info stream Info = api . get Stream Info (  Helper . to Stream ( channel ) , null ) ;  String stream Time = _ STR ; if ( stream Info . is Valid ( ) && stream Info . get Online ( ) ) { stream Time =  Date Time . ago ( stream Info . get Time Started ( ) ) ; } if ( comment == null ) { comment = _ STR ; }  String line =  String . format ( _ STR ,  Date Time . full Date Time ( ) , channel , stream Time , comment ) ; synchronized ( this ) { if ( stream Info . get Time Started ( ) != last Stream Start Written ) { add To File ( _ STR ) ; } boolean success = add To File ( line ) ; if ( success ) { last Stream Start Written = stream Info . get Time Started ( ) ;  String short Comment = _ STR ; if ( ! comment . is Empty ( ) ) { short Comment = _ STR +  String Util . shorten To ( comment , _ NUM ) + _ STR ; } return _ STR + channel + _ STR + stream Time + _ STR + short Comment ; } return _ STR ; } }
public void add Elements (  List <  Select Clause Element > select Clause Elements ) { select List . add All ( select Clause Elements ) ; }
public static double standard Normal Pdf ( double x ) { double a = _ NUM / (  Math . sqrt ( _ NUM *  Math .  PI ) ) ; double b = - ( x ) * ( x ) / ( _ NUM ) ; return a *  Math . exp ( b ) ; }
public  List <  Integer > finish ( boolean right ) { if ( ! active || right != this . right ) { return null ; } else if ( slots . is Empty ( ) ) { return null ; } else {  List <  Integer > result = new  Array List < > ( slots ) ; reset ( ) ; return result ; } }
public static boolean is Numeric Type Specifier ( char c , boolean is Decimal ) { if ( is Decimal ) { switch ( c ) { case _ STR : case _ STR : case _ STR : case _ STR : case _ STR : case _ STR : return _ BOOL ; } } else { switch ( c ) { case _ STR : case _ STR : case _ STR : case _ STR : case _ STR : case _ STR : return _ BOOL ; } } return _ BOOL ; }
public static boolean is Hidden ( final  String key ) { return key . starts With (  HIDDEN_ PREFIX ) ; }
public  Array List <  String > parse Column Names ( ) {  Array List <  String > columns = new  Array List <  String > ( ) ;  Token token = scan Token ( ) ; if ( token ==  Token .  LPAREN ) { do { columns . add ( parse Identifier ( ) ) ; token = scan Token ( ) ; } while ( token ==  Token .  COMMA ) ; if ( token !=  Token .  RPAREN ) { throw error ( _ STR , token ) ; } } else if ( token ==  Token .  IDENTIFIER ) { columns . add ( _lexeme ) ; _token = token ; } else { throw error ( _ STR , token ) ; } return columns ; }
String to String (  Class < ? > [ ] types ) {  String Builder result = new  String Builder ( ) ; if ( types . length != _ NUM ) { append Type Name ( result , types [ _ NUM ] ) ; for ( int i = _ NUM ; i < types . length ; i ++ ) { result . append ( _ STR ) ; append Type Name ( result , types [ i ] ) ; } } return result . to String ( ) ; }
public static double incomplete Beta Fraction2 ( double a , double b , double x ) { double xk , pk , pkm1 , pkm2 , qk , qkm1 , qkm2 ; double k1 , k2 , k3 , k4 , k5 , k6 , k7 , k8 ; double r , t , ans , z , thresh ; int n ; k1 = a ; k2 = b - _ NUM ; k3 = a ; k4 = a + _ NUM ; k5 = _ NUM ; k6 = a + b ; k7 = a + _ NUM ; ; k8 = a + _ NUM ; pkm2 = _ NUM ; qkm2 = _ NUM ; pkm1 = _ NUM ; qkm1 = _ NUM ; z = x / ( _ NUM - x ) ; ans = _ NUM ; r = _ NUM ; n = _ NUM ; thresh = _ NUM *  MACHEP ; do { xk = - ( z * k1 * k2 ) / ( k3 * k4 ) ; pk = pkm1 + pkm2 * xk ; qk = qkm1 + qkm2 * xk ; pkm2 = pkm1 ; pkm1 = pk ; qkm2 = qkm1 ; qkm1 = qk ; xk = ( z * k5 * k6 ) / ( k7 * k8 ) ; pk = pkm1 + pkm2 * xk ; qk = qkm1 + qkm2 * xk ; pkm2 = pkm1 ; pkm1 = pk ; qkm2 = qkm1 ; qkm1 = qk ; if ( qk != _ NUM ) r = pk / qk ; if ( r != _ NUM ) { t =  Math . abs ( ( ans - r ) / r ) ; ans = r ; } else t = _ NUM ; if ( t < thresh ) return ans ; k1 += _ NUM ; k2 -= _ NUM ; k3 += _ NUM ; k4 += _ NUM ; k5 += _ NUM ; k6 += _ NUM ; k7 += _ NUM ; k8 += _ NUM ; if ( (  Math . abs ( qk ) +  Math . abs ( pk ) ) > big ) { pkm2 *= biginv ; pkm1 *= biginv ; qkm2 *= biginv ; qkm1 *= biginv ; } if ( (  Math . abs ( qk ) < biginv ) || (  Math . abs ( pk ) < biginv ) ) { pkm2 *= big ; pkm1 *= big ; qkm2 *= big ; qkm1 *= big ; } } while ( ++ n < _ NUM ) ; return ans ; }
private  String read Value ( char delimiter , boolean resolve Entities , boolean throw On Resolve Failure ,  Value Context value Context ) throws  IOException ,  Xml Pull Parser Exception { int start = position ;  String Builder result = null ; if ( value Context ==  Value Context .  TEXT && text != null ) { result = new  String Builder ( ) ; result . append ( text ) ; } while ( _ BOOL ) { if ( position >= limit ) { if ( start < position ) { if ( result == null ) { result = new  String Builder ( ) ; } result . append ( buffer , start , position - start ) ; } if ( ! fill Buffer ( _ NUM ) ) { return result != null ? result . to String ( ) : _ STR ; } start = position ; } char c = buffer [ position ] ; if ( c == delimiter || ( delimiter == _ STR && ( c <= _ STR || c == _ STR ) ) || c == _ STR && ! resolve Entities ) { break ; } if ( c != _ STR && ( c != _ STR || value Context !=  Value Context .  ATTRIBUTE ) && c != _ STR && c != _ STR && ( c != _ STR || value Context !=  Value Context .  TEXT ) && ( c != _ STR || value Context !=  Value Context .  ENTITY_ DECLARATION ) ) { is Whitespace &= ( c <= _ STR ) ; position ++ ; continue ; } if ( result == null ) { result = new  String Builder ( ) ; } result . append ( buffer , start , position - start ) ; if ( c == _ STR ) { if ( ( position + _ NUM < limit || fill Buffer ( _ NUM ) ) && buffer [ position + _ NUM ] == _ STR ) { position ++ ; } c = ( value Context ==  Value Context .  ATTRIBUTE ) ? _ STR : _ STR ; } else if ( c == _ STR ) { c = _ STR ; } else if ( c == _ STR ) { is Whitespace = _ BOOL ; read Entity ( result , _ BOOL , throw On Resolve Failure , value Context ) ; start = position ; continue ; } else if ( c == _ STR ) { if ( value Context ==  Value Context .  ATTRIBUTE ) { check Relaxed ( _ STR ) ; } is Whitespace = _ BOOL ; } else if ( c == _ STR ) { if ( ( position + _ NUM < limit || fill Buffer ( _ NUM ) ) && buffer [ position + _ NUM ] == _ STR && buffer [ position + _ NUM ] == _ STR ) { check Relaxed ( _ STR ) ; } is Whitespace = _ BOOL ; } else if ( c == _ STR ) { throw new  Xml Pull Parser Exception ( _ STR , this , null ) ; } else { throw new  Assertion Error ( ) ; } position ++ ; result . append ( c ) ; start = position ; } if ( result == null ) { return string Pool . get ( buffer , start , position - start ) ; } else { result . append ( buffer , start , position - start ) ; return result . to String ( ) ; } }
private  Configuration Provider ( ) { throw new  Assertion Error ( ) ; }
public boolean is Empty ( ) { return children == null || children . is Empty ( ) ; }
private void overshadow Rect ( final  Rectangle2 D rect , final  Graphics2 D g ) {  Graphics2 D g2 = (  Graphics2 D ) g . create ( ) ; g2 . set Color (  GRAY_ OUT ) ; g2 . fill ( rect ) ; g2 . dispose ( ) ; }
public static void stop (  Thread thread ) { if ( thread != null ) { thread . interrupt ( ) ; } }
private void write Object (  Object Output Stream s ) throws java . io .  IOException { s . default Write Object ( ) ; s . write Object ( to String ( ) ) ; }
public static  Container center (  Component center ) { return  Container . enclose In ( new  Border Layout ( ) , center ,  Border Layout .  CENTER ) ; }
public static  Object [ ] put All ( ) { try {  Region region = cache . get Region (  Region .  SEPARATOR +  REGION_ NAME ) ; assert Not Null ( region ) ;  Map map = new  Linked Hash Map ( ) ; map . put (  PUTALL_ KEY1 , _ STR ) ; map . put (  PUTALL_ KEY2 , _ STR ) ; map . put (  PUTALL_ KEY3 , _ STR ) ; map . put (  PUTALL_ KEY4 , _ STR ) ; map . put (  PUTALL_ KEY5 , _ STR ) ; region . put All ( map ) ;  Thread . sleep ( _ NUM ) ;  Event ID [ ] evids = new  Event ID [ _ NUM ] ; evids [ _ NUM ] = put Allevent Id1 ; evids [ _ NUM ] = put Allevent Id2 ; evids [ _ NUM ] = put Allevent Id3 ; evids [ _ NUM ] = put Allevent Id4 ; evids [ _ NUM ] = put Allevent Id5 ; assert Not Null ( evids [ _ NUM ] ) ; assert Not Null ( evids [ _ NUM ] ) ; assert Not Null ( evids [ _ NUM ] ) ; assert Not Null ( evids [ _ NUM ] ) ; assert Not Null ( evids [ _ NUM ] ) ; return evids ; } catch (  Exception e ) { fail ( _ STR , e ) ; } return null ; }
private void tab Created In Foreground ( int id , int source Id , boolean new Is Incognito , float origin X , float origin Y ) {  Layout Tab new Layout Tab = create Layout Tab ( id , new Is Incognito ,  NO_ CLOSE_ BUTTON ,  NO_ TITLE ) ; if ( m Layout Tabs == null || m Layout Tabs . length == _ NUM ) { m Layout Tabs = new  Layout Tab [ ] { new Layout Tab } ; } else { m Layout Tabs = new  Layout Tab [ ] { m Layout Tabs [ _ NUM ] , new Layout Tab } ; } update Cache Visible Ids ( new  Linked List <  Integer > (  Arrays . as List ( id , source Id ) ) ) ; new Layout Tab . set Border Alpha ( _ NUM ) ; new Layout Tab . set Static To View Blend ( _ NUM ) ; force Animation To Finish ( ) ;  Interpolator interpolator =  Baked Bezier Interpolator .  TRANSFORM_ CURVE ; add To Animation ( new Layout Tab ,  Layout Tab .  Property .  SCALE , _ NUM , _ NUM ,  FOREGROUND_ ANIMATION_ DURATION , _ NUM , _ BOOL , interpolator ) ; add To Animation ( new Layout Tab ,  Layout Tab .  Property .  ALPHA , _ NUM , _ NUM ,  FOREGROUND_ ANIMATION_ DURATION , _ NUM , _ BOOL , interpolator ) ; add To Animation ( new Layout Tab ,  Layout Tab .  Property .  X , origin X , _ NUM ,  FOREGROUND_ ANIMATION_ DURATION , _ NUM , _ BOOL , interpolator ) ; add To Animation ( new Layout Tab ,  Layout Tab .  Property .  Y , origin Y , _ NUM ,  FOREGROUND_ ANIMATION_ DURATION , _ NUM , _ BOOL , interpolator ) ; m Tab Model Selector . select Model ( new Is Incognito ) ; start Hiding ( id , _ BOOL ) ; }
private synchronized void add Tracker (  String path ,  Object marker ,  File Delete Strategy delete Strategy ) { if ( exit When Finished ) { throw new  Illegal State Exception ( _ STR ) ; } if ( reaper == null ) { reaper = new  Reaper ( ) ; reaper . start ( ) ; } trackers . add ( new  Tracker ( path , delete Strategy , marker , q ) ) ; }
public boolean has Attribute (  String name ) { return elem . has Attribute ( name ) ; }
protected long release Memory ( ) { long memory Freed = _ NUM ; while ( ! windows For Free Memory . is Empty ( ) ) { long window Id = windows For Free Memory . poll ( ) ; long origin Size = key Stream . size ( ) + value Stream . size ( ) ; key Stream . complete Window ( window Id ) ; value Stream . complete Window ( window Id ) ; memory Freed += origin Size - ( key Stream . size ( ) + value Stream . size ( ) ) ; } if ( memory Freed > _ NUM ) {  LOG . debug ( _ STR , memory Freed ) ; size In Bytes . get And Add ( - memory Freed ) ; } return memory Freed ; }
public static boolean is SQL99 Reserved Keyword (  String identifier ) { if ( identifier == null ) { throw new  Null Pointer Exception ( _ STR ) ; } return  Arrays . binary Search (  SQL99_ RESERVED , identifier . to Upper Case ( ) ) >= _ NUM ; }
private void close ( final  IRoot Block View rbv ) throws  IOException { m_write Lock . lock ( ) ; try { if ( m_close Root Block != null ) throw new  Illegal State Exception ( _ STR ) ; write Root Block ( rbv . is Root Block0 ( ) , rbv ) ; m_close Root Block = rbv ; m_callback . release ( this ) ; m_file Change . signal All ( ) ; } finally { m_write Lock . unlock ( ) ; } }
public boolean add Main Task (  Tmm Thread Pool new Task ) { boolean result = _ BOOL ; new Task . add Listener ( this ) ; new Task . set State (  Task State .  QUEUED ) ; main Task Executor . execute ( new Task ) ; return result ; }
public static byte [ ] write Object (  Object object ) throws  IOException {  Byte Array Output Stream buffer = new  Byte Array Output Stream ( ) ;  Object Output Stream out = new  Object Output Stream ( buffer ) ; out . write Object ( object ) ; out . close ( ) ; return buffer . to Byte Array ( ) ; }
public static int find Global Peak Location ( double [ ] data ) { double max =  Double .  Na N ; int imax = - _ NUM ; for ( int i = _ NUM ; i < data . length ; i ++ ) { if (  Double . is Na N ( data [ i ] ) ) continue ; if (  Double . is Na N ( max ) || data [ i ] > max ) { max = data [ i ] ; imax = i ; } } return imax ; }
public  Text trim ( ) { int first = _ NUM ; int last = length ( ) - _ NUM ; while ( ( first <= last ) && ( char At ( first ) <= _ STR ) ) { first ++ ; } while ( ( last >= first ) && ( char At ( last ) <= _ STR ) ) { last -- ; } return subtext ( first , last + _ NUM ) ; }
public int read Int ( ) throws  IOException { return ( ( _is . read ( ) << _ NUM ) | ( _is . read ( ) << _ NUM ) | ( _is . read ( ) << _ NUM ) | ( _is . read ( ) ) ) ; }
public void delete ( int index ) { m_ Instances . remove ( index ) ; }
protected static  String extract Bucket (  String s3uri ) { return s3uri . substring ( s3uri . index Of ( _ STR ) + _ NUM , s3uri . index Of ( _ STR , s3uri . index Of ( _ STR ) ) ) ; }
public boolean do Transaction (  DB db ,  Object threadstate ) throws  Workload Exception { boolean ret = _ BOOL ; long st =  System . nano Time ( ) ;  String op = operationchooser . next String ( ) ; if ( op . compare To ( _ STR ) == _ NUM ) { ret = do Transaction Read ( db ) ; } else if ( op . compare To ( _ STR ) == _ NUM ) { ret = do Transaction Update ( db ) ; } else if ( op . compare To ( _ STR ) == _ NUM ) { ret = do Transaction Insert ( db ) ; } else if ( op . compare To ( _ STR ) == _ NUM ) { ret = do Transaction Scan ( db ) ; } else { ret = do Transaction Read Modify Write ( db ) ; } long en =  System . nano Time ( ) ; _measurements . measure ( _operations . get ( op ) , ( int ) ( ( en - st ) / _ NUM ) ) ; if ( ret ) _measurements . report Return Code ( _operations . get ( op ) , - _ NUM ) ; else { _measurements . report Return Code ( _operations . get ( op ) , _ NUM ) ; } return ret ; }
public static void copy With Gap (  Object src ,  Object dst , int old Size , int gap Index ) { if ( gap Index > _ NUM ) {  System . arraycopy ( src , _ NUM , dst , _ NUM , gap Index ) ; } if ( gap Index < old Size ) {  System . arraycopy ( src , gap Index , dst , gap Index + _ NUM , old Size - gap Index ) ; } }
protected void add Url Into Sitemap (  String url Str ,  Site Map site Map ,  String last Mod ,  String change Freq ,  String priority , int url Index ) { try {  URL url = new  URL ( url Str ) ; boolean valid = url Is Valid ( site Map . get Base Url ( ) , url . to String ( ) ) ; if ( valid || ! strict ) {  Site Map URL s Url = new  Site Map URL ( url . to String ( ) , last Mod , change Freq , priority , valid ) ; site Map . add Site Map Url ( s Url ) ;  LOG . debug ( _ STR , url Index + _ NUM , s Url ) ; } else {  LOG . warn ( _ STR , url . to External Form ( ) , site Map . get Base Url ( ) ) ; } } catch (  Malformed URLException e ) {  LOG . warn ( _ STR , url Str ) ;  LOG . trace ( _ STR , e ) ; } }
public  Optional <  Blaze Edge > edge ( final  Object edge Id ) { try (  Closeable Iterator <  Edge > it = edges ( edge Id ) ) { final  Optional <  Blaze Edge > e = it . has Next ( ) ?  Optional . of ( (  Blaze Edge ) it . next ( ) ) :  Optional . empty ( ) ; if ( it . has Next ( ) ) { throw new  Illegal State Exception ( _ STR + edge Id ) ; } return e ; } }
static void add Cap (  Ring Buffer .  Sequence sequence , long to Add ) { long u , r ; do { r = sequence . get As Long ( ) ; if ( r ==  Long .  MAX_ VALUE ) { return ; } u =  Operators . add Cap ( r , to Add ) ; } while ( ! sequence . compare And Set ( r , u ) ) ; }
private void add (  Http Servlet Request request ,  Http Servlet Response response ) throws  IOException {  Print Writer out = response . get Writer ( ) ;  String label = request . get Parameter ( _ STR ) ;  String units = request . get Parameter ( _ STR ) ;  String value = request . get Parameter ( _ STR ) ;  String detail = request . get Parameter ( _ STR ) ;  Double val = to Double ( value ) ; if ( is Empty ( label ) || is Empty ( units ) || is Empty ( val ) ) { out . println (  ERROR + _ STR ) ; out . println ( _ STR ) ; } else {  Mon Key key = get Mon Key ( label , detail , units ) ;  Monitor mon =  Monitor Factory . add ( key , val ) ; out . println (  OK + _ STR + label + _ STR + mon ) ; } }
public static double sum ( double [ ] data ) { double sum = _ NUM ; for ( int i = _ NUM ; i < data . length ; i ++ ) { if (  Double . is Na N ( data [ i ] ) ) continue ; sum += data [ i ] ; } return sum ; }
public static double  P ( double  Y [ ] [ ] , int j , int v , int k , int w ) { int  N =  Y . length ; double p = _ NUM ; for ( int i = _ NUM ; i <  N ; i ++ ) { if ( ( ( int )  Math . round (  Y [ i ] [ j ] ) == v ) && ( ( int )  Math . round (  Y [ i ] [ k ] ) == w ) ) p += _ NUM ; } return p /  N ; }
private boolean test_float_1 D ( ) {  CUarray array = new  CUarray ( ) ;  CUDA_ ARRAY_ DESCRIPTOR ad = new  CUDA_ ARRAY_ DESCRIPTOR ( ) ; ad .  Format =  CU_ AD_ FORMAT_ FLOAT ; ad .  Width = size X ; ad .  Height = _ NUM ; ad .  Num Channels = _ NUM ; cu Array Create ( array , ad ) ;  Pointer p Input =  Pointer . to ( input_float_1 D ) ; cu Memcpy Hto A ( array , _ NUM , p Input , size X *  Sizeof .  FLOAT ) ;  CUtexref texref = new  CUtexref ( ) ; cu Module Get Tex Ref ( texref , module , _ STR ) ; cu Tex Ref Set Filter Mode ( texref ,  CU_ TR_ FILTER_ MODE_ LINEAR ) ; cu Tex Ref Set Address Mode ( texref , _ NUM ,  CU_ TR_ ADDRESS_ MODE_ CLAMP ) ; cu Tex Ref Set Flags ( texref ,  CU_ TRSF_ NORMALIZED_ COORDINATES ) ; cu Tex Ref Set Format ( texref ,  CU_ AD_ FORMAT_ FLOAT , _ NUM ) ; cu Tex Ref Set Array ( texref , array ,  CU_ TRSA_ OVERRIDE_ FORMAT ) ;  CUdeviceptr d Output = new  CUdeviceptr ( ) ; cu Mem Alloc ( d Output ,  Sizeof .  FLOAT * _ NUM ) ;  CUfunction function = new  CUfunction ( ) ; cu Module Get Function ( function , module , _ STR ) ;  Pointer kernel Parameters =  Pointer . to (  Pointer . to ( d Output ) ,  Pointer . to ( new float [ ] { pos X } ) ) ; cu Launch Kernel ( function , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , null , kernel Parameters , null ) ; cu Ctx Synchronize ( ) ; float h Output [ ] = new float [ _ NUM ] ; cu Memcpy Dto H (  Pointer . to ( h Output ) , d Output ,  Sizeof .  FLOAT * _ NUM ) ; log ( _ STR +  Arrays . to String ( h Output ) ) ; float expected [ ] = new float [ ] { _ NUM } ; boolean passed =  Arrays . equals ( h Output , expected ) ; log ( _ STR + ( passed ? _ STR : _ STR ) ) ; cu Array Destroy ( array ) ; cu Mem Free ( d Output ) ; return passed ; }
public  Closeable Animated Bitmap (  List <  Bitmap > bitmaps ,  List <  Integer > durations ,  Resource Releaser <  Bitmap > resource Releaser ) {  Preconditions . check Not Null ( bitmaps ) ;  Preconditions . check State ( bitmaps . size ( ) >= _ NUM , _ STR ) ; m Bitmaps = new  Array List < > ( bitmaps . size ( ) ) ; m Bitmap References = new  Array List < > ( bitmaps . size ( ) ) ; for (  Bitmap bitmap : bitmaps ) { m Bitmap References . add (  Closeable Reference . of ( bitmap , resource Releaser ) ) ; m Bitmaps . add ( bitmap ) ; } m Durations =  Preconditions . check Not Null ( durations ) ;  Preconditions . check State ( m Durations . size ( ) == m Bitmaps . size ( ) , _ STR ) ; }
protected void do Validate Text Contents (  String path ,  String filename ,  String contents ) {  File in File = new  File ( path , filename ) ;  Buffered Reader file Reader = null ;  Buffered Reader text Reader = null ;  Log . i (  LOG_ TAG , _ STR + filename + _ STR + path ) ; try { file Reader = new  Buffered Reader ( new  File Reader ( in File ) ) ; text Reader = new  Buffered Reader ( new  String Reader ( contents ) ) ;  String actual = null ;  String expected = null ; while ( ( actual = file Reader . read Line ( ) ) != null ) { expected = text Reader . read Line ( ) ; if ( ! actual . equals ( expected ) ) { fail ( _ STR + filename + _ STR + path + _ STR ) ; } } file Reader . close ( ) ; text Reader . close ( ) ;  Log . i (  LOG_ TAG , _ STR + filename + _ STR ) ; } catch (  IOException e ) { fail ( _ STR + in File + _ STR + e . to String ( ) ) ; } }
public void test String Array To Number ( ) {  Integer Converter int Converter = new  Integer Converter ( ) ;  Array Converter array Converter = new  Array Converter ( int [ ] . class , int Converter ) ;  String [ ] array = new  String [ ] { _ STR , _ STR , _ STR , _ STR } ;  Array List list = new  Array List ( ) ; for ( int i = _ NUM ; i < array . length ; i ++ ) { list . add ( array [ i ] ) ; }  String msg = null ; int [ ] expected Int = new int [ ] { _ NUM , _ NUM , _ NUM , _ NUM } ;  Integer [ ] expected Integer = new  Integer [ ] { new  Integer ( expected Int [ _ NUM ] ) , new  Integer ( expected Int [ _ NUM ] ) , new  Integer ( expected Int [ _ NUM ] ) , new  Integer ( expected Int [ _ NUM ] ) } ; try { msg = _ STR ; check Array ( msg , expected Int , array Converter . convert ( int [ ] . class , array ) ) ; } catch (  Exception e ) { fail ( msg + _ STR + e ) ; } try { msg = _ STR ; check Array ( msg , expected Integer , array Converter . convert (  Integer [ ] . class , array ) ) ; } catch (  Exception e ) { fail ( msg + _ STR + e ) ; } try { msg = _ STR ; check Array ( msg , expected Int , array Converter . convert ( int [ ] . class , list ) ) ; } catch (  Exception e ) { fail ( msg + _ STR + e ) ; } try { msg = _ STR ; check Array ( msg , expected Integer , array Converter . convert (  Integer [ ] . class , list ) ) ; } catch (  Exception e ) { fail ( msg + _ STR + e ) ; } }
public  String to XML ( final  XStream xstream , final  Object obj ) throws  Object Stream Exception { final  Writer writer = new  String Writer ( ) ; try { to XML ( xstream , obj , writer ) ; } catch ( final  Object Stream Exception e ) { throw e ; } catch ( final  IOException e ) { throw new  Stream Exception ( _ STR , e ) ; } return writer . to String ( ) ; }
private void test Find First Unseen Message Uid ( ) throws  Exception {  LOG . info ( _ STR ) ;  Message Uid uid = message Mapper . find First Unseen Message Uid (  MBOXES . get ( _ NUM ) ) ; assert Equals (  Message Uid . of ( _ NUM ) , uid ) ; }
public void create Index (  String in File ) {  String ssx File = null ;  String shp File = null ; if ( in File . ends With ( _ STR ) ) { shp File = in File ; ssx File = ssx ( shp File ) ; } else if ( in File . ends With ( _ STR ) ) { ssx File = in File ; shp File = ssx File . substring ( _ NUM , ssx File . index Of ( _ STR ) ) + _ STR ; } else { return ; } byte file Header [ ] = new byte [  SHAPE_ FILE_ HEADER_ LENGTH ] ;  File Input Stream shp = null ;  File Output Stream ssx = null ; int shape Type ; try { shp = new  File Input Stream ( shp File ) ; ssx = new  File Output Stream ( ssx File ) ; shp . read ( file Header , _ NUM ,  SHAPE_ FILE_ HEADER_ LENGTH ) ; ssx . write ( file Header , _ NUM ,  SHAPE_ FILE_ HEADER_ LENGTH ) ; shape Type = read LEInt ( file Header , _ NUM ) ; switch ( shape Type ) { case  SHAPE_ TYPE_ NULL : index Nulls ( shp ,  SHAPE_ FILE_ HEADER_ LENGTH , ssx ) ; break ; case  SHAPE_ TYPE_ POINT : case  SHAPE_ TYPE_ POINTZ : case  SHAPE_ TYPE_ POINTM : index Points ( shp ,  SHAPE_ FILE_ HEADER_ LENGTH , ssx ) ; break ; case  SHAPE_ TYPE_ MULTIPOINT : case  SHAPE_ TYPE_ MULTIPOINTZ : case  SHAPE_ TYPE_ MULTIPOINTM : case  SHAPE_ TYPE_ POLYLINE : case  SHAPE_ TYPE_ POLYLINEZ : case  SHAPE_ TYPE_ POLYLINEM : case  SHAPE_ TYPE_ POLYGON : case  SHAPE_ TYPE_ POLYGONZ : case  SHAPE_ TYPE_ POLYGONM : index Polygons ( shp ,  SHAPE_ FILE_ HEADER_ LENGTH , ssx ) ; break ; default : logger . warning ( _ STR + shape Type ) ; } } catch ( java . io .  IOException e ) { e . print Stack Trace ( ) ; } finally { try { if ( shp != null ) shp . close ( ) ; if ( ssx != null ) ssx . close ( ) ; } catch ( java . io .  IOException e ) { } } }
private  Virtual Pool Change Param convert New Virtual Pool Change Param To Old Param (  Volume Virtual Pool Change Param new Param ) {  Virtual Pool Change Param old Param = new  Virtual Pool Change Param ( ) ; old Param . set Virtual Pool ( new Param . get Virtual Pool ( ) ) ; old Param . set Protection ( new Param . get Protection ( ) ) ; old Param . set Consistency Group ( new Param . get Consistency Group ( ) ) ; old Param . set Transfer Speed Param ( new Param . get Transfer Speed Param ( ) ) ; old Param . set Migration Suspend Before Commit ( new Param . is Migration Suspend Before Commit ( ) ) ; old Param . set Migration Suspend Before Delete Source ( new Param . is Migration Suspend Before Delete Source ( ) ) ; return old Param ; }
@  Override public void replace ( int index ,  Solution new Solution ) {  Iterator <  Solution > iterator = iterator ( ) ; while ( iterator . has Next ( ) ) {  Solution old Solution = iterator . next ( ) ; int flag = comparator . compare ( new Solution , old Solution ) ; if ( flag < _ NUM ) { iterator . remove ( ) ; } else if ( flag > _ NUM ) { return ; } else if ( is Duplicate ( new Solution , old Solution ) ) { return ; } } super . replace ( index , new Solution ) ; }
public void mouse Pressed (  Mouse Event e ) {  Visualization Viewer < ? , ? > vv = (  Visualization Viewer < ? , ? > ) e . get Source ( ) ; boolean accepted = check Modifiers ( e ) ; down = e . get Point ( ) ; if ( accepted ) { vv . set Cursor ( cursor ) ; } }
public  File create New Folder (  File containing Dir ) throws  IOException { if ( containing Dir == null ) { throw new  IOException ( _ STR ) ; }  File new Folder ; new Folder = create File Object ( containing Dir , new Folder String ) ; int i = _ NUM ; while ( new Folder . exists ( ) && i < _ NUM ) { new Folder = create File Object ( containing Dir ,  Message Format . format ( new Folder Next String , new  Integer ( i ) ) ) ; i ++ ; } if ( new Folder . exists ( ) ) { throw new  IOException ( _ STR + new Folder . get Absolute Path ( ) ) ; } else { new Folder . mkdirs ( ) ; } return new Folder ; }
public static  Map <  String ,  Map <  String ,  Map <  String ,  Object > > > prepare Field (  Map <  String , ? > input Fields ,  Map <  String ,  Object > query String Map ,  Map <  String ,  List <  Object [ ] > > orig Value Map ) {  Map <  String ,  Map <  String ,  Map <  String ,  Object > > > normalized Fields = new  Linked Hash Map <  String ,  Map <  String ,  Map <  String ,  Object > > > ( ) ; for (  String field Name Raw : input Fields . key Set ( ) ) {  String field Name Root = null ;  String field Pair = null ;  Object field Value = null ; int i Pos = - _ NUM ; int i Pos2 = - _ NUM ;  Map <  String ,  Map <  String ,  Object > > sub Map = null ;  Map <  String ,  Object > sub Map2 = null ;  String field Mode = null ; field Value = input Fields . get ( field Name Raw ) ; if (  Object Type . is Empty ( field Value ) ) { continue ; } query String Map . put ( field Name Raw , field Value ) ; i Pos = field Name Raw . index Of ( _ STR ) ; if ( i Pos >= _ NUM ) {  String suffix = field Name Raw . substring ( i Pos + _ NUM ) ; i Pos2 = suffix . index Of ( _ STR ) ; if ( i Pos2 == _ NUM ) { continue ; } } if ( i Pos < _ NUM ) { field Name Root = field Name Raw ; field Pair = _ STR ; field Mode = _ STR ; } else { field Name Root = field Name Raw . substring ( _ NUM , i Pos ) ;  String suffix = field Name Raw . substring ( i Pos + _ NUM ) ; i Pos2 = suffix . index Of ( _ STR ) ; if ( i Pos2 < _ NUM ) { if ( suffix . starts With ( _ STR ) ) { field Pair = suffix ; field Mode = _ STR ; } else { field Pair = _ STR ; field Mode = suffix ; } } else {  String tkn0 = suffix . substring ( _ NUM , i Pos2 ) ;  String tkn1 = suffix . substring ( i Pos2 + _ NUM ) ; if ( tkn0 . starts With ( _ STR ) ) { field Pair = tkn0 ; field Mode = tkn1 ; } else { field Pair = tkn1 ; field Mode = tkn0 ; } } } sub Map = normalized Fields . get ( field Name Root ) ; if ( sub Map == null ) { sub Map = new  Linked Hash Map <  String ,  Map <  String ,  Object > > ( ) ; normalized Fields . put ( field Name Root , sub Map ) ; } sub Map2 = sub Map . get ( field Pair ) ; if ( sub Map2 == null ) { sub Map2 = new  Linked Hash Map <  String ,  Object > ( ) ; sub Map . put ( field Pair , sub Map2 ) ; } sub Map2 . put ( field Mode , field Value ) ;  List <  Object [ ] > orig List = orig Value Map . get ( field Name Root ) ; if ( orig List == null ) { orig List = new  Linked List <  Object [ ] > ( ) ; orig Value Map . put ( field Name Root , orig List ) ; }  Object [ ] orig Values = { field Name Raw , field Value } ; orig List . add ( orig Values ) ; } return normalized Fields ; }
public boolean add ( symbol_set other ) throws internal_error { boolean result = _ BOOL ; not_null ( other ) ; for (  Enumeration e = other . all ( ) ; e . has More Elements ( ) ; ) result = add ( ( symbol ) e . next Element ( ) ) || result ; return result ; }
private void check Matrix ( ) { for (  Node variable : variables ) { if ( variable == null ) { throw new  Null Pointer Exception ( ) ; } } if ( sample Size < _ NUM ) { throw new  Illegal Argument Exception ( _ STR ) ; } for ( int i = _ NUM ; i < matrix . rows ( ) ; i ++ ) { for ( int j = _ NUM ; j < matrix . columns ( ) ; j ++ ) { if (  Double . is Na N ( matrix . get ( i , j ) ) ) { throw new  Illegal Argument Exception ( _ STR ) ; } } } }
public static  Array List <  Long > load Workspace Screens Db (  Context context ) { final  Content Resolver content Resolver = context . get Content Resolver ( ) ; final  Uri screens Uri =  Launcher Settings .  Workspace Screens .  CONTENT_ URI ; final  Cursor sc = content Resolver . query ( screens Uri , null , null , null ,  Launcher Settings .  Workspace Screens .  SCREEN_ RANK ) ;  Array List <  Long > screen Ids = new  Array List <  Long > ( ) ; try { final int id Index = sc . get Column Index Or Throw (  Launcher Settings .  Workspace Screens . _ ID ) ; while ( sc . move To Next ( ) ) { try { screen Ids . add ( sc . get Long ( id Index ) ) ; } catch (  Exception e ) {  Launcher . add Dump Log (  TAG , _ STR + _ STR + e , _ BOOL ) ; } } } finally { sc . close ( ) ; } return screen Ids ; }
public static boolean parse Boolean (  FXGNode node ,  String value ,  String name ) { if ( value . equals ( _ STR ) ) return _ BOOL ; else if ( value . equals ( _ STR ) ) return _ BOOL ; throw new  FXGException ( node . get Start Line ( ) , node . get Start Column ( ) , _ STR , name , value ) ; }
protected  String e (  String s ) throws  Exception { return fmt . format ( parser . parse ( s ) ) ; }
public static boolean equals ( int [ ] field1 , int [ ] field2 ) { if ( field1 == null || field1 . length == _ NUM ) { return field2 == null || field2 . length == _ NUM ; } else { return  Arrays . equals ( field1 , field2 ) ; } }
@  Not Null public static  Buffered Image scale (  Buffered Image source , double x Scale , double y Scale ) { return scale ( source , x Scale , y Scale , _ NUM , _ NUM ) ; }
public  Link Icon ( boolean linked ) { this . linked = linked ; link = linked ? linked Im Ic . get Image ( ) : unlinked Im Ic . get Image ( ) ; add Mouse Listener ( this ) ;  Dimension dim = new  Dimension ( ( int ) link . get Width ( null ) , link . get Height ( null ) ) ; set Preferred Size ( dim ) ; set Minimum Size ( dim ) ; set Maximum Size ( dim ) ; set Size ( dim ) ; set Layout ( null ) ; repaint ( ) ; }
public void update Geometry ( int row ,  Geometry geometry ) { set Value At ( geometry , row , get Geometry Field Index ( ) ) ; }
private void wait ( int ms ) { try {  Thread . sleep ( ms ) ; } catch (  Interrupted Exception e ) { } }
public static void clear Log Filters ( ) { if ( filters == null || filters . is Empty ( ) ) { return ; } filters . clear ( ) ; }
public void clear ( ) { data . clear ( ) ; fire Table Structure Changed ( ) ; }
protected boolean write Fields (  Data Output Stream dd ) throws  IOException { field_info fi ; int i ; for ( i = _ NUM ; i < fields_count ; i ++ ) { fi = fields [ i ] ; dd . write Short ( fi . access_flags ) ; dd . write Short ( fi . name_index ) ; dd . write Short ( fi . descriptor_index ) ; dd . write Short ( fi . attributes_count ) ; if ( fi . attributes_count > _ NUM ) { write Attributes ( dd , fi . attributes_count , fi . attributes ) ; } } return _ BOOL ; }
public void test Bug20685022 ( ) throws  Exception { if ( ! is Community Edition ( ) ) { return ; } final  Properties props = new  Properties ( ) ; props . clear ( ) ; props . set Property ( _ STR , _ STR ) ; props . set Property ( _ STR , _ STR ) ; props . set Property ( _ STR , _ STR ) ; get Connection With Props ( props ) ; props . clear ( ) ; props . set Property ( _ STR , _ STR ) ; props . set Property ( _ STR , _ STR ) ; props . set Property ( _ STR , _ STR ) ; props . set Property ( _ STR , _ STR ) ; props . set Property ( _ STR , _ STR ) ; props . set Property ( _ STR , _ STR ) ; get Connection With Props ( props ) ; props . clear ( ) ; props . set Property ( _ STR , _ STR ) ; props . set Property ( _ STR , _ STR ) ; props . set Property ( _ STR , _ STR ) ;  String trust Store Path = _ STR ;  System . set Property ( _ STR , trust Store Path ) ;  System . set Property ( _ STR , _ STR ) ;  System . set Property ( _ STR , trust Store Path ) ;  System . set Property ( _ STR , _ STR ) ; get Connection With Props ( props ) ; }
public void add (  Key key ) { if ( key == null ) throw new  Null Pointer Exception ( _ STR ) ; set . add ( key ) ; }
public static  String generate Timecode Start Address ( ) {  String delimiter = _ STR ;  String time Code Start Address = _ STR ; if ( time Code Start Address . matches ( _ STR ) ) { return time Code Start Address ; } else { throw new  IMFException (  String . format ( _ STR + _ STR ) ) ; } }
public static boolean is Client Level Only ( int  AD_ Client_ ID , int  AD_ Table_ ID ) {  Boolean share = is Shared (  AD_ Client_ ID ,  AD_ Table_ ID ) ; if ( share != null ) return share . boolean Value ( ) ; return _ BOOL ; }
@  Override public void action Performed (  Action Event event ) {  String command = event . get Action Command ( ) ; if ( command . equals ( _ STR ) ) { validate Tick Unit ( ) ; } else { super . action Performed ( event ) ; } }
public byte [ ] serialize ( ) throws  IOException {  Byte Array Output Stream bytes Out = new  Byte Array Output Stream ( ) ;  Data Output Stream data Out = new  Data Output Stream ( bytes Out ) ; write ( data Out ) ; return bytes Out . to Byte Array ( ) ; }
void bind (  String mod Name ,  Module Pointer mod Pointer ) { context . put ( mod Name , mod Pointer ) ; }
private static  File unpack Nar ( final  File nar , final  File base Working Directory ) throws  IOException { final  File nar Working Directory = new  File ( base Working Directory , nar . get Name ( ) + _ STR ) ; if ( ! nar Working Directory . exists ( ) ) { unpack ( nar , nar Working Directory , calculate Md5sum ( nar ) ) ; } else { final byte [ ] nar Md5 = calculate Md5sum ( nar ) ; final  File working Hash File = new  File ( nar Working Directory ,  HASH_ FILENAME ) ; if ( ! working Hash File . exists ( ) ) {  File Utils . delete File ( nar Working Directory , _ BOOL ) ; unpack ( nar , nar Working Directory , nar Md5 ) ; } else { final byte [ ] hash File Contents =  Files . read All Bytes ( working Hash File . to Path ( ) ) ; if ( !  Arrays . equals ( hash File Contents , nar Md5 ) ) { logger . info ( _ STR , new  Object [ ] { nar . get Absolute Path ( ) } ) ;  File Utils . delete File ( nar Working Directory , _ BOOL ) ; unpack ( nar , nar Working Directory , nar Md5 ) ; } } } return nar Working Directory ; }
public static  String compatible Field Name (  String original ) { if ( ! original . matches ( _ STR ) ) { return _ STR + original ; } else { return original ; } }
public void transform Points (  Object native Transform , int point Size , float [ ] in , int src Pos , float [ ] out , int dest Pos , int num Points ) { float [ ] buf In = new float [ point Size ] ; float [ ] buf Out = new float [ point Size ] ; int len = num Points * point Size ; for ( int i = _ NUM ; i < len ; i += point Size ) {  System . arraycopy ( in , src Pos + i , buf In , _ NUM , point Size ) ; transform Point ( native Transform , buf In , buf Out ) ;  System . arraycopy ( buf Out , _ NUM , out , dest Pos + i , point Size ) ; } }
public void test Merge One Filter Into Empty Document ( ) throws  Exception {  String src Xml = _ STR ;  Web Xml src Web Xml =  Web Xml Io . parse Web Xml ( new  Byte Array Input Stream ( src Xml . get Bytes ( _ STR ) ) , null ) ;  String merge Xml = _ STR + _ STR + _ STR + _ STR + _ STR + _ STR ;  Web Xml merge Web Xml =  Web Xml Io . parse Web Xml ( new  Byte Array Input Stream ( merge Xml . get Bytes ( _ STR ) ) , null ) ;  Web Xml Merger merger = new  Web Xml Merger ( src Web Xml ) ; merger . merge Filters ( merge Web Xml ) ; assert True (  Web Xml Utils . has Filter ( src Web Xml , _ STR ) ) ; }
protected int normalize ( char [ ] src , int src Start , int src Limit , char [ ] dest , int dest Start , int dest Limit ,  Unicode Set nx ) { int src Len = ( src Limit - src Start ) ; int dest Len = ( dest Limit - dest Start ) ; if ( src Len > dest Len ) { return src Len ; }  System . arraycopy ( src , src Start , dest , dest Start , src Len ) ; return src Len ; }
public void not ( ) { mv . visit Insn (  Opcodes .  ICONST_1 ) ; mv . visit Insn (  Opcodes .  IXOR ) ; }
public static boolean requires Bidi ( char [ ] text , int start , int limit ) { return  Bidi Base . requires Bidi ( text , start , limit ) ; }
public static  String left Pad (  String s , int min Length , char filling ) { int ln = s . length ( ) ; if ( min Length <= ln ) { return s ; }  String Builder res = new  String Builder ( min Length ) ; int dif = min Length - ln ; for ( int i = _ NUM ; i < dif ; i ++ ) { res . append ( filling ) ; } res . append ( s ) ; return res . to String ( ) ; }
protected  String parse (  Reader reader ) throws  IOException { if ( ! reader . mark Supported ( ) ) { reader = new  Buffered Reader ( reader ) ; }  String Writer sw = new  String Writer ( ) ; start Script ( sw ) ; int c ; while ( ( c = reader . read ( ) ) != - _ NUM ) { if ( c == _ STR ) { reader . mark ( _ NUM ) ; c = reader . read ( ) ; if ( c != _ STR ) { sw . write ( _ STR ) ; reader . reset ( ) ; } else { reader . mark ( _ NUM ) ; c = reader . read ( ) ; if ( c == _ STR ) { groovy Expression ( reader , sw ) ; } else { reader . reset ( ) ; groovy Section ( reader , sw ) ; } } continue ; } if ( c == _ STR ) { reader . mark ( _ NUM ) ; c = reader . read ( ) ; if ( c != _ STR ) { sw . write ( _ STR ) ; reader . reset ( ) ; } else { reader . mark ( _ NUM ) ; sw . write ( _ STR ) ; process GSstring ( reader , sw ) ; } continue ; } if ( c == _ STR ) { sw . write ( _ STR ) ; } if ( c == _ STR || c == _ STR ) { if ( c == _ STR ) { reader . mark ( _ NUM ) ; c = reader . read ( ) ; if ( c != _ STR ) { reader . reset ( ) ; } } sw . write ( _ STR ) ; continue ; } sw . write ( c ) ; } end Script ( sw ) ; return sw . to String ( ) ; }
public  String to HTML ( ) {  String Builder builder = new  String Builder ( ) ; int num Classes = classes . size ( ) ; builder . append ( _ STR ) ; builder . append ( _ STR ) ; builder . append (  String . format ( _ STR , num Classes + _ NUM ) ) ; builder . append ( _ STR ) ; for (  T predicted : classes ) { builder . append ( _ STR ) ; builder . append ( predicted ) ; builder . append ( _ STR ) ; } builder . append ( _ STR ) ; builder . append ( _ STR ) ;  String first Column Label =  String . format ( _ STR , num Classes + _ NUM ) ; for (  T actual : classes ) { builder . append ( first Column Label ) ; first Column Label = _ STR ; builder . append (  String . format ( _ STR , actual ) ) ; for (  T predicted : classes ) { builder . append ( _ STR ) ; builder . append ( get Count ( actual , predicted ) ) ; builder . append ( _ STR ) ; } builder . append ( _ STR ) ; builder . append ( get Actual Total ( actual ) ) ; builder . append ( _ STR ) ; builder . append ( _ STR ) ; } builder . append ( _ STR ) ; for (  T predicted : classes ) { builder . append ( _ STR ) ; builder . append ( get Predicted Total ( predicted ) ) ; builder . append ( _ STR ) ; } builder . append ( _ STR ) ; builder . append ( _ STR ) ; builder . append ( _ STR ) ; return builder . to String ( ) ; }
public  String to Id String (  Object id ) { if ( id == null ) return null ; return id . to String ( ) ; }
public final boolean is Closed ( ) { return closed . get ( ) ; }
public static  Map <  String ,  Object > perform Find List (  Dispatch Context dctx ,  Map <  String ,  Object > context ) {  Integer view Size = (  Integer ) context . get ( _ STR ) ; if ( view Size == null ) view Size =  Integer . value Of ( _ NUM ) ; context . put ( _ STR , view Size ) ;  Integer view Index = (  Integer ) context . get ( _ STR ) ; if ( view Index == null ) view Index =  Integer . value Of ( _ NUM ) ; context . put ( _ STR , view Index ) ;  Map <  String ,  Object > result = perform Find ( dctx , context ) ; int start = view Index . int Value ( ) * view Size . int Value ( ) ;  List <  Generic Value > list = null ;  Integer list Size = null ; try {  Entity List Iterator it = (  Entity List Iterator ) result . get ( _ STR ) ; list = it . get Partial List ( start + _ NUM , view Size ) ; list Size = it . get Results Size After Partial List ( ) ; it . close ( ) ; } catch (  Exception e ) {  Debug . log Info ( _ STR + e , module ) ; } result . put ( _ STR , list Size ) ; result . put ( _ STR , list ) ; result . remove ( _ STR ) ; return result ; }
public static void validate SOAPHeader (  SOAPHeader soap Header ) {  Set <  QName > fields = new  Hash Set < > ( ) ;  Iterator < ? > it = soap Header . get Child Elements ( ) ; while ( it . has Next ( ) ) {  Object next = it . next ( ) ; if ( next instanceof  SOAPElement ) {  SOAPElement soap Element = (  SOAPElement ) next ; if ( ! fields . add ( soap Element . get Element QName ( ) ) ) { throw new  Coded Exception (  X_ DUPLICATE_ HEADER_ FIELD , _ STR , soap Element . get Element QName ( ) ) ; } } } }
@  Override public void close ( ) throws  IOException { synchronized ( lock ) { out . close ( ) ; } }
private static boolean eq (  Object x ,  Object y ) { return x == y || x . equals ( y ) ; }
@  Override public final boolean read Boolean ( ) throws  IOException { return dis . read Boolean ( ) ; }
public static  File file (  String s ) {  File f = new  File ( s ) ; return f ; }
public void test Find Spring Attributes Open Ldap ( ) {  Ldap Proxy proxy = get Ldap Open Ldap ( ) ;  List result = null ; try { result = proxy . find ( get Ldap Search VO ( _ STR ,  Ldap Constants .  NO_ SEARCH_ LIMIT , null , null , new  String [ ] { _ STR } ,  Ldap Scope Constants .  SCOPE_ SUBTREE ) ) ; } catch (  Exception e ) { } assert Not Null ( result ) ; assert Equals ( _ NUM , result . size ( ) ) ; }
public void add Arg ( final  BOp new Arg ) { if ( new Arg == null ) throw new  Illegal Argument Exception ( ) ; if ( new Arg == this ) throw new  Illegal Argument Exception ( ) ; args . add ( new Arg ) ; mutation ( ) ; }
private static double hypot ( double a , double b ) { double r = _ NUM ; if (  Math . abs ( a ) >  Math . abs ( b ) ) { r = b / a ; r =  Math . abs ( a ) *  Math . sqrt ( _ NUM + r * r ) ; } else if ( b != _ NUM ) { r = a / b ; r =  Math . abs ( b ) *  Math . sqrt ( _ NUM + r * r ) ; } return r ; }
public static void write Swapped Integer (  Output Stream output , int value ) throws  IOException { output . write ( ( byte ) ( ( value > > _ NUM ) & _ NUM ) ) ; output . write ( ( byte ) ( ( value > > _ NUM ) & _ NUM ) ) ; output . write ( ( byte ) ( ( value > > _ NUM ) & _ NUM ) ) ; output . write ( ( byte ) ( ( value > > _ NUM ) & _ NUM ) ) ; }
public static void queue Column Load (  ICubic World world ,  Cube IO loader , int x , int z ,  Consumer <  Column > runnable ) {  Queued Column key = new  Queued Column ( x , z , world ) ;  Async Column IOProvider task = column Tasks . get ( key ) ; if ( task == null ) { task = new  Async Column IOProvider ( key , loader ) ; task . add Callback ( runnable ) ; column Tasks . put ( key , task ) ; pool . execute ( task ) ; } else { task . add Callback ( runnable ) ; } }
@  Override public int available ( ) throws  IOException { return m_ Input Stream . available ( ) ; }
public static boolean is Button Pressed (  Input Event e , int button ) { return ( e . get Modifiers ( ) & button ) == button ; }
Message ( ) { }
public void remove Change Listener (  Change Listener l ) { listeners . remove ( l ) ; }
public static  Request Log copy ( ) {  Request Log current =  RLOG . get ( ) ; return new  Request Log ( current ) ; }
public static  String html Decode (  String str ) { if ( str == null ) { return null ; } try { str =  URLDecoder . decode ( str , _ STR ) ; } catch ( final  Throwable e ) { e . print Stack Trace ( ) ; } return  Encoding . html Only Decode ( str ) ; }
public void test Then Combine_exceptional Completion ( ) throws  Throwable { for (  Execution Mode m :  Execution Mode . values ( ) ) for ( boolean f First : new boolean [ ] { _ BOOL , _ BOOL } ) for ( boolean fail First : new boolean [ ] { _ BOOL , _ BOOL } ) for (  Integer v1 : new  Integer [ ] { _ NUM , null } ) { final  Completable Future <  Integer > f = new  Completable Future < > ( ) ; final  Completable Future <  Integer > g = new  Completable Future < > ( ) ; final  CFException ex = new  CFException ( ) ; final  Subtract Function r1 = new  Subtract Function ( m ) ; final  Subtract Function r2 = new  Subtract Function ( m ) ; final  Subtract Function r3 = new  Subtract Function ( m ) ; final  Completable Future <  Integer > fst = f First ? f : g ; final  Completable Future <  Integer > snd = ! f First ? f : g ; final  Callable <  Boolean > complete1 = fail First ? null : null ; final  Callable <  Boolean > complete2 = fail First ? null : null ; final  Completable Future <  Integer > h1 = m . then Combine ( f , g , r1 ) ; assert True ( complete1 . call ( ) ) ; final  Completable Future <  Integer > h2 = m . then Combine ( f , g , r2 ) ; check Incomplete ( h1 ) ; check Incomplete ( h2 ) ; assert True ( complete2 . call ( ) ) ; final  Completable Future <  Integer > h3 = m . then Combine ( f , g , r3 ) ; check Completed With Wrapped Exception ( h1 , ex ) ; check Completed With Wrapped Exception ( h2 , ex ) ; check Completed With Wrapped Exception ( h3 , ex ) ; r1 . assert Not Invoked ( ) ; r2 . assert Not Invoked ( ) ; r3 . assert Not Invoked ( ) ; check Completed Normally ( fail First ? snd : fst , v1 ) ; check Completed Exceptionally ( fail First ? fst : snd , ex ) ; } }
public  JToggle Group ( int type ,  Object [ ] data ) { this ( type , new  Default List Model ( ) , new  Default List Selection Model ( ) ) ;  Default List Model model = (  Default List Model ) m_data ; for ( int i = _ NUM ; i < data . length ; ++ i ) { model . add Element ( data [ i ] ) ; } init UI ( ) ; }
public boolean table Exists Case Sensitive (  Database Meta Data db Meta Data ,  String table Name ) throws  SQLException {  Result Set rs Tables = db Meta Data . get Tables ( null , null , table Name , null ) ; try { return rs Tables . next ( ) ; } finally { close JDBCResult Set ( rs Tables ) ; } }
public void add All (  Collection < ? extends  T > collection ) { if ( m Event Delegate != null ) m Event Delegate . add Data ( collection == null ? _ NUM : collection . size ( ) ) ; if ( collection != null && collection . size ( ) != _ NUM ) { synchronized ( m Lock ) { m Objects . add All ( collection ) ; } } int data Count = collection == null ? _ NUM : collection . size ( ) ; if ( m Observer != null ) m Observer . on Item Range Inserted ( get Count ( ) - data Count + _ NUM , data Count ) ; if ( m Notify On Change ) notify Item Range Inserted ( headers . size ( ) + get Count ( ) - data Count + _ NUM , data Count ) ; log ( _ STR + ( headers . size ( ) + get Count ( ) - data Count + _ NUM ) + _ STR + ( data Count ) ) ; }
public static void add To Current File List (  String old File Name ,  String new File Name ,  String log Name ) {  Array List file List = (  Array List ) current File List . get (  PREFIX + log Name ) ; if ( file List == null ) { file List = new  Array List ( ) ; } current File List . remove (  PREFIX + log Name ) ; file List . remove (  PREFIX + old File Name ) ; file List . add (  PREFIX + new File Name ) ; if ( ! old File Name . equals ( new File Name ) ) { file List . add (  PREFIX + old File Name ) ; } current File List . put (  PREFIX + log Name , file List ) ; }
boolean is Tool Bar Button (  JComponent c ) { return ( c . get Parent ( ) instanceof  JTool Bar ) ; }
public static synchronized boolean execute (  String sql Statement ) { boolean execute Ok = _ BOOL ; logger . trace (  String . format ( _ STR , sql Statement ) ) ; final  Statement  S = get Statement ( ) ; if (  S == null ) { logger . error ( _ STR ) ; return _ BOOL ; } try { execute Ok =  S . execute ( sql Statement ) ; } catch (  Throwable t ) { surface Throwable (  String . format ( _ STR , sql Statement ) , t ) ; } finally { cleanup (  S ) ; } logger . trace ( _ STR + execute Ok ) ; return execute Ok ; }
public void write ( char buf [ ] ) { write ( buf , _ NUM , buf . length ) ; }
@  Suppress Warnings ( _ STR ) public static  String url Encode (  String s ) { try { return  URLEncoder . encode ( s , _ STR ) ; } catch (  Unsupported Encoding Exception e ) { return  URLEncoder . encode ( s ) ; } }
public static void import Expression Types ( final  CConnection connection , final int raw Module Id , final int module Id ) throws  SQLException { final  String query = _ STR +  CTable Names .  EXPRESSION_ TYPES_ TABLE + _ STR + module Id + _ STR + _ STR +  String . format (  CTable Names .  RAW_ EXPRESSION_ TYPES_ TABLE , raw Module Id ) ; connection . execute Update ( query , _ BOOL ) ; }
public static  String format Currency ( double value ,  Currency currency ) {  Number Format f = get Currency Formatter ( ) ; f . set Currency ( currency ) ; return post Format Currency ( f . format ( value ) ) ; }
public static float next Down ( final float start ) { if ( start >  Float .  NEGATIVE_ INFINITY ) { if ( start == _ NUM ) { return -  Float .  MIN_ VALUE ; } final int bits =  Float . float To Raw Int Bits ( start ) ; return  Float . int Bits To Float ( bits + ( bits > _ NUM ? - _ NUM : _ NUM ) ) ; } else if ( start ==  Float .  NEGATIVE_ INFINITY ) { return  Float .  NEGATIVE_ INFINITY ; } else { return start ; } }
private  Map <  URI ,  File Share > query File Shares ( final  List <  File Descriptor > file Share Descriptors ) {  List <  URI > file Share URIs =  File Descriptor . get File System URIs ( file Share Descriptors ) ;  List <  File Share > file Shares = db Client . query Object (  File Share . class , file Share URIs ) ;  Map <  URI ,  File Share > file Share Map = new  Hash Map <  URI ,  File Share > ( ) ; for (  File Share file Share : file Shares ) { if ( file Share != null ) { file Share Map . put ( file Share . get Id ( ) , file Share ) ; } } return file Share Map ; }
private void test Jce Availability ( int key Bit Length ) throws  Encryption Unsupported By Platform Exception ,  PDFParse Exception { final byte [ ] junk Buffer = new byte [ _ NUM ] ;  Arrays . fill ( junk Buffer , ( byte ) _ NUM ) ; final byte [ ] junk Key = new byte [ get Salted Content Key Byte Length ( key Bit Length / _ NUM ) ] ;  Arrays . fill ( junk Key , ( byte ) _ NUM ) ; try { create And Initialise Content Cipher (  Byte Buffer . wrap ( junk Buffer ) , junk Key ) ; } catch (  PDFParse Exception e ) { throw new  PDFParse Exception ( _ STR + _ STR + e . get Message ( ) ) ; } catch (  No Such Algorithm Exception e ) { throw new  Encryption Unsupported By Platform Exception ( _ STR , e ) ; } catch (  No Such Padding Exception e ) { throw new  Encryption Unsupported By Platform Exception ( _ STR , e ) ; } catch (  Invalid Key Exception e ) { throw new  Encryption Unsupported By Platform Exception ( _ STR + ( get Salted Content Key Byte Length ( ) * _ NUM ) + _ STR , e ) ; } catch (  Invalid Algorithm Parameter Exception e ) { throw new  Encryption Unsupported By Platform Exception ( _ STR , e ) ; } try { create MD5 Digest ( ) ; } catch (  No Such Algorithm Exception e ) { throw new  Encryption Unsupported By Platform Exception ( _ STR , e ) ; } if ( encryption Algorithm !=  Encryption Algorithm .  RC4 ) { final  Cipher rc4 ; try { rc4 = create RC4 Cipher ( ) ; } catch (  General Security Exception e ) { throw new  Encryption Unsupported By Platform Exception ( _ STR , e ) ; } final byte [ ] rc4 Junk Key = new byte [ _ NUM ] ;  Arrays . fill ( junk Key , ( byte ) _ NUM ) ; try { init Decryption ( rc4 , create RC4 Key ( rc4 Junk Key ) ) ; } catch (  Invalid Key Exception ex ) { throw new  Encryption Unsupported By Platform Exception ( _ STR + _ STR , ex ) ; } } }
public static double enlargement (  Spatial Comparable exist ,  Spatial Comparable addit ) { final int dim = assert Same Dimensionality ( exist , addit ) ; double v1 = _ NUM ; double v2 = _ NUM ; for ( int i = _ NUM ; i < dim ; i ++ ) { final double emin = exist . get Min ( i ) ; final double emax = exist . get Max ( i ) ; final double amin = addit . get Min ( i ) ; final double amax = addit . get Max ( i ) ; final double min =  Math . min ( emin , amin ) ; final double max =  Math . max ( emax , amax ) ; v1 *= ( max - min ) ; v2 *= ( emax - emin ) ; } return v2 - v1 ; }
public boolean can Get File (  String path ) { return can Get File ( new  File ( path ) ) ; }
private  String strip Quotes (  String s ) {  String Buffer sb = new  String Buffer ( s . length ( ) ) ; for ( int i = _ NUM ; i < s . length ( ) ; i ++ ) { char c = s . char At ( i ) ; if ( c != _ STR ) { sb . append ( c ) ; } } return sb . to String ( ) ; }
static public void assert Equals (  String message ,  String expected ,  String actual ) { if ( expected == null && actual == null ) return ; if ( expected != null && expected . equals ( actual ) ) return ; throw new  Comparison Failure ( message , expected , actual ) ; }
public static  Throwable should Fail (  Class clazz ,  Closure code ) {  Throwable th = null ; try { code . call ( ) ; } catch (  Groovy Runtime Exception gre ) { th =  Script Bytecode Adapter . unwrap ( gre ) ; } catch (  Throwable e ) { th = e ; } if ( th == null ) { fail ( _ STR + code + _ STR + clazz . get Name ( ) ) ; } else if ( ! clazz . is Instance ( th ) ) { fail ( _ STR + code + _ STR + clazz . get Name ( ) + _ STR + th ) ; } return th ; }
private void register End ( final  String prefix Singular , final  String prefix Plural , final  String end String ) { prefix End List . add ( new  Prefix Entry ( end String , prefix Singular , prefix Plural ) ) ; register Prefix ( prefix Singular , prefix Plural ) ; }
public void request Password Expiration Warned Time ( ) { operations . add (  Password Policy State Operation Type .  GET_ PASSWORD_ EXPIRATION_ WARNED_ TIME ) ; }
private static  Object run JUnit3 Test (  Class script Class ) { try {  Object test Suite =  Invoker Helper . invoke Constructor Of ( _ STR , new  Object [ ] { script Class } ) ; return  Invoker Helper . invoke Static Method ( _ STR , _ STR , new  Object [ ] { test Suite } ) ; } catch (  Class Not Found Exception e ) { throw new  Groovy Runtime Exception ( _ STR , e ) ; } }
public static  String pad (  String str , int total Chars ) { if ( str == null ) str = _ STR ; int slen = str . length ( ) ;  String Builder sb = new  String Builder ( str ) ; for ( int i = _ NUM ; i < total Chars - slen ; i ++ ) { sb . append ( _ STR ) ; } return sb . to String ( ) ; }
private void remove Flag File (  String flag Name ) {  File flag File = new  File ( db Dir , flag Name ) ; if ( flag File . exists ( ) ) { flag File . delete ( ) ; } }
protected double kernel LP ( int n , char [ ] s , int end Index S , char [ ] t , int end Index T , int remaining Match Length ) { if (  Math . min ( end Index S + _ NUM , end Index T + _ NUM ) < n ) { return get Return Value ( n ) ; } if ( remaining Match Length == _ NUM ) { return get Return Value ( n ) ; } double result = _ NUM ; for ( int i S = end Index S ; i S > n - _ NUM ; i S -- ) { double buf = _ NUM ; char x = s [ i S ] ; for ( int j = _ NUM ; j <= end Index T ; j ++ ) { if ( t [ j ] == x ) { buf += kernel Helper LP ( n - _ NUM , s , i S - _ NUM , t , j - _ NUM , remaining Match Length - _ NUM ) ; } } result += buf * m_powers Oflambda [ _ NUM ] ; } return result ; }
private  Connection open Connection ( boolean autocommit ) throws  SQLException {  Connection conn = data Src != null ? data Src . get Connection ( ) :  Driver Manager . get Connection ( conn Url , user , passwd ) ; if ( test Mode ) opened . increment ( ) ; conn . set Auto Commit ( autocommit ) ; return conn ; }
private boolean enabled ( ) { return _ BOOL ; }
public void add Key Listener (  Key Listener l ) { m_text Area . add Key Listener ( l ) ; }
public void add Footer View (  View v ,  Object data , boolean is Selectable ) {  Fixed View Info info = new  Fixed View Info ( ) ; info . view = v ; info . data = data ; info . is Selectable = is Selectable ; m Footer View Infos . add ( info ) ; if ( m Data Set Observer != null ) { m Data Set Observer . on Changed ( ) ; } }
public static  Driver driver (  String uri ,  Config config ) { return driver (  URI . create ( uri ) , config ) ; }
protected void put Option ( final  Class option Class , final  String [ ] names ) {  Check . is True ( names . length > _ NUM , _ STR ) ; _options To Canonical Names . put ( option Class , names [ _ NUM ] ) ; for ( int i = _ NUM ; i < names . length ; i ++ ) { _aliases To Options . put ( names [ i ] , option Class ) ; } }
@  Override protected void write Column Auto Increment Stmt (  Table table ,  Column column ,  String Builder ddl ) { ddl . append ( _ STR ) ; }
public static void restart App (  Activity activity ) {  Shared Preferences preferences =  Preference Manager . get Default Shared Preferences ( activity ) ;  Shared Preferences .  Editor editor = preferences . edit ( ) ; if ( ! preferences . get Boolean (  RESTART_ IN_ PROGRESS_ KEY , _ BOOL ) ) {  Common Activity Utils . display Toast ( activity . get Application Context ( ) , _ STR ) ;  Log . e (  LOG_ TAG , _ STR ) ; editor . put Boolean (  RESTART_ IN_ PROGRESS_ KEY , _ BOOL ) ; editor . commit ( ) ;  Pending Intent m Pending Intent =  Pending Intent . get Activity ( activity , _ NUM , new  Intent ( activity ,  Login Activity . class ) ,  Pending Intent .  FLAG_ CANCEL_ CURRENT ) ;  Alarm Manager mgr = (  Alarm Manager ) activity . get System Service (  Context .  ALARM_ SERVICE ) ; mgr . set (  Alarm Manager .  RTC ,  System . current Time Millis ( ) + _ NUM , m Pending Intent ) ;  System . exit ( _ NUM ) ; } else {  Log . e (  LOG_ TAG , _ STR ) ; activity . finish ( ) ; } }
private void paint Background (  Graphics2 D g ,  JComponent c , int x , int y , int width , int height ) {  Color color = c . get Background ( ) ; if ( state ==  Which .  BACKGROUND_ ENABLED ) { color = (  Color ) component Colors [ _ NUM ] ; } else if ( type ==  Common Control State .  DISABLED ) { color = new  Color ( color . get Red ( ) , color . get Green ( ) , color . get Blue ( ) , _ NUM ) ; }  Shape s = shape Generator . create Round Rectangle ( x + _ NUM , y + _ NUM , width - _ NUM , height - _ NUM ,  Corner Size .  BORDER ) ; g . set Paint ( color ) ; g . fill ( s ) ; if ( is Paint Line Seperators ( c ) ) { paint Line Separator ( g , c , width , height ) ; } }
public static void add Sub Schema (  String service Name ,  String sub Schema ,  String schema Type ,  String file Name ) throws  Upgrade Exception {  String class Method = _ STR ; if ( debug . message Enabled ( ) ) { debug . message ( class Method + _ STR + file Name + _ STR + service Name ) ; } try {  Service Schema ss = get Service Schema ( service Name , sub Schema , schema Type ) ; ss . add Sub Schema ( new  File Input Stream ( file Name ) ) ; } catch (  IOException ioe ) { throw new  Upgrade Exception ( _ STR ) ; } catch (  SSOException ssoe ) { throw new  Upgrade Exception ( _ STR ) ; } catch (  SMSException ssoe ) { throw new  Upgrade Exception ( _ STR ) ; } }
private  String Builder encode Product (  String Builder tokens ) {  List Iterator it = product Tokens . list Iterator ( ) ; while ( it . has Next ( ) ) { tokens . append ( (  String ) it . next ( ) ) ; } return tokens ; }
public  String product Publication Date ( ) { return properties . get Property ( _ STR ) ; }
void drop Resource ( final  R resource ) { final  Thread tx =  Thread . current Thread ( ) ; synchronized ( resource Queues ) { final  Resource Queue <  R ,  Thread > resource Queue = resource Queues . get ( resource ) ; if ( resource Queue == null ) { throw new  Illegal Argument Exception ( _ STR + resource ) ; } resource Queue . clear ( tx ) ; resource Queues . remove ( resource ) ; } }
private final  String _decode Short Unicode Name ( int len ) throws  IOException { int out Ptr = _ NUM ; char [ ] out Buf = _text Buffer . empty And Get Current Segment ( ) ; int in Ptr = _input Ptr ; _input Ptr += len ; final int [ ] codes =  Smile Constants . s Utf8 Unit Lengths ; final byte [ ] in Buf = _input Buffer ; for ( int end = in Ptr + len ; in Ptr < end ; ) { int i = in Buf [ in Ptr ++ ] & _ NUM ; int code = codes [ i ] ; if ( code != _ NUM ) { switch ( code ) { case _ NUM : i = ( ( i & _ NUM ) << _ NUM ) | ( in Buf [ in Ptr ++ ] & _ NUM ) ; break ; case _ NUM : i = ( ( i & _ NUM ) << _ NUM ) | ( ( in Buf [ in Ptr ++ ] & _ NUM ) << _ NUM ) | ( in Buf [ in Ptr ++ ] & _ NUM ) ; break ; case _ NUM : i = ( ( i & _ NUM ) << _ NUM ) | ( ( in Buf [ in Ptr ++ ] & _ NUM ) << _ NUM ) | ( ( in Buf [ in Ptr ++ ] & _ NUM ) << _ NUM ) | ( in Buf [ in Ptr ++ ] & _ NUM ) ; i -= _ NUM ; out Buf [ out Ptr ++ ] = ( char ) ( _ NUM | ( i > > _ NUM ) ) ; i = _ NUM | ( i & _ NUM ) ; break ; default : _report Error ( _ STR +  Integer . to Hex String ( i ) + _ STR ) ; } } out Buf [ out Ptr ++ ] = ( char ) i ; } _text Buffer . set Current Length ( out Ptr ) ; return _text Buffer . contents As String ( ) ; }
private static boolean filter (  Stack Trace Element e ) { if ( e . get Line Number ( ) == _ NUM ) { return _ BOOL ; }  String cn = e . get Class Name ( ) ; if ( cn . contains ( _ STR ) ) { return _ BOOL ; } if ( cn . contains ( _ STR ) || cn . contains ( _ STR ) || cn . contains ( _ STR ) ) { return _ BOOL ; } if ( cn . contains ( _ STR ) || cn . contains ( _ STR ) ) { return _ BOOL ; } if ( cn . contains ( _ STR ) ) { return _ BOOL ; } if ( cn . contains ( _ STR ) || cn . contains ( _ STR ) || cn . contains ( _ STR ) ) { return _ BOOL ; } return _ BOOL ; }
public  String debug ( ) {  String Builder builder = new  String Builder ( ) ; for (  Entry <  Journal File ,  Atomic Integer > entry : neg Counts . entry Set ( ) ) { builder . append ( _ STR + entry . get Key ( ) + _ STR + entry . get Value ( ) + _ STR ) ; } return builder . to String ( ) ; }
public void sort ( ) {  Collections . sort ( this . labels ) ; }
public static  Event Bean [ ] add To Array (  Event Bean [ ] array ,  Event Bean event To Add ) {  Event Bean [ ] new Array = new  Event Bean [ array . length + _ NUM ] ;  System . arraycopy ( array , _ NUM , new Array , _ NUM , array . length ) ; new Array [ new Array . length - _ NUM ] = event To Add ; return new Array ; }
public static  String replace (  String a ,  String b ,  String c ) {  String Buffer result = new  String Buffer ( c . length ( ) ) ; int i = _ NUM ; int j = c . index Of ( a ) ; while ( j >= i ) { result . append ( c . substring ( i , j ) ) ; result . append ( b ) ; i = j + a . length ( ) ; j = c . index Of ( a , i ) ; } result . append ( c . substring ( i , c . length ( ) ) ) ; return result . to String ( ) ; }
protected void on Page Scrolled ( int position , float offset , int offset Pixels ) { if ( m Decor Child Count > _ NUM ) { final int scroll Y = get Scroll Y ( ) ; int padding Top = get Padding Top ( ) ; int padding Bottom = get Padding Bottom ( ) ; final int height = get Height ( ) ; final int child Count = get Child Count ( ) ; for ( int i = _ NUM ; i < child Count ; i ++ ) { final  View child = get Child At ( i ) ; final  Layout Params lp = (  Layout Params ) child . get Layout Params ( ) ; if ( ! lp . is Decor ) continue ; final int vgrav = lp . gravity &  Gravity .  VERTICAL_ GRAVITY_ MASK ; int child Top = _ NUM ; switch ( vgrav ) { default : child Top = padding Top ; break ; case  Gravity .  TOP : child Top = padding Top ; padding Top += child . get Height ( ) ; break ; case  Gravity .  CENTER_ VERTICAL : child Top =  Math . max ( ( height - child . get Measured Height ( ) ) / _ NUM , padding Top ) ; break ; case  Gravity .  BOTTOM : child Top = height - padding Bottom - child . get Measured Height ( ) ; padding Bottom += child . get Measured Height ( ) ; break ; } child Top += scroll Y ; final int child Offset = child Top - child . get Top ( ) ; if ( child Offset != _ NUM ) { child . offset Top And Bottom ( child Offset ) ; } } } if ( m On Page Change Listener != null ) { m On Page Change Listener . on Page Scrolled ( position , offset , offset Pixels ) ; } if ( m Internal Page Change Listener != null ) { m Internal Page Change Listener . on Page Scrolled ( position , offset , offset Pixels ) ; } if ( m Page Transformer != null ) { final int scroll Y = get Scroll Y ( ) ; final int child Count = get Child Count ( ) ; for ( int i = _ NUM ; i < child Count ; i ++ ) { final  View child = get Child At ( i ) ; final  Layout Params lp = (  Layout Params ) child . get Layout Params ( ) ; if ( lp . is Decor ) continue ; final float transform Pos = ( float ) ( child . get Top ( ) - scroll Y ) / get Client Height ( ) ; m Page Transformer . transform Page ( child , transform Pos ) ; } } m Called Super = _ BOOL ; }
private void reflect Member Variables In Right Button ( ) { final boolean last Page Reached = ( view Pager . get Current Item ( ) + _ NUM ) == pages . size ( ) ; final boolean button Should Be Invisible = last Page Reached || right Button Disabled ; final boolean button Is Currently Invisible = right Button . get Visibility ( ) ==  View .  INVISIBLE ; final boolean should Update Button = button Should Be Invisible != button Is Currently Invisible ; if ( should Update Button ) { final  Animator button Animator = button Should Be Invisible ? button Animator Factory . new Right Button Disappear Animator ( right Button ) : button Animator Factory . new Right Button Appear Animator ( right Button ) ; if ( button Should Be Invisible ) { disable Button ( button Animator , right Button ) ; } else { enable Button ( button Animator , right Button ) ; } } }
public void test Decoder5 ( ) { boolean res ;  String original App Id Name = m App Id Name ; int original Content Type Value = m Content Type Value ;  Random rd = new  Random ( ) ; for ( int i = _ NUM ; i < _ NUM ; i ++ ) { m App Id Value = rd . next Int ( _ NUM ) ; m Content Type Value = rd . next Int ( _ NUM ) ; byte [ ] pdu = create PDU ( _ NUM ) ;  Wsp Type Decoder pdu Decoder = new  Wsp Type Decoder ( pdu ) ; res = pdu Decoder . seek XWap Application Id ( m Wsp Header Start , m Wsp Header Start + m Wsp Header Len - _ NUM ) ; assert True ( res ) ; int index = ( int ) pdu Decoder . get Value32 ( ) ; res = pdu Decoder . decode XWap Application Id ( index ) ; assert True ( res ) ;  Log . d (  LOG_ TAG , _ STR + m App Id Name + _ STR + pdu Decoder . get Value String ( ) + _ STR ) ; assert True ( m App Id Name . equals ( pdu Decoder . get Value String ( ) ) ) ; } m App Id Name = original App Id Name ; m Content Type Value = original Content Type Value ; }
public static boolean is Writable ( @  Non Null final  File file ) { boolean is Existing = file . exists ( ) ; try {  File Output Stream output = new  File Output Stream ( file , _ BOOL ) ; try { output . close ( ) ; } catch (  IOException e ) { } } catch (  File Not Found Exception e ) { if ( ! file . is Directory ( ) ) { return _ BOOL ; } } boolean result = file . can Write ( ) ; if ( ! is Existing ) { file . delete ( ) ; } return result ; }
public  Priority Queue (  Priority Queue < ? extends  E > c ) { get From Priority Queue ( c ) ; }
public  Cas Idm Accessor (  Cas Idm Client idm Client ) { logger . debug ( _ STR ) ;  Validate . not Null ( idm Client ) ; client = idm Client ; }
public void rotate X ( double theta ) {  Matrix3 D tmp = new  Matrix3 D ( ) ; double c =  Math . cos ( theta ) ; double s =  Math . sin ( theta ) ; tmp . set ( _ NUM , _ NUM , c ) ; tmp . set ( _ NUM , _ NUM , - s ) ; tmp . set ( _ NUM , _ NUM , s ) ; tmp . set ( _ NUM , _ NUM , c ) ; pre Multiply ( tmp ) ; }
public  Service Host start Factory (  Supplier <  Factory Service > factory Creator ,  String service Path ) {  Operation post =  Operation . create Post (  Uri Utils . build Uri ( this , service Path ) ) ;  Factory Service factory Service = factory Creator . get ( ) ; return start Service ( post , factory Service ) ; }
private void wake In ( ) {  State In Pipe state Old ;  State In Pipe state New ; do { state Old = _state In Ref . get ( ) ; if ( state Old . is Active ( ) ) { return ; } state New = state Old . to Wake ( ) ; } while ( ! _state In Ref . compare And Set ( state Old , state New ) ) ; if ( state Old ==  State In Pipe .  IDLE ) { try (  Outbox Amp outbox =  Outbox Amp . current Or Create ( _services ) ) {  Objects . require Non Null ( outbox ) ;  Pipe Wake In Message <  T > msg = new  Pipe Wake In Message < > ( outbox , _in Ref , this ) ; outbox . offer ( msg ) ; } } }
protected  Set <  FIs A > create Initial Assignment Constraints ( final  Annotated Type Mirror assigned To , final  Annotated Type Mirror boxed Return Type , final  Annotated Type Factory type Factory , final  Set <  Type Variable > targets ) { final  Set <  FIs A > result = new  Linked Hash Set < > ( ) ; if ( assigned To != null ) { final  Set <  AFConstraint > reduced Constraints = new  Linked Hash Set < > ( ) ; final  Queue <  AFConstraint > constraints = new  Linked List < > ( ) ; constraints . add ( new  F2 A ( boxed Return Type , assigned To ) ) ; reduce Af Constraints ( type Factory , reduced Constraints , constraints , targets ) ; for ( final  AFConstraint reduced Constraint : reduced Constraints ) { if ( reduced Constraint instanceof  FIs A ) { result . add ( (  FIs A ) reduced Constraint ) ; } } } return result ; }
public static  String clean Text (  String text ) {  String plain Text = text ; plain Text = plain Text . replace All ( _ STR , _ STR ) ; plain Text = plain Text . replace All ( _ STR , _ STR ) ; plain Text = plain Text . replace All ( _ STR , _ STR ) ; plain Text = plain Text . replace All ( _ STR , _ STR ) ; plain Text = plain Text . replace All ( _ STR , _ STR ) ; plain Text = plain Text . replace All ( _ STR , _ STR ) ; plain Text = plain Text . replace ( _ STR , _ STR ) ; plain Text = plain Text . replace ( _ STR , _ STR ) ; plain Text = plain Text . replace ( _ STR , _ STR ) ; plain Text = plain Text . replace ( _ STR , _ STR ) ; plain Text = plain Text . replace ( _ STR , _ STR ) ; plain Text = plain Text . replace ( _ STR , _ STR ) ; plain Text = plain Text . replace ( _ STR , _ STR ) ; plain Text = plain Text . replace ( _ STR , _ STR ) ; plain Text = plain Text . replace ( _ STR , _ STR ) ; plain Text = plain Text . replace ( _ STR , _ STR ) ; plain Text = plain Text . replace ( _ STR , _ STR ) ; plain Text = plain Text . replace ( _ STR , _ STR ) ; plain Text = plain Text . replace All ( _ STR , _ STR ) ; return plain Text ; }
public  Partitions prune Partitions (  Set <  String > valid Partitions ) { if ( valid Partitions != null && ! valid Partitions . is Empty ( ) ) { partitions . retain All ( valid Partitions ) ; } return this ; }
public  Channel Change Listener (  String group Name ,  Sound Group group ) { this . group = group ; this . group Name = group Name ; }
public  Pla Direction (  Pla Vector Int p_vector ) { this (  Big Integer . value Of ( p_vector . v_x ) ,  Big Integer . value Of ( p_vector . v_y ) ) ; }
protected void dispatch Result (  Runnable command ) { command . run ( ) ; }
@  Suppress Warnings ( { _ STR , _ STR } ) public static int calculate Max Bitmap Size ( @  Non Null  Context context ) {  Window Manager wm = (  Window Manager ) context . get System Service (  Context .  WINDOW_ SERVICE ) ;  Display display = wm . get Default Display ( ) ;  Point size = new  Point ( ) ; int width , height ; if (  Build .  VERSION .  SDK_ INT >=  Build .  VERSION_ CODES .  HONEYCOMB_ MR2 ) { display . get Size ( size ) ; width = size . x ; height = size . y ; } else { width = display . get Width ( ) ; height = display . get Height ( ) ; } int max Bitmap Size = ( int )  Math . sqrt (  Math . pow ( width , _ NUM ) +  Math . pow ( height , _ NUM ) ) ;  Canvas canvas = new  Canvas ( ) ; final int max Canvas Size =  Math . min ( canvas . get Maximum Bitmap Width ( ) , canvas . get Maximum Bitmap Height ( ) ) ; if ( max Canvas Size > _ NUM ) { max Bitmap Size =  Math . min ( max Bitmap Size , max Canvas Size ) ; } final int max Texture Size =  Egl Utils . get Max Texture Size ( ) ; if ( max Texture Size > _ NUM ) { max Bitmap Size =  Math . min ( max Bitmap Size , max Texture Size ) ; }  Log . d (  TAG , _ STR + max Bitmap Size ) ; return max Bitmap Size ; }
public void add Charge (  Attack Action ea ) { pending Charges . add Element ( ea ) ; process Game Event ( new  Game New Action Event ( this , ea ) ) ; }
public void test Overwite ( ) throws  Exception {  File config Home = new  File ( configuration . get Home ( ) ) ; assert True ( _ STR , config Home . exists ( ) && config Home . is Directory ( ) ) ;  File existing File = create File ( config Home , _ STR , _ STR ) ; assert Equals ( _ STR , read File ( existing File ) ) ;  String file Name = _ STR ;  String file Contents = _ STR ;  File file1 = create File ( config File Directory , file Name , file Contents ) ;  File Config config File = new  File Config ( ) ; config File . set File ( get Absolute Path ( file1 ) ) ; config File . set To File ( _ STR ) ; config File . set Overwrite ( _ STR ) ; test Copy ( config File , _ STR , _ STR ) ; assert Equals ( _ STR , read File ( existing File ) ) ; }
public byte [ ] encode Sort Key Bytes (  String value ) { return value . get Bytes (  UTF8 ) ; }
public void add Map Listener (  Map Listener listener ) { if ( listeners == null ) { listeners = new  Array List <  Map Listener > ( ) ; } listeners . add ( listener ) ; }
private  String render Tuple Expr (  Tuple Expr the Expr ) throws  Exception {  Sparql Tuple Expr Renderer a Renderer = new  Sparql Tuple Expr Renderer ( ) ; return a Renderer . render ( the Expr ) ; }
public static  String number String ( final int n ) { switch ( n ) { case _ NUM : return _ STR ; case _ NUM : return _ STR ; case _ NUM : return _ STR ; case _ NUM : return _ STR ; case _ NUM : return _ STR ; case _ NUM : return _ STR ; case _ NUM : return _ STR ; case _ NUM : return _ STR ; case _ NUM : return _ STR ; case _ NUM : return _ STR ; case _ NUM : return _ STR ; case _ NUM : return _ STR ; case _ NUM : return _ STR ; default : return  Integer . to String ( n ) ; } }
public void add Message (  Message message ) { messages . add ( message . render Text View ( context ) ) ; if ( messages . size ( ) > history Size ) { messages . remove ( _ NUM ) ; } notify Data Set Changed ( ) ; }
private void delete Children (  Element container ) { while ( container . has Child Nodes ( ) ) { container . remove Child ( container . get Last Child ( ) ) ; } }
public static  Date parse Standard Date (  String date ) {  Simple Date Format formatter = new  Simple Date Format ( _ STR ,  Locale . get Default ( ) ) ; formatter . set Lenient ( _ BOOL ) ; try { return formatter . parse ( date ) ; } catch (  Parse Exception e ) { e . print Stack Trace ( ) ; return new  Date ( ) ; } }
public void close ( ) { for (  Entry entry : entry List ) { entry . close ( ) ; } entry List . clear ( ) ; }
public static  Extension Registry create Registry With Default Extensions ( ) {  Extension Registry extension Registry = new  Extension Registry ( null ) ;  DEFAULT_ EXTENSIONS . for Each ( null ) ; return extension Registry ; }
private  String remove Trailing Period (  String val ) { if ( val . char At ( val . length ( ) - _ NUM ) == _ STR ) { val = val . substring ( _ NUM , val . length ( ) - _ NUM ) ; } return val ; }
private  Auto Completion Server .  Completion Items find Results (  String type ,  String prefix ,  String search ) { return server . get Completion Items ( type , prefix , search ) ; }
@  Override public  Enumeration <  Option > list Options ( ) {  Vector <  Option > result = new  Vector <  Option > ( ) ; result . add Element ( new  Option ( _ STR , _ STR , _ NUM , _ STR ) ) ; result . add All (  Collections . list ( super . list Options ( ) ) ) ; return result . elements ( ) ; }
private boolean has Proxy Settings (  Properties settings ) {  String proxy Host = settings . get Property ( _ STR , null ) ; return proxy Host != null && proxy Host . length ( ) > _ NUM ; }
public static void verify Getter Methods (  Class < ? > clazz ,  Mapped Field ... fields ) { for (  Mapped Field field : fields ) {  String field Name = field . get Name ( ) ;  Class < ? > field Type = field . get Type ( ) ;  String custom Get = field . get Method ( ) ; if ( ! is Null ( custom Get ) && ! custom Get . equals (  Constants .  DEFAULT_ ACCESSOR_ VALUE ) ) try { clazz . get Method ( custom Get ) ; continue ; } catch (  Exception e ) {  Error . custom Method ( _ STR , custom Get , clazz ) ; }  String method Name = get Method ( field Type , field Name ) ; try { clazz . get Method ( method Name ) ; } catch (  Exception e ) { if ( ! is Boolean ( field Type ) )  Error . method ( method Name , field Name , clazz ) ; try { method Name = ( m Get ( field Name ) ) ; clazz . get Method ( method Name ) ; } catch (  Exception e1 ) {  Error . method ( method Name , field Name , clazz ) ; } } field . get Method ( method Name ) ; } }
static public  String random Positive Whole ( int length ) { if ( length == _ NUM ) { return _ STR ; }  String Builder output = new  String Builder ( length ) ; output . append ( rnd . next Int ( _ NUM ) + _ NUM ) ; for ( int i = _ NUM ; i < length - _ NUM ; i ++ ) { output . append ( rnd . next Int ( _ NUM ) ) ; } return output . to String ( ) ; }
public final void add To Tiers By Var Names (  List <  String > var Names ) { if ( ! variables . contains All ( var Names ) ) { for (  String var Name : var Names ) { add Variable ( var Name ) ; } } for (  Object var Name : var Names ) {  String node = (  String ) var Name ; int index = node . last Index Of ( _ STR ) ; if ( index != - _ NUM ) {  String substring = node . substring ( index + _ NUM ) ; add To Tier ( new  Integer ( substring ) , node ) ; } } }
private void update Field Options ( ) {  String current Text = field Box . get Text ( ) ;  List <  String > fields = influx Service . get Fields ( measurement Box . get Text ( ) ) ; if ( null != fields ) { field Box . set Items ( fields . to Array ( new  String [ fields . size ( ) ] ) ) ; } field Box . set Text ( current Text ) ; }
public  IDevice learn Entity ( long mac Address ,  Short vlan ,  Integer ipv4 Address ,  Long switch DPID ,  Integer switch Port , boolean process Updates ) {  List <  IDevice Listener > listeners = device Listeners . get Ordered Listeners ( ) ; if ( ! process Updates ) { device Listeners . clear Listeners ( ) ; }  Vlan Vid v ;  IPv4 Address i ;  Datapath Id d ;  OFPort p ; if ( vlan != null && vlan . short Value ( ) <= _ NUM ) vlan = null ; if ( ipv4 Address != null && ipv4 Address == _ NUM ) ipv4 Address = null ; if ( vlan == null ) { v =  Vlan Vid . of Vlan ( - _ NUM ) ; } else { v =  Vlan Vid . of Vlan ( vlan ) ; } if ( ipv4 Address == null ) { i =  IPv4 Address .  NONE ; } else { i =  IPv4 Address . of ( ipv4 Address ) ; } if ( switch DPID == null ) { d =  Datapath Id . of ( _ NUM ) ; } else { d =  Datapath Id . of ( switch DPID . long Value ( ) ) ; } if ( switch Port == null ) { p =  OFPort .  ZERO ; } else { p =  OFPort . of ( switch Port ) ; }  IDevice res = learn Device By Entity ( new  Entity (  Mac Address . of ( mac Address ) , v , i , d , p , new  Date ( ) ) ) ; if ( listeners != null ) { for (  IDevice Listener listener : listeners ) { device Listeners . add Listener ( _ STR , listener ) ; } } return res ; }
public  Buffer create ( int level ) { if ( ! can Create ( ) ) { return null ; }  Buffer buffer = new  Buffer ( buffer Size , level , random Generator ) ;  List <  Buffer > buffer List = buffer Map . get ( level ) ; if ( buffer List == null ) { buffer List = new  Array List <  Buffer > ( ) ; buffer Map . put ( level , buffer List ) ; } buffer List . add ( buffer ) ; count ++ ; if ( level > max Level ) { max Level = level ; } return buffer ; }
public  String show Switch Wwn ( ) throws  Network Device Controller Exception {  SSHPrompt [ ] prompts = {  SSHPrompt .  POUND ,  SSHPrompt .  GREATER_ THAN ,  SSHPrompt .  MDS_ CONFIG ,  SSHPrompt .  MDS_ CONFIG_ IVR_ ZONE ,  SSHPrompt .  MDS_ CONFIG_ IVR_ ZONESET } ;  String Builder buf = new  String Builder ( ) ; send Wait For (  MDSDialog Properties . get String ( _ STR ) , default Timeout , prompts , buf ) ;  String [ ] lines = get Lines ( buf ) ;  String [ ] regex = {  MDSDialog Properties . get String ( _ STR ) } ;  String switch Wwn = null ;  String [ ] groups = new  String [ _ NUM ] ; for (  String line : lines ) { int index = match ( line , regex , groups ) ; switch ( index ) { case _ NUM : switch Wwn = groups [ _ NUM ] ; break ; } if ( switch Wwn != null ) { break ; } } return switch Wwn ; }
public static  String [ ] split (  String string , char c ) { if ( count Matches ( string , c ) <= _ NUM ) return new  String [ ] { string } ;  String s = string + c ;  String [ ] sa = new  String [ count Matches ( string , c ) + _ NUM ] ;  String Builder sb = new  String Builder ( ) ; char [ ] ca = s . to Char Array ( ) ; int n = _ NUM , x ; for ( x = _ NUM ; x < ca . length ; x ++ ) { if ( ca [ x ] == c ) { sa [ n ] = sb . to String ( ) ; sb = new  String Builder ( ) ; n ++ ; } else { sb . append ( ca [ x ] ) ; } } return sa ; }
private  Image Icon add Space To Icon (  Image Icon icon ) { int width = icon . get Icon Width ( ) ; int height = icon . get Icon Height ( ) ; int hspace = _ NUM ;  Buffered Image res = new  Buffered Image ( width + hspace , height ,  Buffered Image .  TYPE_ INT_ ARGB ) ;  Graphics g = res . get Graphics ( ) ; g . draw Image ( icon . get Image ( ) , _ NUM , _ NUM , null ) ; g . dispose ( ) ; return new  Image Icon ( res ) ; }
public static byte [ ] read All (  Input Stream in Str ) throws  IOException {  Byte Array Output Stream buf = new  Byte Array Output Stream ( ) ; pipe All ( in Str , buf ) ; return buf . to Byte Array ( ) ; }
public static boolean starts With Ignore Case (  String search In , int start At ,  String search For ) { return search In . region Matches ( _ BOOL , start At , search For , _ NUM , search For . length ( ) ) ; }
protected  Ignite start Remote Grid (  String grid Name ,  Ignite Configuration cfg ,  Grid Spring Resource Context ctx ) throws  Exception { if ( ctx != null ) throw new  Unsupported Operation Exception ( _ STR ) ; if ( cfg == null ) cfg = optimize ( get Configuration ( grid Name ) ) ; return new  Ignite Process Proxy ( cfg , log , grid ( _ NUM ) ) ; }
public void execute Command (  String shell Cmd ) { if ( m Thread != null && m Thread . is Alive ( ) ) { m Shell Thread . stop ( ) ; m Results = new  String Builder ( ) ; } m Current Command = shell Cmd ; m Shell Thread = new  Shell Thread ( ) ; m Thread = new  Thread ( m Shell Thread ) ; m Thread . start ( ) ; }
@  Override public  Env Var add New Env Var (  String name ,  Class < ? > type ,  String value ) {  Env Var env Var = null ; if ( ! exist ( name ) ) { env Var = new  Env Var ( name , type , _ BOOL ) ; env Var . set Value ( value ) ; env Var List . add ( env Var ) ; } return env Var ; }
static private  String calc Threshold ( double score Threshold , double lambda ) { final double log Prob Threshold =  Math . log ( _ NUM - score Threshold / _ NUM ) ; int max Num = _ NUM ; if ( calc Log Prob ( max Num , _ BOOL , lambda ) > log Prob Threshold ) { return _ STR ; } int min Num = _ NUM ; while ( min Num < max Num ) { final int mid Num = ( max Num + min Num ) / _ NUM ; final boolean pass Threshold = calc Log Prob ( mid Num , _ BOOL , lambda ) <= log Prob Threshold ; if ( pass Threshold ) { max Num = mid Num ; } else { if ( mid Num == min Num ) { break ; } min Num = mid Num ; } } return  Integer . to String ( max Num ) ; }
public static int index Of Last Separator (  String filename ) { if ( filename == null ) { return - _ NUM ; } int last Unix Pos = filename . last Index Of (  UNIX_ SEPARATOR ) ; int last Windows Pos = filename . last Index Of (  WINDOWS_ SEPARATOR ) ; return  Math . max ( last Unix Pos , last Windows Pos ) ; }
@  Category (  Flaky Test . class ) @  Test public void test Missing Member Redundancy1 ( ) {  Host host =  Host . get Host ( _ NUM ) ;  VM vm0 = host . get VM ( _ NUM ) ;  VM vm1 = host . get VM ( _ NUM ) ;  VM vm2 = host . get VM ( _ NUM ) ; create PR ( vm0 , _ NUM ) ; create PR ( vm1 , _ NUM ) ; create Data ( vm0 , _ NUM ,  NUM_ BUCKETS , _ STR ) ;  Set <  Integer > vm0 Buckets = get Bucket List ( vm0 ) ;  Set <  Integer > vm1 Buckets = get Bucket List ( vm1 ) ; close Cache ( vm1 ) ; check Data ( vm0 , _ NUM ,  NUM_ BUCKETS , _ STR ) ; remove Data ( vm0 , _ NUM ,  NUM_ BUCKETS / _ NUM ) ; create Data ( vm0 ,  NUM_ BUCKETS / _ NUM ,  NUM_ BUCKETS , _ STR ) ; create PR ( vm2 , _ NUM ) ;  Set <  Integer > vm2 Buckets = get Bucket List ( vm2 ) ; assert Equals (  Collections . empty Set ( ) , vm2 Buckets ) ; create PR ( vm1 , _ NUM ) ; check Data ( vm1 , _ NUM ,  NUM_ BUCKETS / _ NUM , null ) ; check Data ( vm1 ,  NUM_ BUCKETS / _ NUM ,  NUM_ BUCKETS , _ STR ) ; assert Equals ( vm0 Buckets , get Bucket List ( vm0 ) ) ; assert Equals ( vm1 Buckets , get Bucket List ( vm1 ) ) ; assert Equals (  Collections . empty Set ( ) , get Bucket List ( vm2 ) ) ; }
public static boolean [ ] parse String (  String [ ] values ) { boolean [ ] result = new boolean [ values . length ] ; for ( int i = _ NUM ; i < result . length ; i ++ ) { result [ i ] = parse String ( values [ i ] ) ; } return result ; }
public void delete Snapshot Schedule (  String id ) throws  Isilon Exception { try { id =  URLEncoder . encode ( id , _ STR ) ; } catch (  Unsupported Encoding Exception e ) { e . print Stack Trace ( ) ; } delete Snapshot Schedule ( _base Url . resolve (  URI_ SNAPSHOT_ SCHEDULES + _ STR + id ) ) ; }
private void parse Header ( final  String header ) {  LOG . debug ( _ STR , header ) ; final  String header Name = header . substring ( _ NUM , header . index Of ( _ STR ) ) ; if ( ! headers Map . contains Key ( header Name ) ) { final  String value = header . substring ( header . index Of ( _ STR ) + _ NUM ) ; headers Map . put ( header Name ,  String Utils . trim ( value ) ) ; } }
public  Block Mask (  Extent extent ,  Base Block ... block ) { this ( extent ,  Arrays . as List ( check Not Null ( block ) ) ) ; }
@  Deprecated public  String  Get Info From File ( ) {  File Input Stream in ; try {  File cache Root = new  File ( get Sdcard Path ( ) , package Name ) ; if ( ! cache Root . exists ( ) ) { return null ; }  File cache File = new  File ( cache Root , _ STR + package Name ) ; if ( ! cache File . exists ( ) ) { return null ; } in = new  File Input Stream ( cache File ) ;  String Buffer sb = new  String Buffer ( ) ; int i = _ NUM ; byte [ ] s = new byte [ _ NUM * _ NUM ] ; while ( ( i = in . read ( s ) ) != - _ NUM ) { sb . append ( new  String ( s , _ NUM , i ) ) ; } return sb . to String ( ) ; } catch (  Exception e ) { e . print Stack Trace ( ) ; return null ; } }
File create Temporary File (  File file ) throws  IOException { return  File . create Temp File ( file . get Name ( ) , _ STR , file . get Parent File ( ) ) ; }
public boolean has Denied Permission ( ) { for ( int i = _ NUM ; i < m Perms . size ( ) ; i ++ ) { if ( m Perms . get ( m User Permission . get ( i ) ) ==  Package Manager .  PERMISSION_ DENIED ) return _ BOOL ; } return _ BOOL ; }
public void execute (  Runnable r ) { executor Service . execute ( r ) ; }
private static  String remove Leading Space (  String raw ) { char c ; int i = _ NUM ; for ( ; i < raw . length ( ) ; i ++ ) { c = raw . char At ( i ) ; if ( c != _ STR && c != _ STR ) { break ; } } return raw . substring ( i , raw . length ( ) ) ; }
private static  List <  String > generate Get Method Names ( final  Field field ) { final  List <  String > prefix = new  Linked List <  String > ( ) ; prefix . add ( _ STR +  Attribute Helper . get Attribute Name ( field ) ) ; if ( field . get Type ( ) == boolean . class || field . get Type ( ) ==  Boolean . class ) { prefix . add ( _ STR +  Attribute Helper . get Attribute Name ( field ) ) ;  String field Name = field . get Name ( ) ; if ( field Name . length ( ) > _ NUM && field Name . starts With ( _ STR ) &&  Character . is Upper Case ( field Name . char At ( _ NUM ) ) ) prefix . add ( field Name ) ; } return prefix ; }
private  SQLDe Arger parse ( ) { while ( has Tokens ( ) ) {  String token = get Next Token ( ) ; if ( first Token ) { set SQLType ( token ) ; first Token = _ BOOL ; } token = ( is Float String ( token ) || is Quoted String ( token ) || ( token == null && is In String ( ) ) ) ? _ STR : token ; parsed SQL . append ( token ) ; } parse Matches ( ) ; return this ; }
public static double euclidean Distance ( double [ ] p , double [ ] q ) { double ret = _ NUM ; for ( int i = _ NUM ; i < p . length ; i ++ ) { double diff = ( q [ i ] - p [ i ] ) ; double sq =  Math . pow ( diff , _ NUM ) ; ret += sq ; } return ret ; }
public void load (  Byte Buffer buf ) { seq Id = buf . get Int ( ) ; n Rows = info . is Row Block Enabled ( ) ? buf . get Int ( ) : _ NUM ; load ( primary Key , buf ) ; for ( int i = _ NUM ; i < info . col Blocks . length ; i ++ ) {  Byte Array cb = cell Blocks [ i ] ; load ( cb , buf ) ; } }
public void debit (  Double debit Amount ) { if (  Double . compare ( debit Amount , _ NUM ) > _ NUM && this . balance - debit Amount > - _ NUM ) { apply ( new  Account Debited Event ( this . account No , debit Amount , this . balance ) ) ; } else { throw new  Illegal Argument Exception ( _ STR ) ; } }
private void update Radio Links ( ) { if ( m_ Exp != null ) { m_ Exp . set Split By Data Set ( m_split By Data Set . is Selected ( ) ) ; } }
private  String create Unique Name (  String base Name ) { int r = random . next Int ( ) ;  String suffix =  Integer . to String ( r ) ; if ( suffix . char At ( _ NUM ) == _ STR ) { suffix = suffix . replace ( _ STR , _ STR ) ; } return base Name + suffix ; }
public  List <  Properties > find All Properties (  String uri ) throws  IOException {  String fulluri = _path + uri ;  List <  Properties > properties = new  Array List < > ( ) ;  Enumeration <  URL > resources = get Resources ( fulluri ) ; while ( resources . has More Elements ( ) ) {  URL url = resources . next Element ( ) ;  Properties props = load Properties ( url ) ; properties . add ( props ) ; } return properties ; }
public void close ( ) { for (  Entry entry : entry List ) { entry . close ( ) ; } entry List . clear ( ) ; }
public static  String format URL (  String url ) { if ( !  Strings . is Null Or Empty ( url ) ) { try {  URI uri =  URI . create ( url ) ; if ( uri . is Absolute ( ) ) { return url ; } else { return _ STR + url ; } } catch (  Illegal Argument Exception e ) { return null ; } } else { return null ; } }
public void test Merge One Servlet Into Document With Same Servlet ( ) throws  Exception {  String src Xml = _ STR + _ STR + _ STR + _ STR + _ STR + _ STR ;  Web Xml src Web Xml =  Web Xml Io . parse Web Xml ( new  Byte Array Input Stream ( src Xml . get Bytes ( _ STR ) ) , null ) ;  String merge Xml = _ STR + _ STR + _ STR + _ STR + _ STR + _ STR ;  Web Xml merge Web Xml =  Web Xml Io . parse Web Xml ( new  Byte Array Input Stream ( merge Xml . get Bytes ( _ STR ) ) , null ) ;  Web Xml Merger merger = new  Web Xml Merger ( src Web Xml ) ; merger . merge ( merge Web Xml ) ; assert True (  Web Xml Utils . has Servlet ( src Web Xml , _ STR ) ) ; }
private  RE union REs (  Set <  RE > coll ) throws  Interrupted Exception { if ( coll . is Empty ( ) ) { return  RE . empty ; }  RE acc =  RE . empty ; for (  RE re : coll ) { acc = acc . union ( re ) ; } return acc ; }
DGCAck Handler (  UID id ) { this . id = id ; if ( id != null ) { assert ! id Table . contains Key ( id ) ; id Table . put ( id , this ) ; } }
public void register Fix ( @  Not Null  Intention Action fix , @  Nullable  Text Range range , @  Nullable final  Highlight Display Key key ) { if ( range == null ) { range = new  Text Range ( my Start Offset , my End Offset ) ; } if ( my Quick Fixes == null ) { my Quick Fixes = new  Array List <  Quick Fix Info > ( ) ; } my Quick Fixes . add ( new  Quick Fix Info ( fix , range , key ) ) ; }
protected void create Container (  IPath pathname ) { if ( directory Entry Cache . contains Key ( pathname ) ) { return ; }  Zip Entry parent ; if ( pathname . segment Count ( ) == _ NUM ) { parent = root ; } else { parent = (  Zip Entry ) directory Entry Cache . get ( pathname . remove Last Segments ( _ NUM ) ) ; }  Zip Entry new Entry = new  Zip Entry ( pathname . to String ( ) ) ; directory Entry Cache . put ( pathname , new Entry ) ; add To Children ( parent , new Entry ) ; }
private  String read Node Address ( ) {  String addr = _ STR ; addr = node Addr Field . get Text ( ) ; if ( addr . equals ( _ STR ) || addr . equals ( _ STR ) || addr . equals ( _ STR ) ) { addr = node Addr64 Field . get Text ( ) ; } return ( addr ) ; }
@  Override public void start Document (  XMLLocator locator ,  String encoding ,  Namespace Context namespace Context ,  Augmentations augs ) throws  XNIException { f Locator = locator ; if ( ! f Defer Node Expansion ) { if ( f Document Class Name . equals (  DEFAULT_ DOCUMENT_ CLASS_ NAME ) ) { f Document = new  Document Impl ( ) ; f Document Impl = (  Core Document Impl ) f Document ; f Document Impl . set Strict Error Checking ( _ BOOL ) ; f Document Impl . set Input Encoding ( encoding ) ; f Document Impl . set Document URI ( locator . get Expanded System Id ( ) ) ; } else if ( f Document Class Name . equals (  PSVI_ DOCUMENT_ CLASS_ NAME ) ) { f Document = new  PSVIDocument Impl ( ) ; f Document Impl = (  Core Document Impl ) f Document ; f Store PSVI = _ BOOL ; f Document Impl . set Strict Error Checking ( _ BOOL ) ; f Document Impl . set Input Encoding ( encoding ) ; f Document Impl . set Document URI ( locator . get Expanded System Id ( ) ) ; } else { try {  Class Loader cl =  Object Factory . find Class Loader ( ) ;  Class document Class =  Object Factory . find Provider Class ( f Document Class Name , cl , _ BOOL ) ; f Document = (  Document ) document Class . new Instance ( ) ;  Class default Doc Class =  Object Factory . find Provider Class (  CORE_ DOCUMENT_ CLASS_ NAME , cl , _ BOOL ) ; if ( default Doc Class . is Assignable From ( document Class ) ) { f Document Impl = (  Core Document Impl ) f Document ;  Class psvi Doc Class =  Object Factory . find Provider Class (  PSVI_ DOCUMENT_ CLASS_ NAME , cl , _ BOOL ) ; if ( psvi Doc Class . is Assignable From ( document Class ) ) { f Store PSVI = _ BOOL ; } f Document Impl . set Strict Error Checking ( _ BOOL ) ; f Document Impl . set Input Encoding ( encoding ) ; if ( locator != null ) { f Document Impl . set Document URI ( locator . get Expanded System Id ( ) ) ; } } } catch (  Class Not Found Exception e ) { } catch (  Exception e ) { throw new  Runtime Exception (  DOMMessage Formatter . format Message (  DOMMessage Formatter .  DOM_ DOMAIN , _ STR , new  Object [ ] { f Document Class Name } ) ) ; } } f Current Node = f Document ; } else { f Deferred Document Impl = new  Deferred Document Impl ( f Namespace Aware ) ; f Document = f Deferred Document Impl ; f Document Index = f Deferred Document Impl . create Deferred Document ( ) ; f Deferred Document Impl . set Input Encoding ( encoding ) ; f Deferred Document Impl . set Document URI ( locator . get Expanded System Id ( ) ) ; f Current Node Index = f Document Index ; } }
public static void silent Close Output Stream (  Output Stream os ) { try { if ( os != null ) { os . close ( ) ; } } catch (  IOException e ) { e . print Stack Trace ( ) ; } }
public void add Observer (  Observer observer ) { observers . add ( observer ) ; }
public  Builder with Heartbeat Interval (  Duration heartbeat Interval ) {  Assert . arg Not ( heartbeat Interval . is Negative ( ) || heartbeat Interval . is Zero ( ) , _ STR ) ;  Assert . arg Not ( heartbeat Interval . to Millis ( ) >= election Timeout . to Millis ( ) , _ STR ) ; this . heartbeat Interval =  Assert . not Null ( heartbeat Interval , _ STR ) ; return this ; }
@  Override public void serialize (  String name , byte [ ] message ,  Output Stream out ) throws  IOException { byte [ ] header = new byte [ _ NUM +  COMMAND_ LEN + _ NUM + _ NUM ] ; uint32 To Byte Array BE ( params . get Packet Magic ( ) , header , _ NUM ) ; for ( int i = _ NUM ; i < name . length ( ) && i <  COMMAND_ LEN ; i ++ ) { header [ _ NUM + i ] = ( byte ) ( name . code Point At ( i ) & _ NUM ) ; }  Utils . uint32 To Byte Array LE ( message . length , header , _ NUM +  COMMAND_ LEN ) ; byte [ ] hash =  Sha256 Hash . hash Twice ( message ) ;  System . arraycopy ( hash , _ NUM , header , _ NUM +  COMMAND_ LEN + _ NUM , _ NUM ) ; out . write ( header ) ; out . write ( message ) ; if ( log . is Debug Enabled ( ) ) log . debug ( _ STR , name ,  HEX . encode ( header ) +  HEX . encode ( message ) ) ; }
private  SSLContext create Ssl Context ( ) throws  SSLException { check Parameters ( ) ; try {  Key Manager Factory key Mgr Factory =  Key Manager Factory . get Instance ( key Algorithm ) ;  Key Store key Store = load Key Store ( key Store Type , key Store File Path , key Store Pwd ) ; key Mgr Factory . init ( key Store , key Store Pwd ) ;  Trust Manager [ ] mgrs = trust Mgrs ; if ( mgrs == null ) {  Trust Manager Factory trust Mgr Factory =  Trust Manager Factory . get Instance ( key Algorithm ) ;  Key Store trust Store = load Key Store ( trust Store Type , trust Store File Path , trust Store Pwd ) ; trust Mgr Factory . init ( trust Store ) ; mgrs = trust Mgr Factory . get Trust Managers ( ) ; }  SSLContext ctx =  SSLContext . get Instance ( proto ) ; ctx . init ( key Mgr Factory . get Key Managers ( ) , mgrs , null ) ; return ctx ; } catch (  General Security Exception e ) { throw new  SSLException ( _ STR + parameters ( ) , e ) ; } }
public  Escape Tokenizer (  String source ) { this . source = source ; this . source Length = source . length ( ) ; this . pos = _ NUM ; }
public void add Arg ( final  BOp new Arg ) { if ( new Arg == null ) throw new  Illegal Argument Exception ( ) ; if ( new Arg == this ) throw new  Illegal Argument Exception ( ) ; args . add ( new Arg ) ; mutation ( ) ; }
public static boolean [ ] convert String To Boolean Arr (  String no Dictionary Col Mapping ) {  String [ ] splitted Value = null != no Dictionary Col Mapping ? no Dictionary Col Mapping . split (  Carbon Common Constants .  COMA_ SPC_ CHARACTER ) : new  String [ _ NUM ] ; boolean [ ] no Dictionary Mapping = new boolean [ splitted Value . length ] ; int index = _ NUM ; for (  String str : splitted Value ) { no Dictionary Mapping [ index ++ ] =  Boolean . parse Boolean ( str ) ; } return no Dictionary Mapping ; }
protected void draw Axis Line (  Graphics2 D g2 , double cursor ,  Rectangle2 D data Area ,  Rectangle Edge edge ) {  Line2 D axis Line = null ; double x = data Area . get X ( ) ; double y = data Area . get Y ( ) ; if ( edge ==  Rectangle Edge .  TOP ) { axis Line = new  Line2 D .  Double ( x , cursor , data Area . get Max X ( ) , cursor ) ; } else if ( edge ==  Rectangle Edge .  BOTTOM ) { axis Line = new  Line2 D .  Double ( x , cursor , data Area . get Max X ( ) , cursor ) ; } else if ( edge ==  Rectangle Edge .  LEFT ) { axis Line = new  Line2 D .  Double ( cursor , y , cursor , data Area . get Max Y ( ) ) ; } else if ( edge ==  Rectangle Edge .  RIGHT ) { axis Line = new  Line2 D .  Double ( cursor , y , cursor , data Area . get Max Y ( ) ) ; } g2 . set Paint ( this . axis Line Paint ) ; g2 . set Stroke ( this . axis Line Stroke ) ;  Object saved = g2 . get Rendering Hint (  Rendering Hints .  KEY_ STROKE_ CONTROL ) ; g2 . set Rendering Hint (  Rendering Hints .  KEY_ STROKE_ CONTROL ,  Rendering Hints .  VALUE_ STROKE_ NORMALIZE ) ; g2 . draw ( axis Line ) ; g2 . set Rendering Hint (  Rendering Hints .  KEY_ STROKE_ CONTROL , saved ) ; }
public static void save KOML (  File save To ,  Object model ,  Instances header ) throws  Exception {  Vector <  Object > v = new  Vector <  Object > ( ) ; v . add ( model ) ; if ( header != null ) { v . add ( header ) ; } v . trim To Size ( ) ;  KOML . write ( save To . get Absolute Path ( ) , v ) ; }
protected static  Span find Root Or Server Span (  String tenant Id ,  Span span ,  Span Cache span Cache ) { while ( span != null && ! span . server Span ( ) && ! span . top Level Span ( ) ) { span = span Cache . get ( tenant Id , span . get Parent Id ( ) ) ; } return span ; }
public int split By Distance (  Array Modifiable DBIDs ind , int begin , int end ,  Double Data Store tpro ,  Random rand ) {  DBIDArray Iter it = ind . iter ( ) ; double rmin =  Double .  MAX_ VALUE * _ NUM , rmax = -  Double .  MAX_ VALUE * _ NUM ; int min Ind = begin , max Ind = end - _ NUM ; for ( it . seek ( begin ) ; it . get Offset ( ) < end ; it . advance ( ) ) { double curr Ele = tpro . double Value ( it ) ; rmin =  Math . min ( curr Ele , rmin ) ; rmax =  Math . max ( curr Ele , rmax ) ; } if ( rmin != rmax ) { double rs = rmin + rand . next Double ( ) * ( rmax - rmin ) ; while ( min Ind < max Ind ) { double curr Ele = tpro . double Value ( it . seek ( min Ind ) ) ; if ( curr Ele > rs ) { while ( min Ind < max Ind && tpro . double Value ( it . seek ( max Ind ) ) > rs ) { max Ind -- ; } if ( min Ind == max Ind ) { break ; } ind . swap ( min Ind , max Ind ) ; max Ind -- ; } min Ind ++ ; } } else { min Ind = ( begin + end ) > > > _ NUM ; } return min Ind ; }
public static  String no Prefix (  String path ,  String prefix ) { return path . starts With ( prefix ) ? path . substring ( prefix . length ( ) ) : path ; }
protected void subscribe ( ) throws  IOException { if ( sample Client Sub == null ) { try { sample Client Sub = new  Sample Async Wait ( url , client Id Sub , clean Session , quiet Mode , user Name , password ) ; } catch (  Mqtt Exception e ) { e . print Stack Trace ( ) ; } } if ( sample Client Sub != null ) {  String topic = _ STR ; int qos = _ NUM ; try { sample Client Sub . subscribe ( topic , qos ) ; } catch (  Throwable e ) { e . print Stack Trace ( ) ; } } }
public  Adaptable List add (  IAdaptable a ) { children . add ( a ) ; return this ; }
public static  Long Stream concat (  Long Stream a ,  Long Stream b ) {  Objects . require Non Null ( a ) ;  Objects . require Non Null ( b ) ;  Spliterator .  Of Long split = new  Streams .  Concat Spliterator .  Of Long ( a . spliterator ( ) , b . spliterator ( ) ) ;  Long Stream stream =  Stream Support . long Stream ( split , a . is Parallel ( ) || b . is Parallel ( ) ) ; return stream . on Close (  Streams . composed Close ( a , b ) ) ; }
public void force ( boolean metadata ) { mapped Buffer . force ( ) ; super . force ( metadata ) ; }
private void await Initialization ( ) { if ( init Latch . get Count ( ) > _ NUM ) { try {  U . await ( init Latch ) ; if ( init Failed ) throw new  Illegal State Exception ( _ STR ) ; } catch (  Ignite Interrupted Checked Exception e ) { throw new  Illegal State Exception ( _ STR + _ STR , e ) ; } } }
public boolean write Characteristic (  String address ,  String service UUID ,  String characteristic UUID ,  String value ) {  Bluetooth Gatt bluetooth Gatt = m Bluetooth Gatt Map . get ( address ) ; if ( bluetooth Gatt != null ) {  Bluetooth Gatt Service service = bluetooth Gatt . get Service (  UUID . from String ( service UUID ) ) ;  Bluetooth Gatt Characteristic characteristic = service . get Characteristic (  UUID . from String ( characteristic UUID ) ) ; characteristic . set Value ( value ) ; return bluetooth Gatt . write Characteristic ( characteristic ) ; } return _ BOOL ; }
public  XMLElement (  String full Name ,  String namespace ,  String system ID , int line Nr ) { this . attributes = new  Array List ( ) ; this . children = new  Array List ( _ NUM ) ; this . full Name = full Name ; if ( namespace == null ) { this . name = full Name ; } else { int index = full Name . index Of ( _ STR ) ; if ( index >= _ NUM ) { this . name = full Name . substring ( index + _ NUM ) ; } else { this . name = full Name ; } } this . namespace = namespace ; this . content = null ; this . line Nr = line Nr ; this . system ID = system ID ; this . parent = null ; }
public static  String read File Contents (  File file ) {  String Builder script Text = new  String Builder ( ) ;  String new Line =  System . get Property ( _ STR ) ;  Scanner scanner = null ; try { scanner = new  Scanner ( new  File Input Stream ( file ) ) ; while ( scanner . has Next Line ( ) ) { script Text . append ( scanner . next Line ( ) + new Line ) ; } } catch (  File Not Found Exception e ) { e . print Stack Trace ( ) ; } finally { scanner . close ( ) ; } return script Text . to String ( ) ; }
public void add (  Json Element element ) { if ( element == null ) { element =  Json Null .  INSTANCE ; } elements . add ( element ) ; }
public  TSink <  String > send String (  TStream <  String > stream ) {  Objects . require Non Null ( stream , _ STR ) ; return send Text ( stream , null ) ; }
private  Type ( final int sort ) { this . sort = sort ; this . len = _ NUM ; }
public void delete Entity Descriptor (  String realm ,  String entity ID ) throws  IDFFMeta Exception { if ( entity ID == null ) {  Log Util . error (  Level .  INFO ,  Log Util .  NULL_ ENTITY_ ID , null ) ; throw new  IDFFMeta Exception ( _ STR , null ) ; } else { if ( ( realm == null ) || ( realm . length ( ) == _ NUM ) ) { realm =  ROOT_ REALM ; }  String [ ] args = { entity ID , realm } ; try {  Map old Attrs = idff Meta Config Instance . get Configuration ( realm , entity ID ) ; if ( old Attrs == null || old Attrs . is Empty ( ) ) {  Log Util . error (  Level .  INFO ,  Log Util .  ENTITY_ DOES_ NOT_ EXISTS , args ) ; throw new  IDFFMeta Exception ( _ STR , args ) ; } remove Entity From COT ( realm , entity ID ) ; idff Meta Config Instance . delete Configuration ( realm , entity ID , null ) ;  Log Util . access (  Level .  INFO ,  Log Util .  DELETE_ ENTITY_ SUCCEEDED , args ) ;  IDFFMeta Cache . set Entity Descriptor ( realm , entity ID , null ) ; } catch (  Configuration Exception ce ) { debug . error ( _ STR + entity ID , ce ) ;  Log Util . error (  Level .  INFO ,  Log Util .  DELETE_ ENTITY_ FAILED , args ) ; throw new  IDFFMeta Exception ( ce ) ; } catch (  Unsupported Operation Exception uoe ) { debug . error ( _ STR , uoe ) ;  Log Util . error (  Level .  INFO ,  Log Util .  UNSUPPORTED_ OPERATION , null ) ; throw new  IDFFMeta Exception ( _ STR , null ) ; } } }
public  Entity Query where (  Entity Condition ... entity Condition ) { this . where Entity Condition =  Entity Condition . make Condition (  Arrays . as List ( entity Condition ) ) ; return this ; }
public void test_journal_one Index No Data ( ) throws  IOException ,  Interrupted Exception ,  Execution Exception { final  File out =  File . create Temp File ( get Name ( ) ,  Options .  JNL ) ; try { final  Journal src = get Store ( get Properties ( ) ) ; try { final  String  NAME = _ STR ; src . register Index ( new  Index Metadata (  NAME ,  UUID . random UUID ( ) ) ) ; src . commit ( ) ; final  Future <  Map <  String ,  Base Index Stats > > f = src . warm Up ( null ) ; final  Map <  String ,  Base Index Stats > map = f . get ( ) ; assert Equals ( _ NUM , map . size ( ) ) ; final  Base Index Stats stats = map . get (  NAME ) ; assert Not Null ( stats ) ; assert Equals ( _ NUM , stats . height ) ; assert Equals ( _ NUM , stats . nnodes ) ; assert Equals ( _ NUM , stats . nleaves ) ; } finally { src . destroy ( ) ; } } finally { out . delete ( ) ; } }
public static void wrap Thread Loader (  Class Loader ldr ,  Runnable c ) {  Thread cur Thread =  Thread . current Thread ( ) ;  Class Loader ctx Ldr = cur Thread . get Context Class Loader ( ) ; try { cur Thread . set Context Class Loader ( ldr ) ; c . run ( ) ; } finally { cur Thread . set Context Class Loader ( ctx Ldr ) ; } }
public int index Of (  String sub String , int start ) { if ( start < _ NUM ) { start = _ NUM ; } int sub Count = sub String . length ( ) ; if ( sub Count > _ NUM ) { if ( sub Count + start > count ) { return - _ NUM ; } char first Char = sub String . char At ( _ NUM ) ; while ( _ BOOL ) { int i = start ; boolean found = _ BOOL ; for ( ; i < count ; i ++ ) { if ( value [ i ] == first Char ) { found = _ BOOL ; break ; } } if ( ! found || sub Count + i > count ) { return - _ NUM ; } int o1 = i , o2 = _ NUM ; while ( ++ o2 < sub Count && value [ ++ o1 ] == sub String . char At ( o2 ) ) { } if ( o2 == sub Count ) { return i ; } start = i + _ NUM ; } } return ( start < count || start == _ NUM ) ? start : count ; }
public void close ( ) throws  IOException { if ( m Input Stream != null ) { m Input Stream . close ( ) ; } else { throw new  IOException ( _ STR ) ; } m Input Stream = null ; }
static byte [ ] read Bytes (  Input Stream is , byte [ ] io Buffer , int max Size ) throws  IOException {  Byte Array Output Stream baos = new  Byte Array Output Stream ( ) ; copy Bytes ( baos , is , io Buffer , max Size ) ; return baos . to Byte Array ( ) ; }
private  String build Name (  String name Prefix ,  String name ) { return name Prefix . is Empty ( ) ? name : name Prefix + _ STR + name ; }
public void add Handler (  Warning Handler handler ) { _handlers . add ( handler ) ; }
private  String remove Trailing Period (  String val ) { if ( val . char At ( val . length ( ) - _ NUM ) == _ STR ) { val = val . substring ( _ NUM , val . length ( ) - _ NUM ) ; } return val ; }
final private  String class Def2 Object Desc (  Attributes attrs ) throws  Naming Exception {  String Buffer object Desc = new  String Buffer ( _ STR ) ;  Attribute attr = null ; int count = _ NUM ; attr = attrs . get (  NUMERICOID_ ID ) ; if ( attr != null ) { object Desc . append ( write Numeric OID ( attr ) ) ; count ++ ; } else { throw new  Configuration Exception ( _ STR + _ STR ) ; } attr = attrs . get (  NAME_ ID ) ; if ( attr != null ) { object Desc . append ( write QDescrs ( attr ) ) ; count ++ ; } attr = attrs . get (  DESC_ ID ) ; if ( attr != null ) { object Desc . append ( write QDString ( attr ) ) ; count ++ ; } attr = attrs . get (  OBSOLETE_ ID ) ; if ( attr != null ) { object Desc . append ( write Boolean ( attr ) ) ; count ++ ; } attr = attrs . get (  SUP_ ID ) ; if ( attr != null ) { object Desc . append ( write OIDs ( attr ) ) ; count ++ ; } attr = attrs . get (  ABSTRACT_ ID ) ; if ( attr != null ) { object Desc . append ( write Boolean ( attr ) ) ; count ++ ; } attr = attrs . get (  STRUCTURAL_ ID ) ; if ( attr != null ) { object Desc . append ( write Boolean ( attr ) ) ; count ++ ; } attr = attrs . get (  AUXILARY_ ID ) ; if ( attr != null ) { object Desc . append ( write Boolean ( attr ) ) ; count ++ ; } attr = attrs . get (  MUST_ ID ) ; if ( attr != null ) { object Desc . append ( write OIDs ( attr ) ) ; count ++ ; } attr = attrs . get (  MAY_ ID ) ; if ( attr != null ) { object Desc . append ( write OIDs ( attr ) ) ; count ++ ; } if ( count < attrs . size ( ) ) {  String attr Id = null ; for (  Naming Enumeration < ? extends  Attribute > ae = attrs . get All ( ) ; ae . has More Elements ( ) ; ) { attr = ae . next ( ) ; attr Id = attr . get ID ( ) ; if ( attr Id . equals (  NUMERICOID_ ID ) || attr Id . equals (  NAME_ ID ) || attr Id . equals (  SUP_ ID ) || attr Id . equals (  MAY_ ID ) || attr Id . equals (  MUST_ ID ) || attr Id . equals (  STRUCTURAL_ ID ) || attr Id . equals (  DESC_ ID ) || attr Id . equals (  AUXILARY_ ID ) || attr Id . equals (  ABSTRACT_ ID ) || attr Id . equals (  OBSOLETE_ ID ) ) { continue ; } else { object Desc . append ( write QDStrings ( attr ) ) ; } } } object Desc . append ( _ STR ) ; return object Desc . to String ( ) ; }
public  String (  String Buffer buffer ) { synchronized ( buffer ) { this . value =  Arrays . copy Of ( buffer . get Value ( ) , buffer . length ( ) ) ; } }
private static void skip Member Value (  Byte Buffer buf ) { int tag = buf . get ( ) ; skip Member Value ( tag , buf ) ; }
public void process Event (  Object the Event ) { if ( the Event instanceof  Timer Event ) { process Time Event ( (  Timer Event ) the Event ) ; return ; }  Event Bean event Bean ; if ( the Event instanceof  Event Bean ) { event Bean = (  Event Bean ) the Event ; } else { event Bean = wrap Event ( the Event ) ; } process Wrapped Event ( event Bean ) ; }
protected void add Field Config (  Field Config Base field Config ) { field Config List . add ( field Config ) ; }
private void hilite (  Graphics graphics ,  JComponent button ) { graphics . set Color ( style . get High Light Color ( ) ) ;  Insets insets = button . get Insets ( ) ; int width = button . get Width ( ) - insets . right - insets . left - _ NUM ; int height = button . get Height ( ) - insets . top - insets . bottom - _ NUM ; graphics . draw Rect ( insets . left , insets . top , width , height ) ; }
public static  String [ ] ls Files (  String directory ,  Filename Filter filter ) throws  IOException {  File dir = new  File ( directory ) ;  Array List <  String > files = new  Array List < > ( ) ; for (  File filepath : dir . list Files ( filter ) ) { if ( is File ( filepath . get Absolute Path ( ) ) ) files . add ( filepath . get Absolute Path ( ) ) ; } return files . to Array ( new  String [ files . size ( ) ] ) ; }
@  Override public  String to String ( ) {  String Buffer result ; if ( m_ Model == null ) { result = new  String Buffer ( _ STR ) ; } else { result = new  String Buffer ( ) ; result . append ( _ STR ) ; result . append ( _ STR ) ; result . append ( _ STR + get Model File ( ) + _ STR ) ; result . append ( m_ Model . to String ( ) ) ; } return result . to String ( ) ; }
public void add Property Change Listener (  Property Change Listener listener ) {  List <  Property Change Listener > l =  Arrays . as List ( listener List . get Listeners (  Property Change Listener . class ) ) ; if ( ! l . contains ( listener ) ) { listener List . add (  Property Change Listener . class , listener ) ; } }
@  Override public void refresh Index (  String row Id ,  Dimension Row dimension Row ,  Dimension Row dimension Row Old ) { refresh Index (  Collections . singleton Map ( row Id , new  Pair < > ( dimension Row , dimension Row Old ) ) ) ; }
public  Element simulate ( final  List <  Instruction > instructions ) { lock . lock ( ) ; try { return Element = null ; return simulate Internal ( instructions ) ; } finally { lock . unlock ( ) ; } }
public void remove All (  Principal caller ) throws  Not Owner Exception { if ( ! is Owner ( caller ) ) throw new  Not Owner Exception ( ) ; entry List . remove All Elements ( ) ; }
public void test Compare To Neg Neg1 ( ) { byte a Bytes [ ] = { _ NUM , _ NUM , _ NUM , - _ NUM , - _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , - _ NUM , _ NUM , _ NUM , _ NUM , _ NUM } ; byte b Bytes [ ] = { _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM } ; int a Sign = - _ NUM ; int b Sign = - _ NUM ;  Big Integer a Number = new  Big Integer ( a Sign , a Bytes ) ;  Big Integer b Number = new  Big Integer ( b Sign , b Bytes ) ; assert Equals ( - _ NUM , a Number . compare To ( b Number ) ) ; }
public int add Point (  Grab Point gp , int position ) { if ( gp == null ) { return - _ NUM ; } int x = gp . get X ( ) ; int y = gp . get Y ( ) ; int render Type = poly . get Render Type ( ) ;  Projection proj = get Projection ( ) ; if ( render Type ==  OMGraphic .  RENDERTYPE_ LATLON ) {  Debug . message ( _ STR , _ STR ) ; if ( proj != null ) { double [ ] ll = poly . get Lat Lon Array ( ) ; int actual Position = ( position ==  Integer .  MAX_ VALUE ? ll . length : position * _ NUM ) ;  Lat Lon Point llpnt = proj . inverse ( x , y , new  Lat Lon Point .  Double ( ) ) ; if (  Debug . debugging ( _ STR ) ) {  Debug . output ( _ STR + x + _ STR + y + _ STR + llpnt + _ STR ) ; for ( int j = _ NUM ; j < ll . length ; j += _ NUM ) {  Debug . output ( ll [ j ] + _ STR + ll [ j + _ NUM ] ) ; } } double [ ] newll = new double [ ll . length + _ NUM ] ; double newlat = llpnt . get Rad Lat ( ) ; double newlon = llpnt . get Rad Lon ( ) ; if ( actual Position >= ll . length ) { if ( ll . length != _ NUM ) {  System . arraycopy ( ll , _ NUM , newll , _ NUM , ll . length ) ; } newll [ ll . length ] = newlat ; newll [ ll . length + _ NUM ] = newlon ; position = ll . length / _ NUM ; } else if ( actual Position <= _ NUM ) {  System . arraycopy ( ll , _ NUM , newll , _ NUM , ll . length ) ; newll [ _ NUM ] = newlat ; newll [ _ NUM ] = newlon ; position = _ NUM ; } else { newll [ actual Position ] = newlat ; newll [ actual Position + _ NUM ] = newlon ;  System . arraycopy ( ll , _ NUM , newll , _ NUM , actual Position ) ;  System . arraycopy ( ll , actual Position , newll , actual Position + _ NUM , ll . length - actual Position ) ; } poly . set Location ( newll ,  OMGraphic .  RADIANS ) ; } } else if ( render Type ==  OMGraphic .  RENDERTYPE_ XY ) {  Debug . message ( _ STR , _ STR ) ; int current Length = poly . xs . length ; int [ ] newxs = new int [ current Length + _ NUM ] ; int [ ] newys = new int [ current Length + _ NUM ] ; if ( position >= current Length ) {  System . arraycopy ( poly . xs , _ NUM , newxs , _ NUM , current Length ) ;  System . arraycopy ( poly . ys , _ NUM , newys , _ NUM , current Length ) ; newxs [ current Length ] = x ; newys [ current Length ] = y ; position = current Length ; } else if ( position <= _ NUM ) {  System . arraycopy ( poly . xs , _ NUM , newxs , _ NUM , current Length ) ;  System . arraycopy ( poly . ys , _ NUM , newys , _ NUM , current Length ) ; newxs [ _ NUM ] = x ; newys [ _ NUM ] = y ; position = _ NUM ; } else { newxs [ position ] = x ; newys [ position ] = y ;  System . arraycopy ( poly . xs , _ NUM , newxs , _ NUM , position ) ;  System . arraycopy ( poly . xs , position , newxs , position + _ NUM , current Length - position ) ;  System . arraycopy ( poly . ys , _ NUM , newys , _ NUM , position ) ;  System . arraycopy ( poly . ys , position , newys , position + _ NUM , current Length - position ) ; } poly . set Location ( newxs , newys ) ; } else {  Debug . message ( _ STR , _ STR ) ; int current Length = poly . xs . length ; int [ ] newxs = new int [ current Length + _ NUM ] ; int [ ] newys = new int [ current Length + _ NUM ] ; if ( position >= current Length ) { position = current Length ;  System . arraycopy ( poly . xs , _ NUM , newxs , _ NUM , current Length ) ;  System . arraycopy ( poly . ys , _ NUM , newys , _ NUM , current Length ) ; } else if ( position <= _ NUM ) { position = _ NUM ;  System . arraycopy ( poly . xs , _ NUM , newxs , _ NUM , current Length ) ;  System . arraycopy ( poly . ys , _ NUM , newys , _ NUM , current Length ) ; } else {  System . arraycopy ( poly . xs , _ NUM , newxs , _ NUM , position ) ;  System . arraycopy ( poly . xs , position , newxs , position + _ NUM , current Length - position ) ;  System . arraycopy ( poly . ys , _ NUM , newys , _ NUM , position ) ;  System . arraycopy ( poly . ys , position , newys , position + _ NUM , current Length - position ) ; } int offset X ; int offset Y ; if ( gpo . get X ( ) == - _ NUM && gpo . get Y ( ) == - _ NUM ) { offset X = proj . get Width ( ) / _ NUM ; offset Y = proj . get Height ( ) / _ NUM ; } else { offset X = gpo . get X ( ) ; offset Y = gpo . get Y ( ) ; } if ( poly . coord Mode ==  OMPoly .  COORDMODE_ ORIGIN || position == _ NUM ) { newxs [ position ] = x - offset X ; newys [ position ] = y - offset Y ; } else { newxs [ position ] = x - offset X - newxs [ position - _ NUM ] ; newys [ position ] = y - offset Y - newys [ position - _ NUM ] ; } if ( position == _ NUM ) {  Lat Lon Point llpnt = proj . inverse ( offset X , offset Y , new  Lat Lon Point .  Double ( ) ) ; poly . lat = llpnt . get Rad Lat ( ) ; poly . lon = llpnt . get Rad Lon ( ) ; } poly . set Location ( poly . lat , poly . lon ,  OMGraphic .  RADIANS , newxs , newys ) ; }  OMArrow Head omah = poly . get Arrow Head ( ) ; poly . set Arrow Head ( null ) ; poly . set Arrow Head ( omah ) ; poly Grab Points . add ( position , gp ) ; if ( gpo != null ) { gpo . add Grab Point ( gp ) ; } poly . regenerate ( proj ) ; gp . generate ( proj ) ; return position ; }
public static void append Text (  Input Connection connection ,  String new Text ) { if ( connection == null ) { return ; } connection . finish Composing Text ( ) ;  Char Sequence char Before Cursor = connection . get Text Before Cursor ( _ NUM , _ NUM ) ; if ( char Before Cursor != null && ! char Before Cursor . equals ( _ STR ) && ( char Before Cursor . length ( ) > _ NUM ) ) { new Text = _ STR + new Text ; } connection . set Composing Text ( new Text , _ NUM ) ; }
public static double cdf ( double val , double rate ) { final double v = _ NUM *  Math . exp ( - rate * val ) ; return ( val < _ NUM ) ? v : _ NUM - v ; }
public static  Data Set read Discrete (  File file , char delimiter ) throws  IOException { return read In Discrete Data ( file , delimiter ,  Collections . singleton ( _ STR ) ) ; }
private  String generate Port Name ( ) {  String Buffer port Name = new  String Buffer ( _ STR ) ; int port Count = all Storage Ports List . size ( ) ; port Name = port Name . append (  String . value Of ( port Count - _ NUM ) ) ; return port Name . to String ( ) ; }
protected boolean can Paths Be Removed (  Tree Path [ ] paths ) { if ( row Mapper == null || selection == null || selection Mode ==  Tree Selection Model .  DISCONTIGUOUS_ TREE_ SELECTION ) return _ BOOL ; else {  Bit Set bit Set = new  Bit Set ( ) ; int counter ; int path Count = paths . length ; int an Index ; int min = - _ NUM ; int valid Count = _ NUM ;  Tree Path [ ] temp Path = new  Tree Path [ _ NUM ] ; int [ ] rows ; last Paths . clear ( ) ; for ( counter = _ NUM ; counter < path Count ; counter ++ ) { if ( paths [ counter ] != null ) { last Paths . put ( paths [ counter ] ,  Boolean .  TRUE ) ; } } for ( counter = selection . length - _ NUM ; counter >= _ NUM ; counter -- ) { if ( last Paths . get ( selection [ counter ] ) == null ) { temp Path [ _ NUM ] = selection [ counter ] ; rows = row Mapper . get Rows For Paths ( temp Path ) ; if ( rows != null && rows [ _ NUM ] != - _ NUM && ! bit Set . get ( rows [ _ NUM ] ) ) { valid Count ++ ; if ( min == - _ NUM ) min = rows [ _ NUM ] ; else min =  Math . min ( min , rows [ _ NUM ] ) ; bit Set . set ( rows [ _ NUM ] ) ; } } } last Paths . clear ( ) ; if ( valid Count > _ NUM ) { for ( counter = min + valid Count - _ NUM ; counter >= min ; counter -- ) if ( ! bit Set . get ( counter ) ) return _ BOOL ; } } return _ BOOL ; }
public  String Reader (  String s ) { this . str = s ; this . length = s . length ( ) ; }
private void update Style (  JPanel c ) {  Sea Glass Context context = get Context ( c ,  ENABLED ) ; style =  Sea Glass Look And Feel . update Style ( context , this ) ; context . dispose ( ) ;  Look And Feel . install Property ( c , _ STR , ! ( c . get Background ( ) instanceof  UIResource ) ) ; }
@  Override protected void on Measure ( int width Measure Spec , int height Measure Spec ) { int width Size =  Measure Spec . get Size ( width Measure Spec ) ; int width Mode =  Measure Spec . get Mode ( width Measure Spec ) ; int width ; int height Size =  Measure Spec . get Size ( height Measure Spec ) ; int height Mode =  Measure Spec . get Mode ( height Measure Spec ) ; int height ; final int count = get Child Count ( ) ; int max Child Width = _ NUM ; for ( int i = _ NUM ; i < count ; i ++ ) {  View child = get Child At ( i ) ; measure Child ( child , width Measure Spec , height Measure Spec ) ; } for ( int i = _ NUM ; i < m Menu Items . size ( ) ; i ++ ) {  Floating Action Button fab = m Menu Items . get ( i ) ;  Text View label = m Menu Item Labels . get ( i ) ; max Child Width =  Math . max ( max Child Width , label . get Measured Width ( ) + fab . get Measured Width ( ) ) ; } max Child Width =  Math . max ( m Menu Button . get Measured Width ( ) , max Child Width ) ; if ( width Mode ==  Measure Spec .  EXACTLY ) { width = width Size ; } else { width = max Child Width + _ NUM ; } if ( height Mode ==  Measure Spec .  EXACTLY ) { height = height Size ; } else { int height Sum = _ NUM ; for ( int i = _ NUM ; i < count ; i ++ ) {  View child = get Child At ( i ) ; height Sum += child . get Measured Height ( ) ; } height = height Sum + _ NUM ; } set Measured Dimension ( resolve Size ( width , width Measure Spec ) , resolve Size ( height , height Measure Spec ) ) ; }
public final void wait ( long timeout ) throws java . lang .  Interrupted Exception { wait ( timeout , _ NUM ) ; }
public  Multi Match Query Builder field (  String field , float boost ) { fields . add ( field ) ; if ( fields Boosts == null ) { fields Boosts = new  Object Float Hash Map < > ( ) ; } fields Boosts . put ( field , boost ) ; return this ; }
ASN1 Output Stream Writer ( final  Output Stream stream , final int max Buffer Size ) { this . out = stream ; this . root Stream = stream ; this . max Buffer Size =  Math . max ( max Buffer Size ,  BUFFER_ INIT_ SIZE ) ; this . stack Depth = - _ NUM ; }
public void register Sensor (  Sensor s , int i ) { if ( ( i < _ NUM ) || ( i > ( input Bytes [ node Type ] * _ NUM - _ NUM ) ) || ( i >  MAXSENSORS ) ) { log . error ( _ STR +  Integer . to String ( i + _ NUM ) ) ; return ; } has Active Sensors = _ BOOL ; if ( sensor Array [ i ] == null ) { sensor Array [ i ] = s ; if ( last Used Sensor < i ) { last Used Sensor = i ; } } else { log . warn ( _ STR +  Integer . to String ( ( get Node Address ( ) *  Serial Sensor Manager .  SENSORSPERNODE ) + i + _ NUM ) ) ; } }
private int id To Int (  String value ) { try { return  Integer . value Of ( value ) ; } catch (  Number Format Exception e ) { throw new  Configuration Exception ( _ STR + value ) ; } }
@  Override public final void sample ( ) { long count = _count . get ( ) ; long last Count = _last Count . get And Set ( count ) ; _value = count - last Count ; }
public int contents Size ( ) { return contents . size ( ) ; }
public static  Encryption Key [ ] acquire Secret Keys (  Principal Name princ ,  String keytab ) { if ( princ == null ) throw new  Illegal Argument Exception ( _ STR ) ;  Key Tab ktab =  Key Tab . get Instance ( keytab ) ; return ktab . read Service Keys ( princ ) ; }
void add Annotation ( @  Non Null  Annotation annotation ) { annotations . put ( annotation . annotation Type ( ) , annotation ) ; }
private static void ensure Packages (  File pkg ) throws  IOException { if ( ! pkg . exists ( ) && ! pkg . mkdirs ( ) ) throw new  IOException ( _ STR + pkg ) ; }
Enum Vertical Rotation ( int index ,  String name ,  Enum Facing facing , int num Rotations ) { this . index = index ; this . name = name ; this . facing = facing ; this . angle = num Rotations *  Math . to Radians ( _ NUM ) ; }
public  File create File Object (  String path ) { if ( path . length ( ) >= _ NUM && path . char At ( _ NUM ) == _ STR &&  Character . is Letter ( path . char At ( _ NUM ) ) ) { if ( path . length ( ) == _ NUM ) { path += _ STR ; } else if ( path . char At ( _ NUM ) != _ STR ) { path = path . substring ( _ NUM , _ NUM ) + _ STR + path . substring ( _ NUM ) ; } } return super . create File Object ( path ) ; }
public long real Length ( ) throws  IOException { long ret = backing Random Access File . length ( ) ; return ret ; }
public static boolean is Default Type (  String schema ) { for ( int i =  ALL_ MEDIA_ TYPES . length ; -- i >= _ NUM ; ) if ( schema . equals (  ALL_ MEDIA_ TYPES [ i ] . schema ) ) return _ BOOL ; return _ BOOL ; }
public void add Dependency (  Plugin dependency ) { dependencies . add ( dependency ) ; }
public static boolean is Network Available (  Context context ) {  Connectivity Manager connectivity Manager = (  Connectivity Manager ) context . get System Service (  Context .  CONNECTIVITY_ SERVICE ) ;  Network Info info = connectivity Manager . get Active Network Info ( ) ; return ( info != null && info . is Connected ( ) ) ; }
public static  String random Regexpish String (  Random r , int max Length ) { final  String Builder regexp = new  String Builder ( max Length ) ; for ( int i = next Int ( r , _ NUM , max Length ) ; i > _ NUM ; i -- ) { if ( r . next Boolean ( ) ) { regexp . append ( ( char )  Random Numbers . random Int Between ( r , _ STR , _ STR ) ) ; } else { regexp . append (  Random Picks . random From ( r , ops ) ) ; } } return regexp . to String ( ) ; }
@  Override public  Partition Key Group delete Partition Key Group (  Partition Key Group Key partition Key Group Key ) { partition Key Group Helper . validate Partition Key Group Key ( partition Key Group Key ) ;  Partition Key Group Entity partition Key Group Entity = partition Key Group Dao Helper . get Partition Key Group Entity ( partition Key Group Key ) ; if ( business Object Format Dao . get Business Object Format Count ( partition Key Group Entity ) > _ NUM ) { throw new  Illegal Argument Exception (  String . format ( _ STR , partition Key Group Key . get Partition Key Group Name ( ) ) ) ; } partition Key Group Dao . delete ( partition Key Group Entity ) ; return create Partition Key Group From Entity ( partition Key Group Entity ) ; }
@  Override public  String to String ( ) { return text . to String ( ) ; }
private void notify Low Memory ( ) { synchronized ( m Listeners ) { for (  Memory Listener listener : m Listeners ) { listener . on Low Memory ( ) ; } } }
public  Object extract Hard Ref (  Object o ) {  Weak Reference w = (  Weak Reference ) o ; if ( w != null ) { return w . get ( ) ; } return null ; }
public static  String format Integer ( int number ) { return int Format . format ( number ) ; }
private byte [ ] read Page Header (  Page page ) { return page . read Bytes ( _ NUM , this . page Header Size ) ; }
public void write Raw Bytes ( final byte [ ] value , int offset , int length ) throws  IOException { if ( limit - position >= length ) {  System . arraycopy ( value , offset , buffer , position , length ) ; position += length ; } else { final int bytes Written = limit - position ;  System . arraycopy ( value , offset , buffer , position , bytes Written ) ; offset += bytes Written ; length -= bytes Written ; position = limit ; refresh Buffer ( ) ; if ( length <= limit ) {  System . arraycopy ( value , offset , buffer , _ NUM , length ) ; position = length ; } else { output . write ( value , offset , length ) ; } } }
public  Properties read Backup Properties (  URI backup Loc ,  String backup Id ) throws  IOException {  Preconditions . check Not Null ( backup Loc ) ;  Preconditions . check Not Null ( backup Id ) ;  URI backup Path = repository . resolve ( backup Loc , backup Id ) ; if ( ! repository . exists ( backup Path ) ) { throw new  Solr Exception (  Error Code .  SERVER_ ERROR , _ STR + backup Path ) ; }  Properties props = new  Properties ( ) ; try (  Reader is = new  Input Stream Reader ( new  Properties Input Stream ( repository . open Input ( backup Path ,  BACKUP_ PROPS_ FILE ,  IOContext .  DEFAULT ) ) ,  Standard Charsets .  UTF_8 ) ) { props . load ( is ) ; return props ; } }
@  Request Mapping ( value = _ STR ) public void slo Error (  Locale locale , @  Path Variable ( value = _ STR )  String tenant ,  Http Servlet Response response ) throws  IOException { logger . info ( _ STR + locale . to String ( ) + _ STR + tenant ) ; slo Default Tenant Binding Error ( locale , response ) ; }
public synchronized void check State (  State required State ) throws  Illegal State Exception { if ( required State != current State ) { throw new  Illegal State Exception (  String . format (  Locale .  US , _ STR , required State , current State ) ) ; } }
public void remove Movie Set (  Movie Set movie Set ) { synchronized ( root ) {  Movie Set Tree Node node = (  Movie Set Tree Node ) node Map . get ( movie Set ) ; int index = root . get Index ( node ) ; movie Set . remove Property Change Listener ( property Change Listener ) ; node Map . remove ( movie Set ) ; for (  Movie movie : movie Set . get Movies ( ) ) { node Map . remove ( movie ) ; movie . remove Property Change Listener ( property Change Listener ) ; } node . remove All Children ( ) ; node . remove From Parent ( ) ;  Tree Model Event event = new  Tree Model Event ( this , root . get Path ( ) , new int [ ] { index } , new  Object [ ] { node } ) ; for (  Tree Model Listener listener : listeners ) { listener . tree Nodes Removed ( event ) ; } } }
public  String build Emr Cluster Name (  String namespace Cd ,  String emr Definition Name ,  String cluster Name ) {  String token Delimiter = configuration Helper . get Property (  Configuration Value .  TEMPLATE_ TOKEN_ DELIMITER ) ;  String namespace Token = token Delimiter + _ STR + token Delimiter ;  String emr Definition Token = token Delimiter + _ STR + token Delimiter ;  String cluster Name Token = token Delimiter + _ STR + token Delimiter ;  Map <  String ,  String > path To Token Value Map = new  Hash Map < > ( ) ; path To Token Value Map . put ( namespace Token , namespace Cd ) ; path To Token Value Map . put ( emr Definition Token , emr Definition Name ) ; path To Token Value Map . put ( cluster Name Token , cluster Name ) ;  String default Cluster Name Template = namespace Token + _ STR + emr Definition Token + _ STR + cluster Name Token ;  String emr Cluster Name = configuration Helper . get Property (  Configuration Value .  EMR_ CLUSTER_ NAME_ TEMPLATE ) ; if ( emr Cluster Name == null ) { emr Cluster Name = default Cluster Name Template ; } for (  Map .  Entry <  String ,  String > map Entry : path To Token Value Map . entry Set ( ) ) { emr Cluster Name = emr Cluster Name . replace All ( map Entry . get Key ( ) , map Entry . get Value ( ) ) ; } return emr Cluster Name ; }
private boolean poll Stats Broker Topic (  Destination topic ) { stats Message Listener . set Destination ( topic ) ;  LOGGER . info ( _ STR + get Queue Name ( topic ) ) ; jms Template . execute (  STATS_ BROKER_ DESTINATION + get Topic Name ( topic ) , new  Producer Callback Impl ( stats Queue ) ) ; try {  Thread . sleep ( _ NUM * _ NUM ) ; } catch (  Interrupted Exception e ) { e . print Stack Trace ( ) ; } return stats Message Listener . get Stats ( ) != null ; }
public static  String resolve Pathname ( final  String pathname ) { return (  String Utils . is Blank ( pathname ) ? pathname :  IOUtils . try Get Canonical Path Else Get Absolute Path ( new  File ( pathname ) ) ) ; }
public  String ruby Type Name (  Type Ref type Ref ) { switch ( type Ref . get Kind ( ) ) { case  TYPE_ MESSAGE : return ruby Type Name For Proto Element ( type Ref . get Message Type ( ) ) ; case  TYPE_ ENUM : return ruby Type Name For Proto Element ( type Ref . get Enum Type ( ) ) ; default : {  String name =  PRIMITIVE_ TYPE_ NAMES . get ( type Ref . get Kind ( ) ) ; if ( !  Strings . is Null Or Empty ( name ) ) { return name ; } throw new  Illegal Argument Exception ( _ STR + type Ref . get Kind ( ) ) ; } } }
public  Set <  State > post Event (  Event Data event Data ,  Long state Machine Instance Id ,  String correlation Id ) {  State Machine state Machine = null ; if ( state Machine Instance Id != null ) { state Machine = retrieve State Machine ( state Machine Instance Id ) ; } else if ( correlation Id != null ) { state Machine = retrieve State Machine By Correlation Id ( correlation Id ) ; state Machine Instance Id = ( state Machine == null ) ? null : state Machine . get Id ( ) ; } if ( state Machine == null ) throw new  Unknown State Machine ( _ STR + state Machine Instance Id + _ STR + correlation Id + _ STR ) ;  Event event = events DAO . find By SMId And Name ( state Machine Instance Id , event Data . get Name ( ) ) ; if ( event == null ) throw new  Illegal Event Exception ( _ STR + state Machine Instance Id + _ STR + event Data . get Name ( ) + _ STR ) ; event . set Status (  Event .  Event Status . triggered ) ; event . set Event Data ( event Data . get Data ( ) ) ; event . set Event Source ( event Data . get Event Source ( ) ) ; events DAO . update Event ( event ) ;  Context context = new  RAMContext (  System . current Time Millis ( ) , null , state Machine ) ; final  Set <  State > dependant States = context . get Dependant States ( event Data . get Name ( ) ) ; logger . debug ( _ STR , dependant States , event Data . get Name ( ) ) ;  Set <  State > executable States = get Executable States ( dependant States , state Machine Instance Id ) ; logger . debug ( _ STR , executable States , event Data . get Name ( ) ) ; execute States ( state Machine Instance Id , executable States ) ; return executable States ; }
protected void linear Layout (  Visual Table labels ) {  Rectangle2 D b = get Layout Bounds ( ) ; double breadth = get Breadth ( b ) ; double span = m_hi - m_lo ; double pspan = m_prevhi - m_prevlo ; double vlo = _ NUM ; if ( m_lo >= _ NUM ) { vlo =  Math . pow ( _ NUM ,  Math . floor (  Math Lib . log10 ( m_lo ) ) ) ; } else { vlo = -  Math . pow ( _ NUM , _ NUM +  Math . floor (  Math Lib . log10 ( - m_lo ) ) ) ; }  Iterator iter = labels . tuples ( ) ; while ( iter . has Next ( ) ) {  Visual Item item = (  Visual Item ) iter . next ( ) ; reset ( item ) ; double v = item . get Double (  VALUE ) ; double x = span == _ NUM ? _ NUM : ( ( v - m_lo ) / span ) * breadth ; set ( item , x , b ) ; }  Index index = labels . index (  VALUE ) ; double step = get Linear Step ( span , span == _ NUM ? _ NUM : breadth / span ) ; if ( step == _ NUM ) step = _ NUM ; int r ; for ( double x , v = vlo ; v <= m_hi ; v += step ) { x = ( ( v - m_lo ) / span ) * breadth ; if ( x < - _ NUM ) { continue ; } else if ( ( r = index . get ( v ) ) >= _ NUM ) {  Visual Item item = labels . get Item ( r ) ; item . set Visible ( _ BOOL ) ; item . set End Visible ( _ BOOL ) ; } else {  Visual Item item = labels . add Item ( ) ; item . set (  LABEL , m_nf . format ( v ) ) ; item . set Double (  VALUE , v ) ; double f = pspan == _ NUM ? _ NUM : ( ( v - m_prevlo ) / pspan ) ; if ( f <= _ NUM || f >= _ NUM ) item . set Start Visible ( _ BOOL ) ; set ( item , f * breadth , b ) ; set ( item , x , b ) ; } } }
public void clear Attributes ( ) { attributes . clear ( ) ; }
public static non_terminal find (  String with_name ) { if ( with_name == null ) return null ; else return ( non_terminal ) _all . get ( with_name ) ; }
public @  Check For Null  Block create New Block ( @  Nonnull  String system Name , @  Check For Null  String user Name ) throws  Illegal Argument Exception {  Block r ; if ( user Name != null && ! user Name . equals ( _ STR ) ) { r = get By User Name ( user Name ) ; if ( r != null ) { return null ; } } r = get By System Name ( system Name ) ; if ( r != null ) { return null ; }  String s Name = system Name . to Upper Case ( ) ; r = new  Block ( s Name , user Name ) ; register ( r ) ; if ( system Name . starts With ( _ STR ) ) { try { int auto Number =  Integer . parse Int ( system Name . substring ( _ NUM ) ) ; if ( auto Number > last Auto Block Ref ) { last Auto Block Ref = auto Number ; } } catch (  Number Format Exception e ) { log . warn ( _ STR + system Name + _ STR ) ; } } try { r . set Block Speed ( _ STR ) ; } catch ( jmri .  Jmri Exception ex ) { log . error ( ex . to String ( ) ) ; } return r ; }
public  Byte Vector ( byte [ ] values ) { this . values = new byte [ values . length ] ;  System . arraycopy ( values , _ NUM , this . values , _ NUM , values . length ) ; }
public boolean add Regex ( final  String regex ) { if ( regex != null && ! regex . is Empty ( ) ) { return regex List . add ( regex ) ; } return _ BOOL ; }
public  Char Buffer (  String string , int offset , int length ) { int capacity =  Math . max ( length ,  MIN_ CAPACITY ) ; init ( new char [ capacity ] , _ NUM , length ) ; string . get Chars ( offset , length , buffer ( ) , _ NUM ) ; }
private void update Promo Visibility ( float percentage ) { if ( is Promo Visible ( ) ) { m Promo Visible = _ BOOL ; m Promo Height Px =  Math . round (  Math Utils . clamp ( percentage * m Promo Content Height Px , _ NUM , m Promo Content Height Px ) ) ; m Promo Opacity = percentage ; } else { m Promo Visible = _ BOOL ; m Promo Height Px = _ NUM ; m Promo Opacity = _ NUM ; } }
public void update Geometry ( int row ,  Geometry geometry ) { set Value At ( geometry , row , get Geometry Field Index ( ) ) ; }
@  Override public void do_after_propagation ( ) { for (  Pt Ins Interval Manager pim : pt_objs . values ( ) ) { pim . flush ( ) ; } new_pts = new  Hash Map <  Alloc Node ,  Pt Ins Interval Manager > ( ) ; }
public static  String Set uri List To String Set (  List <  URI > uris ) {  String Set set = new  String Set ( ) ; if ( uris != null && ! uris . is Empty ( ) ) { for (  URI uri : uris ) { set . add ( uri . to String ( ) ) ; } } return set ; }
public  Position Layer (  Image image ) { this ( new  Image View ( image ) , image . get Width ( ) / - _ NUM , image . get Height ( ) / - _ NUM ) ; }
public boolean dyn Init ( ) { return m_data . load ( ) ; }
protected  Location Handler (  Location location ,  Option ... options ) { this . location = location ; this . options = options . length == _ NUM ?  Enum Set . none Of (  Option . class ) :  Enum Set . copy Of (  Arrays . as List ( options ) ) ; }
private void baseline Layout ( int origin , int size ) { int ascent ; int descent ; if ( baseline Anchored To Top ) { ascent = pref Ascent ; descent = size - ascent ; } else { ascent = size - pref Descent ; descent = pref Descent ; } for ( int counter = springs . size ( ) - _ NUM ; counter >= _ NUM ; counter -- ) {  Spring spring = get Spring ( counter ) ; int alignment = spring . get Alignment ( ) ; if ( alignment ==  NO_ ALIGNMENT || alignment ==  BASELINE ) { int baseline = spring . get Baseline ( ) ; if ( baseline >= _ NUM ) { int spring Max = spring . get Maximum Size (  VERTICAL ) ; int spring Pref = spring . get Preferred Size (  VERTICAL ) ; int height = spring Pref ; int y ; switch ( spring . get Baseline Resize Behavior ( ) ) { case  Component .  BRB_ CONSTANT_ ASCENT : y = origin + ascent - baseline ; height =  Math . min ( descent , spring Max - baseline ) + baseline ; break ; case  Component .  BRB_ CONSTANT_ DESCENT : height =  Math . min ( ascent , spring Max - spring Pref + baseline ) + ( spring Pref - baseline ) ; y = origin + ascent + ( spring Pref - baseline ) - height ; break ; default : y = origin + ascent - baseline ; break ; } spring . set Size (  VERTICAL , y , height ) ; } else { set Child Size ( spring ,  VERTICAL , origin , size ) ; } } else { set Child Size ( spring ,  VERTICAL , origin , size ) ; } } }
public static  String read String ( final  JSONArray json Array , final int index , final boolean required , final boolean not Null ) throws  JSONException { if ( required ) { return json Array . get String ( index ) ; } if ( not Null && json Array . is Null ( index ) ) { throw new  JSONException (  String . format (  Locale .  US ,  NULL_ VALUE_ FORMAT_ ARRAY , index ) ) ; }  String value = null ; if ( ! json Array . is Null ( index ) ) { value = json Array . get String ( index ) ; } return value ; }
public  String storage Policy Key And Version To String (  Storage Policy Key storage Policy Key ,  Integer storage Policy Version ) { return  String . format ( _ STR , storage Policy Key . get Namespace ( ) , storage Policy Key . get Storage Policy Name ( ) , storage Policy Version ) ; }
public final  String to String ( ) {  String Buffer text = new  String Buffer ( ) ; text . append ( _ STR + first + _ STR + last + _ STR ) ; text . append ( _ STR + num Instances + _ STR ) ; text . append ( _ STR + missing Instances + _ STR ) ; text . append ( _ STR + attr + _ STR ) ; text . append ( _ STR + sum + _ STR ) ; text . append ( _ STR + sqr Sum + _ STR ) ; text . append ( _ STR + sd + _ STR ) ; return text . to String ( ) ; }
private static  String [ ] to String Array ( final  Collection < ? > collection ) { if ( collection == null ) { return null ; } return collection . to Array ( new  String [ collection . size ( ) ] ) ; }
public static boolean any Misbehave (  Formatter formatter ,  List <  File > problem Files ) { long start =  System . current Time Millis ( ) ; for (  File problem : problem Files ) {  Padded Cell padded =  Padded Cell . check ( formatter , problem ) ; if ( padded . misbehaved ( ) ) { return _ BOOL ; } if (  System . current Time Millis ( ) - start >  MAX_ MS_ DETERMINING_ MISBEHAVIOR ) { return _ BOOL ; } } return _ BOOL ; }
public void label Distances (  Hypergraph <  V ,  E > graph ,  Set <  V > root Set ) { initialize ( graph , root Set ) ; int distance = _ NUM ; while ( _ BOOL ) {  List <  V > new List = new  Array List <  V > ( ) ; for (  V current Vertex : m Current List ) { if ( graph . contains Vertex ( current Vertex ) ) { for (  V next : graph . get Successors ( current Vertex ) ) { visit New Vertex ( current Vertex , next , distance , new List ) ; } } } if ( new List . size ( ) == _ NUM ) break ; m Current List = new List ; distance ++ ; } for (  V v : m Unvisited Vertices ) { distance Decorator . put ( v , new  Integer ( - _ NUM ) ) ; } }
public static java . lang .  String to String ( double d ) { double m =  Math . abs ( d ) ; if ( d ==  POSITIVE_ INFINITY ) { return _ STR ; } else if ( d ==  NEGATIVE_ INFINITY ) { return _ STR ; } else if ( d == _ NUM ) { return _ STR ; } else if ( m >= _ NUM && m < _ NUM ) {  String str = to String Impl ( d , _ BOOL ) ; char [ ] chars = str . to Char Array ( ) ; int i = chars . length - _ NUM ; char c ; while ( i >= _ NUM && ( c = chars [ i ] ) == _ STR ) { i -- ; } if ( i < _ NUM || str . index Of ( _ STR ) == - _ NUM ) { return str ; } else if ( chars [ i ] == _ STR || chars [ i ] == _ STR ) { i ++ ; } return str . substring ( _ NUM , i + _ NUM ) ; } else { return to String Impl ( d , _ BOOL ) ; } }
private  String read Line Trim Comments (  Buffered Reader br ) throws  IOException {  String line = br . read Line ( ) ; if ( line != null ) { line = line . trim ( ) ; if ( line . index Of ( _ STR ) == _ NUM ) { line = _ STR ; } } return line ; }
public final static  Header Element [ ] parse Elements ( final  String value ,  Header Value Parser parser ) throws  Parse Exception { if ( value == null ) { throw new  Illegal Argument Exception ( _ STR ) ; } if ( parser == null ) parser =  Save Header Value Parser .  DEFAULT ;  Char Array Buffer buffer = new  Char Array Buffer ( value . length ( ) ) ; buffer . append ( value ) ;  Save Parser Cursor cursor = new  Save Parser Cursor ( _ NUM , value . length ( ) ) ; return parser . parse Elements ( buffer , cursor ) ; }
public  Interval gap (  Readable Interval interval ) { interval =  Date Time Utils . get Readable Interval ( interval ) ; long other Start = interval . get Start Millis ( ) ; long other End = interval . get End Millis ( ) ; long this Start = get Start Millis ( ) ; long this End = get End Millis ( ) ; if ( this Start > other End ) { return new  Interval ( other End , this Start , get Chronology ( ) ) ; } else if ( other Start > this End ) { return new  Interval ( this End , other Start , get Chronology ( ) ) ; } else { return null ; } }
private  String read Node Address ( ) {  String addr = _ STR ; addr = node Addr Field . get Text ( ) ; if ( addr . equals ( _ STR ) || addr . equals ( _ STR ) || addr . equals ( _ STR ) ) { addr = node Addr64 Field . get Text ( ) ; } return ( addr ) ; }
public static boolean is Proxy Type (  Class < ? > type ) {  String name = type . get Name ( ) ; if ( name . starts With ( _ STR ) || name . starts With ( _ STR ) ) { return _ BOOL ; } return _ BOOL ; }
@  Suppress Warnings ( _ STR ) private void register Route (  Buffer buffer ) {  Json Object storage Object = new  Json Object ( buffer . to String ( ) ) ;  String request Url = storage Object . get String (  REQUESTURL ) ;  String routed Url = get Routed Url Segment ( request Url ) ; log . debug ( _ STR + routed Url ) ;  Json Object json Hook = storage Object . get Json Object (  HOOK ) ;  Json Array json Methods = json Hook . get Json Array ( _ STR ) ;  Http Hook hook = new  Http Hook ( json Hook . get String ( _ STR ) ) ; if ( json Methods != null ) { hook . set Methods ( json Methods . get List ( ) ) ; } if ( json Hook . get Integer (  EXPIRE_ AFTER ) != null ) { hook . set Expire After ( json Hook . get Integer (  EXPIRE_ AFTER ) ) ; } else { hook . set Expire After (  DEFAULT_ HOOK_ LISTENERS_ EXPIRE_ AFTER_ TIME ) ; } if ( json Hook . get Integer (  QUEUE_ EXPIRE_ AFTER ) != null ) { hook . set Queue Expire After ( json Hook . get Integer (  QUEUE_ EXPIRE_ AFTER ) ) ; } extract And Add Static Headers To Hook ( json Hook , hook ) ;  String expiration Time Expression = storage Object . get String (  EXPIRATION_ TIME ) ; if ( expiration Time Expression != null ) { try { hook . set Expiration Time (  Expiry Check Handler . parse Date Time ( expiration Time Expression ) ) ; } catch (  Exception e ) { log . warn ( _ STR + routed Url + _ STR + expiration Time Expression + _ STR ) ; return ; } } else { log . warn ( _ STR + routed Url + _ STR ) ; return ; } boolean full Url = storage Object . get Boolean (  FULL_ URL , _ BOOL ) ; hook . set Full Url ( full Url ) ; route Repository . add Route ( routed Url , create Route ( routed Url , hook ) ) ; }
private long download Index Files ( boolean download Complete Index ,  Directory index Dir ,  Directory tmp Index Dir , long latest Generation ) throws  Exception { if (  LOG . is Debug Enabled ( ) ) {  LOG . debug ( _ STR +  Arrays . as List ( index Dir . list All ( ) ) ) ; } long bytes Downloaded = _ NUM ; for (  Map <  String ,  Object > file : files To Download ) {  String filename = (  String ) file . get (  NAME ) ; long size = (  Long ) file . get (  SIZE ) ;  Compare Result compare Result = compare File ( index Dir , filename , size , (  Long ) file . get (  CHECKSUM ) ) ; if ( ! compare Result . equal || download Complete Index || files To Always Download If No Checksums ( filename , size , compare Result ) ) { dir File Fetcher = new  Directory File Fetcher ( tmp Index Dir , file , (  String ) file . get (  NAME ) ,  FILE , latest Generation ) ; current File = file ; dir File Fetcher . fetch File ( ) ; bytes Downloaded += dir File Fetcher . get Bytes Downloaded ( ) ; files Downloaded . add ( new  Hash Map < > ( file ) ) ; } else {  LOG . info ( _ STR + file . get (  NAME ) + _ STR ) ; } } return bytes Downloaded ; }
private static  String read Link Impl ( long handle ) throws  IOException { int size =  MAXIMUM_ REPARSE_ DATA_ BUFFER_ SIZE ;  Native Buffer buffer =  Native Buffers . get Native Buffer ( size ) ; try { try {  Device Io Control Get Reparse Point ( handle , buffer . address ( ) , size ) ; } catch (  Windows Exception x ) { if ( x . last Error ( ) ==  ERROR_ NOT_ A_ REPARSE_ POINT ) throw new  Not Link Exception ( null , null , x . error String ( ) ) ; x . rethrow As IOException ( (  String ) null ) ; } final short  OFFSETOF_ REPARSETAG = _ NUM ; final short  OFFSETOF_ PATHOFFSET = _ NUM ; final short  OFFSETOF_ PATHLENGTH = _ NUM ; final short  OFFSETOF_ PATHBUFFER = _ NUM + _ NUM ; int tag = ( int ) unsafe . get Long ( buffer . address ( ) +  OFFSETOF_ REPARSETAG ) ; if ( tag !=  IO_ REPARSE_ TAG_ SYMLINK ) { throw new  Not Link Exception ( null , null , _ STR ) ; } short name Offset = unsafe . get Short ( buffer . address ( ) +  OFFSETOF_ PATHOFFSET ) ; short name Length In Bytes = unsafe . get Short ( buffer . address ( ) +  OFFSETOF_ PATHLENGTH ) ; if ( ( name Length In Bytes % _ NUM ) != _ NUM ) throw new  File System Exception ( null , null , _ STR ) ; char [ ] name = new char [ name Length In Bytes / _ NUM ] ; unsafe . copy Memory ( null , buffer . address ( ) +  OFFSETOF_ PATHBUFFER + name Offset , name ,  Unsafe .  ARRAY_ CHAR_ BASE_ OFFSET , name Length In Bytes ) ;  String target = strip Prefix ( new  String ( name ) ) ; if ( target . length ( ) == _ NUM ) { throw new  IOException ( _ STR ) ; } return target ; } finally { buffer . release ( ) ; } }
public void remove (  String key ) {  Iterator <  Pair <  String ,  Array List <  String > > > it = store . iterator ( ) ; while ( it . has Next ( ) ) {  String this Key = it . next ( ) . first ; if ( key . equals ( this Key ) ) { it . remove ( ) ; break ; } } }
public static  JPanel create Radiobox (  String boxlabel ,  String [ ] buttons , int initially Selected ,  Action Listener al ) {  JPanel jp = create Palette JPanel ( boxlabel ) ;  Button Group buttongroup = new  Button Group ( ) ; for ( int j = _ NUM ; j < buttons . length ; j ++ ) {  JRadio Button jrb = new  JRadio Button ( buttons [ j ] ) ; jrb . set Action Command ( _ STR + j ) ; jp . add ( jrb ) ; buttongroup . add ( jrb ) ; if ( al != null ) { jrb . add Action Listener ( al ) ; } if ( j == initially Selected ) { jrb . set Selected ( _ BOOL ) ; } else { jrb . set Selected ( _ BOOL ) ; } } return jp ; }
public static final  String [ ] decode (  String src ) { if ( src == null || src . length ( ) == _ NUM ) { return ( new  String [ _ NUM ] ) ; } return  String Utils . split ( src ,  SEPARATOR ) ; }
public static void recompute Covariance Matrices (  Relation < ? extends  Number Vector > relation ,  Writable Data Store < double [ ] > prob Cluster IGiven X ,  List < ? extends  EMCluster Model < ? > > models ) { for (  EMCluster Model < ? > m : models ) { m . begin EStep ( ) ; } double [ ] wsum = new double [ models . size ( ) ] ; for (  DBIDIter iditer = relation . iter DBIDs ( ) ; iditer . valid ( ) ; iditer . advance ( ) ) { double [ ] cluster Probabilities = prob Cluster IGiven X . get ( iditer ) ;  Number Vector instance = relation . get ( iditer ) ; int i = _ NUM ; for (  EMCluster Model < ? > m : models ) { final double prior = cluster Probabilities [ i ] ; if ( prior > _ NUM ) { m . update E ( instance , prior ) ; } wsum [ i ] += prior ; ++ i ; } } int i = _ NUM ; for (  EMCluster Model < ? > m : models ) { m . finalize EStep ( ) ; m . set Weight ( wsum [ i ] / relation . size ( ) ) ; i ++ ; } }
public static  URI uri (  String value ) { return ( value != null && value . length ( ) > _ NUM ) ?  URI . create ( value ) : null ; }
public  Byte Vector ( byte [ ] values ) { this . values = new byte [ values . length ] ;  System . arraycopy ( values , _ NUM , this . values , _ NUM , values . length ) ; }
private void partition Class (  GVCongruence Class partition ) {  Iterator <  Value Graph Vertex > i = partition . iterator ( ) ;  Value Graph Vertex first = i . next ( ) ;  Array List <  GVCongruence Class > new Classes = new  Array List <  GVCongruence Class > ( ) ;  Array List <  Value Graph Vertex > to Remove = new  Array List <  Value Graph Vertex > ( ) ; while ( i . has Next ( ) ) {  Value Graph Vertex v = i . next ( ) ; if ( ! check Congruence ( first , v ) ) { int index = find Congruence Match ( new Classes , v ) ; if ( index > - _ NUM ) {  GVCongruence Class match =  B . get ( index ) ; match . add Vertex ( v ) ; v . set Value Number ( match . get Value Number ( ) ) ; } else {  GVCongruence Class c = create Congruence Class ( v ) ; new Classes . add ( c ) ; c . add Vertex ( v ) ; v . set Value Number ( c . get Value Number ( ) ) ; } to Remove . add ( v ) ; } } for (  Value Graph Vertex v : to Remove ) { partition . remove Vertex ( v ) ; } if ( ( ! new Classes . is Empty ( ) ) && ( partition . size ( ) > _ NUM ) ) { work List . push ( partition ) ; } for (  GVCongruence Class c : new Classes ) { if ( c . size ( ) > _ NUM ) { work List . push ( c ) ; } add Dependent Classes To Worklist ( c ) ; } }
public void add Adapter (  Recycler View .  Adapter adapter ) { add Adapter ( adapters . size ( ) , adapter ) ; }
public  Virtual File resolve (  String relative Str ) {  File relative File = null ; if (  File Utils . is Directory ( f ) ) { relative File =  File Util . open File ( f , relative Str ) ; } else if (  File Utils . is File ( f ) ) { relative File =  File Util . open File ( f . get Parent File ( ) , relative Str ) ; }  Virtual File result = null ; if ( relative File != null &&  File Utils . exists ( relative File ) ) { result = new  Local File ( relative File ) ; } if ( ( result != null ) &&  Trace . path Resolver ) {  Trace . trace ( _ STR + relative Str + _ STR + result . get Name ( ) ) ; } return result ; }
public static boolean is Expression Tree (  Tree tree ) { return tree instanceof  Expression Tree ; }
private  Query Exp build Optional Query Exp ( final  String [ ] attributes , final  Object [ ] values ) {  Query Exp query Exp = null ; for ( int i = _ NUM ; i < attributes . length ; i ++ ) { if ( values [ i ] instanceof  Boolean ) { if ( query Exp == null ) { query Exp =  Query . eq (  Query . attr ( attributes [ i ] ) ,  Query . value ( ( (  Boolean ) values [ i ] ) ) ) ; } else { query Exp =  Query . and ( query Exp ,  Query . eq (  Query . attr ( attributes [ i ] ) ,  Query . value ( ( (  Boolean ) values [ i ] ) ) ) ) ; } } else if ( values [ i ] instanceof  Number ) { if ( query Exp == null ) { query Exp =  Query . eq (  Query . attr ( attributes [ i ] ) ,  Query . value ( (  Number ) values [ i ] ) ) ; } else { query Exp =  Query . and ( query Exp ,  Query . eq (  Query . attr ( attributes [ i ] ) ,  Query . value ( (  Number ) values [ i ] ) ) ) ; } } else if ( values [ i ] instanceof  String ) { if ( query Exp == null ) { query Exp =  Query . eq (  Query . attr ( attributes [ i ] ) ,  Query . value ( (  String ) values [ i ] ) ) ; } else { query Exp =  Query . and ( query Exp ,  Query . eq (  Query . attr ( attributes [ i ] ) ,  Query . value ( (  String ) values [ i ] ) ) ) ; } } } return query Exp ; }
public void remove ( final  T object ) { synchronized ( m Lock ) { m List . remove ( object ) ; } notify Data Set Changed ( ) ; }
static public float angle Between (  PVector v1 ,  PVector v2 ) { if ( v1 . x == _ NUM && v1 . y == _ NUM ) return _ NUM ; if ( v2 . x == _ NUM && v2 . y == _ NUM ) return _ NUM ; double dot = v1 . x * v2 . x + v1 . y * v2 . y + v1 . z * v2 . z ; double v1mag =  Math . sqrt ( v1 . x * v1 . x + v1 . y * v1 . y + v1 . z * v1 . z ) ; double v2mag =  Math . sqrt ( v2 . x * v2 . x + v2 . y * v2 . y + v2 . z * v2 . z ) ; double amt = dot / ( v1mag * v2mag ) ; if ( amt <= - _ NUM ) { return  PConstants .  PI ; } else if ( amt >= _ NUM ) { return _ NUM ; } return ( float )  Math . acos ( amt ) ; }
public boolean exists ( @  Not Null final  URL url ) { require Non Null ( url , _ STR ) ; try { final  URLConnection url Connection = url . open Connection ( ) ; url Connection . set Connect Timeout (  CONNECTION_ TIMEOUT ) ; if ( url Connection instanceof  Http URLConnection ) { return exists ( (  Http URLConnection ) url Connection ) ; } else { url Connection . connect ( ) ; return _ BOOL ; } } catch (  IOException ioe ) {  LOG . debug (  UNABLE_ TO_ CHECK_ MESSAGE , url , ioe ) ; return _ BOOL ; } }
private void on Datatype Element (  Element xsd Element ,  Document Factory parent Factory ) {  String name = xsd Element . attribute Value ( _ STR ) ;  String type = xsd Element . attribute Value ( _ STR ) ;  QName qname = get QName ( name ) ;  Datatype Element Factory factory = get Datatype Element Factory ( qname ) ; if ( type != null ) {  XSDatatype data Type = get Type By Name ( type ) ; if ( data Type != null ) { factory . set Child Element XSDatatype ( qname , data Type ) ; } else {  QName type QName = get QName ( type ) ; named Type Resolver . register Typed Element ( xsd Element , type QName , parent Factory ) ; } return ; }  Element xsd Simple Type = xsd Element . element (  XSD_ SIMPLETYPE ) ; if ( xsd Simple Type != null ) {  XSDatatype data Type = load XSDatatype From Simple Type ( xsd Simple Type ) ; if ( data Type != null ) { factory . set Child Element XSDatatype ( qname , data Type ) ; } }  Element schema Complex Type = xsd Element . element (  XSD_ COMPLEXTYPE ) ; if ( schema Complex Type != null ) { on Schema Complex Type ( schema Complex Type , factory ) ; }  Iterator <  Element > iter = xsd Element . element Iterator (  XSD_ ATTRIBUTE ) ; if ( iter . has Next ( ) ) { do { on Datatype Attribute ( xsd Element , factory , iter . next ( ) ) ; } while ( iter . has Next ( ) ) ; } }
public boolean replace Ref (  Object old Ref ,  Object new Ref ) throws  IOException {  Integer value = (  Integer ) _refs . remove ( old Ref ) ; if ( value != null ) { _refs . put ( new Ref , value ) ; return _ BOOL ; } else return _ BOOL ; }
public  String version Qualifier ( ) { return properties . get Property ( _ STR ) ; }
private void sequence Bounded Linearizable Query (  Query Entry entry ,  Server Session Context session ,  Completable Future <  Query Response > future ) { if ( entry . get Sequence ( ) > session . get Command Sequence ( ) ) { session . register Sequence Query ( entry . get Sequence ( ) , null ) ; } else { apply Query ( entry , future ) ; } }
public static <  T >  T first (  List <  T > l ) { return l . get ( _ NUM ) ; }
public void find And Init (  Object some Obj ) { if ( some Obj instanceof  Map Bean ) { set Map ( (  Map Bean ) some Obj ) ; } }
public  Timestamp recalculate Estimated Completion Date ( ) { this . update Completion Date = _ BOOL ; return recalculate Estimated Completion Date (  Long . value Of ( _ NUM ) , estimated Start Date ) ; }
public static  Document new Document ( ) { return document Builder . new Document ( ) ; }
public static  String after (  String line ,  String char Sequence ) { int pos = line . index Of ( char Sequence ) ; if ( pos != - _ NUM ) { line = line . substring ( pos + char Sequence . length ( ) ) ; } return line . trim ( ) ; }
private void perform Frame Tasks ( ) { synchronized ( m Frame Task Queue ) {  AFrame Task task = m Frame Task Queue . poll ( ) ; while ( task != null ) { task . run ( ) ; task = m Frame Task Queue . poll ( ) ; } } }
public static void to Polar Coordinates ( double [ ] x , double [ ] y ) { if ( x . length != y . length ) { throw new  Illegal Argument Exception ( _ STR ) ; } for ( int i = _ NUM ; i < x . length ; i ++ ) { double r =  Math . sqrt ( x [ i ] * x [ i ] + y [ i ] * y [ i ] ) ; double phi =  Math . atan2 ( y [ i ] , x [ i ] ) ; x [ i ] = r ; y [ i ] = phi ; } }
public static boolean does File Exist (  File file ) { if ( file == null ) { return _ BOOL ; } boolean does File Exist ; try { does File Exist = file . exists ( ) ; } catch (  Exception e ) { logger . debug ( e . to String ( ) +  System . line Separator ( ) +  Stack Trace . get String From Stack Trace ( e ) ) ; does File Exist = _ BOOL ; } return does File Exist ; }
public void notify Destroy Viewer ( ) throws  Canceled Exception { synchronized ( director Listeners ) { while ( director Listeners . size ( ) > _ NUM ) {  IDirector Listener director Listener = director Listeners . get ( _ NUM ) ; if ( director Listener != this ) director Listener . destroy View ( ) ; if ( director Listeners . size ( ) > _ NUM && director Listeners . get ( _ NUM ) == director Listener ) director Listeners . remove ( _ NUM ) ; } } while ( viewers . size ( ) > _ NUM ) { remove Viewer ( viewers . get ( _ NUM ) ) ; } if ( projects Changed Listener != null )  Project Manager . remove Projects Changed Listener ( projects Changed Listener ) ; if ( future != null && ! future . is Done ( ) ) { try { future . cancel ( _ BOOL ) ; } catch (  Exception ex ) { } future = null ; } }
protected void write Iterator (  Output out ,  Iterator <  Object > it ) {  Linked List <  Object > list = new  Linked List <  Object > ( ) ; while ( it . has Next ( ) ) { list . add Last ( it . next ( ) ) ; } out . write Array ( list , this ) ; }
public boolean contains Attr Value (  String attr Name ,  String attr Value ) { if ( attr Set != null ) {  Set attr = (  Set ) attr Set . get ( attr Name ) ; if ( attr != null ) { return ( attr . contains ( attr Value ) ) ; } } return ( _ BOOL ) ; }
public void show Preferences ( ) { if ( preferences Stage == null ) { preferences Stage = init Stage (  PREFERENCES_ LAYOUT , _ STR ) ;  Preferences Controller preferences Controller = (  Preferences Controller ) controllers . get (  PREFERENCES_ LAYOUT ) ; preferences Stage . set On Showing ( null ) ; } show Stage ( preferences Stage ) ; }
public void test_copy Stream_full Block Plus One ( ) throws  IOException { final  String id = _ STR ; final int version = _ NUM ;  Random r = new  Random ( ) ; final byte [ ] expected = new byte [  BLOCK_ SIZE + _ NUM ] ; r . next Bytes ( expected ) ; assert Equals ( _ STR , expected . length , repo . copy Stream ( id , version , new  Byte Array Input Stream ( expected ) ) ) ; assert Equals ( _ STR , _ NUM , repo . get Block Count ( id , version ) ) ; assert Same Iterator ( _ STR , new  Long [ ] { _ NUM , _ NUM } , repo . blocks ( id , version ) ) ; assert Equals ( _ STR , expected , read ( repo . input Stream ( id , version ) ) ) ; }
public static  Collection Id parse (  String str ) {  String [ ] parts = str . split ( _ STR + _ STR + _ STR ) ; if ( parts . length < _ NUM ) return null ; return new  Collection Id ( parts [ _ NUM ] , parts [ _ NUM ] , parts [ _ NUM ] ) ; }
protected void request (  Request Context context ,  String key ,  String message ) { try {  Http Servlet Request request = context . get Request ( ) ;  String filename = request . get Remote Addr ( ) ; start ( filename , key , _ STR + request . get Method ( ) + _ STR + request . get Request URI ( ) + _ STR + message ) ; } catch (  Exception e ) { } }
private boolean add Group To Group (  String tenant Name ,  Principal Id group Id ,  String group Name ) throws  Exception { try {  Validate Util . validate Not Empty ( tenant Name , _ STR ) ;  Validate Util . validate Not Null ( group Id , _ STR ) ;  Validate Util . validate Not Empty ( group Name , _ STR ) ;  Tenant Information tenant Info = find Tenant ( tenant Name ) ;  Server Utils . validate Not Null Tenant ( tenant Info , tenant Name ) ;  ISystem Domain Identity Provider provider = tenant Info . find System Provider ( ) ;  Server Utils . validate Not Null System Idp ( provider , tenant Name ) ; if ( provider . find Group ( group Id ) == null ) {  Group group = find Group ( tenant Name , group Id ) ; if ( group != null ) { validate Object Id Not Null ( group ) ;  Principal Id new Group Id = get Fsp Id For System Domain ( provider , group ) ; return provider . add Group To Group ( new Group Id , group Name ) ; } } return provider . add Group To Group ( group Id , group Name ) ; } catch (  Exception ex ) { logger . error (  String . format ( _ STR , group Id != null ? group Id . get Name ( ) : _ STR , group Id != null ? group Id . get Domain ( ) : _ STR , group Name , tenant Name ) ) ; throw ex ; } }
public void add Listener (  Listener a Listener ) { if ( a Listener == null ) return ; if ( hex Edit Control == null ) { if ( list Of Status Changed Listeners == null ) list Of Status Changed Listeners = new  Array List < > ( ) ; list Of Status Changed Listeners . add ( a Listener ) ; } else { hex Edit Control . add Listener (  SWT .  Modify , a Listener ) ; } }
public  String to String For Quest State ( ) { final  String Builder sb = new  String Builder ( ) ; boolean first = _ BOOL ; for ( final  Map .  Entry <  String ,  Integer > e : entry Set ( ) ) { if ( first ) { first = _ BOOL ; } else { sb . append ( _ STR ) ; } sb . append ( e . get Key ( ) ) ; sb . append ( _ STR ) ; sb . append ( e . get Value ( ) ) ; } return sb . to String ( ) ; }
private  Client create Server Client ( ) {  Client client = new  Client ( ) ; client . name = _ STR ; client . registration Token =  SENDER_ ID + _ STR ; client . profile Picture Url = _ STR ; return client ; }
private static char to Lower Case ( char value ) { return  Character . to Lower Case ( value ) ; }
public boolean is Update Required ( ) { return this . update Required ; }
private  Number parse Int (  String value ) {  Long l =  Long . value Of ( value ) ; if ( l . int Value ( ) == l ) { return l . int Value ( ) ; } return l ; }
private void draw Zoom Rectangle (  Graphics2 D g2 , boolean xor ) { if ( this . zoom Rectangle != null ) { if ( xor ) { g2 . set XORMode (  Color . gray ) ; } if ( this . fill Zoom Rectangle ) { g2 . set Paint ( this . zoom Fill Paint ) ; g2 . fill ( this . zoom Rectangle ) ; } else { g2 . set Paint ( this . zoom Outline Paint ) ; g2 . draw ( this . zoom Rectangle ) ; } if ( xor ) { g2 . set Paint Mode ( ) ; } } }
public  Conversion Exception (  Throwable cause ) { super ( cause . get Message ( ) ) ; this . cause = cause ; }
private void validate Initiator Data (  Initiator initiator ,  Export Group export Group ) { validate Port Connectivity ( export Group ,  Collections . singleton List ( initiator ) ) ; }
private  List <  Rich Translation <  TK ,  FV > > standard Nbest (  Beam <  Derivation <  TK ,  FV > > beam ,  Recombination History <  Derivation <  TK ,  FV > > recombination History ,  Input Properties source Input Properties , int source Input Id ,  List <  Sequence <  TK > > targets ,  Output Space <  TK ,  FV > output Space , int size , boolean distinct ) {  List <  Derivation <  TK ,  FV > > goal States = new  Array List < > ( beam . size ( ) ) ; for (  Derivation <  TK ,  FV > derivation : beam ) goal States . add ( derivation ) ; final  State Lattice Decoder <  Derivation <  TK ,  FV > > lattice Decoder = new  State Lattice Decoder < > ( goal States , recombination History ) ; final boolean prefix Decoding = source Input Properties . contains Key (  Input Property .  Target Prefix ) ; final boolean prefix Diversity = distinct && prefix Decoding ; final  Sequence <  TK > prefix = prefix Decoding ? targets . get ( _ NUM ) : null ; final  Set <  Sequence <  TK > > distinct Surface Translations = distinct ? new  Hash Set < > ( size ) : null ; final  List <  Rich Translation <  TK ,  FV > > translations = new  Array List < > ( size ) ; int num Extracted = _ NUM ; long nbest Id = _ NUM ; for (  List <  Derivation <  TK ,  FV > > lattice Path : lattice Decoder ) { ++ num Extracted ; if ( num Extracted >  MAX_ POPPED_ ITEMS ) break ; if ( distinct ) {  Sequence <  TK > path Target = extract Target ( lattice Path ) ; if ( prefix Diversity ) { int start = prefix . size ( ) ; int end =  Math . min ( path Target . size ( ) , prefix . size ( ) +  PREFIX_ DIVERSITY_ SIZE ) ; if ( start < end ) path Target = path Target . subsequence ( start , end ) ; } if ( distinct Surface Translations . contains ( path Target ) ) continue ; distinct Surface Translations . add ( path Target ) ; } boolean with DTUs = _ BOOL ; final  Set <  Rule <  TK > > seen Options = new  Hash Set < > ( ) ;  Derivation <  TK ,  FV > goal Hyp = null ; for (  Derivation <  TK ,  FV > node : lattice Path ) { if ( goal Hyp == null ) { goal Hyp = node ; continue ; } with DTUs = with DTUs || node . rule . abstract Rule instanceof  DTURule ; goal Hyp = with DTUs ? new  DTUHypothesis < > ( source Input Id , node . rule , goal Hyp . length , goal Hyp , node , featurizer , scorer , heuristic , seen Options , output Space ) : new  Derivation < > ( source Input Id , node . rule , goal Hyp . length , goal Hyp , featurizer , scorer , heuristic , output Space ) ; } if ( goal Hyp == null || goal Hyp . featurizable == null ) { logger . warn ( _ STR , source Input Id ) ; return null ; } if ( with DTUs ) {  DTUHypothesis <  TK ,  FV > dtu Hyp = (  DTUHypothesis <  TK ,  FV > ) goal Hyp ; if ( ! dtu Hyp . is Done ( ) || dtu Hyp . has Expired ( ) ) logger . warn ( _ STR , translations . size ( ) , dtu Hyp . has Expired ( ) , goal Hyp ) ; }  Rich Translation <  TK ,  FV > t = new  Rich Translation < > ( goal Hyp . featurizable , goal Hyp . score ,  Feature Values . combine ( goal Hyp ) , nbest Id ++ ) ; translations . add ( t ) ; if ( translations . size ( ) >= size ) break ; }  Collections . sort ( translations , translation Comparator ) ; logger . info ( _ STR , source Input Id , num Extracted , lattice Decoder . max Agenda Size ) ; return translations ; }
public void test Plus Math Context Negative ( ) {  String a = _ STR ; int a Scale = _ NUM ; int precision = _ NUM ;  Rounding Mode rm =  Rounding Mode .  CEILING ;  Math Context mc = new  Math Context ( precision , rm ) ;  String c = _ STR ; int c Scale = _ NUM ;  Big Decimal a Number = new  Big Decimal ( new  Big Integer ( a ) , a Scale ) ;  Big Decimal res = a Number . plus ( mc ) ; assert Equals ( _ STR , c , res . to String ( ) ) ; assert Equals ( _ STR , c Scale , res . scale ( ) ) ; }
private static  IAbstract Node convert And ( final  Common Tree ast ) throws  Recognition Exception { final  List <  IAbstract Node > children = new  Array List <  IAbstract Node > ( ) ; for ( final  Object child Object : ast . get Children ( ) ) { children . add ( convert ( (  Common Tree ) child Object ) ) ; } return new  CAbstract And Expression ( children ) ; }
public static void show Maximized (  Frame frame ) { frame . pack ( ) ; frame . set Extended State (  Frame .  MAXIMIZED_ BOTH ) ; frame . set Visible ( _ BOOL ) ; frame . to Front ( ) ; }
public  Builder add Char Filter (  Class < ? extends  Char Filter Factory > factory ,  Map <  String ,  String > params ) throws  IOException {  Objects . require Non Null ( factory , _ STR ) ; char Filters . add ( apply Resource Loader ( new Factory Class Instance ( factory , apply Default Params ( params ) ) ) ) ; components Added = _ BOOL ; return this ; }
public void update ( int fps , float angle ) { double speed = (  SPEED /  FPS ) *  Math . log ( radius ) ; y -= speed ; x += amp *  Math . sin ( freq * ( step ++ * speed ) ) + skew ; if ( radius < max Radius ) { radius += max Radius / ( ( ( float ) fps /  SPEED ) * radius ) ; if ( radius > max Radius ) radius = max Radius ; } }
public void add Display Changed Listener (  Display Changed Listener client ) { display Changer . add ( client ) ; }
public  String to Ui String ( ) {  String Builder sb = new  String Builder ( ) ;  Calendar date Time = new  Gregorian Calendar (  GMT ) ; long local Time = value ; if ( tz Shift != null ) { local Time += tz Shift . long Value ( ) * _ NUM ; } date Time . set Time In Millis ( local Time ) ; try { append Int ( sb , date Time . get (  Calendar .  YEAR ) , _ NUM ) ; sb . append ( _ STR ) ; append Int ( sb , date Time . get (  Calendar .  MONTH ) + _ NUM , _ NUM ) ; sb . append ( _ STR ) ; append Int ( sb , date Time . get (  Calendar .  DAY_ OF_ MONTH ) , _ NUM ) ; if ( ! date Only ) { sb . append ( _ STR ) ; append Int ( sb , date Time . get (  Calendar .  HOUR_ OF_ DAY ) , _ NUM ) ; sb . append ( _ STR ) ; append Int ( sb , date Time . get (  Calendar .  MINUTE ) , _ NUM ) ; } } catch (  Array Index Out Of Bounds Exception e ) { throw new  Runtime Exception ( e ) ; } return sb . to String ( ) ; }
public  Cors Service Builder allow Request Methods ( final  Http Method ... methods ) { require Non Null ( methods , _ STR ) ; for ( int i = _ NUM ; i < methods . length ; i ++ ) { if ( methods [ i ] == null ) { throw new  Null Pointer Exception ( _ STR + i + _ STR ) ; } }  Collections . add All ( allowed Request Methods , methods ) ; return this ; }
@  Override public void create Redis App Key (  Application application ,  String docker Manager IP ,  String server Port ,  String server Manager Port ) {  String suffix Cloud Unit = application . get Suffix Cloud Unit IO ( ) ;  Jedis Pool pool = null ;  Jedis jedis = null ; try { pool = new  Jedis Pool ( new  Jedis Pool Config ( ) , redis Ip ,  Integer . parse Int ( redis Port ) , _ NUM ) ; jedis = pool . get Resource ( ) ;  String sub Name Space = concat Sub Name Space ( application ) ;  String key = sub Name Space + suffix Cloud Unit ;  String frontend = _ STR + key . to Lower Case ( ) ; jedis . rpush ( frontend , key . to Lower Case ( ) ) ; jedis . rpush ( frontend , _ STR + docker Manager IP + _ STR + server Port ) ;  String frontend Server Manager = _ STR + key . to Lower Case ( ) ; jedis . rpush ( frontend Server Manager , key . to Lower Case ( ) ) ; jedis . rpush ( frontend Server Manager , _ STR + docker Manager IP + _ STR + server Manager Port ) ; } catch (  Jedis Connection Exception |  Unsupported Encoding Exception e ) { logger . error ( _ STR , e ) ; } finally { if ( jedis != null ) { pool . destroy ( ) ; } } }
public  Kml Feature remove Item ( int item Position ) { return m Items . remove ( item Position ) ; }
public static boolean is FFA ( final  Game Data data , final  Player ID player ) { final  Relationship Tracker relationship Tracker = data . get Relationship Tracker ( ) ; final  Set <  Player ID > enemies = relationship Tracker . get Enemies ( player ) ; for ( final  Player ID enemy : enemies ) { if ( relationship Tracker . is At War With Any Of These Players ( enemy , enemies ) ) { return _ BOOL ; } } return _ BOOL ; }
public void destination (  Object destination ) { this . destination =  Objects . require Non Null ( destination ) ; }
public void remove Assigned Storage Pools ( final  Set <  String > storage Pool URIs ) { if ( storage Pool URIs != null && ! storage Pool URIs . is Empty ( ) && _assigned Storage Pools != null ) {  Hash Set <  String > remove Storage Pools = new  Hash Set <  String > ( ) ; remove Storage Pools . add All ( storage Pool URIs ) ; _assigned Storage Pools . remove All ( remove Storage Pools ) ; } }
public void select Next Overlay ( ) { if ( m Current Overlay Index ==  NO_ OVERLAY ) { if ( m Overlays . is Empty ( ) ) { return ; } m Current Overlay Index = _ NUM ; } else { m Current Overlay Index = ++ m Current Overlay Index % m Overlays . size ( ) ; if ( m Current Overlay Index == _ NUM ) { m Current Overlay Index =  NO_ OVERLAY ; } } do Set Overlay ( get Current Overlay ( ) ) ; }
public  Claim Builder put Resource (  Resource resource ) { return put Resource ( resource . path ( ) ) ; }
private void process Version (  String version String ) { try {  String Tokenizer tokens = new  String Tokenizer ( version String , _ STR ) ; major Version =  Integer . parse Int ( tokens . next Token ( ) ) ; minor Version =  Integer . parse Int ( tokens . next Token ( ) ) ; this . version String = version String ; } catch (  Exception e ) { } }
@  Override public  Enumeration <  Option > list Options ( ) {  Vector <  Option > new Vector = new  Vector <  Option > ( _ NUM ) ; new Vector . add Element ( new  Option ( _ STR , _ STR , _ NUM , _ STR ) ) ; new Vector . add Element ( new  Option ( _ STR + _ STR , _ STR , _ NUM , _ STR ) ) ; new Vector . add Element ( new  Option ( _ STR , _ STR , _ NUM , _ STR ) ) ; new Vector . add Element ( new  Option ( _ STR , _ STR , _ NUM , _ STR ) ) ; return new Vector . elements ( ) ; }
public static  String java Escape (  String s ) {  String Builder sb = new  String Builder ( ) ; for ( int i = _ NUM ; i < s . length ( ) ; i ++ ) { char c = s . char At ( i ) ; switch ( c ) { case _ STR : sb . append ( _ STR ) ; break ; case _ STR : sb . append ( _ STR ) ; break ; case _ STR : sb . append ( _ STR ) ; break ; case _ STR : sb . append ( _ STR ) ; break ; case _ STR : sb . append ( _ STR ) ; break ; case _ STR : sb . append ( _ STR ) ; break ; case _ STR : sb . append ( _ STR ) ; break ; case _ STR : sb . append ( _ STR ) ; break ; case _ STR : sb . append ( _ STR ) ; break ; default : sb . append ( c ) ; } } return sb . to String ( ) ; }
private void convergence Step ( final  Vec [ ] xit , int i , final boolean [ ] converged , final int [ ] designations , final  Vec scratch , final  Kernel Function k ) { double denom = _ NUM ;  Vec x Cur = xit [ i ] ;  List < ? extends  Vec Paired <  Vec Paired <  Vec ,  Integer > ,  Double > > contrib = mkde . get Nearby Raw ( x Cur ) ; if ( contrib . size ( ) == _ NUM ) { converged [ i ] = _ BOOL ; designations [ i ] = - _ NUM ; } else { scratch . zero Out ( ) ; for (  Vec Paired <  Vec Paired <  Vec ,  Integer > ,  Double > v : contrib ) { double g = - k . k Prime ( v . get Pair ( ) ) ; denom += g ; scratch . mutable Add ( g , v ) ; } scratch . mutable Divide ( denom ) ; if (  Math . abs ( scratch . p Norm Dist ( _ NUM , x Cur ) ) < _ NUM ) converged [ i ] = _ BOOL ; scratch . copy To ( x Cur ) ; } }
public  Pid File ( final  File directory , final  String filename ) throws  File Not Found Exception { if ( ! directory . is Directory ( ) && directory . exists ( ) ) { throw new  Illegal Argument Exception ( _ STR + directory + _ STR ) ; } final  File file = new  File ( directory , filename ) ; if ( ! file . exists ( ) || file . is Directory ( ) ) { throw new  File Not Found Exception ( _ STR + filename + _ STR + directory ) ; } this . pid File = file ; }
public static boolean compare Results (  Solr Server control Server ,  Solr Server cloud Server ) throws  Solr Server Exception { return compare Results ( control Server , cloud Server , null , null ) ; }
public  String  Get Element Attr (  String x Path Expression ) { try { org . jdom .  Attribute node = (  Attribute )  XPath . select Single Node ( this . xml Document , x Path Expression ) ; return node . get Value ( ) ; } catch (  Exception ex ) {  LOG . error ( _ STR + ex . get Message ( ) , ex ) ; return _ STR ; } }
public static void clear Context (  Properties ctx ) { if ( ctx == null ) throw new  Illegal Argument Exception ( _ STR ) ; ctx . clear ( ) ; }
private void expand Tree ( ) { if ( tree Expand . is Selected ( ) ) { for ( int row = _ NUM ; row < tree . get Row Count ( ) ; row ++ ) tree . expand Row ( row ) ; } else { for ( int row = tree . get Row Count ( ) ; row > _ NUM ; row -- ) tree . collapse Row ( row ) ; } }
@  Suppress Warnings ( _ STR ) private static void replace Player Cape (  Abstract Client Player player ) { final  String display Name = player . get Display Name String ( ) ; final  Network Player Info player Info ; try { player Info = (  Network Player Info )  GET_ PLAYER_ INFO . invoke Exact ( player ) ; } catch (  Throwable throwable ) {  Logger . fatal ( throwable , _ STR , display Name ) ; return ; } if ( player Info == null ) {  Logger . fatal ( _ STR , display Name ) ; return ; } final  Map <  Minecraft Profile Texture .  Type ,  Resource Location > player Textures ; try { player Textures = (  Map <  Minecraft Profile Texture .  Type ,  Resource Location > )  GET_ PLAYER_ TEXTURES . invoke Exact ( player Info ) ; } catch (  Throwable throwable ) {  Logger . fatal ( throwable , _ STR , display Name ) ; return ; } player Textures . put (  Minecraft Profile Texture .  Type .  CAPE ,  CAPE_ LOCATION ) ;  Logger . info ( _ STR , display Name ) ; }
public void remove Vetoable Change Listener (  String property Name ,  Vetoable Change Listener listener ) { if ( listener != null ) { synchronized ( this ) { if ( vetoable Support != null ) { vetoable Support . remove Vetoable Change Listener ( property Name , listener ) ; } } } }
public  String finished (  Logger log ) { if ( m_av Insts Per Sec == _ NUM ) { compute Update (  System . current Time Millis ( ) ) ; } int n S = m_num Samples > _ NUM ? m_num Samples : _ NUM ;  String msg = _ STR + m_instance Count + _ STR + m_av Insts Per Sec / n S + _ STR ; if ( log != null ) { log . status Message ( m_status Message Prefix + msg ) ; } return msg ; }
protected void parse Command ( final  String ... args ) { if ( args != null ) { for (  String arg : args ) {  Command command =  Command . value Of Name ( arg ) ; if ( command != null ) { set Command ( command ) ; break ; } } } }
@  Request Mapping ( method =  Request Method .  POST )  Response Entity <  Bookmark > add Bookmark ( @  Path Variable ( value = _ STR )  String username , @  Request Body  Bookmark bookmark ) throws  User Not Found Exception {  Optional <  User > optional = users Repository . find By Username ( username ) ; if ( optional . is Present ( ) ) {  User user = optional . get ( ) ; user . add Bookmark ( bookmark ) ; bookmark . set User ( user ) ; bookmarks Repository . save ( bookmark ) ; return new  Response Entity < > ( bookmark ,  Http Status .  CREATED ) ; } else { throw new  User Not Found Exception ( username ) ; } }
static int [ ] find Nanp Phone Numbers (  Char Sequence text ) {  Array List <  Integer > list = new  Array List <  Integer > ( ) ; int start Pos = _ NUM ; int end Pos = text . length ( ) -  NANP_ MIN_ DIGITS + _ NUM ; if ( end Pos < _ NUM ) { return new int [ ] { } ; } while ( start Pos < end Pos ) { while (  Character . is Whitespace ( text . char At ( start Pos ) ) && start Pos < end Pos ) { start Pos ++ ; } if ( start Pos == end Pos ) { break ; } int match End = find Nanp Match End ( text , start Pos ) ; if ( match End > start Pos ) { list . add ( start Pos ) ; list . add ( match End ) ; start Pos = match End ; } else { while ( !  Character . is Whitespace ( text . char At ( start Pos ) ) && start Pos < end Pos ) { start Pos ++ ; } } } int [ ] result = new int [ list . size ( ) ] ; for ( int i = list . size ( ) - _ NUM ; i >= _ NUM ; i -- ) { result [ i ] = list . get ( i ) ; } return result ; }
public synchronized void remove (  Class t ,  Event Listener l ) { if ( ! t . is Instance ( l ) ) { throw new  Illegal Argument Exception ( _ STR + l + _ STR + t ) ; } if ( l == null ) { throw new  Illegal Argument Exception ( _ STR + l + _ STR ) ; } int index = - _ NUM ; for ( int i = listener List . length - _ NUM ; i >= _ NUM ; i -= _ NUM ) { if ( ( listener List [ i ] == t ) && ( listener List [ i + _ NUM ] == l ) ) { index = i ; break ; } } if ( index != - _ NUM ) {  Object [ ] tmp = new  Object [ listener List . length - _ NUM ] ;  System . arraycopy ( listener List , _ NUM , tmp , _ NUM , index ) ; if ( index < tmp . length )  System . arraycopy ( listener List , index + _ NUM , tmp , index , tmp . length - index ) ; listener List = ( tmp . length == _ NUM ) ?  NULL_ ARRAY : tmp ; } }
public static  Object [ ] pad Arguments (  Object [ ] args , int count ) { if ( count < args . length ) return args ; int i ;  Object [ ] result = new  Object [ count ] ; for ( i = _ NUM ; i < args . length ; i ++ ) { result [ i ] = args [ i ] ; } for ( ; i < count ; i ++ ) { result [ i ] =  Undefined . instance ; } return result ; }
int find End Text (  String source , int ofs ) { for ( int i = ofs ; i < source . length ( ) ; i ++ ) { if ( is Alpha ( source . char At ( i ) ) == _ BOOL && is Numeric ( source . char At ( i ) ) == _ BOOL ) { return i ; } } return - _ NUM ; }
public  Byte Buffer decode Buffer To Byte Buffer (  String input String ) throws  IOException { return  Byte Buffer . wrap ( decode Buffer ( input String ) ) ; }
public void insert Column ( int at ) { insert Column ( at , get Default Value ( ) ) ; }
public void add Point ( final  T point ) { points . add ( point ) ; }
public boolean has Invoices ( ) { boolean ret Value = _ BOOL ;  String sql = _ STR ;  Prepared Statement pstmt = null ; try { pstmt =  DB . prepare Statement ( sql , get_ Trx Name ( ) ) ; pstmt . set Int ( _ NUM , get_ ID ( ) ) ;  Result Set rs = pstmt . execute Query ( ) ; if ( rs . next ( ) ) { if ( rs . get Int ( _ NUM ) > _ NUM ) ret Value = _ BOOL ; } rs . close ( ) ; pstmt . close ( ) ; pstmt = null ; } catch (  Exception e ) { s_log . log (  Level .  SEVERE , sql , e ) ; } try { if ( pstmt != null ) pstmt . close ( ) ; pstmt = null ; } catch (  Exception e ) { pstmt = null ; } return ret Value ; }
void copy Value (  Mutable Big Integer src ) { int len = src . int Len ; if ( value . length < len ) value = new int [ len ] ;  System . arraycopy ( src . value , src . offset , value , _ NUM , len ) ; int Len = len ; offset = _ NUM ; }
public static  String to String (  Object value ) { if ( value == null ) { return null ; } return value . to String ( ) ; }
@  Override public  List <  Period > generate Rolling Periods (  Date Time Unit date Time Unit ) {  Calendar cal = get Calendar ( ) ; date Time Unit . set Day ( _ NUM ) ; date Time Unit = cal . minus Months ( date Time Unit , ( date Time Unit . get Month ( ) % _ NUM ) + _ NUM ) ;  List <  Period > periods =  Lists . new Array List ( ) ; for ( int i = _ NUM ; i < _ NUM ; i ++ ) { periods . add ( create Period ( date Time Unit , cal ) ) ; date Time Unit = cal . plus Months ( date Time Unit , _ NUM ) ; } return periods ; }
protected int wait For ( int counter ) { if ( counter > _ NUM ) -- counter ; else if ( counter > _ NUM ) { -- counter ;  Thread . yield ( ) ; } else {  Lock Support . park Nanos ( _ NUM ) ; } return counter ; }
public static  Uri add Message To Uri (  Content Resolver resolver ,  Uri uri ,  String address ,  String body ,  String subject ,  Long date , boolean read , boolean delivery Report ) { return add Message To Uri ( resolver , uri , address , body , subject , date , read , delivery Report , - _ NUM ) ; }
protected void compute Doubles For All Zoom Levels ( ) { int num Frames = m Sound File . get Num Frames ( ) ; float max Gain = _ NUM ; for ( int i = _ NUM ; i < num Frames ; i ++ ) { float gain = get Gain ( i , num Frames , m Sound File . get Frame Gains ( ) ) ; if ( gain > max Gain ) { max Gain = gain ; } } scale Factor = _ NUM ; if ( max Gain > _ NUM ) { scale Factor = _ NUM / max Gain ; } max Gain = _ NUM ; int gain Hist [ ] = new int [ _ NUM ] ; for ( int i = _ NUM ; i < num Frames ; i ++ ) { int smoothed Gain = ( int ) ( get Gain ( i , num Frames , m Sound File . get Frame Gains ( ) ) * scale Factor ) ; if ( smoothed Gain < _ NUM ) smoothed Gain = _ NUM ; if ( smoothed Gain > _ NUM ) smoothed Gain = _ NUM ; if ( smoothed Gain > max Gain ) max Gain = smoothed Gain ; gain Hist [ smoothed Gain ] ++ ; } min Gain = _ NUM ; int sum = _ NUM ; while ( min Gain < _ NUM && sum < num Frames / _ NUM ) { sum += gain Hist [ ( int ) min Gain ] ; min Gain ++ ; } sum = _ NUM ; while ( max Gain > _ NUM && sum < num Frames / _ NUM ) { sum += gain Hist [ ( int ) max Gain ] ; max Gain -- ; } range = max Gain - min Gain ; m Num Zoom Levels = _ NUM ; m Len By Zoom Level = new int [ _ NUM ] ; m Zoom Factor By Zoom Level = new float [ _ NUM ] ; float ratio = get Measured Width ( ) / ( float ) num Frames ; if ( ratio < _ NUM ) { m Len By Zoom Level [ _ NUM ] =  Math . round ( num Frames * ratio ) ; m Zoom Factor By Zoom Level [ _ NUM ] = ratio ; m Len By Zoom Level [ _ NUM ] = num Frames ; m Zoom Factor By Zoom Level [ _ NUM ] = _ NUM ; m Len By Zoom Level [ _ NUM ] = num Frames * _ NUM ; m Zoom Factor By Zoom Level [ _ NUM ] = _ NUM ; m Len By Zoom Level [ _ NUM ] = num Frames * _ NUM ; m Zoom Factor By Zoom Level [ _ NUM ] = _ NUM ; m Zoom Level = _ NUM ; } else { m Len By Zoom Level [ _ NUM ] = num Frames ; m Zoom Factor By Zoom Level [ _ NUM ] = _ NUM ; m Len By Zoom Level [ _ NUM ] = num Frames * _ NUM ; m Zoom Factor By Zoom Level [ _ NUM ] = _ NUM ; m Len By Zoom Level [ _ NUM ] = num Frames * _ NUM ; m Zoom Factor By Zoom Level [ _ NUM ] = _ NUM ; m Len By Zoom Level [ _ NUM ] = num Frames * _ NUM ; m Zoom Factor By Zoom Level [ _ NUM ] = _ NUM ; m Zoom Level = _ NUM ; for ( int i = _ NUM ; i < _ NUM ; i ++ ) { if ( m Len By Zoom Level [ m Zoom Level ] - get Measured Width ( ) > _ NUM ) { break ; } else { m Zoom Level = i ; } } } m Initialized = _ BOOL ; }
private boolean expunge Stale Entries ( ) { if ( size == _ NUM ) return _ BOOL ;  Object r ; boolean result = _ BOOL ; while ( ( r = queue . poll ( ) ) != null ) { result = _ BOOL ;  Entry e = (  Entry ) r ; int h = e . get Hash ( ) ; int i = index For ( h , table . length ) ;  Entry prev = table [ i ] ;  Entry p = prev ; while ( p != null ) {  Entry next = p . get State ( ) . next ; if ( p == e ) { if ( prev == e ) table [ i ] = next ; else prev . set Next ( next ) ; e . set Next ( null ) ; size -- ; break ; } prev = p ; p = next ; } } return result ; }
public  Job Execution run Flow (  Flow flow , int batch Size , int thread Count ,  Job Status Listener status Listener ) {  Job Execution result = null ; try {  Configurable Application Context ctx = build Application Context ( flow , status Listener ) ;  Job Parameters params = build Job Parameters ( flow , batch Size , thread Count ) ;  Job Launcher launcher = ctx . get Bean (  Job Launcher . class ) ;  Job job = ctx . get Bean (  Job . class ) ; result = launcher . run ( job , params ) ; } catch (  Exception e ) { e . print Stack Trace ( ) ; } return result ; }
private boolean check External Storage And Notify (  String filename ,  String full Dir Path ,  String external Storage Status ) { if ( full Dir Path == null ) {  Log . e (  TAG , _ STR ) ; alert Download Failure ( filename ) ; return _ BOOL ; } if ( ! external Storage Status . equals (  Environment .  MEDIA_ MOUNTED ) ) { if ( external Storage Status . equals (  Environment .  MEDIA_ SHARED ) ) {  Log . e (  TAG , _ STR ) ; } else {  Log . e (  TAG , _ STR ) ; } alert Download Failure ( filename ) ; return _ BOOL ; } return _ BOOL ; }
public static void append Connections (  Vector <  Bean Connection > connections , int tab ) { if ( tab <  TABBED_ CONNECTIONS . size ( ) ) {  Vector <  Bean Connection > cons =  TABBED_ CONNECTIONS . get ( tab ) ; for ( int i = _ NUM ; i < connections . size ( ) ; i ++ ) { cons . add ( connections . get ( i ) ) ; } } }
public static double point Circle Distance (  Geo p1 ,  Geo p2 ,  Geo center ) {  Geo n =  Geo . cross Normalize ( p1 , p2 , new  Geo ( ) ) ;  Geo c = center . normalize ( new  Geo ( ) ) ; double cos Theta =  Geo . dot ( n , c ) ; double theta =  Math . acos ( cos Theta ) ; return  Math . abs (  Math .  PI / _ NUM - theta ) ; }
public void to Char Array ( char [ ] b , int offset , int length ) { if ( buffer . length == _ NUM ) return ; int t =  Math . min ( length , len ) ; int to End =  Math . min ( t , buffer . length - start ) ;  System . arraycopy ( buffer , start , b , offset , to End ) ; if ( to End < t )  System . arraycopy ( buffer , _ NUM , b , offset + to End , t - to End ) ; }
@  Override public  Trie optimize (  Trie orig ) {  List <  Char Sequence > cmds = orig . cmds ;  List <  Row > rows = new  Array List < > ( ) ;  List <  Row > orows = orig . rows ; int remap [ ] = new int [ orows . size ( ) ] ;  Arrays . fill ( remap , _ NUM ) ; for ( int j = orows . size ( ) - _ NUM ; j >= _ NUM ; j -- ) { if ( eat ( orows . get ( j ) , remap ) ) { remap [ j ] = _ NUM ; } }  Arrays . fill ( remap , - _ NUM ) ; rows = remove Gaps ( orig . root , orows , new  Array List <  Row > ( ) , remap ) ; return new  Trie ( orig . forward , remap [ orig . root ] , cmds , rows ) ; }
public  Document Handler State (  Tag Handler tag Handler ) { this . tag Handler = tag Handler ; }
public boolean is Shutdown ( ) { return shutdown . get ( ) ; }
public  List <  Storage File Entity > create Storage File Entities From Storage Files (  Storage Unit Entity storage Unit Entity ,  List <  Storage File > storage Files ) {  List <  Storage File Entity > storage File Entities = new  Array List < > ( ) ; for (  Storage File storage File : storage Files ) {  Storage File Entity storage File Entity = new  Storage File Entity ( ) ; storage File Entities . add ( storage File Entity ) ; storage File Entity . set Storage Unit ( storage Unit Entity ) ; storage File Entity . set Path ( storage File . get File Path ( ) ) ; storage File Entity . set File Size Bytes ( storage File . get File Size Bytes ( ) ) ; storage File Entity . set Row Count ( storage File . get Row Count ( ) ) ; storage File Dao . save And Refresh ( storage File Entity ) ; } return storage File Entities ; }
final boolean is Source Line (  Line .  Info info ) { for ( int i = _ NUM ; i < source Line Info . length ; i ++ ) { if ( info . matches ( source Line Info [ i ] ) ) { return _ BOOL ; } } return _ BOOL ; }
public void test Get Scope ( ) throws  Exception {  Identity i = new  Identity Stub ( _ STR ) ; assert Null ( i . get Scope ( ) ) ;  Identity Scope s =  Identity Scope . get System Scope ( ) ;  Identity i2 = new  Identity Stub ( _ STR , s ) ; assert Same ( s , i2 . get Scope ( ) ) ; }
public  TSink <  String > send String (  TStream <  String > stream ) {  Objects . require Non Null ( stream , _ STR ) ; return send Text ( stream , null ) ; }
protected static  Method resolve Java Method (  Bsh Class Manager bcm ,  Class clas ,  String name ,  Class [ ] types , boolean static Only ) throws  Util Eval Error { if ( clas == null ) throw new  Interpreter Error ( _ STR ) ;  Method method = null ; if ( bcm == null )  Interpreter . debug ( _ STR ) ; else method = bcm . get Resolved Method ( clas , name , types , static Only ) ; if ( method == null ) { boolean public Only = !  Capabilities . have Accessibility ( ) ; try { method = find Overloaded Method ( clas , name , types , public Only ) ; } catch (  Security Exception e ) { throw new  Util Target Error ( _ STR + clas , e ) ; } check Found Static Method ( method , static Only , clas ) ; if ( method != null && ! public Only ) { try {  Reflect Manager .  RMSet Accessible ( method ) ; } catch (  Util Eval Error e ) { } } if ( method != null && bcm != null ) bcm . cache Resolved Method ( clas , types , method ) ; } return method ; }
protected  Abstract Regex Annotator (  String pattern , boolean case Sensitive , double confidence ) { this (  Pattern . compile ( pattern , case Sensitive ? _ NUM :  Pattern .  CASE_ INSENSITIVE ) , _ NUM , confidence ) ; }
private void perform ( ) throws  Optimizing Compiler Exception { if ( loop == null ) { return ; } try { process Header ( ) ;  Enumeration <  Basic Block > loop Blocks = get Basic Blocks ( ) ; while ( loop Blocks . has More Elements ( ) ) {  Basic Block cur Loop BB = loop Blocks . next Element ( ) ; if ( cur Loop BB == header ) { } else { process Loop Block ( cur Loop BB ) ; } } } catch (  Non Regular Loop Exception e ) { if (  DEBUG ) {  VM . sys Write ( e . summary ( ) + _ STR ) ; } initial Iterator Value = null ; } if (  DEBUG && ( ! is Non Regular Loop ( ) ) ) { dump ( ) ; } }
@  Override public void on Bind View Holder (  K holder , int position ) { holder . bind Item ( items . get ( position ) ) ; }
public static  Date days After (  Date date Inst , int num Days ) { if ( ( num Days <= _ NUM ) || ( date Inst == null ) ) { throw new  Illegal Argument Exception ( ) ; } final  Calendar cal = new  Gregorian Calendar ( ) ; cal . set Time ( date Inst ) ; cal . add (  Calendar .  DAY_ OF_ YEAR , num Days ) ; return cal . get Time ( ) ; }
protected  Abstract Buffer reset ( long offset , long capacity , long max Capacity ) { this . offset = offset ; this . capacity = _ NUM ; this . initial Capacity = capacity ; this . max Capacity = max Capacity ; capacity ( initial Capacity ) ; references . set ( _ NUM ) ; rewind ( ) ; return this ; }
@  Override public void write External (  Object Output out ) throws  IOException { super . write External ( out ) ; out . write Object ( conservative Approximation ) ; out . write Object ( progressive Approximation ) ; }
public void put Object (  String key ,  Object value ) throws  IOException ,  Stream Corrupted Exception ,  Optional Data Exception {  Byte Array Output Stream b = new  Byte Array Output Stream ( ) ;  Object Output Stream o = new  Object Output Stream ( b ) ; o . write Object ( value ) ; o . close ( ) ; put ( key , new  String (  Base64 . encode ( b . to Byte Array ( ) ,  Base64 .  DEFAULT ) ) ) ; }
public void remove Notify ( ) { super . remove Notify ( ) ; if ( focused Component == this ) { focused Component = null ; } }
public void destroy ( ) { m Listeners . clear ( ) ; m Spring System . deregister Spring ( this ) ; }
private void on Sensor Data Start (  Attributes attributes ) { sensor Name = attributes . get Value (  ATTRIBUTE_ NAME ) ; }
public void add Chunk ( byte [ ] data ) { cache . write ( data , _ NUM , data . length ) ; current Size += data . length ; }
public void add (  IResource [ ] resources ,  IProgress Monitor monitor ) throws  Team Exception { if ( monitor == null ) { monitor = new  Null Progress Monitor ( ) ; }  Map table = get Provider Mapping ( resources ) ; if ( table . get ( null ) != null ) { throw new  SVNException (  Policy . bind ( _ STR ) ) ; }  Set key Set = table . key Set ( ) ; monitor . begin Task ( _ STR , key Set . size ( ) * _ NUM ) ; monitor . set Task Name (  Policy . bind ( _ STR ) ) ;  Iterator iterator = key Set . iterator ( ) ; while ( iterator . has Next ( ) ) {  IProgress Monitor sub Monitor = new  Sub Progress Monitor ( monitor , _ NUM ) ;  SVNTeam Provider provider = (  SVNTeam Provider ) iterator . next ( ) ;  List list = (  List ) table . get ( provider ) ;  IResource [ ] provider Resources = (  IResource [ ] ) list . to Array ( new  IResource [ list . size ( ) ] ) ; provider . add ( provider Resources ,  IResource .  DEPTH_ ZERO , sub Monitor ) ; } }
@  Override public final boolean is Magic Word (  String in ) { return in . matches ( _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR ) ; }
public boolean equals (  Object object ) { if ( this == object ) { return _ BOOL ; } else if ( object == null || get Class ( ) != object . get Class ( ) ) { return _ BOOL ; } return  SSOSession ID . equals ( object ) ; }
public void add Class To Display (  Method Ident method Ident ) { classes . add ( method Ident ) ; }
@  Override public  String to String ( ) {  String Buffer text = new  String Buffer ( ) ; if ( m_train Instances == null ) { text . append ( _ STR ) ; } else { text . append ( _ STR ) ; if ( ! m_missing_merge ) { text . append ( _ STR ) ; } } text . append ( _ STR ) ; return text . to String ( ) ; }
public void remove (  List < ? > list , int position ) { if ( list . size ( ) > _ NUM ) { list . remove ( custom Header View != null ? position - _ NUM : position ) ; notify Item Removed ( position ) ; } }
public  AMView Bean Base (  String name ) { super ( name ) ; }
public void clear Gesture ( ) { current Gesture Action List . remove All Elements ( ) ; }
private  Array List <  Neuron > initialize Layer (  Neuron Update Rule node Type , int nodes ) {  Array List <  Neuron > layer = new  Array List <  Neuron > ( nodes ) ; for ( int i = _ NUM ; i < nodes ; i ++ ) {  Neuron node = new  Neuron ( get Parent Network ( ) , node Type ) ; node Type . set Increment ( _ NUM ) ; layer . add ( node ) ; } return layer ; }
public  S2 Lat Lng (  S2 Point p ) { this (  Math . atan2 ( p . z ,  Math . sqrt ( p . x * p . x + p . y * p . y ) ) ,  Math . atan2 ( p . y , p . x ) ) ; }
public void add Neuron (  Neuron neuron ) { add Neuron ( neuron , _ BOOL ) ; }
public void import Certs (  String [ ] cert File Names ,  String alias Prefix ) throws  Certificate Exception ,  IOException ,  Key Store Exception ,  No Such Algorithm Exception { if ( cert File Names == null ) { return ; }  Certificate Factory cert Factory =  Certificate Factory . get Instance ( _ STR ) ; for (  String fn : cert File Names ) {  Input Stream in Stream = new  File Input Stream ( fn ) ;  X509 Certificate cert = (  X509 Certificate ) cert Factory . generate Certificate ( in Stream ) ; in Stream . close ( ) ;  String alias = alias Prefix == null ? fn : alias Prefix + fn ; _key Store . set Certificate Entry ( alias , cert ) ; } }
void handle Selection Changed (  String selection ) { if ( m Did Expand Selection ) { m Selected Text = selection ; m Did Expand Selection = _ BOOL ; return ; } if ( selection == null || selection . is Empty ( ) ) { schedule Invalid Tap Notification ( ) ; if ( m Selection Type ==  Selection Type .  TAP ) { reset Selection States ( ) ; return ; } } if ( ! selection . is Empty ( ) ) { unschedule Invalid Tap Notification ( ) ; } m Selected Text = selection ; if ( m Was Tap Gesture Detected ) { m Selection Type =  Selection Type .  TAP ; handle Selection ( selection , m Selection Type ) ; m Was Tap Gesture Detected = _ BOOL ; } else { m Handler . handle Selection Modification ( selection , is Valid Selection ( selection ) , m X , m Y ) ; } }
public  Terms Request Parser parse ( ) throws  Parser Configuration Exception ,  SAXException ,  Parse Failure Exception { try {  SAXParser Factory factory =  SAXParser Factory . new Instance ( ) ;  SAXParser parser = factory . new SAXParser ( ) ; parser . parse ( m Input Source , this ) ; return this ; } catch (  IOException e ) { throw new  Parse Failure Exception ( _ STR , e ) ; } }
public static int length ( final  String value ) { validate ( value ,  NULL_ STRING_ PREDICATE ,  NULL_ STRING_ MSG_ SUPPLIER ) ; return value . length ( ) ; }
public void close Server ( ) throws  IOException { if ( ! server Is Open ( ) ) { return ; } server Socket . close ( ) ; server Socket = null ; server Input = null ; server Output = null ; }
private  Response Packet execute Delete (  Query Template Packet template ,  ISpace Proxy space ,  Transaction txn ) throws  Remote Exception ,  Transaction Exception ,  Unusable Entry Exception ,  Interrupted Exception {  Response Packet packet = new  Response Packet ( ) ; template . set Operation ID ( get Operation ID ( ) ) ; template . set Explain Plan ( get Explain Plan ( ) ) ; if ( is Return Result ( ) ) { int max = get Rownum Limit ( ) ;  Array List <  IEntry Packet > entries = template . take ( space , get Routing ( ) , get Projection Template ( ) , txn , get Timeout ( ) , get Read Modifier ( ) , get If Exists ( ) , max , get Min Entries To Wait For ( ) , get Query Result Type ( ) ) ; packet . set Result Set ( entries ) ; packet . set Int Result ( entries . size ( ) ) ; } else { template . set Routing ( get Routing ( ) ) ; int cleared = _executor . clear ( template , space , txn , get Read Modifier ( ) ) ; packet . set Int Result ( cleared ) ; } return packet ; }
public  File Path (  File Path base ) { this ( base . elements , base . is Absolute ( ) ) ; }
protected static int [ ] insert ( int [ ] old , int old Size , int pos , int x ) { int [ ] result ; if ( old != null && old . length > old Size ) { result = old ; } else { result = new int [ old Size + _ NUM +  COPY_ THRESHOLD ] ; if ( pos > _ NUM && old != null ) {  System . arraycopy ( old , _ NUM , result , _ NUM , pos ) ; } } if ( old != null && old Size - pos > _ NUM ) {  System . arraycopy ( old , pos , result , pos + _ NUM , old Size - pos ) ; } result [ pos ] = x ; return result ; }
public void test Write Read Empty ( ) throws  Exception {  Byte Array Output Stream out = new  Byte Array Output Stream ( _ NUM ) ;  Object Output Stream os = new  Object Output Stream ( out ) ; os . write Object ( empty ) ;  Object Input Stream is = new  Object Input Stream ( new  Byte Array Input Stream ( out . to Byte Array ( ) ) ) ;  Replication Policy copy = (  Replication Policy ) is . read Object ( ) ; is . close ( ) ; os . close ( ) ; assert True ( helper . are Equals ( empty , copy ) ) ; }
public static int deflate ( byte [ ] previous , int previous Length , byte [ ] current , int current Length , byte [ ] result ) { if ( previous == null ) {  System . arraycopy ( current , _ NUM , result , _ NUM , current Length ) ; return current Length ; } int length = _ NUM ; int start1 = _ NUM ; int start2 = _ NUM ; while ( start1 < previous Length && start2 < current Length ) { int end1 = start1 ; int end2 = start2 ; while ( end1 <= previous Length && end2 <= current Length ) { byte c1 = ( end1 < previous Length ? previous [ end1 ] : ( byte ) _ STR ) ; byte c2 = ( end2 < current Length ? current [ end2 ] : ( byte ) _ STR ) ; if ( c1 == c2 ) { if ( c1 == _ STR ) { result [ length ++ ] = _ STR ; break ; } else { end1 ++ ; end2 ++ ; } } else { while ( end1 < previous Length && previous [ end1 ] != _ STR ) { end1 ++ ; } while ( end2 < current Length && current [ end2 ] != _ STR ) { end2 ++ ; } for ( int i = start2 ; i < end2 ; i ++ ) result [ length ++ ] = current [ i ] ; break ; } } start1 = end1 + _ NUM ; start2 = end2 + _ NUM ; if ( start2 < current Length ) result [ length ++ ] = _ STR ; } return length ; }
private int add Labels Internal (  GL10 gl ,  Paint text Paint , boolean draw To Canvas ,  Label Data [ ] labels ) { int u = _ NUM ; int v = _ NUM ; int line Height = _ NUM ; for (  Label Data label : labels ) { int ascent = _ NUM ; int descent = _ NUM ; int measured Text Width = _ NUM ; int height = _ NUM ; int width = _ NUM ; int font Size = label . get Font Size ( ) ; do { text Paint . set Color ( _ NUM | label . get Color ( ) ) ; text Paint . set Text Size ( font Size * m Res . get Display Metrics ( ) . density ) ; ascent = ( int )  Math . ceil ( - text Paint . ascent ( ) ) ; descent = ( int )  Math . ceil ( text Paint . descent ( ) ) ; measured Text Width = ( int )  Math . ceil ( text Paint . measure Text ( label . get Text ( ) ) ) ; height = ascent + descent ; width = measured Text Width ; font Size -- ; } while ( font Size > _ NUM && width > m Res . get Display Metrics ( ) . width Pixels ) ; int next U ; if ( u + width > m Strike Width ) { u = _ NUM ; next U = width ; v += line Height ; line Height = _ NUM ; } else { next U = u + width ; } line Height =  Math . max ( line Height , height ) ; if ( v + line Height > m Strike Height && draw To Canvas ) { throw new  Illegal Argument Exception ( _ STR ) ; } int v Base = v + ascent ; if ( draw To Canvas ) { m Canvas . draw Text ( label . get Text ( ) , u , v Base , text Paint ) ; label . set Texture Data ( width , height , u , v + height , width , - height , m Texel Width , m Texel Height ) ; } u = next U ; } return v + line Height ; }
public void remove Table (  Table table ) { if ( table != null ) { tables . remove ( table ) ; } }
@  Override public  String to String ( ) {  String Buffer sb = new  String Buffer ( _ STR ) ; sb . append ( this . label ) ; sb . append ( _ STR ) ; sb . append ( this . value ) ; sb . append ( _ STR ) ; return ( sb . to String ( ) ) ; }
public void read Fully ( byte [ ] bytes , int start , int len ) throws  IOException { data Input . read Fully ( bytes , start , len ) ; offset += len ; available -= len ; }
public void add Task (  Runnable task ) { task List . add ( task ) ; }
public void add Page (  Lexicon Page page ) { pages . add ( page ) ; }
@  Override protected  List <  String > create New Export Mask Workflow For Initiators (  List <  URI > initiator URIs ,  Export Group export Group ,  Workflow workflow ,  Map <  URI ,  Integer > volume Map ,  Storage System storage ,  String token ,  String previous Step ) throws  Exception {  List <  String > new Steps = new  Array List < > ( ) ; if ( ! initiator URIs . is Empty ( ) ) {  Map <  String ,  List <  URI > > compute Resource To Initiators = map Initiators To Compute Resource ( export Group , initiator URIs ) ; for (  Map .  Entry <  String ,  List <  URI > > resource Entry : compute Resource To Initiators . entry Set ( ) ) {  String compute Key = resource Entry . get Key ( ) ;  List <  URI > compute Initiator URIs = resource Entry . get Value ( ) ; _log . info (  String . format ( _ STR , compute Key ) ) ;  Gen Export Mask Create Workflow Result result = generate Device Specific Export Mask Create Work Flow ( workflow , previous Step , storage , export Group , compute Initiator URIs , volume Map , token ) ; previous Step = result . get Step Id ( ) ; } } new Steps . add ( previous Step ) ; return new Steps ; }
public boolean is Greater Then (  Percent  Percent ) { assert Defined ( ) ;  Big Decimal this Value = not Null ( this ) ;  Big Decimal parameter = not Null (  Percent ) ; return ( this Value . compare To ( parameter ) > _ NUM ) ; }
@  Override public  URI to Vertex URI ( final  Object key ) { return to URI ( key . to String ( ) ) ; }
public static  List <  INavi Module > load Modules ( final  Abstract SQLProvider provider , final  List <  INavi Raw Module > raw Modules , final  Debugger Template Manager debugger Manager ) throws  Couldnt Load Data Exception {  Preconditions . check Not Null ( raw Modules , _ STR ) ;  Postgre SQLDatabase Functions . check Arguments ( provider , debugger Manager ) ; final  List <  CModule > modules = new  Array List < > ( ) ; final  CConnection connection = provider . get Connection ( ) ; if ( !  Postgre SQLHelpers . has Table ( connection ,  CTable Names .  MODULES_ TABLE ) ) { return new  Array List <  INavi Module > ( modules ) ; } final  String query = _ STR +  CTable Names .  MODULES_ TABLE + _ STR + _ STR + _ STR + _ STR +  CTable Names .  FUNCTIONS_ TABLE + _ STR + _ STR +  CTable Names .  FUNCTIONS_ TABLE + _ STR + _ STR + _ STR +  CTable Names .  MODULE_ VIEWS_ TABLE + _ STR +  CTable Names .  VIEWS_ TABLE + _ STR + _ STR +  CTable Names .  MODULES_ TABLE + _ STR + _ STR +  CTable Names .  MODULES_ TABLE + _ STR + _ STR ; try (  Result Set result Set = connection . execute Query ( query , _ BOOL ) ) { while ( result Set . next ( ) ) { final int module Id = result Set . get Int ( _ STR ) ; final  String name =  Postgre SQLHelpers . read String ( result Set , _ STR ) ; final  String md5 =  Postgre SQLHelpers . read String ( result Set , _ STR ) ; final  String sha1 =  Postgre SQLHelpers . read String ( result Set , _ STR ) ; final  String comment =  Postgre SQLHelpers . read String ( result Set , _ STR ) ; final  Timestamp timestamp = result Set . get Timestamp ( _ STR ) ; final  Timestamp modification Date = result Set . get Timestamp ( _ STR ) ; int function Count = result Set . get Int ( _ STR ) ; final int view Count = result Set . get Int ( _ STR ) ; final  IAddress image Base =  Postgre SQLHelpers . load Address ( result Set , _ STR ) ; final  IAddress file Base =  Postgre SQLHelpers . load Address ( result Set , _ STR ) ; final int debugger Id = result Set . get Int ( _ STR ) ; final boolean is Stared = result Set . get Boolean ( _ STR ) ; final int initialization State = result Set . get Int ( _ STR ) ; final  Debugger Template description = debugger Manager . find Debugger ( debugger Id ) ; final int raw Module Id = result Set . get Int ( _ STR ) ; final  INavi Raw Module raw Module =  Postgre SQLDatabase Functions . find Raw Module ( raw Module Id , raw Modules ) ; if ( ( function Count == _ NUM ) && ( raw Module != null ) ) { function Count = raw Module . get Function Count ( ) ; } modules . add ( new  CModule ( module Id , name , comment , timestamp , modification Date , md5 , sha1 , function Count , view Count , file Base , image Base , description , raw Module , initialization State , is Stared , provider ) ) ; } } catch ( final  SQLException e ) { throw new  Couldnt Load Data Exception ( e ) ; } return new  Array List <  INavi Module > ( modules ) ; }
public static  State load Binary (  Data Input Stream dis ) throws  IOException {  String [ ] phone List ; int phone List Length = dis . read Int ( ) ; if ( phone List Length == _ NUM ) { phone List = null ; } else { phone List = new  String [ phone List Length ] ; } for ( int i = _ NUM ; i < phone List Length ; i ++ ) { int index = dis . read Int ( ) ; phone List [ i ] = (  String ) phoneme Table . get ( index ) ; } return new  Final State ( phone List ) ; }
@  Override protected  Node remove From Frontier ( ) { clean Up Frontier ( ) ;  Node result = frontier . remove ( ) ; explored . add ( result . get State ( ) ) ; update Metrics ( frontier . size ( ) ) ; return result ; }
public static boolean is Directory (  String path ) {  File f = new  File ( path ) ; return f . is Directory ( ) ; }
public boolean equals (  Object object ) { if ( ! ( object instanceof  Attribute ) ) { return _ BOOL ; }  Attribute val = (  Attribute ) object ; if ( value == null ) { if ( val . get Value ( ) == null ) { return name . equals ( val . get Name ( ) ) ; } else { return _ BOOL ; } } return ( ( name . equals ( val . get Name ( ) ) ) && ( value . equals ( val . get Value ( ) ) ) ) ; }
public  Builder port ( int port ) { this . port =  Integer . to String ( port ) ; return this ; }
private boolean put Internal (  String variable ,  Object value ) {  Object old Value = values . get ( variable ) ; values . put ( variable , value ) ; if ( old Value == null ) { return value != null ; } else { return ! old Value . equals ( value ) ; } }
public static boolean starts With Http Or Https (  String uri ) { if ( uri == null ) { return _ BOOL ; }  String lowercase Uri = uri . to Lower Case (  Locale .  US ) ; return lowercase Uri . starts With ( _ STR ) || lowercase Uri . starts With ( _ STR ) ; }
@  Override public final  String to String ( ) { if ( string Rep == null ) {  String Builder buffer = new  String Builder ( ) ; buffer . append ( this . name ) ; buffer . append ( _ STR ) ; buffer . append (  Integer . to String ( this . default Port ) ) ; string Rep = buffer . to String ( ) ; } return string Rep ; }
protected  String create Error Message (  String message ) { return  String . format (  Locale .  US , _ STR , locator . get Line Number ( ) , locator . get Column Number ( ) , message ) ; }
public static <  T extends  Throwable >  T read Stack Trace (  T throwable ,  Stream Input in ) throws  IOException { final int stack Trace Elements = in . read VInt ( ) ;  Stack Trace Element [ ] stack Trace = new  Stack Trace Element [ stack Trace Elements ] ; for ( int i = _ NUM ; i < stack Trace Elements ; i ++ ) { final  String declaring Classs = in . read String ( ) ; final  String file Name = in . read Optional String ( ) ; final  String method Name = in . read String ( ) ; final int line Number = in . read VInt ( ) ; stack Trace [ i ] = new  Stack Trace Element ( declaring Classs , method Name , file Name , line Number ) ; } throwable . set Stack Trace ( stack Trace ) ; int num Suppressed = in . read VInt ( ) ; for ( int i = _ NUM ; i < num Suppressed ; i ++ ) { throwable . add Suppressed ( in . read Throwable ( ) ) ; } return throwable ; }
public boolean update Stats And Return Whether Allowed ( ) { long now =  System Clock . elapsed Realtime ( ) ; long delta Ms = now - m Last Request Ms ; if ( delta Ms < m Delay Ms ) return _ BOOL ; m Last Request Ms = now ; if ( delta Ms < _ NUM * m Delay Ms ) { m Delay Ms =  Math . min (  MAX_ DELAY , m Delay Ms * _ NUM ) ; } else { m Delay Ms =  MIN_ DELAY ; } return _ BOOL ; }
static public  MPrint Format create From Table (  Properties ctx , int  AD_ Table_ ID , int  AD_ Print Format_ ID ) { int  AD_ Client_ ID =  Env . get AD_ Client_ ID ( ctx ) ; s_log . info ( _ STR +  AD_ Table_ ID + _ STR +  AD_ Client_ ID ) ;  MPrint Format pf = new  MPrint Format ( ctx ,  AD_ Print Format_ ID , null ) ; pf . set AD_ Table_ ID (  AD_ Table_ ID ) ;  String sql = _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR ; boolean error = _ BOOL ;  Prepared Statement pstmt = null ;  Result Set rs = null ; try { pstmt =  DB . prepare Statement ( sql , null ) ; pstmt . set Int ( _ NUM ,  AD_ Table_ ID ) ; pstmt . set Int ( _ NUM ,  AD_ Client_ ID ) ; rs = pstmt . execute Query ( ) ; if ( rs . next ( ) ) {  String  Table Name = rs . get String ( _ NUM ) ;  String  Column Name =  Table Name + _ STR ;  String s =  Column Name ; if ( !  Column Name . equals ( _ STR ) ) { s =  Msg . translate ( ctx ,  Column Name ) ; if (  Column Name . equals ( s ) ) s =  Msg . translate ( ctx ,  Table Name ) ; } int count = rs . get Int ( _ NUM ) ; if ( count > _ NUM ) s += _ STR + ( count + _ NUM ) ; pf . set Name ( s ) ; pf . set AD_ Print Color_ ID ( rs . get Int ( _ NUM ) ) ; pf . set AD_ Print Font_ ID ( rs . get Int ( _ NUM ) ) ; pf . set AD_ Print Paper_ ID ( rs . get Int ( _ NUM ) ) ; error = _ BOOL ; } else s_log . log (  Level .  SEVERE , _ STR +  AD_ Table_ ID ) ; } catch (  SQLException e ) { s_log . log (  Level .  SEVERE , sql , e ) ; } finally {  DB . close ( rs , pstmt ) ; rs = null ; pstmt = null ; } if ( error ) return null ; if ( ! pf . save ( ) ) return null ; pf . set Items ( create Items ( ctx , pf ) ) ; return pf ; }
public  Register Values ( final com . google . security . zynamics . binnavi . debug . models . targetinformation .  Register Values register Values ) { final  List <  Thread Register Values > values = new  Array List <  Thread Register Values > ( ) ; for ( final  Thread Registers thread Register Values : register Values ) { values . add ( new  Thread Register Values ( thread Register Values ) ) ; } this . values = values ; }
public void enable ( ) throws  IOException { synchronized ( opt Out Lock ) { if ( is Opt Out ( ) ) { configuration . set ( _ STR , _ BOOL ) ; configuration . save ( configuration File ) ; } if ( task == null ) { start ( ) ; } } }
public void add All ( int [ ] data ) { int data Len = data . length ; if ( data Len == _ NUM ) { return ; } int newcap = size + ( int ) ( data Len * _ NUM ) + _ NUM ; ensure Capacity ( newcap ) ;  System . arraycopy ( data , _ NUM , array , size , data Len ) ; size += data Len ; }
public void write ( byte [ ] b ) throws java . io .  IOException { write ( b , _ NUM , b . length ) ; }
public void add Scanning Callback (  One Sheeld Scanning Callback scanning Callback ) { if ( scanning Callback != null && ! scanning Callbacks . contains ( scanning Callback ) ) scanning Callbacks . add ( scanning Callback ) ; }
public void paint (  Graphics g ,  JComponent c ) {  Rectangle bounds = c . get Bounds ( ) ; check ( bounds ) ; int h = c . get Height ( ) ; int w = c . get Width ( ) ; g . draw Image ( m_back Image , _ NUM , _ NUM , w , h , bounds . x , bounds . y , bounds . x + w , bounds . y + h , c ) ; }
public final double sample Max ( ) { long count = _acquire Count . get ( ) - _release Count . get ( ) ; long max = _max . get And Set ( count ) ; return max ; }
public boolean matches (  Integer i ) { if ( m_ Integer == null ) return _ BOOL ; else if ( i == null ) return _ BOOL ; else return ( m_ Integer . int Value ( ) == i . int Value ( ) ) ; }
public void shutdown ( ) { pool . shutdown ( ) ; }
public static boolean is Proposition Symbol Identifier Start ( char ch ) { return  Character . is Java Identifier Start ( ch ) ; }
public static void o (  Z a ) { o ( a ,  Parameters .  Output Field Width ,  Parameters .  Output Frac Places ) ; }
public int search (  String txt ) { int m = pat . length ( ) ; int n = txt . length ( ) ; int skip ; for ( int i = _ NUM ; i <= n - m ; i += skip ) { skip = _ NUM ; for ( int j = m - _ NUM ; j >= _ NUM ; j -- ) { if ( pat . char At ( j ) != txt . char At ( i + j ) ) { skip =  Math . max ( _ NUM , j - right [ txt . char At ( i + j ) ] ) ; break ; } } if ( skip == _ NUM ) return i ; } return n ; }
private void recalculate Table Indices ( ) {  List <  Integer > indices = new  Linked List <  Integer > ( ) ; for ( int i = _ NUM ; i < elements . length ; i ++ ) { if ( mask [ elements [ i ] ] ) { indices . add ( i ) ; } } table Index Map = new int [ indices . size ( ) ] ;  Iterator <  Integer > i = indices . iterator ( ) ; int counter = _ NUM ; while ( i . has Next ( ) ) { table Index Map [ counter ++ ] = i . next ( ) ; } }
public static  String trim Length (  String str , int length ) { if ( str == null ) return str ; if ( length <= _ NUM ) throw new  Illegal Argument Exception ( _ STR + length ) ; if ( str . length ( ) > length ) return str . substring ( _ NUM , length ) ; return str ; }
public void clear ( ) { clear ( _ BOOL ) ; }
protected void do Run ( ) {  Object groovy ; groovy =  Groovy . new Instance ( m_ Owner . get Filename ( ) ,  Object . class ) ; if ( has Method ( groovy , _ STR ) )  Groovy . invoke ( groovy , _ STR , new  Class [ ] {  String [ ] . class } , new  Object [ ] { get Args ( ) } ) ; else if ( has Method ( groovy , _ STR ) )  Groovy . invoke ( groovy , _ STR , new  Class [ ] {  String [ ] . class } , new  Object [ ] { get Args ( ) } ) ; else throw new  Illegal State Exception ( _ STR ) ; }
protected boolean after Save ( boolean new Record , boolean success ) { if ( ! success ) return success ; re Index ( new Record ) ; return success ; }
public void select New Photo ( ) { remove From Cache ( ) ; final  Intent intent = new  Intent ( ) ; if (  Build .  VERSION .  SDK_ INT < _ NUM ) { intent . set Action (  Intent .  ACTION_ GET_ CONTENT ) ; } else { intent . set Action ( _ STR ) ; intent . add Category (  Intent .  CATEGORY_ OPENABLE ) ; } intent . set Type ( _ STR ) ; start Activity For Result ( intent ,  NEW_ PHOTO ) ; }
public synchronized void store Resource Config (  String cluster Name ,  Resource Type resource Type ,  Tungsten Properties resource Props ) throws  Configuration Exception { if ( get Cluster Home ( ) == null ) { throw new  Configuration Exception ( _ STR + get Module Properties File Name (  Configuration Constants .  TR_ PROPERTIES , get Cluster Home ( ) ) ) ; }  String resource Dir = get Resource Config Dir Name ( get Cluster Home ( ) , cluster Name , resource Type ) ;  File resources = new  File ( resource Dir ) ; if ( ! resources . is Directory ( ) ) { if ( resources . mkdirs ( ) ) { logger . info (  String . format ( _ STR , resource Dir ) ) ; } else {  String msg =  String . format ( _ STR , get Resource Config Dir Name ( get Cluster Home ( ) , cluster Name , resource Type ) ) ; logger . error ( msg ) ; throw new  Configuration Exception ( msg ) ; } }  String out File Name = resources . get Absolute Path ( ) +  File . separator + resource Props . get String ( _ STR ) + _ STR ; store ( resource Props , out File Name ) ; }
public int write Proto Id (  Proto Id proto Id ) { int off = data . position ( ) ; write Int ( proto Id . shorty Index ) ; write Int ( proto Id . return Type Index ) ; write Int ( proto Id . parameters Offset ) ; return off ; }
private void show Popup Menu ( final  Mouse Event event ) { final int index = m_tabbed Pane . index At Location ( event . get X ( ) , event . get Y ( ) ) ; if ( index == - _ NUM ) { return ; } final  CGraph Panel child = (  CGraph Panel ) m_tabbed Pane . get Component At ( index ) ; final  JPopup Menu menu = new  JGraph Tab Menu ( m_tabbed Pane , child ) ; menu . show ( event . get Component ( ) , event . get X ( ) , event . get Y ( ) ) ; }
public static double generate Random Double Between ( double lower Limit , double upper Limit ) { return lower Limit + ( ( upper Limit - lower Limit ) * _r . next Double ( ) ) ; }
public  Types Item Provider Adapter Factory ( ) { supported Types . add (  IEditing Domain Item Provider . class ) ; supported Types . add (  IStructured Item Content Provider . class ) ; supported Types . add (  ITree Item Content Provider . class ) ; supported Types . add (  IItem Label Provider . class ) ; supported Types . add (  IItem Property Source . class ) ; }
private double kd KNNSearch ( int left , int right , int axis ,  O query ,  KNNHeap knns ,  DBIDArray Iter iter , double maxdist ) { if ( right - left <= leafsize ) { for ( iter . seek ( left ) ; iter . get Offset ( ) < right ; iter . advance ( ) ) { double dist = norm . distance ( query , relation . get ( iter ) ) ; count Object Access ( ) ; count Distance Computation ( ) ; if ( dist <= maxdist ) { knns . insert ( dist , iter ) ; } maxdist = knns . get KNNDistance ( ) ; } return maxdist ; } final int middle = ( left + right ) > > > _ NUM ;  O split = relation . get ( iter . seek ( middle ) ) ; count Object Access ( ) ; final double delta = split . double Value ( axis ) - query . double Value ( axis ) ; final boolean onleft = ( delta >= _ NUM ) ; final boolean onright = ( delta <= _ NUM ) ; final int next = ( axis + _ NUM ) % dims ; if ( onleft && onright ) { double dist = norm . distance ( query , split ) ; count Distance Computation ( ) ; if ( dist <= maxdist ) { assert ( iter . get Offset ( ) == middle ) ; knns . insert ( dist , iter ) ; maxdist = knns . get KNNDistance ( ) ; } if ( left < middle ) { maxdist = kd KNNSearch ( left , middle , next , query , knns , iter , maxdist ) ; } if ( middle + _ NUM < right ) { maxdist = kd KNNSearch ( middle + _ NUM , right , next , query , knns , iter , maxdist ) ; } } else { if ( onleft ) { if ( left < middle ) { maxdist = kd KNNSearch ( left , middle , next , query , knns , iter , maxdist ) ; } if (  Math . abs ( delta ) <= maxdist ) { double dist = norm . distance ( query , split ) ; count Distance Computation ( ) ; if ( dist <= maxdist ) { knns . insert ( dist , iter . seek ( middle ) ) ; maxdist = knns . get KNNDistance ( ) ; } } if ( ( middle + _ NUM < right ) && (  Math . abs ( delta ) <= maxdist ) ) { maxdist = kd KNNSearch ( middle + _ NUM , right , next , query , knns , iter , maxdist ) ; } } else { if ( middle + _ NUM < right ) { maxdist = kd KNNSearch ( middle + _ NUM , right , next , query , knns , iter , maxdist ) ; } if (  Math . abs ( delta ) <= maxdist ) { double dist = norm . distance ( query , split ) ; count Distance Computation ( ) ; if ( dist <= maxdist ) { knns . insert ( dist , iter . seek ( middle ) ) ; maxdist = knns . get KNNDistance ( ) ; } } if ( ( left < middle ) && (  Math . abs ( delta ) <= maxdist ) ) { maxdist = kd KNNSearch ( left , middle , next , query , knns , iter , maxdist ) ; } } } return maxdist ; }
public static  Map <  String ,  Map <  String ,  Map <  String ,  Object > > > prepare Field (  Map <  String , ? > input Fields ,  Map <  String ,  Object > query String Map ,  Map <  String ,  List <  Object [ ] > > orig Value Map ) {  Map <  String ,  Map <  String ,  Map <  String ,  Object > > > normalized Fields = new  Linked Hash Map <  String ,  Map <  String ,  Map <  String ,  Object > > > ( ) ; for (  String field Name Raw : input Fields . key Set ( ) ) {  String field Name Root = null ;  String field Pair = null ;  Object field Value = null ; int i Pos = - _ NUM ; int i Pos2 = - _ NUM ;  Map <  String ,  Map <  String ,  Object > > sub Map = null ;  Map <  String ,  Object > sub Map2 = null ;  String field Mode = null ; field Value = input Fields . get ( field Name Raw ) ; if (  Object Type . is Empty ( field Value ) ) { continue ; } query String Map . put ( field Name Raw , field Value ) ; i Pos = field Name Raw . index Of ( _ STR ) ; if ( i Pos >= _ NUM ) {  String suffix = field Name Raw . substring ( i Pos + _ NUM ) ; i Pos2 = suffix . index Of ( _ STR ) ; if ( i Pos2 == _ NUM ) { continue ; } } if ( i Pos < _ NUM ) { field Name Root = field Name Raw ; field Pair = _ STR ; field Mode = _ STR ; } else { field Name Root = field Name Raw . substring ( _ NUM , i Pos ) ;  String suffix = field Name Raw . substring ( i Pos + _ NUM ) ; i Pos2 = suffix . index Of ( _ STR ) ; if ( i Pos2 < _ NUM ) { if ( suffix . starts With ( _ STR ) ) { field Pair = suffix ; field Mode = _ STR ; } else { field Pair = _ STR ; field Mode = suffix ; } } else {  String tkn0 = suffix . substring ( _ NUM , i Pos2 ) ;  String tkn1 = suffix . substring ( i Pos2 + _ NUM ) ; if ( tkn0 . starts With ( _ STR ) ) { field Pair = tkn0 ; field Mode = tkn1 ; } else { field Pair = tkn1 ; field Mode = tkn0 ; } } } sub Map = normalized Fields . get ( field Name Root ) ; if ( sub Map == null ) { sub Map = new  Linked Hash Map <  String ,  Map <  String ,  Object > > ( ) ; normalized Fields . put ( field Name Root , sub Map ) ; } sub Map2 = sub Map . get ( field Pair ) ; if ( sub Map2 == null ) { sub Map2 = new  Linked Hash Map <  String ,  Object > ( ) ; sub Map . put ( field Pair , sub Map2 ) ; } sub Map2 . put ( field Mode , field Value ) ;  List <  Object [ ] > orig List = orig Value Map . get ( field Name Root ) ; if ( orig List == null ) { orig List = new  Linked List <  Object [ ] > ( ) ; orig Value Map . put ( field Name Root , orig List ) ; }  Object [ ] orig Values = { field Name Raw , field Value } ; orig List . add ( orig Values ) ; } return normalized Fields ; }
public void publish (  String topic Name , int qos , byte [ ] payload ) throws  Mqtt Exception { log ( _ STR + broker Url + _ STR + client . get Client Id ( ) ) ;  IMqtt Token con Token = client . connect ( con Opt , null , null ) ; con Token . wait For Completion ( ) ; log ( _ STR ) ; log ( _ STR +  System . current Time Millis ( ) + _ STR + topic Name + _ STR + qos ) ;  Mqtt Message message = new  Mqtt Message ( payload ) ; message . set Qos ( qos ) ;  IMqtt Delivery Token pub Token = client . publish ( topic Name , message , null , null ) ; pub Token . wait For Completion ( ) ; log ( _ STR ) ; log ( _ STR ) ;  IMqtt Token disc Token = client . disconnect ( null , null ) ; disc Token . wait For Completion ( ) ; log ( _ STR ) ; }
synchronized void remove Tracer (  Tracer tracer ) { if ( cur Tracers . remove ( tracer ) ) {  LOG . trace ( to String ( ) + _ STR + tracer . to String ( ) ) ; if ( cur Tracers . size ( ) == _ NUM ) { remove And Close All Span Receivers ( ) ; } } }
public boolean delete Entry ( int index ) {  System . arraycopy ( entries , index + _ NUM , entries , index , num Entries - index - _ NUM ) ; entries [ -- num Entries ] = null ; return _ BOOL ; }
public void restore ( double value ) { set Value (  Math . min ( max Value , get Value ( ) + value ) ) ; }
@  Ignore @  Test public void test Region Factory Properties Region Attributes ( ) { }
public static  Array List <  String > convert String Array To Array List (  String [ ] string Array ) { if ( string Array != null && string Array . length > _ NUM ) { return new  Array List < > (  Arrays . as List ( string Array ) ) ; } else { return null ; } }
public  Message Version (  String version ) { this . version = version ; try { get Version Parts ( ) ; } catch (  Number Format Exception e ) { throw new  Illegal Argument Exception (  String . format ( _ STR , version ) , e ) ; } }
@  Override public void incoming Object (  IAnalyzed Interval analyzed Interval ) throws  Ade Exception { for (  IAnalyzed Message Summary ams : analyzed Interval . get Analyzed Messages ( ) ) { final  String id = ams . get Message Id ( ) ;  Msg Data data = m_msg Data . get ( id ) ; if ( data == null ) { data = new  Msg Data ( ) ; m_msg Data . put ( id , data ) ; } if ( ! is Clustered ( ams ) ) { data . m_total Log Counts +=  Math . log ( ams . get Number Of Appearances ( ) ) ; data . m_interval Count ++ ; } data . m_all Count += ams . get Number Of Appearances ( ) ; data . m_interval All Count ++ ; if ( data . m_max Num Appearance < ams . get Number Of Appearances ( ) ) { data . m_max Num Appearance = ams . get Number Of Appearances ( ) ; } } ++ m_total Interval Count ; }
public static  String map Unsupported Encoding (  String encoding ) { if ( encoding . equals Ignore Case ( _ STR ) ) { return _ STR ; } return encoding ; }
public  Bayes Estimator Editor (  Bayes Estimator Wrapper bayes Est Wrapper ) { this ( bayes Est Wrapper . get Estimated Bayes Im ( ) , bayes Est Wrapper . get Data Set ( ) ) ; }
public void mark Key For Preload ( int idx ) { if ( preload Keys == null ) preload Keys = new  Bit Set ( ) ; preload Keys . set ( idx , _ BOOL ) ; }
private void add Token (  String token Str ) {  Integer token Int = (  Integer ) f Token Names . get ( token Str ) ; if ( token Int == null ) { token Int = new  Integer ( f Token Names . size ( ) ) ; f Token Names . put ( token Int , token Str ) ; } add Token ( token Int . int Value ( ) ) ; }
private static void add Entries For Infrequent Blocks (  IR ir ,  Live Analysis live ,  Hash Map <  Basic Block Pair ,  Hash Set <  Register > > result ) { for (  Enumeration <  Basic Block > e = ir . get Basic Blocks ( ) ; e . has More Elements ( ) ; ) {  Basic Block bb = e . next Element ( ) ; boolean bb Infrequent = bb . get Infrequent ( ) ; for (  Enumeration <  Basic Block > out = bb . get Normal Out ( ) ; out . has More Elements ( ) ; ) {  Basic Block dest = out . next Element ( ) ; boolean dest Infrequent = dest . get Infrequent ( ) ; if ( bb Infrequent ^ dest Infrequent ) {  Hash Set <  Register > live Registers = live . get Live Registers On Edge ( bb , dest ) ; for (  Register r : live Registers ) { if ( r . is Symbolic ( ) ) {  Hash Set <  Register > s = find Or Create Split Set ( result , bb , dest ) ; s . add ( r ) ; } } } } } }
public void insert Sleep Time ( ) {  Script Step sleep Time Script Step =  Script Step Factory . create Sleep Time ( get Sleep Time ( ) ) ; steps . add ( get Insert Index ( ) , sleep Time Script Step ) ; sleep Time = _ STR ; reindex Script Steps ( ) ; }
public  Object invoke (  Object o ) throws  Exception { return new  Integer (  Array . get Length ( o ) ) ; }
@  Override public void remove Request ( int interrupt Number ) { synchronized ( interrupt Request Queue ) {  Interrupt Request request To Remove = null ; for (  Interrupt Request interrupt Request : interrupt Request Queue ) { if ( interrupt Request . get Interrupt Number ( ) == interrupt Number ) { request To Remove = interrupt Request ; break ; } } if ( request To Remove != null ) { interrupt Request Queue . remove ( request To Remove ) ; } } }
@  Override public final void on Heatmap Failed ( ) { m Update Pending = _ BOOL ; }
public void error Handling (  Exception error ) { error Handling ( error , null ) ; }
public static long static Field Offset (  Field field ) { return  UNSAFE . static Field Offset ( field ) ; }
protected synchronized void read ( long offset , byte [ ] b ) throws  IOException { if ( byte Buffer != null ) { byte Buffer . position ( ( int ) offset ) ; byte Buffer . get ( b ) ; } else { throw new  IOException ( _ STR + get Path ( ) + _ STR ) ; } }
public static  String to String (  Timestamp timestamp ) { if ( timestamp == null ) return null ; else return timestamp . to String ( ) ; }
Generic Package BO (  KLVPacket .  Header header ) { super ( header ) ; }
public  Edge find Edge (  Coordinate p0 ,  Coordinate p1 ) { for ( int i = _ NUM ; i < edges . size ( ) ; i ++ ) {  Edge e = (  Edge ) edges . get ( i ) ;  Coordinate [ ] e Coord = e . get Coordinates ( ) ; if ( p0 . equals ( e Coord [ _ NUM ] ) && p1 . equals ( e Coord [ _ NUM ] ) ) return e ; } return null ; }
public static  String trim Trailing Spaces (  String string ) { if ( string == null ) { return null ; } for ( int i = string . length ( ) - _ NUM ; i >= _ NUM ; i -- ) { if ( string . char At ( i ) == _ STR || string . char At ( i ) == _ STR || string . char At ( i ) == _ STR || string . char At ( i ) == _ STR ) { continue ; } else { string = string . substring ( _ NUM , i + _ NUM ) ; return string ; } } return string ; }
protected final void report Issue (  Health Issue health Issue ) {  Event Bus event Bus ; synchronized ( m Lock ) { if ( m Health Event Bus == null ) {  LOG . w ( _ STR + _ STR , health Issue . to String ( ) ) ; return ; } m Active Issues . add ( health Issue ) ; event Bus = m Health Event Bus ; } event Bus . post ( health Issue . discovered ) ; }
private static void warm Up Pool (  ODatabase Document Pool pool ,  String db URL ,  String user ,  String password , int min Size ) { logger . trace ( _ STR ,  Integer . value Of ( min Size ) ) ;  List <  ODatabase Document Tx > list = new  Array List <  ODatabase Document Tx > ( ) ; for ( int count = _ NUM ; count < min Size ; count ++ ) { logger . trace ( _ STR ,  Integer . value Of ( count ) ) ; try { list . add ( pool . acquire ( db URL , user , password ) ) ; } catch (  Exception ex ) { logger . warn ( _ STR ,  Integer . value Of ( count ) , ex ) ; } } for (  ODatabase Document Tx entry : list ) { try { if ( entry != null ) { entry . close ( ) ; } } catch (  Exception ex ) { logger . warn ( _ STR , entry , ex ) ; } } }
@  Override public void agg (  Object new Val ) { if ( new Val instanceof byte [ ] ) {  Byte Buffer buffer =  Byte Buffer . wrap ( ( byte [ ] ) new Val ) ; buffer . rewind ( ) ; while ( buffer . has Remaining ( ) ) { byte [ ] value Byte = new byte [ buffer . get Int ( ) ] ; buffer . get ( value Byte ) ;  Big Decimal value Big Decimal =  Data Type Util . byte To Big Decimal ( value Byte ) ; agg Val = agg Val . add ( value Big Decimal ) ; count += buffer . get Double ( ) ; first Time = _ BOOL ; } return ; } if ( first Time ) { agg Val = (  Big Decimal ) new Val ; first Time = _ BOOL ; } else { agg Val = agg Val . add ( (  Big Decimal ) new Val ) ; } count ++ ; }
public static void register ( int seq ,  ISender sender ) { if ( sender != null && ! senders . contains ( sender ) ) { senders . add ( seq , sender ) ; } }
public boolean is External Entity (  String entity Name ) {  Entity entity = (  Entity ) f Entities . get ( entity Name ) ; if ( entity == null ) { return _ BOOL ; } return entity . is External ( ) ; }
public void add Event ( final  Event evt ) ;
public void add (  Key key ) { if ( key == null ) throw new  Null Pointer Exception ( _ STR ) ; set . add ( key ) ; }
public boolean is Completed ( ) { for (  Aborting Runnable ar : tasks ) { synchronized ( ar ) { if ( ! ar . done ) { return _ BOOL ; } } } return _ BOOL ; }
default  Byte Buffer serialize (  H type Handler ,  T value ) {  Byte Buffer buffer =  Byte Buffer . allocate ( size ( type Handler , value ) ) ; serialize ( type Handler , value , buffer ) ; return buffer ; }
protected int valid Submissions ( ) { if ( submissions == null ) return _ NUM ; int size = _ NUM ; for ( int i = submissions . size ( ) - _ NUM ; i >= _ NUM ; i -- ) { if ( ! submissions . element At ( i ) . errors ) size ++ ; } return size ; }
Calendar to Calendar (  String value ,  String pattern ,  Locale locale ) {  Calendar calendar = null ; try {  Date Format format = ( locale == null ) ? new  Simple Date Format ( pattern ) : new  Simple Date Format ( pattern , locale ) ; format . set Lenient ( _ BOOL ) ; format . parse ( value ) ; calendar = format . get Calendar ( ) ; } catch (  Exception e ) { fail ( _ STR + value + _ STR + pattern + _ STR + e . to String ( ) ) ; } return calendar ; }
public boolean on Touch Event (  Motion Event event ) { try { int pointer Count = multi Touch Supported ? (  Integer ) m_get Pointer Count . invoke ( event ) : _ NUM ; if ( get Mode ( ) ==  MODE_ NOTHING && ! handle Single Touch Events && pointer Count == _ NUM ) return _ BOOL ; int action = event . get Action ( ) ; int hist Len = event . get History Size ( ) / pointer Count ; for ( int hist Idx = _ NUM ; hist Idx <= hist Len ; hist Idx ++ ) { boolean processing Hist = hist Idx < hist Len ; if ( ! multi Touch Supported || pointer Count == _ NUM ) { x Vals [ _ NUM ] = processing Hist ? event . get Historical X ( hist Idx ) : event . get X ( ) ; y Vals [ _ NUM ] = processing Hist ? event . get Historical Y ( hist Idx ) : event . get Y ( ) ; pressure Vals [ _ NUM ] = processing Hist ? event . get Historical Pressure ( hist Idx ) : event . get Pressure ( ) ; } else { int num Pointers =  Math . min ( pointer Count ,  MAX_ TOUCH_ POINTS ) ; for ( int ptr Idx = _ NUM ; ptr Idx < num Pointers ; ptr Idx ++ ) { int ptr Id = (  Integer ) m_get Pointer Id . invoke ( event , ptr Idx ) ; pointer Ids [ ptr Idx ] = ptr Id ; x Vals [ ptr Idx ] = (  Float ) ( processing Hist ? m_get Historical X . invoke ( event , ptr Idx , hist Idx ) : m_get X . invoke ( event , ptr Idx ) ) ; y Vals [ ptr Idx ] = (  Float ) ( processing Hist ? m_get Historical Y . invoke ( event , ptr Idx , hist Idx ) : m_get Y . invoke ( event , ptr Idx ) ) ; pressure Vals [ ptr Idx ] = (  Float ) ( processing Hist ? m_get Historical Pressure . invoke ( event , ptr Idx , hist Idx ) : m_get Pressure . invoke ( event , ptr Idx ) ) ; } } decode Touch Event ( pointer Count , x Vals , y Vals , pressure Vals , pointer Ids , processing Hist ?  Motion Event .  ACTION_ MOVE : action , processing Hist ? _ BOOL : action !=  Motion Event .  ACTION_ UP && ( action & ( ( _ NUM <<  ACTION_ POINTER_ INDEX_ SHIFT ) - _ NUM ) ) !=  ACTION_ POINTER_ UP && action !=  Motion Event .  ACTION_ CANCEL , processing Hist ? event . get Historical Event Time ( hist Idx ) : event . get Event Time ( ) ) ; } return _ BOOL ; } catch (  Exception e ) {  Log . e (  TAG , _ STR , e ) ; return _ BOOL ; } }
public boolean read Bit ( ) throws  IOException { if ( bit Field == - _ NUM ) { bit Field = in . read ( ) ; if ( bit Field == - _ NUM ) { throw new  EOFException ( ) ; } mask = _ NUM ; } boolean bit = ( bit Field & mask ) != _ NUM ; if ( ( mask <<= _ NUM ) == _ NUM ) { bit Field = - _ NUM ; } return bit ; }
protected boolean verify Limit (  Collection result , int limit ,  Execution Context context ) { if ( limit > _ NUM ) { return result . size ( ) == limit ; } return _ BOOL ; }
private int min ( int a , int b ) { if ( a < b ) return a ; return b ; }
public void add Tree Model Listener (  Tree Model Listener l ) { tree Model Listeners . add Element ( l ) ; }
public static  URIName name Constraint (  Der Value value ) throws  IOException {  URI uri ;  String name = value . get IA5 String ( ) ; try { uri = new  URI ( name ) ; } catch (  URISyntax Exception use ) { throw new  IOException ( _ STR + name , use ) ; } if ( uri . get Scheme ( ) == null ) {  String host = uri . get Scheme Specific Part ( ) ; try {  DNSName host DNS ; if ( host . starts With ( _ STR ) ) { host DNS = new  DNSName ( host . substring ( _ NUM ) ) ; } else { host DNS = new  DNSName ( host ) ; } return new  URIName ( uri , host , host DNS ) ; } catch (  IOException ioe ) { throw new  IOException ( _ STR + name , ioe ) ; } } else { throw new  IOException ( _ STR + _ STR + name ) ; } }
public  Projected Stream add View (  String namespace ,  String name ,  Expression ... parameters ) { views . add (  View . create ( namespace , name , parameters ) ) ; return this ; }
protected int read (  Speech Record recorder , byte [ ] buffer ) { int len = buffer . length ; int num Of Bytes = recorder . read ( buffer , _ NUM , len ) ; int status = get Status ( num Of Bytes , len ) ; if ( status == _ NUM && num Of Bytes >= _ NUM ) {  System . arraycopy ( buffer , _ NUM , m Recording , m Recorded Length , num Of Bytes ) ; m Recorded Length += len ; } return status ; }
public int candy ( int [ ] ratings ) { int [ ] candies = new int [ ratings . length ] ; candies [ _ NUM ] = _ NUM ; for ( int i = _ NUM ; i < ratings . length ; i ++ ) candies [ i ] = ratings [ i ] > ratings [ i - _ NUM ] ? candies [ i - _ NUM ] + _ NUM : _ NUM ; int res = candies [ candies . length - _ NUM ] ; for ( int i = ratings . length - _ NUM ; i >= _ NUM ; i -- ) { if ( ratings [ i ] > ratings [ i + _ NUM ] ) candies [ i ] =  Math . max ( candies [ i ] , candies [ i + _ NUM ] + _ NUM ) ; res += candies [ i ] ; } return res ; }
public static  Zone Rules of (  Zone Offset base Standard Offset ,  Zone Offset base Wall Offset ,  List <  Zone Offset Transition > standard Offset Transition List ,  List <  Zone Offset Transition > transition List ,  List <  Zone Offset Transition Rule > last Rules ) {  Objects . require Non Null ( base Standard Offset , _ STR ) ;  Objects . require Non Null ( base Wall Offset , _ STR ) ;  Objects . require Non Null ( standard Offset Transition List , _ STR ) ;  Objects . require Non Null ( transition List , _ STR ) ;  Objects . require Non Null ( last Rules , _ STR ) ; return new  Zone Rules ( base Standard Offset , base Wall Offset , standard Offset Transition List , transition List , last Rules ) ; }
protected int hash (  Object o ) { int h = o == null ? _ NUM : o . hash Code ( ) ; h += ( h << _ NUM ) ^ _ NUM ; h ^= ( h > > > _ NUM ) ; h += ( h << _ NUM ) ; h ^= ( h > > > _ NUM ) ; h += ( h << _ NUM ) + ( h << _ NUM ) ; return h ^ ( h > > > _ NUM ) ; }
public void add Delete Template (  String delete Template ) { delete Templates . add ( delete Template ) ; }
private  Bitmap create Photo Thumbnail ( final  String a Image Url ) {  Bitmap bitmap Ret Value = null ; if ( null != a Image Url ) {  Uri image Uri =  Uri . from File ( new  File ( a Image Url ) ) ; int rotation Angle =  Image Utils . get Rotation Angle For Bitmap (  Vector Medias Picker Activity . this , image Uri ) ; try { final  String filename = image Uri . get Path ( ) ;  File Input Stream image Stream = new  File Input Stream ( new  File ( filename ) ) ; bitmap Ret Value = create Photo Thumbnail ( image Stream , rotation Angle ) ; image Stream . close ( ) ;  System . gc ( ) ; } catch (  Out Of Memory Error e ) {  Log . e (  LOG_ TAG , _ STR ) ; } catch (  Exception e ) {  Log . e (  LOG_ TAG , _ STR + e . get Message ( ) ) ; } } return bitmap Ret Value ; }
public  Object Name pre Register (  MBean Server server ,  Object Name name ) throws  Exception { if ( name == null ) { if ( config == null ) return null ; if ( config . get Name ( ) == null ) return null ; name =  Scan Manager . make MBean Name (  Scan Dir Config MXBean . class , config . get Name ( ) ) ; } object Name = name ; mbean Server = server ; synchronized ( this ) { configname = name . get Key Property ( _ STR ) ; if ( config == null ) config = new  Scan Manager Config ( configname ) ; else config = config . copy ( configname ) ; } return name ; }
public static  Node Version parse ( final  String s ) { final  Matcher matcher =  VERSION_ PATTERN . matcher ( s ) ; if ( ! matcher . matches ( ) ) { throw new  Illegal Argument Exception (  String . format ( _ STR , s ) ) ; } return new  Node Version (  Integer . parse Int ( matcher . group ( _ NUM ) ) ,  Integer . parse Int ( matcher . group ( _ NUM ) ) ,  Integer . parse Int ( matcher . group ( _ NUM ) ) , matcher . group ( _ NUM ) ) ; }
public byte [ ] to Bytes ( ) {  Byte Buffer geometry Byte Buffer = data . to Byte Buffer ( ) ; geometry Byte Buffer . rewind ( ) ; int size = _ NUM + geometry Byte Buffer . capacity ( ) ;  Byte Buffer buf =  Byte Buffer . allocate ( size ) ; buf . order (  Byte Order .  LITTLE_ ENDIAN ) ; buf . rewind ( ) ; buf . put Int (  Byte Swapper . swap ( record Number ) ) ; buf . put Int (  Byte Swapper . swap ( content Length ) ) ; buf . put Int ( get Int From Shape Type ( shape Type ) ) ; byte [ ] bytes = geometry Byte Buffer . array ( ) ; for ( int i = _ NUM ; i < bytes . length ; i ++ ) { buf . put ( bytes [ i ] ) ; } return buf . array ( ) ; }
private static  String [ ] to String Array ( final  Collection < ? > collection ) { if ( collection == null ) { return null ; } return collection . to Array ( new  String [ collection . size ( ) ] ) ; }
public void put String (  String s ) { ensure Capacity ( ( s . length ( ) * _ NUM ) + _ NUM ) ;  System . arraycopy ( s . get Bytes ( ) , _ NUM , this . byte Buffer , this . position , s . length ( ) ) ; this . position += s . length ( ) ; this . byte Buffer [ this . position ++ ] = _ NUM ; }
@  Override public void external Entity Decl (  String name ,  XMLResource Identifier identifier ,  Augmentations augs ) throws  XNIException { try { if ( f Decl Handler != null ) {  String public Id = identifier . get Public Id ( ) ;  String system Id = f Resolve DTDURIs ? identifier . get Expanded System Id ( ) : identifier . get Literal System Id ( ) ; f Decl Handler . external Entity Decl ( name , public Id , system Id ) ; } } catch (  SAXException e ) { throw new  XNIException ( e ) ; } }
public  Moving Average Processor (  String type , double alpha ) { if ( !  VALID_ TYPES . contains ( type ) ) { throw new  Illegal Argument Exception ( type + _ STR + _ STR ) ; } if ( ( alpha < _ NUM ) || ( alpha > _ NUM ) ) { throw new  Illegal Argument Exception ( _ STR ) ; } this . type = type ; this . alpha = alpha ; }
private  String pre Process Signature (  String signature ) { int index ; if ( ( index = signature . index Of ( _ STR ) ) > _ NUM ) { signature = signature . substring ( _ NUM , index ) ; } while ( ( index = signature . index Of ( _ STR ) ) > _ NUM ) { signature = signature . substring ( _ NUM , index ) + signature . substring ( index + _ NUM , signature . length ( ) ) ; } return signature ; }
public void create Resource Ticket Async (  String tenant Id ,  Resource Ticket Create Spec resource Ticket Create Spec , final  Future Callback <  Task > response Callback ) throws  IOException {  String path =  String . format ( _ STR , get Base Path ( ) , tenant Id ) ; create Object Async ( path , serialize Object As Json ( resource Ticket Create Spec ) , response Callback ) ; }
public void schedule (  Timer Task task ,  Date when , long period ) { if ( period <= _ NUM || when . get Time ( ) < _ NUM ) { throw new  Illegal Argument Exception ( ) ; } long delay = when . get Time ( ) -  System . current Time Millis ( ) ; schedule Impl ( task , delay < _ NUM ? _ NUM : delay , period , _ BOOL ) ; }
public void ellipse ( double x , double y , double semi Major Axis , double semi Minor Axis ) { if ( semi Major Axis < _ NUM ) throw new  Illegal Argument Exception ( _ STR ) ; if ( semi Minor Axis < _ NUM ) throw new  Illegal Argument Exception ( _ STR ) ; double xs = scale X ( x ) ; double ys = scale Y ( y ) ; double ws = factor X ( _ NUM * semi Major Axis ) ; double hs = factor Y ( _ NUM * semi Minor Axis ) ; if ( ws <= _ NUM && hs <= _ NUM ) pixel ( x , y ) ; else offscreen . draw ( new  Ellipse2 D .  Double ( xs - ws / _ NUM , ys - hs / _ NUM , ws , hs ) ) ; draw ( ) ; }
public void request Cursor ( java . awt .  Cursor cursor ) { if ( cursor == null ) { if ( show Wait Cursor && ! waiting For Layers ) reset Cursor ( ) ; current Map Bean Cursor = null ; } else if ( this . map != null ) {  Cursor new Cursor ; if ( show Wait Cursor && waiting For Layers ) { new Cursor =  Cursor . get Predefined Cursor (  Cursor .  WAIT_ CURSOR ) ; current Map Bean Cursor = cursor ; } else new Cursor = cursor ; map . set Cursor ( new Cursor ) ; } }
public void lock (  K key ) {  Reentrant Lock lock = get Lock ( key ) ; lock . lock ( ) ; }
public static boolean is Primitive Or Wrapper (  Class clazz ) {  Assert . not Null ( clazz , _ STR ) ; return ( clazz . is Primitive ( ) || is Primitive Wrapper ( clazz ) ) ; }
public static  String generate Native Guid (  Compute System device ) { return  String . format ( _ STR , _device Type Map . get ( device . get System Type ( ) ) , device . get Ip Address ( ) , device . get Port Number ( ) ) ; }
public  Writable Raster create Writable Child ( int x , int y , int width , int height , int x0 , int y0 , int [ ] band List ) { if ( x < this . min X ) { throw new  Raster Format Exception ( _ STR ) ; } if ( y < this . min Y ) { throw new  Raster Format Exception ( _ STR ) ; } if ( ( x + width < x ) || ( x + width > this . min X + this . width ) ) { throw new  Raster Format Exception ( _ STR ) ; } if ( ( y + height < y ) || ( y + height > this . min Y + this . height ) ) { throw new  Raster Format Exception ( _ STR ) ; }  Sample Model sm ; if ( band List != null ) sm = sample Model . create Subset Sample Model ( band List ) ; else sm = sample Model ; int delta X = x0 - x ; int delta Y = y0 - y ; return new  Byte Interleaved Raster ( sm , data Buffer , new  Rectangle ( x0 , y0 , width , height ) , new  Point ( sample Model Translate X + delta X , sample Model Translate Y + delta Y ) , this ) ; }
private void show Popup Menu ( final  Mouse Event event ) { final  JCriterium Tree Node selected Node = (  JCriterium Tree Node )  Tree Helpers . get Node At ( this , event . get X ( ) , event . get Y ( ) ) ; if ( selected Node != null ) { final  JPopup Menu menu = selected Node . get Popup Menu ( ) ; if ( menu != null ) { menu . show ( this , event . get X ( ) , event . get Y ( ) ) ; } } }
public static int poisson ( double lambda ) { if ( ! ( lambda > _ NUM ) ) throw new  Illegal Argument Exception ( _ STR ) ; if (  Double . is Infinite ( lambda ) ) throw new  Illegal Argument Exception ( _ STR ) ; int k = _ NUM ; double p = _ NUM ; double  L =  Math . exp ( - lambda ) ; do { k ++ ; p *= uniform ( ) ; } while ( p >=  L ) ; return k - _ NUM ; }
public  String mutate Lang Model ( final  String input ) { if ( input . length ( ) == _ NUM ) { return input ; } int start Point = ( int ) (  Randomness . next Double ( ) * ( input . length ( ) ) ) ; int remaining Length = ( int )  Math . round (  Randomness . next Double ( ) * ( input . length ( ) - start Point ) ) ; if ( remaining Length == _ NUM ) { return input ; }  String output = input . substring ( _ NUM , start Point ) ;  String replacement Chunk = generate Random String From Model With Exact Length ( remaining Length , _ STR + input . char At ( start Point ) ) ; output += replacement Chunk ; output += input . substring ( start Point + remaining Length , input . length ( ) ) ; return output ; }
protected boolean play User Sound (  String sound Identifier ) {  Object sound = builtin Sounds . get ( sound Identifier ) ; if ( sound == null ) { return _ BOOL ; } return _ BOOL ; }
public  Iterator <  String > iterate Resources ( ) { return resources . iterator ( ) ; }
public void add (  Key key ) { if ( key == null ) throw new  Null Pointer Exception ( _ STR ) ; set . add ( key ) ; }
public boolean is Shutdown ( ) { return shutdown . get ( ) ; }
private void initialize Values ( ) { mn Size =  Math . min ( get Measured Height ( ) , get Measured Width ( ) ) ; mn Ring Radius = ( int ) ( mn Size - mn Ring Width ) / _ NUM ; mn Inner Circle Radius = ( int ) ( mn Size - ( mn Ring Width * _ NUM ) ) / _ NUM ; mn View Center = mn Size / _ NUM ; mn Line Width =  STATUS_ SYMBOL_ WIDTH_ PERCENT * mn Size ; }
public static java . util .  Date parse Date Time (  String date ,  String format ,  String locale ,  String time Zone ) {  Simple Date Format date Format = get Date Format ( format , locale , time Zone ) ; try { synchronized ( date Format ) { return date Format . parse ( date ) ; } } catch (  Exception e ) { throw  Db Exception . get (  Error Code .  PARSE_ ERROR_1 , e , date ) ; } }
protected  Key Pair Generator (  String algorithm ) { this . algorithm = algorithm ; }
private void create Gui ( ) { final  JPanel top Panel = new  JPanel ( new  Border Layout ( ) ) ; final  JPanel inner Top Panel = new  JPanel ( new  Border Layout ( ) ) ; top Panel . add ( inner Top Panel ) ; inner Top Panel . add ( m_std Edit Panel ) ; inner Top Panel . add ( m_debugger Panel ,  Border Layout .  SOUTH ) ; final  JPanel button Panel = new  JPanel ( new  Grid Layout ( _ NUM , _ NUM ) ) ; button Panel . set Border ( new  Empty Border ( _ NUM , _ NUM , _ NUM , _ NUM ) ) ; button Panel . add ( new  JPanel ( ) ) ; button Panel . add ( m_save Button ) ; top Panel . add ( button Panel ,  Border Layout .  SOUTH ) ; final  JPanel inner Sp = new  JPanel ( new  Border Layout ( ) ) ; m_middle Panel . set Preferred Size ( new  Dimension ( m_middle Panel . get Preferred Size ( ) . width , _ NUM ) ) ; inner Sp . add ( m_middle Panel ,  Border Layout .  NORTH ) ; inner Sp . add ( m_bottom Panel ,  Border Layout .  CENTER ) ; final  JSplit Pane outer Sp = new  JSplit Pane (  JSplit Pane .  VERTICAL_ SPLIT , _ BOOL , top Panel , inner Sp ) ; outer Sp . set One Touch Expandable ( _ BOOL ) ; outer Sp . set Divider Location ( outer Sp . get Minimum Divider Location ( ) ) ; outer Sp . set Resize Weight ( _ NUM ) ; final  JPanel inner Panel = new  JPanel ( new  Border Layout ( ) ) ; inner Panel . add ( outer Sp ) ; add ( inner Panel ) ; }
protected final  IMocks Control create Mock Control ( ) {  IMocks Control mock Control =  Easy Mock . create Control ( ) ; assert True ( _ STR , mock Controls . add ( mock Control ) ) ; return mock Control ; }
public  Http Request content Length ( final  String content Length ) { return content Length (  Integer . parse Int ( content Length ) ) ; }
public void add Response (  Response response ) { response Vector . add Element ( response ) ; }
public synchronized void test ( ) { if ( enabled ) { for (  String stream : streams ) { stream Status ( api . get Stream Info ( stream , null ) ) ; } } }
void remove View (  View view ) { int index = m Callback . index Of Child ( view ) ; if ( index < _ NUM ) { return ; } m Callback . remove View At ( index ) ; if ( m Bucket . remove ( index ) ) { m Hidden Views . remove ( view ) ; } if (  DEBUG ) {  Log . d (  TAG , _ STR + index + _ STR + this ) ; } }
public static  String double Array To String ( double [ ] value ) { if ( value == null ) { return ( _ STR ) ; } if ( value . length == _ NUM ) { return ( _ STR ) ; }  String Builder sb = new  String Builder ( ) ; sb . append ( value [ _ NUM ] ) ; for ( int i = _ NUM ; i < value . length ; ++ i ) { sb . append ( _ STR + value [ i ] ) ; } return ( sb . to String ( ) ) ; }
private void serialize Test Summary (  KXml Serializer serializer ) throws  IOException { serializer . start Tag ( ns ,  SUMMARY_ TAG ) ; serializer . attribute ( ns ,  HAS_ CRASH_ ATTR , get Has Crash ( ) ) ; serializer . attribute ( ns ,  CRASH_ FILE_ ATTR , get Crash File ( ) ) ; serializer . attribute ( ns ,  DURATION_ ATTR , get Duration ( ) ) ; serializer . attribute (  Cts Xml Result Reporter . ns ,  RESULT_ ATTR , get Result ( ) ) ; serializer . end Tag ( ns ,  SUMMARY_ TAG ) ; }
@  Override public boolean is Component Enabled (  Resolve Info resolve Info ) { if ( resolve Info != null && resolve Info . service Info != null && !  Text Utils . is Empty ( resolve Info . service Info . package Name ) ) { if ( m Permitted Package Names == null || is System App ( resolve Info . service Info . application Info ) ) { return _ BOOL ; } else { return m Permitted Package Names . contains ( resolve Info . service Info . package Name ) ; } } return _ BOOL ; }
public static void close EL (  Transport t ) { try { if ( t != null && t . is Connected ( ) ) t . close ( ) ; } catch (  Throwable e ) { } }
static  String base64encode ( byte [ ] bytes ) {  String Builder builder = new  String Builder ( ( ( bytes . length + _ NUM ) / _ NUM ) * _ NUM ) ; for ( int i = _ NUM ; i < bytes . length ; i += _ NUM ) { byte b0 = bytes [ i ] ; byte b1 = i < bytes . length - _ NUM ? bytes [ i + _ NUM ] : _ NUM ; byte b2 = i < bytes . length - _ NUM ? bytes [ i + _ NUM ] : _ NUM ; builder . append (  BASE64_ CHARS [ ( b0 & _ NUM ) > > _ NUM ] ) ; builder . append (  BASE64_ CHARS [ ( ( b0 & _ NUM ) << _ NUM ) | ( ( b1 & _ NUM ) > > _ NUM ) ] ) ; builder . append ( i < bytes . length - _ NUM ?  BASE64_ CHARS [ ( ( b1 & _ NUM ) << _ NUM ) | ( ( b2 & _ NUM ) > > _ NUM ) ] : _ STR ) ; builder . append ( i < bytes . length - _ NUM ?  BASE64_ CHARS [ b2 & _ NUM ] : _ STR ) ; } return builder . to String ( ) ; }
@  Override protected final boolean write Data (  Byte Buffer data ) { synchronized ( guard ) {  Ls Server Packet packet = send Msg Queue . poll First ( ) ; if ( packet == null ) { return _ BOOL ; } packet . write ( this , data ) ; return _ BOOL ; } }
public boolean generate (  Projection proj ) { if ( ! update Image For Projection ( proj ) ) { if ( get Need To Reposition ( ) ) { position ( proj ) ; set Shape ( ) ; } else { set Shape ( ) ; set Need To Regenerate ( _ BOOL ) ; return _ BOOL ; } } set Shape ( null ) ; if ( ! position ( proj ) ) { if (  DEBUG ) { logger . fine ( _ STR ) ; } return _ BOOL ; } if ( color Model !=  COLORMODEL_ IMAGEICON ) { if ( bitmap == null || get Need To Regenerate ( ) ) { if (  DEBUG ) { logger . fine ( _ STR ) ; } super . generate ( proj ) ; set Image ( bitmap ) ; pixels = null ; bits = null ; } } scale To ( proj ) ; if ( bitmap != null ) { if ( corners == null ) {  General Path projected Shape = create Box Shape ( point1 . x , point1 . y , point2 . x - point1 . x , point2 . y - point1 . y ) ; int w = bitmap . get Width ( this ) ; int h = bitmap . get Height ( this ) ; double anchor X = point1 . x + w / _ NUM ; double anchor Y = point1 . y + h / _ NUM ; set Shape ( adjust Shape For Rotation ( projected Shape , anchor X , anchor Y ) ) ; } else { int num Rects = corners . size ( ) ;  General Path projected Shape = null ; for ( int i = _ NUM ; i < num Rects ; i += _ NUM ) {  General Path gp = create Shape ( corners . get ( i ) , corners . get ( i + _ NUM ) , _ BOOL ) ; projected Shape = append Shape Edge ( projected Shape , gp , _ BOOL ) ; } if ( projected Shape != null ) {  Rectangle rect = projected Shape . get Bounds ( ) ; double anchor X = rect . get X ( ) + rect . get Width ( ) / _ NUM ; double anchor Y = rect . get Y ( ) + rect . get Height ( ) / _ NUM ; projected Shape = adjust Shape For Rotation ( projected Shape , anchor X , anchor Y ) ; } set Shape ( projected Shape ) ; } set Label Location ( get Shape ( ) , proj ) ; set Need To Regenerate ( _ BOOL ) ; } else { has Label = _ BOOL ; } return _ BOOL ; }
@  Override public boolean contains (  Object object ) { if ( object == null ) { return _ BOOL ; } for ( int i = _ NUM ; i < size ; i ++ ) { if ( object . equals ( elements [ i ] ) ) { return _ BOOL ; } } return _ BOOL ; }
public java . lang .  String Buffer insert ( int offset , boolean b ) { internal . insert ( offset , b ) ; return this ; }
public void test Virtual Destinations Dinamically Included Behavior1 ( ) throws  Exception { start All Brokers ( ) ;  Destination dest = create Destination ( _ STR , _ BOOL ) ;  Message Consumer client B1 = create Consumer ( _ STR , dest ) ;  Message Consumer client B2 = create Consumer ( _ STR , create Destination ( _ STR , _ BOOL ) ) ;  Thread . sleep ( _ NUM * _ NUM ) ; int message Count =  MESSAGE_ COUNT ; send Messages ( _ STR , dest , message Count ) ;  Message Id List msgs B1 = get Consumer Messages ( _ STR , client B1 ) ; msgs B1 . wait For Messages To Arrive ( message Count ) ; assert Equals ( message Count , msgs B1 . get Message Count ( ) ) ;  Message Id List msgs B2 = get Consumer Messages ( _ STR , client B2 ) ; msgs B2 . wait For Messages To Arrive ( message Count ) ; assert Equals ( message Count , msgs B2 . get Message Count ( ) ) ; }
public static  Event convert To Event (  Recordable Event event ) {  Event db Event = new  Event ( ) ; db Event . set Time In Millis ( event . get Timestamp ( ) ) ; db Event . set Event Type ( event . get Type ( ) ) ; db Event . set Tenant Id ( event . get Tenant Id ( ) ) ; db Event . set Project Id ( event . get Project Id ( ) ) ; db Event . set User Id ( event . get User Id ( ) ) ; db Event . set Virtual Pool ( event . get Virtual Pool ( ) ) ; db Event . set Service ( event . get Service ( ) ) ; db Event . set Resource Id ( event . get Resource Id ( ) ) ; db Event . set Severity ( event . get Severity ( ) ) ; db Event . set Description ( event . get Description ( ) ) ; db Event . set Extensions ( event . get Extensions ( ) ) ; db Event . set Event Id ( event . get Event Id ( ) ) ; db Event . set Alert Type ( event . get Alert Type ( ) ) ; db Event . set Record Type ( event . get Record Type ( ) ) ; db Event . set Native Guid ( event . get Native Guid ( ) ) ; db Event . set Operational Status Codes ( event . get Operational Status Codes ( ) ) ; db Event . set Operational Status Descriptions ( event . get Operational Status Descriptions ( ) ) ; db Event . set Event Source ( event . get Source ( ) ) ; return db Event ; }
protected void on Mouse Click ( ) { if ( on Mouse Click != null ) { on Mouse Click . run ( ) ; } }
public void init All Day Heights ( ) { if ( m Max Allday Events <= m Max Unexpanded Allday Event Count ) { return ; } if ( m Show All All Day Events ) { int max ADHeight = m View Height -  DAY_ HEADER_ HEIGHT -  MIN_ HOURS_ HEIGHT ; max ADHeight =  Math . min ( max ADHeight , ( int ) ( m Max Allday Events *  MIN_ UNEXPANDED_ ALLDAY_ EVENT_ HEIGHT ) ) ; m Animate Day Event Height = max ADHeight / m Max Allday Events ; } else { m Animate Day Event Height = ( int )  MIN_ UNEXPANDED_ ALLDAY_ EVENT_ HEIGHT ; } }
public  List <  Igfs File Affinity Range > ranges ( ) { if ( ranges == null ) return  Collections . empty List ( ) ; return  Collections . unmodifiable List ( ranges ) ; }
public boolean show Next Notification ( ) { int i = get Selected Index ( ) ; if ( i != - _ NUM && i < get Notfication Count ( ) - _ NUM ) { model . set Selected Item ( model . get Element At ( i + _ NUM ) ) ; return _ BOOL ; } return _ BOOL ; }
@  Override public void write External (  Object Output out ) throws  IOException { out . write Int ( id ) ; }
public void add Input Node (  BNode input Node ) { if ( input Node == this ) { log . warning ( _ STR + node Id ) ; } if ( contains Cycles ( input Node ) ) { log . warning ( _ STR + input Node . get Id ( ) + _ STR + node Id ) ; } if ( this instanceof  Action Node ) { log . warning ( _ STR ) ; } if ( input Node instanceof  Utility Node ) { log . warning ( _ STR + input Node . get Id ( ) + _ STR + node Id + _ STR ) ; } add Input Node_internal ( input Node ) ; input Node . add Output Node_internal ( this ) ; }
public static  CConnection connect ( final  CDatabase Configuration configuration ) throws  Couldnt Load Driver Exception ,  Couldnt Connect Exception { check Driver ( configuration ) ; try { return new  CConnection ( configuration ) ; } catch ( final  SQLException e ) {  CUtility Functions . log Exception ( e ) ; throw new  Couldnt Connect Exception ( e , e . get Error Code ( ) , e . get SQLState ( ) ) ; } }
public  Set <  String > show Zone Names For Pwwn (  String pwwn ,  Integer vsan Id , boolean active Only ) throws  Network Device Controller Exception {  Set <  String > zone Names =  Sets . new Hash Set ( ) ;  SSHPrompt [ ] prompts = {  SSHPrompt .  POUND ,  SSHPrompt .  GREATER_ THAN } ;  String Builder buf = new  String Builder ( ) ;  String cmd Key = active Only ? _ STR : _ STR ;  String payload =  Message Format . format (  MDSDialog Properties . get String ( cmd Key ) , pwwn , vsan Id . to String ( ) ) ; send Wait For ( payload , default Timeout , prompts , buf ) ;  String [ ] lines = get Lines ( buf ) ;  String [ ] regex = {  MDSDialog Properties . get String ( _ STR ) } ;  String [ ] groups = new  String [ _ NUM ] ; for (  String line : lines ) { int index = match ( line , regex , groups ) ; switch ( index ) { case _ NUM : zone Names . add ( groups [ _ NUM ] ) ; break ; } } return zone Names ; }
public static  Transaction Parameter Buffer process Mapping (  String mapping ) throws  FBResource Exception {  Transaction Parameter Buffer result = new  Transaction Parameter Buffer Impl ( ) ;  String Tokenizer st = new  String Tokenizer ( mapping , _ STR ) ; while ( st . has More Tokens ( ) ) {  String token = st . next Token ( ) ;  Integer arg Value = null ; if ( token . contains ( _ STR ) ) {  String [ ] parts = token . split ( _ STR ) ; try { arg Value =  Integer . value Of ( parts [ _ NUM ] ) ; } catch (  Number Format Exception ex ) { throw new  FBResource Exception ( parts [ _ NUM ] + _ STR ) ; } token = parts [ _ NUM ] ; }  Integer value =  Parameter Buffer Helper . get Tpb Param ( token ) ; if ( value == null ) { throw new  FBResource Exception ( _ STR + token + _ STR ) ; } if ( arg Value == null ) { result . add Argument ( value ) ; } else { result . add Argument ( value , arg Value ) ; } } return result ; }
private void update Adapter Items ( ) {  Section Info last Section Info = null ;  String last Section Name = null ;  Fast Scroll Section Info last Fast Scroller Section Info = null ; int position = _ NUM ; int app Index = _ NUM ; m Filtered Apps . clear ( ) ; m Fast Scroller Sections . clear ( ) ; m Adapter Items . clear ( ) ; m Sections . clear ( ) ; if (  DEBUG_ PREDICTIONS ) { if ( m Predicted App Components . is Empty ( ) && ! m Apps . is Empty ( ) ) { m Predicted App Components . add ( new  Component Key ( m Apps . get ( _ NUM ) . component Name ,  User Handle Compat . my User Handle ( ) ) ) ; m Predicted App Components . add ( new  Component Key ( m Apps . get ( _ NUM ) . component Name ,  User Handle Compat . my User Handle ( ) ) ) ; m Predicted App Components . add ( new  Component Key ( m Apps . get ( _ NUM ) . component Name ,  User Handle Compat . my User Handle ( ) ) ) ; m Predicted App Components . add ( new  Component Key ( m Apps . get ( _ NUM ) . component Name ,  User Handle Compat . my User Handle ( ) ) ) ; } } m Predicted Apps . clear ( ) ; if ( m Predicted App Components != null && ! m Predicted App Components . is Empty ( ) && ! has Filter ( ) ) { for (  Component Key ck : m Predicted App Components ) {  App Info info = m Component To App Map . get ( ck ) ; if ( info != null ) { m Predicted Apps . add ( info ) ; } else { if (  Launcher App State . is Dogfood Build ( ) ) {  Log . e (  TAG , _ STR + ck . flatten To String ( m Launcher ) ) ; } } if ( m Predicted Apps . size ( ) == m Num Predicted Apps Per Row ) { break ; } } if ( ! m Predicted Apps . is Empty ( ) ) { last Section Info = new  Section Info ( ) ; last Fast Scroller Section Info = new  Fast Scroll Section Info ( _ STR ) ;  Adapter Item section Item =  Adapter Item . as Section Break ( position ++ , last Section Info ) ; m Sections . add ( last Section Info ) ; m Fast Scroller Sections . add ( last Fast Scroller Section Info ) ; m Adapter Items . add ( section Item ) ; for (  App Info info : m Predicted Apps ) {  Adapter Item app Item =  Adapter Item . as Predicted App ( position ++ , last Section Info , _ STR , last Section Info . num Apps ++ , info , app Index ++ ) ; if ( last Section Info . first App Item == null ) { last Section Info . first App Item = app Item ; last Fast Scroller Section Info . fast Scroll To Item = app Item ; } m Adapter Items . add ( app Item ) ; m Filtered Apps . add ( info ) ; } } } for (  App Info info : get Filters App Infos ( ) ) {  String section Name = get And Update Cached Section Name ( info . title ) ; if ( last Section Info == null || ! section Name . equals ( last Section Name ) ) { last Section Name = section Name ; last Section Info = new  Section Info ( ) ; last Fast Scroller Section Info = new  Fast Scroll Section Info ( section Name ) ; m Sections . add ( last Section Info ) ; m Fast Scroller Sections . add ( last Fast Scroller Section Info ) ; if ( ! has Filter ( ) ) {  Adapter Item section Item =  Adapter Item . as Section Break ( position ++ , last Section Info ) ; m Adapter Items . add ( section Item ) ; } }  Adapter Item app Item =  Adapter Item . as App ( position ++ , last Section Info , section Name , last Section Info . num Apps ++ , info , app Index ++ ) ; if ( last Section Info . first App Item == null ) { last Section Info . first App Item = app Item ; last Fast Scroller Section Info . fast Scroll To Item = app Item ; } m Adapter Items . add ( app Item ) ; m Filtered Apps . add ( info ) ; } if ( has Filter ( ) ) { if ( has No Filtered Results ( ) ) { m Adapter Items . add (  Adapter Item . as Empty Search ( position ++ ) ) ; } else { m Adapter Items . add (  Adapter Item . as Divider ( position ++ ) ) ; } m Adapter Items . add (  Adapter Item . as Market Search ( position ++ ) ) ; } merge Sections ( ) ; if ( m Num Apps Per Row != _ NUM ) { int num Apps In Section = _ NUM ; int num Apps In Row = _ NUM ; int row Index = - _ NUM ; for (  Adapter Item item : m Adapter Items ) { item . row Index = _ NUM ; if ( item . view Type ==  All Apps Grid Adapter .  SECTION_ BREAK_ VIEW_ TYPE ) { num Apps In Section = _ NUM ; } else if ( item . view Type ==  All Apps Grid Adapter .  ICON_ VIEW_ TYPE || item . view Type ==  All Apps Grid Adapter .  PREDICTION_ ICON_ VIEW_ TYPE ) { if ( num Apps In Section % m Num Apps Per Row == _ NUM ) { num Apps In Row = _ NUM ; row Index ++ ; } item . row Index = row Index ; item . row App Index = num Apps In Row ; num Apps In Section ++ ; num Apps In Row ++ ; } } m Num App Rows In Adapter = row Index + _ NUM ; switch ( m Fast Scroll Distribution Mode ) { case  FAST_ SCROLL_ FRACTION_ DISTRIBUTE_ BY_ ROWS_ FRACTION : float row Fraction = _ NUM / m Num App Rows In Adapter ; for (  Fast Scroll Section Info info : m Fast Scroller Sections ) {  Adapter Item item = info . fast Scroll To Item ; if ( item . view Type !=  All Apps Grid Adapter .  ICON_ VIEW_ TYPE && item . view Type !=  All Apps Grid Adapter .  PREDICTION_ ICON_ VIEW_ TYPE ) { info . touch Fraction = _ NUM ; continue ; } float sub Row Fraction = item . row App Index * ( row Fraction / m Num Apps Per Row ) ; info . touch Fraction = item . row Index * row Fraction + sub Row Fraction ; } break ; case  FAST_ SCROLL_ FRACTION_ DISTRIBUTE_ BY_ NUM_ SECTIONS : float per Section Touch Fraction = _ NUM / m Fast Scroller Sections . size ( ) ; float cumulative Touch Fraction = _ NUM ; for (  Fast Scroll Section Info info : m Fast Scroller Sections ) {  Adapter Item item = info . fast Scroll To Item ; if ( item . view Type !=  All Apps Grid Adapter .  ICON_ VIEW_ TYPE && item . view Type !=  All Apps Grid Adapter .  PREDICTION_ ICON_ VIEW_ TYPE ) { info . touch Fraction = _ NUM ; continue ; } info . touch Fraction = cumulative Touch Fraction ; cumulative Touch Fraction += per Section Touch Fraction ; } break ; } } if ( m Adapter != null ) { m Adapter . notify Data Set Changed ( ) ; } }
public void test File File ( ) throws  Exception {  Properties properties = load Properties ( _ STR ) ; assert Equals ( _ STR , properties . get Property ( _ STR ) ) ; }
public void assign Service (  String universal Id ,  String service Name ,  Map values ) throws  AMConsole Exception { try {  String [ ] params = { universal Id , service Name } ; log Event ( _ STR , params ) ;  AMIdentity amid =  Id Utils . get Identity ( get User SSOToken ( ) , universal Id ) ; amid . assign Service ( service Name , values ) ; log Event ( _ STR , params ) ; } catch (  SSOException e ) {  String [ ] params Ex = { universal Id , service Name , get Error String ( e ) } ; log Event ( _ STR , params Ex ) ; debug . warning ( _ STR , e ) ; throw new  AMConsole Exception ( get Error String ( e ) ) ; } catch (  Id Repo Exception e ) { debug . error ( _ STR , e ) ;  String [ ] params Ex = { universal Id , service Name , get Error String ( e ) } ; log Event ( _ STR , params Ex ) ; debug . warning ( _ STR , e ) ; throw new  AMConsole Exception ( get Error String ( e ) ) ; } }
private static  Address  Get Int Array Elements (  JNIEnvironment env , int array JREF ,  Address is Copy Address ) { if ( trace JNI )  VM . sys Write ( _ STR ) ;  Runtime Entrypoints . check JNICount Down To GC ( ) ; try { int [ ] source Array = ( int [ ] ) env . get JNIRef ( array JREF ) ; int size = source Array . length ; if (  Memory Manager . will Never Move ( source Array ) ) {  JNIGeneric Helpers . set Bool Star ( is Copy Address , _ BOOL ) ; return  Magic . object As Address ( source Array ) ; } else {  Address copy Buffer = sys Call . sys Malloc ( size <<  LOG_ BYTES_ IN_ INT ) ; if ( copy Buffer . is Zero ( ) ) { env . record Exception ( new  Out Of Memory Error ( ) ) ; return  Address . zero ( ) ; }  Memory . memcopy ( copy Buffer ,  Magic . object As Address ( source Array ) , size <<  LOG_ BYTES_ IN_ INT ) ;  JNIGeneric Helpers . set Bool Star ( is Copy Address , _ BOOL ) ; return copy Buffer ; } } catch (  Throwable unexpected ) { if ( trace JNI ) unexpected . print Stack Trace (  System . err ) ; env . record Exception ( unexpected ) ; return  Address . zero ( ) ; } }
public  String preview Next Char ( ) { if ( position < text . length ( ) ) { return text . substring ( position , position + _ NUM ) ; } else if ( position == text . length ( ) ) { return text . substring ( _ NUM , _ NUM ) ; } return _ STR ; }
private void prepare Transfers ( ) throws  Lib Usb Exception { if ( m Available Transfers == null ) { m Available Transfers = new  Linked Transfer Queue < > ( ) ; for ( int x = _ NUM ; x <  TRANSFER_ BUFFER_ POOL_ SIZE ; x ++ ) {  Transfer transfer =  Lib Usb . alloc Transfer ( ) ; if ( transfer == null ) { throw new  Lib Usb Exception ( _ STR ,  Lib Usb .  ERROR_ NO_ MEM ) ; } final  Byte Buffer buffer =  Byte Buffer . allocate Direct ( m Buffer Size ) ;  Lib Usb . fill Bulk Transfer ( transfer , m Device Handle ,  USB_ BULK_ ENDPOINT , buffer ,  Buffer Processor . this , _ STR ,  TIMEOUT_ US ) ; m Available Transfers . add ( transfer ) ; } } }
private  String compute ( double left ,  String right , boolean is Integer ) { if (  Double . is Na N ( left ) && right == null ) { return null ; } if ( is Integer && left == ( int ) left ) { return ( int ) left + ( right == null ? _ STR : right ) ; } else if (  Double . is Infinite ( left ) ) { return  Tools . format Number ( left ) + ( right == null ? _ STR : right ) ; } else { return (  Double . is Na N ( left ) ? _ STR : left ) + ( right == null ? _ STR : right ) ; } }
public  Map <  String ,  Object > finalize Order Entry Payment (  String check Out Payment Id ,  Big Decimal amount , boolean single Use , boolean append ) {  Map <  String ,  Object > result =  Service Util . return Success ( ) ; if (  Util Validate . is Not Empty ( check Out Payment Id ) ) { if ( ! append ) { cart . clear Payments ( ) ; } cart . add Payment Amount ( check Out Payment Id , amount , single Use ) ; } return result ; }
public void remove Text ( ) { if ( _ NUM < texts . size ( ) ) { texts . remove ( texts . size ( ) - _ NUM ) ; invalidate ( ) ; } }
public  Builder delete Name ( ) { delete Fields . add ( _ STR ) ; return this ; }
private void init (  Matrix matrix ) { for ( int i = _ NUM ; i < _ NUM ; i ++ ) { for ( int j = _ NUM ; j < _ NUM ; j ++ ) { matrix . create Entry (  Integer . to String ( i ) ,  Integer . to String ( j ) , _ NUM ) ; } } }
public void end Statement ( ) { for (  Transaction Lifecycle Listener l : lifecycle Listeners ) l . on Tx End Statement ( this ) ; }
long resize Lun ( long size , boolean force ) {  Na Element elem = new  Na Element ( _ STR ) ; elem . add New Child ( _ STR ,  Boolean . to String ( force ) ) ; elem . add New Child ( _ STR , path ) ; elem . add New Child ( _ STR ,  Long . to String ( size ) ) ;  Na Element result = null ; try { result = server . invoke Elem ( elem ) ; return result . get Child Long Value ( _ STR , - _ NUM ) ; } catch (  Exception e ) {  String msg = _ STR + path ; log . error ( msg , e ) ; throw new  Net App Exception ( msg , e ) ; } }
protected boolean should Auto Store State ( ) { return _ BOOL ; }
public final  Bytes Ref bytes ( ) { return bytes ; }
public static  String now (  String date Format ) {  Calendar cal =  Calendar . get Instance ( ) ;  Simple Date Format sdf = new  Simple Date Format ( date Format ) ; return sdf . format ( cal . get Time ( ) ) ; }
protected abstract int main Exec (  Output Stream out ,  Log Stream log ) throws  IOException ;
private  String Buffer prepare Optimized Delete Statement (  One Row Change one Row Change ,  String key Name ) {  String Buffer stmt = new  String Buffer ( ) ; stmt . append ( _ STR ) ; stmt . append ( conn . get Database Object Name ( one Row Change . get Schema Name ( ) ) + _ STR + conn . get Database Object Name ( one Row Change . get Table Name ( ) ) ) ; stmt . append ( _ STR ) ; stmt . append ( conn . get Database Object Name ( key Name ) ) ; stmt . append ( _ STR ) ;  Array List <  Array List <  Column Val > > values = one Row Change . get Key Values ( ) ;  Array List <  Column Spec > key Spec = one Row Change . get Key Spec ( ) ; boolean first Row = _ BOOL ; for (  Array List <  Column Val > one Key Values : values ) { if ( first Row ) first Row = _ BOOL ; else stmt . append ( _ STR ) ; print Column Spec ( stmt , key Spec , null , one Key Values ,  Print Mode .  PLACE_ HOLDER , _ STR ) ; } stmt . append ( _ STR ) ; return stmt ; }
private boolean ends With Separator (  String path ) { return path . ends With ( _ STR ) || path . ends With ( _ STR ) ; }
public synchronized void remove OFChannel Handler (  OFChannel Handler h ) { connected Channel Handlers . remove ( h ) ; }
protected void connection Established (  Channel connected Channel ) {  LOG . info ( _ STR , connected Channel ) ; channel = connected Channel ; connected . set ( _ BOOL ) ; }
public void add Arg If Absent ( final  BOp arg ) { if ( arg == null ) throw new  Illegal Argument Exception ( ) ; if ( arg == this ) throw new  Illegal Argument Exception ( ) ; if ( ! args . contains ( arg ) ) { add Arg ( arg ) ; } }
public void register Text Flavor Properties (  String nat ,  String charset ,  String eoln ,  String terminators ) {  Long format = get Format For Native As Long ( nat ) ; text Natives . add ( format ) ; native Charsets . put ( format , ( charset != null && charset . length ( ) != _ NUM ) ? charset : get Default Text Charset ( ) ) ; if ( eoln != null && eoln . length ( ) != _ NUM && ! eoln . equals ( _ STR ) ) { native EOLNs . put ( format , eoln ) ; } if ( terminators != null && terminators . length ( ) != _ NUM ) {  Integer i Terminators =  Integer . value Of ( terminators ) ; if ( i Terminators . int Value ( ) > _ NUM ) { native Terminators . put ( format , i Terminators ) ; } } }
public void push (  Namespace namespace ) { namespace Stack . add ( namespace ) ; namespace Cache List . add ( null ) ; current Namespace Cache = null ;  String prefix = namespace . get Prefix ( ) ; if ( ( prefix == null ) || ( prefix . length ( ) == _ NUM ) ) { default Namespace = namespace ; } }
private double [ ] [ ]  Calc Constant Coef (  Variogram variogarm ,  List <  Kriging Point >  NNPoints ) { int n =  NNPoints . size ( ) ; double [ ] [ ] mat = new double [ n + _ NUM ] [ n + _ NUM ] ; double dist = _ NUM ; for ( int i = _ NUM ; i < n ; i ++ ) { for ( int j = i ; j < n ; j ++ ) { dist =  Math . sqrt (  Math . abs (  Math . pow (  NNPoints . get ( i ) . x -  NNPoints . get ( j ) . x , _ NUM ) ) +  Math . abs (  Math . pow (  NNPoints . get ( i ) . y -  NNPoints . get ( j ) . y , _ NUM ) ) ) ; mat [ i ] [ j ] = get Theoretical SVValue ( dist , variogarm ) ; mat [ j ] [ i ] = mat [ i ] [ j ] ; } } for ( int i = _ NUM ; i < n ; i ++ ) { mat [ i ] [ n ] = _ NUM ; mat [ n ] [ i ] = _ NUM ; } return mat ; }
public static  Object deserialization (  String file Path ) {  Object Input Stream in = null ; try { in = new  Object Input Stream ( new  File Input Stream ( file Path ) ) ;  Object o = in . read Object ( ) ; in . close ( ) ; return o ; } catch (  File Not Found Exception e ) { throw new  Runtime Exception ( _ STR , e ) ; } catch (  Class Not Found Exception e ) { throw new  Runtime Exception ( _ STR , e ) ; } catch (  IOException e ) { throw new  Runtime Exception ( _ STR , e ) ; } finally {  IOUtil . close ( in ) ; } }
public  String finished (  Logger log ) { if ( m_av Insts Per Sec == _ NUM ) { compute Update (  System . current Time Millis ( ) ) ; } int n S = m_num Samples > _ NUM ? m_num Samples : _ NUM ;  String msg = _ STR + m_instance Count + _ STR + m_av Insts Per Sec / n S + _ STR ; if ( log != null ) { log . status Message ( m_status Message Prefix + msg ) ; } return msg ; }
public void include ( final  Path Matcher matcher ) { include Matchers . add ( matcher ) ; }
public  Array List <  Mech Summary > generate Units ( int num ) { return generate Units ( num , null ) ; }
public static  Automaton union (  Automaton a1 ,  Automaton a2 ) { return union (  Arrays . as List ( a1 , a2 ) ) ; }
public void column Selection Changed (  List Selection Event e ) { if ( e . get Value Is Adjusting ( ) ) { return ; }  List Selection Model selection Model = (  List Selection Model ) e . get Source ( ) ;  Data Set data Set = get Data Set ( ) ; data Set . clear Selection ( ) ; if ( ! get Row Selection Allowed ( ) ) { for ( int i = _ NUM ; i < data Set . get Num Columns ( ) ; i ++ ) { if ( selection Model . is Selected Index ( i + _ NUM ) ) { data Set . set Selected ( data Set . get Variable ( i ) , _ BOOL ) ; } } } }
public  Instances resample (  Random random ) {  Instances new Data = new  Instances ( this , num Instances ( ) ) ; while ( new Data . num Instances ( ) < num Instances ( ) ) { new Data . add ( instance ( random . next Int ( num Instances ( ) ) ) ) ; } return new Data ; }
public static  String extract File Set From Path (  String resource ) {  String [ ] splits = resource . split ( _ STR ) ; if ( splits . length <= _ NUM ) {  Stats . incr ( _ STR ) ; return null ; } return splits [ splits . length - _ NUM ] ; }
private void read Object (  Object Input Stream oos ) throws  IOException ,  Class Not Found Exception { i Instant = (  Local Date ) oos . read Object ( ) ;  Date Time Field Type type = (  Date Time Field Type ) oos . read Object ( ) ; i Field = type . get Field ( i Instant . get Chronology ( ) ) ; }
private boolean is Message From User (  Message message ,  User user ) {  String user Id = null ; boolean is My Message = _ BOOL ; if ( message . user != null && message . user . user ID != null ) { user Id = message . user . user ID ; } else { user Id = message . user ID ; } if ( user Id . equals ( user . user ID ) ) { is My Message = _ BOOL ; } if ( message . type ==  Const .  Message Type .  TYPE_ NEW_ USER || message . type ==  Const .  Message Type .  TYPE_ USER_ LEAVE ) { is My Message = _ BOOL ; } return is My Message ; }
public boolean read Bool ( ) throws  IOException { return dis . read Byte ( ) > _ NUM ; }
private byte [ ] generate Derived Key ( int id Byte , int n ) { byte [ ]  D = new byte [ v ] ; byte [ ] d Key = new byte [ n ] ; for ( int i = _ NUM ; i !=  D . length ; i ++ ) {  D [ i ] = ( byte ) id Byte ; } byte [ ]  S ; if ( ( salt != null ) && ( salt . length != _ NUM ) ) {  S = new byte [ v * ( ( salt . length + v - _ NUM ) / v ) ] ; for ( int i = _ NUM ; i !=  S . length ; i ++ ) {  S [ i ] = salt [ i % salt . length ] ; } } else {  S = new byte [ _ NUM ] ; } byte [ ]  P ; if ( ( password != null ) && ( password . length != _ NUM ) ) {  P = new byte [ v * ( ( password . length + v - _ NUM ) / v ) ] ; for ( int i = _ NUM ; i !=  P . length ; i ++ ) {  P [ i ] = password [ i % password . length ] ; } } else {  P = new byte [ _ NUM ] ; } byte [ ]  I = new byte [  S . length +  P . length ] ;  System . arraycopy (  S , _ NUM ,  I , _ NUM ,  S . length ) ;  System . arraycopy (  P , _ NUM ,  I ,  S . length ,  P . length ) ; byte [ ]  B = new byte [ v ] ; int c = ( n + u - _ NUM ) / u ; byte [ ]  A = new byte [ u ] ; for ( int i = _ NUM ; i <= c ; i ++ ) { digest . update (  D , _ NUM ,  D . length ) ; digest . update (  I , _ NUM ,  I . length ) ; digest . do Final (  A , _ NUM ) ; for ( int j = _ NUM ; j < iteration Count ; j ++ ) { digest . update (  A , _ NUM ,  A . length ) ; digest . do Final (  A , _ NUM ) ; } for ( int j = _ NUM ; j !=  B . length ; j ++ ) {  B [ j ] =  A [ j %  A . length ] ; } for ( int j = _ NUM ; j !=  I . length / v ; j ++ ) { adjust (  I , j * v ,  B ) ; } if ( i == c ) {  System . arraycopy (  A , _ NUM , d Key , ( i - _ NUM ) * u , d Key . length - ( ( i - _ NUM ) * u ) ) ; } else {  System . arraycopy (  A , _ NUM , d Key , ( i - _ NUM ) * u ,  A . length ) ; } } return d Key ; }
public void add Ignored Emote (  String emote Code ) { ignored Emotes . add ( emote Code ) ; }
public boolean is Function Allowed (  Name name ) { return functions Allowed . contains ( name ) ; }
public  String root ( ) { return root ; }
public void test Constructor Sign Bytes Zero Null3 ( ) { byte a Bytes [ ] = { } ; int a Sign = _ NUM ; byte r Bytes [ ] = { _ NUM } ;  Big Integer a Number = new  Big Integer ( a Sign , a Bytes ) ; byte res Bytes [ ] = new byte [ r Bytes . length ] ; res Bytes = a Number . to Byte Array ( ) ; for ( int i = _ NUM ; i < res Bytes . length ; i ++ ) { assert True ( res Bytes [ i ] == r Bytes [ i ] ) ; } assert Equals ( _ STR , _ NUM , a Number . signum ( ) ) ; }
public  Socket create Socket (  Inet Address address , int port ,  Inet Address my Address , int my Port ) throws  IOException { if ( my Address != null ) {  Socket sock = new  Socket ( ) ; sock . bind ( new  Inet Socket Address ( my Address , _ NUM ) ) ; try { sock . connect ( new  Inet Socket Address ( address , port ) , _ NUM ) ; } catch (  Socket Timeout Exception e ) { throw new  Connect Exception ( _ STR + address + _ STR + port ) ; } return sock ; } else {  Socket sock = new  Socket ( ) ; if ( my Port != _ NUM ) { sock . bind ( new  Inet Socket Address ( port ) ) ; } try { sock . connect ( new  Inet Socket Address ( address , port ) , _ NUM ) ; } catch (  Socket Timeout Exception e ) { throw new  Connect Exception ( _ STR + address + _ STR + port ) ; } return sock ; } }
public  SVGRasterizer (  URL url ) { this . input = new  Transcoder Input ( url . to String ( ) ) ; }
public  Document create Document ( ) { return builder . new Document ( ) ; }
@  HLEUnimplemented @  HLEFunction ( nid = _ NUM , version = _ NUM , check Inside Interrupt = _ BOOL ) public int __sce Sas Set Triangular Wave ( int sas Core , int voice , int unknown ) { check Sas And Voice Handles Good ( sas Core , voice ) ; return _ NUM ; }
public void handle Tbl Request Handler List Href Edit Action Request (  Request Invocation Event event ) throws  Model Control Exception { try {  Map values = get Values ( ) ; on Before Save Profile ( values ) ; set Page Session Attribute (  PROPERTY_ ATTRIBUTE , (  Hash Map ) values ) ;  SCSAML2 SOAPBinding Request Handler List Edit View Bean vb = (  SCSAML2 SOAPBinding Request Handler List Edit View Bean ) get View Bean (  SCSAML2 SOAPBinding Request Handler List Edit View Bean . class ) ; unlock Page Trail ( ) ; pass Pg Session Map ( vb ) ; vb . populate Values ( (  String ) get Display Field Value (  TBL_ REQUEST_ HANDLER_ LIST_ HREF_ EDIT_ ACTION ) ) ; vb . forward To ( get Request Context ( ) ) ; } catch (  AMConsole Exception e ) { set Inline Alert Message (  CCAlert .  TYPE_ ERROR , _ STR , e . get Message ( ) ) ; } }
private static void draw Triangle Up (  Graphics gx , double x , double y , int size ) { gx . draw Line ( ( int ) ( x ) , ( int ) ( y - size ) , ( int ) ( x - size ) , ( int ) ( y + size ) ) ; gx . draw Line ( ( int ) ( x - size ) , ( int ) ( y + size ) , ( int ) ( x + size ) , ( int ) ( y + size ) ) ; gx . draw Line ( ( int ) ( x + size ) , ( int ) ( y + size ) , ( int ) ( x ) , ( int ) ( y - size ) ) ; }
public void write As Serialized Byte Array (  Object v ) throws  IOException { if ( this . ignore Writes ) return ; check If Writable ( ) ; ensure Capacity ( _ NUM ) ; if ( v instanceof  Heap Data Output Stream ) {  Heap Data Output Stream other = (  Heap Data Output Stream ) v ; other . finish Writing ( ) ;  Internal Data Serializer . write Array Length ( other . size ( ) , this ) ; if ( this . do Not Copy ) { if ( other . chunks != null ) { for (  Byte Buffer bb : other . chunks ) { write ( bb ) ; } } write ( other . buffer ) ; } else { other . send To ( (  Byte Buffer Writer ) this ) ; other . rewind ( ) ; } } else {  Byte Buffer size Buf = this . buffer ; int size Pos = size Buf . position ( ) ; size Buf . position ( size Pos + _ NUM ) ; final int pre Array Size = size ( ) ;  Data Serializer . write Object ( v , this ) ; int array Size = size ( ) - pre Array Size ; size Buf . put ( size Pos ,  Internal Data Serializer .  INT_ ARRAY_ LEN ) ; size Buf . put Int ( size Pos + _ NUM , array Size ) ; } }
void init (  List <  Column Meta Data > column Meta Data ) { this . column Meta Data = column Meta Data ; column Roles . clear ( ) ; column Names . clear ( ) ; int column Index = _ NUM ; for (  Column Meta Data column : column Meta Data ) { add Column To Columns Maps ( column Index , column ) ; if ( ! column . is Removed ( ) ) { selected Columns . add ( column Index ) ; } column Index ++ ; } check For Duplicates ( ) ; }
public static  Field find Field (  Object instance ,  String name ) throws  No Such Field Exception { for (  Class < ? > clazz = instance . get Class ( ) ; clazz != null ; clazz = clazz . get Superclass ( ) ) { try {  Field field = clazz . get Declared Field ( name ) ; if ( ! field . is Accessible ( ) ) { field . set Accessible ( _ BOOL ) ; } return field ; } catch (  No Such Field Exception e ) { } } throw new  No Such Field Exception ( _ STR + name + _ STR + instance . get Class ( ) ) ; }
public void dump Threads ( ) { log . info ( get Thread Dump ( ) ) ; }
private static boolean date By Ordinal (  Date Time Formatter Builder bld ,  Collection <  Date Time Field Type > fields , boolean extended , boolean strict ISO ) { boolean reduced Prec = _ BOOL ; if ( fields . remove (  Date Time Field Type . year ( ) ) ) { bld . append (  Constants . ye ) ; if ( fields . remove (  Date Time Field Type . day Of Year ( ) ) ) { append Separator ( bld , extended ) ; bld . append Day Of Year ( _ NUM ) ; } else { reduced Prec = _ BOOL ; } } else if ( fields . remove (  Date Time Field Type . day Of Year ( ) ) ) { bld . append Literal ( _ STR ) ; bld . append Day Of Year ( _ NUM ) ; } return reduced Prec ; }
private  String remove Trailing Period (  String val ) { if ( val . char At ( val . length ( ) - _ NUM ) == _ STR ) { val = val . substring ( _ NUM , val . length ( ) - _ NUM ) ; } return val ; }
public  Page Range add Single Page ( int page Number ) { sequence Starts . add ( page Number ) ; sequence Ends . add ( page Number ) ; return this ; }
public static  List <  Dimensional Item Object > as List (  Collection < ? extends  Dimensional Item Object > collection ) {  List <  Dimensional Item Object > list = new  Array List < > ( ) ; list . add All ( collection ) ; return list ; }
public  Create Index Request aliases (  XContent Builder source ) { return aliases ( source . bytes ( ) ) ; }
private static  Table Info create Table Info (  String table Name ,  Integer page Number , int flags ,  Short type ,  String linked Db Name ,  String linked Table Name ) { if (  TYPE_ LINKED_ TABLE . equals ( type ) ) { return new  Linked Table Info ( page Number , table Name , flags , linked Db Name , linked Table Name ) ; } return new  Table Info ( page Number , table Name , flags ) ; }
public static  String generate ( char [ ] password , byte [ ] salt , int cost ) { if ( password == null ) { throw new  Illegal Argument Exception ( _ STR ) ; } if ( salt == null ) { throw new  Illegal Argument Exception ( _ STR ) ; } else if ( salt . length != _ NUM ) { throw new  Data Length Exception ( _ STR + salt . length ) ; } if ( cost < _ NUM || cost > _ NUM ) { throw new  Illegal Argument Exception ( _ STR ) ; } byte [ ] psw =  Strings . to UTF8 Byte Array ( password ) ; byte [ ] tmp = new byte [ psw . length >= _ NUM ? _ NUM : psw . length + _ NUM ] ; if ( tmp . length > psw . length ) {  System . arraycopy ( psw , _ NUM , tmp , _ NUM , psw . length ) ; } else {  System . arraycopy ( psw , _ NUM , tmp , _ NUM , tmp . length ) ; }  Arrays . fill ( psw , ( byte ) _ NUM ) ;  String rv = create Bcrypt String ( tmp , salt , cost ) ;  Arrays . fill ( tmp , ( byte ) _ NUM ) ; return rv ; }
public void add Listener ( @  Not Null  Configuration Listener listener ) { if ( my Listeners == null ) { my Listeners = new  Array List < > ( ) ; } my Listeners . add ( listener ) ; }
public void do Window Open ( ) { }
public boolean submit No Wake (  Runnable task ,  Class Loader loader ) { boolean is Priority = _ BOOL ; boolean is Queue = _ BOOL ; boolean is Wake = _ BOOL ; return schedule Impl ( task , loader ,  MAX_ EXPIRE , is Priority , is Queue , is Wake ) ; }
public static int hash3 ( int hash ,  Object x ,  Object y ,  Object z ) { return _ NUM | ( hash + _ NUM *  System . identity Hash Code ( x ) + _ NUM *  System . identity Hash Code ( y ) + _ NUM *  System . identity Hash Code ( z ) ) ; }
public static double entropy ( double [ ] vector ) { if ( vector == null ) return _ NUM ; else if ( vector . length < _ NUM ) return _ NUM ; else { double ret = _ NUM ; for ( double d : vector ) ret += d *  Math . log ( d ) ; return ret ; } }
private static <  T >  List <  T > as List (  Set <  T > a ,  Set <  T > b ) { if ( a == null || b == null || a . is Empty ( ) || b . is Empty ( ) ) { return  Collections . <  T > empty List ( ) ; } if ( a . size ( ) < b . size ( ) ) {  List <  T > c = new  Array List <  T > ( a ) ; c . retain All ( b ) ; return c ; } else {  List <  T > c = new  Array List <  T > ( b ) ; c . retain All ( a ) ; return c ; } }
private boolean has Port (  List <  Service Port > ports ,  Service Port port ) { for (  Service Port a Port : ports ) { if (  Objects . equals ( port . get Port ( ) , a Port . get Port ( ) ) ) { return _ BOOL ; } } return _ BOOL ; }
public int read ( ) { if ( position >= document . get Length ( ) ) { return - _ NUM ; } try { document . get Text ( ( int ) position , _ NUM , segment ) ; position ++ ; return segment . array [ segment . offset ] ; } catch (  Bad Location Exception ble ) { ble . print Stack Trace ( ) ; return - _ NUM ; } }
private void adjust Column Widths (  JTable table ) {  Table Column Model model = table . get Column Model ( ) ; for ( int column = _ NUM ; column < table . get Column Count ( ) ; column ++ ) {  Table Column tc = model . get Column ( column ) ; int width = tc . get Width ( ) ; for ( int row = _ NUM ; row < table . get Row Count ( ) ; row ++ ) {  Component comp = table . prepare Renderer ( table . get Cell Renderer ( row , column ) , row , column ) ; width =  Math . max ( width , comp . get Preferred Size ( ) . width ) ; } tc . set Preferred Width ( width ) ; } }
public static  List <  Volume > query Volumes By Iterative Query (  Db Client db Client ,  List <  URI > volume URIs ) {  List <  Volume > volumes = new  Array List <  Volume > ( ) ; @  Suppress Warnings ( _ STR )  Iterator <  Volume > volume Iterator = db Client . query Iterative Objects (  Volume . class , volume URIs ) ; while ( volume Iterator . has Next ( ) ) { volumes . add ( volume Iterator . next ( ) ) ; } return volumes ; }
public static int find Whitespace (  Char Sequence s , int start ) { final int len = s . length ( ) ; for ( int i = start ; i < len ; i ++ ) { if (  Character . is Whitespace ( s . char At ( i ) ) ) { return i ; } } return len ; }
private void disable Index Form ( ) { edit Index Index = - _ NUM ; index Name . set Text ( _ STR ) ; index Type . set Text ( _ STR ) ; selected Columns . remove All ( ) ; index Name . set Enabled ( _ BOOL ) ; index Type . set Enabled ( _ BOOL ) ; selected Columns . set Enabled ( _ BOOL ) ; del Index . set Enabled ( _ BOOL ) ; index Add Button . set Enabled ( _ BOOL ) ; index Remove Button . set Enabled ( _ BOOL ) ; index Up Button . set Enabled ( _ BOOL ) ; index Down Button . set Enabled ( _ BOOL ) ; }
void parse ( ) {  Byte Buffer bb = byte Buffer ; bb . clear ( ) ; size = bb . get Short ( ) ; if ( size > buffer . length ) { throw new  Illegal State Exception ( _ STR + size + _ STR + buffer . length ) ; } bb . limit ( size ) ; type = bb . get ( ) ; from Member Id = bb . get Short ( ) ; term = bb . get Int ( ) ; command Size = _ NUM ; num Commands = _ NUM ; timestamp = _ NUM ; switch ( type ) { case  TYPE_ APPEND_ ENTRY_ REQ : prev Rid . set ( bb . get Int ( ) , bb . get Int ( ) ) ; commit Index = bb . get Int ( ) ; entry Term = bb . get Int ( ) ; is Heartbeat = entry Term == _ NUM ; command Size = bb . get Short ( ) ; buffer Offset = bb . position ( ) ; if ( message Tracing ) { if ( is Heartbeat ) { if ( heartbeat Tracing ) { tracing Info =  String . format ( _ STR , term , prev Rid . term , prev Rid . index , commit Index ) ; } } else { tracing Info =  String . format ( _ STR , term , prev Rid . term , entry Term , prev Rid . index + _ NUM , commit Index , size - overhead [  TYPE_ APPEND_ ENTRY_ REQ ] ) ; } } num Commands = _ NUM ; int s = overhead [  TYPE_ APPEND_ ENTRY_ REQ ] + command Size ; int bo = buffer Offset ; int cs = command Size ; while ( s < size ) { num Commands ++ ; bo += cs ; cs = ( _ NUM & buffer [ bo ] ) << _ NUM | ( _ NUM & buffer [ bo + _ NUM ] ) ; bo += _ NUM ; s += cs + _ NUM ; } break ; case  TYPE_ APPEND_ ENTRY_ REP : mn Index = bb . get Int ( ) ; success = bb . get ( ) == _ NUM ; is Heartbeat = bb . get ( ) == _ NUM ; if ( message Tracing && ( heartbeat Tracing || ! is Heartbeat ) ) { tracing Info =  String . format ( _ STR , is Heartbeat ? _ STR : _ STR , term , success ? _ STR : _ STR , mn Index , success ? _ STR : _ STR ) ; } break ; case  TYPE_ REQUEST_ VOTE_ REQ : is Prevote = bb . get ( ) == _ NUM ; prev Rid . set ( bb . get Int ( ) , bb . get Int ( ) ) ; if ( message Tracing ) { tracing Info =  String . format ( _ STR , term , prev Rid . term , prev Rid . index , is Prevote ? _ STR : _ STR ) ; } break ; case  TYPE_ REQUEST_ VOTE_ REP : is Prevote = bb . get ( ) == _ NUM ; vote Granted = bb . get ( ) == _ NUM ; if ( message Tracing ) { tracing Info =  String . format ( _ STR , term , vote Granted ? _ STR : _ STR , is Prevote ? _ STR : _ STR ) ; } break ; default : throw new  Illegal State Exception ( _ STR + type ) ; } }
public void interrupt ( ) { final  Thread t = thread Var . get ( ) ; if ( t != null ) { t . interrupt ( ) ; while ( t . is Alive ( ) ) { try {  Thread . sleep ( _ NUM ) ; } catch ( final  Interrupted Exception e ) {  Log Writer . write Log ( _ STR + e . get Message ( ) ) ; } } } thread Var . clear ( ) ; }
private  String make Content (  Stream Info info ,  String content ) { content = content . replace ( _ STR , info . get Title ( ) ) ; content = content . replace ( _ STR , info . get Game ( ) ) ; content = content . replace ( _ STR ,  Helper . format Viewer Count ( info . get Viewers ( ) ) ) ; content = content . replace ( _ STR ,  Helper . format Viewer Count ( info . get Follower Count ( ) ) ) ; content = content . replace ( _ STR ,  Helper . format Viewer Count ( info . get Subscriber Count ( ) ) ) ; content = content . replace ( _ STR ,  String . value Of ( info . get Viewers ( ) ) ) ; content = content . replace ( _ STR ,  String . value Of ( info . get Follower Count ( ) ) ) ; content = content . replace ( _ STR ,  String . value Of ( info . get Subscriber Count ( ) ) ) ; return content ; }
private int read Int (  Input Stream is ) throws  IOException { return ( ( is . read ( ) << _ NUM ) | ( is . read ( ) << _ NUM ) | ( is . read ( ) << _ NUM ) | ( is . read ( ) ) ) ; }
@  Suppress Warnings ( _ STR ) public static  Map create Map (  Object ... args ) {  Map result = new  Linked Hash Map ( ) ; if ( args == null || args . length == _ NUM ) return result ; for ( int i = _ NUM ; i < args . length - _ NUM ; i += _ NUM ) result . put ( args [ i ] , args [ i + _ NUM ] ) ; return result ; }
@  Override public  Promise <  Void ,  Authentication Exception > clean Subject (  Message Info Context message Info ,  Subject client Subject ) { return auth Module . clean Subject ( message Info , client Subject ) ; }
@  Override public int hash Code ( ) { int code = super . hash Code ( ) ; if ( f Entity Name != null ) { code += f Entity Name . hash Code ( ) ; } return code ; }
public  Builder add Action (  String action Type ,  Action action ) { m Actions . add ( new  Action Pair ( action Type , action ) ) ; return this ; }
@  Override public  String run (  String [ ] args ) { if ( args . length == _ NUM ) {  String help = _ STR ; help += _ STR ; help += _ STR ; help += _ STR ; help += _ STR ; help += _ STR ; return help ; } try { if ( args . length > _ NUM ) {  String cmd = args [ _ NUM ] ; if ( cmd == _ STR ) { if ( args . length > _ NUM ) { int id =  Integer . parse Int ( args [ _ NUM ] ) ; return str List Network ( id , _ BOOL ) ; } else { return str List Networks ( _ BOOL ) ; } } else if ( cmd == _ STR ) { if ( args . length > _ NUM ) { int id1 =  Integer . parse Int ( args [ _ NUM ] ) ; int id2 =  Integer . parse Int ( args [ _ NUM ] ) ; int id3 =  Integer . parse Int ( args [ _ NUM ] ) ; return str Link3 ( id1 , id2 , id3 ) ; } else if ( args . length > _ NUM ) { int id1 =  Integer . parse Int ( args [ _ NUM ] ) ; int id2 =  Integer . parse Int ( args [ _ NUM ] ) ; return str Link2 ( id1 , id2 ) ; } } else if ( cmd == _ STR ) { if ( args . length > _ NUM ) { int id =  Integer . parse Int ( args [ _ NUM ] ) ; return str Unlink ID ( id ) ; } else { return str Unlink All ( ) ; } } return _ STR ; } } catch (  Number Format Exception nfe ) { } catch (  Null Pointer Exception npe ) { } catch (  Index Out Of Bounds Exception ioobe ) { } return _ STR ; }
public  Shape inverse Shape (  Shape shape ) {  Path Iterator pi = shape . get Path Iterator ( null ) ; double [ ] coords = new double [ _ NUM ] ;  Point2 D world = new  Point2 D .  Double ( ) ;  Point2 D world2 = new  Point2 D .  Double ( ) ;  Point2 D world3 = new  Point2 D .  Double ( ) ;  Point2 D screen = new  Point2 D .  Double ( ) ;  Point2 D screen2 = new  Point2 D .  Double ( ) ;  Point2 D screen3 = new  Point2 D .  Double ( ) ;  General Path path = new  General Path (  General Path .  WIND_ EVEN_ ODD ) ; while ( ! pi . is Done ( ) ) { int type = pi . current Segment ( coords ) ; screen . set Location ( coords [ _ NUM ] , coords [ _ NUM ] ) ; inverse ( screen , world ) ; if ( type ==  Path Iterator .  SEG_ MOVETO ) { path . move To ( world . get X ( ) , world . get Y ( ) ) ; } else if ( type ==  Path Iterator .  SEG_ LINETO ) { path . line To ( world . get X ( ) , world . get Y ( ) ) ; } else if ( type ==  Path Iterator .  SEG_ CLOSE ) { path . close Path ( ) ; } else { screen2 . set Location ( coords [ _ NUM ] , coords [ _ NUM ] ) ; inverse ( screen2 , world2 ) ; if ( type ==  Path Iterator .  SEG_ QUADTO ) { path . quad To ( world . get X ( ) , world . get Y ( ) , world2 . get X ( ) , world2 . get Y ( ) ) ; } else if ( type ==  Path Iterator .  SEG_ CUBICTO ) { screen3 . set Location ( coords [ _ NUM ] , coords [ _ NUM ] ) ; inverse ( screen3 , world3 ) ; path . curve To ( world . get X ( ) , world . get Y ( ) , world2 . get X ( ) , world2 . get Y ( ) , world3 . get X ( ) , world3 . get Y ( ) ) ; } } pi . next ( ) ; } return path ; }
public static void drop All (  Connection conn ) throws  SQLException {  Statement stat = conn . create Statement ( ) ; stat . execute ( _ STR +  SCHEMA ) ; remove All Triggers ( conn ,  TRIGGER_ PREFIX ) ; remove Index Files ( conn ) ; }
public boolean contains (  Group Category category ) { return f Content . contains ( category ) ; }
public static boolean is Volume CGFull Copy Source (  Volume volume ,  Db Client db Client ) { boolean is Full Copy Source = _ BOOL ;  String Set full Copy Ids = volume . get Full Copies ( ) ; if ( ( full Copy Ids != null ) && ( ! full Copy Ids . is Empty ( ) ) ) {  Iterator <  String > full Copy Ids Iter = full Copy Ids . iterator ( ) ; while ( full Copy Ids Iter . has Next ( ) ) {  URI full Copy URI =  URI . create ( full Copy Ids Iter . next ( ) ) ;  Volume full Copy Volume = db Client . query Object (  Volume . class , full Copy URI ) ; if ( ( full Copy Volume != null ) && ( ! full Copy Volume . get Inactive ( ) ) ) {  String group Name = full Copy Volume . get Replication Group Instance ( ) ; if (  Null Column Value Getter . is Not Null Value ( group Name ) ||  VPlex Util . is Backend Full Copy In Replication Group ( full Copy Volume , db Client ) ) { is Full Copy Source = _ BOOL ; break ; } } } } return is Full Copy Source ; }
public static void assert Array Equals (  String message ,  Object [ ] expected ,  Object [ ] actual ) { if ( expected == null ) { assert Equals ( (  Object ) null , actual ) ; return ; } if ( actual == null ) { throw new  Assertion Failed Error ( message + _ STR +  Arrays . to String ( expected ) + _ STR ) ; } assert Equals ( message + _ STR , expected . length , actual . length ) ; for ( int i = _ NUM ; i < expected . length ; i ++ ) { assert Equals ( message , expected [ i ] , actual [ i ] ) ; } }
public void test_member Add_terminate Client ( ) throws  Interrupted Exception { final  Quorum < ? , ? > quorum = quorums [ _ NUM ] ; final  Quorum Member < ? > client = clients [ _ NUM ] ; final  Quorum Actor < ? , ? > actor = actors [ _ NUM ] ; final  UUID service Id = client . get Service Id ( ) ; assert False ( client . is Member ( ) ) ; assert Equals ( new  UUID [ ] { } , quorum . get Members ( ) ) ; actor . member Add ( ) ; fixture . await Deque ( ) ; assert True ( client . is Member ( ) ) ; assert Equals ( new  UUID [ ] { service Id } , quorum . get Members ( ) ) ; assert Equals ( client , quorum . get Client ( ) ) ; quorum . terminate ( ) ; try { quorum . get Client ( ) ; } catch (  Illegal State Exception ex ) { log . info ( _ STR + ex ) ; } assert Equals (  Quorum .  NO_ QUORUM , quorum . token ( ) ) ; assert Equals (  Quorum .  NO_ QUORUM , quorum . last Valid Token ( ) ) ; assert Equals ( new  UUID [ ] { } , quorum . get Members ( ) ) ; assert Equals ( new  UUID [ ] { } , quorum . get Joined ( ) ) ; assert Equals ( new  UUID [ ] { } , quorum . get Pipeline ( ) ) ; assert Equals (  Collections . empty Map ( ) , quorum . get Votes ( ) ) ; try { assert False ( client . is Member ( ) ) ; } catch (  Illegal State Exception ex ) { log . info ( _ STR + ex ) ; } quorum . terminate ( ) ; }
public void request After Explanation ( @  Non Null  String [ ] permissions ) {  Array List <  String > permissions To Request = new  Array List < > ( ) ; for (  String permission Name : permissions ) { if ( is Permission Declined ( permission Name ) ) { permissions To Request . add ( permission Name ) ; } else { permission Callback . on Permission Pre Granted ( permission Name ) ; } } if ( permissions To Request . is Empty ( ) ) return ; permissions = permissions To Request . to Array ( new  String [ permissions To Request . size ( ) ] ) ;  Activity Compat . request Permissions ( context , permissions ,  REQUEST_ PERMISSIONS ) ; }
static void pause Thread ( long duration ) { try {  Thread . sleep ( duration ) ; } catch (  Exception e ) { _log . warn ( _ STR , e ) ; } }
final public void println ( int v ) { try { _out . println ( v ) ; } catch (  IOException e ) { log . log (  Level .  FINE , e . to String ( ) , e ) ; } }
public int read ( char [ ] cbuf ) throws java . io .  IOException { return read ( cbuf , _ NUM , cbuf . length ) ; }
public static void write Unsigned Varint (  Byte Buffer buffer , int val ) { while ( ( val & _ NUM ) != val ) { buffer . put ( ( byte ) ( ( val & _ NUM ) | _ NUM ) ) ; val >>>= _ NUM ; } buffer . put ( ( byte ) ( val & _ NUM ) ) ; }
private static int  Call Nonvirtual Int Method V (  JNIEnvironment env , int obj JREF , int class JREF , int method ID ,  Address arg Address ) throws  Exception { if ( trace JNI )  VM . sys Write ( _ STR ) ;  Runtime Entrypoints . check JNICount Down To GC ( ) ; try {  Object obj = env . get JNIRef ( obj JREF ) ;  Object return Obj =  JNIHelpers . invoke With Var Arg ( obj , method ID , arg Address ,  Type Reference .  Int , _ BOOL ) ; return  Reflection . unwrap Int ( return Obj ) ; } catch (  Throwable unexpected ) { if ( trace JNI ) unexpected . print Stack Trace (  System . err ) ; env . record Exception ( unexpected ) ; return _ NUM ; } }
public static  Array List <  Program Block > rcreate Deep Copy Program Blocks (  Array List <  Program Block > child Blocks , long pid , int  IDPrefix ,  Hash Set <  String > fn Stack ,  Hash Set <  String > fn Created , boolean plain , boolean force Deep Copy ) throws  DMLRuntime Exception {  Array List <  Program Block > tmp = new  Array List <  Program Block > ( ) ; for (  Program Block pb : child Blocks ) {  Program prog = pb . get Program ( ) ;  Program Block tmp PB = null ; if ( pb instanceof  While Program Block ) { tmp PB = create Deep Copy While Program Block ( (  While Program Block ) pb , pid ,  IDPrefix , prog , fn Stack , fn Created , plain , force Deep Copy ) ; } else if ( pb instanceof  For Program Block && ! ( pb instanceof  Par For Program Block ) ) { tmp PB = create Deep Copy For Program Block ( (  For Program Block ) pb , pid ,  IDPrefix , prog , fn Stack , fn Created , plain , force Deep Copy ) ; } else if ( pb instanceof  Par For Program Block ) {  Par For Program Block pfpb = (  Par For Program Block ) pb ; if (  Par For Program Block .  ALLOW_ NESTED_ PARALLELISM ) tmp PB = create Deep Copy Par For Program Block ( pfpb , pid ,  IDPrefix , prog , fn Stack , fn Created , plain , force Deep Copy ) ; else tmp PB = create Deep Copy For Program Block ( (  For Program Block ) pb , pid ,  IDPrefix , prog , fn Stack , fn Created , plain , force Deep Copy ) ; } else if ( pb instanceof  If Program Block ) { tmp PB = create Deep Copy If Program Block ( (  If Program Block ) pb , pid ,  IDPrefix , prog , fn Stack , fn Created , plain , force Deep Copy ) ; } else { tmp PB = new  Program Block ( prog ) ; tmp PB . set Statement Block ( create Statement Block Copy ( pb . get Statement Block ( ) , pid , plain , force Deep Copy ) ) ; tmp PB . set Thread ID ( pid ) ; } tmp PB . set Instructions ( create Deep Copy Instruction Set ( pb . get Instructions ( ) , pid ,  IDPrefix , prog , fn Stack , fn Created , plain , _ BOOL ) ) ; tmp . add ( tmp PB ) ; } return tmp ; }
public  String root ( ) { return root ; }
private static double  Internalgamma ( double z ) { double sum = _ NUM ; double [ ] c = { _ NUM , _ NUM , - _ NUM , - _ NUM , _ NUM , - _ NUM , - _ NUM , _ NUM , - _ NUM , - _ NUM , _ NUM , - _ NUM , - _ NUM , _ NUM , - _ NUM , _ NUM , _ NUM , - _ NUM , _ NUM , _ NUM , - _ NUM , _ NUM , - _ NUM , - _ NUM , _ NUM , _ NUM } ; for ( int i = _ NUM ; i < c . length ; i ++ ) { sum += c [ i ] *  Math . pow ( z , ( double ) ( i + _ NUM ) ) ; } return ( _ NUM / sum ) ; }
public static  Class < ? > resolve Primitive If Necessary (  Class < ? > clazz ) {  Assert . not Null ( clazz , _ STR ) ; return ( clazz . is Primitive ( ) && clazz != void . class ? primitive Type To Wrapper Map . get ( clazz ) : clazz ) ; }
private static  Pair <  String ,  String > pre Indexed ASR ( final long offset , final  ITranslation Environment environment , final  List <  Reil Instruction > instructions , final  String register Node Value1 , final  String register Node Value2 , final  String immediate Node Value ) { final  String address = environment . get Next Variable String ( ) ; final  String index = environment . get Next Variable String ( ) ; final  String tmp Var = environment . get Next Variable String ( ) ; long base Offset = offset ; if ( immediate Node Value . equals ( _ STR ) ) { final  String is Zero Condition = environment . get Next Variable String ( ) ; final  String tmp Var1 = environment . get Next Variable String ( ) ; instructions . add (  Reil Helpers . create Bsh ( base Offset ++ , dw , register Node Value2 , wd ,  String . value Of ( - _ NUM ) , dw , tmp Var1 ) ) ; instructions . add (  Reil Helpers . create Bisz ( base Offset ++ , dw , tmp Var1 , bt , is Zero Condition ) ) ; instructions . add (  Reil Helpers . create Sub ( base Offset ++ , dw ,  String . value Of ( _ NUM ) , bt , is Zero Condition , dw , index ) ) ; } else { final  String tmp Var1 = environment . get Next Variable String ( ) ; final  String tmp Var2 = environment . get Next Variable String ( ) ; final  String tmp Var3 = environment . get Next Variable String ( ) ; final  String tmp Var4 = environment . get Next Variable String ( ) ; instructions . add (  Reil Helpers . create Add ( base Offset ++ , dw , register Node Value2 , dw ,  String . value Of ( _ NUM ) , dw , tmp Var1 ) ) ; instructions . add (  Reil Helpers . create Bsh ( base Offset ++ , dw , tmp Var1 , dw , _ STR + immediate Node Value , dw , tmp Var2 ) ) ; instructions . add (  Reil Helpers . create Bsh ( base Offset ++ , dw ,  String . value Of ( _ NUM ) , dw , _ STR + immediate Node Value , dw , tmp Var3 ) ) ; instructions . add (  Reil Helpers . create Sub ( base Offset ++ , dw , tmp Var2 , dw , tmp Var3 , qw , tmp Var4 ) ) ; instructions . add (  Reil Helpers . create And ( base Offset ++ , qw , tmp Var4 , dw , d Word Bit Mask , dw , index ) ) ; } instructions . add (  Reil Helpers . create Add ( base Offset ++ , dw , register Node Value1 , dw , index , dw , tmp Var ) ) ; instructions . add (  Reil Helpers . create And ( base Offset ++ , dw , tmp Var , dw , d Word Bit Mask , dw , address ) ) ; instructions . add (  Reil Helpers . create Str ( base Offset ++ , dw , address , dw , register Node Value1 ) ) ; return new  Pair <  String ,  String > ( address , register Node Value1 ) ; }
public  Class < ? > load Class (  String name ) throws  Class Not Found Exception { return init Class Loader . load Class ( name ) ; }
boolean wait For File Done ( ) { synchronized ( wait File Sync ) { try { while ( ! file Done ) wait File Sync . wait ( ) ; } catch (  Exception e ) { } } return file Success ; }
protected boolean is Any Test Component In Target (  Geometry test Geom ) {  List coords =  Component Coordinate Extracter . get Coordinates ( test Geom ) ; for (  Iterator i = coords . iterator ( ) ; i . has Next ( ) ; ) {  Coordinate p = (  Coordinate ) i . next ( ) ; int loc = target Point Locator . locate ( p ) ; if ( loc !=  Location .  EXTERIOR ) return _ BOOL ; } return _ BOOL ; }
private static void load Files Path (  Context context ) { if ( context != null ) { try {  File file = context . get Files Dir ( ) ; if ( file != null ) {  Crash Constants .  FILES_ PATH = file . get Absolute Path ( ) ; } } catch (  Exception e ) {  L . e ( _ STR ) ; e . print Stack Trace ( ) ; } } }
public  SPARQLRepository (  String endpoint Url ) { this ( endpoint Url , endpoint Url ) ; }
protected  Value parse QName Or Boolean ( ) throws  IOException ,  RDFParse Exception { int c = read Code Point ( ) ; if ( c == - _ NUM ) { throw EOFException ( ) ; } if ( c != _ STR && !  Turtle Util . is Prefix Start Char ( c ) ) { report Error ( _ STR + new  String (  Character . to Chars ( c ) ) + _ STR ,  Basic Parser Settings .  VERIFY_ RELATIVE_ URIS ) ; }  String namespace = null ; if ( c == _ STR ) { namespace = get Namespace ( _ STR ) ; } else {  String Builder prefix = new  String Builder ( _ NUM ) ; append Codepoint ( prefix , c ) ; int previous Char = c ; c = read Code Point ( ) ; while (  Turtle Util . is Prefix Char ( c ) ) { append Codepoint ( prefix , c ) ; previous Char = c ; c = read Code Point ( ) ; } if ( c != _ STR ) {  String value = prefix . to String ( ) ; if ( value . equals ( _ STR ) || value . equals ( _ STR ) ) { unread ( c ) ; return create Literal ( value , null ,  XMLSchema .  BOOLEAN , get Line Number ( ) , - _ NUM ) ; } } else { if ( previous Char == _ STR ) { report Fatal Error ( _ STR ) ; } } verify Character Or Fail ( c , _ STR ) ; namespace = get Namespace ( prefix . to String ( ) ) ; }  String Builder local Name = new  String Builder ( _ NUM ) ; c = read Code Point ( ) ; if (  Turtle Util . is Name Start Char ( c ) ) { if ( c == _ STR ) { local Name . append ( read Local Escaped Char ( ) ) ; } else { append Codepoint ( local Name , c ) ; } int previous Char = c ; c = read Code Point ( ) ; while (  Turtle Util . is Name Char ( c ) ) { if ( c == _ STR ) { local Name . append ( read Local Escaped Char ( ) ) ; } else { append Codepoint ( local Name , c ) ; } previous Char = c ; c = read Code Point ( ) ; } unread ( c ) ; if ( previous Char == _ STR ) { unread ( previous Char ) ; local Name . delete Char At ( local Name . length ( ) - _ NUM ) ; } } else { unread ( c ) ; }  String local Name String = local Name . to String ( ) ; for ( int i = _ NUM ; i < local Name String . length ( ) ; i ++ ) { if ( local Name String . char At ( i ) == _ STR ) { if ( i > local Name String . length ( ) - _ NUM || !  ASCIIUtil . is Hex ( local Name String . char At ( i + _ NUM ) ) || !  ASCIIUtil . is Hex ( local Name String . char At ( i + _ NUM ) ) ) { report Fatal Error ( _ STR + local Name String ) ; } } } return create URI ( namespace + local Name String ) ; }
public  Time Series Collection (  Time Series series ) { this ( series ,  Time Zone . get Default ( ) ) ; }
public static <  E >  List <  E > of (  E e1 ,  E e2 ) {  List <  E > list = new  Array List < > ( ) ; list . add ( e1 ) ; list . add ( e2 ) ; return list ; }
@  Override public void add Attribute (  String name , double value ) {  String str =  Double . to String ( value ) ; if ( str . ends With ( _ STR ) ) str = str . substring ( _ NUM , str . length ( ) - _ NUM ) ; current . set Attribute ( name , str ) ; }
@  Request Mapping ( value = _ STR , method =  Request Method .  GET ) public @  Response Body  List <  Message > list Messages For Application ( @  Path Variable final  String application Name , @  Path Variable final  Integer nb Rows ) throws  Service Exception ,  Check Exception { if ( logger . is Debug Enabled ( ) ) { logger . debug ( _ STR ) ; logger . debug ( _ STR + application Name ) ; logger . debug ( _ STR + nb Rows ) ; }  User user = authentification Utils . get Authentificated User ( ) ;  String application Name Local = application Name . replace All ( _ STR , _ STR ) ; return message Service . list By App ( user , application Name Local , nb Rows ) ; }
public void draw (  Pla Point Float [ ] p_points , double p_half_width ,  Color p_color ,  Graphics p_g , double p_translucency_factor ) { if ( p_color == null ) return ;  Graphics2 D g2 = (  Graphics2 D ) p_g ;  Rectangle clip_shape = (  Rectangle ) p_g . get Clip ( ) ;  Shape Tile Box clip_box = coordinate_transform . screen_to_board ( clip_shape ) ; double scaled_width = coordinate_transform . board_to_screen ( p_half_width ) ; init_draw_graphics ( g2 , p_color , ( float ) scaled_width * _ NUM ) ; set_translucency ( g2 , p_translucency_factor ) ;  General Path draw_path = null ; if ( ! show_line_segments ) { draw_path = new  General Path ( ) ; } for ( int i = _ NUM ; i < ( p_points . length - _ NUM ) ; i ++ ) { if ( line_outside_update_box ( p_points [ i ] , p_points [ i + _ NUM ] , p_half_width + update_offset , clip_box ) ) { continue ; }  Point2 D p1 = coordinate_transform . board_to_screen ( p_points [ i ] ) ;  Point2 D p2 = coordinate_transform . board_to_screen ( p_points [ i + _ NUM ] ) ;  Line2 D line = new  Line2 D .  Double ( p1 , p2 ) ; if ( show_line_segments ) { g2 . draw ( line ) ; } else { draw_path . append ( line , _ BOOL ) ; } } if ( ! show_line_segments ) { g2 . draw ( draw_path ) ; } }
@  Override public void zoom Domain Axes ( double factor ,  Plot Rendering Info info ,  Point2 D source ) { zoom Domain Axes ( factor , info , source , _ BOOL ) ; }
private void load Next Screen ( ) { if ( m Challenge No == m All Due Challenges . size ( ) - _ NUM ) { load Finish Screen ( ) ; return ; } m Challenge No += _ NUM ; m Current Challenge = m Challenge Data Source . get By Id ( m All Due Challenges . get ( m Challenge No ) ) ;  Object Animator animation =  Object Animator . of Int ( m Progress , _ STR , m Challenge No * _ NUM ) ; animation . set Duration ( _ NUM ) ; animation . set Interpolator ( new  Decelerate Interpolator ( ) ) ; animation . start ( ) ; load Challenge ( ) ; m Floating Action Button . set Visibility (  View .  VISIBLE ) ; m Floating Action Button . set Image Resource (  R . drawable . ic_check_white_24dp ) ; }
public  Generic Data ( ) { this (  Enum Set . none Of (  Flags . class ) ) ; }
public static  Image View as Image View FX (  Image Icon image Icon ) { java . awt .  Image awt Image = image Icon . get Image ( ) ; if ( awt Image != null ) { final  Buffered Image b Img ; if ( awt Image instanceof  Buffered Image ) { b Img = (  Buffered Image ) awt Image ; } else { b Img = new  Buffered Image ( awt Image . get Width ( null ) , awt Image . get Height ( null ) ,  Buffered Image .  TYPE_ INT_ ARGB ) ;  Graphics2 D graphics = b Img . create Graphics ( ) ; graphics . draw Image ( awt Image , _ NUM , _ NUM , null ) ; graphics . dispose ( ) ; } return new  Image View (  Swing FXUtils . to FXImage ( b Img , null ) ) ; } else return null ; }
public static void close ( ) { try { in . close ( ) ; } catch (  IOException e ) { e . print Stack Trace ( ) ; throw new  Runtime Exception ( _ STR ) ; } }
public  Str Builder insert ( int index , final boolean value ) { validate Index ( index ) ; if ( value ) { ensure Capacity ( size + _ NUM ) ;  System . arraycopy ( buffer , index , buffer , index + _ NUM , size - index ) ; buffer [ index ++ ] = _ STR ; buffer [ index ++ ] = _ STR ; buffer [ index ++ ] = _ STR ; buffer [ index ] = _ STR ; size += _ NUM ; } else { ensure Capacity ( size + _ NUM ) ;  System . arraycopy ( buffer , index , buffer , index + _ NUM , size - index ) ; buffer [ index ++ ] = _ STR ; buffer [ index ++ ] = _ STR ; buffer [ index ++ ] = _ STR ; buffer [ index ++ ] = _ STR ; buffer [ index ] = _ STR ; size += _ NUM ; } return this ; }
public static boolean is File Type Supported ( int file Type ,  Sequence sequence ) {  List providers = get Midi File Writers ( ) ; for ( int i = _ NUM ; i < providers . size ( ) ; i ++ ) {  Midi File Writer writer = (  Midi File Writer ) providers . get ( i ) ; if ( writer . is File Type Supported ( file Type , sequence ) ) { return _ BOOL ; } } return _ BOOL ; }
public void delete (  SSOToken token ,  String obj Name ) throws  SMSException ,  SSOException { if ( ( obj Name == null ) || ( obj Name . length ( ) == _ NUM ) ) { throw new  Illegal Argument Exception ( _ STR ) ; }  String obj Key = obj Name . to Lower Case ( ) ;  String filepath = null ; m RWLock . read Request ( ) ; try { filepath = m Name Map . get Property ( obj Key ) ; if ( ( filepath == null ) && m Debug . message Enabled ( ) ) { m Debug . message ( _ STR + obj Name + _ STR ) ; } } finally { m RWLock . read Done ( ) ; } if ( filepath != null ) { m RWLock . write Request ( ) ; try { filepath = m Name Map . get Property ( obj Key ) ; if ( filepath == null ) { if ( m Debug . message Enabled ( ) ) { m Debug . message ( _ STR + obj Name + _ STR ) ; } } else {  File filehandle = new  File ( filepath ) ;  File parent Dir = filehandle . get Parent File ( ) ; delete Dir ( parent Dir ) ; obj Name = obj Name . to Lower Case ( ) ;  Enumeration keys Enum = m Name Map . keys ( ) ; while ( keys Enum . has More Elements ( ) ) {  String key = (  String ) keys Enum . next Element ( ) ; if ( key . ends With ( obj Name ) ) { m Name Map . remove ( key ) ; } } save Properties ( m Name Map , m Name Map Handle , null ) ; } } finally { m RWLock . write Done ( ) ; } } }
public static void map Datasource (  Map map ,  List props ) {  String value = (  String ) map . get ( _ STR ) ;  String jndi Name = _ STR ;  Log Writer I18n writer =  Transaction Utils . get Log Writer I18n ( ) ;  Object ds = null ; try { jndi Name = (  String ) map . get ( _ STR ) ; if ( value . equals ( _ STR ) ) { ds =  Data Source Factory . get Pooled Data Source ( map , props ) ; ctx . rebind ( _ STR + jndi Name , ds ) ; data Source List . add ( ds ) ; if ( writer . fine Enabled ( ) ) writer . fine ( _ STR + jndi Name + _ STR ) ; } else if ( value . equals ( _ STR ) ) { ds =  Data Source Factory . get Tranx Data Source ( map , props ) ; ctx . rebind ( _ STR + jndi Name , ds ) ; data Source List . add ( ds ) ; if ( writer . fine Enabled ( ) ) writer . fine ( _ STR + jndi Name + _ STR ) ; } else if ( value . equals ( _ STR ) ) { ds =  Data Source Factory . get Simple Data Source ( map , props ) ; ctx . rebind ( _ STR + jndi Name , ds ) ; if ( writer . fine Enabled ( ) ) writer . fine ( _ STR + jndi Name + _ STR ) ; } else if ( value . equals ( _ STR ) ) {  Client Connection Factory Wrapper ds1 =  Data Source Factory . get Managed Data Source ( map , props ) ; ctx . rebind ( _ STR + jndi Name , ds1 . get Client Conn Factory ( ) ) ; data Source List . add ( ds1 ) ; if ( writer . fine Enabled ( ) ) writer . fine ( _ STR + jndi Name + _ STR ) ; } else {  String exception = _ STR ; if ( writer . fine Enabled ( ) ) writer . fine ( exception ) ; throw new  Data Source Create Exception ( exception ) ; } ds = null ; } catch (  Naming Exception ne ) { if ( writer . info Enabled ( ) ) writer . info (  Localized Strings .  JNDIInvoker_ JNDIINVOKER_ MAPDATASOURCE_0_ WHILE_ BINDING_1_ TO_ JNDI_ CONTEXT , new  Object [ ] { _ STR , jndi Name } ) ; } catch (  Data Source Create Exception dsce ) { if ( writer . info Enabled ( ) ) writer . info (  Localized Strings .  JNDIInvoker_ JNDIINVOKER_ MAPDATASOURCE_0_ WHILE_ BINDING_1_ TO_ JNDI_ CONTEXT , new  Object [ ] { _ STR , jndi Name } ) ; } }
public void add View (  View ... view ) {  List <  View > view List =  Arrays . as List ( view ) ; add Views ( view List ) ; }
public  File create File Object (  String path ) { if ( path . length ( ) >= _ NUM && path . char At ( _ NUM ) == _ STR &&  Character . is Letter ( path . char At ( _ NUM ) ) ) { if ( path . length ( ) == _ NUM ) { path += _ STR ; } else if ( path . char At ( _ NUM ) != _ STR ) { path = path . substring ( _ NUM , _ NUM ) + _ STR + path . substring ( _ NUM ) ; } } return super . create File Object ( path ) ; }
private void refresh Account Schema ( ) { if ( m_acct Schema == null ) { m_acct Schema = new  MAcct Schema (  Env . get Ctx ( ) , m_ C_ Acct Schema_ ID , null ) ; } return ; }
private  Attributes extract Namespaces (  Attributes attrs ) throws  SAXException {  Attributes Impl attrs Only ;  String raw Name ; int i ; int length ; if ( attrs == null ) { return null ; } length = attrs . get Length ( ) ; attrs Only = new  Attributes Impl ( attrs ) ; for ( i = length - _ NUM ; i >= _ NUM ; -- i ) { raw Name = attrs Only . get QName ( i ) ; if ( raw Name . starts With ( _ STR ) ) { if ( raw Name . length ( ) == _ NUM ) { start Prefix Mapping ( _ STR , attrs . get Value ( i ) ) ; attrs Only . remove Attribute ( i ) ; } else if ( raw Name . char At ( _ NUM ) == _ STR ) { start Prefix Mapping ( raw Name . substring ( _ NUM ) , attrs . get Value ( i ) ) ; attrs Only . remove Attribute ( i ) ; } } } return attrs Only ; }
public static byte [ ] load Binary File As Bytes ( final  String file ) throws  IOException { final  File Input Stream input Stream = new  File Input Stream ( file ) ; final byte [ ] data = new byte [ input Stream . available ( ) ] ; input Stream . read ( data ) ; input Stream . close ( ) ; return data ; }
@  Suppress Warnings ( _ STR ) public void test_stream API2 ( ) { final  List <  IBinding Set > expected Solutions = new  Array List <  IBinding Set > ( ) ; { final  IBinding Set expected = new  List Binding Set ( ) ; expected . set (  Var . var ( _ STR ) , new  Constant <  IV > ( term Id ) ) ; expected Solutions . add ( expected ) ; } { final  IBinding Set expected = new  List Binding Set ( ) ; expected Solutions . add ( expected ) ; } { final  IBinding Set expected = new  List Binding Set ( ) ; expected . set (  Var . var ( _ STR ) , new  Constant <  IV > ( term Id ) ) ; expected . set (  Var . var ( _ STR ) , new  Constant <  IV > ( blob IV ) ) ; expected Solutions . add ( expected ) ; } do Encode Decode Test ( expected Solutions ) ; }
public void add Index Condition (  Index Condition condition ) { index Conditions . add ( condition ) ; }
public void remove Index Interval ( int index0 , int index1 ) { int rm Min Index =  Math . min ( index0 , index1 ) ; int rm Max Index =  Math . max ( index0 , index1 ) ; int gap Length = ( rm Max Index - rm Min Index ) + _ NUM ; for ( int i = rm Min Index ; i <= max Index ; i ++ ) { set State ( i , value . get ( i + gap Length ) ) ; } }
protected void compare To DEQSim Events ( final  String deqsim Events File ) {  Linked List <  Event > copy Event List = new  Linked List <  Event > ( ) ; for ( int i = _ NUM ; i < all Events . size ( ) ; i ++ ) { if ( ! ( all Events . get ( i ) instanceof  Activity Start Event || all Events . get ( i ) instanceof  Activity End Event ) ) { copy Event List . add ( all Events . get ( i ) ) ; } }  Array List <  Event Log > deq Sim Log =  Cpp Event File Parser . parse File ( deqsim Events File ) ; for ( int i = _ NUM ; i < copy Event List . size ( ) ; i ++ ) { assert True ( _ STR ,  Cpp Event File Parser . equals ( copy Event List . get ( i ) , deq Sim Log . get ( i ) ) ) ; } }
public  Disk Log ( ) { }
private static void delete Directory (  File file ) throws  IOException { if ( file . is Directory ( ) ) {  File [ ] files = file . list Files ( ) ; if ( files != null ) { for ( int i = _ NUM ; i < files . length ; i ++ ) { delete Directory ( files [ i ] ) ; } } } file . delete ( ) ; }
public int send ( byte [ ] buffer , int offset , int count ) { check Array Bounds ( buffer , offset , count ) ; if ( count == _ NUM ) { return _ NUM ; } byte [ ] data = buffer ; if ( offset > _ NUM ) { data = new byte [ count ] ;  System . arraycopy ( buffer , offset , data , _ NUM , count ) ; }  Int Out bytes Sent Out = new  Int Out ( ) ; try {  IDevice . check Result (  Lib IMobile Device . idevice_connection_send ( get Ref ( ) , data , count , bytes Sent Out ) ) ; return bytes Sent Out . get Value ( ) ; } finally { bytes Sent Out . delete ( ) ; } }
private boolean range Contains Reserved ( int rop Range Start , int width ) { for ( int i = rop Range Start ; i < ( rop Range Start + width ) ; i ++ ) { if ( reserved Rop Regs . get ( i ) ) { return _ BOOL ; } } return _ BOOL ; }
public static void register (  Resource Resolver Spi resource Resolver Spi , boolean start ) {  Java Utils . check Register Permission ( ) ; synchronized ( resolver List ) { if ( start ) { resolver List . add ( _ NUM , new  Resource Resolver ( resource Resolver Spi ) ) ; } else { resolver List . add ( new  Resource Resolver ( resource Resolver Spi ) ) ; } } if ( log . is Loggable ( java . util . logging .  Level .  FINE ) ) { log . log ( java . util . logging .  Level .  FINE , _ STR + resource Resolver Spi . to String ( ) ) ; } }
private boolean process Authentication Response ( final  Http Method method ) {  LOG . trace ( _ STR + _ STR ) ; try { switch ( method . get Status Code ( ) ) { case  Http Status .  SC_ UNAUTHORIZED : return process WWWAuth Challenge ( method ) ; case  Http Status .  SC_ PROXY_ AUTHENTICATION_ REQUIRED : return process Proxy Auth Challenge ( method ) ; default : return _ BOOL ; } } catch ( final  Exception e ) { if (  LOG . is Error Enabled ( ) ) {  LOG . error ( e . get Message ( ) , e ) ; } return _ BOOL ; } }
byte [ ] concatenate Byte Arrays ( byte [ ] ... byte Arrays ) throws  IOException {  Byte Array Output Stream output Stream = new  Byte Array Output Stream ( ) ; for ( byte [ ] array : byte Arrays ) { output Stream . write ( array ) ; } return output Stream . to Byte Array ( ) ; }
public boolean is Pipeline ( ) { return material . is Pipeline ( ) ; }
public void draw Range Marker (  Graphics2 D g2 ,  Contour Plot plot ,  Value Axis range Axis ,  Marker marker ,  Rectangle2 D data Area ) { if ( marker instanceof  Value Marker ) {  Value Marker vm = (  Value Marker ) marker ; double value = vm . get Value ( ) ;  Range range = range Axis . get Range ( ) ; if ( ! range . contains ( value ) ) { return ; } double y = range Axis . value To Java2 D ( value , data Area ,  Rectangle Edge .  LEFT ) ;  Line2 D line = new  Line2 D .  Double ( data Area . get Min X ( ) , y , data Area . get Max X ( ) , y ) ;  Paint paint = marker . get Outline Paint ( ) ;  Stroke stroke = marker . get Outline Stroke ( ) ; g2 . set Paint ( paint != null ? paint :  Plot .  DEFAULT_ OUTLINE_ PAINT ) ; g2 . set Stroke ( stroke != null ? stroke :  Plot .  DEFAULT_ OUTLINE_ STROKE ) ; g2 . draw ( line ) ; } }
private static boolean validate Allowed Values (  String property Value ,  String [ ] acceptable Values ) { for (  String value : acceptable Values ) { if ( value . equals ( property Value ) ) { return _ BOOL ; } } return _ BOOL ; }
public int size ( ) { final  Reentrant Lock lock = this . lock ; lock . lock ( ) ; try { return count ; } finally { lock . unlock ( ) ; } }
private  Rtp Packet parse Rtp Packet ( byte [ ] data ) {  Rtp Packet packet = new  Rtp Packet ( ) ; try { packet . length = data . length ; packet . received At =  System . current Time Millis ( ) ; packet . extension = ( data [ _ NUM ] & _ NUM ) > _ NUM ; if ( ( byte ) ( ( data [ _ NUM ] & _ NUM ) & _ NUM ) == ( byte ) _ NUM ) { packet . marker = _ NUM ; } else { packet . marker = _ NUM ; } packet . payload Type = ( byte ) ( ( data [ _ NUM ] & _ NUM ) & _ NUM ) ; packet . seqnum = ( char ) ( ( data [ _ NUM ] << _ NUM ) | ( data [ _ NUM ] & _ NUM ) ) ; packet . timestamp = ( ( ( data [ _ NUM ] & _ NUM ) << _ NUM ) | ( ( data [ _ NUM ] & _ NUM ) << _ NUM ) | ( ( data [ _ NUM ] & _ NUM ) << _ NUM ) | ( data [ _ NUM ] & _ NUM ) ) ; packet . ssrc = ( ( ( data [ _ NUM ] & _ NUM ) << _ NUM ) | ( ( data [ _ NUM ] & _ NUM ) << _ NUM ) | ( ( data [ _ NUM ] & _ NUM ) << _ NUM ) | ( data [ _ NUM ] & _ NUM ) ) ; if ( packet . extension ) { int data Id = _ NUM ; int extension Header Id = ( ( data [ ++ data Id ] & _ NUM ) << _ NUM ) | ( data [ ++ data Id ] & _ NUM ) ; int length = ( ( data [ ++ data Id ] & _ NUM ) << _ NUM ) | ( data [ ++ data Id ] & _ NUM ) ; if ( extension Header Id ==  Rtp Extension Header .  RTP_ EXTENSION_ HEADER_ ID ) { extract Extension Header ( data , length , data Id , packet ) ; } packet . payloadoffset = _ NUM + length * _ NUM ; } else { packet . payloadoffset = _ NUM ; } packet . payloadlength = packet . length - packet . payloadoffset ; packet . data = new byte [ packet . payloadlength ] ;  System . arraycopy ( data , packet . payloadoffset , packet . data , _ NUM , packet . payloadlength ) ; } catch (  Exception e ) { return null ; } return packet ; }
public static final void write Int Array Xml ( int [ ] val ,  String name ,  Xml Serializer out ) throws  Xml Pull Parser Exception , java . io .  IOException { if ( val == null ) { out . start Tag ( null , _ STR ) ; out . end Tag ( null , _ STR ) ; return ; } out . start Tag ( null , _ STR ) ; if ( name != null ) { out . attribute ( null , _ STR , name ) ; } final int  N = val . length ; out . attribute ( null , _ STR ,  Integer . to String (  N ) ) ; for ( int i = _ NUM ; i <  N ; i ++ ) { out . start Tag ( null , _ STR ) ; out . attribute ( null , _ STR ,  Integer . to String ( val [ i ] ) ) ; out . end Tag ( null , _ STR ) ; } out . end Tag ( null , _ STR ) ; }
private void unify Username By Email (  Map <  String ,  List <  Log Commit Info > > username Map ) { for (  Entry <  String ,  List <  Log Commit Info > > entry : username Map . entry Set ( ) ) {  List <  String > names = get Names List ( entry . get Value ( ) ) ;  String new User Name = names . get ( _ NUM ) ; if ( names . size ( ) > _ NUM ) new User Name = get New Name ( names ) ; for (  Log Commit Info commit : entry . get Value ( ) ) { commit . set User Name ( new User Name ) ; } } }
private void close Connection (  Connection connection ) throws  SQLException { if ( connection != null ) { try { connection . close ( ) ; } catch (  SQLException e ) { throw new  SQLException ( _ STR , e ) ; } } }
public  ELFFormatter ( ) {  String timestamp Generator Class = lmanager . get Property (  Log Constants .  SECURE_ TIMESTAMP_ GENERATOR ) ; try {  Class clz =  Class . for Name ( timestamp Generator Class ) ; secure Timestamp Generator = (  ITimestamp Generator ) clz . new Instance ( ) ; } catch (  Class Not Found Exception cnfe ) {  Debug . error ( _ STR + _ STR , cnfe ) ; } catch (  Instantiation Exception ie ) {  Debug . error ( _ STR + _ STR , ie ) ; } catch (  Illegal Access Exception iae ) {  Debug . error ( _ STR + _ STR , iae ) ; } }
public static  String read All ( final  URL url ) throws  IOException { try (  Input Stream input = url . open Stream ( ) ) { return read All ( input ) ; } }
public static  Data Network init Network ( ) {  Random random = new  Random (  System . current Time Millis ( ) ) ; int id = random . next Int ( ) ; while ( used Ids . contains ( id ) ) { id = random . next Int ( ) ; } ;  Data Network net = new  Data Network ( ) ; used Ids . add ( id ) ; net . network ID = id ; return net ; }
public static  String format File Size ( int bytes ) { if ( bytes <= _ NUM ) return null ; if ( bytes < _ NUM ) { return bytes + _ STR ; } else if ( bytes < _ NUM * _ NUM ) { return  String . format ( _ STR , bytes / _ NUM ) ; } else if ( bytes < _ NUM * _ NUM * _ NUM ) { return  String . format ( _ STR , bytes / ( _ NUM * _ NUM ) ) ; } else { return  String . format ( _ STR , bytes / ( _ NUM * _ NUM * _ NUM ) ) ; } }
public static boolean check Alarm Service (  Context context ,  Pending Intent service Pending Intent ) { final  Intent i = new  Intent ( context ,  Github Widget Service . class ) ; return  Pending Intent . get Service ( context , _ NUM , i ,  Pending Intent .  FLAG_ NO_ CREATE ) != null ; }
public static boolean equals (  Object a ,  Object b ) { return ( a == b ) || ( a != null && a . equals ( b ) ) ; }
public void delete By App Id (  Long app Id ) {  List <  Config > configs = config Dao . list By App Id ( app Id , _ NUM , _ NUM ) ; if ( configs != null && ! configs . is Empty ( ) ) { for (  Config config : configs ) { delete ( config ) ; } } }
public static void is Valid Inet Address (  String  IP ) throws  Illegal Argument Exception { if (  IP == null ||  IP . is Empty ( ) ) { throw new  Illegal Argument Exception ( _ STR ) ; } if (  IP . contains ( _ STR ) ) { } else {  String [ ] segments =  IP . split ( _ STR ) ; if ( segments . length != _ NUM ) { throw new  Illegal Argument Exception ( _ STR +  IP ) ; } try {  Inet Address . get By Name (  IP ) ; } catch (  Unknown Host Exception e ) { throw new  Illegal Argument Exception ( e ) ; } } }
private  View move Selection ( int delta , int children Left , int children Right ) { if (  DEBUG )  Log . i (  TAG , _ STR + delta + _ STR + children Left +  CHILDREN_ RIGHT + children Right +  M_ FIRST_ POSITION + m First Position ) ; final int fading Edge Length = get Horizontal Fading Edge Length ( ) ; final int selected Position = m Selected Position ; final int num Rows = m Num Rows ; final int horizontal Spacing = m Horizontal Spacing ; int old Column Start ; int column Start ; int column End = - _ NUM ; if ( ! m Stack From Bottom ) { old Column Start = ( selected Position - delta ) - ( ( selected Position - delta ) % num Rows ) ; column Start = selected Position - ( selected Position % num Rows ) ; } else { int inverted Selection = m Item Count - _ NUM - selected Position ; column End = m Item Count - _ NUM - ( inverted Selection - ( inverted Selection % num Rows ) ) ; column Start =  Math . max ( _ NUM , column End - num Rows + _ NUM ) ; inverted Selection = m Item Count - _ NUM - ( selected Position - delta ) ; old Column Start = m Item Count - _ NUM - ( inverted Selection - ( inverted Selection % num Rows ) ) ; old Column Start =  Math . max ( _ NUM , old Column Start - num Rows + _ NUM ) ; } final int row Delta = column Start - old Column Start ; final int left Selection Pixel = get Left Selection Pixel ( children Left , fading Edge Length , column Start ) ; final int right Selection Pixel = get Right Selection Pixel ( children Right , fading Edge Length , num Rows , column Start ) ; m First Position = column Start ;  View sel ;  View reference View ; if ( row Delta > _ NUM ) { final int old Right = m Reference View In Selected Row == null ? _ NUM : m Reference View In Selected Row . get Right ( ) ; sel = make Column ( m Stack From Bottom ? column End : column Start , old Right + horizontal Spacing , _ BOOL ) ; reference View = m Reference View ; adjust For Right Fading Edge ( reference View , left Selection Pixel , right Selection Pixel ) ; } else if ( row Delta < _ NUM ) { final int old Top = m Reference View In Selected Row == null ? _ NUM : m Reference View In Selected Row . get Left ( ) ; sel = make Column ( m Stack From Bottom ? column End : column Start , old Top - horizontal Spacing , _ BOOL ) ; reference View = m Reference View ; adjust For Left Fading Edge ( reference View , left Selection Pixel , right Selection Pixel ) ; } else { final int old Top = m Reference View In Selected Row == null ? _ NUM : m Reference View In Selected Row . get Left ( ) ; sel = make Column ( m Stack From Bottom ? column End : column Start , old Top , _ BOOL ) ; reference View = m Reference View ; } if ( ! m Stack From Bottom ) { fill Left ( column Start - num Rows , reference View . get Left ( ) - horizontal Spacing ) ; adjust Views Left Or Right ( ) ; fill Right ( column Start + num Rows , reference View . get Right ( ) + horizontal Spacing ) ; } else { fill Right ( column Start + num Rows , reference View . get Right ( ) + horizontal Spacing ) ; adjust Views Left Or Right ( ) ; fill Left ( column Start - _ NUM , reference View . get Left ( ) - horizontal Spacing ) ; } return sel ; }
public  Shape Tile Box vertical_offset ( double p_dist ) { if ( p_dist == _ NUM || is_empty ( ) ) { return this ; } int dist = ( int )  Math . round ( p_dist ) ;  Pla Point Int lower_left = new  Pla Point Int ( box_ll . v_x , box_ll . v_y - dist ) ;  Pla Point Int upper_right = new  Pla Point Int ( box_ur . v_x , box_ur . v_y + dist ) ; return new  Shape Tile Box ( lower_left , upper_right ) ; }
@  Override public boolean lock ( ) { try { if ( !  File Factory . is File Exist ( location ,  File Factory . get File Type ( tmp Path ) ) ) {  File Factory . mkdirs ( location ,  File Factory . get File Type ( tmp Path ) ) ; } lock File Path = location +  Carbon Common Constants .  FILE_ SEPARATOR + lock File ; if ( !  File Factory . is File Exist ( lock File Path ,  File Factory . get File Type ( location ) ) ) {  File Factory . create New Lock File ( lock File Path ,  File Factory . get File Type ( location ) ) ; } file Output Stream = new  File Output Stream ( lock File Path ) ; channel = file Output Stream . get Channel ( ) ; try { file Lock = channel . try Lock ( ) ; } catch (  Overlapping File Lock Exception e ) { return _ BOOL ; } if ( null != file Lock ) { return _ BOOL ; } else { return _ BOOL ; } } catch (  IOException e ) { return _ BOOL ; } }
public static double create Double Setting ( final  Map <  String ,  String > raw Settings , final  String setting Name , final double default Value ) { final  String setting String = raw Settings . get ( setting Name ) ; if ( setting String == null ) { return default Value ; } else { try { return  Double . parse Double ( setting String ) ; } catch ( final  Number Format Exception exception ) {  CUtility Functions . log Exception ( exception ) ; return default Value ; } } }
private  Item lookup Do (  Template tmpl ) { if ( is Empty ( tmpl . service Types ) || tmpl . service ID != null ) {  Item Iter iter = matching Items ( tmpl ) ; if ( iter . has Next ( ) ) return iter . next ( ) ; return null ; }  List services = matching Services ( tmpl . service Types ) ; long now =  System Time . time Millis ( ) ; int slen = services . size ( ) ; if ( slen == _ NUM ) return null ; int srand = random . next Int (  Integer .  MAX_ VALUE ) % slen ; for ( int i = _ NUM ; i < slen ; i ++ ) {  Svc Reg reg = (  Svc Reg ) services . get ( ( i + srand ) % slen ) ; if ( reg . lease Expiration > now && match Attributes ( tmpl , reg . item ) ) return reg . item ; } return null ; }
@  Override public boolean run After (  List tasks , int size ) { for ( int i = _ NUM ; i < size ; i ++ ) {  Cache Task t = (  Cache Task ) tasks . get ( i ) ; if ( t instanceof  Register Listener Task || t instanceof  Lookup Task || t instanceof  Notify Event Task ) {  Proxy Reg other Reg = t . get Proxy Reg ( ) ; if ( reg . equals ( other Reg ) ) { if ( this Task Seq N > t . get Seq N ( ) ) return _ BOOL ; } } } return super . run After ( tasks , size ) ; }
public static  String serialize (  Object data ) {  String ret = null ; if ( data != null ) { if ( data . get Class ( ) ==  String . class ) { ret = (  String ) data ; } else if ( data instanceof byte [ ] ) { ret = new  String ( ( byte [ ] ) data ) ; } else { try { ret = mapper . write Value As String ( data ) ; } catch (  Json Processing Exception e ) { if ( log . is Loggable (  Level .  FINEST ) ) { log . log (  Level .  FINEST , _ STR , e ) ; } } } } if ( log . is Loggable (  Level .  FINEST ) ) { log . finest ( _ STR + data + _ STR + ret ) ; } return ret ; }
public static int size ( double [ ] array ) { return  Array . get Length ( array ) ; }
private static  String matchable Path (  String path ) { if ( path == null ) { return _ STR ; } else if ( path . ends With ( _ STR ) ) { return path ; } else { return path + _ STR ; } }
private void identify Duplicate Group Names ( final  Collection <  Group > groups ) {  LOG . debug ( _ STR ) ; final  List <  String > group Names = new  Array List <  String > ( ) ; for ( final  Group group : groups ) { if ( group Names . contains ( group . get Name ( ) ) ) { throw new  Wro Runtime Exception ( _ STR + group . get Name ( ) ) ; } group Names . add ( group . get Name ( ) ) ; } }
protected static void add Line (  Print Writer file ,  String level ,  String string ) { log . debug ( string ) ; if ( file != null ) {  String [ ] lines = string . split (  NEW_ LINE ) ; for (  String line : lines ) { print Line ( file , level , line ) ; } } }
protected boolean update Attachment Point ( ) { boolean moved = _ BOOL ; this . old APs = attachment Points ; if ( attachment Points == null || attachment Points . is Empty ( ) ) return _ BOOL ;  List <  Attachment Point > ap List = new  Array List <  Attachment Point > ( ) ; if ( attachment Points != null ) ap List . add All ( attachment Points ) ;  Map <  Datapath Id ,  Attachment Point > new Map = get APMap ( ap List ) ; if ( new Map == null || new Map . size ( ) != ap List . size ( ) ) { moved = _ BOOL ; } if ( moved ) { log . info ( _ STR , attachment Points , new Map ) ;  List <  Attachment Point > new APList = new  Array List <  Attachment Point > ( ) ; if ( new Map != null ) new APList . add All ( new Map . values ( ) ) ; this . attachment Points = new APList ; } return moved ; }
public void add All (  List <  Soft Wrap Impl > soft Wraps ) { my Wraps . add All ( soft Wraps ) ; }
public  String to String ( ) { return _ STR + format . format ( x ) + _ STR + format . format ( y ) + _ STR ; }
public static  String strip Trailing Char (  String string , char c ) { if ( string . length ( ) > _ NUM ) { if ( string . char At ( string . length ( ) - _ NUM ) == c ) { return string . substring ( _ NUM , string . length ( ) - _ NUM ) ; } } return string ; }
public void perform Ranking Update (  Map <  Integer ,  Integer > legion Ranking ) { log . info ( _ STR ) ; long start Time =  System . current Time Millis ( ) ;  Iterator <  Legion > legions Iterator = all Cached Legions . iterator ( ) ; int legions Updated = _ NUM ; this . legion Ranking = legion Ranking ; while ( legions Iterator . has Next ( ) ) {  Legion legion = legions Iterator . next ( ) ; if ( legion Ranking . contains Key ( legion . get Legion Id ( ) ) ) { legion . set Legion Rank ( legion Ranking . get ( legion . get Legion Id ( ) ) ) ;  Packet Send Utility . broadcast Packet To Legion ( legion , new  SM_ LEGION_ EDIT ( _ NUM , legion ) ) ; } legions Updated ++ ; } long work Time =  System . current Time Millis ( ) - start Time ; log . info ( _ STR + work Time + _ STR + legions Updated ) ; }
public static void upto ( float self ,  Number to , @  Closure Params (  First Param . class )  Closure closure ) { float to1 = to . float Value ( ) ; if ( self <= to1 ) { for ( float i = self ; i <= to1 ; i ++ ) { closure . call ( i ) ; } } else throw new  Groovy Runtime Exception ( _ STR + to + _ STR + self + _ STR ) ; }
protected void parse DOMElement (  Element element ) throws  SAML2 Exception {  Assertion Factory assertion Factory =  Assertion Factory . get Instance ( ) ;  Protocol Factory proto Factory =  Protocol Factory . get Instance ( ) ; request Id = element . get Attribute (  SAML2 Constants .  ID ) ; validate ID ( request Id ) ; version = element . get Attribute (  SAML2 Constants .  VERSION ) ; validate Version ( version ) ;  String issue Instant Str = element . get Attribute (  SAML2 Constants .  ISSUE_ INSTANT ) ; validate Issue Instant ( issue Instant Str ) ; destination URI = element . get Attribute (  SAML2 Constants .  DESTINATION ) ; consent = element . get Attribute (  SAML2 Constants .  CONSENT ) ;  Node List n List = element . get Child Nodes ( ) ; if ( ( n List != null ) && ( n List . get Length ( ) > _ NUM ) ) { for ( int i = _ NUM ; i < n List . get Length ( ) ; i ++ ) {  Node child Node = n List . item ( i ) ;  String c Name = child Node . get Local Name ( ) ; if ( c Name != null ) { if ( c Name . equals (  SAML2 Constants .  ISSUER ) ) { validate Issuer ( ) ; name ID = assertion Factory . create Issuer ( (  Element ) child Node ) ; } else if ( c Name . equals (  SAML2 Constants .  SIGNATURE ) ) { validate Signature ( ) ; signature String =  XMLUtils . print ( (  Element ) child Node ) ; is Signed = _ BOOL ; } else if ( c Name . equals (  SAML2 Constants .  EXTENSIONS ) ) { validate Extensions ( ) ; extensions = proto Factory . create Extensions ( (  Element ) child Node ) ; } else if ( c Name . equals (  SAML2 Constants .  SUBJECT ) ) { validate Subject ( ) ; subject = assertion Factory . create Subject ( (  Element ) child Node ) ; } else if ( c Name . equals (  SAML2 Constants .  NAMEIDPOLICY ) ) { validate Name IDPolicy ( ) ; name IDPolicy = proto Factory . create Name IDPolicy ( (  Element ) child Node ) ; } else if ( c Name . equals (  SAML2 Constants .  CONDITIONS ) ) { validate Conditions ( ) ; conditions = assertion Factory . create Conditions ( (  Element ) child Node ) ; } else if ( c Name . equals (  SAML2 Constants .  REQ_ AUTHN_ CONTEXT ) ) { validate Req Authn Context ( ) ; req Authn Context = proto Factory . create Requested Authn Context ( (  Element ) child Node ) ; } else if ( c Name . equals (  SAML2 Constants .  SCOPING ) ) { validate Scoping ( ) ; scoping = proto Factory . create Scoping ( (  Element ) child Node ) ; } } } }  String force Authn Attr = element . get Attribute (  SAML2 Constants .  FORCEAUTHN ) ; if ( ( force Authn Attr != null ) && ( force Authn Attr . length ( ) > _ NUM ) ) { force Authn =  SAML2 SDKUtils . boolean Value Of ( force Authn Attr ) ; }  String is Passive Attr = element . get Attribute (  SAML2 Constants .  ISPASSIVE ) ; if ( ( is Passive Attr != null ) && ( is Passive Attr . length ( ) > _ NUM ) ) { is Passive =  SAML2 SDKUtils . boolean Value Of ( is Passive Attr ) ; } protocol Binding = element . get Attribute (  SAML2 Constants .  PROTOBINDING ) ;  String index = element . get Attribute (  SAML2 Constants .  ASSERTION_ CONSUMER_ SVC_ INDEX ) ; if ( ( index != null ) && ( index . length ( ) > _ NUM ) ) { assertion Consumer Svc Index = new  Integer ( index ) ; validate Assertion Consumer Service Index ( assertion Consumer Svc Index ) ; } assertion Consumer Service URL =  XMLUtils . unescape Special Characters ( element . get Attribute (  SAML2 Constants .  ASSERTION_ CONSUMER_ SVC_ URL ) ) ; index = element . get Attribute (  SAML2 Constants .  ATTR_ CONSUMING_ SVC_ INDEX ) ; if ( ( index != null ) && ( index . length ( ) > _ NUM ) ) { attr Consuming Svc Index = new  Integer ( index ) ; validate Attribute Consuming Service Index ( attr Consuming Svc Index ) ; } provider Name = element . get Attribute (  SAML2 Constants .  PROVIDER_ NAME ) ; }
private void load Old Update Properties ( ) throws  IOException { prop = new  Properties ( ) ;  Input Stream is ; if ( old File . index Of ( _ STR ) > _ NUM ) {  URL url = new  URL ( old File ) ; is = url . open Stream ( ) ; } else { is = new  File Input Stream ( old File ) ; } prop . load ( is ) ; is . close ( ) ; }
public void add (  T item ) { if ( items . add ( item ) ) { notify Data Set Changed ( ) ; } }
public  VNXe Cifs Share find Cifs Share By Name (  String share Name ) {  Cifs Share Requests req = new  Cifs Share Requests ( _kh Client ) ;  List <  VNXe Cifs Share > shares = req . get Cifs Share By Name ( share Name ) ; if ( shares != null && ! shares . is Empty ( ) ) { return shares . get ( _ NUM ) ; } else { return null ; } }
public  Terms Request Parser parse ( ) throws  Parser Configuration Exception ,  SAXException ,  Parse Failure Exception { try {  SAXParser Factory factory =  SAXParser Factory . new Instance ( ) ;  SAXParser parser = factory . new SAXParser ( ) ; parser . parse ( m Input Source , this ) ; return this ; } catch (  IOException e ) { throw new  Parse Failure Exception ( _ STR , e ) ; } }
public  Builder delete Name ( ) { delete Fields . add ( _ STR ) ; return this ; }
protected void incorporate Signature Value ( ) { signature Value Dom =  DSSXMLUtils . add Element ( document Dom , signature Dom ,  XMLNS ,  DS_ SIGNATURE_ VALUE ) ; signature Value Dom . set Attribute (  ID , _ STR + deterministic Id ) ; }
public static double mean ( double [ ] data , int [ ] inds ) { double mean = _ NUM ; for ( int i = _ NUM ; i < inds . length ; i ++ ) { if (  Double . is Na N ( data [ inds [ i ] ] ) ) throw new  Illegal Argument Exception ( _ STR ) ; mean += data [ inds [ i ] ] ; } mean /= inds . length ; return mean ; }
public  String go Back ( ) { if ( pointer > _ NUM ) { pointer -- ; } if ( messages . size ( ) > _ NUM ) { return messages . get ( pointer ) ; } return null ; }
@  Override public  Result do Comparison Test ( final  Properties properties ) throws  Exception { final long timeout =  Long . parse Long ( properties . get Property (  Test Options .  TIMEOUT ) ) ; final int nclients =  Integer . parse Int ( properties . get Property (  Test Options .  NCLIENTS ) ) ; final int ntrials =  Integer . parse Int ( properties . get Property (  Test Options .  NTRIALS ) ) ; final int key Len =  Integer . parse Int ( properties . get Property (  Test Options .  KEYLEN ) ) ; final int nops =  Integer . parse Int ( properties . get Property (  Test Options .  NOPS ) ) ; final double abort Rate =  Double . parse Double ( properties . get Property (  Test Options .  ABORT_ RATE ) ) ; final  Result result = do Concurrent Client Test ( journal , timeout , nclients , ntrials , key Len , nops , abort Rate ) ; return result ; }
private void import Text ( ) {  JFile Chooser jc = new  JFile Chooser ( ) ; jc . set Dialog Title (  Msg . get Msg (  Env . get Ctx ( ) , _ STR ) ) ; jc . set Dialog Type (  JFile Chooser .  OPEN_ DIALOG ) ; jc . set File Selection Mode (  JFile Chooser .  FILES_ ONLY ) ; if ( jc . show Open Dialog ( this ) !=  JFile Chooser .  APPROVE_ OPTION ) return ;  String Buffer sb = new  String Buffer ( ) ; try {  Input Stream Reader in = new  Input Stream Reader ( new  File Input Stream ( jc . get Selected File ( ) ) ) ; char [ ] cbuf = new char [ _ NUM ] ; int count ; while ( ( count = in . read ( cbuf ) ) > _ NUM ) sb . append ( cbuf , _ NUM , count ) ; in . close ( ) ; } catch (  Exception e ) { log . log (  Level .  WARNING , e . get Message ( ) ) ; return ; } text Area . set Text ( sb . to String ( ) ) ; update Status Bar ( ) ; }
private  List <  String > fetch Block Cos Id List ( ) throws  SOSFailure { final  String method Name = _ STR ; log . trace ( method Name + _ STR ) ; final  String  BLOCK_ COS_ URI = _ STR ;  List <  String > block Cos Id List = new  Array List <  String > ( ) ; try {  Co SList cos Elem List = _client . query Object (  BLOCK_ COS_ URI ,  Co SList . class ) ; if ( cos Elem List != null && cos Elem List . get Cos Elements ( ) != null ) { for (  Co SElement elem : cos Elem List . get Cos Elements ( ) ) { if ( elem != null ) { block Cos Id List . add ( elem . get Id ( ) ) ; } } } log . trace ( method Name + _ STR + block Cos Id List ) ; if ( cos Elem List != null && block Cos Id List != null ) { log . trace ( method Name + _ STR + block Cos Id List . size ( ) + _ STR ) ; return block Cos Id List ; } log . trace ( method Name + _ STR ) ; return new  Array List <  String > ( ) ; } catch (  No Such Algorithm Exception e ) { log . error ( method Name + _ STR , e ) ; throw new  SOSFailure ( e ) ; } catch (  Uniform Interface Exception e ) { log . error ( method Name + _ STR , e ) ; throw new  SOSFailure ( e ) ; } }
public void add Task (  Runnable task ) { task List . add ( task ) ; }
public final double sample Max ( ) { synchronized ( _lock ) { long max = _max . get And Set ( _ NUM ) ; return _scale * max ; } }
public static void write File Txt (  String file Name ,  String [ ] total File ) throws  IOException { try ( final  Writer writer =  Files . new Buffered Writer (  Paths . get ( file Name ) ,  Charset . for Name ( _ STR ) ) ;  Print Writer pw = new  Print Writer ( writer ) ) { for (  String file : total File ) { pw . println ( file ) ; } } }
public synchronized void insert Chunk Auth Tag ( int chunk Idx , byte [ ] chunk Auth Tag ) throws  File Encryption Exception { if ( chunk Idx < _ NUM || chunk Auth Tag == null || chunk Auth Tag . length !=  CHUNK_ AUTH_ TAG_ LENGTH ) { throw new  File Encryption Exception ( _ STR ) ; } else { if ( atag List . size ( ) <= chunk Idx ) { atag List . ensure Capacity ( chunk Idx + _ NUM ) ; pad To ( atag List , chunk Idx ) ; atag List . add ( chunk Idx ,  Arrays . copy Of ( chunk Auth Tag ,  CHUNK_ AUTH_ TAG_ LENGTH ) ) ; } else { atag List . set ( chunk Idx ,  Arrays . copy Of ( chunk Auth Tag ,  CHUNK_ AUTH_ TAG_ LENGTH ) ) ; } } }
public <  Annotation Type extends  Annotation > void register (  Type Binder <  Annotation Type > type Binder ) { @  Nullable  Annotated Type <  Annotation Type > annotated Type =  Annotated Types . get ( type Binder . get Annotation Class ( ) , this . annotated Type ) ; if ( annotated Type != null ) { object Binders . add ( new  Annotated Type Binder < > ( type Binder , annotated Type ) ) ; } }
public static  String unescape CString (  String s ) { if ( s . index Of ( _ STR ) < _ NUM ) { return s ; }  String Builder sb = new  String Builder ( ) ; int len = s . length ( ) ; for ( int i = _ NUM ; i < len ; ) { char c = s . char At ( i ++ ) ; if ( c == _ STR && ( i < len ) ) { c = s . char At ( i ++ ) ; switch ( c ) { case _ STR : c = _ STR ; break ; case _ STR : c = _ STR ; break ; case _ STR : c = _ STR ; break ; case _ STR : c = _ STR ; break ; case _ STR : c = _ STR ; break ; case _ STR : c = _ STR ; break ; case _ STR : c = _ STR ; break ; case _ STR : c = _ STR ; break ; case _ STR : c = _ STR ; break ; case _ STR : c = _ STR ; break ; case _ STR : c = _ STR ; break ; default : { if ( ( c == _ STR ) && ( i < len ) && is Hex ( s . char At ( i ) ) ) { int v = hex Value ( s . char At ( i ++ ) ) ; if ( ( i < len ) && is Hex ( s . char At ( i ) ) ) { v = v * _ NUM + hex Value ( s . char At ( i ++ ) ) ; } c = ( char ) v ; } else if ( is Octal ( c ) ) { int v = ( c - _ STR ) ; if ( ( i < len ) && is Octal ( s . char At ( i ) ) ) { v = v * _ NUM + ( s . char At ( i ++ ) - _ STR ) ; } if ( ( i < len ) && is Octal ( s . char At ( i ) ) ) { v = v * _ NUM + ( s . char At ( i ++ ) - _ STR ) ; } c = ( char ) v ; } else { sb . append ( _ STR ) ; } break ; } } } sb . append ( c ) ; } return sb . to String ( ) ; }
public static  Document load Document (  Input Stream stream ) throws  Exception {  Document Builder Factory factory =  Document Builder Factory . new Instance ( ) ;  Document Builder builder = factory . new Document Builder ( ) ; return builder . parse ( stream ) ; }
public void add DTEDDirectory Handler (  DTEDDirectory Handler handler ) { directories . add ( handler ) ; }
public void load (  List <  Policy Information > policy Information ) {  Policy Information [ ] policy Information Array = policy Information . to Array ( new  Policy Information [ policy Information . size ( ) ] ) ;  Arrays . sort ( policy Information Array , new  Policy Information Comparator ( ) ) ; data = new  Object [ policy Information . size ( ) ] [ _ NUM ] ; int i = _ NUM ; for (  Policy Information policy Info : policy Information Array ) { data [ i ] [ _ NUM ] = policy Info ; i ++ ; } fire Table Data Changed ( ) ; }
public  Snmp Var Bind [ ] decode Var Bind List (  Ber Decoder bdec ) throws  Ber Exception { bdec . open Sequence ( ) ;  Vector <  Snmp Var Bind > tmp = new  Vector <  Snmp Var Bind > ( ) ; while ( bdec . cannot Close Sequence ( ) ) {  Snmp Var Bind bind = new  Snmp Var Bind ( ) ; bdec . open Sequence ( ) ; bind . oid = new  Snmp Oid ( bdec . fetch Oid ( ) ) ; bind . set Snmp Value ( decode Var Bind Value ( bdec ) ) ; bdec . close Sequence ( ) ; tmp . add Element ( bind ) ; } bdec . close Sequence ( ) ;  Snmp Var Bind [ ] var Bind List = new  Snmp Var Bind [ tmp . size ( ) ] ; tmp . copy Into ( var Bind List ) ; return var Bind List ; }
public static void init Urban Sim Person Writer (  Urban Sim Parameter Config Module V3 module ) { try { log . info ( _ STR ) ; person Writer =  IOUtils . get Buffered Writer ( module . get MATSim4 Opus Temp ( ) +  FILE_ NAME ) ; log . info ( _ STR + module . get MATSim4 Opus Temp ( ) +  FILE_ NAME + _ STR ) ; person Writer . write (  Internal Constants .  PERSON_ ID + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR ) ; person Writer . new Line ( ) ; log . info ( _ STR ) ; } catch (  Exception e ) { e . print Stack Trace ( ) ; } }
public void add Task (  Runnable task ) { task List . add ( task ) ; }
static char process Char Literal (  String entity ) throws  IOException ,  XMLParse Exception { if ( entity . char At ( _ NUM ) == _ STR ) { entity = entity . substring ( _ NUM , entity . length ( ) - _ NUM ) ; return ( char )  Integer . parse Int ( entity , _ NUM ) ; } else { entity = entity . substring ( _ NUM , entity . length ( ) - _ NUM ) ; return ( char )  Integer . parse Int ( entity , _ NUM ) ; } }
private void capture Different String (  String old Name ,  String new Name ,  String app Name ,  Map <  String ,  String > map ,  String default Value ) {  Reject . if Null ( app Name ) ;  Reject . if Null ( map ) ; if ( old Name == null && new Name == null ) { map . put ( app Name , default Value ) ; } else if ( new Name != null && ! new Name . equals ( old Name ) ) { map . put ( app Name , new Name ) ; } }
@  Override protected void draw XLabels (  List <  Double > x Labels ,  Double [ ] x Text Label Locations ,  Canvas canvas ,  Paint paint , int left , int top , int bottom , double x Pixels Per Unit , double min X , double max X ) { int length = x Labels . size ( ) ; if ( length > _ NUM ) { boolean show Labels = m Renderer . is Show Labels ( ) ; boolean show Grid Y = m Renderer . is Show Grid Y ( ) ;  Date Format format = get Date Format ( x Labels . get ( _ NUM ) , x Labels . get ( length - _ NUM ) ) ; for ( int i = _ NUM ; i < length ; i ++ ) { long label =  Math . round ( x Labels . get ( i ) ) ; float x Label = ( float ) ( left + x Pixels Per Unit * ( label - min X ) ) ; if ( show Labels ) { paint . set Color ( m Renderer . get XLabels Color ( ) ) ; canvas . draw Line ( x Label , bottom , x Label , bottom + m Renderer . get Labels Text Size ( ) / _ NUM , paint ) ; draw Text ( canvas , format . format ( new  Date ( label ) ) , x Label , bottom + m Renderer . get Labels Text Size ( ) * _ NUM / _ NUM + m Renderer . get XLabels Padding ( ) , paint , m Renderer . get XLabels Angle ( ) ) ; } if ( show Grid Y ) { paint . set Color ( m Renderer . get Grid Color ( _ NUM ) ) ; canvas . draw Line ( x Label , bottom , x Label , top , paint ) ; } } } draw XText Labels ( x Text Label Locations , canvas , paint , _ BOOL , left , top , bottom , x Pixels Per Unit , min X , max X ) ; }
public static byte [ ] decode From String (  String src ) { if ( src == null ) { return null ; } if ( src . length ( ) == _ NUM ) { return new byte [ _ NUM ] ; } byte [ ] result ; try { result = delegate . decode ( src . get Bytes (  DEFAULT_ CHARSET . display Name ( ) ) ) ; } catch (  Unsupported Encoding Exception e ) { throw new  Illegal State Exception ( e ) ; } return result ; }
public static  String normalize Region Name ( final  String region Name ) { if ( region Name == null || region Name . length ( ) == _ NUM ) { return  EMPTY_ VALUE ; } char [ ] result Name = new char [ region Name . length ( ) + _ NUM ] ; boolean changed = _ BOOL ; boolean is Prev Char Slash = _ BOOL ; int start Index ; if ( region Name . char At ( _ NUM ) != _ STR ) { changed = _ BOOL ; start Index = _ NUM ; } else { is Prev Char Slash = _ BOOL ; start Index = _ NUM ; } result Name [ _ NUM ] = _ STR ; int result Length = _ NUM ; for ( int index = start Index ; index < region Name . length ( ) ; ++ index ) { char curr Char = region Name . char At ( index ) ; if ( curr Char == _ STR ) { if ( is Prev Char Slash ) { changed = _ BOOL ; continue ; } is Prev Char Slash = _ BOOL ; } else { is Prev Char Slash = _ BOOL ; } result Name [ result Length ++ ] = curr Char ; } if ( result Name [ result Length - _ NUM ] == _ STR ) { -- result Length ; changed = _ BOOL ; } if ( changed ) { return new  String ( result Name , _ NUM , result Length ) ; } else { return region Name ; } }
public void register ( ) { if ( ! registered ) { if (  Install Event Handler ( ) == _ NUM ) { registered = _ BOOL ; } } }
private void load Mapped Binary (  File Input Stream is ) throws  IOException {  File Channel fc = is . get Channel ( ) ;  Mapped Byte Buffer bb = fc . map (  File Channel .  Map Mode .  READ_ ONLY , _ NUM , ( int ) fc . size ( ) ) ; bb . load ( ) ; load Database ( bb ) ; is . close ( ) ; }
private static void primitive2b (  Method Visitor mv ,  Class Node type ) {  Label true Label = new  Label ( ) ;  Label false Label = new  Label ( ) ; if ( type ==  Class Helper . double_ TYPE ) { mv . visit Insn (  DCONST_0 ) ; mv . visit Insn (  DCMPL ) ; } else if ( type ==  Class Helper . long_ TYPE ) { mv . visit Insn (  LCONST_0 ) ; mv . visit Insn (  LCMP ) ; } else if ( type ==  Class Helper . float_ TYPE ) { mv . visit Insn (  FCONST_0 ) ; mv . visit Insn (  FCMPL ) ; } else if ( type ==  Class Helper . int_ TYPE ) { } mv . visit Jump Insn (  IFEQ , false Label ) ; mv . visit Insn (  ICONST_1 ) ; mv . visit Jump Insn (  GOTO , true Label ) ; mv . visit Label ( false Label ) ; mv . visit Insn (  ICONST_0 ) ; mv . visit Label ( true Label ) ; }
public void clear Sections ( ) { sections . clear ( ) ; fire Update Event (  SECTION_ EVENT ) ; }
public  String comment ( ) throws  Parse Exception {  String Builder retval = new  String Builder ( ) ; if ( look Ahead ( _ NUM ) != _ STR ) return null ; consume ( _ NUM ) ; while ( _ BOOL ) { char next = get Next Char ( ) ; if ( next == _ STR ) { break ; } else if ( next == _ STR ) { throw new  Parse Exception ( this . buffer + _ STR , this . ptr ) ; } else if ( next == _ STR ) { retval . append ( next ) ; next = get Next Char ( ) ; if ( next == _ STR ) throw new  Parse Exception ( this . buffer + _ STR , this . ptr ) ; retval . append ( next ) ; } else { retval . append ( next ) ; } } return retval . to String ( ) ; }
public synchronized void remove Session (  Session session ) { if ( session != null ) { if ( exclusive Session == session ) { exclusive Session = null ; } user Sessions . remove ( session ) ; if ( session != system Session && session != lob Session ) { trace . info ( _ STR , session . get Id ( ) ) ; } } if ( user Sessions . size ( ) == _ NUM && session != system Session && session != lob Session ) { if ( close Delay == _ NUM ) { close ( _ BOOL ) ; } else if ( close Delay < _ NUM ) { return ; } else { delayed Closer = new  Database Closer ( this , close Delay * _ NUM , _ BOOL ) ; delayed Closer . set Name ( _ STR + get Short Name ( ) ) ; delayed Closer . set Daemon ( _ BOOL ) ; delayed Closer . start ( ) ; } } if ( session != system Session && session != lob Session && session != null ) { trace . info ( _ STR , session . get Id ( ) ) ; } }
public boolean equals (  Object o ) { if ( o instanceof  Coverage Char Vdt ) {  Coverage Char Vdt civ = (  Coverage Char Vdt ) o ; return ( ( attribute == civ . attribute ) && ( value == civ . value ) ) ; } else { return _ BOOL ; } }
public static void ensure Directory (  String ... file Paths ) { if ( file Paths != null ) {  File file ; for (  String file Path : file Paths ) { file = new  File ( file Path ) ; if ( file . exists ( ) && ! file . is Directory ( ) ) { throw new  Illegal Argument Exception ( _ STR + file . get Absolute Path ( ) ) ; } else if ( ! file . exists ( ) ) { if ( ! file . mkdirs ( ) ) { throw new  Illegal State Exception ( _ STR + file . get Absolute Path ( ) ) ; } } } } }
public void test Pos Neg First Shorter ( ) { byte a Bytes [ ] = { - _ NUM , - _ NUM , - _ NUM , - _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM } ; byte b Bytes [ ] = { - _ NUM , _ NUM , _ NUM , _ NUM , - _ NUM , - _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , - _ NUM , _ NUM , _ NUM , - _ NUM , _ NUM , _ NUM , - _ NUM , - _ NUM } ; int a Sign = _ NUM ; int b Sign = - _ NUM ; byte r Bytes [ ] = { _ NUM , - _ NUM , - _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM } ;  Big Integer a Number = new  Big Integer ( a Sign , a Bytes ) ;  Big Integer b Number = new  Big Integer ( b Sign , b Bytes ) ;  Big Integer result = a Number . and ( b Number ) ; byte res Bytes [ ] = new byte [ r Bytes . length ] ; res Bytes = result . to Byte Array ( ) ; for ( int i = _ NUM ; i < res Bytes . length ; i ++ ) { assert True ( res Bytes [ i ] == r Bytes [ i ] ) ; } assert Equals ( _ STR , _ NUM , result . signum ( ) ) ; }
public  Activity current Activity ( ) {  Activity activity = activity Stack . last Element ( ) ; return activity ; }
@  Override public synchronized void stop ( ) {  LOGGER . info ( _ STR ) ; timer . cancel ( ) ; running = _ BOOL ; }
public static  URL string To Url (  String url String ) {  URL url = null ; try { url = new  URL ( url String ) ; final  URI uri = new  URI ( url . get Protocol ( ) , url . get User Info ( ) , url . get Host ( ) , url . get Port ( ) , url . get Path ( ) , url . get Query ( ) , url . get Ref ( ) ) ; url = uri . to URL ( ) ; } catch (  Exception e ) { try { url = new  URL ( url String ) ; } catch (  Malformed URLException e2 ) {  Log . d ( _ STR , _ STR + url String + _ STR , e2 ) ; } } return url ; }
private int adjust Column ( int row , int col ) { if ( col < _ NUM ) { return _ NUM ; } if ( row == get Row Count ( ) - _ NUM ) { int last Row Count = model . get Byte Count ( ) % _ NUM ; if ( last Row Count == _ NUM ) { last Row Count = _ NUM ; } if ( last Row Count < _ NUM ) { return  Math . min ( col , ( model . get Byte Count ( ) % _ NUM ) - _ NUM ) ; } } return  Math . min ( col , get Column Count ( ) - _ NUM - _ NUM ) ; }
public  Connection Pool ( ) { this ( _ NUM , _ NUM ,  Time Unit .  MINUTES ) ; }
public static _ Fields find By Thrift Id ( int field Id ) { switch ( field Id ) { case _ NUM : return  NAME ; case _ NUM : return  VALUE ; default : return null ; } }
public  String to String ( ) { return super . to String ( ) + _ STR +  String . value Of ( names ) + _ STR ; }
public final void build Signed Directory ( ) throws  Exception { try (  Byte Array Output Stream mime Content = new  Byte Array Output Stream ( ) ) { build ( mime Content ) ; log . debug ( _ STR , mime Content . to String ( ) ) ; byte [ ] content Bytes = mime Content . to Byte Array ( ) ; mime Content . reset ( ) ; sign ( content Bytes , mime Content ) ;  Files . write ( temp Conf Path , mime Content . to Byte Array ( ) ) ; log . debug ( _ STR , temp Conf Path ) ; } }
static boolean is White Space (  String Buffer buf ) { int n = buf . length ( ) ; for ( int i = _ NUM ; i < n ; i ++ ) { if ( ! is White Space ( buf . char At ( i ) ) ) return _ BOOL ; } return _ BOOL ; }
public static  Object deserialize Object ( final byte [ ] obj Bytes ) throws  IOException ,  Class Not Found Exception {  Object Input Stream obj In = null ; try { obj In = new  Object Input Stream ( new  Byte Array Input Stream ( obj Bytes ) ) ; return obj In . read Object ( ) ; } finally { close ( obj In ) ; } }
public  Interval overlap (  Readable Interval interval ) { interval =  Date Time Utils . get Readable Interval ( interval ) ; if ( overlaps ( interval ) == _ BOOL ) { return null ; } long start =  Math . max ( get Start Millis ( ) , interval . get Start Millis ( ) ) ; long end =  Math . min ( get End Millis ( ) , interval . get End Millis ( ) ) ; return new  Interval ( start , end , get Chronology ( ) ) ; }
public int count ( ) { return dict . size ( ) ; }
public void add Item To Shopping Cart (  Shopping Cart Item item ) { if ( item == null ) { throw new  Invalid Parameter Exception ( _ STR ) ; } shopping Cart Items . add ( item ) ; }
private void update Base Matrix (  Drawable d ) {  Image View image View = get Image View ( ) ; if ( null == image View || null == d ) { return ; } final float view Width = image View . get Width ( ) ; final float view Height = image View . get Height ( ) ; final int drawable Width = d . get Intrinsic Width ( ) ; final int drawable Height = d . get Intrinsic Height ( ) ; m Base Matrix . reset ( ) ; final float width Scale = view Width / drawable Width ; final float height Scale = view Height / drawable Height ; if ( m Scale Type ==  Scale Type .  CENTER ) { m Base Matrix . post Translate ( ( view Width - drawable Width ) / _ NUM , ( view Height - drawable Height ) / _ NUM ) ; } else if ( m Scale Type ==  Scale Type .  CENTER_ CROP ) { float scale =  Math . max ( width Scale , height Scale ) ; m Base Matrix . post Scale ( scale , scale ) ; m Base Matrix . post Translate ( ( view Width - drawable Width * scale ) / _ NUM , ( view Height - drawable Height * scale ) / _ NUM ) ; } else if ( m Scale Type ==  Scale Type .  CENTER_ INSIDE ) { float scale =  Math . min ( _ NUM ,  Math . min ( width Scale , height Scale ) ) ; m Base Matrix . post Scale ( scale , scale ) ; m Base Matrix . post Translate ( ( view Width - drawable Width * scale ) / _ NUM , ( view Height - drawable Height * scale ) / _ NUM ) ; } else {  Rect F m Temp Src = new  Rect F ( _ NUM , _ NUM , drawable Width , drawable Height ) ;  Rect F m Temp Dst = new  Rect F ( _ NUM , _ NUM , view Width , view Height ) ; switch ( m Scale Type ) { case  FIT_ CENTER : m Base Matrix . set Rect To Rect ( m Temp Src , m Temp Dst ,  Scale To Fit .  CENTER ) ; break ; case  FIT_ START : m Base Matrix . set Rect To Rect ( m Temp Src , m Temp Dst ,  Scale To Fit .  START ) ; break ; case  FIT_ END : m Base Matrix . set Rect To Rect ( m Temp Src , m Temp Dst ,  Scale To Fit .  END ) ; break ; case  FIT_ XY : m Base Matrix . set Rect To Rect ( m Temp Src , m Temp Dst ,  Scale To Fit .  FILL ) ; break ; default : break ; } } reset Matrix ( ) ; }
public static double sample Kurtosis Standard Error ( int size ) { int n = size ; return  Math . sqrt ( _ NUM * n * ( n - _ NUM ) * ( n - _ NUM ) / ( ( n - _ NUM ) * ( n - _ NUM ) * ( n + _ NUM ) * ( n + _ NUM ) ) ) ; }
public void manage List (  List <  Span > spans ) { managed Lists . add ( spans ) ; }
static public  Analysis Context current Analysis Context ( ) { return current Analysis Context . get ( ) ; }
private static  String map To Text ( ) { final  String Buffer buffer = new  String Buffer ( ) ; for ( final  Map .  Entry <  Long ,  Integer > entry : m_count Map . entry Set ( ) ) { buffer . append (  String . format ( _ STR , entry . get Key ( ) , entry . get Value ( ) ) ) ; } return buffer . to String ( ) ; }
public  Monetary Format positive Sign ( char positive Sign ) { check Argument ( !  Character . is Digit ( positive Sign ) ) ; if ( positive Sign == this . positive Sign ) return this ; else return new  Monetary Format ( negative Sign , positive Sign , zero Digit , decimal Mark , min Decimals , decimal Groups , shift , rounding Mode , codes , code Separator , code Prefixed ) ; }
public  String ( byte [ ] bytes , java . lang .  String enc ) throws java . io .  Unsupported Encoding Exception { this ( bytes To Chars ( bytes , _ NUM , bytes . length , enc ) ) ; }
public  Equipment Alive Sender ( final  IProcess Message Sender process Message Sender , final  Long alive Tag Id , final  Equipment Logger Factory equipment Logger Factory ) { this . process Message Sender = process Message Sender ; this . alive Tag Id = alive Tag Id ; this . equipment Logger = equipment Logger Factory . get Equipment Logger ( get Class ( ) ) ; }
public  String decode (  Abstract Message msg ,  Boolean ext , int header ) {  String str =  Cbus Op Codes . decode ( msg , ext , header ) ; return ( str ) ; }
private boolean classify Example (  Instance example ) throws  Exception { double class Value = - _ NUM ; for (  Enumeration <  Rule List > e = new  Weka Enumeration <  Rule List > ( m_ Decision List ) ; e . has More Elements ( ) && class Value < _ NUM ; ) {  Rule List rl = e . next Element ( ) ; class Value = rl . classify Instance ( example ) ; } if ( class Value >= _ NUM ) { example . set Class Value ( class Value ) ; return _ BOOL ; } else { return _ BOOL ; } }
@  Override public int hash Code ( ) { return  System . identity Hash Code ( this ) ; }
private  Text IO ( ) { }
public void decrypt (  Key Parameter aes Key ) { lock . lock ( ) ; try { check State ( get Encryption Type ( ) !=  Encryption Type .  UNENCRYPTED , _ STR ) ; check Not Null ( key Crypter ) ;  Array List <  ECKey > decrypted Key Chain = new  Array List <  ECKey > ( ) ; for (  ECKey key : keychain ) { if ( ! key . is Encrypted ( ) ) { decrypted Key Chain . add ( key ) ; } else {  ECKey decrypted ECKey = key . decrypt ( key Crypter , aes Key ) ; decrypted Key Chain . add ( decrypted ECKey ) ; } } keychain = decrypted Key Chain ; key Crypter = null ; extensions . remove (  Multi Bit Wallet Protobuf Serializer .  ORG_ MULTIBIT_ WALLET_ PROTECT_2 ) ; } finally { lock . unlock ( ) ; } }
public void add Chunk ( byte [ ] data ) { cache . write ( data , _ NUM , data . length ) ; current Size += data . length ; }
private void process Users (  Local Container container ,  File config Overrides ) throws  IOException {  List <  User > user List = get Users ( ) ; if ( user List != null ) {  Map <  String ,  List <  String > > groups = new  Hash Map <  String ,  List <  String > > ( ) ;  Map <  String ,  String > users = new  Hash Map <  String ,  String > ( ) ; for (  User u : user List ) { users . put ( u . get Name ( ) , u . get Password ( ) ) ; for (  String group : u . get Roles ( ) ) {  List <  String > members = groups . get ( group ) ; if ( members == null ) { members = new  Array List <  String > ( ) ; groups . put ( group , members ) ; } members . add ( u . get Name ( ) ) ; } } write User Registry ( container , config Overrides , users , groups ) ; } }
@  Gen Ignore static  Record create Record (  String name ,  String address ,  Class type ,  Json Object metadata ) { return create Record ( name , address , type != null ? type . get Name ( ) : null , metadata ) ; }
public void start ( ) throws  IOException { this . is Running = _ BOOL ;  Thread thread = new  Thread ( this ) ; thread . set Daemon ( _ BOOL ) ; thread . set Name ( _ STR ) ; thread . set Priority (  Thread .  MAX_ PRIORITY ) ; thread . start ( ) ; }
public synchronized void insert Audio (  String inputtype ,  String locale ,  String voice ,  String outputparams ,  String style ,  String effects ,  String inputtext , byte [ ] audio ) throws  SQLException { if ( inputtype == null || locale == null || voice == null || inputtext == null ) { throw new  Null Pointer Exception ( _ STR ) ; } if ( lookup Audio ( inputtype , locale , voice , outputparams , style , effects , inputtext ) != null ) { return ; }  String query = _ STR + inputtype + _ STR + locale + _ STR + voice + _ STR + outputparams + _ STR + style + _ STR + effects + _ STR ;  Prepared Statement st = connection . prepare Statement ( query ) ; st . set String ( _ NUM , inputtext ) ; st . set Bytes ( _ NUM , audio ) ; st . execute Update ( ) ; st . close ( ) ; }
public  And Condition ( final  Chat Condition ... condition ) { this . conditions =  Arrays . as List ( condition ) ; }
public final void read ( final byte [ ] buffer ) throws  IOException { byte Buffer . get ( buffer ) ; }
public void find Package And Class ( ) throws  IOException { package Name = null ; class Name = null ;  Line Number Reader reader = new  Line Number Reader ( new  File Reader ( input File ) ) ; while ( class Name == null || package Name == null ) {  String line = reader . read Line ( ) ; if ( line == null ) break ; if ( package Name == null ) { int index = line . index Of ( _ STR ) ; if ( index >= _ NUM ) { index += _ NUM ; int end = line . index Of ( _ STR , index ) ; if ( end >= index ) { package Name = line . substring ( index , end ) ; package Name = package Name . trim ( ) ; } } } if ( class Name == null ) { int index = line . index Of ( _ STR ) ; if ( index >= _ NUM ) { index += _ NUM ; class Name = line . substring ( index ) ; class Name = class Name . trim ( ) ; } } } if ( class Name == null ) class Name = _ STR ; }
public static  Set <  URI > fetch SRDFTarget Virtual Pools (  Db Client db Client ) {  Set <  URI > srdf Protected Target VPools = new  Hash Set <  URI > ( ) ; try {  List <  URI > vpool Remote Setting URIs = db Client . query By Type (  Vpool Remote Copy Protection Settings . class , _ BOOL ) ;  Iterator <  Vpool Remote Copy Protection Settings > v Pool Remote Settings Itr = db Client . query Iterative Objects (  Vpool Remote Copy Protection Settings . class , vpool Remote Setting URIs , _ BOOL ) ; while ( v Pool Remote Settings Itr . has Next ( ) ) {  Vpool Remote Copy Protection Settings r Setting = v Pool Remote Settings Itr . next ( ) ; if ( null != r Setting && !  Null Column Value Getter . is Null URI ( r Setting . get Virtual Pool ( ) ) ) { srdf Protected Target VPools . add ( r Setting . get Virtual Pool ( ) ) ; } } } catch (  Exception ex ) { log . error ( _ STR , ex ) ; } return srdf Protected Target VPools ; }
public static int cardinality ( long [ ] v ) { int sum = _ NUM ; for ( int i = _ NUM ; i < v . length ; i ++ ) { sum +=  Long . bit Count ( v [ i ] ) ; } return sum ; }
public static  String literal To String ( long lit ,  Arg Type type ) { if ( type == null || ! type . is Type Known ( ) ) {  String n =  Long . to String ( lit ) ; if (  Math . abs ( lit ) > _ NUM ) { n += _ STR +  Long . to Hex String ( lit ) + _ STR +  Float . int Bits To Float ( ( int ) lit ) + _ STR +  Double . long Bits To Double ( lit ) ; } return n ; } switch ( type . get Primitive Type ( ) ) { case  BOOLEAN : return lit == _ NUM ? _ STR : _ STR ; case  CHAR : return  String Utils . unescape Char ( ( char ) lit ) ; case  BYTE : return format Byte ( ( byte ) lit ) ; case  SHORT : return format Short ( ( short ) lit ) ; case  INT : return format Integer ( ( int ) lit ) ; case  LONG : return format Long ( lit ) ; case  FLOAT : return format Float (  Float . int Bits To Float ( ( int ) lit ) ) ; case  DOUBLE : return format Double (  Double . long Bits To Double ( lit ) ) ; case  OBJECT : case  ARRAY : if ( lit != _ NUM ) {  LOG . warn ( _ STR , lit , type ) ; return  Long . to String ( lit ) ; } return _ STR ; default : throw new  Jadx Runtime Exception ( _ STR + type ) ; } }
public static void e (  String msg ,  Object ... args ) { if ( ! allow E ) return ;  Stack Trace Element caller = get Caller Stack Trace Element ( ) ;  String tag = generate Tag ( caller ) ; if ( s Level >  LEVEL_ ERROR ) { return ; } if ( args . length > _ NUM ) { msg =  String . format ( msg , args ) ; }  Log . e ( tag , msg ) ; }
public  DImport Key Pair Type (  JFrame parent ) { super ( parent ,  Dialog .  Modality Type .  DOCUMENT_ MODAL ) ; set Title ( res . get String ( _ STR ) ) ; init Components ( ) ; }
private int insert Test Data Offset DTTypes (  Prepared Statement pstmt ) throws  Exception { pstmt . set Int ( _ NUM , _ NUM ) ; pstmt . set Object ( _ NUM , test Offset Time ,  JDBCType .  VARCHAR ) ; pstmt . set Object ( _ NUM , test Offset Time ) ; pstmt . set Object ( _ NUM , test Offset Date Time ,  JDBCType .  VARCHAR ) ; pstmt . set Object ( _ NUM , test Offset Date Time ) ; assert Equals ( _ NUM , pstmt . execute Update ( ) ) ; if ( pstmt instanceof  Callable Statement ) {  Callable Statement cstmt = (  Callable Statement ) pstmt ; cstmt . set Int ( _ STR , _ NUM ) ; cstmt . set Object ( _ STR , test Offset Time ,  JDBCType .  VARCHAR ) ; cstmt . set Object ( _ STR , test Offset Time ) ; cstmt . set Object ( _ STR , test Offset Date Time ,  JDBCType .  VARCHAR ) ; cstmt . set Object ( _ STR , test Offset Date Time ) ; assert Equals ( _ NUM , cstmt . execute Update ( ) ) ; return _ NUM ; } return _ NUM ; }
public void add Listener ( final  L listener ) {  Validate . not Null ( listener , _ STR ) ; listeners . add ( listener ) ; }
@  Override public void run ( ) { while ( ! stop Hide ) { print ( _ STR ) ; try {  Thread . sleep ( _ NUM ) ; } catch (  Interrupted Exception e ) { } } }
private synchronized void read Object ( java . io .  Object Input Stream s ) throws  IOException ,  Class Not Found Exception { s . default Read Object ( ) ; init ( get Name ( ) , get Mask ( actions ) ) ; }
public void clear Row ( int node Index , int row Index ) { for ( int col Index = _ NUM ; col Index < get Num Columns ( node Index ) ; col Index ++ ) { set Probability ( node Index , row Index , col Index ,  Double .  Na N ) ; } }
public static void play Sound Buffer ( byte [ ] wav Data ) { jmri . jmrit . sound .  Wav Buffer wb = new jmri . jmrit . sound .  Wav Buffer ( wav Data ) ; float sample Rate = wb . get Sample Rate ( ) ; int sample Size In Bits = wb . get Sample Size In Bits ( ) ; int channels = wb . get Channels ( ) ; boolean signed = wb . get Signed ( ) ; boolean big Endian = wb . get Big Endian ( ) ;  Audio Format format = new  Audio Format ( sample Rate , sample Size In Bits , channels , signed , big Endian ) ;  Source Data Line line ;  Data Line .  Info info = new  Data Line .  Info (  Source Data Line . class , format ) ; if ( !  Audio System . is Line Supported ( info ) ) { log . warn ( _ STR + info ) ; return ; } try { line = (  Source Data Line )  Audio System . get Line ( info ) ; line . open ( format ) ; } catch (  Line Unavailable Exception ex ) { log . error ( _ STR + ex ) ; return ; } line . start ( ) ; line . write ( wav Data , _ NUM , wav Data . length ) ; }
public static byte [ ] decode (  String s ) { return decode ( s ,  NO_ OPTIONS ) ; }
@  Suppress Warnings ( _ STR ) public static void add File (  File f ) throws  IOException { add URL ( f . to URL ( ) ) ; }
public static  String escape (  String string ) { if ( string == null || string . equals ( _ STR ) ) { return string ; }  String prefix = _ STR ; if ( string . index Of ( _ STR ) != - _ NUM ) { prefix = string . substring ( _ NUM , string . index Of ( _ STR ) + _ NUM ) ; string = string . replace First ( prefix , _ STR ) ; } string = string . replace All ( _ STR , _ STR ) ; if ( string . starts With ( _ STR ) ) { string = _ STR + string . replace All ( _ STR , _ STR ) ; } else { string = string . replace All ( _ STR , _ STR ) ; } return prefix . concat ( string ) ; }
@  Override public  Env Var add New Env Var (  String name ,  Class < ? > type ,  String value ) {  Env Var env Var = null ; if ( ! exist ( name ) ) { env Var = new  Env Var ( name , type , _ BOOL ) ; env Var . set Value ( value ) ; env Var List . add ( env Var ) ; } return env Var ; }
public void make Class (  String str , boolean caseless ) { for ( int i = _ NUM ; i < str . length ( ) ; ) { int ch = str . code Point At ( i ) ; make Class ( ch , caseless ) ; i +=  Character . char Count ( ch ) ; } }
private void update Time Stamp ( ) { time Stamp MS =  System . current Time Millis ( ) ; }
@  Override public boolean has (  Pattern pattern ) { final  Matcher matcher = pattern . matcher ( rest ( ) ) ; return matcher . find ( ) && matcher . start ( ) == _ NUM ; }
protected static byte [ ] input Stream To Byte Array (  Input Stream str ) throws  IOException { try (  Byte Array Output Stream baos = new  Byte Array Output Stream ( ) ) { int len = _ NUM ; byte [ ] buf = new byte [ _ NUM ] ; while ( ( len = str . read ( buf ) ) != - _ NUM ) { baos . write ( buf , _ NUM , len ) ; } return baos . to Byte Array ( ) ; } }
public  Builder add Content Item (  Content Item content Item ) { if ( content Items == null ) { content Items = new  Array List <  Content Item > ( ) ; content Type =  Http Media Type .  APPLICATION_ JSON ; } content Items . add ( content Item ) ; return this ; }
private  String encode To String (  String in , int flags ) throws  Exception {  String b64 =  Base64 . encode To String ( in . get Bytes ( ) , flags ) ;  String dec = decode String ( b64 ) ; assert Equals ( in , dec ) ; return b64 ; }
public double min ( ) { if ( is Sparse ( ) && nnz ( ) < length ( ) ) { double min = _ NUM ; for (  Index Value iv : this ) min =  Math . min ( min , iv . get Value ( ) ) ; return min ; } else { double min = get ( _ NUM ) ; for ( int i = _ NUM ; i < length ( ) ; i ++ ) min =  Math . min ( min , get ( i ) ) ; return min ; } }
public  String emit Pattern ( ) { return emit Pattern ( _ BOOL ) ; }
public boolean is Update Completed ( ) { return update Completed . get ( ) ; }
public void repaint (  Rectangle r ) { repaint ( _ NUM , r . x , r . y , r . width , r . height ) ; }
private static  Char Handler parse Unprintable Codes (  String [ ] code Strings ) { if ( code Strings . length != _ NUM ) { throw new  Illegal State Exception ( _ STR +  Arrays . as List ( code Strings ) ) ; } return new  Unprintable Char Handler ( codes To Bytes ( code Strings [ _ NUM ] , _ BOOL ) ) ; }
@  Override public int pending Count ( ) { return get Pending Count ( ) ; }
@  Suppress Warnings ( _ STR ) public static float percentage To Value ( float percentage , float start Value , float end Value ) { float min =  Math . min ( start Value , end Value ) ; float max =  Math . max ( start Value , end Value ) ; float delta = max - min ; return ( delta * ( percentage / _ NUM ) ) + min ; }
public static boolean is Network Connected (  Context context ) { if ( context == null ) { return _ BOOL ; }  Connectivity Manager cm = (  Connectivity Manager ) context . get System Service (  Context .  CONNECTIVITY_ SERVICE ) ;  Network Info network Info = cm . get Active Network Info ( ) ; return ( network Info != null && network Info . is Connected ( ) ) ; }
public void update Item ( int position ,  Object o ) { if ( ! is Data List Empty ( ) && position >= _ NUM && position < m Data List . size ( ) ) { m Data List . set ( position , o ) ; notify Item Changed ( position ) ; } }
private static void nio Copy (  File Output Stream fos ,  File Input Stream fis ) throws  IOException {  File Channel out Channel = fos . get Channel ( ) ;  File Channel in Channel = fis . get Channel ( ) ; long length = in Channel . size ( ) ; long offset = _ NUM ; while ( _ BOOL ) { long remaining = length - offset ; long to Transfer = remaining <  MAX_ TRANSFER_ SIZE ? remaining :  MAX_ TRANSFER_ SIZE ; long transferred Bytes = in Channel . transfer To ( offset , to Transfer , out Channel ) ; offset += transferred Bytes ; length = in Channel . size ( ) ; if ( offset >= length ) { break ; } } }
private void apply Image Matrix ( float width , float height , boolean center , boolean animate ) { if ( m Bitmap != null && width > _ NUM && height > _ NUM ) { m Image Matrix . invert ( m Image Inverse Matrix ) ;  Rect F crop Rect = m Crop Overlay View . get Crop Window Rect ( ) ; m Image Inverse Matrix . map Rect ( crop Rect ) ; m Image Matrix . reset ( ) ; m Image Matrix . post Translate ( ( width - m Bitmap . get Width ( ) ) / _ NUM , ( height - m Bitmap . get Height ( ) ) / _ NUM ) ; map Image Points By Image Matrix ( ) ; if ( m Degrees Rotated > _ NUM ) { m Image Matrix . post Rotate ( m Degrees Rotated ,  Bitmap Utils . get Rect Center X ( m Image Points ) ,  Bitmap Utils . get Rect Center Y ( m Image Points ) ) ; map Image Points By Image Matrix ( ) ; } float scale =  Math . min ( width /  Bitmap Utils . get Rect Width ( m Image Points ) , height /  Bitmap Utils . get Rect Height ( m Image Points ) ) ; if ( m Scale Type ==  Scale Type .  FIT_ CENTER || ( m Scale Type ==  Scale Type .  CENTER_ INSIDE && scale < _ NUM ) || ( scale > _ NUM && m Auto Zoom Enabled ) ) { m Image Matrix . post Scale ( scale , scale ,  Bitmap Utils . get Rect Center X ( m Image Points ) ,  Bitmap Utils . get Rect Center Y ( m Image Points ) ) ; map Image Points By Image Matrix ( ) ; } m Image Matrix . post Scale ( m Zoom , m Zoom ,  Bitmap Utils . get Rect Center X ( m Image Points ) ,  Bitmap Utils . get Rect Center Y ( m Image Points ) ) ; map Image Points By Image Matrix ( ) ; m Image Matrix . map Rect ( crop Rect ) ; if ( center ) { m Zoom Offset X = width >  Bitmap Utils . get Rect Width ( m Image Points ) ? _ NUM :  Math . max (  Math . min ( width / _ NUM - crop Rect . center X ( ) , -  Bitmap Utils . get Rect Left ( m Image Points ) ) , get Width ( ) -  Bitmap Utils . get Rect Right ( m Image Points ) ) / m Zoom ; m Zoom Offset Y = height >  Bitmap Utils . get Rect Height ( m Image Points ) ? _ NUM :  Math . max (  Math . min ( height / _ NUM - crop Rect . center Y ( ) , -  Bitmap Utils . get Rect Top ( m Image Points ) ) , get Height ( ) -  Bitmap Utils . get Rect Bottom ( m Image Points ) ) / m Zoom ; } else { m Zoom Offset X =  Math . min (  Math . max ( m Zoom Offset X * m Zoom , - crop Rect . left ) , - crop Rect . right + width ) / m Zoom ; m Zoom Offset Y =  Math . min (  Math . max ( m Zoom Offset Y * m Zoom , - crop Rect . top ) , - crop Rect . bottom + height ) / m Zoom ; } m Image Matrix . post Translate ( m Zoom Offset X * m Zoom , m Zoom Offset Y * m Zoom ) ; crop Rect . offset ( m Zoom Offset X * m Zoom , m Zoom Offset Y * m Zoom ) ; m Crop Overlay View . set Crop Window Rect ( crop Rect ) ; map Image Points By Image Matrix ( ) ; if ( animate ) { m Animation . set End State ( m Image Points , m Image Matrix ) ; m Image View . start Animation ( m Animation ) ; } else { m Image View . set Image Matrix ( m Image Matrix ) ; } update Image Bounds ( _ BOOL ) ; } }
public static void add Startup Listener (  Start Up Listener s ) { s_startup Listeners . add ( s ) ; }
public static void close Quiet ( @  Nullable  Context rsrc ) { if ( rsrc != null ) try { rsrc . close ( ) ; } catch (  Naming Exception ignored ) { } }
public static <  T >  Completable Future <  T > wait For All (  List <  Completable Future <  T > > futures ) { if ( futures . is Empty ( ) ) { return  Completable Future . completed Future ( null ) ; } final  Completable Future <  T > composite Future = new  Completable Future < > ( ) ; final  Atomic Integer count = new  Atomic Integer ( futures . size ( ) ) ; final  Atomic Reference <  Throwable > exception = new  Atomic Reference < > ( ) ; for (  Completable Future <  T > future : futures ) { future . when Complete ( null ) ; } return composite Future ; }
private static  Key create DESKey ( final byte [ ] bytes , final int offset ) { final byte [ ] key Bytes = new byte [ _ NUM ] ;  System . arraycopy ( bytes , offset , key Bytes , _ NUM , _ NUM ) ; final byte [ ] material = new byte [ _ NUM ] ; material [ _ NUM ] = key Bytes [ _ NUM ] ; material [ _ NUM ] = ( byte ) ( key Bytes [ _ NUM ] << _ NUM | ( key Bytes [ _ NUM ] & _ NUM ) > > > _ NUM ) ; material [ _ NUM ] = ( byte ) ( key Bytes [ _ NUM ] << _ NUM | ( key Bytes [ _ NUM ] & _ NUM ) > > > _ NUM ) ; material [ _ NUM ] = ( byte ) ( key Bytes [ _ NUM ] << _ NUM | ( key Bytes [ _ NUM ] & _ NUM ) > > > _ NUM ) ; material [ _ NUM ] = ( byte ) ( key Bytes [ _ NUM ] << _ NUM | ( key Bytes [ _ NUM ] & _ NUM ) > > > _ NUM ) ; material [ _ NUM ] = ( byte ) ( key Bytes [ _ NUM ] << _ NUM | ( key Bytes [ _ NUM ] & _ NUM ) > > > _ NUM ) ; material [ _ NUM ] = ( byte ) ( key Bytes [ _ NUM ] << _ NUM | ( key Bytes [ _ NUM ] & _ NUM ) > > > _ NUM ) ; material [ _ NUM ] = ( byte ) ( key Bytes [ _ NUM ] << _ NUM ) ; odd Parity ( material ) ; return new  Secret Key Spec ( material , _ STR ) ; }
public static  Js Date to Js (  Date java ) { return java == null ? null : create ( java . get Time ( ) ) ; }
@  Override public  String to String ( ) {  String Builder sb = new  String Builder ( _ STR ) ; sb . append ( _ STR ) ; sb . append ( get Tool Tip Text ( ) ) ; return sb . to String ( ) ; }
private boolean scan Expr (  Symbol Table symbol Table ,  Tokens tokens ,  String data , int current Offset , int end Offset ) throws  XNIException { int ch ; int name Offset ;  String name Handle = null ; while ( _ BOOL ) { if ( current Offset == end Offset ) { break ; } ch = data . char At ( current Offset ) ; byte chartype = ( ch >= _ NUM ) ?  CHARTYPE_ NONASCII : f ASCIIChar Map [ ch ] ; switch ( chartype ) { case  CHARTYPE_ SLASH : if ( ++ current Offset == end Offset ) { return _ BOOL ; } add Token ( tokens ,  Tokens .  XPTRTOKEN_ ELEM_ CHILD ) ; ch = data . char At ( current Offset ) ; int child = _ NUM ; while ( ch >= _ STR && ch <= _ STR ) { child = ( child * _ NUM ) + ( ch - _ STR ) ; if ( ++ current Offset == end Offset ) { break ; } ch = data . char At ( current Offset ) ; } if ( child == _ NUM ) { report Error ( _ STR , new  Object [ ] { new  Character ( ( char ) ch ) } ) ; return _ BOOL ; } tokens . add Token ( child ) ; break ; case  CHARTYPE_ DIGIT : case  CHARTYPE_ LETTER : case  CHARTYPE_ MINUS : case  CHARTYPE_ NONASCII : case  CHARTYPE_ OTHER : case  CHARTYPE_ PERIOD : case  CHARTYPE_ UNDERSCORE : name Offset = current Offset ; current Offset = scan NCName ( data , end Offset , current Offset ) ; if ( current Offset == name Offset ) { report Error ( _ STR , new  Object [ ] { data } ) ; return _ BOOL ; } if ( current Offset < end Offset ) { ch = data . char At ( current Offset ) ; } else { ch = - _ NUM ; } name Handle = symbol Table . add Symbol ( data . substring ( name Offset , current Offset ) ) ; add Token ( tokens ,  Tokens .  XPTRTOKEN_ ELEM_ NCNAME ) ; tokens . add Token ( name Handle ) ; break ; } } return _ BOOL ; }
public void add Line Data ( int input Start Line ,  String input File Name , int input Line Count , int output Start Line , int output Line Increment ) { int file Index = file Path List . index Of ( input File Name ) ; if ( file Index == - _ NUM ) throw new  Illegal Argument Exception ( _ STR + input File Name ) ; if ( output Start Line == _ NUM ) return ;  Line Info li = new  Line Info ( ) ; li . set Input Start Line ( input Start Line ) ; li . set Input Line Count ( input Line Count ) ; li . set Output Start Line ( output Start Line ) ; li . set Output Line Increment ( output Line Increment ) ; if ( file Index != last File ID ) li . set Line File ID ( file Index ) ; last File ID = file Index ; line Data . add ( li ) ; }
public static void open Share Dialog (  Context context ,  String title , @  Suppress Warnings ( _ STR )  String uri ,  String share Text ,  String share Subject ) {  Intent share = new  Intent (  Intent .  ACTION_ SEND ) ; share . set Type ( _ STR ) ; share . put Extra (  Intent .  EXTRA_ TEXT , share Text ) ; share . put Extra (  Intent .  EXTRA_ SUBJECT , share Subject ) ; if ( !  Text Utils . is Empty ( uri ) ) { share . set Type ( _ STR ) ; share . put Extra (  Intent .  EXTRA_ STREAM ,  Uri . parse ( uri ) ) ; } context . start Activity (  Intent . create Chooser ( share , title ) ) ; }
public static  Range iterate To Find ZBounds (  XYZDataset dataset ,  List visible Series Keys ,  Range x Range , boolean include Interval ) {  Param Checks . null Not Permitted ( dataset , _ STR ) ;  Param Checks . null Not Permitted ( visible Series Keys , _ STR ) ;  Param Checks . null Not Permitted ( x Range , _ STR ) ; double minimum =  Double .  POSITIVE_ INFINITY ; double maximum =  Double .  NEGATIVE_ INFINITY ;  Iterator iterator = visible Series Keys . iterator ( ) ; while ( iterator . has Next ( ) ) {  Comparable series Key = (  Comparable ) iterator . next ( ) ; int series = dataset . index Of ( series Key ) ; int item Count = dataset . get Item Count ( series ) ; for ( int item = _ NUM ; item < item Count ; item ++ ) { double x = dataset . get XValue ( series , item ) ; double z = dataset . get ZValue ( series , item ) ; if ( x Range . contains ( x ) ) { if ( !  Double . is Na N ( z ) ) { minimum =  Math . min ( minimum , z ) ; maximum =  Math . max ( maximum , z ) ; } } } } if ( minimum ==  Double .  POSITIVE_ INFINITY ) { return null ; } else { return new  Range ( minimum , maximum ) ; } }
public  Respoke Client create Client (  Context app Context ) { context = app Context ;  Respoke Client new Client = new  Respoke Client ( ) ; instances . add ( new Client ) ; return new Client ; }
public boolean contains Attr Value (  String attr Name ,  String attr Value ) { if ( attr Set != null ) {  Set attr = (  Set ) attr Set . get ( attr Name ) ; if ( attr != null ) { return ( attr . contains ( attr Value ) ) ; } } return ( _ BOOL ) ; }
private void update Zoning Map (  Un Managed Export Mask mask ,  List < com . emc . storageos . db . client . model .  Initiator > initiators ,  List < com . emc . storageos . db . client . model .  Storage Port > storage Ports ) {  Zone Info Map zoning Map = network Device Controller . get Initiators Zone Info Map ( initiators , storage Ports ) ; for (  Zone Info zone Info : zoning Map . values ( ) ) { log . info ( _ STR , zone Info . get Zone Name ( ) , zone Info . get Initiator Wwn ( ) , zone Info . get Port Wwn ( ) ) ; } mask . set Zoning Map ( zoning Map ) ; }
public void reject Session (  Invitation Status status ) { if ( s Logger . is Activated ( ) ) { s Logger . debug ( _ STR ) ; } m Invitation Status = status ; synchronized ( m Wait User Answer ) { m Wait User Answer . notify All ( ) ; } }
public static int remove Last Rows Table (  JTable table ) { if ( table . get Row Count ( ) == _ NUM ) { return _ NUM ; }  Default Table Model model = (  Default Table Model ) table . get Model ( ) ; int count = _ NUM ; while ( _ BOOL ) { boolean remove = _ BOOL ; for ( int i = _ NUM ; i < table . get Column Count ( ) ; i ++ ) {  String data = get String Value Table ( table , table . get Row Count ( ) - _ NUM , i ) ; if ( ! data . equals ( _ STR ) ) { remove = _ BOOL ; break ; } } if ( remove ) { count ++ ; model . remove Row ( model . get Row Count ( ) - _ NUM ) ; } else { break ; } } return count ; }
public static boolean double Array Equals ( double [ ] x , double [ ] y , double tol ) { for ( int i = _ NUM ; i < x . length ; i += _ NUM ) { if ( x [ i ] == _ NUM ) { return y [ i ] == _ NUM ; } if (  Math . abs ( ( y [ i ] - x [ i ] ) / x [ i ] ) > tol ) { return _ BOOL ; } } return _ BOOL ; }
private static int [ ] [ ] find References ( final  List <  Vector3 D > vertices , final  List < int [ ] > facets ) { final int [ ] nb Facets = new int [ vertices . size ( ) ] ; int max Facets = _ NUM ; for ( final int [ ] facet : facets ) { if ( facet . length < _ NUM ) { throw new  Math Illegal Argument Exception (  Localized Core Formats .  WRONG_ NUMBER_ OF_ POINTS , _ NUM , facet . length , _ BOOL ) ; } for ( final int index : facet ) { max Facets =  Fast Math . max ( max Facets , ++ nb Facets [ index ] ) ; } } final int [ ] [ ] references = new int [ vertices . size ( ) ] [ max Facets ] ; for ( int [ ] r : references ) {  Arrays . fill ( r , - _ NUM ) ; } for ( int f = _ NUM ; f < facets . size ( ) ; ++ f ) { for ( final int v : facets . get ( f ) ) { int k = _ NUM ; while ( k < max Facets && references [ v ] [ k ] >= _ NUM ) { ++ k ; } references [ v ] [ k ] = f ; } } return references ; }
public  Set <  String > key Set ( ) {  Hash Set <  String > set = new  Hash Set <  String > ( ) ;  Iterator <  String > keys = keys ( ) ; while ( keys . has Next ( ) ) { set . add ( keys . next ( ) ) ; } return set ; }
@  Override protected void register New Selector ( ) throws  IOException { synchronized ( selector ) {  Set <  Selection Key > keys = selector . keys ( ) ;  Selector new Selector = null ; if ( selector Provider == null ) { new Selector =  Selector . open ( ) ; } else { new Selector = selector Provider . open Selector ( ) ; } for (  Selection Key key : keys ) {  Selectable Channel ch = key . channel ( ) ;  Nio Session session = (  Nio Session ) key . attachment ( ) ;  Selection Key new Key = ch . register ( new Selector , key . interest Ops ( ) , session ) ; session . set Selection Key ( new Key ) ; } selector . close ( ) ; selector = new Selector ; } }
public static int point Crossings For Path (  Path Iterator pi , double px , double py ) { if ( pi . is Done ( ) ) { return _ NUM ; } double coords [ ] = new double [ _ NUM ] ; if ( pi . current Segment ( coords ) !=  Path Iterator .  SEG_ MOVETO ) { throw new  Illegal Path State Exception ( _ STR + _ STR ) ; } pi . next ( ) ; double movx = coords [ _ NUM ] ; double movy = coords [ _ NUM ] ; double curx = movx ; double cury = movy ; double endx , endy ; int crossings = _ NUM ; while ( ! pi . is Done ( ) ) { switch ( pi . current Segment ( coords ) ) { case  Path Iterator .  SEG_ MOVETO : if ( cury != movy ) { crossings += point Crossings For Line ( px , py , curx , cury , movx , movy ) ; } movx = curx = coords [ _ NUM ] ; movy = cury = coords [ _ NUM ] ; break ; case  Path Iterator .  SEG_ LINETO : endx = coords [ _ NUM ] ; endy = coords [ _ NUM ] ; crossings += point Crossings For Line ( px , py , curx , cury , endx , endy ) ; curx = endx ; cury = endy ; break ; case  Path Iterator .  SEG_ QUADTO : endx = coords [ _ NUM ] ; endy = coords [ _ NUM ] ; crossings += point Crossings For Quad ( px , py , curx , cury , coords [ _ NUM ] , coords [ _ NUM ] , endx , endy , _ NUM ) ; curx = endx ; cury = endy ; break ; case  Path Iterator .  SEG_ CUBICTO : endx = coords [ _ NUM ] ; endy = coords [ _ NUM ] ; crossings += point Crossings For Cubic ( px , py , curx , cury , coords [ _ NUM ] , coords [ _ NUM ] , coords [ _ NUM ] , coords [ _ NUM ] , endx , endy , _ NUM ) ; curx = endx ; cury = endy ; break ; case  Path Iterator .  SEG_ CLOSE : if ( cury != movy ) { crossings += point Crossings For Line ( px , py , curx , cury , movx , movy ) ; } curx = movx ; cury = movy ; break ; } pi . next ( ) ; } if ( cury != movy ) { crossings += point Crossings For Line ( px , py , curx , cury , movx , movy ) ; } return crossings ; }
public static  String remove Package Name (  String fully_qualified_name_ ) { if ( fully_qualified_name_ == null ) return null ; int lastdot = fully_qualified_name_ . last Index Of ( _ STR ) ; if ( lastdot < _ NUM ) { return _ STR ; } else { return fully_qualified_name_ . substring ( lastdot + _ NUM ) ; } }
@  Override public void flip (  WComponent Peer peer ,  Component target ,  Volatile Image back Buffer , int x1 , int y1 , int x2 , int y2 ,  Buffer Capabilities .  Flip Contents flip Action ) { if ( flip Action ==  Buffer Capabilities .  Flip Contents .  COPIED ) {  Surface Manager vsm =  Surface Manager . get Manager ( back Buffer ) ;  Surface Data sd = vsm . get Primary Surface Data ( ) ; if ( sd instanceof  WGLVSync Off Screen Surface Data ) {  WGLVSync Off Screen Surface Data vsd = (  WGLVSync Off Screen Surface Data ) sd ;  Surface Data bbsd = vsd . get Flip Surface ( ) ;  Graphics2 D bbg = new  Sun Graphics2 D ( bbsd ,  Color . black ,  Color . white , null ) ; try { bbg . draw Image ( back Buffer , _ NUM , _ NUM , null ) ; } finally { bbg . dispose ( ) ; } } else {  Graphics g = peer . get Graphics ( ) ; try { g . draw Image ( back Buffer , x1 , y1 , x2 , y2 , x1 , y1 , x2 , y2 , null ) ; } finally { g . dispose ( ) ; } return ; } } else if ( flip Action ==  Buffer Capabilities .  Flip Contents .  PRIOR ) { return ; }  OGLSurface Data . swap Buffers ( peer . get Data ( ) ) ; if ( flip Action ==  Buffer Capabilities .  Flip Contents .  BACKGROUND ) {  Graphics g = back Buffer . get Graphics ( ) ; try { g . set Color ( target . get Background ( ) ) ; g . fill Rect ( _ NUM , _ NUM , back Buffer . get Width ( ) , back Buffer . get Height ( ) ) ; } finally { g . dispose ( ) ; } } }
public  Builder add (  String property ) { properties . add ( property ) ; return this ; }
public double [ ] bisector ( final double [ ] a , final double [ ] b ) { double [ ] diff = subtract Components ( a , b ) ; double [ ] sum = sum Components ( a , b ) ; double dot = dot ( diff , sum ) ; double [ ] result = new double [ diff . length + _ NUM ] ;  System . arraycopy ( diff , _ NUM , result , _ NUM , diff . length ) ; result [ diff . length ] = - dot / _ NUM ; return result ; }
public void write Bytes (  Data Output out ) throws  IOException { out . write Long ( most Sig ) ; out . write Long ( least Sig ) ; }
private boolean is Android Namespace (  String ns ) { if ( ns == null ) return _ BOOL ; ns = ns . trim ( ) ; if ( ns . starts With ( _ STR ) ) ns = ns . substring ( _ NUM ) ; if ( ! ns . equals ( _ STR ) ) return _ BOOL ; return _ BOOL ; }
protected int [ ] read Color Table ( int ncolors ) { int nbytes = _ NUM * ncolors ; int [ ] tab = null ; byte [ ] c = new byte [ nbytes ] ; int n = _ NUM ; try { n = in . read ( c ) ; } catch (  IOException e ) { } if ( n < nbytes ) { status =  STATUS_ FORMAT_ ERROR ; } else { tab = new int [ _ NUM ] ; int i = _ NUM ; int j = _ NUM ; while ( i < ncolors ) { int r = c [ j ++ ] & _ NUM ; int g = c [ j ++ ] & _ NUM ; int b = c [ j ++ ] & _ NUM ; tab [ i ++ ] = _ NUM | ( r << _ NUM ) | ( g << _ NUM ) | b ; } } return tab ; }
public static  Key Store create Root Certificate Key Store (  String key Store Type ,  X509 Certificate certificate ,  String private Key Alias ,  Private Key private Key ,  String private Key Password ,  String provider ) { if ( private Key Password == null ) { throw new  Illegal Argument Exception ( _ STR ) ; }  Key Store new Key Store =  Key Store Util . create Empty Key Store ( key Store Type , provider ) ; try { new Key Store . set Key Entry ( private Key Alias , private Key , private Key Password . to Char Array ( ) , new  Certificate [ ] { certificate } ) ; } catch (  Key Store Exception e ) { throw new  Key Store Access Exception ( _ STR , e ) ; } return new Key Store ; }
public boolean contains File (  File file ) { return ( file == null ) ? _ BOOL : xml Files . contains Key ( file . get Name ( ) ) ; }
protected int draw Legend (  Canvas canvas ,  Default Renderer renderer ,  String [ ] titles , int left , int right , int y , int width , int height , int legend Size ,  Paint paint , boolean calculate ) { float size = _ NUM ; if ( renderer . is Show Legend ( ) ) { float current X = left ; float current Y = y + height - legend Size + size ; paint . set Text Align (  Align .  LEFT ) ; paint . set Text Size ( renderer . get Legend Text Size ( ) ) ; int s Length =  Math . min ( titles . length , renderer . get Series Renderer Count ( ) ) ; for ( int i = _ NUM ; i < s Length ; i ++ ) {  Simple Series Renderer r = renderer . get Series Renderer At ( i ) ; final float line Size = get Legend Shape Width ( i ) ; if ( r . is Show Legend Item ( ) ) {  String text = titles [ i ] ; if ( titles . length == renderer . get Series Renderer Count ( ) ) { paint . set Color ( r . get Color ( ) ) ; } else { paint . set Color (  Color .  LTGRAY ) ; } float [ ] widths = new float [ text . length ( ) ] ; paint . get Text Widths ( text , widths ) ; float sum = _ NUM ; for ( float value : widths ) { sum += value ; } float extra Size = line Size + _ NUM + sum ; float current Width = current X + extra Size ; if ( i > _ NUM && get Exceed ( current Width , renderer , right , width ) ) { current X = left ; current Y += renderer . get Legend Text Size ( ) ; size += renderer . get Legend Text Size ( ) ; current Width = current X + extra Size ; } if ( get Exceed ( current Width , renderer , right , width ) ) { float max Width = right - current X - line Size - _ NUM ; if ( is Vertical ( renderer ) ) { max Width = width - current X - line Size - _ NUM ; } int nr = paint . break Text ( text , _ BOOL , max Width , widths ) ; text = text . substring ( _ NUM , nr ) + _ STR ; } if ( ! calculate ) { draw Legend Shape ( canvas , r , current X , current Y , i , paint ) ; draw String ( canvas , text , current X + line Size + _ NUM , current Y + _ NUM , paint ) ; } current X += extra Size ; } } } return  Math . round ( size + renderer . get Legend Text Size ( ) ) ; }
public void remove Repository (  Repository repository ) { repository . pre Remove ( ) ; repository . remove Repository Listener ( repository Listener ) ; repositories . remove ( repository ) ; fire Update ( null ) ; }
private void disable Buttons ( ) { set Kick Enabled ( _ BOOL ) ; set Punch Enabled ( _ BOOL ) ; set Push Enabled ( _ BOOL ) ; set Trip Enabled ( _ BOOL ) ; set Grapple Enabled ( _ BOOL ) ; set Jump Jet Enabled ( _ BOOL ) ; set Club Enabled ( _ BOOL ) ; set Brush Off Enabled ( _ BOOL ) ; set Thrash Enabled ( _ BOOL ) ; set Dodge Enabled ( _ BOOL ) ; set Proto Enabled ( _ BOOL ) ; set Vibro Enabled ( _ BOOL ) ; set Explosives Enabled ( _ BOOL ) ; but Done . set Enabled ( _ BOOL ) ; set Next Enabled ( _ BOOL ) ; }
public static int [ ] random Number ( int n ) { int [ ] num = new int [ n ] ; for ( int i = _ NUM ; i < num . length ; i ++ ) { num [ i ] = ( int ) ( r Gen . next Double ( ) * _ NUM ) ; } return num ; }
public static  String trim ( @  Non Null  String str , int start , int end ) { return str . length ( ) > start ? ( str . length ( ) > end ? str . substring ( start , end ) : str . substring ( start ) ) : _ STR ; }
public void start Sorting ( ) throws  Carbon Sort Key And Group By Exception {  LOGGER . info ( _ STR ) ; if ( this . entry Count > _ NUM ) {  Object [ ] [ ] to Sort ; to Sort = new  Object [ entry Count ] [ ] ;  System . arraycopy ( record Holder List , _ NUM , to Sort , _ NUM , entry Count ) ; if ( parameters . get No Dictionary Count ( ) > _ NUM ) {  Arrays . sort ( to Sort , new  Row Comparator ( parameters . get No Dictionary Dimnesion Column ( ) , parameters . get No Dictionary Count ( ) ) ) ; } else {  Arrays . sort ( to Sort , new  Row Comparator For Normal Dims ( parameters . get Dim Col Count ( ) ) ) ; } record Holder List = to Sort ;  File file = new  File ( parameters . get Temp File Location ( ) +  File . separator + parameters . get Table Name ( ) +  System . nano Time ( ) +  Carbon Common Constants .  SORT_ TEMP_ FILE_ EXT ) ; write Data Tofile ( record Holder List , this . entry Count , file ) ; } start File Based Merge ( ) ; this . record Holder List = null ; }
public void add (  String feats ) { if ( feats == null ) return ;  String key , value ; int idx ; for (  String feat :  Splitter . split Pipes ( feats ) ) { idx = feat . index Of (  DELIM_ KEY_ VALUE ) ; if ( idx > _ NUM ) { key = feat . substring ( _ NUM , idx ) ; value = feat . substring ( idx + _ NUM ) ; put ( key , value ) ; } } }
@  Override protected void assert Valid Value (  String value ) { super . assert Valid Value ( value ) ; for ( int i = _ NUM ; i < value . length ( ) ; i ++ ) { char c = value . char At ( i ) ; if ( c == _ STR ) { throw invalid Raw Template String ( value ) ; } else if ( c == _ STR ) { if ( i + _ NUM < value . length ( ) && value . char At ( i + _ NUM ) == _ STR ) { throw invalid Raw Template String ( value ) ; } } } }
public synchronized void sort ( final  Comparator <  String [ ] > comparator ) {  Check . not Null ( comparator , _ STR ) ;  Collections . sort ( rows , comparator ) ; }
public void println (  Writer writer ) throws  IOException { print ( writer ) ; writer . write ( _ STR ) ; }
public static boolean is XMLName NS (  String name ) { if ( name . length ( ) > _ NUM && ( ! is Name Start Char ( name . char At ( _ NUM ) ) || name . char At ( _ NUM ) == _ STR ) ) { return _ BOOL ; } for ( int i = _ NUM ; i < name . length ( ) ; i ++ ) { if ( ! is Name Char ( name . char At ( i ) ) || name . char At ( i ) == _ STR ) { return _ BOOL ; } } return _ BOOL ; }
public  PWReset Exception (  Throwable t ) { super ( t ) ; err List = new  Array List ( _ NUM ) ; err List . add ( t . get Message ( ) ) ; }
private static boolean equal ( double [ ] [ ] array1 , double [ ] [ ] array2 ) { if ( array1 == null ) { return ( array2 == null ) ; } if ( array2 == null ) { return _ BOOL ; } if ( array1 . length != array2 . length ) { return _ BOOL ; } for ( int i = _ NUM ; i < array1 . length ; i ++ ) { if ( !  Arrays . equals ( array1 [ i ] , array2 [ i ] ) ) { return _ BOOL ; } } return _ BOOL ; }
private void save Window State (  Window window ) { if ( ! location Set . contains ( window ) && window != primary Window ) { return ; }  State Item item = windows . get ( window ) ;  Point location = window . get Location ( ) ;  String state = location . x + _ STR + location . y ;  Dimension size = window . get Size ( ) ; state += _ STR + size . width + _ STR + size . height ; state += _ STR + ( window . is Visible ( ) ? _ STR : _ STR ) ; settings . map Put (  SETTING , item . id , state ) ; }
public  Node Set DTM (  Node Iterator iterator ,  XPath Context xctxt ) { super ( ) ;  Node node ; m_manager = xctxt . get DTMManager ( ) ; while ( null != ( node = iterator . next Node ( ) ) ) { int handle = xctxt . get DTMHandle From Node ( node ) ; add Node In Doc Order ( handle , xctxt ) ; } }
public  List <  Local Date > top ( int n ) {  List <  Local Date > top = new  Array List < > ( ) ; int [ ] values = data . to Int Array ( ) ;  Int Arrays . parallel Quick Sort ( values ,  Reverse Int Comparator . instance ( ) ) ; for ( int i = _ NUM ; i < n && i < values . length ; i ++ ) { top . add (  Packed Local Date . as Local Date ( values [ i ] ) ) ; } return top ; }
public static  String grab Name (  String signature ) {  Matcher matcher = sig RE . matcher ( signature ) ; boolean b = matcher . matches ( ) ; if ( ! b && matcher . group Count ( ) != _ NUM ) logger . error ( _ STR , signature ) ; return matcher . group ( _ NUM ) ; }
boolean is Disjoint (  Type Declaration td ) { if ( this instanceof  Union Type ) { return _ BOOL ; } if ( this instanceof  Class Or Interface && td instanceof  Class Or Interface && equals ( td ) ) { return _ BOOL ; } if ( this instanceof  Type Parameter && td instanceof  Type Parameter && equals ( td ) ) { return _ BOOL ; }  List <  Type > sts = get Satisfied Types ( ) ; for ( int i = _ NUM , s = sts . size ( ) ; i < s ; i ++ ) {  Type st = sts . get ( i ) ; if ( is Disjoint ( td , st ) ) { return _ BOOL ; } }  Type et = get Extended Type ( ) ; if ( et != null ) { if ( is Disjoint ( td , et ) ) { return _ BOOL ; } } return _ BOOL ; }
@  Override public final boolean has More Elements ( ) { if ( m_ Counter < m_ Vector . size ( ) ) { return _ BOOL ; } return _ BOOL ; }
public  Byte read (  String value ) { return  Byte . value Of ( value ) ; }
public void add To Path Option (  String key ,  String to Append ) { if ( to Append == null ) { throw new  Illegal Argument Exception ( _ STR ) ; }  String path = options . get ( key ) ; if ( to Append . starts With (  File . path Separator ) ) { if ( path == null || path . is Empty ( ) ) { path = to Append . substring ( _ NUM , to Append . length ( ) ) ; } else { path += to Append ; } } else { if ( path == null || path . is Empty ( ) ) { path = to Append ; } else { path +=  File . path Separator + to Append ; } } add Option ( key , path ) ; }
public void handle Create Instance Button Request (  Request Invocation Event event ) { remove Page Session Attribute (  AUTH_ INSTANCE_ TABLE ) ;  New Auth Instance View Bean vb = (  New Auth Instance View Bean ) get View Bean (  New Auth Instance View Bean . class ) ; unlock Page Trail ( ) ; pass Pg Session Map ( vb ) ; vb . forward To ( get Request Context ( ) ) ; }
public  JSONException (  Throwable cause ) { super ( cause . get Message ( ) ) ; this . cause = cause ; }
public double distance (  Pla Point Int p_to_point ) { return  Math . sqrt ( distance_square ( p_to_point ) ) ; }
public  Gee Test Result Parser (  String test Run Name ,  ITest Run Listener listener ) { m Test Run Name = test Run Name ; m Test Listeners = new  Array List <  ITest Run Listener > ( _ NUM ) ; m Test Listeners . add ( listener ) ; }
@  Override public int hash Code ( ) { return  System . identity Hash Code ( this ) ; }
private void verify Signature (  X509 Certificate cert ) throws  Cert Path Validator Exception {  String msg = _ STR ; if ( debug != null ) debug . println ( _ STR + msg + _ STR ) ; try { cert . verify ( prev Pub Key , sig Provider ) ; } catch (  Signature Exception e ) { throw new  Cert Path Validator Exception ( msg + _ STR , e , null , - _ NUM ,  Basic Reason .  INVALID_ SIGNATURE ) ; } catch (  General Security Exception e ) { throw new  Cert Path Validator Exception ( msg + _ STR , e ) ; } if ( debug != null ) debug . println ( msg + _ STR ) ; }
public static byte [ ] digest ( final  Digest Algorithm digest Algorithm , final byte [ ] data ) throws  DSSException { final  Message Digest message Digest = get Message Digest ( digest Algorithm ) ; final byte [ ] digest Value = message Digest . digest ( data ) ; return digest Value ; }
public  Object first Row ( ) throws  SQLException {  List rows = rows ( ) ; if ( rows . is Empty ( ) ) return null ; return ( rows . get ( _ NUM ) ) ; }
public static byte [ ] clone ( byte [ ] array ) { if ( array == null ) { return null ; } byte [ ] result = new byte [ array . length ] ;  System . arraycopy ( array , _ NUM , result , _ NUM , array . length ) ; return result ; }
private byte [ ] write Checked Bytes (  Message Nano proto ) {  Checked Message wrapper = new  Checked Message ( ) ; wrapper . payload =  Message Nano . to Byte Array ( proto ) ;  CRC32 checksum = new  CRC32 ( ) ; checksum . update ( wrapper . payload ) ; wrapper . checksum = checksum . get Value ( ) ; return  Message Nano . to Byte Array ( wrapper ) ; }
public int zoom Level For Scale ( float scale , int scale Type ) { if ( scale == _ NUM ) { return _ NUM ; } else if ( scale < _ NUM ) { return  Math . round ( scale * _ NUM ) ; } double scale From0x10 =  Math . round ( scale * _ NUM ) - _ NUM ; double exact Value =  Math . log ( scale From0x10 ) /  Math . log ( _ NUM ) ; int rounded Value = ( int ) ( scale Type ==  SCALE_ TYPE_ FLOOR ?  Math . floor ( exact Value ) : scale Type ==  SCALE_ TYPE_ CEIL ?  Math . ceil ( exact Value ) :  Math . round ( exact Value ) ) ; return ( int ) ( _ NUM +  Math . pow ( _ NUM , rounded Value ) ) ; }
protected boolean play User Sound (  String sound Identifier ) {  Object sound = builtin Sounds . get ( sound Identifier ) ; if ( sound == null ) { return _ BOOL ; } return _ BOOL ; }
private  String generate Template Id SQLStatement ( boolean table Exists ) {  String Buffer output = new  String Buffer ( ) ; output . append ( _ STR +  Generator Constants .  TABLE_ TPLID_ TPLNAME + _ STR + _ STR + _ STR + _ STR ) ; if ( ! table Exists ) { output . append ( _ STR +  Generator Constants .  TABLE_ TPLID_ TPLNAME + _ STR ) ; output . append ( _ STR ) ; } return output . to String ( ) ; }
public static int find Name (  String name ,  String [ ] table ) { for ( int i = _ NUM ; i < table . length ; i ++ ) { if ( name . equals ( table [ i ] ) ) { return i ; } } return - _ NUM ; }
private static  Bitmap transform ( @  Non Null final  Matrix scaler , @  Non Null final  Bitmap source , final int target Width , final int target Height , final int options ) { final boolean scale Up = ( options &  OPTIONS_ SCALE_ UP ) != _ NUM ; final boolean recycle = ( options &  OPTIONS_ RECYCLE_ INPUT ) != _ NUM ; int delta X = source . get Width ( ) - target Width ; int delta Y = source . get Height ( ) - target Height ; if ( ! scale Up && ( delta X < _ NUM || delta Y < _ NUM ) ) {  Bitmap b2 =  Bitmap . create Bitmap ( target Width , target Height ,  Bitmap .  Config .  ARGB_8888 ) ;  Canvas c = new  Canvas ( b2 ) ; int delta XHalf =  Math . max ( _ NUM , delta X / _ NUM ) ; int delta YHalf =  Math . max ( _ NUM , delta Y / _ NUM ) ; final  Rect src = new  Rect ( delta XHalf , delta YHalf , delta XHalf +  Math . min ( target Width , source . get Width ( ) ) , delta YHalf +  Math . min ( target Height , source . get Height ( ) ) ) ; int dst X = ( target Width - src . width ( ) ) / _ NUM ; int dst Y = ( target Height - src . height ( ) ) / _ NUM ; final  Rect dst = new  Rect ( dst X , dst Y , target Width - dst X , target Height - dst Y ) ; c . draw Bitmap ( source , src , dst , null ) ; if ( recycle ) { source . recycle ( ) ; } c . set Bitmap ( null ) ; return b2 ; } float bitmap Width F = source . get Width ( ) ; float bitmap Height F = source . get Height ( ) ; float bitmap Aspect = bitmap Width F / bitmap Height F ; float view Aspect = ( float ) target Width / target Height ;  Matrix scaler Matrix = scaler ; if ( bitmap Aspect > view Aspect ) { float scale = target Height / bitmap Height F ; if ( scale < _ NUM || scale > _ NUM ) { scaler . set Scale ( scale , scale ) ; } else { scaler Matrix = null ; } } else { float scale = target Width / bitmap Width F ; if ( scale < _ NUM || scale > _ NUM ) { scaler . set Scale ( scale , scale ) ; } else { scaler Matrix = null ; } } final  Bitmap b1 ; if ( scaler Matrix != null ) { b1 =  Bitmap . create Bitmap ( source , _ NUM , _ NUM , source . get Width ( ) , source . get Height ( ) , scaler Matrix , _ BOOL ) ; } else { b1 = source ; } if ( recycle && b1 != source ) { source . recycle ( ) ; } final int dx1 =  Math . max ( _ NUM , b1 . get Width ( ) - target Width ) ; final int dy1 =  Math . max ( _ NUM , b1 . get Height ( ) - target Height ) ; final  Bitmap b2 =  Bitmap . create Bitmap ( b1 , dx1 / _ NUM , dy1 / _ NUM , target Width , target Height ) ; if ( b2 != b1 ) { if ( recycle || b1 != source ) { b1 . recycle ( ) ; } } return b2 ; }
public boolean delete Track (  Track track ) { synchronized ( tracks ) { return tracks . remove Element ( track ) ; } }
protected long current Time ( ) { return  System . current Time Millis ( ) ; }
public static void encode Dimension ( double value , byte dest [ ] , int offset ) {  Numeric Utils . long To Sortable Bytes (  Numeric Utils . double To Sortable Long ( value ) , dest , offset ) ; }
public static void put Byte Volatile (  Object obj , long off , byte val ) {  UNSAFE . put Byte Volatile ( obj , off , val ) ; }
public void filled Circle ( double x , double y , double r ) { if ( r < _ NUM ) throw new  Illegal Argument Exception ( _ STR ) ; double xs = scale X ( x ) ; double ys = scale Y ( y ) ; double ws = factor X ( _ NUM * r ) ; double hs = factor Y ( _ NUM * r ) ; if ( ws <= _ NUM && hs <= _ NUM ) pixel ( x , y ) ; else offscreen . fill ( new  Ellipse2 D .  Double ( xs - ws / _ NUM , ys - hs / _ NUM , ws , hs ) ) ; draw ( ) ; }
final public void println ( int v ) {  Writer out = this . out ; if ( out == null ) return ; print ( v ) ; try { out . write ( _newline , _ NUM , _newline . length ) ; } catch (  IOException e ) { log . log (  Level .  FINE , e . to String ( ) , e ) ; } }
public void write UI32 ( long value ) throws  IOException { flush Bits ( ) ; out . write ( ( int ) ( value & _ NUM ) ) ; out . write ( ( int ) ( value > > _ NUM ) ) ; out . write ( ( int ) ( value > > _ NUM ) ) ; out . write ( ( int ) ( value > > _ NUM ) ) ; bytes Written += _ NUM ; }
private static  String Builder escape Regex ( final  String Builder regex , final  String value , final boolean unquote ) { regex . append ( _ STR ) ; for ( int i = _ NUM ; i < value . length ( ) ; ++ i ) { char c = value . char At ( i ) ; switch ( c ) { case _ STR : if ( unquote ) { if ( ++ i == value . length ( ) ) { return regex ; } c = value . char At ( i ) ; } break ; case _ STR : if ( ++ i == value . length ( ) ) { break ; } regex . append ( c ) ; c = value . char At ( i ) ; if ( c == _ STR ) { regex . append ( _ STR ) ; c = _ STR ; } break ; default : break ; } regex . append ( c ) ; } regex . append ( _ STR ) ; return regex ; }
public static boolean is Button Pressed (  Input Event e , int button ) { return ( e . get Modifiers ( ) & button ) == button ; }
@  Override public final  String to String (  Attribute att ) { return to String ( att . index ( ) ) ; }
public void collect And Set Properties ( ) { if ( property Consumer != null ) {  String prefix = property Consumer . get Property Prefix ( ) ;  Properties props = collect Properties ( ) ; property Consumer . set Properties ( prefix , props ) ; } }
public void copy Header (  Input Stream in ,  Output Stream out ) throws  IOException {  Buffered Input Stream is = new  Buffered Input Stream ( in ) ; byte [ ] buf = new byte [ _ NUM * _ NUM ] ; int bytes Read ; while ( ( bytes Read = is . read ( buf ) ) != - _ NUM ) { out . write ( buf , _ NUM , bytes Read ) ; } }
private static  Date read Date (  Data Input data Input ) throws  IOException { if ( data Input . read Int ( ) != _ NUM ) { throw new  Illegal State Exception ( _ STR ) ; } byte [ ] buffer = new byte [ _ NUM ] ; data Input . read Fully ( buffer ) ; return unpack Date ( buffer ) ; }
public  Local XSession Factory Builder add Annotated Classes (  Class < ? > ... annotated Classes ) { for (  Class < ? > annotated Class : annotated Classes ) { add Annotated Class ( annotated Class ) ; } return this ; }
public static boolean some Permission Permanently Denied (  Object object ,  List <  String > denied Permissions ) { for (  String denied Permission : denied Permissions ) { if ( permission Permanently Denied ( object , denied Permission ) ) { return _ BOOL ; } } return _ BOOL ; }
public boolean is Expired (  Repository Proxy Cache proxy Cache ) { long method Cache Time = proxy Cache . get Cache Time ( ) ; boolean unlimited Cache = method Cache Time <= _ NUM ;  File cache File = build File ( proxy Cache . get Cache Dir ( ) , proxy Cache . get File Name ( ) ,  DEFAULT_ FILE_ NAME ) ; if ( is Cached ( cache File ) ) { if ( unlimited Cache ) { return _ BOOL ; } long last Modified Time = file Manager . get Last Modified Time ( cache File ) ; boolean expired =  System . current Time Millis ( ) > ( last Modified Time + method Cache Time ) ; if ( expired ) { evict ( proxy Cache ) ; } return expired ; } return _ BOOL ; }
public void add Control (  Control control ) { controls . add ( control ) ; }
public  Add On Changes Result calculate Update Changes (  Add On add On ) {  Set <  Add On > add Ons = new  Hash Set < > ( ) ; add Ons . add ( add On ) ; return calculate Update Changes ( add Ons ) ; }
private void rederive Color ( ) {  Color src =  UIManager . get Color ( ui Default Parent Name ) ; if ( src != null ) { float [ ] tmp =  Color .  RGBto HSB ( src . get Red ( ) , src . get Green ( ) , src . get Blue ( ) , null ) ; tmp [ _ NUM ] = clamp ( tmp [ _ NUM ] + h Offset ) ; tmp [ _ NUM ] = clamp ( tmp [ _ NUM ] + s Offset ) ; tmp [ _ NUM ] = clamp ( tmp [ _ NUM ] + b Offset ) ; int alpha = clamp ( src . get Alpha ( ) + a Offset ) ; argb Value = (  Color .  HSBto RGB ( tmp [ _ NUM ] , tmp [ _ NUM ] , tmp [ _ NUM ] ) & _ NUM ) | ( alpha << _ NUM ) ; } else { float [ ] tmp = new float [ _ NUM ] ; tmp [ _ NUM ] = clamp ( h Offset ) ; tmp [ _ NUM ] = clamp ( s Offset ) ; tmp [ _ NUM ] = clamp ( b Offset ) ; int alpha = clamp ( a Offset ) ; argb Value = (  Color .  HSBto RGB ( tmp [ _ NUM ] , tmp [ _ NUM ] , tmp [ _ NUM ] ) & _ NUM ) | ( alpha << _ NUM ) ; } }
public void on Idle End ( ) { _idle Count . decrement And Get ( ) ; wake ( ) ; }
private void add Span (  Cache Span span ) {  Tree Set <  Cache Span > spans For Key = cached Spans . get ( span . key ) ; if ( spans For Key == null ) { spans For Key = new  Tree Set < > ( ) ; cached Spans . put ( span . key , spans For Key ) ; } spans For Key . add ( span ) ; total Space += span . length ; notify Span Added ( span ) ; }
@  Override public boolean equals (  Object obj ) { if ( obj == this ) { return _ BOOL ; } if ( obj == null ) { return _ BOOL ; } if ( ! ( get Class ( ) == obj . get Class ( ) ) ) { return _ BOOL ; } return super . equals ( obj ) ; }
public void repaint ( ) { component . repaint ( ) ; }
public void comment (  String comment ) throws  IOException { printer . println ( indent + _ STR + comment ) ; }
public static  String unescape Value (  String str ) {  String Builder retbuf = new  String Builder ( ) ; for ( int i = _ NUM ; i < str . length ( ) ; i ++ ) { char current Char = str . char At ( i ) ; if ( current Char == _ STR ) { char next Char = str . char At ( i + _ NUM ) ; if ( is Escape Character ( next Char ) ) { current Char = next Char ; i ++ ; } } retbuf . append ( current Char ) ; } return retbuf . to String ( ) ; }
public static  Uri format URL (  String url ) { if ( url . starts With ( _ STR ) ) { url = _ STR + url ; } if ( url . starts With ( _ STR ) ) { url = _ STR + url ; } if ( ! url . contains ( _ STR ) ) { url = _ STR + url ; }  Uri uri =  Uri . parse ( url ) ; return uri . normalize Scheme ( ) ; }
public static  String extract CSVOutput Line Freq (  String csv Out ) {  String tokens [ ] = csv Out . split ( _ STR , - _ NUM ) ; return tokens [ _ NUM ] ; }
public void connect (  Socket Address endpoint ) throws  IOException { connect ( endpoint , _ NUM ) ; }
@  Suppress Warnings ( _ STR ) public static boolean check ETag Validators ( final  Http Servlet Request req , final  Http Servlet Response resp , final  Method req Method , final  String etag ) { final  List <  String > if None Match List =  Collections . list ( req . get Headers ( _ STR ) ) ; if ( if None Match List . size ( ) > _ NUM && is Matching Etag ( if None Match List , etag ) ) { if ( req Method ==  Method .  GET || req Method ==  Method .  HEAD ) { send Not Modified ( resp ) ; } else { send Precondition Failed ( resp ) ; } return _ BOOL ; } final  List <  String > if Match List =  Collections . list ( req . get Headers ( _ STR ) ) ; if ( if Match List . size ( ) > _ NUM && ! is Matching Etag ( if Match List , etag ) ) { send Precondition Failed ( resp ) ; return _ BOOL ; } return _ BOOL ; }
public  List <  Ivr Zone > show Active Ivr Zone ( ) throws  Network Device Controller Exception { return show Ivr Zones ( _ BOOL ) ; }
@  Suppress Warnings ( _ STR ) public static <  K >  Immutable Array2 <  K > empty ( ) { return (  Immutable Array2 <  K > )  EMPTY ; }
void place At Position ( final  IGroup Member Node node , final  Integer position To Place ) { if ( position To Place == null ) { non Optional Non Minus Nodes . add Last ( node ) ; } else { non Optional Non Minus Nodes . add ( position To Place , node ) ; } }
public  String to String ( ) {  String Builder sb = new  String Builder ( ) ; to String ( sb , _ NUM , this ) ; return ( sb . to String ( ) ) ; }
@  Override public int hash Code ( ) { return type . hash Code ( ) ; }
public boolean delete Edge Reference (  Atlas Edge edge ,  Data Types .  Type Category type Category , boolean is Composite , boolean force Delete Struct Trait ) throws  Atlas Exception {  LOG . debug ( _ STR , string ( edge ) ) ; boolean force Delete = ( type Category ==  Data Types .  Type Category .  STRUCT || type Category ==  Data Types .  Type Category .  TRAIT ) ? force Delete Struct Trait : _ BOOL ; if ( type Category ==  Data Types .  Type Category .  STRUCT || type Category ==  Data Types .  Type Category .  TRAIT || ( type Category ==  Data Types .  Type Category .  CLASS && is Composite ) ) {  Atlas Vertex vertex For Delete = edge . get In Vertex ( ) ; delete Edge ( edge , _ BOOL , force Delete ) ; delete Type Vertex ( vertex For Delete , type Category , force Delete ) ; } else { delete Edge ( edge , _ BOOL , _ BOOL ) ; } return ! soft Delete || force Delete ; }
public static  List parse Values (  String file Name ) throws  CLIException {  Buffered Reader in = null ;  List values = new  Array List ( ) ; try { in = new  Buffered Reader ( new  File Reader ( file Name ) ) ;  String line = in . read Line ( ) ; while ( line != null ) { line = line . trim ( ) ; if ( line . length ( ) > _ NUM ) { values . add ( line ) ; } line = in . read Line ( ) ; } } catch (  IOException e ) { throw new  CLIException ( e ,  Exit Codes .  IO_ EXCEPTION ) ; } finally { if ( in != null ) { try { in . close ( ) ; } catch (  IOException e ) { } } } return values ; }
private  Platform Target create Platform Cache (  Ignite Cache Proxy cache ) { return new  Platform Cache ( platform Ctx , cache , _ BOOL , cache Exts ) ; }
static void free Memory And Finalize ( ) {  IOUtils . trace ( _ STR , null , null ) ;  Runtime rt =  Runtime . get Runtime ( ) ; long mem = rt . free Memory ( ) ; for ( int i = _ NUM ; i < _ NUM ; i ++ ) { rt . gc ( ) ; long now = rt . free Memory ( ) ; rt . run Finalization ( ) ; if ( now == mem ) { break ; } mem = now ; } }
public int compare To (  Object other ) { return name . compare To ( ( (  Turnout Operation ) other ) . name ) ; }
@  Override public boolean is Modified ( ) { long now =  Current Time . current Time ( ) ; long last Check Time = _last Check Time . get ( ) ; if ( now <= last Check Time + _check Interval ) { return _is Modified ; } if ( ! _last Check Time . compare And Set ( last Check Time , now ) ) { return _is Modified ; } if ( is Modified Impl ( ) ) { _is Modified = _ BOOL ; } else { _is Modified = _ BOOL ; } return _is Modified ; }
protected  Buffered Image create Buffered Image ( int width , int height ) {  Buffered Image image =  Image Util . create Compatible Buffered Image ( width , height ,  Buffered Image .  TYPE_ INT_ RGB ) ;  Image Util . clear Image ( image ) ; return image ; }
public  String to String ( ) { if ( version == null || version . is Empty ( ) ) { return name ; } return name + _ STR + version ; }
@  Override public  Connection Pool Data Source create Connection Pool Data Source (  Properties properties ) throws  SQLException {  Properties properties Copy = new  Properties ( ) ; if ( properties != null ) { properties Copy . put All ( properties ) ; } reject Unsupported Options ( properties Copy ) ; reject Pooling Options ( properties Copy ) ;  Jdbc Data Source data Source = new  Jdbc Data Source ( ) ; setup H2 Data Source ( data Source , properties Copy ) ; return data Source ; }
@  Override public int locations ( ) { return _ NUM ; }
private void snap In Center ( ) { final  View Item current Item = m View Item [ m Current Item ] ; final int current View Center = current Item . get Center X ( ) ; if ( m Controller . is Scrolling ( ) || m Is User Scrolling || m Center X == current View Center ) { return ; } int snap In Time = ( int ) (  SNAP_ IN_ CENTER_ TIME_ MS * ( ( float )  Math . abs ( m Center X - current View Center ) ) / m Draw Area . width ( ) ) ; m Controller . scroll To Position ( current View Center , snap In Time , _ BOOL ) ; if ( get Current View Type ( ) ==  Image Data .  VIEW_ TYPE_ STICKY && ! m Controller . is Scaling ( ) && m Scale !=  FULL_ SCREEN_ SCALE ) { m Controller . go To Full Screen ( ) ; } }
public void delete Meta Object ( int index ) {  Meta Objects . set ( index , null ) ; }
protected  String convert Word (  String word ) { word = word . to Upper Case ( ) ; if ( ignore List . contains ( word ) ) { return null ; } return word ; }
public synchronized void remove Recent Item (  T item ) { item = from String ( to String ( item ) ) ; m_ Recent Items . remove ( item ) ; if ( m_ Ignore Changes ) return ; write Props ( ) ; update Menu ( ) ; }
public void test Invoke Any2 ( ) throws  Throwable {  Executor Service e = new  Fork Join Pool ( _ NUM ) ;  Pool Cleaner cleaner = null ; try { cleaner = cleaner ( e ) ; try { e . invoke Any ( new  Array List <  Callable <  String > > ( ) ) ; should Throw ( ) ; } catch (  Illegal Argument Exception success ) { } } finally { if ( cleaner != null ) { cleaner . close ( ) ; } } }
@  Override protected  Package define Package (  String name ,  String a1 ,  String a2 ,  String a3 ,  String b1 ,  String b2 ,  String b3 ,  URL url ) { name = name . replace ( _ STR , _ STR ) ; name = name . replace ( _ STR , _ STR ) ; if ( name . ends With ( _ STR ) ) { name = name . substring ( _ NUM , name . length ( ) - _ NUM ) ; }  Package pkg = super . define Package ( name , a1 , a2 , a3 , b1 , b2 , b3 , url ) ; return pkg ; }
@  Override public final void close ( ) throws  IOException { close ( _ BOOL ) ; }
private void create Block Snapshot Data (  String name , int num Snapshots ) throws  Exception {  Volume volume = new  Volume ( ) ;  URI volume URI =  URIUtil . create Id (  Volume . class ) ; test Volume URIs . add ( volume URI ) ; volume . set Id ( volume URI ) ;  String vol Name = _ STR ; volume . set Label ( vol Name ) ;  URI cg Uri = create Block Consistency Group ( vol Name + _ STR ) ; volume . set Consistency Group ( cg Uri ) ; _db Client . create Object ( volume ) ; for ( int i = _ NUM ; i <= num Snapshots ; i ++ ) {  Block Snapshot block Snapshot = new  Block Snapshot ( ) ;  URI block Snapshot URI =  URIUtil . create Id (  Block Snapshot . class ) ; test Block Snapshot URIs . add ( block Snapshot URI ) ; block Snapshot . set Id ( block Snapshot URI ) ; block Snapshot . set Label ( name + i ) ; block Snapshot . set Snapset Label ( name + i ) ; block Snapshot . set Parent ( new  Named URI ( volume . get Id ( ) , name + i ) ) ; block Snapshot . set Consistency Group ( cg Uri ) ; _db Client . create Object ( block Snapshot ) ;  Block Snapshot query Snap = _db Client . query Object (  Block Snapshot . class , block Snapshot URI ) ; } }
@  Override public synchronized void stop ( ) { if ( running ) {  LOGGER . info ( _ STR ) ; for (  Endpoint ep : endpoints ) { ep . stop ( ) ; } running = _ BOOL ; } }
public  Json Array add (  String value ) { values . add ( value Of ( value ) ) ; return this ; }
public boolean retain All (  Abstract Byte List other ) { if ( other . size ( ) == _ NUM ) { if ( size == _ NUM ) return _ BOOL ; set Size ( _ NUM ) ; return _ BOOL ; } int limit = other . size ( ) - _ NUM ; int j = _ NUM ; for ( int i = _ NUM ; i < size ; i ++ ) { if ( other . index Of From To ( get Quick ( i ) , _ NUM , limit ) >= _ NUM ) set Quick ( j ++ , get Quick ( i ) ) ; } boolean modified = ( j != size ) ; set Size ( j ) ; return modified ; }
protected void on Result ( ) { }
public static  Collection <  String > string2 Collection (  String in ,  String delimiter , boolean do Strip ,  Collection <  String > collection ) { if ( in == null ) { return null ; } if ( collection == null ) { collection = new  Array List <  String > ( ) ; } if ( delimiter == null || delimiter . length ( ) == _ NUM ) { collection . add ( in ) ; return collection ; } int from Index = _ NUM ; int pos ; while ( ( pos = in . index Of ( delimiter , from Index ) ) >= _ NUM ) {  String interim = in . substring ( from Index , pos ) ; if ( do Strip ) { interim = strip ( interim ) ; } if ( ! do Strip || interim . length ( ) > _ NUM ) { collection . add ( interim ) ; } from Index = pos + delimiter . length ( ) ; }  String interim = in . substring ( from Index ) ; if ( do Strip ) { interim = strip ( interim ) ; } if ( ! do Strip || interim . length ( ) > _ NUM ) { collection . add ( interim ) ; } return collection ; }
private float limit ( float value , float min , float max ) { return  Math . min (  Math . max ( min , value ) , max ) ; }
@  Override public void on Place Selected (  Place place ) {  Log . i (  TAG , _ STR + place . get Name ( ) ) ; m Place Details Text . set Text ( format Place Details ( get Resources ( ) , place . get Name ( ) , place . get Id ( ) , place . get Address ( ) , place . get Phone Number ( ) , place . get Website Uri ( ) ) ) ;  Char Sequence attributions = place . get Attributions ( ) ; if ( !  Text Utils . is Empty ( attributions ) ) { m Place Attribution . set Text (  Html . from Html ( attributions . to String ( ) ) ) ; } else { m Place Attribution . set Text ( _ STR ) ; } }
public static  String to Internal Name (  String qual ) { return qual . replace ( _ STR , _ STR ) ; }
public boolean is Discard If File Altered (  String frame ID ) { return discard If File Altered Frames . contains ( frame ID ) ; }
public  String [ ] parse Configuration (  URL xml URL ) throws  IOException ,  SAXException {  Input Stream is = xml URL . open Stream ( ) ;  Document document = null ; try { document = builder . parse ( is ) ; } finally { is . close ( ) ; } return ( parse Configuration ( document ) ) ; }
public double empirical HSICincomplete Cholesky (  Tetrad Matrix  Gy ,  Tetrad Matrix  Gx , int m ) { int ky =  Gy . columns ( ) ; int kx =  Gx . columns ( ) ;  Tetrad Matrix  H =  Kernel Utils . construct H ( m ) ;  Tetrad Matrix  Gcy =  H . times (  Gy ) ;  Tetrad Matrix  Gcx =  H . times (  Gx ) ;  Tetrad Matrix  Gcyt =  Gcy . transpose ( ) ;  Tetrad Matrix  A =  Gcyt . times (  Gcx ) ;  Tetrad Matrix  B =  Gcy . times (  A ) ;  Tetrad Matrix  Gcxt =  Gcx . transpose ( ) ; double emp HSIC = _ NUM ; for ( int i = _ NUM ; i < m ; i ++ ) { emp HSIC += matrix Product Entry (  B ,  Gcxt , i , i ) ; } emp HSIC /=  Math . pow ( m - _ NUM , _ NUM ) ; return emp HSIC ; }
protected void load Frame Information (  Rpf Toc Entry rpf Toc Entry ) { try { if ( bin File == null && a Toc File Path != null ) { bin File = new  Binary Buffered File ( a Toc File Path ) ; bin File . byte Order ( a Toc Byte Order ) ; read Frame Information ( bin File , rpf Toc Entry ) ; bin File . close ( ) ; bin File = null ; } } catch (  IOException ioe ) {  Debug . error ( _ STR + ioe ) ; } catch (  Format Exception fe ) {  Debug . error ( _ STR + fe ) ; } }
void send Audio Events (  Object event ,  List listeners ) { if ( ( listeners == null ) || ( listeners . size ( ) == _ NUM ) ) { return ; } start ( ) ;  Event Info event Info = new  Event Info ( event , listeners ) ; post Event ( event Info ) ; }
private void remove Old Jar ( ) throws  IOException { if ( output File . exists ( ) ) { if ( output File . is Directory ( ) ) { if ( !  File Utils . recursive Delete ( output File ) ) { throw new  IOException ( _ STR + output File . get Absolute Path ( ) + _ STR ) ; } } else { if ( ! output File . delete ( ) ) { throw new  IOException ( _ STR + output File . get Absolute Path ( ) + _ STR ) ; } } } }
private void add Path ( final  String path ) { if ( ! my Paths . contains ( path ) ) { my Paths . add ( path ) ; } }
public boolean move To First ( ) { try { return result Set . first ( ) ; } catch (  SQLException e ) { logger . error ( e . get Message ( ) , e ) ; } return _ BOOL ; }
private void load Default Exclude Pattern ( final  String src Folder ) { if ( build Tool Name . equals Ignore Case ( _ STR ) ) { ignore File =  Ignore File . load ( src Folder ,  JDK_ IGNORE_ PATTERN ) ; } else if ( build Tool Name . equals Ignore Case ( _ STR ) ) { ignore File =  Ignore File . load ( src Folder ,  ANT_ IGNORE_ PATTERN ) ; } }
public void add Arg If Absent ( final  BOp arg ) { if ( arg == null ) throw new  Illegal Argument Exception ( ) ; if ( arg == this ) throw new  Illegal Argument Exception ( ) ; if ( ! args . contains ( arg ) ) { add Arg ( arg ) ; } }
public static boolean looks Like AURI (  String val ) { return val . starts With ( _ STR ) && val . ends With ( _ STR ) ; }
public boolean contains Attr Value (  String attr Name ,  String attr Value ) { if ( attr Set != null ) {  Set attr = (  Set ) attr Set . get ( attr Name ) ; if ( attr != null ) { return ( attr . contains ( attr Value ) ) ; } } return ( _ BOOL ) ; }
public int update Note (  Note note ) {  SQLite Database db = get Writable Database ( ) ;  String spannable As Html =  Html . to Html ( note . get Spannable ( ) ) ;  String date = dt . format ( new  Date ( ) ) ;  Content Values values = new  Content Values ( ) ; values . put (  KEY_ IMAGE ,  Bitmap Converter . get Bytes ( note . get Image ( ) ) ) ; values . put (  KEY_ DATE_ UPDATED , date ) ; values . put (  KEY_ SPANNABLE_ NOTE , spannable As Html ) ; values . put (  KEY_ NOTE_ TITLE , note . get Title ( ) ) ; return db . update (  TABLE_ NOTES , values ,  KEY_ ID + _ STR , new  String [ ] {  String . value Of ( note . get Id ( ) ) } ) ; }
void add Previous (  Node <  T > n ) { prev Nodes . add ( n ) ;  Collections . sort ( prev Nodes , is Vertical ? vertical Comparator : horizontal Comparator ) ; }
protected void options Dialog Property Change (  Property Change Event event ) { log . debug ( _ STR ) ; fire Property Change (  Property Change ID .  OPTION_ CHANGE , event . get Old Value ( ) , event . get New Value ( ) ) ; }
@  Override public final  String read UTF ( ) throws  IOException { return dis . read UTF ( ) ; }
public static  List reverse List (  List l ) {  Linked List l Res = new  Linked List ( ) ; int i List Size = l . size ( ) ; for ( int i Cnt = _ NUM ; i Cnt < i List Size ; i Cnt ++ ) { l Res . add ( l . get ( i List Size - i Cnt - _ NUM ) ) ; } return l Res ; }
public static void disable Double Buffering (  Component c ) {  Repaint Manager current Manager =  Repaint Manager . current Manager ( c ) ; current Manager . set Double Buffering Enabled ( _ BOOL ) ; }
public  Builder port ( int port ) { this . port =  Integer . to String ( port ) ; return this ; }
private static int flush Buffer (  Writer out , char [ ] buffer , int buffer Index ) throws  IOException { if ( buffer Index > _ NUM ) { out . write ( buffer , _ NUM , buffer Index ) ; } return _ NUM ; }
@  Override public boolean e Is Set ( int feature ID ) { switch ( feature ID ) { case  Eip Package .  ROUTER__ NAME : return  NAME_ EDEFAULT == null ? name != null : !  NAME_ EDEFAULT . equals ( name ) ; case  Eip Package .  ROUTER__ TO_ CHANNELS : return to Channels != null && ! to Channels . is Empty ( ) ; case  Eip Package .  ROUTER__ FROM_ CHANNELS : return from Channels != null && ! from Channels . is Empty ( ) ; case  Eip Package .  ROUTER__ OWNED_ ROUTES : return owned Routes != null && ! owned Routes . is Empty ( ) ; case  Eip Package .  ROUTER__ TYPE : return type !=  TYPE_ EDEFAULT ; } return super . e Is Set ( feature ID ) ; }
public void add Section ( final  Time Section  SECTION ) { if ( null ==  SECTION ) return ; sections . add (  SECTION ) ;  Collections . sort ( sections , new  Time Section Comparator ( ) ) ; fire Update Event (  SECTION_ EVENT ) ; }
protected void check For Tokens (  String content , int start Offset , int end Offset ) { while ( start Offset <= end Offset ) { while ( is Delimiter ( content . substring ( start Offset , start Offset + _ NUM ) ) ) { if ( start Offset < end Offset ) { start Offset ++ ; } else { return ; } } if ( is Quote Delimiter ( content . substring ( start Offset , start Offset + _ NUM ) ) ) { start Offset = get Quote Token ( content , start Offset , end Offset ) ; } else { start Offset = get Other Token ( content , start Offset , end Offset ) ; } } }
public void add All (  IVector v ) { expand For ( size + v . size - _ NUM , _ NUM ) ;  System . arraycopy ( v . vector , _ NUM , vector , size - v . size , v . size ) ; }
public static void drain (  Input Stream in Str ) throws  IOException { byte [ ] bs = new byte [  BUFFER_ SIZE ] ; while ( in Str . read ( bs , _ NUM , bs . length ) >= _ NUM ) { } }
protected abstract boolean validate (  String time ) ;
public synchronized void start ( ) { if ( workers . size ( ) > _ NUM ) { throw new  Runtime Exception ( _ STR + _ STR ) ; } for ( int i = _ NUM ; i < num Workers ; i ++ ) {  Worker worker = new  Worker <  Job > ( worker Name , jobs To Run , this ) ; workers . add ( worker ) ; } for (  Worker w : workers ) { try {  Thread . sleep ( _ NUM ) ; } catch (  Exception e ) {  LOG . error ( e ) ; } w . start ( ) ; } }
public static  Array List <  String > convert String Array To Array List (  String [ ] string Array ) { if ( string Array != null && string Array . length > _ NUM ) { return new  Array List < > (  Arrays . as List ( string Array ) ) ; } else { return null ; } }
public  Charset charset ( ) { return charset != null ?  Charset . for Name ( charset ) : null ; }
protected void register Layer (  Pdf Layer layer ) { if ( layer == null ) throw new  Illegal Argument Exception ( _ STR ) ; layers . add ( layer ) ; }
private  List <  Regex Rule > read Rules (  Reader reader ) throws  IOException ,  Illegal Argument Exception {  Buffered Reader in = new  Buffered Reader ( reader ) ;  List <  Regex Rule > rules = new  Array List <  Regex Rule > ( ) ;  String line ; while ( ( line = in . read Line ( ) ) != null ) { if ( line . length ( ) == _ NUM ) { continue ; } char first = line . char At ( _ NUM ) ; boolean sign = _ BOOL ; switch ( first ) { case _ STR : sign = _ BOOL ; break ; case _ STR : sign = _ BOOL ; break ; case _ STR : case _ STR : case _ STR : continue ; default : throw new  IOException ( _ STR + line ) ; }  String regex = line . substring ( _ NUM ) ; if (  LOG . is Trace Enabled ( ) ) {  LOG . trace ( _ STR + regex + _ STR ) ; }  Regex Rule rule = create Rule ( sign , regex ) ; rules . add ( rule ) ; } return rules ; }
public void write ( char c [ ] , int off , int len ) { if ( off < _ NUM || off > c . length || len < _ NUM || off + len > c . length || off + len < _ NUM ) { throw new  Index Out Of Bounds Exception ( ) ; } else if ( len == _ NUM ) { return ; } int newcount = count + len ; if ( newcount > buf . length ) { expand Capacity ( newcount ) ; }  System . arraycopy ( c , off , buf , count , len ) ; count = newcount ; }
public static  List <  Episode > return New Episodes (  Context context ,  Channel channel ,  List <  Episode > new Episode List ) {  List <  Episode > new Episodes = new  Array List < > ( ) ;  List <  Episode > existing Episode List = get Episodes By Channel ( context , channel ) ;  Map <  String ,  Episode > existing Episode Map = new  Array Map < > ( existing Episode List . size ( ) ) ; for ( int i = _ NUM ; i < existing Episode List . size ( ) ; i ++ ) {  Episode episode = existing Episode List . get ( i ) ; existing Episode Map . put ( episode . get Generated Id ( ) , episode ) ; } for ( int i = _ NUM ; i < new Episode List . size ( ) ; i ++ ) {  Episode episode = new Episode List . get ( i ) ; if ( ! existing Episode Map . contains Key ( episode . get Generated Id ( ) ) ) { new Episodes . add ( episode ) ; } } return new Episodes ; }
public static  Typed Operation create Initialized Array Creation (  Array Type array Type , int size ) {  List <  Type > type List = new  Array List < > ( ) ; for ( int i = _ NUM ; i < size ; i ++ ) { type List . add ( array Type . get Component Type ( ) ) ; }  Type Tuple input Types = new  Type Tuple ( type List ) ; return new  Typed Term Operation ( new  Initialized Array Creation ( array Type , size ) , input Types , array Type ) ; }
public void add Listener ( final  ISPARQLUpdate Listener l ) { if ( is Read Only ( ) ) throw new  Unsupported Operation Exception ( ) ; if ( l == null ) throw new  Illegal Argument Exception ( ) ; listeners . add ( l ) ; }
public void read ( ) {  File pref File = new  File (  System Properties . get Property ( _ STR ) ,  PREF_ FILE_ NAME ) ; if ( ! pref File . exists ( ) || ! pref File . is File ( ) ) { return ; } try { read ( new  File Input Stream ( pref File ) ) ; } catch (  IOException e ) { } }
protected void write Raw ( final  String text ) { write Indent ( ) ; try { final int length = text != null ? text . length ( ) :  NULL_ TEXT . length ( ) ; _writer . write ( text ) ; column += length ; if ( text == null ) { return ; } boolean new Line Seen = _ BOOL ; for ( int i = _ NUM ; i < length ; i ++ ) { if ( text . char At ( i ) == _ STR ) { line ++ ; column = _ NUM ; new Line Seen = _ BOOL ; } else if ( new Line Seen ) { column ++ ; } } } catch (  IOException e ) { throw new  Undeclared Throwable Exception ( e ) ; } }
public static boolean is Object (  String desc ) { return desc . ends With ( _ STR ) ; }
RSAPrivate Crt Key Impl ( byte [ ] encoded ) throws  Invalid Key Exception { decode ( encoded ) ;  RSAKey Factory . check RSAProvider Key Lengths ( n . bit Length ( ) , e ) ; }
private void bind Authentication Provider (  Class < ? extends  Authentication Provider > authentication Provider ) { logger . debug ( _ STR , bound Authentication Providers . size ( ) , authentication Provider . get Name ( ) ) ; bound Authentication Providers . add ( new  Authentication Provider Facade ( authentication Provider ) ) ; }
public void init ( ) { if ( ! _initialized ) { super . init ( ) ; _detect Panel = new  Detection Panel ( this ) ;  JPanel panel = new  JPanel ( ) ; panel . set Layout ( new  Box Layout ( panel ,  Box Layout .  Y_ AXIS ) ) ; panel . add (  Box . create Vertical Glue ( ) ) ; panel . add ( _detect Panel ) ; add ( panel , _ NUM ) ; } }
public static void write Line (  Buffered Writer writer ,  String line ) throws  IOException { writer . write ( line ) ; writer . new Line ( ) ; }
public void add (  WXDom Object child , int index ) { if ( child == null || index < - _ NUM || s Destroy . get ( ) ) { return ; } if ( children == null ) { children = new  Array List < > ( ) ; } int count = children . size ( ) ; index = index >= count ? - _ NUM : index ; if ( index == - _ NUM ) { children . add ( child ) ; super . add Child At ( child , super . get Child Count ( ) ) ; } else { children . add ( index , child ) ; super . add Child At ( child , index ) ; } child . parent = this ; }
private void update Text Input ( ) {  String new Value = list . get Selected Value ( ) ; if ( new Value != null && ! new Value . is Empty ( ) ) { input . set Text ( new Value ) ; value Changed ( new Value ) ; } }
public static  Object evaluate (  Object context ,  Object self ,  String expr ,  List <  String > engine Configs ) throws  Draft3 Expression Exception {  String trimmed Expr =  String Utils . trim ( expr ) ; if ( trimmed Expr . starts With ( _ STR ) ) { trimmed Expr = trimmed Expr . substring ( _ NUM ) ; }  String function = trimmed Expr ; if ( trimmed Expr . starts With ( _ STR ) ) { function = _ STR ; function = function . replace ( _ STR , trimmed Expr ) ; }  Context cx =  Context . enter ( ) ; cx . set Optimization Level (  OPTIMIZATION_ LEVEL ) ; cx . set Maximum Interpreter Stack Depth (  MAX_ STACK_ DEPTH ) ; cx . set Class Shutter ( new  Draft3 Expression Deny All Class Shutter ( ) ) ; try {  Scriptable global Scope = cx . init Standard Objects ( ) ; if ( engine Configs != null ) { for ( int i = _ NUM ; i < engine Configs . size ( ) ; i ++ ) {  Reader engine Config Reader = new  String Reader ( engine Configs . get ( i ) ) ; cx . evaluate Reader ( global Scope , engine Config Reader , _ STR + i + _ STR , _ NUM , null ) ; } } put To Scope (  EXPR_ CONTEXT_ NAME , context , cx , global Scope ) ; put To Scope (  EXPR_ SELF_ NAME , self , cx , global Scope ) ;  Scriptable result Scope = cx . new Object ( global Scope ) ; result Scope . set Prototype ( global Scope ) ; result Scope . set Parent Scope ( global Scope ) ;  Object result = cx . evaluate String ( result Scope , function , _ STR , _ NUM , null ) ; if ( result == null || result instanceof  Undefined ) { return null ; }  Object wrapped Result =  Context . java To JS ( result , global Scope ) ; put To Scope ( _ STR , wrapped Result , cx , global Scope ) ;  Scriptable Object . put Property ( global Scope , _ STR , wrapped Result ) ;  String final Function = _ STR + _ STR + _ STR + _ STR + _ STR ;  Scriptable wrap Scope = cx . new Object ( global Scope ) ; wrap Scope . set Prototype ( global Scope ) ; wrap Scope . set Parent Scope ( global Scope ) ; result = cx . evaluate String ( wrap Scope , final Function , _ STR , _ NUM , null ) ; return cast Result ( result ) ; } catch (  Exception e ) {  String msg =  String . format ( _ STR , expr ) ; throw new  Draft3 Expression Exception ( msg , e ) ; } finally {  Context . exit ( ) ; } }
public  DPolicy Constraints (  JDialog parent , byte [ ] value ) throws  IOException { super ( parent ) ; set Title ( res . get String ( _ STR ) ) ; init Components ( ) ; prepopulate With Value ( value ) ; }
public  Int Column ( int nrows , int capacity , int default Value ) { super ( int . class , new  Integer ( default Value ) ) ; if ( capacity < nrows ) { throw new  Illegal Argument Exception ( _ STR ) ; } m_values = new int [ capacity ] ;  Arrays . fill ( m_values , default Value ) ; m_size = nrows ; }
void read LOG ( ) throws  IOException { while ( _ BOOL ) {  String  S = isr . read Line ( ) ; if (  S == null ) return ; if (  S . starts With ( _ STR ) ) return ; } }
private void check Alter Interval Converters ( ) throws  Security Exception {  Security Manager sm =  System . get Security Manager ( ) ; if ( sm != null ) { sm . check Permission ( new  Joda Time Permission ( _ STR ) ) ; } }
public boolean equals ( final  Object obj ) { return this == obj || obj instanceof  Artifact Coordinates && equals ( (  Artifact Coordinates ) obj ) ; }
public void add Date Time Change Listener (  Date Time Change Listener listener ) { date Time Change Listeners . add ( listener ) ; }
protected void write Line (  String line ) throws  IOException { m Out . write ( line . get Bytes ( ) ) ;  Byte Utils . write Ln ( m Out ) ; }
@  Override public  Query new Prefix Query (  String text ) { if ( settings . lowercase Expanded Terms ( ) ) { text = text . to Lower Case ( settings . locale ( ) ) ; }  Boolean Query .  Builder bq = new  Boolean Query .  Builder ( ) ; bq . set Disable Coord ( _ BOOL ) ; for (  Map .  Entry <  String ,  Float > entry : weights . entry Set ( ) ) { try { if ( settings . analyze Wildcard ( ) ) {  Query analyzed Query = new Possibly Analyzed Query ( entry . get Key ( ) , text ) ; analyzed Query . set Boost ( entry . get Value ( ) ) ; bq . add ( analyzed Query ,  Boolean Clause .  Occur .  SHOULD ) ; } else {  Prefix Query prefix = new  Prefix Query ( new  Term ( entry . get Key ( ) , text ) ) ; prefix . set Boost ( entry . get Value ( ) ) ; bq . add ( prefix ,  Boolean Clause .  Occur .  SHOULD ) ; } } catch (  Runtime Exception e ) { return rethrow Unless Lenient ( e ) ; } } return super . simplify ( bq . build ( ) ) ; }
public  Source Call Chain Info (  Soot Method m ,  Stmt s ,  String type ) { this . type = type ; this . link = _ STR ; this . method = m ; this . stmt = s ; calls = _ NUM ; if ( type . equals ( _ STR ) ) syscalls = _ NUM ; }
public void save Recording (  Context context ,  String new Name ) {  Log . d (  TAG , _ STR + new Name + _ STR ) ; if ( null == m Record File ) {  Log . e (  TAG , _ STR ) ; return ; }  File parent File = m Record File . get Parent File ( ) ; if ( null == parent File ) {  Log . e (  TAG , _ STR ) ; return ; } if ( null != new Name && ! new Name . equals ( get Recording Name ( ) ) ) {  File sd File = new  File ( parent File . get Path ( ) , new Name +  RECORDING_ FILE_ EXTENSION ) ; if ( sd File . exists ( ) ) {  Log . w (  TAG , _ STR + sd File . get Absolute Path ( ) ) ; if ( ! sd File . delete ( ) ) {  Log . e (  TAG , _ STR ) ; } } if ( null != parent File ) { if ( ! m Record File . rename To ( new  File ( parent File . get Path ( ) , new Name +  RECORDING_ FILE_ EXTENSION ) ) ) {  Log . e (  TAG , _ STR ) ; new Name = get Recording Name ( ) ; } m Record File = new  File ( parent File . get Path ( ) , new Name +  RECORDING_ FILE_ EXTENSION ) ; } } m Is Recording File Saved = _ BOOL ; add Current Recording To Db ( context ) ;  Log . d (  TAG , _ STR + new Name + _ STR ) ; }
public static double standard Normal Pdf ( double x ) { double a = _ NUM / (  Math . sqrt ( _ NUM *  Math .  PI ) ) ; double b = - ( x ) * ( x ) / ( _ NUM ) ; return a *  Math . exp ( b ) ; }
public static void not Empty (  String string ) { if ( string == null || string . length ( ) == _ NUM ) throw new  Illegal Argument Exception ( _ STR ) ; }
public boolean is Empty ( ) { synchronized ( contexts ) { return contexts . is Empty ( ) ; } }
private  List <  Object > create Object List (  Object object ,  List <  Object > object List ) { if ( are Filters Passed ( object ) && ! get Expanded State ( object ) ) { if ( children Loaded ( object ) ) { expand To Level ( object , _ NUM ) ; } else { if ( object List == null ) { object List = new  Array List < > ( ) ; } object List . add ( object ) ; } }  Object parent = get Parent Element ( object ) ; if ( null != parent ) { create Object List ( parent , object List ) ; } return object List ; }
String encoded Username ( ) { if ( username . is Empty ( ) ) return _ STR ; int username Start = scheme . length ( ) + _ NUM ; int username End = delimiter Offset ( url , username Start , url . length ( ) , _ STR ) ; return url . substring ( username Start , username End ) ; }
private void validate Removal Of Public Network Interface (  String instance Id , int desired Network Interface State Count ) throws  Throwable { if ( this . is Aws Client Mock ) { return ; }  Compute State stopped Compute State = get Compute By AWSId ( this . host , instance Id ) ; assert Not Null ( stopped Compute State ) ; for (  String network Link : stopped Compute State . network Interface Links ) { assert False ( network Link . contains (  PUBLIC_ INTERFACE ) ) ; } validate Network Interface Count ( desired Network Interface State Count ) ; }
public static  List <  X509 Certificate > parse Certificates (  String [ ] base64 Encoded Certificates ) throws  Certificate Exception {  List <  X509 Certificate > certificates = new  Array List <  X509 Certificate > ( ) ; for (  String base64 Encoded Certificate : base64 Encoded Certificates ) { certificates . add ( parse Certificate ( base64 Encoded Certificate ) ) ; } return certificates ; }
private  Membership Key inner Join (  Inet Address group ,  Network Interface interf ,  Inet Address source ) throws  IOException { if ( ! group . is Multicast Address ( ) ) throw new  Illegal Argument Exception ( _ STR ) ; if ( group instanceof  Inet4 Address ) { if ( family ==  Standard Protocol Family .  INET6 && !  Net . can IPv6 Socket Join IPv4 Group ( ) ) throw new  Illegal Argument Exception ( _ STR ) ; } else if ( group instanceof  Inet6 Address ) { if ( family !=  Standard Protocol Family .  INET6 ) throw new  Illegal Argument Exception ( _ STR ) ; } else { throw new  Illegal Argument Exception ( _ STR ) ; } if ( source != null ) { if ( source . is Any Local Address ( ) ) throw new  Illegal Argument Exception ( _ STR ) ; if ( source . is Multicast Address ( ) ) throw new  Illegal Argument Exception ( _ STR ) ; if ( source . get Class ( ) != group . get Class ( ) ) throw new  Illegal Argument Exception ( _ STR ) ; }  Security Manager sm =  System . get Security Manager ( ) ; if ( sm != null ) sm . check Multicast ( group ) ; synchronized ( state Lock ) { if ( ! is Open ( ) ) throw new  Closed Channel Exception ( ) ; if ( registry == null ) { registry = new  Membership Registry ( ) ; } else {  Membership Key key = registry . check Membership ( group , interf , source ) ; if ( key != null ) return key ; }  Membership Key Impl key ; if ( ( family ==  Standard Protocol Family .  INET6 ) && ( ( group instanceof  Inet6 Address ) ||  Net . can Join6 With IPv4 Group ( ) ) ) { int index = interf . get Index ( ) ; if ( index == - _ NUM ) throw new  IOException ( _ STR ) ; byte [ ] group Address =  Net . inet6 As Byte Array ( group ) ; byte [ ] source Address = ( source == null ) ? null :  Net . inet6 As Byte Array ( source ) ; int n =  Net . join6 ( fd , group Address , index , source Address ) ; if ( n ==  IOStatus .  UNAVAILABLE ) throw new  Unsupported Operation Exception ( ) ; key = new  Membership Key Impl .  Type6 ( this , group , interf , source , group Address , index , source Address ) ; } else {  Inet4 Address target =  Net . any Inet4 Address ( interf ) ; if ( target == null ) throw new  IOException ( _ STR ) ; int group Address =  Net . inet4 As Int ( group ) ; int target Address =  Net . inet4 As Int ( target ) ; int source Address = ( source == null ) ? _ NUM :  Net . inet4 As Int ( source ) ; int n =  Net . join4 ( fd , group Address , target Address , source Address ) ; if ( n ==  IOStatus .  UNAVAILABLE ) throw new  Unsupported Operation Exception ( ) ; key = new  Membership Key Impl .  Type4 ( this , group , interf , source , group Address , target Address , source Address ) ; } registry . add ( key ) ; return key ; } }
public void close ( ) throws  IOException { }
private boolean passes Erdos Gallai Test ( ) {  Mutable Degree Distribution copy = new  Mutable Simple Degree Distribution ( get Degrees ( ) ) ; int  L = copy . size ( ) ; int degree Sum = _ NUM ; for ( int degree : copy . get Degrees ( ) ) { if ( degree < _ NUM ) { return _ BOOL ; } degree Sum += degree ; } if ( degree Sum % _ NUM != _ NUM ) { return _ BOOL ; } copy . sort (  Collections . reverse Order ( ) ) ; for ( int k = _ NUM ; k <  L ; ++ k ) { int sum = _ NUM ; for ( int i = _ NUM ; i < k ; ++ i ) { sum += copy . get ( i ) ; } int comp = _ NUM ; for ( int j = k ; j <  L ; ++ j ) { comp += min ( k , copy . get ( j ) ) ; } if ( sum > k * ( k - _ NUM ) + comp ) { return _ BOOL ; } } return _ BOOL ; }
public static  String to String (  URI uri ,  Charset encoding ) throws  IOException { return to String ( uri . to URL ( ) ,  Charsets . to Charset ( encoding ) ) ; }
void put ( int field Number ,  Field Data data ) { int i = binary Search ( field Number ) ; if ( i >= _ NUM ) { m Data [ i ] = data ; } else { i = ~ i ; if ( i < m Size && m Data [ i ] ==  DELETED ) { m Field Numbers [ i ] = field Number ; m Data [ i ] = data ; return ; } if ( m Garbage && m Size >= m Field Numbers . length ) { gc ( ) ; i = ~ binary Search ( field Number ) ; } if ( m Size >= m Field Numbers . length ) { int n = ideal Int Array Size ( m Size + _ NUM ) ; int [ ] nkeys = new int [ n ] ;  Field Data [ ] nvalues = new  Field Data [ n ] ;  System . arraycopy ( m Field Numbers , _ NUM , nkeys , _ NUM , m Field Numbers . length ) ;  System . arraycopy ( m Data , _ NUM , nvalues , _ NUM , m Data . length ) ; m Field Numbers = nkeys ; m Data = nvalues ; } if ( m Size - i != _ NUM ) {  System . arraycopy ( m Field Numbers , i , m Field Numbers , i + _ NUM , m Size - i ) ;  System . arraycopy ( m Data , i , m Data , i + _ NUM , m Size - i ) ; } m Field Numbers [ i ] = field Number ; m Data [ i ] = data ; m Size ++ ; } }
private void hilite (  Graphics graphics ,  JComponent button ) { graphics . set Color ( style . get High Light Color ( ) ) ;  Insets insets = button . get Insets ( ) ; int width = button . get Width ( ) - insets . right - insets . left - _ NUM ; int height = button . get Height ( ) - insets . top - insets . bottom - _ NUM ; graphics . draw Rect ( insets . left , insets . top , width , height ) ; }
public void init (  String btxn ,  Business Txn Config btc ) {  Filter Processor fp = null ; if ( btc . get Filter ( ) != null ) { fp = new  Filter Processor ( btxn , btc ) ; } synchronized ( filter Map ) {  Filter Processor oldfp = filter Map . get ( btxn ) ; if ( oldfp != null ) { global Exclusion Filters . remove ( oldfp ) ; btxn Filters . remove ( oldfp ) ; } if ( fp != null ) { filter Map . put ( btxn , fp ) ; if ( fp . is Include All ( ) ) { global Exclusion Filters . add ( fp ) ; } else { btxn Filters . add ( fp ) ; } } else { filter Map . remove ( btxn ) ; } } }
public void add To Weight List ( double weight ) { weight List . add ( weight ) ; }
public static int define Tag ( int ifd Id , short tag Id ) { return ( tag Id & _ NUM ) | ( ifd Id << _ NUM ) ; }
public  IOException check Certificate ( ) {  SSLSocket Factory factory = context . get Socket Factory ( ) ; try {  SSLSocket socket = (  SSLSocket ) factory . create Socket ( host , port ) ; socket . set So Timeout ( _ NUM ) ; socket . start Handshake ( ) ; socket . close ( ) ; return null ; } catch (  IOException e ) { return e ; } }
private static  Platform find Platform ( ) { try { try {  Class . for Name ( _ STR ) ; } catch (  Class Not Found Exception e ) {  Class . for Name ( _ STR ) ; }  Optional Method <  Socket > set Use Session Tickets = new  Optional Method < > ( null , _ STR , boolean . class ) ;  Optional Method <  Socket > set Hostname = new  Optional Method < > ( null , _ STR ,  String . class ) ;  Method traffic Stats Tag Socket = null ;  Method traffic Stats Untag Socket = null ;  Optional Method <  Socket > get Alpn Selected Protocol = null ;  Optional Method <  Socket > set Alpn Protocols = null ; try {  Class < ? > traffic Stats =  Class . for Name ( _ STR ) ; traffic Stats Tag Socket = traffic Stats . get Method ( _ STR ,  Socket . class ) ; traffic Stats Untag Socket = traffic Stats . get Method ( _ STR ,  Socket . class ) ; try {  Class . for Name ( _ STR ) ; get Alpn Selected Protocol = new  Optional Method < > ( byte [ ] . class , _ STR ) ; set Alpn Protocols = new  Optional Method < > ( null , _ STR , byte [ ] . class ) ; } catch (  Class Not Found Exception ignored ) { } } catch (  Class Not Found Exception |  No Such Method Exception ignored ) { } return new  Android ( set Use Session Tickets , set Hostname , traffic Stats Tag Socket , traffic Stats Untag Socket , get Alpn Selected Protocol , set Alpn Protocols ) ; } catch (  Class Not Found Exception ignored ) { } try {  String nego Class Name = _ STR ;  Class < ? > nego Class =  Class . for Name ( nego Class Name ) ;  Class < ? > provider Class =  Class . for Name ( nego Class Name + _ STR ) ;  Class < ? > client Provider Class =  Class . for Name ( nego Class Name + _ STR ) ;  Class < ? > server Provider Class =  Class . for Name ( nego Class Name + _ STR ) ;  Method put Method = nego Class . get Method ( _ STR ,  SSLSocket . class , provider Class ) ;  Method get Method = nego Class . get Method ( _ STR ,  SSLSocket . class ) ;  Method remove Method = nego Class . get Method ( _ STR ,  SSLSocket . class ) ; return new  Jdk With Jetty Boot Platform ( put Method , get Method , remove Method , client Provider Class , server Provider Class ) ; } catch (  Class Not Found Exception |  No Such Method Exception ignored ) { } return new  Platform ( ) ; }
public void update Execution Status (  Execution Update Data execution Update Data ) {  Closeable Http Response http Response = null ; http Response = post Over Http ( execution Update Data , _ STR + execution Update Data . get State Machine Id ( ) + _ STR + execution Update Data . get Task Id ( ) + _ STR ) ;  Http Client Utils . close Quietly ( http Response ) ; }
public final boolean between ( int i Num , int i Min , int i Max ) { return ( i Num >= i Min ) && ( i Num <= i Max ) ; }
static  String to S ( float [ ] a ) {  String s = _ STR ; if ( a == null ) { return _ STR ; } for ( int i = _ NUM ; i < a . length ; i ++ ) { if ( i != _ NUM ) { s += _ STR ; }  String t = df . format ( a [ i ] ) + _ STR ; s += t . substring ( _ NUM , _ NUM ) ; } s += _ STR ; return s ; }
private void define Scroll Pane (  UIDefaults d ) {  String c =  PAINTER_ PREFIX + _ STR ;  String p = _ STR ; d . put ( p + _ STR ,  Boolean .  FALSE ) ; d . put ( p + _ STR , new  Insets UIResource ( _ NUM , _ NUM , _ NUM , _ NUM ) ) ; d . put ( p + _ STR , new  Lazy Painter ( c ,  Scroll Pane Painter .  Which .  BACKGROUND_ ENABLED ) ) ; d . put ( p + _ STR , new  Lazy Painter ( c ,  Scroll Pane Painter .  Which .  BORDER_ ENABLED_ FOCUSED ) ) ; d . put ( p + _ STR , new  Lazy Painter ( c ,  Scroll Pane Painter .  Which .  BORDER_ ENABLED ) ) ; d . put ( p + _ STR , new  Lazy Painter ( c ,  Scroll Pane Painter .  Which .  CORNER_ ENABLED ) ) ; p = _ STR ; d . put ( p + _ STR , new  Insets UIResource ( _ NUM , _ NUM , _ NUM , _ NUM ) ) ; d . put ( p + _ STR ,  Boolean .  TRUE ) ; }
public static  Workflow .  Method resync Clone Method (  URI storage ,  List <  URI > clone ,  Boolean update Op Status , boolean is CG ) { return new  Workflow .  Method ( _ STR , storage , clone , update Op Status , is CG ) ; }
@  Override public synchronized void remove Data Source Listener (  Data Source Listener dsl ) { m_data Listeners . remove ( dsl ) ; }
public  String left Str (  String str , int length ) { return str . substring ( _ NUM ,  Math . min ( str . length ( ) , length ) ) ; }
public boolean contains Block (  Block b ) {  Array List <  Block > b List = get Internal Blocks List ( ) ; for ( int i = _ NUM ; i < b List . size ( ) ; i ++ ) { if ( b == b List . get ( i ) ) { return _ BOOL ; } } return _ BOOL ; }
public  Test Suite Builder (  Class clazz ) { this ( clazz . get Name ( ) , clazz . get Class Loader ( ) ) ; }
public void add Grid ( final  Grid grid ) { grid List . add ( grid ) ; add ( grid ) ; revalidate ( ) ; }
public void push Template Folder ( @  Not Null  File folder ) { my Last Template Folders . push ( folder ) ; }
public void clear ( ) { verify State ( ) ; init Depth . set ( init Depth . get ( ) - _ NUM ) ; if ( init Depth . get ( ) == _ NUM ) { resource Cache . set ( null ) ; cache Locked . set ( null ) ; init Depth . set ( null ) ; } }
protected void draw Cubic (  Canvas c ,  Line Data Set data Set ,  List <  Entry > entries ) {  Transformer trans = m Chart . get Transformer ( data Set . get Axis Dependency ( ) ) ;  Entry entry From = data Set . get Entry For XIndex ( m Min X ) ;  Entry entry To = data Set . get Entry For XIndex ( m Max X ) ; int minx = data Set . get Entry Position ( entry From ) ; int maxx =  Math . min ( data Set . get Entry Position ( entry To ) + _ NUM , entries . size ( ) ) ; float phase X = m Animator . get Phase X ( ) ; float phase Y = m Animator . get Phase Y ( ) ; float intensity = data Set . get Cubic Intensity ( ) ; cubic Path . reset ( ) ; int size = ( int )  Math . ceil ( ( maxx - minx ) * phase X + minx ) ; minx =  Math . max ( minx - _ NUM , _ NUM ) ; size =  Math . min ( size + _ NUM , entries . size ( ) ) ; if ( size - minx >= _ NUM ) { float prev Dx = _ NUM ; float prev Dy = _ NUM ; float cur Dx = _ NUM ; float cur Dy = _ NUM ;  Entry cur = entries . get ( minx ) ;  Entry next = entries . get ( minx + _ NUM ) ;  Entry prev = entries . get ( minx ) ;  Entry prev Prev = entries . get ( minx ) ; cubic Path . move To ( cur . get XIndex ( ) , cur . get Val ( ) * phase Y ) ; prev Dx = ( next . get XIndex ( ) - cur . get XIndex ( ) ) * intensity ; prev Dy = ( next . get Val ( ) - cur . get Val ( ) ) * intensity ; cur = entries . get ( minx + _ NUM ) ; next = entries . get ( minx + ( size - minx > _ NUM ? _ NUM : _ NUM ) ) ; cur Dx = ( next . get XIndex ( ) - prev . get XIndex ( ) ) * intensity ; cur Dy = ( next . get Val ( ) - prev . get Val ( ) ) * intensity ; cubic Path . cubic To ( prev . get XIndex ( ) + prev Dx , ( prev . get Val ( ) + prev Dy ) * phase Y , cur . get XIndex ( ) - cur Dx , ( cur . get Val ( ) - cur Dy ) * phase Y , cur . get XIndex ( ) , cur . get Val ( ) * phase Y ) ; for ( int j = minx + _ NUM ; j < size - _ NUM ; j ++ ) { prev Prev = entries . get ( j - _ NUM ) ; prev = entries . get ( j - _ NUM ) ; cur = entries . get ( j ) ; next = entries . get ( j + _ NUM ) ; prev Dx = ( cur . get XIndex ( ) - prev Prev . get XIndex ( ) ) * intensity ; prev Dy = ( cur . get Val ( ) - prev Prev . get Val ( ) ) * intensity ; cur Dx = ( next . get XIndex ( ) - prev . get XIndex ( ) ) * intensity ; cur Dy = ( next . get Val ( ) - prev . get Val ( ) ) * intensity ; cubic Path . cubic To ( prev . get XIndex ( ) + prev Dx , ( prev . get Val ( ) + prev Dy ) * phase Y , cur . get XIndex ( ) - cur Dx , ( cur . get Val ( ) - cur Dy ) * phase Y , cur . get XIndex ( ) , cur . get Val ( ) * phase Y ) ; } if ( size > entries . size ( ) - _ NUM ) { cur = entries . get ( entries . size ( ) - _ NUM ) ; prev = entries . get ( entries . size ( ) - _ NUM ) ; prev Prev = entries . get ( ( entries . size ( ) >= _ NUM ) ? entries . size ( ) - _ NUM : entries . size ( ) - _ NUM ) ; next = cur ; prev Dx = ( cur . get XIndex ( ) - prev Prev . get XIndex ( ) ) * intensity ; prev Dy = ( cur . get Val ( ) - prev Prev . get Val ( ) ) * intensity ; cur Dx = ( next . get XIndex ( ) - prev . get XIndex ( ) ) * intensity ; cur Dy = ( next . get Val ( ) - prev . get Val ( ) ) * intensity ; cubic Path . cubic To ( prev . get XIndex ( ) + prev Dx , ( prev . get Val ( ) + prev Dy ) * phase Y , cur . get XIndex ( ) - cur Dx , ( cur . get Val ( ) - cur Dy ) * phase Y , cur . get XIndex ( ) , cur . get Val ( ) * phase Y ) ; } } if ( data Set . is Draw Filled Enabled ( ) ) { cubic Fill Path . reset ( ) ; cubic Fill Path . add Path ( cubic Path ) ; draw Cubic Fill ( m Bitmap Canvas , data Set , cubic Fill Path , trans , entry From . get XIndex ( ) , entry From . get XIndex ( ) + size ) ; } m Render Paint . set Color ( data Set . get Color ( ) ) ; m Render Paint . set Style (  Paint .  Style .  STROKE ) ; trans . path Value To Pixel ( cubic Path ) ; m Bitmap Canvas . draw Path ( cubic Path , m Render Paint ) ; m Render Paint . set Path Effect ( null ) ; }
public static int waiting ( int d ,  Predicate p ) { int count = _ NUM ;  Sim Event event ;  Iterator <  Sim Event > iterator = deferred . iterator ( ) ; while ( iterator . has Next ( ) ) { event = iterator . next ( ) ; if ( ( event . get Destination ( ) == d ) && ( p . match ( event ) ) ) { count ++ ; } } return count ; }
protected void apply Use Schema (  String schema ) throws  SQLException { if ( schema != null && schema . length ( ) > _ NUM && ! schema . equals ( this . current Schema ) ) { current Schema = schema ; if ( conn . supports Use Default Schema ( ) ) statement . add Batch ( conn . get Use Schema Query ( schema ) ) ; } }
public void test Case6 ( ) { byte a Bytes [ ] = { _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM } ; byte b Bytes [ ] = { _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM } ; int a Sign = _ NUM ; int b Sign = - _ NUM ; byte r Bytes [ ] = { - _ NUM , - _ NUM , - _ NUM , _ NUM , - _ NUM , - _ NUM , - _ NUM , - _ NUM , _ NUM , - _ NUM , - _ NUM , - _ NUM , _ NUM , - _ NUM , _ NUM , _ NUM , _ NUM , - _ NUM , - _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM } ;  Big Integer a Number = new  Big Integer ( a Sign , a Bytes ) ;  Big Integer b Number = new  Big Integer ( b Sign , b Bytes ) ;  Big Integer result = a Number . multiply ( b Number ) ; byte res Bytes [ ] = new byte [ r Bytes . length ] ; res Bytes = result . to Byte Array ( ) ; for ( int i = _ NUM ; i < res Bytes . length ; i ++ ) { assert True ( res Bytes [ i ] == r Bytes [ i ] ) ; } assert Equals ( _ STR , - _ NUM , result . signum ( ) ) ; }
private void close Entity Manager ( ) {  Entity Manager entity Manager = get Entity Manager ( ) ; if ( entity Manager != null && entity Manager . is Open ( ) ) { entity Manager . close ( ) ; entity Manager Thread Local . set ( null ) ; } }
public static  File locate Replicator Log Dir ( ) { if ( replicator Log Dir == null ) {  String replicator Log =  System . get Property (  LOG_ DIR ) ; if ( replicator Log == null ) replicator Log Dir = new  File ( locate Replicator Home Dir ( ) , _ STR ) ; else replicator Log Dir = new  File ( replicator Log ) ; if ( ! replicator Log Dir . is Directory ( ) ) { throw new  Server Runtime Exception ( _ STR + replicator Log Dir ) ; } } return replicator Log Dir ; }
public void extend ( final int size ) {  Preconditions . check Argument ( size > _ NUM , _ STR ) ; final byte [ ] data = new byte [ m_data . length + size ] ;  System . arraycopy ( m_data , _ NUM , data , _ NUM , m_data . length ) ; m_data = data ; }
private  DD compute EBy Taylor Series ( ) {  DD s =  DD . value Of ( _ NUM ) ;  DD t =  DD . value Of ( _ NUM ) ; double n = _ NUM ; int i = _ NUM ; while ( t . double Value ( ) >  DD .  EPS ) { i ++ ; n += _ NUM ; t = t . divide (  DD . value Of ( n ) ) ; s = s . add ( t ) ; } return s ; }
public java . lang .  String Builder append ( float f ) { return append (  Float . to String ( f ) ) ; }
public void source (  File file ) { add Arg ( _ STR , file . get Absolute Path ( ) ) ; }
public  String test Destination (  Location destination ,  Track track ) { return rs Test Destination ( destination , track ) ; }
void pop ( ) { stack . remove ( stack . size ( ) - _ NUM ) ; }
Random fork Random ( ) { if ( random == null ) { return null ; } return new  Random ( random . next Long ( ) ) ; }
public static  String deployment Action In Progress Feedback ( final  String id ) throws  JSONException { return deployment Action Feedback ( id , _ STR ) ; }
protected void on Before Process ( ) { }
static  Class < ? > find Class Or Null (  String class Name ,  Class Loader class Loader ) { try { return class Loader . load Class ( class Name ) ; } catch (  Class Not Found Exception e ) { return null ; } }
public void write (  Input Stream stream ) { if ( is Final ) { log . warning ( _ STR ) ; return ; } try { int n Read ; byte [ ] buffer = new byte [ _ NUM * _ NUM ] ; while ( ( n Read = stream . read ( buffer , _ NUM , buffer . length ) ) != - _ NUM ) { byte [ ] new Data = new byte [ data . length + n Read ] ;  System . arraycopy ( data , _ NUM , new Data , _ NUM , data . length ) ;  System . arraycopy ( buffer , _ NUM , new Data , data . length , n Read ) ; data = new Data ; } } catch (  IOException e ) { log . warning ( _ STR ) ; } }
public void add Control (  Control control ) { controls . add ( control ) ; }
public static final  Hash Set read Set Xml (  Input Stream in ) throws  Xml Pull Parser Exception ,  IOException {  Xml Pull Parser parser =  Xml . new Pull Parser ( ) ; parser . set Input ( in , null ) ; return (  Hash Set ) read Value Xml ( parser , new  String [ _ NUM ] ) ; }
public void write Exif ( byte [ ] jpeg ,  String exif Out File Name ) throws  File Not Found Exception ,  IOException { if ( jpeg == null || exif Out File Name == null ) { throw new  Illegal Argument Exception (  NULL_ ARGUMENT_ STRING ) ; }  Output Stream s = null ; try { s = get Exif Writer Stream ( exif Out File Name ) ; s . write ( jpeg , _ NUM , jpeg . length ) ; s . flush ( ) ; } catch (  IOException e ) { close Silently ( s ) ; throw e ; } s . close ( ) ; }
public  Image Transferable (  Image image ) { this . image = image ; }
public void add Extension (  String ext ) { synchronized ( exts ) { ext = ext . to Lower Case ( ) ; exts . add ( ext ) ; } }
public void add Observer (  Observer observer ) { if ( observer == null ) { throw new  Null Pointer Exception ( ) ; } synchronized ( this ) { if ( ! observers . contains ( observer ) ) observers . add ( observer ) ; } }
public double distance (  Vec x ,  List <  Double > qi , int k ) { if ( k >= mean Sqrd Norms . length || k < _ NUM ) throw new  Index Out Of Bounds Exception ( _ STR + mean Sqrd Norms . length + _ STR + k + _ STR ) ; return  Math . sqrt (  Math . max ( kernel . eval ( _ NUM , _ NUM ,  Arrays . as List ( x ) , qi ) - _ NUM / ownes [ k ] * eval Sum K ( x , qi , k , new Designations ) + mean Sqrd Norms [ k ] * norm Consts [ k ] , _ NUM ) ) ; }
@  Override public  String to String ( ) {  String Buffer result = new  String Buffer ( ) ; for ( int i = _ NUM ; i < data . length ; i ++ ) { result . append ( ( i == _ NUM ? _ STR : _ STR ) + data [ i ] ) ; } return result . to String ( ) ; }
void retain (  Object owner ,  Field field ) { retain ( ) ;  Map <  String ,  Integer > fields = owners . get ( owner ) ; if ( fields == null ) { fields = new  Hash Map < > ( ) ; owners . put ( owner , fields ) ; }  Integer count = fields . get ( field . to Generic String ( ) ) ; if ( count == null ) { fields . put ( field . to Generic String ( ) , _ NUM ) ; } else { count ++ ; fields . put ( field . to Generic String ( ) , count ) ; } }
public static  List <  Annotation Dto > transform To Dto (  List <  Annotation > annotations ) { if ( annotations == null ) { throw new  Web Application Exception ( _ STR ,  Status .  INTERNAL_ SERVER_ ERROR ) ; }  List <  Annotation Dto > result = new  Array List < > ( ) ; for (  Annotation annotation : annotations ) { result . add ( transform To Dto ( annotation ) ) ; } return result ; }
public  Multi Bot Manager ( ) { manager Number =  MANAGER_ COUNT . get And Increment ( ) ;  Thread Pool Executor default Pool = (  Thread Pool Executor )  Executors . new Cached Thread Pool ( ) ; default Pool . allow Core Thread Time Out ( _ BOOL ) ; this . bot Pool =  More Executors . listening Decorator ( default Pool ) ; }
public void remove Group Properties Listener (  Group Properties Listener group Properties Listener ) { group Properties Listeners . remove ( group Properties Listener ) ; }
public static void edit Global Instruction Comment ( final  SQLProvider provider , final  Integer comment Id , final  Integer user Id , final  String new Comment ) throws  Couldnt Save Data Exception {  Preconditions . check Not Null ( provider , _ STR ) ;  Preconditions . check Not Null ( comment Id , _ STR ) ;  Preconditions . check Not Null ( user Id , _ STR ) ;  Preconditions . check Not Null ( new Comment , _ STR ) ;  Postgre SQLComment Functions . edit Comment ( provider , comment Id , user Id , new Comment ) ; }
public static  Element to Element (  Document doc ,  Object o ) throws  Page Exception { if ( o instanceof  Element ) return (  Element ) o ; else if ( o instanceof  Node ) throw new  Expression Exception ( _ STR +  Caster . to Class Name ( o ) + _ STR ) ; return doc . create Element (  Caster . to String ( o ) ) ; }
public synchronized void clear Sessions (  Context context ,  Boolean clear Credentials ) { synchronized (  LOG_ TAG ) { while ( m MXSessions . size ( ) > _ NUM ) { clear Session ( context , m MXSessions . get ( _ NUM ) , clear Credentials ) ; } } }
protected void check If Deleted User (  SSOToken token ,  String user DN ) throws  AMEntry Exists Exception {  String user Attribute [ ] = {  USER_ STATUS_ ATTRIBUTE } ;  Attr attr ; try {  Persistent Object po =  UMSObject . get Object ( token , new  Guid ( user DN ) , user Attribute ) ; attr = po . get Attribute (  USER_ STATUS_ ATTRIBUTE ) ; } catch (  UMSException ue ) { if ( debug . message Enabled ( ) ) debug . message ( _ STR , ue ) ; return ; } if ( attr != null ) {  String attr Value = attr . get Value ( ) ; if ( attr Value != null && attr Value . equals Ignore Case ( _ STR ) ) { debug . warning ( _ STR + _ STR + user DN ) ; throw new  AMEntry Exists Exception (  AMSDKBundle . get String ( _ STR ) , _ STR ) ; } } }
private static int v Int Size ( int x ) { if ( ( x & ( _ NUM << ( _ NUM * _ NUM ) ) ) == _ NUM ) { return _ NUM ; } if ( ( x & ( _ NUM << ( _ NUM * _ NUM ) ) ) == _ NUM ) { return _ NUM ; } if ( ( x & ( _ NUM << ( _ NUM * _ NUM ) ) ) == _ NUM ) { return _ NUM ; } if ( ( x & ( _ NUM << ( _ NUM * _ NUM ) ) ) == _ NUM ) { return _ NUM ; } return _ NUM ; }
private void create Partition Region (  List vm List , int start Index For Region , int end Index For Region , int local Max Memory , int redundancy ) {  Iterator node Iterator = vm List . iterator ( ) ; while ( node Iterator . has Next ( ) ) {  VM vm = (  VM ) node Iterator . next ( ) ; vm . invoke ( create Multiple PRWith Total Num Bucket Prop Set ( pr Prefix , start Index For Region , end Index For Region , redundancy , local Max Memory , _ NUM ) ) ; } }
public  Zhqrd (  Zmat  A ) throws  Jampack Exception {  A . get Properties ( ) ; nrow =  A . nr ; ncol =  A . nc ; ntran =  Math . min (  A . nr ,  A . nc ) ;  U = new  Z1 [ ntran ] ;  R = new  Zutmat (  A ) ; for ( int k =  A . bx ; k <  A . bx + ntran ; k ++ ) {  U [ k -  A . bx ] =  House . genc (  R , k ,  A . rx , k ) ;  House . ua (  U [ k -  A . bx ] ,  R , k ,  A . rx , k + _ NUM ,  A . cx ) ; } if ( nrow > ncol ) {  R = new  Zutmat (  R . get (  R . bx ,  R . cx ,  R . bx ,  R . cx ) ) ; } }
private void build Network ( final  Network network , int [ ] nodes Per Layer ,  Point2 D initial Position , final  Neuron input Neuron Template ) { set Label ( _ STR ) ;  List <  Neuron > input Layer Neurons = new  Array List <  Neuron > ( ) ; for ( int i = _ NUM ; i < nodes Per Layer [ _ NUM ] ; i ++ ) { input Layer Neurons . add ( new  Neuron ( network , input Neuron Template ) ) ; }  Neuron Group input Layer = new  Neuron Group ( network , input Layer Neurons ) ; input Layer . set Clamped ( _ BOOL ) ; add Neuron Group ( input Layer ) ; input Layer . set Layout Based On Size ( initial Position ) ;  Synapse synapse =  Synapse . get Template Synapse ( new  Static Synapse Rule ( ) ) ; synapse . set Lower Bound ( - _ NUM ) ; synapse . set Upper Bound ( _ NUM ) ;  Neuron Group last Layer = input Layer ; for ( int i = _ NUM ; i < nodes Per Layer . length ; i ++ ) {  List <  Neuron > hidden Layer Neurons = new  Array List <  Neuron > ( ) ; for ( int j = _ NUM ; j < nodes Per Layer [ i ] ; j ++ ) {  Sigmoidal Rule rule = new  Sigmoidal Rule ( ) ;  Neuron neuron = new  Neuron ( network , rule ) ; rule . set Lower Bound ( _ NUM ) ; neuron . set Update Priority ( i ) ; hidden Layer Neurons . add ( neuron ) ; }  Neuron Group hidden Layer = new  Neuron Group ( network , hidden Layer Neurons ) ; hidden Layer . set Layout Based On Size ( ) ; add Neuron Group ( hidden Layer ) ;  Network Layout Manager . offset Neuron Group ( last Layer , hidden Layer ,  Direction .  NORTH , between Layer Interval ) ;  All To All connection = new  All To All ( ) ;  Synapse Group lh = connect Neuron Groups ( last Layer , hidden Layer , connection ) ; lh . randomize Connection Weights ( ) ; last Layer = hidden Layer ; } }
private static boolean are Equal ( int from Index ,  Char Sequence left ,  Char Sequence right ) { if ( left == right ) return _ BOOL ; if ( ( left == null ) || ( right == null ) ) return _ BOOL ; int n = left . length ( ) ; if ( right . length ( ) != n ) return _ BOOL ; for ( int i = n ; i > from Index ; ) { if ( left . char At ( -- i ) != right . char At ( i ) ) return _ BOOL ; } return _ BOOL ; }
public int size ( ) { return productions . size ( ) ; }
public void add Tight Source Node (  ASTNode reference ) { f Tight Source Range Nodes . add ( reference ) ;  List <  Structural Property Descriptor > properties = reference . structural Properties For Type ( ) ; for (  Iterator <  Structural Property Descriptor > iterator = properties . iterator ( ) ; iterator . has Next ( ) ; ) {  Structural Property Descriptor descriptor = iterator . next ( ) ; if ( descriptor . is Child Property ( ) ) {  ASTNode child = (  ASTNode ) reference . get Structural Property ( descriptor ) ; if ( child != null && is Extending ( child , reference ) ) { add Tight Source Node ( child ) ; } } else if ( descriptor . is Child List Property ( ) ) {  List < ? extends  ASTNode > children =  ASTNodes . get Child List Property ( reference , (  Child List Property Descriptor ) descriptor ) ; for (  Iterator < ? extends  ASTNode > iterator2 = children . iterator ( ) ; iterator2 . has Next ( ) ; ) {  ASTNode child = iterator2 . next ( ) ; if ( is Extending ( child , reference ) ) { add Tight Source Node ( child ) ; } } } } }
protected boolean is Event Disabled (  XEvent e ) { if ( enable Log . is Loggable (  Platform Logger .  Level .  FINEST ) ) { enable Log . finest ( _ STR , e , ( is Enabled ( ) ? _ STR : _ STR ) ) ; } if ( ! is Enabled ( ) ) { switch ( e . get_type ( ) ) { case  XConstants .  Button Press : case  XConstants .  Button Release : case  XConstants .  Key Press : case  XConstants .  Key Release : case  XConstants .  Enter Notify : case  XConstants .  Leave Notify : case  XConstants .  Motion Notify : if ( enable Log . is Loggable (  Platform Logger .  Level .  FINER ) ) { enable Log . finer ( _ STR , e ) ; } return _ BOOL ; } } switch ( e . get_type ( ) ) { case  XConstants .  Map Notify : case  XConstants .  Unmap Notify : return _ BOOL ; } return super . is Event Disabled ( e ) ; }
public  DSystem Information (  JFrame parent ) { super ( parent , res . get String ( _ STR ) ,  Modality Type .  DOCUMENT_ MODAL ) ; init Components ( ) ; }
public  Noded Segment String (  Coordinate [ ] pts ,  Object data ) { this . pts = pts ; this . data = data ; }
private void start Function ( ) { function = new  Function Lib Function ( ) ; inside Function = _ BOOL ; }
public void add Listener (  Key Combo Listener listener ) { m Listeners . add ( listener ) ; }
public static void create Federated Namespace (  URI namespace ,  Zoo Keeper Client zkc ) throws  Interrupted Exception ,  Zoo Keeper Client .  Zoo Keeper Connection Exception ,  Keeper Exception {  String zk Sub Namespaces Path = namespace . get Path ( ) + _ STR +  ZNODE_ SUB_ NAMESPACES ;  Utils . zk Create Full Path Optimistic ( zkc , zk Sub Namespaces Path , new byte [ _ NUM ] , zkc . get Default ACL ( ) ,  Create Mode .  PERSISTENT ) ; }
private  Calendar as Calendar (  Calendar base ,  Time time ) {  Calendar time Calendar =  Calendar . get Instance ( ) ; time Calendar . set Time ( time ) ; base . set (  Calendar .  HOUR_ OF_ DAY , time Calendar . get (  Calendar .  HOUR_ OF_ DAY ) ) ; base . set (  Calendar .  MINUTE , time Calendar . get (  Calendar .  MINUTE ) ) ; base . set (  Calendar .  SECOND , time Calendar . get (  Calendar .  SECOND ) ) ; base . set (  Calendar .  MILLISECOND , time Calendar . get (  Calendar .  MILLISECOND ) ) ; return base ; }
private void update UDPCache (  Ping Data pd ) { if ( set Ping Data == null && ! warning Logged ) { find Ping Data Method ( ) ; } if ( set Ping Data != null ) { try { set Ping Data . invoke ( transport , new  Object [ ] { pd } ) ; } catch (  Invocation Target Exception |  Illegal Access Exception e ) { if ( ! warning Logged ) { log . warn ( _ STR , e ) ; warning Logged = _ BOOL ; } } } }
private void debug (  String message ) { message = _ STR + message ;  LOGGER . info ( message ) ; }
protected boolean is Port ( int port ) { return _socket . get Port ( ) == port ; }
public static boolean is Boolean (  String str ) { return str . equals ( _ STR ) || str . equals ( _ STR ) || str . equals ( _ STR ) || str . equals ( _ STR ) ; }
protected void handle Install Request Failure (  Member State member ,  Install Request request ,  Throwable error ) { fail Attempt ( member , error ) ; }
public  List <  Feed Item > load All Deep From Cursor (  Cursor cursor ) { int count = cursor . get Count ( ) ;  List <  Feed Item > list = new  Array List <  Feed Item > ( count ) ; if ( cursor . move To First ( ) ) { if ( identity Scope != null ) { identity Scope . lock ( ) ; identity Scope . reserve Room ( count ) ; } try { do { list . add ( load Current Deep ( cursor , _ BOOL ) ) ; } while ( cursor . move To Next ( ) ) ; } finally { if ( identity Scope != null ) { identity Scope . unlock ( ) ; } } } return list ; }
public int create String (  String s ) { byte [ ] utf8 = s . get Bytes ( utf8charset ) ; add Byte ( ( byte ) _ NUM ) ; start Vector ( _ NUM , utf8 . length , _ NUM ) ; bb . position ( space -= utf8 . length ) ; bb . put ( utf8 , _ NUM , utf8 . length ) ; return end Vector ( ) ; }
protected  List <  String > convert List To Lower Case (  List <  String > list ) {  List <  String > lower Case List = new  Array List < > ( ) ; for (  String value : list ) { lower Case List . add ( value . to Lower Case ( ) ) ; } return lower Case List ; }
public boolean write Next Part ( byte [ ] data ) throws  JPlag Exception { if ( remaining Bytes < data . length ) { throw new  JPlag Exception ( _ STR , _ STR + _ STR , _ STR ) ; } try {  File Output Stream out = new  File Output Stream ( file , _ BOOL ) ; out . write ( data ) ; out . close ( ) ; remaining Bytes -= data . length ; } catch (  IOException e ) { e . print Stack Trace ( ) ; throw new  JPlag Exception ( _ STR , _ STR + _ STR , _ STR ) ; } return remaining Bytes == _ NUM ; }
public final int begin Line ( ) { return this . b Line ; }
public void update Width ( ) { if ( m_ Sum Of Weights > _ NUM ) { double mean = m_ Weighted Sum / m_ Sum Of Weights ; double variance = m_ Weighted Sum Squared / m_ Sum Of Weights - mean * mean ; if ( variance < _ NUM ) { variance = _ NUM ; } m_ Width =  Math . sqrt ( variance ) *  Math . pow ( m_ Sum Of Weights , m_ Exponent ) ; if ( m_ Width <= m_ Min Width ) { m_ Width = m_ Min Width ; } } else { m_ Width =  Double .  MAX_ VALUE ; } }
private boolean is Source And Target Different ( ) { boolean result = _ BOOL ;  String source Vendor = _ STR ;  String target Vendor = _ STR ;  String source Url = _ STR ;  String target Url = _ STR ;  String source Catalog = _ STR ;  String target Catalog = _ STR ;  String source Schema = _ STR ;  String target Schema = _ STR ; if ( m_source . get Vendor ( ) != null ) source Vendor = m_source . get Vendor ( ) ; if ( m_target . get Vendor ( ) != null ) target Vendor = m_target . get Vendor ( ) ; if ( m_source . get Url ( ) != null ) source Url = m_source . get Url ( ) ; if ( m_target . get Url ( ) != null ) target Url = m_target . get Url ( ) ; if ( m_source . get Catalog ( ) != null ) source Catalog = m_source . get Catalog ( ) ; if ( m_target . get Catalog ( ) != null ) target Catalog = m_target . get Catalog ( ) ; if ( m_source . get Schema ( ) != null ) source Schema = m_source . get Schema ( ) ; if ( m_target . get Schema ( ) != null ) target Schema = m_target . get Schema ( ) ; if ( ! source Vendor . equals Ignore Case ( target Vendor ) ) result = _ BOOL ; else if ( ! source Url . equals Ignore Case ( target Url ) ) result = _ BOOL ; else if ( ! source Catalog . equals Ignore Case ( target Catalog ) ) result = _ BOOL ; else if ( ! source Schema . equals Ignore Case ( target Schema ) ) result = _ BOOL ; if ( ! result ) s_logger . log (  Level .  SEVERE , _ STR ) ; return result ; }
public static  List <  Shape Record > line ( double start X , double start Y , double end X , double end Y ) {  List <  Shape Record > shape Records = new  Array List <  Shape Record > ( ) ; shape Records . add ( move ( start X , start Y ) ) ; shape Records . add All ( straight Edge ( start X , start Y , end X , end Y ) ) ; return shape Records ; }
public static int find Global Valley Location ( float [ ] data ) { float min =  Float .  Na N ; int imin = - _ NUM ; for ( int i = _ NUM ; i < data . length ; i ++ ) { if (  Float . is Na N ( data [ i ] ) ) continue ; if (  Float . is Na N ( min ) || data [ i ] < min ) { min = data [ i ] ; imin = i ; } } return imin ; }
protected void move Up Selected ( ) { int selected Index = table . get Selected Row ( ) ; if ( selected Index > - _ NUM ) { int index = data . move Up ( index To Model ( selected Index ) ) ; set Row Selected ( index To View ( index ) ) ; } }
private  Volume find RPVPlex Volume With Orginal Assets (  String Set backing Volume URIs ) {  Volume vol With Original Assets = null ; for (  String backing Volume URI : backing Volume URIs ) {  Volume backing Volume = _db Client . query Object (  Volume . class ,  URI . create ( backing Volume URI ) ) ; if ( backing Volume != null && backing Volume . get Virtual Pool ( ) != null ) {  Virtual Pool vpool = _db Client . query Object (  Virtual Pool . class , backing Volume . get Virtual Pool ( ) ) ; if (  Virtual Pool . is RPVPlex Protect HASide ( vpool ) ) { vol With Original Assets = backing Volume ; break ; } } } return vol With Original Assets ; }
public void shutdown ( ) { logger . info ( _ STR ) ; executor . shutdown ( ) ; }
protected void add Data Path (  String path ) { if ( data Paths == null ) { data Paths = new  Array List <  String > ( ) ; } if ( path != null ) { data Paths . add ( path ) ; } }
@  Override public boolean on Key Event (  Key Event event ) { if ( ! m Match Key Combo || m Listeners . is Empty ( ) ) { return _ BOOL ; } switch ( event . get Action ( ) ) { case  Key Event .  ACTION_ DOWN : return on Key Down ( event ) ; case  Key Event .  ACTION_ MULTIPLE : return m Has Partial Match ; case  Key Event .  ACTION_ UP : return on Key Up ( ) ; default : return _ BOOL ; } }
public abstract int parse Part (  String value ,  Event Recurrence er ) ;
public  Vector3 ceil ( ) { x = ( float )  Math . ceil ( x ) ; y = ( float )  Math . ceil ( y ) ; z = ( float )  Math . ceil ( z ) ; return this ; }
@  Override protected boolean is Frontier Empty ( ) { clean Up Frontier ( ) ; update Metrics ( frontier . size ( ) ) ; return frontier . is Empty ( ) ; }
private void parse Attributes (  Typed Array a ) { bar Width = ( int ) a . get Dimension (  R . styleable .  Progress Wheel_bar Width , bar Width ) ; rim Width = ( int ) a . get Dimension (  R . styleable .  Progress Wheel_rim Width , rim Width ) ; spin Speed = ( int ) a . get Dimension (  R . styleable .  Progress Wheel_spin Speed , spin Speed ) ; delay Millis = a . get Integer (  R . styleable .  Progress Wheel_delay Millis , delay Millis ) ; if ( delay Millis < _ NUM ) { delay Millis = _ NUM ; } bar Color = a . get Color (  R . styleable .  Progress Wheel_bar Color , bar Color ) ; bar Length = ( int ) a . get Dimension (  R . styleable .  Progress Wheel_bar Length , bar Length ) ; text Size = ( int ) a . get Dimension (  R . styleable .  Progress Wheel_text Size , text Size ) ; text Color = ( int ) a . get Color (  R . styleable .  Progress Wheel_text Color , text Color ) ; if ( a . has Value (  R . styleable .  Progress Wheel_text ) ) { set Text ( a . get String (  R . styleable .  Progress Wheel_text ) ) ; } rim Color = ( int ) a . get Color (  R . styleable .  Progress Wheel_rim Color , rim Color ) ; circle Color = ( int ) a . get Color (  R . styleable .  Progress Wheel_circle Color , circle Color ) ; contour Color = a . get Color (  R . styleable .  Progress Wheel_contour Color , contour Color ) ; contour Size = a . get Dimension (  R . styleable .  Progress Wheel_contour Size , contour Size ) ; a . recycle ( ) ; }
public static final int [ ] resize ( int [ ] a , int size ) { if ( a . length >= size ) return a ; int [ ] b = new int [ size ] ;  System . arraycopy ( a , _ NUM , b , _ NUM , a . length ) ; return b ; }
private static void init Common Variable (  Calendar _calendar , boolean _trace Flag , int num User ) throws  Exception { initialize ( ) ; trace Flag = _trace Flag ; if ( _calendar == null ) { calendar =  Calendar . get Instance ( ) ; } else { calendar = _calendar ; }  Cloud Sim Shutdown shutdown = new  Cloud Sim Shutdown ( _ STR , num User ) ; shutdown Id = shutdown . get Id ( ) ; }
public void fill (  View view ) { validate Not Nullable View ( view ) ; try { if ( view instanceof  View Group ) {  View Group view Group = (  View Group ) view ; for ( int i = _ NUM ; i < view Group . get Child Count ( ) ; i ++ ) {  View child = view Group . get Child At ( i ) ; fill ( child ) ; } } else { if ( m Ids == null ) { fill View ( view ) ; } else if ( m Ids . contains ( view . get Id ( ) ) ) { fill View ( view ) ; } } } catch (  Exception e ) { e . print Stack Trace ( ) ; } finally { m Faker = null ; } }
public void map Volume To SCSIInitiator (  String volume Id ,  String initiator Id ) throws  Exception { log . info ( _ STR ) ;  String uri =  Scale IOConstants . get Map Volume To Scsi Initiator URI ( volume Id ) ;  Scale IOMap Volume To Scsi Initiator map Parm = new  Scale IOMap Volume To Scsi Initiator ( ) ; map Parm . set Scsi Initiator Id ( initiator Id ) ; map Parm . set Allow Multiple Mapp ( _ STR ) ; post (  URI . create ( uri ) , get Json For Entity ( map Parm ) ) ; }
public static <  T >  Collection <  T > not Empty (  Collection <  T > list ,  String name ) { not Null ( list , name ) ; if ( list . is Empty ( ) ) { throw new  Illegal Argument Exception (  String . format ( _ STR , name ) ) ; } return list ; }
private float spacing ( float x1 , float y1 , float x2 , float y2 ) { float x = x1 - x2 ; float y = y1 - y2 ; return ( float )  Math . sqrt ( x * x + y * y ) ; }
public  Block block ( ) { return block ; }
public void write ( byte [ ] b , int offset , int length ) throws java . io .  IOException { out . write ( b , offset , length ) ; written += length ; }
public void remove All Data Callbacks ( ) { data Callbacks . clear ( ) ; }
public void write ( byte [ ] buf , int off , int len ) throws  TTransport Exception { if ( output Stream_ == null ) { throw new  TTransport Exception (  TTransport Exception .  NOT_ OPEN , _ STR ) ; } try { output Stream_ . write ( buf , off , len ) ; } catch (  IOException iox ) { throw new  TTransport Exception (  TTransport Exception .  UNKNOWN , iox ) ; } }
public void unregister MBean (  Object Name name ) throws  Instance Not Found Exception ,  MBean Registration Exception { mbs Interceptor . unregister MBean ( clone Object Name ( name ) ) ; }
public static  General Path append Shape Edge (  General Path to Shape ,  General Path add Shape , boolean line To ) { boolean  DEBUG =  Debug . debugging ( _ STR ) ; int point Count = _ NUM ; if ( add Shape == null ) { return to Shape ; } if ( to Shape == null ) { return add Shape ; } to Shape . append ( add Shape , line To ) ; return to Shape ; }
public static boolean is Readable ( final  File file ) { if ( file == null || ! file . is File ( ) ) {  Log . e (  File Utils . class , _ STR ) ; return _ BOOL ; } return file . exists ( ) && file . can Read ( ) ; }
final public int read ( final byte [ ] a , final int aoff , final int alen ) throws  IOException { if ( alen == _ NUM ) { return _ NUM ; } final int remaining = limit - off ; if ( remaining == _ NUM ) { return - _ NUM ; } final int n = remaining < alen ? remaining : alen ;  System . arraycopy ( buf , this . off , a , aoff , n ) ; this . off += n ; return n ; }
public void delete ( ) { m Base Name . delete ( ) ; m Backup Name . delete ( ) ; }
public  String ( byte [ ] bytes , java . lang .  String enc ) throws java . io .  Unsupported Encoding Exception { this ( bytes To Chars ( bytes , _ NUM , bytes . length , enc ) ) ; }
public static int [ ] sort Values (  Matrix m ) { double [ ] v = new double [ m . get Column Dimension ( ) ] ; int [ ] index = new int [ v . length ] ; for ( int i = _ NUM ; i < v . length ; i ++ ) { v [ i ] = m . get ( i , i ) ; index [ i ] = i ; } for ( int i = _ NUM ; i < v . length ; i ++ ) { for ( int j = i + _ NUM ; j < v . length ; j ++ ) { if (  Math . abs ( v [ i ] ) <  Math . abs ( v [ j ] ) ) { double tmp Value = v [ j ] ; v [ j ] = v [ i ] ; v [ i ] = tmp Value ; int tmp Index = index [ j ] ; index [ j ] = index [ i ] ; index [ i ] = tmp Index ; } } } return index ; }
public void constrain Child (  Object cell ) { if ( cell != null ) { mx Geometry geo = model . get Geometry ( cell ) ; mx Rectangle area = ( is Constrain Child ( cell ) ) ? get Cell Containment Area ( cell ) : get Maximum Graph Bounds ( ) ; if ( geo != null && area != null ) { if ( ! geo . is Relative ( ) && ( geo . get X ( ) < area . get X ( ) || geo . get Y ( ) < area . get Y ( ) || area . get Width ( ) < geo . get X ( ) + geo . get Width ( ) || area . get Height ( ) < geo . get Y ( ) + geo . get Height ( ) ) ) { double overlap = get Overlap ( cell ) ; if ( area . get Width ( ) > _ NUM ) { geo . set X (  Math . min ( geo . get X ( ) , area . get X ( ) + area . get Width ( ) - ( _ NUM - overlap ) * geo . get Width ( ) ) ) ; } if ( area . get Height ( ) > _ NUM ) { geo . set Y (  Math . min ( geo . get Y ( ) , area . get Y ( ) + area . get Height ( ) - ( _ NUM - overlap ) * geo . get Height ( ) ) ) ; } geo . set X (  Math . max ( geo . get X ( ) , area . get X ( ) - geo . get Width ( ) * overlap ) ) ; geo . set Y (  Math . max ( geo . get Y ( ) , area . get Y ( ) - geo . get Height ( ) * overlap ) ) ; } } } }
public int read ( byte [ ] buffer , int offset , int length ) throws  IOException { return _file . read ( buffer , offset , length ) ; }
private  Cuboid (  String world Name , int x1 , int y1 , int z1 , int x2 , int y2 , int z2 ) { this . world Name = world Name ; this . x1 =  Math . min ( x1 , x2 ) ; this . x2 =  Math . max ( x1 , x2 ) ; this . y1 =  Math . min ( y1 , y2 ) ; this . y2 =  Math . max ( y1 , y2 ) ; this . z1 =  Math . min ( z1 , z2 ) ; this . z2 =  Math . max ( z1 , z2 ) ; }
public double calculate Value ( double log ) { return  Math . pow ( this . base , log ) ; }
public boolean is Destroy Message ( ) { if ( message == null ) { throw new  Illegal State Exception ( _ STR ) ; } return ! callee . equals ( _ STR ) && ( message . equals ( _ STR ) || message . starts With ( _ STR ) ) ; }
private  String user Agent ( ) { return m User Agent ; }
public static boolean is IPv6 Reference (  String address ) { return address . char At ( _ NUM ) == _ STR && address . char At ( address . length ( ) - _ NUM ) == _ STR ; }
public static final  String make Xml Java Identifier (  String name ) { if ( name . index Of ( _ STR ) >= _ NUM ) name = replace ( name , _ STR , _ STR ) ; if ( name . index Of ( _ STR ) >= _ NUM ) name = replace ( name , _ STR , _ STR ) ; if ( name . index Of ( _ STR ) >= _ NUM ) name = replace ( name , _ STR , _ STR ) ; return name ; }
public void degrees And Persist ( ) { degrees And Persist ( degree ) ; }
public  Os Lib ( ) { }
protected  Args Base ( ) { _argv = null ; _start Time = _ NUM ; _program Info = null ; _env = null ; }
@  Override public void element (  String element Name ,  Augmentations augs ) throws  XNIException { if ( f Mixed && f Validation ) { if ( f Mixed Element Types . contains ( element Name ) ) { f Error Reporter . report Error (  XMLMessage Formatter .  XML_ DOMAIN , _ STR , new  Object [ ] { f DTDElement Decl Name , element Name } ,  XMLError Reporter .  SEVERITY_ ERROR ) ; } else { f Mixed Element Types . add ( element Name ) ; } } if ( f DTDGrammar != null ) f DTDGrammar . element ( element Name , augs ) ; if ( f DTDContent Model Handler != null ) { f DTDContent Model Handler . element ( element Name , augs ) ; } }
private static  Point find Midnormal Point (  Point center ,  Point a ,  Point b ,  Rect area , int radius ) { if ( a . y == b . y ) { if ( a . y < center . y ) { return new  Point ( ( a . x + b . x ) / _ NUM , center . y + radius ) ; } return new  Point ( ( a . x + b . x ) / _ NUM , center . y - radius ) ; } if ( a . x == b . x ) { if ( a . x < center . x ) { return new  Point ( center . x + radius , ( a . y + b . y ) / _ NUM ) ; } return new  Point ( center . x - radius , ( a . y + b . y ) / _ NUM ) ; } double ab Slope = ( a . y - b . y ) / ( a . x - b . x * _ NUM ) ; double midnormal Slope = - _ NUM / ab Slope ; double radian =  Math . tan ( midnormal Slope ) ; int dy = ( int ) ( radius *  Math . sin ( radian ) ) ; int dx = ( int ) ( radius *  Math . cos ( radian ) ) ;  Point point = new  Point ( center . x + dx , center . y + dy ) ; if ( ! in Area ( point , area , _ NUM ) ) { point = new  Point ( center . x - dx , center . y - dy ) ; } return point ; }
public static  Input Stream to UTF8 Input Stream (  String str ) {  Input Stream is = null ; try { is = new  Byte Array Input Stream ( str . get Bytes ( _ STR ) ) ; } catch (  Unsupported Encoding Exception e ) { throw new  Assertion Error ( ) ; } return is ; }
public static boolean close ( final  Socket socket ) { if ( socket != null ) { try { socket . close ( ) ; } catch (  IOException ignore ) { return _ BOOL ; } } return _ BOOL ; }
@  Override public void on Artist Update (  Provider Identifier provider ,  Artist a ) throws  Remote Exception { if ( a == null ) {  Log . w (  TAG , _ STR ) ; return ; }  Artist cached = m Cache . get Artist ( a . get Ref ( ) ) ; if ( cached == null ) { m Cache . put Artist ( provider , a ) ; post Artist For Update ( a ) ; } else if ( ! cached . is Identical ( a ) ) { cached . set Name ( a . get Name ( ) ) ;  Iterator <  String > it = a . albums ( ) ; while ( it . has Next ( ) ) { cached . add Album ( it . next ( ) ) ; } cached . set Is Loaded ( a . is Loaded ( ) ) ; post Artist For Update ( a ) ; } }
public static  String [ ] [ ] read ( final  File file ) throws  IOException {  File Input Stream fis = new  File Input Stream ( file ) ; return read ( fis ) ; }
public  Tiled Grayscale Matrix ( final  Grayscale Matrix matrix , final int tile Width , final int tile Height ) { if ( matrix . get Width ( ) < tile Width || matrix . get Height ( ) < tile Height ) { throw new  Illegal Argument Exception ( _ STR ) ; } if ( tile Width <= _ NUM || tile Height <= _ NUM ) { throw new  Illegal Argument Exception ( _ STR ) ; } this . tile Width = tile Width ; this . tile Height = tile Height ; this . tiles X = matrix . get Width ( ) / tile Width ; this . tiles Y = matrix . get Height ( ) / tile Height ; int rounded Width = tiles X * tile Width ; int rounded Height = tiles Y * tile Height ; tiles = new  Array List <  Grayscale Matrix > ( rounded Width * rounded Height ) ; for ( int i = _ NUM ; i < tiles Y ; i ++ ) { for ( int j = _ NUM ; j < tiles X ; j ++ ) { tiles . add (  Grayscale Matrix . create From Region ( matrix , tile Width , tile Height , this . tile Width * j , this . tile Height * i ) ) ; } } }
public  Connection put Connection (  Connection connection ) { return connections . put ( connection . get Identifier ( ) , connection ) ; }
protected static  Method resolve Java Method (  Bsh Class Manager bcm ,  Class clas ,  String name ,  Class [ ] types , boolean static Only ) throws  Util Eval Error { if ( clas == null ) throw new  Interpreter Error ( _ STR ) ;  Method method = null ; if ( bcm == null )  Interpreter . debug ( _ STR ) ; else method = bcm . get Resolved Method ( clas , name , types , static Only ) ; if ( method == null ) { boolean public Only = !  Capabilities . have Accessibility ( ) ; try { method = find Overloaded Method ( clas , name , types , public Only ) ; } catch (  Security Exception e ) { throw new  Util Target Error ( _ STR + clas , e ) ; } check Found Static Method ( method , static Only , clas ) ; if ( method != null && ! public Only ) { try {  Reflect Manager .  RMSet Accessible ( method ) ; } catch (  Util Eval Error e ) { } } if ( method != null && bcm != null ) bcm . cache Resolved Method ( clas , types , method ) ; } return method ; }
public void clear Last Login Time ( ) { operations . add (  Password Policy State Operation Type .  CLEAR_ LAST_ LOGIN_ TIME ) ; }
public static  String format Text Box (  String text , int width ) { require Non Null ( text ) ; return format Text Box ( text , width ,  WORDS ,  Collections . empty Set ( ) ) ; }
static  Predicate field Match (  String field ,  Enum value ) { return field Match ( field , value . name ( ) , _ BOOL ) ; }
public boolean mouse Pressed (  Mouse Event e ) { if ( show_plot_ && graph != null ) { int x = e . get X ( ) ; int y = e . get Y ( ) ; if ( ( x >= plot X ) && ( x <= plot X + plot Width ) && ( y >= plot Y ) && ( y <= plot Y + plot Width ) ) { grabbed_plot_graphics_ = _ BOOL ; prev X = x ; prev Y = y ; } } return _ BOOL ; }
private float [ ] convert Dash List To Array (  List <  Float > dash List ) { if ( dash List == null ) { return null ; } float [ ] dashes = new float [ dash List . size ( ) ] ; int i = _ NUM ; for (  Float f : dash List ) { dashes [ i ++ ] = ( f != null ? f :  Float .  Na N ) ; } return dashes ; }
private  File List filter ( boolean keep ,  String pattern ) { boolean start = _ BOOL ; if ( pattern . ends With ( _ STR ) ) { pattern = pattern . substring ( _ NUM , pattern . length ( ) - _ NUM ) ; start = _ BOOL ; } else if ( pattern . starts With ( _ STR ) ) { pattern = pattern . substring ( _ NUM ) ; } if ( pattern . index Of ( _ STR ) >= _ NUM ) { throw new  Runtime Exception ( _ STR + pattern ) ; } pattern =  Build Base . replace All ( pattern , _ STR ,  File . separator ) ;  File List list = new  File List ( ) ; for (  File f : this ) {  String path = f . get Path ( ) ; boolean match = start ? path . starts With ( pattern ) : path . ends With ( pattern ) ; if ( match == keep ) { list . add ( f ) ; } } return list ; }
@  Override public void evict All ( ) {  File [ ] files = cache Directory . list Files ( ) ; if ( null != files ) { for (  File file : files ) { if ( file != null ) file . delete ( ) ; } } }
public byte [ ] decompress (  Data Input is , int nbytes ) {  Byte Array Output Stream baos = new  Byte Array Output Stream ( ) ; try { int c = _ NUM ; while ( c < nbytes ) { byte b = is . read Byte ( ) ; if ( b == - _ NUM ) break ; baos . write ( b ) ; c ++ ; } } catch (  IOException ex ) { throw new  Runtime Exception ( ex ) ; } return decompress ( baos . to Byte Array ( ) ) ; }
public void add (  String column Name ) { column Names . add ( column Name ) ; }
private void flush Buffer To Writer ( ) throws  IOException { _out . write ( _buffer . array ( ) , _ NUM , _buffer . position ( ) ) ; _buffer . clear ( ) ; }
public boolean is Literal ( ) { return _ BOOL ; }
public  String ( byte [ ] bytes , int off , int len ) { this ( bytes To Chars ( bytes , off , len , _ STR ) ) ; }
public void assert Joined ( final  UUID service Id ) { m_triggers . add ( new  Quorum Event Invariant (  Quorum Event Enum .  SERVICE_ LEAVE , service Id ) ) ; assert Membership ( m_quorum . get Joined ( ) , service Id ) ; }
public  Element next ( ) { if ( element Stack == null ) { return first ( ) ; } if ( element Stack . is Empty ( ) ) { return null ; }  Stack Item item = element Stack . peek ( ) ;  Element elem = item . get Element ( ) ; int index = item . get Index ( ) ; if ( index + _ NUM < elem . get Element Count ( ) ) {  Element child = elem . get Element ( index + _ NUM ) ; if ( child . is Leaf ( ) ) { item . increment Index ( ) ; } else { element Stack . push ( new  Stack Item ( child ) ) ; } return child ; } else { element Stack . pop ( ) ; if ( ! element Stack . is Empty ( ) ) {  Stack Item top = element Stack . peek ( ) ; top . increment Index ( ) ; return next ( ) ; } } return null ; }
private void add Connections (  Collection <  Connection > connections ) throws  Guacamole Exception { for (  Connection connection : connections ) {  APIConnection Group parent = retrieved Groups . get ( connection . get Parent Identifier ( ) ) ; if ( parent != null ) {  Collection <  APIConnection > children = parent . get Child Connections ( ) ; if ( children == null ) { children = new  Array List <  APIConnection > ( ) ; parent . set Child Connections ( children ) ; }  APIConnection api Connection = new  APIConnection ( connection ) ; retrieved Connections . put ( connection . get Identifier ( ) , api Connection ) ; children . add ( api Connection ) ; } else logger . debug ( _ STR , connection . get Identifier ( ) , connection . get Parent Identifier ( ) ) ; } }
public void add Shape ( final  Geo Membership Shape shape ) { shapes . add ( shape ) ; }
public void add Decoration (  Shape Decoration decoration ) { decorations . add ( decoration ) ; }
@  Non Null protected static  String sortable Title ( @  Nullable  String title ) { if ( title == null ) { return _ STR ; } title = title . to Lower Case ( ) ; if ( title . starts With ( _ STR ) ) { return title . substring ( _ NUM ) ; } else if ( title . starts With ( _ STR ) ) { return title . substring ( _ NUM ) ; } else { return title ; } }
public void record Volume Operation (  Db Client db Client ,  Operation Type Enum op Type ,  Operation .  Status status ,  Object ... ext Param ) { try { boolean op Status = (  Operation .  Status . ready == status ) ? _ BOOL : _ BOOL ;  String ev Type ; ev Type = op Type . get Ev Type ( op Status ) ;  String ev Desc = op Type . get Description ( ) ;  String op Stage =  Audit Log Manager .  AUDITOP_ END ; _logger . info ( _ STR , op Type . to String ( ) , ev Type . to String ( ) + _ STR + ev Desc ) ;  URI uri = (  URI ) ext Param [ _ NUM ] ; record Bourne Volume Event ( db Client , ev Type , status , ev Desc , uri ) ;  String id = uri . to String ( ) ;  Audit Block Util . audit Block ( db Client , op Type , op Status , op Stage , id ) ; } catch (  Exception e ) { _logger . error ( _ STR , op Type . to String ( ) , e ) ; } }
@  Override public void put ( double val , double weight ) { final double nn = weight + this . n ; final double delta = val - this . m1 ; final double otherm2 = val * val ; final double otherm3 = otherm2 * val ; final double otherm4 = otherm3 * val ; final double delta_nn = delta / nn ; final double delta_nn2 = delta_nn * delta_nn ; final double delta_nn3 = delta_nn2 * delta_nn ; final double na2 = this . n * this . n ; final double nb2 = weight * weight ; final double ntn = this . n * weight ; this . m4 += otherm4 + delta * delta_nn3 * ntn * ( na2 - ntn + nb2 ) + _ NUM * ( na2 * otherm2 + nb2 * this . m2 ) * delta_nn2 + _ NUM * ( this . n * otherm3 - weight * this . m3 ) * delta_nn ; this . m3 += otherm3 + delta * delta_nn2 * ntn * ( this . n - weight ) + _ NUM * ( this . n * otherm2 - weight * this . m2 ) * delta_nn ; this . m2 += otherm2 + delta * delta_nn * this . n * weight ; this . m1 += weight * delta_nn ; this . n = nn ; min =  Math . min ( min , val ) ; max =  Math . max ( max , val ) ; }
@  Override public void close ( ) throws  IOException { if ( ! closed ) { inf . end ( ) ; closed = _ BOOL ; eof = _ BOOL ; super . close ( ) ; } }
public int size ( ) { return m_ List . size ( ) ; }
public void test Shared Name Simple ( ) throws  Exception {  Byte Array Output Stream out = new  Byte Array Output Stream ( ) ;  Smile Generator gen = smile Generator ( out , _ BOOL ) ; gen . write Start Array ( ) ; gen . write Start Object ( ) ; gen . write Number Field ( _ STR , _ NUM ) ; gen . write End Object ( ) ; gen . write Start Object ( ) ; gen . write Number Field ( _ STR , _ NUM ) ; gen . write End Object ( ) ; gen . write End Array ( ) ; gen . close ( ) ; byte [ ] result = out . to Byte Array ( ) ; assert Equals ( _ NUM , result . length ) ; }
public void handle Remove Entry Button Request (  Request Invocation Event event ) throws  Model Control Exception {  CCAction Table table = (  CCAction Table ) get Child (  AUTH_ ENTRY_ TABLE ) ; table . restore State Data ( ) ;  Integer [ ] selected = entry Table Model . get Selected Rows ( ) ; ac Model = (  Auth Configuration Model ) get Model ( ) ; ac Model . remove Auth Entries ( selected ) ;  String xml = ac Model . get XMLValue ( get Realm Name ( ) , get Config Name ( ) ) ; set Page Session Attribute (  ENTRY_ LIST , xml ) ; cache Values ( ) ; table Populated = _ BOOL ; forward To ( ) ; }
private void init ( ) { set Title ( _ STR ) ; wta Panel = new  WTAProperties Panel ( network Panel ) ; tab Logic . add ( wta Panel ) ; layout Panel = new  Main Layout Panel ( _ BOOL , this ) ; layout Panel . set Current Layout (  Winner Take All .  DEFAULT_ LAYOUT ) ; tab Layout . add ( layout Panel ) ; tabbed Pane . add Tab ( _ STR , tab Logic ) ; tabbed Pane . add Tab ( _ STR , tab Layout ) ; set Content Pane ( tabbed Pane ) ;  Action help Action = new  Show Help Action ( wta Panel . get Help Path ( ) ) ; add Button ( new  JButton ( help Action ) ) ; }
protected double inner Product ( double [ ] x , double [ ] y ) { double sum = _ NUM ; for ( int i = _ NUM ; i < x . length ; i ++ ) { sum += x [ i ] * y [ i ] ; } return sum ; }
public int hash Code ( ) { int hash Code = this . hash Code ; if ( hash Code == _ NUM ) { hash Code = ( ( group Id . hash Code ( ) * _ NUM + artifact Id . hash Code ( ) ) * _ NUM + version . hash Code ( ) ) * _ NUM + classifier . hash Code ( ) ; if ( hash Code == _ NUM ) { hash Code = - _ NUM ; } this . hash Code = hash Code ; } return hash Code ; }
public void archive List ( ) { }
private static  List find Intersection Nodes (  Polygonize Directed Edge start DE , long label ) {  Polygonize Directed Edge de = start DE ;  List int Nodes = null ; do {  Node node = de . get From Node ( ) ; if ( get Degree ( node , label ) > _ NUM ) { if ( int Nodes == null ) int Nodes = new  Array List ( ) ; int Nodes . add ( node ) ; } de = de . get Next ( ) ;  Assert . is True ( de != null , _ STR ) ;  Assert . is True ( de == start DE || ! de . is In Ring ( ) , _ STR ) ; } while ( de != start DE ) ; return int Nodes ; }
private static byte [ ] create Blob ( byte [ ] target Information , byte [ ] client Nonce , long time ) { byte [ ] blob Signature = new byte [ ] { ( byte ) _ NUM , ( byte ) _ NUM , ( byte ) _ NUM , ( byte ) _ NUM } ; byte [ ] reserved = new byte [ ] { ( byte ) _ NUM , ( byte ) _ NUM , ( byte ) _ NUM , ( byte ) _ NUM } ; byte [ ] unknown1 = new byte [ ] { ( byte ) _ NUM , ( byte ) _ NUM , ( byte ) _ NUM , ( byte ) _ NUM } ; byte [ ] unknown2 = new byte [ ] { ( byte ) _ NUM , ( byte ) _ NUM , ( byte ) _ NUM , ( byte ) _ NUM } ; time += _ NUM ; time *= _ NUM ; byte [ ] timestamp = new byte [ _ NUM ] ; for ( int i = _ NUM ; i < _ NUM ; i ++ ) { timestamp [ i ] = ( byte ) time ; time >>>= _ NUM ; } byte [ ] blob = new byte [ blob Signature . length + reserved . length + timestamp . length + client Nonce . length + unknown1 . length + target Information . length + unknown2 . length ] ; int offset = _ NUM ;  System . arraycopy ( blob Signature , _ NUM , blob , offset , blob Signature . length ) ; offset += blob Signature . length ;  System . arraycopy ( reserved , _ NUM , blob , offset , reserved . length ) ; offset += reserved . length ;  System . arraycopy ( timestamp , _ NUM , blob , offset , timestamp . length ) ; offset += timestamp . length ;  System . arraycopy ( client Nonce , _ NUM , blob , offset , client Nonce . length ) ; offset += client Nonce . length ;  System . arraycopy ( unknown1 , _ NUM , blob , offset , unknown1 . length ) ; offset += unknown1 . length ;  System . arraycopy ( target Information , _ NUM , blob , offset , target Information . length ) ; offset += target Information . length ;  System . arraycopy ( unknown2 , _ NUM , blob , offset , unknown2 . length ) ; return blob ; }
public void remove Event Listener (  Video Sharing Listener listener ) throws  Rcs Service Not Available Exception ,  Rcs Generic Exception { if ( m Api == null ) { throw new  Rcs Service Not Available Exception ( ) ; } try {  Weak Reference <  IVideo Sharing Listener > weak Ref = m Video Sharing Listeners . remove ( listener ) ; if ( weak Ref == null ) { return ; }  IVideo Sharing Listener rcs Listener = weak Ref . get ( ) ; if ( rcs Listener != null ) { m Api . remove Event Listener2 ( rcs Listener ) ; } } catch (  Exception e ) {  Rcs Illegal Argument Exception . assert Exception ( e ) ; throw new  Rcs Generic Exception ( e ) ; } }
public static void create Empty File (  File file , long length ) throws  IOException { if ( file == null || length <= _ NUM ) { throw new  Illegal Argument Exception ( _ STR ) ; } try (  File Output Stream f Out = new  File Output Stream ( file ) ;  File Channel f Channel = f Out . get Channel ( ) ) { f Channel . write (  Byte Buffer . allocate ( _ NUM ) , length - _ NUM ) ; } }
public boolean matches Ignore Case (  String sa ) { if ( _length != sa . length ( ) ) return _ BOOL ; char [ ] buffer = _buffer ; int offset = _offset ; for ( int i = _length - _ NUM ; i >= _ NUM ; i -- ) { char ca = buffer [ offset + i ] ; char cb = sa . char At ( i ) ; if ( ca != cb &&  Character . to Lower Case ( ca ) !=  Character . to Lower Case ( cb ) ) return _ BOOL ; } return _ BOOL ; }
public void close ( ) { flush ( ) ; stop Buffer Timer ( ) ; }
public void remove Series ( int index ) {  Time Series series = get Series ( index ) ; if ( series != null ) { remove Series ( series ) ; } }
public void remove Channel (  Channel channel ) { if ( channel != null ) { switch ( channel . get Channel Type ( ) ) { case  STANDARD : int index = m Channels . index Of ( channel ) ; m Channels . remove ( channel ) ; if ( index >= _ NUM ) { fire Table Rows Deleted ( index , index ) ; } break ; case  TRAFFIC : m Traffic Channels . remove ( channel ) ; break ; default : break ; } broadcast ( new  Channel Event ( channel ,  Event .  NOTIFICATION_ DELETE ) ) ; } }
public static  String join (  Object [ ] array ,  String separator ) { if ( array == null ) { return null ; } if ( array . length == _ NUM ) { return  String Pool .  EMPTY ; } if ( array . length == _ NUM ) { return  String . value Of ( array [ _ NUM ] ) ; } final  String Builder sb = new  String Builder ( array . length * _ NUM ) ; for ( int i = _ NUM ; i < array . length ; i ++ ) { if ( i > _ NUM ) { sb . append ( separator ) ; } sb . append ( array [ i ] ) ; } return sb . to String ( ) ; }
public static boolean is Trait ( final  Class clazz ) { return clazz != null && clazz . get Annotation (  Trait . class ) != null ; }
private boolean validate Old Product (  MProduct product ) { if ( ! product . is BOM ( ) ) return _ BOOL ; if ( m_products . contains ( product ) ) { log . warning ( m_product . get Name ( ) + _ STR + product . get Name ( ) ) ; return _ BOOL ; } m_products . add ( product ) ; log . fine ( product . get Name ( ) ) ;  MProduct BOM [ ] products BOMs =  MProduct BOM . get BOMLines ( product ) ; for ( int i = _ NUM ; i < products BOMs . length ; i ++ ) {  MProduct BOM products BOM = products BOMs [ i ] ;  MProduct pp = new  MProduct ( get Ctx ( ) , products BOM . get M_ Product BOM_ ID ( ) , get_ Trx Name ( ) ) ; if ( ! pp . is BOM ( ) ) log . finer ( pp . get Name ( ) ) ; else if ( ! validate Old Product ( pp ) ) return _ BOOL ; } return _ BOOL ; }
public  List <  Local Date > top ( int n ) {  List <  Local Date > top = new  Array List < > ( ) ; int [ ] values = data . to Int Array ( ) ;  Int Arrays . parallel Quick Sort ( values ,  Reverse Int Comparator . instance ( ) ) ; for ( int i = _ NUM ; i < n && i < values . length ; i ++ ) { top . add (  Packed Local Date . as Local Date ( values [ i ] ) ) ; } return top ; }
@  Override public void load XML (  Node stepnode ,  List <  Database Meta > databases ,  Map <  String ,  Counter > counters ) throws  Kettle XMLException { try { database Name =  XMLHandler . get Tag Value ( stepnode , _ STR ) ; tabel Name =  XMLHandler . get Tag Value ( stepnode , _ STR ) ; mdkey Size =  XMLHandler . get Tag Value ( stepnode , _ STR ) ; measure Count =  XMLHandler . get Tag Value ( stepnode , _ STR ) ; heir And Key Size =  XMLHandler . get Tag Value ( stepnode , _ STR ) ; table Name =  XMLHandler . get Tag Value ( stepnode , _ STR ) ; group By Enabled =  XMLHandler . get Tag Value ( stepnode , _ STR ) ; aggregator Class String =  XMLHandler . get Tag Value ( stepnode , _ STR ) ; aggregator String =  XMLHandler . get Tag Value ( stepnode , _ STR ) ; fact Dim Lens String =  XMLHandler . get Tag Value ( stepnode , _ STR ) ; level Anddata Type String =  XMLHandler . get Tag Value ( stepnode , _ STR ) ; partition ID =  XMLHandler . get Tag Value ( stepnode , _ STR ) ; segment Id =  XMLHandler . get Tag Value ( stepnode , _ STR ) ; task No =  XMLHandler . get Tag Value ( stepnode , _ STR ) ; } catch (  Exception e ) { throw new  Kettle XMLException ( _ STR , e ) ; } }
public void read Data (  Data Input din ) throws  IOException { reference = din . read Unsigned Short ( ) ; bit Count = din . read Unsigned Short ( ) ; }
public static double [ ] random ( int m ) { double [ ] res = new double [ m ] ; for ( int i = _ NUM ; i < m ; ++ i ) { res [ i ] =  Math . random ( ) ; } return ( res ) ; }
public double standard Deviation ( ) { return  Math . sqrt ( variance ( ) ) ; }
public int [ ] value Array ( int [ ] array ) { if ( array == null || array . length != size ( ) ) { array = new int [ count ] ; }  System . arraycopy ( values , _ NUM , array , _ NUM , count ) ; return array ; }
public static int compare ( boolean left , double right ) { return compare ( left ? _ NUM : _ NUM , right ) ; }
public static byte [ ] decode ( byte [ ] in , int len ) { final int in Length =  Math . min ( in . length , len ) ;  Byte Array Output Stream output = new  Byte Array Output Stream ( ( in Length / _ NUM ) * _ NUM + _ NUM ) ; int [ ] pos = new int [ _ NUM ] ; try { while ( pos [ _ NUM ] < in Length ) { int byte Triplet As Int = _ NUM ; for ( int j = _ NUM ; j < _ NUM ; j ++ ) { byte c = get Next Byte ( in , pos , in Length ) ; if ( c ==  END_ OF_ INPUT || c ==  PAD_ AS_ BYTE ) { switch ( j ) { case _ NUM : case _ NUM : return ( c ==  END_ OF_ INPUT ) ? output . to Byte Array ( ) : null ; case _ NUM : if ( c ==  END_ OF_ INPUT ) { return check No Trailing And Return ( output , in , pos [ _ NUM ] , in Length ) ; } pos [ _ NUM ] ++ ; c = get Next Byte ( in , pos , in Length ) ; if ( c ==  END_ OF_ INPUT ) { return check No Trailing And Return ( output , in , pos [ _ NUM ] , in Length ) ; } if ( c ==  PAD_ AS_ BYTE ) { byte Triplet As Int >>= _ NUM ; output . write ( byte Triplet As Int ) ; return check No Trailing And Return ( output , in , pos [ _ NUM ] , in Length ) ; } return null ; case _ NUM : if ( c ==  PAD_ AS_ BYTE ) { byte Triplet As Int >>= _ NUM ; output . write ( byte Triplet As Int > > _ NUM ) ; output . write ( byte Triplet As Int & _ NUM ) ; } return check No Trailing And Return ( output , in , pos [ _ NUM ] , in Length ) ; } } else { byte Triplet As Int <<= _ NUM ; byte Triplet As Int += ( c & _ NUM ) ; pos [ _ NUM ] ++ ; } } output . write ( byte Triplet As Int > > _ NUM ) ; output . write ( ( byte Triplet As Int > > _ NUM ) & _ NUM ) ; output . write ( byte Triplet As Int & _ NUM ) ; } return check No Trailing And Return ( output , in , pos [ _ NUM ] , in Length ) ; } catch (  Invalid Base64 Byte Exception e ) { return null ; } }
private void init Connection ( ) throws  Replicator Exception { try { logger . info ( _ STR + server Port ) ;  Inet Address host =  Inet Address . get By Name ( _ STR ) ; socket = new  Socket ( host , server Port ) ; socket . set So Timeout ( timeout * _ NUM ) ; logger . debug ( _ STR + socket . get Receive Buffer Size ( ) ) ; logger . info ( _ STR + socket . get Remote Socket Address ( ) ) ; to Server = new  Print Writer ( socket . get Output Stream ( ) , _ BOOL ) ; from Server = new  Buffered Reader ( new  Input Stream Reader ( socket . get Input Stream ( ) ) ) ; } catch (  Unknown Host Exception e ) { throw new  Replicator Exception ( _ STR + e , e ) ; } catch (  IOException e ) { throw new  Replicator Exception ( _ STR + e , e ) ; } }
private  String remove Trailing Period (  String val ) { if ( val . char At ( val . length ( ) - _ NUM ) == _ STR ) { val = val . substring ( _ NUM , val . length ( ) - _ NUM ) ; } return val ; }
private boolean is Debuggable (  Level level ) { if ( level . int Value ( ) < debug Level . int Value ( ) || debug Level ==  Level .  OFF ) { return _ BOOL ; } return _ BOOL ; }
static  Object [ ] compute Folder Non Java Resources (  IPackage Fragment Root root ,  IContainer folder , char [ ] [ ] inclusion Patterns , char [ ] [ ] exclusion Patterns ) throws  Java Model Exception {  IResource [ ] non Java Resources = new  IResource [ _ NUM ] ; int non Java Resources Counter = _ NUM ; try {  IResource [ ] members = folder . members ( ) ; int length = members . length ; if ( length > _ NUM ) {  IJava Project other Java Project =  Java Core . create ( folder . get Project ( ) ) ;  String source Level = other Java Project . get Option (  Java Core .  COMPILER_ SOURCE , _ BOOL ) ;  String compliance Level = other Java Project . get Option (  Java Core .  COMPILER_ COMPLIANCE , _ BOOL ) ;  Java Project java Project = (  Java Project ) root . get Java Project ( ) ;  IClasspath Entry [ ] classpath = java Project . get Resolved Classpath ( ) ; next Resource : for ( int i = _ NUM ; i < length ; i ++ ) {  IResource member = members [ i ] ; switch ( member . get Type ( ) ) { case  IResource .  FILE :  String file Name = member . get Name ( ) ; if (  Util . is Valid Compilation Unit Name ( file Name , source Level , compliance Level ) && !  Util . is Excluded ( member , inclusion Patterns , exclusion Patterns ) ) continue next Resource ; if (  Util . is Valid Class File Name ( file Name , source Level , compliance Level ) ) continue next Resource ; if ( is Classpath Entry ( member . get Full Path ( ) , classpath ) ) continue next Resource ; break ; case  IResource .  FOLDER : if (  Util . is Valid Folder Name For Package ( member . get Name ( ) , source Level , compliance Level ) && ( !  Util . is Excluded ( member , inclusion Patterns , exclusion Patterns ) || is Classpath Entry ( member . get Full Path ( ) , classpath ) ) ) continue next Resource ; break ; } if ( non Java Resources . length == non Java Resources Counter ) {  System . arraycopy ( non Java Resources , _ NUM , ( non Java Resources = new  IResource [ non Java Resources Counter * _ NUM ] ) , _ NUM , non Java Resources Counter ) ; } non Java Resources [ non Java Resources Counter ++ ] = member ; } } return non Java Resources ; } catch (  Core Exception e ) { throw new  Java Model Exception ( e ) ; } }
public static  String quote String (  String orig ,  String quote ) { return quote + orig + quote ; }
private void write Net Buffer ( ) throws  Ignite Checked Exception { try { ch . write ( out Net Buf ) ; } catch (  IOException e ) { throw new  Ignite Checked Exception ( _ STR , e ) ; } }
@  Method Desc ( description = _ STR , usage = _ STR ) public  Map <  String ,  String > replicator Status ( @  Param Desc ( name = _ STR , description = _ STR )  String name ) throws  Exception {  Open Replicator Manager MBean mgr = replicators . get ( name ) ; if ( mgr == null ) { throw new  Exception (  String . format ( _ STR , name ) ) ; } return mgr . status ( ) ; }
public synchronized boolean is Consumer (  Image Consumer ic ) { return ics . contains ( ic ) ; }
private synchronized void refresh Sockets ( ) { refresh Aperture ( ) ; int n = pending Sockets + active Sockets . size ( ) ; if ( n < target Aperture && ! active Factories . is Empty ( ) ) { logger . debug ( _ STR , n , target Aperture , target Aperture - n ) ; add Sockets ( target Aperture - n ) ; } else if ( target Aperture < active Sockets . size ( ) ) { logger . debug ( _ STR , n , target Aperture ) ; quick Slowest RS ( ) ; } long now =  Clock . now ( ) ; if ( now - last Refresh < refresh Period ) { return ; } else { long prev = refresh Period ; refresh Period = ( long )  Math . min ( refresh Period * _ NUM , max Refresh Period ) ; logger . info ( _ STR , prev / _ NUM , refresh Period / _ NUM ) ; } last Refresh = now ; add Sockets ( _ NUM ) ; }
private void extract All Children (  List <  Invocation Sequence Data > result List ,  Invocation Sequence Data invocation ) { result List . add ( invocation ) ; for (  Invocation Sequence Data child : invocation . get Nested Sequences ( ) ) { extract All Children ( result List , child ) ; } }
public void test Pawn Moves ( ) throws  Chess Parse Error {  String fen = _ STR ;  Position pos =  Text IO . read FEN ( fen ) ; assert Equals ( fen ,  Text IO . to FEN ( pos ) ) ;  List <  String > str Moves = get Move List ( pos , _ BOOL ) ; assert True ( str Moves . contains ( _ STR ) ) ; assert True ( str Moves . contains ( _ STR ) ) ; assert True ( str Moves . contains ( _ STR ) ) ; assert True ( str Moves . contains ( _ STR ) ) ; assert True ( str Moves . contains ( _ STR ) ) ; assert True ( str Moves . contains ( _ STR ) ) ; assert True ( str Moves . contains ( _ STR ) ) ; assert True ( str Moves . contains ( _ STR ) ) ; assert Equals ( _ NUM , str Moves . size ( ) ) ; pos . set Ep Square ( - _ NUM ) ; str Moves = get Move List ( pos , _ BOOL ) ; assert Equals ( _ NUM , str Moves . size ( ) ) ; pos . set White Move ( _ BOOL ) ; str Moves = get Move List ( pos , _ BOOL ) ; assert True ( str Moves . contains ( _ STR ) ) ; assert True ( str Moves . contains ( _ STR ) ) ; assert True ( str Moves . contains ( _ STR ) ) ; assert True ( str Moves . contains ( _ STR ) ) ; assert Equals ( _ NUM , str Moves . size ( ) ) ; pos . set Piece (  Position . get Square ( _ NUM , _ NUM ) ,  Piece .  BPAWN ) ; str Moves = get Move List ( pos , _ BOOL ) ; assert True ( str Moves . contains ( _ STR ) ) ; assert True ( str Moves . contains ( _ STR ) ) ; assert True ( str Moves . contains ( _ STR ) ) ; assert True ( str Moves . contains ( _ STR ) ) ; }
protected void on Message ( final  String message ) { if ( message != null && message . length ( ) > _ NUM ) { post Message Event ( message ) ; } }
public static  Expr Node [ ] validate (  String view Name ,  Event Type event Type ,  Statement Context statement Context ,  List <  Expr Node > expressions , boolean allow Constant Result ) throws  View Parameter Exception {  List <  Expr Node > results = new  Array List <  Expr Node > ( ) ; int expression Number = _ NUM ;  Stream Type Service stream Type Service = new  Stream Type Service Impl ( event Type , null , _ BOOL , statement Context . get Engine URI ( ) ) ; for (  Expr Node expr : expressions ) {  Expr Node validated = validate Expr ( view Name , statement Context , expr , stream Type Service , expression Number ) ; results . add ( validated ) ; if ( ( ! allow Constant Result ) && ( validated . is Constant Result ( ) ) ) {  String message = _ STR + expression Number + get View Desc ( view Name ) + _ STR ; log . error ( message ) ; throw new  View Parameter Exception ( message ) ; } expression Number ++ ; } return results . to Array ( new  Expr Node [ results . size ( ) ] ) ; }
public static  String trim Comma (  String s ) { if ( s . ends With ( _ STR ) ) { s = s . substring ( _ NUM , s . length ( ) - _ NUM ) ; } return s ; }
@  Override public  String generate URL (  XYDataset dataset , int series , int item ) {  String url = this . prefix ; boolean first Parameter = url . index Of ( _ STR ) == - _ NUM ; url += first Parameter ? _ STR : _ STR ; url += this . series Parameter Name + _ STR + series + _ STR + this . item Parameter Name + _ STR + item ; return url ; }
public boolean is Idle Expire ( ) { if ( ! _lifecycle . is Active ( ) ) { return _ BOOL ; } long now = get Current Time Actual ( ) ; long idle Expire = _thread Idle Expire Time . get ( ) ; int idle Count = _idle Count . get ( ) ; if ( _idle Min < idle Count ) { long next Idle Expire = now + _idle Timeout ; if ( _idle Max < idle Count && _idle Min < _idle Max ) { _thread Idle Expire Time . compare And Set ( idle Expire , next Idle Expire ) ; return _ BOOL ; } else if ( idle Expire < now && _thread Idle Expire Time . compare And Set ( idle Expire , next Idle Expire ) ) { return _ BOOL ; } } return _ BOOL ; }
public void begin Display (  Display Event event ) throws  Model Control Exception { super . begin Display ( event ) ;  Server Site Model model = (  Server Site Model ) get Model ( ) ;  String server Name = (  String ) get Page Session Attribute (  PG_ ATTR_ SERVER_ NAME ) ;  Object [ ] param = { server Name } ; pt Model . set Page Title Text (  Message Format . format ( model . get Localized String ( _ STR ) , param ) ) ; set Display Field Value ( _ STR ,  Message Format . format ( model . get Localized String ( _ STR ) , param ) ) ; }
public void test_tuple Count1_empty Key_deleted ( ) { final int m = _ NUM ; final int nkeys = _ NUM ; final byte [ ] [ ] keys = new byte [ m + _ NUM ] [ ] ; final byte [ ] [ ] vals = new byte [ m + _ NUM ] [ ] ; final boolean [ ] delete Markers = new boolean [ m + _ NUM ] ; final long [ ] version Timestamps = new long [ m + _ NUM ] ; keys [ _ NUM ] = new byte [ _ NUM ] ; delete Markers [ _ NUM ] = _ BOOL ; version Timestamps [ _ NUM ] =  System . current Time Millis ( ) ; final  ILeaf Data expected = mock Leaf Factory ( new  Read Only Keys Raba ( nkeys , keys ) , new  Read Only Values Raba ( nkeys , vals ) , delete Markers , version Timestamps , null ) ; assert True ( expected . get Delete Marker ( _ NUM ) ) ; assert Equals ( version Timestamps [ _ NUM ] , expected . get Version Timestamp ( _ NUM ) ) ; assert Equals ( version Timestamps [ _ NUM ] , expected . get Minimum Version Timestamp ( ) ) ; assert Equals ( version Timestamps [ _ NUM ] , expected . get Maximum Version Timestamp ( ) ) ; do Round Trip Test ( expected , coder , new  Data Output Buffer ( ) ) ; }
void run (  String driver ,  String url ,  String user ,  String password ) throws  Exception {  Class . for Name ( driver ) ; conn =  Driver Manager . get Connection ( url , user , password ) ; stat = conn . create Statement ( ) ; try { stat . execute ( _ STR ) ; } catch (  SQLException e ) { } stat . execute ( _ STR + _ STR ) ; stat . execute ( _ STR ) ; stat . execute ( _ STR ) ; stat . execute ( _ STR ) ; login By Name Insecure ( ) ; if ( url . starts With ( _ STR ) ) { login Stored Procedure Insecure ( ) ; limit Row Access ( ) ; } login By Name Secure ( ) ; if ( url . starts With ( _ STR ) ) { stat . execute ( _ STR ) ; stat . execute ( _ STR ) ; stat . execute ( _ STR ) ; } login By Id Insecure ( ) ; login By Id Secure ( ) ; try { stat . execute ( _ STR ) ; } catch (  SQLException e ) { } stat . execute ( _ STR + _ STR ) ; stat . execute ( _ STR ) ; stat . execute ( _ STR ) ; stat . execute ( _ STR ) ; stat . execute ( _ STR ) ; stat . execute ( _ STR ) ; list Active Items ( ) ; if ( url . starts With ( _ STR ) ) { stat . execute ( _ STR ) ; stat . execute ( _ STR ) ; stat . execute ( _ STR ) ; stat . execute ( _ STR ) ; list Active Items Using Constants ( ) ; } list Items Sorted Insecure ( ) ; list Items Sorted Secure ( ) ; if ( url . starts With ( _ STR ) ) { list Items Sorted Secure Param ( ) ; store Password Hash With Salt ( ) ; } conn . close ( ) ; }
public boolean remove Job Group To Never Delete (  String group ) { return group != null && job Groups To Never Delete . remove ( group ) ; }
private  Mobile Doc create Layout (  Mobile Doc doc ,  MWorkflow wf , int active Node ,  MWFNode [ ] nodes ,  Array List nodes_ ID , int [ ] [ ] image Map ) { body b = doc . get Body ( ) ; b . add Element ( print Workflow ( active Node , wf , nodes , nodes_ ID , image Map ) ) ; b . add Element ( new hr ( ) ) ; b . add Element ( print Description ( active Node , wf , nodes , nodes_ ID ) ) ; b . add Element ( new br ( ) ) ; b . add Element ( print Control Panel ( active Node , wf , nodes , nodes_ ID ) ) ; return doc ; }
@  Override public void request Close Read ( ) { _state = _state . to Close Read ( ) ; try { request Loop ( ) ; } catch (  Exception e ) { log . log (  Level .  WARNING , e . to String ( ) , e ) ; } }
static  Predicate field Match (  String field ,  Enum value ) { return field Match ( field , value . name ( ) , _ BOOL ) ; }
public static int calculate Connection Server Count ( int vmcount ) {  Float f = ( vmcount / ( float ) _ NUM ) ; f = ( float )  Math . ceil ( f ) ; if ( f >= _ NUM ) { f ++ ; f ++ ; } else { f ++ ; } final int i = f . int Value ( ) ; return i ; }
public void await All Acks Received ( ) throws  Ignite Interrupted Checked Exception { lock . lock ( ) ; try { while ( ! ack Map . is Empty ( ) )  U . await ( all Acks Rcv Cond ) ; } finally { lock . unlock ( ) ; } }
public  String to String For Quest State ( ) { final  String Builder sb = new  String Builder ( ) ; boolean first = _ BOOL ; for ( final  Map .  Entry <  String ,  Integer > e : entry Set ( ) ) { if ( first ) { first = _ BOOL ; } else { sb . append ( _ STR ) ; } sb . append ( e . get Key ( ) ) ; sb . append ( _ STR ) ; sb . append ( e . get Value ( ) ) ; } return sb . to String ( ) ; }
public static byte [ ] copy ( byte [ ] src , byte [ ] target ) { if ( target . length < src . length ) { target = new byte [ src . length ] ; }  System . arraycopy ( src , _ NUM , target , _ NUM , src . length ) ; return target ; }
public double linear Distance (  Location location ) { if ( location == null ) { throw new  Illegal Argument Exception (  Logger . log Message (  Logger .  ERROR , _ STR , _ STR , _ STR ) ) ; } double lat1 =  Math . to Radians ( this . latitude ) ; double lon1 =  Math . to Radians ( this . longitude ) ; double lat2 =  Math . to Radians ( location . latitude ) ; double lon2 =  Math . to Radians ( location . longitude ) ; if ( lat1 == lat2 && lon1 == lon2 ) { return _ NUM ; } double d Lat = lat2 - lat1 ; double d Lon = lon2 - lon1 ; if (  Math . abs ( d Lon ) >  Math .  PI ) { d Lon = d Lon > _ NUM ? - ( _ NUM *  Math .  PI - d Lon ) : ( _ NUM *  Math .  PI + d Lon ) ; } double distance Radians =  Math . sqrt ( d Lat * d Lat + d Lon * d Lon ) ; return  Double . is Na N ( distance Radians ) ? _ NUM : distance Radians ; }
public boolean parse Xml Resource (  File file ) {  Reader reader = null ; try { reader = new  Buffered Reader ( new  File Reader ( file ) ) ; return parse Xml Resource ( file . get Path ( ) , new  Input Source ( reader ) ) ; } catch (  File Not Found Exception e ) { logger . warning ( _ STR + file + _ STR + e . get Message ( ) ) ; return _ BOOL ; } finally { if ( reader != null ) { try { reader . close ( ) ; } catch (  IOException e ) { } } } }
public void add Operator (  Operator operator , int index ) { if ( operator == null ) { throw new  Null Pointer Exception ( _ STR ) ; } if ( operator instanceof  Process Root Operator ) { throw new  Illegal Argument Exception ( _ STR ) ; } operators . add ( index , operator ) ; register Operator ( operator , _ BOOL ) ; }
@  Override public void modify Variable Id (  String old Id ,  String new Id ) { if ( variable . equals ( old Id ) ) { variable = new Id ; } }
public void add Attribute Spec (  String spec ) {  Attribute Spec new Spec = new  Attribute Spec ( spec ) ; m_attribute Specs . add ( new Spec ) ; }
public static  Integer make Integer (  String s ) { if (  WWUtil . is Empty ( s ) ) { return null ; } try { return  Integer . value Of ( s ) ; } catch (  Number Format Exception e ) { return null ; } }
protected final void add Workers (  Collection <  Worker Thread > workers ) { for ( final  Iterator <  Worker Thread > iter = workers . iterator ( ) ; iter . has Next ( ) ; ) { final  Worker Thread worker = iter . next ( ) ; add Worker ( worker ) ; } }
@  Override public  Object clone ( ) {  Object clone = null ; try { clone = super . clone ( ) ; } catch (  Clone Not Supported Exception e ) { e . print Stack Trace ( ) ; } return clone ; }
@  Override public int hash Code ( ) { int hc = hash Code Value ; if ( hc == _ NUM ) { hc = base Locale . hash Code ( ) ; if ( locale Extensions != null ) { hc ^= locale Extensions . hash Code ( ) ; } hash Code Value = hc ; } return hc ; }
void initialize Evaluation Weights ( ) { ps Weight = users . size ( ) * subject Weight ; pr Weight = rules . size ( ) * rule Weight ; pc Weight = conditions . size ( ) * condition Weight ; }
private static  String make Qualified Method Name (  String name ,  String [ ] params ) {  String Buffer sb = new  String Buffer ( name ) ; sb . append ( _ STR ) ; for ( int i = _ NUM ; i < params . length ; i ++ ) { sb . append ( _ STR ) ; sb . append ( params [ i ] ) ; } return sb . to String ( ) ; }
void write ( ) { clear Attributes ( ) ; if ( term Attribute . length ( ) < buffer . length ( ) ) { term Attribute . resize Buffer ( buffer . length ( ) ) ; } char termbuffer [ ] = term Attribute . buffer ( ) ; buffer . get Chars ( _ NUM , buffer . length ( ) , termbuffer , _ NUM ) ; term Attribute . set Length ( buffer . length ( ) ) ; if ( has Illegal Offsets ) { offset Attribute . set Offset ( saved Start Offset , saved End Offset ) ; } else { offset Attribute . set Offset ( start Offset , end Offset ) ; } pos Inc Attribute . set Position Increment ( position ( _ BOOL ) ) ; type Attribute . set Type ( saved Type ) ; accum Pos Inc = _ NUM ; }
public  Pattern extract Ip (  String str ) {  Pattern pattern = null ;  String [ ] ips = str . split ( _ STR ) ;  List <  Ip Node > ip Nodes = new  Array List < > ( ) ; for (  String ip : ips ) { ip = ip . trim ( ) ; if ( ip . index Of ( _ STR ) != - _ NUM ) { int mask =  Integer . value Of ( ip . substring ( ip . index Of ( _ STR ) + _ NUM ) ) ; ip = ip . substring ( _ NUM , ip . index Of ( _ STR ) ) ; while ( ip . split ( _ STR ) . length < _ NUM ) { ip += _ STR ; }  Ip Node node = new  Ip Node ( ip , mask ) ; ip Nodes . add ( node ) ; } else {  Ip Node node = new  Ip Node ( ip , _ NUM ) ; ip Nodes . add ( node ) ; } } pattern = new  Ip Pattern ( ip Nodes ) ; return pattern ; }
void dispose ( ) { }
public  Object parse Object (  String source ,  Parse Position pos ) { return null ; }
public  Stream <  T > stream ( ) { return  Stream Support . stream ( spliterator ( ) , _ BOOL ) ; }
private  Modifiers ( int rain Mod , int temp Mod , int fog Mod ) { rain = rain Mod ; temperature = temp Mod ; fog = fog Mod ; }
protected  Size2 D arrange NN (  Block Container container ,  Graphics2 D g2 ) { double max W = _ NUM ; double max H = _ NUM ;  List blocks = container . get Blocks ( ) ;  Iterator iterator = blocks . iterator ( ) ; while ( iterator . has Next ( ) ) {  Block b = (  Block ) iterator . next ( ) ; if ( b != null ) {  Size2 D s = b . arrange ( g2 ,  Rectangle Constraint .  NONE ) ; max W =  Math . max ( max W , s . width ) ; max H =  Math . max ( max H , s . height ) ; } } double width = this . columns * max W ; double height = this . rows * max H ;  Rectangle Constraint c = new  Rectangle Constraint ( width , height ) ; return arrange FF ( container , g2 , c ) ; }
public static  Charset for Content Type (  String content Type ) { return for Content Type ( content Type ,  DEFAULT_ HTTP_ ENCODING ) ; }
public static org . opcfoundation . ua . transport . security .  Key Pair create Https Certificate (  String host Name ,  String application Uri , int days , org . opcfoundation . ua . transport . security .  Key Pair issuer Cert ) throws  IOException ,  General Security Exception { if ( application Uri == null ) throw new  Null Pointer Exception ( _ STR ) ; if ( logger . is Debug Enabled ( ) ) logger . debug ( _ STR ,  Arrays . to String (  Security . get Providers ( ) ) ) ;  Key Pair key Pair = generate Key Pair ( ) ;  X509 Certificate cert ; cert = generate Certificate ( _ STR + host Name , days , application Uri , key Pair . get Public ( ) , key Pair . get Private ( ) , issuer Cert ) ; return to Key Pair ( cert , key Pair . get Private ( ) ) ; }
public void handle Button1 Request (  Request Invocation Event event ) throws  Model Control Exception { submit Cycle = _ BOOL ;  String sub Config Name = (  String ) get Display Field Value (  ATTR_ SUBCONFIG_ NAME ) ;  Sub Config Model model = (  Sub Config Model ) get Model ( ) ; try {  AMProperty Sheet ps = (  AMProperty Sheet ) get Child (  PROPERTY_ ATTRIBUTE ) ;  String schema Name = (  String ) get Page Session Attribute (  AMService Profile .  PG_ SESSION_ SUB_ SCHEMA_ NAME ) ;  Map values = ps . get Attribute Values ( model . get Attribute Names ( schema Name ) ) ; model . create Sub Config ( sub Config Name , schema Name , values ) ; back To Profile View Bean ( ) ; } catch (  AMConsole Exception e ) { set Inline Alert Message (  CCAlert .  TYPE_ ERROR , _ STR , e . get Message ( ) ) ; forward To ( ) ; } }
public int read ( byte [ ] b , int off , int len ) throws  IOException { if ( closed ) { throw new  IOException ( _ STR ) ; } if ( len == _ NUM ) { return _ NUM ; } int res = available ( ) ; if ( res == _ NUM ) { res = make Available ( ) ; if ( res == _ NUM ) { return - _ NUM ; } } res =  Math . min ( res , len ) ;  System . arraycopy ( buffer , head , b , off , res ) ; head += res ; total += res ; return res ; }
public void children Removed (  Bean Context Membership Event bcme ) {  Iterator it = bcme . iterator ( ) ; while ( it . has Next ( ) ) { find And Undo ( it . next ( ) ) ; } }
public static  File create Dir If Not Exists (  File directory ) throws  IOException { if ( ! directory . is Directory ( ) ) { if ( ! directory . mkdirs ( ) ) { throw new  IOException ( _ STR + directory . get Absolute Path ( ) ) ; } } return directory ; }
public  String to Clock ( ) {  String Builder s = new  String Builder ( ) ; s . append ( ( ( this . weeks * _ NUM + this . days ) * _ NUM + this . hours ) + _ STR ) ; if ( this . minutes < _ NUM ) { s . append ( _ STR ) ; } s . append ( this . minutes + _ STR ) ; if ( this . seconds < _ NUM ) { s . append ( _ STR ) ; } s . append ( this . seconds + _ STR ) ; if ( this . milliseconds < _ NUM ) { s . append ( _ STR ) ; } if ( this . milliseconds < _ NUM ) { s . append ( _ STR ) ; } s . append ( this . milliseconds ) ; return s . to String ( ) ; }
public boolean is Keyword (  Name name ) { return keywords . contains ( name ) ; }
public static boolean has Group (  Matcher matcher ) { return matcher . group Count ( ) > _ NUM ; }
public boolean equals (  Object other ) { if ( other == null ) return _ BOOL ; if ( get Class ( ) != other . get Class ( ) ) { return _ BOOL ; }  Host Port that = (  Host Port ) other ; return port == that . port && host . equals ( that . host ) ; }
String rename Type (  Type type ) { if ( type == null ) { return null ; } if ( type . get Sort ( ) ==  Type .  OBJECT ) {  String in = type . get Internal Name ( ) ; return _ STR + rename Internal Type ( in ) + _ STR ; } else if ( type . get Sort ( ) ==  Type .  ARRAY ) {  String Builder sb = new  String Builder ( ) ; for ( int n = type . get Dimensions ( ) ; n > _ NUM ; n -- ) { sb . append ( _ STR ) ; } sb . append ( rename Type ( type . get Element Type ( ) ) ) ; return sb . to String ( ) ; } return type . get Descriptor ( ) ; }
public static void write Element List (  XMLOutput xml Output ,  String tag Name ,  Iterator <  String > list Value Iterator ) throws  IOException { while ( list Value Iterator . has Next ( ) ) { xml Output . open Tag ( tag Name ) ; xml Output . write Text ( list Value Iterator . next ( ) ) ; xml Output . close Tag ( tag Name ) ; } }
public  DPolicy Mappings (  JDialog parent ) { super ( parent ) ; set Title ( res . get String ( _ STR ) ) ; init Components ( ) ; }
private void add To Map (  Map <  String ,  Collection <  Cluster Node > > cache Map ,  String cache Name ,  Cluster Node rich ) {  Collection <  Cluster Node > cache Nodes = cache Map . get ( cache Name ) ; if ( cache Nodes == null ) { cache Nodes = new  Array List < > ( all Nodes . size ( ) ) ; cache Map . put ( cache Name , cache Nodes ) ; } cache Nodes . add ( rich ) ; }
public static final void write Int Array Xml ( int [ ] val ,  String name ,  Xml Serializer out ) throws  Xml Pull Parser Exception , java . io .  IOException { if ( val == null ) { out . start Tag ( null , _ STR ) ; out . end Tag ( null , _ STR ) ; return ; } out . start Tag ( null , _ STR ) ; if ( name != null ) { out . attribute ( null , _ STR , name ) ; } final int  N = val . length ; out . attribute ( null , _ STR ,  Integer . to String (  N ) ) ; for ( int i = _ NUM ; i <  N ; i ++ ) { out . start Tag ( null , _ STR ) ; out . attribute ( null , _ STR ,  Integer . to String ( val [ i ] ) ) ; out . end Tag ( null , _ STR ) ; } out . end Tag ( null , _ STR ) ; }
public void cancel Requests By TAG (  Object  TAG , boolean may Interrupt If Running ) { if (  TAG == null ) { log . d (  LOG_ TAG , _ STR ) ; return ; } for (  List <  Request Handle > request List : request Map . values ( ) ) { if ( request List != null ) { for (  Request Handle request Handle : request List ) { if (  TAG . equals ( request Handle . get Tag ( ) ) ) request Handle . cancel ( may Interrupt If Running ) ; } } } }
public static void draw Circled Text (  Graphics2 D g ,  Font font ,  String text , int x , int y ) {  Graphics2 D g2 = (  Graphics2 D ) g . create ( ) ; g2 . set Font ( font ) ;  Font Metrics fm = g2 . get Font Metrics ( ) ; int padding = _ NUM ;  Rectangle2 D bounds = fm . get String Bounds ( text , g2 ) ; double th = bounds . get Height ( ) ; double tw = bounds . get Width ( ) ; float radius = ( float ) (  Math . max ( th , tw ) / _ NUM + padding ) ;  Ellipse2 D .  Float circle = new  Ellipse2 D .  Float ( x - radius , y - radius , _ NUM * radius + _ NUM , _ NUM * radius + _ NUM ) ; g2 . fill ( circle ) ; g2 . set Color (  Color .  BLACK ) ; g2 . draw String ( text , ( int ) ( x - tw / _ NUM ) , ( y + fm . get Ascent ( ) / _ NUM ) ) ; if (  DEBUG ) { g2 . set Color (  Color .  RED ) ; g2 . draw Line ( x - _ NUM , y , x + _ NUM , y ) ; g2 . draw Line ( x , y - _ NUM , x , y + _ NUM ) ; } g2 . dispose ( ) ; }
private double [ ] subset Array ( double [ ] x , int start , int end ) { double [ ] subset = new double [ end - start + _ NUM ] ;  System . arraycopy ( x , start , subset , _ NUM , end - start + _ NUM ) ; return subset ; }
@  Override public void execute (  Runnable runnable ) { if ( runnable == null ) { throw new  Null Pointer Exception ( _ STR ) ; } if ( ! m Work Queue . offer ( runnable ) ) { throw new  Rejected Execution Exception ( m Name + _ STR + m Work Queue . size ( ) ) ; } final int queue Size = m Work Queue . size ( ) ; final int max Size = m Max Queue Size . get ( ) ; if ( ( queue Size > max Size ) && m Max Queue Size . compare And Set ( max Size , queue Size ) ) {  FLog . v (  TAG , _ STR , m Name , queue Size ) ; } start Worker If Needed ( ) ; }
public  Object [ ] align Cells (  String align ,  Object [ ] cells ,  Object param ) { if ( cells == null ) { cells = get Selection Cells ( ) ; } if ( cells != null && cells . length > _ NUM ) { if ( param == null ) { for ( int i = _ NUM ; i < cells . length ; i ++ ) { mx Geometry geo = get Cell Geometry ( cells [ i ] ) ; if ( geo != null && ! model . is Edge ( cells [ i ] ) ) { if ( param == null ) { if ( align == null || align . equals ( mx Constants .  ALIGN_ LEFT ) ) { param = geo . get X ( ) ; } else if ( align . equals ( mx Constants .  ALIGN_ CENTER ) ) { param = geo . get X ( ) + geo . get Width ( ) / _ NUM ; break ; } else if ( align . equals ( mx Constants .  ALIGN_ RIGHT ) ) { param = geo . get X ( ) + geo . get Width ( ) ; } else if ( align . equals ( mx Constants .  ALIGN_ TOP ) ) { param = geo . get Y ( ) ; } else if ( align . equals ( mx Constants .  ALIGN_ MIDDLE ) ) { param = geo . get Y ( ) + geo . get Height ( ) / _ NUM ; break ; } else if ( align . equals ( mx Constants .  ALIGN_ BOTTOM ) ) { param = geo . get Y ( ) + geo . get Height ( ) ; } } else { double tmp =  Double . parse Double (  String . value Of ( param ) ) ; if ( align == null || align . equals ( mx Constants .  ALIGN_ LEFT ) ) { param =  Math . min ( tmp , geo . get X ( ) ) ; } else if ( align . equals ( mx Constants .  ALIGN_ RIGHT ) ) { param =  Math . max ( tmp , geo . get X ( ) + geo . get Width ( ) ) ; } else if ( align . equals ( mx Constants .  ALIGN_ TOP ) ) { param =  Math . min ( tmp , geo . get Y ( ) ) ; } else if ( align . equals ( mx Constants .  ALIGN_ BOTTOM ) ) { param =  Math . max ( tmp , geo . get Y ( ) + geo . get Height ( ) ) ; } } } } } model . begin Update ( ) ; try { double tmp =  Double . parse Double (  String . value Of ( param ) ) ; for ( int i = _ NUM ; i < cells . length ; i ++ ) { mx Geometry geo = get Cell Geometry ( cells [ i ] ) ; if ( geo != null && ! model . is Edge ( cells [ i ] ) ) { geo = ( mx Geometry ) geo . clone ( ) ; if ( align == null || align . equals ( mx Constants .  ALIGN_ LEFT ) ) { geo . set X ( tmp ) ; } else if ( align . equals ( mx Constants .  ALIGN_ CENTER ) ) { geo . set X ( tmp - geo . get Width ( ) / _ NUM ) ; } else if ( align . equals ( mx Constants .  ALIGN_ RIGHT ) ) { geo . set X ( tmp - geo . get Width ( ) ) ; } else if ( align . equals ( mx Constants .  ALIGN_ TOP ) ) { geo . set Y ( tmp ) ; } else if ( align . equals ( mx Constants .  ALIGN_ MIDDLE ) ) { geo . set Y ( tmp - geo . get Height ( ) / _ NUM ) ; } else if ( align . equals ( mx Constants .  ALIGN_ BOTTOM ) ) { geo . set Y ( tmp - geo . get Height ( ) ) ; } model . set Geometry ( cells [ i ] , geo ) ; if ( is Reset Edges On Move ( ) ) { reset Edges ( new  Object [ ] { cells [ i ] } ) ; } } } fire Event ( new mx Event Object ( mx Event .  ALIGN_ CELLS , _ STR , cells , _ STR , align ) ) ; } finally { model . end Update ( ) ; } } return cells ; }
private  Point2 D rotate (  Point2 D a ,  Point2 D center , double angle ) { double result X = center . get X ( ) + ( a . get X ( ) - center . get X ( ) ) *  Math . cos ( angle ) - ( a . get Y ( ) - center . get Y ( ) ) *  Math . sin ( angle ) ; double result Y = center . get Y ( ) + ( a . get X ( ) - center . get X ( ) ) *  Math . sin ( angle ) + ( a . get Y ( ) - center . get Y ( ) ) *  Math . cos ( angle ) ; return new  Point2 D ( result X , result Y ) ; }
public void list (  Print Stream out , int indent ) { for ( int i = _ NUM ; i < indent ; i ++ ) { out . print ( _ STR ) ; } out . println ( this ) ; }
private void init ( ) { set Title ( _ STR ) ; competitive Panel =  Competitive Properties Panel . create Competitive Properties Panel ( network Panel ,  Competitive Props Panel Type .  CREATE_ NETWORK ) ; tab Logic . add ( competitive Panel ) ; layout Panel = new  Main Layout Panel ( _ BOOL , this ) ; layout Panel . set Current Layout ( new  Line Layout ( ) ) ; tab Layout . add ( layout Panel ) ; tabbed Pane . add Tab ( _ STR , tab Logic ) ; tabbed Pane . add Tab ( _ STR , layout Panel ) ; set Content Pane ( tabbed Pane ) ;  Action help Action = new  Show Help Action ( competitive Panel . get Help Path ( ) ) ; add Button ( new  JButton ( help Action ) ) ; }
public static  Revocation Status check (  X509 Certificate cert ,  X509 Certificate issuer Cert ,  URI responder URI ,  X509 Certificate responder Cert ,  Date date ) throws  IOException ,  Cert Path Validator Exception { return check ( cert , issuer Cert , responder URI , responder Cert , date ,  Collections . <  Extension > empty List ( ) ) ; }
public  Shape paint Layer (  Graphics g , int offs0 , int offs1 ,  Shape bounds ,  JText Component c ,  View view ) {  Graphics2 D g2d = (  Graphics2 D ) g ;  Composite original Composite = null ; if ( get Alpha ( ) < _ NUM ) { original Composite = g2d . get Composite ( ) ; g2d . set Composite ( get Alpha Composite ( ) ) ; }  Paint paint = get Paint ( ) ; if ( paint == null ) g2d . set Color ( c . get Selection Color ( ) ) ; else g2d . set Paint ( paint ) ; if ( offs0 == view . get Start Offset ( ) && offs1 == view . get End Offset ( ) ) {  Rectangle alloc ; if ( bounds instanceof  Rectangle ) alloc = (  Rectangle ) bounds ; else alloc = bounds . get Bounds ( ) ; g2d . fill Rect ( alloc . x , alloc . y , alloc . width , alloc . height ) ; if ( get Alpha ( ) < _ NUM ) g2d . set Composite ( original Composite ) ; return alloc ; } else { try {  Shape shape = view . model To View ( offs0 ,  Position .  Bias .  Forward , offs1 ,  Position .  Bias .  Backward , bounds ) ;  Rectangle r = ( shape instanceof  Rectangle ) ? (  Rectangle ) shape : shape . get Bounds ( ) ; if ( rounded Edges ) { g2d . fill Round Rect ( r . x , r . y , r . width , r . height ,  ARCWIDTH ,  ARCHEIGHT ) ; } else { g2d . fill Rect ( r . x , r . y , r . width , r . height ) ; } if ( get Alpha ( ) < _ NUM ) g2d . set Composite ( original Composite ) ; return r ; } catch (  Bad Location Exception ble ) { ble . print Stack Trace ( ) ; } finally { if ( get Alpha ( ) < _ NUM ) g2d . set Composite ( original Composite ) ; } } return null ; }
public static  State load Binary (  Data Input Stream dis ) throws  IOException {  String [ ] phone List ; int phone List Length = dis . read Int ( ) ; if ( phone List Length == _ NUM ) { phone List = null ; } else { phone List = new  String [ phone List Length ] ; } for ( int i = _ NUM ; i < phone List Length ; i ++ ) { int index = dis . read Int ( ) ; phone List [ i ] = (  String ) phoneme Table . get ( index ) ; } return new  Final State ( phone List ) ; }
public static  File rename File (  File file ,  String new Name ) {  String absolute Path = file . get Absolute Path ( ) ;  String file Name = file . get Name ( ) ;  String new Absolute Path = absolute Path . substring ( _ NUM , absolute Path . last Index Of ( file Name ) ) + new Name ; return new  File ( new Absolute Path ) ; }
static double svd_dmax ( double a , double b ) { return  Math . max ( a , b ) ; }
private  Json Writer open (  Json Scope empty ,  String open Bracket ) throws  IOException { before Value ( _ BOOL ) ; stack . add ( empty ) ; out . write ( open Bracket ) ; return this ; }
public double calculate Value ( double log ) { return  Math . pow ( this . base , log ) ; }
public void add (  File file ,  String password ) throws  IOException ,  Unsupported Encoding Exception {  File Input Stream fis = new  File Input Stream ( file ) ; try { add ( file . get Path ( ) , fis , password ) ; } finally { fis . close ( ) ; } }
public void clear Cache ( ) {  Zip File zip File = _zip File Ref . get And Set ( null ) ; if ( zip File != null ) try { zip File . close ( ) ; } catch (  Exception e ) { } }
public boolean is Empty ( ) { return size ( ) == _ NUM ; }
public  Ecu Code List (  String resource Bundle Name ) { codes =  Resource Bundle . get Bundle ( resource Bundle Name ) ; }
public void stop ( ) { clear Cache ( ) ; if ( worker == null && conn == null ) { return ; } if ( looper != null ) { looper . quit ( ) ; } if ( worker != null ) { worker . interrupt ( ) ; try { worker . join ( ) ; } catch (  Interrupted Exception e ) {  Log . i (  TAG , _ STR ) ; e . print Stack Trace ( ) ; worker . stop ( ) ; } worker = null ; } if ( bos != null ) { try { bos . close ( ) ; } catch (  IOException e ) {  Log . i (  TAG , _ STR ) ; e . print Stack Trace ( ) ; } bos = null ; } if ( conn != null ) { conn . disconnect ( ) ; conn = null ; }  Log . i (  TAG ,  String . format ( _ STR , url ) ) ; }
public  Catalog Entry ( int type ,  Vector args ) throws  Catalog Exception { try {  Integer i Args = (  Integer ) entry Args . get ( type ) ; if ( i Args . int Value ( ) != args . size ( ) ) { throw new  Catalog Exception (  Catalog Exception .  INVALID_ ENTRY ) ; } } catch (  Array Index Out Of Bounds Exception e ) { throw new  Catalog Exception (  Catalog Exception .  INVALID_ ENTRY_ TYPE ) ; } entry Type = type ; this . args = args ; }
public long count ( ) { return count . get ( ) ; }
public void push ( final int a ) { if ( pointer >= stack . length ) { final int [ ] new Stack = new int [ ( int ) ( stack . length * _ NUM ) ] ;  System . arraycopy ( stack , _ NUM , new Stack , _ NUM , stack . length ) ; stack = new Stack ; } stack [ pointer ] = a ; pointer ++ ; }
public  Gossip Service (  String cluster ,  String ip Address , int port ,  String id ,  List <  Gossip Member > gossip Members ,  Gossip Settings settings ,  Gossip Listener listener ) throws  Interrupted Exception ,  Unknown Host Exception { gossip Manager = new  Random Gossip Manager ( cluster , ip Address , port , id , settings , gossip Members , listener ) ; }
public  Wildcard Pattern (  String pattern , boolean is Case Sensitive ,  String delimiters ) { this ( pattern , is Case Sensitive , _ BOOL , delimiters ) ; }
public int hash Code ( ) { int hash = type . hash Code ( ) ; if ( name != null ) hash ^= name . hash Code ( ) ; if ( actions != null ) hash ^= actions . hash Code ( ) ; return hash ; }
public  AMService Profile Model Impl (  Http Servlet Request req ,  String service Name ,  Map map ) throws  AMConsole Exception { super ( req , map ) ; this . service Name = service Name ; try { xml Builder = new  Property XMLBuilder ( service Name , get Display Schema Types ( ) , this ) ; if ( service Name . equals (  ADMIN_ CONSOLE_ SERVICE ) &&  Service Manager . is Realm Enabled ( ) ) {  AMView Config config =  AMView Config . get Instance ( ) ; xml Builder . discard Attribute ( config . get Realm Enable Hidden Console Attr Names ( ) ) ; } } catch (  SMSException e ) { throw new  AMConsole Exception ( get Error String ( e ) ) ; } catch (  SSOException e ) { throw new  AMConsole Exception ( get Error String ( e ) ) ; } }
public boolean equals (  Object obj ) { if ( obj == null || ( ! ( obj instanceof  Timestamp ) ) ) { return _ BOOL ; }  Timestamp that = (  Timestamp ) obj ; if ( this == that ) { return _ BOOL ; } return ( timestamp . equals ( that . get Timestamp ( ) ) && signer Cert Path . equals ( that . get Signer Cert Path ( ) ) ) ; }
public static int convert To Color Int (  String argb ) throws  Number Format Exception { if ( argb . starts With ( _ STR ) ) { argb = argb . replace ( _ STR , _ STR ) ; } int alpha = - _ NUM , red = - _ NUM , green = - _ NUM , blue = - _ NUM ; if ( argb . length ( ) == _ NUM ) { alpha =  Integer . parse Int ( argb . substring ( _ NUM , _ NUM ) , _ NUM ) ; red =  Integer . parse Int ( argb . substring ( _ NUM , _ NUM ) , _ NUM ) ; green =  Integer . parse Int ( argb . substring ( _ NUM , _ NUM ) , _ NUM ) ; blue =  Integer . parse Int ( argb . substring ( _ NUM , _ NUM ) , _ NUM ) ; } else if ( argb . length ( ) == _ NUM ) { alpha = _ NUM ; red =  Integer . parse Int ( argb . substring ( _ NUM , _ NUM ) , _ NUM ) ; green =  Integer . parse Int ( argb . substring ( _ NUM , _ NUM ) , _ NUM ) ; blue =  Integer . parse Int ( argb . substring ( _ NUM , _ NUM ) , _ NUM ) ; } return  Color . argb ( alpha , red , green , blue ) ; }
@  Override public void on Action ( ) { on Action (  Action Type .  OPEN ) ; }
public  Dimensional Node Iterator (  Dimensional Node node ) { if ( node == null ) { throw new  Null Pointer Exception ( _ STR ) ; } stack . add ( new  Moment ( node , left ) ) ; advance ( ) ; }
@  Override public void start Element (  String namespace URI ,  String local Name ,  String q Name ,  Attributes atts ) throws  SAXException { if ( q Name . equals (  KEY_ TAG ) ) { clear Current Text ( ) ; } else { throw new  SAXException ( _ STR + q Name ) ; } }
public void cancel ( ) { }
private  String test Comparison String ( ) {  Attribute att = m_ Dataset . attribute ( m_ Att Index ) ; if ( att . is Numeric ( ) ) { return ( ( m_ Not ? _ STR : _ STR ) +  Utils . double To String ( m_ Split , _ NUM ) ) ; } else { if ( att . num Values ( ) != _ NUM ) { return ( ( m_ Not ? _ STR : _ STR ) + att . value ( ( int ) m_ Split ) ) ; } else { return ( _ STR + ( m_ Not ? att . value ( ( int ) m_ Split == _ NUM ? _ NUM : _ NUM ) : att . value ( ( int ) m_ Split ) ) ) ; } } }
public void initialize (  Context context , int initial Hours Of Day , int initial Minutes , boolean is24 Hour Mode , boolean vibrate ) { if ( m Time Initialized ) {  Log . e (  TAG , _ STR ) ; return ; } m Is24 Hour Mode = is24 Hour Mode ; m Hide Am Pm =  Utils . is Touch Exploration Enabled ( m Accessibility Manager ) ? _ BOOL : m Is24 Hour Mode ; m Vibrate = vibrate ; m Circle View . initialize ( context , m Hide Am Pm ) ; m Circle View . invalidate ( ) ; if ( ! m Hide Am Pm ) { m Am Pm Circles View . initialize ( context , initial Hours Of Day < _ NUM ?  AM :  PM ) ; m Am Pm Circles View . invalidate ( ) ; }  Resources res = context . get Resources ( ) ; int [ ] hours = { _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM } ; int [ ] hours_24 = { _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM } ; int [ ] minutes = { _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM } ;  String [ ] hours Texts = new  String [ _ NUM ] ;  String [ ] inner Hours Texts = new  String [ _ NUM ] ;  String [ ] minutes Texts = new  String [ _ NUM ] ; for ( int i = _ NUM ; i < _ NUM ; i ++ ) { hours Texts [ i ] = is24 Hour Mode ?  String . format ( _ STR , hours_24 [ i ] ) :  String . format ( _ STR , hours [ i ] ) ; inner Hours Texts [ i ] =  String . format ( _ STR , hours [ i ] ) ; minutes Texts [ i ] =  String . format ( _ STR , minutes [ i ] ) ; } m Hour Radial Texts View . initialize ( res , hours Texts , ( is24 Hour Mode ? inner Hours Texts : null ) , m Hide Am Pm , _ BOOL ) ; m Hour Radial Texts View . invalidate ( ) ; m Minute Radial Texts View . initialize ( res , minutes Texts , null , m Hide Am Pm , _ BOOL ) ; m Minute Radial Texts View . invalidate ( ) ; set Value For Item (  HOUR_ INDEX , initial Hours Of Day ) ; set Value For Item (  MINUTE_ INDEX , initial Minutes ) ; int hour Degrees = ( initial Hours Of Day % _ NUM ) *  HOUR_ VALUE_ TO_ DEGREES_ STEP_ SIZE ; m Hour Radial Selector View . initialize ( context , m Hide Am Pm , is24 Hour Mode , _ BOOL , hour Degrees , is Hour Inner Circle ( initial Hours Of Day ) ) ; int minute Degrees = initial Minutes *  MINUTE_ VALUE_ TO_ DEGREES_ STEP_ SIZE ; m Minute Radial Selector View . initialize ( context , m Hide Am Pm , _ BOOL , _ BOOL , minute Degrees , _ BOOL ) ; m Time Initialized = _ BOOL ; }
@  Override protected void prepare Block ( ) { double [ ] frame = get Next Frame ( ) ; if ( frame == null ) return ; int frame Length = frame Provider . get Frame Length Samples ( ) ; if ( processor != null ) processor . apply Inline ( frame , _ NUM , frame Length ) ; if ( output Window != null ) output Window . apply Inline ( frame , _ NUM , frame Length ) ; if ( memory . length < frame Length ) { double [ ] old Memory = memory ; memory = new double [ frame Length ] ;  System . arraycopy ( old Memory , _ NUM , memory , _ NUM , old Memory . length ) ; } for ( int i = _ NUM ; i < frame Length ; i ++ ) { memory [ i ] += frame [ i ] ; } }
public  String find Value (  String k ) { if ( k == null ) { for ( int i = nkeys ; -- i >= _ NUM ; ) if ( keys [ i ] == null ) return values [ i ] ; } else for ( int i = nkeys ; -- i >= _ NUM ; ) { if ( k . equals Ignore Case ( keys [ i ] ) ) return values [ i ] ; } return null ; }
public boolean cleanup ( ) throws  IOException {  File System file System =  File System . get ( config ) ; boolean success = _ BOOL ; for (  Path file : files ) { success &= file System . delete ( file , _ BOOL ) ; } return success ; }
public static  Annotated Type Mirror remove Prefix ( final  Elements elements , final  Annotated Type Mirror anno Type ) {  Annotated Type Mirror result = anno Type . deep Copy ( _ BOOL ) ;  Set <  Annotation Mirror > annos = anno Type . get Annotations ( ) ; for (  Annotation Mirror anno : annos ) {  Annotation Mirror cleaned Mirror = remove Prefix ( elements , anno ) ; if ( cleaned Mirror != null ) { result . add Annotation ( cleaned Mirror ) ; } else { result . add Annotation ( anno ) ; } } return result ; }
protected  Abstract Format ( final  Number Format format ) { this ( format , (  Number Format ) format . clone ( ) ) ; }
private void check Log (  Ignite Logger log ) { assert ! log . is Debug Enabled ( ) ; assert log . is Info Enabled ( ) ; log . debug ( _ STR ) ; log . info ( _ STR ) ; log . warning ( _ STR ) ; log . warning ( _ STR , new  Exception ( _ STR ) ) ; log . error ( _ STR ) ; log . error ( _ STR , new  Exception ( _ STR ) ) ; }
public static void monitor Signal ( final  Object monitor ) { synchronized ( monitor ) { monitor . notify All ( ) ; } }
public static  String detect Imdb Id (  String text ) {  String imdb = _ STR ; if ( text != null && ! text . is Empty ( ) ) { imdb =  Strg Utils . substr ( text , _ STR ) ; if ( imdb . is Empty ( ) ) { imdb =  Strg Utils . substr ( text , _ STR ) ; if ( ! imdb . is Empty ( ) ) { imdb = _ STR + imdb ; } } } return imdb ; }
private void start Authentication Activity ( ) {  Intent intent = new  Intent (  Server Details . this ,  Authentication Activity . class ) ; intent . set Flags (  Intent .  FLAG_ ACTIVITY_ CLEAR_ TOP ) ; start Activity ( intent ) ; }
private void write (  Coordinate [ ] coords ,  Writer writer , int level ) throws  IOException { start Line ( level , writer ) ; start Geom Tag (  GMLConstants .  GML_ COORDINATES , null , writer ) ; int dim = _ NUM ; if ( coords . length > _ NUM ) { if ( ! (  Double . is Na N ( coords [ _ NUM ] . z ) ) ) dim = _ NUM ; } boolean is New Line = _ BOOL ; for ( int i = _ NUM ; i < coords . length ; i ++ ) { if ( is New Line ) { start Line ( level + _ NUM , writer ) ; is New Line = _ BOOL ; } if ( dim == _ NUM ) { writer . write ( _ STR + coords [ i ] . x ) ; writer . write ( coordinate Separator ) ; writer . write ( _ STR + coords [ i ] . y ) ; } else if ( dim == _ NUM ) { writer . write ( _ STR + coords [ i ] . x ) ; writer . write ( coordinate Separator ) ; writer . write ( _ STR + coords [ i ] . y ) ; writer . write ( coordinate Separator ) ; writer . write ( _ STR + coords [ i ] . z ) ; } writer . write ( tuple Separator ) ; if ( ( i + _ NUM ) % max Coordinates Per Line == _ NUM && i < coords . length - _ NUM ) { writer . write ( _ STR ) ; is New Line = _ BOOL ; } } if ( ! is New Line ) writer . write ( _ STR ) ; start Line ( level , writer ) ; end Geom Tag (  GMLConstants .  GML_ COORDINATES , writer ) ; }
private static boolean is Intended Exception (  Exception e ,  Class < ? > clazz ) { final  String message = e . get Message ( ) ; return ( !  Text Utils . is Empty ( message ) && message . starts With ( clazz . get Name ( ) ) ) ; }
public static void swap Pivot (  Matrix source , long diag ,  Matrix s ,  Matrix t ) { long swap Row = diag ; long swap Col = diag ; double max Value =  Math . abs ( source . get As Double ( diag , diag ) ) ; long rows = source . get Row Count ( ) ; long cols = source . get Column Count ( ) ; double abs = _ NUM ; for ( long row = diag ; row < rows ; row ++ ) { for ( long col = diag ; col < cols ; col ++ ) { abs =  Math . abs ( source . get As Double ( row , col ) ) ; if ( abs > max Value ) { max Value = abs ; swap Row = row ; swap Col = col ; } } } if ( swap Row != diag ) { swap Rows ( source , swap Row , diag ) ; swap Rows ( t , swap Row , diag ) ; } if ( swap Col != diag ) { swap Cols ( source , swap Col , diag ) ; swap Cols ( s , swap Col , diag ) ; } }
private boolean can Access Clipboard ( ) {  Security Manager sm =  System . get Security Manager ( ) ; if ( sm == null ) return _ BOOL ; try { sm . check Permission (  Security Constants .  AWT .  ACCESS_ CLIPBOARD_ PERMISSION ) ; return _ BOOL ; } catch (  Security Exception e ) { } return _ BOOL ; }
public  Job create Job From Activiti Xml (  String activiti Xml ,  List <  Parameter > parameters ) throws  Exception { job Definition Service Test Helper . create Job Definition For Activiti Xml ( activiti Xml ) ; return job Service . create And Start Job ( create Job Create Request (  Abstract Service Test .  TEST_ ACTIVITI_ NAMESPACE_ CD ,  Abstract Service Test .  TEST_ ACTIVITI_ JOB_ NAME , parameters ) ) ; }
public  Minecraft Directory (  File root Dir ) {  Objects . require Non Null ( root Dir ) ; this . root Dir = root Dir . get Absolute File ( ) ; }
protected boolean is White Space ( char ch ) { return ( ( ch == _ STR ) || ( ch == _ STR ) || ( ch == _ STR ) || ( ch == _ NUM ) || ( ch == _ NUM ) ) ; }
public static void write (  String filename ,  Object o ) throws  Exception { write ( new  File Output Stream ( filename ) , o ) ; }
public void add Default Value (  String value ) throws  SMSException ,  SSOException {  Set default Values = get Default Values ( ) ; if ( default Values !=  Collections .  EMPTY_ SET ) { default Values . add ( value ) ; } else { default Values = new  Hash Set ( ) ; default Values . add ( value ) ; } update Default Values ( default Values ) ; }
private boolean is Usable ( ) { if ( ( this . access &  Opcodes .  ACC_ SYNTHETIC ) != _ NUM ) return _ BOOL ; if ( ( this . access &  Opcodes .  ACC_ BRIDGE ) != _ NUM ) return _ BOOL ; if ( ( this . access &  Opcodes .  ACC_ NATIVE ) != _ NUM ) return _ BOOL ; if ( method Name . contains ( _ STR ) ) return _ BOOL ; if (  Properties .  P_ REFLECTION_ ON_ PRIVATE <= _ NUM ) { if ( method Name . contains ( _ STR ) && ( access &  Opcodes .  ACC_ PRIVATE ) ==  Opcodes .  ACC_ PRIVATE ) return _ BOOL ; } return _ BOOL ; }
public static boolean check Pool Maximum Resources Approached (  Storage Pool pool ,  Db Client db Client ,  Integer resource Count ) { if ( pool . get Is Resource Limit Set ( ) ) {  Integer pool Resources = get Num Resources ( pool , db Client ) ; if ( pool . get Max Resources ( ) < ( pool Resources + resource Count ) ) { _log . info ( _ STR , pool . get Native Guid ( ) , pool . get Max Resources ( ) ) ; return _ BOOL ; } }  URI system Id = pool . get Storage Device ( ) ;  Storage System system = db Client . query Object (  Storage System . class , system Id ) ; if ( system . get Is Resource Limit Set ( ) ) {  Integer system Resources = get Num Resources ( system , db Client ) ; if ( system . get Max Resources ( ) < ( system Resources + resource Count ) ) { _log . info ( _ STR , system . get Native Guid ( ) , system . get Max Resources ( ) ) ; return _ BOOL ; } } return _ BOOL ; }
private void read Object ( final  Object Input Stream in ) throws  IOException ,  Class Not Found Exception { in . default Read Object ( ) ; init ( ) ; }
public void add Line End Cap (  Coordinate p0 ,  Coordinate p1 ) {  Line Segment seg = new  Line Segment ( p0 , p1 ) ;  Line Segment offset L = new  Line Segment ( ) ; compute Offset Segment ( seg ,  Position .  LEFT , distance , offset L ) ;  Line Segment offset R = new  Line Segment ( ) ; compute Offset Segment ( seg ,  Position .  RIGHT , distance , offset R ) ; double dx = p1 . x - p0 . x ; double dy = p1 . y - p0 . y ; double angle =  Math . atan2 ( dy , dx ) ; switch ( buf Params . get End Cap Style ( ) ) { case  Buffer Parameters .  CAP_ ROUND : seg List . add Pt ( offset L . p1 ) ; add Fillet ( p1 , angle +  Math .  PI / _ NUM , angle -  Math .  PI / _ NUM ,  CGAlgorithms .  CLOCKWISE , distance ) ; seg List . add Pt ( offset R . p1 ) ; break ; case  Buffer Parameters .  CAP_ FLAT : seg List . add Pt ( offset L . p1 ) ; seg List . add Pt ( offset R . p1 ) ; break ; case  Buffer Parameters .  CAP_ SQUARE :  Coordinate square Cap Side Offset = new  Coordinate ( ) ; square Cap Side Offset . x =  Math . abs ( distance ) *  Math . cos ( angle ) ; square Cap Side Offset . y =  Math . abs ( distance ) *  Math . sin ( angle ) ;  Coordinate square Cap LOffset = new  Coordinate ( offset L . p1 . x + square Cap Side Offset . x , offset L . p1 . y + square Cap Side Offset . y ) ;  Coordinate square Cap ROffset = new  Coordinate ( offset R . p1 . x + square Cap Side Offset . x , offset R . p1 . y + square Cap Side Offset . y ) ; seg List . add Pt ( square Cap LOffset ) ; seg List . add Pt ( square Cap ROffset ) ; break ; } }
@  Override public  E remove ( int location ) {  E result ; if ( location < _ NUM || location >= size ) { throw new  Index Out Of Bounds Exception ( _ STR + location + _ STR + size ) ; } if ( location == _ NUM ) { result = array [ first Index ] ; array [ first Index ++ ] = null ; } else if ( location == size - _ NUM ) { int last Index = first Index + size - _ NUM ; result = array [ last Index ] ; array [ last Index ] = null ; } else { int element Index = first Index + location ; result = array [ element Index ] ; if ( location < size / _ NUM ) {  System . arraycopy ( array , first Index , array , first Index + _ NUM , location ) ; array [ first Index ++ ] = null ; } else {  System . arraycopy ( array , element Index + _ NUM , array , element Index , size - location - _ NUM ) ; array [ first Index + size - _ NUM ] = null ; } } size -- ; if ( size == _ NUM ) { first Index = _ NUM ; } mod Count ++ ; return result ; }
private  Map <  String ,  Object > parse (  Json json ) { return json . as Map ( ) ; }
public static final byte [ ] to Octets (  Attribute Type type ,  String str ) { final byte [ ] s = str . get Bytes (  Standard Charsets .  UTF_8 ) ; byte [ ] octets ; if ( s . length >  Attribute .  MAX_ ATTRIBUTE_ VALUE_ LENGTH ) { octets = new byte [  Attribute .  MAX_ ATTRIBUTE_ LENGTH ] ; octets [ _ NUM ] = ( byte ) type . get Type Code ( ) ; octets [ _ NUM ] = ( byte )  Attribute .  MAX_ ATTRIBUTE_ LENGTH ;  System . arraycopy ( s , _ NUM , octets , _ NUM ,  Attribute .  MAX_ ATTRIBUTE_ VALUE_ LENGTH ) ; } else { octets = new byte [ s . length + _ NUM ] ; octets [ _ NUM ] = ( byte ) type . get Type Code ( ) ; octets [ _ NUM ] = ( byte ) ( s . length + _ NUM ) ;  System . arraycopy ( s , _ NUM , octets , _ NUM , s . length ) ; } return octets ; }
public float round ( float d , int decimal Place ) {  Big Decimal bd = new  Big Decimal (  Float . to String ( d ) ) ; bd = bd . set Scale ( decimal Place ,  Big Decimal .  ROUND_ HALF_ UP ) ; return bd . float Value ( ) ; }
public void flush ( ) throws  IOException { out . flush ( ) ; }
public  Map <  String ,  List <  File > > find Files Grouped By Base Name ( ) {  Map <  String ,  List <  File > > base Log Files = new  Hash Map <  String ,  List <  File > > ( ) ;  String file Name ;  List <  File > log Files = get All Files Matching Glob Pattern ( ) ;  List <  File > same Base Files ; for (  File file : log Files ) {  String base Name ; file Name = file . get Name ( ) ; int dash Index = file Name . index Of ( _ STR ) ; int dot Index = file Name . index Of ( _ STR ) ; int sub Index ; if ( dot Index > _ NUM && dash Index > _ NUM ) { sub Index = ( dot Index < dash Index ) ? dot Index : dash Index ; } else { sub Index = dot Index > _ NUM ? dot Index : dash Index ; } if ( sub Index > _ NUM ) { base Name = file Name . substring ( _ NUM , sub Index ) ; } else { base Name = file Name ; } logger . debug ( _ STR , file Name , base Name ) ; if ( ( same Base Files = base Log Files . get ( base Name ) ) == null ) { same Base Files = new  Array List <  File > ( ) ; } same Base Files . add ( file ) ; base Log Files . put ( base Name , same Base Files ) ; } return base Log Files ; }
static boolean is Octet String Valid (  String value , int max Length ) { if ( value == null ) return _ BOOL ; if ( value . length ( ) > max Length ) return _ BOOL ; return _ BOOL ; }
private static double distance ( double x1 , double y1 , double x2 , double y2 ) { return  Math . sqrt ( ( y2 - y1 ) * ( y2 - y1 ) + ( x2 - x1 ) * ( x2 - x1 ) ) ; }
public void add Clear Graph Data Button ( ) {  JButton clear Button = new  JButton ( _ STR ) ; clear Button . set Action (  Time Series Plot Actions . get Clear Graph Action ( this ) ) ; button Panel . add ( clear Button ) ; }
public int max Id ( ) { int t = - _ NUM ; while ( _ BOOL ) { int s = bits . next Set Bit ( t + _ NUM ) ; if ( s == - _ NUM ) return t ; else t = s ; } }
private void write Header String (  Buffered Writer output ) throws  IOException { output . write ( _ STR ) ; output . write ( delimiter ) ; output . write ( _ STR ) ; output . write ( delimiter ) ; for ( int i = _ NUM ; i < _ NUM ; i ++ ) { output . write ( _ STR ) ; output . write (  String . value Of ( i ) ) ; output . write ( delimiter ) ; } for ( int i = _ NUM ; i < _ NUM ; i ++ ) { output . write ( _ STR ) ; output . write (  String . value Of ( i ) ) ; output . write ( delimiter ) ; } output . write ( _ STR ) ; output . new Line ( ) ; }
public boolean is Name ( ) { return type String . contains (  SUFFIX_ NAME ) ; }
public void add Notification (  Notification notification ) { notification Vector . add Element ( notification ) ; }
public void delete Nfs Datastore (  File Share Rest Rep file System ,  URI datacenter Id ,  Datastore datastore ) {  String datastore Name = datastore . get Name ( ) ;  List <  Host System > hosts = get Hosts For Datastore ( datastore ) ; if ( hosts . is Empty ( ) ) { throw new  Illegal State Exception ( _ STR ) ; } enter Maintenance Mode ( datastore ) ; set Storage IOControl ( datastore , _ BOOL ) ; for (  Host System host : hosts ) { execute ( new  Delete Datastore ( host , datastore ) ) ; } remove Nfs Datastore Tag ( file System , datacenter Id , datastore Name ) ; }
private void check Size ( final int i ) { if ( i >= max_size ) { final int old_size = max_size ; max_size += increment_size ; if ( max_size <= i ) { max_size = i + increment_size + _ NUM ; } final  Object [ ] temp = items ; items = new  Object [ max_size ] ;  System . arraycopy ( temp , _ NUM , items , _ NUM , old_size ) ; increment_size = increment Size ( increment_size ) ; } }
public  Media Size ( int x , int y , int units ,  Media Size Name media ) { super ( x , y , units ) ; if ( x > y ) { throw new  Illegal Argument Exception ( _ STR ) ; } if ( media != null && media Map . get ( media ) == null ) { media Name = media ; media Map . put ( media Name , this ) ; } size Vector . add ( this ) ; }
protected void schedule Tasks (  Set <  Task Image Container > tasks ) { synchronized ( m Shadow Task Map ) { for (  Task Image Container task : tasks ) {  Image Shadow Task shadow Task = m Shadow Task Map . get ( task . m Session ) ; if ( shadow Task == null ) { throw new  Illegal State Exception ( _ STR ) ; } switch ( task . get Processing Priority ( ) ) { case  FAST : m Thread Pool Fast . execute ( new  Task Done Wrapper ( this , shadow Task , task ) ) ; break ; case  AVERAGE : m Thread Pool Average . execute ( new  Task Done Wrapper ( this , shadow Task , task ) ) ; break ; case  SLOW : m Thread Pool Slow . execute ( new  Task Done Wrapper ( this , shadow Task , task ) ) ; break ; default : m Thread Pool Slow . execute ( new  Task Done Wrapper ( this , shadow Task , task ) ) ; break ; } } } }
public static  String unquote (  String name ) { if ( ! name . is Empty ( ) && name . char At ( _ NUM ) == _ STR ) { return name . substring ( _ NUM ) ; } return name ; }
void update ( int status , int leader Id ) { lock . lock ( ) ; try { this . status = status ; this . leader Id = leader Id ; update Cond . signal ( ) ; } finally { lock . unlock ( ) ; } }
private static  Object report Get (  Object r ) throws  Interrupted Exception ,  Execution Exception { if ( r == null ) throw new  Interrupted Exception ( ) ; if ( r instanceof  Alt Result ) {  Throwable x , cause ; if ( ( x = ( (  Alt Result ) r ) . ex ) == null ) return null ; if ( x instanceof  Cancellation Exception ) throw (  Cancellation Exception ) x ; if ( ( x instanceof  Completion Exception ) && ( cause = x . get Cause ( ) ) != null ) x = cause ; throw new  Execution Exception ( x ) ; } return r ; }
public int write ( final  Protein protein , final boolean standalone ) throws  IOException { check Entry Hierarchy ( ) ; if ( entry Hierarchy != null ) { for (  Protein Xref xref : protein . get Cross References ( ) ) { final  Simple Protein simple Protein =  Simple Protein . value Of ( protein , xref , entry Hierarchy ) ; if ( simple Protein != null ) { final  Simple Hash model = build Model Map ( simple Protein , entry Hierarchy , standalone ) ;  Writer writer = null ; try { final  Template temp = free Marker Config . get Template ( free Marker Template ) ; check Temp Directory ( temp Directory ) ; if ( ! temp Directory . ends With (  File . separator ) ) { temp Directory = temp Directory +  File . separator ; }  Url Friendly Id Generator gen =  Url Friendly Id Generator . get Instance ( ) ;  String url Friendly Id = gen . generate ( xref . get Identifier ( ) ) ; final  Path new Result File =  Paths . get ( temp Directory + url Friendly Id + _ STR ) ; result Files . add ( new Result File ) ; writer =  Files . new Buffered Writer ( new Result File , character Set ) ; temp . process ( model , writer ) ; writer . flush ( ) ; } catch (  Template Exception e ) { e . print Stack Trace ( ) ; } catch (  IOException e ) { e . print Stack Trace ( ) ; } finally { if ( writer != null ) { writer . close ( ) ; } } } } } return _ NUM ; }
@  Data Provider public  Object [ ] [ ] create Rename Test Data ( ) { return new  Object [ ] [ ] { { _ STR , _ STR , _ STR , _ STR } , { _ STR , _ STR , _ STR , _ STR } , { _ STR , _ STR , _ STR , _ STR } , { _ STR , _ STR , _ STR , _ STR } , { _ STR , _ STR , _ STR , _ STR } , { _ STR , _ STR , _ STR , _ STR } , { _ STR , _ STR , _ STR , _ STR } } ; }
public void add Macro (  String macro ,  String value ) { if ( macro != null && ! macro . is Empty ( ) ) { set Changed ( ) ; synchronized (  LOCK ) { macro Map . put ( macro , value ) ; } notify Observers ( this ) ; } }
private double [ ] interpolate Non Zero Values ( double [ ] contour ) { for ( int i = _ NUM ; i < contour . length ; i ++ ) { if ( contour [ i ] == _ NUM ) { int index = find Next Index Non Zero ( contour , i ) ; if ( index == - _ NUM ) { for ( int j = i ; j < contour . length ; j ++ ) { contour [ j ] = contour [ j - _ NUM ] ; } break ; } else { for ( int j = i ; j < index ; j ++ ) { if ( i == _ NUM ) { contour [ j ] = contour [ index ] ; } else { contour [ j ] = contour [ j - _ NUM ] + ( ( contour [ index ] - contour [ i - _ NUM ] ) / ( index - i ) ) ; } } i = index - _ NUM ; } } } return contour ; }
public static void delete Tag Contents (  Element parent Element ,  String name ) {  Node List children = parent Element . get Elements By Tag Name ( name ) ; for ( int i = children . get Length ( ) - _ NUM ; i >= _ NUM ; i -- ) {  Element child = (  Element ) children . item ( i ) ; parent Element . remove Child ( child ) ; } }
private  RE concat (  RE x ,  RE y ) { if ( rec ==  Recursion .  RIGHT ) { return x . concat ( y ) ; } else { return y . concat ( x ) ; } }
public void add ( final  Object element ) {  Set old Selection = new  Hash Set ( selection ) ; boolean rv = selection . add ( element ) ; if ( rv ) { fire Selection Changed ( old Selection , selection ) ; } old Selection = null ; }
@  Override public void mouse Released (  Mouse Event evt ) { delegate . mouse Moved ( evt ) ; }
public static void printf (  Locale locale ,  String format ,  Object ... args ) { out . printf ( locale , format , args ) ; out . flush ( ) ; }
public void test Sorts Same Attributes ( ) throws  Exception {  Xpp Dom dom1 =  Xpp Factory . build Dom ( _ STR ) ;  Xpp Dom dom2 =  Xpp Factory . build Dom ( _ STR ) ; assert Equals ( - _ NUM , comparator . compare ( dom1 , dom2 ) ) ; assert Equals ( _ STR , xpath . get ( ) ) ; assert Equals ( _ NUM , comparator . compare ( dom2 , dom1 ) ) ; assert Equals ( _ STR , xpath . get ( ) ) ; }
public void add (  Dalv Insn insn ) { insns . add ( insn ) ; update Info ( insn ) ; }
private void check Log (  Ignite Logger log ) { assert ! log . is Debug Enabled ( ) ; assert log . is Info Enabled ( ) ; log . debug ( _ STR ) ; log . info ( _ STR ) ; log . warning ( _ STR ) ; log . warning ( _ STR , new  Exception ( _ STR ) ) ; log . error ( _ STR ) ; log . error ( _ STR , new  Exception ( _ STR ) ) ; }
public static  Number add (  Number a ,  Number b ) { if ( is Floating Point ( a ) || is Floating Point ( b ) ) { return a . double Value ( ) + b . double Value ( ) ; } else { return a . long Value ( ) + b . long Value ( ) ; } }
public  Builder optional Attributes ( final  String ... name Or OIDs ) { return optional Attributes (  Arrays . as List ( name Or OIDs ) ) ; }
public static  List <  String > run (  List <  String > commands ) { return  Shell . run ( _ STR , commands . to Array ( new  String [ commands . size ( ) ] ) , null , _ BOOL ) ; }
private static byte [ ] to Byte Array (  Input Stream input Stream ) throws  IOException {  Byte Array Output Stream baos = new  Byte Array Output Stream ( ) ; byte buffer [ ] = new byte [ _ NUM ] ; while ( _ BOOL ) { int read = input Stream . read ( buffer ) ; if ( read == - _ NUM ) { break ; } baos . write ( buffer , _ NUM , read ) ; } return baos . to Byte Array ( ) ; }
public <  T >  Lazy Future Stream <  T > from Publisher ( final  Publisher < ? extends  T > publisher ) {  Objects . require Non Null ( publisher ) ; final  Seq Subscriber <  T > sub =  Seq Subscriber . subscriber ( ) ; publisher . subscribe ( sub ) ; return sub . to Future Stream ( this ) ; }
public  Protobuf Parser (  Listener <  Message Type > handler ,  Message Type prototype , int max Message Size , int timeout Millis ) { this . handler = handler ; this . prototype = prototype ; this . max Message Size =  Math . min ( max Message Size ,  Integer .  MAX_ VALUE - _ NUM ) ; set Timeout Enabled ( _ BOOL ) ; set Socket Timeout ( timeout Millis ) ; }
public void add Notification (  Notification notification ) { notification Vector . add Element ( notification ) ; }
public  Red Gradient ( int max Count ) { this . max Count = max Count ; factor = max Count /  Math . log ( max Count ) ; }
public static void write Histogram (  TDouble Double Hash Map map ,  String key Col ,  String val Col ,  String file , boolean descending ) throws  IOException {  Buffered Writer writer = new  Buffered Writer ( new  File Writer ( file ) ) ; writer . write ( key Col ) ; writer . write (  TAB ) ; writer . write ( val Col ) ; writer . new Line ( ) ; double [ ] keys = map . keys ( ) ;  Arrays . sort ( keys ) ; if ( descending )  Array Utils . reverse ( keys ) ; for ( double key : keys ) { writer . write (  String . value Of ( key ) ) ; writer . write (  TAB ) ; writer . write (  String . value Of ( map . get ( key ) ) ) ; writer . new Line ( ) ; } writer . close ( ) ; }
public static <  T >  Completion Stage <  T > dereference (  Completion Stage < ? extends  Completion Stage <  T > > stage ) { return stage . then Compose (  Function . identity ( ) ) ; }
public static  Number plus (  Number left ,  Character right ) { return  Number Number Plus . plus ( left ,  Integer . value Of ( right ) ) ; }
public static  String clip String (  JComponent c ,  Font Metrics fm ,  String string , int avail Text Width ) {  String clip String = _ STR ; avail Text Width -=  Swing Utilities2 . string Width ( c , fm , clip String ) ; if ( avail Text Width <= _ NUM ) { return clip String ; } boolean needs Text Layout ; synchronized ( chars Buffer Lock ) { int string Length = sync Chars Buffer ( string ) ; needs Text Layout = is Complex Layout ( chars Buffer , _ NUM , string Length ) ; if ( ! needs Text Layout ) { int width = _ NUM ; for ( int n Chars = _ NUM ; n Chars < string Length ; n Chars ++ ) { width += fm . char Width ( chars Buffer [ n Chars ] ) ; if ( width > avail Text Width ) { string = string . substring ( _ NUM , n Chars ) ; break ; } } } } if ( needs Text Layout ) {  Attributed String a String = new  Attributed String ( string ) ; if ( c != null ) { a String . add Attribute (  Text Attribute .  NUMERIC_ SHAPING , c . get Client Property (  Text Attribute .  NUMERIC_ SHAPING ) ) ; }  Line Break Measurer measurer = new  Line Break Measurer ( a String . get Iterator ( ) ,  Break Iterator . get Character Instance ( ) , get Font Render Context ( c , fm ) ) ; string = string . substring ( _ NUM , measurer . next Offset ( avail Text Width ) ) ; } return string + clip String ; }
public boolean add Element (  Object obj ) { synchronized ( actions ) { if ( allow To Change ) { return actions . add ( obj ) ; } } return _ BOOL ; }
public static boolean is Cglib Proxy Class (  Class < ? > clazz ) { return ( clazz != null && is Cglib Proxy Class Name ( clazz . get Name ( ) ) ) ; }
@  Override public void reset References ( ) { _refs . clear ( ) ; }
public void add Slide ( @  Non Null  Fragment fragment , @  Color Int int color ) { fragments . add ( fragment ) ; add Background Color ( color ) ; pager Adapter . notify Data Set Changed ( ) ; }
public static  Float Buffer create Float Buffer ( float [ ] coords ) {  Byte Buffer bb =  Byte Buffer . allocate Direct ( coords . length *  SIZEOF_ FLOAT ) ; bb . order (  Byte Order . native Order ( ) ) ;  Float Buffer fb = bb . as Float Buffer ( ) ; fb . put ( coords ) ; fb . position ( _ NUM ) ; return fb ; }
protected void subscribe ( ) throws  IOException { if ( sample Client Sub == null ) { try { sample Client Sub = new  Sample Async Wait ( url , client Id Sub , clean Session , quiet Mode , user Name , password ) ; } catch (  Mqtt Exception e ) { e . print Stack Trace ( ) ; } } if ( sample Client Sub != null ) {  String topic = _ STR ; int qos = _ NUM ; try { sample Client Sub . subscribe ( topic , qos ) ; } catch (  Throwable e ) { e . print Stack Trace ( ) ; } } }
private void wm Sub Band (  Image img , double [ ] wm , int n , double a , double threshold ) { for ( int i = _ NUM ; i < img . get Width ( ) * img . get Height ( ) ; i ++ ) { if (  Math . abs ( img . get Data ( ) [ i ] ) > threshold ) { img . get Data ( ) [ i ] += ( a *  Math . abs ( img . get Data ( ) [ i ] ) * wm [ i % n ] ) ; } } }
public synchronized  Map <  String ,  Map <  String ,  Tungsten Properties > > load Cluster Configuration (  Resource Type resource Type ) throws  Configuration Exception { if ( get Cluster Home ( ) == null ) { throw new  Configuration Exception ( _ STR ) ; }  Map <  String ,  Map <  String ,  Tungsten Properties > > cluster Configurations = new  Hash Map <  String ,  Map <  String ,  Tungsten Properties > > ( ) ;  File cluster = get Dir ( get Cluster Config Root Dir Name ( get Cluster Home ( ) ) ) ; for (  File found File : cluster . list Files ( ) ) { if ( found File . is Directory ( ) ) {  Map <  String ,  Tungsten Properties > cluster Config = load Configuration ( found File . get Name ( ) , resource Type ) ; cluster Configurations . put ( found File . get Name ( ) , cluster Config ) ; } } return cluster Configurations ; }
private int register Source File (  String file ) { if ( source Files . contains ( file ) ) return - _ NUM ; source Files . add ( file ) ; this . size ++ ; return source Files . size ( ) - _ NUM ; }
private void start File Based Merge ( ) throws  Carbon Sort Key And Group By Exception { try { data Sorter And Writer Executor Service . shutdown ( ) ; data Sorter And Writer Executor Service . await Termination ( _ NUM ,  Time Unit .  DAYS ) ; } catch (  Interrupted Exception e ) { throw new  Carbon Sort Key And Group By Exception ( _ STR , e ) ; } }
private static  Date parse Timestamp (  String value ) { final long parsed ; parsed =  Long . parse Long ( value . trim ( ) ) ; return new  Date ( parsed * _ NUM ) ; }
public void destroy ( ) { m Listeners . clear ( ) ; m Spring System . deregister Spring ( this ) ; }
public int add Ref (  Object ref ) { if ( _refs == null ) _refs = new  Array List ( ) ; _refs . add ( ref ) ; return _refs . size ( ) - _ NUM ; }
protected static  Pair <  String ,  String > asr Immediate ( final long offset , final  ITranslation Environment environment , final  List <  Reil Instruction > instructions , final  String register Node Value , final  String immediate Node Value ) { long base Offset = offset ; final  String shifter Operand = environment . get Next Variable String ( ) ; final  String shifter Carry Out = environment . get Next Variable String ( ) ; if ( immediate Node Value . equals ( _ STR ) ) { final  String tmp Var1 = environment . get Next Variable String ( ) ; instructions . add (  Reil Helpers . create Bsh ( base Offset ++ , d Word Size , register Node Value , word Size , thirty One Set , byte Size , tmp Var1 ) ) ; instructions . add (  Reil Helpers . create And ( base Offset ++ , byte Size , tmp Var1 , byte Size , one Set , byte Size , shifter Carry Out ) ) ; instructions . add (  Reil Helpers . create Sub ( base Offset ++ , byte Size , shifter Carry Out , byte Size ,  String . value Of ( _ NUM ) , d Word Size , shifter Operand ) ) ; return new  Pair <  String ,  String > ( shifter Operand , shifter Carry Out ) ; } else { final  String tmp Var1 = environment . get Next Variable String ( ) ; final  String tmp Var2 = environment . get Next Variable String ( ) ; final  String tmp Var3 = environment . get Next Variable String ( ) ; final  String tmp Var4 = environment . get Next Variable String ( ) ; final  String tmp Var5 = environment . get Next Variable String ( ) ; instructions . add (  Reil Helpers . create Add ( base Offset ++ , d Word Size , register Node Value , d Word Size , bit Mask Highest Bit Set , q Word Size , tmp Var1 ) ) ; instructions . add (  Reil Helpers . create Bsh ( base Offset ++ , q Word Size , tmp Var1 , word Size , _ STR + immediate Node Value , d Word Size , tmp Var2 ) ) ; instructions . add (  Reil Helpers . create Bsh ( base Offset ++ , d Word Size , bit Mask Highest Bit Set , word Size , _ STR + immediate Node Value , d Word Size , tmp Var3 ) ) ; instructions . add (  Reil Helpers . create Sub ( base Offset ++ , d Word Size , tmp Var2 , d Word Size , tmp Var3 , q Word Size , tmp Var4 ) ) ; instructions . add (  Reil Helpers . create And ( base Offset ++ , q Word Size , tmp Var4 , d Word Size , bit Mask All Bits Set , d Word Size , shifter Operand ) ) ; instructions . add (  Reil Helpers . create Bsh ( base Offset ++ , d Word Size , register Node Value , d Word Size ,  String . value Of ( - (  Integer . decode ( immediate Node Value ) - _ NUM ) ) , word Size , tmp Var5 ) ) ; instructions . add (  Reil Helpers . create And ( base Offset ++ , word Size , tmp Var5 , byte Size , one Set , byte Size , shifter Carry Out ) ) ; return new  Pair <  String ,  String > ( shifter Operand , shifter Carry Out ) ; } }
public static  Plain Text plain ( byte text ) { return plain (  Integer . to String ( text ) ) ; }
public static boolean same Date (  Calendar cal ,  Calendar selected Date ) { return cal . get (  Calendar .  MONTH ) == selected Date . get (  Calendar .  MONTH ) && cal . get (  Calendar .  YEAR ) == selected Date . get (  Calendar .  YEAR ) && cal . get (  Calendar .  DAY_ OF_ MONTH ) == selected Date . get (  Calendar .  DAY_ OF_ MONTH ) ; }
public void start ( ) { managed Ports . add ( create Port ( ) ) ; fix Names ( ) ; ports . add Observer ( observer , _ BOOL ) ; }
protected void sprint ( int int Field ) { sprint (  String . value Of ( int Field ) ) ; }
public byte [ ] convert Nv21to Jpeg ( byte [ ] data_copy , int w , int h , int [ ] strides ) {  Log . e (  TAG , _ STR ) ;  Yuv Image yuv Image = new  Yuv Image ( data_copy ,  Image Format .  NV21 , w , h , strides ) ;  Byte Array Output Stream post View Bytes = new  Byte Array Output Stream ( ) ; yuv Image . compress To Jpeg ( new  Rect ( _ NUM , _ NUM , w , h ) , _ NUM , post View Bytes ) ; try { post View Bytes . flush ( ) ; } catch (  IOException e ) { e . print Stack Trace ( ) ; }  Log . e (  TAG , _ STR ) ; return post View Bytes . to Byte Array ( ) ; }
public static  String value Of ( double value ) { return  Double . to String ( value ) ; }
private boolean has Port (  List <  Service Port > ports ,  Service Port port ) { for (  Service Port a Port : ports ) { if (  Objects . equals ( port . get Port ( ) , a Port . get Port ( ) ) ) { return _ BOOL ; } } return _ BOOL ; }
@  Override public  XMLEvent next Event ( ) throws  XMLStream Exception { log . log (  Level .  FINE , _ STR ) ; current Event = next Event ; if ( current Event . get Event Type ( ) !=  XMLStream Constants .  END_ DOCUMENT ) { next Event = construct Event ( stream . next ( ) , stream ) ; } else { next Event = null ; } log . log (  Level .  FINE , _ STR , current Event ) ; return current Event ; }
public static  String to Points (  Point2 D .  Double [ ] points ) throws  IOException {  String Builder buf = new  String Builder ( ) ; for ( int i = _ NUM ; i < points . length ; i ++ ) { if ( i != _ NUM ) { buf . append ( _ STR ) ; } buf . append ( to Number ( points [ i ] . x ) ) ; buf . append ( _ STR ) ; buf . append ( to Number ( points [ i ] . y ) ) ; } return buf . to String ( ) ; }
public void update Combo Box (  JCombo Box <  Schedule > box ) { box . remove All Items ( ) ; box . add Item ( null ) ; for (  Schedule schedule : get Schedules By Name List ( ) ) { box . add Item ( schedule ) ; } }
public void disconnect ( final  IProject [ ] projects ) { disconnect ( projects , _ BOOL ) ; }
public void sort ( final  Data Comparator ... comparators ) { synchronized ( rows ) {  Record Comparator comparator = new  Record Comparator ( comparators ) ;  Collections . sort ( rows , comparator ) ; } }
public void add Patch Resource (  Resource resource ) { resources . add ( resource ) ; }
public void remove All Numeric Value Changed Listeners ( ) { while ( ! m Numeric Listeners . is Empty ( ) ) { m Numeric Listeners . remove ( _ NUM ) ; } }
public static void save (  Key Store key Store ,  File key Store File ,  Password password ) throws  Crypto Exception ,  IOException {  Key Store Type key Store Type =  Key Store Type . resolve Jce ( key Store . get Type ( ) ) ; if ( ! key Store Type . is File Based ( ) ) { throw new  Crypto Exception (  Message Format . format ( res . get String ( _ STR ) , key Store Type . jce ( ) ) ) ; }  File Output Stream fos = null ; fos = new  File Output Stream ( key Store File ) ; try { key Store . store ( fos , password . to Char Array ( ) ) ; } catch (  IOException ex ) { throw new  Crypto Exception ( res . get String ( _ STR ) , ex ) ; } catch (  Key Store Exception ex ) { throw new  Crypto Exception ( res . get String ( _ STR ) , ex ) ; } catch (  Certificate Exception ex ) { throw new  Crypto Exception ( res . get String ( _ STR ) , ex ) ; } catch (  No Such Algorithm Exception ex ) { throw new  Crypto Exception ( res . get String ( _ STR ) , ex ) ; } finally {  IOUtils . close Quietly ( fos ) ; } }
public final long increment And Get ( ) { for ( ; ; ) { long current = get ( ) ; long next = current + _ NUM ; if ( compare And Set ( current , next ) ) return next ; } }
public boolean add Value (  Value v ) { return values . add ( v ) ; }
public  Properties to Properties ( ) { return to Properties ( _ BOOL ) ; }
public void add To Weight List ( double weight ) { weight List . add ( weight ) ; }
protected void select Value ( int value ) { if ( value > _ NUM ) { log . error ( _ STR + value ) ; } for ( int i = _ NUM ; i < _value Array . length ; i ++ ) { if ( _value Array [ i ] == value ) { _value . set Selected Index ( i ) ; return ; } } log . debug ( _ STR + value + _ STR + _value . get Item Count ( ) + _ STR + label ( ) ) ; _value . add Item ( _ STR + value ) ; int [ ] old Array = _value Array ; _value Array = new int [ old Array . length + _ NUM ] ; for ( int i = _ NUM ; i < old Array . length ; i ++ ) { _value Array [ i ] = old Array [ i ] ; } _value Array [ old Array . length ] = value ; _value . set Selected Item ( _ STR + value ) ; }
public static  String unquote (  String string ) { if ( string . starts With ( _ STR ) && string . ends With ( _ STR ) ) { string = string . substring ( _ NUM , string . length ( ) - _ NUM ) ; if ( ( string . index Of ( _ STR ) != - _ NUM ) || ( string . index Of ( _ STR ) != - _ NUM ) || ( string . index Of ( _ STR ) != - _ NUM ) || ( string . index Of ( _ STR ) != - _ NUM ) || ( string . index Of ( _ STR ) != - _ NUM ) || ( string . index Of ( _ STR ) != - _ NUM ) || ( string . index Of ( _ STR ) != - _ NUM ) || ( string . index Of ( _ STR ) != - _ NUM ) ) { string = unback Quote Chars ( string ) ; } } return string ; }
@  Override public  String to String ( ) {  String Builder s = new  String Builder ( ) ; for (  Key key : this ) s . append ( key + _ STR ) ; return s . to String ( ) ; }
public double calculate Value ( double log ) { return  Math . pow ( this . base , log ) ; }
public static double pow ( double value , double power ) { if (  USE_ JDK_ MATH ) { return  STRICT_ MATH ?  Strict Math . pow ( value , power ) :  Math . pow ( value , power ) ; } if ( power == _ NUM ) { return _ NUM ; } else if ( power == _ NUM ) { return value ; } if ( value <= _ NUM ) { int power Info ; if (  Math . abs ( power ) >= (  TWO_ POW_52 * _ NUM ) ) { power Info = _ NUM ; } else { if (  Math . abs ( power ) <= ( double )  Integer .  MAX_ VALUE ) { int power As Int = ( int ) power ; if ( power == ( double ) power As Int ) { power Info = ( ( power As Int & _ NUM ) == _ NUM ) ? _ NUM : - _ NUM ; } else { power Info = _ NUM ; } } else { long power As Long = ( long ) power ; if ( power == ( double ) power As Long ) { power Info = ( ( power As Long & _ NUM ) == _ NUM ) ? _ NUM : - _ NUM ; } else { if ( power != power ) { return  Double .  Na N ; } power Info = _ NUM ; } } } if ( value == _ NUM ) { if ( power < _ NUM ) { return ( power Info < _ NUM ) ? _ NUM / value :  Double .  POSITIVE_ INFINITY ; } else { return ( power Info < _ NUM ) ? value : _ NUM ; } } else { if ( value ==  Double .  NEGATIVE_ INFINITY ) { if ( power Info < _ NUM ) { return ( power < _ NUM ) ? - _ NUM :  Double .  NEGATIVE_ INFINITY ; } else { return ( power < _ NUM ) ? _ NUM :  Double .  POSITIVE_ INFINITY ; } } else { return ( power Info != _ NUM ) ? power Info *  Fast Math . exp ( power *  Fast Math . log ( - value ) ) :  Double .  Na N ; } } } else { return  Fast Math . exp ( power *  Fast Math . log ( value ) ) ; } }
public  Datagram Packet multicast Receive ( ) throws  IOException { byte [ ] buf = new byte [ _ NUM ] ;  Datagram Packet dp = new  Datagram Packet ( buf , buf . length ) ; multicast Socket . receive ( dp ) ; return dp ; }
public void flush ( ) { flush ( _ BOOL ) ; }
public void test Signum Positive ( ) { byte a Bytes [ ] = { _ NUM , _ NUM , _ NUM , - _ NUM , - _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , - _ NUM , _ NUM , _ NUM , _ NUM , _ NUM } ; int a Sign = _ NUM ;  Big Integer a Number = new  Big Integer ( a Sign , a Bytes ) ; assert Equals ( _ STR , _ NUM , a Number . signum ( ) ) ; }
public  Flux Map (  Publisher < ? extends  T > source ,  Function < ? super  T , ? extends  R > mapper ) { super ( source ) ; this . mapper =  Objects . require Non Null ( mapper , _ STR ) ; }
Loco Net Message create Set Packet (  String s ) { int data =  Integer . parse Int ( s ) ;  Loco Net Message m = new  Loco Net Message ( _ NUM ) ; m . set Element ( _ NUM , _ NUM ) ; m . set Element ( _ NUM , _ NUM ) ; m . set Element ( _ NUM , _ NUM ) ; m . set Element ( _ NUM , data ) ; m . set Element ( _ NUM , _ NUM ) ; return m ; }
synchronized void unregister To Notifications ( ) throws  JMSException { if ( event Session == null ) { return ; } if ( _logger . is Loggable (  Level .  FINE ) ) { _logger . log (  Level .  FINE , to String2 ( ) + _ STR ) ; } try { event Session . close ( ) ; } catch (  IOException e ) { if ( _logger . is Loggable (  Level .  FINE ) ) { _logger . log (  Level .  FINE , to String2 ( ) + _ STR + e ) ; }  JMSException e1 = new  JMSException ( _ STR ) ; e1 . set Linked Exception ( e ) ; throw e1 ; } catch (  Unknown Lease Exception e ) { if ( _logger . is Loggable (  Level .  FINE ) ) { _logger . log (  Level .  FINE , to String2 ( ) + _ STR + e ) ; }  JMSException e1 = new  JMSException ( _ STR ) ; e1 . set Linked Exception ( e ) ; throw e1 ; } catch (  Exception e ) { if ( _logger . is Loggable (  Level .  FINE ) ) { _logger . log (  Level .  FINE , to String2 ( ) + _ STR + e ) ; }  JMSException e1 = new  JMSException ( _ STR ) ; e1 . set Linked Exception ( e ) ; throw e1 ; } finally { event Session = null ; } }
public  String sprintf ( ) {  Enumeration e = v Fmt . elements ( ) ;  Conversion Specification cs = null ; char c = _ NUM ;  String Builder sb = new  String Builder ( ) ; while ( e . has More Elements ( ) ) { cs = (  Conversion Specification ) e . next Element ( ) ; c = cs . get Conversion Character ( ) ; if ( c == _ STR ) sb . append ( cs . get Literal ( ) ) ; else if ( c == _ STR ) sb . append ( _ STR ) ; } return sb . to String ( ) ; }
protected static  String remove Package Name (  String type Name ) { int index = type Name . last Index Of ( _ STR ) ; if ( index >= _ NUM ) { type Name = type Name . substring ( index + _ NUM ) ; } return type Name ; }
private void update Updater Combo Box ( ) { }
public  String class Name Tip Text ( ) { return _ STR ; }
public  String random String ( int len ) {  String Builder buff = new  String Builder ( ) ; for ( int i = _ NUM ; i < len ; i ++ ) {  String from = ( i % _ NUM == _ NUM ) ? _ STR : _ STR ; buff . append ( from . char At ( get Int ( from . length ( ) ) ) ) ; } return buff . to String ( ) ; }
protected double prior Val ( double [ ] [ ] dist ) { return  Contingency Tables . entropy Over Columns ( dist ) ; }
public void end ( ) throws  IOException { print ( _ STR , null ) ; printer . println ( ) ; }
public void add Group (  Group group ) { if ( group != null && group . get Items ( ) != null ) { m Items . add All ( group . get Items ( ) ) ; } }
protected static  String normalize Url Ending (  String link ) { if ( link . index Of ( _ STR ) > - _ NUM ) link = link . substring ( _ NUM , link . index Of ( _ STR ) ) ; if ( link . ends With ( _ STR ) ) link = link . substring ( _ NUM , link . length ( ) - _ NUM ) ; if ( link . ends With ( _ STR ) ) link = link . substring ( _ NUM , link . length ( ) - _ NUM ) ; return link ; }
@  Override public long skip ( long bytes ) throws  IOException { if ( closed ) { throw new  File Upload Exception (  Item Skipped Exception ) ; } int av = available ( ) ; if ( av == _ NUM ) { av = make Available ( ) ; if ( av == _ NUM ) { return _ NUM ; } } long res =  Math . min ( av , bytes ) ; head += res ; return res ; }
protected void draw Center Text (  Canvas c ) {  String center Text = m Chart . get Center Text ( ) ; if ( m Chart . is Draw Center Text Enabled ( ) && center Text != null ) {  Point F center = m Chart . get Center Circle Box ( ) ;  String [ ] lines = center Text . split ( _ STR ) ; float maxlineheight = _ NUM ; for (  String line : lines ) { float cur Height =  Utils . calc Text Height ( m Center Text Paint , line ) ; if ( cur Height > maxlineheight ) maxlineheight = cur Height ; } float linespacing = maxlineheight * _ NUM ; float totalheight = maxlineheight * lines . length - linespacing * ( lines . length - _ NUM ) ; int cnt = lines . length ; float y = center . y ; for ( int i = _ NUM ; i < lines . length ; i ++ ) {  String line = lines [ lines . length - i - _ NUM ] ; c . draw Text ( line , center . x , y + maxlineheight * cnt - totalheight / _ NUM , m Center Text Paint ) ; cnt -- ; y -= linespacing ; } } }
public void add Bottom Sheet Callback (  Bottom Sheet Callback callback ) { if ( m Callback == null ) m Callback = new  Vector < > ( ) ; m Callback . add ( callback ) ; }
private void init ( ) { main Panel = new  JPanel ( ) ; main Panel . set Layout ( new  Box Layout ( main Panel ,  Box Layout .  Y_ AXIS ) ) ; main Panel . add ( connection Panel ) ; properties Panel =  Connection Synapse Properties Panel . create Synapse Properties Panel ( this ) ; main Panel . add ( properties Panel ) ; eir Panel =  Synapse Polarity And Randomizer Panel . create Polarity Ratio Panel ( this ) ; main Panel . add ( eir Panel ) ; fill Frame ( ) ; }
public void ensure Capacity ( int min Capacity ) { delegate . ensure Capacity ( min Capacity ) ; }
void initialize Evaluation Weights ( ) { ps Weight = users . size ( ) * subject Weight ; pr Weight = rules . size ( ) * rule Weight ; pc Weight = conditions . size ( ) * condition Weight ; }
private  String create File Name ( ) {  String file Name = url . get Path ( ) ; if ( file Name . starts With ( _ STR ) ) { file Name = file Name . substring ( _ NUM ) ; } else if ( file Name . starts With ( _ STR ) ) { file Name = file Name . substring ( _ NUM ) ; } return file Name ; }
public void delete (  String name ) throws  IOException { if ( name . equals Ignore Case (  DATE ) ) { date = null ; } else { throw new  IOException ( _ STR ) ; } encode This ( ) ; }
public static  Data Frame normalize (  Data Frame data Frame ) { return normalize ( data Frame , _ NUM , _ NUM ,  Collections . <  String > empty List ( ) ) ; }
private static boolean is Excluded (  Spatial s ,  Spatial exclude ) { if ( s . equals ( exclude ) ) { return _ BOOL ; } if ( s . get Parent ( ) != null ) { return is Excluded ( s . get Parent ( ) , exclude ) ; } return _ BOOL ; }
private void add Block Listeners (  Tracker tracker ) {  List <  OBlock > range = tracker . get Range ( ) ; if ( log . is Debug Enabled ( ) ) { log . debug ( _ STR + tracker . get Train Name ( ) + _ STR + range . size ( ) + _ STR ) ; }  Iterator <  OBlock > iter = range . iterator ( ) ; while ( iter . has Next ( ) ) { add Block Listener ( iter . next ( ) , tracker ) ; } }
private static  String pre Parse Code (  String script ) { final  String [ ] search For = { _ STR , _ STR , _ STR , _ STR , _ STR , _ STR , _ STR , _ STR , _ STR , _ STR , _ STR , _ STR , _ STR , _ STR , _ STR , _ STR } ; final  String [ ] replace With = { _ STR , _ STR , _ STR , _ STR , _ STR , _ STR , _ STR , _ STR , _ STR , _ STR , _ STR , _ STR , _ STR , _ STR , _ STR , _ STR } ; for ( int i = _ NUM ; i < search For . length ; i ++ ) { script = check And Replace Code ( search For [ i ] , replace With [ i ] , script ) ; } final int indexs = script . index Of ( _ STR ) ; printf : if ( indexs != - _ NUM ) { final  String Builder buf = new  String Builder ( ) ; int index Start = script . last Index Of ( _ STR , indexs ) ; final int indextmp = script . last Index Of ( _ STR , indexs ) ; if ( index Start == - _ NUM || ( indextmp != - _ NUM && indextmp > index Start ) ) { index Start = indextmp ; } buf . append ( script . substring ( _ NUM , index Start + _ NUM ) ) ; int speech = script . index Of ( _ STR , indexs ) ; speech = script . index Of ( _ STR , speech + _ NUM ) ; while ( script . char At ( speech - _ NUM ) == _ STR ) { speech = script . index Of ( _ STR , speech ) ; } final int start Args = script . index Of ( _ STR , speech ) ; final int end Args = script . index Of ( _ STR , start Args ) ; final  String arguments = script . substring ( start Args + _ NUM , end Args ) ; if ( arguments . equals ( _ STR ) ) { break printf ; } final  String Tokenizer tok = new  String Tokenizer ( arguments , _ STR ) ; buf . append ( _ STR ) ; int i = _ NUM ; while ( tok . has More Tokens ( ) ) { buf . append ( _ STR ) ; buf . append ( i ++ ) ; buf . append ( _ STR ) ; buf . append ( tok . next Token ( ) ) ; buf . append ( _ STR ) ; } buf . append ( script . substring ( index Start + _ NUM , start Args + _ NUM ) ) ; buf . append ( _ STR ) ; buf . append ( script . substring ( end Args ) ) ; script = buf . to String ( ) ; } script = check And Replace Code ( _ STR , _ STR , script ) ; script = check And Replace Code ( _ STR , _ STR , script ) ; script = check And Replace Code ( _ STR , _ STR , script ) ; script = check And Replace Code ( _ STR , _ STR , script ) ; script = check And Replace Code ( _ STR , _ STR , script ) ; return script ; }
public static  String compatible Field Name (  String original ) { if ( ! original . matches ( _ STR ) ) { return _ STR + original ; } else { return original ; } }
public boolean contains (  Event Point ep ) { return events . contains ( ep ) ; }
public  String to String ( ) {  String Buffer buffer = new  String Buffer ( ) ; buffer . append ( to String ( get Class ( ) ) ) ; buffer . append ( _ STR ) ; buffer . append ( is Use Default ( ) ) ; buffer . append ( _ STR ) ; buffer . append ( element Converter . to String ( ) ) ; buffer . append ( _ STR ) ; return buffer . to String ( ) ; }
public static byte [ ] encode ( byte [ ] data ) {  Byte Array Output Stream b Out = new  Byte Array Output Stream ( ) ; try { encoder . encode ( data , _ NUM , data . length , b Out ) ; } catch (  Exception e ) { throw new  Encoder Exception ( _ STR + e . get Message ( ) , e ) ; } return b Out . to Byte Array ( ) ; }
protected  Rectangle calculate BBox (  List <  Point > points ) { double min X =  Double .  MAX_ VALUE ; double min Y =  Double .  MAX_ VALUE ; double max X = -  Double .  MAX_ VALUE ; double max Y = -  Double .  MAX_ VALUE ; for (  Point p : points ) { min X =  Math . min ( p . get X ( ) , min X ) ; min Y =  Math . min ( p . get Y ( ) , min Y ) ; max X =  Math . max ( p . get X ( ) , max X ) ; max Y =  Math . max ( p . get Y ( ) , max Y ) ; } return new  Rectangle ( ( float ) min X , ( float ) min Y , ( float ) ( max X - min X ) , ( float ) ( max Y - min Y ) ) ; }
public  MAVLink Message (  MAVLink Schema schema ,  String msg Name , int system ID , int component ID ) { this . schema = schema ; this . definition = schema . get Message Definition ( msg Name ) ; if ( definition == null ) { throw new  Runtime Exception ( _ STR + msg Name ) ; } this . payload = new byte [ definition . payload Length ] ; this . payload BB =  Byte Buffer . wrap ( payload ) ; payload BB . order ( schema . get Byte Order ( ) ) ; this . system ID = system ID ; this . component ID = component ID ; this . msg ID = definition . id ; }
public static double pdf ( double x , double mu , double sigma , double k ) { if ( x ==  Double .  POSITIVE_ INFINITY || x ==  Double .  NEGATIVE_ INFINITY ) { return _ NUM ; } x = ( x - mu ) / sigma ; if ( k > _ NUM || k < _ NUM ) { if ( k * x > _ NUM ) { return _ NUM ; } double t =  Math . log ( _ NUM - k * x ) ; return t ==  Double .  NEGATIVE_ INFINITY ? _ NUM / sigma : t ==  Double .  POSITIVE_ INFINITY ? _ NUM :  Math . exp ( ( _ NUM - k ) * t / k -  Math . exp ( t / k ) ) / sigma ; } else { return  Math . exp ( - x -  Math . exp ( - x ) ) / sigma ; } }
public  Script Builder small Num ( int num ) { return small Num ( chunks . size ( ) , num ) ; }
private static void draw Triangle Up (  Graphics gx , double x , double y , int size ) { gx . draw Line ( ( int ) ( x ) , ( int ) ( y - size ) , ( int ) ( x - size ) , ( int ) ( y + size ) ) ; gx . draw Line ( ( int ) ( x - size ) , ( int ) ( y + size ) , ( int ) ( x + size ) , ( int ) ( y + size ) ) ; gx . draw Line ( ( int ) ( x + size ) , ( int ) ( y + size ) , ( int ) ( x ) , ( int ) ( y - size ) ) ; }
@  Override public void paint Component (  Graphics g ) { super . paint Component ( g ) ; if ( m_ Background != null ) { g . set Color (  Color .  WHITE ) ; g . clear Rect ( _ NUM , _ NUM , get Width ( ) , get Height ( ) ) ; int width = m_ Background . get Width ( null ) ; int height = m_ Background . get Height ( null ) ; int x = ( get Width ( ) - width ) / _ NUM ; int y = ( get Height ( ) - height ) / _ NUM ; g . draw Image ( m_ Background , x , y , width , height , this ) ; } }
public void add Charge (  Attack Action ea ) { pending Charges . add Element ( ea ) ; process Game Event ( new  Game New Action Event ( this , ea ) ) ; }
public static  String read String ( final  JSONArray json Array , final int index , final boolean required , final boolean not Null ) throws  JSONException { if ( required ) { return json Array . get String ( index ) ; } if ( not Null && json Array . is Null ( index ) ) { throw new  JSONException (  String . format (  Locale .  US ,  NULL_ VALUE_ FORMAT_ ARRAY , index ) ) ; }  String value = null ; if ( ! json Array . is Null ( index ) ) { value = json Array . get String ( index ) ; } return value ; }
public static  Web Element find Element Visible After (  Search Context parent ,  By by , int timeout In Seconds ) {  Preconditions . check Not Null ( parent ) ;  Preconditions . check Not Null ( by ) ; try {  Web Element Wait wait = new  Web Element Wait ( parent , timeout In Seconds ) ; return wait . until ( null ) ; } catch (  Timeout Exception e ) { throw new  Timeout Exception (  String . format ( _ STR , by , timeout In Seconds ) , e ) ; } }
public final  Test Subscriber assert Not Complete ( ) {  String prefix = _ STR ; boolean passed = _ BOOL ; if ( done . get Count ( ) != _ NUM ) { prefix = _ STR ; } long c = completions ; if ( c == _ NUM ) { fail ( prefix , _ STR , errors ) ; fail ( _ STR ) ; passed = _ BOOL ; } else if ( c > _ NUM ) { fail ( prefix , _ STR + c , errors ) ; fail ( _ STR ) ; passed = _ BOOL ; } pass ( _ STR , passed ) ; return this ; }
public void add (  Video video ) { video List . add ( video ) ; notify Data Set Changed ( ) ; }
public static  Account generate Random Account ( ) { return new  Account ( new  Key Pair ( ) ) ; }
private boolean types Match (  Class <  V > value Type ,  Class getter Type ) { if ( getter Type != value Type ) { if ( getter Type . is Primitive ( ) ) { return ( getter Type == float . class && value Type ==  Float . class ) || ( getter Type == int . class && value Type ==  Integer . class ) || ( getter Type == boolean . class && value Type ==  Boolean . class ) || ( getter Type == long . class && value Type ==  Long . class ) || ( getter Type == double . class && value Type ==  Double . class ) || ( getter Type == short . class && value Type ==  Short . class ) || ( getter Type == byte . class && value Type ==  Byte . class ) || ( getter Type == char . class && value Type ==  Character . class ) ; } return _ BOOL ; } return _ BOOL ; }
@  Override public void close ( ) throws  IOException {  Output Stream stream = get Stream ( ) ; if ( stream == null ) { return ; } synchronized ( stream ) { stream . flush ( ) ; } }
public void reset Network State ( ) { m State Depository . clear ( ) ; m Transition Direction =  State Transition Direction .  DO_ NOTHING ; m Transition Target =  State .  UNKNOWN ; }
public boolean remove Container And Cancel If Necessary (  Image Container container ) { m Containers . remove ( container ) ; if ( m Containers . size ( ) == _ NUM ) { m Request . cancel ( ) ; return _ BOOL ; } return _ BOOL ; }
public void normalise ( ) { this . dirty = _ BOOL ; float mag = ( float )  Math . sqrt ( points [ _ NUM ] * points [ _ NUM ] + points [ _ NUM ] * points [ _ NUM ] + points [ _ NUM ] * points [ _ NUM ] + points [ _ NUM ] * points [ _ NUM ] ) ; points [ _ NUM ] = points [ _ NUM ] / mag ; points [ _ NUM ] = points [ _ NUM ] / mag ; points [ _ NUM ] = points [ _ NUM ] / mag ; points [ _ NUM ] = points [ _ NUM ] / mag ; }
public void test Write Read Empty ( ) throws  Exception {  Byte Array Output Stream out = new  Byte Array Output Stream ( _ NUM ) ;  Object Output Stream os = new  Object Output Stream ( out ) ; os . write Object ( empty ) ;  Object Input Stream is = new  Object Input Stream ( new  Byte Array Input Stream ( out . to Byte Array ( ) ) ) ;  Replication Policy copy = (  Replication Policy ) is . read Object ( ) ; is . close ( ) ; os . close ( ) ; assert True ( helper . are Equals ( empty , copy ) ) ; }
public  Zip Entry (  String name ) { if ( name == null ) { throw new  Null Pointer Exception ( ) ; } if ( name . length ( ) > _ NUM ) { throw new  Illegal Argument Exception ( _ STR ) ; } this . name = name ; }
public static boolean check Connection (  Connection conn ) {  String sql = _ STR ;  Statement stmt = null ;  Result Set rs = null ; try { stmt = conn . create Statement ( ) ; stmt . set Query Timeout ( _ NUM ) ; rs = stmt . execute Query ( sql ) ; if ( rs != null && rs . next ( ) ) return _ BOOL ; return _ BOOL ; } catch (  Exception ex ) { } finally { close ( rs ) ; close ( stmt ) ; } return _ BOOL ; }
public void read Dictionary (  String filename ,  String suffix ,  Input Stream res ) throws  IOException {  Buffered Reader in = new  Buffered Reader ( new  Input Stream Reader ( res ) ) ;  String line ; while ( ( line = in . read Line ( ) ) != null ) {  String [ ] terms = splitter . split ( line ) ; if ( terms . length > max Phrase Length ) continue ; if ( terms . length == _ NUM ) continue ;  Gaz Entry ge = gaz . get ( terms [ _ NUM ] ) ; if ( ge == null ) { gaz . put ( terms [ _ NUM ] , new  Gaz Entry ( terms , _ NUM , filename + suffix ) ) ; } else { ge . add Child ( terms , _ NUM , filename + suffix ) ; } } in . close ( ) ; }
private  String aggregate Wildcard (  String target Token ) { int len = _ NUM ; if ( target Token == null || ( len = target Token . length ( ) ) == _ NUM ) { return target Token ; } char [ ] oldchars = target Token . to Char Array ( ) ; char [ ] newchars = new char [ len ] ; int i = _ NUM ; int j = _ NUM ; int k = _ NUM ; boolean found Wildcard = _ BOOL ; while ( i < len ) { if ( target Token . starts With ( one Level Wildcard , i ) ) { if ( ! found Wildcard ) { k = i ; while ( i < k + one Level Wildcard Length ) { newchars [ j ++ ] = oldchars [ i ++ ] ; } found Wildcard = _ BOOL ; } else { i = i + one Level Wildcard Length ; } } else { found Wildcard = _ BOOL ; newchars [ j ++ ] = oldchars [ i ++ ] ; } } return  String . value Of ( newchars , _ NUM , j ) ; }
private  Value Graph Vertex find Or Create Vertex (  Register r ) {  Value Graph Vertex v = get Vertex ( r ) ; if ( v == null ) { v = new  Value Graph Vertex ( r ) ; v . set Label ( r , _ NUM ) ; graph . add Graph Node ( v ) ; name Map . put ( r , v ) ; } return v ; }
public  Set <  String > vars ( ) { return  Collections . unmodifiable Set ( vals . key Set ( ) ) ; }
public static boolean is Windows ( ) {  String os Name =  System . get Property ( _ STR ) ; os Name = os Name . to Lower Case ( ) ; return os Name . index Of ( _ STR ) != - _ NUM ; }
public  Throwable (  Throwable throwable ) { this ( ) ; this . detail Message = throwable == null ? null : throwable . to String ( ) ; cause = throwable ; }
protected void print ( double v ) throws  IOException { print (  String . value Of ( v ) ) ; }
public  Object2 Double Open Hash Map < int [ ] > support Map ( int support Threshold ) {  List <  Item Set > item Sets = learn ( ) ;  Object2 Double Open Hash Map < int [ ] > support Map = new  Object2 Double Open Hash Map < > ( item Sets . size ( ) ) ; for (  Item Set item Set : item Sets ) { if ( item Set . support >= support Threshold ) { support Map . put ( item Set . items , item Set . support ) ; } } return support Map ; }
public static boolean is All Cap (  String str ) { if ( str . length ( ) <= _ NUM ) { return _ BOOL ; } for ( int i = _ NUM ; i < str . length ( ) ; i ++ ) { if ( !  Character . is Letter ( str . char At ( i ) ) || !  Character . is Upper Case ( str . char At ( i ) ) ) { return _ BOOL ; } } return _ BOOL ; }
private boolean show Header Of ( int position , @  Non Null  T item , boolean init ) {  IHeader header = get Header Of ( item ) ; if ( header == null || get Pending Removed Item ( item ) != null ) return _ BOOL ; if ( header . is Hidden ( ) ) { if (  DEBUG )  Log . v (  TAG , _ STR + position + _ STR + header ) ; header . set Hidden ( _ BOOL ) ; if ( init ) { if ( position < m Items . size ( ) ) { m Items . add ( position , (  T ) header ) ; } else { m Items . add ( (  T ) header ) ; } return _ BOOL ; } else { return add Item ( position , (  T ) header ) ; } } return _ BOOL ; }
private static int to Digit ( final char ch , final int index ) { final int digit =  Character . digit ( ch , _ NUM ) ; if ( digit == - _ NUM ) { throw new  Runtime Exception ( _ STR + ch + _ STR + index ) ; } return digit ; }
static void load Library With Class Loader (  String lib Name ,  Class Loader loader ) {  Security Manager sc =  System . get Security Manager ( ) ; if ( sc != null ) { sc . check Link ( lib Name ) ; } if ( loader != null ) {  String full Lib Name = loader . find Library ( lib Name ) ; if ( full Lib Name != null ) { load Library ( full Lib Name , loader , null ) ; return ; } }  String path =  System . get Property ( _ STR , _ STR ) ; path +=  System . get Property ( _ STR , _ STR ) ; load Library ( lib Name , loader , path ) ; }
public  Enumeration list Options ( ) {  Vector new Vector = new  Vector ( _ NUM ) ; new Vector . add Element ( new  Option ( _ STR , _ STR , _ NUM , _ STR ) ) ; new Vector . add Element ( new  Option ( _ STR , _ STR , _ NUM , _ STR ) ) ; return new Vector . elements ( ) ; }
public static void save To Protected Store (  Private Key private Key ,  Certificate certificate ,  File store Location ,  String alias ,  String private Key Password ,  String key Store Password ,  String key Store Type ) throws  IOException ,  Key Store Exception ,  No Such Provider Exception ,  No Such Algorithm Exception ,  Certificate Exception {  Key Store store = null ; if ( key Store Type . equals ( _ STR ) ) { store =  Key Store . get Instance ( key Store Type ,  Crypto Util . get Security Provider Name (  Key Store . class ) ) ; } else store =  Key Store . get Instance ( key Store Type ) ; store . load ( null , null ) ;  Certificate [ ] chain = new  Certificate [ _ NUM ] ; chain [ _ NUM ] = certificate ; if ( private Key Password != null ) store . set Key Entry ( alias , private Key , private Key Password . to Char Array ( ) , chain ) ; else store . set Key Entry ( alias , private Key , null , chain ) ;  File Output Stream f Out = new  File Output Stream ( store Location ) ; try { store . store ( f Out , key Store Password == null ? null : key Store Password . to Char Array ( ) ) ; } finally { f Out . close ( ) ; } }
public  And Query Builder add (  Query Builder filter Builder ) { filters . add ( filter Builder ) ; return this ; }
void update ( long time , int rows ) { count ++ ; execution Time Min =  Math . min ( time , execution Time Min ) ; execution Time Max =  Math . max ( time , execution Time Max ) ; row Count Min =  Math . min ( rows , row Count Min ) ; row Count Max =  Math . max ( rows , row Count Max ) ; double delta = rows - row Count Mean ; row Count Mean += delta / count ; row Count M2 += delta * ( rows - row Count Mean ) ; delta = time - execution Time Mean ; execution Time Mean += delta / count ; execution Time M2 += delta * ( time - execution Time Mean ) ; execution Time Cumulative += time ; row Count Cumulative += rows ; last Update Time =  System . current Time Millis ( ) ; }
public static final void main (  String [ ] args ) { try {  Properties properties = new  Properties ( ) ;  File journal =  File . create Temp File ( _ STR , _ STR ) ; log . info ( journal . get Absolute Path ( ) ) ; journal . delete On Exit ( ) ; properties . set Property (  Bigdata Sail .  Options .  FILE , journal . get Absolute Path ( ) ) ;  Bigdata Sail sail = new  Bigdata Sail ( properties ) ;  Bigdata Sail Repository repo = new  Bigdata Sail Repository ( sail ) ; repo . initialize ( ) ;  Bigdata Writer writer = new  Bigdata Writer ( repo ) ;  Collection <  Bigdata Reader > readers = new  Linked List <  Bigdata Reader > ( ) ; for ( int i = _ NUM ; i < num Readers ; i ++ ) { readers . add ( new  Bigdata Reader ( repo ) ) ; }  Executor Service executor =  Executors . new Cached Thread Pool ( ) ;  Future writer Future = executor . submit ( writer ) ;  Collection <  Future > reader Futures = new  Linked List <  Future > ( ) ; for (  Bigdata Reader reader : readers ) { reader Futures . add ( executor . submit ( reader ) ) ; } writer Future . get ( ) ; for (  Bigdata Reader reader : readers ) { reader . kill ( ) ; } for (  Future reader Future : reader Futures ) { reader Future . get ( ) ; } repo . shut Down ( ) ; } catch (  Exception ex ) { ex . print Stack Trace ( ) ; } }
@  Override public  String to String ( ) {  String result ; try { if ( m_ Document == null ) { result = _ STR ; } else { result = m_ Document . get Text ( _ NUM , m_ Document . get Length ( ) ) ; } } catch (  Exception e ) { result = _ STR ; } return result . to String ( ) ; }
private boolean via_try_snap_smd_center ( int p_layer ) {  Item Selection Filter selection_filter = new  Item Selection Filter (  Item Selection Choice .  PINS ) ;  Collection <  Brd Item > picked_items = r_board . pick_items ( prev_corner , p_layer , selection_filter ) ;  Brd Abit Pin found_smd_pin = null ; for (  Brd Item curr_item : picked_items ) { if ( ! ( curr_item instanceof  Brd Abit Pin ) ) continue ;  Brd Abit Pin a_pin = (  Brd Abit Pin ) curr_item ; if ( ! a_pin . shares_net_no ( net_nos ) ) continue ; if ( a_pin . first_layer ( ) == p_layer && a_pin . last_layer ( ) == p_layer ) { found_smd_pin = a_pin ; break ; } } if ( found_smd_pin == null ) return _ BOOL ;  Pla Point Int pin_center = found_smd_pin . center_get ( ) ; if ( itera_connect ( prev_corner , pin_center ) ) { prev_corner = pin_center ; } return _ BOOL ; }
static  String base64encode ( byte [ ] bytes ) {  String Builder builder = new  String Builder ( ( ( bytes . length + _ NUM ) / _ NUM ) * _ NUM ) ; for ( int i = _ NUM ; i < bytes . length ; i += _ NUM ) { byte b0 = bytes [ i ] ; byte b1 = i < bytes . length - _ NUM ? bytes [ i + _ NUM ] : _ NUM ; byte b2 = i < bytes . length - _ NUM ? bytes [ i + _ NUM ] : _ NUM ; builder . append (  BASE64_ CHARS [ ( b0 & _ NUM ) > > _ NUM ] ) ; builder . append (  BASE64_ CHARS [ ( ( b0 & _ NUM ) << _ NUM ) | ( ( b1 & _ NUM ) > > _ NUM ) ] ) ; builder . append ( i < bytes . length - _ NUM ?  BASE64_ CHARS [ ( ( b1 & _ NUM ) << _ NUM ) | ( ( b2 & _ NUM ) > > _ NUM ) ] : _ STR ) ; builder . append ( i < bytes . length - _ NUM ?  BASE64_ CHARS [ b2 & _ NUM ] : _ STR ) ; } return builder . to String ( ) ; }
public  Create Snapshot Request source ( byte [ ] source ) { return source ( source , _ NUM , source . length ) ; }
protected  List <  String > list User Names ( ) throws  Users Repository Exception {  Collection <  User > users = get All Users ( ) ;  List <  String > user Names = new  Array List <  String > ( users . size ( ) ) ; for (  User user : users ) { user Names . add ( user . get User Name ( ) ) ; } users . clear ( ) ; return user Names ; }
void after Write (  Runnable task ) { write Buffer . add ( task ) ; drain Status . lazy Set (  REQUIRED ) ; try To Drain Buffers ( ) ; notify Listener ( ) ; }
public static void copy File (  File source File ,  File dest File ) throws  IOException { if ( ! source File . exists ( ) ) { throw new  IOException ( _ STR + source File . get Absolute Path ( ) ) ; } copy File ( new  File Input Stream ( source File ) , new  File Output Stream ( dest File ) ) ; }
public static  String properties Encode (  Properties pp ) {  Byte Array Output Stream bos = new  Byte Array Output Stream ( ) ; try { pp . store ( bos , _ STR ) ; } catch (  IOException e ) { log . log (  Level .  SEVERE , _ STR , e ) ; }  String result = new  String ( bos . to Byte Array ( ) ) ; try { result =  URLEncoder . encode ( result ,  Web Env .  ENCODING ) ; } catch (  Unsupported Encoding Exception e ) { log . log (  Level .  SEVERE , _ STR +  Web Env .  ENCODING , e ) ;  String enc =  System . get Property ( _ STR ) ; try { result =  URLEncoder . encode ( result , enc ) ; log . info ( _ STR + enc ) ; } catch (  Exception ex ) { log . log (  Level .  SEVERE , _ STR , ex ) ; } } return result ; }
public void generate (  Xml Writer w ,  Extension Profile ext Profile ) throws  IOException {  Array List <  Xml Writer .  Attribute > attrs = new  Array List <  Xml Writer .  Attribute > ( ) ; if ( row > _ NUM ) { attrs . add ( new  Xml Writer .  Attribute ( _ STR ,  String . value Of ( row ) ) ) ; } if ( col > _ NUM ) { attrs . add ( new  Xml Writer .  Attribute ( _ STR ,  String . value Of ( col ) ) ) ; } if ( input Value != null ) { attrs . add ( new  Xml Writer .  Attribute ( _ STR , input Value ) ) ; } if ( numeric Value != null ) { attrs . add ( new  Xml Writer .  Attribute ( _ STR , numeric Value . to String ( ) ) ) ; } w . simple Element (  Namespaces . g Spread Ns , _ STR , attrs , value ) ; }
public void test Sorts Elements By Nth Name ( ) throws  Exception {  Xpp Dom dom1 =  Xpp Factory . build Dom ( _ STR ) ;  Xpp Dom dom2 =  Xpp Factory . build Dom ( _ STR ) ; assert Equals ( - _ NUM , comparator . compare ( dom1 , dom2 ) ) ; assert Equals ( _ STR , xpath . get ( ) ) ; assert Equals ( _ NUM , comparator . compare ( dom2 , dom1 ) ) ; assert Equals ( _ STR , xpath . get ( ) ) ; }
private static void delete Directory (  File file ) throws  IOException { if ( file . is Directory ( ) ) {  File [ ] files = file . list Files ( ) ; if ( files != null ) { for ( int i = _ NUM ; i < files . length ; i ++ ) { delete Directory ( files [ i ] ) ; } } } file . delete ( ) ; }
public static boolean is Assignable From (  Class < ? > destination ,  Class < ? > source ) { return destination . is Assignable From ( source ) || is Boxing ( destination , source ) || is Un Boxing ( destination , source ) ; }
private static  String convert To Quoted String (  String string ) { if ( string == null || string . length ( ) == _ NUM ) { return null ; } if ( string . char At ( _ NUM ) == _ STR && string . char At ( string . length ( ) - _ NUM ) == _ STR ) { return string ; } return _ STR + string + _ STR ; }
public void clear Values ( ) { values . clear ( ) ; }
private byte [ ] [ ] read Subrs ( byte [ ] d ) { return read Array ( d , _ STR , _ STR ) ; }
public boolean add Auth Index (  String user Name ,  String index Name ) { if ( user Name == null || user Name . equals ( _ STR ) || index Name == null || index Name . equals ( _ STR ) ) { return _ BOOL ; } user Name = user Name . to Lower Case ( ) ; index Name = index Name . to Lower Case ( ) ; if ( user Name . equals ( _ STR ) ) { return _ BOOL ; }  User Data user = get User ( user Name ) ; if ( user == null ) { return _ BOOL ; }  Set <  String > index Filters = user . get Index Filters ( ) ;  String [ ] index Names = index Name . split ( _ STR ) ; for (  String index : index Names ) { index = index . trim ( ) ; if ( index == null || index . equals ( _ STR ) ) { continue ; } if ( index . char At ( _ NUM ) != _ STR ) { index = _ STR + index ; } if ( index . equals ( _ STR ) ) { continue ; } index Filters . add ( index ) ; } user . set Filters ( index Filters ) ; return put User ( user ) ; }
@  Deprecated public static void run Finalizers On Exit ( boolean run ) { finalize On Exit = run ; }
@  Override public double [ ] [ ] predict Intervals ( double conf ) { update Width ( ) ; double val =  Statistics . normal Inverse ( _ NUM - ( _ NUM - conf ) / _ NUM ) ; double min = m_ TM . first Key ( ) - val * m_ Width ; double max = m_ TM . last Key ( ) + val * m_ Width ; double delta = ( max - min ) / m_ Num Intervals ; double [ ] probabilities = new double [ m_ Num Intervals ] ; double left Val =  Math . exp ( log Density ( min ) ) ; for ( int i = _ NUM ; i < m_ Num Intervals ; i ++ ) { double right Val =  Math . exp ( log Density ( min + ( i + _ NUM ) * delta ) ) ; probabilities [ i ] = _ NUM * ( left Val + right Val ) * delta ; left Val = right Val ; } int [ ] sorted Indices =  Utils . sort ( probabilities ) ; double sum = _ NUM ; boolean [ ] to Use = new boolean [ probabilities . length ] ; int k = _ NUM ; while ( ( sum < conf ) && ( k < to Use . length ) ) { to Use [ sorted Indices [ to Use . length - ( k + _ NUM ) ] ] = _ BOOL ; sum += probabilities [ sorted Indices [ to Use . length - ( k + _ NUM ) ] ] ; k ++ ; } probabilities = null ;  Array List < double [ ] > intervals = new  Array List < double [ ] > ( ) ; double [ ] interval = null ; boolean have Started Interval = _ BOOL ; for ( int i = _ NUM ; i < m_ Num Intervals ; i ++ ) { if ( to Use [ i ] ) { if ( have Started Interval == _ BOOL ) { have Started Interval = _ BOOL ; interval = new double [ _ NUM ] ; interval [ _ NUM ] = min + i * delta ; } interval [ _ NUM ] = min + ( i + _ NUM ) * delta ; } else { if ( have Started Interval ) { have Started Interval = _ BOOL ; intervals . add ( interval ) ; } } } if ( have Started Interval ) { intervals . add ( interval ) ; } return intervals . to Array ( new double [ _ NUM ] [ _ NUM ] ) ; }
public static boolean check MD5 ( final  String md5 Hash , final  File file ) { if (  Text Utils . is Empty ( md5 Hash ) || file == null || !  File Utils . is Readable ( file ) ) {  Log . e ( _ STR ) ; return _ BOOL ; } final  String hash = get MD5 ( file ) ; if ( hash == null ) {  Log . e ( _ STR ) ; return _ BOOL ; } return hash . equals Ignore Case ( md5 Hash ) ; }
public void add Dimension Key Name (  String key ) { dimension Key Names . add ( key ) ; }
void order Card Groups ( ) { int [ ] cs = new int [ orig Cards . size ( ) ] ; for ( int i = _ NUM ; i < cs . length ; i ++ ) cs [ i ] = cards [ orig Cards . get ( i ) ] ;  Game Table Views . new Card Group ( orig , cs ) ; cs = new int [ ordered Cards . size ( ) ] ; for ( int i = _ NUM ; i < cs . length ; i ++ ) cs [ i ] = cards [ ordered Cards . get ( i ) ] ;  Game Table Views . new Card Group ( ordered , cs ) ; can Select ( ) ; }
private static void define Entity (  String name , char value ) { if ( _by Name . get ( name ) == null ) { _by Name . put ( name , new  Integer ( value ) ) ; _by Char . put ( new  Integer ( value ) , name ) ; } }
private  String format String (  String content ) { if ( content != null ) return  String Utils . format String ( content ) ; return content ; }
@  Override public void draw (  Graphics2 D g2 ,  Rectangle2 D area ) { draw ( g2 , area , null ) ; }
public void add Hole (  Linear Ring hole ) { if ( holes == null ) holes = new  Array List ( ) ; holes . add ( hole ) ; }
public void replace (  Component existing Component ,  Component new Component ) { if ( existing Component == null || new Component == null ) { throw new  Illegal Argument Exception ( _ STR ) ; } if ( springs Changed ) { register Components ( horizontal Group ,  HORIZONTAL ) ; register Components ( vertical Group ,  VERTICAL ) ; }  Component Info info = (  Component Info ) component Infos . remove ( existing Component ) ; if ( info == null ) { throw new  Illegal Argument Exception ( _ STR ) ; } host . remove Component ( existing Component ) ; if ( new Component . get Parent ( ) != host ) { host . add Component ( new Component ) ; } info . set Component ( new Component ) ; component Infos . put ( new Component , info ) ; invalidate Host ( ) ; }
private int read Input Data ( byte [ ] buf , int off , int len ) throws  IOException { cb Lock . lock ( ) ; try { return iis . read ( buf , off , len ) ; } finally { cb Lock . unlock ( ) ; } }
public byte [ ] generate160 Bit Hash Id ( ) throws  Crypto Exception { try {  DERBit String public Key Bit String = encode Public Key As Bit String ( public Key ) ; return  Digest Util . get Message Digest ( public Key Bit String . get Bytes ( ) ,  Digest Type .  SHA1 ) ; } catch (  IOException ex ) { throw new  Crypto Exception ( res . get String ( _ STR ) , ex ) ; } }
public static <  C extends  Configuration Client ,  S extends  Configuration >  Create Sub Command Handler <  C ,  S > create (  Sub Command Argument Parser parser ,  Managed Object Path < ? , ? > p ,  Set Relation Definition <  C ,  S > r ) throws  Argument Exception { return new  Create Sub Command Handler < > ( parser , p , r , null , p . child ( r ) ) ; }
public  DSubject Alternative Name (  JDialog parent , byte [ ] value ) throws  IOException { super ( parent ) ; set Title ( res . get String ( _ STR ) ) ; init Components ( ) ; prepopulate With Value ( value ) ; }
public void test Get Scope ( ) throws  Exception {  Identity i = new  Identity Stub ( _ STR ) ; assert Null ( i . get Scope ( ) ) ;  Identity Scope s =  Identity Scope . get System Scope ( ) ;  Identity i2 = new  Identity Stub ( _ STR , s ) ; assert Same ( s , i2 . get Scope ( ) ) ; }
private  Figure read Rect Element (  IXMLElement elem ) throws  IOException {  Hash Map <  Attribute Key ,  Object > a = new  Hash Map <  Attribute Key ,  Object > ( ) ; read Core Attributes ( elem , a ) ; read Transform Attribute ( elem , a ) ; read Opacity Attribute ( elem , a ) ; read Shape Attributes ( elem , a ) ; double x = to Number ( elem , read Attribute ( elem , _ STR , _ STR ) ) ; double y = to Number ( elem , read Attribute ( elem , _ STR , _ STR ) ) ; double w = to Width ( elem , read Attribute ( elem , _ STR , _ STR ) ) ; double h = to Height ( elem , read Attribute ( elem , _ STR , _ STR ) ) ;  String rx Value = read Attribute ( elem , _ STR , _ STR ) ;  String ry Value = read Attribute ( elem , _ STR , _ STR ) ; if ( rx Value . equals ( _ STR ) ) { rx Value = ry Value ; } if ( ry Value . equals ( _ STR ) ) { ry Value = rx Value ; } double rx = to Number ( elem , rx Value . equals ( _ STR ) ? _ STR : rx Value ) ; double ry = to Number ( elem , ry Value . equals ( _ STR ) ? _ STR : ry Value ) ;  Figure figure = factory . create Rect ( x , y , w , h , rx , ry , a ) ; element Objects . put ( elem , figure ) ; return figure ; }
public boolean is Set Status ( ) { return __isset_bit_vector . get ( __ STATUS_ ISSET_ ID ) ; }
public  String (  String Buffer buffer ) { synchronized ( buffer ) { this . value =  Arrays . copy Of ( buffer . get Value ( ) , buffer . length ( ) ) ; } }
public  Date Picker (  Composite parent , int style ) { this ( parent , style ,  Calendar . get Instance ( ) ) ; }
private void populate Unity Access Profile For System (  Access Profile access Profile ,  Storage System storage Device ) {  URI provider Uri = storage Device . get Active Provider URI ( ) ; if ( !  Null Column Value Getter . is Null URI ( provider Uri ) ) {  Storage Provider provider = _db Client . query Object (  Storage Provider . class , provider Uri ) ; access Profile . set System Type ( storage Device . get System Type ( ) ) ; access Profile . set Ip Address ( provider . get IPAddress ( ) ) ; access Profile . set User Name ( provider . get User Name ( ) ) ; access Profile . set Password ( provider . get Password ( ) ) ; access Profile . setserial ID ( storage Device . get Serial Number ( ) ) ; access Profile . set Port Number ( provider . get Port Number ( ) ) ; access Profile . set Last Sample Time ( _ NUM ) ; } else { access Profile . set System Type ( storage Device . get System Type ( ) ) ; access Profile . set Ip Address ( storage Device . get Ip Address ( ) ) ; access Profile . set User Name ( storage Device . get Username ( ) ) ; access Profile . set Password ( storage Device . get Password ( ) ) ; access Profile . setserial ID ( storage Device . get Serial Number ( ) ) ; access Profile . set Port Number ( storage Device . get Port Number ( ) ) ; access Profile . set Last Sample Time ( _ NUM ) ; } }
public final int read Int ( ) throws java . io .  IOException { read Fully ( scratch , _ NUM , _ NUM ) ; return ( ( ( scratch [ _ NUM ] & _ NUM ) << _ NUM ) | ( ( scratch [ _ NUM ] & _ NUM ) << _ NUM ) | ( ( scratch [ _ NUM ] & _ NUM ) << _ NUM ) | ( ( scratch [ _ NUM ] & _ NUM ) << _ NUM ) ) ; }
public  Replication Job create Job For Drop Partition ( long audit Log Id , long audit Log Entry Create Time ,  Named Partition named Partition ) throws  State Update Exception {  Map <  String ,  String > extras = new  Hash Map < > ( ) ; extras . put (  Persisted Job Info .  AUDIT_ LOG_ ID_ EXTRAS_ KEY ,  Long . to String ( audit Log Id ) ) ; extras . put (  Persisted Job Info .  AUDIT_ LOG_ ENTRY_ CREATE_ TIME_ KEY ,  Long . to String ( audit Log Entry Create Time ) ) ;  Replication Operation replication Operation =  Replication Operation .  DROP_ PARTITION ;  Hive Object Spec partition Spec = new  Hive Object Spec ( named Partition ) ;  List <  String > partition Names = new  Array List < > ( ) ; partition Names . add ( named Partition . get Name ( ) ) ;  Optional <  String > partition Tldt =  Replication Utils . get Tldt ( named Partition . get Partition ( ) ) ;  Persisted Job Info persisted Job Info = job Info Store . resilient Create ( replication Operation ,  Replication Status .  PENDING ,  Replication Utils . get Location ( named Partition . get Partition ( ) ) , src Cluster . get Name ( ) , partition Spec . get Table Spec ( ) , partition Names , partition Tldt ,  Optional . empty ( ) ,  Optional . empty ( ) , extras ) ; return new  Replication Job ( conf , new  Drop Partition Task ( src Cluster , dest Cluster , partition Spec , partition Tldt ) , on State Change Handler , persisted Job Info ) ; }
private static  String pre Parse Code (  String script ) { final  String [ ] search For = { _ STR , _ STR , _ STR , _ STR , _ STR , _ STR , _ STR , _ STR , _ STR , _ STR , _ STR , _ STR , _ STR , _ STR , _ STR , _ STR } ; final  String [ ] replace With = { _ STR , _ STR , _ STR , _ STR , _ STR , _ STR , _ STR , _ STR , _ STR , _ STR , _ STR , _ STR , _ STR , _ STR , _ STR , _ STR } ; for ( int i = _ NUM ; i < search For . length ; i ++ ) { script = check And Replace Code ( search For [ i ] , replace With [ i ] , script ) ; } final int indexs = script . index Of ( _ STR ) ; printf : if ( indexs != - _ NUM ) { final  String Builder buf = new  String Builder ( ) ; int index Start = script . last Index Of ( _ STR , indexs ) ; final int indextmp = script . last Index Of ( _ STR , indexs ) ; if ( index Start == - _ NUM || ( indextmp != - _ NUM && indextmp > index Start ) ) { index Start = indextmp ; } buf . append ( script . substring ( _ NUM , index Start + _ NUM ) ) ; int speech = script . index Of ( _ STR , indexs ) ; speech = script . index Of ( _ STR , speech + _ NUM ) ; while ( script . char At ( speech - _ NUM ) == _ STR ) { speech = script . index Of ( _ STR , speech ) ; } final int start Args = script . index Of ( _ STR , speech ) ; final int end Args = script . index Of ( _ STR , start Args ) ; final  String arguments = script . substring ( start Args + _ NUM , end Args ) ; if ( arguments . equals ( _ STR ) ) { break printf ; } final  String Tokenizer tok = new  String Tokenizer ( arguments , _ STR ) ; buf . append ( _ STR ) ; int i = _ NUM ; while ( tok . has More Tokens ( ) ) { buf . append ( _ STR ) ; buf . append ( i ++ ) ; buf . append ( _ STR ) ; buf . append ( tok . next Token ( ) ) ; buf . append ( _ STR ) ; } buf . append ( script . substring ( index Start + _ NUM , start Args + _ NUM ) ) ; buf . append ( _ STR ) ; buf . append ( script . substring ( end Args ) ) ; script = buf . to String ( ) ; } script = check And Replace Code ( _ STR , _ STR , script ) ; script = check And Replace Code ( _ STR , _ STR , script ) ; script = check And Replace Code ( _ STR , _ STR , script ) ; script = check And Replace Code ( _ STR , _ STR , script ) ; script = check And Replace Code ( _ STR , _ STR , script ) ; return script ; }
public static  Map <  String ,  Object > create Image (  Dispatch Context dctx ,  Map <  String , ? extends  Object > context ) {  Map <  String ,  Object > result = create Image Method ( dctx , context ) ; return result ; }
public static boolean is File Exist (  String file Path ) { if (  Handler_ String . is Blank ( file Path ) ) { return _ BOOL ; }  File file = new  File ( file Path ) ; return ( file . exists ( ) && file . is File ( ) ) ; }
public void start (  Stage stage ) throws  Exception { stage . set Scene ( new  Scene ( new  My Demo Pane ( ) ) ) ; stage . set Title ( _ STR ) ; stage . set Width ( _ NUM ) ; stage . set Height ( _ NUM ) ; stage . show ( ) ; }
public static double [ ] lprefc2lpc ( double [ ] k ) { int p = k . length ; double [ ] [ ]  A = new double [ p ] [ ] ; int i , j ; for ( i = _ NUM ; i <= p ; i ++ ) {  A [ i - _ NUM ] = new double [ i ] ;  A [ i - _ NUM ] [ i - _ NUM ] = k [ i - _ NUM ] ; for ( j = _ NUM ; j < i ; j ++ )  A [ i - _ NUM ] [ j - _ NUM ] =  A [ i - _ NUM ] [ j - _ NUM ] - k [ i - _ NUM ] *  A [ i - _ NUM ] [ i - j - _ NUM ] ; } double [ ] one Minus A = new double [ p + _ NUM ] ; one Minus A [ _ NUM ] = _ NUM ;  System . arraycopy (  A [ p - _ NUM ] , _ NUM , one Minus A , _ NUM , p ) ; return one Minus A ; }
public synchronized void bootstrap ( ) { if ( ! is Running ( ) ||  System . current Time Millis ( ) - last Bootstrap <  DHTConstants .  BOOTSTRAP_ MIN_ INTERVAL ) { return ; } if ( ! bootstrapping . compare And Set (  Bootstrap State .  NONE ,  Bootstrap State .  FILL ) ) return ; if ( use Router Bootstrapping && node . get Num Entries In Routing Table ( ) <  DHTConstants .  USE_ BT_ ROUTER_ IF_ LESS_ THAN_ X_ PEERS ) { router Bootstrap ( ) ; } else { fill Home Buckets (  Collections . empty List ( ) ) ; } }
DGCAck Handler (  UID id ) { this . id = id ; if ( id != null ) { assert ! id Table . contains Key ( id ) ; id Table . put ( id , this ) ; } }
protected void save Buffer ( ) {  String Buffer sb = m_ History . get Selected Buffer ( ) ; if ( sb != null ) { if ( m_ Save Out . save ( sb ) ) {  JOption Pane . show Message Dialog ( this , _ STR , _ STR ,  JOption Pane .  INFORMATION_ MESSAGE ) ; } } else { m_ Save Out But . set Enabled ( _ BOOL ) ; } }
private  List <  Recommendation > create Metro Point Recommendations (  Virtual Array src Varray ,  List <  Virtual Array > tgt Varrays ,  Virtual Pool src Vpool ,  Virtual Array ha Varray ,  Virtual Pool ha Vpool ,  Project project ,  Virtual Pool Capability Values Wrapper capabilities ,  List <  Storage Pool > candidate Primary Pools ,  List <  Storage Pool > candidate Secondary Pools ,  Volume vpool Change Volume ) {  List <  Recommendation > recommendations = new  Array List <  Recommendation > ( ) ;  RPProtection Recommendation rp Protection Recommendaton = null ;  Map <  Virtual Array ,  List <  Storage Pool > > tgt Varray Storage Pools Map = get Vplex Target Matching Pools ( tgt Varrays , src Vpool , project , capabilities , vpool Change Volume ) ; rp Protection Recommendaton = create RPProtection Recommendation For Metro Point ( src Varray , tgt Varrays , src Vpool , ha Varray , ha Vpool , capabilities , candidate Primary Pools , candidate Secondary Pools , tgt Varray Storage Pools Map , vpool Change Volume , project ) ; _log . info (  String . format ( _ STR , rp Protection Recommendaton . get Resource Count ( ) ) ) ; recommendations . add ( rp Protection Recommendaton ) ; return recommendations ; }
public  Tomcat Service Builder base Dir (  String base Dir ) { return base Dir (  Paths . get ( require Non Null ( base Dir , _ STR ) ) ) ; }
protected void add (  Instance inst ) { for ( int i = _ NUM ; i < m_ Specifiers . size ( ) ; i ++ ) {  Instance specifier = m_ Specifiers . get ( i ) ; boolean found = _ BOOL ; for ( int m_ Dataset Key Column : m_ Dataset Key Columns ) { if ( inst . value ( m_ Dataset Key Column ) != specifier . value ( m_ Dataset Key Column ) ) { found = _ BOOL ; } } if ( found ) { return ; } } m_ Specifiers . add ( inst ) ; }
@  Override protected void validate Auto Tier Policy (  String auto Tier Policy Id ,  Un Managed Volume un Managed Volume ,  Virtual Pool v Pool ) { return ; }
public static void monitor Signal ( final  Object monitor ) { synchronized ( monitor ) { monitor . notify All ( ) ; } }
protected boolean is Level Enabled ( int log Level ) { return ( log Level >= current Log Level ) ; }
private int make Available ( ) throws  IOException { if ( pos != - _ NUM ) { return _ NUM ; } total += tail - head - pad ;  System . arraycopy ( buffer , tail - pad , buffer , _ NUM , pad ) ; head = _ NUM ; tail = pad ; for ( ; ; ) { int bytes Read = input . read ( buffer , tail , buf Size - tail ) ; if ( bytes Read == - _ NUM ) { final  String msg = _ STR ; throw new  Malformed Stream Exception ( msg ) ; } tail += bytes Read ; find Separator ( ) ; int av = available ( ) ; if ( av > _ NUM || pos != - _ NUM ) { return av ; } } }
protected double [ ] make Distribution (  Instances neighbours , double [ ] distances ) throws  Exception { double total = _ NUM , weight ; double [ ] distribution = new double [ m_ Num Classes ] ; if ( m_ Class Type ==  Attribute .  NOMINAL ) { for ( int i = _ NUM ; i < m_ Num Classes ; i ++ ) { distribution [ i ] = _ NUM /  Math . max ( _ NUM , m_ Train . num Instances ( ) ) ; } total = ( double ) m_ Num Classes /  Math . max ( _ NUM , m_ Train . num Instances ( ) ) ; } for ( int i = _ NUM ; i < neighbours . num Instances ( ) ; i ++ ) {  Instance current = neighbours . instance ( i ) ; distances [ i ] = distances [ i ] * distances [ i ] ; distances [ i ] =  Math . sqrt ( distances [ i ] / m_ Num Attributes Used ) ; switch ( m_ Distance Weighting ) { case  WEIGHT_ INVERSE : weight = _ NUM / ( distances [ i ] + _ NUM ) ; break ; case  WEIGHT_ SIMILARITY : weight = _ NUM - distances [ i ] ; break ; default : weight = _ NUM ; break ; } weight *= current . weight ( ) ; try { switch ( m_ Class Type ) { case  Attribute .  NOMINAL : distribution [ ( int ) current . class Value ( ) ] += weight ; break ; case  Attribute .  NUMERIC : distribution [ _ NUM ] += current . class Value ( ) * weight ; break ; } } catch (  Exception ex ) { throw new  Error ( _ STR ) ; } total += weight ; } if ( total > _ NUM ) {  Utils . normalize ( distribution , total ) ; } return distribution ; }
public  List <  String > ordered Groups ( ) { int group Count = group Count ( ) ;  List <  String > groups = new  Array List <  String > ( group Count ) ; for ( int i = _ NUM ; i <= group Count ; i ++ ) { groups . add ( group ( i ) ) ; } return groups ; }
Selector Model ( int n ) { if ( n <= _ NUM ) { throw new  Illegal Argument Exception ( _ STR + n + _ STR ) ; } this . n = n ; }
private  Image Icon add Space To Icon (  Image Icon icon ) { int width = icon . get Icon Width ( ) ; int height = icon . get Icon Height ( ) ; int hspace = _ NUM ;  Buffered Image res = new  Buffered Image ( width + hspace , height ,  Buffered Image .  TYPE_ INT_ ARGB ) ;  Graphics g = res . get Graphics ( ) ; g . draw Image ( icon . get Image ( ) , _ NUM , _ NUM , null ) ; g . dispose ( ) ; return new  Image Icon ( res ) ; }
protected boolean is White Space ( char ch ) { return ( ( ch == _ STR ) || ( ch == _ STR ) || ( ch == _ STR ) || ( ch == _ NUM ) || ( ch == _ NUM ) ) ; }
public void add Header Line (  String line ) { m Lines . add ( line ) ; }
public static  String read String ( final  Result Set result Set , final  String column Name ) throws  SQLException { return result Set . get String ( column Name ) ; }
public static  Address from Encoded ( final  String encoded ) { if ( null == encoded ) { throw new  Illegal Argument Exception ( _ STR ) ; } return new  Address ( encoded . to Upper Case ( ) ) ; }
protected static  String guess Type (  File file ) {  String name = file . get Name ( ) ;  String suffix = name . substring ( name . last Index Of ( _ STR ) + _ NUM ) ;  String type = mime Map . get ( suffix . to Lower Case (  Locale .  ROOT ) ) ; return ( type != null ) ? type : _ STR ; }
public void test Next All Terms ( ) throws  Exception {  List <  String > terms List = new  Array List < > ( ) ; terms List . add All (  Arrays . as List ( common Terms ) ) ; terms List . add All (  Arrays . as List ( medium Terms ) ) ; terms List . add All (  Arrays . as List ( rare Terms ) ) ;  String terms [ ] = terms List . to Array ( new  String [ _ NUM ] ) ; for ( int min Nr Should Match = _ NUM ; min Nr Should Match <= terms . length ; min Nr Should Match ++ ) {  Scorer expected = scorer ( terms , min Nr Should Match ,  Mode .  DOC_ VALUES ) ;  Scorer actual = scorer ( terms , min Nr Should Match ,  Mode .  SCORER ) ; assert Next ( expected , actual ) ; expected = scorer ( terms , min Nr Should Match ,  Mode .  DOC_ VALUES ) ; actual = scorer ( terms , min Nr Should Match ,  Mode .  BULK_ SCORER ) ; assert Next ( expected , actual ) ; } }
public boolean is Public ( ) { return  Modifier . is Public ( _class . get Modifiers ( ) ) ; }
public static void dump (  String file Name , boolean details ) { dump ( file Name , new  Print Writer (  System . out ) , details ) ; }
native long create Drag Source (  Component component ,  Transferable transferable ,  Input Event native Trigger , int actions , long [ ] formats ,  Map format Map ) ;
private int put Length ( int len ,  Output Stream out ) throws  IOException { int ret Val = _ NUM ; if ( len < _ NUM ) { out . write ( ( byte ) len ) ; ret Val = _ NUM ; } else if ( len < ( _ NUM << _ NUM ) ) { out . write ( ( byte ) _ NUM ) ; out . write ( ( byte ) len ) ; ret Val = _ NUM ; } else if ( len < ( _ NUM << _ NUM ) ) { out . write ( ( byte ) _ NUM ) ; out . write ( ( byte ) ( len > > _ NUM ) ) ; out . write ( ( byte ) len ) ; ret Val = _ NUM ; } else if ( len < ( _ NUM << _ NUM ) ) { out . write ( ( byte ) _ NUM ) ; out . write ( ( byte ) ( len > > _ NUM ) ) ; out . write ( ( byte ) ( len > > _ NUM ) ) ; out . write ( ( byte ) len ) ; ret Val = _ NUM ; } else { out . write ( ( byte ) _ NUM ) ; out . write ( ( byte ) ( len > > _ NUM ) ) ; out . write ( ( byte ) ( len > > _ NUM ) ) ; out . write ( ( byte ) ( len > > _ NUM ) ) ; out . write ( ( byte ) len ) ; ret Val = _ NUM ; } return ret Val ; }
private void update Font (  String family , int style , int size ) { console . set Font ( new  Font ( family , style , size ) ) ; }
public void resolve (  Class type ,  String value ) throws  Exception {  String name = type . get Name ( ) ; read . put ( value , name ) ; write . put ( name , value ) ; }
public  String format (  Date Time Formatter formatter ) {  Objects . require Non Null ( formatter , _ STR ) ; return formatter . format ( this ) ; }
public static @  Dotted Class Name  String extract Package Name ( @  Dotted Class Name  String class Name ) { int i = class Name . last Index Of ( _ STR ) ; if ( i < _ NUM ) { return _ STR ; } return class Name . substring ( _ NUM , i ) ; }
public  DAuthority Key Identifier (  JDialog parent , byte [ ] value ,  Public Key authority Public Key ) throws  IOException { super ( parent ) ; set Title ( res . get String ( _ STR ) ) ; this . authority Public Key = authority Public Key ; init Components ( ) ; prepopulate With Value ( value ) ; }
private void play Previous ( ) { if ( media Type ==  Config .  YOUTUBE_ MEDIA_ TYPE_ VIDEO ) { restart Video ( ) ; return ; } if ( next Was Called ) { iterator . previous ( ) ; next Was Called = _ BOOL ; } if ( ! iterator . has Previous ( ) ) { iterator = you Tube Videos . list Iterator ( you Tube Videos . size ( ) ) ; } video Item = iterator . previous ( ) ; previous Was Called = _ BOOL ; play Video ( ) ; }
public static  Object invoke (  Class c ,  Object obj ,  String method ,  Class [ ] param Classes ,  Object [ ] params ) throws  Illegal Access Exception ,  No Such Method Exception ,  Invocation Target Exception {  Method m = c . get Method ( method , param Classes ) ; return m . invoke ( obj , params ) ; }
public static  Rotate Stream create (  String path ) throws  Config Exception { synchronized ( _format Streams ) {  Weak Reference <  Rotate Stream > ref = _format Streams . get ( path ) ;  Rotate Stream stream = ref != null ? ref . get ( ) : null ; if ( stream == null ) { stream = new  Rotate Stream ( path ) ; _format Streams . put ( path , new  Weak Reference <  Rotate Stream > ( stream ) ) ; } return stream ; } }
public  Phone Directory ( int max Numbers ) { set = new  Linked Hash Set < > ( ) ; for ( int i = _ NUM ; i < max Numbers ; i ++ ) { set . add ( i ) ; } }
public static boolean is Valid Template (  String template ) { template = template . trim ( ) ; if ( template . index Of ( _ STR ) == - _ NUM ) { return _ BOOL ; }  String s = template . trim ( ) ; if ( s . last Index Of ( _ STR ) != s . length ( ) - _ NUM ) { return _ BOOL ; } if ( get Method Signature ( template ) == null ) { return _ BOOL ; } if ( get Method Body ( template ) == null ) { return _ BOOL ; } return _ BOOL ; }
public  Char Buffer append ( char [ ] buffer , int offset , int len ) { int length = length ( ) ; ensure Capacity ( length + len ) ;  System . arraycopy ( buffer , offset , buffer ( ) , length , len ) ; length ( length + len ) ; return this ; }
public boolean can Find All ( ) { return _ BOOL ; }
public static boolean read Boolean ( ) {  String s = read String ( ) ; if ( s . equals Ignore Case ( _ STR ) ) return _ BOOL ; if ( s . equals Ignore Case ( _ STR ) ) return _ BOOL ; if ( s . equals ( _ STR ) ) return _ BOOL ; if ( s . equals ( _ STR ) ) return _ BOOL ; throw new  Input Mismatch Exception ( ) ; }
@  Override public boolean e Is Set ( int feature ID ) { switch ( feature ID ) { case  Functionblock Package .  OPERATION__ NAME : return  NAME_ EDEFAULT == null ? name != null : !  NAME_ EDEFAULT . equals ( name ) ; case  Functionblock Package .  OPERATION__ PARAMS : return params != null && ! params . is Empty ( ) ; case  Functionblock Package .  OPERATION__ RETURN_ TYPE : return return Type != null ; case  Functionblock Package .  OPERATION__ DESCRIPTION : return  DESCRIPTION_ EDEFAULT == null ? description != null : !  DESCRIPTION_ EDEFAULT . equals ( description ) ; case  Functionblock Package .  OPERATION__ BREAKABLE : return breakable !=  BREAKABLE_ EDEFAULT ; } return super . e Is Set ( feature ID ) ; }
private void initialize Raw Source Code Map (  String raw Source ) { raw Source Code With Line = new  Linked Hash Map < > ( ) ; int line Number = _ NUM ;  String Reader sr = new  String Reader ( raw Source ) ;  Buffered Reader br = new  Buffered Reader ( sr ) ;  String line ; try { while ( ( line = br . read Line ( ) ) != null ) { if (  String Utils . is Not Blank ( line ) ) { raw Source Code With Line . put ( line Number , line ) ; line Number ++ ; } } } catch (  IOException ex ) {  LOGGER . error ( _ STR + ex . get Message ( ) ) ; } }
public static <  U >  Function <  U ,  Predicate <  U > > not Self ( ) { return null ; }
private void record Visit Field (  Object object ,  Field object Field ,  Field field ) {  Map <  String ,  Set <  String > > bag = visited Fields . get ( object ) ; if ( bag == null ) { bag = new  Hash Map < > ( ) ; visited Fields . put ( object , bag ) ; }  Set <  String > fields = bag . get ( object Field ) ;  String object Filed Key = object Field == null ? _ STR : object Field . to Generic String ( ) ; if ( fields == null ) { fields = new  Hash Set < > ( ) ; bag . put ( object Filed Key , fields ) ; } fields . add ( field . to Generic String ( ) ) ; }
public boolean add To Completed List (  Download Info Runnable download Info Runnable ) { return m Completed List . add ( download Info Runnable ) ; }
protected void add Shingled Phrase Queries ( final  Boolean Query .  Builder main Query , final  List <  Clause > clauses , final  Collection <  Field Params > fields , int shingle Size , final float tiebreaker , final int slop ) throws  Syntax Error { if ( null == fields || fields . is Empty ( ) || null == clauses || clauses . size ( ) < shingle Size ) return ; if ( _ NUM == shingle Size ) shingle Size = clauses . size ( ) ; final int last Clause Index = shingle Size - _ NUM ;  String Builder user Phrase Query = new  String Builder ( ) ; for ( int i = _ NUM ; i < clauses . size ( ) - last Clause Index ; i ++ ) { user Phrase Query . append ( _ STR ) ; for ( int j = _ NUM ; j <= last Clause Index ; j ++ ) { user Phrase Query . append ( clauses . get ( i + j ) . val ) ; user Phrase Query . append ( _ STR ) ; } user Phrase Query . append ( _ STR ) ; user Phrase Query . append ( _ STR ) ; }  Extended Solr Query Parser pp = create Edismax Query Parser ( this ,  IMPOSSIBLE_ FIELD_ NAME ) ; pp . add Alias (  IMPOSSIBLE_ FIELD_ NAME , tiebreaker , get Field Boosts ( fields ) ) ; pp . set Phrase Slop ( slop ) ; pp . set Remove Stop Filter ( _ BOOL ) ; pp . make Dismax = _ BOOL ; pp . min Clause Size = _ NUM ;  Query phrase = pp . parse ( user Phrase Query . to String ( ) ) ; if ( phrase != null ) { main Query . add ( phrase ,  Boolean Clause .  Occur .  SHOULD ) ; } }
public static  String encode Base64 ( byte [ ] input ) { return  Datatype Converter . print Base64 Binary ( input ) ; }
@  Override public void on Update Scrollbar ( int dy ) {  List <  Alphabetical Apps List .  Adapter Item > items = m Apps . get Adapter Items ( ) ; if ( items . is Empty ( ) || m Num Apps Per Row == _ NUM ) { m Scrollbar . set Thumb Offset ( - _ NUM , - _ NUM ) ; return ; } int row Count = m Apps . get Num App Rows ( ) ; get Cur Scroll State ( m Scroll Pos State , - _ NUM ) ; if ( m Scroll Pos State . row Index < _ NUM ) { m Scrollbar . set Thumb Offset ( - _ NUM , - _ NUM ) ; return ; } int available Scroll Bar Height = get Available Scroll Bar Height ( ) ; int available Scroll Height = get Available Scroll Height ( m Apps . get Num App Rows ( ) ) ; if ( available Scroll Height <= _ NUM ) { m Scrollbar . set Thumb Offset ( - _ NUM , - _ NUM ) ; return ; } int scroll Y = get Scroll Top ( m Scroll Pos State ) ; int scroll Bar Y = m Background Padding . top + ( int ) ( ( ( float ) scroll Y / available Scroll Height ) * available Scroll Bar Height ) ; if ( m Scrollbar . is Thumb Detached ( ) ) { int scroll Bar X ; if (  Utilities . is Rtl ( get Resources ( ) ) ) { scroll Bar X = m Background Padding . left ; } else { scroll Bar X = get Width ( ) - m Background Padding . right - m Scrollbar . get Thumb Width ( ) ; } if ( m Scrollbar . is Dragging Thumb ( ) ) { m Scrollbar . set Thumb Offset ( scroll Bar X , ( int ) m Scrollbar . get Last Touch Y ( ) ) ; } else { int thumb Scroll Y = m Scrollbar . get Thumb Offset ( ) . y ; int diff Scroll Y = scroll Bar Y - thumb Scroll Y ; if ( diff Scroll Y * dy > _ NUM ) { if ( dy < _ NUM ) { int offset = ( int ) ( ( dy * thumb Scroll Y ) / ( float ) scroll Bar Y ) ; thumb Scroll Y +=  Math . max ( offset , diff Scroll Y ) ; } else { int offset = ( int ) ( ( dy * ( available Scroll Bar Height - thumb Scroll Y ) ) / ( float ) ( available Scroll Bar Height - scroll Bar Y ) ) ; thumb Scroll Y +=  Math . min ( offset , diff Scroll Y ) ; } thumb Scroll Y =  Math . max ( _ NUM ,  Math . min ( available Scroll Bar Height , thumb Scroll Y ) ) ; m Scrollbar . set Thumb Offset ( scroll Bar X , thumb Scroll Y ) ; if ( scroll Bar Y == thumb Scroll Y ) { m Scrollbar . reattach Thumb To Scroll ( ) ; } } else { m Scrollbar . set Thumb Offset ( scroll Bar X , thumb Scroll Y ) ; } } } else { synchronize Scroll Bar Thumb Offset To View Scroll ( m Scroll Pos State , row Count ) ; } }
protected static  String resolve Snapshot Name (  Snapshot snapshot ) {  String persisted Name = resolve Name ( snapshot , null ) ; if ( persisted Name != null ) return persisted Name ;  File file = snapshot . get File ( ) ; if ( file == null ) return snapshot . to String ( ) ;  String file Name = file . get Name ( ) ;  Snapshot Category category = snapshot . get Category ( ) ;  String name = _ STR + category . get Prefix ( ) + _ STR + file Name ; if ( category . is Snapshot ( file ) ) {  String time Stamp = category . get Time Stamp ( file Name ) ; if ( time Stamp != null ) name = _ STR + category . get Prefix ( ) + _ STR + time Stamp ; } return name ; }
private void process Sync ( ) throws  Replicator Exception ,  IOException ,  Interrupted Exception {  Collection <  Log File > log Files = log File Map . values ( ) ; for (  Log File log File : log Files ) { log File . flush ( ) ; } }
public static  Map <  String ,  Map <  String ,  Map <  String ,  Object > > > prepare Field (  Map <  String , ? > input Fields ,  Map <  String ,  Object > query String Map ,  Map <  String ,  List <  Object [ ] > > orig Value Map ) {  Map <  String ,  Map <  String ,  Map <  String ,  Object > > > normalized Fields = new  Linked Hash Map <  String ,  Map <  String ,  Map <  String ,  Object > > > ( ) ; for (  String field Name Raw : input Fields . key Set ( ) ) {  String field Name Root = null ;  String field Pair = null ;  Object field Value = null ; int i Pos = - _ NUM ; int i Pos2 = - _ NUM ;  Map <  String ,  Map <  String ,  Object > > sub Map = null ;  Map <  String ,  Object > sub Map2 = null ;  String field Mode = null ; field Value = input Fields . get ( field Name Raw ) ; if (  Object Type . is Empty ( field Value ) ) { continue ; } query String Map . put ( field Name Raw , field Value ) ; i Pos = field Name Raw . index Of ( _ STR ) ; if ( i Pos >= _ NUM ) {  String suffix = field Name Raw . substring ( i Pos + _ NUM ) ; i Pos2 = suffix . index Of ( _ STR ) ; if ( i Pos2 == _ NUM ) { continue ; } } if ( i Pos < _ NUM ) { field Name Root = field Name Raw ; field Pair = _ STR ; field Mode = _ STR ; } else { field Name Root = field Name Raw . substring ( _ NUM , i Pos ) ;  String suffix = field Name Raw . substring ( i Pos + _ NUM ) ; i Pos2 = suffix . index Of ( _ STR ) ; if ( i Pos2 < _ NUM ) { if ( suffix . starts With ( _ STR ) ) { field Pair = suffix ; field Mode = _ STR ; } else { field Pair = _ STR ; field Mode = suffix ; } } else {  String tkn0 = suffix . substring ( _ NUM , i Pos2 ) ;  String tkn1 = suffix . substring ( i Pos2 + _ NUM ) ; if ( tkn0 . starts With ( _ STR ) ) { field Pair = tkn0 ; field Mode = tkn1 ; } else { field Pair = tkn1 ; field Mode = tkn0 ; } } } sub Map = normalized Fields . get ( field Name Root ) ; if ( sub Map == null ) { sub Map = new  Linked Hash Map <  String ,  Map <  String ,  Object > > ( ) ; normalized Fields . put ( field Name Root , sub Map ) ; } sub Map2 = sub Map . get ( field Pair ) ; if ( sub Map2 == null ) { sub Map2 = new  Linked Hash Map <  String ,  Object > ( ) ; sub Map . put ( field Pair , sub Map2 ) ; } sub Map2 . put ( field Mode , field Value ) ;  List <  Object [ ] > orig List = orig Value Map . get ( field Name Root ) ; if ( orig List == null ) { orig List = new  Linked List <  Object [ ] > ( ) ; orig Value Map . put ( field Name Root , orig List ) ; }  Object [ ] orig Values = { field Name Raw , field Value } ; orig List . add ( orig Values ) ; } return normalized Fields ; }
public  Builder delete Name ( ) { delete Fields . add ( _ STR ) ; return this ; }
protected void process Play Request ( ) { try To Get Audio Focus ( ) ; if ( m State ==  State .  STOPPED ) { play Media ( ) ; } else if ( m State ==  State .  PAUSED ) { m State =  State .  PLAYING ; set Up As Foreground (  String . format ( get String (  R . string . media_state_playing ) , m File . get File Name ( ) ) ) ; config And Start Media Player ( ) ; } }
public void find End Block ( ) throws  IOException { try {  String token ; do { token = read Token ( _ STR ) ; } while ( ! token . equals Ignore Case ( _ STR ) && ! token . equals Ignore Case ( _ STR ) ) ; } catch (  EOFException e ) { } next Block =  UNKNOWN_ BLOCK ; }
public int size ( ) { return urls . size ( ) ; }
public long skip ( long n ) throws  IOException { return f Input Stream . skip ( n ) ; }
private  Drawable create Shape ( int background Color , int stroke Color ) {  Gradient Drawable shape = new  Gradient Drawable ( ) ; shape . set Color ( background Color ) ; final float [ ] radius Array = new float [ _ NUM ] ;  Arrays . fill ( radius Array , radius ) ; if ( radius Top Left >= _ NUM ) { radius Array [ _ NUM ] = radius Top Left ; radius Array [ _ NUM ] = radius Top Left ; } if ( radius Top Right >= _ NUM ) { radius Array [ _ NUM ] = radius Top Right ; radius Array [ _ NUM ] = radius Top Right ; } if ( radius Bottom Right >= _ NUM ) { radius Array [ _ NUM ] = radius Bottom Right ; radius Array [ _ NUM ] = radius Bottom Right ; } if ( radius Bottom Left >= _ NUM ) { radius Array [ _ NUM ] = radius Bottom Left ; radius Array [ _ NUM ] = radius Bottom Left ; } shape . set Corner Radii ( radius Array ) ; shape . set Stroke ( stroke , stroke Color ) ; return shape ; }
public void add Group ( final  Group group ) { group . recursively Set Ids ( ) ; if ( group . is Top Level Group ( ) ) { group List . add ( group ) ; } fire Group Added ( group ) ; }
public void add (  Protocol protocol ) { if ( protocol List != null ) { protocol List . add ( protocol ) ; protocol . init ( user Connection ) ; } else { throw new  Null Pointer Exception ( _ STR ) ; } }
public static void tql2 ( int n , double [ ] d , double [ ] e , double [ ] [ ]  V ) { for ( int i = _ NUM ; i < n ; i ++ ) { e [ i - _ NUM ] = e [ i ] ; } e [ n - _ NUM ] = _ NUM ; double f = _ NUM ; double tst1 = _ NUM ; double eps =  Math . pow ( _ NUM , - _ NUM ) ; for ( int l = _ NUM ; l < n ; l ++ ) { tst1 =  Math . max ( tst1 ,  Math . abs ( d [ l ] ) +  Math . abs ( e [ l ] ) ) ; int m = l ; while ( m < n ) { if (  Math . abs ( e [ m ] ) <= eps * tst1 ) { break ; } m ++ ; } if ( m > l ) { int iter = _ NUM ; do { iter = iter + _ NUM ; double g = d [ l ] ; double p = ( d [ l + _ NUM ] - g ) / ( _ NUM * e [ l ] ) ; double r = hypot ( p , _ NUM ) ; if ( p < _ NUM ) { r = - r ; } d [ l ] = e [ l ] / ( p + r ) ; d [ l + _ NUM ] = e [ l ] * ( p + r ) ; double dl1 = d [ l + _ NUM ] ; double h = g - d [ l ] ; for ( int i = l + _ NUM ; i < n ; i ++ ) { d [ i ] -= h ; } f = f + h ; p = d [ m ] ; double c = _ NUM ; double c2 = c ; double c3 = c ; double el1 = e [ l + _ NUM ] ; double s = _ NUM ; double s2 = _ NUM ; for ( int i = m - _ NUM ; i >= l ; i -- ) { c3 = c2 ; c2 = c ; s2 = s ; g = c * e [ i ] ; h = c * p ; r = hypot ( p , e [ i ] ) ; e [ i + _ NUM ] = s * r ; s = e [ i ] / r ; c = p / r ; p = c * d [ i ] - s * g ; d [ i + _ NUM ] = h + s * ( c * g + s * d [ i ] ) ; for ( int k = _ NUM ; k < n ; k ++ ) { h =  V [ k ] [ i + _ NUM ] ;  V [ k ] [ i + _ NUM ] = s *  V [ k ] [ i ] + c * h ;  V [ k ] [ i ] = c *  V [ k ] [ i ] - s * h ; } } p = - s * s2 * c3 * el1 * e [ l ] / dl1 ; e [ l ] = s * p ; d [ l ] = c * p ; } while (  Math . abs ( e [ l ] ) > eps * tst1 ) ; } d [ l ] = d [ l ] + f ; e [ l ] = _ NUM ; } for ( int i = _ NUM ; i < n - _ NUM ; i ++ ) { int k = i ; double p = d [ i ] ; for ( int j = i + _ NUM ; j < n ; j ++ ) { if ( d [ j ] < p ) { k = j ; p = d [ j ] ; } } if ( k != i ) { d [ k ] = d [ i ] ; d [ i ] = p ; for ( int j = _ NUM ; j < n ; j ++ ) { p =  V [ j ] [ i ] ;  V [ j ] [ i ] =  V [ j ] [ k ] ;  V [ j ] [ k ] = p ; } } } }
public  Time random Time ( ) { if ( random . next Int ( _ NUM ) == _ NUM ) { return null ; }  String Builder buff = new  String Builder ( ) ; buff . append ( get Int ( _ NUM ) ) ; buff . append ( _ STR ) ; buff . append ( get Int ( _ NUM ) ) ; buff . append ( _ STR ) ; buff . append ( get Int ( _ NUM ) ) ; return  Time . value Of ( buff . to String ( ) ) ; }
public void add Parameter ( final  String parameter Name , final  String parameter Value ) {  LOG . trace ( _ STR ) ; final  Part param = new  String Part ( parameter Name , parameter Value ) ; parameters . add ( param ) ; }
public final  T end ( int i ) { while ( i -- > _ NUM && ! tag Stack . is Empty ( ) ) { end ( ) ; } return get Self ( ) ; }
private  Map <  Hive Object Spec ,  Table > create Table Lookup Map (  List <  Table > tables ) {  Map <  Hive Object Spec ,  Table > spec To Table = new  Hash Map < > ( ) ; for (  Table table : tables ) {  Hive Object Spec spec = new  Hive Object Spec ( table ) ; spec To Table . put ( spec , table ) ; } return spec To Table ; }
private void parse And Init Values (  String encoded Description ) { check Not Blank ( encoded Description , _ STR ) ;  String [ ] token =  TOKEN_ SEPARATOR_ PATTERN . split ( encoded Description ) ; check Argument ( token . length > _ NUM , _ STR ) ; int next Index = _ NUM ;  String next = token [ next Index ++ ] ;  Default Alignment alignment =  Default Alignment . value Of ( next , is Horizontal ( ) ) ; if ( alignment != null ) { set Default Alignment ( alignment ) ; check Argument ( token . length > _ NUM , _ STR ) ; next = token [ next Index ++ ] ; } set Size ( parse Size ( next ) ) ; if ( next Index < token . length ) { set Resize Weight ( parse Resize Weight ( token [ next Index ] ) ) ; } }
static <  T >  Unix Stream <  T > from ( final  Stream <  T > stream ) {  Objects . require Non Null ( stream , _ STR ) ; return new  Unix Stream Impl < > ( stream ) ; }
@  Override public void draw Item (  Graphics2 D g2 ,  XYItem Renderer State state ,  Rectangle2 D data Area ,  Plot Rendering Info info ,  XYPlot plot ,  Value Axis domain Axis ,  Value Axis range Axis ,  XYDataset dataset , int series , int item ,  Crosshair State crosshair State , int pass ) { if ( ! get Item Visible ( series , item ) ) { return ; } double x = dataset . get XValue ( series , item ) ; double y = dataset . get YValue ( series , item ) ; double adjx = ( this . dot Width - _ NUM ) / _ NUM ; double adjy = ( this . dot Height - _ NUM ) / _ NUM ; if ( !  Double . is Na N ( y ) ) {  Rectangle Edge x Axis Location = plot . get Domain Axis Edge ( ) ;  Rectangle Edge y Axis Location = plot . get Range Axis Edge ( ) ; double trans X = domain Axis . value To Java2 D ( x , data Area , x Axis Location ) - adjx ; double trans Y = range Axis . value To Java2 D ( y , data Area , y Axis Location ) - adjy ; g2 . set Paint ( get Item Paint ( series , item ) ) ;  Plot Orientation orientation = plot . get Orientation ( ) ; if ( orientation ==  Plot Orientation .  HORIZONTAL ) { g2 . fill Rect ( ( int ) trans Y , ( int ) trans X , this . dot Height , this . dot Width ) ; } else if ( orientation ==  Plot Orientation .  VERTICAL ) { g2 . fill Rect ( ( int ) trans X , ( int ) trans Y , this . dot Width , this . dot Height ) ; } int domain Axis Index = plot . get Domain Axis Index ( domain Axis ) ; int range Axis Index = plot . get Range Axis Index ( range Axis ) ; update Crosshair Values ( crosshair State , x , y , domain Axis Index , range Axis Index , trans X , trans Y , orientation ) ; } }
public void write Field (  String name , double value ) throws java . io .  IOException { write Field ( name ,  Double . to String ( value ) ) ; }
public void calculate Danger Level ( ) { int max Level = _ NUM ; int level Sum = _ NUM ; for (  Creature Respawn Point spawner : respawn Points ) {  Creature creature = spawner . get Prototype Creature ( ) ; if ( creature . is Rare ( ) ) { continue ; } int level = creature . get Level ( ) + _ NUM ; if ( level > _ NUM ) { continue ; } max Level =  Math . max ( level , max Level ) ; level Sum += level ; } int area = get Free Area ( ) + _ NUM ; double danger Level = max Level * ( _ NUM +  DANGER_ WEIGHT_ CREATURE_ DENSITY * ( level Sum - max Level ) / max Level /  Math . sqrt ( area ) ) - _ NUM ; if ( max Level > _ NUM ) { if ( attributes == null ) { attributes = new  Zone Attributes ( this ) ; } attributes . put ( _ STR ,  Double . to String ( danger Level ) ) ; } }
public void after (  Property Info Rest Rep old Props ,  Property Info Rest Rep new Props ) { }
@  Override @  Graph Transaction public void delete Trait (  String guid ,  String trait Name To Be Deleted ) throws  Trait Not Found Exception ,  Entity Not Found Exception ,  Repository Exception {  LOG . debug ( _ STR , trait Name To Be Deleted , guid ) ;  Atlas Vertex instance Vertex = graph Helper . get Vertex For GUID ( guid ) ;  List <  String > trait Names =  Graph Helper . get Trait Names ( instance Vertex ) ; if ( ! trait Names . contains ( trait Name To Be Deleted ) ) { throw new  Trait Not Found Exception ( _ STR + trait Name To Be Deleted + _ STR + guid ) ; } try { final  String entity Type Name =  Graph Helper . get Type Name ( instance Vertex ) ;  String relationship Label =  Graph Helper . get Trait Label ( entity Type Name , trait Name To Be Deleted ) ;  Atlas Edge edge = graph Helper . get Edge For Label ( instance Vertex , relationship Label ) ; if ( edge != null ) { delete Handler . delete Edge Reference ( edge ,  Data Types .  Type Category .  TRAIT , _ BOOL , _ BOOL ) ; trait Names . remove ( trait Name To Be Deleted ) ; update Traits ( instance Vertex , trait Names ) ; } } catch (  Exception e ) { throw new  Repository Exception ( e ) ; } }
public void add Table (  Table table ) { tables . add ( table ) ; }
void save Offset In External Store (  String topic , int partition , long offset ) { try {  File Writer writer = new  File Writer ( storage Name ( topic , partition ) , _ BOOL ) ;  Buffered Writer buffered Writer = new  Buffered Writer ( writer ) ; buffered Writer . write ( offset + _ STR ) ; buffered Writer . flush ( ) ; buffered Writer . close ( ) ; } catch (  Exception e ) { e . print Stack Trace ( ) ; throw new  Runtime Exception ( e ) ; } }
public static  String slurp URLNo Exceptions (  URL u ) { try { return slurp URL ( u ) ; } catch (  Exception e ) { e . print Stack Trace ( ) ; return null ; } }
protected synchronized void stop Loading ( ) { if ( loader Thread != null ) { loader Thread . interrupt ( ) ; } else { set Load Abort Request ( ) ; } }
public synchronized void remove (  String item ) { int index = items . index Of ( item ) ; if ( index < _ NUM ) { throw new  Illegal Argument Exception ( _ STR + item + _ STR ) ; } else { remove ( index ) ; } }
public void add Attribute (  String alias ,  String type Uri ,  String value ) throws  Message Exception { if ( alias . index Of ( _ STR ) > - _ NUM || alias . index Of ( _ STR ) > - _ NUM || alias . index Of ( _ STR ) > - _ NUM || alias . index Of ( _ STR ) > - _ NUM ) throw new  Message Exception ( _ STR + alias ) ; int count = get Count ( alias ) ;  String index = _ STR ; switch ( count ) { case _ NUM : _parameters . set ( new  Parameter ( _ STR + alias , type Uri ) ) ; break ; case _ NUM : _parameters . set ( new  Parameter ( _ STR + alias + _ STR , get Parameter Value ( _ STR + alias ) ) ) ; _parameters . remove Parameters ( _ STR + alias ) ; index = _ STR ; break ; default : index = _ STR +  Integer . to String ( count + _ NUM ) ; } _parameters . set ( new  Parameter ( _ STR + alias + index , value ) ) ; set Count ( alias , ++ count ) ; if (  DEBUG ) _log . debug ( _ STR + type Uri + _ STR + alias + _ STR + count ) ; }
protected void execute Tasks ( final  Access Path Task [ ] tasks ) throws  Exception { if ( executor == null ) { for (  Access Path Task task : tasks ) { task . call ( ) ; } return ; } final  List <  Future Task <  Void > > future Tasks = new  Linked List <  Future Task <  Void > > ( ) ; for (  Access Path Task task : tasks ) { final  Future Task <  Void > ft = new  Future Task <  Void > ( task ) ; future Tasks . add ( ft ) ; } try { for (  Future Task <  Void > ft : future Tasks ) { if ( halt ) throw new  Runtime Exception ( first Cause . get ( ) ) ; executor . execute ( ft ) ; } for (  Future Task <  Void > ft : future Tasks ) { if ( ! halt ) ft . get ( ) ; } } finally { for (  Future Task <  Void > ft : future Tasks ) { ft . cancel ( _ BOOL ) ; } } }
public  Ansible Runner extra Params (  String params ) { if ( params != null && params . length ( ) > _ NUM ) { extra Params = params ; } return this ; }
static private  String user Id From Range With Mod (  String [ ] values , boolean include ) { int min Id =  Integer . parse Int ( values [ _ NUM ] ) ; int max Id =  Integer . parse Int ( values [ _ NUM ] ) ; int mod =  Integer . parse Int ( values [ _ NUM ] ) ;  Stack <  Integer > stack = get Stack With Mods ( min Id , max Id , mod , include ) ; if ( stack . size ( ) > _ NUM ) { return  Integer . to String ( stack . pop ( ) ) ; } throw new  Illegal Argument Exception ( _ STR ) ; }
public synchronized boolean is Started ( ) { return m Started ; }
public static void write Parity Flag ( final  ITranslation Environment environment , final long offset , final  Operand Size result Size , final  String result , final  List <  Reil Instruction > instructions ) throws  Illegal Argument Exception {  Preconditions . check Not Null ( environment , _ STR ) ;  Preconditions . check Not Null ( result Size , _ STR ) ;  Preconditions . check Not Null ( result , _ STR ) ;  Preconditions . check Not Null ( instructions , _ STR ) ; final  String temp Reg = environment . get Next Variable String ( ) ; instructions . add (  Reil Helpers . create Str ( offset , result Size , result , result Size , temp Reg ) ) ; instructions . add (  Reil Helpers . create Bsh ( offset + _ NUM , result Size , temp Reg ,  Operand Size .  BYTE , _ STR , result Size ,  Helpers .  PARITY_ FLAG ) ) ; instructions . add (  Reil Helpers . create Xor ( offset + _ NUM , result Size , temp Reg , result Size ,  Helpers .  PARITY_ FLAG , result Size ,  Helpers .  PARITY_ FLAG ) ) ; instructions . add (  Reil Helpers . create And ( offset + _ NUM , result Size ,  Helpers .  PARITY_ FLAG , result Size ,  String . value Of ( _ NUM ) ,  Operand Size .  WORD ,  Helpers .  PARITY_ FLAG ) ) ; instructions . add (  Reil Helpers . create Bsh ( offset + _ NUM ,  Operand Size .  WORD ,  String . value Of ( _ NUM ) ,  Operand Size .  WORD ,  Helpers .  PARITY_ FLAG ,  Operand Size .  WORD ,  Helpers .  PARITY_ FLAG ) ) ; instructions . add (  Reil Helpers . create And ( offset + _ NUM ,  Operand Size .  WORD ,  Helpers .  PARITY_ FLAG ,  Operand Size .  WORD ,  String . value Of ( _ NUM ) ,  Operand Size .  WORD ,  Helpers .  PARITY_ FLAG ) ) ; instructions . add (  Reil Helpers . create Bsh ( offset + _ NUM ,  Operand Size .  WORD ,  Helpers .  PARITY_ FLAG ,  Operand Size .  BYTE , _ STR ,  Operand Size .  BYTE ,  Helpers .  PARITY_ FLAG ) ) ; }
public void add Graph ( final  Graph graph ) { if ( graph == null ) { throw new  Illegal Argument Exception ( _ STR ) ; } graphs . add ( graph ) ; }
public boolean check For Type (  Types type ) { if ( types == null ) { return _ BOOL ; } else { return types . contains ( type . to String ( ) ) ; } }
public static void load Excludes Resource (  String resource Name ) throws  IOException { excludes . clear ( ) ; excludes . put All ( load Properties From Resource ( resource Name ) ) ; }
public static void safe Close (  Input Stream in ) { try { if ( in != null ) in . close ( ) ; } catch (  IOException e ) { } }
private boolean is In Transaction ( ) { return transaction != null ; }
public char skip Until (  String skip ) throws  IOException { char ch ; do { ch = read Character ( ) ; } while ( skip . index Of ( ch ) == - _ NUM ) ; return ch ; }
public static long generate ( long hash , int key ) { final long m = _ NUM ; final int r = _ NUM ; int length = _ NUM ; hash ^= length * m ; hash ^=  Integer . reverse Bytes ( key ) ; hash *= m ; hash ^= hash > > > r ; hash *= m ; hash ^= hash > > > r ; return hash ; }
public void sync Download Poi Box ( final  Box box ) { if (  Flavor Utils . is Poi Storage ( ) ) { sync Download Poi Types ( ) ; }  List <  Poi > pois = backend . get Pois In Box ( box ) ; if ( pois . size ( ) > _ NUM ) {  Timber . d ( _ STR , pois . size ( ) ) ; poi Manager . merge From Osm Pois ( pois , box ) ; } else {  Timber . d ( _ STR ) ; } }
private void create Element (  Document doc ,  Element parent Element ,  String element Name , int value ) {  Element element = doc . create Element ( element Name ) ; element . append Child ( doc . create Text Node (  Integer . to String ( value ) ) ) ; parent Element . append Child ( element ) ; }
public static void to Do ( @  Scope int scope ,  String tag ) {  List <  Long > tag Seen List = tag Last Seen Map . get ( tag ) ; if ( tag Seen List . is Empty ( ) ) { to Do Set . put ( tag ) ; return ; }  Long tag Last Seen = tag Seen List . get ( tag Seen List . size ( ) - _ NUM ) ; if ( scope ==  THIS_ APP_ VERSION && tag Last Seen <= last App Updated Time ) { to Do Set . put ( tag ) ; } }
void variable Negation Changed ( int row ,  String oper ) {  Conditional Variable variable = _variable List . get ( row ) ; boolean state = variable . is Negated ( ) ; if ( oper == null ) { variable . set Negation ( _ BOOL ) ; } else { variable . set Negation ( oper . equals (  Bundle . get Message ( _ STR ) ) ) ; } if ( variable . is Negated ( ) != state ) { make Antecedent ( ) ; } }
public  Mock Response add Header (  String name ,  Object value ) { return add Header ( name + _ STR +  String . value Of ( value ) ) ; }
public  Round Robin Redis Pool ( final  List <  Redis > redis Servers ) {  Preconditions . check Not Null ( redis Servers ) ;  Preconditions . check Argument ( redis Servers . size ( ) > _ NUM ) ; this . redis Servers = redis Servers ; this . redis Pool Iterator = redis Servers . iterator ( ) ; }
public boolean is Hidden File (  File f ) { return f . is Hidden ( ) ; }
public static boolean delete Recursive (  File file Or Directory ) { if ( file Or Directory . is Directory ( ) ) {  File [ ] list = file Or Directory . list Files ( ) ; if ( list == null ) { return _ BOOL ; } for (  File f : list ) { if ( ! delete Recursive ( f ) ) { return _ BOOL ; } } } if ( ! file Or Directory . delete ( ) ) { if ( file Or Directory . exists ( ) ) { return _ BOOL ; } } return _ BOOL ; }
boolean is Tool Bar Button (  JComponent c ) { return ( c . get Parent ( ) instanceof  JTool Bar ) ; }
private  Priority Queue <  Score Term > create Queue (  Map <  String ,  Int > words ,  String ... field Names ) throws  IOException { int num Docs = ir . num Docs ( ) ; final int limit =  Math . min ( max Query Terms , words . size ( ) ) ;  Freq Q queue = new  Freq Q ( limit ) ; for (  String word : words . key Set ( ) ) { int tf = words . get ( word ) . x ; if ( min Term Freq > _ NUM && tf < min Term Freq ) { continue ; }  String top Field = field Names [ _ NUM ] ; int doc Freq = _ NUM ; for (  String field Name : field Names ) { int freq = ir . doc Freq ( new  Term ( field Name , word ) ) ; top Field = ( freq > doc Freq ) ? field Name : top Field ; doc Freq = ( freq > doc Freq ) ? freq : doc Freq ; } if ( min Doc Freq > _ NUM && doc Freq < min Doc Freq ) { continue ; } if ( doc Freq > max Doc Freq ) { continue ; } if ( doc Freq == _ NUM ) { continue ; } float idf = similarity . idf ( doc Freq , num Docs ) ; float score = tf * idf ; if ( queue . size ( ) < limit ) { queue . add ( new  Score Term ( word , top Field , score , idf , doc Freq , tf ) ) ; } else {  Score Term term = queue . top ( ) ; if ( term . score < score ) { term . update ( word , top Field , score , idf , doc Freq , tf ) ; queue . update Top ( ) ; } } } return queue ; }
private void read Object (  Object Input Stream ois ) throws  Class Not Found Exception ,  IOException { ois . default Read Object ( ) ; int size = ois . read Int ( ) ; index = new  Concurrent Hash Index < > ( size ) ; for ( int i = _ NUM ; i < size ; ++ i ) { index . add ( ois . read UTF ( ) ) ; } }
public void exit ( int status ) {  System . exit ( status ) ; }
protected boolean is Outside (  Mutable Coord  P1 ,  Mutable Coord  P2 ,  Mutable Coord  P3 ) { double minx =  Math . min (  P1 . get X ( ) ,  P2 . get X ( ) ) , miny =  Math . min (  P1 . get Y ( ) ,  P2 . get Y ( ) ) ; double maxx =  Math . max (  P1 . get X ( ) ,  P2 . get X ( ) ) , maxy =  Math . max (  P1 . get Y ( ) ,  P2 . get Y ( ) ) ; double x =  P3 . get X ( ) , y =  P3 . get Y ( ) ; if ( x >= minx && x <= maxx && y >= miny && y <= maxy ) return _ BOOL ; else return _ BOOL ; }
@  Override public void process Challenge ( final  String challenge ) throws  Malformed Challenge Exception { final  String s =  Auth Challenge Parser . extract Scheme ( challenge ) ; if ( ! s . equals Ignore Case ( get Scheme Name ( ) ) ) { throw new  Malformed Challenge Exception ( _ STR + get Scheme Name ( ) + _ STR + challenge ) ; } params =  Auth Challenge Parser . extract Params ( challenge ) ; }
public static  Big Integer calculate Gx (  Big Integer p ,  Big Integer g ,  Big Integer x ) { return g . mod Pow ( x , p ) ; }
public static boolean create Shipment (  MAcct Schema as , int  AD_ Org_ ID , int  M_ Product_ ID , int  M_ Attribute Set Instance_ ID , int  M_ In Out Line_ ID , int  M_ Cost Element_ ID ,  Big Decimal  Amt ,  Big Decimal  Qty ,  String  Description , boolean  Is SOTrx ,  String trx Name ) {  String sql = _ STR + _ STR + _ STR +  M_ In Out Line_ ID + _ STR + as . get C_ Acct Schema_ ID ( ) + _ STR +  M_ Attribute Set Instance_ ID ; int no =  DB . execute Update ( sql , trx Name ) ; if ( no != _ NUM ) s_log . config ( _ STR + no ) ;  MCost Detail cd = get ( as . get Ctx ( ) , _ STR ,  M_ In Out Line_ ID ,  M_ Attribute Set Instance_ ID , as . get C_ Acct Schema_ ID ( ) , trx Name ) ; if ( cd == null ) { cd = new  MCost Detail ( as ,  AD_ Org_ ID ,  M_ Product_ ID ,  M_ Attribute Set Instance_ ID ,  M_ Cost Element_ ID ,  Amt ,  Qty ,  Description , trx Name ) ; cd . set M_ In Out Line_ ID (  M_ In Out Line_ ID ) ; cd . set Is SOTrx (  Is SOTrx ) ; } else { cd . set Delta Amt (  Amt . subtract ( cd . get Amt ( ) ) ) ; cd . set Delta Qty (  Qty . subtract ( cd . get Qty ( ) ) ) ; if ( cd . is Delta ( ) ) { cd . set Processed ( _ BOOL ) ; cd . set Amt (  Amt ) ; cd . set Qty (  Qty ) ; } else return _ BOOL ; } boolean ok = cd . save ( ) ; if ( ok && ! cd . is Processed ( ) ) {  MClient client =  MClient . get ( as . get Ctx ( ) , as . get AD_ Client_ ID ( ) ) ; if ( client . is Cost Immediate ( ) ) cd . process ( ) ; } s_log . config ( _ STR + ok + _ STR + cd ) ; return ok ; }
public void do Undo ( ) { if ( undo . can Undo ( ) ) { undo . undo ( ) ; parse ( ) ; } }
public  String to Mutil Line String ( ) { final  String new Line =  System . get Property ( _ STR ) ; final  String Buffer problem Str = new  String Buffer ( ) ; for ( final  Problem problem : this . problems ) { problem Str . append ( problem . get Message ( ) + new Line ) ; } return problem Str . to String ( ) ; }
public  List <  Snapshot > snapshots (  String repository Name ) {  Set <  Snapshot > snapshot Set = new Hash Set ( ) ;  List <  Snapshots In Progress .  Entry > entries = current Snapshots ( repository Name , null ) ; for (  Snapshots In Progress .  Entry entry : entries ) { snapshot Set . add ( in Progress Snapshot ( entry ) ) ; }  Repository repository = repositories Service . repository ( repository Name ) ;  List <  Snapshot Id > snapshot Ids = repository . snapshots ( ) ; for (  Snapshot Id snapshot Id : snapshot Ids ) { snapshot Set . add ( repository . read Snapshot ( snapshot Id ) ) ; }  Array List <  Snapshot > snapshot List = new  Array List < > ( snapshot Set ) ;  Collection Util . tim Sort ( snapshot List ) ; return  Collections . unmodifiable List ( snapshot List ) ; }
public boolean has Static Method Call (  String owner ,  String method Name ,  String target Class ,  String target Method ) {  Static Method Call Entry call = new  Static Method Call Entry ( owner , method Name , target Class , target Method ) ; return static Method Calls . contains ( call ) ; }
@  Override protected void paint Tab Border (  Graphics g , int tab Placement , int tab Index , int x , int y , int w , int h , boolean is Selected ) { g . set Color ( is Selected ? dark Shadow : shadow ) ; switch ( tab Placement ) { case  LEFT : g . draw Line ( x + _ NUM , y + h - _ NUM , x + _ NUM , y + h - _ NUM ) ; g . draw Line ( x , y + _ NUM , x , y + h - _ NUM ) ; g . draw Line ( x + _ NUM , y + _ NUM , x + _ NUM , y + _ NUM ) ; g . draw Line ( x + _ NUM , y , x + w - _ NUM , y ) ; g . draw Line ( x + _ NUM , y + h - _ NUM , x + w - _ NUM , y + h - _ NUM ) ; g . draw Line ( x + _ NUM , y + h - _ NUM , x + w - _ NUM , y + h - _ NUM ) ; break ; case  RIGHT : g . draw Line ( x , y , x + w - _ NUM , y ) ; g . draw Line ( x , y + h - _ NUM , x + w - _ NUM , y + h - _ NUM ) ; g . draw Line ( x + w - _ NUM , y + _ NUM , x + w - _ NUM , y + h - _ NUM ) ; g . draw Line ( x + w - _ NUM , y + _ NUM , x + w - _ NUM , y + _ NUM ) ; g . draw Line ( x + w - _ NUM , y + h - _ NUM , x + w - _ NUM , y + h - _ NUM ) ; g . draw Line ( x + w - _ NUM , y + _ NUM , x + w - _ NUM , y + h - _ NUM ) ; g . draw Line ( x , y + h - _ NUM , x + w - _ NUM , y + h - _ NUM ) ; break ; case  BOTTOM : g . draw Line ( x , y , x , y + h - _ NUM ) ; g . draw Line ( x + _ NUM , y + h - _ NUM , x + w - _ NUM , y + h - _ NUM ) ; g . draw Line ( x + w - _ NUM , y , x + w - _ NUM , y + h - _ NUM ) ; break ; case  TOP : default : g . draw Line ( x , y + _ NUM , x , y + h - _ NUM ) ; g . draw Line ( x + _ NUM , y + _ NUM , x + _ NUM , y + _ NUM ) ; g . draw Line ( x + _ NUM , y , x + w - _ NUM , y ) ; g . draw Line ( x + w - _ NUM , y + _ NUM , x + w - _ NUM , y + h - _ NUM ) ; g . draw Line ( x + w - _ NUM , y + _ NUM , x + w - _ NUM , y + h - _ NUM ) ; g . draw Line ( x + w - _ NUM , y + _ NUM , x + w - _ NUM , y + _ NUM ) ; } }
public static  Bytes Ref to Bytes Ref (  Object value ) { if ( value == null ) { return null ; } if ( value instanceof  Bytes Ref ) { return (  Bytes Ref ) value ; } return new  Bytes Ref ( value . to String ( ) ) ; }
protected  Range find Domain Bounds (  XYDataset dataset , boolean include Interval ) { if ( dataset == null ) { return null ; } if ( get Data Bounds Includes Visible Series Only ( ) ) {  List visible Series Keys = new  Array List ( ) ; int series Count = dataset . get Series Count ( ) ; for ( int s = _ NUM ; s < series Count ; s ++ ) { if ( is Series Visible ( s ) ) { visible Series Keys . add ( dataset . get Series Key ( s ) ) ; } } return  Dataset Utilities . find Domain Bounds ( dataset , visible Series Keys , include Interval ) ; } return  Dataset Utilities . find Domain Bounds ( dataset , include Interval ) ; }
public boolean is Shutdown ( ) { return shutdown . get ( ) ; }
public void remove Role (  AMRole role ) throws  AMException ,  SSOException { remove Role ( role . get DN ( ) ) ; }
protected void write Styles (  List styles ) throws  IOException { int num Styles = ( styles != null ) ? styles . size ( ) : _ NUM ; if ( num Styles < _ NUM ) { out . write UI8 ( num Styles ) ; } else { out . write UI8 ( _ NUM ) ; out . write UI16 ( num Styles ) ; } if ( styles != null ) { for (  Iterator enumumerator = styles . iterator ( ) ; enumumerator . has Next ( ) ; ) {  Style style = (  Style ) enumumerator . next ( ) ; style . write ( out , has Alpha ) ; } styles . clear ( ) ; } }
public static byte [ ] decode (  String data ) {  Byte Array Output Stream b Out = new  Byte Array Output Stream ( ) ; try { encoder . decode ( data , b Out ) ; } catch (  IOException e ) { throw new  Runtime Exception ( _ STR + e ) ; } return b Out . to Byte Array ( ) ; }
public void test_single Resource Locking_serialized_low Concurrency5 ( ) throws  Exception {  Properties properties = new  Properties ( ) ; properties . set Property (  Test Options .  NTHREADS , _ STR ) ; properties . set Property (  Test Options .  NTASKS , _ STR ) ; properties . set Property (  Test Options .  NRESOURCES , _ STR ) ; properties . set Property (  Test Options .  MIN_ LOCKS , _ STR ) ; properties . set Property (  Test Options .  MAX_ LOCKS , _ STR ) ; properties . set Property (  Test Options .  PREDECLARE_ LOCKS , _ STR ) ; properties . set Property (  Test Options .  SORT_ LOCK_ REQUESTS , _ STR ) ; do Comparison Test ( properties ) ; }
private static final void run (  Runnable runnable ) { runnable . run ( ) ; }
public void parse (  Input Source source ) throws  IOException { try { parser . parse ( source ) ; } catch (  SAXException e ) { throw new  IOException ( e ) ; } }
@  Override public void process Row (  Result Set result Set ) throws  SQLException {  String upi = result Set . get String ( _ NUM ) ;  String sequence = result Set . get String ( _ NUM ) ; if ( sequence == null || sequence . length ( ) == _ NUM ) { sequence = result Set . get String ( _ NUM ) ; } if ( sequence == null ) { throw new  Illegal Argument Exception ( _ STR ) ; } sequence Loader . store ( sequence , null , upi ) ; }
public void test Case20 ( ) { byte a Bytes [ ] = { _ NUM } ; byte b Bytes [ ] = { _ NUM } ; byte r Bytes [ ] = { _ NUM } ; int a Sign = _ NUM ; int b Sign = _ NUM ;  Big Integer a Number = new  Big Integer ( a Sign , a Bytes ) ;  Big Integer b Number = new  Big Integer ( b Sign , b Bytes ) ;  Big Integer result = a Number . subtract ( b Number ) ; byte res Bytes [ ] = new byte [ r Bytes . length ] ; res Bytes = result . to Byte Array ( ) ; for ( int i = _ NUM ; i < res Bytes . length ; i ++ ) { assert True ( res Bytes [ i ] == r Bytes [ i ] ) ; } assert Equals ( _ NUM , result . signum ( ) ) ; }
@  Nonnull public  Bug Instance add Class And Method (  Method Annotation method Annotation ) { add Class ( method Annotation . get Class Name ( ) ) ; add Method ( method Annotation ) ; return this ; }
protected  Abstract Format ( final  Number Format format ) { this ( format , (  Number Format ) format . clone ( ) ) ; }
public static int parse Title Map (  String s ) throws  Number Format Exception { int title Case =  MAP_ UNDEFINED ; int length = s . length ( ) ; if ( length >= _ NUM && length <= _ NUM ) { title Case =  Integer . parse Int ( s , _ NUM ) ; } else if ( s . length ( ) != _ NUM ) { throw new  Number Format Exception ( ) ; } return title Case ; }
@  Override public void run ( ) { while ( ! is Interrupted ( ) ) { try {  Value Holder <  K ,  V > ref = (  Value Holder <  K ,  V > ) _queue . remove ( ) ; _table . remove ( ref . get Key ( ) ) ; } catch (  Interrupted Exception e ) { interrupt ( ) ; break ; } } }
public void register Playlist Listener (  Cheerleader Playlist Listener listener ) { check State ( ) ; m Cheerleader Playlist Listeners . add ( listener ) ; }
private boolean can Read File (  File file ) { if ( ! file . exists ( ) ) { log . info ( _ STR + file . get Absolute Path ( ) + _ STR ) ; return _ BOOL ; } if ( ! file . can Read ( ) ) { log . info ( _ STR + file . get Absolute Path ( ) + _ STR ) ; return _ BOOL ; } return _ BOOL ; }
public  Pending Change prepare Add Row (  Object [ ] row ,  Row Id Impl row Id ,  Pending Change next Change ) throws  IOException { return prepare Add Row ( row , row Id , new  Add Row Pending Change ( next Change ) ) ; }
public org . smpte_ra . schemas . st2067_2_2013 .  Digest Method Type build Default Digest Method Type ( ) { org . smpte_ra . schemas . st2067_2_2013 .  Digest Method Type digest Method Type = new org . smpte_ra . schemas . st2067_2_2013 .  Digest Method Type ( ) ; digest Method Type . set Algorithm (  Composition Playlist Builder_2013 . default Hash Algorithm ) ; return digest Method Type ; }
public static <  V extends  Sampled Vertex >  Set <  V > create Sampled Partition (  Collection <  V > vertices , int iteration ) {  Set <  V > partition = new  Hash Set <  V > ( ) ; for (  V vertex : vertices ) { if ( vertex . is Sampled ( ) ) { if ( vertex . get Iteration Sampled ( ) == iteration ) partition . add ( vertex ) ; } } return partition ; }
public void add Graph ( final  Graph graph ) { if ( graph == null ) { throw new  Illegal Argument Exception ( _ STR ) ; } graphs . add ( graph ) ; }
public boolean can Accept Connection (  Class < ? > listener Class ) { for ( int i = _ NUM ; i < m_inputs . size ( ) ; i ++ ) {  Bean Instance input = (  Bean Instance ) m_inputs . element At ( i ) ; if ( listener Class . is Instance ( input . get Bean ( ) ) ) { return _ BOOL ; } } return _ BOOL ; }
private  List <  String > default Args ( ) {  List <  String > args = new  Array List <  String > ( ) ; args . add ( _ STR ) ; args . add ( _ STR ) ; args . add ( _ STR ) ; return args ; }
public void make Immutable ( ) { super . make Immutable ( ) ; }
@  Override void inserted Text (  Character Data Impl node , int offset , int count ) { if ( ranges != null ) { notify Ranges Inserted Text ( node , offset , count ) ; } }
public  Swarm ( ) throws  Exception { this (  Boolean . get Boolean (  Swarm Properties .  DEBUG_ BOOTSTRAP ) ) ; }
public static  String remove Last Delimiter (  String topic ) { if ( topic . ends With (  TOPIC_ DELIMITER ) ) { topic = topic . substring ( _ NUM , topic . length ( ) -  TOPIC_ DELIMITER . length ( ) ) ; } return topic ; }
public boolean is Simple Type Or Simple Object ( final  Field field ) {  Class < ? > type = field . get Type ( ) ; boolean simple Type = ( type . is Assignable From (  Short . class ) || type . is Assignable From (  Short .  TYPE ) || type . is Assignable From (  Integer . class ) || type . is Assignable From (  Integer .  TYPE ) || type . is Assignable From (  Float . class ) || type . is Assignable From (  Float .  TYPE ) || type . is Assignable From (  Double . class ) || type . is Assignable From (  Double .  TYPE ) || type . is Assignable From (  Long . class ) || type . is Assignable From (  Long .  TYPE ) || type . is Assignable From (  Byte . class ) || type . is Assignable From (  Byte .  TYPE ) || type . is Assignable From (  Character . class ) || type . is Assignable From (  Character .  TYPE ) || type . is Assignable From (  Boolean . class ) || type . is Assignable From (  Boolean .  TYPE ) || type . is Assignable From (  String . class ) ) || type . is Enum ( ) ; return simple Type ; }
public boolean has Invoices ( ) { boolean ret Value = _ BOOL ;  String sql = _ STR ;  Prepared Statement pstmt = null ; try { pstmt =  DB . prepare Statement ( sql , get_ Trx Name ( ) ) ; pstmt . set Int ( _ NUM , get_ ID ( ) ) ;  Result Set rs = pstmt . execute Query ( ) ; if ( rs . next ( ) ) { if ( rs . get Int ( _ NUM ) > _ NUM ) ret Value = _ BOOL ; } rs . close ( ) ; pstmt . close ( ) ; pstmt = null ; } catch (  Exception e ) { s_log . log (  Level .  SEVERE , sql , e ) ; } try { if ( pstmt != null ) pstmt . close ( ) ; pstmt = null ; } catch (  Exception e ) { pstmt = null ; } return ret Value ; }
public void close Socket ( ) { if ( m Socket != null ) { try { m Socket . close ( ) ; } catch (  IOException e ) { } } }
static boolean is Same Column (  Constraint Widget a ,  Constraint Widget b ) { return  Math . max ( a . get X ( ) , b . get X ( ) ) <  Math . min ( a . get X ( ) + a . get Width ( ) , b . get X ( ) + b . get Width ( ) ) ; }
public static void wait For Process Output (  Process self ,  Appendable output ,  Appendable error ) {  Thread tout = consume Process Output Stream ( self , output ) ;  Thread terr = consume Process Error Stream ( self , error ) ; try { tout . join ( ) ; } catch (  Interrupted Exception ignore ) { } try { terr . join ( ) ; } catch (  Interrupted Exception ignore ) { } try { self . wait For ( ) ; } catch (  Interrupted Exception ignore ) { } close Streams ( self ) ; }
Node <  V > find ( int h , long k ) {  Node <  V > e = this ; do { if ( ( e . key == k ) ) { return e ; } } while ( ( e = e . next ) != null ) ; return null ; }
@  Override public  Axis State draw (  Graphics2 D g2 , double cursor ,  Rectangle2 D plot Area ,  Rectangle2 D data Area ,  Rectangle Edge edge ,  Plot Rendering Info plot State ) { if ( ! is Visible ( ) ) { return new  Axis State ( cursor ) ; } if ( is Axis Line Visible ( ) ) { draw Axis Line ( g2 , cursor , data Area , edge ) ; }  Axis State state = new  Axis State ( cursor ) ; state = draw Sub Category Labels ( g2 , plot Area , data Area , edge , state , plot State ) ; state = draw Category Labels ( g2 , plot Area , data Area , edge , state , plot State ) ; if ( get Attributed Label ( ) != null ) { state = draw Attributed Label ( get Attributed Label ( ) , g2 , plot Area , data Area , edge , state ) ; } else { state = draw Label ( get Label ( ) , g2 , plot Area , data Area , edge , state ) ; } return state ; }
public void test Filter ( ) throws  IOException ,  Exception {  Array List <  URLCrawl Datum > list = new  Array List <  URLCrawl Datum > ( ) ; list . add ( create URLCrawl Datum ( _ STR , _ NUM , _ NUM ) ) ; list . add ( create URLCrawl Datum ( _ STR , _ NUM , _ NUM ) ) ; list . add ( create URLCrawl Datum ( _ STR , _ NUM , _ NUM ) ) ; create Crawl DB ( list ) ;  Configuration my Configuration = new  Configuration ( conf ) ; my Configuration . set ( _ STR , _ STR ) ;  Path generated Segment = generate Fetchlist (  Integer .  MAX_ VALUE , my Configuration , _ BOOL ) ; assert Null ( _ STR , generated Segment ) ; generated Segment = generate Fetchlist (  Integer .  MAX_ VALUE , my Configuration , _ BOOL ) ;  Path fetchlist Path = new  Path ( new  Path ( generated Segment ,  Crawl Datum .  GENERATE_ DIR_ NAME ) , _ STR ) ;  Array List <  URLCrawl Datum > fetch List = read Contents ( fetchlist Path ) ; assert Equals ( list . size ( ) , fetch List . size ( ) ) ; }
public static float next Random Float ( ) { return rand . next Float ( ) ; }
public boolean has Category (  String category ) { if ( category == null ) { return _ BOOL ; } return categories . contains (  String Util . to Lower Case ( category ) ) ; }
private boolean is Test Method (  Method m ) {  String name = m . get Name ( ) ;  Class [ ] parameters = m . get Parameter Types ( ) ;  Class return Type = m . get Return Type ( ) ; return parameters . length == _ NUM && name . starts With ( _ STR ) && return Type . equals (  Void .  TYPE ) ; }
public long to Seconds ( ) { return time Unit . to Seconds ( length ) ; }
public void dispose ( ) { log Debug ( _ STR ) ; m Setup Done = _ BOOL ; if ( m Service Conn != null ) { log Debug ( _ STR ) ; if ( m Context != null && m Service != null ) { try { m Context . unbind Service ( m Service Conn ) ; } catch (  Exception e ) { } } } m Disposed = _ BOOL ; m Context = null ; m Service Conn = null ; m Service = null ; m Purchase Listener = null ; }
public void remove CSPState Listener (  CSPState Listener listener ) { listeners . remove ( listener ) ; }
public  Text Output Callback ( int message Type ,  String message ) { if ( ( message Type !=  INFORMATION && message Type !=  WARNING && message Type !=  ERROR ) || message == null || message . length ( ) == _ NUM ) throw new  Illegal Argument Exception ( ) ; this . message Type = message Type ; this . message = message ; }
public boolean is Inside (  Entity entity ) { for (  Axis Aligned BB bounding Box : this . bounding Boxes ) { if ( bounding Box . is Vec Inside ( entity . get Position Vector ( ) ) ) { return _ BOOL ; } } return _ BOOL ; }
public void reset ( ) { last Mtd = null ; map . clear ( ) ; put Cnt . set ( _ NUM ) ; put All Cnt . set ( _ NUM ) ; rmv Cnt . set ( _ NUM ) ; rmv All Cnt . set ( _ NUM ) ; ts =  System . current Time Millis ( ) ; }
public synchronized void load ( ) throws  Exception { load ( get Conf File Name ( ) ) ; }
public static <  T >  List <  T > as List (  T ... values ) { if ( values == null ) { return new  Array List <  T > ( _ NUM ) ; } else { return new  Array List <  T > (  Arrays . as List ( values ) ) ; } }
public static void add Listener (  Listener listener ) { if ( ! listeners . contains ( listener ) ) listeners . add ( listener ) ; }
@  Request Mapping ( value = _ STR , method =  Request Method .  DELETE , produces =  Media Type .  APPLICATION_ JSON_ VALUE ) @  Timed @  Secured (  Authorities Constants .  ADMIN ) public  Response Entity <  Void > delete User ( @  Path Variable  String login ) { }
@  Override public  String to String ( ) {  String Builder sb = new  String Builder ( ) ; sb . append ( serial Number . to String ( ) ) ; sb . append ( _ STR + revocation Date . to String ( ) ) ; if ( cert Issuer != null ) { sb . append ( _ STR + cert Issuer ) ; } if ( extensions != null ) {  Collection <  Extension > all Entry Exts = extensions . get All Extensions ( ) ;  Extension [ ] exts = all Entry Exts . to Array ( new  Extension [ _ NUM ] ) ; sb . append ( _ STR + exts . length ) ; for ( int i = _ NUM ; i < exts . length ; i ++ ) { sb . append ( _ STR + ( i + _ NUM ) + _ STR ) ;  Extension ext = exts [ i ] ; try { if (  OIDMap . get Class ( ext . get Extension Id ( ) ) == null ) { sb . append ( ext . to String ( ) ) ; byte [ ] ext Value = ext . get Extension Value ( ) ; if ( ext Value != null ) {  Der Output Stream out = new  Der Output Stream ( ) ; out . put Octet String ( ext Value ) ; ext Value = out . to Byte Array ( ) ;  Hex Dump Encoder enc = new  Hex Dump Encoder ( ) ; sb . append ( _ STR + _ STR + enc . encode Buffer ( ext Value ) + _ STR ) ; } } else sb . append ( ext . to String ( ) ) ; } catch (  Exception e ) { sb . append ( _ STR ) ; } } } sb . append ( _ STR ) ; return sb . to String ( ) ; }
public  Builder delete Name ( ) { delete Fields . add ( _ STR ) ; return this ; }
public  Query limit ( int limit , int offset ) { return limit ( limit < _ NUM ?  NO_ LIMIT :  Field . <  Integer > field (  Integer . to String ( limit ) ) , offset < _ NUM ?  NO_ OFFSET :  Field . <  Integer > field (  Integer . to String ( offset ) ) ) ; }
public boolean file Exists ( ) {  File file = get Store File ( ) ; return file == null || file . exists ( ) ; }
public static boolean is Payment Type (  Generic Value payment ,  String input Type Id ) throws  Generic Entity Exception { if ( payment == null ) { return _ BOOL ; }  Generic Value payment Type = payment . get Related One ( _ STR , _ BOOL ) ; if ( payment Type == null ) { throw new  Generic Entity Exception ( _ STR + payment . get String ( _ STR ) ) ; }  String payment Type Id = payment Type . get String ( _ STR ) ; if ( input Type Id . equals ( payment Type Id ) ) { return _ BOOL ; } return is Payment Type Recurse ( payment Type , input Type Id ) ; }
public static  String convert Charset (  String source ,  String src Charset Name ,  String new Charset Name ) { if ( src Charset Name . equals ( new Charset Name ) ) { return source ; } try { return new  String ( source . get Bytes ( src Charset Name ) , new Charset Name ) ; } catch (  Unsupported Encoding Exception unex ) { throw new  Illegal Argument Exception ( unex ) ; } }
private void copy Stream (  Input Stream is ,  Output Stream os ) throws  IOException { try { byte [ ] buffer = new byte [ _ NUM ] ; int len ; while ( ( len = is . read ( buffer ) ) != - _ NUM ) { os . write ( buffer , _ NUM , len ) ; } } catch (  IOException e ) { throw new  IOException ( _ STR , e ) ; } }
public  Zip Entry (  String name ) { if ( name == null ) { throw new  Null Pointer Exception ( ) ; } if ( name . length ( ) > _ NUM ) { throw new  Illegal Argument Exception ( _ STR ) ; } this . name = name ; }
public  Writable Raster create Writable Child ( int x , int y , int width , int height , int x0 , int y0 , int [ ] band List ) { if ( x < this . min X ) { throw new  Raster Format Exception ( _ STR ) ; } if ( y < this . min Y ) { throw new  Raster Format Exception ( _ STR ) ; } if ( ( x + width < x ) || ( x + width > this . min X + this . width ) ) { throw new  Raster Format Exception ( _ STR ) ; } if ( ( y + height < y ) || ( y + height > this . min Y + this . height ) ) { throw new  Raster Format Exception ( _ STR ) ; }  Sample Model sm ; if ( band List != null ) sm = sample Model . create Subset Sample Model ( band List ) ; else sm = sample Model ; int delta X = x0 - x ; int delta Y = y0 - y ; return new  Byte Interleaved Raster ( sm , data Buffer , new  Rectangle ( x0 , y0 , width , height ) , new  Point ( sample Model Translate X + delta X , sample Model Translate Y + delta Y ) , this ) ; }
private void return Buffer (  Byte Buffer buf ) { if ( buf != null ) { buf . clear ( ) ; buffer Pool . add ( buf ) ; } }
public final void fire Event (  Event event ) { event Handlers . fire Event ( event ) ; }
public static boolean has Import Static (  String fq Class Name ,  String member Name ,  Psi Element context ) { final  Psi File file = context . get Containing File ( ) ; if ( ! ( file instanceof  Psi Java File ) ) { return _ BOOL ; } final  Psi Java File java File = (  Psi Java File ) file ; final  Psi Import List import List = java File . get Import List ( ) ; if ( import List == null ) { return _ BOOL ; } final  Psi Import Static Statement [ ] import Static Statements = import List . get Import Static Statements ( ) ; for (  Psi Import Static Statement import Static Statement : import Static Statements ) { if ( import Static Statement . is On Demand ( ) ) {  Psi Class psi Class =  Class Utils . find Class ( fq Class Name , context ) ; if ( psi Class != null && psi Class . equals ( import Static Statement . resolve Target Class ( ) ) ) { return _ BOOL ; } continue ; } final  String name = import Static Statement . get Reference Name ( ) ; if ( ! member Name . equals ( name ) ) { continue ; } final  Psi Java Code Reference Element import Reference = import Static Statement . get Import Reference ( ) ; if ( import Reference == null ) { continue ; } final  Psi Element qualifier = import Reference . get Qualifier ( ) ; if ( qualifier == null ) { continue ; } final  String qualifier Text = qualifier . get Text ( ) ; if ( fq Class Name . equals ( qualifier Text ) ) { return _ BOOL ; } } return _ BOOL ; }
@  Override public int compare ( final  String string1 , final  String string2 ) {  String string1 Copy = string1 . to Lower Case ( ) ;  String string2 Copy = string2 . to Lower Case ( ) ; int len1 = string1 . length ( ) ; int len2 = string2 . length ( ) ;  String liczba1 = _ STR ;  String liczba2 = _ STR ; for ( int i = _ NUM ; i < ( ( len1 > len2 ) ? len1 : len2 ) ; i ++ ) { if ( i == len1 && len2 > len1 ) { return - _ NUM ; } if ( i == len2 && len1 > len2 ) { return _ NUM ; }  Character c1 = string1 Copy . char At ( i ) ;  Character c2 = string2 Copy . char At ( i ) ; if ( is Digit ( c1 ) && is Digit ( c2 ) ) { liczba1 += c1 ; liczba2 += c2 ; } else if ( is Digit ( c1 ) && liczba1 . length ( ) > _ NUM ) { return _ NUM ; } else if ( is Digit ( c2 ) && liczba1 . length ( ) > _ NUM ) { return - _ NUM ; } else { if ( ! liczba1 . equals ( liczba2 ) ) { return liczba1 . compare To ( liczba2 ) ; } liczba1 = _ STR ; liczba2 = _ STR ; if ( ! c1 . equals ( c2 ) ) { return c1 . compare To ( c2 ) ; } } } return string1 Copy . compare To ( string2 Copy ) ; }
protected boolean validate Blob ( int id , byte [ ] base Content , int required Size ) throws  SQLException {  Connection con = get Connection Via Driver Manager ( ) ;  Callable Statement cstmt = null ; try { cstmt = con . prepare Call (  EXECUTE_ CHECK_ BINARY_ BLOB ) ; cstmt . set Int ( _ NUM , id ) ; cstmt . set Bytes ( _ NUM , base Content ) ; cstmt . set Int ( _ NUM , required Size ) ; cstmt . execute ( ) ; return cstmt . get Boolean ( _ NUM ) ; } finally { close Quietly ( cstmt ) ; close Quietly ( con ) ; } }
public int length ( ) { return results . size ( ) ; }
public  Statement is Not Null ( ) { statement . append ( _ STR ) ; return this ; }
public void clear ( ) { process Queue ( ) ; map . clear ( ) ; }
public void delete Favorite ( ) {  Fm Radio Station . update Station To Db ( m Context , m Dlg Station Name ,  Fm Radio Station .  STATION_ TYPE_ SEARCHED , m Dlg Station Freq ) ; m Adapter . notify Data Set Changed ( ) ; }
public boolean add All ( int index ,  Collection < ? extends  E > c ) {  Object [ ] cs = c . to Array ( ) ; final  Reentrant Lock lock = this . lock ; lock . lock ( ) ; try {  Object [ ] elements = get Array ( ) ; int len = elements . length ; if ( index > len || index < _ NUM ) throw new  Index Out Of Bounds Exception ( _ STR + index + _ STR + len ) ; if ( cs . length == _ NUM ) return _ BOOL ; int num Moved = len - index ;  Object [ ] new Elements ; if ( num Moved == _ NUM ) new Elements =  Arrays . copy Of ( elements , len + cs . length ) ; else { new Elements = new  Object [ len + cs . length ] ;  System . arraycopy ( elements , _ NUM , new Elements , _ NUM , index ) ;  System . arraycopy ( elements , index , new Elements , index + cs . length , num Moved ) ; }  System . arraycopy ( cs , _ NUM , new Elements , index , cs . length ) ; set Array ( new Elements ) ; return _ BOOL ; } finally { lock . unlock ( ) ; } }
public  Iterator <  Capability > capabilities ( ) { return m_ Capabilities . iterator ( ) ; }
public void create Resource Ticket Async (  String tenant Id ,  Resource Ticket Create Spec resource Ticket Create Spec , final  Future Callback <  Task > response Callback ) throws  IOException {  String path =  String . format ( _ STR , get Base Path ( ) , tenant Id ) ; create Object Async ( path , serialize Object As Json ( resource Ticket Create Spec ) , response Callback ) ; }
public static  Date parse ISO ( final  String str ) {  QL . require ( str . length ( ) == _ NUM && str . char At ( _ NUM ) == _ STR && str . char At ( _ NUM ) == _ STR , _ STR ) ; final int year =  Integer . parse Int ( str . substring ( _ NUM , _ NUM ) ) ; final int month =  Integer . parse Int ( str . substring ( _ NUM , _ NUM ) ) ; final int day =  Integer . parse Int ( str . substring ( _ NUM , _ NUM ) ) ; final  Date date = new  Date ( day ,  Month . value Of ( month ) , year ) ; return date ; }
protected void add Error (  String error ) { if ( error != null && error . length ( ) > _ NUM ) { if ( error Message == null ) error Message = _ STR ; else error Message += _ STR ; error Message += error ; } }
@  Deprecated public boolean is Http Url OK (  String url String ) { try {  URL e = new  URL ( url String ) ;  Http URLConnection url Connection = (  Http URLConnection ) e . open Connection ( ) ; url Connection . set Request Method ( _ STR ) ; int response Code = url Connection . get Response Code ( ) ; if ( response Code == _ NUM ) { return _ BOOL ; } else { return _ BOOL ; } } catch (  Exception e ) { return _ BOOL ; } }
public static void prepend Resource Source (  Resource Source source ) {  ALL_ RESOURCE_ SOURCES . add First ( source ) ; }
private void commit Changes ( ) { network Properties Panel . commit Changes ( ) ; quick Connect Panel . commit Changes ( ) ; }
private boolean via_try_snap_smd_center ( int p_layer ) {  Item Selection Filter selection_filter = new  Item Selection Filter (  Item Selection Choice .  PINS ) ;  Collection <  Brd Item > picked_items = r_board . pick_items ( prev_corner , p_layer , selection_filter ) ;  Brd Abit Pin found_smd_pin = null ; for (  Brd Item curr_item : picked_items ) { if ( ! ( curr_item instanceof  Brd Abit Pin ) ) continue ;  Brd Abit Pin a_pin = (  Brd Abit Pin ) curr_item ; if ( ! a_pin . shares_net_no ( net_nos ) ) continue ; if ( a_pin . first_layer ( ) == p_layer && a_pin . last_layer ( ) == p_layer ) { found_smd_pin = a_pin ; break ; } } if ( found_smd_pin == null ) return _ BOOL ;  Pla Point Int pin_center = found_smd_pin . center_get ( ) ; if ( itera_connect ( prev_corner , pin_center ) ) { prev_corner = pin_center ; } return _ BOOL ; }
public boolean should Intercept Touch Event (  Motion Event ev ) { final int action =  Motion Event Compat . get Action Masked ( ev ) ; final int action Index =  Motion Event Compat . get Action Index ( ev ) ; if ( action ==  Motion Event .  ACTION_ DOWN ) { cancel ( ) ; } if ( m Velocity Tracker == null ) { m Velocity Tracker =  Velocity Tracker . obtain ( ) ; } m Velocity Tracker . add Movement ( ev ) ; switch ( action ) { case  Motion Event .  ACTION_ DOWN : { final float x = ev . get X ( ) ; final float y = ev . get Y ( ) ; final int pointer Id =  Motion Event Compat . get Pointer Id ( ev , _ NUM ) ; save Initial Motion ( x , y , pointer Id ) ; final  View to Capture = find Top Child Under ( ( int ) x , ( int ) y ) ; if ( to Capture == m Captured View && m Drag State ==  STATE_ SETTLING ) { try Capture View For Drag ( to Capture , pointer Id ) ; } final int edges Touched = m Initial Edge Touched [ pointer Id ] ; if ( ( edges Touched & m Tracking Edges ) != _ NUM ) { m Callback . on Edge Touched ( edges Touched & m Tracking Edges , pointer Id ) ; } break ; } case  Motion Event Compat .  ACTION_ POINTER_ DOWN : { final int pointer Id =  Motion Event Compat . get Pointer Id ( ev , action Index ) ; final float x =  Motion Event Compat . get X ( ev , action Index ) ; final float y =  Motion Event Compat . get Y ( ev , action Index ) ; save Initial Motion ( x , y , pointer Id ) ; if ( m Drag State ==  STATE_ IDLE ) { final int edges Touched = m Initial Edge Touched [ pointer Id ] ; if ( ( edges Touched & m Tracking Edges ) != _ NUM ) { m Callback . on Edge Touched ( edges Touched & m Tracking Edges , pointer Id ) ; } } else if ( m Drag State ==  STATE_ SETTLING ) { final  View to Capture = find Top Child Under ( ( int ) x , ( int ) y ) ; if ( to Capture == m Captured View ) { try Capture View For Drag ( to Capture , pointer Id ) ; } } break ; } case  Motion Event .  ACTION_ MOVE : { final int pointer Count =  Motion Event Compat . get Pointer Count ( ev ) ; for ( int i = _ NUM ; i < pointer Count ; i ++ ) { final int pointer Id =  Motion Event Compat . get Pointer Id ( ev , i ) ; final float x =  Motion Event Compat . get X ( ev , i ) ; final float y =  Motion Event Compat . get Y ( ev , i ) ; final float dx = x - m Initial Motion X [ pointer Id ] ; final float dy = y - m Initial Motion Y [ pointer Id ] ; if ( dx < _ NUM ||  Math . abs ( dx ) <=  Math . abs ( dy ) ) break ; report New Edge Drags ( dx , dy , pointer Id ) ; if ( m Drag State ==  STATE_ DRAGGING ) { break ; } final  View to Capture = find Top Child Under ( ( int ) x , ( int ) y ) ; if ( to Capture != null && check Touch Slop ( to Capture , dx , dy ) && try Capture View For Drag ( to Capture , pointer Id ) ) { break ; } } save Last Motion ( ev ) ; break ; } case  Motion Event Compat .  ACTION_ POINTER_ UP : { final int pointer Id =  Motion Event Compat . get Pointer Id ( ev , action Index ) ; clear Motion History ( pointer Id ) ; break ; } case  Motion Event .  ACTION_ UP : case  Motion Event .  ACTION_ CANCEL : { cancel ( ) ; break ; } } return m Drag State ==  STATE_ DRAGGING ; }
public boolean add Svf (  Owl Class target Class ) { target Class . add Svf Restriction ( this ) ; return svf Classes . add ( target Class ) ; }
@  Override public  Column column ( int column Index ) { return column List . get ( column Index ) ; }
public static boolean is DWMComposition Enabled ( ) { return is DWMComposition Enabled ; }
private void serializable ( final  Isolation Levels level ) throws  Exception { clear ( store ) ; final  Value Factory vf = store . get Value Factory ( ) ; final  IRI subj = vf . create IRI ( _ STR ) ; final  IRI pred = vf . create IRI ( _ STR ) ;  Sail Connection prep = store . get Connection ( ) ; try { prep . begin ( level ) ; prep . add Statement ( subj , pred , vf . create Literal ( _ NUM ) ) ; prep . commit ( ) ; } finally { prep . close ( ) ; } final  Count Down Latch start = new  Count Down Latch ( _ NUM ) ; final  Count Down Latch observed = new  Count Down Latch ( _ NUM ) ;  Thread t1 = increment By ( start , observed , level , vf , subj , pred , _ NUM ) ;  Thread t2 = increment By ( start , observed , level , vf , subj , pred , _ NUM ) ; t2 . start ( ) ; t1 . start ( ) ; t2 . join ( ) ; t1 . join ( ) ; assert Not Failed ( ) ;  Sail Connection check = store . get Connection ( ) ; try { check . begin ( level ) ;  Literal lit = read Literal ( check , subj , pred ) ; int val = lit . int Value ( ) ; if ( val != _ NUM && val != _ NUM ) {  Assert . assert Equals ( _ NUM , val ) ; } check . commit ( ) ; } finally { check . close ( ) ; } }
public static  Array list To Array (  String list , char delimiter ) { if ( list . length ( ) == _ NUM ) return new  Array Impl ( ) ; int len = list . length ( ) ; int last = _ NUM ;  Array array = new  Array Impl ( ) ; try { for ( int i = _ NUM ; i < len ; i ++ ) { if ( list . char At ( i ) == delimiter ) { array . append ( list . substring ( last , i ) ) ; last = i + _ NUM ; } } if ( last <= len ) array . append ( list . substring ( last ) ) ; } catch (  Page Exception e ) { } return array ; }
public static <  T extends  Object &  Comparable < ? super  T > >  T min (  Collection < ? extends  T > collection ) {  Iterator < ? extends  T > it = collection . iterator ( ) ;  T min = it . next ( ) ; while ( it . has Next ( ) ) {  T next = it . next ( ) ; if ( min . compare To ( next ) > _ NUM ) { min = next ; } } return min ; }
Server Heartbeat create Server (  String server Id ) { int p = server Id . index Of ( _ STR ) ;  String address = server Id . substring ( _ NUM , p ) ; int port =  Integer . parse Int ( server Id . substring ( p + _ NUM ) ) ; boolean is SSL = _ BOOL ; return _heartbeat Service . create Server ( address , port , is SSL ) ; }
public void test To String ( ) {  Linked Blocking Deque q = populated Deque (  SIZE ) ;  String s = q . to String ( ) ; for ( int i = _ NUM ; i <  SIZE ; ++ i ) { assert True ( s . index Of (  String . value Of ( i ) ) >= _ NUM ) ; } }
public  String title String ( ) { return title String ( get Model ( ) , get Family ( ) ) ; }
public void test Stress Allocation Context Recycling ( ) { final  Journal store = (  Journal ) get Store ( _ NUM ) ; try { final  RWStrategy buffer Strategy = (  RWStrategy ) store . get Buffer Strategy ( ) ; final  RWStore rw = buffer Strategy . get Store ( ) ; final  IAllocation Context cntxt = rw . new Allocation Context ( _ BOOL ) ; final int allocs = _ NUM ; final  Random ran = new  Random ( ) ; for ( int r = _ NUM ; r < _ NUM ; r ++ ) {  Array List <  Integer > addrs = new  Array List <  Integer > ( ) ; for ( int a = _ NUM ; a < allocs ; a ++ ) { addrs . add ( rw . alloc ( _ NUM , cntxt ) ) ; } final  Pseudo Random ps = new  Pseudo Random ( allocs , ran . next Int ( allocs ) ) ; for ( int a : addrs ) { rw . free ( addrs . get ( ps . next ( ) ) , _ NUM , cntxt ) ; } } assert True ( rw . get Fixed Allocator Count ( ) < _ NUM ) ; if ( log . is Info Enabled ( ) ) { final  String Builder str = new  String Builder ( ) ; rw . show Allocators ( str ) ; log . info ( str ) ; } store . commit ( ) ; } finally { store . destroy ( ) ; } }
private  String diff_lines To Chars Munge (  String text ,  List <  String > line Array ,  Map <  String ,  Integer > line Hash ) { int line Start = _ NUM ; int line End = - _ NUM ;  String line ;  String Builder chars = new  String Builder ( ) ; while ( line End < text . length ( ) - _ NUM ) { line End = text . index Of ( _ STR , line Start ) ; if ( line End == - _ NUM ) { line End = text . length ( ) - _ NUM ; } line = text . substring ( line Start , line End + _ NUM ) ; line Start = line End + _ NUM ; if ( line Hash . contains Key ( line ) ) { chars . append (  String . value Of ( ( char ) ( int ) line Hash . get ( line ) ) ) ; } else { line Array . add ( line ) ; line Hash . put ( line , line Array . size ( ) - _ NUM ) ; chars . append (  String . value Of ( ( char ) ( line Array . size ( ) - _ NUM ) ) ) ; } } return chars . to String ( ) ; }
private  Collection <  Inet Socket Address > filter If Necessary (  Collection <  Inet Socket Address > addrs , boolean filter ) { if ( ! filter ) return addrs ;  List <  Inet Socket Address > res = new  Array List < > ( addrs . size ( ) ) ; for (  Inet Socket Address addr : addrs ) if ( ! addr . is Unresolved ( ) ) res . add ( addr ) ; return res ; }
public static void show Profile (  Fragment fragment ,  String pilot Id , @  Nullable  Hash Map <  String ,  String > extras ) { if ( ( pilot Id == null || pilot Id . is Empty ( ) ) &&  Air Map . has Valid Authenticated User ( ) ) { pilot Id =  Air Map . get User Id ( ) ; }  Intent intent = new  Intent ( fragment . get Activity ( ) ,  Profile Activity . class ) ; intent . put Extra (  Profile Activity .  ARG_ PILOT_ ID , pilot Id ) ; if ( extras != null ) { intent . put Extra (  Create Flight Activity .  KEY_ VALUE_ EXTRAS , extras ) ; } fragment . start Activity ( intent ) ; }
public static void start Run Timer ( ) { exec Start Time =  System . nano Time ( ) ; }
protected void init LST ( ) { logger . fine ( _ STR ) ; try { if ( lst == null ) { if ( library Bean Name != null ) {  Library Bean library Bean = null ;  Bean Context bean Context = get Bean Context ( ) ; if ( bean Context == null ) { return ; } for (  Object obj : bean Context ) { if ( obj instanceof  Library Bean ) {  Library Bean lb = (  Library Bean ) obj ; if ( library Bean Name . equals ( lb . get Name ( ) ) ) { if ( logger . is Loggable (  Level .  FINE ) ) { logger . fine ( get Name ( ) + _ STR + lb . get Name ( ) ) ; } library Bean = lb ; break ; } } } if ( library Bean != null ) { lst = library Bean . get Library Selection Table ( ) ; warehouse = library Bean . get Warehouse ( ) ; warehouse . set Properties ( get Property Prefix ( ) , props ) ; search By Features = _ BOOL ; box = null ; logger . fine ( _ STR ) ; } else { if ( logger . is Loggable (  Level .  FINE ) ) { logger . fine ( _ STR + library Bean Name + _ STR ) ; } } } else { if ( data Paths == null ) { logger . info ( _ STR + get Name ( ) + _ STR ) ; } else { logger . fine ( _ STR ) ; lst = new  Library Selection Table ( data Paths ) ; lst . set Cutoff Scale ( cutoff Scale ) ; } } } } catch ( com . bbn . openmap . io .  Format Exception f ) { throw new java . lang .  Illegal Argument Exception ( f . get Message ( ) ) ; } }
private static final byte [ ] hash ( final byte [ ] value ) throws  No Such Algorithm Exception {  Message Digest md =  Message Digest . get Instance ( _ STR ) ; md . reset ( ) ; md . update ( value ) ; return md . digest ( ) ; }
public void add Funnel (  List <  Long > funnel ) throws  Hive Exception { if ( elements . is Empty ( ) ) { elements . add All ( funnel ) ; } else { if ( elements . size ( ) != funnel . size ( ) ) { throw new  UDFArgument Type Exception ( _ NUM , _ STR ) ; } for ( int i = _ NUM ; i < funnel . size ( ) ; i ++ ) { elements . set ( i , ( funnel . get ( i ) + elements . get ( i ) ) ) ; } } }
public static  String insert Parameter (  Ct Class type ,  String descriptor ) { if ( descriptor . char At ( _ NUM ) != _ STR ) return descriptor ; else return _ STR + of ( type ) + descriptor . substring ( _ NUM ) ; }
public  Filter Pred (  Filter Pred Clause clause ) { clauses . add ( clause ) ; }
public static void stream Content To Browser (  Http Servlet Response response , byte [ ] bytes ,  String content Type ,  String file Name ) throws  IOException { set Response Browser Proxy No Cache ( response ) ; response . set Content Length ( bytes . length ) ; if ( content Type != null ) { response . set Content Type ( content Type ) ; } if ( file Name != null ) { response . set Header ( _ STR , _ STR + file Name ) ; }  Output Stream out = response . get Output Stream ( ) ;  Input Stream in = new  Byte Array Input Stream ( bytes ) ; try { stream Content ( out , in , bytes . length ) ; } catch (  IOException e ) { in . close ( ) ; out . close ( ) ; throw e ; } in . close ( ) ; out . flush ( ) ; out . close ( ) ; }
public void put And Unlock (  Object key ,  Object value ) {  String uid =  String . value Of ( key ) ;  Transaction tr = locked UIDHash Map . get ( uid ) ; if ( tr == null ) { map . put ( key , value , null ,  Integer .  MAX_ VALUE ) ; return ; } try { map . put ( key , value , tr ,  Integer .  MAX_ VALUE ) ; tr . commit ( ) ; } catch (  Throwable t ) { logger . warn ( _ STR + key + _ STR , t ) ; } finally { locked UIDHash Map . remove ( uid ) ; } }
public static double mean ( double [ ] data , int start Index , int end Index ) { double mean = _ NUM ; int total = _ NUM ; start Index =  Math . max ( start Index , _ NUM ) ; start Index =  Math . min ( start Index , data . length - _ NUM ) ; end Index =  Math . max ( end Index , _ NUM ) ; end Index =  Math . min ( end Index , data . length - _ NUM ) ; if ( start Index > end Index ) start Index = end Index ; for ( int i = start Index ; i <= end Index ; i ++ ) { if (  Double . is Na N ( data [ i ] ) ) throw new  Illegal Argument Exception ( _ STR ) ; mean += data [ i ] ; total ++ ; } mean /= total ; return mean ; }
public void wait For Schema Agreement (  String target Schema Version , int node Count ) { long start =  System . current Time Millis ( ) ;  Map <  String ,  List <  String > > versions = null ; while (  System . current Time Millis ( ) - start <  MAX_ SCHEMA_ WAIT_ MS ) { log . info ( _ STR , target Schema Version , node Count ) ; versions = get Schema Versions ( ) ; if ( versions . size ( ) == _ NUM ) { if ( ! versions . contains Key ( target Schema Version ) ) { log . warn ( _ STR , versions , target Schema Version ) ; return ; } if ( node Count != - _ NUM ) {  List <  String > hosts = null ; for (  Entry <  String ,  List <  String > > entry : versions . entry Set ( ) ) { hosts = entry . get Value ( ) ; } if ( hosts != null && hosts . size ( ) == node Count ) { log . info ( _ STR , target Schema Version , node Count ) ; return ; } } else { log . info ( _ STR , target Schema Version ) ; return ; } } log . info ( _ STR ) ; try {  Thread . sleep (  SCHEMA_ RETRY_ SLEEP_ MILLIS ) ; } catch (  Interrupted Exception ex ) { } } log . warn ( _ STR , versions ) ; }
void clear ( ) ;
@  Override protected void build Sprites (  Food entity , final  Map <  Object ,  Sprite > map ) { final  Sprite Store store =  Sprite Store . get ( ) ;  Zone Info info =  Zone Info . get ( ) ; final  Sprite tiles = store . get Modified Sprite ( translate ( entity . get Type ( ) ) , info . get Zone Color ( ) , info . get Color Method ( ) ) ; final int theight = tiles . get Height ( ) ; int i = _ NUM ; for ( int y = _ NUM ; y < theight ; y +=  IGame Screen .  SIZE_ UNIT_ PIXELS ) { map . put (  Integer . value Of ( i ++ ) , store . get Tile ( tiles , _ NUM , y ,  IGame Screen .  SIZE_ UNIT_ PIXELS ,  IGame Screen .  SIZE_ UNIT_ PIXELS ) ) ; } }
public static  String comparable Qualifier (  String qualifier ) { int i = _ QUALIFIERS . index Of ( qualifier ) ; return i == - _ NUM ? ( _ QUALIFIERS . size ( ) + _ STR + qualifier ) :  String . value Of ( i ) ; }
public static  Object evaluate (  Object context ,  Object self ,  String expr ,  List <  String > engine Configs ) throws  Draft3 Expression Exception {  String trimmed Expr =  String Utils . trim ( expr ) ; if ( trimmed Expr . starts With ( _ STR ) ) { trimmed Expr = trimmed Expr . substring ( _ NUM ) ; }  String function = trimmed Expr ; if ( trimmed Expr . starts With ( _ STR ) ) { function = _ STR ; function = function . replace ( _ STR , trimmed Expr ) ; }  Context cx =  Context . enter ( ) ; cx . set Optimization Level (  OPTIMIZATION_ LEVEL ) ; cx . set Maximum Interpreter Stack Depth (  MAX_ STACK_ DEPTH ) ; cx . set Class Shutter ( new  Draft3 Expression Deny All Class Shutter ( ) ) ; try {  Scriptable global Scope = cx . init Standard Objects ( ) ; if ( engine Configs != null ) { for ( int i = _ NUM ; i < engine Configs . size ( ) ; i ++ ) {  Reader engine Config Reader = new  String Reader ( engine Configs . get ( i ) ) ; cx . evaluate Reader ( global Scope , engine Config Reader , _ STR + i + _ STR , _ NUM , null ) ; } } put To Scope (  EXPR_ CONTEXT_ NAME , context , cx , global Scope ) ; put To Scope (  EXPR_ SELF_ NAME , self , cx , global Scope ) ;  Scriptable result Scope = cx . new Object ( global Scope ) ; result Scope . set Prototype ( global Scope ) ; result Scope . set Parent Scope ( global Scope ) ;  Object result = cx . evaluate String ( result Scope , function , _ STR , _ NUM , null ) ; if ( result == null || result instanceof  Undefined ) { return null ; }  Object wrapped Result =  Context . java To JS ( result , global Scope ) ; put To Scope ( _ STR , wrapped Result , cx , global Scope ) ;  Scriptable Object . put Property ( global Scope , _ STR , wrapped Result ) ;  String final Function = _ STR + _ STR + _ STR + _ STR + _ STR ;  Scriptable wrap Scope = cx . new Object ( global Scope ) ; wrap Scope . set Prototype ( global Scope ) ; wrap Scope . set Parent Scope ( global Scope ) ; result = cx . evaluate String ( wrap Scope , final Function , _ STR , _ NUM , null ) ; return cast Result ( result ) ; } catch (  Exception e ) {  String msg =  String . format ( _ STR , expr ) ; throw new  Draft3 Expression Exception ( msg , e ) ; } finally {  Context . exit ( ) ; } }
String char To String ( char c ) { if ( c < _ STR || c > _ NUM ) { return _ STR + ( int ) c ; } return  String . value Of ( c ) ; }
public static boolean is File URL (  URL url ) {  String protocol = url . get Protocol ( ) ; return (  URL_ PROTOCOL_ FILE . equals ( protocol ) ||  URL_ PROTOCOL_ VFSFILE . equals ( protocol ) ||  URL_ PROTOCOL_ VFS . equals ( protocol ) ) ; }
public boolean equals (  Object o ) { if ( o instanceof  LDAPGroups ) {  LDAPGroups g = (  LDAPGroups ) o ; if ( ( selected Group DNs != null ) && ( g . selected Group DNs != null ) && ( selected Group DNs . equals ( g . selected Group DNs ) ) ) { return _ BOOL ; } } return _ BOOL ; }
private void apply Set Timestamp (  Long timestamp ) throws  SQLException { if ( timestamp != null && conn . supports Control Timestamp ( ) ) { if ( timestamp . long Value ( ) != current Timestamp ) { current Timestamp = timestamp . long Value ( ) ; statement . add Batch ( conn . get Control Timestamp Query ( timestamp ) ) ; } } }
public static  Data Type create Object (  String class Name ,  String value ) { try {  Class < ? > the Class =  Class . for Name ( class Name ) ;  Class < ? > [ ] constructor Parameters = new  Class [ _ NUM ] ; constructor Parameters [ _ NUM ] =  Class . for Name ( _ STR ) ;  Constructor < ? > class Constructor = the Class . get Constructor ( constructor Parameters ) ; return (  Data Type ) class Constructor . new Instance ( value ) ; } catch (  Exception ex ) {  Log . e ( _ STR , _ STR + class Name + _ STR + value ) ; } return null ; }
public static  List <  Base Mqtt Message > process Message Log ( final  List <  Logged Mqtt Message > list , final  Progress Updater progress , final long current , final long max ) { final  List <  Base Mqtt Message > mqtt Message List = new  Array List <  Base Mqtt Message > ( ) ; long item = _ NUM ; for ( final  Logged Mqtt Message logged Message : list ) { if ( progress != null ) { if ( progress . is Cancelled ( ) ) { logger . info ( _ STR ) ; return null ; } item ++ ; if ( item % _ NUM == _ NUM ) { progress . update ( current + item , max ) ; } } mqtt Message List . add ( convert To Base Mqtt Message ( logged Message ) ) ; } logger . info ( _ STR , list . size ( ) ) ; return mqtt Message List ; }
public void start ( ) { this . start Time =  System . current Time Millis ( ) ; this . stop Time = _ NUM ; }
public  Windows XP ( ) { int procs = _ NUM ;  String info = _ STR ; try {  Runtime rt =  Runtime . get Runtime ( ) ;  Process proc = rt . exec ( _ STR ) ;  Buffered Reader reader = new  Buffered Reader ( new  Input Stream Reader ( proc . get Input Stream ( ) ) ) ;  String num Procs = reader . read Line ( ) ; proc = rt . exec ( _ STR ) ; reader = new  Buffered Reader ( new  Input Stream Reader ( proc . get Input Stream ( ) ) ) ; info = reader . read Line ( ) ; procs =  Integer . parse Int ( num Procs ) ; } catch (  Exception e ) { } m_processors = procs ; m_cpu Info = info ; }
public static void dump Stack (  Address fp ) { if (  VM .  Verify Assertions ) {  VM . _assert (  VM . running VM ) ; }  Address ip =  Magic . get Return Address ( fp ) ; fp =  Magic . get Caller Frame Pointer ( fp ) ; dump Stack ( ip , fp ) ; }
@  Override public  Path Impl scheme Walk (  String user Path ,  Map <  String ,  Object > attributes ,  String file Path , int offset ) {  String canonical Path = file Path ; if ( offset < file Path . length ( ) && file Path . char At ( offset ) == _ STR ) { } else { canonical Path = normalize Path ( _pathname , file Path , offset , _separator Char ) ; } return fs Walk ( user Path , attributes , canonical Path ) ; }
public static boolean has Mime Type (  String mime Type ) { if ( mime Type == null || mime Type . is Empty ( ) ) { return _ BOOL ; } return mime Type To Extension Map . contains Key ( mime Type ) ; }
public  Channel Change Listener (  String group Name ,  Sound Group group ) { this . group = group ; this . group Name = group Name ; }
public void log Equals ( ) { for ( int i = _ NUM ; i <  A . length ; i ++ ) for ( int j = _ NUM ; j <  A [ i ] . length ; j ++ )  A [ i ] [ j ] =  Math . log (  A [ i ] [ j ] ) ; }
public void remove Attribute (  String attr Name ,  String value ) throws  SMSException {  Set attr = null ; if ( ( attr Set == null ) || ( ( attr = (  Set ) attr Set . get ( attr Name ) ) == null ) || ( ! attr . contains ( value ) ) ) { throw ( new  SMSException (  Ldap Exception . new Ldap Exception (  Result Code .  ATTRIBUTE_ OR_ VALUE_ EXISTS , get Bundle String (  IUMSConstants .  SMS_ ATTR_ OR_ VAL_ EXISTS ) ) , _ STR ) ) ; } attr . remove ( value ) ; attr Set . put ( attr Name , attr ) ; if ( mod Set == null ) { mod Set = new  Hash Set ( ) ; } mod Set . add ( new  Modification Item (  Dir Context .  REMOVE_ ATTRIBUTE , new  Basic Attribute ( attr Name , value ) ) ) ; }
public static void init (  Context context ) { if ( camera Manager == null ) { camera Manager = new  Camera Manager ( context ) ; } }
@  Override public  Enumeration <  Option > list Options ( ) {  Vector <  Option > result = new  Vector <  Option > ( ) ; result . add Element ( new  Option ( _ STR , _ STR , _ NUM , _ STR ) ) ; result . add Element ( new  Option ( _ STR , _ STR , _ NUM , _ STR ) ) ; result . add Element ( new  Option ( _ STR , _ STR , _ NUM , _ STR ) ) ; result . add Element ( new  Option ( _ STR + _ STR , _ STR , _ NUM , _ STR ) ) ; result . add Element ( new  Option ( _ STR + default Min Inst Num ( ) + _ STR + default Max Inst Num ( ) + _ STR , _ STR , _ NUM , _ STR ) ) ; result . add Element ( new  Option ( _ STR , _ STR , _ NUM , _ STR ) ) ; return result . elements ( ) ; }
public  Image rotate90 Degrees (  Image image , boolean maintain Opacity ) { int [ ] rgb = image . get RGB ( ) ; int [ ] new RGB = new int [ rgb . length ] ; int width = image . get Width ( ) ; int height = image . get Height ( ) ; for ( int y = _ NUM ; y < height ; y ++ ) { for ( int x = _ NUM ; x < width ; x ++ ) { int dest X = height - y - _ NUM ; new RGB [ dest X + x * height ] = rgb [ x + y * width ] ; } } return  Encoded Image . create From RGB ( new RGB , height , width , ! maintain Opacity ) ; }
public void test_ Big Decimal0 ( ) { final  Big Decimal [ ] a = new  Big Decimal [ ] { new  Big Decimal ( _ STR ) , new  Big Decimal ( _ STR ) , new  Big Decimal ( _ STR ) , new  Big Decimal ( _ STR ) , new  Big Decimal ( _ STR ) , new  Big Decimal ( _ STR ) , new  Big Decimal ( _ STR ) } ; for (  Big Decimal i : a ) { i = i . strip Trailing Zeros ( ) ; if ( log . is Info Enabled ( ) ) log . info ( _ STR + i + _ STR + i . scale ( ) + _ STR + i . precision ( ) + _ STR + dump Big Decimal ( i ) ) ; } for (  Big Decimal i : a ) { do Encode Decode Test ( i ) ; } for ( int i = _ NUM ; i < a . length ; i ++ ) { for ( int j = _ NUM ; j < a . length ; j ++ ) { do Compare Test ( a [ i ] , a [ j ] ,  Compare Enum .  EQ ) ; } } }
private boolean cmd_save ( ) { log . config ( _ STR ) ;  Calendar date = new  Gregorian Calendar ( ) ; get Date And Time From ( date ) ;  Timestamp assign Date From = new  Timestamp ( date . get Time In Millis ( ) ) ;  Big Decimal qty = f Qty . get Value ( ) ;  List Item list Item = f Resource . get Selected Item ( ) ;  Key Name Pair resource = list Item != null ? new  Key Name Pair ( (  Integer ) list Item . get Value ( ) , list Item . get Label ( ) ) : null ;  Key Name Pair uom = (  Key Name Pair ) m_lookup . get ( resource ) ; int minutes =  MUOMConversion . convert To Minutes (  Env . get Ctx ( ) , uom . get Key ( ) , qty ) ;  Timestamp assign Date To =  Time Util . add Minutess ( assign Date From , minutes ) ; m_m Assignment . set Assign Date To ( assign Date To ) ; return m_m Assignment . save ( ) ; }
private static  Coordinate [ ] coordinates (  Edge component ,  Coordinate [ ] coordinates ) { for ( int i = _ NUM ; i < coordinates . length ; i ++ ) { coordinates [ i ] = ( component = component . next ) . coordinate ; } return coordinates ; }
@  Override public void close ( ) throws  IOException { if ( closed . compare And Set ( _ BOOL , _ BOOL ) ) { close ( _ BOOL ) ; } }
@  Override public boolean connection Allowed (  String event Name ) { if ( ! event Name . equals ( _ STR ) && ! event Name . equals ( _ STR ) && ! event Name . equals ( _ STR ) && ! event Name . equals ( _ STR ) ) { return _ BOOL ; } if ( m_listenee != null ) { return _ BOOL ; } return _ BOOL ; }
public void add Flakes ( int quantity ) { for ( int i = _ NUM ; i < quantity ; ++ i ) { flakes . add (  Flake . create Flake ( get Width ( ) , droid , get Context ( ) ) ) ; } set Num Flakes ( num Flakes + quantity ) ; }
public boolean can Create Rule (  Policy policy ,  String realm Name ) { get Svc Type Name To Actions Map ( policy , realm Name ) ; return ! required Resource Name Service . is Empty ( ) || ! not Required Resource Name Service . is Empty ( ) ; }
public static void main (  String [ ] args ) throws  Exception {  System . exit ( compile ( args ) ) ; }
protected  String r (  String s ,  String u ) throws  Exception {  Date dt =  Date Math Parser . parse Math ( null , s + _ STR + u ) ; return fmt . format ( dt . to Instant ( ) ) ; }
public void reopen ( ) throws  IOException { super . reopen ( ) ;  Debug . message ( _ STR , _ STR + jar File Name ) ; if ( jar File != null ) jar File . close ( ) ; jar File = null ; jar File = new  Jar File (  URLDecoder . decode ( jar File Name , _ STR ) ) ;  Jar Entry entry = jar File . get Jar Entry ( jar Entry Name ) ; input Stream = jar File . get Input Stream ( entry ) ; if ( input Stream == null ) {  Debug . error ( _ STR + jar Entry Name + _ STR + jar File Name ) ; } }
public static  Intent create Email Attendees Intent (  Resources resources ,  String event Title ,  String body ,  List <  String > to Emails ,  List <  String > cc Emails ,  String owner Account ) {  List <  String > to List = to Emails ;  List <  String > cc List = cc Emails ; if ( to Emails . size ( ) <= _ NUM ) { if ( cc Emails . size ( ) <= _ NUM ) { throw new  Illegal Argument Exception ( _ STR ) ; } to List = cc Emails ; cc List = null ; }  String subject = null ; if ( event Title != null ) { subject = resources . get String (  R . string . email_subject_prefix ) + event Title ; }  Uri .  Builder uri Builder = new  Uri .  Builder ( ) ; uri Builder . scheme ( _ STR ) ; if ( to List . size ( ) > _ NUM ) { for ( int i = _ NUM ; i < to List . size ( ) ; i ++ ) { uri Builder . append Query Parameter ( _ STR , to List . get ( i ) ) ; } } if ( subject != null ) { uri Builder . append Query Parameter ( _ STR , subject ) ; } if ( body != null ) { uri Builder . append Query Parameter ( _ STR , body ) ; } if ( cc List != null && cc List . size ( ) > _ NUM ) { for (  String email : cc List ) { uri Builder . append Query Parameter ( _ STR , email ) ; } }  String uri = uri Builder . to String ( ) ; if ( uri . starts With ( _ STR ) ) {  String Builder builder = new  String Builder ( uri ) ; builder . insert ( _ NUM ,  Uri . encode ( to List . get ( _ NUM ) ) ) ; uri = builder . to String ( ) ; }  Intent email Intent = new  Intent ( android . content .  Intent .  ACTION_ SENDTO ,  Uri . parse ( uri ) ) ; email Intent . put Extra ( _ STR , owner Account ) ; if ( body != null ) { email Intent . put Extra (  Intent .  EXTRA_ TEXT , body ) ; } return  Intent . create Chooser ( email Intent , resources . get String (  R . string . email_picker_label ) ) ; }
public void init (  String component Name ) throws  Log Exception { access Logger = ( com . sun . identity . log .  Logger )  Logger . get Logger ( component Name + _ STR ) ; error Logger = ( com . sun . identity . log .  Logger )  Logger . get Logger ( component Name + _ STR ) ; try { msg Provider =  Message Provider Factory . get Provider ( component Name ) ; } catch (  IOException e ) { debug . error ( _ STR , e ) ; } }
public static boolean is Letter Or Digit (  Character self ) { return  Character . is Letter Or Digit ( self ) ; }
private static  String printable Label ( int label ) { if ( label >= _ NUM && label <= _ NUM && label != _ NUM && label != _ NUM ) { return  Character . to String ( ( char ) label ) ; } return _ STR +  Integer . to Hex String ( label ) ; }
public void add Filter (  Value Expr the Expr ) { m Filters . add ( the Expr ) ; }
public  Ascii Table ( ) { this . data = new  Object [ _ NUM ] ; this . buffer = null ; this . n Fields = _ NUM ; this . n Rows = _ NUM ; this . row Len = _ NUM ; this . types = new  Class [ _ NUM ] ; this . lengths = new int [ _ NUM ] ; this . offsets = new int [ _ NUM ] ; this . nulls = new  String [ _ NUM ] ; }
private  String Part create String Part ( final  String name , final  String value ) { final  String Part string Part = new  String Part ( name , value ) ; string Part . set Transfer Encoding ( null ) ; string Part . set Content Type ( null ) ; return string Part ; }
public static  String Block read (  Ext Data Input reader ) throws  IOException { reader . skip Check Chunk Type Int (  CHUNK_ STRINGPOOL_ TYPE ,  CHUNK_ NULL_ TYPE ) ; int chunk Size = reader . read Int ( ) ; int string Count = reader . read Int ( ) ; int style Count = reader . read Int ( ) ; int flags = reader . read Int ( ) ; int strings Offset = reader . read Int ( ) ; int styles Offset = reader . read Int ( ) ;  String Block block = new  String Block ( ) ; block . m_is UTF8 = ( flags &  UTF8_ FLAG ) != _ NUM ; block . m_string Offsets = reader . read Int Array ( string Count ) ; block . m_string Owns = new int [ string Count ] ;  Arrays . fill ( block . m_string Owns , - _ NUM ) ; if ( style Count != _ NUM ) { block . m_style Offsets = reader . read Int Array ( style Count ) ; } { int size = ( ( styles Offset == _ NUM ) ? chunk Size : styles Offset ) - strings Offset ; if ( ( size % _ NUM ) != _ NUM ) { throw new  IOException ( _ STR + size + _ STR ) ; } block . m_strings = new byte [ size ] ; reader . read Fully ( block . m_strings ) ; } if ( styles Offset != _ NUM ) { int size = ( chunk Size - styles Offset ) ; if ( ( size % _ NUM ) != _ NUM ) { throw new  IOException ( _ STR + size + _ STR ) ; } block . m_styles = reader . read Int Array ( size / _ NUM ) ; } return block ; }
private static  String [ ] make Lines ( int n ) {  String [ ] ret = new  String [ n ] ; for ( int i = _ NUM ; i < n ; ++ i ) { ret [ i ] = _ STR + i ; } return ret ; }
@  Override public  String to String ( ) {  String coll = collection Model . get Name ( ) ; if ( coll != null ) { return  String . format (  Locale .  ROOT , _ STR , get Name ( ) , coll ) ; } else { return  String . format (  Locale .  ROOT , _ STR , get Name ( ) ) ; } }
protected  Key Pair Generator (  String algorithm ) { this . algorithm = algorithm ; }
public static void check Field Value From Enum ( final  String value , final  String field Name ,  Class < ? extends  Enum > enum Type ) { if ( value != null ) { check Field Value From Enum ( value , field Name ,  Enum Set . all Of ( enum Type ) ) ; } }
public void remove Events ( ) { scene . set On Key Pressed ( null ) ; scene . set On Key Released ( null ) ; up = down = left = right = sprint = jump = shoot Fireball = _ BOOL ; }
private static  String [ ] to String Array ( final  Collection < ? > collection ) { if ( collection == null ) { return null ; } return collection . to Array ( new  String [ collection . size ( ) ] ) ; }
static public void fill Random Uniform (  IDouble Vector vec ,  Random rand , double min , double max ) { final double delta = max - min ; for ( int i = _ NUM ; i < vec . get Length ( ) ; ++ i ) { vec . set ( i , min + rand . next Double ( ) * delta ) ; } }
public static boolean am Fetcher ( ) { return is Fetcher (  Thread . current Thread ( ) ) ; }
Net Class append (  String p_name , board .  Brd Layer Structure p_layer_structure ,  Clearance Matrix p_clearance_matrix ) {  Net Class new_class = new  Net Class ( p_name , p_layer_structure , p_clearance_matrix ) ; class_list . add ( new_class ) ; return new_class ; }
protected void draw Range Markers (  Graphics2 D g2 ,  Rectangle2 D data Area , int index ,  Layer layer ) {  Category Item Renderer r = get Renderer ( index ) ; if ( r == null ) { return ; }  Collection markers = get Range Markers ( index , layer ) ;  Value Axis axis = get Range Axis For Dataset ( index ) ; if ( markers != null && axis != null ) {  Iterator iterator = markers . iterator ( ) ; while ( iterator . has Next ( ) ) {  Marker marker = (  Marker ) iterator . next ( ) ; r . draw Range Marker ( g2 , this , axis , marker , data Area ) ; } } }
public  VPFFeature Layer ( ) { set Projection Change Policy ( new com . bbn . openmap . layer . policy .  List Reset PCPolicy ( this ) ) ; set Mouse Mode IDs For Events ( new  String [ ] { _ STR } ) ; warehouse = new  VPFAuto Feature Graphic Warehouse ( ) ; }
protected void release (  Pooled Connection con ) { if ( con == null ) return ; try { con . lock ( ) ; if ( con . release ( ) ) { size . add And Get ( - _ NUM ) ; con . set Handler ( null ) ; } } finally { con . unlock ( ) ; } if ( waitcount . get ( ) > _ NUM ) { idle . offer ( create ( _ BOOL ) ) ; } }
private float limit ( float value , float min , float max ) { return  Math . min (  Math . max ( min , value ) , max ) ; }
public void shutdown ( long timeout ,  Time Unit unit ) throws  Interrupted Exception { executor . shutdown ( ) ; executor . await Termination ( timeout , unit ) ; }
public long file Size (  String path ) throws  Illegal State Exception ,  IOException ,  FTPIllegal Reply Exception ,  FTPException { synchronized ( lock ) { if ( ! connected ) { throw new  Illegal State Exception ( _ STR ) ; } if ( ! authenticated ) { throw new  Illegal State Exception ( _ STR ) ; } communication . send FTPCommand ( _ STR ) ;  FTPReply r = communication . read FTPReply ( ) ; touch Auto Noop Timer ( ) ; if ( ! r . is Success Code ( ) ) { throw new  FTPException ( r ) ; } communication . send FTPCommand ( _ STR + path ) ; r = communication . read FTPReply ( ) ; touch Auto Noop Timer ( ) ; if ( ! r . is Success Code ( ) ) { throw new  FTPException ( r ) ; }  String [ ] messages = r . get Messages ( ) ; if ( messages . length != _ NUM ) { throw new  FTPIllegal Reply Exception ( ) ; } else { try { return  Long . parse Long ( messages [ _ NUM ] ) ; } catch (  Throwable t ) { throw new  FTPIllegal Reply Exception ( ) ; } } } }
@  Override public  Column column ( int column Index ) { return column List . get ( column Index ) ; }
public boolean compute Scroll Offset ( ) { if ( m Finished ) { return _ BOOL ; } final long time Passed =  Animation Utils . current Animation Time Millis ( ) - m Start Time ; float time Passed Percent = time Passed * _ NUM / m Duration ; if ( time Passed >= m Duration ) { m Finished = _ BOOL ; time Passed Percent = _ NUM ; } m Curr Value =  Math . round ( m Value Factor * m Path Points Holder . get Y ( time Passed Percent ) ) ; return _ BOOL ; }
public void report (  Quality Query qq ,  Top Docs td ,  String doc Name Field ,  Index Searcher searcher ) throws  IOException { if ( logger == null ) { return ; }  Score Doc sd [ ] = td . score Docs ;  String sep = _ STR ;  Doc Name Extractor xt = new  Doc Name Extractor ( doc Name Field ) ; for ( int i = _ NUM ; i < sd . length ; i ++ ) {  String doc Name = xt . doc Name ( searcher , sd [ i ] . doc ) ; logger . println ( qq . get Query ID ( ) + sep + _ STR + sep + format ( doc Name , _ NUM ) + sep + format ( _ STR + i , _ NUM ) + sep + nf . format ( sd [ i ] . score ) + sep + name ) ; } }
public  String num Attributes Tip Text ( ) { return _ STR ; }
@  Override public synchronized void maybe Start Tracking Job (  Job Status job ) { if ( job . has Timing Delay Constraint ( ) || job . has Deadline Constraint ( ) ) { maybe Stop Tracking Job ( job ) ;  List Iterator <  Job Status > it = m Tracked Jobs . list Iterator ( m Tracked Jobs . size ( ) ) ; while ( it . has Previous ( ) ) {  Job Status ts = it . previous ( ) ; if ( ts . get Latest Run Time Elapsed ( ) < job . get Latest Run Time Elapsed ( ) ) { break ; } } it . add ( job ) ; maybe Update Alarms ( job . has Timing Delay Constraint ( ) ? job . get Earliest Run Time ( ) :  Long .  MAX_ VALUE , job . has Deadline Constraint ( ) ? job . get Latest Run Time Elapsed ( ) :  Long .  MAX_ VALUE ) ; } }
private void release Waiters ( int phase ) {  QNode q ;  Thread t ;  Atomic Reference <  QNode > head = ( phase & _ NUM ) == _ NUM ? even Q : odd Q ; while ( ( q = head . get ( ) ) != null && q . phase != ( int ) ( root . state > > >  PHASE_ SHIFT ) ) { if ( head . compare And Set ( q , q . next ) && ( t = q . thread ) != null ) { q . thread = null ;  Lock Support . unpark ( t ) ; } } }
public final void open Fallback Output Stream ( ) throws  Data Fallback Exception { if ( output == null ) { if (  LOG . is Debug Enabled ( ) )  LOG . debug ( _ STR + data File . get Name ( ) + _ STR ) ; try { output = new  Buffered Writer ( new  File Writer ( data File , _ BOOL ) ) ; } catch (  IOException e ) { throw new  Data Fallback Exception ( e . get Message ( ) ) ; } } }
public void add Memory Listener ( final  IMemory Listener listener ) {  Preconditions . check Not Null ( listener , _ STR ) ; m_listeners . add ( listener ) ; }
static public  Serial Sensor Manager instance ( ) { if ( _instance == null ) { _instance = new  Serial Sensor Manager ( ) ; } return _instance ; }
public  Collection <  IDevice > filter By Used ( @  Not Null  Collection <  IDevice > devices ) {  Set <  IDevice > used =  Sets . new Hash Set With Expected Size ( my Devices Used In Launch . size ( ) ) ; for (  IDevice d : devices ) { if ( my Devices Used In Launch . contains ( d . get Serial Number ( ) ) ) { used . add ( d ) ; } } return used ; }
public  String to Id String (  Object id ) { if ( id == null ) return null ; return id . to String ( ) ; }
public boolean is Used ( long pos , int length ) { int start = get Block ( pos ) ; int blocks = get Block Count ( length ) ; for ( int i = start ; i < start + blocks ; i ++ ) { if ( ! set . get ( i ) ) { return _ BOOL ; } } return _ BOOL ; }
public  Cholesky Decomposition (  Matrix  Arg ) { double [ ] [ ]  A =  Arg . get Array ( ) ; n =  Arg . get Row Dimension ( ) ;  L = new double [ n ] [ n ] ; isspd = (  Arg . get Column Dimension ( ) == n ) ; for ( int j = _ NUM ; j < n ; j ++ ) { double [ ]  Lrowj =  L [ j ] ; double d = _ NUM ; for ( int k = _ NUM ; k < j ; k ++ ) { double [ ]  Lrowk =  L [ k ] ; double s = _ NUM ; for ( int i = _ NUM ; i < k ; i ++ ) { s +=  Lrowk [ i ] *  Lrowj [ i ] ; }  Lrowj [ k ] = s = (  A [ j ] [ k ] - s ) /  L [ k ] [ k ] ; d = d + s * s ; isspd = isspd & (  A [ k ] [ j ] ==  A [ j ] [ k ] ) ; } d =  A [ j ] [ j ] - d ; isspd = isspd & ( d > _ NUM ) ;  L [ j ] [ j ] =  Math . sqrt (  Math . max ( d , _ NUM ) ) ; for ( int k = j + _ NUM ; k < n ; k ++ ) {  L [ j ] [ k ] = _ NUM ; } } }
public  Memory ( ) { this ( _ BOOL ) ; }
@  Override public void agg (  Object new Val ) { value Set . add ( new Val instanceof  Double ? (  Double ) new Val : new  Double ( new Val . to String ( ) ) ) ; first Time = _ BOOL ; }
private void add Legion Member (  Legion legion ,  Player player ) { add Legion Member ( legion , player ,  Legion Rank .  VOLUNTEER ) ; }
public static char [ ] clone Char Array ( char [ ] chars ) { if ( chars == null ) { return null ; } int len = chars . length ; if ( len == _ NUM ) { return chars ; } char [ ] copy = new char [ len ] ;  System . arraycopy ( chars , _ NUM , copy , _ NUM , len ) ; return copy ; }
public  Iterator <  Soot Method > method Iterator ( ) { check Level (  SIGNATURES ) ; return method List . iterator ( ) ; }
public static  String unescape HTML (  String str ) {  String Builder rtn = new  String Builder ( ) ; int pos Start = - _ NUM ; int pos Finish = - _ NUM ; while ( ( pos Start = str . index Of ( _ STR , pos Start ) ) != - _ NUM ) { int last = pos Finish + _ NUM ; pos Finish = str . index Of ( _ STR , pos Start ) ; if ( pos Finish == - _ NUM ) break ; rtn . append ( str . substring ( last , pos Start ) ) ; if ( pos Start + _ NUM < pos Finish ) { rtn . append ( unescape HTMLEntity ( str . substring ( pos Start + _ NUM , pos Finish ) ) ) ; } else { rtn . append ( _ STR ) ; } pos Start = pos Finish + _ NUM ; } rtn . append ( str . substring ( pos Finish + _ NUM ) ) ; return rtn . to String ( ) ; }
public  Connection put Connection (  Connection connection ) { return connections . put ( connection . get Identifier ( ) , connection ) ; }
public  Transit create New Transit (  String user Name ) { boolean found = _ BOOL ;  String test Name = _ STR ;  Transit z ; while ( ! found ) { int next Auto Transit Ref = last Auto Transit Ref + _ NUM ; test Name = _ STR + next Auto Transit Ref ; z = get By System Name ( test Name ) ; if ( z == null ) { found = _ BOOL ; } last Auto Transit Ref = next Auto Transit Ref ; } return create New Transit ( test Name , user Name ) ; }
private boolean step2 ( ) { if (  RV == null ) return _ BOOL ; if (  RV . length ( ) >= _ NUM ) { if ( suffix (  RV , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  RV , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  RV , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  RV , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  RV , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  RV , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } } if (  RV . length ( ) >= _ NUM ) { if ( suffix (  RV , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  RV , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  RV , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  RV , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  RV , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  RV , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  RV , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  RV , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  RV , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  RV , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  RV , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  RV , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  RV , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } } if (  RV . length ( ) >= _ NUM ) { if ( suffix (  RV , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  RV , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  RV , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  RV , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  RV , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  RV , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  RV , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  RV , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  RV , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  RV , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  RV , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  RV , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  RV , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  RV , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  RV , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  RV , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  RV , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  RV , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  RV , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  RV , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  RV , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  RV , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  RV , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  RV , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  RV , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  RV , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  RV , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } } if (  RV . length ( ) >= _ NUM ) { if ( suffix (  RV , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  RV , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  RV , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  RV , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  RV , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  RV , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  RV , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  RV , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  RV , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  RV , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  RV , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  RV , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  RV , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  RV , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  RV , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  RV , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  RV , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  RV , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  RV , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  RV , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  RV , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  RV , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  RV , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  RV , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  RV , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  RV , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  RV , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  RV , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  RV , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  RV , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  RV , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  RV , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  RV , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  RV , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  RV , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  RV , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  RV , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  RV , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  RV , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  RV , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  RV , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } } if (  RV . length ( ) >= _ NUM ) { if ( suffix (  RV , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  RV , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  RV , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  RV , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  RV , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  RV , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  RV , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  RV , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  RV , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  RV , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  RV , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  RV , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  RV , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } } if (  RV . length ( ) >= _ NUM ) { if ( suffix (  RV , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  RV , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  RV , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  RV , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  RV , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  RV , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  RV , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  RV , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  RV , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  RV , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  RV , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  RV , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  RV , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  RV , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } } return _ BOOL ; }
void open ( int context Prec , int own Prec ) throws  IOException { if ( own Prec < context Prec ) out . write ( _ STR ) ; }
public void load Icon Callback ( byte [ ] data , int width , int height , int row Stride , int bps , int channels , boolean alpha ) { tmp Image = null ;  Data Buffer data Buf = new  Data Buffer Byte ( data , ( row Stride * height ) ) ;  Writable Raster raster =  Raster . create Interleaved Raster ( data Buf , width , height , row Stride , channels , ( alpha ?  BAND_ OFFSETS_ ALPHA :  BAND_ OFFSETS ) , null ) ;  Color Model color Model = new  Component Color Model (  Color Space . get Instance (  Color Space .  CS_s RGB ) , alpha , _ BOOL ,  Color Model .  TRANSLUCENT ,  Data Buffer .  TYPE_ BYTE ) ; tmp Image = new  Buffered Image ( color Model , raster , _ BOOL , null ) ; }
public void clear ( ) { clear ( _ BOOL ) ; }
@  Override default  Completable Future <  Optional Double > max Double ( final  To Double Function < ? super  T > fn ) { return  Completable Future . supply Async ( null , get Exec ( ) ) ; }
public int next Int ( ) { return next ( _ NUM ) ; }
private  List <  String > fetch Titles (  String category ) throws  Speechlet Exception {  List <  String > titles = new  Linked List <  String > ( ) ; try {  Document Builder Factory dbf =  Document Builder Factory . new Instance ( ) ;  Document Builder db = dbf . new Document Builder ( ) ;  Document doc = db . parse ( get Request Url ( category ) ) ;  Node List node List = doc . get Elements By Tag Name ( _ STR ) ; for ( int i = _ NUM ; i < node List . get Length ( ) ; i ++ ) {  Node node = node List . item ( i ) ; titles . add ( node . get Text Content ( ) ) ; } } catch (  Exception e ) { throw new  Speechlet Exception ( e ) ; } return titles ; }
public  Distributed Log Configuration ( ) { super ( ) ; add Configuration ( new  System Configuration ( ) ) ; }
public  Builder add Part (  Part part ) { if ( part == null ) throw new  Null Pointer Exception ( _ STR ) ; parts . add ( part ) ; return this ; }
@  Override public void on Location Changed (  Location location ) { if (  GPS . equals ( location . get Provider ( ) ) ) { m Gps Location = location ; update Fused Location ( ) ; } else if (  NETWORK . equals ( location . get Provider ( ) ) ) { m Network Location = location ; update Fused Location ( ) ; } }
public  CData Node Component ( final  INavi Module module , final  IView Container origin Container ) { super ( new  Border Layout ( ) ) ;  Preconditions . check Not Null ( module , _ STR ) ; final  Jide Split Pane split Pane = new  Jide Split Pane (  Jide Split Pane .  VERTICAL_ SPLIT ) ; split Pane . set Double Buffered ( _ BOOL ) ; split Pane . set One Touch Expandable ( _ BOOL ) ; split Pane . set Minimum Size ( new  Dimension ( _ NUM , _ NUM ) ) ; split Pane . set Proportional Layout ( _ BOOL ) ; split Pane . set Initially Even ( _ BOOL ) ; final  JPanel panel = new  JPanel ( new  Border Layout ( ) ) ; data Section Component = new  Data Section Component ( module , origin Container ) ; panel . add ( data Section Component ) ; final  JTabbed Pane pane = new  JTabbed Pane ( ) ; pane . add Tab ( _ STR , new  CNavigation Panel ( data Section Component . get Hex View ( ) ) ) ; split Pane . add Pane ( panel ) ; split Pane . add Pane ( pane ) ; add ( split Pane ) ; }
public  Painter Chain add Painter (  Painter p ) { if ( chain . length != _ NUM ) {  Painter [ ] new Chain = new  Painter [ chain . length + _ NUM ] ;  System . arraycopy ( chain , _ NUM , new Chain , _ NUM , chain . length ) ; new Chain [ chain . length ] = p ; return new  Painter Chain ( new Chain ) ; } return new  Painter Chain ( new  Painter [ ] { p } ) ; }
public  Executor env (  Map <  String ,  String > env ) { this . env = env ; return this ; }
private final boolean add Direction (  Array List <  Move > move List ,  Position pos , int sq0 , int max Steps , int delta ) { int sq = sq0 ; boolean wtm = pos . white Move ; final int o King = ( wtm ?  Piece .  BKING :  Piece .  WKING ) ; while ( max Steps > _ NUM ) { sq += delta ; int p = pos . get Piece ( sq ) ; if ( p ==  Piece .  EMPTY ) { move List . add ( get Move Obj ( sq0 , sq ,  Piece .  EMPTY ) ) ; } else { if (  Piece . is White ( p ) != wtm ) { if ( p == o King ) { return Move List ( move List ) ; move List = get Move List Obj ( ) ; move List . add ( get Move Obj ( sq0 , sq ,  Piece .  EMPTY ) ) ; return _ BOOL ; } else { move List . add ( get Move Obj ( sq0 , sq ,  Piece .  EMPTY ) ) ; } } break ; } max Steps -- ; } return _ BOOL ; }
public  Searcher ( ) throws  IOException { searcher = new  Index Searcher (  Directory Reader . open (  FSDirectory . open (  Paths . get (  INDEX_ DIR ) ) ) ) ; parser = new  Query Parser (  CONTENT_ FIELD , new  Standard Analyzer ( ) ) ; }
private static  Element add Bean (  Document doc ,  Node parent ,  Class < ? > cls ) {  Element elem = doc . create Element ( _ STR ) ; elem . set Attribute ( _ STR , cls . get Name ( ) ) ; parent . append Child ( elem ) ; return elem ; }
protected static void copy (  Input Stream in ,  Output Stream out ) { byte [ ] buffer = new byte [ _ NUM ] ; int read ; try { while ( ( read = in . read ( buffer ) ) > - _ NUM ) { out . write ( buffer , _ NUM , read ) ; } } catch (  IOException e ) { e . print Stack Trace ( ) ; } }
private  String build Remote Name (  String account Name ,  String remote Path ) { return account Name + remote Path ; }
public static  String encrypt With Symmetric Key (  String data ,  String enc Algorithm ,  String secret ) throws  Exception { try {  String algorithm = enc Algorithm ; if ( ! algorithm . starts With ( _ STR ) ) { algorithm = _ STR + enc Algorithm ; }  Secret Key Factory sk Factory =  Secret Key Factory . get Instance ( algorithm ) ;  PBEKey Spec pbe Key Spec = new  PBEKey Spec ( secret . to Char Array ( ) ) ;  Secret Key s Key = sk Factory . generate Secret ( pbe Key Spec ) ;  Cipher cipher =  Cipher . get Instance ( algorithm ) ; cipher . init (  Cipher .  ENCRYPT_ MODE , s Key , pbe Parameter Spec ) ; byte [ ] enc Data = cipher . do Final ( data . get Bytes ( _ STR ) ) ; enc Data = add Prefix ( enc Data ) ; return  Base64 . encode ( enc Data ) ; } catch (  No Such Algorithm Exception nse ) { throw new  Exception ( nse . get Message ( ) ) ; } }
public static  String left Pad (  String original , int length , char pad Char ) { if ( original . length ( ) >= length ) { return original ; } return string Of Char ( pad Char , length - original . length ( ) ) + original ; }
protected  View on Content View Created (  View content View ) { return content View ; }
void reset ( ) {  System . arraycopy ( iv , _ NUM , r , _ NUM , block Size ) ; }
private static void fix Rectangle Orientation ( double [ ] m ,  Rectangle2 D clip ) { if ( clip . get Width ( ) > _ NUM != ( m [ _ NUM ] - m [ _ NUM ] > _ NUM ) ) { double t = m [ _ NUM ] ; m [ _ NUM ] = m [ _ NUM ] ; m [ _ NUM ] = t ; } if ( clip . get Height ( ) > _ NUM != ( m [ _ NUM ] - m [ _ NUM ] > _ NUM ) ) { double t = m [ _ NUM ] ; m [ _ NUM ] = m [ _ NUM ] ; m [ _ NUM ] = t ; } }
private void bind Session ( ) {  Session Factory session Factory = (  Session Factory ) get Bean ( _ STR ) ;  Session session = session Factory . open Session ( ) ;  Transaction Synchronization Manager . bind Resource ( session Factory , new  Session Holder ( session ) ) ; }
public  CAction Select Same Function Type ( final  Zy Graph graph , final  Function Type function Type ) { super (  String . format ( _ STR , function Type ) ) ; m_graph =  Preconditions . check Not Null ( graph , _ STR ) ; m_function Type =  Preconditions . check Not Null ( function Type , _ STR ) ; }
public void append ( byte [ ] bytes , int offset , int len ) { ensure Capacity ( length + len ) ;  System . arraycopy ( bytes , offset , buffer , length , len ) ; length += len ; }
public  Permissions Activity with Permissions ( @  Non Null  Permission ... permissions ) {  Collections . add All ( this . permissions , permissions ) ; return this ; }
public void fill Polygon ( int [ ] x Points , int [ ] y Points , int n Points ) { int [ ] c X = x Points ; int [ ] c Y = y Points ; if ( ( ! impl . is Translation Supported ( ) ) && ( x Translate != _ NUM || y Translate != _ NUM ) ) { c X = new int [ n Points ] ; c Y = new int [ n Points ] ;  System . arraycopy ( x Points , _ NUM , c X , _ NUM , n Points ) ;  System . arraycopy ( y Points , _ NUM , c Y , _ NUM , n Points ) ; for ( int iter = _ NUM ; iter < n Points ; iter ++ ) { c X [ iter ] += x Translate ; c Y [ iter ] += y Translate ; } } impl . fill Polygon ( native Graphics , c X , c Y , n Points ) ; }
public void output (  String msg ) { out . println ( msg ) ; }
private  List <  Facet Result > search ( ) throws  IOException {  Directory Reader index Reader =  Directory Reader . open ( index Dir ) ;  Index Searcher searcher = new  Index Searcher ( index Reader ) ;  Taxonomy Reader taxo Reader = new  Directory Taxonomy Reader ( taxo Dir ) ;  Facets Collector fc = new  Facets Collector ( ) ;  Facets Collector . search ( searcher , new  Match All Docs Query ( ) , _ NUM , fc ) ;  List <  Facet Result > results = new  Array List < > ( ) ;  Facets author = new  Fast Taxonomy Facet Counts ( _ STR , taxo Reader , config , fc ) ; results . add ( author . get Top Children ( _ NUM , _ STR ) ) ;  Facets pub Date = new  Fast Taxonomy Facet Counts ( _ STR , taxo Reader , config , fc ) ; results . add ( pub Date . get Top Children ( _ NUM , _ STR ) ) ; index Reader . close ( ) ; taxo Reader . close ( ) ; return results ; }
public  Compactor major Index ( long index ) { this . major Index =  Math . max ( this . major Index , index ) ; return this ; }
public final void to String (  String Builder builder ) { builder . append ( get Name ( ) ) ; }
public void init (  Filter Config filter Config ) throws  Servlet Exception { this . filter Config = filter Config ; this . encoding = filter Config . get Init Parameter ( _ STR ) ;  String value = filter Config . get Init Parameter ( _ STR ) ; if ( value == null ) this . ignore = _ BOOL ; else if ( value . equals Ignore Case ( _ STR ) ) this . ignore = _ BOOL ; else if ( value . equals Ignore Case ( _ STR ) ) this . ignore = _ BOOL ; else this . ignore = _ BOOL ; }
void add Label (  Component label ) { if ( labels == null ) { labels = new  Vector ( ) ; } labels . add Element ( label ) ; }
public  Vector rotate XY ( final double angle ) { return rotate XY (  Math . sin ( angle ) ,  Math . cos ( angle ) ) ; }
public void disconnect ( ) { connected = _ BOOL ; synchronized ( conn Lost Wait ) { conn Lost Wait . notify ( ) ; } if ( mqtt != null ) { try { mqtt . disconnect ( ) ; } catch (  Exception ex ) { set Title Text ( _ STR ) ; ex . print Stack Trace ( ) ;  System . exit ( _ NUM ) ; } } if ( led . is Flashing ( ) ) { led . set Flash ( ) ; } led . set Red ( ) ; set Connected ( _ BOOL ) ; synchronized ( this ) { write Logln ( _ STR ) ; } }
public boolean contains Header Out (  String name ) {  Array List <  String > header Keys = _header Keys Out ; int size = header Keys . size ( ) ; for ( int i = _ NUM ; i < size ; i ++ ) {  String old Key = header Keys . get ( i ) ; if ( old Key . equals Ignore Case ( name ) ) { return _ BOOL ; } } if ( name . equals Ignore Case ( _ STR ) ) { return _content Type Out != null ; } if ( name . equals Ignore Case ( _ STR ) ) { return _content Length Out >= _ NUM ; } return _ BOOL ; }
public static  Map <  String ,  Set <  String > > clone Map (  Map <  String ,  Set <  String > > map ) {  Map <  String ,  Set <  String > > clone = new  Hash Map <  String ,  Set <  String > > ( ) ; for (  String key : map . key Set ( ) ) {  Set <  String > set = new  Hash Set <  String > ( ) ;  Set <  String > orig = (  Set <  String > ) map . get ( key ) ; set . add All ( orig ) ; clone . put ( key , set ) ; } return clone ; }
public org . w3c . dom .  Element sign With SAMLToken ( org . w3c . dom .  Document doc , java . security . cert .  Certificate cert ,  String assertion ID , java . lang .  String algorithm , java . util .  List ids ) throws  XMLSignature Exception { return null ; }
private  URL create Search URL (  URL url ) throws  Malformed URLException { if ( url == null ) { return url ; }  String protocol = url . get Protocol ( ) ; if ( is Directory ( url ) || protocol . equals ( _ STR ) ) { return url ; } if ( factory == null ) { return new  URL ( _ STR , _ STR , - _ NUM , url . to String ( ) + _ STR ) ; } return new  URL ( _ STR , _ STR , - _ NUM , url . to String ( ) + _ STR , factory . create URLStream Handler ( _ STR ) ) ; }
private static int st To IJ ( double s ) { final int m =  MAX_ SIZE / _ NUM ; return ( int )  Math . max ( _ NUM ,  Math . min ( _ NUM * m - _ NUM ,  Math . round ( m * s + ( m - _ NUM ) ) ) ) ; }
public void init ( ) { }
protected  Document create Configuration Document (  AVList params ) {  Document doc = super . create Configuration Document ( params ) ; if ( doc == null || doc . get Document Element ( ) == null ) return doc ;  Data Configuration Utils . create WMSLayer Config Elements ( params , doc . get Document Element ( ) ) ; return doc ; }
protected void draw Rect ( int x , int y , int w , int h ,  Color fill Color ,  Paint fill Paint ,  Color pen Color , boolean shadow , boolean rounded ) { int radius = ( rounded ) ? get Arc Size ( w , h ) : _ NUM ; if ( fill Color != null || fill Paint != null ) { if ( shadow ) { g . set Color ( mx Constants .  SHADOW_ COLOR ) ; if ( rounded ) { g . fill Round Rect ( x + mx Constants .  SHADOW_ OFFSETX , y + mx Constants .  SHADOW_ OFFSETY , w , h , radius , radius ) ; } else { g . fill Rect ( x + mx Constants .  SHADOW_ OFFSETX , y + mx Constants .  SHADOW_ OFFSETY , w , h ) ; } } if ( fill Paint != null ) { g . set Paint ( fill Paint ) ; } else { g . set Color ( fill Color ) ; } if ( rounded ) { g . fill Round Rect ( x , y , w , h , radius , radius ) ; } else { if ( g . get Clip Bounds ( ) != null ) {  Rectangle rect = new  Rectangle ( x , y , w , h ) ; g . fill ( rect . intersection ( g . get Clip Bounds ( ) ) ) ; } else { g . fill Rect ( x , y , w , h ) ; } } } if ( pen Color != null ) { g . set Color ( pen Color ) ; if ( rounded ) { g . draw Round Rect ( x , y , w , h , radius , radius ) ; } else { g . draw Rect ( x , y , w , h ) ; } } }
public boolean is Static ( ) { return  Modifier . is Static ( modifier ) ; }
public void define Line Style ( int width ,  Color color ) throws  IOException { line Styles . add ( new  Line Style ( width , color ) ) ; outstanding Changes = _ BOOL ; }
@  Override public  String to String ( ) {  String Builder sb = new  String Builder ( ) ; sb . append ( _ STR ) ; final int end = offset + length ; for ( int i = offset ; i < end ; i ++ ) { if ( i > offset ) { sb . append ( _ STR ) ; } sb . append (  Integer . to Hex String ( bytes [ i ] & _ NUM ) ) ; } sb . append ( _ STR ) ; return sb . to String ( ) ; }
public void init (  String component Name ) throws  Log Exception { access Logger = ( com . sun . identity . log .  Logger )  Logger . get Logger ( component Name + _ STR ) ; error Logger = ( com . sun . identity . log .  Logger )  Logger . get Logger ( component Name + _ STR ) ; try { msg Provider =  Message Provider Factory . get Provider ( component Name ) ; } catch (  IOException e ) { debug . error ( _ STR , e ) ; } }
private  View fill Right ( int pos , int next Left ) {  View selected View = null ; int end = ( get Right ( ) - get Left ( ) ) ; while ( next Left < end && pos < m Item Count ) { boolean selected = pos == m Selected Position ;  View child = make And Add View ( pos , next Left , _ BOOL , m List Padding . top , selected ) ; next Left = child . get Right ( ) + m Divider Width ; if ( selected ) { selected View = child ; } pos ++ ; } set Visible Range Hint ( m First Position , m First Position + get Child Count ( ) - _ NUM ) ; return selected View ; }
public void add Default Value (  String value ) throws  SMSException ,  SSOException {  Set default Values = get Default Values ( ) ; if ( default Values !=  Collections .  EMPTY_ SET ) { default Values . add ( value ) ; } else { default Values = new  Hash Set ( ) ; default Values . add ( value ) ; } update Default Values ( default Values ) ; }
public static int key Binding Description To Key Modifier (  String key Binding Description ) { if (  String Utils . is Blank ( key Binding Description ) ) { return _ NUM ; } else if ( key Binding Description . starts With ( _ STR ) ) { return  SWT .  ALT ; } else if ( key Binding Description . starts With ( _ STR ) ) { return  SWT .  CTRL ; } else if ( key Binding Description . starts With ( _ STR ) ) { return  SWT .  COMMAND ; } else { return _ NUM ; } }
private void add To Map (  Map <  String ,  Collection <  Cluster Node > > cache Map ,  String cache Name ,  Cluster Node rich ) {  Collection <  Cluster Node > cache Nodes = cache Map . get ( cache Name ) ; if ( cache Nodes == null ) { cache Nodes = new  Array List < > ( all Nodes . size ( ) ) ; cache Map . put ( cache Name , cache Nodes ) ; } cache Nodes . add ( rich ) ; }
protected double multiply ( double [ ] [ ] mat , double [ ] in , double [ ] out ) { double l = _ NUM ; for ( int d1 = _ NUM ; d1 < in . length ; d1 ++ ) { final double [ ] row = mat [ d1 ] ; double t = _ NUM ; for ( int d2 = _ NUM ; d2 < in . length ; d2 ++ ) { t += row [ d2 ] * in [ d2 ] ; } out [ d1 ] = t ; l += t * t ; } return l > _ NUM ?  Math . sqrt ( l ) : _ NUM ; }
public  Ignite Deployment Checked Exception (  Throwable cause ) { this ( cause . get Message ( ) , cause ) ; }
@  Override public boolean equals (  Object obj ) { if ( obj == this ) { return _ BOOL ; } if ( obj == null ) { return _ BOOL ; } if ( ! ( get Class ( ) == obj . get Class ( ) ) ) { return _ BOOL ; } return super . equals ( obj ) ; }
public static  String encode Java Opts (  String java Opts ) {  String java Opts Base64 =  Datatype Converter . print Base64 Binary ( java Opts . get Bytes (  Charset . for Name ( _ STR ) ) ) ; return  String . format ( _ STR , java Opts Base64 . replace ( _ STR , _ STR ) ) ; }
public void pause ( ) { pause Time =  System . current Time Millis ( ) ; }
public void property Change (  Property Change Event pce ) { if ( pce . get Property Name ( ) ==  Map Bean .  Background Property ) { map Bean . set Bckgrnd ( (  Paint ) pce . get New Value ( ) ) ; } }
public  Section Builder add Frame ( int image Resource ) { m Frames . add ( image Resource ) ; return this ; }
public  String to String ( ) { return _ STR +  Integer . to Hex String ( hash Code ( ) ) + ( location == null ? _ STR : _ STR + location + _ STR ) ; }
public  Light provide Light (  String name ) {  Light t = get Light ( name ) ; if ( t != null ) { return t ; } if ( name . starts With ( get System Prefix ( ) + type Letter ( ) ) ) { return new Light ( name , null ) ; } else if ( name . length ( ) > _ NUM ) { return new Light ( make System Name ( name ) , null ) ; } else { throw new  Illegal Argument Exception ( _ STR + name + _ STR ) ; } }
protected  String create Context Xml (  WAR war ) {  String Builder buffer = new  String Builder ( ) ; buffer . append ( _ STR ) ; buffer . append ( _ STR + _ STR ) ; buffer . append ( _ STR ) ; buffer . append ( _ STR ) ; buffer . append ( _ STR ) ; buffer . append ( _ STR ) ; buffer . append ( _ STR ) ; buffer . append ( _ STR ) ; buffer . append ( _ STR ) ; buffer . append ( _ STR ) ; buffer . append ( _ STR + war . get Context ( ) + _ STR ) ; buffer . append ( _ STR + war . get File ( ) + _ STR ) ; buffer . append ( _ STR ) ; buffer . append ( _ STR + _ STR ) ; buffer . append ( _ STR ) ; buffer . append ( get Extra Classpath Xml Fragment ( war ) ) ; buffer . append ( get Shared Classpath Xml Fragment ( ) ) ; buffer . append ( _ STR ) ; return buffer . to String ( ) ; }
private  Array DBIDs compute M_current (  DBIDs m ,  DBIDs m_best ,  DBIDs m_bad ,  Random random ) {  Array Modifiable DBIDs m_list =  DBIDUtil . new Array ( m ) ; m_list . remove DBIDs ( m_best ) ;  DBIDArray MIter it = m_list . iter ( ) ;  Array Modifiable DBIDs m_current =  DBIDUtil . new Array ( ) ; for (  DBIDIter iter = m_best . iter ( ) ; iter . valid ( ) ; iter . advance ( ) ) { if ( m_bad . contains ( iter ) ) { int current Size = m_current . size ( ) ; while ( m_current . size ( ) == current Size ) { m_current . add ( it . seek ( random . next Int ( m_list . size ( ) ) ) ) ; it . remove ( ) ; } } else { m_current . add ( iter ) ; } } return m_current ; }
public final double do Operation ( ) throws  Operator Failed Exception {  Node Ref root = tree . get Root ( ) ;  List <  Node Ref > candidates = new  Array List <  Node Ref > ( ) ; for ( int i = _ NUM ; i < tree . get Node Count ( ) ; i ++ ) {  Node Ref node = tree . get Node ( i ) ; if ( node != root && tree . get Parent ( node ) != root ) {  Node Ref parent = tree . get Parent ( node ) ; int sum = rate Change ( tree , node ) + rate Change ( tree , parent ) ; if ( sum == _ NUM ) candidates . add ( node ) ; } } if ( candidates . size ( ) == _ NUM ) throw new  Operator Failed Exception ( _ STR ) ;  Node Ref node = candidates . get (  Math Utils . next Int ( candidates . size ( ) ) ) ;  Node Ref parent = tree . get Parent ( node ) ; double node Trait , parent Trait ; double node Rate , parent Rate ; node Trait = tree . get Node Trait ( node , indicator Trait ) ; parent Trait = tree . get Node Trait ( parent , indicator Trait ) ; tree . set Node Trait ( node , indicator Trait , parent Trait ) ; tree . set Node Trait ( parent , indicator Trait , node Trait ) ; if ( trait2 != null ) { node Trait = tree . get Node Trait ( node , trait2 ) ; parent Trait = tree . get Node Trait ( parent , trait2 ) ; tree . set Node Trait ( node , trait2 , parent Trait ) ; tree . set Node Trait ( parent , trait2 , node Trait ) ; } else { node Rate = tree . get Node Rate ( node ) ; parent Rate = tree . get Node Rate ( parent ) ; tree . set Node Rate ( node , parent Rate ) ; tree . set Node Rate ( parent , node Rate ) ; } return _ NUM ; }
@  Deprecated public final boolean is Initialized ( ) { return _ BOOL ; }
public  String to String ( ) { return  Double . to String ( get Value ( ) ) ; }
public void start ( ) { if ( cameras != null ) {  Camera Descriptor camera = cameras . get ( current Camera ) ;  Camera View cv = get Preview ( camera ) ; if ( cv . is Available ( ) ) { open ( ) ; } } }
public void append Only First (  String s ) { if ( index == _ NUM ) { builder . append ( s ) ; } }
public static byte [ ] read Bytes (  Input Stream in ) throws  IOException {  Byte Array Output Stream out = new  Byte Array Output Stream ( _ NUM ) ; transfer ( in , out ) ; return out . to Byte Array ( ) ; }
private void create Lookup Table Data (  Transform Context context ) { for (  String key : mapping Values . key Set ( ) ) {  Value Mapping mapping = mapping Values . get ( key ) ;  String lookup Table Name = mapping . get Lookup Table Name ( ) ; if ( ! lookup Table Cache . contains Key ( lookup Table Name ) ) {  Lookup Table Config table Config = new  Lookup Table Config (  Lookup Table Config .  Table Type .  DATASET ) ;  Lookup <  String > lookup Table = context . provide ( lookup Table Name , table Config . get Dataset Properties ( ) ) ; lookup Table Cache . put ( lookup Table Name , lookup Table ) ; } } }
public static double sum Squared Error ( double [ ] a , double [ ] b ) { if ( a . length != b . length ) { throw new  Illegal Argument Exception ( _ STR ) ; } double sum = _ NUM ; for ( int i = _ NUM ; i < a . length ; i ++ ) { double delta = a [ i ] - b [ i ] ; if ( !  Double . is Na N ( delta ) ) { sum += delta * delta ; } } return sum ; }
public static  String to Hex String ( byte [ ] value ) { if ( value == null ) { return null ; }  String Buffer buffer = new  String Buffer ( _ NUM * value . length ) ; int single ; for ( int i = _ NUM ; i < value . length ; i ++ ) { single = value [ i ] & _ NUM ; if ( single < _ NUM ) { buffer . append ( _ STR ) ; } buffer . append (  Integer . to String ( single , _ NUM ) ) ; } return buffer . to String ( ) ; }
public void execute (  String desc ,  Consumer <  Mongo Client > operation ) { while ( _ BOOL ) {  Mongo Client primary = primary Connection Supplier . get ( ) ; try { operation . accept ( primary ) ; return ; } catch (  Throwable t ) { error Handler . accept ( desc , t ) ; } } }
public int read ( char [ ] cbuf ) throws java . io .  IOException { return read ( cbuf , _ NUM , cbuf . length ) ; }
private  Control create Details Viewer ( final  Composite parent ) { if ( details == null ) { return null ; } final  Text text = new  Text ( parent ,  SWT .  MULTI |  SWT .  READ_ ONLY |  SWT .  BORDER |  SWT .  H_ SCROLL |  SWT .  V_ SCROLL ) ; text . set Layout Data ( new  Grid Data (  Grid Data .  FILL_ BOTH ) ) ; final  String Writer writer = new  String Writer ( _ NUM ) ; if ( details instanceof  Throwable ) { append Exception ( new  Print Writer ( writer ) , (  Throwable ) details ) ; } else if ( details instanceof  IStatus ) { append Command Status ( new  Print Writer ( writer ) , (  IStatus ) details , _ NUM ) ; } text . set Text ( writer . to String ( ) ) ; return text ; }
public  String param String ( ) {  String type Str ; switch ( id ) { case  INPUT_ METHOD_ TEXT_ CHANGED : type Str = _ STR ; break ; case  CARET_ POSITION_ CHANGED : type Str = _ STR ; break ; default : type Str = _ STR ; }  String text String ; if ( text == null ) { text String = _ STR ; } else {  String Builder text Buffer = new  String Builder ( _ STR ) ; int committed Character Count = this . committed Character Count ; char c = text . first ( ) ; while ( committed Character Count -- > _ NUM ) { text Buffer . append ( c ) ; c = text . next ( ) ; } text Buffer . append ( _ STR ) ; while ( c !=  Character Iterator .  DONE ) { text Buffer . append ( c ) ; c = text . next ( ) ; } text Buffer . append ( _ STR ) ; text String = text Buffer . to String ( ) ; }  String count String = committed Character Count + _ STR ;  String caret String ; if ( caret == null ) { caret String = _ STR ; } else { caret String = _ STR + caret . to String ( ) ; }  String visible Position String ; if ( visible Position == null ) { visible Position String = _ STR ; } else { visible Position String = _ STR + visible Position . to String ( ) ; } return type Str + _ STR + text String + _ STR + count String + _ STR + caret String + _ STR + visible Position String ; }
protected boolean [ ] can Handle Missing ( boolean nominal Predictor , boolean numeric Predictor , boolean string Predictor , boolean date Predictor , boolean relational Predictor , boolean multi Instance , int class Type , boolean predictor Missing , boolean class Missing , int missing Level ) { if ( missing Level == _ NUM ) { print ( _ STR ) ; } print ( _ STR ) ; if ( predictor Missing ) { print ( _ STR ) ; if ( class Missing ) { print ( _ STR ) ; } } if ( class Missing ) { print ( _ STR ) ; } print ( _ STR ) ; print Attribute Summary ( nominal Predictor , numeric Predictor , string Predictor , date Predictor , relational Predictor , multi Instance , class Type ) ; print ( _ STR ) ;  Array List <  String > accepts = new  Array List <  String > ( ) ; accepts . add ( _ STR ) ; accepts . add ( _ STR ) ; accepts . add ( _ STR ) ; int num Train = get Num Instances ( ) , num Classes = _ NUM ; return run Basic Test ( nominal Predictor , numeric Predictor , string Predictor , date Predictor , relational Predictor , multi Instance , class Type , missing Level , predictor Missing , class Missing , num Train , num Classes , accepts ) ; }
private void disable Buttons ( ) { set Kick Enabled ( _ BOOL ) ; set Punch Enabled ( _ BOOL ) ; set Push Enabled ( _ BOOL ) ; set Trip Enabled ( _ BOOL ) ; set Grapple Enabled ( _ BOOL ) ; set Jump Jet Enabled ( _ BOOL ) ; set Club Enabled ( _ BOOL ) ; set Brush Off Enabled ( _ BOOL ) ; set Thrash Enabled ( _ BOOL ) ; set Dodge Enabled ( _ BOOL ) ; set Proto Enabled ( _ BOOL ) ; set Vibro Enabled ( _ BOOL ) ; set Explosives Enabled ( _ BOOL ) ; but Done . set Enabled ( _ BOOL ) ; set Next Enabled ( _ BOOL ) ; }
public  Artifact load (  Artifact Name artifact Name ,  File path ) throws  IOException {  Preconditions . check Argument ( path . exists ( ) , _ STR + path ) ;  Preconditions . check Argument ( path . is File ( ) || path . is Directory ( ) , _ STR + path ) ; if ( path . is File ( ) ) { return load From Jar ( artifact Name , path ) ; } return load From Directory ( artifact Name , path ) ; }
@  Override public  String to String ( ) { int len = _value . length ( ) ; len = len + _ NUM + ( len > > _ NUM ) ;  String Builder sb = new  String Builder ( len ) ; append Quoted ( sb , _value ) ; return sb . to String ( ) ; }
@  Override public  Enumeration <  Option > list Options ( ) {  Vector <  Option > result = new  Vector <  Option > ( ) ; result . add Element ( new  Option ( _ STR , _ STR , _ NUM , _ STR ) ) ; result . add Element ( new  Option ( _ STR , _ STR , _ NUM , _ STR ) ) ; result . add Element ( new  Option ( _ STR , _ STR , _ NUM , _ STR ) ) ; result . add Element ( new  Option ( _ STR + _ STR , _ STR , _ NUM , _ STR ) ) ; result . add Element ( new  Option ( _ STR + default Min Inst Num ( ) + _ STR + default Max Inst Num ( ) + _ STR , _ STR , _ NUM , _ STR ) ) ; result . add Element ( new  Option ( _ STR , _ STR , _ NUM , _ STR ) ) ; return result . elements ( ) ; }
public  Monitor Train (  Transit Section Action tsa ) { _tsa = tsa ; }
public  DAuthority Key Identifier (  JDialog parent , byte [ ] value ,  Public Key authority Public Key ) throws  IOException { super ( parent ) ; set Title ( res . get String ( _ STR ) ) ; this . authority Public Key = authority Public Key ; init Components ( ) ; prepopulate With Value ( value ) ; }
private boolean is Redundant (  Coordinate pt ) { if ( pt List . size ( ) < _ NUM ) return _ BOOL ;  Coordinate last Pt = (  Coordinate ) pt List . get ( pt List . size ( ) - _ NUM ) ; double pt Dist = pt . distance ( last Pt ) ; if ( pt Dist < minimim Vertex Distance ) return _ BOOL ; return _ BOOL ; }
private  Verification Result verify Signature (  Auth Success auth Resp ,  Discovery Information discovered ,  Verification Result result ) throws  Association Exception ,  Message Exception ,  Discovery Exception { if ( discovered == null || auth Resp == null ) { _log . error ( _ STR + _ STR ) ; result . set Status Msg ( _ STR + _ STR ) ; return result ; }  Identifier claimed Id = discovered . is Version2 ( ) ? _discovery . parse Identifier ( auth Resp . get Claimed ( ) ) : discovered . get Claimed Identifier ( ) ;  String handle = auth Resp . get Handle ( ) ;  URL op = discovered . get OPEndpoint ( ) ;  Association assoc = _associations . load ( op . to String ( ) , handle ) ; if ( assoc != null ) { _log . info ( _ STR + assoc . get Handle ( ) + _ STR ) ;  String text = auth Resp . get Signed Text ( ) ;  String signature = auth Resp . get Signature ( ) ; if ( assoc . verify Signature ( text , signature ) ) { result . set Verified Id ( claimed Id ) ; if (  DEBUG ) _log . debug ( _ STR ) ; } else { result . set Status Msg ( _ STR ) ; if (  DEBUG ) _log . debug ( _ STR ) ; } } else { _log . info ( _ STR + _ STR ) ;  Verify Request vrfy =  Verify Request . create Verify Request ( auth Resp ) ;  Parameter List response Params = new  Parameter List ( ) ; int resp Code = call ( op . to String ( ) , vrfy , response Params ) ; if (  Http Status .  SC_ OK == resp Code ) {  Verify Response vrfy Resp =  Verify Response . create Verify Response ( response Params ) ; vrfy Resp . validate ( ) ; if ( vrfy Resp . is Signature Verified ( ) ) {  String invalidate Handle = vrfy Resp . get Invalidate Handle ( ) ; if ( invalidate Handle != null ) _associations . remove ( op . to String ( ) , invalidate Handle ) ; result . set Verified Id ( claimed Id ) ; if (  DEBUG ) _log . debug ( _ STR + _ STR + op ) ; } else { if (  DEBUG ) _log . debug ( _ STR + _ STR + op ) ; result . set Status Msg ( _ STR ) ; } } else {  Direct Error err =  Direct Error . create Direct Error ( response Params ) ; if (  DEBUG ) _log . debug ( _ STR + op + _ STR + err . key Value Form Encoding ( ) ) ; result . set Status Msg ( _ STR + err . get Error Msg ( ) ) ; } }  Identifier verified ID = result . get Verified Id ( ) ; if ( verified ID != null ) _log . info ( _ STR + verified ID ) ; else _log . error ( _ STR + auth Resp . get Claimed ( ) + _ STR + result . get Status Msg ( ) ) ; return result ; }
@  Action ( value = _ STR ) public  String report ( ) { final  Report Request report Input = new  Report Request (  CASH_ COLLECTION_ TEMPLATE , crit Params ,  Report Data Source Type .  SQL ) ; final  Report Output report Output = report Service . create Report ( report Input ) ; report Id = report Viewer Util . add Report To Temp Cache ( report Output ) ; return  REPORT ; }
protected void update View (  View view ) { try { m Status Text = (  Text View ) view . find View By Id (  R . id . seek Bar Pref Value ) ; m Status Text . set Text (  String . value Of ( m Current Value ) ) ; m Status Text . set Minimum Width ( _ NUM ) ; m Seek Bar . set Progress ( m Current Value - m Min Value ) ;  Text View units Right = (  Text View ) view . find View By Id (  R . id . seek Bar Pref Units Right ) ; units Right . set Text ( m Units Right ) ;  Text View units Left = (  Text View ) view . find View By Id (  R . id . seek Bar Pref Units Left ) ; units Left . set Text ( m Units Left ) ; } catch (  Exception e ) {  Log . e (  TAG , _ STR , e ) ; } }
public void commit If Prepared (  Ignite Internal Tx tx ,  Set <  UUID > failed Node Ids ) { assert tx instanceof  Grid Dht Tx Local || tx instanceof  Grid Dht Tx Remote : tx ; assert !  F . is Empty ( tx . transaction Nodes ( ) ) : tx ; assert tx . near Xid Version ( ) != null : tx ;  Grid Cache Tx Recovery Future fut = new  Grid Cache Tx Recovery Future ( cctx , tx , failed Node Ids , tx . transaction Nodes ( ) ) ; cctx . mvcc ( ) . add Future ( fut , fut . future Id ( ) ) ; if ( log . is Debug Enabled ( ) ) log . debug ( _ STR + tx + _ STR + fut + _ STR ) ; fut . prepare ( ) ; }
public static byte [ ] encode ( byte [ ] data ,  String pub_key ) { try {  Cipher cipher =  Cipher . get Instance ( _ STR ) ; java . security .  Key k = get Public Key ( pub_key ) ; cipher . init (  Cipher .  ENCRYPT_ MODE , k ) ; byte [ ] en Bytes = cipher . do Final ( data ) ; return en Bytes ; } catch (  Exception e ) { log . error ( _ STR + pub_key + _ STR + data . length , e ) ; } return null ; }
static int derive ARGB (  Color color1 ,  Color color2 , float mid Point ) { int r = color1 . get Red ( ) + ( int ) ( ( color2 . get Red ( ) - color1 . get Red ( ) ) * mid Point + _ NUM ) ; int g = color1 . get Green ( ) + ( int ) ( ( color2 . get Green ( ) - color1 . get Green ( ) ) * mid Point + _ NUM ) ; int b = color1 . get Blue ( ) + ( int ) ( ( color2 . get Blue ( ) - color1 . get Blue ( ) ) * mid Point + _ NUM ) ; int a = color1 . get Alpha ( ) + ( int ) ( ( color2 . get Alpha ( ) - color1 . get Alpha ( ) ) * mid Point + _ NUM ) ; return ( ( a & _ NUM ) << _ NUM ) | ( ( r & _ NUM ) << _ NUM ) | ( ( g & _ NUM ) << _ NUM ) | ( b & _ NUM ) ; }
public void position ( long pos ) { set Current Position ( pos ) ; }
private static  Pair <  String ,  String > parse Strategy (  String desc ) {  String [ ] arg = desc . split ( _ STR ) ;  Pair <  String ,  String > rval = new  Pair <  String ,  String > ( arg [ _ NUM ] , _ STR ) ; if ( arg . length > _ NUM ) { rval . set Second ( arg [ _ NUM ] ) ; } return rval ; }
protected void notify Locator (  L locator ) { synchronized ( this ) { if ( ! known Locators . add ( locator . get Partition Id ( ) ) ) { throw new  Illegal State Exception ( _ STR + locator ) ; } } }
public  String to Id String (  Object id ) { if ( id == null ) return null ; return id . to String ( ) ; }
public void store State ( ) { if ( intervals Known ) { if ( stored Intervals == null ) { stored Intervals = new double [ intervals . length ] ; } if ( stored Lineage Counts == null ) { stored Lineage Counts = new int [ lineage Counts . length ] ; } if ( super Store ) { if ( stored Indices == null ) { stored Indices = new int [ indices . length ] ; } if ( stored Times == null ) { stored Times = new double [ times . length ] ; } }  System . arraycopy ( intervals , _ NUM , stored Intervals , _ NUM , intervals . length ) ;  System . arraycopy ( lineage Counts , _ NUM , stored Lineage Counts , _ NUM , lineage Counts . length ) ; if ( super Store ) {  System . arraycopy ( indices , _ NUM , stored Indices , _ NUM , indices . length ) ;  System . arraycopy ( times , _ NUM , stored Times , _ NUM , times . length ) ; } } stored Intervals Known = intervals Known ; }
public void handle Button2 Request (  Request Invocation Event event ) throws  Model Control Exception {  IDRepo Model model = (  IDRepo Model ) get Model ( ) ;  String id Repo Name = (  String ) property Sheet Model . get Value (  IDRepo Model .  TF_ NAME ) ; id Repo Name = id Repo Name . trim ( ) ;  String id Repo Type = (  String ) property Sheet Model . get Value (  ATTR_ IDREPO_ TYPE ) ; if ( id Repo Name . length ( ) > _ NUM ) {  IDRepo Add View Bean vb = (  IDRepo Add View Bean ) get View Bean (  IDRepo Add View Bean . class ) ; set Page Session Attribute (  IDRepo Add View Bean .  IDREPO_ NAME , id Repo Name ) ; set Page Session Attribute (  IDRepo Add View Bean .  IDREPO_ TYPE , id Repo Type ) ; unlock Page Trail For Swapping ( ) ; pass Pg Session Map ( vb ) ; vb . forward To ( get Request Context ( ) ) ; } else { set Inline Alert Message (  CCAlert .  TYPE_ ERROR , _ STR , _ STR ) ; forward To ( ) ; } }
public void list (  Print Writer out ) { out . println ( _ STR ) ;  Hashtable <  String ,  Object > h = new  Hashtable < > ( ) ; enumerate ( h ) ; for (  Enumeration <  String > e = h . keys ( ) ; e . has More Elements ( ) ; ) {  String key = e . next Element ( ) ;  String val = (  String ) h . get ( key ) ; if ( val . length ( ) > _ NUM ) { val = val . substring ( _ NUM , _ NUM ) + _ STR ; } out . println ( key + _ STR + val ) ; } }
@  Nullable public static  String file Md5 ( @  Nullable  File file , @  Nullable  Ignite Logger log ) {  String md5 = null ; if ( file != null ) { if ( ! file . is File ( ) ) {  U . warn ( log , _ STR + file ) ; return null ; }  Input Stream in = null ; try { in = new  Buffered Input Stream ( new  File Input Stream ( file ) ) ; md5 =  Digest Utils . md5 Hex ( in ) ; } catch (  IOException e ) {  U . warn ( log , _ STR + e . get Message ( ) ) ; } finally {  U . close Quiet ( in ) ; } } return md5 ; }
public void end ( ) { if ( cleanup Counter . get ( ) == null || cleanup Counter . get ( ) < _ NUM ) { log . warn ( _ STR ) ; } else if ( cleanup Counter . get ( ) == _ NUM ) { log . trace ( _ STR ) ;  App Context . set Security Context ( null ) ; cleanup Counter . remove ( ) ; } else { log . trace ( _ STR ) ; cleanup Counter . set ( cleanup Counter . get ( ) - _ NUM ) ; log . trace ( _ STR , cleanup Counter . get ( ) ) ; } }
public void trim ( ) { objects . trim To Size ( ) ; }
void clear ( ) ;
public static  List < ? extends  Node > child Node List (  Node node ) { if ( node == null ) return null ;  List <  Node > nodes = new  Linked List <  Node > ( ) ; do { if ( node . get Node Type ( ) ==  Node .  ELEMENT_ NODE || node . get Node Type ( ) ==  Node .  COMMENT_ NODE ) { nodes . add ( node ) ; } } while ( ( node = node . get Next Sibling ( ) ) != null ) ; return nodes ; }
public static <  T >  Completable Future <  T > wait For All (  List <  Completable Future <  T > > futures ) { if ( futures . is Empty ( ) ) { return  Completable Future . completed Future ( null ) ; } final  Completable Future <  T > composite Future = new  Completable Future < > ( ) ; final  Atomic Integer count = new  Atomic Integer ( futures . size ( ) ) ; final  Atomic Reference <  Throwable > exception = new  Atomic Reference < > ( ) ; for (  Completable Future <  T > future : futures ) { future . when Complete ( null ) ; } return composite Future ; }
public static  List <  Container > create Container List ( int broker Id , int containers Number ) {  Array List <  Container > containers = new  Array List <  Container > ( ) ; for ( int i = _ NUM ; i < containers Number ; ++ i ) { int container Type = i / ( int )  Math . ceil ( ( double ) containers Number / _ NUM ) ; containers . add ( new  Power Container (  IDs . poll Id (  Container . class ) , broker Id , ( double )  Constants Examples .  CONTAINER_ MIPS [ container Type ] ,  Constants Examples .  CONTAINER_ PES [ container Type ] ,  Constants Examples .  CONTAINER_ RAM [ container Type ] ,  Constants Examples .  CONTAINER_ BW , _ NUM , _ STR , new  Container Cloudlet Scheduler Dynamic Workload (  Constants Examples .  CONTAINER_ MIPS [ container Type ] ,  Constants Examples .  CONTAINER_ PES [ container Type ] ) ,  Constants Examples .  SCHEDULING_ INTERVAL ) ) ; } return containers ; }
public  Builder port ( int port ) { this . port =  Integer . to String ( port ) ; return this ; }
private  String remove Suffix (  String value ,  String to Remove ) { if ( ( value == null ) || ( to Remove == null ) || ! suffix ( value , to Remove ) ) { return value ; } return value . substring ( _ NUM , value . length ( ) - to Remove . length ( ) ) ; }
public void add Model Change (  String table Name ,  Model Validator listener ) { if ( table Name == null || listener == null ) return ;  String property Name = m_global Validators . contains ( listener ) ? table Name + _ STR : table Name + listener . get AD_ Client_ ID ( ) ;  Array List <  Model Validator > list = (  Array List <  Model Validator > ) m_model Change Listeners . get ( property Name ) ; if ( list == null ) { list = new  Array List <  Model Validator > ( ) ; list . add ( listener ) ; m_model Change Listeners . put ( property Name , list ) ; } else list . add ( listener ) ; }
public void append To Content Buffer (  String append ) { if ( content Buffer == null ) { content Buffer = new  String Buffer ( append ) ; } else { content Buffer . append ( _ STR ) ; content Buffer . append ( append ) ; } }
private  Object execute Plus (  Page Context pc ,  SQL sql ,  Query qr ,  Operation2 expression , int row ) throws  Page Exception {  Object left = execute Exp ( pc , sql , qr , expression . get Left ( ) , row ) ;  Object right = execute Exp ( pc , sql , qr , expression . get Right ( ) , row ) ; try { return new  Double (  Caster . to Double Value ( left ) +  Caster . to Double Value ( right ) ) ; } catch (  Page Exception e ) { return  Caster . to String ( left ) +  Caster . to String ( right ) ; } }
@  POST @  Produces ( {  Media Type .  APPLICATION_ XML ,  Media Type .  APPLICATION_ JSON } ) @  Path ( _ STR ) @  Check Permission ( roles = {  Role .  SYSTEM_ ADMIN ,  Role .  RESTRICTED_ SYSTEM_ ADMIN } ) public  Task Resource Rep discover Network System ( @  Path Param ( _ STR )  URI id ) {  Arg Validator . check Field Uri Type ( id ,  Network System . class , _ STR ) ;  Network System device = query Object (  Network System . class , id , _ BOOL ) ; return do Discover Network System ( device ) ; }
public int read ( byte [ ] b , int off , int len ) throws  IOException { ensure Open ( ) ; if ( b == null ) { throw new  Null Pointer Exception ( _ STR ) ; } else if ( off < _ NUM || len < _ NUM || len > b . length - off ) { throw new  Index Out Of Bounds Exception ( ) ; } else if ( len == _ NUM ) { return _ NUM ; } int cnt = _ NUM ; while ( len > _ NUM && ! def . finished ( ) ) { int n ; if ( def . needs Input ( ) ) { n = in . read ( buf , _ NUM , buf . length ) ; if ( n < _ NUM ) { def . finish ( ) ; } else if ( n > _ NUM ) { def . set Input ( buf , _ NUM , n ) ; } } n = def . deflate ( b , off , len ) ; cnt += n ; off += n ; len -= n ; } if ( cnt == _ NUM && def . finished ( ) ) { reach EOF = _ BOOL ; cnt = - _ NUM ; } return cnt ; }
private void draw Line To Touch Point (  Canvas canvas ) { if ( touch Point . height ( ) > _ NUM && touch Point . width ( ) > _ NUM ) { draw Line ( canvas , circles [ connection Order . get ( connection Order . size ( ) - _ NUM ) ] , touch Point ) ; } }
public static  Java File Object to Java File Object (  Java File Manager file Manager ,  File source File ) throws  IOException {  List <  Java File Object > java File Objects = to Java File Objects ( file Manager , as List ( source File ) ) ; return java File Objects . is Empty ( ) ? null : java File Objects . get ( _ NUM ) ; }
public  Writable Raster create Compatible Writable Raster ( int w , int h ) { if ( w <= _ NUM || h <= _ NUM ) { throw new  Raster Format Exception ( _ STR + ( ( w <= _ NUM ) ? _ STR : _ STR ) ) ; }  Sample Model sm = sample Model . create Compatible Sample Model ( w , h ) ; return new  Byte Interleaved Raster ( sm , new  Point ( _ NUM , _ NUM ) ) ; }
public static  Left Indexed Power Law Multi Segment Bipartite Graph build Random Multi Segment Bipartite Graph ( int max Num Segments , int max Num Edges Per Segment , int left Size , int right Size , double edge Probability ,  Random random ) {  Left Indexed Power Law Multi Segment Bipartite Graph multi Segment Left Indexed Power Law Bipartite Graph = new  Left Indexed Power Law Multi Segment Bipartite Graph ( max Num Segments , max Num Edges Per Segment , left Size / _ NUM , ( int ) ( right Size * edge Probability / _ NUM ) , _ NUM , right Size / _ NUM , new  Identity Edge Type Mask ( ) , new  Null Stats Receiver ( ) ) ; for ( int i = _ NUM ; i < left Size ; i ++ ) { for ( int j = _ NUM ; j < right Size ; j ++ ) { if ( random . next Double ( ) < edge Probability ) { multi Segment Left Indexed Power Law Bipartite Graph . add Edge ( i , j , ( byte ) _ NUM ) ; } } } return multi Segment Left Indexed Power Law Bipartite Graph ; }
public static  String execute (  String command ) { return execute ( command , null ) ; }
public final void add Progress Thread Listener ( final  Progress Thread Listener listener ) { listeners . add ( listener ) ; }
public void list Directory (  File directory ) { if ( directory == null ) { if ( m Directory != null ) { directory = m Directory ; } else { directory =  Environment . get External Storage Directory ( ) ; if ( directory == null ) return ; } } if ( ! directory . is Directory ( ) ) {  Log_ OC . w (  TAG , _ STR + directory . to String ( ) ) ; directory = directory . get Parent File ( ) ; } m Adapter . swap Directory ( directory ) ; if ( m Directory == null || ! m Directory . equals ( directory ) ) { } m Directory = directory ; }
public boolean starts With ( java . lang .  String prefix ) { return starts With ( prefix , _ NUM ) ; }
private native static boolean has Static Initializer (  Class < ? > cl ) ;
public static  Temp Path create Directory (  Path dir ) throws  IOException { return wrap (  Files . create Temp Directory ( dir ,  PREFIX ) ) ; }
@  Override public  String to String ( ) {  String Builder sb = new  String Builder ( ) ; sb . append ( _ STR ) ; final int end = offset + length ; for ( int i = offset ; i < end ; i ++ ) { if ( i > offset ) { sb . append ( _ STR ) ; } sb . append (  Integer . to Hex String ( bytes [ i ] & _ NUM ) ) ; } sb . append ( _ STR ) ; return sb . to String ( ) ; }
public static boolean is Category Top (  Servlet Request request ,  String product Category Id ) { return is Category Top ( (  Delegator ) request . get Attribute ( _ STR ) , (  Local Dispatcher ) request . get Attribute ( _ STR ) , product Category Id ) ; }
@  Override public boolean input (  Instance instance ) { if ( get Input Format ( ) == null ) { throw new  Illegal State Exception ( _ STR ) ; } if ( m_ New Batch ) { reset Queue ( ) ; m_ New Batch = _ BOOL ; } if ( is First Batch Done ( ) ) { push ( instance ) ; return _ BOOL ; } else { buffer Input ( instance ) ; return _ BOOL ; } }
public  Collection <  String > list Tables ( ) throws  Database Exception {  Collection <  String > result = new  Array List <  String > ( ) ;  Result Set rs = null ; try {  Database Meta Data dbm = connection . get Meta Data ( ) ;  String types [ ] = { _ STR } ; rs = dbm . get Tables ( null , null , null , types ) ; while ( rs . next ( ) ) {  String str = rs . get String ( _ STR ) ; result . add ( str ) ; } } catch (  SQLException e ) { throw ( new  Database Exception ( e ) ) ; } finally { if ( rs != null ) { try { rs . close ( ) ; } catch (  SQLException e ) { } } } return result ; }
public void add Preexisting Resource (  Resource resource ) { resource List . add ( resource ) ; }
public void wait For Event ( long timeout ) {  Thread thread =  Thread . current Thread ( ) ;  Semaphore semaphore = _semaphores . get ( thread ) ; if ( semaphore == null ) { semaphore = new  Semaphore ( _ NUM , _ BOOL ) ; semaphore . drain Permits ( ) ; _semaphores . put If Absent ( thread , semaphore ) ; } semaphore = _semaphores . get ( thread ) ; try { semaphore . try Acquire ( timeout ,  Time Unit .  MILLISECONDS ) ; } catch (  Interrupted Exception exception ) { logger . log (  Level .  FINER , _ STR , exception ) ; } }
@  Override public boolean equals (  Object obj ) { if ( obj == this ) { return _ BOOL ; } if ( ! ( obj instanceof  Keyed Values ) ) { return _ BOOL ; }  Keyed Values that = (  Keyed Values ) obj ; int count = get Item Count ( ) ; if ( count != that . get Item Count ( ) ) { return _ BOOL ; } for ( int i = _ NUM ; i < count ; i ++ ) {  Comparable k1 = get Key ( i ) ;  Comparable k2 = that . get Key ( i ) ; if ( ! k1 . equals ( k2 ) ) { return _ BOOL ; }  Number v1 = get Value ( i ) ;  Number v2 = that . get Value ( i ) ; if ( v1 == null ) { if ( v2 != null ) { return _ BOOL ; } } else { if ( ! v1 . equals ( v2 ) ) { return _ BOOL ; } } } return _ BOOL ; }
protected boolean are All Dbsvc Active ( ) {  Coordinator Client coordinator Client = coordinator . get Coordinator Client ( ) ;  List <  Service > active Dbsvcs = coordinator Client . locate All Svcs All Vers (  Constants .  DBSVC_ NAME ) ;  List <  String > active Dbsvc Ids = new  Array List < > ( active Dbsvcs . size ( ) ) ; for (  Service active Dbsvc : active Dbsvcs ) { active Dbsvc Ids . add ( active Dbsvc . get Id ( ) ) ; } log . info ( _ STR , active Dbsvc Ids , node Count ) ; boolean all Active = active Dbsvcs . size ( ) == node Count ; if ( ! all Active ) { log . info ( _ STR ) ; } return all Active ; }
private void expect Alarm At ( long millis ) { m Mock Alarm Manager . expect Alarm Time (  Alarm Manager .  RTC_ WAKEUP , millis +  Alarm Scheduler .  ALARM_ DELAY_ MS ) ; }
public boolean is Stop Requested ( ) { if ( stop Requested . get ( ) == _ BOOL ) return _ BOOL ; else return _ BOOL ; }
@  Suppress Warnings ( { _ STR } ) public static <  T >  T [ ] join (  Class <  T > component Type ,  T [ ] [ ] arrays ) { if ( arrays . length == _ NUM ) { return arrays [ _ NUM ] ; } int length = _ NUM ; for (  T [ ] array : arrays ) { length += array . length ; }  T [ ] result = (  T [ ] )  Array . new Instance ( component Type , length ) ; length = _ NUM ; for (  T [ ] array : arrays ) {  System . arraycopy ( array , _ NUM , result , length , array . length ) ; length += array . length ; } return result ; }
public  String [ ] split (  String input ) {  List <  String > results = new  Array List <  String > ( ) ; _split ( input , results ) ;  String [ ] parts = new  String [ results . size ( ) ] ; for ( int i = _ NUM ; i < results . size ( ) ; i ++ ) parts [ i ] = (  String ) results . get ( i ) ; return parts ; }
public  Action Forward validate User (  Action Mapping mapping ,  Action Form form ,  Http Servlet Request request ,  Http Servlet Response response ) throws  Exception {  Properties ctx =  Tmk JSPEnv . get Ctx ( request ) ;  Default Form df = (  Default Form ) form ;  Login Bean bean = (  Login Bean ) df . get Bean ( ) ;  Http Session session = request . get Session ( ) ;  Web User Info info = null ;  Web User wu = null ; try { wu = bd . check Login Password ( ctx , bean ) ; info = bd . login ( ctx , wu ) ;  MSession c Session =  MSession . get ( ctx , request . get Remote Addr ( ) , request . get Remote Host ( ) , session . get Id ( ) ) ; if ( c Session != null ) c Session . set Web Store Session ( _ BOOL ) ; session . set Attribute (  Web User Info .  NAME , info ) ;  Array List my Roles =  Role Manager . get My Roles ( ctx ) ; if ( my Roles . size ( ) == _ NUM ) {  Key Name Pair pair = (  Key Name Pair ) my Roles . get ( _ NUM ) ;  Env . set Context ( ctx , _ STR , pair . get Key ( ) ) ;  Session Storage . put Menus ( ctx , request ) ;  Session Storage . put Org ( ctx , request ) ; return mapping . find Forward (  LOGIN_ SUCCESS ) ; } } catch (  User Not Found Exception unfe ) { post Global Error ( _ STR , request ) ; return ( mapping . get Input Forward ( ) ) ; } catch (  Not Logged In Exception e ) { post Global Error ( _ STR , request ) ; return ( mapping . get Input Forward ( ) ) ; } catch (  Invalid Role Exception ire ) { post Global Error ( _ STR , request ) ; return ( mapping . get Input Forward ( ) ) ; } catch (  User Inactive Exception unae ) { post Global Error ( _ STR , request ) ; return ( mapping . get Input Forward ( ) ) ; } return mapping . find Forward (  INIT_ CHOOSE_ ROLE ) ; }
public void add (  Transaction transaction ) {  LOG . debug ( _ STR + transaction ) ; if ( ! transaction . is Empty ( ) ) { m Transactions . add ( transaction ) ; } }
public synchronized void notify Done (  Job done Job ) {  LOG . debug ( _ STR + done Job ) ;  Set <  Job > new Ready Jobs = dag Manager . remove Job ( done Job ) ; for (  Job job To Run : new Ready Jobs ) {  LOG . debug ( _ STR + job To Run + _ STR ) ; jobs To Run . add ( job To Run ) ; } increment Done Job Count ( ) ; count Lock . lock ( ) ; try {  LOG . debug ( _ STR + submitted Job Count + _ STR + ( submitted Job Count - done Job Count ) + _ STR + done Job Count ) ; } finally { count Lock . unlock ( ) ; } }
public  String Constant add String (  String name ) {  String Constant entry = get String ( name ) ; if ( entry != null ) { return entry ; }  Utf8 Constant utf8 = add UTF8 ( name ) ; entry = new  String Constant ( this , _entries . size ( ) , utf8 . get Index ( ) ) ; add Constant ( entry ) ; return entry ; }
public void add (  Rule rule ) { rules . add ( rule ) ; }
@  Suppress Warnings ( { _ STR } ) public static <  T extends  Serializable >  T deserialize Jdk ( byte [ ] bytes ) throws  IOException ,  Class Not Found Exception {  Object Input Stream in = null ; try { in = new  Object Input Stream ( new  Byte Array Input Stream ( bytes ) ) ; return (  T ) in . read Object ( ) ; } finally { close ( in ) ; } }
public void test Division Knuth Multi Digits By One Digit ( ) { byte a Bytes [ ] = { _ NUM , - _ NUM , _ NUM , - _ NUM , _ NUM , - _ NUM , _ NUM , _ NUM , - _ NUM } ; byte b Bytes [ ] = { _ NUM , - _ NUM , - _ NUM , - _ NUM } ; int a Sign = _ NUM ; int b Sign = - _ NUM ; byte r Bytes [ ] = { - _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , - _ NUM } ;  Big Integer a Number = new  Big Integer ( a Sign , a Bytes ) ;  Big Integer b Number = new  Big Integer ( b Sign , b Bytes ) ;  Big Integer result = a Number . divide ( b Number ) ; byte res Bytes [ ] = new byte [ r Bytes . length ] ; res Bytes = result . to Byte Array ( ) ; for ( int i = _ NUM ; i < res Bytes . length ; i ++ ) { assert True ( res Bytes [ i ] == r Bytes [ i ] ) ; } assert Equals ( _ STR , - _ NUM , result . signum ( ) ) ; }
public static void show Dialog If ( @  Nullable  Dialog dialog , boolean show ) { if ( dialog != null ) { if ( show ) { dialog . show ( ) ; } else { dialog . hide ( ) ; } } }
public void decrypt ( byte [ ] in , int length ) { int pos = _ NUM ; while ( pos < in . length && pos < length ) { decrypt Block ( in , pos , length ) ; pos += block Size ; } }
private static  Class register Type Mapping (  RPCServer server ,  Class clazz ) { java . lang . reflect .  Method [ ] methods = clazz . get Methods ( ) ; java . lang . reflect .  Method method ;  Class [ ] params ; for ( int i = _ NUM ; i < methods . length ; i ++ ) { method = methods [ i ] ; if ( method . get Declaring Class ( ) == clazz ) { _register Type Mapping ( server , method . get Return Type ( ) ) ; params = method . get Parameter Types ( ) ; for ( int y = _ NUM ; y < params . length ; y ++ ) { _register Type Mapping ( server , params [ y ] ) ; } } } return clazz ; }
private  Math Helper ( ) { }
public static  String convert To Box (  String s ) {  String temp = s . replace All ( _ STR , _ STR ) ; if ( temp . ends With ( _ STR ) ) { temp = temp . substring ( _ NUM , temp . length ( ) - _ NUM ) + _ STR ; } temp = temp . replace All ( _ STR , _ STR ) ; return  Word Utils . capitalize Fully ( temp ) ; }
private  Value Sub Panel create Value Panel ( boolean add Value Field ) {  Value Sub Panel value Panel = new  Value Sub Panel ( add Value Field ) ; outer Panel . add ( value Panel ,  Value Sub Panel . get Panel Name ( ) ) ; return value Panel ; }
public  Aggregate Application Builder web ( boolean web Environment ) { this . web Environment = web Environment ; return this ; }
protected boolean is Transaction In Advance Of Installment ( final int current Installment Index , final  List <  Loan Repayment Schedule Installment > installments , final  Local Date transaction Date , @  Suppress Warnings ( _ STR ) final  Money transaction Amount ) { final  Loan Repayment Schedule Installment current Installment = installments . get ( current Installment Index ) ; return transaction Date . is Before ( current Installment . get Due Date ( ) ) ; }
public static boolean is Email Id Valid (  String email ) {  String expression = _ STR ;  Pattern pattern =  Pattern . compile ( expression ,  Pattern .  CASE_ INSENSITIVE ) ;  Matcher matcher = pattern . matcher ( email ) ; return matcher . matches ( ) ; }
protected void add (  Directed Edge dir Edge ) { dir Edges . add ( dir Edge ) ; }
public static  Web Xml parse Web Xml From File (  File the File ,  Entity Resolver the Entity Resolver ) throws  IOException ,  JDOMException {  Input Stream in = null ; try { in = new  File Input Stream ( the File ) ; return parse Web Xml ( in , the Entity Resolver ) ; } finally { if ( in != null ) { try { in . close ( ) ; } catch (  IOException ioe ) { } } } }
protected void close Channel (  Socket Channel channel ) { if ( channel == null ) return ;  Socket socket = channel . socket ( ) ; try { socket . shutdown Input ( ) ; socket . shutdown Output ( ) ; socket . close ( ) ; } catch (  IOException ex ) { if ( _logger . is Loggable (  Level .  FINE ) ) { _logger . log (  Level .  FINE , _ STR , ex ) ; } } finally { try { channel . close ( ) ; } catch (  IOException ex ) { if ( _logger . is Loggable (  Level .  FINE ) ) { _logger . log (  Level .  FINE , _ STR , ex ) ; } } } }
private void handle Json Report Response ( final  Client Request Report report , final  Client Request Report Listener report Listener ) { if ( report Listener == null ) {  LOGGER . debug ( _ STR ) ; return ; } if ( report . is Error Report ( ) ) {  LOGGER . debug ( _ STR ) ; report Listener . on Error Report Received ( (  Client Request Error Report ) report ) ; throw new  Runtime Exception ( _ STR + report . get Error Message ( ) ) ; } else if ( report . is Progress Report ( ) ) {  LOGGER . debug ( _ STR ) ; report Listener . on Progress Report Received ( (  Client Request Progress Report ) report ) ; } else  LOGGER . warn ( _ STR ) ; }
public void add Subscription To Store ( final  String topic , final  String client Id ) { final  Client Topic Couple subscription = new  Client Topic Couple ( client Id , topic ) ; if ( ! topics . contains ( topic ) ) { logger . debug ( _ STR + topic + _ STR + client Id + _ STR ) ; subscriptions Store . add ( subscription ) ; topics . add ( topic ) ; } }
public void clear Cache ( ) {  Zip File zip File = _zip File Ref . get And Set ( null ) ; if ( zip File != null ) try { zip File . close ( ) ; } catch (  Exception e ) { } }
private  Hash Map <  Integer ,  Boolean > generate Expanded State Map (  List <  Object > item List ) {  Hash Map <  Integer ,  Boolean > parent Object Hash Map = new  Hash Map < > ( ) ; int child Count = _ NUM ; for ( int i = _ NUM ; i < item List . size ( ) ; i ++ ) { if ( item List . get ( i ) != null ) {  Object helper Item = get Helper Item ( i ) ; if ( helper Item instanceof  Parent Wrapper ) {  Parent Wrapper parent Wrapper = (  Parent Wrapper ) helper Item ; parent Object Hash Map . put ( i - child Count , parent Wrapper . is Expanded ( ) ) ; } else { child Count ++ ; } } } return parent Object Hash Map ; }
private void broadcast (  Audio Metadata metadata ) { if ( m Audio Metadata Listener != null ) { m Audio Metadata Listener . receive ( metadata ) ; } }
public  Freshest CRLExtension (  Boolean critical ,  Object value ) throws  IOException { super (  PKIXExtensions .  Freshest CRL_ Id , critical . boolean Value ( ) , value ,  NAME ) ; }
public  File Path append (  File Path sub Path ) { return append ( sub Path . elements ( ) ) ; }
private  String print OFormat ( long x ) {  String sx = null ; if ( x ==  Long .  MIN_ VALUE ) sx = _ STR ; else if ( x < _ NUM ) {  String t =  Long . to String ( ( ~ ( - x - _ NUM ) ) ^  Long .  MIN_ VALUE , _ NUM ) ; switch ( t . length ( ) ) { case _ NUM : sx = _ STR + t ; break ; case _ NUM : sx = _ STR + t ; break ; case _ NUM : sx = _ STR + t ; break ; case _ NUM : sx = _ STR + t ; break ; case _ NUM : sx = _ STR + t ; break ; case _ NUM : sx = _ STR + t ; break ; case _ NUM : sx = _ STR + t ; break ; case _ NUM : sx = _ STR + t ; break ; case _ NUM : sx = _ STR + t ; break ; case _ NUM : sx = _ STR + t ; break ; case _ NUM : sx = _ STR + t ; break ; case _ NUM : sx = _ STR + t ; break ; case _ NUM : sx = _ STR + t ; break ; case _ NUM : sx = _ STR + t ; break ; case _ NUM : sx = _ STR + t ; break ; case _ NUM : sx = _ STR + t ; break ; case _ NUM : sx = _ STR + t ; break ; case _ NUM : sx = _ STR + t ; break ; case _ NUM : sx = _ STR + t ; break ; case _ NUM : sx = _ STR + t ; break ; case _ NUM : sx = _ STR + t ; break ; } } else sx =  Long . to String ( x , _ NUM ) ; return print OFormat ( sx ) ; }
void remove Callback (  JSObject source ,  String method , boolean async ) {  String key = source . to JSPointer ( ) + _ STR + method ; callbacks . remove ( key ) ;  String js = _ STR + source . to JSPointer ( ) + _ STR + method ; exec ( js , async ) ; }
public boolean contains Block (  Block b ) {  Array List <  Block > b List = get Internal Blocks List ( ) ; for ( int i = _ NUM ; i < b List . size ( ) ; i ++ ) { if ( b == b List . get ( i ) ) { return _ BOOL ; } } return _ BOOL ; }
public static  String read File To String (  Path file ) throws  IOException { byte [ ] file Array =  Files . read All Bytes ( file ) ; return new  String ( file Array ,  Standard Charsets .  UTF_8 ) ; }
private static void collect ( final  INavi Operand Tree Node current Node , final  List <  INavi Operand Tree Node > nodes ) { nodes . add ( current Node ) ; for ( final  INavi Operand Tree Node child : current Node . get Children ( ) ) { collect ( child , nodes ) ; } }
@  Override public void on Value Selected ( int picker Index , int new Value , boolean auto Advance ) { if ( picker Index ==  HOUR_ INDEX ) { set Hour ( new Value , _ BOOL ) ;  String announcement =  String . format ( _ STR , new Value ) ; if ( m Allow Auto Advance && auto Advance ) { set Current Item Showing (  MINUTE_ INDEX , _ BOOL , _ BOOL , _ BOOL ) ; announcement += _ STR + m Select Minutes ; } else { m Time Picker . set Content Description ( m Hour Picker Description + _ STR + new Value ) ; }  Utils . try Accessibility Announce ( m Time Picker , announcement ) ; } else if ( picker Index ==  MINUTE_ INDEX ) { set Minute ( new Value ) ; m Time Picker . set Content Description ( m Minute Picker Description + _ STR + new Value ) ; } else if ( picker Index ==  AMPM_ INDEX ) { update Am Pm Display ( new Value ) ; } else if ( picker Index ==  ENABLE_ PICKER_ INDEX ) { if ( ! is Typed Time Fully Legal ( ) ) { m Typed Times . clear ( ) ; } finish Kb Mode ( _ BOOL ) ; } }
public static double point Circle Distance (  Geo p1 ,  Geo p2 ,  Geo center ) {  Geo n =  Geo . cross Normalize ( p1 , p2 , new  Geo ( ) ) ;  Geo c = center . normalize ( new  Geo ( ) ) ; double cos Theta =  Geo . dot ( n , c ) ; double theta =  Math . acos ( cos Theta ) ; return  Math . abs (  Math .  PI / _ NUM - theta ) ; }
public void add Action (  Network Update Action action ) { action List . add ( action ) ; for (  Update Manager Listener listener : listeners ) { listener . action Added ( action ) ; } }
private void load (  Byte Buffer bb ) throws  Buffer Underflow Exception ,  Mary Configuration Exception { int num Idx = bb . get Int ( ) ; idx Interval = bb . get Int ( ) ; if ( idx Interval <= _ NUM ) { throw new  Mary Configuration Exception ( _ STR ) ; } byte Ptrs = new long [ num Idx ] ; time Ptrs = new long [ num Idx ] ; for ( int i = _ NUM ; i < num Idx ; i ++ ) { byte Ptrs [ i ] = bb . get Long ( ) ; time Ptrs [ i ] = bb . get Long ( ) ; if ( i > _ NUM ) { if ( byte Ptrs [ i ] < byte Ptrs [ i - _ NUM ] || time Ptrs [ i ] < time Ptrs [ i - _ NUM ] ) { throw new  Mary Configuration Exception ( _ STR ) ; } } } bb . get Long ( ) ; bb . get Long ( ) ; }
private void create New Index Entry (  String index Name ) throws  SQLException {  Result Set rs ;  String unique = _ STR ;  String table Name = _ STR ; rs = stmtdb2 . execute Query ( _ STR + index Name + _ STR ) ; if ( rs . next ( ) ) { table Name = rs . get String ( _ STR ) ; unique = rs . get String ( _ STR ) ; if ( unique . equals ( _ STR ) ) { unique = _ STR ; } } rs . close ( ) ;  String create Statement = _ STR + unique + _ STR + index Name + _ STR + table Name + _ STR ; rs = stmtdb2 . execute Query ( _ STR + index Name + _ STR ) ; int k = _ NUM ; while ( rs . next ( ) ) { if ( k != _ NUM ) { create Statement += _ STR ; } create Statement += rs . get String ( _ STR ) ; k ++ ; } rs . close ( ) ; create Statement += _ STR ; m_new Index Statements . add ( create Statement ) ; }
private  String create Non CGSrdf Pair Steps On Populated Group (  List <  Volume Descriptor > source Descriptors ,  List <  Volume Descriptor > target Descriptors ,  Remote Director Group group ,  Map <  URI ,  Volume > uri Volume Map ,  String wait For ,  Workflow workflow ) {  Storage System system = db Client . query Object (  Storage System . class , group . get Source Storage System Uri ( ) ) ;  URI vpool Change Uri = get Virtual Pool Change Volume ( source Descriptors ) ; log . info ( _ STR , vpool Change Uri ) ;  List <  URI > source URIs =  Volume Descriptor . get Volume URIs ( source Descriptors ) ;  List <  URI > target URIs = new  Array List < > ( ) ; for (  URI source URI : source URIs ) {  Volume source = uri Volume Map . get ( source URI ) ;  String Set srdf Targets = source . get Srdf Targets ( ) ; for (  String target Str : srdf Targets ) {  URI target URI =  URI . create ( target Str ) ; target URIs . add ( target URI ) ; } }  Method suspend Group Method = suspend SRDFGroup Method ( system . get Id ( ) , group , source URIs , target URIs ) ;  Method resume Rollback Method = resume SRDFGroup Method ( system . get Id ( ) , group , source URIs , target URIs ) ;  String suspend Group Step = workflow . create Step (  CREATE_ SRDF_ ACTIVE_ VOLUME_ PAIR_ STEP_ GROUP ,  SUSPEND_ SRDF_ MIRRORS_ STEP_ DESC , wait For , system . get Id ( ) , system . get System Type ( ) , get Class ( ) , suspend Group Method , resume Rollback Method , null ) ;  Method create List Method = create List Replicas Method ( system . get Id ( ) , source URIs , target URIs , vpool Change Uri , _ BOOL ) ;  Method rollback Method = rollback SRDFLinks Method ( system . get Id ( ) , source URIs , target URIs , _ BOOL ) ;  String create List Replica Step = workflow . create Step (  CREATE_ SRDF_ ACTIVE_ VOLUME_ PAIR_ STEP_ GROUP ,  CREATE_ SRDF_ ACTIVE_ VOLUME_ PAIR_ STEP_ DESC , suspend Group Step , system . get Id ( ) , system . get System Type ( ) , get Class ( ) , create List Method , rollback Method , null ) ;  Method resume Group Method = resume SRDFGroup Method ( system . get Id ( ) , group , source URIs , target URIs ) ;  String resume Group Step = workflow . create Step (  CREATE_ SRDF_ ACTIVE_ VOLUME_ PAIR_ STEP_ GROUP ,  RESUME_ SRDF_ MIRRORS_ STEP_ DESC , create List Replica Step , system . get Id ( ) , system . get System Type ( ) , get Class ( ) , resume Group Method , rollback Method Null Method ( ) , null ) ; return resume Group Step ; }
public void register ( final  CGraph Window window ) {  Preconditions . check Not Null ( window , _ STR ) ; if ( m_graphs . contains ( window ) ) { throw new  Illegal State Exception ( _ STR ) ; } m_graphs . add ( window ) ; window . add Window Listener ( m_listener ) ; for ( final  IWindow Manager Listener listener : m_listeners ) { try { listener . window Opened ( this , window ) ; } catch ( final  Exception e ) {  CUtility Functions . log Exception ( e ) ; } } }
public  String print List (  My Idx List points ) { if ( points == null || points . length ( ) == _ NUM ) { return _ STR ; }  String Buffer bf = new  String Buffer ( ) ; try {  List Node temp ; for ( int i = _ NUM ; i < points . size ( ) ; i ++ ) { temp = points . get ( i ) ; if ( i == _ NUM ) { bf . append ( _ STR + temp . idx ) ; } else { bf . append ( _ STR + temp . idx ) ; } } } catch (  Exception ex ) { ex . print Stack Trace ( ) ; } return bf . to String ( ) ; }
public static  File extract Archive (  File archive ,  File destination ) {  File directory = get Unique File ( destination , archive . get Name ( ) ) ;  Zip File zip File = null ; try { prepare Directory ( directory ) ; zip File = new  Zip File ( archive ) ;  Enumeration < ? extends  Zip Entry > entries = zip File . entries ( ) ; while ( entries . has More Elements ( ) ) {  Zip Entry entry = entries . next Element ( ) ;  File Output Stream fos = null ;  Input Stream is = null ; try { is = zip File . get Input Stream ( entry ) ; fos = new  File Output Stream ( new  File ( directory , entry . get Name ( ) ) ) ; int bytes ; byte [ ] packet = new byte [  COPY_ PACKET_ SIZE ] ; while ( ( bytes = is . read ( packet , _ NUM ,  COPY_ PACKET_ SIZE ) ) != - _ NUM ) fos . write ( packet , _ NUM , bytes ) ; } finally { try { if ( fos != null ) fos . close ( ) ; } catch (  Exception e ) {  LOGGER . log (  Level .  SEVERE , _ STR , e ) ; } try { if ( is != null ) is . close ( ) ; } catch (  Exception e ) {  LOGGER . log (  Level .  SEVERE , _ STR , e ) ; } } } } catch (  Exception e ) {  LOGGER . log (  Level .  SEVERE , _ STR , e ) ; return null ; } finally { try { if ( zip File != null ) zip File . close ( ) ; } catch (  Exception e ) {  LOGGER . log (  Level .  SEVERE , _ STR , e ) ; } } return directory ; }
public int update (  String table ,  String key ,  Hash Map <  String ,  Byte Iterator > values ) { long st =  System . nano Time ( ) ; int res = _db . update ( table , key , values ) ; long en =  System . nano Time ( ) ; _measurements . measure ( _ STR , ( int ) ( ( en - st ) / _ NUM ) ) ; _measurements . report Return Code ( _ STR , res ) ; return res ; }
public static  String html Single Quotes (  String str ) { str = str . replace All ( _ STR , _ STR ) ; str = str . replace All ( _ STR , _ STR ) ; str = str . replace All ( _ STR , _ STR ) ; str = str . replace All ( _ STR , _ STR ) ; return str ; }
public static long spooky4 ( final  Bit Vector bv , final long prefix Length , final long seed , final long [ ] state ) { long h0 , h1 , h2 , h3 ; h0 = seed ; h1 = seed ; h2 =  ARBITRARY_ BITS ; h3 =  ARBITRARY_ BITS ; long pos ; if ( prefix Length >= _ NUM *  Long .  SIZE ) { final int p = _ NUM * ( int ) ( ( prefix Length - _ NUM *  Long .  SIZE ) / ( _ NUM *  Long .  SIZE ) ) ; h0 = state [ p + _ NUM ] ; h1 = state [ p + _ NUM ] ; h2 = state [ p + _ NUM ] ; h3 = state [ p + _ NUM ] ; pos = p *  Long .  SIZE + _ NUM *  Long .  SIZE ; } else pos = _ NUM ; long remaining = prefix Length - pos ; if ( remaining >=  Long .  SIZE * _ NUM ) { h0 += bv . get Long ( pos + _ NUM *  Long .  SIZE , pos + _ NUM *  Long .  SIZE ) ; h1 += bv . get Long ( pos + _ NUM *  Long .  SIZE , pos + _ NUM *  Long .  SIZE ) ; remaining -= _ NUM *  Long .  SIZE ; pos += _ NUM *  Long .  SIZE ; } if ( remaining >  Long .  SIZE ) { h2 += bv . get Long ( pos + _ NUM *  Long .  SIZE , pos + _ NUM *  Long .  SIZE ) ; h3 += bv . get Long ( pos + _ NUM *  Long .  SIZE , prefix Length ) ; } else if ( remaining > _ NUM ) { h2 += bv . get Long ( pos , prefix Length ) ; } else { h2 +=  ARBITRARY_ BITS ; h3 +=  ARBITRARY_ BITS ; } h0 += prefix Length ; h3 ^= h2 ; h2 =  Long . rotate Left ( h2 , _ NUM ) ; h3 += h2 ; h0 ^= h3 ; h3 =  Long . rotate Left ( h3 , _ NUM ) ; h0 += h3 ; h1 ^= h0 ; h0 =  Long . rotate Left ( h0 , _ NUM ) ; h1 += h0 ; h2 ^= h1 ; h1 =  Long . rotate Left ( h1 , _ NUM ) ; h2 += h1 ; h3 ^= h2 ; h2 =  Long . rotate Left ( h2 , _ NUM ) ; h3 += h2 ; h0 ^= h3 ; h3 =  Long . rotate Left ( h3 , _ NUM ) ; h0 += h3 ; h1 ^= h0 ; h0 =  Long . rotate Left ( h0 , _ NUM ) ; h1 += h0 ; h2 ^= h1 ; h1 =  Long . rotate Left ( h1 , _ NUM ) ; h2 += h1 ; h3 ^= h2 ; h2 =  Long . rotate Left ( h2 , _ NUM ) ; h3 += h2 ; h0 ^= h3 ; h3 =  Long . rotate Left ( h3 , _ NUM ) ; h0 += h3 ; h1 ^= h0 ; h0 =  Long . rotate Left ( h0 , _ NUM ) ; h1 += h0 ; return h0 ; }
public  Free Cell Node next ( ) {  String line = sc . next Line ( ) ;  String Tokenizer st = new  String Tokenizer ( line , _ STR ) ; int val =  Integer . value Of ( st . next Token ( ) ) ; if ( val != deal ) { throw new  No Such Element Exception ( _ STR + deal + _ STR ) ; } int [ ] deals = new int [ _ NUM ] ; int idx = _ NUM ; while ( st . has More Tokens ( ) ) { deals [ idx ++ ] =  Integer . value Of ( st . next Token ( ) ) ; } deal ++ ; return  Deal . initialize ( deals ) ; }
private void add To Map (  Map <  String ,  Collection <  Cluster Node > > cache Map ,  String cache Name ,  Cluster Node rich ) {  Collection <  Cluster Node > cache Nodes = cache Map . get ( cache Name ) ; if ( cache Nodes == null ) { cache Nodes = new  Array List < > ( all Nodes . size ( ) ) ; cache Map . put ( cache Name , cache Nodes ) ; } cache Nodes . add ( rich ) ; }
private static void adjust (  Object [ ] array ,  Comparator c , int lower , int upper ) { int j , k ;  Object temp ; j = lower ; k = lower * _ NUM ; while ( k <= upper ) { if ( ( k < upper ) && ( c . compare ( array [ k - _ NUM ] , array [ k ] ) < _ NUM ) ) { k += _ NUM ; } if ( c . compare ( array [ j - _ NUM ] , array [ k - _ NUM ] ) < _ NUM ) { temp = array [ j - _ NUM ] ; array [ j - _ NUM ] = array [ k - _ NUM ] ; array [ k - _ NUM ] = temp ; } j = k ; k *= _ NUM ; } }
public synchronized int index Of (  IAudio Processor processor ) { return processors . index Of ( processor ) ; }
private boolean ends With ( char s [ ] , int len ,  String suffix ) { final int suffix Len = suffix . length ( ) ; if ( suffix Len > len ) return _ BOOL ; for ( int i = suffix Len - _ NUM ; i >= _ NUM ; i -- ) if ( s [ len - ( suffix Len - i ) ] != suffix . char At ( i ) ) return _ BOOL ; return _ BOOL ; }
protected void notify Locator (  L locator ) { synchronized ( this ) { if ( ! known Locators . add ( locator . get Partition Id ( ) ) ) { throw new  Illegal State Exception ( _ STR + locator ) ; } } }
private static void task Cancelled (  Progress Thread task ) { for (  Progress Thread State Listener l : listener . get Listeners (  Progress Thread State Listener . class ) ) { l . progress Thread Cancelled ( task ) ; } }
public static final void is XMLChar WF (  DOMError Handler error Handler ,  DOMError Impl error ,  DOMLocator Impl locator ,  String datavalue , boolean is XML11 Version ) { if ( datavalue == null || ( datavalue . length ( ) == _ NUM ) ) { return ; } char [ ] dataarray = datavalue . to Char Array ( ) ; int datalength = dataarray . length ; if ( is XML11 Version ) { int i = _ NUM ; while ( i < datalength ) { if (  XML11 Char . is XML11 Invalid ( dataarray [ i ++ ] ) ) { char ch = dataarray [ i - _ NUM ] ; if (  XMLChar . is High Surrogate ( ch ) && i < datalength ) { char ch2 = dataarray [ i ++ ] ; if (  XMLChar . is Low Surrogate ( ch2 ) &&  XMLChar . is Supplemental (  XMLChar . supplemental ( ch , ch2 ) ) ) { continue ; } }  String msg =  DOMMessage Formatter . format Message (  DOMMessage Formatter .  DOM_ DOMAIN , _ STR , new  Object [ ] {  Integer . to String ( dataarray [ i - _ NUM ] , _ NUM ) } ) ; report DOMError ( error Handler , error , locator , msg ,  DOMError .  SEVERITY_ ERROR , _ STR ) ; } } } else { int i = _ NUM ; while ( i < datalength ) { if (  XMLChar . is Invalid ( dataarray [ i ++ ] ) ) { char ch = dataarray [ i - _ NUM ] ; if (  XMLChar . is High Surrogate ( ch ) && i < datalength ) { char ch2 = dataarray [ i ++ ] ; if (  XMLChar . is Low Surrogate ( ch2 ) &&  XMLChar . is Supplemental (  XMLChar . supplemental ( ch , ch2 ) ) ) { continue ; } }  String msg =  DOMMessage Formatter . format Message (  DOMMessage Formatter .  DOM_ DOMAIN , _ STR , new  Object [ ] {  Integer . to String ( dataarray [ i - _ NUM ] , _ NUM ) } ) ; report DOMError ( error Handler , error , locator , msg ,  DOMError .  SEVERITY_ ERROR , _ STR ) ; } } } }
@  Override public void resume Locking ( ) { check Destroyed ( ) ; try { unlock (  SUSPEND_ LOCKING_ TOKEN ) ; } catch (  Illegal State Exception e ) { check Destroyed ( ) ; throw e ; } }
public  Properties load Properties (  String artifact ,  String version ) throws  IOException {  Properties props = new  Properties ( ) ;  Path properties File = get Properties File ( artifact , version ) ; if ( !  Files . exists ( properties File ) ) { throw new  Artifact Not Found Exception ( artifact , version ) ; } try (  Input Stream in = new  Buffered Input Stream (  Files . new Input Stream ( properties File ) ) ) { props . load ( in ) ; } return props ; }
public void load Attribute Data (  String file Name ) throws  IOException {  Input Stream ins =  Resource Manager . get File As Stream ( file Name ) ; load Attribute Data ( ins ) ; ins . close ( ) ; }
public static void check Reader (  Index Reader reader ) throws  IOException { for (  Leaf Reader Context context : reader . leaves ( ) ) { check Reader ( context . reader ( ) , _ BOOL ) ; } }
public static void circumvent Bug2650 (  Document doc ) {  Element document Element = doc . get Document Element ( ) ;  Attr xmlns Attr = document Element . get Attribute Node NS (  Constants .  Namespace Spec NS , _ STR ) ; if ( xmlns Attr == null ) { document Element . set Attribute NS (  Constants .  Namespace Spec NS , _ STR , _ STR ) ; }  XMLUtils . circumvent Bug2650internal ( doc ) ; }
public void mouse Release ( int x , int y , int mouse Button ) { mouse X = x ; mouse Y = y ; if (  Math . abs ( velocity ) > _ NUM ) { amplitude = _ NUM * velocity ; timestamp =  System . current Time Millis ( ) ; double length =  Math . sqrt ( last Dx * last Dx + last Dy * last Dy ) ; last Dx /= length ; last Dy /= length ; } else { amplitude = _ NUM ; update Look At ( ) ; } }
public int size ( ) { return samples . size ( ) ; }
public static  X509 Certificate read X509 Certificate (  URL url ) throws  IOException ,  Certificate Exception {  URLConnection connection = url . open Connection ( ) ;  Input Stream is = connection . get Input Stream ( ) ; try {  Certificate Factory servercf =  Certificate Factory . get Instance ( _ STR ) ; return (  X509 Certificate ) servercf . generate Certificate ( is ) ; } finally { is . close ( ) ; } }
public int connect Timeout ( ) { return reader . get Integer (  CONNECT_ TIMEOUT ,  DEFAULT_ CONNECT_ TIMEOUT ) ; }
default  B with (  String key ,  Object value ) { return with ( key , value != null ? value . to String ( ) : null ) ; }
private int encrypt Column Contents (  String column Name , int table ID ) throws  Exception {  String table Name =  MTable . get Table Name ( get Ctx ( ) , table ID ) ; return encrypt Column Contents ( column Name , table Name ) ; }
protected synchronized long currentchunkpointer ( ) throws  IOException { long fp = backing Random Access File . get File Pointer ( ) ; if ( fp < f Header . header Size ( ) ) { return - _ NUM ; } else { fp -= f Header . header Size ( ) ; return ( fp /  CHUNK_ ENC_ SIZE ) ; } }
public void add Layout (  Loading Layout layout ) { if ( null != layout ) { m Loading Layouts . add ( layout ) ; } }
public static float random ( float f ) { return ( ( float )  Math . random ( ) ) * f ; }
public static  Method find Instance Method (  Class < ? > type ,  String name ,  Class < ? > ... args ) throws  No Such Method Exception {  Method method = find Method ( type , name , args ) ; if (  Modifier . is Static ( method . get Modifiers ( ) ) ) { throw new  No Such Method Exception ( _ STR + name + _ STR ) ; } return method ; }
private void fetch Search Service Cards From Server (  String keyword ) { final  Map <  String ,  String > params = new  Hash Map <  String ,  String > ( _ NUM ) ; params . put (  Http Constants .  LATITUDE ,  Shared Preference Helper . get String (  R . string . pref_latitude ) ) ; params . put (  Http Constants .  LONGITUDE ,  Shared Preference Helper . get String (  R . string . pref_longitude ) ) ; params . put (  Http Constants .  TYPE ,  Http Constants .  Search Type .  SERVICE_ CARD ) ; params . put (  Http Constants .  PER , _ STR ) ; params . put (  Http Constants .  RADIUS , _ STR ) ; params . put (  Http Constants .  TITLE , keyword ) ;  Retro Callback retro Callback ; retro Callback = new  Retro Callback ( this ) ; retro Callback . set Request Id (  Http Constants .  Api Response Codes .  SEARCH_ SERVICES ) ; retro Callback List . add ( retro Callback ) ; params . put (  Http Constants .  PAGE , _ STR ) ; m Yelo Api . get Service Cards ( params , retro Callback ) ; m Swipe Refresh Layout . set Refreshing ( _ BOOL ) ; }
public void remove All Phone Numbers ( ) { phone Numbers . clear ( ) ; }
public static final  String digits And Plus Only (  Matcher Compat matcher ) {  String Builder buffer = new  String Builder ( ) ;  String matching Region = matcher . group ( ) ; for ( int i = _ NUM , size = matching Region . length ( ) ; i < size ; i ++ ) { char character = matching Region . char At ( i ) ; if ( character == _ STR ||  Character . is Digit ( character ) ) { buffer . append ( character ) ; } } return buffer . to String ( ) ; }
public static boolean equals (  String a ,  String b ) { if ( a == null ) { return b == null ; } return a . equals ( b ) ; }
private int find Marker Segment Position (  Class cls , boolean first ) { if ( first ) {  List Iterator iter = marker Sequence . list Iterator ( ) ; for ( int i = _ NUM ; iter . has Next ( ) ; i ++ ) {  Marker Segment seg = (  Marker Segment ) iter . next ( ) ; if ( cls . is Instance ( seg ) ) { return i ; } } } else {  List Iterator iter = marker Sequence . list Iterator ( marker Sequence . size ( ) ) ; for ( int i = marker Sequence . size ( ) - _ NUM ; iter . has Previous ( ) ; i -- ) {  Marker Segment seg = (  Marker Segment ) iter . previous ( ) ; if ( cls . is Instance ( seg ) ) { return i ; } } } return - _ NUM ; }
private static void stop ( ) { if ( db Cli != null ) { db Cli . stop ( ) ; }  System . exit ( _ NUM ) ; }
public  Publisher Concat Array <  T > concat Additional Source Last (  Publisher < ? extends  T > source ) { int n = array . length ; @  Suppress Warnings ( _ STR )  Publisher < ? extends  T > [ ] new Array = new  Publisher [ n + _ NUM ] ;  System . arraycopy ( array , _ NUM , new Array , _ NUM , n ) ; new Array [ n ] = source ; return new  Publisher Concat Array < > ( delay Error , new Array ) ; }
public void send Tams Message (  Tams Message m ,  Tams Listener tl ) { tm = m ; tmq . offer ( tm ) ; if ( tm . is Binary ( ) ) { } else { } send Message ( tm , tl ) ; }
@  Override public boolean e Is Set ( int feature ID ) { switch ( feature ID ) { case  SGen Package .  STRING_ LITERAL__ VALUE : return  VALUE_ EDEFAULT == null ? value != null : !  VALUE_ EDEFAULT . equals ( value ) ; } return super . e Is Set ( feature ID ) ; }
public boolean is Absolute URI ( ) { return ( _scheme != null ) ; }
public  Subject Key Identifier Extension (  Boolean critical ,  Object value ) throws  IOException { this . extension Id =  PKIXExtensions .  Subject Key_ Id ; this . critical = critical . boolean Value ( ) ; this . extension Value = ( byte [ ] ) value ;  Der Value val = new  Der Value ( this . extension Value ) ; this . id = new  Key Identifier ( val ) ; }
public static  Secret Key generate Key (  String algorithm ) throws  Encoding Exception { try {  Key Generator kgen =  Key Generator . get Instance ( algorithm ) ; kgen . init ( _ NUM ) ;  Secret Key key = kgen . generate Key ( ) ; return key ; } catch (  Exception e ) { throw new  Encoding Exception ( e ) ; } }
@  Override public void property Change ( java . beans .  Property Change Event e ) { log . debug ( _ STR + e . get Property Name ( ) + _ STR + e . get Old Value ( ) + _ STR + e . get New Value ( ) ) ; }
public  Spy Versions load Versions ( ) throws  XMLException { set Loading ( _ BOOL ) ; try { final  URL url = new  URL ( property Loader . get Property (  Base Property Names .  VERSION_ INFO_ URL ) ) ; versions = (  Spy Versions ) load From Input Stream ( url . open Stream ( ) ) ; } catch (  IOException |  Null Pointer Exception e ) { throw new  XMLException ( _ STR + property Loader . get Property (  Base Property Names .  VERSION_ INFO_ URL ) , e ) ; } set Loading ( _ BOOL ) ; return versions ; }
@  Request Mapping ( value = _ STR , method =  POST , produces =  APPLICATION_ JSON_ VALUE ) public  Response Entity <  Page Response <  Role DTO > > find All ( @  Request Body  Page Request By Example <  Role DTO > prbe ) throws  URISyntax Exception {  Page Response <  Role DTO > page Response = role DTOService . find All ( prbe ) ; return new  Response Entity < > ( page Response , new  Http Headers ( ) ,  Http Status .  OK ) ; }
public void add Footer View (  View view ) { m Footer Views . add ( view ) ; }
@  Override public  List <  Session > list Sessions ( ) throws  SQLException {  String sql = _ STR ;  Statement stmt = null ;  Result Set rs = null ;  Linked List <  Session > sessions = new  Linked List <  Session > ( ) ; try { stmt = db Conn . create Statement ( ) ; rs = stmt . execute Query ( sql ) ; while ( rs . next ( ) ) {  Session session = new  Session ( ) ; session . set Identifier ( rs . get String ( _ STR ) ) ; session . set Login ( rs . get String ( _ STR ) ) ; sessions . add ( session ) ; } } finally { if ( rs != null ) rs . close ( ) ; if ( stmt != null ) stmt . close ( ) ; } return sessions ; }
public void test Empty Offer ( ) {  Submission Publisher <  Integer > p = basic Publisher ( ) ; assert Equals ( _ NUM , p . offer ( _ NUM , null ) ) ; }
public  String type ( ) { return type ; }
public void print Usage ( ) { out ( get Usage String ( ) ) ; }
private int test In Range ( long actual , long expected , long epsilon ) { long min = expected - epsilon ; long max = expected + epsilon ; return actual < min ? - _ NUM : actual > max ? _ NUM : _ NUM ; }
public  Spider Html Parser (  Spider Param params ) { super ( ) ; if ( params == null ) { throw new  Illegal Argument Exception ( _ STR ) ; } this . params = params ; }
public void flush ( ) { flush ( _ BOOL ) ; }
public  Builder entity (  Entity entity ) { if ( entities == null ) { entities = new  Array List <  Entity > ( ) ; } entities . add ( entity ) ; return this ; }
protected boolean [ ] dataset Integrity ( boolean nominal Predictor , boolean numeric Predictor , boolean string Predictor , boolean date Predictor , boolean relational Predictor , boolean multi Instance , int class Type , boolean predictor Missing , boolean class Missing ) { print ( _ STR ) ; print Attribute Summary ( nominal Predictor , numeric Predictor , string Predictor , date Predictor , relational Predictor , multi Instance , class Type ) ; print ( _ STR ) ; int num Train = get Num Instances ( ) , num Test = get Num Instances ( ) , num Classes = _ NUM , missing Level = _ NUM ; boolean [ ] result = new boolean [ _ NUM ] ;  Instances train = null ;  Instances test = null ;  Classifier classifier = null ;  Evaluation evaluation = null ; boolean built = _ BOOL ; try { train = make Test Dataset ( _ NUM , num Train , nominal Predictor ? get Num Nominal ( ) : _ NUM , numeric Predictor ? get Num Numeric ( ) : _ NUM , string Predictor ? get Num String ( ) : _ NUM , date Predictor ? get Num Date ( ) : _ NUM , relational Predictor ? get Num Relational ( ) : _ NUM , num Classes , class Type , multi Instance ) ; test = make Test Dataset ( _ NUM , num Test , nominal Predictor ? get Num Nominal ( ) : _ NUM , numeric Predictor ? get Num Numeric ( ) : _ NUM , string Predictor ? get Num String ( ) : _ NUM , date Predictor ? get Num Date ( ) : _ NUM , relational Predictor ? get Num Relational ( ) : _ NUM , num Classes , class Type , multi Instance ) ; if ( missing Level > _ NUM ) { add Missing ( train , missing Level , predictor Missing , class Missing ) ; add Missing ( test ,  Math . min ( missing Level , _ NUM ) , predictor Missing , class Missing ) ; } classifier =  Abstract Classifier . make Copies ( get Classifier ( ) , _ NUM ) [ _ NUM ] ; evaluation = new  Evaluation ( train ) ; } catch (  Exception ex ) { throw new  Error ( _ STR + ex . get Message ( ) ) ; } try {  Instances train Copy = new  Instances ( train ) ;  Instances test Copy = new  Instances ( test ) ; classifier . build Classifier ( train Copy ) ; compare Datasets ( train , train Copy ) ; built = _ BOOL ; test WRTZero R ( classifier , evaluation , train Copy , test Copy ) ; compare Datasets ( test , test Copy ) ; println ( _ STR ) ; result [ _ NUM ] = _ BOOL ; } catch (  Exception ex ) { println ( _ STR ) ; result [ _ NUM ] = _ BOOL ; if ( m_ Debug ) { println ( _ STR ) ; print ( _ STR ) ; if ( built ) { print ( _ STR ) ; } else { print ( _ STR ) ; } println ( _ STR + ex . get Message ( ) + _ STR ) ; println ( _ STR ) ; println ( _ STR + train . to String ( ) + _ STR ) ; println ( _ STR + test . to String ( ) + _ STR ) ; } } return result ; }
public boolean is Empty ( ) { return priority Queue . is Empty ( ) ; }
public boolean is Primitive (  Type type ) throws  Exception { return is Primitive ( type . get Type ( ) ) ; }
private void debug Segment Entries (  Write Stream out ,  Read Stream is ,  Segment Extent extent ,  Table Entry table ) throws  IOException {  Temp Buffer t Buf =  Temp Buffer . create ( ) ; byte [ ] buffer = t Buf . buffer ( ) ; for ( long ptr = extent . length ( ) -  BLOCK_ SIZE ; ptr > _ NUM ; ptr -=  BLOCK_ SIZE ) { is . position ( ptr ) ; is . read All ( buffer , _ NUM ,  BLOCK_ SIZE ) ; long seq =  Bits Util . read Long ( buffer , _ NUM ) ; int head = _ NUM ; byte [ ] table Key = new byte [ _ NUM ] ;  System . arraycopy ( buffer , head , table Key , _ NUM , table Key . length ) ; is . read All ( table Key , _ NUM , table Key . length ) ; head += table Key . length ; int offset =  BLOCK_ SIZE - _ NUM ; int tail =  Bits Util . read Int16 ( buffer , offset ) ; offset += _ NUM ; boolean is Cont = buffer [ offset ] == _ NUM ; if ( seq <= _ NUM || tail <= _ NUM ) { return ; } while ( ( head = debug Segment Index ( out , is , buffer , extent . address ( ) , ptr , head , table ) ) < tail ) { } if ( ! is Cont ) { break ; } } }
public static void test VNX2 Net Alloc Assign (  Map <  URI ,  List <  Initiator > > net2 Initiators Map A ,  Map <  URI ,  List <  Initiator > > net2 Initiators Map B ,  Map <  URI ,  List <  Initiator > > net2 Initiators Map C ,  Map <  URI ,  List <  Initiator > > net2 Initiators Map D , int max Paths , int min Paths , int paths Per Initiator , int initiators Per Port ) throws  Exception {  Map <  URI ,  Map <  URI ,  List <  Initiator > > > host To Net To Initiators Map = new  Hash Map <  URI ,  Map <  URI ,  List <  Initiator > > > ( ) ;  URI host A = get Host URI ( net2 Initiators Map A ) ; host To Net To Initiators Map . put ( host A , net2 Initiators Map A ) ; if ( net2 Initiators Map B != null ) {  URI host B = get Host URI ( net2 Initiators Map B ) ; host To Net To Initiators Map . put ( host B , net2 Initiators Map B ) ; } if ( net2 Initiators Map C != null ) {  URI host C = get Host URI ( net2 Initiators Map C ) ; host To Net To Initiators Map . put ( host C , net2 Initiators Map C ) ; } if ( net2 Initiators Map D != null ) {  URI host D = get Host URI ( net2 Initiators Map D ) ; host To Net To Initiators Map . put ( host D , net2 Initiators Map D ) ; }  Port Allocation Context net1ctx = create VNXNet1 ( ) ;  Port Allocation Context net2ctx = create VNXNet2 ( ) ;  Port Allocation Context [ ] contexts = new  Port Allocation Context [ ] { net1ctx , net2ctx } ; test Allocation Assignment ( contexts , host To Net To Initiators Map , max Paths , min Paths , paths Per Initiator , initiators Per Port , _ STR , null ) ; }
protected void process Mapping Key Converter (  Database Mapping mapping ,  String convert Value ,  List <  Convert Metadata > converts ,  Metadata Class reference Class ,  Metadata Class reference Class With Generics ) { process Mapping Converter ( mapping , convert Value , get Map Key Converts ( converts ) , reference Class , reference Class With Generics , _ BOOL ) ; }
protected  Namespace remove ( int index ) {  Namespace namespace = namespace Stack . remove ( index ) ; namespace Cache List . remove ( index ) ; default Namespace = null ; current Namespace Cache = null ; return namespace ; }
public static boolean contains (  Data Flavor [ ] array ,  Data Flavor flavor ) { for ( int i = _ NUM ; i < array . length ; i ++ ) { if ( flavor . equals ( array [ i ] ) ) { return _ BOOL ; } } return _ BOOL ; }
public void test Choice Missing Icon Error Handling ( ) {  String xml = _ STR ; xml += create Start Mission Xml ( _ STR , _ STR ) ; xml += create Start Choice Moment Xml ( _ STR , _ NUM , _ STR , _ STR ) ; xml += create Choice Xml ( _ STR , _ STR , _ STR , _ BOOL , _ BOOL , _ STR ) ; xml += create Choice Xml ( _ STR , _ STR , _ STR , _ BOOL , _ BOOL , null ) ; xml += create End Choice Moment Xml ( ) ; xml += create End Mission Xml ( ) ;  Utils . log Debug (  TAG , xml ) ;  Input Stream moment Input Stream = new  Byte Array Input Stream ( xml . get Bytes ( ) ) ; m Mission = new  Mission ( m Mission Data ) ; boolean did Mission Parse Fail = _ BOOL ; try { m Mission . read Moments ( moment Input Stream ) ; } catch (  Mission Parse Exception e ) { e . print Stack Trace ( ) ; did Mission Parse Fail = _ BOOL ; }  Assert . assert Equals ( _ BOOL , did Mission Parse Fail ) ; }
static  File Channel new File Channel (  String path For Windows ,  String path To Check ,  Set < ? extends  Open Option > options , long p Security Descriptor ) throws  Windows Exception {  Flags flags =  Flags . to Flags ( options ) ; if ( ! flags . read && ! flags . write ) { if ( flags . append ) { flags . write = _ BOOL ; } else { flags . read = _ BOOL ; } } if ( flags . read && flags . append ) throw new  Illegal Argument Exception ( _ STR ) ; if ( flags . append && flags . truncate Existing ) throw new  Illegal Argument Exception ( _ STR ) ;  File Descriptor fd Obj = open ( path For Windows , path To Check , flags , p Security Descriptor ) ; return  File Channel Impl . open ( fd Obj , path For Windows , flags . read , flags . write , flags . append , null ) ; }
public long next ID ( ) { return id . get And Increment ( ) ; }
private void fill Field Values ( ) { if ( is Creation Panel ) { phrase . set Text ( _ STR +  Speech .  DEFAULT_ PHRASE ) ; threshold . set Text ( _ STR +  Speech .  DEFAULT_ THRESHOLD ) ; } else { phrase . set Text ( _ STR + speech Effector . get Phrase ( ) ) ; threshold . set Text ( _ STR + speech Effector . get Threshold ( ) ) ; } }
public boolean mkdir ( ) {  Security Manager security =  System . get Security Manager ( ) ; if ( security != null ) { security . check Write ( path ) ; } if ( is Invalid ( ) ) { return _ BOOL ; } return fs . create Directory ( this ) ; }
public boolean retain All (  Abstract Byte List other ) { if ( other . size ( ) == _ NUM ) { if ( size == _ NUM ) return _ BOOL ; set Size ( _ NUM ) ; return _ BOOL ; } int limit = other . size ( ) - _ NUM ; int j = _ NUM ; for ( int i = _ NUM ; i < size ; i ++ ) { if ( other . index Of From To ( get Quick ( i ) , _ NUM , limit ) >= _ NUM ) set Quick ( j ++ , get Quick ( i ) ) ; } boolean modified = ( j != size ) ; set Size ( j ) ; return modified ; }
public byte [ ] to Byte Array ( ) { write Current Byte ( ) ; byte [ ] byte Array = byte Stream . to Byte Array ( ) ; byte Stream . reset ( ) ; return byte Array ; }
void add Index (  Index index ) { indexes . add ( index ) ; }
public  Builder with Key Store Path (  String key Store Path ) { properties . set Property (  Netty Options .  SSL_ KEY_ STORE_ PATH ,  Assert . not Null ( key Store Path , _ STR ) ) ; return this ; }
public  Distributed Data Manager Impl (  Zk Connection conn ,  String base Path , long max Nodes ) { _zk Client = conn . curator ( ) ; if (  String Utils . is Empty ( base Path ) || ! base Path . starts With ( _ STR ) || ( base Path . length ( ) < _ NUM ) || base Path . ends With ( _ STR ) ) { throw new  Illegal Argument Exception ( _ STR ) ; } _base Path = base Path ; _max Nodes = max Nodes ; _log . info ( _ STR , _base Path , _max Nodes ) ; ensure Cache Started ( ) ; }
private static  String merge Text And Mnemonic (  String text , final int mnemonic , final int mnemonic Index ) { if ( text == null ) { text = _ STR ; } final int index ; if ( mnemonic Index >= _ NUM && mnemonic Index < text . length ( ) &&  Character . to Upper Case ( text . char At ( mnemonic Index ) ) == mnemonic ) { index = mnemonic Index ; } else { index = - _ NUM ; } final  String Buffer buffer = new  String Buffer ( text ) ; if ( index != - _ NUM ) { buffer . insert ( index , _ STR ) ; for ( int i = buffer . length ( ) - _ NUM ; i >= _ NUM ; i -- ) { if ( buffer . char At ( i ) == _ STR && i != index ) { buffer . insert ( i , _ STR ) ; } } } return buffer . to String ( ) ; }
public static void gc ( ) {  RUNTIME . gc ( ) ; }
private  Node rotate Left (  Node x ) {  Node y = x . right ; x . right = y . left ; y . left = x ; y . size = x . size ; x . size = _ NUM + size ( x . left ) + size ( x . right ) ; x . height = _ NUM +  Math . max ( height ( x . left ) , height ( x . right ) ) ; y . height = _ NUM +  Math . max ( height ( y . left ) , height ( y . right ) ) ; return y ; }
public boolean has Warnings ( ) { if ( warnings . size ( ) > _ NUM ) { return _ BOOL ; } else { return _ BOOL ; } }
public static void copy (  String source ,  String target ) {  Input Stream in = null ;  Output Stream out = null ; try { in = new  Buffered Input Stream ( new  File Input Stream ( source ) ) ; out = new  Buffered Output Stream ( new  File Output Stream ( target ) ) ; for ( int c = read ( in ) ; c != - _ NUM ; c = read ( in ) ) { write ( out , c ) ; } } catch (  File Not Found Exception e ) { throw new  Runtime Exception ( e . get Message ( ) , e ) ; } finally { close ( in ) ; close ( out ) ; } close ( in ) ; close ( out ) ; }
public static  Compound Tag read Compound (  Byte Buf buf ) { return read Compound ( buf , _ BOOL ) ; }
private void stop Timer (  Timer timer ) { if ( timer != null && timer . is Running ( ) ) { timer . stop ( ) ; } }
@  Override public int compare To (  Field o ) { return  DEFAULT_ SORT . compare ( this , o ) ; }
static  String property Var ( final  String property ) { return  String . format ( _ STR , property ) ; }
public void add Data ( double [ ] hist Data ,  Integer index ) { data . remove ( index . int Value ( ) ) ; data . add ( index . int Value ( ) , hist Data ) ; redraw ( ) ; }
private void connect ( final  String database Url , final  Properties properties ) throws  SQLException { if ( m_connection != null ) { close Connection ( ) ; } try { m_connection =  Driver Manager . get Connection ( database Url , properties ) ; } catch ( final  SQLException exception ) {  Navi Logger . severe ( _ STR , exception ) ; throw exception ; } }
public  Bayes Estimator Editor (  Bayes Estimator Wrapper bayes Est Wrapper ) { this ( bayes Est Wrapper . get Estimated Bayes Im ( ) , bayes Est Wrapper . get Data Set ( ) ) ; }
public void add Action Listener (  Action Listener listener ) { }
public  String escape (  String string ) { int length = string . length ( ) ; for ( int index = _ NUM ; index < length ; index ++ ) { if ( escape ( string . char At ( index ) ) != null ) { return escape Slow ( string , index ) ; } } return string ; }
protected  Granularity generate Granularity ( @  Not Null  String granularity , @  Not Null  Date Time Zone date Time Zone , @  Not Null  Granularity Parser granularity Parser ) throws  Bad Api Request Exception { try { return granularity Parser . parse Granularity ( granularity , date Time Zone ) ; } catch (  Granularity Parse Exception e ) {  LOG . error (  UNKNOWN_ GRANULARITY . log Format ( granularity ) , granularity ) ; throw new  Bad Api Request Exception ( e . get Message ( ) ) ; } }
public  Word Iterator (  Locale locale ) { m Iterator =  Break Iterator . get Word Instance ( locale ) ; }
private void dump ( int counter ,  INode next ) { if ( ! logger . is Trace Enabled ( ) ) { return ; }  String leaf Text = leaf Text ( next ) ; logger . trace (  String . format ( _ STR , counter , next . to String ( ) , leaf Text ) ) ; }
private void update Data Type State ( ) { boolean is Sync Enabled = m Sync Switch Preference . is Checked ( ) ; boolean sync Everything = m Sync Everything . is Checked ( ) ; boolean password Sync Configurable = m Profile Sync Service . is Sync Initialized ( ) && m Profile Sync Service . is Cryptographer Ready ( ) ; for (  Check Box Preference pref : m All Types ) { boolean can Sync Type = pref != m Sync Passwords || password Sync Configurable ; if ( ! is Sync Enabled ) { pref . set Checked ( _ BOOL ) ; } else if ( sync Everything ) { pref . set Checked ( can Sync Type ) ; } pref . set Enabled ( is Sync Enabled && ! sync Everything && can Sync Type ) ; } if ( is Sync Enabled && ! sync Everything ) {  Set <  Integer > sync Types = m Profile Sync Service . get Preferred Data Types ( ) ; m Sync Autofill . set Checked ( sync Types . contains (  Model Type .  AUTOFILL ) ) ; m Sync Bookmarks . set Checked ( sync Types . contains (  Model Type .  BOOKMARKS ) ) ; m Sync Omnibox . set Checked ( sync Types . contains (  Model Type .  TYPED_ URLS ) ) ; m Sync Passwords . set Checked ( password Sync Configurable && sync Types . contains (  Model Type .  PASSWORDS ) ) ; m Sync Recent Tabs . set Checked ( sync Types . contains (  Model Type .  PROXY_ TABS ) ) ; m Sync Settings . set Checked ( sync Types . contains (  Model Type .  PRIORITY_ PREFERENCES ) ) ; } }
private static boolean is Merged Segment (  String seg Name ) { if ( seg Name . contains ( _ STR ) ) { return _ BOOL ; } return _ BOOL ; }
public int size ( ) { return buffer . size ( ) ; }
public static void delete Contents (  File dir ) throws  IOException {  File [ ] files = dir . list Files ( ) ; if ( files != null ) { for (  File file : files ) { if ( file . is Directory ( ) ) { delete Contents ( file ) ; } file . delete ( ) ; } } }
public void remove Bandwidth (  String name ) { if ( name == null ) { throw new  Null Pointer Exception ( _ STR ) ; } else { int i = _ NUM ; for ( i = _ NUM ; i < bandwidth Fields . size ( ) ; i ++ ) {  Bandwidth Field bandwidth Field = (  Bandwidth Field ) bandwidth Fields . element At ( i ) ;  String type = bandwidth Field . get Bwtype ( ) ; if ( type != null && type . equals ( name ) ) break ; } if ( i < bandwidth Fields . size ( ) ) bandwidth Fields . remove Element At ( i ) ; } }
public static long now In Millis ( ) { return  System . current Time Millis ( ) ; }
public static  String Buffer string Substitution (  String arg Str ,  Map vars ) {  String Buffer arg Buf = new  String Buffer ( ) ; for ( int c Idx = _ NUM ; c Idx < arg Str . length ( ) ; ) { char ch = arg Str . char At ( c Idx ) ; switch ( ch ) { case _ STR :  String Buffer name Buf = new  String Buffer ( ) ; for ( ++ c Idx ; c Idx < arg Str . length ( ) ; ++ c Idx ) { ch = arg Str . char At ( c Idx ) ; if ( ch == _ STR ||  Character . is Letter Or Digit ( ch ) ) name Buf . append ( ch ) ; else break ; } if ( name Buf . length ( ) > _ NUM ) {  String value = (  String ) vars . get ( name Buf . to String ( ) ) ; if ( value != null ) { arg Buf . append ( value ) ; } } break ; default : arg Buf . append ( ch ) ; ++ c Idx ; break ; } } return arg Buf ; }
private boolean ends With ( char s [ ] , int len ,  String suffix ) { final int suffix Len = suffix . length ( ) ; if ( suffix Len > len ) return _ BOOL ; for ( int i = suffix Len - _ NUM ; i >= _ NUM ; i -- ) if ( s [ len - ( suffix Len - i ) ] != suffix . char At ( i ) ) return _ BOOL ; return _ BOOL ; }
public void throw Exception ( ) throws  Exception { throw new  Exception ( _ STR ) ; }
public  Properties strip Prefix (  Properties props ) {  Properties result = new  Properties ( ) ; for (  String name : props . string Property Names ( ) ) { validate Namespaced ( name ) ;  String val = props . get Property ( name ) ; name = strip Prefix ( name ) ; result . set Property ( name , val ) ; } return result ; }
public  Object first Row ( ) throws  SQLException {  List rows = rows ( ) ; if ( rows . is Empty ( ) ) return null ; return ( rows . get ( _ NUM ) ) ; }
protected void add (  Object component ) { if ( component == null ) { return ; } components . add ( component ) ; }
public  Node Representation ( ) { }
public  Standard Pie Section Label Generator (  String label Format ,  Locale locale ) { this ( label Format ,  Number Format . get Number Instance ( locale ) ,  Number Format . get Percent Instance ( locale ) ) ; }
@  Override public  Completable Future <  String > join ( final  Char Sequence delimiter , final  Char Sequence prefix , final  Char Sequence suffix ) { return  Completable Future . supply Async ( null , exec ) ; }
protected  CCCall Func (  Object t ,  String s ,  Class < ? > [ ] p ) { target Callback = t ; selector = s ; partypes = p ; if ( partypes == null ) { try {  Class < ? > cls = target Callback . get Class ( ) ; invocation = cls . get Method ( selector ) ; } catch (  No Such Method Exception e ) { e . print Stack Trace ( ) ; } } else { try {  Class < ? > cls = target Callback . get Class ( ) ; invocation = cls . get Method ( selector , partypes ) ; } catch (  No Such Method Exception e ) { e . print Stack Trace ( ) ; } } }
public static final boolean is Ignorable IOException (  Exception e ) { if ( e instanceof  Closed Channel Exception ) { return _ BOOL ; }  String msg = e . get Message ( ) ; if ( msg == null ) { msg = e . to String ( ) ; } msg = msg . to Lower Case ( ) ; return ( msg . index Of ( _ STR ) >= _ NUM ) || ( msg . index Of ( _ STR ) >= _ NUM ) || ( msg . index Of ( _ STR ) >= _ NUM ) ; }
private  String compute ( double left ,  String right , boolean is Integer ) { if (  Double . is Na N ( left ) && right == null ) { return null ; } if ( is Integer && left == ( int ) left ) { return ( int ) left + ( right == null ? _ STR : right ) ; } else if (  Double . is Infinite ( left ) ) { return  Tools . format Number ( left ) + ( right == null ? _ STR : right ) ; } else { return (  Double . is Na N ( left ) ? _ STR : left ) + ( right == null ? _ STR : right ) ; } }
public void remove Property Change Listener (  Property Change Listener listener ) { property Change Support . remove Property Change Listener ( listener ) ; }
public void load XML (  Node stepnode ,  List <  Database Meta > databases ,  Map <  String ,  Counter > counters ) throws  Kettle XMLException { try { this . tabel Name =  XMLHandler . get Tag Value ( stepnode , _ STR ) ; this . output Row Size =  XMLHandler . get Tag Value ( stepnode , _ STR ) ; this . fact Dim Lens String =  XMLHandler . get Tag Value ( stepnode , _ STR ) ; this . cube Name =  XMLHandler . get Tag Value ( stepnode , _ STR ) ; this . schema Name =  XMLHandler . get Tag Value ( stepnode , _ STR ) ; this . dimension Count =  XMLHandler . get Tag Value ( stepnode , _ STR ) ; this . no Dictionary Dims =  XMLHandler . get Tag Value ( stepnode , _ STR ) ; this . no Dictionary Dims Mapping =  XMLHandler . get Tag Value ( stepnode , _ STR ) ; this . complex Dimension Count =  XMLHandler . get Tag Value ( stepnode , _ STR ) ; this . measure Count =  XMLHandler . get Tag Value ( stepnode , _ STR ) ; this . update Member Request =  XMLHandler . get Tag Value ( stepnode , _ STR ) ; this . measure Data Type =  XMLHandler . get Tag Value ( stepnode , _ STR ) ; current Restruct Number =  Integer . parse Int (  XMLHandler . get Tag Value ( stepnode , _ STR ) ) ; this . partition ID =  XMLHandler . get Tag Value ( stepnode , _ STR ) ; this . segment Id =  XMLHandler . get Tag Value ( stepnode , _ STR ) ; this . task No =  XMLHandler . get Tag Value ( stepnode , _ STR ) ; } catch (  Exception e ) { throw new  Kettle XMLException ( _ STR , e ) ; } }
public static int calc Hash ( char [ ] buffer , int start , int len ) { int hash = ( int ) buffer [ _ NUM ] ; for ( int i = _ NUM ; i < len ; ++ i ) { hash = ( hash * _ NUM ) + ( int ) buffer [ i ] ; } return hash ; }
public static  Insn List cast ( final  Type from , final  Type to ) {  Insn List list = new  Insn List ( ) ; if ( from != to ) { if ( from ==  Type .  DOUBLE_ TYPE ) { if ( to ==  Type .  FLOAT_ TYPE ) { list . add ( new  Insn Node (  Opcodes .  D2 F ) ) ; } else if ( to ==  Type .  LONG_ TYPE ) { list . add ( new  Insn Node (  Opcodes .  D2 L ) ) ; } else { list . add ( new  Insn Node (  Opcodes .  D2 I ) ) ; list . add ( cast (  Type .  INT_ TYPE , to ) ) ; } } else if ( from ==  Type .  FLOAT_ TYPE ) { if ( to ==  Type .  DOUBLE_ TYPE ) { list . add ( new  Insn Node (  Opcodes .  F2 D ) ) ; } else if ( to ==  Type .  LONG_ TYPE ) { list . add ( new  Insn Node (  Opcodes .  F2 L ) ) ; } else { list . add ( new  Insn Node (  Opcodes .  F2 I ) ) ; list . add ( cast (  Type .  INT_ TYPE , to ) ) ; } } else if ( from ==  Type .  LONG_ TYPE ) { if ( to ==  Type .  DOUBLE_ TYPE ) { list . add ( new  Insn Node (  Opcodes .  L2 D ) ) ; } else if ( to ==  Type .  FLOAT_ TYPE ) { list . add ( new  Insn Node (  Opcodes .  L2 F ) ) ; } else { list . add ( new  Insn Node (  Opcodes .  L2 I ) ) ; list . add ( cast (  Type .  INT_ TYPE , to ) ) ; } } else { if ( to ==  Type .  BYTE_ TYPE ) { list . add ( new  Insn Node (  Opcodes .  I2 B ) ) ; } else if ( to ==  Type .  CHAR_ TYPE ) { list . add ( new  Insn Node (  Opcodes .  I2 C ) ) ; } else if ( to ==  Type .  DOUBLE_ TYPE ) { list . add ( new  Insn Node (  Opcodes .  I2 D ) ) ; } else if ( to ==  Type .  FLOAT_ TYPE ) { list . add ( new  Insn Node (  Opcodes .  I2 F ) ) ; } else if ( to ==  Type .  LONG_ TYPE ) { list . add ( new  Insn Node (  Opcodes .  I2 L ) ) ; } else if ( to ==  Type .  SHORT_ TYPE ) { list . add ( new  Insn Node (  Opcodes .  I2 S ) ) ; } } } return list ; }
public  Channel Change Listener (  String group Name ,  Sound Group group ) { this . group = group ; this . group Name = group Name ; }
private  String process Scanned Files ( final  String path , final  String file Name ) throws  Exception { if ( ! is Error ) { if ( scan Mode ==  Scan Mode Constants .  SCAN_ MODE_ FILE ) { if ( ( temp Files != null ) && ! temp Files . is Empty ( ) ) {  File file = (  File ) temp Files . get ( _ NUM ) ;  File new File = new  File ( path , this . prefix ) ; if ( new File . exists ( ) ) { new File . delete ( ) ; } file . rename To ( new File ) ; clear Temp Files ( ) ; return file Name ; } else { return null ; } } else if ( ( scan Mode ==  Scan Mode Constants .  SCAN_ MODE_ NATIVE ) || ( scan Mode ==  Scan Mode Constants .  SCAN_ MODE_ MEMORY ) ) { if ( ( temp Files != null ) && ! temp Files . is Empty ( ) ) {  File new File = new  File ( path , this . prefix ) ; if ( new File . exists ( ) ) { new File . delete ( ) ; }  File Output Stream fos = null ;  Document document = null ; try { fos = new  File Output Stream ( new File ) ; document = new  Document ( ) ;  Pdf Writer . get Instance ( document , fos ) ; document . open ( ) ;  File file Properties = (  File ) temp Files . get ( _ NUM ) ;  Image image Properties =  Image . get Instance ( file Properties . get Path ( ) ) ; document . set Page Size ( image Properties ) ; document . set Margins ( _ NUM , _ NUM , _ NUM , _ NUM ) ;  File file = null ;  Image image = null ;  Iterator it = temp Files . iterator ( ) ; while ( it . has Next ( ) ) { file = (  File ) it . next ( ) ; document . new Page ( ) ; image =  Image . get Instance ( file . get Path ( ) ) ; document . add ( image ) ; } } catch (  Exception e ) { throw e ; } finally { if ( document != null ) { document . close ( ) ; } if ( fos != null ) { fos . close ( ) ; } } clear Temp Files ( ) ; return new File . get Path ( ) ; } else { return null ; } } } else { clear Temp Files ( ) ; } return null ; }
public static boolean read Boolean (  Byte Buffer buff ) { return buff . get ( ) == _ NUM ; }
public void test Submit Callable ( ) throws  Throwable {  Executor Service e = new  Fork Join Pool ( _ NUM ) ;  Pool Cleaner cleaner = null ; try { cleaner = cleaner ( e ) ;  Future <  String > future = e . submit ( new  String Task ( ) ) ; assert Same (  TEST_ STRING , future . get ( ) ) ; assert True ( future . is Done ( ) ) ; assert False ( future . is Cancelled ( ) ) ; } finally { if ( cleaner != null ) { cleaner . close ( ) ; } } }
public  Rectangle2 D expand (  Rectangle2 D area ,  Rectangle2 D result ) { if ( result == null ) { result = new  Rectangle2 D .  Double ( ) ; } result . set Rect ( area . get X ( ) - this . left , area . get Y ( ) - this . top , area . get Width ( ) + this . left + this . right , area . get Height ( ) + this . top + this . bottom ) ; return result ; }
protected void assert Func Equals ( final  String ... inputs ) throws  Exception {  Solr Query Request req = req ( ) ; try { assert Func Equals ( req , inputs ) ; } finally { req . close ( ) ; } }
protected void finalize ( ) { synchronized ( stats Map ) { stats Map . remove ( stats Name ) ; } synchronized ( this ) { if ( stats File == null ) { return ; } stats State =  Stats .  OFF ; stats File . flush ( ) ; stats File . close ( ) ; stats File = null ; } }
@  Override public void run ( ) { am IActive = _ BOOL ;  String input Header = null ;  String output Header = null ; double  SMALL_ NUM = _ NUM ; if ( args . length <= _ NUM ) { show Feedback ( _ STR ) ; return ; } input Header = args [ _ NUM ] ; output Header = args [ _ NUM ] ;  SMALL_ NUM =  Double . parse Double ( args [ _ NUM ] ) ; if ( ( input Header == null ) || ( output Header == null ) ) { show Feedback ( _ STR ) ; return ; } try { update Progress ( _ STR , - _ NUM ) ; int row_n , col_n ; int row , col ; double z_n ; long k = _ NUM ;  Grid Cell gc = null ; double z ; int [ ]  Dy = { - _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , - _ NUM , - _ NUM } ; int [ ]  Dx = { _ NUM , _ NUM , _ NUM , _ NUM , - _ NUM , - _ NUM , - _ NUM , _ NUM } ; int progress = _ NUM ; int old Progress ;  Whitebox Raster image = new  Whitebox Raster ( input Header , _ STR ) ; int rows = image . get Number Rows ( ) ; int rows Less One = rows - _ NUM ; int cols = image . get Number Columns ( ) ; int num Cells = _ NUM ;  String preferred Palette = image . get Preferred Palette ( ) ; double no Data = image . get No Data Value ( ) ; double [ ] [ ] output = new double [ rows ] [ cols ] ; double [ ] [ ] input = new double [ rows + _ NUM ] [ cols + _ NUM ] ; for ( row = _ NUM ; row < rows + _ NUM ; row ++ ) { input [ row ] [ _ NUM ] = no Data ; input [ row ] [ cols + _ NUM ] = no Data ; } for ( col = _ NUM ; col < cols + _ NUM ; col ++ ) { input [ _ NUM ] [ col ] = no Data ; input [ rows + _ NUM ] [ col ] = no Data ; } double [ ] data ; for ( row = _ NUM ; row < rows ; row ++ ) { data = image . get Row Values ( row ) ; for ( col = _ NUM ; col < cols ; col ++ ) { output [ row ] [ col ] = - _ NUM ; input [ row + _ NUM ] [ col + _ NUM ] = data [ col ] ; } } image . close ( ) ; update Progress ( _ STR , - _ NUM ) ; int num Cells Total = rows * cols ; int num Solved Cells = _ NUM ;  Priority Queue <  Grid Cell > queue = new  Priority Queue < > ( ( _ NUM * rows + _ NUM * cols ) * _ NUM ) ; old Progress = - _ NUM ; for ( row = _ NUM ; row < rows ; row ++ ) { for ( col = _ NUM ; col < cols ; col ++ ) { z = input [ row + _ NUM ] [ col + _ NUM ] ; if ( z != no Data ) { num Cells ++ ; for ( int i = _ NUM ; i < _ NUM ; i ++ ) { row_n = row +  Dy [ i ] ; col_n = col +  Dx [ i ] ; z_n = input [ row_n + _ NUM ] [ col_n + _ NUM ] ; if ( z_n == no Data ) { gc = new  Grid Cell ( row , col , z ) ; queue . add ( gc ) ; output [ row ] [ col ] = z ; num Cells Total ++ ; break ; } } } else { num Solved Cells ++ ; output [ row ] [ col ] = no Data ; } } progress = ( int ) ( _ NUM * row / rows Less One ) ; if ( progress > old Progress ) { update Progress ( progress ) ; old Progress = progress ; if ( my Host . is Request For Operation Cancel Set ( ) ) { my Host . show Feedback ( _ STR ) ; return ; } } } update Progress ( _ STR , _ NUM ) ; old Progress = ( int ) ( _ NUM * num Solved Cells / num Cells Total ) ; do { gc = queue . poll ( ) ; row = gc . row ; col = gc . col ; z = gc . z ; for ( int i = _ NUM ; i < _ NUM ; i ++ ) { row_n = row +  Dy [ i ] ; col_n = col +  Dx [ i ] ; z_n = input [ row_n + _ NUM ] [ col_n + _ NUM ] ; if ( ( z_n != no Data ) && ( output [ row_n ] [ col_n ] == - _ NUM ) ) { if ( z_n <= z ) { z_n = z +  SMALL_ NUM ; } output [ row_n ] [ col_n ] = z_n ; num Solved Cells ++ ; gc = new  Grid Cell ( row_n , col_n , z_n ) ; queue . add ( gc ) ; } } progress = ( int ) ( _ NUM * num Solved Cells / num Cells Total ) ; if ( ( progress - old Progress ) == _ NUM ) { update Progress ( progress ) ; old Progress = progress ; if ( my Host . is Request For Operation Cancel Set ( ) ) { my Host . show Feedback ( _ STR ) ; return ; } } } while ( queue . is Empty ( ) == _ BOOL ) ; update Progress ( _ STR , _ NUM ) ;  Whitebox Raster output File = new  Whitebox Raster ( output Header , _ STR , input Header ,  Whitebox Raster .  Data Type .  DOUBLE , - _ NUM ) ; output File . set Preferred Palette ( preferred Palette ) ; old Progress = - _ NUM ; for ( row = _ NUM ; row < rows ; row ++ ) { output File . set Row Values ( row , output [ row ] ) ; progress = ( int ) ( _ NUM * row / rows Less One ) ; if ( progress > old Progress ) { update Progress ( progress ) ; old Progress = progress ; if ( my Host . is Request For Operation Cancel Set ( ) ) { my Host . show Feedback ( _ STR ) ; return ; } } } output File . add Metadata Entry ( _ STR + get Descriptive Name ( ) + _ STR ) ; output File . add Metadata Entry ( _ STR + new  Date ( ) ) ; output File . close ( ) ; return Data ( output Header ) ; } catch (  Out Of Memory Error oe ) { my Host . show Feedback ( _ STR ) ; } catch (  Exception e ) { my Host . show Feedback ( _ STR ) ; my Host . log Exception ( _ STR + get Descriptive Name ( ) , e ) ; } finally { update Progress ( _ STR , _ NUM ) ; am IActive = _ BOOL ; my Host . plugin Complete ( ) ; } }
public  String process Filename (  String filename ) { if ( ! filename . starts With ( get Dir ( ) ) ) filename = get Dir ( ) + filename ; return filename ; }
boolean skip Object ( ) throws  IOException { int ch = read ( ) ; int len ; switch ( ch ) { case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : skip ( ch - _ NUM ) ; return _ BOOL ; case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : skip ( ch - _ NUM ) ; return _ BOOL ; case _ NUM : case _ NUM : case _ NUM : case _ NUM : len = _ NUM * ( ch - _ NUM ) + read ( ) ; skip ( len ) ; return _ BOOL ; case _ NUM : case _ NUM : case _ NUM : case _ NUM : len = _ NUM * ( ch - _ NUM ) + read ( ) ; skip ( len ) ; return _ BOOL ; case _ NUM : case _ NUM : case _ NUM : case _ NUM : skip ( _ NUM ) ; return _ BOOL ; case _ NUM : len = read Short ( ) ; skip ( len ) ; return skip Object ( ) ; case _ NUM : len = read Short ( ) ; skip ( len ) ; return _ BOOL ; case _ NUM : scan Object Def ( ) ; return skip Object ( ) ; case _ NUM : skip ( _ NUM ) ; return _ BOOL ; case _ NUM : throw new  Illegal State Exception ( _ STR ) ; case _ NUM : return _ BOOL ; case _ NUM : skip Object ( ) ; skip Object ( ) ; return _ BOOL ; case _ NUM : { skip Map ( ) ; return _ BOOL ; } case _ NUM : skip ( _ NUM ) ; return _ BOOL ; case _ NUM : skip ( _ NUM ) ; return _ BOOL ; case _ NUM : skip ( _ NUM ) ; return _ BOOL ; case _ NUM : skip ( _ NUM ) ; return _ BOOL ; case _ NUM : { skip Object ( ) ; skip Map ( ) ; return _ BOOL ; } case _ NUM : return _ BOOL ; case _ NUM : { int type = scan Int ( ) ;  String [ ] def = _class Defs . get ( type ) ; len = def . length - _ NUM ; for ( int i = _ NUM ; i < len ; i ++ ) { skip Object ( ) ; } return _ BOOL ; } case _ NUM : skip Object ( ) ; skip Object ( ) ; return _ BOOL ; case _ NUM : skip Object ( ) ; return _ BOOL ; case _ NUM : len = read Short ( ) ; skip ( len ) ; return skip Object ( ) ; case _ NUM : len = read Short ( ) ; skip ( len ) ; return _ BOOL ; case _ NUM : return _ BOOL ; case _ NUM : read Type ( ) ; while ( skip Object ( ) ) { } return _ BOOL ; case _ NUM : read Type ( ) ; len = scan Int ( ) ; for ( int i = _ NUM ; i < len ; i ++ ) { skip Object ( ) ; } return _ BOOL ; case _ NUM : while ( skip Object ( ) ) { } return _ BOOL ; case _ NUM : len = scan Int ( ) ; for ( int i = _ NUM ; i < len ; i ++ ) { skip Object ( ) ; } return _ BOOL ; case _ NUM : skip ( _ NUM ) ; return _ BOOL ; case _ NUM : return _ BOOL ; case _ NUM : case _ NUM : return _ BOOL ; case _ NUM : skip ( _ NUM ) ; return _ BOOL ; case _ NUM : skip ( _ NUM ) ; return _ BOOL ; case _ NUM : return skip Object ( ) ; case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : { int type = ch - _ NUM ;  String [ ] def = _class Defs . get ( type ) ; len = def . length - _ NUM ; for ( int i = _ NUM ; i < len ; i ++ ) { skip Object ( ) ; } return _ BOOL ; } case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : skip Object ( ) ; len = ch - _ NUM ; for ( int i = _ NUM ; i < len ; i ++ ) { skip Object ( ) ; } return _ BOOL ; case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : len = ch - _ NUM ; for ( int i = _ NUM ; i < len ; i ++ ) { skip Object ( ) ; } return _ BOOL ; case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : return _ BOOL ; case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : skip ( _ NUM ) ; return _ BOOL ; case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : skip ( _ NUM ) ; return _ BOOL ; case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : return _ BOOL ; case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : skip ( _ NUM ) ; return _ BOOL ; default : throw new  Unsupported Operation Exception ( _ STR +  Integer . to Hex String ( ch ) ) ; } }
protected  Size2 D arrange FN (  Block Container container ,  Graphics2 D g2 ,  Rectangle Constraint constraint ) {  List blocks = container . get Blocks ( ) ; double width = constraint . get Width ( ) ; double x = _ NUM ; double y = _ NUM ; double max Height = _ NUM ;  List items In Row = new  Array List ( ) ; for ( int i = _ NUM ; i < blocks . size ( ) ; i ++ ) {  Block block = (  Block ) blocks . get ( i ) ;  Size2 D size = block . arrange ( g2 ,  Rectangle Constraint .  NONE ) ; if ( x + size . width <= width ) { items In Row . add ( block ) ; block . set Bounds ( new  Rectangle2 D .  Double ( x , y , size . width , size . height ) ) ; x = x + size . width + this . horizontal Gap ; max Height =  Math . max ( max Height , size . height ) ; } else { if ( items In Row . is Empty ( ) ) { block . set Bounds ( new  Rectangle2 D .  Double ( x , y ,  Math . min ( size . width , width - x ) , size . height ) ) ; x = _ NUM ; y = y + size . height + this . vertical Gap ; } else { items In Row . clear ( ) ; x = _ NUM ; y = y + max Height + this . vertical Gap ; max Height = size . height ; block . set Bounds ( new  Rectangle2 D .  Double ( x , y ,  Math . min ( size . width , width ) , size . height ) ) ; x = size . width + this . horizontal Gap ; items In Row . add ( block ) ; } } } return new  Size2 D ( constraint . get Width ( ) , y + max Height ) ; }
public  Object invoke (  Object proxy ,  Method method ,  Object [ ] args ) throws  Throwable { return invoke ( proxy , new  Standard Method ( method ) , args ) ; }
protected static  String remove HTML (  String text Element ) {  String ret Value = text Element . replace All ( _ STR , _ STR ) ; ret Value = ret Value . replace All ( _ STR , _ STR ) ; ret Value = ret Value . replace All ( _ STR , _ STR ) ; return ret Value . to String ( ) ; }
public int index X ( int k ) { int i =  Arrays . binary Search ( this . x Index , k ) ; if ( i >= _ NUM ) { return i ; } else { return - _ NUM * i - _ NUM ; } }
public void send (  String the String ) { send ( the String . get Bytes ( ) ) ; }
public void key Typed (  Key Event evt ) { int modifiers = evt . get Modifiers ( ) ; char c = evt . get Key Char ( ) ; if ( c !=  Key Event .  CHAR_ UNDEFINED && ( modifiers &  Key Event .  ALT_ MASK ) == _ NUM ) { if ( c >= _ NUM && c != _ NUM ) {  Key Stroke key Stroke =  Key Stroke . get Key Stroke (  Character . to Upper Case ( c ) ) ;  Object o = current Bindings . get ( key Stroke ) ; if ( o instanceof  Hashtable ) { current Bindings = (  Hashtable ) o ; return ; } else if ( o instanceof  Action Listener ) { current Bindings = bindings ; execute Action ( (  Action Listener ) o , evt . get Source ( ) ,  String . value Of ( c ) , modifiers ) ; return ; } current Bindings = bindings ; if ( grab Action != null ) { handle Grab Action ( evt ) ; return ; } if ( repeat &&  Character . is Digit ( c ) ) { repeat Count *= _ NUM ; repeat Count += ( c - _ STR ) ; return ; } execute Action (  INSERT_ CHAR , evt . get Source ( ) ,  String . value Of ( evt . get Key Char ( ) ) , modifiers ) ; repeat Count = _ NUM ; repeat = _ BOOL ; } } }
protected final void put Mapped Char ( final int char Int , final  String mapped Char ) { if ( diff Table == null ) { diff Table = new  String [ max Char Count ] ; } if ( char Int > _ NUM && max Char Count == _ NUM ) { } else if ( diff Table [ char Int ] == null && mapped Char != null && ! mapped Char . starts With ( _ STR ) ) { diff Table [ char Int ] = mapped Char ; } }
private void read Object (  Object Input Stream in ) throws  IOException ,  Class Not Found Exception { in . default Read Object ( ) ; if ( policy == null ) { throw new  Invalid Object Exception ( _ STR ) ; } if ( classpath == null ) { throw new  Invalid Object Exception ( _ STR ) ; } if ( log == null ) { throw new  Invalid Object Exception ( _ STR ) ; } if ( server Options == null ) { throw new  Invalid Object Exception ( _ STR ) ; } if ( server Properties == null ) { throw new  Invalid Object Exception ( _ STR ) ; } if ( host == null ) { throw new  Invalid Object Exception ( _ STR ) ; } if ( port <= _ NUM ) { throw new  Invalid Object Exception ( _ STR + port ) ; } }
public static  Script create Multi Sig Input Script Bytes (  List < byte [ ] > signatures , @  Nullable byte [ ] multisig Program Bytes ) { check Argument ( signatures . size ( ) <= _ NUM ) ;  Script Builder builder = new  Script Builder ( ) ; builder . small Num ( _ NUM ) ; for ( byte [ ] signature : signatures ) builder . data ( signature ) ; if ( multisig Program Bytes != null ) builder . data ( multisig Program Bytes ) ; return builder . build ( ) ; }
static boolean compatible Methods (  Class c1 ,  Class c2 ) {  Method [ ] meths = c1 . get Methods ( ) ; for ( int i = meths . length ; -- i >= _ NUM ; ) {  Method m1 = meths [ i ] ; try {  Method m2 = c2 . get Method ( m1 . get Name ( ) , m1 . get Parameter Types ( ) ) ; if ( m2 != null && m1 . get Return Type ( ) != m2 . get Return Type ( ) ) { return _ BOOL ; } } catch (  No Such Method Exception e ) { } } return _ BOOL ; }
public static boolean strictly Between (  Date base Date ,  Date start Date ,  Date end Date ) { if ( start Date . equals ( end Date ) || end Date . before ( start Date ) ) { return _ BOOL ; } if ( start Date . before ( base Date ) && end Date . after ( base Date ) ) { return _ BOOL ; } return _ BOOL ; }
public void add Listener (  Search Listener listener ) { listeners . add ( listener ) ; }
public  String options Tip Text HTML ( ) { return _ STR ; }
@  Override public  Bytes Impl write ( byte [ ] buffer , int offset , int length ) { while ( length > _ NUM ) { int sublen =  Math . min ( _data . length - _head , length ) ;  System . arraycopy ( buffer , offset , _data , _head , sublen ) ; if ( sublen <= _ NUM ) { throw new  Unsupported Operation Exception ( ) ; } length -= sublen ; offset += sublen ; _head += sublen ; } return this ; }
private void write Post Content (  Http URLConnection connection ,  String post Content ) throws  Exception { connection . set Request Method ( _ STR ) ; connection . add Request Property ( _ STR , _ STR ) ; connection . set Do Output ( _ BOOL ) ; connection . set Do Input ( _ BOOL ) ; connection . set Allow User Interaction ( _ BOOL ) ;  Data Output Stream dstream = null ; try { connection . connect ( ) ; dstream = new  Data Output Stream ( connection . get Output Stream ( ) ) ; dstream . write Bytes ( post Content ) ; dstream . flush ( ) ; } finally { if ( dstream != null ) { try { dstream . close ( ) ; } catch (  Exception ex ) { _log . error ( _ STR + _ STR + ex , _ STR ) ; } } } }
public  String to XMLProperty List ( ) {  String Builder xml = new  String Builder ( _ STR ) ; xml . append (  NSObject .  NEWLINE ) ; xml . append ( _ STR ) ; xml . append (  NSObject .  NEWLINE ) ; xml . append ( _ STR ) ; xml . append (  NSObject .  NEWLINE ) ; to XML ( xml , _ NUM ) ; xml . append (  NSObject .  NEWLINE ) ; xml . append ( _ STR ) ; return xml . to String ( ) ; }
public  Intent Share add Extra Provider ( @  Non Null  Extra Provider extra Provider ) { if ( extra Provider == null ) { throw new  Illegal Argument Exception ( _ STR ) ; } else if ( package With Extra Provider . contains ( extra Provider . package Name ) ) { throw new  Illegal Argument Exception ( _ STR + extra Provider . package Name ) ; } extra Providers . add ( extra Provider ) ; return this ; }
public  String split Keywords (  String contents ) { if ( contents == null ) { return  Values .  EMPTYSTRING ; }  String Builder index Contents = new  String Builder ( ) ; contents = contents . replace All ( _ STR , _ STR ) ; if ( contents . length ( ) > this .  MAXSPLITLENGTH ) { contents = contents . substring ( _ NUM ,  MAXSPLITLENGTH ) + _ STR ; } for (  String split Contents : contents . split ( _ STR ) ) { if ( split Contents . length ( ) >= _ NUM ) {  Matcher m =  MULTIPLEUPPERCASE . matcher ( split Contents ) ; if ( ! m . find ( ) ) {  String [ ] split Strings = split Contents . split ( _ STR ) ; if ( split Strings . length > _ NUM ) { index Contents . append ( _ STR ) ; index Contents . append (  String Utils . join ( split Strings , _ STR ) ) ; } } } } return index Contents . to String ( ) ; }
private static  String format SQL (  String sql ) { if ( ! sql . ends With ( _ STR ) ) sql += _ STR ; return sql ; }
public void write Raw Bytes ( final byte [ ] value , int offset , int length ) throws  IOException { if ( buffer . remaining ( ) >= length ) { buffer . put ( value , offset , length ) ; } else { throw new  Out Of Space Exception ( buffer . position ( ) , buffer . limit ( ) ) ; } }
private  Resource Index refresh Resource Index From Data Store (  Service Type resource Type ) throws  Policy Exception {  Resource Index resource Index = get Resource Index From Data Store ( resource Type ) ; resource Indices . put ( resource Type . get Name ( ) , resource Index ) ; return resource Index ; }
private void release Useless Resources ( ) { offline Processor . destroy ( ) ; offline Processor = null ;  IFigure Manager . clean Cache ( ) ;  System . gc ( ) ; }
public void add ( long start , long end ,  Sequence Name Locus region ) { if ( m Size == m Starts . length ) { final int new Len = m Starts . length * _ NUM / _ NUM + _ NUM ; m Starts =  Arrays . copy Of ( m Starts , new Len ) ; m Ends =  Arrays . copy Of ( m Ends , new Len ) ; m Regions =  Arrays . copy Of ( m Regions , new Len ) ; } m Starts [ m Size ] = start ; m Ends [ m Size ] = end ; m Regions [ m Size ] = region ; m Size ++ ; }
protected static boolean is Missing Type Parameters (  Type type ) { if ( type instanceof  Class ) { for (  Class < ? > clazz = (  Class < ? > ) type ; clazz != null ; clazz = clazz . get Enclosing Class ( ) ) { if ( clazz . get Type Parameters ( ) . length != _ NUM ) return _ BOOL ; } return _ BOOL ; } else if ( type instanceof  Parameterized Type ) { return _ BOOL ; } else { throw new  Assertion Error ( _ STR + type . get Class ( ) ) ; } }
public  Key max ( ) { if ( is Empty ( ) ) throw new  No Such Element Exception ( _ STR ) ; return set . last ( ) ; }
public static boolean use MSInterop ( ) {  String prop Value =  Access Controller . do Privileged ( new  Get Property Action ( _ STR , _ STR ) ) ; return ( ! prop Value . equals Ignore Case ( _ STR ) ) ; }
public void close Storage (  Storage Data storage Data ) throws  Business Exception ,  IOException ,  Serialization Exception {  Storage Data local = get Local Storage Data Object ( storage Data ) ; synchronized ( local ) { if ( ( storage Recorder . is Recording On ( ) || storage Recorder . is Recording Scheduled ( ) ) &&  Objects . equals ( local , recorder Storage Data ) ) { throw new  Business Exception ( _ STR + local + _ STR ,  Storage Error Code Enum .  STORAGE_ CAN_ NOT_ BE_ CLOSED ) ; } else if ( is Storage Closed ( local ) ) { throw new  Business Exception ( _ STR + local + _ STR ,  Storage Error Code Enum .  STORAGE_ ALREADY_ CLOSED ) ; }  Storage Writer writer = opened Storages Map . get ( local ) ; if ( writer != null ) { writer . close Storage Writer ( ) ; } opened Storages Map . remove ( local ) ; local . set Disk Size ( get Disk Size For Storage ( local ) ) ; local . mark Closed ( ) ; write Storage Data To Disk ( local ) ; } }
public static  String base Uri Of ( final  Http Servlet Request request ) { final  String Buffer request Url = request . get Request URL ( ) ; return request Url != null ? request Url . substring ( _ NUM , request Url . index Of ( request . get Servlet Path ( ) ) ) : _ STR ; }
private boolean may Skip ASI (  Common Token last Token ,  Observable Xtext Token Stream tokens ) { int count Down From = last Token . get Token Index ( ) ; for ( int i = count Down From - _ NUM ; i >= _ NUM ; i -- ) {  Token prev Token = tokens . get ( i ) ; if ( prev Token . get Channel ( ) ==  Token .  DEFAULT_ CHANNEL ) { if ( mandatory ASI . get ( prev Token . get Type ( ) ) ) { return _ BOOL ; } return _ BOOL ; } } return _ BOOL ; }
protected  JButton make Ok Button ( ) { return make Ok Button ( _ STR ) ; }
Binary Class load File (  Class File file ) throws  IOException { long tm =  System . current Time Millis ( ) ;  Input Stream input = file . get Input Stream ( ) ;  Binary Class c = null ; if ( tracing ) dt Enter ( _ STR + file ) ; try {  Data Input Stream is = new  Data Input Stream ( new  Buffered Input Stream ( input ) ) ; c =  Binary Class . load ( new  Environment ( this , file ) , is , load File Flags ( ) ) ; } catch (  Class Format Error e ) { error ( _ NUM , _ STR , file . get Path ( ) , e . get Message ( ) ) ; if ( tracing ) dt Exit ( _ STR + file ) ; return null ; } catch ( java . io .  EOFException e ) { error ( _ NUM , _ STR , file . get Path ( ) ) ; return null ; } input . close ( ) ; if ( verbose ( ) ) { tm =  System . current Time Millis ( ) - tm ; output (  Main . get Text ( _ STR , file . get Path ( ) ,  Long . to String ( tm ) ) ) ; } if ( tracing ) dt Exit ( _ STR + file ) ; return c ; }
public  VNXe Command Result remove Luns From Lun Group (  String lun Group Id ,  List <  String > luns ) {  Lun Group Modify Param param = new  Lun Group Modify Param ( ) ;  List <  Lun Add Param > lun Removes = new  Array List <  Lun Add Param > ( ) ; for (  String lun Id : luns ) {  VNXe Base lun = new  VNXe Base ( lun Id ) ;  Lun Add Param lun Add = new  Lun Add Param ( ) ; lun Add . set Lun ( lun ) ; lun Removes . add ( lun Add ) ; } param . set Lun Remove ( lun Removes ) ;  Lun Group Requests req = new  Lun Group Requests ( _kh Client ) ; return req . modify Lun Group Sync ( lun Group Id , param ) ; }
@  Override public void connect ( ) throws  IOException {  Client Cache Factory factory = new  Client Cache Factory ( ) ;  Map <  String ,  String > locators = parse Locator String ( geode Locators ) ; if ( locators . size ( ) == _ NUM ) { throw new  Illegal Argument Exception ( _ STR + geode Locators ) ; } else { for (  Entry <  String ,  String > entry : locators . entry Set ( ) ) { factory . add Pool Locator ( entry . get Key ( ) ,  Integer . value Of ( entry . get Value ( ) ) ) ; } } client Cache = factory . create ( ) ; }
boolean is Any State (  Element element ,  State ... states ) {  String ordinal Str = element . get Attribute (  ATTR_ STATE ) ; if ( ordinal Str == null ) { return _ BOOL ; } int ordinal = - _ NUM ; try { ordinal =  Integer . parse Int ( ordinal Str ) ; } catch (  Number Format Exception e ) { return _ BOOL ; } for (  State state : states ) { if ( ordinal == state . ordinal ( ) ) { return _ BOOL ; } } return _ BOOL ; }
private void update Chart ( ) { main Panel . remove All ( ) ;  Grid Bag Constraints constraints = new  Grid Bag Constraints ( ) ; constraints . fill =  Grid Bag Constraints .  BOTH ; constraints . gridx = _ NUM ; constraints . gridy = _ NUM ; constraints . gridwidth = _ NUM ; constraints . weightx = _ NUM ; constraints . weighty = _ NUM ; constraints . anchor =  Grid Bag Constraints .  CENTER ;  JPanel chart Panel = create Chart Panel ( ) ; chart Panel . set Opaque ( _ BOOL ) ; chart Panel . set Background (  Color And Font Constants .  BACKGROUND_ COLOR ) ; chart Panel . set Foreground (  Color And Font Constants .  TEXT_ COLOR ) ; main Panel . add ( chart Panel , constraints ) ; }
public static final boolean is Oracle JCEProvider (  String provider Name ) { return provider Name != null && ( provider Name . equals ( _ STR ) || provider Name . equals ( _ STR ) || provider Name . equals ( _ STR ) || provider Name . starts With ( _ STR ) ) ; }
public static  Http URLConnection to Http Connection (  Request Batch requests ) { for (  Request request : requests ) { request . validate ( ) ; }  URL url = null ; try { if ( requests . size ( ) == _ NUM ) {  Request request = requests . get ( _ NUM ) ; url = new  URL ( request . get Url For Single Request ( ) ) ; } else { url = new  URL (  Server Protocol . get Graph Url Base ( ) ) ; } } catch (  Malformed URLException e ) { throw new  Facebook Exception ( _ STR , e ) ; }  Http URLConnection connection ; try { connection = create Connection ( url ) ; serialize To Url Connection ( requests , connection ) ; } catch (  IOException e ) { throw new  Facebook Exception ( _ STR , e ) ; } catch (  JSONException e ) { throw new  Facebook Exception ( _ STR , e ) ; } return connection ; }
public void print Map (  Hash Map <  String ,  Hash Map <  String ,  Hash Set <  Integer > > > map ) { map . for Each ( null ) ; }
public  Builder (  String host , int port ) { this . host = host ; this . port =  Integer . to String ( port ) ; }
public void test Bug12753 ( ) throws  Exception { if ( version Meets Minimum ( _ NUM , _ NUM ) ) {  Properties props = new  Properties ( ) ; props . set Property ( _ STR , _ STR ) ;  Connection session Conn = null ; try { session Conn = get Connection With Props ( props ) ;  String sql Mode = get Mysql Variable ( session Conn , _ STR ) ; assert True ( sql Mode . index Of ( _ STR ) != - _ NUM ) ; } finally { if ( session Conn != null ) { session Conn . close ( ) ; session Conn = null ; } } } }
public  Program Rewriter (  Hop Rewrite Rule rewrite ) { _dag Rule Set = new  Array List <  Hop Rewrite Rule > ( ) ; _dag Rule Set . add ( rewrite ) ; _sb Rule Set = new  Array List <  Statement Block Rewrite Rule > ( ) ; }
private  JMenu create Bin Navi Menu ( ) { final  JMenu menu = new  JMenu ( _ STR ) ; menu . set Mnemonic ( _ STR ) ; menu . add (  CAction Proxy . proxy ( new  CAdd Database Action ( m_project Tree ) ) ) ; menu . add Separator ( ) ; menu . add (  CAction Proxy . proxy ( new  CAction Exit ( get Parent ( ) ) ) ) ; return menu ; }
void dump Binary (  Data Output Stream os ) throws  IOException { os . write Int ( type ) ; os . write Int ( phone ) ; os . write Int ( start ) ; os . write Int ( end ) ; os . write Int ( prev ) ; os . write Int ( next ) ; }
public static boolean is Valid Name (  String str ) { if ( str . starts With ( _ STR ) && str . ends With ( _ STR ) ) { return is Java Valid Name ( str . substring ( _ NUM , str . length ( ) - _ NUM ) ) ; } return is Java Valid Name ( str ) && ! keys . contains ( str ) ; }
public void clear Commands ( ) { synchronized ( commands ) { commands . clear ( ) ; } update Images ( ) ; }
public void list Directory (  File directory ) { if ( directory == null ) { if ( m Directory != null ) { directory = m Directory ; } else { directory =  Environment . get External Storage Directory ( ) ; if ( directory == null ) return ; } } if ( ! directory . is Directory ( ) ) {  Log_ OC . w (  TAG , _ STR + directory . to String ( ) ) ; directory = directory . get Parent File ( ) ; } m Adapter . swap Directory ( directory ) ; if ( m Directory == null || ! m Directory . equals ( directory ) ) { } m Directory = directory ; }
public static  Thread consume Process Output Stream (  Process self ,  Appendable output ) {  Thread thread = new  Thread ( new  Text Dumper ( self . get Input Stream ( ) , output ) ) ; thread . start ( ) ; return thread ; }
public  Str Builder delete First (  String str ) { int len = ( str == null ? _ NUM : str . length ( ) ) ; if ( len > _ NUM ) { int index = index Of ( str , _ NUM ) ; if ( index >= _ NUM ) { delete Impl ( index , index + len , len ) ; } } return this ; }
@  Reference ( authors = _ STR , title = _ STR , booktitle = _ STR , url = _ STR ) public static <  V extends  Number Vector > double log Likelihood Alternate (  Relation <  V > relation ,  Clustering < ? extends  Mean Model > clustering ,  Number Vector Distance Function < ? super  V > distance Function ) {  List < ? extends  Cluster < ? extends  Mean Model > > clusters = clustering . get All Clusters ( ) ; final int dim =  Relation Util . dimensionality ( relation ) ; final int m = clusters . size ( ) ; int n = _ NUM ; int [ ] n_i = new int [ m ] ; double [ ] d_i = new double [ m ] ;  Iterator < ? extends  Cluster < ? extends  Mean Model > > it = clusters . iterator ( ) ; for ( int i = _ NUM ; it . has Next ( ) ; ++ i ) {  Cluster < ? extends  Mean Model > cluster = it . next ( ) ; n += n_i [ i ] = cluster . size ( ) ; d_i [ i ] = variance Of Cluster ( cluster , distance Function , relation ) ; } double log Likelihood = _ NUM ; for ( int i = _ NUM ; i < m ; i ++ ) { log Likelihood += n_i [ i ] *  Math . log ( n_i [ i ] / ( double ) n ) - n_i [ i ] * dim * _ NUM *  Math Util .  LOGTWOPI - n_i [ i ] * _ NUM *  Math . log ( d_i [ i ] ) - ( n_i [ i ] - m ) * _ NUM ; } return log Likelihood ; }
public static  Map <  String ,  String [ ] > to Multi Map (  Named List params ) {  Hash Map <  String ,  String [ ] > map = new  Hash Map < > ( ) ; for ( int i = _ NUM ; i < params . size ( ) ; i ++ ) {  String name = params . get Name ( i ) ;  Object val = params . get Val ( i ) ; if ( val instanceof  String [ ] ) {  Multi Map Solr Params . add Param ( name , (  String [ ] ) val , map ) ; } else if ( val instanceof  List ) {  List l = (  List ) val ;  String [ ] s = new  String [ l . size ( ) ] ; for ( int j = _ NUM ; j < l . size ( ) ; j ++ ) { s [ j ] = l . get ( j ) == null ? null :  String . value Of ( l . get ( j ) ) ; }  Multi Map Solr Params . add Param ( name , s , map ) ; } else {  Multi Map Solr Params . add Param ( name , val . to String ( ) , map ) ; } } return map ; }
public boolean has Resources ( ) { return ( disco Data != null ) && ! disco Data . is Empty ( ) ; }
public void trim ( ) { objects . trim To Size ( ) ; }
public boolean contains None ( ) { return prompts . contains (  PROMPT_ NONE ) ; }
private static int select ( int [ ] array , int [ ] index , int left , int right , int k ) { if ( left == right ) { return left ; } else { int middle = partition ( array , index , left , right ) ; if ( ( middle - left + _ NUM ) >= k ) { return select ( array , index , left , middle , k ) ; } else { return select ( array , index , middle + _ NUM , right , k - ( middle - left + _ NUM ) ) ; } } }
public  Image rotate270 Degrees (  Image image , boolean maintain Opacity ) { int [ ] rgb = image . get RGB ( ) ; int [ ] new RGB = new int [ rgb . length ] ; int width = image . get Width ( ) ; int height = image . get Height ( ) ; for ( int y = _ NUM ; y < height ; y ++ ) { for ( int x = _ NUM ; x < width ; x ++ ) { new RGB [ y + x * height ] = rgb [ x + y * width ] ; } } return  Encoded Image . create From RGB ( new RGB , height , width , ! maintain Opacity ) ; }
public static boolean is File Transfer Over Http (  Sip Request request ) {  Cpim Message message = extract Cpim Message ( request ) ; if ( message == null ) { return _ BOOL ; }  String content Type = message . get Content Type ( ) ; return content Type != null && content Type . starts With (  File Transfer Http Info Document .  MIME_ TYPE ) ; }
private void debug Segment (  Write Stream out ,  Segment Service Impl segment Service ,  Segment Extent extent , byte [ ] debug Table Key ) throws  IOException { int length = extent . length ( ) ; try (  In Segment in = segment Service . open Read ( extent ) ) {  Read Stream is = new  Read Stream ( in ) ; is . position ( length -  BLOCK_ SIZE ) ; long seq =  Bits Util . read Long ( is ) ; if ( seq <= _ NUM ) { return ; } byte [ ] table Key = new byte [ _ NUM ] ; is . read All ( table Key , _ NUM , table Key . length ) ;  Table Entry table = segment Service . find Table ( table Key ) ; if ( table == null ) { return ; } if ( debug Table Key != null && !  Arrays . equals ( debug Table Key , table Key ) ) { return ; } out . println ( ) ;  String Builder sb = new  String Builder ( ) ;  Base64 Util . encode ( sb , seq ) ; long time = _id Gen . time ( seq ) ; out . println ( _ STR + extent . get Id ( ) + _ STR + sb + _ STR +  Hex . to Short Hex ( table Key ) + _ STR +  Long . to Hex String ( extent . address ( ) ) + _ STR +  Integer . to Hex String ( length ) + _ STR +  Local Date Time . of Epoch Second ( time / _ NUM , _ NUM ,  Zone Offset .  UTC ) + _ STR ) ; debug Segment Entries ( out , is , extent , table ) ; } }
protected  String handle Time (  Time time ) { return time == null ? null : time . to String ( ) ; }
public static  Map <  String ,  String > convert Object Map To String Map (  Object obj ) { final  Map <  Object ,  Object > map = (  Map <  Object ,  Object > ) obj ; final  Map <  String ,  String > metadata = new  Hash Map < > ( ) ; for (  Map .  Entry <  Object ,  Object > entry : map . entry Set ( ) ) { metadata . put (  String . value Of ( entry . get Key ( ) ) ,  String . value Of ( entry . get Value ( ) ) ) ; } return metadata ; }
private  Array _deserialize Array (  Element el ) throws  Converter Exception {  Array array = new  Array Impl ( ) ;  Node List list = el . get Child Nodes ( ) ; int len = list . get Length ( ) ; for ( int i = _ NUM ; i < len ; i ++ ) {  Node node = list . item ( i ) ; if ( node instanceof  Element ) try { array . append ( _deserialize ( (  Element ) node ) ) ; } catch (  Page Exception e ) { throw to Converter Exception ( e ) ; } } return array ; }
public  Distributed Test CLI (  String [ ] args ) { cli Options = create Options ( ) ; try {  Command Line Parser parser = new  Gnu Parser ( ) ; command Line = parser . parse ( cli Options , args , _ BOOL ) ; if ( has Option ( _ STR ) ) { print Help ( ) ;  System . exit ( _ NUM ) ; } if ( ! has Option ( _ STR ) ) { logger . info ( _ STR ) ;  System . exit ( _ NUM ) ; } } catch (  Exception e ) { e . print Stack Trace ( ) ;  System . exit ( _ NUM ) ; } }
private static byte [ ] concat Bytes ( byte [ ] array1 , byte [ ] array2 ) { byte [ ] c Bytes = new byte [ array1 . length + array2 . length ] ; try {  System . arraycopy ( array1 , _ NUM , c Bytes , _ NUM , array1 . length ) ;  System . arraycopy ( array2 , _ NUM , c Bytes , array1 . length , array2 . length ) ; } catch (  Exception e ) { throw new  Faces Exception ( e ) ; } return c Bytes ; }
protected void create (  String full Id ,  String type ,  String local Id ,  Map <  String ,  Object > obj ,  Connection connection ,  Prepared Statement create Statement , boolean batch Create ) throws  SQLException ,  IOException { logger . debug ( _ STR , full Id ) ;  String rev = _ STR ; obj . put ( _ STR , local Id ) ; obj . put ( _ STR , rev ) ;  Json Value obj Val = new  Json Value ( obj ) ; logger . debug ( _ STR , create Statement , type , local Id , rev ) ; populate Prep Statement Columns ( create Statement , obj Val , token Replacement Prop Pointers ) ; if ( ! batch Create ) { logger . debug ( _ STR , create Statement ) ; int val = create Statement . execute Update ( ) ; logger . debug ( _ STR , full Id , rev ) ; } else { create Statement . add Batch ( ) ; logger . debug ( _ STR , full Id , rev ) ; } }
static long read Millis (  Data Input in ) throws  IOException { int v = in . read Unsigned Byte ( ) ; switch ( v > > _ NUM ) { case _ NUM : default : v = ( v << ( _ NUM - _ NUM ) ) > > ( _ NUM - _ NUM ) ; return v * ( _ NUM * _ NUM ) ; case _ NUM : v = ( v << ( _ NUM - _ NUM ) ) > > ( _ NUM - _ NUM ) ; v |= ( in . read Unsigned Byte ( ) ) << _ NUM ; v |= ( in . read Unsigned Byte ( ) ) << _ NUM ; v |= ( in . read Unsigned Byte ( ) ) ; return v * _ NUM ; case _ NUM : long w = ( ( ( long ) v ) << ( _ NUM - _ NUM ) ) > > ( _ NUM - _ NUM ) ; w |= ( in . read Unsigned Byte ( ) ) << _ NUM ; w |= ( in . read Unsigned Byte ( ) ) << _ NUM ; w |= ( in . read Unsigned Byte ( ) ) << _ NUM ; w |= ( in . read Unsigned Byte ( ) ) ; return w * _ NUM ; case _ NUM : return in . read Long ( ) ; } }
public void clear Results ( ) { if ( m Result List != null ) { m Result List . clear ( ) ; m Adapter . notify Data Set Changed ( ) ; } m Listener . on Search Cleared ( ) ; }
public void remove Item Listener (  Item Listener a Listener ) { listener List . remove (  Item Listener . class , a Listener ) ; }
@  Override public  Enumeration <  Option > list Options ( ) {  Vector <  Option > result = new  Vector <  Option > ( _ NUM ) ; result . add Element ( new  Option ( _ STR + _ STR , _ STR , _ NUM , _ STR ) ) ; result . add Element ( new  Option ( _ STR + _ STR + _ STR , _ STR , _ NUM , _ STR ) ) ; result . add Element ( new  Option ( _ STR + _ STR + _ STR , _ STR , _ NUM , _ STR ) ) ; result . add Element ( new  Option ( _ STR + _ STR , _ STR , _ NUM , _ STR ) ) ; result . add Element ( new  Option ( _ STR + _ STR + _ STR + _ STR + _ STR + _ STR , _ STR , _ NUM , _ STR ) ) ; result . add Element ( new  Option ( _ STR + _ STR , _ STR , _ NUM , _ STR ) ) ; result . add All (  Collections . list ( super . list Options ( ) ) ) ; return result . elements ( ) ; }
public static  Mosaic Levy create Mosaic Levy ( ) { return create Mosaic Levy (  Utils . create Mosaic Id ( _ NUM ) ) ; }
public int next Int ( ) { int ret = counter . get And Increment ( ) ; set Last Int ( ret ) ; return ret ; }
public  Predicate Filter Builder ( final  Predicate predicate ) {  Objects . require Non Null ( predicate ) ; this . predicate = predicate ; }
private static void remove Margin Top Of Content Child (  View m Content Child , int status Bar Height ) { if ( m Content Child == null ) { return ; } if (  TAG_ MARGIN_ ADDED . equals ( m Content Child . get Tag ( ) ) ) {  Frame Layout .  Layout Params lp = (  Frame Layout .  Layout Params ) m Content Child . get Layout Params ( ) ; lp . top Margin -= status Bar Height ; m Content Child . set Layout Params ( lp ) ; m Content Child . set Tag ( null ) ; } }
public static byte [ ] hex String To Byte Array (  String s ) { if ( s == null || s . length ( ) == _ NUM ) { return null ; } int len = s . length ( ) ; if ( len % _ NUM != _ NUM ) { throw new  Illegal Argument Exception ( ) ; } byte [ ] data = new byte [ len / _ NUM ] ; for ( int i = _ NUM ; i < len ; i += _ NUM ) { data [ i / _ NUM ] = ( byte ) ( (  Character . digit ( s . char At ( i ) , _ NUM ) << _ NUM ) +  Character . digit ( s . char At ( i + _ NUM ) , _ NUM ) ) ; } return data ; }
private static  String print Schema (  String Builder sb ,  String schema ,  String last Schema , boolean pure SQL ) { if ( schema != null && ( last Schema == null || ( last Schema != null && last Schema . compare To ( schema ) != _ NUM ) ) ) { if ( pure SQL ) { if ( schema . length ( ) > _ NUM ) println ( sb , _ STR + schema + _ STR ) ; } else println ( sb , _ STR + schema ) ; } return schema ; }
private  String join (  String [ ] s ,  String delimiter ) {  String Buffer buffer = new  String Buffer ( ) ; for ( int i = _ NUM ; i < s . length ; i ++ ) { buffer . append ( _ STR ) ; buffer . append ( s [ i ] ) ; buffer . append ( _ STR ) ; if ( i < s . length - _ NUM ) { buffer . append ( delimiter ) ; } } return buffer . to String ( ) ; }
@  Suppress Warnings ( _ STR )  Full Array (  Class <  L > linear Array Type ,  L real ,  L imag , int [ ] dimensions ) { _dimensions = dimensions ; _number Of Elements =  Array Utils . get Number Of Elements ( _dimensions ) ; _real = linear Array Type . cast ( real ) ; _imag = linear Array Type . cast ( imag ) ; _base Component Type = linear Array Type . get Component Type ( ) ; _linear Array Type = linear Array Type ; _output Array Type = (  Class <  T > )  Array Utils . get Array Class ( _base Component Type , dimensions . length ) ; }
public static  INDArray to Array (  Collection <  Writable > record , int size ) {  Iterator <  Writable > writables = record . iterator ( ) ;  Writable first Writable = writables . next ( ) ; if ( first Writable instanceof  NDArray Writable ) {  NDArray Writable ret = (  NDArray Writable ) first Writable ; return ret . get ( ) ; } else {  INDArray vector =  Nd4j . create ( size ) ; vector . put Scalar ( _ NUM , first Writable . to Double ( ) ) ; int count = _ NUM ; while ( writables . has Next ( ) ) {  Writable w = writables . next ( ) ; vector . put Scalar ( count ++ , w . to Double ( ) ) ; } return vector ; } }
public void update Last Commit Seqno (  Repl DBMSHeader header , long applied Latency ) throws  Replicator Exception { try { if ( low Seqno ==  Long .  MIN_ VALUE ) {  Repl DBMSHeader low Header = last Commit Seqno ( ) ; if ( low Header == null ) low Seqno = - _ NUM ; else low Seqno = low Header . get Seqno ( ) ; if ( logger . is Debug Enabled ( ) ) logger . debug ( _ STR + low Seqno ) ; } if ( header . get Seqno ( ) >= low Seqno ) { if ( logger . is Debug Enabled ( ) ) logger . debug ( _ STR + header . get Seqno ( ) ) ; commit Seqno Update . set Long ( _ NUM , header . get Seqno ( ) ) ; commit Seqno Update . set Short ( _ NUM , header . get Fragno ( ) ) ; commit Seqno Update . set Boolean ( _ NUM , header . get Last Frag ( ) ) ; commit Seqno Update . set String ( _ NUM , header . get Source Id ( ) ) ; commit Seqno Update . set Long ( _ NUM , header . get Epoch Number ( ) ) ; commit Seqno Update . set String ( _ NUM , header . get Event Id ( ) ) ; commit Seqno Update . set Long ( _ NUM ,  Math . max ( applied Latency , _ NUM ) ) ; commit Seqno Update . set Timestamp ( _ NUM , new  Timestamp (  System . current Time Millis ( ) ) ) ; commit Seqno Update . set String ( _ NUM , header . get Shard Id ( ) ) ; commit Seqno Update . set Timestamp ( _ NUM , header . get Extracted Tstamp ( ) ) ; commit Seqno Update . set Int ( _ NUM , task Id ) ; commit Seqno Update . execute Update ( ) ; } else { if ( low Seqno Warning ) { if ( logger . is Debug Enabled ( ) ) logger . debug ( _ STR + header . get Seqno ( ) + _ STR + low Seqno ) ; } else { logger . warn ( _ STR + header . get Seqno ( ) + _ STR + low Seqno ) ; low Seqno Warning = _ BOOL ; } } } catch (  SQLException e ) { throw new  Replicator Exception ( _ STR + e . get Message ( ) , e ) ; } }
public void add Slide ( @  Non Null  Fragment fragment , @  Color Int int color ) { fragments . add ( fragment ) ; add Background Color ( color ) ; pager Adapter . notify Data Set Changed ( ) ; }
public  String process (  Item item ) throws  Process Exception { int count = - _ NUM ; for (  Item p = item . get Item As (  Relation .  SYLLABLE_ STRUCTURE ) ; p != null ; p = p . get Previous ( ) ) { count ++ ; } return  Integer . to String ( rail ( count ) ) ; }
public void add (  String value ) { value List . add ( value ) ; }
@  Override public void write ( byte [ ] buf , int offset , int length , boolean is End ) throws  IOException { while ( offset < length ) {  Temp Buffer tail = _tail ; if ( tail == null || tail . buffer ( ) . length <= tail . length ( ) ) { add Buffer (  Temp Buffer . create ( ) ) ; tail = _tail ; } int tail Length = tail . length ( ) ; byte [ ] tail Buffer = tail . buffer ( ) ; int sublen = tail Buffer . length - tail Length ; if ( length - offset < sublen ) { sublen = length - offset ; }  System . arraycopy ( buf , offset , tail Buffer , tail Length , sublen ) ; offset += sublen ; tail . length ( tail Length + sublen ) ; } }
public static void create Response (  Http Servlet Request request ,  Http Servlet Response response ,  Http Servlet servlet ,  Properties cookie Properties ,  Mobile Doc doc , boolean debug ) throws  IOException { response . set Header ( _ STR , _ STR ) ; response . set Content Type ( _ STR ) ; if ( cookie Properties != null ) {  Cookie cookie = new  Cookie (  Mobile Env .  COOKIE_ INFO , properties Encode ( cookie Properties ) ) ; cookie . set Comment ( _ STR ) ; cookie . set Secure ( _ BOOL ) ; cookie . set Path ( _ STR ) ; if ( cookie Properties . size ( ) == _ NUM ) cookie . set Max Age ( _ NUM ) ; else cookie . set Max Age ( _ NUM ) ; response . add Cookie ( cookie ) ; } if ( debug &&  Mobile Env .  DEBUG ) {  Mobile Env . add Footer ( request , response , servlet , doc . get Body ( ) ) ; }  Print Writer out = response . get Writer ( ) ; doc . output ( out ) ; out . flush ( ) ; if ( out . check Error ( ) ) log . log (  Level .  SEVERE , _ STR ) ; out . close ( ) ; }
public static  Long to Long (  Object o ,  Long default Value ) { if ( o instanceof  Long ) return (  Long ) o ; if ( default Value != null ) return  Long . value Of ( to Long Value ( o , default Value . long Value ( ) ) ) ; long res = to Long Value ( o ,  Long .  MIN_ VALUE ) ; if ( res ==  Long .  MIN_ VALUE ) return default Value ; return  Long . value Of ( res ) ; }
private void update Chart ( ) { main Panel . remove All ( ) ;  Grid Bag Constraints constraints = new  Grid Bag Constraints ( ) ; constraints . fill =  Grid Bag Constraints .  BOTH ; constraints . gridx = _ NUM ; constraints . gridy = _ NUM ; constraints . gridwidth = _ NUM ; constraints . weightx = _ NUM ; constraints . weighty = _ NUM ; constraints . anchor =  Grid Bag Constraints .  CENTER ;  JPanel chart Panel = create Chart Panel ( ) ; chart Panel . set Opaque ( _ BOOL ) ; chart Panel . set Background (  Color And Font Constants .  BACKGROUND_ COLOR ) ; chart Panel . set Foreground (  Color And Font Constants .  TEXT_ COLOR ) ; main Panel . add ( chart Panel , constraints ) ; }
@  Override public void add Bridge Idle Debug Listener (  Not Thread Safe Bridge Idle Debug Listener listener ) { m Bridge Idle Listeners . add ( listener ) ; }
public void update Last Message Received Time ( ) { last Message Received Time =  System . current Time Millis ( ) ; }
public  Date Time Formatter Builder append Literal (  String literal ) {  Objects . require Non Null ( literal , _ STR ) ; if ( literal . length ( ) > _ NUM ) { if ( literal . length ( ) == _ NUM ) { append Internal ( new  Char Literal Printer Parser ( literal . char At ( _ NUM ) ) ) ; } else { append Internal ( new  String Literal Printer Parser ( literal ) ) ; } } return this ; }
void reset ( ) { if ( version != - _ NUM ) { throw new  Runtime Exception ( _ STR ) ; } data . reset ( ) ; }
public  Word Definition (  String s Word ) {  Word = new  String ( s Word . to Lower Case ( ) ) ;  Hash = hash Word ( s Word ) ; }
public  Transfer perform Transfer (  Transfer Manager transfer Manager ) ;
public  Extensions ( ) { }
public void remove All ( ) { if ( nodes != null ) { nodes . clear ( ) ; } }
public static double [ ] [ ]  I (  Instances  D , int  L ) { double  M [ ] [ ] = new double [  L ] [  L ] ; for ( int j = _ NUM ; j <  L ; j ++ ) { for ( int k = j + _ NUM ; k <  L ; k ++ ) {  M [ j ] [ k ] =  I (  D , j , k ) ; } } return  M ; }
@  Override public  Result do Comparison Test ( final  Properties properties ) throws  Exception { final long timeout =  Long . parse Long ( properties . get Property (  Test Options .  TIMEOUT ) ) ; final int nclients =  Integer . parse Int ( properties . get Property (  Test Options .  NCLIENTS ) ) ; final int ntrials =  Integer . parse Int ( properties . get Property (  Test Options .  NTRIALS ) ) ; final int key Len =  Integer . parse Int ( properties . get Property (  Test Options .  KEYLEN ) ) ; final int nops =  Integer . parse Int ( properties . get Property (  Test Options .  NOPS ) ) ; final double abort Rate =  Double . parse Double ( properties . get Property (  Test Options .  ABORT_ RATE ) ) ; final  Result result = do Concurrent Client Test ( journal , timeout , nclients , ntrials , key Len , nops , abort Rate ) ; return result ; }
static  String value To String (  Object value ) { if ( value == null || value . equals ( null ) ) { return _ STR ; } if ( value instanceof  String ) { return (  String ) value ; } if ( value instanceof  Float || value instanceof  Double || value instanceof  Byte || value instanceof  Short || value instanceof  Integer || value instanceof  Long ) { return number To String ( value ) ; } if ( value instanceof  Boolean || value instanceof  Map || value instanceof  List ) { return value . to String ( ) ; } return quote ( value . to String ( ) ) ; }
public boolean is Annotation Present (  Class < ? extends  Annotation > annotation Type ) { return get Annotation ( annotation Type ) != null ; }
public void test Process Msg2 ( ) { byte [ ] pdu = create PDU ( _ NUM ) ; int header Len = pdu . length - ( m Gsm Header . length + m User Data Header . length + m Message Body . length ) ; int pdu Type = _ NUM ; int tran Id = _ NUM ;  String original Package Name = m Package Name ;  String original Class Name = m Class Name ; try { m Class Name = _ STR ;  IWap Push Manager iwapman = get Interface ( ) ; iwapman . add Package (  Integer . to String ( m App Id Value ) ,  Integer . to String ( m Content Type Value ) , m Package Name , m Class Name ,  Wap Push Manager Params .  APP_ TYPE_ SERVICE , _ BOOL , _ BOOL ) ; assert True ( ( iwapman . process Message (  Integer . to String ( m App Id Value ) ,  Integer . to String ( m Content Type Value ) , create Intent ( pdu Type , tran Id ) ) &  Wap Push Manager Params .  MESSAGE_ HANDLED ) ==  Wap Push Manager Params .  MESSAGE_ HANDLED ) ; iwapman . delete Package (  Integer . to String ( m App Id Value ) ,  Integer . to String ( m Content Type Value ) , m Package Name , m Class Name ) ; } catch (  Remote Exception e ) { assert True ( _ BOOL ) ; } m Package Name = original Package Name ; m Class Name = original Class Name ; }
public void add Classpath (  List <  File > classpath ) throws  IOException {  Validate . not Null ( classpath ) ;  Validate . no Null Elements ( classpath ) ; for (  File classpath Element : classpath ) { if ( classpath Element . is File ( ) ) { add Jar ( classpath Element ) ; } else if ( classpath Element . is Directory ( ) ) { add Directory ( classpath Element ) ; } else { throw new  Illegal State Exception ( ) ; } } }
@  Singleton public static synchronized void load License Maps (  String first Option ) throws  Invalid Config Exception { if ( licenses == null || license Texts == null ) { licenses = new  Tree Map <  String ,  String > ( ) ; licenses . put ( _ STR , ( first Option == null ) ? _ STR : first Option ) ; license Texts = new  Tree Map <  String ,  String > ( ) ;  Properties properties = license Properties ( ) ; for (  Map .  Entry <  Object ,  Object > entry : properties . entry Set ( ) ) {  String key =  String Utils . trim ( (  String ) entry . get Key ( ) ) ;  String value =  String Utils . trim ( (  String ) entry . get Value ( ) ) ; if ( key != null && key . starts With (  LICENSE_ NAME_ PROPERTY_ PREFIX ) && value != null ) {  String key Minus Prefix =  String Utils . trim To Null ( key . replace (  LICENSE_ NAME_ PROPERTY_ PREFIX , _ STR ) ) ; if ( key Minus Prefix != null ) {  String license Text =  String Utils . trim To Null ( ( properties . get Property (  LICENSE_ TEXT_ PROPERTY_ PREFIX + key Minus Prefix ) ) ) ; if ( license Text != null ) { licenses . put ( key Minus Prefix , value ) ; license Texts . put ( key Minus Prefix , license Text ) ; } } else {  String error =  LICENSES_ PROPFILE_ PATH + _ STR ;  LOG . error ( error ) ; throw new  Invalid Config Exception (  Invalid Config Exception .  TYPE .  INVALID_ PROPERTIES_ FILE , error ) ; } } } if ( ( licenses . size ( ) - _ NUM ) == _ NUM ) {  String error = _ STR +  LICENSES_ PROPFILE_ PATH + _ STR ;  LOG . error ( error ) ; throw new  Invalid Config Exception (  Invalid Config Exception .  TYPE .  INVALID_ PROPERTIES_ FILE , error ) ; } } }
private  Array List <  Individuum > initial Population ( int popsize ) {  Array List <  Individuum > population = new  Array List < > ( popsize ) ; for ( int i = _ NUM ; i < popsize ; i ++ ) { short [ ] gene = new short [ dim ] ;  Arrays . fill ( gene ,  DONT_ CARE ) ; int count Dim = k ; while ( count Dim > _ NUM ) { int z = random . next Int ( dim ) ; if ( gene [ z ] !=  DONT_ CARE ) { continue ; } gene [ z ] = ( short ) ( random . next Int ( phi ) +  GENE_ OFFSET ) ; count Dim -- ; } population . add ( make Individuum ( gene ) ) ; } return population ; }
public  List <  Class < ? > > find Available Classes (  String uri ) throws  IOException { _resources Not Loaded . clear ( ) ;  List <  Class < ? > > classes = new  Array List < > ( ) ;  List <  String > strings = find Available Strings ( uri ) ; for (  String class Name : strings ) { try {  Class < ? > clazz = _class Loader . load Class ( class Name ) ; classes . add ( clazz ) ; } catch (  Exception not Available ) { _resources Not Loaded . add ( class Name ) ; } } return classes ; }
public boolean matches (  Inventory Crafting inv ,  World world In ) {  Item Stack itemstack = null ;  List <  Item Stack > list =  Lists . <  Item Stack > new Array List ( ) ; for ( int i = _ NUM ; i < inv . get Size Inventory ( ) ; ++ i ) {  Item Stack itemstack1 = inv . get Stack In Slot ( i ) ; if ( itemstack1 != null ) { if ( itemstack1 . get Item ( ) instanceof  Item Armor ) {  Item Armor itemarmor = (  Item Armor ) itemstack1 . get Item ( ) ; if ( itemarmor . get Armor Material ( ) !=  Cyberware Content . trench Mat || itemstack != null ) { return _ BOOL ; } itemstack = itemstack1 ; } else { if ( itemstack1 . get Item ( ) !=  Items .  DYE ) { return _ BOOL ; } list . add ( itemstack1 ) ; } } } return itemstack != null && ! list . is Empty ( ) ; }
@  Override public  String format ( double value , int format Number ) { return format . format ( value ) ; }
public int load Data ( int size ) {  List <  String > list = new  Array List < > ( ) ; for ( int i = _ NUM ; i < size ; i ++ ) list . add ( _ STR + size ) ; return list . size ( ) ; }
public void add Transform (  Data Transform transform ) { transform Source . add ( transform ) ; }
public  ORCondition (  Condition ... conditions ) {  Reject . if Null ( conditions ) ; this . conditions =  Arrays . as List ( conditions ) ; }
@  Override public void on Create (  Bundle saved Instance State ) { super . on Create ( saved Instance State ) ; m Handler = new  Handler ( ) ; set Content View (  R . layout . voice_recognition ) ;  Button speak Button = (  Button ) find View By Id (  R . id . btn_speak ) ; m List = (  List View ) find View By Id (  R . id . list ) ; m Supported Language View = (  Spinner ) find View By Id (  R . id . supported_languages ) ;  Package Manager pm = get Package Manager ( ) ;  List <  Resolve Info > activities = pm . query Intent Activities ( new  Intent (  Recognizer Intent .  ACTION_ RECOGNIZE_ SPEECH ) , _ NUM ) ; if ( activities . size ( ) != _ NUM ) { speak Button . set On Click Listener ( this ) ; } else { speak Button . set Enabled ( _ BOOL ) ; speak Button . set Text ( _ STR ) ; } refresh Voice Settings ( ) ; }
public static void safe Close Stream (  Output Stream out ) { if ( out != null ) { try { out . close ( ) ; } catch (  Exception e ) { log . error ( e . get Message ( ) , e ) ; } } }
public int value ( ) { return get Element ( _ NUM ) & _ NUM ; }
public void test_tuple Count1_empty Key_deleted ( ) { final int m = _ NUM ; final int nkeys = _ NUM ; final byte [ ] [ ] keys = new byte [ m + _ NUM ] [ ] ; final byte [ ] [ ] vals = new byte [ m + _ NUM ] [ ] ; final boolean [ ] delete Markers = new boolean [ m + _ NUM ] ; final long [ ] version Timestamps = new long [ m + _ NUM ] ; keys [ _ NUM ] = new byte [ _ NUM ] ; delete Markers [ _ NUM ] = _ BOOL ; version Timestamps [ _ NUM ] =  System . current Time Millis ( ) ; final  ILeaf Data expected = mock Leaf Factory ( new  Read Only Keys Raba ( nkeys , keys ) , new  Read Only Values Raba ( nkeys , vals ) , delete Markers , version Timestamps , null ) ; assert True ( expected . get Delete Marker ( _ NUM ) ) ; assert Equals ( version Timestamps [ _ NUM ] , expected . get Version Timestamp ( _ NUM ) ) ; assert Equals ( version Timestamps [ _ NUM ] , expected . get Minimum Version Timestamp ( ) ) ; assert Equals ( version Timestamps [ _ NUM ] , expected . get Maximum Version Timestamp ( ) ) ; do Round Trip Test ( expected , coder , new  Data Output Buffer ( ) ) ; }
public static boolean valid System Name Config (  String system Name , char type ) { if ( ! valid System Name Format ( system Name , type ) ) { log . warn ( system Name + _ STR ) ; return _ BOOL ; }  Serial Node node = get Node From System Name ( system Name ) ; if ( node == null ) { log . warn ( system Name + _ STR ) ; return _ BOOL ; } int bit = get Bit From System Name ( system Name ) ; if ( ( type == _ STR ) || ( type == _ STR ) ) { if ( ( bit <= _ NUM ) || ( bit >  Serial Node . output Bits [ node . node Type ] ) ) { log . warn ( system Name + _ STR ) ; return _ BOOL ; } } else if ( type == _ STR ) { if ( ( bit <= _ NUM ) || ( bit >  Serial Node . input Bits [ node . node Type ] ) ) { log . warn ( system Name + _ STR ) ; return _ BOOL ; } } else { log . error ( _ STR ) ; return _ BOOL ; } return _ BOOL ; }
public void write Field (  String name , int value ) throws java . io .  IOException { write Field ( name ,  Integer . to String ( value ) ) ; }
public static double ln Factorial ( double x ) { return  Statistics . ln Gamma ( x + _ NUM ) ; }
public void sync ( long amount ,  Time Unit unit ) throws  IOException { try { latch . await ( amount , unit ) ; } catch (  Interrupted Exception e ) {  Thread . interrupted ( ) ; throw  IOException Support . create ( e ) ; } fail On Error ( ) ; }
public static void close Quietly (  Closeable closeable ) { if ( closeable != null ) { try { closeable . close ( ) ; } catch (  Runtime Exception rethrown ) { throw rethrown ; } catch (  Exception ignored ) { } } }
public void write To Disk ( ) { synchronized ( m_mutex ) { try (  File Output Stream fout = new  File Output Stream ( m_file , _ BOOL ) ;  Object Output Stream out = new  Object Output Stream ( fout ) ) { out . write Object ( m_map ) ; } catch ( final  IOException e ) { } } }
public static <  T extends  Identifiable Object >  List <  T > remove Duplicates (  List <  T > list ) { final  List <  T > temp = new  Array List < > ( list ) ; list . clear ( ) ; for (  T object : temp ) { if ( ! list . contains ( object ) ) { list . add ( object ) ; } } return list ; }
public static  Inet Address int To Inet Address ( int host Address ) { byte [ ] address Bytes = { ( byte ) ( _ NUM & host Address ) , ( byte ) ( _ NUM & ( host Address > > _ NUM ) ) , ( byte ) ( _ NUM & ( host Address > > _ NUM ) ) , ( byte ) ( _ NUM & ( host Address > > _ NUM ) ) } ; try { return  Inet Address . get By Address ( address Bytes ) ; } catch (  Unknown Host Exception e ) { throw new  Assertion Error ( ) ; } }
private  AFTPClient action Remove ( ) throws  IOException ,  Page Exception { required ( _ STR , item ) ;  AFTPClient client = get Client ( ) ; client . delete File ( item ) ; write Cfftp ( client ) ; return client ; }
public void test Plus Math Context Negative ( ) {  String a = _ STR ; int a Scale = _ NUM ; int precision = _ NUM ;  Rounding Mode rm =  Rounding Mode .  CEILING ;  Math Context mc = new  Math Context ( precision , rm ) ;  String c = _ STR ; int c Scale = _ NUM ;  Big Decimal a Number = new  Big Decimal ( new  Big Integer ( a ) , a Scale ) ;  Big Decimal res = a Number . plus ( mc ) ; assert Equals ( _ STR , c , res . to String ( ) ) ; assert Equals ( _ STR , c Scale , res . scale ( ) ) ; }
@  Override public  V put If Absent ( final  K k , final  V v ) { try { final  Weak Reference <  V > ref = new Weak Ref ( k , v , reference Queue ) ; final  Weak Reference <  V > old Ref = map . put If Absent ( k , ref ) ; final  V old Val = old Ref == null ? null : old Ref . get ( ) ; if ( old Ref != null && old Val == null ) { if ( map . replace ( k , old Ref , ref ) ) { if ( queue != null ) { synchronized ( queue ) { if ( queue . add ( v ) &&  DEBUG ) { log . debug ( _ STR + k + _ STR + v ) ; } } } did Update ( k , ref , old Ref ) ; return null ; } else { return put If Absent ( k , v ) ; } } if ( old Val == null ) { if ( queue != null ) { synchronized ( queue ) { if ( queue . add ( v ) &&  DEBUG ) { log . debug ( _ STR + k + _ STR + v ) ; } } } did Update ( k , ref , null ) ; return null ; } return old Val ; } finally { remove Cleared Entries ( ) ; } }
public void purge And Notify Removed Layers ( ) {  Array List <  Layer > r Layers = new  Array List <  Layer > ( removed Layers ) ; removed Layers . clear ( ) ; if ( r Layers . is Empty ( ) ) { return ; } for (  Layer layer : r Layers ) { layer . removed ( this ) ; } if (  Debug . debugging ( _ STR ) ) {  System . gc ( ) ; } }
private void start Monitor Thread ( ) { monitor Thread = new  Thread ( new  Queue Monitor ( resource Manager ) ) ; monitor Thread . start ( ) ;  LOG . debug ( _ STR ) ; }
public  String upload Video (  Context context ,  Uri video Uri ) {  String file Path =  Video Media Store Utils . get Path ( context , video Uri ) ;  Video android Video =  Video Media Store Utils . get Video ( context , file Path ) ; if ( android Video != null ) {  File video File = new  File ( file Path ) ; if ( video File . length ( ) <  Constants .  MAX_ SIZE_ MEGA_ BYTE ) { try {  Video received Video = m Video Service Proxy . add Video ( android Video ) ; if ( received Video != null ) {  Video Status status = m Video Service Proxy . set Video Data ( received Video . get Id ( ) , new  Typed File ( _ STR , video File ) ) ; if ( status . get State ( ) ==  Video State .  READY ) { return  STATUS_ UPLOAD_ SUCCESSFUL ; } } } catch (  Exception e ) { return  STATUS_ UPLOAD_ ERROR ; } } else return  STATUS_ UPLOAD_ ERROR_ FILE_ TOO_ LARGE ; } return  STATUS_ UPLOAD_ ERROR ; }
public void draw Image ( int x , int y , int width , int height ,  Bitmap pic ) {  CBitmap bitmap = new  CBitmap ( pic , x , y ) ; bitmap . set Width ( width ) ; bitmap . set Height ( height ) ; m Drawable List . add ( bitmap ) ; invalidate ( ) ; }
private void read Object (  Object Input Stream s ) throws  IOException ,  Class Not Found Exception { s . default Read Object ( ) ; try { init ( ) ; } catch (  Runtime Exception e ) { if ( e instanceof  Null Pointer Exception || e instanceof  Illegal Argument Exception ) {  Invalid Object Exception ee = new  Invalid Object Exception ( e . get Message ( ) ) ; ee . init Cause ( e ) ; throw ee ; } throw e ; } }
public static  Name any Camel (  String ... pieces ) {  List <  Name Piece > name Pieces = new  Array List < > ( ) ; for (  String piece : pieces ) { validate Camel ( piece ,  Check Case .  NO_ CHECK ) ;  Case Format format =  Case Format .  LOWER_ CAMEL ; if (  Character . is Upper Case ( piece . char At ( _ NUM ) ) ) { format =  Case Format .  UPPER_ CAMEL ; } name Pieces . add ( new  Name Piece ( piece , format ) ) ; } return new  Name ( name Pieces ) ; }
public static boolean is Volume Full Copy (  Volume volume ,  Db Client db Client ) { boolean is Full Copy = _ BOOL ;  URI fc Source Obj URI = volume . get Associated Source Volume ( ) ; if ( !  Null Column Value Getter . is Null URI ( fc Source Obj URI ) ) {  Block Object fc Source Obj =  Block Object . fetch ( db Client , fc Source Obj URI ) ; if ( ( fc Source Obj != null ) && ( ! fc Source Obj . get Inactive ( ) ) ) { is Full Copy = _ BOOL ; } } return is Full Copy ; }
public  Movie Set Remove Action ( boolean with Title ) { if ( with Title ) { put Value (  NAME ,  BUNDLE . get String ( _ STR ) ) ; } put Value (  LARGE_ ICON_ KEY ,  Icon Manager .  LIST_ REMOVE ) ; put Value (  SMALL_ ICON ,  Icon Manager .  LIST_ REMOVE ) ; put Value (  SHORT_ DESCRIPTION ,  BUNDLE . get String ( _ STR ) ) ; }
public static  Process Registry locate Registry ( int port ) throws  Registry Exception { try {  Registry registry =  Locate Registry . get Registry ( port ) ;  Process Registry process Registry = new  Process Registry ( port , registry ) ; return process Registry ; } catch (  Remote Exception e ) { throw new  Registry Exception ( _ STR + port + _ STR , e ) ; } }
public void poll ( final  Snmp Udp Statistics Handler snmp Udp Statistics Handler ) { this . statistics Handler = snmp Udp Statistics Handler ; try { file Loader . load ( ) ; final  Byte Buffer buffer = file Loader . get Buffer ( ) ; line Parser . reset ( ) ; line Parser . handle Token ( buffer , buffer . position ( ) , buffer . limit ( ) ) ; } finally { this . statistics Handler = null ; } }
public static  String remove Duplicate Whitespace (  String s ) {  String Builder result = new  String Builder ( ) ; int length = s . length ( ) ; boolean is Previous White Space = _ BOOL ; for ( int i = _ NUM ; i < length ; i ++ ) { char c = s . char At ( i ) ; boolean this Char White Space =  Character . is Whitespace ( c ) ; if ( ! ( is Previous White Space && this Char White Space ) ) { result . append ( c ) ; } is Previous White Space = this Char White Space ; } return result . to String ( ) ; }
public void handle Tbl Request Handler List Button Add Request (  Request Invocation Event event ) throws  Model Control Exception { try {  Map values = get Values ( ) ; on Before Save Profile ( values ) ; set Page Session Attribute (  PROPERTY_ ATTRIBUTE , (  Hash Map ) values ) ;  SCSOAPBinding Request Handler List Add View Bean vb = (  SCSOAPBinding Request Handler List Add View Bean ) get View Bean (  SCSOAPBinding Request Handler List Add View Bean . class ) ; unlock Page Trail ( ) ; pass Pg Session Map ( vb ) ; vb . forward To ( get Request Context ( ) ) ; } catch (  AMConsole Exception e ) { set Inline Alert Message (  CCAlert .  TYPE_ ERROR , _ STR , e . get Message ( ) ) ; } }
public boolean is Open ( ) { if ( secure Channel Id == - _ NUM ) return _ BOOL ; long expire Time = ( ( long ) ( token Lifetime * _ NUM ) ) + token Issue Time ; long current Time =  System . current Time Millis ( ) ; return expire Time > current Time ; }
@  Override protected  Object create Output Tuple ( ) { try { return output Class . new Instance ( ) ; } catch (  Instantiation Exception e ) { throw new  Runtime Exception ( e ) ; } catch (  Illegal Access Exception e ) { throw new  Runtime Exception ( e ) ; } }
public  Object return Instance ( final  String instance Key , final  Map <  String ,  Object > key Map ) {  Object instance = null ; if ( key Map . contains Key ( instance Key ) ) { instance = key Map . get ( instance Key ) ; } else { _logger . error ( _ STR , instance Key ) ; } return instance ; }
public final double do Operation ( ) throws  Operator Failed Exception { final int dim = indicator Parameter . get Dimension ( ) ; double sum = _ NUM ; for ( int i = _ NUM ; i < dim ; i ++ ) { sum += indicator Parameter . get Parameter Value ( i ) ; } final int pos =  Math Utils . next Int ( dim ) ; final int value = ( int ) indicator Parameter . get Parameter Value ( pos ) ; double rand = _ NUM ; if ( rate Parameter != null ) rand =  Math Utils . next Double ( ) ; double logq ; if ( value == _ NUM ) { indicator Parameter . set Parameter Value ( pos , _ NUM ) ; logq = -  Math . log ( ( dim - sum ) / ( sum + _ NUM ) ) ; } else if ( value == _ NUM ) { indicator Parameter . set Parameter Value ( pos , _ NUM ) ; logq = -  Math . log ( sum / ( dim - sum + _ NUM ) ) ; rand *= - _ NUM ; } else { throw new  Runtime Exception ( _ STR ) ; } if ( rate Parameter != null ) { final double scale =  Math . exp ( ( rand ) * scale Factor ) ; logq +=  Math . log ( scale ) ; final double old Value = rate Parameter . get Parameter Value ( _ NUM ) ; final double new Value = scale * old Value ; rate Parameter . set Parameter Value ( _ NUM , new Value ) ; } return logq ; }
public static void update Web Progress ( ) { web Progress Bar . set Progress ( ( ( float ) public Web Render . current Progress ) / _ NUM ) ; }
public  Day ( ) { this ( new  Date ( ) ) ; }
public long convert Transverse Mercator To Geodetic ( double  Easting , double  Northing ) { double c ; double de ; double dlam ; double eta ; double eta2 ; double eta3 ; double eta4 ; double ftphi ; int i ; double s ; double sn ; double sr ; double t ; double tan2 ; double tan4 ; double t10 ; double t11 ; double t12 ; double t13 ; double t14 ; double t15 ; double t16 ; double t17 ; double tmd ; double tmdo ; long  Error_ Code =  TRANMERC_ NO_ ERROR ; if ( (  Easting < (  Tran Merc_ False_ Easting -  Tran Merc_ Delta_ Easting ) ) || (  Easting > (  Tran Merc_ False_ Easting +  Tran Merc_ Delta_ Easting ) ) ) {  Error_ Code |=  TRANMERC_ EASTING_ ERROR ; } if ( (  Northing < (  Tran Merc_ False_ Northing -  Tran Merc_ Delta_ Northing ) ) || (  Northing > (  Tran Merc_ False_ Northing +  Tran Merc_ Delta_ Northing ) ) ) {  Error_ Code |=  TRANMERC_ NORTHING_ ERROR ; } if (  Error_ Code ==  TRANMERC_ NO_ ERROR ) { tmdo =  Tran Merc_ap *  Tran Merc_ Origin_ Lat -  Tran Merc_bp *  Math . sin ( _ NUM *  Tran Merc_ Origin_ Lat ) +  Tran Merc_cp *  Math . sin ( _ NUM *  Tran Merc_ Origin_ Lat ) -  Tran Merc_dp *  Math . sin ( _ NUM *  Tran Merc_ Origin_ Lat ) +  Tran Merc_ep *  Math . sin ( _ NUM *  Tran Merc_ Origin_ Lat ) ; tmd = tmdo + (  Northing -  Tran Merc_ False_ Northing ) /  Tran Merc_ Scale_ Factor ; sr =  Tran Merc_a * ( _ NUM -  Tran Merc_es ) /  Math . pow (  Math . sqrt ( _ NUM -  Tran Merc_es *  Math . pow (  Math . sin ( _ NUM ) , _ NUM ) ) , _ NUM ) ; ftphi = tmd / sr ; for ( i = _ NUM ; i < _ NUM ; i ++ ) { t10 =  Tran Merc_ap * ftphi -  Tran Merc_bp *  Math . sin ( _ NUM * ftphi ) +  Tran Merc_cp *  Math . sin ( _ NUM * ftphi ) -  Tran Merc_dp *  Math . sin ( _ NUM * ftphi ) +  Tran Merc_ep *  Math . sin ( _ NUM * ftphi ) ; sr =  Tran Merc_a * ( _ NUM -  Tran Merc_es ) /  Math . pow (  Math . sqrt ( _ NUM -  Tran Merc_es *  Math . pow (  Math . sin ( ftphi ) , _ NUM ) ) , _ NUM ) ; ftphi = ftphi + ( tmd - t10 ) / sr ; } sr =  Tran Merc_a * ( _ NUM -  Tran Merc_es ) /  Math . pow (  Math . sqrt ( _ NUM -  Tran Merc_es *  Math . pow (  Math . sin ( ftphi ) , _ NUM ) ) , _ NUM ) ; sn =  Tran Merc_a /  Math . sqrt ( _ NUM -  Tran Merc_es *  Math . pow (  Math . sin ( ftphi ) , _ NUM ) ) ; s =  Math . sin ( ftphi ) ; c =  Math . cos ( ftphi ) ; t =  Math . tan ( ftphi ) ; tan2 = t * t ; tan4 = tan2 * tan2 ; eta =  Tran Merc_ebs *  Math . pow ( c , _ NUM ) ; eta2 = eta * eta ; eta3 = eta2 * eta ; eta4 = eta3 * eta ; de =  Easting -  Tran Merc_ False_ Easting ; if (  Math . abs ( de ) < _ NUM ) de = _ NUM ; t10 = t / ( _ NUM * sr * sn *  Math . pow (  Tran Merc_ Scale_ Factor , _ NUM ) ) ; t11 = t * ( _ NUM + _ NUM * tan2 + eta - _ NUM *  Math . pow ( eta , _ NUM ) - _ NUM * tan2 * eta ) / ( _ NUM * sr *  Math . pow ( sn , _ NUM ) *  Math . pow (  Tran Merc_ Scale_ Factor , _ NUM ) ) ; t12 = t * ( _ NUM + _ NUM * tan2 + _ NUM * eta + _ NUM * tan4 - _ NUM * tan2 * eta - _ NUM * eta2 + _ NUM * eta3 - _ NUM * tan2 * eta2 - _ NUM * tan4 * eta + _ NUM * eta4 + _ NUM * tan4 * eta2 + _ NUM * tan2 * eta3 - _ NUM * tan2 * eta4 ) / ( _ NUM * sr *  Math . pow ( sn , _ NUM ) *  Math . pow (  Tran Merc_ Scale_ Factor , _ NUM ) ) ; t13 = t * ( _ NUM + _ NUM * tan2 + _ NUM * tan4 + _ NUM *  Math . pow ( t , _ NUM ) ) / ( _ NUM * sr *  Math . pow ( sn , _ NUM ) *  Math . pow (  Tran Merc_ Scale_ Factor , _ NUM ) ) ;  Latitude = ftphi -  Math . pow ( de , _ NUM ) * t10 +  Math . pow ( de , _ NUM ) * t11 -  Math . pow ( de , _ NUM ) * t12 +  Math . pow ( de , _ NUM ) * t13 ; t14 = _ NUM / ( sn * c *  Tran Merc_ Scale_ Factor ) ; t15 = ( _ NUM + _ NUM * tan2 + eta ) / ( _ NUM *  Math . pow ( sn , _ NUM ) * c *  Math . pow (  Tran Merc_ Scale_ Factor , _ NUM ) ) ; t16 = ( _ NUM + _ NUM * eta + _ NUM * tan2 - _ NUM * eta2 + _ NUM * tan2 * eta + _ NUM * tan4 - _ NUM * eta3 + _ NUM * tan2 * eta2 + _ NUM * tan2 * eta3 ) / ( _ NUM *  Math . pow ( sn , _ NUM ) * c *  Math . pow (  Tran Merc_ Scale_ Factor , _ NUM ) ) ; t17 = ( _ NUM + _ NUM * tan2 + _ NUM * tan4 + _ NUM *  Math . pow ( t , _ NUM ) ) / ( _ NUM *  Math . pow ( sn , _ NUM ) * c *  Math . pow (  Tran Merc_ Scale_ Factor , _ NUM ) ) ; dlam = de * t14 -  Math . pow ( de , _ NUM ) * t15 +  Math . pow ( de , _ NUM ) * t16 -  Math . pow ( de , _ NUM ) * t17 ;  Longitude =  Tran Merc_ Origin_ Long + dlam ; if (  Math . abs (  Latitude ) > ( _ NUM *  PI / _ NUM ) )  Error_ Code |=  TRANMERC_ NORTHING_ ERROR ; if ( (  Longitude ) > (  PI ) ) {  Longitude -= ( _ NUM *  PI ) ; if (  Math . abs (  Longitude ) >  PI )  Error_ Code |=  TRANMERC_ EASTING_ ERROR ; } if (  Math . abs ( dlam ) > ( _ NUM *  PI / _ NUM ) *  Math . cos (  Latitude ) ) {  Error_ Code |=  TRANMERC_ LON_ WARNING ; } if (  Latitude > _ NUM )  Error_ Code |=  TRANMERC_ LON_ WARNING ; } return (  Error_ Code ) ; }
private void evict All (  Ignite Cache <  Integer ,  Cache Value > cache ) throws  Exception { reset Counters ( ) ; assert Equals (  ENTRY_ CNT , cache . size ( ) ) ; assert Equals ( _ NUM , cache . local Size (  Cache Peek Mode .  OFFHEAP ) ) ; for ( int i = _ NUM ; i <  ENTRY_ CNT ; i ++ ) { cache . local Evict (  Collections . singleton ( i ) ) ; assert Equals (  ENTRY_ CNT - i - _ NUM , cache . local Size (  Cache Peek Mode .  ONHEAP ) ) ; assert Equals ( i + _ NUM , cache . local Size (  Cache Peek Mode .  OFFHEAP ) ) ; } assert Equals ( _ NUM , cache . local Size (  Cache Peek Mode .  ONHEAP ) ) ; assert Equals (  ENTRY_ CNT , cache . local Size (  Cache Peek Mode .  OFFHEAP ) ) ; for ( int i = _ NUM ; i <  ENTRY_ CNT ; i ++ ) assert Null ( cache . local Peek ( i ,  Cache Peek Mode .  ONHEAP ) ) ; assert Equals (  ENTRY_ CNT , swap Cnt . get ( ) ) ; assert Equals ( _ NUM , unswap Cnt . get ( ) ) ; }
Node <  K ,  V > find ( int h ,  Object k ) {  Node <  K ,  V > e = this ; if ( k != null ) { do {  K ek ; if ( e . hash == h && ( ( ek = e . key ) == k || ( ek != null && k . equals ( ek ) ) ) ) return e ; } while ( ( e = e . next ) != null ) ; } return null ; }
@  Override public void start Element (  String uri ,  String local Name ,  String q Name ,  Attributes attributes ) { if ( element Processor != null ) { element Processor = element Processor . get Child ( uri , local Name , q Name ) ; } else if (  ELEMENT_ NAME_ OSM . equals ( q Name ) ) { element Processor = osm Element Processor ; } else { throw new  Osm Runtime Exception ( _ STR ) ; } element Processor . begin ( attributes ) ; }
public void add Language (  Execution Language language ) { languages . add ( _ NUM , language ) ; }
protected void do Update User (  User user ) throws  Users Repository Exception {  Connection conn = null ;  Prepared Statement update User Statement = null ; try { conn = open Connection ( ) ; update User Statement = conn . prepare Statement ( m_update User Sql ) ; set User For Update Statement ( user , update User Statement ) ; update User Statement . execute ( ) ; } catch (  SQLException sql Exc ) { sql Exc . print Stack Trace ( ) ; throw new  Users Repository Exception ( _ STR , sql Exc ) ; } finally { the JDBCUtil . close JDBCStatement ( update User Statement ) ; the JDBCUtil . close JDBCConnection ( conn ) ; } }
public static void spooky4 ( final long [ ] triple , final long seed , final long [ ] tuple ) { long h0 , h1 , h2 , h3 ; h0 = seed ; h1 =  ARBITRARY_ BITS + triple [ _ NUM ] ; h2 =  ARBITRARY_ BITS + triple [ _ NUM ] ; h3 =  ARBITRARY_ BITS + triple [ _ NUM ] ; h2 =  Long . rotate Left ( h2 , _ NUM ) ; h2 += h3 ; h0 ^= h2 ; h3 =  Long . rotate Left ( h3 , _ NUM ) ; h3 += h0 ; h1 ^= h3 ; h0 =  Long . rotate Left ( h0 , _ NUM ) ; h0 += h1 ; h2 ^= h0 ; h1 =  Long . rotate Left ( h1 , _ NUM ) ; h1 += h2 ; h3 ^= h1 ; h2 =  Long . rotate Left ( h2 , _ NUM ) ; h2 += h3 ; h0 ^= h2 ; h3 =  Long . rotate Left ( h3 , _ NUM ) ; h3 += h0 ; h1 ^= h3 ; h0 =  Long . rotate Left ( h0 , _ NUM ) ; h0 += h1 ; h2 ^= h0 ; h1 =  Long . rotate Left ( h1 , _ NUM ) ; h1 += h2 ; h3 ^= h1 ; h2 =  Long . rotate Left ( h2 , _ NUM ) ; h2 += h3 ; h0 ^= h2 ; h3 =  Long . rotate Left ( h3 , _ NUM ) ; h3 += h0 ; h1 ^= h3 ; h0 =  Long . rotate Left ( h0 , _ NUM ) ; h0 += h1 ; h2 ^= h0 ; h1 =  Long . rotate Left ( h1 , _ NUM ) ; h1 += h2 ; h3 ^= h1 ; switch ( tuple . length ) { case _ NUM : tuple [ _ NUM ] = h3 ; case _ NUM : tuple [ _ NUM ] = h2 ; case _ NUM : tuple [ _ NUM ] = h1 ; case _ NUM : tuple [ _ NUM ] = h0 ; } }
public static  Sim Event find First Deferred ( int src ,  Predicate p ) {  Sim Event ev = null ;  Iterator <  Sim Event > iterator = deferred . iterator ( ) ; while ( iterator . has Next ( ) ) { ev = iterator . next ( ) ; if ( ev . get Destination ( ) == src && p . match ( ev ) ) { break ; } } return ev ; }
public  Format (  String p Format String ) {  String l Format Vars [ ] = p Format String . split ( _ STR ) ; m Id =  Integer . parse Int ( l Format Vars [ _ NUM ] ) ; }
public  Jar Modifier (  File jar File ) throws  Jar Exception ,  IOException { this . jar File = jar File ;  Jar File jar = new  Jar File ( jar File ) ;  Enumeration < ? extends  Jar Entry > enumerator = jar . entries ( ) ; while ( enumerator . has More Elements ( ) ) {  Jar Entry current Entry = (  Jar Entry ) enumerator . next Element ( ) ;  Jar Entry reset Entry = new  Jar Entry ( current Entry . get Name ( ) ) ; jar Entries . put ( current Entry . get Name ( ) , reset Entry ) ; }  String manifest Path =  META_ INF +  SEPERATOR + _ STR ;  Jar Entry jar Entry = jar . get Jar Entry ( manifest Path ) ; if ( jar Entry != null ) {  Enumeration <  Jar Entry > entries = jar . entries ( ) ; while ( entries . has More Elements ( ) ) { jar Entry = (  Jar Entry ) entries . next Element ( ) ; if ( manifest Path . equals Ignore Case ( jar Entry . get Name ( ) ) ) { break ; } else { jar Entry = null ; } } }  Manifest manifest = new  Manifest ( ) ; if ( jar Entry != null ) { manifest . read ( jar . get Input Stream ( jar Entry ) ) ; } this . manifest = manifest ; jar . close ( ) ; }
public void append Cell ( byte value ) { append Cell (  String . value Of ( value ) ) ; }
public void expect Server Proxy Failed (  Message Info message Info ) { expected Api Calls . add ( new  Api Call (  SERVER_ PROXY_ FAILED , new  Object [ ] { message Info . get Origin ( ) , message Info . get Client ( ) , message Info . get Service ( ) } ) ) ; }
public void remove (  Object key ) { m_map . remove ( key ) ; }
public void add Attribute (  Attribute attribute ) { regular Attributes . add ( attribute ) ; }
public boolean is Empty ( ) { return children == null || children . is Empty ( ) ; }
Column column ( int column Index ) ;
public void add (  Production production ) { productions . add ( production ) ; }
private  Object do Index (  Object obj , boolean to LHS ,  Call Stack callstack ,  Interpreter interpreter ) throws  Eval Error ,  Reflect Error { int index = get Index Aux ( obj , callstack , interpreter , this ) ; if ( to LHS ) return new  LHS ( obj , index ) ; else try { return  Reflect . get Index ( obj , index ) ; } catch (  Util Eval Error e ) { throw e . to Eval Error ( this , callstack ) ; } }
protected  Object [ ] args With Receiver (  Object receiver ,  Object ... args ) {  Object [ ] execute Args ; if ( receiver == null ) { execute Args = args ; } else { execute Args = new  Object [ args . length + _ NUM ] ; execute Args [ _ NUM ] = receiver ; for ( int i = _ NUM ; i < args . length ; i ++ ) { execute Args [ i + _ NUM ] = args [ i ] ; } } return apply Arg Suppliers ( execute Args ) ; }
private void tred2 ( ) { for ( int j = _ NUM ; j < n ; j ++ ) { d [ j ] =  V [ n - _ NUM ] [ j ] ; } for ( int i = n - _ NUM ; i > _ NUM ; i -- ) { double scale = _ NUM ; double h = _ NUM ; for ( int k = _ NUM ; k < i ; k ++ ) { scale = scale +  Math . abs ( d [ k ] ) ; } if ( scale == _ NUM ) { e [ i ] = d [ i - _ NUM ] ; for ( int j = _ NUM ; j < i ; j ++ ) { d [ j ] =  V [ i - _ NUM ] [ j ] ;  V [ i ] [ j ] = _ NUM ;  V [ j ] [ i ] = _ NUM ; } } else { for ( int k = _ NUM ; k < i ; k ++ ) { d [ k ] /= scale ; h += d [ k ] * d [ k ] ; } double f = d [ i - _ NUM ] ; double g =  Math . sqrt ( h ) ; if ( f > _ NUM ) { g = - g ; } e [ i ] = scale * g ; h = h - f * g ; d [ i - _ NUM ] = f - g ; for ( int j = _ NUM ; j < i ; j ++ ) { e [ j ] = _ NUM ; } for ( int j = _ NUM ; j < i ; j ++ ) { f = d [ j ] ;  V [ j ] [ i ] = f ; g = e [ j ] +  V [ j ] [ j ] * f ; for ( int k = j + _ NUM ; k <= i - _ NUM ; k ++ ) { g +=  V [ k ] [ j ] * d [ k ] ; e [ k ] +=  V [ k ] [ j ] * f ; } e [ j ] = g ; } f = _ NUM ; for ( int j = _ NUM ; j < i ; j ++ ) { e [ j ] /= h ; f += e [ j ] * d [ j ] ; } double hh = f / ( h + h ) ; for ( int j = _ NUM ; j < i ; j ++ ) { e [ j ] -= hh * d [ j ] ; } for ( int j = _ NUM ; j < i ; j ++ ) { f = d [ j ] ; g = e [ j ] ; for ( int k = j ; k <= i - _ NUM ; k ++ ) {  V [ k ] [ j ] -= ( f * e [ k ] + g * d [ k ] ) ; } d [ j ] =  V [ i - _ NUM ] [ j ] ;  V [ i ] [ j ] = _ NUM ; } } d [ i ] = h ; } for ( int i = _ NUM ; i < n - _ NUM ; i ++ ) {  V [ n - _ NUM ] [ i ] =  V [ i ] [ i ] ;  V [ i ] [ i ] = _ NUM ; double h = d [ i + _ NUM ] ; if ( h != _ NUM ) { for ( int k = _ NUM ; k <= i ; k ++ ) { d [ k ] =  V [ k ] [ i + _ NUM ] / h ; } for ( int j = _ NUM ; j <= i ; j ++ ) { double g = _ NUM ; for ( int k = _ NUM ; k <= i ; k ++ ) { g +=  V [ k ] [ i + _ NUM ] *  V [ k ] [ j ] ; } for ( int k = _ NUM ; k <= i ; k ++ ) {  V [ k ] [ j ] -= g * d [ k ] ; } } } for ( int k = _ NUM ; k <= i ; k ++ ) {  V [ k ] [ i + _ NUM ] = _ NUM ; } } for ( int j = _ NUM ; j < n ; j ++ ) { d [ j ] =  V [ n - _ NUM ] [ j ] ;  V [ n - _ NUM ] [ j ] = _ NUM ; }  V [ n - _ NUM ] [ n - _ NUM ] = _ NUM ; e [ _ NUM ] = _ NUM ; }
protected  Client add To Indexes (  String ct ,  Map c Map ) { return add To Indexes ( ct , c Map , _ BOOL ) ; }
private static void delete (  File file To Delete ) { if ( ! file To Delete . delete ( ) ) { message ( _ STR + file To Delete . get Path ( ) ) ; } }
private void add Export Add Volume Steps (  Workflow workflow ,  Protection System rp System ,  URI export Group ID ,  Map <  URI ,  Integer > snapshots ) throws  Internal Exception {  Export Group export Group = _db Client . query Object (  Export Group . class , export Group ID ) ;  String export Step = workflow . create Step Id ( ) ; init Task Status ( export Group , export Step ,  Operation .  Status . pending , _ STR ) ;  Map <  URI ,  Map <  URI ,  Integer > > storage To Block Objects = get Storage To Block Objects ( snapshots ) ; for (  Map .  Entry <  URI ,  Map <  URI ,  Integer > > entry : storage To Block Objects . entry Set ( ) ) { _log . info (  String . format ( _ STR , export Group . get Id ( ) , entry . get Key ( ) , entry . get Value ( ) ) ) ; _export Wf Utils . generate Export Group Add Volumes ( workflow , null ,  STEP_ ENABLE_ IMAGE_ ACCESS , entry . get Key ( ) , export Group ID , entry . get Value ( ) ) ; } _log . info ( _ STR + export Group . get Id ( ) ) ; }
public  Hessian Debug State (  Print Writer dbg ) { _dbg = dbg ; _state = new  Initial State ( ) ; }
private boolean are Swc File Checksums Equal ( ) { if ( swc File Checksums == null ) { if (  Trace . swc Checksum ) {  Trace . trace ( _ STR ) ; } return _ BOOL ; }  Map <  String ,  Virtual File > swc Files = swc Context . get Files ( ) ;  Set <  Map .  Entry <  String ,  Long > > data Set = swc File Checksums . entry Set ( ) ; if ( swc Files . size ( ) < data Set . size ( ) ) { if (  Trace . swc Checksum ) {  Trace . trace ( _ STR ) ; } return _ BOOL ; } for (  Map .  Entry <  String ,  Long > entry : data Set ) {  String filename = entry . get Key ( ) ;  Long data File Last Modified = entry . get Value ( ) ;  Long swc File Last Modified = null ;  Virtual File swc File = swc Files . get ( filename ) ; if ( swc File != null ) { swc File Last Modified = new  Long ( swc File . get Last Modified ( ) ) ; } if ( ! data File Last Modified . equals ( swc File Last Modified ) ) { if (  Trace . swc Checksum ) {  Trace . trace ( _ STR ) ;  Trace . trace ( _ STR + filename ) ;  Trace . trace ( _ STR + data File Last Modified ) ;  Trace . trace ( _ STR + swc File Last Modified ) ; } return _ BOOL ; } } if (  Trace . swc Checksum ) {  Trace . trace ( _ STR ) ; } return _ BOOL ; }
private void adjust Min Pref For Spanning Comps (  Dim Constraint [ ] specs ,  Float [ ] def Push ,  Flow Size Spec fss ,  Array List <  Linked Dim Group > [ ] groups Lists ) { for ( int r = groups Lists . length - _ NUM ; r >= _ NUM ; r -- ) {  Array List <  Linked Dim Group > groups = groups Lists [ r ] ; for (  Linked Dim Group group : groups ) { if ( group . span == _ NUM ) continue ; int [ ] sizes = group . get Min Pref Max ( ) ; for ( int s =  Layout Util .  MIN ; s <=  Layout Util .  PREF ; s ++ ) { int c Size = sizes [ s ] ; if ( c Size ==  Layout Util .  NOT_ SET ) continue ; int row Size = _ NUM ; int s Ix = ( r << _ NUM ) + _ NUM ; int len =  Math . min ( ( group . span << _ NUM ) , fss . sizes . length - s Ix ) - _ NUM ; for ( int j = s Ix ; j < s Ix + len ; j ++ ) { int sz = fss . sizes [ j ] [ s ] ; if ( sz !=  Layout Util .  NOT_ SET ) row Size += sz ; } if ( row Size < c Size && len > _ NUM ) { for ( int eagerness = _ NUM , new Row Size = _ NUM ; eagerness < _ NUM && new Row Size < c Size ; eagerness ++ ) new Row Size = fss . expand Sizes ( specs , def Push , c Size , s Ix , len , s , eagerness ) ; } } } } }
public static byte [ ] decode Hex (  String hex String ) { int length = hex String . length ( ) ; if ( ( length & _ NUM ) != _ NUM ) { throw new  Illegal Argument Exception ( _ STR ) ; } boolean bad Hex = _ BOOL ; byte [ ] out = new byte [ length > > _ NUM ] ; for ( int i = _ NUM , j = _ NUM ; j < length ; i ++ ) { int c1 = hex String . char At ( j ++ ) ; if ( c1 > _ STR ) { bad Hex = _ BOOL ; break ; } final byte d1 =  DIGITS [ c1 ] ; if ( d1 == - _ NUM ) { bad Hex = _ BOOL ; break ; } int c2 = hex String . char At ( j ++ ) ; if ( c2 > _ STR ) { bad Hex = _ BOOL ; break ; } final byte d2 =  DIGITS [ c2 ] ; if ( d2 == - _ NUM ) { bad Hex = _ BOOL ; break ; } out [ i ] = ( byte ) ( d1 << _ NUM | d2 ) ; } if ( bad Hex ) { throw new  Illegal Argument Exception ( _ STR + hex String ) ; } return out ; }
public static  String read File To String (  File file ) { if ( file == null ) { return null ; }  Buffered Reader reader = null ; try { reader = new  Buffered Reader ( new  File Reader ( file ) ) ;  String Builder file Contents = new  String Builder ( _ STR ) ; boolean is First Line = _ BOOL ;  String current Line = reader . read Line ( ) ; while ( current Line != null ) { if ( is First Line ) is First Line = _ BOOL ; else file Contents . append (  System . line Separator ( ) ) ; file Contents . append ( current Line ) ; current Line = reader . read Line ( ) ; } return file Contents . to String ( ) ; } catch (  Exception e ) { logger . debug ( e . to String ( ) +  System . line Separator ( ) +  Stack Trace . get String From Stack Trace ( e ) ) ; return null ; } finally { try { if ( reader != null ) { reader . close ( ) ; } } catch (  Exception e ) { logger . debug ( e . to String ( ) +  System . line Separator ( ) +  Stack Trace . get String From Stack Trace ( e ) ) ; } } }
private  Coder Result control Sequence ( short new Byte ) { if ( new Byte >= _ NUM && new Byte <= _ NUM ) { if ( state ==  CONTROL_ SEQUENCE_ IF ) { return malformed Input (  ERR_ CTRLPI ) ; } queue . write ( new Byte ) ; } else if ( new Byte >= _ NUM && new Byte <= _ NUM ) { state =  CONTROL_ SEQUENCE_ IF ; queue . write ( new Byte ) ; } else if ( new Byte >= _ NUM && new Byte <= _ NUM ) { state =  NORMAL_ BYTES ; queue . reset ( ) ; } else { return malformed Input (  ERR_ CTRLBYTE ) ; } return  Coder Result .  UNDERFLOW ; }
@  Nullable public static  Network Parameters from Pmt Protocol ID (  String pmt Protocol Id ) { if ( pmt Protocol Id . equals (  PAYMENT_ PROTOCOL_ ID_ MAINNET ) ) { return  Main Net Params . get ( ) ; } else if ( pmt Protocol Id . equals (  PAYMENT_ PROTOCOL_ ID_ TESTNET ) ) { return  Test Net3 Params . get ( ) ; } else { return null ; } }
public void add Certificates (  Store cert Store ) throws  CMSException { certs . add All (  CMSUtils . get Certificates From Store ( cert Store ) ) ; }
protected abstract  String encode Body ( ) ;
private static double distance ( double x1 , double y1 , double x2 , double y2 ) { return  Math . sqrt ( ( y2 - y1 ) * ( y2 - y1 ) + ( x2 - x1 ) * ( x2 - x1 ) ) ; }
void save Resource Index (  String resource Type ) throws  Policy Exception ,  SSOException {  Resource Index resource Index = (  Resource Index ) resource Indices . get ( resource Type ) ; if ( resource Index != null ) {  String resource Index XML = resource Index . to XML ( ) ; resource Manager . save Resource Index ( resource Type , resource Index XML ) ; } }
public byte [ ] bitcoin Serialize ( ) { if ( header Bytes Valid && transaction Bytes Valid ) {  Preconditions . check Not Null ( bytes , _ STR ) ; if ( length == bytes . length ) { return bytes ; } else { byte [ ] buf = new byte [ length ] ;  System . arraycopy ( bytes , offset , buf , _ NUM , length ) ; return buf ; } }  Byte Array Output Stream stream = new  Unsafe Byte Array Output Stream ( length ==  UNKNOWN_ LENGTH ?  HEADER_ SIZE + guess Transactions Length ( ) : length ) ; try { write Header ( stream ) ; write Transactions ( stream ) ; } catch (  IOException e ) { } return stream . to Byte Array ( ) ; }
@  Override public  List <  Period > generate Periods (  Date Time Unit date Time Unit ) {  Calendar calendar = get Calendar ( ) ; date Time Unit = calendar . minus Years ( date Time Unit , _ NUM ) ; date Time Unit . set Day ( _ NUM ) ; date Time Unit . set Month ( _ NUM ) ;  List <  Period > periods =  Lists . new Array List ( ) ; for ( int i = _ NUM ; i < _ NUM ; ++ i ) { periods . add ( create Period ( date Time Unit , calendar ) ) ; date Time Unit = calendar . plus Years ( date Time Unit , _ NUM ) ; } return periods ; }
@  Override public  Set <  String > vertex Match Pattern Labels ( ) { return labels . size ( ) == _ NUM ? labels :  Collections . empty Set ( ) ; }
static  String replace Default (  String summary Label ,  String default String ) { return summary Label . replace All ( _ STR , default String ) ; }
public void add Category (  Category category ) { if ( categories == null ) { categories = new  Array List <  Category > ( ) ; } categories . add ( category ) ; }
private static int  Call Object Method V (  JNIEnvironment env , int obj JREF , int method ID ,  Address arg Address ) throws  Exception { if ( trace JNI )  VM . sys Write ( _ STR ) ;  Runtime Entrypoints . check JNICount Down To GC ( ) ; try {  Object obj = env . get JNIRef ( obj JREF ) ;  Object return Obj =  JNIHelpers . invoke With Var Arg ( obj , method ID , arg Address , null , _ BOOL ) ; return env . push JNIRef ( return Obj ) ; } catch (  Throwable unexpected ) { if ( trace JNI ) unexpected . print Stack Trace (  System . err ) ; env . record Exception ( unexpected ) ; return _ NUM ; } }
private  Tuple <  Message ,  Connection > try Other Messages ( ) {  List <  Tuple <  Message ,  Connection > > messages = new  Array List <  Tuple <  Message ,  Connection > > ( ) ;  Collection <  Message > msg Collection = get Message Collection ( ) ; for (  Connection con : get Connections ( ) ) {  DTNHost other = con . get Other Node ( get Host ( ) ) ;  Prophet Router oth Router = (  Prophet Router ) other . get Router ( ) ; if ( oth Router . is Transferring ( ) ) { continue ; } for (  Message m : msg Collection ) { if ( oth Router . has Message ( m . get Id ( ) ) ) { continue ; } if ( oth Router . get Pred For ( m . get To ( ) ) > get Pred For ( m . get To ( ) ) ) { messages . add ( new  Tuple <  Message ,  Connection > ( m , con ) ) ; } } } if ( messages . size ( ) == _ NUM ) { return null ; }  Collections . sort ( messages , new  Tuple Comparator ( ) ) ; return try Messages For Connected ( messages ) ; }
public void remove Movie Set (  Movie Set movie Set ) { synchronized ( root ) {  Movie Set Tree Node node = (  Movie Set Tree Node ) node Map . get ( movie Set ) ; int index = root . get Index ( node ) ; movie Set . remove Property Change Listener ( property Change Listener ) ; node Map . remove ( movie Set ) ; for (  Movie movie : movie Set . get Movies ( ) ) { node Map . remove ( movie ) ; movie . remove Property Change Listener ( property Change Listener ) ; } node . remove All Children ( ) ; node . remove From Parent ( ) ;  Tree Model Event event = new  Tree Model Event ( this , root . get Path ( ) , new int [ ] { index } , new  Object [ ] { node } ) ; for (  Tree Model Listener listener : listeners ) { listener . tree Nodes Removed ( event ) ; } } }
public static void cache Internal Item Id (  Consumer Bean consumer Bean ,  String client Id ,  Long internal Id ) { final  String client Id Key =  Mem Cache Keys . get Item Internal Id ( consumer Bean . get Short_name ( ) , client Id ) ;  Mem Cache Peer . put ( client Id Key , internal Id ,  Constants .  CACHING_ TIME ) ; }
protected void process Ignore Section (  IXMLReader reader ,  IXMLEntity Resolver entity Resolver ) throws  Exception { if ( !  XMLUtil . check Literal ( reader , _ STR ) ) {  XMLUtil . skip Tag ( reader ) ; return ; }  XMLUtil . skip Whitespace ( reader , null ) ;  String str =  XMLUtil . read ( reader , _ STR ) ; char ch = str . char At ( _ NUM ) ; if ( ch != _ STR ) {  XMLUtil . skip Tag ( reader ) ; return ; }  Reader subreader = new  CDATAReader ( reader ) ; subreader . close ( ) ; }
Node <  V > find ( int h , int k ) {  Node <  V > e = this ; do { if ( ( e . key == k ) ) { return e ; } } while ( ( e = e . next ) != null ) ; return null ; }
public boolean is Public ( ) { return  Modifier . is Public ( _class . get Modifiers ( ) ) ; }
@  Override public boolean receive Image (  Image To Process img ,  Set <  Task Image Container > tasks , boolean block Until Image Release , boolean close On Image Release ,  Optional <  Runnable > runnable When Done ) throws  Interrupted Exception { if ( tasks == null || tasks . size ( ) <= _ NUM ) { return _ BOOL ; } if ( img == null ) { throw new  Runtime Exception ( _ STR ) ; } int count Image Refs = num Propagated Image References ( img , tasks ) ; initialize Task Done ( tasks , runnable When Done ) ;  Image Release Protocol protocol = set Semaphore Reference Count ( img , count Image Refs , block Until Image Release , close On Image Release ) ; schedule Tasks ( tasks ) ; if ( protocol . block Until Release ) { protocol . block ( ) ; } return _ BOOL ; }
public static  Big Decimal base (  Big Decimal p_ Amount , int p_ C_ Currency From_ ID ,  Timestamp p_ Conversion Date , int p_ AD_ Client_ ID , int p_ AD_ Org_ ID ) throws  SQLException { if ( p_ Amount == null || p_ C_ Currency From_ ID == _ NUM ) return null ; if ( p_ Amount . signum ( ) == _ NUM ) return p_ Amount ;  String sql = _ STR + _ STR + _ STR + _ STR ; int  C_ Currency To_ ID =  Adempiere . get SQLValue ( sql , p_ AD_ Client_ ID ) ; if ( p_ C_ Currency From_ ID ==  C_ Currency To_ ID ) return p_ Amount ; return convert ( p_ Amount , p_ C_ Currency From_ ID ,  C_ Currency To_ ID , p_ Conversion Date , _ NUM , p_ AD_ Client_ ID , p_ AD_ Org_ ID ) ; }
private static  S2 Cell Id from Face IJWrap ( int face , int i , int j ) { i =  Math . max ( - _ NUM ,  Math . min (  MAX_ SIZE , i ) ) ; j =  Math . max ( - _ NUM ,  Math . min (  MAX_ SIZE , j ) ) ; final double k Scale = _ NUM /  MAX_ SIZE ; double s = k Scale * ( ( i << _ NUM ) + _ NUM -  MAX_ SIZE ) ; double t = k Scale * ( ( j << _ NUM ) + _ NUM -  MAX_ SIZE ) ;  S2 Point p =  S2 Projections . face Uv To Xyz ( face , s , t ) ; face =  S2 Projections . xyz To Face ( p ) ;  R2 Vector st =  S2 Projections . valid Face Xyz To Uv ( face , p ) ; return from Face IJ ( face , st To IJ ( st . x ( ) ) , st To IJ ( st . y ( ) ) ) ; }
private void reset View ( ) { final  Project project = app Context . get Root Project ( ) ; final  String project Name = project != null ? project . get Name ( ) : null ; if ( ! is Current Project ( project Name ) ) return ; view . set Repository Url ( _ STR ) ; if ( ! is Current Project ( project Name ) ) return ; view . set Contribute To Branch ( _ STR ) ; if ( ! is Current Project ( project Name ) ) return ; view . set Contribution Branch Name ( _ STR ) ; if ( ! is Current Project ( project Name ) ) return ; view . set Contribution Branch Name Enabled ( _ BOOL ) ; if ( ! is Current Project ( project Name ) ) return ; view . set Contribution Branch Name List (  Collections . <  String > empty List ( ) ) ; if ( ! is Current Project ( project Name ) ) return ; view . set Contribution Title ( _ STR ) ; if ( ! is Current Project ( project Name ) ) return ; view . set Project Name ( _ STR ) ; if ( ! is Current Project ( project Name ) ) return ; view . set Contribution Title Enabled ( _ BOOL ) ; if ( ! is Current Project ( project Name ) ) return ; view . set Contribution Comment ( _ STR ) ; if ( ! is Current Project ( project Name ) ) return ; view . set Contribution Comment Enabled ( _ BOOL ) ; if ( ! is Current Project ( project Name ) ) return ; view . set Contribute Button Text ( messages . contribute Part Configure Contribution Section Button Contribute Text ( ) ) ; if ( ! is Current Project ( project Name ) ) return ; view . hide Status Section ( ) ; if ( ! is Current Project ( project Name ) ) return ; view . hide New Contribution Section ( ) ; if ( ! is Current Project ( project Name ) ) return ; update Controls ( ) ; }
public void close ( ) throws  IOException { stream . close ( ) ; }
private  String number To National (  String number ) { final  Phone Number Util util =  Phone Number Util . get Instance ( ) ; try { final  Phonenumber .  Phone Number phone Number = util . parse ( number , m Country Code ) ; return  String . value Of ( phone Number . get National Number ( ) ) ; } catch (  Number Parse Exception e ) { return _ STR ; } }
public static void reset Time Comparison Epsilon Micros ( ) { time Comparison Epsilon = initialize Time Epsilon ( ) ; }
public  Optional <  String > string Value ( ) { return  Optional . empty ( ) ; }
static public  JLabel create JLabel For Table ( ) {  JLabel label = new  JLabel ( ) ; set Plain ( label ) ; label . set Opaque ( _ BOOL ) ; label . set Foreground (  TABLE_ COMPONENT_ FG_ COLOR ) ; label . set Background (  TABLE_ COMPONENT_ BG_ COLOR ) ; return label ; }
@  Nullable public  Virtual File find File By Relative Path ( @  Not Null @  Non Nls  String rel Path ) { if ( rel Path . is Empty ( ) ) return this ; rel Path =  String Util . trim Start ( rel Path , _ STR ) ; int index = rel Path . index Of ( _ STR ) ; if ( index < _ NUM ) index = rel Path . length ( ) ;  String name = rel Path . substring ( _ NUM , index ) ;  Virtual File child ; if ( name . equals ( _ STR ) ) { child = this ; } else if ( name . equals ( _ STR ) ) { if ( is (  VFile Property .  SYMLINK ) ) { final  Virtual File canonical File = get Canonical File ( ) ; child = canonical File != null ? canonical File . get Parent ( ) : null ; } else { child = get Parent ( ) ; } } else { child = find Child ( name ) ; } if ( child == null ) return null ; if ( index < rel Path . length ( ) ) { return child . find File By Relative Path ( rel Path . substring ( index + _ NUM ) ) ; } return child ; }
private static  String strip Dot Suffix ( final  String value ) { if ( value == null ) { return null ; } final int index = value . index Of ( _ STR ) ; if ( index != - _ NUM ) return value . substring ( _ NUM , index ) ; return value ; }
public void test Execute Null Runnable ( ) {  Executor Service e = new  Fork Join Pool ( _ NUM ) ;  Pool Cleaner cleaner = null ; try { cleaner = cleaner ( e ) ; try { @  Suppress Warnings ( _ STR )  Future < ? > future = e . submit ( (  Runnable ) null ) ; should Throw ( ) ; } catch (  Null Pointer Exception success ) { } } finally { if ( cleaner != null ) { cleaner . close ( ) ; } } }
private static long read Long (  Input Stream in ) throws  IOException { int b0 = in . read ( ) ; int b1 = in . read ( ) ; int b2 = in . read ( ) ; int b3 = in . read ( ) ; if ( ( b0 | b1 | b2 | b3 ) == - _ NUM ) { throw new  EOFException ( ) ; } int upper = ( b0 << _ NUM ) | ( b1 << _ NUM ) | ( b2 << _ NUM ) | b3 ; b0 = in . read ( ) ; b1 = in . read ( ) ; b2 = in . read ( ) ; b3 = in . read ( ) ; if ( ( b0 | b1 | b2 | b3 ) == - _ NUM ) { throw new  EOFException ( ) ; } int lower = ( b0 << _ NUM ) | ( b1 << _ NUM ) | ( b2 << _ NUM ) | b3 ; return ( ( long ) upper << _ NUM ) | ( lower & _ NUM ) ; }
public synchronized  String format (  Date in Date ) { return format ( in Date . get Time ( ) ) ; }
public void clear ( ) { clear ( _ BOOL ) ; }
@  Override public  Graph Query has ( final  String key ) { criteria . add ( new  Has ( key ) ) ; return this ; }
public  Attr Set read ( java . security .  Principal principal ,  Guid guid ) throws  UMSException { return read ( principal , guid , null ) ; }
private static void write Input Stream To Output Stream (  Input Stream input Stream ,  Output Stream output Stream ) { try { try { final byte [ ] buffer = new byte [ _ NUM ] ; int read ; while ( ( read = input Stream . read ( buffer ) ) != - _ NUM ) { output Stream . write ( buffer , _ NUM , read ) ; } output Stream . flush ( ) ; } catch ( final  Exception e ) { e . print Stack Trace ( ) ; } finally { output Stream . close ( ) ; input Stream . close ( ) ; } } catch ( final  Exception e ) { e . print Stack Trace ( ) ; } }
public  String Element add Element (  String element ) { add Element (  Integer . to String ( element . hash Code ( ) ) , element ) ; return ( this ) ; }
public static byte [ ] as Bytes (  String basic String ) { final byte [ ] b = new byte [ basic String . length ( ) ] ; for ( int i = _ NUM ; i < b . length ; ++ i ) { b [ i ] = ( byte ) basic String . char At ( i ) ; } return b ; }
@  Override public void mouse Released (  Mouse Event e ) { start Sort ( ) ; e . consume ( ) ; }
public java . util .  List create Headers (  String headers ) throws java . text .  Parse Exception { if ( headers == null ) throw new  Null Pointer Exception ( _ STR ) ;  String Msg Parser smp = new  String Msg Parser ( ) ;  SIPHeader shdr = smp . parse SIPHeader ( headers ) ; if ( shdr instanceof  SIPHeader List ) return (  SIPHeader List ) shdr ; else throw new  Parse Exception ( _ STR , _ NUM ) ; }
@  Override public  String to String ( ) {  String Builder result = new  String Builder ( ) ; result . append ( type . to String ( ) ) ; result . append ( _ STR ) ; result . append ( name ) ; result . append ( _ STR ) ; if ( fields Data != null ) { result . append ( fields Data ) ; } result . append ( _ STR ) ; return result . to String ( ) ; }
public int exit_code ( ) { return  Integer . parse Int ( fields [ _ NUM ] ) ; }
public  Int Hash Map (  Map t ) { this (  Math . max ( _ NUM * t . size ( ) , _ NUM ) , _ NUM ) ; put All ( t ) ; }
public static final void write Int Array Xml ( int [ ] val ,  String name ,  Xml Serializer out ) throws  Xml Pull Parser Exception , java . io .  IOException { if ( val == null ) { out . start Tag ( null , _ STR ) ; out . end Tag ( null , _ STR ) ; return ; } out . start Tag ( null , _ STR ) ; if ( name != null ) { out . attribute ( null , _ STR , name ) ; } final int n = val . length ; out . attribute ( null , _ STR ,  Integer . to String ( n ) ) ; for ( int i = _ NUM ; i < n ; i ++ ) { out . start Tag ( null , _ STR ) ; out . attribute ( null , _ STR ,  Integer . to String ( val [ i ] ) ) ; out . end Tag ( null , _ STR ) ; } out . end Tag ( null , _ STR ) ; }
private  Spannable highlight User Handles (  Spannable text ) { if ( text == null ) { return null ; } final  Matcher matcher =  PATTERN_ USER_ HANDLES . matcher ( text ) ; while ( matcher . find ( ) ) { final int start = matcher . start ( _ NUM ) ; final int end = matcher . end ( _ NUM ) ; text . set Span ( new  Foreground Color Span ( m Highlight Color ) , start , end ,  Spanned .  SPAN_ EXCLUSIVE_ EXCLUSIVE ) ; text . set Span ( new  Style Span ( android . graphics .  Typeface .  BOLD ) , start , end ,  Spanned .  SPAN_ EXCLUSIVE_ EXCLUSIVE ) ; } return text ; }
protected int read Block ( ) { block Size = read ( ) ; int n = _ NUM ; if ( block Size > _ NUM ) { try { int count = _ NUM ; while ( n < block Size ) { count = in . read ( block , n , block Size - n ) ; if ( count == - _ NUM ) break ; n += count ; } } catch (  IOException e ) { } if ( n < block Size ) { status =  STATUS_ FORMAT_ ERROR ; } } return n ; }
private static boolean are Method Args Compatible (  Class [ ] arg Types ,  Object [ ] args ) { for ( int i = _ NUM ; i < args . length ; i ++ ) {  Object arg = args [ i ] ;  Class arg Type = wrap ( arg Types [ i ] ) ; if ( arg != null && ! arg Type . is Assignable From ( arg . get Class ( ) ) ) return _ BOOL ; } return _ BOOL ; }
private  Http Entity execute Get (  String url ,  String [ ] [ ] get Params ,  String [ ] [ ] header Params ) throws  IOException { if ( get Params != null ) {  List <  Name Value Pair > formparams = new  Array List <  Name Value Pair > ( ) ; for (  String [ ] param : get Params ) { if ( param [ _ NUM ] != null && param [ _ NUM ] != null ) { formparams . add ( new  Basic Name Value Pair ( param [ _ NUM ] , param [ _ NUM ] ) ) ; } } url = url + _ STR +  URLEncoded Utils . format ( formparams , _ STR ) ; }  Http Get httpget = new  Http Get ( url ) ; if ( header Params != null ) { for (  String [ ] param : header Params ) { if ( param [ _ NUM ] != null && param [ _ NUM ] != null ) { httpget . set Header ( param [ _ NUM ] , param [ _ NUM ] ) ; } } } return execute Http Request ( httpget ) ; }
public  Image rotate270 Degrees (  Image image , boolean maintain Opacity ) { int [ ] rgb = image . get RGB ( ) ; int [ ] new RGB = new int [ rgb . length ] ; int width = image . get Width ( ) ; int height = image . get Height ( ) ; for ( int y = _ NUM ; y < height ; y ++ ) { for ( int x = _ NUM ; x < width ; x ++ ) { new RGB [ y + x * height ] = rgb [ x + y * width ] ; } } return  Encoded Image . create From RGB ( new RGB , height , width , ! maintain Opacity ) ; }
public  Serbian Normalization Filter Factory (  Map <  String ,  String > args ) { super ( args ) ; this . haircut = get ( args , _ STR ,  Arrays . as List ( _ STR , _ STR ) , _ STR ) ; if ( ! args . is Empty ( ) ) { throw new  Illegal Argument Exception ( _ STR + args ) ; } }
public static <  T >  T wrap Throw (  Callable <  T > callable ) { try { return callable . call ( ) ; } catch (  Runtime Exception e ) { throw e ; } catch (  Exception e ) { throw new  Runtime Exception ( e ) ; } }
public static  String pad (  String str , int total Chars ) { if ( str == null ) str = _ STR ; int slen = str . length ( ) ;  String Buffer sb = new  String Buffer ( str ) ; for ( int i = _ NUM ; i < total Chars - slen ; i ++ ) { sb . append ( _ STR ) ; } return sb . to String ( ) ; }
protected void decode Image Data ( ) { int  Null Code = - _ NUM ; int npix = iw * ih ; int available , clear , code_mask , code_size , end_of_information , in_code , old_code , bits , code , count , i , datum , data_size , first , top , bi , pi ; if ( ( pixels == null ) || ( pixels . length < npix ) ) { pixels = new byte [ npix ] ; } if ( prefix == null ) prefix = new short [  Max Stack Size ] ; if ( suffix == null ) suffix = new byte [  Max Stack Size ] ; if ( pixel Stack == null ) pixel Stack = new byte [  Max Stack Size + _ NUM ] ; data_size = read ( ) ; clear = _ NUM << data_size ; end_of_information = clear + _ NUM ; available = clear + _ NUM ; old_code =  Null Code ; code_size = data_size + _ NUM ; code_mask = ( _ NUM << code_size ) - _ NUM ; for ( code = _ NUM ; code < clear ; code ++ ) { prefix [ code ] = _ NUM ; suffix [ code ] = ( byte ) code ; } datum = bits = count = first = top = pi = bi = _ NUM ; for ( i = _ NUM ; i < npix ; ) { if ( top == _ NUM ) { if ( bits < code_size ) { if ( count == _ NUM ) { count = read Block ( ) ; if ( count <= _ NUM ) break ; bi = _ NUM ; } datum += ( block [ bi ] & _ NUM ) << bits ; bits += _ NUM ; bi ++ ; count -- ; continue ; } code = datum & code_mask ; datum >>= code_size ; bits -= code_size ; if ( ( code > available ) || ( code == end_of_information ) ) break ; if ( code == clear ) { code_size = data_size + _ NUM ; code_mask = ( _ NUM << code_size ) - _ NUM ; available = clear + _ NUM ; old_code =  Null Code ; continue ; } if ( old_code ==  Null Code ) { pixel Stack [ top ++ ] = suffix [ code ] ; old_code = code ; first = code ; continue ; } in_code = code ; if ( code == available ) { pixel Stack [ top ++ ] = ( byte ) first ; code = old_code ; } while ( code > clear ) { pixel Stack [ top ++ ] = suffix [ code ] ; code = prefix [ code ] ; } first = suffix [ code ] & _ NUM ; if ( available >=  Max Stack Size ) break ; pixel Stack [ top ++ ] = ( byte ) first ; prefix [ available ] = ( short ) old_code ; suffix [ available ] = ( byte ) first ; available ++ ; if ( ( ( available & code_mask ) == _ NUM ) && ( available <  Max Stack Size ) ) { code_size ++ ; code_mask += available ; } old_code = in_code ; } top -- ; pixels [ pi ++ ] = pixel Stack [ top ] ; i ++ ; } for ( i = pi ; i < npix ; i ++ ) { pixels [ i ] = _ NUM ; } }
public int hash Code ( ) { if ( myhash == - _ NUM ) { myhash = timestamp . hash Code ( ) + signer Cert Path . hash Code ( ) ; } return myhash ; }
public static  Charset default Charset ( ) { if ( default Charset == null ) { synchronized (  Charset . class ) {  String csn =  Access Controller . do Privileged ( new  Get Property Action ( _ STR ) ) ;  Charset cs = lookup ( csn ) ; if ( cs != null ) default Charset = cs ; else default Charset = for Name ( _ STR ) ; } } return default Charset ; }
public boolean has Value Been Updated ( int row Index , int column Index ) {  Scale SLDData data = scale List . get ( row Index ) ; if ( column Index ==  COL_ MIN_ SCALE ) { return data . is Minimum Scale Updated ( ) ; } if ( column Index ==  COL_ MAX_ SCALE ) { return data . is Maximum Scale Updated ( ) ; } return _ BOOL ; }
public void info ( ) { }
private static void ensure Packages (  File pkg ) throws  IOException { if ( ! pkg . exists ( ) && ! pkg . mkdirs ( ) ) throw new  IOException ( _ STR + pkg ) ; }
@  Override public void action Performed (  Action Event ev ) { final megan . remote .  Remote Service Browser remote Service Browser = ( megan . remote .  Remote Service Browser ) get Viewer ( ) ; if ( remote Service Browser != null ) {  String url = remote Service Browser . get URL ( ) ; if ( url . length ( ) > _ NUM ) { execute ( _ STR + url + _ STR ) ; } } }
static public boolean validate Certificate (  X509 Certificate cert , boolean check CAStatus ) {  String method = _ STR ; boolean certgood = _ BOOL ; try {  Vector crls = new  Vector ( ) ;  X509 CRL crl =  AMCRLStore . get CRL ( ldap Params , cert , crl Search Attr ) ; if ( crl != null ) { crls . add ( crl ) ; } if ( debug . message Enabled ( ) ) { debug . message ( method + _ STR + crls . size ( ) ) ; if ( crls . size ( ) > _ NUM ) { debug . message ( method + _ STR + crls . to String ( ) ) ; } else { debug . message ( method + _ STR ) ; } }  AMCert Path certpath = new  AMCert Path ( crls ) ;  X509 Certificate certs [ ] = { cert } ; if ( ! certpath . verify ( certs , _ BOOL , _ BOOL ) ) { debug . error ( method + _ STR ) ; return certgood = _ BOOL ; } } catch (  Exception e ) { debug . error ( method + _ STR , e ) ; return certgood = _ BOOL ; } if ( ( check CAStatus == _ BOOL ) && (  AMCert Store . is Root CA ( cert ) == _ BOOL ) ) {  X509 Certificate ca Cert =  AMCert Store . get Issuer Certificate ( ldap Params , cert , crl Search Attr ) ; certgood = validate Certificate ( ca Cert , check CAStatus ) ; } return certgood ; }
public static void compress ( ) {  String input =  Binary Std In . read String ( ) ;  TST <  Integer > st = new  TST <  Integer > ( ) ; for ( int i = _ NUM ; i <  R ; i ++ ) st . put ( _ STR + ( char ) i , i ) ; int code =  R + _ NUM ; while ( input . length ( ) > _ NUM ) {  String s = st . longest Prefix Of ( input ) ;  Binary Std Out . write ( st . get ( s ) ,  W ) ; int t = s . length ( ) ; if ( t < input . length ( ) && code <  L ) st . put ( input . substring ( _ NUM , t + _ NUM ) , code ++ ) ; input = input . substring ( t ) ; }  Binary Std Out . write (  R ,  W ) ;  Binary Std Out . close ( ) ; }
void define Labels ( ) { labels Values = calc Labels ( ) ; if ( handle Values ) labels = get Labels From Values ( ) ; else labels = get Labels From Data ( ) ; n Labels = labels . size ( ) ; }
public  String to String ( ) {  String Buffer buffer = new  String Buffer ( ) ; buffer . append ( to String ( get Class ( ) ) ) ; buffer . append ( _ STR ) ; buffer . append ( is Use Default ( ) ) ; buffer . append ( _ STR ) ; buffer . append ( element Converter . to String ( ) ) ; buffer . append ( _ STR ) ; return buffer . to String ( ) ; }
@  Override public double [ ] make Inverse Cumulative Test Points ( ) { double [ ] points = make Cumulative Test Values ( ) ; double [ ] points2 = new double [ points . length - _ NUM ] ;  System . arraycopy ( points , _ NUM , points2 , _ NUM , points2 . length ) ; return points2 ; }
public java . lang .  String Buffer append ( boolean b ) { internal . append ( b ) ; return this ; }
boolean check Server Up (  String server Id ) { if ( ( server Id == null ) || ( server Id . is Empty ( ) ) ) { return _ BOOL ; } if ( server Id . equals Ignore Case ( local Server Id ) ) { return _ BOOL ; } if ( ( servers == null ) || servers . is Empty ( ) ) { return _ BOOL ; }  State Info info = servers . get ( server Id ) ; info . is Up = check Server Up ( info ) ; return info . is Up ; }
public synchronized void return Buf ( byte [ ] buf ) { if ( buf == null || buf . length > m Size Limit ) { return ; } m Buffers By Last Use . add ( buf ) ; int pos =  Collections . binary Search ( m Buffers By Size , buf ,  BUF_ COMPARATOR ) ; if ( pos < _ NUM ) { pos = - pos - _ NUM ; } m Buffers By Size . add ( pos , buf ) ; m Current Size += buf . length ; trim ( ) ; }
public boolean contains ( terminal sym ) throws internal_error { not_null ( sym ) ; return _elements . get ( sym . index ( ) ) ; }
public  File create File Object (  String path ) { if ( path . length ( ) >= _ NUM && path . char At ( _ NUM ) == _ STR &&  Character . is Letter ( path . char At ( _ NUM ) ) ) { if ( path . length ( ) == _ NUM ) { path += _ STR ; } else if ( path . char At ( _ NUM ) != _ STR ) { path = path . substring ( _ NUM , _ NUM ) + _ STR + path . substring ( _ NUM ) ; } } return super . create File Object ( path ) ; }
private void enqueue Final Update ( ) { update Handler . remove Messages (  MSG_ FINAL_ UPDATE ) ; update Handler . send Message Delayed ( update Handler . obtain Message (  MSG_ FINAL_ UPDATE , last Start Id , - _ NUM ) , _ NUM *  MINUTE_ IN_ MILLIS ) ; }
public void write Tag (  String tag ,  File value ) { write Tag ( tag , value . get Path ( ) ) ; }
public int hash Code ( ) { if ( myhash == - _ NUM ) { myhash = timestamp . hash Code ( ) + signer Cert Path . hash Code ( ) ; } return myhash ; }
public  Type Variable BV type Variable (  Type Node type Node ) {  Type Variable BV result = type Variable Map . get ( type Node ) ; if ( result == null ) { int id = type Variable List . size ( ) ; type Variable List . add ( null ) ; result = new  Type Variable BV ( id , this , type Node ) ; type Variable List . set ( id , result ) ; type Variable Map . put ( type Node , result ) ; } return result ; }
public abstract  Servlet Request do Before ( final  Servlet Request servlet Request , final  Servlet Response servlet Response ) throws  IOException ,  Servlet Exception ;
public static void upto (  Number self ,  Number to , @  Closure Params (  First Param . class )  Closure closure ) { int self1 = self . int Value ( ) ; int to1 = to . int Value ( ) ; if ( self1 <= to1 ) { for ( int i = self1 ; i <= to1 ; i ++ ) { closure . call ( i ) ; } } else throw new  Groovy Runtime Exception ( _ STR + to + _ STR + self + _ STR ) ; }
public void add Elements (  List <  Select Clause Element > select Clause Elements ) { select List . add All ( select Clause Elements ) ; }
public synchronized void remove Pv Change Listener (  Pv Change Listener l ) { ensure Pv Change Listeners ( ) ;  Pv Change Listeners . remove ( l ) ; allow Events = !  Pv Change Listeners . is Empty ( ) ; log . trace ( _ STR + to String ( ) + _ STR +  String . value Of ( l ) ) ; }
public static  Geo Time Serie normalize (  Geo Time Serie gts ) { if ( (  TYPE .  DOUBLE != gts . get Type ( ) &&  TYPE .  LONG != gts . get Type ( ) ) || _ NUM == gts . values ) { return gts . clone ( ) ; } double dmin =  Double .  POSITIVE_ INFINITY ; double dmax =  Double .  NEGATIVE_ INFINITY ; long lmin =  Long .  MAX_ VALUE ; long lmax =  Long .  MIN_ VALUE ; if (  TYPE .  LONG == gts . get Type ( ) ) { for ( int i = _ NUM ; i < gts . values ; i ++ ) { long value = ( long )  GTSHelper . value At Index ( gts , i ) ; if ( value > lmax ) { lmax = value ; } if ( value < lmin ) { lmin = value ; } } } else { for ( int i = _ NUM ; i < gts . values ; i ++ ) { double value = ( double )  GTSHelper . value At Index ( gts , i ) ; if ( value > dmax ) { dmax = value ; } if ( value < dmin ) { dmin = value ; } } } boolean constant = _ BOOL ; if ( lmin == lmax || dmin == dmax ) { constant = _ BOOL ; }  Geo Time Serie normalized = new  Geo Time Serie ( gts . lastbucket , gts . bucketcount , gts . bucketspan , gts . values ) ; normalized . set Name ( gts . get Name ( ) ) ; normalized . set Labels ( gts . get Labels ( ) ) ; for ( int i = _ NUM ; i < gts . values ; i ++ ) {  Object value ; if ( constant ) { value = _ NUM ; } else if (  TYPE .  LONG == gts . get Type ( ) ) { value = ( ( long )  GTSHelper . value At Index ( gts , i ) - lmin ) / ( double ) ( lmax - lmin ) ; } else { value = ( ( double )  GTSHelper . value At Index ( gts , i ) - dmin ) / ( double ) ( dmax - dmin ) ; }  GTSHelper . set Value ( normalized , gts . ticks [ i ] ,  GTSHelper . location At Index ( gts , i ) ,  GTSHelper . elevation At Index ( gts , i ) , value , _ BOOL ) ; } return normalized ; }
public void save To Properties (  Properties properties ) { properties . set Property ( _ STR ,  Boolean . to String ( projected ) ) ; properties . set Property ( _ STR ,  String Util . double Array To String ( tie Point ) ) ; properties . set Property ( _ STR ,  String Util . double Array To String ( scale ) ) ; if ( globe == null ) { globe =  Layer Factory . default Globe ; } properties . set Property ( _ STR , globe ) ; properties . set Property ( _ STR ,  Integer . to String ( raster Width ) ) ; properties . set Property ( _ STR ,  Integer . to String ( raster Length ) ) ; properties . set Property ( _ STR , proj Linear Units ) ; if ( datum Code > _ NUM ) { properties . set Property ( _ STR ,  Integer . to String ( datum Code ) ) ; } if ( ellipsoid Code > _ NUM ) { properties . set Property ( _ STR ,  Integer . to String ( ellipsoid Code ) ) ; } if ( !  Double . is Na N ( semi Major Axis ) ) { properties . set Property ( _ STR ,  Double . to String ( semi Major Axis ) ) ; } if ( !  Double . is Na N ( semi Minor Axis ) ) { properties . set Property ( _ STR ,  Double . to String ( semi Minor Axis ) ) ; } if ( !  Double . is Na N ( inverse Flattening ) ) { properties . set Property ( _ STR ,  Double . to String ( inverse Flattening ) ) ; } if ( !  Double . is Na N ( gcs Prime Meridian Lon ) ) { properties . set Property ( _ STR ,  Double . to String ( gcs Prime Meridian Lon ) ) ; } if ( proj Code > _ NUM ) { properties . set Property ( _ STR ,  Integer . to String ( proj Code ) ) ; } if ( pcs Code > _ NUM ) { properties . set Property ( _ STR ,  Integer . to String ( pcs Code ) ) ; } if ( coord Transform Code > _ NUM ) { properties . set Property ( _ STR ,  Integer . to String ( coord Transform Code ) ) ; } if ( !  Double . is Na N ( std Parallel1 ) ) { properties . set Property ( _ STR ,  Double . to String ( std Parallel1 ) ) ; } if ( !  Double . is Na N ( std Parallel2 ) ) { properties . set Property ( _ STR ,  Double . to String ( std Parallel2 ) ) ; } if ( !  Double . is Na N ( natural Origin Lon ) ) { properties . set Property ( _ STR ,  Double . to String ( natural Origin Lon ) ) ; } if ( !  Double . is Na N ( natural Origin Lat ) ) { properties . set Property ( _ STR ,  Double . to String ( natural Origin Lat ) ) ; } if ( !  Double . is Na N ( false Origin Lon ) ) { properties . set Property ( _ STR ,  Double . to String ( false Origin Lon ) ) ; } if ( !  Double . is Na N ( false Origin Lat ) ) { properties . set Property ( _ STR ,  Double . to String ( false Origin Lat ) ) ; } if ( !  Double . is Na N ( false Easting ) ) { properties . set Property ( _ STR ,  Double . to String ( false Easting ) ) ; } if ( !  Double . is Na N ( false Northing ) ) { properties . set Property ( _ STR ,  Double . to String ( false Northing ) ) ; } if ( !  Double . is Na N ( center Easting ) ) { properties . set Property ( _ STR ,  Double . to String ( center Easting ) ) ; } if ( !  Double . is Na N ( center Northing ) ) { properties . set Property ( _ STR ,  Double . to String ( center Northing ) ) ; } if ( !  Double . is Na N ( center Lon ) ) { properties . set Property ( _ STR ,  Double . to String ( center Lon ) ) ; } if ( !  Double . is Na N ( center Lat ) ) { properties . set Property ( _ STR ,  Double . to String ( center Lat ) ) ; } if ( !  Double . is Na N ( scale At Natural Origin ) ) { properties . set Property ( _ STR ,  Double . to String ( scale At Natural Origin ) ) ; } if ( !  Double . is Na N ( scale At Center ) ) { properties . set Property ( _ STR ,  Double . to String ( scale At Center ) ) ; } if ( !  Double . is Na N ( azimuth ) ) { properties . set Property ( _ STR ,  Double . to String ( azimuth ) ) ; } if ( !  Double . is Na N ( straight Vert Pole Lon ) ) { properties . set Property ( _ STR ,  Double . to String ( straight Vert Pole Lon ) ) ; } if ( gcs Citation != null ) { properties . set Property ( _ STR , gcs Citation ) ; } if ( pcs Citation != null ) { properties . set Property ( _ STR , pcs Citation ) ; } }
public static double gamma ( double x ) { double  P [ ] = { _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM } ; double  Q [ ] = { - _ NUM , _ NUM , - _ NUM , _ NUM , _ NUM , - _ NUM , _ NUM , _ NUM } ; double p , z ; int i ; double q =  Math . abs ( x ) ; if ( q > _ NUM ) { if ( x < _ NUM ) { p =  Math . floor ( q ) ; if ( p == q ) throw new  Arithmetic Exception ( _ STR ) ; i = ( int ) p ; z = q - p ; if ( z > _ NUM ) { p += _ NUM ; z = q - p ; } z = q *  Math . sin (  Math .  PI * z ) ; if ( z == _ NUM ) throw new  Arithmetic Exception ( _ STR ) ; z =  Math . abs ( z ) ; z =  Math .  PI / ( z * stirling Formula ( q ) ) ; return - z ; } else { return stirling Formula ( x ) ; } } z = _ NUM ; while ( x >= _ NUM ) { x -= _ NUM ; z *= x ; } while ( x < _ NUM ) { if ( x == _ NUM ) { throw new  Arithmetic Exception ( _ STR ) ; } else if ( x > - _ NUM ) { return ( z / ( ( _ NUM + _ NUM * x ) * x ) ) ; } z /= x ; x += _ NUM ; } while ( x < _ NUM ) { if ( x == _ NUM ) { throw new  Arithmetic Exception ( _ STR ) ; } else if ( x < _ NUM ) { return ( z / ( ( _ NUM + _ NUM * x ) * x ) ) ; } z /= x ; x += _ NUM ; } if ( ( x == _ NUM ) || ( x == _ NUM ) ) return z ; x -= _ NUM ; p = polevl ( x ,  P , _ NUM ) ; q = polevl ( x ,  Q , _ NUM ) ; return z * p / q ; }
public void start ( ) { start Time =  System . current Time Millis ( ) ; }
public static  Object evaluate Expression To Object ( final  Value Expression value Expression ) { if ( value Expression == null ) { return null ; } return  JKJsf Util . evaluate Expression To Object ( value Expression . get Expression String ( ) ) ; }
@  Override public synchronized void close ( ) throws  IOException { buffer = null ; is Closed = _ BOOL ; notify All ( ) ; }
protected final void add Section Internal ( int position ,  Section section ) { sections . add ( position , section ) ; }
public static  Genome Relationships load (  Buffered Reader reader ) throws  IOException { final  Genome Relationships ped = new  Genome Relationships ( ) ;  String line ; while ( ( line = reader . read Line ( ) ) != null ) { line = line . trim ( ) ; if ( line . starts With ( _ STR ) || line . matches ( _ STR ) ) { continue ; } parse Ped Line ( ped , line ) ; } return ped ; }
public static double [ ] lprefc2lpc ( double [ ] k ) { int p = k . length ; double [ ] [ ]  A = new double [ p ] [ ] ; int i , j ; for ( i = _ NUM ; i <= p ; i ++ ) {  A [ i - _ NUM ] = new double [ i ] ;  A [ i - _ NUM ] [ i - _ NUM ] = k [ i - _ NUM ] ; for ( j = _ NUM ; j < i ; j ++ )  A [ i - _ NUM ] [ j - _ NUM ] =  A [ i - _ NUM ] [ j - _ NUM ] - k [ i - _ NUM ] *  A [ i - _ NUM ] [ i - j - _ NUM ] ; } double [ ] one Minus A = new double [ p + _ NUM ] ; one Minus A [ _ NUM ] = _ NUM ;  System . arraycopy (  A [ p - _ NUM ] , _ NUM , one Minus A , _ NUM , p ) ; return one Minus A ; }
public static boolean assert Equals ( final double a , final double b ) { if (  Double . is Na N ( a ) &&  Double . is Na N ( b ) ) { return _ BOOL ; } if ( a == b ) { return _ BOOL ; } throw new  Exam Exception ( a + _ STR + b ) ; }
private static  String fix Get Fields (  String js ) { final  Pattern pat =  Pattern . compile ( _ STR ) ; final  Matcher mat = pat . matcher ( js ) ; while ( mat . find ( ) ) { final  String s = mat . group ( ) ; js = js . replace ( s , s . char At ( _ NUM ) + _ STR ) ; } js = js . replace ( _ STR , _ STR ) ; return js ; }
protected boolean is Single Line Comment (  String line ) { return line . starts With ( _ STR ) ; }
private  List <  Volume > create Block Volumes (  String volume Name , int num Volumes ,  URI storage System ) {  List <  Volume > volumes = new  Array List <  Volume > ( ) ; for ( int i = _ NUM ; i <= num Volumes ; i ++ ) {  Volume volume = new  Volume ( ) ;  URI volume URI =  URIUtil . create Id (  Volume . class ) ; block Volume URIs . add ( volume URI ) ; volume . set Id ( volume URI ) ; volume . set Label ( volume Name + i ) ; volume . set Storage Controller ( storage System ) ; _db Client . create Object ( volume ) ; volumes . add ( volume ) ; } return volumes ; }
static public <  T > void reset ( @  Nonnull  Class <  T > type ) { log . debug ( _ STR , type . get Name ( ) ) ; manager Lists . put ( type , new  Array List < > ( ) ) ; }
public void cmd (  String cmd ) { cmd ( new  File (  System . get Property ( _ STR ) ) , cmd ) ; }
public void merge Pre Condition ( ) { if ( pre Condition != null && condition Block != null ) {  List <  Insn Node > cond Insns = condition Block . get Instructions ( ) ;  List <  Insn Node > pre Cond Insns = pre Condition . get Instructions ( ) ; pre Cond Insns . add All ( cond Insns ) ; cond Insns . clear ( ) ; cond Insns . add All ( pre Cond Insns ) ; pre Cond Insns . clear ( ) ; pre Condition = null ; } }
public boolean check Error ( ) { flush ( ) ; synchronized ( lock ) { return m Io Error ; } }
public  List <  Pdf Document > extract Page Ranges (  List <  Page Range > page Ranges ) {  List <  Pdf Document > split Documents = new  Array List < > ( ) ; for (  Page Range current Page Range : page Ranges ) {  Pdf Document current Pdf Document = create Pdf Document ( current Page Range ) ; split Documents . add ( current Pdf Document ) ; pdf Document . copy Pages To ( current Page Range . get All Pages ( ) , current Pdf Document ) ; } return split Documents ; }
private void init From Auth Header (  String auth Header ) { this . auth Header = auth Header ; if ( auth Header == null ) throw new  Null Pointer Exception ( _ STR ) ;  Matcher auth Matcher =  SCHEME_ PATTERN . matcher ( auth Header ) ; if ( ! auth Matcher . matches ( ) ) { throw new  Illegal State Exception ( _ STR + auth Header ) ; } scheme = auth Matcher . group ( _ NUM ) ; if ( auth Matcher . group Count ( ) > _ NUM ) {  Matcher param Matcher =  PARAM_ PATTERN . matcher ( auth Matcher . group ( _ NUM ) ) ; while ( param Matcher . find ( ) ) {  String value = param Matcher . group ( _ NUM ) ; if ( value == null ) { value = param Matcher . group ( _ NUM ) ; } parameters . put ( param Matcher . group ( _ NUM ) , value ) ; } } }
public  IMFError Logger Impl ( ) { this . error Objects =  Collections . synchronized Set ( new  Hash Set <  Error Logger .  Error Object > ( ) ) ; }
public static  String read Line ( ) {  String line ; try { line = scanner . next Line ( ) ; } catch (  No Such Element Exception e ) { line = null ; } return line ; }
public static byte [ ] decode (  String s ) { return decode ( s ,  NO_ OPTIONS ) ; }
public void test Case6 ( ) { byte a Bytes [ ] = { _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM } ; byte b Bytes [ ] = { _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM } ; int a Sign = _ NUM ; int b Sign = - _ NUM ; byte r Bytes [ ] = { - _ NUM , - _ NUM , - _ NUM , _ NUM , - _ NUM , - _ NUM , - _ NUM , - _ NUM , _ NUM , - _ NUM , - _ NUM , - _ NUM , _ NUM , - _ NUM , _ NUM , _ NUM , _ NUM , - _ NUM , - _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM } ;  Big Integer a Number = new  Big Integer ( a Sign , a Bytes ) ;  Big Integer b Number = new  Big Integer ( b Sign , b Bytes ) ;  Big Integer result = a Number . multiply ( b Number ) ; byte res Bytes [ ] = new byte [ r Bytes . length ] ; res Bytes = result . to Byte Array ( ) ; for ( int i = _ NUM ; i < res Bytes . length ; i ++ ) { assert True ( res Bytes [ i ] == r Bytes [ i ] ) ; } assert Equals ( _ STR , - _ NUM , result . signum ( ) ) ; }
public static  List <  String > match Description Classes (  String desc ) {  String pattern = _ STR ;  Pattern pat =  Pattern . compile ( pattern ) ;  Matcher m = pat . matcher ( desc ) ;  List <  String > matches = new  Array List <  String > ( ) ; while ( m . find ( ) ) { matches . add ( m . group ( ) ) ; } return matches ; }
public  Struct Storage Stat [ ] list Storages (  Tracker Server tracker Server ,  String group Name ,  String storage Ip Addr ) throws  IOException { byte [ ] header ; byte [ ] b Group Name ; byte [ ] bs ; int len ; boolean b New Connection ;  Socket tracker Socket ; if ( tracker Server == null ) { tracker Server = get Connection ( ) ; if ( tracker Server == null ) { return null ; } b New Connection = _ BOOL ; } else { b New Connection = _ BOOL ; } tracker Socket = tracker Server . get Socket ( ) ;  Output Stream out = tracker Socket . get Output Stream ( ) ; try { bs = group Name . get Bytes (  Client Global . g_charset ) ; b Group Name = new byte [  Proto Common .  FDFS_ GROUP_ NAME_ MAX_ LEN ] ; if ( bs . length <=  Proto Common .  FDFS_ GROUP_ NAME_ MAX_ LEN ) { len = bs . length ; } else { len =  Proto Common .  FDFS_ GROUP_ NAME_ MAX_ LEN ; }  Arrays . fill ( b Group Name , ( byte ) _ NUM ) ;  System . arraycopy ( bs , _ NUM , b Group Name , _ NUM , len ) ; int ip Addr Len ; byte [ ] b Ip Addr ; if ( storage Ip Addr != null && storage Ip Addr . length ( ) > _ NUM ) { b Ip Addr = storage Ip Addr . get Bytes (  Client Global . g_charset ) ; if ( b Ip Addr . length <  Proto Common .  FDFS_ IPADDR_ SIZE ) { ip Addr Len = b Ip Addr . length ; } else { ip Addr Len =  Proto Common .  FDFS_ IPADDR_ SIZE - _ NUM ; } } else { b Ip Addr = null ; ip Addr Len = _ NUM ; } header =  Proto Common . pack Header (  Proto Common .  TRACKER_ PROTO_ CMD_ SERVER_ LIST_ STORAGE ,  Proto Common .  FDFS_ GROUP_ NAME_ MAX_ LEN + ip Addr Len , ( byte ) _ NUM ) ; byte [ ] whole Pkg = new byte [ header . length + b Group Name . length + ip Addr Len ] ;  System . arraycopy ( header , _ NUM , whole Pkg , _ NUM , header . length ) ;  System . arraycopy ( b Group Name , _ NUM , whole Pkg , header . length , b Group Name . length ) ; if ( ip Addr Len > _ NUM ) {  System . arraycopy ( b Ip Addr , _ NUM , whole Pkg , header . length + b Group Name . length , ip Addr Len ) ; } out . write ( whole Pkg ) ;  Proto Common .  Recv Package Info pkg Info =  Proto Common . recv Package ( tracker Socket . get Input Stream ( ) ,  Proto Common .  TRACKER_ PROTO_ CMD_ RESP , - _ NUM ) ; this . errno = pkg Info . errno ; if ( pkg Info . errno != _ NUM ) { return null ; }  Proto Struct Decoder <  Struct Storage Stat > decoder = new  Proto Struct Decoder <  Struct Storage Stat > ( ) ; return decoder . decode ( pkg Info . body ,  Struct Storage Stat . class ,  Struct Storage Stat . get Fields Total Size ( ) ) ; } catch (  IOException ex ) { if ( ! b New Connection ) { try { tracker Server . close ( ) ; } catch (  IOException ex1 ) { ex1 . print Stack Trace ( ) ; } } throw ex ; } catch (  Exception ex ) { ex . print Stack Trace ( ) ; this . errno =  Proto Common .  ERR_ NO_ EINVAL ; return null ; } finally { if ( b New Connection ) { try { tracker Server . close ( ) ; } catch (  IOException ex1 ) { ex1 . print Stack Trace ( ) ; } } } }
@  Override public  UUID create Exit Node (  UUID parent Node ) {  UUID uuid =  UUID . random UUID ( ) ; graph Server . add Vertex ( uuid ) ; graph Server . add Edge ( parent Node , uuid ) ; exit Node Map . put ( uuid , parent Node ) ; return uuid ; }
public void delivery Complete ( final  IMqtt Delivery Token token ) { logger . trace ( _ STR , token . get Message Id ( ) ) ; }
public void add Module (  Module module ) { module . setup Module ( new  Module Context Impl ( ) ) ; modules . add ( module ) ; }
public static byte [ ] to Byte Array (  Bitmap bitmap ) {  Byte Array Output Stream output Stream = new  Byte Array Output Stream ( ) ; bitmap . compress (  Bitmap .  Compress Format .  PNG , _ NUM , output Stream ) ; return output Stream . to Byte Array ( ) ; }
public static  String escape Special Characters (  String txt ) { if ( txt == null ) { return txt ; } int len = txt . length ( ) ; if ( len == _ NUM ) { return txt ; }  String Builder buf = new  String Builder ( ) ; for ( int i = _ NUM ; i < len ; i ++ ) { char c = txt . char At ( i ) ; switch ( c ) { case _ STR : buf . append ( _ STR ) ; break ; case _ STR : buf . append ( _ STR ) ; break ; case _ STR : buf . append ( _ STR ) ; break ; case _ STR : buf . append ( _ STR ) ; break ; case _ STR : buf . append ( _ STR ) ; break ; case _ STR : buf . append ( _ STR ) ; break ; case _ STR : buf . append ( _ STR ) ; break ; default : buf . append ( c ) ; } } return buf . to String ( ) ; }
protected int hash (  Object key1 ,  Object key2 ) { int h = _ NUM ; if ( key1 != null ) { h ^= key1 . hash Code ( ) ; } if ( key2 != null ) { h ^= key2 . hash Code ( ) ; } h += ~ ( h << _ NUM ) ; h ^= ( h > > > _ NUM ) ; h += ( h << _ NUM ) ; h ^= ( h > > > _ NUM ) ; return h ; }
public void flush ( ) { flush ( _ BOOL ) ; }
public void close ( ) { for (  Entry entry : entry List ) { entry . close ( ) ; } entry List . clear ( ) ; }
public void add Slide ( @  Non Null  Fragment fragment ) { fragments . add ( fragment ) ; m Pager Adapter . notify Data Set Changed ( ) ; }
Delete Prev Char Action ( ) { super ( delete Prev Char Action ) ; }
public boolean content Equals (  Char Sequence chars ) { if ( chars == null ) return _ BOOL ; if ( this . _length != chars . length ( ) ) return _ BOOL ; for ( int i = _length , j = _offset + _length ; -- i >= _ NUM ; ) { if ( _array [ -- j ] != chars . char At ( i ) ) return _ BOOL ; } return _ BOOL ; }
public void flush ( ) throws  IOException { stream . flush ( ) ; }
@  Override public void close ( ) throws  Exception {  Eclipse Starter . shutdown ( ) ; }
@  Suppress Warnings ( _ STR ) public  Data Response paginate List (  Map <  String ,  String > request Params ,  Query query ,  String default Sort ,  Map <  String ,  Query Property > properties ) { return paginate List ( request Params , null , query , default Sort , properties ) ; }
public static final boolean is Oracle JCEProvider (  String provider Name ) { return provider Name != null && ( provider Name . equals ( _ STR ) || provider Name . equals ( _ STR ) || provider Name . equals ( _ STR ) || provider Name . starts With ( _ STR ) ) ; }
public static  Stream Timestamp now ( ) { return now ( _ STR ) ; }
public synchronized void remove (  String item ) { int index = items . index Of ( item ) ; if ( index < _ NUM ) { throw new  Illegal Argument Exception ( _ STR + item + _ STR ) ; } else { remove ( index ) ; } }
public void write Field (  String name , int value ) throws java . io .  IOException { write Field ( name ,  Integer . to String ( value ) ) ; }
public byte [ ] encode Data ( byte [ ] data , int num Error Correction Bytes ) throws  Data Too Large Exception { if ( data == null || data . length == _ NUM ) { return null ; } if ( ( data . length + num Error Correction Bytes ) > _ NUM ) { throw new  Data Too Large Exception ( _ STR ) ; } int total Bytes = num Error Correction Bytes + data . length ; int [ ] data Ints = new int [ total Bytes ] ; for ( int i = _ NUM ; i < data . length ; i ++ ) { data Ints [ i ] = data [ i ] & _ NUM ; } encoder . encode ( data Ints , num Error Correction Bytes ) ;  Byte Array Output Stream bos = new  Byte Array Output Stream ( ) ; for ( int i : data Ints ) { bos . write ( i ) ; } return bos . to Byte Array ( ) ; }
public static  Array List <  String > convert String Array To Array List (  String [ ] string Array ) { if ( string Array != null && string Array . length > _ NUM ) { return new  Array List < > (  Arrays . as List ( string Array ) ) ; } else { return null ; } }
private void clear ( ) { stop ( ) ; for (  View view : m Views ) { remove View ( view ) ; } m Views . clear ( ) ; }
public boolean is Java Library Class ( ) { if ( name . starts With ( _ STR ) || name . starts With ( _ STR ) || name . starts With ( _ STR ) || name . starts With ( _ STR ) || name . starts With ( _ STR ) || name . starts With ( _ STR ) ) return _ BOOL ; return _ BOOL ; }
boolean add (  String src Filename , int src Line , int dst Line , boolean is Prefer Last ) { if ( _src Filename != null && ( ! _src Filename . equals ( src Filename ) || src Filename == null ) ) return _ BOOL ; if ( dst Line <= _dst Line ) { if ( ! is Prefer Last ) return _ BOOL ; else if ( _dst Increment == _ NUM && _repeat == _ NUM ) { _src Line = src Line ; return _ BOOL ; } else if ( _repeat > _ NUM ) { _repeat -- ; return _ BOOL ; } else if ( _dst Increment > _ NUM ) { _dst Increment -- ; return _ BOOL ; } else return _ BOOL ; } if ( src Line == _src Line ) { _dst Increment = dst Line - _dst Line + _ NUM ; return _ BOOL ; } else if ( dst Line - _dst Line == ( src Line - _src Line ) * _dst Increment ) { _repeat = src Line - _src Line + _ NUM ; return _ BOOL ; } else if ( src Line == _src Line + _ NUM && _repeat == _ NUM ) { _dst Increment = dst Line - _dst Line ; return _ BOOL ; } return _ BOOL ; }
public void add Notification (  Notification notification ) { notification Vector . add Element ( notification ) ; }
public boolean has Attributes ( ) { return attributes != null && ! attributes . is Empty ( ) ; }
private void generate (  Class < ? extends  Message > cls ) throws  Exception { assert cls != null ; if ( cls . is Interface ( ) ) return ; if ( cls . is Annotation Present (  Ignite Code Generating Fail . class ) ) throw new  Illegal State Exception ( _ STR + cls . get Name ( ) ) ; write . clear ( ) ; read . clear ( ) ; fields = new  Array List < > ( ) ;  Field [ ] declared Fields = cls . get Declared Fields ( ) ; for (  Field field : declared Fields ) { int mod = field . get Modifiers ( ) ; if ( ! is Static ( mod ) && ! is Transient ( mod ) && ! field . is Annotation Present (  Grid Direct Transient . class ) ) fields . add ( field ) ; }  Collections . sort ( fields ,  FIELD_ CMP ) ; int state = start State ( cls ) ; total Field Cnt = state + fields . size ( ) ; indent = _ NUM ; boolean has Super = cls . get Superclass ( ) !=  Object . class ; start ( write , has Super ? _ STR : null , _ BOOL ) ; start ( read , has Super ? _ STR : null , _ BOOL ) ; indent ++ ; for (  Field field : fields ) process Field ( field , state ++ ) ; indent -- ; finish ( write , null ) ; finish ( read , cls . get Simple Name ( ) ) ; }
public  Ansible Runner extra Params (  String params ) { if ( params != null && params . length ( ) > _ NUM ) { extra Params = params ; } return this ; }
protected static  String create Subset Prefix ( ) {  String Builder s = new  String Builder ( _ STR ) ; for ( int k = _ NUM ; k < _ NUM ; ++ k ) { s . append ( ( char ) (  Math . random ( ) * _ NUM + _ STR ) ) ; } return s + _ STR ; }
protected int draw Host Address ( int host Range [ ] ) { if ( host Range [ _ NUM ] == host Range [ _ NUM ] ) { return host Range [ _ NUM ] ; } return host Range [ _ NUM ] + rng . next Int ( host Range [ _ NUM ] - host Range [ _ NUM ] ) ; }
public static  String grab Name (  String signature ) {  Matcher matcher = sig RE . matcher ( signature ) ; boolean b = matcher . matches ( ) ; if ( ! b && matcher . group Count ( ) != _ NUM ) logger . error ( _ STR , signature ) ; return matcher . group ( _ NUM ) ; }
public void insert (  Event Bean the Event ) { events . add ( the Event ) ;  Event Bean [ ] old Events = null ; if ( events . size ( ) > depth ) { old Events = new  Event Bean [ ] { events . remove ( _ NUM ) } ; } for (  View child : child Views ) { child . update ( new  Event Bean [ ] { the Event } , old Events ) ; } }
public  V put (  K key ,  V value ) { final int hash ; int index ; if ( key == null ) { hash = _ NUM ; index = index Of Null ( ) ; } else { hash = key . hash Code ( ) ; index = index Of ( key , hash ) ; } if ( index >= _ NUM ) { index = ( index << _ NUM ) + _ NUM ; final  V old = (  V ) m Array [ index ] ; m Array [ index ] = value ; return old ; } index = ~ index ; if ( m Size >= m Hashes . length ) { final int n = m Size >= (  BASE_ SIZE * _ NUM ) ? ( m Size + ( m Size > > _ NUM ) ) : ( m Size >=  BASE_ SIZE ? (  BASE_ SIZE * _ NUM ) :  BASE_ SIZE ) ; if (  DEBUG )  Log . d (  TAG , _ STR + m Hashes . length + _ STR + n ) ; final int [ ] ohashes = m Hashes ; final  Object [ ] oarray = m Array ; alloc Arrays ( n ) ; if ( m Hashes . length > _ NUM ) { if (  DEBUG )  Log . d (  TAG , _ STR + m Size + _ STR ) ;  System . arraycopy ( ohashes , _ NUM , m Hashes , _ NUM , ohashes . length ) ;  System . arraycopy ( oarray , _ NUM , m Array , _ NUM , oarray . length ) ; } free Arrays ( ohashes , oarray , m Size ) ; } if ( index < m Size ) { if (  DEBUG )  Log . d (  TAG , _ STR + index + _ STR + ( m Size - index ) + _ STR + ( index + _ NUM ) ) ;  System . arraycopy ( m Hashes , index , m Hashes , index + _ NUM , m Size - index ) ;  System . arraycopy ( m Array , index << _ NUM , m Array , ( index + _ NUM ) << _ NUM , ( m Size - index ) << _ NUM ) ; } m Hashes [ index ] = hash ; m Array [ index << _ NUM ] = key ; m Array [ ( index << _ NUM ) + _ NUM ] = value ; m Size ++ ; return null ; }
public void put Int ( long pos , int val ) { unsafe . put Int ( pos + addr , val ) ; }
public boolean recreate RSet Step (  URI rp System Id ,  List <  URI > volume Ids ,  Map <  String ,  Recreate Replication Set Request Params > rset Params ,  String token ) throws  Internal Exception {  List <  String > replication Set Names = new  Array List <  String > ( ) ; try {  Protection System rp System = _db Client . query Object (  Protection System . class , rp System Id ) ; for (  URI volume Id : volume Ids ) {  Volume volume = _db Client . query Object (  Volume . class , volume Id ) ; replication Set Names . add ( volume . get RSet Name ( ) ) ; }  Recover Point Client rp =  RPHelper . get Recover Point Client ( rp System ) ; _log . info ( _ STR ) ; try {  Thread . sleep ( _ NUM ) ; } catch (  Interrupted Exception e ) { _log . warn ( _ STR ) ; } rp . recreate Replication Sets ( rset Params ) ;  Workflow Step Completer . step Succeded ( token ) ; } catch (  Exception e ) { _log . error (  String . format ( _ STR , replication Set Names . to String ( ) ) ) ; return step Failed ( token , e , _ STR ) ; } return _ BOOL ; }
public  T next ( ) { if ( enable ) { if ( done ) { return null ; } if ( next == null ) has Next ( ) ; if ( next != null ) {  T result = (  T ) next ; next = null ; return result ; } else { return null ; } } else return iterator . next ( ) ; }
public  String warehouse (  Properties ctx , int  Window No ,  Grid Tab m Tab ,  Grid Field m Field ,  Object value ) { if ( is Callout Active ( ) ) return _ STR ;  Integer  M_ Warehouse_ ID = (  Integer ) value ; if (  M_ Warehouse_ ID == null ||  M_ Warehouse_ ID . int Value ( ) == _ NUM ) return _ STR ;  String sql = _ STR + _ STR + _ STR + _ STR ;  Prepared Statement pstmt = null ;  Result Set rs = null ; try { pstmt =  DB . prepare Statement ( sql , null ) ; pstmt . set Int ( _ NUM ,  M_ Warehouse_ ID . int Value ( ) ) ; rs = pstmt . execute Query ( ) ; if ( rs . next ( ) ) {  Integer ii = new  Integer ( rs . get Int ( _ NUM ) ) ; int  AD_ Org_ ID =  Env . get Context As Int ( ctx ,  Window No , _ STR ) ; if (  AD_ Org_ ID != ii . int Value ( ) ) m Tab . set Value ( _ STR , ii ) ; ii = new  Integer ( rs . get Int ( _ NUM ) ) ; if ( rs . was Null ( ) )  Env . set Context ( ctx ,  Window No , _ NUM , _ STR , null ) ; else { log . config ( _ STR + ii ) ;  Env . set Context ( ctx ,  Window No , _ STR , ii . int Value ( ) ) ; } } } catch (  SQLException e ) { log . log (  Level .  SEVERE , sql , e ) ; return e . get Localized Message ( ) ; } finally {  DB . close ( rs , pstmt ) ; } return _ STR ; }
public final int read Int ( ) throws java . io .  IOException { read Fully ( scratch , _ NUM , _ NUM ) ; return ( ( ( scratch [ _ NUM ] & _ NUM ) << _ NUM ) | ( ( scratch [ _ NUM ] & _ NUM ) << _ NUM ) | ( ( scratch [ _ NUM ] & _ NUM ) << _ NUM ) | ( ( scratch [ _ NUM ] & _ NUM ) << _ NUM ) ) ; }
public void test Table Meta Data ( ) throws  Exception {  Statement stmt = con . create Statement (  Result Set .  TYPE_ SCROLL_ INSENSITIVE ,  Result Set .  CONCUR_ READ_ ONLY ) ;  Result Set rs = stmt . execute Query ( _ STR ) ; assert Not Null ( rs ) ;  Result Set Meta Data rsmd = rs . get Meta Data ( ) ;  Assert . assert Equals ( _ STR , rsmd . get Catalog Name ( _ NUM ) ) ;  Assert . assert Equals ( _ STR , rsmd . get Schema Name ( _ NUM ) ) ;  Assert . assert Equals ( _ STR , rsmd . get Table Name ( _ NUM ) ) ; stmt . close ( ) ; rs . close ( ) ; }
public  String global Info ( ) { return _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR ; }
private void handle Json Create Quotation (  Request And Response request And Response ) throws  IOException ,  Servlet Exception { request And Response . set Response Content Type Json ( ) ;  String url ;  String title ;  String quotation ;  String note ;  String session Id ; try { final  Json Node Helper json = get Json Node ( request And Response ) ; url = json . get String (  Db Logic .  Constants . url ) ; title = json . get String (  Db Logic .  Constants . title ) ; quotation = json . get String (  Db Logic .  Constants . quotation ) ; note = json . get String (  Db Logic .  Constants . note ) ; session Id = json . get String ( _ STR ) ; } catch ( final  IOException e ) { return Json400 ( request And Response , servlet Text . error Json ( ) ) ; return ; } if ( !  Entry Attribute Validator . is Note Valid ( note ) ) { return Json400 ( request And Response , servlet Text . error Note Is Invalid ( ) ) ; return ; } if ( !  Entry Attribute Validator . is Quotation Valid ( quotation ) ) { return Json400 ( request And Response , servlet Text . error Quotation Is Invalid ( ) ) ; return ; } if ( !  Entry Attribute Validator . is Url Valid ( url ) ) { return Json400 ( request And Response , servlet Text . error Url Is Invalid ( ) ) ; return ; } if ( !  Entry Attribute Validator . is Source Title Valid ( title ) ) { return Json400 ( request And Response , servlet Text . error Title Is Invalid ( ) ) ; return ; } final  Errors errors = new  Errors ( ) ; try { final  Long time = new  Long (  System . current Time Millis ( ) ) ;  String user Id = null ; if ( session Manager != null ) { final  Http Session session = session Manager . get Session ( session Id ) ; if ( session != null && session . get Attribute ( session User Id Attribute ) != null ) { user Id = (  String ) session . get Attribute ( session User Id Attribute ) ; } } final  User user = db Logic . get User By Id ( user Id ) ; if ( user == null ) { return Json400 ( request And Response , servlet Text . error No Account Found ( ) ) ; return ; } if ( user . get Is Account Closed ( ) ) { return Json400 ( request And Response , servlet Text . error Account Is Closed ( ) ) ; return ; } final  Entry source = db Logic . update Or Create Source ( user , null , url , title , time , time , is User An Admin ( request And Response ) , errors ) ; if ( source == null ) { return Json400 ( request And Response , errors ) ; return ; } final  Entry entry = db Logic . create Entry Quotation ( user , source , quotation , note , time , is User An Admin ( request And Response ) , errors ) ; if ( entry == null ) { return Json400 ( request And Response , errors ) ; return ; } request And Response . print ( _ STR + _ STR + entry . get Id ( ) + _ STR + _ STR + source . get Id ( ) + _ STR ) ; db Logic . commit ( ) ; } catch ( final  Persistence Exception e ) { logger . log (  Level .  INFO , _ STR , e ) ; return Json500 ( request And Response , servlet Text . error Internal Database ( ) ) ; } }
public  Object [ ] build Parameters (  Object [ ] first Parameters ,  Method method ,  Class < ? extends  Annotation > annotation Type ) { int parameters Length = method . get Parameter Types ( ) . length ; if ( first Parameters . length > _ NUM && parameters Length < _ NUM ) { throw new  Repository Method Exception (  String . format ( _ STR , annotation Type ) ) ; } int parameters To Resolve = parameters Length - first Parameters . length ;  Object [ ] additional Parameters = new  Object [ parameters To Resolve ] ; for ( int i = first Parameters . length ; i < parameters Length ; i ++ ) { additional Parameters [ i - first Parameters . length ] = parameter Provider . provide ( method , i ) ; } return concatenate ( first Parameters , additional Parameters ) ; }
public static boolean is Alpha Char (  String text , int index ) { char c = text . char At ( index ) ; return ( c >= _ STR && c <= _ STR ) || ( c >= _ STR && c <= _ STR ) || ( c >= _ STR && c <= _ STR ) ; }
public  IOException check Certificate ( ) {  SSLSocket Factory factory = context . get Socket Factory ( ) ; try {  SSLSocket socket = (  SSLSocket ) factory . create Socket ( host , port ) ; socket . set So Timeout ( _ NUM ) ; socket . start Handshake ( ) ; socket . close ( ) ; return null ; } catch (  IOException e ) { return e ; } }
int read Char ( ) throws  IOException { int ch = read ( ) ; if ( ch == _ STR || ch < _ NUM ) { _peek = ch ; return - _ NUM ; } if ( ch == _ STR ) { ch = read ( ) ; if ( ch == _ STR ) { ch = read ( ) ; if ( ch >= _ STR && ch <= _ STR ) { int v = _ NUM ; for ( ; ch >= _ STR && ch <= _ STR ; ch = read ( ) ) { v = _ NUM * v + ch - _ STR ; } if ( ch != _ STR ) throw error ( _ STR + ( char ) ch ) ; return ( char ) v ; } else throw error ( _ STR + ( char ) ch ) ; } else { _entity Buffer . set Length ( _ NUM ) ; for ( ; ch >= _ STR && ch <= _ STR ; ch = read ( ) ) _entity Buffer . append ( ( char ) ch ) ;  String entity = _entity Buffer . to String ( ) ; if ( ch != _ STR ) throw expected Char ( _ STR , ch ) ; if ( entity . equals ( _ STR ) ) return _ STR ; else if ( entity . equals ( _ STR ) ) return _ STR ; else if ( entity . equals ( _ STR ) ) return _ STR ; else if ( entity . equals ( _ STR ) ) return _ STR ; else if ( entity . equals ( _ STR ) ) return _ STR ; else throw new  Burlap Protocol Exception ( _ STR + entity + _ STR + ( char ) ch + _ STR ) ; } } else if ( ch < _ NUM ) return ( char ) ch ; else if ( ( ch & _ NUM ) == _ NUM ) { int ch1 = read ( ) ; int v = ( ( ch & _ NUM ) << _ NUM ) + ( ch1 & _ NUM ) ; return ( char ) v ; } else if ( ( ch & _ NUM ) == _ NUM ) { int ch1 = read ( ) ; int ch2 = read ( ) ; int v = ( ( ch & _ NUM ) << _ NUM ) + ( ( ch1 & _ NUM ) << _ NUM ) + ( ch2 & _ NUM ) ; return ( char ) v ; } else throw new  Burlap Protocol Exception ( _ STR ) ; }
public int hash Code ( ) { return name . hash Code ( ) ^ ( value == null ? _ NUM : value . hash Code ( ) ) ; }
public  Command checkout Command ( ) throws  Interrupted Exception {  Command command = pool . poll ( ) ; if ( command == null ) { command = new  Command ( gondola , this , cmember ) ; } return command ; }
public static boolean is Object (  String desc ) { return desc . ends With ( _ STR ) ; }
public static void move End (  JScroll Pane pane ) {  JScroll Bar bar = pane . get Vertical Scroll Bar ( ) ; bar . set Value ( bar . get Maximum ( ) ) ; }
public void add (  String arg Name ,  String desc , int expected Number Of Arguments , boolean expect Dashed Arguments ) {  Arg new Arg = new  Arg ( arg Name , desc , expected Number Of Arguments , expect Dashed Arguments ) ; args . add ( new Arg ) ; if (  Debug . debugging ( _ STR ) ) {  Debug . output ( _ STR + arg Name ) ; } }
private boolean add If Absent (  E e ,  Object [ ] snapshot ) { final  Reentrant Lock lock = this . lock ; lock . lock ( ) ; try {  Object [ ] current = get Array ( ) ; int len = current . length ; if ( snapshot != current ) { int common =  Math . min ( snapshot . length , len ) ; for ( int i = _ NUM ; i < common ; i ++ ) if ( current [ i ] != snapshot [ i ] && eq ( e , current [ i ] ) ) return _ BOOL ; if ( index Of ( e , current , common , len ) >= _ NUM ) return _ BOOL ; }  Object [ ] new Elements =  Arrays . copy Of ( current , len + _ NUM ) ; new Elements [ len ] = e ; set Array ( new Elements ) ; return _ BOOL ; } finally { lock . unlock ( ) ; } }
public void add Model (  Model model ) { models . add ( model ) ; }
public static  Object deserialize ( byte [ ] data ) { try {  Byte Array Input Stream in = new  Byte Array Input Stream ( data ) ;  Object Input Stream is = new  Object Input Stream ( in ) ; return is . read Object ( ) ; } catch (  Throwable e ) { throw  Data Utils . new Illegal Argument Exception ( _ STR ,  Arrays . to String ( data ) , e ) ; } }
public static double prob To Log Odds ( double prob ) { if ( gr ( prob , _ NUM ) || ( sm ( prob , _ NUM ) ) ) { throw new  Illegal Argument Exception ( _ STR + _ STR + prob ) ; } double p =  SMALL + ( _ NUM - _ NUM *  SMALL ) * prob ; return  Math . log ( p / ( _ NUM - p ) ) ; }
public static  String [ ] create Fixed Random Strings ( int count ) {  String [ ] strings = new  String [ count ] ;  Random length Random = new  Random ( ) ; length Random . set Seed (  SEED ) ;  Random string Random = new  Random ( ) ; string Random . set Seed (  SEED ) ; for ( int i = _ NUM ; i < count ; i ++ ) { int next Length = length Random . next Int (  MAX_ LENGTH -  MIN_ LENGTH - _ NUM ) ; next Length +=  MIN_ LENGTH ; strings [ i ] =  Random String Utils . random ( next Length , _ NUM ,  CHARS . length , _ BOOL , _ BOOL ,  CHARS , string Random ) ; } return strings ; }
public void increment Applied ( ) { applied ++ ; }
public void expand (  Tree Path [ ] paths ) { for (  Tree Path path : paths ) { expand JTree Node ( data Tree , data Tree . get Model ( ) , path . get Last Path Component ( ) , data Tree . get Row For Path ( path ) , _ NUM ) ; } }
@  Suppress Warnings ( _ STR ) private <  T >  T read By Class (  Buffer Input < ? > buffer ) {  String name = buffer . read UTF8 ( ) ; if ( whitelist Required . get ( ) ) throw new  Serialization Exception ( _ STR + name ) ;  Class <  T > type = (  Class <  T > ) types . get ( name ) ; if ( type == null ) { try { type = (  Class <  T > )  Class . for Name ( name ) ; if ( type == null ) throw new  Serialization Exception ( _ STR ) ; types . put ( name , type ) ; } catch (  Class Not Found Exception e ) { throw new  Serialization Exception ( _ STR + name , e ) ; } }  Type Serializer <  T > serializer = get Serializer ( type ) ; if ( serializer == null ) throw new  Serialization Exception ( _ STR + name ) ; return serializer . read ( type , buffer , this ) ; }
public boolean is Empty ( ) { return nodes . is Empty ( ) ; }
public static void assert True ( boolean b ) { if ( ! b ) { throw Error ( null ) ; } }
DGCAck Handler (  UID id ) { this . id = id ; if ( id != null ) { assert ! id Table . contains Key ( id ) ; id Table . put ( id , this ) ; } }
public static boolean debugging (  String token ) { return  Debug .  On && ( debug All || dbg Table . contains Key ( token ) ) ; }
public  Composite Comparator (  Comparator [ ] cmp , boolean reverse ) { this ( cmp . length , reverse ) ;  System . arraycopy ( cmp , _ NUM , m_cmp , _ NUM , cmp . length ) ; m_size = cmp . length ; }
public void remove Directory Set (  Context context ,  String path ) {  Tiny DB tinydb = new  Tiny DB ( context ) ;  Array List <  String > file = tinydb . get List String ( _ STR ) ; file . remove ( path ) ; tinydb . put List String ( _ STR , file ) ; }
private boolean is Before End (  Fast Concurrent Skip List Map .  Node <  K ,  V > n ) { if ( n == null ) return _ BOOL ; if ( hi == null ) return _ BOOL ;  K k = n . key ; if ( k == null ) return _ BOOL ; int c = m . compare ( k , hi ) ; if ( c > _ NUM || ( c == _ NUM && ! hi Inclusive ) ) return _ BOOL ; return _ BOOL ; }
public void initialize Properties (  Properties properties ) {  Properties new Props = new  Properties ( ) ; new Props . put All ( system Config Props ) ; new Props . put All ( properties ) ; system Config Props = new Props ; }
private static void update Embedded Id Repo (  String org Name ,  String config Name ,  String entry ) throws  SMSException ,  SSOException {  SSOToken token =  Access Controller . do Privileged (  Admin Token Action . get Instance ( ) ) ;  Service Config Manager scm = new  Service Config Manager ( token ,  Id Constants .  REPO_ SERVICE , _ STR ) ;  Service Config sc = scm . get Organization Config ( org Name , null ) ; if ( sc != null ) {  Service Config sub Config = sc . get Sub Config ( config Name ) ; if ( sub Config != null ) {  Map <  String ,  Set <  String > > config Map = sub Config . get Attributes ( ) ;  Set <  String > vals = config Map . get ( _ STR ) ; vals . add ( entry ) ;  Hash Map <  String ,  Set <  String > > mp = new  Hash Map <  String ,  Set <  String > > ( _ NUM ) ; mp . put ( _ STR , vals ) ; sub Config . set Attributes ( mp ) ; } } }
public static  Description describe ( final char [ ] pin ) { if ( pin == null || pin . length == _ NUM ) { return new  Description ( _ NUM ,  Enum Set . none Of (  Character Class . class ) ) ; }  Enum Set <  Character Class > classes =  Enum Set . none Of (  Character Class . class ) ; for ( char ch : pin ) { classes . add (  Character Class . of ( ch ) ) ; } return new  Description ( pin . length , classes ) ; }
public static  String unquote (  String string ) { if ( string . starts With ( _ STR ) && string . ends With ( _ STR ) ) { string = string . substring ( _ NUM , string . length ( ) - _ NUM ) ; if ( ( string . index Of ( _ STR ) != - _ NUM ) || ( string . index Of ( _ STR ) != - _ NUM ) || ( string . index Of ( _ STR ) != - _ NUM ) || ( string . index Of ( _ STR ) != - _ NUM ) || ( string . index Of ( _ STR ) != - _ NUM ) || ( string . index Of ( _ STR ) != - _ NUM ) || ( string . index Of ( _ STR ) != - _ NUM ) || ( string . index Of ( _ STR ) != - _ NUM ) ) { string = unback Quote Chars ( string ) ; } } return string ; }
public  Shape paint Layer (  Graphics g , int offs0 , int offs1 ,  Shape bounds ,  JText Component c ,  View view ) {  Color color = get Color ( ) ; if ( color == null ) { g . set Color ( c . get Selection Color ( ) ) ; } else { g . set Color ( color ) ; }  Rectangle r ; if ( offs0 == view . get Start Offset ( ) && offs1 == view . get End Offset ( ) ) { if ( bounds instanceof  Rectangle ) { r = (  Rectangle ) bounds ; } else { r = bounds . get Bounds ( ) ; } } else { try {  Shape shape = view . model To View ( offs0 ,  Position .  Bias .  Forward , offs1 ,  Position .  Bias .  Backward , bounds ) ; r = ( shape instanceof  Rectangle ) ? (  Rectangle ) shape : shape . get Bounds ( ) ; } catch (  Bad Location Exception e ) { r = null ; } } if ( r != null ) { r . width =  Math . max ( r . width , _ NUM ) ; g . fill Rect ( r . x , r . y , r . width , r . height ) ; } return r ; }
synchronized void receive ( char one Char ) throws  IOException { if ( buffer == null ) { throw new  IOException ( _ STR ) ; } if ( last Reader != null && ! last Reader . is Alive ( ) ) { throw new  IOException ( _ STR ) ; } last Writer =  Thread . current Thread ( ) ; try { while ( buffer != null && out == in ) { notify All ( ) ; wait ( _ NUM ) ; if ( last Reader != null && ! last Reader . is Alive ( ) ) { throw new  IOException ( _ STR ) ; } } } catch (  Interrupted Exception e ) {  Io Utils . throw Interrupted Io Exception ( ) ; } if ( buffer == null ) { throw new  IOException ( _ STR ) ; } if ( in == - _ NUM ) { in = _ NUM ; } buffer [ in ++ ] = one Char ; if ( in == buffer . length ) { in = _ NUM ; } }
static final  Byte Buffer  Buffer To Byte Buffer ( final byte [ ] buffer , final  Byte Order order , final int start , final int len ) { final  Byte Buffer ret Buff =  Byte Buffer . wrap ( buffer , start , len ) ; ret Buff . order ( order ) ; return ret Buff ; }
static protected  String host From Uri Str (  String uri Str ) { debug Out ( _ STR + uri Str + _ STR ) ;  String host = null ;  URI uri ; try { uri = new  URI ( uri Str ) ; host = uri . get Host ( ) ; } catch (  URISyntax Exception e ) { debug Out ( e . get Message ( ) ) ; } return host ; }
public void reset ( ) { current Time = _ NUM ; stored Time = _ NUM ; start Time =  System . current Time Millis ( ) ; }
public int read Word ( ) throws  IOException { length += _ NUM ; int k1 = in . read ( ) ; if ( k1 < _ NUM ) return _ NUM ; return ( k1 + ( in . read ( ) << _ NUM ) ) & _ NUM ; }
private void tag End ( ) throws  IOException { save Current ( _ NUM ) ; go ( _ NUM ) ; _col += _ NUM ; if ( is All Read ( ) ) { return ; }  String tag Name = identifier ( ) ; if ( transformations != null && transformations . has Transformation For Tag ( tag Name ) ) {  Tag Transformation tag Transformation = transformations . get Transformation ( tag Name ) ; if ( tag Transformation != null ) { tag Name = tag Transformation . get Dest Tag ( ) ; } } if ( tag Name != null ) {  ITag Info Provider tag Info Provider = cleaner . get Tag Info Provider ( ) ;  Tag Info tag Info = tag Info Provider . get Tag Info ( tag Name ) ; if ( ( tag Info == null && ! props . is Omit Unknown Tags ( ) && props . is Treat Unknown Tags As Content ( ) && ! is Reserved Tag ( tag Name ) && ! props . is Namespaces Aware ( ) ) || ( tag Info != null && tag Info . is Deprecated ( ) && ! props . is Omit Deprecated Tags ( ) && props . is Treat Deprecated Tags As Content ( ) ) ) { content ( ) ; return ; } } _current Tag Token = new  End Tag Token ( tag Name ) ; if ( _as Expected ) { skip Whitespaces ( ) ; tag Attributes ( ) ; if ( tag Name != null ) { add Token ( _current Tag Token ) ; } if ( is Char ( _ STR ) ) { go ( ) ; } if ( props . is Use Cdata For ( tag Name ) ) { _is Special Context = _ BOOL ; _is Special Context Name = tag Name ; } if ( tag Name != null && tag Name . equals Ignore Case ( _ STR ) ) { skip Whitespaces ( ) ; } _current Tag Token = null ; } else { add Saved As Content ( ) ; } }
public  String next String ( char quote ) throws  JSONException { char c ;  String Buffer sb = new  String Buffer ( ) ; for ( ; ; ) { c = next ( ) ; switch ( c ) { case _ NUM : case _ STR : case _ STR : throw syntax Error ( _ STR ) ; case _ STR : c = next ( ) ; switch ( c ) { case _ STR : sb . append ( _ STR ) ; break ; case _ STR : sb . append ( _ STR ) ; break ; case _ STR : sb . append ( _ STR ) ; break ; case _ STR : sb . append ( _ STR ) ; break ; case _ STR : sb . append ( _ STR ) ; break ; case _ STR : try { sb . append ( ( char )  Integer . parse Int ( next ( _ NUM ) , _ NUM ) ) ; } catch (  Number Format Exception e ) { throw new  JSONException ( _ STR ) ; } break ; case _ STR : case _ STR : case _ STR : case _ STR : sb . append ( c ) ; break ; default : throw syntax Error ( _ STR ) ; } break ; default : if ( c == quote ) { return sb . to String ( ) ; } sb . append ( c ) ; } } }
public void write (  Random Access File file ) throws  IOException { }
public double evaluate (  Vector Instance x , double [ ] y ) throws  Exception { double dot Prod = x . dot Product ( y ) ; return  Math . pow ( m_gamma * dot Prod + m_coef0 , m_degree ) ; }
public boolean use Proxy ( ) { if (  String Utils . is Not Blank ( get Proxy Host ( ) ) ) { return _ BOOL ; } return _ BOOL ; }
public static  Description describe ( final char [ ] pin ) { if ( pin == null || pin . length == _ NUM ) { return new  Description ( _ NUM ,  Enum Set . none Of (  Character Class . class ) ) ; }  Enum Set <  Character Class > classes =  Enum Set . none Of (  Character Class . class ) ; for ( char ch : pin ) { classes . add (  Character Class . of ( ch ) ) ; } return new  Description ( pin . length , classes ) ; }
public void println (  Writer writer ) throws  IOException { print ( writer ) ; writer . write ( _ STR ) ; }
public  Tree <  String > extract Best Max Rule Parse1 ( int start , int end , int state ,  List <  String > sentence ) { int c State = maxc Child [ start ] [ end ] [ state ] ; if ( c State == - _ NUM ) { return extract Best Max Rule Parse2 ( start , end , state , sentence ) ; } else {  List <  Tree <  String > > child = new  Array List <  Tree <  String > > ( ) ; child . add ( extract Best Max Rule Parse2 ( start , end , c State , sentence ) ) ;  String state Str = (  String ) tag Numberer . object ( state ) ; if ( state Str . ends With ( _ STR ) ) state Str = state Str . substring ( _ NUM , state Str . length ( ) - _ NUM ) ; total Used Unaries ++ ; int intermediate Node = grammar . get Unary Intermediate ( ( short ) state , ( short ) c State ) ; if ( intermediate Node > _ NUM ) {  List <  Tree <  String > > restored Child = new  Array List <  Tree <  String > > ( ) ; n Times Restored Unaries ++ ;  String state Str2 = (  String ) tag Numberer . object ( intermediate Node ) ; if ( state Str2 . ends With ( _ STR ) ) state Str2 = state Str2 . substring ( _ NUM , state Str2 . length ( ) - _ NUM ) ; restored Child . add ( new  Tree <  String > ( state Str2 , child ) ) ; return new  Tree <  String > ( state Str , restored Child ) ; } return new  Tree <  String > ( state Str , child ) ; } }
protected void draw Center Text (  Canvas c ) {  String center Text = m Chart . get Center Text ( ) ; if ( m Chart . is Draw Center Text Enabled ( ) && center Text != null ) {  Point F center = m Chart . get Center Circle Box ( ) ;  String [ ] lines = center Text . split ( _ STR ) ; float maxlineheight = _ NUM ; for (  String line : lines ) { float cur Height =  Utils . calc Text Height ( m Center Text Paint , line ) ; if ( cur Height > maxlineheight ) maxlineheight = cur Height ; } float linespacing = maxlineheight * _ NUM ; float totalheight = maxlineheight * lines . length - linespacing * ( lines . length - _ NUM ) ; int cnt = lines . length ; float y = center . y ; for ( int i = _ NUM ; i < lines . length ; i ++ ) {  String line = lines [ lines . length - i - _ NUM ] ; c . draw Text ( line , center . x , y + maxlineheight * cnt - totalheight / _ NUM , m Center Text Paint ) ; cnt -- ; y -= linespacing ; } } }
public  ORCondition (  Condition ... conditions ) {  Reject . if Null ( conditions ) ; this . conditions =  Arrays . as List ( conditions ) ; }
private static  Result Code register Success Result Code ( final int int Value , final  Localizable Message name , final  Enum result Code Enum ) { final  Result Code t = new  Result Code ( int Value , name , _ BOOL , result Code Enum ) ;  ELEMENTS . put ( int Value , t ) ; return t ; }
public void clear ( ) { exception Set . clear ( ) ; explicit Set . clear ( ) ; universal Handler = _ BOOL ; common Supertype = null ; size = _ NUM ; }
@  HLEUnimplemented @  HLEFunction ( nid = _ NUM , version = _ NUM ) public int sce Usb Cam Setup Video ( psp Usb Cam Setup Video Param usb Cam Setup Video Param ,  TPointer work Area , int work Area Size ) { this . work Area = work Area . get Address ( ) ; this . work Area Size = work Area Size ; resolution = usb Cam Setup Video Param . resolution ; frame Rate = usb Cam Setup Video Param . framerate ; white Balance = usb Cam Setup Video Param . wb ; saturation = usb Cam Setup Video Param . saturation ; brightness = usb Cam Setup Video Param . brightness ; contrast = usb Cam Setup Video Param . contrast ; sharpness = usb Cam Setup Video Param . sharpness ; image Effect Mode = usb Cam Setup Video Param . effectmode ; frame Size = usb Cam Setup Video Param . framesize ; ev Level = usb Cam Setup Video Param . evlevel ; if ( ! setup Video ( ) ) { log . warn (  String . format ( _ STR ) ) ; return  Sce Kernel Errors .  ERROR_ USBCAM_ NOT_ READY ; } return _ NUM ; }
public  License Header Step (  String license ,  String delimiter ) { if ( delimiter . contains ( _ STR ) ) { throw new  Gradle Exception ( _ STR ) ; } license =  Line Ending . to Unix ( license ) ; if ( ! license . ends With ( _ STR ) ) { license = license + _ STR ; } this . license = license ; this . delimiter Pattern =  Pattern . compile ( _ STR + delimiter ,  Pattern .  UNIX_ LINES |  Pattern .  MULTILINE ) ; }
public  List <  Project Type Resolution > resolve Sources (  String path , boolean transient Only ) throws  Server Exception ,  Not Found Exception { final  List <  Project Type Resolution > resolutions = new  Array List < > ( ) ; for (  Project Type type : project Type Registry . get Project Types (  Project Type Registry .  CHILD_ TO_ PARENT_ COMPARATOR ) ) { if ( transient Only && type . is Persisted ( ) ) { continue ; } try { final  Project Type Resolution resolution = estimate Project ( path , type . get Id ( ) ) ; if ( resolution . matched ( ) ) { resolutions . add ( resolution ) ; } } catch (  Value Storage Exception e ) {  LOG . warn ( e . get Localized Message ( ) , e ) ; } } return resolutions ; }
static public void remove Notification Listener (  JMXConnector jmx Connector ,  Class < ? > mbean Interface ,  String mbean Name ,  Notification Listener notification Listener , boolean ignored ) throws  Exception {  MBean Server Connection mbsc = jmx Connector . get MBean Server Connection ( ) ;  Object Name object Name = generate MBean Object Name ( mbean Interface . get Name ( ) , mbean Name ) ; mbsc . remove Notification Listener ( object Name , notification Listener ) ; }
protected int consume Available Records (  Consumer <  Source Record > record Consumer ) {  List <  Source Record > records = new  Linked List < > ( ) ; consumed Lines . drain To ( records ) ; if ( record Consumer != null ) { records . for Each ( record Consumer ) ; } return records . size ( ) ; }
public byte [ ] read Raw Bytes ( final int size ) throws  IOException { if ( size < _ NUM ) { throw  Invalid Protocol Buffer Exception . negative Size ( ) ; } if ( total Bytes Retired + buffer Pos + size > current Limit ) { skip Raw Bytes ( current Limit - total Bytes Retired - buffer Pos ) ; throw  Invalid Protocol Buffer Exception . truncated Message ( ) ; } if ( size <= buffer Size - buffer Pos ) { final byte [ ] bytes = new byte [ size ] ;  System . arraycopy ( buffer , buffer Pos , bytes , _ NUM , size ) ; buffer Pos += size ; return bytes ; } else if ( size <  BUFFER_ SIZE ) { final byte [ ] bytes = new byte [ size ] ; int pos = buffer Size - buffer Pos ;  System . arraycopy ( buffer , buffer Pos , bytes , _ NUM , pos ) ; buffer Pos = buffer Size ; refill Buffer ( _ BOOL ) ; while ( size - pos > buffer Size ) {  System . arraycopy ( buffer , _ NUM , bytes , pos , buffer Size ) ; pos += buffer Size ; buffer Pos = buffer Size ; refill Buffer ( _ BOOL ) ; }  System . arraycopy ( buffer , _ NUM , bytes , pos , size - pos ) ; buffer Pos = size - pos ; return bytes ; } else { final int original Buffer Pos = buffer Pos ; final int original Buffer Size = buffer Size ; total Bytes Retired += buffer Size ; buffer Pos = _ NUM ; buffer Size = _ NUM ; int size Left = size - ( original Buffer Size - original Buffer Pos ) ; final  List < byte [ ] > chunks = new  Array List < byte [ ] > ( ) ; while ( size Left > _ NUM ) { final byte [ ] chunk = new byte [  Math . min ( size Left ,  BUFFER_ SIZE ) ] ; int pos = _ NUM ; while ( pos < chunk . length ) { final int n = ( input == null ) ? - _ NUM : input . read ( chunk , pos , chunk . length - pos ) ; if ( n == - _ NUM ) { throw  Invalid Protocol Buffer Exception . truncated Message ( ) ; } total Bytes Retired += n ; pos += n ; } size Left -= chunk . length ; chunks . add ( chunk ) ; } final byte [ ] bytes = new byte [ size ] ; int pos = original Buffer Size - original Buffer Pos ;  System . arraycopy ( buffer , original Buffer Pos , bytes , _ NUM , pos ) ; for ( final byte [ ] chunk : chunks ) {  System . arraycopy ( chunk , _ NUM , bytes , pos , chunk . length ) ; pos += chunk . length ; } return bytes ; } }
private void delete Attrs (  Svc Reg reg ,  Entry Rep entry , boolean check Dups ) {  Entry Class eclass = entry . eclass ; delete Instance ( eclass ) ;  Object [ ] fields = entry . fields ; if ( fields . length == _ NUM ) {  Array List regs = (  Array List ) service By Empty Attr . get ( eclass ) ; if ( regs == null || ( check Dups && has Empty Attr ( reg , eclass ) ) ) return ; int idx = regs . index Of ( reg ) ; if ( idx >= _ NUM ) { regs . remove ( idx ) ; if ( regs . is Empty ( ) ) service By Empty Attr . remove ( eclass ) ; } return ; } for ( int fldidx = fields . length ; -- fldidx >= _ NUM ; ) { eclass = get Defining Class ( eclass , fldidx ) ;  Hash Map [ ] attr Maps = (  Hash Map [ ] ) service By Attr . get ( eclass ) ; if ( attr Maps == null || attr Maps [ fldidx ] == null || ( check Dups && has Attr ( reg , eclass , fldidx , fields [ fldidx ] ) ) ) continue ;  Hash Map map = attr Maps [ fldidx ] ;  Object value = fields [ fldidx ] ;  Array List regs = (  Array List ) map . get ( value ) ; if ( regs == null ) continue ; int idx = regs . index Of ( reg ) ; if ( idx < _ NUM ) continue ; regs . remove ( idx ) ; if ( ! regs . is Empty ( ) ) continue ; map . remove ( value ) ; if ( ! map . is Empty ( ) ) continue ; attr Maps [ fldidx ] = null ; if ( all Null ( attr Maps ) ) service By Attr . remove ( eclass ) ; } }
public boolean is Public ( ) { return  Modifier . is Public ( _class . get Modifiers ( ) ) ; }
private void save Log File (  License license ,  Properties props ) {  File log File = get Log File ( license ) ; logger . fine ( _ STR + props ) ; try { final  Output Stream out = new  File Output Stream ( log File ) ; try { props . store ( out ,  String . format (  LOG_ HEADER , new Date ( ) ) ) ; } finally { out . close ( ) ; } } catch (  IOException ex ) { logger . log (  Level .  SEVERE , _ STR + log File . get Absolute Path ( ) , ex ) ; } }
public  Serbian Normalization Filter Factory (  Map <  String ,  String > args ) { super ( args ) ; this . haircut = get ( args , _ STR ,  Arrays . as List ( _ STR , _ STR ) , _ STR ) ; if ( ! args . is Empty ( ) ) { throw new  Illegal Argument Exception ( _ STR + args ) ; } }
public static int update (  W q ,  V v ) {  String passwd = (  String ) v . value ( _ STR ) ; if ( !  X . is Empty ( passwd ) ) { passwd = encrypt ( passwd ) ; v . set ( _ STR , passwd , _ BOOL ) ; } else { v . remove ( _ STR ) ; } return  Helper . update ( q , v . set ( _ STR ,  System . current Time Millis ( ) ) ,  User . class ) ; }
public  String to String ( ) {  String Buffer text = new  String Buffer ( ) ; text . append ( _ STR ) ; return text . to String ( ) ; }
public static boolean is Client Mode ( ) { return client Mode . get ( ) == null ? _ BOOL : client Mode . get ( ) ; }
public void test_get Put Byte Array With Offset And Length ( ) { final int capacity = _ NUM ; final  Byte Array Buffer buf = new  Byte Array Buffer ( capacity ) ; assert Equals ( ( byte ) _ NUM , buf . get Byte ( _ NUM ) ) ; assert Equals ( ( byte ) _ NUM , buf . get Byte ( capacity - _ NUM ) ) ; final int pos = _ NUM ; for ( int i = _ NUM ; i <  LIMIT ; i ++ ) { final byte [ ] expected = new byte [ r . next Int ( capacity - _ NUM ) ] ; final int off = ( expected . length / _ NUM == _ NUM ? _ NUM : r . next Int ( expected . length / _ NUM ) ) ; final int len = ( expected . length == _ NUM ? _ NUM : r . next Int ( expected . length - off ) ) ; r . next Bytes ( expected ) ; buf . put ( pos , expected , off , len ) ; assert Equals ( _ NUM ,  Bytes Util . compare Bytes With Len And Offset ( off , len , expected , pos , len , buf . array ( ) ) ) ; final int dstoff = r . next Int ( _ NUM ) ; final byte [ ] actual = new byte [ expected . length + dstoff ] ; buf . get ( pos , actual , dstoff , expected . length ) ; assert Equals ( _ NUM ,  Bytes Util . compare Bytes With Len And Offset ( off , len , expected , dstoff , len , actual ) ) ; } assert Equals ( ( byte ) _ NUM , buf . get Byte ( _ NUM ) ) ; assert Equals ( ( byte ) _ NUM , buf . get Byte ( pos + capacity - _ NUM ) ) ; }
public void remove Item (  M model ) { remove Item ( m Datas . index Of ( model ) ) ; }
public  Field Action (  String name ) { super (  I18n . tr ( name ) ) ; }
public static  Collection Id parse (  String str ) {  String [ ] parts = str . split ( _ STR + _ STR + _ STR ) ; if ( parts . length < _ NUM ) return null ; return new  Collection Id ( parts [ _ NUM ] , parts [ _ NUM ] , parts [ _ NUM ] ) ; }
public synchronized void unlisten ( final  Set <  Notification Channel > channel Names ) { m_channels . remove All ( channel Names ) ; }
public  Find Dialog (  Application app ) { this ( ( app . get Component ( ) == null ) ? null : (  Frame )  Swing Utilities . get Window Ancestor ( app . get Component ( ) ) , _ BOOL ) ; this . app = app ; }
@  Override default  Completable Future <  Optional Int > min Int ( final  To Int Function < ? super  T > fn ) { return  Completable Future . supply Async ( null , get Exec ( ) ) ; }
public void test Write1 ( ) throws  Exception { byte [ ] data = new byte [ ] { - _ NUM , - _ NUM , - _ NUM , - _ NUM , - _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM } ;  Test Output Stream tos = new  Test Output Stream ( ) ;  Cipher Output Stream cos = new  Cipher Output Stream ( tos , new  Null Cipher ( ) ) ; for ( int i = _ NUM ; i < data . length ; i ++ ) { cos . write ( data [ i ] ) ; } cos . flush ( ) ; byte [ ] result = tos . to Byte Array ( ) ; if ( !  Arrays . equals ( result , data ) ) { fail ( _ STR ) ; } }
public static  Document read Document (  Input Stream in ,  String encoding ) throws  IOException ,  XMLException { try {  Input Stream Reader reader = new  Input Stream Reader ( in , encoding ) ;  Input Source source = new  Input Source ( new  Buffered Reader ( reader ) ) ;  Document document ; try { document = document Builder . parse ( source ) ; } catch (  SAXException e ) { throw new  XMLException ( _ STR , e ) ; } return document ; } finally { in . close ( ) ; } }
public void add (  Production production ) { productions . add ( production ) ; }
void run (  String driver ,  String url ,  String user ,  String password ) throws  Exception {  Class . for Name ( driver ) ; conn =  Driver Manager . get Connection ( url , user , password ) ; stat = conn . create Statement ( ) ; try { stat . execute ( _ STR ) ; } catch (  SQLException e ) { } stat . execute ( _ STR + _ STR ) ; stat . execute ( _ STR ) ; stat . execute ( _ STR ) ; stat . execute ( _ STR ) ; login By Name Insecure ( ) ; if ( url . starts With ( _ STR ) ) { login Stored Procedure Insecure ( ) ; limit Row Access ( ) ; } login By Name Secure ( ) ; if ( url . starts With ( _ STR ) ) { stat . execute ( _ STR ) ; stat . execute ( _ STR ) ; stat . execute ( _ STR ) ; } login By Id Insecure ( ) ; login By Id Secure ( ) ; try { stat . execute ( _ STR ) ; } catch (  SQLException e ) { } stat . execute ( _ STR + _ STR ) ; stat . execute ( _ STR ) ; stat . execute ( _ STR ) ; stat . execute ( _ STR ) ; stat . execute ( _ STR ) ; stat . execute ( _ STR ) ; list Active Items ( ) ; if ( url . starts With ( _ STR ) ) { stat . execute ( _ STR ) ; stat . execute ( _ STR ) ; stat . execute ( _ STR ) ; stat . execute ( _ STR ) ; list Active Items Using Constants ( ) ; } list Items Sorted Insecure ( ) ; list Items Sorted Secure ( ) ; if ( url . starts With ( _ STR ) ) { list Items Sorted Secure Param ( ) ; store Password Hash With Salt ( ) ; } conn . close ( ) ; }
public static  String decode ( final  String escaped , final  String charset ) throws  URIException { return  Coder . decode ( escaped . to Char Array ( ) , charset ) ; }
public  Polling Scan Disk Space Monitor (  Set <  Path > watch Paths , long polling Interval Millis ) { this . watch Paths =  Collections . unmodifiable Set ( new  Hash Set < > ( watch Paths ) ) ; this . polling Interval Millis = polling Interval Millis ; }
public static void shift Mapping Vector (  Vector mvec , int shift ) { for ( int i = _ NUM ; i < mvec . size ( ) ; i ++ ) {  Vector line = (  Vector ) mvec . element At ( i ) ; for ( int j = _ NUM ; j < line . size ( ) ; j ++ ) {  Mapping Object mobj = (  Mapping Object ) line . element At ( j ) ; if ( mobj . type ==  BEGIN_ TLATOKEN ) {  Begin TLAToken obj = (  Begin TLAToken ) mobj ; obj . set Column ( obj . get Column ( ) + shift ) ; } else if ( mobj . type ==  END_ TLATOKEN ) {  End TLAToken obj = (  End TLAToken ) mobj ; obj . set Column ( obj . get Column ( ) + shift ) ; } else if ( mobj . type ==  SOURCE_ TOKEN ) {  Source Token obj = (  Source Token ) mobj ; obj . set Begin Column ( obj . get Begin Column ( ) + shift ) ; obj . set End Column ( obj . get End Column ( ) + shift ) ; } } } }
private void notify Lines ( final  Key output Type , final  Iterator <  String > lines , final  String Builder line Builder ) { if ( ! lines . has Next ( ) ) return ; if ( line Builder . length ( ) > _ NUM ) { line Builder . append ( lines . next ( ) ) ; if ( lines . has Next ( ) ) { final  String line = line Builder . to String ( ) ; notify Line ( line , output Type ) ; line Builder . set Length ( _ NUM ) ; } } while ( _ BOOL ) {  String line = null ; if ( lines . has Next ( ) ) { line = lines . next ( ) ; } if ( lines . has Next ( ) ) { notify Line ( line , output Type ) ; } else { if ( line != null && line . length ( ) > _ NUM ) { line Builder . append ( line ) ; } break ; } } }
public void add Message (  Localizable Message message ) { messages . add ( message ) ; }
public  List <  Object > objects ( ) ;
public <  E extends  T >  E max (  Iterable <  E > iterable ) {  Iterator <  E > iterator = iterable . iterator ( ) ;  E max So Far = iterator . next ( ) ; while ( iterator . has Next ( ) ) { max So Far = max ( max So Far , iterator . next ( ) ) ; } return max So Far ; }
private void flush Internal ( ) throws  IOException { if ( pos > _ NUM ) { out . write ( buf , _ NUM , pos ) ; } pos = _ NUM ; }
public void test Bug43714 ( ) throws  Exception {  Connection c_ IS = null ; try { c_ IS = get Connection With Props ( _ STR ) ;  Database Meta Data dbmd = c_ IS . get Meta Data ( ) ; this . rs = dbmd . get Exported Keys ( _ STR , _ STR , _ STR ) ; } finally { try { if ( c_ IS != null ) { c_ IS . close ( ) ; } } catch (  SQLException ex ) { } } }
public static int how Many Hours Old ( long time ) { return ( int ) ( (  System . current Time Millis ( ) - time ) /  Date Utils .  HOUR_ IN_ MILLIS ) ; }
protected boolean is WFXMLChar (  String chardata ,  Character ref Invalid Char ) { if ( chardata == null || ( chardata . length ( ) == _ NUM ) ) { return _ BOOL ; } char [ ] dataarray = chardata . to Char Array ( ) ; int datalength = dataarray . length ; if ( f Is XMLVersion11 ) { int i = _ NUM ; while ( i < datalength ) { if (  XML11 Char . is XML11 Invalid ( dataarray [ i ++ ] ) ) { char ch = dataarray [ i - _ NUM ] ; if (  XMLChar . is High Surrogate ( ch ) && i < datalength ) { char ch2 = dataarray [ i ++ ] ; if (  XMLChar . is Low Surrogate ( ch2 ) &&  XMLChar . is Supplemental (  XMLChar . supplemental ( ch , ch2 ) ) ) { continue ; } } ref Invalid Char = new  Character ( ch ) ; return _ BOOL ; } } } else { int i = _ NUM ; while ( i < datalength ) { if (  XMLChar . is Invalid ( dataarray [ i ++ ] ) ) { char ch = dataarray [ i - _ NUM ] ; if (  XMLChar . is High Surrogate ( ch ) && i < datalength ) { char ch2 = dataarray [ i ++ ] ; if (  XMLChar . is Low Surrogate ( ch2 ) &&  XMLChar . is Supplemental (  XMLChar . supplemental ( ch , ch2 ) ) ) { continue ; } } ref Invalid Char = new  Character ( ch ) ; return _ BOOL ; } } } return _ BOOL ; }
public void test Pos Zero ( ) {  String num A = _ STR ;  String num B = _ STR ;  String res = _ STR ;  Big Integer a Number = new  Big Integer ( num A ) ;  Big Integer b Number = new  Big Integer ( num B ) ;  Big Integer result = a Number . xor ( b Number ) ; assert True ( res . equals ( result . to String ( ) ) ) ; }
public final  Parallel Flux <  T > do On Request (  Long Consumer on Request ) {  Objects . require Non Null ( on Request , _ STR ) ; return do On Signal ( this , null , null , null , null , null , null , on Request , null ) ; }
protected void add Missing (  Instances data , int level , boolean attribute Missing , boolean class Missing , int attr Index ) { int class Index = data . class Index ( ) ;  Random random = new  Random ( _ NUM ) ; for ( int i = _ NUM ; i < data . num Instances ( ) ; i ++ ) {  Instance current = data . instance ( i ) ; for ( int j = _ NUM ; j < data . num Attributes ( ) ; j ++ ) { if ( ( ( j == class Index ) && class Missing ) || ( ( j == attr Index ) && attribute Missing ) ) { if (  Math . abs ( random . next Int ( ) ) % _ NUM < level ) { current . set Missing ( j ) ; } } } } }
public <  T extends  Data Object > void update In Batches (  List <  T > records , int partition Size ,  Db Client db Client ,  String type ) {  List <  List <  T > > volume_partitions =  Lists . partition ( records , partition Size ) ; for (  List <  T > partition : volume_partitions ) { try { db Client . update Object ( partition ) ; _log . info ( _ STR , partition . size ( ) , type ) ; } catch (  Database Exception e ) { _log . error ( _ STR , type , e ) ; } } }
public void create (  SSOToken token ,  String obj Name ,  Map attrs ) throws  SMSException ,  SSOException { if ( ( obj Name == null ) || ( obj Name . length ( ) == _ NUM ) || ( attrs == null ) ) { throw new  Illegal Argument Exception ( _ STR + _ STR ) ; }  String attribute File Name = null ; m RWLock . read Request ( ) ; try { if ( root . is Exists ( m Root Dir , obj Name ) ) {  String errmsg = _ STR + obj Name ; m Debug . error ( errmsg ) ; throw new  Service Already Exists Exception ( errmsg ) ; } } finally { m RWLock . read Done ( ) ; } m RWLock . write Request ( ) ; if ( root . is Exists ( m Root Dir , obj Name ) ) {  String errmsg = _ STR + obj Name ; m Debug . error ( errmsg ) ; throw new  Service Already Exists Exception ( errmsg ) ; }  SMSFlat File Tree Node node = new  SMSFlat File Tree Node ( obj Name ) ;  String filepath = node . get Attribute Filename ( m Root Dir ) ; try {  Set sunserviceids = null ;  Set sunxmlkeyvals = null ;  Properties props = new  Properties ( ) ;  Set keys = attrs . key Set ( ) ; if ( keys != null ) { for (  Iterator i = keys . iterator ( ) ; i . has Next ( ) ; ) {  String key = (  String ) i . next ( ) ;  Set vals = (  Set ) attrs . get ( key ) ; if ( key . equals Ignore Case (  SMSEntry .  ATTR_ SERVICE_ ID ) ) { sunserviceids = vals ; } else if ( key . equals Ignore Case (  SMSEntry .  ATTR_ XML_ KEYVAL ) ) { sunxmlkeyvals = vals ; } props . put ( key , to Val String ( vals ) ) ; } } try {  File attr File = new  File ( filepath ) ; try { if ( ! attr File . create New File ( ) ) {  String errmsg = _ STR + obj Name + _ STR + filepath ; m Debug . error ( errmsg ) ; throw new  SMSException ( errmsg ) ; } } catch (  IOException e ) {  String errmsg = _ STR + obj Name + _ STR + filepath + _ STR + e . get Message ( ) ; m Debug . error ( _ STR , e ) ; throw new  SMSException ( errmsg ) ; } save Properties ( props , attr File , obj Name ) ; create Sun Service Id Files ( node , sunserviceids ) ; create Sun Xml Key Val Files ( node , sunxmlkeyvals ) ; if ( ! root . add Child ( node ) ) { throw new  SMSException ( _ STR + obj Name ) ; } save Directory Tree ( ) ; } catch (  SMSException e ) {  File attr File = new  File ( filepath ) ; try { attr File . delete ( ) ; } catch (  Security Exception se ) { } throw e ; } } finally { m RWLock . write Done ( ) ; } }
public void add On Tab Selected Listener (  On Tab Selected Listener listener ) { if ( listener != null ) { m Listeners . add ( listener ) ; } }
public static  Uri create File Uri (  String path ) { if ( path . starts With ( _ STR ) ) { return  Uri . parse ( path ) ; } return  Uri . from File ( new  File ( path ) ) ; }
@  Override public void parse (  String a Line ) throws  IOException {  String [ ] tokens = a Line . split ( _ STR ) ; if ( tokens . length == _ NUM ) { clear ( ) ; query Name = tokens [ _ NUM ] ; } else { query Name = tokens [ _ NUM ] ; ref Name = tokens [ _ NUM ] ; bit Score =  Basic . parse Int ( tokens [ _ NUM ] ) ; expected =  Basic . parse Float ( tokens [ _ NUM ] ) ; percent Identity =  Basic . parse Int ( tokens [ _ NUM ] ) ; } }
public boolean export Type Selected ( ) { return export Type Selected ; }
public  Cycle Bound Tick ( boolean map To Last Cycle ,  Number number ,  String label ,  Text Anchor text Anchor ,  Text Anchor rotation Anchor , double angle ) { super ( number , label , text Anchor , rotation Anchor , angle ) ; this . map To Last Cycle = map To Last Cycle ; }
public boolean is Running ( ) { return m Running . get ( ) ; }
public static  String indent ( int level ) { return ( level <= _ NUM ) ? _ STR :  String . format ( _ STR + level * _ NUM + _ STR , _ STR ) ; }
public  Gossip Service (  String cluster ,  String ip Address , int port ,  String id ,  List <  Gossip Member > gossip Members ,  Gossip Settings settings ,  Gossip Listener listener ) throws  Interrupted Exception ,  Unknown Host Exception { gossip Manager = new  Random Gossip Manager ( cluster , ip Address , port , id , settings , gossip Members , listener ) ; }
public static boolean is Abstract ( int mod ) { return  Modifier . is Abstract ( mod ) ; }
public  JSONBuffer close Array ( ) { if ( stack . empty ( ) || stack . peek ( ) !=  Operand .  ARRAY ) { throw new  JSONException ( _ STR ) ; } remove Separator ( ) ; buffer . append ( _ STR ) ; stack . pop ( ) ; add Separator ( ) ; return this ; }
public static  Tungsten Properties load Passwords From Authentication Info (  Authentication Info authentication Info ) throws  Server Runtime Exception { try {  String password File Location = authentication Info . get Password File Location ( ) ;  Tungsten Properties new Props = new  Tungsten Properties ( ) ; new Props . load ( new  File Input Stream ( password File Location ) , _ BOOL ) ; new Props . trim ( ) ; logger . debug (  Message Format . format ( _ STR , password File Location ) ) ; return new Props ; } catch (  File Not Found Exception e ) { throw new  Server Runtime Exception ( _ STR + authentication Info . get Password File Location ( ) , e ) ; } catch (  IOException e ) { throw new  Server Runtime Exception ( _ STR + authentication Info . get Password File Location ( ) , e ) ; } }
public void error (  Level level ,  String message Id ,  String data [ ] ,  Object session ,  Map props ) throws  Log Exception { if ( is Error Loggable ( level ) ) {  Log Record lr = new  Log Record ( level , format Message ( message Id , data , session ) ) ; error Logger . log ( lr ) ; } }
public synchronized int index Of (  IAudio Processor processor ) { return processors . index Of ( processor ) ; }
private int end Recover Animation (  Recycler View .  View Holder view Holder , boolean override ) { final int recover Anim Size = m Recover Animations . size ( ) ; for ( int i = recover Anim Size - _ NUM ; i >= _ NUM ; i -- ) { final  Recover Animation anim = m Recover Animations . get ( i ) ; if ( anim . m View Holder == view Holder ) { anim . m Overridden |= override ; if ( ! anim . m Ended ) { anim . cancel ( ) ; } m Recover Animations . remove ( i ) ; return anim . m Animation Type ; } } return _ NUM ; }
private void add Proxy Method (  Method m ,  Class < ? > from Class ) {  String name = m . get Name ( ) ;  Class < ? > [ ] parameter Types = m . get Parameter Types ( ) ;  Class < ? > return Type = m . get Return Type ( ) ;  Class < ? > [ ] exception Types = m . get Exception Types ( ) ;  String sig = name + get Parameter Descriptors ( parameter Types ) ;  List <  Proxy Method > sigmethods = proxy Methods . get ( sig ) ; if ( sigmethods != null ) { for (  Proxy Method pm : sigmethods ) { if ( return Type == pm . return Type ) {  List <  Class < ? > > legal Exceptions = new  Array List < > ( ) ; collect Compatible Types ( exception Types , pm . exception Types , legal Exceptions ) ; collect Compatible Types ( pm . exception Types , exception Types , legal Exceptions ) ; pm . exception Types = new  Class < ? > [ legal Exceptions . size ( ) ] ; pm . exception Types = legal Exceptions . to Array ( pm . exception Types ) ; return ; } } } else { sigmethods = new  Array List < > ( _ NUM ) ; proxy Methods . put ( sig , sigmethods ) ; } sigmethods . add ( new  Proxy Method ( name , parameter Types , return Type , exception Types , from Class ) ) ; }
public final boolean parent Of (  Thread Group g ) { for ( ; g != null ; g = g . parent ) { if ( g == this ) { return _ BOOL ; } } return _ BOOL ; }
public  String to String ( ) { return to String ( null ) ; }
private static void check For KOML ( ) { try {  Class . for Name ( _ STR ) ; m_ Present = _ BOOL ; } catch (  Exception e ) { m_ Present = _ BOOL ; } }
@  Target Api (  Build .  VERSION_ CODES .  GINGERBREAD_ MR1 ) private  Response <  Bitmap > do Parse (  Network Response response ) { byte [ ] data = response . data ;  Bitmap Factory .  Options decode Options = new  Bitmap Factory .  Options ( ) ; decode Options . in Input Shareable = _ BOOL ; decode Options . in Purgeable = _ BOOL ; decode Options . in Preferred Config = m Decode Config ;  Bitmap bitmap ; if ( m Max Width == _ NUM && m Max Height == _ NUM ) { bitmap =  Bitmap Factory . decode Byte Array ( data , _ NUM , data . length , decode Options ) ; } else { decode Options . in Just Decode Bounds = _ BOOL ;  Bitmap Factory . decode Byte Array ( data , _ NUM , data . length , decode Options ) ; int actual Width = decode Options . out Width ; int actual Height = decode Options . out Height ; int desired Width = get Resized Dimension ( m Max Width , m Max Height , actual Width , actual Height , m Scale Type ) ; int desired Height = get Resized Dimension ( m Max Height , m Max Width , actual Height , actual Width , m Scale Type ) ; decode Options . in Just Decode Bounds = _ BOOL ; if (  Utils . has Gingerbread MR1 ( ) ) { decode Options . in Prefer Quality Over Speed =  PREFER_ QUALITY_ OVER_ SPEED ; } decode Options . in Sample Size =  Image Utils . find Best Sample Size ( actual Width , actual Height , desired Width , desired Height ) ;  Bitmap temp Bitmap =  Bitmap Factory . decode Byte Array ( data , _ NUM , data . length , decode Options ) ; if ( temp Bitmap != null && ( temp Bitmap . get Width ( ) > desired Width || temp Bitmap . get Height ( ) > desired Height ) ) { bitmap =  Bitmap . create Scaled Bitmap ( temp Bitmap , desired Width , desired Height , _ BOOL ) ; temp Bitmap . recycle ( ) ; } else { bitmap = temp Bitmap ; } } if ( bitmap == null ) { return  Response . error ( new  Parse Error ( response ) ) ; } else { return  Response . success ( bitmap ,  Http Header Parser . parse Cache Headers ( response ) ) ; } }
public double [ ] bisector ( final double [ ] a , final double [ ] b ) { double [ ] diff = subtract Components ( a , b ) ; double [ ] sum = sum Components ( a , b ) ; double dot = dot ( diff , sum ) ; double [ ] result = new double [ diff . length + _ NUM ] ;  System . arraycopy ( diff , _ NUM , result , _ NUM , diff . length ) ; result [ diff . length ] = - dot / _ NUM ; return result ; }
public boolean compile (  String [ ] args ) { long start Time =  System . current Time Millis ( ) ; long batch ID ; synchronized ( batch Count Lock ) { batch ID = batch Count ++ ; }  Batch batch = parse Args ( args ) ; if ( batch == null ) { return _ BOOL ; } boolean status ; try { batch Table . put ( batch ID , batch ) ; status = invoke Javadoc ( batch , batch ID ) ; } finally { batch Table . remove ( batch ID ) ; } if ( batch . verbose ) { long delta Time =  System . current Time Millis ( ) - start Time ; output (  Resources . get Text ( _ STR ,  Long . to String ( delta Time ) ) ) ; } return status ; }
public void clear ( ) { m Cached Tiles . clear ( ) ; }
public  FPSTexture View remove Child ( @  Non Null  Display Base display Base ) { display Base . disable ( ) ; boolean a = m Display List . remove ( display Base ) ; return this ; }
private double [ ] prune (  Tree tree ,  Node Ref node ,  Colour Change Matrix mm ) { double [ ] p = new double [ colour Count ] ; if ( tree . is External ( node ) ) { p [ get Colour ( node ) ] = _ NUM ; } else {  Node Ref left Child = tree . get Child ( node , _ NUM ) ;  Node Ref right Child = tree . get Child ( node , _ NUM ) ; double [ ] left = prune ( tree , left Child , mm ) ; double [ ] right = prune ( tree , right Child , mm ) ; double node Height = tree . get Node Height ( node ) ; double left Time = node Height - tree . get Node Height ( tree . get Child ( node , _ NUM ) ) ; double right Time = node Height - tree . get Node Height ( tree . get Child ( node , _ NUM ) ) ; double maxp = _ NUM ; for ( int i = _ NUM ; i < colour Count ; i ++ ) { double left Sum = _ NUM ; double right Sum = _ NUM ; for ( int j = _ NUM ; j < colour Count ; j ++ ) { left Sum += mm . forward Time Evolution ( i , j , left Time ) * left [ j ] ; right Sum += mm . forward Time Evolution ( i , j , right Time ) * right [ j ] ; } p [ i ] = left Sum * right Sum ; if ( p [ i ] > maxp ) { maxp = p [ i ] ; } } if ( maxp < _ NUM ) { for ( int i = _ NUM ; i < colour Count ; i ++ ) { p [ i ] *= _ NUM ; } log Node Partials Rescaling -=  Math . log ( _ NUM ) ; } } node Partials [ node . get Number ( ) ] = p ; if ( debug Node Partials ) { pretty Print ( _ STR + node . get Number ( ) + _ STR , p ) ; } return p ; }
public  OMGraphic generate (  OMGrid grid ,  Projection proj ) {  Debug . message ( _ STR , _ STR ) ; if ( grid . height <= _ NUM || grid . width <= _ NUM ) {  Debug . message ( _ STR , _ STR ) ; return  Sink Graphic . get Shared Instance ( ) ; }  OMRaster raster = new  OMRaster ( grid . point1 . x , grid . point1 . y , grid . width , grid . height , new int [ grid . width * grid . height ] ) ; int rows = grid . get Rows ( ) ; int columns = grid . get Columns ( ) ;  Raster Helper raster Helper = get Raster Helper ( grid . get Data ( ) ) ; boolean major = grid . get Major ( ) ; double y_interval = ( double ) rows / ( double ) grid . height ; double x_interval = ( double ) columns / ( double ) grid . width ;  Debug . message ( _ STR , _ STR + y_interval + _ STR + x_interval ) ; int post_x , post_y , value ; for ( int x = _ NUM ; x < grid . width ; x ++ ) { for ( int y = _ NUM ; y < grid . height ; y ++ ) { post_x = ( int )  Math . round ( x_interval * ( double ) x ) ; if ( grid . get Render Type ( ) ==  OMGraphic .  RENDERTYPE_ LATLON ) { post_y = ( int )  Math . round ( y_interval * ( grid . height - _ NUM - ( double ) y ) ) ; } else { post_y = ( int )  Math . round ( y_interval * ( double ) y ) ; } if ( major ==  OMGrid .  COLUMN_ MAJOR ) { if ( post_x >= columns ) post_x = columns - _ NUM ; if ( post_y >= rows ) post_y = rows - _ NUM ; value = calibrate Point Value ( raster Helper . get ( post_x , post_y ) ) ; } else { if ( post_y >= columns ) post_y = columns - _ NUM ; if ( post_x >= rows ) post_x = rows - _ NUM ; value = calibrate Point Value ( raster Helper . get ( post_y , post_x ) ) ; } raster . set Pixel ( x , y , value ) ; } } raster . generate ( proj ) ; return raster ; }
public  Time (  Date date ) {  Simple Time Zone tz = new  Simple Time Zone ( _ NUM , _ STR ) ;  Simple Date Format date F = new  Simple Date Format ( _ STR ) ; date F . set Time Zone ( tz ) ;  String d = date F . format ( date ) + _ STR ; int year =  Integer . parse Int ( d . substring ( _ NUM , _ NUM ) ) ; if ( year < _ NUM || year > _ NUM ) { time = new  DERGeneralized Time ( d ) ; } else { time = new  DERUTCTime ( d . substring ( _ NUM ) ) ; } }
public  DProvider Info (  JFrame parent ) { super ( parent ,  Modality Type .  DOCUMENT_ MODAL ) ; init Components ( ) ; }
public static  Automaton determinize Simple (  Automaton a ) {  Set <  Integer > initialset = new  Hash Set < > ( ) ; initialset . add ( _ NUM ) ; return determinize Simple ( a , initialset ) ; }
@  Override public boolean equals (  Object o ) { if ( this == o ) return _ BOOL ; if ( o == null || get Class ( ) != o . get Class ( ) ) return _ BOOL ;  Abstract Drawer Item < ? , ? > that = (  Abstract Drawer Item < ? , ? > ) o ; return m Identifier == that . m Identifier ; }
void add Column (  Column column ) { columns . add ( column ) ; }
private static  Vector  Parenthesize (  Vector vec ) { if (  Needs Parentheses ( vec ) ) { vec . set Element At ( _ STR + ( (  String ) vec . element At ( _ NUM ) ) , _ NUM ) ; for ( int i = _ NUM ; i < vec . size ( ) ; i ++ ) { vec . set Element At ( _ STR + ( (  String ) vec . element At ( i ) ) , i ) ; } ; int cur Line Num = vec . size ( ) - _ NUM ; vec . set Element At ( ( (  String ) vec . element At ( cur Line Num ) ) + _ STR , cur Line Num ) ; } ; return vec ; }
private static  String build Header ( ) { if ( header == null ) {  String Builder strb = new  String Builder ( ) ; strb . append (  LEFT_ BRACE ) ; strb . append (  SELENIUM_ VERSION_ KEY ) ; strb . append (  COLON ) ; strb . append (  SELENIUM_ VERSION_ VALUE ) ; strb . append (  COMMA ) ; strb . append (  FORMAT_ VERSION_ KEY ) ; strb . append (  COLON ) ; strb . append (  FORMAT_ VERSION_ VALUE ) ; strb . append (  COMMA ) ; strb . append (  STEPS_ KEY ) ; strb . append (  COLON ) ; strb . append (  LEFT_ SQUARE_ BRACKET ) ; header = strb . to String ( ) ; } return header ; }
public static  List <  String > read To List (  File f ) throws  IOException { try ( final  Reader reader = as Reader UTF8 Lenient ( new  File Input Stream ( f ) ) ) { return read To List ( reader ) ; } catch (  IOException ioe ) { throw new  Illegal State Exception (  String . format ( _ STR , f . get Absolute Path ( ) , ioe ) , ioe ) ; } }
@  Override public double calculate_ K ( int [ ] x_index , double [ ] x_att , int [ ] y_index , double [ ] y_att ) { return  Math . sqrt ( ( norm2 ( x_index , x_att , y_index , y_att ) / sigma ) + ( shift * shift ) ) ; }
@  Override public void close ( ) throws  IOException { synchronized ( lock ) { if ( is Closed ( ) ) { return ; }  Throwable thrown = null ; try { flush Internal ( ) ; } catch (  Throwable e ) { thrown = e ; } buf = null ; try { out . close ( ) ; } catch (  Throwable e ) { if ( thrown == null ) { thrown = e ; } } out = null ; if ( thrown != null ) {  Sneaky Throw . sneaky Throw ( thrown ) ; } } }
public static double cos ( double radians ) { return  Math . cos ( radians ) ; }
public static double ss Reg ( double [ ] residuals , double [ ] target Attribute ) { double mean = sum ( target Attribute ) / target Attribute . length ; double ret = _ NUM ; for ( int i = _ NUM ; i < residuals . length ; i ++ ) { ret +=  Math . pow ( residuals [ i ] - mean , _ NUM ) ; } return ret ; }
public int size ( ) { return set . size ( ) ; }
public  Augmented Dickey Fuller ( double [ ] ts ) { this . ts = ts ; this . lag = ( int )  Math . floor (  Math . cbrt ( ( ts . length - _ NUM ) ) ) ; compute ADFStatistics ( ) ; }
public <  T extends  Enum <  T > >  T consume Enum (  String name , boolean required ,  Class <  T > enum Class ,  T default Value ) throws  Parse Exception {  String value = consume ( name , required ) ; if ( value == null ) { return default Value ; } try { return  Enum . value Of ( enum Class , value . to Upper Case ( ) ) ; } catch (  Illegal Argument Exception e ) {  Parse Exception pe = new  Parse Exception (  Core Error Domain .  ERR . invalid Attribute Value , e ) ; pe . set Internal Reason ( _ STR + name + _ STR ) ; throw pe ; } }
public final void copy ( byte [ ] bytes , int offset , int length ) { if ( this . bytes == null || this . bytes . length < length ) { this . bytes = new byte [ length ] ; }  System . arraycopy ( bytes , offset , this . bytes , _ NUM , length ) ; this . count = length ; }
public boolean has Key (  ECKey key ) { lock . lock ( ) ; try { return keychain . contains ( key ) ; } finally { lock . unlock ( ) ; } }
public  String root ( ) { return root ; }
public static void close Silently (  Reader reader ) { if ( reader != null ) { try { reader . close ( ) ; } catch (  Exception e ) { } } }
public static boolean is Button Pressed (  Input Event e , int button ) { return ( e . get Modifiers ( ) & button ) == button ; }
private synchronized void init (  String instance RDN ) throws  Exception {  String srvc Name = get Service Name ( ) ; if ( admin Token == null ) { admin Token = (  SSOToken )  Access Controller . do Privileged (  Admin Token Action . get Instance ( ) ) ; s Manager = new  Service Manager ( admin Token ) ;  Service Schema Manager schema Manager = s Manager . get Schema Manager ( srvc Name ,  SERVICE_ VERSION ) ; client Service Schema = schema Manager . get Global Schema ( ) ; client Schema = client Service Schema . get Sub Schema (  DBSTORE_ SUBSCHEMA_ ID ) ; client Schema = client Schema . get Sub Schema (  CLIENT_ SUBSCHEMA_ ID ) ; am Connection = new  AMStore Connection ( admin Token ) ; top Level DN = am Connection . get Organization DN ( null , null ) ; init Client Schema ( ) ; init Configuration Info ( client Service Schema ) ; client Data DN =  CLIENT_ DATA_ DN_ PREFIX +  COMMA + top Level DN ; } database DN = instance RDN +  COMMA + client Data DN ; am Client Org = am Connection . get Organizational Unit ( database DN ) ; }
public static void init (  Context context ) {  Shared Preferences prefs =  Preference Manager . get Default Shared Preferences ( context ) ; prefs . register On Shared Preference Change Listener ( null ) ; }
Type Simplifier (  Types type Utils ,  String package Name ,  Set <  Type Mirror > types ,  Type Mirror base ) { this . type Utils = type Utils ;  Set <  Type Mirror > types Plus Base = new  Type Mirror Set ( types ) ; if ( base != null ) { types Plus Base . add ( base ) ; }  Set <  Type Mirror > referenced = referenced Class Types ( type Utils , types Plus Base ) ;  Set <  Type Mirror > defined = non Private Declared Types ( type Utils , base ) ; this . imports = find Imports ( type Utils , package Name , referenced , defined ) ; }
public static  Histogram add (  Histogram x , double y ) { return x . modify Event Counters ( null ) ; }
private  Point add Point (  Polygon arrow ,  Rectangle rect , int pos , boolean from ) { int x = rect . x ; int y = rect . y ;  Point point = null ; if ( pos ==  Swing Constants .  TOP ) { x += rect . width / _ NUM ; if ( from ) { arrow . add Point ( x - _ NUM , y ) ; arrow . add Point ( x + _ NUM , y ) ; } else arrow . add Point ( x , y ) ; point = new  Point ( x , y - _ NUM ) ; } else if ( pos ==  Swing Constants .  RIGHT ) { x += rect . width ; y += rect . height / _ NUM ; if ( from ) { arrow . add Point ( x , y - _ NUM ) ; arrow . add Point ( x , y + _ NUM ) ; } else arrow . add Point ( x , y ) ; point = new  Point ( x + _ NUM , y ) ; } else if ( pos ==  Swing Constants .  LEFT ) { y += rect . height / _ NUM ; if ( from ) { arrow . add Point ( x , y - _ NUM ) ; arrow . add Point ( x , y + _ NUM ) ; } else arrow . add Point ( x , y ) ; point = new  Point ( x - _ NUM , y ) ; } else { x += rect . width / _ NUM ; y += rect . height ; if ( from ) { arrow . add Point ( x - _ NUM , y ) ; arrow . add Point ( x + _ NUM , y ) ; } else arrow . add Point ( x , y ) ; point = new  Point ( x , y + _ NUM ) ; } return point ; }
void refresh (  String filter ,  Set <  Identity > selected Participants ) {  Set <  Identity > filtered Identities = filter ( filter ) ; for (  Identity selected Participant : selected Participants ) { filtered Identities . remove ( selected Participant ) ; } m Participants . clear ( ) ; m Participants . add All ( filtered Identities ) ;  Collections . sort ( m Participants , new  Identity Display Name Comparator ( ) ) ; notify Data Set Changed ( ) ; if ( m Show Conversations ) { query Conversations ( selected Participants ) ; } }
private void savepost Logout (  String post Location ,  String post Resp Location ,  List log List , com . sun . identity . saml2 . jaxb . metadata .  Object Factory obj Fact ) throws  JAXBException { if ( post Location != null && post Location . length ( ) > _ NUM ) {  Single Logout Service Element sls Elem Post = obj Fact . create Single Logout Service Element ( ) ; sls Elem Post . set Binding ( http Post Binding ) ; sls Elem Post . set Location ( post Location ) ; sls Elem Post . set Response Location ( post Resp Location ) ; log List . add ( sls Elem Post ) ; } }
public static  Intent create Take Picture Intent (  Activity ctx ,  Uri saving Uri ) { if ( saving Uri == null ) { throw new  Null Pointer Exception ( _ STR ) ; } final  List <  Intent > camera Intents = new  Array List <  Intent > ( ) ; final  Intent capture Intent = new  Intent (  Media Store .  ACTION_ IMAGE_ CAPTURE ) ; final  Package Manager package Manager = ctx . get Package Manager ( ) ; final  List <  Resolve Info > list Cam = package Manager . query Intent Activities ( capture Intent , _ NUM ) ; for (  Resolve Info res : list Cam ) { final  String package Name = res . activity Info . package Name ; final  Intent intent = new  Intent ( capture Intent ) ; intent . set Component ( new  Component Name ( res . activity Info . package Name , res . activity Info . name ) ) ; intent . set Package ( package Name ) ; intent . put Extra (  Media Store .  EXTRA_ OUTPUT , saving Uri ) ; camera Intents . add ( intent ) ; } final  Intent gallery Intent = new  Intent ( ) ; gallery Intent . set Type ( _ STR ) ; gallery Intent . set Action (  Intent .  ACTION_ GET_ CONTENT ) ; final  Intent chooser Intent =  Intent . create Chooser ( gallery Intent , _ STR ) ; chooser Intent . put Extra (  Intent .  EXTRA_ INITIAL_ INTENTS , camera Intents . to Array ( new  Parcelable [ ] { } ) ) ; return chooser Intent ; }
private static  Virtual File [ ] to Virtual Files (  File [ ] files ) { if ( files == null ) return null ;  List <  Virtual File > v Files = new  Array List <  Virtual File > ( files . length ) ; for ( int i = _ NUM ; i < files . length ; i ++ ) { if ( files [ i ] != null ) v Files . add ( new  Local File ( files [ i ] ) ) ; } return v Files . to Array ( new  Virtual File [ v Files . size ( ) ] ) ; }
private static boolean has Security Manager ( ) { return (  System . get Security Manager ( ) != null ) ; }
public static  Big Decimal convert (  Big Decimal p_ Amount , int p_ C_ Currency From_ ID , int p_ C_ Currency To_ ID ,  Timestamp p_ Conversion Date , int p_ C_ Conversion Type_ ID , int p_ AD_ Client_ ID , int p_ AD_ Org_ ID ) throws  SQLException { if ( p_ Amount == null || p_ C_ Currency From_ ID == _ NUM || p_ C_ Currency To_ ID == _ NUM ) return null ; if ( p_ Amount . signum ( ) == _ NUM || p_ C_ Currency From_ ID == p_ C_ Currency To_ ID ) return p_ Amount ;  Big Decimal rate = rate ( p_ C_ Currency From_ ID , p_ C_ Currency To_ ID , p_ Conversion Date , p_ C_ Conversion Type_ ID , p_ AD_ Client_ ID , p_ AD_ Org_ ID ) ; if ( rate == null ) return null ; return round ( p_ Amount . multiply ( rate ) , p_ C_ Currency To_ ID , null ) ; }
public static  Snmp Engine Id create Engine Id ( int port , int iana ) throws  Unknown Host Exception {  Inet Address address = null ; address =  Inet Address . get Local Host ( ) ; return create Engine Id ( address , port , iana ) ; }
public static  List <  Active Rule > import Configuration (  String configuration ,  List <  Rule > rules Repository ) {  Ruleset ruleset =  Delphi Rules Utils . build Rule Set From Xml ( configuration ) ;  List <  Active Rule > active Rules = new  Array List <  Active Rule > ( ) ; for (  Delphi Rule f Rule : ruleset . get Rules ( ) ) {  Active Rule active Rule = create Active Rule ( f Rule , rules Repository ) ; if ( active Rule != null ) { active Rules . add ( active Rule ) ; } } return active Rules ; }
public org . w3c . dom .  Element sign With SAMLToken ( org . w3c . dom .  Document doc , java . security . cert .  Certificate cert ,  String assertion ID , java . lang .  String algorithm , java . util .  List ids ) throws  XMLSignature Exception { return null ; }
public void insert Child (  Node [ ] nodes , int index ) { for (  Node node : nodes ) { node . detach From Parent ( ) ; node . parent Node = this ; try { init Child Nodes ( node ) ; child Nodes . add ( index , node ) ; index ++ ; } catch (  Index Out Of Bounds Exception ignore ) { throw new  Lagarto DOMException ( _ STR + index ) ; } } reindex Children ( ) ; }
private static byte [ ] ntlm Hash (  String password ) throws  Exception { byte [ ] unicode Password = password . get Bytes ( _ STR ) ;  Message Digest md4 =  Message Digest . get Instance ( _ STR ) ; return md4 . digest ( unicode Password ) ; }
public static void show Warning ( final  String message Text ) {  JOption Pane . show Message Dialog ( null , message Text , translate ( _ STR ) ,  JOption Pane .  WARNING_ MESSAGE ) ; }
public static  Parameter Type make File Parameter Type (  Parameter Handler parameter Handler ,  String parameter Name ,  String description ,  Port Provider port Provider ,  String ... file Extensions ) { return make File Parameter Type ( parameter Handler , parameter Name , description , port Provider , _ BOOL , file Extensions ) ; }
public void log Equals ( ) { for ( int i = _ NUM ; i <  A . length ; i ++ ) for ( int j = _ NUM ; j <  A [ i ] . length ; j ++ )  A [ i ] [ j ] =  Math . log (  A [ i ] [ j ] ) ; }
private int remaining Data ( ) { return buffer . remaining ( ) ; }
public static  List < ? extends  Node > evaluate XPath (  Document doc ,  String path ) throws  XPath Expression Exception {  XPath Factory factory =  XPath Factory . new Instance ( ) ;  XPath xpath = factory . new XPath ( ) ; xpath . set Namespace Context ( new  Namespace Resolver ( doc ) ) ;  XPath Expression expr = xpath . compile ( path ) ;  Node List nodes = (  Node List ) expr . evaluate ( doc ,  XPath Constants .  NODESET ) ;  List <  Node > nodelist = new  Array List <  Node > ( ) ; for ( int i = _ NUM ; i < nodes . get Length ( ) ; ++ i ) { nodelist . add ( nodes . item ( i ) ) ; }  LOG . trace (  String . format ( _ STR , path , node List To String ( nodelist ) ) ) ; return nodelist ; }
private void generate (  Region .  Entry entry ) throws  SAXException { if ( ( entry == null ) ) { return ; } handler . start Element ( _ STR ,  ENTRY ,  ENTRY ,  EMPTY ) ; handler . start Element ( _ STR ,  KEY ,  KEY ,  EMPTY ) ; generate ( entry . get Key ( ) ) ; handler . end Element ( _ STR ,  KEY ,  KEY ) ; handler . start Element ( _ STR ,  VALUE ,  VALUE ,  EMPTY ) ; generate ( entry . get Value ( ) ) ; handler . end Element ( _ STR ,  VALUE ,  VALUE ) ; handler . end Element ( _ STR ,  ENTRY ,  ENTRY ) ; }
public boolean is Primitive (  Type type ) throws  Exception { return is Primitive ( type . get Type ( ) ) ; }
@  Override public void action Performed (  Action Event ev ) { }
private void check Type Parameter (  Method method ) {  Type Variable <  Method > type Parameter = get Type Parameter ( method ) ; assert Equals ( _ STR , type Parameter . get Name ( ) ) ; assert Equals ( method , type Parameter . get Generic Declaration ( ) ) ; }
public static  List < ? extends  Node > child Node List (  Node node ) { if ( node == null ) return null ;  List <  Node > nodes = new  Linked List <  Node > ( ) ; do { if ( node . get Node Type ( ) ==  Node .  ELEMENT_ NODE || node . get Node Type ( ) ==  Node .  COMMENT_ NODE ) { nodes . add ( node ) ; } } while ( ( node = node . get Next Sibling ( ) ) != null ) ; return nodes ; }
@  Override public boolean connect (  String user Name ,  String password ) {  File file = new  File ( dir Name ) ; try { file = file . get Canonical File ( ) ; return ( file . exists ( ) ) ; } catch (  Exception e ) { e . print Stack Trace ( ) ; return ( _ BOOL ) ; } }
public void update League History ( ) {  Collections . sort ( team List , new  Team Comp Poll ( ) ) ;  String [ ] year Top10 = new  String [ _ NUM ] ;  Team tt ; for ( int i = _ NUM ; i < _ NUM ; ++ i ) { tt = team List . get ( i ) ; year Top10 [ i ] = tt . abbr + _ STR + tt . wins + _ STR + tt . losses + _ STR ; } league History . add ( year Top10 ) ; }
public void write String No Compression (  String str ) throws  IOException { if ( str == null ) { write Int ( _ NUM ) ; } else { write Int ( str . length ( ) ) ; for ( int i = _ NUM ; i < str . length ( ) ; i ++ ) outs . write ( ( byte ) str . char At ( i ) ) ; position += str . length ( ) ; } }
public void read (  Buffered Reader reader ) throws  Exception {  String line ; clear ( ) ; while ( ( line = reader . read Line ( ) ) != null ) { line = line . trim ( ) ; if ( line . starts With ( _ STR ) ) { continue ; } add ( line ) ; } reader . close ( ) ; }
private void stop Checking Status ( ) { executor . shutdown Now ( ) ; executor =  Executors . new Single Thread Executor ( ) ; future = null ; }
public static  Point normalize (  Point p , double length ) { double len =  Math . sqrt ( p . x * p . x + p . y * p . y ) ; length = length / len ; return new  Point ( p . x * length , p . y * length ) ; }
protected void on Result ( ) { }
public  Pojo Key Field (  Property Descriptor desc ) { super ( desc ) ; }
public static boolean is In Range (  String ip ,  String ip Range ) { if ( ip == null || ip Range == null ) return _ BOOL ;  String [ ] cidr String = ip Range . split ( _ STR ) ; if ( cidr String . length == _ NUM ) return _ BOOL ;  String network = cidr String [ _ NUM ] ;  String cidr Mask = _ STR ; if ( cidr String . length > _ NUM ) { cidr Mask = cidr String [ _ NUM ] ; }  String net Mask = cidr Mask To Net Mask ( cidr Mask ) ;  Inet Address masked IP = apply Mask ( ip , net Mask ) ;  Inet Address masked Network = apply Mask ( network , net Mask ) ; if ( masked IP == null || masked Network == null ) return _ BOOL ; return masked IP . equals ( masked Network ) ; }
private void load Environment ( ) {  Map <  String ,  String > env =  System . getenv ( ) ; for (  String env Name : env . key Set ( ) ) { set Parameter ( env Name , env . get ( env Name ) ) ; } }
public static  String join (  String separator , double ... elements ) { if ( elements == null || elements . length == _ NUM ) { return _ STR ; }  List <  Number > list = new  Array List <  Number > ( elements . length ) ; for (  Double elem : elements ) { list . add ( elem ) ; } return join ( separator , list ) ; }
public static void put Unsigned Byte (  Byte Buffer bb , short v , int offset ) { bb . put ( offset , ( byte ) ( v & _ NUM ) ) ; }
@  Override public  Trie optimize (  Trie orig ) {  List <  Char Sequence > cmds = orig . cmds ;  List <  Row > rows = new  Array List < > ( ) ;  List <  Row > orows = orig . rows ; int remap [ ] = new int [ orows . size ( ) ] ;  Arrays . fill ( remap , _ NUM ) ; for ( int j = orows . size ( ) - _ NUM ; j >= _ NUM ; j -- ) { if ( eat ( orows . get ( j ) , remap ) ) { remap [ j ] = _ NUM ; } }  Arrays . fill ( remap , - _ NUM ) ; rows = remove Gaps ( orig . root , orows , new  Array List <  Row > ( ) , remap ) ; return new  Trie ( orig . forward , remap [ orig . root ] , cmds , rows ) ; }
public boolean has Denied Permission ( ) { for ( int i = _ NUM ; i < m Perms . size ( ) ; i ++ ) { if ( m Perms . get ( m User Permission . get ( i ) ) ==  Package Manager .  PERMISSION_ DENIED ) return _ BOOL ; } return _ BOOL ; }
@  Override public  String to String Key ( ) {  String result ; int i ; result = _ STR ; for ( i = _ NUM ; i < get Col Count ( ) ; i ++ ) { if ( get Col Hidden ( i ) ) { continue ; } result +=  LEFT_ PARENTHESES + ( i + _ NUM ) +  RIGHT_ PARENTHESES + _ STR + remove Filter Name ( m_ Col Names [ i ] ) + _ STR ; } return result ; }
Date Time Formatter to Formatter (  Resolver Style resolver Style ,  Chronology chrono ) { return to Formatter (  Locale . get Default (  Locale .  Category .  FORMAT ) , resolver Style , chrono ) ; }
protected void wait For File To Grow (  File file ) throws  Exception { int current Wait Time = _ NUM ; while ( ! file . exists ( ) ) {  Log . i (  LOG_ TAG , _ STR ) ; current Wait Time = timeout Wait ( current Wait Time ,  WAIT_ FOR_ DOWNLOAD_ POLL_ TIME ,  MAX_ WAIT_ FOR_ DOWNLOAD_ TIME , _ STR ) ; } long original Size = file . length ( ) ; while ( file . length ( ) <= original Size ) {  Log . i (  LOG_ TAG , _ STR ) ; current Wait Time = timeout Wait ( current Wait Time ,  WAIT_ FOR_ DOWNLOAD_ POLL_ TIME ,  MAX_ WAIT_ FOR_ DOWNLOAD_ TIME , _ STR ) ; } }
public static boolean is Remote File (  String local File Name ) { return local File Name . contains ( _ STR ) ; }
public void prev ( ) { if (  D )  LOG . info ( _ STR ) ; synchronized ( this ) { if ( m Shuffle Mode ==  SHUFFLE_ NORMAL ) { final int histsize = m History . size ( ) ; if ( histsize == _ NUM ) { return ; } final  Integer pos = m History . remove ( histsize - _ NUM ) ; m Play Pos = pos . int Value ( ) ; } else { if ( m Play Pos > _ NUM ) { m Play Pos -- ; } else { m Play Pos = m Play List Len - _ NUM ; } } stop ( _ BOOL ) ; open Current ( ) ; play ( ) ; notify Change (  META_ CHANGED ) ; } }
public void test Reverse Step By One With Closure ( ) { final  List call Log = new  Array List ( ) ; final  Closure closure = new  Recording Closure ( call Log ) ; final  Range range = create Range ( _ NUM , _ NUM ) ; range . step ( _ NUM , closure ) ; assert Equals ( _ STR , _ NUM , call Log . size ( ) ) ; final  Iterator iter = call Log . iterator ( ) ; for ( int i = _ NUM ; i >= _ NUM ; i -- ) { assert Equals ( _ STR , create Value ( i ) , iter . next ( ) ) ; } }
private static  Big Decimal normalize Decimal Value (  Big Decimal big Decimal , int allowed Precision ) { if ( big Decimal . precision ( ) > allowed Precision ) { return null ; } return big Decimal ; }
protected static  String serialize DOMSource (  DOMSource dom Source ) { try {  String Writer writer = new  String Writer ( ) ;  Stream Result result = new  Stream Result ( writer ) ;  Transformer Factory tf =  Transformer Factory . new Instance ( ) ;  Transformer transformer = tf . new Transformer ( ) ; transformer . set Output Property (  Output Keys .  ENCODING ,  DEFAULT_ ENCODING ) ; transformer . set Output Property (  Output Keys .  INDENT ,  DEFAULT_ INDENT ) ; transformer . transform ( dom Source , result ) ; writer . flush ( ) ; return writer . to String ( ) ; } catch (  Throwable e ) { log . log (  Level .  SEVERE , _ STR , e ) ; } return null ; }
private  Event Node read ( ) throws  Exception {  XMLEvent event = reader . next Event ( ) ; if ( ! event . is End Document ( ) ) { if ( event . is Start Element ( ) ) { return start ( event ) ; } if ( event . is Characters ( ) ) { return text ( event ) ; } if ( event . is End Element ( ) ) { return end ( ) ; } return read ( ) ; } return null ; }
private void write Track Style ( ) { print Writer . println ( _ STR +  TRACK_ STYLE + _ STR ) ; print Writer . println ( _ STR ) ; print Writer . println ( _ STR ) ; print Writer . println ( _ STR ) ; print Writer . println ( _ STR +  TRACK_ ICON + _ STR ) ; print Writer . println ( _ STR ) ; print Writer . println ( _ STR ) ; }
public void update Article ( final  String article Id , final  JSONObject article ) throws  Service Exception { final  Transaction transaction = article Repository . begin Transaction ( ) ; try { final  String author Id = article . opt String (  Article .  ARTICLE_ AUTHOR_ ID ) ; final  JSONObject author = user Repository . get ( author Id ) ; article . put (  Article .  ARTICLE_ COMMENTABLE ,  Boolean . value Of ( article . opt Boolean (  Article .  ARTICLE_ COMMENTABLE ) ) ) ; final  JSONObject old Article = article Repository . get ( article Id ) ; process Tags For Article Update ( old Article , article , author ) ;  String article Title = article . opt String (  Article .  ARTICLE_ TITLE ) ; article Title =  Emotions . to Aliases ( article Title ) ; article . put (  Article .  ARTICLE_ TITLE , article Title ) ;  String article Content = article . opt String (  Article .  ARTICLE_ CONTENT ) ; article Content =  Emotions . to Aliases ( article Content ) ; article . put (  Article .  ARTICLE_ CONTENT , article Content ) ; user Repository . update ( author . opt String (  Keys .  OBJECT_ ID ) , author ) ; article Repository . update ( article Id , article ) ; transaction . commit ( ) ; } catch ( final  Exception e ) { if ( transaction . is Active ( ) ) { transaction . rollback ( ) ; }  LOGGER . log (  Level .  ERROR , _ STR + article Id + _ STR , e ) ; throw new  Service Exception ( e ) ; } }
public  Container remove Child ( @  Non Null  Display Object display Object ) { display Object . disable ( ) ; m Display List . remove ( display Object ) ; return this ; }
public static void close EL (  Output Stream os ) { try { if ( os != null ) os . close ( ) ; } catch (  Throwable e ) { } }
public void remove Search Listener (  Search Listener l ) { m_ Search Listeners . remove ( l ) ; }
public boolean is Single Value ( ) { return ( values . size ( ) == _ NUM ) ; }
public void edit (  File file ) throws  IOException { check AWTPermission ( ) ; check Exec ( ) ; check Action Support (  Action .  EDIT ) ; file . can Write ( ) ; check File Validation ( file ) ; peer . edit ( file ) ; }
Minguo Date (  Local Date iso Date ) {  Objects . require Non Null ( iso Date , _ STR ) ; this . iso Date = iso Date ; }
@  Override public void toggle Selection (  Photo photo ) { if ( selected Photos . contains ( photo ) ) { selected Photos . remove ( photo ) ; } else { selected Photos . add ( photo ) ; } }
protected void pre Collection ( ) { }
String char To String ( char c ) { if ( c < _ STR || c > _ NUM ) { return _ STR + ( int ) c ; } return  String . value Of ( c ) ; }
public static  String strip Generics (  String class Name ) {  String name = class Name ; if ( name . contains ( _ STR ) ) { name = name . substring ( _ NUM , name . index Of ( _ STR ) ) ; } if ( name . contains ( _ STR ) ) { name = name . substring ( _ NUM , name . index Of ( _ STR ) ) ; } return name ; }
protected  Issue Matcher add Property Matcher (  Issue Property Matcher property Matcher ) { issue Matcher . add Property Matcher (  Objects . require Non Null ( property Matcher ) ) ; return issue Matcher ; }
public boolean is Annotation Present (  Class < ? extends  Annotation > ann Type Test ) { for (  Class < ? > ann Type : _ann Types ) { if ( ann Type . equals ( ann Type Test ) ) { return _ BOOL ; } } return _ BOOL ; }
private static native int  Windows Reg Close Key ( int h Key ) ;
public synchronized void remove Property Change Listener (  Property Change Listener listener ) { listener List . remove ( listener ) ; }
@  Override public int following ( int offset ) {  Character Iterator text = get Text ( ) ; check Offset ( offset , text ) ; text . set Index ( offset ) ; if ( offset == text . get Begin Index ( ) ) { cached Last Known Break = handle Next ( ) ; return cached Last Known Break ; } int result = cached Last Known Break ; if ( result >= offset || result <=  Break Iterator .  DONE ) { result = handle Previous ( ) ; } else { text . set Index ( result ) ; } while ( result !=  Break Iterator .  DONE && result <= offset ) { result = handle Next ( ) ; } cached Last Known Break = result ; return result ; }
private void render Image ( ) {  Buffered Image bg Image = segment Images [ _ NUM ] [ _ NUM ] ; int w = bg Image . get Width ( ) ; int h = bg Image . get Height ( ) ;  Buffered Image result = new  Buffered Image ( w , h ,  Buffered Image .  TYPE_ INT_ ARGB ) ;  Graphics g = result . get Graphics ( ) ; g . draw Image ( bg Image , _ NUM , _ NUM , null ) ; int byte Number = _ NUM ; for ( byte b Value : manual Values ) { if ( byte Number > _ NUM && byte Number < _ NUM ) { for ( int bit Number = _ NUM ; bit Number < _ NUM ; bit Number ++ ) { if (  Format . is Bit Set ( b Value , bit Number ) ) {  Buffered Image img = segment Images [ byte Number ] [ bit Number ] ; if ( img != null ) { g . draw Image ( img , _ NUM , _ NUM , null ) ; } } } } byte Number += _ NUM ; } image Panel . set Image ( result ) ; image Panel . repaint ( ) ; }
public boolean starts With (  Name n ) { if ( n instanceof  Composite Name ) { return ( impl . starts With ( n . size ( ) , n . get All ( ) ) ) ; } else { return _ BOOL ; } }
public static  String compatible Field Name (  String original ) { if ( ! original . matches ( _ STR ) ) { return _ STR + original ; } else { return original ; } }
public void test Invoke Any6 ( ) throws  Throwable {  Executor Service e = new  Fork Join Pool ( _ NUM ) ;  Pool Cleaner cleaner = null ; try { cleaner = cleaner ( e ) ;  List <  Callable <  String > > l = new  Array List <  Callable <  String > > ( ) ; l . add ( new  String Task ( ) ) ; l . add ( new  String Task ( ) ) ;  String result = e . invoke Any ( l ) ; assert Same (  TEST_ STRING , result ) ; } finally { if ( cleaner != null ) { cleaner . close ( ) ; } } }
private  Hash Map <  String ,  String > read Config (  String config Path ) throws  Exception { log . debug ( _ STR + config Path ) ;  File config File = new  File ( config Path ) ; if ( ! config File . is File ( ) ) return null ;  Config Reader reader = new  Config Reader ( ) ; reader . read Config ( config Path ) ; return reader . get Config Map ( ) ; }
public byte [ ] to ASN1 ( ) { try { byte [ ] priv Key Bytes = get Priv Key Bytes ( ) ;  Byte Array Output Stream baos = new  Byte Array Output Stream ( _ NUM ) ;  DERSequence Generator seq = new  DERSequence Generator ( baos ) ; seq . add Object ( new  ASN1 Integer ( _ NUM ) ) ; seq . add Object ( new  DEROctet String ( priv Key Bytes ) ) ; seq . add Object ( new  DERTagged Object ( _ NUM ,  CURVE_ PARAMS . to ASN1 Primitive ( ) ) ) ; seq . add Object ( new  DERTagged Object ( _ NUM , new  DERBit String ( get Pub Key ( ) ) ) ) ; seq . close ( ) ; return baos . to Byte Array ( ) ; } catch (  IOException e ) { throw new  Runtime Exception ( e ) ; } }
public void start (  Calendar start Time ,  Calendar end Time ) { if ( start Time == null || end Time == null || start Time . after ( end Time ) ) { throw new  Illegal Argument Exception ( _ STR ) ; } m Start Time = start Time ; start ( end Time ) ; }
private  JMenu create File Menu ( ) {  JMenu file Menu = new  JMenu ( _ STR ) ; file Menu . add Menu Listener ( menu Listener ) ; for (  Action action : action Manager . get Open Save Workspace Actions ( ) ) { file Menu . add ( action ) ; } file Menu . add Separator ( ) ; file Menu . add ( action Manager . get Clear Workspace Action ( ) ) ; file Menu . add Separator ( ) ; file Menu . add ( action Manager . get Open Network Action ( ) ) ;  JMenu world Sub Menu = new  JMenu ( _ STR ) ; for (  Action action : action Manager . get Open World Actions ( ) ) { world Sub Menu . add ( action ) ; } file Menu . add ( world Sub Menu ) ; file Menu . add Separator ( ) ; file Menu . add ( action Manager . get Show Updater Dialog ( ) ) ; file Menu . add ( action Manager . get Show Property Dialog Action ( ) ) ; file Menu . add Separator ( ) ; file Menu . add ( action Manager . get Quit Workspace Action ( ) ) ; return file Menu ; }
private static  List retrieve Loggers ( ) {  List logger Names =  XRLog . list Registered Loggers ( ) ;  List loggers = new  Array List ( logger Names . size ( ) ) ;  Iterator it = logger Names . iterator ( ) ; while ( it . has Next ( ) ) { final  String ln = (  String ) it . next ( ) ; loggers . add (  Logger . get Logger ( ln ) ) ; } return loggers ; }
private void import Records ( ) { for (  X_ I_ Product_ BOM import BOM : get Records ( _ BOOL , m_ Is Import Only No Errors ) ) { is Imported = _ BOOL ;  MPPProduct BOM bom = get MPPProduct BOM ( import BOM ) ;  MPPProduct BOMLine bom Line = null ; if ( bom != null ) bom Line = import BOMLine ( bom , import BOM ) ; if ( bom Line != null ) { import BOM . set PP_ Product_ BOMLine_ ID ( bom Line . get PP_ Product_ BOMLine_ ID ( ) ) ; import BOM . set PP_ Product_ BOM_ ID ( bom . get_ ID ( ) ) ; imported ++ ; is Imported = _ BOOL ; } import BOM . set I_ Is Imported ( is Imported ) ; import BOM . set Processed ( is Imported ) ; import BOM . save Ex ( ) ; } }
private void add Signed Flag ( boolean is Signed ) { if ( is Signed List == null ) { is Signed List = new  Array List <  Boolean > ( ) ; } is Signed List . add (  Boolean . value Of ( is Signed ) ) ; }
@  Suppress Warnings ( { _ STR , _ STR , _ STR } ) public  Object parse Text (  String text ) { if ( text == null || text . length ( ) == _ NUM ) { throw new  Illegal Argument Exception ( _ STR ) ; } return parse ( new  Line Column Reader ( new  String Reader ( text ) ) ) ; }
public static void remove Log Filter (  Log Filter filter ) { if ( filter == null || filters == null || filters . is Empty ( ) ) { return ; } if ( filters . contains ( filter ) ) { filters . remove ( filter ) ; } }
@  Override public void action Performed (  Action Event e ) {  File Dialog chooser = new  File Dialog ( frame , _ STR ,  File Dialog .  SAVE ) ; chooser . set Visible ( _ BOOL ) ; if ( chooser . get File ( ) != null ) { save ( chooser . get Directory ( ) +  File . separator + chooser . get File ( ) ) ; } }
public void dispose ( ) { log Debug ( _ STR ) ; m Setup Done = _ BOOL ; if ( m Service Conn != null ) { log Debug ( _ STR ) ; if ( m Context != null && m Service != null ) m Context . unbind Service ( m Service Conn ) ; } m Disposed = _ BOOL ; m Context = null ; m Service Conn = null ; m Service = null ; m Purchase Listener = null ; }
public  String next Token ( ) {  String result = null ; synchronized ( this ) { if ( is Empty ( ) ) { return null ; } else { if ( is Eating Blocks Of Delimiters ) { trim Starting Delimiters ( ) ; } int nearest Delimeter = - _ NUM ; for ( int i = _ NUM ; i < delimiters . length ( ) ; i ++ ) { int delimiter = source . index Of ( delimiters . char At ( i ) , current Index ) ; if ( nearest Delimeter == - _ NUM || delimiter != - _ NUM && delimiter < nearest Delimeter ) { nearest Delimeter = delimiter ; } } if ( nearest Delimeter == - _ NUM ) { result = source . substring ( current Index ) ; current Index = source . length ( ) ; } else { result = source . substring ( current Index , nearest Delimeter ) ; current Index = nearest Delimeter + _ NUM ; if ( is Eating Blocks Of Delimiters ) { trim Starting Delimiters ( ) ; } } } } return result ; }
public  Collection asignar Fondo (  Collection detallesprestamos ) {  Gestion Fondos BI fondos Service = get Gestion Fondos BI ( ) ;  Array List detallesprestamos Final = new  Array List ( ) ; if ( detallesprestamos != null ) {  Iterator it = detallesprestamos . iterator ( ) ; while ( it . has Next ( ) ) {  Busqueda Detalle VO bdp = (  Busqueda Detalle VO ) it . next ( ) ;  Fondo VO fondoauxiliar = fondos Service . get Fondo XId ( bdp . get Idfondo ( ) ) ; bdp . set Fondo ( fondoauxiliar . get Titulo ( ) ) ; detallesprestamos Final . add ( bdp ) ; } } return detallesprestamos Final ; }
private void build Network ( final  Network network , int [ ] nodes Per Layer ,  Point2 D initial Position , final  Neuron input Neuron Template ) { set Label ( _ STR ) ;  List <  Neuron > input Layer Neurons = new  Array List <  Neuron > ( ) ; for ( int i = _ NUM ; i < nodes Per Layer [ _ NUM ] ; i ++ ) { input Layer Neurons . add ( new  Neuron ( network , input Neuron Template ) ) ; }  Neuron Group input Layer = new  Neuron Group ( network , input Layer Neurons ) ; input Layer . set Clamped ( _ BOOL ) ; add Neuron Group ( input Layer ) ; input Layer . set Layout Based On Size ( initial Position ) ;  Synapse synapse =  Synapse . get Template Synapse ( new  Static Synapse Rule ( ) ) ; synapse . set Lower Bound ( - _ NUM ) ; synapse . set Upper Bound ( _ NUM ) ;  Neuron Group last Layer = input Layer ; for ( int i = _ NUM ; i < nodes Per Layer . length ; i ++ ) {  List <  Neuron > hidden Layer Neurons = new  Array List <  Neuron > ( ) ; for ( int j = _ NUM ; j < nodes Per Layer [ i ] ; j ++ ) {  Sigmoidal Rule rule = new  Sigmoidal Rule ( ) ;  Neuron neuron = new  Neuron ( network , rule ) ; rule . set Lower Bound ( _ NUM ) ; neuron . set Update Priority ( i ) ; hidden Layer Neurons . add ( neuron ) ; }  Neuron Group hidden Layer = new  Neuron Group ( network , hidden Layer Neurons ) ; hidden Layer . set Layout Based On Size ( ) ; add Neuron Group ( hidden Layer ) ;  Network Layout Manager . offset Neuron Group ( last Layer , hidden Layer ,  Direction .  NORTH , between Layer Interval ) ;  All To All connection = new  All To All ( ) ;  Synapse Group lh = connect Neuron Groups ( last Layer , hidden Layer , connection ) ; lh . randomize Connection Weights ( ) ; last Layer = hidden Layer ; } }
private boolean equals Null (  String c1 ,  String c2 ) { if ( c1 == null ) c1 = _ STR ; if ( c2 == null ) c2 = _ STR ; return c1 . equals Ignore Case ( c2 ) ; }
public static  String ltrim (  String s ) { if ( s == null ) { return null ; } int index = _ NUM ; int len = s . length ( ) ; while ( index < len &&  Character . is Whitespace ( s . char At ( index ) ) ) { index ++ ; } return ( index >= len ) ? _ STR : s . substring ( index ) ; }
private  String parse Value (  String value ) { value = value . trim ( ) ; if ( value . char At ( _ NUM ) == _ STR && value . char At ( value . length ( ) - _ NUM ) == _ STR ) { value = value . substring ( _ NUM , value . length ( ) - _ NUM ) ; value = value . replace All ( _ STR , _ STR ) ; } return value ; }
public void create Accrual Based Journal Entries And Reversals For Loan ( final  Office office , final  String currency Code , final  Integer account Type To Be Debited , final  Integer account Type To Be Credited , final  Long loan Product Id , final  Long payment Type Id , final  Long loan Id , final  String transaction Id , final  Date transaction Date , final  Big Decimal amount , final  Boolean is Reversal ) { int account Type To Debit Id = account Type To Be Debited ; int account Type To Credit Id = account Type To Be Credited ; if ( is Reversal ) { account Type To Debit Id = account Type To Be Credited ; account Type To Credit Id = account Type To Be Debited ; } create Journal Entries For Loan ( office , currency Code , account Type To Debit Id , account Type To Credit Id , loan Product Id , payment Type Id , loan Id , transaction Id , transaction Date , amount ) ; }
public int read (  Byte Buffer dst , int dst Start , int dst Length ) throws  IOException { final int remaining = ( int )  Math . min ( this . length - this . position ,  Integer .  MAX_ VALUE ) ; final int read =  Math . min ( remaining , dst Length ) ; final int buffer Position = check Offset ( position , read ) ; final long src Address =  Platform Dependent . direct Buffer Address ( last Mapped ) + buffer Position ; if ( dst . is Direct ( ) ) { final long dst Address =  Platform Dependent . direct Buffer Address ( dst ) + dst Start ;  Platform Dependent . copy Memory ( src Address , dst Address , read ) ; } else { final byte [ ] dst Array = dst . array ( ) ;  Platform Dependent . copy Memory ( src Address , dst Array , dst Start , read ) ; } position += read ; return read ; }
public static  Double to Double (  Number self ) { if ( ( self instanceof  Double ) || ( self instanceof  Long ) || ( self instanceof  Integer ) || ( self instanceof  Short ) || ( self instanceof  Byte ) ) { return self . double Value ( ) ; } return  Double . value Of ( self . to String ( ) ) ; }
public double pdf ( int k ) { if ( k < _ NUM ) throw new  Illegal Argument Exception ( ) ; int r = this . n - k ; return  Math . exp ( this . log_n -  Arithmetic . log Factorial ( k ) -  Arithmetic . log Factorial ( r ) + this . log_p * k + this . log_q * r ) ; }
public static void append Unpadded Integer (  String Buffer buf , int value ) { if ( value < _ NUM ) { buf . append ( _ STR ) ; if ( value !=  Integer .  MIN_ VALUE ) { value = - value ; } else { buf . append ( _ STR + - ( long )  Integer .  MIN_ VALUE ) ; return ; } } if ( value < _ NUM ) { buf . append ( ( char ) ( value + _ STR ) ) ; } else if ( value < _ NUM ) { int d = ( ( value + _ NUM ) * _ NUM ) > > _ NUM ; buf . append ( ( char ) ( d + _ STR ) ) ; buf . append ( ( char ) ( value - ( d << _ NUM ) - ( d << _ NUM ) + _ STR ) ) ; } else { buf . append (  Integer . to String ( value ) ) ; } }
private void draw Text Elements (  Canvas canvas , float text Size ,  Typeface typeface ,  Color State List text Color ,  String [ ] texts , float [ ] text X , float [ ] text Y ,  Paint paint , int alpha , boolean show Activated , int activated Degrees , boolean activated Only ) { paint . set Text Size ( text Size ) ; paint . set Typeface ( typeface ) ; final float activated Index = activated Degrees / ( _ NUM /  NUM_ POSITIONS ) ; final int activated Floor = ( int ) activated Index ; final int activated Ceil = ( ( int )  Math . ceil ( activated Index ) ) %  NUM_ POSITIONS ; for ( int i = _ NUM ; i < _ NUM ; i ++ ) { final boolean activated = ( activated Floor == i || activated Ceil == i ) ; if ( activated Only && ! activated ) { continue ; } final int state Mask =  SUtils .  STATE_ ENABLED | ( show Activated && activated ?  SUtils .  STATE_ ACTIVATED : _ NUM ) ; final int color = text Color . get Color For State (  SUtils . resolve State Set ( state Mask ) , _ NUM ) ; paint . set Color ( color ) ; paint . set Alpha ( get Multiplied Alpha ( color , alpha ) ) ; canvas . draw Text ( texts [ i ] , text X [ i ] , text Y [ i ] , paint ) ; } }
public void test Find Spring Active Directory ( ) {  Ldap Proxy proxy = get Ldap AD ( ) ;  List result = null ; try { result = proxy . find ( get Ldap Search VO ( _ STR ,  Ldap Constants .  NO_ SEARCH_ LIMIT , null , null , null ,  Ldap Scope Constants .  SCOPE_ SUBTREE ) ) ; } catch (  Exception e ) { } assert Not Null ( result ) ; assert Equals ( _ NUM , result . size ( ) ) ; }
@  Override public void key Pressed (  Key Event e ) { synchronized ( key Lock ) { keys Down . add ( e . get Key Code ( ) ) ; } for (  Draw Listener listener : listeners ) listener . key Pressed ( e . get Key Code ( ) ) ; }
@  Override public int hash Code ( ) { return  Float . float To Int Bits ( get Boost ( ) ) ^ slop ^ term Arrays Hash Code ( ) ^ positions . hash Code ( ) ^ _ NUM ; }
private static  String descriptor To Class Name (  String s ) { if ( s . starts With ( _ STR ) || ! s . starts With ( _ STR ) ) return s ; return s . substring ( _ NUM , s . length ( ) - _ NUM ) ; }
protected  Connection State TLS (  SSLSession Impl session ) { try {  Cipher Suite cipher Suite = session . cipher Suite ; hash_size = cipher Suite . get MACLength ( ) ; boolean is_exportabe = cipher Suite . is Exportable ( ) ; int key_size = ( is_exportabe ) ? cipher Suite . key Material : cipher Suite . expanded Key Material ; int iv_size = cipher Suite . iv Size ; block_size = cipher Suite . get Block Size ( ) ;  String alg Name = cipher Suite . get Bulk Encryption Algorithm ( ) ;  String mac Name = cipher Suite . get Hmac Name ( ) ; if ( logger != null ) { logger . println ( _ STR ) ; logger . println ( _ STR + cipher Suite . get Name ( ) ) ; logger . println ( _ STR + alg Name ) ; logger . println ( _ STR + mac Name ) ; logger . println ( _ STR + hash_size ) ; logger . println ( _ STR + block_size ) ; logger . println ( _ STR + iv_size ) ; logger . println ( _ STR + key_size ) ; } byte [ ] client Random = session . client Random ; byte [ ] server Random = session . server Random ; byte [ ] key_block = new byte [ _ NUM * hash_size + _ NUM * key_size + _ NUM * iv_size ] ; byte [ ] seed = new byte [ client Random . length + server Random . length ] ;  System . arraycopy ( server Random , _ NUM , seed , _ NUM , server Random . length ) ;  System . arraycopy ( client Random , _ NUM , seed , server Random . length , client Random . length ) ;  PRF . compute PRF ( key_block , session . master_secret ,  KEY_ EXPANSION_ LABEL , seed ) ; byte [ ] client_mac_secret = new byte [ hash_size ] ; byte [ ] server_mac_secret = new byte [ hash_size ] ; byte [ ] client_key = new byte [ key_size ] ; byte [ ] server_key = new byte [ key_size ] ; boolean is_client = ! session . is Server ;  System . arraycopy ( key_block , _ NUM , client_mac_secret , _ NUM , hash_size ) ;  System . arraycopy ( key_block , hash_size , server_mac_secret , _ NUM , hash_size ) ;  System . arraycopy ( key_block , _ NUM * hash_size , client_key , _ NUM , key_size ) ;  System . arraycopy ( key_block , _ NUM * hash_size + key_size , server_key , _ NUM , key_size ) ;  Iv Parameter Spec client IV = null ;  Iv Parameter Spec server IV = null ; if ( is_exportabe ) {  System . arraycopy ( client Random , _ NUM , seed , _ NUM , client Random . length ) ;  System . arraycopy ( server Random , _ NUM , seed , client Random . length , server Random . length ) ; byte [ ] final_client_key = new byte [ cipher Suite . expanded Key Material ] ; byte [ ] final_server_key = new byte [ cipher Suite . expanded Key Material ] ;  PRF . compute PRF ( final_client_key , client_key ,  CLIENT_ WRITE_ KEY_ LABEL , seed ) ;  PRF . compute PRF ( final_server_key , server_key ,  SERVER_ WRITE_ KEY_ LABEL , seed ) ; client_key = final_client_key ; server_key = final_server_key ; if ( block_size != _ NUM ) { byte [ ] iv_block = new byte [ _ NUM * iv_size ] ;  PRF . compute PRF ( iv_block , null ,  IV_ BLOCK_ LABEL , seed ) ; client IV = new  Iv Parameter Spec ( iv_block , _ NUM , iv_size ) ; server IV = new  Iv Parameter Spec ( iv_block , iv_size , iv_size ) ; } } else if ( block_size != _ NUM ) { client IV = new  Iv Parameter Spec ( key_block , _ NUM * ( hash_size + key_size ) , iv_size ) ; server IV = new  Iv Parameter Spec ( key_block , _ NUM * ( hash_size + key_size ) + iv_size , iv_size ) ; } if ( logger != null ) { logger . println ( _ STR + is_exportabe ) ; logger . println ( _ STR ) ; logger . print ( session . master_secret ) ; logger . println ( _ STR ) ; logger . print ( client Random ) ; logger . println ( _ STR ) ; logger . print ( server Random ) ; logger . println ( _ STR ) ; logger . print ( client_mac_secret ) ; logger . println ( _ STR ) ; logger . print ( server_mac_secret ) ; logger . println ( _ STR ) ; logger . print ( client_key ) ; logger . println ( _ STR ) ; logger . print ( server_key ) ; if ( client IV == null ) { logger . println ( _ STR ) ; } else { logger . println ( _ STR ) ; logger . print ( client IV . get IV ( ) ) ; logger . println ( _ STR ) ; logger . print ( server IV . get IV ( ) ) ; } } if ( alg Name == null ) { enc Cipher = new  Null Cipher ( ) ; dec Cipher = new  Null Cipher ( ) ; } else { enc Cipher =  Cipher . get Instance ( alg Name ) ; dec Cipher =  Cipher . get Instance ( alg Name ) ; if ( is_client ) { enc Cipher . init (  Cipher .  ENCRYPT_ MODE , new  Secret Key Spec ( client_key , alg Name ) , client IV ) ; dec Cipher . init (  Cipher .  DECRYPT_ MODE , new  Secret Key Spec ( server_key , alg Name ) , server IV ) ; } else { enc Cipher . init (  Cipher .  ENCRYPT_ MODE , new  Secret Key Spec ( server_key , alg Name ) , server IV ) ; dec Cipher . init (  Cipher .  DECRYPT_ MODE , new  Secret Key Spec ( client_key , alg Name ) , client IV ) ; } } enc Mac =  Mac . get Instance ( mac Name ) ; dec Mac =  Mac . get Instance ( mac Name ) ; if ( is_client ) { enc Mac . init ( new  Secret Key Spec ( client_mac_secret , mac Name ) ) ; dec Mac . init ( new  Secret Key Spec ( server_mac_secret , mac Name ) ) ; } else { enc Mac . init ( new  Secret Key Spec ( server_mac_secret , mac Name ) ) ; dec Mac . init ( new  Secret Key Spec ( client_mac_secret , mac Name ) ) ; } } catch (  Exception e ) { e . print Stack Trace ( ) ; throw new  Alert Exception (  Alert Protocol .  INTERNAL_ ERROR , new  SSLProtocol Exception ( _ STR ) ) ; } }
public void add Label (  Label label ) { assert Not Null ( label ) ; labels . add ( label ) ; label . set Parent ( this ) ; }
public static long date Value From Date ( long ms ) {  Calendar cal = get Calendar ( ) ; cal . set Time In Millis ( ms ) ; return date Value From Calendar ( cal ) ; }
@  Override default  Completable Future <  Optional Long > min Long ( final  To Long Function < ? super  T > fn ) { return  Completable Future . supply Async ( null , get Exec ( ) ) ; }
private void determine Hosts As Property ( ) { if ( hosts . starts With ( _ STR ) && hosts . ends With ( _ STR ) ) {  String hosts Property = hosts . substring ( _ NUM , hosts . length ( ) - _ NUM ) ; hosts =  Property Util . get Property ( hosts Property ) ; if ( hosts == null ) { throw new  Illegal Argument Exception ( _ STR + hosts Property + _ STR ) ; } } }
public static char [ ] clone ( char [ ] array ) { char [ ] result = new char [ array . length ] ;  System . arraycopy ( array , _ NUM , result , _ NUM , array . length ) ; return result ; }
public void println (  Writer writer ) throws  IOException { print ( writer ) ; writer . write ( _ STR ) ; }
protected boolean no More Characters ( ) throws  IOException { if ( avail == _ NUM ) { avail = is . read ( buffer ) ; if ( avail <= _ NUM ) { avail = _ NUM ; return _ BOOL ; } pos = _ NUM ; } return _ BOOL ; }
public  Instances resample (  Random random ) {  Instances new Data = new  Instances ( this , num Instances ( ) ) ; while ( new Data . num Instances ( ) < num Instances ( ) ) { new Data . add ( instance ( random . next Int ( num Instances ( ) ) ) ) ; } return new Data ; }
@  Override protected  Node remove From Frontier ( ) {  Node result = frontier . remove ( ) ; explored . add ( result . get State ( ) ) ; frontier States . remove ( result . get State ( ) ) ; update Metrics ( frontier . size ( ) ) ; return result ; }
public static byte [ ] decode (  String data ) throws  Coder Exception { byte [ ] array = new byte [ data . length ( ) * _ NUM / _ NUM ] ; char [ ] block = new char [ _ NUM ] ; int length = _ NUM ; data = data . trim ( ) ; final int len = data . length ( ) ; if ( len == _ NUM ) return new byte [ _ NUM ] ; if ( len % _ NUM != _ NUM || len < _ NUM ) throw new  Coder Exception ( _ STR + print String ( data ) + _ STR ) ; for ( int position = _ NUM ; position < len ; ) { int p ; for ( p = _ NUM ; p < _ NUM && position < data . length ( ) ; position ++ ) { char c = data . char At ( position ) ; if ( !  Character . is Whitespace ( c ) ) { block [ p ] = c ; p ++ ; } } if ( p == _ NUM ) break ; int l = decode Group ( block , array , length ) ; length += l ; if ( l < _ NUM ) break ; } return  Arrays . copy Of ( array , length ) ; }
public void change Tick Font Size ( int delta ) {  Font f = get Tick Label Font ( ) ;  String f Name = f . get Font Name ( ) ;  Font new Font = new  Font ( f Name , f . get Style ( ) , ( f . get Size ( ) + delta ) ) ; set Tick Label Font ( new Font ) ; }
public static  String format Name For Class Loading (  String name ) { if ( name == null ) { return _ STR ; } if ( name . equals ( _ STR ) || name . equals ( _ STR ) || name . equals ( _ STR ) || name . equals ( _ STR ) || name . equals ( _ STR ) || name . equals ( _ STR ) || name . equals ( _ STR ) || name . equals ( _ STR ) || name . equals ( _ STR ) ) { return name ; } if ( name . starts With ( _ STR ) ) { return name . replace ( _ STR , _ STR ) ; } if ( name . starts With ( _ STR ) ) { name = name . substring ( _ NUM ) ; if ( name . ends With ( _ STR ) ) { name = name . substring ( _ NUM , name . length ( ) - _ NUM ) ; } return name . replace ( _ STR , _ STR ) ; }  String prefix = _ STR ; if ( name . ends With ( _ STR ) ) { prefix = _ STR ; name = name . substring ( _ NUM , name . length ( ) - _ NUM ) ; if ( name . equals ( _ STR ) ) { return prefix + _ STR ; } else if ( name . equals ( _ STR ) ) { return prefix + _ STR ; } else if ( name . equals ( _ STR ) ) { return prefix + _ STR ; } else if ( name . equals ( _ STR ) ) { return prefix + _ STR ; } else if ( name . equals ( _ STR ) ) { return prefix + _ STR ; } else if ( name . equals ( _ STR ) ) { return prefix + _ STR ; } else if ( name . equals ( _ STR ) ) { return prefix + _ STR ; } else if ( name . equals ( _ STR ) ) { return prefix + _ STR ; } else { return prefix + _ STR + name . replace ( _ STR , _ STR ) + _ STR ; } } return name . replace ( _ STR , _ STR ) ; }
public  String to Simple String ( ) {  String Buffer buffer = new  String Buffer ( ) ; buffer . append ( _ STR + m Label + _ STR + m YVals . size ( ) + _ STR ) ; return buffer . to String ( ) ; }
public static <  T >  T unchecked (  Callable <  T > callable ) { try { return callable . call ( ) ; } catch (  Exception e ) { return sneaky Throw ( e ) ; } }
private void install Selector For Protocol (  Dict proxy Settings ,  Protocol Dispatch Selector ps ,  String protocol ) {  String prefix = protocol . trim ( ) ; if ( is Active ( proxy Settings . get ( prefix + _ STR ) ) ) {  String proxy Host = (  String ) proxy Settings . get ( prefix + _ STR ) ; int proxy Port = (  Integer ) proxy Settings . get ( prefix + _ STR ) ;  Fixed Proxy Selector fp = new  Fixed Proxy Selector ( proxy Host , proxy Port ) ; ps . set Selector ( protocol . to Lower Case ( ) , fp ) ;  Logger . log ( get Class ( ) ,  Log Level .  TRACE , _ STR , protocol , proxy Host , proxy Port ) ; } }
public void load (  Input Stream in ) throws  IOException {  Input Stream Reader reader = new  Input Stream Reader ( in ) ;  Buffered Reader data = new  Buffered Reader ( reader ) ; for (  String ln = data . read Line ( ) ; ln != null ; ln = data . read Line ( ) ) { if ( ln . starts With ( _ STR ) ) { int len = ln . length ( ) ; int i = _ NUM ; while ( ( i < len ) && ( ln . char At ( i ) != _ STR ) ) i ++ ; int j = ++ i ; while ( ( j < len ) && ( ln . char At ( j ) != _ STR ) ) j ++ ;  String id = ln . substring ( i , j ) ; i = ++ j ; while ( ( i < len ) && ( ( ln . char At ( i ) == _ STR ) || ( ln . char At ( i ) == _ STR ) ) ) i ++ ; j = i + _ NUM ; while ( ( j < len ) && ( ln . char At ( j ) != _ STR ) && ( ln . char At ( j ) != _ STR ) ) j ++ ;  String where = ln . substring ( i , j ) ; put ( id , base Str + where ) ; } } data . close ( ) ; }
public static boolean is Monogamous (  Collection <  Family > families ) { final  Hash Set <  String > parents = new  Hash Set < > ( ) ; for (  Family f : families ) { if ( ! parents . add ( f . get Father ( ) ) ) { return _ BOOL ; } if ( ! parents . add ( f . get Mother ( ) ) ) { return _ BOOL ; } } return _ BOOL ; }
public void put (  String key ,  File file ,  String content Type ) throws  File Not Found Exception { if ( file == null || ! file . exists ( ) ) { throw new  File Not Found Exception ( ) ; } if ( key != null ) { file Params . put ( key , new  File Wrapper ( file , content Type ) ) ; } }
public static char [ ] [ ] load Image (  File file , char off Char ) throws  File Not Found Exception ,  Runtime Exception {  Array List <  String > rows =  Boolean Image Load . load Image Pad ( file , off Char ) ;  String s = rows . get ( _ NUM ) ; char [ ] [ ] img = new char [ rows . size ( ) ] [ s . length ( ) ] ; for ( int i = _ NUM ; i < rows . size ( ) ; i ++ ) { s = rows . get ( i ) ; for ( int j = _ NUM ; j < s . length ( ) ; j ++ ) { img [ i ] [ j ] = s . char At ( j ) ; } } return img ; }
@  Action ( value = _ STR ) @  Skip Validation public  String cancel Receipt ( ) { if ( get Selected Receipts ( ) != null && get Selected Receipts ( ) . length > _ NUM ) { receipt Header = receipt Header Service . find By Id (  Long . value Of ( selected Receipts [ _ NUM ] ) , _ BOOL ) ; load Receipt Details ( ) ; } return  Collection Constants .  CANCELRECEIPT ; }
public  Sparkle Motion animate (  Animation ... animations ) {  Collections . add All ( m Animations , animations ) ; return this ; }
private boolean matches Name (  String ... words ) { for (  String word : words ) { if ( ! name Words . contains ( word ) ) { return _ BOOL ; } } return _ BOOL ; }
public static int widen Subword (  Object x ) { if ( x instanceof  Integer ) return ( int ) x ; else if ( x instanceof  Boolean ) return from Boolean ( ( boolean ) x ) ; else if ( x instanceof  Character ) return ( char ) x ; else if ( x instanceof  Short ) return ( short ) x ; else if ( x instanceof  Byte ) return ( byte ) x ; else return ( int ) x ; }
public static void delete (  String path ) throws  IOException { if ( path != null ) delete (  Paths . get ( path ) ) ; }
public void add Operator (  Operator operator , int index ) { if ( operator == null ) { throw new  Null Pointer Exception ( _ STR ) ; } if ( operator instanceof  Process Root Operator ) { throw new  Illegal Argument Exception ( _ STR ) ; } operators . add ( index , operator ) ; register Operator ( operator , _ BOOL ) ; }
public int index Of Column Name (  String column Name ) { return column Name List . index Of ( column Name . to Lower Case ( ) ) ; }
public static  Protection Set check Protection Set Exists In DB (  Db Client db Client ,  String native Guid ) throws  IOException {  List <  Protection Set > cgs =  Custom Query Utility . get Active Protection Set By Native Guid ( db Client , native Guid ) ;  Iterator <  Protection Set > cgs Itr = cgs . iterator ( ) ; if ( cgs Itr . has Next ( ) ) { return cgs Itr . next ( ) ; } return null ; }
private  String generate Query (  String qry ,  Table Descriptor tbl ) throws  Ignite Checked Exception { assert tbl != null ; final  String qry0 = qry ;  String t = tbl . full Table Name ( ) ;  String from = _ STR ; qry = qry . trim ( ) ;  String upper = qry . to Upper Case ( ) ; if ( upper . starts With ( _ STR ) ) { qry = qry . substring ( _ NUM ) . trim ( ) ; final int star = qry . index Of ( _ STR ) ; if ( star == _ NUM ) qry = qry . substring ( _ NUM ) . trim ( ) ; else if ( star > _ NUM ) { if (  F . eq ( _ STR , qry . char At ( star - _ NUM ) ) ) { t = qry . substring ( _ NUM , star - _ NUM ) ; qry = qry . substring ( star + _ NUM ) . trim ( ) ; } else throw new  Ignite Checked Exception ( _ STR + qry0 ) ; } else throw new  Ignite Checked Exception ( _ STR + _ STR + qry0 ) ; upper = qry . to Upper Case ( ) ; } if ( ! upper . starts With ( _ STR ) ) from = _ STR + t + ( upper . starts With ( _ STR ) || upper . starts With ( _ STR ) || upper . starts With ( _ STR ) ? _ STR : _ STR ) ; qry = _ STR + t + _ STR +  KEY_ FIELD_ NAME + _ STR + t + _ STR +  VAL_ FIELD_ NAME + from + qry ; return qry ; }
public final  V update And Get (  T obj ,  Unary Operator <  V > update Function ) {  V prev , next ; do { prev = get ( obj ) ; next = update Function . apply ( prev ) ; } while ( ! compare And Set ( obj , prev , next ) ) ; return next ; }
public static void remove Activity Listener (  Activity Listener listener ) { listeners . remove ( listener ) ; }
public void stop Service (  Service service ) { if ( service == null ) { throw new  Illegal Argument Exception ( _ STR ) ; } stop Service ( service . get Self Link ( ) ) ; }
public static  Object [ ] pad Arguments (  Object [ ] args , int count ) { if ( count < args . length ) return args ; int i ;  Object [ ] result = new  Object [ count ] ; for ( i = _ NUM ; i < args . length ; i ++ ) { result [ i ] = args [ i ] ; } for ( ; i < count ; i ++ ) { result [ i ] =  Undefined . instance ; } return result ; }
private static boolean is Text Obscured (  JComponent c ,  String s ) {  Graphics g = c . get Graphics ( ) ;  Font Metrics fm = g . get Font Metrics ( c . get Font ( ) ) ; int sw = fm . string Width ( s ) ; return ( sw > c . get Width ( ) ) ; }
public  Windows Directory (  Path path ,  Lock Factory lock Factory ) throws  IOException { super ( path , lock Factory ) ; }
public static int find Minutes In Reminder List (  Array List <  Integer > values , int minutes ) { int index = values . index Of ( minutes ) ; if ( index == - _ NUM ) {  Log . e (  TAG , _ STR + minutes + _ STR ) ; return _ NUM ; } return index ; }
@  Override public void property Change ( java . beans .  Property Change Event e ) { log . debug ( _ STR + e . get Property Name ( ) + _ STR + e . get Old Value ( ) + _ STR + e . get New Value ( ) ) ; }
public  Distribution ( float [ ] values ) { assert ( values != null && values . length > _ NUM ) ;  Arrays . sort ( values ) ; ordered Values = values . clone ( ) ; }
private  Object Animator create Entering Image Matrix Animator ( ) {  Matrix init Matrix =  Matrix Utils . get Image Matrix ( m Animated Image ) ; init Matrix . get Values ( m Init Thumbnail Matrix Values ) ; final  Matrix end Matrix =  Matrix Utils . get Image Matrix ( m Image To ) ;  Log . v (  TAG , _ STR +  Arrays . to String ( m Init Thumbnail Matrix Values ) ) ;  Log . v (  TAG , _ STR + init Matrix ) ;  Log . v (  TAG , _ STR + end Matrix ) ; m Animated Image . set Scale Type (  Image View .  Scale Type .  MATRIX ) ; return  Object Animator . of Object ( m Animated Image ,  Matrix Evaluator .  ANIMATED_ TRANSFORM_ PROPERTY , new  Matrix Evaluator ( ) , init Matrix , end Matrix ) ; }
@  Override public synchronized void close ( ) throws  SQLException { if ( conn != null ) { try { conn . close ( ) ; } finally { conn = null ; } } }
public void add Index (  IIndex index ) { if ( index != null ) { indices . add ( index ) ; } }
public void enable Cookie ( ) { is Enable Cookie = _ BOOL ; if ( m Cookie Manager == null ) { m Cookie Manager = new  Cookie Manager ( new  Persistent Cookie Store ( m Context ) ,  Cookie Policy .  ACCEPT_ ALL ) ;  Cookie Handler . set Default ( m Cookie Manager ) ; } }
public void add Model (  Model model ) { models . add ( model ) ; }
private int decode Channel Wordlen ( int ch Num ) { int ret ;  Channel chan = ctx . channels [ ch Num ] ;  Channel ref Chan = ctx . channels [ _ NUM ] ; int weight Idx = _ NUM ; chan . fill Mode = _ NUM ; switch ( br . read ( _ NUM ) ) { case _ NUM : for ( int i = _ NUM ; i < ctx . num Quant Units ; i ++ ) { chan . qu Wordlen [ i ] = br . read ( _ NUM ) ; } break ; case _ NUM : if ( ch Num > _ NUM ) { ret = num Coded Units ( chan ) ; if ( ret < _ NUM ) { return ret ; } if ( chan . num Coded Vals > _ NUM ) {  VLC vlc Tab = wl_vlc_tabs [ br . read ( _ NUM ) ] ; for ( int i = _ NUM ; i < chan . num Coded Vals ; i ++ ) { int delta = vlc Tab . get VLC2 ( br ) ; chan . qu Wordlen [ i ] = ( ref Chan . qu Wordlen [ i ] + delta ) & _ NUM ; } } } else { weight Idx = br . read ( _ NUM ) ; ret = num Coded Units ( chan ) ; if ( ret < _ NUM ) { return ret ; } if ( chan . num Coded Vals > _ NUM ) { int pos = br . read ( _ NUM ) ; if ( pos > chan . num Coded Vals ) { log . error (  String . format ( _ STR , pos ) ) ; return  AT3 P_ ERROR ; } int delta Bits = br . read ( _ NUM ) ; int min Val = br . read ( _ NUM ) ; for ( int i = _ NUM ; i < pos ; i ++ ) { chan . qu Wordlen [ i ] = br . read ( _ NUM ) ; } for ( int i = pos ; i < chan . num Coded Vals ; i ++ ) { chan . qu Wordlen [ i ] = ( min Val + get Delta ( delta Bits ) ) & _ NUM ; } } } break ; case _ NUM : ret = num Coded Units ( chan ) ; if ( ret < _ NUM ) { return ret ; } if ( ch Num > _ NUM && chan . num Coded Vals > _ NUM ) {  VLC vlc Tab = wl_vlc_tabs [ br . read ( _ NUM ) ] ; int delta = vlc Tab . get VLC2 ( br ) ; chan . qu Wordlen [ _ NUM ] = ( ref Chan . qu Wordlen [ _ NUM ] + delta ) & _ NUM ; for ( int i = _ NUM ; i < chan . num Coded Vals ; i ++ ) { int diff = ref Chan . qu Wordlen [ i ] - ref Chan . qu Wordlen [ i - _ NUM ] ; delta = vlc Tab . get VLC2 ( br ) ; chan . qu Wordlen [ i ] = ( chan . qu Wordlen [ i - _ NUM ] + diff + delta ) & _ NUM ; } } else if ( chan . num Coded Vals > _ NUM ) { boolean flag = br . read Bool ( ) ;  VLC vlc Tab = wl_vlc_tabs [ br . read ( _ NUM ) ] ; int start Val = br . read ( _ NUM ) ; unpack Vq Shape ( start Val , atrac3p_wl_shapes [ start Val ] [ br . read ( _ NUM ) ] , chan . qu Wordlen , chan . num Coded Vals ) ; if ( ! flag ) { for ( int i = _ NUM ; i < chan . num Coded Vals ; i ++ ) { int delta = vlc Tab . get VLC2 ( br ) ; chan . qu Wordlen [ i ] = ( chan . qu Wordlen [ i ] + delta ) & _ NUM ; } } else { int i ; for ( i = _ NUM ; i < ( chan . num Coded Vals & - _ NUM ) ; i += _ NUM ) { if ( ! br . read Bool ( ) ) { chan . qu Wordlen [ i ] = ( chan . qu Wordlen [ i ] + vlc Tab . get VLC2 ( br ) ) & _ NUM ; chan . qu Wordlen [ i + _ NUM ] = ( chan . qu Wordlen [ i + _ NUM ] + vlc Tab . get VLC2 ( br ) ) & _ NUM ; } } if ( ( chan . num Coded Vals & _ NUM ) != _ NUM ) { chan . qu Wordlen [ i ] = ( chan . qu Wordlen [ i ] + vlc Tab . get VLC2 ( br ) ) & _ NUM ; } } } break ; case _ NUM : weight Idx = br . read ( _ NUM ) ; ret = num Coded Units ( chan ) ; if ( ret < _ NUM ) { return ret ; } if ( chan . num Coded Vals > _ NUM ) {  VLC vlc Tab = wl_vlc_tabs [ br . read ( _ NUM ) ] ; chan . qu Wordlen [ _ NUM ] = br . read ( _ NUM ) ; for ( int i = _ NUM ; i < chan . num Coded Vals ; i ++ ) { int delta = vlc Tab . get VLC2 ( br ) ; chan . qu Wordlen [ i ] = ( chan . qu Wordlen [ i - _ NUM ] + delta ) & _ NUM ; } } break ; } if ( chan . fill Mode == _ NUM ) { for ( int i = chan . num Coded Vals ; i < ctx . num Quant Units ; i ++ ) { chan . qu Wordlen [ i ] = ( ch Num > _ NUM ? br . read1 ( ) : _ NUM ) ; } } else if ( chan . fill Mode == _ NUM ) { int pos = ( ch Num > _ NUM ? chan . num Coded Vals + chan . split Point : ctx . num Quant Units - chan . split Point ) ; for ( int i = chan . num Coded Vals ; i < pos ; i ++ ) { chan . qu Wordlen [ i ] = _ NUM ; } } if ( weight Idx != _ NUM ) { return add Wordlen Weights ( chan , weight Idx ) ; } return _ NUM ; }
final void unfactor (  IR ir ) { for (  Enumeration <  Instruction > e = forward Real Instr Enumerator ( ) ; e . has More Elements ( ) ; ) {  Instruction s = e . next Element ( ) ;  Enumeration <  Basic Block > exp Outs = get Applicable Exceptional Out ( s ) ; if ( exp Outs . has More Elements ( ) && e . has More Elements ( ) ) {  Basic Block next = split Node With Links At ( s , ir ) ; next . unfactor ( ir ) ; prune Exceptional Out ( ir ) ; return ; } } }
private  Array List <  Array DBIDs > build One Dim Indexes (  Relation < ? extends  Number Vector > relation ) { final int dim =  Relation Util . dimensionality ( relation ) ;  Array List <  Array DBIDs > subspace Index = new  Array List < > ( dim + _ NUM ) ;  Sort DBIDs By Single Dimension comp = new  Vector Util .  Sort DBIDs By Single Dimension ( relation ) ; for ( int i = _ NUM ; i < dim ; i ++ ) {  Array Modifiable DBIDs am DBIDs =  DBIDUtil . new Array ( relation . get DBIDs ( ) ) ; comp . set Dimension ( i ) ; am DBIDs . sort ( comp ) ; subspace Index . add ( am DBIDs ) ; } return subspace Index ; }
public static boolean is File Upload Available ( ) { return is File Upload Available ( _ BOOL ) ; }
public static  String print Line (  String a , int num ) {  String Builder builder = new  String Builder ( ) ; for ( int i = _ NUM ; i < num ; i ++ ) { builder . append ( a ) ; } return builder . to String ( ) ; }
public static  Charset for Content Type (  String content Type ) { return for Content Type ( content Type ,  DEFAULT_ HTTP_ ENCODING ) ; }
@  Benchmark public void no Coding ( ) { run ( ) ; }
private void r Move To ( float dx , float dy ) { dx += m Last X ; dy += m Last Y ; m Path . move To ( m Last X = dx , m Last Y = dy ) ; }
private  List <  String > read Lines ( final  Buffered Reader reader ) throws  IOException { final  List <  String > lines = new  Array List < > ( ) ;  String line ; for ( int line Number = _ NUM ; ( line = reader . read Line ( ) ) != null ; line Number ++ ) { if ( line . starts With ( _ STR ) ) { final int last Line Index = lines . size ( ) - _ NUM ; final  String previous Line = lines . get ( last Line Index ) ; if ( lines . is Empty ( ) || previous Line . is Empty ( ) ) { throw  Decode Exception . fatal Error (  ERR_ TEMPLATE_ FILE_ INVALID_ LEADING_ SPACE . get ( line Number , line ) ) ; } lines . set ( last Line Index , previous Line + line . substring ( _ NUM ) ) ; } else { lines . add ( line ) ; } } return lines ; }
protected void send End Of Header ( final  Output Stream out ) throws  IOException {  LOG . trace ( _ STR ) ; out . write (  CRLF_ BYTES ) ; out . write (  CRLF_ BYTES ) ; }
public void add Actual Min (  Big Decimal add ) { m_actual Min = m_actual Min . add ( add ) ; }
private  Number parse Int (  String value ) {  Long l =  Long . value Of ( value ) ; if ( l . int Value ( ) == l ) { return l . int Value ( ) ; } return l ; }
public void print Stack Trace (  Print Writer pw ) { pw . println ( fetch Stack Trace ( ) ) ; }
public void add Body (  Body arg Body ) { bodies . add ( arg Body ) ; if ( bodies . size ( ) == _ NUM ) { body A = arg Body ; } if ( bodies . size ( ) == _ NUM ) { body B = arg Body ; } }
public void read Data (  Data Input din ) throws  IOException { reference = din . read Unsigned Short ( ) ; bit Count = din . read Unsigned Short ( ) ; }
public void add ( int index ,  E element ) { final  Reentrant Lock lock = this . lock ; lock . lock ( ) ; try {  Object [ ] elements = get Array ( ) ; int len = elements . length ; if ( index > len || index < _ NUM ) throw new  Index Out Of Bounds Exception ( _ STR + index + _ STR + len ) ;  Object [ ] new Elements ; int num Moved = len - index ; if ( num Moved == _ NUM ) new Elements =  Arrays . copy Of ( elements , len + _ NUM ) ; else { new Elements = new  Object [ len + _ NUM ] ;  System . arraycopy ( elements , _ NUM , new Elements , _ NUM , index ) ;  System . arraycopy ( elements , index , new Elements , index + _ NUM , num Moved ) ; } new Elements [ index ] = element ; set Array ( new Elements ) ; } finally { lock . unlock ( ) ; } }
void create Edges (  String [ ] v ) { graph . add Edge ( new  Double (  Math . random ( ) ) , v [ _ NUM ] , v [ _ NUM ] ,  Edge Type .  DIRECTED ) ; graph . add Edge ( new  Double (  Math . random ( ) ) , v [ _ NUM ] , v [ _ NUM ] ,  Edge Type .  DIRECTED ) ; graph . add Edge ( new  Double (  Math . random ( ) ) , v [ _ NUM ] , v [ _ NUM ] ,  Edge Type .  DIRECTED ) ; graph . add Edge ( new  Double (  Math . random ( ) ) , v [ _ NUM ] , v [ _ NUM ] ,  Edge Type .  DIRECTED ) ; graph . add Edge ( new  Double (  Math . random ( ) ) , v [ _ NUM ] , v [ _ NUM ] ,  Edge Type .  DIRECTED ) ; graph . add Edge ( new  Double (  Math . random ( ) ) , v [ _ NUM ] , v [ _ NUM ] ,  Edge Type .  DIRECTED ) ; graph . add Edge ( new  Double (  Math . random ( ) ) , v [ _ NUM ] , v [ _ NUM ] ,  Edge Type .  DIRECTED ) ; graph . add Edge ( new  Double (  Math . random ( ) ) , v [ _ NUM ] , v [ _ NUM ] ,  Edge Type .  DIRECTED ) ; graph . add Edge ( new  Double (  Math . random ( ) ) , v [ _ NUM ] , v [ _ NUM ] ,  Edge Type .  DIRECTED ) ; graph . add Edge ( new  Double (  Math . random ( ) ) , v [ _ NUM ] , v [ _ NUM ] ,  Edge Type .  DIRECTED ) ; graph . add Edge ( new  Double (  Math . random ( ) ) , v [ _ NUM ] , v [ _ NUM ] ,  Edge Type .  DIRECTED ) ; graph . add Edge ( new  Double (  Math . random ( ) ) , v [ _ NUM ] , v [ _ NUM ] ,  Edge Type .  DIRECTED ) ; graph . add Edge ( new  Double (  Math . random ( ) ) , v [ _ NUM ] , v [ _ NUM ] ,  Edge Type .  DIRECTED ) ; graph . add Edge ( new  Double (  Math . random ( ) ) , v [ _ NUM ] , v [ _ NUM ] ,  Edge Type .  DIRECTED ) ; graph . add Edge ( new  Double (  Math . random ( ) ) , v [ _ NUM ] , v [ _ NUM ] ,  Edge Type .  DIRECTED ) ; graph . add Edge ( new  Double (  Math . random ( ) ) , v [ _ NUM ] , v [ _ NUM ] ,  Edge Type .  DIRECTED ) ; graph . add Edge ( new  Double (  Math . random ( ) ) , v [ _ NUM ] , v [ _ NUM ] ,  Edge Type .  DIRECTED ) ; }
@  Suppress Warnings ( _ STR ) public  Data Response paginate List (  Map <  String ,  String > request Params ,  Query query ,  String default Sort ,  Map <  String ,  Query Property > properties ) { return paginate List ( request Params , null , query , default Sort , properties ) ; }
private <  T extends  Component >  T build Row ( final  JPanel panel , final  IType Description description , final  String hint , final  T component , final boolean is Last ) { component . set Preferred Size ( new  Dimension (  COLORPANEL_ WIDTH ,  COLORPANEL_ HEIGHT ) ) ; final  JPanel row Panel = new  JPanel ( new  Border Layout ( ) ) ; row Panel . set Border ( new  Empty Border ( _ NUM , _ NUM , is Last ? _ NUM : _ NUM , _ NUM ) ) ; final  JPanel inner Panel = new  JPanel ( new  Grid Layout ( _ NUM , _ NUM ) ) ; inner Panel . add ( new  JCheck Box ( new  Checkbox Action ( description , description . get Description ( ) + _ STR ) ) ,  Border Layout .  CENTER ) ; inner Panel . add (  CHint Creator . create Hint Panel ( component , hint ) ,  Border Layout .  EAST ) ; row Panel . add ( inner Panel ,  Border Layout .  WEST ) ; panel . add ( row Panel ) ; return component ; }
public void arc To ( double rx , double ry , double x Axis Rotation , boolean large Arc Flag , boolean sweep Flag , double x , double y ) { if ( rx == _ NUM || ry == _ NUM ) { line To ( x , y ) ; return ; }  Node last Point = get ( size ( ) - _ NUM ) ; double x0 = ( ( last Point . mask &  C2_ MASK ) ==  C2_ MASK ) ? last Point . x [ _ NUM ] : last Point . x [ _ NUM ] ; double y0 = ( ( last Point . mask &  C2_ MASK ) ==  C2_ MASK ) ? last Point . y [ _ NUM ] : last Point . y [ _ NUM ] ; if ( x0 == x && y0 == y ) { return ; } double dx2 = ( x0 - x ) / _ NUM ; double dy2 = ( y0 - y ) / _ NUM ; double angle =  Math . to Radians ( x Axis Rotation ) ; double cos Angle =  Math . cos ( angle ) ; double sin Angle =  Math . sin ( angle ) ; double x1 = ( cos Angle * dx2 + sin Angle * dy2 ) ; double y1 = ( - sin Angle * dx2 + cos Angle * dy2 ) ; rx =  Math . abs ( rx ) ; ry =  Math . abs ( ry ) ; double  Prx = rx * rx ; double  Pry = ry * ry ; double  Px1 = x1 * x1 ; double  Py1 = y1 * y1 ; double radii Check =  Px1 /  Prx +  Py1 /  Pry ; if ( radii Check > _ NUM ) { rx =  Math . sqrt ( radii Check ) * rx ; ry =  Math . sqrt ( radii Check ) * ry ;  Prx = rx * rx ;  Pry = ry * ry ; } double sign = ( large Arc Flag == sweep Flag ) ? - _ NUM : _ NUM ; double sq = ( (  Prx *  Pry ) - (  Prx *  Py1 ) - (  Pry *  Px1 ) ) / ( (  Prx *  Py1 ) + (  Pry *  Px1 ) ) ; sq = ( sq < _ NUM ) ? _ NUM : sq ; double coef = ( sign *  Math . sqrt ( sq ) ) ; double cx1 = coef * ( ( rx * y1 ) / ry ) ; double cy1 = coef * - ( ( ry * x1 ) / rx ) ; double sx2 = ( x0 + x ) / _ NUM ; double sy2 = ( y0 + y ) / _ NUM ; double cx = sx2 + ( cos Angle * cx1 - sin Angle * cy1 ) ; double cy = sy2 + ( sin Angle * cx1 + cos Angle * cy1 ) ; double ux = ( x1 - cx1 ) / rx ; double uy = ( y1 - cy1 ) / ry ; double vx = ( - x1 - cx1 ) / rx ; double vy = ( - y1 - cy1 ) / ry ; double p , n ; n =  Math . sqrt ( ( ux * ux ) + ( uy * uy ) ) ; p = ux ; sign = ( uy < _ NUM ) ? - _ NUM : _ NUM ; double angle Start =  Math . to Degrees ( sign *  Math . acos ( p / n ) ) ; n =  Math . sqrt ( ( ux * ux + uy * uy ) * ( vx * vx + vy * vy ) ) ; p = ux * vx + uy * vy ; sign = ( ux * vy - uy * vx < _ NUM ) ? - _ NUM : _ NUM ; double angle Extent =  Math . to Degrees ( sign *  Math . acos ( p / n ) ) ; if ( ! sweep Flag && angle Extent > _ NUM ) { angle Extent -= _ NUM ; } else if ( sweep Flag && angle Extent < _ NUM ) { angle Extent += _ NUM ; } angle Extent %= _ NUM ; angle Start %= _ NUM ;  Arc2 D .  Double arc = new  Arc2 D .  Double ( cx - rx , cy - ry , rx * _ NUM , ry * _ NUM , - angle Start , - angle Extent ,  Arc2 D .  OPEN ) ;  Path Iterator i = arc . get Path Iterator (  Affine Transform . get Rotate Instance ( angle , arc . get Center X ( ) , arc . get Center Y ( ) ) ) ; double [ ] coords = new double [ _ NUM ] ; i . next ( ) ; while ( ! i . is Done ( ) ) { int type = i . current Segment ( coords ) ; switch ( type ) { case  Path Iterator .  SEG_ CLOSE : break ; case  Path Iterator .  SEG_ CUBICTO : curve To ( coords [ _ NUM ] , coords [ _ NUM ] , coords [ _ NUM ] , coords [ _ NUM ] , coords [ _ NUM ] , coords [ _ NUM ] ) ; break ; case  Path Iterator .  SEG_ LINETO : line To ( coords [ _ NUM ] , coords [ _ NUM ] ) ; break ; case  Path Iterator .  SEG_ MOVETO : break ; case  Path Iterator .  SEG_ QUADTO : quad To ( coords [ _ NUM ] , coords [ _ NUM ] , coords [ _ NUM ] , coords [ _ NUM ] ) ; break ; } i . next ( ) ; } }
private void sync Meta Transients ( ) { if ( m_meta Transient Bits == null || m_meta Transient Bits . length != m_meta Bits . length ) { m_meta Transient Bits = ( int [ ] ) m_meta Bits . clone ( ) ; } else {  System . arraycopy ( m_meta Bits , _ NUM , m_meta Transient Bits , _ NUM , m_meta Transient Bits . length ) ; } }
private void open Counter Data Output Stream ( ) throws  Data Fallback Exception { if ( d Output == null ) { if (  LOG . is Debug Enabled ( ) )  LOG . debug ( _ STR + counter File . get Name ( ) + _ STR ) ; try { d Output = new  Buffered Writer ( new  File Writer ( counter File ) ) ; } catch (  IOException e ) { throw new  Data Fallback Exception ( e . get Message ( ) ) ; } } }
private static  String parse Version Number (  String line ) {  String Tokenizer tokenizer = new  String Tokenizer ( line , _ STR ) ; if ( ! expect ( tokenizer , _ STR ) || ! expect ( tokenizer , _ STR ) || ! tokenizer . has More Tokens ( ) ) { return null ; } return tokenizer . next Token ( ) ; }
public final  String to XML ( ) {  String Buffer str = new  String Buffer ( ) ; str . append ( _ STR ) ; str . append (  XML_ ROOT_ ELEMENT ) ; str . append ( _ STR ) ; str . append (  XML_ ATTRIBUTE_ ID ) ; str . append ( _ STR ) ; str . append ( id ) ; str . append ( _ STR ) ; str . append (  XML_ ATTRIBUTE_ NAME ) ; str . append ( _ STR ) ; str . append ( name ) ; str . append ( _ STR ) ; if ( value != null ) { str . append ( _ STR ) ; str . append ( get Data Type ( ) ) ; str . append ( _ STR ) ; str . append ( value . to String ( ) ) ; str . append ( _ STR ) ; } if ( value Description != null ) { str . append ( _ STR ) ; str . append ( value Description ) ; str . append ( _ STR ) ; } str . append ( _ STR ) ; str . append ( quality Code . to String ( ) ) ; str . append ( _ STR ) ; if ( quality Description != null ) { str . append ( _ STR ) ; str . append ( quality Description ) ; str . append ( _ STR ) ; } str . append ( _ STR ) ; str . append ( dynamic Filtered ) ; str . append ( _ STR ) ; str . append ( _ STR ) ; str . append ( filter Applied ) ; str . append ( _ STR ) ; str . append ( _ STR ) ; str . append ( timestamp . get Time ( ) ) ; str . append ( _ STR ) ; str . append ( _ STR ) ; str . append (  XML_ ROOT_ ELEMENT ) ; str . append ( _ STR ) ; return str . to String ( ) ; }
@  Override public  Array List <  Object > [ ] mine CARs (  Instances data ) throws  Exception { m_car = _ BOOL ; build Associations ( data ) ; return m_all The Rules ; }
public void test Float Value Pos ( ) {  String a = _ STR ;  Big Decimal a Number = new  Big Decimal ( a ) ; float result = _ NUM ; assert True ( _ STR , a Number . float Value ( ) == result ) ; }
public static  String replace Last (  String s ,  String sub ,  String with ) { int i = s . last Index Of ( sub ) ; if ( i == - _ NUM ) { return s ; } return s . substring ( _ NUM , i ) + with + s . substring ( i + sub . length ( ) ) ; }
private  Math Helper ( ) { }
public void add Object (  Object o ) throws  Exception { inspect ( o . get Class ( ) ) ; }
public static void main (  String [ ] args ) {  System . set Property ( _ STR , _ STR ) ;  JFrame frame = new  JFrame ( ) ; frame . set Content Pane ( new  Bowler Studio3d Engine ( ) ) ; frame . set Size ( _ NUM , _ NUM ) ; frame . set Visible ( _ BOOL ) ; frame . set Default Close Operation (  JFrame .  EXIT_ ON_ CLOSE ) ; }
@  Override public int hash Code ( ) { return value . hash Code ( ) ; }
public final void test Add All Helper Text Colors From Collection ( ) { int helper Text Color1 =  Color .  BLACK ; int helper Text Color2 =  Color .  GRAY ;  Collection <  Integer > helper Text Colors1 = new  Linked List < > ( ) ; helper Text Colors1 . add ( helper Text Color1 ) ; helper Text Colors1 . add ( helper Text Color2 ) ;  Password Edit Text password Edit Text = new  Password Edit Text ( get Context ( ) ) ; password Edit Text . add All Helper Text Colors ( helper Text Colors1 ) ; password Edit Text . add All Helper Text Colors ( helper Text Colors1 ) ;  Collection <  Integer > helper Text Colors2 = password Edit Text . get Helper Text Colors ( ) ; assert Equals ( helper Text Colors1 . size ( ) , helper Text Colors2 . size ( ) ) ;  Iterator <  Integer > iterator = helper Text Colors2 . iterator ( ) ; assert Equals ( helper Text Color1 , ( int ) iterator . next ( ) ) ; assert Equals ( helper Text Color2 , ( int ) iterator . next ( ) ) ; }
protected void append (  String s ) {  Buffered Writer writer ; if ( m_ Log File == null ) return ; try { writer = new  Buffered Writer ( new  File Writer ( m_ Log File , _ BOOL ) ) ; writer . write ( s ) ; writer . flush ( ) ; writer . close ( ) ; } catch (  Exception e ) { } }
public int hash Code ( ) { int hash Code = this . hash Code ; if ( hash Code == _ NUM ) { hash Code = ( ( group Id . hash Code ( ) * _ NUM + artifact Id . hash Code ( ) ) * _ NUM + version . hash Code ( ) ) * _ NUM + classifier . hash Code ( ) ; if ( hash Code == _ NUM ) { hash Code = - _ NUM ; } this . hash Code = hash Code ; } return hash Code ; }
public void write File (  String name ,  String mime Type ,  String file Name ,  Input Stream is ) throws  IOException { if ( is == null ) { throw new  Illegal Argument Exception ( _ STR ) ; } if ( file Name == null || file Name . is Empty ( ) ) { throw new  Illegal Argument Exception ( _ STR ) ; } out . write Bytes (  PREFIX ) ; out . write Bytes ( boundary ) ; out . write Bytes (  NEWLINE ) ; out . write Bytes ( _ STR + name + _ STR + file Name + _ STR ) ; out . write Bytes (  NEWLINE ) ; if ( mime Type != null ) { out . write Bytes ( _ STR + mime Type ) ; out . write Bytes (  NEWLINE ) ; } out . write Bytes (  NEWLINE ) ; byte [ ] data = new byte [ _ NUM ] ; int r = _ NUM ; while ( ( r = is . read ( data , _ NUM , data . length ) ) != - _ NUM ) { out . write ( data , _ NUM , r ) ; } is . close ( ) ; out . write Bytes (  NEWLINE ) ; out . flush ( ) ; }
public static  Locale to Locale (  String str Locale ) throws  Expression Exception { return  Locale Factory . get Locale ( str Locale ) ; }
public void replace ( final  List <  Edge > remove List , final  Edge new Edge ) { final  Edge previous = previous Edges . get ( remove List . get ( _ NUM ) ) ; final  Edge next = next Edges . get ( remove List . get ( remove List . size ( ) - _ NUM ) ) ; edges . add ( new Edge ) ; previous Edges . put ( new Edge , previous ) ; next Edges . put ( previous , new Edge ) ; previous Edges . put ( next , new Edge ) ; next Edges . put ( new Edge , next ) ; for ( final  Edge edge : remove List ) { if ( edge == one Edge ) { one Edge = new Edge ; } edges . remove ( edge ) ; previous Edges . remove ( edge ) ; next Edges . remove ( edge ) ; } }
protected  String parse Quoted String ( ) throws  IOException ,  RDFParse Exception {  String result = null ; int c1 = read Code Point ( ) ; verify Character Or Fail ( c1 , _ STR ) ; int c2 = read Code Point ( ) ; int c3 = read Code Point ( ) ; if ( ( c1 == _ STR && c2 == _ STR && c3 == _ STR ) || ( c1 == _ STR && c2 == _ STR && c3 == _ STR ) ) { result = parse Long String ( c2 ) ; } else { unread ( c3 ) ; unread ( c2 ) ; result = parse String ( c1 ) ; } try { result =  Turtle Util . decode String ( result ) ; } catch (  Illegal Argument Exception e ) { report Error ( e . get Message ( ) ,  Basic Parser Settings .  VERIFY_ DATATYPE_ VALUES ) ; } return result ; }
public static  String create Web Xml Source ( ) {  String Builder sb = new  String Builder ( ) ; sb . append ( _ STR ) ; sb . append ( _ STR ) ; sb . append ( _ STR ) ; sb . append ( _ STR ) ; sb . append ( _ STR ) ; sb . append ( _ STR ) ; sb . append ( _ STR ) ; sb . append ( _ STR ) ; sb . append ( _ STR ) ; sb . append ( _ STR ) ; return sb . to String ( ) ; }
public void start ( ) { this . start Time =  System . current Time Millis ( ) ; this . stop Time = _ NUM ; }
public  Ascii Table ( ) { this . data = new  Object [ _ NUM ] ; this . buffer = null ; this . n Fields = _ NUM ; this . n Rows = _ NUM ; this . row Len = _ NUM ; this . types = new  Class [ _ NUM ] ; this . lengths = new int [ _ NUM ] ; this . offsets = new int [ _ NUM ] ; this . nulls = new  String [ _ NUM ] ; }
public static  String remove Chars (  String src , char ... chars ) { int i = src . length ( ) ;  String Builder sb = new  String Builder ( i ) ; mainloop : for ( int j = _ NUM ; j < i ; j ++ ) { char c = src . char At ( j ) ; for ( char a Char : chars ) { if ( c == a Char ) { continue mainloop ; } } sb . append ( c ) ; } return sb . to String ( ) ; }
private void add Indexed Columns ( ) throws  SQLException {  Database Meta Data meta Data = get Database Meta Data ( ) ;  Arrays . sort ( column Indexes ) ;  List <  String > columns = new  Array List < > ( ) ; try (  Result Set rs = meta Data . get Columns ( null , null , normalize Object Name ( statement Model . get Table Name ( ) ) , null ) ) { while ( rs . next ( ) ) { if (  Arrays . binary Search ( column Indexes , rs . get Int (  IDX_ ORDINAL_ POSITION ) ) >= _ NUM ) { columns . add ( quote Object Name ( rs . get String (  IDX_ COLUMN_ NAME ) ) ) ; } } } column Names = columns . to Array ( new  String [ _ NUM ] ) ; add Returning Clause ( ) ; }
public void load Ham NSpam (  Connection conn ) throws java . sql .  SQLException {  Prepared Statement pstmt = null ;  Result Set rs = null ; try { pstmt = conn . prepare Statement ( sql Queries . get Sql String ( _ STR , _ BOOL ) ) ; rs = pstmt . execute Query ( ) ;  Map <  String ,  Integer > ham = get Ham Token Counts ( ) ; while ( rs . next ( ) ) {  String token = rs . get String ( _ NUM ) ; int count = rs . get Int ( _ NUM ) ; if ( count > _ NUM ) { ham . put ( token , count ) ; } } delegated Log ( _ STR + ham . size ( ) ) ; rs . close ( ) ; pstmt . close ( ) ; pstmt = conn . prepare Statement ( sql Queries . get Sql String ( _ STR , _ BOOL ) ) ; rs = pstmt . execute Query ( ) ;  Map <  String ,  Integer > spam = get Spam Token Counts ( ) ; while ( rs . next ( ) ) {  String token = rs . get String ( _ NUM ) ; int count = rs . get Int ( _ NUM ) ; if ( count > _ NUM ) { spam . put ( token , count ) ; } } delegated Log ( _ STR + spam . size ( ) ) ; rs . close ( ) ; pstmt . close ( ) ; pstmt = conn . prepare Statement ( sql Queries . get Sql String ( _ STR , _ BOOL ) ) ; rs = pstmt . execute Query ( ) ; if ( rs . next ( ) ) { set Ham Message Count ( rs . get Int ( _ NUM ) ) ; set Spam Message Count ( rs . get Int ( _ NUM ) ) ; } rs . close ( ) ; pstmt . close ( ) ; } finally { if ( rs != null ) { try { rs . close ( ) ; } catch ( java . sql .  SQLException se ) { } rs = null ; } if ( pstmt != null ) { try { pstmt . close ( ) ; } catch ( java . sql .  SQLException se ) { } pstmt = null ; } } }
public static void flush ( final  Input Stream source , final  Output Stream dest ) throws  IOException { final byte [ ] buf = new byte [ _ NUM ] ; int read ; while ( ( read = source . read ( buf ) ) != - _ NUM ) { dest . write ( buf , _ NUM , read ) ; } }
private  GHMock Rule add Setup (  Runnable setup ) { setups . add ( setup ) ; return this ; }
public void test Getter Inheritance ( ) throws  Exception {  Object Mapper m = new  Object Mapper ( ) ;  Map <  String ,  Object > result = write And Map ( m , new  Sub Class Bean ( ) ) ; assert Equals ( _ NUM , result . size ( ) ) ; assert Equals (  Integer . value Of ( _ NUM ) , result . get ( _ STR ) ) ; assert Equals (  Integer . value Of ( _ NUM ) , result . get ( _ STR ) ) ; assert Equals (  Integer . value Of ( _ NUM ) , result . get ( _ STR ) ) ; }
public  Command Editor (  Action Command cmd ,  Editable Resources res ,  String ui Name ,  List < com . codename1 . ui .  Command > commands ,  Properties project Generator Settings , boolean java5 ) { this . java5 = java5 ; this . project Generator Settings = project Generator Settings ; this . ui Name = ui Name ; init Components ( ) ; go To Source . set Enabled ( project Generator Settings != null ) ; com . codename1 . ui .  Command [ ] existing = new com . codename1 . ui .  Command [ commands . size ( ) + _ NUM ] ; existing [ _ NUM ] = null ; for ( int iter = _ NUM ; iter < existing . length ; iter ++ ) { existing [ iter ] = commands . get ( iter - _ NUM ) ; }  Vector post Actions = new  Vector ( ) ; post Actions . add Element ( _ STR ) ;  Vector actions = new  Vector ( ) ; actions . add Element ( _ STR ) ; actions . add Element ( _ STR ) ; actions . add Element ( _ STR ) ; actions . add Element ( _ STR ) ; actions . add Element ( _ STR ) ; back Command . set Selected ( cmd . is Back Command ( ) ) ;  String [ ] ui Entries = new  String [ res . get UIResource Names ( ) . length ] ;  System . arraycopy ( res . get UIResource Names ( ) , _ NUM , ui Entries , _ NUM , ui Entries . length ) ;  Arrays . sort ( ui Entries ) ; for (  String uis : ui Entries ) { if ( ! ui Name . equals ( uis ) ) { actions . add Element ( uis ) ; post Actions . add Element ( uis ) ; } } action . set Model ( new  Default Combo Box Model ( actions ) ) ; post Action . set Model ( new  Default Combo Box Model ( post Actions ) ) ;  String a = cmd . get Action ( ) ; if ( a != null ) { if ( a . starts With ( _ STR ) ) { a = a . substring ( _ NUM ) ; asynchronous . set Selected ( _ BOOL ) ; } else { if ( a . starts With ( _ STR ) ) { a = a . substring ( _ NUM ) ;  String [ ] arr = a . split ( _ STR ) ; action . set Selected Item ( arr [ _ NUM ] ) ; post Action . set Selected Item ( arr [ _ NUM ] ) ; } else { if ( a . starts With ( _ STR ) ) { a = a . substring ( _ NUM ) ; } } } } action . set Selected Item ( a ) ; name . set Text ( cmd . get Command Name ( ) ) ; id . set Model ( new  Spinner Number Model ( cmd . get Id ( ) , - _ NUM ,  Integer .  MAX_ VALUE , _ NUM ) ) ;  Resource Editor View . init Images Combo Box ( icon , res , _ BOOL , _ BOOL ) ; icon . set Selected Item ( cmd . get Icon ( ) ) ;  Resource Editor View . init Images Combo Box ( rollover , res , _ BOOL , _ BOOL ) ; rollover . set Selected Item ( cmd . get Rollover Icon ( ) ) ;  Resource Editor View . init Images Combo Box ( pressed , res , _ BOOL , _ BOOL ) ; pressed . set Selected Item ( cmd . get Pressed Icon ( ) ) ;  Resource Editor View . init Images Combo Box ( disabled , res , _ BOOL , _ BOOL ) ; disabled . set Selected Item ( cmd . get Disabled Icon ( ) ) ; }
public void test_ Big Decimal0 ( ) { final  Big Decimal [ ] a = new  Big Decimal [ ] { new  Big Decimal ( _ STR ) , new  Big Decimal ( _ STR ) , new  Big Decimal ( _ STR ) , new  Big Decimal ( _ STR ) , new  Big Decimal ( _ STR ) , new  Big Decimal ( _ STR ) , new  Big Decimal ( _ STR ) } ; for (  Big Decimal i : a ) { i = i . strip Trailing Zeros ( ) ; if ( log . is Info Enabled ( ) ) log . info ( _ STR + i + _ STR + i . scale ( ) + _ STR + i . precision ( ) + _ STR + dump Big Decimal ( i ) ) ; } for (  Big Decimal i : a ) { do Encode Decode Test ( i ) ; } for ( int i = _ NUM ; i < a . length ; i ++ ) { for ( int j = _ NUM ; j < a . length ; j ++ ) { do Compare Test ( a [ i ] , a [ j ] ,  Compare Enum .  EQ ) ; } } }
private int calculate Index ( int index ) { index = index - ( has Header ( ) ? _ NUM : _ NUM ) ; if ( index >= items . size ( ) ) { throw new  Illegal State Exception ( _ STR ) ; } else { return index ; } }
public static  Symbol Variant symbol Variant (  Char Sequence symbol ) { int length = symbol . length ( ) ; if ( length == _ NUM ) { throw new  Empty Symbol Exception ( ) ; } if ( is Identifier Keyword ( symbol ) ) { return  Symbol Variant .  QUOTED ; } char c = symbol . char At ( _ NUM ) ; if ( is Identifier Start ( c ) ) { for ( int ii = _ NUM ; ii < length ; ii ++ ) { c = symbol . char At ( ii ) ; if ( ( c == _ STR || c < _ NUM || c > _ NUM ) || ! is Identifier Part ( c ) ) { return  Symbol Variant .  QUOTED ; } } return  Symbol Variant .  IDENTIFIER ; } if ( is Operator Part ( c ) ) { for ( int ii = _ NUM ; ii < length ; ii ++ ) { c = symbol . char At ( ii ) ; if ( ! is Operator Part ( c ) ) { return  Symbol Variant .  QUOTED ; } } return  Symbol Variant .  OPERATOR ; } return  Symbol Variant .  QUOTED ; }
public  Zip Entry (  String name ) { if ( name == null ) { throw new  Null Pointer Exception ( ) ; } if ( name . length ( ) > _ NUM ) { throw new  Illegal Argument Exception ( _ STR ) ; } this . name = name ; }
public static  Document load Document (  Input Stream stream ) throws  Exception {  Document Builder Factory factory =  Document Builder Factory . new Instance ( ) ;  Document Builder builder = factory . new Document Builder ( ) ; return builder . parse ( stream ) ; }
public static boolean nodes Equal (  Node this Node ,  Node other Node ) { if ( this Node == other Node ) { return _ BOOL ; } if ( this Node . get Node Type ( ) != other Node . get Node Type ( ) ) { return _ BOOL ; } return _ BOOL ; }
@  Deprecated public  Boolean is Hod ( final  Long assign Id ) { final  List <  Head Of Departments > hod List = employee Department Repository . get All Hod Departments ( assign Id ) ; return ! hod List . is Empty ( ) ; }
public  Munger limit Label Languages (  String ... languages ) { return limit Label Languages (  Arrays . as List ( languages ) ) ; }
Combo Value (  List value List ) { this ( (  Stat Value [ ] ) value List . to Array ( new  Stat Value [ value List . size ( ) ] ) ) ; }
protected double category Utility ( ) throws  Exception { if ( m_children == null ) { throw new  Exception ( _ STR ) ; } double total CU = _ NUM ; for ( int i = _ NUM ; i < m_children . size ( ) ; i ++ ) {  CNode child = m_children . get ( i ) ; total CU += category Utility Child ( child ) ; } total CU /= m_children . size ( ) ; return total CU ; }
private void update Range ( double x , double y ) { m Min X =  Math . min ( m Min X , x ) ; m Max X =  Math . max ( m Max X , x ) ; m Min Y =  Math . min ( m Min Y , y ) ; m Max Y =  Math . max ( m Max Y , y ) ; }
public  Tv Show Episode Scrape Task (  List <  Tv Show Episode > episodes ,  Media Scraper media Scraper , boolean scrape Thumb ) { super (  BUNDLE . get String ( _ STR ) , episodes . size ( ) ,  Task Type .  BACKGROUND_ TASK ) ; this . episodes = episodes ; this . media Scraper = media Scraper ; this . scrape Thumb = scrape Thumb ; }
private static final boolean has Notification ( final  Model MBean Info info , final  String notif Name ) { try { if ( info == null ) return _ BOOL ; else return ( info . get Notification ( notif Name ) != null ) ; } catch (  MBean Exception x ) { return _ BOOL ; } catch (  Runtime Operations Exception r ) { return _ BOOL ; } }
public void remove Task (  Future task ) { task Set . remove ( task ) ; }
public  Geo Distance Sort Builder point ( double lat , double lon ) { points . add ( new  Geo Point ( lat , lon ) ) ; return this ; }
public void send Exception ( final  Exception exception , final  Map <  String ,  String > properties ) { final  Property Map Builder builder = new  Property Map Builder ( properties ) ; logger . debug (  String . format ( _ STR , exception . get Message ( ) , builder . to String ( ) ) ) ; if ( telemetry Client != null ) { telemetry Client . track Exception ( exception , builder . build ( ) , null ) ; } }
public void handle Header Column Left Click (  Point p ) {  JTable Header th =  TABLE . get Table Header ( ) ; int col = th . column At Point ( p ) ; int c =  TABLE . convert Column Index To Model ( col ) ; int old C =  DATA_ MODEL . get Sort Column ( ) ; if ( c != - _ NUM ) { sort And Maintain Selection ( c ) ; th . repaint ( th . get Header Rect ( col ) ) ; if ( old C != - _ NUM && old C != c ) { int old Col =  TABLE . convert Column Index To View ( old C ) ; th . repaint ( th . get Header Rect ( old Col ) ) ; } } }
public void add Response (  Record Response response ) { if ( records == null ) { records = new  Record Response [ _ NUM ] ; } else {  Record Response old [ ] = records ; records = new  Record Response [ old . length + _ NUM ] ;  System . arraycopy ( old , _ NUM , records , _ NUM , old . length ) ; } records [ records . length - _ NUM ] = response ; }
public void add Attribute (  Attribute attr ) { attrs . add Element ( attr ) ; }
private void delete Current File (  File file To Delete ) throws  IOException { logger . info ( _ STR , file To Delete ) ; if ( ! file To Delete . exists ( ) ) { logger . warn ( _ STR , file To Delete ) ; return ; } if ( ! file To Delete . delete ( ) ) { throw new  IOException ( _ STR + file To Delete ) ; } delete Meta File ( ) ; }
public static int hash (  Object object ) { return object == null ? _ NUM : object . hash Code ( ) ; }
public  String documentation Admin Guide Url ( ) { return properties . get Property ( _ STR ) ; }
public static double sum ( final  List < ? extends  Number > list ) { double sum = _ NUM ; for (  Number number : list ) { sum += number . double Value ( ) ; } return sum ; }
public static  String to Hex ( byte [ ] data ) { return new  String (  Hex . encode Hex ( data ) ) ; }
@  Visible For Testing public void disable Browser Override For Test ( ) { m Disable Browser Override = _ BOOL ; m Persistent Control Tokens . clear ( ) ; m Handler . remove Messages (  MSG_ ID_ HIDE_ CONTROLS ) ; if ( m Control Animation != null ) { m Control Animation . cancel ( ) ; m Control Animation = null ; } m Browser Control Offset =  Float .  Na N ; update Visuals ( ) ; }
public static  String encode Path For URL (  String str ) {  String Buffer result = new  String Buffer ( ) ; for ( int i = _ NUM ; i < str . length ( ) ; i ++ ) { char ch = str . char At ( i ) ; if ( ch >= _ STR && ch <= _ STR || ch >= _ STR && ch <= _ STR || ch >= _ STR && ch <= _ STR ) result . append ( ch ) ; else { switch ( ch ) { case _ STR : case _ STR : case _ STR : case _ STR : case _ STR : case _ STR : case _ STR : case _ STR : case _ STR : case _ STR : case _ STR : case _ STR : result . append ( ch ) ; break ; default : result . append ( _ STR ) ; result . append ( hexchars [ ( ch & _ NUM ) > > _ NUM ] ) ; result . append ( hexchars [ ch & _ NUM ] ) ; break ; } } } return result . to String ( ) ; }
static public boolean start (  ASync Process parent ,  Process Info pi ) { if ( pi . get AD_ Process_ ID ( ) == _ NUM ) return start Document Print (  Report Engine .  ORDER , null , pi . get Record_ ID ( ) , null ) ; if ( pi . get AD_ Process_ ID ( ) ==  MProcess . get Process_ ID ( _ STR , null ) ) return start Document Print (  Report Engine .  MANUFACTURING_ ORDER , null , pi . get Record_ ID ( ) , null ) ; if ( pi . get AD_ Process_ ID ( ) ==  MProcess . get Process_ ID ( _ STR , null ) ) return start Document Print (  Report Engine .  DISTRIBUTION_ ORDER , null , pi . get Record_ ID ( ) , null ) ; else if ( pi . get AD_ Process_ ID ( ) == _ NUM ) return start Document Print (  Report Engine .  INVOICE , null , pi . get Record_ ID ( ) , null ) ; else if ( pi . get AD_ Process_ ID ( ) == _ NUM ) return start Document Print (  Report Engine .  SHIPMENT , null , pi . get Record_ ID ( ) , null ) ; else if ( pi . get AD_ Process_ ID ( ) == _ NUM ) return start Document Print (  Report Engine .  PROJECT , null , pi . get Record_ ID ( ) , null ) ; else if ( pi . get AD_ Process_ ID ( ) == _ NUM ) return start Document Print (  Report Engine .  RFQ , null , pi . get Record_ ID ( ) , null ) ; else if ( pi . get AD_ Process_ ID ( ) == _ NUM ) return start Document Print (  Report Engine .  DUNNING , null , pi . get Record_ ID ( ) , null ) ; else if ( pi . get AD_ Process_ ID ( ) == _ NUM || pi . get AD_ Process_ ID ( ) == _ NUM ) return start Fin Report ( pi ) ; return start Standard Report ( pi ) ; }
private  Map <  URI ,  Storage System > build Array Map (  List <  Volume Descriptor > descriptors ,  Volume Descriptor .  Type type ) {  Map <  URI ,  Storage System > array Map = new  Hash Map <  URI ,  Storage System > ( ) ; if ( type != null ) { descriptors =  Volume Descriptor . filter By Type ( descriptors , new  Volume Descriptor .  Type [ ] { type } , new  Volume Descriptor .  Type [ ] { } ) ; } for (  Volume Descriptor desc : descriptors ) { if ( array Map . contains Key ( desc . get Device URI ( ) ) == _ BOOL ) {  Storage System array = get Data Object (  Storage System . class , desc . get Device URI ( ) , _db Client ) ; array Map . put ( desc . get Device URI ( ) , array ) ; } } return array Map ; }
@  Override public  Encrypted Data encrypt ( byte [ ] plain Bytes ,  Key Parameter aes Key ) throws  Key Crypter Exception { check Not Null ( plain Bytes ) ; check Not Null ( aes Key ) ; try { byte [ ] iv = new byte [  BLOCK_ LENGTH ] ; secure Random . next Bytes ( iv ) ;  Parameters With IV key With Iv = new  Parameters With IV ( aes Key , iv ) ;  Buffered Block Cipher cipher = new  Padded Buffered Block Cipher ( new  CBCBlock Cipher ( new  AESFast Engine ( ) ) ) ; cipher . init ( _ BOOL , key With Iv ) ; byte [ ] encrypted Bytes = new byte [ cipher . get Output Size ( plain Bytes . length ) ] ; final int length1 = cipher . process Bytes ( plain Bytes , _ NUM , plain Bytes . length , encrypted Bytes , _ NUM ) ; final int length2 = cipher . do Final ( encrypted Bytes , length1 ) ; return new  Encrypted Data ( iv ,  Arrays . copy Of ( encrypted Bytes , length1 + length2 ) ) ; } catch (  Exception e ) { throw new  Key Crypter Exception ( _ STR , e ) ; } }
public boolean check All Queried Messages ( boolean check ,  String query ) { if ( query == null || query . length ( ) == _ NUM ) { return check All Messages ( check , _ BOOL ) ; }  SQLite Database db = get Writable Database ( ) ; if ( db != null ) {  String parent Only = _ STR +  COL_ BIGPARENT + _ STR +  COL_ BIGPARENT + _ STR +  COL_ MESSAGE_ ID + _ STR +  TABLE + _ STR +  COL_ DELETED + _ STR +  FALSE + _ STR +  COL_ PARENT + _ STR +  COL_ MESSAGE_ ID + _ STR +  TABLE + _ STR +  COL_ DELETED + _ STR +  FALSE + _ STR ; db . exec SQL ( _ STR +  TABLE + _ STR +  COL_ CHECKED + _ STR + ( check ?  TRUE :  FALSE ) + _ STR +  COL_ DELETED + _ STR +  FALSE + _ STR + query + parent Only + _ STR ) ; return _ BOOL ; } return _ BOOL ; }
public static _ Fields find By Thrift Id ( int field Id ) { switch ( field Id ) { case _ NUM : return  ID ; default : return null ; } }
@  Override public void install (  JEditor Pane editor ) { super . install ( editor ) ; editor . add Key Listener ( this ) ; }
public void test Write5 ( ) throws  Exception {  Cipher cf =  Cipher . get Instance ( _ STR ) ;  Null Cipher nc = new  Null Cipher ( ) ;  Cipher Output Stream stream1 = new  Cipher Output Stream ( new  Buffered Output Stream ( (  Output Stream ) null ) , nc ) ;  Cipher Output Stream stream2 = new  Cipher Output Stream ( stream1 , cf ) ;  Cipher Output Stream stream3 = new  Cipher Output Stream ( stream2 , nc ) ; stream3 . write ( new byte [ ] { _ NUM } , _ NUM , _ NUM ) ; }
protected void verify Record Buffer ( int size ) { if ( rec Buf . length < size ) { rec Buf = new byte [ size ] ; } }
public  URI create Tenant (  Keystone Tenant tenant ) {  Tenant Org Rest Rep tenant Resp = _internal Tenant Service Client . create Tenant ( _keystone Utils Service . prepare Tenant Param ( tenant ) ) ; return tenant Resp . get Id ( ) ; }
static private void throw Failure ( ) throws  Internal Gem Fire Error ,  Error { if ( failure != null ) throw failure ; }
@  Override public void draw Node (  Graphics g , int w , int h ) { if ( ( m_type &  PURE_ INPUT ) ==  PURE_ INPUT ) { g . set Color (  Color . green ) ; } else { g . set Color (  Color . orange ) ; }  Font Metrics fm = g . get Font Metrics ( ) ; int l = ( int ) ( m_x * w ) - fm . string Width ( m_id ) / _ NUM ; int t = ( int ) ( m_y * h ) - fm . get Height ( ) / _ NUM ; g . fill3 DRect ( l , t , fm . string Width ( m_id ) + _ NUM , fm . get Height ( ) + fm . get Descent ( ) + _ NUM , _ BOOL ) ; g . set Color (  Color . black ) ; g . draw String ( m_id , l + _ NUM , t + fm . get Height ( ) + _ NUM ) ; }
public  String encode (  String p String ) throws  Encoder Exception { if ( p String == null ) { return null ; } try { return encode ( p String , get Default Charset ( ) ) ; } catch (  Unsupported Encoding Exception e ) { throw new  Encoder Exception ( e . get Message ( ) ) ; } }
public double empirical HSICincomplete Cholesky (  Tetrad Matrix  Gy ,  Tetrad Matrix  Gx , int m ) { int ky =  Gy . columns ( ) ; int kx =  Gx . columns ( ) ;  Tetrad Matrix  H =  Kernel Utils . construct H ( m ) ;  Tetrad Matrix  Gcy =  H . times (  Gy ) ;  Tetrad Matrix  Gcx =  H . times (  Gx ) ;  Tetrad Matrix  Gcyt =  Gcy . transpose ( ) ;  Tetrad Matrix  A =  Gcyt . times (  Gcx ) ;  Tetrad Matrix  B =  Gcy . times (  A ) ;  Tetrad Matrix  Gcxt =  Gcx . transpose ( ) ; double emp HSIC = _ NUM ; for ( int i = _ NUM ; i < m ; i ++ ) { emp HSIC += matrix Product Entry (  B ,  Gcxt , i , i ) ; } emp HSIC /=  Math . pow ( m - _ NUM , _ NUM ) ; return emp HSIC ; }
public static  String parse (  String [ ] options ,  String option ,  String def Value ) throws  Exception {  String value =  Utils . get Option ( option , options ) ; if ( value . is Empty ( ) ) return def Value ; else return value ; }
public boolean is Source Balanced ( ) { if ( m_lines . size ( ) == _ NUM || m_doc . is Multi Currency ( ) ) return _ BOOL ;  Big Decimal balance = get Source Balance ( ) ; boolean ret Value = balance . signum ( ) == _ NUM ; if ( ret Value ) log . finer ( to String ( ) ) ; else log . warning ( _ STR + balance + _ STR + to String ( ) ) ; return ret Value ; }
private void grow ( int min Capacity ) { int old Capacity = element Data . length ; int new Capacity = old Capacity + ( old Capacity > > _ NUM ) ; if ( new Capacity - min Capacity < _ NUM ) { new Capacity = min Capacity ; } if ( new Capacity -  MAX_ ARRAY_ SIZE > _ NUM ) { new Capacity = huge Capacity ( min Capacity ) ; } element Data =  Arrays . copy Of ( element Data , new Capacity ) ; }
public void unpack Start (  String line ) {  String detail =  URLDecoder . decode ( line ) ; detail = detail . substring ( detail . index Of ( _ STR ) ) ;  String tc Start = null ; if ( detail . index Of ( _ STR ) != - _ NUM ) tc Start = detail . substring ( _ NUM , detail . index Of ( _ STR ) ) ; else tc Start = detail . substring ( _ NUM ) ; manage Timer ( detail . substring ( _ NUM ) ) ; started Cases . add ( tc Start ) ; last Test Case Start Time =  System . current Time Millis ( ) ; last Test Case Start = tc Start ; }
public void close ( ) throws  IOException { output . close ( ) ; }
void fully Lock ( ) { put Lock . lock ( ) ; take Lock . lock ( ) ; }
@  Override public  Object create Statement (  Object proxy ,  Method method ,  Object [ ] args ,  Object statement , long time ) { try {  String name = method . get Name ( ) ;  Constructor < ? > constructor = null ;  String sql = null ; if ( compare (  CREATE_ STATEMENT , name ) ) { constructor = get Constructor (  CREATE_ STATEMENT_ IDX ,  Statement . class ) ; } else if ( compare (  PREPARE_ STATEMENT , name ) ) { constructor = get Constructor (  PREPARE_ STATEMENT_ IDX ,  Prepared Statement . class ) ; sql = (  String ) args [ _ NUM ] ; } else if ( compare (  PREPARE_ CALL , name ) ) { constructor = get Constructor (  PREPARE_ CALL_ IDX ,  Callable Statement . class ) ; sql = (  String ) args [ _ NUM ] ; } else { return statement ; } return create Decorator ( proxy , method , args , statement , constructor , sql ) ; } catch (  Exception x ) { if ( x instanceof  Invocation Target Exception ) {  Throwable cause = x . get Cause ( ) ; if ( cause instanceof  Thread Death ) { throw (  Thread Death ) cause ; } if ( cause instanceof  Virtual Machine Error ) { throw (  Virtual Machine Error ) cause ; } } logger . warn ( _ STR , x ) ; } return statement ; }
@  Deprecated public  Concurrent Update Solr Client (  String solr Server Url , int queue Size , int thread Count ) { this ( solr Server Url , null , queue Size , thread Count ) ; shutdown Executor = _ BOOL ; internal Http Client = _ BOOL ; }
public void clear ( ) { set URL ( m_ Db Utils . get Database URL ( ) ) ; set User ( m_ Db Utils . get Username ( ) ) ; set Password ( m_ Db Utils . get Password ( ) ) ; }
public void update (  Client client ,  OAuth2 Request request ) throws  Invalid Client Metadata ,  Unauthorized Client Exception { delete ( client . get Client ID ( ) , request ) ; create ( client , request ) ; }
public void add Method Property (  String name ,  String accessor Method ) { method Properties . add ( new  Legacy Method Prop Desc ( name , accessor Method ) ) ; }
public static  String correct File Name (  String f ) { f = f . replace ( _ STR , _ STR ) ; if ( f . starts With ( _ STR ) ) { f = f . substring ( _ NUM ) ; } return f ; }
public static byte [ ] base64 Decode String (  String base64 String ) { try { return  Base64 . decode Base64 ( base64 String . get Bytes ( _ STR ) ) ; } catch (  Exception e ) { throw new  Runtime Exception ( _ STR + base64 String ) ; } }
@  Override public void draw Series (  Canvas canvas ,  Paint paint ,  List <  Float > points ,  XYSeries Renderer series Renderer , float y Axis Value , int series Index , int start Index ) { int series Nr = m Dataset . get Series Count ( ) ; int length = points . size ( ) ; paint . set Color ( series Renderer . get Color ( ) ) ; paint . set Style (  Style .  FILL ) ; float half Diff X = get Half Diff X ( points , length , series Nr ) ; int start = _ NUM ; if ( start Index > _ NUM ) { start = _ NUM ; } for ( int i = start ; i < length ; i += _ NUM ) { if ( points . size ( ) > i + _ NUM ) { float x Min = points . get ( i ) ; float y Min = points . get ( i + _ NUM ) ; float x Max = points . get ( i + _ NUM ) ; float y Max = points . get ( i + _ NUM ) ; draw Bar ( canvas , x Min , y Min , x Max , y Max , half Diff X , series Nr , series Index , paint ) ; } } paint . set Color ( series Renderer . get Color ( ) ) ; }
String encoded Username ( ) { if ( username . is Empty ( ) ) return _ STR ; int username Start = scheme . length ( ) + _ NUM ; int username End = delimiter Offset ( url , username Start , url . length ( ) , _ STR ) ; return url . substring ( username Start , username End ) ; }
public static boolean is Byte Code Class Name (  String class Name ) { return ( ( class Name . starts With ( _ STR ) || class Name . starts With ( _ STR ) ) && class Name . ends With ( _ STR ) && ( ( class Name . index Of ( _ STR ) != - _ NUM || class Name . index Of ( _ STR ) == - _ NUM ) ) ) ; }
@  Suppress Warnings ( _ STR ) protected boolean is Fast Clock Time GE ( int hr , int min ) {  Date now = fast Clock . get Time ( ) ; now Hours = now . get Hours ( ) ; now Minutes = now . get Minutes ( ) ; if ( ( ( now Hours * _ NUM ) + now Minutes ) >= ( ( hr * _ NUM ) + min ) ) { return _ BOOL ; } return _ BOOL ; }
private boolean is Job Scheduling Needed (  URI id ,  String type , boolean in Progress , boolean is Error , boolean scheduler , long last Time , long next Time ) { long system Time =  System . current Time Millis ( ) ; long tolerance =  Long . parse Long ( _config Info . get (  TOLERANCE ) ) * _ NUM ; _logger . info ( _ STR , next Time , last Time ) ; long refresh Interval = get Refresh Interval ( type ) ; if ( ! in Progress ) { if ( scheduler ) { if ( system Time < next Time - tolerance ) { _logger . info ( _ STR , id + _ STR + type , new  Date ( next Time ) ) ; _logger . info ( _ STR , new  Date ( system Time ) , tolerance ) ; return _ BOOL ; } } if ( ! scheduler && is Error && last Time > _ NUM ) { _logger . info ( _ STR , type , id ) ; return _ BOOL ; } if ( system Time - last Time < refresh Interval * _ NUM ) { _logger . info ( _ STR , id , type ) ; return _ BOOL ; } } else if ( ! scheduler && ( system Time - last Time > refresh Interval * _ NUM ) && last Time > _ NUM ) { _logger . info ( _ STR , type , id ) ; } else if ( scheduler && ( system Time - last Time > refresh Interval * _ NUM ) && next Time > _ NUM &&  System . current Time Millis ( ) - next Time >=  Job Intervals . get Max Idle Interval ( ) * _ NUM ) { _logger . info ( _ STR , type , id ) ; } else { _logger . info ( _ STR , type , id ) ; return _ BOOL ; } return _ BOOL ; }
private void deactivate Breakpoints ( ) { final  Breakpoint Manager manager = debugger . get Breakpoint Manager ( ) ; final  Set <  Breakpoint Address > addresses To Remove = new  Hash Set < > ( ) ; final  Set <  Breakpoint Address > addresses To Disable = new  Hash Set < > ( ) ; for ( final  Breakpoint breakpoint : manager . get Breakpoints (  Breakpoint Type .  REGULAR ) ) { final  Breakpoint Address address = breakpoint . get Address ( ) ; if ( manager . get Breakpoint Status ( address ,  Breakpoint Type .  REGULAR ) ==  Breakpoint Status .  BREAKPOINT_ DELETING ) { addresses To Remove . add ( address ) ; } else if ( manager . get Breakpoint Status ( address ,  Breakpoint Type .  REGULAR ) !=  Breakpoint Status .  BREAKPOINT_ DISABLED ) { addresses To Disable . add ( address ) ; } } manager . remove Breakpoints (  Breakpoint Type .  REGULAR , addresses To Remove ) ; manager . set Breakpoint Status ( addresses To Disable ,  Breakpoint Type .  REGULAR ,  Breakpoint Status .  BREAKPOINT_ INACTIVE ) ; }
private void append Managed Object Path Element (  Relation Definition < ? , ? > r ) {  DN dn =  DN . value Of ( profile . get Relation RDNSequence ( r ) ) ;  List <  RDN > rdns Of Dn = get Rdns In Big Endian Order ( dn ) ; rdns . add All ( rdns Of Dn ) ; }
private static  Entry [ ] unmarshal Attributes (  Object Input Stream in ) throws  IOException ,  Class Not Found Exception {  Array List attributes = new  Array List ( ) ;  Marshalled Instance mi = null ; while ( ( mi = (  Marshalled Instance ) in . read Object ( ) ) != null ) { try { attributes . add ( (  Entry ) mi . get ( _ BOOL ) ) ; } catch (  Throwable e ) { if ( e instanceof  Error &&  Throwable Constants . retryable ( e ) ==  Throwable Constants .  BAD_ OBJECT ) { throw (  Error ) e ; } logger . log (  Level .  WARNING , _ STR , e ) ; } }  Entry [ ] attrs = new  Entry [ attributes . size ( ) ] ; return (  Entry [ ] ) attributes . to Array ( attrs ) ; }
public  Sc Physical Server create Server (  String ssn ,  String host Name , boolean is Iscsi ,  String os Id ) throws  Storage Center APIException {  Parameters params = new  Parameters ( ) ; params . add ( _ STR , host Name ) ; params . add ( _ STR , ssn ) ; params . add ( _ STR ,  NOTES_ STRING ) ; params . add ( _ STR , os Id ) ;  Rest Result rr = rest Client . post ( _ STR , params . to Json ( ) ) ; if ( ! check Results ( rr ) ) {  String error =  String . format ( _ STR , host Name , rr . get Error Msg ( ) ) ; throw new  Storage Center APIException ( error ) ; } return gson . from Json ( rr . get Result ( ) ,  Sc Physical Server . class ) ; }
public void test Completed Stage ( ) {  Atomic Integer x = new  Atomic Integer ( _ NUM ) ;  Atomic Reference <  Throwable > r = new  Atomic Reference <  Throwable > ( ) ;  Completion Stage <  Integer > f =  Completable Future . completed Stage ( _ NUM ) ; f . when Complete ( null ) ; assert Equals ( x . get ( ) , _ NUM ) ; assert Null ( r . get ( ) ) ; }
private void write Directory Post Resource (  String Builder sb ,  String path ) { sb . append ( _ STR +  DIR_ RESOURCE_ SET + _ STR ) ; sb . append ( path . replace ( _ STR , _ STR ) ) ; }
private  String map Table Types (  String table Type ) { if ( table Type . equals ( _ STR ) ) { return _ STR ; } return table Type ; }
public synchronized void add Curl Mesh (  Curl Mesh mesh ) { remove Curl Mesh ( mesh ) ; m Curl Meshes . add ( mesh ) ; }
private void update Pseudo References ( int epoch ) { if ( nbest List Writer != null ) { nbest List Writer . close ( ) ;  Evaluation Metric <  IString ,  String > metric = new  BLEUMetric <  IString ,  String > ( references ) ;  Multi Translation Metric Max <  IString ,  String > search Algorithm = new  Hill Climbing Multi Translation Metric Max <  IString ,  String > ( metric ) ;  NBest List Container <  IString ,  String > nbest Lists = null ; try { nbest Lists = new  Flat NBest List ( nbest Filename , references . size ( ) ) ; } catch (  IOException e ) { e . print Stack Trace ( ) ; logger . error ( _ STR , nbest Filename ) ; throw new  Runtime Exception ( _ STR + nbest Filename ) ; }  List <  Scored Featurized Translation <  IString ,  String > > max Featurized Translations = search Algorithm . maximize ( nbest Lists ) ; assert max Featurized Translations . size ( ) == tune Source . size ( ) : _ STR ; int num Translations = max Featurized Translations . size ( ) ; for ( int i = _ NUM ; i < num Translations ; ++ i ) {  Sequence <  IString > translation = max Featurized Translations . get ( i ) . translation ; if ( pseudo References . get ( i ) . size ( ) >= num Pseudo References ) pseudo References . get ( i ) . remove ( _ NUM ) ; pseudo References . get ( i ) . add ( translation ) ; } logger . info ( _ STR , pseudo References . get ( _ NUM ) . size ( ) ) ;  File file = new  File ( nbest Filename ) ; file . delete ( ) ; reference Weights = new double [ num References + pseudo References . get ( _ NUM ) . size ( ) ] ;  Arrays . fill ( reference Weights , _ NUM ) ; } if ( epoch >= pseudo Reference Burn In ) { nbest Filename =  String . format ( _ STR , temp Directory , epoch ) ; logger . info ( _ STR , nbest Filename ) ; nbest List Writer =  IOTools . get Writer From File ( nbest Filename ) ; } }
public boolean is Closed ( ) throws  SQLException { return this . is Closed ; }
public void insert Sleep Time ( ) {  Script Step sleep Time Script Step =  Script Step Factory . create Sleep Time ( get Sleep Time ( ) ) ; steps . add ( get Insert Index ( ) , sleep Time Script Step ) ; sleep Time = _ STR ; reindex Script Steps ( ) ; }
public  Instruction Iterator instruction Iterator ( ) { return new  Instruction Iterator ( first Instruction , last Instruction ) ; }
public void ensure Capacity ( int minimum Capacity ) { internal . ensure Capacity ( minimum Capacity ) ; }
public static  List <  Integer > inorder Traversal (  Tree Node root ) {  List <  Integer > result = new  Array List <  Integer > ( ) ;  Stack <  Tree Node > s = new  Stack <  Tree Node > ( ) ; while ( ! s . is Empty ( ) || root != null ) { if ( root != null ) { s . push ( root ) ; root = root . left ; } else { root = s . pop ( ) ; result . add ( root . val ) ; root = root . right ; } } return result ; }
public  String entity Id ( ) { return entity Id ; }
private void clean Up Database Resources (  Database conn ,  Statement st ,  Result Set rs ) { if ( rs != null ) { try { rs . close ( ) ; } catch (  SQLException ignore ) { } } if ( st != null ) { try { st . close ( ) ; } catch (  SQLException ignore ) { } } if ( conn != null ) conn . close ( ) ; }
public  OMRaster ( double lt , double ln ,  Image Icon ii ) { this ( lt , ln , ii . get Image ( ) ) ; }
public static boolean copy Stream (  Input Stream is ,  Output Stream os ,  Copy Listener listener , int buffer Size ) throws  IOException { int current = _ NUM ; final int total = is . available ( ) ; final byte [ ] bytes = new byte [ buffer Size ] ; int count ; if ( should Stop Loading ( listener , current , total ) ) return _ BOOL ; while ( ( count = is . read ( bytes , _ NUM , buffer Size ) ) != - _ NUM ) { os . write ( bytes , _ NUM , count ) ; current += count ; if ( should Stop Loading ( listener , current , total ) ) return _ BOOL ; } return _ BOOL ; }
public boolean write Header (  Output Stream os ) { try { write Int ( os ,  CACHE_ MAGIC ) ; write String ( os , key ) ; write String ( os , etag == null ? _ STR : etag ) ; write Long ( os , server Date ) ; write Long ( os , ttl ) ; write String String Map ( response Headers , os ) ; os . flush ( ) ; return _ BOOL ; } catch (  IOException e ) {  Loger . debug (  String . format ( _ STR , e . to String ( ) ) ) ; return _ BOOL ; } }
protected  String read Line ( ) throws  IOException {  String Builder sb = new  String Builder ( ) ; int c ; while ( ( c = input Stream . read ( ) ) != - _ NUM ) { if ( c == _ STR ) continue ; if ( c == _ STR ) break ; sb . append ( ( char ) c ) ; } return sb . to String ( ) ; }
private void code Class For Name (  Class < ? > cl ,  Data Output Stream out ) throws  IOException { code_ldc ( cp . get String ( cl . get Name ( ) ) , out ) ; out . write Byte ( opc_invokestatic ) ; out . write Short ( cp . get Method Ref ( _ STR , _ STR , _ STR ) ) ; }
public static  Collection Id parse (  String str ) {  String [ ] parts = str . split ( _ STR + _ STR + _ STR ) ; if ( parts . length < _ NUM ) return null ; return new  Collection Id ( parts [ _ NUM ] , parts [ _ NUM ] , parts [ _ NUM ] ) ; }
abstract public void init (  Subject subject , java . util .  Map shared State , java . util .  Map options ) ;
public  Clustered Patterns (  Pattern Reference pattern ) { patterns . add ( pattern ) ; }
public static  String [ ] ls Files (  String directory ,  Filename Filter filter ) throws  IOException {  File dir = new  File ( directory ) ;  Array List <  String > files = new  Array List < > ( ) ; for (  File filepath : dir . list Files ( filter ) ) { if ( is File ( filepath . get Absolute Path ( ) ) ) files . add ( filepath . get Absolute Path ( ) ) ; } return files . to Array ( new  String [ files . size ( ) ] ) ; }
private  String parse Value (  String value ) { value = value . trim ( ) ; if ( value . char At ( _ NUM ) == _ STR && value . char At ( value . length ( ) - _ NUM ) == _ STR ) { value = value . substring ( _ NUM , value . length ( ) - _ NUM ) ; value = value . replace All ( _ STR , _ STR ) ; } return value ; }
protected void merge Children Impl ( mx ICell from , mx ICell to , boolean clone All Edges ,  Hashtable <  Object ,  Object > mapping ) throws  Clone Not Supported Exception { begin Update ( ) ; try { int child Count = from . get Child Count ( ) ; for ( int i = _ NUM ; i < child Count ; i ++ ) {  Object child = from . get Child At ( i ) ; if ( child instanceof mx ICell ) { mx ICell cell = ( mx ICell ) child ;  String id = cell . get Id ( ) ; mx ICell target = ( mx ICell ) ( ( id != null && ( ! is Edge ( cell ) || ! clone All Edges ) ) ? get Cell ( id ) : null ) ; if ( target == null ) { mx Cell clone = ( mx Cell ) cell . clone ( ) ; clone . set Id ( id ) ; target = ( mx ICell ) to . insert ( clone ) ; cell Added ( target ) ; } mapping . put ( cell , target ) ; merge Children Impl ( cell , target , clone All Edges , mapping ) ; } } } finally { end Update ( ) ; } }
public void add Foreign Key ( int idx ,  Foreign Key foreign Key ) { if ( foreign Key != null ) { foreign Keys . add ( idx , foreign Key ) ; } }
public java . lang .  String Builder insert ( int offset , int i ) { return insert ( offset ,  Integer . to String ( i ) ) ; }
public void add Gefaehrdungs Baum Child (  IGefaehrdungs Baum Element new Child ) { if ( new Child instanceof  Cn ATree Element ) { add Child ( (  Cn ATree Element ) new Child ) ; } }
@  Override public void write ( byte [ ] buf , int offset , int length , boolean is End ) throws  IOException { while ( offset < length ) {  Temp Buffer tail = _tail ; if ( tail == null || tail . buffer ( ) . length <= tail . length ( ) ) { add Buffer (  Temp Buffer . create ( ) ) ; tail = _tail ; } int tail Length = tail . length ( ) ; byte [ ] tail Buffer = tail . buffer ( ) ; int sublen = tail Buffer . length - tail Length ; if ( length - offset < sublen ) { sublen = length - offset ; }  System . arraycopy ( buf , offset , tail Buffer , tail Length , sublen ) ; offset += sublen ; tail . length ( tail Length + sublen ) ; } }
public static double ceil ( double x ) { double y ; if (  Double . is Na N ( x ) ) { return x ; } y = floor ( x ) ; if ( y == x ) { return y ; } y += _ NUM ; if ( y == _ NUM ) { return x * y ; } return y ; }
protected boolean match Element (  Node node ) { if ( node . get Node Type ( ) !=  Node .  Node Type .  ELEMENT ) { return _ BOOL ; }  String element = get Element ( ) ;  String node Name = node . get Node Name ( ) ; return element . equals (  String Pool .  STAR ) || element . equals ( node Name ) ; }
public static  QName value Of (  String s ) { if ( ( s == null ) || s . equals ( _ STR ) ) { throw new  Illegal Argument Exception ( _ STR ) ; } if ( s . char At ( _ NUM ) == _ STR ) { int i = s . index Of ( _ STR ) ; if ( i == - _ NUM ) { throw new  Illegal Argument Exception ( _ STR ) ; } if ( i == s . length ( ) - _ NUM ) { throw new  Illegal Argument Exception ( _ STR ) ; } else { return new  QName ( s . substring ( _ NUM , i ) , s . substring ( i + _ NUM ) ) ; } } else { return new  QName ( s ) ; } }
public void finish ( ) throws  IOException { if ( done ) { return ; } def . finish ( ) ; while ( ! def . finished ( ) ) { int byte Count = def . deflate ( buf ) ; out . write ( buf , _ NUM , byte Count ) ; } done = _ BOOL ; }
private long offset ( long offset ) { return this . offset + offset ; }
public void internal Entity Decl (  String name ,  XMLString text ,  XMLString non Normalized Text ,  Augmentations augs ) throws  XNIException { try { if ( f Decl Handler != null ) { f Decl Handler . internal Entity Decl ( name , text . to String ( ) ) ; } } catch (  SAXException e ) { throw new  XNIException ( e ) ; } }
public void login (  Credential Provider credential Provider ) throws  Login Failed Exception ,  Remote Server Exception { if ( credential Provider == null ) { throw new  Null Pointer Exception ( _ STR ) ; } this . credential Provider = credential Provider ; start Time = current Time Millis ( ) ; player Profile = new  Player Profile ( this ) ; settings = new  Settings ( this ) ; inventories = new  Inventories ( this ) ; initialize ( ) ; }
public  E current ( ) { if ( pos < _ NUM || pos >= data . size ( ) ) { return null ; } return data . get ( pos ) ; }
protected boolean check Func Num ( ) { return this . ck Finder Func Num != null ; }
public  Abstract Timing Store ( int max Entries ) { if ( max Entries < _ NUM ) { this . max Entries = _ NUM ; } else { this . max Entries = max Entries ; } }
public static int roll1 D20 ( ) { return rand . next Int ( _ NUM ) + _ NUM ; }
public static byte [ ] decode Hex ( final char [ ] data ) { final int len = data . length ; if ( ( len & _ NUM ) != _ NUM ) { throw new  Illegal Argument Exception ( _ STR ) ; } final byte [ ] out = new byte [ len > > _ NUM ] ; for ( int i = _ NUM , j = _ NUM ; j < len ; i ++ ) { int f = to Digit ( data [ j ] , j ) << _ NUM ; j ++ ; f = f | to Digit ( data [ j ] , j ) ; j ++ ; out [ i ] = ( byte ) ( f & _ NUM ) ; } return out ; }
protected  JScroll Pane create Scroller ( ) {  JScroll Pane sp = new  JScroll Pane ( null ,  Scroll Pane Constants .  VERTICAL_ SCROLLBAR_ AS_ NEEDED ,  Scroll Pane Constants .  HORIZONTAL_ SCROLLBAR_ NEVER ) ; sp . set Horizontal Scroll Bar ( null ) ; sp . set Border (  Border Factory . create Empty Border ( ) ) ; return sp ; }
public  Segment ( int marker ) throws  IOException { this . marker = marker ; if ( marker != _ NUM ) { out . write Short ( marker ) ; offset = get Stream Position ( ) ; if ( ! standalone Markers . contains ( marker ) ) { out . write Short ( _ NUM ) ; } } }
protected  Json Deserializer <  Object > find Deserializer (  Deserialization Config config ,  Deserializer Provider provider ,  Java Type type ,  Bean Property property ) throws  Json Mapping Exception {  Json Deserializer <  Object > deser = provider . find Value Deserializer ( config , type , property ) ; return deser ; }
@  Override public double distance (  Instance first ,  Instance second ,  Performance Stats stats ) { return  Math . pow ( distance ( first , second ,  Double .  POSITIVE_ INFINITY , stats ) , _ NUM / m_ Order ) ; }
Closeable Iteration < ? extends  Statement ,  Sail Exception > create Statement Iterator (  Resource subj ,  IRI pred ,  Value obj , boolean explicit ,  Resource ... contexts ) throws  IOException { int subj ID =  Native Value .  UNKNOWN_ ID ; if ( subj != null ) { subj ID = value Store . get ID ( subj ) ; if ( subj ID ==  Native Value .  UNKNOWN_ ID ) { return new  Empty Iteration <  Statement ,  Sail Exception > ( ) ; } } int pred ID =  Native Value .  UNKNOWN_ ID ; if ( pred != null ) { pred ID = value Store . get ID ( pred ) ; if ( pred ID ==  Native Value .  UNKNOWN_ ID ) { return new  Empty Iteration <  Statement ,  Sail Exception > ( ) ; } } int obj ID =  Native Value .  UNKNOWN_ ID ; if ( obj != null ) { obj ID = value Store . get ID ( obj ) ; if ( obj ID ==  Native Value .  UNKNOWN_ ID ) { return new  Empty Iteration <  Statement ,  Sail Exception > ( ) ; } }  List <  Integer > context IDList = new  Array List <  Integer > ( contexts . length ) ; if ( contexts . length == _ NUM ) { context IDList . add (  Native Value .  UNKNOWN_ ID ) ; } else { for (  Resource context : contexts ) { if ( context == null ) { context IDList . add ( _ NUM ) ; } else { int context ID = value Store . get ID ( context ) ; if ( context ID !=  Native Value .  UNKNOWN_ ID ) { context IDList . add ( context ID ) ; } } } }  Array List <  Native Statement Iterator > per Context Iter List = new  Array List <  Native Statement Iterator > ( context IDList . size ( ) ) ; for ( int context ID : context IDList ) {  Record Iterator btree Iter = triple Store . get Triples ( subj ID , pred ID , obj ID , context ID , explicit , _ BOOL ) ; per Context Iter List . add ( new  Native Statement Iterator ( btree Iter , value Store ) ) ; } if ( per Context Iter List . size ( ) == _ NUM ) { return per Context Iter List . get ( _ NUM ) ; } else { return new  Union Iteration <  Statement ,  Sail Exception > ( per Context Iter List ) ; } }
public static void drop All (  Connection conn ) throws  SQLException {  Statement stat = conn . create Statement ( ) ; stat . execute ( _ STR +  SCHEMA ) ; remove All Triggers ( conn ,  TRIGGER_ PREFIX ) ; remove Index Files ( conn ) ; }
public void reset ( ) { m Object Count = _ NUM ; m Object Data Used = _ NUM ;  Arrays . fill ( m Objects , null ) ; }
public double percentile ( double percentile ) { return get ( percentile * get Event Count ( ) / _ NUM ) ; }
public static  String shard Name From DBName (  String db Name ) {  String [ ] tokens = db Name . split ( _ STR ) ; return tokens [ _ NUM ] ; }
public  String  Use This Var (  String id ,  String context ) {  Sym Tab Entry se = null ; int i =  Find Sym ( id , context ) ; if ( i == symtab . size ( ) ) return id ; se = (  Sym Tab Entry ) symtab . element At ( i ) ; if ( se . type ==  GLOBAL || se . type ==  PROCESSVAR || se . type ==  PROCEDUREVAR || se . type ==  PARAMETER ) return se . use This ; i =  Find Sym ( id , _ STR ) ; if ( se . type ==  GLOBAL ) return se . use This ; return id ; }
public static  String trim Comma (  String s ) { if ( s . ends With ( _ STR ) ) { s = s . substring ( _ NUM , s . length ( ) - _ NUM ) ; } return s ; }
private byte [ ] uint8_4 From Data ( int offset ) { return  Arrays . copy Of Range ( data ( ) , offset , offset + _ NUM ) ; }
protected static  Pair <  String ,  String > lsl Register ( final long offset , final  ITranslation Environment environment , final  List <  Reil Instruction > instructions , final  String register Node Value1 , final  String register Node Value2 ) { final  String shifter Operand = environment . get Next Variable String ( ) ; final  String shifter Carry Out = environment . get Next Variable String ( ) ; long base Offset = offset ; final  String tmp Var1 = environment . get Next Variable String ( ) ; final  String tmp Var2 = environment . get Next Variable String ( ) ; final  String tmp Var3 = environment . get Next Variable String ( ) ; final  String tmp Var4 = environment . get Next Variable String ( ) ; final  String tmp Var5 = environment . get Next Variable String ( ) ; final  String tmp Var6 = environment . get Next Variable String ( ) ; final  String tmp Var7 = environment . get Next Variable String ( ) ; final  String is Zero Condition = environment . get Next Variable String ( ) ; final  String shifter Carry Out Tmp1 = environment . get Next Variable String ( ) ; final  String shifter Carry Out Tmp2 = environment . get Next Variable String ( ) ; final  String shifter Carry Out Tmp3 = environment . get Next Variable String ( ) ; final  String shifter Carry Out Tmp4 = environment . get Next Variable String ( ) ; instructions . add (  Reil Helpers . create And ( base Offset ++ , d Word Size , register Node Value2 , d Word Size ,  String . value Of ( _ NUM ) , d Word Size , tmp Var1 ) ) ; instructions . add (  Reil Helpers . create Bsh ( base Offset ++ , d Word Size , register Node Value1 , d Word Size , tmp Var1 , q Word Size , tmp Var2 ) ) ; instructions . add (  Reil Helpers . create And ( base Offset ++ , q Word Size , tmp Var2 , d Word Size , bit Mask All Bits Set , d Word Size , shifter Operand ) ) ; instructions . add (  Reil Helpers . create Bisz ( base Offset ++ , d Word Size , tmp Var1 , byte Size , is Zero Condition ) ) ; instructions . add (  Reil Helpers . create And ( base Offset ++ , byte Size , is Zero Condition , byte Size , _ STR , byte Size , shifter Carry Out Tmp1 ) ) ; instructions . add (  Reil Helpers . create Xor ( base Offset ++ , d Word Size , tmp Var1 , word Size ,  String . value Of ( _ NUM ) , d Word Size , tmp Var3 ) ) ; instructions . add (  Reil Helpers . create Bisz ( base Offset ++ , d Word Size , tmp Var3 , byte Size , is Zero Condition ) ) ; instructions . add (  Reil Helpers . create And ( base Offset ++ , d Word Size , register Node Value1 , d Word Size , one Set , byte Size , tmp Var4 ) ) ; instructions . add (  Reil Helpers . create And ( base Offset ++ , byte Size , is Zero Condition , byte Size , tmp Var4 , byte Size , shifter Carry Out Tmp2 ) ) ; instructions . add (  Reil Helpers . create And ( base Offset ++ , d Word Size , tmp Var1 , d Word Size , not Thirty One Set , d Word Size , tmp Var5 ) ) ; instructions . add (  Reil Helpers . create Bisz ( base Offset ++ , d Word Size , tmp Var5 , byte Size , is Zero Condition ) ) ; instructions . add (  Reil Helpers . create Sub ( base Offset ++ , d Word Size ,  String . value Of ( _ NUM ) , d Word Size , tmp Var1 , d Word Size , tmp Var6 ) ) ; instructions . add (  Reil Helpers . create Bsh ( base Offset ++ , d Word Size , register Node Value1 , d Word Size , _ STR + tmp Var6 , byte Size , tmp Var7 ) ) ; instructions . add (  Reil Helpers . create And ( base Offset ++ , byte Size , is Zero Condition , byte Size , tmp Var7 , byte Size , shifter Carry Out Tmp3 ) ) ; instructions . add (  Reil Helpers . create Or ( base Offset ++ , byte Size , shifter Carry Out Tmp1 , byte Size , shifter Carry Out Tmp2 , byte Size , shifter Carry Out Tmp4 ) ) ; instructions . add (  Reil Helpers . create Or ( base Offset ++ , byte Size , shifter Carry Out Tmp3 , byte Size , shifter Carry Out Tmp4 , byte Size , shifter Carry Out ) ) ; return new  Pair <  String ,  String > ( shifter Operand , shifter Carry Out ) ; }
public static int option Length (  String option ) { if ( option . equals ( _ STR ) ) { return _ NUM ; } else { return _ NUM ; } }
@  Override public  String generate Label (  Category Dataset dataset , int series ) {  Param Checks . null Not Permitted ( dataset , _ STR ) ;  String label =  Message Format . format ( this . format Pattern , create Item Array ( dataset , series ) ) ; return label ; }
private static  String substitute Properties (  String str ) { str = str . trim ( ) ;  Matcher matcher =  PROP_ REGEX . matcher ( str ) ;  String Buffer buf = new  String Buffer ( ) ; while ( matcher . find ( ) ) {  String match = matcher . group ( ) ; if ( match . length ( ) >= _ NUM ) {  String key = match . substring ( _ NUM , match . length ( ) - _ NUM ) ;  String val =  System . getenv ( key ) ; if ( val == null ) val =  System . get Property ( key ) ; if ( val != null ) { match = val . replace All ( _ STR , _ STR ) ; } else if ( match . starts With ( _ STR ) ) match = match . replace ( _ STR , _ STR ) ; } matcher . append Replacement ( buf , match ) ; } matcher . append Tail ( buf ) ; return buf . to String ( ) ; }
HPBar ( ) { super ( new  Linear Scaling Model ( ) ) ; set Background (  Color .  DARK_ GRAY ) ; set Foreground (  Color .  WHITE ) ; set Preferred Size ( new  Dimension ( _ NUM ,  DEFAULT_ HEIGHT ) ) ; set Minimum Size ( get Preferred Size ( ) ) ; }
public  List <  String > field Property Comment (  Field field ) {  String comment Type = field Type Cardinality Comment ( field ) ;  String field Name = property Name ( field ) ; return convert To Commented Block ( field Comment (  String . format ( _ STR , comment Type , field Name ) , null , field ) ) ; }
public  Day (  Date time ,  Time Zone zone ) { this ( time , zone ,  Locale . get Default ( ) ) ; }
private  Marker Util ( ) { super ( ) ; }
default  B with Default (  String key , boolean value ) { return with Default ( key ,  Boolean . to String ( value ) ) ; }
public static  String read String ( final  JSONArray json Array , final int index , final boolean required , final boolean not Null ) throws  JSONException { if ( required ) { return json Array . get String ( index ) ; } if ( not Null && json Array . is Null ( index ) ) { throw new  JSONException (  String . format (  Locale .  US ,  NULL_ VALUE_ FORMAT_ ARRAY , index ) ) ; }  String value = null ; if ( ! json Array . is Null ( index ) ) { value = json Array . get String ( index ) ; } return value ; }
private void throw Ex Int Param (  Method Visitor mv ,  Class < ? > ex Cls ) {  String ex Sig =  Type . get Internal Name ( ex Cls ) ; mv . visit Type Insn (  NEW , ex Sig ) ; mv . visit Insn (  DUP ) ; mv . visit Ldc Insn ( _ STR + this . class Name + _ STR ) ; mv . visit Var Insn (  ILOAD , _ NUM ) ; mv . visit Method Insn (  INVOKESTATIC , _ STR , _ STR , _ STR ) ; mv . visit Method Insn (  INVOKEVIRTUAL , _ STR , _ STR , _ STR ) ; mv . visit Method Insn (  INVOKESPECIAL , ex Sig , _ STR , _ STR ) ; mv . visit Insn (  ATHROW ) ; }
public final  Pdf Object read Reference Table ( final  Pdf Object linear Obj , final  Pdf File Reader current Pdf File , final  Object Reader object Reader ) throws  Pdf Exception { int pointer = - _ NUM ; final int eof = ( int ) this . eof ; boolean islinearized Compressed = _ BOOL ; if ( linear Obj == null ) { pointer = read First Start Ref ( ) ; } else { final byte [ ] data = pdf_datafile . get Pdf Buffer ( ) ; final int count = data . length ; int ptr = _ NUM ; for ( int i = _ NUM ; i < count ; i ++ ) { if ( data [ i ] == _ STR && data [ i + _ NUM ] == _ STR && data [ i + _ NUM ] == _ STR && data [ i + _ NUM ] == _ STR && data [ i + _ NUM ] == _ STR && data [ i + _ NUM ] == _ STR ) { ptr = i + _ NUM ; } if ( data [ i ] == _ STR && data [ i + _ NUM ] == _ STR && data [ i + _ NUM ] == _ STR && data [ i + _ NUM ] == _ STR ) { pointer = i ; i = count ; } else if ( data [ i ] == _ STR && data [ i + _ NUM ] == _ STR && data [ i + _ NUM ] == _ STR && data [ i + _ NUM ] == _ STR ) { islinearized Compressed = _ BOOL ; pointer = ptr ; while ( data [ pointer ] == _ NUM || data [ pointer ] == _ NUM || data [ pointer ] == _ NUM ) { pointer ++ ; } i = count ; } } } offset . add Xref ( pointer ) ;  Pdf Object root Obj = null ; if ( pointer >= eof || pointer == _ NUM ) {  Log Writer . write Log ( _ STR ) ; offset . set Ref Table Invalid ( _ BOOL ) ; try { root Obj = new  Page Object (  Broken Ref Table . find Offsets ( pdf_datafile , offset ) ) ; } catch (  Error err ) { throw new  Pdf Exception ( err . get Message ( ) + _ STR ) ; } current Pdf File . read Object ( root Obj ) ; return root Obj ; } else if ( islinearized Compressed || is Compressed Stream ( pointer , eof ) ) { return read Compressed Stream ( root Obj , pointer , current Pdf File , object Reader , linear Obj ) ; } else { return read Legacy Reference Table ( root Obj , pointer , eof , current Pdf File ) ; } }
public static void main (  String [ ] args ) { main ( suite ( ) , args ) ; }
boolean await Exchange (  E e , int start ) { for ( int step = _ NUM , total Spins = _ NUM ; ( step <  ARENA_ LENGTH ) && ( total Spins <  SPINS ) ; step ++ ) { int index = ( start + step ) &  ARENA_ MASK ;  Atomic Reference <  Object > slot = arena [ index ] ;  Object found = slot . get ( ) ; if ( ( found ==  WAITER ) && slot . compare And Set (  WAITER , e ) ) { return _ BOOL ; } else if ( ( found ==  FREE ) && slot . compare And Set (  FREE , e ) ) { int slot Spins = _ NUM ; for ( ; ; ) { found = slot . get ( ) ; if ( found != e ) { return _ BOOL ; } else if ( ( slot Spins >=  SPINS_ PER_ STEP ) && ( slot . compare And Set ( e ,  FREE ) ) ) { total Spins += slot Spins ; break ; } slot Spins ++ ; } } } return _ BOOL ; }
public static double [ ] [ ] udary ( int m , int n ) { double d [ ] [ ] = new double [ m ] [ n ] ; for ( int i = _ NUM ; i < m ; i ++ ) { for ( int j = _ NUM ; j < n ; j ++ ) { d [ i ] [ j ] =  R . next Double ( ) ; } } return d ; }
public static int find Before New Line Char (  Char Sequence s , int start ) { for ( int i = start - _ NUM ; i > _ NUM ; i -- ) { if ( s . char At ( i ) == _ STR ) { return i ; } } return - _ NUM ; }
protected void assert Func Equals ( final  String ... inputs ) throws  Exception {  Solr Query Request req = req ( ) ; try { assert Func Equals ( req , inputs ) ; } finally { req . close ( ) ; } }
public void add Rect Shape ( float [ ] v , float [ ] v1 , float [ ] v2 , float [ ] v3 , float [ ] v4 , float [ ] v5 , float [ ] v6 , float [ ] v7 , int w , int h , int d ) { float [ ] var1 = new float [ ] { _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM } ; add Rect Shape ( v , v1 , v2 , v3 , v4 , v5 , v6 , v7 , w , h , d , var1 ) ; }
public static  String indent ( int indent ) {  String Buffer s = new  String Buffer ( ) ; for ( int i = _ NUM ; i < indent ; i ++ ) { s . append ( _ STR ) ; } return s . to String ( ) ; }
protected int to Julian ( java . util .  Date date ) {  YMD ymd = null ; synchronized ( gc ) { gc . set Time ( date ) ; ymd = new  YMD ( gc . get (  Gregorian Calendar .  YEAR ) , gc . get (  Gregorian Calendar .  MONTH ) + _ NUM , gc . get (  Gregorian Calendar .  DAY_ OF_ MONTH ) ) ; } return ymd . julian ( ) ; }
public synchronized void add (  K obj ) { int len = array . length ; array =  Arrays . copy Of ( array , len + _ NUM ) ; array [ len ] = obj ; }
private boolean serialize Compact RDFAttr Props (  XMPNode parent Node , int indent ) throws  IOException { boolean all Are Attrs = _ BOOL ; for (  Iterator it = parent Node . iterate Children ( ) ; it . has Next ( ) ; ) {  XMPNode prop = (  XMPNode ) it . next ( ) ; if ( can Be RDFAttr Prop ( prop ) ) { write Newline ( ) ; write Indent ( indent ) ; write ( prop . get Name ( ) ) ; write ( _ STR ) ; append Node Value ( prop . get Value ( ) , _ BOOL ) ; write ( _ STR ) ; } else { all Are Attrs = _ BOOL ; } } return all Are Attrs ; }
public default  Utility Table query Util (  BNetwork network ,  String query Var ) { return query Util ( new  Query .  Util Query ( network ,  Arrays . as List ( query Var ) , new  Assignment ( ) ) ) ; }
public  Block Chain Score ( final long score ) { this (  Big Integer . value Of ( score ) ) ; }
@  Override public void previous ( ) { current Image =  Optional . of ( add Index And Get Image By Offset ( - _ NUM ) ) ; event Bus . post ( new  Source Has Pending Update Event ( this ) ) ; }
public int read ( ) throws  IOException { if ( stream != null ) { return stream . read ( ) ; } else { return reader . read ( ) ; } }
private int find Activity Element ( int activity Index ) { for ( int element Index = _ NUM ; element Index < m Activity List . size ( ) ; element Index ++ ) { if ( m Activity List . get ( element Index ) . m Activity Index == activity Index ) { return element Index ; } } return - _ NUM ; }
public void write Byte ( int value ) throws  IOException { check Write Primitive Types ( ) ; primitive Types . write Byte ( value ) ; }
public  Storage Pool select Pool (  List <  Storage Pool > pool List ) { if ( pool List == null || pool List . is Empty ( ) ) { return null ; } _port Metrics Processor . compute Storage Pools Avg Port Metrics ( pool List ) ;  Collections . sort ( pool List , _storage Pool Comparator ) ; return pool List . get ( _ NUM ) ; }
public void on Register Click (  View view ) { if ( view != null ) {  Intent register = new  Intent (  Intent .  ACTION_ VIEW ,  Uri . parse ( get String (  R . string . welcome_link_url ) ) ) ; set Result (  RESULT_ CANCELED ) ; start Activity ( register ) ; } }
public  Email subject (  String subject ) { if ( subject == null ) throw new  Illegal Argument Exception ( _ STR ) ; this . subject = subject ; return this ; }
public static  String trim Name (  String line ) { int idx = line . index Of ( _ STR ) ; if ( idx != - _ NUM ) { line = line . substring ( _ NUM , idx ) ; } line = trim Line ( line ) ; idx = line . index Of ( _ STR ) ; if ( idx == - _ NUM ) { idx = line . index Of ( _ STR ) ; } if ( idx != - _ NUM ) { line = line . substring ( _ NUM , idx ) ; } return line . trim ( ) ; }
public double distance ( double p1 , double p2 ) { double d = ( p1 - p2 ) * ( p1 - p2 ) ; return  Math . sqrt ( d ) ; }
public  Iterator iterator ( ) { return listener List . iterator ( ) ; }
public void do Send Email (  Email Params email Params ) throws  IOException {  List <  String > filter Domains = new  Array List < > ( ) ; filter Domains . add ( _ STR ) ; filter Domains . add ( _ STR ) ; filter Domains . add ( _ STR ) ; filter Domains . add ( _ STR ) ; filter Domains . add ( _ STR ) ; send Via Sendcloud Api ( email Params ) ; }
public  Iterator <  IPoint > points ( ) { return points . iterator ( ) ; }
private void parse Test Class (  String test Class Name ,  Test Suite Builder test Suite Builder ) { int method Separator Index = test Class Name . index Of ( _ STR ) ;  String test Method Name = null ; if ( method Separator Index > _ NUM ) { test Method Name = test Class Name . substring ( method Separator Index + _ NUM ) ; test Class Name = test Class Name . substring ( _ NUM , method Separator Index ) ; } test Suite Builder . add Test Class By Name ( test Class Name , test Method Name , get Target Context ( ) ) ; }
public long signal ( ) { return  Long . parse Long ( fields [ _ NUM ] ) ; }
public static boolean declares Exception (  Method method ,  Class < ? > exception Type ) {  Assert . not Null ( method , _ STR ) ;  Class < ? > [ ] declared Exceptions = method . get Exception Types ( ) ; for (  Class < ? > declared Exception : declared Exceptions ) { if ( declared Exception . is Assignable From ( exception Type ) ) { return _ BOOL ; } } return _ BOOL ; }
private void save Impl (  File Location loc ) throws  IOException {  Output Stream out = loc . get Output Stream ( ) ;  Print Writer w = new  Print Writer ( new  Buffered Writer ( new  Unicode Writer ( out , get Encoding ( ) ) ) ) ; try { write ( w ) ; } finally { w . close ( ) ; } }
public boolean bound Scroll Raw ( ) { float cur Scroll = get Stack Scroll ( ) ; float new Scroll = get Bounded Stack Scroll ( cur Scroll ) ; if (  Float . compare ( new Scroll , cur Scroll ) != _ NUM ) { set Stack Scroll Raw ( new Scroll ) ; return _ BOOL ; } return _ BOOL ; }
public  Voice ( ) { }
public void append ( int key , byte value ) { if ( m Size != _ NUM && key <= m Keys [ m Size - _ NUM ] ) { put ( key , value ) ; return ; } int pos = m Size ; if ( pos >= m Keys . length ) { int n =  Array Utils . ideal Int Array Size ( pos + _ NUM ) ; int [ ] nkeys = new int [ n ] ; byte [ ] nvalues = new byte [ n ] ;  System . arraycopy ( m Keys , _ NUM , nkeys , _ NUM , m Keys . length ) ;  System . arraycopy ( m Values , _ NUM , nvalues , _ NUM , m Values . length ) ; m Keys = nkeys ; m Values = nvalues ; } m Keys [ pos ] = key ; m Values [ pos ] = value ; m Size = pos + _ NUM ; }
public synchronized void remove Batch Classifier Listener (  Batch Classifier Listener cl ) { m_batch Classifier Listeners . remove ( cl ) ; }
public final float read Float ( ) throws java . io .  IOException { return  Float . int Bits To Float ( read Int ( ) ) ; }
public static void sync Modification Times (  Configuration conf ,  Path src ,  Path dest ,  Optional <  Path Filter > filter ) throws  IOException {  Set <  File Status > src File Statuses = get File Statuses Recursive ( conf , src , filter ) ;  Map <  String ,  Long > src File Modification Times = null ; try { src File Modification Times = get Relative Path To Modification Time ( src , src File Statuses ) ; } catch (  Argument Exception e ) { throw new  IOException ( _ STR , e ) ; }  File System dest Fs = dest . get File System ( conf ) ; for (  String file : src File Modification Times . key Set ( ) ) { dest Fs . set Times ( new  Path ( dest , file ) , src File Modification Times . get ( file ) , - _ NUM ) ; } }
protected void convert From (  Blackboard bb ,  Sql Node from ) { if ( from == null ) { bb . set Root (  Logical Values . create One Row ( cluster ) , _ BOOL ) ; return ; } final  Sql Call call ; final  Sql Node [ ] operands ; switch ( from . get Kind ( ) ) { case  AS : convert From ( bb , ( (  Sql Call ) from ) . operand ( _ NUM ) ) ; return ; case  WITH_ ITEM : convert From ( bb , ( (  Sql With Item ) from ) . query ) ; return ; case  WITH : convert From ( bb , ( (  Sql With ) from ) . body ) ; return ; case  TABLESAMPLE : operands = ( (  Sql Basic Call ) from ) . get Operands ( ) ;  Sql Sample Spec sample Spec =  Sql Literal . sample Value ( operands [ _ NUM ] ) ; if ( sample Spec instanceof  Sql Sample Spec .  Sql Substitution Sample Spec ) {  String sample Name = ( (  Sql Sample Spec .  Sql Substitution Sample Spec ) sample Spec ) . get Name ( ) ; dataset Stack . push ( sample Name ) ; convert From ( bb , operands [ _ NUM ] ) ; dataset Stack . pop ( ) ; } else if ( sample Spec instanceof  Sql Sample Spec .  Sql Table Sample Spec ) {  Sql Sample Spec .  Sql Table Sample Spec table Sample Spec = (  Sql Sample Spec .  Sql Table Sample Spec ) sample Spec ; convert From ( bb , operands [ _ NUM ] ) ;  Rel Opt Sampling Parameters params = new  Rel Opt Sampling Parameters ( table Sample Spec . is Bernoulli ( ) , table Sample Spec . get Sample Percentage ( ) , table Sample Spec . is Repeatable ( ) , table Sample Spec . get Repeatable Seed ( ) ) ; bb . set Root ( new  Sample ( cluster , bb . root , params ) , _ BOOL ) ; } else { throw  Util . new Internal ( _ STR + sample Spec ) ; } return ; case  IDENTIFIER : final  Sql Validator Namespace from Namespace = validator . get Namespace ( from ) . resolve ( ) ; if ( from Namespace . get Node ( ) != null ) { convert From ( bb , from Namespace . get Node ( ) ) ; return ; } final  String dataset Name = dataset Stack . is Empty ( ) ? null : dataset Stack . peek ( ) ; boolean [ ] used Dataset = { _ BOOL } ;  Rel Opt Table table =  Sql Validator Util . get Rel Opt Table ( from Namespace , catalog Reader , dataset Name , used Dataset ) ; final  Rel Node table Rel ; if ( should Convert Table Access ) { table Rel = to Rel ( table ) ; } else { table Rel =  Logical Table Scan . create ( cluster , table ) ; } bb . set Root ( table Rel , _ BOOL ) ; if ( used Dataset [ _ NUM ] ) { bb . set Dataset ( dataset Name ) ; } return ; case  JOIN : final  Sql Join join = (  Sql Join ) from ; final  Sql Validator Scope scope = validator . get Join Scope ( from ) ; final  Blackboard from Blackboard = create Blackboard ( scope , null , _ BOOL ) ;  Sql Node left = join . get Left ( ) ;  Sql Node right = join . get Right ( ) ; final boolean is Natural = join . is Natural ( ) ; final  Join Type join Type = join . get Join Type ( ) ; final  Sql Validator Scope left Scope =  Util . first ( validator . get Join Scope ( left ) , ( (  Delegating Scope ) bb . scope ) . get Parent ( ) ) ; final  Blackboard left Blackboard = create Blackboard ( left Scope , null , _ BOOL ) ; final  Sql Validator Scope right Scope =  Util . first ( validator . get Join Scope ( right ) , ( (  Delegating Scope ) bb . scope ) . get Parent ( ) ) ; final  Blackboard right Blackboard = create Blackboard ( right Scope , null , _ BOOL ) ; convert From ( left Blackboard , left ) ;  Rel Node left Rel = left Blackboard . root ; convert From ( right Blackboard , right ) ;  Rel Node right Rel = right Blackboard . root ;  Join Rel Type converted Join Type = convert Join Type ( join Type ) ;  Rex Node condition Exp ; final  Sql Validator Namespace left Namespace = validator . get Namespace ( left ) ; final  Sql Validator Namespace right Namespace = validator . get Namespace ( right ) ; if ( is Natural ) { final  Rel Data Type left Row Type = left Namespace . get Row Type ( ) ; final  Rel Data Type right Row Type = right Namespace . get Row Type ( ) ; final  List <  String > column List =  Sql Validator Util . derive Natural Join Column List ( left Row Type , right Row Type ) ; condition Exp = convert Using ( left Namespace , right Namespace , column List ) ; } else { condition Exp = convert Join Condition ( from Blackboard , left Namespace , right Namespace , join . get Condition ( ) , join . get Condition Type ( ) , left Rel , right Rel ) ; } final  Rel Node join Rel = create Join ( from Blackboard , left Rel , right Rel , condition Exp , converted Join Type ) ; bb . set Root ( join Rel , _ BOOL ) ; return ; case  SELECT : case  INTERSECT : case  EXCEPT : case  UNION : final  Rel Node rel = convert Query Recursive ( from , _ BOOL , null ) . project ( ) ; bb . set Root ( rel , _ BOOL ) ; return ; case  VALUES : convert Values Impl ( bb , (  Sql Call ) from , null ) ; return ; case  UNNEST : call = (  Sql Call ) from ; final  List <  Sql Node > nodes = call . get Operand List ( ) ; final  Sql Unnest Operator operator = (  Sql Unnest Operator ) call . get Operator ( ) ; for (  Sql Node node : nodes ) { replace Subqueries ( bb , node ,  Rel Opt Util .  Logic .  TRUE_ FALSE_ UNKNOWN ) ; } final  List <  Rex Node > exprs = new  Array List < > ( ) ; final  List <  String > field Names = new  Array List < > ( ) ; for (  Ord <  Sql Node > node :  Ord . zip ( nodes ) ) { exprs . add ( bb . convert Expression ( node . e ) ) ; field Names . add ( validator . derive Alias ( node . e , node . i ) ) ; } final  Rel Node input =  Rel Opt Util . create Project ( ( null != bb . root ) ? bb . root :  Logical Values . create One Row ( cluster ) , exprs , field Names , _ BOOL ) ;  Uncollect uncollect = new  Uncollect ( cluster , cluster . trait Set Of (  Convention .  NONE ) , input , operator . with Ordinality ) ; bb . set Root ( uncollect , _ BOOL ) ; return ; case  COLLECTION_ TABLE : call = (  Sql Call ) from ; assert call . get Operand List ( ) . size ( ) == _ NUM ; final  Sql Call call2 = call . operand ( _ NUM ) ; convert Collection Table ( bb , call2 ) ; return ; default : throw  Util . new Internal ( _ STR + from ) ; } }
public void zoom To Camera ( float z Offset ) { if ( z Offset > (  Z_ FAR - _ NUM ) ) { z Offset =  Z_ FAR - _ NUM ; logger . info ( _ STR + z Offset ) ; } if ( z Offset < (  ZOOM_ MAX ) ) { z Offset =  ZOOM_ MAX ; logger . info ( _ STR + z Offset ) ; } target Zoff = z Offset ; is Scene Changed = _ BOOL ; }
private void configure Button (  JButton button ) {  Font button Font = (  Font )  Default Lookup . get ( option Pane , this , _ STR ) ; if ( button Font != null ) { button . set Font ( button Font ) ; } }
default  Filterable <  T > retain All ( final  Stream < ? extends  T > stream ) { final  Set <  T > set = stream . collect (  Collectors . to Set ( ) ) ; return filter ( null ) ; }
public void draw Shape ( int x , int y , int w , int h ,  Map <  String ,  Object > style ) {  Color pen Color = mx Utils . get Color ( style , mx Constants .  STYLE_ STROKECOLOR ) ; float pen Width = mx Utils . get Float ( style , mx Constants .  STYLE_ STROKEWIDTH , _ NUM ) ; int pw = ( int )  Math . ceil ( pen Width * scale ) ; if ( g . hit Clip ( x - pw , y - pw , w + _ NUM * pw , h + _ NUM * pw ) ) { boolean shadow = mx Utils . is True ( style , mx Constants .  STYLE_ SHADOW , _ BOOL ) ;  Color fill Color = mx Utils . get Style Fill Color ( style ) ;  Paint fill Paint = get Fill Paint ( new  Rectangle ( x , y , w , h ) , fill Color , style ) ; if ( pen Width > _ NUM ) { set Stroke ( pen Width , style ) ; }  String shape = mx Utils . get String ( style , mx Constants .  STYLE_ SHAPE , _ STR ) ; if ( shape . equals ( mx Constants .  SHAPE_ IMAGE ) ) {  String img = get Image For Style ( style ) ; if ( img != null ) { draw Image ( x , y , w , h , img ) ; } } else if ( shape . equals ( mx Constants .  SHAPE_ LINE ) ) { if ( pen Color != null ) { g . set Color ( pen Color ) ;  String direction = mx Utils . get String ( style , mx Constants .  STYLE_ DIRECTION , mx Constants .  DIRECTION_ EAST ) ; if ( direction . equals ( mx Constants .  DIRECTION_ EAST ) || direction . equals ( mx Constants .  DIRECTION_ WEST ) ) { int mid = ( int ) ( y + h / _ NUM ) ; draw Line ( x , mid , x + w , mid ) ; } else { int mid = ( int ) ( x + w / _ NUM ) ; draw Line ( mid , y , mid , y + h ) ; } } } else if ( shape . equals ( mx Constants .  SHAPE_ ELLIPSE ) ) { draw Oval ( x , y , w , h , fill Color , fill Paint , pen Color , shadow ) ; } else if ( shape . equals ( mx Constants .  SHAPE_ DOUBLE_ ELLIPSE ) ) { draw Oval ( x , y , w , h , fill Color , fill Paint , pen Color , shadow ) ; int inset = ( int ) ( ( _ NUM + pen Width ) * scale ) ; x += inset ; y += inset ; w -= _ NUM * inset ; h -= _ NUM * inset ; draw Oval ( x , y , w , h , null , null , pen Color , _ BOOL ) ; } else if ( shape . equals ( mx Constants .  SHAPE_ RHOMBUS ) ) { draw Rhombus ( x , y , w , h , fill Color , fill Paint , pen Color , shadow ) ; } else if ( shape . equals ( mx Constants .  SHAPE_ CYLINDER ) ) { draw Cylinder ( x , y , w , h , fill Color , fill Paint , pen Color , shadow ) ; } else if ( shape . equals ( mx Constants .  SHAPE_ ACTOR ) ) { draw Actor ( x , y , w , h , fill Color , fill Paint , pen Color , shadow ) ; } else if ( shape . equals ( mx Constants .  SHAPE_ CLOUD ) ) { draw Cloud ( x , y , w , h , fill Color , fill Paint , pen Color , shadow ) ; } else if ( shape . equals ( mx Constants .  SHAPE_ TRIANGLE ) ) {  String direction = mx Utils . get String ( style , mx Constants .  STYLE_ DIRECTION , _ STR ) ; draw Triangle ( x , y , w , h , fill Color , fill Paint , pen Color , shadow , direction ) ; } else if ( shape . equals ( mx Constants .  SHAPE_ HEXAGON ) ) {  String direction = mx Utils . get String ( style , mx Constants .  STYLE_ DIRECTION , _ STR ) ; draw Hexagon ( x , y , w , h , fill Color , fill Paint , pen Color , shadow , direction ) ; } else { draw Rect ( x , y , w , h , fill Color , fill Paint , pen Color , shadow , mx Utils . is True ( style , mx Constants .  STYLE_ ROUNDED ) ) ; if ( shape . equals ( mx Constants .  SHAPE_ LABEL ) ) {  String img = get Image For Style ( style ) ; if ( img != null ) {  String img Align = mx Utils . get String ( style , mx Constants .  STYLE_ IMAGE_ ALIGN , mx Constants .  ALIGN_ CENTER ) ;  String img Valign = mx Utils . get String ( style , mx Constants .  STYLE_ IMAGE_ VERTICAL_ ALIGN , mx Constants .  ALIGN_ MIDDLE ) ; int img Width = ( int ) ( mx Utils . get Int ( style , mx Constants .  STYLE_ IMAGE_ WIDTH , mx Constants .  DEFAULT_ IMAGESIZE ) * scale ) ; int img Height = ( int ) ( mx Utils . get Int ( style , mx Constants .  STYLE_ IMAGE_ HEIGHT , mx Constants .  DEFAULT_ IMAGESIZE ) * scale ) ; int spacing = ( int ) ( mx Utils . get Int ( style , mx Constants .  STYLE_ SPACING , _ NUM ) * scale ) ; int img X = x ; if ( img Align . equals ( mx Constants .  ALIGN_ LEFT ) ) { img X += spacing ; } else if ( img Align . equals ( mx Constants .  ALIGN_ RIGHT ) ) { img X += w - img Width - spacing ; } else { img X += ( w - img Width ) / _ NUM ; } int img Y = y ; if ( img Valign . equals ( mx Constants .  ALIGN_ TOP ) ) { img Y += spacing ; } else if ( img Valign . equals ( mx Constants .  ALIGN_ BOTTOM ) ) { img Y += h - img Height - spacing ; } else { img Y += ( h - img Height ) / _ NUM ; } draw Image ( img X , img Y , img Width , img Height , img ) ; } } } } }
public  Rect guaranteed Safe Crop ( int width , int height , @  Nullable  Rect crop ) { if ( crop == null ) { return new  Rect ( _ NUM , _ NUM , width , height ) ; }  Rect safe Crop = new  Rect ( crop ) ; if ( crop . top > crop . bottom || crop . left > crop . right || crop . width ( ) <= _ NUM || crop . height ( ) <= _ NUM ) { return new  Rect ( _ NUM , _ NUM , _ NUM , _ NUM ) ; } safe Crop . left =  Math . max ( safe Crop . left , _ NUM ) ; safe Crop . top =  Math . max ( safe Crop . top , _ NUM ) ; safe Crop . right =  Math . max (  Math . min ( safe Crop . right , width ) , safe Crop . left ) ; safe Crop . bottom =  Math . max (  Math . min ( safe Crop . bottom , height ) , safe Crop . top ) ; if ( safe Crop . width ( ) <= _ NUM || safe Crop . height ( ) <= _ NUM ) { return new  Rect ( _ NUM , _ NUM , _ NUM , _ NUM ) ; } return safe Crop ; }
@  Override public void flush ( ) throws  IOException { stream . flush ( ) ; }
public void attach (  Component comp ) { if ( comp != owner ) { components . add ( comp ) ; } }
public int x ( double lon ) { return ( int )  Math . round ( dots Per Deg * ( lon - origin Lon ) * lon Corr ) ; }
@  Override public boolean equals (  Object o ) { return o != null && o . get Class ( ) == get Class ( ) ; }
public boolean put Register Content ( int register Number ,  String content ) { try { registers [ register Number ] =  Double . parse Double ( content ) ; } catch (  Number Format Exception nfe ) { return _ BOOL ; } return _ BOOL ; }
private void add (  Session ID session ID ) { remote Session Set . add ( session ID ) ; }
public boolean is Dirty ( ) { return dirty . get ( ) ; }
public static byte [ ] hmac MD5 ( byte [ ] data , byte [ ] key ) throws  Exception { byte [ ] ipad = new byte [ _ NUM ] ; byte [ ] opad = new byte [ _ NUM ] ; for ( int i = _ NUM ; i < _ NUM ; i ++ ) { if ( i < key . length ) { ipad [ i ] = ( byte ) ( key [ i ] ^ _ NUM ) ; opad [ i ] = ( byte ) ( key [ i ] ^ _ NUM ) ; } else { ipad [ i ] = _ NUM ; opad [ i ] = _ NUM ; } } byte [ ] content = new byte [ data . length + _ NUM ] ;  System . arraycopy ( ipad , _ NUM , content , _ NUM , _ NUM ) ;  System . arraycopy ( data , _ NUM , content , _ NUM , data . length ) ;  Message Digest md5 =  Message Digest . get Instance ( _ STR ) ; data = md5 . digest ( content ) ; content = new byte [ data . length + _ NUM ] ;  System . arraycopy ( opad , _ NUM , content , _ NUM , _ NUM ) ;  System . arraycopy ( data , _ NUM , content , _ NUM , data . length ) ; return md5 . digest ( content ) ; }
public boolean ends With (  String string ) { if ( string == null ) return _ BOOL ; int strlen = string . length ( ) ; if ( _length < strlen ) return _ BOOL ; char [ ] buffer = _buffer ; int offset = _offset + _length - strlen ; while ( -- strlen >= _ NUM ) { if ( buffer [ offset + strlen ] != string . char At ( strlen ) ) return _ BOOL ; } return _ BOOL ; }
public void write Raw Bytes ( final byte [ ] value , int offset , int length ) throws  IOException { if ( limit - position >= length ) {  System . arraycopy ( value , offset , buffer , position , length ) ; position += length ; total Bytes Written += length ; } else { final int bytes Written = limit - position ;  System . arraycopy ( value , offset , buffer , position , bytes Written ) ; offset += bytes Written ; length -= bytes Written ; position = limit ; total Bytes Written += bytes Written ; refresh Buffer ( ) ; if ( length <= limit ) {  System . arraycopy ( value , offset , buffer , _ NUM , length ) ; position = length ; } else { output . write ( value , offset , length ) ; } total Bytes Written += length ; } }
public void add Src Class (  Soot Class clz ) { src Classes . add ( clz . get Name ( ) ) ; }
public  Builder with Tags (  Map <  String ,  String > tags ) { this . tags =  Collections . unmodifiable Map ( tags ) ; return this ; }
public void expand All ( ) { int row = _ NUM ; while ( row < get Row Count ( ) ) { expand Row ( row ) ; row ++ ; } }
void release If Locked (  Object name ,  Internal Distributed Member owner , int lock Id ) throws  Interrupted Exception { wait While Initializing ( ) ; if ( ! acquire Destroy Read Lock ( _ NUM ) ) { wait Until Destroyed ( ) ; check Destroyed ( ) ; } try { check Destroyed ( ) ; get And Release Grant If Locked By ( name , owner , lock Id ) ; } finally { release Destroy Read Lock ( ) ; } }
public final  Array List <  Wifi Record > load Wifis Overview Within ( final int session , final  Double min Lon , final  Double max Lon , final  Double min Lat , final  Double max Lat ) { final  Array List <  Wifi Record > wifis = new  Array List < > ( ) ;  String selection = null ;  String [ ] selection Args = null ; if ( min Lon != null && max Lon != null && min Lat != null && max Lat != null ) { selection = _ STR +  Schema .  COL_ LONGITUDE + _ STR + _ STR +  Schema .  COL_ LONGITUDE + _ STR + _ STR +  Schema .  COL_ LATITUDE + _ STR + _ STR +  Schema .  COL_ LATITUDE + _ STR ; selection Args = new  String [ ] {  String . value Of ( min Lon ) ,  String . value Of ( max Lon ) ,  String . value Of ( min Lat ) ,  String . value Of ( max Lat ) } ; } final  Cursor cursor = content Resolver . query (  Content Uris . with Appended Id (  Uri . with Appended Path (  Content Provider .  CONTENT_ URI_ WIFI ,  Content Provider .  CONTENT_ URI_ OVERVIEW_ SUFFIX ) , session ) , null , selection , selection Args , null ) ; final int column Index = cursor . get Column Index (  Schema .  COL_ BSSID ) ; final int column Index2 = cursor . get Column Index (  Schema .  COL_ SSID ) ; final int column Index3 = cursor . get Column Index (  Schema .  COL_ CAPABILITIES ) ; final int column Index4 = cursor . get Column Index (  Schema .  COL_ FREQUENCY ) ; final int column Index5 = cursor . get Column Index (  Schema .  COL_ MAX_ LEVEL ) ; final int column Index6 = cursor . get Column Index (  Schema .  COL_ TIMESTAMP ) ; final int column Index7 = cursor . get Column Index (  Schema .  COL_ BEGIN_ POSITION_ ID ) ; final int column Index8 = cursor . get Column Index (  Schema .  COL_ END_ POSITION_ ID ) ; final int column Index9 = cursor . get Column Index (  Schema .  COL_ KNOWN_ WIFI ) ; while ( cursor . move To Next ( ) ) { final  Wifi Record wifi = new  Wifi Record ( ) ; wifi . set Bssid ( cursor . get String ( column Index ) ) ; wifi . set Ssid ( cursor . get String ( column Index2 ) ) ; wifi . set Capabilities ( cursor . get String ( column Index3 ) ) ; wifi . set Frequency ( cursor . get Int ( column Index4 ) ) ; wifi . set Level ( cursor . get Int ( column Index5 ) ) ; wifi . set Open Bmap Timestamp ( cursor . get Long ( column Index6 ) ) ; wifi . set Begin Position ( load Position By Id ( cursor . get String ( column Index7 ) ) ) ; wifi . set End Position ( load Position By Id ( cursor . get String ( column Index8 ) ) ) ; wifi . set Catalog Status (  Catalog Status . values ( ) [ cursor . get Int ( column Index9 ) ] ) ; wifis . add ( wifi ) ; } cursor . close ( ) ; return wifis ; }
public  Check Box List ( ) { this ( null ) ; }
final protected  Outgoing Batch requery If Enough Time Has Passed ( long ts ,  Outgoing Batch current Batch ) { if (  System . current Time Millis ( ) - ts >  MS_ PASSED_ BEFORE_ BATCH_ REQUERIED ) { current Batch = outgoing Batch Service . find Outgoing Batch ( current Batch . get Batch Id ( ) , current Batch . get Node Id ( ) ) ; } return current Batch ; }
public static  Default Job Definition fixed Delay Job Definition ( final  String job Type , final  String job Name , final  String description , final  Duration fixed Delay , final int restarts , final  Optional <  Duration > max Age ) { return new  Default Job Definition ( job Type , job Name , description , max Age ,  Optional . of ( fixed Delay ) ,  Optional . empty ( ) , restarts , _ NUM ,  Optional . empty ( ) ) ; }
public static _ Fields find By Thrift Id ( int field Id ) { switch ( field Id ) { case _ NUM : return  MESSAGE ; case _ NUM : return  TYPE ; default : return null ; } }
public static void put Long LE ( long addr , long val ) { if (  UNALIGNED )  UNSAFE . put Long ( addr ,  Long . reverse Bytes ( val ) ) ; else put Long By Byte ( addr , val , _ BOOL ) ; }
private static void create Reader (  Input Stream input Stream ) { try { close Reader ( ) ;  Reader i Reader = new  Input Stream Reader ( input Stream , _ STR ) ; reader = new  Buffered Reader ( i Reader ) ; } catch (  Unsupported Encoding Exception e ) { e . print Stack Trace ( ) ; } }
public org . w3c . dom .  Element sign XML ( org . w3c . dom .  Document doc , java . lang .  String cert Alias , java . lang .  String algorithm , java . util .  List ids ) throws  XMLSignature Exception { return sign XML ( doc , cert Alias , algorithm , null , ids ) ; }
public static  Data Type create Object (  String class Name ,  String value ) { try {  Class < ? > the Class =  Class . for Name ( class Name ) ;  Class < ? > [ ] constructor Parameters = new  Class [ _ NUM ] ; constructor Parameters [ _ NUM ] =  Class . for Name ( _ STR ) ;  Constructor < ? > class Constructor = the Class . get Constructor ( constructor Parameters ) ; return (  Data Type ) class Constructor . new Instance ( value ) ; } catch (  Exception ex ) {  Log . e ( _ STR , _ STR + class Name + _ STR + value ) ; } return null ; }
public  Index File ( final  File dir ) throws  IOException { m Preread Arm =  Preread Arm .  UNKNOWN ; m Preread Type =  Preread Type .  UNKNOWN ; m Sdf Id = new  Sdf Id ( _ NUM ) ; final  File index = new  File ( dir ,  Sdf File Utils .  INDEX_ FILENAME ) ; try (  Data Input Stream index Stream = new  Data Input Stream ( new  Buffered Input Stream ( new  File Input Stream ( index ) ,  File Utils .  BUFFERED_ STREAM_ SIZE ) ) ) { final  Preread Hash Function header Hash = new  Preread Hash Function ( ) ; version1 Load ( index Stream , header Hash , dir ) ; if ( m Version >  VERSION ) { throw new  No Talkback Slim Exception ( _ STR + dir . to String ( ) + _ STR ) ; } load Version3 Fields ( index Stream , header Hash ) ; load Version4 Fields ( index Stream , header Hash , dir ) ; load Version6 Fields ( index Stream , header Hash ) ; load Version8 Fields ( index Stream , header Hash ) ; load Version9 Fields ( ) ; load Version10 Fields ( index Stream , header Hash ) ; load Version12 Fields ( index Stream , header Hash ) ; load Version13 Fields ( index Stream , header Hash ) ; checksum Load ( index Stream , header Hash , dir ) ; } catch ( final  EOFException e ) { throw new  Corrupt Sdf Exception ( dir ) ; } }
public static int dial Down Heat (  Mounted weapon ,  Weapon Type wtype ) { return  Compute . dial Down Heat ( weapon , wtype , _ NUM ) ; }
public void fix Conversion (  String rep ) { if ( s Hash Code != rep . hash Code ( ) ) throw new  Runtime Exception ( _ STR ) ; if ( s == null ) { s = rep ; } }
public void add Action Listener (  Action Listener listener ) { }
@  Deprecated public  Shapeless Recipe remove Ingredient ( int count ,  Material ingredient , int rawdata ) {  Iterator <  Item Stack > iterator = ingredients . iterator ( ) ; while ( count > _ NUM && iterator . has Next ( ) ) {  Item Stack stack = iterator . next ( ) ; if ( stack . get Type ( ) == ingredient && stack . get Durability ( ) == rawdata ) { iterator . remove ( ) ; count -- ; } } return this ; }
private  Order apply Order By ( ) { final  String order By = sord == null ? ord : sord ; final  String order By Field = sidx == null ? search Field : sidx ; if ( order By . equals ( _ STR ) ) return  Order . asc ( order By Field ) ; else return  Order . desc ( order By Field ) ; }
public static  String map Unsupported Encoding (  String encoding ) { if ( encoding . equals Ignore Case ( _ STR ) ) { return _ STR ; } return encoding ; }
public static boolean looks Like ABGPosition (  String val ) { return  BACKGROUND_ POSITIONS_ IDENTS . contains ( val ) || looks Like ALength ( val ) ; }
static  Process fork Process (  File directory ,  String ... process Args ) throws  IOException {  Process Builder process Builder = new  Process Builder ( process Args ) ; process Builder . directory ( directory ) ; process Builder . redirect Error Stream ( _ BOOL ) ; return process Builder . start ( ) ; }
public void add Meta (  T meta ) { if ( meta != null ) { if ( m Meta == null ) { m Meta = new  Array List < > ( ) ; } m Meta . add ( meta ) ; } }
private  Matches lookup Do (  Template tmpl , int max Matches ) { if ( max Matches < _ NUM ) throw new  Illegal Argument Exception ( _ STR ) ; int total Matches = _ NUM ;  Array List <  Item > matches = null ;  Item Iter iter = matching Items ( tmpl ) ; if ( max Matches > _ NUM || iter . dups Possible ) { int suggested Size = iter . suggested Size ( ) ; suggested Size = max Matches < suggested Size ? max Matches : suggested Size ; matches = new  Array List <  Item > ( suggested Size ) ; } if ( iter . dups Possible ) { while ( iter . has Next ( ) ) {  Item item = iter . next ( ) ; if ( ! matches . contains ( item ) ) matches . add ( item ) ; } total Matches = matches . size ( ) ; if ( max Matches > _ NUM ) { for ( int i = matches . size ( ) ; -- i >= max Matches ; ) matches . remove ( i ) ; for ( int i = matches . size ( ) ; -- i >= _ NUM ; ) { matches . set ( i , copy Item ( matches . get ( i ) ) ) ; } } else { matches = null ; } } else { while ( iter . has Next ( ) ) {  Item item = iter . next ( ) ; total Matches ++ ; if ( -- max Matches >= _ NUM ) matches . add ( copy Item ( item ) ) ; } } return new  Matches ( matches , total Matches ) ; }
public static  List <  History > find History By Job And Status (  Entity Manager em ,  JPAEntity job ,  Big Integer limit ,  Job Status job Status ) { require Argument ( em != null , _ STR ) ; require Argument ( job != null , _ STR ) ;  Typed Query <  History > query = em . create Named Query ( _ STR ,  History . class ) ; if ( limit != null ) { query . set Max Results ( limit . int Value ( ) ) ; } try { query . set Parameter ( _ STR , job ) ; query . set Parameter ( _ STR , job Status ) ; return query . get Result List ( ) ; } catch (  No Result Exception ex ) { return new  Array List <  History > ( _ NUM ) ; } }
protected boolean is WFXMLChar (  String chardata ,  Character ref Invalid Char ) { if ( chardata == null || ( chardata . length ( ) == _ NUM ) ) { return _ BOOL ; } char [ ] dataarray = chardata . to Char Array ( ) ; int datalength = dataarray . length ; if ( f Is XMLVersion11 ) { int i = _ NUM ; while ( i < datalength ) { if (  XML11 Char . is XML11 Invalid ( dataarray [ i ++ ] ) ) { char ch = dataarray [ i - _ NUM ] ; if (  XMLChar . is High Surrogate ( ch ) && i < datalength ) { char ch2 = dataarray [ i ++ ] ; if (  XMLChar . is Low Surrogate ( ch2 ) &&  XMLChar . is Supplemental (  XMLChar . supplemental ( ch , ch2 ) ) ) { continue ; } } ref Invalid Char = new  Character ( ch ) ; return _ BOOL ; } } } else { int i = _ NUM ; while ( i < datalength ) { if (  XMLChar . is Invalid ( dataarray [ i ++ ] ) ) { char ch = dataarray [ i - _ NUM ] ; if (  XMLChar . is High Surrogate ( ch ) && i < datalength ) { char ch2 = dataarray [ i ++ ] ; if (  XMLChar . is Low Surrogate ( ch2 ) &&  XMLChar . is Supplemental (  XMLChar . supplemental ( ch , ch2 ) ) ) { continue ; } } ref Invalid Char = new  Character ( ch ) ; return _ BOOL ; } } } return _ BOOL ; }
void update Pending Nodes ( final int new Landmark Index , final  Node to Node , final  Router Priority Queue <  Node > pending Nodes ) {  Iterator <  Node > it = pending Nodes . iterator ( ) ;  Pre Process Landmarks .  Landmarks Data to Role = get Pre Process Data ( to Node ) ;  Array List <  Double > new Est Rem Trav Costs = new  Array List <  Double > ( ) ;  Array List <  Node > nodes To Be Updated = new  Array List <  Node > ( ) ; while ( it . has Next ( ) ) {  Node node = it . next ( ) ;  AStar Node Data role = get Data ( node ) ;  Pre Process Landmarks .  Landmarks Data pp Role = get Pre Process Data ( node ) ; double est Rem Trav Cost = role . get Expected Remaining Cost ( ) ; double new Est Rem Trav Cost = estimate Remaining Travel Cost ( pp Role , to Role , new Landmark Index ) ; if ( new Est Rem Trav Cost > est Rem Trav Cost ) { nodes To Be Updated . add ( node ) ; new Est Rem Trav Costs . add ( new Est Rem Trav Cost ) ; } } for (  Node node : nodes To Be Updated ) { pending Nodes . remove ( node ) ; } for ( int i = _ NUM ; i < nodes To Be Updated . size ( ) ; i ++ ) {  Node node = nodes To Be Updated . get ( i ) ;  AStar Node Data data = get Data ( node ) ; data . set Expected Remaining Cost ( new Est Rem Trav Costs . get ( i ) ) ; pending Nodes . add ( node , get Priority ( data ) ) ; } }
public  Time random Time ( ) { if ( random . next Int ( _ NUM ) == _ NUM ) { return null ; }  String Builder buff = new  String Builder ( ) ; buff . append ( get Int ( _ NUM ) ) ; buff . append ( _ STR ) ; buff . append ( get Int ( _ NUM ) ) ; buff . append ( _ STR ) ; buff . append ( get Int ( _ NUM ) ) ; return  Time . value Of ( buff . to String ( ) ) ; }
private void paint Arrows (  Graphics2 D g ,  JComponent c , int width , int height ) { int x Offset = width / _ NUM - _ NUM ; int y Offset = height / _ NUM - _ NUM ; g . translate ( x Offset , y Offset ) ;  Shape s = shape Generator . create Arrow Left ( _ NUM , _ NUM , _ NUM , _ NUM ) ; g . set Paint ( get Common Arrow Paint ( s , type ) ) ; g . fill ( s ) ; s = shape Generator . create Arrow Right ( _ NUM , _ NUM , _ NUM , _ NUM ) ; g . set Paint ( get Common Arrow Paint ( s , type ) ) ; g . fill ( s ) ; g . translate ( - x Offset , - y Offset ) ; }
public void write Line ( long time , double [ ] column ) {  String str =  Long . to String ( time ) ; for ( int i = _ NUM ; i < column . length ; ++ i ) { str += _ STR + column [ i ] ; } writer . println ( str ) ; }
public static boolean is PEM ( byte [ ] byte Array ) { try {  String start PEM = _ STR ; int header Length = _ NUM ; byte [ ] preamble = new byte [ header Length ] ;  System . arraycopy ( byte Array , _ NUM , preamble , _ NUM , header Length ) ;  String start Array = new  String ( preamble ) ; return start Array . starts With ( start PEM ) ; } catch (  Exception e ) { throw new  DSSException ( _ STR ) ; } }
public  Weak Close Listener (  Object resource ) { _resource Ref = new  Weak Reference <  Object > ( resource ) ; }
@  Override public  Update Request routing (  String routing ) { if ( routing != null && routing . length ( ) == _ NUM ) { this . routing = null ; } else { this . routing = routing ; } return this ; }
public byte [ ] receive ( ) throws  IOException { if ( connection != null ) { packet . set Length (  Datagram Connection .  DEFAULT_ DATAGRAM_ SIZE ) ; connection . receive ( packet ) ; int packet Length = packet . get Length ( ) ; byte [ ] data = new byte [ packet Length ] ;  System . arraycopy ( packet . get Data ( ) , _ NUM , data , _ NUM , packet Length ) ; return data ; } else { throw new  IOException ( _ STR ) ; } }
@  Override protected void force Insert Attribute At ( int position ) { double [ ] new Values = new double [ m_ Att Values . length + _ NUM ] ;  System . arraycopy ( m_ Att Values , _ NUM , new Values , _ NUM , position ) ; new Values [ position ] =  Utils . missing Value ( ) ;  System . arraycopy ( m_ Att Values , position , new Values , position + _ NUM , m_ Att Values . length - position ) ; m_ Att Values = new Values ; }
protected void engine Init (  Key key ,  Algorithm Parameter Spec params ) throws  Invalid Key Exception ,  Invalid Algorithm Parameter Exception { if ( params != null ) { throw new  Invalid Algorithm Parameter Exception ( _ STR ) ; } if ( ! ( key instanceof  Secret Key ) ) { throw new  Invalid Key Exception ( _ STR ) ; } byte [ ] secret = key . get Encoded ( ) ; if ( secret == null ) { throw new  Invalid Key Exception ( _ STR ) ; } if ( secret . length > block Len ) { byte [ ] tmp = md . digest ( secret ) ;  Arrays . fill ( secret , ( byte ) _ NUM ) ; secret = tmp ; } for ( int i = _ NUM ; i < block Len ; i ++ ) { int si = ( i < secret . length ) ? secret [ i ] : _ NUM ; k_ipad [ i ] = ( byte ) ( si ^ _ NUM ) ; k_opad [ i ] = ( byte ) ( si ^ _ NUM ) ; }  Arrays . fill ( secret , ( byte ) _ NUM ) ; secret = null ; engine Reset ( ) ; }
public  Object return Instance ( final  String instance Key , final  Map <  String ,  Object > key Map ) {  Object instance = null ; if ( key Map . contains Key ( instance Key ) ) { instance = key Map . get ( instance Key ) ; } else { _logger . error ( _ STR , instance Key ) ; } return instance ; }
void start Scrolling Instance ( ) { if ( log . is Loggable (  Platform Logger .  Level .  FINER ) ) { log . finer ( _ STR + this ) ; } scroll ( ) ; i_scroller . set Scrollbar ( this ) ; i_scroller . start ( ) ; }
static  Class < ? > load Class (  String name ) { for (  Class Loader loader : loaders ( ) ) { try { return loader . load Class ( name ) ; } catch (  Class Not Found Exception ex ) { continue ; } } return null ; }
public static  List <  INavi Module > load Modules ( final  Abstract SQLProvider provider , final  List <  INavi Raw Module > raw Modules , final  Debugger Template Manager debugger Manager ) throws  Couldnt Load Data Exception {  Preconditions . check Not Null ( raw Modules , _ STR ) ;  Postgre SQLDatabase Functions . check Arguments ( provider , debugger Manager ) ; final  List <  CModule > modules = new  Array List < > ( ) ; final  CConnection connection = provider . get Connection ( ) ; if ( !  Postgre SQLHelpers . has Table ( connection ,  CTable Names .  MODULES_ TABLE ) ) { return new  Array List <  INavi Module > ( modules ) ; } final  String query = _ STR +  CTable Names .  MODULES_ TABLE + _ STR + _ STR + _ STR + _ STR +  CTable Names .  FUNCTIONS_ TABLE + _ STR + _ STR +  CTable Names .  FUNCTIONS_ TABLE + _ STR + _ STR + _ STR +  CTable Names .  MODULE_ VIEWS_ TABLE + _ STR +  CTable Names .  VIEWS_ TABLE + _ STR + _ STR +  CTable Names .  MODULES_ TABLE + _ STR + _ STR +  CTable Names .  MODULES_ TABLE + _ STR + _ STR ; try (  Result Set result Set = connection . execute Query ( query , _ BOOL ) ) { while ( result Set . next ( ) ) { final int module Id = result Set . get Int ( _ STR ) ; final  String name =  Postgre SQLHelpers . read String ( result Set , _ STR ) ; final  String md5 =  Postgre SQLHelpers . read String ( result Set , _ STR ) ; final  String sha1 =  Postgre SQLHelpers . read String ( result Set , _ STR ) ; final  String comment =  Postgre SQLHelpers . read String ( result Set , _ STR ) ; final  Timestamp timestamp = result Set . get Timestamp ( _ STR ) ; final  Timestamp modification Date = result Set . get Timestamp ( _ STR ) ; int function Count = result Set . get Int ( _ STR ) ; final int view Count = result Set . get Int ( _ STR ) ; final  IAddress image Base =  Postgre SQLHelpers . load Address ( result Set , _ STR ) ; final  IAddress file Base =  Postgre SQLHelpers . load Address ( result Set , _ STR ) ; final int debugger Id = result Set . get Int ( _ STR ) ; final boolean is Stared = result Set . get Boolean ( _ STR ) ; final int initialization State = result Set . get Int ( _ STR ) ; final  Debugger Template description = debugger Manager . find Debugger ( debugger Id ) ; final int raw Module Id = result Set . get Int ( _ STR ) ; final  INavi Raw Module raw Module =  Postgre SQLDatabase Functions . find Raw Module ( raw Module Id , raw Modules ) ; if ( ( function Count == _ NUM ) && ( raw Module != null ) ) { function Count = raw Module . get Function Count ( ) ; } modules . add ( new  CModule ( module Id , name , comment , timestamp , modification Date , md5 , sha1 , function Count , view Count , file Base , image Base , description , raw Module , initialization State , is Stared , provider ) ) ; } } catch ( final  SQLException e ) { throw new  Couldnt Load Data Exception ( e ) ; } return new  Array List <  INavi Module > ( modules ) ; }
void write (  Image Output Stream ios ) throws  IOException { length = _ NUM + ( ( data != null ) ? data . length : _ NUM ) ; write Tag ( ios ) ; if ( data != null ) { ios . write ( data ) ; } }
public static  Iterable <  Node > to Iterable (  Node List node List ) {  List <  Node > nodes = new  Array List < > ( node List . get Length ( ) ) ; for ( int i = _ NUM ; i < node List . get Length ( ) ; i ++ ) { nodes . add ( node List . item ( i ) ) ; } return nodes ; }
public  Named Thread Factory (  String name Prefix ) { this . _name Prefix = name Prefix ; _delegate =  Executors . default Thread Factory ( ) ; }
public void test_metric_heartbeat_uint32 ( ) { final  IGanglia Metadata Message decl = new  Ganglia Metadata Message ( _ STR , _ STR , _ BOOL ,  Ganglia Message Type Enum .  UINT32 , _ STR , _ STR ,  Ganglia Slope Enum . unspecified , _ NUM , _ NUM ,  Abstract Metrics . get Map (  IGanglia Attributes .  GROUP_ CORE , _ STR , _ STR ) ) ; assert Encode Decode ( null , decl ) ; final  IGanglia Metric Message expected = new  Ganglia Metric Message (  Ganglia Message Type Enum .  UINT32 , _ STR , _ STR , _ BOOL , _ STR ,  Long . value Of ( _ NUM ) ) ; final byte [ ] actual Data = assert Encode Decode ( decl , expected ) ; final byte [ ] expected Data = new byte [ ] { _ NUM , _ NUM , _ NUM , - _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , - _ NUM } ; if ( !  Arrays . equals ( expected Data , actual Data ) ) { fail ( _ STR +  Arrays . to String ( expected Data ) + _ STR +  Arrays . to String ( actual Data ) ) ; } }
@  Override public void delete Columns ( int start , int len ) throws  Fits Exception { ensure Data ( ) ;  Object [ ] new Data = new  Object [ this . n Fields - len ] ; int [ ] new Offsets = new int [ this . n Fields - len ] ; int [ ] new Lengths = new int [ this . n Fields - len ] ;  Class < ? > [ ] new Types = new  Class [ this . n Fields - len ] ;  String [ ] new Nulls = new  String [ this . n Fields - len ] ;  System . arraycopy ( this . data , _ NUM , new Data , _ NUM , start ) ;  System . arraycopy ( this . lengths , _ NUM , new Lengths , _ NUM , start ) ;  System . arraycopy ( this . types , _ NUM , new Types , _ NUM , start ) ;  System . arraycopy ( this . nulls , _ NUM , new Nulls , _ NUM , start ) ;  System . arraycopy ( this . data , start + len , new Data , start , this . n Fields - start - len ) ;  System . arraycopy ( this . lengths , start + len , new Lengths , start , this . n Fields - start - len ) ;  System . arraycopy ( this . types , start + len , new Types , start , this . n Fields - start - len ) ;  System . arraycopy ( this . nulls , start + len , new Nulls , start , this . n Fields - start - len ) ; for ( int i = start ; i < start + len ; i += _ NUM ) { this . row Len -= this . lengths [ i ] + _ NUM ; } this . data = new Data ; this . offsets = new Offsets ; this . lengths = new Lengths ; this . types = new Types ; this . nulls = new Nulls ; if ( this . is Null != null ) { boolean found = _ BOOL ; boolean [ ] new Is Null = new boolean [ this . n Rows * ( this . n Fields - len ) ] ; for ( int i = _ NUM ; i < this . n Rows ; i += _ NUM ) { int old Off = this . n Fields * i ; int new Off = ( this . n Fields - len ) * i ; for ( int col = _ NUM ; col < start ; col += _ NUM ) { new Is Null [ new Off + col ] = this . is Null [ old Off + col ] ; found = found || this . is Null [ old Off + col ] ; } for ( int col = start + len ; col < this . n Fields ; col += _ NUM ) { new Is Null [ new Off + col - len ] = this . is Null [ old Off + col ] ; found = found || this . is Null [ old Off + col ] ; } } if ( found ) { this . is Null = new Is Null ; } else { this . is Null = null ; } } this . buffer = null ; this . n Fields -= len ; }
void remove_phi (  Method m ) {  Deque <  Block > code = dfs ( m . entry . to ) ;  Set Map <  Block ,  Edge > pred = preds ( code ) ;  Map <  Integer ,  Integer > locals = new  Tree Map <  Integer ,  Integer > ( ) ;  Map <  Block ,  Deque <  Expr > > exprs = new  Tree Map <  Block ,  Deque <  Expr > > ( ) ;  Conflict Graph conflicts = new  Conflict Graph ( ) ; print Method ( m , _ STR ) ; add Trace Attr ( m ) ; restused : if ( m . needs Arguments ( ) || m . needs Rest ( ) ) { int rest = m . get Params ( ) . length ; for (  Expr e : m . entry . to ) if ( e . op ==  OP_arg && e . imm [ _ NUM ] == rest ) break restused ; m . flags &= ~ (  METHOD_ Arguments |  METHOD_ Needrest ) ; m . flags |=  METHOD_ Ignore Rest ; verbose Status ( _ STR + m . get Name ( ) ) ; } int max_local = m . get Params ( ) . length - _ NUM ; sched_greedy ( m , code , locals , pred , exprs , conflicts ) ; alloc_locals ( code , locals , conflicts , m . fixed Locals ) ;  Set <  Edge > splits = new  Tree Set <  Edge > ( ) ; for (  Block b : code ) { for (  Expr e : b ) { if ( e . op !=  OP_phi ) break ; if ( ! locals . contains Key ( e . id ) ) continue ; add Trace Attr ( e ) ; int lhs = locals . get ( e . id ) ; for ( int i = e . args . length - _ NUM ; i >= _ NUM ; i -- ) { trace Entry ( _ STR ) ; add Trace Attr ( _ STR , i ) ; add Trace Attr ( e . args [ i ] ) ; int rhs = locals . get ( e . args [ i ] . id ) ; if ( lhs != rhs ) {  Edge p = e . pred [ i ] ; if ( ! splits . contains ( p ) ) { split ( p , m , pred ) ; splits . add ( p = e . pred [ i ] ) ; } trace Entry ( _ STR ) ; add Trace Attr ( _ STR , lhs ) ; add Trace Attr ( _ STR , rhs ) ;  Expr get = getlocal ( m , rhs ) ; prepend ( p , get ) ; append ( p , setlocal ( m , lhs , get ) ) ; } } } b . exprs = exprs . get ( b ) ; for (  Expr e : b . exprs ) { int loc = max_local ; if ( e . op ==  OP_getlocal || e . op ==  OP_setlocal ) { loc = e . imm [ _ NUM ] = locals . get ( e . imm [ _ NUM ] ) ; } else if ( e . op ==  OP_hasnext2 ) { int loc0 = locals . get ( e . locals [ _ NUM ] . id ) ; int loc1 = locals . get ( e . locals [ _ NUM ] . id ) ; e . imm = new int [ ] { loc0 , loc1 } ; loc = loc0 > loc1 ? loc0 : loc1 ; } if ( loc > max_local ) max_local = loc ; } } m . local_count = max_local + _ NUM ; cfgopt ( m ) ; print Method ( m , _ STR ) ; }
public  SIPServer Transaction create Server Transaction (  Message Channel encapsulated Message Channel ) { if ( unlimited Server Transaction Table Size ) { return new  SIPServer Transaction ( this , encapsulated Message Channel ) ; } else { float threshold = ( ( float ) ( server Transaction Table . size ( ) - server Transaction Table Lowater Mark ) ) / ( ( float ) ( server Transaction Table Highwater Mark - server Transaction Table Lowater Mark ) ) ; boolean decision =  Math . random ( ) > _ NUM - threshold ; if ( decision ) { return null ; } else { return new  SIPServer Transaction ( this , encapsulated Message Channel ) ; } } }
public  Permuter ( int n ) { if ( n < _ NUM ) { throw new  Illegal Argument Exception ( ) ; } modulus = n ; if ( n == _ NUM ) { return ; } multiplier = ( int )  Math . sqrt ( n ) ; while ( gcd ( multiplier , n ) != _ NUM ) { if ( ++ multiplier == n ) { multiplier = _ NUM ; } } }
public void test Split And Join Multiple Properties On Pipe ( ) {  Properties inner =  Property Utils . split Properties On Pipe (  ONE_ PIPE_ TWO ) ; assert Equals ( _ STR , inner . get Property ( _ STR ) ) ; assert Equals ( _ STR , inner . get Property ( _ STR ) ) ; assert Equals ( _ NUM , inner . size ( ) ) ; try { assert Equals (  ONE_ PIPE_ TWO ,  Property Utils . join On Pipe (  Property Utils . to Map ( inner ) ) ) ; } catch (  Comparison Failure e ) { assert Equals (  TWO_ PIPE_ ONE ,  Property Utils . join On Pipe (  Property Utils . to Map ( inner ) ) ) ; } }
public void test Getter Inheritance ( ) throws  Exception {  Object Mapper m = new  Object Mapper ( ) ;  Map <  String ,  Object > result = write And Map ( m , new  Sub Class Bean ( ) ) ; assert Equals ( _ NUM , result . size ( ) ) ; assert Equals (  Integer . value Of ( _ NUM ) , result . get ( _ STR ) ) ; assert Equals (  Integer . value Of ( _ NUM ) , result . get ( _ STR ) ) ; assert Equals (  Integer . value Of ( _ NUM ) , result . get ( _ STR ) ) ; }
protected int parse Int ( ) throws  IOException { int sign = _ NUM ; int value = _ NUM ; int ch = skip Whitespace ( ) ; if ( ch == _ STR ) ch = read ( ) ; else if ( ch == _ STR ) { sign = - _ NUM ; ch = read ( ) ; } for ( ; ch >= _ STR && ch <= _ STR ; ch = read ( ) ) value = _ NUM * value + ch - _ STR ; peek = ch ; return sign * value ; }
public  Connection Quality register (  Connection Class State Change Listener listener ) { if ( listener != null ) { m Listener List . add ( listener ) ; } return m Current Bandwidth Connection Quality . get ( ) ; }
public void test Merge One Filter Into Empty Document ( ) throws  Exception {  String src Xml = _ STR ;  Web Xml src Web Xml =  Web Xml Io . parse Web Xml ( new  Byte Array Input Stream ( src Xml . get Bytes ( _ STR ) ) , null ) ;  String merge Xml = _ STR + _ STR + _ STR + _ STR + _ STR + _ STR ;  Web Xml merge Web Xml =  Web Xml Io . parse Web Xml ( new  Byte Array Input Stream ( merge Xml . get Bytes ( _ STR ) ) , null ) ;  Web Xml Merger merger = new  Web Xml Merger ( src Web Xml ) ; merger . merge Filters ( merge Web Xml ) ; assert True (  Web Xml Utils . has Filter ( src Web Xml , _ STR ) ) ; }
private  Diff Part decode Replace ( final int block Size_ S , final int block Size_ E , final int block Size_ L ) throws  Unsupported Encoding Exception ,  Decoding Exception { if ( block Size_ S < _ NUM || block Size_ E < _ NUM || block Size_ L < _ NUM ) { throw new  Decoding Exception ( _ STR + block Size_ S + _ STR + block Size_ E + _ STR + block Size_ L ) ; } int s = r . read ( block Size_ S ) ; int e = r . read ( block Size_ E ) ; int l = r . read ( block Size_ L ) ;  Byte Array Output Stream output = new  Byte Array Output Stream ( ) ; for ( int i = _ NUM ; i < l ; i ++ ) { output . write ( r . read Byte ( ) ) ; }  Diff Part part = new  Diff Part (  Diff Action .  REPLACE ) ; part . set Start ( s ) ; part . set Length ( e ) ; part . set Text ( output . to String (  WIKIPEDIA_ ENCODING ) ) ; return part ; }
public void remove (  Node n ) { list . remove ( n ) ; }
private void load Corpus (  Parallel Corpus corpus ) { logger . info ( _ STR ) ;  Time Keeper timer =  Timing Utils . start ( ) ; num Sentences = corpus . size ( ) ; int num Source Positions = corpus . num Source Positions ( ) ; int num Target Positions = corpus . num Target Positions ( ) ; int src Length = num Source Positions + num Sentences ; src Bitext = new int [ src Length ] ; f2e = new int [ src Length ] ; int tgt Length = num Target Positions + num Sentences ; tgt Bitext = new int [ tgt Length ] ; e2f = new int [ tgt Length ] ; int src Offset = _ NUM ; int tgt Offset = _ NUM ; for (  Aligned Sentence sentence : corpus ) {  System . arraycopy ( sentence . source , _ NUM , src Bitext , src Offset , sentence . source Length ( ) ) ;  System . arraycopy ( sentence . f2e , _ NUM , f2e , src Offset , sentence . f2e . length ) ;  System . arraycopy ( sentence . target , _ NUM , tgt Bitext , tgt Offset , sentence . target Length ( ) ) ;  System . arraycopy ( sentence . e2f , _ NUM , e2f , tgt Offset , sentence . e2f . length ) ; src Offset += sentence . source Length ( ) ; tgt Offset += sentence . target Length ( ) ; src Bitext [ src Offset ] = to Sentence Offset ( tgt Offset ) ; tgt Bitext [ tgt Offset ] = to Sentence Offset ( src Offset ) ; ++ src Offset ; ++ tgt Offset ; } vocabulary = corpus . get Vocabulary ( ) ; timer . mark ( _ STR ) ; logger . info ( _ STR , timer ) ; }
@  Layoutlib Delegate static float sqrt ( float value ) { return ( float )  Math . sqrt ( value ) ; }
public static  Base Response new Response Object (  String content Type Header ) {  String content Type =  String Utils . is Not Blank ( content Type Header ) ? content Type Header : _ STR ; if ( content Type . contains ( _ STR ) ) { return new  XMLResponse ( ) ; } else if ( content Type . contains ( _ STR ) ) { return new  Json Response ( ) ; } else { return new  Binary Response ( ) ; } }
public static int [ ] sort Values (  Matrix m ) { double [ ] v = new double [ m . get Column Dimension ( ) ] ; int [ ] index = new int [ v . length ] ; for ( int i = _ NUM ; i < v . length ; i ++ ) { v [ i ] = m . get ( i , i ) ; index [ i ] = i ; } for ( int i = _ NUM ; i < v . length ; i ++ ) { for ( int j = i + _ NUM ; j < v . length ; j ++ ) { if (  Math . abs ( v [ i ] ) <  Math . abs ( v [ j ] ) ) { double tmp Value = v [ j ] ; v [ j ] = v [ i ] ; v [ i ] = tmp Value ; int tmp Index = index [ j ] ; index [ j ] = index [ i ] ; index [ i ] = tmp Index ; } } } return index ; }
private  List <  Volume > create VPlex Volumes (  String name , int number Of Vols ,  URI storage System ) {  List <  Volume > volumes = new  Array List <  Volume > ( ) ; for ( int i = _ NUM ; i <= number Of Vols ; i ++ ) {  Volume vplex Volume = new  Volume ( ) ;  URI vplex Volume Uri =  URIUtil . create Id (  Volume . class ) ; vplex Volume URIs . add ( vplex Volume Uri ) ; vplex Volume . set Id ( vplex Volume Uri ) ; vplex Volume . set Label ( name + i ) ; vplex Volume . set Native Id ( _ STR + i ) ; vplex Volume . set Storage Controller ( storage System ) ;  String Set associated Volumes = new  String Set ( ) ; associated Volumes . add ( _ STR ) ; vplex Volume . set Associated Volumes ( associated Volumes ) ; volumes . add ( vplex Volume ) ; } return volumes ; }
public static int calc Text Height (  Paint paint ,  String demo Text ) {  Rect r = m Calc Text Height Rect ; r . set ( _ NUM , _ NUM , _ NUM , _ NUM ) ; paint . get Text Bounds ( demo Text , _ NUM , demo Text . length ( ) , r ) ; return r . height ( ) ; }
public static  Double zing (  Number value ) { if ( value == null ) { return null ; } return  Math . max ( _ NUM , value . double Value ( ) ) ; }
public  Rich Text with Size ( int size ) { this . size = size ; return this ; }
private boolean is Included ( final  Http Servlet Request request ) {  String uri = (  String ) request . get Attribute ( _ STR ) ; boolean include Request = ! ( uri == null ) ; if ( include Request && log . is Debug Enabled ( ) ) { log . debug ( _ STR + _ STR , request . get Request URL ( ) ) ; } return include Request ; }
public  Buffer Servlet Output Stream ( int buffer Size ) { buffer =  Byte Buffer . allocate ( buffer Size ) ; }
private void fill Conversations ( ) { conversations . add ( _ STR ) ; conversations . add ( _ STR ) ; conversations . add ( _ STR ) ; conversations . add ( _ STR ) ; conversations . add ( _ STR ) ; conversations . add ( _ STR ) ; conversations . add ( _ STR ) ; conversations . add ( _ STR ) ; conversations . add ( _ STR ) ; conversations . add ( _ STR ) ; conversations . add ( _ STR ) ; conversations . add ( _ STR ) ; }
public void add Job (  Runnable job ) { m Jobs . add ( job ) ; }
public void end Element (  String uri ,  String local Name ,  String q Name ) throws  SAXException { if ( q Name . equals (  Print Data .  XML_ TAG ) ) { pop ( ) ; } else if ( q Name . equals (  Print Data Element .  XML_ TAG ) ) { m_cur PD . add Node ( new  Print Data Element ( m_cur PDEname , m_cur PDEvalue . to String ( ) , _ NUM , null ) ) ; } }
public static boolean is Empty (  String str ) { return ( str == null || str . length ( ) == _ NUM ) ; }
public  String build Nonce Counter ( ) {  String result =  Integer . to Hex String ( m Cnonce Counter ) ; while ( result . length ( ) != _ NUM ) { result = _ STR + result ; } return result ; }
@  Override public void accept Instance (  Instance Event e ) { m_busy = _ BOOL ; if ( e . get Status ( ) ==  Instance Event .  FORMAT_ AVAILABLE ) { m_throughput = new  Stream Throughput ( status Message Prefix ( ) ) ;  Instances structure = e . get Structure ( ) ; try { make Output Structure ( structure ) ; } catch (  Exception ex ) {  String msg = status Message Prefix ( ) + _ STR ; if ( m_log != null ) { m_log . status Message ( msg ) ; m_log . log Message ( _ STR + ex . get Message ( ) ) ; } stop ( ) ; ex . print Stack Trace ( ) ; m_busy = _ BOOL ; return ; } if ( ! e . m_format Notification Only ) { if ( m_log != null ) { m_log . status Message ( status Message Prefix ( ) + _ STR ) ; } } m_ie . set Structure ( m_matches . get Output Structure ( ) ) ; m_ie . m_format Notification Only = e . m_format Notification Only ; notify Instance Listeners ( m_ie ) ; } else {  Instance inst = e . get Instance ( ) ;  Instance out = null ; if ( inst != null ) { m_throughput . update Start ( ) ; try { out = m_matches . make Output Instance ( inst , _ BOOL ) ; } catch (  Exception e1 ) { e1 . print Stack Trace ( ) ; } m_throughput . update End ( m_log ) ; } if ( inst == null || out != null || e . get Status ( ) ==  Instance Event .  BATCH_ FINISHED ) { m_ie . set Instance ( out ) ; m_ie . set Status ( e . get Status ( ) ) ; notify Instance Listeners ( m_ie ) ; } if ( e . get Status ( ) ==  Instance Event .  BATCH_ FINISHED || inst == null ) { m_throughput . finished ( m_log ) ; } } m_busy = _ BOOL ; }
public static void match Virtual Pool With All Storage Pools (  Virtual Pool vpool ,  Db Client db Client ,  Coordinator Client coordinator ,  String Buffer error Message ) {  List <  URI > storage Pool URIs = db Client . query By Type (  Storage Pool . class , _ BOOL ) ;  Iterator <  Storage Pool > storage Pool List = db Client . query Iterative Objects (  Storage Pool . class , storage Pool URIs ) ;  List <  Storage Pool > all Pools To Process = new  Array List <  Storage Pool > ( ) ; while ( storage Pool List . has Next ( ) ) { all Pools To Process . add ( storage Pool List . next ( ) ) ; } if ( ! all Pools To Process . is Empty ( ) ) { matchv Pool With Storage Pools ( vpool , all Pools To Process , db Client , coordinator , null , error Message ) ; } }
public void test_ Big Decimal0 ( ) { final  Big Decimal [ ] a = new  Big Decimal [ ] { new  Big Decimal ( _ STR ) , new  Big Decimal ( _ STR ) , new  Big Decimal ( _ STR ) , new  Big Decimal ( _ STR ) , new  Big Decimal ( _ STR ) , new  Big Decimal ( _ STR ) , new  Big Decimal ( _ STR ) } ; for (  Big Decimal i : a ) { i = i . strip Trailing Zeros ( ) ; if ( log . is Info Enabled ( ) ) log . info ( _ STR + i + _ STR + i . scale ( ) + _ STR + i . precision ( ) + _ STR + dump Big Decimal ( i ) ) ; } for (  Big Decimal i : a ) { do Encode Decode Test ( i ) ; } for ( int i = _ NUM ; i < a . length ; i ++ ) { for ( int j = _ NUM ; j < a . length ; j ++ ) { do Compare Test ( a [ i ] , a [ j ] ,  Compare Enum .  EQ ) ; } } }
public boolean add To History ( ) { return add To History ( m_ Editor . get Value ( ) ) ; }
public static  List <  List <  String > > chunk Relative Paths (  List <  String > files ) {  Array List <  List <  String > > rc = new  Array List <  List <  String > > ( ) ; int start = _ NUM ; int size = _ NUM ; int i = _ NUM ; for ( ; i < files . size ( ) ; i ++ ) {  String p = files . get ( i ) ; if ( size + p . length ( ) >  FILE_ PATH_ LIMIT ) { if ( start == i ) { rc . add ( files . sub List ( i , i + _ NUM ) ) ; start = i + _ NUM ; } else { rc . add ( files . sub List ( start , i ) ) ; start = i ; } size = _ NUM ; } else { size += p . length ( ) ; } } if ( start != files . size ( ) ) { rc . add ( files . sub List ( start , i ) ) ; } return rc ; }
public static  String join ( int [ ] self ,  String separator ) {  String Builder buffer = new  String Builder ( ) ; boolean first = _ BOOL ; if ( separator == null ) separator = _ STR ; for ( int next : self ) { if ( first ) { first = _ BOOL ; } else { buffer . append ( separator ) ; } buffer . append ( next ) ; } return buffer . to String ( ) ; }
public  Sort (  String [ ] fields ) { this ( fields , new boolean [ fields . length ] ) ;  Arrays . fill ( m_ascend , _ BOOL ) ; }
public  Stemmed String (  String orig ,  Char Sequence stemmed ) { str Orig = orig ; str Stemmed = stemmed . to String ( ) ; }
public  Log Stream Merger (  Log Request req ,  Log Svc Properties Loader properties Loader ) { logger . trace ( _ STR ) ; this . request = req ;  Log File Finder file Finder = new  Log File Finder ( properties Loader . get Log File Paths ( ) , properties Loader . get Excluded Log File Paths ( ) ) ;  Map <  String ,  List <  File > > grouped Log Files = file Finder . find Files Grouped By Base Name ( ) ;  List <  String > groups = req . get Base Names ( ) ; if ( groups == null || groups . is Empty ( ) ) { groups = new  Array List < > ( grouped Log Files . key Set ( ) ) ; } logger . debug ( _ STR , groups ) ; if ( groups . retain All ( grouped Log Files . key Set ( ) ) ) { logger . info ( _ STR , groups ) ; } int size = groups . size ( ) ; log Stream List = new  Log File Stream [ size ] ; log Heads = new  Log Message [ size ] ; for ( int i = _ NUM ; i < size ; i ++ ) {  String service = groups . get ( i ) ; log Stream List [ i ] = new  Log File Stream ( service , grouped Log Files . get ( service ) , req , status ) ; log Heads [ i ] = null ; } }
public static  String [ ] unpack Cipher Suites (  String ciphers ) { if ( ciphers == null ) return null ;  Vector c = new  Vector ( ) ; int i = ciphers . index Of ( _ STR ) ; int j = _ NUM ; while ( i > - _ NUM ) { c . add ( ciphers . substring ( j , i ) ) ; j = i + _ NUM ; i = ciphers . index Of ( _ STR , j ) ; } c . add ( ciphers . substring ( j ) ) ;  String [ ] s = new  String [ c . size ( ) ] ; c . to Array ( s ) ; return s ; }
public  Default File Filter (  String extension ,  String description ) { ext = extension . to Lower Case ( ) ; desc = description ; }
private boolean is Named Param (  String arg ) { return arg . starts With ( _ STR ) && ( arg . index Of ( _ STR ) > _ NUM && valid First Char ( arg . char At ( _ NUM ) ) ) ; }
public static  Node remove Children (  Node node ) { if ( node . get Node Type ( ) ==  Node .  ELEMENT_ NODE ) {  Node List children = node . get Child Nodes ( ) ; for ( int i = _ NUM ; i < children . get Length ( ) ; i ++ ) {  Node child = children . item ( i ) ;  Node temp = node . remove Child ( child ) ; i -- ; } } return node ; }
protected boolean is Valid Format ( ) { boolean result ; result = _ BOOL ; try { new  Simple Date Format ( m_ Format Text . get Text ( ) ) ; result = _ BOOL ; } catch (  Exception e ) { } return result ; }
public int size ( ) { if ( columns == null ) return _ NUM ; else return columns . size ( ) ; }
public static void write Line (  Buffered Writer writer ,  String line ) throws  IOException { writer . write ( line ) ; writer . new Line ( ) ; }
public static  String to String (  Timestamp timestamp ) { if ( timestamp == null ) return null ; else return timestamp . to String ( ) ; }
private final boolean add Direction (  Array List <  Move > move List ,  Position pos , int sq0 , int max Steps , int delta ) { int sq = sq0 ; boolean wtm = pos . white Move ; final int o King = ( wtm ?  Piece .  BKING :  Piece .  WKING ) ; while ( max Steps > _ NUM ) { sq += delta ; int p = pos . get Piece ( sq ) ; if ( p ==  Piece .  EMPTY ) { move List . add ( get Move Obj ( sq0 , sq ,  Piece .  EMPTY ) ) ; } else { if (  Piece . is White ( p ) != wtm ) { if ( p == o King ) { return Move List ( move List ) ; move List = get Move List Obj ( ) ; move List . add ( get Move Obj ( sq0 , sq ,  Piece .  EMPTY ) ) ; return _ BOOL ; } else { move List . add ( get Move Obj ( sq0 , sq ,  Piece .  EMPTY ) ) ; } } break ; } max Steps -- ; } return _ BOOL ; }
private void handle Static Stop Trees (  Static Metadata .  Stop Tree Request request ,  Transport Network transport Network ,  Task Statistics ts ) {  Static Metadata static Metadata = new  Static Metadata ( request . request , transport Network ) ; if ( request . request . bucket != null ) { try {  Output Stream os =  Static Data Store . get Output Stream ( request . request , _ STR , _ STR ) ; static Metadata . write Stop Trees ( os ) ; os . close ( ) ; } catch (  IOException e ) {  LOG . error ( _ STR , e ) ; } delete Request ( request ) ; } else { try {  Piped Input Stream pis = new  Piped Input Stream ( ) ;  Piped Output Stream pos = new  Piped Output Stream ( pis ) ; finish Priority Task ( request , pis ) ; static Metadata . write Stop Trees ( pos ) ; pos . close ( ) ; } catch (  IOException e ) {  LOG . error ( _ STR , e ) ; } } }
public synchronized void add Room (  String room ) { if ( !  Helper . validate Stream ( room ) ) { return ; } connect ( ) ; room = room . to Lower Case ( ) ; if ( rooms . add ( room ) ) { sub Room ( room ) ; } }
public void remove All ( final  Collection elements ) { adjusting = _ BOOL ;  Set old Selection = new  Hash Set ( selection ) ; boolean rv = selection . remove All ( elements ) ; adjusting = _ BOOL ; if ( rv ) { fire Selection Changed ( old Selection , selection ) ; } }
public  Feature Definition subset (  String [ ] feature Names To Drop ) {  List <  Integer > feature Indices To Drop = new  Array List <  Integer > ( ) ; for (  String feature Name : feature Names To Drop ) { int feature Index ; try { feature Index = get Feature Index ( feature Name ) ; feature Indices To Drop . add ( feature Index ) ; } catch (  Illegal Argument Exception e ) {  System . err . println ( _ STR + feature Name + _ STR ) ; } }  Feature Definition sub Definition = null ; try {  Byte Array Output Stream to Memory = new  Byte Array Output Stream ( ) ;  Data Output output = new  Data Output Stream ( to Memory ) ; write Binary To ( output , feature Indices To Drop ) ; byte [ ] memory = to Memory . to Byte Array ( ) ;  Byte Array Input Stream from Memory = new  Byte Array Input Stream ( memory ) ;  Data Input input = new  Data Input Stream ( from Memory ) ; sub Definition = new  Feature Definition ( input ) ; } catch (  IOException e ) { e . print Stack Trace ( ) ; } assert this . contains ( sub Definition ) ; return sub Definition ; }
public  Set <  Integer > primary Partitions (  UUID node Id ) {  Set <  Integer > set = primary . get ( node Id ) ; return set == null ?  Collections . <  Integer > empty Set ( ) : set ; }
public java . lang .  String Buffer insert ( int offset , java . lang .  Object obj ) { internal . insert ( offset , obj ) ; return this ; }
@  Override protected final  String replace Image Url ( final  String css Uri , final  String image Url ) { if ( ! image Urls . contains ( image Url ) ) { image Urls . add ( image Url ) ; return super . replace Image Url ( css Uri , image Url ) ; }  LOG . debug ( _ STR , image Url ) ; return image Url ; }
private boolean is Redundant (  Coordinate pt ) { if ( pt List . size ( ) < _ NUM ) return _ BOOL ;  Coordinate last Pt = (  Coordinate ) pt List . get ( pt List . size ( ) - _ NUM ) ; double pt Dist = pt . distance ( last Pt ) ; if ( pt Dist < minimim Vertex Distance ) return _ BOOL ; return _ BOOL ; }
public static  Text Line create Line From Text ( char [ ] chars ,  Styled Paragraph styled Paragraph ,  Text Label Factory factory , boolean is Direction LTR , float [ ] baseline Offsets ) { factory . set Line Context ( _ NUM , chars . length ) ;  Bidi line Bidi = factory . get Line Bidi ( ) ; int [ ] chars Lto V = null ; byte [ ] levels = null ; if ( line Bidi != null ) { levels =  Bidi Utils . get Levels ( line Bidi ) ; int [ ] chars Vto L =  Bidi Utils . create Visual To Logical Map ( levels ) ; chars Lto V =  Bidi Utils . create Inverse Map ( chars Vto L ) ; }  Text Line Component [ ] components = get Components ( styled Paragraph , chars , _ NUM , chars . length , chars Lto V , levels , factory ) ; return new  Text Line ( factory . get Font Render Context ( ) , components , baseline Offsets , chars , _ NUM , chars . length , chars Lto V , levels , is Direction LTR ) ; }
public  String patch_to Text (  List <  Patch > patches ) {  String Builder text = new  String Builder ( ) ; for (  Patch a Patch : patches ) { text . append ( a Patch ) ; } return text . to String ( ) ; }
public static double [ ] lprefc2lpc ( double [ ] k ) { int p = k . length ; double [ ] [ ]  A = new double [ p ] [ ] ; int i , j ; for ( i = _ NUM ; i <= p ; i ++ ) {  A [ i - _ NUM ] = new double [ i ] ;  A [ i - _ NUM ] [ i - _ NUM ] = k [ i - _ NUM ] ; for ( j = _ NUM ; j < i ; j ++ )  A [ i - _ NUM ] [ j - _ NUM ] =  A [ i - _ NUM ] [ j - _ NUM ] - k [ i - _ NUM ] *  A [ i - _ NUM ] [ i - j - _ NUM ] ; } double [ ] one Minus A = new double [ p + _ NUM ] ; one Minus A [ _ NUM ] = _ NUM ;  System . arraycopy (  A [ p - _ NUM ] , _ NUM , one Minus A , _ NUM , p ) ; return one Minus A ; }
public boolean has Loop In Tree ( ) { int product Category Id = get M_ Product_ Category_ ID ( ) ; int new Parent Category Id = get M_ Product_ Category_ Parent_ ID ( ) ;  Result Set rs = null ;  Prepared Statement pstmt = null ;  String sql = _ STR ; final  Vector <  Simple Tree Node > categories = new  Vector <  Simple Tree Node > ( _ NUM ) ; try { pstmt =  DB . prepare Statement ( sql , null ) ; rs = pstmt . execute Query ( ) ; while ( rs . next ( ) ) { if ( rs . get Int ( _ NUM ) == product Category Id ) categories . add ( new  Simple Tree Node ( rs . get Int ( _ NUM ) , new Parent Category Id ) ) ; categories . add ( new  Simple Tree Node ( rs . get Int ( _ NUM ) , rs . get Int ( _ NUM ) ) ) ; } if ( has Loop ( new Parent Category Id , categories , product Category Id ) ) return _ BOOL ; } catch (  SQLException e ) { s_log . log (  Level .  SEVERE , sql , e ) ; return _ BOOL ; } finally {  DB . close ( rs , pstmt ) ; rs = null ; pstmt = null ; } return _ BOOL ; }
public  All Stats Table Single (  Dataset Generator dataset Generator ,  Locker locker ) {  Argument Checking . not Null ( dataset Generator , _ STR ) ; init Components ( ) ; table . set Default Renderer (  JLabel . class , new  Renderer ( ) ) ; table . set Column Selection Allowed ( _ BOOL ) ; table . set Row Selection Allowed ( _ BOOL ) ;  JTable Header header = table . get Table Header ( ) ; header . set Reordering Allowed ( _ BOOL ) ;  GUIUtilities . set Table Header ( header ) ; model = new  Model ( dataset Generator ) ; table . set Model ( model ) ; this . locker = locker ; }
public void download (  String remote File Name ,  File local File , long restart At ,  FTPData Transfer Listener listener ) throws  Illegal State Exception ,  File Not Found Exception ,  IOException ,  FTPIllegal Reply Exception ,  FTPException ,  FTPData Transfer Exception ,  FTPAborted Exception {  Output Stream output Stream = null ; try { output Stream = new  File Output Stream ( local File , restart At > _ NUM ) ; } catch (  IOException e ) { throw new  FTPData Transfer Exception ( e ) ; } try { download ( remote File Name , output Stream , restart At , listener ) ; } catch (  Illegal State Exception e ) { throw e ; } catch (  IOException e ) { throw e ; } catch (  FTPIllegal Reply Exception e ) { throw e ; } catch (  FTPException e ) { throw e ; } catch (  FTPData Transfer Exception e ) { throw e ; } catch (  FTPAborted Exception e ) { throw e ; } finally { if ( output Stream != null ) { try { output Stream . close ( ) ; } catch (  Throwable t ) { ; } } } }
public boolean contains (  String name ) { return index Of ( name ) != - _ NUM ; }
public  String to String ( ) {  String Buffer buf = new  String Buffer ( _ STR ) ; to String ( buf , _ BOOL ) ; buf . append ( _ STR ) ; return buf . to String ( ) ; }
private void load Configuration ( ) {  Properties properties = new  Properties ( ) ;  File file = new  File ( get Config File Name ( ) ) ; if ( file . exists ( ) && file . can Read ( ) && file . is File ( ) ) {  File Input Stream in ; try { in = new  File Input Stream ( get Config File Name ( ) ) ; properties . load ( in ) ; in . close ( ) ; } catch (  File Not Found Exception e ) { e . print Stack Trace ( ) ; } catch (  IOException e ) { e . print Stack Trace ( ) ; } in = null ; }  Enumeration <  Object > e = properties . keys ( ) ; while ( e . has More Elements ( ) ) {  String key = (  String ) e . next Element ( ) ; set Parameter ( key , properties . get Property ( key ) ) ; } properties . clear ( ) ; }
public void to EPL (  String Writer writer ) { writer . write ( _ STR ) ; writer . write ( window Name ) ;  Projected Stream . to EPLViews ( writer , views ) ; }
public void remove All Update Listeners ( ) { if ( update Listeners == null ) { return ; } update Listeners . clear ( ) ; update Listeners = null ; }
public void add Generic Attr (  Generic Attr g ) { generic . add Element ( g ) ; g . resolve ( this ) ; }
protected void compare To DEQSim Events ( final  String deqsim Events File ) {  Linked List <  Event > copy Event List = new  Linked List <  Event > ( ) ; for ( int i = _ NUM ; i < all Events . size ( ) ; i ++ ) { if ( ! ( all Events . get ( i ) instanceof  Activity Start Event || all Events . get ( i ) instanceof  Activity End Event ) ) { copy Event List . add ( all Events . get ( i ) ) ; } }  Array List <  Event Log > deq Sim Log =  Cpp Event File Parser . parse File ( deqsim Events File ) ; for ( int i = _ NUM ; i < copy Event List . size ( ) ; i ++ ) { assert True ( _ STR ,  Cpp Event File Parser . equals ( copy Event List . get ( i ) , deq Sim Log . get ( i ) ) ) ; } }
@  Override public  UUID create Transport Node ( ) {  UUID uuid =  UUID . random UUID ( ) ; graph Server . add Vertex ( uuid ) ; return uuid ; }
public boolean is Channel Open (  String channel ) { return open Channels . contains ( channel ) ; }
public int open Channels ( ) { return infos . size ( ) ; }
private void read Object ( java . io .  Object Input Stream p_stream ) throws  IOException ,  Class Not Found Exception { p_stream . default Read Object ( ) ; item_color_table = new  Item Color Table Model ( p_stream ) ; other_color_table = new  Other Color Table Model ( p_stream ) ; }
public  Mock Response add Header (  String name ,  Object value ) { return add Header ( name + _ STR +  String . value Of ( value ) ) ; }
public static double standard Normal Cdf ( double x ) { double a = ( x ) / (  Math . sqrt ( _ NUM ) ) ; return _ NUM * ( _ NUM +  Error Function . erf ( a ) ) ; }
public void add Result (  String name ,  String Buffer result ) { m_ Model . add Element ( name ) ; m_ Results . put ( name , result ) ; }
private void disable Buttons ( ) { set Kick Enabled ( _ BOOL ) ; set Punch Enabled ( _ BOOL ) ; set Push Enabled ( _ BOOL ) ; set Trip Enabled ( _ BOOL ) ; set Grapple Enabled ( _ BOOL ) ; set Jump Jet Enabled ( _ BOOL ) ; set Club Enabled ( _ BOOL ) ; set Brush Off Enabled ( _ BOOL ) ; set Thrash Enabled ( _ BOOL ) ; set Dodge Enabled ( _ BOOL ) ; set Proto Enabled ( _ BOOL ) ; set Vibro Enabled ( _ BOOL ) ; set Explosives Enabled ( _ BOOL ) ; but Done . set Enabled ( _ BOOL ) ; set Next Enabled ( _ BOOL ) ; }
public static double [ ] random ( int m ) { double [ ] res = new double [ m ] ; for ( int i = _ NUM ; i < m ; ++ i ) { res [ i ] =  Math . random ( ) ; } return ( res ) ; }
public  DExport Key Pair (  JFrame parent ,  String entry Alias ,  Password Quality Config password Quality Config ) { super ( parent ,  Dialog .  Modality Type .  DOCUMENT_ MODAL ) ; this . entry Alias = entry Alias ; this . password Quality Config = password Quality Config ; init Components ( ) ; }
public  SQLQuery (  Class <  T > type ,  String sql Expression ) { this ( sql Expression , type . get Name ( ) , null ,  DEFAULT_ QUERY_ RESULT_ TYPE , null ) ; }
private void update Adapter Items ( ) {  Section Info last Section Info = null ;  String last Section Name = null ;  Fast Scroll Section Info last Fast Scroller Section Info = null ; int position = _ NUM ; int app Index = _ NUM ; m Filtered Apps . clear ( ) ; m Fast Scroller Sections . clear ( ) ; m Adapter Items . clear ( ) ; m Sections . clear ( ) ; if (  DEBUG_ PREDICTIONS ) { if ( m Predicted App Components . is Empty ( ) && ! m Apps . is Empty ( ) ) { m Predicted App Components . add ( new  Component Key ( m Apps . get ( _ NUM ) . component Name ,  User Handle Compat . my User Handle ( ) ) ) ; m Predicted App Components . add ( new  Component Key ( m Apps . get ( _ NUM ) . component Name ,  User Handle Compat . my User Handle ( ) ) ) ; m Predicted App Components . add ( new  Component Key ( m Apps . get ( _ NUM ) . component Name ,  User Handle Compat . my User Handle ( ) ) ) ; m Predicted App Components . add ( new  Component Key ( m Apps . get ( _ NUM ) . component Name ,  User Handle Compat . my User Handle ( ) ) ) ; } } m Predicted Apps . clear ( ) ; if ( m Predicted App Components != null && ! m Predicted App Components . is Empty ( ) && ! has Filter ( ) ) { for (  Component Key ck : m Predicted App Components ) {  App Info info = m Component To App Map . get ( ck ) ; if ( info != null ) { m Predicted Apps . add ( info ) ; } else { if (  Launcher App State . is Dogfood Build ( ) ) {  Log . e (  TAG , _ STR + ck . flatten To String ( m Launcher ) ) ; } } if ( m Predicted Apps . size ( ) == m Num Predicted Apps Per Row ) { break ; } } if ( ! m Predicted Apps . is Empty ( ) ) { last Section Info = new  Section Info ( ) ; last Fast Scroller Section Info = new  Fast Scroll Section Info ( _ STR ) ;  Adapter Item section Item =  Adapter Item . as Section Break ( position ++ , last Section Info ) ; m Sections . add ( last Section Info ) ; m Fast Scroller Sections . add ( last Fast Scroller Section Info ) ; m Adapter Items . add ( section Item ) ; for (  App Info info : m Predicted Apps ) {  Adapter Item app Item =  Adapter Item . as Predicted App ( position ++ , last Section Info , _ STR , last Section Info . num Apps ++ , info , app Index ++ ) ; if ( last Section Info . first App Item == null ) { last Section Info . first App Item = app Item ; last Fast Scroller Section Info . fast Scroll To Item = app Item ; } m Adapter Items . add ( app Item ) ; m Filtered Apps . add ( info ) ; } } } for (  App Info info : get Filters App Infos ( ) ) {  String section Name = get And Update Cached Section Name ( info . title ) ; if ( last Section Info == null || ! section Name . equals ( last Section Name ) ) { last Section Name = section Name ; last Section Info = new  Section Info ( ) ; last Fast Scroller Section Info = new  Fast Scroll Section Info ( section Name ) ; m Sections . add ( last Section Info ) ; m Fast Scroller Sections . add ( last Fast Scroller Section Info ) ; if ( ! has Filter ( ) ) {  Adapter Item section Item =  Adapter Item . as Section Break ( position ++ , last Section Info ) ; m Adapter Items . add ( section Item ) ; } }  Adapter Item app Item =  Adapter Item . as App ( position ++ , last Section Info , section Name , last Section Info . num Apps ++ , info , app Index ++ ) ; if ( last Section Info . first App Item == null ) { last Section Info . first App Item = app Item ; last Fast Scroller Section Info . fast Scroll To Item = app Item ; } m Adapter Items . add ( app Item ) ; m Filtered Apps . add ( info ) ; } if ( has Filter ( ) ) { if ( has No Filtered Results ( ) ) { m Adapter Items . add (  Adapter Item . as Empty Search ( position ++ ) ) ; } else { m Adapter Items . add (  Adapter Item . as Divider ( position ++ ) ) ; } m Adapter Items . add (  Adapter Item . as Market Search ( position ++ ) ) ; } merge Sections ( ) ; if ( m Num Apps Per Row != _ NUM ) { int num Apps In Section = _ NUM ; int num Apps In Row = _ NUM ; int row Index = - _ NUM ; for (  Adapter Item item : m Adapter Items ) { item . row Index = _ NUM ; if ( item . view Type ==  All Apps Grid Adapter .  SECTION_ BREAK_ VIEW_ TYPE ) { num Apps In Section = _ NUM ; } else if ( item . view Type ==  All Apps Grid Adapter .  ICON_ VIEW_ TYPE || item . view Type ==  All Apps Grid Adapter .  PREDICTION_ ICON_ VIEW_ TYPE ) { if ( num Apps In Section % m Num Apps Per Row == _ NUM ) { num Apps In Row = _ NUM ; row Index ++ ; } item . row Index = row Index ; item . row App Index = num Apps In Row ; num Apps In Section ++ ; num Apps In Row ++ ; } } m Num App Rows In Adapter = row Index + _ NUM ; switch ( m Fast Scroll Distribution Mode ) { case  FAST_ SCROLL_ FRACTION_ DISTRIBUTE_ BY_ ROWS_ FRACTION : float row Fraction = _ NUM / m Num App Rows In Adapter ; for (  Fast Scroll Section Info info : m Fast Scroller Sections ) {  Adapter Item item = info . fast Scroll To Item ; if ( item . view Type !=  All Apps Grid Adapter .  ICON_ VIEW_ TYPE && item . view Type !=  All Apps Grid Adapter .  PREDICTION_ ICON_ VIEW_ TYPE ) { info . touch Fraction = _ NUM ; continue ; } float sub Row Fraction = item . row App Index * ( row Fraction / m Num Apps Per Row ) ; info . touch Fraction = item . row Index * row Fraction + sub Row Fraction ; } break ; case  FAST_ SCROLL_ FRACTION_ DISTRIBUTE_ BY_ NUM_ SECTIONS : float per Section Touch Fraction = _ NUM / m Fast Scroller Sections . size ( ) ; float cumulative Touch Fraction = _ NUM ; for (  Fast Scroll Section Info info : m Fast Scroller Sections ) {  Adapter Item item = info . fast Scroll To Item ; if ( item . view Type !=  All Apps Grid Adapter .  ICON_ VIEW_ TYPE && item . view Type !=  All Apps Grid Adapter .  PREDICTION_ ICON_ VIEW_ TYPE ) { info . touch Fraction = _ NUM ; continue ; } info . touch Fraction = cumulative Touch Fraction ; cumulative Touch Fraction += per Section Touch Fraction ; } break ; } } if ( m Adapter != null ) { m Adapter . notify Data Set Changed ( ) ; } }
public  Math_ Vector rotate ( double angle ) { double rad = angle *  TO_ RADIANS ; double cos =  Math . cos ( rad ) ; double sin =  Math . sin ( rad ) ; double new X = this . x * cos - this . y * sin ; double new Y = this . x * sin + this . y * cos ; this . x = new X ; this . y = new Y ; return this ; }
private <  T >  String generate Test File (  String filename ,  List <  T > elems ,  Sync Behavior sync Behavior , int sync Interval ,  Avro Coder <  T > coder ,  String codec ) throws  IOException {  Random random = new  Random ( _ NUM ) ;  File tmp File = tmp Folder . new File ( filename ) ;  String path = tmp File . to String ( ) ;  File Output Stream os = new  File Output Stream ( tmp File ) ;  Datum Writer <  T > datum Writer = coder . create Datum Writer ( ) ; try (  Data File Writer <  T > writer = new  Data File Writer < > ( datum Writer ) ) { writer . set Codec (  Codec Factory . from String ( codec ) ) ; writer . create ( coder . get Schema ( ) , os ) ; int record Index = _ NUM ; int sync Index = sync Behavior ==  Sync Behavior .  SYNC_ RANDOM ? random . next Int ( sync Interval ) : _ NUM ; for (  T elem : elems ) { writer . append ( elem ) ; record Index ++ ; switch ( sync Behavior ) { case  SYNC_ REGULAR : if ( record Index == sync Interval ) { record Index = _ NUM ; writer . sync ( ) ; } break ; case  SYNC_ RANDOM : if ( record Index == sync Index ) { record Index = _ NUM ; writer . sync ( ) ; sync Index = random . next Int ( sync Interval ) ; } break ; case  SYNC_ DEFAULT : default : } } } return path ; }
public static  String now ( ) { return from Calendar (  Gregorian Calendar . get Instance ( ) ) ; }
private static  File create Reserve Disk Cache Dir (  Context context ) {  File cache Dir =  Storage Utils . get Cache Directory ( context , _ BOOL ) ;  File individual Dir = new  File ( cache Dir , _ STR ) ; if ( individual Dir . exists ( ) || individual Dir . mkdir ( ) ) { cache Dir = individual Dir ; } return cache Dir ; }
@  Override public  Enumeration <  Option > list Options ( ) {  Vector <  Option > new Vector = new  Vector <  Option > ( _ NUM ) ; new Vector . add Element ( new  Option ( _ STR , _ STR , _ NUM , _ STR ) ) ; new Vector . add Element ( new  Option ( _ STR + _ STR , _ STR , _ NUM , _ STR ) ) ; new Vector . add Element ( new  Option ( _ STR + _ STR , _ STR , _ NUM , _ STR ) ) ; new Vector . add Element ( new  Option ( _ STR , _ STR , _ NUM , _ STR ) ) ; new Vector . add Element ( new  Option ( _ STR + _ STR + _ STR , _ STR , _ NUM , _ STR ) ) ; new Vector . add Element ( new  Option ( _ STR , _ STR , _ NUM , _ STR ) ) ; new Vector . add Element ( new  Option ( _ STR + num Execution Slots Tip Text ( ) + _ STR , _ STR , _ NUM , _ STR ) ) ; new Vector . add Element ( new  Option ( _ STR , _ STR , _ NUM , _ STR ) ) ; return new Vector . elements ( ) ; }
public boolean remove Entry ( int x Index , int data Set Index ) { if ( data Set Index >= m Data Sets . size ( ) ) return _ BOOL ;  T data Set = m Data Sets . get ( data Set Index ) ;  Entry e = data Set . get Entry For XIndex ( x Index ) ; if ( e == null || e . get XIndex ( ) != x Index ) return _ BOOL ; return remove Entry ( e , data Set Index ) ; }
protected void engine Set Mode (  String mode ) { if ( ! mode . equals Ignore Case ( _ STR ) ) { throw new  Illegal Argument Exception ( _ STR + mode ) ; } }
public static void close ( @  Nullable  Auto Closeable rsrc , @  Nullable  Ignite Logger log ) { if ( rsrc != null ) try { rsrc . close ( ) ; } catch (  Exception e ) { warn ( log , _ STR + e . get Message ( ) ) ; } }
public  Writable Raster create Compatible Writable Raster ( int w , int h ) { if ( w <= _ NUM || h <= _ NUM ) { throw new  Raster Format Exception ( _ STR + ( ( w <= _ NUM ) ? _ STR : _ STR ) ) ; }  Sample Model sm = sample Model . create Compatible Sample Model ( w , h ) ; return new  Byte Interleaved Raster ( sm , new  Point ( _ NUM , _ NUM ) ) ; }
public static  String [ ] executor Command (  Config config ,  Config runtime , int container Index ,  List <  Integer > free Ports ) { if ( free Ports . size ( ) <  PORTS_ REQUIRED_ FOR_ EXECUTOR ) { throw new  Runtime Exception ( _ STR ) ; } for ( int port : free Ports ) { if ( port == - _ NUM ) { throw new  Runtime Exception ( _ STR ) ; } }  List <  String > ports = new  Linked List < > ( ) ; for ( int port : free Ports ) { ports . add (  Integer . to String ( port ) ) ; } return get Executor Command ( config , runtime , container Index , ports ) ; }
public  Update Request add ( final  Collection <  Solr Input Document > docs ) { if ( documents == null ) { documents = new  Linked Hash Map < > ( ) ; } for (  Solr Input Document doc : docs ) {  Objects . require Non Null ( doc , _ STR ) ; documents . put ( doc , null ) ; } return this ; }
private void notify After (  Faces Context context ,  Lifecycle lifecycle ) {  UIView Root view Root = context . get View Root ( ) ; if ( null == view Root ) { return ; }  Method Expression after Phase = view Root . get After Phase Listener ( ) ; if ( null != after Phase ) { try {  Phase Event event = new  Phase Event ( context ,  Phase Id .  RESTORE_ VIEW , lifecycle ) ; after Phase . invoke ( context . get ELContext ( ) , new  Object [ ] { event } ) ; } catch (  Exception e ) { if (  LOGGER . is Loggable (  Level .  SEVERE ) ) {  LOGGER . log (  Level .  SEVERE , _ STR , new  Object [ ] { after Phase . get Expression String ( ) , ( _ STR ) } ) ; } return ; } } }
public  Simple Object Permission Set ( ) { }
@  Override public final void add Bezier Curve C ( final float x , final float y , final float x2 , final float y2 , final float x3 , final float y3 ) { elements . add ( new  Cubic Curve To ( x , y , x2 , y2 , x3 , y3 ) ) ; current Pos [ _ NUM ] = x3 ; current Pos [ _ NUM ] = y3 ; }
private void save Bucket (  Auto Mix Bucket bucket ) { if ( ! bucket . is Playlist Session Error ( ) ) {  Shared Preferences prefs = get Prefs ( ) ;  Shared Preferences .  Editor editor = prefs . edit ( ) ; final  String id = bucket . get Session Id ( ) ; if ( id != null ) { editor . put String (  PREF_ PREFIX_ NAME + id , bucket . m Name ) ; editor . put Float (  PREF_ PREFIX_ ADVENTUROUS + id , bucket . m Adventurousness ) ; editor . put Float (  PREF_ PREFIX_ ENERGY + id , bucket . m Energy ) ; editor . put Float (  PREF_ PREFIX_ FAMILIAR + id , bucket . m Familiar ) ; editor . put String (  PREF_ PREFIX_ MOODS + id ,  Utils . implode ( bucket . m Moods , _ STR ) ) ; editor . put String (  PREF_ PREFIX_ SONG_ TYPES + id ,  Utils . implode ( bucket . m Song Types , _ STR ) ) ; editor . put Float (  PREF_ PREFIX_ SPEECHINESS + id , bucket . m Speechiness ) ; editor . put String (  PREF_ PREFIX_ STYLES + id ,  Utils . implode ( bucket . m Styles , _ STR ) ) ; editor . put Boolean (  PREF_ PREFIX_ TASTE + id , bucket . m Use Taste ) ;  Set <  String > set = new  Tree Set < > ( prefs . get String Set (  PREF_ BUCKETS_ IDS , new  Tree Set <  String > ( ) ) ) ; set . add ( id ) ; editor . put String Set (  PREF_ BUCKETS_ IDS , set ) ; editor . apply ( ) ; } } else {  Log . e (  TAG , _ STR ) ; } }
@  Override public void accept Offer (  Offer offer ) { future Accepted Offers . on Next ( offer ) ; offers . remove ( offer ) ; accepted Offers . add ( offer ) ; }
private void inject Dependencies ( ) {  Sample Application easy MVPApplication = (  Sample Application ) get Application ( ) ;  List <  Object > activity Scope Modules = ( get Modules ( ) != null ) ? get Modules ( ) : new  Array List < > ( ) ; activity Scope Modules . add ( new  Activity Module ( this ) ) ; activity Scope Modules . add ( new  Presenter Module ( ) ) ; activity Scope Graph = easy MVPApplication . build Graph With Aditional Modules ( activity Scope Modules ) ; inject ( this ) ; }
synchronized public boolean write Request Immediate ( ) { if ( writer Locks . size ( ) == _ NUM && current Readers == _ NUM && current Writers == _ NUM ) { ++ current Writers ; return _ BOOL ; } return _ BOOL ; }
public long read UTCDate ( ) throws  IOException { expect Start Tag ( _ STR ) ; if ( utc Calendar == null ) utc Calendar =  Calendar . get Instance (  Time Zone . get Time Zone ( _ STR ) ) ; long value = parse Date ( utc Calendar ) ; expect End Tag ( _ STR ) ; return value ; }
public synchronized void remove Selection Listener (  Selection Listener listener ) { if ( listeners != null ) { listeners . remove Element ( listener ) ; } }
public static void process (  Process p ,  Line Consumer stdout ,  Line Consumer stderr ) throws  IOException { try (  Buffered Reader input Reader = new  Buffered Reader ( new  Input Stream Reader ( p . get Input Stream ( ) ) ) ;  Buffered Reader error Reader = new  Buffered Reader ( new  Input Stream Reader ( p . get Error Stream ( ) ) ) ) {  String line ; while ( ( line = input Reader . read Line ( ) ) != null ) { stdout . write Line ( line ) ; } while ( ( line = error Reader . read Line ( ) ) != null ) { stderr . write Line ( line ) ; } } }
private boolean is In Black List (  String tpl ) { if ( black List . contains ( tpl ) ) { return _ BOOL ; } return _ BOOL ; }
private static boolean within Three (  INode n ,  INode goal ) {  Double Linked List <  IMove > moves = n . valid Moves ( ) ; for (  Iterator <  IMove > it = moves . iterator ( ) ; it . has Next ( ) ; ) {  IMove move = it . next ( ) ;  INode successor = n . copy ( ) ; move . execute ( successor ) ; if ( within Two ( successor , goal ) ) { return _ BOOL ; } } return _ BOOL ; }
public static boolean write XMPMeta (  Input Stream input Stream ,  Output Stream output Stream ,  XMPMeta meta ) {  List <  Section > sections = parse ( input Stream , _ BOOL ) ; sections = insert XMPSection ( sections , meta ) ; if ( sections == null ) { return _ BOOL ; } try { write Jpeg File ( output Stream , sections ) ; } catch (  IOException e ) {  Log . d (  TAG , _ STR , e ) ; return _ BOOL ; } finally { if ( output Stream != null ) { try { output Stream . close ( ) ; } catch (  IOException e ) { } } } return _ BOOL ; }
@  Override public void close Write ( ) throws  IOException { if ( _is Close Write ) { return ; } _is Close Write = _ BOOL ; boolean is Shutdown Output = _ BOOL ; if ( _s != null ) { try { _s . shutdown Output ( ) ; is Shutdown Output = _ BOOL ; } catch (  Unsupported Operation Exception e ) { log . log (  Level .  FINEST , e . to String ( ) , e ) ; } catch (  Exception e ) { log . finer ( e . to String ( ) ) ; log . log (  Level .  FINEST , e . to String ( ) , e ) ; } } }
protected void flush Batch ( ) { logger . debug ( _ STR , tuple Batch . size ( ) ) ; for (  Message message : message Batch ) { try { producer . send ( message ) ; } catch (  JMSException ex ) { throw new  Runtime Exception ( ex ) ; } } tuple Batch . clear ( ) ; message Batch . clear ( ) ; logger . debug ( _ STR ) ; }
public  String receive ( ) { try { return reader . read Line ( ) ; } catch (  IOException e ) { throw new  Runtime Exception ( _ STR , e ) ; } }
public static  String to String Never Null (  Object o ) { return o == null ? _ STR : o . to String ( ) ; }
public void write ( byte [ ] vector ) { check ( vector . length ) ;  System . arraycopy ( vector , _ NUM , buffer , write_pos , vector . length ) ; write_pos += vector . length ; }
public  Ints Ref next ( ) { if ( emit Empty String ) { emit Empty String = _ BOOL ; return  EMPTY ; } for ( int depth = string . length ( ) ; depth > _ NUM ; ) {  Path Node node = nodes [ depth - _ NUM ] ; int label = node . next Label ( a ) ; if ( label != - _ NUM ) { string . set Int At ( depth - _ NUM , label ) ; int to = node . to ; if ( a . get Num Transitions ( to ) != _ NUM ) { if ( path States . get ( to ) ) { throw new  Illegal Argument Exception ( _ STR ) ; } path States . set ( to ) ; grow Stack ( depth ) ; nodes [ depth ] . reset State ( a , to ) ; depth ++ ; string . set Length ( depth ) ; string . grow ( depth ) ; } else if ( a . is Accept ( to ) ) { return string . get ( ) ; } } else { int state = node . state ; assert path States . get ( state ) ; path States . clear ( state ) ; depth -- ; string . set Length ( depth ) ; if ( a . is Accept ( state ) ) { return string . get ( ) ; } } } return null ; }
public static  URL [ ] path To URLs (  String path ) {  String Tokenizer st = new  String Tokenizer ( path ,  File . path Separator ) ;  URL [ ] urls = new  URL [ st . count Tokens ( ) ] ; int count = _ NUM ; while ( st . has More Tokens ( ) ) {  URL url = file To URL ( new  File ( st . next Token ( ) ) ) ; if ( url != null ) { urls [ count ++ ] = url ; } } if ( urls . length != count ) {  URL [ ] tmp = new  URL [ count ] ;  System . arraycopy ( urls , _ NUM , tmp , _ NUM , count ) ; urls = tmp ; } return urls ; }
public static  String quote (  String input ) {  String output = _ STR ; for ( int i = _ NUM ; i < input . length ( ) ; i ++ ) { output += _ STR + input . char At ( i ) ; } return output ; }
protected void fire Fatal Connection Error (  SQLException ex ) {  Connection Event evt = new  Connection Event ( this , ex ) ; for (  Connection Event Listener listener : connection Event Listeners ) { listener . connection Error Occurred ( evt ) ; } }
public static void put Byte Volatile (  Object obj , long off , byte val ) {  UNSAFE . put Byte Volatile ( obj , off , val ) ; }
private boolean has Next Inet Socket Address ( ) { return next Inet Socket Address Index < inet Socket Addresses . size ( ) ; }
private void check Chart (  JFree Chart chart ) {  Plot plot = chart . get Plot ( ) ; if ( ! ( plot instanceof  Polar Plot ) ) { throw new  Illegal Argument Exception ( _ STR ) ; } }
Header Renderer ( ) { add ( header ) ; header . set Border ( null ) ; }
public void declare Dimension ( final int dimension Type , final int scale , final int pixelperscale , final int offset , final  Long color Naming , final  Long color Scale , final  String name ) { this . scales [ dimension Type ] =  Math . max ( _ NUM , scale ) ; this . pixels [ dimension Type ] = pixelperscale ; this . offsets [ dimension Type ] = offset ; this . colnames [ dimension Type ] = color Naming ; this . colscale [ dimension Type ] = color Scale ; this . tablenames [ dimension Type ] = name ; if ( ( dimension Type ==  DIMENSION_ LEFT ) || ( dimension Type ==  DIMENSION_ RIGHT ) ) { draw Vertical Scale ( ( dimension Type ==  DIMENSION_ LEFT ) , scale , pixelperscale , offset , color Naming , color Scale , name ) ; } if ( ( dimension Type ==  DIMENSION_ TOP ) || ( dimension Type ==  DIMENSION_ BOTTOM ) ) { draw Horizontal Scale ( ( dimension Type ==  DIMENSION_ TOP ) , scale , pixelperscale , offset , color Naming , color Scale , name ) ; } }
private void create Element (  Document doc ,  Element parent Element ,  String element Name , int value ) {  Element element = doc . create Element ( element Name ) ; element . append Child ( doc . create Text Node (  Integer . to String ( value ) ) ) ; parent Element . append Child ( element ) ; }
private static  String trim Leading Slash (  String value ) { if ( value == null ) return _ STR ; while ( value . index Of ( _ STR ) > - _ NUM ) { value = value . substring ( value . index Of ( _ STR ) + _ NUM ) ; } return value ; }
public boolean is Empty ( ) { return components . is Empty ( ) ; }
public void add Node Test (  Predicated Node Test test ) { if ( null == m_node Tests ) { m_node Tests = new  Predicated Node Test [ _ NUM ] ; m_node Tests [ _ NUM ] = test ; } else {  Predicated Node Test [ ] tests = m_node Tests ; int len = m_node Tests . length ; m_node Tests = new  Predicated Node Test [ len + _ NUM ] ;  System . arraycopy ( tests , _ NUM , m_node Tests , _ NUM , len ) ; m_node Tests [ len ] = test ; } test . expr Set Parent ( this ) ; }
public  Str Builder insert ( int index , char chars [ ] , int offset , int length ) { validate Index ( index ) ; if ( chars == null ) { return insert ( index , null Text ) ; } if ( offset < _ NUM || offset > chars . length ) { throw new  String Index Out Of Bounds Exception ( _ STR + offset ) ; } if ( length < _ NUM || offset + length > chars . length ) { throw new  String Index Out Of Bounds Exception ( _ STR + length ) ; } if ( length > _ NUM ) { ensure Capacity ( size + length ) ;  System . arraycopy ( buffer , index , buffer , index + length , size - index ) ;  System . arraycopy ( chars , offset , buffer , index , length ) ; size += length ; } return this ; }
public  String root ( ) { return root ; }
public void expand Object (  Object element Or Tree Path , int level ) { if ( check Busy ( ) ) { return ; }  Object parent = get Parent Element ( element Or Tree Path ) ; if ( ! ( ( ( parent != null ) && get Expanded State ( parent ) ) || is Root Element ( element Or Tree Path ) ) ) {  List <  Object > objects To Expand = create Object List ( parent , new  Array List < > ( ) ) ; if ( ! objects To Expand . is Empty ( ) ) { objects To Be Expanded . add All ( objects To Expand ) ; } } objects To Be Expanded . add ( element Or Tree Path ) ;  Widget w = internal Expand ( element Or Tree Path , _ BOOL ) ; if ( w != null ) { internal Expand To Level ( w , level ) ; } }
public void append Cell ( byte value ) { append Cell (  String . value Of ( value ) ) ; }
public void update Configuration ( @  Not Null  Configuration configuration ) { my Configuration = configuration ; invalidate Graphics Renderer ( ) ; }
protected void check Bounds (  Component comp , int x , int y , int width , int height ) { if ( comp != null ) { if ( width <= _ NUM ) { width = comp . get Width ( ) ; } if ( max Width > _ NUM && width > max Width ) { width = max Width ; } if ( height <= _ NUM ) { height = comp . get Height ( ) ; } if ( max Height > _ NUM && height > max Height ) { height = max Height ; } comp . set Bounds ( x , y , width , height ) ; } }
public static  String normalize (  Char Sequence src , java . text .  Normalizer .  Form form , int option ) { return  Normalizer Base . normalize ( src . to String ( ) , form , option ) ; }
public static  String escape (  String unescaped ) {  String Builder result = new  String Builder ( ) ; for ( char c : unescaped . to Char Array ( ) ) { switch ( c ) { case _ STR : result . append ( _ STR ) ; break ; case _ STR : result . append ( _ STR ) ; break ; case _ STR : result . append ( _ STR ) ; break ; default : result . append ( c ) ; break ; } } return result . to String ( ) ; }
public static  String escape Som (  String s ) { if ( s == null ) return _ STR ; int idx = s . index Of ( _ STR ) ; if ( idx < _ NUM ) return s ;  String Builder sb = new  String Builder ( ) ; int last = _ NUM ; while ( idx >= _ NUM ) { sb . append ( s . substring ( last , idx ) ) ; sb . append ( _ STR ) ; last = idx ; idx = s . index Of ( _ STR , idx + _ NUM ) ; } sb . append ( s . substring ( last ) ) ; return sb . to String ( ) ; }
public  Future <  Void > update Table Entity Async (  Table Entity table Entity , boolean commit ) { update Table Entity ( table Entity , commit ) ; return new  Async Result <  Void > ( null ) ; }
public static  String read String (  Data Input in ) throws  IOException { int length =  Writable Utils . read VInt ( in ) ; byte [ ] bytes = new byte [ length ] ; in . read Fully ( bytes , _ NUM , length ) ; return decode ( bytes ) ; }
private void before Key ( ) throws  JSONException {  Scope context = peek ( ) ; if ( context ==  Scope .  NONEMPTY_ OBJECT ) { out . append ( _ STR ) ; } else if ( context !=  Scope .  EMPTY_ OBJECT ) { throw new  JSONException ( _ STR ) ; } newline ( ) ; replace Top (  Scope .  DANGLING_ KEY ) ; }
private  String clean Token (  String token ) { token = token . replace ( _ STR , _ STR ) ; token = token . replace ( _ STR , _ STR ) ; token = token . replace ( _ STR , _ STR ) ; token = token . replace ( _ STR , _ STR ) ; token = token . replace ( _ STR , _ STR ) ; token = token . replace ( _ STR , _ STR ) ; token = token . replace ( _ STR , _ STR ) ; token = token . replace ( _ STR , _ STR ) ; token = token . replace ( _ STR , _ STR ) ; token = token . replace ( _ STR , _ STR ) ; return token ; }
public static int darker ( int color , float factor ) { int a =  Color . alpha ( color ) ; int r =  Color . red ( color ) ; int g =  Color . green ( color ) ; int b =  Color . blue ( color ) ; return  Color . argb ( a ,  Math . max ( ( int ) ( r * factor ) , _ NUM ) ,  Math . max ( ( int ) ( g * factor ) , _ NUM ) ,  Math . max ( ( int ) ( b * factor ) , _ NUM ) ) ; }
public static  String number String ( final int n ) { switch ( n ) { case _ NUM : return _ STR ; case _ NUM : return _ STR ; case _ NUM : return _ STR ; case _ NUM : return _ STR ; case _ NUM : return _ STR ; case _ NUM : return _ STR ; case _ NUM : return _ STR ; case _ NUM : return _ STR ; case _ NUM : return _ STR ; case _ NUM : return _ STR ; case _ NUM : return _ STR ; case _ NUM : return _ STR ; case _ NUM : return _ STR ; default : return  Integer . to String ( n ) ; } }
public static  String to Internal Name (  String class Name ) { return class Name . replace ( _ STR , _ STR ) ; }
protected synchronized void add All Data Series ( ) { for (  Indexed Process Var pv : (  Iterable <  Indexed Process Var > ) pvs . values ( ) ) {  XYSeries series = (  XYSeries ) pv . get (  FID_ DATA_ SERIES ) ; if ( series == null ) { series = new  XYSeries (  String . value Of ( pv . get (  Ecu Data Pv .  FID_ DESCRIPT ) ) ) ; pv . put (  FID_ DATA_ SERIES , series ) ; pv . add Pv Change Listener ( this ,  Pv Change Event .  PV_ MODIFIED ) ; } } }
private static void assert Field NS (  String field NS ) throws  XMPException { if ( field NS == null || field NS . length ( ) == _ NUM ) { throw new  XMPException ( _ STR ,  XMPError .  BADSCHEMA ) ; } }
public static  String Builder format To (  String Builder buf , double [ ] d ,  String sep ,  Number Format nf ) { if ( d == null ) { return buf . append ( _ STR ) ; } if ( d . length == _ NUM ) { return buf ; } buf . append ( nf . format ( d [ _ NUM ] ) ) ; for ( int i = _ NUM ; i < d . length ; i ++ ) { buf . append ( sep ) ; buf . append ( nf . format ( d [ i ] ) ) ; } return buf ; }
public void previous Viewpoint ( ) { if ( viewpoint List . size ( ) == _ NUM ) { return ; } viewpoint Index -- ; if ( viewpoint Index < _ NUM ) { viewpoint Index = viewpoint List . size ( ) - _ NUM ; } viewpoint Node . set Viewpoint ( viewpoint List . get ( viewpoint Index ) , _ BOOL , _ BOOL ) ; }
private boolean verify Value Input (  JComponent input ) {  JText Field text Field = (  JText Field ) input ;  String input String = text Field . get Text ( ) ; try {  Double . parse Double ( input String ) ; } catch (  Number Format Exception e ) { text Field . set Foreground (  Color .  RED ) ; return _ BOOL ; } text Field . set Foreground (  Color .  BLACK ) ; return _ BOOL ; }
public void add Ignored View (  View v ) { ignored Views . add ( v ) ; }
public boolean write Header (  Output Stream os ) { try { write Int ( os ,  CACHE_ MAGIC ) ; write String ( os , key ) ; write String ( os , etag == null ? _ STR : etag ) ; write Long ( os , server Date ) ; write Long ( os , last Modified ) ; write Long ( os , ttl ) ; write Long ( os , soft Ttl ) ; write String String Map ( response Headers , os ) ; os . flush ( ) ; return _ BOOL ; } catch (  IOException e ) {  Volley Log . d ( _ STR , e . to String ( ) ) ; return _ BOOL ; } }
protected  Resource load Resource (  String resource Name , int resource Type ,  String encoding ) throws  Resource Not Found Exception ,  Parse Error Exception ,  Exception {  Resource resource =  Resource Factory . get Resource ( resource Name , resource Type ) ; resource . set Runtime Services ( rsvc ) ; resource . set Name ( resource Name ) ; resource . set Encoding ( encoding ) ; long how Old It Was = _ NUM ;  Resource Loader resource Loader = null ; for ( int i = _ NUM ; i < resource Loaders . size ( ) ; i ++ ) { resource Loader = (  Resource Loader ) resource Loaders . get ( i ) ; resource . set Resource Loader ( resource Loader ) ; try { if ( resource . process ( ) ) { if ( log When Found ) { rsvc . info ( _ STR + resource Name + _ STR + resource Loader . get Class Name ( ) ) ; } how Old It Was = resource Loader . get Last Modified ( resource ) ; break ; } } catch (  Resource Not Found Exception rnfe ) { } } if ( resource . get Data ( ) == null ) { throw new  Resource Not Found Exception ( _ STR + resource Name + _ STR ) ; } resource . set Last Modified ( how Old It Was ) ; resource . set Modification Check Interval ( resource Loader . get Modification Check Interval ( ) ) ; resource . touch ( ) ; return resource ; }
public  Builder add Section (  Section Builder section ) { m Sections . add ( section ) ; return this ; }
public  String trim Audio (  String path , double start , double length ) throws  Exception {  Array List <  String > cmd = new  Array List <  String > ( ) ;  File file = new  File ( path ) ;  String out File = file . get Canonical Path ( ) + _ STR ; cmd . add ( sox Bin ) ; cmd . add ( path ) ; cmd . add ( _ STR ) ; cmd . add ( _ STR ) ; cmd . add ( _ STR ) ; cmd . add ( _ STR ) ; cmd . add ( out File ) ; cmd . add ( _ STR ) ; cmd . add ( start + _ STR ) ; if ( length != - _ NUM ) cmd . add ( length + _ STR ) ; int rc = exec Sox ( cmd , callback ) ; if ( rc != _ NUM ) { out File = null ; } if ( file . exists ( ) ) return out File ; else return null ; }
void start Scrolling Instance ( ) { if ( log . is Loggable (  Platform Logger .  Level .  FINER ) ) { log . finer ( _ STR + this ) ; } scroll ( ) ; i_scroller . set Scrollbar ( this ) ; i_scroller . start ( ) ; }
public void add Steps ( final  Iterator < ? extends  IStep > steps ) { if ( steps == null ) throw new  Illegal Argument Exception ( ) ; while ( steps . has Next ( ) ) { add Step ( steps . next ( ) ) ; } }
private static boolean contents Equals (  Input Stream in1 ,  Input Stream in2 ) throws  IOException { if ( ! ( in1 instanceof  Buffered Input Stream ) ) { in1 = new  Buffered Input Stream ( in1 ) ; } if ( ! ( in2 instanceof  Buffered Input Stream ) ) { in2 = new  Buffered Input Stream ( in2 ) ; } int ch = in1 . read ( ) ; while ( ch != - _ NUM ) { int ch2 = in2 . read ( ) ; if ( ch != ch2 ) { return _ BOOL ; } ch = in1 . read ( ) ; } int ch2 = in2 . read ( ) ; return ch2 == - _ NUM ; }
public  Response new Fixed Length Response (  String msg ) { return new Fixed Length Response (  Response .  Status .  OK ,  Nano HTTPD .  MIME_ HTML , msg ) ; }
@  Override public void close ( ) throws  XMLStream Exception { log . log (  Level .  FINE , _ STR ) ; stream . close ( ) ; }
public static  String remove Hashbang (  String url ) { return url . replace First ( _ STR , _ STR ) ; }
public static double magnitude ( final double x , final double y , final double z ) { return  Math . sqrt ( x * x + y * y + z * z ) ; }
public static  Mat D make Translation Rot XY ( double tx , double ty , double tz , double angle X , double angle Y ) { double cos X =  Math . cos (  Math . to Radians ( angle X ) ) ; double sin X =  Math . sin (  Math . to Radians ( angle X ) ) ; double cos Y =  Math . cos (  Math . to Radians ( angle Y ) ) ; double sin Y =  Math . sin (  Math . to Radians ( angle Y ) ) ; return new  Mat D ( new double [ ] { cos Y , sin X * sin Y , - cos X * sin Y , _ NUM , _ NUM , cos X , sin X , _ NUM , sin Y , - sin X * cos Y , cos X * cos Y , _ NUM , tx , ty , tz , _ NUM } ) ; }
private static  SSLContext create Easy SSLContext ( ) {  SSLContext context ; try { context =  SSLContext . get Instance ( _ STR ) ; context . init ( null , _trust Managers , new  Secure Random ( ) ) ;  Https URLConnection . set Default SSLSocket Factory ( context . get Socket Factory ( ) ) ; } catch ( final  General Security Exception gse ) { throw new  Illegal State Exception ( gse . get Message ( ) ) ; } return context ; }
protected  List < byte [ ] > convert String List To Byte Array (  List <  String > value List ) {  List < byte [ ] > byte Array List = new  Array List < > ( value List . size ( ) ) ; for (  String value : value List ) { byte Array List . add ( value . get Bytes (  Charset . default Charset ( ) ) ) ; } return byte Array List ; }
protected void add Widget (  Widget widget ) { if ( widget != null ) { widgets . put ( widget . get Id ( ) , widget ) ; if ( ! widget Types . contains ( widget . get Type ( ) ) ) { widget Types . add ( widget . get Type ( ) ) ; } } }
public void add (  Container Atom atom ) { container Children . add ( atom ) ; }
public  String put (  String url ,  String json , final int expected Status Code ) { return put ( url , json ,  Collections . <  String ,  String > empty Map ( ) , expected Status Code ) ; }
public void update Width ( ) { if ( m_ Sum Of Weights > _ NUM ) { double mean = m_ Weighted Sum / m_ Sum Of Weights ; double variance = m_ Weighted Sum Squared / m_ Sum Of Weights - mean * mean ; if ( variance < _ NUM ) { variance = _ NUM ; } m_ Width =  Math . sqrt ( variance ) *  Math . pow ( m_ Sum Of Weights , m_ Exponent ) ; if ( m_ Width <= m_ Min Width ) { m_ Width = m_ Min Width ; } } else { m_ Width =  Double .  MAX_ VALUE ; } }
public  Multivariate Table (  Categorical Table head Table ) { this . head Vars = new  Hash Set <  String > (  Arrays . as List ( head Table . get Variable ( ) ) ) ; this . table = new  Hash Map <  Assignment ,  Double > ( ) ;  String variable = head Table . get Variable ( ) ; for (  Value a : head Table . get Values ( ) ) { double prob = head Table . get Prob ( a ) ; table . put ( new  Assignment ( variable , a ) , prob ) ; } }
public int last Index Of (  String sub String , int start ) { int count = length ( ) ; int sub Count = sub String . length ( ) ; if ( sub Count <= count && start >= _ NUM ) { if ( sub Count > _ NUM ) { if ( start > count - sub Count ) { start = count - sub Count ; } char [ ] target = sub String . to Char Array ( ) ; int sub Offset = _ NUM ; char first Char = target [ sub Offset ] ; int end = sub Offset + sub Count ; while ( _ BOOL ) { int i = last Index Of ( first Char , start ) ; if ( i == - _ NUM ) { return - _ NUM ; } int o1 = i , o2 = sub Offset ; while ( ++ o2 < end && char At ( ++ o1 ) == target [ o2 ] ) { } if ( o2 == end ) { return i ; } start = i - _ NUM ; } } return start < count ? start : count ; } return - _ NUM ; }
private  Map map Name To Display Name (  Set names ) {  Map map = new  Hash Map ( names . size ( ) * _ NUM ) ;  AMView Config v Config =  AMView Config . get Instance ( ) ; for (  Iterator iter = names . iterator ( ) ; iter . has Next ( ) ; ) {  String name = (  String ) iter . next ( ) ; if ( v Config . is Service Visible ( name ) ) {  String display Name = get Localized Service Name ( name ) ; if ( ! name . equals ( display Name ) ) { map . put ( name , display Name ) ; } } } return map ; }
@  Override public  String to String ( ) { return  String . format ( _ STR , get Thread Id ( ) ) ; }
public static boolean cancel Potential Work (  Object data ,  Image View image View ) { final  Bitmap Worker Task bitmap Worker Task = get Bitmap Worker Task ( image View ) ; if ( bitmap Worker Task != null ) { final  Object bitmap Data = bitmap Worker Task . m Data ; if ( bitmap Data == null || ! bitmap Data . equals ( data ) ) { bitmap Worker Task . cancel ( _ BOOL ) ; } else { return _ BOOL ; } } return _ BOOL ; }
public static final  Bitmap create Blurred Bitmap ( final  Bitmap sent Bitmap ) { if ( sent Bitmap == null ) { return null ; } final  Bitmap m Bitmap = sent Bitmap . copy ( sent Bitmap . get Config ( ) , _ BOOL ) ; final int w = m Bitmap . get Width ( ) ; final int h = m Bitmap . get Height ( ) ; final int [ ] pix = new int [ w * h ] ; m Bitmap . get Pixels ( pix , _ NUM , w , _ NUM , _ NUM , w , h ) ; final int wm = w - _ NUM ; final int hm = h - _ NUM ; final int wh = w * h ; final int div =  DEFAULT_ BLUR_ RADIUS +  DEFAULT_ BLUR_ RADIUS + _ NUM ; final int r [ ] = new int [ wh ] ; final int g [ ] = new int [ wh ] ; final int b [ ] = new int [ wh ] ; final int vmin [ ] = new int [  Math . max ( w , h ) ] ; int rsum , gsum , bsum , x , y , i , p , yp , yi , yw ; int divsum = div + _ NUM > > _ NUM ; divsum *= divsum ; final int dv [ ] = new int [ _ NUM * divsum ] ; for ( i = _ NUM ; i < _ NUM * divsum ; i ++ ) { dv [ i ] = i / divsum ; } yw = yi = _ NUM ; final int [ ] [ ] stack = new int [ div ] [ _ NUM ] ; int stackpointer ; int stackstart ; int [ ] sir ; int rbs ; final int r1 =  DEFAULT_ BLUR_ RADIUS + _ NUM ; int routsum , goutsum , boutsum ; int rinsum , ginsum , binsum ; for ( y = _ NUM ; y < h ; y ++ ) { rinsum = ginsum = binsum = routsum = goutsum = boutsum = rsum = gsum = bsum = _ NUM ; for ( i = -  DEFAULT_ BLUR_ RADIUS ; i <=  DEFAULT_ BLUR_ RADIUS ; i ++ ) { p = pix [ yi +  Math . min ( wm ,  Math . max ( i , _ NUM ) ) ] ; sir = stack [ i +  DEFAULT_ BLUR_ RADIUS ] ; sir [ _ NUM ] = ( p & _ NUM ) > > _ NUM ; sir [ _ NUM ] = ( p & _ NUM ) > > _ NUM ; sir [ _ NUM ] = p & _ NUM ; rbs = r1 -  Math . abs ( i ) ; rsum += sir [ _ NUM ] * rbs ; gsum += sir [ _ NUM ] * rbs ; bsum += sir [ _ NUM ] * rbs ; if ( i > _ NUM ) { rinsum += sir [ _ NUM ] ; ginsum += sir [ _ NUM ] ; binsum += sir [ _ NUM ] ; } else { routsum += sir [ _ NUM ] ; goutsum += sir [ _ NUM ] ; boutsum += sir [ _ NUM ] ; } } stackpointer =  DEFAULT_ BLUR_ RADIUS ; for ( x = _ NUM ; x < w ; x ++ ) { r [ yi ] = dv [ rsum ] ; g [ yi ] = dv [ gsum ] ; b [ yi ] = dv [ bsum ] ; rsum -= routsum ; gsum -= goutsum ; bsum -= boutsum ; stackstart = stackpointer -  DEFAULT_ BLUR_ RADIUS + div ; sir = stack [ stackstart % div ] ; routsum -= sir [ _ NUM ] ; goutsum -= sir [ _ NUM ] ; boutsum -= sir [ _ NUM ] ; if ( y == _ NUM ) { vmin [ x ] =  Math . min ( x +  DEFAULT_ BLUR_ RADIUS + _ NUM , wm ) ; } p = pix [ yw + vmin [ x ] ] ; sir [ _ NUM ] = ( p & _ NUM ) > > _ NUM ; sir [ _ NUM ] = ( p & _ NUM ) > > _ NUM ; sir [ _ NUM ] = p & _ NUM ; rinsum += sir [ _ NUM ] ; ginsum += sir [ _ NUM ] ; binsum += sir [ _ NUM ] ; rsum += rinsum ; gsum += ginsum ; bsum += binsum ; stackpointer = ( stackpointer + _ NUM ) % div ; sir = stack [ stackpointer % div ] ; routsum += sir [ _ NUM ] ; goutsum += sir [ _ NUM ] ; boutsum += sir [ _ NUM ] ; rinsum -= sir [ _ NUM ] ; ginsum -= sir [ _ NUM ] ; binsum -= sir [ _ NUM ] ; yi ++ ; } yw += w ; } for ( x = _ NUM ; x < w ; x ++ ) { rinsum = ginsum = binsum = routsum = goutsum = boutsum = rsum = gsum = bsum = _ NUM ; yp = -  DEFAULT_ BLUR_ RADIUS * w ; for ( i = -  DEFAULT_ BLUR_ RADIUS ; i <=  DEFAULT_ BLUR_ RADIUS ; i ++ ) { yi =  Math . max ( _ NUM , yp ) + x ; sir = stack [ i +  DEFAULT_ BLUR_ RADIUS ] ; sir [ _ NUM ] = r [ yi ] ; sir [ _ NUM ] = g [ yi ] ; sir [ _ NUM ] = b [ yi ] ; rbs = r1 -  Math . abs ( i ) ; rsum += r [ yi ] * rbs ; gsum += g [ yi ] * rbs ; bsum += b [ yi ] * rbs ; if ( i > _ NUM ) { rinsum += sir [ _ NUM ] ; ginsum += sir [ _ NUM ] ; binsum += sir [ _ NUM ] ; } else { routsum += sir [ _ NUM ] ; goutsum += sir [ _ NUM ] ; boutsum += sir [ _ NUM ] ; } if ( i < hm ) { yp += w ; } } yi = x ; stackpointer =  DEFAULT_ BLUR_ RADIUS ; for ( y = _ NUM ; y < h ; y ++ ) { pix [ yi ] = _ NUM | dv [ rsum ] << _ NUM | dv [ gsum ] << _ NUM | dv [ bsum ] ; rsum -= routsum ; gsum -= goutsum ; bsum -= boutsum ; stackstart = stackpointer -  DEFAULT_ BLUR_ RADIUS + div ; sir = stack [ stackstart % div ] ; routsum -= sir [ _ NUM ] ; goutsum -= sir [ _ NUM ] ; boutsum -= sir [ _ NUM ] ; if ( x == _ NUM ) { vmin [ y ] =  Math . min ( y + r1 , hm ) * w ; } p = x + vmin [ y ] ; sir [ _ NUM ] = r [ p ] ; sir [ _ NUM ] = g [ p ] ; sir [ _ NUM ] = b [ p ] ; rinsum += sir [ _ NUM ] ; ginsum += sir [ _ NUM ] ; binsum += sir [ _ NUM ] ; rsum += rinsum ; gsum += ginsum ; bsum += binsum ; stackpointer = ( stackpointer + _ NUM ) % div ; sir = stack [ stackpointer ] ; routsum += sir [ _ NUM ] ; goutsum += sir [ _ NUM ] ; boutsum += sir [ _ NUM ] ; rinsum -= sir [ _ NUM ] ; ginsum -= sir [ _ NUM ] ; binsum -= sir [ _ NUM ] ; yi += w ; } } m Bitmap . set Pixels ( pix , _ NUM , w , _ NUM , _ NUM , w , h ) ; return m Bitmap ; }
public void add Listener (  Key Combo Listener listener ) { m Listeners . add ( listener ) ; }
private int make Available ( ) throws  IOException { if ( pos != - _ NUM ) { return _ NUM ; } total += tail - head - pad ;  System . arraycopy ( buffer , tail - pad , buffer , _ NUM , pad ) ; head = _ NUM ; tail = pad ; for ( ; ; ) { int bytes Read = input . read ( buffer , tail , buf Size - tail ) ; if ( bytes Read == - _ NUM ) { final  String msg = _ STR ; throw new  Malformed Stream Exception ( msg ) ; } tail += bytes Read ; find Separator ( ) ; int av = available ( ) ; if ( av > _ NUM || pos != - _ NUM ) { return av ; } } }
public  Notification (  String type ,  Object source , long sequence Number , long time Stamp ) { super ( source ) ; this . source = source ; this . type = type ; this . sequence Number = sequence Number ; this . time Stamp = time Stamp ; }
@  Override public boolean domain Match ( final  String host , final  String domain ) { final boolean match = host . equals ( domain ) || ( domain . starts With ( _ STR ) && host . ends With ( domain ) ) ; return match ; }
public static  Object [ ] [ ] form Object Array ( double [ ] [ ] data ) {  Object [ ] [ ] object = new  Double [ data . length ] [ data [ _ NUM ] . length ] ; for ( int i = _ NUM ; i < object . length ; i ++ ) { for ( int j = _ NUM ; j < object [ i ] . length ; j ++ ) { object [ i ] [ j ] = new  Double ( data [ i ] [ j ] ) ; } } return object ; }
public void write Timer Report (  XMLWriter writer ) { writer . write Open Tag ( _ STR ) ; writer . write Open Tag ( _ STR , new  Attribute .  Default <  String > ( _ STR , _ STR ) ) ; writer . write IDref ( _ STR , _ STR ) ; writer . write Close Tag ( _ STR ) ; writer . write Close Tag ( _ STR ) ; }
protected void initialize ( ) { super . initialize ( ) ; m_ File Chooser = new  JFile Chooser ( ) ; m_ File Chooser . set Accept All File Filter Used ( _ BOOL ) ; m_ File Chooser . set Multi Selection Enabled ( _ BOOL ) ; m_ Undo = new  Undo Manager ( ) ; m_ Args = new  String [ _ NUM ] ; }
public int read ( char cbuf [ ] , int off , int len ) throws  IOException { synchronized ( lock ) { ensure Open ( ) ; if ( ( off < _ NUM ) || ( off > cbuf . length ) || ( len < _ NUM ) || ( ( off + len ) > cbuf . length ) || ( ( off + len ) < _ NUM ) ) { throw new  Index Out Of Bounds Exception ( ) ; } else if ( len == _ NUM ) { return _ NUM ; } if ( next >= length ) return - _ NUM ; int n =  Math . min ( length - next , len ) ; str . get Chars ( next , next + n , cbuf , off ) ; next += n ; return n ; } }
public static  String remove Duplicate Whitespace (  String s ) {  String Builder result = new  String Builder ( ) ; int length = s . length ( ) ; boolean is Previous White Space = _ BOOL ; for ( int i = _ NUM ; i < length ; i ++ ) { char c = s . char At ( i ) ; boolean this Char White Space =  Character . is Whitespace ( c ) ; if ( ! ( is Previous White Space && this Char White Space ) ) { result . append ( c ) ; } is Previous White Space = this Char White Space ; } return result . to String ( ) ; }
@  Override public  String to Parsable String (  Type declaring Type ,  Type Tuple input Types ,  Type output Type ) { return declaring Type . get Name ( ) + _ STR + field . get Name ( ) + _ STR ; }
public  Audio Module (  Dialogue System system ) { this . system = system ; }
public  Moving Button Container ( ) { set Layout ( new java . awt .  Flow Layout ( ) ) ; timer = new  Timer ( _ NUM , this ) ; button = new  JButton ( _ STR ) ; button . set Opaque ( _ BOOL ) ; button . add Action Listener ( this ) ; add ( button ) ; }
public boolean contains Attr Value (  String attr Name ,  String attr Value ) { if ( attr Set != null ) {  Set attr = (  Set ) attr Set . get ( attr Name ) ; if ( attr != null ) { return ( attr . contains ( attr Value ) ) ; } } return ( _ BOOL ) ; }
public  Business Object Data Key create Business Object Data Key (  Business Object Data business Object Data ) {  Business Object Data Key business Object Data Key = new  Business Object Data Key ( ) ; business Object Data Key . set Namespace ( business Object Data . get Namespace ( ) ) ; business Object Data Key . set Business Object Definition Name ( business Object Data . get Business Object Definition Name ( ) ) ; business Object Data Key . set Business Object Format Usage ( business Object Data . get Business Object Format Usage ( ) ) ; business Object Data Key . set Business Object Format File Type ( business Object Data . get Business Object Format File Type ( ) ) ; business Object Data Key . set Business Object Format Version ( business Object Data . get Business Object Format Version ( ) ) ; business Object Data Key . set Partition Value ( business Object Data . get Partition Value ( ) ) ; business Object Data Key . set Sub Partition Values ( business Object Data . get Sub Partition Values ( ) ) ; business Object Data Key . set Business Object Data Version ( business Object Data . get Version ( ) ) ; return business Object Data Key ; }
public void print Usage ( ) { out ( get Usage String ( ) ) ; }
private void update Call Stack For Call (  Stack <  Method Call > call Stack ,  Method Call call ) { call Stack . push ( call ) ; }
protected boolean run Test If Sys Prop Defined (  String prop Name ) {  String prop =  System . get Property ( prop Name ) ; return ( prop != null ) && ( prop . length ( ) > _ NUM ) ; }
public void start Event Log (  String tenant , int size ) throws  Client Exception ,  Client Protocol Exception ,  Web Application Exception ,  Http Exception ,  IOException { start Event Log ( tenant ,  Integer . value Of ( size ) ) ; }
Index Entry (  Byte Provider byte Provider ) throws  IOException {  MXFProperty Populator . populate Field ( byte Provider , this , _ STR ) ;  MXFProperty Populator . populate Field ( byte Provider , this , _ STR ) ;  MXFProperty Populator . populate Field ( byte Provider , this , _ STR ) ;  MXFProperty Populator . populate Field ( byte Provider , this , _ STR ) ; }
public static  Vector  Discard Last Element (  Vector v ) { if ( v . size ( ) > _ NUM ) v . remove ( v . size ( ) - _ NUM ) ; return v ; }
private static int find Esds Position (  Parsable Byte Array parent , int position , int size ) { int child Atom Position = parent . get Position ( ) ; while ( child Atom Position - position < size ) { parent . set Position ( child Atom Position ) ; int child Atom Size = parent . read Int ( ) ;  Assertions . check Argument ( child Atom Size > _ NUM , _ STR ) ; int child Type = parent . read Int ( ) ; if ( child Type ==  Atom .  TYPE_esds ) { return child Atom Position ; } child Atom Position += child Atom Size ; } return - _ NUM ; }
public static void write Uuid (  Byte Buf buf ,  UUID uuid ) { buf . write Long ( uuid . get Most Significant Bits ( ) ) ; buf . write Long ( uuid . get Least Significant Bits ( ) ) ; }
public  Flux Concat Array <  T > concat Additional Source Last (  Publisher < ? extends  T > source ) { int n = array . length ; @  Suppress Warnings ( _ STR )  Publisher < ? extends  T > [ ] new Array = new  Publisher [ n + _ NUM ] ;  System . arraycopy ( array , _ NUM , new Array , _ NUM , n ) ; new Array [ n ] = source ; return new  Flux Concat Array < > ( delay Error , new Array ) ; }
public void shutdown ( ) { shutdown ( _ BOOL ) ; }
synchronized  String create Local Id ( ) { long local Id Number = random . next Long ( ) ;  String local Id = _ STR +  Long . to Hex String ( local Id Number ) ; if ( ! is Local Id ( local Id ) ) { throw new  Illegal State Exception ( _ STR + local Id + _ STR + _ STR ) ; } return local Id ; }
@  Override public  Socket connect ( ) {  Log . d (  TAG , _ STR + address . get Host Address ( ) + _ STR +  Integer . to String ( port ) ) ; final  Server Socket temp Socket ; try { temp Socket = new  Server Socket ( port , _ NUM , address ) ; } catch (  IOException e ) { report Error ( _ STR + e . get Message ( ) ) ; return null ; } synchronized ( raw Socket Lock ) { if ( server Socket != null ) {  Log . e (  TAG , _ STR ) ; } server Socket = temp Socket ; } try { return temp Socket . accept ( ) ; } catch (  IOException e ) { report Error ( _ STR + e . get Message ( ) ) ; return null ; } }
private void add Text To String (  String text ,  String Builder string Builder ) { if ( string Builder . length ( ) > _ NUM ) { string Builder . append ( _ STR ) ; } string Builder . append ( text ) ; }
public  String to String (  Charset encoding ) {  String Builder out = new  String Builder ( ) ; append To ( out , encoding ) ; return out . to String ( ) ; }
public void write (  String filename ) { logger . info ( _ STR ) ; try { open File ( filename ) ; write Xml Head ( ) ; start Carriers ( this . writer ) ; for (  Carrier carrier : carriers ) { start Carrier ( carrier , this . writer ) ; write Vehicles And Their Types ( carrier , this . writer ) ; write Shipments ( carrier , this . writer ) ; write Services ( carrier , this . writer ) ; write Plans ( carrier , this . writer ) ; end Carrier ( this . writer ) ; } end Carriers ( this . writer ) ; close ( ) ; logger . info ( _ STR ) ; } catch (  IOException e ) { e . print Stack Trace ( ) ; logger . error ( e ) ;  System . exit ( _ NUM ) ; } }
public void add Resource Listener (  Resource Events Listener listener ) { resource Listeners . add ( listener ) ; }
public void test Missing Main Activity ( ) throws  Exception { m Enabled . add (  Launcher Activity Detector .  ISSUE_ MORE_ THAN_ ONE_ LAUNCHER ) ; m Enabled . add (  Launcher Activity Detector .  ISSUE_ MISSING_ LAUNCHER ) ; m Enabled . add (  Launcher Activity Detector .  ISSUE_ LAUNCHER_ ACTIVITY_ IN_ LIBRARY ) ;  String expected = _ STR + _ STR + _ STR + _ STR + _ STR ;  String result = lint Project ( xml (  FN_ ANDROID_ MANIFEST_ XML , _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR ) ) ; assert Equals ( expected , result ) ; }
public static byte [ ] hex To Bytes (  String str ) { byte [ ] bytes = new byte [ ( str . length ( ) + _ NUM ) / _ NUM ] ; if ( str . length ( ) == _ NUM ) { return bytes ; } bytes [ _ NUM ] = _ NUM ; int nibble Idx = ( str . length ( ) % _ NUM ) ; for ( int i = _ NUM ; i < str . length ( ) ; i ++ ) { char c = str . char At ( i ) ; if ( ! is Hex ( c ) ) { throw new  Illegal Argument Exception ( _ STR ) ; } if ( ( nibble Idx % _ NUM ) == _ NUM ) { bytes [ nibble Idx > > _ NUM ] = ( byte ) ( hex Value ( c ) << _ NUM ) ; } else { bytes [ nibble Idx > > _ NUM ] += ( byte ) hex Value ( c ) ; } nibble Idx ++ ; } return bytes ; }
public  String build Jvm Vendor ( ) { return properties . get Property ( _ STR ) ; }
Tree Bin (  Tree Node <  K ,  V > b ) { super (  TREEBIN , null , null , null ) ; this . first = b ;  Tree Node <  K ,  V > r = null ; for (  Tree Node <  K ,  V > x = b , next ; x != null ; x = next ) { next = (  Tree Node <  K ,  V > ) x . next ; x . left = x . right = null ; if ( r == null ) { x . parent = null ; x . red = _ BOOL ; r = x ; } else {  K k = x . key ; int h = x . hash ;  Class < ? > kc = null ; for (  Tree Node <  K ,  V > p = r ; ; ) { int dir , ph ;  K pk = p . key ; if ( ( ph = p . hash ) > h ) dir = - _ NUM ; else if ( ph < h ) dir = _ NUM ; else if ( ( kc == null && ( kc = comparable Class For ( k ) ) == null ) || ( dir = compare Comparables ( kc , k , pk ) ) == _ NUM ) dir = tie Break Order ( k , pk ) ;  Tree Node <  K ,  V > xp = p ; if ( ( p = ( dir <= _ NUM ) ? p . left : p . right ) == null ) { x . parent = xp ; if ( dir <= _ NUM ) xp . left = x ; else xp . right = x ; r = balance Insertion ( r , x ) ; break ; } } } } this . root = r ; assert check Invariants ( root ) ; }
public void action Performed (  Action Event e ) {  Default Mutable Tree Node last Item = get Selected Node ( ) ;  Default Mutable Tree Node parent ; if ( last Item != null ) { parent = (  Default Mutable Tree Node ) last Item . get Parent ( ) ; if ( parent == null ) { parent = (  Default Mutable Tree Node ) tree Model . get Root ( ) ; last Item = null ; } } else { parent = (  Default Mutable Tree Node ) tree Model . get Root ( ) ; } if ( parent == null ) { tree Model . set Root ( create New Node ( _ STR +  Integer . to String ( insert Count ++ ) ) ) ; } else { int new Index ; if ( last Item == null ) { new Index = tree Model . get Child Count ( parent ) ; } else { new Index = parent . get Index ( last Item ) ; } tree Model . insert Node Into ( create New Node ( _ STR +  Integer . to String ( insert Count ++ ) ) , parent , new Index ) ; } }
private void start Authentication Activity ( ) {  Intent intent = new  Intent (  Server Details . this ,  Authentication Activity . class ) ; intent . set Flags (  Intent .  FLAG_ ACTIVITY_ CLEAR_ TOP ) ; start Activity ( intent ) ; }
public  String next Token ( ) { current Position = ( new Position >= _ NUM && ! delims Changed ) ? new Position : skip Delimiters ( current Position ) ; delims Changed = _ BOOL ; new Position = - _ NUM ; if ( current Position >= max Position ) throw new  No Such Element Exception ( ) ; int start = current Position ; current Position = scan Token ( current Position ) ; return str . substring ( start , current Position ) ; }
private  Component create Toolbar ( ) { toolbar = new  JTool Bar ( ) ; for (  String tool Key : get Tool Bar Keys ( ) ) { if ( tool Key . equals ( _ STR ) ) { toolbar . add (  Box . create Horizontal Strut ( _ NUM ) ) ; } else { toolbar . add ( create Tool ( tool Key ) ) ; } } toolbar . add (  Box . create Horizontal Glue ( ) ) ; return toolbar ; }
public  String to Plain ( ) {  String Buffer sb = new  String Buffer ( ) ; int length = size ( ) ; for ( int i = _ NUM ; i <= length ; i ++ ) { sb . append ( i ) ; sb . append ( _ STR ) ; sb . append ( get ( i - _ NUM , null ) ) ; sb . append ( _ STR ) ; } return sb . to String ( ) ; }
@  Override public void populate Frame (  Audio a ) { if ( ! ( a instanceof  Audio Source ) ) { throw new  Illegal Argument Exception ( a . get System Name ( ) + _ STR ) ; } super . populate Frame ( a ) ;  Audio Source s = (  Audio Source ) a ;  Audio Manager am =  Instance Manager . get Default ( jmri .  Audio Manager . class ) ;  String ab = s . get Assigned Buffer Name ( ) ;  Audio b = am . get Audio ( ab ) ; if ( b != null ) { assigned Buffer . set Selected Item ( b . get User Name ( ) == null ? ab : b . get User Name ( ) ) ; } loop Infinite . set Selected ( ( s . get Min Loops ( ) ==  Audio Source .  LOOP_ CONTINUOUS ) ) ; loop Min . set Value ( loop Infinite . is Selected ( ) ? _ NUM : s . get Min Loops ( ) ) ; loop Max . set Value ( loop Infinite . is Selected ( ) ? _ NUM : s . get Max Loops ( ) ) ; position . set Value ( s . get Position ( ) ) ; position Relative . set Selected ( s . is Position Relative ( ) ) ; velocity . set Value ( s . get Velocity ( ) ) ; gain . set Value ( s . get Gain ( ) ) ; pitch . set Value ( s . get Pitch ( ) ) ; ref Distance . set Value ( s . get Reference Distance ( ) ) ; max Distance . set Value ( s . get Maximum Distance ( ) ) ; roll Off Factor . set Value ( s . get Roll Off Factor ( ) ) ; fade In Time . set Value ( s . get Fade In ( ) ) ; fade Out Time . set Value ( s . get Fade Out ( ) ) ; this . new Source = _ BOOL ; }
public static double p ( double  Y [ ] [ ] , int j , int k ) { int  N =  Y . length ; double p = _ NUM ; for ( int i = _ NUM ; i <  N ; i ++ ) { if ( ( int )  Math . round (  Y [ i ] [ j ] ) == k ) { p += _ NUM ; } } return p /  N ; }
public static double calculate Row Total (  Values2 D data , int row , int [ ] valid Cols ) {  Param Checks . null Not Permitted ( data , _ STR ) ; double total = _ NUM ; int col Count = data . get Column Count ( ) ; for ( int v = _ NUM ; v < valid Cols . length ; v ++ ) { int col = valid Cols [ v ] ; if ( col < col Count ) {  Number n = data . get Value ( row , col ) ; if ( n != null ) { total += n . double Value ( ) ; } } } return total ; }
public static boolean check File ( final  File f ) { return f . exists ( ) && f . is File ( ) && f . can Read ( ) ; }
public void children Added (  Bean Context Membership Event bcme ) { find And Init ( bcme . iterator ( ) ) ; }
public  String process (  Item item ) throws  Process Exception { int count = _ NUM ;  Item ss = item . get Item As (  Relation .  SYLLABLE ) ;  Item first Syllable =  FIRST_ SYLLABLE_ PATH . find Item ( item ) ; for (  Item p = ss ; p != null ; p = p . get Previous ( ) , count ++ ) { if ( p . equals Shared ( first Syllable ) ) { break ; } } return  Integer . to String ( rail ( count ) ) ; }
private void remove Instances From Containers (  Array List <  Container > containers ,  Map <  Integer ,  List <  Instance Id > > allocation ,  Map <  String ,  Integer > components To Scale Down ) {  Array List <  Ram Requirement > ram Requirements = get Sorted RAMInstances ( components To Scale Down ) ; for (  Ram Requirement ram Requirement : ram Requirements ) {  String component = ram Requirement . get Component Name ( ) ; int num Instances To Remove = - components To Scale Down . get ( component ) ; for ( int j = _ NUM ; j < num Instances To Remove ; j ++ ) {  Pair <  Integer ,  Instance Id > id Pair = remove FFDInstance ( containers , component ) ;  List <  Instance Id > instances = allocation . get ( id Pair . first ) ; instances . remove ( id Pair . second ) ; allocation . put ( id Pair . first , instances ) ; } } }
public static void draw Default Line And Arrows (  Draw Handler drawer ,  Relation Point Handler relation Points ) { draw Line And Arrows ( drawer , relation Points , new  Match <  Line Type > ( _ STR ,  Line Type .  SOLID ) , new  Match <  Arrow End > ( _ STR , null ) , new  Match <  Arrow End > ( _ STR , null ) ) ; }
public void notify Changed Slot (  Loco Net Slot s ) {  Dcc Throttle throttle = new  Loco Net Throttle ( (  Loco Net System Connection Memo ) adapter Memo , s ) ; notify Throttle Known ( throttle , new  Dcc Loco Address ( s . loco Addr ( ) , is Long Address ( s . loco Addr ( ) ) ) ) ; if ( waiting For Notification . contains Key ( s . loco Addr ( ) ) ) {  Thread r = waiting For Notification . get ( s . loco Addr ( ) ) ; synchronized ( r ) { r . interrupt ( ) ; } waiting For Notification . remove ( s . loco Addr ( ) ) ; } }
public void start ( ) throws  IOException ;
public static boolean are Regexp Modifiers Valid (  String flags ) { final int  GROUP = _ NUM ; final int  CASE_ INSENSITIVE = _ NUM ; final int  MULTILINE = _ NUM ; int seen = _ NUM ; for ( int i = _ NUM , n = flags . length ( ) ; i < n ; ++ i ) { char flag = flags . char At ( i ) ; int flag Mask ; switch ( flag ) { case _ STR : flag Mask =  GROUP ; break ; case _ STR : flag Mask =  CASE_ INSENSITIVE ; break ; case _ STR : flag Mask =  MULTILINE ; break ; default : return _ BOOL ; } if ( ( seen & flag Mask ) != _ NUM ) { return _ BOOL ; } seen = seen | flag Mask ; } return _ BOOL ; }
protected void skipped Ent (  String name ) throws  SAXException { m Hand Cont . skipped Entity ( name ) ; }
boolean match (  String name ) ;
public static  String format Time (  String millis ) {  String result ; try { long time =  Long . value Of ( millis ) ; result = format Time ( time ) ; } catch (  Number Format Exception e ) { throw new  Illegal Argument Exception ( _ STR + millis ) ; } return result ; }
public static byte [ ] decode (  String input ) throws  Parse Exception { if ( input . length ( ) == _ NUM ) { return new byte [ _ NUM ] ; } byte [ ] input58 = new byte [ input . length ( ) ] ; for ( int i = _ NUM ; i < input . length ( ) ; ++ i ) { char c = input . char At ( i ) ; int digit = c < _ NUM ?  INDEXES [ c ] : - _ NUM ; if ( digit < _ NUM ) { throw new  Parse Exception ( _ STR + c + _ STR + i , i ) ; } input58 [ i ] = ( byte ) digit ; } int zeros = _ NUM ; while ( zeros < input58 . length && input58 [ zeros ] == _ NUM ) { ++ zeros ; } byte [ ] decoded = new byte [ input . length ( ) ] ; int output Start = decoded . length ; for ( int input Start = zeros ; input Start < input58 . length ; ) { decoded [ -- output Start ] = divmod ( input58 , input Start , _ NUM , _ NUM ) ; if ( input58 [ input Start ] == _ NUM ) { ++ input Start ; } } while ( output Start < decoded . length && decoded [ output Start ] == _ NUM ) { ++ output Start ; } return  Arrays . copy Of Range ( decoded , output Start - zeros , decoded . length ) ; }
@  Override public synchronized void maybe Start Tracking Job (  Job Status job ) { if ( job . has Timing Delay Constraint ( ) || job . has Deadline Constraint ( ) ) { maybe Stop Tracking Job ( job ) ;  List Iterator <  Job Status > it = m Tracked Jobs . list Iterator ( m Tracked Jobs . size ( ) ) ; while ( it . has Previous ( ) ) {  Job Status ts = it . previous ( ) ; if ( ts . get Latest Run Time Elapsed ( ) < job . get Latest Run Time Elapsed ( ) ) { break ; } } it . add ( job ) ; maybe Update Alarms ( job . has Timing Delay Constraint ( ) ? job . get Earliest Run Time ( ) :  Long .  MAX_ VALUE , job . has Deadline Constraint ( ) ? job . get Latest Run Time Elapsed ( ) :  Long .  MAX_ VALUE ) ; } }
public  Gaussian Density Function ( double [ ] mean , double [ ] variance ) { this . mean = mean ; if ( mean . length != variance . length ) { log . warning ( _ STR ) ; } std Dev = new double [ variance . length ] ; for ( int i = _ NUM ; i < variance . length ; i ++ ) { if ( variance [ i ] < _ NUM ) { log . warning ( _ STR + variance ) ; } std Dev [ i ] =  Math . sqrt ( variance [ i ] ) ; } this . variance = variance ; }
private  String Builder make Description (  Cluster < ? > c ) {  String Builder buf = new  String Builder ( ) ; buf . append ( _ STR ) ; buf . append ( c . get Name Automatic ( ) ) ; buf . append ( _ STR ) ; buf . append ( _ STR + c . size ( ) ) ; buf . append ( _ STR ) ; return buf ; }
public static boolean is Current Version Equal To (  Integer expected Version ) {  String [ ] parsed Version = parse Version ( get Current Version ( ) ) ; if ( parsed Version == null ) { return _ BOOL ; } return expected Version . equals (  Integer . value Of ( parsed Version [ _ NUM ] ) ) ; }
private  Attribute Schema Impl check And Update Choice Values (  Attribute Schema Impl existing Attr ,  Attribute Schema Impl new Attr ,  List <  String > new Choices ) throws  Upgrade Exception {  List <  String > choices = new  Array List < > (  Arrays . as List ( existing Attr . get Choice Values ( ) ) ) ; if ( choices . contains All ( new Choices ) ) { return null ; } else { choices . add All ( new Choices ) ; update Choice Values ( new Attr , choices ) ; } return new Attr ; }
public final boolean is Registered ( ) { return ! canonical Name . starts With ( _ STR ) && ! canonical Name . starts With ( _ STR ) ; }
public void make Primary (  Client Proxy Membership ID proxy Id , boolean is Client Ready ) {  Cache Client Proxy proxy = get Client Proxy ( proxy Id ) ; if ( proxy != null ) { proxy . set Primary ( _ BOOL ) ; if ( is Client Ready || ! proxy . is Durable ( ) ) { if ( logger . is Debug Enabled ( ) ) { logger . debug ( _ STR , proxy ) ; } proxy . start Or Resume Message Dispatcher ( _ BOOL ) ; } } else { throw new  Internal Gem Fire Error ( _ STR + proxy Id ) ; } }
public static  String create Resource Name (  String resource ,  Locale locale , boolean remove Extension ) {  String resource Name = resource ; if ( remove Extension ) { if ( resource Name . ends With ( _ STR ) ) { resource Name = resource Name . replace ( _ STR , _ STR ) ; } else if ( resource Name . ends With ( _ STR ) ) { resource Name = resource Name . replace ( _ STR , _ STR ) ; } } if ( locale != null ) { if (  Util Validate . is Not Empty ( locale . to String ( ) ) ) { resource Name = resource Name + _ STR + locale ; } } return resource Name ; }
public static  List <  Container > create Container List ( int broker Id , int containers Number ) {  Array List <  Container > containers = new  Array List <  Container > ( ) ; for ( int i = _ NUM ; i < containers Number ; ++ i ) { int container Type = i / ( int )  Math . ceil ( ( double ) containers Number / _ NUM ) ; containers . add ( new  Power Container (  IDs . poll Id (  Container . class ) , broker Id , ( double )  Constants Examples .  CONTAINER_ MIPS [ container Type ] ,  Constants Examples .  CONTAINER_ PES [ container Type ] ,  Constants Examples .  CONTAINER_ RAM [ container Type ] ,  Constants Examples .  CONTAINER_ BW , _ NUM , _ STR , new  Container Cloudlet Scheduler Dynamic Workload (  Constants Examples .  CONTAINER_ MIPS [ container Type ] ,  Constants Examples .  CONTAINER_ PES [ container Type ] ) ,  Constants Examples .  SCHEDULING_ INTERVAL ) ) ; } return containers ; }
public static boolean is Local Resource Uri ( @  Nullable  Uri uri ) { final  String scheme = get Scheme Or Null ( uri ) ; return  LOCAL_ RESOURCE_ SCHEME . equals ( scheme ) ; }
public void add File (  String filename ,  String file Path ) { int path Index = file Path List . index Of ( file Path ) ; if ( path Index == - _ NUM ) { file Name List . add ( filename ) ; file Path List . add ( file Path ) ; } }
public void organization Config Changed (  String service Name ,  String version ,  String org Name ,  String group Name ,  String service Component , int type ) { if ( debug . message Enabled ( ) ) { debug . message ( _ STR + _ STR + service Name + _ STR + org Name + _ STR + group Name + _ STR + service Component + _ STR + type ) ; } if ( ( type ==  Service Listener .  REMOVED ) && ( service Component . length ( ) == _ NUM ) ) { remove Id Repo ( org Name ) ; } else if ( ( service Component . length ( ) != _ NUM ) && ! service Component . equals ( _ STR ) && ! service Component . equals ( _ STR ) ) {  String id Repo Name = null ;  String Tokenizer st = new  String Tokenizer ( service Component , _ STR ) ; if ( st . has More Tokens ( ) ) { id Repo Name = st . next Token ( ) ; } try { if ( type ==  Service Listener .  ADDED ) { add Id Repo ( org Name , id Repo Name ) ; } else if ( type ==  Service Listener .  MODIFIED ) { if ( !  Id Services Impl . is Shutdown Called ( ) ) { remove Id Repo ( org Name , id Repo Name , _ BOOL ) ; } else { remove Id Repo ( org Name , id Repo Name , _ BOOL ) ; } } else if ( type ==  Service Listener .  REMOVED ) { remove Id Repo ( org Name , id Repo Name , _ BOOL ) ; } } catch (  Exception e ) { debug . error ( _ STR + _ STR + service Name + _ STR + org Name + _ STR + group Name + _ STR + service Component + _ STR + type , e ) ; } } }
private boolean is Record Exists (  String table Name ,  String column Name ,  String check Condition ) {  String vendor = m_target . get Vendor ( ) ;  String catalog = m_target . get Catalog ( ) ;  String schema = m_target . get Schema ( ) ; boolean is Records Found = _ BOOL ;  Statement stmt = m_target . set Statement ( ) ;  String sql Command = s_db Engine . sql Action_check Record Exists ( vendor , catalog , schema , table Name , column Name , check Condition ) ;  Result Set rs = m_target . execute Query ( stmt , sql Command ) ; if ( m_target . get Result Set Next ( rs ) ) { int number Of Records = m_target . get Result Set Int ( rs , _ STR ) ; if ( number Of Records > _ NUM ) is Records Found = _ BOOL ; } m_target . release Result Set ( rs ) ; m_target . release Statement ( stmt ) ; return is Records Found ; }
public static byte [ ]  SHA1 ( final byte [ ] message , final int offset , final int length ) {  Message Digest digest ; try { digest =  Message Digest . get Instance ( _ STR ) ; digest . update ( message , offset , length ) ; final byte [ ] sha1 = digest . digest ( ) ; return sha1 ; } catch ( final  No Such Algorithm Exception e ) { if (  Cfg .  EXCEPTION ) {  Check . log ( e ) ; } } return null ; }
public static boolean rename File (  File input Path ,  File new File Path ) { if ( new File Path . exists ( ) ) {  Log . e (  TAG , _ STR + new File Path . get Absolute Path ( ) ) ; return _ BOOL ; } if ( input Path . is Directory ( ) ) {  Log . e (  TAG , _ STR + input Path . get Absolute Path ( ) ) ; return _ BOOL ; } if ( ! create Directory If Needed ( new File Path . get Absolute Path ( ) ) ) {  Log . e (  TAG , _ STR + new File Path . get Absolute Path ( ) ) ; return _ BOOL ; } return input Path . rename To ( new File Path ) ; }
public  Set create Sub Group Containers (  Set group Container Names ) throws  AMException ,  SSOException {  Iterator iter = group Container Names . iterator ( ) ;  Set group Containers = new  Hash Set ( ) ; while ( iter . has Next ( ) ) {  String group Container DN =  AMNaming Attr Manager . get Naming Attr (  GROUP_ CONTAINER ) + _ STR + ( (  String ) iter . next ( ) ) + _ STR + entry DN ;  AMGroup Container Impl group Container Impl = new  AMGroup Container Impl ( token , group Container DN ) ; group Container Impl . create ( ) ; group Containers . add ( group Container Impl ) ; } return group Containers ; }
private void test Count Messages In Mailbox ( ) throws  Exception {  LOG . info ( _ STR ) ; long message Count = message Mapper . count Messages In Mailbox (  MBOXES . get ( _ NUM ) ) ; assert Equals (  MESSAGE_ NO . size ( ) , message Count ) ; }
public  Scanner Exception (  Error Messages message ) { this ( null ,  Error Messages . get ( message ) , message , - _ NUM , - _ NUM ) ; }
@  Override public  V remove (  Object key ) { poll ( ) ; int index = _ NUM ;  Entry <  K ,  V > entry , last = null ; if ( key != null ) { index = (  Collections . secondary Hash ( key ) & _ NUM ) % element Data . length ; entry = element Data [ index ] ; while ( entry != null && ! key . equals ( entry . get ( ) ) ) { last = entry ; entry = entry . next ; } } else { entry = element Data [ _ NUM ] ; while ( entry != null && ! entry . is Null ) { last = entry ; entry = entry . next ; } } if ( entry != null ) { mod Count ++ ; if ( last == null ) { element Data [ index ] = entry . next ; } else { last . next = entry . next ; } element Count -- ; return entry . value ; } return null ; }
public  String query (  String handler ,  Solr Query Request req ) throws  Exception { try {  Solr Core core = req . get Core ( ) ;  Solr Query Response rsp = new  Solr Query Response ( ) ;  Solr Request Info . set Request Info ( new  Solr Request Info ( req , rsp ) ) ; core . execute ( core . get Request Handler ( handler ) , req , rsp ) ; if ( rsp . get Exception ( ) != null ) { throw rsp . get Exception ( ) ; }  String Writer sw = new  String Writer ( _ NUM ) ;  Query Response Writer response Writer = core . get Query Response Writer ( req ) ; response Writer . write ( sw , req , rsp ) ; return sw . to String ( ) ; } finally { req . close ( ) ;  Solr Request Info . clear Request Info ( ) ; } }
public void delete Active Links ( ) { if ( selected Link List . is Empty ( ) ) return ; for (  Link link : selected Link List ) { pair Node Node p = delete Link ( link ) ; diff Manager . save State ( diff Manager . clone Link ( link ) ,  Difference Manager . type .  DELETE , p . node1 , p . node2 , null , null , null , null , null , null ) ; active Link = null ; } selected Link List . clear ( ) ; controls . update Buttons ( ) ; active Link = null ; repaint ( ) ; }
public static  String join Punctuation Marks (  String line ) {  String result = line ; result = result . replace ( _ STR , _ STR ) ; result = result . replace ( _ STR , _ STR ) ; result = result . replace ( _ STR , _ STR ) ; result = result . replace ( _ STR , _ STR ) ; result = result . replace ( _ STR , _ STR ) ; result = result . replace ( _ STR , _ STR ) ; result = result . replace ( _ STR , _ STR ) ; result = result . replace ( _ STR , _ STR ) ; result = result . replace ( _ STR , _ STR ) ; result = result . replace ( _ STR , _ STR ) ; result = result . replace ( _ STR , _ STR ) ; result = result . replace ( _ STR , _ STR ) ; result = result . replace ( _ STR , _ STR ) ; result = result . replace ( _ STR , _ STR ) ; return result ; }
public  String Element add Element (  String element ) { add Element (  Integer . to String ( element . hash Code ( ) ) , element ) ; return ( this ) ; }
private float over Scroll Up ( int delta Y , int range ) { delta Y =  Math . max ( delta Y , _ NUM ) ; float current Top Amount = get Current Over Scroll Amount ( _ BOOL ) ; float new Top Amount = current Top Amount - delta Y ; if ( current Top Amount > _ NUM ) { set Over Scroll Amount ( new Top Amount , _ BOOL , _ BOOL ) ; } float scroll Amount = new Top Amount < _ NUM ? - new Top Amount : _ NUM ; float new Scroll Y = m Own Scroll Y + scroll Amount ; if ( new Scroll Y > range ) { if ( ! m Expanded In This Motion ) { float current Bottom Pixels = get Current Over Scrolled Pixels ( _ BOOL ) ; set Over Scrolled Pixels ( current Bottom Pixels + new Scroll Y - range , _ BOOL , _ BOOL ) ; } m Own Scroll Y = range ; scroll Amount = _ NUM ; } return scroll Amount ; }
private void delete Instance (  Entry Class eclass ) { int idx = entry Classes . index Of ( eclass ) ; if ( idx < _ NUM ) { return ; } eclass = entry Classes . get ( idx ) ; int num = eclass . get Num Instances ( ) - _ NUM ; if ( num == _ NUM ) entry Classes . remove ( idx ) ; eclass . set Num Instances ( num ) ; }
public  Warning create ( int limit ,  String message , boolean log All ) { final  Warning warning = new  Warning ( limit , message , log All ) ; m Warnings . add ( warning ) ; return warning ; }
public static  Byte Array List read As Bytes (  Input Stream is ) throws  IOException {  Byte Array List buf = new  Byte Array List ( ) ; byte [ ] b = new byte [ _ NUM ] ; int nread = - _ NUM ; while ( ( nread = is . read ( b ) ) >= _ NUM ) { buf . add ( b , _ NUM , nread ) ; } return buf ; }
public  Array Real Vector ( int size , double preset ) { data = new double [ size ] ;  Arrays . fill ( data , preset ) ; }
public static synchronized void register Transaction Service Plugin (  Transaction Service Plugin l ) { if ( service_ != null ) { service_ . add TSListener ( l ) ; } ts Listeners List_ . add ( l ) ; }
public void do Insertion Sort (  String [ ] names , int [ ] values ) { int i , j , t ;  String temp = _ STR ; for ( i = _ NUM ; i < values . length ; i ++ ) { j = i ; t = values [ j ] ; temp = names [ j ] ; while ( j > _ NUM && values [ j - _ NUM ] > t ) { values [ j ] = values [ j - _ NUM ] ; names [ j ] = names [ j - _ NUM ] ; j -- ; } values [ j ] = t ; names [ j ] = temp ; } }
public void add Session Listener (  Session Listener listener , boolean force ) throws  Session Exception { if ( ! force && session State !=  Session State .  VALID ) { throw new  Session Exception (  Session Bundle . rb Name , _ STR , null ) ; } local Session Event Listeners . add ( listener ) ; }
public void find And Init (  Object some Obj ) { if ( some Obj instanceof  Map Bean ) { set Map ( (  Map Bean ) some Obj ) ; } }
public void purge And Notify Removed Layers ( ) {  Array List <  Layer > r Layers = new  Array List <  Layer > ( removed Layers ) ; removed Layers . clear ( ) ; if ( r Layers . is Empty ( ) ) { return ; } for (  Layer layer : r Layers ) { layer . removed ( this ) ; } if (  Debug . debugging ( _ STR ) ) {  System . gc ( ) ; } }
private void write Object ( final  Object Output Stream oos ) throws  IOException { oos . default Write Object ( ) ; }
public int compare (  Object o1 ,  Object o2 ) { if ( o1 == null ) throw new  Illegal Argument Exception ( _ STR ) ; if ( o2 == null ) throw new  Illegal Argument Exception ( _ STR ) ;  MRf QResponse Line Qty q1 = null ;  MRf QResponse Line Qty q2 = null ; if ( o1 instanceof  MRf QResponse Line Qty ) q1 = (  MRf QResponse Line Qty ) o1 ; else throw new  Class Cast Exception ( _ STR ) ; if ( o2 instanceof  MRf QResponse Line Qty ) q2 = (  MRf QResponse Line Qty ) o2 ; else throw new  Class Cast Exception ( _ STR ) ; if ( ! q1 . is Valid Amt ( ) ) return - _ NUM ; if ( ! q2 . is Valid Amt ( ) ) return + _ NUM ;  Big Decimal net1 = q1 . get Net Amt ( ) ; if ( net1 == null ) return - _ NUM ;  Big Decimal net2 = q2 . get Net Amt ( ) ; if ( net2 == null ) return + _ NUM ; return net1 . compare To ( net2 ) ; }
private void bind Entity Id (  Class < ? > cls ,  String type ,  Accessible Object field Or Method ) {  String field Name = get Field Name ( field Or Method ) ;  Class < ? > field Type = get Field Type ( field Or Method ) ; fields To Types . put ( field Name , field Type ) ; id Field = field Or Method ; id Type = field Type ; id Field Name = field Name ; fields To Values . put ( field Name , field Or Method ) ; if ( id Field != null && ! field Or Method . equals ( id Field ) ) { throw new  Duplicate Mapping Exception ( type + _ STR + cls . get Name ( ) + _ STR + field Name ) ; } }
public static boolean addresses Are Equal (  String host1 ,  String host2 ) { try {  Host Address host1 Address = get By Name ( host1 ) ;  Host Address host2 Address = get By Name ( host2 ) ; byte [ ] host1 Raw = host1 Address . get Address ( ) ; byte [ ] host2 Raw = host2 Address . get Address ( ) ; for ( int octet = _ NUM ; octet < _ NUM ; octet ++ ) { if ( host1 Raw [ octet ] != host2 Raw [ octet ] ) return _ BOOL ; } return _ BOOL ; } catch (  Exception e ) {  CLUtils . println (  String . format ( _ STR , host1 , host2 , e ) ) ; return _ BOOL ; } }
public void remove Membership Listener (  Membership Listener listener ) { membership Listeners . remove ( listener ) ; }
public static  Uri add Message To Uri (  Content Resolver resolver ,  Uri uri ,  String address ,  String body ,  String subject ,  Long date , boolean read , boolean delivery Report ) { return add Message To Uri ( resolver , uri , address , body , subject , date , read , delivery Report , - _ NUM ) ; }
private void present ( ) { gl Use Program ( quad Program ) ; gl Bind Vertex Array ( vao ) ; gl Bind Texture (  GL_ TEXTURE_2 D , tex ) ; gl Bind Sampler ( _ NUM , this . sampler ) ; gl Draw Arrays (  GL_ TRIANGLES , _ NUM , _ NUM ) ; gl Bind Sampler ( _ NUM , _ NUM ) ; gl Bind Texture (  GL_ TEXTURE_2 D , _ NUM ) ; gl Bind Vertex Array ( _ NUM ) ; gl Use Program ( _ NUM ) ; }
public static  Calendar previous (  Calendar self ) {  Calendar result = (  Calendar ) self . clone ( ) ; result . add (  Calendar .  DAY_ OF_ YEAR , - _ NUM ) ; return result ; }
private void index Note Name (  Index Writer w ,  String note Id ,  String note Name ) throws  IOException {  LOG . debug ( _ STR , note Id , note Name ) ; if ( null == note Name || note Name . is Empty ( ) ) {  LOG . debug ( _ STR ) ; return ; } index Doc ( w , note Id , note Name , null ) ; }
public static <  T > void remove All (  List <  T > list ,  Integer ... indexes ) {  List <  Integer > inx = new  Array List < > (  Arrays . as List ( indexes ) ) ; remove All ( list , inx ) ; }
public  CFunction Selection Tree ( final  IDatabase database , final  IAction Provider action Provider ) {  Preconditions . check Not Null ( database , _ STR ) ;  Preconditions . check Not Null ( action Provider , _ STR ) ; final  Default Tree Model model = new  Default Tree Model ( null ) ; set Model ( model ) ; set Root Visible ( _ BOOL ) ; model . set Root ( new  CRoot Node ( database , model , action Provider ) ) ; set Cell Renderer ( new  Icon Node Renderer ( ) ) ; add Mouse Listener ( new  Internal Mouse Listener ( ) ) ; }
public static boolean is Primitive Type ( int type ) { return type != _ OBJECT && type != _ STRING ; }
public void clear Mods Already Requested (  String channel ) { if ( channel == null ) { mods Already Requested . clear ( ) ; } else { mods Already Requested . remove ( channel ) ; } }
public  Big Decimal invoke (  MDepreciation Workfile assetwk ,  MAsset Acct asset Acct , int  A_ Current_ Period ,  Big Decimal  Accum_ Dep ) {  String depreciation Type = get Depreciation Type ( ) ;  Big Decimal ret Value = null ; if (  CLog Mgt . is Level Finest ( ) ) { log . fine ( _ STR + depreciation Type + _ STR + assetwk + _ STR + asset Acct + _ STR +  A_ Current_ Period + _ STR +  Accum_ Dep ) ; } if ( ! can Invoke ( assetwk , asset Acct ,  A_ Current_ Period ,  Accum_ Dep ) ) { return  Big Decimal .  ZERO ; } if ( depreciation Type . equals Ignore Case ( _ STR ) ) { ret Value = apply_ SL ( assetwk , asset Acct ,  A_ Current_ Period ,  Accum_ Dep ) ; } else if ( depreciation Type . equals Ignore Case ( _ STR ) ) { ret Value = apply_ ARH_ VAR ( assetwk , asset Acct ,  A_ Current_ Period ,  Accum_ Dep ) ; } else if ( depreciation Type . equals Ignore Case ( _ STR ) ) { ret Value = apply_ ARH_ AD1 ( assetwk , asset Acct ,  A_ Current_ Period ,  Accum_ Dep ) ; } else if ( depreciation Type . equals Ignore Case ( _ STR ) ) { ret Value = apply_ ARH_ AD2 ( assetwk , asset Acct ,  A_ Current_ Period ,  Accum_ Dep ) ; } else if ( depreciation Type . equals Ignore Case ( _ STR ) ) { ret Value = apply_ ARH_ ZERO ( assetwk , asset Acct ,  A_ Current_ Period ,  Accum_ Dep ) ; } else { throw new  Asset Not Supported Exception (  COLUMNNAME_ Depreciation Type , depreciation Type ) ; } if ( ret Value == null ) { ret Value =  Big Decimal .  ZERO ; } ret Value = ret Value . set Scale ( get Precision ( ) ,  Rounding Mode .  HALF_ UP ) ; if (  CLog Mgt . is Level Finest ( ) ) log . fine ( _ STR + ret Value ) ; return ret Value ; }
@  Override public boolean contains (  Object value ) { if ( value == null ) { return _ BOOL ; } final  Iterator it = new  Step Iterator ( this , step Size ) ; while ( it . has Next ( ) ) { if ( compare Equal ( value , it . next ( ) ) ) { return _ BOOL ; } } return _ BOOL ; }
public synchronized void delete File (  JDBCSequential File file ) throws  SQLException { try { connection . set Auto Commit ( _ BOOL ) ; delete File . set Int ( _ NUM , file . get Id ( ) ) ; delete File . execute Update ( ) ; connection . commit ( ) ; } catch (  SQLException e ) { connection . rollback ( ) ; throw e ; } }
public  Input Stream read ( ) { return new  Byte Array Input Stream ( data ) ; }
protected static void fail ( int exit Code ) {  System . exit ( exit Code ) ; }
public void add ( final  Sensor sensor ) {  Set <  Sensor > old Selection = new  Hash Set <  Sensor > ( selection ) ; boolean rv = selection . add ( sensor ) ; if ( rv ) { fire Selection Changed ( old Selection , selection ) ; } }
@  Override public void visit Map Way (  Map Way way ) {  Default Entity View Info p Info = (  Default Entity View Info ) way . get View Info ( ) ;  List <  Map Node > nodes = get Way Nodes ( way ) ; if ( ! nodes . is Empty ( ) && p Info . way Color != null ) { if ( p Info . way Fill Color != null && nodes . get ( _ NUM ) == nodes . get ( nodes . size ( ) - _ NUM ) && ( way . is Area ( ) || ! p Info . fill Areas Only ) ) area Buffer . add ( way ) ; else way Buffer . add ( way ) ; } if ( p Info . is Way Icon && p Info . icon != null ) node Buffer . add ( way ) ; }
protected int store Reference (  Object obj ) { int new Ref Id = ref Id ++ ; ref Map . put (  Integer . value Of ( new Ref Id ) , obj ) ; return new Ref Id ; }
protected void pick Contained Vertices (  Visualization Viewer <  V ,  E > vv ,  Point2 D down ,  Point2 D out , boolean clear ) {  Layout <  V ,  E > layout = vv . get Graph Layout ( ) ;  Picked State <  V > picked Vertex State = vv . get Picked Vertex State ( ) ;  Rectangle2 D pick Rectangle = new  Rectangle2 D .  Double ( ) ; pick Rectangle . set Frame From Diagonal ( down , out ) ; if ( picked Vertex State != null ) { if ( clear ) { picked Vertex State . clear ( ) ; }  Graph Element Accessor <  V ,  E > pick Support = vv . get Pick Support ( ) ;  Collection <  V > picked = pick Support . get Vertices ( layout , pick Rectangle ) ; for (  V v : picked ) { picked Vertex State . pick ( v , _ BOOL ) ; } } }
public int hash Code ( ) { throw new  Unsupported Operation Exception ( _ STR ) ; }
public static  Search Pattern create And Pattern (  Search Pattern left Pattern ,  Search Pattern right Pattern ) { return new  And Pattern ( left Pattern , right Pattern ) ; }
public static  String validate Credit Card Number (  String credit Card Number ) { if ( credit Card Number == null || credit Card Number . length ( ) == _ NUM ) return _ STR ;  String cc Number1 = check Numeric ( credit Card Number ) ; int cc Length = cc Number1 . length ( ) ;  String Buffer buf = new  String Buffer ( ) ; for ( int i = cc Length ; i != _ NUM ; i -- ) buf . append ( cc Number1 . char At ( i - _ NUM ) ) ;  String cc Number = buf . to String ( ) ; int sum = _ NUM ; for ( int i = _ NUM ; i < cc Length ; i ++ ) { int digit =  Character . get Numeric Value ( cc Number . char At ( i ) ) ; if ( i % _ NUM == _ NUM ) { digit *= _ NUM ; if ( digit > _ NUM ) digit -= _ NUM ; } sum += digit ; } if ( sum % _ NUM == _ NUM ) return _ STR ; s_log . fine ( _ STR + credit Card Number + _ STR + cc Number + _ STR + sum ) ; return _ STR ; }
public static void unpack (  File source Zip , final  File target Dir ) throws  IOException {  Zip File zip File = null ; try { zip File = new  Zip File ( source Zip ) ;  Enumeration < ? extends  Zip Entry > entries Enum = zip File . entries ( ) ; while ( entries Enum . has More Elements ( ) ) { unpack Entry ( zip File , entries Enum . next Element ( ) , target Dir ) ; } } finally { try { if ( zip File != null ) { zip File . close ( ) ; } } catch (  IOException e ) { } } }
public  Xml Config Utils (  String file ) { this . file = file ; }
public  Text Component (  String text ) { this . text = text ; }
private void send Request Teardown ( ) throws  IOException {  String request = _ STR + m Parameters . host + _ STR + m Parameters . port + m Parameters . path + _ STR + add Headers ( ) ;  Log . i (  TAG , request . substring ( _ NUM , request . index Of ( _ STR ) ) ) ; m Output Stream . write ( request . get Bytes ( _ STR ) ) ; }
public static  Geo Time Serie fillprevious (  Geo Time Serie gts ) {  Geo Time Serie filled = gts . clone ( ) ; if ( ! is Bucketized ( filled ) ) { return filled ; } sort ( filled , _ BOOL ) ; int nticks = filled . values ; if ( _ NUM != nticks ) { long firsttick = filled . ticks [ _ NUM ] ; filled . set Size Hint ( _ NUM + ( int ) ( ( filled . lastbucket - firsttick ) / filled . bucketspan ) ) ; } int idx = _ NUM ; int bucketidx = filled . bucketcount - _ NUM ; long bucketts = filled . lastbucket - bucketidx * filled . bucketspan ;  Object prev Value = null ; long prev Location =  Geo Time Serie .  NO_ LOCATION ; long prev Elevation =  Geo Time Serie .  NO_ ELEVATION ; long bucketoffset = filled . lastbucket % filled . bucketspan ; while ( bucketidx >= _ NUM ) { while ( idx < nticks && bucketoffset != ( filled . ticks [ idx ] % filled . bucketspan ) ) { idx ++ ; } if ( idx >= nticks ) { break ; } while ( bucketidx >= _ NUM && filled . ticks [ idx ] > bucketts ) { if ( null != prev Value ) { set Value ( filled , bucketts , prev Location , prev Elevation , prev Value , _ BOOL ) ; } bucketidx -- ; bucketts = filled . lastbucket - bucketidx * filled . bucketspan ; } bucketidx -- ; bucketts = filled . lastbucket - bucketidx * filled . bucketspan ; prev Value = value At Index ( filled , idx ) ; prev Location = null != filled . locations ? filled . locations [ idx ] :  Geo Time Serie .  NO_ LOCATION ; prev Elevation = null != filled . elevations ? filled . elevations [ idx ] :  Geo Time Serie .  NO_ ELEVATION ; idx ++ ; } while ( bucketidx >= _ NUM ) { if ( null != prev Value ) { set Value ( filled , bucketts , prev Location , prev Elevation , prev Value , _ BOOL ) ; } bucketidx -- ; bucketts = filled . lastbucket - bucketidx * filled . bucketspan ; } return filled ; }
@  Override public boolean equals ( final  Object o ) { if ( this == o ) return _ BOOL ; if ( ! ( o instanceof  Header ) ) { return _ BOOL ; } return name . equals ( ( (  Header ) o ) . name ) ; }
public boolean wait For Wifi State ( int expected State , long timeout ) { long start Time =  System . current Time Millis ( ) ; while ( _ BOOL ) { if ( (  System . current Time Millis ( ) - start Time ) > timeout ) { if ( m Wifi State != expected State ) { return _ BOOL ; } else { return _ BOOL ; } }  Log . v (  LOG_ TAG , _ STR + expected State ) ; synchronized ( m Wifi Monitor ) { try { m Wifi Monitor . wait (  SHORT_ TIMEOUT ) ; } catch (  Interrupted Exception e ) { e . print Stack Trace ( ) ; } if ( m Wifi State != expected State ) {  Log . v (  LOG_ TAG , _ STR + m Wifi State ) ; continue ; } return _ BOOL ; } } }
@  Override public  String to String ( ) {  String Builder s = new  String Builder ( ) ; for (  Key key : this ) s . append ( key + _ STR ) ; return s . to String ( ) ; }
public void add Diagram Change Listener ( mx Diagram Change Listener listener ) { if ( diagram Change Listeners == null ) { diagram Change Listeners = new  Array List < mx Diagram Change Listener > ( ) ; } diagram Change Listeners . add ( listener ) ; }
private void notify Network Connectivity Change ( ) { synchronized ( m Connectivity Monitor ) {  Log . v (  LOG_ TAG , _ STR ) ; m Connectivity Monitor . notify All ( ) ; } }
public  String trim Char (  String str , final char ch ) {  Boolean b = _ BOOL , e = _ BOOL ; str = str . trim ( ) ; while ( str . length ( ) > _ NUM && ( b || e ) ) { if ( str . char At ( _ NUM ) == ch ) str = str . substring ( _ NUM , str . length ( ) ) ; else b = _ BOOL ; if ( str . char At ( str . length ( ) - _ NUM ) == ch ) str = str . substring ( _ NUM , str . length ( ) - _ NUM ) ; else e = _ BOOL ; } return str ; }
public static  String normalize (  String p ) { if ( p == null ) return _ STR ; if ( p . ends With ( _ STR ) && p . length ( ) > _ NUM ) return p . substring ( _ NUM , p . length ( ) - _ NUM ) ; return p ; }
void start Scrolling Instance ( ) { if ( log . is Loggable (  Platform Logger .  Level .  FINER ) ) { log . finer ( _ STR + this ) ; } scroll ( ) ; i_scroller . set Scrollbar ( this ) ; i_scroller . start ( ) ; }
public void start (  Stage stage ) throws  Exception { stage . set Scene ( new  Scene ( new  My Demo Pane ( ) ) ) ; stage . set Title ( _ STR ) ; stage . set Width ( _ NUM ) ; stage . set Height ( _ NUM ) ; stage . show ( ) ; }
public void remove Legend ( ) { remove ( plot Legend ) ; }
public void add (  Sub Range new Range ) { if ( new Range == null ) { return ; } for (  Sub Range range : data ) { if ( range . in Range ( new Range ) ) { return ; } } data . add ( new Range ) ; }
public static boolean is Solaris ( ) { return os Name . index Of ( _ STR ) > - _ NUM || os Name . index Of ( _ STR ) > - _ NUM ; }
public  DView Crl (  JFrame parent ,  String title ,  X509 CRL crl ) { super ( parent , title ,  Dialog .  Modality Type .  DOCUMENT_ MODAL ) ; this . crl = crl ; init Components ( ) ; }
public static  String remove Spaces ( final  String value ) { validate ( value ,  NULL_ STRING_ PREDICATE ,  NULL_ STRING_ MSG_ SUPPLIER ) ; return value . replace All ( _ STR , _ STR ) ; }
public synchronized void add Object (  Object obj ) { fifo . add Element ( obj ) ; nb Objects ++ ; notify All ( ) ; }
public void dispose ( ) { super . dispose ( ) ; }
public double distance_signed (  Pla Point Float p_point ) { double dx = point_b . v_x - point_a . v_x ; double dy = point_b . v_y - point_a . v_y ; double det = dy * ( p_point . v_x - point_a . v_x ) - dx * ( p_point . v_y - point_a . v_y ) ; double length =  Math . sqrt ( dx * dx + dy * dy ) ; return det / length ; }
public static void expand Real (  String number String ,  Word Relation word Relation ) { int string Length = number String . length ( ) ; int position ; if ( number String . char At ( _ NUM ) == _ STR ) { word Relation . add Word ( _ STR ) ; expand Real ( number String . substring ( _ NUM , string Length ) , word Relation ) ; } else if ( number String . char At ( _ NUM ) == _ STR ) { word Relation . add Word ( _ STR ) ; expand Real ( number String . substring ( _ NUM , string Length ) , word Relation ) ; } else if ( ( position = number String . index Of ( _ STR ) ) != - _ NUM || ( position = number String . index Of ( _ STR ) ) != - _ NUM ) { expand Real ( number String . substring ( _ NUM , position ) , word Relation ) ; word Relation . add Word ( _ STR ) ; expand Real ( number String . substring ( position + _ NUM ) , word Relation ) ; } else if ( ( position = number String . index Of ( _ STR ) ) != - _ NUM ) {  String before Dot = number String . substring ( _ NUM , position ) ; if ( before Dot . length ( ) > _ NUM ) { expand Real ( before Dot , word Relation ) ; } word Relation . add Word ( _ STR ) ;  String after Dot = number String . substring ( position + _ NUM ) ; if ( after Dot . length ( ) > _ NUM ) { expand Digits ( after Dot , word Relation ) ; } } else { expand Number ( number String , word Relation ) ; } }
public static final double [ ] to Double Array (  Instance x , int  L ) { double a [ ] = new double [  L ] ; for ( int i = _ NUM ; i <  L ; i ++ ) { a [ i ] =  Math . round ( x . value ( i ) ) ; } return a ; }
public void test Compute Location When Ejb Packaging ( ) throws  Exception {  Deployable deployable Element = new  Deployable ( ) ; deployable Element . set Group Id ( _ STR ) ; deployable Element . set Artifact Id ( _ STR ) ; deployable Element . set Type ( _ STR ) ;  String location = deployable Element . compute Location ( create Default Project ( _ STR , null ) ) ; assert True ( location . ends With ( _ STR ) ) ; }
public  Jdk14 Logger (  String name ) { this . jdk Logger =  Logger . get Logger ( name ) ; }
public static  Delete Sub Command Handler create (  Sub Command Argument Parser parser ,  Managed Object Path < ? , ? > p ,  Optional Relation Definition < ? , ? > r ) throws  Argument Exception { return new  Delete Sub Command Handler ( parser , p , r , p . child ( r ) ) ; }
public static int [ ] sort Values (  Matrix m ) { double [ ] v = new double [ m . get Column Dimension ( ) ] ; int [ ] index = new int [ v . length ] ; for ( int i = _ NUM ; i < v . length ; i ++ ) { v [ i ] = m . get ( i , i ) ; index [ i ] = i ; } for ( int i = _ NUM ; i < v . length ; i ++ ) { for ( int j = i + _ NUM ; j < v . length ; j ++ ) { if (  Math . abs ( v [ i ] ) <  Math . abs ( v [ j ] ) ) { double tmp Value = v [ j ] ; v [ j ] = v [ i ] ; v [ i ] = tmp Value ; int tmp Index = index [ j ] ; index [ j ] = index [ i ] ; index [ i ] = tmp Index ; } } } return index ; }
public  String to String (  Double Matrix3 D matrix ) {  String Buffer buf = new  String Buffer ( ) ; boolean old Print Shape = this . print Shape ; this . print Shape = _ BOOL ; for ( int slice = _ NUM ; slice < matrix . slices ( ) ; slice ++ ) { if ( slice != _ NUM ) buf . append ( slice Separator ) ; buf . append ( to String ( matrix . view Slice ( slice ) ) ) ; } this . print Shape = old Print Shape ; if ( print Shape ) buf . insert ( _ NUM , shape ( matrix ) + _ STR ) ; return buf . to String ( ) ; }
private void close ( ) { try { in . close ( ) ; } catch (  Exception e ) { } try { out . close ( ) ; } catch (  Exception e ) { } }
default  Map <  String ,  String > snapshot ( ) { final  Map <  String ,  String > map = new  Linked Hash Map < > ( ) ; for Each ( null ) ; return  Collections . unmodifiable Map ( map ) ; }
protected  Class < ? > resolve Proxy Class (  String [ ] interfaces ) throws  IOException ,  Class Not Found Exception {  Stream Checker checker = stream Checker ; if ( checker != null ) { checker . check Proxy Interface Names ( interfaces ) ; }  Object annotation = read Location ( ) ;  Class Loader default Loader = skip Default Resolve Class ? null : latest User Defined Loader ( ) ;  String codebase = null ; if ( ! use Codebase Only && annotation instanceof  String ) { codebase = (  String ) annotation ; } return  RMIClass Loader . load Proxy Class ( codebase , interfaces , default Loader ) ; }
@  Override public boolean is Inside (  Point point ) { return entity Rect . contains ( point . x , point . y ) ; }
public void append ( byte [ ] buffer , int offset , int length ) { if ( _length + length >= _capacity ) ensure Capacity ( _length + length ) ;  System . arraycopy ( buffer , offset , _buffer , _length , length ) ; _length += length ; }
void recompose Namespace Aliases (  Namespace Alias ns Alias ) { m_namespace Alias Composed . put ( ns Alias . get Stylesheet Namespace ( ) , ns Alias ) ; }
public  Atomic File (  File base Name ) { m Base Name = base Name ; m Backup Name = new  File ( base Name . get Path ( ) + _ STR ) ; }
protected void do Validate Int Contents (  String path ,  String filename , int start , int end ) {  File in File = new  File ( path , filename ) ;  Data Input Stream in Stream = null ;  Log . i (  LOG_ TAG , _ STR + filename + _ STR + path ) ; try { in Stream = new  Data Input Stream ( new  File Input Stream ( in File ) ) ; for ( int i = start ; i < end ; ++ i ) { if ( in Stream . read Int ( ) != i ) { fail ( _ STR ) ; } } if ( in Stream != null ) { in Stream . close ( ) ; }  Log . i (  LOG_ TAG , _ STR + filename ) ; } catch (  File Not Found Exception e ) { fail ( _ STR + in File + _ STR + e . to String ( ) ) ; } catch (  IOException e ) { fail ( _ STR + in File + _ STR + e . to String ( ) ) ; } }
public static  NBT_ Tag make (  Input Stream is ) throws  Exception {  NBT_ Tag ret = null ;  Data Input Stream stream = new  Data Input Stream ( is ) ; byte t = stream . read Byte ( ) ; int type = ( int ) t ;  String name = _ STR ; if ( type > _ NUM ) name = stream . read UTF ( ) ; switch ( type ) { case _ NUM : ret = new  TAG_ End ( name ) ; break ; case _ NUM : ret = new  TAG_ Byte ( name ) ; break ; case _ NUM : ret = new  TAG_ Short ( name ) ; break ; case _ NUM : ret = new  TAG_ Int ( name ) ; break ; case _ NUM : ret = new  TAG_ Long ( name ) ; break ; case _ NUM : ret = new  TAG_ Float ( name ) ; break ; case _ NUM : ret = new  TAG_ Double ( name ) ; break ; case _ NUM : ret = new  TAG_ Byte_ Array ( name ) ; break ; case _ NUM : ret = new  TAG_ String ( name ) ; break ; case _ NUM : ret = new  TAG_ List ( name ) ; break ; case _ NUM : ret = new  TAG_ Compound ( name ) ; break ; case _ NUM : ret = new  TAG_ Int_ Array ( name ) ; break ; default : throw ( new  Exception ( _ STR + type ) ) ; } ret . parse ( stream ) ; return ret ; }
public  Format Result apply Mask (  String mask ,  String value ,  String old Value ,  Integer cursor Index ) { if ( mask == null || value == null ) { return null ; } if ( old Value . length ( ) > value . length ( ) ) { return new  Format Result ( value , null ) ; } value = (  String ) get Mask Or Get Cursor Index ( mask , value , cursor Index , _ BOOL ) ; cursor Index = (  Integer ) get Mask Or Get Cursor Index ( mask , value , cursor Index , _ BOOL ) ; return new  Format Result ( value , cursor Index ) ; }
public  Effect Layer ( int duration ) { this . duration = duration ; timestamp =  System . current Time Millis ( ) ; }
protected boolean read Data Record ( int lon_index ) { try { if ( bin File == null ) { if ( ! reopen ( ) ) { return _ BOOL ; } } bin File . seek (  UHL_ SIZE +  DSI_ SIZE +  ACC_ SIZE + ( lon_index * ( _ NUM + ( _ NUM * uhl . num_lat_points ) ) ) ) ; bin File . read ( ) ; bin File . skip Bytes ( _ NUM ) ; bin File . read Short ( ) ; bin File . read Short ( ) ; elevations [ lon_index ] = new short [ uhl . num_lat_points ] ; for ( int j = _ NUM ; j < uhl . num_lat_points ; j ++ ) { elevations [ lon_index ] [ j ] = bin File . read Short Data ( ) ; } } catch (  IOException e3 ) {  Debug . error ( _ STR ) ; e3 . print Stack Trace ( ) ; elevations [ lon_index ] = null ; return _ BOOL ; } catch (  Format Exception f ) {  Debug . error ( _ STR ) ; elevations [ lon_index ] = null ; return _ BOOL ; } return _ BOOL ; }
protected void update (  OMGraphic List list ,  Projection proj ) {  Buffered Image current Image Buffer = null ; if ( proj != null && layer != null ) { int w = proj . get Width ( ) ; int h = proj . get Height ( ) ; current Image Buffer = get Image Buffer ( ) ;  Buffered Image buffered Image = scrub Or Get New Buffered Image ( current Image Buffer , w , h ) ; if ( buffered Image != null ) { if ( current Image Buffer != null ) { current Image Buffer . flush ( ) ; } current Image Buffer = buffered Image ; }  Graphics2 D g2d = (  Graphics2 D ) current Image Buffer . get Graphics ( ) ; set Rendering Hints ( g2d ) ; if ( list != null ) { list . render ( g2d ) ; } g2d . dispose ( ) ; set Image Raster ( update Raster ( current Image Buffer , proj ) ) ; } set Image Buffer ( current Image Buffer ) ; current Projection = proj ; }
@  Override public int compare To (  Scout Widget scout Widget ) { if ( m Parent == null ) { return - _ NUM ; } if ( m Root Distance != scout Widget . m Root Distance ) { return  Float . compare ( m Root Distance , scout Widget . m Root Distance ) ; } if ( m Y != scout Widget . m Y ) { return  Float . compare ( m Y , scout Widget . m Y ) ; } if ( m X != scout Widget . m X ) { return  Float . compare ( m X , scout Widget . m X ) ; } return _ NUM ; }
