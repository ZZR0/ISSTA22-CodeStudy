protected boolean [ ] dataset Integrity ( boolean nominal Predictor , boolean numeric Predictor , boolean string Predictor , boolean date Predictor , boolean relational Predictor , boolean multi Instance , int class Type , boolean predictor Missing , boolean class Missing ) { print ( _ STR ) ; print Attribute Summary ( nominal Predictor , numeric Predictor , string Predictor , date Predictor , relational Predictor , multi Instance , class Type ) ; print ( _ STR ) ; int num Train = get Num Instances ( ) , num Test = get Num Instances ( ) , num Classes = _ NUM , missing Level = _ NUM ; boolean [ ] result = new boolean [ _ NUM ] ;  Instances train = null ;  Instances test = null ;  Classifier classifier = null ;  Evaluation evaluation = null ; boolean built = _ BOOL ; try { train = make Test Dataset ( _ NUM , num Train , nominal Predictor ? get Num Nominal ( ) : _ NUM , numeric Predictor ? get Num Numeric ( ) : _ NUM , string Predictor ? get Num String ( ) : _ NUM , date Predictor ? get Num Date ( ) : _ NUM , relational Predictor ? get Num Relational ( ) : _ NUM , num Classes , class Type , multi Instance ) ; test = make Test Dataset ( _ NUM , num Test , nominal Predictor ? get Num Nominal ( ) : _ NUM , numeric Predictor ? get Num Numeric ( ) : _ NUM , string Predictor ? get Num String ( ) : _ NUM , date Predictor ? get Num Date ( ) : _ NUM , relational Predictor ? get Num Relational ( ) : _ NUM , num Classes , class Type , multi Instance ) ; if ( missing Level > _ NUM ) { add Missing ( train , missing Level , predictor Missing , class Missing ) ; add Missing ( test ,  Math . min ( missing Level , _ NUM ) , predictor Missing , class Missing ) ; } classifier =  Abstract Classifier . make Copies ( get Classifier ( ) , _ NUM ) [ _ NUM ] ; evaluation = new  Evaluation ( train ) ; } catch (  Exception ex ) { throw new  Error ( _ STR + ex . get Message ( ) ) ; } try {  Instances train Copy = new  Instances ( train ) ;  Instances test Copy = new  Instances ( test ) ; classifier . build Classifier ( train Copy ) ; compare Datasets ( train , train Copy ) ; built = _ BOOL ; test WRTZero R ( classifier , evaluation , train Copy , test Copy ) ; compare Datasets ( test , test Copy ) ; println ( _ STR ) ; result [ _ NUM ] = _ BOOL ; } catch (  Exception ex ) { println ( _ STR ) ; result [ _ NUM ] = _ BOOL ; if ( m_ Debug ) { println ( _ STR ) ; print ( _ STR ) ; if ( built ) { print ( _ STR ) ; } else { print ( _ STR ) ; } println ( _ STR + ex . get Message ( ) + _ STR ) ; println ( _ STR ) ; println ( _ STR + train . to String ( ) + _ STR ) ; println ( _ STR + test . to String ( ) + _ STR ) ; } } return result ; }
public static int intersection Size ( long [ ] x , long [ ] y ) { final int lx = x . length , ly = y . length ; final int min = ( lx < ly ) ? lx : ly ; int res = _ NUM ; for ( int i = _ NUM ; i < min ; i ++ ) { res +=  Long . bit Count ( x [ i ] & y [ i ] ) ; } return res ; }
public void test Reverse Order2 ( ) throws  Exception {  UUID id =  UUID . random UUID ( ) ;  Grid Cache Adapter <  String ,  String > cache = grid . internal Cache ( ) ;  Grid Cache Context <  String ,  String > ctx = cache . context ( ) ;  Grid Cache Test Entry Ex entry1 = new  Grid Cache Test Entry Ex ( ctx , _ STR ) ;  Grid Cache Test Entry Ex entry2 = new  Grid Cache Test Entry Ex ( ctx , _ STR ) ;  Grid Cache Version ver1 = version ( _ NUM ) ;  Grid Cache Version ver2 = version ( _ NUM ) ;  Grid Cache Version ver3 = version ( _ NUM ) ;  Grid Cache Mvcc Candidate v3k1 = entry1 . add Local ( _ NUM , ver3 , _ NUM , _ BOOL , _ BOOL ) ;  Grid Cache Mvcc Candidate v3k2 = entry2 . add Local ( _ NUM , ver3 , _ NUM , _ BOOL , _ BOOL ) ; link Candidates ( ctx , v3k1 , v3k2 ) ; entry1 . ready Local ( v3k1 ) ; check Local ( v3k1 , ver3 , _ BOOL , _ BOOL , _ BOOL ) ; check Local ( v3k2 , ver3 , _ BOOL , _ BOOL , _ BOOL ) ;  Grid Cache Mvcc Candidate v2k1 = entry1 . add Remote ( id , _ NUM , ver2 , _ NUM , _ BOOL , _ BOOL ) ;  Grid Cache Mvcc Candidate v2k2 = entry2 . add Remote ( id , _ NUM , ver2 , _ NUM , _ BOOL , _ BOOL ) ; check Remote ( v2k1 , ver2 , _ BOOL , _ BOOL ) ; check Remote ( v2k2 , ver2 , _ BOOL , _ BOOL ) ;  Grid Cache Mvcc Candidate v1k1 = entry1 . add Local ( _ NUM , ver1 , _ NUM , _ BOOL , _ BOOL ) ;  Grid Cache Mvcc Candidate v1k2 = entry2 . add Local ( _ NUM , ver1 , _ NUM , _ BOOL , _ BOOL ) ; link Candidates ( ctx , v1k1 , v1k2 ) ; entry1 . ready Local ( v1k1 ) ; entry2 . ready Local ( v1k2 ) ; check Local ( v1k1 , ver1 , _ BOOL , _ BOOL , _ BOOL ) ; check Local ( v1k2 , ver1 , _ BOOL , _ BOOL , _ BOOL ) ; check Local ( v3k2 , ver3 , _ BOOL , _ BOOL , _ BOOL ) ; entry2 . ready Local ( v3k2 ) ; check Local ( v3k2 , ver3 , _ BOOL , _ BOOL , _ BOOL ) ; check Local ( v1k1 , ver1 , _ BOOL , _ BOOL , _ BOOL ) ; check Local ( v1k2 , ver1 , _ BOOL , _ BOOL , _ BOOL ) ; }
protected void initialize ( ) {  List <  Add User Fields .  Attribute Spec > specs = m_filter . get Attribute Specs ( ) ; m_list Model = new  Default List Model ( ) ; m_list . set Model ( m_list Model ) ; if ( specs . size ( ) > _ NUM ) { m_up But . set Enabled ( _ BOOL ) ; m_down But . set Enabled ( _ BOOL ) ; for (  Add User Fields .  Attribute Spec s : specs ) {  Add User Fields .  Attribute Spec spec Copy = new  Add User Fields .  Attribute Spec ( s . to String Internal ( ) ) ; m_list Model . add Element ( spec Copy ) ; } m_list . repaint ( ) ; } else { m_name Field . set Enabled ( _ BOOL ) ; m_type Field . set Enabled ( _ BOOL ) ; m_date Format Field . set Enabled ( _ BOOL ) ; m_value Field . set Enabled ( _ BOOL ) ; } }
public  String attributes To String ( ) {  String Buffer text = new  String Buffer ( ) ; int j = _ NUM ; for ( int i = _ NUM ; i < m_attributes . length ; i ++ ) { if ( m_attributes [ i ] ) { if ( is Gaussian ( ) ) { text . append ( _ STR + i ) ; text . append ( _ STR + m_mean Value [ j ] ) ; text . append ( _ STR + m_stddev Value [ j ] + _ STR ) ; } else { text . append ( _ STR + i ) ; text . append ( _ STR + m_min Value [ j ] ) ; text . append ( _ STR + m_max Value [ j ] + _ STR ) ; } j ++ ; } } return text . to String ( ) ; }
public static double remainder ( final double dividend , final double divisor ) { if (  Double . is Infinite ( divisor ) ) { if (  Double . is Infinite ( dividend ) ) { return  Double .  Na N ; } else { return dividend ; } } final double value = dividend % divisor ; if (  Math . abs ( value + value ) >  Math . abs ( divisor ) ) { return value + ( value > _ NUM ? -  Math . abs ( divisor ) :  Math . abs ( divisor ) ) ; } else { return value ; } }
protected  Range find Domain Bounds (  XYDataset dataset , boolean include Interval ) { if ( dataset == null ) { return null ; } if ( get Data Bounds Includes Visible Series Only ( ) ) {  List visible Series Keys = new  Array List ( ) ; int series Count = dataset . get Series Count ( ) ; for ( int s = _ NUM ; s < series Count ; s ++ ) { if ( is Series Visible ( s ) ) { visible Series Keys . add ( dataset . get Series Key ( s ) ) ; } } return  Dataset Utilities . find Domain Bounds ( dataset , visible Series Keys , include Interval ) ; } return  Dataset Utilities . find Domain Bounds ( dataset , include Interval ) ; }
@  Override public boolean on Schedule (  Packing Plan packing ) {  LOG . info ( _ STR +  Local Context . topology Name ( config ) ) ; synchronized ( process To Container ) {  LOG . info ( _ STR ) ; start Executor ( _ NUM ) ; for (  Packing Plan .  Container Plan container : packing . get Containers ( ) ) { start Executor ( container . get Id ( ) ) ; } }  LOG . info ( _ STR ) ; return _ BOOL ; }
public static boolean is String Or Similar Type (  Type type ) { if ( type instanceof  Ref Type ) {  Ref Type ref Type = (  Ref Type ) type ; return ref Type . equals (  Ref Type . v ( _ STR ) ) || ref Type . equals (  Ref Type . v ( _ STR ) ) || ref Type . equals (  Ref Type . v ( _ STR ) ) || ref Type . equals (  Ref Type . v ( _ STR ) ) ; } return _ BOOL ; }
public  Entry create Root (  User user ,  String id ,  String type ,  String notebook Id ,  Long mod Time ,  Long create Time ,  Errors errors ) { if ( user == null ) {  Errors . add ( errors , error Messages . error User Is Null ( ) ) ; return null ; } if ( mod Time == null ) {  Errors . add ( errors , error Messages . error Mod Time Is Null ( ) ) ; return null ; } if ( create Time == null ) {  Errors . add ( errors , error Messages . error Create Time Is Null ( ) ) ; return null ; } if ( id != null && ! id Generator . is Id Well Formed ( id ) ) {  Errors . add ( errors , error Messages . error Id Is Invalid ( ) ) ; return null ; } if ( notebook Id != null && ! id Generator . is Id Well Formed ( notebook Id ) ) {  Errors . add ( errors , error Messages . error Notebook Id Is Invalid ( ) ) ; return null ; } if ( create Time . long Value ( ) > mod Time . long Value ( ) ) { mod Time = create Time ; }  Entry root = new  Entry ( ) ; root . set Db ( db ) ; if ( id == null ) { id = id Generator . get Another Id ( ) ; } root . set Id ( id ) ; root . set Create Time ( create Time ) ; root . set Mod Time ( mod Time ) ; root . set Type ( type ) ; root . set User Id ( user . get Id ( ) ) ; root . set Notebook Id ( notebook Id ) ; db . persist Entry ( root ) ; return root ; }
public int update (  String table ,  Content Values values ,  String where Clause ,  String [ ] where Args ) { verify Db Is Open ( ) ; if ( values == null || values . size ( ) == _ NUM ) { throw new  Illegal Argument Exception ( _ STR ) ; }  String Builder sql = new  String Builder ( _ NUM ) ; sql . append ( _ STR ) ; sql . append ( table ) ; sql . append ( _ STR ) ; int set Values Size = values . size ( ) ; int bind Args Size = ( where Args == null ) ? set Values Size : ( set Values Size + where Args . length ) ;  Object [ ] bind Args = new  Object [ bind Args Size ] ; int i = _ NUM ; for (  String col Name : values . key Set ( ) ) { sql . append ( ( i > _ NUM ) ? _ STR : _ STR ) ; sql . append ( col Name ) ; bind Args [ i ++ ] = values . get ( col Name ) ; sql . append ( _ STR ) ; } if ( where Args != null ) { for ( i = set Values Size ; i < bind Args Size ; i ++ ) { bind Args [ i ] = where Args [ i - set Values Size ] ; } } if ( !  String Utils . is Empty ( where Clause ) ) { sql . append ( _ STR ) ; sql . append ( where Clause ) ; } return execute Sql ( sql . to String ( ) , bind Args ) ; }
public static  Integer [ ] values Of ( int [ ] array ) {  Integer [ ] dest = new  Integer [ array . length ] ; for ( int i = _ NUM ; i < array . length ; i ++ ) { dest [ i ] =  Integer . value Of ( array [ i ] ) ; } return dest ; }
@  Override public void trace (  String msg ) { if ( logger . is Loggable (  Level .  FINEST ) ) { log (  SELF ,  Level .  FINEST , msg , null ) ; } }
public static  Player create Player (  String type , char mark ) {  Player player = null ; if ( type . equals (  Random ) ) { player = new  Random Player ( mark ) ; } else { return null ; } player . score ( new  Board Evaluation ( ) ) ; return player ; }
public  Base Matcher ( final  Network Config config ) { if ( config == null ) { throw new  Null Pointer Exception ( _ STR ) ; } else { this . config = config ; } }
public void denormalize ( int min Level , int level Mod ,  Array List <  S2 Cell Id > output ) { output . clear ( ) ; output . ensure Capacity ( size ( ) ) ; for (  S2 Cell Id id : this ) { int level = id . level ( ) ; int new Level =  Math . max ( min Level , level ) ; if ( level Mod > _ NUM ) { new Level += (  S2 Cell Id .  MAX_ LEVEL - ( new Level - min Level ) ) % level Mod ; new Level =  Math . min (  S2 Cell Id .  MAX_ LEVEL , new Level ) ; } if ( new Level == level ) { output . add ( id ) ; } else {  S2 Cell Id end = id . child End ( new Level ) ; for ( id = id . child Begin ( new Level ) ; ! id . equals ( end ) ; id = id . next ( ) ) { output . add ( id ) ; } } } }
synchronized  String create Local Id ( ) { long local Id Number = random . next Long ( ) ;  String local Id = _ STR +  Long . to Hex String ( local Id Number ) ; if ( ! is Local Id ( local Id ) ) { throw new  Illegal State Exception ( _ STR + local Id + _ STR + _ STR ) ; } return local Id ; }
public static void w (  String msg ,  Object ... args ) { if ( ! allow W ) return ;  Stack Trace Element caller = get Caller Stack Trace Element ( ) ;  String tag = generate Tag ( caller ) ; if ( s Level >  LEVEL_ WARNING ) { return ; } if ( args . length > _ NUM ) { msg =  String . format ( msg , args ) ; }  Log . w ( tag , msg ) ; }
public void add Leaf (  String name ,  String path ) {  Named Icon icon =  Named Icon . get Icon By Name ( path ) ; if ( icon == null ) { log . warn ( _ STR + path + _ STR ) ; return ; } int h = icon . get Icon Height ( ) ; for ( int i = _ NUM ; i < _leaves . size ( ) ; i ++ ) {  Catalog Tree Leaf leaf = _leaves . get ( i ) ; if ( h < leaf . get Size ( ) ) { _leaves . add ( i + _ NUM , new  Catalog Tree Leaf ( name , path , h ) ) ; return ; } } _leaves . add ( new  Catalog Tree Leaf ( name , path , h ) ) ; }
public void debug_stack ( ) {  String Buffer sb = new  String Buffer ( _ STR ) ; for ( int i = _ NUM ; i < stack . size ( ) ; i ++ ) {  Symbol s = (  Symbol ) stack . element At ( i ) ; sb . append ( _ STR + s . parse_state + _ STR + s . sym + _ STR ) ; if ( ( i % _ NUM ) == _ NUM || ( i == ( stack . size ( ) - _ NUM ) ) ) { debug_message ( sb . to String ( ) ) ; sb = new  String Buffer ( _ STR ) ; } } }
protected boolean prevalidate ( final  String component , final  Bit Set disallowed ) { if ( component == null ) { return _ BOOL ; } final char [ ] target = component . to Char Array ( ) ; for ( int i = _ NUM ; i < target . length ; i ++ ) { if ( disallowed . get ( target [ i ] ) ) { return _ BOOL ; } } return _ BOOL ; }
public void add Shutdown Hook (  Thread hook ) {  Security Manager sm =  System . get Security Manager ( ) ; if ( sm != null ) { sm . check Permission (  Runtime Permission Collection .  SHUTDOWN_ HOOKS_ PERMISSION ) ; } if ( hook == null ) throw new  Null Pointer Exception ( _ STR ) ; if ( hook . get State ( ) !=  Thread .  State .  NEW ) { throw new  Illegal Argument Exception ( ) ; } if (  VMState > _ NUM ) { throw new  Illegal State Exception ( ) ; } synchronized ( hooks List ) { if ( hooks List . contains ( hook ) ) { throw new  Illegal Argument Exception ( ) ; } hooks List . add ( hook ) ; } }
@  Override public void run ( ) { try { while ( alive ) { try { packet . set Length ( buffer . length ) ; socket . receive ( packet ) ;  String s = string From Packet ( packet ) ; try {  Thread . sleep ( _ NUM ) ; } catch (  Interrupted Exception ex ) { } string To Packet ( s . to Upper Case ( ) , packet ) ; packet . set Address (  Inet Address . get Local Host ( ) ) ; packet . set Port ( _ NUM ) ; socket . send ( packet ) ; } catch ( java . io .  Interrupted IOException e ) { } } } catch ( java . io .  IOException ex ) { ex . print Stack Trace ( ) ; } finally { socket . close ( ) ; } }
public boolean bound Scroll Raw ( ) { float cur Scroll = get Stack Scroll ( ) ; float new Scroll = get Bounded Stack Scroll ( cur Scroll ) ; if (  Float . compare ( new Scroll , cur Scroll ) != _ NUM ) { set Stack Scroll Raw ( new Scroll ) ; return _ BOOL ; } return _ BOOL ; }
protected boolean [ ] dataset Integrity ( boolean nominal Predictor , boolean numeric Predictor , boolean string Predictor , boolean date Predictor , boolean relational Predictor , boolean multi Instance , int class Type , boolean predictor Missing , boolean class Missing ) { print ( _ STR ) ; print Attribute Summary ( nominal Predictor , numeric Predictor , string Predictor , date Predictor , relational Predictor , multi Instance , class Type ) ; print ( _ STR ) ; int num Train = get Num Instances ( ) , num Test = get Num Instances ( ) , num Classes = _ NUM , missing Level = _ NUM ; boolean [ ] result = new boolean [ _ NUM ] ;  Instances train = null ;  Instances test = null ;  Classifier classifier = null ;  Evaluation evaluation = null ; boolean built = _ BOOL ; try { train = make Test Dataset ( _ NUM , num Train , nominal Predictor ? get Num Nominal ( ) : _ NUM , numeric Predictor ? get Num Numeric ( ) : _ NUM , string Predictor ? get Num String ( ) : _ NUM , date Predictor ? get Num Date ( ) : _ NUM , relational Predictor ? get Num Relational ( ) : _ NUM , num Classes , class Type , multi Instance ) ; test = make Test Dataset ( _ NUM , num Test , nominal Predictor ? get Num Nominal ( ) : _ NUM , numeric Predictor ? get Num Numeric ( ) : _ NUM , string Predictor ? get Num String ( ) : _ NUM , date Predictor ? get Num Date ( ) : _ NUM , relational Predictor ? get Num Relational ( ) : _ NUM , num Classes , class Type , multi Instance ) ; if ( missing Level > _ NUM ) { add Missing ( train , missing Level , predictor Missing , class Missing ) ; add Missing ( test ,  Math . min ( missing Level , _ NUM ) , predictor Missing , class Missing ) ; } classifier =  Abstract Classifier . make Copies ( get Classifier ( ) , _ NUM ) [ _ NUM ] ; evaluation = new  Evaluation ( train ) ; } catch (  Exception ex ) { throw new  Error ( _ STR + ex . get Message ( ) ) ; } try {  Instances train Copy = new  Instances ( train ) ;  Instances test Copy = new  Instances ( test ) ; classifier . build Classifier ( train Copy ) ; compare Datasets ( train , train Copy ) ; built = _ BOOL ; test WRTZero R ( classifier , evaluation , train Copy , test Copy ) ; compare Datasets ( test , test Copy ) ; println ( _ STR ) ; result [ _ NUM ] = _ BOOL ; } catch (  Exception ex ) { println ( _ STR ) ; result [ _ NUM ] = _ BOOL ; if ( m_ Debug ) { println ( _ STR ) ; print ( _ STR ) ; if ( built ) { print ( _ STR ) ; } else { print ( _ STR ) ; } println ( _ STR + ex . get Message ( ) + _ STR ) ; println ( _ STR ) ; println ( _ STR + train . to String ( ) + _ STR ) ; println ( _ STR + test . to String ( ) + _ STR ) ; } } return result ; }
public  Disk Request add New Request (  Disk Request request ) throws  Interrupted Exception { if ( ! is Active ( request . time ) ) set Starting Weight ( request . time ) ; limiter . acquire ( request . estimated Cost ) ; pending . add ( request ) ; return request ; }
protected void process Start Arg ( final  String key , final  String value , final  Map <  String ,  Object > options , final  List <  String > vm Args , final  Properties props ) throws  Exception { props . set Property ( key , value ) ; }
public static  JSONObject read JSONObject ( final  JSONObject json Object , final  String key , final boolean required , final boolean not Null ) throws  JSONException { if ( required ) { return json Object . get JSONObject ( key ) ; } if ( not Null && json Object . is Null ( key ) ) { throw new  JSONException (  String . format (  Locale .  US ,  NULL_ VALUE_ FORMAT_ OBJECT , key ) ) ; }  JSONObject value = null ; if ( ! json Object . is Null ( key ) ) { value = json Object . get JSONObject ( key ) ; } return value ; }
public void paint ( final  Graphics g ) { g . draw Image ( image , _ NUM , _ NUM , this ) ; synchronized ( this ) { if ( ! paint Called ) { paint Called = _ BOOL ; notify All ( ) ; } } }
@  Override public boolean connection Allowed (  String event Name ) { if ( m_listenees . contains Key ( event Name ) ) { return _ BOOL ; } if ( m_listenees . contains Key ( _ STR ) && ( event Name . compare To ( _ STR ) == _ NUM || event Name . compare To ( _ STR ) == _ NUM || event Name . compare To ( _ STR ) == _ NUM ) ) { return _ BOOL ; } if ( ( m_listenees . contains Key ( _ STR ) || m_listenees . contains Key ( _ STR ) ) && ( event Name . compare To ( _ STR ) == _ NUM || event Name . compare To ( _ STR ) == _ NUM ) ) { return _ BOOL ; } if ( m_listenees . contains Key ( _ STR ) && ( event Name . compare To ( _ STR ) == _ NUM || event Name . compare To ( _ STR ) == _ NUM || event Name . compare To ( _ STR ) == _ NUM ) ) { return _ BOOL ; } if ( event Name . compare To ( _ STR ) == _ NUM && ! ( m_ Filter instanceof  Streamable Filter ) ) { return _ BOOL ; } return _ BOOL ; }
public boolean is Prefixed ( ) { return tag . index Of ( _ STR ) >= _ NUM ; }
protected void close (  Connection connection ,  Statement statement ,  Result Set result Set ) { try { if ( result Set != null ) { result Set . close ( ) ; } } catch (  SQLException ex ) {  LOGGER . error ( _ STR , ex ) ; } try { if ( statement != null ) { statement . close ( ) ; } } catch (  SQLException ex ) {  LOGGER . error ( _ STR , ex ) ; } try { if ( connection != null ) { connection . close ( ) ; } } catch (  SQLException ex ) {  LOGGER . error ( _ STR , ex ) ; } }
public  Notifications action (  Action ... actions ) { this . actions = actions == null ?  FXCollections . <  Action > observable Array List ( ) :  FXCollections . observable Array List ( actions ) ; return this ; }
@  Safe Varargs protected <  T extends  Abstract Option Value < ? , ? > >  Abstract Options (  Function <  T ,  T > value Filter ,  Abstract Options base Options ,  T ... values ) { require Non Null ( base Options , _ STR ) ; require Non Null ( value Filter , _ STR ) ; require Non Null ( values , _ STR ) ; value Map = new  Identity Hash Map < > ( base Options . value Map ) ; put All ( value Filter ,  Stream . of ( values ) ) ; }
public int compare To Ignore Case (  Char Seq another ) { return str . compare To Ignore Case ( another . str ) ; }
@  Suppress Warnings ( _ STR ) public static boolean check ETag Validators ( final  Http Servlet Request req , final  Http Servlet Response resp , final  Method req Method , final  String etag ) { final  List <  String > if None Match List =  Collections . list ( req . get Headers ( _ STR ) ) ; if ( if None Match List . size ( ) > _ NUM && is Matching Etag ( if None Match List , etag ) ) { if ( req Method ==  Method .  GET || req Method ==  Method .  HEAD ) { send Not Modified ( resp ) ; } else { send Precondition Failed ( resp ) ; } return _ BOOL ; } final  List <  String > if Match List =  Collections . list ( req . get Headers ( _ STR ) ) ; if ( if Match List . size ( ) > _ NUM && ! is Matching Etag ( if Match List , etag ) ) { send Precondition Failed ( resp ) ; return _ BOOL ; } return _ BOOL ; }
protected boolean compare And Set State (  State Type old State ,  State Type new State ) { if ( state . compare And Set ( old State , new State ) ) { after State Changed ( new State ) ; return _ BOOL ; } else return _ BOOL ; }
private void format And Log Throwable (  Logging Level level ,  String msg ,  Throwable t ) { if (  Photon Logger . level . id < level . id ) { return ; }  Local Date Time date Time =  Local Date Time . now ( ) ;  String formatted = format Log Line ( level , date Time , msg ) ;  Logging Service . log Throwable ( date Time , t , formatted ) ; }
public static  String construct Jobs Table Name (  String queue Name ,  String shard Name , int priority ) { return  String . format ( _ STR , construct DBName ( queue Name , shard Name ) , priority ) ; }
public static boolean is Ascii (  String s ) { if ( s == null ) { return _ BOOL ; } try { if ( ! s . equals ( new  String ( s . get Bytes (  ASCII_ CHARSET ) ,  ASCII_ CHARSET ) ) ) { return _ BOOL ; } } catch ( java . io .  Unsupported Encoding Exception uee ) { return _ BOOL ; } return _ BOOL ; }
public void add Permitted Domain (  String domain Name ) { if (  String Utils . is Empty ( domain Name ) ) { return ; } if ( permitted Domains == null ) { permitted Domains = new  Array List < > ( ) ; } permitted Domains . add ( domain Name ) ; }
public  Stoppable Write Lock (  Read Write Lock lock ,  Cancel Criterion stopper ) { this . lock = lock . write Lock ( ) ; this . stopper = stopper ; }
private long compute Method Hash ( ) { long hash = _ NUM ;  Byte Array Output Stream sink = new  Byte Array Output Stream ( _ NUM ) ; try {  Message Digest md =  Message Digest . get Instance ( _ STR ) ;  Data Output Stream out = new  Data Output Stream ( new  Digest Output Stream ( sink , md ) ) ;  String method String = name And Descriptor ( ) ; out . write UTF ( method String ) ; out . flush ( ) ; byte hash Array [ ] = md . digest ( ) ; for ( int i = _ NUM ; i <  Math . min ( _ NUM , hash Array . length ) ; i ++ ) { hash += ( ( long ) ( hash Array [ i ] & _ NUM ) ) << ( i * _ NUM ) ; } } catch (  IOException e ) { throw new  Assertion Error ( e ) ; } catch (  No Such Algorithm Exception e ) { throw new  Assertion Error ( e ) ; } return hash ; }
private static native long create Entity Parser ( long parent Pointer ,  String context ) ;
private void listener Dropped (  Array List drops ,  Array List notifies ) {  Service Registrar [ ] proxys = new  Service Registrar [ drops . size ( ) ] ; drops . to Array ( proxys ) ; listener Dropped ( proxys , notifies ) ; }
public static long hash (  String s ) { if ( s == null ) { return _ NUM ; } int h = _ NUM ; int l = _ NUM ; int len = s . length ( ) ; char [ ] val = s . to Char Array ( ) ; for ( int i = _ NUM ; i < len ; i ++ ) { h = _ NUM * h + val [ i ] ; l = _ NUM * l + val [ i ] ; } return ( ( long ) h << _ NUM ) | ( ( long ) l & _ NUM ) ; }
public boolean match (  String schema ,  String table ) { if ( db Pattern != null ) { if ( logger . is Debug Enabled ( ) ) logger . debug ( _ STR + schema ) ; if ( db Matcher == null ) db Matcher = db Pattern . matcher ( schema ) ; else db Matcher . reset ( schema ) ; if ( db Matcher . matches ( ) ) { if ( logger . is Debug Enabled ( ) ) logger . debug ( _ STR ) ; return _ BOOL ; } } if ( table != null && table . length ( ) > _ NUM ) {  String searched Table = fully Qualified Name ( schema , table ) ; if ( table Pattern != null ) { if ( table Matcher == null ) table Matcher = table Pattern . matcher ( searched Table ) ; else table Matcher . reset ( searched Table ) ; if ( table Matcher . matches ( ) ) return _ BOOL ; } } return _ BOOL ; }
public void add Nodes In Doc Order (  Node Iterator iterator ,  XPath Context support ) { if ( ! m_mutable ) throw new  Runtime Exception (  XSLMessages . create XPATHMessage (  XPATHError Resources .  ER_ NODESET_ NOT_ MUTABLE , null ) ) ;  Node node ; while ( null != ( node = iterator . next Node ( ) ) ) { add Node In Doc Order ( node , support ) ; } }
public void store Device Throttled (  Device d ) { long interval Ns = sync Store Write Interval Ms * _ NUM * _ NUM ; if ( ! is Master ) return ; if ( d == null ) return ; long now =  System . nano Time ( ) ;  Long last = last Write Times . get ( d . get Device Key ( ) ) ; if ( last == null || now - last > interval Ns ) { write Updated Device To Storage ( d ) ; last Write Times . put ( d . get Device Key ( ) , now ) ; } else { cnt Device Store Throttled . update Counter With Flush ( ) ; } }
protected void print Doc Type (  Writer out ,  Doc Type doc Type ) throws  IOException {  String public ID = doc Type . get Public ID ( ) ;  String system ID = doc Type . get System ID ( ) ;  String internal Subset = doc Type . get Internal Subset ( ) ; boolean has Public = _ BOOL ; out . write ( _ STR ) ; out . write ( doc Type . get Element Name ( ) ) ; if ( public ID != null ) { out . write ( _ STR ) ; out . write ( public ID ) ; out . write ( _ STR ) ; has Public = _ BOOL ; } if ( system ID != null ) { if ( ! has Public ) { out . write ( _ STR ) ; } out . write ( _ STR ) ; out . write ( system ID ) ; out . write ( _ STR ) ; } if ( ( internal Subset != null ) && ( ! internal Subset . equals ( _ STR ) ) ) { out . write ( _ STR ) ; out . write ( line Separator ) ; out . write ( doc Type . get Internal Subset ( ) ) ; out . write ( _ STR ) ; } out . write ( _ STR ) ; }
public void handle Request (  Request Context rc ) throws  CLIException { super . handle Request ( rc ) ; ldap Login ( ) ;  SSOToken admin SSOToken = get Admin SSOToken ( ) ;  IOutput output Writer = get Output Writer ( ) ;  String realm = get String Option Value (  IArgument .  REALM_ NAME ) ;  String pattern Type = get String Option Value (  IArgument .  AGENT_ TYPE ) ;  String filter = get String Option Value (  IArgument .  FILTER ) ; if ( pattern Type == null ) { pattern Type = _ STR ; } if ( ( filter == null ) || ( filter . length ( ) == _ NUM ) ) { filter = _ STR ; }  String [ ] params = { realm , pattern Type , filter } ; write Log (  Log Writer .  LOG_ ACCESS ,  Level .  INFO , _ STR , params ) ; try {  AMIdentity Repository amir = new  AMIdentity Repository ( admin SSOToken , realm ) ;  Id Search Results isr = amir . search Identities (  Id Type .  AGENTGROUP , filter , new  Id Search Control ( ) ) ;  Set results = isr . get Search Results ( ) ; if ( ( results != null ) && ! results . is Empty ( ) ) { for (  Iterator i = results . iterator ( ) ; i . has Next ( ) ; ) {  AMIdentity amid = (  AMIdentity ) i . next ( ) ; if ( ! match Type ( amid , pattern Type ) ) { i . remove ( ) ; } } } if ( ( results != null ) && ! results . is Empty ( ) ) { for (  Iterator i = results . iterator ( ) ; i . has Next ( ) ; ) {  AMIdentity amid = (  AMIdentity ) i . next ( ) ;  Object [ ] args = { amid . get Name ( ) , amid . get Universal Id ( ) } ; output Writer . println Message (  Message Format . format ( get Resource String ( _ STR ) , args ) ) ; } } else { output Writer . println Message ( get Resource String ( _ STR ) ) ; } write Log (  Log Writer .  LOG_ ACCESS ,  Level .  INFO , _ STR , params ) ; } catch (  Id Repo Exception e ) {  String [ ] args = { realm , pattern Type , filter , e . get Message ( ) } ; debug Error ( _ STR , e ) ; write Log (  Log Writer .  LOG_ ERROR ,  Level .  INFO , _ STR , args ) ; throw new  CLIException ( e ,  Exit Codes .  REQUEST_ CANNOT_ BE_ PROCESSED ) ; } catch (  SSOException e ) {  String [ ] args = { realm , pattern Type , filter , e . get Message ( ) } ; debug Error ( _ STR , e ) ; write Log (  Log Writer .  LOG_ ERROR ,  Level .  INFO , _ STR , args ) ; throw new  CLIException ( e ,  Exit Codes .  REQUEST_ CANNOT_ BE_ PROCESSED ) ; } }
@  Override public byte [ ] perform ( byte [ ] blob ) throws  Token Strategy Failed Exception {  Reject . if Null ( blob ) ; final  Byte Array Output Stream bout = new  Byte Array Output Stream ( blob . length ) ; try { final  GZIPOutput Stream out = new  GZIPOutput Stream ( bout ) ; out . write ( blob ) ; out . flush ( ) ; out . close ( ) ; } catch (  IOException e ) { throw new  Token Strategy Failed Exception ( e ) ; } return bout . to Byte Array ( ) ; }
private void create Single Style Legend (  Map <  String ,  Style > style Map ,  Styled Layer selected Styled Layer ,  Style selected Style ) {  List <  Style > style List = null ; if ( selected Styled Layer instanceof  Named Layer Impl ) {  Named Layer Impl named Layer = (  Named Layer Impl ) selected Styled Layer ; style List = named Layer . styles ( ) ; } else if ( selected Styled Layer instanceof  User Layer Impl ) {  User Layer Impl user Layer = (  User Layer Impl ) selected Styled Layer ; style List = user Layer . user Styles ( ) ; }  String style Name ; if ( selected Style . get Name ( ) != null ) { style Name = selected Style . get Name ( ) ; } else { style Name =  String . format ( _ STR , style List . index Of ( selected Style ) ) ; } style Map . put ( style Name , selected Style ) ; }
@  HLEUnimplemented @  HLEFunction ( nid = _ NUM , version = _ NUM ) public int sce Kernel Register Sys Event Handler (  TPointer handler ) { psp Sys Event Handler sys Event Handler = new psp Sys Event Handler ( ) ; sys Event Handler . read ( handler ) ; if ( log . is Debug Enabled ( ) ) { log . debug (  String . format ( _ STR , sys Event Handler ) ) ; } return _ NUM ; }
private  Map <  URI ,  Integer > create Volume Map For Export Mask (  Export Mask export Mask ) {  Map <  URI ,  Integer > map = new  Hash Map < > ( ) ; for (  URI uri :  Export Mask Utils . get Volume URIs ( export Mask ) ) { map . put ( uri ,  Export Group .  LUN_ UNASSIGNED ) ; } return map ; }
public synchronized boolean remove First (  K obj ) { if ( peek First ( ) != obj ) { return _ BOOL ; } int len = array . length ; @  Suppress Warnings ( _ STR )  K [ ] a = (  K [ ] ) new  Object [ len - _ NUM ] ;  System . arraycopy ( array , _ NUM , a , _ NUM , len - _ NUM ) ; array = a ; return _ BOOL ; }
public void write (  Image c ,  Component i ) { if ( page == null ) { newpage ( ) ; } int x = x0 + width - ( c . get Width ( null ) * _ NUM / _ NUM + charwidth ) ; int y = y0 + ( linenum * lineheight ) + lineascent ; if ( page != null && pagenum >= pr First ) { page . draw Image ( c , x , y , c . get Width ( null ) * _ NUM / _ NUM , c . get Height ( null ) * _ NUM / _ NUM , null ) ; } }
public static void copy (  Resource in ,  Output Stream os , boolean close OS ) throws  IOException {  Input Stream is = null ; try { is = to Buffered Input Stream ( in . get Input Stream ( ) ) ; } catch (  IOException ioe ) {  IOUtil . close EL ( is ) ; throw ioe ; } copy ( is , os , _ BOOL , close OS ) ; }
public  String trim Audio (  String path , double start , double length ) throws  Exception {  Array List <  String > cmd = new  Array List <  String > ( ) ;  File file = new  File ( path ) ;  String out File = file . get Canonical Path ( ) + _ STR ; cmd . add ( sox Bin ) ; cmd . add ( path ) ; cmd . add ( _ STR ) ; cmd . add ( _ STR ) ; cmd . add ( _ STR ) ; cmd . add ( _ STR ) ; cmd . add ( out File ) ; cmd . add ( _ STR ) ; cmd . add ( start + _ STR ) ; if ( length != - _ NUM ) cmd . add ( length + _ STR ) ; int rc = exec Sox ( cmd , callback ) ; if ( rc != _ NUM ) { out File = null ; } if ( file . exists ( ) ) return out File ; else return null ; }
private void rescale Canvas ( int width , int height , float stroke Width ,  Canvas canvas ) { final  Rect F view Box = m Svg . get Document View Box ( ) ; final float scale =  Math . min ( width / ( view Box . width ( ) + stroke Width ) , height / ( view Box . height ( ) + stroke Width ) ) ; canvas . translate ( ( width - view Box . width ( ) * scale ) / _ NUM , ( height - view Box . height ( ) * scale ) / _ NUM ) ; canvas . scale ( scale , scale ) ; m Svg . render To Canvas ( canvas ) ; }
public static  List <  Class < ? > > find All Implementations (  Class < ? > c , boolean everything , boolean parameterizable ) { if ( c == null ) { return  Collections . empty List ( ) ; } if ( ! everything && parameterizable ) { return find All Implementations ( c ) ; } if ( ! contains ( c ) ) {  ELKIService Loader . load ( c ) ;  ELKIService Scanner . load ( c ) ; }  List <  Class < ? > > known = find All Implementations ( c ) ;  Hash Set <  Class < ? > > dupes = new  Hash Set < > ( known ) ; for (  Iterator <  Class < ? > > iter =  ELKIService Scanner . nonindexed Classes ( ) ; iter . has Next ( ) ; ) {  Class < ? > cls = iter . next ( ) ; if ( dupes . contains ( cls ) ) { continue ; } if ( ! everything && (  Modifier . is Interface ( cls . get Modifiers ( ) ) ||  Modifier . is Abstract ( cls . get Modifiers ( ) ) ||  Modifier . is Private ( cls . get Modifiers ( ) ) ) ) { continue ; } if ( ! c . is Assignable From ( cls ) ) { continue ; } if ( parameterizable ) { boolean instantiable = _ BOOL ; try { instantiable = cls . get Constructor ( ) != null ; } catch (  Exception |  Error e ) { } try { instantiable = instantiable ||  Class Generics Util . get Parameterizer ( cls ) != null ; } catch (  Exception |  Error e ) { } if ( ! instantiable ) { continue ; } } known . add ( cls ) ; dupes . add ( cls ) ; } return known ; }
public void move To Previous Date ( ) { if ( disable Auto Date Selection && user Selected Item == null ) return ; if ( selected Date Item != null ) {  Calendar cal =  Calendar . get Instance ( ) ; cal . set ( selected Date Item . get Year ( ) , selected Date Item . get Month ( ) , selected Date Item . get Day ( ) ) ; cal . add (  Calendar .  DATE , - _ NUM ) ; if ( selected Date Item . get Month ( ) != cal . get (  Calendar .  MONTH ) ) { selected Date Item . set Day ( cal . get (  Calendar .  DAY_ OF_ MONTH ) ) ; selected Date Item . set Month ( cal . get (  Calendar .  MONTH ) ) ; selected Date Item . set Year ( cal . get (  Calendar .  YEAR ) ) ; should Override Computed Date = _ BOOL ; move To Previous Month ( ) ; } else { selected Date Item . set Day ( cal . get (  Calendar .  DAY_ OF_ MONTH ) ) ; selected Date Item . set Month ( cal . get (  Calendar .  MONTH ) ) ; selected Date Item . set Year ( cal . get (  Calendar .  YEAR ) ) ; month View Pager Adapter . set Selected Item ( selected Date Item ) ; } } }
private  Boolean is Instance Modification Event (  Hashtable <  String ,  String > notification ) {  String event Type = _ STR ;  Boolean is Instance Modification Event =  Boolean .  FALSE ; event Type = notification . get (  CIMConstants .  INDICATION_ CLASS_ TAG ) ; if ( event Type != null && event Type . length ( ) > _ NUM && event Type . contains (  CIMConstants .  INST_ MODIFICATION_ EVENT ) ) { is Instance Modification Event =  Boolean .  TRUE ; } return is Instance Modification Event ; }
@  Override public int read ( ) throws  IOException { int b0 = f Input Stream . read ( ) ; if ( b0 >= _ NUM ) { throw new  Malformed Byte Sequence Exception ( f Formatter , f Locale ,  XMLMessage Formatter .  XML_ DOMAIN , _ STR , new  Object [ ] {  Integer . to String ( b0 ) } ) ; } return b0 ; }
protected void create_y_axis ( int i ,  String y , int size ) { float ver_height = ( ( graphheight / size ) * i ) + border ;  Log . e ( _ STR , i + _ STR + size + _ STR + height + _ STR + graphheight + _ STR + ver_height ) ; if ( i == size ) canvas . draw Line ( horstart , ver_height , width - ( border ) , ver_height , paint ) ; else canvas . draw Line ( horstart , ver_height , border , ver_height , paint ) ; paint . set Color (  Color .  BLACK ) ; paint . set Text Align (  Paint .  Align .  RIGHT ) ; canvas . draw Text ( y + _ STR , horstart - _ NUM , ver_height - _ NUM , paint ) ; paint . set Text Align (  Paint .  Align .  LEFT ) ; }
public final double sample Max ( ) { long count = _acquire Count . get ( ) - _release Count . get ( ) ; long max = _max . get And Set ( count ) ; return max ; }
public void edit (  File file ) throws  IOException { check AWTPermission ( ) ; check Exec ( ) ; check Action Support (  Action .  EDIT ) ; file . can Write ( ) ; check File Validation ( file ) ; peer . edit ( file ) ; }
public void add (  Collection <  Rule Grounding > alternatives ) { boolean found Success = _ BOOL ; for (  Rule Grounding g : alternatives ) { if ( ! g . is Failed ( ) ) { add ( g ) ; found Success = _ BOOL ; } } if ( ! found Success ) { groundings . clear ( ) ; } }
public static  Pattern convert Perl Regex To Pattern ( @  Nonnull final  String regex , @  Nonnull final boolean fault Tolerant ) {  Check . not Null ( regex , _ STR ) ;  String pattern = regex . trim ( ) ; final  Matcher matcher = fault Tolerant ?  PERL_ STYLE_ TOLERANT . matcher ( pattern ) :  PERL_ STYLE . matcher ( pattern ) ; if ( ! matcher . matches ( ) ) { throw new  Illegal Argument Exception ( _ STR + pattern + _ STR ) ; } pattern = pattern . substring ( _ NUM ) ; final int last Index = pattern . last Index Of ( _ STR ) ; pattern = pattern . substring ( _ NUM , last Index ) ; final int flags =  Flag . convert To Bitmask (  Flag . parse ( matcher . group ( _ NUM ) ) ) ; return  Pattern . compile ( pattern , flags ) ; }
public void test Procedure Columns ( ) throws  Exception { try {  Statement stmt = con . create Statement ( ) ; stmt . execute ( _ STR + _ STR + _ STR + _ STR ) ; stmt . close ( ) ;  Database Meta Data dbmd = con . get Meta Data ( ) ;  String [ ] column Patterns = new  String [ ] { null , _ STR } ; for ( int i = _ NUM ; i < column Patterns . length ; i ++ ) {  Result Set rs = dbmd . get Procedure Columns ( null , null , _ STR , column Patterns [ i ] ) ; assert True ( rs . next ( ) ) ;  Assert . assert Equals ( _ STR , rs . get String ( _ STR ) ) ;  Assert . assert Equals (  Database Meta Data . procedure Column Return , rs . get Int ( _ STR ) ) ; assert True ( rs . next ( ) ) ;  Assert . assert Equals ( _ STR , rs . get String ( _ STR ) ) ;  Assert . assert Equals (  Database Meta Data . procedure Column In , rs . get Int ( _ STR ) ) ; assert True ( rs . next ( ) ) ;  Assert . assert Equals ( _ STR , rs . get String ( _ STR ) ) ;  Assert . assert Equals (  Database Meta Data . procedure Column In Out , rs . get Int ( _ STR ) ) ; rs . close ( ) ; } } finally { } }
private static int [ ] [ ] compile Derivatives Indirection ( final int parameters , final int order , final  DSCompiler value Compiler , final  DSCompiler derivative Compiler ) { if ( parameters == _ NUM || order == _ NUM ) { return new int [ _ NUM ] [ parameters ] ; } final int v Size = value Compiler . derivatives Indirection . length ; final int d Size = derivative Compiler . derivatives Indirection . length ; final int [ ] [ ] derivatives Indirection = new int [ v Size + d Size ] [ parameters ] ; for ( int i = _ NUM ; i < v Size ; ++ i ) {  System . arraycopy ( value Compiler . derivatives Indirection [ i ] , _ NUM , derivatives Indirection [ i ] , _ NUM , parameters - _ NUM ) ; } for ( int i = _ NUM ; i < d Size ; ++ i ) {  System . arraycopy ( derivative Compiler . derivatives Indirection [ i ] , _ NUM , derivatives Indirection [ v Size + i ] , _ NUM , parameters ) ; derivatives Indirection [ v Size + i ] [ parameters - _ NUM ] ++ ; } return derivatives Indirection ; }
public static byte [ ] increment Bytes ( byte [ ] value , long amount ) throws  IOException { byte [ ] val = value ; if ( val . length <  SIZEOF_ LONG ) { byte [ ] newvalue ; if ( val [ _ NUM ] < _ NUM ) { newvalue = new byte [ ] { - _ NUM , - _ NUM , - _ NUM , - _ NUM , - _ NUM , - _ NUM , - _ NUM , - _ NUM } ; } else { newvalue = new byte [  SIZEOF_ LONG ] ; }  System . arraycopy ( val , _ NUM , newvalue , newvalue . length - val . length , val . length ) ; val = newvalue ; } else if ( val . length >  SIZEOF_ LONG ) { throw new  Illegal Argument Exception ( _ STR + val . length ) ; } if ( amount == _ NUM ) return val ; if ( val [ _ NUM ] < _ NUM ) { return binary Increment Neg ( val , amount ) ; } return binary Increment Pos ( val , amount ) ; }
public boolean resource Exist (  Integer id ) { if ( id == null ) { return _ BOOL ; } return resource Exist ( id . int Value ( ) ) ; }
public  Projected Stream add View (  String namespace ,  String name ,  Expression ... parameters ) { views . add (  View . create ( namespace , name , parameters ) ) ; return this ; }
public static int how Many Minutes Old ( long time ) { return ( int ) ( (  System . current Time Millis ( ) - time + _ NUM ) /  Date Utils .  MINUTE_ IN_ MILLIS ) ; }
static  String parse Prefix (  String key ) { if ( key == null ) return null ; boolean inquotes = _ BOOL ; for ( int i = _ NUM ; i < key . length ( ) ; i ++ ) { char c = key . char At ( i ) ; if ( c == _ STR ) { inquotes = ! inquotes ; } else if ( ( c == _ STR || c == _ STR ) && ! inquotes ) { return key . substring ( _ NUM , i ) ; } } return null ; }
public  Stream Impl open Read Impl (  Path Impl path ) throws  IOException {  String path Name = path . get Path ( ) ; return open Read Impl ( path Name ) ; }
public static  Result Code value Of ( final int int Value ) {  Result Code result =  ELEMENTS . get ( int Value ) ; if ( result == null ) { result = new  Result Code ( int Value ,  Localizable Message . raw ( _ STR + int Value + _ STR ) , _ BOOL ,  Enum .  UNKNOWN ) ; } return result ; }
public synchronized  OMGraphic List prepare ( ) { if ( spatial Indexes == null || spatial Indexes . is Empty ( ) ) { logger . fine ( get Name ( ) + _ STR ) ; return new  OMGraphic List ( ) ; }  Projection projection = get Projection ( ) ; if ( projection == null ) { logger . fine ( get Name ( ) + _ STR ) ; return new  OMGraphic List ( ) ; }  Point2 D ul = projection . get Upper Left ( ) ;  Point2 D lr = projection . get Lower Right ( ) ; double ul Lat = ul . get Y ( ) ; double ul Lon = ul . get X ( ) ; double lr Lat = lr . get Y ( ) ; double lr Lon = lr . get X ( ) ;  OMGraphic List master List = new  OMGraphic List ( ) ;  OMGraphic List list = null ; if (  Proj Math . is Crossing Dateline ( ul Lon , lr Lon , projection . get Scale ( ) ) ) { if ( logger . is Loggable (  Level .  FINE ) ) { logger . fine ( get Name ( ) + _ STR ) ; } double ymin =  Math . min ( ul Lat , lr Lat ) ; double ymax =  Math . max ( ul Lat , lr Lat ) ;  Iterator <  Spatial Index Handler > sii = spatial Indexes . iterator ( ) ; while ( sii . has Next ( ) ) {  Spatial Index Handler sih = (  Spatial Index Handler ) sii . next ( ) ; if ( ! sih . enabled ) continue ; try { list = sih . get Graphics ( ul Lon , ymin , _ NUM , ymax , list , projection ) ; list = sih . get Graphics ( - _ NUM , ymin , lr Lon , ymax , list , projection ) ; } catch ( java . io .  IOException ex ) { ex . print Stack Trace ( ) ; } catch (  Format Exception fe ) { fe . print Stack Trace ( ) ; } master List . add ( list ) ; } } else { double xmin = ( double )  Math . min ( ul Lon , lr Lon ) ; double xmax = ( double )  Math . max ( ul Lon , lr Lon ) ; double ymin = ( double )  Math . min ( ul Lat , lr Lat ) ; double ymax = ( double )  Math . max ( ul Lat , lr Lat ) ;  Iterator <  Spatial Index Handler > sii = spatial Indexes . iterator ( ) ; while ( sii . has Next ( ) ) {  Spatial Index Handler sih = (  Spatial Index Handler ) sii . next ( ) ; if ( ! sih . enabled ) continue ; if ( logger . is Loggable (  Level .  FINE ) ) { logger . fine ( get Name ( ) + _ STR + sih . pretty Name + _ STR ) ; } try { list = sih . get Graphics ( xmin , ymin , xmax , ymax , list , projection ) ; } catch ( java . io .  IOException ex ) { ex . print Stack Trace ( ) ; } catch (  Format Exception fe ) { fe . print Stack Trace ( ) ; } master List . add ( list ) ; } } return master List ; }
private boolean exposed ( int modifiers ) { return _ NUM != ( modifiers & (  Modifier .  PUBLIC |  Modifier .  PROTECTED ) ) ; }
public void test Divide Round Half Up Pos1 ( ) {  String a = _ STR ; int a Scale = - _ NUM ;  String b = _ STR ; int b Scale = _ NUM ;  String c = _ STR ; int res Scale = - _ NUM ;  Big Decimal a Number = new  Big Decimal ( new  Big Integer ( a ) , a Scale ) ;  Big Decimal b Number = new  Big Decimal ( new  Big Integer ( b ) , b Scale ) ;  Big Decimal result = a Number . divide ( b Number , res Scale ,  Big Decimal .  ROUND_ HALF_ UP ) ; assert Equals ( _ STR , c , result . to String ( ) ) ; assert Equals ( _ STR , res Scale , result . scale ( ) ) ; }
public boolean delete Entry (  User user ,  Entry entry ,  String children Action , boolean is Admin ,  List <  String > deleted Entry Ids ,  Errors errors ) {  String original Children Action = children Action ; if ( entry == null ) {  Errors . add ( errors , error Messages . error Entry Is Null ( ) ) ; return _ BOOL ; } if ( user == null ) {  Errors . add ( errors , error Messages . error User Is Null ( ) ) ; return _ BOOL ; } if ( children Action != null && ! children Action . equals ( _ STR ) && ! children Action . equals ( _ STR ) && ! children Action . equals ( _ STR ) ) {  Errors . add ( errors , error Messages . error Children Action Invalid ( ) ) ; return _ BOOL ; } if ( ! can User Modify Entry ( user , entry , is Admin ) ) {  Errors . add ( errors , error Messages . error User Is Not Entitled To Delete ( ) ) ; return _ BOOL ; } final  Entry parent = get Entry By Id ( entry . get Parent Id ( ) ) ; if ( parent == null && children Action != null && children Action . equals ( _ STR ) ) { if ( entry . is Source ( ) || entry . is Quotation ( ) ) { children Action = _ STR ; } else {  Errors . add ( errors , error Messages . error Children Action May Not Be Parent If The Deleted Entry Has No Parent ( ) ) ; return _ BOOL ; } } boolean do Not Update Siblings = _ BOOL ; if ( children Action != null && children Action . equals ( _ STR ) ) { reparent Children ( entry , parent ) ; do Not Update Siblings = _ BOOL ; } if ( parent != null ) { remove Entry From Parent ( entry , parent , do Not Update Siblings ) ; } for (  Object object Child : get Entries By Parent Id ( entry . get Id ( ) ) ) {  Entry child = (  Entry ) object Child ; if ( children Action == null || children Action . equals ( _ STR ) ) { if ( ! delete Entry ( user , child , children Action , is Admin , deleted Entry Ids , errors ) ) { return _ BOOL ; } } else if ( children Action . equals ( _ STR ) ) { child . set Parent Id ( null ) ; child . set Next Sibling Id ( null ) ; child . set Previous Sibling Id ( null ) ; } else if ( children Action . equals ( _ STR ) ) { child . set Parent Id ( parent . get Id ( ) ) ; } } if ( deleted Entry Ids != null ) { deleted Entry Ids . add ( entry . get Id ( ) ) ; } db . remove Entry ( entry ) ; if ( entry . is Notebook ( ) ) {  Entry root Entry = get Entry By Id ( entry . get Root Id ( ) ) ; return delete Entry ( user , root Entry , _ STR , is Admin , deleted Entry Ids , errors ) ; } else if ( entry . is Source ( ) ) { for (  Object object Quotation : get Entries By Source Id ( entry . get Id ( ) , _ NUM ,  Integer .  MAX_ VALUE ) ) {  Entry quotation = (  Entry ) object Quotation ; if ( was Entry Deleted In This Transaction ( quotation ) ) { continue ; } if ( ! delete Entry ( user , quotation , original Children Action , is Admin , deleted Entry Ids , errors ) ) { return _ BOOL ; } } } return _ BOOL ; }
private int read Block Header ( boolean can Block ) throws  IOException { if ( default Data End ) { return - _ NUM ; } try { for ( ; ; ) { int avail = can Block ?  Integer .  MAX_ VALUE : in . available ( ) ; if ( avail == _ NUM ) { return  HEADER_ BLOCKED ; } int tc = in . peek ( ) ; switch ( tc ) { case  TC_ BLOCKDATA : if ( avail < _ NUM ) { return  HEADER_ BLOCKED ; } in . read Fully ( hbuf , _ NUM , _ NUM ) ; return hbuf [ _ NUM ] & _ NUM ; case  TC_ BLOCKDATALONG : if ( avail < _ NUM ) { return  HEADER_ BLOCKED ; } in . read Fully ( hbuf , _ NUM , _ NUM ) ; int len =  Bits . get Int ( hbuf , _ NUM ) ; if ( len < _ NUM ) { throw new  Stream Corrupted Exception ( _ STR + len ) ; } return len ; case  TC_ RESET : in . read ( ) ; handle Reset ( ) ; break ; default : if ( tc >= _ NUM && ( tc <  TC_ BASE || tc >  TC_ MAX ) ) { throw new  Stream Corrupted Exception (  String . format ( _ STR , tc ) ) ; } return - _ NUM ; } } } catch (  EOFException ex ) { throw new  Stream Corrupted Exception ( _ STR ) ; } }
private void load Text (  Input Stream is ) throws  IOException {  Buffered Reader reader ;  String line ;  String tokenize =  Utilities . get Property ( _ STR , _ STR ) ; tokenize On Load = tokenize . equals ( _ STR ) ; tokenize On Lookup = tokenize . equals ( _ STR ) ; letter Index = new  Hash Map ( ) ; reader = new  Buffered Reader ( new  Input Stream Reader ( is ) ) ; line = reader . read Line ( ) ; while ( line != null ) { if ( ! line . starts With ( _ STR ) ) { parse And Add ( line ) ; } line = reader . read Line ( ) ; } }
private int measure Width ( int measure Spec ) { int result = _ NUM ; int spec Mode =  Measure Spec . get Mode ( measure Spec ) ; int spec Size =  Measure Spec . get Size ( measure Spec ) ; if ( spec Mode ==  Measure Spec .  EXACTLY ) { result = spec Size ; } else { result = ( int ) m Text Paint . measure Text ( m Text ) + get Padding Left ( ) + get Padding Right ( ) ; if ( spec Mode ==  Measure Spec .  AT_ MOST ) { result =  Math . min ( result , spec Size ) ; } } return result ; }
public void test_get Put Byte Array With Offset And Length ( ) { final int capacity = _ NUM ; final  Byte Array Buffer buf = new  Byte Array Buffer ( capacity ) ; assert Equals ( ( byte ) _ NUM , buf . get Byte ( _ NUM ) ) ; assert Equals ( ( byte ) _ NUM , buf . get Byte ( capacity - _ NUM ) ) ; final int pos = _ NUM ; for ( int i = _ NUM ; i <  LIMIT ; i ++ ) { final byte [ ] expected = new byte [ r . next Int ( capacity - _ NUM ) ] ; final int off = ( expected . length / _ NUM == _ NUM ? _ NUM : r . next Int ( expected . length / _ NUM ) ) ; final int len = ( expected . length == _ NUM ? _ NUM : r . next Int ( expected . length - off ) ) ; r . next Bytes ( expected ) ; buf . put ( pos , expected , off , len ) ; assert Equals ( _ NUM ,  Bytes Util . compare Bytes With Len And Offset ( off , len , expected , pos , len , buf . array ( ) ) ) ; final int dstoff = r . next Int ( _ NUM ) ; final byte [ ] actual = new byte [ expected . length + dstoff ] ; buf . get ( pos , actual , dstoff , expected . length ) ; assert Equals ( _ NUM ,  Bytes Util . compare Bytes With Len And Offset ( off , len , expected , dstoff , len , actual ) ) ; } assert Equals ( ( byte ) _ NUM , buf . get Byte ( _ NUM ) ) ; assert Equals ( ( byte ) _ NUM , buf . get Byte ( pos + capacity - _ NUM ) ) ; }
protected boolean is Item Bound To Other Player ( final  Player player , final  RPObject object ) { if ( object instanceof  Item ) { final  Item item = (  Item ) object ; if ( item . is Bound ( ) && ! player . is Bound To ( item ) ) { player . send Private Text ( _ STR + item . get Name ( ) + _ STR + item . get Bound To ( ) + _ STR ) ; return _ BOOL ; } } return _ BOOL ; }
protected  String url String ( ) throws  Parse Exception {  String Builder retval = new  String Builder ( ) ; lexer . select Lexer ( _ STR ) ; while ( lexer . has More Chars ( ) ) { char la = lexer . look Ahead ( _ NUM ) ; if ( la == _ STR || la == _ STR || la == _ STR || la == _ STR || la == _ STR ) break ; lexer . consume ( _ NUM ) ; retval . append ( la ) ; } return retval . to String ( ) ; }
public static void slide In From Bottom Animator ( @  Non Null  List <  Animator > animators , @  Non Null  View view ,  Recycler View recycler View ) { alpha Animator ( animators , view , _ NUM ) ; animators . add (  Object Animator . of Float ( view , _ STR , recycler View . get Measured Height ( ) > > _ NUM , _ NUM ) ) ; if (  Flexible Adapter .  DEBUG )  Log . v (  TAG , _ STR ) ; }
void copy Value ( int [ ] val ) { int len = val . length ; if ( value . length < len ) value = new int [ len ] ;  System . arraycopy ( val , _ NUM , value , _ NUM , len ) ; int Len = len ; offset = _ NUM ; }
@  Request Mapping ( value = _ STR ) public void slo Error (  Locale locale , @  Path Variable ( value = _ STR )  String tenant ,  Http Servlet Response response ) throws  IOException { logger . info ( _ STR + locale . to String ( ) + _ STR + tenant ) ; slo Default Tenant Binding Error ( locale , response ) ; }
@  Override public long add Disk (  String file Name ,  Input Stream input Stream ) throws  IOException ,  Vmdk Format Exception ,  Name Taken Exception ,  Internal Exception { if ( ! input Stream . mark Supported ( ) ) { input Stream = new  Buffered Input Stream ( input Stream ) ; } int single Extent Size =  Vmdk Metadata . get Single Extent Size ( input Stream ) ;  String image Path = get Image File Path ( file Name ) ; logger . info ( _ STR , image Path ) ; nfc Client . put Stream Optimized Disk ( image Path , input Stream ) ; return single Extent Size * _ NUM ; }
public  Tx Id2 Commit Time Index ( final  IRaw Store store , final  Checkpoint checkpoint , final  Index Metadata metadata , boolean read Only ) { super ( store , checkpoint , metadata , read Only ) ; }
private boolean is Closed ( ) { if ( ! verify Reader ) { return _ BOOL ; } try { return ! br . ready ( ) ; } catch (  IOException e ) { return _ BOOL ; } }
private static void insert Value Using If Not Empty ( final  Map <  String ,  List <  String > > params Map , final  String param Val , final  String parameter Name ) { if (  String Utils . is Not Empty ( param Val ) ) {  List <  String > list = new  Array List < > ( ) ; list . add ( param Val ) ; params Map . put ( parameter Name , list ) ; } }
public  Dimension maximum Layout Size (  Container target ) {  Dimension size ; synchronized ( this ) { check Container ( target ) ; check Requests ( ) ; size = new  Dimension ( x Total . maximum , y Total . maximum ) ; }  Insets insets = target . get Insets ( ) ; size . width = ( int )  Math . min ( ( long ) size . width + ( long ) insets . left + ( long ) insets . right ,  Integer .  MAX_ VALUE ) ; size . height = ( int )  Math . min ( ( long ) size . height + ( long ) insets . top + ( long ) insets . bottom ,  Integer .  MAX_ VALUE ) ; return size ; }
public static void tql2 ( int n , double [ ] d , double [ ] e , double [ ] [ ]  V ) { for ( int i = _ NUM ; i < n ; i ++ ) { e [ i - _ NUM ] = e [ i ] ; } e [ n - _ NUM ] = _ NUM ; double f = _ NUM ; double tst1 = _ NUM ; double eps =  Math . pow ( _ NUM , - _ NUM ) ; for ( int l = _ NUM ; l < n ; l ++ ) { tst1 =  Math . max ( tst1 ,  Math . abs ( d [ l ] ) +  Math . abs ( e [ l ] ) ) ; int m = l ; while ( m < n ) { if (  Math . abs ( e [ m ] ) <= eps * tst1 ) { break ; } m ++ ; } if ( m > l ) { int iter = _ NUM ; do { iter = iter + _ NUM ; double g = d [ l ] ; double p = ( d [ l + _ NUM ] - g ) / ( _ NUM * e [ l ] ) ; double r = hypot ( p , _ NUM ) ; if ( p < _ NUM ) { r = - r ; } d [ l ] = e [ l ] / ( p + r ) ; d [ l + _ NUM ] = e [ l ] * ( p + r ) ; double dl1 = d [ l + _ NUM ] ; double h = g - d [ l ] ; for ( int i = l + _ NUM ; i < n ; i ++ ) { d [ i ] -= h ; } f = f + h ; p = d [ m ] ; double c = _ NUM ; double c2 = c ; double c3 = c ; double el1 = e [ l + _ NUM ] ; double s = _ NUM ; double s2 = _ NUM ; for ( int i = m - _ NUM ; i >= l ; i -- ) { c3 = c2 ; c2 = c ; s2 = s ; g = c * e [ i ] ; h = c * p ; r = hypot ( p , e [ i ] ) ; e [ i + _ NUM ] = s * r ; s = e [ i ] / r ; c = p / r ; p = c * d [ i ] - s * g ; d [ i + _ NUM ] = h + s * ( c * g + s * d [ i ] ) ; for ( int k = _ NUM ; k < n ; k ++ ) { h =  V [ k ] [ i + _ NUM ] ;  V [ k ] [ i + _ NUM ] = s *  V [ k ] [ i ] + c * h ;  V [ k ] [ i ] = c *  V [ k ] [ i ] - s * h ; } } p = - s * s2 * c3 * el1 * e [ l ] / dl1 ; e [ l ] = s * p ; d [ l ] = c * p ; } while (  Math . abs ( e [ l ] ) > eps * tst1 ) ; } d [ l ] = d [ l ] + f ; e [ l ] = _ NUM ; } for ( int i = _ NUM ; i < n - _ NUM ; i ++ ) { int k = i ; double p = d [ i ] ; for ( int j = i + _ NUM ; j < n ; j ++ ) { if ( d [ j ] < p ) { k = j ; p = d [ j ] ; } } if ( k != i ) { d [ k ] = d [ i ] ; d [ i ] = p ; for ( int j = _ NUM ; j < n ; j ++ ) { p =  V [ j ] [ i ] ;  V [ j ] [ i ] =  V [ j ] [ k ] ;  V [ j ] [ k ] = p ; } } } }
public void select ( int position , boolean fire Event , boolean consider Selectable Flag ) {  Item item = get Item ( position ) ; if ( item == null ) { return ; } if ( consider Selectable Flag && ! item . is Selectable ( ) ) { return ; } item . with Set Selected ( _ BOOL ) ; if ( m Position Based State Management ) { m Selections . add ( position ) ; } notify Item Changed ( position ) ; if ( m Selection Listener != null ) m Selection Listener . on Selection Changed ( item , _ BOOL ) ; if ( m On Click Listener != null && fire Event ) { m On Click Listener . on Click ( null , get Adapter ( position ) , item , position ) ; } }
public static  String element Value (  Element element ) { if ( element == null ) return null ; element . normalize ( ) ;  Node text Node = element . get First Child ( ) ; if ( text Node == null ) return null ;  String Builder value Buffer = new  String Builder ( ) ; do { if ( text Node . get Node Type ( ) ==  Node .  CDATA_ SECTION_ NODE || text Node . get Node Type ( ) ==  Node .  TEXT_ NODE ) { value Buffer . append ( text Node . get Node Value ( ) ) ; } } while ( ( text Node = text Node . get Next Sibling ( ) ) != null ) ; return value Buffer . to String ( ) ; }
void connect ( ) throws  Exception {  Curator Framework zk Client = null ; long connectioncreatime = _ NUM ;  LOGGER . warn ( _ STR + m_connection Str + _ STR + m_cxn Wait In Millis + _ STR + m_retrycount + _ STR + m_retrywait Time In Millis ) ; long start =  System . current Time Millis ( ) ; zk Client = connect Internal ( m_session Timeout In Millis , m_cxn Wait In Millis , m_retrycount , m_retrywait Time In Millis ) ; long end =  System . current Time Millis ( ) ; connectioncreatime = end - start ; if ( zk Client != null && ( ! is ZKConnected ( zk Client ) ) ) { zk Client . close ( ) ; throw new  Exception ( _ STR ) ; } else { set ZKHandle ( zk Client ) ;  LOGGER . warn ( _ STR + m_connection Str ) ;  LOGGER . warn ( _ STR + connectioncreatime + _ STR ) ; } }
private  List <  Solution > normalize (  Population population ) {  List <  Solution > result = new  Array List <  Solution > ( ) ; double [ ] min = new double [ problem . get Number Of Objectives ( ) ] ; double [ ] max = new double [ problem . get Number Of Objectives ( ) ] ;  Arrays . fill ( min ,  Double .  POSITIVE_ INFINITY ) ;  Arrays . fill ( max ,  Double .  NEGATIVE_ INFINITY ) ; for (  Solution solution : population ) { for ( int i = _ NUM ; i < problem . get Number Of Objectives ( ) ; i ++ ) { min [ i ] =  Math . min ( min [ i ] , solution . get Objective ( i ) ) ; max [ i ] =  Math . max ( max [ i ] , solution . get Objective ( i ) ) ; } } for (  Solution solution : population ) {  Solution new Solution = solution . copy ( ) ; for ( int i = _ NUM ; i < problem . get Number Of Objectives ( ) ; i ++ ) { new Solution . set Objective ( i , ( max [ i ] - ( new Solution . get Objective ( i ) - min [ i ] ) + offset ) / ( max [ i ] - min [ i ] ) ) ; } result . add ( new Solution ) ; } return result ; }
private static int max Buckets Per Element ( long num Elements ) { num Elements =  Math . max ( _ NUM , num Elements ) ; double v = (  Integer .  MAX_ VALUE -  EXCESS ) / ( double ) num Elements ; if ( v < _ NUM ) { throw new  Unsupported Operation Exception ( _ STR + num Elements + _ STR ) ; } return  Math . min (  Bloom Calculations . probs . length - _ NUM , ( int ) v ) ; }
public static boolean is Available (  URL url ) throws  Exception { if ( ( config == null ) || ( keep Monitoring == _ BOOL ) ) { return _ BOOL ; }  String server ID = null ; try { server ID = get Server ID ( url . get Protocol ( ) , url . get Host ( ) ,  Integer . to String ( url . get Port ( ) ) , url . get Path ( ) , _ BOOL ) ; } catch (  Server Entry Not Found Exception e ) { if ( debug . message Enabled ( ) ) { debug . message ( _ STR ) ; } return _ BOOL ; }  Vector sites = get Available Sites ( ) ; boolean available = _ BOOL ;  Iterator it = sites . iterator ( ) ; while ( it . has Next ( ) ) {  String server = (  String ) it . next ( ) ; if ( server ID . equals Ignore Case ( server ) ) { available = _ BOOL ; break ; } } if ( debug . message Enabled ( ) ) { debug . message ( _ STR ) ; if ( available ) { debug . message ( _ STR + url . to String ( ) + _ STR ) ; } else { debug . message ( _ STR + url . to String ( ) + _ STR ) ; } } return available ; }
public void init Dct8x8 ( ) { int i = _ NUM ; int j = _ NUM ; double sq Jpeg =  Math . sqrt (  NJPEG ) ; double sq Jpeg2 =  Math . sqrt ( _ NUM /  NJPEG ) ; for ( j = _ NUM ; j <  NJPEG ; j ++ ) { this .  C [ _ NUM ] [ j ] = _ NUM / sq Jpeg ; this .  Ct [ j ] [ _ NUM ] = this .  C [ _ NUM ] [ j ] ; } for ( i = _ NUM ; i <  NJPEG ; i ++ ) { for ( j = _ NUM ; j <  NJPEG ; j ++ ) { this .  C [ i ] [ j ] = sq Jpeg2 *  Math . cos (  Math .  PI * ( _ NUM * j + _ NUM ) * i / ( _ NUM *  NJPEG ) ) ; this .  Ct [ j ] [ i ] = this .  C [ i ] [ j ] ; } } }
public grammaticality Estimator (  Set  File Names , int i Min Char , int i Max Char , int i Min Word , int i Max Word , int i Neighbourhood Window ) { i Min Char NGram = i Min Char ; i Max Char NGram = i Max Char ; i Min Word NGram = i Min Word ; i Max Word NGram = i Max Word ;  Distro Docs = new  Tree Map <  Integer ,  Distribution Document > ( ) ;  Distro Word Docs = new  Tree Map <  Integer ,  Distribution Word Document > ( ) ;  String Buffer sb = new  String Buffer ( ) ;  Iterator i Texts =  File Names . iterator ( ) ; while ( i Texts . has Next ( ) ) {  String s File = (  String ) i Texts . next ( ) ; try {  Buffered Reader bf = new  Buffered Reader ( new  File Reader ( s File ) ) ;  String s Tmp ; while ( ( s Tmp = bf . read Line ( ) ) != null ) sb . append ( s Tmp ) ; bf . close ( ) ; } catch (  File Not Found Exception ex ) { ex . print Stack Trace (  System . err ) ; } catch (  IOException ex ) { ex . print Stack Trace (  System . err ) ; } sb . append ( ( char ) _ NUM ) ; }  Full Text Data String = sb . to String ( ) ; for ( int i Cnt = i Min Char NGram ; i Cnt <= i Max Char NGram ; i Cnt ++ ) {  Distro Docs . put ( i Cnt , new  Distribution Document ( i Neighbourhood Window , i Cnt ) ) ; } for ( int i Cnt = i Min Word NGram ; i Cnt <= i Max Word NGram ; i Cnt ++ ) {  Distro Word Docs . put ( i Cnt , new  Distribution Word Document ( i Neighbourhood Window , i Cnt ) ) ; } }
private void parse Wild Cards ( ) { if ( f Pattern . starts With ( _ STR ) ) f Has Leading Star = _ BOOL ; if ( f Pattern . ends With ( _ STR ) ) { if ( f Length > _ NUM && f Pattern . char At ( f Length - _ NUM ) != _ STR ) { f Has Trailing Star = _ BOOL ; } }  Vector <  String > temp = new  Vector <  String > ( ) ; int pos = _ NUM ;  String Buffer buf = new  String Buffer ( ) ; while ( pos < f Length ) { char c = f Pattern . char At ( pos ++ ) ; switch ( c ) { case _ STR : if ( pos >= f Length ) { buf . append ( c ) ; } else { char next = f Pattern . char At ( pos ++ ) ; if ( next == _ STR || next == _ STR || next == _ STR ) { buf . append ( next ) ; } else { buf . append ( c ) ; buf . append ( next ) ; } } break ; case _ STR : if ( buf . length ( ) > _ NUM ) { temp . add Element ( buf . to String ( ) ) ; f Bound += buf . length ( ) ; buf . set Length ( _ NUM ) ; } break ; case _ STR : buf . append ( f Single Wild Card ) ; break ; default : buf . append ( c ) ; } } if ( buf . length ( ) > _ NUM ) { temp . add Element ( buf . to String ( ) ) ; f Bound += buf . length ( ) ; } f Segments = new  String [ temp . size ( ) ] ; temp . copy Into ( f Segments ) ; }
public static void assert Chi Square Accept (  String [ ] value Labels , double [ ] expected , long [ ] observed , double alpha ) { if ( chi Square Test ( expected , observed ) <= alpha ) {  String Builder msg Buffer = new  String Builder ( ) ;  Decimal Format df = new  Decimal Format ( _ STR ) ; msg Buffer . append ( _ STR ) ; msg Buffer . append ( _ STR ) ; msg Buffer . append ( chi Square Test ( expected , observed ) ) ; msg Buffer . append ( _ STR ) ; msg Buffer . append ( chi Square ( expected , observed ) ) ; msg Buffer . append ( _ STR ) ; msg Buffer . append ( _ STR ) ; for ( int i = _ NUM ; i < expected . length ; i ++ ) { msg Buffer . append ( value Labels [ i ] ) ; msg Buffer . append ( _ STR ) ; msg Buffer . append ( df . format ( expected [ i ] ) ) ; msg Buffer . append ( _ STR ) ; msg Buffer . append ( observed [ i ] ) ; msg Buffer . append ( _ STR ) ; } msg Buffer . append ( _ STR ) ; msg Buffer . append ( alpha ) ; msg Buffer . append ( _ STR ) ;  Assert . fail ( msg Buffer . to String ( ) ) ; } }
public static void assert Diagonally Dominant (  IDouble Matrix mat ) { assert Square ( mat ) ; for ( int i = _ NUM ; i < mat . get Row Num ( ) ; ++ i ) { final double d = mat . get ( i , i ) ; if (  Double . is Na N ( d ) ) { continue ; } for ( int j = _ NUM ; j < mat . get Row Num ( ) ; ++ j ) { double v ; v = mat . get ( i , j ) ; if ( !  Double . is Na N ( v ) && v > d ) { final  String msg =  String . format ( _ STR , i , j , v , i , i , d , d - v ) ; throw new  Ade Core Illegal Argument Exception ( msg ) ; } v = mat . get ( j , i ) ; if ( !  Double . is Na N ( v ) && v > d ) { final  String msg =  String . format ( _ STR , j , i , v , i , i , d ) ; throw new  Ade Core Illegal Argument Exception ( msg ) ; } } } }
protected void notify Connection Listeners ( int type ,  Exception ex ) {  Iterator <  Connection Listener > iter ;  Connection Listener l ; iter = m_ Connection Listeners . iterator ( ) ; while ( iter . has Next ( ) ) { l = iter . next ( ) ; l . connection Change ( new  Connection Event ( this , type , m_ Db Utils , ex ) ) ; } }
public  Percentiles percentiles (  Constant Range range ) {  Sorted Set <  Constant > sorted = values ( ) ;  Sorted Set <  Constant > contained = new  Tree Set <  Constant > ( ) ;  Constant prev = null ; for (  Constant pct : sorted ) { if ( range . contains ( pct ) ) { contained . add ( pct ) ; } else if ( contained . is Empty ( ) ) prev = pct ; } if ( contained . is Empty ( ) ) return null ; double prev Percent = prev == null ? _ NUM : pcts . get ( prev ) ; double total Percent = pcts . get ( contained . last ( ) ) - prev Percent ;  Map <  Constant ,  Double > new Pcts = new  Hash Map <  Constant ,  Double > ( ) ; for (  Constant p : contained ) new Pcts . put ( p , ( pcts . get ( p ) - prev Percent ) / total Percent ) ; return new  Percentiles ( new Pcts ) ; }
public static void close If Not Null (  Closeable closeable ) { if ( closeable != null ) { try { closeable . close ( ) ; } catch (  IOException ignored ) { } } }
@  Override public boolean implies (  Protection Domain pd ,  Permission p ) {  Policy Info pi = policy Info . get ( ) ;  Protection Domain Cache pd Map = pi . get Pd Mapping ( ) ;  Permission Collection pc = pd Map . get ( pd ) ; if ( pc != null ) { return pc . implies ( p ) ; } pc = get Permissions ( pd ) ; if ( pc == null ) { return _ BOOL ; } pd Map . put ( pd , pc ) ; return pc . implies ( p ) ; }
public static int write Byte Array ( final byte [ ] tgt , final int tgt Offset , final byte [ ] src , final int src Offset , final int src Length ) { byte [ ] vint = vint To Bytes ( src Length ) ;  System . arraycopy ( vint , _ NUM , tgt , tgt Offset , vint . length ) ; int offset = tgt Offset + vint . length ;  System . arraycopy ( src , src Offset , tgt , offset , src Length ) ; return offset + src Length ; }
public static  Configuration load (  String path ,  Class Loader class Loader ,  Consumer <  String > logger ) throws  IOException { try (  Input Stream stream =  Io Util . get Resource As Stream ( path , class Loader , null , null , logger ) ) {  Properties props = new  Properties ( ) ; if ( stream != null ) { props . load ( stream ) ; } return from ( props ) ; } }
@  Override public boolean equals (  Object o ) { if ( o instanceof  Graph .  Node ) {  Graph < ? , ? > .  Node n = (  Graph < ? , ? > .  Node ) o ; return content . equals ( n . content ) && children . equals ( n . children ) && attributes . equals ( n . attributes ) ; } return _ BOOL ; }
public final static  Name Value Pair [ ] parse Parameters ( final  String value ,  Header Value Parser parser ) throws  Parse Exception { if ( value == null ) { throw new  Illegal Argument Exception ( _ STR ) ; } if ( parser == null ) parser =  Save Header Value Parser .  DEFAULT ;  Char Array Buffer buffer = new  Char Array Buffer ( value . length ( ) ) ; buffer . append ( value ) ;  Save Parser Cursor cursor = new  Save Parser Cursor ( _ NUM , value . length ( ) ) ; return parser . parse Parameters ( buffer , cursor ) ; }
private void add Left Paren V (  AST ast ,  PCal Location loc ) { if ( ast . get Origin ( ) == null ) { return ; } if ( loc != null ) { mapping Vector Next Line . add Element ( new  Mapping Object .  Left Paren ( loc ) ) ; } else { add Left Paren ( ast . get Origin ( ) ) ; } }
public  String parse (  String input Template ,  String intput Encoding ,  String output File ,  String output Encoding ,  String object ID ,  Object object ) throws  Exception { if ( object ID != null && object != null ) { control Context . put ( object ID , object ) ; }  Template template = get Template ( input Template , input Encoding != null ? input Encoding : this . input Encoding ) ; if ( output File == null || output File . equals ( _ STR ) ) {  String Writer sw = new  String Writer ( ) ; template . merge ( control Context , sw ) ; return sw . to String ( ) ; } else {  Writer writer = null ; if ( writers . get ( output File ) == null ) { writer = get Writer ( get Output Path ( ) +  File . separator + output File , output Encoding != null ? output Encoding : this . output Encoding ) ; writers . put ( output File , writer ) ; } else { writer = (  Writer ) writers . get ( output File ) ; }  Velocity Context vc = new  Velocity Context ( control Context ) ; template . merge ( vc , writer ) ; return _ STR ; } }
public  JMXControl Service (  String domain ,  Hashtable <  String ,  String > additional Keys ) { mbs =  Management Factory . get Platform MBean Server ( ) ; this . domain = domain ; this . additional Keys = additional Keys ; }
public synchronized void add Remote Tcp Server (  Remote Tcp Server server ) {  Queue <  Remote Tcp Server > queue = remote Current Servers . get ( server . get Address ( ) ) ; if ( queue == null ) { queue = new  Concurrent Linked Queue < > ( ) ; remote Current Servers . put ( server . get Address ( ) , queue ) ; } queue . add ( server ) ; }
protected void add Text Editor ( ) {  String new Label =  JOption Pane . show Input Dialog ( this ,  Bundle . get Message ( _ STR ) ) ; if ( new Label == null ) { return ; }  Positionable Label l = add Label ( new Label ) ; l . set Positionable ( _ BOOL ) ; }
protected  Completion Stage <  Result > on Dev Server Error (  Http .  Request Header request ,  Useful Exception exception ) {  Object Node json Error =  Json . new Object ( ) ; final  Throwable cause = exception . cause ; final  String description = exception . description ; final  String id = exception . id ; final  String title = exception . title ; json Error . put ( _ STR , description ) ; json Error . put ( _ STR , title ) ; json Error . put ( _ STR , id ) ; json Error . put ( _ STR , exception . get Message ( ) ) ; json Error . set ( _ STR , causes To Json ( cause ) ) ; return  Completable Future . completed Future (  Results . internal Server Error ( json Error ) ) ; }
private void read Object (  Object Input Stream in ) throws  Class Not Found Exception ,  IOException { in . default Read Object ( ) ; iter = col . iterator ( ) ; }
private void paint Foreground Pressed (  Graphics2 D g , int width , int height ) {  Shape s = decode Arrow Path ( width , height ) ; g . set Paint ( pressed Color ) ; g . fill ( s ) ; }
public boolean by Pass Control To Processor ( boolean flag ) { return _ BOOL ; }
private void maybe Show Popup ( final  Mouse Event event ) { if ( event . is Popup Trigger ( ) ) { final  JPopup Menu menu = new  JPopup Menu ( ) ; menu . add ( new  Copy Log Action ( m_text Area ) ) ; menu . show ( event . get Component ( ) , event . get X ( ) , event . get Y ( ) ) ; } }
private boolean take Task ( ) { int size = tasks . size ( ) ; for ( int i = first Pending ; i < size ; i ++ ) {  Task t = tasks . get ( i ) ; if ( ! run After ( t , i ) ) { if ( i > first Pending ) { tasks . remove ( i ) ; tasks . add ( first Pending , t ) ; } first Pending ++ ; task = t ; return _ BOOL ; } } return _ BOOL ; }
protected  Transferable create Transferable (  JComponent c ) { if ( c instanceof  JTree ) { tree = (  JTree ) c ;  Tree Path [ ] paths = tree . get Selection Paths ( ) ; if ( paths == null || paths . length == _ NUM ) { return null ; }  String Buffer plain Buf = new  String Buffer ( ) ;  String Buffer html Buf = new  String Buffer ( ) ; html Buf . append ( _ STR ) ;  Tree Model model = tree . get Model ( ) ;  Tree Path last Path = null ;  Tree Path [ ] display Paths = get Display Order Paths ( paths ) ; for (  Tree Path path : display Paths ) {  Object node = path . get Last Path Component ( ) ; boolean leaf = model . is Leaf ( node ) ;  String label = get Display String ( path , _ BOOL , leaf ) ; plain Buf . append ( label + _ STR ) ; html Buf . append ( _ STR + label + _ STR ) ; } plain Buf . delete Char At ( plain Buf . length ( ) - _ NUM ) ; html Buf . append ( _ STR ) ; tree = null ; return new  Basic Transferable ( plain Buf . to String ( ) , html Buf . to String ( ) ) ; } return null ; }
@  Override protected synchronized  Class < ? > load Class (  String name , boolean resolve ) throws  Class Not Found Exception {  Class c = find Loaded Class ( name ) ; if ( ( c == null ) && ( my Loader != null ) && ( my Loader != target Loader ) ) { try { c = my Loader . load Class ( name ) ; } catch (  Class Not Found Exception ignored ) { if (  LOGGER . is Loggable (  Level .  FINEST ) ) {  LOGGER . log (  Level .  FINEST , _ STR , ignored ) ; } } } if ( c == null ) { c = super . load Class ( name , _ BOOL ) ; } if ( resolve ) { resolve Class ( c ) ; } return c ; }
Rules (  Workspace workspace ) { this . root = workspace . get Root ( ) ; this . team Hook = workspace . get Team Hook ( ) ; workspace . add Lifecycle Listener ( this ) ; }
public void remove ( @  Non Null  T item ) { int remove Index ; synchronized ( lock ) { if ( items == null ) { return ; } remove Index = items . index Of ( item ) ; if ( remove Index != - _ NUM ) { items . remove ( remove Index ) ; } } if ( notify On Change && remove Index != - _ NUM ) { notify Item Removed ( remove Index ) ; } }
private void process Client Reconnect Message (  Tcp Discovery Client Reconnect Message msg ) {  UUID node Id = msg . creator Node Id ( ) ;  UUID loc Node Id = get Local Node Id ( ) ; boolean is Loc Node Router = loc Node Id . equals ( msg . router Node Id ( ) ) ; if ( ! msg . verified ( ) ) {  Tcp Discovery Node node = ring . node ( node Id ) ; assert node == null || node . is Client ( ) ; if ( node != null ) { node . client Router Node Id ( msg . router Node Id ( ) ) ; node . alive Check ( spi . max Missed Client Hbs ) ; } if ( is Local Node Coordinator ( ) ) { msg . verify ( loc Node Id ) ; if ( node != null ) {  Collection <  Tcp Discovery Abstract Message > pending = msg Hist . messages ( msg . last Message Id ( ) , node ) ; if ( pending != null ) { msg . pending Messages ( pending ) ; msg . success ( _ BOOL ) ; if ( log . is Debug Enabled ( ) ) log . debug ( _ STR + _ STR + loc Node Id + _ STR + node Id + _ STR ) ; } else { if ( log . is Debug Enabled ( ) ) log . debug ( _ STR + _ STR + loc Node Id + _ STR + node Id + _ STR ) ;  Tcp Discovery Node Failed Message node Failed Msg = new  Tcp Discovery Node Failed Message ( loc Node Id , node . id ( ) , node . internal Order ( ) ) ; process Node Failed Message ( node Failed Msg ) ; if ( node Failed Msg . verified ( ) ) msg Hist . add ( node Failed Msg ) ; } } else if ( log . is Debug Enabled ( ) ) log . debug ( _ STR + node Id + _ STR ) ; if ( is Loc Node Router ) {  Client Message Worker wrk = client Msg Workers . get ( node Id ) ; if ( wrk != null ) wrk . add Message ( msg ) ; else if ( log . is Debug Enabled ( ) ) log . debug ( _ STR + loc Node Id + _ STR + node Id + _ STR ) ; } else { if ( send Message To Remotes ( msg ) ) send Message Across Ring ( msg ) ; } } else { if ( send Message To Remotes ( msg ) ) send Message Across Ring ( msg ) ; } } else { if ( is Local Node Coordinator ( ) ) add Message ( new  Tcp Discovery Discard Message ( loc Node Id , msg . id ( ) , _ BOOL ) ) ; if ( is Loc Node Router ) {  Client Message Worker wrk = client Msg Workers . get ( node Id ) ; if ( wrk != null ) wrk . add Message ( msg ) ; else if ( log . is Debug Enabled ( ) ) log . debug ( _ STR + loc Node Id + _ STR + node Id + _ STR ) ; } else { if ( ring . has Remote Nodes ( ) && ! is Local Node Coordinator ( ) ) send Message Across Ring ( msg ) ; } } }
protected int parse And Add Node (  Xml Resource Parser parser ,  Hash Map <  String ,  Tag Parser > tag Parser Map ,  Array List <  Long > screen Ids ) throws  Xml Pull Parser Exception ,  IOException { if (  TAG_ INCLUDE . equals ( parser . get Name ( ) ) ) { final int res Id = get Attribute Resource Value ( parser ,  ATTR_ WORKSPACE , _ NUM ) ; if ( res Id != _ NUM ) { return parse Layout ( res Id , screen Ids ) ; } else { return _ NUM ; } } m Values . clear ( ) ; parse Container And Screen ( parser , m Temp ) ; final long container = m Temp [ _ NUM ] ; final long screen Id = m Temp [ _ NUM ] ; m Values . put (  Launcher Settings .  Favorites .  CONTAINER , container ) ; m Values . put (  Launcher Settings .  Favorites .  SCREEN , screen Id ) ; m Values . put (  Launcher Settings .  Favorites .  CELLX , get Attribute Value ( parser ,  ATTR_ X ) ) ; m Values . put (  Launcher Settings .  Favorites .  CELLY , get Attribute Value ( parser ,  ATTR_ Y ) ) ;  Tag Parser tag Parser = tag Parser Map . get ( parser . get Name ( ) ) ; if ( tag Parser == null ) { if (  LOGD )  Log . d (  TAG , _ STR + parser . get Name ( ) ) ; return _ NUM ; } long new Element Id = tag Parser . parse And Add ( parser ) ; if ( new Element Id >= _ NUM ) { if ( ! screen Ids . contains ( screen Id ) && container ==  Launcher Settings .  Favorites .  CONTAINER_ DESKTOP ) { screen Ids . add ( screen Id ) ; } return _ NUM ; } return _ NUM ; }
public static float round Decimal ( float value , double places ) { double multiplier =  Math . pow ( _ NUM , places ) ; value *= multiplier ; return ( float ) (  Math . round ( value ) / multiplier ) ; }
public void test Scalar Arrays ( ) throws  Exception {  Object Mapper m = new  Object Mapper ( ) ; m . enable Default Typing (  Object Mapper .  Default Typing .  JAVA_ LANG_ OBJECT ) ;  Object [ ] input = new  Object [ ] { _ STR , new  Date ( _ NUM ) , null ,  Integer . value Of ( _ NUM ) } ;  String json = m . write Value As String ( input ) ; assert Equals ( _ STR , json ) ;  Object [ ] output = m . read Value ( json ,  Object [ ] . class ) ; assert Array Equals ( input , output ) ; }
protected void reconnect ( ) { cancel Reconnection Timer ( ) ; connect ( ) ; }
private void profiles CB ( ) {  Profile profile ;  String host ; profile = (  Profile ) profiles Combo Box . get Selected Item ( ) ; if ( profile != null ) { host = profile . get Host ( ) ; server Field . set Text ( host ) ; server Port Field . set Text (  String . value Of ( profile . get Port ( ) ) ) ; username Field . set Text ( profile . get User ( ) ) ; password Field . set Text ( profile . get Password ( ) ) ; } else { server Port Field . set Text (  String . value Of (  Profile .  DEFAULT_ SERVER_ PORT ) ) ; username Field . set Text ( _ STR ) ; password Field . set Text ( _ STR ) ; } }
public synchronized void open Write ( ) throws  Replicator Exception ,  Interrupted Exception { if ( ! file . exists ( ) ) { throw new  THLException ( _ STR + file . get Name ( ) ) ; } try {  Buffered File Data Input bfdi = new  Buffered File Data Input ( file , buffer Size ) ; check File Header ( bfdi ) ; bfdi . close ( ) ; data Output = new  Buffered File Data Output ( file , buffer Size ) ; } catch (  IOException e ) { throw new  THLException ( _ STR + file . get Name ( ) , e ) ; } mode =  Access Mode . write ; if ( log Flush Task != null ) log Flush Task . add Log File ( this ) ; }
public float maximum Absolute ( ) { if (  Math . abs ( m Left ) >  Math . abs ( m Right ) ) { return  Math . abs ( m Left ) ; } else { return  Math . abs ( m Right ) ; } }
private double determine Alpha Min ( int n , double [ ] alpha_min ,  Hyper Bounding Box interval ) { double alpha_n = extremum_alpha_n ( n , alpha_min ) ; double lower = interval . get Min ( n ) ; double upper = interval . get Max ( n ) ; double [ ] alpha_extreme = new double [ alpha_min . length ] ;  System . arraycopy ( alpha_min , n , alpha_extreme , n , alpha_extreme . length - n ) ; alpha_extreme [ n ] = alpha_n ;  Extremum Type type = extremum Type ( n , alpha_extreme , interval ) ; if ( type . equals (  Extremum Type .  MINIMUM ) || type . equals (  Extremum Type .  CONSTANT ) ) { if ( lower <= alpha_n && alpha_n <= upper ) { return alpha_n ; } else if ( alpha_n < lower ) { return lower ; } else { if ( alpha_n <= upper ) { throw new  Illegal State Exception ( _ STR ) ; } return upper ; } } else { if ( lower <= alpha_n && alpha_n <= upper ) { if ( alpha_n - lower <= upper - alpha_n ) { return upper ; } else { return lower ; } } else if ( alpha_n < lower ) { return upper ; } else { if ( alpha_n <= upper ) { throw new  Illegal State Exception ( _ STR ) ; } return lower ; } } }
public static  String map2 OID (  String alg Name ) { check Cache Version ( ) ;  String result = alg2 Oid Map . get ( alg Name . to Upper Case (  Locale .  US ) ) ; if ( result != null ) { return result ; }  Alg Name Mapper Source s = source ; if ( s != null ) { return s . map Name To Oid ( alg Name ) ; } return null ; }
@  Override public  Generator <  IMulti Point > construct (  String [ ] args ) { return new  Uniform Generator (  Integer . value Of ( args [ _ NUM ] ) ,  Double . value Of ( args [ _ NUM ] ) ) ; }
@  Override protected void process Mouse Event (  Mouse Event evt ) { super . process Mouse Event ( evt ) ; if ( evt . get ID ( ) ==  Mouse Event .  MOUSE_ CLICKED ) fire Action Performed ( new  Action Event ( this ,  Action Event .  ACTION_ PERFORMED , get Normal Text ( ) ) ) ; }
protected static void save Tags ( final  CConnection connection , final  List <  INavi View Node > nodes , final int first Node ) throws  SQLException { int counter = first Node ; final  String delete Statement = _ STR +  CTable Names .  TAGGED_ NODES_ TABLE + _ STR ; final  String insert Statement = _ STR +  CTable Names .  TAGGED_ NODES_ TABLE + _ STR ; boolean is First = _ BOOL ; final  String Builder range = new  String Builder ( ) ; for ( int i = _ NUM ; i < nodes . size ( ) ; i ++ ) { if ( is First ) { range . append ( counter ) ; is First = _ BOOL ; continue ; } range . append ( _ STR ) ; range . append ( counter ) ; ++ counter ; } if ( range . length ( ) != _ NUM ) { connection . execute Update (  String . format ( delete Statement , range . to String ( ) ) , _ BOOL ) ; } counter = first Node ; final  String Builder insert = new  String Builder ( ) ; is First = _ BOOL ; for ( final  INavi View Node node : nodes ) { final  Iterator <  CTag > it = node . get Tags Iterator ( ) ; while ( it . has Next ( ) ) { final  CTag tag = it . next ( ) ; insert . append ( is First ? _ STR : _ STR ) ; insert . append ( _ STR ) ; insert . append ( counter ) ; insert . append ( _ STR ) ; insert . append ( tag . get Id ( ) ) ; insert . append ( _ STR ) ; is First = _ BOOL ; } ++ counter ; } if ( insert . length ( ) != _ NUM ) { connection . execute Update (  String . format ( insert Statement , insert . to String ( ) ) , _ BOOL ) ; } }
@  Suppress Warnings ( _ STR ) public static <  T >  Sequence <  T > wrap End (  Sequence <  T > sequence ,  T end Token ) {  Object [ ] arr = new  Object [ sequence . size ( ) + _ NUM ] ;  System . arraycopy ( sequence . elements ( ) , _ NUM , arr , _ NUM , sequence . size ( ) ) ; arr [ sequence . size ( ) ] = end Token ; return new  Array Sequence <  T > ( _ BOOL , (  T [ ] ) arr ) ; }
View find Hidden Non Removed View ( int position , int type ) { final int count = m Hidden Views . size ( ) ; for ( int i = _ NUM ; i < count ; i ++ ) { final  View view = m Hidden Views . get ( i ) ;  Recycler View .  View Holder holder = m Callback . get Child View Holder ( view ) ; if ( holder . get Position ( ) == position && ! holder . is Invalid ( ) && ( type ==  Recycler View .  INVALID_ TYPE || holder . get Item View Type ( ) == type ) ) { return view ; } } return null ; }
private void update Filter ( ) {  String game = null ; boolean favorites = filter Favorites . is Selected ( ) ; if ( filter Current Game . is Selected ( ) ) { game = current Game ; } table . filter ( game , favorites ) ; }
public void filled Rectangle ( double x , double y , double half Width , double half Height ) { if ( half Width < _ NUM ) throw new  Illegal Argument Exception ( _ STR ) ; if ( half Height < _ NUM ) throw new  Illegal Argument Exception ( _ STR ) ; double xs = scale X ( x ) ; double ys = scale Y ( y ) ; double ws = factor X ( _ NUM * half Width ) ; double hs = factor Y ( _ NUM * half Height ) ; if ( ws <= _ NUM && hs <= _ NUM ) pixel ( x , y ) ; else offscreen . fill ( new  Rectangle2 D .  Double ( xs - ws / _ NUM , ys - hs / _ NUM , ws , hs ) ) ; draw ( ) ; }
public  Pair <  Node ,  Node > crossover (  Node individual A ,  Node individual B ) { boolean is Good = _ BOOL ;  Node new Individual A = null ;  Node new Individual B = null ; for ( int tries = _ NUM ; tries < _ NUM ; tries ++ ) { new Individual A = individual A . clone Tree ( ) ; new Individual B = individual B . clone Tree ( ) ;  Node random Node A = pick Random Node ( new Individual A ) ;  Node random Node B = pick Random Node ( new Individual B ) ; if ( random Node A != null && random Node B != null ) {  Node a Parent = random Node A . get Parent ( ) ;  List <  Node > a Childs = a Parent . get Childrens ( ) ; int a Index = a Childs . index Of ( random Node A ) ;  Node b Parent = random Node B . get Parent ( ) ;  List <  Node > b Childs = b Parent . get Childrens ( ) ; int b Index = b Childs . index Of ( random Node B ) ; a Childs . set ( a Index , random Node B ) ; b Childs . set ( b Index , random Node A ) ; random Node A . set Parent ( b Parent ) ; random Node B . set Parent ( a Parent ) ; if ( check Max Depth ( new Individual A , _ NUM ) && check Max Depth ( new Individual B , _ NUM ) && new Individual A . is Valid ( ) && new Individual B . is Valid ( ) ) { is Good = _ BOOL ; break ; } } } if ( is Good ) { return new  Pair <  Node ,  Node > ( new Individual A , new Individual B ) ; } else { return null ; } }
private void start Item List Item (  String Builder result ,  String root Id ,  String item Id ) { result . append ( _ STR ) ; result . append ( _ STR + item Id + _ STR + root Id + _ STR + item Id + _ STR ) ; }
private long compute Number Of Partitions ( int num Tasks , long total Points In Range , int min Datapoints Per Task ) { final long max Tasks By Datapoint Restriction = total Points In Range / min Datapoints Per Task ; final long desired Num Tasks =  Math . max ( num Tasks , _ NUM ) ; long nr Sub Ranges =  Math . min ( max Tasks By Datapoint Restriction , desired Num Tasks ) ; return  Math . max ( _ NUM , nr Sub Ranges ) ; }
@  Override public void mouse Clicked (  Mouse Event e ) { if ( mouse Clicked Listener != null && e . get Click Count ( ) == _ NUM && ! e . is Alt Down ( ) && ! e . is Alt Graph Down ( ) ) { mouse Clicked Listener . mouse Clicked ( ) ; } }
List <  File > add Collection Files (  File new Basedir ) throws  IOException { final  Directory Scanner ds = new  Directory Scanner ( ) ; ds . set Basedir ( new Basedir ) ; if ( this . includes != null && this . includes . length > _ NUM ) { ds . set Includes ( this . includes ) ; } else { ds . set Includes (  DEFAULT_ INCLUDES ) ; } ds . set Excludes ( this . excludes ) ; ds . add Default Excludes ( ) ; ds . set Case Sensitive ( _ BOOL ) ; ds . set Follow Symlinks ( _ BOOL ) ; ds . scan ( ) ;  List <  File > found Files = new  Array List < > ( ) ; for (  String filename : ds . get Included Files ( ) ) { found Files . add ( new  File ( new Basedir , filename ) ) ; } return found Files ; }
public int size ( ) { return m Selected Widgets . size ( ) ; }
protected  Simple Java File Object (  URI uri ,  Kind kind ) { uri . get Class ( ) ; kind . get Class ( ) ; if ( uri . get Path ( ) == null ) throw new  Illegal Argument Exception ( _ STR + uri ) ; this . uri = uri ; this . kind = kind ; }
public int to Int (  Element el ,  String attribute Name , int default Value ) {  String value = el . get Attribute ( attribute Name ) ; if ( value == null ) return default Value ; int int Value =  Caster . to Int Value ( value ,  Integer .  MIN_ VALUE ) ; if ( int Value ==  Integer .  MIN_ VALUE ) return default Value ; return int Value ; }
private  Object cast (  Resource Type .  Data Type type ,  String column ,  Result Set row ) throws  SQLException { if (  Resource Type .  Data Type .  BOOLEAN == type ) { return row . get Boolean ( column ) ; } else if (  Resource Type .  Data Type .  STRING == type ) { return row . get String ( column ) ; } else if (  Resource Type .  Data Type .  LONG == type ) { return row . get Long ( column ) ; } else if (  Resource Type .  Data Type .  DOUBLE == type ) { return row . get Double ( column ) ; } return null ; }
public static  Cache .  Entry make Random Cache Entry ( byte [ ] data , boolean is Expired , boolean needs Refresh ) {  Random random = new  Random ( ) ;  Cache .  Entry entry = new  Cache .  Entry ( ) ; if ( data != null ) { entry . data = data ; } else { entry . data = new byte [ random . next Int ( _ NUM ) ] ; } entry . etag =  String . value Of ( random . next Long ( ) ) ; entry . last Modified = random . next Long ( ) ; entry . ttl = is Expired ? _ NUM :  Long .  MAX_ VALUE ; entry . soft Ttl = needs Refresh ? _ NUM :  Long .  MAX_ VALUE ; return entry ; }
@  Override public  String execute ( ) { return  INPUT ; }
public static  String decode Endpoint Operation (  String endpoint , boolean stripped ) { int ind = endpoint . index Of ( _ STR ) ; if ( ind != - _ NUM ) { if ( stripped ) { return endpoint . substring ( ind + _ NUM , endpoint . length ( ) - _ NUM ) ; } return endpoint . substring ( ind ) ; } return null ; }
@  Suppress Warnings ( _ STR ) public static void register (  String algorithm URI ,  String implementing Class ) throws  Algorithm Already Registered Exception ,  Class Not Found Exception ,  XMLSignature Exception {  Java Utils . check Register Permission ( ) ; if ( log . is Loggable ( java . util . logging .  Level .  FINE ) ) { log . log ( java . util . logging .  Level .  FINE , _ STR + algorithm URI + _ STR + implementing Class ) ; }  Class < ? extends  Signature Algorithm Spi > registered Class = algorithm Hash . get ( algorithm URI ) ; if ( registered Class != null ) {  Object ex Args [ ] = { algorithm URI , registered Class } ; throw new  Algorithm Already Registered Exception ( _ STR , ex Args ) ; } try {  Class < ? extends  Signature Algorithm Spi > clazz = (  Class < ? extends  Signature Algorithm Spi > )  Class Loader Utils . load Class ( implementing Class ,  Signature Algorithm . class ) ; algorithm Hash . put ( algorithm URI , clazz ) ; } catch (  Null Pointer Exception ex ) {  Object ex Args [ ] = { algorithm URI , ex . get Message ( ) } ; throw new  XMLSignature Exception ( _ STR , ex Args , ex ) ; } }
public static  Properties extract Mapping (  String settings File ) { try {  Document doc =  XMLUtils . get XMLDocument ( settings File ) ;  Properties mapping = extract Mapping (  XMLUtils . get Main Node ( doc ) ) ; return mapping ; } catch (  Runtime Exception e ) { log . warning ( _ STR + e ) ; return new  Properties ( ) ; } }
public boolean contains Explicit Char ( final @  Non Null  Char Sequence input ) { if ( !  Text Utils . is Empty ( input ) ) { for ( int i = _ NUM ; i < input . length ( ) ; i ++ ) { char c = input . char At ( i ) ; if ( is Explicit Char ( c ) ) { return _ BOOL ; } } } return _ BOOL ; }
private void check Collapses ( ) { for (  Iterator i = seg Strings . iterator ( ) ; i . has Next ( ) ; ) {  Segment String ss = (  Segment String ) i . next ( ) ; check Collapses ( ss ) ; } }
private <  T >  Unary Operator <  T > chain Operators (  Stream <  Unary Operator <  T > > operators ) { return operators . reduce (  Unary Operator . identity ( ) , null ) ; }
private void add ( int address ,  Disposition disposition ,  Register Spec spec ) { int reg Num = spec . get Reg ( ) ; result . add ( new  Entry ( address , disposition , spec ) ) ; if ( disposition ==  Disposition .  START ) { regs . put ( spec ) ; end Indices [ reg Num ] = - _ NUM ; } else { regs . remove ( spec ) ; end Indices [ reg Num ] = result . size ( ) - _ NUM ; } }
public static  String convert To Java Class Name (  String name ) { int dot Index = name . index Of ( _ STR ) ; if ( dot Index >= _ NUM ) { name = name . substring ( _ NUM , dot Index ) ; }  String [ ] split = name . split ( _ STR ) ;  String Builder out = new  String Builder ( ) ; for (  String section : split ) { out . append (  String Util . capitalize ( section ) ) ; } return out . to String ( ) ; }
protected void give Table Schema ACopy (  String table Name , int table Type ,  SQLite Database db ) {  String Builder sql = new  String Builder ( _ STR ) ; sql . append (  Const .  Table Schema .  TABLE_ NAME ) ;  Log Util . d (  TAG , _ STR + sql ) ;  Cursor cursor = null ; try { cursor = db . raw Query ( sql . to String ( ) , null ) ; if ( is Needto Give ACopy ( cursor , table Name ) ) {  Content Values values = new  Content Values ( ) ; values . put (  Const .  Table Schema .  COLUMN_ NAME ,  Base Utility . change Case ( table Name ) ) ; values . put (  Const .  Table Schema .  COLUMN_ TYPE , table Type ) ; db . insert (  Const .  Table Schema .  TABLE_ NAME , null , values ) ; } } catch (  Exception e ) { e . print Stack Trace ( ) ; } finally { if ( cursor != null ) { cursor . close ( ) ; } } }
private void add To TT (  String tt SName , boolean start BR ,  Object ... tt O ) { if ( start BR ==  BR ) tooltip String . append ( _ STR ) ; if ( tt O != null ) { tooltip String . append (  Messages . get String ( _ STR + tt SName , tt O ) ) ; } else { tooltip String . append (  Messages . get String ( _ STR + tt SName ) ) ; } }
private void create Migration Rule Page ( ) {  Migration Rule Editor migration Rule Editor = new  Migration Rule Editor ( get Container ( ) , migration Task ) ; int index = add Page ( migration Rule Editor . get Control ( ) ) ; set Page Text ( index , _ STR ) ; task Listeners . add ( migration Rule Editor ) ; }
private void skip (  Pattern pattern ) throws  Decode Exception {  Matcher matcher = pattern . matcher ( gser Value . substring ( pos , length ) ) ; if ( matcher . find ( ) && matcher . group Count ( ) >= _ NUM ) { pos += matcher . end ( _ NUM ) ; } else { final  Localizable Message msg =  WARN_ GSER_ PATTERN_ NO_ MATCH . get ( pattern . pattern ( ) , gser Value . substring ( pos , length ) ) ; throw  Decode Exception . error ( msg ) ; } }
public void push ( final int value ) { if ( value >= - _ NUM && value <= _ NUM ) { mv . visit Insn (  Opcodes .  ICONST_0 + value ) ; } else if ( value >=  Byte .  MIN_ VALUE && value <=  Byte .  MAX_ VALUE ) { mv . visit Int Insn (  Opcodes .  BIPUSH , value ) ; } else if ( value >=  Short .  MIN_ VALUE && value <=  Short .  MAX_ VALUE ) { mv . visit Int Insn (  Opcodes .  SIPUSH , value ) ; } else { mv . visit Ldc Insn ( value ) ; } }
public  File Entry create File (  String name , byte [ ] content ) throws  Forbidden Exception ,  Conflict Exception ,  Server Exception { if ( is Root ( get Virtual File ( ) ) ) { throw new  Forbidden Exception ( _ STR ) ; } return create File ( name , content == null ? null : new  Byte Array Input Stream ( content ) ) ; }
public boolean add Item ( @  Int Range ( from = _ NUM ) int position , @  Non Null  T item ) { if ( item == null ) {  Log . e (  TAG , _ STR ) ; return _ BOOL ; } if (  DEBUG )  Log . v (  TAG , _ STR ) ;  List <  T > items = new  Array List < > ( _ NUM ) ; items . add ( item ) ; return add Items ( position , items ) ; }
public  List <  String > split String With Default Delimiter (  String input String ) {  List <  String > split String = new  Array List < > ( ) ; if ( input String != null ) {  String Tokenizer string Tokenizer = new  String Tokenizer ( input String , configuration Helper . get Property (  Configuration Value .  FIELD_ DATA_ DELIMITER ) ) ; while ( string Tokenizer . has More Elements ( ) ) { split String . add ( string Tokenizer . next Token ( ) ) ; } } return split String ; }
protected final boolean read Available Non Blocking ( ) throws  IOException { char [ ] buffer = my Buffer ;  String Builder token = my Text Buffer ; token . set Length ( _ NUM ) ; boolean read = _ BOOL ; while ( my Reader . ready ( ) ) { int n = my Reader . read ( buffer ) ; if ( n <= _ NUM ) break ; read = _ BOOL ; process Line ( buffer , token , n ) ; } submit Token ( ) ; return read ; }
public  Map <  State ,  Double > thread State Percentages ( ) { final  Map <  State ,  Double > conditions = new  Hash Map <  State ,  Double > ( ) ; for (  State state :  State . values ( ) ) { conditions . put ( state , _ NUM ) ; } final long [ ] all Thread Ids = threads . get All Thread Ids ( ) ; final  Thread Info [ ] all Threads = threads . get Thread Info ( all Thread Ids ) ; int live Count = _ NUM ; for (  Thread Info info : all Threads ) { if ( info != null ) { final  State state = info . get Thread State ( ) ; conditions . put ( state , conditions . get ( state ) + _ NUM ) ; live Count ++ ; } } for (  State state : new  Array List <  State > ( conditions . key Set ( ) ) ) { conditions . put ( state , conditions . get ( state ) / live Count ) ; } return  Collections . unmodifiable Map ( conditions ) ; }
private static  Content Impl parse Content (  Ole Blob Impl blob ) throws  IOException {  Byte Buffer bb =  Page Channel . wrap ( blob . get Bytes ( ) ) ; if ( ( bb . remaining ( ) < _ NUM ) || ( bb . get Short ( ) !=  PACKAGE_ SIGNATURE ) ) { return new  Unknown Content Impl ( blob ) ; } int header Size = bb . get Short ( ) ; bb . get Int ( ) ; int pretty Name Len = bb . get Short ( ) ; int class Name Len = bb . get Short ( ) ; int pretty Name Off = bb . get Short ( ) ; int class Name Off = bb . get Short ( ) ; bb . get Int ( ) ;  String pretty Name = read Str ( bb , pretty Name Off , pretty Name Len ) ;  String class Name = read Str ( bb , class Name Off , class Name Len ) ; bb . position ( header Size ) ; int ole Ver = bb . get Int ( ) ; bb . get Int ( ) ; if ( ole Ver !=  OLE_ VERSION ) { return new  Unknown Content Impl ( blob ) ; } int type Name Len = bb . get Int ( ) ;  String type Name = read Str ( bb , bb . position ( ) , type Name Len ) ; bb . get Long ( ) ; int data Block Len = bb . get Int ( ) ; int data Block Pos = bb . position ( ) ; if (  SIMPLE_ PACKAGE_ TYPE . equals Ignore Case ( type Name ) ) { return create Simple Package Content ( blob , pretty Name , class Name , type Name , bb , data Block Len ) ; } if ( (  COMPOUND_ FACTORY != null ) && ( bb . remaining ( ) >=  COMPOUND_ STORAGE_ SIGNATURE . length ) &&  Byte Util . matches Range ( bb , bb . position ( ) ,  COMPOUND_ STORAGE_ SIGNATURE ) ) { return  COMPOUND_ FACTORY . create Compound Package Content ( blob , pretty Name , class Name , type Name , bb , data Block Len ) ; } return new  Other Content Impl ( blob , pretty Name , class Name , type Name , data Block Pos , data Block Len ) ; }
@  Override public  Instances define Data Format ( ) throws  Exception { set Options ( get Options ( ) ) ; check Coverage ( ) ;  Random random = new  Random ( get Seed ( ) ) ; set Random ( random ) ;  Instances dataset ;  Array List <  Attribute > attributes = new  Array List <  Attribute > ( _ NUM ) ;  Attribute attribute ; boolean class Flag = get Class Flag ( ) ;  Array List <  String > class Values = null ; if ( class Flag ) { class Values = new  Array List <  String > ( get Clusters ( ) . length ) ; }  Array List <  String > bool Values = new  Array List <  String > ( _ NUM ) ; bool Values . add ( _ STR ) ; bool Values . add ( _ STR ) ;  Array List <  String > nom Values = null ; for ( int i = _ NUM ; i < get Num Attributes ( ) ; i ++ ) { if ( m_boolean Cols . is In Range ( i ) ) { attribute = new  Attribute ( _ STR + i , bool Values ) ; } else if ( m_nominal Cols . is In Range ( i ) ) { nom Values = new  Array List <  String > ( m_num Values [ i ] ) ; for ( int j = _ NUM ; j < m_num Values [ i ] ; j ++ ) { nom Values . add ( _ STR + j ) ; } attribute = new  Attribute ( _ STR + i , nom Values ) ; } else { attribute = new  Attribute ( _ STR + i ) ; } attributes . add ( attribute ) ; } if ( class Flag ) { for ( int i = _ NUM ; i < get Clusters ( ) . length ; i ++ ) { class Values . add ( _ STR + i ) ; } attribute = new  Attribute ( _ STR , class Values ) ; attributes . add ( attribute ) ; } dataset = new  Instances ( get Relation Name To Use ( ) , attributes , _ NUM ) ; if ( class Flag ) { dataset . set Class Index ( m_ Num Attributes ) ; }  Instances format = new  Instances ( dataset , _ NUM ) ; set Dataset Format ( format ) ; for ( int i = _ NUM ; i < get Clusters ( ) . length ; i ++ ) {  Subspace Cluster Definition cl = (  Subspace Cluster Definition ) get Clusters ( ) [ i ] ; cl . set Num Instances ( random ) ; cl . set Parent ( this ) ; } return dataset ; }
@  Override public  List <  Match Result > find (  String str , int max Results ) { str = str . trim ( ) ;  List <  Match Result > results = new  Array List <  Match Result > ( ) ; int start = _ NUM ; while ( start != - _ NUM ) { start = str . index Of ( string , start ) ; if ( start != - _ NUM ) { int end = start + string . length ( ) ; if ( ! whole ||  String Utils . is Delimited ( str , start , end ) ) { results . add ( new  Match Result ( start , end ) ) ; } if ( results . size ( ) >= max Results ) { return results ; } start = end ; } } return results ; }
public static  Map <  String ,  String [ ] > to Multi Map (  Named List params ) {  Hash Map <  String ,  String [ ] > map = new  Hash Map < > ( ) ; for ( int i = _ NUM ; i < params . size ( ) ; i ++ ) {  String name = params . get Name ( i ) ;  Object val = params . get Val ( i ) ; if ( val instanceof  String [ ] ) {  Multi Map Solr Params . add Param ( name , (  String [ ] ) val , map ) ; } else if ( val instanceof  List ) {  List l = (  List ) val ;  String [ ] s = new  String [ l . size ( ) ] ; for ( int j = _ NUM ; j < l . size ( ) ; j ++ ) { s [ j ] = l . get ( j ) == null ? null :  String . value Of ( l . get ( j ) ) ; }  Multi Map Solr Params . add Param ( name , s , map ) ; } else {  Multi Map Solr Params . add Param ( name , val . to String ( ) , map ) ; } } return map ; }
public  Statement using (  Object ... columns ) { statement . append ( _ STR ) ; append Clauses ( columns ) ; statement . append ( _ STR ) ; return this ; }
public static  String create Cnonce ( ) { final  Secure Random rnd = new  Secure Random ( ) ; final byte [ ] tmp = new byte [ _ NUM ] ; rnd . next Bytes ( tmp ) ; return encode ( tmp ) ; }
public static  Geo Time Serie normalize (  Geo Time Serie gts ) { if ( (  TYPE .  DOUBLE != gts . get Type ( ) &&  TYPE .  LONG != gts . get Type ( ) ) || _ NUM == gts . values ) { return gts . clone ( ) ; } double dmin =  Double .  POSITIVE_ INFINITY ; double dmax =  Double .  NEGATIVE_ INFINITY ; long lmin =  Long .  MAX_ VALUE ; long lmax =  Long .  MIN_ VALUE ; if (  TYPE .  LONG == gts . get Type ( ) ) { for ( int i = _ NUM ; i < gts . values ; i ++ ) { long value = ( long )  GTSHelper . value At Index ( gts , i ) ; if ( value > lmax ) { lmax = value ; } if ( value < lmin ) { lmin = value ; } } } else { for ( int i = _ NUM ; i < gts . values ; i ++ ) { double value = ( double )  GTSHelper . value At Index ( gts , i ) ; if ( value > dmax ) { dmax = value ; } if ( value < dmin ) { dmin = value ; } } } boolean constant = _ BOOL ; if ( lmin == lmax || dmin == dmax ) { constant = _ BOOL ; }  Geo Time Serie normalized = new  Geo Time Serie ( gts . lastbucket , gts . bucketcount , gts . bucketspan , gts . values ) ; normalized . set Name ( gts . get Name ( ) ) ; normalized . set Labels ( gts . get Labels ( ) ) ; for ( int i = _ NUM ; i < gts . values ; i ++ ) {  Object value ; if ( constant ) { value = _ NUM ; } else if (  TYPE .  LONG == gts . get Type ( ) ) { value = ( ( long )  GTSHelper . value At Index ( gts , i ) - lmin ) / ( double ) ( lmax - lmin ) ; } else { value = ( ( double )  GTSHelper . value At Index ( gts , i ) - dmin ) / ( double ) ( dmax - dmin ) ; }  GTSHelper . set Value ( normalized , gts . ticks [ i ] ,  GTSHelper . location At Index ( gts , i ) ,  GTSHelper . elevation At Index ( gts , i ) , value , _ BOOL ) ; } return normalized ; }
public  Highlight Builder field (  String name ) { if ( fields == null ) { fields = new  Array List < > ( ) ; } fields . add ( new  Field ( name ) ) ; return this ; }
public <  R >  Future W <  R > flat Map Cf ( final  Function < ? super  T , ? extends  Completion Stage < ? extends  R > > mapper ) { return  Future W . <  R > of ( future . <  R > then Compose ( null ) ) ; }
protected void assert Any Mode ( ) throws  Replicator Exception { if ( mode == null ) throw new  THLException ( _ STR + file . get Name ( ) ) ; }
public void test Pos Zero ( ) { byte a Bytes [ ] = { - _ NUM , - _ NUM , - _ NUM , - _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM } ; byte b Bytes [ ] = { _ NUM } ; int a Sign = _ NUM ; int b Sign = _ NUM ; byte r Bytes [ ] = { _ NUM } ;  Big Integer a Number = new  Big Integer ( a Sign , a Bytes ) ;  Big Integer b Number = new  Big Integer ( b Sign , b Bytes ) ;  Big Integer result = a Number . and ( b Number ) ; byte res Bytes [ ] = new byte [ r Bytes . length ] ; res Bytes = result . to Byte Array ( ) ; for ( int i = _ NUM ; i < res Bytes . length ; i ++ ) { assert True ( res Bytes [ i ] == r Bytes [ i ] ) ; } assert Equals ( _ STR , _ NUM , result . signum ( ) ) ; }
public  Stream Status Writer (  String path ,  Twitch Api api ) { this . path = path ; this . api = api ; }
public static  Sentence new Conjunction (  Sentence ... conjuncts ) { return new Conjunction (  Arrays . as List ( conjuncts ) ) ; }
public boolean is Plural ( ) { return type String . contains (  SUFFIX_ PLURAL ) ; }
protected void append Big Decimal Numeric Type (  String Builder sb ,  Field Type field Type , int field Width ) { sb . append ( _ STR ) ; }
public static  Vector tokenize String (  String source , char separator ) {  Vector tokenized = new  Vector ( ) ; int len = source . length ( ) ; boolean last Separator = _ BOOL ;  String Builder buf = new  String Builder ( ) ; for ( int iter = _ NUM ; iter < len ; iter ++ ) { char current = source . char At ( iter ) ; if ( current == separator ) { if ( last Separator ) { buf . append ( separator ) ; last Separator = _ BOOL ; continue ; } last Separator = _ BOOL ; if ( buf . length ( ) > _ NUM ) { tokenized . add Element ( buf . to String ( ) ) ; buf = new  String Builder ( ) ; } } else { last Separator = _ BOOL ; buf . append ( current ) ; } } if ( buf . length ( ) > _ NUM ) { tokenized . add Element ( buf . to String ( ) ) ; } return tokenized ; }
private void backup Favorites (  Backup Data Output data ) throws  IOException {  Content Resolver cr = m Context . get Content Resolver ( ) ;  Cursor cursor = cr . query (  Launcher Settings .  Favorites .  CONTENT_ URI ,  FAVORITE_ PROJECTION , get User Selection Arg ( ) , null , null ) ; try { cursor . move To Position ( - _ NUM ) ; while ( cursor . move To Next ( ) ) { final long id = cursor . get Long (  ID_ INDEX ) ; final long update Time = cursor . get Long (  ID_ MODIFIED ) ;  Backup Protos .  Key key = get Key (  Backup Protos .  Key .  FAVORITE , id ) ; m Keys . add ( key ) ; final  String backup Key = key To Backup Key ( key ) ; if ( ! m Existing Keys . contains ( backup Key ) || update Time >= m Last Backup Restore Time || restored Backup Version < _ NUM ) { write Row To Backup ( key , pack Favorite ( cursor ) , data ) ; } else { if (  DEBUG )  Log . d (  TAG , _ STR + id ) ; } } } finally { cursor . close ( ) ; } }
private boolean do Acquire Nanos ( long arg , long nanos Timeout ) throws  Interrupted Exception { long last Time =  System . nano Time ( ) ; final  Node node = add Waiter (  Node .  EXCLUSIVE ) ; boolean failed = _ BOOL ; try { for ( ; ; ) { final  Node p = node . predecessor ( ) ; if ( p == head && try Acquire ( arg ) ) { set Head ( node ) ; p . next = null ; failed = _ BOOL ; return _ BOOL ; } if ( nanos Timeout <= _ NUM ) return _ BOOL ; if ( should Park After Failed Acquire ( p , node ) && nanos Timeout > spin For Timeout Threshold )  Lock Support . park Nanos ( this , nanos Timeout ) ; long now =  System . nano Time ( ) ; nanos Timeout -= now - last Time ; last Time = now ; if (  Thread . interrupted ( ) ) throw new  Interrupted Exception ( ) ; } } finally { if ( failed ) cancel Acquire ( node ) ; } }
public  List <  Validation Error Message > validate Value (  String value ) { error Message Ids . clear ( ) ; if ( data Restrictions . is Required ( ) && value Null Or Empty ( value ) ) { error Message Ids . add ( new  Validation Error Message ( _ STR , id , null ) ) ; } else { if ( ! value Null Or Empty ( value ) ) { for (  Abstract Validation Rule rule : data Restrictions . get Validation Rules ( ) ) { if ( ! rule . validate ( value ) ) { error Message Ids . add ( new  Validation Error Message ( rule . get Message Id ( ) , id , rule ) ) ; } } } } return error Message Ids ; }
public  Key Store History (  Key Store key Store ,  File file ,  Password password ) { this . file = file ; this . name = file . get Name ( ) ; initial State = new  Key Store State ( this , key Store , password ) ; current State = initial State ; saved State = initial State ; }
public static  Map <  String ,  List <  String > > to Multimap (  Headers headers ,  String value For Null Key ) {  Map <  String ,  List <  String > > result = new  Tree Map < > (  FIELD_ NAME_ COMPARATOR ) ; for ( int i = _ NUM , size = headers . size ( ) ; i < size ; i ++ ) {  String field Name = headers . name ( i ) ;  String value = headers . value ( i ) ;  List <  String > all Values = new  Array List < > ( ) ;  List <  String > other Values = result . get ( field Name ) ; if ( other Values != null ) { all Values . add All ( other Values ) ; } all Values . add ( value ) ; result . put ( field Name ,  Collections . unmodifiable List ( all Values ) ) ; } if ( value For Null Key != null ) { result . put ( null ,  Collections . unmodifiable List (  Collections . singleton List ( value For Null Key ) ) ) ; } return  Collections . unmodifiable Map ( result ) ; }
public void state Changed (  Change Event evt ) { int scale = slider . get Value ( ) ; value . set Text ( _ STR +  String . value Of ( scale ) ) ; size . set Text ( _ STR + ( width * scale ) + _ STR + ( height * scale ) + _ STR ) ; preview . repaint ( ) ; }
private  String create Sized String ( final  String message , final int pixels ) {  Font Metrics fm = get Font Metrics ( get Font ( ) ) ;  String word ;  String Tokenizer st = new  String Tokenizer ( message ) ; int new Width = pixels ; while ( st . has More Tokens ( ) ) { word = st . next Token ( ) ; new Width =  Math . max ( new Width , fm . string Width ( word ) ) ; }  String Builder sb = new  String Builder ( ) ;  String Builder cursb = new  String Builder ( ) ; boolean is New Line ; st = new  String Tokenizer ( message , _ STR , _ BOOL ) ; while ( st . has More Tokens ( ) ) { word = st . next Token ( ) ; if ( word . equals ( _ STR ) ) continue ; is New Line = word . equals ( _ STR ) ; if ( is New Line || fm . string Width ( cursb . to String ( ) + word ) > new Width ) { sb . append ( cursb . to String ( ) ) ; sb . append ( _ STR ) ; cursb = new  String Builder ( ) ; } if ( ! is New Line ) { cursb . append ( word ) ; cursb . append ( _ STR ) ; } } sb . append ( cursb . to String ( ) ) ; return sb . to String ( ) ; }
public void create Connection Dialog ( ) { user Name Label = new  JLabel ( _ STR ,  JLabel .  RIGHT ) ; user Name Field = new  JText Field ( _ STR ) ; password Label = new  JLabel ( _ STR ,  JLabel .  RIGHT ) ; password Field = new  JText Field ( _ STR ) ; server Label = new  JLabel ( _ STR ,  JLabel .  RIGHT ) ; server Field = new  JText Field ( _ STR ) ; driver Label = new  JLabel ( _ STR ,  JLabel .  RIGHT ) ; driver Field = new  JText Field ( _ STR ) ; connection Panel = new  JPanel ( _ BOOL ) ; connection Panel . set Layout ( new  Box Layout ( connection Panel ,  Box Layout .  X_ AXIS ) ) ;  JPanel name Panel = new  JPanel ( _ BOOL ) ; name Panel . set Layout ( new  Grid Layout ( _ NUM , _ NUM ) ) ; name Panel . add ( user Name Label ) ; name Panel . add ( password Label ) ; name Panel . add ( server Label ) ; name Panel . add ( driver Label ) ;  JPanel field Panel = new  JPanel ( _ BOOL ) ; field Panel . set Layout ( new  Grid Layout ( _ NUM , _ NUM ) ) ; field Panel . add ( user Name Field ) ; field Panel . add ( password Field ) ; field Panel . add ( server Field ) ; field Panel . add ( driver Field ) ; connection Panel . add ( name Panel ) ; connection Panel . add ( field Panel ) ; }
@  Override public void trigger (  Dialogue State state ,  Collection <  String > updated Vars ) { if ( frame != null && frame . is Visible ( ) ) { chat Tab . trigger ( state , updated Vars ) ; state Monitor Tab . refresh ( state , updated Vars ) ; } refresh ( ) ; }
public static  Mosaic Definition create Mosaic Definition ( final  Account creator , final  Mosaic Levy levy ) { return create Mosaic Definition ( creator ,  Utils . create Mosaic Id ( _ STR , _ STR ) , create Mosaic Properties ( ) , levy ) ; }
protected void convert From (  Blackboard bb ,  Sql Node from ) { if ( from == null ) { bb . set Root (  Logical Values . create One Row ( cluster ) , _ BOOL ) ; return ; } final  Sql Call call ; final  Sql Node [ ] operands ; switch ( from . get Kind ( ) ) { case  AS : convert From ( bb , ( (  Sql Call ) from ) . operand ( _ NUM ) ) ; return ; case  WITH_ ITEM : convert From ( bb , ( (  Sql With Item ) from ) . query ) ; return ; case  WITH : convert From ( bb , ( (  Sql With ) from ) . body ) ; return ; case  TABLESAMPLE : operands = ( (  Sql Basic Call ) from ) . get Operands ( ) ;  Sql Sample Spec sample Spec =  Sql Literal . sample Value ( operands [ _ NUM ] ) ; if ( sample Spec instanceof  Sql Sample Spec .  Sql Substitution Sample Spec ) {  String sample Name = ( (  Sql Sample Spec .  Sql Substitution Sample Spec ) sample Spec ) . get Name ( ) ; dataset Stack . push ( sample Name ) ; convert From ( bb , operands [ _ NUM ] ) ; dataset Stack . pop ( ) ; } else if ( sample Spec instanceof  Sql Sample Spec .  Sql Table Sample Spec ) {  Sql Sample Spec .  Sql Table Sample Spec table Sample Spec = (  Sql Sample Spec .  Sql Table Sample Spec ) sample Spec ; convert From ( bb , operands [ _ NUM ] ) ;  Rel Opt Sampling Parameters params = new  Rel Opt Sampling Parameters ( table Sample Spec . is Bernoulli ( ) , table Sample Spec . get Sample Percentage ( ) , table Sample Spec . is Repeatable ( ) , table Sample Spec . get Repeatable Seed ( ) ) ; bb . set Root ( new  Sample ( cluster , bb . root , params ) , _ BOOL ) ; } else { throw  Util . new Internal ( _ STR + sample Spec ) ; } return ; case  IDENTIFIER : final  Sql Validator Namespace from Namespace = validator . get Namespace ( from ) . resolve ( ) ; if ( from Namespace . get Node ( ) != null ) { convert From ( bb , from Namespace . get Node ( ) ) ; return ; } final  String dataset Name = dataset Stack . is Empty ( ) ? null : dataset Stack . peek ( ) ; boolean [ ] used Dataset = { _ BOOL } ;  Rel Opt Table table =  Sql Validator Util . get Rel Opt Table ( from Namespace , catalog Reader , dataset Name , used Dataset ) ; final  Rel Node table Rel ; if ( should Convert Table Access ) { table Rel = to Rel ( table ) ; } else { table Rel =  Logical Table Scan . create ( cluster , table ) ; } bb . set Root ( table Rel , _ BOOL ) ; if ( used Dataset [ _ NUM ] ) { bb . set Dataset ( dataset Name ) ; } return ; case  JOIN : final  Sql Join join = (  Sql Join ) from ; final  Sql Validator Scope scope = validator . get Join Scope ( from ) ; final  Blackboard from Blackboard = create Blackboard ( scope , null , _ BOOL ) ;  Sql Node left = join . get Left ( ) ;  Sql Node right = join . get Right ( ) ; final boolean is Natural = join . is Natural ( ) ; final  Join Type join Type = join . get Join Type ( ) ; final  Sql Validator Scope left Scope =  Util . first ( validator . get Join Scope ( left ) , ( (  Delegating Scope ) bb . scope ) . get Parent ( ) ) ; final  Blackboard left Blackboard = create Blackboard ( left Scope , null , _ BOOL ) ; final  Sql Validator Scope right Scope =  Util . first ( validator . get Join Scope ( right ) , ( (  Delegating Scope ) bb . scope ) . get Parent ( ) ) ; final  Blackboard right Blackboard = create Blackboard ( right Scope , null , _ BOOL ) ; convert From ( left Blackboard , left ) ;  Rel Node left Rel = left Blackboard . root ; convert From ( right Blackboard , right ) ;  Rel Node right Rel = right Blackboard . root ;  Join Rel Type converted Join Type = convert Join Type ( join Type ) ;  Rex Node condition Exp ; final  Sql Validator Namespace left Namespace = validator . get Namespace ( left ) ; final  Sql Validator Namespace right Namespace = validator . get Namespace ( right ) ; if ( is Natural ) { final  Rel Data Type left Row Type = left Namespace . get Row Type ( ) ; final  Rel Data Type right Row Type = right Namespace . get Row Type ( ) ; final  List <  String > column List =  Sql Validator Util . derive Natural Join Column List ( left Row Type , right Row Type ) ; condition Exp = convert Using ( left Namespace , right Namespace , column List ) ; } else { condition Exp = convert Join Condition ( from Blackboard , left Namespace , right Namespace , join . get Condition ( ) , join . get Condition Type ( ) , left Rel , right Rel ) ; } final  Rel Node join Rel = create Join ( from Blackboard , left Rel , right Rel , condition Exp , converted Join Type ) ; bb . set Root ( join Rel , _ BOOL ) ; return ; case  SELECT : case  INTERSECT : case  EXCEPT : case  UNION : final  Rel Node rel = convert Query Recursive ( from , _ BOOL , null ) . project ( ) ; bb . set Root ( rel , _ BOOL ) ; return ; case  VALUES : convert Values Impl ( bb , (  Sql Call ) from , null ) ; return ; case  UNNEST : call = (  Sql Call ) from ; final  List <  Sql Node > nodes = call . get Operand List ( ) ; final  Sql Unnest Operator operator = (  Sql Unnest Operator ) call . get Operator ( ) ; for (  Sql Node node : nodes ) { replace Subqueries ( bb , node ,  Rel Opt Util .  Logic .  TRUE_ FALSE_ UNKNOWN ) ; } final  List <  Rex Node > exprs = new  Array List < > ( ) ; final  List <  String > field Names = new  Array List < > ( ) ; for (  Ord <  Sql Node > node :  Ord . zip ( nodes ) ) { exprs . add ( bb . convert Expression ( node . e ) ) ; field Names . add ( validator . derive Alias ( node . e , node . i ) ) ; } final  Rel Node input =  Rel Opt Util . create Project ( ( null != bb . root ) ? bb . root :  Logical Values . create One Row ( cluster ) , exprs , field Names , _ BOOL ) ;  Uncollect uncollect = new  Uncollect ( cluster , cluster . trait Set Of (  Convention .  NONE ) , input , operator . with Ordinality ) ; bb . set Root ( uncollect , _ BOOL ) ; return ; case  COLLECTION_ TABLE : call = (  Sql Call ) from ; assert call . get Operand List ( ) . size ( ) == _ NUM ; final  Sql Call call2 = call . operand ( _ NUM ) ; convert Collection Table ( bb , call2 ) ; return ; default : throw  Util . new Internal ( _ STR + from ) ; } }
private static  SSLContext create Easy SSLContext ( ) {  SSLContext context ; try { context =  SSLContext . get Instance ( _ STR ) ; context . init ( null , _trust Managers , new  Secure Random ( ) ) ;  Https URLConnection . set Default SSLSocket Factory ( context . get Socket Factory ( ) ) ; } catch ( final  General Security Exception gse ) { throw new  Illegal State Exception ( gse . get Message ( ) ) ; } return context ; }
public static void format Tooltips (  Container container ) { for ( int i = _ NUM ; i < container . get Component Count ( ) ; i ++ ) {  Component component = container . get Component ( i ) ; if ( component instanceof  JComponent ) format Tooltip ( (  JComponent ) component ) ; if ( component instanceof  Container ) format Tooltips ( (  Container ) component ) ; } }
public void fill Field Values ( final  Array List <  Randomizer > randomizers ) {  Parameter Getter <  Randomizer ,  Prob Distribution > pdf Getter = null ; if ( !  Network Utils . is Consistent ( randomizers , pdf Getter ) ) { if ( ! ( cb Distribution . get Item Count ( ) ==  Prob Distribution . values ( ) . length ) ) { cb Distribution . add Item (  Prob Distribution .  NULL ) ; cb Distribution . set Selected Index ( cb Distribution . get Item Count ( ) - _ NUM ) ; } card Panel . remove All ( ) ; card Panel . add ( new  JPanel ( ) ) ; card Panel . repaint ( ) ; if ( parent != null ) { parent . pack ( ) ; parent . set Location Relative To ( null ) ; } } else { if ( cb Distribution . get Item Count ( ) ==  Prob Distribution . values ( ) . length ) { cb Distribution . remove Item (  Prob Distribution .  NULL ) ; }  Randomizer rand = (  Randomizer ) randomizers . get ( _ NUM ) ;  Prob Dist Panel rp = card Map . get ( rand . get Pdf ( ) ) ; cb Distribution . set Selected Item ( rand . get Pdf ( ) ) ; rp . fill Field Values ( randomizers ) ; card Panel . remove All ( ) ; card Panel . add ( rp . get Panel ( ) ) ; card Panel . repaint ( ) ; if ( parent != null ) { parent . pack ( ) ; parent . set Location Relative To ( null ) ; } } }
public void await Timeout ( long await Timeout , long await Join ) throws  Interrupted Exception { long end =  System . nano Time ( ) + await Timeout * _ NUM * _ NUM ; for (  Thread t : threads ) { long time =  System . nano Time ( ) ; if ( time < end ) { t . join ( ( ( end - time ) / _ NUM ) , ( int ) ( ( end - time ) % _ NUM ) ) ; } } check ( numthreads , _ NUM , _ NUM ) ; for (  Thread t : threads ) { t . interrupt ( ) ; } end =  System . nano Time ( ) + await Join * _ NUM * _ NUM ; for (  Thread t : threads ) { long time =  System . nano Time ( ) ; if ( time < end ) { t . join ( ( ( end - time ) / _ NUM ) , ( int ) ( ( end - time ) % _ NUM ) ) ; } } check ( numthreads , _ NUM , numthreads ) ; }
private void bcopy ( int cidx , int bidx ) { int length = m Ch Idx - cidx ; if ( ( bidx + length + _ NUM ) >= m Buff . length ) { char buff [ ] = new char [ m Buff . length + length ] ;  System . arraycopy ( m Buff , _ NUM , buff , _ NUM , m Buff . length ) ; m Buff = buff ; }  System . arraycopy ( m Chars , cidx , m Buff , bidx , length ) ; m Buff Idx += length ; }
@  Suppress Warnings ( _ STR ) public static <  T >  T find Value Of Type (  Collection < ? > collection ,  Class <  T > type ) { if ( is Empty ( collection ) ) { return null ; }  T value = null ; for (  Object element : collection ) { if ( type == null || type . is Instance ( element ) ) { if ( value != null ) { return null ; } value = (  T ) element ; } } return value ; }
public  Node remove (  Coordinate pt ) { return (  Node ) node Map . remove ( pt ) ; }
private void clear Up ( ) { long limit =  System . current Time Millis ( ) - interval ; while ( ! data . is Empty ( ) && data . get Last ( ) < limit ) { data . remove Last ( ) ; } }
private void collect Diff Changes ( ) throws  Vcs Exception {  Collection <  File Path > dirty Paths = dirty Paths ( _ BOOL ) ; if ( dirty Paths . is Empty ( ) ) { return ; } try {  String output =  Git Change Utils . get Diff Output ( my Project , my Vcs Root , _ STR , dirty Paths ) ;  Git Change Utils . parse Changes ( my Project , my Vcs Root , null ,  Git Change Utils . resolve Reference ( my Project , my Vcs Root , _ STR ) , output , my Changes , my Unmerged Names ) ; } catch (  Vcs Exception ex ) { if ( !  Git Change Utils . is Head Missing ( ex ) ) { throw ex ; }  Git Simple Handler handler = new  Git Simple Handler ( my Project , my Vcs Root ,  Git Command .  LS_ FILES ) ; handler . add Parameters ( _ STR ) ; handler . set Silent ( _ BOOL ) ; handler . set Stdout Suppressed ( _ BOOL ) ;  String output = handler . run ( ) ; if ( output . length ( ) > _ NUM ) {  String Tokenizer tokenizer = new  String Tokenizer ( output , _ STR ) ; while ( tokenizer . has More Tokens ( ) ) { final  String s = tokenizer . next Token ( ) ;  Change ch = new  Change ( null ,  Git Content Revision . create Revision ( my Vcs Root , s , null , my Project , _ BOOL , _ BOOL , _ BOOL ) ,  File Status .  ADDED ) ; my Changes . add ( ch ) ; } } } }
public int compute (  String line ) { this . line = line ; int count = _ NUM ; if ( attempt First Word ) { int a = _ NUM ; while ( a < line . length ( ) ) { if ( line . char At ( a ) == _ STR ||  Character . is Whitespace ( line . char At ( a ) ) ) a ++ ; else break ; } int b = a + _ NUM ; while ( b < line . length ( ) ) { int ch = line . char At ( b ) ; if (  Character . is Letter Or Digit ( ch ) || ch == _ STR || ch == _ STR ) b ++ ; else break ; } if ( b - a > _ NUM ) { pairs [ count ] [ _ NUM ] = a ; pairs [ count ++ ] [ _ NUM ] = b ; } } if ( id Tags . length > _ NUM ) { for (  String tag : id Tags ) { int b ; for ( int a = line . index Of ( tag ) ; a != - _ NUM ; a = line . index Of ( tag , b + _ NUM ) ) { a += tag . length ( ) ; b = a + _ NUM ; while ( b < line . length ( ) && (  Character . is Letter Or Digit ( line . char At ( b ) ) || line . char At ( b ) == _ STR ) ) b ++ ; if ( b > a ) { if ( count == pairs . length ) pairs =  Multi Words . grow ( pairs ) ; pairs [ count ] [ _ NUM ] = a ; pairs [ count ++ ] [ _ NUM ] = b ; } } } } return count ; }
private  File calc Parent Tree ( ) {  File parent Tree = tree File . get Parent File ( ) ; if ( null == parent Tree ) { return null ; } if ( tree File . is Absolute ( ) && ( null == parent Tree . get Parent File ( ) ) ) { return null ; } return parent Tree ; }
@  Override public long skip ( long n ) throws  IOException { if ( _is == null ) { if ( _s == null ) return - _ NUM ; _is = _s . get Input Stream ( ) ; } return _is . skip ( n ) ; }
public  T remove ( int position ) {  T removed = items . remove ( position ) ; notify Item Removed ( position ) ; return removed ; }
public static double standard Deviation ( double [ ] data , int opt ) { if ( opt == _ NUM ) return  Math . sqrt ( variance ( data , opt ) ) ; else return  Math . sqrt ( variance ( data , opt ) ) ; }
private static void split All Live Ranges (  Instruction s , java . util .  Hash Map <  Register ,  Register > new Map ,  IR ir , boolean root Only ) { for (  Enumeration <  Operand > u = root Only ? s . get Root Uses ( ) : s . get Uses ( ) ; u . has More Elements ( ) ; ) {  Operand use = u . next Element ( ) ; if ( use . is Register ( ) ) {  Register Operand r Use = use . as Register ( ) ;  Register Operand temp = find Or Create Temp ( r Use , new Map , ir ) ; insert Move Before ( temp , r Use . copy RO ( ) , s ) ; } } for (  Enumeration <  Operand > d = s . get Defs ( ) ; d . has More Elements ( ) ; ) {  Operand def = d . next Element ( ) ; if ( def . is Register ( ) ) {  Register Operand r Def = def . as Register ( ) ;  Register Operand temp = find Or Create Temp ( r Def , new Map , ir ) ; insert Move After ( r Def . copy RO ( ) , temp , s ) ; } } for (  Enumeration <  Operand > ops = root Only ? s . get Root Operands ( ) : s . get Operands ( ) ; ops . has More Elements ( ) ; ) {  Operand op = ops . next Element ( ) ; if ( op . is Register ( ) ) {  Register Operand r Op = op . as Register ( ) ;  Register r = r Op . get Register ( ) ;  Register new R = new Map . get ( r ) ; if ( new R != null ) { r Op . set Register ( new R ) ; } } } }
public void fire Annotation Misc Changed (  Workflow Annotation anno ) {  List <  Workflow Annotation > list = new  Linked List < > ( ) ; list . add ( anno ) ; fire Annotations Changed (  Annotation Event .  MISC_ CHANGED , list ) ; }
public boolean update Stats And Return Whether Allowed ( ) { long now =  System Clock . elapsed Realtime ( ) ; long delta Ms = now - m Last Request Ms ; if ( delta Ms < m Delay Ms ) return _ BOOL ; m Last Request Ms = now ; if ( delta Ms < _ NUM * m Delay Ms ) { m Delay Ms =  Math . min (  MAX_ DELAY , m Delay Ms * _ NUM ) ; } else { m Delay Ms =  MIN_ DELAY ; } return _ BOOL ; }
public  Big Integer calculate Client Evidence Message ( ) throws  Crypto Exception { if ( ( this .  A == null ) || ( this .  B == null ) || ( this .  S == null ) ) { throw new  Crypto Exception ( _ STR + _ STR ) ; } this .  M1 =  SRP6 Util . calculate M1 ( digest ,  N ,  A ,  B ,  S ) ; return  M1 ; }
public boolean handle Keyword (  String keyword , int parameter ) { boolean ignore Group If Unknown Keyword Save = ignore Group If Unknown Keyword ; if ( skipping Characters > _ NUM ) { skipping Characters -- ; return _ BOOL ; } ignore Group If Unknown Keyword = _ BOOL ; if ( keyword . equals ( _ STR ) ) { parser State . put ( _ STR ,  Integer . value Of ( parameter ) ) ; return _ BOOL ; } if ( keyword . equals ( _ STR ) ) { if ( parameter < _ NUM ) parameter = parameter + _ NUM ; handle Text ( ( char ) parameter ) ;  Number skip = (  Number ) ( parser State . get ( _ STR ) ) ; if ( skip != null ) { skipping Characters = skip . int Value ( ) ; } else { skipping Characters = _ NUM ; } return _ BOOL ; } if ( keyword . equals ( _ STR ) ) { rtfversion = parameter ; set RTFDestination ( new  Document Destination ( ) ) ; return _ BOOL ; } if ( keyword . starts With ( _ STR ) || keyword . equals ( _ STR ) ) ignore Group If Unknown Keyword Save = _ BOOL ; if ( rtf Destination != null ) { if ( rtf Destination . handle Keyword ( keyword , parameter ) ) return _ BOOL ; } if ( ignore Group If Unknown Keyword Save ) { set RTFDestination ( new  Discarding Destination ( ) ) ; } return _ BOOL ; }
public boolean remove (  URI uri ,  Http Cookie ck ) { if ( ck == null ) { throw new  Null Pointer Exception ( _ STR ) ; } boolean modified = _ BOOL ; lock . lock ( ) ; try { modified = cookie Jar . remove ( ck ) ; } finally { lock . unlock ( ) ; } return modified ; }
public void read From Node (  Node d ) { super . read From Node ( d ) ;  Target Namespace =  DOMUtils . get String Attribute ( d , _ STR ) ;  Named Node Map attribs = d . get Attributes ( ) ; for ( int i = _ NUM ; i < attribs . get Length ( ) ; i ++ ) {  Node attrib = attribs . item ( i ) ;  String ns = attrib . get Node Name ( ) ;  String nv = attrib . get Node Value ( ) ; if ( ns . starts With ( _ STR ) ) { name Space Map . put ( ns . substring ( _ NUM ) , nv ) ; } } for (  Node n :  DOMUtils . get Children By Name ( d , _ STR ) ) {  Constant c = new  Constant ( ) ; c . read From Node ( n ) ; constants . add ( c ) ; } for (  Node n :  DOMUtils . get Children By Name ( d , _ STR ) ) {  Type Declaration c = new  Type Declaration ( ) ; c . read From Node ( n ) ; type Declarations . add ( c ) ; } for (  Node n :  DOMUtils . get Children By Name ( d , _ STR ) ) {  Complex Type c = new  Complex Type ( ) ; c . read From Node ( n ) ; complex Types . add ( c ) ; base Types . add ( c ) ; } for (  Node n :  DOMUtils . get Children By Name ( d , _ STR ) ) {  Enumerated Type e = new  Enumerated Type ( ) ; e . read From Node ( n ) ; enumeration Types . add ( e ) ; } for (  Node n :  DOMUtils . get Children By Name ( d , _ STR ) ) {  Service Type e = new  Service Type ( ) ; e . read From Node ( n ) ; service Types . add ( e ) ; base Types . add ( e .  Request ) ; base Types . add ( e .  Response ) ; } }
private  Parsed View Detail deflate (  View view ) {  Byte Array Output Stream os = new  Byte Array Output Stream ( ) ; try { m View Hierarchy . deflate ( view , os ) ;  Document Builder Factory factory =  Document Builder Factory . new Instance ( ) ;  Document Builder document Builder = factory . new Document Builder ( ) ;  Document doc = document Builder . parse ( new  Byte Array Input Stream ( os . to Byte Array ( ) ) ) ;  Element root = (  Element ) doc . get First Child ( ) ; return convert To Node ( root ) ; } catch (  SAXException e ) { throw new  Runtime Exception ( e ) ; } catch (  Parser Configuration Exception e ) { throw new  Runtime Exception ( e ) ; } catch (  IOException e ) { throw new  Runtime Exception ( e ) ; } }
@  Override public  Object invoke (  Object proxy ,  Method method ,  Object [ ] args ) throws  Throwable { if ( is Correct Method ( method , args ) ) { boolean handled = call Target ( args [ _ NUM ] ) ; set Application Event Handled ( args [ _ NUM ] , handled ) ; } return null ; }
public void test Case20 ( ) { byte a Bytes [ ] = { _ NUM } ; byte b Bytes [ ] = { _ NUM } ; byte r Bytes [ ] = { _ NUM } ; int a Sign = _ NUM ; int b Sign = _ NUM ;  Big Integer a Number = new  Big Integer ( a Sign , a Bytes ) ;  Big Integer b Number = new  Big Integer ( b Sign , b Bytes ) ;  Big Integer result = a Number . subtract ( b Number ) ; byte res Bytes [ ] = new byte [ r Bytes . length ] ; res Bytes = result . to Byte Array ( ) ; for ( int i = _ NUM ; i < res Bytes . length ; i ++ ) { assert True ( res Bytes [ i ] == r Bytes [ i ] ) ; } assert Equals ( _ NUM , result . signum ( ) ) ; }
public  Metadata .  Builder clear ( ) {  Metadata_ Builder _defaults = new  Metadata .  Builder ( ) ; type = _defaults . type ; interface Type = _defaults . interface Type ; optional Builder = _defaults . optional Builder ; builder Factory = _defaults . builder Factory ; generated Builder = _defaults . generated Builder ; value Type = _defaults . value Type ; partial Type = _defaults . partial Type ; visible Nested Types . clear ( ) ; property Enum = _defaults . property Enum ; properties . clear ( ) ; standard Method Underrides . clear ( ) ; builder Serializable = _defaults . builder Serializable ; generated Builder Annotations . clear ( ) ; value Type Annotations . clear ( ) ; value Type Visibility = _defaults . value Type Visibility ; nested Classes . clear ( ) ; _unset Properties . clear ( ) ; _unset Properties . add All ( _defaults . _unset Properties ) ; return (  Metadata .  Builder ) this ; }
public float distance ( vec3 b ) { float x = this . m [ _ NUM ] - b . m [ _ NUM ] ; float y = this . m [ _ NUM ] - b . m [ _ NUM ] ; float z = this . m [ _ NUM ] - b . m [ _ NUM ] ; float result = ( float )  Math . sqrt ( x * x + y * y + z * z ) ; return result ; }
private static  Properties load Properties ( ) {  Properties properties = new  Properties ( ) ;  File file = new  File ( _ STR ) ;  File Input Stream fis = null ; try { if ( file . exists ( ) ) { fis = new  File Input Stream ( file ) ; properties . load ( fis ) ; } } catch (  Exception e ) {  LOGGER . error ( e , e . get Message ( ) ) ; } finally { if ( null != fis ) { try { fis . close ( ) ; } catch (  IOException e ) {  LOGGER . error ( e , e . get Message ( ) ) ; } } } return properties ; }
public static  String escape Xml (  String s ) { if ( s == null ) return null ;  String Builder sb = new  String Builder ( ) ; for ( int i = _ NUM ; i < s . length ( ) ; i ++ ) { char c = s . char At ( i ) ; if ( c == _ STR ) { sb . append ( _ STR ) ; } else if ( c == _ STR ) { sb . append ( _ STR ) ; } else if ( c == _ STR ) { sb . append ( _ STR ) ; } else if ( c == _ STR ) { sb . append ( _ STR ) ; } else if ( c == _ STR ) { sb . append ( _ STR ) ; } else { sb . append ( c ) ; } } return sb . to String ( ) ; }
public static  Uniform Pair <  Event Bean [ ] > flatten List (  Array Deque <  Uniform Pair <  Event Bean [ ] > > event Vector ) { if ( event Vector . is Empty ( ) ) { return null ; } if ( event Vector . size ( ) == _ NUM ) { return event Vector . get First ( ) ; } int total New = _ NUM ; int total Old = _ NUM ; for (  Uniform Pair <  Event Bean [ ] > pair : event Vector ) { if ( pair != null ) { if ( pair . get First ( ) != null ) { total New += pair . get First ( ) . length ; } if ( pair . get Second ( ) != null ) { total Old += pair . get Second ( ) . length ; } } } if ( ( total New + total Old ) == _ NUM ) { return null ; }  Event Bean [ ] result New = null ; if ( total New > _ NUM ) { result New = new  Event Bean [ total New ] ; }  Event Bean [ ] result Old = null ; if ( total Old > _ NUM ) { result Old = new  Event Bean [ total Old ] ; } int dest Pos New = _ NUM ; int dest Pos Old = _ NUM ; for (  Uniform Pair <  Event Bean [ ] > pair : event Vector ) { if ( pair != null ) { if ( pair . get First ( ) != null ) {  System . arraycopy ( pair . get First ( ) , _ NUM , result New , dest Pos New , pair . get First ( ) . length ) ; dest Pos New += pair . get First ( ) . length ; } if ( pair . get Second ( ) != null ) {  System . arraycopy ( pair . get Second ( ) , _ NUM , result Old , dest Pos Old , pair . get Second ( ) . length ) ; dest Pos Old += pair . get Second ( ) . length ; } } } return new  Uniform Pair <  Event Bean [ ] > ( result New , result Old ) ; }
private static  Scout Widget [ ] remove Guidelines (  Scout Widget [ ] list ) {  Array List <  Scout Widget > al = new  Array List < > ( ) ; for (  Scout Widget a List : list ) { if ( a List . m Constraint Widget instanceof  Guideline ) { continue ; } al . add ( a List ) ; } return al . to Array ( new  Scout Widget [ al . size ( ) ] ) ; }
public static  String sanitize Proc Or Func Name (  String src ) { if ( ( src == null ) || ( src . equals ( _ STR ) ) ) { return null ; } return src ; }
public static void evolve (  Subset s1 ,  Subset s2 ) { int k = s1 . get K ( ) ;  Set <  Integer > p1set = s1 . get Set ( ) ;  Set <  Integer > p2set = s2 . get Set ( ) ; for ( int i = _ NUM ; i < k ; i ++ ) { if ( ! p1set . contains ( s2 . get ( i ) ) && ! p2set . contains ( s1 . get ( i ) ) &&  PRNG . next Boolean ( ) ) { int temp = s1 . get ( i ) ; s1 . set ( i , s2 . get ( i ) ) ; s2 . set ( i , temp ) ; } } }
private void contended Lock ( ) { boolean waiting = _ BOOL ; for ( int s ; ; ) { if ( ( ( s = lock State ) & ~  WAITER ) == _ NUM ) { if (  U . compare And Swap Int ( this ,  LOCKSTATE , s ,  WRITER ) ) { if ( waiting ) { waiter = null ; } return ; } } else if ( ( s &  WAITER ) == _ NUM ) { if (  U . compare And Swap Int ( this ,  LOCKSTATE , s , s |  WAITER ) ) { waiting = _ BOOL ; waiter =  Thread . current Thread ( ) ; } } else if ( waiting ) {  Lock Support . park ( this ) ; } } }
private  String trim Text (  String text ) { if ( text . length ( ) >  BUBBLE_ TEXT_ LENGTH ) { text = text . substring ( _ NUM ,  BUBBLE_ TEXT_ LENGTH ) ; int n = text . last Index Of ( _ STR ) ; n =  Math . max ( n , text . last Index Of ( _ STR ) ) ; n =  Math . max ( n , text . last Index Of ( _ STR ) ) ; n =  Math . max ( n , text . last Index Of ( _ STR ) ) ; if ( n > _ NUM ) { text = text . substring ( _ NUM , n ) ; } text += _ STR ; } return text ; }
private double k B ( int i ) { final double [ ] bin Bounds = get Upper Bounds ( ) ; final  Real Distribution kernel = get Kernel ( bin Stats . get ( i ) ) ; return i == _ NUM ? kernel . probability ( min , bin Bounds [ _ NUM ] ) : kernel . probability ( bin Bounds [ i - _ NUM ] , bin Bounds [ i ] ) ; }
public static <  E extends  Identifiable >  E find By Primary Key (  Entity Manager em ,  Big Integer id ,  Class <  E > type ) { require Argument ( em != null , _ STR ) ; require Argument ( id != null && id . compare To (  ZERO ) > _ NUM , _ STR ) ; require Argument ( type != null , _ STR ) ;  Typed Query <  E > query = em . create Named Query ( _ STR , type ) ; query . set Hint ( _ STR , _ STR ) ; try { query . set Parameter ( _ STR , id ) ; query . set Parameter ( _ STR , _ BOOL ) ; return query . get Single Result ( ) ; } catch (  No Result Exception ex ) { return null ; } }
public int hash Code ( ) { int h = _ NUM ; if ( name != null ) { h += name . hash Code ( ) ; } if ( types != null ) { h += hash ( types ) ; } if ( constraints != null ) { h += constraints . hash Code ( ) ; } return h ; }
public static boolean verify ( byte [ ] data , byte [ ] signature , byte [ ] pub ) throws  Assert Fail Exception {  Preconditions . check Argument ( data . length == _ NUM && signature . length <= _ NUM && pub . length <= _ NUM ) ;  Byte Buffer byte Buff = native ECDSABuffer . get ( ) ; if ( byte Buff == null || byte Buff . capacity ( ) < _ NUM ) { byte Buff =  Byte Buffer . allocate Direct ( _ NUM ) ; byte Buff . order (  Byte Order . native Order ( ) ) ; native ECDSABuffer . set ( byte Buff ) ; } byte Buff . rewind ( ) ; byte Buff . put ( data ) ; byte Buff . put ( signature ) ; byte Buff . put ( pub ) ; byte [ ] [ ] ret Byte Array ; r . lock ( ) ; try { return secp256k1_ecdsa_verify ( byte Buff ,  Secp256k1 Context . get Context ( ) , signature . length , pub . length ) == _ NUM ; } finally { r . unlock ( ) ; } }
public  Invalid Mac Exception ( final byte [ ] expected , final byte [ ] actual ) { super ( _ STR ) ; this . expected =  Arrays . copy Of ( expected , expected . length ) ; this . actual =  Arrays . copy Of ( actual , actual . length ) ; }
private void update Action Status ( final  Message message ) { final  Action Update Status action Update Status = convert Message ( message ,  Action Update Status . class ) ; final  Action action = check Action Exist ( message , action Update Status ) ; final  Action Status action Status = create Action Status ( message , action Update Status , action ) ; update Last Poll Time ( action . get Target ( ) ) ; switch ( action Update Status . get Action Status ( ) ) { case  DOWNLOAD : action Status . set Status (  Status .  DOWNLOAD ) ; break ; case  RETRIEVED : action Status . set Status (  Status .  RETRIEVED ) ; break ; case  RUNNING : action Status . set Status (  Status .  RUNNING ) ; break ; case  CANCELED : action Status . set Status (  Status .  CANCELED ) ; break ; case  FINISHED : action Status . set Status (  Status .  FINISHED ) ; break ; case  ERROR : action Status . set Status (  Status .  ERROR ) ; break ; case  WARNING : action Status . set Status (  Status .  WARNING ) ; break ; case  CANCEL_ REJECTED : handle Cancel Rejected ( message , action , action Status ) ; break ; default : log And Throw Message Error ( message , _ STR ) ; } final  Action add Update Action Status = get Update Action Status ( action Status ) ; if ( ! add Update Action Status . is Active ( ) ) { look If Update Available ( action . get Target ( ) ) ; } }
private static  String apply RFC2732 (  String hostname ) { if ( hostname . index Of ( _ STR ) != - _ NUM ) { return _ STR + hostname + _ STR ; } return hostname ; }
public static  List <  Query Response JSON > read Results File (  File file ) throws  IOException {  List <  Query Response JSON > results = new  Array List < > ( ) ; try (  Buffered Reader br = new  Buffered Reader ( new  File Reader ( file ) ) ) {  String line ; while ( ( line = br . read Line ( ) ) != null ) {  Query Response JSON json Result = new  Query Response JSON ( line ) ; results . add ( json Result ) ; } } return results ; }
private static  String add IDPPPrefix (  String expression ) { if ( expression == null || expression . length ( ) == _ NUM ) { return expression ; } if ( expression . index Of ( _ STR ) == - _ NUM ) { debug . error ( _ STR ) ; return expression ; }  String Buffer sb = new  String Buffer ( _ NUM ) ;  String Tokenizer st = new  String Tokenizer ( expression , _ STR ) ; while ( st . has More Tokens ( ) ) {  String temp = (  String ) st . next Token ( ) ;  String prefixed Str = _ STR + idpp Prefix + _ STR + temp ; sb . append ( prefixed Str ) ; } return sb . to String ( ) ; }
protected int draw Host Address ( int host Range [ ] ) { if ( host Range [ _ NUM ] == host Range [ _ NUM ] ) { return host Range [ _ NUM ] ; } return host Range [ _ NUM ] + rng . next Int ( host Range [ _ NUM ] - host Range [ _ NUM ] ) ; }
public static  String to Bits ( final long x ) { final  String Builder sb = new  String Builder ( ) ; long t = x ; boolean first = _ BOOL ; for ( int i = _ NUM ; i < _ NUM ; i ++ ) { if ( t < _ NUM ) { sb . append ( _ STR ) ; first = _ BOOL ; } else if ( first ) { sb . append ( _ STR ) ; } t = t << _ NUM ; } assert t == _ NUM ; return sb . to String ( ) ; }
public static  Result from Content (  String content ,  String format ) throws  Illegal Argument Exception { if ( content == null ) { throw new  Illegal Argument Exception ( _ STR ) ; } if ( format == null ) { throw new  Illegal Argument Exception ( _ STR ) ; } try { return from Content ( new  Input Stream Reader ( new  Byte Array Input Stream ( content . get Bytes ( _ STR ) ) , _ STR ) , format ) ; } catch (  IOException e ) { throw new  Illegal Argument Exception ( e . get Message ( ) ) ; } }
public boolean contains (  Node node ) { int low = _ NUM ; int high = nodes . size ( ) - _ NUM ; while ( low <= high ) { int mid = ( low + high ) > > > _ NUM ;  Node mid Val = nodes . get ( mid ) ; if ( mid Val .  ID < node .  ID ) { low = mid + _ NUM ; } else if ( mid Val .  ID > node .  ID ) { high = mid - _ NUM ; } else { return _ BOOL ; } } return _ BOOL ; }
private void log Pose (  Tango Pose Data pose ) {  String Builder string Builder = new  String Builder ( ) ; float translation [ ] = pose . get Translation As Floats ( ) ; float orientation [ ] = pose . get Rotation As Floats ( ) ; string Builder . append (  String . format ( _ STR , translation [ _ NUM ] , translation [ _ NUM ] , translation [ _ NUM ] ) ) ; string Builder . append (  String . format ( _ STR , orientation [ _ NUM ] , orientation [ _ NUM ] , orientation [ _ NUM ] , orientation [ _ NUM ] ) ) ; log . call ( string Builder . to String ( ) ) ; }
public  OMDrawing Tool Mouse Mode (  OMDrawing Tool omdt ) { this ( ) ; drawing Tool = omdt ; set Mode Cursor (  Cursor . get Predefined Cursor (  Cursor .  DEFAULT_ CURSOR ) ) ; }
public void add Event First (  Sim Event new Event ) { new Event . set Serial ( _ NUM ) ; sorted Set . add ( new Event ) ; }
public  String to String Summary ( ) {  String result ;  String titles ; int resultset Length ; int i ; int j ;  String content ; if ( m_ Non Sig Wins == null ) return _ STR ; result = _ STR ; titles = _ STR ; resultset Length = _ NUM +  Math . max ( ( int ) (  Math . log ( get Col Count ( ) ) /  Math . log ( _ NUM ) ) , ( int ) (  Math . log ( get Row Count ( ) ) /  Math . log ( _ NUM ) ) ) ; for ( i = _ NUM ; i < get Col Count ( ) ; i ++ ) { if ( get Col Hidden ( i ) ) continue ; titles += _ STR + get Summary Title ( i ) + _ STR ; } result += titles + _ STR ; for ( i = _ NUM ; i < get Col Count ( ) ; i ++ ) { if ( get Col Hidden ( i ) ) continue ; result += _ STR ; for ( j = _ NUM ; j < get Col Count ( ) ; j ++ ) { if ( get Col Hidden ( j ) ) continue ; if ( j == i ) content =  Utils . pad Left ( _ STR , resultset Length * _ NUM + _ NUM ) ; else content =  Utils . pad Left ( _ STR + m_ Non Sig Wins [ i ] [ j ] + _ STR + m_ Wins [ i ] [ j ] + _ STR , resultset Length * _ NUM + _ NUM ) ; result += _ STR + content . replace All ( _ STR , _ STR ) + _ STR ; } result += _ STR + get Summary Title ( i ) + _ STR + remove Filter Name ( m_ Col Names [ i ] ) + _ STR ; } result += _ STR ; return result ; }
public static  File savepoint File (  File instance Path ) {  File temp Dir = new  File (  Collect .  CACHE_ PATH ) ; return new  File ( temp Dir , instance Path . get Name ( ) + _ STR ) ; }
public void hrule ( double value ,  Paint color ,  String legend ,  Basic Stroke stroke ) {  Legend Text legend Text = new  Legend Text ( color , legend ) ; comments . add ( legend Text ) ; plot Elements . add ( new  HRule ( value , color , legend Text , stroke ) ) ; }
public  State Interactive extent_to_whole_connected_sets ( ) {  Set <  Brd Item > new_selected_items = new  Tree Set <  Brd Item > ( ) ; for (  Brd Item curr_item : items_list ) { if ( curr_item instanceof  Brd Connectable ) { new_selected_items . add All ( curr_item . get_connected_set ( - _ NUM ) ) ; } } if ( new_selected_items . is Empty ( ) ) return return_state ; items_list = new_selected_items ; actlog_start_scope (  Logfile Scope .  EXTEND_ TO_ WHOLE_ CONNECTED_ SETS ) ; filter ( ) ; i_brd . repaint ( ) ; return this ; }
static private  IV decode Inline BNode ( final byte flags , final byte [ ] key , final int o ) { final  DTE dte =  Abstract IV . get DTE ( flags ) ; switch ( dte ) { case  XSDInt : { final int x =  Key Builder . decode Int ( key , o ) ; return new  Numeric BNode IV <  Bigdata BNode > ( x ) ; } case  UUID : { final  UUID x =  Key Builder . decode UUID ( key , o ) ; return new  UUIDBNode IV <  Bigdata BNode > ( x ) ; } case  XSDString : { final  String Builder sb = new  String Builder ( ) ; final  String str1 ; final int nbytes ; try { nbytes =  IVUnicode . decode ( new  Byte Array Input Stream ( key , o , key . length - o ) , sb ) ; str1 = sb . to String ( ) ; } catch (  IOException e ) { throw new  Runtime Exception ( e ) ; } return new  Fully Inline Unicode BNode IV <  Bigdata BNode > ( str1 , _ NUM + nbytes ) ; } default : throw new  Unsupported Operation Exception ( _ STR + dte ) ; } }
public void load (  Input Stream is , boolean do Substitutions ) throws  IOException {  Properties props = new  Properties ( ) ; props . load ( is ) ; if ( do Substitutions ) substitute System Values ( props ) ; load ( props ) ; props = null ; }
void run (  String driver ,  String url ,  String user ,  String password ) throws  Exception {  Class . for Name ( driver ) ; conn =  Driver Manager . get Connection ( url , user , password ) ; stat = conn . create Statement ( ) ; try { stat . execute ( _ STR ) ; } catch (  SQLException e ) { } stat . execute ( _ STR + _ STR ) ; stat . execute ( _ STR ) ; stat . execute ( _ STR ) ; stat . execute ( _ STR ) ; login By Name Insecure ( ) ; if ( url . starts With ( _ STR ) ) { login Stored Procedure Insecure ( ) ; limit Row Access ( ) ; } login By Name Secure ( ) ; if ( url . starts With ( _ STR ) ) { stat . execute ( _ STR ) ; stat . execute ( _ STR ) ; stat . execute ( _ STR ) ; } login By Id Insecure ( ) ; login By Id Secure ( ) ; try { stat . execute ( _ STR ) ; } catch (  SQLException e ) { } stat . execute ( _ STR + _ STR ) ; stat . execute ( _ STR ) ; stat . execute ( _ STR ) ; stat . execute ( _ STR ) ; stat . execute ( _ STR ) ; stat . execute ( _ STR ) ; list Active Items ( ) ; if ( url . starts With ( _ STR ) ) { stat . execute ( _ STR ) ; stat . execute ( _ STR ) ; stat . execute ( _ STR ) ; stat . execute ( _ STR ) ; list Active Items Using Constants ( ) ; } list Items Sorted Insecure ( ) ; list Items Sorted Secure ( ) ; if ( url . starts With ( _ STR ) ) { list Items Sorted Secure Param ( ) ; store Password Hash With Salt ( ) ; } conn . close ( ) ; }
@  Override public void add Relations (  Task task ,  Iterable <  Object Id > project Ids ,  String field Name ) {  List <  Project > new Project List = new  Linked List < > ( ) ;  Iterable <  Project > projects To Add = project Repository . find All ( project Ids , null ) ; projects To Add . for Each ( null ) ; try { if (  Property Utils . get Property ( task , field Name ) != null ) {  Iterable <  Project > projects = (  Iterable <  Project > )  Property Utils . get Property ( task , field Name ) ; projects . for Each ( null ) ; } } catch (  Exception e ) { throw new  Runtime Exception ( e ) ; } try {  Property Utils . set Property ( task , field Name , new Project List ) ; } catch (  Exception e ) { throw new  Runtime Exception ( e ) ; } task Repository . save ( task ) ; }
protected void discover On All Ports ( ) { if ( log . is Trace Enabled ( ) ) { log . trace ( _ STR ) ; } for ( long sw : floodlight Provider . get All Switch Dpids ( ) ) {  IOFSwitch iof Switch = floodlight Provider . get Switch ( sw ) ; if ( iof Switch == null ) continue ; if ( iof Switch . get Enabled Ports ( ) != null ) { for (  Immutable Port ofp : iof Switch . get Enabled Ports ( ) ) { if ( is Link Discovery Suppressed ( sw , ofp . get Port Number ( ) ) ) continue ; if ( auto Port Fast Feature && iof Switch . is Fast Port ( ofp . get Port Number ( ) ) ) continue ; send Discovery Message ( sw , ofp . get Port Number ( ) , _ BOOL , _ BOOL ) ;  Node Port Tuple npt = new  Node Port Tuple ( sw , ofp . get Port Number ( ) ) ; add To Maintenance Queue ( npt ) ; } } } }
public void sleep ( long millis ) { try {  Thread . sleep ( millis ) ; } catch (  Interrupted Exception e ) { } }
static public  BTree do Insert Random Sparse Key Sequence Test ( final  BTree btree , final int ninserts , final int trace ) { final int keys [ ] = new int [ ninserts ] ; final  Simple Entry entries [ ] = new  Simple Entry [ ninserts ] ; final  Random r = new  Random ( ) ; int last Key = _ NUM ; for ( int i = _ NUM ; i < ninserts ; i ++ ) { final int key = r . next Int ( _ NUM ) + last Key + _ NUM ; keys [ i ] = key ; entries [ i ] = new  Simple Entry ( ) ; last Key = key ; } return do Insert Random Key Sequence Test ( btree , keys , entries , trace ) ; }
public static double entropy ( double [ ] vector ) { if ( vector == null ) return _ NUM ; else if ( vector . length < _ NUM ) return _ NUM ; else { double ret = _ NUM ; for ( double d : vector ) ret += d *  Math . log ( d ) ; return ret ; } }
@  Override public void mouse Dragged (  Mouse Event e ) { if ( m_mouse State == _ NUM ) { m_old Mouse Pos . width = m_new Mouse Pos . width ; m_old Mouse Pos . height = m_new Mouse Pos . height ; m_new Mouse Pos . width = e . get X ( ) ; m_new Mouse Pos . height = e . get Y ( ) ; m_view Pos . width += m_new Mouse Pos . width - m_old Mouse Pos . width ; m_view Pos . height += m_new Mouse Pos . height - m_old Mouse Pos . height ; } else if ( m_mouse State == _ NUM ) {  Graphics g = get Graphics ( ) ; if ( m_ Zoom Box Color == null ) { g . set Color (  Color . black ) ; } else { g . set Color ( m_ Zoom Box Color ) ; } if ( m_ Zoom Box XORColor == null ) { g . set XORMode (  Color . white ) ; } else { g . set XORMode ( m_ Zoom Box XORColor ) ; } g . draw Rect ( m_old Mouse Pos . width , m_old Mouse Pos . height , m_new Mouse Pos . width - m_old Mouse Pos . width , m_new Mouse Pos . height - m_old Mouse Pos . height ) ; m_new Mouse Pos . width = e . get X ( ) ; m_new Mouse Pos . height = e . get Y ( ) ; g . draw Rect ( m_old Mouse Pos . width , m_old Mouse Pos . height , m_new Mouse Pos . width - m_old Mouse Pos . width , m_new Mouse Pos . height - m_old Mouse Pos . height ) ; g . dispose ( ) ; } }
private static  String parse Tag Value (  String parse String ,  String open Tag ,  String close Tag ) { int beg , end ; beg = parse String . index Of ( open Tag ) ; end = parse String . index Of ( close Tag ) ; if ( beg < _ NUM || end < _ NUM ) { return null ; } if ( beg > end ) { return null ; } if ( beg + open Tag . length ( ) == end ) { return _ STR ; } return parse String . substring ( beg + open Tag . length ( ) , end ) ; }
private synchronized void determine Lines ( ) { if ( m_line Map != null ) return ; int count = line Count For ( m_text ) + _ NUM ; m_line Map = new int [ ( _ NUM * count ) + _ NUM ] ; int i = _ NUM ; int line Num = _ NUM ; int start At = _ NUM ; int end At = _ NUM ; int length = m_text . length ( ) ; char c = _ STR ; while ( i < length ) { c = m_text . char At ( i ++ ) ; if ( c == _ STR || c == _ STR ) { m_line Map [ _ NUM * line Num ] = start At ; m_line Map [ ( _ NUM * line Num ) + _ NUM ] = end At ; line Num ++ ; if ( c == _ STR && i < length && m_text . char At ( i ) == _ STR ) i ++ ; start At = i ; end At = i ; } else end At ++ ; } if ( start At != end At ) { m_line Map [ _ NUM * line Num ] = start At ; m_line Map [ ( _ NUM * line Num ) + _ NUM ] = end At ; } }
public void add Rtcp Listener (  Rtcp Event Listener listener ) { if ( s Logger . is Activated ( ) ) { s Logger . debug ( _ STR ) ; } m Listeners . add Element ( listener ) ; }
@  Override protected void ensure Number Of Columns ( int number Of Columns ) { if ( data . length >= number Of Columns ) { return ; } int [ ] new Data = new int [ number Of Columns ] ;  System . arraycopy ( data , _ NUM , new Data , _ NUM , data . length ) ; data = new Data ; }
public void error ( org . xml . sax .  SAXParse Exception e ) throws org . xml . sax .  SAXException {  String formatted Msg = e . get Message ( ) ;  SAXSource Locator locator = get Locator ( ) ;  Error Listener handler = m_stylesheet Processor . get Error Listener ( ) ; try { handler . error ( new  Transformer Exception ( formatted Msg , locator ) ) ; } catch (  Transformer Exception te ) { throw new org . xml . sax .  SAXException ( te ) ; } }
public  CToolbar Panel ( final  JFrame parent , final  CDebug Perspective Model debug Perspective Model ) { super ( new  Border Layout ( ) ) ;  Preconditions . check Not Null ( parent , _ STR ) ;  Preconditions . check Not Null ( debug Perspective Model , _ STR ) ; m_parent = parent ; final  JPanel toolbar Panel = new  JPanel ( new  Border Layout ( ) ) ; toolbar Panel . set Border ( new  Empty Border ( _ NUM , _ NUM , _ NUM , _ NUM ) ) ; m_thread Panel = new  CThread Panel ( debug Perspective Model ) ; final  CDebugger Toolbar toolbar = new  CDebugger Toolbar ( debug Perspective Model ) ; toolbar Panel . add ( toolbar ,  Border Layout .  WEST ) ; toolbar Panel . add ( m_thread Panel ,  Border Layout .  CENTER ) ; add ( toolbar Panel ,  Border Layout .  SOUTH ) ; m_synchronizer = new  CToolbar Panel Synchronizer ( toolbar , m_thread Panel , debug Perspective Model ) ; m_synchronizer . add Listener ( m_internal Synchronizer Listener ) ; }
@  Override public void close ( ) throws  IOException { if ( ! access . equals ( _ STR ) ) { if ( data Stream != null ) { data Stream . close ( ) ; data Stream = null ; } if ( output Stream != null ) { output Stream . close ( ) ; output Stream = null ; } } else if ( i Stream != null ) { i Stream . close ( ) ; } }
@  Nullable public static  String find File In Provided Path (  String provided Path ,  String ... file Names ) { if (  String Util . is Empty ( provided Path ) ) { return _ STR ; }  File provided File = new  File ( provided Path ) ; if ( provided File . exists ( ) ) {  String name = provided File . get Name ( ) ; for (  String file Name : file Names ) { if ( name . equals ( file Name ) ) { return to System Dependent Name ( provided File . get Path ( ) ) ; } } } if ( provided File . is Directory ( ) ) { for (  String file Name : file Names ) {  File file = new  File ( provided File , file Name ) ; if ( file Name . equals ( file . get Name ( ) ) && file . exists ( ) ) { return to System Dependent Name ( file . get Path ( ) ) ; } } } provided File = provided File . get Parent File ( ) ; if ( provided File != null && provided File . exists ( ) ) { for (  String file Name : file Names ) {  File file = new  File ( provided File , file Name ) ; if ( file Name . equals ( file . get Name ( ) ) && file . exists ( ) ) { return to System Dependent Name ( file . get Path ( ) ) ; } } } return null ; }
public static  Resource parse Resource (  String n Triples Resource ,  Value Factory value Factory ) throws  Illegal Argument Exception { if ( n Triples Resource . starts With ( _ STR ) ) { return parse URI ( n Triples Resource , value Factory ) ; } else if ( n Triples Resource . starts With ( _ STR ) ) { return parse BNode ( n Triples Resource , value Factory ) ; } else { throw new  Illegal Argument Exception ( _ STR + n Triples Resource ) ; } }
public void add PSR (  Piloting Roll Data psr ) { pilot Rolls . add Element ( psr ) ; }
public static void sort ( byte [ ] array , int start , int end ) {  Dual Pivot Quicksort . sort ( array , start , end ) ; }
@  Suppress Warnings ( _ STR ) @  Override void process Query Request (  UUID snd Id ,  Grid Cache Query Request req ) { if ( req . cancel ( ) ) { cancel Ids . add ( new  Cancel Message Id ( req . id ( ) , snd Id ) ) ; if ( req . fields ( ) ) remove Fields Query Result ( snd Id , req . id ( ) ) ; else remove Query Result ( snd Id , req . id ( ) ) ; } else { if ( ! cancel Ids . contains ( new  Cancel Message Id ( req . id ( ) , snd Id ) ) ) { if ( !  F . eq ( req . cache Name ( ) , cctx . name ( ) ) ) {  Grid Cache Query Response res = new  Grid Cache Query Response ( cctx . cache Id ( ) , req . id ( ) , new  Ignite Checked Exception ( _ STR + cctx . name ( ) + _ STR + req . cache Name ( ) ) , cctx . deployment Enabled ( ) ) ; send Query Response ( snd Id , res , _ NUM ) ; } else { threads . put ( req . id ( ) ,  Thread . current Thread ( ) ) ; try {  Grid Cache Query Info info = distributed Query Info ( snd Id , req ) ; if ( info == null ) return ; if ( req . fields ( ) ) run Fields Query ( info ) ; else run Query ( info ) ; } catch (  Throwable e ) {  U . error ( log ( ) , _ STR , e ) ; send Query Response ( snd Id , new  Grid Cache Query Response ( cctx . cache Id ( ) , req . id ( ) , e . get Cause ( ) , cctx . deployment Enabled ( ) ) , _ NUM ) ; if ( e instanceof  Error ) throw (  Error ) e ; } finally { threads . remove ( req . id ( ) ) ; } } } } }
private void stretch View Horizontally (  View view , int cross Size ) {  Layout Params lp = (  Layout Params ) view . get Layout Params ( ) ; int new Width = cross Size - lp . left Margin - lp . right Margin ; new Width =  Math . max ( new Width , _ NUM ) ; view . measure (  Measure Spec . make Measure Spec ( new Width ,  Measure Spec .  EXACTLY ) ,  Measure Spec . make Measure Spec ( view . get Measured Height ( ) ,  Measure Spec .  EXACTLY ) ) ; }
public  String str ( ) { if (  Double . is Na N ( m_val ) ) { return _ STR ; } else if (  Double . is Infinite ( m_val ) ) { if ( m_val > _ NUM ) return _ STR ; else return _ STR ; } double num = m_val ;  String s =  Double . to String ( num ) ; int len = s . length ( ) ; if ( s . char At ( len - _ NUM ) == _ STR && s . char At ( len - _ NUM ) == _ STR ) { s = s . substring ( _ NUM , len - _ NUM ) ; if ( s . equals ( _ STR ) ) return _ STR ; return s ; } int e = s . index Of ( _ STR ) ; if ( e < _ NUM ) { if ( s . char At ( len - _ NUM ) == _ STR ) return s . substring ( _ NUM , len - _ NUM ) ; else return s ; } int exp =  Integer . parse Int ( s . substring ( e + _ NUM ) ) ;  String sign ; if ( s . char At ( _ NUM ) == _ STR ) { sign = _ STR ; s = s . substring ( _ NUM ) ; -- e ; } else sign = _ STR ; int n Digits = e - _ NUM ; if ( exp >= n Digits ) return sign + s . substring ( _ NUM , _ NUM ) + s . substring ( _ NUM , e ) + zeros ( exp - n Digits ) ; while ( s . char At ( e - _ NUM ) == _ STR ) e -- ; if ( exp > _ NUM ) return sign + s . substring ( _ NUM , _ NUM ) + s . substring ( _ NUM , _ NUM + exp ) + _ STR + s . substring ( _ NUM + exp , e ) ; return sign + _ STR + zeros ( - _ NUM - exp ) + s . substring ( _ NUM , _ NUM ) + s . substring ( _ NUM , e ) ; }
public double read Double ( ) throws  IOException { return dis . read Double ( ) ; }
public static void move End (  JScroll Pane pane ) {  JScroll Bar bar = pane . get Vertical Scroll Bar ( ) ; bar . set Value ( bar . get Maximum ( ) ) ; }
private boolean is Null Setting ( boolean make Dest ,  Mapping Type mtd ,  Mapping Type mts ,  String Builder result ) { if ( make Dest && ( mtd ==  ALL_ FIELDS || mtd ==  ONLY_ VALUED_ FIELDS ) && mts ==  ONLY_ NULL_ FIELDS ) { result . append ( _ STR + string Of Set Destination + _ STR + new Line ) ; return _ BOOL ; } return _ BOOL ; }
protected  Date compute ( double value ,  String locale String ) { if (  Double . is Na N ( value ) || locale String == null ) { return null ; }  Locale locale = new  Locale ( locale String ) ; long date Long = ( long ) value ;  Date date = new  Date ( date Long ) ;  Calendar cal =  Calendar . get Instance ( locale ) ; cal . set Time ( date ) ; return cal . get Time ( ) ; }
public void enable (  Bluetooth Adapter adapter ) { int mask = (  Bluetooth Receiver .  STATE_ TURNING_ ON_ FLAG |  Bluetooth Receiver .  STATE_ ON_ FLAG |  Bluetooth Receiver .  SCAN_ MODE_ CONNECTABLE_ FLAG ) ; long start = - _ NUM ;  Bluetooth Receiver receiver = get Bluetooth Receiver ( mask ) ; int state = adapter . get State ( ) ; switch ( state ) { case  Bluetooth Adapter .  STATE_ ON : assert True ( adapter . is Enabled ( ) ) ; remove Receiver ( receiver ) ; return ; case  Bluetooth Adapter .  STATE_ TURNING_ ON : assert False ( adapter . is Enabled ( ) ) ; mask = _ NUM ; break ; case  Bluetooth Adapter .  STATE_ OFF : assert False ( adapter . is Enabled ( ) ) ; start =  System . current Time Millis ( ) ; assert True ( adapter . enable ( ) ) ; break ; case  Bluetooth Adapter .  STATE_ TURNING_ OFF : start =  System . current Time Millis ( ) ; assert True ( adapter . enable ( ) ) ; break ; default : remove Receiver ( receiver ) ; fail (  String . format ( _ STR , state ) ) ; } long s =  System . current Time Millis ( ) ; while (  System . current Time Millis ( ) - s <  ENABLE_ DISABLE_ TIMEOUT ) { state = adapter . get State ( ) ; if ( state ==  Bluetooth Adapter .  STATE_ ON && ( receiver . get Fired Flags ( ) & mask ) == mask ) { assert True ( adapter . is Enabled ( ) ) ; long finish = receiver . get Completed Time ( ) ; if ( start != - _ NUM && finish != - _ NUM ) { write Output (  String . format ( _ STR , ( finish - start ) ) ) ; } else { write Output ( _ STR ) ; } remove Receiver ( receiver ) ; return ; } sleep (  POLL_ TIME ) ; } int fired Flags = receiver . get Fired Flags ( ) ; remove Receiver ( receiver ) ; fail (  String . format ( _ STR , state ,  Bluetooth Adapter .  STATE_ ON , fired Flags , mask ) ) ; }
private  Cuboid (  String world Name , int x1 , int y1 , int z1 , int x2 , int y2 , int z2 ) { this . world Name = world Name ; this . x1 =  Math . min ( x1 , x2 ) ; this . x2 =  Math . max ( x1 , x2 ) ; this . y1 =  Math . min ( y1 , y2 ) ; this . y2 =  Math . max ( y1 , y2 ) ; this . z1 =  Math . min ( z1 , z2 ) ; this . z2 =  Math . max ( z1 , z2 ) ; }
private  Workflow .  Method create Meta Volumes Method (  URI system URI ,  URI pool URI ,  List <  URI > volume URIs ,  Virtual Pool Capability Values Wrapper capabilities ) { return new  Workflow .  Method ( _ STR , system URI , pool URI , volume URIs , capabilities ) ; }
public  String parameterize (  String command ,  Map <  String ,  String > parameters ) { for (  String key : parameters . key Set ( ) ) {  String value = parameters . get ( key ) ; command = command . replace ( key , value ) ; } return command ; }
public void next Page (  Gui Manual Herblore manual ) { if ( current Page + _ NUM <= visible Pages . size ( ) ) { set Page ( current Page + _ NUM , manual ) ; } }
public final double sample Active Count Max ( ) { return _active Count Max . get And Set ( _active Count . get ( ) ) ; }
public  Map .  Entry <  String ,  String > issue Token (  Access Token access Token ,  OAuth2 Request request ) throws  Server Exception ,  Invalid Client Exception ,  Not Found Exception { final  Set <  String > scope = access Token . get Scope ( ) ; if ( scope != null && scope . contains (  OAuth2 Constants .  Params .  OPENID ) ) { final  Resource Owner resource Owner ; try { request . set Session ( access Token . get Session Id ( ) ) ; resource Owner = resource Owner Session Validator . validate ( request ) ; final  String nonce = access Token . get Nonce ( ) ; final  Open Id Connect Token open Id Token = token Store . create Open IDToken ( resource Owner , access Token . get Client Id ( ) , access Token . get Client Id ( ) , nonce , get Ops ( access Token , request ) , request ) ; return new  Abstract Map .  Simple Entry < > (  OAuth2 Constants .  JWTToken Params .  ID_ TOKEN , open Id Token . get Token Id ( ) ) ; } catch (  OAuth2 Exception e ) { logger . error ( _ STR , e ) ; throw new  Server Exception ( _ STR ) ; } } return null ; }
public void test Missing Mission Name Handling ( ) {  String xml = _ STR ; xml += _ STR + _ STR ; xml += create End Mission Xml ( ) ;  Input Stream mission Input Stream = new  Byte Array Input Stream ( xml . get Bytes ( ) ) ; boolean did Mission Name Parse Fail = _ BOOL ; try {  Mission Parser . get Mission Name ( mission Input Stream ) ; } catch (  Mission Parse Exception e ) { did Mission Name Parse Fail = _ BOOL ; }  Assert . assert Equals ( _ BOOL , did Mission Name Parse Fail ) ; }
public static double abs (  Z z ) { double are , aim , rho ; are =  Math . abs ( z . re ) ; aim =  Math . abs ( z . im ) ; if ( are + aim == _ NUM ) return _ NUM ; if ( are >= aim ) { rho = aim / are ; return are *  Math . sqrt ( _ NUM + rho * rho ) ; } else { rho = are / aim ; return aim *  Math . sqrt ( _ NUM + rho * rho ) ; } }
public static void silent Close Output Stream (  Output Stream os ) { try { if ( os != null ) { os . close ( ) ; } } catch (  IOException e ) {  Log . w (  LOG_ TAG , _ STR , e ) ; } }
public synchronized void listen To Proj Root ( ) {  List <  String > dirs Added = new  Array List <  String > ( ) ;  String relative Path = null ;  File Object fo = this . proj Root ;  File Change Listener weak Fcl =  File Util . weak File Change Listener ( this , fo ) ; fo . add File Change Listener ( weak Fcl ) ;  File Object parent = null ;  File Object child = null ; for (  List <  String > path : paths ) { parent = fo ; for (  String path Elem : path ) { child = parent . get File Object ( path Elem ) ; if ( child != null ) { relative Path =  File Util . get Relative Path ( fo , child ) ; if ( ! dirs Added . contains ( relative Path ) ) { dirs Added . add ( relative Path ) ; weak Fcl =  File Util . weak File Change Listener ( this , child ) ; child . add File Change Listener ( weak Fcl ) ; parent = child ; } } else { break ; } } } }
public synchronized void release ( ) { if ( event Queue != null ) { event Queue . clear ( ) ; event Queue = null ; } if ( control Queue != null ) { control Queue . clear ( ) ; control Queue = null ; } if ( watch Predicates != null ) { watch Predicates . clear ( ) ; watch Predicates = null ; } }
protected void add Message Processor (  Message Processor new Message Processor ) throws  IOException { synchronized ( message Processors ) { message Processors . add ( new Message Processor ) ; } }
public boolean is Revoked (  Certificate cert ) { if ( revoked Map . is Empty ( ) || ( ! ( cert instanceof  X509 Certificate ) ) ) { return _ BOOL ; }  X509 Certificate xcert = (  X509 Certificate ) cert ;  X509 Issuer Serial issuer Serial = new  X509 Issuer Serial ( xcert ) ; return revoked Map . contains Key ( issuer Serial ) ; }
private void add To Set (  Object Xml Persist persist ,  IFile file ,  String set Name ) throws  IOException ,  Core Exception {  Collection <  Relation Set Descriptor > update Set = load Relation Sets ( persist , file ) ; persist Updated Bundle ( persist , file , update Set , set Name ) ; }
public void put Len Bytes ( byte [ ] bytes ) { ensure Capacity ( _ NUM + bytes . length ) ; put Field Length ( bytes . length ) ;  System . arraycopy ( bytes , _ NUM , this . byte Buffer , this . position , bytes . length ) ; this . position += bytes . length ; }
private static  String list (  String [ ] arr , int from , int len ) {  String Buffer sb = new  String Buffer ( ) ; for ( int i = from ; i < len ; i ++ ) { sb . append ( arr [ i ] ) ; if ( i + _ NUM != arr . length ) sb . append ( _ STR ) ; } return sb . to String ( ) ; }
public static void fill Rectange (  Graphics2 D g2 D ,  JComponent c , boolean round ) {  Compiere Color cc = null ; boolean std CC = c . get Client Property (  Compiere Look And Feel .  BACKGROUND_ FILL ) != null ; try { cc = (  Compiere Color ) c . get Client Property (  Compiere Look And Feel .  BACKGROUND ) ; } catch (  Exception e ) { std CC = _ BOOL ; } if ( std CC ) cc =  Compiere Color . get Default Background ( ) ; if ( cc != null ) { cc . paint ( g2 D , c ) ; } else {  Paint paint = c . get Background ( ) ; g2 D . set Paint ( paint ) ;  Rectangular Shape rec = null ; if ( round ) rec = new  Round Rectangle2 D .  Float ( _ NUM , _ NUM , c . get Width ( ) , c . get Height ( ) , _ NUM , _ NUM ) ; else rec = new  Rectangle ( _ NUM , _ NUM , c . get Width ( ) , c . get Height ( ) ) ; g2 D . fill ( rec ) ; } }
public static int java New ( int lua State ,  Class clazz ) throws  Lua Exception {  Lua State  L =  Lua State Factory . get Existing State ( lua State ) ; synchronized (  L ) {  Object ret = get Obj Instance (  L , clazz ) ;  L . push Java Object ( ret ) ; return _ NUM ; } }
private static final int check Max Lg Arr Longs (  Memory dst Mem ) { int pre Bytes =  CONST_ PREAMBLE_ LONGS << _ NUM ; long cap = dst Mem . get Capacity ( ) ; int max Lg Arr Longs =  Integer . number Of Trailing Zeros ( floor Power Of2 ( ( int ) ( cap - pre Bytes ) ) > > > _ NUM ) ; if ( max Lg Arr Longs <  MIN_ LG_ ARR_ LONGS ) { throw new  Sketches Argument Exception ( _ STR + cap ) ; } return max Lg Arr Longs ; }
public int read ( byte b [ ] , int off , int len ) throws  IOException { if ( input Stream == null ) { throw new  IOException ( _ STR ) ; } int gotsofar = _ NUM ; while ( gotsofar < len ) { int read = input Stream . read ( b , off + gotsofar , len - gotsofar ) ; if ( read == - _ NUM ) { if ( gotsofar > _ NUM ) { count ( gotsofar ) ; return gotsofar ; } else { return read ; } } else { gotsofar += read ; } } count ( gotsofar ) ; return gotsofar ; }
public void shutdown ( ) { final long begin =  System . current Time Millis ( ) ; log . info ( _ STR ) ; log . info ( _ STR + get Task Count ( scheduled Pool ) + _ STR ) ; log . info ( _ STR + get Task Count ( instant Pool ) + _ STR ) ; log . info ( _ STR + get Task Count ( long Running Pool ) + _ STR ) ; scheduled Pool . shutdown ( ) ; instant Pool . shutdown ( ) ; long Running Pool . shutdown ( ) ; boolean success = _ BOOL ; try { success = await Termination ( _ NUM ) ; scheduled Pool . set Execute Existing Delayed Tasks After Shutdown Policy ( _ BOOL ) ; scheduled Pool . set Continue Existing Periodic Tasks After Shutdown Policy ( _ BOOL ) ; success |= await Termination ( _ NUM ) ; } catch (  Interrupted Exception e ) { e . print Stack Trace ( ) ; } log . info ( _ STR + success + _ STR + (  System . current Time Millis ( ) - begin ) + _ STR ) ; log . info ( _ STR + get Task Count ( scheduled Pool ) + _ STR ) ; log . info ( _ STR + get Task Count ( instant Pool ) + _ STR ) ; log . info ( _ STR + get Task Count ( long Running Pool ) + _ STR ) ; }
@  Override protected  String do In Background (  Void ... params ) { try {  String res = launch Ping ( url To Ping ) ; m Trace Route Result . append ( res ) ; publish Progress ( res ) ;  Trace Route Container trace ; if ( res . contains (  UNREACHABLE_ PING ) && ! res . contains (  EXCEED_ PING ) ) { trace = new  Trace Route Container ( _ STR , parse Ip From Ping ( res ) , elapsed Time , _ BOOL ) ; } else { trace = new  Trace Route Container ( _ STR , parse Ip From Ping ( res ) , ttl == max Ttl ?  Float . parse Float ( parse Time From Ping ( res ) ) : elapsed Time , _ BOOL ) ;  Inet Address inet Addr =  Inet Address . get By Name ( trace . get Ip ( ) ) ;  Log . e ( _ STR , _ STR + trace . get Ip ( ) ) ;  String hostname = inet Addr . get Host Name ( ) ;  String canonical Hostname = inet Addr . get Canonical Host Name ( ) ; trace . set Hostname ( hostname ) ; traces . add ( trace ) ; } return res ; } catch ( final  Exception e ) { e . print Stack Trace ( ) ; } return _ STR ; }
public static  String file Name Clean (  String s ) { char [ ] chars = s . to Char Array ( ) ;  String Buffer sb = new  String Buffer ( ) ; for ( int i = _ NUM ; i < chars . length ; i ++ ) { char c = chars [ i ] ; if ( ( c >= _ STR && c <= _ STR ) || ( c >= _ STR && c <= _ STR ) || ( c >= _ STR && c <= _ STR ) || ( c == _ STR ) ) { sb . append ( c ) ; } else { if ( c == _ STR || c == _ STR ) { sb . append ( _ STR ) ; } else { sb . append ( _ STR + ( int ) c + _ STR ) ; } } } return sb . to String ( ) ; }
private void assert Write Result ( int size ) throws  IOException {  Byte Buffer buf =  Byte Buffer . allocate ( size + _ NUM ) ; int count = _ NUM ; int total = _ NUM ; long begin Time =  System . current Time Millis ( ) ; while ( ( count = client Channel . read ( buf ) ) != - _ NUM ) { total = total + count ; if (  System . current Time Millis ( ) - begin Time > _ NUM ) { break ; } } assert Equals ( total , size ) ; buf . flip ( ) ; for ( int i = _ NUM ; i < count ; i ++ ) { assert Equals ( ( byte ) i , buf . get ( i ) ) ; } }
protected  String extract Link ( final  Character Iterator ci ) { final  String Builder sbuf = new  String Builder ( ) ; char ch = ci . current ( ) ; char terminator = _ STR ; if ( ch == _ STR ) { terminator = ch ; } while ( ch !=  Character Iterator .  DONE ) { if ( ch == terminator ) { if ( terminator == _ STR ) { ch = ci . next ( ) ; if ( ch == _ STR ) { ch = _ STR ; } else { ci . previous ( ) ; break ; } } else { break ; } } sbuf . append ( ch ) ; ch = ci . next ( ) ; } int len = sbuf . length ( ) ; while ( len != _ NUM ) { if ( ! is Word Delim ( sbuf . char At ( -- len ) ) ) { len ++ ; break ; } sbuf . set Length ( len ) ; ci . previous ( ) ; } if ( len == _ NUM ) { return null ; } return sbuf . to String ( ) ; }
private  Collection <  Var > migrate Columns (  SQLTable table ,  Result Set row ,  Var instance ) throws  SQLException {  String table Type = table . get Entity Type ( ) ;  Map <  String ,  Resource Type .  Data Type > columns = table . get Columns ( ) ;  Map <  String ,  String > foreign = table . get Foreign Key Columns ( ) ;  Result Set Meta Data metadata = row . get Meta Data ( ) ;  List <  Var > vars = new  Array List < > ( ) ; for ( int i = _ NUM ; i <= metadata . get Column Count ( ) ; i ++ ) {  String column Name = metadata . get Column Name ( i ) ;  Object column Value = row . get Object ( column Name ) ;  Resource Type .  Data Type data Type = columns . get ( column Name ) ;  String foreign Key = foreign . get ( column Name ) ; if ( foreign Key != null ) { vars . add All ( migrate Column Value As Relation ( instance , column Name , foreign Key , column Value ) ) ; } else { vars . add All ( migrate Column Value As Resource ( instance , column Name , cast ( data Type , column Name , row ) , table Type ) ) ; } } return vars ; }
public int list Max Channel (  Database conn ) throws  SQLException {  Result Set rs = null ;  Statement statement = null ; int max Channel = - _ NUM ; try { statement = conn . create Statement ( ) ; rs = statement . execute Query ( select Max ) ; while ( rs . next ( ) ) { max Channel = rs . get Int ( _ NUM ) ; } } finally { close ( rs ) ; close ( statement ) ; } return max Channel ; }
@  Override public synchronized void remove Attribute ( int index ) {  Attribute a = attributes . get ( index ) ; if ( a == null ) { return ; } attributes . set ( index , null ) ; unused Column List . add ( index ) ; }
default  B with (  String key , double value ) { return with ( key ,  Double . to String ( value ) ) ; }
public static  String array To Hex String ( byte [ ] array , int offset , int limit ) {  String ret Val ; if ( array != null ) {  String Buffer hex String = new  String Buffer ( array . length ) ; int hex Val ; char hex Char ; int length =  Math . min ( limit , array . length ) ; for ( int i = offset ; i < length ; i ++ ) { hex Val = ( array [ i ] & _ NUM ) > > _ NUM ; hex Char = ( char ) ( ( hex Val > _ NUM ) ? ( _ STR + ( hex Val - _ NUM ) ) : ( _ STR + hex Val ) ) ; hex String . append ( hex Char ) ; hex Val = array [ i ] & _ NUM ; hex Char = ( char ) ( ( hex Val > _ NUM ) ? ( _ STR + ( hex Val - _ NUM ) ) : ( _ STR + hex Val ) ) ; hex String . append ( hex Char ) ; } ret Val = hex String . to String ( ) ; } else { ret Val = _ STR ; } return ret Val ; }
public  SIPServer Transaction create Server Transaction (  Message Channel encapsulated Message Channel ) { if ( unlimited Server Transaction Table Size ) { return new  SIPServer Transaction ( this , encapsulated Message Channel ) ; } else { float threshold = ( ( float ) ( server Transaction Table . size ( ) - server Transaction Table Lowater Mark ) ) / ( ( float ) ( server Transaction Table Highwater Mark - server Transaction Table Lowater Mark ) ) ; boolean decision =  Math . random ( ) > _ NUM - threshold ; if ( decision ) { return null ; } else { return new  SIPServer Transaction ( this , encapsulated Message Channel ) ; } } }
public static  Visor File Block read Block (  File file , long off , int block Sz , long last Modified ) throws  IOException {  Random Access File raf = null ; try { long f Sz = file . length ( ) ; long f Last Modified = file . last Modified ( ) ; long pos = off >= _ NUM ? off :  Math . max ( f Sz - block Sz , _ NUM ) ; if ( f Last Modified == last Modified && f Sz != _ NUM && pos >= f Sz ) throw new  IOException ( _ STR + pos + _ STR + f Sz ) ; if ( f Sz == _ NUM ) return new  Visor File Block ( file . get Path ( ) , pos , f Last Modified , _ NUM , _ BOOL ,  EMPTY_ FILE_ BUF ) ; else { int to Read =  Math . min ( block Sz , ( int ) ( f Sz - pos ) ) ; byte [ ] buf = new byte [ to Read ] ; raf = new  Random Access File ( file , _ STR ) ; raf . seek ( pos ) ; int cnt Read = raf . read ( buf , _ NUM , to Read ) ; if ( cnt Read != to Read ) throw new  IOException ( _ STR + cnt Read + _ STR + to Read + _ STR ) ; boolean zipped = buf . length > _ NUM ; return new  Visor File Block ( file . get Path ( ) , pos , f Sz , f Last Modified , zipped , zipped ? zip Bytes ( buf ) : buf ) ; } } finally {  U . close ( raf , null ) ; } }
public static void assume False (  Boolean Supplier assumption Supplier ,  Supplier <  String > message Supplier ) throws  Test Aborted Exception { if ( assumption Supplier . get As Boolean ( ) ) { throw Test Aborted Exception ( message Supplier . get ( ) ) ; } }
public static  String add To Cart Bulk Requirements (  Http Servlet Request request ,  Http Servlet Response response ) {  Shopping Cart cart = get Cart Object ( request ) ;  Delegator delegator = (  Delegator ) request . get Attribute ( _ STR ) ;  Local Dispatcher dispatcher = (  Local Dispatcher ) request . get Attribute ( _ STR ) ;  Shopping Cart Helper cart Helper = new  Shopping Cart Helper ( delegator , dispatcher , cart ) ;  String control Directive ;  Map <  String ,  Object > result ;  Map <  String ,  Object > param Map =  Util Http . get Parameter Map ( request ) ;  String catalog Id =  Catalog Worker . get Current Catalog Id ( request ) ; result = cart Helper . add To Cart Bulk Requirements ( catalog Id , param Map ) ; control Directive = process Result ( result , request ) ; if ( control Directive . equals (  ERROR ) ) { return _ STR ; } else { return _ STR ; } }
public  Object2 Double Open Hash Map < int [ ] > support Map ( int support Threshold ) {  List <  Item Set > item Sets = learn ( ) ;  Object2 Double Open Hash Map < int [ ] > support Map = new  Object2 Double Open Hash Map < > ( item Sets . size ( ) ) ; for (  Item Set item Set : item Sets ) { if ( item Set . support >= support Threshold ) { support Map . put ( item Set . items , item Set . support ) ; } } return support Map ; }
@  Override public long skip ( long n ) throws  IOException { long bytes Skipped = f Input Stream . skip ( n << _ NUM ) ; if ( ( bytes Skipped & _ NUM ) != _ NUM ) { int b = f Input Stream . read ( ) ; if ( b == - _ NUM ) { expected Two Bytes ( ) ; } ++ bytes Skipped ; } return bytes Skipped > > _ NUM ; }
protected  Workflow .  Method create CGMethod (  URI vplex URI ,  URI cg URI ,  List <  URI > vplex Volume URIs ) { return new  Workflow .  Method (  CREATE_ CG_ METHOD_ NAME , vplex URI , cg URI , vplex Volume URIs ) ; }
@  Deprecated public static  String escape String (  String string ) {  List <  String > urls = new  Array List < > ( ) ;  Matcher matcher =  URL_ PATTERN . matcher ( string ) ; while ( matcher . find ( ) ) { int match Start = matcher . start ( _ NUM ) ; int match End = matcher . end ( ) ;  String url = string . substring ( match Start , match End ) ; urls . add ( url ) ; string = matcher . replace First ( _ STR + ( urls . size ( ) - _ NUM ) + _ STR ) ; } string =  String Escape Utils . escape Json ( string ) ; for ( int i = _ NUM ; i < urls . size ( ) ; i ++ ) { string = string . replace ( _ STR + i + _ STR , _ STR + urls . get ( i ) ) ; } return string ; }
private void show Popup ( final  Mouse Event event ) { int [ ] rows = get Selected Rows ( ) ; if ( ( rows . length == _ NUM ) || ( rows . length == _ NUM ) ) { final int row = row At Point ( event . get Point ( ) ) ; final int column = column At Point ( event . get Point ( ) ) ; if ( ( row == - _ NUM ) || ( column == - _ NUM ) ) { return ; } change Selection ( row , column , _ BOOL , _ BOOL ) ; rows = get Selected Rows ( ) ; } final  JPopup Menu menu = new  JPopup Menu ( ) ; menu . add ( new  JMenu Item (  CAction Proxy . proxy ( new  CDelete Bookmark Action ( m_debugger Provider , rows ) ) ) ) ; menu . show ( event . get Component ( ) , event . get X ( ) , event . get Y ( ) ) ; }
public static  String replace String (  String original String ,  String token ,  String new String ) { int len Token = token . length ( ) ; int idx = original String . index Of ( token ) ; while ( idx != - _ NUM ) { original String = original String . substring ( _ NUM , idx ) + new String + original String . substring ( idx + len Token ) ; idx = original String . index Of ( token , idx + len Token ) ; } return original String ; }
public  String generate Call Identifier (  String address ) { long random = rand . next Long ( ) ; int hash = ( int )  Math . abs ( random % digester Pools Size ) ;  Message Digest md = digester Pool [ hash ] ; synchronized ( md ) {  String date =  Long . to String (  System . nano Time ( ) +  System . current Time Millis ( ) + call IDCounter ++ + random ) ; byte cid [ ] = md . digest ( date . get Bytes ( ) ) ;  String cid String =  Utils . to Hex String ( cid ) ; return cid String + _ STR + address ; } }
protected void load History ( ) { int size ; int i ;  String cmd ; size =  Integer . parse Int (  PROPERTIES . get Property ( _ STR , _ STR ) ) ; m_ Command History . clear ( ) ; for ( i = _ NUM ; i < size ; i ++ ) { cmd =  PROPERTIES . get Property ( _ STR + i , _ STR ) ; if ( cmd . length ( ) != _ NUM ) { m_ Command History . add ( cmd ) ; } else { break ; } } m_ History Pos = m_ Command History . size ( ) ; }
public  Reference Binding find Super Type Originating From ( int well Known Original ID , boolean original Is Class ) { if ( ! ( this instanceof  Reference Binding ) ) return null ;  Reference Binding reference = (  Reference Binding ) this ; if ( reference . id == well Known Original ID || ( original ( ) . id == well Known Original ID ) ) return reference ;  Reference Binding current Type = reference ; if ( original Is Class ) { while ( ( current Type = current Type . superclass ( ) ) != null ) { if ( current Type . id == well Known Original ID ) return current Type ; if ( current Type . original ( ) . id == well Known Original ID ) return current Type ; } return null ; }  Reference Binding [ ] interfaces To Visit = null ; int next Position = _ NUM ; do {  Reference Binding [ ] its Interfaces = current Type . super Interfaces ( ) ; if ( its Interfaces != null && its Interfaces !=  Binding .  NO_ SUPERINTERFACES ) { if ( interfaces To Visit == null ) { interfaces To Visit = its Interfaces ; next Position = interfaces To Visit . length ; } else { int its Length = its Interfaces . length ; if ( next Position + its Length >= interfaces To Visit . length )  System . arraycopy ( interfaces To Visit , _ NUM , interfaces To Visit = new  Reference Binding [ next Position + its Length + _ NUM ] , _ NUM , next Position ) ; next Interface : for ( int a = _ NUM ; a < its Length ; a ++ ) {  Reference Binding next = its Interfaces [ a ] ; for ( int b = _ NUM ; b < next Position ; b ++ ) if ( next == interfaces To Visit [ b ] ) continue next Interface ; interfaces To Visit [ next Position ++ ] = next ; } } } } while ( ( current Type = current Type . superclass ( ) ) != null ) ; for ( int i = _ NUM ; i < next Position ; i ++ ) { current Type = interfaces To Visit [ i ] ; if ( current Type . id == well Known Original ID ) return current Type ; if ( current Type . original ( ) . id == well Known Original ID ) return current Type ;  Reference Binding [ ] its Interfaces = current Type . super Interfaces ( ) ; if ( its Interfaces != null && its Interfaces !=  Binding .  NO_ SUPERINTERFACES ) { int its Length = its Interfaces . length ; if ( next Position + its Length >= interfaces To Visit . length )  System . arraycopy ( interfaces To Visit , _ NUM , interfaces To Visit = new  Reference Binding [ next Position + its Length + _ NUM ] , _ NUM , next Position ) ; next Interface : for ( int a = _ NUM ; a < its Length ; a ++ ) {  Reference Binding next = its Interfaces [ a ] ; for ( int b = _ NUM ; b < next Position ; b ++ ) if ( next == interfaces To Visit [ b ] ) continue next Interface ; interfaces To Visit [ next Position ++ ] = next ; } } } return null ; }
@  Override protected void on Draw (  Canvas canvas ) { super . on Draw ( canvas ) ; if ( m Shader == null ) return ; float radius = m Center X <= m Center Y ? m Center X - _ NUM : m Center Y - _ NUM ; canvas . rotate ( m Rotate Degrees , m Center X , m Center Y ) ; canvas . draw Circle ( m Center X , m Center Y , radius , m Paint Cover ) ; canvas . rotate ( - m Rotate Degrees , m Center X , m Center Y ) ; canvas . draw Circle ( m Center X , m Center Y , m Button Radius , m Paint Button ) ; canvas . draw Bitmap ( is Rotating ( ) ? m Bitmap Pause : m Bitmap Play , m Center X - m Bitmap Pause . get Width ( ) / _ NUM , m Center Y - m Bitmap Pause . get Height ( ) / _ NUM , m Paint Play Pause ) ; if ( m Progress Visibility ) { canvas . draw Arc ( rect F , _ NUM , _ NUM , _ BOOL , m Paint Progress Empty ) ; canvas . draw Arc ( rect F , _ NUM , calculate Past Progress Degree ( ) , _ BOOL , m Paint Progress Loaded ) ;  String left Time = seconds To Time ( calculate Left Seconds ( ) ) ; m Paint Time . get Text Bounds ( left Time , _ NUM , left Time . length ( ) , m Rect Text ) ; canvas . draw Text ( left Time , ( float ) ( m Center X *  Math . cos (  Math . to Radians ( _ NUM ) ) ) + m Width / _ NUM - m Rect Text . width ( ) / _ NUM , ( float ) ( m Center X *  Math . sin (  Math . to Radians ( _ NUM ) ) ) + m Height / _ NUM + m Rect Text . height ( ) + _ NUM , m Paint Time ) ;  String passed Time = seconds To Time ( calculate Passed Seconds ( ) ) ; m Paint Time . get Text Bounds ( passed Time , _ NUM , passed Time . length ( ) , m Rect Text ) ; canvas . draw Text ( passed Time , ( float ) ( m Center X * -  Math . cos (  Math . to Radians ( _ NUM ) ) ) + m Width / _ NUM - m Rect Text . width ( ) / _ NUM , ( float ) ( m Center X *  Math . sin (  Math . to Radians ( _ NUM ) ) ) + m Height / _ NUM + m Rect Text . height ( ) + _ NUM , m Paint Time ) ; } }
public  Connection Acceptor (  TCPTransport transport ) { this . transport = transport ; }
public void clear Account Disabled State ( ) { operations . add (  Password Policy State Operation Type .  CLEAR_ ACCOUNT_ DISABLED_ STATE ) ; }
@  Request Mapping ( value = { _ STR , _ STR } , method =  Request Method .  GET ) @  Response Body public  Rest Wrapper list ( @  Request Param ( value = _ STR , default Value = _ STR ) int start Page , @  Request Param ( value = _ STR , default Value = _ STR ) int page Size ,  Principal principal ) {  Rest Wrapper rest Wrapper = null ; try {  List <  Properties Template > get Properties Template = properties Template DAO . list Property Template ( start Page , page Size ) ; rest Wrapper = new  Rest Wrapper ( get Properties Template ,  Rest Wrapper .  OK ) ;  LOGGER . info ( _ STR + principal . get Name ( ) ) ; } catch (  Exception e ) {  LOGGER . error ( e ) ; rest Wrapper = new  Rest Wrapper ( e . get Message ( ) ,  Rest Wrapper .  ERROR ) ; } return rest Wrapper ; }
public void test Pos Zero ( ) { byte a Bytes [ ] = { - _ NUM , - _ NUM , - _ NUM , - _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM } ; byte b Bytes [ ] = { _ NUM } ; int a Sign = _ NUM ; int b Sign = _ NUM ; byte r Bytes [ ] = { _ NUM } ;  Big Integer a Number = new  Big Integer ( a Sign , a Bytes ) ;  Big Integer b Number = new  Big Integer ( b Sign , b Bytes ) ;  Big Integer result = a Number . and ( b Number ) ; byte res Bytes [ ] = new byte [ r Bytes . length ] ; res Bytes = result . to Byte Array ( ) ; for ( int i = _ NUM ; i < res Bytes . length ; i ++ ) { assert True ( res Bytes [ i ] == r Bytes [ i ] ) ; } assert Equals ( _ STR , _ NUM , result . signum ( ) ) ; }
public static double hz2bark ( double freq In Hz ) { double f = freq In Hz / _ NUM ; return _ NUM *  Math . log ( f +  Math . sqrt ( ( f * f ) + _ NUM ) ) ; }
private void add Property (  Statement statement ,  Search Document document ) {  String value =  Search Fields . get Literal Property Value As String ( statement ) ; if ( value == null ) { return ; }  String field =  Search Fields . get Property Field ( statement . get Predicate ( ) ) ; add Property ( field , value , document ) ; }
public void add (  String arg Name ,  String desc , int expected Number Of Arguments , boolean expect Dashed Arguments ) {  Arg new Arg = new  Arg ( arg Name , desc , expected Number Of Arguments , expect Dashed Arguments ) ; args . add ( new Arg ) ; if (  Debug . debugging ( _ STR ) ) {  Debug . output ( _ STR + arg Name ) ; } }
private void run Disconnect For Reconnect ( final  Disconnect Listener dc ,  Thread Group tg ) { try { dc . on Disconnect (  Internal Distributed System . this ) ; } catch (  Distributed System Disconnected Exception e ) { if ( logger . is Debug Enabled ( ) ) { logger . debug ( _ STR , dc , e , logger . is Trace Enabled ( ) ? e : null ) ; } } }
public  Builder ( ) { }
private static int last Index Of (  Object o ,  Object [ ] elements , int index ) { if ( o == null ) { for ( int i = index ; i >= _ NUM ; i -- ) if ( elements [ i ] == null ) return i ; } else { for ( int i = index ; i >= _ NUM ; i -- ) if ( o . equals ( elements [ i ] ) ) return i ; } return - _ NUM ; }
public static void copy (  Byte Buffer buffer ,  Output Stream out ) throws  IOException { if ( buffer . has Array ( ) ) { out . write ( buffer . array ( ) , buffer . array Offset ( ) + buffer . position ( ) , buffer . remaining ( ) ) ; } else { byte [ ] arr = new byte [  BUFFER_ SIZE ] ;  Byte Buffer in = buffer . duplicate ( ) ; while ( in . has Remaining ( ) ) { int len =  Math . min ( in . remaining ( ) , arr . length ) ; in . get ( arr , _ NUM , len ) ; out . write ( arr , _ NUM , len ) ; } } }
static  Object [ ] promote Primitives (  Object lhs ,  Object rhs ) { lhs = promote To Integer ( lhs ) ; rhs = promote To Integer ( rhs ) ; if ( ( lhs instanceof  Number ) && ( rhs instanceof  Number ) ) {  Number lnum = (  Number ) lhs ;  Number rnum = (  Number ) rhs ; boolean b ; if ( ( b = ( lnum instanceof  Double ) ) || ( rnum instanceof  Double ) ) { if ( b ) rhs = new  Double ( rnum . double Value ( ) ) ; else lhs = new  Double ( lnum . double Value ( ) ) ; } else if ( ( b = ( lnum instanceof  Float ) ) || ( rnum instanceof  Float ) ) { if ( b ) rhs = new  Float ( rnum . float Value ( ) ) ; else lhs = new  Float ( lnum . float Value ( ) ) ; } else if ( ( b = ( lnum instanceof  Long ) ) || ( rnum instanceof  Long ) ) { if ( b ) rhs = new  Long ( rnum . long Value ( ) ) ; else lhs = new  Long ( lnum . long Value ( ) ) ; } } return new  Object [ ] { lhs , rhs } ; }
private synchronized void block ( boolean tf ) { if ( tf ) { try { if ( m_build Thread . is Alive ( ) && m_state !=  IDLE ) { wait ( ) ; } } catch (  Interrupted Exception ex ) { } } else { notify All ( ) ; } }
public void move (  Mouse Event e ) {  Point2 D pnt = get Projection Point ( e ) ; int x = ( int ) pnt . get X ( ) ; int y = ( int ) pnt . get Y ( ) ; if ( line . get Render Type ( ) ==  OMGraphic .  RENDERTYPE_ OFFSET ) { gpm = new  Offset Grab Point ( x , y ) ; gpm . add Grab Point ( gp1 ) ; gpm . add Grab Point ( gp2 ) ; } else { gpm = gpo ; gpm . set ( x , y ) ; gpm . update Offsets ( ) ; } moving Point = gpm ; }
private  String parse Ip From Ping (  String ping ) {  String ip = _ STR ; if ( ping . contains (  FROM_ PING ) || ping . contains (  SMALL_ FROM_ PING ) ) { int index = ping . index Of (  FROM_ PING ) ; if ( index == _ NUM ) { index = ping . index Of (  SMALL_ FROM_ PING ) ; } ip = ping . substring ( index + _ NUM ) ; if ( ip . contains (  PARENTHESE_ OPEN_ PING ) ) { int index Open = ip . index Of (  PARENTHESE_ OPEN_ PING ) ; int index Close = ip . index Of (  PARENTHESE_ CLOSE_ PING ) ; ip = ip . substring ( index Open + _ NUM , index Close ) ; } else { ip = ip . substring ( _ NUM , ip . index Of ( _ STR ) ) ; if ( ip . contains ( _ STR ) ) { index = ip . index Of ( _ STR ) ; } else { index = ip . index Of ( _ STR ) ; } ip = ip . substring ( _ NUM , index ) ; } } else { int index Open = ping . index Of (  PARENTHESE_ OPEN_ PING ) ; int index Close = ping . index Of (  PARENTHESE_ CLOSE_ PING ) ; ip = ping . substring ( index Open + _ NUM , index Close ) ; } return ip ; }
protected static  Boolean try Lock (  String service Name ,  Object name ,  Long wait ) {  DLock Service service =  DLock Service . get Internal Service Named ( service Name ) ; boolean locked = service . lock ( name , wait . long Value ( ) , - _ NUM , _ BOOL ) ; return  Boolean . value Of ( locked ) ; }
protected int check Request Header ( ) { int ret Val = _ NUM ; debug . message ( _ STR ,  ADAPTIVE ) ;  Http Servlet Request req = get Http Servlet Request ( ) ; if ( req != null ) {  Enumeration <  String > e Hdrs = req . get Header Names ( ) ; while ( e Hdrs . has More Elements ( ) ) {  String header = e Hdrs . next Element ( ) ; if ( req Header Name . equals Ignore Case ( header ) ) { if ( debug . message Enabled ( ) ) { debug . message ( _ STR ,  ADAPTIVE , header ) ; } if ( req Header Value != null ) {  Enumeration <  String > e Vals = req . get Headers ( header ) ; while ( e Vals . has More Elements ( ) ) {  String val = e Vals . next Element ( ) ; if ( req Header Value . equals Ignore Case ( val ) ) { if ( debug . message Enabled ( ) ) { debug . message ( _ STR ,  ADAPTIVE , val ) ; } ret Val = req Header Score ; } } } else { ret Val = req Header Score ; } break ; } } } if ( ! req Header Invert ) { ret Val = req Header Score - ret Val ; } return ret Val ; }
private  File select Export File ( final  String title ,  File Name Extension Filter file Name Extension Filter ) { if (  Boolean . parse Boolean (  System . get Property ( _ STR ,  Boolean . to String (  OSType . is Mac ( ) ) ) ) ) {  File Dialog export Dialog = file Dialogs . get ( title ) ; if ( export Dialog == null ) { export Dialog = new  File Dialog ( this , title ,  File Dialog .  SAVE ) ; file Dialogs . put ( title , export Dialog ) ; } export Dialog . set File ( options . file Name Stem + _ STR ) ; export Dialog . set Visible ( _ BOOL ) ; if ( export Dialog . get File ( ) != null ) { return new  File ( export Dialog . get Directory ( ) , export Dialog . get File ( ) ) ; } } else {  JFile Chooser export Chooser = file Choosers . get ( title ) ; if ( export Chooser == null ) { export Chooser = new  JFile Chooser (  Utils . get CWD ( ) ) ; export Chooser = new  JFile Chooser (  Utils . get CWD ( ) ) ; export Chooser . set File Filter ( file Name Extension Filter ) ; export Chooser . set Dialog Title ( title ) ; file Choosers . put ( title , export Chooser ) ; } export Chooser . set Selected File ( new  File ( options . file Name Stem + _ STR ) ) ; final int return Val = export Chooser . show Save Dialog ( this ) ; if ( return Val ==  JFile Chooser .  APPROVE_ OPTION ) {  File file = export Chooser . get Selected File ( ) ; int n =  JOption Pane .  YES_ OPTION ; if ( file . exists ( ) ) { n =  JOption Pane . show Confirm Dialog ( this , file . get Name ( ) , _ STR ,  JOption Pane .  YES_ NO_ OPTION ) ; } if ( n ==  JOption Pane .  YES_ OPTION ) { return file ; } } } return null ; }
public  GT_ Meta Generated_ Item_ X01 (  String a Unlocalized ,  Ore Prefixes a Generated Prefix , int a Icon Set Index ) { super ( a Unlocalized , ( short ) _ NUM , ( short ) _ NUM ) ; m Prefix = a Generated Prefix ; m Icon Set Index = a Icon Set Index >= _ NUM ? a Icon Set Index : a Generated Prefix . m Texture Index >= _ NUM ? a Generated Prefix . m Texture Index : _ NUM ; for ( int i = _ NUM ; i <  Greg Tech_ API . s Generated Materials . length ; i ++ ) {  Ore Prefixes t Prefix = m Prefix ; if ( t Prefix == null ) continue ;  Materials t Material =  Greg Tech_ API . s Generated Materials [ i ] ; if ( t Material == null ) continue ; if ( m Prefix . do Generate Item ( t Material ) ) {  Item Stack t Stack = new  Item Stack ( this , _ NUM , i ) ;  GT_ Language Manager . add String Localization ( get Unlocalized Name ( t Stack ) + _ STR , get Default Localization ( t Prefix , t Material , i ) ) ;  GT_ Language Manager . add String Localization ( get Unlocalized Name ( t Stack ) + _ STR , t Material . get Tool Tip ( t Prefix . m Material Amount /  M ) ) ;  String t Ore Name = get Ore Dict String ( t Prefix , t Material ) ; t Prefix =  Ore Prefixes . get Ore Prefix ( t Ore Name ) ; if ( t Prefix != null && t Prefix . m Is Unificatable ) {  GT_ Ore Dict Unificator . set ( t Prefix ,  Ore Prefixes . get Material ( t Ore Name , t Prefix ) , t Stack ) ; } else {  GT_ Ore Dict Unificator . register Ore ( t Ore Name , t Stack ) ; } } } }
@  Override public  Enumeration <  Option > list Options ( ) {  Vector <  Option > new Vector = new  Vector <  Option > ( _ NUM ) ; new Vector . add Element ( new  Option ( _ STR , _ STR , _ NUM , _ STR ) ) ; new Vector . add Element ( new  Option ( _ STR , _ STR , _ NUM , _ STR ) ) ; new Vector . add Element ( new  Option ( _ STR , _ STR , _ NUM , _ STR ) ) ; new Vector . add Element ( new  Option ( _ STR + _ STR , _ STR , _ NUM , _ STR ) ) ; new Vector . add Element ( new  Option ( _ STR + _ STR , _ STR , _ NUM , _ STR ) ) ; new Vector . add Element ( new  Option ( _ STR , _ STR , _ NUM , _ STR ) ) ; new Vector . add Element ( new  Option ( _ STR , _ STR , _ NUM , _ STR ) ) ; new Vector . add Element ( new  Option ( _ STR , _ STR , _ NUM , _ STR ) ) ; new Vector . add Element ( new  Option ( _ STR , _ STR , _ NUM , _ STR ) ) ; new Vector . add All (  Collections . list ( super . list Options ( ) ) ) ; return new Vector . elements ( ) ; }
public static  Parsed Sql parse Sql Statement (  String sql ) { if ( sql == null ) new  Illegal Argument Exception ( _ STR ) ;  Set <  String > named Parameters = new  Hash Set <  String > ( ) ;  Parsed Sql parsed Sql = new  Parsed Sql ( sql ) ; char [ ] statement = sql . to Char Array ( ) ; int named Parameter Count = _ NUM ; int unnamed Parameter Count = _ NUM ; int total Parameter Count = _ NUM ; int i = _ NUM ; while ( i < statement . length ) { int skip To Position = skip Comments And Quotes ( statement , i ) ; if ( i != skip To Position ) { if ( skip To Position >= statement . length ) { break ; } i = skip To Position ; } char c = statement [ i ] ; if ( c == _ STR || c == _ STR || c == _ STR || c == _ STR ) { int j = i + _ NUM ; if ( j < statement . length && statement [ j ] == _ STR && c == _ STR ) { i = i + _ NUM ; continue ; } while ( j < statement . length && ! is Parameter Separator ( statement [ j ] ) ) { j ++ ; } if ( j - i > _ NUM ) {  String parameter = sql . substring ( i + _ NUM , j ) ; if ( ! named Parameters . contains ( parameter ) ) { named Parameters . add ( parameter ) ; named Parameter Count ++ ; }  String removed Prefix And Suffix Parameter = remove Prefix And Suffix ( c , parameter , sql ) ; parsed Sql . add Named Parameter ( removed Prefix And Suffix Parameter , c + parameter , i , j ) ; total Parameter Count ++ ; } i = j - _ NUM ; } else { if ( c == _ STR ) { unnamed Parameter Count ++ ; total Parameter Count ++ ; } } i ++ ; } parsed Sql . set Named Parameter Count ( named Parameter Count ) ; parsed Sql . set Unnamed Parameter Count ( unnamed Parameter Count ) ; parsed Sql . set Total Parameter Count ( total Parameter Count ) ; return parsed Sql ; }
final void put Double ( int offset , double value ) { unsafe . put Double ( offset + address , value ) ; }
public void add Request (  Action Request request ,  Limited Queue Info queue Info ) {  String request Id =  Penn Station . request Action ( request , queue Info ) ; synchronized ( this ) { m Last Request Id By Type . put ( request . type ( ) , request Id ) ; m Request Ids . add ( request Id ) ; } }
public static  String gensalt ( int log_rounds ,  Secure Random random ) {  String Buffer rs = new  String Buffer ( ) ; byte rnd [ ] = new byte [  BCRYPT_ SALT_ LEN ] ; random . next Bytes ( rnd ) ; rs . append ( _ STR ) ; if ( log_rounds < _ NUM ) rs . append ( _ STR ) ; rs . append (  Integer . to String ( log_rounds ) ) ; rs . append ( _ STR ) ; rs . append ( encode_base64 ( rnd , rnd . length ) ) ; return rs . to String ( ) ; }
private static  String merge Text And Mnemonic (  String text , final int mnemonic , final int mnemonic Index ) { if ( text == null ) { text = _ STR ; } final int index ; if ( mnemonic Index >= _ NUM && mnemonic Index < text . length ( ) &&  Character . to Upper Case ( text . char At ( mnemonic Index ) ) == mnemonic ) { index = mnemonic Index ; } else { index = - _ NUM ; } final  String Buffer buffer = new  String Buffer ( text ) ; if ( index != - _ NUM ) { buffer . insert ( index , _ STR ) ; for ( int i = buffer . length ( ) - _ NUM ; i >= _ NUM ; i -- ) { if ( buffer . char At ( i ) == _ STR && i != index ) { buffer . insert ( i , _ STR ) ; } } } return buffer . to String ( ) ; }
private void run Init Function If Required (  String url ,  Connection connection ) throws  SQLException {  Matcher matcher =  INITFUNCTION_ MATCHING_ PATTERN . matcher ( url ) ; if ( matcher . matches ( ) ) {  String class Name = matcher . group ( _ NUM ) ;  String method Name = matcher . group ( _ NUM ) ; try {  Class < ? > init Function Clazz =  Class . for Name ( class Name ) ;  Method method = init Function Clazz . get Method ( method Name ,  Connection . class ) ; method . invoke ( null , connection ) ; } catch (  Class Not Found Exception |  No Such Method Exception |  Illegal Access Exception |  Invocation Target Exception e ) {  LOGGER . error ( _ STR , class Name , method Name , e ) ; throw new  SQLException ( _ STR + class Name + _ STR + method Name , e ) ; } } }
public static void check Finite ( final double x ) throws  Math Illegal Argument Exception { if (  Double . is Infinite ( x ) ||  Double . is Na N ( x ) ) { throw new  Math Illegal Argument Exception (  Localized Core Formats .  NOT_ FINITE_ NUMBER , x ) ; } }
protected void update View (  View view ) { try { m Status Text = (  Text View ) view . find View By Id (  R . id . seek Bar Pref Value ) ; m Status Text . set Text (  String . value Of ( m Current Value ) ) ; m Status Text . set Minimum Width ( _ NUM ) ; m Seek Bar . set Progress ( m Current Value - m Min Value ) ;  Text View units Right = (  Text View ) view . find View By Id (  R . id . seek Bar Pref Units Right ) ; units Right . set Text ( m Units Right ) ;  Text View units Left = (  Text View ) view . find View By Id (  R . id . seek Bar Pref Units Left ) ; units Left . set Text ( m Units Left ) ; } catch (  Exception e ) {  Log . e (  TAG , _ STR , e ) ; } }
public static boolean is Auto Commit (  Properties ctx , int  Window No ) { if ( ctx == null ) throw new  Illegal Argument Exception ( _ STR ) ;  String s = get Context ( ctx ,  Window No , _ STR , _ BOOL ) ; if ( s != null ) { if ( s . equals ( _ STR ) ) return _ BOOL ; else return _ BOOL ; } return is Auto Commit ( ctx ) ; }
void expand (  File dir ,  String [ ] files , boolean is Update ) { if ( files == null ) { return ; } for ( int i = _ NUM ; i < files . length ; i ++ ) {  File f ; if ( dir == null ) { f = new  File ( files [ i ] ) ; } else { f = new  File ( dir , files [ i ] ) ; } if ( f . is File ( ) ) { if ( entries . add ( f ) ) { if ( is Update ) entry Map . put ( entry Name ( f . get Path ( ) ) , f ) ; } } else if ( f . is Directory ( ) ) { if ( entries . add ( f ) ) { if ( is Update ) {  String dir Path = f . get Path ( ) ; dir Path = ( dir Path . ends With (  File . separator ) ) ? dir Path : ( dir Path +  File . separator ) ; entry Map . put ( entry Name ( dir Path ) , f ) ; } expand ( f , f . list ( ) , is Update ) ; } } else { error ( format Msg ( _ STR ,  String . value Of ( f ) ) ) ; ok = _ BOOL ; } } }
public boolean init ( ) { if (  MODE ==  MODE_ HORIZONTAL ) { center Panel . set Layout ( new  ALayout ( ) ) ; } if (  MODE ==  MODE_ VERTICAL ) { gbc . anchor =  Grid Bag Constraints .  NORTHWEST ; gbc . weightx = _ NUM ; gbc . weighty = _ NUM ; gbc . gridy = m_line ++ ; gbc . gridx = _ NUM ; gbc . gridwidth = _ NUM ; gbc . insets = null Inset ; gbc . fill =  Grid Bag Constraints .  HORIZONTAL ; center Panel . add (  Box . create Vertical Strut ( _ NUM ) , gbc ) ; } log . config ( _ STR ) ;  MClient client =  MClient . get (  Env . get Ctx ( ) ) ;  String  ASPFilter = _ STR ; if ( client . is Use ASP ( ) )  ASPFilter = _ STR + _ STR + _ STR + _ STR + _ STR + client . get AD_ Client_ ID ( ) + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + client . get AD_ Client_ ID ( ) + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + client . get AD_ Client_ ID ( ) + _ STR + _ STR + _ STR + _ STR + _ STR ;  String sql = null ; if (  Env . is Base Language (  Env . get Ctx ( ) , _ STR ) ) sql = _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR +  ASPFilter + _ STR ; else sql = _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR +  Env . get AD_ Language (  Env . get Ctx ( ) ) + _ STR + _ STR +  ASPFilter + _ STR ; int cols = _ NUM ; int col = _ NUM ; int row = _ NUM ; boolean has Fields = _ BOOL ;  Prepared Statement pstmt = null ;  Result Set rs = null ; try { pstmt =  DB . prepare Statement ( sql , null ) ; pstmt . set Int ( _ NUM , m_process Info . get AD_ Process_ ID ( ) ) ; rs = pstmt . execute Query ( ) ; while ( rs . next ( ) ) { has Fields = _ BOOL ; if (  MODE ==  MODE_ HORIZONTAL ) { create Field ( rs , row , cols ) ; cols = cols + col ; if ( cols >= _ NUM ) { cols = _ NUM ; row ++ ; } } if (  MODE ==  MODE_ VERTICAL ) { create Field ( rs ) ; } } } catch (  SQLException e ) { throw new  DBException ( e , sql ) ; } finally {  DB . close ( rs , pstmt ) ; rs = null ; pstmt = null ; } if ( m_m Fields . size ( ) != m_m Fields2 . size ( ) || m_m Fields . size ( ) != m_v Editors . size ( ) || m_m Fields2 . size ( ) != m_v Editors2 . size ( ) ) log . log (  Level .  SEVERE , _ STR ) ; if ( has Fields ) { if (  MODE ==  MODE_ VERTICAL ) { gbc . gridy = m_line ++ ; center Panel . add (  Box . create Vertical Strut ( _ NUM ) , gbc ) ; gbc . gridx = _ NUM ; center Panel . add (  Box . create Horizontal Strut ( _ NUM ) , gbc ) ; } dynamic Display ( ) ; } else dispose ( ) ; return has Fields ; }
public void add Leaking Resource (  Leaking Resource resource ) { synchronized ( leaking Resources ) { leaking Resources . add ( resource ) ; } }
public void test Case20 ( ) { byte a Bytes [ ] = { _ NUM } ; byte b Bytes [ ] = { _ NUM } ; byte r Bytes [ ] = { _ NUM } ; int a Sign = _ NUM ; int b Sign = _ NUM ;  Big Integer a Number = new  Big Integer ( a Sign , a Bytes ) ;  Big Integer b Number = new  Big Integer ( b Sign , b Bytes ) ;  Big Integer result = a Number . subtract ( b Number ) ; byte res Bytes [ ] = new byte [ r Bytes . length ] ; res Bytes = result . to Byte Array ( ) ; for ( int i = _ NUM ; i < res Bytes . length ; i ++ ) { assert True ( res Bytes [ i ] == r Bytes [ i ] ) ; } assert Equals ( _ NUM , result . signum ( ) ) ; }
public static  String generate Random Name (  String prefix ) {  String Builder sb = new  String Builder ( ) ;  Random random = new  Random ( ) ; sb . append ( prefix ) ; for ( int i = _ NUM ; i < _ NUM ; i ++ ) { sb . append ( _ STR + random . next Int ( _ NUM ) ) ; } return sb . to String ( ) ; }
private static void restore Database (  Properties properties ) throws  IOException ,  Tar Malformat Exception {  String backup = properties . get Property ( _ STR ) ;  String location = properties . get Property ( _ STR ) ; if ( backup == null || location == null ) { throw new  Unsupported Operation Exception ( ) ; }  File Utils . delete Directory ( new  File ( location ) ) ;  String [ ] args = { _ STR , backup , location } ;  Db Backup Main . main ( args ) ; logger . info ( _ STR ) ; }
private void kill All (  String name ) { int sz = size ( ) ; for ( int i = sz - _ NUM ; i >= _ NUM ; i -- ) {  String n = get Name ( i ) ; if ( name == n || ( name != null && name . equals ( n ) ) ) { remove ( i ) ; } } }
public <  T >  T retrieve (  String key , final  Class <  T > clazz , boolean is Encrypted ,  String encrypt Key ) { key = safety Key ( key ) ;  File file = new  File ( cache Directory , key ) ; if ( is Encrypted ) { file = file Encryptor . decrypt ( encrypt Key , file ) ; } try {  T data = jolyglot . from Json ( file , clazz ) ; return data ; } catch (  Exception ignore ) { return null ; } finally { if ( is Encrypted ) { file . delete ( ) ; } } }
public void component ( int  M_ Product_ ID ) throws  Exception { if ( p_implosion ) {  Level No += _ NUM ;  Prepared Statement stmt = null ;  Result Set rs = null ;  String sql = _ STR + _ STR ; try { stmt =  DB . prepare Statement ( sql , get_ Trx Name ( ) ) ; stmt . set Int ( _ NUM ,  M_ Product_ ID ) ; rs = stmt . execute Query ( ) ; while ( rs . next ( ) ) { parent Implotion ( rs . get Int ( _ NUM ) ) ; } rs . close ( ) ; stmt . close ( ) ;  Level No -= _ NUM ; return ; } catch (  SQLException e ) { log . log (  Level .  SEVERE , e . get Localized Message ( ) + sql , e ) ; throw new  Exception ( _ STR + e . get Localized Message ( ) ) ; } finally {  DB . close ( rs , stmt ) ; rs = null ; stmt = null ; } } else {  String sql = _ STR + _ STR ;  Prepared Statement stmt = null ;  Result Set rs = null ; try {  String  Value =  DB . get SQLValue String ( get_ Trx Name ( ) , _ STR ,  M_ Product_ ID ) ; if (  Value == null ) { throw new  Exception (  CLogger . retrieve Error String ( _ STR ) ) ; } stmt =  DB . prepare Statement ( sql , get_ Trx Name ( ) ) ; stmt . set String ( _ NUM ,  Value ) ; rs = stmt . execute Query ( ) ; boolean level = _ BOOL ; while ( rs . next ( ) ) { if ( ! level )  Level No += _ NUM ; level = _ BOOL ; parent Explotion ( rs . get Int ( _ NUM ) ) ;  Level No -= _ NUM ; } } catch (  SQLException e ) { log . log (  Level .  SEVERE , e . get Localized Message ( ) + sql , e ) ; throw new  Exception ( _ STR + e . get Localized Message ( ) ) ; } finally {  DB . close ( rs , stmt ) ; rs = null ; stmt = null ; } } return ; }
private void append Start Tag (  String q Name ,  Attributes attributes ) { char Buf . append ( _ STR + q Name ) ; for (  Map .  Entry <  String ,  String > entry : new Namespace Mappings . entry Set ( ) ) {  String prefix = entry . get Key ( ) ;  String namespace = entry . get Value ( ) ; append Namespace Decl ( char Buf , prefix , namespace ) ; } int att Count = attributes . get Length ( ) ; for ( int i = _ NUM ; i < att Count ; i ++ ) { append Attribute ( char Buf , attributes . get QName ( i ) , attributes . get Value ( i ) ) ; } char Buf . append ( _ STR ) ; int colon Idx = q Name . index Of ( _ STR ) ;  String prefix = ( colon Idx > _ NUM ) ? q Name . substring ( _ NUM , colon Idx ) : _ STR ; if ( ! xml Literal Prefixes . contains ( prefix ) && ! unknown Prefixes In XMLLiteral . contains ( prefix ) ) { unknown Prefixes In XMLLiteral . add ( prefix ) ; } }
public void add Remove And Get Time Nanos ( long duration ) { rmv Time Nanos . add And Get ( duration ) ; get Time Nanos . add And Get ( duration ) ; if ( delegate != null ) delegate . add Remove And Get Time Nanos ( duration ) ; }
private static  Array List <  Object > read Amf Strict Array (  Parsable Byte Array data ) { int count = data . read Unsigned Int To Int ( ) ;  Array List <  Object > list = new  Array List < > ( count ) ; for ( int i = _ NUM ; i < count ; i ++ ) { int type = read Amf Type ( data ) ; list . add ( read Amf Data ( data , type ) ) ; } return list ; }
@  Request Processing ( value = _ STR , method =  HTTPRequest Method .  GET ) @  Before ( advice Class = {  Stopwatch Start Advice . class ,  Anonymous View Check . class ,  User Block Check . class } ) @  After ( advice Class =  Stopwatch End Advice . class ) public void show Home Following Users ( final  HTTPRequest Context context , final  Http Servlet Request request , final  Http Servlet Response response , final  String user Name ) throws  Exception { final  JSONObject user = (  JSONObject ) request . get Attribute (  User .  USER ) ; request . set Attribute (  Keys .  TEMAPLTE_ DIR_ NAME ,  Symphonys . get ( _ STR ) ) ; final  Abstract Free Marker Renderer renderer = new  Skin Renderer ( ) ; context . set Renderer ( renderer ) ; renderer . set Template Name ( _ STR ) ; final  Map <  String ,  Object > data Model = renderer . get Data Model ( ) ; filler . fill Header And Footer ( request , response , data Model ) ;  String page Num Str = request . get Parameter ( _ STR ) ; if (  Strings . is Empty Or Null ( page Num Str ) || !  Strings . is Numeric ( page Num Str ) ) { page Num Str = _ STR ; } final int page Num =  Integer . value Of ( page Num Str ) ; final int page Size =  Symphonys . get Int ( _ STR ) ; final int window Size =  Symphonys . get Int ( _ STR ) ; fill Home User ( data Model , user ) ; final  String following Id = user . opt String (  Keys .  OBJECT_ ID ) ; data Model . put (  Follow .  FOLLOWING_ ID , following Id ) ; avatar Query Service . fill User Avatar URL ( user ) ; final  JSONObject following Users Result = follow Query Service . get Following Users ( following Id , page Num , page Size ) ; final  List <  JSONObject > following Users = (  List <  JSONObject > ) following Users Result . opt (  Keys .  RESULTS ) ; data Model . put (  Common .  USER_ HOME_ FOLLOWING_ USERS , following Users ) ; final boolean is Logged In = (  Boolean ) data Model . get (  Common .  IS_ LOGGED_ IN ) ; if ( is Logged In ) { final  JSONObject current User = (  JSONObject ) data Model . get (  Common .  CURRENT_ USER ) ; final  String follower Id = current User . opt String (  Keys .  OBJECT_ ID ) ; final boolean is Following = follow Query Service . is Following ( follower Id , following Id ) ; data Model . put (  Common .  IS_ FOLLOWING , is Following ) ; for ( final  JSONObject following User : following Users ) { final  String home User Following User Id = following User . opt String (  Keys .  OBJECT_ ID ) ; following User . put (  Common .  IS_ FOLLOWING , follow Query Service . is Following ( follower Id , home User Following User Id ) ) ; } } user . put (  User Ext .  USER_ T_ CREATE_ TIME , new  Date ( user . get Long (  Keys .  OBJECT_ ID ) ) ) ; final int following User Cnt = following Users Result . opt Int (  Pagination .  PAGINATION_ RECORD_ COUNT ) ; final int page Count = ( int )  Math . ceil ( ( double ) following User Cnt / ( double ) page Size ) ; final  List <  Integer > page Nums =  Paginator . paginate ( page Num , page Size , page Count , window Size ) ; if ( ! page Nums . is Empty ( ) ) { data Model . put (  Pagination .  PAGINATION_ FIRST_ PAGE_ NUM , page Nums . get ( _ NUM ) ) ; data Model . put (  Pagination .  PAGINATION_ LAST_ PAGE_ NUM , page Nums . get ( page Nums . size ( ) - _ NUM ) ) ; } data Model . put (  Pagination .  PAGINATION_ CURRENT_ PAGE_ NUM , page Num ) ; data Model . put (  Pagination .  PAGINATION_ PAGE_ COUNT , page Count ) ; data Model . put (  Pagination .  PAGINATION_ PAGE_ NUMS , page Nums ) ; }
public int interp Elevation At ( float lat , float lon ) { if ( frame_is_valid == _ BOOL ) { if ( lat >= dsi . sw_lat && lat <= dsi . ne_lat && lon >= dsi . sw_lon && lon <= dsi . ne_lon ) { float lat_index = ( lat - dsi . sw_lat ) * _ NUM / uhl . lat_post_interval ; float lon_index = ( lon - dsi . sw_lon ) * _ NUM / uhl . lon_post_interval ; int lflon_index = ( int )  Math . floor ( lon_index ) ; int lclon_index = ( int )  Math . ceil ( lon_index ) ; int lclat_index = ( int )  Math . ceil ( lat_index ) ; if ( elevations [ lflon_index ] == null ) read Data Record ( lflon_index ) ; if ( elevations [ lclon_index ] == null ) read Data Record ( lclon_index ) ; int ul = elevations [ lflon_index ] [ lclat_index ] ; int ur = elevations [ lclon_index ] [ lclat_index ] ; int ll = elevations [ lflon_index ] [ lclat_index ] ; int lr = elevations [ lclon_index ] [ lclat_index ] ; float answer = resolve Four Points ( ul , ur , lr , ll , lat_index , lon_index ) ; return  Math . round ( answer ) ; } } return - _ NUM ; }
@  Override  Observed Object create Observed Object (  Object Name object ) { final  Gauge Monitor Observed Object gmo = new  Gauge Monitor Observed Object ( object ) ; gmo . set Status (  RISING_ OR_ FALLING ) ; gmo . set Previous Scan Gauge ( null ) ; return gmo ; }
protected void add Component (  XMLComponent component ) { if ( f Components . contains ( component ) ) { return ; } f Components . add ( component ) ;  String [ ] recognized Features = component . get Recognized Features ( ) ; add Recognized Features ( recognized Features ) ;  String [ ] recognized Properties = component . get Recognized Properties ( ) ; add Recognized Properties ( recognized Properties ) ; if ( recognized Features != null ) { for ( int i = _ NUM ; i < recognized Features . length ; i ++ ) {  String feature Id = recognized Features [ i ] ;  Boolean state = component . get Feature Default ( feature Id ) ; if ( state != null ) { super . set Feature ( feature Id , state . boolean Value ( ) ) ; } } } if ( recognized Properties != null ) { for ( int i = _ NUM ; i < recognized Properties . length ; i ++ ) {  String property Id = recognized Properties [ i ] ;  Object value = component . get Property Default ( property Id ) ; if ( value != null ) { super . set Property ( property Id , value ) ; } } } }
public boolean check_change_net (  Brd Item p_item , int p_new_net_no ) {  Net Nos List net_no_arr = new  Net Nos List ( p_new_net_no ) ; for ( int index = _ NUM ; index < p_item . tile_shape_count ( ) ; ++ index ) {  Shape Tile curr_shape = p_item . tile_shape_get ( index ) ;  Set <  Brd Item > obstacles = overlapping_items_with_clearance ( curr_shape , p_item . shape_layer ( index ) , net_no_arr , p_item . clearance_idx ( ) ) ; for (  Brd Item curr_ob : obstacles ) { if ( curr_ob != p_item ) continue ; if ( curr_ob . contains_net ( p_new_net_no ) ) continue ; return _ BOOL ; } } return _ BOOL ; }
private  Object try Eval As Method (  Class < ? > clazz ,  Object target ,  List <  Object > args ) {  Method method = find Method ( clazz , args ) ; if ( method == null ) { return null ; } try { return  Values . ensure Not Null ( location ( ) , method . invoke ( target ,  Values . convert Args ( location ( ) , method . get Parameter Types ( ) , args ) ) ) ; } catch (  Illegal Access Exception |  Illegal Argument Exception e ) { throw new  Eval Exception ( location ( ) , _ STR , name ( ) , e . get Message ( ) ) ; } catch (  Invocation Target Exception e ) { throw new  Eval Exception (  Issue . create ( location ( ) , _ STR , name ( ) , e . get Cause ( ) ) ) ; } }
private static  String pad String (  String s ,  Align alignment , int min Length ) { if ( alignment ==  Align .  Left ) { return pad Right ( s , min Length ) ; } else if ( alignment ==  Align .  Right ) { return pad Left ( s , min Length ) ; } else { throw new  Index Out Of Bounds Exception ( _ STR ) ; } }
protected synchronized void on Send Accepted (  Record Buffer <  R > buffer ) { logger . trace ( _ STR , name ( ) , buffer ) ; throttler . on Send Accepted ( ) ; active Send Tasks . increment And Get ( ) ; }
public void add Add Delete Buttons ( ) {  JButton delete Button = new  JButton ( _ STR ) ; delete Button . set Action (  Raster Plot Actions . get Remove Source Action ( this ) ) ;  JButton add Button = new  JButton ( _ STR ) ; add Button . set Action (  Raster Plot Actions . get Add Source Action ( this ) ) ; button Panel . add ( delete Button ) ; button Panel . add ( add Button ) ; }
public byte [ ] [ ] generate Keys ( final int nkeys ) { if ( nkeys < _ NUM ) throw new  Illegal Argument Exception ( ) ; if ( nkeys > max Keys ) throw new  Illegal Argument Exception ( ) ; final  Set < byte [ ] > set = new  Tree Set < byte [ ] > (  Bytes Util .  Unsigned Byte Array Comparator .  INSTANCE ) ; final byte [ ] [ ] keys = new byte [ max Keys ] [ ] ; int n = _ NUM ; while ( n < max Keys ) { final byte [ ] key = new byte [ r . next Int ( max Key Length ) + _ NUM ] ; r . next Bytes ( key ) ; if ( set . add ( key ) ) { keys [ n ++ ] = key ; } }  Arrays . sort ( keys ,  Bytes Util .  Unsigned Byte Array Comparator .  INSTANCE ) ; for ( int i = nkeys ; i < max Keys ; i ++ ) { keys [ i ] = null ; } return keys ; }
public boolean has Invoices ( ) { boolean ret Value = _ BOOL ;  String sql = _ STR ;  Prepared Statement pstmt = null ; try { pstmt =  DB . prepare Statement ( sql , get_ Trx Name ( ) ) ; pstmt . set Int ( _ NUM , get_ ID ( ) ) ;  Result Set rs = pstmt . execute Query ( ) ; if ( rs . next ( ) ) { if ( rs . get Int ( _ NUM ) > _ NUM ) ret Value = _ BOOL ; } rs . close ( ) ; pstmt . close ( ) ; pstmt = null ; } catch (  Exception e ) { s_log . log (  Level .  SEVERE , sql , e ) ; } try { if ( pstmt != null ) pstmt . close ( ) ; pstmt = null ; } catch (  Exception e ) { pstmt = null ; } return ret Value ; }
public  Byte Packed Raster (  Sample Model sample Model ,  Data Buffer data Buffer ,  Point origin ) { this ( sample Model , data Buffer , new  Rectangle ( origin . x , origin . y , sample Model . get Width ( ) , sample Model . get Height ( ) ) , origin , null ) ; }
@  Override public boolean long Click (  Selector obj ,  String corner ) throws  Ui Object Not Found Exception { return long Click ( device . find Object ( obj . to Ui Selector ( ) ) , corner ) ; }
public static double parse (  String s ) { try { return  Double . parse Double ( s ) ; } catch (  Number Format Exception e ) { } s = s . replace All ( _ STR , _ STR ) ; s = s . replace All ( _ STR , _ STR ) ; s = s . replace All ( _ STR , _ STR ) ; s = s . replace All ( _ STR , _ STR ) ; try { return  Double . parse Double ( s ) ; } catch (  Number Format Exception e ) { }  Pattern p2 =  Pattern . compile ( _ STR ) ;  Matcher m2 = p2 . matcher ( s ) ; if ( m2 . matches ( ) ) { try { return (  Double . parse Double ( m2 . group ( _ NUM ) ) +  Double . parse Double ( m2 . group ( _ NUM ) ) ) / _ NUM ; } catch (  Number Format Exception e ) { } }  Pattern p1 =  Pattern . compile ( _ STR ) ;  Matcher m1 = p1 . matcher ( s ) ; if ( m1 . matches ( ) ) { try { return  Double . parse Double ( m1 . group ( _ NUM ) ) ; } catch (  Number Format Exception e ) { } } return  Double .  Na N ; }
public void add Listener ( final  INavi Graph Listener listener ) { super . add Listener ( listener ) ; m_listeners . add Listener ( listener ) ; m_synchronizer . add Listener ( listener ) ; }
boolean filter Changed (  Table Line Filter <  Search Result Data Line > filter , int depth ) {  FILTER . set Filter ( depth , filter ) ; int [ ] rows =  TABLE . get Selected Rows ( ) ;  Search Result Data Line [ ] lines = new  Search Result Data Line [ rows . length ] ;  List <  Search Result Data Line > in View = new  Linked List < > ( ) ; for ( int i = _ NUM ; i < rows . length ; i ++ ) { int row = rows [ i ] ;  Search Result Data Line line =  DATA_ MODEL . get ( row ) ; lines [ i ] = line ; if (  TABLE . is Row Visible ( row ) ) in View . add ( line ) ; }  DATA_ MODEL . filters Changed ( ) ; for ( int i = _ NUM ; i < rows . length ; i ++ ) {  Search Result Data Line line = lines [ i ] ; int row =  DATA_ MODEL . get Row ( line ) ; if ( row != - _ NUM ) {  TABLE . add Row Selection Interval ( row , row ) ; if ( in View != null && in View . contains ( line ) ) {  TABLE . ensure Row Visible ( row ) ; in View = null ; } } }  Search Mediator . set Tab Display Count ( this ) ; return _ BOOL ; }
public void test_restart Safe_one Write ( ) {  IAtomic Store store = (  IAtomic Store ) get Store ( ) ; try { assert True ( store . is Stable ( ) ) ; final  Random r = new  Random ( ) ; final int len = _ NUM ; final byte [ ] expected = new byte [ len ] ; r . next Bytes ( expected ) ; final  Byte Buffer tmp =  Byte Buffer . wrap ( expected ) ; final long addr1 = store . write ( tmp ) ; assert Equals ( len , tmp . position ( ) ) ; assert Equals ( tmp . position ( ) , tmp . limit ( ) ) ;  Byte Buffer actual = store . read ( addr1 ) ; assert Equals ( expected , actual ) ; assert Equals ( _ NUM , actual . position ( ) ) ; assert Equals ( expected . length , actual . limit ( ) ) ; store . commit ( ) ; store = (  IAtomic Store ) reopen Store ( store ) ; assert True ( store . is Stable ( ) ) ; actual = store . read ( addr1 ) ; assert Equals ( expected , actual ) ; } finally { store . destroy ( ) ; } }
public static  FSize calc Text Size (  Paint paint ,  String demo Text ) {  Rect r = new  Rect ( ) ; paint . get Text Bounds ( demo Text , _ NUM , demo Text . length ( ) , r ) ; return new  FSize ( r . width ( ) , r . height ( ) ) ; }
private void initialize Values ( ) { mn Size =  Math . min ( get Measured Height ( ) , get Measured Width ( ) ) ; mn Ring Radius = ( int ) ( mn Size - mn Ring Width ) / _ NUM ; mn Inner Circle Radius = ( int ) ( mn Size - ( mn Ring Width * _ NUM ) ) / _ NUM ; mn View Center = mn Size / _ NUM ; mn Line Width =  STATUS_ SYMBOL_ WIDTH_ PERCENT * mn Size ; }
public static void write ( float lt , float ln ,  Image image , int image_width , int image_height ,  Link Properties properties ,  Data Output Stream dos ) throws  IOException ,  Interrupted Exception { int [ ] pixels = new int [ image_width * image_height ] ;  Pixel Grabber pixelgrabber = new  Pixel Grabber ( image , _ NUM , _ NUM , image_width , image_height , pixels , _ NUM , image_width ) ; pixelgrabber . grab Pixels ( ) ;  Link Raster . write ( lt , ln , image_width , image_height , pixels , properties , dos ) ; }
private void check Preload ( ) throws  Exception { assert cache Mode ==  PARTITIONED ; start Up ( ) ;  Collection <  Igfs File > files = write ( ) ;  Map <  UUID ,  Integer > exp Sizes = new  Hash Map < > (  GRID_ CNT , _ NUM ) ; for (  Igfs File file : files ) { for (  Igfs Block block : file . blocks ( ) ) {  Collection <  UUID > ids = primary Or Backups ( block . key ( ) ) ; for (  UUID id : ids ) { if ( exp Sizes . get ( id ) == null ) exp Sizes . put ( id , block . length ( ) ) ; else exp Sizes . put ( id , exp Sizes . get ( id ) + block . length ( ) ) ; } } } info ( _ STR + exp Sizes ) ; for ( int i = _ NUM ; i <  GRID_ CNT ; i ++ ) {  UUID id = grid ( i ) . local Node ( ) . id ( ) ;  Grid Cache Adapter <  Igfs Block Key , byte [ ] > cache = cache ( id ) ; int exp Size = exp Sizes . get ( id ) != null ? exp Sizes . get ( id ) : _ NUM ; assert Equals ( exp Size , cache . igfs Data Space Used ( ) ) ; }  Ignite g = start Grid (  GRID_ CNT ) ; info ( _ STR + g . cluster ( ) . local Node ( ) . id ( ) ) ; await Partition Map Exchange ( ) ; exp Sizes . clear ( ) ; for (  Igfs File file : files ) { for (  Igfs Block block : file . blocks ( ) ) {  Collection <  UUID > ids = primary Or Backups ( block . key ( ) ) ; assert ! ids . is Empty ( ) ; for (  UUID id : ids ) { if ( exp Sizes . get ( id ) == null ) exp Sizes . put ( id , block . length ( ) ) ; else exp Sizes . put ( id , exp Sizes . get ( id ) + block . length ( ) ) ; } } } info ( _ STR + exp Sizes ) ; for ( int i = _ NUM ; i <  GRID_ CNT - _ NUM ; i ++ ) {  UUID id = grid ( i ) . local Node ( ) . id ( ) ;  Grid Cache Adapter <  Igfs Block Key , byte [ ] > cache = cache ( id ) ; int exp Size = exp Sizes . get ( id ) != null ? exp Sizes . get ( id ) : _ NUM ; assert Equals ( _ STR + id , exp Size , cache . igfs Data Space Used ( ) ) ; } }
void save Offset In External Store (  String topic , int partition , long offset ) { try {  File Writer writer = new  File Writer ( storage Name ( topic , partition ) , _ BOOL ) ;  Buffered Writer buffered Writer = new  Buffered Writer ( writer ) ; buffered Writer . write ( offset + _ STR ) ; buffered Writer . flush ( ) ; buffered Writer . close ( ) ; } catch (  Exception e ) { e . print Stack Trace ( ) ; throw new  Runtime Exception ( e ) ; } }
public static boolean is Relay State URLValid (  String meta Alias ,  String relay State ,  String role ) { boolean result = _ BOOL ; if ( meta Alias != null ) {  String realm =  SAML2 Meta Utils . get Realm By Meta Alias ( meta Alias ) ; try {  String host Entity ID = saml2 Meta Manager . get Entity By Meta Alias ( meta Alias ) ; if ( host Entity ID != null ) { validate Relay State URL ( realm , host Entity ID , relay State , role ) ; result = _ BOOL ; } } catch (  SAML2 Exception e ) { if ( debug . message Enabled ( ) ) { debug . message ( _ STR + relay State + _ STR + role + _ STR + e . get Message ( ) , e ) ; } result = _ BOOL ; } } if ( debug . message Enabled ( ) ) { debug . message ( _ STR + relay State + _ STR + role + _ STR + result ) ; } return result ; }
public static void add Servers To Site (  SSOToken sso Token ,  String site Name ,  Collection server Instance Names ) throws  SMSException ,  SSOException ,  Configuration Exception {  String site Id = get Site Id ( sso Token , site Name ) ; if ( site Id != null ) { for (  Iterator i = server Instance Names . iterator ( ) ; i . has Next ( ) ; ) {  String svr = (  String ) i . next ( ) ;  Server Configuration . add To Site ( sso Token , svr , site Name ) ; } } }
private int parent Height ( ) {  Container parent = get Parent ( ) ; if ( parent != null ) { return parent . get Height ( ) ; } return get Height ( ) ; }
private  String preprocess SLD (  Styled Layer Descriptor sld ) { if ( sld == null ) { return null ; }  SLDWriter Interface sld Writer =  SLDWriter Factory . create Writer ( null ) ;  Duplicating Style Visitor duplicator = new  Duplicating Style Visitor ( ) ; sld . accept ( duplicator ) ;  Styled Layer Descriptor sld Copy = (  Styled Layer Descriptor ) duplicator . get Copy ( ) ; for (  Styled Layer styled Layer : sld Copy . layers ( ) ) { if ( styled Layer instanceof  User Layer ) {  User Layer Impl user Layer = (  User Layer Impl ) styled Layer ; user Layer . set Inline Feature Datastore ( null ) ; user Layer . set Inline Feature Type ( null ) ; } }  String sld Contents = sld Writer . encode SLD ( null , sld Copy ) ; return sld Contents ; }
private static void garbage Collect ( ) { try {  System . gc ( ) ;  Thread . sleep ( _ NUM ) ;  System . run Finalization ( ) ;  Thread . sleep ( _ NUM ) ;  System . gc ( ) ;  Thread . sleep ( _ NUM ) ;  System . run Finalization ( ) ;  Thread . sleep ( _ NUM ) ; } catch (  Interrupted Exception ex ) { ex . print Stack Trace ( ) ; } }
private void display All String Defined In String Xml ( ) {  Simple Icon Font Text View text View = (  Simple Icon Font Text View ) find View By Id (  R . id . text_view_2 ) ;  List <  String > list = new  Array List < > ( ) ; list . add ( get String (  R . string . cubeicon_gems_logo ) ) ; list . add ( get String (  R . string . cubeicon_android ) ) ; list . add ( get String (  R . string . cubeicon_heart ) ) ;  String text =  Text Utils . join ( _ STR , list ) ; text View . set Text ( text ) ; }
public static void send Error (  Http Servlet Request request ,  Http Servlet Response response , int http Status Code ,  String error Code ,  String error Msg ) { if ( ( error Url == null ) || ( error Url . length ( ) == _ NUM ) ) { try { response . send Error ( http Status Code , error Msg ) ; return ; } catch (  IOException ioe ) { debug . error ( _ STR , ioe ) ; } } else {  String joint String = _ STR ; if ( error Url . index Of ( _ STR ) != - _ NUM ) { joint String = _ STR ; }  String new Url = error Url . trim ( ) + joint String + _ STR + error Code + _ STR + _ STR + http Status Code + _ STR + _ STR +  URLEnc Dec . encode ( error Msg ) ; if ( debug . message Enabled ( ) ) { debug . message ( _ STR + new Url ) ; }  String tmp = error Url . to Lower Case ( ) ; if ( tmp . starts With ( _ STR ) || tmp . starts With ( _ STR ) ) { try { response . send Redirect ( new Url ) ; } catch (  IOException e ) { debug . error ( _ STR + _ STR + new Url , e ) ; } } else { try {  Request Dispatcher dispatcher = request . get Request Dispatcher ( new Url ) ; dispatcher . forward ( request , response ) ; } catch (  Servlet Exception e ) { debug . error ( _ STR + _ STR + new Url , e ) ; } catch (  IOException e ) { debug . error ( _ STR + _ STR + new Url , e ) ; } } } }
protected  Foreign Key Constraint build Foreign Key Constraint (  List <  String > fk Field Names ,  List <  String > pk Field Names ,  Table Definition target Table ,  Database Platform platform ) { assert fk Field Names . size ( ) > _ NUM && fk Field Names . size ( ) == pk Field Names . size ( ) ;  Foreign Key Constraint fk Constraint = new  Foreign Key Constraint ( ) ; for ( int i = _ NUM ; i < fk Field Names . size ( ) ; i ++ ) { fk Constraint . get Source Fields ( ) . add ( fk Field Names . get ( i ) ) ; fk Constraint . get Target Fields ( ) . add ( pk Field Names . get ( i ) ) ; } fk Constraint . set Target Table ( target Table . get Full Name ( ) ) ;  String fk Field Name = fk Field Names . get ( _ NUM ) ;  String name = build Foreign Key Constraint Name ( this . get Name ( ) , fk Field Name , platform . get Max Foreign Key Name Size ( ) , platform ) ; fk Constraint . set Name ( name ) ; return fk Constraint ; }
public void member Joined (  Client Membership Event event ) {  Notification notification = new  Notification (  JMXNotification Type .  CLIENT_ JOINED , server Source ,  Sequence Number . next ( ) ,  System . current Time Millis ( ) ,  Management Constants .  CLIENT_ JOINED_ PREFIX + event . get Member Id ( ) ) ; server Level Notif Emitter . send Notification ( notification ) ; member Level Notif Emitter . send Notification ( notification ) ; }
Map <  String ,  String > add Presets To Tags (  Preset Item preset ,  Linked Hash Map <  String ,  String > tags ) {  Linked Hash Map <  String ,  String > left Overs = new  Linked Hash Map <  String ,  String > ( ) ; if ( preset != null ) {  List <  Preset Item > linked Preset List = preset . get Linked Presets ( ) ; for (  String key : tags . key Set ( ) ) { if ( preset . has Key Value ( key , tags . get ( key ) ) ) { store Preset ( key , preset ) ; } else { boolean found = _ BOOL ; if ( linked Preset List != null ) { for (  Preset Item linked Preset : linked Preset List ) { if ( linked Preset . has Key Value ( key , tags . get ( key ) ) ) { store Preset ( key , linked Preset ) ; found = _ BOOL ; break ; } } } if ( ! found ) { left Overs . put ( key , tags . get ( key ) ) ; } } } } else {  Log . e (  DEBUG_ TAG , _ STR ) ; } return left Overs ; }
public void deselect All ( final boolean should Fire Events ) { check Widget ( ) ; items . add All ( selection ) ; final  List <  DLItem > deselected Items = new  Array List <  DLItem > ( ) ; for ( final  DLItem item : selection ) { item . set Last Action (  LAST_ ACTION .  DESELECTION ) ; deselected Items . add ( item ) ; if ( should Fire Events ) { fire Selection Event ( item ) ; } } fire Selection Change Event ( deselected Items ) ; selection . clear ( ) ; redraw Tables ( ) ; }
public void rotate Way ( final  Way way , final float angle , final int direction , final float pivot X , final float pivot Y , int w , int h ,  Bounding Box v ) { if ( way . get Nodes ( ) == null ) {  Log . d ( _ STR , _ STR + way . get Osm Id ( ) + _ STR ) ; return ; } dirty = _ BOOL ; try {  Hash Set <  Node > nodes = new  Hash Set <  Node > ( way . get Nodes ( ) ) ; for (  Node nd : nodes ) { undo . save ( nd ) ; api Storage . insert Element Safe ( nd ) ; float node X =  Geo Math . lon E7 To X ( w , v , nd . get Lon ( ) ) ; float node Y =  Geo Math . lat E7 To Y ( h , w , v , nd . get Lat ( ) ) ; float new X = pivot X + ( node X - pivot X ) * ( float )  Math . cos ( angle ) - direction * ( node Y - pivot Y ) * ( float )  Math . sin ( angle ) ; float new Y = pivot Y + direction * ( node X - pivot X ) * ( float )  Math . sin ( angle ) + ( node Y - pivot Y ) * ( float )  Math . cos ( angle ) ; int lat =  Geo Math . y To Lat E7 ( h , w , v , new Y ) ; int lon =  Geo Math . x To Lon E7 ( w , v , new X ) ; nd . set Lat ( lat ) ; nd . set Lon ( lon ) ; nd . update State (  Osm Element .  STATE_ MODIFIED ) ; } record Imagery ( ) ; } catch (  Storage Exception e ) { e . print Stack Trace ( ) ; } }
public static void add Listener (  Listener listener ) { if ( ! listeners . contains ( listener ) ) listeners . add ( listener ) ; }
@  Override public boolean equals (  Object obj ) { return ( obj instanceof  String Compare ) ; }
public static  List <  Entry > load Entries From Assets (  Asset Manager am ,  String path ) {  List <  Entry > entries = new  Array List <  Entry > ( ) ;  Buffered Reader reader = null ; try { reader = new  Buffered Reader ( new  Input Stream Reader ( am . open ( path ) , _ STR ) ) ;  String line = reader . read Line ( ) ; while ( line != null ) {  String [ ] split = line . split ( _ STR ) ; if ( split . length <= _ NUM ) { entries . add ( new  Entry (  Float . parse Float ( split [ _ NUM ] ) ,  Integer . parse Int ( split [ _ NUM ] ) ) ) ; } else { float [ ] vals = new float [ split . length - _ NUM ] ; for ( int i = _ NUM ; i < vals . length ; i ++ ) { vals [ i ] =  Float . parse Float ( split [ i ] ) ; } entries . add ( new  Bar Entry ( vals ,  Integer . parse Int ( split [ split . length - _ NUM ] ) ) ) ; } line = reader . read Line ( ) ; } } catch (  IOException e ) {  Log . e (  LOG , e . to String ( ) ) ; } finally { if ( reader != null ) { try { reader . close ( ) ; } catch (  IOException e ) {  Log . e (  LOG , e . to String ( ) ) ; } } } return entries ; }
public void test_copy Stream_full Block Plus One ( ) throws  IOException { final  String id = _ STR ; final int version = _ NUM ;  Random r = new  Random ( ) ; final byte [ ] expected = new byte [  BLOCK_ SIZE + _ NUM ] ; r . next Bytes ( expected ) ; assert Equals ( _ STR , expected . length , repo . copy Stream ( id , version , new  Byte Array Input Stream ( expected ) ) ) ; assert Equals ( _ STR , _ NUM , repo . get Block Count ( id , version ) ) ; assert Same Iterator ( _ STR , new  Long [ ] { _ NUM , _ NUM } , repo . blocks ( id , version ) ) ; assert Equals ( _ STR , expected , read ( repo . input Stream ( id , version ) ) ) ; }
public  Singleton Task (  Scheduled Executor Service ses ,  Runnable task ) { super ( ) ; this . task = task ; this . ses = ses ; }
private void is Reversed Transaction (  String client Id ,  String transaction Id ) { final  Boolean is Reversed =  Client Helper . get Client Transactions ( this . request Spec , this . response Spec , client Id . to String ( ) , transaction Id ) ;  Assert . assert True ( is Reversed ) ; }
public static  File savepoint File (  File instance Path ) {  File temp Dir = new  File (  Collect .  CACHE_ PATH ) ; return new  File ( temp Dir , instance Path . get Name ( ) + _ STR ) ; }
@  Override public void add Layout Complete Event Listener (  Layout Complete Event Listener l ) { if ( layout Complete Listeners == null ) { layout Complete Listeners = new  Array List <  Layout Complete Event Listener > ( ) ; } layout Complete Listeners . add ( l ) ; }
public  P12 Reader (  Input Stream input Stream ,  String password ) throws  General Security Exception ,  IOException { this . password = password ; key Store =  Key Store . get Instance (  KEYSTORE_ TYPE ) ; key Store . load ( input Stream , password . to Char Array ( ) ) ;  Enumeration aliases = key Store . aliases ( ) ; if ( aliases . has More Elements ( ) ) alias = (  String ) aliases . next Element ( ) ; }
public static  Tungsten Properties load From JSON (  String json ) throws  Json Parse Exception ,  Json Mapping Exception ,  IOException {  Object Mapper mapper = new  Object Mapper ( ) ;  Tungsten Properties tungsten Prop = mapper . read Value ( json ,  Tungsten Properties . class ) ; return tungsten Prop ; }
protected static int to Digit ( final char ch , final int index ) throws  Illegal Argument Exception { final int digit =  Character . digit ( ch , _ NUM ) ; if ( digit == - _ NUM ) { throw new  Illegal Argument Exception ( _ STR + ch + _ STR + index ) ; } return digit ; }
public  JSONObject to JSON ( ) throws  JSONException {  JSONObject json = new  JSONObject ( ) ; if ( entries . size ( ) > _ NUM ) {  JSONObject history = new  JSONObject ( ) ; for (  Entry e : entries ) { history . put ( e . push Id , e . timestamp ) ; } json . put ( _ STR , history ) ; } json . put Opt ( _ STR , last Time ) ; return json ; }
public static void save (  Key Store key Store ,  File key Store File ,  Password password ) throws  Crypto Exception ,  IOException {  Key Store Type key Store Type =  Key Store Type . resolve Jce ( key Store . get Type ( ) ) ; if ( ! key Store Type . is File Based ( ) ) { throw new  Crypto Exception (  Message Format . format ( res . get String ( _ STR ) , key Store Type . jce ( ) ) ) ; }  File Output Stream fos = null ; fos = new  File Output Stream ( key Store File ) ; try { key Store . store ( fos , password . to Char Array ( ) ) ; } catch (  IOException ex ) { throw new  Crypto Exception ( res . get String ( _ STR ) , ex ) ; } catch (  Key Store Exception ex ) { throw new  Crypto Exception ( res . get String ( _ STR ) , ex ) ; } catch (  Certificate Exception ex ) { throw new  Crypto Exception ( res . get String ( _ STR ) , ex ) ; } catch (  No Such Algorithm Exception ex ) { throw new  Crypto Exception ( res . get String ( _ STR ) , ex ) ; } finally {  IOUtils . close Quietly ( fos ) ; } }
public static boolean is Auto Scan Enabled (  Context context ) { final  Shared Preferences prefs =  Preference Manager . get Default Shared Preferences ( context ) ; return prefs . get Boolean ( context . get String (  R . string . pref_key_auto_scan_enabled ) ,  Boolean . parse Boolean ( context . get String (  R . string . pref_auto_scan_default_value ) ) ) ; }
@  Override public boolean equals (  Object o ) { if ( this == o ) { return _ BOOL ; } if ( ! ( o instanceof  Long Bit Set ) ) { return _ BOOL ; }  Long Bit Set other = (  Long Bit Set ) o ; if ( num Bits != other . num Bits ) { return _ BOOL ; } return  Arrays . equals ( bits , other . bits ) ; }
@  Override public boolean equals (  Object obj ) { if ( obj == this ) { return _ BOOL ; } if ( ! ( obj instanceof  Stacked XYBar Renderer ) ) { return _ BOOL ; }  Stacked XYBar Renderer that = (  Stacked XYBar Renderer ) obj ; if ( this . render As Percentages != that . render As Percentages ) { return _ BOOL ; } return super . equals ( obj ) ; }
static boolean verify Zip File (  File file ) { try {  Zip File zip File = new  Zip File ( file ) ; try { zip File . close ( ) ; return _ BOOL ; } catch (  IOException e ) {  Log . w (  TAG , _ STR + file . get Absolute Path ( ) ) ; } } catch (  Zip Exception ex ) {  Log . w (  TAG , _ STR + file . get Absolute Path ( ) + _ STR , ex ) ; } catch (  IOException ex ) {  Log . w (  TAG , _ STR + file . get Absolute Path ( ) , ex ) ; } return _ BOOL ; }
protected int unicode Escape Lexer ( int c ) throws  IOException { int ret = _ NUM ; c = in . read ( ) ; code . clear ( ) ; try { for ( int i = _ NUM ; i < _ NUM ; i ++ ) { c = in . read ( ) ; if ( is End Of File ( c ) || is End Of Line ( c ) ) { throw new  Number Format Exception ( _ STR ) ; } code . append ( ( char ) c ) ; } ret =  Integer . parse Int ( code . to String ( ) , _ NUM ) ; } catch (  Number Format Exception e ) { throw new  IOException ( _ STR + get Line Number ( ) + _ STR + code . to String ( ) + _ STR + e . to String ( ) ) ; } return ret ; }
protected static void compute Cartesian (  List <  Event Bean [ ] > stream One , int [ ] sub Stream Nums One ,  List <  Event Bean [ ] > stream Two , int [ ] sub Stream Nums Two ,  List <  Event Bean [ ] > result List ) { if ( ( stream Two == null ) || ( stream Two . is Empty ( ) ) ) { if ( ( stream One == null ) || ( stream One . is Empty ( ) ) ) { return ; } result List . add All ( stream One ) ; return ; } if ( ( stream One == null ) || ( stream One . is Empty ( ) ) ) { result List . add All ( stream Two ) ; return ; } int stream One Size = stream One . size ( ) ; int stream Two Size = stream Two . size ( ) ; if ( stream One Size == _ NUM ) { copy To Each ( sub Stream Nums One , stream One . get ( _ NUM ) , stream Two ) ; result List . add All ( stream Two ) ; return ; } if ( stream Two Size == _ NUM ) { copy To Each ( sub Stream Nums Two , stream Two . get ( _ NUM ) , stream One ) ; result List . add All ( stream One ) ; return ; } if ( stream Two Size > stream One Size ) {  List <  Event Bean [ ] > hold Rows = stream One ; int hold Size = stream One Size ; stream One = stream Two ; stream One Size = stream Two Size ; stream Two = hold Rows ; stream Two Size = hold Size ; sub Stream Nums Two = sub Stream Nums One ; } int cartesian Total Rows = stream One Size * stream Two Size ; int num Columns = stream One . get ( _ NUM ) . length ;  Event Bean [ ] [ ] results = new  Event Bean [ cartesian Total Rows ] [ ] ; int stream One Count = _ NUM ; for (  Event Bean [ ] row : stream One ) { results [ stream One Count ] = row ; for ( int i = _ NUM ; i < stream Two Size ; i ++ ) {  Event Bean [ ] dup Row = new  Event Bean [ num Columns ] ;  System . arraycopy ( row , _ NUM , dup Row , _ NUM , num Columns ) ; int index = stream One Size * i + stream One Count ; results [ index ] = dup Row ; } stream One Count ++ ; } int stream Two Count = _ NUM ; for (  Event Bean [ ] row : stream Two ) { for ( int i = _ NUM ; i < stream One Size ; i ++ ) { int index = stream Two Count * stream One Size + i ; copy ( sub Stream Nums Two , row , results [ index ] ) ; } stream Two Count ++ ; } result List . add All (  Arrays . as List ( results ) ) ; }
private static  Kdb Group deserialize Group (  Kdb Group last Group ,  Data Input data Input ) throws  IOException { int field Type ;  Kdb Group group = new  Kdb Group ( ) ; while ( ( field Type = data Input . read Unsigned Short ( ) ) != _ NUM ) { switch ( field Type ) { case _ NUM : read Ext Data ( data Input ) ; break ; case _ NUM :  UUID uuid = new  UUID ( _ NUM , read Int ( data Input ) ) ; group . set Uuid ( uuid ) ; break ; case _ NUM : group . set Name ( read String ( data Input ) ) ; break ; case _ NUM : group . set Creation Time ( read Date ( data Input ) ) ; break ; case _ NUM : group . set Last Modification Time ( read Date ( data Input ) ) ; break ; case _ NUM : group . set Last Access Time ( read Date ( data Input ) ) ; break ; case _ NUM : group . set Expiry Time ( read Date ( data Input ) ) ; break ; case _ NUM : group . set Icon ( new  Kdb Icon ( read Int ( data Input ) ) ) ; break ; case _ NUM : int level = read Short ( data Input ) ; group . set Parent ( compute Parent Group ( last Group , level ) ) ; break ; case _ NUM : group . set Flags ( read Int ( data Input ) ) ; break ; default : throw new  Illegal State Exception ( _ STR ) ; } } data Input . read Int ( ) ; return group ; }
private  Diff Part decode Replace ( final int block Size_ S , final int block Size_ E , final int block Size_ L ) throws  Unsupported Encoding Exception ,  Decoding Exception { if ( block Size_ S < _ NUM || block Size_ E < _ NUM || block Size_ L < _ NUM ) { throw new  Decoding Exception ( _ STR + block Size_ S + _ STR + block Size_ E + _ STR + block Size_ L ) ; } int s = r . read ( block Size_ S ) ; int e = r . read ( block Size_ E ) ; int l = r . read ( block Size_ L ) ;  Byte Array Output Stream output = new  Byte Array Output Stream ( ) ; for ( int i = _ NUM ; i < l ; i ++ ) { output . write ( r . read Byte ( ) ) ; }  Diff Part part = new  Diff Part (  Diff Action .  REPLACE ) ; part . set Start ( s ) ; part . set Length ( e ) ; part . set Text ( output . to String (  WIKIPEDIA_ ENCODING ) ) ; return part ; }
private void run Regression ( ) { runner . execute ( ) ;  Graph graph = runner . get Out Graph ( ) ;  Graph Utils . circle Layout ( graph , _ NUM , _ NUM , _ NUM ) ;  Graph Utils . fruchterman Reingold Layout ( graph ) ; workbench . set Graph ( graph ) ;  Regression Result report = runner . get Result ( ) ; report Text . set Text ( report . to String ( ) ) ; text With Table . remove All ( ) ; text With Table . set Layout ( new  Border Layout ( ) ) ; text With Table . add (  Text With Table . component ( report . get Preamble ( ) , report . get Results Table ( ) ) ) ; text With Table . revalidate ( ) ; text With Table . repaint ( ) ; }
protected void fill ( ) throws  IOException { ensure Open ( ) ; len = in . read ( buf , _ NUM , buf . length ) ; if ( len == - _ NUM ) { throw new  EOFException ( _ STR ) ; } inf . set Input ( buf , _ NUM , len ) ; }
@  Override @  Nullable protected  Object extract Parameter ( @  Nullable  String cache Name ,  String type Name ,  Type Kind type Kind ,  String fld Name ,  Object obj ) throws  Cache Exception { switch ( type Kind ) { case  BUILT_ IN : return obj ; case  POJO : return extract Pojo Parameter ( cache Name , type Name , fld Name , obj ) ; default : return extract Binary Parameter ( fld Name , obj ) ; } }
public final void go To Last Page ( ) { view Pager . set Current Item ( pages . size ( ) - _ NUM ) ; }
public  List <  Class < ? > > parameter List ( ) { return  Collections . unmodifiable List (  Arrays . as List ( ptypes . clone ( ) ) ) ; }
private static void add Rules (  List <  String > batch List ,  List <  Rule > rules To Add ) {  String add Statement = _ STR +  RULES_ TABLE + _ STR + _ STR + _ STR + _ STR + _ STR ; for (  Rule rule : rules To Add ) { batch List . add (  String . format ( add Statement , rule . get Name ( ) , rule . get Description ( ) , rule . get Membership Rule ( ) ) ) ; } }
private synchronized void perform ( ) { if ( done ) return ; while ( my Elements . has Next ( ) ) {  Object element = my Elements . next ( ) ; if ( ! is Visited ( element ) ) { visit ( element , _ NUM ) ; } } }
protected  Grid Client Abstract Projection (  Grid Client Impl client ,  Collection <  Grid Client Node > nodes ,  Grid Client Predicate < ? super  Grid Client Node > filter ,  Grid Client Load Balancer balancer ) { assert client != null ; this . client = client ; this . nodes = nodes ; this . filter = filter ; this . balancer = balancer ; }
public static <  T >  Completable Future <  T > exceptional Future (  Throwable t ) {  Completable Future <  T > future = new  Completable Future < > ( ) ; future . complete Exceptionally ( t ) ; return future ; }
protected void update Numeric Scores ( double [ ] predicted , double [ ] actual , double weight ) { double diff ; double sum Err = _ NUM , sum Abs Err = _ NUM , sum Sqr Err = _ NUM ; double sum Prior Abs Err = _ NUM , sum Prior Sqr Err = _ NUM ; for ( int i = _ NUM ; i < m_ Num Classes ; i ++ ) { diff = predicted [ i ] - actual [ i ] ; sum Err += diff ; sum Abs Err +=  Math . abs ( diff ) ; sum Sqr Err += diff * diff ; diff = ( m_ Class Priors [ i ] / m_ Class Priors Sum ) - actual [ i ] ; sum Prior Abs Err +=  Math . abs ( diff ) ; sum Prior Sqr Err += diff * diff ; } m_ Sum Err += weight * sum Err / m_ Num Classes ; m_ Sum Abs Err += weight * sum Abs Err / m_ Num Classes ; m_ Sum Sqr Err += weight * sum Sqr Err / m_ Num Classes ; m_ Sum Prior Abs Err += weight * sum Prior Abs Err / m_ Num Classes ; m_ Sum Prior Sqr Err += weight * sum Prior Sqr Err / m_ Num Classes ; }
public boolean check Modifiers (  Mouse Event e ) { return ( e . get Modifiers ( ) & modifiers ) != _ NUM ; }
void output Variables (  List <  Var Holder > vars ) { boolean first = _ BOOL ; for (  Var Holder vh : vars ) { if ( vh . name != null ) { if ( first ) { gen . out ( _ STR , vh . name ) ; first = _ BOOL ; } else { gen . out ( _ STR , vh . name ) ; } } else if ( vh . destr != null && vh . vars != null ) { for (  Tree .  Variable v : vh . vars ) { final  String vname = names . name ( v . get Declaration Model ( ) ) ; if ( first ) { gen . out ( _ STR , vname ) ; first = _ BOOL ; } else { gen . out ( _ STR , vname ) ; } } } } if ( ! first ) { gen . end Line ( _ BOOL ) ; } }
public void lazy KBest Extract On HG (  Hyper Graph hg , int top N ,  Buffered Writer out ) throws  IOException { reset State ( ) ; if ( null == hg . goal Node ) return ; for ( int k = _ NUM ; k <= top N ; k ++ ) {  String hyp Str = get Kth Hyp ( hg . goal Node , k ) ; if ( null == hyp Str ) break ; out . write ( hyp Str ) ; out . write ( _ STR ) ; out . flush ( ) ; } }
private boolean is VMAX3 Volume (  Volume volume ) { boolean is VMAX3 = _ BOOL ; if (  URIUtil . is Type ( volume . get Storage Controller ( ) ,  Storage System . class ) ) {  Storage System storage = _db Client . query Object (  Storage System . class , volume . get Storage Controller ( ) ) ; is VMAX3 = ( storage != null && storage . check If Vmax3 ( ) ) ; } return is VMAX3 ; }
private  List <  File Descriptor > prepare File Descriptors (  List <  File Share > filesystems ,  Virtual Pool Capability Values Wrapper cos Capabilities ,  String suggested Id ) { final  List <  File Descriptor > file Descriptors = new  Array List <  File Descriptor > ( ) ; for (  File Share filesystem : filesystems ) {  File Descriptor desc = new  File Descriptor (  File Descriptor .  Type .  FILE_ DATA , filesystem . get Storage Device ( ) , filesystem . get Id ( ) , filesystem . get Pool ( ) , filesystem . get Capacity ( ) , cos Capabilities , null , suggested Id ) ; file Descriptors . add ( desc ) ; } return file Descriptors ; }
private  String strip Tags (  String string ) { return string . replace All ( _ STR , _ STR ) ; }
public static double logpdf ( double val , double alpha , double beta ) { if ( alpha <= _ NUM || beta <= _ NUM ||  Double . is Na N ( alpha ) ||  Double . is Na N ( beta ) ||  Double . is Na N ( val ) ) { return  Double .  Na N ; } if ( val < _ NUM || val > _ NUM ) { return  Double .  NEGATIVE_ INFINITY ; } if ( val == _ NUM ) { return ( alpha > _ NUM ) ?  Double .  NEGATIVE_ INFINITY : ( alpha < _ NUM ) ?  Double .  POSITIVE_ INFINITY :  Math . log ( beta ) ; } if ( val == _ NUM ) { return ( beta > _ NUM ) ?  Double .  NEGATIVE_ INFINITY : ( beta < _ NUM ) ?  Double .  POSITIVE_ INFINITY :  Math . log ( alpha ) ; } return - log Beta ( alpha , beta ) +  Math . log ( val ) * ( alpha - _ NUM ) +  Math . log1p ( - val ) * ( beta - _ NUM ) ; }
public void verify Signature (  String message ,  String signature ,  String algorithm Uri ) throws  Illegal State Exception ,  Websso Client Exception { log . debug ( _ STR ) ;  Validate . not Null ( message , _ STR ) ;  Validate . not Null ( signature , _ STR ) ;  Validate . not Null ( algorithm Uri , _ STR ) ;  Validate . not Null ( get Certificate ( ) , _ STR ) ; boolean verifies = _ BOOL ;  String decoded Algorithm Uri = null ; byte [ ] decoded Signature = null ; try { decoded Algorithm Uri =  URLDecoder . decode ( algorithm Uri , _ STR ) ; log . debug ( _ STR , decoded Algorithm Uri ) ; decoded Signature =  Base64 . decode (  URLDecoder . decode ( signature , _ STR ) ) ; } catch (  Unsupported Encoding Exception e ) { throw new  Websso Client Exception ( _ STR , e ) ; } try {  Signature Algorithm algo =  Signature Algorithm . get Signature Algorithm For URI ( decoded Algorithm Uri ) ;  Signature sig =  Signature . get Instance ( algo . get Algorithm Name ( ) ) ;  X509 Certificate cert = get Certificate ( ) ; sig . init Verify ( cert . get Public Key ( ) ) ; sig . update ( message . get Bytes ( _ STR ) ) ; verifies = sig . verify ( decoded Signature ) ; log . debug ( _ STR + verifies ) ; } catch (  Exception e ) { log . error ( _ STR , e ) ; throw new  Illegal State Exception ( e ) ; } if ( ! verifies ) { throw new  Illegal State Exception ( _ STR ) ; } }
private  Collection <  Hadoop Task Info > mapper Tasks (  Iterable <  Hadoop Input Split > mappers ,  Hadoop Job Metadata meta ) {  UUID loc Node Id = ctx . local Node Id ( ) ;  Hadoop Job Id job Id = meta . job Id ( ) ;  Job Local State state = active Jobs . get ( job Id ) ;  Collection <  Hadoop Task Info > tasks = null ; if ( mappers != null ) { if ( state == null ) state = init State ( job Id ) ; for (  Hadoop Input Split split : mappers ) { if ( state . add Mapper ( split ) ) { if ( log . is Debug Enabled ( ) ) log . debug ( _ STR + loc Node Id + _ STR + split + _ STR ) ;  Hadoop Task Info task Info = new  Hadoop Task Info (  MAP , job Id , meta . task Number ( split ) , _ NUM , split ) ; if ( tasks == null ) tasks = new  Array List < > ( ) ; tasks . add ( task Info ) ; } } } return tasks ; }
public void test Get Servlet Run As Role ( ) throws  Exception {  String xml =  WEBAPP_ TEST_ HEADER + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR ;  Web Xml web Xml =  Web Xml Io . parse Web Xml ( new  Byte Array Input Stream ( xml . get Bytes ( _ STR ) ) , get Entity Resolver ( ) ) ;  String role Name =  Web Xml Utils . get Servlet Run As Role Name ( web Xml , _ STR ) ; assert Equals ( _ STR , role Name ) ; }
public  Date Time Formatter Builder append Text (  Temporal Field field ,  Text Style text Style ) {  Objects . require Non Null ( field , _ STR ) ;  Objects . require Non Null ( text Style , _ STR ) ; append Internal ( new  Text Printer Parser ( field , text Style ,  Date Time Text Provider . get Instance ( ) ) ) ; return this ; }
public static void format Line (  String format ,  Object ... args ) { if ( ! is Disabled ( ) ) { print Line (  String . format ( format , args ) ) ; } }
@  Override public synchronized void begin Turn ( ) { final long start =  System . nano Time ( ) ; try { destroy Obsolete Zones ( ) ; } catch ( final  Exception e ) { logger . error ( _ STR , e ) ; } try { log Number Of Players Online ( ) ; } catch ( final  Exception e ) { logger . error ( _ STR , e ) ; } try { handle Killed Entities ( ) ; } catch ( final  Exception e ) { logger . error ( _ STR , e ) ; } try { execute Player Logic ( ) ; } catch ( final  Exception e ) { logger . error ( _ STR , e ) ; } try { execute NPCs Pre Logic ( ) ; } catch ( final  Exception e ) { logger . error ( _ STR , e ) ; } try { handle Players Rm Texts ( ) ; } catch ( final  Exception e ) { logger . error ( _ STR , e ) ; } logger . debug ( _ STR + (  System . nano Time ( ) - start ) / _ NUM ) ; }
public int hash Code ( ) { if (  Thread . interrupted ( ) ) throw new  Runtime Exception ( ) ; int acc = _ NUM ; int c = _ NUM ; c = op . ordinal ( ) ; acc = acc * _ NUM + c ; c = low ; acc = acc * _ NUM + c ; c = high ; acc = acc * _ NUM + c ; if ( lit == null ) { acc *= _ NUM ; } else { acc = acc * _ NUM + lit . hash Code ( ) ; } if ( unary Arg == null ) { acc *= _ NUM ; } else { acc = acc * _ NUM + unary Arg . hash Code ( ) ; } if ( cats == null ) { acc *= _ NUM ; } else { acc = acc * _ NUM + cats . hash Code ( ) ; } if ( alts == null ) { acc *= _ NUM ; } else { acc = acc * _ NUM + alts . hash Code ( ) ; } if ( str Op == null ) { acc *= _ NUM ; } else { acc = acc * _ NUM + str Op . hash Code ( ) ; } return acc ; }
@  Suppress Warnings ( _ STR ) private <  T >  T allow Static Access To Member (  T member , boolean static Only ) { if ( member == null ) return null ; if ( ! static Only ) return member ; boolean is Static ; if ( member instanceof  Variable ) {  Variable v = (  Variable ) member ; is Static =  Modifier . is Static ( v . get Modifiers ( ) ) ; } else if ( member instanceof  List ) {  List <  Method Node > list = (  List <  Method Node > ) member ; if ( list . size ( ) == _ NUM ) { return (  T )  Collections . singleton List ( allow Static Access To Member ( list . get ( _ NUM ) , static Only ) ) ; } return (  T )  Collections . empty List ( ) ; } else {  Method Node mn = (  Method Node ) member ; is Static = mn . is Static ( ) ; } if ( static Only && ! is Static ) return null ; return member ; }
public  String current Date (  String format ,  String timezone ) {  Date Format formatter = get Formatter ( format ) ; if (  String Utils . is Not Blank ( timezone ) ) { formatter . set Time Zone (  Time Zone . get Time Zone ( timezone ) ) ; } return formatter . format ( new  Date ( ) ) ; }
public  KMZWriter ( final  String out Filename ) { log . set Level (  Level .  INFO ) ;  String filename = out Filename ; if ( filename . ends With ( _ STR ) || filename . ends With ( _ STR ) ) { filename = filename . substring ( _ NUM , filename . length ( ) - _ NUM ) ; } try { this . zip Out = new  Zip Output Stream ( new  File Output Stream ( filename + _ STR ) ) ; this . out = new  Buffered Writer ( new  Output Stream Writer ( this . zip Out , _ STR ) ) ; } catch (  IOException e ) { e . print Stack Trace ( ) ; }  Kml Type doc KML = kml Object Factory . create Kml Type ( ) ;  Network Link Type nl = kml Object Factory . create Network Link Type ( ) ;  Link Type link = kml Object Factory . create Link Type ( ) ; link . set Href ( _ STR ) ; nl . set Link ( link ) ; doc KML . set Abstract Feature Group ( kml Object Factory . create Network Link ( nl ) ) ; write Kml ( _ STR , doc KML ) ; }
public  String find Extension (  String mime Type ) {  Object value = mime Mappings . get ( mime Type ) ; if ( value instanceof  String [ ] ) { return ( (  String [ ] ) value ) [ _ NUM ] ; } else if ( value instanceof  String ) { return (  String ) value ; } else { return null ; } }
public  Customizer UI ( ) { init Components ( ) ; init Defaults ( ) ; update ( ) ; }
@  Override public void trim ( final long position ) { if ( ! setup ) { throw new  Illegal State Exception ( _ STR ) ; } synchronized ( lock ) { final  Iterator <  Header > iter = headers . iterator ( ) ; final  List <  Header > unlink =  Lists . new Array List ( ) ;  Header current = iter . next ( ) ; while ( iter . has Next ( ) ) { final  Header next = iter . next ( ) ; if ( next . offset ( ) >= position ) { break ; } unlink . add ( current ) ; current = next ; } for ( final  Header m : unlink ) { headers . remove ( m ) ; log . info ( _ STR , m ) ; try {  Files . delete ( m . path ( ) ) ; } catch (  IOException e ) { log . error ( _ STR , m , e ) ; } } } }
public static  List <  Web Element > find Elements Present After (  Search Context parent ,  By by , int wait In Seconds ) {  Preconditions . check Not Null ( parent ) ;  Preconditions . check Not Null ( by ) ; find Element Present After ( parent , by , wait In Seconds ) ; return parent . find Elements ( by ) ; }
public  Respoke Client create Client (  Context app Context ) { context = app Context ;  Respoke Client new Client = new  Respoke Client ( ) ; instances . add ( new Client ) ; return new Client ; }
@  Override public synchronized void parse (  Input Stream in ,  String base URI ) throws  IOException ,  RDFParse Exception ,  RDFHandler Exception { if ( in == null ) { throw new  Illegal Argument Exception ( _ STR ) ; } if ( base URI == null ) { throw new  Illegal Argument Exception ( _ STR ) ; }  Input Source input Source = new  Input Source ( new  BOMInput Stream ( in , _ BOOL ) ) ; input Source . set System Id ( base URI ) ; parse ( input Source ) ; }
public static  Date parse Date (  String date Value ,  Collection date Formats ,  Date start Date ) throws  Date Parse Exception { if ( date Value == null ) { throw new  Illegal Argument Exception ( _ STR ) ; } if ( date Formats == null ) { date Formats =  DEFAULT_ PATTERNS ; } if ( start Date == null ) { start Date =  DEFAULT_ TWO_ DIGIT_ YEAR_ START ; } if ( date Value . length ( ) > _ NUM && date Value . starts With ( _ STR ) && date Value . ends With ( _ STR ) ) { date Value = date Value . substring ( _ NUM , date Value . length ( ) - _ NUM ) ; }  Simple Date Format date Parser = null ; final  Iterator format Iter = date Formats . iterator ( ) ; while ( format Iter . has Next ( ) ) { final  String format = (  String ) format Iter . next ( ) ; if ( date Parser == null ) { date Parser = new  Simple Date Format ( format ,  Locale .  US ) ; date Parser . set Time Zone (  Time Zone . get Time Zone ( _ STR ) ) ; date Parser . set2 Digit Year Start ( start Date ) ; } else { date Parser . apply Pattern ( format ) ; } try { return date Parser . parse ( date Value ) ; } catch ( final  Parse Exception pe ) { } } throw new  Date Parse Exception ( _ STR + date Value ) ; }
public  Json Object remove (  String name ) { if ( name == null ) { throw new  Null Pointer Exception ( _ STR ) ; } int index = index Of ( name ) ; if ( index != - _ NUM ) { table . remove ( index ) ; names . remove ( index ) ; values . remove ( index ) ; } return this ; }
void sccp (  Method m ) { add Trace Attr ( _ STR , m ) ;  Deque <  Block > code = dfs ( m . entry . to ) ;  Edge Map <  Expr > uses = find Uses ( code ) ;  Map <  Expr ,  Object > values = new  Tree Map <  Expr ,  Object > ( ) ;  Map <  Expr ,  Typeref > types = new  Tree Map <  Expr ,  Typeref > ( ) ;  Set <  Edge > reached = new  Tree Set <  Edge > ( ) ; sccp_analyze ( m , uses , values , types , reached ) ; verbose Status ( _ STR + reached ) ; verbose Status ( _ STR + types ) ; sccp_cfgopt ( values , types , reached ) ; dce ( m ) ; code = dfs ( m . entry . to ) ; uses = find Uses ( code ) ;  Tree Set <  Expr > work = new  Tree Set <  Expr > ( ) ; for (  Block b : code ) for (  Expr e : b ) work . add ( e ) ; while ( ! work . is Empty ( ) ) {  Expr e = get Expr ( work ) ; sccp_modify ( m , uses , values , types , e , work ) ; } dce ( m ) ; }
private void calibrating Current Element ( long difference , float isig , byte [ ] read Data , int index ,  Medtronic Sensor Record record , int num ,  Date current Time ) { boolean calibrated = _ BOOL ; if ( is Calibrating ) { if ( num > _ NUM ) { calculate Calibration ( difference , isig , read Data [ index ] ) ; if ( calibration Factor > _ NUM ) { if ( ! is Calibrating ) { if ( calibration Status !=  Medtronic Constants .  WITHOUT_ ANY_ CALIBRATION && calibration Status !=  Medtronic Constants .  LAST_ CALIBRATION_ FAILED_ USING_ PREVIOUS && calibration Status !=  Medtronic Constants .  CALIBRATION_ MORE_ THAN_12 H_ OLD ) { record . set BGValue ( ( ( int ) last Glucometer Value ) + _ STR ) ; record . set Unfiltered Glucose ( last Glucometer Value ) ; record . calibration Factor = calibration Factor ; record . is Calibrating = _ BOOL ; record . calibration Status = calibration Status ; last Calibration Date = current Time . get Time ( ) ;  Shared Preferences .  Editor editor = settings . edit ( ) ; log . debug ( _ STR ) ; editor . put Long ( _ STR , last Calibration Date ) ; editor . commit ( ) ; calibrated = _ BOOL ; } } } } } if ( calibration Factor > _ NUM && ! calibrated ) {  List <  Record > aux List = null ; synchronized ( last Records List Lock ) { aux List = last Records In Memory . get List From Tail ( _ NUM ) ; } if ( calibration Status !=  Medtronic Constants .  WITHOUT_ ANY_ CALIBRATION ) { record . set Unfiltered Glucose ( isig * calibration Factor ) ; record . set BGValue ( ( apply Filter To Record ( record , aux List ) ) + _ STR ) ; record . is Calibrating = _ BOOL ; record . calibration Factor = calibration Factor ; record . calibration Status = calibration Status ; } else { record . set Unfiltered Glucose ( isig * calibration Factor ) ; record . set BGValue ( ( apply Filter To Record ( record , aux List ) ) + _ STR ) ; record . is Calibrating = _ BOOL ; record . calibration Factor = calibration Factor ; record . calibration Status =  Medtronic Constants .  LAST_ CALIBRATION_ FAILED_ USING_ PREVIOUS ; } } calculate Date ( record , current Time , _ NUM ) ; previous Record = record ; }
public void write To (  Print Writer out , boolean write Weights ) { out . println ( _ STR ) ; for ( int i = _ NUM ; i < num Byte Features ; i ++ ) { if ( write Weights ) { out . print ( feature Weights [ i ] + _ STR ) ; } out . print ( get Feature Name ( i ) ) ; for ( int v = _ NUM , vmax = get Number Of Values ( i ) ; v < vmax ; v ++ ) { out . print ( _ STR ) ;  String val = get Feature Value As String ( i , v ) ; out . print ( val ) ; } out . println ( ) ; } out . println ( _ STR ) ; for ( int i = _ NUM ; i < num Short Features ; i ++ ) { if ( write Weights ) { out . print ( feature Weights [ num Byte Features + i ] + _ STR ) ; } out . print ( get Feature Name ( num Byte Features + i ) ) ; for ( int v = _ NUM , vmax = get Number Of Values ( num Byte Features + i ) ; v < vmax ; v ++ ) { out . print ( _ STR ) ;  String val = get Feature Value As String ( num Byte Features + i , v ) ; out . print ( val ) ; } out . println ( ) ; } out . println ( _ STR ) ; for ( int i = _ NUM ; i < num Continuous Features ; i ++ ) { if ( write Weights ) { out . print ( feature Weights [ num Byte Features + num Short Features + i ] ) ; out . print ( _ STR ) ; out . print ( float Weight Functs [ i ] ) ; out . print ( _ STR ) ; } out . print ( get Feature Name ( num Byte Features + num Short Features + i ) ) ; out . println ( ) ; } }
public boolean is Page Break ( ) { if ( is Function Row ( ) && m_nodes != null ) { for ( int i = _ NUM ; i < m_nodes . size ( ) ; i ++ ) {  Object o = m_nodes . get ( i ) ; if ( o instanceof  Print Data Element ) {  Print Data Element pde = (  Print Data Element ) o ; if ( pde . is Page Break ( ) ) return _ BOOL ; } } } return _ BOOL ; }
public  String multi Line ( int col ) {  String val = _ STR + wf ; if ( sf == null ) { return val ; } return val + _ STR +  NSpaces ( col ) + _ STR + sf ; }
public void world To Spherical (  Vector3 vec ) { if ( pj Unprojected == null ) {  String proj Str = _ STR + proj Info . get Semi Major Axis ( ) + _ STR + proj Info . get Semi Minor Axis ( ) + _ STR ; pj Unprojected =  Proj4 . new Instance ( proj Str ) ; } if ( pj Projected == null ) { pj Projected =  Proj4 . new Instance ( proj4 String ) ; } try { vec . to Array ( coord ) ; pj Projected . transform ( pj Unprojected , coord ) ; vec . set X (  Math . to Degrees ( coord [ _ NUM ] ) ) ; vec . set Y (  Math . to Degrees ( coord [ _ NUM ] ) ) ; } catch (  Exception e ) { e . print Stack Trace ( ) ; } }
public static  String encode For POST ( final  String str ) { try { return  Base64 . encode ( str . get Bytes ( _ STR ) , _ BOOL ) ; } catch (  Unsupported Encoding Exception uee ) { debug . error ( _ STR , uee ) ; return null ; } }
public boolean draw Image (  Image img ,  Affine Transform xform ,  Image Observer obs ) { if ( img == null ) { return _ BOOL ; } m Drawing Area . add Infinite ( ) ; m Print Metrics . draw Image ( this , img ) ; return m Graphics . draw Image ( img , xform , obs ) ; }
private  String print OFormat ( long x ) {  String sx = null ; if ( x ==  Long .  MIN_ VALUE ) sx = _ STR ; else if ( x < _ NUM ) {  String t =  Long . to String ( ( ~ ( - x - _ NUM ) ) ^  Long .  MIN_ VALUE , _ NUM ) ; switch ( t . length ( ) ) { case _ NUM : sx = _ STR + t ; break ; case _ NUM : sx = _ STR + t ; break ; case _ NUM : sx = _ STR + t ; break ; case _ NUM : sx = _ STR + t ; break ; case _ NUM : sx = _ STR + t ; break ; case _ NUM : sx = _ STR + t ; break ; case _ NUM : sx = _ STR + t ; break ; case _ NUM : sx = _ STR + t ; break ; case _ NUM : sx = _ STR + t ; break ; case _ NUM : sx = _ STR + t ; break ; case _ NUM : sx = _ STR + t ; break ; case _ NUM : sx = _ STR + t ; break ; case _ NUM : sx = _ STR + t ; break ; case _ NUM : sx = _ STR + t ; break ; case _ NUM : sx = _ STR + t ; break ; case _ NUM : sx = _ STR + t ; break ; case _ NUM : sx = _ STR + t ; break ; case _ NUM : sx = _ STR + t ; break ; case _ NUM : sx = _ STR + t ; break ; case _ NUM : sx = _ STR + t ; break ; case _ NUM : sx = _ STR + t ; break ; } } else sx =  Long . to String ( x , _ NUM ) ; return print OFormat ( sx ) ; }
public boolean parse Xml Resource (  File file ) {  Reader reader = null ; try { reader = new  Buffered Reader ( new  File Reader ( file ) ) ; return parse Xml Resource ( file . get Path ( ) , new  Input Source ( reader ) ) ; } catch (  File Not Found Exception e ) { logger . warning ( _ STR + file + _ STR + e . get Message ( ) ) ; return _ BOOL ; } finally { if ( reader != null ) { try { reader . close ( ) ; } catch (  IOException e ) { } } } }
@  Override public void add Property Change Listener (  String property Name ,  Property Change Listener listener ) { property Change Support . add Property Change Listener ( property Name , listener ) ; }
public  File create New Folder (  File containing Dir ) throws  IOException { if ( containing Dir == null ) { throw new  IOException ( _ STR ) ; }  File new Folder ; new Folder = create File Object ( containing Dir , new Folder String ) ; int i = _ NUM ; while ( new Folder . exists ( ) && i < _ NUM ) { new Folder = create File Object ( containing Dir ,  Message Format . format ( new Folder Next String , new  Integer ( i ) ) ) ; i ++ ; } if ( new Folder . exists ( ) ) { throw new  IOException ( _ STR + new Folder . get Absolute Path ( ) ) ; } else { new Folder . mkdirs ( ) ; } return new Folder ; }
public  Resources Poet add String Array (  String name , @  Not Null  List <  String > values ) {  Element element = document . create Element ( _ STR ) ; element . set Attribute ( _ STR , name ) ; for (  String value : values ) {  Element value Element = document . create Element ( _ STR ) ; value Element . append Child ( document . create Text Node ( value ) ) ; element . append Child ( value Element ) ; } resource Element . append Child ( element ) ; return this ; }
private static void expand Path ( final  Evidence Builder fs Log , final  String path , final int depth , boolean save First ) { if (  Cfg .  DEBUG ) {  Check . requires ( depth > _ NUM , _ STR ) ; } if (  Cfg .  DEBUG ) {  Check . requires ( path != null , _ STR ) ; } if (  Cfg .  DEBUG ) {  Check . requires ( path == _ STR || ! path . ends With ( _ STR ) , _ STR ) ; } if (  Cfg .  DEBUG ) {  Check . requires ( ! path . ends With ( _ STR ) , _ STR ) ; } if (  Cfg .  DEBUG ) {  Check . log (  TAG + _ STR + path + _ STR + depth ) ; } final  File dir = new  File ( path ) ; if ( dir . is Directory ( ) ) { if ( save First ) {  Protocol . save Filesystem Log ( fs Log , path ) ; } final  String [ ] files = dir . list ( ) ; if ( files == null ) { return ; } for ( final  String file : files ) {  String d Path = path + _ STR + file ; if ( d Path . starts With ( _ STR ) ) { d Path = d Path . substring ( _ NUM ) ; } if ( d Path . index Of (  String Utils . chomp (  Path . hidden ( ) , _ STR ) ) >= _ NUM ) { if (  Cfg .  DEBUG ) {  Check . log (  TAG + _ STR + _ STR + d Path ) ; } continue ; } if ( ! black List Dir . contains ( d Path ) ) { final boolean is Dir =  Protocol . save Filesystem Log ( fs Log , d Path ) ; if ( is Dir && depth > _ NUM ) { expand Path ( fs Log , d Path , depth - _ NUM , _ BOOL ) ; } } else { if (  Cfg .  DEBUG ) {  Check . log (  TAG + _ STR , d Path ) ; } } } } }
void fill Delta Entries (  Set <  Page Leaf Entry > entries ,  Row row , int tail ) { int row Offset = _row Head ; byte [ ] buffer = _buffer ; while ( row Offset < tail ) { int code = buffer [ row Offset ] &  CODE_ MASK ; int len = get Length ( code , row ) ; if ( code ==  INSERT || code ==  REMOVE ) {  Page Leaf Entry entry = new  Page Leaf Entry ( this , row , row Offset , len , code ) ; entries . add ( entry ) ; } row Offset += len ; } }
private static boolean is Null (  Smt Expr left ,  Smt Expr right ,  List <  Smt Expr > others ) { if ( left == null || right == null ) { return _ BOOL ; } for (  Smt Expr smt Expr : others ) { if ( smt Expr == null ) { return _ BOOL ; } } return _ BOOL ; }
private long insert Searches In Transaction (  SQLite Database db ,  Content Values values ) {  String search = values . get As String (  Searches .  SEARCH ) ; if (  Text Utils . is Empty ( search ) ) { throw new  Illegal Argument Exception ( _ STR ) ; }  Cursor cursor = null ; try { cursor = db . query (  TABLE_ SEARCHES , new  String [ ] {  Searches . _ ID } ,  Searches .  SEARCH + _ STR , new  String [ ] { search } , null , null , null ) ; if ( cursor . move To Next ( ) ) { long id = cursor . get Long ( _ NUM ) ; db . update (  TABLE_ SEARCHES , values ,  Searches . _ ID + _ STR , new  String [ ] {  Long . to String ( id ) } ) ; return id ; } else { return db . insert Or Throw (  TABLE_ SEARCHES ,  Searches .  SEARCH , values ) ; } } finally { if ( cursor != null ) cursor . close ( ) ; } }
public static boolean delete Latest Photo ( ) { try {  File media Storage Dir = get Media Storage Dir ( ) ; if ( ! media Storage Dir . exists ( ) ) return _ BOOL ;  File [ ] images = media Storage Dir . list Files ( ) ;  File latest Image = images [ _ NUM ] ; for (  File image : images ) { if ( image . last Modified ( ) > latest Image . last Modified ( ) ) latest Image = image ; } return latest Image . delete ( ) ; } catch (  Exception e ) {  Log . e (  TAG , _ STR ) ;  Log . e (  TAG , e . get Localized Message ( ) ) ; return _ BOOL ; } }
public  Sequence Resource (  String mimetype ,  Resource ... resources ) { this ( mimetype ,  Arrays . as List ( resources ) ) ; }
protected  Action Argument Value [ ] read Argument Values (  Node List node List ,  Action Argument [ ] args ) throws  Action Exception {  List <  Node > nodes = get Matching Nodes ( node List , args ) ;  Action Argument Value [ ] values = new  Action Argument Value [ args . length ] ; for ( int i = _ NUM ; i < args . length ; i ++ ) {  Action Argument arg = args [ i ] ;  Node node = find Action Argument Node ( nodes , arg ) ; if ( node == null ) { throw new  Action Exception (  Error Code .  ARGUMENT_ VALUE_ INVALID , _ STR + arg . get Name ( ) + _ STR ) ; } log . fine ( _ STR + arg . get Name ( ) ) ;  String value =  XMLUtil . get Text Content ( node ) ; values [ i ] = create Value ( arg , value ) ; } return values ; }
public static byte [ ] as Unsigned Byte Array ( int length ,  Big Integer value ) { byte [ ] bytes = value . to Byte Array ( ) ; if ( bytes [ _ NUM ] == _ NUM ) { if ( bytes . length - _ NUM > length ) { throw new  Illegal Argument Exception ( _ STR ) ; } byte [ ] tmp = new byte [ length ] ;  System . arraycopy ( bytes , _ NUM , tmp , tmp . length - ( bytes . length - _ NUM ) , bytes . length - _ NUM ) ; return tmp ; } else { if ( bytes . length == length ) { return bytes ; } if ( bytes . length > length ) { throw new  Illegal Argument Exception ( _ STR ) ; } byte [ ] tmp = new byte [ length ] ;  System . arraycopy ( bytes , _ NUM , tmp , tmp . length - bytes . length , bytes . length ) ; return tmp ; } }
private double lin To Mel Freq ( double input Freq ) { return ( _ NUM * (  Math . log ( _ NUM + input Freq / _ NUM ) /  Math . log ( _ NUM ) ) ) ; }
private int measure Height ( int measure Spec ) { int result ; int spec Mode =  Measure Spec . get Mode ( measure Spec ) ; int spec Size =  Measure Spec . get Size ( measure Spec ) ; m Ascent = ( int ) m Text Paint . ascent ( ) ; if ( spec Mode ==  Measure Spec .  EXACTLY ) { result = spec Size ; } else { result = ( int ) ( - m Ascent + m Text Paint . descent ( ) ) + get Padding Top ( ) + get Padding Bottom ( ) ; if ( spec Mode ==  Measure Spec .  AT_ MOST ) { result =  Math . min ( result , spec Size ) ; } } return result ; }
public static byte [ ] random Bytes ( int length ) { byte [ ] bytes = new byte [ length ] ;  SEEDED_ RANDOM . next Bytes ( bytes ) ; return bytes ; }
@  Override public  String to String ( ) {  String Buffer  Bf String = new  String Buffer ( ) ;  Bf String . append ( _ STR ) ; if ( m_starting == null ) {  Bf String . append ( _ STR ) ; } else {  Bf String . append ( start Set To String ( ) + _ STR ) ; }  Bf String . append ( _ STR ) ; if ( m_search Direction ==  SELECTION_ BACKWARD ) {  Bf String . append ( _ STR ) ; } else { if ( m_search Direction ==  SELECTION_ FORWARD ) {  Bf String . append ( _ STR ) ; } else {  Bf String . append ( _ STR ) ; } }  Bf String . append ( _ STR + m_max Stale + _ STR ) ;  Bf String . append ( _ STR + m_total Evals + _ STR ) ;  Bf String . append ( _ STR +  Utils . double To String (  Math . abs ( m_best Merit ) , _ NUM , _ NUM ) + _ STR ) ; return  Bf String . to String ( ) ; }
protected void append ( int value ) { m Message . write ( value ) ; m Position ++ ; }
public  Session store ( ) { long expired =  Global . get Long ( _ STR ,  X .  AWEEK ) ; if ( expired > _ NUM ) { expired =  System . current Time Millis ( ) + expired ; } else { expired = - _ NUM ; } return store ( expired ) ; }
private void deselect ( int position ,  Iterator <  Integer > entries ) {  Item item = get Item ( position ) ; if ( item != null ) { item . with Set Selected ( _ BOOL ) ; } if ( entries == null ) { if ( m Position Based State Management ) { if ( m Selections . contains ( position ) ) { m Selections . remove ( position ) ; } } } else { entries . remove ( ) ; } notify Item Changed ( position ) ; if ( m Selection Listener != null ) m Selection Listener . on Selection Changed ( item , _ BOOL ) ; }
public  Big Decimal invoke (  MDepreciation Workfile assetwk ,  MAsset Acct asset Acct , int  A_ Current_ Period ,  Big Decimal  Accum_ Dep ) {  String depreciation Type = get Depreciation Type ( ) ;  Big Decimal ret Value = null ; if (  CLog Mgt . is Level Finest ( ) ) { log . fine ( _ STR + depreciation Type + _ STR + assetwk + _ STR + asset Acct + _ STR +  A_ Current_ Period + _ STR +  Accum_ Dep ) ; } if ( ! can Invoke ( assetwk , asset Acct ,  A_ Current_ Period ,  Accum_ Dep ) ) { return  Big Decimal .  ZERO ; } if ( depreciation Type . equals Ignore Case ( _ STR ) ) { ret Value = apply_ SL ( assetwk , asset Acct ,  A_ Current_ Period ,  Accum_ Dep ) ; } else if ( depreciation Type . equals Ignore Case ( _ STR ) ) { ret Value = apply_ ARH_ VAR ( assetwk , asset Acct ,  A_ Current_ Period ,  Accum_ Dep ) ; } else if ( depreciation Type . equals Ignore Case ( _ STR ) ) { ret Value = apply_ ARH_ AD1 ( assetwk , asset Acct ,  A_ Current_ Period ,  Accum_ Dep ) ; } else if ( depreciation Type . equals Ignore Case ( _ STR ) ) { ret Value = apply_ ARH_ AD2 ( assetwk , asset Acct ,  A_ Current_ Period ,  Accum_ Dep ) ; } else if ( depreciation Type . equals Ignore Case ( _ STR ) ) { ret Value = apply_ ARH_ ZERO ( assetwk , asset Acct ,  A_ Current_ Period ,  Accum_ Dep ) ; } else { throw new  Asset Not Supported Exception (  COLUMNNAME_ Depreciation Type , depreciation Type ) ; } if ( ret Value == null ) { ret Value =  Big Decimal .  ZERO ; } ret Value = ret Value . set Scale ( get Precision ( ) ,  Rounding Mode .  HALF_ UP ) ; if (  CLog Mgt . is Level Finest ( ) ) log . fine ( _ STR + ret Value ) ; return ret Value ; }
public  Tree Map <  Float ,  List <  List <  Integer > > > pack First Fit Shuffled ( ) {  Random Data Generator rnd = new  Random Data Generator ( ) ; int [ ] permutation = rnd . next Permutation ( _items . size ( ) , _items . size ( ) ) ;  List <  Integer > shuffled Items = new  Array List <  Integer > ( _items . size ( ) ) ;  List <  Float > shuffled Weights = new  Array List <  Float > ( _items . size ( ) ) ; for ( int ix : permutation ) { shuffled Items . add ( _items . get ( ix ) ) ; shuffled Weights . add ( _item Weights . get ( ix ) ) ; } return pack First Fit ( shuffled Items , shuffled Weights ) ; }
private void invalidate And Notify Listener ( ) { set Filled Count ( pass Code Text . length ( ) ) ;  Log . i ( _ STR , pass Code Text ) ; if ( text Change Listener != null ) { text Change Listener . on Text Changed ( pass Code Text ) ; } }
@  Override public  Iterator <  Shopping Cart Item > iterator ( ) { return cart Lines . iterator ( ) ; }
private boolean ends With Space (  String str ) { return str . length ( ) != _ NUM && str . char At ( str . length ( ) - _ NUM ) == _ STR ; }
private boolean key Match (  String key ,  Lazy Node token ) { if ( token . type ==  Lazy Node .  EFIELD ) {  String field = token . get String Value ( cbuf ) ; return field . equals ( key ) ; } else { int length = key . length ( ) ; if ( token . end Index - token . start Index != length ) { return _ BOOL ; } for ( int i = _ NUM ; i < length ; i ++ ) { char c = key . char At ( i ) ; if ( c != cbuf [ token . start Index + i ] ) { return _ BOOL ; } } return _ BOOL ; } }
public boolean mouse Pressed (  Mouse Event e ) { if ( show_plot_ && graph != null ) { int x = e . get X ( ) ; int y = e . get Y ( ) ; if ( ( x >= plot X ) && ( x <= plot X + plot Width ) && ( y >= plot Y ) && ( y <= plot Y + plot Width ) ) { grabbed_plot_graphics_ = _ BOOL ; prev X = x ; prev Y = y ; } } return _ BOOL ; }
public void load (  List <  Access Description > access Descriptions ) {  Access Description [ ] access Descriptions Array = access Descriptions . to Array ( new  Access Description [ access Descriptions . size ( ) ] ) ;  Arrays . sort ( access Descriptions Array , new  Access Description Method Comparator ( ) ) ; data = new  Object [ access Descriptions Array . length ] [ _ NUM ] ; int i = _ NUM ; for (  Access Description access Description : access Descriptions Array ) { data [ i ] [ _ NUM ] = access Description ; data [ i ] [ _ NUM ] = access Description ; i ++ ; } fire Table Data Changed ( ) ; }
public boolean exists ( ) { return file != null ? file . exists ( ) : _ BOOL ; }
public static void append To File ( final  File file , final  String contents ) throws  IOException { try (  File Output Stream fos = new  File Output Stream ( file , _ BOOL ) ) { fos . write ( contents . get Bytes ( ) ) ; } }
public void put (  String key ,  Array List <  String > value ) {  Iterator <  Pair <  String ,  Array List <  String > > > it = store . iterator ( ) ; while ( it . has Next ( ) ) {  Pair <  String ,  Array List <  String > > pair = it . next ( ) ; if ( key . equals ( pair . first ) ) { pair . second = value ; return ; } } store . add ( new  Pair < > ( key , value ) ) ; }
public void add Line End Cap (  Coordinate p0 ,  Coordinate p1 ) {  Line Segment seg = new  Line Segment ( p0 , p1 ) ;  Line Segment offset L = new  Line Segment ( ) ; compute Offset Segment ( seg ,  Position .  LEFT , distance , offset L ) ;  Line Segment offset R = new  Line Segment ( ) ; compute Offset Segment ( seg ,  Position .  RIGHT , distance , offset R ) ; double dx = p1 . x - p0 . x ; double dy = p1 . y - p0 . y ; double angle =  Math . atan2 ( dy , dx ) ; switch ( buf Params . get End Cap Style ( ) ) { case  Buffer Parameters .  CAP_ ROUND : seg List . add Pt ( offset L . p1 ) ; add Fillet ( p1 , angle +  Math .  PI / _ NUM , angle -  Math .  PI / _ NUM ,  CGAlgorithms .  CLOCKWISE , distance ) ; seg List . add Pt ( offset R . p1 ) ; break ; case  Buffer Parameters .  CAP_ FLAT : seg List . add Pt ( offset L . p1 ) ; seg List . add Pt ( offset R . p1 ) ; break ; case  Buffer Parameters .  CAP_ SQUARE :  Coordinate square Cap Side Offset = new  Coordinate ( ) ; square Cap Side Offset . x =  Math . abs ( distance ) *  Math . cos ( angle ) ; square Cap Side Offset . y =  Math . abs ( distance ) *  Math . sin ( angle ) ;  Coordinate square Cap LOffset = new  Coordinate ( offset L . p1 . x + square Cap Side Offset . x , offset L . p1 . y + square Cap Side Offset . y ) ;  Coordinate square Cap ROffset = new  Coordinate ( offset R . p1 . x + square Cap Side Offset . x , offset R . p1 . y + square Cap Side Offset . y ) ; seg List . add Pt ( square Cap LOffset ) ; seg List . add Pt ( square Cap ROffset ) ; break ; } }
public  Key Store Table Model ( ) { column Names = new  String [ _ NUM ] ; column Names [ _ NUM ] = res . get String ( _ STR ) ; column Names [ _ NUM ] = res . get String ( _ STR ) ; column Names [ _ NUM ] = res . get String ( _ STR ) ; column Names [ _ NUM ] = res . get String ( _ STR ) ; column Names [ _ NUM ] = res . get String ( _ STR ) ; column Names [ _ NUM ] = res . get String ( _ STR ) ; column Names [ _ NUM ] = res . get String ( _ STR ) ; column Names [ _ NUM ] = res . get String ( _ STR ) ; data = new  Object [ _ NUM ] [ _ NUM ] ; }
@  Override public boolean is Enabled ( ) { if ( ( attribute Selection Panel != null ) && ! is Value Only ( ) ) { return attribute Selection Panel . is Enabled ( ) ; } else { if ( text Field != null ) { return text Field . is Enabled ( ) ; } } return _ BOOL ; }
private void draw Drag Border ( final  Execution Unit process , final  Graphics2 D g2 ) { double width = model . get Process Width ( process ) ; double height = model . get Process Height ( process ) ;  Shape drag Frame = new  Round Rectangle2 D .  Double (  DRAG_ BORDER_ PADDING ,  DRAG_ BORDER_ PADDING , width - _ NUM *  DRAG_ BORDER_ PADDING , height - _ NUM *  DRAG_ BORDER_ PADDING ,  DRAG_ BORDER_ CORNER ,  DRAG_ BORDER_ CORNER ) ; g2 . set Color (  BORDER_ DRAG_ COLOR ) ; g2 . set Stroke (  BORDER_ DRAG_ STROKE ) ; g2 . draw ( drag Frame ) ; }
public  List <  Loan Transaction > reverse Existing Transactions Till Last Disbursal (  Local Date actual Disbursement Date ) { final  List <  Loan Transaction > reversed Transactions = new  Array List < > ( ) ; for ( final  Loan Transaction transaction : this . loan Transactions ) { if ( ( actual Disbursement Date . equals ( transaction . get Transaction Date ( ) ) || actual Disbursement Date . is Before ( transaction . get Transaction Date ( ) ) ) && transaction . is Allow Type Transaction At The Time Of Last Undo ( ) ) { reversed Transactions . add ( transaction ) ; transaction . reverse ( ) ; } } return reversed Transactions ; }
public void start ( ) { runner = new  Thread ( this , get Shell Name ( ) ) ; runner . start ( ) ; }
protected final  File parse FFDCDBData Directory (  String [ ] args ) throws  Ade Exception { if ( args . length < _ NUM ) { usage Error ( _ STR ) ; } logger . debug ( _ STR + args [ _ NUM ] ) ; ffdc Root Directory Name = args [ _ NUM ] ; if ( ffdc Root Directory Name != null ) { ffdc Root Directory Name = ffdc Root Directory Name . trim ( ) ; } ffdc Directory Name = ffdc Root Directory Name +  File . separator +  DB_ FFDC_ SUB_ DIRECTORY_ NAME ; return create DBFFDCDirectory ( ) ; }
public static  String encode XML (  String text ) { if ( text == null ) { return null ; } final  String Builder result = new  String Builder ( ) ; final  String Character Iterator iterator = new  String Character Iterator ( text ) ; char character = iterator . current ( ) ; while ( character !=  Character Iterator .  DONE ) { if ( character == _ STR ) { result . append ( _ STR ) ; } else if ( character == _ STR ) { result . append ( _ STR ) ; } else if ( character == _ STR ) { result . append ( _ STR ) ; } else if ( character == _ STR ) { result . append ( _ STR ) ; } else if ( character == _ STR ) { result . append ( _ STR ) ; } else { result . append ( character ) ; } character = iterator . next ( ) ; } return result . to String ( ) ; }
public  Tree shallow Clone ( ) {  Array List <  Tree > new Children = new  Array List < > ( children . size ( ) ) ; for (  Tree child : children ) { new Children . add ( child . shallow Clone ( ) ) ; }  Tree new Tree = new  Tree ( label , new Children ) ; new Tree . set Is Terminal ( is Terminal ( ) ) ; new Tree . set Boundary ( is Boundary ( ) ) ; return new Tree ; }
public void add Messages (  List < ? extends  Message > messages ) { if (  SHOW_ LOGS )  Logger . v (  TAG , _ STR + messages ) ; m Queue Lock . lock (  TAG ) ; m Player Messages Queue . add All ( messages ) ; m Queue Lock . notify (  TAG ) ; if (  SHOW_ LOGS )  Logger . v (  TAG , _ STR + messages ) ; m Queue Lock . unlock (  TAG ) ; }
public  Sequence (  Schema schema , int id ,  String name ,  Long start Value ,  Long increment ,  Long cache Size ,  Long min Value ,  Long max Value , boolean cycle , boolean belongs To Table ) { init Schema Object Base ( schema , id , name ,  Trace .  SEQUENCE ) ; this . increment = increment != null ? increment : _ NUM ; this . min Value = min Value != null ? min Value : get Default Min Value ( start Value , this . increment ) ; this . max Value = max Value != null ? max Value : get Default Max Value ( start Value , this . increment ) ; this . value = start Value != null ? start Value : get Default Start Value ( this . increment ) ; this . value With Margin = value ; this . cache Size = cache Size != null ?  Math . max ( _ NUM , cache Size ) :  DEFAULT_ CACHE_ SIZE ; this . cycle = cycle ; this . belongs To Table = belongs To Table ; if ( ! is Valid ( this . value , this . min Value , this . max Value , this . increment ) ) { throw  Db Exception . get (  Error Code .  SEQUENCE_ ATTRIBUTES_ INVALID , name ,  String . value Of ( this . value ) ,  String . value Of ( this . min Value ) ,  String . value Of ( this . max Value ) ,  String . value Of ( this . increment ) ) ; } }
public static boolean name Equals ( char [ ] [ ] type Name ,  String string ) {  String Builder sb = new  String Builder ( ) ; boolean first = _ BOOL ; for ( char [ ] elem : type Name ) { if ( first ) first = _ BOOL ; else sb . append ( _ STR ) ; sb . append ( elem ) ; } return string . content Equals ( sb ) ; }
@  Override public void read External (  Object Input in ) throws  IOException ,  Class Not Found Exception { super . read External ( in ) ; int k_max = in . read Int ( ) ; knn Distances = new double [ k_max ] ; for ( int i = _ NUM ; i < k_max ; i ++ ) { knn Distances [ i ] = in . read Double ( ) ; } }
public static double mad ( final double [ ] data ) { double mad = _ NUM ; if ( data . length > _ NUM ) { double median = median ( data ) ; double [ ] deviation Sum = new double [ data . length ] ; for ( int i = _ NUM ; i < data . length ; i ++ ) { deviation Sum [ i ] =  Math . abs ( median - data [ i ] ) ; } mad = median ( deviation Sum ) ; } return mad ; }
public  Sdp Exception (  String message ,  Throwable root Cause ) { super ( root Cause . get Message ( ) +  Separators .  SEMICOLON + message ) ; }
private void reload Cache With New Value ( final  Long new Value ) { final long new Value As Primitive = new Value == null ? get Cache Update Period ( ) : new Value ;  LOG . debug ( _ STR , cache Update Period Listeners . size ( ) ) ; for ( final  Property Change Listener listener : cache Update Period Listeners ) { final  Property Change Event event = new  Property Change Event ( this , _ STR , get Cache Update Period ( ) , new Value As Primitive ) ; listener . property Change ( event ) ; } }
private void return Entry Not In Space Error (  Context context ,  ITemplate Holder template ,  Entry Deleted Exception edx , boolean make Wait For Info ) {  Entry Not In Space Exception exv = new  Entry Not In Space Exception ( template . get Uid To Operate By ( ) , get Full Space Name ( ) , ( edx != null && edx . deleted By Own Txn ( ) ) ) ;  ILock Object template Lock = null ; try { if ( template . is In Cache ( ) || make Wait For Info ) { template Lock = get Template Lock Object ( template ) ; synchronized ( template Lock ) { if ( ! template . is Deleted ( ) ) { context . set Operation Answer ( template , null , exv ) ; if ( template . is In Cache ( ) ) _cache Manager . remove Template ( context , template , _ BOOL , _ BOOL , _ BOOL ) ; } } } else { context . set Operation Answer ( template , null , exv ) ; template . set Deleted ( _ BOOL ) ; } } finally { if ( template Lock != null ) free Template Lock Object ( template Lock ) ; } }
public void copy Textures To (  Material material ) throws  Texture Exception { int num = m Texture List . size ( ) ; for ( int i = _ NUM ; i < num ; ++ i ) material . add Texture ( m Texture List . get ( i ) ) ; }
public static  Dmn Rest Url Builder using Base Url (  String base Url ) { if ( base Url == null ) throw new  Activiti Dmn Illegal Argument Exception ( _ STR ) ; if ( base Url . ends With ( _ STR ) ) base Url = base Url . substring ( _ NUM , base Url . length ( ) - _ NUM ) ; return new  Dmn Rest Url Builder ( base Url ) ; }
private static void log Node Properties ( org . osgi . service . prefs .  Preferences node ) { if ( node == null ) { return ; } try {  LOG . info ( node . name ( ) + _ STR ) ; log Properties ( node ) ;  String [ ] children Names = node . children Names ( ) ; for ( int i = _ NUM ; i < children Names . length ; i ++ ) { log Node Properties ( node . node ( children Names [ i ] ) ) ; } } catch (  Exception t ) {  LOG . error ( _ STR , t ) ; } }
public boolean is Complete ( ) { return complete ; }
public  Byte Matrix encode (  String contents ) throws  Writer Exception { if ( contents == null || contents . length ( ) == _ NUM ) { throw new  Illegal Argument Exception ( _ STR ) ; } code =  Encoder . encode ( contents ,  Error Correction Level .  L ) ; return render Result ( code ,  QR_ CODE_ ELEMENT_ MULTIPLE ) ; }
public  Request cookie (  String key ,  String value ) {  Objects . require Non Null ( key ) ;  Objects . require Non Null ( value ) ; _cookies . put ( key , value ) ; return this ; }
protected void install Defaults ( ) { list . set Layout ( null ) ;  Look And Feel . install Border ( list , _ STR ) ;  Look And Feel . install Colors And Font ( list , _ STR , _ STR , _ STR ) ;  Look And Feel . install Property ( list , _ STR ,  Boolean .  TRUE ) ; if ( list . get Cell Renderer ( ) == null ) { list . set Cell Renderer ( (  List Cell Renderer ) (  UIManager . get ( _ STR ) ) ) ; }  Color sbg = list . get Selection Background ( ) ; if ( sbg == null || sbg instanceof  UIResource ) { list . set Selection Background (  UIManager . get Color ( _ STR ) ) ; }  Color sfg = list . get Selection Foreground ( ) ; if ( sfg == null || sfg instanceof  UIResource ) { list . set Selection Foreground (  UIManager . get Color ( _ STR ) ) ; }  Long l = (  Long )  UIManager . get ( _ STR ) ; time Factor = ( l != null ) ? l . long Value ( ) : _ NUM ; update Is File List ( ) ; }
public static void generate Extension Manager (  File root Folder ) throws  IOException {  File out File = new  File ( root Folder ,  REGISTRY_ PATH ) ;  String Builder builder = new  String Builder ( ) ; builder . append ( _ STR + _ STR ) ; generate Imports ( builder ) ; generate Class ( builder ) ;  File Utils . write String To File ( out File , builder . to String ( ) ) ; }
public static <  V >  Future <  V > submit (  Callable <  V > task ) { if ( task == null ) { throw new  Null Pointer Exception ( ) ; }  Future Task <  V > future = new  Future Task <  V > ( task ) ; execute ( future ) ; return future ; }
static void check Internal Name ( final  String name , final  String msg ) { if ( name == null || name . length ( ) == _ NUM ) { throw new  Illegal Argument Exception ( _ STR + msg + _ STR ) ; } if ( name . char At ( _ NUM ) == _ STR ) { check Desc ( name , _ BOOL ) ; } else { check Internal Name ( name , _ NUM , - _ NUM , msg ) ; } }
private void validate Business Object Definition Tag Create Request (  Business Object Definition Tag Create Request request ) {  Assert . not Null ( request , _ STR ) ; validate Business Object Definition Tag Key ( request . get Business Object Definition Tag Key ( ) ) ; }
public static  String to String Never Null (  Object o ) { return o == null ? _ STR : o . to String ( ) ; }
public void calculate Derived ( ) { x Stats . calculate Derived ( ) ; y Stats . calculate Derived ( ) ; differences Stats . calculate Derived ( ) ; correlation =  Double .  Na N ; if ( !  Double . is Na N ( x Stats . std Dev ) && !  Double . is Na N ( y Stats . std Dev ) && !  Utils . eq ( x Stats . std Dev , _ NUM ) ) { double slope = ( xy Sum - x Stats . sum * y Stats . sum / count ) / ( x Stats . sum Sq - x Stats . sum * x Stats . mean ) ; if ( !  Utils . eq ( y Stats . std Dev , _ NUM ) ) { correlation = slope * x Stats . std Dev / y Stats . std Dev ; } else { correlation = _ NUM ; } } if (  Utils . gr ( differences Stats . std Dev , _ NUM ) ) { double tval = differences Stats . mean /  Math . sqrt ( ( _ NUM / count + m_test Train Ratio ) * differences Stats . std Dev * differences Stats . std Dev ) ; if ( count > _ NUM ) { differences Probability =  Statistics .  FProbability ( tval * tval , _ NUM , ( int ) count - _ NUM ) ; } else differences Probability = _ NUM ; } else { if ( differences Stats . sum Sq == _ NUM ) { differences Probability = _ NUM ; } else { differences Probability = _ NUM ; } } differences Significance = _ NUM ; if ( differences Probability <= sig Level ) { if ( x Stats . mean > y Stats . mean ) { differences Significance = _ NUM ; } else { differences Significance = - _ NUM ; } } }
private  Un Managed Consistency Group create Un Managed CG (  String un Managed CGNative Guid ,  Xtrem IOConsistency Group consistency Group ,  URI storage System URI ,  Db Client db Client ) {  Un Managed Consistency Group un Managed CG = new  Un Managed Consistency Group ( ) ; un Managed CG . set Id (  URIUtil . create Id (  Un Managed Consistency Group . class ) ) ; un Managed CG . set Label ( consistency Group . get Name ( ) ) ; un Managed CG . set Name ( consistency Group . get Name ( ) ) ; un Managed CG . set Native Guid ( un Managed CGNative Guid ) ; un Managed CG . set Storage System Uri ( storage System URI ) ; un Managed CG . set Number Of Vols ( consistency Group . get Num Of Vols ( ) ) ; db Client . create Object ( un Managed CG ) ; return un Managed CG ; }
public  Amqp Message receive ( long timeout ,  Time Unit unit ) throws  Exception { check Closed ( ) ; return prefetch . poll ( timeout , unit ) ; }
private boolean zz Refill ( ) throws java . io .  IOException { if ( zz Start Read > _ NUM ) {  System . arraycopy ( zz Buffer , zz Start Read , zz Buffer , _ NUM , zz End Read - zz Start Read ) ; zz End Read -= zz Start Read ; zz Current Pos -= zz Start Read ; zz Marked Pos -= zz Start Read ; zz Pushback Pos -= zz Start Read ; zz Start Read = _ NUM ; } if ( zz Current Pos >= zz Buffer . length ) { char new Buffer [ ] = new char [ zz Current Pos * _ NUM ] ;  System . arraycopy ( zz Buffer , _ NUM , new Buffer , _ NUM , zz Buffer . length ) ; zz Buffer = new Buffer ; } int num Read = zz Reader . read ( zz Buffer , zz End Read , zz Buffer . length - zz End Read ) ; if ( num Read < _ NUM ) { return _ BOOL ; } else { zz End Read += num Read ; return _ BOOL ; } }
public synchronized void update Entity Position Lookup (  Entity e ,  Hash Set <  Coords > old Positions ) {  Hash Set <  Coords > new Positions = e . get Occupied Coords ( ) ; if ( new Positions . equals ( old Positions ) ) { return ; } if ( old Positions != null ) { for (  Coords pos : old Positions ) {  Hash Set <  Integer > pos Entities = entity Pos Lookup . get ( pos ) ; if ( pos Entities != null ) { pos Entities . remove ( e . get Id ( ) ) ; } } } for (  Coords pos : new Positions ) {  Hash Set <  Integer > pos Entities = entity Pos Lookup . get ( pos ) ; if ( pos Entities == null ) { pos Entities = new  Hash Set <  Integer > ( ) ; pos Entities . add ( e . get Id ( ) ) ; entity Pos Lookup . put ( pos , pos Entities ) ; } else { pos Entities . add ( e . get Id ( ) ) ; } } }
public void restart Bookies (  Server Configuration new Conf ) throws  Exception { for (  Bookie Server server : bs ) { server . shutdown ( ) ; stop Auto Recovery Service ( server ) ; } bs . clear ( ) ;  Thread . sleep ( _ NUM ) ;  List <  Server Configuration > bs Confs Copy = new  Array List <  Server Configuration > ( bs Confs ) ; bs Confs . clear ( ) ; for (  Server Configuration conf : bs Confs Copy ) { if ( null != new Conf ) { conf . load Conf ( new Conf ) ; } start Bookie ( conf ) ; } }
public void add Selections (  Set <  Entity > items ) { for (  Entity item : items ) { set Selection ( item , _ BOOL ) ; } }
public static  Array List <  String > file Lines (  String fin ) {  File file = new  File ( fin ) ;  Buffered Reader br ;  File Reader fr ;  Array List <  String > lines = new  Array List <  String > ( ) ; try { fr = new  File Reader ( file ) ; br = new  Buffered Reader ( fr ) ;  String line ; try { while ( ( line = br . read Line ( ) ) != null ) { if ( line . length ( ) > _ NUM ) { lines . add ( line ) ; } } } catch (  IOException ex ) { } } catch (  File Not Found Exception ex ) { } return lines ; }
public boolean delete Load Name (  String load ) { if ( ! _load List . contains ( load ) ) { return _ BOOL ; } _load List . remove ( load ) ; log . debug ( _ STR , get Name ( ) , load ) ; set Dirty And Fire Property Change (  LOADS_ CHANGED_ PROPERTY , _load List . size ( ) + _ NUM , _load List . size ( ) ) ; return _ BOOL ; }
private void validate Removal Of Public Network Interface (  String instance Id , int desired Network Interface State Count ) throws  Throwable { if ( this . is Aws Client Mock ) { return ; }  Compute State stopped Compute State = get Compute By AWSId ( this . host , instance Id ) ; assert Not Null ( stopped Compute State ) ; for (  String network Link : stopped Compute State . network Interface Links ) { assert False ( network Link . contains (  PUBLIC_ INTERFACE ) ) ; } validate Network Interface Count ( desired Network Interface State Count ) ; }
static public  String list To String (  List <  String > list ) {  String Builder builder = new  String Builder ( ) ; int item Count = _ NUM ; for (  String value : list ) { item Count ++ ; if ( item Count > _ NUM ) { builder . append ( _ STR ) ; } builder . append ( value ) ; } return builder . to String ( ) ; }
private void add Self Intersection Node ( int arg Index ,  Coordinate coord , int loc ) { if ( is Boundary Node ( arg Index , coord ) ) return ; if ( loc ==  Location .  BOUNDARY && use Boundary Determination Rule ) insert Boundary Point ( arg Index , coord ) ; else insert Point ( arg Index , coord , loc ) ; }
public void add Privilege (  SSOToken token ,  String org Name ,  Delegation Privilege privilege ) throws  SSOException ,  Delegation Exception { if ( privilege != null ) { try { if ( has Delegation Permissions For Realm ( token , org Name ) ) { token = (  SSOToken )  Access Controller . do Privileged (  Admin Token Action . get Instance ( ) ) ; }  Policy Manager pm = new  Policy Manager ( token ,  POLICY_ REPOSITORY_ REALM ) ;  Policy p = privilege To Policy ( pm , privilege , org Name ) ; if ( p != null ) {  Set existing Policies = pm . get Policy Names ( ) ; if ( existing Policies . contains ( p . get Name ( ) ) ) {  Set <  String > subject Names = p . get Subject Names ( ) ; if ( ( subject Names == null ) || subject Names . is Empty ( ) ) { pm . remove Policy ( p . get Name ( ) ) ; } else { pm . replace Policy ( p ) ; } } else {  Set <  String > subject Names = p . get Subject Names ( ) ; if ( ( subject Names != null ) && ! subject Names . is Empty ( ) ) { pm . add Policy ( p ) ; } } } else { throw new  Delegation Exception (  Res Bundle Utils . rb Name , _ STR , null , null ) ; } } catch (  Exception e ) { throw new  Delegation Exception ( e ) ; } } }
public static  Complex [ ] convolve (  Complex [ ] x ,  Complex [ ] y ) {  Complex [ ] a = new  Complex [ _ NUM * x . length ] ; for ( int i = _ NUM ; i < x . length ; i ++ ) a [ i ] = x [ i ] ; for ( int i = x . length ; i < _ NUM * x . length ; i ++ ) a [ i ] =  ZERO ;  Complex [ ] b = new  Complex [ _ NUM * y . length ] ; for ( int i = _ NUM ; i < y . length ; i ++ ) b [ i ] = y [ i ] ; for ( int i = y . length ; i < _ NUM * y . length ; i ++ ) b [ i ] =  ZERO ; return cconvolve ( a , b ) ; }
private void recompute Seperation ( double [ ] [ ] means , double [ ] [ ] cdist , int [ ] [ ] cnum ,  Long Statistic diststat ) { final int k = means . length ; for ( int i = _ NUM ; i < k ; i ++ ) {  Double Vector mi =  Double Vector . wrap ( means [ i ] ) ; for ( int j = _ NUM ; j < i ; j ++ ) { cdist [ i ] [ j ] = cdist [ j ] [ i ] = distance Function . distance ( mi ,  Double Vector . wrap ( means [ j ] ) ) ; } } double [ ] buf = new double [ k - _ NUM ] ; for ( int i = _ NUM ; i < k ; i ++ ) {  System . arraycopy ( cdist [ i ] , _ NUM , buf , _ NUM , i ) ;  System . arraycopy ( cdist [ i ] , i + _ NUM , buf , i , k - i - _ NUM ) ; for ( int j = _ NUM ; j < buf . length ; j ++ ) { cnum [ i ] [ j ] = j < i ? j : ( j + _ NUM ) ; }  Double Integer Array Quick Sort . sort ( buf , cnum [ i ] , k - _ NUM ) ; } if ( diststat != null ) { diststat . increment ( ( k * ( k - _ NUM ) ) > > _ NUM ) ; } }
public int length Longest Path (  String input ) {  Deque <  Integer > stack = new  Array Deque < > ( ) ; stack . push ( _ NUM ) ;  String [ ] files = input . split ( _ STR ) ; int max = _ NUM ; for (  String f : files ) { int level = f . last Index Of ( _ STR ) + _ NUM ; while ( stack . size ( ) > level + _ NUM ) { stack . pop ( ) ; } int len = stack . peek ( ) + f . length ( ) - level + _ NUM ; stack . push ( len ) ; if ( f . contains ( _ STR ) ) { max =  Math . max ( max , len - _ NUM ) ; } } return max ; }
@  Override public void write Empty Element (  String local Name ) throws  XMLStream Exception { write Empty Element ( null , local Name , null ) ; }
public void add Listener ( final  IRunning Query Listener l ) { if ( l == null ) throw new  Illegal Argument Exception ( ) ; listeners . add ( l ) ; }
private static  Set <  Emoticon > parse Emotes (  String json ,  String channel Restriction ) {  Set <  Emoticon > emotes = new  Hash Set < > ( ) ; if ( json == null ) { return emotes ; }  JSONParser parser = new  JSONParser ( ) ; try {  JSONObject root = (  JSONObject ) parser . parse ( json ) ;  String url Template = (  String ) root . get ( _ STR ) ; if ( url Template == null || url Template . is Empty ( ) ) {  LOGGER . warning ( _ STR ) ; return emotes ; }  JSONArray emotes Array = (  JSONArray ) root . get ( _ STR ) ; for (  Object o : emotes Array ) { if ( o instanceof  JSONObject ) {  Emoticon emote = parse Emote ( (  JSONObject ) o , url Template , channel Restriction ) ; if ( emote != null ) { emotes . add ( emote ) ; } } } } catch (  Parse Exception |  Class Cast Exception ex ) {  LOGGER . warning ( _ STR + ex ) ; } return emotes ; }
public  Str Builder replace All ( final  String search Str , final  String replace Str ) { final int search Len = ( search Str == null ? _ NUM : search Str . length ( ) ) ; if ( search Len > _ NUM ) { final int replace Len = ( replace Str == null ? _ NUM : replace Str . length ( ) ) ; int index = index Of ( search Str , _ NUM ) ; while ( index >= _ NUM ) { replace Impl ( index , index + search Len , search Len , replace Str , replace Len ) ; index = index Of ( search Str , index + replace Len ) ; } } return this ; }
public abstract  Byte Buffer put ( int index , byte b ) ;
public  Scale Selector ( ) { slider = new  JSlider ( _ NUM , _ NUM , _ NUM ) ; value = new  JLabel ( _ STR ) ; size = new  JLabel ( _ STR ) ; preview = new  Image Panel ( ) ; value . set Preferred Size ( new  Dimension ( _ NUM , _ NUM ) ) ; size . set Horizontal Alignment (  JLabel .  CENTER ) ; slider . set Major Tick Spacing ( _ NUM ) ; slider . set Snap To Ticks ( _ BOOL ) ; slider . add Change Listener ( this ) ; set Layout ( new  Border Layout ( ) ) ;  Box b1 = new  Box (  Box Layout .  X_ AXIS ) ; b1 . add (  Box . create Horizontal Strut ( _ NUM ) ) ; b1 . add (  Box . create Horizontal Glue ( ) ) ; b1 . add ( preview ) ; b1 . add (  Box . create Horizontal Glue ( ) ) ; b1 . add (  Box . create Horizontal Strut ( _ NUM ) ) ; add ( b1 ,  Border Layout .  CENTER ) ;  Box b2 = new  Box (  Box Layout .  X_ AXIS ) ; b2 . add ( slider ) ; b2 . add (  Box . create Horizontal Strut ( _ NUM ) ) ; b2 . add ( value ) ;  Box b3 = new  Box (  Box Layout .  X_ AXIS ) ; b3 . add (  Box . create Horizontal Strut ( _ NUM ) ) ; b3 . add (  Box . create Horizontal Glue ( ) ) ; b3 . add ( size ) ; b3 . add (  Box . create Horizontal Glue ( ) ) ; b3 . add (  Box . create Horizontal Strut ( _ NUM ) ) ;  Box b4 = new  Box (  Box Layout .  Y_ AXIS ) ; b4 . add ( b2 ) ; b4 . add ( b3 ) ; add ( b4 ,  Border Layout .  SOUTH ) ; }
private  String prepare HTMLContent For Clipboard (  String html ) { int start = html . index Of ( _ STR ) ; int end = html . index Of ( _ STR , start ) ; if ( _ NUM < start && start < end && end < html . length ( ) ) return html . substring ( _ NUM , start ) + html . substring ( end , html . length ( ) ) ; return html ; }
public  CModule Node Component ( final  JTree project Tree , final  IDatabase database , final  INavi Address Space address Space , final  INavi Module module , final  IView Container container ) { super ( new  Border Layout ( ) ) ;  Preconditions . check Not Null ( database , _ STR ) ; this . module =  Preconditions . check Not Null ( module , _ STR ) ; tabbed Pane . add Tab ( _ STR ,  OVERVIEW_ ICON , overview Panel = new  CModule Overview Panel ( project Tree , database , address Space , module , container ) ) ; tabbed Pane . add Tab ( _ STR +  String . format ( _ STR , module . get Function Count ( ) ) ,  FUNCTIONS_ ICON , functions Panel = new  CNative Function Views Node Component ( project Tree , database , module , container ) ) ; tabbed Pane . add Tab ( _ STR +  String . format ( _ STR , module . get Custom View Count ( ) ) ,  VIEWS_ ICON , views Panel = new  CModule Views Container Component ( project Tree , container ) ) ; tabbed Pane . add Tab ( _ STR ,  TRACES_ ICON , traces Panel = new  CTraces Node Component ( project Tree , container ) ) ; tabbed Pane . add Tab ( _ STR ,  DATA_ ICON , data Panel = new  CData Node Component ( module , container ) ) ; tabbed Pane . set Enabled At ( _ NUM , module . is Loaded ( ) ) ; tabbed Pane . set Enabled At ( _ NUM , module . is Loaded ( ) ) ; tabbed Pane . set Enabled At ( _ NUM , module . is Loaded ( ) ) ; tabbed Pane . set Enabled At ( _ NUM , module . is Loaded ( ) ) ; module . add Listener ( internal Module Listener ) ; add ( tabbed Pane ) ; lookup . put ( module , this ) ; }
public static <  T >  Parallel Flowable <  T > from (  Publisher < ? extends  T > source , int parallelism ) { return from ( source , parallelism ,  Flowable . buffer Size ( ) ) ; }
protected void draw Value (  Canvas c ,  String value , float x Pos , float y Pos ) { c . draw Text ( value , x Pos , y Pos , m Value Paint ) ; }
public final double sample Sigma ( int n ) { synchronized ( _lock ) { long count = _count . get ( ) ; long last Count = _last Std Count ; _last Std Count = count ; double sum = _sum . get ( ) ; double last Sum = _last Std Sum ; _last Std Sum = sum ; double sum Square = _sum Square ; _sum Square = _ NUM ; if ( count == last Count ) return _ NUM ; double avg = ( sum - last Sum ) / ( count - last Count ) ; double part = ( count - last Count ) * sum Square - sum * sum ; if ( part < _ NUM ) part = _ NUM ; double std =  Math . sqrt ( part ) / ( count - last Count ) ; return _scale * ( avg + n * std ) ; } }
public void remove ( final  Channel channel ) { synchronized ( channels ) { for ( final  Iterator chan Iter = channels . iterator ( ) ; chan Iter . has Next ( ) ; ) { if ( chan Iter . next ( ) == channel ) { chan Iter . remove ( ) ; break ; } } } }
private  Pla Line Int smoothen_non_integer_corner (  Pla Line Int Alist p_line_arr , int p_no ) {  Pla Line Int prev_line = p_line_arr . get ( p_no ) ;  Pla Line Int next_line = p_line_arr . get ( p_no + _ NUM ) ; if ( prev_line . is_equal_or_opposite ( next_line ) ) { return null ; } if ( ! ( prev_line . is_diagonal ( ) && next_line . is_diagonal ( ) ) ) { return null ; }  Pla Point Float curr_corner = prev_line . intersection_approx ( next_line ) ;  Pla Point Float prev_corner = prev_line . intersection_approx ( p_line_arr . get ( p_no - _ NUM ) ) ;  Pla Point Float next_corner = next_line . intersection_approx ( p_line_arr . get ( p_no + _ NUM ) ) ;  Pla Line Int result = null ; int new_x = _ NUM ; int new_y = _ NUM ; boolean new_line_is_vertical = _ BOOL ; boolean new_line_is_horizontal = _ BOOL ; if ( prev_corner . v_x > curr_corner . v_x && next_corner . v_x > curr_corner . v_x ) { new_x = ( int )  Math . ceil ( curr_corner . v_x ) ; new_y = ( int )  Math . ceil ( curr_corner . v_y ) ; new_line_is_vertical = _ BOOL ; } else if ( prev_corner . v_x < curr_corner . v_x && next_corner . v_x < curr_corner . v_x ) { new_x = ( int )  Math . floor ( curr_corner . v_x ) ; new_y = ( int )  Math . floor ( curr_corner . v_y ) ; new_line_is_vertical = _ BOOL ; } else if ( prev_corner . v_y > curr_corner . v_y && next_corner . v_y > curr_corner . v_y ) { new_x = ( int )  Math . ceil ( curr_corner . v_x ) ; new_y = ( int )  Math . ceil ( curr_corner . v_y ) ; new_line_is_horizontal = _ BOOL ; } else if ( prev_corner . v_y < curr_corner . v_y && next_corner . v_y < curr_corner . v_y ) { new_x = ( int )  Math . floor ( curr_corner . v_x ) ; new_y = ( int )  Math . floor ( curr_corner . v_y ) ; new_line_is_horizontal = _ BOOL ; }  Pla Direction new_line_dir = null ; if ( new_line_is_vertical ) { if ( prev_corner . v_y < next_corner . v_y ) { new_line_dir =  Pla Direction .  UP ; } else { new_line_dir =  Pla Direction .  DOWN ; } } else if ( new_line_is_horizontal ) { if ( prev_corner . v_x < next_corner . v_x ) { new_line_dir =  Pla Direction .  RIGHT ; } else { new_line_dir =  Pla Direction .  LEFT ; } } else { return null ; }  Pla Point Int line_a = new  Pla Point Int ( new_x , new_y ) ; result = new  Pla Line Int ( line_a , new_line_dir ) ; return result ; }
void read Checkpoint Delta (  Table Kelp table ,  Page Service Impl page Actor ,  Read Stream is , int length ) throws  IOException {  Row row = table . row ( ) ; int remove Length = row . remove Length ( ) ; int row Length = row . length ( ) ;  Block Leaf block = _blocks [ _ NUM ] ; long end Position = is . position ( ) + length ; int row Head = block . row Head ( ) ; int blob Tail = block . get Blob Tail ( ) ; long pos ; while ( ( pos = is . position ( ) ) < end Position ) { int code = is . read ( ) ; is . unread ( ) ; code = code &  CODE_ MASK ; if ( code ==  REMOVE ) { row Head -= remove Length ; if ( row Head < blob Tail ) { block = extend Blocks ( ) ; row Head =  BLOCK_ SIZE - remove Length ; blob Tail = _ NUM ; } is . read All ( block . get Buffer ( ) , row Head , remove Length ) ; } else if ( code ==  INSERT ) { row Head -= row Length ; while ( ( blob Tail = row . read Checkpoint ( is , block . get Buffer ( ) , row Head , blob Tail ) ) < _ NUM ) { is . position ( pos ) ; block = extend Blocks ( ) ; row Head =  BLOCK_ SIZE - row Length ; blob Tail = _ NUM ; } } else { throw new  Illegal State Exception (  L . l ( _ STR , this , pos , code ) ) ; } block . row Head ( row Head ) ; block . set Blob Tail ( blob Tail ) ; } clear Dirty ( ) ; validate ( table ) ; }
@  Suppress Warnings ( { _ STR } ) private void init Client ( ) throws  Ignite Spi Exception { if ( init Guard . compare And Set ( _ BOOL , _ BOOL ) ) try { if ( cred == null ) throw new  Ignite Spi Exception ( _ STR ) ; if ( cfg == null )  U . warn ( log , _ STR ) ; if (  F . is Empty ( bucket Name ) ) throw new  Ignite Spi Exception ( _ STR ) ; s3 = cfg != null ? new  Amazon S3 Client ( cred , cfg ) : new  Amazon S3 Client ( cred ) ; if ( ! s3 . does Bucket Exist ( bucket Name ) ) { try { s3 . create Bucket ( bucket Name ) ; if ( log . is Debug Enabled ( ) ) log . debug ( _ STR + bucket Name ) ; while ( ! s3 . does Bucket Exist ( bucket Name ) ) try {  U . sleep ( _ NUM ) ; } catch (  Ignite Interrupted Checked Exception e ) { throw new  Ignite Spi Exception ( _ STR , e ) ; } } catch (  Amazon Client Exception e ) { if ( ! s3 . does Bucket Exist ( bucket Name ) ) { s3 = null ; throw new  Ignite Spi Exception ( _ STR + bucket Name , e ) ; } } } } finally { init Latch . count Down ( ) ; } else { try {  U . await ( init Latch ) ; } catch (  Ignite Interrupted Checked Exception e ) { throw new  Ignite Spi Exception ( _ STR , e ) ; } if ( s3 == null ) throw new  Ignite Spi Exception ( _ STR ) ; } }
protected  Ball Node build Tree Middle Out ( int start Idx , int end Idx ) throws  Exception {  Instance pivot ; double radius ;  Vector <  Temp Node > anchors ; int num Insts = end Idx - start Idx + _ NUM ; int num Anchors = ( int )  Math . round (  Math . sqrt ( num Insts ) ) ; if ( num Anchors > _ NUM ) { pivot =  Ball Node . calc Centroid Pivot ( start Idx , end Idx , m_ Inst List , m_ Instances ) ; radius =  Ball Node . calc Radius ( start Idx , end Idx , m_ Inst List , m_ Instances , pivot , m_ Distance Function ) ; if ( num Insts <= m_ Max Instances In Leaf || ( root Radius == _ NUM ? _ BOOL : radius / root Radius < m_ Max Rel Leaf Radius ) ) {  Ball Node node = new  Ball Node ( start Idx , end Idx , m_ Num Nodes , pivot , radius ) ; return node ; } anchors = new  Vector <  Temp Node > ( num Anchors ) ; create Anchors Hierarchy ( anchors , num Anchors , start Idx , end Idx ) ;  Ball Node node = merge Nodes ( anchors , start Idx , end Idx ) ; build Leaves Middle Out ( node ) ; return node ; } else {  Ball Node node = new  Ball Node ( start Idx , end Idx , m_ Num Nodes , ( pivot =  Ball Node . calc Centroid Pivot ( start Idx , end Idx , m_ Inst List , m_ Instances ) ) ,  Ball Node . calc Radius ( start Idx , end Idx , m_ Inst List , m_ Instances , pivot , m_ Distance Function ) ) ; return node ; } }
public static double distance Point Line (  Coordinate p ,  Coordinate  A ,  Coordinate  B ) { if (  A . x ==  B . x &&  A . y ==  B . y ) return p . distance (  A ) ; double len2 = (  B . x -  A . x ) * (  B . x -  A . x ) + (  B . y -  A . y ) * (  B . y -  A . y ) ; double r = ( ( p . x -  A . x ) * (  B . x -  A . x ) + ( p . y -  A . y ) * (  B . y -  A . y ) ) / len2 ; if ( r <= _ NUM ) return p . distance (  A ) ; if ( r >= _ NUM ) return p . distance (  B ) ; double s = ( (  A . y - p . y ) * (  B . x -  A . x ) - (  A . x - p . x ) * (  B . y -  A . y ) ) / len2 ; return  Math . abs ( s ) *  Math . sqrt ( len2 ) ; }
public  Resource from Properties (  Properties properties ) {  String name = properties . get Property (  Resource Property Set .  RESOURCE_ NAME ) ;  String type = properties . get Property (  Resource Property Set .  RESOURCE_ TYPE ) ;  Resource resource = new  Resource ( name , type ) ; if ( properties . contains Key (  Resource Property Set .  RESOURCE_ CLASS ) ) {  String class Name = properties . get Property (  Resource Property Set .  RESOURCE_ CLASS ) ; resource . set Class Name ( class Name ) ; } if ( properties . contains Key (  Resource Property Set .  RESOURCE_ ID ) ) {  String id = properties . get Property (  Resource Property Set .  RESOURCE_ ID ) ; resource . set Id ( id ) ; } else { resource . set Id ( create Id From Jndi Location If Not Null ( name ) ) ; }  String parameters As ASemicolon Delimited String = properties . get Property (  Resource Property Set .  PARAMETERS ) ; resource . set Parameters (  Property Utils . to Map ( get Parameters From String (  Property Utils . escape Back Slashes If Not Null ( parameters As ASemicolon Delimited String ) ) ) ) ; return resource ; }
public void write ( byte [ ] b ) throws java . io .  IOException { write ( b , _ NUM , b . length ) ; }
private void create Gui ( ) { final  JPanel top Panel = new  JPanel ( new  Border Layout ( ) ) ; final  JPanel inner Top Panel = new  JPanel ( new  Border Layout ( ) ) ; top Panel . add ( inner Top Panel ) ; inner Top Panel . add ( m_std Edit Panel ) ; inner Top Panel . add ( m_debugger Panel ,  Border Layout .  SOUTH ) ; final  JPanel button Panel = new  JPanel ( new  Grid Layout ( _ NUM , _ NUM ) ) ; button Panel . set Border ( new  Empty Border ( _ NUM , _ NUM , _ NUM , _ NUM ) ) ; button Panel . add ( new  JPanel ( ) ) ; button Panel . add ( m_save Button ) ; top Panel . add ( button Panel ,  Border Layout .  SOUTH ) ; final  JPanel inner Sp = new  JPanel ( new  Border Layout ( ) ) ; m_middle Panel . set Preferred Size ( new  Dimension ( m_middle Panel . get Preferred Size ( ) . width , _ NUM ) ) ; inner Sp . add ( m_middle Panel ,  Border Layout .  NORTH ) ; inner Sp . add ( m_bottom Panel ,  Border Layout .  CENTER ) ; final  JSplit Pane outer Sp = new  JSplit Pane (  JSplit Pane .  VERTICAL_ SPLIT , _ BOOL , top Panel , inner Sp ) ; outer Sp . set One Touch Expandable ( _ BOOL ) ; outer Sp . set Divider Location ( outer Sp . get Minimum Divider Location ( ) ) ; outer Sp . set Resize Weight ( _ NUM ) ; final  JPanel inner Panel = new  JPanel ( new  Border Layout ( ) ) ; inner Panel . add ( outer Sp ) ; add ( inner Panel ) ; }
public static boolean is Document Mode Eligible (  Context context ) { return  Build .  VERSION .  SDK_ INT >=  Build .  VERSION_ CODES .  LOLLIPOP && !  Device Form Factor . is Tablet ( context ) ; }
private double gamma Ratio ( int n , int k ) { double top = ( n - k + _ NUM ) / _ NUM ; double bottom = ( n - k ) / _ NUM ; double lngamma =  Prob Utils . lngamma ( top ) -  Prob Utils . lngamma ( bottom ) ; return  Math . exp ( lngamma ) ; }
public boolean check For Dangerous Props ( ) { final  Map <  String ,  String > dangerous Props = new  Hash Map <  String ,  String > ( ) ; dangerous Props . put ( _ STR , _ STR ) ; dangerous Props . put ( _ STR , _ STR ) ; boolean result = _ BOOL ;  String [ ] lines = props Reader ( ) ; for (  String line : lines ) { for (  String key : dangerous Props . key Set ( ) ) { if ( line . contains ( key ) ) {  String bad Value = dangerous Props . get ( key ) ; bad Value = _ STR + bad Value + _ STR ; if ( line . contains ( bad Value ) ) {  QLog . v ( key + _ STR + bad Value + _ STR ) ; result = _ BOOL ; } } } } return result ; }
@  Override public  String to String ( ) {  String result ; if ( valid ) { result = _ STR + output File . get Absolute Path ( ) + _ STR ; if ( sign Mode ) { result += _ STR + key Store Path + _ STR + _ STR + alias + _ STR ; } else { result += _ STR + key File Path + _ STR ; } } else { return invalid Message ; } result += _ STR + reason + _ STR + _ STR + location + _ STR ; if ( can Encrypt ( ) ) { result += _ STR + _ STR ; } if ( can Flatten ( ) ) { result += _ STR + _ STR ; } if ( certify Mode !=  Itext Functions .  NOT_ CERTIFIED ) { result += _ STR + _ STR ; } return result ; }
public void add Cancel Listener (  Action Listener a ) { m_cancel But . add Action Listener ( a ) ; }
public double calculate Log Likelihood ( ) { double log L = _ NUM ; for (  Statistic statistic : data List ) { for ( int j = _ NUM ; j < statistic . get Dimension ( ) ; j ++ ) { log L -= _ NUM *  Math . log ( statistic . get Statistic Value ( j ) ) ; } } return log L ; }
public static boolean has Dead States To Accept (  Automaton a ) {  Bit Set reachable From Initial = get Live States From Initial ( a ) ;  Bit Set reachable From Accept = get Live States To Accept ( a ) ; reachable From Accept . and Not ( reachable From Initial ) ; return reachable From Accept . is Empty ( ) == _ BOOL ; }
public  Decimal add (  Decimal decimal ) { assert Defined ( ) ; if ( null == m_value ) { if ( null == decimal . get Big Decimal Value ( ) ) { return new  Decimal (  SCALE ) ; } else { return new  Decimal ( decimal . get Big Decimal Value ( ) ,  SCALE ) ; } }  Big Decimal value = m_value . add ( decimal . get Big Decimal Value ( ) ) ; return new  Decimal ( value ,  SCALE ) ; }
@  Override public boolean equals (  Object object ) { if ( object == null ) { return _ BOOL ; } if ( object == this ) { return _ BOOL ; } if ( super . equals ( object ) && object instanceof  Middle Pin Needle ) { return _ BOOL ; } return _ BOOL ; }
protected  String parse (  Reader reader ) throws  IOException { if ( ! reader . mark Supported ( ) ) { reader = new  Buffered Reader ( reader ) ; }  String Writer sw = new  String Writer ( ) ; start Script ( sw ) ; int c ; while ( ( c = reader . read ( ) ) != - _ NUM ) { if ( c == _ STR ) { reader . mark ( _ NUM ) ; c = reader . read ( ) ; if ( c != _ STR ) { sw . write ( _ STR ) ; reader . reset ( ) ; } else { reader . mark ( _ NUM ) ; c = reader . read ( ) ; if ( c == _ STR ) { groovy Expression ( reader , sw ) ; } else { reader . reset ( ) ; groovy Section ( reader , sw ) ; } } continue ; } if ( c == _ STR ) { reader . mark ( _ NUM ) ; c = reader . read ( ) ; if ( c != _ STR ) { sw . write ( _ STR ) ; reader . reset ( ) ; } else { reader . mark ( _ NUM ) ; sw . write ( _ STR ) ; process GSstring ( reader , sw ) ; } continue ; } if ( c == _ STR ) { sw . write ( _ STR ) ; } if ( c == _ STR || c == _ STR ) { if ( c == _ STR ) { reader . mark ( _ NUM ) ; c = reader . read ( ) ; if ( c != _ STR ) { reader . reset ( ) ; } } sw . write ( _ STR ) ; continue ; } sw . write ( c ) ; } end Script ( sw ) ; return sw . to String ( ) ; }
public void add (  IEditor Input input ) {  File file =  MME . get File ( input ) ; if ( file != null ) {  String uri =  Workbook History Item . to URI ( file . get Absolute Path ( ) ) ; remove ( input , uri ) ; items . add ( _ NUM , new  Workbook History Item ( input , uri ,  System . current Time Millis ( ) ) ) ; while ( items . size ( ) >  MAX_ SIZE ) { items . remove ( items . size ( ) - _ NUM ) ; } last Modified Time =  System . current Time Millis ( ) ; schedule Save ( ) ; fire Updated ( ) ; } }
public static  List <  Byte Buffer > base64 String To Byte Buffer (  String ... base64 Encoded Keys ) {  List <  Byte Buffer > byte Buffers = new  Array List < > ( base64 Encoded Keys . length ) ; for (  String base64 Encoded Key : base64 Encoded Keys ) { byte Buffers . add ( base64 String To Byte Buffer ( base64 Encoded Key ) ) ; } return byte Buffers ; }
public void update ( long dt Ms ) { m Current Time += dt Ms ; m Current Time =  Math . min ( m Current Time , m Duration + m Start Delay ) ; if ( m Delay Start Value && m Current Time < m Start Delay ) { return ; } long relative Time =  Math . max ( _ NUM ,  Math . min ( m Current Time - m Start Delay , m Duration ) ) ; set Property ( m Start + ( m End - m Start ) * m Interpolator . get Interpolation ( ( float ) relative Time / ( float ) m Duration ) ) ; }
public  String next String ( char quote ) throws  JSONException { char c ;  String Buffer sb = new  String Buffer ( ) ; for ( ; ; ) { c = next ( ) ; switch ( c ) { case _ NUM : case _ STR : case _ STR : throw syntax Error ( _ STR ) ; case _ STR : c = next ( ) ; switch ( c ) { case _ STR : sb . append ( _ STR ) ; break ; case _ STR : sb . append ( _ STR ) ; break ; case _ STR : sb . append ( _ STR ) ; break ; case _ STR : sb . append ( _ STR ) ; break ; case _ STR : sb . append ( _ STR ) ; break ; case _ STR : sb . append ( ( char )  Integer . parse Int ( next ( _ NUM ) , _ NUM ) ) ; break ; case _ STR : sb . append ( ( char )  Integer . parse Int ( next ( _ NUM ) , _ NUM ) ) ; break ; default : sb . append ( c ) ; } break ; default : if ( c == quote ) { return sb . to String ( ) ; } sb . append ( c ) ; } } }
public  H2 Full Pruned Block Store (  Network Parameters params ,  String db Name , int full Store Depth ) throws  Block Store Exception { this . params = params ; this . full Store Depth = full Store Depth ; connection URL = _ STR + db Name + _ STR ; conn = new  Thread Local <  Connection > ( ) ; all Connections = new  Linked List <  Connection > ( ) ; try {  Class . for Name ( driver ) ; log . info ( driver + _ STR ) ; } catch ( java . lang .  Class Not Found Exception e ) { log . error ( _ STR , e ) ; } maybe Connect ( ) ; try { if ( ! table Exists ( _ STR ) ) create Tables ( ) ; init From Database ( ) ; } catch (  SQLException e ) { throw new  Block Store Exception ( e ) ; } }
private  IRunning Query init Query With Conditional Routing Op (  IConstraint condition , int start Id , int join Id1 , int join Id2 ) throws  Exception { final int pred Id1 = _ NUM ; final int pred Id2 = _ NUM ; final int cond Id = _ NUM ; final int slice Id = _ NUM ; final  Pipeline Op start Op = new  Start Op ( new  BOp [ ] { } ,  NV . as Map ( new  NV [ ] { new  NV (  Predicate .  Annotations .  BOP_ ID , start Id ) , new  NV (  Slice Op .  Annotations .  EVALUATION_ CONTEXT ,  BOp Evaluation Context .  CONTROLLER ) } ) ) ; final  Predicate < ? > pred1 Op = new  Predicate <  E > ( new  IVariable Or Constant [ ] {  Var . var ( _ STR ) ,  Var . var ( _ STR ) } ,  NV . as Map ( new  NV [ ] { new  NV (  Predicate .  Annotations .  RELATION_ NAME , new  String [ ] { namespace } ) , new  NV (  Predicate .  Annotations .  BOP_ ID , pred Id1 ) , new  NV (  Annotations .  TIMESTAMP ,  ITx .  READ_ COMMITTED ) } ) ) ; final  Predicate < ? > pred2 Op = new  Predicate <  E > ( new  IVariable Or Constant [ ] {  Var . var ( _ STR ) ,  Var . var ( _ STR ) } ,  NV . as Map ( new  NV [ ] { new  NV (  Predicate .  Annotations .  RELATION_ NAME , new  String [ ] { namespace } ) , new  NV (  Predicate .  Annotations .  BOP_ ID , pred Id2 ) , new  NV (  Annotations .  TIMESTAMP ,  ITx .  READ_ COMMITTED ) } ) ) ; final  Conditional Routing Op cond = new  Conditional Routing Op ( new  BOp [ ] { start Op } ,  NV . as Map ( new  NV [ ] { new  NV (  BOp .  Annotations .  BOP_ ID , cond Id ) , new  NV (  Pipeline Op .  Annotations .  SINK_ REF , join Id1 ) , new  NV (  Pipeline Op .  Annotations .  ALT_ SINK_ REF , slice Id ) , new  NV (  Conditional Routing Op .  Annotations .  CONDITION , condition ) } ) ) ; final  Pipeline Op join1 Op = new  Pipeline Join <  E > ( new  BOp [ ] { cond } , new  NV (  Predicate .  Annotations .  BOP_ ID , join Id1 ) , new  NV (  Pipeline Join .  Annotations .  PREDICATE , pred1 Op ) ) ; final  Pipeline Op join2 Op = new  Pipeline Join <  E > ( new  BOp [ ] { join1 Op } , new  NV (  Predicate .  Annotations .  BOP_ ID , join Id2 ) , new  NV (  Pipeline Join .  Annotations .  PREDICATE , pred2 Op ) ) ; final  Pipeline Op slice Op = new  Slice Op ( new  BOp [ ] { join2 Op } ,  NV . as Map ( new  NV [ ] { new  NV (  BOp .  Annotations .  BOP_ ID , slice Id ) , new  NV (  BOp .  Annotations .  EVALUATION_ CONTEXT ,  BOp Evaluation Context .  CONTROLLER ) , new  NV (  Pipeline Op .  Annotations .  SHARED_ STATE , _ BOOL ) , new  NV (  Pipeline Op .  Annotations .  REORDER_ SOLUTIONS , _ BOOL ) , new  NV (  Query Engine .  Annotations .  CHUNK_ HANDLER ,  Standalone Chunk Handler .  TEST_ INSTANCE ) } ) ) ; final  Pipeline Op query = slice Op ; final  UUID query Id =  UUID . random UUID ( ) ; final  IBinding Set initial Bindings = new  List Binding Set ( ) ; { initial Bindings . set (  Var . var ( _ STR ) , new  Constant <  String > ( _ STR ) ) ; } final  IRunning Query running Query = query Engine . eval ( query Id , query , initial Bindings ) ; return running Query ; }
private  Token scan Flow Scalar ( char style ) { boolean _double ; if ( style == _ STR ) { _double = _ BOOL ; } else { _double = _ BOOL ; }  String Builder chunks = new  String Builder ( ) ;  Mark start Mark = reader . get Mark ( ) ; char quote = reader . peek ( ) ; reader . forward ( ) ; chunks . append ( scan Flow Scalar Non Spaces ( _double , start Mark ) ) ; while ( reader . peek ( ) != quote ) { chunks . append ( scan Flow Scalar Spaces ( start Mark ) ) ; chunks . append ( scan Flow Scalar Non Spaces ( _double , start Mark ) ) ; } reader . forward ( ) ;  Mark end Mark = reader . get Mark ( ) ; return new  Scalar Token ( chunks . to String ( ) , _ BOOL , start Mark , end Mark , style ) ; }
public static final  String to Bit String ( double d [ ] ) {  String Builder sb = new  String Builder ( d . length ) ; for ( double b : d ) { sb . append ( ( int )  Math . round ( b ) ) ; } return sb . to String ( ) ; }
public static  Byte Buffer convert To Signed16 Bit Samples ( float [ ] samples ) {  Byte Buffer converted =  Byte Buffer . allocate ( samples . length * _ NUM ) ; converted . order (  Byte Order .  LITTLE_ ENDIAN ) ; for ( float sample : samples ) { converted . put Short ( ( short ) ( sample *  Short .  MAX_ VALUE ) ) ; } return converted ; }
public static boolean validate Ip Port List (  String ip Port List ) { if ( ip Port List == null || ip Port List . is Empty ( ) ) { return _ BOOL ; }  String [ ] server Port List = ip Port List . split ( _ STR ) ; for (  String server Port : server Port List ) {  String ip = server Port . substring ( _ NUM , server Port . last Index Of ( _ STR ) ) ;  String port = server Port . substring ( server Port . last Index Of ( _ STR ) + _ NUM ) ; if ( ip . starts With ( _ STR ) && ip . ends With ( _ STR ) ) { ip = ip . substring ( _ NUM , ip . length ( ) - _ NUM ) ; if ( ! validate Ipv6 Addr ( ip ) ) return _ BOOL ; } else if ( validate Ipv6 Addr ( ip ) ) { return _ BOOL ; } else if ( ! validate Host Name ( ip ) ) { return _ BOOL ; } if ( ! validate Uint16 ( port ) ) return _ BOOL ; } return _ BOOL ; }
private void collapse Expanded ( final  Tree Path new Path ) { if ( ! m_stay Expanded Paths . is Empty ( ) ) {  Tree Path root = new Path ; while ( root . get Path Count ( ) > _ NUM ) { root = root . get Parent Path ( ) ; } final  Enumeration <  Tree Path > expanded Descendants = m_tree . get Expanded Descendants ( root ) ; final  Tree Path selected Path = m_tree . get Selection Path ( ) ; final  Stack <  Tree Path > collapse Paths = new  Stack < > ( ) ; while ( expanded Descendants . has More Elements ( ) ) { final  Tree Path current Descendant = expanded Descendants . next Element ( ) ; if ( ! current Descendant . is Descendant ( new Path ) && ( selected Path == null || ! current Descendant . is Descendant ( selected Path ) ) ) { collapse Paths . add ( current Descendant ) ; } } if ( ! collapse Paths . is Empty ( ) ) { for ( final  Tree Path current Path : collapse Paths ) { m_tree . collapse Path ( current Path ) ; } m_stay Expanded Paths . remove All ( collapse Paths ) ; } } }
public static  List <  Namespace Dto > transform To Dto (  List <  Namespace > namespaces ) { if ( namespaces == null ) { throw new  Web Application Exception ( _ STR ,  Status .  INTERNAL_ SERVER_ ERROR ) ; }  List <  Namespace Dto > result = new  Array List < > ( ) ; for (  Namespace namespace : namespaces ) { result . add ( transform To Dto ( namespace ) ) ; } return result ; }
public void test Timed Invoke Any3 ( ) throws  Throwable {  Count Down Latch latch = new  Count Down Latch ( _ NUM ) ;  Executor Service e = new  Fork Join Pool ( _ NUM ) ;  Pool Cleaner cleaner = null ; try { cleaner = cleaner ( e ) ;  List <  Callable <  String > > l = new  Array List <  Callable <  String > > ( ) ; l . add ( latch Awaiting String Task ( latch ) ) ; l . add ( null ) ; try { e . invoke Any ( l ,  MEDIUM_ DELAY_ MS ,  MILLISECONDS ) ; should Throw ( ) ; } catch (  Null Pointer Exception success ) { } latch . count Down ( ) ; } finally { if ( cleaner != null ) { cleaner . close ( ) ; } } }
public static void tql2 ( int n , double [ ] d , double [ ] e , double [ ] [ ]  V ) { for ( int i = _ NUM ; i < n ; i ++ ) { e [ i - _ NUM ] = e [ i ] ; } e [ n - _ NUM ] = _ NUM ; double f = _ NUM ; double tst1 = _ NUM ; double eps =  Math . pow ( _ NUM , - _ NUM ) ; for ( int l = _ NUM ; l < n ; l ++ ) { tst1 =  Math . max ( tst1 ,  Math . abs ( d [ l ] ) +  Math . abs ( e [ l ] ) ) ; int m = l ; while ( m < n ) { if (  Math . abs ( e [ m ] ) <= eps * tst1 ) { break ; } m ++ ; } if ( m > l ) { int iter = _ NUM ; do { iter = iter + _ NUM ; double g = d [ l ] ; double p = ( d [ l + _ NUM ] - g ) / ( _ NUM * e [ l ] ) ; double r = hypot ( p , _ NUM ) ; if ( p < _ NUM ) { r = - r ; } d [ l ] = e [ l ] / ( p + r ) ; d [ l + _ NUM ] = e [ l ] * ( p + r ) ; double dl1 = d [ l + _ NUM ] ; double h = g - d [ l ] ; for ( int i = l + _ NUM ; i < n ; i ++ ) { d [ i ] -= h ; } f = f + h ; p = d [ m ] ; double c = _ NUM ; double c2 = c ; double c3 = c ; double el1 = e [ l + _ NUM ] ; double s = _ NUM ; double s2 = _ NUM ; for ( int i = m - _ NUM ; i >= l ; i -- ) { c3 = c2 ; c2 = c ; s2 = s ; g = c * e [ i ] ; h = c * p ; r = hypot ( p , e [ i ] ) ; e [ i + _ NUM ] = s * r ; s = e [ i ] / r ; c = p / r ; p = c * d [ i ] - s * g ; d [ i + _ NUM ] = h + s * ( c * g + s * d [ i ] ) ; for ( int k = _ NUM ; k < n ; k ++ ) { h =  V [ k ] [ i + _ NUM ] ;  V [ k ] [ i + _ NUM ] = s *  V [ k ] [ i ] + c * h ;  V [ k ] [ i ] = c *  V [ k ] [ i ] - s * h ; } } p = - s * s2 * c3 * el1 * e [ l ] / dl1 ; e [ l ] = s * p ; d [ l ] = c * p ; } while (  Math . abs ( e [ l ] ) > eps * tst1 ) ; } d [ l ] = d [ l ] + f ; e [ l ] = _ NUM ; } for ( int i = _ NUM ; i < n - _ NUM ; i ++ ) { int k = i ; double p = d [ i ] ; for ( int j = i + _ NUM ; j < n ; j ++ ) { if ( d [ j ] < p ) { k = j ; p = d [ j ] ; } } if ( k != i ) { d [ k ] = d [ i ] ; d [ i ] = p ; for ( int j = _ NUM ; j < n ; j ++ ) { p =  V [ j ] [ i ] ;  V [ j ] [ i ] =  V [ j ] [ k ] ;  V [ j ] [ k ] = p ; } } } }
public  Int Pointer (  String s ) { this ( s . length ( ) + _ NUM ) ; put String ( s ) ; }
private  Hash Map add Attr (  Svc Reg reg ,  Entry Class eclass , int fldidx ,  Object value ) {  Hash Map [ ] attr Maps = (  Hash Map [ ] ) service By Attr . get ( eclass ) ; if ( attr Maps == null ) { attr Maps = new  Hash Map [ eclass . get Num Fields ( ) ] ; service By Attr . put ( eclass , attr Maps ) ; }  Hash Map map = attr Maps [ fldidx ] ; if ( map == null ) { map = new  Hash Map ( _ NUM ) ; attr Maps [ fldidx ] = map ; }  Array List regs = (  Array List ) map . get ( value ) ; if ( regs == null ) { regs = new  Array List ( _ NUM ) ; map . put ( value , regs ) ; } else if ( regs . contains ( reg ) ) return map ; regs . add ( reg ) ; return map ; }
public  Query String Decoder Util (  String uri ) { this ( uri ,  Charset . default Charset ( ) ) ; }
public static void print Raw Lines (  Print Writer writer ,  String msg ) { int nl ; while ( ( nl = msg . index Of ( _ STR ) ) != - _ NUM ) { writer . println ( msg . substring ( _ NUM , nl ) ) ; msg = msg . substring ( nl + _ NUM ) ; } if ( msg . length ( ) != _ NUM ) writer . println ( msg ) ; }
@  Override public void on Destroy ( ) {  LOG . d (  TAG , _ STR ) ; super . on Destroy ( ) ; if ( this . app View != null ) { app View . handle Destroy ( ) ; } else { this . activity State =  ACTIVITY_ EXITING ; } }
private static  Windows File Attributes from File Attribute Data ( long address , int reparse Tag ) { int file Attrs = unsafe . get Int ( address +  OFFSETOF_ FILE_ ATTRIBUTE_ DATA_ ATTRIBUTES ) ; long creation Time = unsafe . get Long ( address +  OFFSETOF_ FILE_ ATTRIBUTE_ DATA_ CREATETIME ) ; long last Access Time = unsafe . get Long ( address +  OFFSETOF_ FILE_ ATTRIBUTE_ DATA_ LASTACCESSTIME ) ; long last Write Time = unsafe . get Long ( address +  OFFSETOF_ FILE_ ATTRIBUTE_ DATA_ LASTWRITETIME ) ; long size = ( ( long ) ( unsafe . get Int ( address +  OFFSETOF_ FILE_ ATTRIBUTE_ DATA_ SIZEHIGH ) ) << _ NUM ) + ( unsafe . get Int ( address +  OFFSETOF_ FILE_ ATTRIBUTE_ DATA_ SIZELOW ) & _ NUM ) ; return new  Windows File Attributes ( file Attrs , creation Time , last Access Time , last Write Time , size , reparse Tag , _ NUM , _ NUM , _ NUM ) ; }
public static final void write Map Xml (  Map val ,  Xml Serializer out ,  Write Map Callback callback ) throws  Xml Pull Parser Exception , java . io .  IOException { if ( val == null ) { return ; }  Set s = val . entry Set ( ) ;  Iterator i = s . iterator ( ) ; while ( i . has Next ( ) ) {  Map .  Entry e = (  Map .  Entry ) i . next ( ) ; write Value Xml ( e . get Value ( ) , (  String ) e . get Key ( ) , out , callback ) ; } }
public final void fire Event (  Event event ) { event Handlers . fire Event ( event ) ; }
@  Override public boolean contains Value (  Object value ) { poll ( ) ; if ( value != null ) { for ( int i = element Data . length ; -- i >= _ NUM ; ) {  Entry <  K ,  V > entry = element Data [ i ] ; while ( entry != null ) {  K key = entry . get ( ) ; if ( ( key != null || entry . is Null ) && value . equals ( entry . value ) ) { return _ BOOL ; } entry = entry . next ; } } } else { for ( int i = element Data . length ; -- i >= _ NUM ; ) {  Entry <  K ,  V > entry = element Data [ i ] ; while ( entry != null ) {  K key = entry . get ( ) ; if ( ( key != null || entry . is Null ) && entry . value == null ) { return _ BOOL ; } entry = entry . next ; } } } return _ BOOL ; }
public  IResource [ ] members ( final  IResource resource ) {  Check . not Null ( resource , _ STR ) ; final  List <  IResource > members = member Map . get ( resource ) ; if ( members == null ) { return new  IResource [ _ NUM ] ; } return members . to Array ( new  IResource [ members . size ( ) ] ) ; }
private static  Annotation create Zipkin Annotation (  String value , long time ,  Endpoint ep , boolean send Request ) {  Annotation annotation = new  Annotation ( ) ; annotation . set Host ( ep ) ; if ( send Request ) { annotation . set Timestamp ( time * _ NUM ) ; } else { annotation . set Timestamp ( time * _ NUM ) ; } annotation . set Value ( value ) ; return annotation ; }
public  Connector create Connector (  Inet Address inet Address , int port , boolean secure ) { return new  Connector ( invoke ( embedded Create Connector , inet Address , new  Integer ( port ) ,  Boolean . value Of ( secure ) ) ) ; }
public boolean revision Contains Template Names ( int rev Id ,  List <  String > template Names ) throws  Wiki Api Exception {  List <  String > tpl List = get Template Names From Revision ( rev Id ) ; for (  String tpl : tpl List ) { for (  String template Name : template Names ) { if ( tpl . equals Ignore Case ( template Name ) ) { return _ BOOL ; } } } return _ BOOL ; }
public  List <  Generic Entry > retrieve All Mailbox Dump Requests (  Date from Date ) throws  Apps For Your Domain Exception ,  Malformed URLException ,  IOException ,  Service Exception {  String url =  BASE_ URL + _ STR + domain ; if ( from Date != null ) { url += _ STR +  DATE_ FORMAT . format ( from Date ) ; } return get All Pages ( new  URL ( url ) ,  Generic Feed . class ) ; }
protected void draw Oval ( int x , int y , int w , int h ,  Color fill Color ,  Paint fill Paint ,  Color pen Color , boolean shadow ) { if ( fill Color != null || fill Paint != null ) { if ( shadow ) { g . set Color ( mx Constants .  SHADOW_ COLOR ) ; g . fill Oval ( x + mx Constants .  SHADOW_ OFFSETX , y + mx Constants .  SHADOW_ OFFSETY , w , h ) ; } if ( fill Paint != null ) { g . set Paint ( fill Paint ) ; } else { g . set Color ( fill Color ) ; } g . fill Oval ( x , y , w , h ) ; } if ( pen Color != null ) { g . set Color ( pen Color ) ; g . draw Oval ( x , y , w , h ) ; } }
protected int exec Script (  String script ,  String List args ) { if ( is Windows ( ) ) {  String List new Args = new  String List ( ) ; new Args . add ( _ STR ) ; new Args . add ( script ) ; new Args . add All ( args ) ; return exec ( _ STR , new Args ) ; } return exec ( script , args ) ; }
protected void signal Event (  Ddl Parser Listener .  Event event ) { if ( event != null && ! listeners . is Empty ( ) ) { listeners . for Each ( null ) ; } }
public static  Decompounded Word create From String (  String a Split ) {  Decompounded Word s = new  Decompounded Word ( ) ;  String [ ] elems = a Split . split ( _ STR ) ; for (  String string : elems ) { s . append Split Element (  Fragment . create From String ( string ) ) ; } return s ; }
public  String app_source_path (  String app_class ) {  String filename = app_class . replace ( _ STR , _ STR ) ; filename = filename . replace First ( _ STR , _ STR ) ; if ( filename . index Of ( _ STR ) > _ NUM ) { filename = filename . substring ( _ NUM , filename . index Of ( _ STR ) ) ; } return _ STR + filename + _ STR ; }
public void add Title Prefix (  String prfx ) { if ( ! title Prefix . contains ( prfx ) ) { title Prefix . add ( prfx ) ; fire Property Change (  TITLE_ PREFIX , null , title Prefix ) ; } }
public void send (  Set recipients , boolean multicast ) throws  Interrupted Exception ,  Reply Exception { if (  Thread . interrupted ( ) ) { throw new  Interrupted Exception ( ) ; } this . op = operation Type .  DRAIN_ POOL ;  Set recips = new  Hash Set ( recipients ) ;  Distributed Member me = origin Dm . get Distribution Manager Id ( ) ; if ( recips . contains ( me ) ) { recips . remove ( me ) ; } rp = new  Reply Processor21 ( origin Dm , recips ) ; processor Id = rp . get Processor Id ( ) ; set Recipients ( recips ) ; set Multicast ( multicast ) ; origin Dm . put Outgoing ( this ) ; rp . wait For Replies ( ) ; }
public static int write (  Audio Input Stream stream ,  Audio File Format .  Type file Type ,  File out ) throws  IOException {  List providers = get Audio File Writers ( ) ; int bytes Written = _ NUM ; boolean flag = _ BOOL ; for ( int i = _ NUM ; i < providers . size ( ) ; i ++ ) {  Audio File Writer writer = (  Audio File Writer ) providers . get ( i ) ; try { bytes Written = writer . write ( stream , file Type , out ) ; flag = _ BOOL ; break ; } catch (  Illegal Argument Exception e ) { continue ; } } if ( ! flag ) { throw new  Illegal Argument Exception ( _ STR + file Type ) ; } else { return bytes Written ; } }
public int find Engine By Road Number (  String road Number ) { if ( sys List != null ) { if ( ! road Number . equals ( _road Number ) ) { return get Index ( _ NUM , road Number ) ; } int index = get Index ( _index , road Number ) ; if ( index > _ NUM ) { return index ; } return get Index ( _ NUM , road Number ) ; } return - _ NUM ; }
@  Dotted Class Name @  Suppress FBWarnings ( _ STR ) public static  String to Dotted Class Name ( @  Slashed Class Name ( when =  When .  UNKNOWN )  String class Name ) { if ( class Name . index Of ( _ STR ) >= _ NUM ) { return  Descriptor Factory . canonicalize String ( class Name . replace ( _ STR , _ STR ) ) ; } return class Name ; }
public  Cholesky Decomposition (  Matrix  Arg ) { double [ ] [ ]  A =  Arg . get Array ( ) ; n =  Arg . get Row Dimension ( ) ;  L = new double [ n ] [ n ] ; isspd = (  Arg . get Column Dimension ( ) == n ) ; for ( int j = _ NUM ; j < n ; j ++ ) { double [ ]  Lrowj =  L [ j ] ; double d = _ NUM ; for ( int k = _ NUM ; k < j ; k ++ ) { double [ ]  Lrowk =  L [ k ] ; double s = _ NUM ; for ( int i = _ NUM ; i < k ; i ++ ) { s +=  Lrowk [ i ] *  Lrowj [ i ] ; }  Lrowj [ k ] = s = (  A [ j ] [ k ] - s ) /  L [ k ] [ k ] ; d = d + s * s ; isspd = isspd & (  A [ k ] [ j ] ==  A [ j ] [ k ] ) ; } d =  A [ j ] [ j ] - d ; isspd = isspd & ( d > _ NUM ) ;  L [ j ] [ j ] =  Math . sqrt (  Math . max ( d , _ NUM ) ) ; for ( int k = j + _ NUM ; k < n ; k ++ ) {  L [ j ] [ k ] = _ NUM ; } } }
public void register (  Location location ) {  Integer old Size =  Integer . value Of ( _location Hash Table . size ( ) ) ; _location Hash Table . put ( location . get Id ( ) , location ) ; int id =  Integer . parse Int ( location . get Id ( ) ) ; if ( id > _id ) { _id = id ; } set Dirty And Fire Property Change (  LISTLENGTH_ CHANGED_ PROPERTY , old Size ,  Integer . value Of ( _location Hash Table . size ( ) ) ) ; }
@  Override public void on Finish Input ( ) { super . on Finish Input ( ) ; m Composing . set Length ( _ NUM ) ; update Candidates ( ) ; set Candidates View Shown ( _ BOOL ) ; m Cur Keyboard = m Qwerty Keyboard ; if ( m Input View != null ) { m Input View . closing ( ) ; } }
@  Not Null private  Flutter Daemon Controller controller For (  String project Dir ,  String device Id ) { synchronized ( my Lock ) {  Flutter Daemon Controller new Controller = new  Flutter Daemon Controller ( project Dir ) ; my Controllers . add ( new Controller ) ; new Controller . add Listener ( my Listener ) ; return new Controller ; } }
@  Override public boolean connection Allowed (  String event Name ) { if ( m_listenees . contains Key ( event Name ) ) { return _ BOOL ; } if ( m_listenees . contains Key ( _ STR ) && ( event Name . compare To ( _ STR ) == _ NUM || event Name . compare To ( _ STR ) == _ NUM || event Name . compare To ( _ STR ) == _ NUM ) ) { return _ BOOL ; } if ( ( m_listenees . contains Key ( _ STR ) || m_listenees . contains Key ( _ STR ) ) && ( event Name . compare To ( _ STR ) == _ NUM || event Name . compare To ( _ STR ) == _ NUM ) ) { return _ BOOL ; } if ( m_listenees . contains Key ( _ STR ) && ( event Name . compare To ( _ STR ) == _ NUM || event Name . compare To ( _ STR ) == _ NUM || event Name . compare To ( _ STR ) == _ NUM ) ) { return _ BOOL ; } if ( event Name . compare To ( _ STR ) == _ NUM && ! ( m_ Filter instanceof  Streamable Filter ) ) { return _ BOOL ; } return _ BOOL ; }
public static  Vector2 abs (  Vector2 o ) { return new  Vector2 (  Math . abs ( o . x ) ,  Math . abs ( o . z ) ) ; }
public static  Object invoke Static (  String clazz ,  String method Name ,  Class [ ] types ,  Object [ ] values ,  Object default Value ) { try { return invoke Static (  Class . for Name ( clazz ) , method Name , types , values ) ; } catch (  Class Not Found Exception e ) { return default Value ; } catch (  No Such Method Exception e ) { return default Value ; } }
protected static  String read Stream (  Input Stream stream ) throws  One Drive APIException { if ( stream == null ) { return null ; }  Input Stream Reader reader = new  Input Stream Reader ( stream ,  Standard Charsets .  UTF_8 ) ;  String Builder builder = new  String Builder ( ) ; char [ ] buffer = new char [  BUFFER_ SIZE ] ; try { int read ; while ( ( read = reader . read ( buffer , _ NUM ,  BUFFER_ SIZE ) ) != - _ NUM ) { builder . append ( buffer , _ NUM , read ) ; } stream . close ( ) ; } catch (  IOException e ) { throw new  One Drive APIException ( _ STR , e ) ; } return builder . to String ( ) ; }
protected  JButton create Left One Touch Button ( ) {  Sea Glass Arrow Button b = new  Sea Glass Arrow Button (  Swing Constants .  NORTH ) ; int one Touch Size = lookup One Touch Size ( ) ; b . set Name ( _ STR ) ; b . set Minimum Size ( new  Dimension ( one Touch Size , one Touch Size ) ) ; b . set Cursor (  Cursor . get Predefined Cursor ( split Pane . get Orientation ( ) ==  JSplit Pane .  HORIZONTAL_ SPLIT ?  Cursor .  W_ RESIZE_ CURSOR :  Cursor .  N_ RESIZE_ CURSOR ) ) ; b . set Focus Painted ( _ BOOL ) ; b . set Border Painted ( _ BOOL ) ; b . set Request Focus Enabled ( _ BOOL ) ; b . set Direction ( map Direction ( _ BOOL ) ) ; return b ; }
public void add Mapping (  Matcher <  Request > request Matcher ,  Response Source response Source ) { mappings . add First ( new  Matcher Response Source Pair ( request Matcher , response Source ) ) ; }
@  Override @  Timed public  Assignment assign User (  Assignment assignment ,  Experiment experiment ,  Date date ) {  Assignment new_assignment = null ; if ( assign User To Old ) { new_assignment = assign User To Old ( assignment , date ) ; } if ( assign User To New ) { new_assignment = assign User To Look Up ( assignment , date ) ; } boolean count Up = _ BOOL ; assignments Count Executor . execute ( new  Assignment Count Envelope ( assignments Repository , experiment Repository , db Repository , experiment , assignment , count Up , event Log , date , assign User To Export , assign Bucket Count ) ) ; index User To Experiment ( assignment ) ; index User To Bucket ( assignment ) ; index Experiments To User ( assignment ) ; return new_assignment ; }
@  Suppress Warnings ( _ STR ) public static  String [ ] split (  String original ,  String separator ) { nodes . remove All Elements ( ) ; int index = original . index Of ( separator ) ; while ( index >= _ NUM ) { nodes . add Element ( original . substring ( _ NUM , index ) ) ; original = original . substring ( index + separator . length ( ) ) ; index = original . index Of ( separator ) ; } nodes . add Element ( original ) ;  String [ ] result = new  String [ nodes . size ( ) ] ; if ( nodes . size ( ) > _ NUM ) { for ( int loop = _ NUM ; loop < nodes . size ( ) ; loop ++ ) { result [ loop ] = (  String ) nodes . element At ( loop ) ; } } return result ; }
public void move To End (  Instruction inst ) {  Iterator <  GCIRMap Element > iter = list . iterator ( ) ; while ( iter . has Next ( ) ) {  GCIRMap Element new Ptr = iter . next ( ) ; if ( new Ptr . get Instruction ( ) == inst ) { iter . remove ( ) ; list . add ( new Ptr ) ; return ; } } throw new  Optimizing Compiler Exception ( _ STR + inst + _ STR ) ; }
public synchronized  Object co_entry_pause ( int this Coroutine ) throws java . lang .  No Such Method Exception { if ( ! m_active IDs . get ( this Coroutine ) ) throw new java . lang .  No Such Method Exception ( ) ; while ( m_next Coroutine != this Coroutine ) { try { wait ( ) ; } catch ( java . lang .  Interrupted Exception e ) { } } return m_yield ; }
public static  String join (  String separator ,  List <  String > strings ) {  String Builder sb = new  String Builder ( ) ; for (  Iterator <  String > iter = strings . iterator ( ) ; iter . has Next ( ) ; ) {  String s = iter . next ( ) ; sb . append ( s ) ; if ( iter . has Next ( ) ) sb . append ( separator ) ; } return sb . to String ( ) ; }
public boolean add (  String document , boolean to Head ) { int i = documents . index Of ( document ) ; if ( _ NUM == i ) return _ BOOL ; if ( _ NUM < i ) { documents . remove ( i ) ; } else { while ( documents . size ( ) >= max Size ) { documents . remove ( max Size - _ NUM ) ; } } if ( to Head ) { documents . add ( _ NUM , document ) ; } else { documents . add ( document ) ; } fire MRUList Changed ( ) ; return _ BOOL ; }
private void schedule Settings Save ( ) { if ( ! m Loading Settings ) { if ( m Settings Save Pending . compare And Set ( _ BOOL , _ BOOL ) ) { m Thread Pool Manager . schedule Once ( new  Settings Save Task ( ) , _ NUM ,  Time Unit .  SECONDS ) ; } } }
protected void continue Read ( ) { if ( log . is Debug Enabled ( ) ) { log . debug ( _ STR ) ; }  Iterator <  Variable Value > i = variables . iterator ( ) ; while ( i . has Next ( ) ) {  Variable Value v = i . next ( ) ; if ( v . is To Read ( ) && ( ! reading Changes || v . is Changed ( ) ) ) { am Reading = _ BOOL ; set Busy ( _ BOOL ) ; if ( reading Changes ) { v . read Changes ( ) ; } else { v . read All ( ) ; } return ; } } am Reading = _ BOOL ; super . set State (  READ ) ; set Busy ( _ BOOL ) ; log . debug ( _ STR ) ; }
public void action Performed (  Action Event e ) {  Swing Utilities . invoke Later ( m_tick PB ) ; }
@  Override public  String to String No Weight ( int after Decimal Point ) {  String Buffer text = new  String Buffer ( ) ; for ( int i = _ NUM ; i < m_ Att Values . length ; i ++ ) { if ( i > _ NUM ) { text . append ( _ STR ) ; } text . append ( to String ( i , after Decimal Point ) ) ; } return text . to String ( ) ; }
public static  Integer to Ref ( int i ) { return  Integer . value Of ( i ) ; }
public boolean add ( int value ) { int index = value % this . num Buckets ;  Bucket bucket = this . buckets [ index ] ; if ( bucket == null ) { bucket = this . buckets [ index ] = new  Bucket ( this . bucket Initial Capacity ) ; } else { for ( int i = _ NUM ; i < bucket . length ; i ++ ) { if ( bucket . values [ i ] == value ) return _ BOOL ; } } if ( bucket . values . length <= bucket . length ) { int [ ] tmp = new int [ _ NUM * bucket . values . length ] ;  System . arraycopy ( bucket . values , _ NUM , tmp , _ NUM , bucket . values . length ) ; bucket . values = tmp ; } bucket . values [ bucket . length ++ ] = value ; this . size ++ ; return _ BOOL ; }
@  Override public void put All (  Map < ? extends  K , ? extends  V > m ) { try Presize ( m . size ( ) ) ; for (  Map .  Entry < ? extends  K , ? extends  V > e : m . entry Set ( ) ) put Val ( e . get Key ( ) , e . get Value ( ) , _ BOOL ) ; }
public  String build Query (  String [ ] projection In ,  String selection ,  String group By ,  String having ,  String sort Order ,  String limit ) {  String [ ] projection = compute Projection ( projection In ) ;  String Builder where = new  String Builder ( ) ; boolean has Base Where Clause = m Where Clause != null && m Where Clause . length ( ) > _ NUM ; if ( has Base Where Clause ) { where . append ( m Where Clause . to String ( ) ) ; where . append ( _ STR ) ; } if ( selection != null && selection . length ( ) > _ NUM ) { if ( has Base Where Clause ) { where . append ( _ STR ) ; } where . append ( _ STR ) ; where . append ( selection ) ; where . append ( _ STR ) ; } return build Query String ( m Distinct , m Tables , projection , where . to String ( ) , group By , having , sort Order , limit ) ; }
@  Override public void write ( byte [ ] buffer , int offset , int length ) throws  IOException { int to Send = length ; int sent ; long start =  System . current Time Millis ( ) ; while ( to Send > _ NUM ) { synchronized ( pseudo Tcp ) { sent = pseudo Tcp . send ( buffer , offset + length - to Send , to Send ) ; } if ( sent > _ NUM ) { to Send -= sent ; } else { try { logger . log (  Level .  FINER , _ STR ) ; synchronized ( write_notify ) { if ( write Timeout > _ NUM ) { long elapsed =  System . current Time Millis ( ) - start ; long left = write Timeout - elapsed ; if ( left <= _ NUM ) {  IOException exc = new  IOException ( _ STR ) ; pseudo Tcp . closedown ( exc ) ; throw exc ; } write_notify . wait ( left ) ; } else { write_notify . wait ( ) ; } } logger . log (  Level .  FINER , _ STR + pseudo Tcp . get Available Send Buffer ( ) ) ; if ( exception != null ) { throw exception ; } } catch (  Interrupted Exception ex ) { if ( exception != null ) { throw new  IOException ( _ STR , exception ) ; } else { throw new  IOException ( _ STR , ex ) ; } } } } }
public static void copy (  File source ,  File destination ) throws  IOException {  Validate . not Null ( source , _ STR ) ;  Validate . not Null ( destination , _ STR ) ; if ( source . equals ( destination ) ) { return ; }  Input Stream input = null ;  Output Stream output = null ; try { input = new  File Input Stream ( source ) ; try { output = new  File Output Stream ( destination ) ; copy ( input , output ) ; } finally { if ( output != null ) { output . close ( ) ; } } } finally { if ( input != null ) { input . close ( ) ; } } }
public static  Tree build Tree (  Rule rule ,  List <  HGNode > tail Nodes , int max Depth ) {  Tree tree = get Fragment From Yield ( rule . get English Words ( ) ) ; if ( tree == null ) { tree = new  Tree (  String . format ( _ STR ,  Vocabulary . word ( rule . get LHS ( ) ) , rule . get English Words ( ) ) ) ; } else { tree = tree . shallow Clone ( ) ; } if ( tree != null && tail Nodes != null && tail Nodes . size ( ) > _ NUM && max Depth > _ NUM ) {  List <  Tree > frontier = tree . get Nonterminal Yield ( ) ;  Array List <  Integer > tail Indices = new  Array List < > ( ) ; int [ ] english Ints = rule . get English ( ) ; for ( int english Int : english Ints ) if ( english Int < _ NUM ) tail Indices . add ( - _ NUM * english Int - _ NUM ) ; for ( int i = _ NUM ; i < tail Nodes . size ( ) ; i ++ ) { try {  Tree frontier Tree = frontier . get ( tail Indices . get ( i ) ) ; frontier Tree . set Boundary ( _ BOOL ) ;  Hyper Edge edge = tail Nodes . get ( i ) . best Hyperedge ; if ( edge != null ) {  Tree child Tree = build Tree ( edge . get Rule ( ) , edge . get Tail Nodes ( ) , max Depth - _ NUM ) ; if ( child Tree != null ) frontier Tree . children = child Tree . children ; } else { frontier Tree . children = tree . children ; } } catch (  Index Out Of Bounds Exception e ) {  LOG . error ( _ STR , i ) ;  LOG . error ( _ STR , rule . get English Words ( ) , tree ) ;  LOG . error ( _ STR ) ; for (  Tree kid : frontier ) {  LOG . error ( _ STR , kid ) ; } throw new  Runtime Exception (  String . format ( _ STR , i ) , e ) ; } } } return tree ; }
public  CGPoint inverse Transform (  CGPoint src ,  CGPoint dst ) throws  Noninvertible Transform Exception { double det = get Determinant ( ) ; if (  Math . abs ( det ) <  ZERO ) { throw new  Noninvertible Transform Exception ( _ STR ) ; } if ( dst == null ) { dst =  CGPoint . zero ( ) ; } double x = src . x - m02 ; double y = src . y - m12 ; dst . x = ( float ) ( ( x * m11 - y * m01 ) / det ) ; dst . y = ( float ) ( ( y * m00 - x * m10 ) / det ) ; return dst ; }
private void load Currencies ( ) { s_ Currencies = new  Hashtable <  Integer ,  Key Name Pair > ( _ NUM ) ;  String  SQL = _ STR + _ STR + _ STR ; try {  Prepared Statement pstmt =  DB . prepare Statement (  SQL , null ) ;  Result Set rs = pstmt . execute Query ( ) ; while ( rs . next ( ) ) { int id = rs . get Int ( _ NUM ) ;  String name = rs . get String ( _ NUM ) ; s_ Currencies . put ( new  Integer ( id ) , new  Key Name Pair ( id , name ) ) ; } rs . close ( ) ; pstmt . close ( ) ; } catch (  SQLException e ) { log . log (  Level .  SEVERE ,  SQL , e ) ; } }
@  Override public  List <  Work Order > search WOFor MB ( final  Map <  String ,  Object > criteria Map ) { logger . info ( _ STR ) ; final  List <  Work Order > filtered List = new  Array List <  Work Order > ( ) ; criteria Map . put (  ACTION_ FLAG , _ STR ) ; for ( final  Work Order workorder : search WO ( criteria Map ) ) if ( ! is Approval Limit Reached For WO ( workorder . get Id ( ) ) ) filtered List . add ( workorder ) ; return filtered List ; }
public  Day (  Date time ,  Time Zone zone ,  Locale locale ) {  Param Checks . null Not Permitted ( time , _ STR ) ;  Param Checks . null Not Permitted ( zone , _ STR ) ;  Param Checks . null Not Permitted ( locale , _ STR ) ;  Calendar calendar =  Calendar . get Instance ( zone , locale ) ; calendar . set Time ( time ) ; int d = calendar . get (  Calendar .  DAY_ OF_ MONTH ) ; int m = calendar . get (  Calendar .  MONTH ) + _ NUM ; int y = calendar . get (  Calendar .  YEAR ) ; this . serial Date =  Serial Date . create Instance ( d , m , y ) ; peg ( calendar ) ; }
public  Resource Queue (  R resource ,  Tx Dag waits For ) { if ( resource == null ) throw new  Null Pointer Exception ( ) ; this . resource = resource ; this . waits For = waits For ; }
public void sign (  Private Key key ,  String algorithm ,  String provider ) throws  Certificate Exception ,  No Such Algorithm Exception ,  Invalid Key Exception ,  No Such Provider Exception ,  Signature Exception { try { if ( read Only ) throw new  Certificate Encoding Exception ( _ STR ) ;  Signature sig Engine = null ; if ( ( provider == null ) || ( provider . length ( ) == _ NUM ) ) sig Engine =  Signature . get Instance ( algorithm ) ; else sig Engine =  Signature . get Instance ( algorithm , provider ) ; sig Engine . init Sign ( key ) ; alg Id =  Algorithm Id . get ( sig Engine . get Algorithm ( ) ) ;  Der Output Stream out = new  Der Output Stream ( ) ;  Der Output Stream tmp = new  Der Output Stream ( ) ; info . encode ( tmp ) ; byte [ ] raw Cert = tmp . to Byte Array ( ) ; alg Id . encode ( tmp ) ; sig Engine . update ( raw Cert , _ NUM , raw Cert . length ) ; signature = sig Engine . sign ( ) ; tmp . put Bit String ( signature ) ; out . write (  Der Value . tag_ Sequence , tmp ) ; signed Cert = out . to Byte Array ( ) ; read Only = _ BOOL ; } catch (  IOException e ) { throw new  Certificate Encoding Exception ( e . to String ( ) ) ; } }
public void schedule At Fixed Rate (  Timer Task task ,  Date when , long period ) { if ( period <= _ NUM || when . get Time ( ) < _ NUM ) { throw new  Illegal Argument Exception ( ) ; } long delay = when . get Time ( ) -  System . current Time Millis ( ) ; schedule Impl ( task , delay , period , _ BOOL ) ; }
protected void stop Output Test ( ) { if ( test Running && out Test ) { out Timer . stop ( ) ; status Text1 . set Text ( _ STR +  Integer . to String ( num Iterations ) + _ STR ) ; status Text1 . set Visible ( _ BOOL ) ; status Text2 . set Text ( _ STR ) ; status Text2 . set Visible ( _ BOOL ) ; } }
protected int find Row Item (  Comparator <  Row Item > comparator ,  Row Item item ) { int row = lookup Row Item ( comparator , item ) ; if ( row < table . get Row Count ( ) && comparator . compare ( item , get Row Item ( row ) ) == _ NUM ) { return row ; } return - _ NUM ; }
private void nuke Symbols ( ) { _count = _ NUM ;  Arrays . fill ( _main Hash , _ NUM ) ;  Arrays . fill ( _main Names , null ) ;  Arrays . fill ( _coll List , null ) ; _coll Count = _ NUM ; _coll End = _ NUM ; }
public  Name join (  Name rhs ) {  List <  Name Piece > new Piece List = new  Array List < > ( ) ; new Piece List . add All ( name Pieces ) ; new Piece List . add All ( rhs . name Pieces ) ; return new  Name ( new Piece List ) ; }
public static  Date parse Date (  String date Str ) { try { return m Simple Date Format . parse ( date Str ) ; } catch (  Parse Exception e ) { e . print Stack Trace ( ) ; throw new  Runtime Exception ( _ STR ) ; } }
public static  String number To String (  Number number ) throws  JSONException { if ( number == null ) { throw new  JSONException ( _ STR ) ; } test Validity ( number ) ;  String string = number . to String ( ) ; if ( string . index Of ( _ STR ) > _ NUM && string . index Of ( _ STR ) < _ NUM && string . index Of ( _ STR ) < _ NUM ) { while ( string . ends With ( _ STR ) ) { string = string . substring ( _ NUM , string . length ( ) - _ NUM ) ; } if ( string . ends With ( _ STR ) ) { string = string . substring ( _ NUM , string . length ( ) - _ NUM ) ; } } return string ; }
public static boolean is Numeric Type Specifier ( char c , boolean is Decimal ) { if ( is Decimal ) { switch ( c ) { case _ STR : case _ STR : case _ STR : case _ STR : case _ STR : case _ STR : return _ BOOL ; } } else { switch ( c ) { case _ STR : case _ STR : case _ STR : case _ STR : case _ STR : case _ STR : return _ BOOL ; } } return _ BOOL ; }
public static void remove Log Filter (  Log Filter filter ) { if ( filter == null || filters == null || filters . is Empty ( ) ) { return ; } if ( filters . contains ( filter ) ) { filters . remove ( filter ) ; } }
protected void remove Datasets ( int [ ] indices ) { int i ; if ( indices == null ) { m_ Model Datasets . remove All Elements ( ) ; } else { for ( i = indices . length - _ NUM ; i >= _ NUM ; i -- ) m_ Model Datasets . remove ( indices [ i ] ) ; } set Modified ( _ BOOL ) ; }
public void fill Combo Box ( boolean restore ) { if ( restore && m_temp Data != null ) {  Object obj = m_selected Object ; p_data . clear ( ) ; p_data = new  Array List <  Object > ( m_temp Data . length ) ; for ( int i = _ NUM ; i < m_temp Data . length ; i ++ ) p_data . add ( m_temp Data [ i ] ) ; m_temp Data = null ; if ( obj == null && p_data . size ( ) > _ NUM ) obj = p_data . get ( _ NUM ) ; set Selected Item ( obj ) ; fire Contents Changed ( this , _ NUM , p_data . size ( ) ) ; return ; } if ( p_data != null ) fill Combo Box ( is Mandatory ( ) , _ BOOL , _ BOOL , _ BOOL ) ; }
public void remove Assigned Virtual Arrays (  Set <  String > virtual Array URIs ) { if ( ( virtual Array URIs != null ) && ( ! virtual Array URIs . is Empty ( ) ) && ( _assigned Virtual Arrays != null ) ) {  Hash Set <  String > remove Virtual Arrays = new  Hash Set <  String > ( ) ; remove Virtual Arrays . add All ( virtual Array URIs ) ; _assigned Virtual Arrays . remove All ( remove Virtual Arrays ) ; update Virtual Array Tags ( ) ; } }
@  Override public  Env Var add New Env Var (  String name ,  Class < ? > type ,  String value ) {  Env Var env Var = null ; if ( ! exist ( name ) ) { env Var = new  Env Var ( name , type , _ BOOL ) ; env Var . set Value ( value ) ; env Var List . add ( env Var ) ; } return env Var ; }
public void remove From Dragging Connections (  Block root Block ) { if ( m Pending Drag == null ) { return ; } m Temp Connections . clear ( ) ; root Block . get All Connections Recursive ( m Temp Connections ) ; for ( int i = _ NUM ; i < m Temp Connections . size ( ) ; i ++ ) {  Connection conn = m Temp Connections . get ( i ) ; m Dragged Connections . remove ( conn ) ; conn . set Drag Mode ( _ BOOL ) ; } }
public static <  T >  List <  T > as List (  T ... values ) { if ( values == null ) { return new  Array List <  T > ( _ NUM ) ; } else { return new  Array List <  T > (  Arrays . as List ( values ) ) ; } }
private static int [ ] [ ] incidence Matrix (  Graph graph ) throws  Illegal Argument Exception {  List <  Node > nodes = graph . get Nodes ( ) ; int [ ] [ ] m = new int [ nodes . size ( ) ] [ nodes . size ( ) ] ; for (  Edge edge : graph . get Edges ( ) ) { if ( !  Edges . is Directed Edge ( edge ) ) { throw new  Illegal Argument Exception ( _ STR ) ; } } for ( int i = _ NUM ; i < nodes . size ( ) ; i ++ ) { for ( int j = _ NUM ; j < nodes . size ( ) ; j ++ ) {  Node x1 = nodes . get ( i ) ;  Node x2 = nodes . get ( j ) ;  Edge edge = graph . get Edge ( x1 , x2 ) ; if ( edge == null ) { m [ i ] [ j ] = _ NUM ; } else if ( edge . get Proximal Endpoint ( x1 ) ==  Endpoint .  ARROW ) { m [ i ] [ j ] = _ NUM ; } else if ( edge . get Proximal Endpoint ( x1 ) ==  Endpoint .  TAIL ) { m [ i ] [ j ] = - _ NUM ; } } } return m ; }
public boolean do Yes No Dialog (  String title ,  String question ) {  Confirm Dialog confirm = new  Confirm Dialog ( frame , title , question ) ; confirm . set Visible ( _ BOOL ) ; return confirm . get Answer ( ) ; }
public  Pooled Executor With DMStats (  Blocking Queue <  Runnable > q , int pool Size ,  Thread Factory tf ) { this ( q , pool Size , null , tf ) ; }
private void create Pre Streaming Tags ( int timestamp , boolean clear ) { log . debug ( _ STR ) ; if ( clear ) { first Tags . clear ( ) ; }  ITag tag = null ;  Io Buffer body = null ; if ( has Video ) { body =  Io Buffer . allocate ( _ NUM ) ; body . set Auto Expand ( _ BOOL ) ; body . put (  PREFIX_ VIDEO_ CONFIG_ FRAME ) ; if ( video Decoder Bytes != null ) { body . put ( video Decoder Bytes ) ; } tag = new  Tag (  Io Constants .  TYPE_ VIDEO , timestamp , body . position ( ) , null , _ NUM ) ; body . flip ( ) ; tag . set Body ( body ) ; first Tags . add ( tag ) ; } if ( has Audio ) { body =  Io Buffer . allocate ( _ NUM ) ; body . set Auto Expand ( _ BOOL ) ; body . put ( new byte [ ] { ( byte ) _ NUM , ( byte ) _ NUM } ) ; if ( audio Decoder Bytes != null ) { body . put ( audio Decoder Bytes ) ; } else { body . put (  AUDIO_ CONFIG_ FRAME_ AAC_ LC ) ; } body . put ( ( byte ) _ NUM ) ; tag = new  Tag (  Io Constants .  TYPE_ AUDIO , timestamp , body . position ( ) , null , tag . get Body Size ( ) ) ; body . flip ( ) ; tag . set Body ( body ) ; first Tags . add ( tag ) ; } }
public void add Child (  Accessibility Node Info child ) { if ( m Children == null ) { m Children = new  Linked List < > ( ) ; } m Children . add ( child ) ; ( (  Shadow Accessibility Node Info )  Shadow Extractor . extract ( child ) ) . m Parent = m Real Accessibility Node Info ; }
public  String build Union Sub Query (  String type Discriminator Column ,  String [ ] union Columns ,  Set <  String > columns Present In Table , int computed Columns Offset ,  String type Discriminator Value ,  String selection ,  String group By ,  String having ) { int union Columns Count = union Columns . length ;  String [ ] projection In = new  String [ union Columns Count ] ; for ( int i = _ NUM ; i < union Columns Count ; i ++ ) {  String union Column = union Columns [ i ] ; if ( union Column . equals ( type Discriminator Column ) ) { projection In [ i ] = _ STR + type Discriminator Value + _ STR + type Discriminator Column ; } else if ( i <= computed Columns Offset || columns Present In Table . contains ( union Column ) ) { projection In [ i ] = union Column ; } else { projection In [ i ] = _ STR + union Column ; } } return build Query ( projection In , selection , group By , having , null , null ) ; }
@  Override public void clean ( ) { m_storage = null ; m_keys = null ; }
public void consume All ( long timeout ,  Time Unit unit ) throws  Timeout Exception { final long stop Time =  System . current Time Millis ( ) + unit . to Millis ( timeout ) ; while (  System . current Time Millis ( ) < stop Time ) {  Event next Event = queue . poll ( ) ; if ( next Event != null ) {  Testing . print ( _ STR + next Event ) ; consumed Events . accept ( next Event ) ; } } }
protected void parse Command ( final  String ... args ) { if ( args != null ) { for (  String arg : args ) {  Command command =  Command . value Of Name ( arg ) ; if ( command != null ) { set Command ( command ) ; break ; } } } }
public static int rand Exponential ( final int mean ) { return ( int ) ( - mean *  Math . log ( rand . next Double ( ) ) ) ; }
public  DVector ( int c ) { vector = new double [  Math . max ( default Capacity , c ) ] ; }
public void process Invite (  Request Event request Event ,  Server Transaction server Transaction ) { final  Request request = request Event . get Request ( ) ; final  Sip Provider sip Provider = (  Sip Provider ) request Event . get Source ( ) ;  Server Transaction st = server Transaction ; try { if ( st == null ) { st = sip Provider . get New Server Transaction ( request ) ; } sip Provider . get New Dialog ( st ) ; final  String to Tag = _ STR +  System . nano Time ( ) ;  Response response = message Factory . create Response (  Response .  RINGING , request ) ;  To Header to Header = (  To Header ) response . get Header (  To Header .  NAME ) ; to Header . set Tag ( to Tag ) ; st . send Response ( response ) ; response = message Factory . create Response (  Response .  OK , request ) ; final  Address address = address Factory . create Address ( _ STR + my Address + _ STR + my Port + _ STR ) ; final  Contact Header contact Header = header Factory . create Contact Header ( address ) ; response . add Header ( contact Header ) ; to Header = (  To Header ) response . get Header (  To Header .  NAME ) ; to Header . set Tag ( to Tag ) ; st . send Response ( response ) ; } catch (  Exception ex ) { ex . print Stack Trace ( ) ; } }
public  Grid Tcp Rest Nio Listener (  Ignite Logger log ,  Grid Tcp Rest Protocol proto ,  Grid Rest Protocol Handler hnd ,  Grid Kernal Context ctx ) { memcached Lsnr = new  Grid Tcp Memcached Nio Listener ( log , hnd , ctx ) ; this . log = log ; this . proto = proto ; this . hnd = hnd ; }
protected boolean read Num Input Bits ( ) { try { input Bits =  Integer . parse Int ( num Input Field . get Text ( ) ) ; } catch (  Exception e ) { status Text1 . set Text ( rb . get String ( _ STR ) ) ; status Text1 . set Visible ( _ BOOL ) ; input Bits = _ NUM ; error In Status1 = _ BOOL ; reset Notes2 ( ) ; return ( _ BOOL ) ; } if ( input Bits <= _ NUM ) { status Text1 . set Text ( rb . get String ( _ STR ) ) ; status Text1 . set Visible ( _ BOOL ) ; input Bits = _ NUM ; error In Status1 = _ BOOL ; reset Notes2 ( ) ; return ( _ BOOL ) ; } if ( input Bits > _ NUM ) { status Text1 . set Text ( rb . get String ( _ STR ) ) ; status Text1 . set Visible ( _ BOOL ) ; input Bits = _ NUM ; error In Status1 = _ BOOL ; reset Notes2 ( ) ; return ( _ BOOL ) ; } return _ BOOL ; }
public double [ ] draw Transition Times ( double time Duration , int total Number Of Changes ) { double [ ] times = new double [ total Number Of Changes ] ; for ( int i = _ NUM ; i < total Number Of Changes ; i ++ ) { times [ i ] = time Duration *  Math Utils . next Double ( ) ; } if ( times . length > _ NUM ) {  Arrays . sort ( times ) ; } return times ; }
public static int as Int (  String value , int default Value ) { if ( value != null ) { try { return  Integer . parse Int ( value ) ; } catch (  Number Format Exception e ) { } } return default Value ; }
@  Override public boolean equals (  Object obj ) { if ( this == obj ) { return _ BOOL ; } if ( obj == null ) { return _ BOOL ; } if ( get Class ( ) != obj . get Class ( ) ) { return _ BOOL ; }  Alert item = (  Alert ) obj ; if ( risk != item . risk ) { return _ BOOL ; } if ( confidence != item . confidence ) { return _ BOOL ; } if ( plugin Id != item . plugin Id ) { return _ BOOL ; } if ( ! name . equals ( item . name ) ) { return _ BOOL ; } if ( ! method . equals Ignore Case ( item . method ) ) { return _ BOOL ; } if ( ! uri . equals Ignore Case ( item . uri ) ) { return _ BOOL ; } if ( ! param . equals Ignore Case ( item . param ) ) { return _ BOOL ; } if ( ! other Info . equals Ignore Case ( item . other Info ) ) { return _ BOOL ; } if ( evidence == null ) { if ( item . evidence != null ) { return _ BOOL ; } } else if ( ! evidence . equals ( item . evidence ) ) { return _ BOOL ; } if ( attack == null ) { if ( item . attack != null ) { return _ BOOL ; } } else if ( ! attack . equals ( item . attack ) ) { return _ BOOL ; } return _ BOOL ; }
private boolean unseen Node (  Node candidate ) { if ( candidate != null && ! already Seen . contains ( candidate ) ) { current = candidate ; already Seen . add ( current ) ; return _ BOOL ; } return _ BOOL ; }
@  Override public boolean on Touch Event (  Motion Event event ) { if ( ! is Enabled ( ) ) return _ BOOL ; int pointer Index ; final int action = event . get Action ( ) ; switch ( action &  Motion Event .  ACTION_ MASK ) { case  Motion Event .  ACTION_ DOWN : m Active Pointer Id = event . get Pointer Id ( event . get Pointer Count ( ) - _ NUM ) ; pointer Index = event . find Pointer Index ( m Active Pointer Id ) ; m Down Motion X = event . get X ( pointer Index ) ; pressed Thumb = eval Pressed Thumb ( m Down Motion X ) ; if ( pressed Thumb == null ) return super . on Touch Event ( event ) ; set Pressed ( _ BOOL ) ; invalidate ( ) ; on Start Tracking Touch ( ) ; track Touch Event ( event ) ; attempt Claim Drag ( ) ; break ; case  Motion Event .  ACTION_ MOVE : if ( pressed Thumb != null ) { if ( m Is Dragging ) { track Touch Event ( event ) ; } else { pointer Index = event . find Pointer Index ( m Active Pointer Id ) ; final float x = event . get X ( pointer Index ) ; if (  Math . abs ( x - m Down Motion X ) > m Scaled Touch Slop ) { set Pressed ( _ BOOL ) ; invalidate ( ) ; on Start Tracking Touch ( ) ; track Touch Event ( event ) ; attempt Claim Drag ( ) ; } } if ( notify While Dragging && listener != null ) { listener . on Range Seek Bar Values Changed ( this , get Selected Min Value ( ) , get Selected Max Value ( ) ) ; } } break ; case  Motion Event .  ACTION_ UP : if ( m Is Dragging ) { track Touch Event ( event ) ; on Stop Tracking Touch ( ) ; set Pressed ( _ BOOL ) ; } else { on Start Tracking Touch ( ) ; track Touch Event ( event ) ; on Stop Tracking Touch ( ) ; } pressed Thumb = null ; invalidate ( ) ; if ( listener != null ) { listener . on Range Seek Bar Values Changed ( this , get Selected Min Value ( ) , get Selected Max Value ( ) ) ; } break ; case  Motion Event .  ACTION_ POINTER_ DOWN : { final int index = event . get Pointer Count ( ) - _ NUM ; m Down Motion X = event . get X ( index ) ; m Active Pointer Id = event . get Pointer Id ( index ) ; invalidate ( ) ; break ; } case  Motion Event .  ACTION_ POINTER_ UP : on Secondary Pointer Up ( event ) ; invalidate ( ) ; break ; case  Motion Event .  ACTION_ CANCEL : if ( m Is Dragging ) { on Stop Tracking Touch ( ) ; set Pressed ( _ BOOL ) ; } invalidate ( ) ; break ; } return _ BOOL ; }
public synchronized void add Batch Clusterer Listener (  Batch Clusterer Listener cl ) { m_batch Clusterer Listeners . add Element ( cl ) ; }
public  Held Locks Token refresh ( long expiration Date Ms ) { return new  Held Locks Token ( token Id , client , creation Date Ms , expiration Date Ms , lock Map , lock Timeout , version Id ) ; }
void add Known Object (  Parse Object object ) { synchronized ( mutex ) { known Objects . add ( object ) ; } }
static  Bytes Store < ? ,  Byte Buffer > wrap ( @  Not Null  Byte Buffer bb ) { return bb . is Direct ( ) ?  Native Bytes Store . wrap ( bb ) :  Heap Bytes Store . wrap ( bb ) ; }
public static  File generate Content Path (  Context context ,  String type ) { if ( context == null ) { return null ; }  File base = context . get External Files Dir ( type ) ; if ( base == null ) { return null ; } if ( ! base . exists ( ) ) { if ( ! base . mkdirs ( ) ) { return null ; } } return base ; }
public void before Insert ( int index , short element ) { if ( index > size || index < _ NUM ) throw new  Index Out Of Bounds Exception ( _ STR + index + _ STR + size ) ; ensure Capacity ( size + _ NUM ) ;  System . arraycopy ( elements , index , elements , index + _ NUM , size - index ) ; elements [ index ] = element ; size ++ ; }
public void clear ( ) {  Grid Unsafe . copy Memory ( spine Empty ,  INT_ ARR_ OFF , spine ,  INT_ ARR_ OFF , spine Empty . length << _ NUM ) ;  Grid Unsafe . copy Memory ( next Empty ,  INT_ ARR_ OFF , next ,  INT_ ARR_ OFF , next Empty . length << _ NUM ) ;  Arrays . fill ( objs , null ) ; size = _ NUM ; }
public  Sided Plane ( final  Vector p , final  Vector  A , final  Vector  B ) { super (  A ,  B ) ; sig Num =  Math . signum ( evaluate ( p ) ) ; if ( sig Num == _ NUM ) throw new  Illegal Argument Exception ( _ STR ) ; }
public static void clear ( ) { if ( ( auth Ctx Obj Hash != null ) && ( ! auth Ctx Obj Hash . is Empty ( ) ) ) { auth Ctx Obj Hash . clear ( ) ; } if ( ( auth Context Hash != null ) && ( ! auth Context Hash . is Empty ( ) ) ) { auth Context Hash . clear ( ) ; } }
public static void register Reportable Object (  Reportable obj ) { report Objects . add ( obj ) ; }
public static void assert End Of Output Expected To Contain (  String end Marker ,  String expected String ,  File log ) {  String r = read Logfile ( log ) ; int idx = r . index Of ( end Marker ) ; if ( idx == - _ NUM ) fail ( _ STR + end Marker + _ STR + expected String + _ STR ) ;  String x = r . substring ( idx ) ; assert Expected Output Contains ( expected String , x ) ; }
public boolean add (  String classname ) {  String pkgname ;  Hash Set <  String > names ; classname = clean Up ( classname ) ; pkgname = extract Package ( classname ) ; if ( ! m_ Cache . contains Key ( pkgname ) ) { m_ Cache . put ( pkgname , new  Hash Set <  String > ( ) ) ; } names = m_ Cache . get ( pkgname ) ; return names . add ( classname ) ; }
public void test Completed Stage ( ) {  Atomic Integer x = new  Atomic Integer ( _ NUM ) ;  Atomic Reference <  Throwable > r = new  Atomic Reference <  Throwable > ( ) ;  Completion Stage <  Integer > f =  Completable Future . completed Stage ( _ NUM ) ; f . when Complete ( null ) ; assert Equals ( x . get ( ) , _ NUM ) ; assert Null ( r . get ( ) ) ; }
@  Override public void paint Component (  Graphics g ) { super . paint Component ( g ) ;  Graphics2 D graphics = (  Graphics2 D ) g ; graphics . set Background ( m Color Spectrum Background ) ; graphics . set Rendering Hints (  RENDERING_ HINTS ) ; draw Frequencies ( graphics ) ; draw Channels ( graphics ) ; draw Cursor ( graphics ) ; }
public void class Loader Destroy (  Dynamic Class Loader loader ) {  Object resource = _resource Ref . get ( ) ; if ( resource == null ) return ;  Method destroy =  Close Listener . get Destroy Method ( resource . get Class ( ) ) ; if ( destroy == null ) return ; try { destroy . invoke ( resource , (  Object [ ] ) null ) ; } catch (  Throwable e ) { log . log (  Level .  WARNING , e . to String ( ) , e ) ; } }
public boolean delete Attachment Point ( long sw , short port ) {  Attachment Point ap = new  Attachment Point ( sw , port , _ NUM ) ; if ( this . old APs != null ) {  Array List <  Attachment Point > ap List = new  Array List <  Attachment Point > ( ) ; ap List . add All ( this . old APs ) ; int index = ap List . index Of ( ap ) ; if ( index > _ NUM ) { ap List . remove ( index ) ; this . old APs = ap List ; } } if ( this . attachment Points != null ) {  Array List <  Attachment Point > ap List = new  Array List <  Attachment Point > ( ) ; ap List . add All ( this . attachment Points ) ; int index = ap List . index Of ( ap ) ; if ( index > _ NUM ) { ap List . remove ( index ) ; this . attachment Points = ap List ; return _ BOOL ; } } return _ BOOL ; }
public boolean is Primitive (  Class type ) throws  Exception { if ( type ==  String . class ) { return _ BOOL ; } if ( type ==  Float . class ) { return _ BOOL ; } if ( type ==  Double . class ) { return _ BOOL ; } if ( type ==  Long . class ) { return _ BOOL ; } if ( type ==  Integer . class ) { return _ BOOL ; } if ( type ==  Boolean . class ) { return _ BOOL ; } if ( type . is Enum ( ) ) { return _ BOOL ; } if ( type . is Primitive ( ) ) { return _ BOOL ; } return transform . valid ( type ) ; }
public synchronized long total Recover Bytes ( ) { long total = _ NUM ; for (  File file : file Details . values ( ) ) { if ( file . reused ( ) == _ BOOL ) { total += file . length ( ) ; } } return total ; }
@  Override @  Timed public  Assignment assign User (  Assignment assignment ,  Experiment experiment ,  Date date ) {  Assignment new_assignment = null ; if ( assign User To Old ) { new_assignment = assign User To Old ( assignment , date ) ; } if ( assign User To New ) { new_assignment = assign User To Look Up ( assignment , date ) ; } boolean count Up = _ BOOL ; assignments Count Executor . execute ( new  Assignment Count Envelope ( assignments Repository , experiment Repository , db Repository , experiment , assignment , count Up , event Log , date , assign User To Export , assign Bucket Count ) ) ; index User To Experiment ( assignment ) ; index User To Bucket ( assignment ) ; index Experiments To User ( assignment ) ; return new_assignment ; }
public static  List < ? > clone List (  List < ? > source ) {  Param Checks . null Not Permitted ( source , _ STR ) ;  List result = new  Array List ( ) ; for (  Object obj : source ) { if ( obj != null ) { try { result . add (  Object Utilities . clone ( obj ) ) ; } catch (  Clone Not Supported Exception ex ) { throw new  Runtime Exception ( ex ) ; } } else { result . add ( null ) ; } } return result ; }
public void thread Dump ( ) { if ( can Dump Locks ) { if ( tmbean . is Object Monitor Usage Supported ( ) && tmbean . is Synchronizer Usage Supported ( ) ) { dump Thread Info With Locks ( ) ; } } else { dump Thread Info ( ) ; } }
private void check Stop ( ) { if ( m Can Process Audio && m Output . is Running ( ) && m Output . available ( ) >= m Buffer Stop Threshold ) { m Output . drain ( ) ; m Output . stop ( ) ; } }
private boolean matches Entity Type Filter (  Metadata Reader reader ,  Metadata Reader Factory reader Factory ) throws  IOException { for (  Type Filter filter :  ENTITY_ TYPE_ FILTERS ) { if ( filter . match ( reader , reader Factory ) ) { return _ BOOL ; } } return _ BOOL ; }
public static void create Project (  String qualified Module Name ,  String out Dir ,  Gwt Sdk gwt Runtime ,  IProgress Monitor monitor ,  String [ ] extra Class Path ,  String ... templates ) throws  Core Exception { try { int process Status =  Process Utilities . launch Process And Wait For ( compute Web App Creator Command Line ( qualified Module Name , out Dir , gwt Runtime , templates , extra Class Path ) , null ,  System . out , null ) ; if ( process Status != _ NUM ) { throw new  Core Exception ( new  Status (  IStatus .  ERROR ,  GWTPlugin .  PLUGIN_ ID , _ STR + compute Web App Creator Class Name ( ) + _ STR ) ) ; } } catch (  IOException e ) { throw new  Core Exception ( new  Status (  IStatus .  ERROR ,  GWTPlugin .  PLUGIN_ ID , e . get Localized Message ( ) , e ) ) ; } catch (  Interrupted Exception e ) { throw new  Core Exception ( new  Status (  IStatus .  ERROR ,  GWTPlugin .  PLUGIN_ ID , e . get Localized Message ( ) , e ) ) ; } }
public boolean has Invoices ( ) { boolean ret Value = _ BOOL ;  String sql = _ STR ;  Prepared Statement pstmt = null ; try { pstmt =  DB . prepare Statement ( sql , get_ Trx Name ( ) ) ; pstmt . set Int ( _ NUM , get_ ID ( ) ) ;  Result Set rs = pstmt . execute Query ( ) ; if ( rs . next ( ) ) { if ( rs . get Int ( _ NUM ) > _ NUM ) ret Value = _ BOOL ; } rs . close ( ) ; pstmt . close ( ) ; pstmt = null ; } catch (  Exception e ) { s_log . log (  Level .  SEVERE , sql , e ) ; } try { if ( pstmt != null ) pstmt . close ( ) ; pstmt = null ; } catch (  Exception e ) { pstmt = null ; } return ret Value ; }
private static  String unqualify (  String path ) { path = path . replace ( _ STR , _ STR ) ; return path . substring ( path . last Index Of ( _ STR ) + _ NUM ) ; }
@  Before Class public static void init JFX ( ) { if ( t == null ) { t = new  Thread ( null ) ; t . set Daemon ( _ BOOL ) ; t . start ( ) ; } }
public  Css Filter Rule (  String rule Text ) { super ( rule Text ) ;  String mask ; boolean style Inject = _ BOOL ; boolean white List Rule = _ BOOL ; if (  String Utils . contains ( rule Text ,  MASK_ CSS_ INJECT_ EXCEPTION_ RULE ) ) { mask =  MASK_ CSS_ INJECT_ EXCEPTION_ RULE ; white List Rule = _ BOOL ; style Inject = _ BOOL ; } else if (  String Utils . contains ( rule Text ,  MASK_ CSS_ INJECT_ RULE ) ) { mask =  MASK_ CSS_ INJECT_ RULE ; style Inject = _ BOOL ; } else if (  String Utils . contains ( rule Text ,  MASK_ CSS_ EXCEPTION_ RULE ) ) { mask =  MASK_ CSS_ EXCEPTION_ RULE ; white List Rule = _ BOOL ; } else if (  String Utils . contains ( rule Text ,  MASK_ CSS_ RULE ) ) { mask =  MASK_ CSS_ RULE ; } else { throw new  Illegal Argument Exception ( _ STR ) ; } int index Of Mask =  String Utils . index Of ( rule Text , mask ) ; if ( index Of Mask > _ NUM ) {  String domains =  String Utils . substring ( rule Text , _ NUM , index Of Mask ) ; load Domains ( domains ) ; } this . style Inject = style Inject ; this . white List Rule = white List Rule ; css Content = rule Text . substring ( index Of Mask + mask . length ( ) ) ; }
private static void expand Path ( final  Evidence Builder fs Log , final  String path , final int depth , boolean save First ) { if (  Cfg .  DEBUG ) {  Check . requires ( depth > _ NUM , _ STR ) ; } if (  Cfg .  DEBUG ) {  Check . requires ( path != null , _ STR ) ; } if (  Cfg .  DEBUG ) {  Check . requires ( path == _ STR || ! path . ends With ( _ STR ) , _ STR ) ; } if (  Cfg .  DEBUG ) {  Check . requires ( ! path . ends With ( _ STR ) , _ STR ) ; } if (  Cfg .  DEBUG ) {  Check . log (  TAG + _ STR + path + _ STR + depth ) ; } final  File dir = new  File ( path ) ; if ( dir . is Directory ( ) ) { if ( save First ) {  Protocol . save Filesystem Log ( fs Log , path ) ; } final  String [ ] files = dir . list ( ) ; if ( files == null ) { return ; } for ( final  String file : files ) {  String d Path = path + _ STR + file ; if ( d Path . starts With ( _ STR ) ) { d Path = d Path . substring ( _ NUM ) ; } if ( d Path . index Of (  String Utils . chomp (  Path . hidden ( ) , _ STR ) ) >= _ NUM ) { if (  Cfg .  DEBUG ) {  Check . log (  TAG + _ STR + _ STR + d Path ) ; } continue ; } if ( ! black List Dir . contains ( d Path ) ) { final boolean is Dir =  Protocol . save Filesystem Log ( fs Log , d Path ) ; if ( is Dir && depth > _ NUM ) { expand Path ( fs Log , d Path , depth - _ NUM , _ BOOL ) ; } } else { if (  Cfg .  DEBUG ) {  Check . log (  TAG + _ STR , d Path ) ; } } } } }
private void need New Buffer ( int newcount ) { if ( current Buffer Index < buffers . size ( ) - _ NUM ) { filled Buffer Sum += current Buffer . length ; current Buffer Index ++ ; current Buffer = buffers . get ( current Buffer Index ) ; } else { int new Buffer Size ; if ( current Buffer == null ) { new Buffer Size = newcount ; filled Buffer Sum = _ NUM ; } else { new Buffer Size =  Math . max ( current Buffer . length << _ NUM , newcount - filled Buffer Sum ) ; filled Buffer Sum += current Buffer . length ; } current Buffer Index ++ ; current Buffer = new byte [ new Buffer Size ] ; buffers . add ( current Buffer ) ; } }
public org . mozilla . javascript .  Scriptable generate JStype ( final  String text String , final boolean return As String ) { if ( return As String ) { return cx . new Object ( scope , _ STR , new  Object [ ] { text String } ) ; } else { if ( text String != null && ! text String . is Empty ( ) &&  String Utils . is Number ( text String ) && ! ( text String . length ( ) == _ NUM && text String . index Of ( _ STR ) != - _ NUM ) ) { final  Double ret Num =  Double . value Of ( text String ) ; return cx . new Object ( scope , _ STR , new  Object [ ] { ret Num } ) ; } else { return cx . new Object ( scope , _ STR , new  Object [ ] { text String } ) ; } } }
@  Override public boolean truncate (  String file Name , long valid Data End Offset ) {  Data Output Stream data Output Stream = null ;  Data Input Stream data Input Stream = null ; boolean file Truncated Successfully = _ BOOL ; int buffer Size = valid Data End Offset >  Carbon Common Constants .  BYTE_ TO_ KB_ CONVERSION_ FACTOR ?  Carbon Common Constants .  BYTE_ TO_ KB_ CONVERSION_ FACTOR : ( int ) valid Data End Offset ;  String temp Write File Path = file Name +  Carbon Common Constants .  TEMPWRITEFILEEXTENSION ;  File Factory .  File Type file Type =  File Factory . get File Type ( file Name ) ; try {  Carbon File temp File = null ; if (  File Factory . is File Exist ( temp Write File Path , file Type ) ) { temp File =  File Factory . get Carbon File ( temp Write File Path , file Type ) ; temp File . delete ( ) ; }  File Factory . create New File ( temp Write File Path , file Type ) ; temp File =  File Factory . get Carbon File ( temp Write File Path , file Type ) ; byte [ ] buff = new byte [ buffer Size ] ; data Input Stream =  File Factory . get Data Input Stream ( file Name , file Type ) ; int read = data Input Stream . read ( buff , _ NUM , buff . length ) ; data Output Stream =  File Factory . get Data Output Stream ( temp Write File Path , file Type ) ; data Output Stream . write ( buff , _ NUM , read ) ; long remaining = valid Data End Offset - read ; while ( remaining > _ NUM ) { if ( remaining > buffer Size ) { buff = new byte [ buffer Size ] ; } else { buff = new byte [ ( int ) remaining ] ; } read = data Input Stream . read ( buff , _ NUM , buff . length ) ; data Output Stream . write ( buff , _ NUM , read ) ; remaining = remaining - read ; }  Carbon Util . close Streams ( data Input Stream , data Output Stream ) ; temp File . rename Force ( file Name ) ; file Truncated Successfully = _ BOOL ; } catch (  IOException e ) {  LOGGER . error ( _ STR + e . get Message ( ) ) ; } finally {  Carbon Util . close Streams ( data Output Stream , data Input Stream ) ; } return file Truncated Successfully ; }
private final  Styled String append Parameter Signature (  Styled String buffer , char [ ] [ ] parameter Types , char [ ] [ ] parameter Names ) { if ( parameter Types != null ) { for ( int i = _ NUM ; i < parameter Types . length ; i ++ ) { if ( i > _ NUM ) { buffer . append ( _ STR ) ; buffer . append ( _ STR ) ; } buffer . append ( parameter Types [ i ] ) ; if ( parameter Names != null && parameter Names [ i ] != null ) { buffer . append ( _ STR ) ; buffer . append ( parameter Names [ i ] ) ; } } } return buffer ; }
public void start Heartbeat (  Database database ,  String name ) throws  SQLException {  Array List <  Column > where Clause = new  Array List <  Column > ( ) ;  Array List <  Column > values = new  Array List <  Column > ( ) ;  Timestamp now = new  Timestamp (  System . current Time Millis ( ) ) ; if ( logger . is Debug Enabled ( ) ) logger . debug ( _ STR + name + _ STR + now ) ; hb Id . set Value (  KEY ) ; where Clause . add ( hb Id ) ; hb Source Tstamp . set Value ( now ) ; hb Salt . set Value ( salt Value . get And Increment ( ) ) ; hb Name . set Value ( name ) ; values . add ( hb Source Tstamp ) ; values . add ( hb Salt ) ; values . add ( hb Name ) ; database . update ( hb Table , where Clause , values ) ; }
public  Cipher Parameters encrypt ( byte [ ] out , int out Off , int key Len ) throws  Illegal Argument Exception { if ( key . is Private ( ) ) { throw new  Illegal Argument Exception ( _ STR ) ; }  Big Integer n = key . get Modulus ( ) ;  Big Integer e = key . get Exponent ( ) ;  Big Integer r =  Big Integers . create Random In Range (  ZERO , n . subtract (  ONE ) , rnd ) ;  Big Integer c = r . mod Pow ( e , n ) ; byte [ ]  C =  Big Integers . as Unsigned Byte Array ( ( n . bit Length ( ) + _ NUM ) / _ NUM , c ) ;  System . arraycopy (  C , _ NUM , out , out Off ,  C . length ) ; return generate Key ( n , r , key Len ) ; }
public  Public Key load Public Key ( int id ) throws  Exception { if ( default Keys ) { return get Public Key From String (  RSAKey Loader .  DEFAULT_ UKEY ) ; }  File Reader f = new  File Reader ( path + _ STR + id ) ;  Buffered Reader r = new  Buffered Reader ( f ) ;  String tmp = _ STR ;  String key = _ STR ; while ( ( tmp = r . read Line ( ) ) != null ) { key = key + tmp ; } f . close ( ) ; r . close ( ) ;  Public Key ret = get Public Key From String ( key ) ; return ret ; }
public void add Categories Listener (  Snapshot Categories Listener listener ) { listeners . add ( listener ) ; }
public  Array List <  Integer > mutate (  Array List <  Integer > genome ) {  Array List <  Integer > result = new  Array List <  Integer > ( this . genome Length ) ; for (  Integer integer : genome ) { result . add ( integer ) ; } for ( int i = _ NUM ; i < number Of Mutations To Mutant ; i ++ ) {  Array List <  Integer > strip = permutator . permutate ( genome Length ) ; int pos1 = strip . get ( _ NUM ) - _ NUM ; int pos2 = strip . get ( _ NUM ) - _ NUM ;  Collections . swap ( result , pos1 , pos2 ) ; } return result ; }
public static int [ ] string To Int Array (  String str ) { if ( str == null ) { return ( null ) ; }  String [ ] array = str . split ( _ STR ) ; if ( array . length == _ NUM ) { array = new  String [ ] { str . trim ( ) } ; } int [ ] n Array = new int [ array . length ] ; for ( int i = _ NUM ; i < n Array . length ; ++ i ) { n Array [ i ] =  Integer . parse Int ( array [ i ] ) ; } return ( n Array ) ; }
@  Override public void run ( ) { _log . info ( _ STR ) ; try { if ( ! _call Home Event Manager . can Send Event ( ) ) { return ; } int total Sleep = _ NUM ; while ( _ BOOL ) { if ( _license Manager . get Target Info Lock ( ) ) { try { perform Send Events ( ) ; } catch (  Exception e ) { _log . error ( _ STR , e ) ; break ; } finally { _license Manager . release Target Version Lock ( ) ; } break ; } else { _log . info ( _ STR ) ; if ( total Sleep >=  Call Home Constants .  MAX_ LOCK_ WAIT_ TIME_ MS ) { _log . warn ( _ STR ,  Call Home Constants .  MAX_ LOCK_ WAIT_ TIME_ MS ) ; break ; }  Thread . sleep (  Call Home Constants .  LOCK_ WAIT_ TIME_ MS ) ; total Sleep +=  Call Home Constants .  LOCK_ WAIT_ TIME_ MS ; } } } catch (  APIException i ) { _log . info ( _ STR ) ; } catch (  Exception e ) { _log . error ( _ STR , e ) ; } _log . info ( _ STR ) ; }
static  Class Loader create Loader ( ) {  List <  URL > urls = new  Array List < > ( ) ; for (  String name : new  String [ ] { _ STR , _ STR } ) {  String value =  System . get Property ( name ) ; if ( value != null ) { add URLs From Path ( urls , value ) ; } } for ( int i = _ NUM ; add Patch Paths ( urls , i ) ; i ++ ) { } return new  URLClass Loader ( urls . to Array ( new  URL [ urls . size ( ) ] ) ) ; }
public void inline Image (  Rendered Image image ,  Color bkg ,  String encode ) throws  IOException {  Image Bytes bytes = new  Image Bytes ( image , bkg ,  Image Constants .  JPG ,  Image Constants .  COLOR_ MODEL_ RGB ) ; println ( _ STR ) ; image Info ( _ STR , image . get Width ( ) ) ; image Info ( _ STR , image . get Height ( ) ) ; image Info ( _ STR , pdf . name ( _ STR ) ) ; image Info ( _ STR , _ NUM ) ; image Info ( _ STR , get Filter Name ( bytes . get Format ( ) ) ) ; print ( _ STR ) ; write ( bytes . get Bytes ( ) ) ; println ( _ STR ) ; }
public  List <  Object > ids By DFSFinish Time ( boolean increasing ) { if ( ! initialized ) { throw new  Illegal Argument Exception ( ) ; } int len = vertex List . size ( ) ;  Object [ ] r = new  Object [ len ] ; for (  Iterator <  Vertex > all V = vertex List . iterator ( ) ; all V . has Next ( ) ; ) {  Vertex vertex = all V . next ( ) ; int f = vertex . finish Time ; if ( increasing ) { r [ f - _ NUM ] = vertex . id ; } else { r [ len - f ] = vertex . id ; } } return  Arrays . as List ( r ) ; }
@  Override public boolean write Logs (  String container ,  Output Stream output ) throws  IOException { try {  Process executed Process = follow Logs ( container ) ;  IOUtils . copy ( executed Process . get Input Stream ( ) , output ) ; executed Process . wait For (  COMMAND_ TIMEOUT . get Millis ( ) ,  MILLISECONDS ) ; } catch (  Interrupted Exception e ) { return _ BOOL ; } return _ BOOL ; }
private static int index Of ( int from Index ,  Char Sequence csq ) { if ( csq == null ) return _ NUM ; int length = csq . length ( ) ; int j = from Index ; int i = ( j < length ) ?  Character . to Upper Case ( csq . char At ( j ++ ) ) : _ NUM ; i <<= _ NUM ; i |= ( j < length ) ?  Character . to Upper Case ( csq . char At ( j ++ ) ) : _ NUM ; return i ; }
protected  Size Requirements calculate Minor Axis Requirements ( int axis ,  Size Requirements r ) { if ( r == null ) { r = new  Size Requirements ( ) ; } float pref = layout Pool . get Preferred Span ( axis ) ; float min = layout Pool . get Minimum Span ( axis ) ; r . minimum = ( int ) min ; r . preferred =  Math . max ( r . minimum , ( int ) pref ) ; r . maximum =  Integer .  MAX_ VALUE ; r . alignment = _ NUM ; return r ; }
private  String as Reg Pattern (  String string ) {  String Buffer out = new  String Buffer ( string . length ( ) ) ; for ( int i = _ NUM , length = string . length ( ) ; i < length ; i ++ ) { char ch = string . char At ( i ) ; if ( ch == _ STR ) { out . append ( _ STR ) ; } else if ( ch == _ STR ) { out . append ( _ STR ) ; } else { out . append ( ch ) ; } } return out . to String ( ) ; }
public static  Function from String (  String name ) { if ( name != null ) { for (  Function func :  Function . values ( ) ) { if ( name . equals Ignore Case ( func . get Name ( ) ) ) { return func ; } } } throw new  Illegal Argument Exception ( name ) ; }
private  Cluster <  Dendrogram Model > make Cluster (  DBIDRef lead , double depth ,  DBIDs members ) { final  String name ; if ( members . size ( ) == _ NUM ) { name = _ STR +  DBIDUtil . to String ( lead ) + _ STR + depth ; } else if ( !  Double . is Na N ( depth ) &&  Double . is Infinite ( depth ) || ( members . size ( ) == _ NUM && members . contains ( lead ) ) ) { name = _ STR +  DBIDUtil . to String ( lead ) ; } else if ( !  Double . is Na N ( depth ) ) { name = _ STR +  DBIDUtil . to String ( lead ) + _ STR + depth ; } else { name = _ STR +  DBIDUtil . to String ( lead ) ; }  Cluster <  Dendrogram Model > cluster = new  Cluster < > ( name , members , new  Dendrogram Model ( depth ) ) ; return cluster ; }
public  Table sort On (  String ... column Names ) {  Sort key = null ;  Order order ;  List <  String > names = new  Array List < > ( ) ; for (  String name : column Names ( ) ) { names . add ( name . to Upper Case ( ) ) ; } for (  String column Name : column Names ) { if ( names . contains ( column Name . to Upper Case ( ) ) ) { order =  Order .  ASCEND ; } else {  String prefix = column Name . substring ( _ NUM , _ NUM ) ; column Name = column Name . substring ( _ NUM , column Name . length ( ) ) ; switch ( prefix ) { case _ STR : order =  Order .  ASCEND ; break ; case _ STR : order =  Order .  DESCEND ; break ; default : throw new  Illegal State Exception ( _ STR + prefix + _ STR ) ; } } if ( key == null ) { key = first ( column Name , order ) ; } else { key . next ( column Name , order ) ; } } return sort On ( key ) ; }
protected void initialize Data Extends (  Relation <  Number Vector > relation , int dim , double [ ] min , double [ ] extend ) { assert ( min . length == dim && extend . length == dim ) ; if ( minima == null || maxima == null || minima . length == _ NUM || maxima . length == _ NUM ) { double [ ] [ ] minmax =  Relation Util . compute Min Max ( relation ) ; final double [ ] dmin = minmax [ _ NUM ] , dmax = minmax [ _ NUM ] ; for ( int d = _ NUM ; d < dim ; d ++ ) { min [ d ] = dmin [ d ] ; extend [ d ] = dmax [ d ] - dmin [ d ] ; } return ; } if ( minima . length == dim ) {  System . arraycopy ( minima , _ NUM , min , _ NUM , dim ) ; } else if ( minima . length == _ NUM ) {  Arrays . fill ( min , minima [ _ NUM ] ) ; } else { throw new  Abort Exception ( _ STR + dim + _ STR + minima . length ) ; } if ( maxima . length == dim ) { for ( int d = _ NUM ; d < dim ; d ++ ) { extend [ d ] = maxima [ d ] - min [ d ] ; } return ; } else if ( maxima . length == _ NUM ) { for ( int d = _ NUM ; d < dim ; d ++ ) { extend [ d ] = maxima [ _ NUM ] - min [ d ] ; } return ; } else { throw new  Abort Exception ( _ STR + dim + _ STR + maxima . length ) ; } }
protected  Array List < float [ ] > _forward Poly ( double [ ] rawllpts , int ltype , int nsegs , boolean is Filled ) { boolean  DEBUG =  Debug . debugging ( _ STR ) ; int len = rawllpts . length > > > _ NUM ; if ( len < _ NUM ) return new  Array List < float [ ] > ( _ NUM ) ; if ( is Complicated Line Type ( ltype ) ) return do Poly Dispatch ( rawllpts , ltype , nsegs , is Filled ) ; int invalid_count = _ NUM ; boolean curr_invalid , prev_invalid = _ BOOL ;  Point temp = new  Point ( ) ;  Azimuth Var az_first = null , az_save = null , az Var = new  Azimuth Var ( ) ;  Array List <  Azimuth Var > sections = new  Array List <  Azimuth Var > ( _ NUM ) ; float [ ] x_ , xs = new float [ len ] ; float [ ] y_ , ys = new float [ len ] ; _forward ( rawllpts [ _ NUM ] , rawllpts [ _ NUM ] , temp , az Var ) ; xs [ _ NUM ] = temp . x ; ys [ _ NUM ] = temp . y ; prev_invalid = az Var . invalid_forward ; if ( prev_invalid ) { ++ invalid_count ; } else { az Var . index = _ NUM ; az Var . current_azimuth = ( float )  Great Circle . spherical Azimuth ( center Y , center X , rawllpts [ _ NUM ] , rawllpts [ _ NUM ] ) ; if ( ! is Filled ) { sections . add ( az Var ) ; } else { az_first = az Var ; } az Var = new  Azimuth Var ( ) ; } int i = _ NUM , j = _ NUM ; for ( i = _ NUM , j = _ NUM ; i < len ; i ++ , j += _ NUM ) { az Var . invalid_forward = _ BOOL ; _forward ( rawllpts [ j ] , rawllpts [ j + _ NUM ] , temp , az Var ) ; curr_invalid = az Var . invalid_forward ; xs [ i ] = temp . x ; ys [ i ] = temp . y ; if ( ! curr_invalid && prev_invalid ) { az Var . index = i - _ NUM ; az Var . current_azimuth = ( float )  Great Circle . spherical Azimuth ( center Y , center X , rawllpts [ j - _ NUM ] , rawllpts [ j - _ NUM ] ) ; sections . add ( az Var ) ; az Var = new  Azimuth Var ( ) ; } else if ( curr_invalid ) { if ( ! prev_invalid ) { az Var . index = i ; if ( is Filled && ( invalid_count == _ NUM ) ) { az_save = az Var ; } else { sections . add ( az Var ) ; } az Var = new  Azimuth Var ( ) ; } ++ invalid_count ; } prev_invalid = curr_invalid ; } if ( invalid_count == _ NUM ) {  Array List < float [ ] > ret_val = new  Array List < float [ ] > ( _ NUM ) ; ret_val . add ( xs ) ; ret_val . add ( ys ) ; return ret_val ; } if ( invalid_count == len ) { return new  Array List < float [ ] > ( _ NUM ) ; } if ( ! prev_invalid ) { if ( is Filled && ( az_save != null ) ) { int l = az_save . index ; x_ = new float [ len + l ] ; y_ = new float [ len + l ] ;  System . arraycopy ( xs , _ NUM , x_ , _ NUM , len ) ;  System . arraycopy ( ys , _ NUM , y_ , _ NUM , len ) ;  System . arraycopy ( xs , _ NUM , x_ , len , l ) ;  System . arraycopy ( ys , _ NUM , y_ , len , l ) ; az_save . index = len + l ; sections . add ( az_save ) ; xs = x_ ; ys = y_ ; } else { if (  DEBUG && is Filled && ( az_save == null ) ) {  Debug . output ( _ STR ) ; } az Var . index = i ; j = rawllpts . length ; az Var . current_azimuth = ( float )  Great Circle . spherical Azimuth ( center Y , center X , rawllpts [ j - _ NUM ] , rawllpts [ j - _ NUM ] ) ; sections . add ( az Var ) ; } } else if ( az_save != null ) { if (  DEBUG )  Debug . output ( _ STR ) ; sections . add ( az_first ) ; sections . add ( az_save ) ; } int size = sections . size ( ) ;  Array List < float [ ] > ret_val = new  Array List < float [ ] > ( size ) ; if ( is Filled && ( len > _ NUM ) ) { generate Filled Poly ( xs , ys , sections , ret_val ) ; return ret_val ; } for ( j = _ NUM ; j < size ; j += _ NUM ) {  Azimuth Var az1 = (  Azimuth Var ) sections . get ( j ) ;  Azimuth Var az2 = (  Azimuth Var ) sections . get ( j + _ NUM ) ; int off1 = az1 . index ; int off2 = az2 . index ; int l = off2 - off1 ; x_ = new float [ l ] ; y_ = new float [ l ] ;  System . arraycopy ( xs , off1 , x_ , _ NUM , l ) ;  System . arraycopy ( ys , off1 , y_ , _ NUM , l ) ; ret_val . add ( x_ ) ; ret_val . add ( y_ ) ; } return ret_val ; }
private  Type < ? > find Interface ( final  Class < ? > the Interface ) {  Type < ? > the Interface Type = null ;  Linked List <  Type < ? > > types = new  Linked List <  Type < ? > > ( ) ; types . add ( this ) ; while ( the Interface Type == null && ! types . is Empty ( ) ) {  Type < ? > current Type = types . remove First ( ) ; if ( the Interface . equals ( current Type . get Raw Type ( ) ) ) { the Interface Type = current Type ; } else if ( ! current Type . equals (  Type Factory .  TYPE_ OF_ OBJECT ) ) { types . add All (  Arrays . as List ( current Type . get Interfaces ( ) ) ) ; types . add ( current Type . get Super Type ( ) ) ; } } return the Interface Type ; }
private <  T >  Binding Inject <  T > find Bean (  Key <  T > key ) { for (  Inject Provider provider : _provider List ) {  Binding Inject <  T > bean = (  Binding Inject ) provider . lookup ( key . raw Class ( ) ) ; if ( bean != null ) { return bean ; } } return null ; }
protected void smart Indent After New Line (  IDocument document ,  Document Command command ) { int doc Length = document . get Length ( ) ; if ( command . offset == - _ NUM || doc Length == _ NUM ) { return ; } try { int p = ( command . offset == doc Length ? command . offset - _ NUM : command . offset ) ; int line = document . get Line Of Offset ( p ) ;  String Buffer buf = new  String Buffer ( command . text ) ; if ( command . offset < doc Length && document . get Char ( command . offset ) == _ STR ) { int ind Line = find Matching Open Bracket ( document , line , command . offset , _ NUM ) ; if ( ind Line == - _ NUM ) { ind Line = line ; } buf . append ( get Indent Of Line ( document , ind Line ) ) ; } else { int start = document . get Line Offset ( line ) ; int whiteend = find End Of White Space ( document , start , command . offset ) ; buf . append ( document . get ( start , whiteend - start ) ) ; if ( get Bracket Count ( document , start , command . offset , _ BOOL ) > _ NUM ) { buf . append ( get Indent Token ( ) ) ; } } command . text = buf . to String ( ) ; } catch (  Bad Location Exception e ) {  GWTPlugin Log . log Error ( e ) ; } }
private  String input Accrued National Number ( ) { int length Of National Number = national Number . length ( ) ; if ( length Of National Number > _ NUM ) {  String temp National Number = _ STR ; for ( int i = _ NUM ; i < length Of National Number ; i ++ ) { temp National Number = input Digit Helper ( national Number . char At ( i ) ) ; } return able To Format ? append National Number ( temp National Number ) : accrued Input . to String ( ) ; } else { return prefix Before National Number . to String ( ) ; } }
private void fill Picks ( ) throws  Exception {  Language language =  Language . get Login Language ( ) ;  MLookup order L =  MLookup Factory . get (  Env . get Ctx ( ) , m_ Window No ,  MColumn . get Column_ ID (  MDDOrder .  Table_ Name ,  MDDOrder .  COLUMNNAME_ DD_ Order_ ID ) ,  Display Type .  Search , language ,  MDDOrder .  COLUMNNAME_ DD_ Order_ ID , _ NUM , _ BOOL , _ STR ) ; f Order = new  VLookup (  MDDOrder .  COLUMNNAME_ DD_ Order_ ID , _ BOOL , _ BOOL , _ BOOL , order L ) ; l Order . set Text (  Msg . translate (  Env . get Ctx ( ) ,  MDDOrder .  COLUMNNAME_ DD_ Order_ ID ) ) ; f Order . add Vetoable Change Listener ( this ) ;  Timestamp today = new  Timestamp (  System . current Time Millis ( ) ) ; m_ Movement Date = today ; f Movement Date . set Value ( today ) ; f Movement Date . add Vetoable Change Listener ( this ) ; }
@  Override protected  Field Config Base create Copy (  Field Config Base field Config Base ) {  Field Config Boolean copy = null ; if ( field Config Base != null ) { copy = new  Field Config Boolean ( field Config Base . get Common Data ( ) ) ; } return copy ; }
private  Image cache Annotation Image ( final  Workflow Annotation anno , final int cache Id ) {  Rectangle2 D loc = anno . get Location ( ) ;  Dimension size = new  Dimension ( ( int ) loc . get Width ( ) , ( int ) loc . get Height ( ) ) ; pane . set Size ( size ) ; pane . set Text (  Annotation Draw Utils . create Styled Comment String ( anno ) ) ; pane . set Caret Position ( _ NUM ) ;  Buffered Image img = new  Buffered Image ( ( int ) loc . get Width ( ) , ( int ) loc . get Height ( ) ,  Buffered Image .  TYPE_ INT_ ARGB ) ;  Graphics2 D g Img = img . create Graphics ( ) ; g Img . set Rendering Hints (  Process Drawer .  HI_ QUALITY_ HINTS ) ; g Img . set Composite (  Alpha Composite .  Src Over ) ; pane . paint ( g Img ) ; display Cache . put ( anno . get Id ( ) , new  Weak Reference <  Image > ( img ) ) ; cached ID . put ( anno . get Id ( ) , cache Id ) ; return img ; }
public void add (  Two DNode dn ) { if ( in Progress ) { throw new  Concurrent Modification Exception ( _ STR ) ; } nodes . add ( dn ) ; }
public static  Configuration load (  Input Stream stream ) throws  IOException { try {  Properties properties = new  Properties ( ) ; properties . load ( stream ) ; return from ( properties ) ; } finally { stream . close ( ) ; } }
public synchronized  Combo Box <  V > add Item (  V item ) { if ( item == null ) { throw new  Illegal Argument Exception ( _ STR ) ; } items . add ( item ) ; if ( selected Index == - _ NUM && items . size ( ) == _ NUM ) { set Selected Index ( _ NUM ) ; } invalidate ( ) ; return this ; }
private static  Element add Bean (  Document doc ,  Node parent ,  Class < ? > cls ) {  Element elem = doc . create Element ( _ STR ) ; elem . set Attribute ( _ STR , cls . get Name ( ) ) ; parent . append Child ( elem ) ; return elem ; }
@  Override public final boolean read Boolean ( ) throws  IOException { return dis . read Boolean ( ) ; }
public  Enumeration <  String > enumerate Measures ( ) {  Vector <  String > new Vector = new  Vector <  String > ( _ NUM ) ; new Vector . add Element ( _ STR ) ; new Vector . add Element ( _ STR ) ; return new Vector . elements ( ) ; }
@  Override public  Instances define Data Format ( ) throws  Exception {  Array List <  Attribute > atts ;  Array List <  String > att Values ; int i ; int n ; m_ Random = new  Random ( get Seed ( ) ) ; set Num Examples Act ( get Num Examples ( ) ) ; atts = new  Array List <  Attribute > ( ) ; for ( n = _ NUM ; n <= _ NUM ; n ++ ) { att Values = new  Array List <  String > ( ) ; for ( i = _ NUM ; i < _ NUM ; i ++ ) { att Values . add ( _ STR + i ) ; } atts . add ( new  Attribute ( _ STR + n , att Values ) ) ; } att Values = new  Array List <  String > ( ) ; for ( i = _ NUM ; i < _ NUM ; i ++ ) { att Values . add ( _ STR + i ) ; } atts . add ( new  Attribute ( _ STR , att Values ) ) ; m_ Dataset Format = new  Instances ( get Relation Name To Use ( ) , atts , _ NUM ) ; return m_ Dataset Format ; }
public static double ln Gamma ( double x ) { double p , q , w , z ; double  A [ ] = { _ NUM , - _ NUM , _ NUM , - _ NUM , _ NUM } ; double  B [ ] = { - _ NUM , - _ NUM , - _ NUM , - _ NUM , - _ NUM , - _ NUM } ; double  C [ ] = { - _ NUM , - _ NUM , - _ NUM , - _ NUM , - _ NUM , - _ NUM } ; if ( x < - _ NUM ) { q = - x ; w = ln Gamma ( q ) ; p =  Math . floor ( q ) ; if ( p == q ) { throw new  Arithmetic Exception ( _ STR ) ; } z = q - p ; if ( z > _ NUM ) { p += _ NUM ; z = p - q ; } z = q *  Math . sin (  Math .  PI * z ) ; if ( z == _ NUM ) { throw new  Arithmetic Exception ( _ STR ) ; } z =  LOGPI -  Math . log ( z ) - w ; return z ; } if ( x < _ NUM ) { z = _ NUM ; while ( x >= _ NUM ) { x -= _ NUM ; z *= x ; } while ( x < _ NUM ) { if ( x == _ NUM ) { throw new  Arithmetic Exception ( _ STR ) ; } z /= x ; x += _ NUM ; } if ( z < _ NUM ) { z = - z ; } if ( x == _ NUM ) { return  Math . log ( z ) ; } x -= _ NUM ; p = x * polevl ( x ,  B , _ NUM ) / p1evl ( x ,  C , _ NUM ) ; return (  Math . log ( z ) + p ) ; } if ( x > _ NUM ) { throw new  Arithmetic Exception ( _ STR ) ; } q = ( x - _ NUM ) *  Math . log ( x ) - x + _ NUM ; if ( x > _ NUM ) { return ( q ) ; } p = _ NUM / ( x * x ) ; if ( x >= _ NUM ) { q += ( ( _ NUM * p - _ NUM ) * p + _ NUM ) / x ; } else { q += polevl ( p ,  A , _ NUM ) / x ; } return q ; }
public synchronized  Configuration Framework initialize ( final  String install Path , final  String instance Path , final  Class Loader parent ) throws  Config Exception { if ( loader != null ) { throw new  Illegal State Exception ( _ STR ) ; } this . install Path = install Path != null ? install Path :  System . getenv ( _ STR ) ; if ( instance Path != null ) { this . instance Path = instance Path ; } else {  String instance Root =  System . getenv ( _ STR ) ; this . instance Path = instance Root != null ? instance Root : this . install Path ; } this . parent = parent ; initialize0 ( ) ; return this ; }
@  Override public  String run (  String [ ] args ) { if ( args . length == _ NUM ) {  String help = _ STR ; help += _ STR ; help += _ STR ; help += _ STR ; help += _ STR ; help += _ STR ; return help ; } try { if ( args . length > _ NUM ) {  String cmd = args [ _ NUM ] ; if ( cmd == _ STR ) { if ( args . length > _ NUM ) { int id =  Integer . parse Int ( args [ _ NUM ] ) ; return str List Network ( id , _ BOOL ) ; } else { return str List Networks ( _ BOOL ) ; } } else if ( cmd == _ STR ) { if ( args . length > _ NUM ) { int id1 =  Integer . parse Int ( args [ _ NUM ] ) ; int id2 =  Integer . parse Int ( args [ _ NUM ] ) ; int id3 =  Integer . parse Int ( args [ _ NUM ] ) ; return str Link3 ( id1 , id2 , id3 ) ; } else if ( args . length > _ NUM ) { int id1 =  Integer . parse Int ( args [ _ NUM ] ) ; int id2 =  Integer . parse Int ( args [ _ NUM ] ) ; return str Link2 ( id1 , id2 ) ; } } else if ( cmd == _ STR ) { if ( args . length > _ NUM ) { int id =  Integer . parse Int ( args [ _ NUM ] ) ; return str Unlink ID ( id ) ; } else { return str Unlink All ( ) ; } } return _ STR ; } } catch (  Number Format Exception nfe ) { } catch (  Null Pointer Exception npe ) { } catch (  Index Out Of Bounds Exception ioobe ) { } return _ STR ; }
public void processed (  String source Id ,  String target Id , boolean link Existed ,  String link Id , boolean link Created ,  Situation situation ,  Recon Action action ) {  String id ; if ( phase ==  Phase .  SOURCE ) { id = source Id ; } else { id = target Id ; } parent Stat . processed ( source Id , target Id , link Existed , link Id , link Created , situation , action ) ; if ( id != null ) { processed Entries . increment And Get ( ) ; if ( situation != null ) {  List <  String > situation Ids = ids . get ( situation ) ; if ( situation Ids != null ) { situation Ids . add ( id ) ; } } } }
private void create Collection Reader (  Object collection Reader Config ) throws  Baleen Exception {  String class Name =  Cpe Builder Utils . get Class Name From Config ( collection Reader Config ) ;  Map <  String ,  Object > params =  Cpe Builder Utils . get Params From Config ( collection Reader Config ) ; if ( class Name == null || class Name . is Empty ( ) ) { throw new  Baleen Exception ( _ STR ) ; }  Optional <  Collection Reader Description > desc = create Collection Reader ( class Name , params ,  READER_ DEFAULT_ PACKAGE ) ; if ( desc . is Present ( ) ) { set Collector Reader ( desc . get ( ) ) ; } else { throw new  Baleen Exception (  String . format ( _ STR , class Name ) ) ; } }
private static void store As Type With Signatures Import (  String str Type To Import , @  Nullable  Function obj Scope ,  Php Index obj Index ,  Hash Set <  String > obj Types Set ) { if ( str Type To Import . contains ( _ STR ) ) { for (  String str One Type : str Type To Import . split ( _ STR ) ) { store As Type With Signatures Import (  Types . get Type ( str One Type ) , obj Scope , obj Index , obj Types Set ) ; } return ; } if (  String Util . is Empty ( str Type To Import ) || str Type To Import . equals ( _ STR ) ) { return ; } if ( str Type To Import . contains ( _ STR ) ) {  Type From Signature Resolving Util . resolve Signature ( str Type To Import , obj Scope , obj Index , obj Types Set ) ; return ; } obj Types Set . add (  Types . get Type ( str Type To Import ) ) ; }
@  Parameters Are Nonnull By Default public static  List <  Size > filter Black Listed Sizes (  List <  Size > sizes ,  String blacklist String ) {  String [ ] blacklist String Array = blacklist String . split ( _ STR ) ; if ( blacklist String Array . length == _ NUM ) { return sizes ; }  Set <  String > blacklisted Sizes = new  Hash Set (  Lists . new Array List ( blacklist String Array ) ) ;  List <  Size > new Size List = new  Array List < > ( ) ; for (  Size size : sizes ) { if ( ! is Black Listed ( size , blacklisted Sizes ) ) { new Size List . add ( size ) ; } } return new Size List ; }
public static void copy ( final  JText Area area ) { final  String selected Text = area . get Selected Text ( ) ; if ( selected Text == null ) {  Clipboard Helpers . copy To Clipboard ( area . get Text ( ) ) ; } else {  Clipboard Helpers . copy To Clipboard ( selected Text ) ; } }
public  Bitmap take Bite (  Bitmap bitmap , float cx , float cy , float radius , int rotation Degrees ) {  Canvas c = new  Canvas ( bitmap ) ;  Paint paint = new  Paint ( ) ; paint . set Xfermode ( new  Porter Duff Xfermode (  Porter Duff .  Mode .  CLEAR ) ) ;  Rect F bounds = new  Rect F ( cx - radius , cy - radius , cx + radius , cy + radius ) ; rect F . set ( bounds ) ; c . draw Arc ( rect F , rotation Degrees , _ NUM , _ BOOL , paint ) ; int num Teeth = _ NUM ; int angle Slice = _ NUM / num Teeth ; for ( int i = _ NUM ; i < num Teeth ; i ++ ) { int angle Start = ( angle Slice * i ) + rotation Degrees ; double angle Start Radian = angle Start *  Math .  PI / _ NUM ; float x Start = ( float ) ( cx + radius *  Math . cos ( angle Start Radian ) ) ; float y Start = ( float ) ( cy + radius *  Math . sin ( angle Start Radian ) ) ; int angle End = ( angle Slice * ( i + _ NUM ) ) + rotation Degrees ; double angle End Radian = angle End *  Math .  PI / _ NUM ; float x End = ( float ) ( cx + radius *  Math . cos ( angle End Radian ) ) ; float y End = ( float ) ( cy + radius *  Math . sin ( angle End Radian ) ) ; float circle Center X =  Draw Utils . get Point Between Two Points ( x Start , x End , _ NUM ) ; float circle Center Y =  Draw Utils . get Point Between Two Points ( y Start , y End , _ NUM ) ; double circumference =  Draw Utils . get Distance Between Two Points ( x Start , y Start , x End , y End ) ; int num = i + _ NUM ; if ( num > ( num Teeth / _ NUM ) + _ NUM ) { if ( num == _ NUM ) num -= _ NUM ; if ( num == _ NUM ) num -= _ NUM ; if ( num == _ NUM ) num -= _ NUM ; if ( num == _ NUM ) num -= _ NUM ; } double angle Of Small Semi Circle = ( ( _ NUM / num Teeth ) * num ) - _ NUM ; float radius Small = ( float ) ( circumference / _ NUM ) ;  Rect F bounds2 = new  Rect F ( circle Center X - radius Small , circle Center Y - radius Small , circle Center X + radius Small , circle Center Y + radius Small ) ;  Rect F rect Tooth = new  Rect F ( ) ; rect Tooth . set ( bounds2 ) ; int base Small Circle Angle Start = rotation Degrees - _ NUM ; if ( i > num Teeth / _ NUM ) { angle Of Small Semi Circle = _ NUM + ( _ NUM - angle Of Small Semi Circle ) ; } float start Angle = ( float ) ( base Small Circle Angle Start + angle Of Small Semi Circle ) ; c . draw Arc ( rect Tooth , ( float ) start Angle , _ NUM , _ BOOL , paint ) ; } return bitmap ; }
final private  String match Rule Def2 Match Rule Desc (  Attributes attrs ) throws  Naming Exception {  String Buffer match Rule Desc = new  String Buffer ( _ STR ) ;  Attribute attr = null ; int count = _ NUM ; attr = attrs . get (  NUMERICOID_ ID ) ; if ( attr != null ) { match Rule Desc . append ( write Numeric OID ( attr ) ) ; count ++ ; } else { throw new  Configuration Exception ( _ STR + _ STR ) ; } attr = attrs . get (  NAME_ ID ) ; if ( attr != null ) { match Rule Desc . append ( write QDescrs ( attr ) ) ; count ++ ; } attr = attrs . get (  DESC_ ID ) ; if ( attr != null ) { match Rule Desc . append ( write QDString ( attr ) ) ; count ++ ; } attr = attrs . get (  OBSOLETE_ ID ) ; if ( attr != null ) { match Rule Desc . append ( write Boolean ( attr ) ) ; count ++ ; } attr = attrs . get (  SYNTAX_ ID ) ; if ( attr != null ) { match Rule Desc . append ( write WOID ( attr ) ) ; count ++ ; } else { throw new  Configuration Exception ( _ STR + _ STR ) ; } if ( count < attrs . size ( ) ) {  String attr Id = null ; for (  Naming Enumeration < ? extends  Attribute > ae = attrs . get All ( ) ; ae . has More Elements ( ) ; ) { attr = ae . next ( ) ; attr Id = attr . get ID ( ) ; if ( attr Id . equals (  NUMERICOID_ ID ) || attr Id . equals (  NAME_ ID ) || attr Id . equals (  SYNTAX_ ID ) || attr Id . equals (  DESC_ ID ) || attr Id . equals (  OBSOLETE_ ID ) ) { continue ; } else { match Rule Desc . append ( write QDStrings ( attr ) ) ; } } } match Rule Desc . append ( _ STR ) ; return match Rule Desc . to String ( ) ; }
@  Suppress Warnings ( _ STR ) public static <  T >  T find Value Of Type (  Collection < ? > collection ,  Class <  T > type ) { if ( is Empty ( collection ) ) { return null ; }  T value = null ; for (  Object element : collection ) { if ( type == null || type . is Instance ( element ) ) { if ( value != null ) { return null ; } value = (  T ) element ; } } return value ; }
public void load All Images (  Component comp ,  Media Tracker tracker ) { for (  Iterator <  Hex Entry > i = bases . iterator ( ) ; i . has Next ( ) ; ) {  Hex Entry entry = i . next ( ) ; if ( entry . get Image ( ) == null ) { entry . load Image ( comp ) ; } tracker . add Image ( entry . get Image ( ) , _ NUM ) ; } for (  Iterator <  Hex Entry > i = supers . iterator ( ) ; i . has Next ( ) ; ) {  Hex Entry entry = i . next ( ) ; if ( entry . get Image ( ) == null ) { entry . load Image ( comp ) ; } tracker . add Image ( entry . get Image ( ) , _ NUM ) ; } for (  Iterator <  Hex Entry > i = ortho . iterator ( ) ; i . has Next ( ) ; ) {  Hex Entry entry = i . next ( ) ; if ( entry . get Image ( ) == null ) { entry . load Image ( comp ) ; } tracker . add Image ( entry . get Image ( ) , _ NUM ) ; } }
public static  Date parse (  String date Str ) { try { return m Simple Date Time Format . parse ( date Str ) ; } catch (  Parse Exception e ) { e . print Stack Trace ( ) ; throw new  Runtime Exception ( _ STR ) ; } }
public static  String serialize (  Object node ) {  String ret = null ; if ( node instanceof  String ) { ret = (  String ) node ; } else if ( node instanceof byte [ ] ) { ret = new  String ( ( byte [ ] ) node ) ; } else if ( node instanceof  DOMSource ) { ret = serialize DOMSource ( (  DOMSource ) node ) ; } else if ( node instanceof  Node ) { ret = serialize Node ( (  Node ) node ) ; } else { log . severe ( _ STR + node + _ STR ) ; } if ( ret != null ) { ret = ret . trim ( ) ; } return ret ; }
void close Internal ( ) throws  SQLException { for (  Iterator <  Jdbc Result Set > it = res Sets . iterator ( ) ; it . has Next ( ) ; ) {  Jdbc Result Set rs = it . next ( ) ; rs . close Internal ( ) ; it . remove ( ) ; } closed = _ BOOL ; }
boolean contains (  Binary Search Tree Node <  E > node ) { if ( node == null ) return _ BOOL ; if ( this . root == null ) return _ BOOL ; if ( node == this . root ) return _ BOOL ;  Binary Search Tree Node <  E > curr = this . root ; while ( curr != null ) { if ( curr == node ) return _ BOOL ; int diff = node . compare To ( curr ) ; if ( diff == _ NUM ) { return curr == node ; } else if ( diff < _ NUM ) { curr = curr . left ; } else { curr = curr . right ; } } return _ BOOL ; }
public void delete Entity Config (  String realm ,  String entity Id ) throws  SAML2 Meta Exception { if ( entity Id == null ) { return ; } if ( realm == null ) { realm = _ STR ; }  String [ ] objs = { entity Id , realm } ; try {  Map old Attrs = config Inst . get Configuration ( realm , entity Id ) ;  Set old Values = (  Set ) old Attrs . get (  ATTR_ ENTITY_ CONFIG ) ; if ( old Values == null || old Values . is Empty ( ) ) {  Log Util . error (  Level .  INFO ,  Log Util .  NO_ ENTITY_ DESCRIPTOR_ DELETE_ ENTITY_ CONFIG , objs , null ) ; throw new  SAML2 Meta Exception ( _ STR , objs ) ; } remove From Circle Of Trust ( realm , entity Id ) ;  Set attr = new  Hash Set ( ) ; attr . add (  ATTR_ ENTITY_ CONFIG ) ; config Inst . delete Configuration ( realm , entity Id , attr ) ;  Log Util . access (  Level .  INFO ,  Log Util .  ENTITY_ CONFIG_ DELETED , objs , null ) ;  SAML2 Meta Cache . put Entity Config ( realm , entity Id , null ) ; } catch (  Configuration Exception e ) { debug . error ( _ STR , e ) ;  String [ ] data = { e . get Message ( ) , entity Id , realm } ;  Log Util . error (  Level .  INFO ,  Log Util .  CONFIG_ ERROR_ DELETE_ ENTITY_ CONFIG , data , null ) ; throw new  SAML2 Meta Exception ( e ) ; } }
public static synchronized  Explorer Support shared Instance ( ) { if ( shared Instance == null ) shared Instance = new  Explorer Support ( ) ; return shared Instance ; }
public void test Certificates ( ) throws  Exception {  Identity i = new  Identity Stub ( _ STR ) ;  Public Key Stub pk1 = new  Public Key Stub ( _ STR , _ STR , null ) ;  Certificate Stub c1 = new  Certificate Stub ( _ STR , null , null , pk1 ) ;  Certificate Stub c2 = new  Certificate Stub ( _ STR , null , null , pk1 ) ; i . add Certificate ( c1 ) ; i . add Certificate ( c2 ) ; java . security .  Certificate [ ] s = i . certificates ( ) ; assert Equals ( _ NUM , s . length ) ; assert True ( c1 . equals ( s [ _ NUM ] ) || c2 . equals ( s [ _ NUM ] ) ) ; assert True ( c1 . equals ( s [ _ NUM ] ) || c2 . equals ( s [ _ NUM ] ) ) ; s [ _ NUM ] = null ; s [ _ NUM ] = null ; s = i . certificates ( ) ; assert Equals ( _ NUM , s . length ) ; assert True ( c1 . equals ( s [ _ NUM ] ) || c2 . equals ( s [ _ NUM ] ) ) ; assert True ( c1 . equals ( s [ _ NUM ] ) || c2 . equals ( s [ _ NUM ] ) ) ; }
public static  String format Exception (  Exception exc ) {  String Writer string Writer = new  String Writer ( ) ;  Print Writer print Writer = new  Print Writer ( string Writer ) ; exc . print Stack Trace ( print Writer ) ; try { string Writer . close ( ) ; } catch (  IOException ex ) { } return string Writer . to String ( ) ; }
public  String resolve Path (  String path Info ) { if ( ( path Info == null ) || ( path Info . index Of ( _ STR ) != - _ NUM ) ) { return null ; } int lib Start = path Info . index Of ( _ STR ) + _ NUM ; int lib End = path Info . index Of ( _ STR , lib Start ) ; if ( lib End == - _ NUM ) { lib End = path Info . length ( ) ; }  String libname = path Info . substring ( lib Start , lib End ) ;  String subpath = path Info . substring ( lib End ) ;  String lib_home = get Path ( libname ) ; if ( lib_home == null ) { return null ; } return lib_home + _ STR + subpath ; }
public void compress ( ) {  Io Buffer tmp =  Io Buffer . allocate ( _ NUM ) ; tmp . set Auto Expand ( _ BOOL ) ;  Deflater Output Stream deflater = new  Deflater Output Stream ( tmp . as Output Stream ( ) , new  Deflater (  Deflater .  BEST_ COMPRESSION ) ) ; byte [ ] tmp Data = new byte [ data . limit ( ) ] ; data . position ( _ NUM ) ; data . get ( tmp Data ) ; try { deflater . write ( tmp Data ) ; deflater . finish ( ) ; } catch (  IOException e ) { tmp . free ( ) ; throw new  Runtime Exception ( _ STR , e ) ; } finally { if ( deflater != null ) { try { deflater . close ( ) ; } catch (  IOException e1 ) { } } } data . free ( ) ; data = tmp ; data . flip ( ) ; prepare IO ( ) ; }
public void poll ( final  Snmp Udp Statistics Handler snmp Udp Statistics Handler ) { this . statistics Handler = snmp Udp Statistics Handler ; try { file Loader . load ( ) ; final  Byte Buffer buffer = file Loader . get Buffer ( ) ; line Parser . reset ( ) ; line Parser . handle Token ( buffer , buffer . position ( ) , buffer . limit ( ) ) ; } finally { this . statistics Handler = null ; } }
@  Override public int compare To (  Byte Buffer other Buffer ) { int compare Remaining = ( remaining ( ) < other Buffer . remaining ( ) ) ? remaining ( ) : other Buffer . remaining ( ) ; int this Pos = position ; int other Pos = other Buffer . position ; byte this Byte , other Byte ; while ( compare Remaining > _ NUM ) { this Byte = get ( this Pos ) ; other Byte = other Buffer . get ( other Pos ) ; if ( this Byte != other Byte ) { return this Byte < other Byte ? - _ NUM : _ NUM ; } this Pos ++ ; other Pos ++ ; compare Remaining -- ; } return remaining ( ) - other Buffer . remaining ( ) ; }
public  Urbansim Cell Based Accessibility CSVWriter V2 (  String matsim Output Directory ) { log . info ( _ STR ) ; try { accessibility Data Writer =  IOUtils . get Buffered Writer ( matsim Output Directory + _ STR +  ACCESSIBILITY_ INDICATORS ) ; } catch (  Exception ee ) { ee . print Stack Trace ( ) ; throw new  Runtime Exception ( _ STR ) ; } if ( accessibility Data Writer == null ) { throw new  Runtime Exception ( _ STR ) ; } try { accessibility Data Writer . write (  Labels .  ZONE_ ID + _ STR +  Labels .  X_ COORDINATE + _ STR +  Labels .  Y_ COORDINATE + _ STR +  Labels .  ACCESSIBILITY_ BY_ FREESPEED + _ STR +  Labels .  ACCESSIBILITY_ BY_ CAR + _ STR +  Labels .  ACCESSIBILITY_ BY_ BIKE + _ STR +  Labels .  ACCESSIBILITY_ BY_ WALK + _ STR +  Labels .  ACCESSIBILITY_ BY_ PT ) ; accessibility Data Writer . new Line ( ) ; } catch (  IOException e ) { e . print Stack Trace ( ) ; throw new  Runtime Exception ( _ STR ) ; } log . info ( _ STR ) ; }
@  Override public void agg (  Object new Val ) { if ( new Val instanceof byte [ ] ) {  Byte Buffer buffer =  Byte Buffer . wrap ( ( byte [ ] ) new Val ) ; buffer . rewind ( ) ; while ( buffer . has Remaining ( ) ) { byte [ ] value Byte = new byte [ buffer . get Int ( ) ] ; buffer . get ( value Byte ) ;  Big Decimal value Big Decimal =  Data Type Util . byte To Big Decimal ( value Byte ) ; agg Val = agg Val . add ( value Big Decimal ) ; count += buffer . get Double ( ) ; first Time = _ BOOL ; } return ; } if ( first Time ) { agg Val = (  Big Decimal ) new Val ; first Time = _ BOOL ; } else { agg Val = agg Val . add ( (  Big Decimal ) new Val ) ; } count ++ ; }
public static  SMSFlat File Tree Node create Tree (  String xml ,  Debug debug ) throws  Exception {  SMSFlat File Tree Node root = null ;  Document doc =  XMLUtils . to DOMDocument ( xml , debug ) ;  Node root Node =  XMLUtils . get Root Node ( doc ,  XML_ ROOT_ ELEMENT ) ; if ( root Node != null ) { root = create Node (  XMLUtils . get Child Node ( root Node ,  XML_ NODE_ ELEMENT ) ) ; } return root ; }
public static  Signed Document Validator from Document ( final  DSSDocument dss Document ) { if (  Collection Utils . is Empty ( registred Document Validators ) ) { throw new  DSSException ( _ STR ) ; } for (  Class <  Signed Document Validator > clazz : registred Document Validators ) { try {  Constructor <  Signed Document Validator > default And Private Constructor = clazz . get Declared Constructor ( ) ; default And Private Constructor . set Accessible ( _ BOOL ) ;  Signed Document Validator validator = default And Private Constructor . new Instance ( ) ; if ( validator . is Supported ( dss Document ) ) {  Constructor < ? extends  Signed Document Validator > constructor = clazz . get Declared Constructor (  DSSDocument . class ) ; return constructor . new Instance ( dss Document ) ; } } catch (  Exception e ) {  LOG . error ( _ STR + clazz . get Name ( ) + _ STR + e . get Message ( ) , e ) ; } } throw new  DSSException ( _ STR ) ; }
private static final  String decode Field Name ( final  String p Xml Field Name ) {  String Buffer str = new  String Buffer ( ) ; int field Name Length = p Xml Field Name . length ( ) ; char current Char ; for ( int i = _ NUM ; i < field Name Length ; i ++ ) { current Char = p Xml Field Name . char At ( i ) ; if ( current Char == _ STR ) { str . append (  Character . to Upper Case ( p Xml Field Name . char At ( ++ i ) ) ) ; } else { str . append ( current Char ) ; } } return str . to String ( ) ; }
public boolean authenticate User (  String username ,  String password ,  String uri ) throws  Data Access Exception { if ( null == username || null == password ) { return _ BOOL ; }  User Info user = get User Info ( username ) ; if ( user == null ) { return _ BOOL ; }  String hashed Salted Password =  Utilities . get Salted Password ( username , uri , password ) ; return hashed Salted Password . equals ( user . get Hashed Password ( ) ) ; }
public  Builder add Content Item (  Content Item content Item ) { if ( content Items == null ) { content Items = new  Array List <  Content Item > ( ) ; content Type =  Http Media Type .  APPLICATION_ JSON ; } content Items . add ( content Item ) ; return this ; }
public static  String [ ] split Classname (  String classname ) { classname = canonicalize Class Name ( classname ) ; int i = classname . last Index Of ( _ STR ) ;  String classn , packn ; if ( i == - _ NUM ) { classn = classname ; packn = _ STR ; } else { packn = classname . substring ( _ NUM , i ) ; classn = classname . substring ( i + _ NUM ) ; } return new  String [ ] { packn , classn } ; }
public static long pause ( final long sleep Time MS ) { final long start Time =  System . current Time Millis ( ) ; do { try { final long sleep Time = sleep Time MS - (  System . current Time Millis ( ) - start Time ) ;  Thread . sleep ( sleep Time > _ NUM ? sleep Time : _ NUM ) ; } catch (  Interrupted Exception e ) { } } while ( (  System . current Time Millis ( ) - start Time ) < sleep Time MS ) ; return  System . current Time Millis ( ) - start Time ; }
public boolean by Pass Control To Processor ( boolean flag ) { return _ BOOL ; }
private void remove Lock To Jobs Needing Lock (  String lock ,  Job job , boolean should Be At Head ) {  Array List <  Job > jobs = lock To Jobs Needing Lock . get ( lock ) ; if ( should Be At Head && jobs . get ( _ NUM ) != job ) { throw new  Runtime Exception ( _ STR + job + _ STR + _ STR + lock + _ STR + jobs ) ; } boolean removed = jobs . remove ( job ) ; if ( ! removed ) { throw new  Runtime Exception ( _ STR + job + _ STR + jobs ) ; } }
public static double [ ] lprefc2lpc ( double [ ] k ) { int p = k . length ; double [ ] [ ]  A = new double [ p ] [ ] ; int i , j ; for ( i = _ NUM ; i <= p ; i ++ ) {  A [ i - _ NUM ] = new double [ i ] ;  A [ i - _ NUM ] [ i - _ NUM ] = k [ i - _ NUM ] ; for ( j = _ NUM ; j < i ; j ++ )  A [ i - _ NUM ] [ j - _ NUM ] =  A [ i - _ NUM ] [ j - _ NUM ] - k [ i - _ NUM ] *  A [ i - _ NUM ] [ i - j - _ NUM ] ; } double [ ] one Minus A = new double [ p + _ NUM ] ; one Minus A [ _ NUM ] = _ NUM ;  System . arraycopy (  A [ p - _ NUM ] , _ NUM , one Minus A , _ NUM , p ) ; return one Minus A ; }
protected void generate Adapter ( ) {  String holder Class Name =  Utils . get View Holder Class Name ( ) ;  String Builder holder Builder = new  String Builder ( ) ;  String Builder generator = new  String Builder ( ) ; generator . append ( _ STR + holder Class Name + _ STR ) ;  String root View Name = _ STR ; holder Builder . append ( _ STR + _ STR + root View Name + _ STR ) ; generator . append ( _ STR + root View Name + _ STR + root View Name + _ STR ) ; for (  Element element : m Elements ) { if ( ! element . used ) { continue ; } holder Builder . append ( _ STR + element . name + _ STR + element . get Field Name ( ) + _ STR ) ; generator . append ( _ STR + element . get Field Name ( ) + _ STR + element . name + _ STR + root View Name + _ STR + element . get Full ID ( ) + _ STR ) ; } generator . append ( _ STR ) ; holder Builder . append ( generator . to String ( ) ) ;  Psi Class view Holder = m Factory . create Class From Text ( holder Builder . to String ( ) , m Class ) ; view Holder . set Name ( holder Class Name ) ; m Class . add ( view Holder ) ; m Class . add Before ( m Factory . create Keyword ( _ STR , m Class ) , m Class . find Inner Class By Name ( holder Class Name , _ BOOL ) ) ; m Class . add Before ( m Factory . create Keyword ( _ STR , m Class ) , m Class . find Inner Class By Name ( holder Class Name , _ BOOL ) ) ; }
public boolean is Started ( ) { return writer != null || nrt Replica Node != null || nrt Primary Node != null ; }
private static void create Thread Pool ( ) { if ( m Thread Pool Size <= _ NUM ) { m Executor Service =  Executors . new Cached Thread Pool ( ) ; } else { m Executor Service =  Executors . new Fixed Thread Pool ( m Thread Pool Size ) ; } }
public void scroll To Open ( ) { if ( current Inner Status ==  Inner Status .  OPENED ) { return ; } if ( max Offset == min Offset ) { return ; } int dy = - get Scroll Y ( ) - max Offset ; if ( dy == _ NUM ) { return ; } current Inner Status =  Inner Status .  SCROLLING ; int duration =  MIN_ SCROLL_ DURATION +  Math . abs ( (  MAX_ SCROLL_ DURATION -  MIN_ SCROLL_ DURATION ) * dy / ( max Offset - min Offset ) ) ; scroller . start Scroll ( _ NUM , get Scroll Y ( ) , _ NUM , dy , duration ) ; invalidate ( ) ; }
private void retrieve Tracks (  Search Query query ,  Array List <  Track > tracks ) {  String query Like Selection = _ STR + query . text Query + _ STR ;  String [ ] track Selection Args = new  String [ ] { query Like Selection , query Like Selection , query Like Selection } ;  Cursor cursor = null ; try { cursor = provider Utils . get Track Cursor (  TRACK_ SELECTION_ QUERY , track Selection Args ,  TRACK_ SELECTION_ ORDER ) ; if ( cursor != null ) { tracks . ensure Capacity ( cursor . get Count ( ) ) ; while ( cursor . move To Next ( ) ) { tracks . add ( provider Utils . create Track ( cursor ) ) ; } } } finally { if ( cursor != null ) { cursor . close ( ) ; } } }
public void recreate ( ) { int new Size = nox Items . size ( ) ;  Weak Reference <  Bitmap > new Bitmaps [ ] = new  Weak Reference [ new Size ] ;  Drawable new Drawables [ ] = new  Drawable [ new Size ] ;  Drawable new Placeholders [ ] = new  Drawable [ new Size ] ; boolean new Loadings [ ] = new boolean [ new Size ] ;  Image Loader .  Listener new Listeners [ ] = new  Image Loader .  Listener [ new Size ] ; float length =  Math . min ( bitmaps . length , new Size ) ; for ( int i = _ NUM ; i < length ; i ++ ) { new Bitmaps [ i ] = bitmaps [ i ] ; new Drawables [ i ] = drawables [ i ] ; new Placeholders [ i ] = placeholders [ i ] ; new Loadings [ i ] = loading [ i ] ; new Listeners [ i ] = listeners [ i ] ; } bitmaps = new Bitmaps ; drawables = new Drawables ; placeholders = new Placeholders ; loading = new Loadings ; listeners = new Listeners ; }
public void insert (  String name , long cnt ) { if ( _values == null ) { _values = new  Array List < > ( _ NUM ) ; } _values . add ( _ NUM , new  Count ( this , name , cnt ) ) ; }
@  Override public void on Reset ( ) { close Dialog ( ) ; }
public static void add Params ( final  Map <  String ,  String > params , final  String Builder uri ) { if ( params == null || params . is Empty ( ) ) return ; for (  Entry <  String ,  String > param : params . entry Set ( ) ) add Param ( param . get Key ( ) , param . get Value ( ) , uri ) ; }
public  Create Event (  JSONObject json ) throws  JSONException { super (  TYPE_ CREATE , json ) ; if ( m Block Id == null ) { throw new  JSONException (  JSON_ BLOCK_ ID + _ STR ) ; } m Xml = json . get String (  JSON_ XML ) ;  JSONArray json Ids = json . get JSONArray ( _ STR ) ; int count = json Ids . length ( ) ;  List <  String > ids = new  Array List < > ( count ) ; for ( int i = _ NUM ; i < count ; ++ i ) { ids . add ( json Ids . get String ( i ) ) ; } m Ids =  Collections . unmodifiable List ( ids ) ; }
public static boolean is Full Copy Resynchronizable (  Volume volume ,  Db Client db Client ) { boolean result = _ BOOL ;  String replica State = volume . get Replica State ( ) ; if ( is Volume Full Copy ( volume , db Client ) && replica State != null && ! replica State . is Empty ( ) ) {  Replication State state =  Replication State . get Enum Value ( replica State ) ; if ( state != null && state ==  Replication State .  SYNCHRONIZED ) { result = _ BOOL ; } } return result ; }
private static int end Of Tag Match (  String string , int from Index ,  String tag ) { int pos = string . index Of ( tag , from Index ) ; if ( pos != - _ NUM ) { while ( pos < string . length ( ) &&  Character . is Whitespace ( string . char At ( pos ) ) ) pos ++ ; return pos + tag . length ( ) ; } if ( tag . contains ( _ STR ) ) { tag = tag . replace All ( _ STR , _ STR ) ; pos = string . index Of ( tag ) ; if ( pos != - _ NUM ) { while ( pos < string . length ( ) &&  Character . is Whitespace ( string . char At ( pos ) ) ) pos ++ ; return pos + tag . length ( ) ; } } return - _ NUM ; }
public  Byte Buffer decode (  Byte Buffer buf ) throws  Ignite Checked Exception ,  SSLException { in Net Buf . clear ( ) ; if ( buf . limit ( ) > in Net Buf . remaining ( ) ) { in Net Buf = expand Buffer ( in Net Buf , in Net Buf . capacity ( ) + buf . limit ( ) * _ NUM ) ; app Buf = expand Buffer ( app Buf , in Net Buf . capacity ( ) * _ NUM ) ; if ( log . is Debug Enabled ( ) ) log . debug ( _ STR + in Net Buf . capacity ( ) + _ STR + app Buf . capacity ( ) + _ STR ) ; } in Net Buf . put ( buf ) ; if ( ! handshake Finished ) handshake ( ) ; else unwrap Data ( ) ; if ( is Inbound Done ( ) ) { int new Position = buf . position ( ) - in Net Buf . position ( ) ; if ( new Position >= _ NUM ) { buf . position ( new Position ) ; if ( buf . has Remaining ( ) )  U . warn ( log , _ STR ) ; } in Net Buf . clear ( ) ; } app Buf . flip ( ) ; return app Buf ; }
public static boolean needs Recalculation ( long query Start Time , long last Modified Time ) { return  ENABLE_ UPDATE_ IN_ PROGRESS_ INDEX_ CALCULATION && query Start Time <=  SAFE_ QUERY_ TIME . get ( ) - query Start Time + last Modified Time ; }
final public boolean check DSClosing (  Distribution Manager dm ) {  Internal Distributed System ds = dm . get System ( ) ; return ( ds == null || ds . is Disconnecting ( ) ) ; }
private boolean check External Storage And Notify (  String filename ,  String full Dir Path ,  String external Storage Status ) { if ( full Dir Path == null ) {  Log . e (  TAG , _ STR ) ; alert Download Failure ( filename ) ; return _ BOOL ; } if ( ! external Storage Status . equals (  Environment .  MEDIA_ MOUNTED ) ) { if ( external Storage Status . equals (  Environment .  MEDIA_ SHARED ) ) {  Log . e (  TAG , _ STR ) ; } else {  Log . e (  TAG , _ STR ) ; } alert Download Failure ( filename ) ; return _ BOOL ; } return _ BOOL ; }
public static  String plnoun Creature ( final int quantity , final  String noun ) { if ( noun . equals ( _ STR ) ) { if ( quantity == _ NUM ) { return _ STR ; } else { return _ STR ; } } return plnoun ( quantity , noun ) ; }
public org . w3c . dom .  Element sign XML ( org . w3c . dom .  Document doc , java . lang .  String cert Alias , java . lang .  String algorithm , java . lang .  String id ) throws  XMLSignature Exception { return sign XML ( doc , cert Alias , algorithm ,  DEF_ ID_ ATTRIBUTE , id , _ BOOL , null ) ; }
public void read Turns ( final int [ ] columns Indices , final  Buffered Reader reader ) throws  IOException {  String line = reader . read Line ( ) ; while ( line != null && line . length ( ) > _ NUM ) { line = reader . read Line ( ) ; } }
public  Component Config Builder add Item In Fieldset (  String fieldset Label ,  String item Type ,  String item Label ,  String value ) {  String type =  String . format ( _ STR , item Type ) ;  String label =  String . format ( _ STR , fieldset Label , item Label ) ; config . add ( new  Configuration Entry ( current Tab , type , label , value ) ) ; return this ; }
private static int [ ] [ ] compile Sizes ( final int parameters , final int order , final  DSCompiler value Compiler ) { final int [ ] [ ] sizes = new int [ parameters + _ NUM ] [ order + _ NUM ] ; if ( parameters == _ NUM ) {  Arrays . fill ( sizes [ _ NUM ] , _ NUM ) ; } else {  System . arraycopy ( value Compiler . sizes , _ NUM , sizes , _ NUM , parameters ) ; sizes [ parameters ] [ _ NUM ] = _ NUM ; for ( int i = _ NUM ; i < order ; ++ i ) { sizes [ parameters ] [ i + _ NUM ] = sizes [ parameters ] [ i ] + sizes [ parameters - _ NUM ] [ i + _ NUM ] ; } } return sizes ; }
public boolean is Session Token (  String site ,  String token ) { if ( ! site . contains ( _ STR ) ) { site = site + ( _ STR ) ; }  Http Session Tokens Set site Tokens = session Tokens . get ( site ) ; if ( site Tokens == null ) return _ BOOL ; return site Tokens . is Session Token ( token ) ; }
public static  String strip Version From Rest Name (  String rest Name ) {  Preconditions . check Not Null ( rest Name ) ;  String version = extract Default Major Version From Rest Name ( rest Name ) ;  String [ ] segs = rest Name . split ( _ STR ) ; if ( segs . length > _ NUM ) { version = version + _ STR ; } return rest Name . starts With ( version ) ? rest Name . substring ( version . length ( ) ) : rest Name ; }
private static  Vec4  Spherical To Cartesian ( double latitude , double longitude , float radius ) { latitude *=  Math .  PI / _ NUM ; longitude *=  Math .  PI / _ NUM ; double rad Cos Lat = radius *  Math . cos ( latitude ) ; return new  Vec4 ( rad Cos Lat *  Math . sin ( longitude ) , ( double ) radius *  Math . sin ( latitude ) , rad Cos Lat *  Math . cos ( longitude ) ) ; }
public boolean start Using Data Socket ( ) { try { data Socket = local Data Socket . on Transfer ( ) ; if ( data Socket == null ) {  Log . i (  TAG , _ STR ) ; return _ BOOL ; } data Output Stream = data Socket . get Output Stream ( ) ; return _ BOOL ; } catch (  IOException e ) {  Log . i (  TAG , _ STR ) ; data Socket = null ; return _ BOOL ; } }
private  Stack graham Scan (  Coordinate [ ] c ) {  Coordinate p ;  Stack ps = new  Stack ( ) ; p = (  Coordinate ) ps . push ( c [ _ NUM ] ) ; p = (  Coordinate ) ps . push ( c [ _ NUM ] ) ; p = (  Coordinate ) ps . push ( c [ _ NUM ] ) ; for ( int i = _ NUM ; i < c . length ; i ++ ) { p = (  Coordinate ) ps . pop ( ) ; while ( ! ps . empty ( ) &&  CGAlgorithms . compute Orientation ( (  Coordinate ) ps . peek ( ) , p , c [ i ] ) > _ NUM ) { p = (  Coordinate ) ps . pop ( ) ; } p = (  Coordinate ) ps . push ( p ) ; p = (  Coordinate ) ps . push ( c [ i ] ) ; } p = (  Coordinate ) ps . push ( c [ _ NUM ] ) ; return ps ; }
protected void sync Provider (  Uri uri ,  String account Name ,  String authority ) throws  Exception {  Bundle extras = new  Bundle ( ) ; extras . put Boolean (  Content Resolver .  SYNC_ EXTRAS_ IGNORE_ SETTINGS , _ BOOL ) ;  Account account = new  Account ( account Name , _ STR ) ;  Content Resolver . request Sync ( account , authority , extras ) ; long start Time In Millis =  System Clock . elapsed Realtime ( ) ; long end Time In Millis = start Time In Millis +  MAX_ TIME_ FOR_ SYNC_ IN_ MINS * _ NUM ; int counter = _ NUM ; while ( counter < _ NUM ) {  Thread . sleep ( _ NUM ) ; if (  System Clock . elapsed Realtime ( ) > end Time In Millis ) { break ; } if (  Content Resolver . is Sync Active ( account , authority ) ) { counter = _ NUM ; continue ; } counter ++ ; } }
public  CART load (  String file Name ) throws  IOException ,  Mary Configuration Exception {  File Input Stream fis = new  File Input Stream ( file Name ) ; try { return load From Stream ( fis ) ; } finally { fis . close ( ) ; } }
public static void subtract In Place Unsafe ( double [ ] x , double [ ] y ) { for ( int i = _ NUM ; i < x . length ; ++ i ) { if (  Double . is Na N ( x [ i ] - y [ i ] ) ) { continue ; } x [ i ] -= y [ i ] ; } }
void move ( boolean move Up ) { final  ISelection selection = f Table Viewer . get Selection ( ) ; if ( selection instanceof  IStructured Selection ) { final  IStructured Selection ss = (  IStructured Selection ) selection ; final  String selected = (  String ) ss . get First Element ( ) ; int index = f Location List . index Of ( selected ) ; if ( move Up && index - _ NUM >= _ NUM ) { f Location List . remove ( index ) ; f Location List . add ( index - _ NUM , selected ) ; f Table Viewer . refresh ( ) ; update Enablement Move Buttons ( ss ) ; } else if ( ! move Up && index + _ NUM < f Location List . size ( ) ) { f Location List . remove ( index ) ; f Location List . add ( index + _ NUM , selected ) ; f Table Viewer . refresh ( ) ; update Enablement Move Buttons ( ss ) ; } } }
public  JDTRefactoring Descriptor Comment ( final  String project , final  Object object , final  String header ) {  Assert . is Not Null ( object ) ;  Assert . is Not Null ( header ) ; f Project = project ; f Header = header ; initialize Inferred Settings ( object ) ; }
public static int find Global Peak Location ( double [ ] data ) { double max =  Double .  Na N ; int imax = - _ NUM ; for ( int i = _ NUM ; i < data . length ; i ++ ) { if (  Double . is Na N ( data [ i ] ) ) continue ; if (  Double . is Na N ( max ) || data [ i ] > max ) { max = data [ i ] ; imax = i ; } } return imax ; }
public double pruned Wide (  Prior prior ,  Likelihood likelihood ) throws  Operator Failed Exception { final int node Count = tree . get Node Count ( ) ; final  Node Ref root = tree . get Root ( ) ;  Node Ref i ; int index I ; do { index I =  Math Utils . next Int ( node Count ) ; i = tree . get Node ( index I ) ; } while ( root == i || ( tree . get Parent ( i ) == root && tree . get Node Height ( i ) > tree . get Node Height ( get Other Child ( tree , tree . get Parent ( i ) , i ) ) ) ) ;  List <  Integer > second Node Indices = new  Array List <  Integer > ( ) ;  List <  Double > probabilities = new  Array List <  Double > ( ) ;  Node Ref j , j P ;  Node Ref i P = tree . get Parent ( i ) ; double height IP = tree . get Node Height ( i P ) ; double height I = tree . get Node Height ( i ) ; double sum = _ NUM ; double backward = calculate Tree Likelihood ( prior , likelihood , tree ) ; int offset = ( int ) - backward ; backward =  Math . exp ( backward + offset ) ; for ( int n = _ NUM ; n < node Count ; n ++ ) { j = tree . get Node ( n ) ; if ( j != root ) { j P = tree . get Parent ( j ) ; if ( ( i P != j P ) && ( tree . get Node Height ( j ) < height IP ) && ( height I < tree . get Node Height ( j P ) ) && get Node Distance ( i P , j P ) <=  MAX_ DISTANCE ) { second Node Indices . add ( n ) ; swap ( tree , i , j , i P , j P ) ; double prob =  Math . exp ( calculate Tree Likelihood ( prior , likelihood , tree ) + offset ) ; probabilities . add ( prob ) ; swap ( tree , i , j , j P , i P ) ; sum += prob ; } } } if ( sum <= _ NUM ) { throw new  Operator Failed Exception ( _ STR ) ; } double ran =  Math . random ( ) * sum ; int index = _ NUM ; while ( ran > _ NUM ) { ran -= probabilities . get ( index ) ; index ++ ; } index -- ; j = tree . get Node ( second Node Indices . get ( index ) ) ; j P = tree . get Parent ( j ) ; double height JP = tree . get Node Height ( j P ) ; double height J = tree . get Node Height ( j ) ; double sum Forward2 = _ NUM ;  Node Ref k , k P ; for ( int n = _ NUM ; n < node Count ; n ++ ) { k = tree . get Node ( n ) ; if ( k != root ) { k P = tree . get Parent ( k ) ; if ( ( j P != k P ) && ( tree . get Node Height ( k ) < height JP ) && ( height J < tree . get Node Height ( k P ) ) && get Node Distance ( k P , j P ) <=  MAX_ DISTANCE ) { swap ( tree , j , k , j P , k P ) ; double prob =  Math . exp ( calculate Tree Likelihood ( prior , likelihood , tree ) + offset ) ; sum Forward2 += prob ; swap ( tree , j , k , k P , j P ) ; } } } swap ( tree , i , j , i P , j P ) ; double forward = probabilities . get ( index ) ; i P = j P ; height IP = height JP ; double sum Backward = _ NUM ; for ( int n = _ NUM ; n < node Count ; n ++ ) { j = tree . get Node ( n ) ; if ( j != root ) { j P = tree . get Parent ( j ) ; if ( ( i P != j P ) && ( tree . get Node Height ( j ) < height IP ) && ( height I < tree . get Node Height ( j P ) ) && get Node Distance ( i P , j P ) <=  MAX_ DISTANCE ) { swap ( tree , i , j , i P , j P ) ; double prob =  Math . exp ( calculate Tree Likelihood ( prior , likelihood , tree ) + offset ) ; sum Backward += prob ; swap ( tree , i , j , j P , i P ) ; } } } double sum Backward2 = _ NUM ; j = tree . get Node ( second Node Indices . get ( index ) ) ; j P = tree . get Parent ( j ) ; height JP = tree . get Node Height ( j P ) ; height J = tree . get Node Height ( j ) ; for ( int n = _ NUM ; n < node Count ; n ++ ) { k = tree . get Node ( n ) ; if ( k != root ) { k P = tree . get Parent ( k ) ; if ( ( j P != k P ) && ( tree . get Node Height ( k ) < height JP ) && ( height J < tree . get Node Height ( k P ) ) && get Node Distance ( k P , j P ) <=  MAX_ DISTANCE ) { swap ( tree , j , k , j P , k P ) ; double prob =  Math . exp ( calculate Tree Likelihood ( prior , likelihood , tree ) + offset ) ; sum Backward2 += prob ; swap ( tree , j , k , k P , j P ) ; } } } double forward Prob = ( forward / sum ) + ( forward / sum Forward2 ) ; double backward Prob = ( backward / sum Backward ) + ( backward / sum Backward2 ) ; double hastings Ratio =  Math . log ( backward Prob / forward Prob ) ; return hastings Ratio ; }
public boolean is Output Column Name Allowed (  String column Name ) { if ( column Name == null || column Name . length ( ) == _ NUM ) return _ BOOL ; get Output Column Names ( _ BOOL ) ; for ( int i = _ NUM ; i < m_outputcolumnnames . length ; i ++ ) { if ( column Name . equals ( m_outputcolumnnames [ i ] ) ) return _ BOOL ; } return _ BOOL ; }
public void test Field Types ( ) throws  Exception {  Prepared Statement ps = connection . prepare Statement ( _ STR ) ; for ( int i = _ NUM ; i <  TEST_ ROW_ COUNT ; i ++ ) { ps . set Int ( _ NUM , i ) ; ps . set Bytes ( _ NUM , test Data [ i ] ) ; ps . execute Update ( ) ; } ps . close ( ) ;  Statement stmt = connection . create Statement ( ) ;  Result Set rs = stmt . execute Query ( _ STR ) ; try { int counter = _ NUM ; while ( rs . next ( ) ) { int id = rs . get Int ( _ STR ) ; byte [ ] data = rs . get Bytes ( _ STR ) ; assert True ( _ STR + id + _ STR ,  Arrays . equals ( test Data [ id ] , data ) ) ; counter ++ ; } assert True ( _ STR +  TEST_ ROW_ COUNT + _ STR + counter ,  TEST_ ROW_ COUNT == counter ) ; } finally { rs . close ( ) ; stmt . close ( ) ; } }
private synchronized void rebuild Journal ( ) throws  IOException { if ( journal Writer != null ) { journal Writer . close ( ) ; }  Writer writer = new  Buffered Writer ( new  Output Stream Writer ( new  File Output Stream ( journal File Tmp ) ,  Util .  US_ ASCII ) ) ; try { writer . write (  MAGIC ) ; writer . write ( _ STR ) ; writer . write (  VERSION_1 ) ; writer . write ( _ STR ) ; writer . write (  Integer . to String ( app Version ) ) ; writer . write ( _ STR ) ; writer . write (  Integer . to String ( value Count ) ) ; writer . write ( _ STR ) ; writer . write ( _ STR ) ; for (  Entry entry : lru Entries . values ( ) ) { if ( entry . current Editor != null ) { writer . write (  DIRTY + _ STR + entry . key + _ STR ) ; } else { writer . write (  CLEAN + _ STR + entry . key + entry . get Lengths ( ) + _ STR ) ; } } } finally { writer . close ( ) ; } if ( journal File . exists ( ) ) { rename To ( journal File , journal File Backup , _ BOOL ) ; } rename To ( journal File Tmp , journal File , _ BOOL ) ; journal File Backup . delete ( ) ; journal Writer = new  Buffered Writer ( new  Output Stream Writer ( new  File Output Stream ( journal File , _ BOOL ) ,  Util .  US_ ASCII ) ) ; }
@  Suppress Warnings ( _ STR ) public void load History (  String filename ) throws  Exception {  File Input Stream fis = new  File Input Stream ( filename ) ;  Object Input Stream ois = new  Object Input Stream ( fis ) ; set History ( (  Map <  Double ,  Double > ) ois . read Object ( ) ) ; ois . close ( ) ; }
public void notify Listeners Of Initialization ( ) { if ( initialized ) { for (  Action Listener l : listeners ) { l . action Performed ( new  Action Event ( this ,  Action Event .  ACTION_ PERFORMED , _ STR ) ) ; } } }
private void blackman Harris4s ( int size ) { int start = ( window Function . length - size ) / _ NUM ; int stop = ( window Function . length + size ) / _ NUM ; double scale = _ NUM / ( double ) size / _ NUM ; for ( int i = _ NUM ; start < stop ; start ++ , i ++ ) window Function [ i ] = scale * ( _ NUM - _ NUM *  Math . cos ( two PI * i / size ) + _ NUM *  Math . cos ( _ NUM * two PI * i / size ) - _ NUM *  Math . cos ( _ NUM * two PI * i / size ) ) ; }
public int hash Code ( ) { int hash Code = this . hash Code ; if ( hash Code == _ NUM ) { hash Code = ( ( group Id . hash Code ( ) * _ NUM + artifact Id . hash Code ( ) ) * _ NUM + version . hash Code ( ) ) * _ NUM + classifier . hash Code ( ) ; if ( hash Code == _ NUM ) { hash Code = - _ NUM ; } this . hash Code = hash Code ; } return hash Code ; }
private void update ( boolean forced ) { long now =  System . current Time Millis ( ) ; long diff = now - this . last Update Rt ; double dur = ( now - start Time ) / _ NUM ; if ( forced || ( diff >  UI_ UP_ INTERVAL ) ) { double ssps = ( (  Sim Clock . get Time ( ) - last Update ) * _ NUM ) / diff ; print (  String . format ( _ STR , dur ,  Sim Clock . get Int Time ( ) , ssps ) ) ; this . last Update Rt =  System . current Time Millis ( ) ; this . last Update =  Sim Clock . get Time ( ) ; } }
protected  Conversation Parser ( final  Sentence Implementation sentence ) {  String text = sentence . get Original Text ( ) ; if ( text == null ) { text = _ STR ; } else if ( text . starts With ( _ STR ) ) { text = _ STR ; } final  String text Without Punctation = detect Sentence Type ( text , sentence ) ; tokenizer = new  String Tokenizer ( text Without Punctation ) ; }
public void tear Down (  Proxy Test Case test Case ) throws  Exception { if ( _ BOOL && data Dir . exists ( ) && data Dir . is Directory ( ) ) { recursive Delete ( data Dir ) ; } }
protected boolean check Special Position (  Element current Rule Part ,  String special Position Type ) {  Named Node Map att Nodes = current Rule Part . get Attributes ( ) ; for ( int z = _ NUM ; z < att Nodes . get Length ( ) ; z ++ ) {  Node el = att Nodes . item ( z ) ;  String current Att = el . get Node Name ( ) ;  String current Val = el . get Node Value ( ) ; if ( current Att . equals ( _ STR ) ) { if ( ! current Val . starts With ( _ STR ) ) { if ( ! special Position Type . equals ( current Val ) ) return _ BOOL ; } else { current Val = current Val . substring ( _ NUM , current Val . length ( ) ) ; if ( special Position Type . equals ( current Val ) ) return _ BOOL ; } } } return _ BOOL ; }
public static  Configuration load (  String path ,  Class Loader class Loader ,  Consumer <  String > logger ) throws  IOException { try (  Input Stream stream =  Io Util . get Resource As Stream ( path , class Loader , null , null , logger ) ) {  Properties props = new  Properties ( ) ; if ( stream != null ) { props . load ( stream ) ; } return from ( props ) ; } }
public  Set create Sub Group Containers (  Set group Container Names ) throws  AMException ,  SSOException {  Iterator iter = group Container Names . iterator ( ) ;  Set group Containers = new  Hash Set ( ) ; while ( iter . has Next ( ) ) {  String group Container DN =  AMNaming Attr Manager . get Naming Attr (  GROUP_ CONTAINER ) + _ STR + ( (  String ) iter . next ( ) ) + _ STR + entry DN ;  AMGroup Container Impl group Container Impl = new  AMGroup Container Impl ( token , group Container DN ) ; group Container Impl . create ( ) ; group Containers . add ( group Container Impl ) ; } return group Containers ; }
public void schedule (  Timer Task task ,  Date when , long period ) { if ( period <= _ NUM || when . get Time ( ) < _ NUM ) { throw new  Illegal Argument Exception ( ) ; } long delay = when . get Time ( ) -  System . current Time Millis ( ) ; schedule Impl ( task , delay < _ NUM ? _ NUM : delay , period , _ BOOL ) ; }
private  Object load Object (  String class Name ,  Class < ? > [ ] args Class ,  Object [ ] args ) {  Object o = null ;  Class < ? > obj Class = get Class ( class Name ) ;  Constructor < ? > constructor ; try { if ( args Class != null ) { constructor = obj Class . get Constructor ( (  Class [ ] ) args Class ) ; o = constructor . new Instance ( args ) ; } else { o = obj Class . new Instance ( ) ; } } catch (  Security Exception e ) { e . print Stack Trace ( ) ; throw new  Settings Error ( _ STR + e , e ) ; } catch (  Illegal Argument Exception e ) { e . print Stack Trace ( ) ; throw new  Settings Error ( _ STR + e , e ) ; } catch (  No Such Method Exception e ) { throw new  Settings Error ( _ STR + class Name + _ STR , e ) ; } catch (  Instantiation Exception e ) { throw new  Settings Error ( _ STR + class Name + _ STR , e ) ; } catch (  Illegal Access Exception e ) { e . print Stack Trace ( ) ; throw new  Settings Error ( _ STR + e , e ) ; } catch (  Invocation Target Exception e ) { if ( e . get Cause ( ) instanceof  Settings Error ) { throw (  Settings Error ) e . get Cause ( ) ; } else { e . print Stack Trace ( ) ; throw new  Sim Error ( _ STR + _ STR + class Name + _ STR + _ STR + e . get Cause ( ) , e ) ; } } return o ; }
public static native boolean embedded Init ( ) ;
public static byte [ ] object To Bytes (  Object obj ) throws java . io .  IOException {  Byte Array Output Stream bos = new  Byte Array Output Stream ( ) ;  Object Output Stream oos = new  Object Output Stream ( bos ) ; oos . write Object ( obj ) ; oos . flush ( ) ; oos . close ( ) ; bos . close ( ) ; byte [ ] data = bos . to Byte Array ( ) ; return data ; }
public static boolean is Java Identifier ( final  String str ) { if ( str == null || str . length ( ) < _ NUM ) { return _ BOOL ; } if ( !  Character . is Java Identifier Start ( str . char At ( _ NUM ) ) ) { return _ BOOL ; } for ( int i = _ NUM ; i < str . length ( ) ; i ++ ) { if ( !  Character . is Java Identifier Part ( str . char At ( i ) ) ) { return _ BOOL ; } } return _ BOOL ; }
static boolean less Than Unsigned ( long x1 , long x2 ) { return ( x1 +  Long .  MIN_ VALUE ) < ( x2 +  Long .  MIN_ VALUE ) ; }
public void update Track Point (  Point p ) { int new Loc X =  Math . min ( p . x , this . anchor . x ) ; int new Loc Y =  Math . min ( p . y , this . anchor . y ) ; int delta X =  Math . abs ( p . x - this . anchor . x ) ; int delta Y =  Math . abs ( p . y - this . anchor . y ) ; set Location ( new Loc X , new Loc Y ) ; set Size ( delta X , delta Y ) ; }
public void load Config (  Configuration Section config ) {  Configuration Section general = config . get Configuration Section ( _ STR ) ; if ( general != null ) { for (  String key : general . get Keys ( _ BOOL ) ) {  Configuration Section topic = general . get Configuration Section ( key ) ; if ( topic != null ) {  String short Text = topic . get String ( _ STR , _ STR ) ;  String full Text = topic . get String ( _ STR , _ STR ) ; if ( ! short Text . is Empty ( ) ) { if ( full Text . is Empty ( ) ) { full Text = short Text ; } else { full Text = short Text + _ STR +  Chat Color .  RESET + full Text ; } } add Topic ( new  General Help Topic ( key , color ( short Text ) , color ( full Text ) , topic . get String ( _ STR , null ) ) ) ; } } }  Configuration Section index = config . get Configuration Section ( _ STR ) ; if ( index != null ) { for (  String key : index . get Keys ( _ BOOL ) ) {  Configuration Section topic = index . get Configuration Section ( key ) ; if ( topic != null ) {  String short Text = color ( topic . get String ( _ STR , _ STR ) ) ;  String preamble = color ( topic . get String ( _ STR , null ) ) ;  String permission = topic . get String ( _ STR , null ) ;  Help Topic help Topic = new  Lazy Index Topic ( key , short Text , permission , topic . get String List ( _ STR ) , preamble ) ; if ( key . equals ( _ STR ) ) { default Topic = help Topic ; } else { add Topic ( help Topic ) ; } } } } ignored Plugins . add All ( config . get String List ( _ STR ) ) ; commands In Index = config . get Boolean ( _ STR , _ BOOL ) ; }
public  Chat Fragment Builder add Email (  String email ) { emails . add ( email ) ; return this ; }
public static  Hash Provider best (  Hash Parameters params ,  Enum Set <  Hash Support > required ) {  Hash Provider result = null ;  Enum Set <  Hash Support > result Support = null ; for ( final  Hash Provider provider :  ALL_ PROVIDERS ) { final  Enum Set <  Hash Support > support = provider . query Support ( params ) ; if ( support . contains All ( required ) && ( result == null ||  Hash Support . compare ( support , result Support ) < _ NUM ) ) { result = provider ; result Support = support ; } } if ( result == null ) throw new  Unsupported Operation Exception ( ) ; return result ; }
public byte [ ] read Raw Bytes ( final int size ) throws  IOException { if ( size < _ NUM ) { throw  Invalid Protocol Buffer Exception . negative Size ( ) ; } if ( total Bytes Retired + buffer Pos + size > current Limit ) { skip Raw Bytes ( current Limit - total Bytes Retired - buffer Pos ) ; throw  Invalid Protocol Buffer Exception . truncated Message ( ) ; } if ( size <= buffer Size - buffer Pos ) { final byte [ ] bytes = new byte [ size ] ;  System . arraycopy ( buffer , buffer Pos , bytes , _ NUM , size ) ; buffer Pos += size ; return bytes ; } else if ( size <  BUFFER_ SIZE ) { final byte [ ] bytes = new byte [ size ] ; int pos = buffer Size - buffer Pos ;  System . arraycopy ( buffer , buffer Pos , bytes , _ NUM , pos ) ; buffer Pos = buffer Size ; refill Buffer ( _ BOOL ) ; while ( size - pos > buffer Size ) {  System . arraycopy ( buffer , _ NUM , bytes , pos , buffer Size ) ; pos += buffer Size ; buffer Pos = buffer Size ; refill Buffer ( _ BOOL ) ; }  System . arraycopy ( buffer , _ NUM , bytes , pos , size - pos ) ; buffer Pos = size - pos ; return bytes ; } else { final int original Buffer Pos = buffer Pos ; final int original Buffer Size = buffer Size ; total Bytes Retired += buffer Size ; buffer Pos = _ NUM ; buffer Size = _ NUM ; int size Left = size - ( original Buffer Size - original Buffer Pos ) ; final  List < byte [ ] > chunks = new  Array List < byte [ ] > ( ) ; while ( size Left > _ NUM ) { final byte [ ] chunk = new byte [  Math . min ( size Left ,  BUFFER_ SIZE ) ] ; int pos = _ NUM ; while ( pos < chunk . length ) { final int n = ( input == null ) ? - _ NUM : input . read ( chunk , pos , chunk . length - pos ) ; if ( n == - _ NUM ) { throw  Invalid Protocol Buffer Exception . truncated Message ( ) ; } total Bytes Retired += n ; pos += n ; } size Left -= chunk . length ; chunks . add ( chunk ) ; } final byte [ ] bytes = new byte [ size ] ; int pos = original Buffer Size - original Buffer Pos ;  System . arraycopy ( buffer , original Buffer Pos , bytes , _ NUM , pos ) ; for ( final byte [ ] chunk : chunks ) {  System . arraycopy ( chunk , _ NUM , bytes , pos , chunk . length ) ; pos += chunk . length ; } return bytes ; } }
static boolean pair Diff ( int ar [ ] , int x ) {  Arrays . sort ( ar ) ; int len = ar . length ; for ( int i = _ NUM , j = _ NUM ; i < len && j < len ; ) { if ( i != j && ar [ j ] - ar [ i ] == x ) { return _ BOOL ; } else if ( ar [ j ] - ar [ i ] < x ) { j ++ ; } else { i ++ ; } } return _ BOOL ; }
public synchronized void import From File ( ) {  Path file =  Paths . get ( import File Name ) ; try (  Buffered Reader reader =  Files . new Buffered Reader ( file ,  CHARSET ) ) {  LOGGER . info ( _ STR + file . to Absolute Path ( ) ) ;  String line ; while ( ( line = reader . read Line ( ) ) != null ) {  String result = command ( line ) ;  LOGGER . info (  String . format ( _ STR , result , line ) ) ; } } catch (  IOException ex ) {  LOGGER . warning ( _ STR + ex ) ; } }
public static  Matrix back Sub (  Matrix  U ,  Matrix y ) { if ( y . rows ( ) !=  U . rows ( ) ) throw new  Arithmetic Exception ( _ STR ) ;  Matrix x = new  Dense Matrix (  U . cols ( ) , y . cols ( ) ) ; double [ ] x_col_k = new double [ y . rows ( ) ] ; final int start =  Math . min (  U . rows ( ) ,  U . cols ( ) ) - _ NUM ; for ( int k = _ NUM ; k < y . cols ( ) ; k ++ ) { for ( int i = start ; i >= _ NUM ; i -- ) { x_col_k [ i ] = y . get ( i , k ) ; for ( int j = i + _ NUM ; j <= start ; j ++ ) x_col_k [ i ] -=  U . get ( i , j ) * x_col_k [ j ] ; x_col_k [ i ] /=  U . get ( i , i ) ; } for ( int i = _ NUM ; i < x_col_k . length ; i ++ ) if (  Double . is Infinite ( x_col_k [ i ] ) ) x . set ( i , k , _ NUM ) ; else x . set ( i , k , x_col_k [ i ] ) ; } return x ; }
public boolean add ( final  T item ) { final  Adapter Transaction add Transaction = new  Add Transaction < > ( this , item ) ; final boolean success = add Transaction . perform ( ) ; m Transactions . offer ( add Transaction ) ; return success ; }
private  List <  Type > parse Type List (  List <  Map <  String ,  Object > > types ,  List <  Type Parameter > type Params ) {  List <  Type > ts = new  Array List <  Type > ( types . size ( ) ) ; for (  Map <  String ,  Object > st : types ) { ts . add ( get Type From Json ( st , null , type Params ) ) ; } return ts ; }
public void clear ( ) { data Dimension Items . clear ( ) ; periods . clear ( ) ; relatives = null ; organisation Units . clear ( ) ; data Element Groups . clear ( ) ; organisation Unit Groups . clear ( ) ; organisation Unit Levels . clear ( ) ; category Dimensions . clear ( ) ; category Option Groups . clear ( ) ; attribute Dimensions . clear ( ) ; data Element Dimensions . clear ( ) ; program Indicator Dimensions . clear ( ) ; user Organisation Unit = _ BOOL ; user Organisation Unit Children = _ BOOL ; user Organisation Unit Grand Children = _ BOOL ; item Organisation Unit Groups . clear ( ) ; }
public void build (  String code ) { try { result . put ( resources . get String (  R . string . intent_extra_status ) , resources . get String (  R . string . shared_pref_default_status ) ) ; result . put ( resources . get String (  R . string . intent_extra_code ) , code ) ; operation List Result . put ( result ) ; } catch (  JSONException e ) {  Log . e (  TAG , _ STR + e . to String ( ) ) ; } }
public static void create Index (  Connection conn ,  String schema ,  String table ,  String column List ) throws  SQLException { init ( conn ) ;  Prepared Statement prep = conn . prepare Statement ( _ STR +  SCHEMA + _ STR ) ; prep . set String ( _ NUM , schema ) ; prep . set String ( _ NUM , table ) ; prep . set String ( _ NUM , column List ) ; prep . execute ( ) ; create Trigger ( conn , schema , table ) ; index Existing Rows ( conn , schema , table ) ; }
public long start_brk ( ) { return  Long . parse Long ( fields [ _ NUM ] ) ; }
public static void delete Realm Privileges (  SSOToken token ,  String realm Name ) throws  SSOException ,  Delegation Exception {  Delegation Manager dm = new  Delegation Manager ( token , realm Name ) ;  Set privs = dm . get Privileges ( ) ; if ( ( privs == null ) || privs . is Empty ( ) ) { return ; }  Iterator it = privs . iterator ( ) ; while ( it . has Next ( ) ) {  Delegation Privilege dp = (  Delegation Privilege ) it . next ( ) ;  String priv Name = dp . get Name ( ) ; dm . remove Privilege ( priv Name ) ; if ( debug . message Enabled ( ) ) { debug . message ( _ STR + priv Name + _ STR + realm Name ) ; } } }
@  Override public boolean equals (  Object o ) { if ( o == this ) return _ BOOL ; if ( ! ( o instanceof  Record ) ) return _ BOOL ;  Record other = (  Record ) o ; return ( name == null ? other . name == null : name . equals ( other . name ) ) && ( type == null ? other . type == null : type . equals ( other . type ) ) && ( location == null ? other . location == null : location . equals ( other . location ) ) && ( metadata == null ? other . metadata == null : metadata . equals ( other . metadata ) ) && ( registration == null ? other . registration == null : registration . equals ( other . registration ) ) && ( status == null ? other . status == null : status . equals ( other . status ) ) ; }
@  Override public boolean is Armed ( ) { boolean b = should Act Like Button ( ) || ( pressed When Popup Visible && combo Box . is Popup Visible ( ) ) ; return b ? is Pressed ( ) : super . is Armed ( ) ; }
public  Encoder Test Suite Builder invalid ( int min , int max ) { _invalid . set ( min , max + _ NUM ) ; _valid . clear ( min , max + _ NUM ) ; _encoded . clear ( min , max + _ NUM ) ; return this ; }
private void log Descriptors (  List <  Volume Descriptor > descriptors ) {  String Buffer buf = new  String Buffer ( ) ; buf . append (  String . format (  NEW_ LINE ) ) ; buf . append (  String . format ( _ STR ) ) ; for (  Volume Descriptor desc : descriptors ) {  Volume volume = _db Client . query Object (  Volume . class , desc . get Volume URI ( ) ) ; buf . append (  String . format ( _ STR , volume . get Label ( ) , desc . get Type ( ) , desc . to String ( ) ) ) ; } buf . append (  String . format (  NEW_ LINE ) ) ; _log . info ( buf . to String ( ) ) ; }
public static boolean invalid Captcha ( final  String captcha , final  Http Servlet Request request ) { final  Http Session session = request . get Session ( _ BOOL ) ; if ( null == session ) { return _ BOOL ; } if (  Strings . is Empty Or Null ( captcha ) || captcha . length ( ) !=  CAPTCHA_ LENGTH ) { return _ BOOL ; } final  String stored Captcha = (  String ) session . get Attribute (  Captcha Processor .  CAPTCHA ) ; if ( null == stored Captcha || ! stored Captcha . equals ( captcha ) ) { return _ BOOL ; } session . remove Attribute (  Captcha Processor .  CAPTCHA ) ; return _ BOOL ; }
public boolean equals (  Object obj ) { if ( this == obj ) return _ BOOL ; if ( this ==  POINT_ INFINITY ) return _ BOOL ; if ( obj instanceof  ECPoint ) { return ( ( x . equals ( ( (  ECPoint ) obj ) . x ) ) && ( y . equals ( ( (  ECPoint ) obj ) . y ) ) ) ; } return _ BOOL ; }
private static  String  H (  String data ) { try {  Message Digest digest =  Message Digest . get Instance ( _ STR ) ; return to Hex String ( digest . digest ( data . get Bytes ( ) ) ) ; } catch (  No Such Algorithm Exception ex ) { throw new  Runtime Exception ( _ STR , ex ) ; } }
private  List <  String > fetch Titles (  String category ) throws  Speechlet Exception {  List <  String > titles = new  Linked List <  String > ( ) ; try {  Document Builder Factory dbf =  Document Builder Factory . new Instance ( ) ;  Document Builder db = dbf . new Document Builder ( ) ;  Document doc = db . parse ( get Request Url ( category ) ) ;  Node List node List = doc . get Elements By Tag Name ( _ STR ) ; for ( int i = _ NUM ; i < node List . get Length ( ) ; i ++ ) {  Node node = node List . item ( i ) ; titles . add ( node . get Text Content ( ) ) ; } } catch (  Exception e ) { throw new  Speechlet Exception ( e ) ; } return titles ; }
public  Str Builder insert ( int index ,  Object obj ) { if ( obj == null ) { return insert ( index , null Text ) ; } return insert ( index , obj . to String ( ) ) ; }
@  Override public void handle Mouse Pressed (  Chart Canvas canvas ,  Mouse Event e ) {  Point2 D pt = new  Point2 D .  Double ( e . get X ( ) , e . get Y ( ) ) ;  Rectangle2 D data Area = canvas . find Data Area ( pt ) ; if ( data Area != null ) { this . start Point =  Shape Utilities . get Point In Rectangle ( e . get X ( ) , e . get Y ( ) , data Area ) ; } else { this . start Point = null ; canvas . clear Live Handler ( ) ; } }
public static void concat (  Iterable <  File > to Merge ,  File dst ) throws  IOException { try (  File Channel dst Channel =  File Channel . open ( dst . to Path ( ) ,  Standard Open Option .  CREATE ,  Standard Open Option .  TRUNCATE_ EXISTING ,  Standard Open Option .  WRITE ) ) { for (  File file : to Merge ) { try (  Random Access File raf = new  Random Access File ( file , _ STR ) ) {  File Channel channel = raf . get Channel ( ) ; dst Channel . write ( channel . map (  File Channel .  Map Mode .  READ_ ONLY , _ NUM , raf . length ( ) ) ) ; } } } }
private boolean is VMAX3 Volume (  Volume volume ) { boolean is VMAX3 = _ BOOL ; if (  URIUtil . is Type ( volume . get Storage Controller ( ) ,  Storage System . class ) ) {  Storage System storage = _db Client . query Object (  Storage System . class , volume . get Storage Controller ( ) ) ; is VMAX3 = ( storage != null && storage . check If Vmax3 ( ) ) ; } return is VMAX3 ; }
public static  Lat Lon great Circle End Position (  Lat Lon p , double great Circle Azimuth Radians , double path Length Radians ) { if ( p == null ) { throw new  Illegal Argument Exception ( _ STR ) ; } return great Circle End Position ( p ,  Angle . from Radians ( great Circle Azimuth Radians ) ,  Angle . from Radians ( path Length Radians ) ) ; }
public  Dimension maximum Layout Size (  Container target ) {  Dimension size ; synchronized ( this ) { check Container ( target ) ; check Requests ( ) ; size = new  Dimension ( x Total . maximum , y Total . maximum ) ; }  Insets insets = target . get Insets ( ) ; size . width = ( int )  Math . min ( ( long ) size . width + ( long ) insets . left + ( long ) insets . right ,  Integer .  MAX_ VALUE ) ; size . height = ( int )  Math . min ( ( long ) size . height + ( long ) insets . top + ( long ) insets . bottom ,  Integer .  MAX_ VALUE ) ; return size ; }
String pull In Source (  Input Stream in ,  Charset encoding ) {  String script = _ STR ;  Buffered Reader f = null ; try {  String Builder sb = new  String Builder ( ) ;  Reader reader = null ; if ( encoding == null ) reader = new  Input Stream Reader ( in ) ; else reader = new  Input Stream Reader ( in , encoding ) ; f = new  Buffered Reader ( reader ) ;  String line ; while ( ( line = f . read Line ( ) ) != null ) { sb . append ( line ) ; sb . append ( _ STR ) ; } script = sb . to String ( ) ; } catch (  IOException e ) { e . print Stack Trace ( ) ; } return script ; }
public synchronized void remove (  Lease lease ) throws  Unknown Lease Exception {  Entry e = find Entry ( lease ) ; if ( ! remove Lease In Renew ( e ) ) leases . remove ( e ) ; calc Actual Renews ( ) ; logger . log (  Level .  FINE , _ STR , lease ) ; }
public static final int count Lines (  String buffer ) { int count = _ NUM ; int index = buffer . index Of ( _ STR ) ; while ( index != - _ NUM ) { count ++ ; index = buffer . index Of ( _ STR , index + _ NUM ) ; } return count ; }
protected final void write S (  String text , int size ) { if ( text == null ) { buf . put ( new byte [ size ] ) ; } else { final int len = text . length ( ) ; for ( int i = _ NUM ; i < len ; i ++ ) { buf . put Char ( text . char At ( i ) ) ; } buf . put ( new byte [ size - ( len * _ NUM ) ] ) ; } }
@  Override public void on New Frame ( final  Head Transform head Transform ) {  FPSCounter . log Frame ( ) ; if ( pref Show Env && ! bg Env . is Ready ( ) ) { if ( pref Show Env String . equals ( _ STR ) ) bg Env . init ( _ NUM ) ; else bg Env . init ( _ NUM ) ; bg Env . set Fixed Model ( ) ; move Thing ( bg Env ) ; }  Matrix . set Look At M ( m Camera , _ NUM , _ NUM , _ NUM ,  CAMERA_ Z , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM ) ;  GLES20 . gl Clear Color ( r , g , b , a ) ; head Transform . get Head View ( m Head View SDK , _ NUM ) ; m Head View Use = get Head View ( ) ; if ( screen . is Looking At Object ( m Head View Use ) ) { aim Point . set Alpha ( _ NUM ) ; } else { aim Point . set Alpha ( _ NUM ) ; } for (  Button Thing button : button List ) { if ( button . is Looking At Object ( m Head View Use ) && ! button . is Hidden ) { if ( fuse Start == - _ NUM ) { fuse Start =  System Clock . elapsed Realtime ( ) ; fuse Button = button ; } else if ( fuse Button == button ) { check Fuse (  System Clock . elapsed Realtime ( ) ) ; } } else if ( fuse Button == button ) { check Fuse ( _ NUM ) ; fuse Start = - _ NUM ; fuse Button = null ; } }  Engine . check GLError ( _ STR ) ; }
protected int consume Available Records (  Consumer <  Source Record > record Consumer ) {  List <  Source Record > records = new  Linked List < > ( ) ; consumed Lines . drain To ( records ) ; if ( record Consumer != null ) { records . for Each ( record Consumer ) ; } return records . size ( ) ; }
@  Override public boolean equals ( final  Object o ) { if ( this == o ) return _ BOOL ; if ( ! ( o instanceof  Header ) ) { return _ BOOL ; } return name . equals ( ( (  Header ) o ) . name ) ; }
protected  Map <  String ,  Double > load Bing Liu ( ) throws  File Not Found Exception {  Map <  String ,  Double > lexi Map = new  Hash Map <  String ,  Double > ( ) ;  File file = new  File ( _ STR ) ;  Scanner scanner = new  Scanner ( file ) ; while ( scanner . has Next Line ( ) ) { lexi Map . put ( scanner . next Line ( ) , _ NUM ) ; } scanner . close ( ) ;  File file2 = new  File ( _ STR ) ;  Scanner scanner2 = new  Scanner ( file2 ) ; while ( scanner2 . has Next Line ( ) ) { lexi Map . put ( scanner2 . next Line ( ) , - _ NUM ) ; } scanner2 . close ( ) ; return lexi Map ; }
public final boolean is Valid ( ) { return !  Float . is Na N ( x ) && !  Float . is Infinite ( x ) && !  Float . is Na N ( y ) && !  Float . is Infinite ( y ) ; }
public boolean is Plural ( ) { return type String . contains (  SUFFIX_ PLURAL ) ; }
@ edu . umd . cs . findbugs . annotations .  Suppress FBWarnings ( value = _ STR , justification = _ STR ) protected void purge Stream ( @  Nonnull java . io .  Input Stream serial Stream ) throws java . io .  IOException { int count = serial Stream . available ( ) ; log . debug ( _ STR + count + _ STR ) ; while ( count > _ NUM ) { serial Stream . skip ( count ) ; count = serial Stream . available ( ) ; } }
void scroll To Visible ( int target Pos , int bound Pos , int duration ) { final int first Pos = m First Position ; final int child Count = get Child Count ( ) ; final int last Pos = first Pos + child Count - _ NUM ; final int padded Left = m List Padding . left ; final int padded Right = get Width ( ) - m List Padding . right ; if ( target Pos < first Pos || target Pos > last Pos ) {  Log . w (  TAG , _ STR + target Pos + _ STR + first Pos + _ STR + last Pos + _ STR ) ; } if ( bound Pos < first Pos || bound Pos > last Pos ) { bound Pos =  INVALID_ POSITION ; } final  View target Child = get Child At ( target Pos - first Pos ) ; final int target Left = target Child . get Left ( ) ; final int target Right = target Child . get Right ( ) ; int scroll By = _ NUM ; if ( target Right > padded Right ) { scroll By = target Right - padded Right ; } if ( target Left < padded Left ) { scroll By = target Left - padded Left ; } if ( scroll By == _ NUM ) { return ; } if ( bound Pos >= _ NUM ) { final  View bound Child = get Child At ( bound Pos - first Pos ) ; final int bound Left = bound Child . get Left ( ) ; final int bound Right = bound Child . get Right ( ) ; final int abs Scroll =  Math . abs ( scroll By ) ; if ( scroll By < _ NUM && bound Right + abs Scroll > padded Right ) { scroll By =  Math . max ( _ NUM , bound Right - padded Right ) ; } else if ( scroll By > _ NUM && bound Left - abs Scroll < padded Left ) { scroll By =  Math . min ( _ NUM , bound Left - padded Left ) ; } } smooth Scroll By ( scroll By , duration ) ; }
private  Class Vertex resolve Class Vertex (  Class Descriptor class Descriptor ) throws  Class Not Found Exception {  Class Vertex type Vertex = optionally Resolve Class Vertex ( class Descriptor ) ; if ( ! type Vertex . is Resolved ( ) ) {  Class Descriptor . throw Class Not Found Exception ( class Descriptor ) ; } assert type Vertex . is Resolved ( ) ; return type Vertex ; }
public void not ( ) { mv . visit Insn (  Opcodes .  ICONST_1 ) ; mv . visit Insn (  Opcodes .  IXOR ) ; }
@  Override public void load Url (  Tab tab ,  String url ) { load Url ( tab , url , null ) ; }
synchronized void unregister To Notifications ( ) throws  JMSException { if ( event Session == null ) { return ; } if ( _logger . is Loggable (  Level .  FINE ) ) { _logger . log (  Level .  FINE , to String2 ( ) + _ STR ) ; } try { event Session . close ( ) ; } catch (  IOException e ) { if ( _logger . is Loggable (  Level .  FINE ) ) { _logger . log (  Level .  FINE , to String2 ( ) + _ STR + e ) ; }  JMSException e1 = new  JMSException ( _ STR ) ; e1 . set Linked Exception ( e ) ; throw e1 ; } catch (  Unknown Lease Exception e ) { if ( _logger . is Loggable (  Level .  FINE ) ) { _logger . log (  Level .  FINE , to String2 ( ) + _ STR + e ) ; }  JMSException e1 = new  JMSException ( _ STR ) ; e1 . set Linked Exception ( e ) ; throw e1 ; } catch (  Exception e ) { if ( _logger . is Loggable (  Level .  FINE ) ) { _logger . log (  Level .  FINE , to String2 ( ) + _ STR + e ) ; }  JMSException e1 = new  JMSException ( _ STR ) ; e1 . set Linked Exception ( e ) ; throw e1 ; } finally { event Session = null ; } }
JPanel make Button Panel (  Action Listener update Listener ,  Action Listener cancel Listener ,  Action Listener delete Listener ) {  JPanel panel3 = new  JPanel ( ) ; panel3 . set Layout ( new  Box Layout ( panel3 ,  Box Layout .  X_ AXIS ) ) ;  JButton cancel Action = new  JButton (  Bundle . get Message ( _ STR ) ) ; panel3 . add ( cancel Action ) ; panel3 . add (  Box . create Horizontal Strut (  STRUT ) ) ; cancel Action . add Action Listener ( cancel Listener ) ; cancel Action . set Tool Tip Text ( rbx . get String ( _ STR ) ) ;  JButton update Action = new  JButton (  Bundle . get Message ( _ STR ) ) ; panel3 . add ( update Action ) ; panel3 . add (  Box . create Horizontal Strut (  STRUT ) ) ; update Action . add Action Listener ( update Listener ) ; update Action . set Tool Tip Text ( rbx . get String ( _ STR ) ) ;  JButton delete Action = new  JButton (  Bundle . get Message ( _ STR ) ) ; panel3 . add ( delete Action ) ; delete Action . add Action Listener ( delete Listener ) ; delete Action . set Tool Tip Text ( rbx . get String ( _ STR ) ) ; return panel3 ; }
private  Data <  Input ,  Output > derive_ (  Input input ) {  Data <  Input ,  Output > result = new  Data < > ( input , fn_ . apply ( input ) ) ; recent_ . set ( result ) ; return result ; }
public static boolean is Instane Of (  Class src ,  Class trg ) { if ( src . is Array ( ) && trg . is Array ( ) ) { return is Instane Of ( src . get Component Type ( ) , trg . get Component Type ( ) ) ; } if ( src == trg ) return _ BOOL ; if ( trg . is Interface ( ) ) { return _check Interfaces ( src , trg ) ; } while ( src != null ) { if ( src == trg ) return _ BOOL ; src = src . get Superclass ( ) ; } return trg ==  Object . class ; }
public static void parse Model To Content Values (  Object model ,  Content Values content Values ) { if ( content Values . size ( ) > _ NUM ) content Values . clear ( ) ;  Class < ? > clazz = model . get Class ( ) ;  Field [ ] fields = clazz . get Declared Fields ( ) ;  Class < ? > field Type = null ;  Object field Val = null ; for (  Field field : fields ) { try { if ( field . is Accessible ( ) == _ BOOL ) field . set Accessible ( _ BOOL ) ;  Column column = field . get Annotation (  Column . class ) ; field Type = field . get Type ( ) ; field Val = field . get ( model ) ; if ( column == null || field Val == null ) continue ; if ( field Type . equals ( int . class ) ) { content Values . put ( column . name ( ) , field . get Int ( model ) ) ; } else if ( field Type . equals (  Integer . class ) ) { content Values . put ( column . name ( ) , (  Integer ) field . get ( model ) ) ; } else if ( field Type . equals ( short . class ) ) { content Values . put ( column . name ( ) , field . get Short ( model ) ) ; } else if ( field Type . equals (  Short . class ) ) { content Values . put ( column . name ( ) , (  Short ) field . get ( model ) ) ; } else if ( field Type . equals ( long . class ) ) { content Values . put ( column . name ( ) , field . get Long ( model ) ) ; } else if ( field Type . equals (  Long . class ) ) { content Values . put ( column . name ( ) , (  Long ) field . get ( model ) ) ; } else if ( field Type . equals ( float . class ) ) { content Values . put ( column . name ( ) , field . get Float ( model ) ) ; } else if ( field Type . equals (  Float . class ) ) { content Values . put ( column . name ( ) , (  Float ) field . get ( model ) ) ; } else if ( field Type . equals ( double . class ) ) { content Values . put ( column . name ( ) , field . get Double ( model ) ) ; } else if ( field Type . equals (  Double . class ) ) { content Values . put ( column . name ( ) , (  Double ) field . get ( model ) ) ; } else if ( field Type . equals ( boolean . class ) ) { if ( field . get Boolean ( model ) == _ BOOL ) { content Values . put ( column . name ( ) , _ STR ) ; } else { content Values . put ( column . name ( ) , _ STR ) ; } } else if ( field Type . equals (  Boolean . class ) ) { if ( (  Boolean ) field . get ( model ) == _ BOOL ) { content Values . put ( column . name ( ) , _ STR ) ; } else { content Values . put ( column . name ( ) , _ STR ) ; } } else if ( field Type . equals (  String . class ) ) { content Values . put ( column . name ( ) , (  String ) field . get ( model ) ) ; } else if ( field Type . equals ( byte [ ] . class ) ) { content Values . put ( column . name ( ) , ( byte [ ] ) field . get ( model ) ) ; } else if ( field Type . equals (  Date . class ) ) {  Date date = (  Date ) field . get ( model ) ; content Values . put ( column . name ( ) ,  Date Utils . format Date2 Str ( date ) ) ; } } catch (  Illegal Argument Exception e ) { e . print Stack Trace ( ) ; } catch (  Illegal Access Exception e ) { e . print Stack Trace ( ) ; } } }
public static boolean is Not Null ( final  String element ) { boolean is Not Null = _ BOOL ; if ( element != null && ! element . is Empty ( ) ) { is Not Null = _ BOOL ; } return is Not Null ; }
public boolean equal Array Value (  Object other Value ) { if ( value instanceof  Object [ ] && other Value instanceof  Object [ ] ) { return  Arrays . equals ( (  Object [ ] ) value , (  Object [ ] ) other Value ) ; }  Class type = value . get Class ( ) ; if ( type != other Value . get Class ( ) ) { return _ BOOL ; } if ( type == int [ ] . class ) { return  Arrays . equals ( ( int [ ] ) value , ( int [ ] ) other Value ) ; } else if ( type == byte [ ] . class ) { return  Arrays . equals ( ( byte [ ] ) value , ( byte [ ] ) other Value ) ; } else if ( type == short [ ] . class ) { return  Arrays . equals ( ( short [ ] ) value , ( short [ ] ) other Value ) ; } else if ( type == long [ ] . class ) { return  Arrays . equals ( ( long [ ] ) value , ( long [ ] ) other Value ) ; } else if ( type == char [ ] . class ) { return  Arrays . equals ( ( char [ ] ) value , ( char [ ] ) other Value ) ; } else if ( type == boolean [ ] . class ) { return  Arrays . equals ( ( boolean [ ] ) value , ( boolean [ ] ) other Value ) ; } else if ( type == float [ ] . class ) { return  Arrays . equals ( ( float [ ] ) value , ( float [ ] ) other Value ) ; } else if ( type == double [ ] . class ) { return  Arrays . equals ( ( double [ ] ) value , ( double [ ] ) other Value ) ; } return _ BOOL ; }
public static void unzip (  Input Stream in ,  Path dest Dir ) throws  IOException { in = new  Buffered Input Stream ( in ) ; try (  Zip Input Stream zip Input = new  Zip Input Stream ( in ) ) {  Zip Entry entry ; byte [ ] buffer = new byte [ _ NUM ] ; while ( ( entry = zip Input . get Next Entry ( ) ) != null ) {  Path target File = dest Dir . resolve ( entry . get Name ( ) ) ;  Files . create Directories ( target File . get Parent ( ) ) ; if ( ! entry . is Directory ( ) ) {  Output Stream out =  Files . new Output Stream ( target File ) ; int len ; while ( ( len = zip Input . read ( buffer ) ) >= _ NUM ) { out . write ( buffer , _ NUM , len ) ; } out . close ( ) ; } zip Input . close Entry ( ) ; } } }
public  Coords drift Add Smoke (  Coords coords , int wind Dir , int wind Str ) { return drift Add Smoke ( coords , wind Dir , wind Str , _ NUM ) ; }
@  Rpc Method public void power Vm Op (  String vm Id ,  Power Vm Op op ,  Async Method Callback <  Host .  Async Client . power_vm_op_call > handler ) throws  Rpc Exception { ensure Client ( ) ;  Power Vm Op Request power Vm Op Request = new  Power Vm Op Request ( vm Id , op ) ; client Proxy . set Timeout (  POWER_ VM_ OP_ TIMEOUT_ MS ) ; logger . info ( _ STR , vm Id , get Host Ip ( ) , power Vm Op Request ) ; try { client Proxy . power_vm_op ( power Vm Op Request , handler ) ; } catch (  TException e ) { throw new  Rpc Exception ( e . get Message ( ) ) ; } }
public static  Channel Data decode ( byte bin Message [ ] , char offset ) throws  Stun Exception { char msg Len = _ NUM ; char channel Number = _ NUM ;  Channel Data channel Data = null ; byte data [ ] = null ; if ( ( bin Message . length - offset ) <  HEADER_ LENGTH ) { throw new  Stun Exception (  Stun Exception .  ILLEGAL_ ARGUMENT , _ STR ) ; } channel Number = ( char ) ( ( bin Message [ offset ++ ] << _ NUM ) | ( bin Message [ offset ++ ] & _ NUM ) ) ; if ( ! validate Channel Number ( channel Number ) ) { throw new  Stun Exception (  Stun Exception .  ILLEGAL_ ARGUMENT , _ STR ) ; } msg Len = ( char ) ( ( bin Message [ offset ++ ] << _ NUM ) | ( bin Message [ offset ++ ] & _ NUM ) ) ; if ( msg Len > ( bin Message . length - offset ) ) { throw new  Stun Exception (  Stun Exception .  ILLEGAL_ ARGUMENT , _ STR ) ; } data = new byte [ msg Len ] ;  System . arraycopy ( bin Message , offset , data , _ NUM , msg Len ) ; channel Data = new  Channel Data ( ) ; channel Data . set Data ( data ) ; channel Data . set Channel Number ( channel Number ) ; return channel Data ; }
protected void update Edit Pane (  Operation Permission Target item ,  Set selected ) { if ( item != null ) { if ( selected . size ( ) == _ NUM ) {  String name = item . get Meta Class Name ( ) ;  String local Name = item . get Local Name ( ) ; selected Target Caption . set Visible ( _ BOOL ) ; selected Target Caption . set Value ( name ) ; selected Target Caption . set Description ( name ) ; selected Target Local Caption . set Visible ( _ BOOL ) ; selected Target Local Caption . set Value ( local Name ) ; selected Target Local Caption . set Description ( local Name ) ; for (  Entity Operation Control control : operation Controls ) { if ( control . applicable To Entity ( item . get Entity Class ( ) ) ) { control . show ( ) ; } else { control . hide ( ) ; } } } else if ( selected . size ( ) > _ NUM ) { selected Target Caption . set Visible ( _ BOOL ) ; selected Target Caption . set Value ( _ STR ) ; selected Target Local Caption . set Visible ( _ BOOL ) ; selected Target Local Caption . set Value ( _ STR ) ; for (  Entity Operation Control control : operation Controls ) control . show ( ) ; for (  Object obj : selected ) {  Operation Permission Target target = (  Operation Permission Target ) obj ; for (  Entity Operation Control control : operation Controls ) { if ( control . is Control Visible ( ) && ! control . applicable To Entity ( target . get Entity Class ( ) ) ) control . hide ( ) ; } } } } }
public synchronized void update Path (  Property Change Listener listener ,  Object new Object ,  Set update Set ) { if ( current Object != new Object ) { remove Listeners ( ) ; } if ( ( children != null ) && ( children . length > _ NUM ) ) { try {  Object new Value = null ; if ( new Object != null ) { update Set . add ( new Object ) ; new Value = extract New Value ( new Object ) ; } for (  Bind Path child : children ) { child . update Path ( listener , new Value , update Set ) ; } } catch (  Exception e ) { } } if ( current Object != new Object ) { add Listeners ( listener , new Object , update Set ) ; } }
public void redo ( ) { if ( ! redo Stack . is Empty ( ) ) {  Undoable Action redo Event = redo Stack . pop ( ) ; redo Event . redo ( ) ; undo Stack . push ( redo Event ) ; } }
public void add All ( int [ ] data ) { int data Len = data . length ; if ( data Len == _ NUM ) { return ; } int newcap = size + ( int ) ( data Len * _ NUM ) + _ NUM ; ensure Capacity ( newcap ) ;  System . arraycopy ( data , _ NUM , array , size , data Len ) ; size += data Len ; }
public static void play ( double sample ) { if (  Double . is Na N ( sample ) ) throw new  Illegal Argument Exception ( _ STR ) ; if ( sample < - _ NUM ) sample = - _ NUM ; if ( sample > + _ NUM ) sample = + _ NUM ; short s = ( short ) (  MAX_16_ BIT * sample ) ; buffer [ buffer Size ++ ] = ( byte ) s ; buffer [ buffer Size ++ ] = ( byte ) ( s > > _ NUM ) ; if ( buffer Size >= buffer . length ) { line . write ( buffer , _ NUM , buffer . length ) ; buffer Size = _ NUM ; } }
public  String Builder encode Body (  String Builder buffer ) { return buffer . append ( organization ) ; }
protected void tear Down ( ) { try { if ( s != null ) s . close ( ) ; } catch (  Exception e ) { } try { if ( ss != null ) ss . close ( ) ; } catch (  Exception e ) { } try { if ( t != null ) t . interrupt ( ) ; } catch (  Exception e ) { } }
private int detect Type (  String file Name ) throws  IOException ,  FTPIllegal Reply Exception ,  FTPException { int start = file Name . last Index Of ( _ STR ) + _ NUM ; int stop = file Name . length ( ) ; if ( start > _ NUM && start < stop - _ NUM ) {  String ext = file Name . substring ( start , stop ) ; ext = ext . to Lower Case ( ) ; if ( textual Extension Recognizer . is Textual Ext ( ext ) ) { return  TYPE_ TEXTUAL ; } else { return  TYPE_ BINARY ; } } else { return  TYPE_ BINARY ; } }
protected void going Inactive (  OBlock block ) { if ( _run Mode ==  MODE_ NONE ) { return ; } if ( !  Threading Util . is Layout Thread ( ) ) log . error ( _ STR , new  Exception ( _ STR ) ) ; int idx = get Index Of Block ( block , _idx Last Order ) ; if ( log . is Debug Enabled ( ) ) { log . debug ( _ STR + block . get Display Name ( ) + _ STR + idx + _ STR + _idx Current Order + _ STR + get Display Name ( ) ) ; } if ( idx < _idx Current Order ) { release Block ( block , idx ) ; } else if ( idx == _idx Current Order ) { if ( _idx Current Order + _ NUM < _orders . size ( ) ) {  OBlock next Block = get Block At ( _idx Current Order + _ NUM ) ; if ( ( next Block . get State ( ) &  OBlock .  DARK ) != _ NUM ) { if ( _engineer != null ) { going Active ( next Block ) ; release Block ( block , idx ) ; } else { if ( _run Mode ==  MODE_ LEARN ) { _idx Current Order ++ ; fire Property Change ( _ STR , block , next Block ) ; } else if ( _run Mode ==  MODE_ RUN ) { control Run Train (  ABORT ) ; } } } else { if ( log . is Debug Enabled ( ) ) { log . debug ( _ STR + block . get Display Name ( ) + _ STR + get Display Name ( ) ) ; } fire Property Change ( _ STR , block , null ) ; if ( _engineer != null ) { _engineer . set Halt ( _ BOOL ) ; } else { control Run Train (  ABORT ) ; } return ; } } else { abort Warrant ( _ STR + get Display Name ( ) + _ STR + block . get Display Name ( ) + _ STR ) ; } } else if ( idx == _idx Current Order + _ NUM ) { restart ( ) ; move Into Next Block (  END ) ; } else { block . allocate ( this ) ; } }
public void add Custom Sash Form Listener (  ICustom Sash Form Listener listener ) { if ( custom Sash Form Listeners == null ) custom Sash Form Listeners = new  Array List ( ) ; custom Sash Form Listeners . add ( listener ) ; }
@  Override public void close ( ) throws  IOException { if ( ! m Seen Eof ) { m Thread . interrupt ( ) ; try { m Thread . join ( ) ; } catch ( final  Interrupted Exception e ) { throw new  IOException ( _ STR ) ; } finally { super . close ( ) ; } } check Exception ( ) ; }
public static  UUID parse String As UUID (  String in ) throws  Index Parse Field Exception { try { return  UUID . from String ( in ) ; } catch (  Illegal Argument Exception e ) { throw new  Index Parse Field Exception ( in , e ) ; } }
public void write All ( java . sql .  Result Set rs , boolean include Column Names , boolean trim ) throws  SQLException ,  IOException { if ( include Column Names ) { write Column Names ( rs ) ; } while ( rs . next ( ) ) { write Next ( result Service . get Column Values ( rs , trim ) ) ; } }
public  Zone Rules Builder add Rule To Window ( int start Year , int end Year , int month , int day Of Month Indicator , int day Of Week ,  Local Time time , boolean time End Of Day ,  Time Definition time Definition , int saving Amount Secs ) {  Objects . require Non Null ( time , _ STR ) ;  Objects . require Non Null ( time Definition , _ STR ) ; if ( day Of Month Indicator < - _ NUM || day Of Month Indicator > _ NUM || day Of Month Indicator == _ NUM ) { throw new  Illegal Argument Exception ( _ STR ) ; } if ( time End Of Day && time . equals (  Local Time .  MIDNIGHT ) == _ BOOL ) { throw new  Illegal Argument Exception ( _ STR ) ; } if ( window List . is Empty ( ) ) { throw new  Illegal State Exception ( _ STR ) ; }  TZWindow window = window List . get ( window List . size ( ) - _ NUM ) ; window . add Rule ( start Year , end Year , month , day Of Month Indicator , day Of Week , time , time End Of Day , time Definition , saving Amount Secs ) ; return this ; }
private  String concat (  List <  ILine Segment > list ) {  String Builder res = new  String Builder ( ) ;  Node <  ILine Segment > n = list . head ( ) ; while ( n != null ) { res . append ( n . value ( ) ) ; n = n . next ( ) ; if ( n != null ) { res . append ( _ STR ) ; } } return res . to String ( ) ; }
private static void parse Directories (  Byte Buffer data , int num Tables ,  True Type Font ttf ) { for ( int i = _ NUM ; i < num Tables ; i ++ ) { int tag = data . get Int ( ) ;  String tag String =  True Type Table . tag To String ( tag ) ; int checksum = data . get Int ( ) ; int offset = data . get Int ( ) ; int length = data . get Int ( ) ; data . mark ( ) ; data . position ( offset ) ;  Byte Buffer table Data = data . slice ( ) ; table Data . limit ( length ) ; int calc Checksum = calculate Checksum ( tag String , table Data ) ; if ( calc Checksum == checksum ) { ttf . add Table ( tag String , table Data ) ; } else { ttf . add Table ( tag String , table Data ) ; } data . reset ( ) ; } }
public  Multi Module Script Provider (  Iterable < ? extends  Module Script Provider > providers ) { final  List <  Module Script Provider > l = new  Linked List <  Module Script Provider > ( ) ; for (  Module Script Provider provider : providers ) { l . add ( provider ) ; } this . providers = l . to Array ( new  Module Script Provider [ l . size ( ) ] ) ; }
protected void write Blob ( int test Id , byte [ ] test Bytes ,  Fb Database db ,  Blob Parameter Buffer blob Parameter Buffer ) throws  SQLException { final  Simple Statement Listener listener = new  Simple Statement Listener ( ) ; final  Fb Transaction transaction = get Transaction ( db ) ; try { final  Fb Statement statement = db . create Statement ( transaction ) ; statement . add Statement Listener ( listener ) ; final  Fb Blob blob = db . create Blob For Output ( transaction , blob Parameter Buffer ) ; blob . open ( ) ; int bytes Written = _ NUM ; while ( bytes Written < test Bytes . length ) { byte [ ] buffer = new byte [  Math . min ( blob . get Maximum Segment Size ( ) , test Bytes . length - bytes Written ) ] ;  System . arraycopy ( test Bytes , bytes Written , buffer , _ NUM , buffer . length ) ; blob . put Segment ( buffer ) ; bytes Written += buffer . length ; } blob . close ( ) ; statement . prepare (  INSERT_ BLOB_ TABLE ) ; final  Datatype Coder datatype Coder = db . get Datatype Coder ( ) ;  Field Value param1 = new  Field Value ( datatype Coder . encode Int ( test Id ) ) ;  Field Value param2 = new  Field Value ( datatype Coder . encode Long ( blob . get Blob Id ( ) ) ) ; statement . execute (  Row Value . of ( param1 , param2 ) ) ; statement . close ( ) ; } finally { transaction . commit ( ) ; } }
public static double sqrt Quick ( final double value ) { if (  USE_ JDK_ MATH ) { return  Math . sqrt ( value ) ; } final long bits =  Double . double To Raw Long Bits ( value ) ; return  Double . long Bits To Double ( bits + _ NUM > > > _ NUM ) ; }
public void add Near Key (  Key Cache Object key ,  Grid Cache Shared Context ctx ) throws  Ignite Checked Exception { if ( near Keys == null ) near Keys = new  Array List < > ( ) ; near Keys . add ( key ) ; }
public static void do With Fields (  Class < ? > clazz ,  Field Callback fc ,  Field Filter ff ) {  Class < ? > target Class = clazz ; do {  Field [ ] fields = target Class . get Declared Fields ( ) ; for (  Field field : fields ) { if ( ff != null && ! ff . matches ( field ) ) { continue ; } try { fc . do With ( field ) ; } catch (  Illegal Access Exception ex ) { throw new  Illegal State Exception ( _ STR + field . get Name ( ) + _ STR + ex ) ; } } target Class = target Class . get Superclass ( ) ; } while ( target Class != null && target Class !=  Object . class ) ; }
public static void clone ( final  CGraph Window parent , final  INavi View view , final  IView Container container ) { final  Clone Thread clone Thread = new  Clone Thread ( parent , view , container ) ;  CProgress Dialog . show Endless ( parent ,  String . format ( _ STR , view . get Name ( ) ) , clone Thread ) ; if ( clone Thread . get Exception ( ) != null ) {  CUtility Functions . log Exception ( clone Thread . get Exception ( ) ) ; final  String inner Message = _ STR + _ STR ; final  String inner Description =  CUtility Functions . create Description (  String . format ( _ STR , view . get Name ( ) ) , new  String [ ] { _ STR } , new  String [ ] { _ STR } ) ;  Navi Error Dialog . show ( parent , inner Message , inner Description , clone Thread . get Exception ( ) ) ; } }
public static void rename (  String from ,  String to ) {  Process p = null ;  Thread std = null ; try {  Runtime run Time =  Runtime . get Runtime ( ) ; log . debug ( _ STR ) ; if (  File . separator Char == _ STR ) { p = run Time . exec ( _ STR + from + _ STR + to + _ STR ) ; } else { p = run Time . exec ( _ STR + from + _ STR + to ) ; } std = std Out ( p ) ; while ( std . is Alive ( ) ) { try {  Thread . sleep ( _ NUM ) ; } catch (  Exception e ) { } } log . debug ( _ STR ) ; } catch (  Exception e ) { log . error ( _ STR , e ) ; } finally { if ( null != p ) { log . debug ( _ STR ) ; p . destroy ( ) ; p = null ; std = null ; } } }
public static  String find Edit Table (  String tables ) { if ( !  Text Utils . is Empty ( tables ) ) { int spacepos = tables . index Of ( _ STR ) ; int commapos = tables . index Of ( _ STR ) ; if ( spacepos > _ NUM && ( spacepos < commapos || commapos < _ NUM ) ) { return tables . substring ( _ NUM , spacepos ) ; } else if ( commapos > _ NUM && ( commapos < spacepos || spacepos < _ NUM ) ) { return tables . substring ( _ NUM , commapos ) ; } return tables ; } else { throw new  Illegal State Exception ( _ STR ) ; } }
public void write Operations Engine File ( ) { make Backup File ( default Operations Filename ( ) ) ; try { if ( ! check File ( default Operations Filename ( ) ) ) { java . io .  File file = new java . io .  File ( default Operations Filename ( ) ) ; java . io .  File parent Dir = file . get Parent File ( ) ; if ( ! parent Dir . exists ( ) ) { if ( ! parent Dir . mkdir ( ) ) { log . error ( _ STR ) ; } } if ( file . create New File ( ) ) { log . debug ( _ STR ) ; } } write File ( default Operations Filename ( ) ) ; } catch (  Exception e ) { log . error ( _ STR + e ) ; } }
public  Follower Info (  Follower .  Type type ,  String stream ,  List <  Follower > followers , int total ) { this . type = type ; this . followers = followers ; this . total = total ; this . time =  System . current Time Millis ( ) ; this . stream = stream ; this . request Error = _ BOOL ; this . request Error Description = null ; }
private void on Altitude Element End ( ) throws  SAXException { try { elevation =  Double . parse Double ( content ) ; } catch (  Number Format Exception e ) { throw new  SAXException ( create Error Message ( _ STR + content ) , e ) ; } }
@  Override public void property Change (  Property Change Event evt ) { was Modified ( evt ) ; support . fire Property Change ( _ STR , null , null ) ; }
public static void sort Methods (  Method Binding [ ] sorted Methods , int left , int right ) {  Arrays . sort ( sorted Methods , left , right ,  METHOD_ COMPARATOR ) ; }
private void draw Background ( final  Graphics g ) { g . set Color ( m_bg Color Offset ) ; g . fill Rect ( - m_first Column * m_char Width , _ NUM , m_offset View Width , get Height ( ) ) ; g . set Color ( m_bg Color Hex ) ; g . fill Rect ( ( - m_first Column * m_char Width ) + m_offset View Width , _ NUM , m_hex View Width , get Height ( ) ) ; g . set Color ( m_bg Color Ascii ) ; g . fill Rect ( ( - m_first Column * m_char Width ) + m_hex View Width + m_offset View Width , _ NUM , ( ( m_first Column * m_char Width ) + get Width ( ) ) - ( m_hex View Width + m_offset View Width ) - m_scrollbar . get Width ( ) , get Height ( ) - m_horizontal Scrollbar . get Height ( ) ) ; g . set Color (  Color .  BLACK ) ; g . draw Line ( ( - m_first Column * m_char Width ) + m_offset View Width , _ NUM , ( - m_first Column * m_char Width ) + m_offset View Width , get Height ( ) ) ; g . draw Line ( ( - m_first Column * m_char Width ) + m_offset View Width + m_hex View Width , _ NUM , ( - m_first Column * m_char Width ) + m_offset View Width + m_hex View Width , get Height ( ) ) ; }
public void add Included Attributes ( final  String element Name , final  List attr Names ) {  List attr Names List = null ; if ( ( attr Names List = (  List ) _included Element Attrs Map . get ( element Name ) ) == null ) { attr Names List = new  Array List ( ) ; } attr Names List . add All ( attr Names ) ; _included Element Attrs Map . put ( element Name , attr Names List ) ; }
private static  Power Vm Op Response check Power Vm Op Response (  Power Vm Op Response power Vm Op Response ) throws  Rpc Exception { logger . info ( _ STR , power Vm Op Response ) ; switch ( power Vm Op Response . get Result ( ) ) { case  OK : break ; case  INVALID_ VM_ POWER_ STATE : throw new  Invalid Vm Power State Exception ( power Vm Op Response . get Error ( ) ) ; case  SYSTEM_ ERROR : throw new  System Error Exception ( power Vm Op Response . get Error ( ) ) ; case  VM_ NOT_ FOUND : throw new  Vm Not Found Exception ( power Vm Op Response . get Error ( ) ) ; default : throw new  Rpc Exception (  String . format ( _ STR , power Vm Op Response . get Result ( ) ) ) ; } return power Vm Op Response ; }
default  Literal to Literal ( final  Object value ) { final  Value Factory vf =  Defaults .  VF ; if ( value instanceof  Float ) { return vf . create Literal ( (  Float ) value ) ; } else if ( value instanceof  Double ) { return vf . create Literal ( (  Double ) value ) ; } else if ( value instanceof  Integer ) { return vf . create Literal ( (  Integer ) value ) ; } else if ( value instanceof  Long ) { return vf . create Literal ( (  Long ) value ) ; } else if ( value instanceof  Boolean ) { return vf . create Literal ( (  Boolean ) value ) ; } else if ( value instanceof  Short ) { return vf . create Literal ( (  Short ) value ) ; } else if ( value instanceof  Byte ) { return vf . create Literal ( (  Byte ) value ) ; } else if ( value instanceof  String ) { return vf . create Literal ( (  String ) value ) ; } else { throw new  Illegal Argument Exception (  String . format ( _ STR , value ) ) ; } }
public  Authorization Code (  Json Value token ) throws  Invalid Grant Exception { super ( token ) ; if ( !  OAUTH_ CODE_ TYPE . equals ( get Token Name ( ) ) ) { throw new  Invalid Grant Exception ( _ STR + get Token Id ( ) ) ; } }
private static int parse Notification Id (  String id ) { try { return  Integer . parse Int ( id ) ; } catch (  Number Format Exception nfe ) {  Log . w (  TAG , _ STR + id ) ; return - _ NUM ; } }
private static boolean is IPv4 (  String host ) {  String regex = _ STR ; return host . matches ( regex ) ; }
public static <  T >  Future W <  T > of Error ( final  Throwable error ) { final  Completable Future <  T > cf = new  Completable Future < > ( ) ; cf . complete Exceptionally ( error ) ; return  Future W . <  T > of ( cf ) ; }
protected boolean handle Remote Action (  String action ,  Bundle extras ) { if ( action == null || action . is Empty ( ) ) { return _ BOOL ; } switch ( action ) { case  Remote Actions .  ACTION_ PLAY_ PAUSE : perform Play Pause ( ) ; break ; case  Remote Actions .  ACTION_ NEXT : perform Next ( ) ; break ; case  Remote Actions .  ACTION_ PREVIOUS : perform Previous ( ) ; break ; case  Remote Actions .  ACTION_ REPEAT : perform Repeat ( ) ; break ; case  Remote Actions .  ACTION_ SHUFFLE : perform Shuffle ( ) ; break ; case  Remote Actions .  ACTION_ STOP : perform Stop ( ) ; break ; case  Remote Actions .  ACTION_ SEEK_ STARTED : perform Seek Started ( ) ; break ; case  Remote Actions .  ACTION_ SEEK_ ENDED : perform Seek Ended ( extras . get Long (  Remote Actions .  ACTION_ EXTRA_ SEEK_ POSITION , _ NUM ) ) ; break ; case  Remote Actions .  ACTION_ ALLOWED_ TYPE_ CHANGED : update Allowed Media Type ( extras . get Int (  Remote Actions .  ACTION_ EXTRA_ ALLOWED_ TYPE ) ) ; break ; default : return _ BOOL ; } return _ BOOL ; }
protected  Object convert Builtin Sound (  Input Stream i ) throws  IOException {  Byte Array Output Stream b = new  Byte Array Output Stream ( ) ; byte [ ] buffer = new byte [ _ NUM ] ; int size = i . read ( buffer ) ; while ( size > - _ NUM ) { b . write ( buffer , _ NUM , size ) ; size = i . read ( buffer ) ; } b . close ( ) ; i . close ( ) ; return b . to Byte Array ( ) ; }
private static  String do Get Full Path (  String filename , boolean include Separator ) { if ( filename == null ) { return null ; } int prefix = get Prefix Length ( filename ) ; if ( prefix < _ NUM ) { return null ; } if ( prefix >= filename . length ( ) ) { if ( include Separator ) { return get Prefix ( filename ) ; } else { return filename ; } } int index = index Of Last Separator ( filename ) ; if ( index < _ NUM ) { return filename . substring ( _ NUM , prefix ) ; } int end = index + ( include Separator ? _ NUM : _ NUM ) ; if ( end == _ NUM ) { end ++ ; } return filename . substring ( _ NUM , end ) ; }
public static  String decode (  String s ) { if ( s == null ) { return null ; } return  Uri Codec . decode ( s , _ BOOL ,  Charset . for Name ( _ STR ) ) ; }
public void test Encoding Decoding Fullness ( ) { for (  Grid Client Cache Flag f :  Grid Client Cache Flag . values ( ) ) { if ( f ==  KEEP_ BINARIES ) continue ; int bits =  Grid Client Connection . encode Cache Flags (  Collections . singleton ( f ) ) ; assert True ( bits != _ NUM ) ; boolean out =  Grid Cache Command Handler . parse Cache Flags ( bits ) ; assert Equals ( out , _ BOOL ) ; } }
public boolean contains (  Data Source source ) { return data . contains ( source ) ; }
public void add Value ( double value , double weight ) { m_ Weighted Sum += value * weight ; m_ Weighted Sum Squared += value * value * weight ; m_ Sum Of Weights += weight ; }
public static  Date parse Date ( final  String format , final  String date String ) throws  DSSException { try { final  Simple Date Format sdf = new  Simple Date Format ( format ) ; final  Date date = sdf . parse ( date String ) ; return date ; } catch (  Parse Exception e ) { throw new  DSSException ( e ) ; } }
public void change Item Icon At Position ( int item Index , int new Icon ) { if ( item Index < _ NUM || item Index > space Items . size ( ) ) { throw Array Index Out Of Bounds Exception ( item Index ) ; } else {  Space Item space Item = space Items . get ( item Index ) ;  Relative Layout text And Icon Container = (  Relative Layout ) space Item List . get ( item Index ) ;  Image View space Item Icon = (  Image View ) text And Icon Container . find View By Id (  R . id . space_icon ) ; space Item Icon . set Image Resource ( new Icon ) ; space Item . set Item Icon ( new Icon ) ; changed Item And Icon Hash Map . put ( item Index , space Item ) ; } }
private void correct Too Low ( int child Count ) { if ( m First Position == _ NUM && child Count > _ NUM ) { final int first Top = get Highest Child Top ( ) ; final int start = get List Padding Top ( ) ; final int end = ( get Top ( ) - get Bottom ( ) ) - get List Padding Bottom ( ) ; int top Offset = first Top - start ; final int last Bottom = get Lowest Child Bottom ( ) ; int last Position = m First Position + child Count - _ NUM ; if ( top Offset > _ NUM ) { if ( last Position < m Item Count - _ NUM || last Bottom > end ) { if ( last Position == m Item Count - _ NUM ) { top Offset =  Math . min ( top Offset , last Bottom - end ) ; } offset Children Top And Bottom ( - top Offset ) ; if ( last Position < m Item Count - _ NUM ) { int next Position = last Position + _ NUM ; fill Down ( next Position , get Next Child Downs Top ( next Position ) ) ; adjust Views Up Or Down ( ) ; } } else if ( last Position == m Item Count - _ NUM ) { adjust Views Up Or Down ( ) ; } } } }
public void organization Config Changed (  String service Name ,  String version ,  String org Name ,  String group Name ,  String service Component , int type ) { if ( debug . message Enabled ( ) ) { debug . message ( _ STR + _ STR + service Name + _ STR + org Name + _ STR + group Name + _ STR + service Component + _ STR + type ) ; } if ( ( type ==  Service Listener .  REMOVED ) && ( service Component . length ( ) == _ NUM ) ) { remove Id Repo ( org Name ) ; } else if ( ( service Component . length ( ) != _ NUM ) && ! service Component . equals ( _ STR ) && ! service Component . equals ( _ STR ) ) {  String id Repo Name = null ;  String Tokenizer st = new  String Tokenizer ( service Component , _ STR ) ; if ( st . has More Tokens ( ) ) { id Repo Name = st . next Token ( ) ; } try { if ( type ==  Service Listener .  ADDED ) { add Id Repo ( org Name , id Repo Name ) ; } else if ( type ==  Service Listener .  MODIFIED ) { if ( !  Id Services Impl . is Shutdown Called ( ) ) { remove Id Repo ( org Name , id Repo Name , _ BOOL ) ; } else { remove Id Repo ( org Name , id Repo Name , _ BOOL ) ; } } else if ( type ==  Service Listener .  REMOVED ) { remove Id Repo ( org Name , id Repo Name , _ BOOL ) ; } } catch (  Exception e ) { debug . error ( _ STR + _ STR + service Name + _ STR + org Name + _ STR + group Name + _ STR + service Component + _ STR + type , e ) ; } } }
public static void launch Sms Intent ( final  Activity activity ,  String number ,  String text ) {  Log . i (  LOG_ TAG , _ STR + number ) ;  Uri sms Uri =  Uri . parse ( _ STR + number ) ;  Intent sms Intent = new  Intent (  Intent .  ACTION_ SENDTO , sms Uri ) ; sms Intent . put Extra ( _ STR , text ) ;  Package Manager smspackage Manager = activity . get Package Manager ( ) ;  List <  Resolve Info > smsresolve Infos = smspackage Manager . query Intent Activities ( sms Intent , _ NUM ) ; if ( smsresolve Infos . size ( ) > _ NUM ) { activity . start Activity ( sms Intent ) ; } }
public int [ ] intersect ( int [ ] nums1 , int [ ] nums2 ) {  Map <  Integer ,  Integer > count = new  Hash Map < > ( ) ; for ( int n : nums1 ) { count . put ( n , count . contains Key ( n ) ? count . get ( n ) + _ NUM : _ NUM ) ; }  List <  Integer > intersections = new  Array List < > (  Math . min ( nums1 . length , nums2 . length ) ) ; for ( int n : nums2 ) { if ( count . contains Key ( n ) ) { intersections . add ( n ) ; count . put ( n , count . get ( n ) - _ NUM ) ; if ( count . get ( n ) == _ NUM ) count . remove ( n ) ; } } int [ ] res = new int [ intersections . size ( ) ] ; for ( int i = _ NUM ; i < intersections . size ( ) ; i ++ ) { res [ i ] = intersections . get ( i ) ; } return res ; }
public static  String decode (  String s , boolean convert Plus ) { if ( ! convert Plus && s . index Of ( _ STR ) == - _ NUM ) return s ;  String Buffer result = new  String Buffer ( s . length ( ) ) ;  Byte Array Output Stream out = new  Byte Array Output Stream ( ) ; for ( int i = _ NUM ; i < s . length ( ) ; ) { char c = s . char At ( i ) ; if ( convert Plus && c == _ STR ) result . append ( _ STR ) ; else if ( c == _ STR ) { out . reset ( ) ; do { if ( i + _ NUM >= s . length ( ) ) throw new  Illegal Argument Exception (  Msg . get String ( _ STR , i ) ) ; int d1 =  Character . digit ( s . char At ( i + _ NUM ) , _ NUM ) ; int d2 =  Character . digit ( s . char At ( i + _ NUM ) , _ NUM ) ; if ( d1 == - _ NUM || d2 == - _ NUM ) throw new  Illegal Argument Exception (  Msg . get String ( _ STR , s . substring ( i , i + _ NUM ) ,  String . value Of ( i ) ) ) ; out . write ( ( byte ) ( ( d1 << _ NUM ) + d2 ) ) ; i += _ NUM ; } while ( i < s . length ( ) && s . char At ( i ) == _ STR ) ; result . append ( out . to String ( ) ) ; continue ; } else result . append ( c ) ; i ++ ; } return result . to String ( ) ; }
public final void open Pdf File From Stream ( final  Object filename , final  String password ) throws  Pdf Exception { close On Exit = _ BOOL ; if ( filename instanceof  Image Input Stream ) { final  Image Input Stream iis = (  Image Input Stream ) filename ; if ( is Open ) { close Pdf File ( ) ; } is Open = _ BOOL ; this . filename = _ STR +  System . current Time Millis ( ) ; org . jpedal .  Dev Flags . current File = this . filename ; res . flush ( ) ; res . flush Objects ( ) ; object Store Ref . store File Name ( this . filename ) ; current Pdf File = new  Pdf Object Reader ( password ) ; current Pdf File . open Pdf File ( iis ) ; open Pdf File ( ) ; } else { throw new  Runtime Exception ( filename + _ STR ) ; } }
public void add Footer View (  View v ,  Object data , boolean is Selectable ) {  Fixed View Info info = new  Fixed View Info ( ) ; info . view = v ; info . data = data ; info . is Selectable = is Selectable ; m Footer View Infos . add ( info ) ; if ( m Data Set Observer != null ) { m Data Set Observer . on Changed ( ) ; } }
public  Object source (  String filename ,  Name Space name Space ) throws  File Not Found Exception ,  IOException ,  Eval Error {  File file = path To File ( filename ) ; if (  Interpreter .  DEBUG ) debug ( _ STR + file ) ;  Reader source In = new  Buffered Reader ( new  File Reader ( file ) ) ; try { return eval ( source In , name Space , filename ) ; } finally { source In . close ( ) ; } }
private void broadcast From Gm ( final  Player player ) {  Packet Send Utility . broadcast Packet ( player , new  SM_ MESSAGE ( player , message , type ) , _ BOOL ) ; }
public static void remove Breakpoints ( final  Set <  Breakpoint Address > addresses , final  Breakpoint Manager manager ) {  Preconditions . check Not Null ( manager , _ STR ) ;  Preconditions . check Not Null ( addresses , _ STR ) ; final  Set <  Breakpoint Address > addresses To Remove From Manager = new  Hash Set <  Breakpoint Address > ( ) ; final  Set <  Breakpoint Address > addresses To Remove From Debugger = new  Hash Set <  Breakpoint Address > ( ) ; for ( final  Breakpoint Address address : addresses ) { final  Breakpoint Status status = manager . get Breakpoint Status ( address ,  Breakpoint Type .  REGULAR ) ; if ( ( status ==  Breakpoint Status .  BREAKPOINT_ DISABLED ) || ( status ==  Breakpoint Status .  BREAKPOINT_ INACTIVE ) ) { addresses To Remove From Manager . add ( address ) ; } if ( status !=  Breakpoint Status .  BREAKPOINT_ DELETING ) { addresses To Remove From Debugger . add ( address ) ; } } if ( addresses To Remove From Manager . size ( ) != _ NUM ) { manager . remove Breakpoints (  Breakpoint Type .  REGULAR , addresses To Remove From Manager ) ; } if ( addresses To Remove From Debugger . size ( ) != _ NUM ) { manager . set Breakpoint Status ( addresses To Remove From Debugger ,  Breakpoint Type .  REGULAR ,  Breakpoint Status .  BREAKPOINT_ DELETING ) ; } }
protected void execute Tasks ( final  Access Path Task [ ] tasks ) throws  Exception { if ( executor == null ) { for (  Access Path Task task : tasks ) { task . call ( ) ; } return ; } final  List <  Future Task <  Void > > future Tasks = new  Linked List <  Future Task <  Void > > ( ) ; for (  Access Path Task task : tasks ) { final  Future Task <  Void > ft = new  Future Task Mon <  Void > ( task ) ; future Tasks . add ( ft ) ; } try { for (  Future Task <  Void > ft : future Tasks ) { halted ( ) ; executor . execute ( ft ) ; } for (  Future Task <  Void > ft : future Tasks ) { if ( ! is Done ( ) ) ft . get ( ) ; } } finally { for (  Future Task <  Void > ft : future Tasks ) { ft . cancel ( _ BOOL ) ; } } }
private void validate Cloumns (  Map <  String ,  Object > column Name To Type Map ) { if ( column Name To Type Map == null ) { throw new  Illegal Argument Exception ( _ STR ) ; } for (  Map .  Entry <  String ,  Object > entry : column Name To Type Map . entry Set ( ) ) {  Object obj Value = entry . get Value ( ) ; if ( obj Value == null ) { throw new  Illegal Argument Exception ( _ STR + entry . get Key ( ) + _ STR ) ; } if ( obj Value instanceof  Class < ? > ) { continue ; } if ( obj Value instanceof  String ) { try { entry . set Value (  Class . for Name ( (  String ) obj Value ) ) ; } catch (  Class Not Found Exception e ) { throw new  Illegal Argument Exception ( _ STR , e ) ; } } } }
protected void merge Advices (  Entitlement e1 ,  Entitlement e2 ) {  Map <  String ,  Set <  String > > result = new  Hash Map <  String ,  Set <  String > > ( ) ;  Map <  String ,  Set <  String > > a1 = e1 . get Advices ( ) ; if ( a1 == null ) { a1 =  Collections .  EMPTY_ MAP ; }  Map <  String ,  Set <  String > > a2 = e2 . get Advices ( ) ; if ( a2 == null ) { a2 =  Collections .  EMPTY_ MAP ; }  Set <  String > names = new  Hash Set <  String > ( ) ; names . add All ( a1 . key Set ( ) ) ; names . add All ( a2 . key Set ( ) ) ; for (  String n : names ) {  Set <  String > advice1 = a1 . get ( n ) ;  Set <  String > advice2 = a2 . get ( n ) ;  Set <  String > r = result . get ( n ) ; if ( r == null ) { r = new  Hash Set <  String > ( ) ; result . put ( n , r ) ; } if ( ( advice1 != null ) && ! advice1 . is Empty ( ) ) { r . add All ( advice1 ) ; } if ( ( advice2 != null ) && ! advice2 . is Empty ( ) ) { r . add All ( advice2 ) ; } } e1 . set Advices ( result ) ; }
public void test Find Spring Attributes Open Ldap ( ) {  Ldap Proxy proxy = get Ldap Open Ldap ( ) ;  List result = null ; try { result = proxy . find ( get Ldap Search VO ( _ STR ,  Ldap Constants .  NO_ SEARCH_ LIMIT , null , null , new  String [ ] { _ STR } ,  Ldap Scope Constants .  SCOPE_ SUBTREE ) ) ; } catch (  Exception e ) { } assert Not Null ( result ) ; assert Equals ( _ NUM , result . size ( ) ) ; }
public  Map read (  SSOToken token ,  String dn ) throws  SMSException ,  SSOException { if ( dn == null || dn . length ( ) == _ NUM ) { debug . error ( _ STR + dn ) ; throw new  SMSException ( _ STR , _ STR ) ; } if ( !  LDAPUtils . is DN ( dn ) ) { debug . warning ( _ STR + dn ) ;  String [ ] args = { dn } ; throw new  SMSException (  IUMSConstants .  UMS_ BUNDLE_ NAME , _ STR , args ) ; } if (  SMSNotification Manager . is Cache Enabled ( ) && entries Not Present . contains ( dn ) ) { if ( debug . message Enabled ( ) ) { debug . message ( _ STR + dn + _ STR ) ; } return ( null ) ; }  Search Request request =  Requests . new Search Request (  DN . value Of ( dn ) ,  Search Scope .  BASE_ OBJECT ,  Search Filter . object Class Present ( ) , sms Attributes . to Array ( new  String [ sms Attributes . size ( ) ] ) ) ;  Internal Search Operation iso = ic Conn . process Search ( request ) ;  Result Code result Code = iso . get Result Code ( ) ; if ( result Code ==  Result Code .  SUCCESS ) {  Linked List search Result = iso . get Search Entries ( ) ; if ( ! search Result . is Empty ( ) ) {  Search Result Entry entry = (  Search Result Entry ) search Result . get ( _ NUM ) ;  List attributes = entry . get Attributes ( ) ; return  Embedded Search Result Iterator . convert LDAPAttribute Set To Map ( attributes ) ; } else { return null ; } } else if ( result Code ==  Result Code .  NO_ SUCH_ OBJECT ) { object Changed ( dn ,  DELETE ) ; if ( debug . message Enabled ( ) ) { debug . message ( _ STR + _ STR + dn ) ; } return null ; } else { if ( debug . warning Enabled ( ) ) { debug . warning ( _ STR + _ STR + dn + _ STR + result Code ) ; } throw new  SMSException ( _ STR , _ STR ) ; } }
private static <  T extends  Abstract Block Base <  T > > void compute Code Emitting Order (  List <  T > order ,  Priority Queue <  T > worklist ,  Bit Set visited Blocks ) { while ( ! worklist . is Empty ( ) ) {  T next Important Path = worklist . poll ( ) ; add Path To Code Emitting Order ( next Important Path , order , worklist , visited Blocks ) ; } }
public void add Role (  Role Entity role ) { roles . add ( role ) ; }
private  JPanel build Row ( final  String string , final  JCheck Box check Box ) { final  JPanel panel = new  JPanel ( new  Border Layout ( ) ) ; panel . add ( new  JLabel ( string ) ,  Border Layout .  WEST ) ; panel . add ( check Box ,  Border Layout .  EAST ) ; check Box . add Item Listener ( m_check Box Listener ) ; return panel ; }
public  QDate (  Time Zone zone ) { _time Zone = zone ; if ( zone == _gmt Time Zone ) { _std Name = _gmt Std Name ; _dst Name = _gmt Dst Name ; } else if ( zone == _local Time Zone ) { _std Name = _local Std Name ; _dst Name = _local Dst Name ; } else { _std Name = _time Zone . get Display Name ( _ BOOL ,  Time Zone .  SHORT ) ; _dst Name = _time Zone . get Display Name ( _ BOOL ,  Time Zone .  SHORT ) ; } _calendar = new  Gregorian Calendar ( _time Zone ) ; set Local Time (  Current Time . current Time ( ) ) ; }
public static boolean check Url (  String url As String ) { if ( url As String == null ) { logger . error ( _ STR ) ; return _ BOOL ; }  URL url ; try { url = new  URL ( url As String ) ; } catch (  Malformed URLException e ) { logger . error ( url As String + _ STR ) ; return _ BOOL ; } int response Code ;  String response Message = _ STR ;  Object content = _ STR ;  Http URLConnection huc ; try { huc = (  Http URLConnection ) url . open Connection ( ) ; huc . set Request Method ( _ STR ) ; response Code = huc . get Response Code ( ) ; content = huc . get Content ( ) ; response Message = huc . get Response Message ( ) ; } catch (  Protocol Exception e ) { logger . error ( _ STR + e . get Message ( ) , e ) ; return _ BOOL ; } catch (  IOException e ) { logger . error ( _ STR + e . get Message ( ) , e ) ; return _ BOOL ; } if ( response Code == _ NUM || ( response Code > _ NUM && response Code < _ NUM ) ) { logger . info ( _ STR + url As String + _ STR ) ; return _ BOOL ; } else { logger . error ( url As String + _ STR + response Code + _ STR + content + _ STR + response Message ) ; return _ BOOL ; } }
protected void finalize (  List <  Snapshot Files > snapshots , int file List Generation ,  Map <  String ,  Blob Meta Data > blobs ) {  Blob Store Index Shard Snapshots new Snapshots = new  Blob Store Index Shard Snapshots ( snapshots ) ;  List <  String > blobs To Delete = new  Array List < > ( ) ; for (  String blob Name : blobs . key Set ( ) ) { if ( index Shard Snapshots Format . is Temp Blob Name ( blob Name ) || blob Name . starts With (  SNAPSHOT_ INDEX_ PREFIX ) ) { blobs To Delete . add ( blob Name ) ; } } try { blob Container . delete Blobs ( blobs To Delete ) ; } catch (  IOException e ) { throw new  Index Shard Snapshot Failed Exception ( shard Id , _ STR + e . get Message ( ) , e ) ; } blobs To Delete = new  Array List < > ( ) ; for (  String blob Name : blobs . key Set ( ) ) { if ( blob Name . starts With (  DATA_ BLOB_ PREFIX ) ) { if ( new Snapshots . find Name File (  File Info . canonical Name ( blob Name ) ) == null ) { blobs To Delete . add ( blob Name ) ; } } } try { blob Container . delete Blobs ( blobs To Delete ) ; } catch (  IOException e ) { logger . debug ( _ STR , e , snapshot Id , shard Id , blobs To Delete ) ; } if ( snapshots . size ( ) > _ NUM ) { try { index Shard Snapshots Format . write Atomic ( new Snapshots , blob Container ,  Integer . to String ( file List Generation ) ) ; } catch (  IOException e ) { throw new  Index Shard Snapshot Failed Exception ( shard Id , _ STR , e ) ; } } }
public void read From (  Channel Buffer data ) { this . wildcards = data . read Int ( ) ; this . input Port = data . read Short ( ) ; this . data Layer Source = new byte [ _ NUM ] ; data . read Bytes ( this . data Layer Source ) ; this . data Layer Destination = new byte [ _ NUM ] ; data . read Bytes ( this . data Layer Destination ) ; this . data Layer Virtual Lan = data . read Short ( ) ; this . data Layer Virtual Lan Priority Code Point = data . read Byte ( ) ; data . read Byte ( ) ; this . data Layer Type = data . read Short ( ) ; this . network Type Of Service = data . read Byte ( ) ; this . network Protocol = data . read Byte ( ) ; data . read Byte ( ) ; data . read Byte ( ) ; this . network Source = data . read Int ( ) ; this . network Destination = data . read Int ( ) ; this . transport Source = data . read Short ( ) ; this . transport Destination = data . read Short ( ) ; }
@  Override public boolean is Armed ( ) { boolean b = should Act Like Button ( ) || ( pressed When Popup Visible && combo Box . is Popup Visible ( ) ) ; return b ? is Pressed ( ) : super . is Armed ( ) ; }
public static  Attrib Key for Attribute (  Namespaces in Scope ,  El Key el ,  String qname ) {  Namespaces ns ;  String local Name ; int colon = qname . index Of ( _ STR ) ; if ( colon < _ NUM ) { ns = el . ns ; local Name = qname ; } else { ns = in Scope . for Attr Name ( el . ns , qname ) ; if ( ns == null ) { return null ; } ns = in Scope . for Uri ( ns . uri ) ; local Name = qname . substring ( colon + _ NUM ) ; } return new  Attrib Key ( el , ns , local Name ) ; }
Sparse Array (  Class <  L > linear Array Type , int [ ] linear Indices , int [ ] row Indices , int [ ] col Indices ,  L real ,  L imag , int num Rows , int num Cols ) { _num Rows = num Rows ; _num Cols = num Cols ; _base Component Type = linear Array Type . get Component Type ( ) ; _output Array Type = (  Class <  L [ ] > )  Array Utils . get Array Class ( _base Component Type , _ NUM ) ; _linear Indices = linear Indices ; _row Indices = row Indices ; _col Indices = col Indices ; _real Values = linear Array Type . cast ( real ) ; _imag Values = linear Array Type . cast ( imag ) ; }
protected void update Radio Links ( ) { m_ Set Test But . set Enabled ( m_ Test Split But . is Selected ( ) ) ; if ( ( m_ Set Test Frame != null ) && ( ! m_ Test Split But . is Selected ( ) ) ) { m_ Set Test Frame . set Visible ( _ BOOL ) ; } m_ CVText . set Enabled ( m_ CVBut . is Selected ( ) ) ; m_ CVLab . set Enabled ( m_ CVBut . is Selected ( ) ) ; m_ Percent Text . set Enabled ( m_ Percent But . is Selected ( ) ) ; m_ Percent Lab . set Enabled ( m_ Percent But . is Selected ( ) ) ; }
public double eval ( int id1 , int id2 ,  Instance inst1 ) throws  Exception { double div =  Math . sqrt ( super . eval ( id1 , id1 , inst1 ) * ( ( m_keys != null ) ? super . eval ( id2 , id2 , m_data . instance ( id2 ) ) : super . eval ( - _ NUM , - _ NUM , m_data . instance ( id2 ) ) ) ) ; if ( div != _ NUM ) { return super . eval ( id1 , id2 , inst1 ) / div ; } else { return _ NUM ; } }
public void copy Bits (  Bit Vector set ) {  System . arraycopy ( set . bits , _ NUM , this . bits , _ NUM , set . bits . length ) ; }
public void test Date To Number ( ) {  Number Converter converter = make Converter ( ) ;  Date date Value = new  Date ( ) ; long long Value = date Value . get Time ( ) ; assert Equals ( _ STR , new  Long ( long Value ) , converter . convert (  Long . class , date Value ) ) ; try { converter . convert (  Integer . class , date Value ) ; fail ( _ STR ) ; } catch (  Conversion Exception e ) { } }
private static void write Sort Order (  Byte Buffer buffer ,  Sort Order sort Order ,  Jet Format format ) { if ( sort Order == null ) { sort Order = format .  DEFAULT_ SORT_ ORDER ; } buffer . put Short ( sort Order . get Value ( ) ) ; if ( format .  SIZE_ SORT_ ORDER == _ NUM ) { buffer . put ( ( byte ) _ NUM ) ; buffer . put ( sort Order . get Version ( ) ) ; } }
private static double distance ( double x1 , double y1 , double x2 , double y2 ) { return  Math . sqrt ( ( y2 - y1 ) * ( y2 - y1 ) + ( x2 - x1 ) * ( x2 - x1 ) ) ; }
@  Override public  Object annotation Button ( final  Form Object form ) { final int subtype = form . get Parameter Constant (  Pdf Dictionary .  Subtype ) ; if ( subtype ==  Pdf Dictionary .  Popup ) { return create Annotation Popup ( form ) ; } if ( ! form . is Appearance Used ( ) ) { switch ( subtype ) { case  Pdf Dictionary .  Text : return create Annotation Text ( form ) ; case  Pdf Dictionary .  Free Text : return create Annotation Free Text ( form ) ; case  Pdf Dictionary .  Highlight : return create Anntoation Highlight ( form ) ; case  Pdf Dictionary .  Underline : return create Annotation Underline ( form ) ; case  Pdf Dictionary .  Ink : return create Annotation Ink ( form ) ; case  Pdf Dictionary .  Strick Out : return create Annotation Strike Out ( form ) ; } } return setup Annotation Button ( form ) ; }
@  Objective CName ( _ STR ) static  List <  Message > parse (  String message ,  Deepstream Client Abstract client ) {  List <  Message > messages = new  Array List < > ( ) ;  String [ ] raw Messages = message . split (  MS ) ;  Message parsed Message ; for (  String raw Message : raw Messages ) { parsed Message = parse Message ( raw Message , client ) ; if ( parsed Message != null ) { messages . add ( parsed Message ) ; } } return messages ; }
public static  Vector2 max (  Vector2 o1 ,  Vector2 o2 ) { return new  Vector2 (  Math . max ( o1 . x , o2 . x ) ,  Math . max ( o1 . z , o2 . z ) ) ; }
public static void save Nonvolatiles Around Sys Call (  Instruction call ,  IR ir ) { save Nonvolatiles Before Sys Call ( call , ir ) ; restore Nonvolatiles After Sys Call ( call , ir ) ; call . change Operator To (  IA32_ CALL ) ; }
public void serialize (  Managed Object Path Serializer serializer ) { for (  Element < ? , ? > element : elements ) { element . serialize ( serializer ) ; } }
private void migrate Block Mirrors ( ) { log . info ( _ STR ) ;  Db Client db Client = get Db Client ( ) ;  List <  URI > block Mirror URIs = db Client . query By Type (  Block Mirror . class , _ BOOL ) ;  Iterator <  Block Mirror > block Mirrors = db Client . query Iterative Objects (  Block Mirror . class , block Mirror URIs , _ BOOL ) ;  List <  Block Object > block Objects = new  Array List <  Block Object > ( ) ; while ( block Mirrors . has Next ( ) ) { block Objects . add ( block Mirrors . next ( ) ) ; } migrate Block Objects ( block Objects ) ; }
private void build Branch (  Tree Node parent ,  String [ ] values , int lvl ) { if ( lvl == values . length ) { parent . children = null ; return ; } if ( lvl > ( m_ Depth - _ NUM ) ) { m_ Depth = lvl + _ NUM ; }  Vector <  Tree Node > kids = parent . children ; int index = search ( kids , values [ lvl ] ) ; if ( index != - _ NUM ) {  Tree Node new Parent = kids . element At ( index ) ; if ( new Parent . children == null ) { new Parent . children = new  Vector <  Tree Node > ( ) ; } build Branch ( new Parent , values , lvl + _ NUM ) ; } else {  Tree Node added = new  Tree Node ( ) ; added . parent = parent ; added . value = values [ lvl ] ; added . children = new  Vector <  Tree Node > ( ) ; added . level = lvl ; if ( parent != m_ Root ) { added . context = parent . context + m_ Seperator + parent . value ; } else { added . context = parent . value ; } kids . add Element ( added ) ; build Branch ( added , values , lvl + _ NUM ) ; } }
private  Element create Organization (  String name ,  String displ Name ,  String url ,  String lang Str ) throws  Exception {  Element org Ele = doc . create Element (  SAMLNames .  ORGANIZATION ) ;  Element name Ele = doc . create Element (  SAMLNames .  ORGANIZATIONNAME ) ; name Ele . set Attribute (  SAMLNames .  XMLLANG ,  SAMLNames .  ENGLISH ) ; name Ele . append Child ( doc . create Text Node ( name ) ) ; org Ele . append Child ( name Ele ) ;  Element display Name Ele = doc . create Element (  SAMLNames .  ORGANIZATIONDISPLAYNAME ) ; display Name Ele . set Attribute (  SAMLNames .  XMLLANG ,  SAMLNames .  ENGLISH ) ; display Name Ele . append Child ( doc . create Text Node ( displ Name ) ) ; org Ele . append Child ( display Name Ele ) ;  String url Str = idm Client . get Entity ID ( tenant Name ) ; if ( url Str == null ) { url Str = tenant Name ; }  Element url Ele = doc . create Element (  SAMLNames .  ORGANIZATIONURL ) ; url Ele . set Attribute (  SAMLNames .  XMLLANG , lang Str ) ; url Ele . append Child ( doc . create Text Node ( url ) ) ; org Ele . append Child ( url Ele ) ; return org Ele ; }
public void clear ( ) { info Queue . clear ( ) ; allocator . release ( data Queue . to Array ( new  Allocation [ data Queue . size ( ) ] ) ) ; data Queue . clear ( ) ; total Bytes Dropped = _ NUM ; total Bytes Written = _ NUM ; last Allocation = null ; last Allocation Offset = allocation Length ; }
public void end Picking ( final  GL2 gl ) { int selected Index =  Picking State .  NONE ; final int how Many Objects = gl . gl Render Mode (  GL2 .  GL_ RENDER ) ; gl . gl Matrix Mode (  GLMatrix Func .  GL_ PROJECTION ) ; gl . gl Pop Matrix ( ) ; gl . gl Matrix Mode (  GLMatrix Func .  GL_ MODELVIEW ) ; if ( how Many Objects > _ NUM ) { selected Index = select Buffer . get ( _ NUM ) ; int mindistance =  Math . abs ( select Buffer . get ( _ NUM ) ) ; for ( int i = _ NUM ; i < how Many Objects ; i ++ ) { if ( mindistance <  Math . abs ( select Buffer . get ( _ NUM + i * _ NUM ) ) ) { mindistance =  Math . abs ( select Buffer . get ( _ NUM + i * _ NUM ) ) ; selected Index = select Buffer . get ( _ NUM + i * _ NUM ) ; } } } else { selected Index =  Picking State .  WORLD ; } picking State . set Picked Index ( selected Index ) ; }
public static  Result Set simple Result Set ( ) {  Simple Result Set rs = new  Simple Result Set ( ) ; rs . add Column ( _ STR ,  Types .  INTEGER , _ NUM , _ NUM ) ; rs . add Column ( _ STR ,  Types .  VARCHAR , _ NUM , _ NUM ) ; rs . add Row ( _ NUM , _ STR ) ; return rs ; }
public static void reconcile HLUs (  Db Client db Client ,  Export Group export Group ,  Export Mask export Mask ,  Map <  URI ,  Integer > volume Map ) { if ( export Mask . get Created By System ( ) && export Mask . get Volumes ( ) != null ) { for (  URI bo URI : volume Map . key Set ( ) ) {  String hlu = export Mask . return Volume HLU ( bo URI ) ; _log . info (  String . format ( _ STR , export Group . get Label ( ) , export Group . get Id ( ) , bo URI , hlu ) ) ; export Group . add Volume ( bo URI ,  Integer . parse Int ( hlu ) ) ; } reconcile Export Groups HLUs ( db Client , export Group ) ; } }
public boolean is Match (  Path Impl path ,  String prefix ) {  String suffix = _ STR ;  String full Path = path . get Path ( ) ; if ( prefix . length ( ) < full Path . length ( ) ) { suffix = full Path . substring ( prefix . length ( ) ) ; } for ( int i = _ NUM ; i < _exclude List . size ( ) ; i ++ ) {  Path Pattern Type pattern = _exclude List . get ( i ) ; if ( pattern . is Match ( suffix ) ) return _ BOOL ; } if ( _include List == null ) return _ BOOL ; for ( int i = _ NUM ; i < _include List . size ( ) ; i ++ ) {  Path Pattern Type pattern = _include List . get ( i ) ; if ( pattern . is Match ( suffix ) ) { return _ BOOL ; } } return _ BOOL ; }
private void apply Lower Bounds ( final  List < ? extends  Annotation Mirror > annos ) { if ( ! annos . is Empty ( ) ) { final  Annotated Type Mirror lower Bound = type Param . get Lower Bound ( ) ; for (  Annotation Mirror anno : annos ) { lower Bound . add Annotation ( anno ) ; } } }
void read (  Block Id blk ,  Io Buffer buffer ) { try {  Io Channel file Channel = get File Channel ( blk . file Name ( ) ) ; buffer . clear ( ) ; file Channel . read ( buffer , blk . number ( ) *  BLOCK_ SIZE ) ; } catch (  IOException e ) { e . print Stack Trace ( ) ; throw new  Runtime Exception ( _ STR + blk ) ; } }
private int digit Count (  String text , int position , int amount ) { int limit =  Math . min ( text . length ( ) - position , amount ) ; amount = _ NUM ; for ( ; limit > _ NUM ; limit -- ) { char c = text . char At ( position + amount ) ; if ( c < _ STR || c > _ STR ) { break ; } amount ++ ; } return amount ; }
@  Override @  Nullable public  Object find Template Source ( @  Not Null  String name ) throws  IOException {  File file = resolve Name ( name ) ;  Template Source template Source =  Template Source . open ( file ) ; push Template Folder ( file . get Parent File ( ) ) ; return template Source ; }
protected synchronized void init Interface (  Iterator <  OMEvent > it , boolean set Selected ) { if ( logger . is Loggable (  Level .  FINE ) ) { logger . fine ( _ STR ) ; }  Default List Model list Model = new  Default List Model ( ) ; int selected Index = - _ NUM ; int cur Index = _ NUM ; while ( it . has Next ( ) ) {  OMEvent cur Event = it . next ( ) ; list Model . add Element ( cur Event ) ; if ( last Selected Event == cur Event && last Selected Event != null ) { selected Index = cur Index ; } cur Index ++ ; } if ( logger . is Loggable (  Level .  FINE ) ) { logger . fine ( _ STR + cur Index + _ STR ) ; } if ( display List == null ) { if ( logger . is Loggable (  Level .  FINE ) ) { logger . fine ( _ STR ) ; }  JPanel wrapper = new  JPanel ( ) ;  Grid Bag Layout gridbag = new  Grid Bag Layout ( ) ;  Grid Bag Constraints c = new  Grid Bag Constraints ( ) ; wrapper . set Layout ( gridbag ) ; c . fill =  Grid Bag Constraints .  BOTH ; c . weighty = _ NUM ; c . weightx = _ NUM ; c . gridwidth =  Grid Bag Constraints .  REMAINDER ; c . insets = new  Insets ( _ NUM , _ NUM , _ NUM , _ NUM ) ; if ( ttmanager == null ) { ttmanager =  Tool Tip Manager . shared Instance ( ) ; ttmanager . set Enabled ( _ BOOL ) ; ttmanager . set Initial Delay ( _ NUM ) ; } else if ( display List != null ) { ttmanager . unregister Component ( display List ) ; } display List = new  JList ( list Model ) ; display List . set Selection Mode (  List Selection Model .  MULTIPLE_ INTERVAL_ SELECTION ) ; display List . add List Selection Listener ( this ) ; display List . add Mouse Listener ( this ) ; display List . add Mouse Motion Listener ( this ) ; display List . set Cell Renderer ( get Event Cell Renderer ( ) ) ; ttmanager . register Component ( display List ) ;  JScroll Pane list Scroll Pane = new  JScroll Pane ( display List ) ; list Scroll Pane . set Preferred Size ( new  Dimension ( pref Width , pref Height ) ) ; list Scroll Pane . set Horizontal Scroll Bar Policy (  JScroll Pane .  HORIZONTAL_ SCROLLBAR_ NEVER ) ; list Scroll Pane . set Vertical Scroll Bar Policy (  JScroll Pane .  VERTICAL_ SCROLLBAR_ AS_ NEEDED ) ; gridbag . set Constraints ( list Scroll Pane , c ) ; wrapper . add ( list Scroll Pane ) ; c . fill =  Grid Bag Constraints .  HORIZONTAL ; c . weighty = _ NUM ; detail Space = new  JLabel ( _ STR ) ; detail Space Panel = new  JPanel ( new  Border Layout ( ) ) ; detail Space Panel . set Background ( new  Color ( _ NUM ) ) ; detail Space Panel . set Visible ( _ BOOL ) ; detail Space Panel . add ( detail Space ,  Border Layout .  CENTER ) ; gridbag . set Constraints ( detail Space Panel , c ) ; wrapper . add ( detail Space Panel ) ;  JComponent ecp = get Event Control Panel ( ) ; gridbag . set Constraints ( ecp , c ) ; wrapper . add ( ecp ) ; add ( wrapper ,  Border Layout .  CENTER ) ; validate ( ) ; repaint ( ) ; if ( logger . is Loggable (  Level .  FINE ) ) { logger . fine ( _ STR ) ; } } else { set List Model ( list Model ) ; display List . revalidate ( ) ; display List . repaint ( ) ; } if ( logger . is Loggable (  Level .  FINE ) ) { logger . fine ( _ STR ) ; } if ( selected Index >= _ NUM && set Selected ) { display List . set Selected Index ( selected Index ) ; } else { last Selected Event = null ; } }
@  Safe Varargs public static final <  T >  List <  T > list (  T ... items ) {  Array List <  T > list = new  Array List <  T > ( items . length ) ; for (  T item : items ) { list . add ( item ) ; } return list ; }
public void save (  Output Stream os ) throws  IOException {  Data Output Stream dos = null ; try { dos = new  Data Output Stream ( os ) ; dos . write Long (  FILE_ MAGIC_ NUMBER ) ; dos . write Int (  FILE_ VERSION ) ; save Extensions ( critical Extensions , dos ) ; save Extensions ( non Critical Extensions , dos ) ; } finally {  IOUtils . close Quietly ( dos ) ; } }
public long start_brk ( ) { return  Long . parse Long ( fields [ _ NUM ] ) ; }
private static byte [ ] generate Seed ( ) { try {  Byte Array Output Stream seed Buffer = new  Byte Array Output Stream ( ) ;  Data Output Stream seed Buffer Out = new  Data Output Stream ( seed Buffer ) ; seed Buffer Out . write Long (  System . current Time Millis ( ) ) ; seed Buffer Out . write Long (  System . nano Time ( ) ) ; seed Buffer Out . write Int (  Process . my Pid ( ) ) ; seed Buffer Out . write Int (  Process . my Uid ( ) ) ; seed Buffer Out . write (  BUILD_ FINGERPRINT_ AND_ DEVICE_ SERIAL ) ; seed Buffer Out . close ( ) ; return seed Buffer . to Byte Array ( ) ; } catch (  IOException e ) { throw new  Security Exception ( _ STR , e ) ; } }
public void add Filter (  Value Expr the Expr ) { m Filters . add ( the Expr ) ; }
public void start Sampling ( ) { if ( m Sampling Counter . get And Increment ( ) == _ NUM ) { m Handler . start Sampling Thread ( ) ; m Last Time Reading =  System Clock . elapsed Realtime ( ) ; } }
public  DSign Csr (  JFrame parent ,  Spkac spkac Csr ,  File csr File ,  Private Key sign Private Key ,  Key Pair Type sign Key Pair Type ,  X509 Certificate verification Certificate ,  Provider provider ) throws  Crypto Exception { super ( parent ,  Dialog .  Modality Type .  DOCUMENT_ MODAL ) ; this . spkac Csr = spkac Csr ; this . csr File = csr File ; this . sign Private Key = sign Private Key ; this . sign Key Pair Type = sign Key Pair Type ; this . verification Certificate = verification Certificate ; this . provider = provider ; set Title ( res . get String ( _ STR ) ) ; init Components ( ) ; }
public static  Volume rollback Volume (  URI volume URI ,  Db Client db Client ) {  Volume volume = db Client . query Object (  Volume . class , volume URI ) ; if ( volume != null && ! volume . get Inactive ( ) ) { _log . info (  String . format ( _ STR , volume . get Label ( ) ) ) ; if ( volume . get Provisioned Capacity ( ) == null || volume . get Provisioned Capacity ( ) == _ NUM ) { db Client . mark For Deletion ( volume ) ; } else {  String rollback Label = _ STR +  Math . random ( ) ; volume . set Label ( volume . get Label ( ) + rollback Label ) ; db Client . update Object ( volume ) ; } if (  RPHelper . is VPlex Volume ( volume , db Client ) && ( null != volume . get Associated Volumes ( ) ) ) { for (  String associated Vol Id : volume . get Associated Volumes ( ) ) {  Volume associated Volume = db Client . query Object (  Volume . class ,  URI . create ( associated Vol Id ) ) ; if ( associated Volume != null && ! associated Volume . get Inactive ( ) ) { _log . info (  String . format ( _ STR , associated Volume . get Label ( ) ) ) ; if ( associated Volume . get Provisioned Capacity ( ) == null || associated Volume . get Provisioned Capacity ( ) == _ NUM ) { db Client . mark For Deletion ( associated Volume ) ; } else { associated Volume . set Label ( volume . get Label ( ) + _ STR +  Math . random ( ) ) ; db Client . update Object ( associated Volume ) ; } } } } } return volume ; }
public static  String format Millis To Seconds ( long time ) { double sec = time / _ NUM ; return millis Format . format ( sec ) + _ STR ; }
public static  String left (  String s , int width , char fill Char ) { if ( s . length ( ) >= width ) { return s ; }  String Buffer sb = new  String Buffer ( width ) ; sb . append ( s ) ; for ( int i = width - s . length ( ) ; -- i >= _ NUM ; ) { sb . append ( fill Char ) ; } return sb . to String ( ) ; }
public synchronized boolean add All (  Collection c ) { mod Count ++ ;  Object [ ] a = c . to Array ( ) ; int num New = a . length ; ensure Capacity Helper ( element Count + num New ) ;  System . arraycopy ( a , _ NUM , element Data , element Count , num New ) ; element Count += num New ; return num New != _ NUM ; }
public void update (  CSTState state ) { new Checkpoint ( state . get Serialized State ( ) , state . get State Hash ( ) , state . get Checkpoint CID ( ) ) ; set Last Checkpoint CID ( state . get Checkpoint CID ( ) ) ; }
private static <  T > void execute Script ( final  File file , final  T plugin Interface ) { final  List <  Pair <  String ,  Object > > bindings = new  Array List < > ( ) ; final  Console Writer console Writer = new  Console Writer ( new  String Writer ( ) ) ; bindings . add ( new  Pair <  String ,  Object > ( _ STR , plugin Interface ) ) ; bindings . add ( new  Pair <  String ,  Object > ( _ STR , console Writer ) ) ; try {  Script Runner . run Script ( file , bindings ) ; if ( console Writer . get Output ( ) != null ) {  Navi Logger . info ( console Writer . get Output ( ) ) ; } } catch ( final  Exception exception ) { final  String message = _ STR + _ STR ; final  String description =  CUtility Functions . create Description (  String . format ( _ STR + _ STR + _ STR , file . get Absolute File ( ) ) , new  String [ ] { _ STR } , new  String [ ] { _ STR + _ STR } ) ;  Navi Logger . severe ( message ) ;  CUtility Functions . log Exception ( exception ) ;  Navi Logger . severe ( console Writer . get Output ( ) ) ;  Navi Error Dialog . show ( null , message , description , exception ) ; } }
public void remove Message Observer ( final  Message Observer observer ) { if ( observer == null ) { throw new  Null Pointer Exception ( ) ; } else if ( message Observers != null ) { message Observers . remove ( observer ) ; } }
public int calculate Partition ( char _initial Char , int num Partitions ) { final int partition Size = ( int ) (  Math . ceil ( _ NUM / ( double ) num Partitions ) ) ; int initial Char = ( int ) _initial Char ; if ( initial Char < _ STR ) return _ NUM ; if ( initial Char > _ STR ) return num Partitions - _ NUM ; return ( initial Char - _ NUM ) / partition Size ; }
private static void byte2hex ( byte b ,  String Buffer buf ) { char [ ] hex Chars = { _ STR , _ STR , _ STR , _ STR , _ STR , _ STR , _ STR , _ STR , _ STR , _ STR , _ STR , _ STR , _ STR , _ STR , _ STR , _ STR } ; int high = ( ( b & _ NUM ) > > _ NUM ) ; int low = ( b & _ NUM ) ; buf . append ( hex Chars [ high ] ) ; buf . append ( hex Chars [ low ] ) ; }
public  E remove ( int index ) { range Check ( index ) ; mod Count ++ ;  E old Value = (  E ) element Data [ index ] ; int num Moved = size - index - _ NUM ; if ( num Moved > _ NUM )  System . arraycopy ( element Data , index + _ NUM , element Data , index , num Moved ) ; element Data [ -- size ] = null ; return old Value ; }
public static  Double Vector rchisq ( int n , double ncp ,  Random random ) {  Double Vector v = new  Double Vector ( n ) ; double mean =  Math . sqrt ( ncp ) ; double x ; for ( int i = _ NUM ; i < n ; i ++ ) { x = random . next Gaussian ( ) + mean ; v . set ( i , x * x ) ; } return v ; }
public static boolean is Font Embedded (  Pdf Object pdf Object ) { final int font Type = pdf Object . get Parameter Constant (  Pdf Dictionary .  Subtype ) ; if ( font Type ==  Standard Fonts .  TYPE0 ) { pdf Object = pdf Object . get Dictionary (  Pdf Dictionary .  Descendant Fonts ) ; } final  Pdf Object desc Font Obj = pdf Object . get Dictionary (  Pdf Dictionary .  Font Descriptor ) ; if ( desc Font Obj == null ) { return _ BOOL ; } else { return desc Font Obj . has Stream ( ) ; } }
void warning Occurred ( int code ) { cb Lock . lock ( ) ; try { if ( ( code < _ NUM ) || ( code >  MAX_ WARNING ) ) { throw new  Internal Error ( _ STR ) ; } process Warning Occurred ( current Image , _ STR ,  Integer . to String ( code ) ) ; } finally { cb Lock . unlock ( ) ; } }
public static boolean copy Tree (  String source Dir ,  String target Root ) { boolean result ; try {  File source = new  File ( source Dir ) ;  File root = new  File ( target Root ) ; if ( source . exists ( ) == _ BOOL || source . is Directory ( ) == _ BOOL ) { log . error ( _ STR + source . get Canonical Path ( ) + _ STR ) ; return _ BOOL ; } if ( root . exists ( ) == _ BOOL ) { log . error ( _ STR + root . get Canonical Path ( ) + _ STR ) ; log . info ( _ STR ) ; if ( ! root . mkdirs ( ) ) { log . equals ( _ STR ) ; return _ BOOL ; } }  String target Root Name =  Paths . check Path Ending ( root . get Canonical Path ( ) ) ;  Array List <  File > file Names = list All Files ( source , _ BOOL ) ; result = _ BOOL ;  File target ; for (  File f : file Names ) {  String full Name = f . get Canonical Path ( ) ; int pos = full Name . index Of ( source Dir ) ;  String sub Name = null ; if ( source Dir . ends With ( _ STR ) ) sub Name = full Name . substring ( pos + source Dir . length ( ) ) ; else sub Name = full Name . substring ( pos + source Dir . length ( ) + _ NUM ) ;  String target Name = target Root Name + sub Name ; target = new  File ( target Name ) ; if ( f . is Directory ( ) ) { if ( target . exists ( ) == _ BOOL ) { boolean st = target . mkdir ( ) ; if ( st == _ BOOL ) result = _ BOOL ; } continue ; } boolean st = file Copy ( f , target ) ; if ( st == _ BOOL ) result = _ BOOL ; } } catch (  Exception e ) { e . print Stack Trace ( ) ; result = _ BOOL ; } return result ; }
public boolean resource Exist (  Integer id ) { if ( id == null ) { return _ BOOL ; } return resource Exist ( id . int Value ( ) ) ; }
public void clear2 Lead Search Light ( int bit ) { if ( node Type !=  SMINI ) { log . error ( _ STR ) ; return ; } if ( ( bit < _ NUM ) || ( bit > _ NUM ) ) { log . error ( _ STR +  Integer . to String ( bit ) ) ; return ; } if ( ( loc Search Light Bits [ bit ] != _ NUM ) || ( loc Search Light Bits [ bit + _ NUM ] != _ NUM ) ) { log . error ( _ STR +  Integer . to String ( bit ) ) ; return ; } loc Search Light Bits [ bit ] = _ NUM ; loc Search Light Bits [ bit + _ NUM ] = _ NUM ; num2 LSearch Lights -- ; }
public void calc Major Tick ( ) { fraction =  UNIT ; double u = major Tick ; double r = max Tick - min Tick ; major Tick Count = ( int ) ( r / u ) ; while ( major Tick Count < pref Major Tick Count ) { u = major Tick / _ NUM ; if ( ! is Discrete || u ==  Math . floor ( u ) ) { major Tick Count = ( int ) ( r / u ) ; fraction =  HALFS ; if ( major Tick Count >= pref Major Tick Count ) break ; } u = major Tick / _ NUM ; if ( ! is Discrete || u ==  Math . floor ( u ) ) { major Tick Count = ( int ) ( r / u ) ; fraction =  QUARTERS ; if ( major Tick Count >= pref Major Tick Count ) break ; } u = major Tick / _ NUM ; if ( ! is Discrete || u ==  Math . floor ( u ) ) { major Tick Count = ( int ) ( r / u ) ; fraction =  FIFTHS ; if ( major Tick Count >= pref Major Tick Count ) break ; } if ( is Discrete && ( major Tick / _ NUM ) !=  Math . floor ( major Tick / _ NUM ) ) { u = major Tick ; major Tick Count = ( int ) ( r / u ) ; break ; } major Tick /= _ NUM ; u = major Tick ; major Tick Count = ( int ) ( r / u ) ; fraction =  UNIT ; } major Tick = u ; if ( is Discrete && major Tick < _ NUM ) { major Tick = _ NUM ; major Tick Count = ( int ) ( r / major Tick ) ; fraction =  UNIT ; } major Tick Count ++ ; while ( ( min Tick + major Tick - epsilon ) < min Data ) { min Tick += major Tick ; major Tick Count -- ; } while ( ( max Tick - major Tick + epsilon ) > max Data ) { max Tick -= major Tick ; major Tick Count -- ; } }
public  Sample Attribute Table merge Samples (  Collection <  String > samples ,  String new Name ) {  Sample Attribute Table sample Attribute Table = new  Sample Attribute Table ( ) ;  Map <  String ,  Object > attribute2value = new  Hash Map < > ( ) ; for (  String attribute : get Attribute Set ( ) ) { boolean value Mismatch = _ BOOL ;  Object previous Value = null ; for (  String sample : samples ) {  Object value = table . get ( sample , attribute ) ; if ( value != null ) { if ( previous Value == null ) previous Value = value ; else if ( ! value . equals ( previous Value ) ) { value Mismatch = _ BOOL ; break ; } } } if ( ! value Mismatch && previous Value != null ) { attribute2value . put ( attribute , previous Value ) ; } } sample Attribute Table . add Sample ( new Name , attribute2value , _ BOOL , _ BOOL ) ; return sample Attribute Table ; }
@  Override public  List <  Evaluation Statistics > aggregate (  List <  Evaluation Statistics > stats ) {  List <  Evaluation Statistics > result ;  List <  Evaluation Statistics > temp ;  Evaluation Statistics Comparator comp ; int i ; try { stats = new  Array List < > ( stats ) ; result = new  Array List < > ( ) ; comp = new  Evaluation Statistics Comparator (  Utils . split Options ( m_ Aggregation Keys ) ) ;  Collections . sort ( stats , comp ) ; i = _ NUM ; temp = new  Array List < > ( ) ; while ( i < stats . size ( ) ) { if ( ( temp . size ( ) == _ NUM ) || ( comp . compare ( temp . get ( temp . size ( ) - _ NUM ) , stats . get ( i ) ) == _ NUM ) ) { temp . add ( stats . get ( i ) ) ; i ++ ; } else { result . add ( do Aggregate ( temp ) ) ; temp . clear ( ) ; } } if ( temp . size ( ) > _ NUM ) result . add ( do Aggregate ( temp ) ) ; } catch (  Exception e ) { result = stats ; handle Exception ( _ STR , e ) ; } return result ; }
public void dispose ( ) {  Object [ ] in Nodes Array = in Nodes . to Array ( ) ; for ( int i = _ NUM ; i < in Nodes Array . length ; i ++ ) {  Digraph Node node = (  Digraph Node ) in Nodes Array [ i ] ; node . remove Edge ( this ) ; }  Object [ ] out Nodes Array = out Nodes . to Array ( ) ; for ( int i = _ NUM ; i < out Nodes Array . length ; i ++ ) {  Digraph Node node = (  Digraph Node ) out Nodes Array [ i ] ; remove Edge ( node ) ; } }
private  String file To String (  File file ) throws  IOException {  Input Stream in = new  Buffered Input Stream ( new  File Input Stream ( file ) , _ NUM ) ;  Reader reader ; in . mark ( _ NUM ) ; int byte1 = in . read ( ) ; int byte2 = in . read ( ) ; if ( byte1 == _ NUM && byte2 == _ NUM ) { reader = new  Input Stream Reader ( in , _ STR ) ; } else if ( byte1 == _ NUM && byte2 == _ NUM ) { reader = new  Input Stream Reader ( in , _ STR ) ; } else { int byte3 = in . read ( ) ; if ( byte1 == _ NUM && byte2 == _ NUM && byte3 == _ NUM ) { reader = new  Input Stream Reader ( in , _ STR ) ; } else { in . reset ( ) ; reader = new  Input Stream Reader ( in ) ; } }  String Writer out = new  String Writer ( ) ; char [ ] buffer = new char [ _ NUM ] ; int count ; while ( ( count = reader . read ( buffer ) ) != - _ NUM ) { out . write ( buffer , _ NUM , count ) ; } in . close ( ) ; return out . to String ( ) ; }
public  Shape straight Line Shape ( ) {  General Path path = null ; if ( llpts != null && llpts . length >= _ NUM && llpts . length % _ NUM == _ NUM ) { double y1 = llpts [ _ NUM ] ; double x1 = llpts [ _ NUM ] ; path = new  General Path (  General Path .  WIND_ EVEN_ ODD , llpts . length / _ NUM ) ; if ( return Degrees ) { path . move To (  Proj Math . rad To Deg ( x1 ) ,  Proj Math . rad To Deg ( y1 ) ) ; } else { path . move To ( x1 , y1 ) ; } for ( int i = _ NUM ; i < llpts . length - _ NUM ; i += _ NUM ) { x1 = llpts [ i + _ NUM ] ; y1 = llpts [ i ] ; if ( return Degrees ) { path . line To (  Proj Math . rad To Deg ( x1 ) ,  Proj Math . rad To Deg ( y1 ) ) ; } else { path . line To ( x1 , y1 ) ; } } } return path ; }
public  DTLSSession (  Inet Socket Address peer Address , boolean is Client ) { this ( peer Address , is Client , _ NUM ) ; }
protected static  Vector convert To Vector ( final  Object [ ] [ ] an Array ) { if ( an Array == null ) { return null ; } final  Vector v = new  Vector ( an Array . length ) ; for ( final  Object [ ] element : an Array ) { v . add Element ( convert To Vector ( element ) ) ; } return v ; }
synchronized protected void timeout ( ) {  Sprog Version v ; switch ( state ) { case  CRSENT : log . debug ( _ STR ) ; state =  Query State .  IDLE ; v = new  Sprog Version ( new  Sprog Type (  Sprog Type .  TIMEOUT ) ) ; notify Version ( v ) ; break ; case  QUERYSENT : log . debug ( _ STR ) ; state =  Query State .  IDLE ; v = new  Sprog Version ( new  Sprog Type (  Sprog Type .  NOT_ A_ SPROG ) ) ; notify Version ( v ) ; break ; case  DONE : case  IDLE : log . error ( _ STR + state ) ; break ; } }
protected void accept Drag ( int drag Operation ) {  Drop Target Context Peer peer = get Drop Target Context Peer ( ) ; if ( peer != null ) { peer . accept Drag ( drag Operation ) ; } }
@  Override public  String to String ( ) {  Vector <  Capability > sorted ;  String Buffer result ; result = new  String Buffer ( ) ; sorted = new  Vector <  Capability > ( m_ Capabilities ) ;  Collections . sort ( sorted ) ; result . append ( _ STR + sorted . to String ( ) + _ STR ) ; sorted = new  Vector <  Capability > ( m_ Dependencies ) ;  Collections . sort ( sorted ) ; result . append ( _ STR + sorted . to String ( ) + _ STR ) ; result . append ( _ STR + get Minimum Number Instances ( ) + _ STR ) ; return result . to String ( ) ; }
private void reconstruct States (  Tree tree ,  Node Ref node , int [ ] parent States ) { for ( int i = _ NUM ; i < patterns . get Pattern Count ( ) ; i ++ ) { double [ ]  Sa = node Scores [ node . get Number ( ) ] [ i ] ; if ( compress States ) { int [ ] set = state Sets [ i ] ; int min State = set [ _ NUM ] ; double min Cost =  Sa [ min State ] + cost Matrix [ parent States [ i ] ] [ min State ] ; for ( int j = _ NUM ; j < set . length ; j ++ ) { double c =  Sa [ set [ j ] ] + cost Matrix [ parent States [ i ] ] [ set [ j ] ] ; if ( c < min Cost ) { min State = set [ j ] ; min Cost = c ; } } node States [ node . get Number ( ) ] [ i ] = min State ; } else { int min State = _ NUM ; double min Cost =  Sa [ min State ] + cost Matrix [ parent States [ i ] ] [ min State ] ; for ( int j = _ NUM ; j <  Sa . length ; j ++ ) { double c =  Sa [ j ] + cost Matrix [ parent States [ i ] ] [ j ] ; if ( c < min Cost ) { min State = j ; min Cost = c ; } } node States [ node . get Number ( ) ] [ i ] = min State ; } } for ( int i = _ NUM ; i < tree . get Child Count ( node ) ; i ++ ) { reconstruct States ( tree , tree . get Child ( node , i ) , node States [ node . get Number ( ) ] ) ; } }
public long file Size (  String path ) throws  Illegal State Exception ,  IOException ,  FTPIllegal Reply Exception ,  FTPException { synchronized ( lock ) { if ( ! connected ) { throw new  Illegal State Exception ( _ STR ) ; } if ( ! authenticated ) { throw new  Illegal State Exception ( _ STR ) ; } communication . send FTPCommand ( _ STR ) ;  FTPReply r = communication . read FTPReply ( ) ; touch Auto Noop Timer ( ) ; if ( ! r . is Success Code ( ) ) { throw new  FTPException ( r ) ; } communication . send FTPCommand ( _ STR + path ) ; r = communication . read FTPReply ( ) ; touch Auto Noop Timer ( ) ; if ( ! r . is Success Code ( ) ) { throw new  FTPException ( r ) ; }  String [ ] messages = r . get Messages ( ) ; if ( messages . length != _ NUM ) { throw new  FTPIllegal Reply Exception ( ) ; } else { try { return  Long . parse Long ( messages [ _ NUM ] ) ; } catch (  Throwable t ) { throw new  FTPIllegal Reply Exception ( ) ; } } } }
public boolean is Selected ( ) { return check Box . is Selected ( ) ; }
public  Phase One Result process (  Tree Path body Path ,  Processing Environment env ,  Underlying AST underlying AST ,  Label exceptional Exit Label ,  Tree Builder tree Builder ,  Annotation Provider annotation Provider ) { this . env = env ; this . try Stack = new  Try Stack ( exceptional Exit Label ) ; this . tree Builder = tree Builder ; this . annotation Provider = annotation Provider ; elements = env . get Element Utils ( ) ; types = env . get Type Utils ( ) ; tree Lookup Map = new  Identity Hash Map < > ( ) ; converted Tree Lookup Map = new  Identity Hash Map < > ( ) ; node List = new  Array List < > ( ) ; bindings = new  Hash Map < > ( ) ; leaders = new  Hash Set < > ( ) ; break Labels = new  Hash Map < > ( ) ; continue Labels = new  Hash Map < > ( ) ; return Nodes = new  Array List < > ( ) ; scan ( body Path , null ) ; node List . add ( new  Unconditional Jump ( regular Exit Label ) ) ; return new  Phase One Result ( underlying AST , tree Lookup Map , converted Tree Lookup Map , node List , bindings , leaders , return Nodes ) ; }
public boolean is Fusion ( ) { if ( ( engine Type ==  COMBUSTION_ ENGINE ) || ( engine Type ==  FISSION ) || ( engine Type ==  FUEL_ CELL ) || ( engine Type ==  NONE ) || ( engine Type ==  BATTERY ) || ( engine Type ==  SOLAR ) || ( engine Type ==  STEAM ) || ( engine Type ==  MAGLEV ) ) { return _ BOOL ; } return _ BOOL ; }
private double [ ] calculate B ( ) { int length = m Extremal Indices . size ( ) ; double [ ] b = new double [ length ] ; for ( int k = _ NUM ; k < length ; k ++ ) { b [ k ] = _ NUM ; double xk = m Grid . get Cosine Frequency Grid ( ) [ m Extremal Indices . get ( k ) ] ; for ( int i = _ NUM ; i < length ; i ++ ) { if ( i != k ) { double xi = m Grid . get Cosine Frequency Grid ( ) [ m Extremal Indices . get ( i ) ] ; double denominator = xk - xi ; if (  Math . abs ( denominator ) < _ NUM ) { denominator = _ NUM ; } b [ k ] *= _ NUM / denominator ; } } } return b ; }
private long read UTFSpan (  String Builder sbuf , long utflen ) throws  IOException { int cpos = _ NUM ; int start = pos ; int avail =  Math . min ( end - pos ,  CHAR_ BUF_ SIZE ) ; int stop = pos + ( ( utflen > avail ) ? avail - _ NUM : ( int ) utflen ) ; boolean out Of Bounds = _ BOOL ; try { while ( pos < stop ) { int b1 , b2 , b3 ; b1 = buf [ pos ++ ] & _ NUM ; switch ( b1 > > _ NUM ) { case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : case _ NUM : cbuf [ cpos ++ ] = ( char ) b1 ; break ; case _ NUM : case _ NUM : b2 = buf [ pos ++ ] ; if ( ( b2 & _ NUM ) != _ NUM ) { throw new  UTFData Format Exception ( ) ; } cbuf [ cpos ++ ] = ( char ) ( ( ( b1 & _ NUM ) << _ NUM ) | ( ( b2 & _ NUM ) << _ NUM ) ) ; break ; case _ NUM : b3 = buf [ pos + _ NUM ] ; b2 = buf [ pos + _ NUM ] ; pos += _ NUM ; if ( ( b2 & _ NUM ) != _ NUM || ( b3 & _ NUM ) != _ NUM ) { throw new  UTFData Format Exception ( ) ; } cbuf [ cpos ++ ] = ( char ) ( ( ( b1 & _ NUM ) << _ NUM ) | ( ( b2 & _ NUM ) << _ NUM ) | ( ( b3 & _ NUM ) << _ NUM ) ) ; break ; default : throw new  UTFData Format Exception ( ) ; } } } catch (  Array Index Out Of Bounds Exception ex ) { out Of Bounds = _ BOOL ; } finally { if ( out Of Bounds || ( pos - start ) > utflen ) { pos = start + ( int ) utflen ; throw new  UTFData Format Exception ( ) ; } } sbuf . append ( cbuf , _ NUM , cpos ) ; return pos - start ; }
private static  Properties load Properties ( ) {  Properties properties = new  Properties ( ) ;  File file = new  File ( _ STR ) ;  File Input Stream fis = null ; try { if ( file . exists ( ) ) { fis = new  File Input Stream ( file ) ; properties . load ( fis ) ; } } catch (  Exception e ) {  LOGGER . error ( e , e . get Message ( ) ) ; } finally { if ( null != fis ) { try { fis . close ( ) ; } catch (  IOException e ) {  LOGGER . error ( e , e . get Message ( ) ) ; } } } return properties ; }
public  Map <  String ,  Set <  String > > evaluate (  Subject admin Subject ,  String realm ,  Subject subject ,  String resource Name ,  Map <  String ,  Set <  String > > environment ) throws  Entitlement Exception {  Subject Attributes Manager sac =  Subject Attributes Manager . get Instance ( admin Subject , realm ) ;  Set <  String > names = new  Hash Set <  String > ( ) ; if ( ( property Values == null ) || property Values . is Empty ( ) ) { names . add ( property Name ) ; } else { names . add All ( property Values ) ; }  Map <  String ,  Set <  String > > values = sac . get User Attributes ( subject , names ) ;  Set <  String > tmp = new  Hash Set <  String > ( ) ; if ( ( values != null ) && ! values . is Empty ( ) ) { for (  String k : values . key Set ( ) ) { tmp . add All ( values . get ( k ) ) ; } }  Map <  String ,  Set <  String > > results = new  Hash Map <  String ,  Set <  String > > ( ) ; results . put ( property Name , tmp ) ; return results ; }
@  Suppress Warnings ( _ STR ) public <  U >  Lazy Future Stream <  U > from ( final  Iterator <  U > iterator ) { return from Stream (  Stream Support . stream (  Spliterators . spliterator Unknown Size ( iterator ,  Spliterator .  ORDERED ) , _ BOOL ) ) ; }
private  Dimension layout Size (  Container target , boolean preferred ) { synchronized ( target . get Tree Lock ( ) ) { int target Width = target . get Size ( ) . width ; if ( target Width == _ NUM ) target Width =  Integer .  MAX_ VALUE ; int hgap = get Hgap ( ) ; int vgap = get Vgap ( ) ;  Insets insets = target . get Insets ( ) ; int horizontal Insets And Gap = insets . left + insets . right + ( hgap * _ NUM ) ; int max Width = target Width - horizontal Insets And Gap ;  Dimension dim = new  Dimension ( _ NUM , _ NUM ) ; int row Width = _ NUM ; int row Height = _ NUM ; int nmembers = target . get Component Count ( ) ; for ( int i = _ NUM ; i < nmembers ; i ++ ) {  Component m = target . get Component ( i ) ; if ( m . is Visible ( ) ) {  Dimension d = preferred ? m . get Preferred Size ( ) : m . get Minimum Size ( ) ; if ( row Width + d . width > max Width ) { add Row ( dim , row Width , row Height ) ; row Width = _ NUM ; row Height = _ NUM ; } if ( row Width != _ NUM ) { row Width += hgap ; } row Width += d . width ; row Height =  Math . max ( row Height , d . height ) ; } } add Row ( dim , row Width , row Height ) ; dim . width += horizontal Insets And Gap ; dim . height += insets . top + insets . bottom + vgap * _ NUM ;  Container scroll Pane =  Swing Utilities . get Ancestor Of Class (  JScroll Pane . class , target ) ; if ( scroll Pane != null && target . is Valid ( ) ) { dim . width -= ( hgap + _ NUM ) ; } return dim ; } }
private void read Object ( final java . io .  Object Input Stream in ) throws  IOException ,  Class Not Found Exception { time Stamp = in . read Long ( ) ; duration = in . read Long ( ) ; }
public  Interval XYItem Label Generator ( ) { this (  DEFAULT_ ITEM_ LABEL_ FORMAT ,  Number Format . get Number Instance ( ) ,  Number Format . get Number Instance ( ) ) ; }
public double adjusted Log10 ( double val ) { boolean neg Flag = ( val < _ NUM ) ; if ( neg Flag ) { val = - val ; } if ( val < _ NUM ) { val += ( _ NUM - val ) / _ NUM ; } double res =  Math . log ( val ) /  LOG10_ VALUE ; return neg Flag ? ( - res ) : res ; }
public boolean is Last Invoice ( ) {  String cm = get Costing Method ( ) ; return cm != null && cm . equals (  COSTINGMETHOD_ Last Invoice ) &&  COSTELEMENTTYPE_ Material . equals ( get Cost Element Type ( ) ) ; }
public static  String build Cluster Cg Name (  String cluster Name ,  String cg Name ) { return  String . format ( _ STR +  SPLITTER + _ STR , cluster Name , cg Name ) ; }
public void fetch My Walls (  String user Id ) {  Retro Callback retro Callback ; retro Callback = new  Retro Callback ( this ) ; retro Callback . set Request Id (  Http Constants .  Api Response Codes .  GET_ USER_ WALLS ) ; retro Callback List . add ( retro Callback ) ; m Yelo Api . get User Walls ( user Id , retro Callback ) ; m Swipe Refresh Layout . set Refreshing ( _ BOOL ) ; }
public  DDate Time Chooser (  JFrame parent ,  String title ,  Date date ) { super ( parent , title ,  Dialog .  Modality Type .  DOCUMENT_ MODAL ) ; init Components ( date ) ; }
public  List <  Colour Change > sample Conditional Migration Events ( int parent Colour , double parent Height , int child Colour , double child Height , double [ ] m ) {  List <  Colour Change > colour Changes = new  Array List <  Colour Change > ( ) ; int current Colour ; double current Height ; do { colour Changes . clear ( ) ; current Colour = parent Colour ; current Height = parent Height ; do { double total Rate = m [ _ NUM - current Colour ] ; double  U =  Math Utils . next Double ( ) ; if ( ( parent Colour != child Colour ) && ( colour Changes . size ( ) == _ NUM ) ) { double min U =  Math . exp ( - total Rate * ( parent Height - child Height ) ) ;  U = min U +  U * ( _ NUM - min U ) ; } double time = -  Math . log (  U ) / total Rate ; current Height -= time ; if ( current Height > child Height ) { current Colour = _ NUM - current Colour ; colour Changes . add ( new  Colour Change ( current Height , current Colour ) ) ; } } while ( current Height > child Height ) ; } while ( current Colour != child Colour ) ; reverse Colour Change List ( colour Changes , parent Colour ) ; return colour Changes ; }
private void validate Cloumns (  Map <  String ,  Object > column Name To Type Map ) { if ( column Name To Type Map == null ) { throw new  Illegal Argument Exception ( _ STR ) ; } for (  Map .  Entry <  String ,  Object > entry : column Name To Type Map . entry Set ( ) ) {  Object obj Value = entry . get Value ( ) ; if ( obj Value == null ) { throw new  Illegal Argument Exception ( _ STR + entry . get Key ( ) + _ STR ) ; } if ( obj Value instanceof  Class < ? > ) { continue ; } if ( obj Value instanceof  String ) { try { entry . set Value (  Class . for Name ( (  String ) obj Value ) ) ; } catch (  Class Not Found Exception e ) { throw new  Illegal Argument Exception ( _ STR , e ) ; } } } }
public void write ( final byte b [ ] , final int off , final int len ) throws  IOException { if ( ! m_open ) { throw new  Illegal State Exception ( _ STR ) ; } if ( ( m_cursor + len ) >  WORM_ STREAM_ BUFFER_ SIZE ) { for ( int i = _ NUM ; i < len ; i ++ ) { write ( b [ off + i ] ) ; } } else {  System . arraycopy ( b , off , m_buffer , m_cursor , len ) ; m_cursor += len ; } }
private void draw ( final  Execution Unit process , final  Graphics2 D g2 , final  Process Renderer Model renderer Model , final boolean printing ) { if ( ! visualizer . is Active ( ) ) { return ; }  List <  Operator > selected Operators = renderer Model . get Selected Operators ( ) ; for (  Operator operator : process . get Operators ( ) ) { if ( selected Operators . contains ( operator ) ) { continue ; } draw Op Anno ( operator , g2 , renderer Model , printing ) ; } for (  Operator sel Op : selected Operators ) { if ( process . equals ( sel Op . get Execution Unit ( ) ) ) { draw Op Anno ( sel Op , g2 , renderer Model , printing ) ; } } }
public synchronized void remove Property Change Listener (  Property Change Listener listener ) { listener List . remove ( listener ) ; }
private void forward Media File (  String mime Type ,  Uri media Uri ) {  String reshare Path = _ STR + media Uri . get Path ( ) ;  Intent share Intent = new  Intent ( context ,  Im Url Activity . class ) ; share Intent . set Action (  Intent .  ACTION_ SEND ) ; share Intent . set Data And Type (  Uri . parse ( reshare Path ) , mime Type ) ; context . start Activity ( share Intent ) ; }
@  Caller Sensitive public static <  U >  Atomic Integer Field Updater <  U > new Updater (  Class <  U > tclass ,  String field Name ) { return new  Atomic Integer Field Updater Impl <  U > ( tclass , field Name ,  Reflection . get Caller Class ( ) ) ; }
public static void tql2 ( int n , double [ ] d , double [ ] e , double [ ] [ ]  V ) { for ( int i = _ NUM ; i < n ; i ++ ) { e [ i - _ NUM ] = e [ i ] ; } e [ n - _ NUM ] = _ NUM ; double f = _ NUM ; double tst1 = _ NUM ; double eps =  Math . pow ( _ NUM , - _ NUM ) ; for ( int l = _ NUM ; l < n ; l ++ ) { tst1 =  Math . max ( tst1 ,  Math . abs ( d [ l ] ) +  Math . abs ( e [ l ] ) ) ; int m = l ; while ( m < n ) { if (  Math . abs ( e [ m ] ) <= eps * tst1 ) { break ; } m ++ ; } if ( m > l ) { int iter = _ NUM ; do { iter = iter + _ NUM ; double g = d [ l ] ; double p = ( d [ l + _ NUM ] - g ) / ( _ NUM * e [ l ] ) ; double r = hypot ( p , _ NUM ) ; if ( p < _ NUM ) { r = - r ; } d [ l ] = e [ l ] / ( p + r ) ; d [ l + _ NUM ] = e [ l ] * ( p + r ) ; double dl1 = d [ l + _ NUM ] ; double h = g - d [ l ] ; for ( int i = l + _ NUM ; i < n ; i ++ ) { d [ i ] -= h ; } f = f + h ; p = d [ m ] ; double c = _ NUM ; double c2 = c ; double c3 = c ; double el1 = e [ l + _ NUM ] ; double s = _ NUM ; double s2 = _ NUM ; for ( int i = m - _ NUM ; i >= l ; i -- ) { c3 = c2 ; c2 = c ; s2 = s ; g = c * e [ i ] ; h = c * p ; r = hypot ( p , e [ i ] ) ; e [ i + _ NUM ] = s * r ; s = e [ i ] / r ; c = p / r ; p = c * d [ i ] - s * g ; d [ i + _ NUM ] = h + s * ( c * g + s * d [ i ] ) ; for ( int k = _ NUM ; k < n ; k ++ ) { h =  V [ k ] [ i + _ NUM ] ;  V [ k ] [ i + _ NUM ] = s *  V [ k ] [ i ] + c * h ;  V [ k ] [ i ] = c *  V [ k ] [ i ] - s * h ; } } p = - s * s2 * c3 * el1 * e [ l ] / dl1 ; e [ l ] = s * p ; d [ l ] = c * p ; } while (  Math . abs ( e [ l ] ) > eps * tst1 ) ; } d [ l ] = d [ l ] + f ; e [ l ] = _ NUM ; } for ( int i = _ NUM ; i < n - _ NUM ; i ++ ) { int k = i ; double p = d [ i ] ; for ( int j = i + _ NUM ; j < n ; j ++ ) { if ( d [ j ] < p ) { k = j ; p = d [ j ] ; } } if ( k != i ) { d [ k ] = d [ i ] ; d [ i ] = p ; for ( int j = _ NUM ; j < n ; j ++ ) { p =  V [ j ] [ i ] ;  V [ j ] [ i ] =  V [ j ] [ k ] ;  V [ j ] [ k ] = p ; } } } }
private static  Pair <  String ,  String > post Indexed LSL ( final long offset , final  ITranslation Environment environment , final  List <  Reil Instruction > instructions , final  String register Node Value1 , final  String register Node Value2 , final  String immediate Node Value ) { final  String address = environment . get Next Variable String ( ) ; final  String tmp Var1 = environment . get Next Variable String ( ) ; final  String tmp Var2 = environment . get Next Variable String ( ) ; final  String index = environment . get Next Variable String ( ) ; long base Offset = offset ; instructions . add (  Reil Helpers . create Str ( base Offset ++ , dw , register Node Value1 , dw , address ) ) ; instructions . add (  Reil Helpers . create Bsh ( base Offset ++ , dw , register Node Value2 , dw , immediate Node Value , qw , tmp Var1 ) ) ; instructions . add (  Reil Helpers . create And ( base Offset ++ , qw , tmp Var1 , dw , d Word Bit Mask , dw , index ) ) ; instructions . add (  Reil Helpers . create Add ( base Offset ++ , dw , register Node Value1 , dw , index , dw , tmp Var2 ) ) ; instructions . add (  Reil Helpers . create And ( base Offset ++ , dw , tmp Var2 , dw , d Word Bit Mask , dw , register Node Value1 ) ) ; return new  Pair <  String ,  String > ( address , register Node Value1 ) ; }
private void apply Partner Device Profile Overrides (  Context ctx ,  Display Metrics dm ) {  Partner p =  Partner . get ( ctx . get Package Manager ( ) ) ; if ( p != null ) {  Device Profile partner Dp = p . get Device Profile Override ( dm ) ; if ( partner Dp != null ) { if ( partner Dp . num Rows > _ NUM && partner Dp . num Columns > _ NUM ) { num Rows = partner Dp . num Rows ; num Columns = partner Dp . num Columns ; } if ( partner Dp . all Apps Short Edge Count > _ NUM && partner Dp . all Apps Long Edge Count > _ NUM ) { all Apps Short Edge Count = partner Dp . all Apps Short Edge Count ; all Apps Long Edge Count = partner Dp . all Apps Long Edge Count ; } if ( partner Dp . icon Size > _ NUM ) { icon Size = partner Dp . icon Size ; all Apps Icon Size Px =  Dynamic Grid . px From Dp ( icon Size , dm ) ; } } } }
public final int last_common_layer (  Brd Item p_other ) { int max_first_layer =  Math . max ( first_layer ( ) , p_other . first_layer ( ) ) ; int min_last_layer =  Math . min ( last_layer ( ) , p_other . last_layer ( ) ) ; if ( max_first_layer > min_last_layer ) return - _ NUM ; return min_last_layer ; }
public  Item Stack add Item (  Item Stack drive ,  Item Stack item ) { if ( get Max Kilobits ( drive ) == - _ NUM ) { if ( get Partitioning Mode ( drive ) ==  Partitioning Mode .  NONE || find Data Index For Prototype ( drive , create Prototype ( item ) ) != - _ NUM ) { item . stack Size = _ NUM ; return null ; } else { return item ; } } int bits Free = get Kilobits Free For ( drive , item ) ; int amount Taken =  Math . min ( item . stack Size , bits Free ) ; int current = get Amount Stored ( drive , item ) ; if ( amount Taken > _ NUM ) { set Amount Stored ( drive , item , current + amount Taken ) ; item . stack Size -= amount Taken ; mark Dirty ( drive ) ; } if ( item . stack Size <= _ NUM ) { return null ; } else { return item ; } }
public boolean add ( int value ) { int index = value % this . num Buckets ;  Bucket bucket = this . buckets [ index ] ; if ( bucket == null ) { bucket = this . buckets [ index ] = new  Bucket ( this . bucket Initial Capacity ) ; } else { for ( int i = _ NUM ; i < bucket . length ; i ++ ) { if ( bucket . values [ i ] == value ) return _ BOOL ; } } if ( bucket . values . length <= bucket . length ) { int [ ] tmp = new int [ _ NUM * bucket . values . length ] ;  System . arraycopy ( bucket . values , _ NUM , tmp , _ NUM , bucket . values . length ) ; bucket . values = tmp ; } bucket . values [ bucket . length ++ ] = value ; this . size ++ ; return _ BOOL ; }
public void add Item (  Artist artist ) { if ( artist == null ) throw new  Null Pointer Exception ( _ STR ) ; artists . add ( artist ) ; notify Item Inserted ( get Item Count ( ) - _ NUM ) ; }
public  Data Source (  String location ) throws  Exception { super ( ) ; if ( location . starts With ( _ STR ) || location . starts With ( _ STR ) || location . starts With ( _ STR ) || location . starts With ( _ STR ) ) { m_ URL = new  URL ( location ) ; } else { m_ File = new  File ( location ) ; } if ( is Arff ( location ) ) { m_ Loader = new  Arff Loader ( ) ; } else { if ( m_ File != null ) { m_ Loader =  Converter Utils . get Loader For File ( location ) ; } else { m_ Loader =  Converter Utils . get URLLoader For File ( location ) ; } if ( m_ Loader == null ) { throw new  Illegal Argument Exception ( _ STR + location + _ STR ) ; } } m_ Incremental = ( m_ Loader instanceof  Incremental Converter ) ; reset ( ) ; }
private static void save Confirmed Stack Traces (  Weak Reference <  Context > weak Context ) {  Context context = null ; if ( weak Context != null ) { context = weak Context . get ( ) ; if ( context != null ) { try {  String [ ] filenames = search For Report ( ) ;  Shared Preferences preferences = context . get Shared Preferences (  ARTISAN_ SDK ,  Context .  MODE_ PRIVATE ) ;  Editor editor = preferences . edit ( ) ; editor . put String ( _ STR , join Array ( filenames , _ STR ) ) ; editor . apply ( ) ; } catch (  Exception e ) { } } } }
public void encode (  Output Stream out ) throws  IOException {  Der Output Stream tmp = new  Der Output Stream ( ) ; if ( this . extension Value == null ) { this . extension Id =  PKIXExtensions .  Invalidity Date_ Id ; this . critical = _ BOOL ; encode This ( ) ; } super . encode ( tmp ) ; out . write ( tmp . to Byte Array ( ) ) ; }
public  Driver Task create Volumes (  List <  Storage Volume > volumes ,  Storage Capabilities storage Capabilities ) {  Driver Task task = new  Dell SCDriver Task ( _ STR ) ;  String Builder err Buffer = new  String Builder ( ) ; int volumes Created = _ NUM ; for (  Storage Volume volume : volumes ) {  LOG . debug ( _ STR , volume . get Display Name ( ) , volume . get Storage System Id ( ) ) ;  String ssn = volume . get Storage System Id ( ) ; try {  Storage Center API api = connection Manager . get Connection ( ssn ) ;  Sc Volume sc Vol = api . create Volume ( ssn , volume . get Display Name ( ) , volume . get Storage Pool Id ( ) ,  Size Util . byte To Meg ( volume . get Requested Capacity ( ) ) , volume . get Consistency Group ( ) ) ; volume . set Provisioned Capacity (  Size Util . size Str To Bytes ( sc Vol . configured Size ) ) ; volume . set Allocated Capacity ( _ NUM ) ; volume . set Wwn ( sc Vol . device Id ) ; volume . set Native Id ( sc Vol . instance Id ) ; volume . set Device Label ( sc Vol . name ) ; volume . set Access Status (  Access Status .  READ_ WRITE ) ; volumes Created ++ ;  LOG . info ( _ STR , sc Vol . name ) ; } catch (  Storage Center APIException |  Dell SCDriver Exception dex ) {  String error =  String . format ( _ STR , volume . get Display Name ( ) , dex ) ;  LOG . error ( error ) ; err Buffer . append (  String . format ( _ STR , error ) ) ; } } task . set Message ( err Buffer . to String ( ) ) ; if ( volumes Created == volumes . size ( ) ) { task . set Status (  Task Status .  READY ) ; } else if ( volumes Created == _ NUM ) { task . set Status (  Task Status .  FAILED ) ; } else { task . set Status (  Task Status .  PARTIALLY_ FAILED ) ; } return task ; }
public void create Vm Async ( final  String project Id , final  Vm Create Spec vm Create Spec , final  Future Callback <  Task > response Callback ) throws  IOException { final  String path =  String . format ( _ STR , get Base Path ( ) , project Id ) ; create Object Async ( path , serialize Object As Json ( vm Create Spec ) , response Callback ) ; }
public static  Result Code value Of ( final int int Value ) {  Result Code result =  ELEMENTS . get ( int Value ) ; if ( result == null ) { result = new  Result Code ( int Value ,  Localizable Message . raw ( _ STR + int Value + _ STR ) , _ BOOL ,  Enum .  UNKNOWN ) ; } return result ; }
public static void write Unsafe (  Packet Output Stream out ,  Input Stream is , boolean no Backslash Escapes ) throws  IOException { out . write Unsafe (  QUOTE ) ; byte [ ] buffer = new byte [ _ NUM ] ; int len ; while ( ( len = is . read ( buffer ) ) >= _ NUM ) { write Bytes Escaped Unsafe ( out , buffer , len , no Backslash Escapes ) ; } out . write Unsafe (  QUOTE ) ; }
public int read (  Byte Buffer dst , int dst Start , int dst Length ) throws  IOException { final int remaining = ( int )  Math . min ( this . length - this . position ,  Integer .  MAX_ VALUE ) ; final int read =  Math . min ( remaining , dst Length ) ; final int buffer Position = check Offset ( position , read ) ; final long src Address =  Platform Dependent . direct Buffer Address ( last Mapped ) + buffer Position ; if ( dst . is Direct ( ) ) { final long dst Address =  Platform Dependent . direct Buffer Address ( dst ) + dst Start ;  Platform Dependent . copy Memory ( src Address , dst Address , read ) ; } else { final byte [ ] dst Array = dst . array ( ) ;  Platform Dependent . copy Memory ( src Address , dst Array , dst Start , read ) ; } position += read ; return read ; }
public byte [ ] encode To Bitcoin ( ) { if ( schnorr != null ) { try {  Byte Array Output Stream bos = new  Byte Array Output Stream ( _ NUM ) ; bos . write ( schnorr ) ; bos . write ( sighash Flags ) ; return bos . to Byte Array ( ) ; } catch (  IOException e ) { throw new  Runtime Exception ( e ) ; } } try {  Byte Array Output Stream bos = der Byte Stream ( ) ; bos . write ( sighash Flags ) ; return bos . to Byte Array ( ) ; } catch (  IOException e ) { throw new  Runtime Exception ( e ) ; } }
public boolean is Reconnect Needed ( ) { if ( file Lock Method !=  File Lock .  LOCK_ SERIALIZED ) { return _ BOOL ; } if ( reconnect Change Pending ) { return _ BOOL ; } long now =  System . current Time Millis ( ) ; if ( now < reconnect Check Next ) { return _ BOOL ; } reconnect Check Next = now + reconnect Check Delay ; if ( lock == null ) { lock = new  File Lock ( trace System , database Name +  Constants .  SUFFIX_ LOCK_ FILE ,  Constants .  LOCK_ SLEEP ) ; } try {  Properties prop = lock . load ( ) , first = prop ; while ( _ BOOL ) { if ( prop . equals ( reconnect Last Lock ) ) { return _ BOOL ; } if ( prop . get Property ( _ STR , null ) == null ) { break ; } if (  System . current Time Millis ( ) > now + reconnect Check Delay * _ NUM ) { if ( first . equals ( prop ) ) { lock . set Property ( _ STR , null ) ; lock . save ( ) ; break ; } } trace . debug ( _ STR ) ;  Thread . sleep ( reconnect Check Delay ) ; prop = lock . load ( ) ; } reconnect Last Lock = prop ; } catch (  Exception e ) { trace . error ( e , _ STR , read Only ) ; } return _ BOOL ; }
public static <  T > int compare (  Comparable <  T > object1 ,  T object2 ) { if ( ( null != object1 ) && ( null != object2 ) ) { return object1 . compare To ( object2 ) ; } else if ( null != object1 ) { return _ NUM ; } else if ( null != object2 ) { return - _ NUM ; } else { return _ NUM ; } }
public static void si Wait (  Object o , long time ) { try { if ( time == - _ NUM ) o . wait ( ) ; else o . wait ( time ) ; } catch (  Interrupted Exception e ) { throw new  SIException ( ) ; } abort Or Pause If Necessary ( ) ; }
private void log OData Perf (  String query , long delta_time ) {  LOGGER . debug ( _ STR + get Id ( ) + _ STR + query + _ STR + delta_time + _ STR ) ; }
public static  Geo Time Serie from GTSWrapper To GTS (  GTSWrapper wrapper ) {  Metadata metadata = wrapper . get Metadata ( ) ;  Geo Time Serie gts = null ; if ( null != wrapper . get Encoded ( ) ) { byte [ ] bytes = null ; if ( wrapper . is Compressed ( ) ) { bytes = unwrap Encoded ( wrapper ) ; } else { bytes = wrapper . get Encoded ( ) ; }  Byte Buffer bb =  Byte Buffer . wrap ( bytes ) ;  GTSDecoder decoder = new  GTSDecoder ( wrapper . get Base ( ) , bb ) ; decoder . set Count ( _ NUM != wrapper . get Count ( ) ? wrapper . get Count ( ) : bytes . length / _ NUM ) ; gts = decoder . decode ( ) ; } else { gts = new  Geo Time Serie ( ) ; } if ( null == metadata ) { metadata = new  Metadata ( ) ; } if ( wrapper . is Set Bucketcount ( ) ) { gts . bucketcount = ( int ) wrapper . get Bucketcount ( ) ; } if ( wrapper . is Set Bucketspan ( ) ) { gts . bucketspan = wrapper . get Bucketspan ( ) ; } if ( wrapper . is Set Lastbucket ( ) ) { gts . lastbucket = wrapper . get Lastbucket ( ) ; } gts . set Metadata ( metadata ) ; return gts ; }
public static void send SLORequests To Other Participants (  String tenant ,  Logout State logout State ) throws  IOException { log . info ( _ STR ) ;  Locale locale = logout State . get Locale ( ) ;  Http Servlet Response response = logout State . get Response ( ) ;  Validate . not Null ( response ) ;  Collection <  String > saml Request Urls = logout State . generate Request Urls For Tenant ( tenant , logout State . get Message Source ( ) , locale ) ; if ( saml Request Urls == null ) return ; for (  String request Url : saml Request Urls ) { log . info ( _ STR + request Url ) ; if ( request Url != null ) {  Throwable exception = null ; try { send SLORequest To Other Participant ( request Url ) ; } catch (  URISyntax Exception e ) { exception = e ; } catch (  IOException e ) { exception = e ; } catch (  Key Management Exception e ) { exception = e ; } catch (  No Such Algorithm Exception e ) { exception = e ; } catch (  Key Store Exception e ) { exception = e ; } if ( exception != null ) { log . error ( _ STR + request Url , exception ) ; } } else {  Saml Service Impl . send Logout Error ( locale , response , logout State , logout State . get Message Source ( ) ) ; } } }
public static void assert Label (  String name ,  String text ) { if ( verbose ) { log ( _ STR + name + _ STR + text + _ STR ) ; }  Label l = (  Label ) find By Name ( name ) ; assert Bool ( l != null , _ STR + text ) ; assert Bool ( text == l . get Text ( ) || text . equals ( l . get Text ( ) ) , name + _ STR + text ) ; }
public static boolean is Equivalent (  Array List <  Path Parser .  Path Data Node > original ,  Array List <  Path Parser .  Path Data Node > alternative ) { int inner Start = _ NUM ; for (  Path Parser .  Path Data Node o : original ) { boolean found = _ BOOL ; for ( int i = inner Start ; i < alternative . size ( ) && ! found ; i ++ ) {  Path Parser .  Path Data Node n = alternative . get ( i ) ; if ( ( o . m Type == n . m Type &&  Arrays . equals ( o . m Params , n . m Params ) ) || ( ( o . m Type == _ STR || o . m Type == _ STR ) && n . m Type == _ STR ) ) { found = _ BOOL ; inner Start = i + _ NUM ; } } if ( ! found ) return _ BOOL ; } return _ BOOL ; }
private  Stream Tokenizer make Arff Tokenizer (  Buffered Reader br ) {  Stream Tokenizer tokenizer = new  Stream Tokenizer ( br ) ; { tokenizer . reset Syntax ( ) ; tokenizer . whitespace Chars ( _ NUM , _ STR ) ; tokenizer . ordinary Chars ( _ STR , _ STR ) ; tokenizer . ordinary Char ( _ STR ) ; tokenizer . ordinary Char ( _ STR ) ; tokenizer . word Chars ( _ STR + _ NUM , _ STR ) ; tokenizer . whitespace Chars ( _ STR , _ STR ) ; tokenizer . comment Char ( _ STR ) ; tokenizer . quote Char ( _ STR ) ; tokenizer . quote Char ( _ STR ) ; tokenizer . ordinary Char ( _ STR ) ; tokenizer . ordinary Char ( _ STR ) ; tokenizer . eol Is Significant ( _ BOOL ) ; } return tokenizer ; }
protected void close All Activities ( ) throws  Exception { try { for ( int i = _ NUM ; i < _ NUM ; i ++ ) { press Back ( ) ;  Thread . sleep ( _ NUM ) ; } } catch (  No Activity Resumed Exception |  Interrupted Exception e ) { } }
protected void view Record Field (  DDFField po Field ) {  DDFField Definition po Field Defn = po Field . get Field Defn ( ) ;  Debug . output ( _ STR + po Field Defn . get Name ( ) + _ STR + po Field Defn . get Description ( ) ) ; byte [ ] pach Field Data = po Field . get Data ( ) ; int n Bytes Remaining = po Field . get Data Size ( ) ; for ( int i Repeat = _ NUM ; i Repeat < po Field . get Repeat Count ( ) ; i Repeat ++ ) { if ( i Repeat > _ NUM ) {  Debug . output ( _ STR + i Repeat + _ STR ) ; } for ( int i SF = _ NUM ; i SF < po Field Defn . get Subfield Count ( ) ; i SF ++ ) {  DDFSubfield Definition po SFDefn = po Field Defn . get Subfield Defn ( i SF ) ; int n Bytes Consumed = view Subfield ( po SFDefn , pach Field Data , n Bytes Remaining ) ; n Bytes Remaining -= n Bytes Consumed ; byte [ ] temp Data = new byte [ pach Field Data . length - n Bytes Consumed ] ;  System . arraycopy ( pach Field Data , n Bytes Consumed , temp Data , _ NUM , temp Data . length ) ; pach Field Data = temp Data ; } } }
@  Override public boolean lock ( ) { try { if ( !  File Factory . is File Exist ( location ,  File Factory . get File Type ( tmp Path ) ) ) {  File Factory . mkdirs ( location ,  File Factory . get File Type ( tmp Path ) ) ; } lock File Path = location +  Carbon Common Constants .  FILE_ SEPARATOR + lock File ; if ( !  File Factory . is File Exist ( lock File Path ,  File Factory . get File Type ( location ) ) ) {  File Factory . create New Lock File ( lock File Path ,  File Factory . get File Type ( location ) ) ; } file Output Stream = new  File Output Stream ( lock File Path ) ; channel = file Output Stream . get Channel ( ) ; try { file Lock = channel . try Lock ( ) ; } catch (  Overlapping File Lock Exception e ) { return _ BOOL ; } if ( null != file Lock ) { return _ BOOL ; } else { return _ BOOL ; } } catch (  IOException e ) { return _ BOOL ; } }
public  List <  Script > populate Scripts From File List ( final  List <  File > files ) { final  List <  Script > added Scripts = new  Array List < > ( ) ; for ( final  File script File : files ) {  Script script = scripts . get (  Script . get Script Id From File ( script File ) ) ; if ( script == null ) { script = new  Script ( ) ; create File Based Script ( script , script File , new  Script Details ( _ BOOL , _ BOOL , script File . get Name ( ) ) ) ; added Scripts . add ( script ) ; add Script ( script ) ; } } return added Scripts ; }
public void enable (  Rich Formatter Feature feature ) { features . add ( feature ) ; }
public void add Event Listener (  ZWave Event Listener event Listener ) { synchronized ( zwave Event Listeners ) { if ( zwave Event Listeners . contains ( event Listener ) ) { logger . debug ( _ STR , event Listener ) ; return ; } zwave Event Listeners . add ( event Listener ) ; } }
public double can Use (  Gadget Type gadget ) {  Object count = gadget Cooldowns . get ( gadget ) ; if ( count == null ||  System . current Time Millis ( ) > ( long ) count ) { return - _ NUM ; } double value Millis = ( long ) count -  System . current Time Millis ( ) ; return value Millis / _ NUM ; }
public  Change Set add All To Collection (  String path ,  Serializable ... new Items ) { return add All To Collection ( path ,  Arrays . as List ( new Items ) ) ; }
public static  String quote (  String name ) { return  JVMModule Util . quote ( name ) ; }
private static <  T ,  ID >  Mapped Delete Collection <  T ,  ID > build (  Database Type database Type ,  Table Info <  T ,  ID > table Info , int data Size ) throws  SQLException {  Field Type id Field = table Info . get Id Field ( ) ; if ( id Field == null ) { throw new  SQLException ( _ STR + table Info . get Data Class ( ) + _ STR ) ; }  String Builder sb = new  String Builder ( _ NUM ) ; append Table Name ( database Type , sb , _ STR , table Info . get Table Name ( ) ) ;  Field Type [ ] arg Field Types = new  Field Type [ data Size ] ; append Where Ids ( database Type , id Field , sb , data Size , arg Field Types ) ; return new  Mapped Delete Collection <  T ,  ID > ( table Info , sb . to String ( ) , arg Field Types ) ; }
public static  String pad Left (  String s , int length ) { if ( s . length ( ) > length ) { throw new  Runtime Exception ( s + _ STR + length + _ STR ) ; }  String t = _ STR ; for ( int i = _ NUM ; i < length - s . length ( ) ; i ++ ) { t += _ STR ; } return t + s ; }
@  HLEFunction ( nid = _ NUM , version = _ NUM ) public int sce Rtc Get Tick (  Sce Psp Date Time time ,  TPointer64 ticks Addr ) {  Calendar cal = new  Gregorian Calendar ( time . year , time . month - _ NUM , time . day , time . hour , time . minute , time . second ) ; cal . set (  Calendar .  MILLISECOND , time . microsecond / _ NUM ) ; cal . set Time Zone (  Sce Psp Date Time .  GMT ) ; long ticks = rtc Magic Offset + ( cal . get Time In Millis ( ) * _ NUM ) + ( time . microsecond % _ NUM ) ; ticks Addr . set Value ( ticks ) ; if ( log . is Debug Enabled ( ) ) { log . debug (  String . format ( _ STR , ticks ) ) ; } return _ NUM ; }
private void populate Nav Drawer ( ) { m Nav Drawer Items . clear ( ) ; m Nav Drawer Items . add (  NAVDRAWER_ ITEM_ HOME ) ; m Nav Drawer Items . add (  NAVDRAWER_ ITEM_ WEBVIEW ) ; m Nav Drawer Items . add (  NAVDRAWER_ ITEM_ TSTB ) ; m Nav Drawer Items . add (  NAVDRAWER_ ITEM_ VOICE_ COMMANDS ) ; m Nav Drawer Items . add (  NAVDRAWER_ ITEM_ PALETTE ) ; m Nav Drawer Items . add (  NAVDRAWER_ ITEM_ SEPARATOR_ SPECIAL ) ; m Nav Drawer Items . add (  NAVDRAWER_ ITEM_ ABOUT ) ; m Nav Drawer Items . add (  NAVDRAWER_ ITEM_ BUG_ REPORT ) ; m Nav Drawer Items . add (  NAVDRAWER_ ITEM_ REQUEST ) ; create Nav Drawer Items ( ) ; }
protected static  Dfp [ ] split ( final  Dfp Field field , final  String a ) {  Dfp result [ ] = new  Dfp [ _ NUM ] ; char [ ] buf ; boolean leading = _ BOOL ; int sp = _ NUM ; int sig = _ NUM ; buf = new char [ a . length ( ) ] ; for ( int i = _ NUM ; i < buf . length ; i ++ ) { buf [ i ] = a . char At ( i ) ; if ( buf [ i ] >= _ STR && buf [ i ] <= _ STR ) { leading = _ BOOL ; } if ( buf [ i ] == _ STR ) { sig += ( _ NUM - sig ) % _ NUM ; leading = _ BOOL ; } if ( sig == ( field . get Radix Digits ( ) / _ NUM ) * _ NUM ) { sp = i ; break ; } if ( buf [ i ] >= _ STR && buf [ i ] <= _ STR && ! leading ) { sig ++ ; } } result [ _ NUM ] = field . new Dfp ( new  String ( buf , _ NUM , sp ) ) ; for ( int i = _ NUM ; i < buf . length ; i ++ ) { buf [ i ] = a . char At ( i ) ; if ( buf [ i ] >= _ STR && buf [ i ] <= _ STR && i < sp ) { buf [ i ] = _ STR ; } } result [ _ NUM ] = field . new Dfp ( new  String ( buf ) ) ; return result ; }
private void write XMLContent ( char [ ] content , int start , int length , boolean escape Chars ) throws  XMLStream Exception { if ( ! escape Chars ) { _writer . write ( content , start , length ) ; return ; } int start Write Pos = start ; final int end = start + length ; for ( int index = start ; index < end ; index ++ ) { char ch = content [ index ] ; if ( ! _writer . can Encode ( ch ) ) { _writer . write ( content , start Write Pos , index - start Write Pos ) ; _writer . write (  ENCODING_ PREFIX ) ; _writer . write (  Integer . to Hex String ( ch ) ) ; _writer . write (  SEMICOLON ) ; start Write Pos = index + _ NUM ; continue ; } switch ( ch ) { case  OPEN_ START_ TAG : _writer . write ( content , start Write Pos , index - start Write Pos ) ; _writer . write ( _ STR ) ; start Write Pos = index + _ NUM ; break ; case  AMPERSAND : _writer . write ( content , start Write Pos , index - start Write Pos ) ; _writer . write ( _ STR ) ; start Write Pos = index + _ NUM ; break ; case  CLOSE_ START_ TAG : _writer . write ( content , start Write Pos , index - start Write Pos ) ; _writer . write ( _ STR ) ; start Write Pos = index + _ NUM ; break ; } } _writer . write ( content , start Write Pos , end - start Write Pos ) ; }
public static byte [ ] values (  Byte [ ] array ) { byte [ ] dest = new byte [ array . length ] ; for ( int i = _ NUM ; i < array . length ; i ++ ) {  Byte v = array [ i ] ; if ( v != null ) { dest [ i ] = v . byte Value ( ) ; } } return dest ; }
public void audit Config (  Operation Type Enum audit Type ,  String operational Status ,  String description ,  Object ... descparams ) { _audit Mgr . record Audit Log ( null , null ,  EVENT_ SERVICE_ TYPE , audit Type ,  System . current Time Millis ( ) , operational Status , description , descparams ) ; }
public static double mean ( double [ ] data , int start Index , int end Index ) { double mean = _ NUM ; int total = _ NUM ; start Index =  Math . max ( start Index , _ NUM ) ; start Index =  Math . min ( start Index , data . length - _ NUM ) ; end Index =  Math . max ( end Index , _ NUM ) ; end Index =  Math . min ( end Index , data . length - _ NUM ) ; if ( start Index > end Index ) start Index = end Index ; for ( int i = start Index ; i <= end Index ; i ++ ) { if (  Double . is Na N ( data [ i ] ) ) throw new  Illegal Argument Exception ( _ STR ) ; mean += data [ i ] ; total ++ ; } mean /= total ; return mean ; }
public  Run Stats delegate Get Bucket For Fourthousand Year Dates ( int buckets ) throws  Exception { long start Time =  System . current Time Millis ( ) ;  Primary Index Bucket Generator Impl ibg = new  Primary Index Bucket Generator Impl (  Field Data Type .  DATE_ TIME , buckets ) ;  Primary Index Bucket Locator Impl locator = new  Primary Index Bucket Locator Impl ( null , ibg . generate Buckets ( ) , null , null , null , null , null , null , null ) ; logger . debug ( _ STR ) ;  Simple Date Format simple Dt Format = new  Simple Date Format ( _ STR ) ;  String start Date = _ STR ;  Hash Map <  Long ,  List <  Object > > hm = new  Hash Map < > ( ) ;  Summary Statistics stats = new  Summary Statistics ( ) ;  Date date = null ; for ( int i = _ NUM ; i < _ NUM ; i ++ ) { date = simple Dt Format . parse ( start Date ) ; final  Date  TIME = new  Date ( ( long ) (  Math . random ( ) * _ NUM ) ) ; date . set Time ( date . get Time ( ) +  TIME . get Time ( ) ) ;  Long bucket Id = locator . get Bucket ( start Date ,  Field Data Type .  DATE_ TIME ) ; calculate ( hm , stats , bucket Id , start Date ) ; date . set Time ( date . get Time ( ) + _ NUM -  TIME . get Time ( ) ) ; start Date = simple Dt Format . format ( date . get Time ( ) ) ; } long run Time =  System . current Time Millis ( ) - start Time ;  Run Stats run Stats = new  Run Stats ( _ STR ,  Field Data Type .  DATE_ TIME , run Time , stats , hm ) ; logger . debug ( run Stats . to String ( ) ) ; return run Stats ; }
private boolean is Media Type Match (  Media Type media Type ,  Media Type range Pattern ) {  String  WILDCARD = _ STR ;  String range Pattern Type = range Pattern . get Type ( ) ;  String range Pattern Subtype = range Pattern . get Subtype ( ) ; return ( range Pattern Type . equals (  WILDCARD ) || range Pattern Type . equals ( media Type . get Type ( ) ) ) && ( range Pattern Subtype . equals (  WILDCARD ) || range Pattern Subtype . equals ( media Type . get Subtype ( ) ) ) ; }
public void paint Text (  Synth Context ss ,  Graphics g ,  String text , int x , int y , int mnemonic Index ) { if ( text != null ) {  Graphics2 D g2d = (  Graphics2 D ) g . create ( ) ; g2d . set Rendering Hint (  Rendering Hints .  KEY_ TEXT_ ANTIALIASING ,  Rendering Hints .  VALUE_ TEXT_ ANTIALIAS_ ON ) ;  JComponent c = ss . get Component ( ) ;  Font Metrics fm =  Swing Utilities2 . get Font Metrics ( c , g2d ) ; y += fm . get Ascent ( ) ;  Swing Utilities2 . draw String ( c , g2d , text , x , y ) ; if ( mnemonic Index >= _ NUM && mnemonic Index < text . length ( ) ) { int underline X = x +  Swing Utilities2 . string Width ( c , fm , text . substring ( _ NUM , mnemonic Index ) ) ; int underline Y = y ; int underline Width = fm . char Width ( text . char At ( mnemonic Index ) ) ; int underline Height = _ NUM ; g2d . fill Rect ( underline X , underline Y + fm . get Descent ( ) - _ NUM , underline Width , underline Height ) ; } } }
public void add All ( int [ ] data ) { int data Len = data . length ; if ( data Len == _ NUM ) { return ; } int newcap = size + ( int ) ( data Len * _ NUM ) + _ NUM ; ensure Capacity ( newcap ) ;  System . arraycopy ( data , _ NUM , array , size , data Len ) ; size += data Len ; }
static byte [ ] read ( final  IMemory Manager mmgr , final long addr ) { final int nbytes = get Allocation Size ( addr ) ; final byte [ ] a = new byte [ nbytes ] ; final  Byte Buffer mybb =  Byte Buffer . wrap ( a ) ; final  Byte Buffer [ ] bufs = mmgr . get ( addr ) ; for (  Byte Buffer b : bufs ) { mybb . put ( b ) ; } return a ; }
@  Override public boolean accept (  File file ) {  String name = file . get Name ( ) ; for (  String name2 : this . names ) { if ( case Sensitivity . check Equals ( name , name2 ) ) { return _ BOOL ; } } return _ BOOL ; }
@  Override public boolean equals (  Object obj ) { if ( obj == this ) { return _ BOOL ; } if ( ! ( obj instanceof  Text Title ) ) { return _ BOOL ; }  Text Title that = (  Text Title ) obj ; if ( !  Object Utilities . equal ( this . text , that . text ) ) { return _ BOOL ; } if ( !  Object Utilities . equal ( this . font , that . font ) ) { return _ BOOL ; } if ( !  Paint Utilities . equal ( this . paint , that . paint ) ) { return _ BOOL ; } if ( this . text Alignment != that . text Alignment ) { return _ BOOL ; } if ( !  Paint Utilities . equal ( this . background Paint , that . background Paint ) ) { return _ BOOL ; } if ( this . maximum Lines To Display != that . maximum Lines To Display ) { return _ BOOL ; } if ( this . expand To Fit Space != that . expand To Fit Space ) { return _ BOOL ; } if ( !  Object Utilities . equal ( this . tool Tip Text , that . tool Tip Text ) ) { return _ BOOL ; } if ( !  Object Utilities . equal ( this . url Text , that . url Text ) ) { return _ BOOL ; } return super . equals ( obj ) ; }
public static  Node remove Children (  Node node ) { if ( node . get Node Type ( ) ==  Node .  ELEMENT_ NODE ) {  Node List children = node . get Child Nodes ( ) ; for ( int i = _ NUM ; i < children . get Length ( ) ; i ++ ) {  Node child = children . item ( i ) ;  Node temp = node . remove Child ( child ) ; i -- ; } } return node ; }
public synchronized  Combo Box <  V > remote Item ( int index ) { items . remove ( index ) ; if ( index < selected Index ) { set Selected Index ( selected Index - _ NUM ) ; } else if ( index == selected Index ) { set Selected Index ( - _ NUM ) ; } invalidate ( ) ; return this ; }
public static final int [ ] trim ( int [ ] a , int size ) { if ( a . length == size ) { return a ; } else { int [ ] b = new int [ size ] ;  System . arraycopy ( a , _ NUM , b , _ NUM , size ) ; return b ; } }
public void check Permission (  Object object ,  Namespace Permission Enum [ ] permissions ) {  List <  Access Denied Exception > access Denied Exceptions = new  Array List < > ( ) ; check Permission ( object , permissions , access Denied Exceptions ) ; if ( ! access Denied Exceptions . is Empty ( ) ) { throw get Access Denied Exception ( access Denied Exceptions ) ; } }
private static  Intent create Call Activity Intent (  Context context ,  URLSpan [ ] url Spans ) {  Telephony Manager tm = (  Telephony Manager ) context . get System Service (  Context .  TELEPHONY_ SERVICE ) ; if ( tm . get Phone Type ( ) ==  Telephony Manager .  PHONE_ TYPE_ NONE ) { return null ; } for ( int span_i = _ NUM ; span_i < url Spans . length ; span_i ++ ) {  URLSpan url Span = url Spans [ span_i ] ;  String url String = url Span . get URL ( ) ; if ( url String . starts With (  TEL_ PREFIX ) ) {  Intent call Intent = new  Intent (  Intent .  ACTION_ DIAL ,  Uri . parse ( url String ) ) ; call Intent . add Flags (  Intent .  FLAG_ ACTIVITY_ NEW_ TASK ) ; return call Intent ; } } return null ; }
private  String params To String ( ) {  String Builder result = new  String Builder ( ) ; if ( ! parameters . is Empty ( ) ) { for (  Map .  Entry <  String ,  String > entry : parameters . entry Set ( ) ) { if ( result . length ( ) == _ NUM ) { result . append ( _ STR ) ; } else { result . append ( _ STR ) ; } result . append ( entry . get Key ( ) ) ; result . append ( _ STR ) ; result . append ( entry . get Value ( ) ) ; } } return result . to String ( ) ; }
private  String pre Process Signature (  String signature ) { int index ; if ( ( index = signature . index Of ( _ STR ) ) > _ NUM ) { signature = signature . substring ( _ NUM , index ) ; } while ( ( index = signature . index Of ( _ STR ) ) > _ NUM ) { signature = signature . substring ( _ NUM , index ) + signature . substring ( index + _ NUM , signature . length ( ) ) ; } return signature ; }
private void draw ( final  Execution Unit process , final  Graphics2 D g2 , final  Process Renderer Model renderer Model , final boolean printing ) {  Process Background Image image = renderer Model . get Background Image ( process ) ; if ( image != null ) {  Graphics2 D g2 D = (  Graphics2 D ) g2 . create ( ) ; int x = image . get X ( ) ; int y = image . get Y ( ) ; int w = image . get Width ( ) ; int h = image . get Height ( ) ; if ( x == - _ NUM ) { double process Width = renderer Model . get Process Width ( process ) ; x = ( int ) ( ( process Width - w ) / _ NUM ) ; } if ( y == - _ NUM ) { double process Height = renderer Model . get Process Height ( process ) ; y = ( int ) ( ( process Height - h ) / _ NUM ) ; } if ( renderer Model . get Zoom Factor ( ) > _ NUM ) { float alpha =  Math . max (  MIN_ OPACITY , _ NUM - ( float ) renderer Model . get Zoom Factor ( ) ) ;  Alpha Composite ac =  Alpha Composite . get Instance (  Alpha Composite .  SRC_ OVER , alpha ) ; g2 D . set Composite ( ac ) ; } g2 D . set Rendering Hint (  Rendering Hints .  KEY_ INTERPOLATION ,  Rendering Hints .  VALUE_ INTERPOLATION_ BILINEAR ) ; g2 D . draw Image ( image . get Image ( load Listener ) , x , y , w , h , null ) ; g2 D . dispose ( ) ; } }
public static  List <  Integer > to Int List ( @  Nullable int [ ] arr ,  Ignite Predicate <  Integer > ... p ) { if ( arr == null || arr . length == _ NUM ) return  Collections . empty List ( ) ;  List <  Integer > ret = new  Array List < > ( arr . length ) ; if (  F . is Empty ( p ) ) for ( int i : arr ) ret . add ( i ) ; else { for ( int i : arr ) if (  F . is All ( i , p ) ) ret . add ( i ) ; } return ret ; }
public static void show Center Window (  Window parent ,  Window window ) { position Center Window ( parent , window ) ; show Window ( window ) ; }
private static  Array List <  Constraint Widget Container > gather Containers (  Constraint Widget Container container ) {  Array List <  Constraint Widget Container > containers = new  Array List < > ( ) ; for (  Constraint Widget widget : container . get Children ( ) ) { if ( widget instanceof  Constraint Widget Container ) { containers . add ( (  Constraint Widget Container ) widget ) ; } } return containers ; }
public final void print Quoted Symbol (  Char Sequence text ) throws  IOException { if ( text == null ) { append Ascii ( _ STR ) ; } else if ( text . length ( ) == _ NUM ) { throw new  Empty Symbol Exception ( ) ; } else { append Ascii ( _ STR ) ; print Code Points ( text ,  SYMBOL_ ESCAPE_ CODES ) ; append Ascii ( _ STR ) ; } }
@  Override public  String to String ( ) {  Map <  Value ,  Double > sorted Table =  Inference Utils . get NBest ( table ,  Math . max ( table . size ( ) , _ NUM ) ) ;  String str = _ STR ; for (  Entry <  Value ,  Double > entry : sorted Table . entry Set ( ) ) {  String prob =  String Utils . get Short Form ( entry . get Value ( ) ) ; str += _ STR + variable + _ STR + entry . get Key ( ) + _ STR + prob + _ STR ; } return ( str . length ( ) > _ NUM ) ? str . substring ( _ NUM , str . length ( ) - _ NUM ) : str ; }
protected  Conversation Parser ( final  Sentence Implementation sentence ) {  String text = sentence . get Original Text ( ) ; if ( text == null ) { text = _ STR ; } else if ( text . starts With ( _ STR ) ) { text = _ STR ; } final  String text Without Punctation = detect Sentence Type ( text , sentence ) ; tokenizer = new  String Tokenizer ( text Without Punctation ) ; }
private  Method find Any Method Match (  Class < ? > clz ,  String name ,  Class < ? > [ ] classes ) { try {  Method m = clz . get Declared Method ( name , classes ) ; if ( m != null ) { return m ; } } catch (  No Such Method Exception ignored ) { }  Class < ? > sup = clz . get Superclass ( ) ; if ( sup != null ) {  Method m = find Any Method Match ( sup , name , classes ) ; if ( m != null ) { return m ; } }  Class < ? > [ ] itfs = clz . get Interfaces ( ) ; if ( itfs != null && itfs . length > _ NUM ) { for (  Class < ? > itf : itfs ) {  Method m = find Any Method Match ( itf , name , classes ) ; if ( m != null ) { return m ; } } } return null ; }
@  Override public void reset References ( ) { _refs . clear ( ) ; }
@  Override public void schema Changed (  String service Name ,  String version ) { }
protected  Date Time Data parse (  String str ) throws  Schema Date Time Exception {  Date Time Data date = new  Date Time Data ( str , this ) ; int len = str . length ( ) ; date . year =  YEAR ; if ( str . char At ( _ NUM ) != _ STR || str . char At ( _ NUM ) != _ STR ) { throw new  Schema Date Time Exception ( _ STR + str ) ; } date . month = parse Int ( str , _ NUM , _ NUM ) ; int start = _ NUM ; if ( str . char At ( start ++ ) != _ STR ) { throw new  Schema Date Time Exception ( _ STR + str ) ; } date . day = parse Int ( str , start , start + _ NUM ) ; if (  MONTHDAY_ SIZE < len ) { if ( ! is Next Char UTCSign ( str ,  MONTHDAY_ SIZE , len ) ) { throw new  Schema Date Time Exception ( _ STR + str ) ; } else { get Time Zone ( str , date ,  MONTHDAY_ SIZE , len ) ; } } validate Date Time ( date ) ; save Unnormalized ( date ) ; if ( date . utc != _ NUM && date . utc != _ STR ) { normalize ( date ) ; } date . position = _ NUM ; return date ; }
private boolean send Message ( ) { if ( msg Queue . is Empty ( ) == _ BOOL ) { return _ BOOL ; } if ( free To Send == _ BOOL ) {  Serial Message msg = msg Queue . peek ( ) ; if ( msg != null ) { free To Send = _ BOOL ; logger . debug ( _ STR , node . get Node Id ( ) , msg Queue . size ( ) ) ; if ( msg . get Message Class ( ) ==  Serial Message Class .  Send Data ) { controller . send Data ( msg ) ; } else { controller . enqueue ( msg ) ; } } } return _ BOOL ; }
private boolean perform Search (  String query ) { if ( check Integer ( query ) ) { return get Comic By Number (  Integer . parse Int ( query ) ) ; } else { return search Comic Title Or Transcript ( query ) ; } }
@  Override public final void write Int ( int v ) throws  IOException { work [ _ NUM ] = ( byte ) v ; work [ _ NUM ] = ( byte ) ( v > > _ NUM ) ; work [ _ NUM ] = ( byte ) ( v > > _ NUM ) ; work [ _ NUM ] = ( byte ) ( v > > _ NUM ) ; dis . write ( work , _ NUM , _ NUM ) ; }
final public void println ( int v ) {  Writer out = this . out ; if ( out == null ) return ; print ( v ) ; try { out . write ( _newline , _ NUM , _newline . length ) ; } catch (  IOException e ) { log . log (  Level .  FINE , e . to String ( ) , e ) ; } }
public void add Resource Result (  Resource Result resource Result ,  Service Type service Type ) throws  Policy Exception { add Resource Result ( resource Result , service Type . get Resource Name Comparator ( ) ) ; }
public  Writable Raster create Compatible Writable Raster ( int w , int h ) { if ( w <= _ NUM || h <= _ NUM ) { throw new  Raster Format Exception ( _ STR + ( ( w <= _ NUM ) ? _ STR : _ STR ) ) ; }  Sample Model sm = sample Model . create Compatible Sample Model ( w , h ) ; return new  Short Interleaved Raster ( sm , new  Point ( _ NUM , _ NUM ) ) ; }
private void export Source Documents (  Project a Project ,  File a Copy Dir ) throws  IOException ,  Project Export Exception {  File source Document Dir = new  File ( a Copy Dir +  SOURCE_ FOLDER ) ;  File Utils . force Mkdir ( source Document Dir ) ;  List < de . tudarmstadt . ukp . clarin . webanno . model .  Source Document > documents = repository . list Source Documents ( a Project ) ; documents . add All ( automation Service . list Tab Sep Documents ( a Project ) ) ; int i = _ NUM ; for ( de . tudarmstadt . ukp . clarin . webanno . model .  Source Document source Document : documents ) { try {  File Utils . copy File To Directory ( repository . get Source Document File ( source Document ) , source Document Dir ) ; progress = ( int )  Math . ceil ( ( ( double ) i ) / documents . size ( ) * _ NUM ) ; i ++ ; } catch (  File Not Found Exception e ) {  String Buffer error Message = new  String Buffer ( ) ; error Message . append ( _ STR ) ; error Message . append ( source Document . get Name ( ) ) ; error Message . append ( _ STR ) ;  LOG . error ( error Message . to String ( ) ) ;  LOG . error (  Exception Utils . get Root Cause ( e ) ) ; messages . add ( error Message . to String ( ) ) ; throw new  Project Export Exception ( _ STR ) ; } } }
private void process Tracker State Change (  Tracker tracker ,  OBlock block , int state ) {  List <  OBlock > old Range = tracker . get Range ( ) ; switch ( tracker . move ( block , state ) ) { case  Tracker .  NO_ BLOCK : adjust Block Listeners ( old Range , tracker . get Range ( ) , tracker ) ;  String msg =  Bundle . get Message ( _ STR , tracker . get Train Name ( ) , block . get Display Name ( ) ) + _ STR +  Bundle . get Message ( _ STR ) ;  JOption Pane . show Message Dialog ( this , msg ,  Bundle . get Message ( _ STR ) ,  JOption Pane .  WARNING_ MESSAGE ) ; stop Train ( tracker ) ; set Status ( msg ) ; break ; case  Tracker .  ENTER_ BLOCK : block . _entry Time =  System . current Time Millis ( ) ; adjust Block Listeners ( old Range , tracker . get Range ( ) , tracker ) ; set Status (  Bundle . get Message ( _ STR , tracker . get Train Name ( ) , block . get Display Name ( ) ) ) ; break ; case  Tracker .  LEAVE_ BLOCK : adjust Block Listeners ( old Range , tracker . get Range ( ) , tracker ) ; long et = (  System . current Time Millis ( ) - block . _entry Time ) / _ NUM ; set Status (  Bundle . get Message ( _ STR , tracker . get Train Name ( ) , block . get Display Name ( ) , et / _ NUM , et % _ NUM ) ) ; break ; case  Tracker .  ERROR_ BLOCK : break ; } }
private  Layout parse Layout (  Token Stream tokens ) {  Doc .  Group Kind kind =  Doc .  Group Kind .  VERTICAL ;  Doc separator =  Doc .  BREAK ; int nest = _ NUM ; if ( tokens . has ( _ STR ) ) { tokens . next ( ) ; kind =  Doc .  Group Kind .  VERTICAL ; } else if ( tokens . has ( _ STR ) ) { tokens . next ( ) ; kind =  Doc .  Group Kind .  HORIZONTAL ; } else if ( tokens . has ( _ STR ) ) { tokens . next ( ) ; kind =  Doc .  Group Kind .  AUTO ; } else if ( tokens . has ( _ STR ) ) { tokens . next ( ) ; kind =  Doc .  Group Kind .  FILL ; } if ( tokens . has (  INT_ LITERAL ) ) { nest =  Integer . parse Int ( tokens . next ( ) ) ; } if ( tokens . has (  JOIN_ SEPARATOR ) ) { tokens . next ( ) ;  Elem expr = parse Expr ( tokens ) ; if ( expr != null ) { separator = eval Parsing Time ( expr ) ; } } return  Layout . create ( separator , kind , nest ) ; }
public boolean load Properties (  Properties props ,  URL url ) { try {  Input Stream props In = url . open Stream ( ) ; props . load ( props In ) ; return _ BOOL ; } catch ( java . io .  IOException e ) {  Debug . error ( _ STR + url ) ; return _ BOOL ; } }
public  Builder put (  Properties properties ) { for (  Map .  Entry entry : properties . entry Set ( ) ) { map . put ( (  String ) entry . get Key ( ) , (  String ) entry . get Value ( ) ) ; } return this ; }
protected void process Selectors (  List <  Node > results ,  List <  Css Selector > selectors ) {  List <  Node > selected Nodes = select ( root Node , selectors ) ; for (  Node selected Node : selected Nodes ) { if ( ! results . contains ( selected Node ) ) { results . add ( selected Node ) ; } } }
public static int int From Properties (  Properties p ,  String prop Name , int default Value ) { int ret = default Value ;  String int String = p . get Property ( prop Name ) ; if ( int String != null ) { try { ret =  Integer . parse Int ( int String . trim ( ) ) ; } catch (  Number Format Exception e ) { ret = default Value ; } } return ret ; }
private static  Shape generate Star ( double x , double y , double inner Radius , double outer Radius , int points Count ) {  General Path path = new  General Path ( ) ; double outer Angle Increment = _ NUM *  Math .  PI / points Count ; double outer Angle = _ NUM ; double inner Angle = outer Angle Increment / _ NUM ; x += outer Radius ; y += outer Radius ; float x1 = ( float ) (  Math . cos ( outer Angle ) * outer Radius + x ) ; float y1 = ( float ) (  Math . sin ( outer Angle ) * outer Radius + y ) ; float x2 = ( float ) (  Math . cos ( inner Angle ) * inner Radius + x ) ; float y2 = ( float ) (  Math . sin ( inner Angle ) * inner Radius + y ) ; path . move To ( x1 , y1 ) ; path . line To ( x2 , y2 ) ; outer Angle += outer Angle Increment ; inner Angle += outer Angle Increment ; for ( int i = _ NUM ; i < points Count ; i ++ ) { x1 = ( float ) (  Math . cos ( outer Angle ) * outer Radius + x ) ; y1 = ( float ) (  Math . sin ( outer Angle ) * outer Radius + y ) ; path . line To ( x1 , y1 ) ; x2 = ( float ) (  Math . cos ( inner Angle ) * inner Radius + x ) ; y2 = ( float ) (  Math . sin ( inner Angle ) * inner Radius + y ) ; path . line To ( x2 , y2 ) ; outer Angle += outer Angle Increment ; inner Angle += outer Angle Increment ; } path . close Path ( ) ; return path ; }
private static  Locale strip (  Locale locale ) {  String language = locale . get Language ( ) ;  String country = locale . get Country ( ) ;  String variant = locale . get Variant ( ) ; if ( ! variant . is Empty ( ) ) { variant = _ STR ; } else if ( ! country . is Empty ( ) ) { country = _ STR ; } else if ( ! language . is Empty ( ) ) { language = _ STR ; } else { return null ; } return new  Locale ( language , country , variant ) ; }
static  List <  Map <  String ,  Object > > query (  Result Set rs ) throws  SQLException {  List <  Map <  String ,  Object > > list = new  Array List <  Map <  String ,  Object > > ( ) ;  Result Set Meta Data meta = rs . get Meta Data ( ) ; int column Count = meta . get Column Count ( ) ; while ( rs . next ( ) ) {  Hash Map <  String ,  Object > map = new  Hash Map <  String ,  Object > ( ) ; for ( int i = _ NUM ; i < column Count ; i ++ ) { map . put ( meta . get Column Label ( i + _ NUM ) , rs . get Object ( i + _ NUM ) ) ; } list . add ( map ) ; } return list ; }
@  Override public boolean equals (  Object obj ) { if ( obj == this ) { return _ BOOL ; } if ( ! ( obj instanceof  Task Series Collection ) ) { return _ BOOL ; }  Task Series Collection that = (  Task Series Collection ) obj ; if ( !  Object Utilities . equal ( this . data , that . data ) ) { return _ BOOL ; } return _ BOOL ; }
private static void write Setting ( final  CConnection connection , final int container Id , final  String key , final  String value , final  String table ) throws  Couldnt Save Data Exception {  String id_column = _ STR ; if ( table . equals Ignore Case (  CTable Names .  MODULE_ SETTINGS_ TABLE ) ) { id_column = _ STR ; } else { id_column = _ STR ; } final  String delete Query = _ STR + table + _ STR + id_column + _ STR + container Id + _ STR + key + _ STR ; final  String insert Query = _ STR + table + _ STR + container Id + _ STR + key + _ STR + value + _ STR ; try {  Postgre SQLHelpers . begin Transaction ( connection ) ; connection . execute Update ( delete Query , _ BOOL ) ; connection . execute Update ( insert Query , _ BOOL ) ;  Postgre SQLHelpers . end Transaction ( connection ) ; } catch ( final  SQLException exception ) { throw new  Couldnt Save Data Exception ( _ STR + table ) ; } }
public  CProcess List Panel ( final  Process List process List ) { super ( new  Border Layout ( ) ) ; m_process List = process List ; final  CProcess List Model model = new  CProcess List Model ( process List ) ; m_sorter = new  Table Row Sorter <  CProcess List Model > ( model ) ; m_table = new  JTable ( model ) ; m_table . set Selection Mode (  List Selection Model .  SINGLE_ SELECTION ) ; m_table . set Row Sorter ( m_sorter ) ; final  JScroll Pane scroll Pane = new  JScroll Pane ( m_table ) ; scroll Pane . set Border ( new  Titled Border ( _ STR ) ) ; add ( scroll Pane ) ; set Preferred Size ( new  Dimension ( _ NUM , _ NUM ) ) ; }
public static void initialize Properties (  String property Name ,  String property Value ) {  Properties new Props = new  Properties ( ) ; new Props . put ( property Name , property Value ) ; initialize Properties ( new Props , _ BOOL , _ BOOL ) ; }
protected static  String normalize Url Ending (  String link ) { if ( link . index Of ( _ STR ) > - _ NUM ) link = link . substring ( _ NUM , link . index Of ( _ STR ) ) ; if ( link . ends With ( _ STR ) ) link = link . substring ( _ NUM , link . length ( ) - _ NUM ) ; if ( link . ends With ( _ STR ) ) link = link . substring ( _ NUM , link . length ( ) - _ NUM ) ; return link ; }
private void add Manifest Package (  String name ,  Attributes attr ) { if ( ! name . ends With ( _ STR ) && ! name . equals ( _ STR ) ) return ;  String spec Title = attr . get Value ( _ STR ) ;  String spec Version = attr . get Value ( _ STR ) ;  String spec Vendor = attr . get Value ( _ STR ) ;  String impl Title = attr . get Value ( _ STR ) ;  String impl Version = attr . get Value ( _ STR ) ;  String impl Vendor = attr . get Value ( _ STR ) ; if ( spec Title == null && spec Version == null && spec Vendor != null && impl Title == null && impl Version == null && impl Vendor != null ) return ;  Class Package pkg = new  Class Package ( name ) ; pkg . set Specification Title ( spec Title ) ; pkg . set Specification Version ( spec Version ) ; pkg . set Specification Vendor ( spec Vendor ) ; pkg . set Implementation Title ( impl Title ) ; pkg . set Implementation Version ( impl Version ) ; pkg . set Implementation Vendor ( impl Vendor ) ; _packages . add ( pkg ) ; }
public  Reference Binding find Super Type Originating From ( int well Known Original ID , boolean original Is Class ) { if ( ! ( this instanceof  Reference Binding ) ) return null ;  Reference Binding reference = (  Reference Binding ) this ; if ( reference . id == well Known Original ID || ( original ( ) . id == well Known Original ID ) ) return reference ;  Reference Binding current Type = reference ; if ( original Is Class ) { while ( ( current Type = current Type . superclass ( ) ) != null ) { if ( current Type . id == well Known Original ID ) return current Type ; if ( current Type . original ( ) . id == well Known Original ID ) return current Type ; } return null ; }  Reference Binding [ ] interfaces To Visit = null ; int next Position = _ NUM ; do {  Reference Binding [ ] its Interfaces = current Type . super Interfaces ( ) ; if ( its Interfaces != null && its Interfaces !=  Binding .  NO_ SUPERINTERFACES ) { if ( interfaces To Visit == null ) { interfaces To Visit = its Interfaces ; next Position = interfaces To Visit . length ; } else { int its Length = its Interfaces . length ; if ( next Position + its Length >= interfaces To Visit . length )  System . arraycopy ( interfaces To Visit , _ NUM , interfaces To Visit = new  Reference Binding [ next Position + its Length + _ NUM ] , _ NUM , next Position ) ; next Interface : for ( int a = _ NUM ; a < its Length ; a ++ ) {  Reference Binding next = its Interfaces [ a ] ; for ( int b = _ NUM ; b < next Position ; b ++ ) if ( next == interfaces To Visit [ b ] ) continue next Interface ; interfaces To Visit [ next Position ++ ] = next ; } } } } while ( ( current Type = current Type . superclass ( ) ) != null ) ; for ( int i = _ NUM ; i < next Position ; i ++ ) { current Type = interfaces To Visit [ i ] ; if ( current Type . id == well Known Original ID ) return current Type ; if ( current Type . original ( ) . id == well Known Original ID ) return current Type ;  Reference Binding [ ] its Interfaces = current Type . super Interfaces ( ) ; if ( its Interfaces != null && its Interfaces !=  Binding .  NO_ SUPERINTERFACES ) { int its Length = its Interfaces . length ; if ( next Position + its Length >= interfaces To Visit . length )  System . arraycopy ( interfaces To Visit , _ NUM , interfaces To Visit = new  Reference Binding [ next Position + its Length + _ NUM ] , _ NUM , next Position ) ; next Interface : for ( int a = _ NUM ; a < its Length ; a ++ ) {  Reference Binding next = its Interfaces [ a ] ; for ( int b = _ NUM ; b < next Position ; b ++ ) if ( next == interfaces To Visit [ b ] ) continue next Interface ; interfaces To Visit [ next Position ++ ] = next ; } } } return null ; }
public void add Column (  Column previous Column ,  Column column ) { if ( column != null ) { if ( previous Column == null ) { columns . add ( _ NUM , column ) ; } else { columns . add ( columns . index Of ( previous Column ) , column ) ; } } }
public void update Contents ( ) { clear ( ) ;  String display Category = get Display Category ( ) ;  Display [ ] displays = m Display Manager . get Displays ( display Category ) ; add All ( displays ) ;  Log . d (  TAG , _ STR + displays . length + _ STR ) ; for (  Display display : displays ) {  Log . d (  TAG , _ STR + display ) ; } }
static public float angle Between (  PVector v1 ,  PVector v2 ) { if ( v1 . x == _ NUM && v1 . y == _ NUM ) return _ NUM ; if ( v2 . x == _ NUM && v2 . y == _ NUM ) return _ NUM ; double dot = v1 . x * v2 . x + v1 . y * v2 . y + v1 . z * v2 . z ; double v1mag =  Math . sqrt ( v1 . x * v1 . x + v1 . y * v1 . y + v1 . z * v1 . z ) ; double v2mag =  Math . sqrt ( v2 . x * v2 . x + v2 . y * v2 . y + v2 . z * v2 . z ) ; double amt = dot / ( v1mag * v2mag ) ; if ( amt <= - _ NUM ) { return  PConstants .  PI ; } else if ( amt >= _ NUM ) { return _ NUM ; } return ( float )  Math . acos ( amt ) ; }
public void remove Listener ( final  IRunning Query Listener l ) { if ( l == null ) throw new  Illegal Argument Exception ( ) ; listeners . remove ( l ) ; }
@  Override public void send Mail (  Mime Message message ) throws  Messaging Exception {  Mail Address sender = new  Mail Address ( (  Internet Address ) message . get From ( ) [ _ NUM ] ) ;  Collection <  Mail Address > recipients = new  Hash Set <  Mail Address > ( ) ;  Address addresses [ ] = message . get All Recipients ( ) ; if ( addresses != null ) { for (  Address address : addresses ) { if ( address instanceof  Internet Address ) { recipients . add ( new  Mail Address ( (  Internet Address ) address ) ) ; } } } send Mail ( sender , recipients , message ) ; }
@  Nullable public  Grid Cache Mvcc Candidate add Entry (  Grid Dht Cache Entry entry ) throws  Grid Cache Entry Removed Exception ,  Grid Distributed Lock Cancelled Exception { if ( log . is Debug Enabled ( ) ) log . debug ( _ STR + entry ) ; if ( entry == null ) return null ; if ( timed Out ) return null ;  Grid Cache Mvcc Candidate c = entry . add Dht Local ( near Node Id , near Lock Ver , top Ver , thread Id , lock Ver , null , null , timeout , _ BOOL , in Tx ( ) , implicit Single ( ) ) ; if ( c == null && timeout < _ NUM ) { if ( log . is Debug Enabled ( ) ) log . debug ( _ STR + entry ) ; on Failed ( _ BOOL ) ; return null ; } synchronized ( sync ) { entries . add ( c == null || c . reentry ( ) ? null : entry ) ; if ( c != null && ! c . reentry ( ) ) pending Locks . add ( entry . key ( ) ) ; } if ( timed Out ) { entry . remove Lock ( lock Ver ) ; return null ; } return c ; }
@  Override public boolean has Feature (  String feature ,  String version ) { boolean result = super . has Feature ( feature , version ) ; if ( ! result ) { boolean any Version = version == null || version . length ( ) == _ NUM ; if ( feature . starts With ( _ STR ) ) { feature = feature . substring ( _ NUM ) ; } return ( ( feature . equals Ignore Case ( _ STR ) && ( any Version || version . equals ( _ STR ) ) ) || ( feature . equals Ignore Case ( _ STR ) && ( any Version || version . equals ( _ STR ) ) ) || ( feature . equals Ignore Case ( _ STR ) && ( any Version || version . equals ( _ STR ) ) ) || ( feature . equals Ignore Case ( _ STR ) && ( any Version || version . equals ( _ STR ) ) ) || ( feature . equals Ignore Case ( _ STR ) && ( any Version || version . equals ( _ STR ) ) ) ) ; } return result ; }
protected void assert Same Join Order ( final int [ ] expected , final  Test Helper helper ) throws  Exception { assert Same Join Order (  Collections . singleton List ( expected ) , helper ) ; }
private boolean delete File (  String filepath ) { try { if ( filepath != null ) {  File file = new  File ( filepath ) ; if ( file . exists ( ) ) { if ( file . delete ( ) ) { logger . debug ( _ STR + file . get Path ( ) ) ; return _ BOOL ; } else { logger . warn ( _ STR + file . get Path ( ) ) ; } } else { logger . warn ( _ STR + file . get Path ( ) ) ; return _ BOOL ; } } } catch (  Exception e ) { logger . error ( e ) ; } return _ BOOL ; }
public void delete Group Member (  Gitlab Group group ,  Gitlab User user ) throws  IOException { delete Group Member ( group . get Id ( ) , user . get Id ( ) ) ; }
public  Ecu Code List (  String resource Bundle Name ) { codes =  Resource Bundle . get Bundle ( resource Bundle Name ) ; }
@  Override public void increment ( double coord , double val ) { int bin = get Bin Nr ( coord ) ; if ( bin < _ NUM ) { if ( size - bin > data . length ) { double [ ] tmpdata = new double [ grow Size ( data . length , size - bin ) ] ;  System . arraycopy ( data , _ NUM , tmpdata , - bin , size ) ; data = tmpdata ; } else {  System . arraycopy ( data , _ NUM , data , - bin , size ) ;  Arrays . fill ( data , _ NUM , - bin , ( double ) _ NUM ) ; } data [ _ NUM ] = val ; assert ( data . length >= size - bin ) ; offset -= bin ; size -= bin ; } else if ( bin >= data . length ) { double [ ] tmpdata = new double [ grow Size ( data . length , bin + _ NUM ) ] ;  System . arraycopy ( data , _ NUM , tmpdata , _ NUM , size ) ; tmpdata [ bin ] = val ; data = tmpdata ; size = bin + _ NUM ; max =  Double .  MAX_ VALUE ; } else { if ( bin >= size ) { size = bin + _ NUM ; } data [ bin ] += val ; } }
public static  Writable Native Map make Native Map (  Map <  String ,  Object > objects ) {  Writable Native Map native Map = new  Writable Native Map ( ) ; if ( objects == null ) { return native Map ; } for (  Map .  Entry <  String ,  Object > entry : objects . entry Set ( ) ) { add Entry ( native Map , entry . get Key ( ) , entry . get Value ( ) ) ; } return native Map ; }
public static double mad ( final double [ ] data ) { double mad = _ NUM ; if ( data . length > _ NUM ) { double median = median ( data ) ; double [ ] deviation Sum = new double [ data . length ] ; for ( int i = _ NUM ; i < data . length ; i ++ ) { deviation Sum [ i ] =  Math . abs ( median - data [ i ] ) ; } mad = median ( deviation Sum ) ; } return mad ; }
private static <  T >  Load Result <  T > validate Loaded Plugins ( final  Load Result <  T > result ) { final  Hash Set <  Long > guids = new  Hash Set < > ( ) ; final  Array List <  Pair < com . google . security . zynamics . binnavi . api2 . plugins .  IPlugin <  T > ,  Plugin Status > > validated Plugins = new  Array List < > ( ) ; for ( final  Pair < com . google . security . zynamics . binnavi . api2 . plugins .  IPlugin <  T > ,  Plugin Status > plugin Pair : result . get Loaded Plugins ( ) ) { final com . google . security . zynamics . binnavi . api2 . plugins .  IPlugin <  T > plugin = plugin Pair . first ( ) ; final  String name = plugin . get Name ( ) ; final long guid = plugin . get Guid ( ) ; if ( ( name == null ) && ( guid == _ NUM ) ) { validated Plugins . add ( new  Pair < com . google . security . zynamics . binnavi . api2 . plugins .  IPlugin <  T > ,  Plugin Status > ( plugin ,  Plugin Status .  Invalid Name Guid ) ) ; } else if ( name == null ) { validated Plugins . add ( new  Pair < com . google . security . zynamics . binnavi . api2 . plugins .  IPlugin <  T > ,  Plugin Status > ( plugin ,  Plugin Status .  Invalid Name ) ) ; } else if ( guid == _ NUM ) { validated Plugins . add ( new  Pair < com . google . security . zynamics . binnavi . api2 . plugins .  IPlugin <  T > ,  Plugin Status > ( plugin ,  Plugin Status .  Invalid Guid ) ) ; } else if ( guids . contains ( guid ) ) { validated Plugins . add ( new  Pair < com . google . security . zynamics . binnavi . api2 . plugins .  IPlugin <  T > ,  Plugin Status > ( plugin ,  Plugin Status .  Duplicate Guid ) ) ; } else { validated Plugins . add ( new  Pair < com . google . security . zynamics . binnavi . api2 . plugins .  IPlugin <  T > ,  Plugin Status > ( plugin ,  Plugin Status .  Valid ) ) ; } guids . add ( guid ) ; } return new  Load Result <  T > ( validated Plugins , result . get Failed Plugins ( ) ) ; }
public synchronized void stop ( ) { m Run = _ BOOL ; if ( m Process != null ) { m Process . destroy ( ) ; m Process = null ; } try { m Thread . join ( ) ; } catch (  Interrupted Exception e ) { } m Thread = null ; m Callback = null ; }
public static  Graph Request new Upload Video Request (  Access Token access Token ,  File file ,  Callback callback ) throws  File Not Found Exception {  Parcel File Descriptor descriptor =  Parcel File Descriptor . open ( file ,  Parcel File Descriptor .  MODE_ READ_ ONLY ) ;  Bundle parameters = new  Bundle ( _ NUM ) ; parameters . put Parcelable ( file . get Name ( ) , descriptor ) ; return new  Graph Request ( access Token ,  MY_ VIDEOS , parameters ,  Http Method .  POST , callback ) ; }
Socket create Socket ( ) throws  IOException {  Socket sock ; if ( is Ssl Enabled ( ) ) sock = ssl Sock Factory . create Socket ( ) ; else sock = new  Socket ( ) ; sock . bind ( new  Inet Socket Address ( loc Host , _ NUM ) ) ; sock . set Tcp No Delay ( _ BOOL ) ; return sock ; }
public static boolean is Node After (  Node node1 ,  Node node2 ) { if ( node1 == node2 || is Node The Same ( node1 , node2 ) ) return _ BOOL ; boolean is Node After = _ BOOL ;  Node parent1 = get Parent Of Node ( node1 ) ;  Node parent2 = get Parent Of Node ( node2 ) ; if ( parent1 == parent2 || is Node The Same ( parent1 , parent2 ) ) { if ( null != parent1 ) is Node After = is Node After Sibling ( parent1 , node1 , node2 ) ; else { } } else { int n Parents1 = _ NUM , n Parents2 = _ NUM ; while ( parent1 != null ) { n Parents1 ++ ; parent1 = get Parent Of Node ( parent1 ) ; } while ( parent2 != null ) { n Parents2 ++ ; parent2 = get Parent Of Node ( parent2 ) ; }  Node start Node1 = node1 , start Node2 = node2 ; if ( n Parents1 < n Parents2 ) { int adjust = n Parents2 - n Parents1 ; for ( int i = _ NUM ; i < adjust ; i ++ ) { start Node2 = get Parent Of Node ( start Node2 ) ; } } else if ( n Parents1 > n Parents2 ) { int adjust = n Parents1 - n Parents2 ; for ( int i = _ NUM ; i < adjust ; i ++ ) { start Node1 = get Parent Of Node ( start Node1 ) ; } }  Node prev Child1 = null , prev Child2 = null ; while ( null != start Node1 ) { if ( start Node1 == start Node2 || is Node The Same ( start Node1 , start Node2 ) ) { if ( null == prev Child1 ) { is Node After = ( n Parents1 < n Parents2 ) ? _ BOOL : _ BOOL ; break ; } else { is Node After = is Node After Sibling ( start Node1 , prev Child1 , prev Child2 ) ; break ; } } prev Child1 = start Node1 ; start Node1 = get Parent Of Node ( start Node1 ) ; prev Child2 = start Node2 ; start Node2 = get Parent Of Node ( start Node2 ) ; } } return is Node After ; }
protected  Example Set Meta Data modify Inner Output Example Set (  Example Set Meta Data meta Data ) { return meta Data ; }
public static void copy Properties (  Object dest ,  Object src ) { if ( dest == null || src == null ) { return ; } try {  Property Utils . copy Properties ( dest , src ) ; } catch (  Illegal Access Exception e ) { throw new  Illegal State Exception ( e ) ; } catch (  Invocation Target Exception e ) { throw new  Illegal State Exception ( e ) ; } catch (  No Such Method Exception e ) { throw new  Illegal State Exception ( e ) ; } }
public static  UIAddress from Satoshi Style (  String address ) throws  Hyper Ledger Exception { try {  Network network =  Network .  PRODUCTION ;  Address .  Type type =  Address .  Type .  COMMON ; byte [ ] raw =  Byte Utils . from Base58 ( address ) ; if ( ( raw [ _ NUM ] & _ NUM ) == _ NUM ) { network =  Network .  PRODUCTION ; type =  Address .  Type .  COMMON ; } if ( ( raw [ _ NUM ] & _ NUM ) == _ NUM ) { network =  Network .  PRODUCTION ; type =  Address .  Type .  P2 SH ; } if ( ( raw [ _ NUM ] & _ NUM ) == _ NUM ) { network =  Network .  TEST ; type =  Address .  Type .  COMMON ; } if ( ( raw [ _ NUM ] & _ NUM ) == _ NUM ) { network =  Network .  TEST ; type =  Address .  Type .  P2 SH ; } byte [ ] check =  Hash . hash ( raw , _ NUM , raw . length - _ NUM ) ; for ( int i = _ NUM ; i < _ NUM ; ++ i ) { if ( check [ i ] != raw [ raw . length - _ NUM + i ] ) { throw new  Hyper Ledger Exception ( _ STR ) ; } } byte [ ] key Digest = new byte [ raw . length - _ NUM ] ;  System . arraycopy ( raw , _ NUM , key Digest , _ NUM , raw . length - _ NUM ) ; return new  UIAddress ( network , type , key Digest ) ; } catch (  Exception e ) { throw new  Hyper Ledger Exception ( e ) ; } }
protected boolean after Save ( boolean new Record , boolean success ) { if ( ! success ) return success ; return update Journal Total ( ) ; }
public static  String [ ] list Resources (  String quote Directory Unquote ) throws  URISyntax Exception ,  IOException { final  String dir With Slash = trailing Slash ( quote Directory Unquote , _ BOOL ) ; final  URL url ;  URL temp = get Resource ( dir With Slash ) ; if ( temp == null ) { temp = get Resource ( trailing Slash ( quote Directory Unquote , _ BOOL ) ) ; } url = temp ; if ( url == null ) { return null ; } if ( url . get Protocol ( ) . equals ( _ STR ) ) { final  Array List <  String > strings = new  Array List < > ( ) ; final  File dir = new  File ( url . to URI ( ) ) ; for ( final  File f :  File Utils . list Files ( dir ) ) { strings . add (  String Utils .  FS . equals ( _ STR ) ? f . get Path ( ) : f . get Path ( ) . replace All ( _ STR +  String Utils .  FS , _ STR ) ) ; } return strings . to Array ( new  String [ strings . size ( ) ] ) ; } else if ( url . get Protocol ( ) . equals ( _ STR ) ) { final  Array List <  String > strings = new  Array List < > ( ) ; assert url . get Path ( ) . starts With ( _ STR ) ; final  String jar Path = url . get Path ( ) . substring ( _ NUM , url . get Path ( ) . last Index Of ( _ STR ) ) ; try (  Jar File jf = new  Jar File ( jar Path ) ) { final  Enumeration <  Jar Entry > en = jf . entries ( ) ; while ( en . has More Elements ( ) ) { final  Jar Entry je = en . next Element ( ) ; if ( je . get Name ( ) . starts With ( dir With Slash ) ) { final  String rest = je . get Name ( ) . substring ( dir With Slash . length ( ) ) ; final int index = rest . index Of ( _ STR ) ; if ( rest . length ( ) > _ NUM && ( index < _ NUM || ( index > _ NUM && index == rest . length ( ) - _ NUM ) ) ) { strings . add ( je . get Name ( ) ) ; } } } } return strings . to Array ( new  String [ strings . size ( ) ] ) ; } return null ; }
private  Iterable <  Field > fields With Annotation (  Class < ? > cls ) { synchronized ( mux ) {  List <  Field > fields = field Cache . get ( cls ) ; if ( fields == null ) { fields = new  Array List < > ( ) ; for (  Field field : cls . get Declared Fields ( ) ) {  Annotation ann = field . get Annotation ( ann Cls ) ; if ( ann != null || needs Recursion ( field ) ) fields . add ( field ) ; } if ( ! fields . is Empty ( ) ) field Cache . put ( cls , fields ) ; } return fields ; } }
private  Git Note Writer (  String review Hash , final  Repository repo ,  String ref ,  Person Ident author ) { this . ref = ref ; this . repo = repo ; this . author = author ; rev Walk = new  Rev Walk ( repo ) ; inserter = repo . new Object Inserter ( ) ; reader = repo . new Object Reader ( ) ; try {  Object Id review Ref Obj Id = repo . resolve ( review Hash ) ; this . review Commit = rev Walk . parse Commit ( review Ref Obj Id ) ; } catch (  Exception e ) { logger . log (  Level .  SEVERE , _ STR + review Hash , e ) ; throw new  Runtime Exception ( e ) ; } }
public void rollback ( ) { final  Write Lock lock = _field Read Write Lock . write Lock ( ) ; lock . lock ( ) ; try { assert Open ( ) ; if ( is Read Only ( ) ) throw new  Illegal State Exception ( ) ; tx Log . warn ( _ STR ) ; final  Byte Buffer buf = _buffer Strategy . read Root Block ( ! _root Block . is Root Block0 ( ) ) ; final  IRoot Block View new Root Block = new  Root Block View ( _root Block . is Root Block0 ( ) , buf , checker ) ; _buffer Strategy . write Root Block ( new Root Block , force On Commit ) ; _root Block = new Root Block ; abort ( ) ; historical Index Cache . clear ( ) ; index Cache . clear ( ) ; } finally { lock . unlock ( ) ; } }
protected boolean is Dto Getter (  Method method ) { if ( method . is Annotation Present (  Delegate To . class ) ) { return _ BOOL ; }  String method Name = method . get Name ( ) ; if ( ( method Name . starts With ( _ STR ) || method Name . starts With ( _ STR ) ) && method . get Parameter Types ( ) . length == _ NUM ) { if ( method Name . starts With ( _ STR ) && method Name . length ( ) > _ NUM ) { return method . get Return Type ( ) ==  Boolean . class || method . get Return Type ( ) == boolean . class ; } return method Name . length ( ) > _ NUM ; } return _ BOOL ; }
private static <  T > void assert Collection Equals No Order (  Collection <  T > expected ,  Collection <  T > actual ) {  String msg =  String . format ( _ STR , expected , actual ) ; assert Equals ( msg , expected . size ( ) , actual . size ( ) ) ; for (  T e : expected ) { if ( ! actual . contains ( e ) ) { msg =  String . format ( _ STR + _ STR , e , expected , actual ) ; fail ( msg ) ; } } }
public static  File create Testing File (  Path relative Path ) {  Path path = relative Path . to Absolute Path ( ) ; if ( ! in Target Dir ( path ) ) { throw new  Illegal State Exception ( _ STR + relative Path + _ STR ) ; } return  Io Util . create File ( path ) ; }
public final boolean skip Any (  Char Set char Set ,  Char Sequence csq ) { int i = index ; int n = csq . length ( ) ; for ( ; ( i < n ) && char Set . contains ( csq . char At ( i ) ) ; i ++ ) { } if ( i == index ) return _ BOOL ; index = i ; return _ BOOL ; }
private void generate Gaussian Examples (  Instances format , int num Instances ,  Random random ,  Subspace Cluster Definition cl ,  String c Name ) { boolean make Integer = cl . is Integer ( ) ;  Instance example = null ; int num Atts = m_ Num Attributes ; if ( get Class Flag ( ) ) { num Atts ++ ; } example = new  Dense Instance ( num Atts ) ; example . set Dataset ( format ) ; boolean [ ] attributes = cl . get Attributes ( ) ; double [ ] mean Value = cl . get Mean Value ( ) ; double [ ] stddev Value = cl . get Stddev Value ( ) ; for ( int j = _ NUM ; j < num Instances ; j ++ ) { int num = - _ NUM ; for ( int i = _ NUM ; i < m_ Num Attributes ; i ++ ) { if ( attributes [ i ] ) { num ++ ; double value = mean Value [ num ] + ( random . next Gaussian ( ) * stddev Value [ num ] ) ; if ( make Integer ) { value =  Math . round ( value ) ; } example . set Value ( i , value ) ; } else { example . set Missing ( i ) ; } } if ( get Class Flag ( ) ) { example . set Class Value ( c Name ) ; } format . add ( example ) ; } }
public synchronized boolean retain All (  Collection c ) {  Object [ ] elements = get Array ( ) ; int len = elements . length ; if ( len != _ NUM ) { int newlen = _ NUM ;  Object [ ] temp = new  Object [ len ] ; for ( int i = _ NUM ; i < len ; ++ i ) {  Object element = elements [ i ] ; if ( c . contains ( element ) ) temp [ newlen ++ ] = element ; } if ( newlen != len ) { set Array ( copy Of Range ( temp , _ NUM , newlen ,  Object [ ] . class ) ) ; return _ BOOL ; } } return _ BOOL ; }
public  Info create Info (  String value ) {  Information Field info Impl = new  Information Field ( ) ; try { info Impl . set Value ( value ) ; } catch (  Sdp Exception s ) { s . print Stack Trace ( ) ; } return info Impl ; }
public static  String escape (  String string ) { if ( string == null || string . equals ( _ STR ) ) { return string ; }  String prefix = _ STR ; if ( string . index Of ( _ STR ) != - _ NUM ) { prefix = string . substring ( _ NUM , string . index Of ( _ STR ) + _ NUM ) ; string = string . replace First ( prefix , _ STR ) ; } string = string . replace All ( _ STR , _ STR ) ; if ( string . starts With ( _ STR ) ) { string = _ STR + string . replace All ( _ STR , _ STR ) ; } else { string = string . replace All ( _ STR , _ STR ) ; } return prefix . concat ( string ) ; }
private void reload Cache With New Value ( final  Long new Value ) { final long new Value As Primitive = new Value == null ? get Cache Update Period ( ) : new Value ;  LOG . debug ( _ STR , cache Update Period Listeners . size ( ) ) ; for ( final  Property Change Listener listener : cache Update Period Listeners ) { final  Property Change Event event = new  Property Change Event ( this , _ STR , get Cache Update Period ( ) , new Value As Primitive ) ; listener . property Change ( event ) ; } }
public static void write Chars To Writer ( char [ ] chars ,  Writer writer ) throws  IOException {  Buffered Writer bw = new  Buffered Writer ( writer ) ; try { bw . write ( chars ) ; } finally { bw . close ( ) ; } }
public final void dec Ref ( ) throws  IOException { if ( ref Count . get ( ) <= _ NUM ) { throw new  Already Closed Exception ( _ STR ) ; } final int rc = ref Count . decrement And Get ( ) ; if ( rc == _ NUM ) { closed = _ BOOL ;  Throwable throwable = null ; try { do Close ( ) ; } catch (  Throwable th ) { throwable = th ; } finally { try { report Close To Parent Readers ( ) ; } finally { notify Reader Closed Listeners ( throwable ) ; } } } else if ( rc < _ NUM ) { throw new  Illegal State Exception ( _ STR + rc + _ STR ) ; } }
public  Jca X509v3 Certificate Builder (  X500 Name issuer ,  Big Integer serial ,  Date not Before ,  Date not After ,  X500 Name subject ,  Public Key public Key ) { super ( issuer , serial , not Before , not After , subject ,  Subject Public Key Info . get Instance ( public Key . get Encoded ( ) ) ) ; }
@  Override public  Bigdata Statement next ( ) throws  Query Evaluation Exception { final  Bigdata Statement stmt = src . next ( ) ; { final  Bigdata Value s = stmt . get Subject ( ) ; if ( described Resources . contains ( s ) ) { record ( s , stmt ) ; } } { final  Bigdata Value o = stmt . get Object ( ) ; if ( described Resources . contains ( o ) ) { record ( o , stmt ) ; } } return stmt ; }
private static boolean is Unexpected Bug (  Bug Instance bug ) { return  FB_ MISSING_ EXPECTED_ WARNING . equals ( bug . get Type ( ) ) ||  FB_ UNEXPECTED_ WARNING . equals ( bug . get Type ( ) ) ; }
public static void show Finished Notification (  String content , int time , boolean error ,  Context context ,  Intent intent ) { if ( context == null ) return ;  Notification Manager m Not Man = (  Notification Manager ) context . get System Service (  Context .  NOTIFICATION_ SERVICE ) ; int icon =  R . drawable . icon ;  Char Sequence title =  String . format ( (  String ) context . get Text (  R . string .  Utils_ Download Finished Title ) , time ) ;  Char Sequence ticker = context . get Text (  R . string .  Utils_ Download Finished Ticker ) ;  Char Sequence text = content ; if ( content == null ) text = context . get Text (  R . string .  Utils_ Download Finished Text ) ; if ( error ) { icon =  R . drawable . icon ; title = context . get Text (  R . string .  Utils_ Download Error Title ) ; ticker = context . get Text (  R . string .  Utils_ Download Error Ticker ) ; }  Notification notification = build Notification ( context , icon , ticker , title , text , _ BOOL , intent ) ; m Not Man . notify (  ID_ FINISHED , notification ) ; }
public static int longest Valid Parentheses (  String s ) { if ( s == null ) return _ NUM ;  Stack <  Integer > stack = new  Stack <  Integer > ( ) ; int max Len = _ NUM ; int len = _ NUM ; for ( int i = _ NUM ; i < s . length ( ) ; i ++ ) { if ( s . char At ( i ) == _ STR ) stack . push ( i ) ; else if ( s . is Empty ( ) ) len = _ NUM ; else { int matched Pos = stack . pop ( ) ; int matched Len = i - matched Pos + _ NUM ; if ( s . is Empty ( ) ) { len += matched Len ; matched Len = len ; } else matched Len = i - stack . peek ( ) ; max Len =  Math . max ( max Len , matched Len ) ; } } return max Len ; }
private static void exit ( @  Nullable  String err Msg , boolean show Usage , int exit Code ) { if ( err Msg != null )  X . error ( err Msg ) ;  String runner =  System . get Property (  IGNITE_ PROG_ NAME , _ STR ) ; int space = runner . index Of ( _ STR ) ; runner = runner . substring ( _ NUM , space == - _ NUM ? runner . length ( ) : space ) ; if ( show Usage ) { boolean ignite = runner . contains ( _ STR ) ;  X . error ( _ STR , _ STR + runner + ( ignite ? _ STR : _ STR ) , _ STR , _ STR , _ STR , _ STR , _ STR ) ; if ( ignite ) {  X . error ( _ STR , _ STR , _ STR , _ STR , _ STR , _ STR , _ STR ) ; } }  System . exit ( exit Code ) ; }
@  Override public int compare To (  New Split Emitted Term term2 ) { int result ; if ( ( result = term . compare To ( term2 . get Term ( ) ) ) != _ NUM ) return result ; if ( ( result = splitno - term2 . get Splitno ( ) ) != _ NUM ) return result ; return flushno - term2 . get Flushno ( ) ; }
public  Section (  Location location ,  Location location2 ) { this . min X =  Math . min ( location . get Block X ( ) , location2 . get Block X ( ) ) ; this . min Y =  Math . min ( location . get Block Y ( ) , location2 . get Block Y ( ) ) ; this . min Z =  Math . min ( location . get Block Z ( ) , location2 . get Block Z ( ) ) ; this . max X =  Math . max ( location . get Block X ( ) , location2 . get Block X ( ) ) ; this . max Y =  Math . max ( location . get Block Y ( ) , location2 . get Block Y ( ) ) ; this . max Z =  Math . max ( location . get Block Z ( ) , location2 . get Block Z ( ) ) ; this . world = location . get World ( ) ; }
public void find Package And Class ( ) throws  IOException { package Name = null ; class Name = null ;  Line Number Reader reader = new  Line Number Reader ( new  File Reader ( input File ) ) ; while ( class Name == null || package Name == null ) {  String line = reader . read Line ( ) ; if ( line == null ) break ; if ( package Name == null ) { int index = line . index Of ( _ STR ) ; if ( index >= _ NUM ) { index += _ NUM ; int end = line . index Of ( _ STR , index ) ; if ( end >= index ) { package Name = line . substring ( index , end ) ; package Name = package Name . trim ( ) ; } } } if ( class Name == null ) { int index = line . index Of ( _ STR ) ; if ( index >= _ NUM ) { index += _ NUM ; class Name = line . substring ( index ) ; class Name = class Name . trim ( ) ; } } } if ( class Name == null ) class Name = _ STR ; }
public void parse ( ) { for (  String line : commands ) {  String [ ] args = line . split ( _ STR ) ; switch ( args [ _ NUM ] ) { case _ STR : handle Response ( args ) ; break ; case _ STR : switch ( args [ _ NUM ] ) { case _ STR : sub . await Terminal Event ( ) ; break ; case _ STR : try { sub . await At Least (  Long . parse Long ( args [ _ NUM ] ) ) ; } catch (  Interrupted Exception e ) {  Console Utils . error ( _ STR ) ; } break ; case _ STR : try { sub . await No Events (  Long . parse Long ( args [ _ NUM ] ) ) ; } catch (  Interrupted Exception e ) {  Console Utils . error ( _ STR ) ; } break ; } break ; case _ STR : switch ( args [ _ NUM ] ) { case _ STR : sub . assert No Errors ( ) ; break ; case _ STR : sub . assert Error ( new  Throwable ( ) ) ; break ; case _ STR : handle Received ( args ) ; break ; case _ STR : sub . assert Value Count (  Integer . parse Int ( args [ _ NUM ] ) ) ; break ; case _ STR : sub . assert Received At Least (  Integer . parse Int ( args [ _ NUM ] ) ) ; break ; case _ STR : sub . assert Complete ( ) ; break ; case _ STR : sub . assert Not Complete ( ) ; break ; case _ STR : sub . is Cancelled ( ) ; break ; } break ; case _ STR : sub . take (  Long . parse Long ( args [ _ NUM ] ) ) ; break ; case _ STR : sub . request (  Long . parse Long ( args [ _ NUM ] ) ) ;  Console Utils . info ( _ STR + args [ _ NUM ] ) ; break ; case _ STR : sub . cancel ( ) ; break ; } } if ( name . equals ( _ STR ) ) { name = _ STR ; } if ( sub . has Passed ( ) && this . pass )  Console Utils . success ( name ) ; else if ( ! sub . has Passed ( ) && ! this . pass )  Console Utils . success ( name ) ; else  Console Utils . failure ( name ) ; }
@  Post Construct public void init ( ) {  Iterator <  Validator Factory > iterator = validator Factory Instance . iterator ( ) ; if ( iterator . has Next ( ) ) { this . validator Factory = iterator . next ( ) ; } else { log . warning ( _ STR ) ; this . validator Factory =  Validation . build Default Validator Factory ( ) ; } }
public void start ( ) { try { heart = new  Heart ( ) ; int threads =  Integer . parse Int ( properties . get Property ( _ STR , _ STR ) ) ; for ( int i = _ NUM ; i < threads ; i ++ ) {  Worker worker = new  Worker ( this , i ) ; workers . add ( worker ) ; } client = new  Async ( this , async_timeout , _ BOOL ) ; client . start ( threads ) ; alive = _ BOOL ;  Thread thread = new  Thread ( this , _ STR ) ; id = thread . get Id ( ) ; thread . start ( ) ; } catch (  Exception e ) { e . print Stack Trace ( out ) ; } }
public void adapt ( ) { double [ ] zmin = new double [ number Of Objectives ] ; double [ ] zmax = new double [ number Of Objectives ] ;  Arrays . fill ( zmin ,  Double .  POSITIVE_ INFINITY ) ;  Arrays . fill ( zmax ,  Double .  NEGATIVE_ INFINITY ) ; for (  Solution solution : this ) { for ( int i = _ NUM ; i < number Of Objectives ; i ++ ) { zmin [ i ] =  Math . min ( zmin [ i ] , solution . get Objective ( i ) ) ; zmax [ i ] =  Math . max ( zmax [ i ] , solution . get Objective ( i ) ) ; } } weights . clear ( ) ; for ( double [ ] weight : original Weights ) { double [ ] new Weight = weight . clone ( ) ; for ( int i = _ NUM ; i < number Of Objectives ; i ++ ) { new Weight [ i ] *=  Math . max ( _ NUM , zmax [ i ] - zmin [ i ] ) ; } weights . add (  Vector . normalize ( new Weight ) ) ; } min Angles = new double [ weights . size ( ) ] ; for ( int i = _ NUM ; i < weights . size ( ) ; i ++ ) { min Angles [ i ] = smallest Angle Between Weights ( i ) ; } }
public void add Column (  Column previous Column ,  Column column ) { if ( column != null ) { if ( previous Column == null ) { columns . add ( _ NUM , column ) ; } else { columns . add ( columns . index Of ( previous Column ) , column ) ; } } }
public static void print ( final  Print Stream out , final  String name , final  Percentile p ) { if ( p . is Ready ( ) ) { try { final  String Builder sb = new  String Builder ( _ NUM ) ; final float [ ] q = p . get Quantiles ( ) ; final float [ ] e = p . get Estimates ( ) ; final int  SCREENWIDTH = _ NUM ; sb . append ( name ) ; sb . append ( _ STR ) ; sb . append ( p . get Min ( ) ) ; sb . append ( _ STR ) ; sb . append ( p . get Max ( ) ) ; sb . append ( _ STR ) ; sb . append ( _ STR ) ; final float max = e [ e . length - _ NUM ] ; for ( int i = _ NUM ; i < q . length ; i ++ ) { sb . append (  String . format ( _ STR , q [ i ] ) ) ; sb . append ( _ STR ) ; final int len = ( int ) ( e [ i ] / max *  SCREENWIDTH ) ; for ( int j = _ NUM ; j < len ; j ++ ) { sb . append ( _ STR ) ; } sb . append ( _ STR ) ; sb . append (  String . format ( _ STR , e [ i ] ) ) ; } out . println ( sb . to String ( ) ) ; } catch (  Insufficient Samples Exception e ) { } } }
@  Target Api (  Build .  VERSION_ CODES .  JELLY_ BEAN ) private void dequeue Output Buffer (  Media Codec codec ,  Byte Buffer [ ] output Buffers , int index ,  Media Codec .  Buffer Info info ) { if (  Build .  VERSION .  SDK_ INT >=  Build .  VERSION_ CODES .  JELLY_ BEAN ) {  Byte Buffer buffer = output Buffers [ index ] ;  Log . i ( _ STR + info . size + _ STR + buffer . remaining ( ) ) ; if ( info . size <= buffer . remaining ( ) ) { final byte [ ] buffer Copied = new byte [ info . size ] ; buffer . get ( buffer Copied ) ; codec . release Output Buffer ( index , _ BOOL ) ; add Encoded ( buffer Copied ) ; if (  Log .  DEBUG ) {  Audio Utils . show Some Bytes ( _ STR , buffer Copied ) ; } } else {  Log . e ( _ STR ) ; codec . release Output Buffer ( index , _ BOOL ) ; } } }
private  Carbon Iterator <  Batch Raw Result > execute Block List (  List <  Table Block Info > block List ) throws  Query Execution Exception { query Model . set Table Block Infos ( block List ) ; this . query Executor =  Query Executor Factory . get Query Executor ( query Model ) ;  Carbon Iterator <  Batch Raw Result > iter = null ; try { iter = query Executor . execute ( query Model ) ; } catch (  Query Execution Exception e ) {  LOGGER . error ( e . get Message ( ) ) ; throw e ; } return iter ; }
@  Override public int hash Code ( ) { return node Id . hash Code ( ) + action Values . hash Code ( ) ; }
private void internal Remove ( final  Object [ ] elements ) {  Object input = get Input ( ) ; for ( int i = _ NUM ; i < elements . length ; ++ i ) { if ( equals ( elements [ i ] , input ) ) { set Input ( null ) ; return ; } int ix = get Element Index ( elements [ i ] ) ; if ( ix >= _ NUM ) {  Check Item item = list Remove ( ix ) ; list Map . remove ( ix ) ; unmap Element ( elements [ i ] , item . get Control ( ) ) ; } } }
public  Process Drawer ( final  Process Renderer Model model , final boolean draw Highlight ) { if ( model == null ) { throw new  Illegal Argument Exception ( _ STR ) ; } this . model = model ; this . draw Highlight = draw Highlight ; decorators = new  Hash Map < > ( ) ; for (  Render Phase phase :  Render Phase . draw Order ( ) ) { decorators . put ( phase , new  Copy On Write Array List <  Process Draw Decorator > ( ) ) ; } operator Decorators = new  Copy On Write Array List <  Operator Draw Decorator > ( ) ; }
public boolean has Update Listeners ( ) { boolean is Empty = ! listeners . is Empty ( ) ; return is Empty ; }
public static  String [ ] split Options (  String quoted Option String ) throws  Exception {  Vector <  String > options Vec = new  Vector <  String > ( ) ;  String str = new  String ( quoted Option String ) ; int i ; while ( _ BOOL ) { i = _ NUM ; while ( ( i < str . length ( ) ) && (  Character . is Whitespace ( str . char At ( i ) ) ) ) { i ++ ; } str = str . substring ( i ) ; if ( str . length ( ) == _ NUM ) { break ; } if ( str . char At ( _ NUM ) == _ STR ) { i = _ NUM ; while ( i < str . length ( ) ) { if ( str . char At ( i ) == str . char At ( _ NUM ) ) { break ; } if ( str . char At ( i ) == _ STR ) { i += _ NUM ; if ( i >= str . length ( ) ) { throw new  Exception ( _ STR ) ; } } i += _ NUM ; } if ( i >= str . length ( ) ) { throw new  Exception ( _ STR ) ; }  String opt Str = str . substring ( _ NUM , i ) ; opt Str = unback Quote Chars ( opt Str ) ; options Vec . add Element ( opt Str ) ; str = str . substring ( i + _ NUM ) ; } else { i = _ NUM ; while ( ( i < str . length ( ) ) && ( !  Character . is Whitespace ( str . char At ( i ) ) ) ) { i ++ ; }  String opt Str = str . substring ( _ NUM , i ) ; options Vec . add Element ( opt Str ) ; str = str . substring ( i ) ; } }  String [ ] options = new  String [ options Vec . size ( ) ] ; for ( i = _ NUM ; i < options Vec . size ( ) ; i ++ ) { options [ i ] = options Vec . element At ( i ) ; } return options ; }
public static int put Short ( byte [ ] bytes , int offset , short val ) { if ( little Endian ) { val =  Short . reverse Bytes ( val ) ; } the Unsafe . put Short ( bytes , offset +  BYTE_ ARRAY_ BASE_ OFFSET , val ) ; return offset +  Bytes .  SIZEOF_ SHORT ; }
protected void draw Value Label (  Drawing Context context ,  Shape point ,  Row row , int point Index , int col ) {  Comparable < ? > value = row . get ( col ) ;  Format format = get Value Format ( ) ; if ( ( format == null ) && row . is Column Numeric ( col ) ) { format =  Number Format . get Instance ( ) ; }  String text = ( format != null ) ? format . format ( value ) : value . to String ( ) ;  Color Mapper colors = get Value Color ( ) ;  Paint paint = colors . get ( point Index ) ;  Font font = get Value Font ( ) ; double font Size = font . get Size2 D ( ) ;  Location location = get Value Location ( ) ; double align X = get Value Alignment X ( ) ; double align Y = get Value Alignment Y ( ) ; double rotation = get Value Rotation ( ) ; double distance = get Value Distance ( ) ; if (  Math Utils . is Calculatable ( distance ) ) { distance *= font Size ; } else { distance = _ NUM ; }  Label label = new  Label ( text ) ; label . set Alignment X ( align X ) ; label . set Alignment Y ( align Y ) ; label . set Rotation ( rotation ) ; label . set Color ( paint ) ; label . set Font ( font ) ;  Rectangle2 D bounds Point = point . get Bounds2 D ( ) ;  Drawable Container label Container = new  Drawable Container ( new  Outer Edge Layout ( distance ) ) ; label Container . add ( label , location ) ; label Container . set Bounds ( bounds Point ) ; label Container . draw ( context ) ; }
protected static boolean starts With (  String string ,  String tag ) { return string . starts With ( tag ) || ( tag . contains ( _ STR ) && string . starts With ( tag . replace All ( _ STR , _ STR ) ) ) ; }
private void check Status (  Hadoop Job Id job Id , boolean complete ) throws  Exception { for ( int i = _ NUM ; i < grid Count ( ) ; i ++ ) {  Ignite Kernal kernal = (  Ignite Kernal ) grid ( i ) ;  Hadoop hadoop = kernal . hadoop ( ) ;  Hadoop Job Status stat = hadoop . status ( job Id ) ; assert stat != null ;  Ignite Internal Future < ? > fut = hadoop . finish Future ( job Id ) ; if ( ! complete ) assert False ( fut . is Done ( ) ) ; else { info ( _ STR + i + _ STR + kernal . get Local Node Id ( ) + _ STR ) ; fut . get ( ) ; } } }
private  List <  String > build Train Command (  File training File ,  String target Model Location , double param C , int param Order E , int param Order T , double param Epsilon , int param B ) {  List <  String > result = new  Array List < > ( ) ; result . add ( resolve SVMHmm Learn Command ( ) ) ; result . add ( _ STR ) ; result . add (  String . format (  Locale .  ENGLISH , _ STR , this . param C ) ) ; result . add ( _ STR ) ; result . add (  Integer . to String ( this . param Order E ) ) ; result . add ( _ STR ) ; result . add (  Integer . to String ( this . param Order T ) ) ; result . add ( _ STR ) ; result . add (  String . format (  Locale .  ENGLISH , _ STR , this . param Epsilon ) ) ; result . add ( _ STR ) ; result . add (  Integer . to String ( this . param B ) ) ; result . add ( training File . get Absolute Path ( ) ) ; result . add ( target Model Location ) ; return result ; }
private static final  Set <  File > encode (  String src ) { if ( src == null || src . length ( ) == _ NUM ) return new  Hash Set <  File > ( ) ;  String Tokenizer tokenizer = new  String Tokenizer ( src , _ STR ) ; int size = tokenizer . count Tokens ( ) ;  Set <  File > set = new  Hash Set <  File > ( ) ; for ( int i = _ NUM ; i < size ; i ++ ) set . add ( new  File ( tokenizer . next Token ( ) ) ) ; return set ; }
public  E poll ( long timeout ,  Time Unit unit ) throws  Interrupted Exception { long nanos = unit . to Nanos ( timeout ) ; final  Reentrant Lock lock = this . lock ; lock . lock Interruptibly ( ) ; try { for ( ; ; ) {  E first = q . peek ( ) ; if ( first == null ) { if ( nanos <= _ NUM ) return null ; else nanos = available . await Nanos ( nanos ) ; } else { long delay = first . get Delay (  NANOSECONDS ) ; if ( delay <= _ NUM ) return q . poll ( ) ; if ( nanos <= _ NUM ) return null ; first = null ; if ( nanos < delay || leader != null ) nanos = available . await Nanos ( nanos ) ; else {  Thread this Thread =  Thread . current Thread ( ) ; leader = this Thread ; try { long time Left = available . await Nanos ( delay ) ; nanos -= delay - time Left ; } finally { if ( leader == this Thread ) leader = null ; } } } } } finally { if ( leader == null && q . peek ( ) != null ) available . signal ( ) ; lock . unlock ( ) ; } }
public int add Patterns ( ) throws  IOException { if ( paint List . size ( ) > _ NUM ) {  PDFDictionary patterns = pdf . open Dictionary ( _ STR ) ;  List Iterator <  Entry > i = paint List . list Iterator ( ) ; while ( i . has Next ( ) ) {  Entry e = (  Entry ) i . next ( ) ; patterns . entry ( e . name , pdf . ref ( e . name ) ) ; } pdf . close ( patterns ) ; } return paint List . size ( ) ; }
private int find Last Group Index ( int group Id ) { int i = _ NUM , size = m Items . size ( ) ; boolean traversing Group = _ BOOL ; while ( _ BOOL ) { if ( i < size ) { final  Sublime Base Menu Item item = m Items . get ( i ) ; if ( item . get Group Id ( ) == group Id ) { traversing Group = _ BOOL ; } else if ( traversing Group ) { return i - _ NUM ; } i ++ ; } else { return traversing Group ? size - _ NUM : size ; } } }
public static void write Short Integer (  Output Stream the Os , int the Value ) throws  IOException { the Os . write ( ( byte ) ( the Value | ( byte ) _ NUM ) ) ; }
public void add Header (  String name ,  String value ) { if ( custom Headers == null ) { custom Headers = new  Hash Map < > ( _ NUM ) ; }  List <  String > header = custom Headers . get ( name ) ; if ( header == null ) { header = new  Array List < > ( ) ; custom Headers . put ( name , header ) ; } header . add ( value ) ; }
public void store ( ) throws  IOException ,  Certificate Exception ,  No Such Algorithm Exception ,  Key Store Exception { try {  File Output Stream key Store OStream = new  File Output Stream ( keystore File ) ; ks . store ( key Store OStream , keystore Pass . to Char Array ( ) ) ; key Store OStream . close ( ) ; key Store OStream = null ; if ( logger . message Enabled ( ) ) { logger . message ( _ STR + keystore File ) ; } } catch (  Key Store Exception e ) { logger . error ( e . get Message ( ) ) ; throw e ; } }
public synchronized  Base Type create Union ( final  String name ) throws  Couldnt Save Data Exception {  Preconditions . check Not Null ( name , _ STR ) ;  Preconditions . check Argument ( ! name . is Empty ( ) , _ STR ) ; final  Base Type union Type = instantiate Type ( name , _ NUM , _ BOOL , null ,  Base Type Category .  UNION ) ; notify Type Added ( union Type ) ; return union Type ; }
public static void sort ( char [ ] a ) { do Sort ( a , _ NUM , a . length - _ NUM ) ; }
public  String to String ( ) { return _ STR + format . format ( x ) + _ STR + format . format ( y ) + _ STR ; }
public  Optional <  T > first ( ) {  Iterator <  T > iterator = iterator ( ) ; return iterator . has Next ( ) ?  Optional . of ( iterator . next ( ) ) :  Optional . <  T > empty ( ) ; }
public static void sleep ( long millis ) { try {  Thread . sleep ( millis ) ; } catch (  Interrupted Exception e ) { throw new  Runtime Exception ( e ) ; } }
static boolean is Package Access ( final int modifiers ) { return ( modifiers &  Member Utils .  ACCESS_ TEST ) == _ NUM ; }
public static void install Palette Prefs Handler ( final  Preferences prefs , final  String name ,  Window window ) { install Palette Prefs Handler ( prefs , name , window , _ NUM ) ; }
private boolean discard Upstream Media Chunks ( int queue Length ) { if ( media Chunks . size ( ) <= queue Length ) { return _ BOOL ; } long total Bytes = _ NUM ; long start Time Us = _ NUM ; long end Time Us = media Chunks . get Last ( ) . end Time Us ; while ( media Chunks . size ( ) > queue Length ) {  Media Chunk removed = media Chunks . remove Last ( ) ; total Bytes += removed . bytes Loaded ( ) ; start Time Us = removed . start Time Us ; removed . release ( ) ; } notify Upstream Discarded ( start Time Us , end Time Us , total Bytes ) ; return _ BOOL ; }
public static boolean test File Exists (  String name ) { boolean status ; if ( ( test Save Location Exists ( ) ) && ( ! name . equals ( _ STR ) ) ) {  File path =  Environment . get External Storage Directory ( ) ;  File new Path = construct File Paths ( path . to String ( ) , name ) ; status = new Path . exists ( ) ; } else { status = _ BOOL ; } return status ; }
Map <  String ,  Type Name > convert Properties To Types (  Map <  String ,  Executable Element > properties ) {  Map <  String ,  Type Name > types = new  Linked Hash Map <  String ,  Type Name > ( ) ; for (  Map .  Entry <  String ,  Executable Element > entry : properties . entry Set ( ) ) {  Executable Element el = entry . get Value ( ) ; types . put ( entry . get Key ( ) ,  Type Name . get ( el . get Return Type ( ) ) ) ; } return types ; }
public static void change Font (  JComponent comp , double scale Factor , int style ) {  Font font = comp . get Font ( ) ; font = scale ( font , scale Factor ) ; comp . set Font ( font . derive Font ( style ) ) ; }
public static  Image Icon create Icon From Color ( final  Color color , final  Color border Color , final int width , final int height , final  Shape shape ) {  Buffered Image img = new  Buffered Image ( width , height ,  Buffered Image .  TYPE_ INT_ ARGB ) ;  Graphics2 D g2 = img . create Graphics ( ) ; g2 . set Rendering Hint (  Rendering Hints .  KEY_ ANTIALIASING ,  Rendering Hints .  VALUE_ ANTIALIAS_ ON ) ; g2 . set Color ( color ) ; g2 . fill ( shape ) ; g2 . set Color ( border Color ) ; g2 . draw ( shape ) ; g2 . dispose ( ) ; return new  Image Icon ( img ) ; }
void print Command Builder (  Command Builder command Builder ) { if ( display Equivalent Argument . is Present ( ) ) { println ( ) ; println No Wrap (  INFO_ DSCFG_ NON_ INTERACTIVE . get ( command Builder ) ) ; } if ( equivalent Command File Argument . is Present ( ) ) {  String file = equivalent Command File Argument . get Value ( ) ;  Buffered Writer writer = null ; try { writer = new  Buffered Writer ( new  File Writer ( file , _ BOOL ) ) ; if ( ! session Start Time Printed ) { writer . write (  SHELL_ COMMENT_ SEPARATOR + get Session Start Time Message ( ) ) ; writer . new Line ( ) ; session Start Time Printed = _ BOOL ; } session Equivalent Operation Number ++ ; writer . new Line ( ) ; writer . write (  SHELL_ COMMENT_ SEPARATOR +  INFO_ DSCFG_ EQUIVALENT_ COMMAND_ LINE_ SESSION_ OPERATION_ NUMBER . get ( session Equivalent Operation Number ) ) ; writer . new Line ( ) ; writer . write (  SHELL_ COMMENT_ SEPARATOR + get Current Operation Date Message ( ) ) ; writer . new Line ( ) ; writer . write ( command Builder . to String ( ) ) ; writer . new Line ( ) ; writer . new Line ( ) ; writer . flush ( ) ; } catch (  IOException ioe ) { err Println (  ERR_ DSCFG_ ERROR_ WRITING_ EQUIVALENT_ COMMAND_ LINE . get ( file , ioe ) ) ; } finally { close Silently ( writer ) ; } } }
public void remove On Central Position Changed Listener (  On Central Position Changed Listener listener ) { m On Central Position Changed Listeners . remove ( listener ) ; }
public static  Object invoke Static (  Class clazz ,  String method Name ,  Class [ ] types ,  Object [ ] values ) throws  No Such Method Exception { try {  Method method = clazz . get Method ( method Name , types ) ;  Object result = method . invoke ( null , values ) ; return result ; } catch (  Illegal Access Exception e ) { throw new  No Such Method Exception ( method Name + _ STR ) ; } catch (  Invocation Target Exception e ) { throw new  Internal Error ( e . get Message ( ) ) ; } }
public static _ Fields find By Thrift Id ( int field Id ) { switch ( field Id ) { case _ NUM : return  NOTE_ ID ; case _ NUM : return  PARAGRAPH_ ID ; case _ NUM : return  RESOURCE_ NAME ; default : return null ; } }
private void transmit (  Packet packet ) throws  Network Exception { byte [ ] data = packet . m Data ; if ( packet . m Offset > _ NUM ) {  System . arraycopy ( data , packet . m Offset , data = new byte [ packet . m Length ] , _ NUM , packet . m Length ) ; } stats . num Bytes += packet . m Length ; stats . num Packets ++ ; if ( data == null ) { return ; } datagram Connection . send ( remote Address , remote Port , data ) ;  Rtp Source s = rtcp Session . get My Source ( ) ; s . active Sender = _ BOOL ; rtcp Session . time Of Last RTPSent = rtcp Session . current Time ( ) ; rtcp Session . packet Count ++ ; rtcp Session . octet Count += data . length ; }
private static  String fix Get Fields (  String js ) { final  Pattern pat =  Pattern . compile ( _ STR ) ; final  Matcher mat = pat . matcher ( js ) ; while ( mat . find ( ) ) { final  String s = mat . group ( ) ; js = js . replace ( s , s . char At ( _ NUM ) + _ STR ) ; } js = js . replace ( _ STR , _ STR ) ; return js ; }
private boolean scan ( ) { if ( bt Adapter . start Le Scan ( m Callback ) ) { m Scanning = _ BOOL ;  Log . i (  TAG , _ STR ) ; if ( m Handler . post Delayed ( scan Timeout Callback , scan Timeout * _ NUM ) ) {  Log . i (  TAG ,  String . format ( _ STR , scan Timeout ) ) ; } else {  Log . e (  TAG , _ STR ) ; } return _ BOOL ; } else {  Log . i (  TAG , _ STR ) ; return _ BOOL ; } }
public void clear (  Faces Context faces Context ,  Map <  String ,  Object > view Map ) { if (  LOGGER . is Loggable (  Level .  FINEST ) ) {  LOGGER . log (  Level .  FINEST , _ STR , view Map ) ; } if ( context Manager != null ) { context Manager . clear ( faces Context , view Map ) ; } destroy Beans ( faces Context , view Map ) ; }
public  Set <  URI > check For Active User Mapping Using Group (  String domain ,  String label ) {  Set <  URI > tenants Using User Group = null ;  Map <  URI ,  List <  User Mapping > > mappings = get All User Mappings For Domain ( domain ) ; if (  Collection Utils . is Empty ( mappings ) ) { _log . debug ( _ STR , domain ) ; return tenants Using User Group ; } tenants Using User Group = new  Hash Set <  URI > ( ) ; for (  Map .  Entry <  URI ,  List <  Base Permissions Helper .  User Mapping > > entry : mappings . entry Set ( ) ) { if (  Collection Utils . is Empty ( entry . get Value ( ) ) ) { continue ; } for (  User Mapping user Mapping : entry . get Value ( ) ) { if ( user Mapping == null ||  Collection Utils . is Empty ( user Mapping . get Groups ( ) ) ) { continue ; } for (  String group : user Mapping . get Groups ( ) ) { if (  String Utils . is Not Blank ( group ) && group . equals Ignore Case ( label ) ) { tenants Using User Group . add ( entry . get Key ( ) ) ; } } } } return tenants Using User Group ; }
public  Process ( final  URL url ) throws  IOException ,  XMLException { init Context ( ) ;  Reader in = new  Input Stream Reader (  Web Service Tools . open Stream From URL ( url ) , get Encoding ( null ) ) ; read Process ( in ) ; in . close ( ) ; }
@  Override public boolean accepts URL (  String url ) { if ( url != null ) { if ( url . starts With (  Constants .  START_ URL ) ) { return _ BOOL ; } else if ( url . equals (  DEFAULT_ URL ) ) { return  DEFAULT_ CONNECTION . get ( ) != null ; } } return _ BOOL ; }
protected  String url ( int zoom Level , int x Tile , int y Tile ) {  String Builder sb = new  String Builder ( _url ) ; sb . append ( _ STR ) ; sb . append ( zoom Level ) ; sb . append ( _ STR ) ; sb . append ( x Tile ) ; sb . append ( _ STR ) ; sb . append ( y Tile ) ; sb . append ( _ STR ) ; return sb . to String ( ) ; }
private static  String convert Class2 Parameter Name (  Class input Type ) {  String class Name = input Type . get Name ( ) ;  String name = class Name . substring ( class Name . last Index Of ( _ STR ) + _ NUM ) ;  String Buffer result = new  String Buffer ( ) ; for ( int i = _ NUM ; i < name . length ( ) ; i ++ ) { char current = name . char At ( i ) ; if (  Character . is Upper Case ( current ) ) { result . append ( _ STR +  Character . to Lower Case ( current ) ) ; } else { result . append ( current ) ; } } return _ STR + result . to String ( ) ; }
static int derive ARGB (  Color color1 ,  Color color2 , float mid Point ) { int r = color1 . get Red ( ) +  Math . round ( ( color2 . get Red ( ) - color1 . get Red ( ) ) * mid Point ) ; int g = color1 . get Green ( ) +  Math . round ( ( color2 . get Green ( ) - color1 . get Green ( ) ) * mid Point ) ; int b = color1 . get Blue ( ) +  Math . round ( ( color2 . get Blue ( ) - color1 . get Blue ( ) ) * mid Point ) ; int a = color1 . get Alpha ( ) +  Math . round ( ( color2 . get Alpha ( ) - color1 . get Alpha ( ) ) * mid Point ) ; return ( ( a & _ NUM ) << _ NUM ) | ( ( r & _ NUM ) << _ NUM ) | ( ( g & _ NUM ) << _ NUM ) | ( b & _ NUM ) ; }
public static void activate System Style ( ) { try {  UIManager . set Look And Feel (  UIManager . get System Look And Feel Class Name ( ) ) ; } catch (  Exception e ) { e . print Stack Trace ( ) ; }  JFrame . set Default Look And Feel Decorated ( _ BOOL ) ; }
public static  Buffered Image to Buffered Image (  Image img ) { if ( img instanceof  Buffered Image ) { return (  Buffered Image ) img ; }  Buffered Image bimage = new  Buffered Image ( img . get Width ( null ) , img . get Height ( null ) ,  Buffered Image .  TYPE_ INT_ ARGB ) ;  Graphics2 D b Gr = bimage . create Graphics ( ) ; b Gr . draw Image ( img , _ NUM , _ NUM , null ) ; b Gr . dispose ( ) ; return bimage ; }
public boolean is Useful (  Result current ,  Linked List <  Result > other Results , int criterion ,  Example Set example Set , int min_model_number ) { boolean result = _ BOOL ; switch ( criterion ) { case  Iterating GSS .  TYPE_ WORST_ UTILITY : double worst Utility = current . get Utility ( ) - current . get Confidence ( ) ; if ( worst Utility < this . min_utility_useful ) { result = _ BOOL ; } else { result = _ BOOL ; } break ; case  Iterating GSS .  TYPE_ UTILITY : double utility = current . get Utility ( ) ; if ( utility < this . min_utility_useful ) { result = _ BOOL ; } else { result = _ BOOL ; } break ; case  Iterating GSS .  TYPE_ BEST_ UTILITY : double best Utility = current . get Utility ( ) + current . get Confidence ( ) ; if ( best Utility < this . min_utility_useful ) { result = _ BOOL ; } else { result = _ BOOL ; } break ; case  Iterating GSS .  TYPE_ EXAMPLE : if ( other Results . size ( ) == _ NUM || other Results . size ( ) < min_model_number ) { return _ BOOL ; } double sum = _ NUM ;  Iterator it = other Results . iterator ( ) ; while ( it . has Next ( ) ) {  Result r = (  Result ) it . next ( ) ; sum = sum + r . get Total Weight ( ) ; } double average = sum / other Results . size ( ) ; if ( current . get Total Weight ( ) < this . example Factor * average ) { result = _ BOOL ; } else { result = _ BOOL ; } break ; } return result ; }
public void add Sensor Selection Listener ( final  Sensor Selection Listener listener ) { listener List . add (  Sensor Selection Listener . class , listener ) ; }
public void write ( char c ) throws  IOException { if ( _output == null ) throw new  IOException ( _ STR ) ; _output . append ( c ) ; }
public void unregister (  Grid Cache Ttl Manager mgr ) { synchronized ( mux ) { mgrs . remove ( mgr ) ; if ( mgrs . is Empty ( ) ) stop Cleanup Worker ( ) ; } }
public void close ( ) { if (  Debug . message Enabled ( ) ) {  Debug . message ( log Name + _ STR ) ; } flush ( ) ; try { if ( writer != null ) { writer . close ( ) ; } } catch (  IOException ioe ) {  Debug . error ( log Name + _ STR , ioe ) ; } if ( sign Task != null ) { stop Periodic Log Signer ( ) ; if (  Debug . message Enabled ( ) ) {  Debug . message ( log Name + _ STR ) ; } } if ( lv != null ) { lv . stop Log Verifier ( ) ; if (  Debug . message Enabled ( ) ) {  Debug . message ( log Name + _ STR ) ; } } }
@  Override protected  Image platform Image Bytes To Image ( byte [ ] bytes , long format ) throws  IOException {  String mime Type = null ; if ( format ==  CF_ PNG ) { mime Type = _ STR ; } else if ( format ==  CF_ JFIF ) { mime Type = _ STR ; } if ( mime Type != null ) { return standard Image Bytes To Image ( bytes , mime Type ) ; } int [ ] image Data = platform Image Bytes To Image Data ( bytes , format ) ; if ( image Data == null ) { throw new  IOException ( _ STR ) ; } int len = image Data . length - _ NUM ; int width = image Data [ len ] ; int height = image Data [ len + _ NUM ] ;  Data Buffer Int buffer = new  Data Buffer Int ( image Data , len ) ;  Writable Raster raster =  Raster . create Packed Raster ( buffer , width , height , width , bandmasks , null ) ; return new  Buffered Image ( direct Color Model , raster , _ BOOL , null ) ; }
public static  String clean Stacking Markers (  String filename ) { if ( !  String Utils . is Empty ( filename ) ) {  Matcher m = stacking Pattern1 . matcher ( filename ) ; if ( m . matches ( ) ) { return m . group ( _ NUM ) + m . group ( _ NUM ) ; } m = stacking Pattern2 . matcher ( filename ) ; if ( m . matches ( ) ) { return m . group ( _ NUM ) + m . group ( _ NUM ) ; } m = stacking Pattern3 . matcher ( filename ) ; if ( m . matches ( ) ) { return m . group ( _ NUM ) + m . group ( _ NUM ) ; } m = stacking Pattern4 . matcher ( filename ) ; if ( m . matches ( ) ) { return m . group ( _ NUM ) + m . group ( _ NUM ) ; } } return filename ; }
private void send Discarded (  Service Registrar reg ,  String [ ] cur Groups ) {  Service ID srvc ID = reg . get Service ID ( ) ; if ( cur Groups == null ) {  Unicast Response resp = (  Unicast Response ) registrars . get ( srvc ID ) ; if ( resp == null ) return ; cur Groups = resp . get Groups ( ) ; } if ( registrars . remove ( srvc ID ) != null ) { reg Info . remove ( srvc ID ) ; if ( ! listeners . is Empty ( ) ) { add Notify ( (  Array List ) listeners . clone ( ) , map Reg To Groups ( reg , cur Groups ) ,  DISCARDED ) ; } } }
private int parse Fuzziness (  State state ) { char slop Text [ ] = new char [ state . length ] ; int slop Length = _ NUM ; if ( state . data [ state . index ] == _ STR ) { while ( state . index < state . length ) { state . index ++ ; if ( state . index < state . length ) { if ( token Finished ( state ) ) { break ; } slop Text [ slop Length ] = state . data [ state . index ] ; slop Length ++ ; } } int fuzziness = _ NUM ; try { fuzziness =  Integer . parse Int ( new  String ( slop Text , _ NUM , slop Length ) ) ; } catch (  Number Format Exception e ) { } if ( fuzziness < _ NUM ) { fuzziness = _ NUM ; } return fuzziness ; } return _ NUM ; }
public static  String replace Strings (  String properties ,  String property ,  String value ) {  String Builder sb = new  String Builder ( ) ; int start = _ NUM ; int index = properties . index Of ( property ) ; while ( index != - _ NUM ) { sb . append ( properties . substring ( start , index ) ) ; sb . append ( value ) ; start = index + property . length ( ) ; index = properties . index Of ( property , start ) ; } sb . append ( properties . substring ( start ) ) ; return sb . to String ( ) ; }
public void save ( ) throws  File Not Found Exception {  Print Stream p = new  Print Stream ( file ) ; p . println (  COMMENT_ PREFIX + _ STR ) ; for (  Pair <  String ,  Array List <  String > > settings : store ) { p . println ( settings . first ) ; for (  String str : settings . second ) { p . println ( str ) ; } p . println ( ) ; } p . close ( ) ; }
@  Override public int hash Code ( ) { int result = bucket Name . hash Code ( ) ; result = _ NUM * result + name . hash Code ( ) ; result = _ NUM * result + created Time . hash Code ( ) ; result = _ NUM * result + ( int ) ( length ^ ( length > > > _ NUM ) ) ; result = _ NUM * result + etag . hash Code ( ) ; result = _ NUM * result + content Type . hash Code ( ) ; return result ; }
@  Override public void end DTD (  Augmentations augs ) throws  XNIException { f In DTD = _ BOOL ; try { if ( f Lexical Handler != null ) { f Lexical Handler . end DTD ( ) ; } } catch (  SAXException e ) { throw new  XNIException ( e ) ; } if ( f Declared Attrs != null ) { f Declared Attrs . clear ( ) ; } }
public static boolean rollback ( boolean throw Exception ,  String trx Name ) throws  SQLException { try {  Connection conn = null ;  Trx trx = trx Name == null ? null :  Trx . get ( trx Name , _ BOOL ) ; if ( trx != null ) return trx . rollback ( _ BOOL ) ; else conn =  DB . get Connection RW ( ) ; if ( conn != null && ! conn . get Auto Commit ( ) ) conn . rollback ( ) ; } catch (  SQLException e ) { log . log (  Level .  SEVERE , _ STR + trx Name + _ STR , e ) ; if ( throw Exception ) throw e ; return _ BOOL ; } return _ BOOL ; }
private  Map <  String ,  String > check IPVersion (  String range ) {  Map <  String ,  String > details = new  Hash Map <  String ,  String > ( _ NUM ) ;  String Tokenizer st ;  String ip Start , ip End ; if ( range . contains ( _ STR ) ) { debug . message ( _ STR ) ; st = new  String Tokenizer ( range , _ STR ) ; if ( st . count Tokens ( ) != _ NUM ) { throw new  Illegal Argument Exception ( range + _ STR ) ; } ip Start = st . next Token ( ) ; ip End = st . next Token ( ) ; if (  Validate IPaddress . is IPv4 ( ip Start ) &&  Validate IPaddress . is IPv4 ( ip End ) ) { details . put (  IP_ Version ,  IP_ V4 ) ; details . put (  IP_ TYPE , _ STR ) ; } else if (  Validate IPaddress . is IPv6 ( ip Start ) &&  Validate IPaddress . is IPv6 ( ip End ) ) { details . put (  IP_ Version ,  IP_ V6 ) ; details . put (  IP_ TYPE , _ STR ) ; details . put (  IP_ START , ip Start ) ; details . put (  IP_ END , ip End ) ; } else { throw new  Illegal Argument Exception ( range + _ STR ) ; } } else if ( range . contains ( _ STR ) ) { debug . message ( _ STR ) ;  String cidr ; st = new  String Tokenizer ( range , _ STR ) ; if ( st . count Tokens ( ) != _ NUM ) { throw new  Illegal Argument Exception ( _ STR ) ; } ip Start = st . next Token ( ) ; cidr = st . next Token ( ) ; if (  Validate IPaddress . is IPv4 ( ip Start ) && (  Integer . parse Int ( cidr ) >= _ NUM ) && (  Integer . parse Int ( cidr ) <= _ NUM ) ) { details . put (  IP_ Version ,  IP_ V4 ) ; details . put (  IP_ TYPE , _ STR ) ; } else if (  Validate IPaddress . is IPv6 ( ip Start ) && (  Integer . parse Int ( cidr ) >= _ NUM ) && (  Integer . parse Int ( cidr ) <= _ NUM ) ) { details . put (  IP_ Version ,  IP_ V6 ) ; details . put (  IP_ TYPE , _ STR ) ; } else { throw new  Illegal Argument Exception ( ip Start + _ STR ) ; } } else { debug . message ( _ STR ) ; if (  Validate IPaddress . is IPv4 ( range ) ) { details . put (  IP_ Version ,  IP_ V4 ) ; details . put (  IP_ TYPE , _ STR ) ; } else if (  Validate IPaddress . is IPv6 ( range ) ) { details . put (  IP_ Version ,  IP_ V6 ) ; details . put (  IP_ TYPE , _ STR ) ; } else { throw new  Illegal Argument Exception ( range + _ STR ) ; } } return details ; }
public static boolean has Mime Type (  String mime Type ) { if ( mime Type == null || mime Type . is Empty ( ) ) { return _ BOOL ; } return mime Type To Extension Map . contains Key ( mime Type ) ; }
private  String replace Meta Chars (  String input ) {  String result = input . replace All ( _ STR , _ STR ) ; result = result . replace All (  Pattern . quote ( _ STR ) , _ STR ) ; result = result . replace All (  Pattern . quote ( _ STR ) , _ STR ) ; result = result . replace All (  Pattern . quote ( _ STR ) , _ STR ) ; result = result . replace All (  Pattern . quote ( _ STR ) , _ STR ) ; result = result . replace All (  Pattern . quote ( _ STR ) , _ STR ) ; result = result . replace All (  Pattern . quote ( _ STR ) , _ STR ) ; result = result . replace All (  Pattern . quote ( _ STR ) , _ STR ) ; result = result . replace All (  Pattern . quote ( _ STR ) , _ STR ) ; result = result . replace All (  Pattern . quote ( _ STR ) , _ STR ) ; result = result . replace All (  Pattern . quote ( _ STR ) , _ STR ) ; result = result . replace All (  Pattern . quote ( _ STR ) , _ STR ) ; result = result . replace All (  Pattern . quote ( _ STR ) , _ STR ) ; result = result . replace All (  Pattern . quote ( _ STR ) , _ STR ) ; result = result . replace All (  Pattern . quote ( _ STR ) , _ STR ) ; return result ; }
public static  String encode (  String s ,  String allow ) { if ( s == null ) { return null ; }  String Builder encoded = null ; int old Length = s . length ( ) ; int current = _ NUM ; while ( current < old Length ) { int next To Encode = current ; while ( next To Encode < old Length && is Allowed ( s . char At ( next To Encode ) , allow ) ) { next To Encode ++ ; } if ( next To Encode == old Length ) { if ( current == _ NUM ) { return s ; } else { encoded . append ( s , current , old Length ) ; return encoded . to String ( ) ; } } if ( encoded == null ) { encoded = new  String Builder ( ) ; } if ( next To Encode > current ) { encoded . append ( s , current , next To Encode ) ; } else { } current = next To Encode ; int next Allowed = current + _ NUM ; while ( next Allowed < old Length && ! is Allowed ( s . char At ( next Allowed ) , allow ) ) { next Allowed ++ ; }  String to Encode = s . substring ( current , next Allowed ) ; try { byte [ ] bytes = to Encode . get Bytes (  DEFAULT_ ENCODING ) ; int bytes Length = bytes . length ; for ( int i = _ NUM ; i < bytes Length ; i ++ ) { encoded . append ( _ STR ) ; encoded . append (  HEX_ DIGITS [ ( bytes [ i ] & _ NUM ) > > _ NUM ] ) ; encoded . append (  HEX_ DIGITS [ bytes [ i ] & _ NUM ] ) ; } } catch (  Unsupported Encoding Exception e ) { throw new  Assertion Error ( e ) ; } current = next Allowed ; } return encoded == null ? s : encoded . to String ( ) ; }
final public void print ( float v ) {  Writer out = this . out ; if ( out == null ) return ; try {  String s =  String . value Of ( v ) ; out . write ( s , _ NUM , s . length ( ) ) ; } catch (  IOException e ) { log . log (  Level .  FINE , e . to String ( ) , e ) ; } }
@  Override public  String to String ( ) {  String Buffer result ; if ( m_ Model == null ) { result = new  String Buffer ( _ STR ) ; } else { result = new  String Buffer ( ) ; result . append ( _ STR ) ; result . append ( _ STR ) ; result . append ( _ STR + get Model File ( ) + _ STR ) ; result . append ( m_ Model . to String ( ) ) ; } return result . to String ( ) ; }
public static boolean check Chroot Path (  String zk Host , boolean create ) throws  Keeper Exception ,  Interrupted Exception { if ( !  Solr Zk Client . contains Chroot ( zk Host ) ) { return _ BOOL ; } log . trace ( _ STR ) ;  String chroot Path = zk Host . substring ( zk Host . index Of ( _ STR ) , zk Host . length ( ) ) ;  Solr Zk Client tmp Client = new  Solr Zk Client ( zk Host . substring ( _ NUM , zk Host . index Of ( _ STR ) ) , _ NUM , _ NUM , null , null , null ) ; boolean exists = tmp Client . exists ( chroot Path , _ BOOL ) ; if ( ! exists && create ) { tmp Client . make Path ( chroot Path , _ BOOL , _ BOOL ) ; exists = _ BOOL ; } tmp Client . close ( ) ; return exists ; }
protected  Integer column Index (  Map <  String ,  Integer > load Col Idxs ,  String db Name ) {  Integer col Idx = load Col Idxs . get ( db Name . to Upper Case ( ) ) ; if ( col Idx == null ) throw new  Illegal State Exception ( _ STR + db Name ) ; return col Idx ; }
public int hash Code ( ) { int result = _ NUM ; if ( is Destroyed ( ) ) { return result ; } result = result * _ NUM +  Arrays . hash Code ( get Encoded ( ) ) ; result = result * _ NUM + end Time . hash Code ( ) ; result = result * _ NUM + client . hash Code ( ) ; result = result * _ NUM + server . hash Code ( ) ; result = result * _ NUM + session Key . hash Code ( ) ; if ( auth Time != null ) { result = result * _ NUM + auth Time . hash Code ( ) ; } if ( start Time != null ) { result = result * _ NUM + start Time . hash Code ( ) ; } if ( renew Till != null ) { result = result * _ NUM + renew Till . hash Code ( ) ; } result = result * _ NUM +  Arrays . hash Code ( client Addresses ) ; return result * _ NUM +  Arrays . hash Code ( flags ) ; }
public static  Print Data parse XML (  Properties ctx ,  File input ) { log . config ( input . to String ( ) ) ;  Print Data pd = null ; try {  Print Data Handler handler = new  Print Data Handler ( ctx ) ;  SAXParser Factory factory =  SAXParser Factory . new Instance ( ) ;  SAXParser parser = factory . new SAXParser ( ) ; parser . parse ( input , handler ) ; pd = handler . get Print Data ( ) ; } catch (  Exception e ) { log . log (  Level .  SEVERE , _ STR , e ) ; } return pd ; }
void notify Failure (  Throwable exception ) { synchronized ( wait Object ) { is Complete = _ BOOL ; if ( exception instanceof  Mqtt Exception ) { pending Exception = (  Mqtt Exception ) exception ; } else { pending Exception = new  Mqtt Exception ( exception ) ; } wait Object . notify All ( ) ; if ( exception instanceof  Mqtt Exception ) { last Exception = (  Mqtt Exception ) exception ; } if ( listener != null ) { listener . on Failure ( this , exception ) ; } } }
@  Override public boolean contains (  String identifier ) { return blacklist . contains ( identifier ) ; }
static private  String  SHORT_ Max ( ) { short temp Value =  Short .  MAX_ VALUE ; return  String . value Of ( temp Value ) ; }
public static  String make Compliant Name (  String value ) { value = value . replace ( _ STR , _ STR ) ; value = value . replace ( _ STR , _ STR ) ; value = value . replace ( _ STR , _ STR ) ; value = value . replace ( _ STR , _ STR ) ; value = value . replace ( _ STR , _ STR ) ; if ( value . length ( ) < _ NUM ) { value = _ STR ; } return value ; }
public  Storage Unit Entity create Database Entities For Business Object Data Ddl Testing (  String partition Value ,  String s3 Key Prefix ) {  List <  Schema Column > schema Columns = new  Array List < > ( ) ; schema Columns . add ( new  Schema Column (  Abstract Service Test .  FIRST_ PARTITION_ COLUMN_ NAME , _ STR ,  Abstract Service Test .  NO_ COLUMN_ SIZE ,  Abstract Service Test .  COLUMN_ REQUIRED ,  Abstract Service Test .  NO_ COLUMN_ DEFAULT_ VALUE ,  Abstract Service Test .  NO_ COLUMN_ DESCRIPTION ) ) ; schema Columns . add ( new  Schema Column (  Abstract Service Test .  COLUMN_ NAME , _ STR ,  Abstract Service Test .  COLUMN_ SIZE ,  Abstract Service Test .  NO_ COLUMN_ REQUIRED ,  Abstract Service Test .  COLUMN_ DEFAULT_ VALUE ,  Abstract Service Test .  COLUMN_ DESCRIPTION ) ) ;  List <  Schema Column > partition Columns = schema Columns . sub List ( _ NUM , _ NUM ) ;  Business Object Format Entity business Object Format Entity = business Object Format Dao Test Helper . create Business Object Format Entity (  Abstract Service Test .  NAMESPACE ,  Abstract Service Test .  BDEF_ NAME ,  Abstract Service Test .  FORMAT_ USAGE_ CODE ,  File Type Entity .  TXT_ FILE_ TYPE ,  Abstract Service Test .  FORMAT_ VERSION ,  Abstract Service Test .  FORMAT_ DESCRIPTION ,  Abstract Service Test .  LATEST_ VERSION_ FLAG_ SET ,  Abstract Service Test .  FIRST_ PARTITION_ COLUMN_ NAME ,  Abstract Service Test .  NO_ PARTITION_ KEY_ GROUP ,  Abstract Service Test .  NO_ ATTRIBUTES ,  Abstract Service Test .  SCHEMA_ DELIMITER_ PIPE ,  Abstract Service Test .  SCHEMA_ ESCAPE_ CHARACTER_ BACKSLASH ,  Abstract Service Test .  SCHEMA_ NULL_ VALUE_ BACKSLASH_ N , schema Columns , partition Columns ) ; if ( partition Value != null ) {  Business Object Data Entity business Object Data Entity = business Object Data Dao Test Helper . create Business Object Data Entity ( business Object Format Entity , partition Value ,  Abstract Service Test .  NO_ SUBPARTITION_ VALUES ,  Abstract Service Test .  DATA_ VERSION ,  Abstract Service Test .  LATEST_ VERSION_ FLAG_ SET ,  Business Object Data Status Entity .  VALID ) ;  Storage Entity storage Entity = storage Dao Test Helper . create Storage Entity (  Abstract Service Test .  STORAGE_ NAME ,  Storage Platform Entity .  S3 ,  Arrays . as List ( new  Attribute ( configuration Helper . get Property (  Configuration Value .  S3_ ATTRIBUTE_ NAME_ BUCKET_ NAME ) ,  Abstract Service Test .  S3_ BUCKET_ NAME ) , new  Attribute ( configuration Helper . get Property (  Configuration Value .  S3_ ATTRIBUTE_ NAME_ KEY_ PREFIX_ VELOCITY_ TEMPLATE ) ,  Abstract Service Test .  S3_ KEY_ PREFIX_ VELOCITY_ TEMPLATE ) ) ) ; return storage Unit Dao Test Helper . create Storage Unit Entity ( storage Entity , business Object Data Entity ,  Storage Unit Status Entity .  ENABLED , s3 Key Prefix ) ; } return null ; }
private  PDFObject read Array ( int obj Num , int obj Gen ,  PDFDecrypter decrypter ) throws  IOException {  Array List <  PDFObject > ary = new  Array List <  PDFObject > ( ) ;  PDFObject obj ; while ( ( obj = read Object ( obj Num , obj Gen , decrypter ) ) != null ) { ary . add ( obj ) ; } if ( buf . get ( ) != _ STR ) { throw new  PDFParse Exception ( _ STR ) ; }  PDFObject [ ] objlist = new  PDFObject [ ary . size ( ) ] ; for ( int i = _ NUM ; i < objlist . length ; i ++ ) { objlist [ i ] = (  PDFObject ) ary . get ( i ) ; } return new  PDFObject ( this ,  PDFObject .  ARRAY , objlist ) ; }
static  Map add Map To Map (  Map map To Add ,  Map to Map ) { if ( ( map To Add != null ) && ( to Map != null ) ) {  Set key Set = map To Add . key Set ( ) ;  Iterator key Iter = key Set . iterator ( ) ; while ( key Iter . has Next ( ) ) {  String key = (  String ) key Iter . next ( ) ;  Set values = (  Set ) map To Add . get ( key ) ; add Element To Map ( key , values , to Map ) ; } } return to Map ; }
public void dump Created Resource Bundles (  String location ) {  Hashtable bundle Hash = get Create Hash ( ) ; for (  Enumeration enumeration = bundle Hash . keys ( ) ; enumeration . has More Elements ( ) ; ) {  String key = (  String ) enumeration . next Element ( ) ;  Properties props = (  Properties ) bundle Hash . get ( key ) ; try {  File prop File = new  File ( location + _ STR + key ) ;  File parent Dir = new  File ( prop File . get Parent ( ) ) ; parent Dir . mkdirs ( ) ; prop File . create New File ( ) ;  File Output Stream fos = new  File Output Stream ( prop File ) ; props . store ( fos , _ STR ) ; fos . close ( ) ; } catch (  File Not Found Exception fnfe ) { fnfe . print Stack Trace ( ) ; } catch (  IOException e ) { e . print Stack Trace ( ) ; } } }
private void print Properties (  Properties properties ) throws  IOException {  String Writer string Buffer = new  String Writer ( ) ;  Buffered Reader reader = null ; properties . store ( string Buffer , null ) ; try { reader = new  Buffered Reader ( new  String Reader ( string Buffer . to String ( ) ) ) ; reader . read Line ( ) ;  String line = null ; while ( ( line = reader . read Line ( ) ) != null ) { writer . print ( _ STR ) ; writer . println ( line ) ; } } finally { if ( reader != null ) { reader . close ( ) ; } } }
public  Packet Output Stream write Time Length ( final  Calendar calendar , final boolean fractional Seconds ) { if ( fractional Seconds ) { assure Buffer Capacity ( _ NUM ) ; buffer . put ( ( byte ) _ NUM ) ; buffer . put ( ( byte ) _ NUM ) ; buffer . put Int ( _ NUM ) ; buffer . put ( ( byte ) calendar . get (  Calendar .  HOUR_ OF_ DAY ) ) ; buffer . put ( ( byte ) calendar . get (  Calendar .  MINUTE ) ) ; buffer . put ( ( byte ) calendar . get (  Calendar .  SECOND ) ) ; buffer . put Int ( calendar . get (  Calendar .  MILLISECOND ) * _ NUM ) ; } else { assure Buffer Capacity ( _ NUM ) ; buffer . put ( ( byte ) _ NUM ) ; buffer . put ( ( byte ) _ NUM ) ; buffer . put Int ( _ NUM ) ; buffer . put ( ( byte ) calendar . get (  Calendar .  HOUR_ OF_ DAY ) ) ; buffer . put ( ( byte ) calendar . get (  Calendar .  MINUTE ) ) ; buffer . put ( ( byte ) calendar . get (  Calendar .  SECOND ) ) ; } return this ; }
public static  String encode XML (  String text ) { if ( text == null ) { return null ; } final  String Builder result = new  String Builder ( ) ; final  String Character Iterator iterator = new  String Character Iterator ( text ) ; char character = iterator . current ( ) ; while ( character !=  Character Iterator .  DONE ) { if ( character == _ STR ) { result . append ( _ STR ) ; } else if ( character == _ STR ) { result . append ( _ STR ) ; } else if ( character == _ STR ) { result . append ( _ STR ) ; } else if ( character == _ STR ) { result . append ( _ STR ) ; } else if ( character == _ STR ) { result . append ( _ STR ) ; } else { result . append ( character ) ; } character = iterator . next ( ) ; } return result . to String ( ) ; }
public static  Print Writer open Print Writer To File (  File file , boolean verbose ) throws  Ade Usage Exception { try { if ( verbose ) { logger . info ( _ STR + file . get Path ( ) ) ; } return new  Print Writer ( file ,  FILE_ ENCODING ) ; } catch (  File Not Found Exception e ) { throw new  Ade Usage Exception ( _ STR + file . get Path ( ) , e ) ; } catch (  Unsupported Encoding Exception e ) { throw new  Ade Usage Exception ( _ STR +  FILE_ ENCODING , e ) ; } }
public  Shape create Arrow Right ( final double x , final double y , final double w , final double h ) { path . reset ( ) ; path . move To ( x , y ) ; path . line To ( x + w , y + h / _ NUM ) ; path . line To ( x , y + h ) ; path . close Path ( ) ; return path ; }
synchronized void do Connect (  Inet Address address , int port , int timeout ) throws  IOException { synchronized ( fd Lock ) { if ( ! close Pending && ( socket == null || ! socket . is Bound ( ) ) ) {  Net Hooks . before Tcp Connect ( fd , address , port ) ; } } try { acquire FD ( ) ; try { socket Connect ( address , port , timeout ) ; synchronized ( fd Lock ) { if ( close Pending ) { throw new  Socket Exception ( _ STR ) ; } } if ( socket != null ) { socket . set Bound ( ) ; socket . set Connected ( ) ; } } finally { release FD ( ) ; } } catch (  IOException e ) { close ( ) ; throw e ; } }
protected void copy Selected Bean ( ) { if (  Debug . debugging ( _ STR ) )  Debug . output ( _ STR ) ; if ( selected Bean == null || selected Bean Location == null ) { clear Selection ( ) ; if (  Debug . debugging ( _ STR ) )  Debug . output ( _ STR + selected Bean ) ; if (  Debug . debugging ( _ STR ) )  Debug . output ( _ STR + selected Bean Location ) ; return ; } try { ser Bean = new  Byte Array Output Stream ( ) ;  Object Output Stream oos = new  Object Output Stream ( ser Bean ) ; oos . write Object ( selected Bean ) ; } catch (  Exception e ) { e . print Stack Trace ( ) ; clear Selection ( ) ; if (  Debug . debugging ( _ STR ) )  Debug . output ( _ STR ) ; return ; } cut Bean = null ; if (  Debug . debugging ( _ STR ) )  Debug . output ( _ STR ) ; }
public void component Hidden ( final  Component Event e ) { final  Object source = e . get Source ( ) ; if ( ! ( source instanceof  JMenu Item ) ) return ; set Child Visible ( (  JMenu Item ) source , _ BOOL ) ; }
private void can Edit Check ( ) { can Edit = ! profile . is Common Profile ( ) ; if ( ! can Edit ) { add Button . set Enabled ( _ BOOL ) ; remove Button . set Enabled ( _ BOOL ) ; } }
private  File [ ] list Files (  File file ) {  File [ ] children = null ; if ( file . is Directory ( ) ) { children = file Filter == null ? file . list Files ( ) : file . list Files ( file Filter ) ; } if ( children == null ) { children =  File Utils .  EMPTY_ FILE_ ARRAY ; } if ( comparator != null && children . length > _ NUM ) {  Arrays . sort ( children , comparator ) ; } return children ; }
public static  String player Id To Name (  UUID uuid ) { long least Sig Bits = uuid . get Least Significant Bits ( ) ; long most Sig Bits = uuid . get Most Significant Bits ( ) ; byte [ ] bytes = to Array ( most Sig Bits , least Sig Bits ) ; bytes = remove Zeroes At End ( bytes ) ; return new  String ( bytes ,  Standard Charsets .  UTF_8 ) ; }
public  Component create Edit Component (  Value Property value Property ) {  Component component ; switch ( type ) { case  DATATYPE : component = create Datatype Field (  Datatypes . get NN ( java Class ) , value Property ) ; break ; case  ENTITY : component = create Entity Lookup ( value Property ) ; break ; case  UNARY : component = create Unary Field ( value Property ) ; break ; case  ENUM : component = create Enum Lookup ( value Property ) ; break ; case  RUNTIME_ ENUM : component = create Runtime Enum Lookup ( value Property ) ; break ; default : throw new  Unsupported Operation Exception ( _ STR + type ) ; } this . edit Component = component ; return component ; }
public  String to String ( ) { if ( cert Policies == null ) { return _ STR ; }  String Builder sb = new  String Builder ( super . to String ( ) ) ; sb . append ( _ STR ) ; for (  Policy Information info : cert Policies ) { sb . append ( info . to String ( ) ) ; } sb . append ( _ STR ) ; return sb . to String ( ) ; }
protected void request Result (  Request Type type ,  String url ,  String result , int response Code ,  String error ,  String encoding ) { int length = - _ NUM ; if ( result != null ) { length = result . length ( ) ; }  String encoding Text = encoding == null ? _ STR : _ STR + encoding ;  LOGGER . info ( _ STR + response Code + _ STR + length + encoding Text + _ STR + url + ( error != null ? _ STR + error + _ STR : _ STR ) ) ;  String stream = remove Request ( url ) ; if ( type ==  Request Type .  STREAM ) { stream Info Manager . request Result ( url , result , response Code , stream ) ; } else if ( type ==  Request Type .  STREAMS ) { stream Info Manager . request Result Streams ( url , result , response Code ) ; } else if ( type ==  Request Type .  EMOTICONS ) { emoticon Manager . emoticons Received ( result , stream ) ; } else if ( type ==  Request Type .  CHAT_ ICONS ) { if ( result == null ) {  LOGGER . warning ( _ STR + result ) ; return ; }  List <  Usericon > icons = parse Chat Icons ( result , stream ) ; if ( icons == null ) {  LOGGER . warning ( _ STR + result ) ; return ; } else { result Listener . received Usericons ( icons ) ; requested Chat Icons . add ( stream ) ; } } else if ( type ==  Request Type .  GLOBAL_ BADGES ) { result Listener . received Usericons ( badge Manager . handle Global Badges Result ( result ) ) ; } else if ( type ==  Request Type .  ROOM_ BADGES ) { result Listener . received Usericons ( badge Manager . handle Room Badges Result ( result , stream ) ) ; } else if ( type ==  Request Type .  CHANNEL || type ==  Request Type .  CHANNEL_ PUT ) { handle Channel Info Result ( type , url , result , response Code , stream ) ; } else if ( type ==  Request Type .  GAME_ SEARCH ) { if ( result == null ) {  LOGGER . warning ( _ STR ) ; return ; }  Set <  String > games = parse Game Search ( result ) ; if ( games == null ) {  LOGGER . warning ( _ STR ) ; return ; } result Listener . game Search Result ( games ) ; } else if ( type ==  Request Type .  FOLLOWERS ) { follower Manager . received ( response Code , stream , result ) ; } else if ( type ==  Request Type .  SUBSCRIBERS ) { subscriber Manager . received ( response Code , stream , result ) ; } else if ( type ==  Request Type .  USERINFO ) {  String display Name = parse Name From User Info ( result ) ; result Listener . received Display Name (  String Util . to Lower Case ( stream ) , display Name ) ; } else if ( type ==  Request Type .  CHAT_ SERVER ) { result Listener . received Server ( stream , parse Server ( result ) ) ; } else if ( type ==  Request Type .  CHAT_ INFO ) { result Listener . received Chat Info (  Chat Info . decode ( stream , result ) ) ; } }
public static int execute Update (  Connection connection ,  String raw Sql Query ,  Object ... parameters ) throws  SQLException {  Prepared Statement stmt = null ; try { stmt = connection . prepare Statement ( raw Sql Query ) ; for ( int index = _ NUM ; index < parameters . length ; index ++ ) {  Jdbc Utils . bind Parameter ( stmt , index + _ NUM , parameters [ index ] ) ; } return stmt . execute Update ( ) ; } finally {  Jdbc Utils . close Statement ( stmt ) ; } }
public  Future <  Sync Reply > send Request ( int xid ,  Sync Message request ) throws  Remote Store Exception { ensure Connected ( ) ;  Remote Sync Future future = new  Remote Sync Future ( xid , connection Generation ) ; future Map . put (  Integer . value Of ( xid ) , future ) ; if ( future Map . size ( ) >  MAX_ PENDING_ REQUESTS ) { synchronized ( future Notify ) { while ( future Map . size ( ) >  MAX_ PENDING_ REQUESTS ) { try { future Notify . wait ( ) ; } catch (  Interrupted Exception e ) { throw new  Remote Store Exception ( _ STR , e ) ; } } } } channel . write ( request ) ; return future ; }
public static boolean is Empty (  String str ) { return str == null || str . length ( ) == _ NUM ; }
public void disable Dependency (  Capability c ) { if ( do Not Check Capabilities ( ) ) { return ; } if ( c ==  Capability .  NOMINAL_ ATTRIBUTES ) { disable Dependency (  Capability .  BINARY_ ATTRIBUTES ) ; } else if ( c ==  Capability .  BINARY_ ATTRIBUTES ) { disable Dependency (  Capability .  UNARY_ ATTRIBUTES ) ; } else if ( c ==  Capability .  UNARY_ ATTRIBUTES ) { disable Dependency (  Capability .  EMPTY_ NOMINAL_ ATTRIBUTES ) ; } else if ( c ==  Capability .  NOMINAL_ CLASS ) { disable Dependency (  Capability .  BINARY_ CLASS ) ; } else if ( c ==  Capability .  BINARY_ CLASS ) { disable Dependency (  Capability .  UNARY_ CLASS ) ; } else if ( c ==  Capability .  UNARY_ CLASS ) { disable Dependency (  Capability .  EMPTY_ NOMINAL_ CLASS ) ; } m_ Dependencies . remove ( c ) ; }
private boolean can Be Placed At Position ( final boolean requires All Bound , final  Group Node Var Binding Info binding Info , final  Hash Set <  IVariable < ? > > known Bound , final  Map <  IVariable < ? > ,  Integer > remaining Maybe Bound , int i ) { final  Set <  IVariable < ? > > left To Be Bound = binding Info . left To Be Bound ( known Bound ) ; if ( left To Be Bound . is Empty ( ) ) { return _ BOOL ; } if ( ! requires All Bound ) { boolean more Can Be Bound = _ BOOL ; final  Set <  IVariable < ? > > can Be Bound = remaining Maybe Bound . key Set ( ) ; for (  IVariable < ? > left To Be Bound Var : left To Be Bound ) { more Can Be Bound |= can Be Bound . contains ( left To Be Bound Var ) ; if ( more Can Be Bound ) { break ; } } if ( ! more Can Be Bound ) { return _ BOOL ; } } return _ BOOL ; }
public  Resources Poet add Drawable (  String name ,  String value ) {  Element bool = document . create Element ( _ STR ) ; bool . set Attribute ( _ STR , name ) ; bool . append Child ( document . create Text Node ( value ) ) ; resource Element . append Child ( bool ) ; return this ; }
public double max ( ) { int size = values . size ( ) ; double max = -  Double .  MAX_ VALUE ; for ( int i = _ NUM ; i < size ; i ++ ) max =  Math . max ( max , values . get ( i ) ) ; return max ; }
private boolean start Compact Mode (  String type ) { long time Passed =  System . current Time Millis ( ) - compact Mode Start ; if ( time Passed >  MAX_ COMPACTMODE_ TIME ) { close Compact Mode ( ) ; } if ( ! type . equals ( compact Mode ) ) { close Compact Mode ( ) ; } if ( compact Mode == null ) { compact Mode = type ; compact Mode Start =  System . current Time Millis ( ) ; compact Mode Length = _ NUM ; return _ BOOL ; } return _ BOOL ; }
protected void handle Or Defer Surprise Connect (  Internal Distributed Member member ) { synchronized ( startup Lock ) { if ( ! processing Events ) { startup Messages . add ( new  Startup Event ( member ) ) ; return ; } } process Surprise Connect ( member ) ; }
public boolean zone Export Masks Delete (  List <  Network Zoning Param > zoning Params ,  Collection <  URI > volume URIs ,  String step Id ) {  Network Zoning Param zoning Param = zoning Params . get ( _ NUM ) ; _log . info (  String . format ( _ STR , zoning Param . get Export Group Display ( ) ) ) ; return do Zone Export Masks Delete ( zoning Params , volume URIs , step Id ) ; }
private void update Pseudo References ( int epoch ) { if ( nbest List Writer != null ) { nbest List Writer . close ( ) ;  Evaluation Metric <  IString ,  String > metric = new  BLEUMetric <  IString ,  String > ( references ) ;  Multi Translation Metric Max <  IString ,  String > search Algorithm = new  Hill Climbing Multi Translation Metric Max <  IString ,  String > ( metric ) ;  NBest List Container <  IString ,  String > nbest Lists = null ; try { nbest Lists = new  Flat NBest List ( nbest Filename , references . size ( ) ) ; } catch (  IOException e ) { e . print Stack Trace ( ) ; logger . error ( _ STR , nbest Filename ) ; throw new  Runtime Exception ( _ STR + nbest Filename ) ; }  List <  Scored Featurized Translation <  IString ,  String > > max Featurized Translations = search Algorithm . maximize ( nbest Lists ) ; assert max Featurized Translations . size ( ) == tune Source . size ( ) : _ STR ; int num Translations = max Featurized Translations . size ( ) ; for ( int i = _ NUM ; i < num Translations ; ++ i ) {  Sequence <  IString > translation = max Featurized Translations . get ( i ) . translation ; if ( pseudo References . get ( i ) . size ( ) >= num Pseudo References ) pseudo References . get ( i ) . remove ( _ NUM ) ; pseudo References . get ( i ) . add ( translation ) ; } logger . info ( _ STR , pseudo References . get ( _ NUM ) . size ( ) ) ;  File file = new  File ( nbest Filename ) ; file . delete ( ) ; reference Weights = new double [ num References + pseudo References . get ( _ NUM ) . size ( ) ] ;  Arrays . fill ( reference Weights , _ NUM ) ; } if ( epoch >= pseudo Reference Burn In ) { nbest Filename =  String . format ( _ STR , temp Directory , epoch ) ; logger . info ( _ STR , nbest Filename ) ; nbest List Writer =  IOTools . get Writer From File ( nbest Filename ) ; } }
@  Suppress Warnings ( _ STR ) @  Override public void paint Icon (  Component c ,  Graphics g , int x , int y ) {  Sea Glass Painter painter = (  Sea Glass Painter )  UIManager . get ( prefix + _ STR + key ) ; if ( painter != null ) {  JComponent jc = ( c instanceof  JComponent ) ? (  JComponent ) c : null ;  Graphics2 D gfx = (  Graphics2 D ) g ; gfx . translate ( x , y ) ; painter . paint ( gfx , jc , width , height ) ; gfx . translate ( - x , - y ) ; } }
public void load Ham NSpam (  Connection conn ) throws java . sql .  SQLException {  Prepared Statement pstmt = null ;  Result Set rs = null ; try { pstmt = conn . prepare Statement ( sql Queries . get Sql String ( _ STR , _ BOOL ) ) ; rs = pstmt . execute Query ( ) ;  Map <  String ,  Integer > ham = get Ham Token Counts ( ) ; while ( rs . next ( ) ) {  String token = rs . get String ( _ NUM ) ; int count = rs . get Int ( _ NUM ) ; if ( count > _ NUM ) { ham . put ( token , count ) ; } } delegated Log ( _ STR + ham . size ( ) ) ; rs . close ( ) ; pstmt . close ( ) ; pstmt = conn . prepare Statement ( sql Queries . get Sql String ( _ STR , _ BOOL ) ) ; rs = pstmt . execute Query ( ) ;  Map <  String ,  Integer > spam = get Spam Token Counts ( ) ; while ( rs . next ( ) ) {  String token = rs . get String ( _ NUM ) ; int count = rs . get Int ( _ NUM ) ; if ( count > _ NUM ) { spam . put ( token , count ) ; } } delegated Log ( _ STR + spam . size ( ) ) ; rs . close ( ) ; pstmt . close ( ) ; pstmt = conn . prepare Statement ( sql Queries . get Sql String ( _ STR , _ BOOL ) ) ; rs = pstmt . execute Query ( ) ; if ( rs . next ( ) ) { set Ham Message Count ( rs . get Int ( _ NUM ) ) ; set Spam Message Count ( rs . get Int ( _ NUM ) ) ; } rs . close ( ) ; pstmt . close ( ) ; } finally { if ( rs != null ) { try { rs . close ( ) ; } catch ( java . sql .  SQLException se ) { } rs = null ; } if ( pstmt != null ) { try { pstmt . close ( ) ; } catch ( java . sql .  SQLException se ) { } pstmt = null ; } } }
public static  File locate File (  String name ,  String basedir ) {  File f = new  File ( name ) ; if ( f . exists ( ) ) { return f ; } if ( basedir != null ) { f = new  File ( basedir , name ) ; if ( f . exists ( ) ) { return f ; } } {  String name2 = name . trim ( ) ; if ( ! name . equals ( name2 ) ) { f = locate File ( name2 , basedir ) ; if ( f != null ) { return f ; } } } {  String name2 = name . replace ( _ STR ,  File . separator Char ) ; if ( ! name . equals ( name2 ) ) { f = locate File ( name2 , basedir ) ; if ( f != null ) { return f ; } } name2 = name . replace ( _ STR ,  File . separator Char ) ; if ( ! name . equals ( name2 ) ) { f = locate File ( name2 , basedir ) ; if ( f != null ) { return f ; } } } if ( name . length ( ) > _ NUM && name . char At ( _ NUM ) == _ STR && name . char At ( name . length ( ) - _ NUM ) == _ STR ) { f = locate File ( name . substring ( _ NUM , name . length ( ) - _ NUM ) , basedir ) ; if ( f != null ) { return f ; } } return null ; }
protected int range Upper (  String range ) { int hyphen Index ; if ( ( hyphen Index = range . index Of ( _ STR ) ) >= _ NUM ) { return  Math . max ( range Upper ( range . substring ( _ NUM , hyphen Index ) ) , range Upper ( range . substring ( hyphen Index + _ NUM ) ) ) ; } return range Single ( range ) ; }
private byte [ ] unzip ( byte [ ] body ) {  Zip Entry ze ; byte buf [ ] = new byte [ _ NUM ] ; try (  Byte Array Output Stream bao = new  Byte Array Output Stream ( ) ;  Byte Array Input Stream bytein = new  Byte Array Input Stream ( body ) ;  Zip Input Stream zis = new  Zip Input Stream ( bytein ) ) { while ( ( ze = zis . get Next Entry ( ) ) != null ) { int l = _ NUM ; while ( ( l = zis . read ( buf ) ) > _ NUM ) { bao . write ( buf , _ NUM , l ) ; } } return bao . to Byte Array ( ) ; } catch (  IOException e ) { } return null ; }
public static void update Artwork (  Movie Set movie Set ) { find Artwork In Artwork Folder ( movie Set ) ; for (  Movie movie : new  Array List < > ( movie Set . get Movies ( ) ) ) { find Artwork In Movie Folder ( movie Set , movie ) ; } }
public  Multivariate Table (  Categorical Table head Table ) { this . head Vars = new  Hash Set <  String > (  Arrays . as List ( head Table . get Variable ( ) ) ) ; this . table = new  Hash Map <  Assignment ,  Double > ( ) ;  String variable = head Table . get Variable ( ) ; for (  Value a : head Table . get Values ( ) ) { double prob = head Table . get Prob ( a ) ; table . put ( new  Assignment ( variable , a ) , prob ) ; } }
public void write Jar From Content ( final  String class Name , final  String content , final  Output Stream out Stream ) throws  IOException {  Jar Output Stream jar Output Stream = new  Jar Output Stream ( out Stream ) ;  String formatted Name = class Name ; if ( ! formatted Name . ends With ( _ STR ) ) { formatted Name = formatted Name . concat ( _ STR ) ; } if ( class Name . contains ( _ STR ) ) {  Jar Entry entry = new  Jar Entry ( class Name . substring ( _ NUM , class Name . last Index Of ( _ STR ) ) ) ; entry . set Time (  System . current Time Millis ( ) ) ; jar Output Stream . put Next Entry ( entry ) ; }  Jar Entry entry = new  Jar Entry ( formatted Name ) ; entry . set Time (  System . current Time Millis ( ) ) ; jar Output Stream . put Next Entry ( entry ) ; jar Output Stream . write ( compile Class ( class Name , content ) ) ; jar Output Stream . close Entry ( ) ; jar Output Stream . close ( ) ; }
@  Suppress Warnings ( _ STR ) boolean track Motion Scroll ( int delta Y , int incremental Delta Y ) { final int child Count = get Child Count ( ) ; if ( child Count == _ NUM ) { return _ BOOL ; } final int first Top = get Scroll Child Top ( ) ; final int last Bottom = get Scroll Child Bottom ( ) ; final  Rect list Padding = m List Padding ; final int end = get Height ( ) - list Padding . bottom ; final int space Above = list Padding . top - get Fill Child Top ( ) ; final int space Below = get Fill Child Bottom ( ) - end ; final int height = get Height ( ) - get Padding Bottom ( ) - get Padding Top ( ) ; if ( delta Y < _ NUM ) { delta Y =  Math . max ( - ( height - _ NUM ) , delta Y ) ; } else { delta Y =  Math . min ( height - _ NUM , delta Y ) ; } if ( incremental Delta Y < _ NUM ) { incremental Delta Y =  Math . max ( - ( height - _ NUM ) / _ NUM , incremental Delta Y ) ; } else { incremental Delta Y =  Math . min ( ( height - _ NUM ) / _ NUM , incremental Delta Y ) ; } final int first Position = m First Position ; if ( first Position == _ NUM && first Top >= list Padding . top && delta Y >= _ NUM ) { return _ BOOL ; } if ( first Position + child Count == m Item Count && last Bottom <= end && delta Y <= _ NUM ) { return _ BOOL ; } final boolean down = incremental Delta Y < _ NUM ; final int header Views Count = get Header Views Count ( ) ; final int footer Views Start = m Item Count - get Footer Views Count ( ) ; int start = _ NUM ; int count = _ NUM ; if ( down ) { final int top = list Padding . top - incremental Delta Y ; for ( int i = _ NUM ; i < child Count ; i ++ ) { final  View child = get Child At ( i ) ; if ( child . get Bottom ( ) >= top ) { break ; } else { count ++ ; int position = first Position + i ; if ( position >= header Views Count && position < footer Views Start ) { m Recycler . add Scrap View ( child ) ; if (  View Debug .  TRACE_ RECYCLER ) {  View Debug . trace ( child ,  View Debug .  Recycler Trace Type .  MOVE_ TO_ SCRAP_ HEAP , first Position + i , - _ NUM ) ; } } } } } else { final int bottom = get Height ( ) - list Padding . bottom - incremental Delta Y ; for ( int i = child Count - _ NUM ; i >= _ NUM ; i -- ) { final  View child = get Child At ( i ) ; if ( child . get Top ( ) <= bottom ) { break ; } else { start = i ; count ++ ; int position = first Position + i ; if ( position >= header Views Count && position < footer Views Start ) { m Recycler . add Scrap View ( child ) ; if (  View Debug .  TRACE_ RECYCLER ) {  View Debug . trace ( child ,  View Debug .  Recycler Trace Type .  MOVE_ TO_ SCRAP_ HEAP , first Position + i , - _ NUM ) ; } } } } } m Motion View New Top = m Motion View Original Top + delta Y ; m Block Layout Requests = _ BOOL ; if ( count > _ NUM ) { detach Views From Parent ( start , count ) ; } try Offset Children Top And Bottom ( incremental Delta Y ) ; if ( down ) { m First Position += count ; } invalidate ( ) ; final int abs Incremental Delta Y =  Math . abs ( incremental Delta Y ) ; if ( space Above < abs Incremental Delta Y || space Below < abs Incremental Delta Y ) { fill Gap ( down ) ; } m Block Layout Requests = _ BOOL ; invoke On Item Scroll Listener ( ) ; awaken Scroll Bars ( ) ; return _ BOOL ; }
public static <  K extends  Object ,  V extends  Object > boolean add To List Map (  Map <  K ,  List <  V > > map ,  K key ,  V value ) { if ( map == null ) { return _ BOOL ; }  List <  V > list = map . get ( key ) ; if ( list == null ) { list = new  Array List <  V > ( ) ; map . put ( key , list ) ; } if ( ! list . contains ( value ) ) { list . add ( value ) ; return _ BOOL ; } return _ BOOL ; }
public void message Item Details (  String str Class ,  String item ,  String description ,  String [ ] msg Option , int [ ] msg Number , int default Option ) {  Hash Map <  Integer ,  String > options = new  Hash Map <  Integer ,  String > ( msg Option . length ) ; for ( int i = _ NUM ; i < msg Option . length ; i ++ ) { options . put ( msg Number [ i ] , msg Option [ i ] ) ; } message Item Details ( str Class , description , item , options , default Option ) ; }
public void remove Listener (  Color Map Listener listener ) { if ( listener == null ) return ; listeners . remove ( listener ) ; }
protected double compute PLOFs (  Relation <  O > relation ,  KNNQuery <  O > knn ,  Writable Double Data Store pdists ,  Writable Double Data Store plofs ) {  Finite Progress progress PLOFs =  LOG . is Verbose ( ) ? new  Finite Progress ( _ STR , relation . size ( ) ,  LOG ) : null ; double nplof = _ NUM ; for (  DBIDIter iditer = relation . iter DBIDs ( ) ; iditer . valid ( ) ; iditer . advance ( ) ) { final  KNNList neighbors = knn . get KNNFor DBID ( iditer , kcomp + _ NUM ) ; int ks = _ NUM ; double sum = _ NUM ; for (  DBIDIter neighbor = neighbors . iter ( ) ; neighbor . valid ( ) && ks < kcomp ; neighbor . advance ( ) ) { if (  DBIDUtil . equal ( neighbor , iditer ) ) { continue ; } sum += pdists . double Value ( neighbor ) ; ks ++ ; } double plof =  Math Util . max ( pdists . double Value ( iditer ) * ks / sum , _ NUM ) ; if (  Double . is Na N ( plof ) ||  Double . is Infinite ( plof ) ) { plof = _ NUM ; } plofs . put Double ( iditer , plof ) ; nplof += ( plof - _ NUM ) * ( plof - _ NUM ) ;  LOG . increment Processed ( progress PLOFs ) ; }  LOG . ensure Completed ( progress PLOFs ) ; nplof = lambda *  Math . sqrt ( nplof / relation . size ( ) ) ; if (  LOG . is Debugging Fine ( ) ) {  LOG . debug Fine ( _ STR + nplof ) ; } return nplof > _ NUM ? nplof : _ NUM ; }
private void do Wait For (  Process process ) { start Read Stream Thread ( process . get Input Stream ( ) ) ; start Read Stream Thread ( process . get Error Stream ( ) ) ; try { process . wait For ( ) ; } catch (  Interrupted Exception e ) { log . warn ( _ STR , e ) ; } }
public static int start Agent (  SSOServer Mon Config mon Config ) { mon Html Port = mon Config . html Port ; mon Snmp Port = mon Config . snmp Port ; mon Rmi Port = mon Config . rmi Port ; monitoring Enabled = mon Config . monitoring Enabled ; mon Html Port Enabled = mon Config . mon Html Port Enabled ; mon Snmp Port Enabled = mon Config . mon Snmp Port Enabled ; mon Rmi Port Enabled = mon Config . mon Rmi Port Enabled ; mon Auth File Path = mon Config . mon Auth File Path ; policy Window = mon Config . policy Window ; session Window = mon Config . session Window ;  String class Method = _ STR ;  String server Port = agent Svr Info . server Port ; if ( ( mon Auth File Path != null ) && ( mon Auth File Path . ends With ( _ STR ) ) ) {  File mon Auth File = new  File ( mon Auth File Path ) ;  File new Mon Auth File = new  File ( mon Auth File . get Parent File ( ) + _ STR + _ STR ) ; if ( mon Auth File . rename To ( new Mon Auth File ) ) { mon Auth File Path = new Mon Auth File . get Absolute Path ( ) ; } } if ( debug . message Enabled ( ) ) { debug . message ( class Method + _ STR + _ STR + mon Html Port + _ STR + _ STR + mon Auth File Path + _ STR + _ STR + mon Snmp Port + _ STR + _ STR + mon Rmi Port + _ STR + _ STR + monitoring Enabled + _ STR + _ STR + mon Html Port Enabled + _ STR + _ STR + mon Snmp Port Enabled + _ STR + _ STR + mon Rmi Port Enabled + _ STR + _ STR + policy Window + _ STR + _ STR + session Window + _ STR + _ STR + server Port + _ STR ) ; } if ( ! monitoring Enabled ) { debug . warning ( class Method + _ STR ) ; return  MON_ CONFIG_ DISABLED ; } try { int sport =  Integer . parse Int ( server Port ) ; if ( mon Rmi Port == sport ) { debug . error ( class Method + _ STR + sport + _ STR ) ; return  MON_ RMICONNECTOR_ PROBLEM ; } if ( mon Html Port == sport ) { mon Html Port Enabled = _ BOOL ; if ( debug . warning Enabled ( ) ) { debug . warning ( class Method + _ STR + sport + _ STR ) ; } } if ( mon Snmp Port == sport ) { mon Snmp Port Enabled = _ BOOL ; if ( debug . warning Enabled ( ) ) { debug . warning ( class Method + _ STR + sport + _ STR ) ; } } } catch (  Number Format Exception nfe ) { debug . error ( class Method + _ STR + server Port + _ STR + nfe . get Message ( ) ) ; } if ( debug . message Enabled ( ) ) { debug . message ( class Method + _ STR + _ STR + monitoring Enabled + _ STR + _ STR + mon Html Port + _ STR + mon Html Port Enabled + _ STR + _ STR + mon Snmp Port + _ STR + mon Snmp Port Enabled + _ STR + _ STR + mon Rmi Port + _ STR + mon Rmi Port Enabled + _ STR + _ STR + session Window + _ STR + _ STR + policy Window + _ STR ) ; }  List <  MBean Server > servers = null ; try { servers =  MBean Server Factory . find MBean Server ( null ) ; } catch (  Security Exception ex ) { if ( debug . warning Enabled ( ) ) { debug . warning ( class Method + _ STR + ex . get Message ( ) ) ; } } if ( debug . message Enabled ( ) ) { debug . message ( class Method + _ STR + ( ( servers != null ) && ! servers . is Empty ( ) ) ) ; } if ( ( servers != null ) && ! servers . is Empty ( ) ) { server = servers . get ( _ NUM ) ; } else { try { server =  MBean Server Factory . create MBean Server ( ) ; } catch (  Security Exception ex ) { if ( debug . warning Enabled ( ) ) { debug . warning ( class Method + _ STR + ex . get Message ( ) ) ; } return  MON_ MBEANSRVR_ PROBLEM ; } catch (  JMRuntime Exception ex ) { if ( debug . warning Enabled ( ) ) { debug . warning ( class Method + _ STR + ex . get Message ( ) ) ; } return  MON_ MBEANSRVR_ PROBLEM ; } catch (  Class Cast Exception ex ) { if ( debug . warning Enabled ( ) ) { debug . warning ( class Method + _ STR + ex . get Message ( ) ) ; } return  MON_ MBEANSRVR_ PROBLEM ; } } if ( server == null ) { if ( debug . warning Enabled ( ) ) { debug . warning ( class Method + _ STR ) ; } return  MON_ MBEANSRVR_ PROBLEM ; }  String domain = server . get Default Domain ( ) ; try { sun Mib Obj Name = new  Object Name ( _ STR ) ; forgerock Cts Mib Obj Name = new  Object Name ( _ STR ) ; forgerock Policy Mib Obj Name = new  Object Name ( _ STR ) ; forgerock Session Mib Obj Name = new  Object Name ( _ STR ) ; if ( debug . message Enabled ( ) ) { debug . message ( class Method + _ STR + _ STR + sun Mib Obj Name + _ STR ) ; debug . message ( class Method + _ STR + _ STR + forgerock Cts Mib Obj Name + _ STR ) ; } } catch (  Malformed Object Name Exception ex ) { if ( debug . warning Enabled ( ) ) { debug . warning ( class Method + _ STR + ex . get Message ( ) ) ; } return  MON_ CREATEMIB_ PROBLEM ; } try { sun Mib = new  SUN_ OPENSSO_ SERVER_ MIBImpl ( ) ; forgerock Cts Mib = new  FORGEROCK_ OPENAM_ CTS_ MIBImpl ( ) ; forgerock Policy Mib = new  FORGEROCK_ OPENAM_ POLICY_ MIBImpl ( ) ; forgerock Session Mib = new  FORGEROCK_ OPENAM_ SESSION_ MIBImpl ( ) ; } catch (  Runtime Exception ex ) { debug . error ( class Method + _ STR , ex ) ; return  MON_ CREATEMIB_ PROBLEM ; } catch (  Exception ex ) { debug . error ( class Method + _ STR , ex ) ; return  MON_ CREATEMIB_ PROBLEM ; } try { server . register MBean ( sun Mib , sun Mib Obj Name ) ; server . register MBean ( forgerock Cts Mib , forgerock Cts Mib Obj Name ) ; server . register MBean ( forgerock Policy Mib , forgerock Policy Mib Obj Name ) ; server . register MBean ( forgerock Session Mib , forgerock Session Mib Obj Name ) ; } catch (  Runtime Operations Exception ex ) { if ( debug . warning Enabled ( ) ) { debug . warning ( class Method + _ STR + ex . get Message ( ) ) ; } return  MON_ CREATEMIB_ PROBLEM ; } catch (  Instance Already Exists Exception ex ) { if ( debug . warning Enabled ( ) ) { debug . warning ( class Method + _ STR + ex . get Message ( ) ) ; } } catch (  MBean Registration Exception ex ) { if ( debug . warning Enabled ( ) ) { debug . warning ( class Method + _ STR + ex . get Message ( ) ) ; } return  MON_ CREATEMIB_ PROBLEM ; } catch (  Not Compliant MBean Exception ex ) { if ( debug . warning Enabled ( ) ) { debug . warning ( class Method + _ STR + ex . get Message ( ) ) ; } return  MON_ CREATEMIB_ PROBLEM ; } boolean mon HTMLStarted = _ BOOL ; boolean mon SNMPStarted = _ BOOL ; boolean mon RMIStarted = _ BOOL ; if ( mon Html Port Enabled ) { try { html Obj Name = new  Object Name ( domain + _ STR + mon Html Port ) ; if ( debug . message Enabled ( ) ) { debug . message ( class Method + _ STR + html Obj Name + _ STR + _ STR + mon Html Port ) ; }  Map <  String ,  String > users =  Monitoring Util . get Mon Auth List ( mon Auth File Path ) ; if ( users != null ) {  Auth Info auth Info [ ] = new  Auth Info [ users . size ( ) ] ; int i = _ NUM ; for (  Map .  Entry <  String ,  String > entry : users . entry Set ( ) ) { auth Info [ i ] = new  Auth Info ( entry . get Key ( ) , entry . get Value ( ) ) ; i ++ ; } html Adaptor = new  Html Adaptor Server ( mon Html Port , auth Info ) ; } else { if ( debug . warning Enabled ( ) ) { debug . warning ( class Method + _ STR + _ STR ) ; } html Adaptor = null ; } if ( html Adaptor == null ) { if ( debug . warning Enabled ( ) ) { debug . warning ( class Method + _ STR + mon Html Port + _ STR + _ STR ) ; } } else { server . register MBean ( html Adaptor , html Obj Name ) ; html Adaptor . start ( ) ; mon HTMLStarted = _ BOOL ; } } catch (  Malformed Object Name Exception ex ) { if ( debug . warning Enabled ( ) ) { debug . warning ( class Method + _ STR + ex . get Message ( ) ) ; } } catch (  Null Pointer Exception ex ) { debug . error ( class Method + _ STR , ex ) ; if ( debug . warning Enabled ( ) ) { debug . warning ( class Method + _ STR + ex . get Message ( ) ) ; } } catch (  Instance Already Exists Exception ex ) { if ( debug . warning Enabled ( ) ) { debug . warning ( class Method + _ STR + ex . get Message ( ) ) ; } } catch (  MBean Registration Exception ex ) { if ( debug . warning Enabled ( ) ) { debug . warning ( class Method + _ STR + ex . get Message ( ) ) ; } } catch (  Not Compliant MBean Exception ex ) { if ( debug . warning Enabled ( ) ) { debug . warning ( class Method + _ STR + ex . get Message ( ) ) ; } } } else { debug . warning ( class Method + _ STR ) ; } if ( mon Snmp Port Enabled ) { try { snmp Obj Name = new  Object Name ( domain + _ STR + mon Snmp Port ) ; if ( debug . message Enabled ( ) ) { debug . message ( class Method + _ STR + snmp Obj Name + _ STR + _ STR + mon Snmp Port ) ; } snmp Adaptor = new  Snmp Adaptor Server ( mon Snmp Port ) ; if ( snmp Adaptor == null ) { if ( debug . warning Enabled ( ) ) { debug . warning ( class Method + _ STR ) ; } } else { server . register MBean ( snmp Adaptor , snmp Obj Name ) ; snmp Adaptor . start ( ) ; if ( debug . message Enabled ( ) ) { debug . message ( class Method + _ STR + _ STR ) ; } snmp Adaptor . set Trap Port ( new  Integer ( mon Snmp Port + _ NUM ) ) ; snmp Adaptor . snmp V1 Trap ( _ NUM , _ NUM , null ) ; if ( debug . message Enabled ( ) ) { debug . message ( class Method + _ STR ) ; } sun Mib . set Snmp Adaptor ( snmp Adaptor ) ; forgerock Cts Mib . set Snmp Adaptor ( snmp Adaptor ) ; forgerock Policy Mib . set Snmp Adaptor ( snmp Adaptor ) ; forgerock Session Mib . set Snmp Adaptor ( snmp Adaptor ) ; mon SNMPStarted = _ BOOL ; } } catch (  Exception ex ) { if ( debug . warning Enabled ( ) ) { debug . warning ( class Method + _ STR + ex . get Message ( ) ) ; } if ( ex instanceof  IOException || ex instanceof  Snmp Status Exception ) { mon SNMPStarted = _ BOOL ; } } } else { debug . warning ( class Method + _ STR ) ; } if ( mon Rmi Port Enabled ) { try { registry =  Locate Registry . create Registry ( mon Rmi Port ) ;  JMXService URL url = new  JMXService URL ( _ STR + mon Rmi Port + _ STR ) ; cs =  JMXConnector Server Factory . new JMXConnector Server ( url , null , server ) ; cs . start ( ) ; mon RMIStarted = _ BOOL ; } catch (  Malformed URLException ex ) { if ( debug . warning Enabled ( ) ) { debug . warning ( class Method + _ STR + _ STR + ex . get Message ( ) ) ; } } catch (  Null Pointer Exception ex ) { if ( debug . warning Enabled ( ) ) { debug . warning ( class Method + _ STR + _ STR + ex . get Message ( ) ) ; } } catch (  IOException ex ) { if ( debug . warning Enabled ( ) ) { debug . warning ( class Method + _ STR + _ STR + ex . get Message ( ) ) ; } } catch (  Illegal State Exception ex ) { if ( debug . warning Enabled ( ) ) { debug . warning ( class Method + _ STR + _ STR + ex . get Message ( ) ) ; } } catch (  Exception ex ) { debug . error ( class Method + _ STR + mon Rmi Port + _ STR , ex ) ; } } else { debug . warning ( class Method + _ STR ) ; } if ( ! mon RMIStarted && ! mon SNMPStarted && ! mon HTMLStarted ) { debug . warning ( class Method + _ STR ) ; return  MON_ RMICONNECTOR_ PROBLEM ; } else { agent Started = _ BOOL ; start Monitoring Agent ( agent Svr Info ) ; return _ NUM ; } }
public void and With (  Query Predicate predicate ) { children . add ( predicate ) ; }
public  MMRoll (  MMRandom rng , int count , int start , int keep ) { super ( count , start ) ; this . total = rng . random Int ( this . faces ) + this . min ; all . add Element ( this . total ) ; this . keep = keep ; }
public synchronized void remove Blanks ( ) { if (  DEBUG != null )  DEBUG . println ( _ STR ) ;  Reference ref ; while ( ( ref = ref Queue . poll ( ) ) != null ) { if ( ref instanceof  Weak Key Reference ) { final  Weak Reference valref = (  Weak Reference ) table . remove ( ref ) ; if ( valref != null && handler != null && valref . get ( ) != null ) handler . key GC ( valref . get ( ) ) ; if (  DEBUG != null ) { boolean removed = ( valref != null ) ;  DEBUG . print ( _ STR + ref ) ;  DEBUG . println ( _ STR + ( removed ? _ STR : _ STR ) + _ STR + table . size ( ) + _ STR ) ; } } else { if (  DEBUG != null )  DEBUG . println ( _ STR + ref ) ; } } if (  DEBUG != null )  DEBUG . println ( _ STR ) ; }
public static void close Quietly (  Closeable closeable ) { if ( closeable != null ) { try { closeable . close ( ) ; } catch (  Runtime Exception rethrown ) { throw rethrown ; } catch (  Exception ignored ) { } } }
public void send (  Coordinator Stream Message message ) { log . debug ( _ STR , message ) ; try {  String source = message . get Source ( ) ; byte [ ] key = key Serde . to Bytes (  Arrays . as List ( message . get Key Array ( ) ) ) ; byte [ ] value = null ; if ( ! message . is Delete ( ) ) { value = message Serde . to Bytes ( message . get Message Map ( ) ) ; }  Outgoing Message Envelope envelope = new  Outgoing Message Envelope ( system Stream ,  Integer . value Of ( _ NUM ) , key , value ) ; system Producer . send ( source , envelope ) ; } catch (  Exception e ) { throw new  Samza Exception ( e ) ; } }
public static int rand Range ( int min , int max ) { int mod = max - min ; double val =  Math . ceil (  Math . random ( ) * _ NUM ) % mod ; return ( int ) val + min ; }
public void test_simple Close On End ( ) {  Striterator iter = new  Striterator ( m_data . iterator ( ) ) ; assert True ( iter . is Open ( ) ) ; while ( iter . has Next ( ) ) { iter . next ( ) ; assert True ( iter . is Open ( ) ) ; } assert True ( ! iter . is Open ( ) ) ; }
public void push Draw List Head (  Psp Ge List list ) { synchronized ( draw List Queue ) { int array Size = draw List Queue . size ( ) ; if ( array Size > _ NUM ) {  Psp Ge List [ ] array = draw List Queue . to Array ( new  Psp Ge List [ array Size ] ) ;  Concurrent Linked Queue <  Psp Ge List > new Queue = new  Concurrent Linked Queue <  Psp Ge List > ( ) ;  Psp Ge List [ ] new Array = new  Psp Ge List [ array Size + _ NUM ] ; new Array [ _ NUM ] = list ; for ( int i = _ NUM ; i < array Size ; i ++ ) { new Array [ i + _ NUM ] = array [ i ] ; new Queue . add ( new Array [ i ] ) ; } draw List Queue = new Queue ; } else { draw List Queue . add ( list ) ; } } }
protected void add Tasks For Volumes And CGs (  Db Client db Client ,  List <  Volume > add Vols ,  List <  Volume > remove Vols ,  Set <  URI > remove Volume CGs ,  String task Id ,  Task List task List ) { if ( add Vols != null && ! add Vols . is Empty ( ) ) { for (  Volume vol : add Vols ) { add Volume Task ( db Client , vol , task List , task Id ,  Resource Operation Type Enum .  UPDATE_ VOLUME_ GROUP ) ; } } if ( remove Vols != null && ! remove Vols . is Empty ( ) ) { for (  Volume vol : remove Vols ) { add Volume Task ( db Client , vol , task List , task Id ,  Resource Operation Type Enum .  UPDATE_ VOLUME_ GROUP ) ; } } if ( remove Volume CGs != null && ! remove Volume CGs . is Empty ( ) ) { for (  URI cg : remove Volume CGs ) { add Consistency Group Task ( db Client , cg , task List , task Id ,  Resource Operation Type Enum .  UPDATE_ VOLUME_ GROUP ) ; } } }
public  String format String ( final  String str To Format ) { if ( str To Format != null ) { if ( str To Format . equals Ignore Case ( _ STR ) ) return _ STR ; final  String valn1 = str To Format . replace All ( _ STR , _ STR ) ; final  String formt Str = valn1 . replace All ( _ STR , _ STR ) ; return formt Str . replace All ( _ STR , _ STR ) ; } else return _ STR ; }
public void add Listener (  Air Map Traffic Listener listener ) { if ( listeners . is Empty ( ) ) { listeners . add ( listener ) ; connect ( ) ; } else { listeners . add ( listener ) ; } }
private static void copy File (  Input Stream stream ,  Output Stream out Stream ) throws  IOException { int len ; final byte [ ] buffer = new byte [  Carbon Common Constants .  BYTEBUFFER_ SIZE ] ; try { for ( ; ; ) { len = stream . read ( buffer ) ; if ( len == - _ NUM ) { return ; } out Stream . write ( buffer , _ NUM , len ) ; } } catch (  IOException e ) { throw e ; } finally {  Carbon Util . close Streams ( stream , out Stream ) ; } }
public double longing (  F f , int  N ) { return  Math . pow ( _ NUM - p ( f ) ,  N ) ; }
public void append Simple (  Object ... data ) { if ( data . length != meta . size ( ) ) { throw new  Abort Exception ( _ STR ) ; } for ( int i = _ NUM ; i < data . length ; i ++ ) { @  Suppress Warnings ( _ STR ) final  List <  Object > col = (  List <  Object > ) columns . get ( i ) ; col . add ( data [ i ] ) ; } }
public void write ( byte [ ] b , int off , int len , long pos ) throws  IOException { if ( b == null ) { throw new  Null Pointer Exception ( _ STR ) ; } if ( ( off < _ NUM ) || ( len < _ NUM ) || ( pos < _ NUM ) || ( off + len > b . length ) || ( off + len < _ NUM ) ) { throw new  Index Out Of Bounds Exception ( ) ; } long last Pos = pos + len - _ NUM ; if ( last Pos >= length ) { pad ( last Pos ) ; length = last Pos + _ NUM ; } int offset = ( int ) ( pos %  BUFFER_ LENGTH ) ; while ( len > _ NUM ) { byte [ ] buf = get Cache Block ( pos /  BUFFER_ LENGTH ) ; int nbytes =  Math . min ( len ,  BUFFER_ LENGTH - offset ) ;  System . arraycopy ( b , off , buf , offset , nbytes ) ; pos += nbytes ; off += nbytes ; len -= nbytes ; offset = _ NUM ; } }
private static void expand Number At (  String number String , int start Index ,  Word Relation word Relation ,  Item token Item ) { expand Number ( number String . substring ( start Index , number String . length ( ) ) , word Relation , token Item ) ; }
private  Data Store <  DBIDs > load Neighbors (  Database database ,  Relation < ? > relation ) { final  Writable Data Store <  DBIDs > store =  Data Store Util . make Storage ( relation . get DBIDs ( ) ,  Data Store Factory .  HINT_ HOT |  Data Store Factory .  HINT_ STATIC |  Data Store Factory .  HINT_ TEMP ,  DBIDs . class ) ; if (  LOG . is Verbose ( ) ) {  LOG . verbose ( _ STR ) ; } if (  LOG . is Debugging ( ) ) {  LOG . verbose ( _ STR ) ; }  Map <  String ,  DBID > lblmap = new  Hash Map < > ( relation . size ( ) << _ NUM ) ; {  Relation <  Label List > olq = database . get Relation (  Type Util .  LABELLIST ) ;  Relation <  External ID > eidq = database . get Relation (  Type Util .  EXTERNALID ) ; for (  DBIDIter iditer = relation . iter DBIDs ( ) ; iditer . valid ( ) ; iditer . advance ( ) ) { if ( eidq != null ) {  External ID eid = eidq . get ( iditer ) ; if ( eid != null ) { lblmap . put ( eid . to String ( ) ,  DBIDUtil . deref ( iditer ) ) ; } } if ( olq != null ) {  Label List label = olq . get ( iditer ) ; if ( label != null ) { for ( int i = _ NUM ; i < label . size ( ) ; i ++ ) { lblmap . put ( label . get ( i ) ,  DBIDUtil . deref ( iditer ) ) ; } } } } } if (  LOG . is Debugging ( ) ) {  LOG . verbose ( _ STR ) ; } try (  Input Stream in =  File Util . try Gzip Input ( new  File Input Stream ( file ) ) ;  Buffered Reader br = new  Buffered Reader ( new  Input Stream Reader ( in ) ) ) { for (  String line ; ( line = br . read Line ( ) ) != null ; ) {  Array Modifiable DBIDs neighbours =  DBIDUtil . new Array ( ) ;  String [ ] entries = line . split ( _ STR ) ;  DBID id = lblmap . get ( entries [ _ NUM ] ) ; if ( id != null ) { for ( int i = _ NUM ; i < entries . length ; i ++ ) { final  DBID neigh = lblmap . get ( entries [ i ] ) ; if ( neigh != null ) { neighbours . add ( neigh ) ; } else { if (  LOG . is Debugging ( ) ) {  LOG . debug ( _ STR + entries [ i ] ) ; } } } store . put ( id , neighbours ) ; } else { if (  LOG . is Debugging ( ) ) {  LOG . warning ( _ STR + entries [ _ NUM ] ) ; } } } return store ; } catch (  IOException e ) { throw new  Abort Exception ( _ STR , e ) ; } }
protected  Map <  String ,  Set <  String > > filter Query Params By Key (  Query Params Parser Context context ,  String query Key ) {  Map <  String ,  Set <  String > > filtered Query Params = new  Hash Map < > ( ) ; for (  String param Name : context . get Parameter Names ( ) ) { if ( param Name . starts With ( query Key ) ) { filtered Query Params . put ( param Name , context . get Parameter Value ( param Name ) ) ; } } return filtered Query Params ; }
public void stop ( ) throws  Interrupted Exception { stopped = _ BOOL ; if ( thd != null ) { try { logger . info ( _ STR ) ; socket Service . close ( ) ; thd . interrupt ( ) ; thd . join ( ) ; thd = null ; } catch (  Interrupted Exception e ) { logger . info ( _ STR + e ) ; throw e ; } } }
public static  URI resolve ( final  URI base URI , final  String reference ) { return  URIUtils . resolve ( base URI ,  URI . create ( reference ) ) ; }
public void message Sent (  DMessage msg ) { int type = msg . get Type ( ) ; if ( type < _ NUM || type >=  DMessage .  Out SIZE ) type =  DMessage .  Out SIZE ; long target Isolate = msg . get Target Isolate ( ) ;  Object out Lock = get Out Lock ( ) ; if ( ! m_isolate ) { synchronized ( m_isolate Lock ) { if ( m_last Isolate !=  Isolate .  DEFAULT_ ID ) {  DMessage Counter counter = m_isolate Counter Map . get ( m_last Isolate ) ; out Lock = counter . get Out Lock ( ) ; } } } synchronized ( out Lock ) { if ( ! m_isolate && target Isolate !=  Isolate .  DEFAULT_ ID ) {  DMessage Counter counter = m_isolate Counter Map . get ( target Isolate ) ; counter . message Sent ( msg ) ; m_out Counts [ type ] += _ NUM ; out Lock . notify All ( ) ; } else { m_out Counts [ type ] += _ NUM ; out Lock . notify All ( ) ; } } }
public boolean equals Ignore Case (  String string ) { if ( string == this ) { return _ BOOL ; } if ( string == null || count != string . count ) { return _ BOOL ; } int o1 = offset , o2 = string . offset ; int end = offset + count ; char c1 , c2 ; char [ ] target = string . value ; while ( o1 < end ) { if ( ( c1 = value [ o1 ++ ] ) != ( c2 = target [ o2 ++ ] ) &&  Character . to Upper Case ( c1 ) !=  Character . to Upper Case ( c2 ) &&  Character . to Lower Case ( c1 ) !=  Character . to Lower Case ( c2 ) ) { return _ BOOL ; } } return _ BOOL ; }
public static long unix Timestamp (  UUID uuid ) { if ( uuid . version ( ) != _ NUM ) { throw new  Illegal Argument Exception (  String . format ( _ STR , uuid . version ( ) ) ) ; } else { return uuid . timestamp ( ) / _ NUM +  START_ EPOCH ; } }
public  String sql AD_get Translated Columns (  String vendor Name ,  String catalog Name ,  String schema Name ) {  String search Table Name = _ STR ;  Array List <  String > column Names = new  Array List <  String > ( ) ; column Names . add ( _ STR ) ;  Array List <  String > alias Names = null ;  Array List <  String > join Types = new  Array List <  String > ( ) ; join Types . add ( _ STR ) ;  Array List <  String > join Tables = new  Array List <  String > ( ) ; join Tables . add ( _ STR ) ;  Array List <  String > join Conditions = new  Array List <  String > ( ) ; join Conditions . add ( _ STR ) ;  Array List <  String > conditions = new  Array List <  String > ( ) ; conditions . add ( _ STR ) ; conditions . add ( _ STR ) ; conditions . add ( _ STR ) ;  Array List <  String > sort Columns = new  Array List <  String > ( ) ; sort Columns . add ( _ STR ) ; return sql_select ( vendor Name , catalog Name , schema Name , search Table Name , null , column Names , alias Names , join Types , join Tables , null , join Conditions , conditions , sort Columns , _ BOOL ) ; }
private void apply To (  Class Visitor v ,  Method m ) { if (  Log . is Logging On ( ) ) {  Log . log Line (  String . format ( _ STR , m . to Generic String ( ) ) ) ; } v . visit ( m ) ; }
public void test Case15 ( ) { byte a Bytes [ ] = { _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM } ; byte b Bytes [ ] = { _ NUM } ; int a Sign = _ NUM ; int b Sign = _ NUM ;  Big Integer a Number = new  Big Integer ( a Sign , a Bytes ) ;  Big Integer b Number = new  Big Integer ( b Sign , b Bytes ) ; try { a Number . remainder ( b Number ) ; fail ( _ STR ) ; } catch (  Arithmetic Exception e ) { } }
private void add Observed File (  String local Path ,  Account account ) {  File file = new  File ( local Path ) ;  String parent Path = file . get Parent ( ) ;  Folder Observer observer = m Folder Observers Map . get ( parent Path ) ; if ( observer == null ) { observer = new  Folder Observer ( parent Path , account , get Application Context ( ) ) ; m Folder Observers Map . put ( parent Path , observer ) ;  Log_ OC . d (  TAG , _ STR + parent Path + _ STR ) ; } observer . start Watching ( file . get Name ( ) ) ;  Log_ OC . d (  TAG , _ STR + local Path + _ STR ) ; }
public static  Block Snapshot Session query Snapshot Session (  URI snap Session URI ,  Uri Info uri Info ,  Db Client db Client , boolean check Inactive ) {  Arg Validator . check Uri ( snap Session URI ) ;  Block Snapshot Session snap Session = db Client . query Object (  Block Snapshot Session . class , snap Session URI ) ;  Arg Validator . check Entity ( snap Session , snap Session URI ,  Block Service Utils . is Id Embedded In URL ( snap Session URI , uri Info ) , check Inactive ) ; return snap Session ; }
private void find Stabbed Segments (  Coordinate stabbing Ray Left Pt ,  List dir Edges ,  List stabbed Segments ) { for (  Iterator i = dir Edges . iterator ( ) ; i . has Next ( ) ; ) {  Directed Edge de = (  Directed Edge ) i . next ( ) ; if ( ! de . is Forward ( ) ) continue ; find Stabbed Segments ( stabbing Ray Left Pt , de , stabbed Segments ) ; } }
public static byte [ ] to Byte Array (  String spaced Hex ) { int idx = _ NUM ; final int len = spaced Hex . length ( ) ; final  String Builder sb = new  String Builder ( ) ; final  Byte Array Output Stream bytes = new  Byte Array Output Stream ( ) ; while ( idx < len ) { final char chr = spaced Hex . char At ( idx ++ ) ; if ( chr != _ STR ) { sb . set Length ( _ NUM ) ; sb . append ( chr ) ; sb . append ( spaced Hex . char At ( idx ++ ) ) ; final int i =  Integer . parse Int ( sb . to String ( ) , _ NUM ) ; final byte b = ( ( byte ) i ) ; bytes . write ( b ) ; } } return bytes . to Byte Array ( ) ; }
public  Array Set (  Collection < ? extends  E > collection ) { items = new  Array List <  E > ( collection . size ( ) ) ; for (  E item : collection ) if ( ! items . contains ( item ) ) items . add ( item ) ; }
public  Resource from Properties (  Properties properties ) {  String name = properties . get Property (  Resource Property Set .  RESOURCE_ NAME ) ;  String type = properties . get Property (  Resource Property Set .  RESOURCE_ TYPE ) ;  Resource resource = new  Resource ( name , type ) ; if ( properties . contains Key (  Resource Property Set .  RESOURCE_ CLASS ) ) {  String class Name = properties . get Property (  Resource Property Set .  RESOURCE_ CLASS ) ; resource . set Class Name ( class Name ) ; } if ( properties . contains Key (  Resource Property Set .  RESOURCE_ ID ) ) {  String id = properties . get Property (  Resource Property Set .  RESOURCE_ ID ) ; resource . set Id ( id ) ; } else { resource . set Id ( create Id From Jndi Location If Not Null ( name ) ) ; }  String parameters As ASemicolon Delimited String = properties . get Property (  Resource Property Set .  PARAMETERS ) ; resource . set Parameters (  Property Utils . to Map ( get Parameters From String (  Property Utils . escape Back Slashes If Not Null ( parameters As ASemicolon Delimited String ) ) ) ) ; return resource ; }
private boolean ensure Temp Path ( final  String path ) { final  File folder = new  File ( path ) ; boolean folder Accessible = _ BOOL ; if ( folder . exists ( ) && folder . can Write ( ) ) { folder Accessible = _ BOOL ; } if ( ! folder . exists ( ) ) { folder Accessible = folder . mkdirs ( ) ; } return folder Accessible ; }
public void remove Selection Listener ( final  Selection Listener listener ) { check Widget ( ) ; if ( listener == null ) {  SWT . error (  SWT .  ERROR_ NULL_ ARGUMENT ) ; } selection Listeners . remove ( listener ) ; }
public void push (  Class Node type ) { stack . add ( type ) ; }
public void handle Button1 Request (  Request Invocation Event event ) throws  Model Control Exception { submit Cycle = _ BOOL ;  Entities Model model = (  Entities Model ) get Model ( ) ;  AMProperty Sheet prop = (  AMProperty Sheet ) get Child (  PROPERTY_ ATTRIBUTE ) ;  String entity Type = (  String ) get Page Session Attribute (  ENTITY_ TYPE ) ;  String entity Name = (  String ) property Sheet Model . get Value (  ENTITY_ NAME ) ; entity Name = entity Name . trim ( ) ; try {  Map default Values = model . get Default Attribute Values ( entity Type , null , _ BOOL ) ;  Map values = prop . get Attribute Values ( default Values . key Set ( ) ) ;  String realm Name = (  String ) get Page Session Attribute (  AMAdmin Constants .  CURRENT_ REALM ) ; model . create Entity ( realm Name , entity Name , entity Type , values ) ; forward To Entities View Bean ( ) ; } catch (  AMConsole Exception e ) { set Inline Alert Message (  CCAlert .  TYPE_ ERROR , _ STR , e . get Message ( ) ) ; forward To ( ) ; } }
private static  Double compute Angle ( final  Geo Point point , final double sin Latitude , final double cos Latitude , final double sin Longitude , final double cos Longitude ) { final double x1 = point . x * cos Longitude + point . y * sin Longitude ; final double y1 = - point . x * sin Longitude + point . y * cos Longitude ; final double z1 = point . z ; final double y2 = y1 ; final double z2 = - x1 * sin Latitude + z1 * cos Latitude ; if (  Math . sqrt ( y2 * y2 + z2 * z2 ) <  Vector .  MINIMUM_ RESOLUTION ) { return null ; } return  Math . atan2 ( z2 , y2 ) ; }
private  Node rotate Right (  Node x ) {  Node y = x . left ; x . left = y . right ; y . right = x ; y . size = x . size ; x . size = _ NUM + size ( x . left ) + size ( x . right ) ; x . height = _ NUM +  Math . max ( height ( x . left ) , height ( x . right ) ) ; y . height = _ NUM +  Math . max ( height ( y . left ) , height ( y . right ) ) ; return y ; }
protected void on Progress (  Progress Event event ) { if (  Log Configuration . logging Is Enabled ( ) ) { logger . log (  Level .  INFO , messages . progress Status ( event . get Loaded ( ) , event . get Total ( ) ) ) ; } ui Handler . show Message ( messages . progress Status ( event . get Loaded ( ) , event . get Total ( ) ) ) ; fire Application Cache Event (  Cache Event . on Progress ) ; }
public boolean add Agent (  IMoving Agent agent ) { if ( ! agents . contains ( agent ) ) { agents . add ( agent ) ; if ( agent instanceof  Hive ) { hives . add ( (  Hive ) agent ) ; } if ( agent instanceof  Food Source ) { food Sources . add ( (  Food Source ) agent ) ; } if ( agent instanceof  Obstacle ) obstacles . add ( (  Obstacle ) agent ) ; double r = agent . get Sphere Radius ( ) ; if ( r > max Agent Sphere Radius ) max Agent Sphere Radius = r ; return _ BOOL ; } return _ BOOL ; }
public  Week (  Date time ,  Time Zone zone ) { this ( time , zone ,  Locale . get Default ( ) ) ; }
public void write (  Byte Code Writer out ) throws  IOException { out . write Short ( _access Flags ) ; out . write UTF8 Const ( _name ) ; out . write UTF8 Const ( _descriptor ) ; out . write Short ( _attributes . size ( ) ) ; for ( int i = _ NUM ; i < _attributes . size ( ) ; i ++ ) {  Attribute attr = _attributes . get ( i ) ; attr . write ( out ) ; } }
public  Binary Out (  Socket socket ) { try {  Output Stream os = socket . get Output Stream ( ) ; out = new  Buffered Output Stream ( os ) ; } catch (  IOException e ) { e . print Stack Trace ( ) ; } }
public static boolean create File (  File target File ) { if ( target File . exists ( ) ) { if ( target File . is File ( ) ) return _ BOOL ; target File . delete ( ) ; } try { return target File . create New File ( ) ; } catch (  IOException e ) { return _ BOOL ; } }
public void test One One ( ) { byte a Bytes [ ] = { _ NUM } ; byte b Bytes [ ] = { _ NUM } ; int a Sign = _ NUM ; int b Sign = _ NUM ; byte r Bytes [ ] = { _ NUM } ;  Big Integer a Number = new  Big Integer ( a Sign , a Bytes ) ;  Big Integer b Number = new  Big Integer ( b Sign , b Bytes ) ;  Big Integer result = a Number . or ( b Number ) ; byte res Bytes [ ] = new byte [ r Bytes . length ] ; res Bytes = result . to Byte Array ( ) ; for ( int i = _ NUM ; i < res Bytes . length ; i ++ ) { assert True ( res Bytes [ i ] == r Bytes [ i ] ) ; } assert Equals ( _ STR , _ NUM , result . signum ( ) ) ; }
protected int execute Prepare (  Table table ,  List <  Column > columns ,  String  SQL , boolean keep , int type ) throws  SQLException { int bind No = _ NUM ;  Prepared Statement statement = null ; int affected Rows = _ NUM ; try { statement = db Conn . prepare Statement (  SQL ) ; for (  Column c : columns ) { set Column Value ( statement , bind No , c ) ; bind No ++ ; } affected Rows = statement . execute Update ( ) ; } finally { if ( statement != null && ! keep ) { statement . close ( ) ; statement = null ; } } if ( keep && type > - _ NUM ) table . set Statement ( type , statement ) ; return affected Rows ; }
public static  List <  Try Catch Block Node > find Try Catch Block Nodes Encompassing Instruction (  Insn List insn List ,  List <  Try Catch Block Node > try Catch Block Nodes ,  Abstract Insn Node insn Node ) {  Validate . not Null ( insn List ) ;  Validate . not Null ( try Catch Block Nodes ) ;  Validate . not Null ( insn Node ) ;  Validate . no Null Elements ( try Catch Block Nodes ) ;  Map <  Label Node ,  Integer > label Positions = new  Hash Map < > ( ) ; int insn Node Idx = - _ NUM ;  List Iterator <  Abstract Insn Node > insn It = insn List . iterator ( ) ; int insn Counter = _ NUM ; while ( insn It . has Next ( ) ) {  Abstract Insn Node node = insn It . next ( ) ; if ( node == insn Node ) { if ( insn Node Idx == - _ NUM ) { insn Node Idx = insn Counter ; } else { throw new  Illegal Argument Exception ( ) ; } } if ( node instanceof  Label Node ) { label Positions . put ( (  Label Node ) node , insn Counter ) ; } insn Counter ++ ; }  Validate . is True ( insn Node Idx != - _ NUM ) ;  List <  Try Catch Block Node > ret = new  Array List < > ( ) ; for (  Try Catch Block Node try Catch Block Node : try Catch Block Nodes ) {  Integer start Idx = label Positions . get ( try Catch Block Node . start ) ;  Integer end Idx = label Positions . get ( try Catch Block Node . end ) ;  Validate . is True ( start Idx != null ) ;  Validate . is True ( end Idx != null ) ; if ( insn Node Idx >= start Idx && insn Node Idx < end Idx ) { ret . add ( try Catch Block Node ) ; } } return ret ; }
public static  String check Not Empty (  String string ,  Object error Message ) { if (  Exo Player Library Info .  ASSERTIONS_ ENABLED &&  Text Utils . is Empty ( string ) ) { throw new  Illegal Argument Exception (  String . value Of ( error Message ) ) ; } return string ; }
public void shutdown Now ( ) { if ( pool Running ( ) ) { try {  Thread . sleep ( _ NUM ) ; } catch (  Exception e ) { } } if ( image Download Executor != null && ! image Download Executor . is Terminated ( ) ) { image Download Executor . shutdown Now ( ) ; } if ( unnamed Task Executor != null && ! unnamed Task Executor . is Terminated ( ) ) { unnamed Task Executor . shutdown Now ( ) ; } if ( download Executor != null && ! download Executor . is Terminated ( ) ) { download Executor . shutdown Now ( ) ; } if ( main Task Executor != null && ! main Task Executor . is Terminated ( ) ) { main Task Executor . shutdown Now ( ) ; } if ( scheduler != null && ! scheduler . is Terminated ( ) ) { scheduler . shutdown Now ( ) ; } }
private char read Escape Character ( ) throws  IOException { if ( pos == limit && ! fill Buffer ( _ NUM ) ) { throw syntax Error ( _ STR ) ; } char escaped = buffer [ pos ++ ] ; switch ( escaped ) { case _ STR : if ( pos + _ NUM > limit && ! fill Buffer ( _ NUM ) ) { throw syntax Error ( _ STR ) ; }  String hex = string Pool . get ( buffer , pos , _ NUM ) ; pos += _ NUM ; return ( char )  Integer . parse Int ( hex , _ NUM ) ; case _ STR : return _ STR ; case _ STR : return _ STR ; case _ STR : return _ STR ; case _ STR : return _ STR ; case _ STR : return _ STR ; case _ STR : case _ STR : case _ STR : default : return escaped ; } }
private void fix Spanned With Spaces (  Spannable String Builder builder , int width Measure Spec , int height Measure Spec ) { long start Fix =  System . current Time Millis ( ) ;  Fixing Result result = add Spaces Around Spans Until Fixed ( builder , width Measure Spec , height Measure Spec ) ; if ( result . fixed ) { remove Unneeded Spaces ( width Measure Spec , height Measure Spec , builder , result ) ; } else { fallback To String ( width Measure Spec , height Measure Spec ) ; } if (  Build Config .  DEBUG ) { long fix Duration =  System . current Time Millis ( ) - start Fix ;  Log . d (  Html Text View .  TAG , _ STR + fix Duration ) ; } }
public  Count Integration Test ( ) { set Response Log Length Limit ( _ NUM ) ; date Format = new  Simple Date Format ( _ STR ) ;  Calendar cal =  Calendar . get Instance ( ) ; cal . add (  Calendar .  DATE , - _ NUM ) ; yesterday = date Format . format ( cal . get Time ( ) ) ; yesterday += _ STR ; cal =  Calendar . get Instance ( ) ; cal . add (  Calendar .  DATE , _ NUM ) ; today = date Format . format ( cal . get Time ( ) ) ; today += _ STR ; cal =  Calendar . get Instance ( ) ; cal . add (  Calendar .  DATE , _ NUM ) ; tomorrow = date Format . format ( cal . get Time ( ) ) ; tomorrow += _ STR ; cal =  Calendar . get Instance ( ) ; cal . add (  Calendar .  DATE , _ NUM ) ; tomorrow Plus3 = date Format . format ( cal . get Time ( ) ) ; tomorrow Plus3 += _ STR ; cal =  Calendar . get Instance ( ) ; cal . add (  Calendar .  DATE , _ NUM ) ; tomorrow Plus2 = date Format . format ( cal . get Time ( ) ) ; tomorrow Plus2 += _ STR ; cal =  Calendar . get Instance ( ) ; cal . add (  Calendar .  DATE , _ NUM ) ; tomorrow Plus1 = date Format . format ( cal . get Time ( ) ) ; tomorrow Plus1 += _ STR ; cal =  Calendar . get Instance ( ) ; cal . add (  Calendar .  DATE , - _ NUM ) ; yesterday Minus3 = date Format . format ( cal . get Time ( ) ) ; yesterday Minus3 += _ STR ; experiment =  Experiment Factory . create Experiment ( ) ; experiment . start Time = yesterday ; experiment . end Time = tomorrow Plus3 ; experiment . sampling Percent = _ NUM ; experiment . label = _ STR ; experiment . application Name =  QBO +  UUID . random UUID ( ) ;  Default Name Exclusion Strategy experiment Comparison Strategy = new  Default Name Exclusion Strategy ( _ STR , _ STR , _ STR ) ; experiment . set Serialization Strategy ( experiment Comparison Strategy ) ; }
default  Filterable <  T > retain All ( final  Stream < ? extends  T > stream ) { final  Set <  T > set = stream . collect (  Collectors . to Set ( ) ) ; return filter ( null ) ; }
@  Override public boolean is Inside (  Point point ) { return attack Poly . contains ( point . x - bounds . x , point . y - bounds . y ) ; }
@  Suppress Warnings ( _ STR ) private static void load Extensions ( final  Class Loader class Loader ) { for ( final  Map .  Entry <  Class ,  Set <  Class > > entry : definition Map . entry Set ( ) ) { final  Service Loader < ? > service Loader =  Service Loader . load ( entry . get Key ( ) , class Loader ) ; for ( final  Object o : service Loader ) { register Service Class ( o . get Class ( ) , extension Classloader Lookup , class Loader , entry . get Value ( ) ) ; } } }
public static  Inet Address find Inet Address ( ) throws  Socket Exception ,  Unknown Host Exception { final  Enumeration <  Network Interface > enum1 =  Network Interface . get Network Interfaces ( ) ; if ( enum1 == null ) { final  Inet Address ip1 =  Inet Address . get Local Host ( ) ; return ip1 ; } final  List <  Inet Address > all But Loopback = new  Array List < > ( ) ; while ( enum1 . has More Elements ( ) ) { final  Network Interface netface = enum1 . next Element ( ) ; final  Enumeration <  Inet Address > enum2 = netface . get Inet Addresses ( ) ; while ( enum2 . has More Elements ( ) ) { final  Inet Address ip2 = enum2 . next Element ( ) ; if ( ! ip2 . is Loopback Address ( ) ) { all But Loopback . add ( ip2 ) ; } } } for ( final  Inet Address address : all But Loopback ) { if ( address . get Address ( ) . length == _ NUM && ! is Private Network Address ( address ) ) { return address ; } } for ( final  Inet Address address : all But Loopback ) { if ( ! is Private Network Address ( address ) ) { return address ; } } for ( final  Inet Address address : all But Loopback ) { if ( ! address . is Link Local Address ( ) ) { return address ; } } return  Inet Address . get Local Host ( ) ; }
private  Bitmap compress (  String image Path , int width , int height ) {  Bitmap Factory .  Options options = new  Bitmap Factory .  Options ( ) ; options . in Just Decode Bounds = _ BOOL ;  Bitmap Factory . decode File ( image Path , options ) ; int out H = options . out Height ; int out W = options . out Width ; int in Sample Size = _ NUM ; if ( out H > height || out W > width ) { int half H = out H / _ NUM ; int half W = out W / _ NUM ; while ( ( half H / in Sample Size ) > height && ( half W / in Sample Size ) > width ) { in Sample Size *= _ NUM ; } } options . in Sample Size = in Sample Size ; options . in Just Decode Bounds = _ BOOL ; int height Ratio = ( int )  Math . ceil ( options . out Height / ( float ) height ) ; int width Ratio = ( int )  Math . ceil ( options . out Width / ( float ) width ) ; if ( height Ratio > _ NUM || width Ratio > _ NUM ) { if ( height Ratio > width Ratio ) { options . in Sample Size = height Ratio ; } else { options . in Sample Size = width Ratio ; } } options . in Just Decode Bounds = _ BOOL ; return  Bitmap Factory . decode File ( image Path , options ) ; }
public static boolean is Sync Status (  Context context ,  String status ) { if (  Text Utils . is Empty ( status ) ) { return _ BOOL ; }  String [ ] statuses = get Sync Statuses ( context ) ; if ( statuses == null ) { return _ BOOL ; } for (  String s : statuses ) { if ( s . equals ( status ) ) { return _ BOOL ; } } return _ BOOL ; }
@  Override public  String to String ( ) { return _ STR + xmin + _ STR + xmax + _ STR + ymin + _ STR + ymax + _ STR ; }
public void remove Channel Map (  Channel Map channel Map ) { if ( m Channel Maps . contains ( channel Map ) ) { int index = m Channel Maps . index Of ( channel Map ) ; m Channel Maps . remove ( channel Map ) ; fire Interval Removed ( this , index , index ) ; broadcast ( new  Channel Map Event ( channel Map ,  Event .  DELETE ) ) ; } }
public boolean offer (  E o ) { if ( null == o ) { throw new  Null Pointer Exception ( ) ; } grow To Size ( size + _ NUM ) ; elements [ size ] = o ; sift Up ( size ++ ) ; return _ BOOL ; }
@  Suppress Warnings ( _ STR ) public  Object put (  Object key ,  Object value ) {  Object orig = remove ( key ) ; result . put ( key , value ) ; return orig ; }
public  Id Range [ ] parse Id Range (  Imap Session session ) throws  Decoding Exception { if ( session != null ) { char c = next Word Char ( ) ; if ( c == _ STR ) { consume ( ) ; return  Search Res Util . get Saved Sequence Set ( session ) ; } }  Character Validator validator = new  Message Set Char Validator ( ) ;  String next Word = consume Word ( validator , _ BOOL ) ; int comma Pos = next Word . index Of ( _ STR ) ; if ( comma Pos == - _ NUM ) { return new  Id Range [ ] { parse Range ( next Word ) } ; }  Array List <  Id Range > range List = new  Array List <  Id Range > ( ) ; int pos = _ NUM ; while ( comma Pos != - _ NUM ) {  String range = next Word . substring ( pos , comma Pos ) ;  Id Range set = parse Range ( range ) ; range List . add ( set ) ; pos = comma Pos + _ NUM ; comma Pos = next Word . index Of ( _ STR , pos ) ; }  String range = next Word . substring ( pos ) ; range List . add ( parse Range ( range ) ) ;  List <  Id Range > merged =  Id Range . merge Ranges ( range List ) ; return (  Id Range [ ] ) merged . to Array ( new  Id Range [ merged . size ( ) ] ) ; }
private  String remove Suffix (  String value ,  String to Remove ) { if ( ( value == null ) || ( to Remove == null ) || ! suffix ( value , to Remove ) ) { return value ; } return value . substring ( _ NUM , value . length ( ) - to Remove . length ( ) ) ; }
private static <  T > boolean complete Task (  Vi PRTask Monitor <  T > task ,  Vi PRTask Handler <  T > handler ) { try {  T value = task . get Value ( ) ; handler . on Success ( task . get Task ( ) , value ) ; return _ BOOL ; } catch (  Execution Exception e ) { handler . on Failure ( task . get Task ( ) , e ) ; return _ BOOL ; } }
private static boolean create Zynamics Directory ( ) { final  File dir = new  File (  Config Helper . get Zynamics Directory (  Constants .  COMPANY_ NAME ) ) ; return dir . exists ( ) || dir . mkdir ( ) ; }
public void update Button Action Performed ( ) { node Type = node Type Box . get Selected Index ( ) ; log . debug ( _ STR + cur Node . get Node Type ( ) + _ STR + node Type ) ; if ( cur Node . get Node Type ( ) != node Type ) { cur Node . set Node Type ( node Type ) ; } set Node Parameters ( ) ; changed Node = _ BOOL ; edit Mode = _ BOOL ; cur Node = null ; add Button . set Visible ( _ BOOL ) ; edit Button . set Visible ( _ BOOL ) ; delete Button . set Visible ( _ BOOL ) ; done Button . set Visible ( _ BOOL ) ; update Button . set Visible ( _ BOOL ) ; cancel Button . set Visible ( _ BOOL ) ; node Addr Field . set Visible ( _ BOOL ) ; node Addr Static . set Visible ( _ BOOL ) ; status Text2 . set Text ( std Status2 ) ; status Text3 . set Text ( std Status3 ) ; status Text1 . set Text ( rb . get String ( _ STR ) + _ STR +  Integer . to String ( node Address ) ) ; error In Status1 = _ BOOL ; }
public  Weight Matrix Viewer (  List <  Neuron > source List ,  List <  Neuron > target List ,  Network Panel panel ) { init ( source List , target List , panel ) ; }
public void update Track Point (  Point p ) { int new Loc X =  Math . min ( p . x , this . anchor . x ) ; int new Loc Y =  Math . min ( p . y , this . anchor . y ) ; int delta X =  Math . abs ( p . x - this . anchor . x ) ; int delta Y =  Math . abs ( p . y - this . anchor . y ) ; set Location ( new Loc X , new Loc Y ) ; set Size ( delta X , delta Y ) ; }
private static  Map <  String ,  Snmp Oid > build Pool Index Map (  Snmp Table Handler handler ) { if ( handler instanceof  Snmp Cached Data ) return build Pool Index Map ( (  Snmp Cached Data ) handler ) ; final  Map <  String ,  Snmp Oid > m = new  Hash Map < > ( ) ;  Snmp Oid index = null ; while ( ( index = handler . get Next ( index ) ) != null ) { final  Memory Pool MXBean mpm = (  Memory Pool MXBean ) handler . get Data ( index ) ; if ( mpm == null ) continue ; final  String name = mpm . get Name ( ) ; if ( name == null ) continue ; m . put ( name , index ) ; } return m ; }
public  DCrypto Strength (  JDialog parent ,  Dialog .  Modality Type modality ) throws  Crypto Exception { super ( parent , res . get String ( _ STR ) , modality ) ; init Components ( ) ; }
public static  Component create Separator ( ) {  JPanel p = new  JPanel ( ) ; p . set Layout ( new  Border Layout ( ) ) ;  JSeparator separator = new  JSeparator (  Swing Constants .  HORIZONTAL ) ; p . add ( separator ,  Border Layout .  CENTER ) ;  Dimension size = new  Dimension (  FULL_ WIDTH , _ NUM ) ; p . set Preferred Size ( size ) ; return p ; }
public void insert ( final  T object , final int index ) { synchronized ( m Lock ) { m List . add ( index , object ) ; } notify Data Set Changed ( ) ; }
public boolean verify Signature ( byte [ ] signature ) { content Digest . do Final ( m Dash , m Dash . length - h Len - s Len ) ; try { byte [ ] b = cipher . process Block ( signature , _ NUM , signature . length ) ;  System . arraycopy ( b , _ NUM , block , block . length - b . length , b . length ) ; } catch (  Exception e ) { return _ BOOL ; } if ( block [ block . length - _ NUM ] != trailer ) { clear Block ( block ) ; return _ BOOL ; } byte [ ] db Mask = mask Generator Function1 ( block , block . length - h Len - _ NUM , h Len , block . length - h Len - _ NUM ) ; for ( int i = _ NUM ; i != db Mask . length ; i ++ ) { block [ i ] ^= db Mask [ i ] ; } block [ _ NUM ] &= ( _ NUM > > ( ( block . length * _ NUM ) - em Bits ) ) ; for ( int i = _ NUM ; i != block . length - h Len - s Len - _ NUM ; i ++ ) { if ( block [ i ] != _ NUM ) { clear Block ( block ) ; return _ BOOL ; } } if ( block [ block . length - h Len - s Len - _ NUM ] != _ NUM ) { clear Block ( block ) ; return _ BOOL ; }  System . arraycopy ( block , block . length - s Len - h Len - _ NUM , m Dash , m Dash . length - s Len , s Len ) ; content Digest . update ( m Dash , _ NUM , m Dash . length ) ; content Digest . do Final ( m Dash , m Dash . length - h Len ) ; for ( int i = block . length - h Len - _ NUM , j = m Dash . length - h Len ; j != m Dash . length ; i ++ , j ++ ) { if ( ( block [ i ] ^ m Dash [ j ] ) != _ NUM ) { clear Block ( m Dash ) ; clear Block ( block ) ; return _ BOOL ; } } clear Block ( m Dash ) ; clear Block ( block ) ; return _ BOOL ; }
public static final void draw Arc (  GL2 gl , double cx , double cy , double r , double sa , double aa ) { double t ; double x = r ; double y = _ NUM ; t = x ; x =  Math . cos ( sa ) * x -  Math . sin ( sa ) * y ; y =  Math . sin ( sa ) * t +  Math . cos ( sa ) * y ; double sign =  Math . signum ( aa ) ; double cos =  COS ; double sin = sign >= _ NUM ?  SIN : -  SIN ; gl . gl Begin (  GL .  GL_ LINE_ STRIP ) ; for ( int i = _ NUM ; i <  N ; i ++ ) { gl . gl Vertex2d ( x + cx , y + cy ) ; t = x ; x = cos * x - sin * y ; y = sin * t + cos * y ; if (  Math . abs ( cos * i ) >=  Math . abs ( aa ) ) break ; } gl . gl End ( ) ; }
public static void share Channel (  Context context ,  Channel channel ,  Uri bitmap Uri ) {  String share Text =  String . format ( context . get String (  R . string . share_channel_text ) , channel . get Title ( ) , channel . get Site Url ( ) ) ;  Intent intent = new  Intent (  Intent .  ACTION_ SEND ) ; intent . set Type ( _ STR ) ; intent . put Extra (  Intent .  EXTRA_ TEXT , share Text ) ; if ( bitmap Uri != null ) { intent . put Extra (  Intent .  EXTRA_ STREAM , bitmap Uri ) ; }  Intent chooser =  Intent . create Chooser ( intent , context . get String (  R . string . share_with ) ) ; if ( intent . resolve Activity ( context . get Package Manager ( ) ) != null ) { context . start Activity ( chooser ) ; } }
public static int round ( final float x ) { final int bits =  Float . float To Raw Int Bits ( x ) ; final int biased Exp = ( bits > > _ NUM ) & _ NUM ; final int shift = ( _ NUM - _ NUM +  Float .  MAX_ EXPONENT ) - biased Exp ; if ( ( shift & - _ NUM ) == _ NUM ) { int extended Mantissa = _ NUM | ( bits & _ NUM ) ; if ( bits < _ NUM ) { extended Mantissa = - extended Mantissa ; } return ( ( extended Mantissa > > shift ) + _ NUM ) > > _ NUM ; } else { return ( int ) x ; } }
public static  Plain Text plain ( byte text ) { return plain (  Integer . to String ( text ) ) ; }
private void update Accessor Text ( ) { accessor Text . set Text ( _ STR ) ;  String Builder builder = new  String Builder ( ) ; for (  String path : paths ) { builder . append ( _ STR ) ; builder . append ( path ) ; } accessor Text . set Text ( builder . to String ( ) ) ; }
public static synchronized void fit (  String description ,  Unsafe Block block ) { fit ( description , identity ( ) , block ) ; }
public static boolean make Dirs For File ( final  File file ) { if ( file == null ) return _ BOOL ;  Log . d ( _ STR , _ STR + file + _ STR + file . is Directory ( ) ) ; final  String file Parent Dir = file . get Parent ( ) ; final  File file Dir =  Text Utils . is Empty ( file Parent Dir ) ? null : new  File ( file . get Parent ( ) ) ; boolean is Succeed = file Dir == null || file Dir . exists ( ) ; if ( is Succeed )  Log . d ( _ STR , _ STR + file Dir + _ STR + is Succeed ) ; if ( ! is Succeed && file Dir != null ) { is Succeed = file Dir . mkdirs ( ) ;  Log . d ( _ STR , _ STR + file Dir + _ STR + is Succeed ) ; } return is Succeed ; }
public static  String to String ( int [ ] oid ) {  String Builder sb = new  String Builder ( _ NUM * oid . length ) ; for ( int i = _ NUM ; i < oid . length - _ NUM ; ++ i ) { sb . append ( oid [ i ] ) ; sb . append ( _ STR ) ; } sb . append ( oid [ oid . length - _ NUM ] ) ; return sb . to String ( ) ; }
public static void replace Sub Config Attribute Default Values (  String service Name ,  Set sun Service ID ,  String realm ,  String sub Config Name ,  String attribute Name ,  Set old Values ,  Set new Values ) {  String class Method = _ STR ; try {  Service Config Manager scm = get Service Config Manager ( service Name ) ;  Service Config sc = scm . get Organization Config ( realm , null ) ;  Service Config sub Config = sc . get Sub Config ( sub Config Name ) ;  String service ID = get Sun Service ID ( sub Config ) ; if ( debug . message Enabled ( ) ) { debug . message ( _ STR + sun Service ID ) ; debug . message ( _ STR + service ID ) ; debug . message ( _ STR + sub Config Name ) ; } if ( sun Service ID . contains ( service ID ) ) { sub Config . replace Attribute Values ( attribute Name , old Values , new Values ) ; } } catch (  SSOException ssoe ) { debug . error ( class Method + _ STR , ssoe ) ; } catch (  SMSException sme ) { debug . error ( class Method + _ STR + attribute Name , sme ) ; } }
public void read (  Byte Code Parser in ) throws  IOException { int length = in . read Int ( ) ; int exn Count = in . read Short ( ) ; for ( int i = _ NUM ; i < exn Count ; i ++ ) { int index = in . read Short ( ) ; if ( index == _ NUM ) { _methods . add ( null ) ; } } }
void add String ( int c ) { if ( strpos == str . length ) { char newstr [ ] = new char [ str . length * _ NUM ] ;  System . arraycopy ( str , _ NUM , newstr , _ NUM , str . length ) ; str = newstr ; } str [ strpos ++ ] = ( char ) c ; }
public final void compute Index ( ) { if ( index Computed ) { return ; }  List <  Long > cell List =  Lists . new Array List ( ) ;  List <  Integer > edge List =  Lists . new Array List ( ) ; for ( int i = _ NUM ; i < get Num Edges ( ) ; ++ i ) {  S2 Point from = edge From ( i ) ;  S2 Point to = edge To ( i ) ;  Array List <  S2 Cell Id > cover =  Lists . new Array List ( ) ; int level = get Covering ( from , to , _ BOOL , cover ) ; minimum S2 Level Used =  Math . min ( minimum S2 Level Used , level ) ; for (  S2 Cell Id cell Id : cover ) { cell List . add ( cell Id . id ( ) ) ; edge List . add ( i ) ; } } cells = new long [ cell List . size ( ) ] ; edges = new int [ edge List . size ( ) ] ; for ( int i = _ NUM ; i < cells . length ; i ++ ) { cells [ i ] = cell List . get ( i ) ; edges [ i ] = edge List . get ( i ) ; } sort Index ( ) ; index Computed = _ BOOL ; }
public static _ Fields find By Thrift Id ( int field Id ) { switch ( field Id ) { case _ NUM : return  MESSAGE ; case _ NUM : return  TYPE ; default : return null ; } }
private  URL check URL (  URL url ) {  String protocol = url . get Protocol ( ) ; if ( protocol == null ) { throw new  Repository Exception ( repository Name , _ STR + url + _ STR ) ; } for (  String supported Protocol : supported Protocols ) { if ( supported Protocol . equals ( protocol ) ) { try { if (  URIPattern . match ( url White List , url . to URI ( ) ) ) { return url ; } } catch (  URISyntax Exception ex ) { logger . warn ( _ STR , url ) ; throw new  Repository Exception ( repository Name , _ STR + url + _ STR ) ; }  URL normalized Url = environment . resolve Repo URL ( url ) ; if ( normalized Url == null ) { logger . warn ( _ STR , url , environment . repo Files ( ) ) ; throw new  Repository Exception ( repository Name , _ STR + url + _ STR ) ; } return normalized Url ; } } throw new  Repository Exception ( repository Name , _ STR + protocol + _ STR + url + _ STR ) ; }
private int scroll By ( int dy ,  Recycler View .  Recycler recycler ,  Recycler View .  State state ) { int delta = _ NUM ; if ( dy > _ NUM ) { top Border = get Padding Top ( ) ; bottom Border += dy ; m Current Position = last Attached Item Position + _ NUM ; fill Grid ( recycler , state , _ BOOL ) ; if ( span Bottom Min >= bottom Border ) { delta = dy ; bottom Border -= dy ; } else { bottom Border = get Height ( ) - get Padding Bottom ( ) ; if ( span Bottom Max - bottom Border >= dy ) { delta = dy ; } else { delta =  Math . max ( _ NUM , span Bottom Max - bottom Border ) ; } } offset Children Vertical ( - delta ) ; for ( int i = _ NUM ; i < m Span Count ; i ++ ) { span Top [ i ] -= delta ; span Bottom [ i ] -= delta ; } span Top Min -= delta ; span Top Max -= delta ; span Bottom Min -= delta ; span Bottom Max -= delta ; recycle Top Invisible Views ( recycler ) ; } else { top Border += dy ; bottom Border = get Height ( ) - get Padding Bottom ( ) ; if ( first Attached Item Position == - _ NUM || first Attached Item Position >= state . get Item Count ( ) ) { first Attached Item Position = state . get Item Count ( ) - _ NUM ; last Attached Item Position = first Attached Item Position ; m Current Position = first Attached Item Position ; } else { m Current Position = first Attached Item Position - _ NUM ; } fill Grid ( recycler , state , _ BOOL ) ; if ( span Top Max <= top Border ) { delta = dy ; top Border -= dy ; } else { top Border = get Padding Top ( ) ; if ( span Top Min - top Border <= dy ) { delta = dy ; } else { delta = -  Math . max ( _ NUM , top Border - span Top Min ) ; } } offset Children Vertical ( - delta ) ; for ( int i = _ NUM ; i < m Span Count ; i ++ ) { span Top [ i ] -= delta ; span Bottom [ i ] -= delta ; } span Top Min -= delta ; span Top Max -= delta ; span Bottom Min -= delta ; span Bottom Max -= delta ; recycle Bottom Invisible Views ( recycler ) ; } scroll Offset += delta ; return delta ; }
@  Override public  String to String ( ) { if ( get User Object ( ) instanceof  Tv Show ) {  Tv Show tv Show = (  Tv Show ) get User Object ( ) ; return tv Show . get Title ( ) ; } return super . to String ( ) ; }
public boolean is Empty ( ) { return hmap . is Empty ( ) ; }
public static  String geometry To WKB (  Geometry g ,  Coordinate Transformation transformation ) {  String Builder wkb = new  String Builder (  BIG_ ENDIAN ) ; if ( g instanceof  Point ) { wkb . append (  WKB_ POINT ) ; } else if ( g instanceof  Line String ) { wkb . append (  WKB_ LINE_ STRING ) ; } else if ( g instanceof  Multi Line String ) { wkb . append (  WKB_ MULTI_ LINE_ STRING ) ; } for (  Coordinate coordinate : g . get Coordinates ( ) ) {  Coord c = transformation . transform (  MGC . coordinate2 Coord ( coordinate ) ) ; wkb . append (  Long . to Hex String (  Double . double To Raw Long Bits ( c . get X ( ) ) ) ) ; wkb . append (  Long . to Hex String (  Double . double To Raw Long Bits ( c . get Y ( ) ) ) ) ; } return wkb . to String ( ) ; }
public  String format String ( final  String str To Format ) { if ( str To Format != null ) { if ( str To Format . equals Ignore Case ( _ STR ) ) return _ STR ; final  String valn1 = str To Format . replace All ( _ STR , _ STR ) ; final  String formt Str = valn1 . replace All ( _ STR , _ STR ) ; return formt Str . replace All ( _ STR , _ STR ) ; } else return _ STR ; }
public  JSONTokener (  Reader reader ) { this . reader = reader . mark Supported ( ) ? reader : new  Buffered Reader ( reader ) ; this . eof = _ BOOL ; this . use Previous = _ BOOL ; this . previous = _ NUM ; this . index = _ NUM ; this . character = _ NUM ; this . line = _ NUM ; }
public static int parse Int Default ( final  String s , final int def ) { if ( s == null ) { return def ; } int r ; try { r =  Integer . parse Int ( s ) ; } catch ( final  Number Format Exception e ) { r = def ; } return r ; }
public  Profile import Profile (  Profile profile ) throws  Business Exception ,  JAXBException ,  IOException { if ( null == profile . get Id ( ) ) { throw new  Business Exception ( _ STR + profile . get Name ( ) + _ STR ,  Configuration Interface Error Code Enum .  IMPORT_ DATA_ NOT_ VALID ) ; } profile . set Import Date ( new  Date ( ) ) ; if ( existing Profiles . contains Key ( profile . get Id ( ) ) ) {  Profile old = existing Profiles . replace ( profile . get Id ( ) , profile ) ;  Files . delete If Exists ( path Resolver . get Profile File Path ( old ) ) ; } else { existing Profiles . put ( profile . get Id ( ) , profile ) ; } save Profile ( profile ) ; return profile ; }
private void print UC ( int c ) { if ( c > _ NUM ) { out . print ( _ STR ) ; if ( c < _ NUM ) out . print ( _ STR ) ; out . print (  Integer . to Hex String ( c ) ) ; } else { out . print ( _ STR ) ; out . print (  Integer . to Octal String ( c ) ) ; } }
public static void create Views (  List <  Block > blocks ,  Block View Factory view Factory ,  Connection Manager connection Manager ,  Workspace View workspace View ) { for ( int i = _ NUM ; i < blocks . size ( ) ; i ++ ) { workspace View . add View ( view Factory . build Block Group Tree ( blocks . get ( i ) , connection Manager , null ) ) ; } }
protected void clear All Data (  SSOToken ID token ID ) { boolean removed = _ BOOL ;  String key = token ID . to String ( ) ; synchronized ( map Token IDs ) { removed = ( map Token IDs . remove ( key ) != null ) ; } }
public  DSubject Alternative Name (  JDialog parent , byte [ ] value ) throws  IOException { super ( parent ) ; set Title ( res . get String ( _ STR ) ) ; init Components ( ) ; prepopulate With Value ( value ) ; }
public  File Operation Failed Exception (  String operation ,  String entity ,  String name ) { super (  String . format ( _error Message , operation , entity , name ) ) ; }
private static void copy File (  Input Stream stream ,  Output Stream out Stream ) throws  IOException { int len ; final byte [ ] buffer = new byte [  Carbon Common Constants .  BYTEBUFFER_ SIZE ] ; try { for ( ; ; ) { len = stream . read ( buffer ) ; if ( len == - _ NUM ) { return ; } out Stream . write ( buffer , _ NUM , len ) ; } } catch (  IOException e ) { throw e ; } finally {  Carbon Util . close Streams ( stream , out Stream ) ; } }
public static final void shuffle ( double [ ] a , int start , int len ,  Random r ) { for ( int i = start + len ; i > _ NUM ; -- i ) { double t = a [ i ] ; int j = r . next Int ( i ) ; a [ i ] = a [ j ] ; a [ j ] = t ; } }
public  SIPHeader parse SIPHeader (  String header ) throws  Parse Exception { int start = _ NUM ; int end = header . length ( ) - _ NUM ; try { while ( header . char At ( start ) <= _ NUM ) start ++ ; while ( header . char At ( end ) <= _ NUM ) end -- ; } catch (  Array Index Out Of Bounds Exception e ) { throw new  Parse Exception ( _ STR , _ NUM ) ; }  String Buffer buffer = new  String Buffer ( end + _ NUM ) ; int i = start ; int line Start = start ; boolean end Of Line = _ BOOL ; while ( i <= end ) { char c = header . char At ( i ) ; if ( c == _ STR || c == _ STR ) { if ( ! end Of Line ) { buffer . append ( header . substring ( line Start , i ) ) ; end Of Line = _ BOOL ; } } else { if ( end Of Line ) { end Of Line = _ BOOL ; if ( c == _ STR || c == _ STR ) { buffer . append ( _ STR ) ; line Start = i + _ NUM ; } else { line Start = i ; } } } i ++ ; } buffer . append ( header . substring ( line Start , i ) ) ; buffer . append ( _ STR ) ;  Header Parser hp =  Parser Factory . create Parser ( buffer . to String ( ) ) ; if ( hp == null ) throw new  Parse Exception ( _ STR , _ NUM ) ; return hp . parse ( ) ; }
private static int convert Linear RGBto SRGB ( int color ) { float input , output ; input = color / _ NUM ; if ( input <= _ NUM ) { output = input * _ NUM ; } else { output = ( _ NUM * ( ( float )  Math . pow ( input , ( _ NUM / _ NUM ) ) ) ) - _ NUM ; } return  Math . round ( output * _ NUM ) ; }
public void record End ( long metric , boolean success ) { final  String msg = _ STR + m Module Name + _ STR + m Run Id + _ STR + metric + _ STR + success ; m Usage Messages . add ( msg ) ;  Diagnostic . developer Log ( msg ) ; m Client . record End ( metric , m Module Name , m Run Id , success ) ; }
static float rotate X ( float p X , float p Y , float c X , float c Y , float angle In Degrees ) { double angle =  Math . to Radians ( angle In Degrees ) ; return ( float ) (  Math . cos ( angle ) * ( p X - c X ) -  Math . sin ( angle ) * ( p Y - c Y ) + c X ) ; }
public boolean is Pronounceable (  String word ) {  String lower Case Word = word . to Lower Case ( ) ; if ( prefix FSM == null || suffix FSM == null ) { throw new  Error ( _ STR ) ; } else { return ( prefix FSM . accept ( lower Case Word ) && suffix FSM . accept ( lower Case Word ) ) ; } }
public void compute Edge Ends (  Edge edge ,  List l ) {  Edge Intersection List ei List = edge . get Edge Intersection List ( ) ; ei List . add Endpoints ( ) ;  Iterator it = ei List . iterator ( ) ;  Edge Intersection ei Prev = null ;  Edge Intersection ei Curr = null ; if ( ! it . has Next ( ) ) return ;  Edge Intersection ei Next = (  Edge Intersection ) it . next ( ) ; do { ei Prev = ei Curr ; ei Curr = ei Next ; ei Next = null ; if ( it . has Next ( ) ) ei Next = (  Edge Intersection ) it . next ( ) ; if ( ei Curr != null ) { create Edge End For Prev ( edge , l , ei Curr , ei Prev ) ; create Edge End For Next ( edge , l , ei Curr , ei Next ) ; } } while ( ei Curr != null ) ; }
public  Core Admin Handler ( final  Core Container core Container ) { this . core Container = core Container ;  Hash Map <  String ,  Map <  String ,  Task Object > > map = new  Hash Map < > ( _ NUM , _ NUM ) ; map . put (  RUNNING ,  Collections . synchronized Map ( new  Linked Hash Map <  String ,  Task Object > ( ) ) ) ; map . put (  COMPLETED ,  Collections . synchronized Map ( new  Linked Hash Map <  String ,  Task Object > ( ) ) ) ; map . put (  FAILED ,  Collections . synchronized Map ( new  Linked Hash Map <  String ,  Task Object > ( ) ) ) ; request Status Map =  Collections . unmodifiable Map ( map ) ; }
public  Bitmap decode Best Region ( int required Width , int required Height , int gravity ) { boolean upscaling = _ BOOL ; int real Width = get Width ( ) ; int real Height = get Height ( ) ;  Bitmap Factory .  Options options = new  Bitmap Factory .  Options ( ) ; if ( ! ( required Width <= real Width && required Height <= real Height ) ) { float width Ratio = ( float ) required Width / real Width ; float height Ratio = ( float ) required Height / real Height ; float destination Ratio =  Math . max ( width Ratio , height Ratio ) ; required Width =  Math . round ( ( ( float ) required Width / destination Ratio ) ) ; required Height =  Math . round ( ( ( float ) required Height / destination Ratio ) ) ; upscaling = _ BOOL ; } boolean limit Reached = _ BOOL ; int base Pow = _ NUM ; int actual Scale ; while ( ! limit Reached ) { actual Scale = ( int )  Math . pow ( _ NUM , base Pow + _ NUM ) ; if ( required Width <= real Width / actual Scale && required Height <= real Height / actual Scale ) { base Pow ++ ; } else { limit Reached = _ BOOL ; } } options . in Sample Size = ( int )  Math . pow ( _ NUM , base Pow ) ; int from Top = _ NUM ; int from Left = _ NUM ; if ( gravity ==  Gravity .  CENTER ) { from Top = ( real Height - required Height * options . in Sample Size ) / _ NUM ; from Left = ( real Width - required Width * options . in Sample Size ) / _ NUM ; } else { int horizontal Gravity = gravity &  Gravity .  HORIZONTAL_ GRAVITY_ MASK ; int vertical Gravity = gravity &  Gravity .  VERTICAL_ GRAVITY_ MASK ; if ( horizontal Gravity ==  Gravity .  LEFT ) from Left = _ NUM ; else if ( horizontal Gravity ==  Gravity .  RIGHT ) from Left = real Width - required Width * options . in Sample Size ; else if ( horizontal Gravity ==  Gravity .  CENTER_ HORIZONTAL ) from Left = ( real Width - required Width * options . in Sample Size ) / _ NUM ; if ( vertical Gravity ==  Gravity .  TOP ) from Top = _ NUM ; else if ( vertical Gravity ==  Gravity .  BOTTOM ) from Top = real Height - required Height * options . in Sample Size ; else if ( vertical Gravity ==  Gravity .  CENTER_ VERTICAL ) from Top = ( real Height - required Height * options . in Sample Size ) / _ NUM ; }  Rect area = new  Rect ( from Left , from Top , from Left + required Width * options . in Sample Size , from Top + required Height * options . in Sample Size ) ; return impl . decode Region ( area , options ) ; }
public void enable Buttons ( boolean b ) { pub Button . set Enabled ( b ) ; }
public void mouse Exited (  Mouse Event e ) { if (  Debug . debugging ( _ STR ) ) {  Debug . output ( get ID ( ) + _ STR ) ; } super . mouse Exited ( e ) ; if ( the Map == e . get Source ( ) ) { auto Zoom = _ BOOL ; point2 = null ; the Map . repaint ( ) ; } }
@  Override public void force Refetch (  String url ,  Web Page page , boolean asap ) { if ( page . get Fetch Interval ( ) > max Interval ) page . set Fetch Interval (  Math . round ( max Interval * _ NUM ) ) ; page . set Status ( ( int )  Crawl Status .  STATUS_ UNFETCHED ) ; page . set Retries Since Fetch ( _ NUM ) ; page . set Modified Time ( _ NUM ) ; if ( asap ) page . set Fetch Time (  System . current Time Millis ( ) ) ; }
public  Ids Query Builder add Ids (  Collection <  String > ids ) { values . add All ( ids ) ; return this ; }
private void skip (  Http Servlet Request request ,  Http Servlet Response response ) throws  IOException {  Print Writer out = response . get Writer ( ) ;  String label = request . get Parameter ( _ STR ) ;  Monitor mon = remove Mon ( label , null ,  DEFAULT_ UNITS ) ; if ( mon == null ) { out . println (  ERROR + _ STR ) ; } else { mon . skip ( ) ; out . println (  OK + _ STR + mon ) ; } }
public  URI (  String scheme ,  String authority ,  String path ,  String query ,  String fragment ) throws  URISyntax Exception { if ( scheme != null && path != null && ! path . is Empty ( ) && path . char At ( _ NUM ) != _ STR ) { throw new  URISyntax Exception ( path , _ STR ) ; }  String Builder uri = new  String Builder ( ) ; if ( scheme != null ) { uri . append ( scheme ) ; uri . append ( _ STR ) ; } if ( authority != null ) { uri . append ( _ STR ) ;  AUTHORITY_ ENCODER . append Encoded ( uri , authority ) ; } if ( path != null ) {  PATH_ ENCODER . append Encoded ( uri , path ) ; } if ( query != null ) { uri . append ( _ STR ) ;  ALL_ LEGAL_ ENCODER . append Encoded ( uri , query ) ; } if ( fragment != null ) { uri . append ( _ STR ) ;  ALL_ LEGAL_ ENCODER . append Encoded ( uri , fragment ) ; } parse URI ( uri . to String ( ) , _ BOOL ) ; }
public void copy (  File in ,  File out ) throws  IOException {  Input Stream is = null ;  Output Stream os = null ; try { is = new  Buffered File Input Stream ( in ) ; os = new  Buffered File Output Stream ( out ) ; } catch (  IOException ioe ) { close EL ( is , os ) ; throw ioe ; } copy ( is , os , _ BOOL , _ BOOL ) ; }
public void commit ( ) throws  JMSException { ensure Open ( ) ; ensure TX ( ) ; if ( _logger . is Loggable (  Level .  FINE ) ) { _logger . fine ( _ STR + _tx ) ; } try { send Messages ( this . sent Messages , _tx ) ; if ( _logger . is Loggable (  Level .  FINE ) ) { _logger . fine ( _ STR + _tx ) ; } commit Local Transaction ( ) ; renew Transaction ( ) ; } catch (  JMSException mf E ) { if ( _logger . is Loggable (  Level .  SEVERE ) ) { _logger . log (  Level .  SEVERE , _ STR , mf E ) ; _logger . log (  Level .  SEVERE , _ STR + _tx ) ; } try { rollback ( ) ; } catch (  JMSException e ) { if ( _logger . is Loggable (  Level .  SEVERE ) ) { _logger . log (  Level .  SEVERE , _ STR + _tx , e ) ; } }  Transaction Rolled Back Exception t E = new  Transaction Rolled Back Exception ( _ STR ) ; t E . set Linked Exception ( mf E ) ; throw t E ; } catch (  Transaction Exception te ) { if ( _logger . is Loggable (  Level .  SEVERE ) ) { _logger . log (  Level .  SEVERE , _ STR , te ) ; _logger . log (  Level .  SEVERE , _ STR + _tx ) ; } try { rollback ( ) ; } catch (  JMSException e ) { if ( _logger . is Loggable (  Level .  SEVERE ) ) { _logger . log (  Level .  SEVERE , _ STR + _tx , e ) ; } }  Transaction Rolled Back Exception e = new  Transaction Rolled Back Exception ( _ STR ) ; e . set Linked Exception ( te ) ; throw e ; } catch (  Remote Exception re ) { if ( _logger . is Loggable (  Level .  SEVERE ) ) { _logger . log (  Level .  SEVERE , _ STR , re ) ; _logger . log (  Level .  SEVERE , _ STR + _tx ) ; } try { rollback ( ) ; } catch (  JMSException e ) { }  Transaction Rolled Back Exception e = new  Transaction Rolled Back Exception ( _ STR ) ; e . set Linked Exception ( re ) ; throw e ; } catch (  Commit Failed Exception cfe ) { if ( _logger . is Loggable (  Level .  SEVERE ) ) { _logger . log (  Level .  SEVERE , _ STR , cfe . orig ) ; _logger . log (  Level .  SEVERE , _ STR + _tx ) ; } try { rollback ( ) ; } catch (  JMSException e ) { if ( _logger . is Loggable (  Level .  SEVERE ) ) { _logger . log (  Level .  SEVERE , _ STR + _tx , e ) ; } }  Transaction Rolled Back Exception e = new  Transaction Rolled Back Exception ( _ STR + _tx + _ STR ) ; e . set Linked Exception ( cfe . orig ) ; throw e ; } catch (  Transaction Create Exception tce ) { if ( _logger . is Loggable (  Level .  SEVERE ) ) { _logger . log (  Level .  SEVERE , _ STR , tce . orig ) ; _logger . log (  Level .  SEVERE , _ STR + _tx ) ; }  JMSException e = new  JMSException ( _ STR ) ; e . set Linked Exception ( tce . orig ) ; throw e ; } finally { sent Messages . clear ( ) ; unacked Messages . clear ( ) ; } }
private  Start build (  Start event ) {  Iterator <  Attribute > list = event . get Attributes ( ) ; while ( list . has Next ( ) ) {  Attribute node = list . next ( ) ;  Entry entry = attribute ( node ) ; if ( ! entry . is Reserved ( ) ) { event . add ( entry ) ; } } return event ; }
public  List <  Boundary > populate Locations ( final  Long area Id ) {  List <  Boundary > location List = new  Linked List <  Boundary > ( ) ; try { location List = boundary Service . get Child Boundaries By Boundary Id ( area Id ) ; } catch ( final  Exception e ) {  LOGGER . error ( _ STR + e . get Message ( ) ) ; throw new  Application Runtime Exception ( _ STR , e ) ; }  LOGGER . info ( _ STR + location List . to String ( ) ) ; return location List ; }
private static  String read Name ( byte data [ ] , int offset ,  Hash Set <  Integer > jumps ) throws  IOException { int c = data [ offset ] & _ NUM ; if ( ( c & _ NUM ) == _ NUM ) { c = ( ( c & _ NUM ) << _ NUM ) + ( data [ offset + _ NUM ] & _ NUM ) ; if ( jumps . contains ( c ) ) { throw new  Dns Exception ( _ STR , _ STR ) ; } jumps . add ( c ) ; return read Name ( data , c , jumps ) ; } if ( c == _ NUM ) { return _ STR ; }  String s = new  String ( data , offset + _ NUM , c ) ;  String t = read Name ( data , offset + _ NUM + c , jumps ) ; if ( t . length ( ) > _ NUM ) { s = s + _ STR + t ; } return s ; }
public  Simple String [ ] split ( final char delim ) {  List <  Simple String > all = null ; byte low = ( byte ) ( delim & _ NUM ) ; byte high = ( byte ) ( delim > > _ NUM & _ NUM ) ; int las Pos = _ NUM ; for ( int i = _ NUM ; i < data . length ; i += _ NUM ) { if ( data [ i ] == low && data [ i + _ NUM ] == high ) { byte [ ] bytes = new byte [ i - las Pos ] ;  System . arraycopy ( data , las Pos , bytes , _ NUM , bytes . length ) ; las Pos = i + _ NUM ; if ( all == null ) { all = new  Array List < > ( _ NUM ) ; } all . add ( new  Simple String ( bytes ) ) ; } } if ( all == null ) { return new  Simple String [ ] { this } ; } else { byte [ ] bytes = new byte [ data . length - las Pos ] ;  System . arraycopy ( data , las Pos , bytes , _ NUM , bytes . length ) ; all . add ( new  Simple String ( bytes ) ) ;  Simple String [ ] parts = new  Simple String [ all . size ( ) ] ; return all . to Array ( parts ) ; } }
public double narrow ( ) throws  Operator Failed Exception {  Node Ref i = null , i P = null , j = null , j P = null ; int tries = _ NUM ; int before Moves = get All Valid Narrow Moves ( ) ; while ( tries <  MAX_ TRIES ) { i = tree . get Node (  Math Utils . next Int ( tree . get Node Count ( ) ) ) ; while ( tree . get Root ( ) == i || tree . get Parent ( i , _ NUM ) == tree . get Root ( ) || tree . get Parent ( i , _ NUM ) == tree . get Root ( ) ) { i = tree . get Node (  Math Utils . next Int ( tree . get Node Count ( ) ) ) ; } i P = tree . get Parent ( i , _ NUM ) ; if ( tree . is Reassortment ( i ) &&  Math Utils . next Boolean ( ) ) i P = tree . get Parent ( i , _ NUM ) ; j P = tree . get Parent ( i P , _ NUM ) ; if ( tree . is Reassortment ( i P ) &&  Math Utils . next Boolean ( ) ) j P = tree . get Parent ( i P , _ NUM ) ; j = tree . get Child ( j P , _ NUM ) ; if ( j == i P ) { j = tree . get Child ( j P , _ NUM ) ; } if ( j != i P && i != j && ( tree . get Node Height ( j ) < tree . get Node Height ( i P ) ) && ( tree . get Node Height ( i ) < tree . get Node Height ( j P ) ) ) { break ; } tries += _ NUM ; } if ( tries <  MAX_ TRIES ) { eupdate ARG ( i , j , i P , j P ) ; tree . push Tree Changed Event ( i P ) ; tree . push Tree Changed Event ( j P ) ; } else throw new  Operator Failed Exception ( _ STR ) ; return  Math . log ( ( double ) before Moves / get All Valid Narrow Moves ( ) ) ; }
protected void remove Item ( int index ) { if ( nodes != null && index < nodes . size ( ) ) { nodes . remove ( index ) ; } }
public void add To Global Blacklist (  String host , long timeout ) { if ( is Global Blacklist Enabled ( ) ) { synchronized ( global Blacklist ) { global Blacklist . put ( host , timeout ) ; } } }
public boolean add Node (  Service Node node ) { try { return nodes . add ( node ) ; } catch (  Exception e ) { return _ BOOL ; } }
public double convexity Bias ( final double future Price , final double t , final double  T , final double sigma , final double a ) {  QL . require ( future Price >= _ NUM , _ STR ) ;  QL . require ( t >= _ NUM , _ STR ) ;  QL . require (  T >= t , _ STR ) ;  QL . require ( a >= _ NUM , _ STR ) ; final double delta T = (  T - t ) ; final double temp Delta T = ( _ NUM -  Math . exp ( - a * delta T ) ) / a ; final double half Sigma Square = sigma * sigma / _ NUM ; final double lambda = half Sigma Square * ( _ NUM -  Math . exp ( - _ NUM * a * t ) ) / a * temp Delta T * temp Delta T ; final double temp T = ( _ NUM -  Math . exp ( - a * t ) ) / a ; final double phi = half Sigma Square * temp Delta T * temp T * temp T ; final double z = lambda + phi ; final double future Rate = ( _ NUM - future Price ) / _ NUM ; return ( _ NUM -  Math . exp ( - z ) ) * ( future Rate + _ NUM / (  T - t ) ) ; }
private boolean replace Bad Entry (  KBucket Entry entry ) {  List <  KBucket Entry > entries Ref = entries ; for ( int i = _ NUM , n = entries Ref . size ( ) ; i < n ; i ++ ) {  KBucket Entry e = entries Ref . get ( i ) ; if ( e . needs Replacement ( ) ) { modify Main Bucket ( e , entry ) ; return _ BOOL ; } } return _ BOOL ; }
public void shear ( double shx , double shy ) { current Transform . shear ( shx , shy ) ; try { write Transform ( new  Affine Transform ( _ NUM , shy , shx , _ NUM , _ NUM , _ NUM ) ) ; } catch (  IOException e ) { handle Exception ( e ) ; } }
private static boolean is Supported Add Mirrors Virtual Pool Change For Vplex Distributed (  Volume volume ,  Virtual Pool current Vpool ,  Virtual Pool new Vpool ,  Db Client db Client ,  String Buffer not Supp Reason Buff ) { s_logger . info (  String . format ( _ STR , current Vpool . get Label ( ) , new Vpool . get Label ( ) ) ) ; boolean supported = _ BOOL ; if ( new Vpool . get Max Native Continuous Copies ( ) > _ NUM && new Vpool . get Mirror Virtual Pool ( ) != null ) {  String [ ] include = new  String [ ] {  TYPE ,  VARRAYS ,  REF_ VPOOL ,  HIGH_ AVAILABILITY ,  PROTECTION_ VARRAY_ SETTINGS ,  FAST_ EXPANSION ,  ACLS ,  INACTIVE ,  DRIVE_ TYPE ,  ARRAY_ INFO ,  PROVISIONING_ TYPE ,  PROTOCOLS } ;  String [ ] contain = new  String [ ] {  MATCHED_ POOLS ,  ASSIGNED_ STORAGE_ POOLS } ;  Map <  String ,  Change > changes = analyze Changes ( current Vpool , new Vpool , include , null , contain ) ; if ( ! changes . is Empty ( ) ) { not Supp Reason Buff . append ( _ STR ) ; fill In Not Supported Reasons ( changes , not Supp Reason Buff ) ; return _ BOOL ; } supported = _ BOOL ; }  Virtual Pool current Ha Vpool =  Virtual Pool . get HAVPool ( current Vpool , db Client ) ; if ( current Ha Vpool == null ) { current Ha Vpool = current Vpool ; }  Virtual Pool new Ha Vpool =  Virtual Pool . get HAVPool ( new Vpool , db Client ) ; if ( current Ha Vpool != null && new Ha Vpool != null ) { if ( new Ha Vpool . get Max Native Continuous Copies ( ) > _ NUM && new Ha Vpool . get Mirror Virtual Pool ( ) != null ) {  String [ ] include = new  String [ ] {  TYPE ,  VARRAYS ,  REF_ VPOOL ,  PROTECTION_ VARRAY_ SETTINGS ,  FAST_ EXPANSION ,  ACLS ,  INACTIVE ,  DRIVE_ TYPE ,  ARRAY_ INFO ,  PROVISIONING_ TYPE ,  PROTOCOLS } ;  String [ ] contain = new  String [ ] {  MATCHED_ POOLS ,  ASSIGNED_ STORAGE_ POOLS } ;  Map <  String ,  Change > changes = analyze Changes ( current Ha Vpool , new Ha Vpool , include , null , contain ) ; if ( ! changes . is Empty ( ) ) { not Supp Reason Buff . append ( _ STR ) ; fill In Not Supported Reasons ( changes , not Supp Reason Buff ) ; return _ BOOL ; } supported = _ BOOL ; } } return supported ; }
private void write Object (  Object Output Stream oos ) throws  IOException { oos . default Write Object ( ) ; oos . write Int ( index . size ( ) ) ; for ( int i = _ NUM , sz = index . size ( ) ; i < sz ; ++ i ) { oos . write UTF ( index . get ( i ) ) ; } }
public void add Included Tax (  Big Decimal amt ) { m_included Tax = m_included Tax . add ( amt ) ; }
public static double overlap (  Spatial Comparable box1 ,  Spatial Comparable box2 ) { final int dim = assert Same Dimensionality ( box1 , box2 ) ; double omax , omin ; double overlap = _ NUM ; for ( int i = _ NUM ; i < dim ; i ++ ) { omax =  Math . min ( box1 . get Max ( i ) , box2 . get Max ( i ) ) ; omin =  Math . max ( box1 . get Min ( i ) , box2 . get Min ( i ) ) ; if ( omax <= omin ) { return _ NUM ; } overlap *= omax - omin ; } return overlap ; }
protected void compute Field Polynomial ( ) { if ( test Trinomials ( ) ) { return ; } if ( test Pentanomials ( ) ) { return ; } test Random ( ) ; }
protected final void _load To Have At Least ( int min Available ) throws  IOException { if ( _input Stream == null ) { throw _construct Error ( _ STR + min Available + _ STR ) ; } int amount = _input End - _input Ptr ; if ( amount > _ NUM && _input Ptr > _ NUM ) { _curr Input Processed += _input Ptr ;  System . arraycopy ( _input Buffer , _input Ptr , _input Buffer , _ NUM , amount ) ; _input End = amount ; } else { _input End = _ NUM ; } _input Ptr = _ NUM ; while ( _input End < min Available ) { int count = _input Stream . read ( _input Buffer , _input End , _input Buffer . length - _input End ) ; if ( count < _ NUM ) { _close Input ( ) ; if ( count == _ NUM ) { throw new  IOException ( _ STR + amount + _ STR ) ; } throw _construct Error ( _ STR + min Available + _ STR + min Available + _ STR ) ; } _input End += count ; } }
public  Serial Message ( byte [ ] a , int l ) { super (  String . value Of ( a ) ) ; set Response Length ( l ) ; set Binary ( _ BOOL ) ; }
private  Method Descriptor [ ] introspect Methods ( ) { return introspect Methods ( _ BOOL , bean Class ) ; }
protected  Protected Properties create Metadata (  Element parent ) throws  Exception {  Protected Properties result ;  Properties props ;  Vector <  Element > list ;  Element node ;  Element metanode ; int i ; result = null ; metanode = null ; list = get Child Tags ( parent ,  TAG_ METADATA ) ; if ( list . size ( ) > _ NUM ) { metanode = list . get ( _ NUM ) ; } if ( metanode != null ) { props = new  Properties ( ) ; list = get Child Tags ( metanode ,  TAG_ PROPERTY ) ; for ( i = _ NUM ; i < list . size ( ) ; i ++ ) { node = list . get ( i ) ; props . set Property ( node . get Attribute (  ATT_ NAME ) , get Content ( node ) ) ; } result = new  Protected Properties ( props ) ; } return result ; }
public boolean outer Class Has Annotation (  Annotation annotation ) {  Class < ? > outer = type . get Declaring Class ( ) ; while ( outer != null ) {  Annotation Accessor accessor = new  Annotation Accessor ( supported Annotations , outer , ignore Annotation Failure ) ; if ( accessor . type Has ( annotation ) ) { return _ BOOL ; } outer = outer . get Declaring Class ( ) ; } return _ BOOL ; }
private  String build Tool Tip ( final  List <  Navi Node > nodes ) { final  String Builder tooltip = new  String Builder ( _ STR ) ; boolean first = _ BOOL ; for ( final  Navi Node graph Node : nodes ) { if ( ! first ) { tooltip . append ( _ STR ) ; } tooltip . append (  CNodes Display String . get Display String ( graph Node ) ) ; first = _ BOOL ; } return tooltip + _ STR ; }
public void write Vecor (  File ftrain ,  File ftest ,  File all ,  File train Label ) throws  Exception { int labels [ ] = read Labels ( ) ;  File Writer fw = new  File Writer ( ftrain ) ;  File Writer fwt = new  File Writer ( ftest ) ;  File Writer flabel = new  File Writer ( train Label ) ; for ( int i = _ NUM ; i < data Num ; i ++ ) { if (  Test Train [ i ] == _ NUM ) { flabel . write (  String . value Of ( labels [ i ] ) + _ STR ) ; for ( int j = _ NUM ; j < dimension ; j ++ ) { if ( j != dimension - _ NUM ) { fw . write (  String . value Of (  W [ i ] [ j ] ) + _ STR ) ; } else { fw . write (  String . value Of (  W [ i ] [ j ] ) + _ STR ) ; } } } else { for ( int j = _ NUM ; j < dimension ; j ++ ) { if ( j != dimension - _ NUM ) { fwt . write (  String . value Of (  W [ i ] [ j ] ) + _ STR ) ; } else { fwt . write (  String . value Of (  W [ i ] [ j ] ) + _ STR ) ; } } } } fw . close ( ) ; fwt . close ( ) ; flabel . close ( ) ;  File Writer fwall = new  File Writer ( all ) ; for ( int i = _ NUM ; i < data Num ; i ++ ) { for ( int j = _ NUM ; j < dimension ; j ++ ) { if ( j != dimension - _ NUM ) { fwall . write (  String . value Of (  W [ i ] [ j ] ) + _ STR ) ; } else { fwall . write (  String . value Of (  W [ i ] [ j ] ) + _ STR ) ; } } } fwall . close ( ) ; }
public boolean add On Item Click Listener (  On Item Click Listener item Click Listener ) { return click Listeners . add ( item Click Listener ) ; }
@  Override int look For Selectable Position ( int position , boolean look Down ) { final  List Adapter adapter = m Adapter ; if ( adapter == null || is In Touch Mode ( ) ) { return  INVALID_ POSITION ; } final int count = adapter . get Count ( ) ; if ( ! m Are All Items Selectable ) { if ( look Down ) { position =  Math . max ( _ NUM , position ) ; while ( position < count && ! adapter . is Enabled ( position ) ) { position ++ ; } } else { position =  Math . min ( position , count - _ NUM ) ; while ( position >= _ NUM && ! adapter . is Enabled ( position ) ) { position -- ; } } if ( position < _ NUM || position >= count ) { return  INVALID_ POSITION ; } return position ; } else { if ( position < _ NUM || position >= count ) { return  INVALID_ POSITION ; } return position ; } }
public static  String pad Left ( final  String s , final int length ) { final int pad = length - s . length ( ) ; return pad > _ NUM ? get Space String ( pad ) + s : s ; }
@  Non Null private  List <  String > map Obsolete Elements (  List <  String > names ) {  List <  String > elements To Remove = new  Array List < > ( names . size ( ) ) ; for (  String name : names ) { if ( name . starts With ( _ STR ) ) continue ; elements To Remove . add ( name ) ; } return elements To Remove ; }
public static boolean is Cache Safe (  Class < ? > clazz ,  Class Loader class Loader ) {  Assert . not Null ( clazz , _ STR ) ; try {  Class Loader target = clazz . get Class Loader ( ) ; if ( target == null ) { return _ BOOL ; }  Class Loader cur = class Loader ; if ( cur == target ) { return _ BOOL ; } while ( cur != null ) { cur = cur . get Parent ( ) ; if ( cur == target ) { return _ BOOL ; } } return _ BOOL ; } catch (  Security Exception ex ) { return _ BOOL ; } }
public void write (  Print Stream out ) { out . println ( _ STR ) ; write ( out , first Capitalized ) ; out . println ( _ STR ) ; write ( out , not First Capitalized ) ; out . println ( _ STR ) ; write ( out , table ) ; }
public  Month ( int month , int year ) { if ( ( month < _ NUM ) || ( month > _ NUM ) ) { throw new  Illegal Argument Exception ( _ STR ) ; } this . month = month ; this . year = year ; peg (  Calendar . get Instance ( ) ) ; }
private  Object Stream Class read Class Desc ( boolean unshared ) throws  IOException { byte tc = bin . peek Byte ( ) ;  Object Stream Class descriptor ; switch ( tc ) { case  TC_ NULL : descriptor = (  Object Stream Class ) read Null ( ) ; break ; case  TC_ REFERENCE : descriptor = (  Object Stream Class ) read Handle ( unshared ) ; break ; case  TC_ PROXYCLASSDESC : descriptor = read Proxy Desc ( unshared ) ; break ; case  TC_ CLASSDESC : descriptor = read Non Proxy Desc ( unshared ) ; break ; default : throw new  Stream Corrupted Exception (  String . format ( _ STR , tc ) ) ; } if ( descriptor != null ) { validate Descriptor ( descriptor ) ; } return descriptor ; }
private static boolean is16 Bit Register ( final  String register ) { return register . equals ( _ STR ) || register . equals ( _ STR ) || register . equals ( _ STR ) || register . equals ( _ STR ) || register . equals ( _ STR ) || register . equals ( _ STR ) || register . equals ( _ STR ) || register . equals ( _ STR ) || register . equals ( _ STR ) ; }
@  Override void check After Unmarshalled ( ) { super . check After Unmarshalled ( ) ; assert Equals ( short Val . short Value ( ) , _ NUM ) ; assert Equals ( long Val , _ NUM ) ; assert Null ( a Arr ) ; assert Equals ( double Val , _ NUM ) ; }
@  Override public <  R ,  A >  Completable Future <  R > collect ( final  Collector < ? super  T ,  A ,  R > collector ) { return  Completable Future . supply Async ( null ) ; }
@  Suppress Warnings ( _ STR ) private  Object from Reflection Type ( final  Object value ) {  Field Descriptor descriptor = get Descriptor ( ) ; if ( descriptor . is Repeated ( ) ) { if ( descriptor . get Java Type ( ) ==  Field Descriptor .  Java Type .  MESSAGE || descriptor . get Java Type ( ) ==  Field Descriptor .  Java Type .  ENUM ) { final  List result = new  Array List ( ) ; for ( final  Object element : (  List ) value ) { result . add ( singular From Reflection Type ( element ) ) ; } return result ; } else { return value ; } } else { return singular From Reflection Type ( value ) ; } }
public  List <  MType > build ( ) { is Clean = _ BOOL ; if ( ! is Messages List Mutable && builders == null ) { return messages ; } boolean all Messages In Sync = _ BOOL ; if ( ! is Messages List Mutable ) { for ( int i = _ NUM ; i < messages . size ( ) ; i ++ ) {  Message message = messages . get ( i ) ;  Single Field Builder <  MType ,  BType ,  IType > builder = builders . get ( i ) ; if ( builder != null ) { if ( builder . build ( ) != message ) { all Messages In Sync = _ BOOL ; break ; } } } if ( all Messages In Sync ) { return messages ; } } ensure Mutable Message List ( ) ; for ( int i = _ NUM ; i < messages . size ( ) ; i ++ ) { messages . set ( i , get Message ( i , _ BOOL ) ) ; } messages =  Collections . unmodifiable List ( messages ) ; is Messages List Mutable = _ BOOL ; return messages ; }
public static void show Reil Code ( final  Window parent , final  INavi Code Node code Node ) { try {  CReil Instruction Dialog . show ( parent , code Node ) ; } catch ( final  Internal Translation Exception exception ) {  CUtility Functions . log Exception ( exception ) ; final  String message = _ STR + _ STR ; final  String description =  CUtility Functions . create Description (  String . format ( _ STR , code Node . get Address ( ) ) , new  String [ ] { _ STR } , new  String [ ] { _ STR + _ STR } ) ;  Navi Error Dialog . show ( parent , message , description , exception ) ; } }
public static  String to String (  Reader reader , boolean buffered ) throws  IOException {  String Writer sw = new  String Writer ( _ NUM ) ; if ( buffered ) copy ( to Buffered Reader ( reader ) , sw , - _ NUM ) ; else copy ( reader , sw , - _ NUM ) ; sw . close ( ) ; return sw . to String ( ) ; }
private int compute Number Of Letters In Perfect Overlap (  Lane i Lane ,  Lane j Lane ) { final int first Coordinate =  Math . max ( i Lane . get First Non Gap Position ( ) , j Lane . get First Non Gap Position ( ) ) ; final int last Coordinate =  Math . min ( i Lane . get Last Non Gap Position ( ) , j Lane . get Last Non Gap Position ( ) ) ; int count = _ NUM ; for ( int i = first Coordinate ; i < last Coordinate ; i ++ ) { char i Char =  Character . to Lower Case ( i Lane . char At ( i ) ) ; char j Char =  Character . to Lower Case ( j Lane . char At ( i ) ) ; if ( i Char != j Char && i Char != _ STR && j Char != _ STR ) return _ NUM ; else if (  Character . is Letter ( i Char ) ) count ++ ; } return count ; }
private void on Finished Movement ( ) { check Selection Changed ( ) ; invalidate ( ) ; }
public  String prep Operand (  String label ,  Data Type dt ,  Value Type vt ) {  String Builder sb = new  String Builder ( ) ; sb . append ( label ) ; sb . append (  Lop .  DATATYPE_ PREFIX ) ; sb . append ( dt ) ; sb . append (  Lop .  VALUETYPE_ PREFIX ) ; sb . append ( vt ) ; return sb . to String ( ) ; }
public static  List <  Point2 D > divide Conquer Brownian Bridge ( double  D ,  Point2 D t0y0 ,  Point2 D t1y1 , int depth ,  Space Time Rejector1 D rejector ) {  List <  Point2 D > points = new  Linked List <  Point2 D > ( ) ; points . add ( t0y0 ) ; points . add ( t1y1 ) ; divide Conquer Brownian Bridge (  D , _ NUM , points , depth , rejector ) ; return points ; }
public void test Get Owner Document1 ( ) throws  Throwable {  Document doc ;  Document owner Doc ;  DOMImplementation dom Impl ;  Document Type doc Type ;  String null ID = null ; doc = (  Document ) load ( _ STR , builder ) ; dom Impl = doc . get Implementation ( ) ; doc Type = dom Impl . create Document Type ( _ STR , null ID , null ID ) ; owner Doc = doc Type . get Owner Document ( ) ; assert Null ( _ STR , owner Doc ) ; }
private  List <  Double > to List ( double [ ] x ) {  List <  Double > result = new  Array List <  Double > ( ) ; for ( int i = _ NUM ; i < x . length ; i ++ ) { result . add ( x [ i ] ) ; } return result ; }
public static void mark Text (  JText Component pane , int start , int end ,  Simple Marker marker ) { try {  Highlighter hiliter = pane . get Highlighter ( ) ; int sel Start = pane . get Selection Start ( ) ; int sel End = pane . get Selection End ( ) ; if ( sel Start == sel End || end < sel Start || start > sel Start ) { hiliter . add Highlight ( start , end , marker ) ; return ; } if ( sel Start > start && sel Start < end ) { hiliter . add Highlight ( start , sel Start , marker ) ; } if ( sel End > start && sel End < end ) { hiliter . add Highlight ( sel End , end , marker ) ; } } catch (  Bad Location Exception ex ) {  LOG . log (  Level .  SEVERE , null , ex ) ; } }
public void handle Button1 Request (  Request Invocation Event event ) throws  Model Control Exception { submit Cycle = _ BOOL ;  RMRealm Model model = (  RMRealm Model ) get Model ( ) ;  String realm = (  String ) get Page Session Attribute (  AMAdmin Constants .  CURRENT_ REALM ) ;  AMProperty Sheet ps = (  AMProperty Sheet ) get Child (  REALM_ PROPERTIES ) ; try {  Map orig = model . get Attribute Values ( realm ) ;  Map values = ps . get Attribute Values ( orig , _ BOOL , _ BOOL , model ) ; model . set Attribute Values ( realm , values ) ; set Inline Alert Message (  CCAlert .  TYPE_ INFO , _ STR , _ STR ) ; } catch (  AMConsole Exception e ) { set Inline Alert Message (  CCAlert .  TYPE_ ERROR , _ STR , e . get Message ( ) ) ; } forward To ( ) ; }
private void add Minimized Section (  Composite parent ,  Form Toolkit toolkit ,  String section Title , int num Colums ) {  Section section = toolkit . create Section ( parent ,  Expandable Composite .  TITLE_ BAR |  Expandable Composite .  TWISTIE ) ; section . set Text ( section Title ) ; section . set Layout Data ( new  Grid Data (  SWT .  FILL ,  SWT .  FILL , _ BOOL , _ BOOL ) ) ;  Composite section Composite = toolkit . create Composite ( section ) ;  Grid Layout grid Layout = new  Grid Layout ( num Colums , _ BOOL ) ; grid Layout . margin Left = _ NUM ; grid Layout . margin Top = _ NUM ; section Composite . set Layout ( grid Layout ) ; section . set Client ( section Composite ) ; if ( ! minimized Sections . contains Key ( section Title ) ) { minimized Sections . put ( section Title , section Composite ) ; } }
public  Version Provider ( final  Http Method Client <  Error Response Deserializer Union > http Client ) { this . http Client = http Client ; }
public  ISO9796d2 Signer (  Asymmetric Block Cipher cipher ,  Digest digest , boolean implicit ) { this . cipher = cipher ; this . digest = digest ; if ( implicit ) { trailer =  TRAILER_ IMPLICIT ; } else {  Integer trailer Obj = (  Integer ) trailer Map . get ( digest . get Algorithm Name ( ) ) ; if ( trailer Obj != null ) { trailer = trailer Obj . int Value ( ) ; } else { throw new  Illegal Argument Exception ( _ STR ) ; } } }
public  Serial IO (  String port Name , byte [ ] data Begin , byte [ ] data End ) { this . port Name = port Name ; this . data Begin =  Arrays . copy Of ( data Begin , data Begin . length ) ; this . data End =  Arrays . copy Of ( data End , data End . length ) ; }
public static <  T >  List <  T > find All ( final  Collection <  T > collection , final  Filter <  T > filter ) { final  List <  T > matches = new  Array List <  T > ( collection . size ( ) ) ; for ( final  T element : collection ) { if ( filter . accept ( element ) ) { matches . add ( element ) ; } } return matches ; }
public static boolean is Samsung ( ) { return s Build Model . starts With ( _ STR ) || s Build Model . contains ( _ STR ) || s Build Model . starts With ( _ STR ) || s Build Model . starts With ( _ STR ) || s Build Model . starts With ( _ STR ) ; }
public static  String escape HTML (  String str , short version ) {  String [ ] [ ] data ; int [ ] offset ;  String Builder rtn = new  String Builder ( str . length ( ) ) ; char [ ] chars = str . to Char Array ( ) ; if ( version ==  HTMLV20 ) { data =  HTML20_ DATA ; offset =  HTML20_ OFFSET ; } else if ( version ==  HTMLV32 ) { data =  HTML32_ DATA ; offset =  HTML32_ OFFSET ; } else { data =  HTML40_ DATA ; offset =  HTML40_ OFFSET ; } outer : for ( int i = _ NUM ; i < chars . length ; i ++ ) { char c = chars [ i ] ; if ( c ==  CR ) continue ; for ( int y = _ NUM ; y < offset . length ; y ++ ) { if ( c >= offset [ y ] && c < data [ y ] . length + offset [ y ] ) {  String replacement = data [ y ] [ c - offset [ y ] ] ; if ( replacement != null ) { rtn . append ( _ STR ) ; rtn . append ( replacement ) ; rtn . append ( _ STR ) ; continue outer ; } } } rtn . append ( c ) ; } return rtn . to String ( ) ; }
private  Concurrent Skip List Map .  Node <  K ,  V > lo Node ( ) { if ( lo == null ) return m . find First ( ) ; else if ( lo Inclusive ) return m . find Near ( lo ,  GT |  EQ ) ; else return m . find Near ( lo ,  GT ) ; }
public  String to String ( int num Sets ) { if ( m_sets . size ( ) == _ NUM ) { return _ STR ; }  String Buffer result = new  String Buffer ( ) ; result . append ( _ STR + m_sets . size ( ) + _ STR ) ; if ( num Sets > _ NUM ) { result . append ( _ STR + num Sets ) ; } result . append ( _ STR ) ; int count = _ NUM ; for (  Frequent Binary Item Set i : m_sets ) { if ( num Sets > _ NUM && count > num Sets ) { break ; } result . append ( i . to String ( ) + _ STR ) ; count ++ ; } return result . to String ( ) ; }
public static void normalize ( float [ ] input ) { double norm Sq = _ NUM ; for ( int i = _ NUM ; i < input . length ; ++ i ) { norm Sq += input [ i ] * input [ i ] ; } float norm = ( float )  Math . sqrt ( norm Sq ) ; for ( int i = _ NUM ; i < input . length ; ++ i ) { input [ i ] = input [ i ] / norm ; } }
protected int map Drag Operation From Modifiers (  Mouse Event e ) { int mods = e . get Modifiers Ex ( ) ; int btns = mods &  Button Mask ; if ( ! ( btns ==  Input Event .  BUTTON1_ DOWN_ MASK || btns ==  Input Event .  BUTTON2_ DOWN_ MASK || btns ==  Input Event .  BUTTON3_ DOWN_ MASK ) ) { return  Dn DConstants .  ACTION_ NONE ; } return  Sun Drag Source Context Peer . convert Modifiers To Drop Action ( mods , get Source Actions ( ) ) ; }
public  On Update Clause add Assignment (  Expression expression ) { assignments . add ( new  Assignment ( expression ) ) ; return this ; }
private static void populate Mime Type Icon Mapping ( ) {  MIMETYPE_ TO_ ICON_ MAPPING . put ( _ STR ,  R . drawable . file_image ) ;  MIMETYPE_ TO_ ICON_ MAPPING . put ( _ STR ,  R . drawable . file_text ) ;  MIMETYPE_ TO_ ICON_ MAPPING . put ( _ STR ,  R . drawable . file_image ) ;  MIMETYPE_ TO_ ICON_ MAPPING . put ( _ STR ,  R . drawable . file_image ) ;  MIMETYPE_ TO_ ICON_ MAPPING . put ( _ STR ,  R . drawable . file_image ) ;  MIMETYPE_ TO_ ICON_ MAPPING . put ( _ STR ,  R . drawable . file_code ) ;  MIMETYPE_ TO_ ICON_ MAPPING . put ( _ STR ,  R . drawable . file_code ) ;  MIMETYPE_ TO_ ICON_ MAPPING . put ( _ STR ,  R . drawable . file ) ;  MIMETYPE_ TO_ ICON_ MAPPING . put ( _ STR ,  R . drawable . file_xls ) ;  MIMETYPE_ TO_ ICON_ MAPPING . put ( _ STR ,  R . drawable . file_ppt ) ;  MIMETYPE_ TO_ ICON_ MAPPING . put ( _ STR ,  R . drawable . file_doc ) ;  MIMETYPE_ TO_ ICON_ MAPPING . put ( _ STR ,  R . drawable . file ) ;  MIMETYPE_ TO_ ICON_ MAPPING . put ( _ STR ,  R . drawable . file_image ) ;  MIMETYPE_ TO_ ICON_ MAPPING . put ( _ STR ,  R . drawable . file_pdf ) ;  MIMETYPE_ TO_ ICON_ MAPPING . put ( _ STR ,  R . drawable . file_code ) ;  MIMETYPE_ TO_ ICON_ MAPPING . put ( _ STR ,  R . drawable . file ) ;  MIMETYPE_ TO_ ICON_ MAPPING . put ( _ STR ,  R . drawable . file_zip ) ;  MIMETYPE_ TO_ ICON_ MAPPING . put ( _ STR ,  R . drawable . file_xls ) ;  MIMETYPE_ TO_ ICON_ MAPPING . put ( _ STR ,  R . drawable . file_xls ) ;  MIMETYPE_ TO_ ICON_ MAPPING . put ( _ STR ,  R . drawable . file_xls ) ;  MIMETYPE_ TO_ ICON_ MAPPING . put ( _ STR ,  R . drawable . file_xls ) ;  MIMETYPE_ TO_ ICON_ MAPPING . put ( _ STR ,  R . drawable . file_xls ) ;  MIMETYPE_ TO_ ICON_ MAPPING . put ( _ STR ,  R . drawable . file_image ) ;  MIMETYPE_ TO_ ICON_ MAPPING . put ( _ STR ,  R . drawable . file_ppt ) ;  MIMETYPE_ TO_ ICON_ MAPPING . put ( _ STR ,  R . drawable . file_ppt ) ;  MIMETYPE_ TO_ ICON_ MAPPING . put ( _ STR ,  R . drawable . file_ppt ) ;  MIMETYPE_ TO_ ICON_ MAPPING . put ( _ STR ,  R . drawable . file_ppt ) ;  MIMETYPE_ TO_ ICON_ MAPPING . put ( _ STR ,  R . drawable . file_ppt ) ;  MIMETYPE_ TO_ ICON_ MAPPING . put ( _ STR ,  R . drawable . file_doc ) ;  MIMETYPE_ TO_ ICON_ MAPPING . put ( _ STR ,  R . drawable . file_doc ) ;  MIMETYPE_ TO_ ICON_ MAPPING . put ( _ STR ,  R . drawable . file_ppt ) ;  MIMETYPE_ TO_ ICON_ MAPPING . put ( _ STR ,  R . drawable . file_ppt ) ;  MIMETYPE_ TO_ ICON_ MAPPING . put ( _ STR ,  R . drawable . file_xls ) ;  MIMETYPE_ TO_ ICON_ MAPPING . put ( _ STR ,  R . drawable . file_xls ) ;  MIMETYPE_ TO_ ICON_ MAPPING . put ( _ STR ,  R . drawable . file_doc ) ;  MIMETYPE_ TO_ ICON_ MAPPING . put ( _ STR ,  R . drawable . file_doc ) ;  MIMETYPE_ TO_ ICON_ MAPPING . put ( _ STR ,  R . drawable . file_doc ) ;  MIMETYPE_ TO_ ICON_ MAPPING . put ( _ STR ,  R . drawable . file_doc ) ;  MIMETYPE_ TO_ ICON_ MAPPING . put ( _ STR ,  R . drawable . file_ppt ) ;  MIMETYPE_ TO_ ICON_ MAPPING . put ( _ STR ,  R . drawable . file_ppt ) ;  MIMETYPE_ TO_ ICON_ MAPPING . put ( _ STR ,  R . drawable . file_ppt ) ;  MIMETYPE_ TO_ ICON_ MAPPING . put ( _ STR ,  R . drawable . file_xls ) ;  MIMETYPE_ TO_ ICON_ MAPPING . put ( _ STR ,  R . drawable . file_xls ) ;  MIMETYPE_ TO_ ICON_ MAPPING . put ( _ STR ,  R . drawable . file_doc ) ;  MIMETYPE_ TO_ ICON_ MAPPING . put ( _ STR ,  R . drawable . file_doc ) ;  MIMETYPE_ TO_ ICON_ MAPPING . put ( _ STR ,  R . drawable . file_zip ) ;  MIMETYPE_ TO_ ICON_ MAPPING . put ( _ STR ,  R . drawable . file_application ) ;  MIMETYPE_ TO_ ICON_ MAPPING . put ( _ STR ,  R . drawable . file_text ) ;  MIMETYPE_ TO_ ICON_ MAPPING . put ( _ STR ,  R . drawable . file_zip ) ;  MIMETYPE_ TO_ ICON_ MAPPING . put ( _ STR ,  R . drawable . file_image ) ;  MIMETYPE_ TO_ ICON_ MAPPING . put ( _ STR ,  R . drawable . file_zip ) ;  MIMETYPE_ TO_ ICON_ MAPPING . put ( _ STR ,  R . drawable . file_image ) ;  MIMETYPE_ TO_ ICON_ MAPPING . put ( _ STR ,  R . drawable . file_image ) ;  MIMETYPE_ TO_ ICON_ MAPPING . put ( _ STR ,  R . drawable . file_zip ) ;  MIMETYPE_ TO_ ICON_ MAPPING . put ( _ STR ,  R . drawable . file_application ) ;  MIMETYPE_ TO_ ICON_ MAPPING . put ( _ STR ,  R . drawable . file_application ) ;  MIMETYPE_ TO_ ICON_ MAPPING . put ( _ STR ,  R . drawable . file_xls ) ;  MIMETYPE_ TO_ ICON_ MAPPING . put ( _ STR ,  R . drawable . file_ppt ) ;  MIMETYPE_ TO_ ICON_ MAPPING . put ( _ STR ,  R . drawable . file_doc ) ;  MIMETYPE_ TO_ ICON_ MAPPING . put ( _ STR ,  R . drawable . file_code ) ;  MIMETYPE_ TO_ ICON_ MAPPING . put ( _ STR ,  R . drawable . file_image ) ;  MIMETYPE_ TO_ ICON_ MAPPING . put ( _ STR ,  R . drawable . file_code ) ;  MIMETYPE_ TO_ ICON_ MAPPING . put ( _ STR ,  R . drawable . file_zip ) ;  MIMETYPE_ TO_ ICON_ MAPPING . put ( _ STR ,  R . drawable . file_application ) ;  MIMETYPE_ TO_ ICON_ MAPPING . put ( _ STR ,  R . drawable . file_zip ) ;  MIMETYPE_ TO_ ICON_ MAPPING . put ( _ STR ,  R . drawable . file_text ) ;  MIMETYPE_ TO_ ICON_ MAPPING . put ( _ STR ,  R . drawable . file_text ) ;  MIMETYPE_ TO_ ICON_ MAPPING . put ( _ STR ,  R . drawable . file_code ) ;  MIMETYPE_ TO_ ICON_ MAPPING . put ( _ STR ,  R . drawable . file_zip ) ;  MIMETYPE_ TO_ ICON_ MAPPING . put ( _ STR ,  R . drawable . file ) ;  MIMETYPE_ TO_ ICON_ MAPPING . put ( _ STR ,  R . drawable . ic_menu_archive ) ;  MIMETYPE_ TO_ ICON_ MAPPING . put ( _ STR ,  R . drawable . file_image ) ;  MIMETYPE_ TO_ ICON_ MAPPING . put ( _ STR ,  R . drawable . file_image ) ;  MIMETYPE_ TO_ ICON_ MAPPING . put ( _ STR ,  R . drawable . file_calendar ) ;  MIMETYPE_ TO_ ICON_ MAPPING . put ( _ STR ,  R . drawable . file_code ) ;  MIMETYPE_ TO_ ICON_ MAPPING . put ( _ STR ,  R . drawable . file_xls ) ;  MIMETYPE_ TO_ ICON_ MAPPING . put ( _ STR ,  R . drawable . file_code ) ;  MIMETYPE_ TO_ ICON_ MAPPING . put ( _ STR ,  R . drawable . file_vcard ) ;  MIMETYPE_ TO_ ICON_ MAPPING . put ( _ STR ,  R . drawable . file_code ) ;  MIMETYPE_ TO_ ICON_ MAPPING . put ( _ STR ,  R . drawable . file_code ) ;  MIMETYPE_ TO_ ICON_ MAPPING . put ( _ STR ,  R . drawable . file_code ) ;  MIMETYPE_ TO_ ICON_ MAPPING . put ( _ STR ,  R . drawable . file_code ) ;  MIMETYPE_ TO_ ICON_ MAPPING . put ( _ STR ,  R . drawable . file_code ) ;  MIMETYPE_ TO_ ICON_ MAPPING . put ( _ STR ,  R . drawable . file_code ) ;  MIMETYPE_ TO_ ICON_ MAPPING . put ( _ STR ,  R . drawable . ic_menu_archive ) ; }
public void register Listeners (  Property Change Support pcs ) {  Property Change Listener listener = new  HPChange Listener ( ) ; add Property Change Listener With Modified Support ( pcs , _ STR , listener ) ; add Property Change Listener With Modified Support ( pcs , _ STR , listener ) ; listener = new  ATKChange Listener ( ) ; add Property Change Listener With Modified Support ( pcs , _ STR , listener ) ; pcs . add Property Change Listener ( _ STR , listener ) ; listener = new  DEFChange Listener ( ) ; add Property Change Listener With Modified Support ( pcs , _ STR , listener ) ; pcs . add Property Change Listener ( _ STR , listener ) ; if (  Testing .  COMBAT ) { listener = new  RATKChange Listener ( ) ; add Property Change Listener With Modified Support ( pcs , _ STR , listener ) ; pcs . add Property Change Listener ( _ STR , listener ) ; } listener = new  XPChange Listener ( ) ; pcs . add Property Change Listener ( _ STR , listener ) ; listener = new  Level Change Listener ( ) ; add Property Change Listener With Modified Support ( pcs , _ STR , listener ) ; listener = new  Weapon Change Listener ( ) ; pcs . add Property Change Listener ( _ STR , listener ) ; listener = new  Armor Change Listener ( ) ; pcs . add Property Change Listener ( _ STR , listener ) ; if (  Testing .  COMBAT ) { listener = new  Ranged Weapon Change Listener ( ) ; pcs . add Property Change Listener ( _ STR , listener ) ; } listener = new  Money Change Listener ( ) ; for (  String slot :  MONEY_ SLOTS ) { pcs . add Property Change Listener ( slot , listener ) ; } listener = new  Eating Change Listener ( ) ; pcs . add Property Change Listener ( _ STR , listener ) ; pcs . add Property Change Listener ( _ STR , listener ) ; listener = new  Status Change Listener ( ) ; for (  Status ID id :  Status ID . values ( ) ) { pcs . add Property Change Listener ( id . get Attribute ( ) , listener ) ; } listener = new  Away Change Listener ( ) ; pcs . add Property Change Listener ( _ STR , listener ) ; listener = new  Grumpy Change Listener ( ) ; pcs . add Property Change Listener ( _ STR , listener ) ; listener = new  Karma Change Listener ( ) ; pcs . add Property Change Listener ( _ STR , listener ) ; listener = new  Mana Change Listener ( ) ; add Property Change Listener With Modified Support ( pcs , _ STR , listener ) ; add Property Change Listener With Modified Support ( pcs , _ STR , listener ) ; }
protected final void run On Ui Thread ( @  Non Null  Runnable runnable ) { if (  Looper . my Looper ( ) ==  Looper . get Main Looper ( ) ) { runnable . run ( ) ; } else { m Poster . post ( runnable ) ; } }
public void initialize (  Map config Params ) throws  Policy Exception { if (  DEBUG . message Enabled ( ) ) {  DEBUG . message ( _ STR + _ STR ) ; } if ( config Params == null ) { throw ( new  Policy Exception (  Res Bundle Utils . rb Name , _ STR , null , null ) ) ; }  Set org Name Set = (  Set ) config Params . get (  Policy Manager .  ORGANIZATION_ NAME ) ; if ( ( org Name Set != null ) && ( ! org Name Set . is Empty ( ) ) ) {  Iterator items = org Name Set . iterator ( ) ; org Name = (  String ) items . next ( ) ; } valid Dynamic Attr Names = (  Set ) config Params . get (  Policy Config .  SELECTED_ DYNAMIC_ ATTRIBUTES ) ; if ( valid Dynamic Attr Names == null ) { valid Dynamic Attr Names =  Collections .  EMPTY_ SET ; } initialized = _ BOOL ; if (  DEBUG . message Enabled ( ) ) {  DEBUG . message ( _ STR + _ STR + _ STR + org Name + _ STR + valid Dynamic Attr Names ) ; } }
public void remove NXWarrant (  Warrant w ) { w . remove Property Change Listener ( this ) ; _war List . remove ( w ) ; _war NX . remove ( w ) ; _manager . deregister ( w ) ; w . dispose ( ) ; }
public void add Command (  PDFCmd cmd ) { synchronized ( commands ) { commands . add ( cmd ) ; } update Images ( ) ; }
public boolean connect ( final  String address ) { if ( m Bluetooth Adapter == null || address == null ) {  Log . w (  TAG , _ STR ) ; return _ BOOL ; } if ( m Bluetooth Device Address != null && address . equals ( m Bluetooth Device Address ) && m Bluetooth Gatt != null ) {  Log . d (  TAG , _ STR ) ; if ( m Bluetooth Gatt . connect ( ) ) { m Connection State =  STATE_ CONNECTING ; return _ BOOL ; } else { return _ BOOL ; } } final  Bluetooth Device device = m Bluetooth Adapter . get Remote Device ( address ) ; if ( device == null ) {  Log . d (  TAG , _ STR ) ; return _ BOOL ; } m Bluetooth Gatt = device . connect Gatt ( this , _ BOOL , m Gatt Callback ) ;  Log . d (  TAG , _ STR ) ; m Bluetooth Device Address = address ; m Connection State =  STATE_ CONNECTING ; return _ BOOL ; }
private double log Normal Dens ( double x , double mean , double std Dev ) { double diff = x - mean ; return - ( diff * diff / ( _ NUM * std Dev * std Dev ) ) - m_norm Const -  Math . log ( std Dev ) ; }
public  Shape transform (  Shape shape ) {  General Path new Path = new  General Path ( ) ; float [ ] coords = new float [ _ NUM ] ; for (  Path Iterator iterator = shape . get Path Iterator ( null ) ; iterator . is Done ( ) == _ BOOL ; iterator . next ( ) ) { int type = iterator . current Segment ( coords ) ; switch ( type ) { case  Path Iterator .  SEG_ MOVETO :  Point2 D p = transform ( new  Point2 D .  Float ( coords [ _ NUM ] , coords [ _ NUM ] ) ) ; new Path . move To ( ( float ) p . get X ( ) , ( float ) p . get Y ( ) ) ; break ; case  Path Iterator .  SEG_ LINETO : p = transform ( new  Point2 D .  Float ( coords [ _ NUM ] , coords [ _ NUM ] ) ) ; new Path . line To ( ( float ) p . get X ( ) , ( float ) p . get Y ( ) ) ; break ; case  Path Iterator .  SEG_ QUADTO : p = transform ( new  Point2 D .  Float ( coords [ _ NUM ] , coords [ _ NUM ] ) ) ;  Point2 D q = transform ( new  Point2 D .  Float ( coords [ _ NUM ] , coords [ _ NUM ] ) ) ; new Path . quad To ( ( float ) p . get X ( ) , ( float ) p . get Y ( ) , ( float ) q . get X ( ) , ( float ) q . get Y ( ) ) ; break ; case  Path Iterator .  SEG_ CUBICTO : p = transform ( new  Point2 D .  Float ( coords [ _ NUM ] , coords [ _ NUM ] ) ) ; q = transform ( new  Point2 D .  Float ( coords [ _ NUM ] , coords [ _ NUM ] ) ) ;  Point2 D r = transform ( new  Point2 D .  Float ( coords [ _ NUM ] , coords [ _ NUM ] ) ) ; new Path . curve To ( ( float ) p . get X ( ) , ( float ) p . get Y ( ) , ( float ) q . get X ( ) , ( float ) q . get Y ( ) , ( float ) r . get X ( ) , ( float ) r . get Y ( ) ) ; break ; case  Path Iterator .  SEG_ CLOSE : new Path . close Path ( ) ; break ; } } return new Path ; }
private void clear Context (  Context context ) throws  Naming Exception { for (  Naming Enumeration e = context . list Bindings ( _ STR ) ; e . has More Elements ( ) ; ) {  Binding binding = (  Binding ) e . next Element ( ) ; if ( binding . get Object ( ) instanceof  Context ) { clear Context ( (  Context ) binding . get Object ( ) ) ; } context . unbind ( binding . get Name ( ) ) ; } }
public void start ( final  Input Stream in ) throws  SAXException ,  IOException ,  Parser Configuration Exception {  SAXParser Factory factory =  SAXParser Factory . new Instance ( ) ;  SAXParser sax Parser = factory . new SAXParser ( ) ; sax Parser . parse ( in , this ) ; }
public static  Collection <  String > string2 Collection (  String in ,  String delimiter , boolean do Strip ,  Collection <  String > collection ) { if ( in == null ) { return null ; } if ( collection == null ) { collection = new  Array List <  String > ( ) ; } if ( delimiter == null || delimiter . length ( ) == _ NUM ) { collection . add ( in ) ; return collection ; } int from Index = _ NUM ; int pos ; while ( ( pos = in . index Of ( delimiter , from Index ) ) >= _ NUM ) {  String interim = in . substring ( from Index , pos ) ; if ( do Strip ) { interim = strip ( interim ) ; } if ( ! do Strip || interim . length ( ) > _ NUM ) { collection . add ( interim ) ; } from Index = pos + delimiter . length ( ) ; }  String interim = in . substring ( from Index ) ; if ( do Strip ) { interim = strip ( interim ) ; } if ( ! do Strip || interim . length ( ) > _ NUM ) { collection . add ( interim ) ; } return collection ; }
public static  String encode Base64 ( byte [ ] input ) { return  Datatype Converter . print Base64 Binary ( input ) ; }
protected void handle Premove Drop ( int from Square , int to Square ) {  Premove Info premove Info = new  Premove Info ( ) ; premove Info . is Premove Drop = _ BOOL ; premove Info . to Square = to Square ; premove Info . from Square = from Square ; premove Info . from Piece =  Chess Board Utils . piece Jail Square To Piece ( from Square ) ; premoves . add ( premove Info ) ; adjust Premove Label Highlights And Arrows ( ) ; board . unhide Pieces ( ) ; refresh Board ( ) ; }
public void append To (  String Builder buffer ) { buffer . append ( this . original String , this . offset , this . offset + this . length ) ; }
private void stop ( ) { if ( this . throttle == null ) { return ; } internal Adjust = _ BOOL ; throttle . set Speed Setting ( - _ NUM ) ; speed Slider . set Value ( _ NUM ) ; if ( speed Spinner != null ) { speed Spinner Model . set Value (  Integer . value Of ( _ NUM ) ) ; } if ( speed Slider Continuous != null ) { speed Slider Continuous . set Value (  Integer . value Of ( _ NUM ) ) ; } internal Adjust = _ BOOL ; }
@  Override public boolean input (  Instance instance ) {  Instance new Instance ; double [ ] values ; if ( get Input Format ( ) == null ) { throw new  Illegal State Exception ( _ STR ) ; } if ( m_ New Batch ) { reset Queue ( ) ; m_ New Batch = _ BOOL ; } values = instance . to Double Array ( ) ; if ( ! instance . is Missing ( m_ Att Index . get Index ( ) ) ) { values [ m_ Att Index . get Index ( ) ] = m_ Sorted Indices [ ( int ) values [ m_ Att Index . get Index ( ) ] ] ; } new Instance = new  Dense Instance ( instance . weight ( ) , values ) ; copy Values ( instance , _ BOOL , instance . dataset ( ) , get Output Format ( ) ) ; push ( new Instance ) ; return _ BOOL ; }
@  Override public  Enumeration <  Option > list Options ( ) {  Vector <  Option > new Vector = new  Vector <  Option > ( _ NUM ) ; new Vector . add Element ( new  Option ( _ STR , _ STR , _ NUM , _ STR ) ) ; new Vector . add Element ( new  Option ( _ STR + _ STR , _ STR , _ NUM , _ STR ) ) ; new Vector . add Element ( new  Option ( _ STR , _ STR , _ NUM , _ STR ) ) ; new Vector . add Element ( new  Option ( _ STR , _ STR , _ NUM , _ STR ) ) ; return new Vector . elements ( ) ; }
static  String parse Prefix (  String key ) { if ( key == null ) return null ; boolean inquotes = _ BOOL ; for ( int i = _ NUM ; i < key . length ( ) ; i ++ ) { char c = key . char At ( i ) ; if ( c == _ STR ) { inquotes = ! inquotes ; } else if ( ( c == _ STR || c == _ STR ) && ! inquotes ) { return key . substring ( _ NUM , i ) ; } } return null ; }
public static  String unformat String (  String s ) {  String Buffer result = new  String Buffer ( ) ; int i = _ NUM ; while ( i < s . length ( ) ) { char c = s . char At ( i ++ ) ; if ( ( c == _ STR ) && ( i < s . length ( ) ) ) { c = s . char At ( i ++ ) ; if ( ( c == _ STR ) && ( i + _ NUM < s . length ( ) ) ) { int value = _ NUM ; for ( int j = _ NUM ; j < _ NUM ; j ++ ) { c = s . char At ( i ++ ) ; int digit =  Character . digit ( c , _ NUM ) ; if ( digit != - _ NUM ) { value = ( value << _ NUM ) + digit ; } else { throw new  Illegal Argument Exception ( _ STR ) ; } } result . append ( ( char ) value ) ; } else if ( c == _ STR ) { result . append ( c ) ; } else { result . append ( _ STR ) ; result . append ( c ) ; } } else { result . append ( c ) ; } } return result . to String ( ) ; }
public static double sample Kurtosis Standard Error ( int size ) { int n = size ; return  Math . sqrt ( _ NUM * n * ( n - _ NUM ) * ( n - _ NUM ) / ( ( n - _ NUM ) * ( n - _ NUM ) * ( n + _ NUM ) * ( n + _ NUM ) ) ) ; }
public static  String to String (  Policy Information policy Information ) throws  IOException {  String Buffer sb Policy Information = new  String Buffer ( ) ;  ASN1 Object Identifier policy Identifier = policy Information . get Policy Identifier ( ) ; sb Policy Information . append (  Message Format . format ( res . get String ( _ STR ) , policy Identifier . get Id ( ) ) ) ;  ASN1 Sequence policy Qualifiers = policy Information . get Policy Qualifiers ( ) ; if ( policy Qualifiers != null ) { sb Policy Information . append ( _ STR ) ;  String Buffer sb Policy Qualifiers = new  String Buffer ( ) ; for ( int i = _ NUM ; i < policy Qualifiers . size ( ) ; i ++ ) {  Policy Qualifier Info policy Qualifier Info =  Policy Qualifier Info . get Instance ( policy Qualifiers . get Object At ( i ) ) ; sb Policy Qualifiers . append ( to String ( policy Qualifier Info ) ) ; if ( ( i + _ NUM ) < policy Qualifiers . size ( ) ) { sb Policy Qualifiers . append ( _ STR ) ; } } sb Policy Information . append (  Message Format . format ( res . get String ( _ STR ) , sb Policy Qualifiers ) ) ; } return sb Policy Information . to String ( ) ; }
public void with Transaction (  Closure closure ) throws  SQLException { boolean saved Cache Connection = cache Connection ; cache Connection = _ BOOL ;  Connection connection = null ; boolean saved Auto Commit = _ BOOL ; try { connection = create Connection ( ) ; saved Auto Commit = connection . get Auto Commit ( ) ; connection . set Auto Commit ( _ BOOL ) ; call Closure Possibly With Connection ( closure , connection ) ; connection . commit ( ) ; } catch (  SQLException e ) { handle Error ( connection , e ) ; throw e ; } catch (  Runtime Exception e ) { handle Error ( connection , e ) ; throw e ; } catch (  Error e ) { handle Error ( connection , e ) ; throw e ; } catch (  Exception e ) { handle Error ( connection , e ) ; throw new  SQLException ( _ STR , e ) ; } finally { if ( connection != null ) { try { connection . set Auto Commit ( saved Auto Commit ) ; } catch (  SQLException e ) {  LOG . finest ( _ STR + e . get Message ( ) + _ STR ) ; } } cache Connection = _ BOOL ; close Resources ( connection , null ) ; cache Connection = saved Cache Connection ; if ( data Source != null && ! cache Connection ) { use Connection = null ; } } }
public double do Operation ( ) throws  Operator Failed Exception { double logq ; final double alpha = ( arctan Transform ?  Math . atan ( bias ) *  SCALE_ ALPHA :  Math . log ( bias ) ) ; final  Node Ref root = tree . get Root ( ) ; double max Height = tree . get Node Height ( root ) ;  Node Ref i ;  Node Ref i P = null ;  Node Ref  Ci P = null ;  Node Ref  Pi P = null ; double height =  Double .  Na N ;  List <  Node Ref > destinations = null ; do { i = tree . get Node (  Math Utils . next Int ( tree . get Node Count ( ) ) ) ; } while ( root == i || tree . get Parent ( i ) == root ) ; i P = tree . get Parent ( i ) ;  Ci P = get Other Child ( tree , i P , i ) ;  Pi P = tree . get Parent ( i P ) ; height = tree . get Node Height ( i P ) ; destinations = get Intersecting Edges ( tree , height ) ; if ( destinations . size ( ) == _ NUM ) { throw new  Operator Failed Exception ( _ STR ) ; } double [ ] pdf = get Destination Probabilities ( tree , i , height , max Height , destinations , alpha ) ; destinations . remove ( i ) ; destinations . remove (  Ci P ) ; int r =  Math Utils . random Choice PDF ( pdf ) ; double forward Probability = pdf [ r ] ; final  Node Ref j = destinations . get ( r ) ; final  Node Ref j P = tree . get Parent ( j ) ; tree . begin Tree Edit ( ) ; tree . remove Child ( i P ,  Ci P ) ; tree . remove Child (  Pi P , i P ) ; tree . add Child (  Pi P ,  Ci P ) ; tree . remove Child ( j P , j ) ; tree . add Child ( i P , j ) ; tree . add Child ( j P , i P ) ; tree . end Tree Edit ( ) ; final  List <  Node Ref > reverse Destinations = get Intersecting Edges ( tree , height ) ; double reverse Probability = get Reverse Probability ( tree ,  Ci P , j , height , max Height , reverse Destinations , alpha ) ; logq =  Math . log ( reverse Probability ) -  Math . log ( forward Probability ) ; return logq ; }
private int find Marker Segment Position (  Class cls , boolean first ) { if ( first ) {  List Iterator iter = marker Sequence . list Iterator ( ) ; for ( int i = _ NUM ; iter . has Next ( ) ; i ++ ) {  Marker Segment seg = (  Marker Segment ) iter . next ( ) ; if ( cls . is Instance ( seg ) ) { return i ; } } } else {  List Iterator iter = marker Sequence . list Iterator ( marker Sequence . size ( ) ) ; for ( int i = marker Sequence . size ( ) - _ NUM ; iter . has Previous ( ) ; i -- ) {  Marker Segment seg = (  Marker Segment ) iter . previous ( ) ; if ( cls . is Instance ( seg ) ) { return i ; } } } return - _ NUM ; }
default  Filterable <  T > retain All ( final  Stream < ? extends  T > stream ) { final  Set <  T > set = stream . collect (  Collectors . to Set ( ) ) ; return filter ( null ) ; }
private void close Output Streams (  Output Stream header Stream ,  Output Stream body Stream ) throws  IOException { try { if ( ( header Stream != null ) && ( header Stream != body Stream ) ) { header Stream . close ( ) ; } } finally { if ( body Stream != null ) { body Stream . close ( ) ; } } }
public static void finish Share To Messenger (  Activity activity ,  Share To Messenger Params share To Messenger Params ) {  Intent original Intent = activity . get Intent ( ) ;  Set <  String > categories = original Intent . get Categories ( ) ; if ( categories == null ) { activity . set Result (  Activity .  RESULT_ CANCELED , null ) ; activity . finish ( ) ; return ; } if ( categories . contains (  ORCA_ THREAD_ CATEGORY_20150314 ) ) {  Bundle app Link Extras =  App Links . get App Link Extras ( original Intent ) ;  Intent result Intent = new  Intent ( ) ; if ( categories . contains (  ORCA_ THREAD_ CATEGORY_20150314 ) ) { result Intent . put Extra (  EXTRA_ PROTOCOL_ VERSION ,  Messenger Utils .  PROTOCOL_ VERSION_20150314 ) ;  String thread Token = app Link Extras . get String (  Messenger Utils .  EXTRA_ THREAD_ TOKEN_ KEY ) ; result Intent . put Extra (  EXTRA_ THREAD_ TOKEN_ KEY , thread Token ) ; } else { throw new  Runtime Exception ( ) ; } result Intent . set Data And Type ( share To Messenger Params . uri , share To Messenger Params . mime Type ) ; result Intent . set Flags (  Intent .  FLAG_ GRANT_ READ_ URI_ PERMISSION ) ; result Intent . put Extra (  EXTRA_ APP_ ID ,  Facebook Sdk . get Application Id ( ) ) ; result Intent . put Extra (  EXTRA_ METADATA , share To Messenger Params . meta Data ) ; result Intent . put Extra (  EXTRA_ EXTERNAL_ URI , share To Messenger Params . external Uri ) ; activity . set Result (  Activity .  RESULT_ OK , result Intent ) ; activity . finish ( ) ; } else { activity . set Result (  Activity .  RESULT_ CANCELED , null ) ; activity . finish ( ) ; } }
public static  Uri add Message To Uri (  Content Resolver resolver ,  Uri uri ,  String address ,  String body ,  String subject ,  Long date , boolean read , boolean delivery Report ) { return add Message To Uri ( resolver , uri , address , body , subject , date , read , delivery Report , - _ NUM ) ; }
private double round MGRS ( double value ) { double ivalue =  Math . floor ( value ) ; long ival ; double fraction = value - ivalue ; ival = ( long ) ( ivalue ) ; if ( ( fraction > _ NUM ) || ( ( fraction == _ NUM ) && ( ival % _ NUM == _ NUM ) ) ) ival ++ ; return ( double ) ival ; }
final  V replace Node (  Object key ,  V value ,  Object cv ) { int hash = spread ( key . hash Code ( ) ) ; for (  Node <  K ,  V > [ ] tab = table ; ; ) {  Node <  K ,  V > f ; int n , i , fh ; if ( tab == null || ( n = tab . length ) == _ NUM || ( f = tab At ( tab , i = ( n - _ NUM ) & hash ) ) == null ) break ; else if ( ( fh = f . hash ) ==  MOVED ) tab = help Transfer ( tab , f ) ; else {  V old Val = null ; boolean validated = _ BOOL ; synchronized ( f ) { if ( tab At ( tab , i ) == f ) { if ( fh >= _ NUM ) { validated = _ BOOL ; for (  Node <  K ,  V > e = f , pred = null ; ; ) {  K ek ; if ( e . hash == hash && ( ( ek = e . key ) == key || ( ek != null && key . equals ( ek ) ) ) ) {  V ev = e . val ; if ( cv == null || cv == ev || ( ev != null && cv . equals ( ev ) ) ) { old Val = ev ; if ( value != null ) e . val = value ; else if ( pred != null ) pred . next = e . next ; else set Tab At ( tab , i , e . next ) ; } break ; } pred = e ; if ( ( e = e . next ) == null ) break ; } } else if ( f instanceof  Tree Bin ) { validated = _ BOOL ;  Tree Bin <  K ,  V > t = (  Tree Bin <  K ,  V > ) f ;  Tree Node <  K ,  V > r , p ; if ( ( r = t . root ) != null && ( p = r . find Tree Node ( hash , key , null ) ) != null ) {  V pv = p . val ; if ( cv == null || cv == pv || ( pv != null && cv . equals ( pv ) ) ) { old Val = pv ; if ( value != null ) p . val = value ; else if ( t . remove Tree Node ( p ) ) set Tab At ( tab , i , untreeify ( t . first ) ) ; } } } } } if ( validated ) { if ( old Val != null ) { if ( value == null ) add Count ( - _ NUM , - _ NUM ) ; return old Val ; } break ; } } } return null ; }
private static final boolean copy Header (  String name ,  String from Req ,  String Builder buf ) { int start = from Req . index Of ( name ) ; if ( start != - _ NUM ) { int end = from Req . index Of ( _ STR , start ) ; if ( end != - _ NUM ) { buf . append ( from Req . sub Sequence ( start - _ NUM , end ) ) ; return _ BOOL ; } } return _ BOOL ; }
public void send Exception ( final  Exception exception , final  Map <  String ,  String > properties ) { final  Property Map Builder builder = new  Property Map Builder ( properties ) ; logger . debug (  String . format ( _ STR , exception . get Message ( ) , builder . to String ( ) ) ) ; if ( telemetry Client != null ) { telemetry Client . track Exception ( exception , builder . build ( ) , null ) ; } }
private void check Http Parameter Conditions (  Method method ,  Iterable <  Field > fields ,  Set <  Message Type > visited ) { for (  Field field : fields ) { check Http Parameter Conditions ( method , field , visited ) ; } }
public  URL find Resource (  String name , boolean check ) {  Loader loader ; int [ ] cache = get Lookup Cache ( name ) ; for ( int i = _ NUM ; ( loader = get Next Loader ( cache , i ) ) != null ; i ++ ) {  URL url = loader . find Resource ( name , check ) ; if ( url != null ) { return url ; } } return null ; }
public void to EPL (  String Writer writer ,  EPStatement Formatter formatter ) { formatter . begin Merge When Matched ( writer ) ; if ( matched ) { writer . write ( _ STR ) ; } else { writer . write ( _ STR ) ; } if ( optional Condition != null ) { writer . write ( _ STR ) ; optional Condition . to EPL ( writer ,  Expression Precedence Enum .  MINIMUM ) ; } for (  On Merge Matched Action action : actions ) { formatter . begin Merge Action ( writer ) ; action . to EPL ( writer ) ; } }
public static int index Of Parenthesis Match (  String str , int first ) throws  URISyntax Exception { int index = - _ NUM ; if ( first < _ NUM || first > str . length ( ) ) { throw new  Illegal Argument Exception ( _ STR + first ) ; } if ( str . char At ( first ) != _ STR ) { throw new  Illegal Argument Exception ( _ STR ) ; } int depth = _ NUM ; char [ ] array = str . to Char Array ( ) ; for ( index = first + _ NUM ; index < array . length ; ++ index ) { char current = array [ index ] ; if ( current == _ STR ) { depth ++ ; } else if ( current == _ STR ) { if ( -- depth == _ NUM ) { break ; } } } if ( depth != _ NUM ) { throw new  URISyntax Exception ( str , _ STR ) ; } return index ; }
public  Binary Content (  File a File ) throws  IOException { this ( ) ; if ( a File == null || a File . length ( ) < _ NUM ) return ; ranges . add ( new  Range ( _ NUM , a File , _ BOOL ) ) ; }
private void add Initial Peer ( ) { try { add Peer ( null , new  Inet Socket Address (  Inet Address . get By Name (  CONNECTABLE_ ADDRESS ) ,  DEFAULT_ PORT ) ,  Peer .  OUTGOING ) ; } catch (  Unknown Host Exception e ) { e . print Stack Trace ( ) ; } }
public void write ( long file Offset , byte [ ] buffer , int offset , int length ) throws  IOException { _file . seek ( file Offset ) ; _file . write ( buffer , offset , length ) ; }
private static boolean is Partition Tag (  String [ ] partitions ,  String tag Name ) { if ( partitions != null ) { for (  String partition : partitions ) { if ( partition . equals ( tag Name ) ) { return _ BOOL ; } } } return _ BOOL ; }
public void shutdown ( boolean is Ignoring Preference Saves ) { shutdown Without Exit ( is Ignoring Preference Saves ) ;  System . exit ( _ NUM ) ; }
public static int expand JTree Node ( javax . swing .  JTree tree , javax . swing . tree .  Tree Model model ,  Object node , int row , int depth ) { if ( node != null && ! model . is Leaf ( node ) ) { tree . expand Row ( row ) ; if ( depth != _ NUM ) { for ( int index = _ NUM ; row + _ NUM < tree . get Row Count ( ) && index < model . get Child Count ( node ) ; index ++ ) { row ++ ;  Object child = model . get Child ( node , index ) ; if ( child == null ) break ; javax . swing . tree .  Tree Path path ; while ( ( path = tree . get Path For Row ( row ) ) != null && path . get Last Path Component ( ) != child ) row ++ ; if ( path == null ) break ; row = expand JTree Node ( tree , model , child , row , depth - _ NUM ) ; } } } return row ; }
public static boolean is Absolute URI (  String system Id ) { if ( is Windows Absolute Path ( system Id ) ) { return _ BOOL ; } final int fragment Index = system Id . index Of ( _ STR ) ; final int query Index = system Id . index Of ( _ STR ) ; final int slash Index = system Id . index Of ( _ STR ) ; final int colon Index = system Id . index Of ( _ STR ) ; int index = system Id . length ( ) - _ NUM ; if ( fragment Index > _ NUM ) index = fragment Index ; if ( ( query Index > _ NUM ) && ( query Index < index ) ) index = query Index ; if ( ( slash Index > _ NUM ) && ( slash Index < index ) ) index = slash Index ; return ( ( colon Index > _ NUM ) && ( colon Index < index ) ) ; }
public void invoke (  Request request ,  Pattern Path Router .  Routable Destination <  Http Resource Model > destination ) throws  Exception {  Object return Val = method . invoke ( handler , args ) ; return Val = invoke Sub Resource ( request , destination , return Val ) ; responder . set Entity ( return Val ) ; responder . send ( ) ; }
@  Override public void mouse Released (  Mouse Event e ) { if ( m_mouse State == _ NUM ) { m_click Available = _ BOOL ; } else { m_click Available = _ BOOL ; } if ( m_mouse State == _ NUM && mouse In Bounds ( e ) ) { m_mouse State = _ NUM ;  Dimension ns = new  Dimension ( m_view Size . width / _ NUM , m_view Size . height / _ NUM ) ; if ( ns . width < _ NUM ) { ns . width = _ NUM ; } if ( ns . height < _ NUM ) { ns . height = _ NUM ; }  Dimension d = get Size ( ) ;  Dimension np = new  Dimension ( ( int ) ( d . width / _ NUM - ( ( double ) d . width / _ NUM - m_view Pos . width ) / _ NUM ) , ( int ) ( d . height / _ NUM - ( ( double ) d . height / _ NUM - m_view Pos . height ) / _ NUM ) ) ; animate Scaling ( np , ns , _ NUM ) ; } else if ( m_mouse State == _ NUM ) { m_mouse State = _ NUM ;  Graphics g = get Graphics ( ) ; if ( m_ Zoom Box Color == null ) { g . set Color (  Color . black ) ; } else { g . set Color ( m_ Zoom Box Color ) ; } if ( m_ Zoom Box XORColor == null ) { g . set XORMode (  Color . white ) ; } else { g . set XORMode ( m_ Zoom Box XORColor ) ; } g . draw Rect ( m_old Mouse Pos . width , m_old Mouse Pos . height , m_new Mouse Pos . width - m_old Mouse Pos . width , m_new Mouse Pos . height - m_old Mouse Pos . height ) ; g . dispose ( ) ; int cw = m_new Mouse Pos . width - m_old Mouse Pos . width ; int ch = m_new Mouse Pos . height - m_old Mouse Pos . height ; if ( cw >= _ NUM && ch >= _ NUM ) { if ( mouse In Bounds ( e ) && ( get Size ( ) . width / cw ) <= _ NUM && ( get Size ( ) . height / ch ) <= _ NUM ) {  Dimension ns = new  Dimension ( ) ;  Dimension np = new  Dimension ( ) ; double nvsw = get Size ( ) . width / ( double ) ( cw ) ; double nvsh = get Size ( ) . height / ( double ) ( ch ) ; np . width = ( int ) ( ( m_old Mouse Pos . width - m_view Pos . width ) * - nvsw ) ; np . height = ( int ) ( ( m_old Mouse Pos . height - m_view Pos . height ) * - nvsh ) ; ns . width = ( int ) ( m_view Size . width * nvsw ) ; ns . height = ( int ) ( m_view Size . height * nvsh ) ; animate Scaling ( np , ns , _ NUM ) ; } } } else if ( m_mouse State == _ NUM && m_scaling == _ NUM ) { m_mouse State = _ NUM ; set Font ( new  Font ( _ STR , _ NUM , _ NUM ) ) ; int s = - _ NUM ; for ( int noa = _ NUM ; noa < m_num Nodes ; noa ++ ) { if ( m_nodes [ noa ] . m_quad == _ NUM ) { calc Screen Coords ( noa ) ; if ( e . get X ( ) <= m_nodes [ noa ] . m_center + m_nodes [ noa ] . m_side && e . get X ( ) >= m_nodes [ noa ] . m_center - m_nodes [ noa ] . m_side && e . get Y ( ) >= m_nodes [ noa ] . m_top && e . get Y ( ) <= m_nodes [ noa ] . m_top + m_nodes [ noa ] . m_height ) { s = noa ; } m_nodes [ noa ] . m_top = _ NUM ; } } if ( s == - _ NUM ) { m_win Menu . show ( this , e . get X ( ) , e . get Y ( ) ) ; } else { m_focus Node = s ; m_node Menu . show ( this , e . get X ( ) , e . get Y ( ) ) ; } set Font ( m_current Font ) ; } else if ( m_mouse State == _ NUM ) { m_mouse State = _ NUM ; m_frame Limiter . stop ( ) ; repaint ( ) ; } }
public static final  Collection <  Race > find Races (  String stream ,  Collection <  Race > races ) {  Collection <  Race > result = new  Array List < > ( ) ; for (  Race r : races ) { for (  Entrant e : r . get Entrants ( ) ) { if ( stream . equals Ignore Case ( e . twitch ) ) { result . add ( r ) ; } } } return result ; }
public boolean anonymous ( ) { return _parameter Metadata . contains (  Metadata .  ANONYMOUS ) ; }
protected  T prepare Error Fragment (  Throwable Failure Event event , boolean finish After Dialog ,  Bundle arguments For Error Dialog ) { if ( event . is Suppress Error Ui ( ) ) { return null ; }  Bundle bundle ; if ( arguments For Error Dialog != null ) { bundle = (  Bundle ) arguments For Error Dialog . clone ( ) ; } else { bundle = new  Bundle ( ) ; } if ( ! bundle . contains Key (  Error Dialog Manager .  KEY_ TITLE ) ) {  String title = get Title For ( event , bundle ) ; bundle . put String (  Error Dialog Manager .  KEY_ TITLE , title ) ; } if ( ! bundle . contains Key (  Error Dialog Manager .  KEY_ MESSAGE ) ) {  String message = get Message For ( event , bundle ) ; bundle . put String (  Error Dialog Manager .  KEY_ MESSAGE , message ) ; } if ( ! bundle . contains Key (  Error Dialog Manager .  KEY_ FINISH_ AFTER_ DIALOG ) ) { bundle . put Boolean (  Error Dialog Manager .  KEY_ FINISH_ AFTER_ DIALOG , finish After Dialog ) ; } if ( ! bundle . contains Key (  Error Dialog Manager .  KEY_ EVENT_ TYPE_ ON_ CLOSE ) && config . default Event Type On Dialog Closed != null ) { bundle . put Serializable (  Error Dialog Manager .  KEY_ EVENT_ TYPE_ ON_ CLOSE , config . default Event Type On Dialog Closed ) ; } if ( ! bundle . contains Key (  Error Dialog Manager .  KEY_ ICON_ ID ) && config . default Dialog Icon Id != _ NUM ) { bundle . put Int (  Error Dialog Manager .  KEY_ ICON_ ID , config . default Dialog Icon Id ) ; } return create Error Fragment ( event , bundle ) ; }
private  Object iterative Method (  Context cx , int id ,  Scriptable scope ,  Scriptable this Obj ,  Object [ ] args ) {  Object callback Arg = args . length > _ NUM ? args [ _ NUM ] :  Undefined . instance ; if ( callback Arg == null || ! ( callback Arg instanceof  Function ) ) { throw  Script Runtime . not Function Error ( callback Arg ) ; }  Function f = (  Function ) callback Arg ;  Scriptable parent =  Scriptable Object . get Top Level Scope ( f ) ;  Scriptable this Arg ; if ( args . length < _ NUM || args [ _ NUM ] == null || args [ _ NUM ] ==  Undefined . instance ) { this Arg = parent ; } else { this Arg =  Script Runtime . to Object ( cx , scope , args [ _ NUM ] ) ; } long length = get Length Property ( cx , this Obj ) ; int result Length = id ==  Id_map ? ( int ) length : _ NUM ;  Scriptable array = cx . new Array ( scope , result Length ) ; long j = _ NUM ; for ( long i = _ NUM ; i < length ; i ++ ) {  Object [ ] inner Args = new  Object [ _ NUM ] ;  Object elem = get Raw Elem ( this Obj , i ) ; if ( elem ==  Scriptable .  NOT_ FOUND ) { continue ; } inner Args [ _ NUM ] = elem ; inner Args [ _ NUM ] =  Long . value Of ( i ) ; inner Args [ _ NUM ] = this Obj ;  Object result = f . call ( cx , parent , this Arg , inner Args ) ; switch ( id ) { case  Id_every : if ( !  Script Runtime . to Boolean ( result ) ) return  Boolean .  FALSE ; break ; case  Id_filter : if (  Script Runtime . to Boolean ( result ) ) set Elem ( cx , array , j ++ , inner Args [ _ NUM ] ) ; break ; case  Id_for Each : break ; case  Id_map : set Elem ( cx , array , i , result ) ; break ; case  Id_some : if (  Script Runtime . to Boolean ( result ) ) return  Boolean .  TRUE ; break ; } } switch ( id ) { case  Id_every : return  Boolean .  TRUE ; case  Id_filter : case  Id_map : return array ; case  Id_some : return  Boolean .  FALSE ; case  Id_for Each : default : return  Undefined . instance ; } }
public void add Biome Type (  Biome Dictionary .  Type type ) {  Array List <  Biome Gen Base > entry List = new  Array List <  Biome Gen Base > ( ) ; entry List . add All (  Arrays . as List (  Biome Dictionary . get Biomes For Type ( type ) ) ) ; entry List . remove (  Biome Gen Base . hell ) ; entry List . remove (  Biome Gen Base . sky ) ;  Iterator <  Biome Gen Base > iter = entry List . iterator ( ) ; while ( iter . has Next ( ) ) {  Biome Gen Base nextbiome = iter . next ( ) ; for (  Biome Entry entry : allowed Biomes ) { if (  Biome Dictionary . are Biomes Equivalent ( entry . biome , nextbiome ) ) iter . remove ( ) ; } } allowed Biomes . add All ( get Biomes Entries ( entry List ) ) ; }
static void calculate Tiled Layout (  Layout Iterator iter , int target Span ) { long preferred = _ NUM ; long current Preferred ; int last Margin = _ NUM ; int total Spacing = _ NUM ; int n = iter . get Count ( ) ; int adjustment Weights Count =  Layout Iterator .  Worst Adjustment Weight + _ NUM ; long gain [ ] = new long [ adjustment Weights Count ] ; long loss [ ] = new long [ adjustment Weights Count ] ; for ( int i = _ NUM ; i < adjustment Weights Count ; i ++ ) { gain [ i ] = loss [ i ] = _ NUM ; } for ( int i = _ NUM ; i < n ; i ++ ) { iter . set Index ( i ) ; int margin0 = last Margin ; int margin1 = ( int ) iter . get Leading Collapse Span ( ) ; iter . set Offset (  Math . max ( margin0 , margin1 ) ) ; total Spacing += iter . get Offset ( ) ; current Preferred = ( long ) iter . get Preferred Span ( target Span ) ; iter . set Span ( ( int ) current Preferred ) ; preferred += current Preferred ; gain [ iter . get Adjustment Weight ( ) ] += ( long ) iter . get Maximum Span ( target Span ) - current Preferred ; loss [ iter . get Adjustment Weight ( ) ] += current Preferred - ( long ) iter . get Minimum Span ( target Span ) ; last Margin = ( int ) iter . get Trailing Collapse Span ( ) ; } total Spacing += last Margin ; total Spacing += _ NUM * iter . get Border Width ( ) ; for ( int i = _ NUM ; i < adjustment Weights Count ; i ++ ) { gain [ i ] += gain [ i - _ NUM ] ; loss [ i ] += loss [ i - _ NUM ] ; } int allocated = target Span - total Spacing ; long desired Adjustment = allocated - preferred ; long adjustments Array [ ] = ( desired Adjustment > _ NUM ) ? gain : loss ; desired Adjustment =  Math . abs ( desired Adjustment ) ; int adjustment Level = _ NUM ; for ( ; adjustment Level <=  Layout Iterator .  Worst Adjustment Weight ; adjustment Level ++ ) { if ( adjustments Array [ adjustment Level ] >= desired Adjustment ) { break ; } } float adjustment Factor = _ NUM ; if ( adjustment Level <=  Layout Iterator .  Worst Adjustment Weight ) { desired Adjustment -= ( adjustment Level > _ NUM ) ? adjustments Array [ adjustment Level - _ NUM ] : _ NUM ; if ( desired Adjustment != _ NUM ) { float maximum Adjustment = adjustments Array [ adjustment Level ] - ( ( adjustment Level > _ NUM ) ? adjustments Array [ adjustment Level - _ NUM ] : _ NUM ) ; adjustment Factor = desired Adjustment / maximum Adjustment ; } } int total Offset = ( int ) iter . get Border Width ( ) ; for ( int i = _ NUM ; i < n ; i ++ ) { iter . set Index ( i ) ; iter . set Offset ( iter . get Offset ( ) + total Offset ) ; if ( iter . get Adjustment Weight ( ) < adjustment Level ) { iter . set Span ( ( int ) ( ( allocated > preferred ) ?  Math . floor ( iter . get Maximum Span ( target Span ) ) :  Math . ceil ( iter . get Minimum Span ( target Span ) ) ) ) ; } else if ( iter . get Adjustment Weight ( ) == adjustment Level ) { int available Span = ( allocated > preferred ) ? ( int ) iter . get Maximum Span ( target Span ) - iter . get Span ( ) : iter . get Span ( ) - ( int ) iter . get Minimum Span ( target Span ) ; int adj = ( int )  Math . floor ( adjustment Factor * available Span ) ; iter . set Span ( iter . get Span ( ) + ( ( allocated > preferred ) ? adj : - adj ) ) ; } total Offset = ( int )  Math . min ( ( long ) iter . get Offset ( ) + ( long ) iter . get Span ( ) ,  Integer .  MAX_ VALUE ) ; } int round Error = target Span - total Offset - ( int ) iter . get Trailing Collapse Span ( ) - ( int ) iter . get Border Width ( ) ; int adj = ( round Error > _ NUM ) ? _ NUM : - _ NUM ; round Error *= adj ; boolean can Adjust = _ BOOL ; while ( round Error > _ NUM && can Adjust ) { can Adjust = _ BOOL ; int offset Adjust = _ NUM ; for ( int i = _ NUM ; i < n ; i ++ ) { iter . set Index ( i ) ; iter . set Offset ( iter . get Offset ( ) + offset Adjust ) ; int cur Span = iter . get Span ( ) ; if ( round Error > _ NUM ) { int bound Gap = ( adj > _ NUM ) ? ( int )  Math . floor ( iter . get Maximum Span ( target Span ) ) - cur Span : cur Span - ( int )  Math . ceil ( iter . get Minimum Span ( target Span ) ) ; if ( bound Gap >= _ NUM ) { can Adjust = _ BOOL ; iter . set Span ( cur Span + adj ) ; offset Adjust += adj ; round Error -- ; } } } } }
public static void write Padded Integer (  Writer out , int value , int size ) throws  IOException { if ( value < _ NUM ) { out . write ( _ STR ) ; if ( value !=  Integer .  MIN_ VALUE ) { value = - value ; } else { for ( ; size > _ NUM ; size -- ) { out . write ( _ STR ) ; } out . write ( _ STR + - ( long )  Integer .  MIN_ VALUE ) ; return ; } } if ( value < _ NUM ) { for ( ; size > _ NUM ; size -- ) { out . write ( _ STR ) ; } out . write ( value + _ STR ) ; } else if ( value < _ NUM ) { for ( ; size > _ NUM ; size -- ) { out . write ( _ STR ) ; } int d = ( ( value + _ NUM ) * _ NUM ) > > _ NUM ; out . write ( d + _ STR ) ; out . write ( value - ( d << _ NUM ) - ( d << _ NUM ) + _ STR ) ; } else { int digits ; if ( value < _ NUM ) { digits = _ NUM ; } else if ( value < _ NUM ) { digits = _ NUM ; } else { digits = ( int ) (  Math . log ( value ) /  LOG_10 ) + _ NUM ; } for ( ; size > digits ; size -- ) { out . write ( _ STR ) ; } out . write (  Integer . to String ( value ) ) ; } }
public static  Matched Values Request Control new Control ( final boolean is Critical , final  String ... filters ) {  Reject . if False ( filters . length > _ NUM , _ STR ) ; final  List <  Filter > parsed Filters = new  Array List < > ( filters . length ) ; for ( final  String filter : filters ) { parsed Filters . add ( validate Filter (  Filter . value Of ( filter ) ) ) ; } return new  Matched Values Request Control ( is Critical ,  Collections . unmodifiable List ( parsed Filters ) ) ; }
int find Index Of Valid Field (  String blob ) { for (  Field field :  Attribute Compression Strategy . get All Valid Fields (  Internal Session . class ) ) {  String search =  JSONSerialisation . json Attribute Name ( field . get Name ( ) ) ; int index = blob . index Of ( search ) ; if ( index != - _ NUM ) { return index ; } } return - _ NUM ; }
void define Labels ( ) { labels Values = calc Labels ( ) ; if ( handle Values ) labels = get Labels From Values ( ) ; else labels = get Labels From Data ( ) ; n Labels = labels . size ( ) ; }
public  List <  Interval > insert B (  List <  Interval > intervals ,  Interval new Interval ) { int i = _ NUM ; while ( i < intervals . size ( ) && intervals . get ( i ) . end < new Interval . start ) { i ++ ; } while ( i < intervals . size ( ) && intervals . get ( i ) . start <= new Interval . end ) { new Interval = new  Interval (  Math . min ( intervals . get ( i ) . start , new Interval . start ) ,  Math . max ( intervals . get ( i ) . end , new Interval . end ) ) ; intervals . remove ( i ) ; } intervals . add ( i , new Interval ) ; return intervals ; }
public static  String take While (  GString self , @  Closure Params ( value =  From String . class , conflict Resolution Strategy =  Pick First Resolver . class , options = { _ STR , _ STR } )  Closure condition ) { return take While ( self . to String ( ) , condition ) ; }
public  Node Set DTM (  Node List node List ,  XPath Context xctxt ) { super ( ) ; m_manager = xctxt . get DTMManager ( ) ; int n = node List . get Length ( ) ; for ( int i = _ NUM ; i < n ; i ++ ) {  Node node = node List . item ( i ) ; int handle = xctxt . get DTMHandle From Node ( node ) ; add Node ( handle ) ; } }
public void print Text (  String text ,  String color ) { view . print ( text , text . ends With ( _ STR ) , color ) ; for (  Action Delegate action Delegate : action Delegates ) { action Delegate . on Console Output ( this ) ; } }
protected void ensure Rows Are Visible ( int begin Row , int end Row ) { if ( tree != null && begin Row >= _ NUM && end Row < get Row Count ( tree ) ) { boolean scroll Vert =  Default Lookup . get Boolean ( tree , this , _ STR , _ BOOL ) ; if ( begin Row == end Row ) {  Rectangle scroll Bounds = get Path Bounds ( tree , get Path For Row ( tree , begin Row ) ) ; if ( scroll Bounds != null ) { if ( ! scroll Vert ) { scroll Bounds . x = tree . get Visible Rect ( ) . x ; scroll Bounds . width = _ NUM ; } tree . scroll Rect To Visible ( scroll Bounds ) ; } } else {  Rectangle begin Rect = get Path Bounds ( tree , get Path For Row ( tree , begin Row ) ) ; if ( begin Rect != null ) {  Rectangle vis Rect = tree . get Visible Rect ( ) ;  Rectangle test Rect = begin Rect ; int begin Y = begin Rect . y ; int max Y = begin Y + vis Rect . height ; for ( int counter = begin Row + _ NUM ; counter <= end Row ; counter ++ ) { test Rect = get Path Bounds ( tree , get Path For Row ( tree , counter ) ) ; if ( test Rect == null ) { return ; } if ( ( test Rect . y + test Rect . height ) > max Y ) counter = end Row ; } tree . scroll Rect To Visible ( new  Rectangle ( vis Rect . x , begin Y , _ NUM , test Rect . y + test Rect . height - begin Y ) ) ; } } } }
private void divide (  DBIDArray Iter it , double [ ] data ,  Array List <  DBIDs > idx , int start , int end , int depth ,  Mean mean ) { final int count = end - start ; if ( depth == _ NUM ) { if ( count > _ NUM ) {  Modifiable DBIDs out =  DBIDUtil . new Hash Set ( count ) ; it . seek ( start ) ; for ( int i = count ; i > _ NUM ; i -- , it . advance ( ) ) { out . add ( it ) ; } idx . add ( out ) ; } else { idx . add (  DBIDUtil .  EMPTYDBIDS ) ; } return ; } else { if ( count > _ NUM ) { mean . reset ( ) ; for ( int i = start ; i < end ; i ++ ) { mean . put ( data [ i ] ) ; } final double m = mean . get Mean ( ) ; int pos =  Arrays . binary Search ( data , start , end , m ) ; if ( pos >= _ NUM ) { int opt = ( start + end ) > > _ NUM ; while (  Double . compare ( data [ pos ] , m ) == _ NUM ) { if ( pos < opt ) { pos ++ ; } else if ( pos > opt ) { pos -- ; } else { break ; } } } else { pos = ( - pos - _ NUM ) ; } divide ( it , data , idx , start , pos , depth - _ NUM , mean ) ; divide ( it , data , idx , pos , end , depth - _ NUM , mean ) ; } else { divide ( it , data , idx , start , end , depth - _ NUM , mean ) ; divide ( it , data , idx , start , end , depth - _ NUM , mean ) ; } } }
void assert Thread Stays Alive (  Thread thread , long millis ) { try { delay ( millis ) ; assert True ( thread . is Alive ( ) ) ; } catch (  Interrupted Exception fail ) { thread Fail ( _ STR ) ; } }
public  Id Query (  String type Name ,  Object id ,  Object routing ,  Query Result Type query Result Type , int version ) { if ( type Name == null || type Name . length ( ) == _ NUM ) throw new  Illegal Argument Exception ( _ STR ) ; if ( id == null ) throw new  Illegal Argument Exception ( _ STR ) ; if ( query Result Type == null ) throw new  Illegal Argument Exception ( _ STR ) ; if ( version < _ NUM ) throw new  Illegal Argument Exception ( _ STR ) ; this . _type Name = type Name ; this . _id = id ; this . _routing = routing ; this . _query Result Type = query Result Type ; this . _version = version ; }
@  Override public double [ ] analyse ( double [ ] frame ) { if ( frame . length != get Frame Length Samples ( ) ) throw new  Illegal Argument Exception ( _ STR + get Frame Length Samples ( ) + _ STR + frame . length ) ;  System . arraycopy ( frame , _ NUM , real , _ NUM , frame . length ) ; if ( real . length > frame . length )  Arrays . fill ( real , frame . length , real . length , _ NUM ) ;  FFT . real Transform ( real , _ BOOL ) ; return  FFT . compute Power Spectrum_ FD ( real ) ; }
public boolean move_drill_item (  Brd Abit p_drill_item ,  Pla Vector Int p_vector , int p_max_recursion_depth , int p_max_via_recursion_depth , int p_pull_tight_accuracy , int p_pull_tight_time_limit ) { shove_fail_clear ( ) ;  Collection <  Brd Item > contact_list = p_drill_item . get_normal_contacts ( ) ;  Iterator <  Brd Item > it = contact_list . iterator ( ) ; while ( it . has Next ( ) ) {  Brd Item curr_contact = it . next ( ) ; if ( curr_contact . get_fixed_state ( ) ==  Item Fix State .  SHOVE_ FIXED ) { curr_contact . set_fixed_state (  Item Fix State .  UNFIXED ) ; } }  Net Nos List net_no_arr = p_drill_item . net_nos ; changed_area_clear ( ) ; if ( ! move_drill_algo . insert ( p_drill_item , p_vector , p_max_recursion_depth , p_max_via_recursion_depth , null ) ) { return _ BOOL ; }  Net Nos List opt_net_no_arr = p_max_recursion_depth <= _ NUM ? net_no_arr :  Net Nos List .  EMPTY ;  Time Limit Stoppable t_limit = new  Time Limit Stoppable ( p_pull_tight_time_limit ) ; changed_area_optimize ( opt_net_no_arr , p_pull_tight_accuracy , null , t_limit , null ) ; return _ BOOL ; }
public static  String [ ] split (  Char Sequence self ) {  String Tokenizer st = new  String Tokenizer ( self . to String ( ) ) ;  String [ ] strings = new  String [ st . count Tokens ( ) ] ; for ( int i = _ NUM ; i < strings . length ; i ++ ) { strings [ i ] = st . next Token ( ) ; } return strings ; }
private char [ ] f Format Digits ( double x ) {  String sx , sx Out ; int i , j , k ; int n1 In , n2 In ; int expon = _ NUM ; boolean minus Sign = _ BOOL ; if ( x > _ NUM ) sx =  Double . to String ( x ) ; else if ( x < _ NUM ) { sx =  Double . to String ( - x ) ; minus Sign = _ BOOL ; } else { sx =  Double . to String ( x ) ; if ( sx . char At ( _ NUM ) == _ STR ) { minus Sign = _ BOOL ; sx = sx . substring ( _ NUM ) ; } } int e Pos = sx . index Of ( _ STR ) ; int r Pos = sx . index Of ( _ STR ) ; if ( r Pos != - _ NUM ) n1 In = r Pos ; else if ( e Pos != - _ NUM ) n1 In = e Pos ; else n1 In = sx . length ( ) ; if ( r Pos != - _ NUM ) { if ( e Pos != - _ NUM ) n2 In = e Pos - r Pos - _ NUM ; else n2 In = sx . length ( ) - r Pos - _ NUM ; } else n2 In = _ NUM ; if ( e Pos != - _ NUM ) { int ie = e Pos + _ NUM ; expon = _ NUM ; if ( sx . char At ( ie ) == _ STR ) { for ( ++ ie ; ie < sx . length ( ) ; ie ++ ) if ( sx . char At ( ie ) != _ STR ) break ; if ( ie < sx . length ( ) ) expon = -  Integer . parse Int ( sx . substring ( ie ) ) ; } else { if ( sx . char At ( ie ) == _ STR ) ++ ie ; for ( ; ie < sx . length ( ) ; ie ++ ) if ( sx . char At ( ie ) != _ STR ) break ; if ( ie < sx . length ( ) ) expon =  Integer . parse Int ( sx . substring ( ie ) ) ; } } int p ; if ( precision Set ) p = precision ; else p = default Digits - _ NUM ; char [ ] ca1 = sx . to Char Array ( ) ; char [ ] ca2 = new char [ n1 In + n2 In ] ; char [ ] ca3 , ca4 , ca5 ; for ( j = _ NUM ; j < n1 In ; j ++ ) ca2 [ j ] = ca1 [ j ] ; i = j + _ NUM ; for ( k = _ NUM ; k < n2 In ; j ++ , i ++ , k ++ ) ca2 [ j ] = ca1 [ i ] ; if ( n1 In + expon <= _ NUM ) { ca3 = new char [ - expon + n2 In ] ; for ( j = _ NUM , k = _ NUM ; k < ( - n1 In - expon ) ; k ++ , j ++ ) ca3 [ j ] = _ STR ; for ( i = _ NUM ; i < ( n1 In + n2 In ) ; i ++ , j ++ ) ca3 [ j ] = ca2 [ i ] ; } else ca3 = ca2 ; boolean carry = _ BOOL ; if ( p < - expon + n2 In ) { if ( expon < _ NUM ) i = p ; else i = p + n1 In ; carry = check For Carry ( ca3 , i ) ; if ( carry ) carry = start Symbolic Carry ( ca3 , i - _ NUM , _ NUM ) ; } if ( n1 In + expon <= _ NUM ) { ca4 = new char [ _ NUM + p ] ; if ( ! carry ) ca4 [ _ NUM ] = _ STR ; else ca4 [ _ NUM ] = _ STR ; if ( alternate Form || ! precision Set || precision != _ NUM ) { ca4 [ _ NUM ] = _ STR ; for ( i = _ NUM , j = _ NUM ; i <  Math . min ( p , ca3 . length ) ; i ++ , j ++ ) ca4 [ j ] = ca3 [ i ] ; for ( ; j < ca4 . length ; j ++ ) ca4 [ j ] = _ STR ; } } else { if ( ! carry ) { if ( alternate Form || ! precision Set || precision != _ NUM ) ca4 = new char [ n1 In + expon + p + _ NUM ] ; else ca4 = new char [ n1 In + expon ] ; j = _ NUM ; } else { if ( alternate Form || ! precision Set || precision != _ NUM ) ca4 = new char [ n1 In + expon + p + _ NUM ] ; else ca4 = new char [ n1 In + expon + _ NUM ] ; ca4 [ _ NUM ] = _ STR ; j = _ NUM ; } for ( i = _ NUM ; i <  Math . min ( n1 In + expon , ca3 . length ) ; i ++ , j ++ ) ca4 [ j ] = ca3 [ i ] ; for ( ; i < n1 In + expon ; i ++ , j ++ ) ca4 [ j ] = _ STR ; if ( alternate Form || ! precision Set || precision != _ NUM ) { ca4 [ j ] = _ STR ; j ++ ; for ( k = _ NUM ; i < ca3 . length && k < p ; i ++ , j ++ , k ++ ) ca4 [ j ] = ca3 [ i ] ; for ( ; j < ca4 . length ; j ++ ) ca4 [ j ] = _ STR ; } } int n Zeros = _ NUM ; if ( ! left Justify && leading Zeros ) { int x Thousands = _ NUM ; if ( thousands ) { int xlead = _ NUM ; if ( ca4 [ _ NUM ] == _ STR || ca4 [ _ NUM ] == _ STR || ca4 [ _ NUM ] == _ STR ) xlead = _ NUM ; int xdp = xlead ; for ( ; xdp < ca4 . length ; xdp ++ ) if ( ca4 [ xdp ] == _ STR ) break ; x Thousands = ( xdp - xlead ) / _ NUM ; } if ( field Width Set ) n Zeros = field Width - ca4 . length ; if ( ( ! minus Sign && ( leading Sign || leading Space ) ) || minus Sign ) n Zeros -- ; n Zeros -= x Thousands ; if ( n Zeros < _ NUM ) n Zeros = _ NUM ; } j = _ NUM ; if ( ( ! minus Sign && ( leading Sign || leading Space ) ) || minus Sign ) { ca5 = new char [ ca4 . length + n Zeros + _ NUM ] ; j ++ ; } else ca5 = new char [ ca4 . length + n Zeros ] ; if ( ! minus Sign ) { if ( leading Sign ) ca5 [ _ NUM ] = _ STR ; if ( leading Space ) ca5 [ _ NUM ] = _ STR ; } else ca5 [ _ NUM ] = _ STR ; for ( i = _ NUM ; i < n Zeros ; i ++ , j ++ ) ca5 [ j ] = _ STR ; for ( i = _ NUM ; i < ca4 . length ; i ++ , j ++ ) ca5 [ j ] = ca4 [ i ] ; int lead = _ NUM ; if ( ca5 [ _ NUM ] == _ STR || ca5 [ _ NUM ] == _ STR || ca5 [ _ NUM ] == _ STR ) lead = _ NUM ; int dp = lead ; for ( ; dp < ca5 . length ; dp ++ ) if ( ca5 [ dp ] == _ STR ) break ; int n Thousands = ( dp - lead ) / _ NUM ; if ( dp < ca5 . length ) ca5 [ dp ] = dfs . get Decimal Separator ( ) ; char [ ] ca6 = ca5 ; if ( thousands && n Thousands > _ NUM ) { ca6 = new char [ ca5 . length + n Thousands + lead ] ; ca6 [ _ NUM ] = ca5 [ _ NUM ] ; for ( i = lead , k = lead ; i < dp ; i ++ ) { if ( i > _ NUM && ( dp - i ) % _ NUM == _ NUM ) { ca6 [ k ] = dfs . get Grouping Separator ( ) ; ca6 [ k + _ NUM ] = ca5 [ i ] ; k += _ NUM ; } else { ca6 [ k ] = ca5 [ i ] ; k ++ ; } } for ( ; i < ca5 . length ; i ++ , k ++ ) { ca6 [ k ] = ca5 [ i ] ; } } return ca6 ; }
public int countk NN (  TObject Int Hash Map <  Object > counters ,  Object l ) { if ( l instanceof  Label List ) {  Label List ll = (  Label List ) l ; int m = _ NUM ; for ( int i = _ NUM , e = ll . size ( ) ; i < e ; i ++ ) { m =  Math . max ( m , counters . adjust Or Put Value ( ll . get ( i ) , _ NUM , _ NUM ) ) ; } return m ; } return counters . adjust Or Put Value ( l , _ NUM , _ NUM ) ; }
public  Pla Point Int round_to_the_right (  Pla Direction p_dir ) {  Pla Point Float dir = p_dir . to_float ( ) ; double rounded_x ; if ( dir . v_y > _ NUM ) { rounded_x =  Math . ceil ( v_x ) ; } else if ( dir . v_y < _ NUM ) { rounded_x =  Math . floor ( v_x ) ; } else { rounded_x =  Math . round ( v_x ) ; } double rounded_y ; if ( dir . v_x > _ NUM ) { rounded_y =  Math . floor ( v_y ) ; } else if ( dir . v_x < _ NUM ) { rounded_y =  Math . ceil ( v_y ) ; } else { rounded_y =  Math . round ( v_y ) ; } return new  Pla Point Int ( rounded_x , rounded_y ) ; }
public static synchronized void copy Synchronized ( final  File src , final  File dst ) throws  IOException { if ( src == null || ! src . exists ( ) || ! src . can Read ( ) ) throw new  IOException ( _ STR ) ; if ( ! is Writable ( dst , _ BOOL ) ) throw new  IOException ( _ STR ) ; final  File Input Stream fis = new  File Input Stream ( src ) ; final  File Output Stream fos = new  File Output Stream ( dst ) ; final  Input Stream in = new  Buffered Input Stream ( fis ) ; final  Buffered Output Stream out = new  Buffered Output Stream ( fos ) ; final byte [ ] buf = new byte [ _ NUM ] ; int len ;  IOException e = null ; try { while ( ( len = in . read ( buf ) ) > _ NUM ) out . write ( buf , _ NUM , len ) ; } catch (  IOException e1 ) { e = e1 ; } try { in . close ( ) ; } catch (  IOException ignored ) { } try { fis . close ( ) ; } catch (  IOException ignored ) { } try { out . flush ( ) ; out . close ( ) ; } catch (  IOException ignored ) { } try { fos . flush ( ) ; fos . close ( ) ; } catch (  IOException ignored ) { } sync ( fos ) ; if ( e != null ) throw e ; }
public boolean authenticate User (  String username ,  String password ,  String uri ) throws  Data Access Exception { if ( null == username || null == password ) { return _ BOOL ; }  User Info user = get User Info ( username ) ; if ( user == null ) { return _ BOOL ; }  String hashed Salted Password =  Utilities . get Salted Password ( username , uri , password ) ; return hashed Salted Password . equals ( user . get Hashed Password ( ) ) ; }
public static  String dump ( final  Byte Buffer bytes ) { bytes . rewind ( ) ; final int columns = _ NUM ; final  String Builder builder = new  String Builder ( ) ; int i = _ NUM ; while ( bytes . has Remaining ( ) ) { if ( ( i % columns ) != _ NUM ) { builder . append ( _ STR ) ; } else if ( i >= columns ) { builder . append (  String . format ( _ STR ) ) ; } builder . append (  String . format ( _ STR , bytes . get ( ) ) ) ; i ++ ; } return builder . to String ( ) ; }
public static void unregister MBean (  Class < ? > mbean Interface ,  String mbean Name ) {  MBean Server mbs =  Management Factory . get Platform MBean Server ( ) ; try {  Object Name name = generate MBean Object Name ( mbean Interface . get Name ( ) , mbean Name ) ; if ( mbs . is Registered ( name ) ) { logger . info ( _ STR + name . to String ( ) ) ; mbs . unregister MBean ( name ) ; } else { logger . warn ( _ STR + name . to String ( ) ) ; } } catch (  Exception e ) { throw new  Server Runtime Exception ( _ STR + mbean Interface + _ STR + mbean Name , e ) ; } }
public static  Set <  String > to String Set (  Template Collection Model coll Model ) throws  Template Model Exception {  Set <  String > set = new  Hash Set <  String > ( ) ;  Template Model Iterator model It = coll Model . iterator ( ) ; while ( model It . has Next ( ) ) { set . add ( get As String Non Escaping ( (  Template Scalar Model ) model It . next ( ) ) ) ; } return set ; }
@  Override public  Key Store load Key Store (  File file ,  String key Store Type ,  String password ) {  Key Store key Store ; try { key Store =  Key Store . get Instance ( key Store Type ) ; } catch (  Key Store Exception e ) { throw new  Key Store Access Exception ( _ STR + key Store Type , e ) ; } try {  Input Stream keystore As Stream = new  File Input Stream ( file ) ; key Store . load ( keystore As Stream , password . to Char Array ( ) ) ; } catch (  IOException e ) { throw new  Import Exception ( _ STR + file . get Name ( ) , e ) ; } catch (  Certificate Exception |  No Such Algorithm Exception e ) { throw new  Import Exception ( _ STR , e ) ; } return key Store ; }
public void load (  File Location loc ,  String default Enc ) throws  IOException { this . loc = loc ; if ( loc . is Local ( ) && ! loc . is Local And Exists ( ) ) { this . char Set = default Enc != null ? default Enc : get Default Encoding ( ) ; return ; }  Unicode Reader ur = new  Unicode Reader ( loc . get Input Stream ( ) , default Enc ) ; char Set = ur . get Encoding ( ) ;  Document doc = get Document ( ) ; doc . remove Document Listener ( this ) ;  Buffered Reader r = new  Buffered Reader ( ur ) ; try { read ( r , null ) ; } finally { doc . add Document Listener ( this ) ; r . close ( ) ; } }
protected  Table __union (  Table t , int offset ) { offset += bb_pos ; t . bb_pos = offset + bb . get Int ( offset ) ; t . bb = bb ; return t ; }
public static  Element select Element (  XPath Expression expr ,  Node context ) { try {  Object result = expr . evaluate ( context ,  XPath Constants .  NODE ) ; if ( result == null ) { return null ; } else if ( result instanceof  Element ) { return (  Element ) result ; } else { throw new  Xml Exception ( _ STR + result ) ; } } catch (  XPath Expression Exception e ) { throw new  Xml Exception ( e ) ; } }
public static  Carbon Message create Text Response ( int status ,  String msg ) {  Default Carbon Message response = new  Default Carbon Message ( ) ; response . set Property (  Constants .  HTTP_ STATUS_ CODE , status ) ; if ( msg != null ) { response . set Header (  Http Headers .  CONTENT_ LENGTH ,  String . value Of ( msg . length ( ) ) ) ; response . set String Message Body ( msg ) ; } else { response . set Header (  Http Headers .  CONTENT_ LENGTH , _ STR ) ; } return response ; }
public int read ( byte b [ ] , int off , int len ) throws  IOException { int numread = _ NUM ; int copy ; if ( len < bytesinbuffer ) copy = len ; else copy = bytesinbuffer ; numread += copy ; bytesinbuffer -= copy ;  System . arraycopy ( buffer , curptr , b , off , copy ) ; curptr += copy ; off += copy ; if ( len == copy ) return numread ; len -= copy ; if ( len > _ NUM ) { final int bcnt = super . read ( b , off , len ) ; firstbyteoffset += ( curptr + bcnt ) ; curptr = _ NUM ; return ( numread + bcnt ) ; } else { try { refill Buffer ( ) ; } catch (  EOFException e ) { if ( numread >= _ NUM ) { numread = - _ NUM ; } return numread ; } return ( numread + read ( b , off , len ) ) ; } }
void init Program ( ) { gl Use Program ( this . program ) ; view Matrix Uniform = gl Get Uniform Location ( this . program , _ STR ) ; proj Matrix Uniform = gl Get Uniform Location ( this . program , _ STR ) ; viewport Size Uniform = gl Get Uniform Location ( this . program , _ STR ) ; gl Use Program ( _ NUM ) ; }
public void test Float Value Pos ( ) {  String a = _ STR ;  Big Decimal a Number = new  Big Decimal ( a ) ; float result = _ NUM ; assert True ( _ STR , a Number . float Value ( ) == result ) ; }
public  Key Store History (  Key Store key Store ,  String name ,  Password password ,  Provider explicit Provider ) { this . name = name ; this . explicit Provider = explicit Provider ;  Key Store Type type =  Key Store Type . resolve Jce ( key Store . get Type ( ) ) ; if ( type . is File Based ( ) ) { initial State = new  Key Store State ( this , key Store , password ) ; } else { initial State = new  Always Identical Key Store State ( this , key Store , password ) ; } current State = initial State ; }
@  Override public void draw Series (  Canvas canvas ,  Paint paint ,  List <  Float > points ,  XYSeries Renderer series Renderer , float y Axis Value , int series Index , int start Index ) { int series Nr = m Dataset . get Series Count ( ) ; int length = points . size ( ) ; paint . set Color ( series Renderer . get Color ( ) ) ; paint . set Style (  Style .  FILL ) ; float half Diff X = get Half Diff X ( points , length , series Nr ) ; for ( int i = _ NUM ; i < length ; i += _ NUM ) { float x = points . get ( i ) ; float y = points . get ( i + _ NUM ) ; draw Bar ( canvas , x , y Axis Value , x , y , half Diff X , series Nr , series Index , paint ) ; } paint . set Color ( series Renderer . get Color ( ) ) ; }
private boolean has Def Clear Path (  Def Use target DU ,  Bytecode Instruction current Vertex ,  Set <  String > handle ) { if ( ! graph . contains Vertex ( current Vertex ) ) throw new  Illegal Argument Exception ( _ STR ) ; handle . add ( method Name ) ;  String target Variable = target DU . get Variable Name ( ) ; if ( current Vertex . is Definition For Variable ( target Variable ) ) return _ BOOL ;  Set <  Control Flow Edge > outgoing Edges = graph . outgoing Edges Of ( current Vertex ) ; if ( outgoing Edges . size ( ) == _ NUM ) return _ BOOL ; for (  Control Flow Edge e : outgoing Edges ) {  Bytecode Instruction edge Target = graph . get Edge Target ( e ) ; if ( can Be Overwriting Method ( target DU , edge Target ) && ! handle . contains ( edge Target . get Called Method ( ) ) && can Overwrite DU ( target DU , edge Target , handle ) ) continue ; if ( has Def Clear Path ( target DU , edge Target , handle ) ) return _ BOOL ; } return _ BOOL ; }
public  Prompting Trust Manager ( final  Console Application app , final  String accepted Store Path , final  X509 Trust Manager source Trust Manager ) throws  Key Store Exception ,  IOException ,  No Such Algorithm Exception ,  Certificate Exception {  Reject . if Null ( app , accepted Store Path ) ; this . app = app ; this . nested Trust Manager = source Trust Manager ; in Memory Trust Store =  Key Store . get Instance (  Key Store . get Default Type ( ) ) ; on Disk Trust Store =  Key Store . get Instance (  Key Store . get Default Type ( ) ) ; final  File on Disk Trust Store Path = new  File ( accepted Store Path ) ; in Memory Trust Store . load ( null , null ) ; if ( ! on Disk Trust Store Path . exists ( ) ) { on Disk Trust Store . load ( null , null ) ; } else { try ( final  File Input Stream fos = new  File Input Stream ( on Disk Trust Store Path ) ) { on Disk Trust Store . load ( fos ,  DEFAULT_ PASSWORD ) ; } } final  Trust Manager Factory tmf =  Trust Manager Factory . get Instance (  Trust Manager Factory . get Default Algorithm ( ) ) ; tmf . init ( in Memory Trust Store ) ;  X509 Trust Manager x509tm = null ; for ( final  Trust Manager tm : tmf . get Trust Managers ( ) ) { if ( tm instanceof  X509 Trust Manager ) { x509tm = (  X509 Trust Manager ) tm ; break ; } } if ( x509tm == null ) { throw new  No Such Algorithm Exception ( ) ; } this . in Memory Trust Manager = x509tm ; tmf . init ( on Disk Trust Store ) ; x509tm = null ; for ( final  Trust Manager tm : tmf . get Trust Managers ( ) ) { if ( tm instanceof  X509 Trust Manager ) { x509tm = (  X509 Trust Manager ) tm ; break ; } } if ( x509tm == null ) { throw new  No Such Algorithm Exception ( ) ; } this . on Disk Trust Manager = x509tm ; }
public  Pooled Executor With DMStats (  Blocking Queue <  Runnable > q , int pool Size ,  Thread Factory tf ) { this ( q , pool Size , null , tf ) ; }
public final void remove Helper Text Color ( @  Color Int final int color ) { int index = helper Text Colors . index Of ( color ) ; if ( index != - _ NUM ) { helper Text Colors . remove ( index ) ; verify Password Strength ( ) ; } }
public void test_validate ( ) { }
List Based Token Stream (  List <  Attribute Source > tokens ) { this . tokens = tokens ; token Iterator = tokens . iterator ( ) ; }
@  Override protected  Class < ? > resolve Class (  Object Stream Class object Stream Class ) throws  IOException ,  Class Not Found Exception {  Class < ? > clazz =  Class . for Name ( object Stream Class . get Name ( ) , _ BOOL , class Loader ) ; if ( clazz != null ) { return clazz ; } else { return super . resolve Class ( object Stream Class ) ; } }
public static int find ( byte [ ] a , int from Index , int to Index , byte key ) { int result = - _ NUM ; if ( from Index < _ NUM ) { from Index = _ NUM ; } to Index =  Math . min ( to Index , a . length ) ; for ( int i = from Index ; from Index < to Index && result == - _ NUM && i < to Index ; i ++ ) { if ( a [ i ] == key ) { result = i ; } } return result ; }
public  Collection <  Graph Node > compute Successor Nodes ( ) {  Collection <  Graph Node > result =  Lists . new Array List ( ) ; for (  Graph Edge edge : get Forward Edges ( ) ) { result . add ( edge . get Tail ( ) ) ; } for (  Graph Edge edge : get Reverse Edges ( ) ) { result . add ( edge . get Head ( ) ) ; } return result ; }
public  State Machine (  State [ ] s ) { for ( int i = _ NUM ; i < s . length ; i ++ ) states . add Element ( s [ i ] ) ; }
private static int  Windows Reg Flush Key1 ( int h Key ) { int result =  Windows Reg Flush Key ( h Key ) ; if ( result ==  ERROR_ SUCCESS ) { return result ; } else { long sleep Time =  INIT_ SLEEP_ TIME ; for ( int i = _ NUM ; i <  MAX_ ATTEMPTS ; i ++ ) { try {  Thread . sleep ( sleep Time ) ; } catch (  Interrupted Exception e ) { return result ; } sleep Time *= _ NUM ; result =  Windows Reg Flush Key ( h Key ) ; if ( result ==  ERROR_ SUCCESS ) { return result ; } } } return result ; }
public  Tasker add UITask (  Task task ) { tasks . add ( task ) ; task . set Run Type (  THREAD_ TYPE .  UI ) ; last Added Task = task ; return this ; }
private void init Compute Program ( ) { gl Use Program ( compute Program ) ;  Int Buffer work Group Size =  Buffer Utils . create Int Buffer ( _ NUM ) ; gl Get Programiv ( compute Program ,  GL_ COMPUTE_ WORK_ GROUP_ SIZE , work Group Size ) ; work Group Size X = work Group Size . get ( _ NUM ) ; work Group Size Y = work Group Size . get ( _ NUM ) ; time Uniform = gl Get Uniform Location ( compute Program , _ STR ) ; blend Factor Uniform = gl Get Uniform Location ( compute Program , _ STR ) ; bounce Count Uniform = gl Get Uniform Location ( compute Program , _ STR ) ; int boxes Resource Index = gl Get Program Resource Index ( compute Program ,  GL_ SHADER_ STORAGE_ BLOCK , _ STR ) ;  Int Buffer props =  Buffer Utils . create Int Buffer ( _ NUM ) ;  Int Buffer params =  Buffer Utils . create Int Buffer ( _ NUM ) ; props . put ( _ NUM ,  GL_ BUFFER_ BINDING ) ; gl Get Program Resourceiv ( compute Program ,  GL_ SHADER_ STORAGE_ BLOCK , boxes Resource Index , props , null , params ) ; boxes Ssbo Binding = params . get ( _ NUM ) ; int loc = gl Get Uniform Location ( compute Program , _ STR ) ; gl Get Uniformiv ( compute Program , loc , params ) ; framebuffer Image Binding = params . get ( _ NUM ) ; loc = gl Get Uniform Location ( compute Program , _ STR ) ; gl Get Uniformiv ( compute Program , loc , params ) ; world Position Image Binding = params . get ( _ NUM ) ; loc = gl Get Uniform Location ( compute Program , _ STR ) ; gl Get Uniformiv ( compute Program , loc , params ) ; world Normal Image Binding = params . get ( _ NUM ) ; gl Use Program ( _ NUM ) ; }
public void sort ( ) { if ( ! sorted ) {  Collections . sort ( samples ) ; sorted = _ BOOL ; } }
public static  Object object From Byte Buffer ( byte [ ] buffer ) throws  Exception { if ( buffer == null ) return null ;  Byte Array Input Stream in Stream = new  Byte Array Input Stream ( buffer ) ;  Object Input Stream in = new  Object Input Stream ( in Stream ) ;  Object retval = in . read Object ( ) ; in . close ( ) ; return retval ; }
public  String generate Group Name (  Set <  String > existing Group Names ,  String storage Group Name ) {  String storage Group Name Temp = storage Group Name . replace All (  Constants .  SMIS_ PLUS_ REGEX ,  Constants .  HYPHEN ) ; _log . info ( _ STR , storage Group Name , storage Group Name Temp ) ;  String result = storage Group Name Temp ; if ( existing Group Names . contains ( storage Group Name Temp . to Lower Case ( ) ) ) { int size = existing Group Names . size ( ) ; for ( int index = _ NUM ; index <= size ; index ++ ) { result =  String . format ( _ STR , storage Group Name Temp , index ) ; if ( ! existing Group Names . contains ( result . to Lower Case ( ) ) ) { break ; } } } _log . info (  String . format ( _ STR , existing Group Names . size ( ) , storage Group Name Temp , result ) ) ; return result ; }
public  Multiple Actions ( final  Chat Action ... action ) { this . actions =  Arrays . as List ( action ) ; }
public boolean add Row (  Table Entry entry ) { try { int row = list . size ( ) ; list . add ( entry ) ; fire Table Rows Inserted ( row , row ) ; } catch (  Exception e ) { return _ BOOL ; } return _ BOOL ; }
@  Override protected void on Layout ( boolean changed , int l , int t , int r , int b ) { m Lines . clear ( ) ; m Line Heights . clear ( ) ; m Line Margins . clear ( ) ; int width = get Width ( ) ; int height = get Height ( ) ; int lines Sum = get Padding Top ( ) ; int line Width = _ NUM ; int line Height = _ NUM ;  List <  View > line Views = new  Array List <  View > ( ) ; float horizontal Gravity Factor ; switch ( ( m Gravity &  Gravity .  HORIZONTAL_ GRAVITY_ MASK ) ) { case  Gravity .  LEFT : default : horizontal Gravity Factor = _ NUM ; break ; case  Gravity .  CENTER_ HORIZONTAL : horizontal Gravity Factor = _ NUM ; break ; case  Gravity .  RIGHT : horizontal Gravity Factor = _ NUM ; break ; } for ( int i = _ NUM ; i < get Child Count ( ) ; i ++ ) {  View Group child = (  View Group ) get Child At ( i ) ; if ( child . get Visibility ( ) ==  View .  GONE ) { continue ; }  Layout Params lp = (  Layout Params ) child . get Layout Params ( ) ; int child Width = child . get Measured Width ( ) + lp . left Margin + lp . right Margin ; int child Height = child . get Measured Height ( ) + lp . bottom Margin + lp . top Margin ; if ( line Width + child Width > width ) { m Line Heights . add ( line Height ) ; m Lines . add ( line Views ) ; m Line Margins . add ( ( int ) ( ( width - line Width ) * horizontal Gravity Factor ) + get Padding Left ( ) ) ; lines Sum += line Height ; line Height = _ NUM ; line Width = _ NUM ; line Views = new  Array List < > ( ) ; } line Width += child Width ; line Height =  Math . max ( line Height , child Height ) ; line Views . add ( child ) ; } m Line Heights . add ( line Height ) ; m Lines . add ( line Views ) ; m Line Margins . add ( ( int ) ( ( width - line Width ) * horizontal Gravity Factor ) + get Padding Left ( ) ) ; lines Sum += line Height ; int vertical Gravity Margin = _ NUM ; switch ( ( m Gravity &  Gravity .  VERTICAL_ GRAVITY_ MASK ) ) { case  Gravity .  TOP : default : break ; case  Gravity .  CENTER_ VERTICAL : vertical Gravity Margin = ( height - lines Sum ) / _ NUM ; break ; case  Gravity .  BOTTOM : vertical Gravity Margin = height - lines Sum ; break ; } int num Lines = m Lines . size ( ) ; int left ; int top = get Padding Top ( ) ; for ( int i = _ NUM ; i < num Lines ; i ++ ) { line Height = m Line Heights . get ( i ) ; line Views = m Lines . get ( i ) ; left = m Line Margins . get ( i ) ; int children = line Views . size ( ) ; for ( int j = _ NUM ; j < children ; j ++ ) {  View child = line Views . get ( j ) ; if ( child . get Visibility ( ) ==  View .  GONE ) { continue ; }  Layout Params lp = (  Layout Params ) child . get Layout Params ( ) ; if ( lp . height ==  Layout Params .  MATCH_ PARENT ) { int child Width Mode =  Measure Spec .  AT_ MOST ; int child Width Size = line Width ; if ( lp . width ==  Layout Params .  MATCH_ PARENT ) { child Width Mode =  Measure Spec .  EXACTLY ; } else if ( lp . width >= _ NUM ) { child Width Mode =  Measure Spec .  EXACTLY ; child Width Size = lp . width ; } child . measure (  Measure Spec . make Measure Spec ( child Width Size , child Width Mode ) ,  Measure Spec . make Measure Spec ( line Height - lp . top Margin - lp . bottom Margin ,  Measure Spec .  EXACTLY ) ) ; } int child Width = child . get Measured Width ( ) ; int child Height = child . get Measured Height ( ) ; int gravity Margin = _ NUM ; if (  Gravity . is Vertical ( lp . gravity ) ) { switch ( lp . gravity ) { case  Gravity .  TOP : default : break ; case  Gravity .  CENTER_ VERTICAL : case  Gravity .  CENTER : gravity Margin = ( line Height - child Height - lp . top Margin - lp . bottom Margin ) / _ NUM ; break ; case  Gravity .  BOTTOM : gravity Margin = line Height - child Height - lp . top Margin - lp . bottom Margin ; break ; } } child . layout ( left + lp . left Margin , top + lp . top Margin + gravity Margin + vertical Gravity Margin , left + child Width + lp . left Margin , top + child Height + lp . top Margin + gravity Margin + vertical Gravity Margin ) ; left += child Width + lp . left Margin + lp . right Margin ; } top += line Height ; } }
private void check Or Reallocate Buffer ( int length ) throws  Out Of Block Buffer Memory Exception { if ( size + length <= capacity ) { return ; } if ( exposed Slices ) { throw new  Out Of Block Buffer Memory Exception ( ) ; } capacity = ( size + length ) * _ NUM ; byte [ ] old Buffer = buffer ; buffer = new byte [ capacity ] ; if ( size > _ NUM ) {  System . arraycopy ( old Buffer , _ NUM , buffer , _ NUM , size ) ; } }
static <  K extends  Comparable <  K > ,  V >  Small Sorted Map <  K ,  V > new Instance For Test ( int array Size ) { return new  Small Sorted Map <  K ,  V > ( array Size ) ; }
@  Override public boolean connection Allowed (  String event Name ) { if ( ! event Name . equals ( _ STR ) && ! event Name . equals ( _ STR ) && ! event Name . equals ( _ STR ) && ! event Name . equals ( _ STR ) ) { return _ BOOL ; } if ( m_listenee != null ) { return _ BOOL ; } return _ BOOL ; }
protected  String read Word (  Reader r ) throws  IOException {  String Buffer buf = new  String Buffer ( ) ; char c = skip All Whitespace ( r ) ; while ( c != ( char ) - _ NUM && !  Character . is Whitespace ( c ) ) { buf . append ( c ) ; c = ( char ) r . read ( ) ; } if ( c == ( char ) - _ NUM ) { set Done ( _ BOOL ) ; } return buf . to String ( ) ; }
public  Map <  String ,  String > parse ( final  String str , char separator ) { if ( str == null ) { return new  Hash Map <  String ,  String > ( ) ; } return parse ( str . to Char Array ( ) , separator ) ; }
private  Resource Path managed Id (  String resource Id ) { return resource Id != null ? managed Object Path . child ( resource Id ) : managed Object Path ; }
private long acquire Read ( boolean interruptible , long deadline ) {  WNode node = null , p ; for ( int spins = - _ NUM ; ; ) {  WNode h ; if ( ( h = whead ) == ( p = wtail ) ) { for ( long m , s , ns ; ; ) { if ( ( m = ( s = state ) &  ABITS ) <  RFULL ?  U . compare And Swap Long ( this ,  STATE , s , ns = s +  RUNIT ) : ( m <  WBIT && ( ns = try Inc Reader Overflow ( s ) ) != _ NUM ) ) return ns ; else if ( m >=  WBIT ) { if ( spins > _ NUM ) { if (  Lock Support . next Secondary Seed ( ) >= _ NUM ) -- spins ; } else { if ( spins == _ NUM ) {  WNode nh = whead , np = wtail ; if ( ( nh == h && np == p ) || ( h = nh ) != ( p = np ) ) break ; } spins =  SPINS ; } } } } if ( p == null ) {  WNode hd = new  WNode (  WMODE , null ) ; if (  U . compare And Swap Object ( this ,  WHEAD , null , hd ) ) wtail = hd ; } else if ( node == null ) node = new  WNode (  RMODE , p ) ; else if ( h == p || p . mode !=  RMODE ) { if ( node . prev != p ) node . prev = p ; else if (  U . compare And Swap Object ( this ,  WTAIL , p , node ) ) { p . next = node ; break ; } } else if ( !  U . compare And Swap Object ( p ,  WCOWAIT , node . cowait = p . cowait , node ) ) node . cowait = null ; else { for ( ; ; ) {  WNode pp , c ;  Thread w ; if ( ( h = whead ) != null && ( c = h . cowait ) != null &&  U . compare And Swap Object ( h ,  WCOWAIT , c , c . cowait ) && ( w = c . thread ) != null )  U . unpark ( w ) ; if ( h == ( pp = p . prev ) || h == p || pp == null ) { long m , s , ns ; do { if ( ( m = ( s = state ) &  ABITS ) <  RFULL ?  U . compare And Swap Long ( this ,  STATE , s , ns = s +  RUNIT ) : ( m <  WBIT && ( ns = try Inc Reader Overflow ( s ) ) != _ NUM ) ) return ns ; } while ( m <  WBIT ) ; } if ( whead == h && p . prev == pp ) { long time ; if ( pp == null || h == p || p . status > _ NUM ) { node = null ; break ; } if ( deadline == _ NUM ) time = _ NUM ; else if ( ( time = deadline -  System . nano Time ( ) ) <= _ NUM ) return cancel Waiter ( node , p , _ BOOL ) ;  Thread wt =  Thread . current Thread ( ) ;  U . put Object ( wt ,  PARKBLOCKER , this ) ; node . thread = wt ; if ( ( h != pp || ( state &  ABITS ) ==  WBIT ) && whead == h && p . prev == pp )  U . park ( _ BOOL , time ) ; node . thread = null ;  U . put Object ( wt ,  PARKBLOCKER , null ) ; if ( interruptible &&  Thread . interrupted ( ) ) return cancel Waiter ( node , p , _ BOOL ) ; } } } } for ( int spins = - _ NUM ; ; ) {  WNode h , np , pp ; int ps ; if ( ( h = whead ) == p ) { if ( spins < _ NUM ) spins =  HEAD_ SPINS ; else if ( spins <  MAX_ HEAD_ SPINS ) spins <<= _ NUM ; for ( int k = spins ; ; ) { long m , s , ns ; if ( ( m = ( s = state ) &  ABITS ) <  RFULL ?  U . compare And Swap Long ( this ,  STATE , s , ns = s +  RUNIT ) : ( m <  WBIT && ( ns = try Inc Reader Overflow ( s ) ) != _ NUM ) ) {  WNode c ;  Thread w ; whead = node ; node . prev = null ; while ( ( c = node . cowait ) != null ) { if (  U . compare And Swap Object ( node ,  WCOWAIT , c , c . cowait ) && ( w = c . thread ) != null )  U . unpark ( w ) ; } return ns ; } else if ( m >=  WBIT &&  Lock Support . next Secondary Seed ( ) >= _ NUM && -- k <= _ NUM ) break ; } } else if ( h != null ) {  WNode c ;  Thread w ; while ( ( c = h . cowait ) != null ) { if (  U . compare And Swap Object ( h ,  WCOWAIT , c , c . cowait ) && ( w = c . thread ) != null )  U . unpark ( w ) ; } } if ( whead == h ) { if ( ( np = node . prev ) != p ) { if ( np != null ) ( p = np ) . next = node ; } else if ( ( ps = p . status ) == _ NUM )  U . compare And Swap Int ( p ,  WSTATUS , _ NUM ,  WAITING ) ; else if ( ps ==  CANCELLED ) { if ( ( pp = p . prev ) != null ) { node . prev = pp ; pp . next = node ; } } else { long time ; if ( deadline == _ NUM ) time = _ NUM ; else if ( ( time = deadline -  System . nano Time ( ) ) <= _ NUM ) return cancel Waiter ( node , node , _ BOOL ) ;  Thread wt =  Thread . current Thread ( ) ;  U . put Object ( wt ,  PARKBLOCKER , this ) ; node . thread = wt ; if ( p . status < _ NUM && ( p != h || ( state &  ABITS ) ==  WBIT ) && whead == h && node . prev == p )  U . park ( _ BOOL , time ) ; node . thread = null ;  U . put Object ( wt ,  PARKBLOCKER , null ) ; if ( interruptible &&  Thread . interrupted ( ) ) return cancel Waiter ( node , node , _ BOOL ) ; } } } }
@  Override public void init ( ) { }
private  String xml Escape (  String string ) { if ( string == null ) { return null ; }  String Builder sb = new  String Builder ( ) ; for ( int i = _ NUM ; i < string . length ( ) ; i ++ ) { char ch = string . char At ( i ) ; switch ( ch ) { case _ STR : sb . append ( _ STR ) ; break ; case _ STR : sb . append ( _ STR ) ; break ; case _ STR : sb . append ( _ STR ) ; break ; default : if ( ch < _ NUM || ch > _ NUM ) { sb . append ( _ STR + ( int ) ch + _ STR ) ; } else { sb . append ( ch ) ; } } } return sb . to String ( ) ; }
public static  File create Container Schema File (  String schema Prefix File Name ,  String container Schema File Path ) throws  Remote Exception {  File default Schema File = null ; try {  String schema File Path =  Constants .  Container .  CONTAINER_ CONFIG_ DIRECTORY + _ STR +  Constants .  Schemas .  SCHEMAS_ FOLDER + _ STR +  Constants .  Schemas .  DEFAULT_ SCHEMA +  Constants .  Schemas .  CONTAINER_ SCHEMA_ FILE_ SUFFIX ;  Input Stream schema Input Stream =  Resource Loader . get Resource Stream ( schema File Path ) ;  String folder Owner Path = container Schema File Path . substring ( _ NUM , container Schema File Path . last Index Of (  File . separator ) ) ;  File folder Owner Instance = new  File ( folder Owner Path ) ; if ( ! folder Owner Instance . exists ( ) ) { folder Owner Instance . mkdirs ( ) ; } default Schema File = new  File ( container Schema File Path ) ;  File Output Stream fos = new  File Output Stream ( default Schema File ) ; int read = _ NUM ; while ( read > _ NUM ) { byte [ ] read Bytes Array = new byte [ schema Input Stream . available ( ) ] ; read = schema Input Stream . read ( read Bytes Array ) ; fos . write ( read Bytes Array ) ; } fos . flush ( ) ; fos . close ( ) ; schema Input Stream . close ( ) ;  Replace In File Utils file = new  Replace In File Utils ( container Schema File Path ) ; file . replace In File ( _ STR +  Constants .  Schemas .  DEFAULT_ SCHEMA + _ STR , _ STR + schema Prefix File Name + _ STR ) ; file . replace In File ( _ STR +  Constants .  Schemas .  DEFAULT_ SCHEMA + _ STR , _ STR + schema Prefix File Name + _ STR ) ; file . close ( ) ; } catch (  Exception ex ) { throw new  Remote Exception ( _ STR , ex ) ; } return default Schema File ; }
public boolean is Aborted ( ) { return  STATE_ Aborted . equals ( m_state ) ; }
public void append ( int key ,  E value ) { if ( m Size != _ NUM && key <= m Keys [ m Size - _ NUM ] ) { put ( key , value ) ; return ; } if ( m Garbage && m Size >= m Keys . length ) { gc ( ) ; } int pos = m Size ; if ( pos >= m Keys . length ) { int n =  Array Utils . ideal Int Array Size ( pos + _ NUM ) ; int [ ] nkeys = new int [ n ] ;  Object [ ] nvalues = new  Object [ n ] ;  System . arraycopy ( m Keys , _ NUM , nkeys , _ NUM , m Keys . length ) ;  System . arraycopy ( m Values , _ NUM , nvalues , _ NUM , m Values . length ) ; m Keys = nkeys ; m Values = nvalues ; } m Keys [ pos ] = key ; m Values [ pos ] = value ; m Size = pos + _ NUM ; }
public void notify Consist Throttle Found (  Dcc Throttle t ) { this . consist Throttle = t ; for ( int i = _ NUM ; i < listeners . size ( ) ; i ++ ) {  Address Listener l = listeners . get ( i ) ; if ( log . is Debug Enabled ( ) ) { log . debug ( _ STR + l . get Class ( ) ) ; } l . notify Consist Address Throttle Found ( t ) ; } }
private void close Connection (  Connection connection ) throws  SQLException { if ( connection != null ) { try { connection . close ( ) ; } catch (  SQLException e ) { throw new  SQLException ( _ STR , e ) ; } } }
public  Version remove Qualifier (  String qualifier ) {  List <  String > new Qualifiers = new  Array List < > ( this . qualifiers ) ; new Qualifiers . remove ( qualifier ) ; return new  Version ( major , minor , patch , new Qualifiers . to Array ( new  String [ new Qualifiers . size ( ) ] ) ) ; }
public int load Signed16 ( int addr ) { return ( load Signed8 ( addr ) << _ NUM ) | load Unsigned8 ( addr + _ NUM ) ; }
public static  String array To Hex String ( byte [ ] array , int offset , int limit ) {  String ret Val ; if ( array != null ) {  String Buffer hex String = new  String Buffer ( array . length ) ; int hex Val ; char hex Char ; int length =  Math . min ( limit , array . length ) ; for ( int i = offset ; i < length ; i ++ ) { hex Val = ( array [ i ] & _ NUM ) > > _ NUM ; hex Char = ( char ) ( ( hex Val > _ NUM ) ? ( _ STR + ( hex Val - _ NUM ) ) : ( _ STR + hex Val ) ) ; hex String . append ( hex Char ) ; hex Val = array [ i ] & _ NUM ; hex Char = ( char ) ( ( hex Val > _ NUM ) ? ( _ STR + ( hex Val - _ NUM ) ) : ( _ STR + hex Val ) ) ; hex String . append ( hex Char ) ; } ret Val = hex String . to String ( ) ; } else { ret Val = _ STR ; } return ret Val ; }
public static void register Baggage Handler (  Baggage Handler handler ) { handlers . add ( handler ) ; }
protected  Rectangle calculate BBox (  List <  Point > points ) { double min X =  Double .  MAX_ VALUE ; double min Y =  Double .  MAX_ VALUE ; double max X = -  Double .  MAX_ VALUE ; double max Y = -  Double .  MAX_ VALUE ; for (  Point p : points ) { min X =  Math . min ( p . get X ( ) , min X ) ; min Y =  Math . min ( p . get Y ( ) , min Y ) ; max X =  Math . max ( p . get X ( ) , max X ) ; max Y =  Math . max ( p . get Y ( ) , max Y ) ; } return new  Rectangle ( ( float ) min X , ( float ) min Y , ( float ) ( max X - min X ) , ( float ) ( max Y - min Y ) ) ; }
public static void assert Array Equals (  String message ,  Object [ ] expected ,  Object [ ] actual ) { if ( expected == null ) { assert Equals ( (  Object ) null , actual ) ; return ; } if ( actual == null ) { throw new  Assertion Failed Error ( message + _ STR +  Arrays . to String ( expected ) + _ STR ) ; } assert Equals ( message + _ STR , expected . length , actual . length ) ; for ( int i = _ NUM ; i < expected . length ; i ++ ) { assert Equals ( message , expected [ i ] , actual [ i ] ) ; } }
protected void complete Current Text Node ( ) { if ( strip Whitespace Text ) { boolean whitespace = _ BOOL ; for ( int i = _ NUM , size = text Buffer . length ( ) ; i < size ; i ++ ) { if ( !  Character . is Whitespace ( text Buffer . char At ( i ) ) ) { whitespace = _ BOOL ; break ; } } if ( ! whitespace ) { current Element . add Text ( text Buffer . to String ( ) ) ; } } else { current Element . add Text ( text Buffer . to String ( ) ) ; } text Buffer . set Length ( _ NUM ) ; text In Text Buffer = _ BOOL ; }
void add Annotation ( @  Non Null  Annotation annotation ) { annotations . put ( annotation . annotation Type ( ) , annotation ) ; }
@  Deprecated public  Ad Blocker Advise Dialog (  Context context ,  String title ,  String text ) { this . library Preferences = new  Library Preferences ( context ) ; this . context = context ; this . title = title ; this . text = text ; this . only Once = _ BOOL ; }
public void remove Tick Mark Section ( final  Section  SECTION ) { if ( null ==  SECTION ) return ; tick Mark Sections . remove (  SECTION ) ;  Collections . sort ( tick Mark Sections , new  Section Comparator ( ) ) ; fire Update Event (  REDRAW_ EVENT ) ; }
public static double raw Probability ( double x , double lambda ) { if ( lambda == _ NUM ) { return ( ( x == _ NUM ) ? _ NUM : _ NUM ) ; } if (  Double . is Infinite ( lambda ) || x < _ NUM ) { return _ NUM ; } if ( x <= lambda *  Double .  MIN_ NORMAL ) { return  Math . exp ( - lambda ) ; } if ( lambda < x *  Double .  MIN_ NORMAL ) { double r = - lambda + x *  Math . log ( lambda ) -  Gamma Distribution . log Gamma ( x + _ NUM ) ; return  Math . exp ( r ) ; } final double f =  Math Util .  TWOPI * x ; final double y = - stirling Error ( x ) - deviance Term ( x , lambda ) ; return  Math . exp ( y ) /  Math . sqrt ( f ) ; }
public void display Message And Usage Reference ( final  Print Stream print Stream , final  Localizable Message message ) { print Wrapped Text ( print Stream , message ) ; print Stream . println ( ) ; print Wrapped Text ( print Stream , get Help Usage Reference ( ) ) ; }
public  Char Buffer replace ( int start , int end ,  String string ) { int length = length ( ) ; if ( start < _ NUM || end < start || length < start ) throw new  String Index Out Of Bounds Exception ( ) ; int len = string . length ( ) ; ensure Capacity ( len + length - ( end - start ) ) ; char [ ] buffer = buffer ( ) ; if ( len < end - start ) { int tail = length - end ; for ( int i = _ NUM ; i < tail ; i ++ ) { buffer [ start + len + i ] = buffer [ end + i ] ; } } else { int tail = length - end ; for ( int i = tail - _ NUM ; i >= _ NUM ; i -- ) { buffer [ end + i ] = buffer [ start + len + i ] ; } } string . get Chars ( _ NUM , len , buffer , start ) ; length ( length + len - ( end - start ) ) ; return this ; }
public void add Listener (  Air Map Traffic Listener listener ) { if ( listeners . is Empty ( ) ) { listeners . add ( listener ) ; connect ( ) ; } else { listeners . add ( listener ) ; } }
public void add Syntax Actions (  Keymap map ,  String prefix ) {  Pattern splitter =  CONFIG . get Value Separator ( prefix ) ;  Configuration actions Conf =  CONFIG . sub Config ( prefix , _ STR ) ; for (  String action Name : actions Conf . string Property Names ( ) ) {  String [ ] values = splitter . split ( actions Conf . get Property ( action Name ) ) ;  String action Class = values [ _ NUM ] ;  Syntax Action action = editor Actions . get ( action Class ) ; if ( action == null ) { action = create Action ( action Class ) ; action . config (  CONFIG , prefix , action Name ) ; }  String key Stroke String = values [ _ NUM ] ;  Key Stroke ks =  Key Stroke . get Key Stroke ( key Stroke String ) ; if ( ks == null ) { throw new  Illegal Argument Exception ( _ STR + key Stroke String ) ; }  Text Action ta = action . get Action ( action Name ) ; if ( ta == null ) { throw new  Illegal Argument Exception ( _ STR + action Name ) ; } map . add Action For Key Stroke ( ks , ta ) ; } }
public static <  T >  String encode To Base64 (  Coder <  T > coder ,  T value ) throws  Coder Exception { byte [ ] raw Value = encode To Byte Array ( coder , value ) ; return  Base64 . encode Base64 URLSafe String ( raw Value ) ; }
public static void remove All Case Ignore (  Set master ,  Set deleting Set ) { if ( ( deleting Set != null ) && ! deleting Set . is Empty ( ) ) {  Set lc Set = lower Case ( deleting Set ) ; for (  Iterator iter = master . iterator ( ) ; iter . has Next ( ) ; ) {  String e = (  String ) iter . next ( ) ; if ( lc Set . contains ( e . to Lower Case ( ) ) ) { iter . remove ( ) ; } } } }
public  String subtract (  Object ... values ) { double result =  Function Handler . get Double ( values [ _ NUM ] ) ; for ( int i = _ NUM ; i < values . length ; i ++ ) { result -=  Function Handler . get Double ( values [ i ] ) ; } return  Double . to String ( result ) ; }
public  DBInstance Info retrieve DBInfo (  String db Group Name ,  String host Name ) {  Connection conn = null ; try { conn = create Connection ( _ BOOL ) ; return retrieve DBInfo ( conn , db Group Name , host Name ) ; } catch (  Exception ex ) { logger . log (  Level .  SEVERE , _ STR , ex ) ; } finally {  DBUtils . close ( conn ) ; } return null ; }
public static void normalize ( float [ ] input ) { double norm Sq = _ NUM ; for ( int i = _ NUM ; i < input . length ; ++ i ) { norm Sq += input [ i ] * input [ i ] ; } float norm = ( float )  Math . sqrt ( norm Sq ) ; for ( int i = _ NUM ; i < input . length ; ++ i ) { input [ i ] = input [ i ] / norm ; } }
public int compare (  T a ,  T b ) {  Object o1 = a . get Value At ( _active Column ) ;  Object o2 = b . get Value At ( _active Column ) ; return  Abstract Table Mediator . compare ( o1 , o2 ) * _ascending ; }
public void add Apply Action Listener (  Action Listener al ) { apply Button . add Action Listener ( al ) ; }
public  Null Info Registry add (  Null Info Registry other ) { if ( ( other . tag Bits &  NULL_ FLAG_ MASK ) == _ NUM ) { return this ; } this . tag Bits |=  NULL_ FLAG_ MASK ; this . null Bit1 |= other . null Bit1 ; this . null Bit2 |= other . null Bit2 ; this . null Bit3 |= other . null Bit3 ; this . null Bit4 |= other . null Bit4 ; if ( other . extra != null ) { if ( this . extra == null ) { this . extra = new long [ extra Length ] [ ] ; for ( int i = _ NUM , length = other . extra [ _ NUM ] . length ; i < extra Length ; i ++ ) {  System . arraycopy ( other . extra [ i ] , _ NUM , ( this . extra [ i ] = new long [ length ] ) , _ NUM , length ) ; } } else { int length = this . extra [ _ NUM ] . length , other Length = other . extra [ _ NUM ] . length ; if ( other Length > length ) { for ( int i = _ NUM ; i < extra Length ; i ++ ) {  System . arraycopy ( this . extra [ i ] , _ NUM , ( this . extra [ i ] = new long [ other Length ] ) , _ NUM , length ) ;  System . arraycopy ( other . extra [ i ] , length , this . extra [ i ] , length , other Length - length ) ; } } else if ( other Length < length ) { length = other Length ; } for ( int i = _ NUM ; i < extra Length ; i ++ ) { for ( int j = _ NUM ; j < length ; j ++ ) { this . extra [ i ] [ j ] |= other . extra [ i ] [ j ] ; } } } } return this ; }
protected static  String literal Bits String (  Cst Literal Bits value ) {  String Buffer sb = new  String Buffer ( _ NUM ) ; sb . append ( _ STR ) ; if ( value instanceof  Cst Known Null ) { sb . append ( _ STR ) ; } else { sb . append ( value . type Name ( ) ) ; sb . append ( _ STR ) ; sb . append ( value . to Human ( ) ) ; } return sb . to String ( ) ; }
public static void copy Memory Field By Field ( long src Address ,  Object dest ) {  Class clazz = dest . get Class ( ) ; while ( clazz !=  Object . class ) { for (  Field f : clazz . get Declared Fields ( ) ) { if ( ( f . get Modifiers ( ) &  Modifier .  STATIC ) == _ NUM ) { final  Class type = f . get Type ( ) ;  Preconditions . check Argument ( type . is Primitive ( ) , _ STR ) ; final long offset = unsafe . object Field Offset ( f ) ; final long src = src Address + offset ; if ( type == int . class ) { unsafe . put Int ( dest , offset , unsafe . get Int ( src ) ) ; } else if ( type == long . class ) { unsafe . put Long ( dest , offset , unsafe . get Long ( src ) ) ; } else { throw new  Illegal Argument Exception ( _ STR + type ) ; } } } clazz = clazz . get Superclass ( ) ; } }
public final  V remove ( int index ) { if (  GWT . is Script ( ) ) {  V ret = js Array . get ( index ) ; js Array . remove ( index ) ; return ret ; } else { return java Array . remove ( index ) ; } }
@  Override public void action Performed (  Action Event event ) {  String command = event . get Action Command ( ) ; if ( command . equals ( _ STR ) ) { validate Angle Offset ( ) ; } else if ( command . equals ( _ STR ) ) { validate Tick Unit ( ) ; } }
public static void clone Server Instance (  SSOToken sso Token ,  String server Name ,  String clone Name ,  String clone Id ) throws  SMSException ,  SSOException ,  Configuration Exception {  URL url = null ; try { url = new  URL ( clone Name ) ; } catch (  Malformed URLException ex ) {  String [ ] param = { clone Name } ; throw new  Configuration Exception ( _ STR , param ) ; }  Service Config cfg = get Server Config ( sso Token , server Name ) ; if ( cfg != null ) {  Map map = cfg . get Attributes ( ) ;  Service Config sc = get Root Server Config With Retry ( sso Token ) ; if ( sc != null ) {  Set set ID = new  Hash Set ( _ NUM ) ; set ID . add ( clone Id ) ; map . put (  ATTR_ SERVER_ ID , set ID ) ; set Protocol Host Port URI ( map , clone Name ) ; sc . add Sub Config ( clone Name ,  SUBSCHEMA_ SERVER , _ NUM , map ) ; update Organization Alias ( sso Token , clone Name , _ BOOL ) ; } } }
public static <  T extends  Storable >  T unserialize (  Class <  T > clazz ,  Data data ) { try {  T storable Obj = clazz . new Instance ( ) ; storable Obj . load ( data ) ; return storable Obj ; } catch (  Exception e ) { throw new  Data Exception ( e ) ; } }
public  Generic Sip Rtp Session create Rtp Session (  Contact Id contact ,  String feature Tag ,  String encoding ) { if ( s Logger . is Activated ( ) ) { s Logger . info ( _ STR + contact ) ; } return new  Originating Sip Rtp Session ( this , contact , feature Tag , m Rcs Settings ,  System . current Time Millis ( ) , m Contact Manager , encoding ) ; }
public static void draw Circled Text (  Graphics2 D g ,  Font font ,  String text , int x , int y ) {  Graphics2 D g2 = (  Graphics2 D ) g . create ( ) ; g2 . set Font ( font ) ;  Font Metrics fm = g2 . get Font Metrics ( ) ; int padding = _ NUM ;  Rectangle2 D bounds = fm . get String Bounds ( text , g2 ) ; double th = bounds . get Height ( ) ; double tw = bounds . get Width ( ) ; float radius = ( float ) (  Math . max ( th , tw ) / _ NUM + padding ) ;  Ellipse2 D .  Float circle = new  Ellipse2 D .  Float ( x - radius , y - radius , _ NUM * radius + _ NUM , _ NUM * radius + _ NUM ) ; g2 . fill ( circle ) ; g2 . set Color (  Color .  BLACK ) ; g2 . draw String ( text , ( int ) ( x - tw / _ NUM ) , ( y + fm . get Ascent ( ) / _ NUM ) ) ; if (  DEBUG ) { g2 . set Color (  Color .  RED ) ; g2 . draw Line ( x - _ NUM , y , x + _ NUM , y ) ; g2 . draw Line ( x , y - _ NUM , x , y + _ NUM ) ; } g2 . dispose ( ) ; }
public void component Hidden (  Component Event e ) { if ( logger . is Loggable (  Level .  FINE ) ) { logger . fine ( _ STR + layer . get Name ( ) + _ STR ) ; }  Component comp = e . get Component ( ) ; if ( comp == layer ) { if ( is Layer On ( ) != _ BOOL ) { set Layer On ( _ BOOL ) ; if ( logger . is Loggable (  Level .  FINE ) ) { logger . fine ( _ STR + layer . get Name ( ) + _ STR ) ; } } } else if ( comp == layer . get Palette ( ) ) { set Palette On ( _ BOOL ) ; } else if ( comp == null ) { if ( logger . is Loggable (  Level .  FINE ) ) { logger . fine ( _ STR + layer . get Name ( ) + _ STR ) ; } } }
public static  String byte Array To Hex String ( byte [ ] block ) {  String Buffer buf = new  String Buffer ( ) ; int len = block . length ; for ( int i = _ NUM ; i < len ; i ++ ) { byte2hex ( block [ i ] , buf ) ; if ( ( i < len - _ NUM ) &  WITH_ BYTE_ SEPARATOR ) { buf . append (  BYTE_ SEPARATOR ) ; } } return buf . to String ( ) ; }
private boolean is Label Type Exists In Storage (  Abstract Storage Label Type < ? > label Type ,  Set <  Abstract Storage Label < ? > > labels In Storages ) { for (  Abstract Storage Label < ? > label : labels In Storages ) { if (  Object Utils . equals ( label . get Storage Label Type ( ) , label Type ) ) { return _ BOOL ; } } return _ BOOL ; }
private void write Deflated ( byte [ ] b , int offset , int length ) throws  IOException { if ( length > _ NUM && ! def . finished ( ) ) { entry . bytes Read += length ; if ( length <=  DEFLATER_ BLOCK_ SIZE ) { def . set Input ( b , offset , length ) ; deflate Until Input Is Needed ( ) ; } else { final int fullblocks = length /  DEFLATER_ BLOCK_ SIZE ; for ( int i = _ NUM ; i < fullblocks ; i ++ ) { def . set Input ( b , offset + i *  DEFLATER_ BLOCK_ SIZE ,  DEFLATER_ BLOCK_ SIZE ) ; deflate Until Input Is Needed ( ) ; } final int done = fullblocks *  DEFLATER_ BLOCK_ SIZE ; if ( done < length ) { def . set Input ( b , offset + done , length - done ) ; deflate Until Input Is Needed ( ) ; } } } }
public float distance To Center ( float x , float y ) {  Point F c = get Center Offsets ( ) ; float dist ; float x Dist ; float y Dist ; if ( x > c . x ) { x Dist = x - c . x ; } else { x Dist = c . x - x ; } if ( y > c . y ) { y Dist = y - c . y ; } else { y Dist = c . y - y ; } dist = ( float )  Math . sqrt (  Math . pow ( x Dist , _ NUM ) +  Math . pow ( y Dist , _ NUM ) ) ; return dist ; }
@  Override public int clamp View Position Horizontal (  View child , int left , int dx ) { int left Bound = _ NUM ; int right Bound = _ NUM ; switch ( dragger View . get Drag Position ( ) ) { case  RIGHT : if ( left > _ NUM ) { left Bound = dragger View . get Padding Left ( ) ; right Bound = ( int ) dragger Listener . drag Horizontal Drag Range ( ) ; } break ; case  LEFT : if ( left < _ NUM ) { left Bound = ( int ) - dragger Listener . drag Horizontal Drag Range ( ) ; right Bound = dragger View . get Padding Left ( ) ; } break ; default : break ; } return  Math . min (  Math . max ( left , left Bound ) , right Bound ) ; }
public  Request Logging Filter Wrapper (  Http Servlet Request request ) throws  IOException { super ( request ) ; if (  LOGGER . is Debug Enabled ( ) ) {  Input Stream input Stream = null ; try { input Stream = request . get Input Stream ( ) ; if ( input Stream != null ) { payload =  IOUtils . to Byte Array ( request . get Input Stream ( ) ) ; } } finally { if ( input Stream != null ) { try { input Stream . close ( ) ; } catch (  IOException iox ) {  LOGGER . warn ( _ STR , iox ) ; } } } } }
private static double expm1 ( double x , double hi Prec Out [ ] ) { if (  Double . is Na N ( x ) || x == _ NUM ) { return x ; } if ( x <= - _ NUM || x >= _ NUM ) { double hi Prec [ ] = new double [ _ NUM ] ; exp ( x , _ NUM , hi Prec ) ; if ( x > _ NUM ) { return - _ NUM + hi Prec [ _ NUM ] + hi Prec [ _ NUM ] ; } else { final double ra = - _ NUM + hi Prec [ _ NUM ] ; double rb = - ( ra + _ NUM - hi Prec [ _ NUM ] ) ; rb += hi Prec [ _ NUM ] ; return ra + rb ; } } double base A ; double base B ; double epsilon ; boolean negative = _ BOOL ; if ( x < _ NUM ) { x = - x ; negative = _ BOOL ; } { int int Frac = ( int ) ( x * _ NUM ) ; double temp A =  Exp Frac Table .  EXP_ FRAC_ TABLE_ A [ int Frac ] - _ NUM ; double temp B =  Exp Frac Table .  EXP_ FRAC_ TABLE_ B [ int Frac ] ; double temp = temp A + temp B ; temp B = - ( temp - temp A - temp B ) ; temp A = temp ; temp = temp A *  HEX_40000000 ; base A = temp A + temp - temp ; base B = temp B + ( temp A - base A ) ; epsilon = x - int Frac / _ NUM ; } double zb = _ NUM ; zb = zb * epsilon + _ NUM ; zb = zb * epsilon + _ NUM ; zb = zb * epsilon + _ NUM ; zb *= epsilon ; zb *= epsilon ; double za = epsilon ; double temp = za + zb ; zb = - ( temp - za - zb ) ; za = temp ; temp = za *  HEX_40000000 ; temp = za + temp - temp ; zb += za - temp ; za = temp ; double ya = za * base A ; temp = ya + za * base B ; double yb = - ( temp - ya - za * base B ) ; ya = temp ; temp = ya + zb * base A ; yb += - ( temp - ya - zb * base A ) ; ya = temp ; temp = ya + zb * base B ; yb += - ( temp - ya - zb * base B ) ; ya = temp ; temp = ya + base A ; yb += - ( temp - base A - ya ) ; ya = temp ; temp = ya + za ; yb += - ( temp - ya - za ) ; ya = temp ; temp = ya + base B ; yb += - ( temp - ya - base B ) ; ya = temp ; temp = ya + zb ; yb += - ( temp - ya - zb ) ; ya = temp ; if ( negative ) { double denom = _ NUM + ya ; double denomr = _ NUM / denom ; double denomb = - ( denom - _ NUM - ya ) + yb ; double ratio = ya * denomr ; temp = ratio *  HEX_40000000 ; final double ra = ratio + temp - temp ; double rb = ratio - ra ; temp = denom *  HEX_40000000 ; za = denom + temp - temp ; zb = denom - za ; rb += ( ya - za * ra - za * rb - zb * ra - zb * rb ) * denomr ; rb += yb * denomr ; rb += - ya * denomb * denomr * denomr ; ya = - ra ; yb = - rb ; } if ( hi Prec Out != null ) { hi Prec Out [ _ NUM ] = ya ; hi Prec Out [ _ NUM ] = yb ; } return ya + yb ; }
public void handle Expansion Recursion ( final  Http Server Request request ) { remove Zip Parameter ( request ) ; handle Expansion Request ( request ,  Recursive Handler Factory .  Recursive Handler Types .  EXPANSION ) ; }
private void write Entry (  Prepared Statement stmt ,  Search Index Entry entry ) throws  SQLException { stmt . set String ( _ NUM , entry . get Search Term ( ) ) ; stmt . set String ( _ NUM ,  String . value Of ( entry . get Entity Type ( ) ) ) ; stmt . set String ( _ NUM , entry . get Entity Name ( ) ) ; stmt . set Int ( _ NUM , entry . get Search Score ( ) ) ; stmt . add Batch ( ) ; }
public static long read UINT64 (  Input Stream stream ) throws  IOException { long result = _ NUM ; for ( int i = _ NUM ; i <= _ NUM ; i += _ NUM ) { result |= ( long ) stream . read ( ) << i ; } return result ; }
private  Expression parse Evaluation (  Variable Expression variable ) throws  Parse Exception { expect (  Token .  EQUATION ) ; if ( token !=  Token .  STRING ) { throw new  Parse Exception ( _ STR , lexer . get Current Offset ( ) ) ; }  String s = lexer . get Token String ( ) ; next Token ( ) ; return new  Evaluation Expression ( variable , s . replace ( _ STR , _ STR ) ) ; }
private  CSVRecord (  List <  String > record ) { this . record =  Objects . require Non Null ( record ) ; }
private void schedule Send ( final int queue Size ) { if ( pending ) { return ; } if ( queue Size >= batch Size ) { enqueue Send ( ) ; return ; } if ( scheduled . compare And Set ( _ BOOL , _ BOOL ) ) { try { scheduler . schedule ( null , max Latency Ms ,  MILLISECONDS ) ; scheduler Queue Size . increment And Get ( ) ; } catch (  Rejected Execution Exception ignore ) { } } }
public static  String join ( boolean [ ] self ,  String separator ) {  String Builder buffer = new  String Builder ( ) ; boolean first = _ BOOL ; if ( separator == null ) separator = _ STR ; for ( boolean next : self ) { if ( first ) { first = _ BOOL ; } else { buffer . append ( separator ) ; } buffer . append ( next ) ; } return buffer . to String ( ) ; }
private <  T >  Binding Amp <  T > find Binding (  Key <  T > key ) {  Binding Set <  T > set = (  Binding Set ) _binding Set Map . get ( key . raw Class ( ) ) ; if ( set != null ) {  Binding Amp <  T > binding = set . find ( key ) ; if ( binding != null ) { return binding ; } } return null ; }
private void init Compute Program ( ) { gl Use Program ( compute Program ) ;  Int Buffer work Group Size =  Buffer Utils . create Int Buffer ( _ NUM ) ; gl Get Programiv ( compute Program ,  GL_ COMPUTE_ WORK_ GROUP_ SIZE , work Group Size ) ; work Group Size X = work Group Size . get ( _ NUM ) ; work Group Size Y = work Group Size . get ( _ NUM ) ; time Uniform = gl Get Uniform Location ( compute Program , _ STR ) ; blend Factor Uniform = gl Get Uniform Location ( compute Program , _ STR ) ; bounce Count Uniform = gl Get Uniform Location ( compute Program , _ STR ) ; int boxes Resource Index = gl Get Program Resource Index ( compute Program ,  GL_ SHADER_ STORAGE_ BLOCK , _ STR ) ;  Int Buffer props =  Buffer Utils . create Int Buffer ( _ NUM ) ;  Int Buffer params =  Buffer Utils . create Int Buffer ( _ NUM ) ; props . put ( _ NUM ,  GL_ BUFFER_ BINDING ) ; gl Get Program Resourceiv ( compute Program ,  GL_ SHADER_ STORAGE_ BLOCK , boxes Resource Index , props , null , params ) ; boxes Ssbo Binding = params . get ( _ NUM ) ; int loc = gl Get Uniform Location ( compute Program , _ STR ) ; gl Get Uniformiv ( compute Program , loc , params ) ; framebuffer Image Binding = params . get ( _ NUM ) ; loc = gl Get Uniform Location ( compute Program , _ STR ) ; gl Get Uniformiv ( compute Program , loc , params ) ; world Position Image Binding = params . get ( _ NUM ) ; loc = gl Get Uniform Location ( compute Program , _ STR ) ; gl Get Uniformiv ( compute Program , loc , params ) ; world Normal Image Binding = params . get ( _ NUM ) ; gl Use Program ( _ NUM ) ; }
public boolean namespace Published To Mapgraph ( final  String namespace ) throws  Exception { assert Mapgraph Runtime Available ( ) ; final  String repository Url = get Sparql Endpoint Url For Namespace Or Default ( namespace ) ; final  Connect Options opts = new Connect Options ( repository Url ,  UUID . random UUID ( ) , null ) ;  Jetty Response Listener response = null ; { opts . set Accept Header ( _ STR ) ; opts . add Request Param (  MAPGRAPH ,  CHECK_ PUBLISHED ) ; opts . method = _ STR ; } try { check Response Code ( response = do Connect ( opts ) ) ; final  String response Body = response . get Response Body ( ) ; return response Body != null && response Body . contains ( _ STR ) ; } finally { if ( response != null ) response . abort ( ) ; } }
public void space Vertical (  Array List <  Integer > nodes ) { if ( m_b Needs Undo Action ) { add Undo Action ( new space Vertical Action ( nodes ) ) ; } int n Min Y = - _ NUM ; int n Max Y = - _ NUM ; for ( int i Node = _ NUM ; i Node < nodes . size ( ) ; i Node ++ ) { int n Y = get Position Y ( nodes . get ( i Node ) ) ; if ( n Y < n Min Y || i Node == _ NUM ) { n Min Y = n Y ; } if ( n Y > n Max Y || i Node == _ NUM ) { n Max Y = n Y ; } } for ( int i Node = _ NUM ; i Node < nodes . size ( ) ; i Node ++ ) { int n Node = nodes . get ( i Node ) ; m_n Position Y . set ( n Node , ( int ) ( n Min Y + i Node * ( n Max Y - n Min Y ) / ( nodes . size ( ) - _ NUM ) ) ) ; } }
private void append Text (  Comment Tokenizer tokenizer ,  String Builder builder ) { while ( tokenizer . has Next ( ) && tokenizer . peek Next ( ) . kind ==  Token Kind .  TEXT ) {  String text = tokenizer . poll Next ( ) . text ; if ( builder . length ( ) > _ NUM && builder . char At ( builder . length ( ) - _ NUM ) != _ STR && ! text . equals (  NEW_ LINE ) ) { builder . append ( _ STR ) ; } builder . append ( text ) ; } }
@  Override protected void on Create ( final  Bundle saved Instance State ) { super . on Create ( saved Instance State ) ; set Content View (  R . layout . activity_intro ) ; bind Views ( ) ; initialise Navigation Buttons ( ) ; button Animator Factory = generate Button Animator Factory ( ) ; pages . add All ( generate Pages ( saved Instance State ) ) ; view Pager . add On Page Change Listener ( page Change Listener Delegate ) ; initialise View Pager ( saved Instance State ) ; progress Indicator = new  Dot Indicator ( this ) ; regenerate Progress Indicator ( ) ; }
public  Minute ( int minute ,  Hour hour ) {  Param Checks . null Not Permitted ( hour , _ STR ) ; this . minute = ( byte ) minute ; this . hour = ( byte ) hour . get Hour ( ) ; this . day = hour . get Day ( ) ; peg (  Calendar . get Instance ( ) ) ; }
public void open (  File file ,  Abstract File Loader loader ) {  Instances data ; try { log ( null , _ STR + file ) ; loader . set File ( file ) ; data = loader . get Data Set ( ) ;  MLUtils . fix Relation Name ( data ) ; log ( null , _ STR + file ) ; } catch (  Exception e ) { handle Exception ( null , _ STR + file + _ STR , e ) ;  JOption Pane . show Message Dialog ( this , _ STR + file + _ STR + e , _ STR ,  JOption Pane .  ERROR_ MESSAGE ) ; return ; } try { add Undo Point ( ) ;  MLUtils . prepare Data ( data ) ; m_ Current File = file ; notify Tabs Data Changed ( null , data ) ; m_ Recent Files Handler . add Recent Item ( new  Recent Files Handler With Commandline .  Setup ( file , loader ) ) ; } catch (  Exception e ) { handle Exception ( null , _ STR + file + _ STR , e ) ;  JOption Pane . show Message Dialog ( this , _ STR + file + _ STR + e , _ STR ,  JOption Pane .  ERROR_ MESSAGE ) ; return ; } update Menu ( ) ; }
public static boolean is Network Connected (  Context context ) { if ( context == null ) { return _ BOOL ; }  Connectivity Manager cm = (  Connectivity Manager ) context . get System Service (  Context .  CONNECTIVITY_ SERVICE ) ;  Network Info network Info = cm . get Active Network Info ( ) ; return ( network Info != null && network Info . is Connected ( ) ) ; }
public void save CSV (  File file ) throws  IOException {  File Writer writer = null ; try { writer = new  File Writer ( file ) ; writer . write ( to CSV ( ) ) ; } finally { if ( writer != null ) { writer . close ( ) ; } } }
public  Process ( final  URL url ) throws  IOException ,  XMLException { init Context ( ) ;  Reader in = new  Input Stream Reader (  Web Service Tools . open Stream From URL ( url ) , get Encoding ( null ) ) ; read Process ( in ) ; in . close ( ) ; }
public static  String extract Music IDFrom Media ID (  String media ID ) { int pos = media ID . index Of (  LEAF_ SEPARATOR ) ; if ( pos >= _ NUM ) { return media ID . substring ( pos + _ NUM ) ; } return null ; }
public static int [ ] values (  Integer [ ] array ) { int [ ] dest = new int [ array . length ] ; for ( int i = _ NUM ; i < array . length ; i ++ ) {  Integer v = array [ i ] ; if ( v != null ) { dest [ i ] = v . int Value ( ) ; } } return dest ; }
public void import Data ( final  File the File ) { try {  CSVParser the Parser = new  CSVParser ( new  File Input Stream ( the File ) , _ STR , _ STR , _ STR ) ;  String [ ] [ ] values = the Parser . get All Values ( ) ;  String [ ] line ; double [ ] vector ; int dimension = values [ _ NUM ] . length ; init ( dimension ) ; for ( int i = _ NUM ; i < values . length ; i ++ ) { line = values [ i ] ; vector = new double [ values [ _ NUM ] . length ] ; for ( int j = _ NUM ; j < line . length ; j ++ ) { vector [ j ] =  Double . parse Double ( line [ j ] ) ; } add Datapoint ( new  Data Point Colored ( vector ) ) ; } } catch (  IOException e ) { throw new  Runtime Exception ( e ) ; } projection Method . init ( ) ; projection Method . project ( ) ; fire Projector Data Changed ( ) ; }
boolean verify String (  String str ) { if ( ( str . length ( ) > max Length ) || ( str . length ( ) < min Length ) ) { return _ BOOL ; } int i = _ NUM ;  Enumeration e = format Constraints . elements ( ) ; if ( ! str . equals ( _ STR ) ) { char c = str . char At ( i ) ; for ( ; e . has More Elements ( ) ; ) {  Format Constraint constraint = (  Format Constraint ) e . next Element ( ) ; if ( constraint . count ==  Format Constraint .  COUNT_ EXACTLY_ ONE ) { if ( ! verify Char ( c , constraint . type ) ) { return _ BOOL ; } i ++ ; if ( i < str . length ( ) ) { c = str . char At ( i ) ; } else { break ; } } else { int char Num = _ NUM ; while ( ( i < str . length ( ) ) && ( char Num < constraint . count ) ) { if ( ! verify Char ( c , constraint . type ) ) { break ; } i ++ ; char Num ++ ; if ( i < str . length ( ) ) { c = str . char At ( i ) ; } else { break ; } } if ( i >= str . length ( ) ) { break ; } } } if ( i < str . length ( ) ) { return _ BOOL ; } } while ( e . has More Elements ( ) ) {  Format Constraint constraint = (  Format Constraint ) e . next Element ( ) ; if ( constraint . count ==  Format Constraint .  COUNT_ EXACTLY_ ONE ) { return _ BOOL ; } } return _ BOOL ; }
public void read Data (  Data Input din ) throws  IOException { int byte Count = din . read Unsigned Byte ( ) ; records = new  Record Request [ _ NUM ] ; for ( int offset = _ NUM ; offset + _ NUM < byte Count ; ) { int function = din . read Unsigned Byte ( ) ; int file = din . read Unsigned Short ( ) ; int record = din . read Unsigned Short ( ) ; int count = din . read Unsigned Short ( ) ; offset += _ NUM ; if ( function != _ NUM ) { throw new  IOException ( ) ; } if ( record < _ NUM || record >= _ NUM ) { throw new  IOException ( ) ; } if ( count < _ NUM || count >= _ NUM ) { throw new  IOException ( ) ; } short registers [ ] = new short [ count ] ; for ( int j = _ NUM ; j < count ; j ++ ) { registers [ j ] = din . read Short ( ) ; offset += _ NUM ; }  Record Request dummy [ ] = new  Record Request [ records . length + _ NUM ] ; if ( records . length > _ NUM ) {  System . arraycopy ( records , _ NUM , dummy , _ NUM , records . length ) ; } records = dummy ; records [ records . length - _ NUM ] = new  Record Request ( file , record , registers ) ; } }
private int scroll By ( int dy ,  Recycler View .  Recycler recycler ,  Recycler View .  State state ) { int delta = _ NUM ; if ( dy > _ NUM ) { top Border = get Padding Top ( ) ; bottom Border += dy ; m Current Position = last Attached Item Position + _ NUM ; fill Grid ( recycler , state , _ BOOL ) ; if ( span Bottom Min >= bottom Border ) { delta = dy ; bottom Border -= dy ; } else { bottom Border = get Height ( ) - get Padding Bottom ( ) ; if ( span Bottom Max - bottom Border >= dy ) { delta = dy ; } else { delta =  Math . max ( _ NUM , span Bottom Max - bottom Border ) ; } } offset Children Vertical ( - delta ) ; for ( int i = _ NUM ; i < m Span Count ; i ++ ) { span Top [ i ] -= delta ; span Bottom [ i ] -= delta ; } span Top Min -= delta ; span Top Max -= delta ; span Bottom Min -= delta ; span Bottom Max -= delta ; recycle Top Invisible Views ( recycler ) ; } else { top Border += dy ; bottom Border = get Height ( ) - get Padding Bottom ( ) ; if ( first Attached Item Position == - _ NUM || first Attached Item Position >= state . get Item Count ( ) ) { first Attached Item Position = state . get Item Count ( ) - _ NUM ; last Attached Item Position = first Attached Item Position ; m Current Position = first Attached Item Position ; } else { m Current Position = first Attached Item Position - _ NUM ; } fill Grid ( recycler , state , _ BOOL ) ; if ( span Top Max <= top Border ) { delta = dy ; top Border -= dy ; } else { top Border = get Padding Top ( ) ; if ( span Top Min - top Border <= dy ) { delta = dy ; } else { delta = -  Math . max ( _ NUM , top Border - span Top Min ) ; } } offset Children Vertical ( - delta ) ; for ( int i = _ NUM ; i < m Span Count ; i ++ ) { span Top [ i ] -= delta ; span Bottom [ i ] -= delta ; } span Top Min -= delta ; span Top Max -= delta ; span Bottom Min -= delta ; span Bottom Max -= delta ; recycle Bottom Invisible Views ( recycler ) ; } scroll Offset += delta ; return delta ; }
public long capacity ( ) { return capacity . get ( ) ; }
protected static token do_id ( ) throws java . io .  IOException {  String Buffer result = new  String Buffer ( ) ;  String result_str ;  Integer keyword_num ; char buffer [ ] = new char [ _ NUM ] ; buffer [ _ NUM ] = ( char ) next_char ; result . append ( buffer , _ NUM , _ NUM ) ; advance ( ) ; while ( id_char ( next_char ) ) { buffer [ _ NUM ] = ( char ) next_char ; result . append ( buffer , _ NUM , _ NUM ) ; advance ( ) ; } result_str = result . to String ( ) ; keyword_num = (  Integer ) keywords . get ( result_str ) ; if ( keyword_num != null ) return new token ( keyword_num . int Value ( ) ) ; return new str_token ( sym .  ID , result_str ) ; }
public static double overlap (  Spatial Comparable box1 ,  Spatial Comparable box2 ) { final int dim = assert Same Dimensionality ( box1 , box2 ) ; double omax , omin ; double overlap = _ NUM ; for ( int i = _ NUM ; i < dim ; i ++ ) { omax =  Math . min ( box1 . get Max ( i ) , box2 . get Max ( i ) ) ; omin =  Math . max ( box1 . get Min ( i ) , box2 . get Min ( i ) ) ; if ( omax <= omin ) { return _ NUM ; } overlap *= omax - omin ; } return overlap ; }
public void test_delete_markers_do Not Visit Deleted ( ) { final  BTree btree ; {  Index Metadata md = new  Index Metadata (  UUID . random UUID ( ) ) ; md . set Delete Markers ( _ BOOL ) ; btree =  BTree . create ( new  Simple Memory Raw Store ( ) , md ) ; btree . insert ( _ NUM , _ STR ) ; btree . insert ( _ NUM , _ STR ) ; btree . insert ( _ NUM , _ STR ) ; } final int flags =  IRange Query .  DEFAULT ; {  ITuple Cursor2 <  String > cursor = new Cursor ( btree , flags , null , null ) ; assert Equals ( new  Test Tuple <  String > ( flags , _ NUM , _ STR , _ BOOL , _ NUM ) , cursor . seek ( _ NUM ) ) ; cursor . remove ( ) ; assert Equals ( null , cursor . tuple ( ) ) ; assert True ( cursor . has Next ( ) ) ; assert Equals ( new  Test Tuple <  String > ( flags , _ NUM , _ STR , _ BOOL , _ NUM ) , cursor . next ( ) ) ; assert False ( cursor . has Prior ( ) ) ; try { cursor . prior ( ) ; fail ( _ STR +  No Such Element Exception . class ) ; } catch (  No Such Element Exception ex ) { log . info ( _ STR + ex ) ; } } }
public static  String relative File (  Iterable < ? extends  File > paths ,  String file ) {  File path = select Path ( paths , file ) ;  File rel File = relative File ( path , new  File ( file ) ) ; return rel File . get Path ( ) ; }
private  String decrypt Image URLPassword (  String image Url ) {  String password = extract Password From Image Url ( image Url ) ; if (  String Utils . is Not Blank ( password ) ) {  String enc Pwd = null ; try {  Encryption Provider Impl encryption Provider Impl = new  Encryption Provider Impl ( ) ; encryption Provider Impl . set Coordinator ( _coordinator ) ; encryption Provider Impl . start ( ) ;  Encryption Provider encryption Provider = encryption Provider Impl ; enc Pwd =  URLEncoder . encode ( encryption Provider . decrypt (  Base64 . decode Base64 ( password ) ) , _ STR ) ; return  String Utils . replace ( image Url , _ STR + password + _ STR , _ STR + enc Pwd + _ STR ) ; } catch (  Unsupported Encoding Exception e ) { log . warn ( _ STR + _ STR , image Url , e . get Message ( ) ) ; } catch (  Exception e ) { log . error ( _ STR + e . get Localized Message ( ) ) ; e . print Stack Trace ( ) ; throw e ; } } return image Url ; }
public  Session Id ( byte [ ] session Id ) { if ( session Id == null ) { throw new  Null Pointer Exception ( _ STR ) ; } this . id =  Arrays . copy Of ( session Id , session Id . length ) ; }
protected static void remove All Triggers (  Connection conn ,  String prefix ) throws  SQLException {  Statement stat = conn . create Statement ( ) ;  Result Set rs = stat . execute Query ( _ STR ) ;  Statement stat2 = conn . create Statement ( ) ; while ( rs . next ( ) ) {  String schema = rs . get String ( _ STR ) ;  String name = rs . get String ( _ STR ) ; if ( name . starts With ( prefix ) ) { name =  String Utils . quote Identifier ( schema ) + _ STR +  String Utils . quote Identifier ( name ) ; stat2 . execute ( _ STR + name ) ; } } }
public boolean add Ignore ( final  String name , final int duration , final  String reply ) { final  String Builder sbuf = new  String Builder ( ) ; if ( duration != _ NUM ) { sbuf . append (  System . current Time Millis ( ) + duration * _ NUM ) ; } sbuf . append ( _ STR ) ; if ( reply != null ) { sbuf . append ( reply ) ; } return set Keyed Slot ( _ STR , _ STR + name , sbuf . to String ( ) ) ; }
public void test Create Element NS1 ( ) throws  Throwable {  Document doc ;  Element element ;  String namespace URI = _ STR ;  String qualified Name = _ STR ;  String node Name ;  String ns URI ;  String local Name ;  String prefix ;  String tag Name ; doc = (  Document ) load ( _ STR , builder ) ; element = doc . create Element NS ( namespace URI , qualified Name ) ; node Name = element . get Node Name ( ) ; ns URI = element . get Namespace URI ( ) ; local Name = element . get Local Name ( ) ; prefix = element . get Prefix ( ) ; tag Name = element . get Tag Name ( ) ; assert Equals ( _ STR , _ STR , node Name ) ; assert Equals ( _ STR , _ STR , ns URI ) ; assert Equals ( _ STR , _ STR , local Name ) ; assert Equals ( _ STR , _ STR , prefix ) ; assert Equals ( _ STR , _ STR , tag Name ) ; }
public void write To File In Directory (  File directory ,  String file Name ,  String content ) { try {  Files . write ( content , new  File ( directory , file Name ) ,  Standard Charsets .  UTF_8 ) ; } catch (  IOException ioe ) { throw new  Runtime Exception ( ioe ) ; } }
public void to UPS ( double lat , double lon ) { double a = _ NUM ; double t = _ NUM ; double e = _ NUM ; double es = _ NUM ; double rho = _ NUM ; double x ; double y ; final double k0 = _ NUM ; double lambda = lon *  Degree ; double phi =  Math . abs ( lat *  Degree ) ; a = _ NUM ; es = _ NUM ; e =  Math . sqrt ( es ) ; t =  Math . tan (  Math .  PI / _ NUM - phi / _ NUM ) /  Math . pow ( ( _ NUM - e *  Math . sin ( phi ) ) / ( _ NUM + e *  Math . sin ( phi ) ) , ( e / _ NUM ) ) ; rho = _ NUM * a * k0 * t /  Math . sqrt (  Math . pow ( _ NUM + e , _ NUM + e ) *  Math . pow ( _ NUM - e , _ NUM - e ) ) ; x = rho *  Math . sin ( lambda ) ; y = rho *  Math . cos ( lambda ) ; if ( lat > _ NUM ) { y = - ( y ) ; } x += _ NUM ; y += _ NUM ; easting = x ; northing = y ; }
protected boolean remove Level Xing (  Level Xing o ) { if ( ! no Warn Level Xing ) { int selected Value =  JOption Pane . show Option Dialog ( this , rb . get String ( _ STR ) ,  Bundle . get Message ( _ STR ) ,  JOption Pane .  YES_ NO_ CANCEL_ OPTION ,  JOption Pane .  QUESTION_ MESSAGE , null , new  Object [ ] {  Bundle . get Message ( _ STR ) ,  Bundle . get Message ( _ STR ) , rb . get String ( _ STR ) } ,  Bundle . get Message ( _ STR ) ) ; if ( selected Value == _ NUM ) { return ( _ BOOL ) ; } if ( selected Value == _ NUM ) { no Warn Level Xing = _ BOOL ; } } if ( selected Object == o ) { selected Object = null ; } if ( prev Selected Object == o ) { prev Selected Object = null ; }  Track Segment t = (  Track Segment ) o . get Connect A ( ) ; if ( t != null ) { substitute Anchor ( o . get Coords A ( ) , o , t ) ; } t = (  Track Segment ) o . get Connect B ( ) ; if ( t != null ) { substitute Anchor ( o . get Coords B ( ) , o , t ) ; } t = (  Track Segment ) o . get Connect C ( ) ; if ( t != null ) { substitute Anchor ( o . get Coords C ( ) , o , t ) ; } t = (  Track Segment ) o . get Connect D ( ) ; if ( t != null ) { substitute Anchor ( o . get Coords D ( ) , o , t ) ; }  Layout Block lb = o . get Layout Block AC ( ) ; if ( lb != null ) { lb . decrement Use ( ) ; }  Layout Block lbx = o . get Layout Block BD ( ) ; if ( lbx != null && lb != null && lbx != lb ) { lb . decrement Use ( ) ; } for ( int i = _ NUM ; i < xing List . size ( ) ; i ++ ) {  Level Xing lx = xing List . get ( i ) ; if ( lx == o ) { xing List . remove ( i ) ; o . remove ( ) ; set Dirty ( _ BOOL ) ; repaint ( ) ; return ( _ BOOL ) ; } } return ( _ BOOL ) ; }
public static  Buffered Image crop Image (  Buffered Image image , int crop Width , int crop Height ) {  Buffered Image ret Img = null ; int width = _ NUM ; int height = _ NUM ; width = image . get Width ( ) ; height = image . get Height ( ) ; ret Img = new  Buffered Image ( crop Width , crop Height ,  Buffered Image .  TYPE_ INT_ RGB ) ; for ( int i = _ NUM ; i < crop Width ; i ++ ) { for ( int j = _ NUM ; j < crop Height ; j ++ ) { if ( i < width && j < height ) { ret Img . set RGB ( i , j , image . get RGB ( i , j ) ) ; } else { ret Img . set RGB ( i , j , _ NUM ) ; } } } return ret Img ; }
private void schedule Send ( final int queue Size ) { if ( pending ) { return ; } if ( queue Size >= batch Size ) { enqueue Send ( ) ; return ; } if ( scheduled . compare And Set ( _ BOOL , _ BOOL ) ) { try { scheduler . schedule ( null , max Latency Ms ,  MILLISECONDS ) ; scheduler Queue Size . increment And Get ( ) ; } catch (  Rejected Execution Exception ignore ) { } } }
public  DGet Password (  JFrame parent ,  String title ) { super ( parent , title ,  Modality Type .  DOCUMENT_ MODAL ) ; init Components ( ) ; }
public void add Line End Cap (  Coordinate p0 ,  Coordinate p1 ) {  Line Segment seg = new  Line Segment ( p0 , p1 ) ;  Line Segment offset L = new  Line Segment ( ) ; compute Offset Segment ( seg ,  Position .  LEFT , distance , offset L ) ;  Line Segment offset R = new  Line Segment ( ) ; compute Offset Segment ( seg ,  Position .  RIGHT , distance , offset R ) ; double dx = p1 . x - p0 . x ; double dy = p1 . y - p0 . y ; double angle =  Math . atan2 ( dy , dx ) ; switch ( buf Params . get End Cap Style ( ) ) { case  Buffer Parameters .  CAP_ ROUND : seg List . add Pt ( offset L . p1 ) ; add Fillet ( p1 , angle +  Math .  PI / _ NUM , angle -  Math .  PI / _ NUM ,  CGAlgorithms .  CLOCKWISE , distance ) ; seg List . add Pt ( offset R . p1 ) ; break ; case  Buffer Parameters .  CAP_ FLAT : seg List . add Pt ( offset L . p1 ) ; seg List . add Pt ( offset R . p1 ) ; break ; case  Buffer Parameters .  CAP_ SQUARE :  Coordinate square Cap Side Offset = new  Coordinate ( ) ; square Cap Side Offset . x =  Math . abs ( distance ) *  Math . cos ( angle ) ; square Cap Side Offset . y =  Math . abs ( distance ) *  Math . sin ( angle ) ;  Coordinate square Cap LOffset = new  Coordinate ( offset L . p1 . x + square Cap Side Offset . x , offset L . p1 . y + square Cap Side Offset . y ) ;  Coordinate square Cap ROffset = new  Coordinate ( offset R . p1 . x + square Cap Side Offset . x , offset R . p1 . y + square Cap Side Offset . y ) ; seg List . add Pt ( square Cap LOffset ) ; seg List . add Pt ( square Cap ROffset ) ; break ; } }
public void test Multiply Diff Scale Neg Pos ( ) {  String a = _ STR ; int a Scale = - _ NUM ;  String b = _ STR ; int b Scale = _ NUM ;  String c = _ STR ; int c Scale = - _ NUM ;  Big Decimal a Number = new  Big Decimal ( new  Big Integer ( a ) , a Scale ) ;  Big Decimal b Number = new  Big Decimal ( new  Big Integer ( b ) , b Scale ) ;  Big Decimal result = a Number . multiply ( b Number ) ; assert Equals ( _ STR , c , result . to String ( ) ) ; assert Equals ( _ STR , c Scale , result . scale ( ) ) ; }
public static  String format Simple Decimal With Zeros ( double d ) { return simple Format Force Zero . format ( d ) ; }
protected  Abstract Category Item Label Generator (  String label Format ,  Number Format formatter ) { this ( label Format , formatter ,  Number Format . get Percent Instance ( ) ) ; }
public void add Item (  String item , int i ) { int old Max Length = max Length ; boolean hsb Was Vis = hsb Vis ; boolean vsb Was Vis = vsb Vis ; int added Index = _ NUM ; if ( i < _ NUM || i >= items . size ( ) ) { i = - _ NUM ; } current Index = - _ NUM ; if ( i == - _ NUM ) { items . add Element ( item ) ; i = _ NUM ; added Index = items . size ( ) - _ NUM ; } else { items . insert Element At ( item , i ) ; added Index = i ; for ( int j = _ NUM ; j < selected . length ; j ++ ) { if ( selected [ j ] >= i ) { selected [ j ] += _ NUM ; } } } if ( log . is Loggable (  Platform Logger .  Level .  FINER ) ) { log . finer ( _ STR + item + _ STR + added Index ) ; } boolean repaint Items = ! is Item Hidden ( added Index ) ; max Length =  Math . max ( max Length , get Item Width ( added Index ) ) ; layout ( ) ; int options = _ NUM ; if ( vsb Vis != vsb Was Vis || hsb Vis != hsb Was Vis ) { options =  PAINT_ ALL ; } else { options = ( repaint Items ? (  PAINT_ ITEMS ) : _ NUM ) | ( ( max Length != old Max Length || ( hsb Was Vis ^ hsb Vis ) ) ? (  PAINT_ HSCROLL ) : _ NUM ) | ( ( vsb . needs Repaint ( ) ) ? (  PAINT_ VSCROLL ) : _ NUM ) ; } if ( log . is Loggable (  Platform Logger .  Level .  FINEST ) ) { log . finest ( _ STR + get Last Visible Item ( ) + _ STR + ( hsb Was Vis ^ hsb Vis ) + _ STR + repaint Items ) ; } repaint ( added Index , get Last Visible Item ( ) , options ) ; }
Net Node agg3way (  Net Node x ,  Net Node y ,  Net Node z ,  Stack <  Net Node > amalgs , double [ ] [ ]  D ,  Net Node net Nodes , int num_nodes ) {  Net Node u = new  Net Node ( ) ; u . id = num_nodes + _ NUM ; u . ch1 = x ; u . ch2 = y ;  Net Node v = new  Net Node ( ) ; v . id = num_nodes + _ NUM ; v . ch1 = y ; v . ch2 = z ; u . next = x . next ; u . prev = x . prev ; if ( u . next != null ) u . next . prev = u ; if ( u . prev != null ) u . prev . next = u ; v . next = z . next ; v . prev = z . prev ; if ( v . next != null ) v . next . prev = v ; if ( v . prev != null ) v . prev . next = v ; if ( y . next != null ) y . next . prev = y . prev ; if ( y . prev != null ) y . prev . next = y . next ; u . nbr = v ; v . nbr = u ; for (  Net Node p = net Nodes . next ; p != null ; p = p . next ) {  D [ u . id ] [ p . id ] =  D [ p . id ] [ u . id ] = ( _ NUM / _ NUM ) *  D [ x . id ] [ p . id ] +  D [ y . id ] [ p . id ] / _ NUM ;  D [ v . id ] [ p . id ] =  D [ p . id ] [ v . id ] = ( _ NUM / _ NUM ) *  D [ z . id ] [ p . id ] +  D [ y . id ] [ p . id ] / _ NUM ; }  D [ u . id ] [ u . id ] =  D [ v . id ] [ v . id ] = _ NUM ; amalgs . push ( u ) ; return u ; }
static void put Circle Of Trust (  String realm ,  String name ,  Circle Of Trust Descriptor cot Descriptor ) {  String class Method = _ STR ;  String cache Key = build Cache Key ( realm , name ) ; if ( debug . message Enabled ( ) ) { debug . message ( class Method + _ STR + cache Key ) ; } cot Cache . put ( cache Key , cot Descriptor ) ; }
public void read (  Reader policy ) throws  Parsing Exception ,  IOException { if ( ! ( policy instanceof  Buffered Reader ) ) { policy = new  Buffered Reader ( policy ) ; } st = new  Stream Tokenizer ( policy ) ; st . reset Syntax ( ) ; st . word Chars ( _ STR , _ STR ) ; st . word Chars ( _ STR , _ STR ) ; st . word Chars ( _ STR , _ STR ) ; st . word Chars ( _ STR , _ STR ) ; st . word Chars ( _ STR , _ STR ) ; st . word Chars ( _ STR , _ STR ) ; st . word Chars ( _ NUM + _ NUM , _ NUM ) ; st . whitespace Chars ( _ NUM , _ STR ) ; st . comment Char ( _ STR ) ; st . quote Char ( _ STR ) ; st . quote Char ( _ STR ) ; st . lower Case Mode ( _ BOOL ) ; st . ordinary Char ( _ STR ) ; st . slash Slash Comments ( _ BOOL ) ; st . slash Star Comments ( _ BOOL ) ; lookahead = st . next Token ( ) ;  Grant Entry ge = null ; while ( lookahead !=  Stream Tokenizer .  TT_ EOF ) { if ( peek ( _ STR ) ) { ge = parse Grant Entry ( ) ; if ( ge != null ) add ( ge ) ; } else if ( peek ( _ STR ) && key Store Url String == null ) { parse Key Store Entry ( ) ; } else if ( peek ( _ STR ) && store Pass URL == null ) { parse Store Pass URL ( ) ; } else if ( ge == null && key Store Url String == null && store Pass URL == null && peek ( _ STR ) ) { if ( domain Entries == null ) { domain Entries = new  Tree Map < > ( ) ; }  Domain Entry de = parse Domain Entry ( ) ; if ( de != null ) {  String domain Name = de . get Name ( ) ; if ( ! domain Entries . contains Key ( domain Name ) ) { domain Entries . put ( domain Name , de ) ; } else {  Message Format form = new  Message Format (  Resources Mgr . get String ( _ STR ) ) ;  Object [ ] source = { domain Name } ; throw new  Parsing Exception ( form . format ( source ) ) ; } } } else { } match ( _ STR ) ; } if ( key Store Url String == null && store Pass URL != null ) { throw new  Parsing Exception (  Resources Mgr . get String ( _ STR ) ) ; } }
protected void inject Into Volume Characterstic Container (  Map <  String ,  String > volume Characterstic ,  String characterstic Key ,  String alt Char Key ,  CIMInstance volume Instance ) {  Object value = get CIMProperty Value ( volume Instance , characterstic Key ) ; if ( null == value ) { value = get CIMProperty Value ( volume Instance , alt Char Key ) ; }  String characterstic Name =  Supported Volume Characterstics . get Volume Characterstic ( characterstic Key ) ; if ( null != value && null != characterstic Name ) { volume Characterstic . put ( characterstic Name , value . to String ( ) ) ; } }
@  Override @  Ui Thread public void on Detached From Recycler View ( @  Non Null  Recycler View recycler View ) { super . on Detached From Recycler View ( recycler View ) ; m Attached Recycler View Pool . remove ( recycler View ) ; }
private void load File (  String filename ,  Abstract File Loader ... loaders ) {  Data Sorted Table Model model ; this . m_ Filename = filename ; create Title ( ) ; if ( filename . equals ( _ STR ) ) { model = null ; } else { model = new  Data Sorted Table Model ( filename , loaders ) ; model . set Show Attribute Index ( get Show Attribute Index ( ) ) ; } m_ Table Data . set Model ( model ) ; set Changed ( _ BOOL ) ; create Name ( ) ; }
public static  String decode Endpoint URI (  String endpoint ) { int ind = endpoint . index Of ( _ STR ) ; if ( ind == _ NUM ) { return null ; } else if ( ind != - _ NUM ) { return endpoint . substring ( _ NUM , ind ) ; } return endpoint ; }
public static boolean is Gzip File (  Input Stream in ) throws  IOException { if ( ! in . mark Supported ( ) ) { throw new  Illegal Argument Exception ( _ STR ) ; } in . mark ( _ NUM ) ; try { final byte [ ] b = new byte [ _ NUM ] ;  IOUtils . read Fully ( in , b , _ NUM , _ NUM ) ; final int magic = ( ( ( int ) b [ _ NUM ] & _ NUM ) << _ NUM ) | ( ( int ) b [ _ NUM ] & _ NUM ) ; return magic ==  GZIPInput Stream .  GZIP_ MAGIC ; } finally { in . reset ( ) ; } }
public  String to String ( ) { return _ STR +  Integer . to Hex String ( hash Code ( ) ) + ( location == null ? _ STR : _ STR + location + _ STR ) ; }
public static int prefix Length To Netmask Int ( int prefix Length ) throws  Illegal Argument Exception { if ( prefix Length < _ NUM || prefix Length > _ NUM ) { throw new  Illegal Argument Exception ( _ STR ) ; } int value = _ NUM << ( _ NUM - prefix Length ) ; return  Integer . reverse Bytes ( value ) ; }
public void add Subject (  String subject Name ,  Subject subject ) throws  Name Already Exists Exception ,  Invalid Name Exception ,  Policy Exception ,  SSOException { add Subject ( subject Name , subject , _ BOOL ) ; }
protected void expand For ( int index , int d ) { if ( index < size ) return ; int old Size = size , capacity = vector . length ; size = index + _ NUM ; if ( capacity >= size ) return ; while ( capacity < size ) capacity *= _ NUM ; int [ ] t = new int [ capacity ] ;  System . arraycopy ( vector , _ NUM , t , _ NUM , old Size ) ; if ( d != _ NUM )  Arrays . fill ( t , old Size , size , d ) ; vector = t ; }
private  List <  String > build Command Line ( ) {  List <  String > command Line = new  Array List <  String > ( ) ; command Line . add ( executable ) ; command Line . add All ( jvm Arguments ) ; command Line . add All ( system Properties ) ; if ( classpath != null && jar Path == null ) { command Line . add ( _ STR ) ; command Line . add ( classpath ) ; } if ( jar Path != null ) { command Line . add ( _ STR ) ; command Line . add ( jar Path ) ; } if ( jar Path == null ) { command Line . add ( main Class ) ; } command Line . add All ( application Arguments ) ; return command Line ; }
public  Image base For (  IHex hex ) { return hex Tileset . get Base ( hex , boardview ) ; }
public static  String encode From File (  String filename ) {  String encoded Data = null ;  Base64 .  Input Stream bis = null ; try { java . io .  File file = new java . io .  File ( filename ) ; byte [ ] buffer = new byte [ ( int ) ( file . length ( ) * _ NUM ) ] ; int length = _ NUM ; int num Bytes = _ NUM ; bis = new  Base64 .  Input Stream ( new java . io .  Buffered Input Stream ( new java . io .  File Input Stream ( file ) ) ,  Base64 .  ENCODE ) ; while ( ( num Bytes = bis . read ( buffer , length , _ NUM ) ) >= _ NUM ) length += num Bytes ; encoded Data = new  String ( buffer , _ NUM , length ,  Base64 .  PREFERRED_ ENCODING ) ; } catch ( java . io .  IOException e ) { logger . error ( _ STR + filename , e ) ; } finally { try { bis . close ( ) ; } catch (  Exception e ) { } } return encoded Data ; }
private void write Java Parameter Spec (  Java Parameter Spec spec ,  Document document ,  Element parent Element ) {  Element parameter = document . create Element ( _ STR ) ; parent Element . append Child ( parameter ) ; parameter . set Attribute ( _ STR , spec . get Package Name ( ) ) ; parameter . set Attribute ( _ STR , spec . get Class Name ( ) ) ; parameter . set Attribute ( _ STR , spec . get Half Signature ( ) ) ; parameter . set Attribute ( _ STR ,  Integer . to String ( spec . get Param Idx ( ) ) ) ; }
private synchronized void read Object ( java . io .  Object Input Stream s ) throws  IOException ,  Class Not Found Exception { s . default Read Object ( ) ; init ( get Mask ( actions ) ) ; }
@  Override public synchronized void parse (  Input Stream in ,  String base URI ) throws  IOException ,  RDFParse Exception ,  RDFHandler Exception { if ( in == null ) { throw new  Illegal Argument Exception ( _ STR ) ; } if ( base URI == null ) { throw new  Illegal Argument Exception ( _ STR ) ; }  Input Source input Source = new  Input Source ( new  BOMInput Stream ( in , _ BOOL ) ) ; input Source . set System Id ( base URI ) ; parse ( input Source ) ; }
public static boolean is Surrogate Pair (  String text , int idx ) { return ! ( idx < _ NUM || idx > text . length ( ) - _ NUM ) && is Surrogate High ( text . char At ( idx ) ) && is Surrogate Low ( text . char At ( idx + _ NUM ) ) ; }
@  Suppress Warnings ( _ STR ) public static void add File (  File f ) throws  IOException { add URL ( f . to URL ( ) ) ; }
public void insert ( int row Index ,  Iterable < ? extends  T > new Items ) { int ri = row Index ; int ri2 = row Index - _ NUM ; for (  T t : new Items ) { ri2 ++ ; items . add ( ri2 , t ) ; } fire Table Rows Inserted ( ri , ri2 ) ; }
public void put (  Double Min Max val ) { min = val . min < min ? val . min : min ; max = val . max > max ? val . max : max ; }
public  Int Buffer minor Version Buffer ( ) { int [ ] holder = new int [ _ NUM ] ; holder [ _ NUM ] = get Minor Version ( ) ;  Int Buffer ib =  Int Buffer . wrap ( holder ) ; ib . limit ( _ NUM ) ; return ib ; }
public  Create Index Request aliases (  XContent Builder source ) { return aliases ( source . bytes ( ) ) ; }
static synchronized void compute PRF_ SSLv3 ( byte [ ] out , byte [ ] secret , byte [ ] seed ) { if ( sha == null ) { init ( ) ; } int pos = _ NUM ; int iteration = _ NUM ; byte [ ] digest ; while ( pos < out . length ) { byte [ ] pref = new byte [ iteration ] ;  Arrays . fill ( pref , ( byte ) ( _ NUM + iteration ++ ) ) ; sha . update ( pref ) ; sha . update ( secret ) ; sha . update ( seed ) ; md5 . update ( secret ) ; md5 . update ( sha . digest ( ) ) ; digest = md5 . digest ( ) ; if ( pos + _ NUM > out . length ) {  System . arraycopy ( digest , _ NUM , out , pos , out . length - pos ) ; pos = out . length ; } else {  System . arraycopy ( digest , _ NUM , out , pos , _ NUM ) ; pos += _ NUM ; } } }
public  Http Request content Length ( final int value ) { connection . set Fixed Length Streaming Mode ( value ) ; return this ; }
public static void build Excel Sheet ( final  JKTable Model model ) { final  JKExcel Util sheet = new  JKExcel Util ( model ) ; try { final  File file =  JKIOUtil . create Temp File ( _ STR ) ; sheet . write To ( file ) ;  JKIOUtil . execute File ( file . get Absolute Path ( ) ) ; file . delete On Exit ( ) ; } catch ( final  IOException ex ) { throw new  Runtime Exception ( ex ) ; } }
public static  Object demux Array (  Object src , int [ ] dims ,  Class < ? > component Type ) {  Object dst = null ; if ( component Type != byte . class ) { dst =  Array . new Instance ( component Type , dims ) ; } else { int [ ] dims Temp = new int [ dims . length + _ NUM ] ;  System . arraycopy ( dims , _ NUM , dims Temp , _ NUM , dims . length ) ; dims Temp [ dims . length ] = _ NUM ; dst =  Array . new Instance ( component Type , dims Temp ) ; } _fill Demux ( _ NUM , dims , src , _ NUM , dst ) ; return dst ; }
private void force Quit ( ) { if ( stdout != null ) { stdout . close ( ) ; } try { if ( shell != null ) { shell . disconnect ( ) ; } } catch (  Runtime Exception e ) {  LOG . error ( e . get Message ( ) , e ) ; } finally { shell = null ; } try { if ( session != null ) { session . disconnect ( ) ; } } catch (  Runtime Exception e ) {  LOG . error ( e . get Message ( ) , e ) ; } finally { session = null ; } }
public  String request Statistics ( ) { if ( interval > _ NUM ) { synchronized ( sbmutex ) { return sb . to String ( ) ; } } else { sb . set Length ( _ NUM ) ; make String Buffer ( sb ) ; return sb . to String ( ) ; } }
private void plot Point ( int x , int y , int width , int height , double [ ] probs , boolean update ) {  Graphics osg = m_osi . get Graphics ( ) ; if ( update ) { osg . set XORMode (  Color . white ) ; osg . draw Line ( _ NUM , y , m_panel Width - _ NUM , y ) ; update ( ) ; osg . draw Line ( _ NUM , y , m_panel Width - _ NUM , y ) ; } osg . set Paint Mode ( ) ; float [ ] col Val = new float [ _ NUM ] ; float [ ] temp Cols = new float [ _ NUM ] ; for ( int k = _ NUM ; k < probs . length ; k ++ ) {  Color curr = m_ Colors . get ( k % m_ Colors . size ( ) ) ; curr . get RGBColor Components ( temp Cols ) ; for ( int z = _ NUM ; z < _ NUM ; z ++ ) { col Val [ z ] += probs [ k ] * temp Cols [ z ] ; } } for ( int z = _ NUM ; z < _ NUM ; z ++ ) { if ( col Val [ z ] < _ NUM ) { col Val [ z ] = _ NUM ; } else if ( col Val [ z ] > _ NUM ) { col Val [ z ] = _ NUM ; } } osg . set Color ( new  Color ( col Val [ _ NUM ] , col Val [ _ NUM ] , col Val [ _ NUM ] ) ) ; osg . fill Rect ( x , y , width , height ) ; }
@  Override public void key Pressed (  Key Event e ) { synchronized ( key Lock ) { keys Down . add ( e . get Key Code ( ) ) ; } for (  Draw Listener listener : listeners ) listener . key Pressed ( e . get Key Code ( ) ) ; }
public static  String slurp URLNo Exceptions (  URL u ) { try { return slurp URL ( u ) ; } catch (  Exception e ) { e . print Stack Trace ( ) ; return null ; } }
public static  Rename Participant [ ] load Rename Participants (  Refactoring Status status ,  Refactoring Processor processor ,  Object element ,  Rename Arguments arguments ,  IParticipant Descriptor Filter filter ,  String [ ] affected Natures ,  Sharable Participants shared ) {  Refactoring Participant [ ] participants = fg Rename Instance . get Participants ( status , processor , element , arguments , filter , affected Natures , shared ) ;  Rename Participant [ ] result = new  Rename Participant [ participants . length ] ;  System . arraycopy ( participants , _ NUM , result , _ NUM , participants . length ) ; return result ; }
Impl (  Strategy <  K ,  V ,  E > strategy ,  Builder builder ) { int concurrency Level = builder . get Concurrency Level ( ) ; int initial Capacity = builder . get Initial Capacity ( ) ; if ( concurrency Level >  MAX_ SEGMENTS ) { concurrency Level =  MAX_ SEGMENTS ; } int segment Shift = _ NUM ; int segment Count = _ NUM ; while ( segment Count < concurrency Level ) { ++ segment Shift ; segment Count <<= _ NUM ; } this . segment Shift = _ NUM - segment Shift ; segment Mask = segment Count - _ NUM ; this . segments = new Segment Array ( segment Count ) ; if ( initial Capacity >  MAXIMUM_ CAPACITY ) { initial Capacity =  MAXIMUM_ CAPACITY ; } int segment Capacity = initial Capacity / segment Count ; if ( segment Capacity * segment Count < initial Capacity ) { ++ segment Capacity ; } int segment Size = _ NUM ; while ( segment Size < segment Capacity ) { segment Size <<= _ NUM ; } for ( int i = _ NUM ; i < this . segments . length ; ++ i ) { this . segments [ i ] = new  Segment ( segment Size ) ; } this . strategy = strategy ; strategy . set Internals ( new  Internals Impl ( ) ) ; }
private void paint Foreground Pressed (  Graphics2 D g , int width , int height ) {  Shape s = decode Arrow Path ( width , height ) ; g . set Paint ( pressed Color ) ; g . fill ( s ) ; }
@  Request Processing ( value = _ STR , method =  HTTPRequest Method .  GET ) @  Before ( advice Class = {  Stopwatch Start Advice . class ,  Anonymous View Check . class ,  User Block Check . class } ) @  After ( advice Class =  Stopwatch End Advice . class ) public void show Home ( final  HTTPRequest Context context , final  Http Servlet Request request , final  Http Servlet Response response , final  String user Name ) throws  Exception { final  JSONObject user = (  JSONObject ) request . get Attribute (  User .  USER ) ;  String page Num Str = request . get Parameter ( _ STR ) ; if (  Strings . is Empty Or Null ( page Num Str ) || !  Strings . is Numeric ( page Num Str ) ) { page Num Str = _ STR ; } final int page Num =  Integer . value Of ( page Num Str ) ; request . set Attribute (  Keys .  TEMAPLTE_ DIR_ NAME ,  Symphonys . get ( _ STR ) ) ; final  Abstract Free Marker Renderer renderer = new  Skin Renderer ( ) ; context . set Renderer ( renderer ) ; final  Map <  String ,  Object > data Model = renderer . get Data Model ( ) ; filler . fill Header And Footer ( request , response , data Model ) ; final  String following Id = user . opt String (  Keys .  OBJECT_ ID ) ; data Model . put (  Follow .  FOLLOWING_ ID , following Id ) ; renderer . set Template Name ( _ STR ) ; data Model . put (  User .  USER , user ) ; fill Home User ( data Model , user ) ; avatar Query Service . fill User Avatar URL ( user ) ; final boolean is Logged In = (  Boolean ) data Model . get (  Common .  IS_ LOGGED_ IN ) ; if ( is Logged In ) { final  JSONObject current User = (  JSONObject ) data Model . get (  Common .  CURRENT_ USER ) ; final  String follower Id = current User . opt String (  Keys .  OBJECT_ ID ) ; final boolean is Following = follow Query Service . is Following ( follower Id , following Id ) ; data Model . put (  Common .  IS_ FOLLOWING , is Following ) ; } user . put (  User Ext .  USER_ T_ CREATE_ TIME , new  Date ( user . get Long (  Keys .  OBJECT_ ID ) ) ) ; final int page Size =  Symphonys . get Int ( _ STR ) ; final int window Size =  Symphonys . get Int ( _ STR ) ; final  List <  JSONObject > user Articles = article Query Service . get User Articles ( user . opt String (  Keys .  OBJECT_ ID ) , page Num , page Size ) ; data Model . put (  Common .  USER_ HOME_ ARTICLES , user Articles ) ; final int article Cnt = user . opt Int (  User Ext .  USER_ ARTICLE_ COUNT ) ; final int page Count = ( int )  Math . ceil ( ( double ) article Cnt / ( double ) page Size ) ; final  List <  Integer > page Nums =  Paginator . paginate ( page Num , page Size , page Count , window Size ) ; if ( ! page Nums . is Empty ( ) ) { data Model . put (  Pagination .  PAGINATION_ FIRST_ PAGE_ NUM , page Nums . get ( _ NUM ) ) ; data Model . put (  Pagination .  PAGINATION_ LAST_ PAGE_ NUM , page Nums . get ( page Nums . size ( ) - _ NUM ) ) ; } data Model . put (  Pagination .  PAGINATION_ CURRENT_ PAGE_ NUM , page Num ) ; data Model . put (  Pagination .  PAGINATION_ PAGE_ COUNT , page Count ) ; data Model . put (  Pagination .  PAGINATION_ PAGE_ NUMS , page Nums ) ; final  JSONObject current User =  Sessions . current User ( request ) ; if ( null == current User ) { data Model . put (  Common .  IS_ MY_ ARTICLE , _ BOOL ) ; } else { data Model . put (  Common .  IS_ MY_ ARTICLE , user Name . equals ( current User . opt String (  User .  USER_ NAME ) ) ) ; } }
@  Override public  XMLEvent next Event ( ) throws  XMLStream Exception { log . log (  Level .  FINE , _ STR ) ; current Event = next Event ; if ( current Event . get Event Type ( ) !=  XMLStream Constants .  END_ DOCUMENT ) { next Event = construct Event ( stream . next ( ) , stream ) ; } else { next Event = null ; } log . log (  Level .  FINE , _ STR , current Event ) ; return current Event ; }
private void close Connection (  Connection connection ) throws  SQLException { if ( connection != null ) { try { connection . close ( ) ; } catch (  SQLException e ) { throw new  SQLException ( _ STR , e ) ; } } }
public void validate (  Object obj ) {  Class clazz = obj . get Class ( ) ;  Validator validator = _input Type Map . get ( clazz ) ; if ( validator == null ) { validator = new  Validator ( clazz ) ; _input Type Map . put If Absent ( clazz , validator ) ; } validator . validate ( obj ) ; }
void cross Over (  Bayes Net Representation other ) { boolean [ ] bits = new boolean [ m_bits . length ] ; for ( int i = _ NUM ; i < m_bits . length ; i ++ ) { bits [ i ] = m_bits [ i ] ; } int i Cross Over Point = m_bits . length ; do { for ( int i = i Cross Over Point ; i < m_bits . length ; i ++ ) { m_bits [ i ] = bits [ i ] ; } i Cross Over Point = m_random . next Int ( m_bits . length ) ; for ( int i = i Cross Over Point ; i < m_bits . length ; i ++ ) { m_bits [ i ] = other . m_bits [ i ] ; } } while ( has Cycles ( ) ) ; calc Score ( ) ; }
public byte [ ] digest ( ) { byte [ ] result = engine Digest ( ) ; state =  INITIAL ; return result ; }
public void show Perspective ( final  String perspective Name ) { show Perspective ( model . get Perspective ( perspective Name ) ) ; }
public static double phred To Prob ( double phred ) { return  Math . pow ( _ NUM , - phred / _ NUM ) ; }
protected  Token <  Token Type > read Delimited String Token ( char delimiter , char escape Char ,  Token Type token Type ) throws  Simple Parser Exception { final  Token Position position = get Token Position ( ) ; final  String attachment = read Delimited String ( delimiter , escape Char ) ; return new  Token < > ( token Type , position , attachment . length ( ) , attachment ) ; }
public void test Set String ( ) throws  Exception { connection . set Auto Commit ( _ BOOL ) ;  Prepared Statement stmt = connection . prepare Statement ( _ STR ) ; try { stmt . set Int ( _ NUM , _ NUM ) ; stmt . set String ( _ NUM ,  TEST_ TEXT ) ; stmt . execute Update ( ) ; connection . commit ( ) ; stmt . set Int ( _ NUM , _ NUM ) ; stmt . set String ( _ NUM ,  TEST_ TEXT ) ; stmt . execute Update ( ) ; connection . commit ( ) ; stmt . set Int ( _ NUM , _ NUM ) ; stmt . set String ( _ NUM ,  TEST_ TEXT ) ; stmt . execute Update ( ) ; connection . commit ( ) ; } finally { stmt . close ( ) ; } connection . set Auto Commit ( _ BOOL ) ; }
public  Eg Demand Details insert Advance Collection ( final  String demand Reason , final  Big Decimal advance Collection Amount , final  Installment installment ) {  Eg Demand Details demand Detail = null ; if ( advance Collection Amount != null && advance Collection Amount . compare To (  Big Decimal .  ZERO ) > _ NUM ) { final  Eg Demand Reason Master eg Demand Reason Master = demand Generic DAO . get Demand Reason Master By Code (  Water Tax Constants .  DEMANDRSN_ CODE_ ADVANCE , module ( ) ) ; if ( eg Demand Reason Master == null ) throw new  Application Runtime Exception ( _ STR ) ; final  Eg Demand Reason eg Demand Reason = demand Generic DAO . get Dmd Reason By Dmd Reason Mster Install And Mod ( eg Demand Reason Master , installment , module ( ) ) ; if ( eg Demand Reason == null ) throw new  Application Runtime Exception ( _ STR ) ; demand Detail = create Demand Details ( eg Demand Reason , advance Collection Amount ,  Big Decimal .  ZERO ) ; } return demand Detail ; }
private void load Database Header (  Byte Buffer bb ) throws  IOException { if ( bb . get Int ( ) !=  MAGIC ) { throw new  Error ( _ STR ) ; } if ( bb . get Int ( ) !=  VERSION ) { throw new  Error ( _ STR ) ; } sample Rate = bb . get Int ( ) ; num Channels = bb . get Int ( ) ; lpc Min = bb . get Float ( ) ; lpc Range = bb . get Float ( ) ; }
public void handle Periodic Maintenance (  Operation post ) { post . complete ( ) ; }
public <  T >  T time (  Callable <  T > event ) throws  Exception { final long start Time = clock . get Tick ( ) ; try { return event . call ( ) ; } finally { update ( clock . get Tick ( ) - start Time ) ; } }
public static boolean is Post JDK5 (  String bytecode Version ) { return  JDK5 . equals ( bytecode Version ) ||  JDK6 . equals ( bytecode Version ) ||  JDK7 . equals ( bytecode Version ) ||  JDK8 . equals ( bytecode Version ) ; }
public  Create Index Request mapping (  String type ,  Object ... source ) { mapping ( type ,  Put Mapping Request . build From Simplified Def ( type , source ) ) ; return this ; }
private static  String load Contents (  Object file Data ) throws  IOException {  String path =  Draft3 File Value Helper . get Path ( file Data ) ;  Input Stream is = null ; try {  File file = new  File ( path ) ; is = new  File Input Stream ( file ) ; byte [ ] buffer = new byte [  Math . min (  CONTENTS_ NUMBER_ OF_ BYTES , ( int ) file . length ( ) ) ] ; is . read ( buffer ) ; return new  String ( buffer , _ STR ) ; } finally { if ( is != null ) { try { is . close ( ) ; } catch (  IOException e ) { } } } }
public synchronized void add Listener (  Object listener ) { if ( listener != null ) { if ( listeners == null ) { listeners = new  Array List <  Object > ( ) ; } if ( ! listeners . contains ( listener ) ) { listeners . add ( listener ) ; } } }
public  Distribution Graph ( ) { super ( ) ;  Edge Distros = new  Hash Map ( ) ; }
@  Override public void render Forms Onto G2 In Headless ( final  Object raw , final int page Index , final  Map components To Ignore , final  Form Factory form Factory ) { if ( forms Ordered == null || forms Ordered [ page Index ] == null ) { return ; } this . components To Ignore = components To Ignore ;  Form Object form Object ; final boolean is Printing = form Factory != null ; final  Graphics2 D g2 = (  Graphics2 D ) raw ; final  Affine Transform default Af = g2 . get Transform ( ) ; final  Affine Transform aff = g2 . get Transform ( ) ; aff . scale ( _ NUM , _ NUM ) ; g2 . set Transform ( aff ) ; for ( final  Form Object next Val : forms Ordered [ page Index ] ) { if ( next Val != null ) { form Object = next Val ; final boolean [ ] flags = form Object . get Characteristics ( ) ; if ( ( ( flags [ _ NUM ] || ( is Printing && ! flags [ _ NUM ] ) ) ) ) { continue ; } render Component ( g2 , form Object , is Printing ) ; } } g2 . set Transform ( default Af ) ; }
public void test Copy Char Array Set ( ) {  Char Array Set set Ingore Case = new  Char Array Set ( _ NUM , _ BOOL ) ;  Char Array Set set Case Sensitive = new  Char Array Set ( _ NUM , _ BOOL ) ;  List <  String > stopwords =  Arrays . as List (  TEST_ STOP_ WORDS ) ;  List <  String > stopwords Upper = new  Array List < > ( ) ; for (  String string : stopwords ) { stopwords Upper . add ( string . to Upper Case (  Locale .  ROOT ) ) ; } set Ingore Case . add All (  Arrays . as List (  TEST_ STOP_ WORDS ) ) ; set Ingore Case . add (  Integer . value Of ( _ NUM ) ) ; set Case Sensitive . add All (  Arrays . as List (  TEST_ STOP_ WORDS ) ) ; set Case Sensitive . add (  Integer . value Of ( _ NUM ) ) ;  Char Array Set copy =  Char Array Set . copy ( set Ingore Case ) ;  Char Array Set copy Case Sens =  Char Array Set . copy ( set Case Sensitive ) ; assert Equals ( set Ingore Case . size ( ) , copy . size ( ) ) ; assert Equals ( set Case Sensitive . size ( ) , copy . size ( ) ) ; assert True ( copy . contains All ( stopwords ) ) ; assert True ( copy . contains All ( stopwords Upper ) ) ; assert True ( copy Case Sens . contains All ( stopwords ) ) ; for (  String string : stopwords Upper ) { assert False ( copy Case Sens . contains ( string ) ) ; }  List <  String > new Words = new  Array List < > ( ) ; for (  String string : stopwords ) { new Words . add ( string + _ STR ) ; } copy . add All ( new Words ) ; assert True ( copy . contains All ( stopwords ) ) ; assert True ( copy . contains All ( stopwords Upper ) ) ; assert True ( copy . contains All ( new Words ) ) ; for (  String string : new Words ) { assert False ( set Ingore Case . contains ( string ) ) ; assert False ( set Case Sensitive . contains ( string ) ) ; } }
public void send Event ( int id ) { synchronized ( this ) { if ( queue == null ) { queue = new  Queue ( ) ; }  Integer event Id =  Integer . value Of ( id ) ; queue . enqueue ( event Id ) ; notify All ( ) ; } if ( id ==  APPLET_ QUIT ) { try { join Applet Thread ( ) ; } catch (  Interrupted Exception e ) { } if ( loader == null ) loader = get Class Loader ( get Code Base ( ) , get Class Loader Cache Key ( ) ) ; release ( ) ; } }
private  List <  String > pick Table Names From Table Models ( ) {  List <  String > table Names = new  Array List <  String > ( ) ; for (  Table Model table Model : m Table Models ) { table Names . add ( table Model . get Table Name ( ) ) ; } return table Names ; }
public  Iterable find All (  Iterable ids ) { final  List entities = new  Linked List ( ) ; log . info ( _ STR ) ; log . debug ( ids ) ; for (  Object id : ids ) { final  Object found = find One ( (  Serializable ) id ) ; if ( found != null ) { log . trace ( _ STR + id + _ STR ) ; entities . add ( found ) ; } } return entities ; }
private void unmark Removed Default Session Token (  String site ,  String token ) { if ( removed Default Tokens == null ) return ;  Hash Set <  String > removed = removed Default Tokens . get ( site ) ; if ( removed == null ) return ; removed . remove ( token ) ; }
protected  Map <  URI ,  List <  URI > > to Export Mask To Initiator URIs (  Map <  String ,  Set <  URI > > initiator To Export Masks ,  Map <  String ,  URI > port Name To Initiator URI ) {  Map <  URI ,  List <  URI > > map =  Collections .  EMPTY_ MAP ; if ( initiator To Export Masks != null && initiator To Export Masks . size ( ) > _ NUM ) { map = new  Hash Map < > ( ) ; for (  Map .  Entry <  String ,  Set <  URI > > entry : initiator To Export Masks . entry Set ( ) ) { for (  URI export Mask URI : entry . get Value ( ) ) {  List <  URI > initiators = map . get ( export Mask URI ) ; if ( initiators == null ) { initiators = new  Array List < > ( ) ; map . put ( export Mask URI , initiators ) ; }  URI initiator URI = port Name To Initiator URI . get ( entry . get Key ( ) ) ; if ( initiator URI != null && ! initiators . contains ( initiator URI ) ) { initiators . add ( initiator URI ) ; } } } } return map ; }
private boolean on Notification Clicked ( long persistent Notification Id ,  String origin ,  String tag ) { m Last Notification Click Ms =  System . current Time Millis ( ) ; return native On Notification Clicked ( m Native Notification Manager , persistent Notification Id , origin , tag ) ; }
public static final  File Time win Time To File Time ( long wtime ) { return  File Time . from ( wtime / _ NUM +  WINDOWS_ EPOCH_ IN_ MICROSECONDS ,  Time Unit .  MICROSECONDS ) ; }
public void add Address (  Address Entity address ) { addresses . add ( address ) ; }
public  Validation Result is Fully Qualified Host (  String host ,  Map props ,  IState Access state ) {  Validation Result Status valid Res =  Validation Result Status .  STATUS_ FAILED ;  Localized Message return Message = null ; if ( ( host != null ) && ( host . length ( ) > _ NUM ) ) { if ( ( ! host . starts With ( _ STR ) ) && ( ! host . ends With ( _ STR ) ) ) {  String Tokenizer tokens = new  String Tokenizer ( host , _ STR ) ; if ( tokens . count Tokens ( ) >= _ NUM ) { valid Res =  Validation Result Status .  STATUS_ SUCCESS ; } } } if ( valid Res . get Int Value ( ) ==  Validation Result Status .  INT_ STATUS_ FAILED ) { return Message =  Localized Message . get (  LOC_ VA_ WRN_ IN_ VAL_ FULLY_ QUAL_ HOST , new  Object [ ] { host } ) ; }  Debug . log ( _ STR + host + _ STR + _ STR + valid Res . is Successful ( ) ) ; return new  Validation Result ( valid Res , null , return Message ) ; }
private static  String add Arguments (  Object [ ] arguments ,  String message ) { try { formatter . apply Pattern ( message ) ;  String formatted = formatter . format ( arguments ) ; return formatted ; } catch (  Throwable t ) { return message ; } }
protected  Element insert Prosody Settings (  Element insert Here ,  Feature Set feature Set ) { if ( insert Here == null || feature Set == null ) throw new  Null Pointer Exception ( _ STR ) ; boolean have Prosody Info = _ BOOL ; for (  String att :  XML2 Utt Base .  PROSODY_ ATTRIBUTES ) { if ( feature Set . get String ( att ) != null ) { have Prosody Info = _ BOOL ; break ; } } if ( ! have Prosody Info ) { return null ; }  Document doc = insert Here . get Owner Document ( ) ;  Element prosody =  Mary XML . create Element ( doc ,  Mary XML .  PROSODY ) ; insert Here . append Child ( prosody ) ; for (  String att :  XML2 Utt Base .  PROSODY_ ATTRIBUTES ) {  String val = feature Set . get String ( att ) ; if ( val != null ) { prosody . set Attribute ( att , val ) ; } } return prosody ; }
public static  File store Catalog File (  String catalog File Name ) {  File folder = null ;  String folder Name ; int pos = catalog File Name . index Of (  Constants .  FOLDER_ SEPARATOR ) ; if ( pos != - _ NUM ) { folder Name = catalog File Name . substring ( _ NUM , pos ) ; folder = new  File ( get Generate Folder ( ) , folder Name ) ; } else { folder Name = _ STR ; folder = new  File ( get Generate Folder ( ) , folder Name ) ; } if ( ! folder . exists ( ) ) { folder . mkdirs ( ) ; } map Of Catalog Folder Names . put ( catalog File Name , folder Name ) ;  File result = new  File ( get Generate Folder ( ) , catalog File Name ) ; return result ; }
private void check Protocol Already Exists (  Set <  String > protocols ,  String protocol Type ) { if ( ! protocols . contains ( protocol Type ) ) { protocols . add ( protocol Type ) ; } }
public void put (  Unique String key ,  Object val ) { int loc = key . get Defn Loc ( ) ; if ( loc == - _ NUM ) { loc = defn Idx ++ ; key . set Loc ( loc ) ; } if ( loc >= this . table . length ) { int old Size = this . table . length ; int new Size =  Math . max ( _ NUM * old Size , loc + _ NUM ) ;  Object [ ] old = this . table ; this . table = new  Object [ new Size ] ;  System . arraycopy ( old , _ NUM , this . table , _ NUM , old . length ) ; } this . table [ loc ] = val ; }
public static void write With Locale (  File eml File ,  Resource resource ,  Locale locale ) {  Locale current Locale =  Locale . get Default ( ) ; try { synchronized ( current Locale ) {  Locale . set Default ( locale ) ;  Eml Writer . write Eml File ( eml File , resource . get Eml ( ) ) ;  Locale . set Default ( current Locale ) ; } } catch (  IOException e ) {  LOG . error ( e ) ; throw new  Invalid Config Exception (  TYPE .  CONFIG_ WRITE , _ STR + resource ) ; } catch (  Template Exception e ) {  LOG . error ( _ STR , e ) ; throw new  Invalid Config Exception (  TYPE .  EML , _ STR + resource + _ STR + e . get Message ( ) ) ; } finally {  Locale . set Default ( current Locale ) ; } }
public  Log Message read Log Batch (  Log Message start Log ,  List <  Log Message > log Batch ) throws  IOException ,  Compressor Exception { long batch Time = start Log . get Time ( ) ; log Batch . add ( start Log ) ;  Log Message msg ; while ( ( msg = read Next Merged Log Message ( ) ) != null ) { if ( msg . get Time ( ) == batch Time ) { log Batch . add ( msg ) ; } else { return msg ; } } return null ; }
protected  Size2 D draw Horizontal (  Graphics2 D g2 ,  Rectangle2 D chart Area ) { double start Y ; double top Space ; double bottom Space ; double left Space ; double right Space ; double w = get Width ( ) ; double h = get Height ( ) ;  Rectangle Insets padding = get Padding ( ) ; top Space = padding . calculate Top Outset ( h ) ; bottom Space = padding . calculate Bottom Outset ( h ) ; left Space = padding . calculate Left Outset ( w ) ; right Space = padding . calculate Right Outset ( w ) ; if ( get Position ( ) ==  Rectangle Edge .  TOP ) { start Y = chart Area . get Y ( ) + top Space ; } else { start Y = chart Area . get Y ( ) + chart Area . get Height ( ) - bottom Space - h ; }  Horizontal Alignment horizontal Alignment = get Horizontal Alignment ( ) ; double start X = _ NUM ; if ( horizontal Alignment ==  Horizontal Alignment .  CENTER ) { start X = chart Area . get X ( ) + left Space + chart Area . get Width ( ) / _ NUM - w / _ NUM ; } else if ( horizontal Alignment ==  Horizontal Alignment .  LEFT ) { start X = chart Area . get X ( ) + left Space ; } else if ( horizontal Alignment ==  Horizontal Alignment .  RIGHT ) { start X = chart Area . get X ( ) + chart Area . get Width ( ) - right Space - w ; } g2 . draw Image ( this . image , ( int ) start X , ( int ) start Y , ( int ) w , ( int ) h , null ) ; return new  Size2 D ( chart Area . get Width ( ) + left Space + right Space , h + top Space + bottom Space ) ; }
private static final  Private Key construct Private Key ( byte [ ] encoded Key ,  String encoded Key Algorithm ) throws  Invalid Key Exception ,  No Such Algorithm Exception {  Private Key key = null ; try {  Key Factory key Factory =  Key Factory . get Instance ( encoded Key Algorithm ,  Sun JCE . get Instance ( ) ) ;  PKCS8 Encoded Key Spec key Spec = new  PKCS8 Encoded Key Spec ( encoded Key ) ; return key Factory . generate Private ( key Spec ) ; } catch (  No Such Algorithm Exception nsae ) { try {  Key Factory key Factory =  Key Factory . get Instance ( encoded Key Algorithm ) ;  PKCS8 Encoded Key Spec key Spec = new  PKCS8 Encoded Key Spec ( encoded Key ) ; key = key Factory . generate Private ( key Spec ) ; } catch (  No Such Algorithm Exception nsae2 ) { throw new  No Such Algorithm Exception ( _ STR + _ STR + encoded Key Algorithm + _ STR ) ; } catch (  Invalid Key Spec Exception ikse2 ) {  Invalid Key Exception ike = new  Invalid Key Exception ( _ STR ) ; ike . init Cause ( ikse2 ) ; throw ike ; } } catch (  Invalid Key Spec Exception ikse ) {  Invalid Key Exception ike = new  Invalid Key Exception ( _ STR ) ; ike . init Cause ( ikse ) ; throw ike ; } return key ; }
public final  String dump Model (  Instances data ) throws  Exception {  String Buffer text ; int i ; text = new  String Buffer ( ) ; for ( i = _ NUM ; i < m_num Subsets ; i ++ ) { text . append ( left Side ( data ) + right Side ( i , data ) + _ STR ) ; text . append ( dump Label ( i , data ) + _ STR ) ; } return text . to String ( ) ; }
@  Override public  Completable Future <  Optional <  T > > min ( final  Comparator < ? super  T > comparator ) { return  Completable Future . supply Async ( null , exec ) ; }
final public void println ( int v ) {  Writer out = this . out ; if ( out == null ) return ; print ( v ) ; try { out . write ( _newline , _ NUM , _newline . length ) ; } catch (  IOException e ) { log . log (  Level .  FINE , e . to String ( ) , e ) ; } }
public void test_restart Safe_one Write No Commit ( ) {  IAtomic Store store = (  IAtomic Store ) get Store ( ) ; try { assert True ( store . is Stable ( ) ) ; final  Random r = new  Random ( ) ; final int len = _ NUM ; final byte [ ] expected = new byte [ len ] ; r . next Bytes ( expected ) ; final  Byte Buffer tmp =  Byte Buffer . wrap ( expected ) ; final long addr1 = store . write ( tmp ) ; assert Equals ( len , tmp . position ( ) ) ; assert Equals ( tmp . position ( ) , tmp . limit ( ) ) ; final  Byte Buffer actual = store . read ( addr1 ) ; assert Equals ( expected , actual ) ; assert Equals ( _ NUM , actual . position ( ) ) ; assert Equals ( expected . length , actual . limit ( ) ) ; store = (  IAtomic Store ) reopen Store ( store ) ; assert True ( store . is Stable ( ) ) ; try { store . read ( addr1 ) ; fail ( _ STR +  Illegal Argument Exception . class ) ; } catch (  Runtime Exception ex ) { if (  Inner Cause . is Inner Cause ( ex ,  Illegal Argument Exception . class ) ) { if ( log . is Info Enabled ( ) ) log . info ( _ STR + ex ) ; } else { fail ( _ STR +  Illegal Argument Exception . class + _ STR + ex , ex ) ; } } } finally { store . destroy ( ) ; } }
public  Core Admin Handler ( final  Core Container core Container ) { this . core Container = core Container ;  Hash Map <  String ,  Map <  String ,  Task Object > > map = new  Hash Map < > ( _ NUM , _ NUM ) ; map . put (  RUNNING ,  Collections . synchronized Map ( new  Linked Hash Map <  String ,  Task Object > ( ) ) ) ; map . put (  COMPLETED ,  Collections . synchronized Map ( new  Linked Hash Map <  String ,  Task Object > ( ) ) ) ; map . put (  FAILED ,  Collections . synchronized Map ( new  Linked Hash Map <  String ,  Task Object > ( ) ) ) ; request Status Map =  Collections . unmodifiable Map ( map ) ; }
public static  String trim Leading Tabs And Spaces (  String line ) { int size = line . length ( ) ; int start = size ; for ( int i = _ NUM ; i < size ; i ++ ) { char c = line . char At ( i ) ; if ( !  Indent Manipulation . is Indent Char ( c ) ) { start = i ; break ; } } if ( start == _ NUM ) return line ; else if ( start == size ) return _ STR ; else return line . substring ( start ) ; }
@  Override public  Double DBIDList reverse KNNQuery (  DBIDRef id , int k ) {  Modifiable Double DBIDList result =  DBIDUtil . new Distance DBIDList ( ) ; final  Heap <  Generic MTree Distance Search Candidate > pq = new  Updatable Heap < > ( ) ; pq . add ( new  Generic MTree Distance Search Candidate ( _ NUM , get Root ID ( ) , null ) ) ; while ( ! pq . is Empty ( ) ) {  Generic MTree Distance Search Candidate pq Node = pq . poll ( ) ;  Mk App Tree Node <  O > node = get Node ( pq Node . node ID ) ; if ( ! node . is Leaf ( ) ) { for ( int i = _ NUM ; i < node . get Num Entries ( ) ; i ++ ) {  Mk App Entry entry = node . get Entry ( i ) ; double distance = distance ( entry . get Routing Object ID ( ) , id ) ; double min Dist = ( entry . get Covering Radius ( ) > distance ) ? _ NUM : distance - entry . get Covering Radius ( ) ; double approx Value = settings . log ?  Math . exp ( entry . approximated Value At ( k ) ) : entry . approximated Value At ( k ) ; if ( approx Value < _ NUM ) { approx Value = _ NUM ; } if ( min Dist <= approx Value ) { pq . add ( new  Generic MTree Distance Search Candidate ( min Dist , get Page ID ( entry ) , entry . get Routing Object ID ( ) ) ) ; } } } else { for ( int i = _ NUM ; i < node . get Num Entries ( ) ; i ++ ) {  Mk App Leaf Entry entry = (  Mk App Leaf Entry ) node . get Entry ( i ) ; double distance = distance ( entry . get Routing Object ID ( ) , id ) ; double approx Value = settings . log ?  Strict Math . exp ( entry . approximated Value At ( k ) ) : entry . approximated Value At ( k ) ; if ( approx Value < _ NUM ) { approx Value = _ NUM ; } if ( distance <= approx Value ) { result . add ( distance , entry . get Routing Object ID ( ) ) ; } } } } return result ; }
private static boolean is Sub Format (  String filename ) { for (  String ext :  SUB_ EXTENSIONS ) { if ( filename . contains ( _ STR + ext ) ) { return _ BOOL ; } } return _ BOOL ; }
public  String encode (  String p String ,  String charset ) throws  Unsupported Encoding Exception { if ( p String == null ) { return null ; } return new  String ( encode ( p String . get Bytes ( charset ) ) ,  String Encodings .  US_ ASCII ) ; }
public void slide ( ) { int position = _ NUM ; if ( items != null ) { position = items . size ( ) / _ NUM ; } slide ( position ) ; }
@  Override public void trace (  String msg ) { if ( logger . is Loggable (  Level .  FINEST ) ) { log (  SELF ,  Level .  FINEST , msg , null ) ; } }
private static void sort1 ( long [ ] x , int off , int len ) { if ( len < _ NUM ) { for ( int i = off ; i < len + off ; i ++ ) for ( int j = i ; j > off && x [ j - _ NUM ] > x [ j ] ; j -- ) swap ( x , j , j - _ NUM ) ; return ; } int m = off + ( len > > _ NUM ) ; if ( len > _ NUM ) { int l = off ; int n = off + len - _ NUM ; if ( len > _ NUM ) { int s = len / _ NUM ; l = med3 ( x , l , l + s , l + _ NUM * s ) ; m = med3 ( x , m - s , m , m + s ) ; n = med3 ( x , n - _ NUM * s , n - s , n ) ; } m = med3 ( x , l , m , n ) ; } long v = x [ m ] ; int a = off , b = a , c = off + len - _ NUM , d = c ; while ( _ BOOL ) { while ( b <= c && x [ b ] <= v ) { if ( x [ b ] == v ) swap ( x , a ++ , b ) ; b ++ ; } while ( c >= b && x [ c ] >= v ) { if ( x [ c ] == v ) swap ( x , c , d -- ) ; c -- ; } if ( b > c ) break ; swap ( x , b ++ , c -- ) ; } int s , n = off + len ; s =  Math . min ( a - off , b - a ) ; vecswap ( x , off , b - s , s ) ; s =  Math . min ( d - c , n - d - _ NUM ) ; vecswap ( x , b , n - s , s ) ; if ( ( s = b - a ) > _ NUM ) sort1 ( x , off , s ) ; if ( ( s = d - c ) > _ NUM ) sort1 ( x , n - s , s ) ; }
private int run ( ) { if ( cur == - _ NUM ) { return - _ NUM ; } boolean leaf = _ BOOL ; while ( _ BOOL ) { while ( cur != _ NUM ) { if ( sc [ cur ] == _ NUM ) { leaf = _ BOOL ; break ; } ns . push ( new  Item ( ( char ) cur , _ STR ) ) ; if ( sc [ cur ] == _ NUM ) { leaf = _ BOOL ; break ; } cur = lo [ cur ] ; } if ( leaf ) { break ; } cur = up ( ) ; if ( cur == - _ NUM ) { return - _ NUM ; } }  String Builder buf = new  String Builder ( ks . to String ( ) ) ; if ( sc [ cur ] == _ NUM ) { int p = lo [ cur ] ; while ( kv . get ( p ) != _ NUM ) { buf . append ( kv . get ( p ++ ) ) ; } } curkey = buf . to String ( ) ; return _ NUM ; }
static public  PVector from Angle ( float angle ,  PVector target ) { if ( target == null ) { target = new  PVector ( ( float )  Math . cos ( angle ) , ( float )  Math . sin ( angle ) , _ NUM ) ; } else { target . set ( ( float )  Math . cos ( angle ) , ( float )  Math . sin ( angle ) , _ NUM ) ; } return target ; }
@  Override public int process Image (  String name , final int data Pointer , final  Pdf Object  XObject ) throws  Pdf Exception {  String key = null ; if (  Image Commands . reject Superimposed Images ) { key = ( ( int ) gs .  CTM [ _ NUM ] [ _ NUM ] ) + _ STR + ( ( int ) gs .  CTM [ _ NUM ] [ _ NUM ] ) + _ STR + ( ( int ) gs .  CTM [ _ NUM ] [ _ NUM ] ) + _ STR + ( ( int ) gs .  CTM [ _ NUM ] [ _ NUM ] ) + _ STR + ( ( int ) gs .  CTM [ _ NUM ] [ _ NUM ] ) + _ STR + ( ( int ) gs .  CTM [ _ NUM ] [ _ NUM ] ) ; } try { if (  System . get Property ( _ STR ) == null ) { process XImage ( name , name , key ,  XObject ) ; } } catch ( final  Error e ) {  Log Writer . write Log ( _ STR + e . get Message ( ) ) ; parser Options . images Processed Fully = _ BOOL ; error Tracker . add Page Failure Message ( _ STR + e + _ STR ) ; } catch ( final  Exception e ) {  Log Writer . write Log ( _ STR + e ) ; parser Options . images Processed Fully = _ BOOL ; error Tracker . add Page Failure Message ( _ STR + e + _ STR ) ; } return data Pointer ; }
public byte [ ] embed Data ( byte [ ] msg ,  String msg File Name , byte [ ] cover ,  String cover File Name ,  String stego File Name ) throws  Open Stego Exception {  Buffered Image image = null ;  Dct LSBOutput Stream os = null ; int img Type = _ NUM ; try { if ( cover == null ) { image =  Image Util . generate Random Image ( (  DCTData Header . get Max Header Size ( ) + msg . length ) * _ NUM *  DCT .  NJPEG *  DCT .  NJPEG ) ; } else { image =  Image Util . byte Array To Image ( cover , cover File Name ) ; } img Type = image . get Type ( ) ; os = new  Dct LSBOutput Stream ( image , msg . length , msg File Name , this . config ) ; os . write ( msg ) ; os . close ( ) ; return  Image Util . image To Byte Array ( os . get Image ( img Type ) , stego File Name , this ) ; } catch (  IOException io Ex ) { throw new  Open Stego Exception ( io Ex ) ; } }
public  Creation Tool (  Figure prototype ) { this ( prototype , null , null ) ; }
static public  Automaton concatenate (  List <  Automaton > l ) {  Automaton result = new  Automaton ( ) ; for (  Automaton a : l ) { if ( a . get Num States ( ) == _ NUM ) { result . finish State ( ) ; return result ; } int num States = a . get Num States ( ) ; for ( int s = _ NUM ; s < num States ; s ++ ) { result . create State ( ) ; } } int state Offset = _ NUM ;  Transition t = new  Transition ( ) ; for ( int i = _ NUM ; i < l . size ( ) ; i ++ ) {  Automaton a = l . get ( i ) ; int num States = a . get Num States ( ) ;  Automaton next A = ( i == l . size ( ) - _ NUM ) ? null : l . get ( i + _ NUM ) ; for ( int s = _ NUM ; s < num States ; s ++ ) { int num Transitions = a . init Transition ( s , t ) ; for ( int j = _ NUM ; j < num Transitions ; j ++ ) { a . get Next Transition ( t ) ; result . add Transition ( state Offset + s , state Offset + t . dest , t . min , t . max ) ; } if ( a . is Accept ( s ) ) {  Automaton follow A = next A ; int follow Offset = state Offset ; int upto = i + _ NUM ; while ( _ BOOL ) { if ( follow A != null ) { num Transitions = follow A . init Transition ( _ NUM , t ) ; for ( int j = _ NUM ; j < num Transitions ; j ++ ) { follow A . get Next Transition ( t ) ; result . add Transition ( state Offset + s , follow Offset + num States + t . dest , t . min , t . max ) ; } if ( follow A . is Accept ( _ NUM ) ) { follow Offset += follow A . get Num States ( ) ; follow A = ( upto == l . size ( ) - _ NUM ) ? null : l . get ( upto + _ NUM ) ; upto ++ ; } else { break ; } } else { result . set Accept ( state Offset + s , _ BOOL ) ; break ; } } } } state Offset += num States ; } if ( result . get Num States ( ) == _ NUM ) { result . create State ( ) ; } result . finish State ( ) ; return result ; }
protected void compute Axis Values ( float min , float max ) { float y Min = min ; float y Max = max ; int label Count = m YAxis . get Label Count ( ) ; double range =  Math . abs ( y Max - y Min ) ; if ( label Count == _ NUM || range <= _ NUM ) { m YAxis . m Entries = new float [ ] { } ; m YAxis . m Entry Count = _ NUM ; return ; } double raw Interval = range / label Count ; double interval =  Utils . round To Next Significant ( raw Interval ) ; double interval Magnitude =  Math . pow ( _ NUM , ( int )  Math . log10 ( interval ) ) ; int interval Sig Digit = ( int ) ( interval / interval Magnitude ) ; if ( interval Sig Digit > _ NUM ) { interval =  Math . floor ( _ NUM * interval Magnitude ) ; } if ( m YAxis . is Show Only Min Max Enabled ( ) ) { m YAxis . m Entry Count = _ NUM ; m YAxis . m Entries = new float [ _ NUM ] ; m YAxis . m Entries [ _ NUM ] = y Min ; m YAxis . m Entries [ _ NUM ] = y Max ; } else { double first =  Math . ceil ( y Min / interval ) * interval ; double last =  Utils . next Up (  Math . floor ( y Max / interval ) * interval ) ; double f ; int i ; int n = _ NUM ; for ( f = first ; f <= last ; f += interval ) { ++ n ; } m YAxis . m Entry Count = n ; if ( m YAxis . m Entries . length < n ) { m YAxis . m Entries = new float [ n ] ; } for ( f = first , i = _ NUM ; i < n ; f += interval , ++ i ) { m YAxis . m Entries [ i ] = ( float ) f ; } } if ( interval < _ NUM ) { m YAxis . m Decimals = ( int )  Math . ceil ( -  Math . log10 ( interval ) ) ; } else { m YAxis . m Decimals = _ NUM ; } }
public static <  T > boolean equals ( final  Collection <  T > c1 , final  Collection <  T > c2 ) { if ( c1 == null || c2 == null ) { return c1 == c2 ; } if ( c1 . size ( ) != c2 . size ( ) ) { return _ BOOL ; } if ( c1 == c2 ) { return _ BOOL ; } if ( ! c1 . contains All ( c2 ) ) { return _ BOOL ; } return c2 . contains All ( c1 ) ; }
public boolean check Root By Super User Apk ( ) {  File su Apk = new  File (  SU_ APK ) ; if ( su Apk . exists ( ) ) { if (  Constants .  DEBUG_ MODE_ ENABLED ) {  Log . d (  TAG , _ STR ) ; } return _ BOOL ; } return _ BOOL ; }
private void create Expression Parameter List (  Filter Node node , int no Of Expressions ,  List <  Expression > parameter Filter ) { if ( no Of Expressions <= node . get Child Count ( ) ) { for ( int index = _ NUM ; index < no Of Expressions ; index ++ ) {  Expression Node expression Node = (  Expression Node ) node . get Child At ( index ) ;  Expression expression = add Expression ( expression Node ) ; parameter Filter . add ( expression ) ; } } }
public <  E extends  T >  E max (  Iterable <  E > iterable ) {  Iterator <  E > iterator = iterable . iterator ( ) ;  E max So Far = iterator . next ( ) ; while ( iterator . has Next ( ) ) { max So Far = max ( max So Far , iterator . next ( ) ) ; } return max So Far ; }
public void bind Tree (  Container ui , int defer , boolean object Lead ) { int component Count = ui . get Component Count ( ) ; for ( int iter = _ NUM ; iter < component Count ; iter ++ ) {  Component c = ui . get Component At ( iter ) ; if ( c instanceof  Container ) { bind Tree ( (  Container ) c , defer , object Lead ) ; continue ; }  String bind = c . get Cloud Bound Property ( ) ; if ( bind != null && bind . length ( ) > _ NUM ) {  String attribute Name = c . get Cloud Destination Property ( ) ; if ( attribute Name != null ) { bind Property ( c , bind , attribute Name , defer , object Lead ) ; } } } }
public boolean equals (  Object o ) { return source . equals ( o ) ; }
public void write Field ( final  String name , final long value ) throws java . io .  IOException { write Field ( name ,  Long . to String ( value ) ) ; }
private void extract Row Key And Data (  String line ,  Default Category Dataset dataset ,  List column Keys ) {  Comparable row Key = null ; int field Index = _ NUM ; int start = _ NUM ; for ( int i = _ NUM ; i < line . length ( ) ; i ++ ) { if ( line . char At ( i ) == this . field Delimiter ) { if ( field Index == _ NUM ) {  String key = line . substring ( start , i ) ; row Key = remove String Delimiters ( key ) ; } else {  Double value =  Double . value Of ( remove String Delimiters ( line . substring ( start , i ) ) ) ; dataset . add Value ( value , row Key , (  Comparable ) column Keys . get ( field Index - _ NUM ) ) ; } start = i + _ NUM ; field Index ++ ; } }  Double value =  Double . value Of ( remove String Delimiters ( line . substring ( start , line . length ( ) ) ) ) ; dataset . add Value ( value , row Key , (  Comparable ) column Keys . get ( field Index - _ NUM ) ) ; }
protected void draw Oval ( int x , int y , int w , int h ,  Color fill Color ,  Paint fill Paint ,  Color pen Color , boolean shadow ) { if ( fill Color != null || fill Paint != null ) { if ( shadow ) { g . set Color ( mx Constants .  SHADOW_ COLOR ) ; g . fill Oval ( x + mx Constants .  SHADOW_ OFFSETX , y + mx Constants .  SHADOW_ OFFSETY , w , h ) ; } if ( fill Paint != null ) { g . set Paint ( fill Paint ) ; } else { g . set Color ( fill Color ) ; } g . fill Oval ( x , y , w , h ) ; } if ( pen Color != null ) { g . set Color ( pen Color ) ; g . draw Oval ( x , y , w , h ) ; } }
Class < ? > load Class (  String class Name ,  Class Loader cl ) throws  Class Not Found Exception {  Class < ? > cls =  Class . for Name ( class Name , _ BOOL , cl ) ; return cls ; }
@  Target Api (  Build .  VERSION_ CODES .  HONEYCOMB_ MR2 ) private void show Progress ( final boolean show ) { if (  Build .  VERSION .  SDK_ INT >=  Build .  VERSION_ CODES .  HONEYCOMB_ MR2 ) { edit Container . set Visibility ( show ?  View .  GONE :  View .  VISIBLE ) ; progress Bar . set Visibility ( show ?  View .  VISIBLE :  View .  GONE ) ; } else { progress Bar . set Visibility ( show ?  View .  VISIBLE :  View .  GONE ) ; edit Container . set Visibility ( show ?  View .  GONE :  View .  VISIBLE ) ; } }
public static  String abbreviate Name (  String str ,  Font Metrics fm , int width ) { if ( fm . string Width ( str ) > width ) str = abbreviate Name ( str , _ BOOL ) ; if ( fm . string Width ( str ) > width ) str = abbreviate Name ( str , _ BOOL ) ; return str ; }
public  Accessibility Event dequeue ( ) { if ( m Event Queue . is Empty ( ) ) { return null ; } final  Accessibility Event event = m Event Queue . remove ( _ NUM ) ; if ( event != null &&  Accessibility Event Utils . event Matches Any Type ( event ,  MASK_ LIMITED_ EVENT_ TYPES ) ) { final int event Type = event . get Event Type ( ) ; final int event Count Of Type = m Qualifying Events . get ( event Type , _ NUM ) ; m Qualifying Events . put ( event Type , ( event Count Of Type - _ NUM ) ) ; } return event ; }
public void action Performed ( java . awt . event .  Action Event e ) {  String command = e . get Action Command ( ) ; if (  Debug . debugging ( _ STR ) ) {  Debug . output ( _ STR + command ) ; } if ( command ==  Layers Panel .  Layer Top Cmd || command ==  Layers Panel .  Layer Bottom Cmd || command ==  Layers Panel .  Layer Up Cmd || command ==  Layers Panel .  Layer Down Cmd || command ==  Layers Panel .  Layer Remove Cmd ) { if ( selected != null ) { if (  Debug . debugging ( _ STR ) ) {  Debug . output ( _ STR + command + _ STR + selected . get Name ( ) ) ; } fire Property Change ( command , null , selected ) ; } else { if (  Debug . debugging ( _ STR ) ) {  Debug . output ( _ STR + command + _ STR ) ; } } if ( command ==  Layers Panel .  Layer Remove Cmd ) { selected = null ; delete . set Enabled ( _ BOOL ) ; } } else if ( command . equals (  Layers Panel .  Layer Add Cmd ) ) { if ( layer Add Panel != null ) { layer Add Panel . show Panel ( ) ; } } }
public static  String to String (  Local Date data ,  String modelo ) { return data == null ? _ STR : data . format ( formatter ( modelo ) ) ; }
@  Suppress Warnings ( _ STR ) @  Json Creator public static  Client Detail Response V2 from Parts ( @  Json Property ( _ STR )  String name , @  Json Property ( _ STR )  String description , @  Json Property ( _ STR ) long created At Seconds , @  Json Property ( _ STR ) long updated At Seconds , @  Json Property ( _ STR )  String created By , @  Json Property ( _ STR )  String updated By , @  Json Property ( _ STR )  Optional <  Long > last Seen Seconds ) { return new  Auto Value_ Client Detail Response V2 ( name , description , created At Seconds , updated At Seconds , created By , updated By , last Seen Seconds ) ; }
public  Info create Info (  String value ) {  Information Field info Impl = new  Information Field ( ) ; try { info Impl . set Value ( value ) ; } catch (  Sdp Exception s ) { s . print Stack Trace ( ) ; } return info Impl ; }
public  Account Creator ( final  String username , final  String password , final  String email ) { this . username = username . trim ( ) ; this . password = password . trim ( ) ; this . email = email . trim ( ) ; }
private void add (  String world ,  Permission Holder holder ,  String permission ) { try { if ( world != null && ! world . equals ( _ STR ) ) { holder . set Permission ( permission , _ BOOL , server , world ) ; } else { holder . set Permission ( permission , _ BOOL , server ) ; } } catch (  Object Already Has Exception ignored ) { } save ( holder ) ; }
private  Cuboid (  String world Name , int x1 , int y1 , int z1 , int x2 , int y2 , int z2 ) { this . world Name = world Name ; this . x1 =  Math . min ( x1 , x2 ) ; this . x2 =  Math . max ( x1 , x2 ) ; this . y1 =  Math . min ( y1 , y2 ) ; this . y2 =  Math . max ( y1 , y2 ) ; this . z1 =  Math . min ( z1 , z2 ) ; this . z2 =  Math . max ( z1 , z2 ) ; }
private boolean vdc Properties Changed ( ) { long local Vdc Config Version = local Vdc Prop Info . get Property (  Vdc Config Util .  VDC_ CONFIG_ VERSION ) == null ? _ NUM :  Long . parse Long ( local Vdc Prop Info . get Property (  Vdc Config Util .  VDC_ CONFIG_ VERSION ) ) ; long target Vdc Config Version = target Site Info . get Vdc Config Version ( ) ; log . info ( _ STR , local Vdc Config Version , target Vdc Config Version ) ; return local Vdc Config Version != target Vdc Config Version ; }
@  Override public void open Element (  String tag Name ) {  Element new Element = document . create Element ( tag Name ) ; current . append Child ( new Element ) ; current = new Element ; }
public  Format (  String p Format String ) {  String l Format Vars [ ] = p Format String . split ( _ STR ) ; m Id =  Integer . parse Int ( l Format Vars [ _ NUM ] ) ; }
protected void dispose (  IInterval interval ) { if ( intervals == null ) { return ; } for ( int i = intervals . size ( ) - _ NUM ; i >= _ NUM ; i -- ) {  IInterval ival = intervals . get ( i ) ; if ( ( interval . get Left ( ) == ival . get Left ( ) ) && ( interval . get Right ( ) == ival . get Right ( ) ) ) { intervals . remove ( i ) ; break ; } } }
public static  String server Under Test ( ) {  String ip Address = _ STR ;  String base URL = _ STR ;  String server =  System . get Property ( _ STR ) ; if ( server == null ) { base URL =  Utils . read Config Property ( _ STR ) ; } else {  Inet Address local Machine = null ; try { local Machine =  Inet Address . get Local Host ( ) ; } catch (  Unknown Host Exception e ) { e . print Stack Trace ( ) ; } ip Address = local Machine . get Host Address ( ) ; base URL = server . replace ( _ STR , ip Address ) ; } return base URL ; }
public boolean add Main Task (  Tmm Thread Pool new Task ) { boolean result = _ BOOL ; new Task . add Listener ( this ) ; new Task . set State (  Task State .  QUEUED ) ; main Task Executor . execute ( new Task ) ; return result ; }
public  Tx Id2 Commit Time Index ( final  IRaw Store store , final  Checkpoint checkpoint , final  Index Metadata metadata , boolean read Only ) { super ( store , checkpoint , metadata , read Only ) ; }
private void do Delete Breakpoint (  Breakpoint breakpoint ) {  Breakpoint Renderer breakpoint Renderer = get Breakpoint Renderer For File ( breakpoint . get Path ( ) ) ; if ( breakpoint Renderer != null ) { breakpoint Renderer . remove Breakpoint Mark ( breakpoint . get Line Number ( ) ) ; }  String path = breakpoint . get Path ( ) ;  List <  Breakpoint > path Breakpoints = breakpoints . get ( path ) ; if ( path Breakpoints != null ) { path Breakpoints . remove ( breakpoint ) ; if ( path Breakpoints . is Empty ( ) ) { breakpoints . remove ( breakpoint . get Path ( ) ) ; } } preserve Breakpoints ( ) ; }
private void read Header ( ) throws  IOException { byte [ ] signature Bytes = new byte [ _ NUM ] ; for ( int i = _ NUM ; i < _ NUM ; i ++ ) signature Bytes [ i ] = plog Stream . read Byte ( ) ;  String stringified Header = new  String ( signature Bytes , _ STR ) ; if ( ! stringified Header . equals ( _ STR ) ) { throw new  IOException ( _ STR ) ; } int major_file_version = read Swapped Integer ( plog Stream ) ; int minor_file_version = read Swapped Integer ( plog Stream ) ; if ( major_file_version != _ NUM || minor_file_version != _ NUM ) { throw new  IOException ( _ STR + major_file_version + _ STR + minor_file_version + _ STR ) ; } logger . info ( _ STR ) ; return ; }
private void parse Last Consonant ( ) { if ( ! valid Vi Syll ) return ; if ( i Cur Pos > str Syllable . length ( ) ) str Last Consonant =  ZERO ;  String str Con = str Syllable . substring ( i Cur Pos , str Syllable . length ( ) ) ; if ( str Con . length ( ) > _ NUM ) { valid Vi Syll = _ BOOL ; return ; }  Iterator iter = al Last Consonants . iterator ( ) ; while ( iter . has Next ( ) ) {  String temp Last Con = (  String ) iter . next ( ) ; if ( str Con . equals ( temp Last Con ) ) { str Last Consonant = temp Last Con ; i Cur Pos += str Last Consonant . length ( ) ; return ; } } str Last Consonant =  ZERO ; if ( i Cur Pos >= str Syllable . length ( ) ) valid Vi Syll = _ BOOL ; else valid Vi Syll = _ BOOL ; return ; }
Information Panel ( ) { set Layout ( new  Overlay Layout ( this ) ) ;  JComponent container =  SBox Layout . create Container (  SBox Layout .  VERTICAL ) ; glass Pane = new  JComponent ( ) { } ; add ( glass Pane ) ; add ( container ) ; name Field = new  JText Pane ( ) ;  Style Constants . set Alignment ( center ,  Style Constants .  ALIGN_ CENTER ) ; name Field . set Alignment X (  CENTER_ ALIGNMENT ) ; name Field . set Opaque ( _ BOOL ) ; name Field . set Background ( get Background ( ) ) ; name Field . set Foreground (  Color .  WHITE ) ; name Field . set Focusable ( _ BOOL ) ; name Field . set Editable ( _ BOOL ) ; container . add ( name Field ,  SLayout .  EXPAND_ X ) ; danger Indicator = new  Danger Indicator (  MAX_ SKULLS ) ; danger Indicator . set Alignment X (  CENTER_ ALIGNMENT ) ; container . add ( danger Indicator ) ; describe Danger ( _ NUM ) ; }
private void remove Gaps ( int nodes Level [ ] ) { int temp = m_nodes . size ( ) ; int temp2 = graph Matrix [ _ NUM ] . length , temp Cnt = _ NUM ; for ( int n = _ NUM ; n < temp ; n ++ ) { for ( int i = _ NUM ; i < temp2 ; i ++ ) { int len = graph Matrix . length ; if ( graph Matrix [ n ] [ i ] > _ NUM ) { if ( nodes Level [ i ] > nodes Level [ n ] + _ NUM ) { int temp Matrix [ ] [ ] = new int [ graph Matrix . length + ( nodes Level [ i ] - nodes Level [ n ] - _ NUM ) ] [ graph Matrix . length + ( nodes Level [ i ] - nodes Level [ n ] - _ NUM ) ] ; int level = nodes Level [ n ] + _ NUM ; copy Matrix ( graph Matrix , temp Matrix ) ;  String s1 = new  String ( _ STR + temp Cnt ++ ) ; m_nodes . add ( new  Graph Node ( s1 , s1 ,  SINGULAR_ DUMMY ) ) ; int temp3 [ ] = new int [ node Levels [ level ] . length + _ NUM ] ;  System . arraycopy ( node Levels [ level ] , _ NUM , temp3 , _ NUM , node Levels [ level ] . length ) ; temp3 [ temp3 . length - _ NUM ] = m_nodes . size ( ) - _ NUM ; node Levels [ level ] = temp3 ; level ++ ; int k ; for ( k = len ; k < len + nodes Level [ i ] - nodes Level [ n ] - _ NUM - _ NUM ; k ++ ) {  String s2 = new  String ( _ STR + temp Cnt ) ; m_nodes . add ( new  Graph Node ( s2 , s2 ,  SINGULAR_ DUMMY ) ) ; temp3 = new int [ node Levels [ level ] . length + _ NUM ] ;  System . arraycopy ( node Levels [ level ] , _ NUM , temp3 , _ NUM , node Levels [ level ] . length ) ; temp3 [ temp3 . length - _ NUM ] = m_nodes . size ( ) - _ NUM ; node Levels [ level ++ ] = temp3 ; temp Matrix [ k ] [ k + _ NUM ] = temp Matrix [ n ] [ i ] ; temp Cnt ++ ; if ( k > len ) { temp Matrix [ k ] [ k - _ NUM ] = - _ NUM * temp Matrix [ n ] [ i ] ; } } temp Matrix [ k ] [ i ] = temp Matrix [ n ] [ i ] ; temp Matrix [ n ] [ len ] = temp Matrix [ n ] [ i ] ; temp Matrix [ len ] [ n ] = - _ NUM * temp Matrix [ n ] [ i ] ; temp Matrix [ i ] [ k ] = - _ NUM * temp Matrix [ n ] [ i ] ; if ( k > len ) { temp Matrix [ k ] [ k - _ NUM ] = - _ NUM * temp Matrix [ n ] [ i ] ; } temp Matrix [ n ] [ i ] = _ NUM ; temp Matrix [ i ] [ n ] = _ NUM ; graph Matrix = temp Matrix ; } else { graph Matrix [ i ] [ n ] = - _ NUM * graph Matrix [ n ] [ i ] ; } } } } }
public static void mute Current Out And Err Stream ( ) { if ( already Muted ) { return ; }  Byte Array Output Stream byte Stream = new  Byte Array Output Stream ( ) ;  Print Stream out Stream = new  Print Stream ( byte Stream ) ; latest Out =  System . out ; latest Err =  System . err ;  System . set Out ( out Stream ) ;  System . set Err ( out Stream ) ; already Muted = _ BOOL ; }
public synchronized void register (  Platform platform ) { check Not Null ( platform ) ; logger . log (  Level .  FINE , _ STR + platform . get Class ( ) + _ STR + super . to String ( ) + _ STR ) ; platforms . add ( platform ) ; if ( first Seen Version != null ) { if ( ! first Seen Version . equals ( platform . get Version ( ) ) ) { logger . log (  Level .  WARNING , _ STR + _ STR , new  Object [ ] { first Seen Version , platform . get Version ( ) } ) ; } } else { first Seen Version = platform . get Version ( ) ; } }
public  Action Request Helper depends On (  Action Request Helper dependency , boolean terminate On Failure ) { dependency . terminate On Failure ( terminate On Failure ) ; m Dependencies . add ( dependency ) ; return this ; }
static boolean is Big Integer (  Object obj ) { return obj instanceof  Big Integer && obj . get Class ( ) ==  Big Integer . class ; }
public static void to Xml ( final  Config to Convert , final  Output Stream stream ,  Boolean pretty Xml ) throws  JAXBException {  Marshaller var Marshaller = get Marshaller ( pretty Xml ) ; var Marshaller . marshal ( to Convert , stream ) ; }
protected  Vector2 D [ ] create Triangle Vertices ( float triangle Size ) {  Vector2 D [ ] p = new  Vector2 D [ _ NUM ] ; double f ; f = _ NUM *  Math .  PI / _ NUM ; p [ _ NUM ] = new  Vector2 D ( triangle Size *  Math . sin ( f ) , triangle Size *  Math . cos ( f ) ) ; f = _ NUM *  Math .  PI / _ NUM ; p [ _ NUM ] = new  Vector2 D ( triangle Size *  Math . sin ( f ) , triangle Size *  Math . cos ( f ) ) ; f = _ NUM *  Math .  PI / _ NUM ; p [ _ NUM ] = new  Vector2 D ( triangle Size *  Math . sin ( f ) , triangle Size *  Math . cos ( f ) ) ; return p ; }
private void heapify Up ( int twopos ,  Comparable <  Object > cur ) { while ( twopos > _ NUM ) { final int parent = ( twopos - _ NUM ) > > > _ NUM ;  Comparable <  Object > par = twoheap [ parent ] ; if ( cur . compare To ( par ) >= _ NUM ) { break ; } twoheap [ twopos ] = par ; twopos = parent ; } twoheap [ twopos ] = cur ; }
public void insert (  String key , char val ) { int len = key . length ( ) + _ NUM ; if ( freenode + len > eq . length ) { redim Node Arrays ( eq . length +  BLOCK_ SIZE ) ; } char [ ] strkey = new char [ len -- ] ; key . get Chars ( _ NUM , len , strkey , _ NUM ) ; strkey [ len ] = _ NUM ; root = insert ( root , strkey , _ NUM , val ) ; }
void write (  Environment env ,  Data Output Stream out ,  Constant Pool tab ) throws  IOException { out . write Byte (  CONSTANT_ CLASS ) ; out . write Short ( tab . index ( name ) ) ; }
public void initialize Properties (  Properties properties ) {  Properties new Props = new  Properties ( ) ; new Props . put All ( system Config Props ) ; new Props . put All ( properties ) ; system Config Props = new Props ; }
public void fire Synapses Updated ( ) { for (  Network Listener listener : network Listeners ) { listener . update Synapses ( ) ; } }
public static void append Content Prefix (  Http Servlet Request request ,  String Builder url Buffer ) { try { append Content Prefix ( request , (  Appendable ) url Buffer ) ; } catch (  IOException e ) { throw  Util Misc . init Cause ( new  Internal Error ( e . get Message ( ) ) , e ) ; } }
public void remove Error Listener ( final  Error Listener error Listener ) { if ( error Listeners != null ) { error Listeners . remove ( error Listener ) ; } }
public  Java Class Writer (  String output Folder ,  String class Name ) throws  File Not Found Exception { if ( class Name . index Of ( _ STR ) > - _ NUM ) { throw new  File Not Found Exception ( _ STR + class Name ) ; } this . out = new  Print Stream ( new  File Output Stream ( output Folder + _ STR + class Name + _ STR ) ) ; this . class Name = class Name ; }
public static void import Expression Types ( final  CConnection connection , final int raw Module Id , final int module Id ) throws  SQLException { final  String query = _ STR +  CTable Names .  EXPRESSION_ TYPES_ TABLE + _ STR + module Id + _ STR + _ STR +  String . format (  CTable Names .  RAW_ EXPRESSION_ TYPES_ TABLE , raw Module Id ) ; connection . execute Update ( query , _ BOOL ) ; }
public  Object read Cost Matrix Old (  Element node ) throws  Exception { weka . classifiers .  Cost Matrix matrix ; weka . core . matrix .  Matrix matrix New ;  String Writer writer ; if (  DEBUG ) { trace ( new  Throwable ( ) , node . get Attribute (  ATT_ NAME ) ) ; } m_ Current Node = node ; matrix New = ( weka . core . matrix .  Matrix ) read Matrix ( node ) ; writer = new  String Writer ( ) ; matrix New . write ( writer ) ; matrix = new weka . classifiers .  Cost Matrix ( new  String Reader ( writer . to String ( ) ) ) ; return matrix ; }
public void record Volume Operation (  Db Client db Client ,  Operation Type Enum op Type ,  Operation .  Status status ,  Object ... ext Param ) { try { boolean op Status = (  Operation .  Status . ready == status ) ? _ BOOL : _ BOOL ;  String ev Type ; ev Type = op Type . get Ev Type ( op Status ) ;  String ev Desc = op Type . get Description ( ) ;  String op Stage =  Audit Log Manager .  AUDITOP_ END ; _logger . info ( _ STR , op Type . to String ( ) , ev Type . to String ( ) + _ STR + ev Desc ) ;  URI uri = (  URI ) ext Param [ _ NUM ] ; record Bourne Volume Event ( db Client , ev Type , status , ev Desc , uri ) ;  String id = uri . to String ( ) ;  Audit Block Util . audit Block ( db Client , op Type , op Status , op Stage , id ) ; } catch (  Exception e ) { _logger . error ( _ STR , op Type . to String ( ) , e ) ; } }
public  Core Token Exception ( int error Code ,  Throwable cause ) { super ( cause ) ; this . error Code = error Code ; this . message = get Localized Message (  Locale . get Default ( ) ) ; }
public  DView Certificate (  Window parent ,  String title ,  X509 Certificate [ ] certs ,  Kse Frame kse Frame , int import Export ) throws  Crypto Exception { super ( parent , title ,  Dialog .  Modality Type .  DOCUMENT_ MODAL ) ; this . kse Frame = kse Frame ; this . import Export = import Export ; init Components ( certs ) ; }
private  String validate Super Dev Mode Linker Exists (  IJava Project java Project ,  ILaunch Configuration configuration ) { try {  List <  String > modules =  GWTLaunch Configuration Working Copy . get Entry Point Modules ( configuration ) ; if ( modules == null || modules . is Empty ( ) ) { return  ERROR_ NO_ LINKER ; }  List <  String > errors = new  Array List <  String > ( ) ; for (  String module : modules ) {  IModule imodule =  Module Utils . find Module ( java Project , module , _ BOOL ) ; if ( imodule != null ) {  String error = validate Module ( imodule , java Project , configuration ) ; if ( error != null ) { errors . add ( error ) ; } } } if ( errors . size ( ) > _ NUM ) { return  String Utilities . join ( errors , _ STR ) ; } } catch (  Core Exception e ) { return  ERROR_ NO_ LINKER ; } return null ; }
private static  String normalize Helper (  String number ,  Map <  Character ,  Character > normalization Replacements , boolean remove Non Matches ) {  String Builder normalized Number = new  String Builder ( number . length ( ) ) ; for ( int i = _ NUM ; i < number . length ( ) ; i ++ ) { char character = number . char At ( i ) ;  Character new Digit = normalization Replacements . get (  Character . to Upper Case ( character ) ) ; if ( new Digit != null ) { normalized Number . append ( new Digit ) ; } else if ( ! remove Non Matches ) { normalized Number . append ( character ) ; } } return normalized Number . to String ( ) ; }
private int [ ] do Union ( int [ ] c2 ) { int [ ] result = new int [ chars . length + c2 . length ] ; int i = _ NUM ; int j = _ NUM ; int index = _ NUM ; while ( i < chars . length && j < c2 . length ) { int ub ; if ( chars [ i ] < c2 [ j ] ) { result [ index ++ ] = chars [ i ] ; ub = chars [ ++ i ] ; } else { result [ index ++ ] = c2 [ j ] ; ub = c2 [ ++ j ] ; } while ( i % _ NUM == _ NUM || j % _ NUM == _ NUM || ( i < chars . length && chars [ i ] <= ub + _ NUM ) ) { while ( i < chars . length && chars [ i ] <= ub + _ NUM ) { ++ i ; } if ( i % _ NUM == _ NUM ) { ub = chars [ i ] ; } else if ( i > _ NUM && chars [ i - _ NUM ] > ub ) { ub = chars [ i - _ NUM ] ; } while ( j < c2 . length && c2 [ j ] <= ub + _ NUM ) { ++ j ; } if ( j % _ NUM == _ NUM ) { ub = c2 [ j ] ; } else if ( j > _ NUM && c2 [ j - _ NUM ] > ub ) { ub = c2 [ j - _ NUM ] ; } } result [ index ++ ] = ub ; } if ( i < chars . length ) { for ( int k = i ; k < chars . length ; k ++ ) { result [ index ++ ] = chars [ k ] ; } } if ( j < c2 . length ) { for ( int k = j ; k < c2 . length ; k ++ ) { result [ index ++ ] = c2 [ k ] ; } } if ( result . length > index ) { int [ ] tmpbuf = new int [ index ] ;  System . arraycopy ( result , _ NUM , tmpbuf , _ NUM , index ) ; return tmpbuf ; } return result ; }
public void remove Sub Config (  String sub Config Name ) throws  SMSException ,  SSOException { validate Service Config Impl ( ) ; sub Config Name =  SMSSchema . unescape Name ( sub Config Name ) ;  String sdn = _ STR + sub Config Name + _ STR + sc . get DN ( ) ;  Service Config Manager Impl scm Impl =  Service Config Manager Impl . get Instance ( token , get Service Name ( ) , get Version ( ) ) ;  Service Config Impl s Config Impl = sc . get Sub Config ( token , sub Config Name ) ; if ( s Config Impl != null ) {  Service Config Impl . delete Instance ( token , scm Impl , null , sdn , _ STR , s Config Impl . get Group Name ( ) , ( get Component Name ( ) + _ STR +  SMSSchema . escape Special Characters ( sub Config Name ) ) , _ BOOL , ss ) ; }  Cached SMSEntry c Entry =  Cached SMSEntry . get Instance ( token , sdn ) ; if ( c Entry . is Dirty ( ) ) { c Entry . refresh ( ) ; }  SMSEntry entry = c Entry . get Cloned SMSEntry ( ) ; entry . delete ( token ) ; c Entry . refresh ( entry ) ;  Cached Sub Entries cse =  Cached Sub Entries . get Instance ( token , sc . get DN ( ) ) ; cse . remove ( sub Config Name ) ; }
public void add Group Listener ( final  Group Listener listener ) { group Listeners . add ( listener ) ; }
public void write Task Container Mapping (  String task Name ,  Integer container Id ) {  Integer existing Container Id = task Name To Container Id . get ( task Name ) ; if ( existing Container Id != null && ! existing Container Id . equals ( container Id ) ) { log . info ( _ STR , new  Object [ ] { task Name , existing Container Id , container Id } ) ; } else { log . debug ( _ STR , task Name , container Id ) ; } if ( container Id == null ) { send ( new  Delete ( get Source ( ) , task Name ,  Set Task Container Mapping .  TYPE ) ) ; task Name To Container Id . remove ( task Name ) ; } else { send ( new  Set Task Container Mapping ( get Source ( ) , task Name ,  String . value Of ( container Id ) ) ) ; task Name To Container Id . put ( task Name , container Id ) ; } }
@  Override public  Solr Info MBean put (  String key ,  Solr Info MBean info Bean ) { if ( server != null && info Bean != null ) { try {  Object Name name = get Object Name ( key , info Bean ) ; if ( server . is Registered ( name ) ) server . unregister MBean ( name ) ;  Solr Dynamic MBean mbean = new  Solr Dynamic MBean ( core Hash Code , info Bean , use Cached Stats Between Get MBean Info Calls ) ; server . register MBean ( mbean , name ) ; } catch (  Exception e ) { log . warn ( _ STR + key , e ) ; } } return super . put ( key , info Bean ) ; }
@  Suppress Warnings ( _ STR ) public static <  E > void transform String Collection (  Collection <  String > original ,  Collection <  E > collection ,  Class <  E > element Class ) throws  Preference Exception {  Method parse Method = find Parse Method ( element Class ) ; if ( null != parse Method ) { for (  String to Transform : original ) { try {  Object transformed = parse Method . invoke ( null , to Transform ) ; if ( element Class . is Assignable From ( transformed . get Class ( ) ) ) { collection . add ( (  E ) transformed ) ; } } catch (  Exception e ) { throw new  Preference Exception ( _ STR + element Class . get Name ( ) + _ STR , e ) ; } } } else { throw new  Preference Exception ( _ STR + element Class . get Name ( ) + _ STR + element Class . get Name ( ) + _ STR ) ; } }
protected void check Params (  XCreate Window Params params ) { if ( params == null ) { throw new  Illegal Argument Exception ( _ STR ) ; } params . put If Null (  PARENT_ WINDOW ,  Long . value Of (  XToolkit . get Default Root Window ( ) ) ) ; params . put If Null (  BOUNDS , new  Rectangle (  DEF_ LOCATION ,  DEF_ LOCATION ,  MIN_ SIZE ,  MIN_ SIZE ) ) ; params . put If Null (  DEPTH ,  Integer . value Of ( ( int )  XConstants .  Copy From Parent ) ) ; params . put If Null (  VISUAL ,  Long . value Of (  XConstants .  Copy From Parent ) ) ; params . put If Null (  VISUAL_ CLASS ,  Integer . value Of ( ( int )  XConstants .  Input Only ) ) ; params . put If Null (  VALUE_ MASK ,  Long . value Of (  XConstants .  CWEvent Mask ) ) ;  Rectangle bounds = (  Rectangle ) params . get (  BOUNDS ) ; bounds . width =  Math . max (  MIN_ SIZE , bounds . width ) ; bounds . height =  Math . max (  MIN_ SIZE , bounds . height ) ;  Long event Mask Obj = (  Long ) params . get (  EVENT_ MASK ) ; long event Mask = event Mask Obj != null ? event Mask Obj . long Value ( ) : _ NUM ; event Mask |=  XConstants .  Property Change Mask |  XConstants .  Owner Grab Button Mask ; params . put (  EVENT_ MASK ,  Long . value Of ( event Mask ) ) ; }
public  Component Manager ( ) { gral Components = new  Sequence Collection ( ) ; gral Seeds =  Collections . unmodifiable Set (  Collections . <  Sequence > empty Set ( ) ) ; }
public static boolean requires Unsynchronization ( byte [ ] aby Source ) { for ( int i = _ NUM ; i < aby Source . length - _ NUM ; i ++ ) { if ( ( ( aby Source [ i ] &  MPEGFrame Header .  SYNC_ BYTE1 ) ==  MPEGFrame Header .  SYNC_ BYTE1 ) && ( ( aby Source [ i + _ NUM ] &  MPEGFrame Header .  SYNC_ BYTE2 ) ==  MPEGFrame Header .  SYNC_ BYTE2 ) ) { if ( logger . is Loggable (  Level .  FINEST ) ) { logger . finest ( _ STR + i ) ; } return _ BOOL ; } } return _ BOOL ; }
final static  String  HMAC_ MD5 ( byte [ ] key , byte [ ] text ) throws  No Such Algorithm Exception {  Message Digest md5 =  Message Digest . get Instance ( _ STR ) ; if ( key . length >  MD5_ BLOCKSIZE ) { key = md5 . digest ( key ) ; } byte [ ] ipad = new byte [  MD5_ BLOCKSIZE ] ; byte [ ] opad = new byte [  MD5_ BLOCKSIZE ] ; byte [ ] digest ; int i ; for ( i = _ NUM ; i < key . length ; i ++ ) { ipad [ i ] = key [ i ] ; opad [ i ] = key [ i ] ; } for ( i = _ NUM ; i <  MD5_ BLOCKSIZE ; i ++ ) { ipad [ i ] ^= _ NUM ; opad [ i ] ^= _ NUM ; } md5 . update ( ipad ) ; md5 . update ( text ) ; digest = md5 . digest ( ) ; md5 . update ( opad ) ; md5 . update ( digest ) ; digest = md5 . digest ( ) ;  String Buffer digest String = new  String Buffer ( ) ; for ( i = _ NUM ; i < digest . length ; i ++ ) { if ( ( digest [ i ] & _ NUM ) < _ NUM ) { digest String . append ( _ STR +  Integer . to Hex String ( digest [ i ] & _ NUM ) ) ; } else { digest String . append (  Integer . to Hex String ( digest [ i ] & _ NUM ) ) ; } }  Arrays . fill ( ipad , ( byte ) _ NUM ) ;  Arrays . fill ( opad , ( byte ) _ NUM ) ; ipad = null ; opad = null ; return ( digest String . to String ( ) ) ; }
public  Extractor ( final  Logger logger ) { this . logger = logger ; pdf Config . set Extract Inline Images ( _ BOOL ) ; pdf Config . set Extract Unique Inline Images Only ( _ BOOL ) ; ocr Config . set Timeout (  Math . to Int Exact (  DEFAULT_ OCR_ TIMEOUT . to (  Time Unit .  SECONDS ) ) ) ; }
public static final byte [ ] inflate ( byte [ ] in ) throws  IOException {  Byte Array Output Stream out Stream = new  Byte Array Output Stream (  EXPECTED_ COMPRESSION_ RATIO * in . length ) ;  Inflater Input Stream in Stream = new  Inflater Input Stream ( new  Byte Array Input Stream ( in ) ) ; byte [ ] buf = new byte [  BUF_ SIZE ] ; while ( _ BOOL ) { int size = in Stream . read ( buf ) ; if ( size <= _ NUM ) break ; out Stream . write ( buf , _ NUM , size ) ; } out Stream . close ( ) ; return out Stream . to Byte Array ( ) ; }
public static <  T > void add First Item (  JCombo Box <  T > combobox ,  T item ) { int idx = - _ NUM ;  Default Combo Box Model <  T > model = (  Default Combo Box Model <  T > ) combobox . get Model ( ) ; for ( int i = _ NUM ; i < model . get Size ( ) ; i ++ ) {  T t = model . get Element At ( i ) ; if (  Objects . equals ( t , item ) ) { idx = i ; break ; } } model . insert Element At ( item , _ NUM ) ; if ( idx >= _ NUM ) { model . remove Element At ( idx + _ NUM ) ; } }
@  Override public boolean is Valid Row (  Map <  String ,  Object > row ) { if ( ! row . contains Key ( column ) ) { return _ BOOL ; }  Matcher match = pattern . matcher ( (  Char Sequence ) row . get ( column ) ) ; return match . find ( ) ; }
public void test_huffman Codec Stress ( ) { final int ntrials = _ NUM ; final  Random r = new  Random ( ) ; for ( int trial = _ NUM ; trial < ntrials ; trial ++ ) { final int [ ] frequency = new int [ r . next Int ( _ NUM ) + _ NUM ] ; for ( int i = _ NUM ; i < frequency . length ; i ++ ) { if ( r . next Float ( ) < _ NUM ) { frequency [ i ] = _ NUM ; } else { frequency [ i ] = r . next Int ( _ NUM ) ; } } do Round Trip Test ( frequency ) ; } }
public  Set <  String > key Set ( ) { synchronized ( mutex ) { return  Collections . unmodifiable Set ( estimated Data . key Set ( ) ) ; } }
public static int [ ] create Normalized Map ( int [ ] values , byte [ ] levels , int start , int limit ) { if ( values != null ) { if ( start != _ NUM || limit != values . length ) { boolean copy Range , canonical ; byte primary Level ; if ( levels == null ) { primary Level = ( byte ) _ NUM ; copy Range = _ BOOL ; canonical = _ BOOL ; } else { if ( levels [ start ] == levels [ limit - _ NUM ] ) { primary Level = levels [ start ] ; canonical = ( primary Level & ( byte ) _ NUM ) == _ NUM ; int i ; for ( i = start ; i < limit ; i ++ ) { if ( levels [ i ] < primary Level ) { break ; } if ( canonical ) { canonical = levels [ i ] == primary Level ; } } copy Range = ( i == limit ) ; } else { copy Range = _ BOOL ; primary Level = ( byte ) _ NUM ; canonical = _ BOOL ; } } if ( copy Range ) { if ( canonical ) { return null ; } int [ ] result = new int [ limit - start ] ; int base Value ; if ( ( primary Level & ( byte ) _ NUM ) != _ NUM ) { base Value = values [ limit - _ NUM ] ; } else { base Value = values [ start ] ; } if ( base Value == _ NUM ) {  System . arraycopy ( values , start , result , _ NUM , limit - start ) ; } else { for ( int j = _ NUM ; j < result . length ; j ++ ) { result [ j ] = values [ j + start ] - base Value ; } } return result ; } else { return compute Contiguous Order ( values , start , limit ) ; } } else { return values ; } } return null ; }
@  Suppress Warnings ( _ STR ) public  Composite Transaction Adaptor (  Stack <  Composite Transaction > lineage ,  String tid , boolean serial ,  Recovery Coordinator adaptor ) { super ( tid , (  Stack <  Composite Transaction > ) lineage . clone ( ) , serial ) ; adaptor For Replay Requests_ = adaptor ;  Stack <  Composite Transaction > tmp = (  Stack <  Composite Transaction > ) lineage . clone ( ) ;  Composite Transaction parent = null ; while ( ! tmp . empty ( ) ) { parent = tmp . pop ( ) ; } root_ = parent . get Tid ( ) ; }
public  Minecraft Directory (  File root Dir ) {  Objects . require Non Null ( root Dir ) ; this . root Dir = root Dir . get Absolute File ( ) ; }
public static  String to Json ( final  Object object , final boolean indent ) { final  String Builder s = new  String Builder ( ) ; encode ( s , object , indent , indent ? _ NUM : - _ NUM ) ; return s . to String ( ) ; }
public static void clear Time Of Day (  Calendar calendar ) { calendar . set (  Calendar .  MILLISECOND , _ NUM ) ; calendar . set (  Calendar .  SECOND , _ NUM ) ; calendar . set (  Calendar .  MINUTE , _ NUM ) ; calendar . set (  Calendar .  HOUR_ OF_ DAY , _ NUM ) ; }
public static  String cut Surrounding (  String string ,  String prefix ,  String suffix ) { int start = _ NUM ; int end = string . length ( ) ; if ( string . starts With ( prefix ) ) { start = prefix . length ( ) ; } if ( string . ends With ( suffix ) ) { end -= suffix . length ( ) ; } return string . substring ( start , end ) ; }
public void compute Ring ( ) { if ( ring != null ) return ;  Coordinate [ ] coord = new  Coordinate [ pts . size ( ) ] ; for ( int i = _ NUM ; i < pts . size ( ) ; i ++ ) { coord [ i ] = (  Coordinate ) pts . get ( i ) ; } ring = geometry Factory . create Linear Ring ( coord ) ; is Hole =  CGAlgorithms . is CCW ( ring . get Coordinates ( ) ) ; }
public static  String remove Trailing Zeros ( final  String str ) {  String result = str ; if ( str != null && str . length ( ) != _ NUM ) { int end Index = str . length ( ) ; while ( end Index > _ NUM ) { final char ch = str . char At ( end Index - _ NUM ) ; if ( ch != _ STR ) { break ; } end Index -- ; } if ( end Index < str . length ( ) ) { result = str . substring ( _ NUM , end Index ) ; } } return result ; }
private void step With Timeout (  Any Kind Of Step step , int isolate Id ) throws  Player Debug Exception { int timeout = m_session . get Preference (  Session Manager .  PREF_ RESPONSE_ TIMEOUT ) ; long timeout Time =  System . current Time Millis ( ) + timeout ; step . step ( ) ;  Isolate Session worker Session = m_session . get Worker Session ( isolate Id ) ; while (  System . current Time Millis ( ) < timeout Time && ! worker Session . is Suspended ( ) ) { process Events ( ) ; if ( ! m_session . is Suspended ( ) ) { try {  Thread . sleep ( _ NUM ) ; } catch (  Interrupted Exception e ) { } } } if (  System . current Time Millis ( ) >= timeout Time && ! worker Session . is Suspended ( ) ) throw new  No Response Exception ( timeout ) ; }
public  Cipher Parameters encrypt ( byte [ ] out , int key Len ) { return encrypt ( out , _ NUM , key Len ) ; }
public static void delete Umpty Folders In Folder (  File folder ) { if ( folder . is File ( ) ) return ; if ( folder . list Files ( ) == null || folder . list Files ( ) . length <= _ NUM ) { folder . delete ( ) ; } else { for (  File f : folder . list Files ( ) ) { if ( f . is Directory ( ) ) delete Umpty Folders In Folder ( f ) ; } } if ( folder . list Files ( ) == null || folder . list Files ( ) . length <= _ NUM ) {  Logger . append Log ( _ STR + folder . get Absolute Path ( ) ) ; folder . delete ( ) ; } }
public static byte [ ] hash ( byte [ ] input ) { if ( input != null ) { final  Message Digest digest ; try { digest =  Message Digest . get Instance ( _ STR ) ; byte [ ] hashed Bytes = input ; digest . update ( hashed Bytes , _ NUM , hashed Bytes . length ) ; return hashed Bytes ; } catch (  No Such Algorithm Exception e ) {  Log . e (  TAG , _ STR + input + _ STR + e . get Message ( ) , e ) ; } } else {  Log . w (  TAG , _ STR ) ; } return null ; }
public static  Network lookup Network Full (  Db Client db Client ,  Storage Protocol .  Transport transport Type ,  String endpoint ) { _log . info (  String . format ( _ STR , transport Type . name ( ) , endpoint ) ) ; try { return  Network Util . get Endpoint Network ( endpoint , db Client ) ; } catch (  Database Exception e ) { _log . error ( _ STR , endpoint ) ; } _log . info ( _ STR ) ; return null ; }
public void test Add Security Constraint ( ) throws  Exception {  String xml =  WEBAPP_ TEST_ HEADER + _ STR ;  Web Xml web Xml =  Web Xml Io . parse Web Xml ( new  Byte Array Input Stream ( xml . get Bytes ( _ STR ) ) , get Entity Resolver ( ) ) ;  Web Xml Utils . add Security Constraint ( web Xml , _ STR , _ STR ,  Collections .  EMPTY_ LIST ) ; assert True (  Web Xml Utils . has Security Constraint ( web Xml , _ STR ) ) ; }
@  Override public boolean equals (  Object obj ) { if ( this == obj ) { return _ BOOL ; } if ( ( null == obj ) || ( get Class ( ) != obj . get Class ( ) ) ) { return _ BOOL ; } final  ECMInfo other = (  ECMInfo ) obj ; return  Objects . equals ( owner , other . owner ) &&  Objects . equals ( pos , other . pos ) && ( strength == other . strength ) && ( angel Strength == other . angel Strength ) && ( eccm Strength == other . eccm Strength ) && ( angel ECCMStrength == other . angel ECCMStrength ) && ( is ECMNova == other . is ECMNova ) && ( range == other . range ) ; }
@  Override public void debug (  String msg ,  Throwable t ) { if ( logger . is Loggable (  Level .  FINE ) ) { log (  SELF ,  Level .  FINE , msg , t ) ; } }
public void remove Event Listener (  SIPDialog Event Listener old Listener ) { event Listeners . remove ( old Listener ) ; }
public static  String add Properties To URI (  URI uri ,  Map <  String ,  String > properties ) throws  Exception { return add Properties To URI ( uri . to String ( ) , properties ) ; }
@  Not Null public static  SQFCommand Expression create Private Decl From Existing ( @  Not Null  Project project , @  Not Null  SQFPrivate Decl decl , @  Not Null  String ... var Names ) {  List <  SQFPrivate Decl Var > decl Vars = decl . get Private Vars ( ) ;  String text = _ STR ; for (  SQFPrivate Decl Var decl Var : decl Vars ) { text += _ STR + decl Var . get Var Name ( ) + _ STR ; } for ( int i = _ NUM ; i < var Names . length ; i ++ ) { text += _ STR + var Names [ i ] + ( i != var Names . length - _ NUM ? _ STR : _ STR ) ; } return (  SQFCommand Expression ) create Element ( project , text ,  SQFTypes .  COMMAND_ EXPRESSION ) ; }
private void handle Json Report Response ( final  Client Request Report report , final  Client Request Report Listener report Listener ) { if ( report Listener == null ) {  LOGGER . debug ( _ STR ) ; return ; } if ( report . is Error Report ( ) ) {  LOGGER . debug ( _ STR ) ; report Listener . on Error Report Received ( (  Client Request Error Report ) report ) ; throw new  Runtime Exception ( _ STR + report . get Error Message ( ) ) ; } else if ( report . is Progress Report ( ) ) {  LOGGER . debug ( _ STR ) ; report Listener . on Progress Report Received ( (  Client Request Progress Report ) report ) ; } else  LOGGER . warn ( _ STR ) ; }
public static boolean starts With ( char s [ ] , int len ,  String prefix ) { final int prefix Len = prefix . length ( ) ; if ( prefix Len > len ) return _ BOOL ; for ( int i = _ NUM ; i < prefix Len ; i ++ ) if ( s [ i ] != prefix . char At ( i ) ) return _ BOOL ; return _ BOOL ; }
private void parse Create Column (  Table Builder Kraken factory ,  String name ) {  Token token ; if ( ( token = scan Token ( ) ) !=  Token .  IDENTIFIER ) { throw error (  L . l ( _ STR , token ) ) ; }  String type = _lexeme ; int length = - _ NUM ; int scale = - _ NUM ; if ( type . equals Ignore Case ( _ STR ) ) { if ( ( token = peek Token ( ) ) ==  Token .  IDENTIFIER ) { scan Token ( ) ; if ( _lexeme . equals Ignore Case ( _ STR ) ) { } else throw error (  L . l ( _ STR , _lexeme ) ) ; } } if ( ( token = peek Token ( ) ) ==  Token .  LPAREN ) { scan Token ( ) ; if ( ( token = scan Token ( ) ) !=  Token .  INTEGER ) { throw error ( _ STR , token ) ; } length =  Integer . parse Int ( _lexeme ) ; if ( ( token = scan Token ( ) ) ==  Token .  COMMA ) { if ( ( token = scan Token ( ) ) !=  Token .  INTEGER ) { throw error ( _ STR , token ) ; } scale =  Integer . parse Int ( _lexeme ) ; token = scan Token ( ) ; } if ( token !=  Token .  RPAREN ) { throw error ( _ STR , token ) ; } } if ( type . equals Ignore Case ( _ STR ) ) { factory . add Varchar ( name , length ) ; } else if ( type . equals Ignore Case ( _ STR ) ) { factory . add Blob ( name ) ; } else if ( type . equals Ignore Case ( _ STR ) ) { factory . add String ( name ) ; } else if ( type . equals Ignore Case ( _ STR ) ) { factory . add Object ( name ) ; } else if ( type . equals Ignore Case ( _ STR ) ) { length =  Math . max ( length , _ NUM ) ; factory . add Varchar ( name , length ) ; } else if ( type . equals Ignore Case ( _ STR ) ) { if ( length < _ NUM ) { throw error ( _ STR ) ; } factory . add Varbinary ( name , length ) ; } else if ( type . equals Ignore Case ( _ STR ) || type . equals Ignore Case ( _ STR ) ) { if ( length < _ NUM ) throw error (  L . l ( _ STR ) ) ; factory . add Bytes ( name , length ) ; } else if ( type . equals Ignore Case ( _ STR ) ) { factory . add Varchar ( name , _ NUM ) ; } else if ( type . equals Ignore Case ( _ STR ) ) { factory . add Varchar ( name , _ NUM ) ; } else if ( type . equals Ignore Case ( _ STR ) || type . equals Ignore Case ( _ STR ) ) { factory . add Bool ( name ) ; } else if ( type . equals Ignore Case ( _ STR ) || type . equals Ignore Case ( _ STR ) || type . equals Ignore Case ( _ STR ) ) { factory . add Int8 ( name ) ; } else if ( type . equals Ignore Case ( _ STR ) || type . equals Ignore Case ( _ STR ) ) { factory . add Int16 ( name ) ; } else if ( type . equals Ignore Case ( _ STR ) || type . equals Ignore Case ( _ STR ) || type . equals Ignore Case ( _ STR ) || type . equals Ignore Case ( _ STR ) ) { factory . add Int32 ( name ) ; } else if ( type . equals Ignore Case ( _ STR ) || type . equals Ignore Case ( _ STR ) || type . equals Ignore Case ( _ STR ) ) { factory . add Int64 ( name ) ; } else if ( type . equals Ignore Case ( _ STR ) || type . equals Ignore Case ( _ STR ) || type . equals Ignore Case ( _ STR ) ) { factory . add Double ( name ) ; } else if ( type . equals Ignore Case ( _ STR ) || type . equals Ignore Case ( _ STR ) ) { factory . add Float ( name ) ; } else if ( type . equals Ignore Case ( _ STR ) || type . equals Ignore Case ( _ STR ) ) { factory . add Date Time ( name ) ; } else if ( type . equals Ignore Case ( _ STR ) || type . equals Ignore Case ( _ STR ) ) { factory . add Varchar ( name , _ NUM ) ; } else if ( type . equals Ignore Case ( _ STR ) ) { factory . add Identity ( name ) ; } else throw error (  L . l ( _ STR , type ) ) ; while ( _ BOOL ) { token = scan Token ( ) ; switch ( token ) { case  RPAREN : case  COMMA : _token = token ; return ; case  PRIMARY : token = scan Token ( ) ; if ( token !=  Token .  KEY ) throw error ( _ STR , token ) ; factory . set Primary Key ( name ) ; break ; case  NULL : break ; case  NOT : if ( ( token = scan Token ( ) ) ==  Token .  NULL ) factory . set Not Null ( name ) ; else throw error ( _ STR , token ) ; break ; default : throw error ( _ STR , token ) ; } } }
public boolean fire Map Mouse Pressed (  Mouse Event evt ) { if (  DEBUG ) { logger . fine ( _ STR ) ; } boolean consumed = _ BOOL ; if (  DEBUG ) { logger . fine ( _ STR + ( proxy != null ) + _ STR + evt . is Shift Down ( ) + _ STR ) ; } if ( proxy == null || evt . is Shift Down ( ) || ( proxy Distribution Mask &  PROXY_ DISTRIB_ MOUSE_ PRESSED ) > _ NUM ) { evt = new  Map Mouse Event ( get Parent Mode ( ) , evt ) ; if (  DEBUG && proxy != null && evt . is Shift Down ( ) ) { logger . fine ( _ STR ) ; }  Iterator <  Map Mouse Listener > it = iterator ( ) ; while ( it . has Next ( ) && ! consumed ) {  Map Mouse Listener target = it . next ( ) ; consumed = target . mouse Pressed ( evt ) && consume Events ; if ( consumed ) { priority Listener = target ; } } } boolean ignore Consumed = ! consumed || ( consumed && ( ( proxy Distribution Mask &  PROXY_ ACK_ CONSUMED_ MOUSE_ PRESSED ) == _ NUM ) ) ; if ( proxy != null && ignore Consumed && ! evt . is Shift Down ( ) ) { proxy . mouse Pressed ( evt ) ; consumed = _ BOOL ; } else { if (  DEBUG && evt . is Shift Down ( ) ) { logger . fine ( _ STR ) ; } } return consumed ; }
private static  String descriptor From Proto Array (  String [ ] protos ,  String return Type ) {  String Builder builder = new  String Builder ( ) ; builder . append ( _ STR ) ; for ( int i = _ NUM ; i < protos . length ; i ++ ) { builder . append ( protos [ i ] ) ; } builder . append ( _ STR ) ; builder . append ( return Type ) ; return builder . to String ( ) ; }
@  Override void to XML (  String Builder xml , int level ) { indent ( xml , level ) ; xml . append ( _ STR ) ; for ( int i = _ NUM ; i < bytes . length ; i ++ ) { byte b = bytes [ i ] ; if ( b < _ NUM ) xml . append ( _ STR ) ; xml . append (  Integer . to Hex String ( b ) ) ; } xml . append ( _ STR ) ; }
protected void paint Content Border Right Edge (  Graphics g , int x , int y , int w , int h , boolean draw Broken ,  Rectangle sel Rect , boolean is Content Border Painted ) { if ( is Content Border Painted ) { g . set Color ( dark Shadow ) ; g . fill Rect ( x + w - _ NUM , y , _ NUM , h ) ; } }
private void write Final Results (  String output Dir , double total TT , double [ ] total Route TTs , double [ ] avg Route TTs , int [ ] route Users , int number Of Stucked Agents ) {  Print Stream stream ;  String filename = output Dir + _ STR ; try { stream = new  Print Stream ( new  File ( filename ) ) ; } catch (  File Not Found Exception e ) { e . print Stack Trace ( ) ; return ; } log . info ( _ STR + total TT ) ;  String header = _ STR ;  String Buffer result Line = new  String Buffer ( ) ; result Line . append ( total TT ) ;  String latex Format = _ STR + ( int ) total TT ; log . info ( _ STR ) ; for ( int route Nr = _ NUM ; route Nr < number Of Routes ; route Nr ++ ) { log . info ( _ STR + route Nr + _ STR + route Users [ route Nr ] ) ; header += _ STR + route Nr ; result Line . append ( _ STR + route Users [ route Nr ] ) ; latex Format += _ STR + route Users [ route Nr ] ; } log . info ( _ STR ) ; for ( int route Nr = _ NUM ; route Nr < number Of Routes ; route Nr ++ ) { log . info ( _ STR + route Nr + _ STR + avg Route TTs [ route Nr ] ) ; header += _ STR + route Nr ; result Line . append ( _ STR + avg Route TTs [ route Nr ] ) ; latex Format += _ STR + (  Double . is Na N ( avg Route TTs [ route Nr ] ) ? _ STR : ( int ) avg Route TTs [ route Nr ] ) ; } log . info ( _ STR + number Of Stucked Agents ) ; header += _ STR ; result Line . append ( _ STR + number Of Stucked Agents ) ; latex Format += _ STR ; log . info ( _ STR + latex Format ) ; stream . println ( header ) ; stream . println ( result Line . to String ( ) ) ; stream . close ( ) ; log . info ( _ STR + filename ) ; }
public int execute (  String sql ) throws  SQLException { if ( logger . is Debug Enabled ( ) ) logger . debug ( _ STR + sql ) ; return statement . execute Update ( sql ) ; }
@  Layoutlib Delegate static long current Thread Time Micro ( ) { return  System . current Time Millis ( ) * _ NUM ; }
public static  List <  Entry > make Entries (  List <  String > ldif Lines ) { return make Entries ( ldif Lines . to Array ( new  String [ ldif Lines . size ( ) ] ) ) ; }
public int format ( long val , byte [ ] buf , int off , int len ) { if ( val ==  Long .  MIN_ VALUE ) { if ( len >  MAX_ LONG_ LENGTH ) { return format ( _ STR , buf , off , len ) ; } else { truncation Filler ( buf , off , len ) ; return off + len ; } } long pos =  Math . abs ( val ) ; int ndig = _ NUM ; long dmax =  Byte Formatter .  NUMBER_ BASE ; while ( ndig <  MAX_ LONG_ LENGTH && pos >= dmax ) { ndig ++ ; dmax *=  Byte Formatter .  NUMBER_ BASE ; } if ( val < _ NUM ) { ndig ++ ; } if ( ndig > len || ndig > buf . length - off ) { truncation Filler ( buf , off , len ) ; return off + len ; } off += ndig ; int xoff = off - _ NUM ; buf [ xoff ] = ( byte ) _ STR ; boolean last = pos == _ NUM ; while ( ! last ) { int giga = ( int ) ( pos %  LONG_ TO_ INT_ MODULO ) ; pos /=  LONG_ TO_ INT_ MODULO ; last = pos == _ NUM ; for ( int i = _ NUM ; i <  MAXIMUM_ SINGLE_ DIGIT_ INTEGER ; i ++ ) { buf [ xoff ] =  Byte Formatter .  DIGITS [ giga %  Byte Formatter .  NUMBER_ BASE ] ; xoff -- ; giga /=  Byte Formatter .  NUMBER_ BASE ; if ( last && giga == _ NUM ) { break ; } } } if ( val < _ NUM ) { buf [ xoff ] = ( byte ) _ STR ; } return off ; }
private void append Affix (  String Buffer buffer ,  String affix Pattern ,  String exp Affix , boolean localized ) { if ( affix Pattern == null ) { append Affix ( buffer , exp Affix , localized ) ; } else { int i ; for ( int pos = _ NUM ; pos < affix Pattern . length ( ) ; pos = i ) { i = affix Pattern . index Of (  QUOTE , pos ) ; if ( i < _ NUM ) { append Affix ( buffer , affix Pattern . substring ( pos ) , localized ) ; break ; } if ( i > pos ) { append Affix ( buffer , affix Pattern . substring ( pos , i ) , localized ) ; } char c = affix Pattern . char At ( ++ i ) ; ++ i ; if ( c ==  QUOTE ) { buffer . append ( c ) ; } else if ( c ==  CURRENCY_ SIGN && i < affix Pattern . length ( ) && affix Pattern . char At ( i ) ==  CURRENCY_ SIGN ) { ++ i ; buffer . append ( c ) ; } else if ( localized ) { switch ( c ) { case  PATTERN_ PERCENT : c = symbols . get Percent ( ) ; break ; case  PATTERN_ PER_ MILLE : c = symbols . get Per Mill ( ) ; break ; case  PATTERN_ MINUS : c = symbols . get Minus Sign ( ) ; break ; } } buffer . append ( c ) ; } } }
private boolean check Class Implements Compliance ( ) {  Class < ? > [ ] interfaces = m Class . get Interfaces ( ) ;  Set <  String > inter Face Set = new  Hash Set < > ( ) ; for (  Class < ? > c : interfaces ) { inter Face Set . add ( c . get Canonical Name ( ) ) ; } for (  String inter : impl Interfaces ) { if ( ! inter Face Set . contains ( inter ) ) { return _ BOOL ; } } return _ BOOL ; }
protected boolean apply Peephole Branch Opts (  IR ir ) { boolean did Something = _ BOOL ; for (  Enumeration <  Basic Block > e = ir . get Basic Blocks ( ) ; e . has More Elements ( ) ; ) {  Basic Block bb = e . next Element ( ) ; if ( ! bb . is Empty ( ) ) { for (  Enumeration <  Instruction > ie = bb . enumerate Branch Instructions ( ) ; ie . has More Elements ( ) ; ) {  Instruction s = ie . next Element ( ) ; if ( optimize Branch Instruction ( ir , s , bb ) ) { did Something = _ BOOL ; ie = bb . enumerate Branch Instructions ( ) ; } } } } return did Something ; }
public int checksum_ts ( ) { return calculate Checksum ( compile_checksum . to String ( ) + compile_checksum_ts . to String ( ) ) ; }
public boolean by Pass Control To Processor ( boolean flag ) { return _ BOOL ; }
protected void draw Value (  Canvas c ,  String value , float x Pos , float y Pos ) { c . draw Text ( value , x Pos , y Pos , m Value Paint ) ; }
public sun . net . ftp .  Ftp Client login (  String user , char [ ] password ,  String account ) throws sun . net . ftp .  Ftp Protocol Exception ,  IOException { if ( ! is Connected ( ) ) { throw new sun . net . ftp .  Ftp Protocol Exception ( _ STR ,  Ftp Reply Code .  BAD_ SEQUENCE ) ; } if ( user == null || user . length ( ) == _ NUM ) { throw new  Illegal Argument Exception ( _ STR ) ; } try Login ( user , password ) ; if ( last Reply Code ==  Ftp Reply Code .  NEED_ ACCOUNT ) { issue Command Check ( _ STR + account ) ; }  String Buffer sb = new  String Buffer ( ) ; if ( server Response != null ) { for (  String l : server Response ) { if ( l != null ) { if ( l . length ( ) >= _ NUM && l . starts With ( _ STR ) ) { l = l . substring ( _ NUM ) ; } sb . append ( l ) ; } } } welcome Msg = sb . to String ( ) ; logged In = _ BOOL ; return this ; }
public static boolean install Normal (  Context context ,  String file Path ) {  Intent i = new  Intent (  Intent .  ACTION_ VIEW ) ;  File file = new  File ( file Path ) ; if ( file == null || ! file . exists ( ) || ! file . is File ( ) || file . length ( ) <= _ NUM ) { return _ BOOL ; } i . set Data And Type (  Uri . parse ( _ STR + file Path ) , _ STR ) ; i . add Flags (  Intent .  FLAG_ ACTIVITY_ NEW_ TASK ) ; context . start Activity ( i ) ; return _ BOOL ; }
private  List <  IItem > create Insert List (  List <  IItem > item Drag List ) {  List <  IItem > temp List = new  Array List <  IItem > ( ) ;  List <  IItem > insert List = new  Array List <  IItem > ( ) ; int depth = _ NUM ; int removed = _ NUM ; for (  IItem item : item Drag List ) { create Insert List ( item , temp List , insert List , depth , removed ) ; } this . number Of Controls = temp List . size ( ) - removed ; return insert List ; }
public static boolean is Font Embedded (  Pdf Object pdf Object ) { final int font Type = pdf Object . get Parameter Constant (  Pdf Dictionary .  Subtype ) ; if ( font Type ==  Standard Fonts .  TYPE0 ) { pdf Object = pdf Object . get Dictionary (  Pdf Dictionary .  Descendant Fonts ) ; } final  Pdf Object desc Font Obj = pdf Object . get Dictionary (  Pdf Dictionary .  Font Descriptor ) ; if ( desc Font Obj == null ) { return _ BOOL ; } else { return desc Font Obj . has Stream ( ) ; } }
public  Singular Value Decomposition (  Matrix  Arg ) { double [ ] [ ]  A =  Arg . get Array Copy ( ) ; m =  Arg . get Row Dimension ( ) ; n =  Arg . get Column Dimension ( ) ; int nu =  Math . min ( m , n ) ; s = new double [  Math . min ( m + _ NUM , n ) ] ;  U = new double [ m ] [ nu ] ;  V = new double [ n ] [ n ] ; double [ ] e = new double [ n ] ; double [ ] work = new double [ m ] ; boolean wantu = _ BOOL ; boolean wantv = _ BOOL ; int nct =  Math . min ( m - _ NUM , n ) ; int nrt =  Math . max ( _ NUM ,  Math . min ( n - _ NUM , m ) ) ; for ( int k = _ NUM ; k <  Math . max ( nct , nrt ) ; k ++ ) { if ( k < nct ) { s [ k ] = _ NUM ; for ( int i = k ; i < m ; i ++ ) { s [ k ] =  Maths . hypot ( s [ k ] ,  A [ i ] [ k ] ) ; } if ( s [ k ] != _ NUM ) { if (  A [ k ] [ k ] < _ NUM ) { s [ k ] = - s [ k ] ; } for ( int i = k ; i < m ; i ++ ) {  A [ i ] [ k ] /= s [ k ] ; }  A [ k ] [ k ] += _ NUM ; } s [ k ] = - s [ k ] ; } for ( int j = k + _ NUM ; j < n ; j ++ ) { if ( ( k < nct ) & ( s [ k ] != _ NUM ) ) { double t = _ NUM ; for ( int i = k ; i < m ; i ++ ) { t +=  A [ i ] [ k ] *  A [ i ] [ j ] ; } t = - t /  A [ k ] [ k ] ; for ( int i = k ; i < m ; i ++ ) {  A [ i ] [ j ] += t *  A [ i ] [ k ] ; } } e [ j ] =  A [ k ] [ j ] ; } if ( wantu & ( k < nct ) ) { for ( int i = k ; i < m ; i ++ ) {  U [ i ] [ k ] =  A [ i ] [ k ] ; } } if ( k < nrt ) { e [ k ] = _ NUM ; for ( int i = k + _ NUM ; i < n ; i ++ ) { e [ k ] =  Maths . hypot ( e [ k ] , e [ i ] ) ; } if ( e [ k ] != _ NUM ) { if ( e [ k + _ NUM ] < _ NUM ) { e [ k ] = - e [ k ] ; } for ( int i = k + _ NUM ; i < n ; i ++ ) { e [ i ] /= e [ k ] ; } e [ k + _ NUM ] += _ NUM ; } e [ k ] = - e [ k ] ; if ( ( k + _ NUM < m ) & ( e [ k ] != _ NUM ) ) { for ( int i = k + _ NUM ; i < m ; i ++ ) { work [ i ] = _ NUM ; } for ( int j = k + _ NUM ; j < n ; j ++ ) { for ( int i = k + _ NUM ; i < m ; i ++ ) { work [ i ] += e [ j ] *  A [ i ] [ j ] ; } } for ( int j = k + _ NUM ; j < n ; j ++ ) { double t = - e [ j ] / e [ k + _ NUM ] ; for ( int i = k + _ NUM ; i < m ; i ++ ) {  A [ i ] [ j ] += t * work [ i ] ; } } } if ( wantv ) { for ( int i = k + _ NUM ; i < n ; i ++ ) {  V [ i ] [ k ] = e [ i ] ; } } } } int p =  Math . min ( n , m + _ NUM ) ; if ( nct < n ) { s [ nct ] =  A [ nct ] [ nct ] ; } if ( m < p ) { s [ p - _ NUM ] = _ NUM ; } if ( nrt + _ NUM < p ) { e [ nrt ] =  A [ nrt ] [ p - _ NUM ] ; } e [ p - _ NUM ] = _ NUM ; if ( wantu ) { for ( int j = nct ; j < nu ; j ++ ) { for ( int i = _ NUM ; i < m ; i ++ ) {  U [ i ] [ j ] = _ NUM ; }  U [ j ] [ j ] = _ NUM ; } for ( int k = nct - _ NUM ; k >= _ NUM ; k -- ) { if ( s [ k ] != _ NUM ) { for ( int j = k + _ NUM ; j < nu ; j ++ ) { double t = _ NUM ; for ( int i = k ; i < m ; i ++ ) { t +=  U [ i ] [ k ] *  U [ i ] [ j ] ; } t = - t /  U [ k ] [ k ] ; for ( int i = k ; i < m ; i ++ ) {  U [ i ] [ j ] += t *  U [ i ] [ k ] ; } } for ( int i = k ; i < m ; i ++ ) {  U [ i ] [ k ] = -  U [ i ] [ k ] ; }  U [ k ] [ k ] = _ NUM +  U [ k ] [ k ] ; for ( int i = _ NUM ; i < k - _ NUM ; i ++ ) {  U [ i ] [ k ] = _ NUM ; } } else { for ( int i = _ NUM ; i < m ; i ++ ) {  U [ i ] [ k ] = _ NUM ; }  U [ k ] [ k ] = _ NUM ; } } } if ( wantv ) { for ( int k = n - _ NUM ; k >= _ NUM ; k -- ) { if ( ( k < nrt ) & ( e [ k ] != _ NUM ) ) { for ( int j = k + _ NUM ; j < nu ; j ++ ) { double t = _ NUM ; for ( int i = k + _ NUM ; i < n ; i ++ ) { t +=  V [ i ] [ k ] *  V [ i ] [ j ] ; } t = - t /  V [ k + _ NUM ] [ k ] ; for ( int i = k + _ NUM ; i < n ; i ++ ) {  V [ i ] [ j ] += t *  V [ i ] [ k ] ; } } } for ( int i = _ NUM ; i < n ; i ++ ) {  V [ i ] [ k ] = _ NUM ; }  V [ k ] [ k ] = _ NUM ; } } int pp = p - _ NUM ; int iter = _ NUM ; double eps =  Math . pow ( _ NUM , - _ NUM ) ; double tiny =  Math . pow ( _ NUM , - _ NUM ) ; while ( p > _ NUM ) { int k , kase ; for ( k = p - _ NUM ; k >= - _ NUM ; k -- ) { if ( k == - _ NUM ) { break ; } if (  Math . abs ( e [ k ] ) <= tiny + eps * (  Math . abs ( s [ k ] ) +  Math . abs ( s [ k + _ NUM ] ) ) ) { e [ k ] = _ NUM ; break ; } } if ( k == p - _ NUM ) { kase = _ NUM ; } else { int ks ; for ( ks = p - _ NUM ; ks >= k ; ks -- ) { if ( ks == k ) { break ; } double t = ( ks != p ?  Math . abs ( e [ ks ] ) : _ NUM ) + ( ks != k + _ NUM ?  Math . abs ( e [ ks - _ NUM ] ) : _ NUM ) ; if (  Math . abs ( s [ ks ] ) <= tiny + eps * t ) { s [ ks ] = _ NUM ; break ; } } if ( ks == k ) { kase = _ NUM ; } else if ( ks == p - _ NUM ) { kase = _ NUM ; } else { kase = _ NUM ; k = ks ; } } k ++ ; switch ( kase ) { case _ NUM : { double f = e [ p - _ NUM ] ; e [ p - _ NUM ] = _ NUM ; for ( int j = p - _ NUM ; j >= k ; j -- ) { double t =  Maths . hypot ( s [ j ] , f ) ; double cs = s [ j ] / t ; double sn = f / t ; s [ j ] = t ; if ( j != k ) { f = - sn * e [ j - _ NUM ] ; e [ j - _ NUM ] = cs * e [ j - _ NUM ] ; } if ( wantv ) { for ( int i = _ NUM ; i < n ; i ++ ) { t = cs *  V [ i ] [ j ] + sn *  V [ i ] [ p - _ NUM ] ;  V [ i ] [ p - _ NUM ] = - sn *  V [ i ] [ j ] + cs *  V [ i ] [ p - _ NUM ] ;  V [ i ] [ j ] = t ; } } } } break ; case _ NUM : { double f = e [ k - _ NUM ] ; e [ k - _ NUM ] = _ NUM ; for ( int j = k ; j < p ; j ++ ) { double t =  Maths . hypot ( s [ j ] , f ) ; double cs = s [ j ] / t ; double sn = f / t ; s [ j ] = t ; f = - sn * e [ j ] ; e [ j ] = cs * e [ j ] ; if ( wantu ) { for ( int i = _ NUM ; i < m ; i ++ ) { t = cs *  U [ i ] [ j ] + sn *  U [ i ] [ k - _ NUM ] ;  U [ i ] [ k - _ NUM ] = - sn *  U [ i ] [ j ] + cs *  U [ i ] [ k - _ NUM ] ;  U [ i ] [ j ] = t ; } } } } break ; case _ NUM : { double scale =  Math . max (  Math . max (  Math . max (  Math . max (  Math . abs ( s [ p - _ NUM ] ) ,  Math . abs ( s [ p - _ NUM ] ) ) ,  Math . abs ( e [ p - _ NUM ] ) ) ,  Math . abs ( s [ k ] ) ) ,  Math . abs ( e [ k ] ) ) ; double sp = s [ p - _ NUM ] / scale ; double spm1 = s [ p - _ NUM ] / scale ; double epm1 = e [ p - _ NUM ] / scale ; double sk = s [ k ] / scale ; double ek = e [ k ] / scale ; double b = ( ( spm1 + sp ) * ( spm1 - sp ) + epm1 * epm1 ) / _ NUM ; double c = ( sp * epm1 ) * ( sp * epm1 ) ; double shift = _ NUM ; if ( ( b != _ NUM ) | ( c != _ NUM ) ) { shift =  Math . sqrt ( b * b + c ) ; if ( b < _ NUM ) { shift = - shift ; } shift = c / ( b + shift ) ; } double f = ( sk + sp ) * ( sk - sp ) + shift ; double g = sk * ek ; for ( int j = k ; j < p - _ NUM ; j ++ ) { double t =  Maths . hypot ( f , g ) ; double cs = f / t ; double sn = g / t ; if ( j != k ) { e [ j - _ NUM ] = t ; } f = cs * s [ j ] + sn * e [ j ] ; e [ j ] = cs * e [ j ] - sn * s [ j ] ; g = sn * s [ j + _ NUM ] ; s [ j + _ NUM ] = cs * s [ j + _ NUM ] ; if ( wantv ) { for ( int i = _ NUM ; i < n ; i ++ ) { t = cs *  V [ i ] [ j ] + sn *  V [ i ] [ j + _ NUM ] ;  V [ i ] [ j + _ NUM ] = - sn *  V [ i ] [ j ] + cs *  V [ i ] [ j + _ NUM ] ;  V [ i ] [ j ] = t ; } } t =  Maths . hypot ( f , g ) ; cs = f / t ; sn = g / t ; s [ j ] = t ; f = cs * e [ j ] + sn * s [ j + _ NUM ] ; s [ j + _ NUM ] = - sn * e [ j ] + cs * s [ j + _ NUM ] ; g = sn * e [ j + _ NUM ] ; e [ j + _ NUM ] = cs * e [ j + _ NUM ] ; if ( wantu && ( j < m - _ NUM ) ) { for ( int i = _ NUM ; i < m ; i ++ ) { t = cs *  U [ i ] [ j ] + sn *  U [ i ] [ j + _ NUM ] ;  U [ i ] [ j + _ NUM ] = - sn *  U [ i ] [ j ] + cs *  U [ i ] [ j + _ NUM ] ;  U [ i ] [ j ] = t ; } } } e [ p - _ NUM ] = f ; iter = iter + _ NUM ; } break ; case _ NUM : { if ( s [ k ] <= _ NUM ) { s [ k ] = ( s [ k ] < _ NUM ? - s [ k ] : _ NUM ) ; if ( wantv ) { for ( int i = _ NUM ; i <= pp ; i ++ ) {  V [ i ] [ k ] = -  V [ i ] [ k ] ; } } } while ( k < pp ) { if ( s [ k ] >= s [ k + _ NUM ] ) { break ; } double t = s [ k ] ; s [ k ] = s [ k + _ NUM ] ; s [ k + _ NUM ] = t ; if ( wantv && ( k < n - _ NUM ) ) { for ( int i = _ NUM ; i < n ; i ++ ) { t =  V [ i ] [ k + _ NUM ] ;  V [ i ] [ k + _ NUM ] =  V [ i ] [ k ] ;  V [ i ] [ k ] = t ; } } if ( wantu && ( k < m - _ NUM ) ) { for ( int i = _ NUM ; i < m ; i ++ ) { t =  U [ i ] [ k + _ NUM ] ;  U [ i ] [ k + _ NUM ] =  U [ i ] [ k ] ;  U [ i ] [ k ] = t ; } } k ++ ; } iter = _ NUM ; p -- ; } break ; } } }
public  Only One Is Allowed To Be Set Global Constraint (  Parameter < ? > ... params ) { parameters =  Arrays . as List ( params ) ; }
public  Rhythm Overlay inflate Overlay (  String config String , @  Non Null  Map <  String ,  String > vars ) {  List <  String > config Strings =  Arrays . as List ( config String . split ( _ STR ) ) ; return inflate Overlay Internal ( config Strings , vars , _ NUM ) ; }
@  Nullable public static  String find File In Provided Path (  String provided Path ,  String ... file Names ) { if (  String Util . is Empty ( provided Path ) ) { return _ STR ; }  File provided File = new  File ( provided Path ) ; if ( provided File . exists ( ) ) {  String name = provided File . get Name ( ) ; for (  String file Name : file Names ) { if ( name . equals ( file Name ) ) { return to System Dependent Name ( provided File . get Path ( ) ) ; } } } if ( provided File . is Directory ( ) ) { for (  String file Name : file Names ) {  File file = new  File ( provided File , file Name ) ; if ( file Name . equals ( file . get Name ( ) ) && file . exists ( ) ) { return to System Dependent Name ( file . get Path ( ) ) ; } } } provided File = provided File . get Parent File ( ) ; if ( provided File != null && provided File . exists ( ) ) { for (  String file Name : file Names ) {  File file = new  File ( provided File , file Name ) ; if ( file Name . equals ( file . get Name ( ) ) && file . exists ( ) ) { return to System Dependent Name ( file . get Path ( ) ) ; } } } return null ; }
public void flip (  WComponent Peer peer ,  Component target ,  Volatile Image back Buffer , int x1 , int y1 , int x2 , int y2 ,  Buffer Capabilities .  Flip Contents flip Action ) { if ( flip Action ==  Buffer Capabilities .  Flip Contents .  COPIED || flip Action ==  Buffer Capabilities .  Flip Contents .  UNDEFINED ) {  Graphics g = peer . get Graphics ( ) ; try { g . draw Image ( back Buffer , x1 , y1 , x2 , y2 , x1 , y1 , x2 , y2 , null ) ; } finally { g . dispose ( ) ; } } else if ( flip Action ==  Buffer Capabilities .  Flip Contents .  BACKGROUND ) {  Graphics g = back Buffer . get Graphics ( ) ; try { g . set Color ( target . get Background ( ) ) ; g . fill Rect ( _ NUM , _ NUM , back Buffer . get Width ( ) , back Buffer . get Height ( ) ) ; } finally { g . dispose ( ) ; } } }
protected void load Value (  String s Value ) { try { value =  Integer . parse Int ( s Value . trim ( ) ) ; } catch (  Number Format Exception nfe ) { revert To Default ( ) ; } }
public static  List <  SOAPElement > input Needed (  SOAPElement ele ) {  List <  SOAPElement > l = new  Array List <  SOAPElement > ( ) ; log . trace ( _ STR + ele . get Node Name ( ) ) ; input Needed ( ele , l ) ; log . trace ( _ STR + l ) ; return l ; }
private void build Pieces ( ) { pieces = new  Piece [ path Array . size ( ) ] ;  Paint paint = new  Paint ( ) ;  Matrix matrix = new  Matrix ( ) ;  Canvas canvas = new  Canvas ( ) ; for ( int i = _ NUM ; i < pieces . length ; i ++ ) { int shadow =  Utils . next Int (  Utils . dp2px ( _ NUM ) ,  Utils . dp2px ( _ NUM ) ) ;  Path path = path Array . get ( i ) ;  Rect F r = new  Rect F ( ) ; path . compute Bounds ( r , _ BOOL ) ;  Bitmap p Bitmap =  Utils . create Bitmap Safely ( ( int ) r . width ( ) + shadow * _ NUM , ( int ) r . height ( ) + shadow * _ NUM ,  Bitmap .  Config .  ARGB_4444 , _ NUM ) ; if ( p Bitmap == null ) { pieces [ i ] = new  Piece ( - _ NUM , - _ NUM , null , shadow ) ; continue ; } pieces [ i ] = new  Piece ( ( int ) r . left + m Touch Point . x - shadow , ( int ) r . top + m Touch Point . y - shadow , p Bitmap , shadow ) ; canvas . set Bitmap ( pieces [ i ] . bitmap ) ;  Bitmap Shader m Bitmap Shader = new  Bitmap Shader ( m Bitmap ,  Shader .  Tile Mode .  CLAMP ,  Shader .  Tile Mode .  CLAMP ) ; matrix . reset ( ) ; matrix . set Translate ( - r . left - offset X + shadow , - r . top - offset Y + shadow ) ; m Bitmap Shader . set Local Matrix ( matrix ) ; paint . reset ( ) ;  Path offset Path = new  Path ( ) ; offset Path . add Path ( path , - r . left + shadow , - r . top + shadow ) ; paint . set Style (  Paint .  Style .  FILL ) ; paint . set Shadow Layer ( shadow , _ NUM , _ NUM , _ NUM ) ; canvas . draw Path ( offset Path , paint ) ; paint . set Shadow Layer ( _ NUM , _ NUM , _ NUM , _ NUM ) ; paint . set Xfermode ( new  Porter Duff Xfermode (  Porter Duff .  Mode .  XOR ) ) ; canvas . draw Path ( offset Path , paint ) ; paint . set Xfermode ( null ) ; paint . set Shader ( m Bitmap Shader ) ; paint . set Alpha ( _ NUM ) ; canvas . draw Path ( offset Path , paint ) ; }  Arrays . sort ( pieces ) ; }
protected void stop Output Test ( ) { if ( test Running && out Test ) { out Timer . stop ( ) ; status Text1 . set Text ( _ STR +  Integer . to String ( num Iterations ) + _ STR ) ; status Text1 . set Visible ( _ BOOL ) ; status Text2 . set Text ( _ STR ) ; status Text2 . set Visible ( _ BOOL ) ; } }
@  HLEFunction ( nid = _ NUM , version = _ NUM ) public int sce Net Resolver Start Ato N ( @  Check Argument ( _ STR ) int rid , int addr ,  TPointer hostname Addr , int hostname Length , int timeout , int retry ) { try { byte [ ] bytes = sce Net Inet . internet Address To Bytes ( addr ) ;  Inet Address inet Address =  Inet Address . get By Address ( bytes ) ;  String host Name = inet Address . get Host Name ( ) ; hostname Addr . set String NZ ( hostname Length , host Name ) ; if ( log . is Debug Enabled ( ) ) { log . debug (  String . format ( _ STR , host Name ) ) ; } } catch (  Unknown Host Exception e ) { log . error ( e ) ; return  Sce Kernel Errors .  ERROR_ NET_ RESOLVER_ INVALID_ HOST ; } return _ NUM ; }
public void reset ( ) { m Active Calls . clear ( ) ; m Talkgroups First Heard . clear ( ) ; m Talkgroups . clear ( ) ; m LCNTracker . reset ( ) ; reset State ( ) ; }
public static void copy File (  File source File ,  File dest File ) throws  IOException { if ( ! source File . exists ( ) ) { throw new  IOException ( _ STR + source File . get Absolute Path ( ) ) ; } copy File ( new  File Input Stream ( source File ) , new  File Output Stream ( dest File ) ) ; }
private synchronized void rebuild Journal ( ) throws  IOException { if ( journal Writer != null ) { journal Writer . close ( ) ; } final  Writer writer = new  Buffered Writer ( new  File Writer ( journal File Tmp ) ,  IO_ BUFFER_ SIZE ) ; writer . write (  MAGIC ) ; writer . write ( _ STR ) ; writer . write (  VERSION_1 ) ; writer . write ( _ STR ) ; writer . write (  Integer . to String ( app Version ) ) ; writer . write ( _ STR ) ; writer . write (  Integer . to String ( value Count ) ) ; writer . write ( _ STR ) ; writer . write ( _ STR ) ; for ( final  Entry entry : lru Entries . values ( ) ) { if ( entry . current Editor != null ) { writer . write (  DIRTY + _ STR + entry . key + _ STR ) ; } else { writer . write (  CLEAN + _ STR + entry . key + entry . get Lengths ( ) + _ STR ) ; } } writer . close ( ) ; journal File Tmp . rename To ( journal File ) ; journal Writer = new  Buffered Writer ( new  File Writer ( journal File , _ BOOL ) ,  IO_ BUFFER_ SIZE ) ; }
private static  Vector permute List (  Vector arr ,  Secure Random rand ) {  Vector retval = new  Vector ( ) ;  Vector tmp = new  Vector ( ) ; for ( int i = _ NUM ; i < arr . size ( ) ; i ++ ) { tmp . add Element ( arr . element At ( i ) ) ; } retval . add Element ( tmp . element At ( _ NUM ) ) ; tmp . remove Element At ( _ NUM ) ; while ( tmp . size ( ) != _ NUM ) { retval . insert Element At ( tmp . element At ( _ NUM ) , get Int ( rand , retval . size ( ) + _ NUM ) ) ; tmp . remove Element At ( _ NUM ) ; } return retval ; }
private static  List <  Command > load Rewrites (  Content Resolver content Resolver ,  Uri uri ) throws  IOException {  Input Stream input Stream = content Resolver . open Input Stream ( uri ) ;  List <  Command > commands = new  Array List < > ( ) ; if ( input Stream != null ) {  Buffered Reader reader = new  Buffered Reader ( new  Input Stream Reader ( input Stream ) ) ;  String line ; while ( ( line = reader . read Line ( ) ) != null ) { add Line ( commands , line ) ; } input Stream . close ( ) ; } return commands ; }
@  Override public  State Connection service ( ) throws  IOException { try {  Connection Protocol request = request Or Create ( ) ; if ( request == null ) { log . warning ( _ STR + this ) ; return  State Connection .  CLOSE ; }  State Connection next = request . service ( ) ; if ( next !=  State Connection .  CLOSE ) { return next ; } else { return on Close Read ( ) ; } } catch (  Out Of Memory Error e ) {  String msg = _ STR ;  Shutdown System . shutdown Out Of Memory ( msg ) ; log . log (  Level .  WARNING , e . to String ( ) , e ) ; } catch (  Throwable e ) { e . print Stack Trace ( ) ; log . log (  Level .  WARNING , e . to String ( ) , e ) ; } return  State Connection .  CLOSE ; }
public static  Map <  UUID ,  Collection <  Cluster Node > > neighbors (  Collection <  Cluster Node > top Snapshot ) {  Map <  String ,  Collection <  Cluster Node > > mac Map = new  Hash Map < > ( top Snapshot . size ( ) , _ NUM ) ; for (  Cluster Node node : top Snapshot ) {  String macs = node . attribute (  Ignite Node Attributes .  ATTR_ MACS ) ;  Collection <  Cluster Node > nodes = mac Map . get ( macs ) ; if ( nodes == null ) mac Map . put ( macs , nodes = new  Hash Set < > ( ) ) ; nodes . add ( node ) ; }  Map <  UUID ,  Collection <  Cluster Node > > neighbors = new  Hash Map < > ( top Snapshot . size ( ) , _ NUM ) ; for (  Collection <  Cluster Node > group : mac Map . values ( ) ) for (  Cluster Node node : group ) neighbors . put ( node . id ( ) , group ) ; return neighbors ; }
public void handle Request (  String request ,  Output Stream out ) throws  IOException ,  Map Request Format Exception {  Properties request Properties = convert Request To Props ( request ) ;  String request Type = request Properties . get Property (  REQUEST ) ; if ( request Type != null ) { if ( request Type . equals Ignore Case (  MAP ) ) {  Debug . message ( _ STR , _ STR ) ; handle Map Request ( request Properties , out ) ; } else if ( request Type . equals Ignore Case (  CAPABILITIES ) ) {  Debug . message ( _ STR , _ STR ) ; handle Capabilities Request ( request Properties , out ) ; } else if ( request Type . equals Ignore Case (  PAN ) ) {  Debug . message ( _ STR , _ STR ) ; handle Pan Request ( request Properties , out ) ; } else if ( request Type . equals Ignore Case (  RECENTER ) ) {  Debug . message ( _ STR , _ STR ) ; handle Recenter Request ( request Properties , out ) ; } else { throw new  Map Request Format Exception ( _ STR + request Type ) ; } } else { throw new  Map Request Format Exception ( _ STR + request ) ; } }
public  String format ( float val ) {  Decimal Format df = get Float Format ( ) ; if ( df != null ) { return df . format ( val ) ; } return  Float . to String ( val ) ; }
public void add Identity Position ( int position ,  Set <  Identity > participants ) { for (  Identity participant : participants ) {  Set <  Integer > positions = identity Positions . get ( participant . get Id ( ) ) ; if ( positions == null ) { positions = new  Hash Set < > ( ) ; identity Positions . put ( participant . get Id ( ) , positions ) ; } positions . add ( position ) ; } }
private void draw Drag Border ( final  Execution Unit process , final  Graphics2 D g2 ) { double width = model . get Process Width ( process ) ; double height = model . get Process Height ( process ) ;  Shape drag Frame = new  Round Rectangle2 D .  Double (  DRAG_ BORDER_ PADDING ,  DRAG_ BORDER_ PADDING , width - _ NUM *  DRAG_ BORDER_ PADDING , height - _ NUM *  DRAG_ BORDER_ PADDING ,  DRAG_ BORDER_ CORNER ,  DRAG_ BORDER_ CORNER ) ; g2 . set Color (  BORDER_ DRAG_ COLOR ) ; g2 . set Stroke (  BORDER_ DRAG_ STROKE ) ; g2 . draw ( drag Frame ) ; }
public static final  Read Only Color RGBA string To Color RGBA (  String str ,  Read Only Color RGBA default Color ) { if ( ( str == null ) || str . is Empty ( ) ) { if ( default Color == null ) { throw new  Null Pointer Exception ( ) ; } return ( default Color ) ; } try { float [ ] col = string To Float Array ( str ) ; if ( col . length < _ NUM ) { return ( default Color ) ; } if ( col . length == _ NUM ) { return ( new  Color RGBA ( col [ _ NUM ] , col [ _ NUM ] , col [ _ NUM ] , _ NUM ) ) ; } else { return ( new  Color RGBA ( col [ _ NUM ] , col [ _ NUM ] , col [ _ NUM ] , col [ _ NUM ] ) ) ; } } catch (  Exception e ) { if ( default Color == null ) { throw new  Illegal Argument Exception ( e ) ; } return ( default Color ) ; } }
public boolean process String (  String str ) { if ( handle Command ( str ) ) { return _ BOOL ; } if ( get Game State ( ) !=  Game State .  ALIVE ) { return _ BOOL ; }  Move m =  Text IO . string To Move ( pos , str ) ; if ( m == null ) { return _ BOOL ; }  Undo Info ui = new  Undo Info ( ) ; pos . make Move ( m , ui ) ;  Text IO . fixup EPSquare ( pos ) ; while ( current Move < move List . size ( ) ) { move List . remove ( current Move ) ; ui Info List . remove ( current Move ) ; draw Offer List . remove ( current Move ) ; } move List . add ( m ) ; ui Info List . add ( ui ) ; draw Offer List . add ( pending Draw Offer ) ; pending Draw Offer = _ BOOL ; current Move ++ ; return _ BOOL ; }
public static boolean contains Modifiable Variable Modification (  Protocol Message object ) { for (  Modifiable Variable Holder holder : object . get All Modifiable Variable Holders ( ) ) { for (  Field f : holder . get All Modifiable Variable Fields ( ) ) { if ( contains Modifiable Variable Modification ( holder , f ) ) { return _ BOOL ; } } } return _ BOOL ; }
public boolean save As Geo JSON (  File file ) { try {  File Writer fw = new  File Writer ( file ) ;  Buffered Writer writer = new  Buffered Writer ( fw , _ NUM ) ; boolean result = save As Geo JSON ( writer ) ; writer . close ( ) ; return result ; } catch (  IOException e ) { e . print Stack Trace ( ) ; return _ BOOL ; } }
public static  List <  String > read File To List (  String file Path ) {  File file = new  File ( file Path ) ;  List <  String > file Content = new  Array List <  String > ( ) ; if ( file == null || ! file . is File ( ) ) { return null ; }  Buffered Reader reader = null ; try { reader = new  Buffered Reader ( new  File Reader ( file ) ) ;  String line = null ; while ( ( line = reader . read Line ( ) ) != null ) { file Content . add ( line ) ; } reader . close ( ) ; return file Content ; } catch (  IOException e ) { throw new  Runtime Exception ( _ STR , e ) ; } finally { if ( reader != null ) { try { reader . close ( ) ; } catch (  IOException e ) { throw new  Runtime Exception ( _ STR , e ) ; } } } }
public double do Operation ( ) throws  Operator Failed Exception { double logq ; final double alpha = ( arctan Transform ?  Math . atan ( bias ) *  SCALE_ ALPHA :  Math . log ( bias ) ) ; final  Node Ref root = tree . get Root ( ) ; double max Height = tree . get Node Height ( root ) ;  Node Ref i ;  Node Ref i P = null ;  Node Ref  Ci P = null ;  Node Ref  Pi P = null ; double height =  Double .  Na N ;  List <  Node Ref > destinations = null ; do { i = tree . get Node (  Math Utils . next Int ( tree . get Node Count ( ) ) ) ; } while ( root == i || tree . get Parent ( i ) == root ) ; i P = tree . get Parent ( i ) ;  Ci P = get Other Child ( tree , i P , i ) ;  Pi P = tree . get Parent ( i P ) ; height = tree . get Node Height ( i P ) ; destinations = get Intersecting Edges ( tree , height ) ; if ( destinations . size ( ) == _ NUM ) { throw new  Operator Failed Exception ( _ STR ) ; } double [ ] pdf = get Destination Probabilities ( tree , i , height , max Height , destinations , alpha ) ; destinations . remove ( i ) ; destinations . remove (  Ci P ) ; int r =  Math Utils . random Choice PDF ( pdf ) ; double forward Probability = pdf [ r ] ; final  Node Ref j = destinations . get ( r ) ; final  Node Ref j P = tree . get Parent ( j ) ; tree . begin Tree Edit ( ) ; tree . remove Child ( i P ,  Ci P ) ; tree . remove Child (  Pi P , i P ) ; tree . add Child (  Pi P ,  Ci P ) ; tree . remove Child ( j P , j ) ; tree . add Child ( i P , j ) ; tree . add Child ( j P , i P ) ; tree . end Tree Edit ( ) ; final  List <  Node Ref > reverse Destinations = get Intersecting Edges ( tree , height ) ; double reverse Probability = get Reverse Probability ( tree ,  Ci P , j , height , max Height , reverse Destinations , alpha ) ; logq =  Math . log ( reverse Probability ) -  Math . log ( forward Probability ) ; return logq ; }
private void close Internal ( ) { final  Bigdata Sail Repository Connection cxn = tl Tx . get ( ) ; if ( cxn != null ) { close ( cxn ) ; } }
Buffered Image create Image ( final int w , final int h , final byte [ ] rgb ) { final  Buffered Image image ; byte [ ] image Data = data To RGBByte Array ( rgb , w , h ) ; image = new  Buffered Image ( w , h ,  Buffered Image .  TYPE_ INT_ RGB ) ; final  Raster raster =  Color Space Convertor . create Interleaved Raster ( image Data , w , h ) ; image . set Data ( raster ) ; return image ; }
void remove (  Visible Object object ) { if ( objects . remove ( object . get Object Id ( ) ) != null ) { if ( object instanceof  Player ) { check Activeness ( player Count . decrement And Get ( ) > _ NUM ) ; } } }
@  Suppress Warnings ( _ STR ) public static void create Project Guideline (  Zip File zip ,  Project a Project ,  Repository Service a Repository ) throws  IOException { for (  Enumeration zip Enumerate = zip . entries ( ) ; zip Enumerate . has More Elements ( ) ; ) {  Zip Entry entry = (  Zip Entry ) zip Enumerate . next Element ( ) ;  String entry Name = normalize Entry Name ( entry ) ; if ( entry Name . starts With (  GUIDELINE ) ) {  String filename =  Filename Utils . get Name ( entry . get Name ( ) ) ;  File guideline Dir = a Repository . get Guidelines File ( a Project ) ;  File Utils . force Mkdir ( guideline Dir ) ;  File Utils . copy Input Stream To File ( zip . get Input Stream ( entry ) , new  File ( guideline Dir , filename ) ) ;  LOG . info ( _ STR + filename + _ STR + a Project . get Name ( ) + _ STR + a Project . get Id ( ) + _ STR ) ; } } }
static <  T >  T [ ] arrays Copy Of (  T [ ] original , int new Length ) {  T [ ] copy = new Array ( original , new Length ) ;  System . arraycopy ( original , _ NUM , copy , _ NUM ,  Math . min ( original . length , new Length ) ) ; return copy ; }
private void write Non Proxy Desc (  Object Stream Class desc , boolean unshared ) throws  IOException { bout . write Byte (  TC_ CLASSDESC ) ; handles . assign ( unshared ? null : desc ) ; if ( protocol ==  PROTOCOL_ VERSION_1 ) { desc . write Non Proxy ( this ) ; } else { write Class Descriptor ( desc ) ; }  Class < ? > cl = desc . for Class ( ) ; bout . set Block Data Mode ( _ BOOL ) ; if ( cl != null && is Custom Subclass ( ) ) {  Reflect Util . check Package Access ( cl ) ; } annotate Class ( cl ) ; bout . set Block Data Mode ( _ BOOL ) ; bout . write Byte (  TC_ ENDBLOCKDATA ) ; write Class Desc ( desc . get Super Desc ( ) , _ BOOL ) ; }
public boolean can Attend Meetings (  Interval [ ] intervals ) {  Arrays . sort ( intervals , null ) ; for ( int i = _ NUM ; i < intervals . length ; i ++ ) { if ( intervals [ i ] . start < intervals [ i - _ NUM ] . end ) { return _ BOOL ; } } return _ BOOL ; }
public int compare (  File file1 ,  File file2 ) { long size1 = _ NUM ; if ( file1 . is Directory ( ) ) { size1 = sum Directory Contents && file1 . exists ( ) ?  File Utils . size Of Directory ( file1 ) : _ NUM ; } else { size1 = file1 . length ( ) ; } long size2 = _ NUM ; if ( file2 . is Directory ( ) ) { size2 = sum Directory Contents && file2 . exists ( ) ?  File Utils . size Of Directory ( file2 ) : _ NUM ; } else { size2 = file2 . length ( ) ; } long result = size1 - size2 ; if ( result < _ NUM ) { return - _ NUM ; } else if ( result > _ NUM ) { return _ NUM ; } else { return _ NUM ; } }
Builder add Query Parameter (  String name ,  String value ) { if ( name == null ) throw new  Illegal Argument Exception ( _ STR ) ; if ( encoded Query Names And Values == null ) encoded Query Names And Values = new  Array List < > ( ) ; encoded Query Names And Values . add ( canonicalize ( name ,  QUERY_ COMPONENT_ ENCODE_ SET , _ BOOL , _ BOOL ) ) ; encoded Query Names And Values . add ( value != null ? canonicalize ( value ,  QUERY_ COMPONENT_ ENCODE_ SET , _ BOOL , _ BOOL ) : null ) ; return this ; }
private static img create Control Button Image (  String name ,  String js_command , boolean enabled ) {  String Buffer img Name = new  String Buffer ( _ STR + name ) ; if ( ! enabled ) img Name . append ( _ STR ) ; img Name . append ( _ STR ) ; img img = new img (  Web Env . get Image Directory ( img Name . to String ( ) ) , name ) ; if ( enabled ) img . set Alt (  Msg . get Msg (  AD_ Language , name ) ) ; img . set ID ( _ STR ) ; if ( js_command != null && js_command . length ( ) > _ NUM && enabled ) { img . set On Click ( _ STR +  FORM_ NAME + _ STR +  M_ Command + _ STR + name + _ STR + js_command ) ; } return img ; }
public static  List <  Principal User Dto > transform To Dto (  List <  Principal User > users ) { if ( users == null ) { throw new  Web Application Exception ( _ STR ,  Status .  INTERNAL_ SERVER_ ERROR ) ; }  List <  Principal User Dto > result = new  Array List < > ( ) ; for (  Principal User user : users ) { result . add ( transform To Dto ( user ) ) ; } return result ; }
public final int increment And Get ( ) { return unsafe . get And Add Int ( this , value Offset , _ NUM ) + _ NUM ; }
private  Result Points And Transitions transitions Between (  Result Point from ,  Result Point to ) { int from X = ( int ) from . get X ( ) ; int from Y = ( int ) from . get Y ( ) ; int to X = ( int ) to . get X ( ) ; int to Y = ( int ) to . get Y ( ) ; boolean steep =  Math . abs ( to Y - from Y ) >  Math . abs ( to X - from X ) ; if ( steep ) { int temp = from X ; from X = from Y ; from Y = temp ; temp = to X ; to X = to Y ; to Y = temp ; } int dx =  Math . abs ( to X - from X ) ; int dy =  Math . abs ( to Y - from Y ) ; int error = - dx / _ NUM ; int ystep = from Y < to Y ? _ NUM : - _ NUM ; int xstep = from X < to X ? _ NUM : - _ NUM ; int transitions = _ NUM ; boolean in Black = image . get ( steep ? from Y : from X , steep ? from X : from Y ) ; for ( int x = from X , y = from Y ; x != to X ; x += xstep ) { boolean is Black = image . get ( steep ? y : x , steep ? x : y ) ; if ( is Black != in Black ) { transitions ++ ; in Black = is Black ; } error += dy ; if ( error > _ NUM ) { if ( y == to Y ) { break ; } y += ystep ; error -= dx ; } } return new  Result Points And Transitions ( from , to , transitions ) ; }
public final void add (  V value ) { if (  GWT . is Script ( ) ) { js Array . add ( value ) ; } else { java Array . add ( value ) ; } }
@  Override public synchronized void clear ( ) {  File [ ] files = m Root Directory . list Files ( ) ; if ( files != null ) { for (  File file : files ) { file . delete ( ) ; } } m Entries . clear ( ) ; m Total Size = _ NUM ;  Volley Log . d ( _ STR ) ; }
public static  List <  Episode > return New Episodes (  Context context ,  Channel channel ,  List <  Episode > new Episode List ) {  List <  Episode > new Episodes = new  Array List < > ( ) ;  List <  Episode > existing Episode List = get Episodes By Channel ( context , channel ) ;  Map <  String ,  Episode > existing Episode Map = new  Array Map < > ( existing Episode List . size ( ) ) ; for ( int i = _ NUM ; i < existing Episode List . size ( ) ; i ++ ) {  Episode episode = existing Episode List . get ( i ) ; existing Episode Map . put ( episode . get Generated Id ( ) , episode ) ; } for ( int i = _ NUM ; i < new Episode List . size ( ) ; i ++ ) {  Episode episode = new Episode List . get ( i ) ; if ( ! existing Episode Map . contains Key ( episode . get Generated Id ( ) ) ) { new Episodes . add ( episode ) ; } } return new Episodes ; }
private void use Our UIs ( ) { for (  String ui Name :  UI_ LIST ) { ui Name = ui Name + _ STR ; ui Defaults . put ( ui Name ,  UI_ PACKAGE_ PREFIX + ui Name ) ; } }
public void make Immutable ( ) { super . make Immutable ( ) ; }
public  KNNDistance Order Result run (  Database database ,  Relation <  O > relation ) { final  Distance Query <  O > distance Query = database . get Distance Query ( relation , get Distance Function ( ) ) ; final  KNNQuery <  O > knn Query = database . get KNNQuery ( distance Query , k + _ NUM ) ; final int size = ( int ) ( ( sample <= _ NUM ) ?  Math . ceil ( relation . size ( ) * sample ) : sample ) ;  DBIDs sample =  DBIDUtil . random Sample ( relation . get DBIDs ( ) , size , rnd ) ;  Finite Progress prog =  LOG . is Verbose ( ) ? new  Finite Progress ( _ STR , size ,  LOG ) : null ; double [ ] knn Distances = new double [ size ] ; int i = _ NUM ; for (  DBIDIter iditer = sample . iter ( ) ; iditer . valid ( ) ; iditer . advance ( ) , i ++ ) { final  KNNList neighbors = knn Query . get KNNFor DBID ( iditer , k + _ NUM ) ; knn Distances [ i ] = neighbors . get KNNDistance ( ) ;  LOG . increment Processed ( prog ) ; }  LOG . ensure Completed ( prog ) ; return new  KNNDistance Order Result ( knn Distances , k ) ; }
public static  Sparse Int Array adjust Position (  Sparse Int Array positions , int start Position , int end Position , int adjust By ) {  Sparse Int Array new Positions = new  Sparse Int Array ( ) ; for ( int i = _ NUM , size = positions . size ( ) ; i < size ; i ++ ) { int position = positions . key At ( i ) ; if ( position < start Position || position > end Position ) { new Positions . put ( position , positions . value At ( i ) ) ; } else if ( adjust By > _ NUM ) { new Positions . put ( position + adjust By , positions . value At ( i ) ) ; } else if ( adjust By < _ NUM ) { if ( position > start Position + adjust By && position <= start Position ) { ; } else { new Positions . put ( position + adjust By , positions . value At ( i ) ) ; } } } return new Positions ; }
private  Resolved Migration create Available Migration (  String version ) {  Resolved Migration migration = new  Resolved Migration ( ) ; migration . set Version (  Migration Version . from Version ( version ) ) ; migration . set Description ( _ STR ) ; migration . set Script ( _ STR ) ; migration . set Type (  Migration Type .  CQL ) ; return migration ; }
public boolean draw Image (  Image img , int x , int y ,  Color bg ,  Image Observer observer ) { if ( img == null ) { return _ BOOL ; } if ( is Hi DPIImage ( img ) ) { final int img W = img . get Width ( null ) ; final int img H = img . get Height ( null ) ; return draw Hi DPIImage ( img , x , y , x + img W , y + img H , _ NUM , _ NUM , img W , img H , bg , observer ) ; } try { return imagepipe . copy Image ( this , img , x , y , bg , observer ) ; } catch (  Invalid Pipe Exception e ) { try { revalidate All ( ) ; return imagepipe . copy Image ( this , img , x , y , bg , observer ) ; } catch (  Invalid Pipe Exception e2 ) { return _ BOOL ; } } finally { surface Data . mark Dirty ( ) ; } }
public void begin Display (  Display Event event ) throws  Model Control Exception { super . begin Display ( event ) ;  Server Site Model model = (  Server Site Model ) get Model ( ) ;  String server Name = (  String ) get Page Session Attribute (  PG_ ATTR_ SERVER_ NAME ) ;  Object [ ] param = { server Name } ; pt Model . set Page Title Text (  Message Format . format ( model . get Localized String ( _ STR ) , param ) ) ; set Display Field Value ( _ STR ,  Message Format . format ( model . get Localized String ( _ STR ) , param ) ) ; }
@  Override public void clear ( ) {  Arrays . fill ( this . d , _ NUM ) ;  Arrays . fill ( this . rhs , _ NUM ) ;  Arrays . fill ( this . r , _ NUM ) ;  Arrays . fill ( this . tol , _ NUM ) ;  Arrays . fill ( this . rss , _ NUM ) ;  Arrays . fill ( this . work_tolset , _ NUM ) ;  Arrays . fill ( this . work_sing , _ NUM ) ;  Arrays . fill ( this . x_sing , _ NUM ) ;  Arrays . fill ( this . lindep , _ BOOL ) ; for ( int i = _ NUM ; i < nvars ; i ++ ) { this . vorder [ i ] = i ; } this . nobs = _ NUM ; this . sserr = _ NUM ; this . sumy = _ NUM ; this . sumsqy = _ NUM ; this . rss_set = _ BOOL ; this . tol_set = _ BOOL ; }
public  Http Request header ( final  String name , final  String value ) { connection . set Request Property ( name , value ) ; return this ; }
@  Override public void clear ( ) { for ( int i = _ NUM ; i < array . length ( ) ; i ++ ) { array . set ( i , default Get Key Return Value ) ; } size . set ( _ NUM ) ; }
protected  File ensure Directory Exists ( final  Logger default Log , final  Logger shop Log , final  File shop Dir , final  Shop shop , final  String dirname ) throws  IOException { final  File dir = new  File ( shop Dir , dirname ) ; if ( ! dir . exists ( ) ) { default Log . info ( _ STR , dir . get Absolute Path ( ) , shop . get Code ( ) ) ; shop Log . info ( _ STR , dir . get Absolute Path ( ) , shop . get Code ( ) ) ; if ( ! dir . mkdirs ( ) ) { throw new  IOException ( _ STR + dir . get Absolute Path ( ) + _ STR + shop . get Code ( ) ) ; } } return dir ; }
public void remove Pause Listener (  Animator Pause Listener listener ) { if ( m Pause Listeners == null ) { return ; } m Pause Listeners . remove ( listener ) ; if ( m Pause Listeners . size ( ) == _ NUM ) { m Pause Listeners = null ; } }
private  Direct COSDefinition create COSDefinition (  String service ID ,  Set attr Names ) throws  UMSException {  Attr Set attrs = new  Attr Set ( ) ;  Attr attr = new  Attr (  ICOSDefinition .  DEFAULT_ NAMING_ ATTR , service ID ) ; attrs . add ( attr ) ; attr = new  Attr (  ICOSDefinition .  COSSPECIFIER , _ STR ) ; attrs . add ( attr ) ; attr = new  Attr (  ICOSDefinition .  COSATTRIBUTE ) ;  Iterator iter = attr Names . iterator ( ) ; while ( iter . has Next ( ) ) {  String attr Name = (  String ) iter . next ( ) ; attr . add Value ( attr Name ) ; } attrs . add ( attr ) ; return new  Direct COSDefinition ( attrs ) ; }
@  Override public synchronized void accept Data Set (  Data Set Event e ) { m_busy = _ BOOL ; if ( m_completed == null ) { m_completed = new  Hash Map <  Object ,  Instances > ( ) ; m_temp Batch Files = new  Hash Map <  Object ,  File > ( ) ; }  Object source = e . get Source ( ) ; if ( m_completed . contains Key ( source ) ) { if ( m_log != null && ! e . is Structure Only ( ) ) {  String msg = status Message Prefix ( ) + _ STR ; m_log . status Message ( msg ) ; m_log . log Message ( _ STR + msg + _ STR + _ STR + _ STR ) ; } m_completed = new  Hash Map <  Object ,  Instances > ( ) ; m_temp Batch Files = new  Hash Map <  Object ,  File > ( ) ; }  Instances header = new  Instances ( e . get Data Set ( ) , _ NUM ) ; m_completed . put ( source , header ) ; try {  File tmp F =  File . create Temp File ( _ STR ,  Serialized Instances Loader .  FILE_ EXTENSION ) ; tmp F . delete On Exit ( ) ;  Object Output Stream oos = new  Object Output Stream ( new  Buffered Output Stream ( new  File Output Stream ( tmp F ) ) ) ; oos . write Object ( e . get Data Set ( ) ) ; oos . flush ( ) ; oos . close ( ) ; m_temp Batch Files . put ( source , tmp F ) ; } catch (  IOException e1 ) { stop ( ) ; e1 . print Stack Trace ( ) ;  String msg = status Message Prefix ( ) + _ STR ; if ( m_log != null ) { m_log . status Message ( msg ) ; m_log . log Message ( _ STR + e1 . get Message ( ) ) ; } m_busy = _ BOOL ; return ; } if ( m_completed . size ( ) == m_listenees . size ( ) ) { try {  Instances output = make Output Header ( ) ; if ( m_log != null ) {  String msg = status Message Prefix ( ) + _ STR ; m_log . status Message ( msg ) ; m_log . log Message ( _ STR + msg ) ; } for (  File f : m_temp Batch Files . values ( ) ) {  Object Input Stream ois = new  Object Input Stream ( new  Buffered Input Stream ( new  File Input Stream ( f ) ) ) ;  Instances temp = (  Instances ) ois . read Object ( ) ; ois . close ( ) ; for ( int i = _ NUM ; i < temp . num Instances ( ) ; i ++ ) {  Instance converted = make Output Instance ( output , temp . instance ( i ) ) ; output . add ( converted ) ; } }  Data Set Event d = new  Data Set Event ( this , output ) ; notify Data Listeners ( d ) ; } catch (  Exception ex ) { stop ( ) ; ex . print Stack Trace ( ) ;  String msg = status Message Prefix ( ) + _ STR ; if ( m_log != null ) { m_log . status Message ( msg ) ; m_log . log Message ( _ STR + ex . get Message ( ) ) ; } } m_completed = null ; m_temp Batch Files = null ; if ( m_log != null ) { m_log . status Message ( status Message Prefix ( ) + _ STR ) ; } } m_busy = _ BOOL ; }
public void add Component (  Multiblock Component component ) { if ( get Component For Location ( component . get Relative Position ( ) ) != null ) throw new  Illegal Argument Exception ( _ STR ) ; components . add ( component ) ; change Axis For New Component ( component . get Relative Position ( ) ) ; calculate Cost For New Component ( component ) ; add Component To Location Cache ( component ) ; }
public static void open Url ( final  Activity context , final  String url ) { open Url ( context , url , _ BOOL ) ; }
public  Byte Packed Raster (  Sample Model sample Model ,  Point origin ) { this ( sample Model , sample Model . create Data Buffer ( ) , new  Rectangle ( origin . x , origin . y , sample Model . get Width ( ) , sample Model . get Height ( ) ) , origin , null ) ; }
public static  Optional <  Notification > try Find ( @  Nonnull final  Iterable <  Notification > notifications , final long id ) { final com . google . common . base .  Optional <  Notification > result =  Iterables . try Find ( notifications , null ) ; if ( result . is Present ( ) ) { return  Optional . of ( result . get ( ) ) ; } return  Optional . empty ( ) ; }
private boolean execute (  String command ,  File arg ,  List <  String > lines ) {  Process Builder pb = new  Process Builder ( command , arg . get Absolute Path ( ) ) ; pb . redirect Error Stream ( _ BOOL ) ; try {  Process proc = pb . start ( ) ;  Buffered Reader reader = new  Buffered Reader ( new  Input Stream Reader ( proc . get Input Stream ( ) ) ) ;  String line ; while ( ( line = reader . read Line ( ) ) != null ) { lines . add ( line ) ; } proc . wait For ( ) ; return proc . exit Value ( ) == _ NUM ; } catch (  Exception e ) { log . error ( _ STR + command + _ STR + arg , e ) ; lines . add ( e . get Message ( ) ) ; return _ BOOL ; } }
@  Request Processing ( value = _ STR , method =  HTTPRequest Method .  POST ) @  Before ( advice Class = {  Stopwatch Start Advice . class ,  Mall Admin Check . class } ) @  After ( advice Class =  Stopwatch End Advice . class ) public void charge Point ( final  HTTPRequest Context context , final  Http Servlet Request request , final  Http Servlet Response response ) throws  Exception { final  String user Name = request . get Parameter (  User .  USER_ NAME ) ; final  String point Str = request . get Parameter (  Common .  POINT ) ; final  String memo = request . get Parameter (  Common .  MEMO ) ; if (  String Utils . is Blank ( point Str ) || !  String Utils . is Numeric ( memo ) ) { final  Abstract Free Marker Renderer renderer = new  Skin Renderer ( ) ; context . set Renderer ( renderer ) ; renderer . set Template Name ( _ STR ) ; final  Map <  String ,  Object > data Model = renderer . get Data Model ( ) ; data Model . put (  Keys .  MSG , _ STR ) ; filler . fill Header And Footer ( request , response , data Model ) ; return ; } final  JSONObject user = user Query Service . get User By Name ( user Name ) ; if ( null == user ) { final  Abstract Free Marker Renderer renderer = new  Skin Renderer ( ) ; context . set Renderer ( renderer ) ; renderer . set Template Name ( _ STR ) ; final  Map <  String ,  Object > data Model = renderer . get Data Model ( ) ; data Model . put (  Keys .  MSG , _ STR + user Name + _ STR ) ; filler . fill Header And Footer ( request , response , data Model ) ; return ; } final  JSONObject current User = (  JSONObject ) request . get Attribute (  User .  USER ) ; try { final int point =  Integer . value Of ( point Str ) ; final  String transfer Id = pointtransfer Mgmt Service . transfer (  Pointtransfer .  ID_ C_ SYS , user . opt String (  Keys .  OBJECT_ ID ) ,  Pointtransfer .  TRANSFER_ TYPE_ C_ CHARGE , point , memo + _ STR + current User . opt String (  Keys .  OBJECT_ ID ) ) ; final  JSONObject notification = new  JSONObject ( ) ; notification . put (  Notification .  NOTIFICATION_ USER_ ID , user . opt String (  Keys .  OBJECT_ ID ) ) ; notification . put (  Notification .  NOTIFICATION_ DATA_ ID , transfer Id ) ; notification Mgmt Service . add Point Charge Notification ( notification ) ; } catch ( final  Exception e ) { final  Abstract Free Marker Renderer renderer = new  Skin Renderer ( ) ; context . set Renderer ( renderer ) ; renderer . set Template Name ( _ STR ) ; final  Map <  String ,  Object > data Model = renderer . get Data Model ( ) ; data Model . put (  Keys .  MSG , e . get Message ( ) ) ; filler . fill Header And Footer ( request , response , data Model ) ; return ; } response . send Redirect (  Latkes . get Serve Path ( ) + _ STR ) ; }
public  Multiple Composite Space Predicate (  List <  ISpace Predicate > operands ) { if ( operands == null ) throw new  Illegal Argument Exception ( _ STR ) ; for ( int i = _ NUM ; i < operands . size ( ) ; i ++ ) if ( operands . get ( i ) == null ) throw new  Illegal Argument Exception ( _ STR + i + _ STR ) ; this . _operands List = operands ; }
public static  String replace Html Entities ( final  String s ) { final  String Builder t = new  String Builder ( ) ; for ( int i = _ NUM , n = s . length ( ) ; i < n ; i ++ ) { final char c = s . char At ( i ) ; if ( c == _ STR ) { final int j = s . index Of ( _ STR , i ) ; if ( j >= _ NUM ) { final  Character unicode =  HTML_ ENTITY_ TO_ UNICODE_ MAP . get ( s . substring ( i + _ NUM , j ) ) ; if ( unicode != null ) { t . append ( ( char ) unicode ) ; i = j ; continue ; } } } t . append ( c ) ; } return t . to String ( ) ; }
public  String generate Challan ( final  Receipt Header receipt , final boolean flag ) { final  List <  Bill Receipt Info > receipt List = new  Array List <  Bill Receipt Info > ( _ NUM ) ; receipt List . add ( new  Bill Receipt Info Impl ( receipt , egov Common , new  Receipt Header ( ) , chart Of Accounts Hibernate DAO , persistence Service ) ) ; final  String template Name =  Collection Constants .  CHALLAN_ TEMPLATE_ NAME ; final  Map <  String ,  Object > report Params = new  Hash Map <  String ,  Object > ( _ NUM ) ; report Params . put ( _ STR , egov Common ) ; final  Report Request report Input = new  Report Request ( template Name , receipt List , report Params ) ; report Input . set Print Dialog On Open Report ( flag ) ; return report Viewer Util . add Report To Temp Cache ( collections Util . create Report ( report Input ) ) ; }
public int read ( byte [ ] bytes , int offset , int count ) throws  IOException { if ( bytes == null ) throw new  Illegal Argument Exception ( _ STR ) ; int starting Count = count ; int copy Count =  Math . min ( limit - position , count ) ; while ( _ BOOL ) {  System . arraycopy ( buffer , position , bytes , offset , copy Count ) ; position += copy Count ; count -= copy Count ; if ( count == _ NUM ) break ; offset += copy Count ; copy Count = optional ( count ) ; if ( copy Count == - _ NUM ) { if ( starting Count == count ) return - _ NUM ; break ; } if ( position == limit ) break ; } return starting Count - count ; }
public void test_concurrent_modification_insert_split_root_leaf ( ) { final  BTree btree ; {  Index Metadata md = new  Index Metadata (  UUID . random UUID ( ) ) ; md . set Branching Factor ( _ NUM ) ; btree =  BTree . create ( new  Simple Memory Raw Store ( ) , md ) ; btree . insert ( _ NUM , _ STR ) ; btree . insert ( _ NUM , _ STR ) ; btree . insert ( _ NUM , _ STR ) ; } {  ITuple Cursor2 <  String > cursor = new Cursor ( btree ) ; assert Equals ( new  Test Tuple <  String > ( _ NUM , _ STR ) , cursor . seek ( _ NUM ) ) ; assert Equals ( new  Test Tuple <  String > ( _ NUM , _ STR ) , cursor . tuple ( ) ) ; btree . insert ( _ NUM , _ STR ) ; assert Equals (  Test Key Builder . as Sort Key ( _ NUM ) , cursor . current Key ( ) ) ; assert Equals ( new  Test Tuple <  String > ( _ NUM , _ STR ) , cursor . tuple ( ) ) ; assert Equals ( new  Test Tuple <  String > ( _ NUM , _ STR ) , cursor . prior ( ) ) ; assert Equals ( new  Test Tuple <  String > ( _ NUM , _ STR ) , cursor . tuple ( ) ) ; btree . remove ( _ NUM ) ; assert Equals (  Test Key Builder . as Sort Key ( _ NUM ) , cursor . current Key ( ) ) ; assert Equals ( null , cursor . tuple ( ) ) ; assert Equals ( new  Test Tuple <  String > ( _ NUM , _ STR ) , cursor . next ( ) ) ; btree . remove ( _ NUM ) ; assert Equals (  Test Key Builder . as Sort Key ( _ NUM ) , cursor . current Key ( ) ) ; assert Equals ( null , cursor . tuple ( ) ) ; btree . insert ( _ NUM , _ STR ) ; assert Equals (  Test Key Builder . as Sort Key ( _ NUM ) , cursor . current Key ( ) ) ; assert Equals ( null , cursor . tuple ( ) ) ; assert Equals ( new  Test Tuple <  String > ( _ NUM , _ STR ) , cursor . next ( ) ) ; assert Equals ( new  Test Tuple <  String > ( _ NUM , _ STR ) , cursor . tuple ( ) ) ; } }
public void add Im (  Im Entity im ) { ims . add ( im ) ; }
public void copy String (  String encoding ,  String s ) throws  Unsupported Encoding Exception { super . set Content Encoding ( encoding ) ; content = s . get Bytes ( encoding ) ; }
private void compare Surrogate Key Data (  List <  String > data ,  Dictionary reverse Dictionary ) { int surrogate Key = _ NUM ; for ( int i = _ NUM ; i < data . size ( ) ; i ++ ) { surrogate Key ++ ; assert True ( surrogate Key == reverse Dictionary . get Surrogate Key ( data . get ( i ) ) ) ; } }
public static  String Buffer string Substitution (  String arg Str ,  Map vars ) {  String Buffer arg Buf = new  String Buffer ( ) ; for ( int c Idx = _ NUM ; c Idx < arg Str . length ( ) ; ) { char ch = arg Str . char At ( c Idx ) ; switch ( ch ) { case _ STR :  String Buffer name Buf = new  String Buffer ( ) ; for ( ++ c Idx ; c Idx < arg Str . length ( ) ; ++ c Idx ) { ch = arg Str . char At ( c Idx ) ; if ( ch == _ STR ||  Character . is Letter Or Digit ( ch ) ) name Buf . append ( ch ) ; else break ; } if ( name Buf . length ( ) > _ NUM ) {  String value = (  String ) vars . get ( name Buf . to String ( ) ) ; if ( value != null ) { arg Buf . append ( value ) ; } } break ; default : arg Buf . append ( ch ) ; ++ c Idx ; break ; } } return arg Buf ; }
public static int patch Less Memory (  Random Access File old File ,  File new File ,  File diff File , int ext Len ) throws  IOException { if ( old File == null || old File . length ( ) <= _ NUM ) { return  RETURN_ OLD_ FILE_ ERR ; } if ( new File == null ) { return  RETURN_ NEW_ FILE_ ERR ; } if ( diff File == null || diff File . length ( ) <= _ NUM ) { return  RETURN_ DIFF_ FILE_ ERR ; } byte [ ] diff Bytes = new byte [ ( int ) diff File . length ( ) ] ;  Input Stream diff Input Stream = new  File Input Stream ( diff File ) ; try {  BSUtil . read From Stream ( diff Input Stream , diff Bytes , _ NUM , diff Bytes . length ) ; } finally { diff Input Stream . close ( ) ; } return patch Less Memory ( old File , ( int ) old File . length ( ) , diff Bytes , diff Bytes . length , new File , ext Len ) ; }
public boolean run ( ) { try { if ( m Executor . is Shutdown ( ) || m Executor . is Terminated ( ) ) {  Log . e (  TAG , _ STR ) ; m Executor =  Executors . new Single Thread Executor ( ) ; } for (  Task task : tasks ) { final  Thread Runnable thread Runnable = new  Thread Runnable ( task ) ; final  Future future = m Executor . submit ( thread Runnable ) ; runable Map . put ( thread Runnable , future ) ; } tasks . clear ( ) ; } catch (  Exception  Rejected Execution Exception ) {  Log . e (  TAG , _ STR ,  Rejected Execution Exception ) ; return _ BOOL ; } return _ BOOL ; }
public  Date parse (  String text ) throws  Parser Exception { text = text . trim ( ) ; int length = text . length ( ) ; if ( length ==  LONG_ DATE_ FORMAT . length ( ) ) { return parse ( text ,  LONG_ DATE_ FORMAT ) ; } if ( length ==  MEDIUM_ DATE_ FORMAT . length ( ) ) { return parse ( text ,  MEDIUM_ DATE_ FORMAT ) ; } return parse ( text ,  SHORT_ DATE_ FORMAT ) ; }
protected static @  Not Null  String convert Map To Groovy Source ( @  Not Null  Map <  String ,  Object > map ) {  String Builder sb = new  String Builder ( ) ; for (  Map .  Entry <  String ,  Object > entry : map . entry Set ( ) ) { if ( sb . length ( ) > _ NUM ) { sb . append ( _ STR ) ; } sb . append ( entry . get Key ( ) ) ; sb . append ( _ STR ) ; sb . append ( convert Value To Groovy Source ( entry . get Value ( ) ) ) ; } return sb . to String ( ) ; }
private boolean is Media Type Match (  Media Type media Type ,  Media Type range Pattern ) {  String  WILDCARD = _ STR ;  String range Pattern Type = range Pattern . get Type ( ) ;  String range Pattern Subtype = range Pattern . get Subtype ( ) ; return ( range Pattern Type . equals (  WILDCARD ) || range Pattern Type . equals ( media Type . get Type ( ) ) ) && ( range Pattern Subtype . equals (  WILDCARD ) || range Pattern Subtype . equals ( media Type . get Subtype ( ) ) ) ; }
public static void clear Image (  Buffered Image image ,  Color bg Color ) {  Graphics2 D g2d = (  Graphics2 D ) image . get Graphics ( ) ; g2d . set Color ( bg Color ) ; g2d . fill Rect ( _ NUM , _ NUM , image . get Width ( ) , image . get Height ( ) ) ; g2d . dispose ( ) ; }
public long start (  String name ) { this . name = name ; start Time =  System . current Time Millis ( ) ; log . debug ( _ STR + name ) ; return start Time ; }
public void next (  Controller Animator animator ) { if ( animator == null ) throw new  Null Pointer Exception ( _ STR ) ; if ( iterator . has Next ( ) ) {  View current View = iterator . next ( ) ; if ( is Using Default Listener ( ) ) current View . set On Click Listener ( null ) ; if ( iterator . next Index ( ) < m Views . size ( ) ) {  View next View = m Views . get ( iterator . next Index ( ) ) ; if ( is Using Default Listener ( ) ) next View . set On Click Listener ( listener ) ; animator . set Old View ( current View ) ; animator . set New View ( next View ) ; current View . start Animation ( animator ) ; if ( iterator . next Index ( ) == m Views . size ( ) - _ NUM ) if ( has Controller Listener ( ) ) m Listener . on End Reached ( ) ; } else { if ( m Loop ) { iterator = m Views . list Iterator ( ) ;  View next View = m Views . get ( _ NUM ) ; if ( m Use Default Listener ) next View . set On Click Listener ( listener ) ; animator . set Old View ( current View ) ; animator . set New View ( next View ) ; current View . start Animation ( animator ) ; } } } }
protected static  Method resolve Java Method (  Bsh Class Manager bcm ,  Class clas ,  String name ,  Class [ ] types , boolean static Only ) throws  Util Eval Error { if ( clas == null ) throw new  Interpreter Error ( _ STR ) ;  Method method = null ; if ( bcm == null )  Interpreter . debug ( _ STR ) ; else method = bcm . get Resolved Method ( clas , name , types , static Only ) ; if ( method == null ) { boolean public Only = !  Capabilities . have Accessibility ( ) ; try { method = find Overloaded Method ( clas , name , types , public Only ) ; } catch (  Security Exception e ) { throw new  Util Target Error ( _ STR + clas , e ) ; } check Found Static Method ( method , static Only , clas ) ; if ( method != null && ! public Only ) { try {  Reflect Manager .  RMSet Accessible ( method ) ; } catch (  Util Eval Error e ) { } } if ( method != null && bcm != null ) bcm . cache Resolved Method ( clas , types , method ) ; } return method ; }
private void destroy Beans (  Application Associate application Associate ,  Map <  String ,  Object > view Map ) { for (  Map .  Entry <  String ,  Object > entry : view Map . entry Set ( ) ) {  String name = entry . get Key ( ) ;  Object bean = entry . get Value ( ) ; try { if ( application Associate != null ) {  Bean Manager bean Manager = application Associate . get Bean Manager ( ) ; if ( bean Manager != null && bean Manager . is Managed ( name ) ) { bean Manager . destroy ( name , bean ) ; } } } catch (  Exception exception ) { if (  LOGGER . is Loggable (  Level .  WARNING ) ) {  LOGGER . log (  Level .  WARNING , _ STR + name , exception ) ; } } } }
private static void save (  Bitmap src ,  String file Name ,  Bitmap .  Compress Format format , int quality ) throws  Image Save Exception {  File Output Stream output Stream = null ; try { output Stream = new  File Output Stream ( file Name ) ; src . compress ( format , quality , output Stream ) ; output Stream . close ( ) ; } catch (  IOException e ) { throw new  Image Save Exception ( e ) ; } finally { if ( output Stream != null ) { try { output Stream . close ( ) ; } catch (  IOException e1 ) { e1 . print Stack Trace ( ) ; } } } }
@  Override public  Node item ( int index ) {  Node this Node ; if ( root Node . changes ( ) != changes ) { nodes = new  Array List ( ) ; changes = root Node . changes ( ) ; } final int current Size = nodes . size ( ) ; if ( index < current Size ) { return (  Node ) nodes . get ( index ) ; } else { if ( current Size == _ NUM ) { this Node = root Node ; } else { this Node = (  Node Impl ) ( nodes . get ( current Size - _ NUM ) ) ; } while ( this Node != null && index >= nodes . size ( ) ) { this Node = next Matching Element After ( this Node ) ; if ( this Node != null ) { nodes . add ( this Node ) ; } } return this Node ; } }
public static int height ( final  Segment document , final int max Width , final  Font Renderer renderer ) { int current X = _ NUM ; int current Y = _ NUM ;  Segment segment = document ; while ( segment != null ) { current Y += segment . next Y ( current X , max Width , renderer ) ; current X = segment . next X ( current X , max Width , renderer ) ; segment = segment . next ( ) ; } return current Y ; }
public  GTSEncoder ( long base Timestamp , byte [ ] key ) { this . base Timestamp = base Timestamp ; this . stream = new  Byte Array Output Stream ( ) ; this . wrapping Key = null == key ? null :  Arrays . copy Of ( key , key . length ) ; }
public static  Coordinate Sequence decode ( final  String encoded Path ) { int len = encoded Path . length ( ) ; final  List <  Coordinate > path = new  Array List < > ( ) ; int index = _ NUM ; int lat = _ NUM ; int lng = _ NUM ; while ( index < len ) { int result = _ NUM ; int shift = _ NUM ; int b ; do { b = encoded Path . char At ( index ++ ) - _ NUM - _ NUM ; result += b << shift ; shift += _ NUM ; } while ( b >= _ NUM ) ; lat += ( result & _ NUM ) != _ NUM ? ~ ( result > > _ NUM ) : ( result > > _ NUM ) ; result = _ NUM ; shift = _ NUM ; do { b = encoded Path . char At ( index ++ ) - _ NUM - _ NUM ; result += b << shift ; shift += _ NUM ; } while ( b >= _ NUM ) ; lng += ( result & _ NUM ) != _ NUM ? ~ ( result > > _ NUM ) : ( result > > _ NUM ) ; path . add ( new  Coordinate ( lng * _ NUM , lat * _ NUM ) ) ; } return new  Packed Coordinate Sequence .  Double ( path . to Array ( new  Coordinate [ path . size ( ) ] ) ) ; }
public static <  T >  List <  T > [ ] split (  Collection <  T > set , double [ ] weights ) { if ( set . size ( ) >= weights . length ) { @  Suppress Warnings ( _ STR )  List <  T > [ ] arrays = new  List [ weights . length ] ; double totalweight = _ NUM ; for ( double w : weights ) totalweight += w ; double [ ] relative Weight = new double [ weights . length ] ; for ( int i = _ NUM ; i < weights . length ; i ++ ) relative Weight [ i ] = weights [ i ] / totalweight ; int [ ] list Sizes = new int [ weights . length ] ; for ( int i = _ NUM ; i < weights . length ; i ++ ) list Sizes [ i ] = ( int ) ( weights [ i ] / totalweight * ( double ) set . size ( ) ) ; int allocated = _ NUM ; for ( int ls : list Sizes ) allocated += ls ; int remainder = set . size ( ) - allocated ; list Sizes [ _ NUM ] += remainder ;  Iterator <  T > it = set . iterator ( ) ; for ( int i = _ NUM ; i < list Sizes . length ; i ++ ) {  List <  T > segment = new  Array List < > ( list Sizes [ i ] ) ; for ( int k = _ NUM ; k < list Sizes [ i ] ; k ++ ) { segment . add ( it . next ( ) ) ; } arrays [ i ] = segment ; } return arrays ; } else { throw new  Illegal Argument Exception ( _ STR ) ; } }
public void close ( ) { flush ( ) ; if ( writer != null ) { try { writer . close ( ) ; } catch (  IOException e ) {  Debug . error ( file Name + _ STR , e ) ; } } stop Buffer Timer ( ) ; }
public int eval0 (  INode state ) {  Jumping Solitaire State node = (  Jumping Solitaire State ) state ;  Double Linked List <  IMove > mv = node . valid Moves ( ) ; int hn = ( mv . size ( ) ) * _ NUM ; int nf = _ NUM ; for ( int i = _ NUM ; i < node . filled . length ; i ++ ) { if ( node . filled [ i ] ) nf ++ ; } int ni = num Isolated ( node ) ; if ( ni == _ NUM ) { hn += ( int )  Math . sqrt ( nf ) ; } else { hn += nf - ni * ni ; } int gn = _ NUM ;  Depth Transition t = (  Depth Transition ) state . stored Data ( ) ; if ( t != null ) { gn = t . depth ; } return gn + hn ; }
public void put String (  String s ) { ensure Capacity ( ( s . length ( ) * _ NUM ) + _ NUM ) ;  System . arraycopy ( s . get Bytes ( ) , _ NUM , this . byte Buffer , this . position , s . length ( ) ) ; this . position += s . length ( ) ; this . byte Buffer [ this . position ++ ] = _ NUM ; }
private boolean has Unexpected Italian Leading Zero (  Phone Number number ) { return number . is Italian Leading Zero ( ) && ! is Leading Zero Possible ( number . get Country Code ( ) ) ; }
public  String normalize Uri (  String uri ) { if ( uri != null && ! uri . ends With ( _ STR ) ) { uri += _ STR ; } return uri ; }
@  Override public  App Configuration Entry [ ] engine Get App Configuration Entry (  String application Name ) {  List <  App Configuration Entry > list = null ; synchronized ( configuration ) { list = configuration . get ( application Name ) ; } if ( list == null || list . size ( ) == _ NUM ) { return null ; }  App Configuration Entry [ ] entries = new  App Configuration Entry [ list . size ( ) ] ;  Iterator <  App Configuration Entry > iterator = list . iterator ( ) ; for ( int i = _ NUM ; iterator . has Next ( ) ; i ++ ) {  App Configuration Entry e = iterator . next ( ) ; entries [ i ] = new  App Configuration Entry ( e . get Login Module Name ( ) , e . get Control Flag ( ) , e . get Options ( ) ) ; } return entries ; }
public static  String convert To ARGB ( int color ) {  String alpha =  Integer . to Hex String (  Color . alpha ( color ) ) ;  String red =  Integer . to Hex String (  Color . red ( color ) ) ;  String green =  Integer . to Hex String (  Color . green ( color ) ) ;  String blue =  Integer . to Hex String (  Color . blue ( color ) ) ; if ( alpha . length ( ) == _ NUM ) { alpha = _ STR + alpha ; } if ( red . length ( ) == _ NUM ) { red = _ STR + red ; } if ( green . length ( ) == _ NUM ) { green = _ STR + green ; } if ( blue . length ( ) == _ NUM ) { blue = _ STR + blue ; } return _ STR + alpha + red + green + blue ; }
@  After Class public void stop Jetty ( ) throws  Exception { server . stop ( ) ; }
protected  Date Time Data parse (  String str ) throws  Schema Date Time Exception {  Date Time Data date = new  Date Time Data ( str , this ) ; int len = str . length ( ) ; date . year =  YEAR ; if ( str . char At ( _ NUM ) != _ STR || str . char At ( _ NUM ) != _ STR ) { throw new  Schema Date Time Exception ( _ STR + str ) ; } date . month = parse Int ( str , _ NUM , _ NUM ) ; int start = _ NUM ; if ( str . char At ( start ++ ) != _ STR ) { throw new  Schema Date Time Exception ( _ STR + str ) ; } date . day = parse Int ( str , start , start + _ NUM ) ; if (  MONTHDAY_ SIZE < len ) { if ( ! is Next Char UTCSign ( str ,  MONTHDAY_ SIZE , len ) ) { throw new  Schema Date Time Exception ( _ STR + str ) ; } else { get Time Zone ( str , date ,  MONTHDAY_ SIZE , len ) ; } } validate Date Time ( date ) ; save Unnormalized ( date ) ; if ( date . utc != _ NUM && date . utc != _ STR ) { normalize ( date ) ; } date . position = _ NUM ; return date ; }
public static boolean is Node Group Available (  Service Host host ,  Node Group State local State ) { if (  Node Group Utils . is Membership Settled ( host , host . get Maintenance Interval Micros ( ) , local State ) &&  Node Group Utils . has Membership Quorum ( host , local State ) ) { return _ BOOL ; } return _ BOOL ; }
private  Array List <  String > load System Languages ( ) { s_logger . log (  Level .  FINE , _ STR , get Direction ( ) ) ;  Array List <  String > system Clients = new  Array List <  String > ( ) ;  String sql = s_db Engine . sql AD_get System Languages ( get Vendor ( ) , get Catalog ( ) , get Schema ( ) ) ;  Result Set rs = null ;  Statement stmt = null ; if ( is Object Exists ( _ STR , m_tables ) ) { stmt = set Statement ( ) ; rs = execute Query ( stmt , sql ) ; while ( get Result Set Next ( rs ) ) {  String s = get Result Set String ( rs , _ STR ) ; system Clients . add ( s ) ; } release Result Set ( rs ) ; release Statement ( stmt ) ; }  String Buffer result = new  String Buffer ( ) ; for (  Iterator <  String > it = system Clients . iterator ( ) ; it . has Next ( ) ; ) {  String s = it . next ( ) ; if ( result . length ( ) > _ NUM ) result . append ( _ STR ) ; result . append ( s ) ; } s_logger . log (  Level .  FINE , _ STR , new  Object [ ] { get Direction ( ) , result } ) ; s_logger . flush ( ) ; return system Clients ; }
public boolean send (  Xmpp Msg message ,  String to ) { if ( to == null ) {  Log . i ( _ STR + message . to Short String ( ) + _ STR ) ; } else {  Log . i ( _ STR + message . to Short String ( ) + _ STR + to ) ; }  Message msg ;  Multi User Chat muc = null ; if ( to == null ) { msg = new  Message ( ) ; } else { msg = new  Message ( to ) ; muc = m Xmpp Muc . get Room Via Room Name ( to ) ; } msg . set From ( m Connection . get User ( ) ) ; msg . set Body ( m Settings . format Responses ? message . generate Fmt Txt ( ) : message . generate Txt ( ) ) ; try {  XHTMLManager . add Body ( msg , message . generate XHTMLText ( ) ) ; } catch (  Exception e ) {  Log . d ( _ STR + e . get Message ( ) ) ; } msg . set Type ( muc == null ?  Message .  Type . chat :  Message .  Type . groupchat ) ; if ( is Connected ( ) ) { if ( muc == null && to == null ) { return  Xmpp Multiple Recipient Manager . send ( m Connection , msg ) ; } else if ( muc == null ) { try { m Connection . send Stanza ( msg ) ; } catch (  Smack Exception .  Not Connected Exception e ) {  Log . e ( _ STR + e . get Message ( ) ) ; return _ BOOL ; } } else { try { muc . send Message ( msg ) ; } catch (  Exception e ) {  Log . e ( _ STR + e . get Message ( ) ) ; return _ BOOL ; } } return _ BOOL ; } else { boolean result = m Client Offline Messages . add Offline Message ( msg ) ;  Log . d ( _ STR + message . to Short String ( ) + _ STR + status String ( ) ) ; return result ; } }
private synchronized void close Output Stream Quietly ( ) { if ( ! m Closed ) { try { m Output Stream . close ( ) ; report Decoded Size If Applicable ( ) ; } catch (  IOException e ) {  CLog . write To Console ( m Network Peer Manager ,  Console .  Message Level .  ERROR ,  Console .  Message Source .  NETWORK , _ STR + e ) ; } finally { m Closed = _ BOOL ; } } }
public  Builder ( ) { }
public  Str Builder insert ( int index , final boolean value ) { validate Index ( index ) ; if ( value ) { ensure Capacity ( size + _ NUM ) ;  System . arraycopy ( buffer , index , buffer , index + _ NUM , size - index ) ; buffer [ index ++ ] = _ STR ; buffer [ index ++ ] = _ STR ; buffer [ index ++ ] = _ STR ; buffer [ index ] = _ STR ; size += _ NUM ; } else { ensure Capacity ( size + _ NUM ) ;  System . arraycopy ( buffer , index , buffer , index + _ NUM , size - index ) ; buffer [ index ++ ] = _ STR ; buffer [ index ++ ] = _ STR ; buffer [ index ++ ] = _ STR ; buffer [ index ++ ] = _ STR ; buffer [ index ] = _ STR ; size += _ NUM ; } return this ; }
private  List <  String > missing Weapons ( final  Player player , final boolean hash ) { final  List <  String > result = new  Linked List <  String > ( ) ;  String done Text = player . get Quest (  QUEST_ SLOT ) ; if ( done Text == null ) { done Text = _ STR ; } final  List <  String > done =  Arrays . as List ( done Text . split ( _ STR ) ) ; for (  String weapon : needed Weapons ) { if ( ! done . contains ( weapon ) ) { if ( hash ) { weapon = _ STR + weapon ; } result . add ( weapon ) ; } } return result ; }
private static void add Id ( final  String Builder buf , final byte [ ] id ) { buf . append ( _ STR ) ; boolean backslash = _ BOOL ; for ( final byte b : id ) { buf . append ( ( char ) ( b & _ NUM ) ) ; if ( b == _ STR && backslash ) { buf . append ( _ STR ) ; } else { backslash = b == _ STR ; } } buf . append ( _ STR ) ; }
final  V do Remove (  Object key ,  Object value ) { if ( key == null ) throw new  Null Pointer Exception ( ) ;  Comparator < ? super  K > cmp = comparator ; outer : for ( ; ; ) { for (  Node <  K ,  V > b = find Predecessor ( key , cmp ) , n = b . next ; ; ) {  Object v ; int c ; if ( n == null ) break outer ;  Node <  K ,  V > f = n . next ; if ( n != b . next ) break ; if ( ( v = n . value ) == null ) { n . help Delete ( b , f ) ; break ; } if ( b . value == null || v == n ) break ; if ( ( c = cpr ( cmp , key , n . key ) ) < _ NUM ) break outer ; if ( c > _ NUM ) { b = n ; n = f ; continue ; } if ( value != null && ! value . equals ( v ) ) break outer ; if ( ! n . cas Value ( v , null ) ) break ; if ( ! n . append Marker ( f ) || ! b . cas Next ( n , f ) ) find Node ( key ) ; else { find Predecessor ( key , cmp ) ; if ( head . right == null ) try Reduce Level ( ) ; } @  Suppress Warnings ( _ STR )  V vv = (  V ) v ; return vv ; } } return null ; }
private static  Drill Down Query add Drill Downs ( long timestamp Sec ,  Index State state ,  Request r ,  Query q ,  Map <  String ,  Field Def > dynamic Fields ) {  Drill Down Query ddq = new  Drill Down Query ( state . facets Config , q ) ; if ( r . has Param ( _ STR ) ) {  List <  Object > drill Down List = r . get List ( _ STR ) ; if ( ! drill Down List . is Empty ( ) ) { for (  Object o : drill Down List ) {  Request fr = (  Request ) o ;  String f = fr . get String ( _ STR ) ;  Field Def fd = dynamic Fields . get ( f ) ; if ( fd == null ) { fr . fail ( _ STR , _ STR + f + _ STR ) ; fd = null ; } if ( fr . has Param ( _ STR ) ) { ddq . add ( fd . name , parse Query ( timestamp Sec , null , state , r . get Struct ( _ STR ) , fd . name , null , dynamic Fields ) ) ; } else if ( fr . has Param ( _ STR ) ) {  Request rr = fr . get Struct ( _ STR ) ;  Range range ; if ( fd . value Type ==  Field Def .  Field Value Type .  INT || fd . value Type ==  Field Def .  Field Value Type .  LONG ) { range = new  Long Range ( rr . get String ( _ STR ) , rr . get Long ( _ STR ) , rr . get Boolean ( _ STR ) , rr . get Long ( _ STR ) , rr . get Boolean ( _ STR ) ) ; } else if ( fd . value Type ==  Field Def .  Field Value Type .  FLOAT || fd . value Type ==  Field Def .  Field Value Type .  DOUBLE || fd . value Type ==  Field Def .  Field Value Type .  VIRTUAL ) { range = new  Double Range ( rr . get String ( _ STR ) , rr . get Double ( _ STR ) , rr . get Boolean ( _ STR ) , rr . get Double ( _ STR ) , rr . get Boolean ( _ STR ) ) ; } else { fr . fail ( _ STR , _ STR + fd . name + _ STR ) ; range = null ; }  Value Source value Source ; if ( fd . value Source == null ) { if ( fd . value Type ==  Field Def .  Field Value Type .  INT ) { value Source = new  Int Field Source ( fd . name ) ; } else if ( fd . value Type ==  Field Def .  Field Value Type .  LONG ) { value Source = new  Long Field Source ( fd . name ) ; } else if ( fd . value Type ==  Field Def .  Field Value Type .  DOUBLE ) { value Source = new  Double Field Source ( fd . name ) ; } else if ( fd . value Type ==  Field Def .  Field Value Type .  FLOAT ) { value Source = new  Float Field Source ( fd . name ) ; } else { fr . fail ( _ STR , _ STR ) ; value Source = null ; } } else { value Source = fd . value Source ; } ddq . add ( fd . name , range . get Query ( null , value Source ) ) ; } else {  String [ ] path ; if ( fr . is String ( _ STR ) ) { path = new  String [ ] { fr . get String ( _ STR ) } ; } else {  List <  Object > values = fr . get List ( _ STR ) ; path = new  String [ values . size ( ) ] ; for ( int i = _ NUM ; i < path . length ; i ++ ) { path [ i ] = (  String ) values . get ( i ) ; } } ddq . add ( fd . name , path ) ; } } } } return ddq ; }
public void open ( ) { open ( new  Config ( ) ) ; }
public static  Optional <  Notification > try Find ( @  Nonnull final  Iterable <  Notification > notifications , final long id ) { final com . google . common . base .  Optional <  Notification > result =  Iterables . try Find ( notifications , null ) ; if ( result . is Present ( ) ) { return  Optional . of ( result . get ( ) ) ; } return  Optional . empty ( ) ; }
private boolean advance Api Between Or Later (  Tree Set <  Area Panel Info > sorted Api Tree ,  Area Panel Info api , int min Time , int max Time , int end Time ) { sorted Api Tree . remove ( api ) ;  Area Panel ap = api . ap ( ) ;  Time Tree root Tt = ap . get Time Tree ( ) ;  Time Tree tt = root Tt . get Encompassig Time Tree Or Max Time Tree Before Time ( max Time , _ BOOL ) ; if ( tt == null || tt . get Min Time Secs ( ) < min Time ) { tt = root Tt . get Encompassig Time Tree Or Min Time Tree After Time ( max Time , _ BOOL ) ; if ( api . set Tt ( tt , end Time ) ) { sorted Api Tree . add ( api ) ; } return _ BOOL ; } else { if ( api . set Tt ( tt , end Time ) ) sorted Api Tree . add ( api ) ; return _ BOOL ; } }
@  Request Mapping ( value = { _ STR , _ STR } , method =  Request Method .  POST ) @  Response Body public  Rest Wrapper update ( @  Model Attribute ( _ STR ) @  Valid  Users users ,  Binding Result binding Result ,  Principal principal ) {  Rest Wrapper rest Wrapper = null ; if ( binding Result . has Errors ( ) ) {  Binding Result Error binding Result Error = new  Binding Result Error ( ) ; return binding Result Error . error Message ( binding Result ) ; } try {  String hashed Password =  Digest Utils . sha1 Hex ( users . get Password ( ) ) ; users . set Password ( hashed Password ) ; com . wipro . ats . bdre . md . dao . jpa .  Users jpa Users = new com . wipro . ats . bdre . md . dao . jpa .  Users ( ) ; jpa Users . set Password ( hashed Password ) ; jpa Users . set Username ( users . get Username ( ) ) ; jpa Users . set Enabled ( ( users . get Enabled ( ) == _ NUM ) ? _ BOOL : _ BOOL ) ; users DAO . update ( jpa Users ) ; rest Wrapper = new  Rest Wrapper ( users ,  Rest Wrapper .  OK ) ;  LOGGER . info ( _ STR + users . get Username ( ) + _ STR + principal . get Name ( ) + users ) ; } catch (  Exception e ) {  LOGGER . error ( e ) ; rest Wrapper = new  Rest Wrapper ( e . get Message ( ) ,  Rest Wrapper .  ERROR ) ; } return rest Wrapper ; }
private void send Request Option ( ) throws  IOException {  String request = _ STR + m Parameters . host + _ STR + m Parameters . port + m Parameters . path + _ STR + add Headers ( ) ;  Log . i (  TAG , request . substring ( _ NUM , request . index Of ( _ STR ) ) ) ; m Output Stream . write ( request . get Bytes ( _ STR ) ) ; m Output Stream . flush ( ) ;  Response . parse Response ( m Buffered Reader ) ; }
@  Override public  Result do Comparison Test ( final  Properties properties ) throws  Exception { final long timeout =  Long . parse Long ( properties . get Property (  Test Options .  TIMEOUT ) ) ; final int nclients =  Integer . parse Int ( properties . get Property (  Test Options .  NCLIENTS ) ) ; final int ntrials =  Integer . parse Int ( properties . get Property (  Test Options .  NTRIALS ) ) ; final int key Len =  Integer . parse Int ( properties . get Property (  Test Options .  KEYLEN ) ) ; final int nops =  Integer . parse Int ( properties . get Property (  Test Options .  NOPS ) ) ; final double abort Rate =  Double . parse Double ( properties . get Property (  Test Options .  ABORT_ RATE ) ) ; final  Result result = do Concurrent Client Test ( journal , timeout , nclients , ntrials , key Len , nops , abort Rate ) ; return result ; }
private void write Final Results (  String output Dir , double total TT , double [ ] total Route TTs , double [ ] avg Route TTs , int [ ] route Users , int number Of Stucked Agents ) {  Print Stream stream ;  String filename = output Dir + _ STR ; try { stream = new  Print Stream ( new  File ( filename ) ) ; } catch (  File Not Found Exception e ) { e . print Stack Trace ( ) ; return ; } log . info ( _ STR + total TT ) ;  String header = _ STR ;  String Buffer result Line = new  String Buffer ( ) ; result Line . append ( total TT ) ;  String latex Format = _ STR + ( int ) total TT ; log . info ( _ STR ) ; for ( int route Nr = _ NUM ; route Nr < number Of Routes ; route Nr ++ ) { log . info ( _ STR + route Nr + _ STR + route Users [ route Nr ] ) ; header += _ STR + route Nr ; result Line . append ( _ STR + route Users [ route Nr ] ) ; latex Format += _ STR + route Users [ route Nr ] ; } log . info ( _ STR ) ; for ( int route Nr = _ NUM ; route Nr < number Of Routes ; route Nr ++ ) { log . info ( _ STR + route Nr + _ STR + avg Route TTs [ route Nr ] ) ; header += _ STR + route Nr ; result Line . append ( _ STR + avg Route TTs [ route Nr ] ) ; latex Format += _ STR + (  Double . is Na N ( avg Route TTs [ route Nr ] ) ? _ STR : ( int ) avg Route TTs [ route Nr ] ) ; } log . info ( _ STR + number Of Stucked Agents ) ; header += _ STR ; result Line . append ( _ STR + number Of Stucked Agents ) ; latex Format += _ STR ; log . info ( _ STR + latex Format ) ; stream . println ( header ) ; stream . println ( result Line . to String ( ) ) ; stream . close ( ) ; log . info ( _ STR + filename ) ; }
public void add Delete (  IResource delete ) { if ( f Delete == null ) f Delete = new  Array List ( _ NUM ) ; f Delete . add ( delete ) ; if ( f Ignore Count == _ NUM ) { internal Add ( new  Delete Description ( delete ) ) ; } }
public static double min ( final double a , final double b ) { if ( a > b ) { return b ; } if ( a < b ) { return a ; } if ( a != b ) { return  Double .  Na N ; } long bits =  Double . double To Raw Long Bits ( a ) ; if ( bits == _ NUM ) { return a ; } return b ; }
@  Override public void write External (  Object Output out ) throws  IOException { super . write External ( out ) ; out . write Object ( conservative Approximation ) ; out . write Object ( progressive Approximation ) ; }
public void add (  String method Name ,  List <  Expression > parameters , boolean is Property ) { chain . add ( new  Dot Expression Item ( method Name , parameters , is Property ) ) ; }
public  Request add (  Request request ) { request . set Request Queue ( this ) ; synchronized ( m Current Requests ) { m Current Requests . add ( request ) ; } request . set Sequence ( get Sequence Number ( ) ) ; request . add Marker ( _ STR ) ; if ( ! request . should Cache ( ) ) { m Network Queue . add ( request ) ; return request ; } synchronized ( m Waiting Requests ) {  String cache Key = request . get Cache Key ( ) ; if ( m Waiting Requests . contains Key ( cache Key ) ) {  Queue <  Request > staged Requests = m Waiting Requests . get ( cache Key ) ; if ( staged Requests == null ) { staged Requests = new  Linked List <  Request > ( ) ; } staged Requests . add ( request ) ; m Waiting Requests . put ( cache Key , staged Requests ) ; if (  Volley Log .  DEBUG ) {  Volley Log . v ( _ STR , cache Key ) ; } } else { m Waiting Requests . put ( cache Key , null ) ; m Cache Queue . add ( request ) ; } return request ; } }
private void commercial Button Clicked (  String command ) { int length =  Integer . parse Int ( command ) ;  JToggle Button button = commercial Buttons . get ( length ) ; if ( button . is Selected ( ) ) { if ( scheduled Commercial Time == _ NUM ) { run Commercial ( length ) ; } else { scheduled Commercial Length = length ; update ( ) ; } } else { scheduled Commercial Time = _ NUM ; set Commercial Result ( _ STR ) ; } }
private int hash Code ( double key ) { long bits =  Double . double To Long Bits ( key ) ; return ( int ) ( bits ^ ( bits > > _ NUM ) ) ; }
public void publish (  AWSIot Message message ) throws  AWSIot Exception { try { publish Message ( message ) ; } catch (  Aws Iot Retryable Exception e ) { if ( client . get Max Offline Queue Size ( ) > _ NUM && publish Queue . size ( ) < client . get Max Offline Queue Size ( ) ) { publish Queue . add ( message ) ; } else {  LOGGER . info ( _ STR + message . get Topic ( ) ) ; throw new  AWSIot Exception ( e ) ; } } }
public static boolean is Solaris ( ) { return os Name . index Of ( _ STR ) > - _ NUM || os Name . index Of ( _ STR ) > - _ NUM ; }
@  Override public void release Connection ( ) { try { if ( response Stream != null ) { try { response Stream . close ( ) ; } catch ( final  IOException ignore ) { } } } finally { ensure Connection Release ( ) ; } }
public boolean ends With (  Name n ) { if ( n instanceof  Composite Name ) { return ( impl . ends With ( n . size ( ) , n . get All ( ) ) ) ; } else { return _ BOOL ; } }
private int calculate Total Width ( float star Size , int number Of Stars , float stars Separation , boolean padding ) { return  Math . round ( star Size * number Of Stars + stars Separation * ( number Of Stars - _ NUM ) ) + ( padding ? get Padding Left ( ) + get Padding Right ( ) : _ NUM ) ; }
@  Suppress Warnings ( { _ STR , _ STR } ) public static boolean is Regex (  String s , int groups ) {  Pattern p ; try { p =  Pattern . compile ( s ) ; } catch (  Pattern Syntax Exception e ) { return _ BOOL ; } return get Group Count ( p ) >= groups ; }
public void flush ( ) { clear Buffer ( ) ; try { out . flush ( ) ; } catch (  IOException e ) { e . print Stack Trace ( ) ; } }
private static void build Name Line ( final  INavi Function Node node , final  Zy Label Content content , final boolean show Function Information ) { final  INavi Function function = node . get Function ( ) ;  String information String = _ STR ; if ( function . get Basic Block Count ( ) > _ NUM ) { final  String Builder builder = new  String Builder ( ) ; builder . append ( _ STR ) ; builder . append ( function . get Basic Block Count ( ) ) ; builder . append ( _ STR ) ; if ( function . get Basic Block Count ( ) > _ NUM ) { builder . append ( _ STR ) ; } if ( function . get Edge Count ( ) > _ NUM ) { builder . append ( _ STR ) ; builder . append ( function . get Edge Count ( ) ) ; builder . append ( _ STR ) ; if ( function . get Edge Count ( ) > _ NUM ) { builder . append ( _ STR ) ; } } builder . append ( _ STR ) ; information String = builder . to String ( ) ; } final  Zy Line Content name Line = new  Zy Line Content ( function . get Name ( ) + information String ,  NORMAL_ FONT , null ) ; content . add Line Content ( name Line ) ; }
public static  Sentence new Conjunction (  Sentence ... conjuncts ) { return new Conjunction (  Arrays . as List ( conjuncts ) ) ; }
public void remove Temporary Maps (  Bit Field object Ids ) { for (  String map Name : store . get Map Names ( ) ) { if ( map Name . starts With ( _ STR ) ) {  MVMap < ? , ? > map = store . open Map ( map Name ) ; store . remove Map ( map ) ; } else if ( map Name . starts With ( _ STR ) || map Name . starts With ( _ STR ) ) { int id =  Integer . parse Int ( map Name . substring ( _ NUM + map Name . index Of ( _ STR ) ) ) ; if ( ! object Ids . get ( id ) ) {  Value Data Type key Type = new  Value Data Type ( null , null , null ) ;  Value Data Type value Type = new  Value Data Type ( null , null , null ) ;  Transaction t = transaction Store . begin ( ) ;  Transaction Map < ? , ? > m = t . open Map ( map Name , key Type , value Type ) ; transaction Store . remove Map ( m ) ; t . commit ( ) ; } } } }
public static void write Histogram (  TDouble Double Hash Map map ,  String key Col ,  String val Col ,  String file , boolean descending ) throws  IOException {  Buffered Writer writer = new  Buffered Writer ( new  File Writer ( file ) ) ; writer . write ( key Col ) ; writer . write (  TAB ) ; writer . write ( val Col ) ; writer . new Line ( ) ; double [ ] keys = map . keys ( ) ;  Arrays . sort ( keys ) ; if ( descending )  Array Utils . reverse ( keys ) ; for ( double key : keys ) { writer . write (  String . value Of ( key ) ) ; writer . write (  TAB ) ; writer . write (  String . value Of ( map . get ( key ) ) ) ; writer . new Line ( ) ; } writer . close ( ) ; }
@  Override protected  Date Time Data parse (  String str ) throws  Schema Date Time Exception {  Date Time Data date = new  Date Time Data ( str , this ) ; int len = str . length ( ) ; int end = get Date ( str , _ NUM , len , date ) ; parse Time Zone ( str , end , len , date ) ; validate Date Time ( date ) ; save Unnormalized ( date ) ; if ( date . utc != _ NUM && date . utc != _ STR ) { normalize ( date ) ; } return date ; }
public void replace Attribute Values (  String attr Name ,  Set old Values ,  Set new Values ) throws  SMSException ,  SSOException { validate Plugin Config ( ) ;  Map attributes = get Attributes ( ) ;  Set new Vals = new  Hash Set ( ) ;  Set old Vals = (  Set ) attributes . get ( attr Name ) ; if ( old Vals != null ) { new Vals . add All ( old Vals ) ; new Vals . remove All ( old Values ) ; } new Vals . add All ( new Values ) ; ps . validate Attr Values ( token , attr Name , new Vals , _ BOOL , pc . get Organization Name ( ) ) ;  SMSEntry e = pc . get SMSEntry ( ) ;  SMSUtils . replace Attribute Values ( e , attr Name , old Values , new Values , ps . get Searchable Attribute Names ( ) ) ; save SMSEntry ( e ) ; }
private void complete Commits ( long previous Commit Index , long commit Index ) { for ( long i = previous Commit Index + _ NUM ; i <= commit Index ; i ++ ) {  Completable Future <  Long > future = append Futures . remove ( i ) ; if ( future != null ) { future . complete ( i ) ; } } }
public void add Sequence Element (  Sequence Element elem ) { for (  Fragment comment : open Fragments ) { comment . add Element ( elem ) ; } for (  Fragment comment : closing Fragments ) { comment . add Element ( elem ) ; } }
private final void _write String Segments ( char [ ] cbuf , int offset , int total Len ) throws  IOException ,  Json Generation Exception { do { int len =  Math . min ( _output Max Contiguous , total Len ) ; if ( ( _output Tail + len ) > _output End ) { _flush Buffer ( ) ; } _write String Segment ( cbuf , offset , len ) ; offset += len ; total Len -= len ; } while ( total Len > _ NUM ) ; }
public  List <  Coord > read Coords (  String shapefile ) {  List <  Coord > list = new  Array List <  Coord > ( ) ;  Shape File Reader sfr = new  Shape File Reader ( ) ;  Collection <  Simple Feature > features = sfr . read File And Initialize ( shapefile ) ; for (  Simple Feature feature : features ) {  Geometry geo = (  Geometry ) feature . get Default Geometry ( ) ; if ( geo instanceof  Point ) {  Point ps = (  Point ) geo ; list . add ( new  Coord ( ps . get X ( ) , ps . get Y ( ) ) ) ; } else { throw new  Runtime Exception ( _ STR ) ; } } return list ; }
private double calculate Node Times (  Tree Model tree ,  Node Ref node ) {  Node Ref parent = tree . get Parent ( node ) ; double time0 = _ NUM ; if ( ! tree . is External ( node ) ) {  Node Ref child1 = tree . get Child ( node , _ NUM ) ; double t1 = calculate Node Times ( tree , child1 ) ;  Node Ref child2 = tree . get Child ( node , _ NUM ) ; double t2 = calculate Node Times ( tree , child2 ) ; time0 = ( t1 + t2 ) / _ NUM ; } if ( parent == null ) return _ NUM ; double branch Time = tree . get Node Height ( parent ) - tree . get Node Height ( node ) ; double time1 = time0 + branch Time ; node Times [ node . get Number ( ) ] = time0 ; return time1 ; }
public static  Array List <  Object > merge All Item Sets (  Array List <  Object > item Sets , int size , int total Trans ) {  Array List <  Object > new Vector = new  Array List <  Object > ( ) ;  Apriori Item Set result ; int num Found , k ; for ( int i = _ NUM ; i < item Sets . size ( ) ; i ++ ) {  Item Set first = (  Item Set ) item Sets . get ( i ) ; out : for ( int j = i + _ NUM ; j < item Sets . size ( ) ; j ++ ) {  Item Set second = (  Item Set ) item Sets . get ( j ) ; result = new  Apriori Item Set ( total Trans ) ; result . m_items = new int [ first . m_items . length ] ; num Found = _ NUM ; k = _ NUM ; while ( num Found < size ) { if ( first . m_items [ k ] == second . m_items [ k ] ) { if ( first . m_items [ k ] != - _ NUM ) { num Found ++ ; } result . m_items [ k ] = first . m_items [ k ] ; } else { break out ; } k ++ ; } while ( k < first . m_items . length ) { if ( ( first . m_items [ k ] != - _ NUM ) && ( second . m_items [ k ] != - _ NUM ) ) { break ; } else { if ( first . m_items [ k ] != - _ NUM ) { result . m_items [ k ] = first . m_items [ k ] ; } else { result . m_items [ k ] = second . m_items [ k ] ; } } k ++ ; } if ( k == first . m_items . length ) { result . m_counter = _ NUM ; new Vector . add ( result ) ; } } } return new Vector ; }
public boolean is Set Message Type ( ) { return __isset_bit_vector . get ( __ MESSAGETYPE_ ISSET_ ID ) ; }
public void add Capabilities Listener (  Set <  Contact Id > contacts ,  Capabilities Listener listener ) throws  Rcs Service Not Available Exception ,  Rcs Generic Exception { if ( m Api == null ) { throw new  Rcs Service Not Available Exception ( ) ; } if ( contacts == null || contacts . is Empty ( ) ) { throw new  Rcs Illegal Argument Exception ( _ STR ) ; } try {  ICapabilities Listener rcs Listener = new  Capabilities Listener Impl ( listener ) ; m Capabilities Listeners . put ( listener , new  Weak Reference < > ( rcs Listener ) ) ; for (  Contact Id contact : contacts ) { m Api . add Capabilities Listener2 ( contact , rcs Listener ) ; } } catch (  Exception e ) {  Rcs Illegal Argument Exception . assert Exception ( e ) ; throw new  Rcs Generic Exception ( e ) ; } }
public static double guess Date (  String s ) { int i = s . length ( ) ; char c ; do { i -- ; c = s . char At ( i ) ; } while ( i >= _ NUM && (  Character . is Digit ( c ) || c == _ STR ) ) ; if ( i == s . length ( ) ) { return _ NUM ; } return  Double . parse Double ( s . substring ( i + _ NUM ) ) ; }
public static final  Index Created Event create Test Index Creation Status ( ) {  Index Created Event to Return = new  Index Created Event (  UUID . random UUID ( ) , new  Date ( ) , new  Date ( ) , create Test Index One Field ( ) , _ NUM , _ NUM ) ; to Return . calculate Values ( ) ; return to Return ; }
public  List <  Validation Error Message > validate Value (  String value ) { error Message Ids . clear ( ) ; if ( data Restrictions . is Required ( ) && value Null Or Empty ( value ) ) { error Message Ids . add ( new  Validation Error Message ( _ STR , id , null ) ) ; } else { if ( ! value Null Or Empty ( value ) ) { for (  Abstract Validation Rule rule : data Restrictions . get Validation Rules ( ) ) { if ( ! rule . validate ( value ) ) { error Message Ids . add ( new  Validation Error Message ( rule . get Message Id ( ) , id , rule ) ) ; } } } } return error Message Ids ; }
@  Event Handler ( priority =  Event Priority .  HIGH , ignore Cancelled = _ BOOL ) public void on Bucket Fill (  Player Bucket Fill Event event ) {  Match match =  Cardinal . get Match ( event . get Player ( ) ) ; if ( match == null || ! match . has Player ( event . get Player ( ) ) ) { return ; } for (  Applied Region reg : get ( match ,  Apply Type .  BLOCK ,  Apply Type .  BLOCK_ BREAK ) ) {  Block evaluating = event . get Block Clicked ( ) ; if ( apply ( reg , evaluating . get Location ( ) , event . get Player ( ) , event , event , evaluating , event . get Player ( ) ) ) { break ; } } }
public static byte [ ] create Nonce ( int bytes ) {  LOGGER . debug ( _ STR , bytes ) ; byte [ ] nonce = new byte [ bytes ] ; random . next Bytes ( nonce ) ; return nonce ; }
static  Zone Offset read Offset (  Data Input in ) throws  IOException { int offset Byte = in . read Byte ( ) ; return ( offset Byte == _ NUM ?  Zone Offset . of Total Seconds ( in . read Int ( ) ) :  Zone Offset . of Total Seconds ( offset Byte * _ NUM ) ) ; }
public void draw Bars On Graph (  Graphics2 D g2d ,  Array List <  Comparable Label > ordered Date Set ,  Hash Map <  Comparable Label ,  Integer [ ] > bar Data Points , long y Max Mark ) { int section Width = this . graph Width / ordered Date Set . size ( ) ; int x Offset = section Width / _ NUM ; int y Value ; float y Offset Perc ; int number Of Bars = bar Data Points . get ( ordered Date Set . get ( _ NUM ) ) . length ; int bar Width = section Width / ( number Of Bars + _ NUM ) ; for ( int date Pos = _ NUM ; date Pos < ordered Date Set . size ( ) ; date Pos ++ ) { for ( int bar Number = _ NUM ; bar Number < number Of Bars ; bar Number ++ ) { y Value = bar Data Points . get ( ordered Date Set . get ( date Pos ) ) [ bar Number ] ; y Offset Perc = y Value / ( float ) y Max Mark ; int x Left Bar = this . graph Left + date Pos * section Width + bar Width / _ NUM + bar Width * bar Number ; draw Bar ( g2d ,  Math . round ( this . graph Height * y Offset Perc ) , bar Width , x Left Bar , this . graph Bottom , this . bar Colors [ bar Number ] ) ; if (  Math . round ( this . graph Height * y Offset Perc ) == _ NUM && y Value != _ NUM ) { g2d . set Color ( this . bar Colors [ bar Number ] ) ; g2d . draw Line ( x Left Bar , this . graph Bottom , x Left Bar + bar Width , this . graph Bottom ) ; } } } }
final public void println (  Object v ) {  Writer out = this . out ; if ( out == null ) return ; try { if ( v == null ) out . write ( _null Chars , _ NUM , _null Chars . length ) ; else {  String s = v . to String ( ) ; out . write ( s , _ NUM , s . length ( ) ) ; } out . write ( _newline , _ NUM , _newline . length ) ; } catch (  IOException e ) { log . log (  Level .  FINE , e . to String ( ) , e ) ; } }
private  URI canonicalize (  String uri String ) throws  URISyntax Exception { if ( ( uri String == null ) || ( uri String . compare To ( _ STR ) == _ NUM ) ) { uri String = _ STR ; return new  URI ( uri String ) ; }  URI u = new  URI ( uri String ) ; if ( u . is Absolute ( ) ) { if ( u . is Opaque ( ) ) {  String scheme = u . get Scheme ( ) ;  String ssp = u . get Scheme Specific Part ( ) ;  String frag = u . get Fragment ( ) ;  URI u2 = null ; int c1index = uri String . index Of ( _ STR ) ; int c2index = uri String . last Index Of ( _ STR ) ; if ( c2index != c1index ) { if ( frag == null ) { u2 = new  URI ( scheme + _ STR + ssp ) ; } else { u2 = new  URI ( scheme + _ STR + ssp + _ STR + frag ) ; } return u2 ; } u2 = new  URI ( _ STR + uri String ) ; return u2 ; } else { return u ; } } else {  String ssp = u . get Scheme Specific Part ( ) ; if ( ssp . starts With ( _ STR ) ) { return u ; } else { return new  URI ( _ STR + uri String ) ; } } }
@  Override public void operator Exported ( final  Operator op , final  Element op Element ) {  Rectangle2 D bounds = lookup Operator Rectangle ( op ) ; if ( bounds != null ) { op Element . set Attribute (  XML_ ATTRIBUTE_ X_ POSITION , _ STR + ( int ) bounds . get X ( ) ) ; op Element . set Attribute (  XML_ ATTRIBUTE_ Y_ POSITION , _ STR + ( int ) bounds . get Y ( ) ) ; op Element . set Attribute (  XML_ ATTRIBUTE_ WIDTH , _ STR + ( int ) bounds . get Width ( ) ) ; op Element . set Attribute (  XML_ ATTRIBUTE_ HEIGHT , _ STR + ( int ) bounds . get Height ( ) ) ; } }
public void process Connection (  Data Input Stream dis ,  Data Output Stream dos Param ) throws  IOException ,  Exception {  GZIPOutput Stream gzip = new  GZIPOutput Stream ( new  Buffered Output Stream ( dos Param ) ) ;  Data Output Stream dos = new  Data Output Stream ( gzip ) ; byte response Status =  Response Status .  STATUS_ ERROR ; try {  Byte Array Output Stream baos = new  Byte Array Output Stream ( ) ;  String name = dis . read UTF ( ) ;  String pw = dis . read UTF ( ) ;  String serializer = dis . read UTF ( ) ; @  Suppress Warnings ( _ STR )  String locale = dis . read UTF ( ) ; byte action = dis . read Byte ( ) ;  Context . open Session ( ) ; try {  Context . authenticate ( name , pw ) ; } catch (  Context Authentication Exception ex ) { response Status =  Response Status .  STATUS_ ACCESS_ DENIED ; } if ( response Status !=  Response Status .  STATUS_ ACCESS_ DENIED ) {  Data Output Stream dos Temp = new  Data Output Stream ( baos ) ; if ( action ==  ACTION_ DOWNLOAD_ PATIENTS ) download Patients (  String . value Of ( dis . read Int ( ) ) , dos Temp , serializer , _ BOOL ) ; else if ( action ==  ACTION_ DOWNLOAD_ SS_ PATIENTS ) download Patients (  String . value Of ( dis . read Int ( ) ) , dos Temp , serializer , _ BOOL ) ; else if ( action ==  ACTION_ DOWNLOAD_ COHORTS )  Patient Download Manager . download Cohorts ( dos Temp , serializer ) ; else if ( action ==  ACTION_ DOWNLOAD_ SAVED_ SEARCHES )  Patient Download Manager . download Saves Searches ( dos Temp , serializer ) ; else if ( action ==  ACTION_ DOWNLOAD_ FORMS )  Xform Download Manager . download Xforms ( dos Temp , serializer ) ; else if ( action ==  ACTION_ UPLOAD_ FORMS ) submit Xforms ( dis , dos Temp , serializer ) ; else if ( action ==  ACTION_ DOWNLOAD_ USERS )  User Download Manager . download Users ( dos Temp , serializer ) ; else if ( action ==  ACTION_ DOWNLOAD_ USERS_ AND_ FORMS ) download Users And Forms ( dos Temp , serializer ) ; else if ( action ==  ACTION_ DOWNLOAD_ FILTERED_ PATIENTS ) download Patients ( dis . read UTF ( ) , dis . read UTF ( ) , dos Temp , serializer ) ; response Status =  Response Status .  STATUS_ SUCCESS ; } dos . write Byte ( response Status ) ; if ( response Status ==  Response Status .  STATUS_ SUCCESS ) dos . write ( baos . to Byte Array ( ) ) ; dos . close ( ) ; gzip . finish ( ) ; } catch (  Exception ex ) { log . error ( ex . get Message ( ) , ex ) ; try { dos . write Byte ( response Status ) ; dos . flush ( ) ; gzip . finish ( ) ; } catch (  Exception e ) { e . print Stack Trace ( ) ; } } finally {  Context . close Session ( ) ; } }
public void add Import ( @  Not Null  Psi Element importable , @  Not Null  Psi File System Item file , @  Nullable  Qualified Name path ) { my Imports . add ( new  Import Candidate Holder ( importable , file , null , path ) ) ; }
@  Override protected void paint Tab Border (  Graphics g , int tab Placement , int tab Index , int x , int y , int w , int h , boolean is Selected ) { g . set Color ( is Selected ? dark Shadow : shadow ) ; switch ( tab Placement ) { case  LEFT : g . draw Line ( x + _ NUM , y + h - _ NUM , x + _ NUM , y + h - _ NUM ) ; g . draw Line ( x , y + _ NUM , x , y + h - _ NUM ) ; g . draw Line ( x + _ NUM , y + _ NUM , x + _ NUM , y + _ NUM ) ; g . draw Line ( x + _ NUM , y , x + w - _ NUM , y ) ; g . draw Line ( x + _ NUM , y + h - _ NUM , x + w - _ NUM , y + h - _ NUM ) ; g . draw Line ( x + _ NUM , y + h - _ NUM , x + w - _ NUM , y + h - _ NUM ) ; break ; case  RIGHT : g . draw Line ( x , y , x + w - _ NUM , y ) ; g . draw Line ( x , y + h - _ NUM , x + w - _ NUM , y + h - _ NUM ) ; g . draw Line ( x + w - _ NUM , y + _ NUM , x + w - _ NUM , y + h - _ NUM ) ; g . draw Line ( x + w - _ NUM , y + _ NUM , x + w - _ NUM , y + _ NUM ) ; g . draw Line ( x + w - _ NUM , y + h - _ NUM , x + w - _ NUM , y + h - _ NUM ) ; g . draw Line ( x + w - _ NUM , y + _ NUM , x + w - _ NUM , y + h - _ NUM ) ; g . draw Line ( x , y + h - _ NUM , x + w - _ NUM , y + h - _ NUM ) ; break ; case  BOTTOM : g . draw Line ( x , y , x , y + h - _ NUM ) ; g . draw Line ( x + _ NUM , y + h - _ NUM , x + w - _ NUM , y + h - _ NUM ) ; g . draw Line ( x + w - _ NUM , y , x + w - _ NUM , y + h - _ NUM ) ; break ; case  TOP : default : g . draw Line ( x , y + _ NUM , x , y + h - _ NUM ) ; g . draw Line ( x + _ NUM , y + _ NUM , x + _ NUM , y + _ NUM ) ; g . draw Line ( x + _ NUM , y , x + w - _ NUM , y ) ; g . draw Line ( x + w - _ NUM , y + _ NUM , x + w - _ NUM , y + h - _ NUM ) ; g . draw Line ( x + w - _ NUM , y + _ NUM , x + w - _ NUM , y + h - _ NUM ) ; g . draw Line ( x + w - _ NUM , y + _ NUM , x + w - _ NUM , y + _ NUM ) ; } }
public  Weak Loader Listener (  Env Loader Listener listener ) { _listener Ref = new  Weak Reference < > ( listener ) ; }
private  Object [ ] unmarshal Parameters Unchecked (  Method method ,  Object Input in ) throws  IOException ,  Class Not Found Exception {  Class < ? > [ ] types = method . get Parameter Types ( ) ;  Object [ ] params = new  Object [ types . length ] ; for ( int i = _ NUM ; i < types . length ; i ++ ) { params [ i ] = unmarshal Value ( types [ i ] , in ) ; } return params ; }
private void load Data From Service ( ) {  List <  Invocation Sequence Data > invoc Data ; if ( ! auto Update ) { if ( template . get Method Ident ( ) !=  Id Definition .  ID_ NOT_ USED ) { invoc Data = data Access Service . get Invocation Sequence Overview ( template . get Platform Ident ( ) , template . get Method Ident ( ) , limit , from Date , to Date , result Comparator ) ; } else { invoc Data = data Access Service . get Invocation Sequence Overview ( template . get Platform Ident ( ) , limit , from Date , to Date , result Comparator ) ; } } else { if ( template . get Method Ident ( ) !=  Id Definition .  ID_ NOT_ USED ) { invoc Data = data Access Service . get Invocation Sequence Overview ( template . get Platform Ident ( ) , template . get Method Ident ( ) , limit , result Comparator ) ; } else { invoc Data = data Access Service . get Invocation Sequence Overview ( template . get Platform Ident ( ) , limit , result Comparator ) ; } } invocation Sequence Data . clear ( ) ; if ( ! invoc Data . is Empty ( ) ) { invocation Sequence Data . add All ( invoc Data ) ; } }
void draw Letter (  Graphics g , char letter , int ax , int ay , int aw , int ah , float align , int index ) {  String str = format Item Num ( index , letter ) ; str = is Left To Right ? str + _ STR : _ STR + str ;  Font Metrics fm =  Swing Utilities2 . get Font Metrics ( null , g ) ; int stringwidth =  Swing Utilities2 . string Width ( null , fm , str ) ; int gap = is Left To Right ? - ( stringwidth + bulletgap ) : ( aw + bulletgap ) ; int x = ax + gap ; int y =  Math . max ( ay + fm . get Ascent ( ) , ay + ( int ) ( ah * align ) ) ;  Swing Utilities2 . draw String ( null , g , str , x , y ) ; }
public int sync (  String entity Id ,  Collection <  Statement > statements ,  Collection <  String > value List ) { long start =  System . current Time Millis ( ) ; int modified = execute ( _ STR ,  UPDATE_ COUNT_ RESPONSE , get Sync Query ( entity Id , statements , value List ) ) ; log . debug ( _ STR , entity Id ,  System . current Time Millis ( ) - start , modified ) ; return modified ; }
public static  Properties read Properties (  Class clazz ) { return read Properties ( clazz . get Name ( ) ) ; }
void draw (  Graphics g , int x , int y ) { if ( image == null ) { image = new  Buffered Image ( width , height ,  Buffered Image .  TYPE_ INT_ RGB ) ; } if ( needs Redraw ) { needs Redraw = _ BOOL ;  Graphics gr = image . create Graphics ( ) ; draw Image ( gr ) ; gr . dispose ( ) ; } g . draw Image ( image , x , y , null ) ; }
public final boolean is Cancelled ( ) { return cancelled ; }
public void add (  Directed Edge de ) { out Edges . add ( de ) ; sorted = _ BOOL ; }
@  Override protected void on Message On Producer Thread (  T msg ) { synchronized ( _lock ) { if ( _pending == null ) { _pending = new  Array List < > ( ) ; _queue . schedule ( _flush Runnable , _interval , _time Unit ) ; } _pending . add ( msg ) ; } }
public static  String to String (  Date date ) {  String string ; synchronized ( format ) { string = format . format ( date ) ; } return string ; }
private boolean is In Thumb Range ( float touch X , double normalized Thumb Value ) { return  Math . abs ( touch X - normalized To Screen ( normalized Thumb Value ) ) <= thumb Half Width ; }
public boolean cleanup ( ) throws  IOException {  File System file System =  File System . get ( config ) ; boolean success = _ BOOL ; for (  Path file : files ) { success &= file System . delete ( file , _ BOOL ) ; } return success ; }
@  Override public boolean is Busy ( ) { return _ BOOL ; }
private void enqueue Next Task (  String queue Name ,  Dispatcher Task dispatcher Task ) { synchronized ( sync Root ) {  Queue <  Dispatcher Task > queue = task Queues Map . get ( queue Name ) ; if ( queue == null ) { queue = new  Linked List < > ( ) ; task Queues Map . put ( queue Name , queue ) ; } queue . add ( dispatcher Task ) ; } }
public void dump (  Writer writer ) {  Decimal Format number Format = new  Decimal Format ( ) ; number Format . set Maximum Fraction Digits ( _ NUM ) ; number Format . set Minimum Fraction Digits ( _ NUM ) ;  Print Writer pw = new  Print Writer ( new  Buffered Writer ( writer ) ) ; if ( get Number Of Frames ( ) == _ NUM ) { pw . println ( _ STR ) ; pw . println ( _ STR + get Number Of Frames ( ) ) ; pw . flush ( ) ; return ; } pw . println ( _ STR ) ; pw . println ( _ STR + get Number Of Frames ( ) ) ; pw . println ( _ STR + get Number Of Channels ( ) ) ; pw . println ( _ STR + get Number Of Samples ( ) ) ; pw . println ( _ STR + sample Rate ) ; pw . println ( _ STR + number Format . format ( lpc Minimum ) ) ; pw . println ( _ STR + number Format . format ( lpc Range ) ) ; pw . println ( _ STR + residual Fold ) ; pw . println ( _ STR + number Format . format (  POST_ EMPHASIS ) ) ; int i ; pw . print ( _ STR ) ; for ( i = _ NUM ; i < get Number Of Frames ( ) ; i ++ ) { pw . print ( times [ i ] + _ STR ) ; } pw . print ( _ STR ) ; for ( i = _ NUM ; i < get Number Of Frames ( ) ; i ++ ) { short [ ] frame = get Frame ( i ) ; for ( int j = _ NUM ; j < frame . length ; j ++ ) { pw . print ( ( ( ( int ) frame [ j ] ) + _ NUM ) + _ STR ) ; } } pw . print ( _ STR ) ; for ( i = _ NUM ; i < get Number Of Frames ( ) ; i ++ ) { pw . print ( sizes [ i ] + _ STR ) ; } pw . print ( _ STR ) ; for ( i = _ NUM ; i < get Number Of Samples ( ) ; i ++ ) { if ( residuals [ i ] == _ NUM ) { pw . print ( _ NUM ) ; } else { pw . print ( ( ( ( int ) residuals [ i ] ) + _ NUM ) ) ; } pw . print ( _ STR ) ; pw . flush ( ) ; } pw . flush ( ) ; }
private void create Field (  Result Set rs ) {  Grid Field VO vo F =  Grid Field VO . create Parameter (  Env . get Ctx ( ) , m_ Window No , rs ) ;  Grid Field m Field = new  Grid Field ( vo F ) ; m_m Fields . add ( m Field ) ; gbc . gridy = m_line ++ ; gbc . gridwidth = _ NUM ; gbc . fill =  Grid Bag Constraints .  HORIZONTAL ; gbc . gridx = _ NUM ; gbc . weightx = _ NUM ;  JLabel label =  VEditor Factory . get Label ( m Field ) ; if ( label == null ) { gbc . insets = null Inset ; center Panel . add (  Box . create Horizontal Strut ( _ NUM ) , gbc ) ; } else { gbc . insets = label Inset ; center Panel . add ( label , gbc ) ; } gbc . insets = field Inset ; gbc . fill =  Grid Bag Constraints .  HORIZONTAL ; gbc . gridwidth = _ NUM ; gbc . gridx = _ NUM ; gbc . weightx = _ NUM ;  VEditor v Editor =  VEditor Factory . get Editor ( m Field , _ BOOL ) ; v Editor . add Vetoable Change Listener ( this ) ; m Field . add Property Change Listener ( v Editor ) ; center Panel . add ( (  Component ) v Editor , gbc ) ; m_v Editors . add ( v Editor ) ;  Object default Object = m Field . get Default ( ) ; m Field . set Value ( default Object , _ BOOL ) ; if ( vo F . is Range ) { gbc . gridx = _ NUM ; gbc . weightx = _ NUM ; gbc . fill =  Grid Bag Constraints .  NONE ;  JLabel dash = new  JLabel ( _ STR ) ; center Panel . add ( dash , gbc ) ; m_separators . add ( dash ) ; gbc . gridx = _ NUM ; gbc . insets = field Inset Right ; gbc . weightx = _ NUM ; gbc . fill =  Grid Bag Constraints .  HORIZONTAL ; gbc . anchor =  Grid Bag Constraints .  WEST ;  Grid Field VO vo F2 =  Grid Field VO . create Parameter ( vo F ) ;  Grid Field m Field2 = new  Grid Field ( vo F2 ) ; m_m Fields2 . add ( m Field2 ) ;  VEditor v Editor2 =  VEditor Factory . get Editor ( m Field2 , _ BOOL ) ; m Field2 . add Property Change Listener ( v Editor2 ) ; center Panel . add ( (  Component ) v Editor2 , gbc ) ; m_v Editors2 . add ( v Editor2 ) ;  Object default Object2 = m Field2 . get Default ( ) ; m Field2 . set Value ( default Object2 , _ BOOL ) ; } else { m_separators . add ( null ) ; m_m Fields2 . add ( null ) ; m_v Editors2 . add ( null ) ; } }
public  Brd From Side calc_from_side (  Shape Tile p_shape ,  Pla Point Int p_shape_center , int p_layer , int p_offset , int p_cl_class ) {  Net Nos List empty_arr =  Net Nos List .  EMPTY ;  Shape Tile offset_shape = p_shape . offset ( p_offset ) ; for ( int index = _ NUM ; index < offset_shape . border_line_count ( ) ; ++ index ) {  Shape Tile check_shape = calc_check_chape_for_from_side ( p_shape , p_shape_center , offset_shape . border_line ( index ) ) ; if ( r_board . check_trace ( check_shape , p_layer , empty_arr , p_cl_class , null ) ) { return new  Brd From Side ( index , null ) ; } } for ( int index = _ NUM ; index < offset_shape . border_line_count ( ) ; ++ index ) {  Shape Tile check_shape = calc_check_chape_for_from_side ( p_shape , p_shape_center , offset_shape . border_line ( index ) ) ; if ( r_board . check_trace ( check_shape , p_layer , empty_arr , _ NUM , null ) ) { return new  Brd From Side ( index , null ) ; } } return  Brd From Side .  NOT_ CALCULATED ; }
static double compute Desired Ellipsoid Magnitude ( final  Planet Model planet Model , final double z ) { return _ NUM /  Math . sqrt ( ( _ NUM - z * z ) * planet Model . inverse Ab Squared + z * z * planet Model . inverse CSquared ) ; }
private void validate Vcenter Credentials (  Vcenter Param param ,  Vcenter vcenter ) { if (  String Utils . is Blank ( param . get Password ( ) ) && vcenter != null ) { param . set Password (  String Utils . trim To Null ( vcenter . get Password ( ) ) ) ; } if (  String Utils . is Blank ( param . get User Name ( ) ) && vcenter != null ) { param . set User Name (  String Utils . trim To Null ( vcenter . get Username ( ) ) ) ; }  Arg Validator . check Field Not Null ( param . get User Name ( ) , _ STR ) ;  Arg Validator . check Field Not Null ( param . get Password ( ) , _ STR ) ; }
public void create Accrual Based Journal Entries And Reversals For Loan ( final  Office office , final  String currency Code , final  Integer account Type To Be Debited , final  Integer account Type To Be Credited , final  Long loan Product Id , final  Long payment Type Id , final  Long loan Id , final  String transaction Id , final  Date transaction Date , final  Big Decimal amount , final  Boolean is Reversal ) { int account Type To Debit Id = account Type To Be Debited ; int account Type To Credit Id = account Type To Be Credited ; if ( is Reversal ) { account Type To Debit Id = account Type To Be Credited ; account Type To Credit Id = account Type To Be Debited ; } create Journal Entries For Loan ( office , currency Code , account Type To Debit Id , account Type To Credit Id , loan Product Id , payment Type Id , loan Id , transaction Id , transaction Date , amount ) ; }
public  State Interactive add_corner (  Pla Point Float p_location ) {  Pla Point Int location = snap_to_restriction ( p_location . round ( ) ) ; corner_list . add ( location ) ; i_brd . repaint ( ) ; actlog_add_corner ( p_location ) ; return this ; }
public  Sensor create New Sensor (  String system Name ,  String user Name ) {  Sensor s ;  String s Name =  Serial Address . normalize System Name ( system Name ) ; if ( s Name . equals ( _ STR ) ) { log . error ( _ STR + system Name ) ; return null ; } s = get By System Name ( s Name ) ; if ( s != null ) { log . error ( _ STR + system Name ) ; return null ; }  String alt Name =  Serial Address . convert System Name To Alternate ( s Name ) ; s = get By System Name ( alt Name ) ; if ( s != null ) { log . error ( _ STR + system Name + _ STR + alt Name + _ STR ) ; return null ; } int bit =  Serial Address . get Bit From System Name ( s Name ) ; if ( ( bit <= _ NUM ) || ( bit >=  SENSORSPERNODE ) ) { log . error ( _ STR +  Integer . to String ( bit ) + _ STR +  Integer . to String (  SENSORSPERNODE - _ NUM ) ) ; return null ; } if ( user Name == null ) { s = new  Serial Sensor ( s Name ) ; } else { s = new  Serial Sensor ( s Name , user Name ) ; }  Serial Node node =  Serial Address . get Node From System Name ( s Name ) ; if ( node == null ) { log . warn ( _ STR + s Name + _ STR ) ; return s ; } node . register Sensor ( s , bit - _ NUM ) ; return s ; }
public static double [ ] logs2probs ( double [ ] a ) { double max = a [ max Index ( a ) ] ; double sum = _ NUM ; double [ ] result = new double [ a . length ] ; for ( int i = _ NUM ; i < a . length ; i ++ ) { result [ i ] =  Math . exp ( a [ i ] - max ) ; sum += result [ i ] ; } normalize ( result , sum ) ; return result ; }
public void fill_area (  Pla Point Float [ ] [ ] p_point_lists ,  Graphics p_g ,  Color p_color , double p_translucency_factor ) { if ( p_color == null ) return ;  General Path draw_path = new  General Path (  General Path .  WIND_ EVEN_ ODD ) ; for ( int jndex = _ NUM ; jndex < p_point_lists . length ; ++ jndex ) {  Polygon draw_polygon = new  Polygon ( ) ;  Pla Point Float [ ] curr_point_list = p_point_lists [ jndex ] ; for ( int index = _ NUM ; index < curr_point_list . length ; index ++ ) {  Point2 D curr_corner = coordinate_transform . board_to_screen ( curr_point_list [ index ] ) ; draw_polygon . add Point ( ( int )  Math . round ( curr_corner . get X ( ) ) , ( int )  Math . round ( curr_corner . get Y ( ) ) ) ; } draw_path . append ( draw_polygon , _ BOOL ) ; }  Graphics2 D g2 = (  Graphics2 D ) p_g ; g2 . set Color ( p_color ) ; set_translucency ( g2 , p_translucency_factor ) ; g2 . set Rendering Hint (  Rendering Hints .  KEY_ ANTIALIASING ,  Rendering Hints .  VALUE_ ANTIALIAS_ ON ) ; g2 . fill ( draw_path ) ; }
public void move To Previous Date ( ) { if ( disable Auto Date Selection && user Selected Item == null ) return ; if ( selected Date Item != null ) {  Calendar cal =  Calendar . get Instance ( ) ; cal . set ( selected Date Item . get Year ( ) , selected Date Item . get Month ( ) , selected Date Item . get Day ( ) ) ; cal . add (  Calendar .  DATE , - _ NUM ) ; if ( selected Date Item . get Month ( ) != cal . get (  Calendar .  MONTH ) ) { selected Date Item . set Day ( cal . get (  Calendar .  DAY_ OF_ MONTH ) ) ; selected Date Item . set Month ( cal . get (  Calendar .  MONTH ) ) ; selected Date Item . set Year ( cal . get (  Calendar .  YEAR ) ) ; should Override Computed Date = _ BOOL ; move To Previous Month ( ) ; } else { selected Date Item . set Day ( cal . get (  Calendar .  DAY_ OF_ MONTH ) ) ; selected Date Item . set Month ( cal . get (  Calendar .  MONTH ) ) ; selected Date Item . set Year ( cal . get (  Calendar .  YEAR ) ) ; month View Pager Adapter . set Selected Item ( selected Date Item ) ; } } }
public static boolean is Valid Template (  String template ) { template = template . trim ( ) ; if ( template . index Of ( _ STR ) == - _ NUM ) { return _ BOOL ; }  String s = template . trim ( ) ; if ( s . last Index Of ( _ STR ) != s . length ( ) - _ NUM ) { return _ BOOL ; } if ( get Method Signature ( template ) == null ) { return _ BOOL ; } if ( get Method Body ( template ) == null ) { return _ BOOL ; } return _ BOOL ; }
public synchronized boolean send Reply For One Result (  DM dm ,  Partitioned Region pr , long start Time ,  Object one Result , boolean last Result , boolean send Results In Order ) throws  Cache Exception ,  Force Reattempt Exception ,  Interrupted Exception { if ( this . reply Last Msg ) { return _ BOOL ; } if (  Thread . interrupted ( ) ) throw new  Interrupted Exception ( ) ; int msg Num = this . reply Msg Num ; this . reply Last Msg = last Result ; send Reply ( get Sender ( ) , this . processor Id , dm , null , one Result , pr , start Time , msg Num , last Result , send Results In Order ) ; if ( logger . is Debug Enabled ( ) ) { logger . debug ( _ STR ) ; } this . reply Msg Num ++ ; return _ BOOL ; }
private int inv Wm Transform ( double alpha , double f1 , double f2 , double f3 ) { double s = alpha *  Math . abs ( f3 - f1 ) / _ NUM ; double l = f1 ; int x = _ NUM ; while ( l < f2 ) { l += s ; x ++ ; } if (  Math . abs ( l - s - f2 ) <  Math . abs ( l - f2 ) ) { return ( x + _ NUM ) % _ NUM ; } else { return x % _ NUM ; } }
@  Override public void run ( ) { try { while ( ! is Closed ( ) && _is . read ( ) > _ NUM && _in . read Message ( _is ) ) {  Service Ref . flush Outbox ( ) ; } } catch (  EOFException e ) { log . finer ( this + _ STR ) ; if ( log . is Loggable (  Level .  ALL ) ) { log . log (  Level .  ALL , e . to String ( ) , e ) ; } } catch (  Socket Exception e ) { e . print Stack Trace ( ) ; log . finer ( this + _ STR + e ) ; if ( log . is Loggable (  Level .  ALL ) ) { log . log (  Level .  ALL , e . to String ( ) , e ) ; } } catch (  IOException e ) { e . print Stack Trace ( ) ; throw new  Runtime Exception ( e ) ; } catch (  Throwable e ) { e . print Stack Trace ( ) ; throw e ; } finally { close ( ) ; } }
int terminal ( int [ ] flags ) throws  RESyntax Exception { switch ( pattern . char At ( idx ) ) { case  RE .  OP_ EOL : case  RE .  OP_ BOL : case  RE .  OP_ ANY : return node ( pattern . char At ( idx ++ ) , _ NUM ) ; case _ STR : return character Class ( ) ; case _ STR : return expr ( flags ) ; case _ STR : syntax Error ( _ STR ) ; case _ STR : internal Error ( ) ; case _ STR : syntax Error ( _ STR ) ; case _ NUM : syntax Error ( _ STR ) ; case _ STR : case _ STR : case _ STR : case _ STR : syntax Error ( _ STR ) ; case _ STR : { int idx Before Escape = idx ; switch ( escape ( ) ) { case  ESC_ CLASS : case  ESC_ COMPLEX : flags [ _ NUM ] &= ~  NODE_ NULLABLE ; return node (  RE .  OP_ ESCAPE , pattern . char At ( idx - _ NUM ) ) ; case  ESC_ BACKREF : { char backreference = ( char ) ( pattern . char At ( idx - _ NUM ) - _ STR ) ; if ( parens <= backreference ) { syntax Error ( _ STR ) ; } flags [ _ NUM ] |=  NODE_ NULLABLE ; return node (  RE .  OP_ BACKREF , backreference ) ; } default : idx = idx Before Escape ; flags [ _ NUM ] &= ~  NODE_ NULLABLE ; break ; } } } flags [ _ NUM ] &= ~  NODE_ NULLABLE ; return atom ( ) ; }
@  Override public void draw Item (  Graphics2 D g2 ,  Category Item Renderer State state ,  Rectangle2 D data Area ,  Category Plot plot ,  Category Axis domain Axis ,  Value Axis range Axis ,  Category Dataset dataset , int row , int column , int pass ) { if ( ! get Item Visible ( row , column ) ) { return ; } if ( ! get Item Line Visible ( row , column ) && ! get Item Shape Visible ( row , column ) ) { return ; }  Number v = dataset . get Value ( row , column ) ; if ( v == null ) { return ; } int visible Row = state . get Visible Series Index ( row ) ; if ( visible Row < _ NUM ) { return ; } int visible Row Count = state . get Visible Series Count ( ) ;  Plot Orientation orientation = plot . get Orientation ( ) ; double x1 ; if ( this . use Series Offset ) { x1 = domain Axis . get Category Series Middle ( column , dataset . get Column Count ( ) , visible Row , visible Row Count , this . item Margin , data Area , plot . get Domain Axis Edge ( ) ) ; } else { x1 = domain Axis . get Category Middle ( column , get Column Count ( ) , data Area , plot . get Domain Axis Edge ( ) ) ; } double value = v . double Value ( ) ; double y1 = range Axis . value To Java2 D ( value , data Area , plot . get Range Axis Edge ( ) ) ; if ( pass == _ NUM && get Item Line Visible ( row , column ) ) { if ( column != _ NUM ) {  Number previous Value = dataset . get Value ( row , column - _ NUM ) ; if ( previous Value != null ) { double previous = previous Value . double Value ( ) ; double x0 ; if ( this . use Series Offset ) { x0 = domain Axis . get Category Series Middle ( column - _ NUM , dataset . get Column Count ( ) , visible Row , visible Row Count , this . item Margin , data Area , plot . get Domain Axis Edge ( ) ) ; } else { x0 = domain Axis . get Category Middle ( column - _ NUM , get Column Count ( ) , data Area , plot . get Domain Axis Edge ( ) ) ; } double y0 = range Axis . value To Java2 D ( previous , data Area , plot . get Range Axis Edge ( ) ) ;  Line2 D line = null ; if ( orientation ==  Plot Orientation .  HORIZONTAL ) { line = new  Line2 D .  Double ( y0 , x0 , y1 , x1 ) ; } else if ( orientation ==  Plot Orientation .  VERTICAL ) { line = new  Line2 D .  Double ( x0 , y0 , x1 , y1 ) ; } g2 . set Paint ( get Item Paint ( row , column ) ) ; g2 . set Stroke ( get Item Stroke ( row , column ) ) ; g2 . draw ( line ) ; } } } if ( pass == _ NUM ) {  Shape shape = get Item Shape ( row , column ) ; if ( orientation ==  Plot Orientation .  HORIZONTAL ) { shape =  Shape Utilities . create Translated Shape ( shape , y1 , x1 ) ; } else if ( orientation ==  Plot Orientation .  VERTICAL ) { shape =  Shape Utilities . create Translated Shape ( shape , x1 , y1 ) ; } if ( get Item Shape Visible ( row , column ) ) { if ( get Item Shape Filled ( row , column ) ) { if ( this . use Fill Paint ) { g2 . set Paint ( get Item Fill Paint ( row , column ) ) ; } else { g2 . set Paint ( get Item Paint ( row , column ) ) ; } g2 . fill ( shape ) ; } if ( this . draw Outlines ) { if ( this . use Outline Paint ) { g2 . set Paint ( get Item Outline Paint ( row , column ) ) ; } else { g2 . set Paint ( get Item Paint ( row , column ) ) ; } g2 . set Stroke ( get Item Outline Stroke ( row , column ) ) ; g2 . draw ( shape ) ; } } if ( is Item Label Visible ( row , column ) ) { if ( orientation ==  Plot Orientation .  HORIZONTAL ) { draw Item Label ( g2 , orientation , dataset , row , column , y1 , x1 , ( value < _ NUM ) ) ; } else if ( orientation ==  Plot Orientation .  VERTICAL ) { draw Item Label ( g2 , orientation , dataset , row , column , x1 , y1 , ( value < _ NUM ) ) ; } } int dataset Index = plot . index Of ( dataset ) ; update Crosshair Values ( state . get Crosshair State ( ) , dataset . get Row Key ( row ) , dataset . get Column Key ( column ) , value , dataset Index , x1 , y1 , orientation ) ;  Entity Collection entities = state . get Entity Collection ( ) ; if ( entities != null ) { add Item Entity ( entities , dataset , row , column , shape ) ; } } }
public static <  T >  List <  T > satisfy (  List <  T > input ,  Function < ? super  T , ? extends  Ordering Constraints <  T > > constraint Supplier ) { return satisfy ( input ,  Function . identity ( ) , constraint Supplier ) ; }
public static boolean is Network Connected (  Context context ) { if ( context == null ) { return _ BOOL ; }  Connectivity Manager cm = (  Connectivity Manager ) context . get System Service (  Context .  CONNECTIVITY_ SERVICE ) ;  Network Info network Info = cm . get Active Network Info ( ) ; return ( network Info != null && network Info . is Connected ( ) ) ; }
public void put (  String name ,  String supported ,  String key ,  String value ,  String level ) {  IDFFAuth Context c = new  IDFFAuth Context ( ) ; c . name = name ; c . supported = supported ; c . key = key ; c . value = value ; c . level = level ; collections . put ( name , c ) ; }
public final void close (  Gs Server Packet close Packet , boolean forced ) { synchronized ( guard ) { if ( is Write Disabled ( ) ) { return ; } pending Close = _ BOOL ; is Forced Closing = forced ; send Msg Queue . clear ( ) ; send Msg Queue . add Last ( close Packet ) ; enable Write Interest ( ) ; } }
public void add Edges (  List edges To Add ) { for (  Iterator it = edges To Add . iterator ( ) ; it . has Next ( ) ; ) {  Edge e = (  Edge ) it . next ( ) ; edges . add ( e ) ;  Directed Edge de1 = new  Directed Edge ( e , _ BOOL ) ;  Directed Edge de2 = new  Directed Edge ( e , _ BOOL ) ; de1 . set Sym ( de2 ) ; de2 . set Sym ( de1 ) ; add ( de1 ) ; add ( de2 ) ; } }
public static void use Internal Frames (  JRoot Pane root Pane ) { if ( root Pane != null ) { use Internal Frames ( root Pane . get Layered Pane ( ) ) ; } else { use Internal Frames ( (  JLayered Pane ) null ) ; } }
public void write Int ( int value ) throws  IOException { check Write Primitive Types ( ) ; primitive Types . write Int ( value ) ; }
static public  Input Stream find JMSConfig (  String custom Config File Name ) throws  Exception {  URL config URL = null ;  String file Path =  Constants .  Jms .  JMS_ CONFIG_ DIRECTORY ; boolean is Full URLPath = _ BOOL ; try { config URL = new  URL ( custom Config File Name ) ; } catch (  Malformed URLException e ) { } if ( config URL != null ) { if ( !  JSpace Utilities . is Empty ( config URL . get Protocol ( ) ) ) { file Path = config URL . get File ( ) ; is Full URLPath = _ BOOL ; } } if ( ! is Full URLPath ) { if ( custom Config File Name != null ) { file Path =  Constants .  Jms .  JMS_ CONFIG_ DIRECTORY + custom Config File Name ; } else { file Path =  Constants .  Jms .  JMS_ CONFIG_ DIRECTORY +  Constants .  Jms .  JMS_ CONFIG_ FILE_ NAME ; } }  Input Stream input Stream = get Resource Stream ( file Path ) ; if ( input Stream == null ) {  String missing JMSConfig File Msg = _ STR + file Path + _ STR ; throw new  Exception ( missing JMSConfig File Msg ) ; } else { if ( _logger . is Loggable (  Level .  INFO ) ) { _logger . info ( _ STR + get Resource URL ( file Path ) + _ STR ) ; } } return input Stream ; }
public static  List <  Module Spec > expand Spec Wildcards (  List <  File > dirs ,  List <  Module Spec > modules ,  Backend for Backend ) {  List <  Module Spec > result = new  Array List <  Module Spec > ( modules . size ( ) ) ; for (  Module Spec spec : modules ) {  List <  String > names = new  Array List <  String > ( ) ; expand Wildcard ( names , dirs , spec . get Name ( ) , for Backend ) ; for (  String name : names ) { result . add ( new  Module Spec ( name , spec . get Version ( ) ) ) ; } } return result ; }
public  Hex ( final  String charset Name ) { this (  Charset . for Name ( charset Name ) ) ; }
public  NSNumber (  String text ) { if ( text == null ) throw new  Illegal Argument Exception ( _ STR ) ; try { long l ; if ( text . starts With ( _ STR ) ) { l =  Long . parse Long ( text . substring ( _ NUM ) , _ NUM ) ; } else { l =  Long . parse Long ( text ) ; } double Value = long Value = l ; type =  INTEGER ; } catch (  Exception ex ) { try { double Value =  Double . parse Double ( text ) ; long Value =  Math . round ( double Value ) ; type =  REAL ; } catch (  Exception ex2 ) { try { bool Value = text . equals Ignore Case ( _ STR ) || text . equals Ignore Case ( _ STR ) ; if ( ! bool Value && ! ( text . equals Ignore Case ( _ STR ) || text . equals Ignore Case ( _ STR ) ) ) { throw new  Exception ( _ STR ) ; } type =  BOOLEAN ; double Value = long Value = bool Value ? _ NUM : _ NUM ; } catch (  Exception ex3 ) { throw new  Illegal Argument Exception ( _ STR ) ; } } } }
public void collect (  Thread thread ) { final  Stack Trace Element [ ] stack Trace = thread . get Stack Trace ( ) ; collect By Key (  GLOBAL , stack Trace ) ; }
@  Override public boolean e Is Set ( int feature ID ) { switch ( feature ID ) { case  Eip Package .  CHANNEL__ TO_ ENDPOINT : return to Endpoint != null ; case  Eip Package .  CHANNEL__ FROM_ ENDPOINT : return from Endpoint != null ; case  Eip Package .  CHANNEL__ NAME : return  NAME_ EDEFAULT == null ? name != null : !  NAME_ EDEFAULT . equals ( name ) ; case  Eip Package .  CHANNEL__ GUARANTEED : return guaranteed !=  GUARANTEED_ EDEFAULT ; } return super . e Is Set ( feature ID ) ; }
public static void load Library (  String libname ) throws  IOException {  File lib = jni Extractor . extract Jni ( libname ) ;  System . load ( lib . get Absolute Path ( ) ) ; }
public  String find In Content (  String content ) { for (  Boyer Moore Matcher matcher : strings ) { if ( matcher . find In Content ( content ) >= _ NUM ) return matcher . get Pattern ( ) ; }  Matcher matcher ; for (  Pattern pattern : patterns ) { matcher = pattern . matcher ( content ) ; if ( matcher . find ( ) ) { return matcher . group ( ) ; } } return null ; }
private void fill Ordinal To Block Mapping For Dimension ( ) { int block Ordinal = - _ NUM ;  Carbon Dimension dimension = null ; int index = _ NUM ; int prvcolumn Group Id = - _ NUM ; while ( index < dimensions . size ( ) ) { dimension = dimensions . get ( index ) ; if ( dimension . is Columnar ( ) || dimension . column Group Id ( ) != prvcolumn Group Id ) { block Ordinal ++ ; } dimension Ordinal To Block Mapping . put ( dimension . get Ordinal ( ) , block Ordinal ) ; prvcolumn Group Id = dimension . column Group Id ( ) ; index ++ ; } index = _ NUM ; while ( index < complex Dimensions . size ( ) ) { dimension = complex Dimensions . get ( index ) ; dimension Ordinal To Block Mapping . put ( dimension . get Ordinal ( ) , ++ block Ordinal ) ; block Ordinal = fill Complex Dimension Child Block Index ( block Ordinal , dimension ) ; index ++ ; } fill Block To Dimension Ordinal Mapping ( ) ; }
public static void call Method (  Method Operation operation ,  Method Context method Context ,  List <  Method Object < ? > > parameters ,  Class < ? > method Class ,  Object method Object ,  String method Name ,  Flexible Map Accessor <  Object > ret Field Fma ) throws  Mini Lang Runtime Exception {  Object [ ] args = null ;  Class < ? > [ ] parameter Types = null ; if ( parameters != null ) { args = new  Object [ parameters . size ( ) ] ; parameter Types = new  Class < ? > [ parameters . size ( ) ] ; int i = _ NUM ; for (  Method Object < ? > method Object Def : parameters ) { args [ i ] = method Object Def . get Object ( method Context ) ;  Class < ? > type Class = null ; try { type Class = method Object Def . get Type Class ( method Context ) ; } catch (  Class Not Found Exception e ) { throw new  Mini Lang Runtime Exception ( e , operation ) ; } parameter Types [ i ] = type Class ; i ++ ; } } try {  Method method = method Class . get Method ( method Name , parameter Types ) ;  Object ret Value = method . invoke ( method Object , args ) ; if ( ! ret Field Fma . is Empty ( ) ) { ret Field Fma . put ( method Context . get Env Map ( ) , ret Value ) ; } } catch (  Exception e ) { throw new  Mini Lang Runtime Exception ( e , operation ) ; } }
protected void  Create FDArray (  Offset Item fdarray Ref ,  Offset Item private Ref , int  Font ) {  Output List . add Last ( new  Marker Item ( fdarray Ref ) ) ;  Build Index Header ( _ NUM , _ NUM , _ NUM ) ;  Offset Item private Index1 Ref = new  Index Offset Item ( _ NUM ) ;  Output List . add Last ( private Index1 Ref ) ;  Index Base Item private Base = new  Index Base Item ( ) ;  Output List . add Last ( private Base ) ; int  New Size = fonts [  Font ] . private Length ; int  Org Subrs Offset Size =  Calc Subr Offset Size ( fonts [  Font ] . private Offset , fonts [  Font ] . private Length ) ; if (  Org Subrs Offset Size != _ NUM )  New Size += _ NUM -  Org Subrs Offset Size ;  Output List . add Last ( new  Dict Number Item (  New Size ) ) ;  Output List . add Last ( private Ref ) ;  Output List . add Last ( new  UInt8 Item ( ( char ) _ NUM ) ) ;  Output List . add Last ( new  Index Marker Item ( private Index1 Ref , private Base ) ) ; }
public  Status Component ( ) {  STEPPING = _ BOOL ;  NF = null ;  LABEL = new  JLabel ( ) ;  BAR = new  JProgress Bar ( ) ; set Layout ( new  Box Layout ( this ,  Box Layout .  Y_ AXIS ) ) ; construct ( ) ;  GUIUtils . set Opaque ( _ BOOL , this ) ; if (  BAR != null && !  OSUtils . is Mac OSX ( ) ) {  BAR . set Opaque ( _ BOOL ) ; }  BAR . set Indeterminate ( _ BOOL ) ; }
public static void main (  String args [ ] ) { try {  String command , param ; int delim =  Query String . index Of ( _ STR ) ; if ( delim == - _ NUM ) { command =  Query String ; param = _ STR ; } else { command =  Query String . substring ( _ NUM , delim ) ; param =  Query String . substring ( delim + _ NUM ) ; }  CGICommand Handler handler = command Lookup . get ( command ) ; if ( handler != null ) try { handler . execute ( param ) ; } catch (  CGIClient Exception e ) { e . print Stack Trace ( ) ; return Client Error ( e . get Message ( ) ) ; } catch (  CGIServer Exception e ) { e . print Stack Trace ( ) ; return Server Error ( e . get Message ( ) ) ; } else return Client Error ( _ STR ) ; } catch (  Exception e ) { e . print Stack Trace ( ) ; return Server Error ( _ STR + e . get Message ( ) ) ; }  System . exit ( _ NUM ) ; }
public void add Line (  String line ) { int index = line . index Of ( _ STR , _ NUM ) ; if ( index != - _ NUM ) { add Lenient ( line . substring ( _ NUM , index ) , line . substring ( index + _ NUM ) ) ; } else if ( line . starts With ( _ STR ) ) { add Lenient ( _ STR , line . substring ( _ NUM ) ) ; } else { add Lenient ( _ STR , line ) ; } }
public static void merge Nodes (  Tree Node master ,  Tree Node slave ) {  Default Mutable Tree Node master Node = (  Default Mutable Tree Node ) master ;  Default Mutable Tree Node slave Node = (  Default Mutable Tree Node ) slave ; int master Cnt = master Node . get Child Count ( ) ; while ( slave Node . get Child Count ( ) > _ NUM ) {  Default Mutable Tree Node slave Node Child = (  Default Mutable Tree Node ) slave Node . get First Child ( ) ; for ( int m = _ NUM ; m < master Cnt ; m ++ ) {  Default Mutable Tree Node master At M = (  Default Mutable Tree Node ) master Node . get Child At ( m ) ; if ( do Custom Merge ( slave Node Child , master At M ) ) { slave Node Child = null ; break ; } if (  Merge Help Utilities . compare Names ( master At M , slave Node Child ) == _ NUM ) { if (  Merge Help Utilities . have Equal ID ( master At M , slave Node Child ) ) {  Merge Help Utilities . merge Nodes (  DEFAULT_ MERGE_ TYPE , master At M , slave Node Child ) ; slave Node Child . remove From Parent ( ) ; slave Node Child = null ; break ; }  Merge Help Utilities . mark Nodes ( master At M , slave Node Child ) ; master Node . add ( slave Node Child ) ;  Merge Help Utilities . merge Node Children (  DEFAULT_ MERGE_ TYPE , slave Node Child ) ; slave Node Child = null ; break ; } } if ( slave Node Child != null ) { master Node . add ( slave Node Child ) ;  Merge Help Utilities . merge Node Children (  DEFAULT_ MERGE_ TYPE , slave Node Child ) ; } } slave Node . remove From Parent ( ) ; slave Node = null ; }
public void test Negate Positive ( ) {  String a = _ STR ; int a Scale = _ NUM ;  String c = _ STR ; int c Scale = _ NUM ;  Big Decimal a Number = new  Big Decimal ( new  Big Integer ( a ) , a Scale ) ;  Big Decimal c Number = new  Big Decimal ( new  Big Integer ( c ) , c Scale ) ; assert Equals ( _ STR , c Number , a Number . negate ( ) ) ; }
private static void bind List (  Class < ? > item Type ,  Object target ,  Field field ,  Parameter Access parameters ) {  String field Name = field . get Name ( ) ;  Class < ? > field Type = field . get Type ( ) ;  List <  Parameter Access > item Parameters = create Item Parameters ( item Type , parameters ) ;  Object array =  Array . new Instance ( item Type , item Parameters . size ( ) ) ; for ( int i = _ NUM ; i < item Parameters . size ( ) ; i ++ ) {  Object item Value = create And Bind Item ( item Parameters . get ( i ) , item Type ) ;  Array . set ( array , i , item Value ) ; }  Object target Value = convert Array ( array , field Type , item Type ) ; try { field . set Accessible ( _ BOOL ) ; field . set ( target , target Value ) ; } catch (  Exception e ) {  String message =  String . format ( _ STR , field Name ) ; throw new  Binding Exception ( message , e ) ; } }
public  Generator Property Iterator Panel (  Experiment exp ) { this ( ) ; set Experiment ( exp ) ; }
private void parse Arguments (  String [ ] args ) throws  IOException { for ( int i = _ NUM ; i < args . length ; i ++ ) {  String arg = args [ i ] ; if ( arg . equals ( _ STR ) ) { i ++ ; if ( args . length <= i ) { parsing Error ( arg + _ STR ) ; } indirectory = new  File ( args [ i ] ) ; if ( ! indirectory . exists ( ) ) { parsing Error ( args [ i ] + _ STR ) ; } } else if ( arg . equals ( _ STR ) ) { i ++ ; if ( args . length <= i ) { parsing Error ( arg + _ STR ) ; } outdirectory = new  File ( args [ i ] ) ; } else if ( arg . equals ( _ STR ) ) { i ++ ; if ( args . length <= i ) { parsing Error ( arg + _ STR ) ; }  File config = new  File ( args [ i ] ) ; if ( ! config . exists ( ) ) { parsing Error ( arg + _ STR + args [ i ] + _ STR ) ; } ner Annotator =  Ner Annotator Manager . build Ner Annotator ( new  Resource Manager ( args [ i ] ) ,  View Names .  NER_ CONLL ) ; } else if ( arg . equals ( _ STR ) ) { i ++ ; try { max =  Integer . parse Int ( args [ i ] ) ; } catch (  Number Format Exception nfe ) { parsing Error ( _ STR + args [ i ] + _ STR ) ; } } else { parsing Error ( _ STR + arg + _ STR ) ; } } if ( ner Annotator == null ) { parsing Error ( _ STR ) ; } if ( outdirectory != null && ! outdirectory . exists ( ) ) { if ( indirectory == null ) outdirectory . create New File ( ) ; else if ( indirectory . is Directory ( ) ) { outdirectory . mkdirs ( ) ; } else { outdirectory . create New File ( ) ; } } }
public static boolean is Metro Point Volume (  Db Client db Client ,  Volume volume ) { if ( volume != null ) {  Virtual Pool vpool = db Client . query Object (  Virtual Pool . class , volume . get Virtual Pool ( ) ) ; if ( vpool != null &&  Virtual Pool . v Pool Specifies Metro Point ( vpool ) ) { _log . info (  String . format ( _ STR , vpool . get Label ( ) , vpool . get Id ( ) ) ) ; return _ BOOL ; } } return _ BOOL ; }
public  Collection <  XMLElement > consume Child Elements (  Interpreter <  Boolean > interpreter ) throws  Unable To Complete Exception {  List <  XMLElement > elements = new  Array List <  XMLElement > ( ) ;  List <  Node > doomed = new  Array List <  Node > ( ) ;  Node List child Nodes = elem . get Child Nodes ( ) ; for ( int i = _ NUM ; i < child Nodes . get Length ( ) ; ++ i ) {  Node child Node = child Nodes . item ( i ) ; if ( child Node . get Node Type ( ) ==  Node .  ELEMENT_ NODE ) {  XMLElement child Element = provider . get ( (  Element ) child Node ) ; if ( interpreter . interpret Element ( child Element ) ) { elements . add ( child Element ) ; doomed . add ( child Node ) ; } } } for (  Node n : doomed ) { elem . remove Child ( n ) ; } return elements ; }
public boolean has Name Value (  String name ) { return hmap . contains Key ( name . to Lower Case ( ) ) ; }
private static  String prepend If Missing ( final  String str , final  Char Sequence prefix , final boolean ignore Case , final  Char Sequence ... prefixes ) { if ( str == null || is Empty ( prefix ) || starts With ( str , prefix , ignore Case ) ) { return str ; } if ( prefixes != null && prefixes . length > _ NUM ) { for ( final  Char Sequence p : prefixes ) { if ( starts With ( str , p , ignore Case ) ) { return str ; } } } return prefix . to String ( ) + str ; }
public void apply Shape (  Region shape ) { if (  Xlib Util . is Shaping Supported ( ) ) { if ( shape Log . is Loggable (  Platform Logger .  Level .  FINER ) ) { shape Log . finer ( _ STR + this + _ STR + get Window ( ) + _ STR + target + _ STR + shape ) ; }  XToolkit . awt Lock ( ) ; try { if ( shape != null ) {  Xlib Wrapper .  Set Rectangular Shape (  XToolkit . get Display ( ) , get Window ( ) , shape . get Lo X ( ) , shape . get Lo Y ( ) , shape . get Hi X ( ) , shape . get Hi Y ( ) , ( shape . is Rectangular ( ) ? null : shape ) ) ; } else {  Xlib Wrapper .  Set Rectangular Shape (  XToolkit . get Display ( ) , get Window ( ) , _ NUM , _ NUM , _ NUM , _ NUM , null ) ; } } finally {  XToolkit . awt Unlock ( ) ; } } else { if ( shape Log . is Loggable (  Platform Logger .  Level .  FINER ) ) { shape Log . finer ( _ STR ) ; } } }
public void fire Property Change (  String property Name , long old Value , long new Value ) { if ( change Support == null || old Value == new Value ) { return ; } fire Property Change ( property Name ,  Long . value Of ( old Value ) ,  Long . value Of ( new Value ) ) ; }
public  Abstract Surface Object ( ) { this . visible = _ BOOL ; this . unique Id = next Unique Id ( ) ; this . last Modified Time =  System . current Time Millis ( ) ; this . enable Batch Picking = _ BOOL ; }
private static  String canonize Tree String (  String str ) {  String canon = str . trim ( ) ;  Pattern pattern =  Pattern . compile ( _ STR ) ;  Matcher matcher = pattern . matcher ( canon ) ; while ( matcher . find ( ) ) { canon = matcher . replace First ( matcher . group ( _ NUM ) ) ; matcher . reset ( canon ) ; } return canon . trim ( ) ; }
private  String create New Review (  Task Data task Data ,  Appraise Plugin Review Client client ) throws  Core Exception { boolean can Request Review = client . can Request Review ( task Data ) ; if ( ! can Request Review ) { throw new  Core Exception (  Status .  CANCEL_ STATUS ) ; }  String task Id = null ; try {  Review review = build Review From Task Data ( task Data ) ; review . set Timestamp (  System . current Time Millis ( ) / _ NUM ) ;  String review Commit Hash = get Review Commit Hash ( task Data ) ; task Id = client . write Review ( review Commit Hash , review ) ; if ( task Id == null ) { throw new  Core Exception (  Status .  CANCEL_ STATUS ) ; } } catch (  Git Client Exception e ) { throw new  Core Exception ( new  Status (  IStatus .  ERROR ,  Appraise Connector Plugin .  PLUGIN_ ID , _ STR , e ) ) ; } return task Id ; }
@  Override public synchronized void power On Self Test ( ) throws  Error {  Log . i (  Mary .  LOG , _ STR ) ; try {  Mary Data Type in Type = maryxml To Mbrola . input Type ( ) ;  Collection voices =  Voice . get Available Voices ( this ) ; if ( voices . is Empty ( ) ) throw new  Error ( _ STR ) ;  Voice v = (  Voice ) voices . iterator ( ) . next ( ) ; assert v != null ;  Mary Data in = new  Mary Data ( in Type , v . get Locale ( ) ) ;  String example = in Type . example Text ( v . get Locale ( ) ) ; if ( example != null ) { in . read From ( new  String Reader ( example ) ) ; in . set Default Voice ( v ) ;  Mary Data mbrola = maryxml To Mbrola . process ( in ) ; mbrola . set Audio File Format ( new  Audio File Format (  Audio File Format .  Type .  WAVE ,  Voice .  AF22050 ,  Audio System .  NOT_ SPECIFIED ) ) ; mbrola . set Default Voice ( v ) ; mbrola Caller . process ( mbrola ) ; } else {  Log . d (  Mary .  LOG , _ STR ) ; } } catch (  Throwable t ) { throw new  Error ( _ STR + to String ( ) + _ STR , t ) ; }  Log . i (  Mary .  LOG , _ STR ) ; }
public final void render (  Terminal Emulator m Emulator ,  Canvas canvas , int top Row , int selection Y1 , int selection Y2 , int selection X1 , int selection X2 ) { final boolean reverse Video = m Emulator . is Reverse Video ( ) ; final int end Row = top Row + m Emulator . m Rows ; final int columns = m Emulator . m Columns ; final int cursor Col = m Emulator . get Cursor Col ( ) ; final int cursor Row = m Emulator . get Cursor Row ( ) ; final boolean cursor Visible = m Emulator . is Showing Cursor ( ) ; final  Terminal Buffer screen = m Emulator . get Screen ( ) ; final int [ ] palette = m Emulator . m Colors . m Current Colors ; if ( reverse Video ) canvas . draw Color ( palette [  Text Style .  COLOR_ INDEX_ FOREGROUND ] ,  Porter Duff .  Mode .  SRC ) ; float height Offset = m Font Line Spacing And Ascent ; for ( int row = top Row ; row < end Row ; row ++ ) { height Offset += m Font Line Spacing ; final int cursor X = ( row == cursor Row && cursor Visible ) ? cursor Col : - _ NUM ; int selx1 = - _ NUM , selx2 = - _ NUM ; if ( row >= selection Y1 && row <= selection Y2 ) { if ( row == selection Y1 ) selx1 = selection X1 ; selx2 = ( row == selection Y2 ) ? selection X2 : m Emulator . m Columns ; }  Terminal Row line Object = screen . allocate Full Line If Necessary ( screen . external To Internal Row ( row ) ) ; final char [ ] line = line Object . m Text ; final int chars Used In Line = line Object . get Space Used ( ) ; long last Run Style = _ NUM ; boolean last Run Inside Cursor = _ BOOL ; int last Run Start Column = - _ NUM ; int last Run Start Index = _ NUM ; boolean last Run Font Width Mismatch = _ BOOL ; int current Char Index = _ NUM ; float measured Width For Run = _ NUM ; for ( int column = _ NUM ; column < columns ; ) { final char char At Index = line [ current Char Index ] ; final boolean char Is Highsurrogate =  Character . is High Surrogate ( char At Index ) ; final int chars For Code Point = char Is Highsurrogate ? _ NUM : _ NUM ; final int code Point = char Is Highsurrogate ?  Character . to Code Point ( char At Index , line [ current Char Index + _ NUM ] ) : char At Index ; final int code Point Wc Width =  Wc Width . width ( code Point ) ; final boolean inside Cursor = ( column >= selx1 && column <= selx2 ) || ( cursor X == column || ( code Point Wc Width == _ NUM && cursor X == column + _ NUM ) ) ; final long style = line Object . get Style ( column ) ; final float measured Code Point Width = ( code Point < ascii Measures . length ) ? ascii Measures [ code Point ] : m Text Paint . measure Text ( line , current Char Index , chars For Code Point ) ; final boolean font Width Mismatch =  Math . abs ( measured Code Point Width / m Font Width - code Point Wc Width ) > _ NUM ; if ( style != last Run Style || inside Cursor != last Run Inside Cursor || font Width Mismatch || last Run Font Width Mismatch ) { if ( column == _ NUM ) { } else { final int column Width Since Last Run = column - last Run Start Column ; final int chars Since Last Run = current Char Index - last Run Start Index ; draw Text Run ( canvas , line , palette , height Offset , last Run Start Column , column Width Since Last Run , last Run Start Index , chars Since Last Run , measured Width For Run , last Run Inside Cursor , last Run Style , reverse Video ) ; } measured Width For Run = _ NUM ; last Run Style = style ; last Run Inside Cursor = inside Cursor ; last Run Start Column = column ; last Run Start Index = current Char Index ; last Run Font Width Mismatch = font Width Mismatch ; } measured Width For Run += measured Code Point Width ; column += code Point Wc Width ; current Char Index += chars For Code Point ; while ( current Char Index < chars Used In Line &&  Wc Width . width ( line , current Char Index ) <= _ NUM ) { current Char Index +=  Character . is High Surrogate ( line [ current Char Index ] ) ? _ NUM : _ NUM ; } } final int column Width Since Last Run = columns - last Run Start Column ; final int chars Since Last Run = current Char Index - last Run Start Index ; draw Text Run ( canvas , line , palette , height Offset , last Run Start Column , column Width Since Last Run , last Run Start Index , chars Since Last Run , measured Width For Run , last Run Inside Cursor , last Run Style , reverse Video ) ; } }
public boolean overlaps Time Range ( int from Time , int to Time ) { int first Stop Time , last Stop Time ; if ( this . headway Seconds != null ) { first Stop Time =  Integer .  MAX_ VALUE ; last Stop Time =  Integer .  MIN_ VALUE ; if ( this . headway Seconds . length == _ NUM ) {  LOG . warn ( _ STR ) ; return _ BOOL ; } for ( int i = _ NUM ; i < this . headway Seconds . length ; i ++ ) { first Stop Time =  Math . min ( first Stop Time , this . start Times [ i ] ) ; last Stop Time =  Math . max ( last Stop Time , this . end Times [ i ] + this . arrivals [ this . arrivals . length - _ NUM ] ) ; } } else { first Stop Time = departures [ _ NUM ] ; last Stop Time = arrivals [ arrivals . length - _ NUM ] ; } return first Stop Time <= to Time && last Stop Time >= from Time ; }
private void paint Background (  Graphics2 D g ,  JComponent c , int x , int y , int width , int height ) {  Color color = c . get Background ( ) ; if ( state ==  Which .  BACKGROUND_ ENABLED ) { color = (  Color ) component Colors [ _ NUM ] ; } else if ( type ==  Common Control State .  DISABLED ) { color = new  Color ( color . get Red ( ) , color . get Green ( ) , color . get Blue ( ) , _ NUM ) ; }  Shape s = shape Generator . create Round Rectangle ( x + _ NUM , y + _ NUM , width - _ NUM , height - _ NUM ,  Corner Size .  BORDER ) ; g . set Paint ( color ) ; g . fill ( s ) ; if ( is Paint Line Seperators ( c ) ) { paint Line Separator ( g , c , width , height ) ; } }
private static  Linked List <  Mary Module > modules Required For Processing (  Mary Data Type source Type ,  Mary Data Type target Type ,  Locale locale ,  Voice voice ,  Linked List <  Mary Data Type > seen Types ) { if ( source Type . equals ( target Type ) ) {  Log . d (  Mary .  LOG , _ STR ) ; return new  Linked List <  Mary Module > ( ) ; }  List <  Mary Module > candidates = null ; if ( voice != null ) candidates = voice . get Preferred Modules Accepting Type ( source Type ) ; if ( candidates == null || candidates . is Empty ( ) ) { candidates = get ( source Type , locale , voice ) ; } if ( candidates == null || candidates . is Empty ( ) ) { return null ; } for (  Iterator <  Mary Module > it = candidates . iterator ( ) ; it . has Next ( ) ; ) {  Mary Module candidate = it . next ( ) ;  Mary Data Type output Type = candidate . output Type ( ) ; if ( ! seen Types . contains ( output Type ) ) { seen Types . add ( output Type ) ;  Log . d (  Mary .  LOG , _ STR + candidate . name ( ) + _ STR + source Type . name ( ) + _ STR + output Type + _ STR + locale + _ STR + voice + _ STR ) ;  Linked List <  Mary Module > path = modules Required For Processing ( output Type , target Type , locale , voice , seen Types ) ; if ( path != null ) { path . add First ( candidate ) ; return path ; } seen Types . remove Last ( ) ; } } return null ; }
public double length ( ) { return  Math . sqrt (  Number Conversions . square ( x ) +  Number Conversions . square ( y ) +  Number Conversions . square ( z ) ) ; }
public long time Millis ( ) { return ( ( _perf . high Res Counter ( ) *  TO_ MILLISECONDS ) /  TICKS_ PER_ SECOND ) ; }
public  Flat Buffer Builder init (  Byte Buffer existing_bb ) { bb = existing_bb ; bb . clear ( ) ; bb . order (  Byte Order .  LITTLE_ ENDIAN ) ; minalign = _ NUM ; space = bb . capacity ( ) ; vtable_in_use = _ NUM ; nested = _ BOOL ; finished = _ BOOL ; object_start = _ NUM ; num_vtables = _ NUM ; vector_num_elems = _ NUM ; return this ; }
private  Map <  String ,  String > produce Stream (  String topic ) {  List <  Integer > subnet = new  Array List < > ( ) ; for ( int i = _ NUM ; i <=  CNT ; i ++ ) subnet . add ( i ) ;  Collections . shuffle ( subnet ) ;  List <  Producer Record <  String ,  String > > messages = new  Array List < > (  CNT ) ;  Map <  String ,  String > key Val Map = new  Hash Map < > ( ) ; for ( int evt = _ NUM ; evt <  CNT ; evt ++ ) { long runtime =  System . current Time Millis ( ) ;  String ip =  KEY_ PREFIX + subnet . get ( evt ) ;  String msg = runtime +  VALUE_ URL + ip ; messages . add ( new  Producer Record < > ( topic , ip , msg ) ) ; key Val Map . put ( ip , msg ) ; } embedded Broker . send Messages ( messages ) ; return key Val Map ; }
private static  String string Of Char ( char ch , int len ) {  String Buffer buf = new  String Buffer ( ) ; for ( int i = _ NUM ; i < len ; i ++ ) { buf . append ( ch ) ; } return buf . to String ( ) ; }
@  Subscribe public synchronized void on Step Moved (  Step Moved Event event ) {  Platform Impl . run And Wait ( null ) ; }
public void trim (  String a Text , int [ ] a Span ) { int begin = a Span [ _ NUM ] ; int end = a Span [ _ NUM ] - _ NUM ;  String data = a Text ; while ( ( begin < ( data . length ( ) - _ NUM ) ) && trim Char ( data . char At ( begin ) ) ) { begin ++ ; } while ( ( end > _ NUM ) && trim Char ( data . char At ( end ) ) ) { end -- ; } end ++ ; a Span [ _ NUM ] = begin ; a Span [ _ NUM ] = end ; }
public void remove Script Finished Listener (  Script Execution Listener l ) { m_ Finished Listeners . remove ( l ) ; }
public void test_get Put Byte Array With Offset And Length ( ) { final int capacity = _ NUM ; final  Byte Array Buffer buf = new  Byte Array Buffer ( capacity ) ; assert Equals ( ( byte ) _ NUM , buf . get Byte ( _ NUM ) ) ; assert Equals ( ( byte ) _ NUM , buf . get Byte ( capacity - _ NUM ) ) ; final int pos = _ NUM ; for ( int i = _ NUM ; i <  LIMIT ; i ++ ) { final byte [ ] expected = new byte [ r . next Int ( capacity - _ NUM ) ] ; final int off = ( expected . length / _ NUM == _ NUM ? _ NUM : r . next Int ( expected . length / _ NUM ) ) ; final int len = ( expected . length == _ NUM ? _ NUM : r . next Int ( expected . length - off ) ) ; r . next Bytes ( expected ) ; buf . put ( pos , expected , off , len ) ; assert Equals ( _ NUM ,  Bytes Util . compare Bytes With Len And Offset ( off , len , expected , pos , len , buf . array ( ) ) ) ; final int dstoff = r . next Int ( _ NUM ) ; final byte [ ] actual = new byte [ expected . length + dstoff ] ; buf . get ( pos , actual , dstoff , expected . length ) ; assert Equals ( _ NUM ,  Bytes Util . compare Bytes With Len And Offset ( off , len , expected , dstoff , len , actual ) ) ; } assert Equals ( ( byte ) _ NUM , buf . get Byte ( _ NUM ) ) ; assert Equals ( ( byte ) _ NUM , buf . get Byte ( pos + capacity - _ NUM ) ) ; }
private  Object [ ] ensure Capacity ( int min Capacity ) { if ( tmp . length < min Capacity ) { int new Size = min Capacity ; new Size |= new Size > > _ NUM ; new Size |= new Size > > _ NUM ; new Size |= new Size > > _ NUM ; new Size |= new Size > > _ NUM ; new Size |= new Size > > _ NUM ; new Size ++ ; if ( new Size < _ NUM ) new Size = min Capacity ; else new Size =  Math . min ( new Size , a . length > > > _ NUM ) ;  Object [ ] new Array = new  Object [ new Size ] ; tmp = new Array ; } return tmp ; }
public void  CL ( int session Number ,  String client Line ) { this . max Session Number =  Math . max ( this . max Session Number , session Number ) ; test Elements . add ( new  Client Request ( session Number , client Line ) ) ; }
public void rotate (  Point F p1 ,  Point F p2 , float angle ) { float px = p1 . x ; float py = p1 . y ; float ox = p2 . x ; float oy = p2 . y ; p1 . x = ( float ) (  Math . cos ( angle ) * ( px - ox ) -  Math . sin ( angle ) * ( py - oy ) + ox ) ; p1 . y = ( float ) (  Math . sin ( angle ) * ( px - ox ) +  Math . cos ( angle ) * ( py - oy ) + oy ) ; }
private static int count Gaps Dash Dot (  String sequence ) { int count = _ NUM ; for ( int i = _ NUM ; i < sequence . length ( ) ; i ++ ) { int a = sequence . char At ( i ) ; if ( a == _ STR || a == _ STR ) count ++ ; } return count ; }
public  CRLNumber Extension ( int crl Num ) throws  IOException { this (  PKIXExtensions .  CRLNumber_ Id , _ BOOL ,  Big Integer . value Of ( crl Num ) ,  NAME ,  LABEL ) ; }
static private double calc Log Prob At Mu ( double mu ) { final double sigma = calc Sigma From Mu ( mu ) ; return ( - s_log Sqrt Two Pi -  Math . log ( sigma ) ) ; }
public boolean is Nearly Equal To (  Int Vector v , double tolerance ) { return  Math . abs ( v . x - x ) < tolerance &&  Math . abs ( v . y - y ) < tolerance &&  Math . abs ( v . z - z ) < tolerance ; }
protected final void drag Exit ( final int x , final int y ) {  Drag Source Event event = new  Drag Source Event ( get Drag Source Context ( ) , x , y ) ;  Event Dispatcher dispatcher = new  Event Dispatcher (  DISPATCH_ EXIT , event ) ;  Sun Toolkit . invoke Later On App Context (  Sun Toolkit . target To App Context ( get Component ( ) ) , dispatcher ) ; start Secondary Event Loop ( ) ; }
protected static  String extract Bucket (  String s3uri ) { return s3uri . substring ( s3uri . index Of ( _ STR ) + _ NUM , s3uri . index Of ( _ STR , s3uri . index Of ( _ STR ) ) ) ; }
private void send SMS (  String message ,  String contact Information ) {  Resolved Contact rc = m Contacts Resolver . resolve Contact ( contact Information ,  Contacts Resolver .  TYPE_ CELL ) ; if ( rc == null ) { send (  R . string . chat_no_match_for , contact Information ) ; } else if ( rc . is Distinct ( ) ) { send SMSBy Phone Number ( message , rc . get Number ( ) , rc . get Name ( ) ) ; } else { ask For More Details ( rc . get Candidates ( ) ) ; } }
public boolean is Safe Class (  Soot Class clz ) { return safe Classes . contains ( clz . get Name ( ) ) ; }
public void remove From Active List (  Download Info Runnable download Info Runnable ) { m Active List . remove ( download Info Runnable ) ; }
public boolean is Running ( ) { return running ; }
@  Override public void validate Parameters ( ) {  Set <  String > unique Ids = new  Hash Set < > ( ) ; for (  Step step : steps ) { unique Ids . add ( step . get Identifier ( ) ) ; } if ( unique Ids . size ( ) != steps . size ( ) ) { throw new  Invalid Task Exception ( _ STR ) ; } }
@  Override public  String to String ( ) { final  String Builder sb = new  String Builder ( ) ; sb . append ( _ STR ) ; sb . append ( get Request ID ( ) ) ; sb . append ( _ STR ) ; sb . append ( timestamp ) ; sb . append ( _ STR ) ; sb . append ( get Request ( ) ) ; sb . append ( _ STR ) ; return sb . to String ( ) ; }
public void test_empty Journal ( ) throws  IOException ,  Interrupted Exception ,  Execution Exception { final  File out =  File . create Temp File ( get Name ( ) ,  Options .  JNL ) ; try { final  Journal src = get Store ( get Properties ( ) ) ; try { try { final  Future <  Journal > f = src . compact ( out ) ; final  Journal new Journal = f . get ( ) ; try { new Journal . destroy ( ) ; } finally { fail ( _ STR +  Illegal Argument Exception . class ) ; } } catch (  Illegal Argument Exception ex ) { log . info ( _ STR + ex ) ; } } finally { src . destroy ( ) ; } } finally { out . delete ( ) ; } }
public static int check Actions (  Map <  String ,  Object > entry ) { boolean ip6 = _ BOOL ; boolean ip4 = _ BOOL ;  String actions = null ; if ( entry . contains Key (  Static Flow Entry Pusher .  COLUMN_ ACTIONS ) || entry . contains Key (  Static Flow Entry Pusher .  COLUMN_ INSTR_ APPLY_ ACTIONS ) || entry . contains Key (  Static Flow Entry Pusher .  COLUMN_ INSTR_ WRITE_ ACTIONS ) ) { if ( entry . contains Key (  Static Flow Entry Pusher .  COLUMN_ ACTIONS ) ) { actions = (  String ) entry . get (  Static Flow Entry Pusher .  COLUMN_ ACTIONS ) ; } else if ( entry . contains Key (  Static Flow Entry Pusher .  COLUMN_ INSTR_ APPLY_ ACTIONS ) ) { actions = (  String ) entry . get (  Static Flow Entry Pusher .  COLUMN_ INSTR_ APPLY_ ACTIONS ) ; } else if ( entry . contains Key (  Static Flow Entry Pusher .  COLUMN_ INSTR_ WRITE_ ACTIONS ) ) { actions = (  String ) entry . get (  Static Flow Entry Pusher .  COLUMN_ INSTR_ WRITE_ ACTIONS ) ; } if ( actions . contains (  Match Utils .  STR_ ICMPV6_ CODE ) || actions . contains (  Match Utils .  STR_ ICMPV6_ TYPE ) || actions . contains (  Match Utils .  STR_ IPV6_ DST ) || actions . contains (  Match Utils .  STR_ IPV6_ SRC ) || actions . contains (  Match Utils .  STR_ IPV6_ FLOW_ LABEL ) || actions . contains (  Match Utils .  STR_ IPV6_ ND_ SSL ) || actions . contains (  Match Utils .  STR_ IPV6_ ND_ TARGET ) || actions . contains (  Match Utils .  STR_ IPV6_ ND_ TTL ) ) { ip6 = _ BOOL ; } if ( actions . contains (  Match Utils .  STR_ NW_ SRC ) || actions . contains (  Match Utils .  STR_ NW_ DST ) || actions . contains (  Match Utils .  STR_ ARP_ OPCODE ) || actions . contains (  Match Utils .  STR_ ARP_ SHA ) || actions . contains (  Match Utils .  STR_ ARP_ DHA ) || actions . contains (  Match Utils .  STR_ ARP_ SPA ) || actions . contains (  Match Utils .  STR_ ARP_ DPA ) || actions . contains (  Match Utils .  STR_ ICMP_ CODE ) || actions . contains (  Match Utils .  STR_ ICMP_ TYPE ) ) { ip4 = _ BOOL ; } } if ( ip6 == _ BOOL && ip4 == _ BOOL ) { return _ NUM ; } else if ( ip6 == _ BOOL && ip4 == _ BOOL ) { return _ NUM ; } else if ( ip6 == _ BOOL && ip4 == _ BOOL ) { return _ NUM ; } else { return - _ NUM ; } }
public static double pow ( double value , double power ) { if (  USE_ JDK_ MATH ) { return  STRICT_ MATH ?  Strict Math . pow ( value , power ) :  Math . pow ( value , power ) ; } if ( power == _ NUM ) { return _ NUM ; } else if ( power == _ NUM ) { return value ; } if ( value <= _ NUM ) { int power Info ; if (  Math . abs ( power ) >= (  TWO_ POW_52 * _ NUM ) ) { power Info = _ NUM ; } else { if (  Math . abs ( power ) <= ( double )  Integer .  MAX_ VALUE ) { int power As Int = ( int ) power ; if ( power == ( double ) power As Int ) { power Info = ( ( power As Int & _ NUM ) == _ NUM ) ? _ NUM : - _ NUM ; } else { power Info = _ NUM ; } } else { long power As Long = ( long ) power ; if ( power == ( double ) power As Long ) { power Info = ( ( power As Long & _ NUM ) == _ NUM ) ? _ NUM : - _ NUM ; } else { if ( power != power ) { return  Double .  Na N ; } power Info = _ NUM ; } } } if ( value == _ NUM ) { if ( power < _ NUM ) { return ( power Info < _ NUM ) ? _ NUM / value :  Double .  POSITIVE_ INFINITY ; } else { return ( power Info < _ NUM ) ? value : _ NUM ; } } else { if ( value ==  Double .  NEGATIVE_ INFINITY ) { if ( power Info < _ NUM ) { return ( power < _ NUM ) ? - _ NUM :  Double .  NEGATIVE_ INFINITY ; } else { return ( power < _ NUM ) ? _ NUM :  Double .  POSITIVE_ INFINITY ; } } else { return ( power Info != _ NUM ) ? power Info *  Fast Math . exp ( power *  Fast Math . log ( - value ) ) :  Double .  Na N ; } } } else { return  Fast Math . exp ( power *  Fast Math . log ( value ) ) ; } }
private static  Class < ? > find Class (  Class Loader loader ,  Class < ? > clazz ) { final  String name = clazz . get Name ( ) ; if ( name . starts With ( _ STR ) || name . starts With ( _ STR ) ) return null ;  String generated Class Name = generate Retainer Class Name ( name ) ; try { if (  Akatsuki . logging Level ==  Akatsuki Config .  Logging Level .  VERBOSE )  Log . i (  Akatsuki .  TAG , _ STR + clazz ) ; return  Class . for Name ( generated Class Name , _ BOOL , loader ) ; } catch (  Class Not Found Exception e ) { return find Class ( loader , clazz . get Superclass ( ) ) ; } }
public  POSMikheev Feature Extractor (  String view Name ,  String json ) { this . view Name = view Name ; this . counter =  POSMikheev Counter . read ( json ) ; }
private  Map <  String ,  Annotation Mirror > annos In Type (  Type Element type Element ) { return create Imported Annotations Map (  Element Filter . types In ( type Element . get Enclosed Elements ( ) ) ) ; }
public void replace Node ( final  Node node ) {  List <  Way > ways = current Storage . get Ways ( node ) ; if ( ways . size ( ) > _ NUM ) {  Node new Node = factory . create Node With New Id ( node . lat , node . lon ) ; insert Element Unsafe ( new Node ) ; dirty = _ BOOL ; for (  Way way : ways ) { replace Node In Way ( node , new Node , way ) ; } } }
void update Cursor ( ) { if ( model . get Hovering Operator ( ) != null || model . get Hovering Port ( ) != null ) { set Cursor (  Cursor . get Predefined Cursor (  Cursor .  HAND_ CURSOR ) ) ; } else { set Cursor (  Cursor . get Default Cursor ( ) ) ; } }
public static boolean is Middle Mouse Button (  Mouse Event an Event ) { return ( an Event . get Modifiers Ex ( ) &  Input Event .  BUTTON2_ DOWN_ MASK ) > _ NUM ; }
public static  List <  String > build Command ( final  String class Name , final  String additional Classpath , final  Properties system Properties , final  List <  String > jvm Options ) { final  List <  String > java Command Line = new  Array List <  String > ( ) ; final  File java Bin Dir = new  File (  System . get Property ( _ STR ) , _ STR ) ; final  File java Command = new  File ( java Bin Dir , _ STR ) ; java Command Line . add ( java Command . get Path ( ) ) ; final  String dash Server Arg = get Dash Server Arg ( java Bin Dir ) ; if ( dash Server Arg != null ) { java Command Line . add ( dash Server Arg ) ; } if ( jvm Options != null ) { for ( final  String jvm Option : jvm Options ) { java Command Line . add ( jvm Option ) ; } } java Command Line . add ( _ STR ) ; java Command Line . add ( build Classpath ( additional Classpath ) ) ; if ( system Properties != null ) { for ( final  Object key : system Properties . key Set ( ) ) { java Command Line . add ( _ STR + key + _ STR + system Properties . get Property ( key . to String ( ) ) ) ; } } java Command Line . add ( class Name ) ; return java Command Line ; }
private void correct Changed ( ) { clock . set Correct Hardware ( correct Check Box . is Selected ( ) , _ BOOL ) ; changed = _ BOOL ; }
protected void reopen ( ) throws  IOException { if ( input Stream != null ) {  Debug . message ( _ STR , _ STR ) ; input Stream . close ( ) ; } input Stream Count = _ NUM ; }
private void read ASCII ( final  Buffered Reader buffer ) throws  Number Format Exception ,  IOException {  Raj Log . i ( _ STR ) ; final  List <  Float > vertices = new  Array List <  Float > ( ) ; final  List <  Float > normals = new  Array List <  Float > ( ) ; final float [ ] temp Norms = new float [ _ NUM ] ; int next Offset , prev Offset , i , insert ;  String line ; line = buffer . read Line ( ) ; while ( ( line = buffer . read Line ( ) ) != null ) { if ( line . contains ( _ STR ) ) { next Offset = line . last Index Of ( _ STR ) ; temp Norms [ _ NUM ] =  Float . parse Float ( line . substring ( next Offset + _ NUM ) ) ; prev Offset = next Offset ; next Offset = line . last Index Of ( _ STR , prev Offset - _ NUM ) ; temp Norms [ _ NUM ] =  Float . parse Float ( line . substring ( next Offset + _ NUM , prev Offset ) ) ; prev Offset = next Offset ; next Offset = line . last Index Of ( _ STR , prev Offset - _ NUM ) ; temp Norms [ _ NUM ] =  Float . parse Float ( line . substring ( next Offset + _ NUM , prev Offset ) ) ; for ( i = _ NUM ; i < _ NUM ; i ++ ) { normals . add ( temp Norms [ _ NUM ] ) ; normals . add ( temp Norms [ _ NUM ] ) ; normals . add ( temp Norms [ _ NUM ] ) ; } } else if ( line . contains ( _ STR ) ) { insert = vertices . size ( ) ; next Offset = line . last Index Of ( _ STR ) ; vertices . add (  Float . parse Float ( line . substring ( next Offset + _ NUM ) ) ) ; prev Offset = next Offset ; next Offset = line . last Index Of ( _ STR , prev Offset - _ NUM ) ; vertices . add ( insert ,  Float . parse Float ( line . substring ( next Offset + _ NUM , prev Offset ) ) ) ; prev Offset = next Offset ; next Offset = line . last Index Of ( _ STR , prev Offset - _ NUM ) ; vertices . add ( insert ,  Float . parse Float ( line . substring ( next Offset + _ NUM , prev Offset ) ) ) ; } } float [ ] vertices Arr = new float [ vertices . size ( ) ] ; float [ ] normals Arr = new float [ normals . size ( ) ] ; for ( i = _ NUM ; i < vertices Arr . length ; i ++ ) { vertices Arr [ i ] = vertices . get ( i ) ; normals Arr [ i ] = normals . get ( i ) ; } vertices . clear ( ) ; normals . clear ( ) ; int [ ] indices Arr = new int [ vertices Arr . length / _ NUM ] ; for ( i = _ NUM ; i < indices Arr . length ; i ++ ) indices Arr [ i ] = i ; m Root Object . set Data ( vertices Arr , normals Arr , null , null , indices Arr , _ BOOL ) ; }
public static void assert Array Name (  String array Name ) throws  XMPException { if ( array Name == null || array Name . length ( ) == _ NUM ) { throw new  XMPException ( _ STR ,  XMPError .  BADPARAM ) ; } }
public  Entity Bomb add Time ( int time ) { fuse Time =  Math . max ( fuse Time + time , fuse Time ) ; return this ; }
@  Override public void release Reader ( ) { reader Lock . unlock ( ) ; }
@  Override public void on Draw Frame (  GL10 gl10 ) {  GLES20 . gl Clear Color ( _ NUM , _ NUM , _ NUM , _ NUM ) ;  GLES20 . gl Clear (  GLES20 .  GL_ COLOR_ BUFFER_ BIT |  GLES20 .  GL_ DEPTH_ BUFFER_ BIT ) ;  GLES20 . gl Enable (  GLES20 .  GL_ DEPTH_ TEST ) ;  GLES20 . gl Enable (  GLES20 .  GL_ CULL_ FACE ) ; long current Time Millis =  System . current Time Millis ( ) ; update With Delta ( current Time Millis - last Time Millis ) ; last Time Millis = current Time Millis ; }
public void add COSAttribute (  String attr Name , int qualifier ) throws  UMSException {  String Builder attr Str = new  String Builder ( ) ; if ( qualifier <  ICOSDefinition . min Qualifier || qualifier >  ICOSDefinition . max Qualifier ) {  String msg = i18n . get String (  IUMSConstants .  BAD_ COS_ ATTR_ QUALIFIER ) ; throw new  UMSException ( msg ) ; } attr Str . append ( attr Name ) ; attr Str . append ( _ STR ) ; attr Str . append (  ICOSDefinition . qualifiers [ qualifier ] ) ; modify (  ICOSDefinition .  COSATTRIBUTE , attr Str . to String ( ) ,  Modification Type .  ADD ) ; }
@  Deprecated public static  Source Data Tag Quality from XML (  Element dom Element ) {  Node List fields = dom Element . get Child Nodes ( ) ; int fields Count = fields . get Length ( ) ;  String field Name ;  String field Value String ;  Node field Node ;  Source Data Tag Quality result = new  Source Data Tag Quality ( ) ; for ( int i = _ NUM ; i != fields Count ; i ++ ) { field Node = fields . item ( i ) ; if ( field Node . get Node Type ( ) ==  Node .  ELEMENT_ NODE ) { field Name = field Node . get Node Name ( ) ;  Node field Value Node = field Node . get First Child ( ) ; if ( field Value Node != null ) { field Value String = field Value Node . get Node Value ( ) ; } else { field Value String = _ STR ; } if ( field Name . equals (  XML_ ELEMENT_ QUALITY_ CODE ) ) { short code =  Short . parse Short ( field Value String ) ; result . quality Code =  Source Data Tag Quality Code . get Enum ( code ) ; } else if ( field Name . equals (  XML_ ELEMENT_ QUALITY_ DESC ) ) { result . description = field Value String ; } } } return result ; }
public static  String to SQLName (  Field field ) { if ( field . is Annotation Present (  Column . class ) ) {  Column annotation = field . get Annotation (  Column . class ) ; return annotation . name ( ) ; } return to SQLName Default ( field . get Name ( ) ) ; }
public static  Boolean verify JWT ( final  String jwt , final  String secret ) throws  Hmac Exception { try {  Signed JWT signed JWT =  Signed JWT . parse ( jwt ) ;  JWSVerifier jws Verifier = new  MACVerifier ( secret ) ; return signed JWT . verify ( jws Verifier ) ; } catch (  Parse Exception |  JOSEException ex ) { throw new  Hmac Exception ( _ STR , ex ) ; } }
public void flatten Symbol Table ( boolean flatten All Tables ) { if ( ! flatten All Tables ) {  List <  Symbol > new Symbols = new  Array List <  Symbol > ( ) ; if ( this . symbol Table != null ) { for ( int i = _ NUM ; i < symbols . size ( ) ; i ++ ) {  Symbol symbol = symbols . get ( i ) ; if ( symbol . get Containing Table ( ) == this ) { new Symbols . add ( symbol ) ; } } } symbols = new Symbols ; } variable Names = new  String [ symbols . size ( ) ] ; is Consts = new boolean [ symbols . size ( ) ] ; for ( int i = _ NUM ; i < symbols . size ( ) ; i ++ ) {  Symbol symbol = symbols . get ( i ) ; variable Names [ i ] = symbol . get Name ( ) ; is Consts [ i ] = symbol . get Decl Type ( ) ==  Token .  CONST ; symbol . set Index ( i ) ; } }
@  Override public synchronized void add Instance Listener (  Instance Listener dsl ) { m_instance Listeners . add Element ( dsl ) ; if ( m_format != null ) {  Instance Event e = new  Instance Event ( this , m_format ) ; dsl . accept Instance ( e ) ; } }
public static  Set <  Annotation Mirror > glb Of Bounds ( final  Annotated Intersection Type isect , final  Qualifier Hierarchy qualifier Hierarchy ) {  Set <  Annotation Mirror > result =  Annotation Utils . create Annotation Set ( ) ; for ( final  Annotation Mirror top : qualifier Hierarchy . get Top Annotations ( ) ) { final  Annotation Mirror glb Anno = glb Of Bounds In Hierarchy ( isect , top , qualifier Hierarchy ) ; if ( glb Anno != null ) { result . add ( glb Anno ) ; } } return result ; }
public boolean to Stopping ( ) {  Lifecycle State state ; synchronized ( this ) { state = _state ; if ( state . is After Stopping ( ) || state . is Starting ( ) ) { return _ BOOL ; } _state =  STOPPING ; _last Change Time =  Current Time . current Time ( ) ; } if ( _log != null && _log . is Loggable ( _level ) ) { _log . log ( _level , _ STR + _name ) ; } notify Listeners ( state ,  STOPPING ) ; return _ BOOL ; }
public byte [ ] receive Message ( ) throws  IOException { byte [ ] prefix = new byte [ _ NUM ] ; int idx = _ NUM ; while ( idx < _ NUM ) { int read = in . read ( prefix , idx , _ NUM - idx ) ; if ( read < _ NUM ) throw new  IOException ( _ STR ) ; idx += read ; } int len =  U . bytes To Int ( prefix , _ NUM ) ; byte [ ] res = new byte [ len ] ; idx = _ NUM ; while ( idx < len ) { int read = in . read ( res , idx , len - idx ) ; if ( read < _ NUM ) throw new  IOException ( _ STR ) ; idx += read ; } return res ; }
public double evaluate (  Vector Instance x ,  Vector Instance y ) throws  Exception { double dot Prod = x . dot Product ( y ) ; double z = m_gamma * dot Prod + m_coef0 ; double a =  Math . exp ( z ) ; double b =  Math . exp ( - z ) ; return ( ( a - b ) / ( a + b ) ) ; }
void cancel Included Only ( ) { if ( ! show All ) { all Button . do Click ( ) ; } }
public  Watermark Disk Quota Policy (  List <  Entry > entries ) { entries = new  Array List < > ( entries ) ;  Collections . sort ( entries ,  POLICY_ COMPARATOR ) ; this . entries =  Collections . unmodifiable List ( entries ) ; double last High Water Mark = _ NUM ; double last Work Factor =  Throttleable .  MAX_ WORK_ FACTOR ; for ( int i = _ NUM ; i < entries . size ( ) ; ++ i ) { final  Entry entry = entries . get ( i ) ; if ( last High Water Mark < entry . get High Water Mark Percent ( ) ) { throw new  Illegal Argument Exception ( _ STR + i + _ STR + entry . get High Water Mark Percent ( ) + _ STR + last High Water Mark + _ STR + dump Policy Entries ( entries ) ) ; } if ( last Work Factor < entry . get Work Factor ( ) ) { throw new  Illegal Argument Exception ( _ STR + i + _ STR + entry . get Work Factor ( ) + _ STR + last Work Factor + _ STR + dump Policy Entries ( entries ) ) ; } if ( entry . get Work Factor ( ) <  Throttleable .  MIN_ WORK_ FACTOR ) { throw new  Illegal Argument Exception ( _ STR + i + _ STR + entry . get Work Factor ( ) + _ STR +  Throttleable .  MIN_ WORK_ FACTOR + _ STR + dump Policy Entries ( entries ) ) ; } last High Water Mark = entry . get High Water Mark Percent ( ) ; last Work Factor = entry . get Work Factor ( ) ; } log . info ( _ STR , entries . is Empty ( ) ? _ STR : dump Policy Entries ( entries ) ) ; }
public void read Dictionary (  String filename ,  String suffix ,  Input Stream res ) throws  IOException {  Buffered Reader in = new  Buffered Reader ( new  Input Stream Reader ( res ) ) ;  String line ; while ( ( line = in . read Line ( ) ) != null ) {  String [ ] terms = splitter . split ( line ) ; if ( terms . length > max Phrase Length ) continue ; if ( terms . length == _ NUM ) continue ;  Gaz Entry ge = gaz . get ( terms [ _ NUM ] ) ; if ( ge == null ) { gaz . put ( terms [ _ NUM ] , new  Gaz Entry ( terms , _ NUM , filename + suffix ) ) ; } else { ge . add Child ( terms , _ NUM , filename + suffix ) ; } } in . close ( ) ; }
public static  String extract Remote Host (  String connection Info ) {  String [ ] tokens = connection Info . split ( _ STR ) ; if ( tokens . length > _ NUM ) { return tokens [ _ NUM ] ; } return null ; }
protected void draw Actor ( int x , int y , int w , int h ,  Color fill Color ,  Paint fill Paint ,  Color pen Color , boolean shadow ) { float width = w * _ NUM / _ NUM ;  General Path path = new  General Path ( ) ; path . move To ( x , y + h ) ; path . curve To ( x , y + _ NUM * h / _ NUM , x , y + _ NUM * h / _ NUM , x + w / _ NUM , y + _ NUM * h / _ NUM ) ; path . curve To ( x + w / _ NUM - width , y + _ NUM * h / _ NUM , x + w / _ NUM - width , y , x + w / _ NUM , y ) ; path . curve To ( x + w / _ NUM + width , y , x + w / _ NUM + width , y + _ NUM * h / _ NUM , x + w / _ NUM , y + _ NUM * h / _ NUM ) ; path . curve To ( x + w , y + _ NUM * h / _ NUM , x + w , y + _ NUM * h / _ NUM , x + w , y + h ) ; path . close Path ( ) ; draw Path ( path , fill Color , fill Paint , pen Color , shadow ) ; }
private static boolean trusted (  Set set ,  Trust Verifier .  Context ctx ) throws  Remote Exception { return trusted ( set . iterator ( ) , ctx ) ; }
public static  Persistent Search Request Control new Control ( final boolean is Critical , final boolean changes Only , final boolean return ECs , final  Collection <  Persistent Search Change Type > change Types ) {  Reject . if Null ( change Types ) ; final  Set <  Persistent Search Change Type > copy Of Change Types =  Enum Set . none Of (  Persistent Search Change Type . class ) ; copy Of Change Types . add All ( change Types ) ; return new  Persistent Search Request Control ( is Critical , changes Only , return ECs ,  Collections . unmodifiable Set ( copy Of Change Types ) ) ; }
public static boolean test Recurrence (  List <  Neuron > source Neurons ,  List <  Neuron > target Neurons ) { if ( source Neurons . size ( ) != target Neurons . size ( ) ) { return _ BOOL ; } else { for ( int i = _ NUM ; i < source Neurons . size ( ) ; i ++ ) { if ( source Neurons . get ( i ) != target Neurons . get ( i ) ) { return _ BOOL ; } } } return _ BOOL ; }
public static  Number multiply (  Character left ,  Number right ) { return  Number Number Multiply . multiply (  Integer . value Of ( left ) , right ) ; }
public static  String mask Right (  String s , int len , char mask_ch ) { if ( len <= _ NUM ) { return s ; } len =  Math . min ( len , s . length ( ) ) ;  String Builder sb = new  String Builder ( ) ; sb . append ( s . substring ( _ NUM , s . length ( ) - len ) ) ; for ( int i = _ NUM ; i < len ; i ++ ) { sb . append ( mask_ch ) ; } return sb . to String ( ) ; }
public void add (  Io Service Listener listener ) { if ( listener != null ) { listeners . add ( listener ) ; } }
public long save ( ) { if ( m_is Saved ) { throw new  Illegal State Exception (  ERR_ ALREADY_ SAVED ) ; } if ( m_store == null ) { return _ NUM ; } if ( m_count == _ NUM ) { m_is Saved = _ BOOL ; return _ NUM ; } int addr = ( int ) m_store . alloc ( m_buf , m_count , m_context ) ; if ( m_blob Header != null ) { try { m_writing Hdr = _ BOOL ; m_blob Header . add ( addr ) ; m_count = _ NUM ; try { final int hdr Buf Size = _ NUM * ( m_blob Header . size ( ) + _ NUM ) ; final  Byte Array Output Stream hdrbuf = new  Byte Array Output Stream ( hdr Buf Size ) ; final  Data Output Stream hdrout = new  Data Output Stream ( hdrbuf ) ; hdrout . write Int ( m_blob Header . size ( ) ) ; for ( int i = _ NUM ; i < m_blob Header . size ( ) ; i ++ ) { hdrout . write Int ( m_blob Header . get ( i ) ) ; } hdrout . flush ( ) ; final byte [ ] outbuf = hdrbuf . to Byte Array ( ) ; addr = ( int ) m_store . alloc ( outbuf , hdr Buf Size , m_context ) ; } catch (  IOException e ) { throw new  Runtime Exception ( e ) ; } } finally { m_writing Hdr = _ BOOL ; } } m_is Saved = _ BOOL ; return addr ; }
public  Weak Close Listener (  Object resource ) { _resource Ref = new  Weak Reference <  Object > ( resource ) ; }
static public <  T > void shuffle (  List <  T > list ,  Random rand , int last Index ) { int i , j , size = last Index - _ NUM ; for ( i = _ NUM ; i < size ; i ++ ) { j = rand . next Int ( size - i ) + i + _ NUM ; swap ( list , i , j ) ; } }
public void hide ( ) { m Dismissed = _ BOOL ; remove Callbacks ( m Delayed Show ) ; long diff =  System . current Time Millis ( ) - m Start Time ; if ( diff >=  MIN_ SHOW_ TIME || m Start Time == - _ NUM ) { set Visibility (  View .  GONE ) ; } else { if ( ! m Posted Hide ) { post Delayed ( m Delayed Hide ,  MIN_ SHOW_ TIME - diff ) ; m Posted Hide = _ BOOL ; } } }
public void tear Down ( ) throws  Exception {  Throwable t = thread Failure . get And Set ( null ) ; if ( t != null ) { if ( t instanceof  Error ) throw (  Error ) t ; else if ( t instanceof  Runtime Exception ) throw (  Runtime Exception ) t ; else if ( t instanceof  Exception ) throw (  Exception ) t ; else {  Assertion Failed Error afe = new  Assertion Failed Error ( t . to String ( ) ) ; afe . init Cause ( t ) ; throw afe ; } } }
protected double compute Factor ( double omega , double sigma ) { double root =  Math . sqrt (  Math . pow ( _ NUM , _ NUM / omega ) - _ NUM ) ; return _ NUM * root / sigma ; }
public void trim To Size ( ) { if ( count < value . length ) { char [ ] new Value = new char [ count ] ;  System . arraycopy ( value , _ NUM , new Value , _ NUM , count ) ; value = new Value ; } }
public void insert (  Menu Item menuitem , int index ) { synchronized ( get Tree Lock ( ) ) { if ( index < _ NUM ) { throw new  Illegal Argument Exception ( _ STR ) ; } int nitems = get Item Count ( ) ;  Vector <  Menu Item > temp Items = new  Vector < > ( ) ; for ( int i = index ; i < nitems ; i ++ ) { temp Items . add Element ( get Item ( index ) ) ; remove ( index ) ; } add ( menuitem ) ; for ( int i = _ NUM ; i < temp Items . size ( ) ; i ++ ) { add ( temp Items . element At ( i ) ) ; } } }
public static  String unmask ( char char To Unmask ,  String masked ) { if ( char To Unmask == _ STR || char To Unmask == _ STR ) { throw new  Illegal Argument Exception ( _ STR + char To Unmask + _ STR ) ; }  String Builder unmasked String Builder = new  String Builder ( ) ; char mask Char = _ STR ; char escape Char = _ STR ; boolean escape Char Found = _ BOOL ; for ( char c : masked . to Char Array ( ) ) { if ( c == mask Char ) { if ( escape Char Found ) { unmasked String Builder . append ( mask Char ) ; escape Char Found = _ BOOL ; } else { unmasked String Builder . append ( char To Unmask ) ; } } else if ( c == escape Char ) { if ( escape Char Found ) { unmasked String Builder . append ( escape Char ) ; escape Char Found = _ BOOL ; } else { escape Char Found = _ BOOL ; } } else { unmasked String Builder . append ( c ) ; } } return unmasked String Builder . to String ( ) ; }
private  List <  Quote > download Url (  String url Param ) throws  IOException ,  Xml Pull Parser Exception {  Input Stream is = null ; try {  URL url = new  URL ( url Param ) ;  Http URLConnection conn = (  Http URLConnection ) url . open Connection ( ) ; conn . set Read Timeout ( _ NUM ) ; conn . set Connect Timeout ( _ NUM ) ; conn . set Request Method ( _ STR ) ; conn . set Do Input ( _ BOOL ) ; conn . connect ( ) ; int response = conn . get Response Code ( ) ;  Log . d ( _ STR , _ STR + response ) ; if ( response == _ NUM ) { is = conn . get Input Stream ( ) ; return read XML ( is ) ; } } finally { if ( is != null ) { is . close ( ) ; } } return null ; }
public  Concurrent Hash Map (  Map < ? extends  K , ? extends  V > m ) { this (  Math . max ( ( int ) ( m . size ( ) /  DEFAULT_ LOAD_ FACTOR ) + _ NUM ,  DEFAULT_ INITIAL_ CAPACITY ) ,  DEFAULT_ LOAD_ FACTOR ,  DEFAULT_ CONCURRENCY_ LEVEL ) ; put All ( m ) ; }
private static void encode Patterns (  IPath [ ] patterns ,  String tag ,  Map parameters ) { if ( patterns != null && patterns . length > _ NUM ) {  String Buffer rule = new  String Buffer ( _ NUM ) ; for ( int i = _ NUM , max = patterns . length ; i < max ; i ++ ) { if ( i > _ NUM ) rule . append ( _ STR ) ; rule . append ( patterns [ i ] ) ; } parameters . put ( tag ,  String . value Of ( rule ) ) ; } }
public  Matrix ( final double [ ] [ ] data , final  Set <  Address .  Flags > flags ) { super ( data . length , data [ _ NUM ] . length , null ) ; this . addr = new  Direct Matrix Address ( this . $ , _ NUM , data . length , null , _ NUM , data [ _ NUM ] . length , flags , _ BOOL , data . length , data [ _ NUM ] . length ) ; for ( int row = _ NUM ; row < data . length ; row ++ ) {  System . arraycopy ( data [ row ] , _ NUM , this . $ , row * this . cols , this . cols ) ; } }
private boolean region Dialing From Matches Number (  Phone Number number ,  String region Dialing From ) {  List <  String > region Codes = get Region Codes For Country Code ( number . get Country Code ( ) ) ; return region Codes . contains ( region Dialing From ) ; }
private  OMGraphic List plot Data Sources (  GLOBETemp Data temperature_data ) {  Debug . message ( _ STR , _ STR ) ; int num_graphics = _ NUM ;  OMGraphic List graphics = new  OMGraphic List ( ) ; graphics . set Traverse Mode (  OMGraphic List .  LAST_ ADDED_ ON_ TOP ) ;  Enumeration site_enum = temperature_data . get All Sites ( ) ; while ( site_enum . has More Elements ( ) ) {  GLOBESite site = (  GLOBESite ) site_enum . next Element ( ) ; graphics . add ( site . get Graphic ( ) ) ; num_graphics ++ ; }  Debug . message ( _ STR , _ STR + num_graphics + _ STR ) ; return graphics ; }
public static boolean is Jdbc Package (  String package Name ) { return package Name != null && ( package Name . starts With ( _ STR ) || package Name . starts With ( _ STR ) || package Name . starts With (  MYSQL_ JDBC_ PACKAGE_ ROOT ) ) ; }
Async Connector (  RMISocket Factory factory ,  String host , int port ,  Access Control Context acc ) { this . factory = factory ; this . host = host ; this . port = port ; this . acc = acc ;  Security Manager security =  System . get Security Manager ( ) ; if ( security != null ) { security . check Connect ( host , port ) ; } }
Map .  Entry <  K ,  V > do Remove First Entry ( ) { for ( ; ; ) {  Node <  K ,  V > b = head . node ;  Node <  K ,  V > n = b . next ; if ( n == null ) return null ;  Node <  K ,  V > f = n . next ; if ( n != b . next ) continue ;  Object v = n . value ; if ( v == null ) { n . help Delete ( b , f ) ; continue ; } if ( ! n . cas Value ( v , null ) ) continue ; if ( ! n . append Marker ( f ) || ! b . cas Next ( n , f ) ) find First ( ) ; clear Index To First ( ) ; return new  Abstract Map .  Simple Immutable Entry <  K ,  V > ( n . key , (  V ) v ) ; } }
public  Gridify Runtime Exception (  Throwable cause ) { this ( cause . get Message ( ) , cause ) ; }
protected int normalize ( char [ ] src , int src Start , int src Limit , char [ ] dest , int dest Start , int dest Limit ,  Unicode Set nx ) { int src Len = ( src Limit - src Start ) ; int dest Len = ( dest Limit - dest Start ) ; if ( src Len > dest Len ) { return src Len ; }  System . arraycopy ( src , src Start , dest , dest Start , src Len ) ; return src Len ; }
@  Non Null private  List <  String > map Obsolete Elements (  List <  String > names ) {  List <  String > elements To Remove = new  Array List < > ( names . size ( ) ) ; for (  String name : names ) { if ( name . starts With ( _ STR ) ) continue ; elements To Remove . add ( name ) ; } return elements To Remove ; }
public boolean by Pass Control To Processor ( boolean flag ) { return _ BOOL ; }
public void remove Action (  Update Action action ) { action List . remove ( action ) ; for (  Update Manager Listener listener : listeners ) { listener . action Removed ( action ) ; } }
public static  Transform Matrix2 D rotate ( double alpha ) { final double sin =  Math . sin ( alpha ) ; final double cos =  Math . cos ( alpha ) ; return new  Transform Matrix2 D ( cos , sin , - sin , cos , _ NUM , _ NUM ) ; }
public  Pair <  String ,  String > next ( ) { current Header Position = next Header Position ;  Pair <  String ,  String > result = new  Pair < > ( next Header , next Sequence ) ; next Header = next Next Header ; next Header Position = next Next Header Position ; next Sequence = null ; next Next Header = null ; if ( next Header != null ) {  String a Line ; try { while ( ( a Line = r . read Line ( ) ) != null ) { if ( a Line . starts With ( _ STR ) ) { next Next Header = a Line ; next Next Header Position = position ; position += a Line . length ( ) + end Of Line Bytes ; break ; } else { position += a Line . length ( ) + end Of Line Bytes ; parts . add ( a Line ) ; } } number Of Sequences Read ++ ; } catch (  IOException e ) {  Basic . caught ( e ) ; } next Sequence =  Basic . concatenate And Remove White Spaces ( parts ) ; parts . clear ( ) ; } else try { close ( ) ; } catch (  IOException ex ) {  Basic . caught ( ex ) ; } return result ; }
public void add (  Boolean bool ) { elements . add ( bool == null ?  Json Null .  INSTANCE : new  Json Primitive ( bool ) ) ; }
public void remove Child ( int id ) { child Planets . remove ( id ) ; }
protected  Storage Port check Port Exists In DB (  String native Guid ) {  Storage Port port = null ;  List <  Storage Port > port In DB =  Custom Query Utility . get Active Storage Port By Native Guid ( _db Client , native Guid ) ; if ( port In DB != null && ! port In DB . is Empty ( ) ) { port = port In DB . get ( _ NUM ) ; } return port ; }
public void prepend Split Element (  Fragment a Split ) { splits . add ( _ NUM , a Split ) ; }
@  Inject public  Aggregator Parsers (  Set <  Aggregator .  Parser > agg Parsers ,  Set <  Pipeline Aggregator .  Parser > pipeline Aggregator Parsers ) {  Map Builder <  String ,  Aggregator .  Parser > agg Parsers Builder =  Map Builder . new Map Builder ( ) ; for (  Aggregator .  Parser parser : agg Parsers ) { agg Parsers Builder . put ( parser . type ( ) , parser ) ; } this . agg Parsers = agg Parsers Builder . immutable Map ( ) ;  Map Builder <  String ,  Pipeline Aggregator .  Parser > pipeline Aggregator Parsers Builder =  Map Builder . new Map Builder ( ) ; for (  Pipeline Aggregator .  Parser parser : pipeline Aggregator Parsers ) { pipeline Aggregator Parsers Builder . put ( parser . type ( ) , parser ) ; } this . pipeline Aggregator Parsers = pipeline Aggregator Parsers Builder . immutable Map ( ) ; }
public void close ( ) throws  IOException { super . close ( ) ; out . close ( ) ; }
public  Byte Buffer _read From Cache ( final long offset , final int nbytes ) throws  Checksum Error ,  Interrupted Exception { if ( nbytes > capacity ) { return null ; } final  Long off =  Long . value Of ( offset ) ; while ( _ BOOL ) { if ( ! open . get ( ) ) { return null ; } final  Write Cache cache = service Map . get ( off ) ; if ( cache == null ) { break ; } try { final  Byte Buffer ret = cache . read ( off . long Value ( ) , nbytes ) ; if ( ret == null && service Map . get ( off ) == cache ) { throw new  Illegal State Exception ( _ STR + off ) ; } if ( ret == null && log . is Debug Enabled ( ) ) { log . debug ( _ STR ) ; } if ( ret != null ) return ret ; continue ; } catch (  Illegal State Exception ex ) { assert ! open . get ( ) ; return null ; } } return null ; }
private boolean attempt To Extract Idd ( ) {  Pattern international Prefix = regex Cache . get Pattern For Regex ( _ STR +  Phone Number Util .  PLUS_ SIGN + _ STR + current Metadata . get International Prefix ( ) ) ;  Matcher idd Matcher = international Prefix . matcher ( accrued Input Without Formatting ) ; if ( idd Matcher . looking At ( ) ) { is Complete Number = _ BOOL ; int start Of Country Calling Code = idd Matcher . end ( ) ; national Number . set Length ( _ NUM ) ; national Number . append ( accrued Input Without Formatting . substring ( start Of Country Calling Code ) ) ; prefix Before National Number . set Length ( _ NUM ) ; prefix Before National Number . append ( accrued Input Without Formatting . substring ( _ NUM , start Of Country Calling Code ) ) ; if ( accrued Input Without Formatting . char At ( _ NUM ) !=  Phone Number Util .  PLUS_ SIGN ) { prefix Before National Number . append (  SEPARATOR_ BEFORE_ NATIONAL_ NUMBER ) ; } return _ BOOL ; } return _ BOOL ; }
public static double static Next Double ( double mean , double gamma , double cut ) { synchronized ( shared ) { return shared . next Double ( mean , gamma , cut ) ; } }
public void shutdown Now ( ) throws  Exception { log . debug ( _ STR ) ; parsing . set ( _ BOOL ) ; if ( parser Service != null ) parser Service . shutdown Now ( ) ; if ( indexer Service != null ) indexer Service . shutdown Now ( ) ; if ( indexer Task != null ) { indexer Task . cancel ( _ BOOL ) ; } if ( mmgr != null ) { mmgr . clear ( ) ; } }
public synchronized void release ( ) { if ( event Queue != null ) { event Queue . clear ( ) ; event Queue = null ; } if ( control Queue != null ) { control Queue . clear ( ) ; control Queue = null ; } if ( watch Predicates != null ) { watch Predicates . clear ( ) ; watch Predicates = null ; } }
private static void search From URL (  Set result ,  String prefix ,  String suffix ,  URL url ) throws  IOException { boolean done = _ BOOL ;  Input Stream is = get Input Stream ( url ) ; if ( is != null ) { try (  Zip Input Stream zis = ( is instanceof  Zip Input Stream ) ? (  Zip Input Stream ) is : new  Zip Input Stream ( is ) ) {  Zip Entry entry = zis . get Next Entry ( ) ; done = ( entry != null ) ; while ( entry != null ) {  String entry Name = entry . get Name ( ) ; if ( entry Name . ends With ( suffix ) ) {  String url String = url . to External Form ( ) ; result . add ( new  URL ( url String + entry Name ) ) ; } entry = zis . get Next Entry ( ) ; } } } if ( ! done && prefix . length ( ) > _ NUM ) {  String url String = url . to External Form ( ) + _ STR ;  String [ ] split = prefix . split ( _ STR ) ; prefix = join ( split , _ BOOL ) ;  String end = join ( split , _ BOOL ) ; int p = url String . last Index Of ( end ) ; url String = url String . substring ( _ NUM , p ) ; for (  String cur :  PREFIXES_ TO_ EXCLUDE ) { if ( url String . starts With ( cur ) ) { return ; } } url = new  URL ( url String ) ; search From URL ( result , prefix , suffix , url ) ; } }
public void transform (  Affine Transform transform ) { current Transform . concatenate ( transform ) ; try { write Transform ( transform ) ; } catch (  IOException e ) { handle Exception ( e ) ; } }
public void test Signum Negative ( ) {  String a = _ STR ; int a Scale = _ NUM ;  Big Decimal a Number = new  Big Decimal ( new  Big Integer ( a ) , a Scale ) ; assert Equals ( _ STR , - _ NUM , a Number . signum ( ) ) ; }
public  Painter Chain add Painter (  Painter p ) { if ( chain . length != _ NUM ) {  Painter [ ] new Chain = new  Painter [ chain . length + _ NUM ] ;  System . arraycopy ( chain , _ NUM , new Chain , _ NUM , chain . length ) ; new Chain [ chain . length ] = p ; return new  Painter Chain ( new Chain ) ; } return new  Painter Chain ( new  Painter [ ] { p } ) ; }
private  Layout parse Layout (  Token Stream tokens ) {  Doc .  Group Kind kind =  Doc .  Group Kind .  VERTICAL ;  Doc separator =  Doc .  BREAK ; int nest = _ NUM ; if ( tokens . has ( _ STR ) ) { tokens . next ( ) ; kind =  Doc .  Group Kind .  VERTICAL ; } else if ( tokens . has ( _ STR ) ) { tokens . next ( ) ; kind =  Doc .  Group Kind .  HORIZONTAL ; } else if ( tokens . has ( _ STR ) ) { tokens . next ( ) ; kind =  Doc .  Group Kind .  AUTO ; } else if ( tokens . has ( _ STR ) ) { tokens . next ( ) ; kind =  Doc .  Group Kind .  FILL ; } if ( tokens . has (  INT_ LITERAL ) ) { nest =  Integer . parse Int ( tokens . next ( ) ) ; } if ( tokens . has (  JOIN_ SEPARATOR ) ) { tokens . next ( ) ;  Elem expr = parse Expr ( tokens ) ; if ( expr != null ) { separator = eval Parsing Time ( expr ) ; } } return  Layout . create ( separator , kind , nest ) ; }
@  Override public boolean swipe (  Selector obj ,  String dir , float percent , int steps ) throws  Ui Object Not Found Exception { if ( obj . to Ui Object2 ( ) == null ) { return swipe ( device . find Object ( obj . to Ui Selector ( ) ) , dir , steps ) ; } return swipe ( obj . to Ui Object2 ( ) , dir , percent , steps ) ; }
private void filter Already Synced (  Contact Sync Entry sync Entry ) { final  String selection =  String . format (  Locale .  US , _ STR ,  Database Columns .  NUMBER , sync Entry . get Joined Numbers Csv ( ) ) ; final  Cursor cursor =  DBInterface . query ( _ BOOL ,  Table Uploaded Contacts .  NAME , null , selection , null , null , null , null , null ) ; if ( cursor != null ) { while ( cursor . move To Next ( ) ) { sync Entry . remove Number ( cursor . get String ( cursor . get Column Index (  Database Columns .  NUMBER ) ) ) ; } cursor . close ( ) ; } }
public boolean outer Class Has Annotation (  Annotation annotation ) {  Class < ? > outer = type . get Declaring Class ( ) ; while ( outer != null ) {  Annotation Accessor accessor = new  Annotation Accessor ( supported Annotations , outer , ignore Annotation Failure ) ; if ( accessor . type Has ( annotation ) ) { return _ BOOL ; } outer = outer . get Declaring Class ( ) ; } return _ BOOL ; }
private  Ascii Funcs ( ) { }
public static  String render (  Tree tree ) {  String Builder sb = new  String Builder ( ) ; render Tree ( tree , _ NUM , _ BOOL , _ BOOL , _ BOOL , _ BOOL , sb ) ; sb . append ( _ STR ) ; return sb . to String ( ) ; }
public  Text Editor replace All (  String regex ,  String replacement ) { if ( text . length ( ) > _ NUM ) { final  String r = replacement ;  Pattern p =  Pattern . compile ( regex ,  Pattern .  MULTILINE ) ;  Matcher m = p . matcher ( text ) ;  String Buffer sb = new  String Buffer ( ) ; while ( m . find ( ) ) { m . append Replacement ( sb , r ) ; } m . append Tail ( sb ) ; text = new  String Builder ( sb . to String ( ) ) ; } return this ; }
public boolean matches Ignore Case (  String sa ) { if ( _length != sa . length ( ) ) return _ BOOL ; char [ ] buffer = _buffer ; int offset = _offset ; for ( int i = _length - _ NUM ; i >= _ NUM ; i -- ) { char ca = buffer [ offset + i ] ; char cb = sa . char At ( i ) ; if ( ca != cb &&  Character . to Lower Case ( ca ) !=  Character . to Lower Case ( cb ) ) return _ BOOL ; } return _ BOOL ; }
protected void _write Last Chunk ( byte [ ] buffer , long index ) throws  File Encryption Exception ,  Random Data Generation Exception ,  Invalid Key Exception ,  Invalid Algorithm Parameter Exception ,  Illegal Block Size Exception ,  Bad Padding Exception ,  IOException { byte [ ] iv = generate Random Chunk IV ( ) ;  Iv Parameter Spec spec = new  Iv Parameter Spec ( iv ) ; last Chunk Cipher . init (  Cipher .  ENCRYPT_ MODE , get File Key ( ) , spec ) ; byte [ ] enc Chunk = last Chunk Cipher . do Final ( buffer ) ; if ( ( enc Chunk == null ) || ( enc Chunk . length != ( buffer . length +  CHUNK_ TLEN ) ) ) { throw new  File Encryption Exception ( _ STR ) ; } long oldpos = backing Random Access File . get File Pointer ( ) ; backing Random Access File . seek ( chunk Offset ( index ) ) ; backing Random Access File . write ( iv ) ; backing Random Access File . write ( enc Chunk ) ; backing Random Access File . seek ( oldpos ) ; }
public static <  T >  T min (  Collection < ? extends  T > collection ,  Comparator < ? super  T > comparator ) { if ( comparator == null ) { @  Suppress Warnings ( _ STR )  T result = (  T ) min ( (  Collection < java . lang .  Comparable > ) collection ) ; return result ; }  Iterator < ? extends  T > it = collection . iterator ( ) ;  T min = it . next ( ) ; while ( it . has Next ( ) ) {  T next = it . next ( ) ; if ( comparator . compare ( min , next ) > _ NUM ) { min = next ; } } return min ; }
@  Override public void run ( int conn Id ,  String [ ] args ) { if ( ! can Run Restricted Command ( conn Id ) ) { server . send Server Chat ( conn Id , _ STR ) ; return ; } if ( args . length > _ NUM ) {  String s Final File = args [ _ NUM ] ; if ( ! s Final File . ends With ( _ STR ) && ! s Final File . ends With ( _ STR ) ) { s Final File = s Final File + _ STR ; } if ( ! s Final File . ends With ( _ STR ) ) { s Final File = s Final File + _ STR ; } load ( new  File ( _ STR , s Final File ) , conn Id ) ; } else { server . send Server Chat ( conn Id , _ STR ) ; } }
public  String parse DTDMarkup ( ) throws  IOException {  String Builder str Buff = new  String Builder ( ) ; ch = read Ch ( ) ; while ( _ BOOL ) { switch ( ch ) { case _ STR : ch = read Ch ( ) ; return str Buff . to String ( ) ; case - _ NUM : error ( _ STR ) ; return str Buff . to String ( ) ; case _ STR : ln ++ ; ch = read Ch ( ) ; lf Count ++ ; break ; case _ STR : ch = read Ch ( ) ; break ; case _ STR : ln ++ ; if ( ( ch = read Ch ( ) ) == _ STR ) { ch = read Ch ( ) ; crlf Count ++ ; } else { cr Count ++ ; } break ; default : str Buff . append ( ( char ) ( ch & _ NUM ) ) ; ch = read Ch ( ) ; break ; } } }
public static  String real Format Array ( final double [ ] x ) { final  String Builder sb = new  String Builder ( ) ; sb . append ( _ STR ) ; for ( int i = _ NUM ; i < x . length ; i ++ ) { if ( i > _ NUM ) { sb . append ( _ STR ) ; } sb . append ( real Format ( x [ i ] ) ) ; } sb . append ( _ STR ) ; return sb . to String ( ) ; }
public static  Generalized Sem Pm serializable Instance ( ) {  Dag dag = new  Dag ( ) ;  Graph Node node1 = new  Graph Node ( _ STR ) ; dag . add Node ( node1 ) ; return new  Generalized Sem Pm (  Dag . serializable Instance ( ) ) ; }
public boolean recreate Workspace Table (  SQLite Database db ) { db . begin Transaction ( ) ; try {  Cursor c = db . query (  TABLE_ WORKSPACE_ SCREENS , new  String [ ] {  Launcher Settings .  Workspace Screens . _ ID } , null , null , null , null ,  Launcher Settings .  Workspace Screens .  SCREEN_ RANK ) ;  Array List <  Long > sorted IDs = new  Array List <  Long > ( ) ; long max Id = _ NUM ; try { while ( c . move To Next ( ) ) {  Long id = c . get Long ( _ NUM ) ; if ( ! sorted IDs . contains ( id ) ) { sorted IDs . add ( id ) ; max Id =  Math . max ( max Id , id ) ; } } } finally { c . close ( ) ; } db . exec SQL ( _ STR +  TABLE_ WORKSPACE_ SCREENS ) ; add Workspaces Table ( db , _ BOOL ) ; int total = sorted IDs . size ( ) ; for ( int i = _ NUM ; i < total ; i ++ ) {  Content Values values = new  Content Values ( ) ; values . put (  Launcher Settings .  Workspace Screens . _ ID , sorted IDs . get ( i ) ) ; values . put (  Launcher Settings .  Workspace Screens .  SCREEN_ RANK , i ) ; add Modified Time ( values ) ; db . insert Or Throw (  TABLE_ WORKSPACE_ SCREENS , null , values ) ; } db . set Transaction Successful ( ) ; m Max Screen Id = max Id ; } catch (  SQLException ex ) {  Log . e (  TAG , ex . get Message ( ) , ex ) ; return _ BOOL ; } finally { db . end Transaction ( ) ; } return _ BOOL ; }
private  Segment create Mapped Segment (  Segment Descriptor descriptor ) {  File segment File =  Segment File . create Segment File ( name , storage . directory ( ) , descriptor . id ( ) , descriptor . version ( ) ) ;  Buffer buffer =  Mapped Buffer . allocate ( segment File ,  Math . min (  DEFAULT_ BUFFER_ SIZE , descriptor . max Segment Size ( ) ) ,  Integer .  MAX_ VALUE ) ; descriptor . copy To ( buffer ) ;  Segment segment = new  Segment ( new  Segment File ( segment File ) , buffer . slice ( ) , descriptor , create Index ( descriptor ) , new  Offset Predicate ( ) , serializer . clone ( ) , this ) ;  LOGGER . debug ( _ STR , segment ) ; return segment ; }
public static boolean validate Email List (  String value ) {  String [ ] emails = value . split ( _ STR ) ; for (  String email : emails ) { if ( validate Email ( email . trim ( ) ) == _ BOOL ) { return _ BOOL ; } } return _ BOOL ; }
public synchronized boolean retain All (  Collection c ) {  Object [ ] elements = get Array ( ) ; int len = elements . length ; if ( len != _ NUM ) { int newlen = _ NUM ;  Object [ ] temp = new  Object [ len ] ; for ( int i = _ NUM ; i < len ; ++ i ) {  Object element = elements [ i ] ; if ( c . contains ( element ) ) temp [ newlen ++ ] = element ; } if ( newlen != len ) { set Array ( copy Of Range ( temp , _ NUM , newlen ,  Object [ ] . class ) ) ; return _ BOOL ; } } return _ BOOL ; }
private double max Ignore Na N ( double a , double b ) { if (  Double . is Na N ( a ) ) { return b ; } if (  Double . is Na N ( b ) ) { return a ; } return  Math . max ( a , b ) ; }
public void modify Leaf Block (  Block Id blk ) { lock Tbl . x Lock ( blk , tx Num ) ; writen Index Blks . add ( blk ) ; }
public void remove Connection (  Connection connection ) { if ( connection == null ) throw new  Illegal Argument Exception ( _ STR ) ; connection . remove Listener ( invoke Listener ) ; synchronized ( connections Lock ) {  Array List <  Connection > temp = new  Array List (  Arrays . as List ( connections ) ) ; temp . remove ( connection ) ; connections = temp . to Array ( new  Connection [ temp . size ( ) ] ) ; } if (  TRACE ) trace ( _ STR , _ STR + connection ) ; }
public boolean matches Whitespace ( ) { return ! is Empty ( ) &&  Character . is Whitespace ( queue . char At ( pos ) ) ; }
public void test_encode_decode_random Bits_stress ( ) { final  Random r = new  Random ( ) ; for ( int i = _ NUM ; i < _ NUM ; i ++ ) { final int nbits = r . next Int ( _ NUM ) ; final int pid = r . next Int ( ) ; final int ctr = r . next Int ( ) ; if ( pid == _ NUM && ctr == _ NUM ) { continue ; } final  Term Id Encoder encoder = new  Term Id Encoder ( nbits ) ; do Encode Decode Test ( encoder , pid , ctr ) ; } }
public void generate (  Batch Environment env ,  Class Doc input Class ,  File dest Dir ) {  Remote Class remote Class =  Remote Class . for Class ( env , input Class ) ; if ( remote Class == null ) { return ; }  Stub Skeleton Writer writer = new  Stub Skeleton Writer ( env , remote Class , version ) ;  File stub File = source File For Class ( writer . stub Class Name ( ) , dest Dir ) ; try {  Indenting Writer out = new  Indenting Writer ( new  Output Stream Writer ( new  File Output Stream ( stub File ) ) ) ; writer . write Stub ( out ) ; out . close ( ) ; if ( env . verbose ( ) ) { env . output (  Resources . get Text ( _ STR , stub File . get Path ( ) ) ) ; } env . add Generated File ( stub File ) ; } catch (  IOException e ) { env . error ( _ STR , stub File . to String ( ) ) ; return ; }  File skeleton File = source File For Class ( writer . skeleton Class Name ( ) , dest Dir ) ; if ( version ==  Stub Version .  V1_1 || version ==  Stub Version .  VCOMPAT ) { try {  Indenting Writer out = new  Indenting Writer ( new  Output Stream Writer ( new  File Output Stream ( skeleton File ) ) ) ; writer . write Skeleton ( out ) ; out . close ( ) ; if ( env . verbose ( ) ) { env . output (  Resources . get Text ( _ STR , skeleton File . get Path ( ) ) ) ; } env . add Generated File ( skeleton File ) ; } catch (  IOException e ) { env . error ( _ STR , skeleton File . to String ( ) ) ; return ; } } else {  File skeleton Class File = class File For Class ( writer . skeleton Class Name ( ) , dest Dir ) ; skeleton File . delete ( ) ; skeleton Class File . delete ( ) ; } }
public static  Data In Memory load Delay Quality (  File directory ,  Index File index ,  Data File Index seq Index , long start , long end ) throws  IOException { final  Pointer Loader point = new  Pointer Loader ( directory , index , seq Index , start , end ) ; final  Sequence Loader seq ; final  Quality Loader qual ; if ( start < end ) { point . load Pointers ( ) ; seq = new  Sequence Loader ( point ) ; qual = new  Quality Loader ( point ) ; seq . load Sequence Data ( ) ; } else { seq = new  Sequence Loader ( point ) ; qual = new  Quality Loader ( point ) ; } return new  Data In Memory ( point . m Pointers , point . m Sequence Checksums , point . m Quality Checksums , seq . m Sequence Data , qual ) ; }
private byte [ ] add Exif ( byte [ ] jpeg ) {  Exif Interface exif = new  Exif Interface ( ) ; exif . add Date Time Stamp Tag (  Exif Interface .  TAG_ DATE_ TIME ,  System . current Time Millis ( ) ,  Time Zone . get Default ( ) ) ;  Byte Array Output Stream jpeg Out = new  Byte Array Output Stream ( ) ; try { exif . write Exif ( jpeg , jpeg Out ) ; } catch (  IOException e ) {  Log . e (  TAG , _ STR , e ) ; } return jpeg Out . to Byte Array ( ) ; }
public static int bytes To Int ( final byte [ ] bytes ) { final  Byte Buffer buffer =  Byte Buffer . allocate ( _ NUM ) ; buffer . put ( bytes , _ NUM , _ NUM ) ; buffer . flip ( ) ; return buffer . get Int ( ) ; }
@  Override public void mouse Exited (  Mouse Event evt ) { delegate . mouse Moved ( evt ) ; }
public static  String remove Formatting (  String line ) { int length = line . length ( ) ;  String Buffer buffer = new  String Buffer ( ) ; for ( int i = _ NUM ; i < length ; i ++ ) { char ch = line . char At ( i ) ; if ( ch == _ STR || ch == _ STR || ch == _ STR || ch == _ STR ) { } else { buffer . append ( ch ) ; } } return buffer . to String ( ) ; }
public void write To (  Print Writer out , boolean write Weights ) { out . println ( _ STR ) ; for ( int i = _ NUM ; i < num Byte Features ; i ++ ) { if ( write Weights ) { out . print ( feature Weights [ i ] + _ STR ) ; } out . print ( get Feature Name ( i ) ) ; for ( int v = _ NUM , vmax = get Number Of Values ( i ) ; v < vmax ; v ++ ) { out . print ( _ STR ) ;  String val = get Feature Value As String ( i , v ) ; out . print ( val ) ; } out . println ( ) ; } out . println ( _ STR ) ; for ( int i = _ NUM ; i < num Short Features ; i ++ ) { if ( write Weights ) { out . print ( feature Weights [ num Byte Features + i ] + _ STR ) ; } out . print ( get Feature Name ( num Byte Features + i ) ) ; for ( int v = _ NUM , vmax = get Number Of Values ( num Byte Features + i ) ; v < vmax ; v ++ ) { out . print ( _ STR ) ;  String val = get Feature Value As String ( num Byte Features + i , v ) ; out . print ( val ) ; } out . println ( ) ; } out . println ( _ STR ) ; for ( int i = _ NUM ; i < num Continuous Features ; i ++ ) { if ( write Weights ) { out . print ( feature Weights [ num Byte Features + num Short Features + i ] ) ; out . print ( _ STR ) ; out . print ( float Weight Functs [ i ] ) ; out . print ( _ STR ) ; } out . print ( get Feature Name ( num Byte Features + num Short Features + i ) ) ; out . println ( ) ; } }
public boolean has Update Listeners ( ) { boolean is Empty = ! listeners . is Empty ( ) ; return is Empty ; }
private void save Memory Block Serialized (  Image Data image Data ,  File file Serialize ) throws  Exception {  File Output Stream fos = null ;  Object Output Stream oos = null ; try { fos = new  File Output Stream ( file Serialize ) ; oos = new  Object Output Stream ( fos ) ; oos . write Object ( image Data ) ; add Scan File ( file Serialize ) ; } catch (  Exception e ) { throw e ; } finally { if ( oos != null ) { oos . close ( ) ; } if ( fos != null ) { fos . close ( ) ; } } }
public  Service Config create Global Config (  Map attrs ) throws  SMSException ,  SSOException { validate SSM ( ) ;  Service Schema Impl ss = ssm . get Schema (  Schema Type .  GLOBAL ) ; if ( ss == null ) {  String [ ] args = { service Name } ; throw ( new  SMSException (  IUMSConstants .  UMS_ BUNDLE_ NAME , _ STR , args ) ) ; }  String org DN = scm . construct Service Config DN (  SMSUtils .  DEFAULT ,  Create Service Config .  GLOBAL_ CONFIG_ NODE , null ) ; try {  Create Service Config . create Sub Config Entry ( token , org DN , ss , null , null , attrs ,  SMSEntry . base DN ) ; } catch (  Service Already Exists Exception slee ) { } return ( get Global Config ( null ) ) ; }
public void assign Service (  String realm ) throws  AMConsole Exception {  String [ ] params = { realm ,  AMAdmin Constants .  DISCOVERY_ SERVICE } ; try {  AMIdentity Repository repo = new  AMIdentity Repository ( get User SSOToken ( ) , realm ) ;  AMIdentity realm Identity = repo . get Realm Identity ( ) ;  Set services From Id Repo = realm Identity . get Assignable Services ( ) ; if ( services From Id Repo . contains (  AMAdmin Constants .  DISCOVERY_ SERVICE ) ) { realm Identity . assign Service (  AMAdmin Constants .  DISCOVERY_ SERVICE ,  Collections .  EMPTY_ MAP ) ; } else {  Organization Config Manager org Cfg Mgr = new  Organization Config Manager ( get User SSOToken ( ) , realm ) ; org Cfg Mgr . assign Service (  AMAdmin Constants .  DISCOVERY_ SERVICE ,  Collections .  EMPTY_ MAP ) ; } } catch (  SSOException e ) {  String str Error = get Error String ( e ) ;  String [ ] params Ex = { realm ,  AMAdmin Constants .  DISCOVERY_ SERVICE , str Error } ; log Event ( _ STR , params Ex ) ; throw new  AMConsole Exception ( str Error ) ; } catch (  Id Repo Exception e ) {  String str Error = get Error String ( e ) ;  String [ ] params Ex = { realm ,  AMAdmin Constants .  DISCOVERY_ SERVICE , str Error } ; log Event ( _ STR , params Ex ) ; throw new  AMConsole Exception ( str Error ) ; } catch (  SMSException e ) {  String str Error = get Error String ( e ) ;  String [ ] params Ex = { realm ,  AMAdmin Constants .  DISCOVERY_ SERVICE , str Error } ; log Event ( _ STR , params Ex ) ; throw new  AMConsole Exception ( str Error ) ; } }
protected void add Source Code Remark On Attribute (  Test Solution test Solution ,  Element element ,  String message Code ,  String attribute Name ) { if ( attribute Name != null ) {  Collection <  Evidence Element > evidence Element List = new  Array List < > ( ) ;  Evidence Element ee = get Evidence Element (  Evidence Store .  TARGETTED_ ELEMENT_ FROM_ SCOPE_ EE , attribute Name ) ; evidence Element List . add ( ee ) ; process Remark Service . add Source Code Remark On Element ( test Solution , element , message Code , evidence Element List ) ; } }
void add Deleted ( long position ,  List <  Integer > integer List , boolean is Single ) { if ( integer List . size ( ) > _ NUM || ! is Single ) {  Binary Content .  Range range = new Range From Integer List ( position , integer List ) ;  List <  Range > one Element List = new  Array List < > ( ) ; one Element List . add ( range ) ; add Lost Ranges ( one Element List ) ; } else { add Lost Byte ( position , integer List . get ( _ NUM ) ) ; } previous Time =  System . current Time Millis ( ) ; }
default  Optional <  Document Entity > single Result (  Document Query query ) throws  Non Unique Result Exception {  List <  Document Entity > entities = find ( query ) ; if ( entities . is Empty ( ) ) { return  Optional . empty ( ) ; } if ( entities . size ( ) == _ NUM ) { return  Optional . of ( entities . get ( _ NUM ) ) ; } throw new  Non Unique Result Exception ( _ STR + query ) ; }
private  Environment Logger build Parent Tree (  String child Name ) { if ( child Name == null || child Name . equals ( _ STR ) ) return null ; int p = child Name . last Index Of ( _ STR ) ;  String parent Name ; if ( p > _ NUM ) parent Name = child Name . substring ( _ NUM , p ) ; else parent Name = _ STR ;  Environment Logger parent = null ;  Soft Reference <  Environment Logger > parent Ref = _env Loggers . get ( parent Name ) ; if ( parent Ref != null ) parent = parent Ref . get ( ) ; if ( parent != null ) return parent ; else { parent = new  Environment Logger ( parent Name , null ) ; _env Loggers . put ( parent Name , new  Soft Reference <  Environment Logger > ( parent ) ) ;  Environment Logger grandparent = build Parent Tree ( parent Name ) ; if ( grandparent != null ) parent . set Parent ( grandparent ) ; return parent ; } }
protected void convert From (  Blackboard bb ,  Sql Node from ) { if ( from == null ) { bb . set Root (  Logical Values . create One Row ( cluster ) , _ BOOL ) ; return ; } final  Sql Call call ; final  Sql Node [ ] operands ; switch ( from . get Kind ( ) ) { case  AS : convert From ( bb , ( (  Sql Call ) from ) . operand ( _ NUM ) ) ; return ; case  WITH_ ITEM : convert From ( bb , ( (  Sql With Item ) from ) . query ) ; return ; case  WITH : convert From ( bb , ( (  Sql With ) from ) . body ) ; return ; case  TABLESAMPLE : operands = ( (  Sql Basic Call ) from ) . get Operands ( ) ;  Sql Sample Spec sample Spec =  Sql Literal . sample Value ( operands [ _ NUM ] ) ; if ( sample Spec instanceof  Sql Sample Spec .  Sql Substitution Sample Spec ) {  String sample Name = ( (  Sql Sample Spec .  Sql Substitution Sample Spec ) sample Spec ) . get Name ( ) ; dataset Stack . push ( sample Name ) ; convert From ( bb , operands [ _ NUM ] ) ; dataset Stack . pop ( ) ; } else if ( sample Spec instanceof  Sql Sample Spec .  Sql Table Sample Spec ) {  Sql Sample Spec .  Sql Table Sample Spec table Sample Spec = (  Sql Sample Spec .  Sql Table Sample Spec ) sample Spec ; convert From ( bb , operands [ _ NUM ] ) ;  Rel Opt Sampling Parameters params = new  Rel Opt Sampling Parameters ( table Sample Spec . is Bernoulli ( ) , table Sample Spec . get Sample Percentage ( ) , table Sample Spec . is Repeatable ( ) , table Sample Spec . get Repeatable Seed ( ) ) ; bb . set Root ( new  Sample ( cluster , bb . root , params ) , _ BOOL ) ; } else { throw  Util . new Internal ( _ STR + sample Spec ) ; } return ; case  IDENTIFIER : final  Sql Validator Namespace from Namespace = validator . get Namespace ( from ) . resolve ( ) ; if ( from Namespace . get Node ( ) != null ) { convert From ( bb , from Namespace . get Node ( ) ) ; return ; } final  String dataset Name = dataset Stack . is Empty ( ) ? null : dataset Stack . peek ( ) ; boolean [ ] used Dataset = { _ BOOL } ;  Rel Opt Table table =  Sql Validator Util . get Rel Opt Table ( from Namespace , catalog Reader , dataset Name , used Dataset ) ; final  Rel Node table Rel ; if ( should Convert Table Access ) { table Rel = to Rel ( table ) ; } else { table Rel =  Logical Table Scan . create ( cluster , table ) ; } bb . set Root ( table Rel , _ BOOL ) ; if ( used Dataset [ _ NUM ] ) { bb . set Dataset ( dataset Name ) ; } return ; case  JOIN : final  Sql Join join = (  Sql Join ) from ; final  Sql Validator Scope scope = validator . get Join Scope ( from ) ; final  Blackboard from Blackboard = create Blackboard ( scope , null , _ BOOL ) ;  Sql Node left = join . get Left ( ) ;  Sql Node right = join . get Right ( ) ; final boolean is Natural = join . is Natural ( ) ; final  Join Type join Type = join . get Join Type ( ) ; final  Sql Validator Scope left Scope =  Util . first ( validator . get Join Scope ( left ) , ( (  Delegating Scope ) bb . scope ) . get Parent ( ) ) ; final  Blackboard left Blackboard = create Blackboard ( left Scope , null , _ BOOL ) ; final  Sql Validator Scope right Scope =  Util . first ( validator . get Join Scope ( right ) , ( (  Delegating Scope ) bb . scope ) . get Parent ( ) ) ; final  Blackboard right Blackboard = create Blackboard ( right Scope , null , _ BOOL ) ; convert From ( left Blackboard , left ) ;  Rel Node left Rel = left Blackboard . root ; convert From ( right Blackboard , right ) ;  Rel Node right Rel = right Blackboard . root ;  Join Rel Type converted Join Type = convert Join Type ( join Type ) ;  Rex Node condition Exp ; final  Sql Validator Namespace left Namespace = validator . get Namespace ( left ) ; final  Sql Validator Namespace right Namespace = validator . get Namespace ( right ) ; if ( is Natural ) { final  Rel Data Type left Row Type = left Namespace . get Row Type ( ) ; final  Rel Data Type right Row Type = right Namespace . get Row Type ( ) ; final  List <  String > column List =  Sql Validator Util . derive Natural Join Column List ( left Row Type , right Row Type ) ; condition Exp = convert Using ( left Namespace , right Namespace , column List ) ; } else { condition Exp = convert Join Condition ( from Blackboard , left Namespace , right Namespace , join . get Condition ( ) , join . get Condition Type ( ) , left Rel , right Rel ) ; } final  Rel Node join Rel = create Join ( from Blackboard , left Rel , right Rel , condition Exp , converted Join Type ) ; bb . set Root ( join Rel , _ BOOL ) ; return ; case  SELECT : case  INTERSECT : case  EXCEPT : case  UNION : final  Rel Node rel = convert Query Recursive ( from , _ BOOL , null ) . project ( ) ; bb . set Root ( rel , _ BOOL ) ; return ; case  VALUES : convert Values Impl ( bb , (  Sql Call ) from , null ) ; return ; case  UNNEST : call = (  Sql Call ) from ; final  List <  Sql Node > nodes = call . get Operand List ( ) ; final  Sql Unnest Operator operator = (  Sql Unnest Operator ) call . get Operator ( ) ; for (  Sql Node node : nodes ) { replace Subqueries ( bb , node ,  Rel Opt Util .  Logic .  TRUE_ FALSE_ UNKNOWN ) ; } final  List <  Rex Node > exprs = new  Array List < > ( ) ; final  List <  String > field Names = new  Array List < > ( ) ; for (  Ord <  Sql Node > node :  Ord . zip ( nodes ) ) { exprs . add ( bb . convert Expression ( node . e ) ) ; field Names . add ( validator . derive Alias ( node . e , node . i ) ) ; } final  Rel Node input =  Rel Opt Util . create Project ( ( null != bb . root ) ? bb . root :  Logical Values . create One Row ( cluster ) , exprs , field Names , _ BOOL ) ;  Uncollect uncollect = new  Uncollect ( cluster , cluster . trait Set Of (  Convention .  NONE ) , input , operator . with Ordinality ) ; bb . set Root ( uncollect , _ BOOL ) ; return ; case  COLLECTION_ TABLE : call = (  Sql Call ) from ; assert call . get Operand List ( ) . size ( ) == _ NUM ; final  Sql Call call2 = call . operand ( _ NUM ) ; convert Collection Table ( bb , call2 ) ; return ; default : throw  Util . new Internal ( _ STR + from ) ; } }
public static  String rate2speed ( double rate ) { return  NUMBER_ FORMAT0 . format ( rate ) + _ STR +  GENERAL_ UNIT_ KBPSEC ; }
public void start ( ) throws  IOException { this . is Running = _ BOOL ;  Thread thread = new  Thread ( this ) ; thread . set Daemon ( _ BOOL ) ; thread . set Name ( _ STR ) ; thread . set Priority (  Thread .  MAX_ PRIORITY ) ; thread . start ( ) ; }
static byte [ ] append Data ( byte [ ] binary_data , final byte [ ] decoded_stream_data ) { if ( decoded_stream_data != null ) { final int current_length = binary_data . length + _ NUM ; int processed_length = decoded_stream_data . length ; if ( processed_length > _ NUM ) { while ( decoded_stream_data [ processed_length - _ NUM ] == _ NUM ) { processed_length -- ; } final byte [ ] temp = new byte [ current_length ] ;  System . arraycopy ( binary_data , _ NUM , temp , _ NUM , current_length - _ NUM ) ; temp [ current_length - _ NUM ] = _ STR ; binary_data = new byte [ current_length + processed_length ] ;  System . arraycopy ( temp , _ NUM , binary_data , _ NUM , current_length ) ;  System . arraycopy ( decoded_stream_data , _ NUM , binary_data , current_length , processed_length ) ; } } return binary_data ; }
private static native  Class < ? > for Name0 (  String name , boolean initialize ,  Class Loader loader ,  Class < ? > caller ) throws  Class Not Found Exception ;
protected static  String serialize DOMSource (  DOMSource dom Source ) { try {  String Writer writer = new  String Writer ( ) ;  Stream Result result = new  Stream Result ( writer ) ;  Transformer Factory tf =  Transformer Factory . new Instance ( ) ;  Transformer transformer = tf . new Transformer ( ) ; transformer . set Output Property (  Output Keys .  ENCODING ,  DEFAULT_ ENCODING ) ; transformer . set Output Property (  Output Keys .  INDENT ,  DEFAULT_ INDENT ) ; transformer . transform ( dom Source , result ) ; writer . flush ( ) ; return writer . to String ( ) ; } catch (  Throwable e ) { log . log (  Level .  SEVERE , _ STR , e ) ; } return null ; }
public  List <  Server Address > addresses ( ) { return addresses ; }
private static  String correct Reserved Word (  String str ) { char first = str . char At ( _ NUM ) ; switch ( first ) { case _ STR : if ( str . equals ( _ STR ) ) return _ STR + str ; break ; case _ STR : if ( str . equals ( _ STR ) ) return _ STR + str ; else if ( str . equals ( _ STR ) ) return _ STR + str ; else if ( str . equals ( _ STR ) ) return _ STR + str ; break ; case _ STR : if ( str . equals ( _ STR ) ) return _ STR + str ; else if ( str . equals ( _ STR ) ) return _ STR + str ; else if ( str . equals ( _ STR ) ) return _ STR + str ; else if ( str . equals ( _ STR ) ) return _ STR + str ; else if ( str . equals ( _ STR ) ) return _ STR + str ; else if ( str . equals ( _ STR ) ) return _ STR + str ; break ; case _ STR : if ( str . equals ( _ STR ) ) return _ STR + str ; else if ( str . equals ( _ STR ) ) return _ STR + str ; else if ( str . equals ( _ STR ) ) return _ STR + str ; break ; case _ STR : if ( str . equals ( _ STR ) ) return _ STR + str ; else if ( str . equals ( _ STR ) ) return _ STR + str ; else if ( str . equals ( _ STR ) ) return _ STR + str ; break ; case _ STR : if ( str . equals ( _ STR ) ) return _ STR + str ; else if ( str . equals ( _ STR ) ) return _ STR + str ; else if ( str . equals ( _ STR ) ) return _ STR + str ; else if ( str . equals ( _ STR ) ) return _ STR + str ; else if ( str . equals ( _ STR ) ) return _ STR + str ; break ; case _ STR : if ( str . equals ( _ STR ) ) return _ STR + str ; break ; case _ STR : if ( str . equals ( _ STR ) ) return _ STR + str ; else if ( str . equals ( _ STR ) ) return _ STR + str ; else if ( str . equals ( _ STR ) ) return _ STR + str ; else if ( str . equals ( _ STR ) ) return _ STR + str ; else if ( str . equals ( _ STR ) ) return _ STR + str ; else if ( str . equals ( _ STR ) ) return _ STR + str ; break ; case _ STR : if ( str . equals ( _ STR ) ) return _ STR + str ; else if ( str . equals ( _ STR ) ) return _ STR + str ; else if ( str . equals ( _ STR ) ) return _ STR + str ; break ; case _ STR : if ( str . equals ( _ STR ) ) return _ STR + str ; else if ( str . equals ( _ STR ) ) return _ STR + str ; else if ( str . equals ( _ STR ) ) return _ STR + str ; else if ( str . equals ( _ STR ) ) return _ STR + str ; break ; case _ STR : if ( str . equals ( _ STR ) ) return _ STR + str ; break ; case _ STR : if ( str . equals ( _ STR ) ) return _ STR + str ; else if ( str . equals ( _ STR ) ) return _ STR + str ; else if ( str . equals ( _ STR ) ) return _ STR + str ; else if ( str . equals ( _ STR ) ) return _ STR + str ; else if ( str . equals ( _ STR ) ) return _ STR + str ; else if ( str . equals ( _ STR ) ) return _ STR + str ; break ; case _ STR : if ( str . equals ( _ STR ) ) return _ STR + str ; else if ( str . equals ( _ STR ) ) return _ STR + str ; else if ( str . equals ( _ STR ) ) return _ STR + str ; else if ( str . equals ( _ STR ) ) return _ STR + str ; else if ( str . equals ( _ STR ) ) return _ STR + str ; else if ( str . equals ( _ STR ) ) return _ STR + str ; break ; case _ STR : if ( str . equals ( _ STR ) ) return _ STR + str ; else if ( str . equals ( _ STR ) ) return _ STR + str ; break ; case _ STR : if ( str . equals ( _ STR ) ) return _ STR + str ; break ; } return str ; }
public static byte [ ] instrument ( byte [ ] original Bytes ,  String recorder Class ,  String recorder Method ,  Class Loader loader ) { try {  Class Reader cr = new  Class Reader ( original Bytes ) ;  Class Writer cw = new  Static Class Writer ( cr ,  Class Writer .  COMPUTE_ FRAMES , loader ) ;  Verifying Class Adapter vcw = new  Verifying Class Adapter ( cw , original Bytes , cr . get Class Name ( ) ) ;  Class Visitor adapter = new  Allocation Class Adapter ( vcw , recorder Class , recorder Method ) ; cr . accept ( adapter ,  Class Reader .  SKIP_ FRAMES ) ; return vcw . to Byte Array ( ) ; } catch (  Runtime Exception e ) { logger . log (  Level .  WARNING , _ STR , e ) ; throw e ; } catch (  Error e ) { logger . log (  Level .  WARNING , _ STR , e ) ; throw e ; } }
public static  Map <  String ,  String > simple Command Line Parser (  String [ ] args ) {  Map <  String ,  String > map = new  Hash Map <  String ,  String > ( ) ; for ( int i = _ NUM ; i <= args . length ; i ++ ) {  String key = ( i > _ NUM ? args [ i - _ NUM ] : null ) ;  String value = ( i < args . length ? args [ i ] : null ) ; if ( key == null || key . starts With ( _ STR ) ) { if ( value != null && value . starts With ( _ STR ) ) value = null ; if ( key != null || value != null ) map . put ( key , value ) ; } } return map ; }
public static void main (  String [ ] args ) { main ( suite ( ) , args ) ; }
@  Override public boolean has Feature (  String feature ,  String version ) { boolean result = super . has Feature ( feature , version ) ; if ( ! result ) { boolean any Version = version == null || version . length ( ) == _ NUM ; if ( feature . starts With ( _ STR ) ) { feature = feature . substring ( _ NUM ) ; } return ( ( feature . equals Ignore Case ( _ STR ) && ( any Version || version . equals ( _ STR ) ) ) || ( feature . equals Ignore Case ( _ STR ) && ( any Version || version . equals ( _ STR ) ) ) || ( feature . equals Ignore Case ( _ STR ) && ( any Version || version . equals ( _ STR ) ) ) || ( feature . equals Ignore Case ( _ STR ) && ( any Version || version . equals ( _ STR ) ) ) || ( feature . equals Ignore Case ( _ STR ) && ( any Version || version . equals ( _ STR ) ) ) ) ; } return result ; }
public  T init (  Callable <  T > c ) throws  Ignite Checked Exception { if ( ! finished ) { synchronized ( mux ) { if ( ! finished ) { try { res = c . call ( ) ; } catch (  Exception e ) { this . e = e ; } finally { finished = _ BOOL ; mux . notify All ( ) ; } } } } if ( e != null ) throw e instanceof  Ignite Checked Exception ? (  Ignite Checked Exception ) e : new  Ignite Checked Exception ( e ) ; return res ; }
public static  Buffered Image create Image (  Image Producer producer ) {  Pixel Grabber pg = new  Pixel Grabber ( producer , _ NUM , _ NUM , - _ NUM , - _ NUM , null , _ NUM , _ NUM ) ; try { pg . grab Pixels ( ) ; } catch (  Interrupted Exception e ) { throw new  Runtime Exception ( _ STR ) ; } if ( ( pg . status ( ) &  Image Observer .  ABORT ) != _ NUM ) throw new  Runtime Exception ( _ STR ) ; if ( ( pg . status ( ) &  Image Observer .  ERROR ) != _ NUM ) throw new  Runtime Exception ( _ STR ) ;  Buffered Image p = new  Buffered Image ( pg . get Width ( ) , pg . get Height ( ) ,  Buffered Image .  TYPE_ INT_ ARGB ) ; p . set RGB ( _ NUM , _ NUM , pg . get Width ( ) , pg . get Height ( ) , ( int [ ] ) pg . get Pixels ( ) , _ NUM , pg . get Width ( ) ) ; return p ; }
private static short  Call Nonvirtual Short Method V (  JNIEnvironment env , int obj JREF , int class JREF , int method ID ,  Address arg Address ) throws  Exception { if ( trace JNI )  VM . sys Write ( _ STR ) ;  Runtime Entrypoints . check JNICount Down To GC ( ) ; try {  Object obj = env . get JNIRef ( obj JREF ) ;  Object return Obj =  JNIHelpers . invoke With Var Arg ( obj , method ID , arg Address ,  Type Reference .  Short , _ BOOL ) ; return  Reflection . unwrap Short ( return Obj ) ; } catch (  Throwable unexpected ) { if ( trace JNI ) unexpected . print Stack Trace (  System . err ) ; env . record Exception ( unexpected ) ; return _ NUM ; } }
public static void draw Horizontal Margin Indicator (  Graphics2 D g ,  String text , int x1 , int x2 , int y ) { if ( x1 > x2 ) { int temp = x1 ; x1 = x2 ; x2 = temp ; } if ( text == null ) { g . draw Line ( x1 , y , x2 , y ) ; g . draw Line ( x1 , y , x1 +  CONNECTION_ ARROW_ SIZE , y -  CONNECTION_ ARROW_ SIZE ) ; g . draw Line ( x1 , y , x1 +  CONNECTION_ ARROW_ SIZE , y +  CONNECTION_ ARROW_ SIZE ) ; g . draw Line ( x2 , y , x2 -  CONNECTION_ ARROW_ SIZE , y -  CONNECTION_ ARROW_ SIZE ) ; g . draw Line ( x2 , y , x2 -  CONNECTION_ ARROW_ SIZE , y +  CONNECTION_ ARROW_ SIZE ) ; return ; }  Canvas c = new  Canvas ( ) ;  Font Metrics fm = c . get Font Metrics ( s Font ) ; g . set Font ( s Font ) ; int padding = _ NUM ;  Rectangle2 D bounds = fm . get String Bounds ( text , g ) ; int th = ( int ) bounds . get Height ( ) ; int tw = ( int ) bounds . get Width ( ) ; int offset = _ NUM *  CONNECTION_ ARROW_ SIZE ; int w = ( ( x2 - x1 ) - ( tw + _ NUM * padding ) ) / _ NUM ; if ( w <= padding ) { g . draw Line ( x1 , y , x2 , y ) ; g . draw String ( text , x1 + w + padding , y + offset ) ; g . draw Line ( x1 , y -  CONNECTION_ ARROW_ SIZE , x1 , y +  CONNECTION_ ARROW_ SIZE ) ; g . draw Line ( x2 , y -  CONNECTION_ ARROW_ SIZE , x2 , y +  CONNECTION_ ARROW_ SIZE ) ; } else { g . draw Line ( x1 , y , x1 + w , y ) ; g . draw Line ( x2 - w , y , x2 , y ) ; g . draw String ( text , x1 + w + padding , ( int ) ( y + ( bounds . get Height ( ) / _ NUM ) ) ) ; g . draw Line ( x1 , y , x1 +  CONNECTION_ ARROW_ SIZE , y -  CONNECTION_ ARROW_ SIZE ) ; g . draw Line ( x1 , y , x1 +  CONNECTION_ ARROW_ SIZE , y +  CONNECTION_ ARROW_ SIZE ) ; g . draw Line ( x2 , y , x2 -  CONNECTION_ ARROW_ SIZE , y -  CONNECTION_ ARROW_ SIZE ) ; g . draw Line ( x2 , y , x2 -  CONNECTION_ ARROW_ SIZE , y +  CONNECTION_ ARROW_ SIZE ) ; } }
protected boolean is Empty (  Byte Buffer bbuf ) { switch ( layer Type ) { case none : case footprint : case viewshed : case derivative : break ; case elevation : case field :  Float Buffer fbuf = bbuf . as Float Buffer ( ) ; int fl = fbuf . limit ( ) ; for ( int i = _ NUM ; i < fl ; ++ i ) { if ( !  Float . is Na N ( fbuf . get ( i ) ) ) { return ( _ BOOL ) ; } } break ; case colorimage :  Int Buffer ibuf = bbuf . as Int Buffer ( ) ; int il = ibuf . limit ( ) ; for ( int i = _ NUM ; i < il ; ++ i ) { if ( ibuf . get ( i ) != _ NUM ) { return ( _ BOOL ) ; } } break ; case grayimage : int bl = bbuf . limit ( ) ; for ( int i = _ NUM ; i < bl ; ++ i ) { if ( bbuf . get ( i ) != _ NUM ) { return ( _ BOOL ) ; } } break ; } return ( _ BOOL ) ; }
int parse Tr Block Content ( int current Offset , char open Quote , char close Quote ) { int block Start Offset = current Offset ;  Char Sequence buffer = get Buffer ( ) ; int buffer End = get Buffer End ( ) ; boolean is Escaped = _ BOOL ; boolean is Quote Differs = open Quote != close Quote ; int quotes Level = _ NUM ; while ( current Offset < buffer End ) { char current Char = buffer . char At ( current Offset ) ; if ( ! is Escaped && quotes Level == _ NUM && current Char == close Quote ) { if ( current Offset > block Start Offset ) { push Preparsed Token ( block Start Offset , current Offset ,  STRING_ CONTENT ) ; } break ; } if ( is Quote Differs && ! is Escaped ) { if ( current Char == open Quote ) { quotes Level ++ ; } else if ( current Char == close Quote ) { quotes Level -- ; } } is Escaped = ( current Char == _ STR && ! is Escaped ) ; current Offset ++ ; } return current Offset ; }
public static  String rate2speed ( double rate ) { return  NUMBER_ FORMAT0 . format ( rate ) + _ STR +  GENERAL_ UNIT_ KBPSEC ; }
void message Received (  Byte Buffer buf ) throws  Ignite Checked Exception ,  SSLException { if ( buf . limit ( ) > in Net Buf . remaining ( ) ) { in Net Buf = expand Buffer ( in Net Buf , in Net Buf . capacity ( ) + buf . limit ( ) * _ NUM ) ; app Buf = expand Buffer ( app Buf , in Net Buf . capacity ( ) * _ NUM ) ; if ( log . is Debug Enabled ( ) ) log . debug ( _ STR + in Net Buf . capacity ( ) + _ STR + app Buf . capacity ( ) + _ STR + ses + _ STR ) ; } in Net Buf . put ( buf ) ; if ( ! handshake Finished ) handshake ( ) ; else unwrap Data ( ) ; if ( is Inbound Done ( ) ) { int new Position = buf . position ( ) - in Net Buf . position ( ) ; if ( new Position >= _ NUM ) { buf . position ( new Position ) ; if ( buf . has Remaining ( ) )  U . warn ( log , _ STR + ses ) ; } in Net Buf . clear ( ) ; } }
public void initialize (  Context context ,  Haptic Feedback Controller haptic Feedback Controller , int initial Hours Of Day , int initial Minutes , boolean is24 Hour Mode ) { if ( m Time Initialized ) {  Log . e (  TAG , _ STR ) ; return ; } m Haptic Feedback Controller = haptic Feedback Controller ; m Is24 Hour Mode = is24 Hour Mode ; m Hide Am Pm = m Accessibility Manager . is Touch Exploration Enabled ( ) || m Is24 Hour Mode ; m Circle View . initialize ( context , m Hide Am Pm ) ; m Circle View . invalidate ( ) ; if ( ! m Hide Am Pm ) { m Am Pm Circles View . initialize ( context , initial Hours Of Day < _ NUM ?  AM :  PM ) ; m Am Pm Circles View . invalidate ( ) ; }  Resources res = context . get Resources ( ) ; int [ ] hours = { _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM } ; int [ ] hours_24 = { _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM } ; int [ ] minutes = { _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM } ;  String [ ] hours Texts = new  String [ _ NUM ] ;  String [ ] inner Hours Texts = new  String [ _ NUM ] ;  String [ ] minutes Texts = new  String [ _ NUM ] ; for ( int i = _ NUM ; i < _ NUM ; i ++ ) { hours Texts [ i ] =  Language Utils . get Persian Numbers ( is24 Hour Mode ?  String . format ( _ STR , hours_24 [ i ] ) :  String . format ( _ STR , hours [ i ] ) ) ; inner Hours Texts [ i ] =  Language Utils . get Persian Numbers (  String . format ( _ STR , hours [ i ] ) ) ; minutes Texts [ i ] =  Language Utils . get Persian Numbers (  String . format ( _ STR , minutes [ i ] ) ) ; } m Hour Radial Texts View . initialize ( res , hours Texts , ( is24 Hour Mode ? inner Hours Texts : null ) , m Hide Am Pm , _ BOOL ) ; m Hour Radial Texts View . set Selection ( is24 Hour Mode ? initial Hours Of Day : initial Hours Of Day % _ NUM ) ; m Hour Radial Texts View . invalidate ( ) ; m Minute Radial Texts View . initialize ( res , minutes Texts , null , m Hide Am Pm , _ BOOL ) ; m Minute Radial Texts View . set Selection ( initial Minutes ) ; m Minute Radial Texts View . invalidate ( ) ; set Value For Item (  HOUR_ INDEX , initial Hours Of Day ) ; set Value For Item (  MINUTE_ INDEX , initial Minutes ) ; int hour Degrees = ( initial Hours Of Day % _ NUM ) *  HOUR_ VALUE_ TO_ DEGREES_ STEP_ SIZE ; m Hour Radial Selector View . initialize ( context , m Hide Am Pm , is24 Hour Mode , _ BOOL , hour Degrees , is Hour Inner Circle ( initial Hours Of Day ) ) ; int minute Degrees = initial Minutes *  MINUTE_ VALUE_ TO_ DEGREES_ STEP_ SIZE ; m Minute Radial Selector View . initialize ( context , m Hide Am Pm , _ BOOL , _ BOOL , minute Degrees , _ BOOL ) ; m Time Initialized = _ BOOL ; }
protected void linear Layout (  Visual Table labels ) {  Rectangle2 D b = get Layout Bounds ( ) ; double breadth = get Breadth ( b ) ; double span = m_hi - m_lo ; double pspan = m_prevhi - m_prevlo ; double vlo = _ NUM ; if ( m_lo >= _ NUM ) { vlo =  Math . pow ( _ NUM ,  Math . floor (  Math Lib . log10 ( m_lo ) ) ) ; } else { vlo = -  Math . pow ( _ NUM , _ NUM +  Math . floor (  Math Lib . log10 ( - m_lo ) ) ) ; }  Iterator iter = labels . tuples ( ) ; while ( iter . has Next ( ) ) {  Visual Item item = (  Visual Item ) iter . next ( ) ; reset ( item ) ; double v = item . get Double (  VALUE ) ; double x = span == _ NUM ? _ NUM : ( ( v - m_lo ) / span ) * breadth ; set ( item , x , b ) ; }  Index index = labels . index (  VALUE ) ; double step = get Linear Step ( span , span == _ NUM ? _ NUM : breadth / span ) ; if ( step == _ NUM ) step = _ NUM ; int r ; for ( double x , v = vlo ; v <= m_hi ; v += step ) { x = ( ( v - m_lo ) / span ) * breadth ; if ( x < - _ NUM ) { continue ; } else if ( ( r = index . get ( v ) ) >= _ NUM ) {  Visual Item item = labels . get Item ( r ) ; item . set Visible ( _ BOOL ) ; item . set End Visible ( _ BOOL ) ; } else {  Visual Item item = labels . add Item ( ) ; item . set (  LABEL , m_nf . format ( v ) ) ; item . set Double (  VALUE , v ) ; double f = pspan == _ NUM ? _ NUM : ( ( v - m_prevlo ) / pspan ) ; if ( f <= _ NUM || f >= _ NUM ) item . set Start Visible ( _ BOOL ) ; set ( item , f * breadth , b ) ; set ( item , x , b ) ; } } }
private  String value To String (  Object value ) throws  Replicator Exception { if ( value instanceof  String ) { return value . to String ( ) ; } else if ( value instanceof  Integer ) { return value . to String ( ) ; } else if ( value instanceof  Serial Blob ) { try {  Serial Blob blob = (  Serial Blob ) value ; return new  String ( blob . get Bytes ( _ NUM , ( int ) blob . length ( ) ) ) ; } catch (  Serial Exception e ) { throw new  Replicator Exception ( _ STR + e , e ) ; } } else { return (  String ) value ; } }
public static boolean is Wrapper Instance (  Class type ,  Object instance ) { if ( ! type . is Primitive ( ) ) throw new  Illegal Argument Exception ( _ STR ) ; if ( int . class == type && instance instanceof  Integer ) { return _ BOOL ; } else if ( long . class == type && instance instanceof  Long ) { return _ BOOL ; } else if ( float . class == type && instance instanceof  Float ) { return _ BOOL ; } else if ( double . class == type && instance instanceof  Double ) { return _ BOOL ; } else if ( boolean . class == type && instance instanceof  Boolean ) { return _ BOOL ; } else if ( short . class == type && instance instanceof  Short ) { return _ BOOL ; } else if ( byte . class == type && instance instanceof  Byte ) { return _ BOOL ; } else if ( char . class == type && instance instanceof  Character ) { return _ BOOL ; } else { return _ BOOL ; } }
public  List <  Zone > show Zones (  Collection <  String > zone Names , boolean exclude Aliases ) {  List <  Zone > zones = new  Array List <  Zone > ( ) ;  Zone zone = null ; if ( zone Names != null && ! zone Names . is Empty ( ) ) {  Map <  String ,  String > alias Database = show Device Alias Database ( ) ; for (  String zone Name : zone Names ) { if ( zone Name . starts With (  IVR_ ZONENAME_ PREFIX ) ) { zone = show Ivr Zone ( zone Name . substring (  IVR_ ZONENAME_ PREFIX . length ( ) ) ) ; } else { zone = show Zone ( zone Name , alias Database , exclude Aliases ) ; } zones . add ( zone ) ; } } return zones ; }
public static boolean is Extension (  String filename ,  Collection <  String > extensions ) { if ( filename == null ) { return _ BOOL ; } if ( extensions == null || extensions . is Empty ( ) ) { return index Of Extension ( filename ) == - _ NUM ; }  String file Ext = get Extension ( filename ) ; for (  String extension : extensions ) { if ( file Ext . equals ( extension ) ) { return _ BOOL ; } } return _ BOOL ; }
private static void append Path Elements (  Document doc ,  String element Type ,  Element library Element ,  String [ ] paths ) { if ( paths . length > _ NUM ) {  Element child = doc . create Element ( element Type ) ; library Element . append Child ( child ) ; for ( int i = _ NUM ; i < paths . length ; i ++ ) {  String path = paths [ i ] ;  Element entry = doc . create Element ( _ STR ) ; child . append Child ( entry ) ; entry . set Attribute ( _ STR , path ) ; } } }
@  Override protected void close File (  Input Stream is ) throws  IOException { super . close File ( is ) ; br . close ( ) ; br = null ; path = null ; }
public void add Event Type (  Class event Class ) { add Event Type ( event Class . get Simple Name ( ) , event Class . get Name ( ) ) ; }
public static final  Variable Context [ ] parse (  String variable ) { char [ ] text = variable . to Char Array ( ) ;  List <  Variable Context > contexts = new  Array List < > ( ) ; int i = add Member ( text , _ NUM , contexts ) ; while ( i < text . length ) { if ( text [ i ] == _ STR ) { if ( text [ ++ i ] == _ STR ) { i = add String Index ( text , i , contexts ) ; } else { i = add Int Index ( text , i , contexts ) ; } ++ i ; } else { i = add Member ( text , i + _ NUM , contexts ) ; } } return contexts . to Array ( new  Variable Context [ contexts . size ( ) ] ) ; }
public void text ( int [ ] glyph Indices , int [ ] glyph Advances ) { int [ ] codes = ( int [ ] ) font Codes . get ( font Id ) ; if ( codes == null ) { return ; } char [ ] chars = new char [ glyph Indices . length ] ; for ( int i = _ NUM ; i < chars . length ; i ++ ) { int index = glyph Indices [ i ] ; if ( index >= codes . length ) { chars [ i ] = ( char ) index ; } else { chars [ i ] = ( char ) ( codes [ index ] ) ; } } output . print ( chars ) ; }
public double do Operation ( ) throws  Operator Failed Exception { double prior Precision = _ NUM / prior . variance ( ) ; double prior Mean = prior . mean ( ) ; double likelihood Precision = _ NUM / likelihood . variance ( ) ; double total = _ NUM ; int n = _ NUM ; for (  Attribute < double [ ] > statistic : data List ) { for ( double x : statistic . get Attribute Value ( ) ) { if ( is Log ) total +=  Math . log ( x ) ; else total += x ; n ++ ; } } double precision = prior Precision + likelihood Precision * n ; double mu = ( prior Precision * prior Mean + likelihood Precision * total ) / precision ; mean Parameter . set Parameter Value ( _ NUM ,  Math Utils . next Gaussian ( ) /  Math . sqrt ( precision ) + mu ) ; return _ NUM ; }
public void remove Method (  Soot Method m ) { check Level (  SIGNATURES ) ; if ( ! m . is Declared ( ) || m . get Declaring Class ( ) != this ) throw new  Runtime Exception ( _ STR + m . get Name ( ) ) ; if ( sub Sig To Methods . get ( m . get Numbered Sub Signature ( ) ) == null ) { throw new  Runtime Exception ( _ STR + m . get Sub Signature ( ) + _ STR + this ) ; } sub Sig To Methods . put ( m . get Numbered Sub Signature ( ) , null ) ; method List . remove ( m ) ; m . set Declared ( _ BOOL ) ; }
public void begin ( ) {  Operation op = curr Op . get ( ) ; if ( op != null ) { op . reentries ++ ; return ; } op = new  Operation ( ) ; curr Op . set ( op ) ; for ( ; ; ) {  Operation prev = head . get ( ) ; op . previous ( prev ) ; if ( head . compare And Set ( prev , op ) ) { prev . next ( op ) ; break ; } } }
public static synchronized  Buffered Image load Buffered JPEGImage (  URL url ) {  Buffered Image image = null ; if ( url != null ) { try { image =  Image IO . read ( url ) ; } catch (  Exception e ) { log . severe ( _ STR + url + _ STR + e . get Message ( ) ) ; image = null ; } finally { } if ( image != null ) { log . config ( _ STR + image . get Type ( ) ) ; if ( image . get Width ( ) <= _ NUM || image . get Height ( ) <= _ NUM ) { log . severe ( _ STR + url + _ STR ) ; image = null ; } } } return image ; }
protected int decode Line Prefix (  Pushback Input Stream in Stream ,  Output Stream out Stream ) throws  IOException { int c ; c = in Stream . read ( ) ; if ( c == _ STR ) { c = in Stream . read ( ) ; c = in Stream . read ( ) ; if ( ( c != _ STR ) && ( c != - _ NUM ) ) in Stream . unread ( c ) ; throw new  CEStream Exhausted ( ) ; } else if ( c == - _ NUM ) { throw new  CEFormat Exception ( _ STR ) ; } c = ( c - _ STR ) & _ NUM ; if ( c > bytes Per Line ( ) ) { throw new  CEFormat Exception ( _ STR ) ; } return ( c ) ; }
public void process Invite (  Request Event request Event ,  Server Transaction server Transaction ) {  Sip Provider sip Provider = (  Sip Provider ) request Event . get Source ( ) ;  Request request = request Event . get Request ( ) ; if ( counter == _ NUM ) new  Ttask ( ) ; this . counter ++ ; try {  Response response = message Factory . create Response (  Response .  BUSY_ HERE , request ) ;  To Header to Header = (  To Header ) response . get Header (  To Header .  NAME ) ; to Header . set Tag ( _ STR ) ;  Address address = address Factory . create Address ( _ STR + my Address + _ STR + my Port + _ STR ) ;  Contact Header contact Header = header Factory . create Contact Header ( address ) ; response . add Header ( contact Header ) ; if ( server Transaction == null ) { server Transaction = sip Provider . get New Server Transaction ( request ) ; } server Transaction . send Response ( response ) ; } catch (  Exception ex ) { ex . print Stack Trace ( ) ;  System . exit ( _ NUM ) ; } }
public boolean is IPCMethod (  Soot Method method ) { return ipc Methods . contains Poly ( method ) ; }
public  Extended Type ( int nodetype ,  String namespace ,  String local Name ) { this . nodetype = nodetype ; this . namespace = namespace ; this . local Name = local Name ; this . hash = nodetype + namespace . hash Code ( ) + local Name . hash Code ( ) ; }
public boolean is Item ( ) { if ( m_is Item != null ) return m_is Item . boolean Value ( ) ; m_is Item =  Boolean .  FALSE ; if ( get M_ Product_ ID ( ) != _ NUM ) {  MProduct product =  MProduct . get (  Env . get Ctx ( ) , get M_ Product_ ID ( ) ) ; if ( product . get_ ID ( ) == get M_ Product_ ID ( ) && product . is Item ( ) ) m_is Item =  Boolean .  TRUE ; } return m_is Item . boolean Value ( ) ; }
private void rewrite Save File (  Iterable <  Track Point > data ) {  File Output Stream file Output = null ;  Data Output Stream out = null ; try { file Output = ctx . open File Output (  SAVEFILE ,  Context .  MODE_ PRIVATE ) ; out = new  Data Output Stream ( new  Buffered Output Stream ( file Output ) ) ; out . write Int (  Track Point .  FORMAT_ VERSION ) ; for (  Track Point point : data ) { point . to Stream ( out ) ; } } catch (  Exception e ) { mark Saving Broken ( _ STR , e ) ; } finally {  Saving Helper . close ( out ) ; } }
public void test Isolated Index Write Rate ( ) throws  IOException {  String name = _ STR ; final  BTree btree ; {  Index Metadata metadata = new  Index Metadata (  UUID . random UUID ( ) ) ; metadata . set Branching Factor ( get Branching Factor ( ) ) ; metadata . set Isolatable ( _ BOOL ) ; btree =  BTree . create ( journal , metadata ) ; } journal . register Index ( name , btree ) ; journal . commit ( ) ; long tx = journal . new Tx (  ITx .  UNISOLATED ) ; do Index Write Rate Test ( name , tx , _ NUM ) ; }
@  Override public void stop (  Runnable callback ) { stop ( ) ; callback . run ( ) ; }
protected int read (  Input Stream input Stream , byte [ ] buffer , char [ ] divider ) throws  IOException { int index = _ NUM ; int divider Index = _ NUM ; do { byte read Byte = ( byte ) ( _ NUM & input Stream . read ( ) ) ; if ( read Byte == - _ NUM ) { return index ; } if ( read Byte == divider [ divider Index ] ) { divider Index ++ ; } if ( divider Index == divider . length ) { index -= divider Index - _ NUM ; for ( int i = index ; i < index + divider Index ; i ++ ) { if ( i >= buffer . length ) { break ; } buffer [ i ] = _ NUM ; } return index ; } buffer [ index ] = read Byte ; index ++ ; } while ( index < buffer . length ) ; return index ; }
private static void generate Graph File (  Trans Meta trans Meta ,  String graph File ) throws  Graph Generator Exception {  Data Output Stream dos = null ; try {  String xml = trans Meta . get XML ( ) ; dos = new  Data Output Stream ( new  File Output Stream ( new  File ( graph File ) ) ) ; dos . write ( xml . get Bytes ( _ STR ) ) ; } catch (  Kettle Exception kettel Exception ) { throw new  Graph Generator Exception ( _ STR , kettel Exception ) ; } catch (  File Not Found Exception e ) { throw new  Graph Generator Exception ( _ STR , e ) ; } catch (  Unsupported Encoding Exception ue ) { throw new  Graph Generator Exception ( _ STR , ue ) ; } catch (  IOException ioe ) { throw new  Graph Generator Exception ( _ STR , ioe ) ; } finally { if ( dos != null ) { try { dos . close ( ) ; } catch (  IOException e ) { e . get Message ( ) ; } } } }
public void test Ignore Over ( ) throws  Exception {  Object Mapper m = new  Object Mapper ( ) ;  Map <  String ,  Object > result = write And Map ( m , new  Base Class Ignore ( ) ) ; assert Equals ( _ NUM , result . size ( ) ) ; assert Equals (  Integer . value Of ( _ NUM ) , result . get ( _ STR ) ) ; result = write And Map ( m , new  Sub Class Non Ignore ( ) ) ; assert Equals ( _ NUM , result . size ( ) ) ; assert Equals (  Integer . value Of ( _ NUM ) , result . get ( _ STR ) ) ; assert Equals (  Integer . value Of ( _ NUM ) , result . get ( _ STR ) ) ; }
public void delete Entity Config (  String realm ,  String entity Id ) throws  SAML2 Meta Exception { if ( entity Id == null ) { return ; } if ( realm == null ) { realm = _ STR ; }  String [ ] objs = { entity Id , realm } ; try {  Map old Attrs = config Inst . get Configuration ( realm , entity Id ) ;  Set old Values = (  Set ) old Attrs . get (  ATTR_ ENTITY_ CONFIG ) ; if ( old Values == null || old Values . is Empty ( ) ) {  Log Util . error (  Level .  INFO ,  Log Util .  NO_ ENTITY_ DESCRIPTOR_ DELETE_ ENTITY_ CONFIG , objs , null ) ; throw new  SAML2 Meta Exception ( _ STR , objs ) ; } remove From Circle Of Trust ( realm , entity Id ) ;  Set attr = new  Hash Set ( ) ; attr . add (  ATTR_ ENTITY_ CONFIG ) ; config Inst . delete Configuration ( realm , entity Id , attr ) ;  Log Util . access (  Level .  INFO ,  Log Util .  ENTITY_ CONFIG_ DELETED , objs , null ) ;  SAML2 Meta Cache . put Entity Config ( realm , entity Id , null ) ; } catch (  Configuration Exception e ) { debug . error ( _ STR , e ) ;  String [ ] data = { e . get Message ( ) , entity Id , realm } ;  Log Util . error (  Level .  INFO ,  Log Util .  CONFIG_ ERROR_ DELETE_ ENTITY_ CONFIG , data , null ) ; throw new  SAML2 Meta Exception ( e ) ; } }
private  Number Printer Parser number Printer Parser ( ) { if ( number Printer Parser == null ) { number Printer Parser = new  Number Printer Parser ( field , _ NUM , _ NUM ,  Sign Style .  NORMAL ) ; } return number Printer Parser ; }
public void dispatch Event (  AWTEvent event ) { if ( ! ( event instanceof  Key Event ) ) { return ; }  Key Event e = (  Key Event ) event ; int event ID = event . get ID ( ) ; boolean not In Composition Mode = buffer . length ( ) == _ NUM ; if ( event ID ==  Key Event .  KEY_ PRESSED ) { if ( not In Composition Mode ) { return ; } switch ( e . get Key Code ( ) ) { case  Key Event .  VK_ LEFT : move Caret Left ( ) ; break ; case  Key Event .  VK_ RIGHT : move Caret Right ( ) ; break ; } } else if ( event ID ==  Key Event .  KEY_ TYPED ) { char c = e . get Key Char ( ) ; if ( not In Composition Mode ) { if ( c != _ STR ) { return ; } start Composition ( ) ; } else { switch ( c ) { case _ STR : finish Composition ( ) ; break ; case _ STR : delete Character ( ) ; break ; case _ STR : delete Previous Character ( ) ; break ; case _ STR : cancel Composition ( ) ; break ; case _ STR : case _ STR : send Committed Text ( ) ; break ; default : compose Unicode Escape ( c ) ; break ; } } } else { if ( not In Composition Mode ) { return ; } } e . consume ( ) ; }
public void manage List (  List <  Span > spans ) { managed Lists . add ( spans ) ; }
public static java . sql .  Timestamp to Timestamp ( int month , int day , int year , int hour , int minute , int second ) { java . util .  Date new Date = to Date ( month , day , year , hour , minute , second ) ; if ( new Date != null ) { return new java . sql .  Timestamp ( new Date . get Time ( ) ) ; } else { return null ; } }
protected boolean schedule New Task (  String task Id ) {  LOG . info (  String . format ( _ STR , task Id ) ) ; int container Index =  Task Utils . get Container Index For Task Id ( task Id ) ; tasks Id . put ( container Index , task Id ) ; to Schedule Tasks . add ( task Id ) ;  LOG . info (  String . format ( _ STR , task Id ) ) ; return _ BOOL ; }
private void apply Ltp (  Single Channel Element sce ) {  Long Term Prediction ltp = sce . ics . ltp ; final int offsets [ ] = sce . ics . swb Offset ; if ( sce . ics . window Sequence [ _ NUM ] !=  EIGHT_ SHORT_ SEQUENCE ) { final float pred Time [ ] = sce . ret ; final float pred Freq [ ] = ac . buf Mdct ; int num Samples = _ NUM ; if ( ltp . lag < _ NUM ) { num Samples = ltp . lag + _ NUM ; } for ( int i = _ NUM ; i < num Samples ; i ++ ) { pred Time [ i ] = sce . ltp State [ i + _ NUM - ltp . lag ] * ltp . coef ; }  Arrays . fill ( pred Time , num Samples , _ NUM , _ NUM ) ; windowing And Mdct Ltp ( pred Freq , pred Time , sce . ics ) ; if ( sce . tns . present ) { apply Tns ( pred Freq , sce . tns , sce . ics , _ BOOL ) ; } for ( int sfb = _ NUM ; sfb <  Math . min ( sce . ics . max Sfb ,  MAX_ LTP_ LONG_ SFB ) ; sfb ++ ) { if ( ltp . used [ sfb ] ) { for ( int i = offsets [ sfb ] ; i < offsets [ sfb + _ NUM ] ; i ++ ) { sce . coeffs [ i ] += pred Freq [ i ] ; } } } } }
private  Hash Map <  String ,  String > read Config (  String config Path ) throws  Exception { log . debug ( _ STR + config Path ) ;  File config File = new  File ( config Path ) ; if ( ! config File . is File ( ) ) return null ;  Config Reader reader = new  Config Reader ( ) ; reader . read Config ( config Path ) ; return reader . get Config Map ( ) ; }
@  Override public void draw Domain Marker (  Graphics2 D g2 ,  XYPlot plot ,  Value Axis domain Axis ,  Marker marker ,  Rectangle2 D data Area ) { if ( marker instanceof  Value Marker ) {  Value Marker vm = (  Value Marker ) marker ; double value = vm . get Value ( ) ;  Range range = domain Axis . get Range ( ) ; if ( ! range . contains ( value ) ) { return ; } double v = domain Axis . value To Java2 D ( value , data Area , plot . get Domain Axis Edge ( ) ) ;  Plot Orientation orientation = plot . get Orientation ( ) ;  Line2 D line = null ; if ( orientation ==  Plot Orientation .  HORIZONTAL ) { line = new  Line2 D .  Double ( data Area . get Min X ( ) , v , data Area . get Max X ( ) , v ) ; } else if ( orientation ==  Plot Orientation .  VERTICAL ) { line = new  Line2 D .  Double ( v , data Area . get Min Y ( ) , v , data Area . get Max Y ( ) ) ; } else { throw new  Illegal State Exception ( _ STR ) ; } final  Composite original Composite = g2 . get Composite ( ) ; g2 . set Composite (  Alpha Composite . get Instance (  Alpha Composite .  SRC_ OVER , marker . get Alpha ( ) ) ) ; g2 . set Paint ( marker . get Paint ( ) ) ; g2 . set Stroke ( marker . get Stroke ( ) ) ; g2 . draw ( line ) ;  String label = marker . get Label ( ) ;  Rectangle Anchor anchor = marker . get Label Anchor ( ) ; if ( label != null ) {  Font label Font = marker . get Label Font ( ) ; g2 . set Font ( label Font ) ;  Point2 D coords = calculate Domain Marker Text Anchor Point ( g2 , orientation , data Area , line . get Bounds2 D ( ) , marker . get Label Offset ( ) ,  Length Adjustment Type .  EXPAND , anchor ) ;  Rectangle2 D r =  Text Utils . calc Aligned String Bounds ( label , g2 , ( float ) coords . get X ( ) , ( float ) coords . get Y ( ) , marker . get Label Text Anchor ( ) ) ; g2 . set Paint ( marker . get Label Background Color ( ) ) ; g2 . fill ( r ) ; g2 . set Paint ( marker . get Label Paint ( ) ) ;  Text Utils . draw Aligned String ( label , g2 , ( float ) coords . get X ( ) , ( float ) coords . get Y ( ) , marker . get Label Text Anchor ( ) ) ; } g2 . set Composite ( original Composite ) ; } else if ( marker instanceof  Interval Marker ) {  Interval Marker im = (  Interval Marker ) marker ; double start = im . get Start Value ( ) ; double end = im . get End Value ( ) ;  Range range = domain Axis . get Range ( ) ; if ( ! ( range . intersects ( start , end ) ) ) { return ; } double start2d = domain Axis . value To Java2 D ( start , data Area , plot . get Domain Axis Edge ( ) ) ; double end2d = domain Axis . value To Java2 D ( end , data Area , plot . get Domain Axis Edge ( ) ) ; double low =  Math . min ( start2d , end2d ) ; double high =  Math . max ( start2d , end2d ) ;  Plot Orientation orientation = plot . get Orientation ( ) ;  Rectangle2 D rect = null ; if ( orientation ==  Plot Orientation .  HORIZONTAL ) { low =  Math . max ( low , data Area . get Min Y ( ) ) ; high =  Math . min ( high , data Area . get Max Y ( ) ) ; rect = new  Rectangle2 D .  Double ( data Area . get Min X ( ) , low , data Area . get Width ( ) , high - low ) ; } else if ( orientation ==  Plot Orientation .  VERTICAL ) { low =  Math . max ( low , data Area . get Min X ( ) ) ; high =  Math . min ( high , data Area . get Max X ( ) ) ; rect = new  Rectangle2 D .  Double ( low , data Area . get Min Y ( ) , high - low , data Area . get Height ( ) ) ; } final  Composite original Composite = g2 . get Composite ( ) ; g2 . set Composite (  Alpha Composite . get Instance (  Alpha Composite .  SRC_ OVER , marker . get Alpha ( ) ) ) ;  Paint p = marker . get Paint ( ) ; if ( p instanceof  Gradient Paint ) {  Gradient Paint gp = (  Gradient Paint ) p ;  Gradient Paint Transformer t = im . get Gradient Paint Transformer ( ) ; if ( t != null ) { gp = t . transform ( gp , rect ) ; } g2 . set Paint ( gp ) ; } else { g2 . set Paint ( p ) ; } g2 . fill ( rect ) ; if ( im . get Outline Paint ( ) != null && im . get Outline Stroke ( ) != null ) { if ( orientation ==  Plot Orientation .  VERTICAL ) {  Line2 D line = new  Line2 D .  Double ( ) ; double y0 = data Area . get Min Y ( ) ; double y1 = data Area . get Max Y ( ) ; g2 . set Paint ( im . get Outline Paint ( ) ) ; g2 . set Stroke ( im . get Outline Stroke ( ) ) ; if ( range . contains ( start ) ) { line . set Line ( start2d , y0 , start2d , y1 ) ; g2 . draw ( line ) ; } if ( range . contains ( end ) ) { line . set Line ( end2d , y0 , end2d , y1 ) ; g2 . draw ( line ) ; } } else {  Line2 D line = new  Line2 D .  Double ( ) ; double x0 = data Area . get Min X ( ) ; double x1 = data Area . get Max X ( ) ; g2 . set Paint ( im . get Outline Paint ( ) ) ; g2 . set Stroke ( im . get Outline Stroke ( ) ) ; if ( range . contains ( start ) ) { line . set Line ( x0 , start2d , x1 , start2d ) ; g2 . draw ( line ) ; } if ( range . contains ( end ) ) { line . set Line ( x0 , end2d , x1 , end2d ) ; g2 . draw ( line ) ; } } }  String label = marker . get Label ( ) ;  Rectangle Anchor anchor = marker . get Label Anchor ( ) ; if ( label != null ) {  Font label Font = marker . get Label Font ( ) ; g2 . set Font ( label Font ) ;  Point2 D coords = calculate Domain Marker Text Anchor Point ( g2 , orientation , data Area , rect , marker . get Label Offset ( ) , marker . get Label Offset Type ( ) , anchor ) ;  Rectangle2 D r =  Text Utils . calc Aligned String Bounds ( label , g2 , ( float ) coords . get X ( ) , ( float ) coords . get Y ( ) , marker . get Label Text Anchor ( ) ) ; g2 . set Paint ( marker . get Label Background Color ( ) ) ; g2 . fill ( r ) ; g2 . set Paint ( marker . get Label Paint ( ) ) ;  Text Utilities . draw Aligned String ( label , g2 , ( float ) coords . get X ( ) , ( float ) coords . get Y ( ) , marker . get Label Text Anchor ( ) ) ; } g2 . set Composite ( original Composite ) ; } }
@  Suppress Warnings ( _ STR ) @  Override protected  Object apply Updates To Managed Data (  Object updates ) { boolean made Changes = _ BOOL ;  List <  String > words = (  List <  String > ) updates ; log . info ( _ STR + words ) ; boolean ignore Case = get Ignore Case ( ) ; for (  String word : words ) { if ( ignore Case ) word = word . to Lower Case (  Locale .  ROOT ) ; if ( managed Words . add ( word ) ) { made Changes = _ BOOL ; log . info ( _ STR , word ) ; } } return made Changes ? managed Words : null ; }
@  Override public boolean on Preference Tree Click (  Preference Screen preference Screen ,  Preference preference ) { log ( _ STR + preference ) ; if ( preference == m Airplane Mode Preference &&  Boolean . parse Boolean (  System Properties . get (  Telephony Properties .  PROPERTY_ INECM_ MODE ) ) ) { start Activity For Result ( new  Intent (  Telephony Intents .  ACTION_ SHOW_ NOTICE_ ECM_ BLOCK_ OTHERS , null ) ,  REQUEST_ CODE_ EXIT_ ECM ) ; return _ BOOL ; } else if ( preference == find Preference (  KEY_ MANAGE_ MOBILE_ PLAN ) ) { on Manage Mobile Plan Click ( ) ; } return super . on Preference Tree Click ( preference Screen , preference ) ; }
public void read Proxy Authenticate Header (  Sip Response response ) {  Proxy Authenticate Header header = (  Proxy Authenticate Header ) response . get Header (  Proxy Authenticate Header .  NAME ) ; if ( header != null ) { m Digest . set Realm ( header . get Realm ( ) ) ; m Digest . set Qop ( header . get Qop ( ) ) ; m Digest . set Nextnonce ( header . get Nonce ( ) ) ; } }
public static  Boolean value Of (  String value ) { return value != null ?  Boolean . value Of ( value ) : null ; }
public void test Consume Queue ( ) throws  Exception {  Message Producer producer = create Producer ( _ NUM ) ; consumer Destination = session . create Queue ( get Consumer Subject ( ) ) ; producer Destination = session . create Queue ( get Producer Subject ( ) ) ;  Message Consumer consumer = create Consumer ( ) ; connection . start ( ) ; for ( int i = _ NUM ; i < data . length ; i ++ ) {  Message message = session . create Text Message ( data [ i ] ) ; message . set String Property ( _ STR , data [ i ] ) ; message . set Int Property ( _ STR , i ) ; if ( verbose ) { if (  LOG . is Debug Enabled ( ) ) {  LOG . debug ( _ STR + message + _ STR + data [ i ] ) ; } } producer . send ( producer Destination , message ) ; } assert Not Null ( consumer . receive ( _ NUM ) ) ; }
public  Parse Exception ( final int line , final int column , final  String message ) { super (  Integer . to String ( line ) + _ STR + column + _ STR + message ) ; this . line = line ; this . column = column ; }
public boolean draw Image (  Image img ,  Affine Transform xform ,  Image Observer obs ) { if ( img == null ) { return _ BOOL ; } m Drawing Area . add Infinite ( ) ; m Print Metrics . draw Image ( this , img ) ; return m Graphics . draw Image ( img , xform , obs ) ; }
public static  String encode ( byte source [ ] ) { int offset = _ NUM ; int num = _ NUM ; int num Bytes = _ NUM ;  String Builder sb = new  String Builder ( ) ; for ( int i = _ NUM ; i < source . length ; i ++ ) { int b = source [ offset ++ ] ; if ( b < _ NUM ) b += _ NUM ; num = ( num << _ NUM ) + b ; if ( ++ num Bytes != _ NUM ) continue ; sb . append ( int To Base64 [ num > > _ NUM ] ) ; sb . append ( int To Base64 [ num > > _ NUM & _ NUM ] ) ; sb . append ( int To Base64 [ num > > _ NUM & _ NUM ] ) ; sb . append ( int To Base64 [ num & _ NUM ] ) ; num = _ NUM ; num Bytes = _ NUM ; } if ( num Bytes > _ NUM ) { if ( num Bytes == _ NUM ) { sb . append ( int To Base64 [ num > > _ NUM ] ) ; sb . append ( int To Base64 [ num << _ NUM & _ NUM ] ) ; sb . append ( _ STR ) ; } else { sb . append ( int To Base64 [ num > > _ NUM ] ) ; sb . append ( int To Base64 [ num > > _ NUM & _ NUM ] ) ; sb . append ( int To Base64 [ num << _ NUM & _ NUM ] ) ; sb . append ( _ STR ) ; } } return sb . to String ( ) ; }
protected void update (  Timer Status new Status ) { if ( new Status ==  Timer Status .  FORWARD ) { if (  Debug . debugging ( _ STR ) ) {  Debug . output ( _ STR ) ; } backward Button . set Icon ( backward Icon ) ; backward Button . set Action Command (  Timer Status .  TIMER_ BACKWARD ) ; forward Button . set Icon ( pause Icon ) ; forward Button . set Action Command (  Timer Status .  TIMER_ STOPPED ) ; } else if ( new Status ==  Timer Status .  BACKWARD ) { if (  Debug . debugging ( _ STR ) ) {  Debug . output ( _ STR ) ; } forward Button . set Icon ( forward Icon ) ; forward Button . set Action Command (  Timer Status .  TIMER_ FORWARD ) ; backward Button . set Icon ( pause Icon ) ; backward Button . set Action Command (  Timer Status .  TIMER_ STOPPED ) ; } else if ( new Status ==  Timer Status .  STOPPED ) { if (  Debug . debugging ( _ STR ) ) {  Debug . output ( _ STR ) ; } forward Button . set Icon ( forward Icon ) ; forward Button . set Action Command (  Timer Status .  TIMER_ FORWARD ) ; backward Button . set Icon ( backward Icon ) ; backward Button . set Action Command (  Timer Status .  TIMER_ BACKWARD ) ; } check Clock ( new Status ) ; }
public static  Angle rhumb Azimuth (  Lat Lon p1 ,  Lat Lon p2 ) { if ( p1 == null || p2 == null ) { throw new  Illegal Argument Exception ( _ STR ) ; } double lat1 = p1 . get Latitude ( ) . radians ; double lon1 = p1 . get Longitude ( ) . radians ; double lat2 = p2 . get Latitude ( ) . radians ; double lon2 = p2 . get Longitude ( ) . radians ; if ( lat1 == lat2 && lon1 == lon2 ) return  Angle .  ZERO ; double d Lon = lon2 - lon1 ; double d Phi =  Math . log (  Math . tan ( lat2 / _ NUM +  Math .  PI / _ NUM ) /  Math . tan ( lat1 / _ NUM +  Math .  PI / _ NUM ) ) ; if (  Math . abs ( d Lon ) >  Math .  PI ) { d Lon = d Lon > _ NUM ? - ( _ NUM *  Math .  PI - d Lon ) : ( _ NUM *  Math .  PI + d Lon ) ; } double azimuth Radians =  Math . atan2 ( d Lon , d Phi ) ; return  Double . is Na N ( azimuth Radians ) ?  Angle .  ZERO :  Angle . from Radians ( azimuth Radians ) ; }
public boolean is Option Checked ( int index ) { if ( index >= checkbox Panel . get Components ( ) . length ) { return _ BOOL ; }  JCheck Box checkbox = (  JCheck Box ) checkbox Panel . get Component ( index ) ; if ( checkbox . is Selected ( ) ) { return _ BOOL ; } else { return _ BOOL ; } }
private void paint Check Icon Selected And Mouse Over (  Graphics2 D g , int width , int height ) {  Shape s = shape Generator . create Check Mark ( _ NUM , _ NUM , width , height ) ; g . set Paint ( icon Selected Mouse Over ) ; g . fill ( s ) ; }
public static int find URISplit Index (  String uri ) { int uri Length = uri . length ( ) ; int i = uri Length - _ NUM ; while ( i >= _ NUM ) { char c = uri . char At ( i ) ; if ( c == _ STR || c == _ STR || !  XMLUtil . is NCName Char ( c ) ) { break ; } i -- ; } i ++ ; while ( i < uri Length ) { char c = uri . char At ( i ) ; if ( c == _ STR ||  XMLUtil . is Letter ( c ) ) { break ; } i ++ ; } if ( i == uri Length ) { i = - _ NUM ; } return i ; }
public  File tofile (  HSSFWorkbook wb ,  String [ ] general Title ) {  String path =  System . get Property ( _ STR ) ; if ( ! ( path . ends With ( _ STR ) || path . ends With ( _ STR ) ) ) path = path +  System . get Property ( _ STR ) ;  String prefix =  String Utils . make Prefix ( general Title [ _ NUM ] ) ; if ( log . is Loggable (  Level .  FINE ) ) { log . log (  Level .  FINE , _ STR + path + _ STR + prefix ) ; }  File file = new  File ( path + prefix + _ STR ) ; try { if ( file . exists ( ) ) file . delete ( ) ; } catch (  Exception e ) { log . log (  Level .  SEVERE , _ STR , e ) ; return null ; }  File Output Stream fos ; try { fos = new  File Output Stream ( file ) ; wb . write ( fos ) ; fos . flush ( ) ; fos . close ( ) ; } catch (  File Not Found Exception e ) { e . print Stack Trace ( ) ; } catch (  IOException e ) { e . print Stack Trace ( ) ; } return file ; }
@  Override public void on Loader Reset (  Loader <  Cursor > loader ) { if (  Global . debug Enabled ) {  Log . i (  Global .  LOG_ CONTEXT , m Debug Prefix + _ STR + get Debug Context ( ) ) ; } m Last Visible Position = m Gallery View . get Last Visible Position ( ) ; m Adapter . swap Cursor ( null ) ; m Adapter . notify Data Set Changed ( ) ; }
protected void initialize Content Model Stack ( ) { if ( f Op Stack == null ) { f Op Stack = new short [ _ NUM ] ; f Node Index Stack = new int [ _ NUM ] ; f Prev Node Index Stack = new int [ _ NUM ] ; } else if ( f Depth == f Op Stack . length ) { short [ ] new Stack = new short [ f Depth * _ NUM ] ;  System . arraycopy ( f Op Stack , _ NUM , new Stack , _ NUM , f Depth ) ; f Op Stack = new Stack ; int [ ] new Int Stack = new int [ f Depth * _ NUM ] ;  System . arraycopy ( f Node Index Stack , _ NUM , new Int Stack , _ NUM , f Depth ) ; f Node Index Stack = new Int Stack ; new Int Stack = new int [ f Depth * _ NUM ] ;  System . arraycopy ( f Prev Node Index Stack , _ NUM , new Int Stack , _ NUM , f Depth ) ; f Prev Node Index Stack = new Int Stack ; } f Op Stack [ f Depth ] = - _ NUM ; f Node Index Stack [ f Depth ] = - _ NUM ; f Prev Node Index Stack [ f Depth ] = - _ NUM ; }
private void grow Spine ( ) { int size = ( spine . length << _ NUM ) + _ NUM ; spine = new int [ size ] ; spine Empty = new int [ size ] ; threshold = ( int ) ( spine . length * load Factor ) ;  Arrays . fill ( spine Empty , - _ NUM ) ;  Grid Unsafe . copy Memory ( spine Empty ,  INT_ ARR_ OFF , spine ,  INT_ ARR_ OFF , spine Empty . length << _ NUM ) ; for ( int i = _ NUM ; i < this . size ; i ++ ) {  Object obj = objs [ i ] ; int idx = hash ( obj ) % spine . length ; insert ( objs [ i ] , i , idx ) ; } }
public void close ( ) {  Thread current = thread ; thread = null ; if ( current != null ) { current . interrupt ( ) ; try { current . join ( ) ; } catch (  Interrupted Exception e ) { log . error ( e . get Message ( ) , e ) ; } } try { buffer . close ( ) ; } catch (  IOException e ) { log . error ( e . get Message ( ) , e ) ; } }
Vcf Record [ ] merge Records (  Vcf Record [ ] records ,  Vcf Header [ ] headers ,  Vcf Header dest Header ,  Set <  String > unmergeable Format Fields , boolean preserve Formats ) { assert records . length == headers . length ; final  Multi Map <  Integer ,  Vcf Record > record Sets = new  Multi Map < > ( _ BOOL ) ; final  Multi Map <  Integer ,  Vcf Header > header Sets = new  Multi Map < > ( _ BOOL ) ; for ( int i = _ NUM ; i < records . length ; i ++ ) { record Sets . put ( records [ i ] . get Length ( ) , records [ i ] ) ; header Sets . put ( records [ i ] . get Length ( ) , headers [ i ] ) ; } final  Array List <  Vcf Record > ret = new  Array List < > ( ) ; for (  Integer key : record Sets . key Set ( ) ) { final  Collection <  Vcf Record > recs = record Sets . get ( key ) ; final  Collection <  Vcf Header > heads = header Sets . get ( key ) ; final  Vcf Record [ ] recs Array = recs . to Array ( new  Vcf Record [ recs . size ( ) ] ) ; final  Vcf Header [ ] heads Array = heads . to Array ( new  Vcf Header [ heads . size ( ) ] ) ; final  Vcf Record merged = merge Records With Same Ref ( recs Array , heads Array , dest Header , unmergeable Format Fields , ! preserve Formats ) ; if ( merged != null ) { ret . add ( merged ) ; } else { final  Vcf Record [ ] rec Holder = new  Vcf Record [ _ NUM ] ; final  Vcf Header [ ] head Holder = new  Vcf Header [ _ NUM ] ; for ( int i = _ NUM ; i < recs Array . length ; i ++ ) { rec Holder [ _ NUM ] = recs Array [ i ] ; head Holder [ _ NUM ] = heads Array [ i ] ; ret . add ( merge Records With Same Ref ( rec Holder , head Holder , dest Header , unmergeable Format Fields , ! preserve Formats ) ) ; } } } return ret . to Array ( new  Vcf Record [ ret . size ( ) ] ) ; }
public boolean var Used In Filter Or Assignment (  IVariable < ? > var ) { if ( ! usage Map . contains Key ( var ) ) { return _ BOOL ; } final  List <  IQuery Node > var Occurrences = usage Map . get ( var ) ; for ( int i = _ NUM ; i < var Occurrences . size ( ) ; i ++ ) { final  IQuery Node n = var Occurrences . get ( i ) ; if ( n instanceof  Filter Node || n instanceof  Assignment Node ) { return _ BOOL ; } } return _ BOOL ; }
private void calculate Intersect Points ( ) { intersect Points . clear ( ) ; if ( center . x - menu Bounds . left < expanded Radius ) { int dy = ( int )  Math . sqrt (  Math . pow ( expanded Radius , _ NUM ) -  Math . pow ( center . x - menu Bounds . left , _ NUM ) ) ; if ( center . y - dy > menu Bounds . top ) { intersect Points . add ( new  Point ( menu Bounds . left , center . y - dy ) ) ; } if ( center . y + dy < menu Bounds . bottom ) { intersect Points . add ( new  Point ( menu Bounds . left , center . y + dy ) ) ; } } if ( center . y - menu Bounds . top < expanded Radius ) { int dx = ( int )  Math . sqrt (  Math . pow ( expanded Radius , _ NUM ) -  Math . pow ( center . y - menu Bounds . top , _ NUM ) ) ; if ( center . x + dx < menu Bounds . right ) { intersect Points . add ( new  Point ( center . x + dx , menu Bounds . top ) ) ; } if ( center . x - dx > menu Bounds . left ) { intersect Points . add ( new  Point ( center . x - dx , menu Bounds . top ) ) ; } } if ( menu Bounds . right - center . x < expanded Radius ) { int dy = ( int )  Math . sqrt (  Math . pow ( expanded Radius , _ NUM ) -  Math . pow ( menu Bounds . right - center . x , _ NUM ) ) ; if ( center . y - dy > menu Bounds . top ) { intersect Points . add ( new  Point ( menu Bounds . right , center . y - dy ) ) ; } if ( center . y + dy < menu Bounds . bottom ) { intersect Points . add ( new  Point ( menu Bounds . right , center . y + dy ) ) ; } } if ( menu Bounds . bottom - center . y < expanded Radius ) { int dx = ( int )  Math . sqrt (  Math . pow ( expanded Radius , _ NUM ) -  Math . pow ( menu Bounds . bottom - center . y , _ NUM ) ) ; if ( center . x + dx < menu Bounds . right ) { intersect Points . add ( new  Point ( center . x + dx , menu Bounds . bottom ) ) ; } if ( center . x - dx > menu Bounds . left ) { intersect Points . add ( new  Point ( center . x - dx , menu Bounds . bottom ) ) ; } } int size = intersect Points . size ( ) ; if ( size == _ NUM ) { from Angle = _ NUM ; to Angle = _ NUM ; return ; } int index A = size - _ NUM ; double max Angle = arc Angle ( center , intersect Points . get ( _ NUM ) , intersect Points . get ( index A ) , menu Bounds , expanded Radius ) ; for ( int i = _ NUM ; i < size - _ NUM ; i ++ ) {  Point a = intersect Points . get ( i ) ;  Point b = intersect Points . get ( i + _ NUM ) ; double angle = arc Angle ( center , a , b , menu Bounds , expanded Radius ) ;  Point midnormal Point = find Midnormal Point ( center , a , b , menu Bounds , expanded Radius ) ; int pointer Index = i ; int end Index = index A + _ NUM ; if ( ! is Clockwise ( center , a , midnormal Point ) ) { int tmp Index = pointer Index ; pointer Index = end Index ; end Index = tmp Index ; } if ( pointer Index == intersect Points . size ( ) - _ NUM ) { pointer Index = _ NUM ; } else { pointer Index ++ ; } if ( pointer Index == end Index && angle > max Angle ) { index A = i ; max Angle = angle ; } }  Point a = intersect Points . get ( index A ) ;  Point b = intersect Points . get ( index A + _ NUM >= size ? _ NUM : index A + _ NUM ) ;  Point midnormal Point = find Midnormal Point ( center , a , b , menu Bounds , expanded Radius ) ;  Point x = new  Point ( menu Bounds . right , center . y ) ; if ( ! is Clockwise ( center , a , midnormal Point ) ) {  Point tmp = a ; a = b ; b = tmp ; } from Angle = point Angle On Circle ( center , a , x ) ; to Angle = point Angle On Circle ( center , b , x ) ; to Angle = to Angle <= from Angle ? _ NUM + to Angle : to Angle ; }
public  Argument Values process ( final  String [ ] program Args ) throws  Usage Exception {  Argument Handler arg Handler ; final  Argument Values result = new  Argument Values ( ) ;  List <  Argument > unmatched ;  List <  Match > matches ; matches = check Matches ( program Args , result ) ; unmatched = new  Array List <  Argument > ( ) ; unmatched . add All ( args ) ; for (  Match match : matches ) { unmatched . remove ( match . get Argument ( ) ) ; } for (  Argument arg : unmatched ) { if ( arg . is Required ( ) && ! arg . is Defined In Env ( ) ) { final  Usage Exception usage Exception = new  Usage Exception ( _ STR + arg ) ; usage Exception . set Usage ( get Usage ( ) ) ; throw usage Exception ; } } for (  Match match : matches ) { final  Argument arg = match . get Argument ( ) ; arg Handler = arg . get Argument Handler ( ) ; if ( arg Handler != null ) { arg Handler . handle Argument ( arg , match . get Form ( ) , match . get Params ( ) ) ; } result . add Result ( arg , match . get Params ( ) ) ; } return result ; }
public  Annotating Graph Mouse Plugin (  Render Context <  V ,  E > rc , int selection Modifiers , int additional Modifiers ) { super ( selection Modifiers ) ; this . rc = rc ; this . basic Transformer = rc . get Multi Layer Transformer ( ) ; this . additional Modifiers = additional Modifiers ; this . lens Paintable = new  Lens Paintable ( ) ; this . annotation Manager = new  Annotation Manager ( rc ) ; this . cursor =  Cursor . get Predefined Cursor (  Cursor .  HAND_ CURSOR ) ; }
public double [ ] breadth First Search ( double intial Value , double first Value ,  IBFSTraversable <  N > traversable ,  IDouble Bfs Next Level Value Iterator <  N > next Value Iterator ,  List <  Integer > sources ) { double [ ] results = new double [ nodes . length ] ;  Arrays . fill ( results , intial Value ) ; boolean [ ] already Scanned = new boolean [ nodes . length ] ;  Arrays . fill ( already Scanned , _ BOOL ) ;  Set <  Integer > current Nodes Index = new  Hash Set < > ( sources ) ; iterative Double Breadth First Search ( results , already Scanned , current Nodes Index , first Value , _ NUM , traversable , next Value Iterator ) ; return results ; }
public  View Ref Render (  View Render <  T > view ) {  Objects . require Non Null ( view ) ; _view = view ; _type = type Of ( view ) ; _priority = priority Of ( view ) ; }
public static void encode Multicast Announcement (  Multicast Announcement announcement ,  Datagram Buffer Factory bufs ) throws  IOException { try {  Linked List groups = new  Linked List ( ) ; groups . add All (  Arrays . as List ( announcement . get Groups ( ) ) ) ; do {  Byte Buffer buf = bufs . new Buffer ( ) ; int slim = buf . limit ( ) ; buf . limit ( slim -  SERVICE_ ID_ LEN ) ; buf . put Long ( announcement . get Sequence Number ( ) ) ; put Utf ( buf , announcement . get Host ( ) ) ; buf . put Short ( int To Ushort ( announcement . get Port ( ) ) ) ; int ngroups = _ NUM ; int ngroups Pos = buf . position ( ) ; buf . put Short ( ( short ) _ NUM ) ; try { while ( ! groups . is Empty ( ) && ngroups <  MAX_ USHORT ) { put Utf ( buf , (  String ) groups . get First ( ) ) ; groups . remove First ( ) ; ngroups ++ ; } } catch (  Buffer Overflow Exception e ) { if ( ngroups == _ NUM ) { throw e ; } } buf . put Short ( ngroups Pos , int To Ushort ( ngroups ) ) ;  Service ID id = announcement . get Service ID ( ) ; buf . limit ( slim ) ; buf . put Long ( id . get Most Significant Bits ( ) ) ; buf . put Long ( id . get Least Significant Bits ( ) ) ; } while ( ! groups . is Empty ( ) ) ; } catch (  Runtime Exception e ) { throw new  Discovery Protocol Exception ( null , e ) ; } }
public void add Property Change Listener (  Property Change Listener listener ) { if ( property Change Support == null ) { property Change Support = new  Property Change Support ( this ) ; } property Change Support . add Property Change Listener ( listener ) ; }
public void remove Policy (  String policy Name ) throws  SSOException ,  No Permission Exception ,  Policy Exception { if ( policy Name == null ) { if ( debug . warning Enabled ( ) ) { debug . warning ( _ STR ) ; } throw ( new  Invalid Name Exception (  Res Bundle Utils . rb Name , _ STR , null , _ STR ,  Policy Exception .  POLICY ) ) ; } try {  Policy Manager . init Admin Subject ( ) ;  Service Config o Config = scm . get Organization Config ( org , null ) ;  Service Config named Policy = ( o Config == null ) ? null : o Config . get Sub Config (  NAMED_ POLICY ) ; if ( named Policy != null ) {  Policy policy = get Policy ( policy Name ) ; named Policy . remove Sub Config ( policy Name ) ; if ( policy != null ) {  Privilege Index Store pis =  Privilege Index Store . get Instance (  Subject Utils . create Super Admin Subject ( ) , get Organization DN ( ) ) ; if ( policy . is Referral Policy ( ) ) { pis . delete Referral ( ( policy Name ) ) ; } else { pis . delete (  Privilege Utils . policy To Privileges ( policy ) ) ; } policy Cache . send Policy Change Notification ( null , policy ,  Service Listener .  REMOVED ) ; } } } catch (  Entitlement Exception e ) { debug . error ( _ STR + e . get Message ( ) ) ; } catch (  Service Not Found Exception snfe ) { debug . error ( _ STR + snfe . get Message ( ) ) ; } catch (  SMSException smse ) {  String objs [ ] = { policy Name , org } ; if (  Policy Utils . log Status ) {  Policy Utils . log Error Message ( _ STR , objs , token ) ; } debug . error ( _ STR + policy Name + _ STR + org , smse ) ; if ( smse . get Exception Code ( ) ==  SMSException .  STATUS_ NO_ PERMISSION ) { throw ( new  No Permission Exception (  Res Bundle Utils . rb Name , _ STR , null ) ) ; } else { throw ( new  Policy Exception (  Res Bundle Utils . rb Name , _ STR , objs , smse ) ) ; } }  String objs [ ] = { policy Name , org } ; if (  Policy Utils . log Status ) {  Policy Utils . log Access Message ( _ STR , objs , token ) ; } }
private void internal Group Snap Copy To Target (  Storage System storage ,  Block Snapshot snapshot ,  List <  URI > snapshot List ) throws  Exception {  String snap Group Name = snapshot . get Replication Group Instance ( ) ;  CIMObject Path target Group = _cim Path . get Replication Group Path ( storage , snap Group Name ) ;  CIMObject Path settings State = _helper . get Settings Define State For Source Group ( storage , snapshot . get Settings Group Instance ( ) ) ;  CIMArgument [ ] in Args = _helper . get VNXCopy To Target Group Input Arguments ( settings State , target Group ) ;  CIMArgument [ ] out Args = new  CIMArgument [ _ NUM ] ; _helper . call Modify Settings Define State ( storage , in Args , out Args ) ;  List <  Block Snapshot > snapshots = _db Client . query Object (  Block Snapshot . class , snapshot List ) ; for (  Block Snapshot it : snapshots ) { it . set Needs Copy To Target ( _ BOOL ) ; } _db Client . persist Object ( snapshots ) ; }
public static long convert String To Time Millis (  String time ) { long result = _ NUM ; if ( time . ends With ( _ STR ) ) { long hours To Add =  Integer . value Of (  String Utils . remove ( time , _ STR ) ) ; result = ( ( _ NUM * _ NUM ) * _ NUM ) * hours To Add ; } else if ( time . ends With ( _ STR ) ) { long mins To Add =  Integer . value Of (  String Utils . remove ( time , _ STR ) ) ; result = ( _ NUM * _ NUM ) * mins To Add ; } else if ( time . ends With ( _ STR ) ) { long secs To Add =  Integer . value Of (  String Utils . remove ( time , _ STR ) ) ; result = _ NUM * secs To Add ; } return result ; }
public void detach ( ) { activity . clear ( ) ; }
public  Xerces HTML2 Document Builder Factory (  Document Builder Setting [ ] settings ) throws  DOMTest Incompatible Exception { super ( settings ) ; try {  Class Loader class Loader =  Class Loader . get System Class Loader ( ) ;  Class html Builder Class = class Loader . load Class ( _ STR ) ; html Builder Constructor = html Builder Class . get Constructor (  NO_ CLASSES ) ; get HTMLDocument Method = html Builder Class . get Method ( _ STR ,  NO_ CLASSES ) ;  Class html DOMImpl = class Loader . load Class ( _ STR ) ;  Method method = html DOMImpl . get Method ( _ STR ,  NO_ CLASSES ) ; dom Impl = (  DOMImplementation ) method . invoke ( null ,  NO_ OBJECTS ) ;  Class sax Factory Class = class Loader . load Class ( _ STR ) ; factory = (  SAXParser Factory ) sax Factory Class . new Instance ( ) ; } catch (  Invocation Target Exception ex ) { throw new  DOMTest Incompatible Exception ( ex . get Target Exception ( ) , null ) ; } catch (  Exception ex ) { throw new  DOMTest Incompatible Exception ( ex , null ) ; } if ( settings != null ) { for ( int i = _ NUM ; i < settings . length ; i ++ ) { } } try { factory . new SAXParser ( ) ; } catch (  Parser Configuration Exception ex ) { throw new  DOMTest Incompatible Exception ( ex , null ) ; } catch (  SAXException ex ) { throw new  DOMTest Incompatible Exception ( ex , null ) ; } }
public void remove From Active List (  Download Info Runnable download Info Runnable ) { m Active List . remove ( download Info Runnable ) ; }
private void end Current Line Of TLA ( ) { if ( tlacode Next Line . length ( ) != _ NUM ) { tlacode . add Element ( tlacode Next Line ) ; mapping Vector . add Element ( mapping Vector Next Line ) ; tlacode Next Line = _ STR ; mapping Vector Next Line = new  Vector ( ) ; } else { if ( mapping Vector Next Line . size ( ) != _ NUM ) {  Vector last Line = (  Vector ) mapping Vector . element At ( mapping Vector . size ( ) - _ NUM ) ; for ( int i = _ NUM ; i < mapping Vector Next Line . size ( ) ; i ++ ) {  Mapping Object obj = (  Mapping Object ) mapping Vector Next Line . element At ( i ) ; if ( obj . get Type ( ) ==  Mapping Object .  RIGHT_ PAREN || obj . get Type ( ) ==  Mapping Object .  LEFT_ PAREN || obj . get Type ( ) ==  Mapping Object .  BREAK ) { last Line . add ( obj ) ; } else {  Pcal Debug .  Report Bug ( _ STR ) ; } mapping Vector Next Line = new  Vector ( ) ; } } } }
private boolean is Word ( final  String str ) { if ( str == null || str . length ( ) == _ NUM ) { return _ BOOL ; } for ( int i = _ NUM ; i < str . length ( ) ; i ++ ) { if ( !  Character . is Java Identifier Part ( str . char At ( i ) ) ) { return _ BOOL ; } } return _ BOOL ; }
private static int index Of Non Digit (  String string , int offset ) { for ( int i = offset ; i < string . length ( ) ; i ++ ) { char c = string . char At ( i ) ; if ( c < _ STR || c > _ STR ) return i ; } return string . length ( ) ; }
public boolean submit No Wake (  Runnable task ,  Class Loader loader ) { boolean is Priority = _ BOOL ; boolean is Queue = _ BOOL ; boolean is Wake = _ BOOL ; return schedule Impl ( task , loader ,  MAX_ EXPIRE , is Priority , is Queue , is Wake ) ; }
static void remove Duplicate Affix (  List <  String > str List , boolean is Suffix ) {  Hash Set <  String > str Set = new  Hash Set <  String > ( str List ) ; str List . clear ( ) ; str List . add All ( str Set ) ; if ( is Suffix ) {  Collections . sort ( str List , null ) ; } else {  Collections . sort ( str List , null ) ; } }
public static double next Double ( ) {  Random random = get Random ( ) ; double value = random . next Double ( ) ; if ( ! _is Test ) _free Random List . free ( random ) ; return value ; }
public void on Range Changed ( ) { m Adapter . set Range ( m Min Date , m Max Date ) ; go To ( m Selected Day . get Time In Millis ( ) , _ BOOL , _ BOOL , _ BOOL ) ; }
public static float run ( double min Seconds ,  Timer Procedure procedure ) { long iter = _ NUM ; long min Millis = ( long ) ( min Seconds * _ NUM ) ; long begin =  System . current Time Millis ( ) ; long limit = begin + min Millis ; while (  System . current Time Millis ( ) < limit ) { procedure . init ( ) ; procedure . apply ( null ) ; iter ++ ; } long end =  System . current Time Millis ( ) ; if ( min Seconds / iter < _ NUM ) { begin =  System . current Time Millis ( ) ; for ( long i = iter ; -- i >= _ NUM ; ) { procedure . init ( ) ; procedure . apply ( null ) ; } end =  System . current Time Millis ( ) ; } long begin2 =  System . current Time Millis ( ) ; int dummy = _ NUM ; for ( long i = iter ; -- i >= _ NUM ; ) { dummy *= i ; procedure . init ( ) ; } long end2 =  System . current Time Millis ( ) ; long elapsed = ( end - begin ) - ( end2 - begin2 ) ; return ( float ) elapsed / _ NUM / iter ; }
public void merge_contents ( ) { if ( contents . length == _ NUM ) return ;  Arrays . sort ( contents ) ;  List <  Call Chain Info > unique_calls = new  Array List <  Call Chain Info > ( ) ; unique_calls . add ( contents [ _ NUM ] ) ; for ( int ii = _ NUM ; ii < contents . length ; ii ++ ) {  Call Chain Info top = unique_calls . get ( unique_calls . size ( ) - _ NUM ) ; if ( contents [ ii ] . method == top . method ) top . merge ( contents [ ii ] ) ; else unique_calls . add ( contents [ ii ] ) ; } logger . info ( _ STR , method , contents . length , unique_calls . size ( ) ) ; contents = unique_calls . to Array ( new  Call Chain Info [ _ NUM ] ) ; }
public  Java Version (  String java Version ) throws  Version Exception { this . java Version = java Version ; int version Delimiters = _ NUM ; int last Index = _ NUM ; while ( ( last Index = java Version . index Of (  VERSION_ DELIMITER , last Index + _ NUM ) ) != - _ NUM ) { version Delimiters ++ ; } int index Update ; if ( version Delimiters == _ NUM ) { index Update = java Version . last Index Of (  VERSION_ DELIMITER ) ; } else { index Update = java Version . index Of (  START_ UPDATE ) ; } int index Identifier = java Version . index Of (  START_ IDENTIFIER ) ;  String version Read = null ;  String update Read = _ STR ;  String identifier Read = null ; if ( index Update == - _ NUM && index Identifier == - _ NUM ) { version Read = java Version ; } else if ( index Update != - _ NUM && index Identifier == - _ NUM ) { version Read = java Version . substring ( _ NUM , index Update ) ; update Read = java Version . substring ( index Update + _ NUM ) ; } else if ( index Update == - _ NUM ) { version Read = java Version . substring ( _ NUM , index Identifier ) ; identifier Read = java Version . substring ( index Identifier + _ NUM ) ; } else { version Read = java Version . substring ( _ NUM , index Update ) ; update Read = java Version . substring ( index Update + _ NUM , index Identifier ) ; identifier Read = java Version . substring ( index Identifier + _ NUM ) ; }  String Tokenizer str Tok = new  String Tokenizer ( version Read , _ STR +  VERSION_ DELIMITER ) ; if ( str Tok . count Tokens ( ) != _ NUM ) { throw new  Version Exception (  Message Format . format ( res . get String ( _ STR ) , java Version ) ) ; }  String major Read = str Tok . next Token ( ) ; try { major =  Integer . parse Int ( major Read ) ; } catch (  Number Format Exception ex ) { throw new  Version Exception (  Message Format . format ( res . get String ( _ STR ) , java Version ) ) ; } if ( major < _ NUM ) { throw new  Version Exception (  Message Format . format ( res . get String ( _ STR ) , java Version ) ) ; }  String middle Read = str Tok . next Token ( ) ; try { middle =  Integer . parse Int ( middle Read ) ; } catch (  Number Format Exception ex ) { throw new  Version Exception (  Message Format . format ( res . get String ( _ STR ) , java Version ) ) ; } if ( middle < _ NUM ) { throw new  Version Exception (  Message Format . format ( res . get String ( _ STR ) , java Version ) ) ; }  String minor Read = str Tok . next Token ( ) ; try { minor =  Integer . parse Int ( minor Read ) ; } catch (  Number Format Exception ex ) { throw new  Version Exception (  Message Format . format ( res . get String ( _ STR ) , java Version ) ) ; } if ( minor < _ NUM ) { throw new  Version Exception (  Message Format . format ( res . get String ( _ STR ) , java Version ) ) ; } try { update =  Integer . parse Int ( update Read ) ; } catch (  Number Format Exception ex ) { throw new  Version Exception (  Message Format . format ( res . get String ( _ STR ) , java Version ) ) ; } if ( update < _ NUM ) { throw new  Version Exception (  Message Format . format ( res . get String ( _ STR ) , java Version ) ) ; } this . identifier = identifier Read ; }
private  List result Set To Array List ( final  List <  Object [ ] > result List ) throws  Application Runtime Exception { final  List list = new  Array List ( ) ;  Label Value Bean label Value Bean = null ;  Big Decimal id ; try { for ( final  Object [ ] obj Arr : result List ) { label Value Bean = new  Label Value Bean ( ) ; id = (  Big Decimal ) obj Arr [ _ NUM ] ; label Value Bean . set Id ( id . int Value ( ) ) ; label Value Bean . set Name ( (  String ) obj Arr [ _ NUM ] ) ; list . add ( label Value Bean ) ; } } catch ( final  Exception e ) {  LOGGER . error ( _ STR , e ) ; throw new  Application Runtime Exception ( _ STR , e ) ; } return list ; }
public double evaluation For Single Instance ( double [ ] dist ,  Instance instance , boolean store Predictions ) throws  Exception { double pred ; if ( m_ Class Is Nominal ) { pred =  Utils . max Index ( dist ) ; if ( dist [ ( int ) pred ] <= _ NUM ) { pred =  Utils . missing Value ( ) ; } update Stats For Classifier ( dist , instance ) ; if ( store Predictions && ! m_ Discard Predictions ) { if ( m_ Predictions == null ) { m_ Predictions = new  Array List <  Prediction > ( ) ; } m_ Predictions . add ( new  Nominal Prediction ( instance . class Value ( ) , dist , instance . weight ( ) ) ) ; } } else { pred = dist [ _ NUM ] ; update Stats For Predictor ( pred , instance ) ; if ( store Predictions && ! m_ Discard Predictions ) { if ( m_ Predictions == null ) { m_ Predictions = new  Array List <  Prediction > ( ) ; } m_ Predictions . add ( new  Numeric Prediction ( instance . class Value ( ) , pred , instance . weight ( ) ) ) ; } } return pred ; }
public boolean accept (  File f ) { if ( f != null ) { if ( f . is Directory ( ) ) { return _ BOOL ; }  String extension = get Extension ( f ) ; if ( ( extension != null ) && ( filters . get ( get Extension ( f ) ) != null ) ) { return _ BOOL ; } } return _ BOOL ; }
@  Override public  Poll Result start Poll (  Poll Controller conn ) { try { boolean is New = conn . enable Keepalive If New ( this ) ; if ( ! enable Keepalive ( conn , is New ) ) { return  Poll Result .  CLOSED ; } if ( conn . to Keepalive Start ( ) ) { _active Count . increment And Get ( ) ; return  Poll Result .  START ; } else { return  Poll Result .  DATA ; } } catch (  IOException e ) { conn . on Poll Read Close ( ) ; throw new  Illegal State Exception ( e ) ; } }
private static  String to String ( double [ ] [ ] m ,  Number Format nf ,  List <  String > variables ) {  String result ; if ( nf == null ) { throw new  Null Pointer Exception ( _ STR ) ; } if ( variables == null ) { variables = new  Array List < > ( ) ; for ( int i = _ NUM ; i < m [ _ NUM ] . length ; i ++ ) { variables . add ( _ STR + ( i + _ NUM ) ) ; } } if ( m == null ) { result = null Message ( ) ; } else {  Text Table text Table = new  Text Table ( m . length + _ NUM , m [ _ NUM ] . length ) ; for ( int i = _ NUM ; i < variables . size ( ) ; i ++ ) { text Table . set Token ( _ NUM , i , variables . get ( i ) ) ; } for ( int i = _ NUM ; i < m . length ; i ++ ) { for ( int j = _ NUM ; j < m [ _ NUM ] . length ; j ++ ) { text Table . set Token ( i + _ NUM , j , m [ i ] [ j ] == _ NUM ? _ STR : nf . format ( m [ i ] [ j ] ) ) ; } } result = _ STR + text Table . to String ( ) ; } return result ; }
public static boolean assert Equals ( final double a , final double b ) { if (  Double . is Na N ( a ) &&  Double . is Na N ( b ) ) { return _ BOOL ; } if ( a == b ) { return _ BOOL ; } throw new  Exam Exception ( a + _ STR + b ) ; }
public  Configure Xml Element Count Dialog_ NB (  Xml Element Count xml Element Count ) { this . xml Element Count = xml Element Count ; init Components ( ) ; configure String List_ NB1 . set Validator ( new  XMLElement Validator ( ) ) ; final  Iterate Model number Of Tags Iterator = xml Element Count . get Number Of Elements Iterator ( ) ; configure Iterate Model_ NB2 . set Start At (  String . value Of ( number Of Tags Iterator . get Start At ( ) ) ) ; configure Iterate Model_ NB2 . set Stop At (  String . value Of ( number Of Tags Iterator . get Stop At ( ) ) ) ; configure Iterate Model_ NB2 . set Increment (  String . value Of ( number Of Tags Iterator . get Increment ( ) ) ) ; configure Iterate Model_ NB2 . set Iterate Strategie ( number Of Tags Iterator . get Iterate Strategie ( ) ) ;  List <  String > elements =  Arrays . as List ( xml Element Count . get Elements ( ) ) ; configure String List_ NB1 . set String List ( elements ) ; }
public final static int log Base2 ( double number ) { int log = _ NUM ; while ( number > _ NUM ) { number =  Math . floor ( number / _ NUM ) ; ++ log ; } return log ; }
public boolean delete Entry (  User user ,  Entry entry ,  String children Action , boolean is Admin ,  List <  String > deleted Entry Ids ,  Errors errors ) {  String original Children Action = children Action ; if ( entry == null ) {  Errors . add ( errors , error Messages . error Entry Is Null ( ) ) ; return _ BOOL ; } if ( user == null ) {  Errors . add ( errors , error Messages . error User Is Null ( ) ) ; return _ BOOL ; } if ( children Action != null && ! children Action . equals ( _ STR ) && ! children Action . equals ( _ STR ) && ! children Action . equals ( _ STR ) ) {  Errors . add ( errors , error Messages . error Children Action Invalid ( ) ) ; return _ BOOL ; } if ( ! can User Modify Entry ( user , entry , is Admin ) ) {  Errors . add ( errors , error Messages . error User Is Not Entitled To Delete ( ) ) ; return _ BOOL ; } final  Entry parent = get Entry By Id ( entry . get Parent Id ( ) ) ; if ( parent == null && children Action != null && children Action . equals ( _ STR ) ) { if ( entry . is Source ( ) || entry . is Quotation ( ) ) { children Action = _ STR ; } else {  Errors . add ( errors , error Messages . error Children Action May Not Be Parent If The Deleted Entry Has No Parent ( ) ) ; return _ BOOL ; } } boolean do Not Update Siblings = _ BOOL ; if ( children Action != null && children Action . equals ( _ STR ) ) { reparent Children ( entry , parent ) ; do Not Update Siblings = _ BOOL ; } if ( parent != null ) { remove Entry From Parent ( entry , parent , do Not Update Siblings ) ; } for (  Object object Child : get Entries By Parent Id ( entry . get Id ( ) ) ) {  Entry child = (  Entry ) object Child ; if ( children Action == null || children Action . equals ( _ STR ) ) { if ( ! delete Entry ( user , child , children Action , is Admin , deleted Entry Ids , errors ) ) { return _ BOOL ; } } else if ( children Action . equals ( _ STR ) ) { child . set Parent Id ( null ) ; child . set Next Sibling Id ( null ) ; child . set Previous Sibling Id ( null ) ; } else if ( children Action . equals ( _ STR ) ) { child . set Parent Id ( parent . get Id ( ) ) ; } } if ( deleted Entry Ids != null ) { deleted Entry Ids . add ( entry . get Id ( ) ) ; } db . remove Entry ( entry ) ; if ( entry . is Notebook ( ) ) {  Entry root Entry = get Entry By Id ( entry . get Root Id ( ) ) ; return delete Entry ( user , root Entry , _ STR , is Admin , deleted Entry Ids , errors ) ; } else if ( entry . is Source ( ) ) { for (  Object object Quotation : get Entries By Source Id ( entry . get Id ( ) , _ NUM ,  Integer .  MAX_ VALUE ) ) {  Entry quotation = (  Entry ) object Quotation ; if ( was Entry Deleted In This Transaction ( quotation ) ) { continue ; } if ( ! delete Entry ( user , quotation , original Children Action , is Admin , deleted Entry Ids , errors ) ) { return _ BOOL ; } } } return _ BOOL ; }
public  Parameter Type File (  String key ,  String description , boolean optional ,  String [ ] extensions ) { super ( key , description , null ) ; set Optional ( optional ) ; this . extensions = extensions ; }
protected int read Block ( ) { block Size = read ( ) ; int n = _ NUM ; if ( block Size > _ NUM ) { try { int count = _ NUM ; while ( n < block Size ) { count = in . read ( block , n , block Size - n ) ; if ( count == - _ NUM ) break ; n += count ; } } catch (  IOException e ) { } if ( n < block Size ) { status =  STATUS_ FORMAT_ ERROR ; } } return n ; }
public void destroy ( ) { for ( int i = _ NUM ; i < runs . size ( ) ; i ++ ) { final  Run run = (  Run ) runs . get ( i ) ; run . destroy ( ) ; } }
@  Override public boolean event Generatable (  String event Name ) { if ( event Name . compare To ( _ STR ) == _ NUM ) { if ( ! ( m_ Loader instanceof weka . core . converters .  Incremental Converter ) ) { return _ BOOL ; } if ( m_data Set Event Targets > _ NUM ) { return _ BOOL ; } } if ( event Name . compare To ( _ STR ) == _ NUM ) { if ( ! ( m_ Loader instanceof weka . core . converters .  Batch Converter ) ) { return _ BOOL ; } if ( m_instance Event Targets > _ NUM ) { return _ BOOL ; } } return _ BOOL ; }
public boolean validate Sensor (  String sensor Name ,  Layout Block blk ,  Component open Frame ) { if ( sensor Name . length ( ) < _ NUM ) { return _ BOOL ; }  Sensor s = blk . validate Sensor ( sensor Name , open Frame ) ; if ( s == null ) { return _ BOOL ; } return _ BOOL ; }
@  Override public void close ( ) throws  IOException {  Socket Channel channel = _channel ; _channel = null ; if ( channel != null ) channel . close ( ) ; }
public  Queued Media Player (  Context context ) { m Context = context ; m Current Player = new  Managed Media Player ( ) ; m Next Player = new  Managed Media Player ( ) ; m Next Player . set Audio Session Id ( m Current Player . get Audio Session Id ( ) ) ; m Current Player . set On Prepared Listener ( this ) ; m Current Player . set On Error Listener ( this ) ; m Current Player . set On Completion Listener ( this ) ; m Next Player . set On Prepared Listener ( this ) ; m Next Player . set On Error Listener ( this ) ; m Next Player . set On Completion Listener ( this ) ; m Queue =  Collections . empty List ( ) ; m Queue Index = _ NUM ; }
public void if Present Or Else (  Consumer < ? super  T > consumer ,  Runnable empty Action ) { if ( value != null ) consumer . accept ( value ) ; else empty Action . run ( ) ; }
protected void send Intensity ( double intensity ) { if ( log . is Debug Enabled ( ) ) { log . debug ( _ STR + intensity + _ STR + _ STR + last Output Step + _ STR + max Dim Step ) ; } int new Step = ( int )  Math . round ( intensity * max Dim Step ) ; if ( ( new Step < _ NUM ) || ( new Step > max Dim Step ) ) { log . error ( _ STR + new Step + _ STR + intensity ) ; } if ( new Step == last Output Step ) { if ( log . is Debug Enabled ( ) ) { log . debug ( _ STR + intensity + _ STR ) ; } return ; } if ( log . is Debug Enabled ( ) ) { log . debug ( _ STR + intensity ) ; }  Insteon Sequence out = new  Insteon Sequence ( ) ; out . add Function ( idhighbyte , idmiddlebyte , idlowbyte ,  Constants .  FUNCTION_ REQ_ STD ,  Constants .  FLAG_ STD ,  Constants .  CMD_ LIGHT_ CHG , new Step ) ; tc . send Insteon Sequence ( out , null ) ; if ( log . is Debug Enabled ( ) ) { log . debug ( _ STR + intensity + _ STR + idhighbyte + idmiddlebyte + idlowbyte + _ STR + new Step ) ; } last Output Step = new Step ; }
public  Socket Address start ( ) throws  Socket Exception { running = _ BOOL ; server = new  Datagram Socket ( ) ; if ( network Monitor != null ) { server = new  Monitor Datagram Socket Wrapper ( server , network Monitor ) ; }  Socket Address socket Address = server . get Local Socket Address ( ) ; thread = new  Thread ( this ) ; thread . start ( ) ; return socket Address ; }
public void delete ( ) throws  IOException { close ( ) ; delete Contents ( directory ) ; }
@  Override public boolean execute ( @  Not Null  Psi Element pe , @  Not Null  Resolve State state ) { if ( pe instanceof  Psi Variable ) { final  Psi Variable pvar = (  Psi Variable ) pe ; final  String pvar_name = pvar . get Name ( ) ; if ( pvar_name . starts With ( my Prefix ) ) { if ( ! my Static Sensitive Flag || ( ! my Static Scope Flag || pvar . has Modifier Property (  Psi Modifier .  STATIC ) ) ) { my Result List . add ( pvar ) ; } } } return _ BOOL ; }
private void write Esc ( char ch [ ] , int start , int length , boolean is Att Val ) throws  SAXException { for ( int i = start ; i < start + length ; i ++ ) { switch ( ch [ i ] ) { case _ STR : write ( _ STR ) ; break ; case _ STR : write ( _ STR ) ; break ; case _ STR : write ( _ STR ) ; break ; case _ STR : if ( is Att Val ) { write ( _ STR ) ; } else { write ( _ STR ) ; } break ; default : if ( ! unicode Mode && ch [ i ] > _ STR ) { write ( _ STR ) ; write (  Integer . to String ( ch [ i ] ) ) ; write ( _ STR ) ; } else { write ( ch [ i ] ) ; } } } }
@  Suppress Warnings ( _ STR ) private void init Time ( ) {  Time time = new  Time (  System . current Time Millis ( ) ) ; int hours = time . get Hours ( ) ; m Hour Single Digits = hours % _ NUM ; m Hour Ten Digits = hours / _ NUM ; int minutes = time . get Minutes ( ) ; m Min Single Digits = minutes % _ NUM ; m Min Ten Digits = minutes / _ NUM ; int seconds = time . get Seconds ( ) ; m Sec Single Digits = seconds % _ NUM ; m Sec Ten Digits = seconds / _ NUM ; }
public  IChat Message send Message2 (  Geoloc geoloc ) throws  Remote Exception { if ( geoloc == null ) { throw new  Server Api Illegal Argument Exception ( _ STR ) ; } if ( ! is Allowed To Send Message ( ) ) { throw new  Server Api Permission Denied Exception ( _ STR ) ; }  String label = geoloc . get Label ( ) ; if ( label != null ) { int label Length = label . length ( ) ; int label Max Length = m Rcs Settings . get Max Geoloc Label Length ( ) ; if ( label Length > label Max Length ) { throw new  Server Api Illegal Argument Exception ( _ STR + label Length + _ STR + label Max Length + _ STR ) ; } } try { long timestamp =  System . current Time Millis ( ) ; final  Chat Message geoloc Msg =  Chat Utils . create Geoloc Message ( null , geoloc , timestamp , timestamp ) ;  Chat Message Persisted Storage Accessor persisted Storage = new  Chat Message Persisted Storage Accessor ( m Messaging Log , geoloc Msg . get Message Id ( ) , geoloc Msg . get Remote Contact ( ) , geoloc Msg . get Content ( ) , geoloc Msg . get Mime Type ( ) , m Chat Id ,  Direction .  OUTGOING ) ; add Outgoing Group Chat Message ( geoloc Msg ,  Content .  Status .  QUEUED ,  Content .  Reason Code .  UNSPECIFIED ) ; if ( ! m Chat Service . is Group Chat Active ( m Chat Id ) ) { m Chat Service . set Group Chat State And Reason Code ( m Chat Id ,  Group Chat .  State .  STARTED ,  Group Chat .  Reason Code .  UNSPECIFIED ) ; } m Im Service . try To Dequeue Group Chat Messages And Group File Transfers ( m Chat Id ) ; return new  Chat Message Impl ( persisted Storage ) ; } catch (  Server Api Base Exception e ) { if ( ! e . should Not Be Logged ( ) ) { s Logger . error (  Exception Util . get Full Stack Trace ( e ) ) ; } throw e ; } catch (  Exception e ) { s Logger . error (  Exception Util . get Full Stack Trace ( e ) ) ; throw new  Server Api Generic Exception ( e ) ; } }
synchronized void remove (  Pg Server Thread t ) { running . remove ( t ) ; }
public void associate (  Node node ) { if ( this . node == null ) { this . node = node ; } }
private void toggle Underlay Image ( ) { if ( enable Bg Image . is Selected ( ) ) {  String img File = null ; int [ ] offsets ; double scale , rotate ;  Buffered Image image ; try {  Settings settings = new  Settings (  UNDERLAY_ NS ) ; img File = settings . get Setting ( _ STR ) ; offsets = settings . get Csv Ints ( _ STR , _ NUM ) ; scale = settings . get Double ( _ STR ) ; rotate = settings . get Double ( _ STR ) ; image =  Image IO . read ( new  File ( img File ) ) ; } catch (  IOException ex ) { warn ( _ STR + img File + _ STR + ex . get Message ( ) ) ; enable Bg Image . set Selected ( _ BOOL ) ; return ; } catch (  Settings Error er ) { warn ( _ STR + er . get Message ( ) ) ; return ; } field . set Underlay Image ( image , offsets [ _ NUM ] , offsets [ _ NUM ] , scale , rotate ) ; } else { field . set Underlay Image ( null , _ NUM , _ NUM , _ NUM , _ NUM ) ; } }
public  License Header Step (  File license File ,  Charset encoding ,  String delimiter ) throws  IOException { this ( new  String (  Files . read All Bytes ( license File . to Path ( ) ) , encoding ) , delimiter ) ; }
@  Nullable public static  Network Parameters from Pmt Protocol ID (  String pmt Protocol Id ) { if ( pmt Protocol Id . equals (  PAYMENT_ PROTOCOL_ ID_ MAINNET ) ) { return  Main Net Params . get ( ) ; } else if ( pmt Protocol Id . equals (  PAYMENT_ PROTOCOL_ ID_ TESTNET ) ) { return  Test Net3 Params . get ( ) ; } else { return null ; } }
private void read From Version2 Stream (  Status From Bytes Stream dis ) throws  IOException {  String url String = dis . read UTF ( ) ; if ( url String . equals ( _ STR ) ) { url = null ; } else { url = url String ; } last Changed Revision = dis . read Long ( ) ; last Changed Date = dis . read Long ( ) ;  String last Commit Author String = dis . read UTF ( ) ; if ( ( url == null ) || ( last Commit Author String . equals ( _ STR ) ) ) { last Commit Author = null ; } else { last Commit Author = last Commit Author String ; } text Status = dis . read Int ( ) ; prop Status = dis . read Int ( ) ; set Revision Number ( dis . read Long ( ) ) ; node Kind = dis . read Int ( ) ; }
public  Rect update Fast Scroller Bounds ( int last Touch Y ) { m Invalidate Rect . set ( m Bg Bounds ) ; if ( is Visible ( ) ) { int edge Padding = m Rv . get Max Scrollbar Width ( ) ; int bg Padding = ( m Bg Original Size - m Text Bounds . height ( ) ) / _ NUM ; int bg Height = m Bg Original Size ; int bg Width =  Math . max ( m Bg Original Size , m Text Bounds . width ( ) + ( _ NUM * bg Padding ) ) ; if (  Utilities . is Rtl ( m Res ) ) { m Bg Bounds . left = m Rv . get Background Padding ( ) . left + ( _ NUM * m Rv . get Max Scrollbar Width ( ) ) ; m Bg Bounds . right = m Bg Bounds . left + bg Width ; } else { m Bg Bounds . right = m Rv . get Width ( ) - m Rv . get Background Padding ( ) . right - ( _ NUM * m Rv . get Max Scrollbar Width ( ) ) ; m Bg Bounds . left = m Bg Bounds . right - bg Width ; } m Bg Bounds . top = last Touch Y - ( int ) (  FAST_ SCROLL_ OVERLAY_ Y_ OFFSET_ FACTOR * bg Height ) ; m Bg Bounds . top =  Math . max ( edge Padding ,  Math . min ( m Bg Bounds . top , m Rv . get Height ( ) - edge Padding - bg Height ) ) ; m Bg Bounds . bottom = m Bg Bounds . top + bg Height ; } else { m Bg Bounds . set Empty ( ) ; } m Invalidate Rect . union ( m Bg Bounds ) ; return m Invalidate Rect ; }
public  DNetscape Ca Policy Url (  JDialog parent , byte [ ] value ) throws  IOException { super ( parent ) ; set Title ( res . get String ( _ STR ) ) ; init Components ( ) ; prepopulate With Value ( value ) ; }
public boolean textbox Key Typed ( char p_146201_1_ , int p_146201_2_ ) { if ( ! field_146213_o ) return _ BOOL ; else switch ( p_146201_1_ ) { case _ NUM : func_146202_e ( ) ; func_146199_i ( _ NUM ) ; return _ BOOL ; case _ NUM :  Gui Screen . set Clipboard String ( func_146207_c ( ) ) ; return _ BOOL ; case _ NUM : if ( field_146226_p ) func_146191_b (  Gui Screen . get Clipboard String ( ) ) ; return _ BOOL ; case _ NUM :  Gui Screen . set Clipboard String ( func_146207_c ( ) ) ; if ( field_146226_p ) func_146191_b ( _ STR ) ; return _ BOOL ; default : switch ( p_146201_2_ ) { case _ NUM : if (  Gui Screen . is Ctrl Key Down ( ) ) { if ( field_146226_p ) func_146177_a ( - _ NUM ) ; } else if ( field_146226_p ) func_146175_b ( - _ NUM ) ; return _ BOOL ; case _ NUM : if (  Gui Screen . is Shift Key Down ( ) ) func_146199_i ( _ NUM ) ; else func_146196_d ( ) ; return _ BOOL ; case _ NUM : if (  Gui Screen . is Shift Key Down ( ) ) { if (  Gui Screen . is Ctrl Key Down ( ) ) func_146199_i ( func_146183_a ( - _ NUM , func_146186_n ( ) ) ) ; else func_146199_i ( func_146186_n ( ) - _ NUM ) ; } else if (  Gui Screen . is Ctrl Key Down ( ) ) func_146190_e ( func_146187_c ( - _ NUM ) ) ; else func_146182_d ( - _ NUM ) ; return _ BOOL ; case _ NUM : if (  Gui Screen . is Shift Key Down ( ) ) { if (  Gui Screen . is Ctrl Key Down ( ) ) func_146199_i ( func_146183_a ( _ NUM , func_146186_n ( ) ) ) ; else func_146199_i ( func_146186_n ( ) + _ NUM ) ; } else if (  Gui Screen . is Ctrl Key Down ( ) ) func_146190_e ( func_146187_c ( _ NUM ) ) ; else func_146182_d ( _ NUM ) ; return _ BOOL ; case _ NUM : if (  Gui Screen . is Shift Key Down ( ) ) func_146199_i ( field_146216_j . length ( ) ) ; else func_146202_e ( ) ; return _ BOOL ; case _ NUM : if (  Gui Screen . is Ctrl Key Down ( ) ) { if ( field_146226_p ) func_146177_a ( _ NUM ) ; } else if ( field_146226_p ) func_146175_b ( _ NUM ) ; return _ BOOL ; default : if (  Chat Allowed Characters . is Allowed Character ( p_146201_1_ ) ) { if ( field_146226_p ) func_146191_b (  Character . to String ( p_146201_1_ ) ) ; return _ BOOL ; } else return _ BOOL ; } } }
@  Nullable public static  File find Executable File (  File parent ,  String name ) { if (  System Info . is Windows ||  System Info . is OS2 ) { for (  String suffix :  WINDOWS_ EXECUTABLE_ SUFFIXES ) {  File file = new  File ( parent , name + _ STR + suffix ) ; if ( file . exists ( ) ) return file ; } } else if (  System Info . is Unix ) {  File file = new  File ( parent , name ) ; if ( file . exists ( ) ) return file ; } return null ; }
public static boolean is Windows7 ( ) { return os Name . index Of ( _ STR ) > - _ NUM && os Version . equals ( _ STR ) ; }
public boolean one Outgoing Transition Leaves Composite With Exit Actions (  State state ) {  Set <  State > source Parent States = new  Hash Set <  State > ( get Parent States ( state ) ) ; for (  Transition transition : state . get Outgoing Transitions ( ) ) {  Set <  State > target Parent States = get Parent States ( transition . get Target ( ) ) ;  Set <  State > crossed States = new  Hash Set <  State > ( source Parent States ) ; crossed States . remove All ( target Parent States ) ; for (  State crossed Composite State : crossed States ) { if ( has Exit Action ( crossed Composite State ) ) return _ BOOL ; } } return _ BOOL ; }
private void recycle Children (  Recycler View .  Recycler recycler , int start Index , int end Index ) { if ( start Index == end Index ) { return ; } if (  DEBUG ) {  Log . d (  TAG , _ STR +  Math . abs ( start Index - end Index ) + _ STR ) ; } if ( end Index > start Index ) { for ( int i = end Index - _ NUM ; i >= start Index ; i -- ) { remove And Recycle View At ( i , recycler ) ; } } else { for ( int i = start Index ; i > end Index ; i -- ) { remove And Recycle View At ( i , recycler ) ; } } }
@  Override public  List <  Proxy > select (  URI uri ) {  Array List <  Proxy > proxies = new  Array List <  Proxy > ( ) ; proxies . add (  Proxy .  NO_ PROXY ) ; return proxies ; }
public void add Externs (  String [ ] definitions ) { add Strings (  EXTERNS , definitions ) ; add Strings ( linker_more ,  EXTERNS , definitions ) ; new Linker Options After Compile . add (  EXTERNS ) ; }
public  Vcf Record next ( ) throws  IOException { if ( m Current . size ( ) == _ NUM ) { throw new  Illegal State Exception ( _ STR ) ; } final  Vcf Record rec = m Current . poll ( ) ; set Next ( ) ; return rec ; }
public  LDIFChange Record Reader ( final  String ... ldif Lines ) { super (  Arrays . as List ( ldif Lines ) ) ; }
public  Icicle Redis Response ( final  List <  Long > results ) {  Preconditions . check Not Null ( results ) ; this . start Sequence = results . get (  START_ SEQUENCE_ INDEX ) ; this . end Sequence = results . get (  END_ SEQUENCE_ INDEX ) ; this . logical Shard Id = results . get (  LOGICAL_ SHARD_ ID_ INDEX ) ; this . time Seconds = results . get (  TIME_ SECONDS_ INDEX ) ; this . time Microseconds = results . get (  TIME_ MICROSECONDS_ INDEX ) ; }
public  License Header Step (  String license ,  String delimiter ) { if ( delimiter . contains ( _ STR ) ) { throw new  Gradle Exception ( _ STR ) ; } license =  Line Ending . to Unix ( license ) ; if ( ! license . ends With ( _ STR ) ) { license = license + _ STR ; } this . license = license ; this . delimiter Pattern =  Pattern . compile ( _ STR + delimiter ,  Pattern .  UNIX_ LINES |  Pattern .  MULTILINE ) ; }
public void add Field (  XTIFFField field ) { field Index . put ( new  Integer ( field . tag ) , field ) ; }
public static final  Geo Time Serie sub Serie (  Geo Time Serie gts , long starttimestamp , long stoptimestamp , boolean overwrite , boolean copy Labels ,  Geo Time Serie subgts ) { if ( null == subgts ) { subgts = new  Geo Time Serie ( _ NUM ) ; subgts . set Name ( gts . get Name ( ) ) ; if ( copy Labels ) { subgts . set Labels ( gts . get Labels ( ) ) ; } } else {  GTSHelper . reset ( subgts ) ; } if ( null == gts . ticks || _ NUM == gts . values ) { return subgts ; }  GTSHelper . sort ( gts ) ; int lastidx =  Arrays . binary Search ( gts . ticks , _ NUM , gts . values , stoptimestamp ) ; if ( - _ NUM == lastidx ) { return subgts ; } else if ( lastidx < _ NUM ) { lastidx = - lastidx - _ NUM ; if ( lastidx >= gts . values ) { lastidx = gts . values - _ NUM ; } } int firstidx =  Arrays . binary Search ( gts . ticks , _ NUM , lastidx + _ NUM , starttimestamp ) ; if ( firstidx < _ NUM ) { firstidx = - firstidx - _ NUM ; } if ( firstidx >= gts . values ) { return subgts ; } for ( int i = firstidx ; i <= lastidx ; i ++ ) { if ( gts . ticks [ i ] >= starttimestamp && gts . ticks [ i ] <= stoptimestamp ) { set Value ( subgts , gts . ticks [ i ] , null != gts . locations ? gts . locations [ i ] :  Geo Time Serie .  NO_ LOCATION , null != gts . elevations ? gts . elevations [ i ] :  Geo Time Serie .  NO_ ELEVATION , value At Index ( gts , i ) , overwrite ) ; } } return subgts ; }
public  List <  String > message Comments (  Message Type msg ,  Python Import Handler import Handler ) {  String Builder param Types Builder = new  String Builder ( ) ; param Types Builder . append ( _ STR ) ; for (  Field field : msg . get Fields ( ) ) { param Types Builder . append ( field Comment ( field . get Simple Name ( ) , field , import Handler , null ) ) ; }  String param Types = param Types Builder . to String ( ) ;  String Builder content Builder = new  String Builder ( ) ; if ( msg . has Attribute (  Element Documentation Attribute .  KEY ) ) { content Builder . append ( get Sphinxified Scoped Description ( msg ) ) ; if ( !  Strings . is Null Or Empty ( param Types ) ) { content Builder . append ( _ STR ) ; } } content Builder . append ( param Types ) ; return python Common . convert To Commented Block ( content Builder . to String ( ) ) ; }
public static final void write Boolean Array Xml ( boolean [ ] val ,  String name ,  Xml Serializer out ) throws  Xml Pull Parser Exception ,  IOException { if ( val == null ) { out . start Tag ( null , _ STR ) ; out . end Tag ( null , _ STR ) ; return ; } out . start Tag ( null , _ STR ) ; if ( name != null ) { out . attribute ( null , _ STR , name ) ; } final int  N = val . length ; out . attribute ( null , _ STR ,  Integer . to String (  N ) ) ; for ( int i = _ NUM ; i <  N ; i ++ ) { out . start Tag ( null , _ STR ) ; out . attribute ( null , _ STR ,  Boolean . to String ( val [ i ] ) ) ; out . end Tag ( null , _ STR ) ; } out . end Tag ( null , _ STR ) ; }
protected  Rewritten Outbound Url process Encode URL (  Http Servlet Response hs Response ,  Http Servlet Request hs Request , boolean encode Url Has Been Run ,  String outbound Url ) { if ( log . is Debug Enabled ( ) ) { log . debug ( _ STR + outbound Url ) ; } if ( outbound Url == null ) { return new  Rewritten Outbound Url ( null , _ BOOL ) ; } boolean final Encode Outbound Url = _ BOOL ;  String final To Url = outbound Url ; final  List outbound Rules = conf . get Outbound Rules ( ) ; try { for ( int i = _ NUM ; i < outbound Rules . size ( ) ; i ++ ) { final  Outbound Rule outbound Rule = (  Outbound Rule ) outbound Rules . get ( i ) ; if ( ! encode Url Has Been Run && outbound Rule . is Encode First ( ) ) { continue ; } if ( encode Url Has Been Run && ! outbound Rule . is Encode First ( ) ) { continue ; } final  Rewritten Outbound Url rewritten Url = outbound Rule . execute ( final To Url , hs Request , hs Response ) ; if ( rewritten Url != null ) { if ( log . is Debug Enabled ( ) ) { log . debug ( _ STR + outbound Rule . get Display Name ( ) + _ STR ) ; } final To Url = rewritten Url . get Target ( ) ; final Encode Outbound Url = rewritten Url . is Encode ( ) ; if ( outbound Rule . is Last ( ) ) { log . debug ( _ STR ) ; break ; } } } } catch (  Invocation Target Exception e ) { try { handle Invocation Target Exception ( hs Request , hs Response , e ) ; } catch (  Servlet Exception e1 ) { log . error ( e1 ) ; } catch (  IOException e1 ) { log . error ( e1 ) ; } } return new  Rewritten Outbound Url ( final To Url , final Encode Outbound Url ) ; }
public  Amqp Client (  URI remote URI ,  String username ,  String password ) { this . remote URI = remote URI ; this . password = password ; this . username = username ; }
protected void add Flags ( int flags ) { this . status |= ( flags & ~  KIND_ MASK ) ; }
public static boolean contains Key (  Key Store key Store ) throws  Crypto Exception { try {  Enumeration <  String > aliases = key Store . aliases ( ) ; while ( aliases . has More Elements ( ) ) {  String alias = aliases . next Element ( ) ; if ( is Key Entry ( alias , key Store ) ) { return _ BOOL ; } } return _ BOOL ; } catch (  Key Store Exception ex ) { throw new  Crypto Exception ( res . get String ( _ STR ) , ex ) ; } }
void purge Orphaned Articles ( ) { if ( ! is DBAvailable ( ) ) return ; long time =  System . current Time Millis ( ) ; safely Delete Articles ( _ STR +  TABLE_ FEEDS + _ STR , null ) ;  Log . d (  TAG , _ STR + (  System . current Time Millis ( ) - time ) + _ STR ) ; }
public void reclaim Views (  List <  View > views ) { int child Count = get Child Count ( ) ;  Recycler Listener listener = m Recycler . m Recycler Listener ; for ( int i = _ NUM ; i < child Count ; i ++ ) {  View child = get Child At ( i ) ;  PLA_ Abs List View .  Layout Params lp = (  PLA_ Abs List View .  Layout Params ) child . get Layout Params ( ) ; if ( lp != null && m Recycler . should Recycle View Type ( lp . view Type ) ) { views . add ( child ) ; if ( listener != null ) { listener . on Moved To Scrap Heap ( child ) ; } } } m Recycler . reclaim Scrap Views ( views ) ; remove All Views In Layout ( ) ; }
@  Suppress Warnings ( _ STR ) @  Deprecated private static  Template Sequence Model to Simple Sequence (  Template Model object ,  Object Wrapper object Wrapper ) throws  Template Model Exception { if ( object instanceof  Template Sequence Model ) { return (  Template Sequence Model ) object ; } else if ( object instanceof  Wrapper Template Model ) {  Wrapper Template Model wrapper Model = (  Wrapper Template Model ) object ;  Object wrapped Object = wrapper Model . get Wrapped Object ( ) ; if ( wrapped Object instanceof  List ) { return  Default List Adapter . adapt ( (  List <  Object > ) wrapped Object , (  Rich Object Wrapper ) object Wrapper ) ; } else if ( wrapped Object instanceof  Object [ ] ) { return  Default Array Adapter . adapt ( (  Object [ ] ) wrapped Object , (  Object Wrapper And Unwrapper ) object Wrapper ) ; } else if ( wrapped Object instanceof  Set ) { throw new  Unsupported Operation Exception ( _ STR ) ; } else if ( wrapped Object instanceof  Collection ) { throw new  Unsupported Operation Exception ( _ STR ) ; } else if ( wrapped Object instanceof  Iterable ) { throw new  Unsupported Operation Exception ( _ STR ) ; } else { throw new  Template Model Exception ( _ STR + ( object != null ? object . get Class ( ) : _ STR ) + _ STR ) ; } } else if ( object instanceof  Template Collection Model ) {  Template Collection Model coll Model = (  Template Collection Model ) object ;  Simple Sequence res = new  Simple Sequence ( object Wrapper ) ;  Template Model Iterator it = coll Model . iterator ( ) ; while ( it . has Next ( ) ) { res . add ( it . next ( ) ) ; } return res ; } else { throw new  Template Model Exception ( _ STR + ( object != null ? object . get Class ( ) : _ STR ) + _ STR ) ; } }
@  Override public void paint (  Graphics g ) { super . paint ( g ) ; paint Empty Rows ( g ) ; }
public static double min ( final double a , final double b ) { if ( a > b ) { return b ; } if ( a < b ) { return a ; } if ( a != b ) { return  Double .  Na N ; } long bits =  Double . double To Raw Long Bits ( a ) ; if ( bits == _ NUM ) { return a ; } return b ; }
private boolean serialize Compact RDFAttr Props (  XMPNode parent Node , int indent ) throws  IOException { boolean all Are Attrs = _ BOOL ; for (  Iterator it = parent Node . iterate Children ( ) ; it . has Next ( ) ; ) {  XMPNode prop = (  XMPNode ) it . next ( ) ; if ( can Be RDFAttr Prop ( prop ) ) { write Newline ( ) ; write Indent ( indent ) ; write ( prop . get Name ( ) ) ; write ( _ STR ) ; append Node Value ( prop . get Value ( ) , _ BOOL ) ; write ( _ STR ) ; } else { all Are Attrs = _ BOOL ; } } return all Are Attrs ; }
public static  Pair <  Integer ,  Boolean > show Yes No Question With Checkbox ( final  Component parent , final  String msg , final  String check Box Title ) {  JCheck Box checkbox = null ;  Object params ; if ( check Box Title != null ) { checkbox = new  JCheck Box ( check Box Title ) ; params = new  Object [ ] { msg , checkbox } ; } else { params = msg ; } final int option =  JOption Pane . show Confirm Dialog ( is Iconified ( parent ) ? null : parent , params ,  System . get Property (  DEFAULT_ WINDOW_ TITLE_ PROPERTY ) ,  JOption Pane .  YES_ NO_ OPTION ,  JOption Pane .  QUESTION_ MESSAGE ) ; return  Pair . make ( option , check Box Title != null ? checkbox . is Selected ( ) : _ BOOL ) ; }
public void pop ( ) { state = (  Graphics State ) stack . pop ( ) ; set Transform ( state . xform ) ; set Clip ( state . cliprgn ) ; }
public static void drop Index (  Connection conn ,  String schema ,  String table ) throws  SQLException { init ( conn ) ;  Prepared Statement prep = conn . prepare Statement ( _ STR +  SCHEMA + _ STR ) ; prep . set String ( _ NUM , schema ) ; prep . set String ( _ NUM , table ) ; int row Count = prep . execute Update ( ) ; if ( row Count == _ NUM ) { return ; } reindex ( conn ) ; }
public synchronized int index Of (  IAudio Processor processor ) { return processors . index Of ( processor ) ; }
public static void append Fin And Op Code (  Byte Buffer buffer , byte opcode , boolean fin ) { byte b = _ NUM ; if ( fin ) { b |= _ NUM ; } b |= opcode & _ NUM ; buffer . put ( b ) ; }
public void initialize (  Map config Params ) {  String delimiter Config = (  String ) config Params . get (  Resource Match .  RESOURCE_ COMPARATOR_ DELIMITER ) ; if ( delimiter Config != null ) { this . delimiter = delimiter Config ; }  String case Config = (  String ) config Params . get (  Resource Match .  RESOURCE_ COMPARATOR_ CASE_ SENSITIVE ) ; if ( case Config != null ) { if ( case Config . equals ( _ STR ) ) { this . case Sensitive = _ BOOL ; } else if ( case Config . equals ( _ STR ) ) { this . case Sensitive = _ BOOL ; } else { this . case Sensitive = _ BOOL ; } }  String wildcard Config = (  String ) config Params . get (  Resource Match .  RESOURCE_ COMPARATOR_ WILDCARD ) ; if ( wildcard Config != null ) { this . wildcard = wildcard Config ; }  String one Level Wildcard Config = (  String ) config Params . get (  Resource Match .  RESOURCE_ COMPARATOR_ ONE_ LEVEL_ WILDCARD ) ; if ( one Level Wildcard Config != null ) { this . one Level Wildcard = one Level Wildcard Config ; } if ( debug . message Enabled ( ) ) { debug . message ( _ STR + _ STR + delimiter + _ STR + wildcard + _ STR + one Level Wildcard + _ STR + case Config ) ; } one Level Wildcard Length = one Level Wildcard . length ( ) ; wildcard Length = wildcard . length ( ) ; if ( one Level Wildcard . index Of ( wildcard ) != - _ NUM ) { wildcard Embedded = _ BOOL ; } else { wildcard Embedded = _ BOOL ; } if ( wildcard . index Of ( one Level Wildcard ) != - _ NUM ) { one Level Wildcard Embedded = _ BOOL ; } else { one Level Wildcard Embedded = _ BOOL ; } if ( debug . message Enabled ( ) ) { debug . message ( _ STR + wildcard Embedded + _ STR + one Level Wildcard Embedded ) ; } return ; }
public static boolean is SSH (  String uri ) { return uri != null && uri . starts With ( _ STR ) ; }
protected boolean compare And Set State (  State Type old State ,  State Type new State ) { if ( state . compare And Set ( old State , new State ) ) { after State Changed ( new State ) ; return _ BOOL ; } else return _ BOOL ; }
private boolean parse Autolink ( ) {  String m ; if ( ( m = match (  EMAIL_ AUTOLINK ) ) != null ) {  String dest = m . substring ( _ NUM , m . length ( ) - _ NUM ) ;  Link node = new  Link ( _ STR + dest , null ) ; node . append Child ( new  Text ( dest ) ) ; append Node ( node ) ; return _ BOOL ; } else if ( ( m = match (  AUTOLINK ) ) != null ) {  String dest = m . substring ( _ NUM , m . length ( ) - _ NUM ) ;  Link node = new  Link ( dest , null ) ; node . append Child ( new  Text ( dest ) ) ; append Node ( node ) ; return _ BOOL ; } else { return _ BOOL ; } }
private static void insert Comments In Cu (  Compilation Unit cu ,  Comments Collection comments Collection ) { if ( comments Collection . size ( ) == _ NUM ) return ;  List <  Comment > comments = comments Collection . get All ( ) ;  Position Utils . sort By Begin Position ( comments ) ;  List <  Node > children = cu . get Children Nodes ( ) ;  Position Utils . sort By Begin Position ( children ) ; if ( cu . get Package ( ) != null && ( children . size ( ) == _ NUM ||  Position Utils . are In Order ( comments . get ( _ NUM ) , children . get ( _ NUM ) ) ) ) { cu . set Comment ( comments . get ( _ NUM ) ) ; comments . remove ( _ NUM ) ; } insert Comments In Node ( cu , comments ) ; }
public  Configurator from File (  File file ) { if ( ! file . exists ( ) ) { throw new  File Not Found Exception ( file . get Absolute Path ( ) + _ STR ) ; } return new  Configurator ( file . get Absolute Path ( ) , _ BOOL ) ; }
public synchronized void check Access (  License Checker Callback callback ) { if ( m Policy . allow Access ( ) ) {  Log . i (  TAG , _ STR ) ; callback . allow (  Policy .  LICENSED ) ; } else {  License Validator validator = new  License Validator ( m Policy , new  Null Device Limiter ( ) , callback , generate Nonce ( ) , m Package Name , m Version Code ) ; if ( m Service == null ) {  Log . i (  TAG , _ STR ) ; try { boolean bind Result = m Context . bind Service ( new  Intent ( _ STR ) , this ,  Context .  BIND_ AUTO_ CREATE ) ; if ( bind Result ) { m Pending Checks . offer ( validator ) ; } else {  Log . e (  TAG , _ STR ) ; handle Service Connection Error ( validator ) ; } } catch (  Exception e ) { callback . application Error (  License Checker Callback .  ERROR_ MISSING_ PERMISSION ) ; } } else { m Pending Checks . offer ( validator ) ; run Checks ( ) ; } } }
public  Track (  Context context ) { track = new  Array List <  Track Point > ( ) ; ctx = context ; if ( is Open ) { mark Saving Broken ( _ STR , null ) ; } else { is Open = _ BOOL ;  Log . i (  TAG , _ STR ) ; async Load ( ) ; } }
protected static  String [ ] split String By Delimiter Points (  String s Str ,  Integer [ ] i Res ) {  Array List al Res = new  Array List ( ) ; for ( int i Cnt = _ NUM ; i Cnt < i Res . length ; i Cnt ++ ) { if ( i Cnt == _ NUM ) al Res . add ( s Str . substring ( _ NUM , i Res [ i Cnt ] ) ) ; else al Res . add ( s Str . substring ( i Res [ i Cnt - _ NUM ] , i Res [ i Cnt ] ) ) ; } if ( i Res . length > _ NUM ) al Res . add ( s Str . substring ( i Res [ i Res . length - _ NUM ] ) ) ; else al Res . add ( s Str ) ;  String [ ] s Res = new  String [ al Res . size ( ) ] ; al Res . to Array ( s Res ) ; return s Res ; }
private static  String escape JSON (  String text ) {  String Builder builder = new  String Builder ( ) ; builder . append ( _ STR ) ; for ( int index = _ NUM ; index < text . length ( ) ; index ++ ) { char chr = text . char At ( index ) ; switch ( chr ) { case _ STR : case _ STR : builder . append ( _ STR ) ; builder . append ( chr ) ; break ; case _ STR : builder . append ( _ STR ) ; break ; case _ STR : builder . append ( _ STR ) ; break ; case _ STR : builder . append ( _ STR ) ; break ; case _ STR : builder . append ( _ STR ) ; break ; default : if ( chr < _ STR ) {  String t = _ STR +  Integer . to Hex String ( chr ) ; builder . append ( _ STR + t . substring ( t . length ( ) - _ NUM ) ) ; } else { builder . append ( chr ) ; } break ; } } builder . append ( _ STR ) ; return builder . to String ( ) ; }
public void clear Results ( ) { m_ Results . clear ( ) ; m_ Model . clear ( ) ; m_ Objs . clear ( ) ;  System . gc ( ) ; }
public static int desaturate ( int c ) { int a = c & _ NUM ; float r = ( ( c & _ NUM ) > > _ NUM ) ; float g = ( ( c & _ NUM ) > > _ NUM ) ; float b = ( c & _ NUM ) ; r *= _ NUM ; g *= _ NUM ; b *= _ NUM ; int gray =  Math . min ( ( ( int ) ( r + g + b ) ) , _ NUM ) & _ NUM ; return a | ( gray << _ NUM ) | ( gray << _ NUM ) | gray ; }
public void start ( ) { if ( dependencies . is Empty ( ) ) {  EXECUTOR . execute ( make Wrapper ( ) ) ; } else { boolean blocked = _ BOOL ; synchronized (  LOCK ) { blocked = is Blocked By Dependencies ( ) ; } if ( ! blocked ) {  EXECUTOR . execute ( make Wrapper ( ) ) ; } else { synchronized (  LOCK ) { queued Threads . add ( this ) ; } task Queued ( this ) ; } } }
public  Serial Message ( byte [ ] a , int l ) { super (  String . value Of ( a ) ) ; set Response Length ( l ) ; set Binary ( _ BOOL ) ; }
@  Override @  Suppress Warnings ( _ STR ) public void completed ( int bytes Transferred , boolean can Invoke Direct ) { update Buffers ( bytes Transferred ) ; release Buffers ( ) ; synchronized ( result ) { if ( result . is Done ( ) ) return ; enable Writing ( ) ; if ( gathering Write ) { result . set Result ( (  V )  Long . value Of ( bytes Transferred ) ) ; } else { result . set Result ( (  V )  Integer . value Of ( bytes Transferred ) ) ; } } if ( can Invoke Direct ) {  Invoker . invoke Unchecked ( result ) ; } else {  Invoker . invoke ( result ) ; } }
public void write Golomb ( int divisor , int value ) throws  IOException { int q = value / divisor ; for ( int i = _ NUM ; i < q ; i ++ ) { write Bit ( _ BOOL ,  MAX_ PROBABILITY / _ NUM ) ; } write Bit ( _ BOOL ,  MAX_ PROBABILITY / _ NUM ) ; int r = value - q * divisor ; int bit = _ NUM -  Integer . number Of Leading Zeros ( divisor - _ NUM ) ; if ( r < ( ( _ NUM << bit ) - divisor ) ) { bit -- ; } else { r += ( _ NUM << bit ) - divisor ; } for ( ; bit >= _ NUM ; bit -- ) { write Bit ( ( ( r > > > bit ) & _ NUM ) == _ NUM ,  MAX_ PROBABILITY / _ NUM ) ; } }
private static  Metric Value duration_to_metricvalue_ (  Duration duration ) { return  Metric Value . from Int Value ( duration . get Millis ( ) ) ; }
public  T reverse ( ) {  String id = get Id ( ) ;  String  REVERSE = _ STR ; if ( id . ends With (  REVERSE ) ) { set Id ( id . substring ( _ NUM , id . length ( ) -  REVERSE . length ( ) ) ) ; } float start = m Start ; float end = m End ; m Start = end ; m End = start ; m Reverse = ! m Reverse ; return self ( ) ; }
public static boolean assert Equals ( final double a , final double b ) { if (  Double . is Na N ( a ) &&  Double . is Na N ( b ) ) { return _ BOOL ; } if ( a == b ) { return _ BOOL ; } throw new  Exam Exception ( a + _ STR + b ) ; }
protected void prepare ( ) { for (  Process Info Parameter para : get Parameter ( ) ) {  String name = para . get Parameter Name ( ) ; if ( para . get Parameter ( ) == null ) ; else if ( name . equals (  X_ M_ Product .  COLUMNNAME_ M_ Product_ ID ) ) { p_ M_ Product_ ID = para . get Parameter As Int ( ) ; } else if ( name . equals (  X_ M_ Warehouse .  COLUMNNAME_ M_ Warehouse_ ID ) ) { p_ M_ Warehouse_ ID = para . get Parameter As Int ( ) ; } else if ( name . equals ( _ STR ) ) { p_ Date Trx = (  Timestamp ) para . get Parameter ( ) ; } else if ( name . equals (  X_ PP_ Order_ BOMLine .  COLUMNNAME_ Qty Required ) ) { p_ Qty Requiered = (  Big Decimal ) para . get Parameter ( ) ; } else if ( name . equals (  X_ PP_ Product_ BOMLine .  COLUMNNAME_ Backflush Group ) ) { p_ Backflush Group = (  String ) para . get Parameter ( ) ; } else if ( name . equals (  X_ T_ BOMLine .  COLUMNNAME_ Level No ) ) { p_ Level No = para . get Parameter As Int ( ) ; } else log . log (  Level .  SEVERE , _ STR + name ) ; } }
public static boolean is Truncated (  Content content ) { byte [ ] content Bytes = content . get Content ( ) ; if ( content Bytes == null ) return _ BOOL ;  Metadata metadata = content . get Metadata ( ) ; if ( metadata == null ) return _ BOOL ;  String length Str = metadata . get (  Response .  CONTENT_ LENGTH ) ; if ( length Str != null ) length Str = length Str . trim ( ) ; if (  String Util . is Empty ( length Str ) ) { return _ BOOL ; } int in Header Size ;  String url = content . get Url ( ) ; try { in Header Size =  Integer . parse Int ( length Str ) ; } catch (  Number Format Exception e ) {  LOG . warn ( _ STR + url , e ) ; return _ BOOL ; } int actual Size = content Bytes . length ; if ( in Header Size > actual Size ) {  LOG . info ( url + _ STR + in Header Size + _ STR + actual Size ) ; return _ BOOL ; } if (  LOG . is Debug Enabled ( ) ) {  LOG . debug ( url + _ STR + actual Size + _ STR + in Header Size ) ; } return _ BOOL ; }
private static void  Release String Critical (  JNIEnvironment env , int str JREF ,  Address carray ) { if ( trace JNI )  VM . sys Write ( _ STR ) ;  Runtime Entrypoints . check JNICount Down To GC ( ) ; try {  VM . enable GC ( _ BOOL ) ; } catch (  Throwable unexpected ) { if ( trace JNI ) unexpected . print Stack Trace (  System . err ) ; env . record Exception ( unexpected ) ; } }
public void make Backup File (  String name ) {  File file = find File ( name ) ; if ( file == null ) { log . info ( _ STR + name + _ STR ) ; } else if ( file . can Write ( ) ) {  String backup Name = backup File Name ( file . get Absolute Path ( ) ) ;  File backup File = find File ( backup Name ) ; if ( backup File != null ) { if ( backup File . delete ( ) ) { log . debug ( _ STR + backup Name ) ; } } if ( file . rename To ( new  File ( backup Name ) ) ) { log . debug ( _ STR + backup Name ) ; } else { log . error ( _ STR + backup Name ) ; } } }
public static boolean add Files To Existing Zip Aapt (  File temp Apk ,  Array List <  File > classes Files ) {  Array List <  String > rm Cmd = new  Array List <  String > ( ) ; rm Cmd . add (  S . get Aapt ( ) ) ; rm Cmd . add ( _ STR ) ; rm Cmd . add ( _ STR ) ; rm Cmd . add ( temp Apk . get Absolute Path ( ) ) ; for (  File f : classes Files ) rm Cmd . add ( f . get Name ( ) ) ;  String [ ] cmd Rm = new  String [ rm Cmd . size ( ) ] ; for ( int i = _ NUM ; i < rm Cmd . size ( ) ; i ++ ) cmd Rm [ i ] = rm Cmd . get ( i ) ;  Cmd Utils . run Command ( cmd Rm ) ;  Array List <  String > cmds = new  Array List <  String > ( ) ; cmds . add (  S . get Aapt ( ) ) ; cmds . add ( _ STR ) ; cmds . add ( _ STR ) ; cmds . add ( temp Apk . get Absolute Path ( ) ) ; for (  File f : classes Files ) cmds . add ( f . get Absolute Path ( ) ) ;  String [ ] cmd = new  String [ cmds . size ( ) ] ; for ( int i = _ NUM ; i < cmds . size ( ) ; i ++ ) cmd [ i ] = cmds . get ( i ) ; boolean sucess = (  Cmd Utils . run Command ( cmd ) == _ NUM ) ; if ( ! sucess ) { sucess = _ BOOL ; for (  File f : classes Files ) { try { sucess = sucess &&  Zip Tools . is Filein Zip ( f . get Name ( ) , new  Zip File ( temp Apk ) ) ; } catch (  Zip Exception e ) { e . print Stack Trace ( ) ; } } } return sucess ; }
public synchronized boolean safe Count ( int partition , long offset ) throws  IOException {  Atomic Long counter = null ; if ( partition >= this . counters . length ) { this . counters =  Arrays . copy Of ( this . counters , this . counters . length +  GROWBY ) ; } counter = counters [ partition ] ; if ( null == counter ) { counter = new  Atomic Long ( _ NUM ) ; counters [ partition ] = counter ; counter . set ( offset ) ; if ( null != committed Offsets && committed Offsets . length > partition && committed Offsets [ partition ] >= _ NUM && _ NUM < ( offset - committed Offsets [ partition ] ) ) { labels . clear ( ) ; labels . put (  Sensision Constants .  SENSISION_ LABEL_ TOPIC , this . topic ) ; labels . put (  Sensision Constants .  SENSISION_ LABEL_ GROUPID , this . groupid ) ; labels . put (  Sensision Constants .  SENSISION_ LABEL_ PARTITION ,  Integer . to String ( partition ) ) ;  Sensision . update (  Sensision Constants .  SENSISION_ CLASS_ WARP_ KAFKA_ CONSUMER_ OFFSET_ FORWARD_ LEAPS , labels , _ NUM ) ; throw new  IOException ( _ STR + offset + _ STR + committed Offsets [ partition ] ) ; } } else { long previous Offset = counter . get And Set ( offset ) ; if ( _ NUM < ( offset - previous Offset ) ) { labels . clear ( ) ; labels . put (  Sensision Constants .  SENSISION_ LABEL_ TOPIC , this . topic ) ; labels . put (  Sensision Constants .  SENSISION_ LABEL_ GROUPID , this . groupid ) ; labels . put (  Sensision Constants .  SENSISION_ LABEL_ PARTITION ,  Integer . to String ( partition ) ) ;  Sensision . update (  Sensision Constants .  SENSISION_ CLASS_ WARP_ KAFKA_ CONSUMER_ OFFSET_ FORWARD_ LEAPS , labels , _ NUM ) ; throw new  IOException ( _ STR + offset + _ STR + previous Offset ) ; } } if ( null != committed Offsets && committed Offsets . length > partition && offset <= committed Offsets [ partition ] ) { labels . clear ( ) ; labels . put (  Sensision Constants .  SENSISION_ LABEL_ TOPIC , this . topic ) ; labels . put (  Sensision Constants .  SENSISION_ LABEL_ GROUPID , this . groupid ) ; labels . put (  Sensision Constants .  SENSISION_ LABEL_ PARTITION ,  Integer . to String ( partition ) ) ;  Sensision . update (  Sensision Constants .  SENSISION_ CLASS_ WARP_ KAFKA_ CONSUMER_ OFFSET_ BACKWARD_ LEAPS , labels , _ NUM ) ; return _ BOOL ; } return _ BOOL ; }
Object Stream Class ( ) { }
public void add Region (  Region r ) { regions . add ( r ) ; }
public static void silent Close Input Stream (  Input Stream is ) { try { if ( is != null ) { is . close ( ) ; } } catch (  IOException e ) {  Log . w (  LOG_ TAG , _ STR , e ) ; } }
@  Override public void start Element (  String uri ,  String local Name ,  String q Name ,  Attributes attributes ) { if ( element Processor != null ) { element Processor = element Processor . get Child ( uri , local Name , q Name ) ; } else if (  ELEMENT_ NAME_ OSM . equals ( q Name ) ) { element Processor = osm Element Processor ; } else { throw new  Osm Runtime Exception ( _ STR ) ; } element Processor . begin ( attributes ) ; }
public void stop ( int timeout ) throws  Interrupted Exception { if ( ! isclosed . compare And Set ( _ BOOL , _ BOOL ) ) { return ; }  List <  Web Socket > sockets To Close = null ; synchronized ( connections ) { sockets To Close = new  Array List <  Web Socket > ( connections ) ; } for (  Web Socket ws : sockets To Close ) { ws . close (  Close Frame .  GOING_ AWAY ) ; } synchronized ( this ) { if ( selectorthread != null && selectorthread !=  Thread . current Thread ( ) ) { selector . wakeup ( ) ; selectorthread . interrupt ( ) ; selectorthread . join ( timeout ) ; } } }
public  Storage (  File directory ,  String properties File ) { if ( directory == null ) throw new  Null Pointer Exception ( _ STR ) ; if ( directory . is File ( ) ) throw new  Illegal Argument Exception ( _ STR + directory ) ; this . directory = directory ; this . properties File = properties File != null ? new  File ( directory , properties File ) : null ; }
protected void calculate Bar Width (  Category Plot plot ,  Rectangle2 D data Area , int renderer Index ,  Category Item Renderer State state ) {  Category Axis domain Axis = get Domain Axis ( plot , renderer Index ) ;  Category Dataset dataset = plot . get Dataset ( renderer Index ) ; if ( dataset != null ) { int columns = dataset . get Column Count ( ) ; int rows = state . get Visible Series Count ( ) >= _ NUM ? state . get Visible Series Count ( ) : dataset . get Row Count ( ) ; double space = _ NUM ;  Plot Orientation orientation = plot . get Orientation ( ) ; if ( orientation ==  Plot Orientation .  HORIZONTAL ) { space = data Area . get Height ( ) ; } else if ( orientation ==  Plot Orientation .  VERTICAL ) { space = data Area . get Width ( ) ; } double max Width = space * get Maximum Bar Width ( ) ; double category Margin = _ NUM ; double current Item Margin = _ NUM ; if ( columns > _ NUM ) { category Margin = domain Axis . get Category Margin ( ) ; } if ( rows > _ NUM ) { current Item Margin = get Item Margin ( ) ; } double used = space * ( _ NUM - domain Axis . get Lower Margin ( ) - domain Axis . get Upper Margin ( ) - category Margin - current Item Margin ) ; if ( ( rows * columns ) > _ NUM ) { state . set Bar Width (  Math . min ( used / ( rows * columns ) , max Width ) ) ; } else { state . set Bar Width (  Math . min ( used , max Width ) ) ; } } }
@  Requires Permission (  Manifest . permission .  CAMERA ) public  Camera Source start ( ) throws  IOException { synchronized ( m Camera Lock ) { if ( m Camera != null ) { return this ; } m Camera = create Camera ( ) ; if (  Build .  VERSION .  SDK_ INT >=  Build .  VERSION_ CODES .  HONEYCOMB ) { m Dummy Surface Texture = new  Surface Texture (  DUMMY_ TEXTURE_ NAME ) ; m Camera . set Preview Texture ( m Dummy Surface Texture ) ; } else { m Dummy Surface View = new  Surface View ( m Context ) ; m Camera . set Preview Display ( m Dummy Surface View . get Holder ( ) ) ; } m Camera . start Preview ( ) ; m Processing Thread = new  Thread ( m Frame Processor ) ; m Frame Processor . set Active ( _ BOOL ) ; m Processing Thread . start ( ) ; } return this ; }
public void remove Breakpoint Listener ( final  Breakpoint Listener listener ) { breakpoint Listeners . remove ( listener ) ; }
@  Override public void paint Component (  Graphics g ) { super . paint Component ( g ) ; if ( m_ Background != null ) { g . set Color (  Color .  WHITE ) ; g . clear Rect ( _ NUM , _ NUM , get Width ( ) , get Height ( ) ) ; int width = m_ Background . get Width ( null ) ; int height = m_ Background . get Height ( null ) ; int x = ( get Width ( ) - width ) / _ NUM ; int y = ( get Height ( ) - height ) / _ NUM ; g . draw Image ( m_ Background , x , y , width , height , this ) ; } }
public static final  String stack Trace (  Throwable e ) {  String foo = null ; try {  Byte Array Output Stream ostr = new  Byte Array Output Stream ( ) ; e . print Stack Trace ( new  Print Writer ( ostr , _ BOOL ) ) ; foo = ostr . to String ( ) ; } catch (  Exception f ) { } return foo ; }
@  Override public  Void visit Variable (  Variable Element e ,  Void p ) { if ( ! check For Serial ( e ) ) { if ( e . get Kind ( ) ==  ENUM_ CONSTANT || e . get Constant Value ( ) != null || heuristically Constant ( e ) ) check All Caps ( e ) ; else check Camel Case ( e , _ BOOL ) ; } return null ; }
@  Suppress Warnings ( _ STR ) public  Composite Comparator (  Comparator < ? super  T > ... comparators ) { this (  Arrays . as List ( comparators ) ) ; }
private double log Fac ( double x ) { double result = _ NUM ; for ( double i = _ NUM ; i <= x ; i ++ ) { result +=  Math . log ( i ) ; } return result ; }
public void begin ( ) {  Operation op = curr Op . get ( ) ; if ( op != null ) { op . reentries ++ ; return ; } op = new  Operation ( ) ; curr Op . set ( op ) ; for ( ; ; ) {  Operation prev = head . get ( ) ; op . previous ( prev ) ; if ( head . compare And Set ( prev , op ) ) { prev . next ( op ) ; break ; } } }
public void add ( final  Socket Channel channel , final  Quarantine Conversation conversation ) { if ( channel . is Blocking ( ) ) { throw new  Illegal Argument Exception ( _ STR ) ; } m_decoder . add ( channel , conversation ) ; m_reader . add ( channel ) ; }
public synchronized void save ( ) {  Properties to Save = (  Properties )  PROPS . clone ( ) ; for (  Setting set : settings ) { if ( ! set . should Always Save ( ) && set . is Default ( ) ) to Save . remove ( set . get Key ( ) ) ; }  Output Stream out = null ; try { if (  SETTINGS_ FILE . is Directory ( ) )  SETTINGS_ FILE . delete ( ) ;  File parent =  SETTINGS_ FILE . get Parent File ( ) ; if ( parent != null ) { parent . mkdirs ( ) ; }  File Utils . set Writeable (  SETTINGS_ FILE ) ; if (  SETTINGS_ FILE . exists ( ) && !  SETTINGS_ FILE . can Read ( ) ) {  SETTINGS_ FILE . delete ( ) ; } try { out = new  Buffered Output Stream ( new  File Output Stream (  SETTINGS_ FILE ) ) ; } catch (  IOException ioe ) { if (  SETTINGS_ FILE . exists ( ) ) {  SETTINGS_ FILE . delete ( ) ; out = new  Buffered Output Stream ( new  File Output Stream (  SETTINGS_ FILE ) ) ; } } if ( out != null ) { to Save . store ( out ,  HEADING ) ; } else { mark Failure ( ) ; } } catch (  IOException e ) { mark Failure ( ) ; } finally {  IOUtils . close Quietly ( out ) ; } }
public  E take ( ) throws  Interrupted Exception { final  Reentrant Lock lock = this . lock ; lock . lock Interruptibly ( ) ; try { for ( ; ; ) {  E first = q . peek ( ) ; if ( first == null ) available . await ( ) ; else { long delay = first . get Delay (  NANOSECONDS ) ; if ( delay <= _ NUM ) return q . poll ( ) ; first = null ; if ( leader != null ) available . await ( ) ; else {  Thread this Thread =  Thread . current Thread ( ) ; leader = this Thread ; try { available . await Nanos ( delay ) ; } finally { if ( leader == this Thread ) leader = null ; } } } } } finally { if ( leader == null && q . peek ( ) != null ) available . signal ( ) ; lock . unlock ( ) ; } }
public boolean submit Action (  Action0 action ) { boolean submitted = _ BOOL ;  Thread current Thread =  Thread . current Thread ( ) ; if ( current Thread . equals ( duty Thread ) ) { action . call ( ) ; } else { submitted = actions . offer ( action ) ; } return submitted ; }
boolean match Attribute Selections (  HTMLElement element ) { if ( get Tag Id ( ) ==  TAG_ CSS_ ILLEGAL_ SELECTOR ) { return _ BOOL ; } if ( attribute Selections == null ) { return _ BOOL ; } for (  Enumeration e = attribute Selections . elements ( ) ; e . has More Elements ( ) ; ) {  Att String att Str = (  Att String ) e . next Element ( ) ; if ( att Str . constraint ==  Att String .  LANG ) {  String lang = att Str . value ;  String elem Lang = get Lang ( element ) ; if ( ( elem Lang == null ) || ( ( ! lang . equals ( elem Lang ) ) && ( ! elem Lang . starts With ( lang + _ STR ) ) ) ) { return _ BOOL ; } } else {  String element Val = element . get Attribute ( att Str . attribute ) ; if ( element Val == null ) { return _ BOOL ; } if ( att Str . value != null ) { switch ( att Str . constraint ) { case  Att String .  EQUALS : if ( ! element Val . equals ( att Str . value ) ) { return _ BOOL ; } break ; case  Att String .  BEGINS_ WITH : if ( ( ! element Val . equals ( att Str . value ) ) && ( ! element Val . starts With ( att Str . value + _ STR ) ) ) { return _ BOOL ; } break ; case  Att String .  CONTAINS_ WORD :  String str = _ STR + element Val + _ STR ; if ( str . index Of ( _ STR + att Str . value + _ STR ) == - _ NUM ) { return _ BOOL ; } break ; } } } } return _ BOOL ; }
public void remove Value (  Value value ) { action Values . remove ( value ) ; action Values As Array = null ; }
@  Override public void channel Open (  Channel Handler Context channel Handler Context ,  Channel State Event channel State Event ) throws  Exception { total_conns . increment And Get ( ) ; curr_conns . increment And Get ( ) ; channel Group . add ( channel Handler Context . get Channel ( ) ) ; }
private static void prepare Rmi GC ( ) { try { if (  System . get Property ( _ STR ) == null )  System . set Property ( _ STR , _ STR ) ; if (  System . get Property ( _ STR ) == null )  System . set Property ( _ STR , _ STR ) ; } catch (  Exception sec Exc ) { if ( logger . is Loggable (  Level .  WARNING ) ) { logger . log (  Level .  WARNING , _ STR , sec Exc ) ; } } }
public static boolean is Next Window (  URI id ) { return  NEXT . equals ( id ) ; }
public  Queue Event offer ( byte [ ] data , long timeout ) throws  Keeper Exception ,  Interrupted Exception {  Timer Context time = stats . time ( dir + _ STR ) ; try {  String path = create Data ( dir + _ STR + prefix , data ,  Create Mode .  PERSISTENT_ SEQUENTIAL ) ;  String watch ID = create Data ( dir + _ STR + response_prefix + path . substring ( path . last Index Of ( _ STR ) + _ NUM ) , null ,  Create Mode .  EPHEMERAL ) ;  Object lock = new  Object ( ) ;  Latch Child Watcher watcher = new  Latch Child Watcher ( lock ) ; synchronized ( lock ) { if ( zookeeper . exists ( watch ID , watcher , _ BOOL ) != null ) { watcher . await ( timeout ) ; } } byte [ ] bytes = zookeeper . get Data ( watch ID , null , null , _ BOOL ) ; zookeeper . delete ( watch ID , - _ NUM , _ BOOL ) ; return new  Queue Event ( watch ID , bytes , watcher . get Watched Event ( ) ) ; } finally { time . stop ( ) ; } }
public  Property XMLBuilder (  String service Name ,  AMModel model ,  Set attribute Schemas ,  Schema Type schema Type ) throws  SMSException ,  SSOException { this . model = model ; this . service Name = service Name ; svc Schema Manager = new  Service Schema Manager ( service Name , model . get User SSOToken ( ) ) ; if ( schema Type != null ) { if ( load Section Order ( ) ) { schema Types = new  Hash Set <  Schema Type > ( ) ; schema Types . add ( schema Type ) ; get Sections For Type ( ) ; } } get Service Resource Bundle ( ) ; if ( service Bundle != null ) { map Type To Attribute Schema = new  Hash Map ( attribute Schemas . size ( ) * _ NUM ) ; map Type To Attribute Schema . put (  NULL_ TYPE , attribute Schemas ) ; } }
public boolean parse Args (  String [ ] args ,  Main main ) {  String explicit Version = null ; for ( int i = _ NUM ; i < args . length ; i ++ ) {  String arg = args [ i ] ; if ( version Options . contains Key ( arg ) ) { if ( explicit Version != null && ! explicit Version . equals ( arg ) ) { main . error ( _ STR , explicit Version , arg ) ; return _ BOOL ; } explicit Version = arg ; version = version Options . get ( arg ) ; args [ i ] = null ; } } return _ BOOL ; }
public static  List <  String > to List (  String [ ] array ) {  List <  String > list = new  Array List <  String > ( ) ; if ( ( array != null ) && ( array . length > _ NUM ) ) { for ( int i = _ NUM ; i < array . length ; i ++ ) { list . add ( array [ i ] ) ; } } return list ; }
public void remove ( final  T object ) { synchronized ( m Lock ) { m List . remove ( object ) ; } notify Data Set Changed ( ) ; }
public void test_vmstat_header_and_data_parse ( ) { final  Pattern pattern =  VMStat Collector . pattern ; final  String h0 = _ STR ; final  String h1 = _ STR ; final  String d1 = _ STR ; { final  String [ ] fields = pattern . split ( h0 . trim ( ) , _ NUM ) ; for ( int i = _ NUM ; i < fields . length ; i ++ ) { if ( log . is Info Enabled ( ) ) log . info ( _ STR + i + _ STR + fields [ i ] + _ STR ) ; } assert Field ( h0 , fields , _ NUM , _ STR ) ; assert Field ( h0 , fields , _ NUM , _ STR ) ; } { final  String [ ] fields = pattern . split ( h1 . trim ( ) , _ NUM ) ; for ( int i = _ NUM ; i < fields . length ; i ++ ) { if ( log . is Info Enabled ( ) ) log . info ( _ STR + i + _ STR + fields [ i ] + _ STR ) ; } assert Field ( h1 , fields , _ NUM , _ STR ) ; assert Field ( h1 , fields , _ NUM , _ STR ) ; assert Field ( h1 , fields , _ NUM , _ STR ) ; assert Field ( h1 , fields , _ NUM , _ STR ) ; assert Field ( h1 , fields , _ NUM , _ STR ) ; assert Field ( h1 , fields , _ NUM , _ STR ) ; assert Field ( h1 , fields , _ NUM , _ STR ) ; assert Field ( h1 , fields , _ NUM , _ STR ) ; assert Field ( h1 , fields , _ NUM , _ STR ) ; assert Field ( h1 , fields , _ NUM , _ STR ) ; assert Field ( h1 , fields , _ NUM , _ STR ) ; } { final  String [ ] fields = pattern . split ( d1 . trim ( ) , _ NUM ) ; assert Field ( d1 , fields , _ NUM , _ STR ) ; assert Field ( d1 , fields , _ NUM , _ STR ) ; assert Field ( d1 , fields , _ NUM , _ STR ) ; assert Field ( d1 , fields , _ NUM , _ STR ) ; assert Field ( d1 , fields , _ NUM , _ STR ) ; assert Field ( d1 , fields , _ NUM , _ STR ) ; assert Field ( d1 , fields , _ NUM , _ STR ) ; assert Field ( d1 , fields , _ NUM , _ STR ) ; assert Field ( d1 , fields , _ NUM , _ STR ) ; assert Field ( d1 , fields , _ NUM , _ STR ) ; assert Field ( d1 , fields , _ NUM , _ STR ) ; } }
public static  String remove Chars (  String src , char ... chars ) { int i = src . length ( ) ;  String Builder sb = new  String Builder ( i ) ; mainloop : for ( int j = _ NUM ; j < i ; j ++ ) { char c = src . char At ( j ) ; for ( char a Char : chars ) { if ( c == a Char ) { continue mainloop ; } } sb . append ( c ) ; } return sb . to String ( ) ; }
@  Override public void run ( ) { try { while ( running ) { step ( ) ; try {  Thread . sleep ( step Pause ) ; } catch (  Interrupted Exception e ) { e . print Stack Trace ( ) ; } } } catch (  Null Pointer Exception e ) { robot Gui . notify Initialize ( ) ; } catch (  Robot Exception e ) { } try { running Lock . acquire ( ) ; } catch (  Interrupted Exception e ) { e . print Stack Trace ( ) ; } running = _ BOOL ; gui . enable Buttons ( gui . button State Normal ) ; button . set Text ( gui . auto Locate Title ) ; running Lock . release ( ) ; }
public boolean is Attacked By ( final  IEntity attacker ) { return attackers . contains ( attacker ) ; }
public static <  T >  Optional <  T > cast (  Object object ,  Class <  T > clazz ) { require Non Null ( clazz ) ; if ( object == null ) { return  Optional . empty ( ) ; } if ( clazz . is Assignable From ( object . get Class ( ) ) ) { final  T result = clazz . cast ( object ) ; return  Optional . of ( result ) ; } return  Optional . empty ( ) ; }
private boolean wait Cluster Power Off State Not Less Than (  Power Off State .  State state , boolean check Num Of Control Nodes ) { long expire Time =  System . current Time Millis ( ) + power Off State Change Timeout ; while ( _ BOOL ) { if ( coordinator . verify Nodes Power Off State Not Before ( state , check Num Of Control Nodes ) ) { return _ BOOL ; } sleep ( power Off State Probe Interval ) ; if (  System . current Time Millis ( ) >= expire Time ) { return _ BOOL ; } } }
void delete Replica Based On Count (  Cluster State cluster State ,  Zk Node Props message ,  Named List results ,  Runnable on Complete , boolean parallel ) throws  Keeper Exception ,  Interrupted Exception { ocmh . check Required ( message ,  COLLECTION_ PROP ,  COUNT_ PROP ) ; int count =  Integer . parse Int ( message . get Str (  COUNT_ PROP ) ) ;  String collection Name = message . get Str (  COLLECTION_ PROP ) ;  String shard = message . get Str (  SHARD_ ID_ PROP ) ;  Doc Collection coll = cluster State . get Collection ( collection Name ) ;  Slice slice = null ; if ( shard != null ) { slice = coll . get Slice ( shard ) ; if ( slice == null ) { throw new  Solr Exception (  Solr Exception .  Error Code .  BAD_ REQUEST , _ STR + shard + _ STR + collection Name ) ; } }  Map <  Slice ,  Set <  String > > shard To Replicas Mapping = new  Hash Map <  Slice ,  Set <  String > > ( ) ; if ( slice != null ) {  Set <  String > replicas To Be Deleted = pick Replicas Tobe Deleted ( slice , shard , collection Name , count ) ; shard To Replicas Mapping . put ( slice , replicas To Be Deleted ) ; } else {  Collection <  Slice > all Slices = coll . get Slices ( ) ; for (  Slice individual Slice : all Slices ) {  Set <  String > replicas To Be Deleted = pick Replicas Tobe Deleted ( individual Slice , individual Slice . get Name ( ) , collection Name , count ) ; shard To Replicas Mapping . put ( individual Slice , replicas To Be Deleted ) ; } } for (  Slice shard Slice : shard To Replicas Mapping . key Set ( ) ) {  String shard Id = shard Slice . get Name ( ) ;  Set <  String > replicas = shard To Replicas Mapping . get ( shard Slice ) ; for (  String replica : replicas ) { log . debug ( _ STR , replica , shard Id , count ) ; delete Core ( shard Slice , collection Name , replica , message , shard , results , on Complete , parallel ) ; } results . add ( _ STR , shard Id ) ; results . add ( _ STR , replicas ) ; } }
default  Type Declaration as Type ( ) { throw new  Unsupported Operation Exception (  String . format ( _ STR , this ) ) ; }
protected static @  Not Null  String convert Map To Groovy Source ( @  Not Null  Map <  String ,  Object > map ) {  String Builder sb = new  String Builder ( ) ; for (  Map .  Entry <  String ,  Object > entry : map . entry Set ( ) ) { if ( sb . length ( ) > _ NUM ) { sb . append ( _ STR ) ; } sb . append ( entry . get Key ( ) ) ; sb . append ( _ STR ) ; sb . append ( convert Value To Groovy Source ( entry . get Value ( ) ) ) ; } return sb . to String ( ) ; }
public void upload Image (  Multipart File file ,  Long cheque ID ,  String username ) { if ( ! file . is Empty ( ) ) {  Photo photo = new  Photo ( ) ; try { photo . set Bytes ( file . get Bytes ( ) ) ; } catch (  IOException e ) { e . print Stack Trace ( ) ; } photo . set Name ( file . get Original Filename ( ) ) ; photo . set Content Type ( file . get Content Type ( ) ) ; photo . set Cheque Id ( cheque ID . to String ( ) ) ; photo . set Username ( username ) ; photo . set Add Date (  Offset Date Time . now ( ) ) ; photo Repository . save ( photo ) ; } }
public  Data Bounds calculate Projected Image Bounds (  Projection p ) {  Data Bounds db = null ; if ( source Image Bounds != null ) { int pw = p . get Width ( ) ; int ph = p . get Height ( ) ;  Point2 D min = source Image Bounds . get Min ( ) ;  Point2 D max = source Image Bounds . get Max ( ) ; double x1 =  Math . floor ( min . get X ( ) ) ; double y1 =  Math . floor ( min . get Y ( ) ) ; double x2 =  Math . ceil ( max . get X ( ) ) ; double y2 =  Math . ceil ( max . get Y ( ) ) ; double width = source Image Bounds . get Width ( ) ; double height = source Image Bounds . get Height ( ) ;  Lat Lon Point tmp G = new  Lat Lon Point .  Double ( ) ;  Point2 D tmp P = new  Point2 D .  Double ( ) ; db = new  Data Bounds ( ) ; db . set Hard Limits ( new  Data Bounds ( _ NUM , _ NUM , pw , ph ) ) ; db . add ( p . forward ( geo Trans . inverse ( x1 , y1 , tmp G ) , tmp P ) ) ; db . add ( p . forward ( geo Trans . inverse ( x1 , y2 , tmp G ) , tmp P ) ) ; db . add ( p . forward ( geo Trans . inverse ( x2 , y1 , tmp G ) , tmp P ) ) ; db . add ( p . forward ( geo Trans . inverse ( x2 , y2 , tmp G ) , tmp P ) ) ; double num Splits = _ NUM ; double x Spacer = width / num Splits ; double y Spacer = height / num Splits ; for ( int i = _ NUM ; i < num Splits ; i ++ ) { db . add ( p . forward ( geo Trans . inverse (  Math . ceil ( x1 + x Spacer * i ) , y1 , tmp G ) , tmp P ) ) ; db . add ( p . forward ( geo Trans . inverse ( x1 ,  Math . ceil ( y1 + y Spacer * i ) , tmp G ) , tmp P ) ) ; db . add ( p . forward ( geo Trans . inverse (  Math . ceil ( x1 + x Spacer * i ) , y2 , tmp G ) , tmp P ) ) ; db . add ( p . forward ( geo Trans . inverse ( x2 ,  Math . ceil ( y1 + y Spacer * i ) , tmp G ) , tmp P ) ) ; } if ( db . get Width ( ) <= _ NUM || db . get Height ( ) <= _ NUM ) { logger . fine ( _ STR + db ) ; return null ; } } return db ; }
public  Class < ? > load Class (  String name ) throws  Class Not Found Exception { if ( best Candidate != null ) { try { return best Candidate . load Class ( name ) ; } catch (  Throwable t ) { best Candidate = null ; } }  Throwable throwable = null ;  Class < ? > clazz = null ;  Class Load Helper load Helper = null ;  Iterator <  Class Load Helper > iter = load Helpers . iterator ( ) ; while ( iter . has Next ( ) ) { load Helper = iter . next ( ) ; try { clazz = load Helper . load Class ( name ) ; break ; } catch (  Throwable t ) { throwable = t ; } } if ( clazz == null ) { if ( throwable instanceof  Class Not Found Exception ) { throw (  Class Not Found Exception ) throwable ; } else { throw new  Class Not Found Exception (  String . format ( _ STR , name ) , throwable ) ; } } best Candidate = load Helper ; return clazz ; }
public void add Remove And Get Time Nanos ( long duration ) { rmv Time Nanos . add And Get ( duration ) ; get Time Nanos . add And Get ( duration ) ; if ( delegate != null ) delegate . add Remove And Get Time Nanos ( duration ) ; }
private float check Valid ( final float val ) { float tempval = val ; if ( val > _ NUM ) { tempval = _ NUM ; } if ( val < _ NUM ) { tempval = _ NUM ; } return tempval ; }
public static  Collection Id parse (  String str ) {  String [ ] parts = str . split ( _ STR + _ STR + _ STR ) ; if ( parts . length < _ NUM ) return null ; return new  Collection Id ( parts [ _ NUM ] , parts [ _ NUM ] , parts [ _ NUM ] ) ; }
public static void assert Prop Name (  String prop Name ) throws  XMPException { if ( prop Name == null || prop Name . length ( ) == _ NUM ) { throw new  XMPException ( _ STR ,  XMPError .  BADPARAM ) ; } }
private boolean execute (  String command ,  File arg ,  List <  String > lines ) {  Process Builder pb = new  Process Builder ( command , arg . get Absolute Path ( ) ) ; pb . redirect Error Stream ( _ BOOL ) ; try {  Process proc = pb . start ( ) ;  Buffered Reader reader = new  Buffered Reader ( new  Input Stream Reader ( proc . get Input Stream ( ) ) ) ;  String line ; while ( ( line = reader . read Line ( ) ) != null ) { lines . add ( line ) ; } proc . wait For ( ) ; return proc . exit Value ( ) == _ NUM ; } catch (  Exception e ) { log . error ( _ STR + command + _ STR + arg , e ) ; lines . add ( e . get Message ( ) ) ; return _ BOOL ; } }
@  Override public  Selectable Channel selectable Channel ( ) { if ( _s != null ) { return _s . get Channel ( ) ; } else { return null ; } }
private static  String byte To Hex ( byte [ ] digest ) {  String Builder builder = new  String Builder ( ) ; for ( byte b : digest ) {  String hex =  Integer . to Hex String ( _ NUM & b ) ; if ( hex . length ( ) == _ NUM ) { builder . append ( _ STR ) ; } builder . append ( hex ) ; } return builder . to String ( ) ; }
static public javax . swing .  Combo Box Model <  String > j Combo Box Model From List (  List <  Decoder File > l ) { javax . swing .  Default Combo Box Model <  String > b = new javax . swing .  Default Combo Box Model <  String > ( ) ; for ( int i = _ NUM ; i < l . size ( ) ; i ++ ) {  Decoder File r = l . get ( i ) ; b . add Element ( r . title String ( ) ) ; } return b ; }
private static int  Windows Reg Flush Key1 ( int h Key ) { int result =  Windows Reg Flush Key ( h Key ) ; if ( result ==  ERROR_ SUCCESS ) { return result ; } else { long sleep Time =  INIT_ SLEEP_ TIME ; for ( int i = _ NUM ; i <  MAX_ ATTEMPTS ; i ++ ) { try {  Thread . sleep ( sleep Time ) ; } catch (  Interrupted Exception e ) { return result ; } sleep Time *= _ NUM ; result =  Windows Reg Flush Key ( h Key ) ; if ( result ==  ERROR_ SUCCESS ) { return result ; } } } return result ; }
public  Date parse Date (  String str ) { try { return date Format . parse ( str ) ; } catch ( java . text .  Parse Exception e ) { throw new  Runtime Exception ( e ) ; } }
public void assert All Queries (  Memory Index memory ,  Directory ramdir ,  Analyzer analyzer ) throws  Exception {  Index Reader reader =  Directory Reader . open ( ramdir ) ;  Index Searcher ram = new Searcher ( reader ) ;  Index Searcher mem = memory . create Searcher ( ) ;  Query Parser qp = new  Query Parser ( _ STR , analyzer ) ; for (  String query : queries ) {  Top Docs ram Docs = ram . search ( qp . parse ( query ) , _ NUM ) ;  Top Docs mem Docs = mem . search ( qp . parse ( query ) , _ NUM ) ; assert Equals ( query , ram Docs . total Hits , mem Docs . total Hits ) ; } reader . close ( ) ; }
private  IStatus run Safely (  IProgress Monitor monitor ) throws  Exception { monitor . begin Task ( null , _ NUM ) ; monitor . sub Task (  NLS . bind (  Messages .  Connecting Source , get Source URL ( ) ) ) ;  URL url = new  URL ( source URL ) ;  URLConnection connection = url . open Connection ( ) ; set URLConnection ( connection ) ; if ( monitor . is Canceled ( ) ) return cancel Status ( ) ; setup Connection ( connection ) ; if ( monitor . is Canceled ( ) ) return cancel Status ( ) ; connection . connect ( ) ; if ( monitor . is Canceled ( ) ) return cancel Status ( ) ;  IStatus consumed = validate Connection ( connection ) ; if ( consumed != null ) return consumed ; if ( monitor . is Canceled ( ) ) return cancel Status ( ) ; int length = connection . get Content Length ( ) ; if ( monitor . is Canceled ( ) ) return cancel Status ( ) ;  Input Stream source Stream = connection . get Input Stream ( ) ; try { if ( monitor . is Canceled ( ) ) return cancel Status ( ) ; monitor . sub Task (  NLS . bind (  Messages .  Initializing Target , get Target Path ( ) ) ) ;  Output Stream target Stream = target . open Output Stream ( ) ; if ( monitor . is Canceled ( ) ) return cancel Status ( ) ; try { source Stream = new  Monitored Input Stream ( source Stream , monitor ) ; target Stream = new  Monitored Output Stream ( target Stream , monitor ) ; monitor . sub Task (  Messages .  Transfering Data ) ; transfer ( source Stream , target Stream , new  Sub Progress Monitor ( monitor , _ NUM ) , length ) ; set URLConnection ( null ) ; monitor . done ( ) ; return new  Status (  IStatus .  OK , plugin Id ,  NLS . bind (  Messages .  Download Finished , get Source URL ( ) , get Target Path ( ) ) ) ; } finally { try { target Stream . close ( ) ; } catch (  IOException ignore ) { } } } finally { try { source Stream . close ( ) ; } catch (  IOException ignore ) { } } }
void add Annotation ( @  Non Null  Annotation annotation ) { annotations . put ( annotation . annotation Type ( ) , annotation ) ; }
public static  List <  String > split (  String str ,  String delim ) {  List <  String > split List = null ;  String Tokenizer st = null ; if ( str == null ) return split List ; if ( delim != null ) st = new  String Tokenizer ( str , delim ) ; else st = new  String Tokenizer ( str ) ; if ( st != null && st . has More Tokens ( ) ) { split List = new  Linked List <  String > ( ) ; while ( st . has More Tokens ( ) ) split List . add ( st . next Token ( ) ) ; } return split List ; }
public static void delete Directory Quickly (  File dir ) throws  IOException { if ( ! dir . exists ( ) ) { return ; } final  File to = new  File ( dir . get Absolute Path ( ) +  System . current Time Millis ( ) ) ; dir . rename To ( to ) ; if ( ! dir . exists ( ) ) { dir . mkdirs ( ) ; } if ( to . exists ( ) ) {  String delete Cmd = _ STR + to ;  Runtime runtime =  Runtime . get Runtime ( ) ; try {  Process process = runtime . exec ( delete Cmd ) ; process . wait For ( ) ; } catch (  IOException e ) { } catch (  Interrupted Exception e ) { e . print Stack Trace ( ) ; } } if ( ! to . exists ( ) ) { return ; } delete Directory Recursively ( to ) ; if ( to . exists ( ) ) { to . delete ( ) ; } }
public int find Julian Day From Position ( int position ) { if ( m Row Info == null || position < _ NUM ) { return _ NUM ; } int len = m Row Info . size ( ) ; if ( position >= len ) return _ NUM ; for ( int index = position ; index >= _ NUM ; index -- ) {  Row Info row = m Row Info . get ( index ) ; if ( row . m Type ==  TYPE_ DAY ) { return row . m Day ; } } return _ NUM ; }
final public void println ( double v ) {  String s =  String . value Of ( v ) ; write ( s , _ NUM , s . length ( ) ) ; println ( ) ; }
public static void move And Mask ( final  ITranslation Environment environment , final long offset , final  Operand Size value Size , final  String value , final  String sub Register , final  List <  Reil Instruction > instructions ) throws  Illegal Argument Exception ,  Internal Translation Exception ,  Illegal Argument Exception {  Preconditions . check Not Null ( environment , _ STR ) ;  Preconditions . check Not Null ( value , _ STR ) ;  Preconditions . check Not Null ( sub Register , _ STR ) ;  Preconditions . check Not Null ( value Size , _ STR ) ;  Preconditions . check Not Null ( instructions , _ STR ) ; final  String parent Register = get Parent Register ( sub Register ) ; final  Operand Size register Size = get Register Size ( sub Register ) ; final  Operand Size parent Register Size = get Register Size ( parent Register ) ; final  Operand Size arch Size = environment . get Architecture Size ( ) ; if ( register Size . get Byte Size ( ) >= arch Size . get Byte Size ( ) ) { throw new  Internal Translation Exception ( _ STR ) ; } if ( value Size . get Byte Size ( ) >= arch Size . get Byte Size ( ) ) { throw new  Internal Translation Exception ( _ STR ) ; } if ( value Size . get Byte Size ( ) >= parent Register Size . get Byte Size ( ) ) { throw new  Internal Translation Exception ( _ STR ) ; } final  String mask =  String . value Of ( get Negative Mask ( sub Register ) ) ; if ( is Higher8 Bit Register ( sub Register ) ) { final  String shifted Value = environment . get Next Variable String ( ) ; final  String masked Value = environment . get Next Variable String ( ) ; instructions . add (  Reil Helpers . create Bsh ( offset , value Size , value , value Size , _ STR , arch Size , shifted Value ) ) ; instructions . add (  Reil Helpers . create And ( offset + _ NUM , arch Size , parent Register , arch Size , mask , arch Size , masked Value ) ) ; instructions . add (  Reil Helpers . create Or ( offset + _ NUM , arch Size , shifted Value , arch Size , masked Value , arch Size , parent Register ) ) ; } else { final  String masked Value = environment . get Next Variable String ( ) ; instructions . add (  Reil Helpers . create And ( offset , arch Size , parent Register , arch Size , mask , arch Size , masked Value ) ) ; instructions . add (  Reil Helpers . create Or ( offset + _ NUM , value Size , value , arch Size , masked Value , arch Size , parent Register ) ) ; } }
private boolean is Shell Only (  Method method ) {  Cli Meta Data cli Metadata = method . get Annotation (  Cli Meta Data . class ) ; return cli Metadata != null && cli Metadata . shell Only ( ) ; }
protected  String url ( int zoom Level , int x Tile , int y Tile ) {  String Builder sb = new  String Builder ( _url ) ; sb . append ( _ STR ) ; sb . append ( zoom Level ) ; sb . append ( _ STR ) ; sb . append ( x Tile ) ; sb . append ( _ STR ) ; sb . append ( y Tile ) ; sb . append ( _ STR ) ; return sb . to String ( ) ; }
private static void analyze New String Set Contains Old String Set Values (  String Set a ,  String Set b ,  String name ,  Hash Map <  String ,  Change > changes ) { if ( a != null ) {  Iterator <  String > iter = a . iterator ( ) ; while ( iter . has Next ( ) ) {  String val = iter . next ( ) ; if ( b != null && b . contains ( val ) ) { continue ; }  String key = name + _ STR + val ;  Change change = new  Change ( key , val , null , name ) ; changes . put ( key , change ) ; } } else if ( a == null && b != null ) {  String key = name ;  Change change = new  Change ( key , null ,  NOT_ NULL , name ) ; changes . put ( key , change ) ; } }
private void register Heap Variables (  IR ir ) {  SSADictionary dictionary = ir .  HIRInfo . dictionary ; for (  Enumeration <  Basic Block > bbe = ir . get Basic Blocks ( ) ; bbe . has More Elements ( ) ; ) {  Basic Block b = bbe . next Element ( ) ; for (  Enumeration <  Instruction > e = b . forward Instr Enumerator ( ) ; e . has More Elements ( ) ; ) {  Instruction s = e . next Element ( ) ; if ( s . is Implicit Load ( ) || s . is Implicit Store ( ) || s . is Allocation ( ) ||  Phi . conforms ( s ) || s . is PEI ( ) ||  Label . conforms ( s ) ||  BBend . conforms ( s ) || s . get Opcode ( ) ==  UNINT_ BEGIN_opcode || s . get Opcode ( ) ==  UNINT_ END_opcode ) { dictionary . register Instruction ( s , b ) ; } } } }
public  String to HTML ( ) {  List <  Test Case > failed = get Failed Test Cases ( ) ;  List <  Test Case > passed = get Passed Test Cases ( ) ;  List <  Test Case > skipped = get Skipped Test Cases ( ) ;  String Buffer buff = new  String Buffer ( ) ; for (  Test Case tc : failed ) { buff . append ( tc . to HTML ( ) ) ; } for (  Test Case tc : passed ) { buff . append ( tc . to HTML ( ) ) ; } for (  Test Case tc : skipped ) { buff . append ( tc . to HTML ( ) ) ; }  Object [ ] params = { name , buff . to String ( ) } ; return  Message Format . format (  HTMLConstants .  TEST_ TABLE , params ) ; }
public <  T >  T create (  Class <  T > service ,  TProtocol Factory protocol Factory ,  Scheduler subscrib Scheduler ,  Interceptor ... interceptors ) { if ( ! service . is Interface ( ) ) { throw new  Illegal Argument Exception ( _ STR ) ; } return (  T )  Proxy . new Proxy Instance ( service . get Class Loader ( ) , new  Class < ? > [ ] { service } , new  Client ( protocol Factory , subscrib Scheduler , interceptors ) ) ; }
private boolean check GMLFootprint (  String footprint ) { try {  Configuration configuration = new  GMLConfiguration ( ) ;  Parser parser = new  Parser ( configuration ) ; parser . parse ( new  Input Source ( new  String Reader ( footprint ) ) ) ; return _ BOOL ; } catch (  Exception e ) {  LOGGER . error ( _ STR + e . get Message ( ) ) ; return _ BOOL ; } }
public static double quantile ( double p , double k , double theta , double shift ) { return  Math . log (  Gamma Distribution . quantile ( p , k , theta ) ) + shift ; }
public  Text Editor Init ( final  Text Editor Configuration configuration , final  Event Bus general Event Bus , final  Code Assistant Factory code Assistant Factory , final  Quick Assist Assistant quick Assist , final  Text Editor Presenter <  T > text Editor ) { this . configuration = configuration ; this . general Event Bus = general Event Bus ; this . code Assistant Factory = code Assistant Factory ; this . quick Assist = quick Assist ; this . text Editor = text Editor ; }
final void put Double ( int offset , double value ) { unsafe . put Double ( offset + address , value ) ; }
public final void add Validation Errors (  Iterable <  String > errors ) { for (  String error : errors ) { validation Errors . add ( error ) ; } }
private static  Map <  String ,  String > extract Key Value Pairs (  String props ,  Object Name mbean ) {  Map <  String ,  String > map = new  Linked Hash Map <  String ,  String > ( ) ; int eq = props . index Of ( _ STR ) ; while ( eq != - _ NUM ) {  String key = props . substring ( _ NUM , eq ) ;  String value = mbean . get Key Property ( key ) ; map . put ( key , value ) ; props = props . substring ( key . length ( ) + _ NUM + value . length ( ) ) ; if ( props . starts With ( _ STR ) ) { props = props . substring ( _ NUM ) ; } eq = props . index Of ( _ STR ) ; } return map ; }
public  Big Integer calculate Secret (  Big Integer client A ) throws  Crypto Exception { this .  A =  SRP6 Util . validate Public Value (  N , client A ) ; this . u =  SRP6 Util . calculate U ( digest ,  N ,  A ,  B ) ; this .  S = calculate S ( ) ; return  S ; }
public void reload (  Solr Core core ,  Solr Index Searcher searcher ) throws  IOException {  LOG . info ( _ STR + name + _ STR ) ; if ( dictionary == null && store Dir != null ) {  File lookup File = get Store File ( ) ; if ( lookup File . exists ( ) ) {  File Input Stream is = new  File Input Stream ( lookup File ) ; try { if ( lookup . load ( is ) ) { return ; } } finally {  IOUtils . close While Handling Exception ( is ) ; } } else {  LOG . info ( _ STR ) ; } } }
public  Abstract Script Command (  Configuration configuration ,  String resource Path ) { this . configuration = configuration ; this . resource Path = resource Path ; this . resource Utils = new  Resource Utils ( ) ; this . ant Utils = new  Ant Utils ( ) ; }
private void connect ( ) throws  IOException {  JMXService URL jmx Url = new  JMXService URL (  String . format (  FMTURL , host , host , port ) ) ;  Map <  String ,  Object > env = new  Hash Map <  String ,  Object > ( ) ; if ( username != null ) {  String [ ] creds = { username , password } ; env . put (  JMXConnector .  CREDENTIALS , creds ) ; } jmxc =  JMXConnector Factory . connect ( jmx Url , env ) ; mbean Server Conn = jmxc . get MBean Server Connection ( ) ; try {  Object Name name = new  Object Name (  SSOBJNAME ) ; ss Proxy =  JMX . new MBean Proxy ( mbean Server Conn , name ,  Storage Service MBean . class ) ; snitch Proxy =  JMX . new MBean Proxy ( mbean Server Conn , new  Object Name ( _ STR ) ,  Endpoint Snitch Info MBean . class ) ; internode Auth Proxy =  JMX . new MBean Proxy ( mbean Server Conn , new  Object Name (  Geo Internode Authenticator MBean .  MBEAN_ NAME ) ,  Geo Internode Authenticator MBean . class ) ; db Mgr Ops = new  Db Manager Ops ( mbean Server Conn ) ; } catch (  Malformed Object Name Exception e ) { throw new  Runtime Exception ( _ STR , e ) ; } }
private long read Word ( final int position ) { if ( position < _ NUM ) { throw new  Array Index Out Of Bounds Exception ( position ) ; } final long first Bit Index = ( ( long ) position ) * ( ( long ) word Length ) ; final int first Byte Index = ( byte Padding + ( int ) ( first Bit Index /  BITS_ PER_ BYTE ) ) ; final int first Byte Skip Bits = ( int ) ( first Bit Index %  BITS_ PER_ BYTE ) ; final long last Bit Index = ( first Bit Index + word Length - _ NUM ) ; final int last Byte Index = ( byte Padding + ( int ) ( last Bit Index /  BITS_ PER_ BYTE ) ) ; final int last Byte Bits To Consume ; final int bits After Byte Boundary = ( int ) ( ( last Bit Index + _ NUM ) %  BITS_ PER_ BYTE ) ; if ( bits After Byte Boundary == _ NUM ) { last Byte Bits To Consume =  BITS_ PER_ BYTE ; } else { last Byte Bits To Consume = bits After Byte Boundary ; } if ( last Byte Index >= bytes . length ) { throw new  Array Index Out Of Bounds Exception ( _ STR ) ; } long value = _ NUM ; final int bits Remaining In First Byte = (  BITS_ PER_ BYTE - first Byte Skip Bits ) ; final int bits To Consume In First Byte =  Math . min ( bits Remaining In First Byte , word Length ) ; long first Byte = ( long ) bytes [ first Byte Index ] ; final long first Byte Mask = ( ( _ NUM << bits Remaining In First Byte ) - _ NUM ) ; first Byte &= first Byte Mask ; first Byte >>>= ( bits Remaining In First Byte - bits To Consume In First Byte ) ; value |= first Byte ; if ( first Byte Index == last Byte Index ) { return value ; } final int middle Byte Count = ( last Byte Index - first Byte Index - _ NUM ) ; for ( int i = _ NUM ; i < middle Byte Count ; i ++ ) { final long middle Byte = ( bytes [ first Byte Index + i + _ NUM ] &  BYTE_ MASK ) ; value <<=  BITS_ PER_ BYTE ; value |= middle Byte ; } long last Byte = ( bytes [ last Byte Index ] &  BYTE_ MASK ) ; last Byte >>= (  BITS_ PER_ BYTE - last Byte Bits To Consume ) ; value <<= last Byte Bits To Consume ; value |= last Byte ; return value ; }
private void split Full Name ( ) { int first End = full Name . index Of ( _ STR ) ; int second End = full Name . index Of ( _ STR , first End + _ NUM ) ; timestamp = full Name . substring ( _ NUM , first End ) ; unique String = full Name . substring ( first End + _ NUM , second End ) ; hostname And Meta = full Name . substring ( second End + _ NUM , full Name . length ( ) ) ; }
@  Override public void handle Click ( int x , int y ,  Plot Rendering Info info ) {  Rectangle2 D data Area = info . get Data Area ( ) ; if ( data Area . contains ( x , y ) ) {  Value Axis xaxis = get Domain Axis ( ) ; if ( xaxis != null ) { double hvalue = xaxis . java2 DTo Value ( x , info . get Data Area ( ) , get Domain Axis Edge ( ) ) ; set Domain Crosshair Value ( hvalue ) ; }  Value Axis yaxis = get Range Axis ( ) ; if ( yaxis != null ) { double vvalue = yaxis . java2 DTo Value ( y , info . get Data Area ( ) , get Range Axis Edge ( ) ) ; set Range Crosshair Value ( vvalue ) ; } } }
public void test_park Until_2 ( ) throws  Exception {  Cyclic Barrier barrier = new  Cyclic Barrier ( _ NUM ) ;  Parker parker = new  Parker ( barrier , _ BOOL , _ NUM ) ;  Thread parker Thread = new  Thread ( parker ) ;  Thread waiter Thread = new  Thread ( new  Wait And Unpark ( barrier , _ NUM , parker Thread ) ) ; parker Thread . start ( ) ; waiter Thread . start ( ) ; parker . assert Duration Is In Range ( _ NUM ) ; waiter Thread . join ( ) ; parker Thread . join ( ) ; }
@  Override public  String to String ( ) {  String Builder risul = new  String Builder ( _ NUM ) ; risul . append ( classname ) ; risul . append ( _ STR ) ; return risul . to String ( ) ; }
private int decode Scalefactors ( float sf [ ] , int global Gain ,  Individual Channel Stream ics , int band Type [ ] , int band Type Run End [ ] ) { int idx = _ NUM ; int offset [ ] = { global Gain , global Gain - _ NUM , _ NUM } ; boolean noise Flag = _ BOOL ; for ( int g = _ NUM ; g < ics . num Window Groups ; g ++ ) { for ( int i = _ NUM ; i < ics . max Sfb ; ) { int run End = band Type Run End [ idx ] ; if ( band Type [ idx ] ==  ZERO_ BT ) { for ( ; i < run End ; i ++ , idx ++ ) { sf [ idx ] = _ NUM ; } } else if ( band Type [ idx ] ==  INTENSITY_ BT || band Type [ idx ] ==  INTENSITY_ BT2 ) { for ( ; i < run End ; i ++ , idx ++ ) { offset [ _ NUM ] += vlc_scalefactors . get VLC2 ( br , _ NUM ) - _ NUM ; int clipped Offset =  Utilities . clip ( offset [ _ NUM ] , - _ NUM , _ NUM ) ; if ( offset [ _ NUM ] != clipped Offset ) { log . warn (  String . format ( _ STR , offset [ _ NUM ] , clipped Offset ) ) ; } sf [ idx ] = ff_aac_pow2sf_tab [ - clipped Offset +  POW_ SF2_ ZERO ] ; } } else if ( band Type [ idx ] ==  NOISE_ BT ) { for ( ; i < run End ; i ++ , idx ++ ) { if ( noise Flag ) { offset [ _ NUM ] += br . read ( _ NUM ) - _ NUM ; noise Flag = _ BOOL ; } else { offset [ _ NUM ] += vlc_scalefactors . get VLC2 ( br , _ NUM ) - _ NUM ; } int clipped Offset =  Utilities . clip ( offset [ _ NUM ] , - _ NUM , _ NUM ) ; if ( offset [ _ NUM ] != clipped Offset ) { log . warn (  String . format ( _ STR , offset [ _ NUM ] , clipped Offset ) ) ; } sf [ idx ] = - ff_aac_pow2sf_tab [ clipped Offset +  POW_ SF2_ ZERO ] ; } } else { for ( ; i < run End ; i ++ , idx ++ ) { offset [ _ NUM ] += vlc_scalefactors . get VLC2 ( br , _ NUM ) - _ NUM ; if ( offset [ _ NUM ] > _ NUM ) { log . error (  String . format ( _ STR , offset [ _ NUM ] ) ) ; return  AAC_ ERROR ; } sf [ idx ] = - ff_aac_pow2sf_tab [ offset [ _ NUM ] - _ NUM +  POW_ SF2_ ZERO ] ; } } } } return _ NUM ; }
public  Task <  Void > handle Registration Intent Async (  Intent intent ) {  List <  Task <  Void > > tasks = new  Array List < > ( ) ;  String registration Id = intent . get String Extra (  REGISTRATION_ ID_ EXTRA ) ; if ( registration Id != null && registration Id . length ( ) > _ NUM ) {  PLog . v (  TAG , _ STR + registration Id + _ STR ) ;  Parse Installation installation =  Parse Installation . get Current Installation ( ) ; if ( ! registration Id . equals ( installation . get Device Token ( ) ) ) { installation . set Push Type (  Push Type .  GCM ) ; installation . set Device Token ( registration Id ) ; tasks . add ( installation . save In Background ( ) ) ; } tasks . add ( update Local Device Token Last Modified Async ( ) ) ; } synchronized ( lock ) { if ( request != null ) { request . on Receive Response Intent ( intent ) ; } } return  Task . when All ( tasks ) ; }
public static  Element create Element In Encryption11 Space (  Document doc ,  String element Name ) { if ( doc == null ) { throw new  Runtime Exception ( _ STR ) ; } if ( ( xenc11 Prefix == null ) || ( xenc11 Prefix . length ( ) == _ NUM ) ) { return doc . create Element NS (  Encryption Constants .  Encryption Spec11 NS , element Name ) ; } return doc . create Element NS (  Encryption Constants .  Encryption Spec11 NS , xenc11 Prefix + _ STR + element Name ) ; }
public boolean equals Default ( ) { return (  Float . float To Int Bits ( value ) == _ NUM ) ; }
protected void log Counters ( final  String basename ) { if ( is Transient ) { log . warn ( _ STR ) ; return ; } final  File file = new  File ( log Dir , _ STR + basename + _ STR ) ; log Counters ( file ) ; }
public void add Tele Missile Attack (  Attack Action ea ) { pending Tele Missile Attacks . add Element ( ea ) ; process Game Event ( new  Game New Action Event ( this , ea ) ) ; }
public void clear Commands ( ) { synchronized ( commands ) { commands . clear ( ) ; } update Images ( ) ; }
public  String to String ( ) {  String Buffer sb = new  String Buffer ( ) ; char [ ] separator = { _ STR , _ STR } ; for ( int i = _ NUM ; i < components . length ; i ++ ) { sb . append ( separator ) ; sb . append ( components [ i ] ) ; separator [ _ NUM ] = _ STR ; } sb . append ( _ STR ) ; return sb . to String ( ) ; }
public void add First (  Statement Sequence statements ) { if ( statements != null ) { sequence . add All ( _ NUM , statements . sequence ) ; } }
private void remove ( int hash Code ) { synchronized ( m Records ) {  Iterator <  Record > iterator = m Records . iterator ( ) ; while ( iterator . has Next ( ) ) {  Record record = (  Record ) iterator . next ( ) ; if ( record . m Hash Code == hash Code ) { iterator . remove ( ) ; } } } }
public double elasticity Forward ( ) { final double val = value ( ) ; final double del = delta Forward ( ) ; if ( val >  Constants .  QL_ EPSILON ) return del / val * forward ; else if (  Math . abs ( del ) <  Constants .  QL_ EPSILON ) return _ NUM ; else if ( del > _ NUM ) return  Double .  MAX_ VALUE ; else return  Double .  MIN_ VALUE ; }
private byte [ ] entity To Bytes (  Http Entity entity ) throws  IOException ,  Server Error {  Pooling Byte Array Output Stream bytes = new  Pooling Byte Array Output Stream ( m Pool , ( int ) entity . get Content Length ( ) ) ; byte [ ] buffer = null ; try {  Input Stream in = entity . get Content ( ) ; if ( in == null ) { throw new  Server Error ( ) ; } buffer = m Pool . get Buf ( _ NUM ) ; int count ; while ( ( count = in . read ( buffer ) ) != - _ NUM ) { bytes . write ( buffer , _ NUM , count ) ; } return bytes . to Byte Array ( ) ; } finally { try { entity . consume Content ( ) ; } catch (  IOException e ) {  Volley Log . v ( _ STR ) ; } m Pool . return Buf ( buffer ) ; bytes . close ( ) ; } }
public static float round Decimal ( float value , double places ) { double multiplier =  Math . pow ( _ NUM , places ) ; value *= multiplier ; return ( float ) (  Math . round ( value ) / multiplier ) ; }
@  Not Null public  Runner add Runner ( @  Not Null  Application Process Descriptor process Descriptor ) {  Run Options run Options = dto Factory . create Dto (  Run Options . class ) ;  Runner runner = models Factory . create Runner ( run Options ) ;  String environment Id = process Descriptor . get Environment Id ( ) ; if ( environment Id != null && environment Id . starts With (  PROJECT_ PREFIX ) ) { runner . set Scope (  PROJECT ) ; } runners Id . add ( process Descriptor . get Process Id ( ) ) ; runner . set Process Descriptor ( process Descriptor ) ; runner . set RAM ( process Descriptor . get Memory Size ( ) ) ; runner . set Status (  Runner .  Status .  DONE ) ; runner . reset Creation Time ( ) ; history . add Runner ( runner ) ; on Selection Changed (  RUNNER ) ; runner Timer . schedule (  ONE_ SEC . get Value ( ) ) ;  Launch Action launch Action = action Factory . create Launch ( ) ; runner Actions . put ( runner , launch Action ) ; launch Action . perform ( runner ) ; select History Tab ( ) ; return runner ; }
public static boolean is Windows7 ( ) { return os Name . index Of ( _ STR ) > - _ NUM && os Version . equals ( _ STR ) ; }
private  String boolean To String (  Boolean input ) { if ( input == null ) { return null ; } else { return input . to String ( ) ; } }
@  Override public int maximum Size (  Container container ,  List components ,  Form Layout .  Measure min Measure ,  Form Layout .  Measure pref Measure ,  Form Layout .  Measure default Measure ) {  Form Layout .  Measure measure = this ==  MINIMUM ? min Measure : ( this ==  PREFERRED ? pref Measure : default Measure ) ; int maximum = _ NUM ; for (  Iterator i = components . iterator ( ) ; i . has Next ( ) ; ) {  Component c = (  Component ) i . next ( ) ; maximum =  Math . max ( maximum , measure . size Of ( c ) ) ; } return maximum ; }
static void inflate Gens (  Segment Infos infos ,  Collection <  String > files ,  Info Stream info Stream ) { long max Segment Gen =  Long .  MIN_ VALUE ; int max Segment Name =  Integer .  MIN_ VALUE ;  Map <  String ,  Long > max Per Segment Gen = new  Hash Map < > ( ) ; for (  String file Name : files ) { if ( file Name . equals (  Index File Names .  OLD_ SEGMENTS_ GEN ) || file Name . equals (  Index Writer .  WRITE_ LOCK_ NAME ) ) { } else if ( file Name . starts With (  Index File Names .  SEGMENTS ) ) { try { max Segment Gen =  Math . max (  Segment Infos . generation From Segments File Name ( file Name ) , max Segment Gen ) ; } catch (  Number Format Exception ignore ) { } } else if ( file Name . starts With (  Index File Names .  PENDING_ SEGMENTS ) ) { try { max Segment Gen =  Math . max (  Segment Infos . generation From Segments File Name ( file Name . substring ( _ NUM ) ) , max Segment Gen ) ; } catch (  Number Format Exception ignore ) { } } else {  String segment Name =  Index File Names . parse Segment Name ( file Name ) ; assert segment Name . starts With ( _ STR ) : _ STR + file Name ; if ( file Name . to Lower Case (  Locale .  ROOT ) . ends With ( _ STR ) ) { continue ; } max Segment Name =  Math . max ( max Segment Name ,  Integer . parse Int ( segment Name . substring ( _ NUM ) ,  Character .  MAX_ RADIX ) ) ;  Long cur Gen = max Per Segment Gen . get ( segment Name ) ; if ( cur Gen == null ) { cur Gen = _ NUM ; } try { cur Gen =  Math . max ( cur Gen ,  Index File Names . parse Generation ( file Name ) ) ; } catch (  Number Format Exception ignore ) { } max Per Segment Gen . put ( segment Name , cur Gen ) ; } } infos . set Next Write Generation (  Math . max ( infos . get Generation ( ) , max Segment Gen ) ) ; if ( infos . counter < _ NUM + max Segment Name ) { if ( info Stream . is Enabled ( _ STR ) ) { info Stream . message ( _ STR , _ STR + ( _ NUM + max Segment Name ) + _ STR + infos . counter ) ; } infos . counter = _ NUM + max Segment Name ; } for (  Segment Commit Info info : infos ) {  Long gen = max Per Segment Gen . get ( info . info . name ) ; assert gen != null ; long gen Long = gen ; if ( info . get Next Write Del Gen ( ) < gen Long + _ NUM ) { if ( info Stream . is Enabled ( _ STR ) ) { info Stream . message ( _ STR , _ STR + info . info . name + _ STR + ( gen Long + _ NUM ) + _ STR + info . get Next Write Del Gen ( ) ) ; } info . set Next Write Del Gen ( gen Long + _ NUM ) ; } if ( info . get Next Write Field Infos Gen ( ) < gen Long + _ NUM ) { if ( info Stream . is Enabled ( _ STR ) ) { info Stream . message ( _ STR , _ STR + info . info . name + _ STR + ( gen Long + _ NUM ) + _ STR + info . get Next Write Field Infos Gen ( ) ) ; } info . set Next Write Field Infos Gen ( gen Long + _ NUM ) ; } if ( info . get Next Write Doc Values Gen ( ) < gen Long + _ NUM ) { if ( info Stream . is Enabled ( _ STR ) ) { info Stream . message ( _ STR , _ STR + info . info . name + _ STR + ( gen Long + _ NUM ) + _ STR + info . get Next Write Doc Values Gen ( ) ) ; } info . set Next Write Doc Values Gen ( gen Long + _ NUM ) ; } } }
public int compare (  Integer node1 ,  Integer node2 ) { double dist1 = distances From Start . get ( node1 ) ; double dist2 = distances From Start . get ( node2 ) ; if ( dist1 > dist2 ) { return _ NUM ; } else if ( dist1 < dist2 ) { return - _ NUM ; } else { return node1 . compare To ( node2 ) ; } }
@  Override public  Log Message read Next Log Message ( ) { while ( _ BOOL ) { if ( file Counter . get ( ) >= log Paths . size ( ) ) { break ; } if ( reader == null ) {  String file Path = log Paths . get ( file Counter . get ( ) ) ; try { reader = new  Log Reader ( file Path , request , status , basename ) ; } catch (  Exception e ) { status . append (  String . format ( _ STR , e . get Message ( ) ) ) ; logger . error ( _ STR , e . get Message ( ) ) ; return null ; } logger . debug ( _ STR + file Path ) ;  File f = new  File ( file Path ) ; size Counter . add And Get ( f . length ( ) ) ; } if ( current Log != null ) { prev Log Time = current Log . get Time ( ) ; } current Log = reader . read Next Log Message ( ) ; if ( current Log != null ) { log Counter . increment And Get ( ) ; current Log . set Service (  Log Util . service To Bytes ( basename ) ) ; if ( !  Log Util . permit Current Log ( request . get Max Count ( ) , log Counter . get ( ) , current Log . get Time ( ) , prev Log Time ) ) { break ; } return current Log ; } else { reader = null ; file Counter . increment And Get ( ) ; } } return null ; }
private void load Binary (  Byte Buffer bb ) throws  IOException { if ( bb . get Int ( ) !=  MAGIC ) { throw new  Error ( _ STR ) ; } if ( bb . get Int ( ) !=  VERSION ) { throw new  Error ( _ STR ) ; } continuity Weight = bb . get Int ( ) ; optimal Coupling = bb . get Int ( ) ; extend Selections = bb . get Int ( ) ; join Method = bb . get Int ( ) ; join Weight Shift = bb . get Int ( ) ; int weight Length = bb . get Int ( ) ; join Weights = new int [ weight Length ] ; for ( int i = _ NUM ; i < join Weights . length ; i ++ ) { join Weights [ i ] = bb . get Int ( ) ; } int units Length = bb . get Int ( ) ; units = new  Database Cluster Unit [ units Length ] ; for ( int i = _ NUM ; i < units . length ; i ++ ) { units [ i ] = new  Database Cluster Unit ( bb ) ; } int unit Types Length = bb . get Int ( ) ; unit Types = new  Unit Type [ unit Types Length ] ; for ( int i = _ NUM ; i < unit Types . length ; i ++ ) { unit Types [ i ] = new  Unit Type ( bb ) ; } sts = new  Sample Set ( bb ) ; mcep = new  Sample Set ( bb ) ; int num Carts = bb . get Int ( ) ; cart Map = new  Hash Map ( ) ; for ( int i = _ NUM ; i < num Carts ; i ++ ) {  String name =  Utilities . get String ( bb ) ;  CART cart =  CARTImpl . load Binary ( bb ) ; cart Map . put ( name , cart ) ; if ( default Cart == null ) { default Cart = cart ; } } }
public static  String to String ( int i ) { if ( i <  NUMBERS_ MIN || i >  NUMBERS_ MAX ) return  Integer . to String ( i , _ NUM ) ; return  NUMBERS [ i ] ; }
public  FSIDPAuthentication Context Info (  String info String ) throws  FSException { if ( info String == null ) { throw new  FSException ( _ STR , null ) ; }  String Tokenizer stk = new  String Tokenizer ( info String ,  IFSConstants .  ATTRIBUTE_ SEPARATOR ) ; while ( stk . has More Tokens ( ) ) {  String token = stk . next Token ( ) ; int equal Sign = token . index Of (  IFSConstants .  KEY_ VALUE_ SEPARATOR ) ; if ( equal Sign == - _ NUM ) { throw new  FSException ( _ STR , null ) ; } try {  String key = token . substring ( _ NUM , equal Sign ) ;  String value = token . substring ( equal Sign + _ NUM , token . length ( ) ) ; if ( key . equals Ignore Case (  IFSConstants .  AUTH_ CONTEXT_ NAME ) ) { authentication Context = value ; } else if ( key . equals Ignore Case (  IFSConstants .  MODULE_ INDICATOR_ KEY ) ) { module Indicator Key = value ; } else if ( key . equals Ignore Case (  IFSConstants .  MODULE_ INDICATOR_ VALUE ) ) { module Indicator Value = value ; } else if ( key . equals Ignore Case (  IFSConstants .  LEVEL ) ) { level =  Integer . parse Int ( value ) ; } else { throw new  FSException ( _ STR , null ) ; } } catch (  Index Out Of Bounds Exception ie ) { throw new  FSException ( _ STR , null ) ; } catch (  Number Format Exception ne ) { throw new  FSException ( _ STR , null ) ; } } if ( authentication Context == null || module Indicator Key == null || module Indicator Value == null || level == - _ NUM ) { throw new  FSException ( _ STR , null ) ; } }
public static  File savepoint File (  File instance Path ) {  File temp Dir = new  File (  Collect .  CACHE_ PATH ) ; return new  File ( temp Dir , instance Path . get Name ( ) + _ STR ) ; }
public  Selection Input Dialog (  Window owner ,  String key , boolean editable ,  Collection <  T > selection Values ,  T initial Selection Value ,  Input Validator <  T > input Validator ,  Object ... key Arguments ) { this ( owner , key , selection Values , initial Selection Value , input Validator , key Arguments ) ; combo Box . set Editable ( editable ) ; }
public void reload (  Solr Core core ,  Solr Index Searcher searcher ) throws  IOException {  LOG . info ( _ STR + name + _ STR ) ; if ( dictionary == null && store Dir != null ) {  File lookup File = get Store File ( ) ; if ( lookup File . exists ( ) ) {  File Input Stream is = new  File Input Stream ( lookup File ) ; try { if ( lookup . load ( is ) ) { return ; } } finally {  IOUtils . close While Handling Exception ( is ) ; } } else {  LOG . info ( _ STR ) ; } } }
@  Override public void write ( int b ) { int new Cnt = cnt + _ NUM ; if ( new Cnt > buf . length ) buf =  Arrays . copy Of ( buf ,  Math . max ( buf . length << _ NUM , new Cnt ) ) ; buf [ cnt ] = ( byte ) b ; cnt = new Cnt ; }
public void create Vm Async ( final  String project Id , final  Vm Create Spec vm Create Spec , final  Future Callback <  Task > response Callback ) throws  IOException { final  String path =  String . format ( _ STR , get Base Path ( ) , project Id ) ; create Object Async ( path , serialize Object As Json ( vm Create Spec ) , response Callback ) ; }
@  Override public boolean domain Match ( final  String host , final  String domain ) { final boolean match = host . equals ( domain ) || ( domain . starts With ( _ STR ) && host . ends With ( domain ) ) ; return match ; }
public synchronized void enable Attribute (  String name ) throws java . lang .  Illegal Argument Exception { if ( name == null ) { throw new java . lang .  Illegal Argument Exception ( _ STR ) ; } if ( ! enabled Attributes . contains ( name ) ) { enabled Attributes . add Element ( name ) ; } }
public void load (  Input Stream in Stream ) throws  IOException {  Properties properties = new  Properties ( ) ; properties . load ( in Stream ) ; for (  Map .  Entry <  Object ,  Object > property : properties . entry Set ( ) ) {  String handle Id = (  String ) property . get Key ( ) ;  String value = (  String ) property . get Value ( ) ;  Property Table handle Properties = new  Property Table ( ) ;  JSONObject json Object = (  JSONObject )  JSONValue . parse ( value ) ; if ( json Object != null ) { handle Properties . put All ( json Object ) ; }  Handle handle = new  Handle ( ) ; handle . set Id ( handle Id ) ; handle . set Properties ( handle Properties ) ; handles . put ( handle Id , handle ) ; } }
public static  String [ ] split ( final  Char Sequence char Sequence , final char separator ) { if ( is Empty ( char Sequence ) ) { return  EMPTY_ ARRAY ; } final int original Separators Count = count Separated Char Appearances ( char Sequence , separator ) ; int separators Count = original Separators Count ; if ( starts With ( char Sequence , separator ) ) { separators Count -- ; } if ( char Sequence . length ( ) > _ NUM && ends With ( char Sequence , separator ) ) { separators Count -- ; } if ( separators Count <= _ NUM ) { if ( original Separators Count == _ NUM ) { return new  String [ ] { char Sequence . to String ( ) } ; } else if ( is Same Char ( char Sequence ) ) { return  EMPTY_ ARRAY ; } return new  String [ ] { remove Character ( char Sequence . to String ( ) , separator ) } ; } final  String [ ] result = new  String [ separators Count + _ NUM ] ; int current Result Index = _ NUM ; final  String Builder builder = new  String Builder ( ) ; for ( int index = _ NUM , length = char Sequence . length ( ) ; index < length ; index ++ ) { final char character = char Sequence . char At ( index ) ; if ( character == separator ) { if ( is Not Empty ( builder ) ) { result [ current Result Index ++ ] = builder . to String ( ) ; clear Builder ( builder ) ; } } else { builder . append ( character ) ; } } if ( is Not Empty ( builder ) ) { result [ current Result Index ++ ] = builder . to String ( ) ; } return result ; }
private static void assert Change Events (  Collection <  Port Change Event > early Events ,  Collection <  Port Change Event > late Events ,  Collection <  Port Change Event > anytime Events ,  Collection <  Port Change Event > actual Events ) {  String input Desc =  String . format ( _ STR + _ STR , early Events . to String ( ) , late Events . to String ( ) , anytime Events . to String ( ) , actual Events . to String ( ) ) ;  Collection <  Port Change Event > early = new  Array List <  Port Change Event > ( early Events ) ;  Collection <  Port Change Event > late = new  Array List <  Port Change Event > ( late Events ) ;  Collection <  Port Change Event > any = new  Array List <  Port Change Event > ( anytime Events ) ; for (  Port Change Event ev : early ) { assert False ( _ STR , late . contains ( ev ) ) ; assert False ( _ STR , any . contains ( ev ) ) ; } for (  Port Change Event ev : late ) { assert False ( _ STR , early . contains ( ev ) ) ; assert False ( _ STR , any . contains ( ev ) ) ; } for (  Port Change Event ev : any ) { assert False ( _ STR , early . contains ( ev ) ) ; assert False ( _ STR , late . contains ( ev ) ) ; } for (  Port Change Event a : actual Events ) { if ( early . remove ( a ) ) { continue ; } if ( any . remove ( a ) ) { continue ; } if ( late . remove ( a ) ) { if ( ! early . is Empty ( ) ) { fail ( a + _ STR + _ STR + input Desc ) ; } else { continue ; } } fail ( a + _ STR + input Desc ) ; } if ( ! early . is Empty ( ) ) fail ( _ STR + early + _ STR + input Desc ) ; if ( ! late . is Empty ( ) ) fail ( _ STR + late + _ STR + input Desc ) ; if ( ! any . is Empty ( ) ) fail ( _ STR + any + _ STR + input Desc ) ; }
public void print (  Print Writer output ,  Number Format format , int width ) { output . println ( ) ; for ( int i = _ NUM ; i < m ; i ++ ) { for ( int j = _ NUM ; j < n ; j ++ ) {  String s = format . format (  A [ i ] [ j ] ) ; int padding =  Math . max ( _ NUM , width - s . length ( ) ) ; for ( int k = _ NUM ; k < padding ; k ++ ) { output . print ( _ STR ) ; } output . print ( s ) ; } output . println ( ) ; } output . println ( ) ; }
public void add Element (  Object Property element ) { assert Not Null ( element ) ; if ( elements == null ) { elements = new  Array List <  Object Property > ( ) ; } elements . add ( element ) ; element . set Parent ( this ) ; }
public static void srs_print_bytes (  String tag ,  Byte Buffer bb , int size ) {  String Builder sb = new  String Builder ( ) ; int i = _ NUM ; int bytes_in_line = _ NUM ; int max = bb . remaining ( ) ; for ( i = _ NUM ; i < size && i < max ; i ++ ) { sb . append (  String . format ( _ STR ,  Integer . to Hex String ( bb . get ( i ) & _ NUM ) ) ) ; if ( ( ( i + _ NUM ) % bytes_in_line ) == _ NUM ) {  Log . i ( tag ,  String . format ( _ STR , i / bytes_in_line * bytes_in_line , i , sb . to String ( ) ) ) ; sb = new  String Builder ( ) ; } } if ( sb . length ( ) > _ NUM ) {  Log . i ( tag ,  String . format ( _ STR , size / bytes_in_line * bytes_in_line , i - _ NUM , sb . to String ( ) ) ) ; } }
public  Array Field Vector (  T [ ] v1 ,  Field Vector <  T > v2 ) throws  Null Argument Exception {  Math Utils . check Not Null ( v1 ) ;  Math Utils . check Not Null ( v2 ) ; field = v2 . get Field ( ) ; final  T [ ] v2 Data = ( v2 instanceof  Array Field Vector ) ? ( (  Array Field Vector <  T > ) v2 ) . data : v2 . to Array ( ) ; data =  Math Arrays . build Array ( field , v1 . length + v2 Data . length ) ;  System . arraycopy ( v1 , _ NUM , data , _ NUM , v1 . length ) ;  System . arraycopy ( v2 Data , _ NUM , data , v1 . length , v2 Data . length ) ; }
public void stop ( ) { if ( s Logger . is Activated ( ) ) { s Logger . info ( _ STR ) ; } m Check Handler . remove Messages (  CHECK_ MESSAGE ) ; if ( m Observer Is Registered ) { m Contacts Contract Cursor . unregister Content Observer ( m Contacts Contract Observer ) ; m Observer Is Registered = _ BOOL ; m Contacts Contract Cursor . close ( ) ; } m Cleanup Executor . shutdown Now ( ) ; }
protected final void fire Vetoable Change (  String property Name , float old Value , float new Value ) throws  Property Veto Exception { fire Vetoable Change ( property Name ,  Float . value Of ( old Value ) ,  Float . value Of ( new Value ) ) ; }
public void test LMJelinek Mercer ( ) throws  IOException { float p = ( _ NUM - _ NUM ) *  FREQ /  DOC_ LEN + _ NUM * (  TOTAL_ TERM_ FREQ + _ NUM ) / (  NUMBER_ OF_ FIELD_ TOKENS + _ NUM ) ; float gold = ( float ) (  Math . log ( p / ( _ NUM * (  TOTAL_ TERM_ FREQ + _ NUM ) / (  NUMBER_ OF_ FIELD_ TOKENS + _ NUM ) ) ) ) ; correctness Test Core ( new  LMJelinek Mercer Similarity ( _ NUM ) , gold ) ; }
private void await All ( ) throws  Interrupted Exception ,  Execution Exception { if ( buffer . is Open ( ) ) { throw new  Illegal State Exception ( ) ; } will Shutdown ( ) ; while ( _ BOOL ) { halted ( ) ; final  E [ ] a ; lock . lock Interruptibly ( ) ; try { a = redirect Queue . poll ( ) ; if ( a == null ) { if ( finished Subtask Queue . is Empty ( ) && sinks . is Empty ( ) && redirect Queue . is Empty ( ) && nothing Pending ( ) ) { if ( log . is Info Enabled ( ) ) log . info ( _ STR + this ) ; return ; } if ( log . is Debug Enabled ( ) ) log . debug ( _ STR + sinks . size ( ) + _ STR + this ) ; drain Futures ( ) ; if ( ! finished Subtask Queue . is Empty ( ) ) { subtask Done . await ( _ NUM ,  Time Unit .  MILLISECONDS ) ; } } } finally { lock . unlock ( ) ; } if ( a != null ) { handle Chunk ( a , _ BOOL ) ; } } }
@  Transactional public  Role DTO save (  Role DTO dto ) { if ( dto == null ) { return null ; }  Role role ; if ( dto . is Id Set ( ) ) { role = role Repository . find One ( dto . id ) ; } else { role = new  Role ( ) ; } role . set Role Name ( dto . role Name ) ; return to DTO ( role Repository . save ( role ) ) ; }
public void write External Index Drop Stmt (  Table table ,  IIndex index ,  String Builder ddl ) { if ( database Info . is Alter Table For Drop Used ( ) ) { write Table Alter Stmt ( table , ddl ) ; } ddl . append ( _ STR ) ; print Identifier ( get Index Name ( index ) , ddl ) ; if ( ! database Info . is Alter Table For Drop Used ( ) ) { ddl . append ( _ STR ) ; ddl . append ( get Fully Qualified Table Name Shorten ( table ) ) ; } print End Of Statement ( ddl ) ; }
public void obtain ( ) throws  IOException { if ( file Lock != null && file Lock . is Valid ( ) ) { return ; } file Lock = file To Lock . lock ( ) ; }
@  Override public void delete Rows ( int start , int len ) throws  Fits Exception { try { if ( this . n Rows == _ NUM || start < _ NUM || start >= this . n Rows || len <= _ NUM ) { return ; } if ( start + len > this . n Rows ) { len = this . n Rows - start ; } ensure Data ( ) ; for ( int i = _ NUM ; i < this . n Fields ; i += _ NUM ) {  Object o =  Array Funcs . new Instance ( this . types [ i ] , this . n Rows - len ) ;  System . arraycopy ( this . data [ i ] , _ NUM , o , _ NUM , start ) ;  System . arraycopy ( this . data [ i ] , start + len , o , start , this . n Rows - len - start ) ; this . data [ i ] = o ; } this . n Rows -= len ; } catch (  Fits Exception e ) { throw e ; } catch (  Exception e ) { throw new  Fits Exception ( _ STR + e . get Message ( ) , e ) ; } }
public static boolean open Editors ( @  Not Null  Project project , @  Not Null  Collection <  File > files , boolean select ) { if ( files . size ( ) > _ NUM ) { boolean result = _ BOOL ;  Virtual File last = null ; for (  File file : files ) { if ( file . exists ( ) ) {  Virtual File v File =  Vfs Util . find File By Io File ( file , _ BOOL ) ; if ( v File != null ) { result &= open Editor ( project , v File ) ; last = v File ; } else { result = _ BOOL ; } } } if ( select && last != null ) { select Editor ( project , last ) ; } return result ; } return _ BOOL ; }
private void update Tick Visibility ( ) { tick Visibilities . clear ( ) ; for ( int i = _ NUM ; i < tick Label Positions . size ( ) ; i ++ ) { tick Visibilities . add (  Boolean .  TRUE ) ; } if ( tick Label Positions . size ( ) == _ NUM ) { return ; } int previous Position = _ NUM ;  String previous Label = null ; for ( int i = _ NUM ; i < tick Label Positions . size ( ) ; i ++ ) { boolean has Space To Draw = _ BOOL ; if ( i != _ NUM ) { has Space To Draw = has Space To Draw ( previous Position , tick Label Positions . get ( i ) , previous Label , tick Labels . get ( i ) ) ; }  String current Label = tick Labels . get ( i ) ; boolean is Repeat Same Tick And Not End = current Label . equals ( previous Label ) && ( i != _ NUM && i != tick Label Positions . size ( ) - _ NUM ) ; boolean is Major Tick Or End = _ BOOL ; if ( scale . is Log Scale Enabled ( ) ) { is Major Tick Or End = is Major Tick ( tick Label Values . get ( i ) ) || i == _ NUM || i == tick Label Positions . size ( ) - _ NUM ; } if ( ! has Space To Draw || is Repeat Same Tick And Not End || ! is Major Tick Or End ) { tick Visibilities . set ( i ,  Boolean .  FALSE ) ; } else { previous Position = tick Label Positions . get ( i ) ; previous Label = current Label ; } } }
private void finish String Section (  List <  String Section > sections ,  String Section current Section ,  String Builder template Expressions ,  Position last Source Position ,  Position target Position ) { if ( current Section . last Source Position != null ) { return ; } current Section . last Source Position = new  Position ( last Source Position ) ; sections . add ( current Section ) ; append ( template Expressions , target Position , _ STR + index ++ + _ STR ) ; current Section . last Target Position = new  Position ( target Position . row , target Position . column ) ; }
private  T select Pivot ( int from , int to ) { int count = ( int ) ( _ NUM *  Math . log10 ( to - from ) ) ; count =  Math . min ( count , temp . length ) ; int step = ( to - from ) / count ; for ( int i = from , j = _ NUM ; i < to ; i += step , j ++ ) { temp [ j ] = data [ i ] ; }  T pivot = select ( temp , _ NUM , count - _ NUM , count / _ NUM ) ; return pivot ; }
public boolean has Badge ( @  Id Res final int item Id ) { return map . contains ( item Id ) ; }
public  Options put (  String option ,  Boolean value ) { if ( value == null ) { return remove ( option ) ; } options . put ( option ,  Boolean . to String ( value ) ) ; return this ; }
private boolean page Scrolled ( int x Pos ) { if ( items . size ( ) == _ NUM ) { return _ BOOL ; } final int delta Scroll = x Pos - last Scroll ; virtual Pos = reverse Pos ? virtual Pos + delta Scroll : virtual Pos - delta Scroll ; last Scroll = x Pos ; final int width = get Client Width ( ) ; final float page Offset = virtual Pos / width ; if ( on Card Change Listener != null ) { on Card Change Listener . on Card Scrolled ( current Item , page Offset , ( int ) virtual Pos ) ; } on Page Scrolled ( ) ; return _ BOOL ; }
protected  String form (  Double Matrix1 D matrix , int index ,  Former formatter ) { return formatter . form ( matrix . get ( index ) ) ; }
public void enable (  Bluetooth Adapter adapter ) { int mask = (  Bluetooth Receiver .  STATE_ TURNING_ ON_ FLAG |  Bluetooth Receiver .  STATE_ ON_ FLAG |  Bluetooth Receiver .  SCAN_ MODE_ CONNECTABLE_ FLAG ) ; long start = - _ NUM ;  Bluetooth Receiver receiver = get Bluetooth Receiver ( mask ) ; int state = adapter . get State ( ) ; switch ( state ) { case  Bluetooth Adapter .  STATE_ ON : assert True ( adapter . is Enabled ( ) ) ; remove Receiver ( receiver ) ; return ; case  Bluetooth Adapter .  STATE_ TURNING_ ON : assert False ( adapter . is Enabled ( ) ) ; mask = _ NUM ; break ; case  Bluetooth Adapter .  STATE_ OFF : assert False ( adapter . is Enabled ( ) ) ; start =  System . current Time Millis ( ) ; assert True ( adapter . enable ( ) ) ; break ; case  Bluetooth Adapter .  STATE_ TURNING_ OFF : start =  System . current Time Millis ( ) ; assert True ( adapter . enable ( ) ) ; break ; default : remove Receiver ( receiver ) ; fail (  String . format ( _ STR , state ) ) ; } long s =  System . current Time Millis ( ) ; while (  System . current Time Millis ( ) - s <  ENABLE_ DISABLE_ TIMEOUT ) { state = adapter . get State ( ) ; if ( state ==  Bluetooth Adapter .  STATE_ ON && ( receiver . get Fired Flags ( ) & mask ) == mask ) { assert True ( adapter . is Enabled ( ) ) ; long finish = receiver . get Completed Time ( ) ; if ( start != - _ NUM && finish != - _ NUM ) { write Output (  String . format ( _ STR , ( finish - start ) ) ) ; } else { write Output ( _ STR ) ; } remove Receiver ( receiver ) ; return ; } sleep (  POLL_ TIME ) ; } int fired Flags = receiver . get Fired Flags ( ) ; remove Receiver ( receiver ) ; fail (  String . format ( _ STR , state ,  Bluetooth Adapter .  STATE_ ON , fired Flags , mask ) ) ; }
public static int parse Major Java Version (  String version ) {  String jvm Version = version ; if ( jvm Version . starts With ( _ STR ) ) { jvm Version = jvm Version . substring ( _ NUM ) ; } int separator = jvm Version . index Of ( _ STR ) ; if ( separator > _ NUM ) { jvm Version = jvm Version . substring ( _ NUM , separator ) ; } separator = jvm Version . index Of ( _ STR ) ; if ( separator > _ NUM ) { jvm Version = jvm Version . substring ( _ NUM , separator ) ; } return  Integer . parse Int ( jvm Version ) ; }
protected  Boolean Literal ( boolean value ) { super (  Boolean . to String ( value ) ,  XMLSchema .  BOOLEAN ) ; this . value = value ; }
private static  Vector <  String > ins String To Stringified Comps (  String str ) throws  Invalid Name Exception { int len = str . length ( ) ;  Vector <  String > components = new  Vector < > ( _ NUM ) ; char [ ] id = new char [ len ] ; char [ ] kind = new char [ len ] ; int id Count , kind Count ; boolean id Mode ; for ( int i = _ NUM ; i < len ; ) { id Count = kind Count = _ NUM ; id Mode = _ BOOL ; while ( i < len ) { if ( str . char At ( i ) == comp Separator ) { break ; } else if ( str . char At ( i ) == escape Char ) { if ( i + _ NUM >= len ) { throw new  Invalid Name Exception ( str + _ STR ) ; } else if ( is Meta ( str . char At ( i + _ NUM ) ) ) { ++ i ; if ( id Mode ) { id [ id Count ++ ] = str . char At ( i ++ ) ; } else { kind [ kind Count ++ ] = str . char At ( i ++ ) ; } } else { throw new  Invalid Name Exception ( str + _ STR ) ; } } else if ( id Mode && str . char At ( i ) == kind Separator ) { ++ i ; id Mode = _ BOOL ; } else { if ( id Mode ) { id [ id Count ++ ] = str . char At ( i ++ ) ; } else { kind [ kind Count ++ ] = str . char At ( i ++ ) ; } } } components . add Element ( stringify Component ( new  Name Component ( new  String ( id , _ NUM , id Count ) , new  String ( kind , _ NUM , kind Count ) ) ) ) ; if ( i < len ) { ++ i ; } } return components ; }
private static void add Entries For Infrequent Blocks (  IR ir ,  Live Analysis live ,  Hash Map <  Basic Block Pair ,  Hash Set <  Register > > result ) { for (  Enumeration <  Basic Block > e = ir . get Basic Blocks ( ) ; e . has More Elements ( ) ; ) {  Basic Block bb = e . next Element ( ) ; boolean bb Infrequent = bb . get Infrequent ( ) ; for (  Enumeration <  Basic Block > out = bb . get Normal Out ( ) ; out . has More Elements ( ) ; ) {  Basic Block dest = out . next Element ( ) ; boolean dest Infrequent = dest . get Infrequent ( ) ; if ( bb Infrequent ^ dest Infrequent ) {  Hash Set <  Register > live Registers = live . get Live Registers On Edge ( bb , dest ) ; for (  Register r : live Registers ) { if ( r . is Symbolic ( ) ) {  Hash Set <  Register > s = find Or Create Split Set ( result , bb , dest ) ; s . add ( r ) ; } } } } } }
public void test Split And Join Multiple Properties On Semicolon ( ) {  Properties inner =  Property Utils . split Properties On Delimiter (  ONE_ SEMI_ TWO , _ STR ) ; assert Equals ( _ STR , inner . get Property ( _ STR ) ) ; assert Equals ( _ STR , inner . get Property ( _ STR ) ) ; assert Equals ( _ NUM , inner . size ( ) ) ; try { assert Equals (  ONE_ SEMI_ TWO ,  Property Utils . join On Semicolon (  Property Utils . to Map ( inner ) ) ) ; } catch (  Comparison Failure e ) { assert Equals (  TWO_ SEMI_ ONE ,  Property Utils . join On Semicolon (  Property Utils . to Map ( inner ) ) ) ; } }
public static void insert Object At Offset (  Object [ ] source Array ,  Object [ ] destination Array , int offset ,  Object o ) { if ( offset == _ NUM ) { destination Array [ _ NUM ] = o ;  System . arraycopy ( source Array , _ NUM , destination Array , _ NUM , source Array . length ) ; } else { if ( offset == source Array . length ) {  System . arraycopy ( source Array , _ NUM , destination Array , _ NUM , source Array . length ) ; destination Array [ source Array . length ] = o ; } else {  System . arraycopy ( source Array , _ NUM , destination Array , _ NUM , offset ) ; destination Array [ offset ] = o ;  System . arraycopy ( source Array , offset , destination Array , offset + _ NUM , source Array . length - offset ) ; } } }
private void create From Assets (  String db Name ,  File dbfile ,  Input Stream asset File Input Stream ) {  Output Stream out = null ; try {  Log . v ( _ STR , _ STR ) ;  String db Path = dbfile . get Absolute Path ( ) ; db Path = db Path . substring ( _ NUM , db Path . last Index Of ( _ STR ) + _ NUM ) ;  File db Path File = new  File ( db Path ) ; if ( ! db Path File . exists ( ) ) db Path File . mkdirs ( ) ;  File new Db File = new  File ( db Path + db Name ) ; out = new  File Output Stream ( new Db File ) ; byte [ ] buf = new byte [ _ NUM ] ; int len ; while ( ( len = asset File Input Stream . read ( buf ) ) > _ NUM ) out . write ( buf , _ NUM , len ) ;  Log . v ( _ STR , _ STR + new Db File . get Absolute Path ( ) ) ; } catch (  IOException e ) {  Log . v ( _ STR , _ STR + e . get Message ( ) ) ; } finally { if ( out != null ) { try { out . close ( ) ; } catch (  IOException ignored ) { } } } }
public  Kafka Consumer (  Kafka Stream < byte [ ] , byte [ ] > stream ) { _logger . debug ( _ STR ) ; _stream = stream ; }
public void organize ( ) { if (  DEBUG ) { logger . fine ( _ STR ) ; } init File Holder ( ) ;  Iterator it = filenames . iterator ( ) ;  DTEDName Translator dnt = get Translator ( ) ; while ( it . has Next ( ) ) {  File file = (  File ) it . next ( ) ;  String filename = file . get Absolute Path ( ) ; try { dnt . set ( filename ) ; int l = dnt . get Level ( ) ; int lt = ( int ) ( dnt . get Lat ( ) + _ NUM ) ; int ln = ( int ) ( dnt . get Lon ( ) + _ NUM ) ; if (  DEBUG ) { logger . fine ( _ STR + filename + _ STR + l + _ STR + lt + _ STR + ln + _ STR ) ; } files [ l ] [ lt ] [ ln ] = file ; } catch (  Format Exception fe ) { continue ; } catch (  Array Index Out Of Bounds Exception aioobe ) { continue ; } } }
public boolean matches (  String expected ) { skip Whitespace ( ) ; for ( int i = _ NUM ; i < expected . length ( ) ; i ++ ) { if ( i + n >= s . length ( ) ) return _ BOOL ; if (  Character . to Upper Case ( s . char At ( i + n ) ) !=  Character . to Upper Case ( expected . char At ( i ) ) ) return _ BOOL ; } n += expected . length ( ) ; return _ BOOL ; }
public short read Short ( ) throws  IOException { return dis . read Short ( ) ; }
public void print ( boolean bool ) { print (  String . value Of ( bool ) ) ; }
public static <  Node Type >  Collection <  Node Type > collect Nodes ( final  Collection < ? extends  Node Type > nodes , final  INode Filter <  Node Type > filter ) {  Preconditions . check Not Null ( nodes , _ STR ) ;  Preconditions . check Not Null ( filter , _ STR ) ; final  Collection <  Node Type > filtered Nodes = new  Array List <  Node Type > ( ) ; for ( final  Node Type child : nodes ) { if ( filter . qualifies ( child ) ) { filtered Nodes . add ( child ) ; } } return filtered Nodes ; }
public static boolean is Backend Export Mask (  Db Client db Client ,  Export Mask export Mask ) {  Set <  URI > initiator URIs =  Export Mask Utils . get All Initiators For Export Mask ( db Client , export Mask ) ; if ( initiator URIs != null && ! initiator URIs . is Empty ( ) ) {  List <  Initiator > initiators = db Client . query Object (  Initiator . class , initiator URIs ) ; if ( initiators != null ) { return are Backend Initiators ( initiators ) ; } } return _ BOOL ; }
public  Sequence Sprite (  Sequence Sprite Listener listener ,  Sprite [ ] frames , int delay ) { super ( frames , delay ) ; loop = _ BOOL ; last Update =  System . current Time Millis ( ) ; this . listener = listener ; }
private void navigate To Child (  String starts With ) {  Tree Path current Path = tree . get Selection Path ( ) ;  Default Mutable Tree Node dump Node = (  Default Mutable Tree Node ) current Path . get Last Path Component ( ) ;  Enumeration childs = dump Node . children ( ) ;  Tree Path search Path = null ; while ( ( search Path == null ) && childs . has More Elements ( ) ) {  Default Mutable Tree Node child = (  Default Mutable Tree Node ) childs . next Element ( ) ;  String name = child . to String ( ) ; if ( name != null && name . starts With ( starts With ) ) { search Path = new  Tree Path ( child . get Path ( ) ) ; } } if ( search Path != null ) { tree . make Visible ( search Path ) ; tree . set Selection Path ( search Path ) ; tree . scroll Path To Visible ( search Path ) ; } }
void update Day Counter ( final long new Messages ) {  Gregorian Calendar cal = new  Gregorian Calendar ( ) ; int current Index = cal . get (  Calendar .  HOUR_ OF_ DAY ) ; boolean b Update = _ BOOL ; for ( int i = _ NUM ; i <= current Index ; i ++ ) { if ( counters [ i ] > - _ NUM ) { b Update = _ BOOL ; } if ( b Update == _ BOOL ) { if ( counters [ i ] == - _ NUM ) { counters [ i ] = _ NUM ; } } } counters [ current Index ] += new Messages ; }
public int swap ( ) { if ( ! m Egl . egl Swap Buffers ( m Egl Display , m Egl Surface ) ) { return m Egl . egl Get Error ( ) ; } return  EGL10 .  EGL_ SUCCESS ; }
public static  List <  Window > windows (  Input Stream words , int window Size ) {  Tokenizer tokenizer = new  Default Stream Tokenizer ( words ) ;  List <  String > list = new  Array List < > ( ) ; while ( tokenizer . has More Tokens ( ) ) list . add ( tokenizer . next Token ( ) ) ; return windows ( list , window Size ) ; }
protected void draw Center Text (  Canvas c ) {  String center Text = m Chart . get Center Text ( ) ; if ( m Chart . is Draw Center Text Enabled ( ) && center Text != null ) {  Point F center = m Chart . get Center Circle Box ( ) ;  String [ ] lines = center Text . split ( _ STR ) ; float maxlineheight = _ NUM ; for (  String line : lines ) { float cur Height =  Utils . calc Text Height ( m Center Text Paint , line ) ; if ( cur Height > maxlineheight ) maxlineheight = cur Height ; } float linespacing = maxlineheight * _ NUM ; float totalheight = maxlineheight * lines . length - linespacing * ( lines . length - _ NUM ) ; int cnt = lines . length ; float y = center . y ; for ( int i = _ NUM ; i < lines . length ; i ++ ) {  String line = lines [ lines . length - i - _ NUM ] ; c . draw Text ( line , center . x , y + maxlineheight * cnt - totalheight / _ NUM , m Center Text Paint ) ; cnt -- ; y -= linespacing ; } } }
public  XPattern Tokenizer (  Attribute Factory factory ,  Pattern pattern , int group ) { super ( factory ) ; this . group = group ; matcher = pattern . matcher ( _ STR ) ; if ( group >= _ NUM && group > matcher . group Count ( ) ) { throw new  Illegal Argument Exception ( _ STR + matcher . group Count ( ) + _ STR ) ; } }
private static  Object add ( final  Object array , final int index , final  Object element , final  Class < ? > clss ) { if ( array == null ) { if ( index != _ NUM ) { throw new  Index Out Of Bounds Exception ( _ STR + index + _ STR ) ; } final  Object joined Array =  Array . new Instance ( clss , _ NUM ) ;  Array . set ( joined Array , _ NUM , element ) ; return joined Array ; } final int length =  Array . get Length ( array ) ; if ( index > length || index < _ NUM ) { throw new  Index Out Of Bounds Exception ( _ STR + index + _ STR + length ) ; } final  Object result =  Array . new Instance ( clss , length + _ NUM ) ;  System . arraycopy ( array , _ NUM , result , _ NUM , index ) ;  Array . set ( result , index , element ) ; if ( index < length ) {  System . arraycopy ( array , index , result , index + _ NUM , length - index ) ; } return result ; }
private void update Min Max (  V feature Vector , double [ ] minima , double [ ] maxima ) { if ( minima . length != feature Vector . get Dimensionality ( ) ) { throw new  Illegal Argument Exception ( _ STR ) ; } for ( int d = _ NUM ; d < feature Vector . get Dimensionality ( ) ; d ++ ) { if ( ( feature Vector . double Value ( d ) ) > maxima [ d ] ) { maxima [ d ] = ( feature Vector . double Value ( d ) ) ; } if ( ( feature Vector . double Value ( d ) ) < minima [ d ] ) { minima [ d ] = ( feature Vector . double Value ( d ) ) ; } } }
public  String to Matlab ( ) {  String Buffer result ; int i ; int n ; result = new  String Buffer ( ) ; result . append ( _ STR ) ; for ( i = _ NUM ; i < m_size ; i ++ ) { if ( i > _ NUM ) { result . append ( _ STR ) ; } for ( n = _ NUM ; n < m_size ; n ++ ) { if ( n > _ NUM ) { result . append ( _ STR ) ; } result . append ( get Cell ( i , n ) ) ; } } result . append ( _ STR ) ; return result . to String ( ) ; }
public  File Input Reader (  String f ) throws  IOException { if (  Debug . debugging ( _ STR ) ) {  Debug . output ( _ STR + f ) ; }  File file = new  File ( f ) ; name = file . get Name ( ) ; absolute Path = file . get Absolute Path ( ) ; input File = init ( file ) ; }
public static  Buffered Output Stream new Output Stream (  Path self ) throws  IOException { return new  Buffered Output Stream (  Files . new Output Stream ( self ) ) ; }
public synchronized  Set <  K > key Set ( ) {  Hash Set <  K > set = new  Hash Set <  K > ( ) ; for (  Segment <  K ,  V > s : segments ) { set . add All ( s . key Set ( ) ) ; } return set ; }
private  Certificate Token deal Signature ( final  Advanced Signature signature , final  Xml Signature xml Signature ) { final  Advanced Signature master Signature = signature . get Master Signature ( ) ; if ( master Signature != null ) { xml Signature . set Type (  Attribute Value .  COUNTERSIGNATURE ) ; xml Signature . set Parent Id ( master Signature . get Id ( ) ) ; } perform Structural Validation ( signature , xml Signature ) ; perform Signature Cryptographic Validation ( signature , xml Signature ) ; xml Signature . set Id ( signature . get Id ( ) ) ; xml Signature . set Date Time ( signature . get Signing Time ( ) ) ; final  Signature Level data Found Up To Level = signature . get Data Found Up To Level ( ) ; final  String value = data Found Up To Level == null ? _ STR : data Found Up To Level . name ( ) ; xml Signature . set Signature Format ( value ) ; deal With Signature Production Place ( signature , xml Signature ) ; deal With Commitment Type Indication ( signature , xml Signature ) ; deal With Claimed Role ( signature , xml Signature ) ; final  String content Type = signature . get Content Type ( ) ; xml Signature . set Content Type ( content Type ) ; final  String content Identifier = signature . get Content Identifier ( ) ; xml Signature . set Content Identifier ( content Identifier ) ; final  String content Hints = signature . get Content Hints ( ) ; xml Signature . set Content Hints ( content Hints ) ; deal With Certified Role ( signature , xml Signature ) ; final  Certificate Validity certificate Validity = deal Signing Certificate ( signature , xml Signature ) ; final  Xml Basic Signature Type xml Basic Signature = get Xml Basic Signature Type ( xml Signature ) ; final  Encryption Algorithm encryption Algorithm = signature . get Encryption Algorithm ( ) ; final  String encryption Algorithm String = encryption Algorithm == null ? _ STR : encryption Algorithm . get Name ( ) ; xml Basic Signature . set Encryption Algo Used To Sign This Token ( encryption Algorithm String ) ; final  Certificate Token signing Certificate Token = certificate Validity == null ? null : certificate Validity . get Certificate Token ( ) ; final int key Length = signing Certificate Token == null ? _ NUM :  DSSPKUtils . get Public Key Size ( signing Certificate Token . get Public Key ( ) ) ; xml Basic Signature . set Key Length Used To Sign This Token (  String . value Of ( key Length ) ) ; final  Digest Algorithm digest Algorithm = signature . get Digest Algorithm ( ) ; final  String digest Algorithm String = digest Algorithm == null ? _ STR : digest Algorithm . get Name ( ) ; xml Basic Signature . set Digest Algo Used To Sign This Token ( digest Algorithm String ) ; xml Signature . set Basic Signature ( xml Basic Signature ) ; deal Signature Scope ( xml Signature , signature ) ; return signing Certificate Token ; }
void add Policy Listener (  Policy Listener policy Listener ) {  String listener Service Name = policy Listener . get Service Type Name ( ) ;  Set new Listeners = new  Hash Set ( ) ; new Listeners . add ( policy Listener ) ;  Set old Listeners = (  Set ) policy Listeners Map . get ( listener Service Name ) ; if ( old Listeners != null ) { new Listeners . add All ( old Listeners ) ; } policy Listeners Map . put ( listener Service Name , new Listeners ) ; }
public static int ping (  String url ) throws  Exception {  URL u = new  URL ( url ) ;  Http URLConnection c = (  Http URLConnection ) u . open Connection ( ) ; c . connect ( ) ; int code = c . get Response Code ( ) ; log . debug ( _ STR + url + _ STR + code ) ; c . disconnect ( ) ; return code ; }
List <  INavi Module > initialize Raw Modules ( final  List <  INavi Module > modules , final  List <  INavi Raw Module > raw Modules ) { final  List <  INavi Module > new Modules = new  Array List <  INavi Module > ( ) ; for ( final  INavi Raw Module raw Module : raw Modules ) { if ( ! has Module ( modules , raw Module ) ) { try { new Modules . add ( create Module ( raw Module ) ) ; } catch (  Couldnt Load Data Exception |  Couldnt Save Data Exception e ) {  CUtility Functions . log Exception ( e ) ; } } } return new Modules ; }
private  Object try Eval As Method (  Class < ? > clazz ,  Object target ,  List <  Object > args ) {  Method method = find Method ( clazz , args ) ; if ( method == null ) { return null ; } try { return  Values . ensure Not Null ( location ( ) , method . invoke ( target ,  Values . convert Args ( location ( ) , method . get Parameter Types ( ) , args ) ) ) ; } catch (  Illegal Access Exception |  Illegal Argument Exception e ) { throw new  Eval Exception ( location ( ) , _ STR , name ( ) , e . get Message ( ) ) ; } catch (  Invocation Target Exception e ) { throw new  Eval Exception (  Issue . create ( location ( ) , _ STR , name ( ) , e . get Cause ( ) ) ) ; } }
@  Override public  Japanese Date date ( int proleptic Year , int month , int day Of Month ) { return new  Japanese Date (  Local Date . of ( proleptic Year , month , day Of Month ) ) ; }
private  Pair <  Key , char [ ] > recover Key (  String alias , char [ ] store Pass , char [ ] key Pass ) throws  Exception {  Key key = null ; if ( key Store . contains Alias ( alias ) == _ BOOL ) {  Message Format form = new  Message Format ( rb . get String ( _ STR ) ) ;  Object [ ] source = { alias } ; throw new  Exception ( form . format ( source ) ) ; } if ( ! key Store . entry Instance Of ( alias ,  Key Store .  Private Key Entry . class ) && ! key Store . entry Instance Of ( alias ,  Key Store .  Secret Key Entry . class ) ) {  Message Format form = new  Message Format ( rb . get String ( _ STR ) ) ;  Object [ ] source = { alias } ; throw new  Exception ( form . format ( source ) ) ; } if ( key Pass == null ) { try { key = key Store . get Key ( alias , store Pass ) ; key Pass = store Pass ; passwords . add ( key Pass ) ; } catch (  Unrecoverable Key Exception e ) { if ( ! token ) { key Pass = get Key Passwd ( alias , null , null ) ; key = key Store . get Key ( alias , key Pass ) ; } else { throw e ; } } } else { key = key Store . get Key ( alias , key Pass ) ; } return  Pair . of ( key , key Pass ) ; }
Class < ? > load Class (  String class Name ,  URL [ ] urls ) throws  Class Not Found Exception {  URLClass Loader cl = new  URLClass Loader ( urls ) ;  Class < ? > test Class = cl . load Class ( class Name ) ; return test Class ; }
public  Thread Monitor (  MBean Server Connection server ) throws  IOException { this . server = server ; this . tmbean = new Platform MXBean Proxy ( server ,  THREAD_ MXBEAN_ NAME ,  Thread MXBean . class ) ; try { objname = new  Object Name (  THREAD_ MXBEAN_ NAME ) ; } catch (  Malformed Object Name Exception e ) {  Internal Error ie = new  Internal Error ( e . get Message ( ) ) ; ie . init Cause ( e ) ; throw ie ; } parse MBean Info ( ) ; }
public static <  T >  T [ ] concat ( @  Nullable  T [ ] arr ,  T ... obj ) {  T [ ] new Arr ; if ( arr == null || arr . length == _ NUM ) new Arr = obj ; else { new Arr =  Arrays . copy Of ( arr , arr . length + obj . length ) ;  System . arraycopy ( obj , _ NUM , new Arr , arr . length , obj . length ) ; } return new Arr ; }
public void pedestal Camera ( float size ) { move To Position ( - ( float ) ( target Xoff + ( size *  Math . sin (  Math . to Radians ( zrot ) ) ) ) , - ( float ) ( target Yoff + ( size *  Math . cos (  Math . to Radians ( zrot ) ) ) ) ) ; }
public static byte [ ] decode (  String encoded ) { if ( encoded == null ) { return null ; } char [ ] base64 Data = encoded . to Char Array ( ) ; int len = remove White Space ( base64 Data ) ; if ( len %  FOURBYTE != _ NUM ) { return null ; } int number Quadruple = ( len /  FOURBYTE ) ; if ( number Quadruple == _ NUM ) { return new byte [ _ NUM ] ; } byte decoded Data [ ] = null ; byte b1 = _ NUM , b2 = _ NUM , b3 = _ NUM , b4 = _ NUM ; char d1 = _ NUM , d2 = _ NUM , d3 = _ NUM , d4 = _ NUM ; int i = _ NUM ; int encoded Index = _ NUM ; int data Index = _ NUM ; decoded Data = new byte [ ( number Quadruple ) * _ NUM ] ; for ( ; i < number Quadruple - _ NUM ; i ++ ) { if ( ! is Data ( ( d1 = base64 Data [ data Index ++ ] ) ) || ! is Data ( ( d2 = base64 Data [ data Index ++ ] ) ) || ! is Data ( ( d3 = base64 Data [ data Index ++ ] ) ) || ! is Data ( ( d4 = base64 Data [ data Index ++ ] ) ) ) { return null ; } b1 = base64 Alphabet [ d1 ] ; b2 = base64 Alphabet [ d2 ] ; b3 = base64 Alphabet [ d3 ] ; b4 = base64 Alphabet [ d4 ] ; decoded Data [ encoded Index ++ ] = ( byte ) ( b1 << _ NUM | b2 > > _ NUM ) ; decoded Data [ encoded Index ++ ] = ( byte ) ( ( ( b2 & _ NUM ) << _ NUM ) | ( ( b3 > > _ NUM ) & _ NUM ) ) ; decoded Data [ encoded Index ++ ] = ( byte ) ( b3 << _ NUM | b4 ) ; } if ( ! is Data ( ( d1 = base64 Data [ data Index ++ ] ) ) || ! is Data ( ( d2 = base64 Data [ data Index ++ ] ) ) ) { return null ; } b1 = base64 Alphabet [ d1 ] ; b2 = base64 Alphabet [ d2 ] ; d3 = base64 Data [ data Index ++ ] ; d4 = base64 Data [ data Index ++ ] ; if ( ! is Data ( ( d3 ) ) || ! is Data ( ( d4 ) ) ) { if ( is Pad ( d3 ) && is Pad ( d4 ) ) { if ( ( b2 & _ NUM ) != _ NUM ) { return null ; } byte [ ] tmp = new byte [ i * _ NUM + _ NUM ] ;  System . arraycopy ( decoded Data , _ NUM , tmp , _ NUM , i * _ NUM ) ; tmp [ encoded Index ] = ( byte ) ( b1 << _ NUM | b2 > > _ NUM ) ; return tmp ; } else if ( ! is Pad ( d3 ) && is Pad ( d4 ) ) { b3 = base64 Alphabet [ d3 ] ; if ( ( b3 & _ NUM ) != _ NUM ) { return null ; } byte [ ] tmp = new byte [ i * _ NUM + _ NUM ] ;  System . arraycopy ( decoded Data , _ NUM , tmp , _ NUM , i * _ NUM ) ; tmp [ encoded Index ++ ] = ( byte ) ( b1 << _ NUM | b2 > > _ NUM ) ; tmp [ encoded Index ] = ( byte ) ( ( ( b2 & _ NUM ) << _ NUM ) | ( ( b3 > > _ NUM ) & _ NUM ) ) ; return tmp ; } else { return null ; } } else { b3 = base64 Alphabet [ d3 ] ; b4 = base64 Alphabet [ d4 ] ; decoded Data [ encoded Index ++ ] = ( byte ) ( b1 << _ NUM | b2 > > _ NUM ) ; decoded Data [ encoded Index ++ ] = ( byte ) ( ( ( b2 & _ NUM ) << _ NUM ) | ( ( b3 > > _ NUM ) & _ NUM ) ) ; decoded Data [ encoded Index ++ ] = ( byte ) ( b3 << _ NUM | b4 ) ; } return decoded Data ; }
public void stop ( ) { try { scheduled Executor Service . shutdown ( ) ; scheduled Executor Service . await Termination ( termination_wait ,  Time Unit .  MILLISECONDS ) ; } catch (  Interrupted Exception ignore ) { } }
public static int deflate ( byte [ ] previous , int previous Length , byte [ ] current , int current Length , byte [ ] result ) { if ( previous == null ) {  System . arraycopy ( current , _ NUM , result , _ NUM , current Length ) ; return current Length ; } int length = _ NUM ; int start1 = _ NUM ; int start2 = _ NUM ; while ( start1 < previous Length && start2 < current Length ) { int end1 = start1 ; int end2 = start2 ; while ( end1 <= previous Length && end2 <= current Length ) { byte c1 = ( end1 < previous Length ? previous [ end1 ] : ( byte ) _ STR ) ; byte c2 = ( end2 < current Length ? current [ end2 ] : ( byte ) _ STR ) ; if ( c1 == c2 ) { if ( c1 == _ STR ) { result [ length ++ ] = _ STR ; break ; } else { end1 ++ ; end2 ++ ; } } else { while ( end1 < previous Length && previous [ end1 ] != _ STR ) { end1 ++ ; } while ( end2 < current Length && current [ end2 ] != _ STR ) { end2 ++ ; } for ( int i = start2 ; i < end2 ; i ++ ) result [ length ++ ] = current [ i ] ; break ; } } start1 = end1 + _ NUM ; start2 = end2 + _ NUM ; if ( start2 < current Length ) result [ length ++ ] = _ STR ; } return length ; }
protected <  S extends  Property Source < ? > >  S find Property Source (  Class <  S > source Class ) {  List <  S > sources = find Property Sources ( source Class ) ; if ( sources . size ( ) == _ NUM ) { return null ; } if ( sources . size ( ) > _ NUM ) { log . warn ( _ STR + source Class ) ; } return sources . get ( _ NUM ) ; }
public void add Property Change Listener (  Property Change Listener l ) { if ( listeners == null ) { listeners = new  Array List <  Property Change Listener > ( _ NUM ) ; } if ( ! listeners . contains ( l ) ) { listeners . add ( l ) ; } }
public static boolean delete Recursive (  File path ) throws  File Not Found Exception { if ( ! path . exists ( ) ) throw new  File Not Found Exception ( path . get Absolute Path ( ) ) ; boolean ret = _ BOOL ; if ( path . is Directory ( ) ) { for (  File f : path . list Files ( ) ) { ret = ret &&  Utils . delete Recursive ( f ) ; } } return ret && path . delete ( ) ; }
void check Locks ( ) { if ( ! is Done ( ) ) { for ( int i = _ NUM ; i < entries . size ( ) ; i ++ ) { while ( _ BOOL ) {  Grid Cache Entry Ex cached = entries . get ( i ) ; try { if ( ! locked ( cached ) ) return ; break ; } catch (  Grid Cache Entry Removed Exception ignore ) { if ( log . is Debug Enabled ( ) ) log . debug ( _ STR + cached ) ; entries . add ( i , (  Grid Local Cache Entry ) cache . entry Ex ( cached . key ( ) ) ) ; } } } if ( log . is Debug Enabled ( ) ) log . debug ( _ STR + entries ) ; on Complete ( _ BOOL ) ; } }
Map <  String ,  Integer > create Const Map (  String grammar Content ) {  Map <  String ,  Integer > parser Const Map = new  Hash Map < > ( ) ;  Matcher matcher =  CONST_ DEF_ PATTERN . matcher ( grammar Content ) ; while ( matcher . find ( ) ) {  String name = matcher . group ( _ NUM ) ; int value =  Integer . parse Int ( matcher . group ( _ NUM ) ) ; parser Const Map . put ( name , value ) ; } return parser Const Map ; }
public void characters ( char [ ] ch , int start , int length ) throws  SAXException { pvalue . append ( ch , start , length ) ; }
public  Singular Value Decomposition (  Matrix  Arg ) { double [ ] [ ]  A =  Arg . get Array Copy ( ) ; m =  Arg . get Row Dimension ( ) ; n =  Arg . get Column Dimension ( ) ; int nu =  Math . min ( m , n ) ; s = new double [  Math . min ( m + _ NUM , n ) ] ;  U = new double [ m ] [ nu ] ;  V = new double [ n ] [ n ] ; double [ ] e = new double [ n ] ; double [ ] work = new double [ m ] ; boolean wantu = _ BOOL ; boolean wantv = _ BOOL ; int nct =  Math . min ( m - _ NUM , n ) ; int nrt =  Math . max ( _ NUM ,  Math . min ( n - _ NUM , m ) ) ; for ( int k = _ NUM ; k <  Math . max ( nct , nrt ) ; k ++ ) { if ( k < nct ) { s [ k ] = _ NUM ; for ( int i = k ; i < m ; i ++ ) { s [ k ] =  Maths . hypot ( s [ k ] ,  A [ i ] [ k ] ) ; } if ( s [ k ] != _ NUM ) { if (  A [ k ] [ k ] < _ NUM ) { s [ k ] = - s [ k ] ; } for ( int i = k ; i < m ; i ++ ) {  A [ i ] [ k ] /= s [ k ] ; }  A [ k ] [ k ] += _ NUM ; } s [ k ] = - s [ k ] ; } for ( int j = k + _ NUM ; j < n ; j ++ ) { if ( ( k < nct ) & ( s [ k ] != _ NUM ) ) { double t = _ NUM ; for ( int i = k ; i < m ; i ++ ) { t +=  A [ i ] [ k ] *  A [ i ] [ j ] ; } t = - t /  A [ k ] [ k ] ; for ( int i = k ; i < m ; i ++ ) {  A [ i ] [ j ] += t *  A [ i ] [ k ] ; } } e [ j ] =  A [ k ] [ j ] ; } if ( wantu & ( k < nct ) ) { for ( int i = k ; i < m ; i ++ ) {  U [ i ] [ k ] =  A [ i ] [ k ] ; } } if ( k < nrt ) { e [ k ] = _ NUM ; for ( int i = k + _ NUM ; i < n ; i ++ ) { e [ k ] =  Maths . hypot ( e [ k ] , e [ i ] ) ; } if ( e [ k ] != _ NUM ) { if ( e [ k + _ NUM ] < _ NUM ) { e [ k ] = - e [ k ] ; } for ( int i = k + _ NUM ; i < n ; i ++ ) { e [ i ] /= e [ k ] ; } e [ k + _ NUM ] += _ NUM ; } e [ k ] = - e [ k ] ; if ( ( k + _ NUM < m ) & ( e [ k ] != _ NUM ) ) { for ( int i = k + _ NUM ; i < m ; i ++ ) { work [ i ] = _ NUM ; } for ( int j = k + _ NUM ; j < n ; j ++ ) { for ( int i = k + _ NUM ; i < m ; i ++ ) { work [ i ] += e [ j ] *  A [ i ] [ j ] ; } } for ( int j = k + _ NUM ; j < n ; j ++ ) { double t = - e [ j ] / e [ k + _ NUM ] ; for ( int i = k + _ NUM ; i < m ; i ++ ) {  A [ i ] [ j ] += t * work [ i ] ; } } } if ( wantv ) { for ( int i = k + _ NUM ; i < n ; i ++ ) {  V [ i ] [ k ] = e [ i ] ; } } } } int p =  Math . min ( n , m + _ NUM ) ; if ( nct < n ) { s [ nct ] =  A [ nct ] [ nct ] ; } if ( m < p ) { s [ p - _ NUM ] = _ NUM ; } if ( nrt + _ NUM < p ) { e [ nrt ] =  A [ nrt ] [ p - _ NUM ] ; } e [ p - _ NUM ] = _ NUM ; if ( wantu ) { for ( int j = nct ; j < nu ; j ++ ) { for ( int i = _ NUM ; i < m ; i ++ ) {  U [ i ] [ j ] = _ NUM ; }  U [ j ] [ j ] = _ NUM ; } for ( int k = nct - _ NUM ; k >= _ NUM ; k -- ) { if ( s [ k ] != _ NUM ) { for ( int j = k + _ NUM ; j < nu ; j ++ ) { double t = _ NUM ; for ( int i = k ; i < m ; i ++ ) { t +=  U [ i ] [ k ] *  U [ i ] [ j ] ; } t = - t /  U [ k ] [ k ] ; for ( int i = k ; i < m ; i ++ ) {  U [ i ] [ j ] += t *  U [ i ] [ k ] ; } } for ( int i = k ; i < m ; i ++ ) {  U [ i ] [ k ] = -  U [ i ] [ k ] ; }  U [ k ] [ k ] = _ NUM +  U [ k ] [ k ] ; for ( int i = _ NUM ; i < k - _ NUM ; i ++ ) {  U [ i ] [ k ] = _ NUM ; } } else { for ( int i = _ NUM ; i < m ; i ++ ) {  U [ i ] [ k ] = _ NUM ; }  U [ k ] [ k ] = _ NUM ; } } } if ( wantv ) { for ( int k = n - _ NUM ; k >= _ NUM ; k -- ) { if ( ( k < nrt ) & ( e [ k ] != _ NUM ) ) { for ( int j = k + _ NUM ; j < nu ; j ++ ) { double t = _ NUM ; for ( int i = k + _ NUM ; i < n ; i ++ ) { t +=  V [ i ] [ k ] *  V [ i ] [ j ] ; } t = - t /  V [ k + _ NUM ] [ k ] ; for ( int i = k + _ NUM ; i < n ; i ++ ) {  V [ i ] [ j ] += t *  V [ i ] [ k ] ; } } } for ( int i = _ NUM ; i < n ; i ++ ) {  V [ i ] [ k ] = _ NUM ; }  V [ k ] [ k ] = _ NUM ; } } int pp = p - _ NUM ; int iter = _ NUM ; double eps =  Math . pow ( _ NUM , - _ NUM ) ; double tiny =  Math . pow ( _ NUM , - _ NUM ) ; while ( p > _ NUM ) { int k , kase ; for ( k = p - _ NUM ; k >= - _ NUM ; k -- ) { if ( k == - _ NUM ) { break ; } if (  Math . abs ( e [ k ] ) <= tiny + eps * (  Math . abs ( s [ k ] ) +  Math . abs ( s [ k + _ NUM ] ) ) ) { e [ k ] = _ NUM ; break ; } } if ( k == p - _ NUM ) { kase = _ NUM ; } else { int ks ; for ( ks = p - _ NUM ; ks >= k ; ks -- ) { if ( ks == k ) { break ; } double t = ( ks != p ?  Math . abs ( e [ ks ] ) : _ NUM ) + ( ks != k + _ NUM ?  Math . abs ( e [ ks - _ NUM ] ) : _ NUM ) ; if (  Math . abs ( s [ ks ] ) <= tiny + eps * t ) { s [ ks ] = _ NUM ; break ; } } if ( ks == k ) { kase = _ NUM ; } else if ( ks == p - _ NUM ) { kase = _ NUM ; } else { kase = _ NUM ; k = ks ; } } k ++ ; switch ( kase ) { case _ NUM : { double f = e [ p - _ NUM ] ; e [ p - _ NUM ] = _ NUM ; for ( int j = p - _ NUM ; j >= k ; j -- ) { double t =  Maths . hypot ( s [ j ] , f ) ; double cs = s [ j ] / t ; double sn = f / t ; s [ j ] = t ; if ( j != k ) { f = - sn * e [ j - _ NUM ] ; e [ j - _ NUM ] = cs * e [ j - _ NUM ] ; } if ( wantv ) { for ( int i = _ NUM ; i < n ; i ++ ) { t = cs *  V [ i ] [ j ] + sn *  V [ i ] [ p - _ NUM ] ;  V [ i ] [ p - _ NUM ] = - sn *  V [ i ] [ j ] + cs *  V [ i ] [ p - _ NUM ] ;  V [ i ] [ j ] = t ; } } } } break ; case _ NUM : { double f = e [ k - _ NUM ] ; e [ k - _ NUM ] = _ NUM ; for ( int j = k ; j < p ; j ++ ) { double t =  Maths . hypot ( s [ j ] , f ) ; double cs = s [ j ] / t ; double sn = f / t ; s [ j ] = t ; f = - sn * e [ j ] ; e [ j ] = cs * e [ j ] ; if ( wantu ) { for ( int i = _ NUM ; i < m ; i ++ ) { t = cs *  U [ i ] [ j ] + sn *  U [ i ] [ k - _ NUM ] ;  U [ i ] [ k - _ NUM ] = - sn *  U [ i ] [ j ] + cs *  U [ i ] [ k - _ NUM ] ;  U [ i ] [ j ] = t ; } } } } break ; case _ NUM : { double scale =  Math . max (  Math . max (  Math . max (  Math . max (  Math . abs ( s [ p - _ NUM ] ) ,  Math . abs ( s [ p - _ NUM ] ) ) ,  Math . abs ( e [ p - _ NUM ] ) ) ,  Math . abs ( s [ k ] ) ) ,  Math . abs ( e [ k ] ) ) ; double sp = s [ p - _ NUM ] / scale ; double spm1 = s [ p - _ NUM ] / scale ; double epm1 = e [ p - _ NUM ] / scale ; double sk = s [ k ] / scale ; double ek = e [ k ] / scale ; double b = ( ( spm1 + sp ) * ( spm1 - sp ) + epm1 * epm1 ) / _ NUM ; double c = ( sp * epm1 ) * ( sp * epm1 ) ; double shift = _ NUM ; if ( ( b != _ NUM ) | ( c != _ NUM ) ) { shift =  Math . sqrt ( b * b + c ) ; if ( b < _ NUM ) { shift = - shift ; } shift = c / ( b + shift ) ; } double f = ( sk + sp ) * ( sk - sp ) + shift ; double g = sk * ek ; for ( int j = k ; j < p - _ NUM ; j ++ ) { double t =  Maths . hypot ( f , g ) ; double cs = f / t ; double sn = g / t ; if ( j != k ) { e [ j - _ NUM ] = t ; } f = cs * s [ j ] + sn * e [ j ] ; e [ j ] = cs * e [ j ] - sn * s [ j ] ; g = sn * s [ j + _ NUM ] ; s [ j + _ NUM ] = cs * s [ j + _ NUM ] ; if ( wantv ) { for ( int i = _ NUM ; i < n ; i ++ ) { t = cs *  V [ i ] [ j ] + sn *  V [ i ] [ j + _ NUM ] ;  V [ i ] [ j + _ NUM ] = - sn *  V [ i ] [ j ] + cs *  V [ i ] [ j + _ NUM ] ;  V [ i ] [ j ] = t ; } } t =  Maths . hypot ( f , g ) ; cs = f / t ; sn = g / t ; s [ j ] = t ; f = cs * e [ j ] + sn * s [ j + _ NUM ] ; s [ j + _ NUM ] = - sn * e [ j ] + cs * s [ j + _ NUM ] ; g = sn * e [ j + _ NUM ] ; e [ j + _ NUM ] = cs * e [ j + _ NUM ] ; if ( wantu && ( j < m - _ NUM ) ) { for ( int i = _ NUM ; i < m ; i ++ ) { t = cs *  U [ i ] [ j ] + sn *  U [ i ] [ j + _ NUM ] ;  U [ i ] [ j + _ NUM ] = - sn *  U [ i ] [ j ] + cs *  U [ i ] [ j + _ NUM ] ;  U [ i ] [ j ] = t ; } } } e [ p - _ NUM ] = f ; iter = iter + _ NUM ; } break ; case _ NUM : { if ( s [ k ] <= _ NUM ) { s [ k ] = ( s [ k ] < _ NUM ? - s [ k ] : _ NUM ) ; if ( wantv ) { for ( int i = _ NUM ; i <= pp ; i ++ ) {  V [ i ] [ k ] = -  V [ i ] [ k ] ; } } } while ( k < pp ) { if ( s [ k ] >= s [ k + _ NUM ] ) { break ; } double t = s [ k ] ; s [ k ] = s [ k + _ NUM ] ; s [ k + _ NUM ] = t ; if ( wantv && ( k < n - _ NUM ) ) { for ( int i = _ NUM ; i < n ; i ++ ) { t =  V [ i ] [ k + _ NUM ] ;  V [ i ] [ k + _ NUM ] =  V [ i ] [ k ] ;  V [ i ] [ k ] = t ; } } if ( wantu && ( k < m - _ NUM ) ) { for ( int i = _ NUM ; i < m ; i ++ ) { t =  U [ i ] [ k + _ NUM ] ;  U [ i ] [ k + _ NUM ] =  U [ i ] [ k ] ;  U [ i ] [ k ] = t ; } } k ++ ; } iter = _ NUM ; p -- ; } break ; } } }
public static void init ( ) {  Properties p ; try { p =  System . get Properties ( ) ; } catch ( java . security .  Access Control Exception ace ) { p = new  Properties ( ) ; } init ( p ) ; }
public int remove ( int index ) { check Range ( index ) ; int oldval = array [ index ] ; int numtomove = size - index - _ NUM ; if ( numtomove > _ NUM ) {  System . arraycopy ( array , index + _ NUM , array , index , numtomove ) ; } size -- ; return oldval ; }
public  Restore In Progress (  Entry ... entries ) { this . entries =  Arrays . as List ( entries ) ; }
public static boolean starts With Ignore Case (  String s ,  String prefix ) { final int pl = prefix . length ( ) ; if ( s . length ( ) < pl ) return _ BOOL ; for ( int i = _ NUM ; i < pl ; i ++ ) { char sc = s . char At ( i ) ; char pc = prefix . char At ( i ) ; if ( sc != pc ) { sc =  Character . to Upper Case ( sc ) ; pc =  Character . to Upper Case ( pc ) ; if ( sc != pc ) { sc =  Character . to Lower Case ( sc ) ; pc =  Character . to Lower Case ( pc ) ; if ( sc != pc ) return _ BOOL ; } } } return _ BOOL ; }
public <  T >  T as Class (  Class <  T > clazz ,  T default Value ) { if ( value == null ) return default Value ; try { return clazz . cast ( value ) ; } catch (  Class Cast Exception e ) { return default Value ; } }
public  Solid Map (  Iterable <  Pair <  K ,  V > > iterable ) {  Linked Hash Map <  K ,  V > m = new  Linked Hash Map < > ( ) ; for (  Pair <  K ,  V > pair : iterable ) m . put ( pair . first , pair . second ) ; this . map =  Collections . unmodifiable Map ( m ) ; }
private void parse Menu (  Xml Pull Parser parser ,  Attribute Set attrs ,  Icon Data menu ) throws  Xml Pull Parser Exception ,  IOException {  Menu State menu State = new  Menu State ( menu ) ; int event Type = parser . get Event Type ( ) ;  String tag Name ; boolean looking For End Of Unknown Tag = _ BOOL ;  String unknown Tag Name = null ; do { if ( event Type ==  Xml Pull Parser .  START_ TAG ) { tag Name = parser . get Name ( ) ; if ( tag Name . equals (  XML_ MENU ) ) { event Type = parser . next ( ) ; break ; } throw new  Runtime Exception ( _ STR + tag Name ) ; } event Type = parser . next ( ) ; } while ( event Type !=  Xml Pull Parser .  END_ DOCUMENT ) ; boolean reached End Of Menu = _ BOOL ; while ( ! reached End Of Menu ) { switch ( event Type ) { case  Xml Pull Parser .  START_ TAG : if ( looking For End Of Unknown Tag ) { break ; } tag Name = parser . get Name ( ) ; if ( tag Name . equals (  XML_ GROUP ) ) { menu State . read Group ( attrs ) ; } else if ( tag Name . equals (  XML_ ITEM ) ) { menu State . read Item ( attrs ) ; } else if ( tag Name . equals (  XML_ MENU ) ) {  Icon Data sub Menu = menu State . add Sub Menu Item ( ) ; parse Menu ( parser , attrs , sub Menu ) ; } else { looking For End Of Unknown Tag = _ BOOL ; unknown Tag Name = tag Name ; } break ; case  Xml Pull Parser .  END_ TAG : tag Name = parser . get Name ( ) ; if ( looking For End Of Unknown Tag && tag Name . equals ( unknown Tag Name ) ) { looking For End Of Unknown Tag = _ BOOL ; unknown Tag Name = null ; } else if ( tag Name . equals (  XML_ GROUP ) ) { menu State . reset Group ( ) ; } else if ( tag Name . equals (  XML_ ITEM ) ) { if ( ! menu State . has Added Item ( ) ) { menu State . add Item ( ) ; } } else if ( tag Name . equals (  XML_ MENU ) ) { reached End Of Menu = _ BOOL ; } break ; case  Xml Pull Parser .  END_ DOCUMENT : throw new  Runtime Exception ( _ STR ) ; } event Type = parser . next ( ) ; } }
public static double cross Track Distance Rad ( double lat1 , double lon1 , double lat2 , double lon2 , double lat Q , double lon Q , double dist1 Q ) { final double dlon12 = lon2 - lon1 ; final double dlon1 Q = lon Q - lon1 ; final double slat1 =  Math . sin ( lat1 ) , clat1 =  Math Util . sin To Cos ( lat1 , slat1 ) ; final double slat Q =  Math . sin ( lat Q ) , clat Q =  Math Util . sin To Cos ( lat Q , slat Q ) ; final double slat2 =  Math . sin ( lat2 ) , clat2 =  Math Util . sin To Cos ( lat2 , slat2 ) ; final double sdlon12 =  Math . sin ( dlon12 ) , cdlon12 =  Math Util . sin To Cos ( dlon12 , sdlon12 ) ; final double sdlon1 Q =  Math . sin ( dlon1 Q ) , cdlon1 Q =  Math Util . sin To Cos ( dlon1 Q , sdlon1 Q ) ; final double y E = sdlon12 * clat2 ; final double y Q = sdlon1 Q * clat Q ; final double x E = clat1 * slat2 - slat1 * clat2 * cdlon12 ; final double x Q = clat1 * slat Q - slat1 * clat Q * cdlon1 Q ; final double crs12 =  Math . atan2 ( y E , x E ) ; final double crs1 Q =  Math . atan2 ( y Q , x Q ) ; return  Math . asin (  Math . sin ( dist1 Q ) *  Math . sin ( crs1 Q - crs12 ) ) ; }
@  Override public  String choose Server Alias ( final  String key Type , final  Principal [ ] issuers , final  Socket socket ) { if ( key Manager != null ) { return key Manager . choose Server Alias ( key Type , issuers , socket ) ; } return null ; }
public static double log Pdf ( double x , double shape , double scale , double factor ) { if ( x <= _ NUM ) return  Double .  NEGATIVE_ INFINITY ; return factor + shape *  Math . log ( scale ) - ( shape + _ NUM ) *  Math . log ( x ) - ( scale / x ) -  Gamma Function . ln Gamma ( shape ) ; }
public  String charge (  Properties ctx , int  Window No ,  Grid Tab m Tab ,  Grid Field m Field ,  Object value ) {  Integer  C_ Charge_ ID = (  Integer ) value ; if (  C_ Charge_ ID == null ||  C_ Charge_ ID . int Value ( ) == _ NUM ) return _ STR ; if ( m Tab . get Value ( _ STR ) != null ) { m Tab . set Value ( _ STR , null ) ; return _ STR ; } m Tab . set Value ( _ STR , null ) ; m Tab . set Value ( _ STR , null ) ; m Tab . set Value ( _ STR , new  Integer ( _ NUM ) ) ;  Env . set Context ( ctx ,  Window No , _ STR , _ STR ) ;  String sql = _ STR ;  Prepared Statement pstmt = null ;  Result Set rs = null ; try { pstmt =  DB . prepare Statement ( sql , null ) ; pstmt . set Int ( _ NUM ,  C_ Charge_ ID . int Value ( ) ) ; rs = pstmt . execute Query ( ) ; if ( rs . next ( ) ) { m Tab . set Value ( _ STR , rs . get Big Decimal ( _ NUM ) ) ; m Tab . set Value ( _ STR , rs . get Big Decimal ( _ NUM ) ) ; m Tab . set Value ( _ STR ,  Env .  ZERO ) ; m Tab . set Value ( _ STR ,  Env .  ZERO ) ; m Tab . set Value ( _ STR ,  Env .  ZERO ) ; } } catch (  SQLException e ) { log . log (  Level .  SEVERE , sql + e ) ; return e . get Localized Message ( ) ; } finally {  DB . close ( rs , pstmt ) ; rs = null ; pstmt = null ; } return tax ( ctx ,  Window No , m Tab , m Field , value ) ; }
private void process Tag ( final  String Builder builder ) { boolean started = _ BOOL ; while ( template Reader . has Next Character ( ) ) { final char tag Character = template Reader . next Character ( ) ; if ( ! started &&  Strings . is Whitespace ( tag Character ) ) { continue ; } started = _ BOOL ; if ( tag Character == syntax . get Argument Opening ( ) ) { process Argument ( ) ; } else if ( tag Character == syntax . get Tag Opening ( ) && is Next Character Comment Opening ( ) ) { process Comment ( ) ; } else if ( tag Character == syntax . get Tag Closing ( ) ) { process Tag Entity ( builder ) ; return ; } else { builder . append ( tag Character ) ; } } throw Error ( _ STR + builder . to String ( ) ) ; }
public void test BAand BCbroker Network ( ) throws  Exception { bridge Brokers ( _ STR , _ STR ) ; bridge Brokers ( _ STR , _ STR ) ; start All Brokers ( ) ;  Destination dest = create Destination ( _ STR , _ BOOL ) ;  Message Consumer client A = create Consumer ( _ STR , dest ) ;  Message Consumer client B = create Consumer ( _ STR , dest ) ;  Message Consumer client C = create Consumer ( _ STR , dest ) ;  Thread . sleep ( _ NUM ) ; send Messages ( _ STR , dest ,  MESSAGE_ COUNT ) ; send Messages ( _ STR , dest ,  MESSAGE_ COUNT ) ; send Messages ( _ STR , dest ,  MESSAGE_ COUNT ) ;  Message Id List msgs A = get Consumer Messages ( _ STR , client A ) ;  Message Id List msgs B = get Consumer Messages ( _ STR , client B ) ;  Message Id List msgs C = get Consumer Messages ( _ STR , client C ) ; msgs A . wait For Messages To Arrive (  MESSAGE_ COUNT * _ NUM ) ; msgs B . wait For Messages To Arrive (  MESSAGE_ COUNT ) ; msgs C . wait For Messages To Arrive (  MESSAGE_ COUNT * _ NUM ) ; assert Equals (  MESSAGE_ COUNT * _ NUM , msgs A . get Message Count ( ) ) ; assert Equals (  MESSAGE_ COUNT , msgs B . get Message Count ( ) ) ; assert Equals (  MESSAGE_ COUNT * _ NUM , msgs C . get Message Count ( ) ) ; }
@  Override public void flush ( ) { super . flush ( ) ; try { if ( out != null ) synchronized ( out ) { out . flush ( ) ; } } catch (  Socket Exception se ) { close ( ) ; } catch (  IOException ioe ) { ioe . print Stack Trace ( ) ; close ( ) ; } }
public static  Detached Baggage stop ( ) { try { return  Detached Baggage . wrap ( current . get ( ) ) ; } finally { current . remove ( ) ; } }
public static  Treebank Node select Matching Leaf (  JCas j Cas ,  Annotation annotation ) {  Treebank Node leaf = null ; for (  Treebank Node node :  JCas Util . select Covered ( j Cas ,  Treebank Node . class , annotation ) ) { if ( node . get Leaf ( ) && node . get Begin ( ) == annotation . get Begin ( ) && node . get End ( ) == annotation . get End ( ) ) { if ( leaf == null ) { leaf = node ; } else { throw new  Illegal Argument Exception (  String . format ( _ STR , annotation ,  Arrays . as List ( leaf , node ) ) ) ; } } } return leaf ; }
@  Override public void write ( byte [ ] buf , int offset , int length , boolean is End ) throws  IOException {  Output Stream stream = get Stream ( ) ; if ( stream == null ) { return ; } synchronized ( stream ) { stream . write ( buf , offset , length ) ; if ( is End ) { stream . flush ( ) ; } } }
public  Set <  Physical Table > filter (  Collection <  Physical Table > candidate Tables ,  List <  Physical Table Matcher > matchers ) throws  No Match Found Exception {  Collection <  Physical Table > current Matches = candidate Tables ; for (  Physical Table Matcher matcher : matchers ) { current Matches = matcher . match Not Empty ( current Matches . stream ( ) ) ; } return new  Linked Hash Set < > ( current Matches ) ; }
public static int parse Int (  String text , int default Value ) { try { return  Integer . parse Int ( text ) ; } catch (  Number Format Exception |  Null Pointer Exception ex ) { return default Value ; } }
public static  Request Security Token Response parse XML (  Input Stream is ) throws  WSFederation Exception {  Document doc =  XMLUtils . to DOMDocument ( is , debug ) ;  Element root = doc . get Document Element ( ) ; return new  Request Security Token Response ( root ) ; }
@  Override public void cancel Resource Request (  Samza Resource Request request ) { log . info ( _ STR , request ) ; synchronized ( lock ) {  AMRMClient .  Container Request container Request = requests Map . get ( request ) ; if ( container Request == null ) { log . info ( _ STR , container Request ) ; return ; } requests Map . remove ( request ) ; am Client . remove Container Request ( container Request ) ; } }
public static  String enumerate Collection With Hash ( final  Collection <  String > collection ) { if ( collection == null ) { return _ STR ; } final  List <  String > result = new  Array List <  String > ( collection . size ( ) ) ; for (  String entry : collection ) { result . add ( _ STR + entry ) ; } return enumerate Collection ( result ) ; }
private  String print DFormat (  String sx ) { int n Leading Zeros = _ NUM ; int n Blanks = _ NUM , n = _ NUM ; int i = _ NUM , j First = _ NUM ; boolean neg = sx . char At ( _ NUM ) == _ STR ; if ( sx . equals ( _ STR ) && precision Set && precision == _ NUM ) sx = _ STR ; if ( ! neg ) { if ( precision Set && sx . length ( ) < precision ) n Leading Zeros = precision - sx . length ( ) ; } else { if ( precision Set && ( sx . length ( ) - _ NUM ) < precision ) n Leading Zeros = precision - sx . length ( ) + _ NUM ; } if ( n Leading Zeros < _ NUM ) n Leading Zeros = _ NUM ; if ( field Width Set ) { n Blanks = field Width - n Leading Zeros - sx . length ( ) ; if ( ! neg && ( leading Sign || leading Space ) ) n Blanks -- ; } if ( n Blanks < _ NUM ) n Blanks = _ NUM ; if ( leading Sign ) n ++ ; else if ( leading Space ) n ++ ; n += n Blanks ; n += n Leading Zeros ; n += sx . length ( ) ; char [ ] ca = new char [ n ] ; if ( left Justify ) { if ( neg ) ca [ i ++ ] = _ STR ; else if ( leading Sign ) ca [ i ++ ] = _ STR ; else if ( leading Space ) ca [ i ++ ] = _ STR ; char [ ] csx = sx . to Char Array ( ) ; j First = neg ? _ NUM : _ NUM ; for ( int j = _ NUM ; j < n Leading Zeros ; i ++ , j ++ ) ca [ i ] = _ STR ; for ( int j = j First ; j < csx . length ; j ++ , i ++ ) ca [ i ] = csx [ j ] ; for ( int j = _ NUM ; j < n Blanks ; i ++ , j ++ ) ca [ i ] = _ STR ; } else { if ( ! leading Zeros ) { for ( i = _ NUM ; i < n Blanks ; i ++ ) ca [ i ] = _ STR ; if ( neg ) ca [ i ++ ] = _ STR ; else if ( leading Sign ) ca [ i ++ ] = _ STR ; else if ( leading Space ) ca [ i ++ ] = _ STR ; } else { if ( neg ) ca [ i ++ ] = _ STR ; else if ( leading Sign ) ca [ i ++ ] = _ STR ; else if ( leading Space ) ca [ i ++ ] = _ STR ; for ( int j = _ NUM ; j < n Blanks ; j ++ , i ++ ) ca [ i ] = _ STR ; } for ( int j = _ NUM ; j < n Leading Zeros ; j ++ , i ++ ) ca [ i ] = _ STR ; char [ ] csx = sx . to Char Array ( ) ; j First = neg ? _ NUM : _ NUM ; for ( int j = j First ; j < csx . length ; j ++ , i ++ ) ca [ i ] = csx [ j ] ; } return new  String ( ca ) ; }
private void draw Anno Drag Indicators ( final  Graphics2 D g , final  Workflow Annotation anno , final  Rectangle2 D loc , final boolean printing ) { if ( printing ) { return ; }  Annotation Drag Helper dragged = model . get Dragged ( ) ; if ( dragged . get Hovered Operator ( ) == null ) { return ; }  Graphics2 D g2 = (  Graphics2 D ) g . create ( ) ; int padding = _ NUM ;  Rectangle2 D op Rect = renderer Model . get Operator Rect ( dragged . get Hovered Operator ( ) ) ; op Rect = new  Rectangle2 D .  Double ( op Rect . get X ( ) , op Rect . get Y ( ) , op Rect . get Width ( ) , op Rect . get Height ( ) ) ;  Rectangle2 D shadow Rect = new  Rectangle2 D .  Double ( op Rect . get X ( ) - padding - _ NUM , op Rect . get Y ( ) - padding - _ NUM , op Rect . get Width ( ) + _ NUM * padding + _ NUM , op Rect . get Height ( ) + _ NUM * padding + _ NUM ) ; g2 . set Color (  DRAG_ LINK_ COLOR ) ; g2 . set Stroke (  DRAG_ BORDER_ STROKE ) ; g2 . draw ( shadow Rect ) ; g2 . dispose ( ) ; }
public void remove ( symbol sym ) throws internal_error { not_null ( sym ) ; _all . remove ( sym . name ( ) ) ; }
public final int index Of (  V value ) { if (  GWT . is Script ( ) ) { return js Array . index Of ( value ) ; } else { return java Array . index Of ( value ) ; } }
protected  Geo Point [ ] find Intersections ( final  Planet Model planet Model , final  Plane q , final  Membership [ ] bounds , final  Membership [ ] more Bounds ) { final double line Vector X = y * q . z - z * q . y ; final double line Vector Y = z * q . x - x * q . z ; final double line Vector Z = x * q . y - y * q . x ; if (  Math . abs ( line Vector X ) <  MINIMUM_ RESOLUTION &&  Math . abs ( line Vector Y ) <  MINIMUM_ RESOLUTION &&  Math . abs ( line Vector Z ) <  MINIMUM_ RESOLUTION ) { return  NO_ POINTS ; } double x0 ; double y0 ; double z0 ; final double denom YZ = this . y * q . z - this . z * q . y ; final double denom XZ = this . x * q . z - this . z * q . x ; final double denom XY = this . x * q . y - this . y * q . x ; if (  Math . abs ( denom YZ ) >=  Math . abs ( denom XZ ) &&  Math . abs ( denom YZ ) >=  Math . abs ( denom XY ) ) { if (  Math . abs ( denom YZ ) <  MINIMUM_ RESOLUTION_ SQUARED ) { return  NO_ POINTS ; } final double denom = _ NUM / denom YZ ; x0 = _ NUM ; y0 = ( - this .  D * q . z - this . z * - q .  D ) * denom ; z0 = ( this . y * - q .  D + this .  D * q . y ) * denom ; } else if (  Math . abs ( denom XZ ) >=  Math . abs ( denom XY ) &&  Math . abs ( denom XZ ) >=  Math . abs ( denom YZ ) ) { if (  Math . abs ( denom XZ ) <  MINIMUM_ RESOLUTION_ SQUARED ) { return  NO_ POINTS ; } final double denom = _ NUM / denom XZ ; x0 = ( - this .  D * q . z - this . z * - q .  D ) * denom ; y0 = _ NUM ; z0 = ( this . x * - q .  D + this .  D * q . x ) * denom ; } else { if (  Math . abs ( denom XY ) <  MINIMUM_ RESOLUTION_ SQUARED ) { return  NO_ POINTS ; } final double denom = _ NUM / denom XY ; x0 = ( - this .  D * q . y - this . y * - q .  D ) * denom ; y0 = ( this . x * - q .  D + this .  D * q . x ) * denom ; z0 = _ NUM ; } final double  A = line Vector X * line Vector X * planet Model . inverse Ab Squared + line Vector Y * line Vector Y * planet Model . inverse Ab Squared + line Vector Z * line Vector Z * planet Model . inverse CSquared ; final double  B = _ NUM * ( line Vector X * x0 * planet Model . inverse Ab Squared + line Vector Y * y0 * planet Model . inverse Ab Squared + line Vector Z * z0 * planet Model . inverse CSquared ) ; final double  C = x0 * x0 * planet Model . inverse Ab Squared + y0 * y0 * planet Model . inverse Ab Squared + z0 * z0 * planet Model . inverse CSquared - _ NUM ; final double  Bsquared Minus =  B *  B - _ NUM *  A *  C ; if (  Math . abs (  Bsquared Minus ) <  MINIMUM_ RESOLUTION_ SQUARED ) { final double inverse2 A = _ NUM / ( _ NUM *  A ) ; final double t = -  B * inverse2 A ; final double point X = line Vector X * t + x0 ; final double point Y = line Vector Y * t + y0 ; final double point Z = line Vector Z * t + z0 ; for ( final  Membership bound : bounds ) { if ( ! bound . is Within ( point X , point Y , point Z ) ) { return  NO_ POINTS ; } } for ( final  Membership bound : more Bounds ) { if ( ! bound . is Within ( point X , point Y , point Z ) ) { return  NO_ POINTS ; } } return new  Geo Point [ ] { new  Geo Point ( point X , point Y , point Z ) } ; } else if (  Bsquared Minus > _ NUM ) { final double inverse2 A = _ NUM / ( _ NUM *  A ) ; final double sqrt Term =  Math . sqrt (  Bsquared Minus ) ; final double t1 = ( -  B + sqrt Term ) * inverse2 A ; final double t2 = ( -  B - sqrt Term ) * inverse2 A ; final double point1 X = line Vector X * t1 + x0 ; final double point1 Y = line Vector Y * t1 + y0 ; final double point1 Z = line Vector Z * t1 + z0 ; final double point2 X = line Vector X * t2 + x0 ; final double point2 Y = line Vector Y * t2 + y0 ; final double point2 Z = line Vector Z * t2 + z0 ; boolean point1 Valid = _ BOOL ; boolean point2 Valid = _ BOOL ; for ( final  Membership bound : bounds ) { if ( ! bound . is Within ( point1 X , point1 Y , point1 Z ) ) { point1 Valid = _ BOOL ; break ; } } if ( point1 Valid ) { for ( final  Membership bound : more Bounds ) { if ( ! bound . is Within ( point1 X , point1 Y , point1 Z ) ) { point1 Valid = _ BOOL ; break ; } } } for ( final  Membership bound : bounds ) { if ( ! bound . is Within ( point2 X , point2 Y , point2 Z ) ) { point2 Valid = _ BOOL ; break ; } } if ( point2 Valid ) { for ( final  Membership bound : more Bounds ) { if ( ! bound . is Within ( point2 X , point2 Y , point2 Z ) ) { point2 Valid = _ BOOL ; break ; } } } if ( point1 Valid && point2 Valid ) { return new  Geo Point [ ] { new  Geo Point ( point1 X , point1 Y , point1 Z ) , new  Geo Point ( point2 X , point2 Y , point2 Z ) } ; } if ( point1 Valid ) { return new  Geo Point [ ] { new  Geo Point ( point1 X , point1 Y , point1 Z ) } ; } if ( point2 Valid ) { return new  Geo Point [ ] { new  Geo Point ( point2 X , point2 Y , point2 Z ) } ; } return  NO_ POINTS ; } else { return  NO_ POINTS ; } }
public  List <  Page > expand Pages (  List <  Page > pages ) {  List <  Page > expanded Pages = new  Array List <  Page > ( ) ;  Set <  String > in And Out Links = new  Hash Set <  String > ( ) ; for ( int i = _ NUM ; i < pages . size ( ) ; i ++ ) {  Page curr P = pages . get ( i ) ; if ( ! expanded Pages . contains ( curr P ) ) { expanded Pages . add ( curr P ) ; }  List <  String > curr Inlinks = curr P . get Inlinks ( ) ; for ( int j = _ NUM ; j < curr Inlinks . size ( ) ; j ++ ) { in And Out Links . add ( curr Inlinks . get ( i ) ) ; }  List <  String > curr Outlinks = curr P . get Outlinks ( ) ; for ( int j = _ NUM ; j < curr Outlinks . size ( ) ; j ++ ) { in And Out Links . add ( curr Outlinks . get ( i ) ) ; } }  Iterator <  String > it = in And Out Links . iterator ( ) ; while ( it . has Next ( ) ) {  String addr = it . next ( ) ;  Page p = p Table . get ( addr ) ; if ( p != null && ! expanded Pages . contains ( p ) ) { expanded Pages . add ( p ) ; } } return expanded Pages ; }
private void abort Loading ( ) { if ( thread == null ) return ; if ( thread . is Alive ( ) ) { thread . interrupt ( ) ; try { thread . join ( ) ; } catch (  Interrupted Exception e ) { e . print Stack Trace ( ) ; } } }
public static  Hash Map <  Cell Index ,  Double > read DMLMatrix From HDFS (  String file Path ) {  Hash Map <  Cell Index ,  Double > expected Values = new  Hash Map <  Cell Index ,  Double > ( ) ; try {  File System fs =  File System . get ( conf ) ;  Path out Directory = new  Path ( file Path ) ;  String line ;  File Status [ ] out Files = fs . list Status ( out Directory ) ; for (  File Status file : out Files ) {  FSData Input Stream out In = fs . open ( file . get Path ( ) ) ;  Buffered Reader reader = new  Buffered Reader ( new  Input Stream Reader ( out In ) ) ; while ( ( line = reader . read Line ( ) ) != null ) {  String Tokenizer st = new  String Tokenizer ( line , _ STR ) ; int i =  Integer . parse Int ( st . next Token ( ) ) ; int j =  Integer . parse Int ( st . next Token ( ) ) ; double v =  Double . parse Double ( st . next Token ( ) ) ; expected Values . put ( new  Cell Index ( i , j ) , v ) ; } out In . close ( ) ; } } catch (  IOException e ) { assert True ( _ STR + file Path , _ BOOL ) ; } return expected Values ; }
public void bind Section (  Section Part section Part ,  String id ,  String page Id ) { section Parts . put ( id , section Part ) ; page For Section . put ( id , page Id ) ;  Vector <  String > section Ids = sections For Page . get ( page Id ) ; if ( section Ids == null ) { section Ids = new  Vector <  String > ( ) ; sections For Page . put ( page Id , section Ids ) ; } section Ids . add ( id ) ; }
private void unwrap Data ( ) throws  Ignite Checked Exception ,  SSLException { if ( log . is Debug Enabled ( ) ) log . debug ( _ STR + ses ) ; in Net Buf . flip ( ) ;  SSLEngine Result res = unwrap0 ( ) ; in Net Buf . compact ( ) ; check Status ( res ) ; renegotiate If Needed ( res ) ; }
private void check Alter Partial Converters ( ) throws  Security Exception {  Security Manager sm =  System . get Security Manager ( ) ; if ( sm != null ) { sm . check Permission ( new  Joda Time Permission ( _ STR ) ) ; } }
public void store Username (  String username ) { if ( is Store && shared State != null ) { shared State . put ( get User Key ( ) , username ) ; } }
private  Node search Word (  Node Array children ,  String word , int depth ,  Node parent Node ) { final int word Length = word . length ( ) ; final char c = word . char At ( depth ) ; final int children Length = children . length ;  Node child Node = null ; boolean found = _ BOOL ; for ( int i = _ NUM ; i < children Length ; i ++ ) { child Node = children . data [ i ] ; if ( child Node . code == c ) { found = _ BOOL ; break ; } } if ( ! found ) { child Node = new  Node ( ) ; child Node . code = c ; child Node . parent = parent Node ; children . add ( child Node ) ; } if ( word Length == depth + _ NUM ) { child Node . terminal = _ BOOL ; return child Node ; } if ( child Node . children == null ) { child Node . children = new  Node Array ( ) ; } return search Word ( child Node . children , word , depth + _ NUM , child Node ) ; }
public static boolean is Location Reachable (  Inet Socket Address endpoint , int timeout Ms , int retry Count , int retry Interval Ms ) { int retry Left = retry Count ; while ( retry Left > _ NUM ) { try (  Socket s = new  Socket ( ) ) { s . connect ( endpoint , timeout Ms ) ; return _ BOOL ; } catch (  IOException e ) { } finally {  Sys Utils . sleep ( retry Interval Ms ) ; retry Left -- ; } }  LOG . log (  Level .  FINE , _ STR , endpoint . to String ( ) ) ; return _ BOOL ; }
public void load All Images (  Component comp ,  Media Tracker tracker ) { for (  Iterator <  Hex Entry > i = bases . iterator ( ) ; i . has Next ( ) ; ) {  Hex Entry entry = i . next ( ) ; if ( entry . get Image ( ) == null ) { entry . load Image ( comp ) ; } tracker . add Image ( entry . get Image ( ) , _ NUM ) ; } for (  Iterator <  Hex Entry > i = supers . iterator ( ) ; i . has Next ( ) ; ) {  Hex Entry entry = i . next ( ) ; if ( entry . get Image ( ) == null ) { entry . load Image ( comp ) ; } tracker . add Image ( entry . get Image ( ) , _ NUM ) ; } for (  Iterator <  Hex Entry > i = ortho . iterator ( ) ; i . has Next ( ) ; ) {  Hex Entry entry = i . next ( ) ; if ( entry . get Image ( ) == null ) { entry . load Image ( comp ) ; } tracker . add Image ( entry . get Image ( ) , _ NUM ) ; } }
private static  String extract Shortcut (  String pattern ) { char [ ] wildcard Chars = new char [ ] { _ STR , _ STR } ; int start Index = _ NUM ; int end Index =  String Utils . index Of Any ( pattern , wildcard Chars ) ; if ( end Index < _ NUM ) { return pattern ; }  String shortcut = end Index == start Index ?  String Utils .  EMPTY : pattern . substring ( start Index , end Index - start Index ) ; while ( end Index >= _ NUM ) { start Index = start Index + end Index + _ NUM ; if ( pattern . length ( ) <= start Index ) { break ; } end Index =  String Utils . index Of Any ( pattern . substring ( start Index ) , wildcard Chars ) ;  String tmp Shortcut = end Index < _ NUM ? pattern . substring ( start Index ) : pattern . substring ( start Index , end Index + start Index ) ; if ( tmp Shortcut . length ( ) > shortcut . length ( ) ) { shortcut = tmp Shortcut ; } } return shortcut ; }
@  Override protected void failed (  Throwable e ,  Description description ) { this . tr State . is Success = _ BOOL ; this . tr State . failure Reason =  Utils . to String ( e ) ; }
private void do Post Helper (  Http Servlet Request request ,  Http Servlet Response response ) throws  Servlet Exception ,  IOException { logger . log (  Level .  INFO , _ STR + request . get Request URI ( ) ) ; final  Request And Response request And Response = new  Request And Response ( request , response ) ; standard Response Stuff ( request And Response ) ; final  String uri = request . get Request URI ( ) ; request And Response . set Override Uri ( uri ) ; if ( uri . equals ( _ STR ) ) { handle Json Create Quotation ( request And Response ) ; } else if ( uri . equals ( _ STR ) ) { handle Html Make Notebook ( request And Response ) ; } else if ( uri . equals ( _ STR ) ) { handle Json Move Notes ( request And Response ) ; } else if ( uri . equals ( _ STR ) ) { handle Json Note Op ( request And Response ) ; } else if ( uri . equals ( _ STR ) ) { handle Json Get Notebook Path ( request And Response ) ; } else if ( uri . equals ( _ STR ) ) { handle Json Make Children ( request And Response ) ; } else if ( uri . equals ( _ STR ) ) { handle Json Make Siblings ( request And Response ) ; } else if ( uri . equals ( _ STR ) ) { handle Json Sign In ( request And Response ) ; } else if ( uri . equals ( _ STR ) ) { handle Json Sign Out ( request And Response ) ; } else if ( uri . equals ( _ STR ) ) { handle Json Create Account ( request And Response ) ; } else if ( uri . starts With ( _ STR ) ) { handle Html Do User Restore ( request And Response ) ; } else if ( uri . starts With ( _ STR ) ) { handle Html Do Offline Db Backup ( request And Response ) ; } else if ( uri . starts With ( _ STR ) ) { handle Html Do Online Db Backup ( request And Response ) ; } else if ( uri . starts With ( _ STR ) ) { handle Html Do Clear ( request And Response ) ; } else if ( uri . starts With ( _ STR ) ) { handle Html Do User Backup ( request And Response ) ; } else if ( uri . starts With ( _ STR ) ) { handle Html Do Shutdown ( request And Response ) ; } else if ( uri . starts With ( _ STR ) ) { handle Html Do Check For Errors ( request And Response ) ; } else if ( uri . starts With ( _ STR ) ) { handle Html Change Password ( request And Response ) ; } else if ( uri . starts With ( _ STR ) ) { handle Html Change Account ( request And Response ) ; } else if ( uri . starts With ( _ STR ) ) { handle Html Close Account ( request And Response ) ; } else if ( uri . equals ( _ STR ) ) { handle Json Save Options ( request And Response ) ; } else if ( uri . starts With ( _ STR ) ) { handle Html Do Export ( request And Response ) ; } else { return Html404 ( request And Response ) ; } }
private void export Source Documents (  Project a Project ,  File a Copy Dir ) throws  IOException ,  Project Export Exception {  File source Document Dir = new  File ( a Copy Dir +  SOURCE_ FOLDER ) ;  File Utils . force Mkdir ( source Document Dir ) ;  List < de . tudarmstadt . ukp . clarin . webanno . model .  Source Document > documents = repository . list Source Documents ( a Project ) ; documents . add All ( automation Service . list Tab Sep Documents ( a Project ) ) ; int i = _ NUM ; for ( de . tudarmstadt . ukp . clarin . webanno . model .  Source Document source Document : documents ) { try {  File Utils . copy File To Directory ( repository . get Source Document File ( source Document ) , source Document Dir ) ; progress = ( int )  Math . ceil ( ( ( double ) i ) / documents . size ( ) * _ NUM ) ; i ++ ; } catch (  File Not Found Exception e ) {  String Buffer error Message = new  String Buffer ( ) ; error Message . append ( _ STR ) ; error Message . append ( source Document . get Name ( ) ) ; error Message . append ( _ STR ) ;  LOG . error ( error Message . to String ( ) ) ;  LOG . error (  Exception Utils . get Root Cause ( e ) ) ; messages . add ( error Message . to String ( ) ) ; throw new  Project Export Exception ( _ STR ) ; } } }
public boolean remove Entry (  T e ) { if ( e == null ) return _ BOOL ; boolean removed = m YVals . remove ( e ) ; if ( removed ) { float val = e . get Val ( ) ; m YValue Sum -= val ; calc Min Max ( ) ; } return removed ; }
public void on Key Pressed ( final int key Code ) { if ( ! pressed State Keys . contains ( key Code ) ) { pressed State Keys . add ( key Code ) ; } }
public boolean has Descendant (  Set <  String > variables ) {  Queue <  BNode > nodes To Process = new  Linked List <  BNode > ( ) ; nodes To Process . add ( this ) ; while ( ! nodes To Process . is Empty ( ) ) {  BNode current Node = nodes To Process . poll ( ) ; for (  BNode descendant Node : current Node . get Output Nodes ( ) ) { if ( variables . contains ( descendant Node . get Id ( ) ) ) { return _ BOOL ; } if ( ! nodes To Process . contains ( descendant Node ) ) { nodes To Process . add ( descendant Node ) ; } } } return _ BOOL ; }
public static  List <  Blog > parse (  String data ) {  List <  Blog > blog List = null ;  Blog blog = null ; if ( data != null && ! data . equals ( _ STR ) ) try {  JSONTokener json Parser = new  JSONTokener ( data ) ;  JSONObject content = (  JSONObject ) json Parser . next Value ( ) ;  JSONArray list = content . get JSONArray ( _ STR ) ; if ( list . length ( ) > _ NUM ) blog List = new  Array List < > ( ) ; for ( int i = _ NUM ; i < list . length ( ) ; ++ i ) {  JSONObject info = (  JSONObject ) list . get ( i ) ; blog = new  Blog ( ) ; blog . set Author_name ( info . get String ( _ STR ) ) ; blog . set Post Id ( info . get String ( _ STR ) ) ; blog . set Url (  String Utils . to Url ( info . get String ( _ STR ) ) ) ; blog . set Blog Id (  String Utils . to Int ( info . get String ( _ STR ) ) ) ; blog . set Blogapp ( info . get String ( _ STR ) ) ; blog . set Comments (  String Utils . to Int ( info . get String ( _ STR ) ) ) ; blog . set Summary ( info . get String ( _ STR ) ) ; blog . set Reads (  String Utils . to Int ( info . get String ( _ STR ) ) ) ; blog . set Title ( info . get String ( _ STR ) ) ; blog . set Updated (  String Utils . to Date ( info . get String ( _ STR ) ) ) ; if ( blog List != null ) { blog List . add ( blog ) ; } } } catch (  Exception e ) { e . print Stack Trace ( ) ; } return blog List ; }
public boolean equals (  Object object ) { if ( this == object ) { return _ BOOL ; } else if ( object == null || get Class ( ) != object . get Class ( ) ) { return _ BOOL ; } return principal . equals ( object . to String ( ) ) ; }
public void test Bug27412 ( ) throws  Exception {  Properties props = new  Properties ( ) ; props . put ( _ STR , _ STR ) ; props . put ( _ STR , _ STR ) ; props . put ( _ STR , _ STR ) ;  Connection conn2 = get Connection With Props ( props ) ;  Prepared Statement pstm = conn2 . prepare Statement ( _ STR ) ; try { assert True ( pstm . execute ( ) ) ; } finally { pstm . close ( ) ; conn2 . close ( ) ; } }
public static boolean equals ( float [ ] field1 , float [ ] field2 ) { if ( field1 == null || field1 . length == _ NUM ) { return field2 == null || field2 . length == _ NUM ; } else { return  Arrays . equals ( field1 , field2 ) ; } }
public void to Back ( final  Workflow Annotation anno ) { if ( anno == null ) { throw new  Illegal Argument Exception ( _ STR ) ; } synchronized ( lock ) { if ( annotations Draw Order . remove ( anno ) ) { annotations Draw Order . add ( _ NUM , anno ) ; } if ( annotations Event Order . remove ( anno ) ) { annotations Event Order . add ( annotations Event Order . size ( ) , anno ) ; } } }
public synchronized void update ( ) { if ( frames . size ( ) > _ NUM ) { anim Time += _ NUM ; if ( anim Time >= total Duration ) { anim Time = anim Time % total Duration ; curr Frame Index = _ NUM ; } while ( anim Time > get Frame ( curr Frame Index ) . end Time ) { curr Frame Index ++ ; } } }
public static  String randomly Recase Code Points (  Random random ,  String str ) {  String Builder builder = new  String Builder ( ) ; int pos = _ NUM ; while ( pos < str . length ( ) ) { int code Point = str . code Point At ( pos ) ; pos +=  Character . char Count ( code Point ) ; switch ( next Int ( random , _ NUM , _ NUM ) ) { case _ NUM : builder . append Code Point (  Character . to Upper Case ( code Point ) ) ; break ; case _ NUM : builder . append Code Point (  Character . to Lower Case ( code Point ) ) ; break ; case _ NUM : builder . append Code Point ( code Point ) ; } } return builder . to String ( ) ; }
private  Boolean handle Execution Response (  Http URLConnection connection ) throws  IOException { int response Code = connection . get Response Code ( ) ; if ( is Successful ( response Code ) ) {  String response Content = get Response Content As String ( connection ) ;  String id = response Content != null ? response Content : _ STR ;  Log . i (  TAG , _ STR + m File To Upload . get Name ( ) + _ STR + id ) ; cleanup Minidump File ( ) ; try { append Uploaded Entry To Log ( id ) ; } catch (  IOException ioe ) {  Log . e (  TAG , _ STR ) ; } return _ BOOL ; } else {  String msg =  String . format (  Locale .  US , _ STR , m File To Upload . get Name ( ) , response Code , connection . get Response Message ( ) ) ;  Log . i (  TAG , msg ) ; return _ BOOL ; } }
boolean close Outbound ( ) throws  SSLException { if ( ssl Engine == null || ssl Engine . is Outbound Done ( ) ) { return _ BOOL ; } ssl Engine . close Outbound ( ) ; create Out Net Buffer ( _ NUM ) ;  SSLEngine Result result ; for ( ; ; ) { result = ssl Engine . wrap ( empty Buffer . buf ( ) , out Net Buffer . buf ( ) ) ; if ( result . get Status ( ) ==  Status .  BUFFER_ OVERFLOW ) { out Net Buffer . capacity ( out Net Buffer . capacity ( ) << _ NUM ) ; out Net Buffer . limit ( out Net Buffer . capacity ( ) ) ; } else { break ; } } if ( result . get Status ( ) !=  Status .  CLOSED ) { throw new  SSLException ( _ STR + result ) ; } out Net Buffer . flip ( ) ; return _ BOOL ; }
protected static  Bitmap create Bitmap And Gc If Necessary ( int width , int height ) { try { return  Bitmap . create Bitmap ( width , height ,  Bitmap .  Config .  ARGB_8888 ) ; } catch (  Out Of Memory Error e ) {  System . gc ( ) ; return  Bitmap . create Bitmap ( width , height ,  Bitmap .  Config .  ARGB_8888 ) ; } }
private void copy Application Stub ( ) throws  Build Exception {  File new Stub File = new  File ( m Mac Os Dir , bundle Properties . get CFBundle Executable ( ) ) ; if ( m Verbose ) log ( _ STR + bundle Path ( new Stub File ) + _ STR ) ; try { m File Utils . copy File ( m Stub File , new Stub File ) ; } catch (  IOException ex ) { throw new  Build Exception ( _ STR + ex ) ; } set Executable ( new Stub File ) ; }
public void add (  Event Bean the Event ) { if ( the Event == null ) { throw new  Illegal Argument Exception ( _ STR ) ; } if ( first Event == null ) { first Event = the Event ; return ; } if ( additional Events == null ) { additional Events = new  Array Deque <  Event Bean > ( ) ; } additional Events . add ( the Event ) ; }
public  Oid ( byte [ ] data ) throws  GSSException { try {  Der Value der Val = new  Der Value ( data ) ; der Encoding = der Val . to Byte Array ( ) ; oid = der Val . get OID ( ) ; } catch (  IOException e ) { throw new  GSSException (  GSSException .  FAILURE , _ STR ) ; } }
public  String detect ( ) throws  Lang Detect Exception {  Array List <  Language > probabilities = get Probabilities ( ) ; if ( probabilities . size ( ) > _ NUM ) return probabilities . get ( _ NUM ) . lang ; return  UNKNOWN_ LANG ; }
private void type Alphabetic ( char c ) { if (  Character . is Upper Case ( c ) ) { controller . key Press (  Key Event .  VK_ SHIFT ) ; } controller . key Press (  Character . to Upper Case ( c ) ) ; controller . key Release (  Character . to Upper Case ( c ) ) ; if (  Character . is Upper Case ( c ) ) { controller . key Release (  Key Event .  VK_ SHIFT ) ; } }
private static boolean eq (  Object o1 ,  Object o2 ) { return ( o1 == null ) ? o2 == null : o1 . equals ( o2 ) ; }
public static  Optional <  Notification > try Find ( @  Nonnull final  Iterable <  Notification > notifications , final long id ) { final com . google . common . base .  Optional <  Notification > result =  Iterables . try Find ( notifications , null ) ; if ( result . is Present ( ) ) { return  Optional . of ( result . get ( ) ) ; } return  Optional . empty ( ) ; }
@  Override public boolean equals (  Object obj ) { if ( obj == this ) { return _ BOOL ; } if ( obj == null ) { return _ BOOL ; } if ( ! ( get Class ( ) == obj . get Class ( ) ) ) { return _ BOOL ; } return super . equals ( obj ) ; }
@  Override public  ILong Putter put ( long index , long value ) { if ( index < limit ( ) ) { index <<= _ NUM ; final  Byte Buffer buf = buffers [ get Which Buffer ( index ) ] ; int index Buffer = get Index In Buffer ( index ) ; buf . put ( index Buffer ++ , ( byte ) ( value > > _ NUM ) ) ; buf . put ( index Buffer ++ , ( byte ) ( value > > _ NUM ) ) ; buf . put ( index Buffer ++ , ( byte ) ( value > > _ NUM ) ) ; buf . put ( index Buffer ++ , ( byte ) ( value > > _ NUM ) ) ; buf . put ( index Buffer ++ , ( byte ) ( value > > _ NUM ) ) ; buf . put ( index Buffer ++ , ( byte ) ( value > > _ NUM ) ) ; buf . put ( index Buffer ++ , ( byte ) ( value > > _ NUM ) ) ; buf . put ( index Buffer , ( byte ) ( value ) ) ; } else throw new  Array Index Out Of Bounds Exception ( _ STR + index ) ; return this ; }
public int put (  Object key , int value ) { if ( key == null ) key =  NULL_ KEY ; synchronized ( this ) { int hash = key . hash Code ( ) & _mask ; for (  Item item = _entries [ hash ] ; item != null ; item = item . _next ) {  Object test Key = item . _key ; if ( test Key == key || test Key . equals ( key ) ) { int old Value = item . _value ; item . _value = value ; return old Value ; } }  Item item = new  Item ( key , value ) ; item . _next = _entries [ hash ] ; _entries [ hash ] = item ; _size ++ ; } return  NULL ; }
protected void paint Content Border Right Edge (  Graphics g , int x , int y , int w , int h , boolean draw Broken ,  Rectangle sel Rect , boolean is Content Border Painted ) { if ( is Content Border Painted ) { g . set Color ( dark Shadow ) ; g . fill Rect ( x + w - _ NUM , y , _ NUM , h ) ; } }
public void test_session Protection ( ) { final  Journal store = (  Journal ) get Store ( ) ; try { final  RWStrategy bs = (  RWStrategy ) store . get Buffer Strategy ( ) ; final  RWStore rw = bs . get Store ( ) ; final byte [ ] buf = new byte [ _ NUM ] ; r . next Bytes ( buf ) ; final  Byte Buffer bb =  Byte Buffer . wrap ( buf ) ; long faddr = bs . write ( bb ) ;  IRaw Tx tx = rw . new Tx ( ) ; bs . delete ( faddr ) ; bb . position ( _ NUM ) ; final  Byte Buffer rd Buf = bs . read ( faddr ) ; assert Equals ( bb , rd Buf ) ; tx . close ( ) ; store . commit ( ) ; } finally { store . destroy ( ) ; } }
public static <  T >  Parallel Flowable <  T > from (  Publisher < ? extends  T > source , int parallelism ) { return from ( source , parallelism ,  Flowable . buffer Size ( ) ) ; }
public void add To Queue (  Collection < ? extends  Var > vars ) { batch . add All ( vars ) ; if ( batch . size ( ) >= batch Size ) { submit Batch ( batch ) ; batch . clear ( ) ; } }
public static  String combine Extra Style (  String style ,  String extra Style ) {  String res ; if ( style == null ) { style = _ STR ; } else { style = style . trim ( ) ; } if ( extra Style == null ) { extra Style = _ STR ; } else { extra Style = extra Style . trim ( ) ; } if ( style . is Empty ( ) ) { if ( extra Style . starts With ( _ STR ) || extra Style . starts With ( _ STR ) ) { res = _ STR + extra Style . substring ( _ NUM ) ; } else { res = _ STR + extra Style ; } } else { if ( extra Style . starts With ( _ STR ) || extra Style . starts With ( _ STR ) ) { res = style + _ STR + extra Style . substring ( _ NUM ) ; } else { res = style + _ STR + extra Style ; } } return res ; }
@  Request Processing ( value = _ STR , method =  HTTPRequest Method .  GET ) @  Before ( advice Class = {  Stopwatch Start Advice . class ,  Anonymous View Check . class ,  User Block Check . class } ) @  After ( advice Class =  Stopwatch End Advice . class ) public void show Home ( final  HTTPRequest Context context , final  Http Servlet Request request , final  Http Servlet Response response , final  String user Name ) throws  Exception { final  JSONObject user = (  JSONObject ) request . get Attribute (  User .  USER ) ;  String page Num Str = request . get Parameter ( _ STR ) ; if (  Strings . is Empty Or Null ( page Num Str ) || !  Strings . is Numeric ( page Num Str ) ) { page Num Str = _ STR ; } final int page Num =  Integer . value Of ( page Num Str ) ; request . set Attribute (  Keys .  TEMAPLTE_ DIR_ NAME ,  Symphonys . get ( _ STR ) ) ; final  Abstract Free Marker Renderer renderer = new  Skin Renderer ( ) ; context . set Renderer ( renderer ) ; final  Map <  String ,  Object > data Model = renderer . get Data Model ( ) ; filler . fill Header And Footer ( request , response , data Model ) ; final  String following Id = user . opt String (  Keys .  OBJECT_ ID ) ; data Model . put (  Follow .  FOLLOWING_ ID , following Id ) ; renderer . set Template Name ( _ STR ) ; data Model . put (  User .  USER , user ) ; fill Home User ( data Model , user ) ; avatar Query Service . fill User Avatar URL ( user ) ; final boolean is Logged In = (  Boolean ) data Model . get (  Common .  IS_ LOGGED_ IN ) ; if ( is Logged In ) { final  JSONObject current User = (  JSONObject ) data Model . get (  Common .  CURRENT_ USER ) ; final  String follower Id = current User . opt String (  Keys .  OBJECT_ ID ) ; final boolean is Following = follow Query Service . is Following ( follower Id , following Id ) ; data Model . put (  Common .  IS_ FOLLOWING , is Following ) ; } user . put (  User Ext .  USER_ T_ CREATE_ TIME , new  Date ( user . get Long (  Keys .  OBJECT_ ID ) ) ) ; final int page Size =  Symphonys . get Int ( _ STR ) ; final int window Size =  Symphonys . get Int ( _ STR ) ; final  List <  JSONObject > user Articles = article Query Service . get User Articles ( user . opt String (  Keys .  OBJECT_ ID ) , page Num , page Size ) ; data Model . put (  Common .  USER_ HOME_ ARTICLES , user Articles ) ; final int article Cnt = user . opt Int (  User Ext .  USER_ ARTICLE_ COUNT ) ; final int page Count = ( int )  Math . ceil ( ( double ) article Cnt / ( double ) page Size ) ; final  List <  Integer > page Nums =  Paginator . paginate ( page Num , page Size , page Count , window Size ) ; if ( ! page Nums . is Empty ( ) ) { data Model . put (  Pagination .  PAGINATION_ FIRST_ PAGE_ NUM , page Nums . get ( _ NUM ) ) ; data Model . put (  Pagination .  PAGINATION_ LAST_ PAGE_ NUM , page Nums . get ( page Nums . size ( ) - _ NUM ) ) ; } data Model . put (  Pagination .  PAGINATION_ CURRENT_ PAGE_ NUM , page Num ) ; data Model . put (  Pagination .  PAGINATION_ PAGE_ COUNT , page Count ) ; data Model . put (  Pagination .  PAGINATION_ PAGE_ NUMS , page Nums ) ; final  JSONObject current User =  Sessions . current User ( request ) ; if ( null == current User ) { data Model . put (  Common .  IS_ MY_ ARTICLE , _ BOOL ) ; } else { data Model . put (  Common .  IS_ MY_ ARTICLE , user Name . equals ( current User . opt String (  User .  USER_ NAME ) ) ) ; } }
public final double similarity ( final boolean [ ] sig1 , final boolean [ ] sig2 ) { double agg = _ NUM ; for ( int i = _ NUM ; i < sig1 . length ; i ++ ) { if ( sig1 [ i ] == sig2 [ i ] ) { agg ++ ; } } agg = agg / sig1 . length ; return  Math . cos ( ( _ NUM - agg ) *  Math .  PI ) ; }
private int measure Height ( int measure Spec ) { float result ; int spec Mode =  Measure Spec . get Mode ( measure Spec ) ; int spec Size =  Measure Spec . get Size ( measure Spec ) ; if ( spec Mode ==  Measure Spec .  EXACTLY ) { result = spec Size ; } else { result = m Paint Selected . get Stroke Width ( ) + get Padding Top ( ) + get Padding Bottom ( ) ; if ( spec Mode ==  Measure Spec .  AT_ MOST ) { result =  Math . min ( result , spec Size ) ; } } return ( int )  Math . ceil ( result ) ; }
public void layout (  Container container ) {  Map <  Location ,  Drawable > comps = get Components By Location ( container ) ;  Drawable north = comps . get (  Location .  NORTH ) ;  Drawable north East = comps . get (  Location .  NORTH_ EAST ) ;  Drawable east = comps . get (  Location .  EAST ) ;  Drawable south East = comps . get (  Location .  SOUTH_ EAST ) ;  Drawable south = comps . get (  Location .  SOUTH ) ;  Drawable south West = comps . get (  Location .  SOUTH_ WEST ) ;  Drawable west = comps . get (  Location .  WEST ) ;  Drawable north West = comps . get (  Location .  NORTH_ WEST ) ;  Drawable center = comps . get (  Location .  CENTER ) ; double width West = get Max Width ( north West , west , south West ) ; double width East = get Max Width ( north East , east , south East ) ; double height North = get Max Height ( north West , north , north East ) ; double height South = get Max Height ( south West , south , south East ) ; double gap West = ( width West > _ NUM && center != null ) ? get Gap X ( ) : _ NUM ; double gap East = ( width East > _ NUM && center != null ) ? get Gap X ( ) : _ NUM ; double gap North = ( height North > _ NUM && center != null ) ? get Gap Y ( ) : _ NUM ; double gap South = ( height South > _ NUM && center != null ) ? get Gap Y ( ) : _ NUM ;  Rectangle2 D bounds = container . get Bounds ( ) ;  Insets2 D insets = container . get Insets ( ) ; if ( insets == null ) { insets = new  Insets2 D .  Double ( ) ; } double x West = bounds . get Min X ( ) + insets . get Left ( ) ; double x Center = x West + width West + gap West ; double x East = bounds . get Max X ( ) - insets . get Right ( ) - width East ; double y North = bounds . get Min Y ( ) + insets . get Top ( ) ; double y Center = y North + height North + gap North ; double y South = bounds . get Max Y ( ) - insets . get Bottom ( ) - height South ; double width All = width West + width East ; double height All = height North + height South ; double gap HAll = gap West + gap East ; double gap VAll = gap North - gap South ; layout Component ( north West , x West , y North , width West , height North ) ; layout Component ( north , x Center , y North , bounds . get Width ( ) - insets . get Horizontal ( ) - width All - gap HAll , height North ) ; layout Component ( north East , x East , y North , width East , height North ) ; layout Component ( east , x East , y Center , width East , bounds . get Height ( ) - insets . get Vertical ( ) - height All - gap VAll ) ; layout Component ( south East , x East , y South , width East , height South ) ; layout Component ( south , x Center , y South , bounds . get Width ( ) - insets . get Horizontal ( ) - width All - gap HAll , height South ) ; layout Component ( south West , x West , y South , width West , height South ) ; layout Component ( west , x West , y Center , width West , bounds . get Height ( ) - insets . get Vertical ( ) - height All - gap VAll ) ; layout Component ( center , x Center , y Center , bounds . get Width ( ) - insets . get Left ( ) - width All - insets . get Right ( ) - gap HAll , bounds . get Height ( ) - insets . get Top ( ) - height All - insets . get Bottom ( ) - gap VAll ) ; }
public void append ( byte [ ] buffer , int offset , int length ) { if ( _length + length >= _capacity ) ensure Capacity ( _length + length ) ;  System . arraycopy ( buffer , offset , _buffer , _length , length ) ; _length += length ; }
static public void fill Random Uniform (  IDouble Vector vec ,  Random rand , double min , double max ) { final double delta = max - min ; for ( int i = _ NUM ; i < vec . get Length ( ) ; ++ i ) { vec . set ( i , min + rand . next Double ( ) * delta ) ; } }
protected void draw Value (  Canvas c ,  String value , float x Pos , float y Pos ) { c . draw Text ( value , x Pos , y Pos , m Value Paint ) ; }
public static  Date parse Date ( final  String format , final  String date String ) throws  DSSException { try { final  Simple Date Format sdf = new  Simple Date Format ( format ) ; final  Date date = sdf . parse ( date String ) ; return date ; } catch (  Parse Exception e ) { throw new  DSSException ( e ) ; } }
private static boolean equals Handles Nulls (  Local Item a ,  Local Item b ) { return ( a == b ) || ( ( a != null ) && a . equals ( b ) ) ; }
public static  Set <  String > uri List To Set (  List <  URI > uris ) {  Set <  String > set = new  Hash Set <  String > ( ) ; if ( uris != null && ! uris . is Empty ( ) ) { for (  URI uri : uris ) { set . add ( uri . to String ( ) ) ; } } return set ; }
public final static void close EL ( final  Input Stream is ) { try { if ( is != null ) is . close ( ) ; } catch ( final  Throwable e ) { } }
private  String linkify Monitor (  String line ) { if ( line != null && line . index Of ( _ STR ) >= _ NUM ) {  String begin = line . substring ( _ NUM , line . index Of ( _ STR ) ) ;  String monitor = line . substring ( line . index Of ( _ STR ) , line . index Of ( _ STR ) + _ NUM ) ;  String end = line . substring ( line . index Of ( _ STR ) + _ NUM ) ; monitor = monitor . replace All ( _ STR , _ STR + monitor + _ STR ) ; monitor = monitor . substring ( _ NUM , monitor . length ( ) - _ NUM ) + _ STR ; return ( begin + monitor + end ) ; } else if ( line != null && line . index Of ( _ STR ) >= _ NUM ) {  String begin = line . substring ( _ NUM , line . index Of ( _ STR ) + _ NUM ) ;  String monitor = line . substring ( line . index Of ( _ STR ) ) ; monitor = monitor . replace All ( _ STR , _ STR + monitor . substring ( _ NUM ) + _ STR ) ; monitor = monitor . substring ( _ NUM , monitor . length ( ) - _ NUM ) + _ STR ; return ( begin + monitor ) ; } else { return ( line ) ; } }
public static  String htmlentities ( final  String str ) { if ( str == null ) { return _ STR ; } if ( htmlentities_map . is Empty ( ) ) { initialize Entities Tables ( ) ; } final  String Builder buf = new  String Builder ( ) ; for ( int i = _ NUM ; i < str . length ( ) ; ++ i ) { final char ch = str . char At ( i ) ; final  String entity = htmlentities_map . get ( new  Integer ( ch ) ) ; if ( entity == null ) { if ( ch > _ NUM ) { buf . append ( _ STR + ( int ) ch + _ STR ) ; } else { buf . append ( ch ) ; } } else { buf . append ( entity ) ; } } return buf . to String ( ) ; }
@  Action ( value = _ STR ) @  Validation Error Page ( value =  ERROR ) @  Skip Validation public  String view Challan ( ) { if ( challan Id == null ) receipt Header = receipt Header Service . find By Id ( receipt Id , _ BOOL ) ; else receipt Header = (  Receipt Header ) persistence Service . find By Named Query (  Collection Constants .  QUERY_ RECEIPT_ BY_ CHALLANID ,  Long . value Of ( challan Id ) ) ; set Login Dept ( ) ; load Receipt Details ( ) ; return  VIEW ; }
boolean is Disjoint (  Type Declaration td ) { if ( this instanceof  Union Type ) { return _ BOOL ; } if ( this instanceof  Class Or Interface && td instanceof  Class Or Interface && equals ( td ) ) { return _ BOOL ; } if ( this instanceof  Type Parameter && td instanceof  Type Parameter && equals ( td ) ) { return _ BOOL ; }  List <  Type > sts = get Satisfied Types ( ) ; for ( int i = _ NUM , s = sts . size ( ) ; i < s ; i ++ ) {  Type st = sts . get ( i ) ; if ( is Disjoint ( td , st ) ) { return _ BOOL ; } }  Type et = get Extended Type ( ) ; if ( et != null ) { if ( is Disjoint ( td , et ) ) { return _ BOOL ; } } return _ BOOL ; }
public void offer Busy Box (  Activity activity ) {  Root Tools . log ( _ STR ) ;  Intent i = new  Intent (  Intent .  ACTION_ VIEW ,  Uri . parse ( _ STR ) ) ; activity . start Activity ( i ) ; }
private static void read Data From Binlog (  Replicator Runtime runtime ,  Binlog Reader binlog , byte [ ] data , int offset , int length , int timeout ) throws  IOException ,  Replicator Exception ,  Interrupted Exception { boolean already Logged = _ BOOL ; int spent Time = _ NUM ; int timeout In Ms = timeout * _ NUM ; long available ; while ( ( available = binlog . available ( ) ) < ( long ) length ) { if ( ! already Logged ) { if ( logger . is Debug Enabled ( ) ) { logger . debug ( _ STR + length + _ STR + available + _ STR + binlog . get File Name ( ) + _ STR ) ; } already Logged = _ BOOL ; } try { if ( spent Time < timeout In Ms ) {  Thread . sleep ( _ NUM ) ; spent Time ++ ; } else throw new  My SQLExtract Exception ( _ STR + timeout + _ STR + length + _ STR ) ; } catch (  Interrupted Exception e ) { } } binlog . read ( data , offset , length ) ; }
public static boolean check CGCreated On Back End Array (  Volume volume ) { return ( volume != null &&  Null Column Value Getter . is Not Null Value ( volume . get Replication Group Instance ( ) ) ) ; }
private void do Wait For (  Process process ) { start Read Stream Thread ( process . get Input Stream ( ) ) ; start Read Stream Thread ( process . get Error Stream ( ) ) ; try { process . wait For ( ) ; } catch (  Interrupted Exception e ) { log . warn ( _ STR , e ) ; } }
public static  String escape (  String input ) { boolean insidequote = _ BOOL ;  String output = _ STR ; for ( int i = _ NUM ; i < input . length ( ) ; i ++ ) { char current = input . char At ( i ) ; if ( current == _ STR ) { insidequote = ! insidequote ; output += current ; } else if ( insidequote ) { if ( current == _ STR ) { output += _ STR ; } else if ( current == _ STR ) { output += _ STR ; } else if ( current == _ STR ) { output += _ STR ; } else if ( current == _ STR ) { output += _ STR ; } else if ( current == _ STR ) { output += _ STR ; } else if ( current == _ STR ) { output += _ STR ; } else { output += current ; } } else { if ( current == _ STR ) { output += _ STR ; } else { output += current ; } } } return output ; }
private static byte [ ] parse Proj From Parent (  Parsable Byte Array parent , int position , int size ) { int child Position = position +  Atom .  HEADER_ SIZE ; while ( child Position - position < size ) { parent . set Position ( child Position ) ; int child Atom Size = parent . read Int ( ) ; int child Atom Type = parent . read Int ( ) ; if ( child Atom Type ==  Atom .  TYPE_proj ) { return  Arrays . copy Of Range ( parent . data , child Position , child Position + child Atom Size ) ; } child Position += child Atom Size ; } return null ; }
public boolean contains Any (  Taxon List taxon List ) { for ( int i = _ NUM ; i < taxon List . get Taxon Count ( ) ; i ++ ) {  Taxon taxon = taxon List . get Taxon ( i ) ; if ( taxa . contains ( taxon ) ) { return _ BOOL ; } } return _ BOOL ; }
protected int draw Label Text ( int text Decoration , boolean rtl , boolean is Ticker Running , boolean ends With3 Points ,  Object native Font , int txt W , int text Space W , int shift Text ,  String text , int x , int y , int font Height ) { if ( ( ! is Ticker Running ) || rtl ) { if ( txt W > text Space W && text Space W > _ NUM ) { if ( rtl ) { if ( ( ! is Ticker Running ) && ends With3 Points ) {  String points = _ STR ; int points W = impl . string Width ( native Font , points ) ; draw String ( native Font , points , shift Text + x , y , text Decoration , font Height ) ; clip Rect ( points W + shift Text + x , y , text Space W - points W , font Height ) ; } x = x - txt W + text Space W ; } else if ( ends With3 Points ) {  String points = _ STR ; int index = _ NUM ; int widest = impl . char Width ( native Font , _ STR ) ; int points W = impl . string Width ( native Font , points ) ; while ( fast Char Width Check ( text , index , text Space W - points W , widest , native Font ) && index < text . length ( ) ) { index ++ ; } text = text . substring ( _ NUM ,  Math . min ( text . length ( ) ,  Math . max ( _ NUM , index - _ NUM ) ) ) + points ; txt W = impl . string Width ( native Font , text ) ; } } } draw String ( native Font , text , shift Text + x , y , text Decoration , font Height ) ; return  Math . min ( txt W , text Space W ) ; }
public void apply Interpolated Radii ( ) {  Assert . is True ( map Objects != null ) ;  Assert . is True ( map Objects . size ( ) > _ NUM ) ;  Internal Map Object min = null , max = null ; for (  Internal Map Object map Object : map Objects ) { if ( min == null || map Object . get Value ( ) < min . get Value ( ) ) { min = map Object ; } if ( max == null || map Object . get Value ( ) > max . get Value ( ) ) { max = map Object ; } } for (  Internal Map Object map Object : map Objects ) { double factor = ( map Object . get Value ( ) - min . get Value ( ) ) / ( max . get Value ( ) - min . get Value ( ) ) ; int radius =  Map Utils . lerp ( radius Low , radius High , factor ) ; map Object . set Radius ( radius ) ; } }
protected void add Items (  List < ? extends  Action > actions ) {  Action Container Factory factory = new  Action Container Factory ( null ) ; for (  Action action : actions ) {  Abstract Action Ext a = (  Abstract Action Ext ) action ; if ( action . is Enabled ( ) ) { if ( a . is State Action ( ) ) add Item ( create Check Box ( (  Abstract Action Ext ) action ) ) ; else { add Item ( factory . create Button ( action ) ) ; } } } }
public boolean append_items (  String p_button_name ,  String p_window_title , java . util .  Collection <  Brd Item > p_items ) { java . util .  Collection <  Printable Info > object_list = new java . util .  Linked List <  Printable Info > ( ) ; object_list . add All ( p_items ) ; return append_objects ( p_button_name , p_window_title , object_list ) ; }
public void test_prefix Namespace Override ( ) { final  IIndex Manager index Manager = null ; final  Properties properties = new  Properties ( ) ; final  String namespace = _ STR ; final  String global Name = _ STR ; final  String default Value = _ STR ; final  String override Name =  Configuration . get Override Property ( namespace , global Name ) ; final  String override Value = _ STR ; assert Equals ( default Value ,  Configuration . get Property ( index Manager , properties , namespace , global Name , default Value ) ) ; properties . set Property ( override Name , override Value ) ; assert Equals ( override Value ,  Configuration . get Property ( index Manager , properties , namespace , global Name , default Value ) ) ; }
public  Dimension preferred Layout Size (  Container target ) { synchronized ( target . get Tree Lock ( ) ) {  Dimension dim = new  Dimension ( _ NUM , _ NUM ) ; if ( ( chart != null ) && chart . is Visible ( ) ) {  Dimension d = chart . get Preferred Size ( ) ; dim . width = d . width ; dim . height = d . height ; } if ( ( x Label != null ) && x Label . is Visible ( ) ) {  Dimension d = x Label . get Preferred Size ( ) ; dim . width =  Math . max ( d . width , dim . width ) ; dim . height += d . height + vgap ; } if ( ( y Label != null ) && y Label . is Visible ( ) ) {  Dimension d = y Label . get Preferred Size ( ) ; dim . width += d . width + hgap ; dim . height =  Math . max ( d . height , dim . height ) ; } if ( ( title != null ) && title . is Visible ( ) ) {  Dimension d = title . get Preferred Size ( ) ; dim . width =  Math . max ( d . width , dim . width ) ; dim . height += d . height + vgap ; }  Insets insets = target . get Insets ( ) ; dim . width += insets . left + insets . right ; dim . height += insets . top + insets . bottom ; return dim ; } }
public void replace ( final  Resource resource , final  List <  Resource > expanded Resources ) {  LOG . debug ( _ STR , resource , expanded Resources ) ; not Null ( resource ) ; not Null ( expanded Resources ) ; synchronized ( this ) { boolean found = _ BOOL ; final  Set <  Resource > result = new  Linked Hash Set <  Resource > ( ) ; for ( final  Resource resource Item : resources ) { if ( resource Item . equals ( resource ) ) { found = _ BOOL ; for ( final  Resource expanded Resource : expanded Resources ) { expanded Resource . set Minimize ( resource . is Minimize ( ) ) ; result . add ( expanded Resource ) ; } } else { result . add ( resource Item ) ; } } if ( ! found ) { throw new  Illegal Argument Exception ( _ STR + resource + _ STR + this + _ STR ) ; } set Resources ( new  Array List <  Resource > ( result ) ) ; } }
public javax . sip . address .  Tel URL create Tel URL (  String uri ) throws  Parse Exception { if ( uri == null ) throw new  Null Pointer Exception ( _ STR ) ;  String tel Url = null ; if ( uri . starts With ( _ STR ) ) { tel Url = uri ; } else { tel Url = _ STR + uri ; } try {  String Msg Parser smp = new  String Msg Parser ( ) ;  Tel URLImpl timp = (  Tel URLImpl ) smp . parse Url ( tel Url ) ; return (  Tel URL ) timp ; } catch (  Parse Exception ex ) { throw new  Parse Exception ( ex . get Message ( ) , _ NUM ) ; } }
public  Kernel Logistic Regression Model (  Example Set example Set ,  List <  Support Vector > support Vectors ,  Kernel kernel , double bias ) { super ( example Set ,  Example Set Utilities .  Sets Compare Option .  ALLOW_ SUPERSET ,  Example Set Utilities .  Types Compare Option .  ALLOW_ SAME_ PARENTS ) ; this . support Vectors = support Vectors ; if ( support Vectors == null || support Vectors . size ( ) == _ NUM ) { throw new  Illegal Argument Exception ( _ STR ) ; } this . kernel = kernel ; this . bias = bias ; }
public boolean remove Update ( final  Password password ) throws  IOException ,  Servlet Exception { if ( ! singelton . can (  CFMLEngine .  CAN_ UPDATE , password ) ) throw new  IOException ( _ STR ) ; return remove Update ( ) ; }
public  Code Viewer ( ) { set Highlight Color (  DEFAULT_ HIGHLIGHT_ COLOR ) ; init Actions ( ) ; set Layout ( new  Border Layout ( ) ) ; code Highlight Bar = create Code Highlight Bar ( ) ; code Highlight Bar . set Visible ( _ BOOL ) ; add ( code Highlight Bar ,  Border Layout .  NORTH ) ; code Panel = create Code Panel ( ) ; add ( code Panel ,  Border Layout .  CENTER ) ; apply Defaults ( ) ; }
public static double logpdf ( double x , double mu , double sigma , double k ) { if ( x ==  Double .  POSITIVE_ INFINITY || x ==  Double .  NEGATIVE_ INFINITY ) { return  Double .  NEGATIVE_ INFINITY ; } x = ( x - mu ) / sigma ; if ( k > _ NUM || k < _ NUM ) { if ( k * x > _ NUM ) { return  Double .  NEGATIVE_ INFINITY ; } double t =  Math . log ( _ NUM - k * x ) ; return t ==  Double .  NEGATIVE_ INFINITY ? -  Math . log ( sigma ) : t ==  Double .  POSITIVE_ INFINITY ?  Double .  NEGATIVE_ INFINITY : ( _ NUM - k ) * t / k -  Math . exp ( t / k ) -  Math . log ( sigma ) ; } else { return - x -  Math . exp ( - x ) -  Math . log ( sigma ) ; } }
public static  Format generate Format (  String codec ) { return s Supported Codexs . get ( codec . to Lower Case ( ) ) ; }
public  Optional Int min By Int (  Int Unary Operator key Extractor ) { int [ ] result = collect ( null , null , null ) ; return result [ _ NUM ] == _ NUM ?  Optional Int . of ( result [ _ NUM ] ) :  Optional Int . empty ( ) ; }
public void test_one Prefix ( ) { final  BTree btree ; {  Index Metadata md = new  Index Metadata (  UUID . random UUID ( ) ) ; md . set Tuple Serializer ( tuple Ser ) ; btree =  BTree . create ( new  Simple Memory Raw Store ( ) , md ) ; } btree . insert ( _ STR , _ STR ) ; btree . insert ( _ STR , _ STR ) ; btree . insert ( _ STR , _ STR ) ; btree . insert ( _ STR , _ STR ) ; btree . insert ( _ STR , _ STR ) ; btree . insert ( _ STR , _ STR ) ; btree . dump (  Level .  DEBUG ,  System . err ) ; { final  ITuple Iterator <  String > itr = btree . range Iterator ( null , null , _ NUM ,  IRange Query .  DEFAULT |  IRange Query .  CURSOR , new  Prefix Filter <  String > ( as Prefix Key ( _ STR ) ) ) ; assert True ( itr . has Next ( ) ) ;  Abstract Tuple Cursor Test Case . assert Equals ( new Test Tuple ( _ STR ) , itr . next ( ) ) ; assert True ( itr . has Next ( ) ) ;  Abstract Tuple Cursor Test Case . assert Equals ( new Test Tuple ( _ STR ) , itr . next ( ) ) ; assert False ( itr . has Next ( ) ) ; } { final  ITuple Iterator <  String > itr = btree . range Iterator ( null , null , _ NUM ,  IRange Query .  DEFAULT |  IRange Query .  CURSOR , new  Prefix Filter <  String > ( as Prefix Key ( _ STR ) ) ) ; assert True ( itr . has Next ( ) ) ;  Abstract Tuple Cursor Test Case . assert Equals ( new Test Tuple ( _ STR ) , itr . next ( ) ) ; assert True ( itr . has Next ( ) ) ;  Abstract Tuple Cursor Test Case . assert Equals ( new Test Tuple ( _ STR ) , itr . next ( ) ) ; assert False ( itr . has Next ( ) ) ; } { final  ITuple Iterator <  String > itr = btree . range Iterator ( null , null , _ NUM ,  IRange Query .  DEFAULT |  IRange Query .  CURSOR , new  Prefix Filter <  String > ( as Prefix Key ( _ STR ) ) ) ; assert True ( itr . has Next ( ) ) ;  Abstract Tuple Cursor Test Case . assert Equals ( new Test Tuple ( _ STR ) , itr . next ( ) ) ; assert True ( itr . has Next ( ) ) ;  Abstract Tuple Cursor Test Case . assert Equals ( new Test Tuple ( _ STR ) , itr . next ( ) ) ; assert True ( itr . has Next ( ) ) ;  Abstract Tuple Cursor Test Case . assert Equals ( new Test Tuple ( _ STR ) , itr . next ( ) ) ; assert True ( itr . has Next ( ) ) ;  Abstract Tuple Cursor Test Case . assert Equals ( new Test Tuple ( _ STR ) , itr . next ( ) ) ; assert False ( itr . has Next ( ) ) ; } { final  ITuple Iterator <  String > itr = btree . range Iterator ( null , null , _ NUM ,  IRange Query .  DEFAULT |  IRange Query .  CURSOR , new  Prefix Filter <  String > ( as Prefix Key ( _ STR ) ) ) ; assert False ( itr . has Next ( ) ) ; } }
public static  String format Exception (  Exception exc ) {  String Writer string Writer = new  String Writer ( ) ;  Print Writer print Writer = new  Print Writer ( string Writer ) ; exc . print Stack Trace ( print Writer ) ; try { string Writer . close ( ) ; } catch (  IOException ex ) { } return string Writer . to String ( ) ; }
private int compare Vdc Config Version (  String left ,  String right ) { if ( left == null && right == null ) { return _ NUM ; } if ( left == null && right != null ) { return - _ NUM ; } if ( left != null && right == null ) { return _ NUM ; } return ( int ) (  Long . parse Long ( left ) -  Long . parse Long ( right ) ) ; }
public void on Child Thread Resume End ( ) { int thread Max = _thread Count . get And Decrement ( ) ; if ( _thread Max <= thread Max ) { wake ( ) ; } wake If Low Idle ( ) ; }
public static void register Local Time MBean (  String container Name ) {  MBean Server m Bean Server = get MBean Server ( container Name ) ; if ( m Bean Server == null ) return ;  Local Time MBean local Time MBean = new  Local Time ( ) ;  Object Name obj Name =  Local Time Constants .  MBEAN_ NAME ; if ( ! m Bean Server . is Registered ( obj Name ) ) { try { m Bean Server . register MBean ( local Time MBean , obj Name ) ; } catch (  Instance Already Exists Exception e ) { } catch (  Not Compliant MBean Exception e ) { if ( _logger . is Loggable (  Level .  WARNING ) ) { _logger . log (  Level .  SEVERE , failed Local Time MBean Registration Message Prefix + container Name + _ STR , e ) ; } } catch (  MBean Registration Exception e ) { if ( _logger . is Loggable (  Level .  SEVERE ) ) { _logger . log (  Level .  SEVERE , failed Local Time MBean Registration Message Prefix + container Name + _ STR , e ) ; } } if ( _logger . is Loggable (  Level .  CONFIG ) ) { _logger . config ( successful Transport MBean Registration Message + container Name + _ STR ) ; } } }
final public static int insert Table (  V sets ,  Class < ? extends  Bean > t ) {  Table mapping = (  Table ) t . get Annotation (  Table . class ) ; if ( mapping == null ) { if ( log . is Error Enabled ( ) ) log . error ( _ STR + t + _ STR ) ; return - _ NUM ; } if ( !  X . is Empty ( mapping . name ( ) ) ) { return insert Table ( mapping . name ( ) , sets ) ; } return - _ NUM ; }
private synchronized void cleanup Futures ( ) { if ( scheduler Future != null ) { scheduler Future . cancel ( _ BOOL ) ; scheduler Future = null ; } if ( monitor Future != null ) { monitor Future . cancel ( _ BOOL ) ; monitor Future = null ; } }
public final void remove Listener (  TListener listener ) { listeners . remove ( listener ) ; }
private void update Entries (  Cache <  Integer ,  Integer > cache , int new Val , boolean invoke ,  Set <  Integer > keys ) { if ( invoke ) cache . invoke All ( keys , new  Integer Set Value ( new Val ) ) ; else { final  Map <  Integer ,  Integer > entries = new  Hash Map < > (  ENTRY_ COUNT ) ; for ( final  Integer key : keys ) entries . put ( key , new Val ) ; cache . put All ( entries ) ; } }
public void clear (  Absolute Table Identifier absolute Table Identifier ) { table Lock Map . remove ( absolute Table Identifier ) ; table Segment Map . remove ( absolute Table Identifier ) ; }
private static  Set <  Annotation Mirror > find All Supers (  Annotation Mirror anno ,  Map <  Annotation Mirror ,  Set <  Annotation Mirror > > supertypes ,  Map <  Annotation Mirror ,  Set <  Annotation Mirror > > all Supers So Far ) {  Set <  Annotation Mirror > supers =  Annotation Utils . create Annotation Set ( ) ; for (  Annotation Mirror super Anno : supertypes . get ( anno ) ) { supers . add ( super Anno ) ; supers . add All ( find All Supers ( super Anno , supertypes , all Supers So Far ) ) ; } all Supers So Far . put ( anno ,  Collections . unmodifiable Set ( supers ) ) ; return supers ; }
public void task Soon Main ( final  Runnable r , boolean async ) { if ( async ) { async ( r ) ; } else { task ( r ) ; } }
protected  Array List < float [ ] > forward Rhumb Poly ( double [ ] rawllpts , int nsegs , boolean is Filled ) { if ( this instanceof  Mercator ) { return _forward Poly ( rawllpts ,  Line Type .  Straight , nsegs , is Filled ) ; } int i , n , xp , flag = _ NUM , xadj = _ NUM , totalpts = _ NUM ;  Point from = new  Point ( _ NUM , _ NUM ) ;  Point to = new  Point ( _ NUM , _ NUM ) ; int len = rawllpts . length ; double [ ] [ ] augllpts = new double [ len > > > _ NUM ] [ _ NUM ] ; mercator . forward ( rawllpts [ _ NUM ] , rawllpts [ _ NUM ] , from , _ BOOL ) ; xp = from . x ; for ( i = _ NUM , n = _ NUM ; n < len ; i ++ , n += _ NUM ) { mercator . forward ( rawllpts [ n ] , rawllpts [ n + _ NUM ] , to , _ BOOL ) ; if (  Math . abs ( xp - to . x ) >= mercator . half_world ) { flag += ( xp < to . x ) ? - _ NUM : _ NUM ; xadj = flag * mercator . world . x ; } xp = to . x ; if ( flag != _ NUM ) { to . x += xadj ; } augllpts [ i ] = mercator . rhumb Project Double ( from , to , _ BOOL , nsegs ) ; totalpts += augllpts [ i ] . length ; from . x = to . x ; from . y = to . y ; }  Lat Lon Point llp = new  Lat Lon Point .  Double ( ) ; mercator . inverse ( from , llp ) ; augllpts [ i ] = new double [ _ NUM ] ; augllpts [ i ] [ _ NUM ] = llp . get Rad Lat ( ) ; augllpts [ i ] [ _ NUM ] = llp . get Rad Lon ( ) ; totalpts += _ NUM ; double [ ] newllpts = new double [ totalpts ] ; int pos = _ NUM ; for ( i = _ NUM ; i < augllpts . length ; i ++ ) {  System . arraycopy ( augllpts [ i ] , _ NUM , newllpts , pos , augllpts [ i ] . length ) ; pos += augllpts [ i ] . length ; } augllpts = null ; return _forward Poly ( newllpts ,  Line Type .  Straight , - _ NUM , is Filled ) ; }
private  Connection open Connection ( boolean autocommit ) throws  SQLException {  Connection conn = data Src != null ? data Src . get Connection ( ) :  Driver Manager . get Connection ( conn Url , user , passwd ) ; if ( test Mode ) opened . increment ( ) ; conn . set Auto Commit ( autocommit ) ; return conn ; }
public void mouse Pressed (  Mouse Event e ) { if (  Swing Utilities2 . should Ignore ( e , tree ) ) { return ; } if ( is Editing ( tree ) && tree . get Invokes Stop Cell Editing ( ) && ! stop Editing ( tree ) ) { return ; } complete Editing ( ) ; pressed Path = get Closest Path For Location ( tree , e . get X ( ) , e . get Y ( ) ) ; if ( tree . get Drag Enabled ( ) ) { mouse Pressed DND ( e ) ; } else {  Swing Utilities2 . adjust Focus ( tree ) ; handle Selection ( e ) ; } }
public  Object apply (  String source , int line No , int column No ,  Object func Body ,  Vector names Vec ,  Vector args Vec ) throws  BSFException { if ( names Vec . size ( ) != args Vec . size ( ) ) throw new  BSFException ( _ STR ) ; if ( ! ( func Body instanceof  String ) ) throw new  BSFException ( _ STR ) ;  String [ ] names = new  String [ names Vec . size ( ) ] ; names Vec . copy Into ( names ) ;  Object [ ] args = new  Object [ args Vec . size ( ) ] ; args Vec . copy Into ( args ) ; try { if ( ! installed Apply Method ) { interpreter . eval ( bsf Apply Method ) ; installed Apply Method = _ BOOL ; } bsh .  This global = ( bsh .  This ) interpreter . get ( _ STR ) ;  Object value = global . invoke Method ( _ STR , new  Object [ ] { names , args , (  String ) func Body } ) ; return  Primitive . unwrap ( value ) ; } catch (  Interpreter Error e ) { throw new  BSFException ( _ STR + e + source Info ( source , line No , column No ) ) ; } catch (  Target Error e2 ) { throw new  BSFException ( _ STR + e2 . get Target ( ) + source Info ( source , line No , column No ) ) ; } catch (  Eval Error e3 ) { throw new  BSFException ( _ STR + e3 + source Info ( source , line No , column No ) ) ; } }
public  Set key Set ( ) { return map . key Set ( ) ; }
public static void write JSONString (  List list ,  Writer out ) throws  IOException { if ( list == null ) { out . write ( _ STR ) ; return ; } boolean first = _ BOOL ;  Iterator iter = list . iterator ( ) ; out . write ( _ STR ) ; while ( iter . has Next ( ) ) { if ( first ) first = _ BOOL ; else out . write ( _ STR ) ;  Object value = iter . next ( ) ; if ( value == null ) { out . write ( _ STR ) ; continue ; }  JSONValue . write JSONString ( value , out ) ; } out . write ( _ STR ) ; }
public void test Constr String Exception ( ) {  String a = _ STR ; try {  Big Decimal bd = new  Big Decimal ( a ) ; fail ( _ STR + bd . to String ( ) ) ; } catch (  Number Format Exception e ) { } }
private static int [ ] mult With Monomial ( int [ ] a , int k ) { int d = compute Degree ( a ) ; if ( d == - _ NUM ) { return new int [ _ NUM ] ; } int [ ] result = new int [ d + k + _ NUM ] ;  System . arraycopy ( a , _ NUM , result , k , d + _ NUM ) ; return result ; }
@  Override public  Enumeration <  Option > list Options ( ) {  Vector <  Option > result = new  Vector <  Option > ( ) ; result . add Element ( new  Option ( _ STR , _ STR , _ NUM , _ STR ) ) ; result . add Element ( new  Option ( _ STR , _ STR , _ NUM , _ STR ) ) ; result . add Element ( new  Option ( _ STR , _ STR , _ NUM , _ STR ) ) ; result . add Element ( new  Option ( _ STR + _ STR , _ STR , _ NUM , _ STR ) ) ; result . add Element ( new  Option ( _ STR + default Min Inst Num ( ) + _ STR + default Max Inst Num ( ) + _ STR , _ STR , _ NUM , _ STR ) ) ; result . add Element ( new  Option ( _ STR , _ STR , _ NUM , _ STR ) ) ; return result . elements ( ) ; }
public static  String remove (  String seq , char ... to Remove ) {  String Builder sb = new  String Builder ( ) ; for ( int i = _ NUM ; i < seq . length ( ) ; i ++ ) { final char ch = seq . char At ( i ) ; boolean append = _ BOOL ; for ( int j = _ NUM ; j < to Remove . length ; j ++ ) { final char c = to Remove [ j ] ; if ( ch == c ) { append = _ BOOL ; break ; } } if ( append ) { sb . append ( ch ) ; } } return sb . to String ( ) ; }
@  Override public boolean on Kill (  Scheduler .  Kill Topology Request request ) {  String topology Name =  Local Context . topology Name ( config ) ;  LOG . info ( _ STR + topology Name ) ; is Topology Killed = _ BOOL ; synchronized ( process To Container ) { for (  Process p : process To Container . key Set ( ) ) { int index = process To Container . get ( p ) ;  LOG . info ( _ STR + index ) ; p . destroy ( ) ;  LOG . info ( _ STR + index ) ; } process To Container . clear ( ) ; } return _ BOOL ; }
@  Override public  Enumeration <  Option > list Options ( ) {  Vector <  Option > result = new  Vector <  Option > ( ) ; result . add Element ( new  Option ( _ STR , _ STR , _ NUM , _ STR ) ) ; result . add All (  Collections . list ( super . list Options ( ) ) ) ; return result . elements ( ) ; }
public  Filter Spec add Expression (  Filter Spec expr ) { if ( expressions == null ) { expressions = new  Array List < > ( ) ; } expressions . add ( (  Filter Spec ) expr ) ; return this ; }
public void register Data Sent ( long platform Ident ) {  Agent Status Data agent Status Data = agent Status Data Map . get ( platform Ident ) ; if ( null != agent Status Data ) { agent Status Data . set Last Data Send Timestamp (  System . current Time Millis ( ) ) ; } }
public static int deflate ( byte [ ] previous , int previous Length , byte [ ] current , int current Length , byte [ ] result ) { if ( previous == null ) {  System . arraycopy ( current , _ NUM , result , _ NUM , current Length ) ; return current Length ; } int length = _ NUM ; int start1 = _ NUM ; int start2 = _ NUM ; while ( start1 < previous Length && start2 < current Length ) { int end1 = start1 ; int end2 = start2 ; while ( end1 <= previous Length && end2 <= current Length ) { byte c1 = ( end1 < previous Length ? previous [ end1 ] : ( byte ) _ STR ) ; byte c2 = ( end2 < current Length ? current [ end2 ] : ( byte ) _ STR ) ; if ( c1 == c2 ) { if ( c1 == _ STR ) { result [ length ++ ] = _ STR ; break ; } else { end1 ++ ; end2 ++ ; } } else { while ( end1 < previous Length && previous [ end1 ] != _ STR ) { end1 ++ ; } while ( end2 < current Length && current [ end2 ] != _ STR ) { end2 ++ ; } for ( int i = start2 ; i < end2 ; i ++ ) result [ length ++ ] = current [ i ] ; break ; } } start1 = end1 + _ NUM ; start2 = end2 + _ NUM ; if ( start2 < current Length ) result [ length ++ ] = _ STR ; } return length ; }
private static void load Package Data (  Context context ) { if ( context != null ) { try {  Package Manager package Manager = context . get Package Manager ( ) ;  Package Info package Info = package Manager . get Package Info ( context . get Package Name ( ) , _ NUM ) ;  Crash Constants .  APP_ PACKAGE = package Info . package Name ;  Crash Constants .  APP_ VERSION = _ STR + package Info . version Code ;  Crash Constants .  APP_ VERSION_ NAME = package Info . version Name ; int build Number = load Build Number ( context , package Manager ) ; if ( ( build Number != _ NUM ) && ( build Number > package Info . version Code ) ) {  Crash Constants .  APP_ VERSION = _ STR + build Number ; } } catch (  Package Manager .  Name Not Found Exception e ) {  L . e ( _ STR ) ; e . print Stack Trace ( ) ; } } }
public static  Left Indexed Power Law Multi Segment Bipartite Graph build Random Multi Segment Bipartite Graph ( int max Num Segments , int max Num Edges Per Segment , int left Size , int right Size , double edge Probability ,  Random random ) {  Left Indexed Power Law Multi Segment Bipartite Graph multi Segment Left Indexed Power Law Bipartite Graph = new  Left Indexed Power Law Multi Segment Bipartite Graph ( max Num Segments , max Num Edges Per Segment , left Size / _ NUM , ( int ) ( right Size * edge Probability / _ NUM ) , _ NUM , right Size / _ NUM , new  Identity Edge Type Mask ( ) , new  Null Stats Receiver ( ) ) ; for ( int i = _ NUM ; i < left Size ; i ++ ) { for ( int j = _ NUM ; j < right Size ; j ++ ) { if ( random . next Double ( ) < edge Probability ) { multi Segment Left Indexed Power Law Bipartite Graph . add Edge ( i , j , ( byte ) _ NUM ) ; } } } return multi Segment Left Indexed Power Law Bipartite Graph ; }
private void forward Post (  Http URLConnection connection ,  Http Servlet Request request ,  Http Servlet Response response ) throws  IOException { connection . set Do Output ( _ BOOL ) ; connection . set Do Input ( _ BOOL ) ; connection . set Use Caches ( _ BOOL ) ; connection . set Request Method ( _ STR ) ; connection . set Request Property ( _ STR , request . get Content Type ( ) ) ; handle Http Request ( connection , request , response ) ; handle Http Response ( connection , request , response ) ; }
public long skip ( long n ) throws  IOException { if ( n < _ NUM ) throw new  Illegal Argument Exception ( _ STR ) ; int nn = ( int )  Math . min ( n , max Skip Buffer Size ) ; synchronized ( lock ) { if ( ( skip Buffer == null ) || ( skip Buffer . length < nn ) ) skip Buffer = new char [ nn ] ; long r = n ; while ( r > _ NUM ) { int nc = read ( skip Buffer , _ NUM , ( int )  Math . min ( r , nn ) ) ; if ( nc == - _ NUM ) break ; r -= nc ; } return n - r ; } }
public int wait For ( ) throws  Interrupted Exception { int r = process . wait For ( ) ; if ( input != null ) input . join ( ) ; if ( output != null ) output . join ( ) ; if ( error != null ) error . join ( ) ; process . destroy ( ) ; return r ; }
public static  File locate Replicator Conf Dir ( ) { if ( replicator Conf Dir == null ) {  String replicator Conf =  System . get Property (  CONF_ DIR ) ; if ( replicator Conf == null ) replicator Conf Dir = new  File ( locate Replicator Home Dir ( ) , _ STR ) ; else replicator Conf Dir = new  File ( replicator Conf ) ; if ( ! replicator Conf Dir . is Directory ( ) ) { throw new  Server Runtime Exception ( _ STR + replicator Conf Dir ) ; } } return replicator Conf Dir ; }
public static byte [ ] as Byte Array ( final  List <  Byte > l ) { final byte [ ] a = new byte [ l . size ( ) ] ; for ( int i = _ NUM ; i < a . length ; i ++ ) { a [ i ] = l . get ( i ) ; } return a ; }
public  CNode Menu Builder ( final  JCriterium Tree Node node , final  CCriterium Tree ctree , final  List <  ICriterium Creator > criteria ) { m_criterium Node = node ; final  CCriterium Tree Node clicked Criterium =  CCriterium Functions . find Node ( ctree . get Root ( ) , node . get Criterium ( ) ) ; m_append And = new  JMenu Item ( new  CAppend And Operator Action ( ctree , clicked Criterium ) ) ; m_append Or = new  JMenu Item ( new  CAppend Or Operator Action ( ctree , clicked Criterium ) ) ; m_append Not = new  JMenu Item ( new  CAppend Not Operator Action ( ctree , clicked Criterium ) ) ; m_popup . add ( m_append And ) ; m_popup . add ( m_append Or ) ; m_popup . add ( m_append Not ) ; m_popup . add ( new  JSeparator ( ) ) ; m_insert And = new  JMenu Item ( new  CInsert And Operator Action ( ctree , clicked Criterium ) ) ; m_insert Or = new  JMenu Item ( new  CInsert Or Operator Action ( ctree , clicked Criterium ) ) ; m_insert Not = new  JMenu Item ( new  CInsert Not Operator Action ( ctree , clicked Criterium ) ) ; m_popup . add ( m_insert And ) ; m_popup . add ( m_insert Or ) ; m_popup . add ( m_insert Not ) ; m_popup . add ( new  JSeparator ( ) ) ; m_condition Submenu = new  JMenu ( _ STR ) ; for ( final  ICriterium Creator condition : criteria ) { m_condition Submenu . add ( new  JMenu Item ( new  CAdd Condition Action ( ctree , clicked Criterium , condition ) ) ) ; } m_popup . add ( m_condition Submenu ) ; m_popup . add ( new  JSeparator ( ) ) ; m_remove = new  JMenu Item ( new  CRemove Action ( ctree , clicked Criterium ) ) ; m_popup . add ( m_remove ) ; m_popup . add ( new  JSeparator ( ) ) ; m_remove All = new  JMenu Item ( new  CRemove All Action ( ctree ) ) ; m_popup . add ( m_remove All ) ; }
public void test Store Failure ( ) throws  Exception { delegate . set Should Fail ( _ BOOL ) ; init Store ( _ NUM ) ;  Set <  Integer > exp ; try { exp = run Put Get Remove Multithreaded ( _ NUM , _ NUM ) ;  U . sleep (  FLUSH_ FREQUENCY ) ; info ( _ STR + store . get Write Behind Error Retry Count ( ) + _ STR ) ; delegate . set Should Fail ( _ BOOL ) ;  U . sleep ( _ NUM ) ; } finally { shutdown Store ( ) ; }  Map <  Integer ,  String > map = delegate . get Map ( ) ;  Collection <  Integer > extra = new  Hash Set < > ( map . key Set ( ) ) ; extra . remove All ( exp ) ; assert True ( _ STR + extra , extra . is Empty ( ) ) ;  Collection <  Integer > missing = new  Hash Set < > ( exp ) ; missing . remove All ( map . key Set ( ) ) ; assert True ( _ STR + missing , missing . is Empty ( ) ) ; for (  Integer key : exp ) assert Equals ( _ STR + key , _ STR + key , map . get ( key ) ) ; }
static  String list To Comma Delimited String (  List <  String > list ) {  String Builder result = new  String Builder ( ) ; for (  String str : list ) { if ( result . length ( ) > _ NUM ) { result . append ( _ STR ) ; } result . append ( str ) ; } return result . to String ( ) ; }
private  Snmp Message make Response Message (  Snmp Message req Msg ) {  Snmp Message resp Msg = null ;  Snmp Pdu Packet req Pdu ;  Object user Data = null ; try { req Pdu = (  Snmp Pdu Packet ) pdu Factory . decode Snmp Pdu ( req Msg ) ; if ( req Pdu != null && user Data Factory != null ) user Data = user Data Factory . allocate User Data ( req Pdu ) ; } catch (  Snmp Status Exception x ) { req Pdu = null ;  Snmp Adaptor Server snmp Server = (  Snmp Adaptor Server ) adaptor Server ; snmp Server . inc Snmp In ASNParse Errs ( _ NUM ) ; if ( x . get Status ( ) ==  Snmp Definitions . snmp Wrong Snmp Version ) snmp Server . inc Snmp In Bad Versions ( _ NUM ) ; if (  SNMP_ ADAPTOR_ LOGGER . is Loggable (  Level .  FINEST ) ) {  SNMP_ ADAPTOR_ LOGGER . logp (  Level .  FINEST , dbg Tag , _ STR , _ STR , x ) ; } }  Snmp Pdu Packet resp Pdu = null ; if ( req Pdu != null ) { resp Pdu = make Response Pdu ( req Pdu , user Data ) ; try { if ( user Data Factory != null ) user Data Factory . release User Data ( user Data , resp Pdu ) ; } catch (  Snmp Status Exception x ) { resp Pdu = null ; } } if ( resp Pdu != null ) { try { resp Msg = (  Snmp Message ) pdu Factory . encode Snmp Pdu ( resp Pdu , packet . get Data ( ) . length ) ; } catch (  Snmp Status Exception x ) { resp Msg = null ; if (  SNMP_ ADAPTOR_ LOGGER . is Loggable (  Level .  FINEST ) ) {  SNMP_ ADAPTOR_ LOGGER . logp (  Level .  FINEST , dbg Tag , _ STR , _ STR , x ) ; } } catch (  Snmp Too Big Exception x ) { if (  SNMP_ ADAPTOR_ LOGGER . is Loggable (  Level .  FINEST ) ) {  SNMP_ ADAPTOR_ LOGGER . logp (  Level .  FINEST , dbg Tag , _ STR , _ STR ) ; } try { if ( packet . get Data ( ) . length <= _ NUM ) throw x ; int pos = x . get Var Bind Count ( ) ; if (  SNMP_ ADAPTOR_ LOGGER . is Loggable (  Level .  FINEST ) ) {  SNMP_ ADAPTOR_ LOGGER . logp (  Level .  FINEST , dbg Tag , _ STR , _ STR + pos ) ; } int old ; while ( _ BOOL ) { try { resp Pdu = reduce Response Pdu ( req Pdu , resp Pdu , pos ) ; resp Msg = (  Snmp Message ) pdu Factory . encode Snmp Pdu ( resp Pdu , packet . get Data ( ) . length - _ NUM ) ; break ; } catch (  Snmp Too Big Exception xx ) { if (  SNMP_ ADAPTOR_ LOGGER . is Loggable (  Level .  FINEST ) ) {  SNMP_ ADAPTOR_ LOGGER . logp (  Level .  FINEST , dbg Tag , _ STR , _ STR ) ; } old = pos ; pos = xx . get Var Bind Count ( ) ; if (  SNMP_ ADAPTOR_ LOGGER . is Loggable (  Level .  FINEST ) ) {  SNMP_ ADAPTOR_ LOGGER . logp (  Level .  FINEST , dbg Tag , _ STR , _ STR + pos ) ; } if ( pos == old ) { throw xx ; } } } } catch (  Snmp Status Exception xx ) { resp Msg = null ; if (  SNMP_ ADAPTOR_ LOGGER . is Loggable (  Level .  FINEST ) ) {  SNMP_ ADAPTOR_ LOGGER . logp (  Level .  FINEST , dbg Tag , _ STR , _ STR , xx ) ; } } catch (  Snmp Too Big Exception xx ) { try { resp Pdu = new Too Big Pdu ( req Pdu ) ; resp Msg = (  Snmp Message ) pdu Factory . encode Snmp Pdu ( resp Pdu , packet . get Data ( ) . length ) ; } catch (  Snmp Too Big Exception xxx ) { resp Msg = null ; if (  SNMP_ ADAPTOR_ LOGGER . is Loggable (  Level .  FINEST ) ) {  SNMP_ ADAPTOR_ LOGGER . logp (  Level .  FINEST , dbg Tag , _ STR , _ STR ) ; } adaptor . inc Snmp Silent Drops ( _ NUM ) ; } catch (  Exception xxx ) { if (  SNMP_ ADAPTOR_ LOGGER . is Loggable (  Level .  FINEST ) ) {  SNMP_ ADAPTOR_ LOGGER . logp (  Level .  FINEST , dbg Tag , _ STR , _ STR , xxx ) ; } resp Msg = null ; } } catch (  Exception xx ) { if (  SNMP_ ADAPTOR_ LOGGER . is Loggable (  Level .  FINEST ) ) {  SNMP_ ADAPTOR_ LOGGER . logp (  Level .  FINEST , dbg Tag , _ STR , _ STR , xx ) ; } resp Msg = null ; } } } return resp Msg ; }
public int compare (  File file1 ,  File file2 ) { long size1 = _ NUM ; if ( file1 . is Directory ( ) ) { size1 = sum Directory Contents && file1 . exists ( ) ?  File Utils . size Of Directory ( file1 ) : _ NUM ; } else { size1 = file1 . length ( ) ; } long size2 = _ NUM ; if ( file2 . is Directory ( ) ) { size2 = sum Directory Contents && file2 . exists ( ) ?  File Utils . size Of Directory ( file2 ) : _ NUM ; } else { size2 = file2 . length ( ) ; } long result = size1 - size2 ; if ( result < _ NUM ) { return - _ NUM ; } else if ( result > _ NUM ) { return _ NUM ; } else { return _ NUM ; } }
private static void d_ucummxx ( double [ ] a , double [ ] agg , double [ ] c , int m , int n , double init ,  Builtin builtin , int rl , int ru ) { double [ ] cmxx = ( agg != null ) ? agg : new double [ n ] ; if ( agg == null )  Arrays . fill ( cmxx , init ) ; for ( int i = rl , aix = rl * n ; i < ru ; i ++ , aix += n ) { builtin Agg ( a , cmxx , aix , n , builtin ) ;  System . arraycopy ( cmxx , _ NUM , c , aix , n ) ; } }
public static  List <  Module Spec > expand Spec Wildcards (  List <  File > dirs ,  List <  Module Spec > modules ,  Backend for Backend ) {  List <  Module Spec > result = new  Array List <  Module Spec > ( modules . size ( ) ) ; for (  Module Spec spec : modules ) {  List <  String > names = new  Array List <  String > ( ) ; expand Wildcard ( names , dirs , spec . get Name ( ) , for Backend ) ; for (  String name : names ) { result . add ( new  Module Spec ( name , spec . get Version ( ) ) ) ; } } return result ; }
private void $$$setup UI$$$ ( ) { my Content Pane = new  JPanel ( ) ; my Content Pane . set Layout ( new  Grid Layout Manager ( _ NUM , _ NUM , new  Insets ( _ NUM , _ NUM , _ NUM , _ NUM ) , - _ NUM , - _ NUM ) ) ; server Label = new  JPanel ( ) ; server Label . set Layout ( new  Grid Layout Manager ( _ NUM , _ NUM , new  Insets ( _ NUM , _ NUM , _ NUM , _ NUM ) , - _ NUM , - _ NUM ) ) ; my Content Pane . add ( server Label , new  Grid Constraints ( _ NUM , _ NUM , _ NUM , _ NUM ,  Grid Constraints .  ANCHOR_ CENTER ,  Grid Constraints .  FILL_ BOTH ,  Grid Constraints .  SIZEPOLICY_ CAN_ SHRINK |  Grid Constraints .  SIZEPOLICY_ CAN_ GROW ,  Grid Constraints .  SIZEPOLICY_ CAN_ SHRINK |  Grid Constraints .  SIZEPOLICY_ CAN_ GROW , null , null , null , _ NUM , _ BOOL ) ) ; server Label . set Border (  Border Factory . create Titled Border ( _ STR ) ) ; my Manage Button = new  JButton ( ) ; my Manage Button . set Text ( _ STR ) ; my Manage Button . set Mnemonic ( _ STR ) ; my Manage Button . set Displayed Mnemonic Index ( _ NUM ) ; server Label . add ( my Manage Button , new  Grid Constraints ( _ NUM , _ NUM , _ NUM , _ NUM ,  Grid Constraints .  ANCHOR_ CENTER ,  Grid Constraints .  FILL_ HORIZONTAL ,  Grid Constraints .  SIZEPOLICY_ CAN_ SHRINK |  Grid Constraints .  SIZEPOLICY_ CAN_ GROW ,  Grid Constraints .  SIZEPOLICY_ FIXED , null , null , null , _ NUM , _ BOOL ) ) ; final  Spacer spacer1 = new  Spacer ( ) ; server Label . add ( spacer1 , new  Grid Constraints ( _ NUM , _ NUM , _ NUM , _ NUM ,  Grid Constraints .  ANCHOR_ CENTER ,  Grid Constraints .  FILL_ HORIZONTAL ,  Grid Constraints .  SIZEPOLICY_ WANT_ GROW , _ NUM , null , null , null , _ NUM , _ BOOL ) ) ; my Use Idea Http Proxy Check Box = new  JCheck Box ( ) ; my Use Idea Http Proxy Check Box . set Enabled ( _ BOOL ) ; my Use Idea Http Proxy Check Box . set Selected ( _ BOOL ) ; my Use Idea Http Proxy Check Box . set Text ( _ STR ) ; my Use Idea Http Proxy Check Box . set Mnemonic ( _ STR ) ; my Use Idea Http Proxy Check Box . set Displayed Mnemonic Index ( _ NUM ) ; server Label . add ( my Use Idea Http Proxy Check Box , new  Grid Constraints ( _ NUM , _ NUM , _ NUM , _ NUM ,  Grid Constraints .  ANCHOR_ WEST ,  Grid Constraints .  FILL_ NONE ,  Grid Constraints .  SIZEPOLICY_ CAN_ SHRINK |  Grid Constraints .  SIZEPOLICY_ CAN_ GROW ,  Grid Constraints .  SIZEPOLICY_ FIXED , null , null , null , _ NUM , _ BOOL ) ) ; password Label = new  JPanel ( ) ; password Label . set Layout ( new  Grid Layout Manager ( _ NUM , _ NUM , new  Insets ( _ NUM , _ NUM , _ NUM , _ NUM ) , - _ NUM , - _ NUM ) ) ; my Content Pane . add ( password Label , new  Grid Constraints ( _ NUM , _ NUM , _ NUM , _ NUM ,  Grid Constraints .  ANCHOR_ CENTER ,  Grid Constraints .  FILL_ BOTH ,  Grid Constraints .  SIZEPOLICY_ CAN_ SHRINK |  Grid Constraints .  SIZEPOLICY_ CAN_ GROW ,  Grid Constraints .  SIZEPOLICY_ CAN_ SHRINK |  Grid Constraints .  SIZEPOLICY_ CAN_ GROW , null , null , null , _ NUM , _ BOOL ) ) ; password Label . set Border (  Border Factory . create Titled Border ( _ STR ) ) ; final  Spacer spacer2 = new  Spacer ( ) ; password Label . add ( spacer2 , new  Grid Constraints ( _ NUM , _ NUM , _ NUM , _ NUM ,  Grid Constraints .  ANCHOR_ CENTER ,  Grid Constraints .  FILL_ HORIZONTAL ,  Grid Constraints .  SIZEPOLICY_ WANT_ GROW , _ NUM , null , null , null , _ NUM , _ BOOL ) ) ; my Reset Passwords Button = new  JButton ( ) ; my Reset Passwords Button . set Text ( _ STR ) ; my Reset Passwords Button . set Mnemonic ( _ STR ) ; my Reset Passwords Button . set Displayed Mnemonic Index ( _ NUM ) ; password Label . add ( my Reset Passwords Button , new  Grid Constraints ( _ NUM , _ NUM , _ NUM , _ NUM ,  Grid Constraints .  ANCHOR_ CENTER ,  Grid Constraints .  FILL_ HORIZONTAL ,  Grid Constraints .  SIZEPOLICY_ CAN_ SHRINK |  Grid Constraints .  SIZEPOLICY_ CAN_ GROW ,  Grid Constraints .  SIZEPOLICY_ FIXED , null , null , null , _ NUM , _ BOOL ) ) ; checkin Policy Label = new  JPanel ( ) ; checkin Policy Label . set Layout ( new  Grid Layout Manager ( _ NUM , _ NUM , new  Insets ( _ NUM , _ NUM , _ NUM , _ NUM ) , - _ NUM , - _ NUM ) ) ; my Content Pane . add ( checkin Policy Label , new  Grid Constraints ( _ NUM , _ NUM , _ NUM , _ NUM ,  Grid Constraints .  ANCHOR_ CENTER ,  Grid Constraints .  FILL_ BOTH ,  Grid Constraints .  SIZEPOLICY_ CAN_ SHRINK |  Grid Constraints .  SIZEPOLICY_ CAN_ GROW ,  Grid Constraints .  SIZEPOLICY_ CAN_ SHRINK |  Grid Constraints .  SIZEPOLICY_ CAN_ GROW , null , null , null , _ NUM , _ BOOL ) ) ; checkin Policy Label . set Border (  Border Factory . create Titled Border ( _ STR ) ) ; my Report Not Installed Policies Check Box = new  JCheck Box ( ) ; my Report Not Installed Policies Check Box . set Text ( _ STR ) ; my Report Not Installed Policies Check Box . set Mnemonic ( _ STR ) ; my Report Not Installed Policies Check Box . set Displayed Mnemonic Index ( _ NUM ) ; checkin Policy Label . add ( my Report Not Installed Policies Check Box , new  Grid Constraints ( _ NUM , _ NUM , _ NUM , _ NUM ,  Grid Constraints .  ANCHOR_ WEST ,  Grid Constraints .  FILL_ NONE ,  Grid Constraints .  SIZEPOLICY_ CAN_ SHRINK |  Grid Constraints .  SIZEPOLICY_ CAN_ GROW ,  Grid Constraints .  SIZEPOLICY_ FIXED , null , null , null , _ NUM , _ BOOL ) ) ; note Label = new  JLabel ( ) ; note Label . set Text ( _ STR ) ; checkin Policy Label . add ( note Label , new  Grid Constraints ( _ NUM , _ NUM , _ NUM , _ NUM ,  Grid Constraints .  ANCHOR_ WEST ,  Grid Constraints .  FILL_ NONE ,  Grid Constraints .  SIZEPOLICY_ FIXED ,  Grid Constraints .  SIZEPOLICY_ FIXED , null , null , null , _ NUM , _ BOOL ) ) ; my TFSCheck Box = new  JCheck Box ( ) ; my TFSCheck Box . set Text ( _ STR ) ; my TFSCheck Box . set Mnemonic ( _ STR ) ; my TFSCheck Box . set Displayed Mnemonic Index ( _ NUM ) ; checkin Policy Label . add ( my TFSCheck Box , new  Grid Constraints ( _ NUM , _ NUM , _ NUM , _ NUM ,  Grid Constraints .  ANCHOR_ WEST ,  Grid Constraints .  FILL_ NONE ,  Grid Constraints .  SIZEPOLICY_ CAN_ SHRINK |  Grid Constraints .  SIZEPOLICY_ CAN_ GROW ,  Grid Constraints .  SIZEPOLICY_ FIXED , null , null , null , _ NUM , _ BOOL ) ) ; my Stateful Check Box = new  JCheck Box ( ) ; my Stateful Check Box . set Text ( _ STR ) ; my Stateful Check Box . set Mnemonic ( _ STR ) ; my Stateful Check Box . set Displayed Mnemonic Index ( _ NUM ) ; checkin Policy Label . add ( my Stateful Check Box , new  Grid Constraints ( _ NUM , _ NUM , _ NUM , _ NUM ,  Grid Constraints .  ANCHOR_ WEST ,  Grid Constraints .  FILL_ NONE ,  Grid Constraints .  SIZEPOLICY_ CAN_ SHRINK |  Grid Constraints .  SIZEPOLICY_ CAN_ GROW ,  Grid Constraints .  SIZEPOLICY_ FIXED , null , null , null , _ NUM , _ BOOL ) ) ; path Label = new  JLabel ( ) ; path Label . set Text ( _ STR ) ; my Content Pane . add ( path Label , new  Grid Constraints ( _ NUM , _ NUM , _ NUM , _ NUM ,  Grid Constraints .  ANCHOR_ WEST ,  Grid Constraints .  FILL_ NONE ,  Grid Constraints .  SIZEPOLICY_ FIXED ,  Grid Constraints .  SIZEPOLICY_ FIXED , null , null , null , _ NUM , _ BOOL ) ) ; tf Exe Field = new  Text Field With Browse Button ( ) ; my Content Pane . add ( tf Exe Field , new  Grid Constraints ( _ NUM , _ NUM , _ NUM , _ NUM ,  Grid Constraints .  ANCHOR_ CENTER ,  Grid Constraints .  FILL_ HORIZONTAL ,  Grid Constraints .  SIZEPOLICY_ CAN_ SHRINK |  Grid Constraints .  SIZEPOLICY_ CAN_ GROW ,  Grid Constraints .  SIZEPOLICY_ CAN_ SHRINK |  Grid Constraints .  SIZEPOLICY_ CAN_ GROW , null , null , null , _ NUM , _ BOOL ) ) ; test Exe Button = new  JButton ( ) ; test Exe Button . set Text ( _ STR ) ; my Content Pane . add ( test Exe Button , new  Grid Constraints ( _ NUM , _ NUM , _ NUM , _ NUM ,  Grid Constraints .  ANCHOR_ EAST ,  Grid Constraints .  FILL_ NONE ,  Grid Constraints .  SIZEPOLICY_ FIXED ,  Grid Constraints .  SIZEPOLICY_ CAN_ GROW , null , null , null , _ NUM , _ BOOL ) ) ; final  Spacer spacer3 = new  Spacer ( ) ; my Content Pane . add ( spacer3 , new  Grid Constraints ( _ NUM , _ NUM , _ NUM , _ NUM ,  Grid Constraints .  ANCHOR_ CENTER ,  Grid Constraints .  FILL_ VERTICAL , _ NUM ,  Grid Constraints .  SIZEPOLICY_ WANT_ GROW , null , null , null , _ NUM , _ BOOL ) ) ; }
public static  String construct Config Name (  String config Name ,  String Map scope ) {  String Builder builder = new  String Builder ( ) ; for (  Map .  Entry <  String ,  String > entry : scope . entry Set ( ) ) { builder . append ( entry . get Key ( ) ) ; builder . append ( _ STR ) ; builder . append ( entry . get Value ( ) ) ; builder . append ( _ STR ) ; } builder . append ( config Name ) ; return builder . to String ( ) ; }
public void parse Arguments ( final  String [ ] raw Arguments , final  String properties File , final boolean require Properties File ) throws  Argument Exception {  Properties argument Properties = null ; try ( final  File Input Stream fis = new  File Input Stream ( properties File ) ) { final  Properties p = new  Properties ( ) ; p . load ( fis ) ; argument Properties = p ; } catch ( final  Exception e ) { if ( require Properties File ) { final  Localizable Message message =  ERR_ ARGPARSER_ CANNOT_ READ_ PROPERTIES_ FILE . get ( properties File , get Exception Message ( e ) ) ; throw new  Argument Exception ( message , e ) ; } } parse Arguments ( raw Arguments , argument Properties ) ; }
Attributed String (  Attributed Character Iterator [ ] iterators ) { if ( iterators == null ) { throw new  Null Pointer Exception ( _ STR ) ; } if ( iterators . length == _ NUM ) { text = _ STR ; } else {  String Buffer buffer = new  String Buffer ( ) ; for ( int counter = _ NUM ; counter < iterators . length ; counter ++ ) { append Contents ( buffer , iterators [ counter ] ) ; } text = buffer . to String ( ) ; if ( text . length ( ) > _ NUM ) { int offset = _ NUM ;  Map <  Attribute ,  Object > last = null ; for ( int counter = _ NUM ; counter < iterators . length ; counter ++ ) {  Attributed Character Iterator iterator = iterators [ counter ] ; int start = iterator . get Begin Index ( ) ; int end = iterator . get End Index ( ) ; int index = start ; while ( index < end ) { iterator . set Index ( index ) ;  Map <  Attribute ,  Object > attrs = iterator . get Attributes ( ) ; if ( maps Differ ( last , attrs ) ) { set Attributes ( attrs , index - start + offset ) ; } last = attrs ; index = iterator . get Run Limit ( ) ; } offset += ( end - start ) ; } } } }
@  Override public  Connection Pool Data Source create Connection Pool Data Source (  Properties properties ) throws  SQLException {  Properties properties Copy = new  Properties ( ) ; if ( properties != null ) { properties Copy . put All ( properties ) ; } reject Unsupported Options ( properties Copy ) ; reject Pooling Options ( properties Copy ) ;  Jdbc Data Source data Source = new  Jdbc Data Source ( ) ; setup H2 Data Source ( data Source , properties Copy ) ; return data Source ; }
public static double to Radians ( double x ) { if (  Double . is Infinite ( x ) || x == _ NUM ) { return x ; } final double facta = _ NUM ; final double factb = _ NUM ; double xa = double High Part ( x ) ; double xb = x - xa ; double result = xb * factb + xb * facta + xa * factb + xa * facta ; if ( result == _ NUM ) { result *= x ; } return result ; }
private  Map <  String ,  Big Decimal > init Reasons Map ( final  Map <  String ,  Big Decimal > tax Sum ) { tax Sum . put (  DEMANDRSN_ CODE_ GENERAL_ TAX ,  Big Decimal .  ZERO ) ; tax Sum . put (  DEMANDRSN_ CODE_ LIBRARY_ CESS ,  Big Decimal .  ZERO ) ; tax Sum . put (  DEMANDRSN_ CODE_ EDUCATIONAL_ CESS ,  Big Decimal .  ZERO ) ; tax Sum . put (  DEMANDRSN_ CODE_ UNAUTHORIZED_ PENALTY ,  Big Decimal .  ZERO ) ; tax Sum . put (  DEMANDRSN_ CODE_ PENALTY_ FINES ,  Big Decimal .  ZERO ) ; tax Sum . put (  DEMANDRSN_ CODE_ CHQ_ BOUNCE_ PENALTY ,  Big Decimal .  ZERO ) ; return tax Sum ; }
protected void add (  Instance inst ) { for ( int i = _ NUM ; i < m_ Specifiers . size ( ) ; i ++ ) {  Instance specifier = m_ Specifiers . get ( i ) ; boolean found = _ BOOL ; for ( int m_ Dataset Key Column : m_ Dataset Key Columns ) { if ( inst . value ( m_ Dataset Key Column ) != specifier . value ( m_ Dataset Key Column ) ) { found = _ BOOL ; } } if ( found ) { return ; } } m_ Specifiers . add ( inst ) ; }
public  Shaped Recipe shape ( final  String ... shape ) {  Validate . not Null ( shape , _ STR ) ;  Validate . is True ( shape . length > _ NUM && shape . length < _ NUM , _ STR , shape . length ) ; for (  String row : shape ) {  Validate . not Null ( row , _ STR ) ;  Validate . is True ( row . length ( ) > _ NUM && row . length ( ) < _ NUM , _ STR , row . length ( ) ) ; } this . rows = new  String [ shape . length ] ; for ( int i = _ NUM ; i < shape . length ; i ++ ) { this . rows [ i ] = shape [ i ] ; }  Hash Map <  Character ,  Item Stack > new Ingredients = new  Hash Map <  Character ,  Item Stack > ( ) ; for (  String row : shape ) { for (  Character c : row . to Char Array ( ) ) { new Ingredients . put ( c , ingredients . get ( c ) ) ; } } this . ingredients = new Ingredients ; return this ; }
public void write Tag (  String tag , int value ) { write Tag ( tag ,  Integer . to String ( value ) ) ; }
public  Socket create Socket (  Inet Address address , int port ,  Inet Address my Address , int my Port ) throws  IOException { if ( my Address != null ) {  Socket sock = new  Socket ( ) ; sock . bind ( new  Inet Socket Address ( my Address , _ NUM ) ) ; try { sock . connect ( new  Inet Socket Address ( address , port ) , _ NUM ) ; } catch (  Socket Timeout Exception e ) { throw new  Connect Exception ( _ STR + address + _ STR + port ) ; } return sock ; } else {  Socket sock = new  Socket ( ) ; if ( my Port != _ NUM ) { sock . bind ( new  Inet Socket Address ( port ) ) ; } try { sock . connect ( new  Inet Socket Address ( address , port ) , _ NUM ) ; } catch (  Socket Timeout Exception e ) { throw new  Connect Exception ( _ STR + address + _ STR + port ) ; } return sock ; } }
@  Override public boolean input (  Instance instance ) { if ( get Input Format ( ) == null ) { throw new  Illegal State Exception ( _ STR ) ; } if ( m_ New Batch ) { reset Queue ( ) ; m_ New Batch = _ BOOL ; }  Instances output Format = output Format Peek ( ) ; double [ ] vals = new double [ output Format . num Attributes ( ) ] ; boolean in Range = _ BOOL ; double last Val =  Utils . missing Value ( ) ; int i , j ; for ( i = _ NUM , j = _ NUM ; j < output Format . num Attributes ( ) ; i ++ ) { if ( m_ Delta Cols . is In Range ( i ) && ( i != instance . class Index ( ) ) ) { if ( in Range ) { if (  Utils . is Missing Value ( last Val ) || instance . is Missing ( i ) ) { vals [ j ++ ] =  Utils . missing Value ( ) ; } else { vals [ j ++ ] = instance . value ( i ) - last Val ; } } else { in Range = _ BOOL ; } last Val = instance . value ( i ) ; } else { vals [ j ++ ] = instance . value ( i ) ; } }  Instance inst = null ; if ( instance instanceof  Sparse Instance ) { inst = new  Sparse Instance ( instance . weight ( ) , vals ) ; } else { inst = new  Dense Instance ( instance . weight ( ) , vals ) ; } inst . set Dataset ( get Output Format ( ) ) ; copy Values ( inst , _ BOOL , instance . dataset ( ) , get Output Format ( ) ) ; inst . set Dataset ( get Output Format ( ) ) ; push ( inst ) ; return _ BOOL ; }
public void mouse Moved (  Mouse Event e ) { mouse Support . fire Map Mouse Moved ( e ) ; if ( e . get Source ( ) instanceof  Map Bean ) { if ( draw Distance Objects && the Map != null ) { double lat1 , lat2 , long1 , long2 ; r Point2 = the Map . get Coordinates ( e ) ; the Map . repaint ( ) ; if ( info Delegator != null ) {  Debug . message ( _ STR , _ STR ) ; lat1 = r Point1 . get Y ( ) ; long1 = r Point1 . get X ( ) ; lat2 = r Point2 . get Y ( ) ; long2 = r Point2 . get X ( ) ; distance =  Great Circle . spherical Distance (  Proj Math . deg To Rad ( lat1 ) ,  Proj Math . deg To Rad ( long1 ) ,  Proj Math . deg To Rad ( lat2 ) ,  Proj Math . deg To Rad ( long2 ) ) ; double azimuth = get Spherical Azimuth ( lat1 , long1 , lat2 , long2 ) ; double tmp Distance = total Distance + distance ;  String info Line = create Distance Information Line ( r Point2 , tmp Distance , azimuth ) ;  Info Display Event info = new  Info Display Event ( this , info Line ,  Information Delegator .  COORDINATE_ INFO_ LINE ) ; info Delegator . request Info Line ( info ) ; } } else { fire Mouse Location ( e ) ; } } }
public static void exec And Check Output (  Process Builder builder ,  String expected Out ,  String expected Err ) throws  Exception {  Process process = builder . start ( ) ;  Executor Service executor Service =  Executors . new Fixed Thread Pool ( _ NUM ) ; try {  Future <  String > err Future = executor Service . submit ( stream To String Callable ( process . get Error Stream ( ) ) ) ;  Future <  String > out Future = executor Service . submit ( stream To String Callable ( process . get Input Stream ( ) ) ) ; assert Equals ( expected Out , out Future . get ( _ NUM ,  Time Unit .  SECONDS ) ) ; assert Equals ( expected Err , err Future . get ( _ NUM ,  Time Unit .  SECONDS ) ) ; } finally { executor Service . shutdown ( ) ; process . wait For ( ) ; } }
public static void recover (  File file ) { try {  Zip Input Stream zip = new  Zip Input Stream ( new  File Input Stream ( file ) ) ; zip . get Next Entry ( ) ;  Buffered Reader in = new  Buffered Reader ( new  Input Stream Reader ( zip ) ) ;  Set <  String > c1 = get Collections ( ) ; log . debug ( _ STR + c1 ) ; for (  String table : c1 ) {  Mongo Collection <  Document > c2 = get Collection ( table ) ; try { c2 . drop ( ) ; } catch (  Exception e ) { log . error ( _ STR + table , e ) ; } }  String line = in . read Line ( ) ; while ( line != null ) { _recover ( line ) ; line = in . read Line ( ) ; } zip . close Entry ( ) ; in . close ( ) ; } catch (  Exception e ) { log . error ( e . get Message ( ) , e ) ; } }
public static  Test suite ( ) { return suite (  Test Mode . triples ) ; }
public  Element store (  Object o ) {  Portal Icon p = (  Portal Icon ) o ; if ( ! p . is Active ( ) ) { return null ; }  Element element = new  Element ( _ STR ) ; store Common Attributes ( p , element ) ; element . set Attribute ( _ STR ,  String . value Of ( p . get Scale ( ) ) ) ; element . set Attribute ( _ STR ,  String . value Of ( p . get Degrees ( ) ) ) ;  Portal portal = p . get Portal ( ) ; if ( portal == null ) { log . info ( _ STR ) ; return null ; } element . set Attribute ( _ STR , portal . get Name ( ) ) ; if ( portal . get To Block ( ) != null ) { element . set Attribute ( _ STR , portal . get To Block Name ( ) ) ; } if ( portal . get From Block Name ( ) != null ) { element . set Attribute ( _ STR , portal . get From Block Name ( ) ) ; } element . set Attribute ( _ STR , _ STR + ( p . get Arrow Switch ( ) ? _ STR : _ STR ) ) ; element . set Attribute ( _ STR , _ STR + ( p . get Arrow Hide ( ) ? _ STR : _ STR ) ) ; element . set Attribute ( _ STR , _ STR ) ; return element ; }
public static void write ( float lt , float ln , int offset_x1 , int offset_y1 ,  Image Icon ii ,  Link Properties properties ,  Data Output Stream dos ) throws  IOException ,  Interrupted Exception { int image_width , image_height ;  Image image ; image_width = ii . get Icon Width ( ) ; image_height = ii . get Icon Height ( ) ; image = ii . get Image ( ) ;  Link Raster . write ( lt , ln , offset_x1 , offset_y1 , image , image_width , image_height , properties , dos ) ; }
synchronized void discard Queue ( ) { queue . remove All Elements ( ) ; for (  Enumeration e = running . elements ( ) ; e . has More Elements ( ) ; ) {  Resource Thread t = (  Resource Thread ) e . next Element ( ) ; t . cancel ( ) ; } running . remove All Elements ( ) ; bg Image Comps Selected . remove All Elements ( ) ; bg Image Comps Unselected . remove All Elements ( ) ; bg Image Comps Pressed . remove All Elements ( ) ; thread Count = _ NUM ; css Count = - _ NUM ; started = _ BOOL ; }
@  Override protected void property Change (  Property Change Event evt ) { super . property Change ( evt ) ;  String name = evt . get Property Name ( ) ; if ( name . equals ( _ STR ) ) { update Foreground ( (  Color ) evt . get New Value ( ) ) ; } else if ( name . equals ( _ STR ) ) { update Font ( (  Font ) evt . get New Value ( ) ) ; } else if ( name . equals ( _ STR ) ) {  JComponent comp = get Component ( ) ; update Foreground ( comp . get Foreground ( ) ) ; update Font ( comp . get Font ( ) ) ; } }
public static <  T > int compare (  Comparable <  T > object1 ,  T object2 ) { if ( ( null != object1 ) && ( null != object2 ) ) { return object1 . compare To ( object2 ) ; } else if ( null != object1 ) { return _ NUM ; } else if ( null != object2 ) { return - _ NUM ; } else { return _ NUM ; } }
public static int execute Update (  String sql ,  Object [ ] params , boolean ignore Error ,  String trx Name , int time Out ) { if ( sql == null || sql . length ( ) == _ NUM ) throw new  Illegal Argument Exception ( _ STR + sql ) ; verify Trx ( trx Name , sql ) ; int no = - _ NUM ;  CPrepared Statement cs =  Proxy Factory . new CPrepared Statement (  Result Set .  TYPE_ FORWARD_ ONLY ,  Result Set .  CONCUR_ UPDATABLE , sql , trx Name ) ; try { set Parameters ( cs , params ) ; if ( time Out > _ NUM ) cs . set Query Timeout ( time Out ) ; no = cs . execute Update ( ) ; if ( trx Name == null ) { cs . commit ( ) ; } } catch (  Exception e ) { e = get SQLException ( e ) ; if ( ignore Error ) log . log (  Level .  SEVERE , cs . get Sql ( ) + _ STR + trx Name + _ STR + e . get Message ( ) ) ; else { log . log (  Level .  SEVERE , cs . get Sql ( ) + _ STR + trx Name + _ STR , e ) ; log . save Error ( _ STR , e ) ; } } finally { try { cs . close ( ) ; } catch (  SQLException e2 ) { log . log (  Level .  SEVERE , _ STR ) ; } } return no ; }
static void ordered Show Views ( final  List <  View > views , long animation Duration , int animation Delay ) { if ( views != null ) { for ( int view Index = _ NUM ; view Index < views . size ( ) ; view Index ++ ) { final  View child View = views . get ( view Index ) ; child View . set Visibility (  View .  VISIBLE ) ; final  Scale Animation scale Animation = new  Scale Animation ( _ NUM , child View . get Scale X ( ) , _ NUM , child View . get Scale Y ( ) ,  Animation .  RELATIVE_ TO_ SELF , _ NUM ,  Animation .  RELATIVE_ TO_ SELF , _ NUM ) ; scale Animation . set Interpolator ( new  Decelerate Interpolator ( ) ) ; scale Animation . set Duration ( animation Duration ) ; scale Animation . set Start Offset ( view Index * animation Delay ) ; child View . start Animation ( scale Animation ) ; } } }
public void compile Projects (  List <  File > p Project Roots ,  List <  File > project Locations To Compile ,  Issue Acceptor issue Acceptor ) throws  N4 JSCompile Exception { compile Projects ( p Project Roots , project Locations To Compile ,  Collections . empty List ( ) , issue Acceptor ) ; }
protected final void print_clearance_violation_info (  Object Info Panel p_window , java . util .  Locale p_locale ) {  Collection <  Brd Item Violation > clearance_violations = clearance_violations ( ) ; if ( clearance_violations . is Empty ( ) ) return ;  Gui Resources resources = r_board . new Gui Resources ( _ STR ) ; p_window . append ( _ STR ) ;  Integer violation_count = clearance_violations . size ( ) ;  Collection <  Printable Info > violations = new java . util .  Linked List <  Printable Info > ( ) ; violations . add All ( clearance_violations ) ; p_window . append_objects ( violation_count . to String ( ) , resources . get String ( _ STR ) , violations ) ; if ( violation_count == _ NUM ) { p_window . append ( _ STR + resources . get String ( _ STR ) ) ; } else { p_window . append ( _ STR + resources . get String ( _ STR ) ) ; } }
@  Suppress Warnings ( _ STR ) public  Promise <  Result ,  Progress > reject (  Exception ex ) {  List <  Fail Callback > fail Callbacks ;  List <  Always Callback > always Callbacks ; synchronized ( this ) { validate In Pending State ( ) ; m State =  STATE_ REJECTED ; print State Changed ( _ STR ) ; m Exception = ex ; fail Callbacks = m Callbacks . clone Fail Callbacks ( ) ; always Callbacks = m Callbacks . clone Always Callbacks ( ) ; clear Callbacks ( ) ; } if ( fail Callbacks . size ( ) > _ NUM || always Callbacks . size ( ) > _ NUM ) { trigger All Fails ( fail Callbacks ) ; trigger All Always ( always Callbacks ) ; } return this ; }
private boolean is Snapshot Session Supported (  Block Snapshot snapshot ) { boolean is Supported = _ BOOL ;  URI system URI = snapshot . get Storage Controller ( ) ;  Storage System system = db Client . query Object (  Storage System . class , system URI ) ; if ( ( system != null ) && ( system . check If Vmax3 ( ) ) ) { s_logger . info ( _ STR , snapshot . get Id ( ) , snapshot . get Label ( ) ) ; is Supported = _ BOOL ; } return is Supported ; }
public void load ( ) throws  IOException {  Properties proxy Config =  Configuration Util . load Configuration Properties (  PROXY_ SETTINGS_ FILENAME , null ) ; props File = new  File ( conf Dir ,  PROXY_ SETTINGS_ FILENAME ) ; props =  Configuration Util . load Configuration Properties ( props File , proxy Config ) ; }
public static  String list Insert At (  String list , int pos ,  String value ,  String delimiter , boolean ignore Empty ) throws  Expression Exception { if ( pos < _ NUM ) throw new  Expression Exception ( _ STR + ( pos ) + _ STR ) ; char [ ] del = delimiter . to Char Array ( ) ; char c ;  String Builder result = new  String Builder ( ) ;  String end = _ STR ; int len ; if ( ignore Empty ) { outer : while ( list . length ( ) > _ NUM ) { c = list . char At ( _ NUM ) ; for ( int i = _ NUM ; i < del . length ; i ++ ) { if ( c == del [ i ] ) { list = list . substring ( _ NUM ) ; result . append ( c ) ; continue outer ; } } break ; } } if ( ignore Empty ) { outer : while ( list . length ( ) > _ NUM ) { c = list . char At ( list . length ( ) - _ NUM ) ; for ( int i = _ NUM ; i < del . length ; i ++ ) { if ( c == del [ i ] ) { len = list . length ( ) ; list = list . substring ( _ NUM , len - _ NUM < _ NUM ? _ NUM : len - _ NUM ) ; end = c + end ; continue outer ; } } break ; } } len = list . length ( ) ; int last = _ NUM ; int count = _ NUM ; outer : for ( int i = _ NUM ; i < len ; i ++ ) { c = list . char At ( i ) ; for ( int y = _ NUM ; y < del . length ; y ++ ) { if ( c == del [ y ] ) { if ( ! ignore Empty || last < i ) { if ( pos == ++ count ) { result . append ( value ) ; result . append ( del [ _ NUM ] ) ; } } result . append ( list . substring ( last , i ) ) ; result . append ( c ) ; last = i + _ NUM ; continue outer ; } } } count ++ ; if ( last <= len ) { if ( pos == count ) { result . append ( value ) ; result . append ( del [ _ NUM ] ) ; } result . append ( list . substring ( last ) ) ; } if ( pos > count ) { throw new  Expression Exception ( _ STR + ( pos ) + _ STR + ( count ) ) ; } return result + end ; }
static void dispose ( long p Data ) {  D3 DRender Queue rq =  D3 DRender Queue . get Instance ( ) ; rq . lock ( ) ; try {  Render Buffer buf = rq . get Buffer ( ) ; rq . ensure Capacity And Alignment ( _ NUM , _ NUM ) ; buf . put Int (  DISPOSE_ SURFACE ) ; buf . put Long ( p Data ) ; rq . flush Now ( ) ; } finally { rq . unlock ( ) ; } }
void render Normal ( ) { gl Enable (  GL_ DEPTH_ TEST ) ; gl Use Program ( this . normal Program ) ; gl Uniform Matrix4fv ( view Matrix Uniform , _ BOOL , view Matrix . get ( matrix Buffer ) ) ; gl Uniform Matrix4fv ( proj Matrix Uniform , _ BOOL , proj Matrix . get ( matrix Buffer ) ) ; gl Uniform Matrix3fv ( normal Matrix Uniform , _ BOOL , normal Matrix . get ( matrix Buffer ) ) ; gl Bind Framebuffer EXT (  GL_ FRAMEBUFFER_ EXT , fbo ) ; gl Clear (  GL_ COLOR_ BUFFER_ BIT |  GL_ DEPTH_ BUFFER_ BIT ) ; gl Bind Buffer (  GL_ ARRAY_ BUFFER , this . cube Vbo ) ; gl Enable Vertex Attrib Array ( _ NUM ) ; gl Vertex Attrib Pointer ( _ NUM , _ NUM ,  GL_ FLOAT , _ BOOL , _ NUM , _ NUM ) ; gl Enable Vertex Attrib Array ( _ NUM ) ; gl Vertex Attrib Pointer ( _ NUM , _ NUM ,  GL_ FLOAT , _ BOOL , _ NUM , this . normals Offset ) ; gl Draw Arrays (  GL_ TRIANGLES , _ NUM , this . num Vertices ) ; gl Disable Vertex Attrib Array ( _ NUM ) ; gl Disable Vertex Attrib Array ( _ NUM ) ; gl Bind Buffer (  GL_ ARRAY_ BUFFER , _ NUM ) ; gl Bind Framebuffer EXT (  GL_ FRAMEBUFFER_ EXT , _ NUM ) ; gl Use Program ( _ NUM ) ; }
private <  T extends  Draft2 Resource >  List <  T > look For Resources (  Draft2 Resource Type type ,  Class <  T > clazz ) {  List <  T > resources = get Requirements ( type , clazz ) ; if ( resources == null || resources . size ( ) == _ NUM ) { resources = get Hints ( type , clazz ) ; } return resources ; }
public int decrement ( int decrement ) { allocator . assert Open ( ) ; final int outcome ; try (  Auto Closeable Lock write = write Lock . open ( ) ) { outcome = buf Ref Cnt . add And Get ( - decrement ) ; if ( outcome == _ NUM ) { l Destruction Time =  System . nano Time ( ) ; listener . release ( ) ; } } return outcome ; }
public void add Tight Source Node (  ASTNode reference ) { f Tight Source Range Nodes . add ( reference ) ;  List <  Structural Property Descriptor > properties = reference . structural Properties For Type ( ) ; for (  Iterator <  Structural Property Descriptor > iterator = properties . iterator ( ) ; iterator . has Next ( ) ; ) {  Structural Property Descriptor descriptor = iterator . next ( ) ; if ( descriptor . is Child Property ( ) ) {  ASTNode child = (  ASTNode ) reference . get Structural Property ( descriptor ) ; if ( child != null && is Extending ( child , reference ) ) { add Tight Source Node ( child ) ; } } else if ( descriptor . is Child List Property ( ) ) {  List < ? extends  ASTNode > children =  ASTNodes . get Child List Property ( reference , (  Child List Property Descriptor ) descriptor ) ; for (  Iterator < ? extends  ASTNode > iterator2 = children . iterator ( ) ; iterator2 . has Next ( ) ; ) {  ASTNode child = iterator2 . next ( ) ; if ( is Extending ( child , reference ) ) { add Tight Source Node ( child ) ; } } } } }
public  Uniform Distribution estimate (  Double Min Max mm ) { return new  Uniform Distribution (  Math . max ( mm . get Min ( ) , -  Double .  MAX_ VALUE ) ,  Math . min ( mm . get Max ( ) ,  Double .  MAX_ VALUE ) ) ; }
public static  String read String (  File file ) throws  IOException {  File Input Stream in = new  File Input Stream ( file ) ; try { return read String ( in ) ; } finally { in . close ( ) ; } }
protected  Decimal Literal (  Big Decimal value ,  IRI datatype ) { super ( value . to Plain String ( ) , datatype ) ; this . value = value ; }
private void add Separator (  JComponent container ,  Grid Bag Constraints c ) { c . gridy = _ NUM ; c . gridx ++ ; c . gridheight =  Grid Bag Constraints .  REMAINDER ;  JComponent separator = new  JSeparator (  Swing Constants .  VERTICAL ) ;  Insets tmp Insets = c . insets ; c . insets = new  Insets (  SEPARATOR_ MARGIN , _ NUM ,  SEPARATOR_ MARGIN , _ NUM ) ; container . add ( separator , c ) ; c . gridheight = _ NUM ; c . insets = tmp Insets ; }
public boolean equals (  Object object ) { if ( ! ( object instanceof  Database Field ) ) { return _ BOOL ; } return equals ( (  Database Field ) object ) ; }
public boolean save As Geo JSON (  File file ) { try {  File Writer fw = new  File Writer ( file ) ;  Buffered Writer writer = new  Buffered Writer ( fw , _ NUM ) ; boolean result = save As Geo JSON ( writer ) ; writer . close ( ) ; return result ; } catch (  IOException e ) { e . print Stack Trace ( ) ; return _ BOOL ; } }
public void remove Written ( byte [ ] value ) { write Set Lock . lock ( ) ;  Set <  Timestamp Value Pair > temp = (  Hash Set <  Timestamp Value Pair > ) write Set . clone ( ) ; for (  Timestamp Value Pair rv : temp ) { if (  Arrays . equals ( rv . get Value ( ) , value ) ) write Set . remove ( rv ) ; } write Set Lock . unlock ( ) ; }
@  Override public void load (  Entity unit , boolean check False ) throws  Illegal Argument Exception { if ( ! can Load ( unit ) ) { throw new  Illegal Argument Exception ( _ STR + unit . get Short Name ( ) + _ STR ) ; } if ( unit instanceof  Fighter Squadron ) { fighters . add All ( ( (  Fighter Squadron ) unit ) . fighters ) ; } else { fighters . add Element ( unit . get Id ( ) ) ; } if ( game . get Phase ( ) !=  Phase .  PHASE_ LOUNGE ) { compute Squadron Bomb Loadout ( ) ; } else { update Weapon Groups ( ) ; load All Weapons ( ) ; } update Skills ( ) ; }
public void finish ( ) throws  IOException { if ( ! def . finished ( ) ) { def . finish ( ) ; while ( ! def . finished ( ) ) { int len = def . deflate ( buf , _ NUM , buf . length ) ; if ( def . finished ( ) && len <= buf . length -  TRAILER_ SIZE ) { write Trailer ( buf , len ) ; len = len +  TRAILER_ SIZE ; total Length +=  TRAILER_ SIZE ; out . write ( buf , _ NUM , len ) ; return ; } if ( len > _ NUM ) { out . write ( buf , _ NUM , len ) ; } } byte [ ] trailer = new byte [  TRAILER_ SIZE ] ; write Trailer ( trailer , _ NUM ) ; out . write ( trailer ) ; total Length +=  TRAILER_ SIZE ; } }
public boolean free (  T obj ) { int top = _top . get ( ) ; if ( top < _free Stack . length ( ) ) { boolean is Free = _free Stack . compare And Set ( top , null , obj ) ; _top . compare And Set ( top , top + _ NUM ) ; return is Free ; } else return _ BOOL ; }
private <  T >  Binding Amp <  T > find Binding (  Key <  T > key ) {  Binding Set <  T > set = (  Binding Set ) _binding Set Map . get ( key . raw Class ( ) ) ; if ( set != null ) {  Binding Amp <  T > binding = set . find ( key ) ; if ( binding != null ) { return binding ; } } return null ; }
private void start Replication Service (  Tungsten Properties repl Props ) throws  Replicator Exception {  String service Name = repl Props . get String (  Replicator Conf .  SERVICE_ NAME ) ;  String service Type = repl Props . get String (  Replicator Conf .  SERVICE_ TYPE ) ; boolean is Detached = repl Props . get Boolean (  Replicator Conf .  DETACHED ) ;  Open Replicator Manager MBean orm = null ; try { if ( is Detached ) { throw new  Replicator Exception ( _ STR ) ; } else { orm = create Internal Service ( service Name ) ; } replicators . put ( service Name , orm ) ; orm . start ( repl Props . get Boolean (  Replicator Conf .  FORCE_ OFFLINE ) ) ; int listen Port = orm . get Master Listen Port ( ) ; if ( listen Port > master Listen Port Max ) master Listen Port Max = listen Port ; logger . info (  String . format ( _ STR , ( is Detached ? _ STR : _ STR ) , service Type , service Name ) ) ; } catch (  Exception e ) { logger . error (  String . format ( _ STR , service Name ) , e ) ; } }
public void test Valid After Acquire ( ) throws  IOException {  Path temp Path = create Temp Dir ( ) ;  Directory dir = get Directory ( temp Path ) ;  Lock l = dir . obtain Lock ( _ STR ) ; l . ensure Valid ( ) ; l . close ( ) ; dir . close ( ) ; }
void add Policy To Resource Tree (  Policy policy ) throws  Policy Exception ,  SSOException {  Set rule Names = policy . get Rule Names ( ) ;  Iterator i = rule Names . iterator ( ) ;  String rule Name = null ;  Rule rule = null ; while ( i . has Next ( ) ) { rule Name = (  String ) i . next ( ) ; rule = policy . get Rule ( rule Name ) ; add Rule To Resource Tree ( policy . get Name ( ) , rule ) ; }  Referrals referrals = policy . get Referrals ( ) ; if ( referrals != null ) {  Set referral Names = referrals . get Referral Names ( ) ; if ( ( referral Names != null ) && ( ! referral Names . is Empty ( ) ) ) {  Iterator referral Iter = referral Names . iterator ( ) ; while ( referral Iter . has Next ( ) ) {  String referral Name = (  String ) referral Iter . next ( ) ;  Referral referral = referrals . get Referral ( referral Name ) ; if ( referral instanceof  Org Referral ) {  Set values = referral . get Values ( ) ; if ( ( values != null ) && ( ! values . is Empty ( ) ) ) {  Iterator value Iter = values . iterator ( ) ; while ( value Iter . has Next ( ) ) {  String value = (  String ) value Iter . next ( ) ;  Policy Manager pm = new  Policy Manager ( token , value ) ;  Resource Manager rm = pm . get Resource Manager ( ) ;  Set rule Names1 = policy . get Rule Names ( ) ;  Iterator rule Iter = rule Names1 . iterator ( ) ; while ( rule Iter . has Next ( ) ) {  String rule Name1 = (  String ) rule Iter . next ( ) ;  Rule rule1 = policy . get Rule ( rule Name1 ) ;  String resource Name = rule1 . get Resource Name ( ) ; if ( resource Name != null ) {  String service Type Name = rule1 . get Service Type Name ( ) ;  Set resource Names = new  Hash Set ( ) ; resource Names . add ( resource Name ) ; rm . add Resource Prefixes ( service Type Name , resource Names ) ; } } } } } } } } }
static int [ ] sort Unique ( int [ ] list ) {  Arrays . sort ( list ) ; int count = _ NUM ; for ( int i = _ NUM ; i < list . length ; i ++ ) { if ( list [ i ] != list [ i - _ NUM ] ) { count ++ ; } } int [ ] ret = new int [ count ] ; count = _ NUM ; ret [ _ NUM ] = list [ _ NUM ] ; for ( int i = _ NUM ; i < list . length ; i ++ ) { if ( list [ i ] != list [ i - _ NUM ] ) { ret [ count ++ ] = list [ i ] ; } } return ret ; }
public static void put Short LE ( long addr , short val ) { if (  UNALIGNED )  UNSAFE . put Short ( addr ,  Short . reverse Bytes ( val ) ) ; else put Short By Byte ( addr , val , _ BOOL ) ; }
public static byte [ ] hash ( byte [ ] input , int offset , int length ) {  Message Digest digest = new Digest ( ) ; digest . update ( input , offset , length ) ; return digest . digest ( ) ; }
public static  X509 Certificate read X509 Certificate (  URL url ) throws  IOException ,  Certificate Exception {  URLConnection connection = url . open Connection ( ) ;  Input Stream is = connection . get Input Stream ( ) ; try {  Certificate Factory servercf =  Certificate Factory . get Instance ( _ STR ) ; return (  X509 Certificate ) servercf . generate Certificate ( is ) ; } finally { is . close ( ) ; } }
private char [ ] apply Float Padding ( char [ ] ca4 , boolean no Digits ) { char [ ] ca5 = ca4 ; if ( field Width Set ) { int i , j , n Blanks ; if ( left Justify ) { n Blanks = field Width - ca4 . length ; if ( n Blanks > _ NUM ) { ca5 = new char [ ca4 . length + n Blanks ] ; for ( i = _ NUM ; i < ca4 . length ; i ++ ) ca5 [ i ] = ca4 [ i ] ; for ( j = _ NUM ; j < n Blanks ; j ++ , i ++ ) ca5 [ i ] = _ STR ; } } else if ( ! leading Zeros || no Digits ) { n Blanks = field Width - ca4 . length ; if ( n Blanks > _ NUM ) { ca5 = new char [ ca4 . length + n Blanks ] ; for ( i = _ NUM ; i < n Blanks ; i ++ ) ca5 [ i ] = _ STR ; for ( j = _ NUM ; j < ca4 . length ; i ++ , j ++ ) ca5 [ i ] = ca4 [ j ] ; } } else if ( leading Zeros ) { n Blanks = field Width - ca4 . length ; if ( n Blanks > _ NUM ) { ca5 = new char [ ca4 . length + n Blanks ] ; i = _ NUM ; j = _ NUM ; if ( ca4 [ _ NUM ] == _ STR ) { ca5 [ _ NUM ] = _ STR ; i ++ ; j ++ ; } for ( int k = _ NUM ; k < n Blanks ; i ++ , k ++ ) ca5 [ i ] = _ STR ; for ( ; j < ca4 . length ; i ++ , j ++ ) ca5 [ i ] = ca4 [ j ] ; } } } return ca5 ; }
public void make Immutable ( ) { if ( is Mutable ) { if ( conditions != null ) { int length = conditions . size ( ) ; for ( int i = _ NUM ; i < length ; i ++ ) {  Condition condition = (  Condition ) conditions . get ( i ) ; condition . make Immutable ( ) ; } conditions =  Collections . unmodifiable List ( conditions ) ; } if ( audience Restrictions != null ) { int length = audience Restrictions . size ( ) ; for ( int i = _ NUM ; i < length ; i ++ ) {  Audience Restriction ar = (  Audience Restriction ) audience Restrictions . get ( i ) ; ar . make Immutable ( ) ; } audience Restrictions =  Collections . unmodifiable List ( audience Restrictions ) ; } if ( one Time Uses != null ) { int length = one Time Uses . size ( ) ; for ( int i = _ NUM ; i < length ; i ++ ) {  One Time Use one Time Use = (  One Time Use ) one Time Uses . get ( i ) ; one Time Use . make Immutable ( ) ; } one Time Uses =  Collections . unmodifiable List ( one Time Uses ) ; } if ( proxy Restrictions != null ) { int length = proxy Restrictions . size ( ) ; for ( int i = _ NUM ; i < length ; i ++ ) {  Proxy Restriction pr = (  Proxy Restriction ) proxy Restrictions . get ( i ) ; pr . make Immutable ( ) ; } proxy Restrictions =  Collections . unmodifiable List ( proxy Restrictions ) ; } is Mutable = _ BOOL ; } }
public void add Leaf (  String name ,  String path ) {  Named Icon icon =  Named Icon . get Icon By Name ( path ) ; if ( icon == null ) { log . warn ( _ STR + path + _ STR ) ; return ; } int h = icon . get Icon Height ( ) ; for ( int i = _ NUM ; i < _leaves . size ( ) ; i ++ ) {  Catalog Tree Leaf leaf = _leaves . get ( i ) ; if ( h < leaf . get Size ( ) ) { _leaves . add ( i + _ NUM , new  Catalog Tree Leaf ( name , path , h ) ) ; return ; } } _leaves . add ( new  Catalog Tree Leaf ( name , path , h ) ) ; }
public void add Component Listener ( final  Component Update Listener listener ) { component Listeners . add ( listener ) ; }
public static _ Fields find By Thrift Id ( int field Id ) { switch ( field Id ) { case _ NUM : return  SEQUENCE_ ID ; case _ NUM : return  STATUS ; case _ NUM : return  MESSAGE ; default : return null ; } }
private boolean is Empty (  String text ) { return text == null || text . length ( ) == _ NUM ; }
public void test_metric_heartbeat_uint32 ( ) { final  IGanglia Metadata Message decl = new  Ganglia Metadata Message ( _ STR , _ STR , _ BOOL ,  Ganglia Message Type Enum .  UINT32 , _ STR , _ STR ,  Ganglia Slope Enum . unspecified , _ NUM , _ NUM ,  Abstract Metrics . get Map (  IGanglia Attributes .  GROUP_ CORE , _ STR , _ STR ) ) ; assert Encode Decode ( null , decl ) ; final  IGanglia Metric Message expected = new  Ganglia Metric Message (  Ganglia Message Type Enum .  UINT32 , _ STR , _ STR , _ BOOL , _ STR ,  Long . value Of ( _ NUM ) ) ; final byte [ ] actual Data = assert Encode Decode ( decl , expected ) ; final byte [ ] expected Data = new byte [ ] { _ NUM , _ NUM , _ NUM , - _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , - _ NUM } ; if ( !  Arrays . equals ( expected Data , actual Data ) ) { fail ( _ STR +  Arrays . to String ( expected Data ) + _ STR +  Arrays . to String ( actual Data ) ) ; } }
protected boolean is Relevant (  String term ) { return term . length ( ) >= _ NUM && matches ( character Pattern , term ) ; }
private void send Response (  String status ,  String mime ,  Properties header ,  Input Stream data ) { try { if ( status == null ) throw new  Error ( _ STR ) ;  Output Stream out = my Socket . get Output Stream ( ) ;  Print Writer pw = new  Print Writer ( out ) ; pw . print ( _ STR + status + _ STR ) ; if ( mime != null ) pw . print ( _ STR + mime + _ STR ) ; if ( header == null || header . get Property ( _ STR ) == null ) pw . print ( _ STR + gmt Frmt . format ( new  Date ( ) ) + _ STR ) ; if ( header != null ) {  Enumeration < ? > e = header . keys ( ) ; while ( e . has More Elements ( ) ) {  String key = (  String ) e . next Element ( ) ;  String value = header . get Property ( key ) ; pw . print ( key + _ STR + value + _ STR ) ; } } pw . print ( _ STR ) ; pw . flush ( ) ; if ( data != null ) { int pending = data . available ( ) ; byte [ ] buff = new byte [ the Buffer Size ] ; while ( pending > _ NUM ) { int read = data . read ( buff , _ NUM , ( ( pending > the Buffer Size ) ? the Buffer Size : pending ) ) ; if ( read <= _ NUM ) break ; out . write ( buff , _ NUM , read ) ; pending -= read ; } } out . flush ( ) ; out . close ( ) ; if ( data != null ) data . close ( ) ; } catch (  IOException ioe ) { try { my Socket . close ( ) ; } catch (  Exception t ) { } } }
private static boolean is Access Permitted ( ) { try {  ISSecurity Permission isp = new  ISSecurity Permission ( _ STR , _ STR ) ; if ( security Manager != null ) { security Manager . check Permission ( isp ) ; } return _ BOOL ; } catch (  Security Exception e ) {  Debug debug =  Debug . get Instance ( _ STR ) ; debug . error ( _ STR + _ STR , e ) ; } return _ BOOL ; }
protected void wait For Shutdown Signal ( ) throws  Interrupted Exception { if ( mutex Waiting == null ) { mutex Waiting = new  Object ( ) ; } try { synchronized ( mutex Waiting ) { mutex Waiting . wait ( ) ; } } catch (  Interrupted Exception e ) { if ( ! shutdown ) { throw e ; } } }
public void remove Connection (  Connection connection ) { if ( connection == null ) throw new  Illegal Argument Exception ( _ STR ) ; connection . remove Listener ( invoke Listener ) ; synchronized ( connections Lock ) {  Array List <  Connection > temp = new  Array List (  Arrays . as List ( connections ) ) ; temp . remove ( connection ) ; connections = temp . to Array ( new  Connection [ temp . size ( ) ] ) ; } if (  TRACE ) trace ( _ STR , _ STR + connection ) ; }
public void update Edge Bounds ( mx Cell State state ) {  List < mx Point > points = state . get Absolute Points ( ) ; if ( points != null && points . size ( ) > _ NUM ) { mx Point p0 = points . get ( _ NUM ) ; mx Point pe = points . get ( points . size ( ) - _ NUM ) ; if ( p0 == null || pe == null ) { remove State ( state . get Cell ( ) ) ; } else { if ( p0 . get X ( ) != pe . get X ( ) || p0 . get Y ( ) != pe . get Y ( ) ) { double dx = pe . get X ( ) - p0 . get X ( ) ; double dy = pe . get Y ( ) - p0 . get Y ( ) ; state . set Terminal Distance (  Math . sqrt ( dx * dx + dy * dy ) ) ; } else { state . set Terminal Distance ( _ NUM ) ; } double length = _ NUM ; double [ ] segments = new double [ points . size ( ) - _ NUM ] ; mx Point pt = p0 ; if ( pt != null ) { double min X = pt . get X ( ) ; double min Y = pt . get Y ( ) ; double max X = min X ; double max Y = min Y ; for ( int i = _ NUM ; i < points . size ( ) ; i ++ ) { mx Point tmp = points . get ( i ) ; if ( tmp != null ) { double dx = pt . get X ( ) - tmp . get X ( ) ; double dy = pt . get Y ( ) - tmp . get Y ( ) ; double segment =  Math . sqrt ( dx * dx + dy * dy ) ; segments [ i - _ NUM ] = segment ; length += segment ; pt = tmp ; min X =  Math . min ( pt . get X ( ) , min X ) ; min Y =  Math . min ( pt . get Y ( ) , min Y ) ; max X =  Math . max ( pt . get X ( ) , max X ) ; max Y =  Math . max ( pt . get Y ( ) , max Y ) ; } } state . set Length ( length ) ; state . set Segments ( segments ) ; double marker Size = _ NUM ; state . set X ( min X ) ; state . set Y ( min Y ) ; state . set Width (  Math . max ( marker Size , max X - min X ) ) ; state . set Height (  Math . max ( marker Size , max Y - min Y ) ) ; } else { state . set Length ( _ NUM ) ; } } } }
public static int int From Properties (  Properties p ,  String prop Name , int default Value ) { int ret = default Value ;  String int String = p . get Property ( prop Name ) ; if ( int String != null ) { try { ret =  Integer . parse Int ( int String . trim ( ) ) ; } catch (  Number Format Exception e ) { ret = default Value ; } } return ret ; }
@  Safe Varargs public static final <  T >  List <  T > list (  T ... items ) {  Array List <  T > list = new  Array List <  T > ( items . length ) ; for (  T item : items ) { list . add ( item ) ; } return list ; }
private void update State View (  Object state ) {  Platform . run Later ( null ) ; sim Pane Ctrl . wait After Step ( ) ; }
public static  Socket create Socket (  Inet Address address , int port , boolean ssl ) throws  IOException { long start =  System . current Time Millis ( ) ; for ( int i = _ NUM ; ; i ++ ) { try { if ( ssl ) { return  Cipher Factory . create Socket ( address , port ) ; }  Socket socket = new  Socket ( ) ; socket . connect ( new  Inet Socket Address ( address , port ) ,  Sys Properties .  SOCKET_ CONNECT_ TIMEOUT ) ; return socket ; } catch (  IOException e ) { if (  System . current Time Millis ( ) - start >=  Sys Properties .  SOCKET_ CONNECT_ TIMEOUT ) { throw e ; } if ( i >=  Sys Properties .  SOCKET_ CONNECT_ RETRY ) { throw e ; } try { long sleep =  Math . min ( _ NUM , i * i ) ;  Thread . sleep ( sleep ) ; } catch (  Interrupted Exception e2 ) { } } } }
@  Override public void evict All ( ) {  File [ ] files = cache Directory . list Files ( ) ; if ( null != files ) { for (  File file : files ) { if ( file != null ) file . delete ( ) ; } } }
public  Audio Module (  Dialogue System system ) { this . system = system ; }
private void backup Screens (  Backup Data Output data ) throws  IOException {  Content Resolver cr = m Context . get Content Resolver ( ) ;  Cursor cursor = cr . query (  Launcher Settings .  Workspace Screens .  CONTENT_ URI ,  SCREEN_ PROJECTION , null , null , null ) ; try { cursor . move To Position ( - _ NUM ) ; if (  DEBUG )  Log . d (  TAG , _ STR + m Last Backup Restore Time ) ; while ( cursor . move To Next ( ) ) { final long id = cursor . get Long (  ID_ INDEX ) ; final long update Time = cursor . get Long (  ID_ MODIFIED ) ;  Backup Protos .  Key key = get Key (  Backup Protos .  Key .  SCREEN , id ) ; m Keys . add ( key ) ; final  String backup Key = key To Backup Key ( key ) ; if ( ! m Existing Keys . contains ( backup Key ) || update Time >= m Last Backup Restore Time ) { write Row To Backup ( key , pack Screen ( cursor ) , data ) ; } else { if (  VERBOSE )  Log . v (  TAG , _ STR + id ) ; } } } finally { cursor . close ( ) ; } }
@  Override default  Completable Future <  Optional Double > max Double ( final  To Double Function < ? super  T > fn ) { return  Completable Future . supply Async ( null , get Exec ( ) ) ; }
private boolean to Next State (  Lifecycle State new State ) {  Lifecycle State state ; synchronized ( this ) { state = _state ; if ( new State . ordinal ( ) <= state . ordinal ( ) ) { return _ BOOL ; } _state = new State ; _last Change Time =  Current Time . current Time ( ) ; } if ( _log != null && _log . is Loggable ( _low Level ) ) { _log . log ( _low Level , new State + _ STR + _name ) ; } notify Listeners ( state , new State ) ; return _ BOOL ; }
public boolean init ( ) { if (  MODE ==  MODE_ HORIZONTAL ) { center Panel . set Layout ( new  ALayout ( ) ) ; } if (  MODE ==  MODE_ VERTICAL ) { gbc . anchor =  Grid Bag Constraints .  NORTHWEST ; gbc . weightx = _ NUM ; gbc . weighty = _ NUM ; gbc . gridy = m_line ++ ; gbc . gridx = _ NUM ; gbc . gridwidth = _ NUM ; gbc . insets = null Inset ; gbc . fill =  Grid Bag Constraints .  HORIZONTAL ; center Panel . add (  Box . create Vertical Strut ( _ NUM ) , gbc ) ; } log . config ( _ STR ) ;  MClient client =  MClient . get (  Env . get Ctx ( ) ) ;  String  ASPFilter = _ STR ; if ( client . is Use ASP ( ) )  ASPFilter = _ STR + _ STR + _ STR + _ STR + _ STR + client . get AD_ Client_ ID ( ) + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + client . get AD_ Client_ ID ( ) + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + client . get AD_ Client_ ID ( ) + _ STR + _ STR + _ STR + _ STR + _ STR ;  String sql = null ; if (  Env . is Base Language (  Env . get Ctx ( ) , _ STR ) ) sql = _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR +  ASPFilter + _ STR ; else sql = _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR +  Env . get AD_ Language (  Env . get Ctx ( ) ) + _ STR + _ STR +  ASPFilter + _ STR ; int cols = _ NUM ; int col = _ NUM ; int row = _ NUM ; boolean has Fields = _ BOOL ;  Prepared Statement pstmt = null ;  Result Set rs = null ; try { pstmt =  DB . prepare Statement ( sql , null ) ; pstmt . set Int ( _ NUM , m_process Info . get AD_ Process_ ID ( ) ) ; rs = pstmt . execute Query ( ) ; while ( rs . next ( ) ) { has Fields = _ BOOL ; if (  MODE ==  MODE_ HORIZONTAL ) { create Field ( rs , row , cols ) ; cols = cols + col ; if ( cols >= _ NUM ) { cols = _ NUM ; row ++ ; } } if (  MODE ==  MODE_ VERTICAL ) { create Field ( rs ) ; } } } catch (  SQLException e ) { throw new  DBException ( e , sql ) ; } finally {  DB . close ( rs , pstmt ) ; rs = null ; pstmt = null ; } if ( m_m Fields . size ( ) != m_m Fields2 . size ( ) || m_m Fields . size ( ) != m_v Editors . size ( ) || m_m Fields2 . size ( ) != m_v Editors2 . size ( ) ) log . log (  Level .  SEVERE , _ STR ) ; if ( has Fields ) { if (  MODE ==  MODE_ VERTICAL ) { gbc . gridy = m_line ++ ; center Panel . add (  Box . create Vertical Strut ( _ NUM ) , gbc ) ; gbc . gridx = _ NUM ; center Panel . add (  Box . create Horizontal Strut ( _ NUM ) , gbc ) ; } dynamic Display ( ) ; } else dispose ( ) ; return has Fields ; }
@  Override protected  String date To String (  Date Time Data date ) {  String Buffer message = new  String Buffer ( _ NUM ) ; message . append ( _ STR ) ; message . append ( _ STR ) ; append ( message , date . month , _ NUM ) ; message . append ( _ STR ) ; append ( message , date . day , _ NUM ) ; append ( message , ( char ) date . utc , _ NUM ) ; return message . to String ( ) ; }
private  Array List <  Test > generate Test List (  Random random ,  Instance example ) throws  Exception {  Instances format = get Dataset Format ( ) ; if ( format == null ) { throw new  Exception ( _ STR ) ; } int num Tests = get Num Attributes ( ) - get Num Irrelevant ( ) ;  Array List <  Test >  Test List = new  Array List <  Test > ( num Tests ) ; boolean [ ] irrelevant = get Att List_ Irr ( ) ; for ( int i = _ NUM ; i < get Num Attributes ( ) ; i ++ ) { if ( ! irrelevant [ i ] ) {  Test new Test = null ;  Attribute att = example . attribute ( i ) ; if ( att . is Numeric ( ) ) { double new Split = random . next Double ( ) ; boolean new Not = new Split < example . value ( i ) ; new Test = new  Test ( i , new Split , format , new Not ) ; } else { new Test = new  Test ( i , example . value ( i ) , format , _ BOOL ) ; }  Test List . add ( new Test ) ; } } return  Test List ; }
public static double next Random ( double k , double theta ,  Random random ) { final double q1 = _ NUM , q2 = _ NUM , q3 = _ NUM ; final double q4 = _ NUM , q5 = - _ NUM , q6 = _ NUM ; final double q7 = _ NUM , q8 = - _ NUM , q9 = _ NUM ; final double a1 = _ NUM , a2 = - _ NUM , a3 = _ NUM ; final double a4 = - _ NUM , a5 = _ NUM , a6 = - _ NUM ; final double a7 = _ NUM , a8 = - _ NUM , a9 = _ NUM ; final double e1 = _ NUM , e2 = _ NUM , e3 = _ NUM ; final double e4 = _ NUM , e5 = _ NUM , e6 = _ NUM ; final double e7 = _ NUM ; if ( k < _ NUM ) { final double b = _ NUM + _ NUM * k ; while ( _ BOOL ) { final double p = b * random . next Double ( ) ; if ( p <= _ NUM ) { final double gds =  Math . exp (  Math . log ( p ) / k ) ; if (  Math . log ( random . next Double ( ) ) <= - gds ) { return ( gds / theta ) ; } } else { final double gds = -  Math . log ( ( b - p ) / k ) ; if (  Math . log ( random . next Double ( ) ) <= ( ( k - _ NUM ) *  Math . log ( gds ) ) ) { return ( gds / theta ) ; } } } } else { final double ss , s , d ; if ( k != - _ NUM ) { ss = k - _ NUM ; s =  Math . sqrt ( ss ) ; d = _ NUM - _ NUM * s ; } else { ss = _ NUM ; s = _ NUM ; d = _ NUM ; } final double v1 , v12 ; { double tv1 , tv2 , tv12 ; do { tv1 = _ NUM * random . next Double ( ) - _ NUM ; tv2 = _ NUM * random . next Double ( ) - _ NUM ; tv12 = tv1 * tv1 + tv2 * tv2 ; } while ( tv12 > _ NUM ) ; v1 = tv1 ; v12 = tv12 ; } final double b , c , si , q0 ; { final double t = v1 *  Math . sqrt ( - _ NUM *  Math . log ( v12 ) / v12 ) ; final double x = s + _ NUM * t ; final double gds = x * x ; if ( t >= _ NUM ) { return ( gds / theta ) ; } final double un = random . next Double ( ) ; if ( d * un <= t * t * t ) { return ( gds / theta ) ; } if ( k != - _ NUM ) { final double r = _ NUM / k ; q0 = ( ( ( ( ( ( ( ( q9 * r + q8 ) * r + q7 ) * r + q6 ) * r + q5 ) * r + q4 ) * r + q3 ) * r + q2 ) * r + q1 ) * r ; if ( k > _ NUM ) { if ( k > _ NUM ) { b = _ NUM ; si = _ NUM ; c = _ NUM / s ; } else { b = _ NUM + _ NUM * ss ; si = _ NUM / s + _ NUM ; c = _ NUM / s + _ NUM ; } } else { b = _ NUM + s - _ NUM * ss ; si = _ NUM ; c = _ NUM / s - _ NUM + _ NUM * s ; } } else { b = _ NUM ; c = _ NUM ; si = _ NUM ; q0 = _ NUM ; } if ( x > _ NUM ) { final double v = t / ( s + s ) ; final double q ; if (  Math . abs ( v ) > _ NUM ) { q = q0 - s * t + _ NUM * t * t + ( ss + ss ) *  Math . log ( _ NUM + v ) ; } else { q = q0 + _ NUM * t * t * ( ( ( ( ( ( ( ( a9 * v + a8 ) * v + a7 ) * v + a6 ) * v + a5 ) * v + a4 ) * v + a3 ) * v + a2 ) * v + a1 ) * v ; } if (  Math . log ( _ NUM - un ) <= q ) { return ( gds / theta ) ; } } } while ( _ BOOL ) { double e , u , sign_u , t ; do { e = -  Math . log ( random . next Double ( ) ) ; u = random . next Double ( ) ; u = u + u - _ NUM ; sign_u = ( u > _ NUM ) ? _ NUM : - _ NUM ; t = b + ( e * si ) * sign_u ; } while ( t <= - _ NUM ) ; final double v = t / ( s + s ) ; final double q ; if (  Math . abs ( v ) > _ NUM ) { q = q0 - s * t + _ NUM * t * t + ( ss + ss ) *  Math . log ( _ NUM + v ) ; } else { q = q0 + _ NUM * t * t * ( ( ( ( ( ( ( ( a9 * v + a8 ) * v + a7 ) * v + a6 ) * v + a5 ) * v + a4 ) * v + a3 ) * v + a2 ) * v + a1 ) * v ; } if ( q <= _ NUM ) { continue ; } final double w ; if ( q > _ NUM ) { w =  Math . exp ( q ) - _ NUM ; } else { w = ( ( ( ( ( ( e7 * q + e6 ) * q + e5 ) * q + e4 ) * q + e3 ) * q + e2 ) * q + e1 ) * q ; } if ( c * u * sign_u <= w *  Math . exp ( e - _ NUM * t * t ) ) { final double x = s + _ NUM * t ; return ( x * x / theta ) ; } } } }
public static void swap (  List list , int i , int j ) {  Object tmp = list . get ( i ) ; list . set ( i , list . get ( j ) ) ; list . set ( j , tmp ) ; }
public static  Http Response create Post (  String server ,  String username ,  String password ,  String token , boolean learning Opt Out ,  String content ,  String voice ,  String codec ) throws  Exception {  String url = server ;  Http Client http Client = new  Default Http Client ( ) ;  List <  Basic Name Value Pair > params = new  Linked List <  Basic Name Value Pair > ( ) ; params . add ( new  Basic Name Value Pair ( _ STR , content ) ) ; params . add ( new  Basic Name Value Pair ( _ STR , voice ) ) ; params . add ( new  Basic Name Value Pair ( _ STR , codec ) ) ;  Http Get http Get = new  Http Get ( url + _ STR +  URLEncoded Utils . format ( params , _ STR ) ) ; if ( token != null ) {  Log . d (  TAG , _ STR ) ; http Get . set Header ( _ STR , token ) ; } else {  Log . d (  TAG , _ STR ) ; http Get . set Header (  Basic Scheme . authenticate ( new  Username Password Credentials ( username , password ) , _ STR , _ BOOL ) ) ; } if ( learning Opt Out ) {  Log . d (  TAG , _ STR ) ; http Get . set Header ( _ STR , _ STR ) ; }  Http Response executed = http Client . execute ( http Get ) ; return executed ; }
public static <  T ,  U extends  Auto Closeable >  T with Auto Closeable (  U self , @  Closure Params ( value =  First Param . class )  Closure <  T > action ) throws  Exception { try {  T result = action . call ( self ) ;  Auto Closeable temp = self ; self = null ; temp . close ( ) ; return result ; } finally { close With Warning ( self ) ; } }
private int find Marker Segment Position (  Class cls , boolean first ) { if ( first ) {  List Iterator iter = marker Sequence . list Iterator ( ) ; for ( int i = _ NUM ; iter . has Next ( ) ; i ++ ) {  Marker Segment seg = (  Marker Segment ) iter . next ( ) ; if ( cls . is Instance ( seg ) ) { return i ; } } } else {  List Iterator iter = marker Sequence . list Iterator ( marker Sequence . size ( ) ) ; for ( int i = marker Sequence . size ( ) - _ NUM ; iter . has Previous ( ) ; i -- ) {  Marker Segment seg = (  Marker Segment ) iter . previous ( ) ; if ( cls . is Instance ( seg ) ) { return i ; } } } return - _ NUM ; }
public synchronized void update Load (  Server Location location ,  Server Load new Load ,  List client Ids ) {  String [ ] groups = (  String [ ] ) server Group Map . get ( location ) ; if ( groups == null ) { return ; } if ( client Ids != null ) { for (  Iterator itr = client Ids . iterator ( ) ; itr . has Next ( ) ; ) { cancel Client Estimate ( (  Client Proxy Membership ID ) itr . next ( ) , location ) ; } } update Map ( connection Load Map , location , new Load . get Connection Load ( ) , new Load . get Load Per Connection ( ) ) ; update Map ( queue Load Map , location , new Load . get Subscription Connection Load ( ) , new Load . get Load Per Subscription Connection ( ) ) ; }
public void add Leaf (  String name ,  String path ) {  Named Icon icon =  Named Icon . get Icon By Name ( path ) ; if ( icon == null ) { log . warn ( _ STR + path + _ STR ) ; return ; } int h = icon . get Icon Height ( ) ; for ( int i = _ NUM ; i < _leaves . size ( ) ; i ++ ) {  Catalog Tree Leaf leaf = _leaves . get ( i ) ; if ( h < leaf . get Size ( ) ) { _leaves . add ( i + _ NUM , new  Catalog Tree Leaf ( name , path , h ) ) ; return ; } } _leaves . add ( new  Catalog Tree Leaf ( name , path , h ) ) ; }
public static long plus ( long tstamp , long microseconds ) { long microsmask = ( long )  UMASK ; long newmicros = tstamp & microsmask ; if ( ( newmicros + microseconds ) <=  MAX_ MICROS ) { tstamp += microseconds ; } else { int [ ] pieces = new int [  NUMIDX ] ;  Component Time . unpack Bits ( tstamp , pieces ) ; int year = pieces [  YIDX ] ; int month = pieces [  MIDX ] ; int day = pieces [  DIDX ] ; int hour = pieces [  HIDX ] ; int minute = pieces [  IIDX ] ; int second = pieces [  SIDX ] ; newmicros += microseconds ; int overseconds = ( int ) ( newmicros / _ NUM ) ; newmicros = ( newmicros % _ NUM ) ;  Gregorian Calendar cal = new  Gregorian Calendar ( year , month - _ NUM , day , hour , minute , second ) ; cal . add (  Calendar .  SECOND , overseconds ) ; second = cal . get (  Calendar .  SECOND ) ; minute = cal . get (  Calendar .  MINUTE ) ; hour = cal . get (  Calendar .  HOUR_ OF_ DAY ) ; day = cal . get (  Calendar .  DAY_ OF_ MONTH ) ; month = cal . get (  Calendar .  MONTH ) + _ NUM ; year = cal . get (  Calendar .  YEAR ) ; tstamp = newmicros ; tstamp |= ( ( long ) year ) <<  YPOS ; tstamp |= ( ( long ) month ) <<  MPOS ; tstamp |= ( ( long ) day ) <<  DPOS ; tstamp |= ( ( long ) hour ) <<  HPOS ; tstamp |= ( ( long ) minute ) <<  IPOS ; tstamp |= ( ( long ) second ) <<  SPOS ; } return ( tstamp ) ; }
public  Http Request content Length ( final  String content Length ) { return content Length (  Integer . parse Int ( content Length ) ) ; }
public  VNXe Command Result modify Lun Sync (  Lun Modify Param param ,  String resource Id ) {  String Builder url Bld = new  String Builder (  URL_ RESOURCE ) ; url Bld . append ( resource Id ) ; url Bld . append (  URL_ LUN_ MODIFY_ ACTION ) ; _url = url Bld . to String ( ) ;  VNXe Command Result result = post Request Sync ( param ) ; result . set Success ( _ BOOL ) ; return result ; }
public  String replace (  Char Sequence target ,  Char Sequence replacement ) { if ( target == null ) { throw new  Null Pointer Exception ( _ STR ) ; } if ( replacement == null ) { throw new  Null Pointer Exception ( _ STR ) ; }  String target String = target . to String ( ) ; int match Start = index Of ( target String , _ NUM ) ; if ( match Start == - _ NUM ) { return this ; }  String replacement String = replacement . to String ( ) ; int target Length = target String . length ( ) ; if ( target Length == _ NUM ) { int result Length = count + ( count + _ NUM ) * replacement String . length ( ) ;  String Builder result = new  String Builder ( result Length ) ; result . append ( replacement String ) ; int end = offset + count ; for ( int i = offset ; i != end ; ++ i ) { result . append ( value [ i ] ) ; result . append ( replacement String ) ; } return result . to String ( ) ; }  String Builder result = new  String Builder ( count ) ; int search Start = _ NUM ; do { result . append ( value , offset + search Start , match Start - search Start ) ; result . append ( replacement String ) ; search Start = match Start + target Length ; } while ( ( match Start = index Of ( target String , search Start ) ) != - _ NUM ) ; result . append ( value , offset + search Start , count - search Start ) ; return result . to String ( ) ; }
private  Set <  String > array To Set (  Object [ ] arr ) {  Hash Set <  String > r = new  Hash Set < > ( ) ; if ( null == arr ) return r ; for (  Object o : arr ) { if ( null != o ) r . add ( o . to String ( ) ) ; } return r ; }
public void callback ( final long status_id , final  String twitlonger_message_id ) throws  Exception { final  Array List <  Name Value Pair > args = new  Array List < > ( _ NUM ) ; args . add ( new  Basic Name Value Pair ( _ STR , app_name ) ) ; args . add ( new  Basic Name Value Pair ( _ STR , api_key ) ) ; args . add ( new  Basic Name Value Pair ( _ STR , twitlonger_message_id ) ) ; args . add ( new  Basic Name Value Pair ( _ STR ,  Long . to String ( status_id ) ) ) ; try { final  Http Client httpclient = new  Default Http Client ( ) ; final  Http Post httppost = new  Http Post (  TWITLONGER_ API_ CALLBACK ) ; httppost . set Entity ( new  Url Encoded Form Entity ( args , _ STR ) ) ; final  Http Response response = httpclient . execute ( httppost ) ; final  String response Str =  Entity Utils . to String ( response . get Entity ( ) , _ STR ) ; final  Xml Pull Parser Factory factory =  Xml Pull Parser Factory . new Instance ( ) ; factory . set Namespace Aware ( _ BOOL ) ; final  Xml Pull Parser parser = factory . new Pull Parser ( ) ; parser . set Input ( new  String Reader ( response Str ) ) ; int event Type = parser . get Event Type ( ) ;  String tag Name ; boolean looking For End Of Unknown Tag = _ BOOL ;  String unknown Tag Name = null ; do { if ( event Type ==  Xml Pull Parser .  START_ TAG ) { tag Name = parser . get Name ( ) ; if (  TAG_ TWITLONGER . equals ( tag Name ) ) { event Type = parser . next ( ) ; break ; } throw new  Runtime Exception ( _ STR +  TAG_ TWITLONGER + _ STR + tag Name ) ; } event Type = parser . next ( ) ; } while ( event Type !=  Xml Pull Parser .  END_ DOCUMENT ) ; boolean end Of Document = _ BOOL ; while ( ! end Of Document ) { switch ( event Type ) { case  Xml Pull Parser .  START_ TAG : { if ( looking For End Of Unknown Tag ) { break ; } tag Name = parser . get Name ( ) ; if (  TAG_ POST . equals Ignore Case ( tag Name ) ) { } else if (  TAG_ ERROR . equals Ignore Case ( tag Name ) ) throw new  Twit Longer Exception ( _ STR + parser . next Text ( ) ) ; else { looking For End Of Unknown Tag = _ BOOL ; unknown Tag Name = tag Name ; } break ; } case  Xml Pull Parser .  END_ TAG : { tag Name = parser . get Name ( ) ; if ( looking For End Of Unknown Tag && tag Name . equals ( unknown Tag Name ) ) { looking For End Of Unknown Tag = _ BOOL ; unknown Tag Name = null ; } break ; } case  Xml Pull Parser .  END_ DOCUMENT : { end Of Document = _ BOOL ; } } event Type = parser . next ( ) ; } } catch ( final  IOException e ) { throw new  Twit Longer Exception ( e ) ; } catch ( final  Xml Pull Parser Exception e ) { throw new  Twit Longer Exception ( e ) ; } }
public void remove Like (  Song song ) { remove Liking Impl ( song ,  PREF_ LIKED_ ENTRIES ) ; }
@  Not Null public  Psi Query siblings ( @  Not Null final  Class < ? extends  Psi Named Element > clazz , @  Not Null final  String name ) { final  List <  Psi Element > result = new  Array List <  Psi Element > ( ) ; for ( final  Psi Element element : my Psi Elements ) { final  Psi Element parent = element . get Parent ( ) ; for ( final  Psi Named Element named Sibling :  Psi Tree Util . find Children Of Type ( parent , clazz ) ) { if ( ( ! named Sibling . equals ( element ) ) && ( name . equals ( named Sibling . get Name ( ) ) ) ) { result . add ( named Sibling ) ; } } } return new  Psi Query ( result . to Array ( new  Psi Element [ result . size ( ) ] ) ) ; }
@  Override public int compare To (  Value o ) { return hash Code ( ) - o . hash Code ( ) ; }
protected  String limit Text (  String text ) { int start Index = _ NUM ; int search Start = _ NUM ; if ( start Pattern != null ) {  Matcher start Matcher = start Pattern . matcher ( text ) ; if ( start Matcher . find ( ) ) { start Index = start Matcher . start ( ) ; search Start = start Matcher . end ( ) ; } else if ( ! start Match Optional ) { return null ; } } int end Index = text . length ( ) ; if ( end Pattern != null ) {  Matcher end Matcher = end Pattern . matcher ( text ) ; if ( end Matcher . find ( search Start ) ) { end Index = end Matcher . start ( ) ; } else if ( ! end Match Optional ) { return null ; } } if ( ( start Index > _ NUM ) || ( end Index < text . length ( ) ) ) { return  String Utils . substring ( text , start Index , end Index ) ; } else { return text ; } }
private void replace Impl ( int start Index , int end Index , int remove Len ,  String insert Str , int insert Len ) { int new Size = size - remove Len + insert Len ; if ( insert Len != remove Len ) { ensure Capacity ( new Size ) ;  System . arraycopy ( buffer , end Index , buffer , start Index + insert Len , size - end Index ) ; size = new Size ; } if ( insert Len > _ NUM ) { insert Str . get Chars ( _ NUM , insert Len , buffer , start Index ) ; } }
public static void remove Permission Recursive (  Path path ,  Posix File Permission permission ) throws  IOException { change Permissions Recursive ( path ,  Permission Change .  REMOVE ,  Collections . singleton ( permission ) ) ; }
public void  Wait Until All Viewers Are Upto Date ( ) { while ( ! is All Viewers Uptodate ( ) ) { try {  Thread . sleep ( _ NUM ) ; } catch (  Exception e ) { } } }
public void test Case20 ( ) { byte a Bytes [ ] = { _ NUM } ; byte b Bytes [ ] = { _ NUM } ; byte r Bytes [ ] = { _ NUM } ; int a Sign = _ NUM ; int b Sign = _ NUM ;  Big Integer a Number = new  Big Integer ( a Sign , a Bytes ) ;  Big Integer b Number = new  Big Integer ( b Sign , b Bytes ) ;  Big Integer result = a Number . subtract ( b Number ) ; byte res Bytes [ ] = new byte [ r Bytes . length ] ; res Bytes = result . to Byte Array ( ) ; for ( int i = _ NUM ; i < res Bytes . length ; i ++ ) { assert True ( res Bytes [ i ] == r Bytes [ i ] ) ; } assert Equals ( _ NUM , result . signum ( ) ) ; }
public  XPattern Tokenizer (  Attribute Factory factory ,  Pattern pattern , int group ) { super ( factory ) ; this . group = group ; matcher = pattern . matcher ( _ STR ) ; if ( group >= _ NUM && group > matcher . group Count ( ) ) { throw new  Illegal Argument Exception ( _ STR + matcher . group Count ( ) + _ STR ) ; } }
public static  IP parse From String (  String ip ) {  String regex = _ STR ;  Pattern pattern =  Pattern . compile ( regex ) ;  Matcher m = pattern . matcher ( ip ) ; check Argument ( m . find ( ) , _ STR , regex ) ; int a =  Integer . parse Int ( m . group ( _ NUM ) ) ; int b =  Integer . parse Int ( m . group ( _ NUM ) ) ; int c =  Integer . parse Int ( m . group ( _ NUM ) ) ; int d =  Integer . parse Int ( m . group ( _ NUM ) ) ; return new  IP ( a , b , c , d ) ; }
public void randomize Fan In ( ) { for (  Synapse synapse : get Fan In ( ) ) { synapse . randomize ( ) ; } }
@  Nullable public static  String find File In Provided Path (  String provided Path ,  String ... file Names ) { if (  String Util . is Empty ( provided Path ) ) { return _ STR ; }  File provided File = new  File ( provided Path ) ; if ( provided File . exists ( ) ) {  String name = provided File . get Name ( ) ; for (  String file Name : file Names ) { if ( name . equals ( file Name ) ) { return to System Dependent Name ( provided File . get Path ( ) ) ; } } } if ( provided File . is Directory ( ) ) { for (  String file Name : file Names ) {  File file = new  File ( provided File , file Name ) ; if ( file Name . equals ( file . get Name ( ) ) && file . exists ( ) ) { return to System Dependent Name ( file . get Path ( ) ) ; } } } provided File = provided File . get Parent File ( ) ; if ( provided File != null && provided File . exists ( ) ) { for (  String file Name : file Names ) {  File file = new  File ( provided File , file Name ) ; if ( file Name . equals ( file . get Name ( ) ) && file . exists ( ) ) { return to System Dependent Name ( file . get Path ( ) ) ; } } } return null ; }
static  String base64encode ( byte [ ] bytes ) {  String Builder builder = new  String Builder ( ( ( bytes . length + _ NUM ) / _ NUM ) * _ NUM ) ; for ( int i = _ NUM ; i < bytes . length ; i += _ NUM ) { byte b0 = bytes [ i ] ; byte b1 = i < bytes . length - _ NUM ? bytes [ i + _ NUM ] : _ NUM ; byte b2 = i < bytes . length - _ NUM ? bytes [ i + _ NUM ] : _ NUM ; builder . append (  BASE64_ CHARS [ ( b0 & _ NUM ) > > _ NUM ] ) ; builder . append (  BASE64_ CHARS [ ( ( b0 & _ NUM ) << _ NUM ) | ( ( b1 & _ NUM ) > > _ NUM ) ] ) ; builder . append ( i < bytes . length - _ NUM ?  BASE64_ CHARS [ ( ( b1 & _ NUM ) << _ NUM ) | ( ( b2 & _ NUM ) > > _ NUM ) ] : _ STR ) ; builder . append ( i < bytes . length - _ NUM ?  BASE64_ CHARS [ b2 & _ NUM ] : _ STR ) ; } return builder . to String ( ) ; }
public static boolean enough Space On Sd Card ( long update Size ) {  String status =  Environment . get External Storage State ( ) ; if ( ! status . equals (  Environment .  MEDIA_ MOUNTED ) ) return _ BOOL ; return ( update Size < get Real Size On Sdcard ( ) ) ; }
public void fire Indexed Property Change (  String property Name , int index , int old Value , int new Value ) { if ( old Value != new Value ) { fire Indexed Property Change ( property Name , index ,  Integer . value Of ( old Value ) ,  Integer . value Of ( new Value ) ) ; } }
public void add Nodes In Doc Order (  Node Iterator iterator ,  XPath Context support ) { if ( ! m_mutable ) throw new  Runtime Exception (  XSLMessages . create XPATHMessage (  XPATHError Resources .  ER_ NODESET_ NOT_ MUTABLE , null ) ) ;  Node node ; while ( null != ( node = iterator . next Node ( ) ) ) { add Node In Doc Order ( node , support ) ; } }
protected static  String read Stream (  Input Stream stream ) throws  One Drive APIException { if ( stream == null ) { return null ; }  Input Stream Reader reader = new  Input Stream Reader ( stream ,  Standard Charsets .  UTF_8 ) ;  String Builder builder = new  String Builder ( ) ; char [ ] buffer = new char [  BUFFER_ SIZE ] ; try { int read ; while ( ( read = reader . read ( buffer , _ NUM ,  BUFFER_ SIZE ) ) != - _ NUM ) { builder . append ( buffer , _ NUM , read ) ; } stream . close ( ) ; } catch (  IOException e ) { throw new  One Drive APIException ( _ STR , e ) ; } return builder . to String ( ) ; }
public <  T extends  Comparable <  T > >  Map <  T ,  Double > recommend Docs Using Doc Query (  List <  T > recent Items ,  Query Transform <  T > doc Transform , int num Results ,  Set <  T > exclusions ,  T min Doc , boolean ignore Perfect Matches ) {  Map <  T ,  Double > scores = new  Hash Map < > ( ) ; for (  T recent : recent Items ) {  Array List <  Sem Vector Result <  T > > doc Result = new  Array List < > ( ) ; recommend Docs Using Doc Query ( recent , doc Result , doc Transform , num Results * _ NUM , exclusions , min Doc ) ; for (  Sem Vector Result <  T > r : doc Result ) {  Double score = scores . get ( r . result ) ; if ( ignore Perfect Matches && r . score == _ NUM ) logger . info ( _ STR + recent + _ STR + r . result + _ STR + r . score ) ; else { if ( score != null ) score = score + r . score ; else score = r . score ; scores . put ( r . result , score ) ; } } } return  Recommendation Utils . rescale Scores To One ( scores , num Results ) ; }
public void reset (  Dialogue State state ) { record State ( state ,  CURRENT ) ; list Box . set Selected Index ( _ NUM ) ; while ( list Model . size ( ) > _ NUM ) {  String name = list Model . remove ( _ NUM ) ; states . remove ( name ) ; } visualisation . show Bayesian Network ( state ) ; }
public void write Bytes ( final byte [ ] bytes , final int off , final int len ) { if ( len > remaining ( ) ) { write Bytes Slow ( bytes , off , len ) ; return ; } final  Block block = current ;  System . arraycopy ( bytes , off , block . data , block . limit , len ) ; block . limit += len ; }
private void populate Connection Combo Box ( ) { connection Combo Box . remove All Items ( ) ; if ( geo Server Connection Manager != null ) {  List <  Geo Server Connection > connection List = geo Server Connection Manager . get Connection List ( ) ; for (  Geo Server Connection connection : connection List ) { connection Combo Box . add Item ( connection . get Connection Name ( ) ) ; connection Map . put ( connection . get Connection Name ( ) , connection ) ; } } }
protected  Connection State TLS (  SSLSession Impl session ) { try {  Cipher Suite cipher Suite = session . cipher Suite ; hash_size = cipher Suite . get MACLength ( ) ; boolean is_exportabe = cipher Suite . is Exportable ( ) ; int key_size = ( is_exportabe ) ? cipher Suite . key Material : cipher Suite . expanded Key Material ; int iv_size = cipher Suite . iv Size ; block_size = cipher Suite . get Block Size ( ) ;  String alg Name = cipher Suite . get Bulk Encryption Algorithm ( ) ;  String mac Name = cipher Suite . get Hmac Name ( ) ; if ( logger != null ) { logger . println ( _ STR ) ; logger . println ( _ STR + cipher Suite . get Name ( ) ) ; logger . println ( _ STR + alg Name ) ; logger . println ( _ STR + mac Name ) ; logger . println ( _ STR + hash_size ) ; logger . println ( _ STR + block_size ) ; logger . println ( _ STR + iv_size ) ; logger . println ( _ STR + key_size ) ; } byte [ ] client Random = session . client Random ; byte [ ] server Random = session . server Random ; byte [ ] key_block = new byte [ _ NUM * hash_size + _ NUM * key_size + _ NUM * iv_size ] ; byte [ ] seed = new byte [ client Random . length + server Random . length ] ;  System . arraycopy ( server Random , _ NUM , seed , _ NUM , server Random . length ) ;  System . arraycopy ( client Random , _ NUM , seed , server Random . length , client Random . length ) ;  PRF . compute PRF ( key_block , session . master_secret ,  KEY_ EXPANSION_ LABEL , seed ) ; byte [ ] client_mac_secret = new byte [ hash_size ] ; byte [ ] server_mac_secret = new byte [ hash_size ] ; byte [ ] client_key = new byte [ key_size ] ; byte [ ] server_key = new byte [ key_size ] ; boolean is_client = ! session . is Server ;  System . arraycopy ( key_block , _ NUM , client_mac_secret , _ NUM , hash_size ) ;  System . arraycopy ( key_block , hash_size , server_mac_secret , _ NUM , hash_size ) ;  System . arraycopy ( key_block , _ NUM * hash_size , client_key , _ NUM , key_size ) ;  System . arraycopy ( key_block , _ NUM * hash_size + key_size , server_key , _ NUM , key_size ) ;  Iv Parameter Spec client IV = null ;  Iv Parameter Spec server IV = null ; if ( is_exportabe ) {  System . arraycopy ( client Random , _ NUM , seed , _ NUM , client Random . length ) ;  System . arraycopy ( server Random , _ NUM , seed , client Random . length , server Random . length ) ; byte [ ] final_client_key = new byte [ cipher Suite . expanded Key Material ] ; byte [ ] final_server_key = new byte [ cipher Suite . expanded Key Material ] ;  PRF . compute PRF ( final_client_key , client_key ,  CLIENT_ WRITE_ KEY_ LABEL , seed ) ;  PRF . compute PRF ( final_server_key , server_key ,  SERVER_ WRITE_ KEY_ LABEL , seed ) ; client_key = final_client_key ; server_key = final_server_key ; if ( block_size != _ NUM ) { byte [ ] iv_block = new byte [ _ NUM * iv_size ] ;  PRF . compute PRF ( iv_block , null ,  IV_ BLOCK_ LABEL , seed ) ; client IV = new  Iv Parameter Spec ( iv_block , _ NUM , iv_size ) ; server IV = new  Iv Parameter Spec ( iv_block , iv_size , iv_size ) ; } } else if ( block_size != _ NUM ) { client IV = new  Iv Parameter Spec ( key_block , _ NUM * ( hash_size + key_size ) , iv_size ) ; server IV = new  Iv Parameter Spec ( key_block , _ NUM * ( hash_size + key_size ) + iv_size , iv_size ) ; } if ( logger != null ) { logger . println ( _ STR + is_exportabe ) ; logger . println ( _ STR ) ; logger . print ( session . master_secret ) ; logger . println ( _ STR ) ; logger . print ( client Random ) ; logger . println ( _ STR ) ; logger . print ( server Random ) ; logger . println ( _ STR ) ; logger . print ( client_mac_secret ) ; logger . println ( _ STR ) ; logger . print ( server_mac_secret ) ; logger . println ( _ STR ) ; logger . print ( client_key ) ; logger . println ( _ STR ) ; logger . print ( server_key ) ; if ( client IV == null ) { logger . println ( _ STR ) ; } else { logger . println ( _ STR ) ; logger . print ( client IV . get IV ( ) ) ; logger . println ( _ STR ) ; logger . print ( server IV . get IV ( ) ) ; } } if ( alg Name == null ) { enc Cipher = new  Null Cipher ( ) ; dec Cipher = new  Null Cipher ( ) ; } else { enc Cipher =  Cipher . get Instance ( alg Name ) ; dec Cipher =  Cipher . get Instance ( alg Name ) ; if ( is_client ) { enc Cipher . init (  Cipher .  ENCRYPT_ MODE , new  Secret Key Spec ( client_key , alg Name ) , client IV ) ; dec Cipher . init (  Cipher .  DECRYPT_ MODE , new  Secret Key Spec ( server_key , alg Name ) , server IV ) ; } else { enc Cipher . init (  Cipher .  ENCRYPT_ MODE , new  Secret Key Spec ( server_key , alg Name ) , server IV ) ; dec Cipher . init (  Cipher .  DECRYPT_ MODE , new  Secret Key Spec ( client_key , alg Name ) , client IV ) ; } } enc Mac =  Mac . get Instance ( mac Name ) ; dec Mac =  Mac . get Instance ( mac Name ) ; if ( is_client ) { enc Mac . init ( new  Secret Key Spec ( client_mac_secret , mac Name ) ) ; dec Mac . init ( new  Secret Key Spec ( server_mac_secret , mac Name ) ) ; } else { enc Mac . init ( new  Secret Key Spec ( server_mac_secret , mac Name ) ) ; dec Mac . init ( new  Secret Key Spec ( client_mac_secret , mac Name ) ) ; } } catch (  Exception e ) { e . print Stack Trace ( ) ; throw new  Alert Exception (  Alert Protocol .  INTERNAL_ ERROR , new  SSLProtocol Exception ( _ STR ) ) ; } }
long cleanup ( long now ) { int in Use Connection Count = _ NUM ; int idle Connection Count = _ NUM ;  Real Connection longest Idle Connection = null ; long longest Idle Duration Ns =  Long .  MIN_ VALUE ; synchronized ( this ) { for (  Iterator <  Real Connection > i = connections . iterator ( ) ; i . has Next ( ) ; ) {  Real Connection connection = i . next ( ) ; if ( prune And Get Allocation Count ( connection , now ) > _ NUM ) { in Use Connection Count ++ ; continue ; } idle Connection Count ++ ; long idle Duration Ns = now - connection . idle At Nanos ; if ( idle Duration Ns > longest Idle Duration Ns ) { longest Idle Duration Ns = idle Duration Ns ; longest Idle Connection = connection ; } } if ( longest Idle Duration Ns >= this . keep Alive Duration Ns || idle Connection Count > this . max Idle Connections ) { connections . remove ( longest Idle Connection ) ; } else if ( idle Connection Count > _ NUM ) { return keep Alive Duration Ns - longest Idle Duration Ns ; } else if ( in Use Connection Count > _ NUM ) { return keep Alive Duration Ns ; } else { return - _ NUM ; } }  Util . close Quietly ( longest Idle Connection . get Socket ( ) ) ; return _ NUM ; }
public  State Info (  State Info info ) { this . state = info . state ; this . font = info . font ; if ( info . data != null ) { if ( data == null ) { data = new  Hash Map ( ) ; } data . put All ( info . data ) ; } if ( info . colors != null ) { this . colors = new  Color [ info . colors . length ] ;  System . arraycopy ( info . colors , _ NUM , colors , _ NUM , info . colors . length ) ; } }
public static void assert Equals (  String message ,  Object expected ,  Object actual ) { if ( expected == null && actual == null ) { return ; } if ( expected != null && expected . equals ( actual ) ) { return ; } fail Not Equals ( message , expected , actual ) ; }
public static byte [ ] decode (  String str ) throws  Coder Exception { byte out [ ] = new byte [ str . length ( ) ] ; int len = _ NUM ; int offset = _ NUM ; byte b = _ NUM ; boolean stop = _ BOOL ;  String Character Iterator it = new  String Character Iterator ( str ) ; do { b = _dec ( it . current ( ) ) ; it . next ( ) ; if ( b > _ NUM ) throw new  Coder Exception ( _ STR + str + _ STR ) ; if ( b < _ NUM ) stop = _ BOOL ; len += b ; for ( ; b > _ NUM ; b -= _ NUM ) { decode Chars ( it , out , offset ) ; offset += _ NUM ; } it . next ( ) ; } while ( ! stop ) ; byte rtn [ ] = new byte [ len ] ; for ( int i = _ NUM ; i < len ; i ++ ) rtn [ i ] = out [ i ] ; return rtn ; }
private void compute Position Of Events (  List <  Event Rect > event Rects ) {  List <  List <  Event Rect > > collision Groups = new  Array List <  List <  Event Rect > > ( ) ; for (  Event Rect event Rect : event Rects ) { boolean is Placed = _ BOOL ; outer Loop : for (  List <  Event Rect > collision Group : collision Groups ) { for (  Event Rect group Event : collision Group ) { if ( is Events Collide ( group Event . event , event Rect . event ) ) { collision Group . add ( event Rect ) ; is Placed = _ BOOL ; break outer Loop ; } } } if ( ! is Placed ) {  List <  Event Rect > new Group = new  Array List <  Event Rect > ( ) ; new Group . add ( event Rect ) ; collision Groups . add ( new Group ) ; } } for (  List <  Event Rect > collision Group : collision Groups ) { expand Events To Max Width ( collision Group ) ; } }
public byte [ ] embed Data ( byte [ ] msg ,  String msg File Name , byte [ ] cover ,  String cover File Name ,  String stego File Name ) throws  Open Stego Exception {  Buffered Image image = null ;  Dct LSBOutput Stream os = null ; int img Type = _ NUM ; try { if ( cover == null ) { image =  Image Util . generate Random Image ( (  DCTData Header . get Max Header Size ( ) + msg . length ) * _ NUM *  DCT .  NJPEG *  DCT .  NJPEG ) ; } else { image =  Image Util . byte Array To Image ( cover , cover File Name ) ; } img Type = image . get Type ( ) ; os = new  Dct LSBOutput Stream ( image , msg . length , msg File Name , this . config ) ; os . write ( msg ) ; os . close ( ) ; return  Image Util . image To Byte Array ( os . get Image ( img Type ) , stego File Name , this ) ; } catch (  IOException io Ex ) { throw new  Open Stego Exception ( io Ex ) ; } }
private  Bitmap create Text Bitmap (  Configuration config ) {  Bitmap bitmap =  Bitmap . create Bitmap (  TEXTURE_ SIZE ,  TEXTURE_ SIZE ,  Bitmap .  Config .  ARGB_4444 ) ;  Canvas canvas = new  Canvas ( bitmap ) ; bitmap . erase Color ( _ NUM ) ;  Paint text Paint = new  Paint ( ) ;  Typeface typeface =  Typeface . default From Style (  Typeface .  BOLD ) ; text Paint . set Typeface ( typeface ) ; text Paint . set Text Size (  TEXT_ SIZE ) ; text Paint . set Anti Alias ( _ BOOL ) ; int start X = _ NUM ; int start Y = _ NUM ; int line Height = _ NUM ; for ( int i = _ NUM ; i <  STRING_ COUNT ; i ++ ) {  String str = config . get Text String ( i ) ; text Paint . set Color ( _ NUM | config . get Text Color ( i ) ) ; if ( config . get Text Shadow ( i ) ) { text Paint . set Shadow Layer (  SHADOW_ RADIUS ,  SHADOW_ OFFSET ,  SHADOW_ OFFSET , _ NUM ) ; } else { text Paint . set Shadow Layer ( _ NUM , _ NUM , _ NUM , _ NUM ) ; }  Rect bounds Rect = new  Rect ( ) ; text Paint . get Text Bounds ( str , _ NUM , str . length ( ) , bounds Rect ) ; if ( config . get Text Shadow ( i ) ) { bounds Rect . right +=  SHADOW_ RADIUS +  SHADOW_ OFFSET ; bounds Rect . bottom +=  SHADOW_ RADIUS +  SHADOW_ OFFSET ; } if ( bounds Rect . width ( ) >  TEXTURE_ SIZE || bounds Rect . height ( ) >  TEXTURE_ SIZE ) {  Log . w (  TAG , _ STR + str + _ STR + bounds Rect ) ; } if ( start X != _ NUM && start X + bounds Rect . width ( ) >  TEXTURE_ SIZE ) { start X = _ NUM ; start Y += line Height ; line Height = _ NUM ; if ( start Y >=  TEXTURE_ SIZE ) {  Log . w (  TAG , _ STR ) ; } } canvas . draw Text ( str , start X - bounds Rect . left , start Y - bounds Rect . top , text Paint ) ; bounds Rect . offset To ( start X , start Y ) ; m Text Positions [ i ] = bounds Rect ; line Height =  Math . max ( line Height , bounds Rect . height ( ) + _ NUM ) ; start X += bounds Rect . width ( ) + _ NUM ; } return bitmap ; }
public boolean is Greater Then (  Percent  Percent ) { assert Defined ( ) ;  Big Decimal this Value = not Null ( this ) ;  Big Decimal parameter = not Null (  Percent ) ; return ( this Value . compare To ( parameter ) > _ NUM ) ; }
private void adjust Column Widths (  JTable table ) {  Table Column Model model = table . get Column Model ( ) ; for ( int column = _ NUM ; column < table . get Column Count ( ) ; column ++ ) {  Table Column tc = model . get Column ( column ) ; int width = tc . get Width ( ) ; for ( int row = _ NUM ; row < table . get Row Count ( ) ; row ++ ) {  Component comp = table . prepare Renderer ( table . get Cell Renderer ( row , column ) , row , column ) ; width =  Math . max ( width , comp . get Preferred Size ( ) . width ) ; } tc . set Preferred Width ( width ) ; } }
public static boolean delete Files In Folder (  Context context , @  Non Null final  File folder ) { boolean total Success = _ BOOL ;  String [ ] children = folder . list ( ) ; if ( children != null ) { for (  String child : children ) {  File file = new  File ( folder , child ) ; if ( ! file . is Directory ( ) ) { boolean success = delete File ( context , file ) ; if ( ! success ) {  Log . w (  TAG , _ STR + child ) ; total Success = _ BOOL ; } } } } return total Success ; }
public static  Workflow .  Method rollback Create Volumes Method (  URI system URI ,  List <  URI > volume URIs ) { return new  Workflow .  Method ( _ STR , system URI , volume URIs ) ; }
private void kick Off (  Team offense ) { if ( game Time <= _ NUM ) return ; else { if ( game Time < _ NUM && ( ( game Poss && ( away Score - home Score ) <= _ NUM && ( away Score - home Score ) > _ NUM ) || ( ! game Poss && ( home Score - away Score ) <= _ NUM && ( home Score - away Score ) > _ NUM ) ) ) { if ( offense . get K ( _ NUM ) . rat Kick Fum *  Math . random ( ) > _ NUM ||  Math . random ( ) < _ NUM ) { game Event Log += get Event Prefix ( ) + offense . abbr + _ STR + offense . get K ( _ NUM ) . name + _ STR + offense . abbr + _ STR ; } else { game Event Log += get Event Prefix ( ) + offense . abbr + _ STR + offense . get K ( _ NUM ) . name + _ STR ; game Poss = ! game Poss ; } game Yard Line = _ NUM ; game Down = _ NUM ; game Yards Need = _ NUM ; game Time -= _ NUM + _ NUM *  Math . random ( ) ; } else { game Yard Line = ( int ) ( _ NUM - ( offense . get K ( _ NUM ) . rat Kick Pow + _ NUM - _ NUM *  Math . random ( ) ) ) ; if ( game Yard Line <= _ NUM ) game Yard Line = _ NUM ; game Down = _ NUM ; game Yards Need = _ NUM ; game Poss = ! game Poss ; } game Time -= _ NUM *  Math . random ( ) ; } }
public static final byte [ ] inflate ( byte [ ] in ) throws  IOException {  Byte Array Output Stream out Stream = new  Byte Array Output Stream (  EXPECTED_ COMPRESSION_ RATIO * in . length ) ;  Inflater Input Stream in Stream = new  Inflater Input Stream ( new  Byte Array Input Stream ( in ) ) ; byte [ ] buf = new byte [  BUF_ SIZE ] ; while ( _ BOOL ) { int size = in Stream . read ( buf ) ; if ( size <= _ NUM ) break ; out Stream . write ( buf , _ NUM , size ) ; } out Stream . close ( ) ; return out Stream . to Byte Array ( ) ; }
private void process ( double [ ] data , double min , double max ,  Kernel Density Function kernel , int window , double epsilon ) { dens = new double [ data . length ] ; var = new double [ data . length ] ; double halfwidth = ( ( max - min ) / window ) * _ NUM ; for ( int current = _ NUM ; current < data . length ; current ++ ) { double value = _ NUM ; for ( int i = current ; i >= _ NUM ; i -- ) { double delta =  Math . abs ( data [ i ] - data [ current ] ) / halfwidth ; final double contrib = kernel . density ( delta ) ; value += contrib ; if ( contrib < epsilon ) { break ; } } for ( int i = current + _ NUM ; i < data . length ; i ++ ) { double delta =  Math . abs ( data [ i ] - data [ current ] ) / halfwidth ; final double contrib = kernel . density ( delta ) ; value += contrib ; if ( contrib < epsilon ) { break ; } } double realwidth = (  Math . min ( data [ current ] + halfwidth , max ) -  Math . max ( min , data [ current ] - halfwidth ) ) ; double weight = realwidth / ( _ NUM * halfwidth ) ; dens [ current ] = value / ( data . length * realwidth * _ NUM ) ; var [ current ] = _ NUM / weight ; } }
public static  Socket create Socket (  Inet Address address , int port ) throws  IOException {  Socket socket = null ; set Keystore ( ) ;  SSLSocket Factory f = (  SSLSocket Factory )  SSLSocket Factory . get Default ( ) ;  SSLSocket secure Socket = (  SSLSocket ) f . create Socket ( ) ; secure Socket . connect ( new  Inet Socket Address ( address , port ) ,  Sys Properties .  SOCKET_ CONNECT_ TIMEOUT ) ; secure Socket . set Enabled Protocols ( disable SSL ( secure Socket . get Enabled Protocols ( ) ) ) ; if (  Sys Properties .  ENABLE_ ANONYMOUS_ TLS ) {  String [ ] list = enable Anonymous ( secure Socket . get Enabled Cipher Suites ( ) , secure Socket . get Supported Cipher Suites ( ) ) ; secure Socket . set Enabled Cipher Suites ( list ) ; } socket = secure Socket ; return socket ; }
public static void decode Ignore Whitespace (  Reader r ,  Output Stream os ) throws  IOException { while ( _ BOOL ) { int ch0 = read Non Whitespace ( r ) ; int ch1 = read Non Whitespace ( r ) ; int ch2 = read Non Whitespace ( r ) ; int ch3 = read Non Whitespace ( r ) ; if ( ch1 < _ NUM ) break ; if ( ch2 < _ NUM ) ch2 = _ STR ; if ( ch3 < _ NUM ) ch3 = _ STR ; int chunk = ( ( _decode [ ch0 ] << _ NUM ) + ( _decode [ ch1 ] << _ NUM ) + ( _decode [ ch2 ] << _ NUM ) + ( _decode [ ch3 ] ) ) ; os . write ( ( byte ) ( ( chunk > > _ NUM ) & _ NUM ) ) ; if ( ch2 != _ STR && ch2 != - _ NUM ) os . write ( ( byte ) ( ( chunk > > _ NUM ) & _ NUM ) ) ; if ( ch3 != _ STR && ch3 != - _ NUM ) os . write ( ( byte ) ( ( chunk & _ NUM ) ) ) ; else break ; } os . flush ( ) ; }
public void update VVset (  String volume CGName ,  String vol Name , int action Value ) throws  Exception { _log . info ( _ STR ) ;  Client Response client Resp = null ; final  String path =  Message Format . format (  URI_ UPDATE_ CG , volume CGName ) ;  String payload = _ STR + action Value + _ STR + vol Name + _ STR ; _log . info ( _ STR , path , payload ) ; try { client Resp = put ( path , payload ) ; if ( client Resp == null ) { _log . error ( _ STR ) ; throw new  HP3 PARException ( _ STR ) ; } else if ( client Resp . get Status ( ) != _ NUM ) {  String err Resp = get Response Details ( client Resp ) ; throw new  HP3 PARException ( err Resp ) ; } else { _log . info ( _ STR ) ; } } catch (  Exception e ) { throw e ; } finally { if ( client Resp != null ) { client Resp . close ( ) ; } _log . info ( _ STR ) ; } }
public void notify Consist Throttle Found (  Dcc Throttle t ) { this . consist Throttle = t ; for ( int i = _ NUM ; i < listeners . size ( ) ; i ++ ) {  Address Listener l = listeners . get ( i ) ; if ( log . is Debug Enabled ( ) ) { log . debug ( _ STR + l . get Class ( ) ) ; } l . notify Consist Address Throttle Found ( t ) ; } }
public boolean is Expired ( final  Date now ) { return ( cookie Expiry Date != null && cookie Expiry Date . get Time ( ) <= now . get Time ( ) ) ; }
private int measure Height ( int measure Spec ) { int result ; int spec Mode =  Measure Spec . get Mode ( measure Spec ) ; int spec Size =  Measure Spec . get Size ( measure Spec ) ; m Ascent = ( int ) m Text Paint . ascent ( ) ; if ( spec Mode ==  Measure Spec .  EXACTLY ) { result = spec Size ; } else { result = ( int ) ( - m Ascent + m Text Paint . descent ( ) ) + get Padding Top ( ) + get Padding Bottom ( ) ; if ( spec Mode ==  Measure Spec .  AT_ MOST ) { result =  Math . min ( result , spec Size ) ; } } return result ; }
public  Host State Change (  Host target ,  URI old Cluster URI ) { this . host = target ; this . old Initiators =  Sets . new Hash Set ( ) ; this . new Initiators =  Sets . new Hash Set ( ) ; this . old Cluster = old Cluster URI ; }
public void put All (  Tungsten Properties props ) { properties . put All ( props . map ( ) ) ; }
public int register (  Advice advice ) { int advice Id = advice Id Seed . get And Increment ( ) ;  Active Instances current , next ; do { current = active . get ( ) ; next = current . add ( advice , advice Id ) ; } while ( ! active . compare And Set ( current , next ) ) ; return advice Id ; }
private  Bitmap process Bitmap (  String data ) { if (  Build Config .  DEBUG ) {  Log . d (  TAG , _ STR + data ) ; } final  String key =  Image Cache . hash Key For Disk ( data ) ;  File Descriptor file Descriptor = null ;  File Input Stream file Input Stream = null ;  Disk Lru Cache .  Snapshot snapshot ; synchronized ( m Http Disk Cache Lock ) { while ( m Http Disk Cache Starting ) { try { m Http Disk Cache Lock . wait ( ) ; } catch (  Interrupted Exception e ) { } } if ( m Http Disk Cache != null ) { try { snapshot = m Http Disk Cache . get ( key ) ; if ( snapshot == null ) { if (  Build Config .  DEBUG ) {  Log . d (  TAG , _ STR ) ; }  Disk Lru Cache .  Editor editor = m Http Disk Cache . edit ( key ) ; if ( editor != null ) { if ( download Url To Stream ( data , editor . new Output Stream (  DISK_ CACHE_ INDEX ) ) ) { editor . commit ( ) ; } else { editor . abort ( ) ; } } snapshot = m Http Disk Cache . get ( key ) ; } if ( snapshot != null ) { file Input Stream = (  File Input Stream ) snapshot . get Input Stream (  DISK_ CACHE_ INDEX ) ; file Descriptor = file Input Stream . get FD ( ) ; } } catch (  IOException e ) {  Log . e (  TAG , _ STR + e ) ; } catch (  Illegal State Exception e ) {  Log . e (  TAG , _ STR + e ) ; } finally { if ( file Descriptor == null && file Input Stream != null ) { try { file Input Stream . close ( ) ; } catch (  IOException e ) { } } } } }  Bitmap bitmap = null ; if ( file Descriptor != null ) { bitmap = decode Sampled Bitmap From Descriptor ( file Descriptor , m Image Width , m Image Height , get Image Cache ( ) ) ; } if ( file Input Stream != null ) { try { file Input Stream . close ( ) ; } catch (  IOException e ) { } } return bitmap ; }
public static  Pair <  String ,  String > parse Title And Date In Brackets (  String title ) { if ( title == null ) return new  Pair < > ( null , null ) ;  Pattern p =  Pattern . compile ( _ STR ,  Pattern .  CASE_ INSENSITIVE ) ;  Matcher m = p . matcher ( title ) ; if ( m . find ( ) ) { return new  Pair < > ( m . group ( _ NUM ) , m . group ( _ NUM ) ) ; } return new  Pair < > ( title , null ) ; }
private void adjust Selections (  Selection selection ,  String inserted ) { int dif = ( selection . y - selection . x ) - inserted . length ( ) ; for (  Selection sel : this . selections ) { sel . x = sel . x - dif ; sel . y = sel . y - dif ; } }
public void pre Allocate Synapses ( int expected Num Synapses ) throws  Illegal State Exception { if ( ! ex Synapse Set . is Empty ( ) || ! in Synapse Set . is Empty ( ) ) { throw new  Illegal Argument Exception ( _ STR + _ STR + _ STR + _ STR + _ STR ) ; } ex Synapse Set = new  Hash Set <  Synapse > ( ( int ) ( expected Num Synapses * excitatory Ratio / _ NUM ) ) ; in Synapse Set = new  Hash Set <  Synapse > ( ( int ) ( expected Num Synapses * ( _ NUM - excitatory Ratio ) / _ NUM ) ) ; }
public void root Added (  ISVNRepository Location root ) {  Iterator it = listeners . iterator ( ) ; while ( it . has Next ( ) ) {  IRepository Listener listener = (  IRepository Listener ) it . next ( ) ; listener . repository Added ( root ) ; } }
private void bfs ( char [ ] [ ] grid , int i , int j ) {  Queue <  Point > queue = new  Array Deque < > ( ) ; grid [ i ] [ j ] = _ STR ; queue . add ( new  Point ( i , j ) ) ; while ( ! queue . is Empty ( ) ) {  Point p = queue . poll ( ) ; for ( int [ ] dir : dirs ) { int row = p . row + dir [ _ NUM ] ; int col = p . col + dir [ _ NUM ] ; if ( row >= _ NUM && row < grid . length && col >= _ NUM && col < grid [ row ] . length && grid [ row ] [ col ] == _ STR ) { grid [ row ] [ col ] = _ STR ; queue . add ( new  Point ( row , col ) ) ; } } } }
Message ( ) { }
private void read Fig Tree Block (  Map <  String ,  Object > settings ) throws  Import Exception ,  IOException {  String command = helper . read Token ( _ STR ) ; while ( ! command . equals Ignore Case ( _ STR ) ) { if ( command . equals Ignore Case ( _ STR ) ) { while ( helper . get Last Delimiter ( ) != _ STR ) {  String key = helper . read Token ( _ STR ) ; if ( helper . get Last Delimiter ( ) != _ STR ) { throw new  Import Exception ( _ STR + key + _ STR + command + _ STR ) ; }  String value = helper . read Token ( _ STR ) ; settings . put ( key , parse Value ( value ) ) ; } } else { throw new  Import Exception ( _ STR + command + _ STR ) ; } command = helper . read Token ( _ STR ) ; } find End Block ( ) ; }
synchronized void unregister To Notifications ( ) throws  JMSException { if ( event Session == null ) { return ; } if ( _logger . is Loggable (  Level .  FINE ) ) { _logger . log (  Level .  FINE , to String2 ( ) + _ STR ) ; } try { event Session . close ( ) ; } catch (  IOException e ) { if ( _logger . is Loggable (  Level .  FINE ) ) { _logger . log (  Level .  FINE , to String2 ( ) + _ STR + e ) ; }  JMSException e1 = new  JMSException ( _ STR ) ; e1 . set Linked Exception ( e ) ; throw e1 ; } catch (  Unknown Lease Exception e ) { if ( _logger . is Loggable (  Level .  FINE ) ) { _logger . log (  Level .  FINE , to String2 ( ) + _ STR + e ) ; }  JMSException e1 = new  JMSException ( _ STR ) ; e1 . set Linked Exception ( e ) ; throw e1 ; } catch (  Exception e ) { if ( _logger . is Loggable (  Level .  FINE ) ) { _logger . log (  Level .  FINE , to String2 ( ) + _ STR + e ) ; }  JMSException e1 = new  JMSException ( _ STR ) ; e1 . set Linked Exception ( e ) ; throw e1 ; } finally { event Session = null ; } }
public static int index Of Ignore Parentheses ( char c ,  String s , int start ) { int level = _ NUM ; for ( int i = start ; i < s . length ( ) ; i ++ ) { char other = s . char At ( i ) ; if ( other == _ STR ) { level ++ ; } else if ( other == _ STR ) { level -- ; } else if ( other == c && level == _ NUM ) { return i ; } } return - _ NUM ; }
public  Attr Set (  Attr [ ] attrs ) { int size = attrs . length ; _attrs = new  Array List ( size ) ; for ( int i = _ NUM ; i < size ; i ++ ) { _attrs . add ( attrs [ i ] ) ; } }
public double narrow ( ) throws  Operator Failed Exception {  Node Ref i = null , i P = null , j = null , j P = null ; int tries = _ NUM ; int before Moves = get All Valid Narrow Moves ( ) ; while ( tries <  MAX_ TRIES ) { i = tree . get Node (  Math Utils . next Int ( tree . get Node Count ( ) ) ) ; while ( tree . get Root ( ) == i || tree . get Parent ( i , _ NUM ) == tree . get Root ( ) || tree . get Parent ( i , _ NUM ) == tree . get Root ( ) ) { i = tree . get Node (  Math Utils . next Int ( tree . get Node Count ( ) ) ) ; } i P = tree . get Parent ( i , _ NUM ) ; if ( tree . is Reassortment ( i ) &&  Math Utils . next Boolean ( ) ) i P = tree . get Parent ( i , _ NUM ) ; j P = tree . get Parent ( i P , _ NUM ) ; if ( tree . is Reassortment ( i P ) &&  Math Utils . next Boolean ( ) ) j P = tree . get Parent ( i P , _ NUM ) ; j = tree . get Child ( j P , _ NUM ) ; if ( j == i P ) { j = tree . get Child ( j P , _ NUM ) ; } if ( j != i P && i != j && ( tree . get Node Height ( j ) < tree . get Node Height ( i P ) ) && ( tree . get Node Height ( i ) < tree . get Node Height ( j P ) ) ) { break ; } tries += _ NUM ; } if ( tries <  MAX_ TRIES ) { eupdate ARG ( i , j , i P , j P ) ; tree . push Tree Changed Event ( i P ) ; tree . push Tree Changed Event ( j P ) ; } else throw new  Operator Failed Exception ( _ STR ) ; return  Math . log ( ( double ) before Moves / get All Valid Narrow Moves ( ) ) ; }
public void remove Listeners ( ) { if ( click Listeners != null ) { click Listeners . clear ( ) ; } if ( select Listeners != null ) { select Listeners . clear ( ) ; } }
public  String decrypt String (  String s Cipher Text ) { int n Len = ( s Cipher Text . length ( ) > > _ NUM ) & ~ _ NUM ; if ( n Len <  Blowfish ECB .  BLOCKSIZE ) return null ; byte [ ] cbciv = new byte [  Blowfish ECB .  BLOCKSIZE ] ; int n Num Of Bytes =  Bin Converter . bin Hex To Bytes ( s Cipher Text , cbciv , _ NUM , _ NUM ,  Blowfish ECB .  BLOCKSIZE ) ; if ( n Num Of Bytes <  Blowfish ECB .  BLOCKSIZE ) return null ; m_bfish . set CBCIV ( cbciv ) ; n Len -=  Blowfish ECB .  BLOCKSIZE ; if ( n Len == _ NUM ) return _ STR ; byte [ ] buf = new byte [ n Len ] ; n Num Of Bytes =  Bin Converter . bin Hex To Bytes ( s Cipher Text , buf ,  Blowfish ECB .  BLOCKSIZE * _ NUM , _ NUM , n Len ) ; if ( n Num Of Bytes < n Len ) return null ; m_bfish . decrypt ( buf ) ; int n Pad Byte = buf [ buf . length - _ NUM ] & _ NUM ; if ( ( n Pad Byte > _ NUM ) || ( n Pad Byte < _ NUM ) ) n Pad Byte = _ NUM ; n Num Of Bytes -= n Pad Byte ; if ( n Num Of Bytes < _ NUM ) return _ STR ; return  Bin Converter . byte Array To UNCString ( buf , _ NUM , n Num Of Bytes ) ; }
public static  Trellis order Trellis (  Trellis trel , double  I [ ] [ ] ,  Random rand ) { int  L =  I . length ; int  Y [ ] = new int [  L ] ;  Array List <  Integer > list = new  Array List <  Integer > ( ) ; for ( int i : trel . indices ) { list . add ( new  Integer ( i ) ) ; }  Y [ _ NUM ] = list . remove ( rand . next Int (  L ) ) ; for ( int j = _ NUM ; j <  L ; j ++ ) { double max_w = - _ NUM ; int j_ = - _ NUM ; for ( int j_prop : list ) { double w = trel . weight (  Y , j , j_prop ,  I ) ; if ( w >= max_w ) { max_w = w ; j_ = j_prop ; } } list . remove ( new  Integer ( j_ ) ) ;  Y [ j ] = j_ ; } trel = new  Trellis (  Y , trel .  WIDTH , trel .  TYPE ) ; return trel ; }
@  Override public double [ ] [ ] process Ids (  DBIDs ids ,  Relation < ? extends  Number Vector > relation ) { final int dim =  Relation Util . dimensionality ( relation ) ; final  Covariance Matrix cmat = new  Covariance Matrix ( dim ) ; final  Centroid centroid =  Centroid . make ( relation , ids ) ; double maxdist = _ NUM ; double stddev = _ NUM ; { for (  DBIDIter iter = ids . iter ( ) ; iter . valid ( ) ; iter . advance ( ) ) {  Number Vector obj = relation . get ( iter ) ; double distance = weight Distance . distance ( centroid , obj ) ; stddev += distance * distance ; if ( distance > maxdist ) { maxdist = distance ; } } if ( maxdist == _ NUM ) { maxdist = _ NUM ; } stddev =  Math . sqrt ( stddev / ids . size ( ) ) ; } for (  DBIDIter iter = ids . iter ( ) ; iter . valid ( ) ; iter . advance ( ) ) {  Number Vector obj = relation . get ( iter ) ; double distance = weight Distance . distance ( centroid , obj ) ; double weight = weightfunction . get Weight ( distance , maxdist , stddev ) ; cmat . put ( obj , weight ) ; } return cmat . destroy To Naive Matrix ( ) ; }
@  Override public boolean is Modified ( ) { if ( _is Digest Modified ) { if ( log . is Loggable (  Level .  FINE ) ) log . fine ( _source . get Native Path ( ) + _ STR ) ; return _ BOOL ; } long source Last Modified = _source . get Last Modified ( ) ; long source Length = _source . length ( ) ; if ( ! _require Source && source Last Modified == _ NUM ) { return _ BOOL ; } else if ( source Length != _length ) { if ( log . is Loggable (  Level .  FINE ) ) { log . fine ( _source . get Native Path ( ) + _ STR + _length + _ STR + source Length + _ STR ) ; } return _ BOOL ; } else if ( source Last Modified != _last Modified ) { if ( log . is Loggable (  Level .  FINE ) ) log . fine ( _source . get Native Path ( ) + _ STR ) ; return _ BOOL ; } else return _ BOOL ; }
public boolean is Expired (  Repository Proxy Cache proxy Cache ) { long method Cache Time = proxy Cache . get Cache Time ( ) ; boolean unlimited Cache = method Cache Time <= _ NUM ;  File cache File = build File ( proxy Cache . get Cache Dir ( ) , proxy Cache . get File Name ( ) ,  DEFAULT_ FILE_ NAME ) ; if ( is Cached ( cache File ) ) { if ( unlimited Cache ) { return _ BOOL ; } long last Modified Time = file Manager . get Last Modified Time ( cache File ) ; boolean expired =  System . current Time Millis ( ) > ( last Modified Time + method Cache Time ) ; if ( expired ) { evict ( proxy Cache ) ; } return expired ; } return _ BOOL ; }
protected void calculate Fitness And Sort Population ( ) { logger . debug ( _ STR + population . size ( ) + _ STR ) ;  Iterator <  T > iterator = population . iterator ( ) ; while ( iterator . has Next ( ) ) {  T c = iterator . next ( ) ; if ( is Finished ( ) ) { if ( c . is Changed ( ) ) iterator . remove ( ) ; } else { for (  Fitness Function <  T > fitness Function : fitness Functions ) { fitness Function . get Fitness ( c ) ; notify Evaluation ( c ) ; } } } sort Population ( ) ; }
public  Session ( ) { long uptime =  System . current Time Millis ( ) ;  Handler Thread thread = new  Handler Thread ( _ STR ) ; thread . start ( ) ; m Handler = new  Handler ( thread . get Looper ( ) ) ; m Main Handler = new  Handler (  Looper . get Main Looper ( ) ) ; m Timestamp = ( uptime / _ NUM ) << _ NUM & ( ( ( uptime - ( ( uptime / _ NUM ) * _ NUM ) ) > > _ NUM ) / _ NUM ) ; m Origin = _ STR ; }
public  List <  Setor > listar ( ) {  List <  Setor > dados = new  Array List < > ( ) ; try {  String sql = _ STR + _ STR ; stm = conector . prepare Statement ( sql ) ; rs = stm . execute Query ( sql ) ; while ( rs . next ( ) ) {  Organizacao org = new  Organizacao ( rs . get Int ( _ NUM ) , rs . get String ( _ NUM ) ) ;  Setor setor = new  Setor ( rs . get Int ( _ NUM ) , rs . get String ( _ NUM ) , rs . get String ( _ NUM ) , org ) ; dados . add ( setor ) ; } stm . close ( ) ; rs . close ( ) ; } catch (  SQLException ex ) {  Mensagem . erro ( _ STR + ex ) ; } return dados ; }
private static void remove Branches After Gotos (  Basic Block bb ) {  Instruction first Goto = null ;  Instruction end = bb . last Real Instruction ( ) ; for (  Enumeration <  Instruction > branches = bb . enumerate Branch Instructions ( ) ; branches . has More Elements ( ) ; ) {  Instruction s = branches . next Element ( ) ; if (  Goto . conforms ( s ) ) { first Goto = s ; break ; } } if ( first Goto != null ) {  Enumeration <  Instruction > ie =  IREnumeration . forward Intra Block IE ( first Goto , end ) ; ie . next Element ( ) ; while ( ie . has More Elements ( ) ) {  Instruction s = ie . next Element ( ) ; if (  Guard Result Carrier . conforms ( s ) ) { insert True Guard ( s ,  Guard Result Carrier . get Guard Result ( s ) ) ; } s . remove ( ) ; } } }
public  String read String ( int length ) throws  IOException { byte [ ] array = new byte [ length ] ; read Fully ( array ) ;  String s = new  String ( array ) ; return s . trim ( ) ; }
private void init Dx Settings ( ) { try {  Boolean d3d = ! settings . get Boolean ( _ STR ) ;  System . set Property ( _ STR , d3d . to String ( ) ) ;  Boolean ddraw = settings . get Boolean ( _ STR ) ;  System . set Property ( _ STR , ddraw . to String ( ) ) ;  LOGGER . info ( _ STR + d3d + _ STR + ddraw ) ; } catch (  Security Exception ex ) {  LOGGER . warning ( _ STR + ex . get Localized Message ( ) ) ; } }
public boolean equals (  Object obj ) { if ( obj == null ) { return _ BOOL ; } if ( get Class ( ) != obj . get Class ( ) ) { return _ BOOL ; } final  ECEFPoint pt = (  ECEFPoint ) obj ; return (  More Math . approximately_equal ( x_ , pt . x_ ,  EQUIVALENT_ TOLERANCE ) &&  More Math . approximately_equal ( y_ , pt . y_ ,  EQUIVALENT_ TOLERANCE ) &&  More Math . approximately_equal ( z_ , pt . z_ ,  EQUIVALENT_ TOLERANCE ) ) ; }
public void wait For Frame ( int frame Number ,  String jump Label ) throws  IOException { print ( _ STR , new  String [ ] {  Integer . to String ( frame Number ) , _ STR + jump Label + _ STR } ) ; }
public void delete (  String name ) throws  IOException { if ( name . equals Ignore Case (  ISSUER_ NAME ) ) { names = null ; } else { throw new  IOException ( _ STR + _ STR ) ; } encode This ( ) ; }
public  Geo Distance Builder add Range (  String key , double from , double to ) { ranges . add ( new  Range ( key , from , to ) ) ; return this ; }
public synchronized void store (  Document doc ,  Resource res ) throws  IOException {  Output Format format = new  Output Format ( doc , null , _ BOOL ) ; format . set Line Separator ( _ STR ) ; format . set Line Width ( _ NUM ) ;  Output Stream os = null ; try {  XMLSerializer serializer = new  XMLSerializer ( os = res . get Output Stream ( ) , format ) ; serializer . serialize ( doc . get Document Element ( ) ) ; } finally {  IOUtil . close EL ( os ) ; } }
public static  String randomly Recase Code Points (  Random random ,  String str ) {  String Builder builder = new  String Builder ( ) ; int pos = _ NUM ; while ( pos < str . length ( ) ) { int code Point = str . code Point At ( pos ) ; pos +=  Character . char Count ( code Point ) ; switch ( next Int ( random , _ NUM , _ NUM ) ) { case _ NUM : builder . append Code Point (  Character . to Upper Case ( code Point ) ) ; break ; case _ NUM : builder . append Code Point (  Character . to Lower Case ( code Point ) ) ; break ; case _ NUM : builder . append Code Point ( code Point ) ; } } return builder . to String ( ) ; }
public  Base Matcher ( final  Network Config config ) { if ( config == null ) { throw new  Null Pointer Exception ( _ STR ) ; } else { this . config = config ; } }
public static void copy File ( final  File from File , final  File to File ) throws  Unchecked IOException {  Input Stream from = null ;  Output Stream to = null ; try { from = new  File Input Stream ( from File ) ; to = new  File Output Stream ( to File ) ; copy Stream ( from , to ) ; } catch (  IOException e ) { throw new  Unchecked IOException ( e ) ; } finally { if ( from != null ) { try { from . close ( ) ; } catch (  IOException ignored ) { ignored . print Stack Trace ( ) ; } } if ( to != null ) { try { to . close ( ) ; } catch (  IOException ignored ) { ignored . print Stack Trace ( ) ; } } } }
public long start_brk ( ) { return  Long . parse Long ( fields [ _ NUM ] ) ; }
public static  Bitmap make Round User Picture (  Bitmap bitmap ) { if ( bitmap == null ) return null ;  Bitmap output =  Bitmap . create Bitmap ( bitmap . get Width ( ) , bitmap . get Height ( ) ,  Config .  ARGB_8888 ) ;  Canvas canvas = new  Canvas ( output ) ; final  Paint paint = new  Paint ( ) ; final  Rect rect = new  Rect ( _ NUM , _ NUM , bitmap . get Width ( ) , bitmap . get Height ( ) ) ; canvas . draw ARGB ( _ NUM , _ NUM , _ NUM , _ NUM ) ; paint . set Anti Alias ( _ BOOL ) ; paint . set Color ( _ NUM ) ; canvas . draw Circle ( bitmap . get Width ( ) * _ NUM , bitmap . get Height ( ) * _ NUM , bitmap . get Width ( ) * _ NUM , paint ) ; paint . set Xfermode ( new  Porter Duff Xfermode (  Porter Duff .  Mode .  SRC_ IN ) ) ; canvas . draw Bitmap ( bitmap , rect , rect , paint ) ; return output ; }
@  Bean public  Controller controller ( ) { if ( use Qt Interface ) { return new  Controller Qt Implementation ( ) ; } else { return new  Controller Java FXImplementation ( ) ; } }
public  Profiler start Collecting ( ) { thread = new  Thread ( this , _ STR ) ; thread . set Daemon ( _ BOOL ) ; thread . start ( ) ; return this ; }
public static void write ( float lt , float ln ,  Image image , int image_width , int image_height ,  Link Properties properties ,  Data Output Stream dos ) throws  IOException ,  Interrupted Exception { int [ ] pixels = new int [ image_width * image_height ] ;  Pixel Grabber pixelgrabber = new  Pixel Grabber ( image , _ NUM , _ NUM , image_width , image_height , pixels , _ NUM , image_width ) ; pixelgrabber . grab Pixels ( ) ;  Link Raster . write ( lt , ln , image_width , image_height , pixels , properties , dos ) ; }
public static  String compress Chars (  String s , char c ) { int len = s . length ( ) ;  String Builder sb = new  String Builder ( len ) ; boolean was Char = _ BOOL ; for ( int i = _ NUM ; i < len ; i ++ ) { char c1 = s . char At ( i ) ; if ( c1 == c ) { if ( was Char ) { continue ; } was Char = _ BOOL ; } else { was Char = _ BOOL ; } sb . append ( c1 ) ; } if ( sb . length ( ) == len ) { return s ; } return sb . to String ( ) ; }
public static double magnitude ( final double x , final double y , final double z ) { return  Math . sqrt ( x * x + y * y + z * z ) ; }
@  Suppress Warnings ( { _ STR , _ STR } ) private static  Object to Set (  Object value ,  Class < ? > parameter Type ) throws  Gf Json Exception { try {  JSONArray array = (  JSONArray ) value ;  Set set = new  Hash Set ( ) ; for ( int i = _ NUM ; i < array . length ( ) ; i ++ ) {  Object element = array . get ( i ) ; if ( is Primitive Or Wrapper ( element . get Class ( ) ) ) { set . add ( element ) ; } else throw new  Gf Json Exception ( _ STR ) ; } return set ; } catch (  JSONException e ) { throw new  Gf Json Exception ( e ) ; } }
private static  Properties create Properties1 ( ) {  Properties props = new  Properties ( ) ; props . set Property (  MCAST_ PORT , _ STR ) ; props . set Property (  LOCATORS , _ STR ) ; return props ; }
private  JPanel create Left Side ( ) {  JPanel left Panel = new  JPanel ( ) ; list Model = new  Custom List Model ( ) ; left Panel . set Layout ( new  Border Layout ( ) ) ; list Box = new  JList <  String > ( list Model ) ; list Box . set Cell Renderer ( new  Jlist Renderer ( ) ) ; list Box . set Selection Mode (  List Selection Model .  SINGLE_ SELECTION ) ; list Box . add List Selection Listener ( new  Custom List Selection Listener ( ) ) ;  JScroll Pane scroll Pane = new  JScroll Pane ( list Box ) ; scroll Pane . set Border (  Border Factory . create Empty Border ( ) ) ; left Panel . add ( scroll Pane ,  Border Layout .  CENTER ) ; scroll Pane . set Border (  Border Factory . create Titled Border ( _ STR ) ) ;  JPanel control Panel = create Control Panel ( ) ; left Panel . add ( control Panel ,  Border Layout .  SOUTH ) ; return left Panel ; }
private static int [ ] add ( int [ ] x , int [ ] y ) { if ( x . length < y . length ) { int [ ] tmp = x ; x = y ; y = tmp ; } int x Index = x . length ; int y Index = y . length ; int result [ ] = new int [ x Index ] ; long sum = _ NUM ; if ( y Index == _ NUM ) { sum = ( x [ -- x Index ] &  LONG_ MASK ) + ( y [ _ NUM ] &  LONG_ MASK ) ; result [ x Index ] = ( int ) sum ; } else { while ( y Index > _ NUM ) { sum = ( x [ -- x Index ] &  LONG_ MASK ) + ( y [ -- y Index ] &  LONG_ MASK ) + ( sum > > > _ NUM ) ; result [ x Index ] = ( int ) sum ; } } boolean carry = ( sum > > > _ NUM != _ NUM ) ; while ( x Index > _ NUM && carry ) carry = ( ( result [ -- x Index ] = x [ x Index ] + _ NUM ) == _ NUM ) ; while ( x Index > _ NUM ) result [ -- x Index ] = x [ x Index ] ; if ( carry ) { int bigger [ ] = new int [ result . length + _ NUM ] ;  System . arraycopy ( result , _ NUM , bigger , _ NUM , result . length ) ; bigger [ _ NUM ] = _ NUM ; return bigger ; } return result ; }
public  Property Sheet Panel ( ) { set Border (  Border Factory . create Empty Border ( _ NUM , _ NUM , _ NUM , _ NUM ) ) ; m_env =  Environment . get System Wide ( ) ; }
public void add Photo (  Photo Entity photo ) { photos . add ( photo ) ; }
public int compute Id (  Bit Set active Matches ,  IRead Block read Block ) { if ( read Block . get Number Of Matches ( ) == _ NUM ) return  Id Mapper .  NOHITS_ ID ; if ( active Matches . cardinality ( ) > _ NUM ) { boolean has Disabled Matches = _ BOOL ; int number Of Addresses = _ NUM ; for ( int i = active Matches . next Set Bit ( _ NUM ) ; i != - _ NUM ; i = active Matches . next Set Bit ( i + _ NUM ) ) { final  IMatch Block match Block = read Block . get Match Block ( i ) ; final int id = match Block . get Id ( c Name ) ; if ( id > _ NUM ) {  String address = full Tree . get Address ( id ) ; if ( address != null ) { if ( number Of Addresses >= addresses . length ) {  String [ ] tmp = new  String [ _ NUM * addresses . length ] ;  System . arraycopy ( addresses , _ NUM , tmp , _ NUM , addresses . length ) ; addresses = tmp ; } addresses [ number Of Addresses ++ ] = address ; } } else has Disabled Matches = _ BOOL ; } if ( number Of Addresses == _ NUM && has Disabled Matches ) { for ( int i = active Matches . next Set Bit ( _ NUM ) ; i != - _ NUM ; i = active Matches . next Set Bit ( i + _ NUM ) ) { final  IMatch Block match Block = read Block . get Match Block ( i ) ; final int id = match Block . get Id ( c Name ) ; if ( id > _ NUM ) {  String address = full Tree . get Address ( id ) ; if ( address != null ) { if ( number Of Addresses >= addresses . length ) {  String [ ] tmp = new  String [ _ NUM * addresses . length ] ;  System . arraycopy ( addresses , _ NUM , tmp , _ NUM , addresses . length ) ; addresses = tmp ; } addresses [ number Of Addresses ++ ] = address ; } } } } if ( number Of Addresses > _ NUM ) { final  String address =  LCAAddressing . get Common Prefix ( addresses , number Of Addresses , _ BOOL ) ; final int id = full Tree . get Address2 Id ( address ) ; if ( id > _ NUM ) { return id ; } } } return  Id Mapper .  UNASSIGNED_ ID ; }
public  Static SETof Ints ( int [ ] keys ) { a = new int [ keys . length ] ; for ( int i = _ NUM ; i < keys . length ; i ++ ) a [ i ] = keys [ i ] ;  Arrays . sort ( a ) ; for ( int i = _ NUM ; i < a . length ; i ++ ) if ( a [ i ] == a [ i - _ NUM ] ) throw new  Illegal Argument Exception ( _ STR ) ; }
public void fetch Entries (  Hash Map <  Integer ,  Hash Set > bucket Keys ,  Versioned Object List values ,  Server Connection serv Conn ) throws  IOException { int retry Attempts = calc Retry ( ) ;  Retry Time Keeper retry Time = null ;  Hash Map <  Integer ,  Hash Set > failures = new  Hash Map <  Integer ,  Hash Set > ( bucket Keys ) ;  Hash Map <  Internal Distributed Member ,  Hash Map <  Integer ,  Hash Set > > node To Buckets = new  Hash Map <  Internal Distributed Member ,  Hash Map <  Integer ,  Hash Set > > ( ) ; while ( -- retry Attempts >= _ NUM && ! failures . is Empty ( ) ) { node To Buckets . clear ( ) ; update Node To Bucket Map ( node To Buckets , failures ) ; failures . clear ( ) ;  Hash Map <  Integer ,  Hash Set > local Buckets = node To Buckets . remove ( get My Id ( ) ) ; if ( local Buckets != null && ! local Buckets . is Empty ( ) ) {  Set keys = new  Hash Set ( ) ; for (  Integer id : local Buckets . key Set ( ) ) { keys . add All ( local Buckets . get ( id ) ) ; } if ( ! keys . is Empty ( ) ) {  Base Command . append New Register Interest Response Chunk From Local ( this , values , _ STR , keys , serv Conn ) ; } }  Set <  Integer > failed Set = handle Old Nodes ( node To Buckets , values , serv Conn ) ; if ( ! failed Set . is Empty ( ) ) { for (  Integer b Id : failed Set ) { failures . put ( b Id , bucket Keys . get ( b Id ) ) ; } update Node To Bucket Map ( node To Buckets , failures ) ; failures . clear ( ) ; } fetch Remote Entries ( node To Buckets , failures , values , serv Conn ) ; if ( ! failures . is Empty ( ) ) { if ( retry Time == null ) { retry Time = new  Retry Time Keeper ( this . retry Timeout ) ; } if ( ! wait For Fetch Remote Entries Retry ( retry Time ) ) { break ; } } } if ( ! failures . is Empty ( ) ) { throw new  Internal Gem Fire Exception ( _ STR + failures . size ( ) + _ STR + get Name ( ) + _ STR ) ; } }
public void dump_stack ( ) { if ( stack == null ) { debug_message ( _ STR ) ; return ; } debug_message ( _ STR ) ; for ( int i = _ NUM ; i < stack . size ( ) ; i ++ ) { debug_message ( _ STR + ( (  Symbol ) stack . element At ( i ) ) . sym + _ STR + ( (  Symbol ) stack . element At ( i ) ) . parse_state ) ; } debug_message ( _ STR ) ; }
public static  Set <  String > parse Channels From String (  String channels , boolean prepend ) {  String [ ] parts = channels . split ( _ STR ) ;  Set <  String > result = new  Linked Hash Set < > ( ) ; for (  String part : parts ) {  String channel = part . trim ( ) ; if ( validate Channel ( channel ) ) { if ( prepend && ! channel . starts With ( _ STR ) ) { channel = _ STR + channel ; } result . add (  String Util . to Lower Case ( channel ) ) ; } } return result ; }
public void download (  String remote File Name ,  File local File , long restart At ,  FTPData Transfer Listener listener ) throws  Illegal State Exception ,  File Not Found Exception ,  IOException ,  FTPIllegal Reply Exception ,  FTPException ,  FTPData Transfer Exception ,  FTPAborted Exception {  Output Stream output Stream = null ; try { output Stream = new  File Output Stream ( local File , restart At > _ NUM ) ; } catch (  IOException e ) { throw new  FTPData Transfer Exception ( e ) ; } try { download ( remote File Name , output Stream , restart At , listener ) ; } catch (  Illegal State Exception e ) { throw e ; } catch (  IOException e ) { throw e ; } catch (  FTPIllegal Reply Exception e ) { throw e ; } catch (  FTPException e ) { throw e ; } catch (  FTPData Transfer Exception e ) { throw e ; } catch (  FTPAborted Exception e ) { throw e ; } finally { if ( output Stream != null ) { try { output Stream . close ( ) ; } catch (  Throwable t ) { ; } } } }
public static  Socket create Socket (  Inet Address address , int port ) throws  IOException {  Socket socket = null ; set Keystore ( ) ;  SSLSocket Factory f = (  SSLSocket Factory )  SSLSocket Factory . get Default ( ) ;  SSLSocket secure Socket = (  SSLSocket ) f . create Socket ( ) ; secure Socket . connect ( new  Inet Socket Address ( address , port ) ,  Sys Properties .  SOCKET_ CONNECT_ TIMEOUT ) ; secure Socket . set Enabled Protocols ( disable SSL ( secure Socket . get Enabled Protocols ( ) ) ) ; if (  Sys Properties .  ENABLE_ ANONYMOUS_ TLS ) {  String [ ] list = enable Anonymous ( secure Socket . get Enabled Cipher Suites ( ) , secure Socket . get Supported Cipher Suites ( ) ) ; secure Socket . set Enabled Cipher Suites ( list ) ; } socket = secure Socket ; return socket ; }
private  String format Node (  Binary Node <  T > node ) {  Binary Node <  T > n ;  String Builder response = new  String Builder ( _ STR ) ; if ( ( n = node . get Left Son ( ) ) != null ) { response . append ( format Node ( n ) ) ; } response . append ( node . to String ( ) ) ; if ( ( n = node . get Right Son ( ) ) != null ) { response . append ( format Node ( n ) ) ; } response . append ( _ STR ) ; return response . to String ( ) ; }
public static void unregister MBean (  Class < ? > mbean Interface ,  String mbean Name ) {  MBean Server mbs =  Management Factory . get Platform MBean Server ( ) ; try {  Object Name name = generate MBean Object Name ( mbean Interface . get Name ( ) , mbean Name ) ; if ( mbs . is Registered ( name ) ) { logger . info ( _ STR + name . to String ( ) ) ; mbs . unregister MBean ( name ) ; } else { logger . warn ( _ STR + name . to String ( ) ) ; } } catch (  Exception e ) { throw new  Server Runtime Exception ( _ STR + mbean Interface + _ STR + mbean Name , e ) ; } }
public static boolean add Last Cause ( @  Nullable  Throwable e , @  Nullable  Throwable cause ,  Ignite Logger log ) { if ( e == null || cause == null ) return _ BOOL ; for (  Throwable t = e ; t != null ; t = t . get Cause ( ) ) { if ( t == cause ) return _ BOOL ; if ( t . get Cause ( ) == null || t . get Cause ( ) == t ) { try { t . init Cause ( cause ) ; } catch (  Illegal State Exception ignored ) { error ( log , _ STR + _ STR + e , _ STR + e , cause ) ; } return _ BOOL ; } } return _ BOOL ; }
public  Json Array add (  String value ) { values . add ( value Of ( value ) ) ; return this ; }
public  Rhythm Overlay inflate Overlay (  String config String , @  Non Null  Map <  String ,  String > vars ) {  List <  String > config Strings =  Arrays . as List ( config String . split ( _ STR ) ) ; return inflate Overlay Internal ( config Strings , vars , _ NUM ) ; }
@  HLEUnimplemented @  HLEFunction ( nid = _ NUM , version = _ NUM ) public int sce Usb Cam Setup Video ( psp Usb Cam Setup Video Param usb Cam Setup Video Param ,  TPointer work Area , int work Area Size ) { this . work Area = work Area . get Address ( ) ; this . work Area Size = work Area Size ; resolution = usb Cam Setup Video Param . resolution ; frame Rate = usb Cam Setup Video Param . framerate ; white Balance = usb Cam Setup Video Param . wb ; saturation = usb Cam Setup Video Param . saturation ; brightness = usb Cam Setup Video Param . brightness ; contrast = usb Cam Setup Video Param . contrast ; sharpness = usb Cam Setup Video Param . sharpness ; image Effect Mode = usb Cam Setup Video Param . effectmode ; frame Size = usb Cam Setup Video Param . framesize ; ev Level = usb Cam Setup Video Param . evlevel ; if ( ! setup Video ( ) ) { log . warn (  String . format ( _ STR ) ) ; return  Sce Kernel Errors .  ERROR_ USBCAM_ NOT_ READY ; } return _ NUM ; }
public  List <  Statistics > load All Deep From Cursor (  Cursor cursor ) { int count = cursor . get Count ( ) ;  List <  Statistics > list = new  Array List <  Statistics > ( count ) ; if ( cursor . move To First ( ) ) { if ( identity Scope != null ) { identity Scope . lock ( ) ; identity Scope . reserve Room ( count ) ; } try { do { list . add ( load Current Deep ( cursor , _ BOOL ) ) ; } while ( cursor . move To Next ( ) ) ; } finally { if ( identity Scope != null ) { identity Scope . unlock ( ) ; } } } return list ; }
public static  Date parse Date ( final  String format , final  String date String ) throws  DSSException { try { final  Simple Date Format sdf = new  Simple Date Format ( format ) ; final  Date date = sdf . parse ( date String ) ; return date ; } catch (  Parse Exception e ) { throw new  DSSException ( e ) ; } }
public static  Document create DOM (  String str XML ) throws  Parser Configuration Exception ,  SAXException ,  IOException {  Document Builder Factory dbf =  Document Builder Factory . new Instance ( ) ; dbf . set Validating ( _ BOOL ) ; dbf . set Ignoring Comments ( _ BOOL ) ; dbf . set Ignoring Element Content Whitespace ( _ BOOL ) ; dbf . set Namespace Aware ( _ BOOL ) ; dbf . set Feature (  XMLConstants .  FEATURE_ SECURE_ PROCESSING , _ BOOL ) ; dbf . set Feature (  DISALLOW_ DOCTYPE_ DECL , _ BOOL ) ; dbf . set Feature (  EXTERNAL_ GENERAL_ ENTITIES , _ BOOL ) ; dbf . set Feature (  EXTERNAL_ PARAMETER_ ENTITIES , _ BOOL ) ; dbf . set Feature (  LOAD_ EXTERNAL_ DTD , _ BOOL ) ;  Document Builder db = null ; db = dbf . new Document Builder ( ) ; db . set Entity Resolver ( new  Null Resolver ( ) ) ; db . set Error Handler ( new  Saml Parser Error Handler ( ) ) ;  Input Source source XML = new  Input Source ( new  String Reader ( str XML ) ) ;  Document xml Doc = db . parse ( source XML ) ; return xml Doc ; }
public void close ( ) { while ( sub Channel . size ( ) > _ NUM ) { subs . add Sample ( sub Channel . poll ( ) ) ; } while ( pub Channel . size ( ) > _ NUM ) { pubs . add Sample ( pub Channel . poll ( ) ) ; } if ( subs . has Samples ( ) ) { start = subs . start ; end = subs . end ; } else { start = pubs . start ; end = pubs . end ; } end =  Math . min ( end , subs . end ) ; end =  Math . min ( end , pubs . end ) ; msg Bytes = pubs . msg Bytes + subs . msg Bytes ; io Bytes = pubs . io Bytes + subs . io Bytes ; msg Cnt = pubs . msg Cnt + subs . msg Cnt ; job Msg Cnt = pubs . job Msg Cnt + subs . job Msg Cnt ; }
void decode Attribute Body ( byte [ ] attribute Value , char offset , char length ) throws  Stun Exception { this . attribute Value = new byte [ length ] ;  System . arraycopy ( attribute Value , offset , this . attribute Value , _ NUM , length ) ; }
public static void copy Assets (  Context context ,  String assets Filename ,  File file ,  String mode ) throws  IOException ,  Interrupted Exception {  Asset Manager manager = context . get Assets ( ) ; final  Input Stream is = manager . open ( assets Filename ) ; copy File ( file , is , mode ) ; }
@  Override public boolean equals (  Object obj ) { if ( obj == null ) { return _ BOOL ; } if ( get Class ( ) != obj . get Class ( ) ) { return _ BOOL ; } final  Name For Request other = (  Name For Request ) obj ; if ( !  Objects . equals ( this . name , other . name ) ) { return _ BOOL ; } return _ BOOL ; }
@  Suppress Warnings ( _ STR ) static void murmurhash3_x64_128 ( byte [ ] key , int offset , int len , int seed ,  Long Pair out ) { long h1 = seed & _ NUM ; long h2 = seed & _ NUM ; final long c1 = _ NUM ; final long c2 = _ NUM ; int rounded End = offset + ( len & _ NUM ) ; for ( int i = offset ; i < rounded End ; i += _ NUM ) { long k1 = get Long Little Endian ( key , i ) ; long k2 = get Long Little Endian ( key , i + _ NUM ) ; k1 *= c1 ; k1 =  Long . rotate Left ( k1 , _ NUM ) ; k1 *= c2 ; h1 ^= k1 ; h1 =  Long . rotate Left ( h1 , _ NUM ) ; h1 += h2 ; h1 = h1 * _ NUM + _ NUM ; k2 *= c2 ; k2 =  Long . rotate Left ( k2 , _ NUM ) ; k2 *= c1 ; h2 ^= k2 ; h2 =  Long . rotate Left ( h2 , _ NUM ) ; h2 += h1 ; h2 = h2 * _ NUM + _ NUM ; } long k1 = _ NUM ; long k2 = _ NUM ; switch ( len & _ NUM ) { case _ NUM : k2 = ( key [ rounded End + _ NUM ] & _ NUM ) << _ NUM ; case _ NUM : k2 |= ( key [ rounded End + _ NUM ] & _ NUM ) << _ NUM ; case _ NUM : k2 |= ( key [ rounded End + _ NUM ] & _ NUM ) << _ NUM ; case _ NUM : k2 |= ( key [ rounded End + _ NUM ] & _ NUM ) << _ NUM ; case _ NUM : k2 |= ( key [ rounded End + _ NUM ] & _ NUM ) << _ NUM ; case _ NUM : k2 |= ( key [ rounded End + _ NUM ] & _ NUM ) << _ NUM ; case _ NUM : k2 |= ( key [ rounded End + _ NUM ] & _ NUM ) ; k2 *= c2 ; k2 =  Long . rotate Left ( k2 , _ NUM ) ; k2 *= c1 ; h2 ^= k2 ; case _ NUM : k1 = ( ( long ) key [ rounded End + _ NUM ] ) << _ NUM ; case _ NUM : k1 |= ( key [ rounded End + _ NUM ] & _ NUM ) << _ NUM ; case _ NUM : k1 |= ( key [ rounded End + _ NUM ] & _ NUM ) << _ NUM ; case _ NUM : k1 |= ( key [ rounded End + _ NUM ] & _ NUM ) << _ NUM ; case _ NUM : k1 |= ( key [ rounded End + _ NUM ] & _ NUM ) << _ NUM ; case _ NUM : k1 |= ( key [ rounded End + _ NUM ] & _ NUM ) << _ NUM ; case _ NUM : k1 |= ( key [ rounded End + _ NUM ] & _ NUM ) << _ NUM ; case _ NUM : k1 |= ( key [ rounded End ] & _ NUM ) ; k1 *= c1 ; k1 =  Long . rotate Left ( k1 , _ NUM ) ; k1 *= c2 ; h1 ^= k1 ; } h1 ^= len ; h2 ^= len ; h1 += h2 ; h2 += h1 ; h1 = fmix64 ( h1 ) ; h2 = fmix64 ( h2 ) ; h1 += h2 ; h2 += h1 ; out . val1 = h1 ; out . val2 = h2 ; }
public  Listenable Server Socket Channel (  Server Socket Channel channel ,  Executor event Executor ) throws  IOException { this ( channel , event Executor , new  Async Selector (  Selector . open ( ) ) ) ; owns Selector = _ BOOL ; }
public void add (  WXDom Object child , int index ) { if ( child == null || index < - _ NUM || s Destroy . get ( ) ) { return ; } if ( children == null ) { children = new  Array List < > ( ) ; } int count = children . size ( ) ; index = index >= count ? - _ NUM : index ; if ( index == - _ NUM ) { children . add ( child ) ; super . add Child At ( child , super . get Child Count ( ) ) ; } else { children . add ( index , child ) ; super . add Child At ( child , index ) ; } child . parent = this ; }
private void paint (  Sea Glass Painter p ,  Synth Context ctx ,  Graphics g , int x , int y , int w , int h ,  Affine Transform transform ) { if ( p != null ) { if ( g instanceof  Graphics2 D ) {  Graphics2 D gfx = (  Graphics2 D ) g ; if ( transform != null ) { gfx . transform ( transform ) ; } gfx . translate ( x , y ) ; p . paint ( gfx , ctx . get Component ( ) , w , h ) ; gfx . translate ( - x , - y ) ; if ( transform != null ) { try { gfx . transform ( transform . create Inverse ( ) ) ; } catch (  Noninvertible Transform Exception e ) { e . print Stack Trace ( ) ; } } } else {  Buffered Image img = new  Buffered Image ( w , h ,  Buffered Image .  TYPE_ INT_ ARGB ) ;  Graphics2 D gfx = img . create Graphics ( ) ; if ( transform != null ) { gfx . transform ( transform ) ; } p . paint ( gfx , ctx . get Component ( ) , w , h ) ; gfx . dispose ( ) ; g . draw Image ( img , x , y , null ) ; img = null ; } } }
public static long file Length (  File file ) { long length = _ NUM ; if ( file . is File ( ) ) length = file . length ( ) ; else if ( file . is Directory ( ) ) {  File [ ] files = file . list Files ( ) ; if ( files != null ) { for (  File f : files ) length += file Length ( f ) ; } } return length ; }
public static <  T extends  Throwable > void throw If Instance Of (  Throwable t ,  Class <  T > cls ) throws  T { if ( cls . is Instance ( t ) ) { throw cls . cast ( t ) ; } }
public static void write Var Long (  Output Stream out , long x ) throws  IOException { while ( ( x & ~ _ NUM ) != _ NUM ) { out . write ( ( byte ) ( _ NUM | ( x & _ NUM ) ) ) ; x >>>= _ NUM ; } out . write ( ( byte ) x ) ; }
protected void engine Update ( byte [ ] b , int off , int len ) throws  Signature Exception { message Digest . update ( b , off , len ) ; needs Reset = _ BOOL ; }
protected void process Initiators (  Export Group export Group ,  Collection <  Initiator > initiators ,  Collection <  String > port Names ,  Map <  String ,  URI > port Name To Initiator URI ,  Collection <  URI > host URIs ,  List Multimap <  String ,  String > compute Resource To Port Names ) { for (  Initiator initiator : initiators ) {  String normalized Name =  Initiator . normalize Port ( initiator . get Initiator Port ( ) ) ; port Names . add ( normalized Name ) ; port Name To Initiator URI . put ( normalized Name , initiator . get Id ( ) ) ; if ( host URIs != null ) { if ( !  Null Column Value Getter . is Null URI ( initiator . get Host ( ) ) && ! host URIs . contains ( initiator . get Host ( ) ) ) { host URIs . add ( initiator . get Host ( ) ) ; } } if ( compute Resource To Port Names != null ) {  String compute Resource Id ; if ( export Group != null && export Group . for Cluster ( ) ) { compute Resource Id = initiator . get Cluster Name ( ) ; } else {  URI host URI = initiator . get Host ( ) ; if ( host URI == null ) { host URI =  Null Column Value Getter . get Null URI ( ) ; } compute Resource Id = host URI . to String ( ) ; } compute Resource To Port Names . put ( compute Resource Id , normalized Name ) ; } } }
@  Override public  Enumeration <  URL > find Resources ( final  String name ) throws  IOException { if ( name == null ) { return null ; }  Array List <  URL > result = new  Array List <  URL > ( ) ; int n = _ NUM ; while ( _ BOOL ) {  URLHandler handler = get Handler ( n ++ ) ; if ( handler == null ) { break ; } handler . find Resources ( name , result ) ; } return  Collections . enumeration ( result ) ; }
public  Map Widget (  Bundle bundle ,  Context context ,  String root Map Folder , int initial Zoom Level ) { super ( context ) ; init Common Stuff ( context ) ;  String config Path =  Offline Map Util . get Config File Path ( root Map Folder ) ; try {  Map Config Parser config Parser = new  Map Config Parser ( root Map Folder ) ; config = config Parser . parse ( context , config Path ) ; tile Provider = new  Asset Tile Provider ( get Context ( ) , config ) ; int max Zoom Level =  Offline Map Util . get Max Zoom Level ( config . get Image Width ( ) , config . get Image Height ( ) ) ; int zoom Level = initial Zoom Level ; float scale = _ NUM ; if ( bundle != null ) { if ( bundle . contains Key ( _ STR ) ) zoom Level = bundle . get Int ( _ STR ) ; if ( bundle . contains Key ( _ STR ) ) scale = bundle . get Float ( _ STR ) ; } if ( zoom Level > max Zoom Level ) { grid = new  Grid ( this , config , tile Provider , max Zoom Level ) ; if ( scale == _ NUM ) { scale = ( float )  Math . pow ( _ NUM , zoom Level - max Zoom Level ) ; } } else { grid = new  Grid ( this , config , tile Provider , zoom Level ) ; } this . scale = scale ; grid . set Internal Scale ( scale ) ; init Position Pin ( ) ; restore Map Position ( bundle ) ; } catch (  SAXException e ) {  Log . e (  TAG , _ STR + e ) ; e . print Stack Trace ( ) ; } catch (  IOException e ) {  Log . e (  TAG , _ STR + e ) ; e . print Stack Trace ( ) ; } }
default  B with Default (  String key , long value ) { return with Default ( key ,  Long . to String ( value ) ) ; }
public void to Char Array ( char [ ] b , int offset , int length ) { if ( buffer . length == _ NUM ) return ; int t =  Math . min ( length , len ) ; int to End =  Math . min ( t , buffer . length - start ) ;  System . arraycopy ( buffer , start , b , offset , to End ) ; if ( to End < t )  System . arraycopy ( buffer , _ NUM , b , offset + to End , t - to End ) ; }
public void add Bonded Devices ( final  Set <  Bluetooth Device > devices ) { final  List <  Extended Bluetooth Device > bonded Devices = m List Bonded Values ; for (  Bluetooth Device device : devices ) { bonded Devices . add ( new  Extended Bluetooth Device ( device ) ) ; } notify Data Set Changed ( ) ; }
protected  String build Image (  String repository ,  File tar , final  Progress Monitor progress Monitor ,  Auth Configs auth Configs ) throws  IOException ,  Interrupted Exception { return do Build Image ( repository , tar , progress Monitor , docker Daemon Uri , auth Configs ) ; }
private void draw Arrows ( final  Graphics2 D g2d , final int x , final int y , final int width , final int height , final  Enum Set <  Direction > directions , final  Color line Color ) { int arrow Height = _ NUM + _ NUM * ( height / _ NUM - _ NUM ) ; int arrow Width = _ NUM + ( width / _ NUM - _ NUM ) ; if ( directions . contains (  Direction .  LEFT ) ) { g2d . set Color (  Color .  RED ) ; g2d . fill Polygon ( new int [ ] { x + _ NUM , x - arrow Width , x + _ NUM } , new int [ ] { y + ( height / _ NUM ) - ( arrow Height / _ NUM ) , y + ( height / _ NUM ) , y + ( height / _ NUM ) + ( arrow Height / _ NUM ) } , _ NUM ) ; g2d . set Color ( line Color ) ; g2d . draw Polyline ( new int [ ] { x , x - arrow Width , x } , new int [ ] { y + ( height / _ NUM ) - ( arrow Height / _ NUM ) , y + ( height / _ NUM ) , y + ( height / _ NUM ) + ( arrow Height / _ NUM ) } , _ NUM ) ; } if ( directions . contains (  Direction .  RIGHT ) ) { g2d . set Color (  Color .  RED ) ; g2d . fill Polygon ( new int [ ] { x + width , x + width + arrow Width , x + width } , new int [ ] { y + ( height / _ NUM ) - ( arrow Height / _ NUM ) , y + ( height / _ NUM ) , y + ( height / _ NUM ) + ( arrow Height / _ NUM ) } , _ NUM ) ; g2d . set Color ( line Color ) ; g2d . draw Polyline ( new int [ ] { x + width , x + width + arrow Width , x + width } , new int [ ] { y + ( height / _ NUM ) - ( arrow Height / _ NUM ) , y + ( height / _ NUM ) , y + ( height / _ NUM ) + ( arrow Height / _ NUM ) } , _ NUM ) ; } if ( directions . contains (  Direction .  UP ) ) { g2d . set Color (  Color .  RED ) ; g2d . fill Polygon ( new int [ ] { x + ( width / _ NUM ) - ( arrow Height / _ NUM ) , x + ( width / _ NUM ) , x + ( width / _ NUM ) + ( arrow Height / _ NUM ) } , new int [ ] { y + _ NUM , y - arrow Width , y + _ NUM } , _ NUM ) ; g2d . set Color ( line Color ) ; g2d . draw Polyline ( new int [ ] { x + ( width / _ NUM ) - ( arrow Height / _ NUM ) , x + ( width / _ NUM ) , x + ( width / _ NUM ) + ( arrow Height / _ NUM ) } , new int [ ] { y , y - arrow Width , y } , _ NUM ) ; } if ( directions . contains (  Direction .  DOWN ) ) { g2d . set Color (  Color .  RED ) ; g2d . fill Polygon ( new int [ ] { x + ( width / _ NUM ) - ( arrow Height / _ NUM ) , x + ( width / _ NUM ) , x + ( width / _ NUM ) + ( arrow Height / _ NUM ) } , new int [ ] { y + height , y + height + arrow Width , y + height } , _ NUM ) ; g2d . set Color ( line Color ) ; g2d . draw Polyline ( new int [ ] { x + ( width / _ NUM ) - ( arrow Height / _ NUM ) , x + ( width / _ NUM ) , x + ( width / _ NUM ) + ( arrow Height / _ NUM ) } , new int [ ] { y + height , y + height + arrow Width , y + height } , _ NUM ) ; } }
@  Override public boolean is Component Enabled (  Resolve Info resolve Info ) { if ( resolve Info != null && resolve Info . service Info != null && !  Text Utils . is Empty ( resolve Info . service Info . package Name ) ) { if ( m Permitted Package Names == null || is System App ( resolve Info . service Info . application Info ) ) { return _ BOOL ; } else { return m Permitted Package Names . contains ( resolve Info . service Info . package Name ) ; } } return _ BOOL ; }
private static  Pair <  String ,  String > post Indexed LSL ( final long offset , final  ITranslation Environment environment , final  List <  Reil Instruction > instructions , final  String register Node Value1 , final  String register Node Value2 , final  String immediate Node Value ) { final  String address = environment . get Next Variable String ( ) ; final  String tmp Var1 = environment . get Next Variable String ( ) ; final  String tmp Var2 = environment . get Next Variable String ( ) ; final  String index = environment . get Next Variable String ( ) ; long base Offset = offset ; instructions . add (  Reil Helpers . create Str ( base Offset ++ , dw , register Node Value1 , dw , address ) ) ; instructions . add (  Reil Helpers . create Bsh ( base Offset ++ , dw , register Node Value2 , dw , immediate Node Value , qw , tmp Var1 ) ) ; instructions . add (  Reil Helpers . create And ( base Offset ++ , qw , tmp Var1 , dw , d Word Bit Mask , dw , index ) ) ; instructions . add (  Reil Helpers . create Add ( base Offset ++ , dw , register Node Value1 , dw , index , dw , tmp Var2 ) ) ; instructions . add (  Reil Helpers . create And ( base Offset ++ , dw , tmp Var2 , dw , d Word Bit Mask , dw , register Node Value1 ) ) ; return new  Pair <  String ,  String > ( address , register Node Value1 ) ; }
public int add Ref (  Object ref ) { if ( _refs == null ) _refs = new  Array List ( ) ; _refs . add ( ref ) ; return _refs . size ( ) - _ NUM ; }
private  Resource Type (  Builder builder ) { this . uuid = builder . uuid ; this . name = builder . name ; this . description = builder . description ; this . patterns =  Collections . unmodifiable Set ( builder . patterns ) ; this . actions =  Collections . unmodifiable Map ( builder . actions ) ; this . created By = builder . created By ; this . creation Date = builder . creation Date ; this . last Modified By = builder . last Modified By ; this . last Modified Date = builder . last Modified Date ; }
public  Head Rule Map (  Input Stream in ) {  Buffered Reader reader =  IOUtils . create Buffered Reader ( in ) ;  String line , p Tag , dir , rule ;  String [ ] tmp ; try { while ( ( line = reader . read Line ( ) ) != null ) { tmp =  P_ COLUMN . split ( line ) ; p Tag = tmp [ _ NUM ] ; dir = tmp [ _ NUM ] ; rule = tmp [ _ NUM ] ; put ( p Tag , new  Head Rule ( dir , rule ) ) ; } } catch (  IOException e ) { e . print Stack Trace ( ) ; } }
public void test One One ( ) { byte a Bytes [ ] = { _ NUM } ; byte b Bytes [ ] = { _ NUM } ; int a Sign = _ NUM ; int b Sign = _ NUM ; byte r Bytes [ ] = { _ NUM } ;  Big Integer a Number = new  Big Integer ( a Sign , a Bytes ) ;  Big Integer b Number = new  Big Integer ( b Sign , b Bytes ) ;  Big Integer result = a Number . or ( b Number ) ; byte res Bytes [ ] = new byte [ r Bytes . length ] ; res Bytes = result . to Byte Array ( ) ; for ( int i = _ NUM ; i < res Bytes . length ; i ++ ) { assert True ( res Bytes [ i ] == r Bytes [ i ] ) ; } assert Equals ( _ STR , _ NUM , result . signum ( ) ) ; }
public <  T >  Future <  T > submit (  Callable <  T > task ) { return executor . submit ( task ) ; }
public void test Subtract Math Context Diff Scale Neg Pos ( ) {  String a = _ STR ; int a Scale = - _ NUM ;  String b = _ STR ; int b Scale = _ NUM ;  String c = _ STR ; int c Scale = - _ NUM ;  Big Decimal a Number = new  Big Decimal ( new  Big Integer ( a ) , a Scale ) ;  Big Decimal b Number = new  Big Decimal ( new  Big Integer ( b ) , b Scale ) ;  Math Context mc = new  Math Context ( _ NUM ,  Rounding Mode .  HALF_ DOWN ) ;  Big Decimal result = a Number . subtract ( b Number , mc ) ; assert Equals ( _ STR , c , result . to String ( ) ) ; assert Equals ( _ STR , c Scale , result . scale ( ) ) ; }
protected abstract  Big Decimal decode ( final  Field Descriptor field Descriptor , final byte [ ] field Data ) ;
int escape ( ) throws  RESyntax Exception { if ( pattern . char At ( idx ) != _ STR ) { internal Error ( ) ; } if ( idx + _ NUM == len ) { syntax Error ( _ STR ) ; } idx += _ NUM ; char escape Char = pattern . char At ( idx - _ NUM ) ; switch ( escape Char ) { case  RE .  E_ BOUND : case  RE .  E_ NBOUND : return  ESC_ COMPLEX ; case  RE .  E_ ALNUM : case  RE .  E_ NALNUM : case  RE .  E_ SPACE : case  RE .  E_ NSPACE : case  RE .  E_ DIGIT : case  RE .  E_ NDIGIT : return  ESC_ CLASS ; case _ STR : case _ STR : { int hex Digits = ( escape Char == _ STR ? _ NUM : _ NUM ) ; int val = _ NUM ; for ( ; idx < len && hex Digits -- > _ NUM ; idx ++ ) { char c = pattern . char At ( idx ) ; if ( c >= _ STR && c <= _ STR ) { val = ( val << _ NUM ) + c - _ STR ; } else { c =  Character . to Lower Case ( c ) ; if ( c >= _ STR && c <= _ STR ) { val = ( val << _ NUM ) + ( c - _ STR ) + _ NUM ; } else { syntax Error ( _ STR + hex Digits + _ STR + escape Char ) ; } } } return val ; } case _ STR : return _ STR ; case _ STR : return _ STR ; case _ STR : return _ STR ; case _ STR : return _ STR ; case _ STR : case _ STR : case _ STR : case _ STR : case _ STR : case _ STR : case _ STR : case _ STR : case _ STR : case _ STR : if ( ( idx < len &&  Character . is Digit ( pattern . char At ( idx ) ) ) || escape Char == _ STR ) { int val = escape Char - _ STR ; if ( idx < len &&  Character . is Digit ( pattern . char At ( idx ) ) ) { val = ( ( val << _ NUM ) + ( pattern . char At ( idx ++ ) - _ STR ) ) ; if ( idx < len &&  Character . is Digit ( pattern . char At ( idx ) ) ) { val = ( ( val << _ NUM ) + ( pattern . char At ( idx ++ ) - _ STR ) ) ; } } return val ; } return  ESC_ BACKREF ; default : return escape Char ; } }
public static  String empty If Equal (  String string ,  String test ) { return test != null && test . equals ( string ) ?  EMPTY : string ; }
public boolean is Login Timeout ( long last Callback Sent , long timeout ) { long now = current Time Millis ( ) ; long timeout Val = last Callback Sent + ( timeout - _ NUM ) * _ NUM ; return ( timeout Val < now ) ; }
public  Point translate Java2 DTo Screen (  Point2 D java2 DPoint ) {  Insets insets = get Insets ( ) ; int x = ( int ) ( java2 DPoint . get X ( ) * this . scale X + insets . left ) ; int y = ( int ) ( java2 DPoint . get Y ( ) * this . scale Y + insets . top ) ; return new  Point ( x , y ) ; }
public  String scan (  String tables To Find ,  Hashtable <  String ,  String > template Options ,  Writer writer ) throws  Replicator Exception ,  Interrupted Exception ,  SQLException ,  IOException { int tables Rendered = _ NUM ;  Array List <  Table > tables = null ; if ( tables To Find == null ) { tables = db . get Tables ( db Name , _ BOOL , _ BOOL ) ; } else { tables = new  Array List <  Table > ( ) ;  String [ ] table Names = tables To Find . split ( _ STR ) ; for (  String table Name : table Names ) {  Table table = db . find Table ( db Name , table Name , _ BOOL ) ; if ( table != null ) tables . add ( table ) ; } }  Velocity Context context = new  Velocity Context ( ) ; for (  String option : template Options . key Set ( ) ) { context . put ( option , template Options . get ( option ) ) ; } context . put ( _ STR , db Name ) ; context . put ( _ STR , user ) ; context . put ( _ STR , url ) ; context . put ( _ STR , db ) ; context . put ( _ STR , rename Definitions ) ; context . put ( _ STR ,  Enum To String Filter . class ) ; context . put ( _ STR , new java . util .  Date ( ) ) ; context . put ( _ STR , reserved Words Oracle ) ; context . put ( _ STR , reserved Words My SQL ) ; context . put ( _ STR , velocity ) ; int size = tables . size ( ) ; for ( int i = _ NUM ; i < size ; i ++ ) {  Table table = tables . get ( i ) ; if ( i == _ NUM ) context . put ( _ STR , _ BOOL ) ; else context . put ( _ STR , _ BOOL ) ; if ( i >= size - _ NUM ) context . put ( _ STR , _ BOOL ) ; else context . put ( _ STR , _ BOOL ) ; rename ( table ) ; merge ( context , table , writer ) ; tables Rendered ++ ; } if ( tables Rendered == _ NUM ) { merge ( context , null , writer ) ; } return writer . to String ( ) ; }
private void clear Old Traffic ( ) {  List <  Air Map Traffic > old All Traffic = new  Array List < > ( ) ; for (  Air Map Traffic traffic : all Traffic ) { if ( traffic Expired ( traffic ) ) { old All Traffic . add ( traffic ) ; all Traffic . remove ( traffic ) ; } } notify Removed ( old All Traffic ) ; }
static void stop Refresh Timer ( ) { try { if ( refresh Timer != null && mbean Server != null ) { mbean Server . unregister MBean ( refresh Timer Object Name ) ; refresh Timer . stop ( ) ; } } catch (  JMException e ) { log Stack Trace (  Level .  WARN , e ) ; } catch (  JMRuntime Exception e ) { log Stack Trace (  Level .  WARN , e ) ; } catch (  Exception e ) { log Stack Trace (  Level .  DEBUG , e , _ STR ) ; } }
public static float compute Contrast ( int background , int foreground ) {  Pair <  Integer ,  Integer > key = new  Pair < > ( background , foreground ) ; if ( contrast Cache == null ) { contrast Cache = new  Lru Cache < > ( _ NUM ) ; } else {  Float contrast = contrast Cache . get ( key ) ; if ( contrast != null ) { return contrast ; } } float bg R =  Color . red ( background ) / _ NUM ; float bg G =  Color . green ( background ) / _ NUM ; float bg B =  Color . blue ( background ) / _ NUM ; bg R = ( bg R < _ NUM ) ? bg R / _ NUM : ( float )  Math . pow ( ( bg R + _ NUM ) / _ NUM , _ NUM ) ; bg G = ( bg G < _ NUM ) ? bg G / _ NUM : ( float )  Math . pow ( ( bg G + _ NUM ) / _ NUM , _ NUM ) ; bg B = ( bg B < _ NUM ) ? bg B / _ NUM : ( float )  Math . pow ( ( bg B + _ NUM ) / _ NUM , _ NUM ) ; float bg L = _ NUM * bg R + _ NUM * bg G + _ NUM * bg B ; float fg R =  Color . red ( foreground ) / _ NUM ; float fg G =  Color . green ( foreground ) / _ NUM ; float fg B =  Color . blue ( foreground ) / _ NUM ; fg R = ( fg R < _ NUM ) ? fg R / _ NUM : ( float )  Math . pow ( ( fg R + _ NUM ) / _ NUM , _ NUM ) ; fg G = ( fg G < _ NUM ) ? fg G / _ NUM : ( float )  Math . pow ( ( fg G + _ NUM ) / _ NUM , _ NUM ) ; fg B = ( fg B < _ NUM ) ? fg B / _ NUM : ( float )  Math . pow ( ( fg B + _ NUM ) / _ NUM , _ NUM ) ; float fg L = _ NUM * fg R + _ NUM * fg G + _ NUM * fg B ; float value =  Math . abs ( ( fg L + _ NUM ) / ( bg L + _ NUM ) ) ; contrast Cache . put ( key , value ) ; return value ; }
private  Menu Item add Internal ( int group , int id , int category Order ,  Char Sequence title ) { final  Menu Item Impl item = create New Menu Item ( group , id , category Order , title ) ; m Items . add ( find Insert Index ( m Items , category Order ) , item ) ; on Items Changed ( _ BOOL ) ; return item ; }
public void test Sub List And Non Structural Changes ( ) {  Copy On Write Array List <  String > list = new  Copy On Write Array List <  String > ( ) ; list . add All (  Arrays . as List ( _ STR , _ STR , _ STR , _ STR , _ STR ) ) ;  List <  String > bcd = list . sub List ( _ NUM , _ NUM ) ; list . set ( _ NUM , _ STR ) ; try { bcd . get ( _ NUM ) ; fail ( ) ; } catch (  Concurrent Modification Exception expected ) { } }
public boolean check Signals (  Jmri JFrame frame ,  Layout Editor panel ) { if ( panel == null ) { log . error ( _ STR ) ; return _ BOOL ; } if ( initialization Needed ) { initialize Blocks ( ) ; }  Block e Block = get Entry Block ( ) ;  Array List <  Entry Point > ep List = get List Of Forward Block Entry Points ( e Block ) ; if ( ep List . size ( ) > _ NUM ) { } return _ BOOL ; }
public final void close Fallback Output Stream ( ) throws  Data Fallback Exception { if ( output != null ) { if (  LOG . is Debug Enabled ( ) )  LOG . debug ( _ STR + data File . get Name ( ) ) ; try { output . close ( ) ; } catch (  IOException e ) { throw new  Data Fallback Exception ( e . get Message ( ) ) ; } finally { output = null ; } } }
@  PUT @  Path ( _ STR ) @  Produces ( {  Media Type .  APPLICATION_ XML ,  Media Type .  APPLICATION_ JSON } ) @  Check Permission ( roles = {  Role .  TENANT_ ADMIN } ) public  Ip Interface Rest Rep update Ip Interface ( @  Path Param ( _ STR )  URI id ,  Ip Interface Update Param update Param ) throws  Database Exception {  Ip Interface ip Interface = query Object (  Ip Interface . class , id , _ BOOL ) ; _host Service . validate Ip Interface Data ( update Param , ip Interface ) ; _host Service . populate Ip Interface ( update Param , ip Interface ) ; _db Client . persist Object ( ip Interface ) ; audit Op (  Operation Type Enum .  UPDATE_ HOST_ IPINTERFACE , _ BOOL , null , ip Interface . audit Parameters ( ) ) ; return map ( query Object (  Ip Interface . class , id , _ BOOL ) ) ; }
protected  IContent Proposal [ ] content Proposals From (  List <  IEdit Proposal > edit Proposals ) {  IContent Proposal [ ] content Proposals = new  IContent Proposal [ edit Proposals . size ( ) ] ; for ( int i = _ NUM ; i < edit Proposals . size ( ) ; i ++ ) { content Proposals [ i ] = new  Edit Proposal Wrapper ( edit Proposals . get ( i ) ) ; } return content Proposals ; }
public  Extension Query (  String extension Point Name ,  String attribute Name ) {  Preconditions . check Argument ( extension Point Name . contains ( _ STR ) , _ STR ) ; this . plugin Id = null ; this . extension Point Name = extension Point Name ; this . attribute Name = attribute Name ; }
public static  String apply Ptb Format (  String image ,  String type ) {  String result = null ; if ( type . equals (  Punct Description .  OPEN_ BRACKET ) ) { if ( image . equals ( _ STR ) ) { result =  LRB ; } else if ( image . equals ( _ STR ) ) { result =  LSB ; } else if ( image . equals ( _ STR ) ) { result =  LCB ; } } else if ( type . equals (  Punct Description .  CLOSE_ BRACKET ) ) { if ( image . equals ( _ STR ) ) { result =  RRB ; } else if ( image . equals ( _ STR ) ) { result =  RSB ; } else if ( image . equals ( _ STR ) ) { result =  RCB ; } } else if ( type . equals (  Punct Description .  OPEN_ PUNCT ) ) { result = _ STR ; } else if ( type . equals (  Punct Description .  CLOSE_ PUNCT ) ) { result = _ STR ; } else if ( image . contains ( _ STR ) ) { result = image . replace ( _ STR , _ STR ) ; } else if ( image . contains ( _ STR ) ) { result = image . replace ( _ STR , _ STR ) ; } return result ; }
protected  String use Kernel (  Instances data ) throws  Exception {  Kernel kernel = null ;  String Buffer text = new  String Buffer ( ) ; try { kernel =  Kernel . make Copy ( m_ Kernel ) ; } catch (  Exception e ) { e . print Stack Trace ( ) ; fail ( _ STR + e ) ; } kernel . build Kernel ( data ) ; for ( int n = _ NUM ; n < data . num Instances ( ) ; n ++ ) { for ( int i = n ; i < data . num Instances ( ) ; i ++ ) { text . append ( ( n + _ NUM ) + _ STR + ( i + _ NUM ) + _ STR + kernel . eval ( n , i , data . instance ( i ) ) + _ STR ) ; } } return text . to String ( ) ; }
protected double compute Random Projection ( int rp Index , int class Index ,  Instance instance ) { double sum = _ NUM ; for ( int i = _ NUM ; i < instance . num Values ( ) ; i ++ ) { int index = instance . index ( i ) ; if ( index != class Index ) { double value = instance . value Sparse ( i ) ; if ( !  Utils . is Missing Value ( value ) ) { sum += m_rmatrix [ rp Index ] [ index ] * value ; } } } return sum ; }
public static boolean clip Line (  Line2 D line ,  Rectangle2 D rect ) { double x1 = line . get X1 ( ) ; double y1 = line . get Y1 ( ) ; double x2 = line . get X2 ( ) ; double y2 = line . get Y2 ( ) ; double min X = rect . get Min X ( ) ; double max X = rect . get Max X ( ) ; double min Y = rect . get Min Y ( ) ; double max Y = rect . get Max Y ( ) ; int f1 = rect . outcode ( x1 , y1 ) ; int f2 = rect . outcode ( x2 , y2 ) ; while ( ( f1 | f2 ) != _ NUM ) { if ( ( f1 & f2 ) != _ NUM ) { return _ BOOL ; } double dx = ( x2 - x1 ) ; double dy = ( y2 - y1 ) ; if ( f1 != _ NUM ) { if ( ( f1 &  Rectangle2 D .  OUT_ LEFT ) ==  Rectangle2 D .  OUT_ LEFT && dx != _ NUM ) { y1 = y1 + ( min X - x1 ) * dy / dx ; x1 = min X ; } else if ( ( f1 &  Rectangle2 D .  OUT_ RIGHT ) ==  Rectangle2 D .  OUT_ RIGHT && dx != _ NUM ) { y1 = y1 + ( max X - x1 ) * dy / dx ; x1 = max X ; } else if ( ( f1 &  Rectangle2 D .  OUT_ BOTTOM ) ==  Rectangle2 D .  OUT_ BOTTOM && dy != _ NUM ) { x1 = x1 + ( max Y - y1 ) * dx / dy ; y1 = max Y ; } else if ( ( f1 &  Rectangle2 D .  OUT_ TOP ) ==  Rectangle2 D .  OUT_ TOP && dy != _ NUM ) { x1 = x1 + ( min Y - y1 ) * dx / dy ; y1 = min Y ; } f1 = rect . outcode ( x1 , y1 ) ; } else if ( f2 != _ NUM ) { if ( ( f2 &  Rectangle2 D .  OUT_ LEFT ) ==  Rectangle2 D .  OUT_ LEFT && dx != _ NUM ) { y2 = y2 + ( min X - x2 ) * dy / dx ; x2 = min X ; } else if ( ( f2 &  Rectangle2 D .  OUT_ RIGHT ) ==  Rectangle2 D .  OUT_ RIGHT && dx != _ NUM ) { y2 = y2 + ( max X - x2 ) * dy / dx ; x2 = max X ; } else if ( ( f2 &  Rectangle2 D .  OUT_ BOTTOM ) ==  Rectangle2 D .  OUT_ BOTTOM && dy != _ NUM ) { x2 = x2 + ( max Y - y2 ) * dx / dy ; y2 = max Y ; } else if ( ( f2 &  Rectangle2 D .  OUT_ TOP ) ==  Rectangle2 D .  OUT_ TOP && dy != _ NUM ) { x2 = x2 + ( min Y - y2 ) * dx / dy ; y2 = min Y ; } f2 = rect . outcode ( x2 , y2 ) ; } } line . set Line ( x1 , y1 , x2 , y2 ) ; return _ BOOL ; }
public <  V extends  Vertex >  List <  Set <  V > > components (  Graph graph ) {  Adjacency Matrix <  V > y = new  Adjacency Matrix <  V > ( graph ) ;  List <  TInt Array List > comps = extract Components ( y ) ;  List <  Set <  V > > components = new  Array List <  Set <  V > > ( comps . size ( ) ) ; for (  TInt Array List comp : comps ) {  Set <  V > component = new  Hash Set <  V > ( ) ; for ( int i = _ NUM ; i < comp . size ( ) ; i ++ ) { component . add ( y . get Vertex ( comp . get ( i ) ) ) ; } components . add ( component ) ; } return components ; }
private int tailing Non Newline (  String str , int off , int len ) { for ( int cnt = _ NUM ; cnt < len ; cnt ++ ) { final int pos = off + ( len - _ NUM ) - cnt ; if ( str . char At ( pos ) ==  Output Stream Logger .  UNIX_ NEWLINE ) { return cnt ; } } return len ; }
public  String to String ( ) {  String Builder sb = new  String Builder ( super . to String ( ) ) ; sb . append ( _ STR ) ; if ( intervals != null ) { for (  IInterval i : intervals ) { sb . append ( i ) ; sb . append ( _ STR ) ; } } sb . append ( _ STR ) ; return sb . to String ( ) ; }
public void add Layout Callback (  Layout Callback callback ) { if ( callback == null ) { throw new  Null Pointer Exception ( ) ; } if ( callback List == null ) { callback List = new  Array List <  Layout Callback > ( _ NUM ) ; } callback List . add ( callback ) ; grid = null ; }
public static <  K ,  V >  Multi Value Map <  K ,  V > unmodifiable Multi Value Map (  Multi Value Map < ? extends  K , ? extends  V > map ) {  Assert . not Null ( map , _ STR ) ;  Map <  K ,  List <  V > > result = new  Linked Hash Map <  K ,  List <  V > > ( map . size ( ) ) ; for (  Map .  Entry < ? extends  K , ? extends  List < ? extends  V > > entry : map . entry Set ( ) ) {  List <  V > values =  Collections . unmodifiable List ( entry . get Value ( ) ) ; result . put ( entry . get Key ( ) , values ) ; }  Map <  K ,  List <  V > > unmodifiable Map =  Collections . unmodifiable Map ( result ) ; return to Multi Value Map ( unmodifiable Map ) ; }
protected void sleep ( final int wait Time ) throws  Interrupted Exception {  Thread . sleep ( wait Time ) ; }
public static void mute Current Out And Err Stream ( ) { if ( already Muted ) { return ; }  Byte Array Output Stream byte Stream = new  Byte Array Output Stream ( ) ;  Print Stream out Stream = new  Print Stream ( byte Stream ) ; latest Out =  System . out ; latest Err =  System . err ;  System . set Out ( out Stream ) ;  System . set Err ( out Stream ) ; already Muted = _ BOOL ; }
public static  Big Integer [ ] convert List To Array (  List <  Big Integer > list ) {  Big Integer [ ] result = new  Big Integer [ list . size ( ) ] ; for ( int i = _ NUM ; i < list . size ( ) ; i ++ ) { result [ i ] = list . get ( i ) ; } return result ; }
private int measure Height ( int measure Spec ) { int result ; int spec Mode =  Measure Spec . get Mode ( measure Spec ) ; int spec Size =  Measure Spec . get Size ( measure Spec ) ; m Ascent = ( int ) m Text Paint . ascent ( ) ; if ( spec Mode ==  Measure Spec .  EXACTLY ) { result = spec Size ; } else { result = ( int ) ( - m Ascent + m Text Paint . descent ( ) ) + get Padding Top ( ) + get Padding Bottom ( ) ; if ( spec Mode ==  Measure Spec .  AT_ MOST ) { result =  Math . min ( result , spec Size ) ; } } return result ; }
public void test Case20 ( ) { byte a Bytes [ ] = { _ NUM } ; byte b Bytes [ ] = { _ NUM } ; byte r Bytes [ ] = { _ NUM } ; int a Sign = _ NUM ; int b Sign = _ NUM ;  Big Integer a Number = new  Big Integer ( a Sign , a Bytes ) ;  Big Integer b Number = new  Big Integer ( b Sign , b Bytes ) ;  Big Integer result = a Number . subtract ( b Number ) ; byte res Bytes [ ] = new byte [ r Bytes . length ] ; res Bytes = result . to Byte Array ( ) ; for ( int i = _ NUM ; i < res Bytes . length ; i ++ ) { assert True ( res Bytes [ i ] == r Bytes [ i ] ) ; } assert Equals ( _ NUM , result . signum ( ) ) ; }
protected <  T >  T wait For Property Value (  String document Self Link ,  Class <  T > type ,  String prop Name ,  Object prop Value ) throws  Throwable { return wait For Property Value ( document Self Link , type , prop Name ,  Arrays . as List ( prop Value ) , _ BOOL , wait For Stage Change Count ( ) ) ; }
@  Override public  Array List <  Array List <  Region > > define Regions (  Array List <  Chart Set > data ) {  Array List <  Array List <  Region > > result = new  Array List <  Array List <  Region > > ( ) ;  Array List <  Region > region Set ; float x ; float y ; for (  Chart Set set : data ) { region Set = new  Array List <  Region > ( set . size ( ) ) ; for (  Chart Entry e : set . get Entries ( ) ) { x = e . get X ( ) ; y = e . get Y ( ) ; region Set . add ( new  Region ( ( int ) ( x - s Region Radius ) , ( int ) ( y - s Region Radius ) , ( int ) ( x + s Region Radius ) , ( int ) ( y + s Region Radius ) ) ) ; } result . add ( region Set ) ; } return result ; }
void insert Function3 (  Byte Buffer bb ) { int base Sec = ( int ) ( window Id > > _ NUM ) ; bb . put Int ( base Sec ) ; short win Id = ( short ) ( window Id & _ NUM ) ; bb . put Short ( win Id ) ;  Integer oper Id = operator Id ; for ( int i = _ NUM ; i < _ NUM ; i ++ ) { byte num = ( byte ) ( oper Id > > _ NUM * ( _ NUM - i ) ) ; bb . put ( num ) ; } for ( int i = _ NUM ; i < _ NUM ; i ++ ) { byte num = ( byte ) ( tuple Id > > _ NUM * ( _ NUM - i ) ) ; bb . put ( num ) ; } }
static float distance (  Rectangle a ,  Rectangle b ) { float ax1 , ax2 , ay1 , ay2 ; float bx1 , bx2 , by1 , by2 ; ax1 = a . x ; ax2 = a . x + a . width ; ay1 = a . y ; ay2 = a . y + a . height ; bx1 = b . x ; bx2 = b . x + b . width ; by1 = b . y ; by2 = b . y + b . height ; float xdiff11 =  Math . abs ( ax1 - bx1 ) ; float xdiff12 =  Math . abs ( ax1 - bx2 ) ; float xdiff21 =  Math . abs ( ax2 - bx1 ) ; float xdiff22 =  Math . abs ( ax2 - bx2 ) ; float ydiff11 =  Math . abs ( ay1 - by1 ) ; float ydiff12 =  Math . abs ( ay1 - by2 ) ; float ydiff21 =  Math . abs ( ay2 - by1 ) ; float ydiff22 =  Math . abs ( ay2 - by2 ) ; float xmin =  Math . min (  Math . min ( xdiff11 , xdiff12 ) ,  Math . min ( xdiff21 , xdiff22 ) ) ; float ymin =  Math . min (  Math . min ( ydiff11 , ydiff12 ) ,  Math . min ( ydiff21 , ydiff22 ) ) ; boolean y Overlap = ay1 <= by2 && by1 <= ay2 ; boolean x Overlap = ax1 <= bx2 && bx1 <= ax2 ; float x Return = ( y Overlap ) ? xmin : ( float )  Math . hypot ( xmin , ymin ) ; float y Return = ( x Overlap ) ? ymin : ( float )  Math . hypot ( xmin , ymin ) ; return  Math . min ( x Return , y Return ) ; }
public boolean next Tile ( ) throws  Model Control Exception { boolean moved To Row = super . next Tile ( ) ; if ( moved To Row ) { cur Tile = get Tile Index ( ) ; set Display Field Value (  TXT_ INDEX ,  Integer . to String ( cur Tile ) ) ; set Display Field Value (  TXT_ BUTTON , buttons [ cur Tile ] ) ; set Display Field Value (  TXT_ CLASS , cur Tile == _ NUM ? _ STR : _ STR ) ; } return moved To Row ; }
private void toggle Stealth ( ) { initialize ( ) ; int total_bv , known_bv , known_range , known_count , trigger_range ; int new_stealth ; for (  Entity check_ent : game . get Entities Vector ( ) ) { if ( ( check_ent . get Owner Id ( ) == local Player Number ) && ( check_ent instanceof  Mech ) ) { if ( check_ent . has Stealth ( ) && ( check_ent . get Position ( ) != null ) ) { for (  Mounted m Equip : check_ent . get Misc ( ) ) {  Misc Type mtype = (  Misc Type ) m Equip . get Type ( ) ; if ( mtype . has Flag (  Misc Type .  F_ STEALTH ) ) { trigger_range = _ NUM +  Compute . random Int ( _ NUM ) ; if ( check_ent . heat > trigger_range ) { new_stealth = _ NUM ; } else { total_bv = _ NUM ; known_bv = _ NUM ; known_range = _ NUM ; known_count = _ NUM ; for (  Entity test_ent : game . get Entities Vector ( ) ) { if ( check_ent . is Enemy Of ( test_ent ) ) { total_bv += test_ent . calculate Battle Value ( ) ; if ( test_ent . is Visible To Enemy ( ) ) { known_count ++ ; known_bv += test_ent . calculate Battle Value ( ) ; known_range +=  Compute . effective Distance ( game , check_ent , test_ent ) ; } } } if ( ( known_count == _ NUM ) || ( known_bv < ( total_bv / _ NUM ) ) ) { new_stealth = _ NUM ; } else { if ( ( known_range / known_count ) <= ( _ NUM +  Compute . random Int ( _ NUM ) ) ) { new_stealth = _ NUM ; } else { new_stealth = _ NUM ; } } } m Equip . set Mode ( new_stealth ) ; send Mode Change ( check_ent . get Id ( ) , check_ent . get Equipment Num ( m Equip ) , new_stealth ) ; break ; } } } } } }
public static  Intent create Take Picture Intent (  Activity ctx ,  Uri saving Uri ) { if ( saving Uri == null ) { throw new  Null Pointer Exception ( _ STR ) ; } final  List <  Intent > camera Intents = new  Array List <  Intent > ( ) ; final  Intent capture Intent = new  Intent (  Media Store .  ACTION_ IMAGE_ CAPTURE ) ; final  Package Manager package Manager = ctx . get Package Manager ( ) ; final  List <  Resolve Info > list Cam = package Manager . query Intent Activities ( capture Intent , _ NUM ) ; for (  Resolve Info res : list Cam ) { final  String package Name = res . activity Info . package Name ; final  Intent intent = new  Intent ( capture Intent ) ; intent . set Component ( new  Component Name ( res . activity Info . package Name , res . activity Info . name ) ) ; intent . set Package ( package Name ) ; intent . put Extra (  Media Store .  EXTRA_ OUTPUT , saving Uri ) ; camera Intents . add ( intent ) ; } final  Intent gallery Intent = new  Intent ( ) ; gallery Intent . set Type ( _ STR ) ; gallery Intent . set Action (  Intent .  ACTION_ GET_ CONTENT ) ; final  Intent chooser Intent =  Intent . create Chooser ( gallery Intent , _ STR ) ; chooser Intent . put Extra (  Intent .  EXTRA_ INITIAL_ INTENTS , camera Intents . to Array ( new  Parcelable [ ] { } ) ) ; return chooser Intent ; }
public static  Http URLConnection to Http Connection (  Request Batch requests ) { for (  Request request : requests ) { request . validate ( ) ; }  URL url = null ; try { if ( requests . size ( ) == _ NUM ) {  Request request = requests . get ( _ NUM ) ; url = new  URL ( request . get Url For Single Request ( ) ) ; } else { url = new  URL (  Server Protocol . get Graph Url Base ( ) ) ; } } catch (  Malformed URLException e ) { throw new  Facebook Exception ( _ STR , e ) ; }  Http URLConnection connection ; try { connection = create Connection ( url ) ; serialize To Url Connection ( requests , connection ) ; } catch (  IOException e ) { throw new  Facebook Exception ( _ STR , e ) ; } catch (  JSONException e ) { throw new  Facebook Exception ( _ STR , e ) ; } return connection ; }
public boolean is Revoked (  Certificate cert ) { if ( revoked Map . is Empty ( ) || ( ! ( cert instanceof  X509 Certificate ) ) ) { return _ BOOL ; }  X509 Certificate xcert = (  X509 Certificate ) cert ;  X509 Issuer Serial issuer Serial = new  X509 Issuer Serial ( xcert ) ; return revoked Map . contains Key ( issuer Serial ) ; }
@  Request Mapping ( value = { _ STR , _ STR } , method =  Request Method .  POST ) @  Response Body public  Rest Wrapper update ( @  Model Attribute ( _ STR ) @  Valid  Users users ,  Binding Result binding Result ,  Principal principal ) {  Rest Wrapper rest Wrapper = null ; if ( binding Result . has Errors ( ) ) {  Binding Result Error binding Result Error = new  Binding Result Error ( ) ; return binding Result Error . error Message ( binding Result ) ; } try {  String hashed Password =  Digest Utils . sha1 Hex ( users . get Password ( ) ) ; users . set Password ( hashed Password ) ; com . wipro . ats . bdre . md . dao . jpa .  Users jpa Users = new com . wipro . ats . bdre . md . dao . jpa .  Users ( ) ; jpa Users . set Password ( hashed Password ) ; jpa Users . set Username ( users . get Username ( ) ) ; jpa Users . set Enabled ( ( users . get Enabled ( ) == _ NUM ) ? _ BOOL : _ BOOL ) ; users DAO . update ( jpa Users ) ; rest Wrapper = new  Rest Wrapper ( users ,  Rest Wrapper .  OK ) ;  LOGGER . info ( _ STR + users . get Username ( ) + _ STR + principal . get Name ( ) + users ) ; } catch (  Exception e ) {  LOGGER . error ( e ) ; rest Wrapper = new  Rest Wrapper ( e . get Message ( ) ,  Rest Wrapper .  ERROR ) ; } return rest Wrapper ; }
public  Set <  Word Token > nearest Words ( final int distance ,  Predicate <  Dependency > predicate , final  Word Token ... start ) { return nearest Words ( distance , predicate ,  Arrays . as List ( start ) ) ; }
public  Collection <  IDevice > filter By Used ( @  Not Null  Collection <  IDevice > devices ) {  Set <  IDevice > used =  Sets . new Hash Set With Expected Size ( my Devices Used In Launch . size ( ) ) ; for (  IDevice d : devices ) { if ( my Devices Used In Launch . contains ( d . get Serial Number ( ) ) ) { used . add ( d ) ; } } return used ; }
public  List <  Interval > insert (  List <  Interval > intervals ,  Interval new Interval ) {  List <  Interval > res = new  Array List < > ( ) ; res . add ( new Interval ) ; if ( intervals == null || intervals . size ( ) == _ NUM ) { return res ; } for (  Interval i : intervals ) { int start = res . get ( res . size ( ) - _ NUM ) . start ; int end = res . get ( res . size ( ) - _ NUM ) . end ; if ( i . end < start ) { res . add ( res . size ( ) - _ NUM , i ) ; } else if ( end < i . start ) { res . add ( i ) ; } else { start =  Math . min ( start , i . start ) ; end =  Math . max ( end , i . end ) ; res . set ( res . size ( ) - _ NUM , new  Interval ( start , end ) ) ; } } return res ; }
private  String extract Human Readable Realm String (  String realm ) { if ( realm == null || ! realm . contains ( _ STR ) ) { return _ STR ; }  List <  String > tokens = new  Array List <  String > ( ) ;  String Tokenizer tokenizer = new  String Tokenizer ( realm , _ STR ) ; while ( tokenizer . has More Tokens ( ) ) { tokens . add ( tokenizer . next Token ( ) ) ; }  String extracted Realm String = _ STR ; for (  String token : tokens ) { if ( token . contains ( _ STR ) ) { extracted Realm String += _ STR + token . substring ( token . index Of ( _ STR ) + _ NUM ) ; } } extracted Realm String += _ STR ; return extracted Realm String ; }
public static  Key Store Handler create ( final  File key Store File , final char [ ] password ) throws  IOException ,  Key Store Exception { if ( key Store File == null ) { throw new  File Not Found Exception ( null ) ; } else if ( key Store File . exists ( ) ) { throw new  File Already Exists Exception ( key Store File . get Absolute Path ( ) ) ; } final  Key Store ks =  Key Store . get Instance (  Key Store Handler .  KEYSTORE_ TYPE ) ; try { ks . load ( null , password ) ; } catch ( final  No Such Algorithm Exception |  Certificate Exception ex ) { throw new  Illegal State Exception ( _ STR , ex ) ; } final  Secret Key Factory skf =  Key Store Handler . get Secret Key Factory ( ) ; final  Key Store Handler ksh = new  Key Store Handler ( ks , password , key Store File , skf , _ BOOL ) ; ksh . save ( ) ; return ksh ; }
@  Override public void zoom Range Axes ( double factor ,  Plot Rendering Info info ,  Point2 D source , boolean use Anchor ) { final double source X = source . get X ( ) ; for ( int axis Idx = _ NUM ; axis Idx < get Axis Count ( ) ; axis Idx ++ ) { final  Value Axis axis = get Axis ( axis Idx ) ; if ( axis != null ) { if ( use Anchor ) { double anchor X = axis . java2 DTo Value ( source X , info . get Data Area ( ) ,  Rectangle Edge .  BOTTOM ) ; axis . resize Range ( factor , anchor X ) ; } else { axis . resize Range ( factor ) ; } } } }
private void inject Dependencies ( ) {  Sample Application easy MVPApplication = (  Sample Application ) get Application ( ) ;  List <  Object > activity Scope Modules = ( get Modules ( ) != null ) ? get Modules ( ) : new  Array List < > ( ) ; activity Scope Modules . add ( new  Activity Module ( this ) ) ; activity Scope Modules . add ( new  Presenter Module ( ) ) ; activity Scope Graph = easy MVPApplication . build Graph With Aditional Modules ( activity Scope Modules ) ; inject ( this ) ; }
static public  JCheck Box create JCheck Box For Table ( boolean selected ) {  JCheck Box check Box = new  JCheck Box ( ) ; check Box . set Opaque ( _ BOOL ) ; check Box . set Horizontal Alignment (  Swing Constants .  CENTER ) ; check Box . set Foreground (  TABLE_ COMPONENT_ FG_ COLOR ) ; check Box . set Background (  TABLE_ COMPONENT_ BG_ COLOR ) ; check Box . set Selected ( selected ) ; return check Box ; }
protected void process Window Event (  Window Event e ) { if ( e . get ID ( ) ==  Window Event .  WINDOW_ CLOSING ) dispose ( ) ; super . process Window Event ( e ) ; }
public static void do Deactivate Vcenter Data Center (  Db Client db Client ,  Vcenter Data Center data Center ) {  List <  Named Element Query Result List .  Named Element > host Uris = list Children ( db Client , data Center . get Id ( ) ,  Host . class , _ STR , _ STR ) ;  Set <  URI > do Not Deleteclusters = new  Hash Set <  URI > ( ) ; for (  Named Element Query Result List .  Named Element host Uri : host Uris ) {  Host host = db Client . query Object (  Host . class , host Uri . get Id ( ) ) ; if ( host != null && ! host . get Inactive ( ) ) { if (  Null Column Value Getter . is Null URI ( host . get Compute Element ( ) ) ) { do Deactivate Host ( db Client , host ) ; } else { host . set Vcenter Data Center (  Null Column Value Getter . get Null URI ( ) ) ; db Client . persist Object ( host ) ; if ( !  Null Column Value Getter . is Null URI ( host . get Cluster ( ) ) ) { do Not Deleteclusters . add ( host . get Cluster ( ) ) ; } } } }  List <  Named Element Query Result List .  Named Element > clusters Uris = list Children ( db Client , data Center . get Id ( ) ,  Cluster . class , _ STR , _ STR ) ; for (  Named Element Query Result List .  Named Element cluster Uri : clusters Uris ) {  Cluster cluster = db Client . query Object (  Cluster . class , cluster Uri . get Id ( ) ) ; if ( cluster != null && ! cluster . get Inactive ( ) ) { if ( do Not Deleteclusters . contains ( cluster . get Id ( ) ) ) { cluster . set Vcenter Data Center (  Null Column Value Getter . get Null URI ( ) ) ; cluster . set External Id (  Null Column Value Getter . get Null Str ( ) ) ; db Client . persist Object ( cluster ) ; } else { db Client . mark For Deletion ( cluster ) ;  Event Utils . delete Resource Events ( db Client , cluster . get Id ( ) ) ; } } } _log . info ( _ STR , data Center . get Label ( ) , data Center . get Id ( ) ) ; db Client . mark For Deletion ( data Center ) ;  Event Utils . delete Resource Events ( db Client , data Center . get Id ( ) ) ; }
private void update ( ) { if ( current Info != null ) { if ( current Info . request Error ) { if ( last Updated != - _ NUM ) { load Info . set Text (  String . format ( _ STR , current Info . request Error Description ,  Date Time . ago Single Compact ( current Info . time ) ,  Date Time . ago Single Compact ( last Updated ) ) ) ; } else { load Info . set Text (  String . format ( _ STR , current Info . request Error Description ,  Date Time . ago Single Compact ( current Info . time ) ) ) ; } } else { load Info . set Text (  String . format ( _ STR ,  Date Time . ago Single Verbose ( last Updated ) ) ) ; } } if ( loading ) { load Info . set Text ( _ STR ) ; } update Stats ( ) ; }
public void engine Delete Entry (  String alias ) throws  Key Store Exception { permission Check ( ) ; synchronized ( entries ) {  Object entry = entries . remove ( alias . to Lower Case ( ) ) ; deleted Entries . put ( alias . to Lower Case ( ) , entry ) ; } }
public void remove Smaller ( int value ) { int target Position =  Arrays . binary Search ( backing Array , _ NUM , num Elements , value ) ; if ( target Position < _ NUM ) { target Position = - target Position - _ NUM ; } num Elements -= target Position ; if ( target Position != _ NUM && num Elements > _ NUM ) {  System . arraycopy ( backing Array , target Position , backing Array , _ NUM , num Elements ) ; } }
public final void print Initial Clustering Changes (  File file ,  List <  Cluster Data > cluster Data , int [ ] mat Index To Msg Internal Id ) throws  Ade Usage Exception { if ( m_initial Clusters == null ) { return ; } final  Print Writer out =  File Utils . open Print Writer To File ( file , _ BOOL ) ; if ( m_final Clusters == null ) { update Clusters ( cluster Data , mat Index To Msg Internal Id ) ; } int count No Change = _ NUM ; int count Contained = _ NUM ; for (  Map .  Entry <  String ,  Array List <  Integer > > entry : m_initial Clusters . entry Set ( ) ) { final  String name = entry . get Key ( ) ; final  Array List <  Integer > members = entry . get Value ( ) ; out . printf ( _ STR , name , members ) ; int count C = _ NUM ; boolean split Flag = _ BOOL ; final  Array List <  String > names = new  Array List <  String > ( ) ; for (  Map .  Entry <  String ,  Collection <  Integer > > new Entry : m_final Clusters . entry Set ( ) ) { final  Collection <  Integer > new Members = new Entry . get Value ( ) ; final  String new Name = new Entry . get Key ( ) ; int count M = _ NUM ; boolean update C = _ BOOL ; for ( int m : new Members ) { if ( members . contains ( mat Index To Msg Internal Id [ m ] ) ) { if ( update C ) { count C ++ ; update C = _ BOOL ; names . add ( new Name ) ; } count M ++ ; } } if ( count M == members . size ( ) ) { split Flag = _ BOOL ; if ( members . size ( ) == new Members . size ( ) ) { out . printf ( _ STR ) ; count No Change ++ ; } else { out . printf ( _ STR , new Name ) ; count Contained ++ ; } break ; } } if ( split Flag ) { out . printf ( _ STR , count C , names ) ; } } out . printf ( _ STR , count No Change , count Contained , m_initial Clusters . size ( ) - count No Change - count Contained ) ; out . close ( ) ; }
protected void add To GUI (  JPanel gui ,  Abstract Button b ,  String cmd ) { b . set Action Command ( cmd ) ; b . add Action Listener ( this ) ; gui . add ( b ) ; }
protected  String concat Fields (  Solr Input Document doc ) {  String Builder sb = new  String Builder ( get Expected Size ( doc , input Fields ) ) ; for (  String field Name : input Fields ) { log . debug ( _ STR + field Name ) ; if ( doc . contains Key ( field Name ) ) {  Collection <  Object > field Values = doc . get Field Values ( field Name ) ; if ( field Values != null ) { for (  Object content : field Values ) { if ( content instanceof  String ) {  String string Content = (  String ) content ; if ( string Content . length ( ) > max Field Value Chars ) { sb . append ( string Content . substring ( _ NUM , max Field Value Chars ) ) ; } else { sb . append ( string Content ) ; } sb . append ( _ STR ) ; if ( sb . length ( ) > max Total Chars ) { sb . set Length ( max Total Chars ) ; break ; } } else { log . warn ( _ STR + field Name + _ STR ) ; } } } } } return sb . to String ( ) ; }
public  Brd From Side calc_from_side (  Shape Tile p_shape ,  Pla Point Int p_shape_center , int p_layer , int p_offset , int p_cl_class ) {  Net Nos List empty_arr =  Net Nos List .  EMPTY ;  Shape Tile offset_shape = p_shape . offset ( p_offset ) ; for ( int index = _ NUM ; index < offset_shape . border_line_count ( ) ; ++ index ) {  Shape Tile check_shape = calc_check_chape_for_from_side ( p_shape , p_shape_center , offset_shape . border_line ( index ) ) ; if ( r_board . check_trace ( check_shape , p_layer , empty_arr , p_cl_class , null ) ) { return new  Brd From Side ( index , null ) ; } } for ( int index = _ NUM ; index < offset_shape . border_line_count ( ) ; ++ index ) {  Shape Tile check_shape = calc_check_chape_for_from_side ( p_shape , p_shape_center , offset_shape . border_line ( index ) ) ; if ( r_board . check_trace ( check_shape , p_layer , empty_arr , _ NUM , null ) ) { return new  Brd From Side ( index , null ) ; } } return  Brd From Side .  NOT_ CALCULATED ; }
public static void delete (  File file Or Folder ) { if ( file Or Folder != null ) delete ( file Or Folder . to Path ( ) ) ; }
public static double [ ] string Array To Double Array ( final  String [ ] line ) { double [ ] ret = new double [ line . length ] ; for ( int i = _ NUM ; i < line . length ; i ++ ) { ret [ i ] =  Double . parse Double ( line [ i ] ) ; } return ret ; }
public boolean refresh Object State ( boolean keep Old State ) { boolean change Detected = _ BOOL ;  Object [ ] args = null ; if ( keep Old State ) { old Object State . put All ( object State ) ; } for (  Map .  Entry <  String ,  Method > gettor Method Entry : getter Method Map . entry Set ( ) ) {  String property = gettor Method Entry . get Key ( ) ;  Object property Value = null ; try {  Method m = gettor Method Entry . get Value ( ) ; property Value = m . invoke ( mbean Object , args ) ;  Open Method op = method Handler Map . get ( m ) ; property Value = op . to Open Return Value ( property Value ) ; } catch (  Exception e ) { property Value = null ; if ( logger . is Trace Enabled ( ) ) { logger . trace ( e . get Message ( ) ) ; } }  Object old Value = object State . put ( property , property Value ) ; if ( ! change Detected ) { if ( property Value != null ) { if ( ! property Value . equals ( old Value ) ) { change Detected = _ BOOL ; } } else { if ( old Value != null ) { change Detected = _ BOOL ; } } } } boolean ret Val = prev Refresh Change Detected || change Detected ; prev Refresh Change Detected = change Detected ; return ret Val ; }
protected double decode ( int value , double lower , double upper , int nbits ) { int maxval = ( int ) (  Math . pow ( _ NUM , nbits ) - _ NUM ) ; return value * ( ( upper - lower ) / ( maxval - _ NUM ) ) + lower ; }
public int read ( byte b [ ] , int off , int len ) throws  IOException { if ( input Stream == null ) { throw new  IOException ( _ STR ) ; } int gotsofar = _ NUM ; while ( gotsofar < len ) { int read = input Stream . read ( b , off + gotsofar , len - gotsofar ) ; if ( read == - _ NUM ) { if ( gotsofar > _ NUM ) { count ( gotsofar ) ; return gotsofar ; } else { return read ; } } else { gotsofar += read ; } } count ( gotsofar ) ; return gotsofar ; }
public void handle Tbl Supported Container Href Action Request (  Request Invocation Event event ) throws  Model Control Exception { try {  Map values = get Values ( ) ; on Before Save Profile ( values ) ; set Page Session Attribute (  PROPERTY_ ATTRIBUTE , (  Hash Map ) values ) ;  WSPPService Supported Container Edit View Bean vb = (  WSPPService Supported Container Edit View Bean ) get View Bean (  WSPPService Supported Container Edit View Bean . class ) ; unlock Page Trail ( ) ; pass Pg Session Map ( vb ) ; vb . populate Values ( (  String ) get Display Field Value ( _ STR ) ) ; vb . forward To ( get Request Context ( ) ) ; } catch (  AMConsole Exception e ) { set Inline Alert Message (  CCAlert .  TYPE_ ERROR , _ STR , e . get Message ( ) ) ; forward To ( ) ; } }
final  V do Remove (  Object key ,  Object value ) { if ( key == null ) throw new  Null Pointer Exception ( ) ;  Comparator < ? super  K > cmp = comparator ; outer : for ( ; ; ) { for (  Node <  K ,  V > b = find Predecessor ( key , cmp ) , n = b . next ; ; ) {  Object v ; int c ; if ( n == null ) break outer ;  Node <  K ,  V > f = n . next ; if ( n != b . next ) break ; if ( ( v = n . value ) == null ) { n . help Delete ( b , f ) ; break ; } if ( b . value == null || v == n ) break ; if ( ( c = cpr ( cmp , key , n . key ) ) < _ NUM ) break outer ; if ( c > _ NUM ) { b = n ; n = f ; continue ; } if ( value != null && ! value . equals ( v ) ) break outer ; if ( ! n . cas Value ( v , null ) ) break ; if ( ! n . append Marker ( f ) || ! b . cas Next ( n , f ) ) find Node ( key ) ; else { find Predecessor ( key , cmp ) ; if ( head . right == null ) try Reduce Level ( ) ; } @  Suppress Warnings ( _ STR )  V vv = (  V ) v ; return vv ; } } return null ; }
@  Deprecated protected void insert At Boundry (  JEditor Pane editor ,  HTMLDocument doc , int offset ,  Element insert Element ,  String html ,  HTML .  Tag parent Tag ,  HTML .  Tag add Tag ) {  Element e ;  Element common Parent ; boolean is First = ( offset == _ NUM ) ; if ( offset > _ NUM || insert Element == null ) { e = doc . get Default Root Element ( ) ; while ( e != null && e . get Start Offset ( ) != offset && ! e . is Leaf ( ) ) { e = e . get Element ( e . get Element Index ( offset ) ) ; } common Parent = ( e != null ) ? e . get Parent Element ( ) : null ; } else { common Parent = insert Element ; } if ( common Parent != null ) { int pops = _ NUM ; int pushes = _ NUM ; if ( is First && insert Element != null ) { e = common Parent ; while ( e != null && ! e . is Leaf ( ) ) { e = e . get Element ( e . get Element Index ( offset ) ) ; pops ++ ; } } else { e = common Parent ; offset -- ; while ( e != null && ! e . is Leaf ( ) ) { e = e . get Element ( e . get Element Index ( offset ) ) ; pops ++ ; } e = common Parent ; offset ++ ; while ( e != null && e != insert Element ) { e = e . get Element ( e . get Element Index ( offset ) ) ; pushes ++ ; } } pops =  Math . max ( _ NUM , pops - _ NUM ) ; insert HTML ( editor , doc , offset , html , pops , pushes , add Tag ) ; } }
private void update Quick Reply View (  String edit Text ) { if (  Build Config .  DEBUG )  Log . v ( _ STR + edit Text + _ STR ) ; if ( qr Edit Text != null && edit Text != null ) { qr Edit Text . set Text ( edit Text + signature Text ) ; qr Edit Text . set Selection ( edit Text . length ( ) ) ; } if ( quickreply Text View != null && quick Reply Sms Message != null ) { quickreply Text View . set Text ( get String (  R . string . quickreply_from_text , quick Reply Sms Message . get Contact Name ( ) ) ) ; } }
@  Override protected synchronized void read ( long offset , byte [ ] b ) throws  IOException { if ( byte Buffer != null ) { byte Buffer . position ( ( int ) offset ) ; byte Buffer . get ( b ) ; } else { throw new  IOException ( _ STR + get Path ( ) + _ STR ) ; } }
protected boolean has Outstanding Changes ( ) { return ( f Amt From . has Changed ( ) || f Amt To . has Changed ( ) || f Bank Account_ ID . has Changed ( ) || f Cash_ ID . has Changed ( ) || f Cash Book_ ID . has Changed ( ) || f Charge_ ID . has Changed ( ) || f Date From . has Changed ( ) || f Date To . has Changed ( ) || f Invoice_ ID . has Changed ( ) || f Payment_ ID . has Changed ( ) || cb Absolute . has Changed ( ) ) ; }
public void fill (  View view ) { validate Not Nullable View ( view ) ; try { if ( view instanceof  View Group ) {  View Group view Group = (  View Group ) view ; for ( int i = _ NUM ; i < view Group . get Child Count ( ) ; i ++ ) {  View child = view Group . get Child At ( i ) ; fill ( child ) ; } } else { if ( m Ids == null ) { fill View ( view ) ; } else if ( m Ids . contains ( view . get Id ( ) ) ) { fill View ( view ) ; } } } catch (  Exception e ) { e . print Stack Trace ( ) ; } finally { m Faker = null ; } }
public void replace Header ( int state ,  String header ) throws  Auth Login Exception { if ( debug . message Enabled ( ) ) { debug . message ( _ STR + state + _ STR + header ) ; } if ( last State != state ) { already Replaced = _ BOOL ; } last State = state ; if ( state > state Length ) { throw new  Auth Login Exception ( bundle Name , _ STR , new  Object [ ] { new  Integer ( state ) } ) ; }  Callback [ ] ext = get Callback ( state , _ BOOL ) ; if ( ext . length <= _ NUM ) { throw new  Auth Login Exception ( bundle Name , _ STR , null ) ; } if ( ( header != null ) && ( header . length ( ) != _ NUM ) ) {  Page Properties Callback pc = (  Page Properties Callback ) ( (  Callback [ ] ) internal . get ( state - _ NUM ) ) [ _ NUM ] ; if ( ! ( already Replaced ) ) { header With Replace Tag = pc . get Header ( ) ; } int idx = header With Replace Tag . index Of ( _ STR ) ; if ( idx != - _ NUM ) {  String new Header = header With Replace Tag . substring ( _ NUM , idx ) + header ; pc . set Header ( new Header ) ; already Replaced = _ BOOL ; } else {  String new Header = header With Replace Tag . substring ( _ NUM , header With Replace Tag . index Of ( _ STR ) ) + _ STR + header ; pc . set Header ( new Header ) ; } } }
private  String build Virtual Volume Name (  List <  String > native Volume Names ) { s_logger . info ( _ STR ) ;  String Builder name Builder = new  String Builder ( ) ; if ( native Volume Names . size ( ) == _ NUM ) { name Builder . append (  VPlex Api Constants .  DEVICE_ PREFIX ) ; name Builder . append ( native Volume Names . get ( _ NUM ) ) ; name Builder . append (  VPlex Api Constants .  VIRTUAL_ VOLUME_ SUFFIX ) ; } else { name Builder . append (  VPlex Api Constants .  DIST_ DEVICE_ PREFIX ) ; for (  String native Volume Name : native Volume Names ) { name Builder . append (  VPlex Api Constants .  DIST_ DEVICE_ NAME_ DELIM ) ; name Builder . append ( native Volume Name ) ; } name Builder . append (  VPlex Api Constants .  VIRTUAL_ VOLUME_ SUFFIX ) ; } s_logger . info ( _ STR , name Builder . to String ( ) ) ; return name Builder . to String ( ) ; }
public boolean remove ( int location ,  Image Info object ) { final boolean removed = data . remove ( object ) ; notify Item Range Removed ( location , data . size ( ) ) ; return removed ; }
private final void add User (  String channel ,  User user ) { channel = channel . to Lower Case ( ) ; synchronized ( _channels ) {  Hashtable <  User ,  User > users = _channels . get ( channel ) ; if ( users == null ) { users = new  Hashtable <  User ,  User > ( ) ; _channels . put ( channel , users ) ; } users . put ( user , user ) ; } }
void delete Local Device (  Volume Info device Info ) throws  VPlex Api Exception {  String device Name =  VPlex Api Constants .  DEVICE_ PREFIX + device Info . get Volume Name ( ) ; delete Local Device ( device Name ) ; }
public static <  T extends  Throwable >  T read Stack Trace (  T throwable ,  Stream Input in ) throws  IOException { final int stack Trace Elements = in . read VInt ( ) ;  Stack Trace Element [ ] stack Trace = new  Stack Trace Element [ stack Trace Elements ] ; for ( int i = _ NUM ; i < stack Trace Elements ; i ++ ) { final  String declaring Classs = in . read String ( ) ; final  String file Name = in . read Optional String ( ) ; final  String method Name = in . read String ( ) ; final int line Number = in . read VInt ( ) ; stack Trace [ i ] = new  Stack Trace Element ( declaring Classs , method Name , file Name , line Number ) ; } throwable . set Stack Trace ( stack Trace ) ; int num Suppressed = in . read VInt ( ) ; for ( int i = _ NUM ; i < num Suppressed ; i ++ ) { throwable . add Suppressed ( in . read Throwable ( ) ) ; } return throwable ; }
@  Override public synchronized void destroy ( ) { destroyed = _ BOOL ; for (  Thread t : workers Threads ) { t . interrupt ( ) ; } notify All ( ) ; }
private int show Has Changed Dialog ( ) {  Object [ ] options = { _ STR , _ STR , _ STR } ; return  JOption Pane . show Option Dialog ( frame , _ STR + _ STR , _ STR ,  JOption Pane .  YES_ NO_ OPTION ,  JOption Pane .  WARNING_ MESSAGE , null , options , options [ _ NUM ] ) ; }
public  Tv Show Update Datasource Task2 (  String datasource ) { super (  BUNDLE . get String ( _ STR ) + _ STR + datasource + _ STR ) ; tv Show List =  Tv Show List . get Instance ( ) ; data Sources = new  Array List < > ( _ NUM ) ; data Sources . add ( datasource ) ; }
public static  Text Map from String (  String text ) { final int text Length = text . length ( ) ; final  Array List <  Integer > lines = new  Array List < > ( ) ; lines . add ( _ NUM ) ; int offset = _ NUM ; while ( offset < text . length ( ) ) { final int nl Index = text . index Of ( _ STR , offset ) ; if ( nl Index >= _ NUM ) { offset = nl Index + _ NUM ; lines . add ( offset ) ; } else { break ; } } lines . add (  Integer .  MAX_ VALUE ) ; final int [ ] nl Offsets = new int [ lines . size ( ) ] ; for ( int line = _ NUM ; line < lines . size ( ) ; line ++ ) { nl Offsets [ line ] = lines . get ( line ) ; } final boolean final NL = text Length > _ NUM && ( text Length == nl Offsets [ nl Offsets . length - _ NUM ] ) ; return new  Text Map ( nl Offsets , text Length , final NL ) ; }
public void add ( final  Sensor sensor ) {  Set <  Sensor > old Selection = new  Hash Set <  Sensor > ( selection ) ; boolean rv = selection . add ( sensor ) ; if ( rv ) { fire Selection Changed ( old Selection , selection ) ; } }
protected boolean include (  Iterable <  String > path ,  String name ) throws  IOException ,  Lexer Exception { for (  String dir : path ) {  Virtual File file = filesystem . get File ( dir , name ) ; if ( include ( file ) ) return _ BOOL ; }  Virtual File file = filesystem . get File ( name ) ; if ( include ( file ) ) return _ BOOL ; return _ BOOL ; }
public synchronized void close ( ) { if ( socket != null && ! socket . is Closed ( ) ) { try { socket . close ( ) ; } catch (  IOException e ) { logger . warn ( e . get Message ( ) ) ; } } }
public  Message Tokenizer (  IMessage message ) { this ( message . get Client ( ) , message . get Content ( ) ) ; }
public  Hash ( byte [ ] hash ) { if ( hash . length != _ NUM ) { throw new  Illegal Argument Exception ( _ STR ) ; } this . bytes = new byte [ _ NUM ] ;  System . arraycopy ( hash , _ NUM , this . bytes , _ NUM , _ NUM ) ; }
private void apply Opposite Bicycle Permissions (  Way way ,  Enum Set <  Edge Store .  Edge Flag > backward ) {  String cycleway Left Tag Value = way . get Tag ( _ STR ) ;  String cycleway Right Tag Value = way . get Tag ( _ STR ) ;  String cycleway Tag Value = way . get Tag ( _ STR ) ; boolean added Bike Permissions = _ BOOL ; if ( cycleway Tag Value != null && cycleway Tag Value . starts With ( _ STR ) ) { backward . add (  Edge Store .  Edge Flag .  ALLOWS_ BIKE ) ; added Bike Permissions = _ BOOL ; } else if ( cycleway Right Tag Value != null ) { if ( cycleway Right Tag Value . starts With ( _ STR ) ) { backward . add (  Edge Store .  Edge Flag .  ALLOWS_ BIKE ) ; added Bike Permissions = _ BOOL ; } } if ( ! added Bike Permissions && cycleway Left Tag Value != null ) { if ( cycleway Left Tag Value . starts With ( _ STR ) ) { backward . add (  Edge Store .  Edge Flag .  ALLOWS_ BIKE ) ; } } }
public void handle Button1 Request (  Request Invocation Event event ) throws  Model Control Exception {  FSAuth Domains Model model = (  FSAuth Domains Model ) get Model ( ) ;  String name = (  String ) get Display Field Value ( model .  TF_ NAME ) ;  AMProperty Sheet ps = (  AMProperty Sheet ) get Child (  PROPERTY_ ATTRIBUTE ) ; try {  String realm = model . get Realm ( name ) ;  Map values = ps . get Attribute Values ( model . get Data Map ( ) , _ BOOL , model ) ; model . set Attribute Values ( realm , name , values ) ;  Serialized Field sz Cache = (  Serialized Field ) get Child (  SZ_ CACHE ) ;  Federation View Bean vb = (  Federation View Bean ) get View Bean (  Federation View Bean . class ) ;  CCAdd Remove add Remove List = (  CCAdd Remove ) get Child (  ADD_ REMOVE_ PROVIDERS ) ; add Remove List . restore State Data ( ) ;  CCAdd Remove Model add Remove Model = (  CCAdd Remove Model ) add Remove List . get Model ( ) ;  List list = new  Array List ( get Selected Values ( add Remove Model ) ) ; model . add Providers ( realm , name , list ) ; set Inline Alert Message (  CCAlert .  TYPE_ INFO , _ STR , _ STR ) ; forward To ( ) ; } catch (  AMConsole Exception e ) { set Inline Alert Message (  CCAlert .  TYPE_ ERROR , _ STR , e . get Message ( ) ) ; forward To ( ) ; } }
private static byte [ ] read Class ( final  Input Stream is ) throws  IOException { if ( is == null ) { throw new  IOException ( _ STR ) ; } byte [ ] b = new byte [ is . available ( ) ] ; int len = _ NUM ; while ( _ BOOL ) { int n = is . read ( b , len , b . length - len ) ; if ( n == - _ NUM ) { if ( len < b . length ) { byte [ ] c = new byte [ len ] ;  System . arraycopy ( b , _ NUM , c , _ NUM , len ) ; b = c ; } return b ; } len += n ; if ( len == b . length ) { byte [ ] c = new byte [ b . length + _ NUM ] ;  System . arraycopy ( b , _ NUM , c , _ NUM , len ) ; b = c ; } } }
public  String format String ( final  String str To Format ) { if ( str To Format != null ) { if ( str To Format . equals Ignore Case ( _ STR ) ) return _ STR ; final  String valn1 = str To Format . replace All ( _ STR , _ STR ) ; final  String formt Str = valn1 . replace All ( _ STR , _ STR ) ; return formt Str . replace All ( _ STR , _ STR ) ; } else return _ STR ; }
public  Joiner join (  Class < ? extends  Data Object > clazz ,  String alias ,  Data Object ... objs ) { return join ( clazz , alias , new  Array List <  Data Object > (  Arrays . as List ( objs ) ) ) ; }
@  Override protected void close File (  Input Stream is ) throws  IOException { super . close File ( is ) ; br . close ( ) ; br = null ; path = null ; }
public  String show Switch Wwn ( ) throws  Network Device Controller Exception {  SSHPrompt [ ] prompts = {  SSHPrompt .  POUND ,  SSHPrompt .  GREATER_ THAN ,  SSHPrompt .  MDS_ CONFIG ,  SSHPrompt .  MDS_ CONFIG_ IVR_ ZONE ,  SSHPrompt .  MDS_ CONFIG_ IVR_ ZONESET } ;  String Builder buf = new  String Builder ( ) ; send Wait For (  MDSDialog Properties . get String ( _ STR ) , default Timeout , prompts , buf ) ;  String [ ] lines = get Lines ( buf ) ;  String [ ] regex = {  MDSDialog Properties . get String ( _ STR ) } ;  String switch Wwn = null ;  String [ ] groups = new  String [ _ NUM ] ; for (  String line : lines ) { int index = match ( line , regex , groups ) ; switch ( index ) { case _ NUM : switch Wwn = groups [ _ NUM ] ; break ; } if ( switch Wwn != null ) { break ; } } return switch Wwn ; }
public void reset ( ) { set Service (  OBD_ SVC_ NONE , _ BOOL ) ; cmd Queue . clear ( ) ; pid Supported . clear ( ) ; reset Fixed Pid ( ) ;  Pid Pvs . clear ( ) ; t Codes . clear ( ) ;  Vid Pvs . clear ( ) ; }
public  Quad Edge locate From Edge (  Vertex v ,  Quad Edge start Edge ) { int iter = _ NUM ; int max Iter = quad Edges . size ( ) ;  Quad Edge e = start Edge ; while ( _ BOOL ) { iter ++ ; if ( iter > max Iter ) { throw new  Locate Failure Exception ( e . to Line Segment ( ) ) ; } if ( ( v . equals ( e . orig ( ) ) ) || ( v . equals ( e . dest ( ) ) ) ) { break ; } else if ( v . right Of ( e ) ) { e = e . sym ( ) ; } else if ( ! v . right Of ( e . o Next ( ) ) ) { e = e . o Next ( ) ; } else if ( ! v . right Of ( e . d Prev ( ) ) ) { e = e . d Prev ( ) ; } else { break ; } } return e ; }
static void remove Duplicate Affix (  List <  String > str List , boolean is Suffix ) {  Hash Set <  String > str Set = new  Hash Set <  String > ( str List ) ; str List . clear ( ) ; str List . add All ( str Set ) ; if ( is Suffix ) {  Collections . sort ( str List , null ) ; } else {  Collections . sort ( str List , null ) ; } }
default  B with (  String key , double value ) { return with ( key ,  Double . to String ( value ) ) ; }
private void list Directory (  File directory ,  Relative Directory subdirectory ,  Set <  Java File Object .  Kind > file Kinds , boolean recurse ,  List Buffer <  Java File Object > result List ) {  File d = subdirectory . get File ( directory ) ; if ( ! case Map Check ( d , subdirectory ) ) return ;  File [ ] files = d . list Files ( ) ; if ( files == null ) return ; if ( sort Files != null )  Arrays . sort ( files , sort Files ) ; for (  File f : files ) {  String fname = f . get Name ( ) ; if ( f . is Directory ( ) ) { if ( recurse && is Valid Directory ( fname ) ) { list Directory ( directory , new  Relative Directory ( subdirectory , fname ) , file Kinds , recurse , result List ) ; } } else { if ( is Valid File ( fname , file Kinds ) ) {  Java File Object fe = new  Regular File Object ( this , fname , new  File ( d , fname ) ) ; result List . append ( fe ) ; } } } }
private  Shape decode Interior ( int width , int height ) { path . reset ( ) ; path . move To ( _ NUM , _ NUM ) ; path . line To ( width - _ NUM , _ NUM ) ; path . line To ( width - _ NUM , height - _ NUM ) ; path . line To ( width - _ NUM , height - _ NUM ) ; path . line To ( _ NUM , height - _ NUM ) ; path . line To ( _ NUM , height - _ NUM ) ; path . close Path ( ) ; return path ; }
private static  Method search Candidates (  List <  Method > candidate Methods ,  Method bridge Method ) { if ( candidate Methods . is Empty ( ) ) { return null ; }  Method previous Method = null ; boolean same Sig = _ BOOL ; for (  Method candidate Method : candidate Methods ) { if ( is Bridge Method For ( bridge Method , candidate Method , bridge Method . get Declaring Class ( ) ) ) { return candidate Method ; } else if ( previous Method != null ) { same Sig = same Sig &&  Arrays . equals ( candidate Method . get Generic Parameter Types ( ) , previous Method . get Generic Parameter Types ( ) ) ; } previous Method = candidate Method ; } return ( same Sig ? candidate Methods . get ( _ NUM ) : null ) ; }
public static  String create Resource Name (  String resource ,  Locale locale , boolean remove Extension ) {  String resource Name = resource ; if ( remove Extension ) { if ( resource Name . ends With ( _ STR ) ) { resource Name = resource Name . replace ( _ STR , _ STR ) ; } else if ( resource Name . ends With ( _ STR ) ) { resource Name = resource Name . replace ( _ STR , _ STR ) ; } } if ( locale != null ) { if (  Util Validate . is Not Empty ( locale . to String ( ) ) ) { resource Name = resource Name + _ STR + locale ; } } return resource Name ; }
@  Override public void read External (  Object Input in ) throws  IOException ,  Class Not Found Exception { super . read External ( in ) ; this . routing Object ID =  DBIDUtil . import Integer ( in . read Int ( ) ) ; this . parent Distance = in . read Double ( ) ; this . covering Radius = in . read Double ( ) ; }
public  Obj Id Map (  Obj Id Map old Map ) { this . table = new  Entry [ old Map . table . length ] ;  System . arraycopy ( old Map . table , _ NUM , this . table , _ NUM , this . table . length ) ; this . count = old Map . count ; this . threshold = old Map . threshold ; this . load Factor = old Map . load Factor ; }
public static  Connection Factory new Failover Connection Factory (  Set <  LDAPURL > servers ,  String username , char [ ] password , int heart Beat Interval ,  String heart Beat Time Unit ,  Options ldap Options ) {  List <  Connection Factory > factories = new  Array List <  Connection Factory > ( servers . size ( ) ) ; for (  LDAPURL ldapurl : servers ) { factories . add ( new Connection Factory ( ldapurl , username , password , heart Beat Interval , heart Beat Time Unit , ldap Options ) ) ; } return load Balance Factories ( factories ) ; }
public  Extended Message Format ( final  String pattern ) { this ( pattern ,  Locale . get Default ( ) ) ; }
private  Class Code ( final  String name , final byte class Type ) { this . name = name ; this . class Type = class Type ; this . ordinal = next Ordinal ++ ;  VALUES [ this . ordinal ] = this ;  CODE_ NAME_ MAP . put ( name , this ) ; }
@  Suppress Warnings ( _ STR ) @  Override public void paint Icon (  Component c ,  Graphics g , int x , int y ) {  Sea Glass Painter painter = (  Sea Glass Painter )  UIManager . get ( prefix + _ STR + key ) ; if ( painter != null ) {  JComponent jc = ( c instanceof  JComponent ) ? (  JComponent ) c : null ;  Graphics2 D gfx = (  Graphics2 D ) g ; gfx . translate ( x , y ) ; painter . paint ( gfx , jc , width , height ) ; gfx . translate ( - x , - y ) ; } }
public static  Abstract File Output Operator checkpoint (  Abstract File Output Operator writer , long window Id ) { if ( window Id >=  Stateless .  WINDOW_ ID ) { writer . before Checkpoint ( window Id ) ; }  Kryo kryo = new  Kryo ( ) ;  Byte Array Output Stream bos = new  Byte Array Output Stream ( ) ;  Output loutput = new  Output ( bos ) ; kryo . write Object ( loutput , writer ) ; loutput . close ( ) ;  Input l Input = new  Input ( bos . to Byte Array ( ) ) ; @  Suppress Warnings ( _ STR )  Abstract File Output Operator check Pointed Writer = kryo . read Object ( l Input , writer . get Class ( ) ) ; l Input . close ( ) ; return check Pointed Writer ; }
private  Replace Tokens create Hostname Token ( ) {  Replace Tokens .  Token token Hostname = new  Replace Tokens .  Token ( ) ; token Hostname . set Key (  General Property Set .  HOSTNAME ) ;  String hostname = get Property Value (  General Property Set .  HOSTNAME ) ; if ( hostname == null ) { hostname =  DEFAULT_ HOSTNAME ; } token Hostname . set Value ( hostname ) ;  Replace Tokens replace Hostname = new  Replace Tokens ( ) ; replace Hostname . add Configured Token ( token Hostname ) ; return replace Hostname ; }
public  CAddress Space Configuration ( final  CAddress Space address Space , final  Address Space Configuration Backend provider , final int address Space Id , final  String name , final  String description , final  Date creation Date , final  Date modification Date , final  Debugger Template debugger Template ) { m_address Space = address Space ; m_provider = provider ; m_id = address Space Id ; m_name = name ; m_description = description ; m_creation Date = new  Date ( creation Date . get Time ( ) ) ; m_modification Date = new  Date ( modification Date . get Time ( ) ) ; m_debugger Template = debugger Template ; }
public  Shape screen To Chart Shape (  Shape s ) {  General Path p = new  General Path ( ) ;  Transform t =  Transform . make Identity ( ) ; if ( current Transform != null ) { t . concatenate ( current Transform . get Inverse ( ) ) ; } t . translate ( - get Absolute X ( ) , - get Absolute Y ( ) ) ; p . append ( s . get Path Iterator ( t ) , _ BOOL ) ; return p ; }
public static final void apply Window Fix (  Window window ) { if ( ! instance . needs Window Fix ) { return ; } window . remove Window State Listener ( instance ) ; window . add Window State Listener ( instance ) ; instance . window State Changed ( null ) ; }
public  Performance Logger (  String title ) { time1 =  System . current Time Millis ( ) ; }
private boolean path Match (  URL realm Url ,  URL return To Url ) {  String realm Path = realm Url . get Path ( ) ;  String return To Path = return To Url . get Path ( ) ; if ( ! realm Path . ends With ( _ STR ) ) realm Path += _ STR ; if ( ! return To Path . ends With ( _ STR ) ) return To Path += _ STR ; return return To Path . starts With ( realm Path ) ; }
public static byte [ ] from Hex (  String s ) { int len = s . length ( ) ; byte [ ] data = new byte [ len / _ NUM ] ; for ( int i = _ NUM ; i < len ; i += _ NUM ) { data [ i / _ NUM ] = ( byte ) ( (  Character . digit ( s . char At ( i ) , _ NUM ) << _ NUM ) +  Character . digit ( s . char At ( i + _ NUM ) , _ NUM ) ) ; } return data ; }
static  String path (  String uri ) { int i = uri . index Of ( _ STR ) ; if ( i == - _ NUM ) { i = _ NUM ; } else { i = uri . index Of ( _ STR , i + _ NUM ) ; if ( i == - _ NUM ) { return _ STR ; } } int query Start = uri . index Of ( _ STR , i ) ; if ( query Start == - _ NUM ) { query Start = uri . length ( ) ; } return uri . substring ( i , query Start ) ; }
public static boolean is Valid Name (  String str ) { if ( str . starts With ( _ STR ) && str . ends With ( _ STR ) ) { return is Java Valid Name ( str . substring ( _ NUM , str . length ( ) - _ NUM ) ) ; } return is Java Valid Name ( str ) && ! keys . contains ( str ) ; }
public boolean enter ( ) throws  Keeper Exception ,  Interrupted Exception { zoo Keeper . create ( root Path + _ STR + name , new byte [ _ NUM ] ,  Ids .  OPEN_ ACL_ UNSAFE ,  Create Mode .  EPHEMERAL ) ; while ( _ BOOL ) { synchronized ( mutex ) {  List <  String > list = zoo Keeper . get Children ( root Path , _ BOOL ) ; if ( list . size ( ) < size ) { mutex . wait ( ) ; } else { return _ BOOL ; } } } }
public  Select Clause add (  Expression expression ,  String as Name ) { select List . add ( new  Select Clause Expression ( expression , as Name ) ) ; return this ; }
public static void remove Plugins (  String interface Name ,  List <  String > names ) { for (  String name : names ) { remove Plugin ( interface Name , name ) ; } }
public static  String cut From Index Of (  String string , char c ) { int i = string . index Of ( c ) ; if ( i != - _ NUM ) { string = string . substring ( i ) ; } return string ; }
public void unregister (  String key ) throws  Registry Exception { try { registry . unbind ( key ) ; } catch (  Exception e ) { throw new  Registry Exception ( _ STR + key + _ STR , e ) ; } }
public void test Weakly Consistent Iteration ( ) { final  Linked Blocking Queue q = new  Linked Blocking Queue ( _ NUM ) ; q . add ( one ) ; q . add ( two ) ; q . add ( three ) ; for (  Iterator it = q . iterator ( ) ; it . has Next ( ) ; ) { q . remove ( ) ; it . next ( ) ; } assert Equals ( _ NUM , q . size ( ) ) ; }
@  Override public boolean has Permission (  U current User ,  String permission ) { log . debug ( _ STR + permission + _ STR + this + _ STR + current User ) ; decorate ( current User ) ; if ( permission . equals ( _ STR ) ) return editable ; return _ BOOL ; }
private void add Tv Show (  Tv Show tv Show ) { synchronized ( root ) {  Default Mutable Tree Node tv Show Node = new  Tv Show Tree Node ( tv Show ) ; root . add ( tv Show Node ) ; node Map . put ( tv Show , tv Show Node ) ; for (  Tv Show Season season : new  Array List < > ( tv Show . get Seasons ( ) ) ) {  Tv Show Season Tree Node season Node = (  Tv Show Season Tree Node ) node Map . get ( season ) ; if ( season Node == null ) { add Tv Show Season ( season , tv Show ) ; } for (  Tv Show Episode episode : new  Array List < > ( season . get Episodes ( ) ) ) { add Tv Show Episode ( episode , season ) ; } } int index = get Index Of Child ( root , tv Show Node ) ; if ( index > - _ NUM ) {  Tree Model Event event = new  Tree Model Event ( this , root . get Path ( ) , new int [ ] { index } , new  Object [ ] { tv Show } ) ; for (  Tree Model Listener listener : listeners ) { try { listener . tree Nodes Inserted ( event ) ; } catch (  Null Pointer Exception |  Array Index Out Of Bounds Exception ignored ) { } } } } tv Show . add Property Change Listener ( property Change Listener ) ; }
public  Compliance Feature check Policy State ( org . wso2 . emm . agent . beans .  Operation operation ) throws  Android Agent Exception { policy = new  Compliance Feature ( ) ; policy . set Feature Code ( operation . get Code ( ) ) ; switch ( operation . get Code ( ) ) { case  Constants .  Operation .  CAMERA : return check Camera Policy ( operation ) ; case  Constants .  Operation .  INSTALL_ APPLICATION : return check Install App Policy ( operation ) ; case  Constants .  Operation .  UNINSTALL_ APPLICATION : return check Uninstall App Policy ( operation ) ; case  Constants .  Operation .  ENCRYPT_ STORAGE : return check Encrypt Policy ( operation ) ; case  Constants .  Operation .  PASSCODE_ POLICY : return check Password Policy ( ) ; case  Constants .  Operation .  WIFI : return check Wifi Policy ( operation ) ; case  Constants .  Operation .  WORK_ PROFILE : return check Work Profile Policy ( operation ) ; case  Constants .  Operation .  DISALLOW_ ADJUST_ VOLUME : case  Constants .  Operation .  DISALLOW_ CONFIG_ BLUETOOTH : case  Constants .  Operation .  DISALLOW_ CONFIG_ CELL_ BROADCASTS : case  Constants .  Operation .  DISALLOW_ CONFIG_ CREDENTIALS : case  Constants .  Operation .  DISALLOW_ CONFIG_ MOBILE_ NETWORKS : case  Constants .  Operation .  DISALLOW_ CONFIG_ TETHERING : case  Constants .  Operation .  DISALLOW_ CONFIG_ VPN : case  Constants .  Operation .  DISALLOW_ CONFIG_ WIFI : case  Constants .  Operation .  DISALLOW_ APPS_ CONTROL : case  Constants .  Operation .  DISALLOW_ CREATE_ WINDOWS : case  Constants .  Operation .  DISALLOW_ CROSS_ PROFILE_ COPY_ PASTE : case  Constants .  Operation .  DISALLOW_ DEBUGGING_ FEATURES : ; case  Constants .  Operation .  DISALLOW_ FACTORY_ RESET : case  Constants .  Operation .  DISALLOW_ ADD_ USER : case  Constants .  Operation .  DISALLOW_ INSTALL_ APPS : case  Constants .  Operation .  DISALLOW_ INSTALL_ UNKNOWN_ SOURCES : case  Constants .  Operation .  DISALLOW_ MODIFY_ ACCOUNTS : case  Constants .  Operation .  DISALLOW_ MOUNT_ PHYSICAL_ MEDIA : case  Constants .  Operation .  DISALLOW_ NETWORK_ RESET : case  Constants .  Operation .  DISALLOW_ OUTGOING_ BEAM : case  Constants .  Operation .  DISALLOW_ OUTGOING_ CALLS : case  Constants .  Operation .  DISALLOW_ REMOVE_ USER : case  Constants .  Operation .  DISALLOW_ SAFE_ BOOT : case  Constants .  Operation .  DISALLOW_ SHARE_ LOCATION : case  Constants .  Operation .  DISALLOW_ SMS : case  Constants .  Operation .  DISALLOW_ UNINSTALL_ APPS : case  Constants .  Operation .  DISALLOW_ UNMUTE_ MICROPHONE : case  Constants .  Operation .  DISALLOW_ USB_ FILE_ TRANSFER : case  Constants .  Operation .  ALLOW_ PARENT_ PROFILE_ APP_ LINKING : case  Constants .  Operation .  ENSURE_ VERIFY_ APPS : case  Constants .  Operation .  AUTO_ TIME : case  Constants .  Operation .  ENABLE_ ADMIN : case  Constants .  Operation .  SET_ SCREEN_ CAPTURE_ DISABLED : case  Constants .  Operation .  SET_ STATUS_ BAR_ DISABLED : if ( application Manager . is Package Installed (  Constants .  SERVICE_ PACKAGE_ NAME ) ) {  Common Utils . call System App ( context , operation . get Code ( ) ,  Boolean . to String ( operation . is Enabled ( ) ) , null ) ; policy . set Compliance ( _ BOOL ) ; return policy ; } else { throw new  Android Agent Exception ( _ STR ) ; } case  Constants .  Operation .  APP_ RESTRICTION : return check App Restriction Policy ( operation ) ; default : throw new  Android Agent Exception ( _ STR ) ; } }
public static boolean is Uniform Collection (  Collection < ? > c ,  Class < ? > e ) { if ( e == null ) { throw new  Illegal Argument Exception ( _ STR ) ; } if ( c == null ) { throw new  Illegal Argument Exception ( _ STR ) ; } if ( c . is Empty ( ) ) { return _ BOOL ; } for (  Object o : c ) { if ( o == null || ! e . is Assignable From ( o . get Class ( ) ) ) { return _ BOOL ; } } return _ BOOL ; }
private void send Trap Message (  Snmp Message msg ) throws  IOException ,  Snmp Too Big Exception { byte [ ] buffer = new byte [ buffer Size ] ;  Datagram Packet packet = new  Datagram Packet ( buffer , buffer . length ) ; int encoding Length = msg . encode Message ( buffer ) ; packet . set Length ( encoding Length ) ; packet . set Address ( msg . address ) ; packet . set Port ( msg . port ) ; if (  SNMP_ ADAPTOR_ LOGGER . is Loggable (  Level .  FINER ) ) {  SNMP_ ADAPTOR_ LOGGER . logp (  Level .  FINER , dbg Tag , _ STR , _ STR + msg . address + _ STR + msg . port ) ; } trap Socket . send ( packet ) ; if (  SNMP_ ADAPTOR_ LOGGER . is Loggable (  Level .  FINER ) ) {  SNMP_ ADAPTOR_ LOGGER . logp (  Level .  FINER , dbg Tag , _ STR , _ STR + msg . address + _ STR + msg . port ) ; } snmp Out Traps ++ ; snmp Out Pkts ++ ; }
private  Scan State switch State (  Scan State desired ,  Enum Set <  Scan State > allowed ) { final  Scan State old ; final long timestamp ; final long sequence ; synchronized ( this ) { old = state ; if ( ! allowed . contains ( state ) ) throw new  Illegal State Exception ( state . to String ( ) ) ; state = desired ; timestamp =  System . current Time Millis ( ) ; sequence = get Next Seq Number ( ) ; }  LOG . fine ( _ STR + old + _ STR + desired ) ; if ( old != desired ) queue State Changed Notification ( sequence , timestamp , old , desired ) ; return old ; }
public  Resource from Properties (  Properties properties ) {  String name = properties . get Property (  Resource Property Set .  RESOURCE_ NAME ) ;  String type = properties . get Property (  Resource Property Set .  RESOURCE_ TYPE ) ;  Resource resource = new  Resource ( name , type ) ; if ( properties . contains Key (  Resource Property Set .  RESOURCE_ CLASS ) ) {  String class Name = properties . get Property (  Resource Property Set .  RESOURCE_ CLASS ) ; resource . set Class Name ( class Name ) ; } if ( properties . contains Key (  Resource Property Set .  RESOURCE_ ID ) ) {  String id = properties . get Property (  Resource Property Set .  RESOURCE_ ID ) ; resource . set Id ( id ) ; } else { resource . set Id ( create Id From Jndi Location If Not Null ( name ) ) ; }  String parameters As ASemicolon Delimited String = properties . get Property (  Resource Property Set .  PARAMETERS ) ; resource . set Parameters (  Property Utils . to Map ( get Parameters From String (  Property Utils . escape Back Slashes If Not Null ( parameters As ASemicolon Delimited String ) ) ) ) ; return resource ; }
public void add Handler (  String target ,  Synchronous Callback handler ) { handlers . put ( target , handler ) ; }
protected void do Print Classification (  Classifier classifier ,  Instance inst , int index ) throws  Exception { double [ ] d = classifier . distribution For Instance ( inst ) ; do Print Classification ( d , inst , index ) ; }
protected void finish (  Qualifier Hierarchy qual Hierarchy ,  Map <  Annotation Mirror ,  Set <  Annotation Mirror > > full Map ,  Map <  Annotation Mirror ,  Annotation Mirror > poly Qualifiers ,  Set <  Annotation Mirror > tops ,  Set <  Annotation Mirror > bottoms ,  Object ... args ) { }
public void process Game Event (  Game Event event ) { if ( game Listeners == null ) { game Listeners = new  Vector <  Game Listener > ( ) ; } for (  Enumeration <  Game Listener > e = game Listeners . elements ( ) ; e . has More Elements ( ) ; ) { event . fire Event ( e . next Element ( ) ) ; } }
public boolean is Valid ( int pixel ) { return ( ( pixel >= _ NUM && pixel < map_size ) && ( valid Bits == null || valid Bits . test Bit ( pixel ) ) ) ; }
private boolean check For Carry ( char [ ] ca1 , int icarry ) { boolean carry = _ BOOL ; if ( icarry < ca1 . length ) { if ( ca1 [ icarry ] == _ STR || ca1 [ icarry ] == _ STR || ca1 [ icarry ] == _ STR || ca1 [ icarry ] == _ STR ) carry = _ BOOL ; else if ( ca1 [ icarry ] == _ STR ) { int ii = icarry + _ NUM ; for ( ; ii < ca1 . length ; ii ++ ) if ( ca1 [ ii ] != _ STR ) break ; carry = ii < ca1 . length ; if ( ! carry && icarry > _ NUM ) { carry = ( ca1 [ icarry - _ NUM ] == _ STR || ca1 [ icarry - _ NUM ] == _ STR || ca1 [ icarry - _ NUM ] == _ STR || ca1 [ icarry - _ NUM ] == _ STR || ca1 [ icarry - _ NUM ] == _ STR ) ; } } } return carry ; }
private void add Component (  JPanel panel ,  Grid Bag Layout gbl ,  Component c , int x , int y , int width , int height , int fill , double weightx , double weighty ,  Insets insets ) {  Grid Bag Constraints gbc = new  Grid Bag Constraints ( ) ; gbc . gridx = x ; gbc . gridy = y ; gbc . gridwidth = width ; gbc . gridheight = height ; gbc . fill = fill ; gbc . weightx = weightx ; gbc . weighty = weighty ; gbc . insets = insets ; gbl . set Constraints ( c , gbc ) ; panel . add ( c ) ; }
public static boolean does File Exist (  String file Path And Name ) { if ( ( file Path And Name == null ) || file Path And Name . is Empty ( ) ) { return _ BOOL ; }  File file = new  File ( file Path And Name ) ; boolean does File Exist ; try { does File Exist = file . exists ( ) ; } catch (  Exception e ) { logger . debug ( e . to String ( ) +  System . line Separator ( ) +  Stack Trace . get String From Stack Trace ( e ) ) ; does File Exist = _ BOOL ; } return does File Exist ; }
public static void create Dir If Not Exists (  File dir ) throws  IOException { if ( ! dir . exists ( ) && ! dir . mkdirs ( ) ) { throw new  IOException ( _ STR + dir . to String ( ) ) ; } }
public static int execute Update Ex (  String sql ,  Object [ ] params ,  String trx Name , int time Out ) throws  DBException { if ( sql == null || sql . length ( ) == _ NUM ) throw new  Illegal Argument Exception ( _ STR + sql ) ; verify Trx ( trx Name , sql ) ; int no = - _ NUM ;  CPrepared Statement cs =  Proxy Factory . new CPrepared Statement (  Result Set .  TYPE_ FORWARD_ ONLY ,  Result Set .  CONCUR_ UPDATABLE , sql , trx Name ) ; try { set Parameters ( cs , params ) ; if ( time Out > _ NUM ) cs . set Query Timeout ( time Out ) ; no = cs . execute Update ( ) ; if ( trx Name == null ) { cs . commit ( ) ; } } catch (  Exception e ) { throw new  DBException ( e ) ; } finally {  DB . close ( cs ) ; } return no ; }
@  Nullable private static  Boolean find Path (  Instruction cur , int destination ,  Linked Hash Set <  Integer > fragment Insns , boolean was Outside ,  Hash Map <  Instruction ,  Boolean > visited ) { was Outside = was Outside || ! fragment Insns . contains ( cur . num ( ) ) ; visited . put ( cur , null ) ;  Iterable < ? extends  Instruction > instructions = cur . all Successors ( ) ; boolean path Exists = _ BOOL ; for (  Instruction i : instructions ) { if ( i . num ( ) == destination ) return was Outside ;  Boolean result ; if ( visited . contains Key ( i ) ) { result = visited . get ( i ) ; } else { result = find Path ( i , destination , fragment Insns , was Outside , visited ) ; visited . put ( i , result ) ; } if ( result != null ) { if ( result . boolean Value ( ) ) { visited . put ( cur , _ BOOL ) ; return _ BOOL ; } path Exists = _ BOOL ; } } if ( path Exists ) { visited . put ( cur , _ BOOL ) ; return _ BOOL ; } else { visited . put ( cur , null ) ; return null ; } }
public void register Text Flavor Properties (  String nat ,  String charset ,  String eoln ,  String terminators ) {  Long format = get Format For Native As Long ( nat ) ; text Natives . add ( format ) ; native Charsets . put ( format , ( charset != null && charset . length ( ) != _ NUM ) ? charset : get Default Text Charset ( ) ) ; if ( eoln != null && eoln . length ( ) != _ NUM && ! eoln . equals ( _ STR ) ) { native EOLNs . put ( format , eoln ) ; } if ( terminators != null && terminators . length ( ) != _ NUM ) {  Integer i Terminators =  Integer . value Of ( terminators ) ; if ( i Terminators . int Value ( ) > _ NUM ) { native Terminators . put ( format , i Terminators ) ; } } }
final int find Mark Adjust Index ( int search Index ) { search . index =  Math . max ( search Index , _ NUM ) ; int index = find Sort Index ( search ) ; for ( int i = index - _ NUM ; i >= _ NUM ; i -- ) {  Mark Data d = marks . element At ( i ) ; if ( d . index != search . index ) { break ; } index -= _ NUM ; } return index ; }
@  Nullable public static  String extract Class Name ( @  Not Null  String string ) {  String Builder sb = new  String Builder ( string . length ( ) ) ; int n = string . length ( ) ; int i = _ NUM ; for ( ; i < n ; i ++ ) { char c =  Character . to Upper Case ( string . char At ( i ) ) ; if (  Character . is Java Identifier Start ( c ) ) { sb . append ( c ) ; i ++ ; break ; } } if ( sb . length ( ) > _ NUM ) { for ( ; i < n ; i ++ ) { char c = string . char At ( i ) ; if (  Character . is Java Identifier Part ( c ) ) { sb . append ( c ) ; } } return sb . to String ( ) ; } return null ; }
protected  String is Valid Placement ( final  Collection <  Unit > units , final  Territory at , final  Player ID player ) {  String error = player Has Enough Units ( units , at , player ) ; if ( error != null ) { return error ; } error = can Produce ( at , units , player ) ; if ( error != null ) { return error ; } error = check Production ( at , units , player ) ; if ( error != null ) { return error ; } error = can Units Be Placed ( at , units , player ) ; if ( error != null ) { return error ; } return null ; }
public static void remove Activity Listener (  Activity Listener listener ) { listeners . remove ( listener ) ; }
public void add Muted Mac ( final  String mac , final  Date mute Till ) { if ( is Mac Muted ( mac ) ) { remove Muted Mac ( mac ) ; }  Timestamp mute Till Ts = null ; if ( mute Till != null ) { mute Till Ts = new  Timestamp ( mute Till . get Time ( ) ) ; } s_logger . fine ( _ STR + mac ) ; final  Connection con =  Database . get Connection ( ) ; try { final  Prepared Statement ps = con . prepare Statement ( _ STR ) ; ps . set String ( _ NUM , mac ) ; ps . set Timestamp ( _ NUM , mute Till Ts ) ; ps . execute ( ) ; ps . close ( ) ; con . commit ( ) ; } catch ( final  SQLException sqle ) { if ( sqle . get Error Code ( ) == _ NUM ) { s_logger . info ( _ STR + mac + _ STR + sqle . get Message ( ) ) ; return ; } s_logger . log (  Level .  SEVERE , _ STR + mac , sqle ) ; throw new  Illegal State Exception ( sqle . get Message ( ) ) ; } finally {  Db Util . close Connection ( con ) ; } }
private  Response <  Bitmap > do Parse (  Network Response response ) { byte [ ] data = response . data ;  Bitmap Factory .  Options decode Options = new  Bitmap Factory .  Options ( ) ;  Bitmap bitmap = null ; if ( m Max Width == _ NUM && m Max Height == _ NUM ) { decode Options . in Preferred Config = m Decode Config ; bitmap =  Bitmap Factory . decode Byte Array ( data , _ NUM , data . length , decode Options ) ; } else { decode Options . in Just Decode Bounds = _ BOOL ;  Bitmap Factory . decode Byte Array ( data , _ NUM , data . length , decode Options ) ; int actual Width = decode Options . out Width ; int actual Height = decode Options . out Height ; int desired Width = get Resized Dimension ( m Max Width , m Max Height , actual Width , actual Height , m Scale Type ) ; int desired Height = get Resized Dimension ( m Max Height , m Max Width , actual Height , actual Width , m Scale Type ) ; decode Options . in Just Decode Bounds = _ BOOL ; decode Options . in Sample Size = find Best Sample Size ( actual Width , actual Height , desired Width , desired Height ) ;  Bitmap temp Bitmap =  Bitmap Factory . decode Byte Array ( data , _ NUM , data . length , decode Options ) ; if ( temp Bitmap != null && ( temp Bitmap . get Width ( ) > desired Width || temp Bitmap . get Height ( ) > desired Height ) ) { bitmap =  Bitmap . create Scaled Bitmap ( temp Bitmap , desired Width , desired Height , _ BOOL ) ; temp Bitmap . recycle ( ) ; } else { bitmap = temp Bitmap ; } } if ( bitmap == null ) { return  Response . error ( new  Parse Error ( response ) ) ; } else { return  Response . success ( bitmap ,  Http Header Parser . parse Cache Headers ( response ) ) ; } }
public boolean has Update Listeners ( ) { boolean is Empty = ! listeners . is Empty ( ) ; return is Empty ; }
@  Override public void close ( ) throws  IOException { if ( ! closed ) { finish ( ) ; inf . end ( ) ; out . close ( ) ; closed = _ BOOL ; } }
private void put Result Into Cache (  String token Id Str ,  String resource ,  Map env Params ,  Policy Decision pd ) throws  SSOException ,  Delegation Exception { if ( resource != null ) {  List <  Object > al = new  Array List <  Object > ( _ NUM ) ; al . add ( _ NUM , env Params ) ; al . add ( _ NUM , pd ) ; synchronized ( delegation Cache ) {  Map <  String ,  List <  Object > > items = delegation Cache . get ( token Id Str ) ; if ( items == null ) { items =  Collections . synchronized Map ( new  Hash Map <  String ,  List <  Object > > ( ) ) ; delegation Cache . put ( token Id Str , items ) ; } items . put ( resource , al ) ; } } }
public void next Bytes ( byte [ ] bytes ) { final int length = bytes . length ; for ( int i = _ NUM ; i < length ; ) { for ( int rnd = next Int ( ) , n =  Math . min ( length - i ,  INTEGER_ SIZE /  BYTE_ SIZE ) ; n -- > _ NUM ; rnd >>=  BYTE_ SIZE ) { bytes [ i ++ ] = ( byte ) rnd ; } } }
private void draw Low Far Out ( double a Radius ,  Graphics2 D g2 , double xx , double m ) { double side = a Radius * _ NUM ; g2 . draw ( new  Line2 D .  Double ( xx - side , m - side , xx + side , m - side ) ) ; g2 . draw ( new  Line2 D .  Double ( xx - side , m - side , xx , m ) ) ; g2 . draw ( new  Line2 D .  Double ( xx + side , m - side , xx , m ) ) ; }
private  Set <  Object Instance > object Instances From Filtered Named Objects (  Set <  Named Object > list ,  Query Exp query ) {  Set <  Object Instance > result = new  Hash Set <  Object Instance > ( ) ; if ( query == null ) { for (  Named Object no : list ) { final  Dynamic MBean obj = no . get Object ( ) ; final  String class Name = safe Get Class Name ( obj ) ; result . add ( new  Object Instance ( no . get Name ( ) , class Name ) ) ; } } else {  MBean Server old Server =  Query Eval . get MBean Server ( ) ; query . set MBean Server ( server ) ; try { for (  Named Object no : list ) { final  Dynamic MBean obj = no . get Object ( ) ; boolean res ; try { res = query . apply ( no . get Name ( ) ) ; } catch (  Exception e ) { res = _ BOOL ; } if ( res ) {  String class Name = safe Get Class Name ( obj ) ; result . add ( new  Object Instance ( no . get Name ( ) , class Name ) ) ; } } } finally { query . set MBean Server ( old Server ) ; } } return result ; }
private  Element create Indexed End Point (  String name ,  String attr Binding ,  String attr Location ,  String attr Response Location , int index ,  Boolean is Default ) throws  DOMException { if ( name == null ) { throw new  Illegal Argument Exception ( _ STR ) ; } if ( attr Binding == null ) { throw new  Illegal Argument Exception ( _ STR ) ; } if ( attr Location == null ) { throw new  Illegal Argument Exception ( _ STR ) ; }  Element indexed End Pt = doc . create Element ( name ) ; indexed End Pt . set Attribute (  SAMLNames .  BINDING , attr Binding ) ; indexed End Pt . set Attribute (  SAMLNames .  LOCATION , attr Location ) ; if ( attr Response Location != null ) { indexed End Pt . set Attribute (  SAMLNames .  RESPLOC , attr Response Location ) ; } indexed End Pt . set Attribute (  SAMLNames .  INDEX ,  String . value Of ( index ) ) ; if ( is Default != null ) { indexed End Pt . set Attribute (  SAMLNames .  ISDEFAULT , is Default . to String ( ) ) ; } return indexed End Pt ; }
public static void copy Files ( final  File src , final  File dest ) throws  IOException { if ( ! src . exists ( ) ) { throw new  IOException ( _ STR + src . get Absolute Path ( ) ) ; } else if ( ! src . can Read ( ) ) { throw new  IOException ( _ STR + src . get Absolute Path ( ) + _ STR ) ; } final  List <  String > no Copy =  Arrays . as List ( _ STR , _ STR , _ STR , _ STR , _ STR ) ; if ( src . is Directory ( ) ) { if ( no Copy . contains ( src . get Name ( ) ) ) return ; if ( ! dest . exists ( ) ) { if ( ! dest . mkdirs ( ) ) { throw new  IOException ( _ STR + dest . get Absolute Path ( ) ) ; } } final  String list [ ] = src . list ( ) ; if ( list != null ) for ( int i = _ NUM ; i < list . length ; i ++ ) { final  File dest1 = new  File ( dest , list [ i ] ) ; final  File src1 = new  File ( src , list [ i ] ) ; copy Files ( src1 , dest1 ) ; } } else { final byte [ ] buffer = new byte [ _ NUM ] ; int bytes Read ; try (  File Input Stream fin = new  File Input Stream ( src ) ;  File Output Stream fout = new  File Output Stream ( dest ) ) { while ( ( bytes Read = fin . read ( buffer ) ) >= _ NUM ) { fout . write ( buffer , _ NUM , bytes Read ) ; } } catch ( final  IOException e ) { final  IOException wrapper = new  IOException ( _ STR + src . get Absolute Path ( ) + _ STR + dest . get Absolute Path ( ) ) ; wrapper . init Cause ( e ) ; wrapper . set Stack Trace ( e . get Stack Trace ( ) ) ; throw wrapper ; } } }
public  String to String ( ) {  String Buffer buffer = new  String Buffer ( ) ; buffer . append ( to String ( get Class ( ) ) ) ; buffer . append ( _ STR ) ; buffer . append ( is Use Default ( ) ) ; buffer . append ( _ STR ) ; buffer . append ( use Locale Format ) ; if ( display Patterns != null ) { buffer . append ( _ STR ) ; buffer . append ( display Patterns ) ; buffer . append ( _ STR ) ; } if ( locale != null ) { buffer . append ( _ STR ) ; buffer . append ( locale ) ; } if ( time Zone != null ) { buffer . append ( _ STR ) ; buffer . append ( time Zone ) ; } buffer . append ( _ STR ) ; return buffer . to String ( ) ; }
public void test_multiple Resource Locking_resources3_locktries_3 ( ) throws  Exception {  Properties properties = new  Properties ( ) ; properties . set Property (  Test Options .  NTHREADS , _ STR ) ; properties . set Property (  Test Options .  NTASKS , _ STR ) ; properties . set Property (  Test Options .  NRESOURCES , _ STR ) ; properties . set Property (  Test Options .  MIN_ LOCKS , _ STR ) ; properties . set Property (  Test Options .  MAX_ LOCKS , _ STR ) ; properties . set Property (  Test Options .  MAX_ LOCK_ TRIES , _ STR ) ; properties . set Property (  Test Options .  PREDECLARE_ LOCKS , _ STR ) ; properties . set Property (  Test Options .  SORT_ LOCK_ REQUESTS , _ STR ) ; do Comparison Test ( properties ) ; }
public static byte [ ] flatten Bitmap (  Bitmap bitmap ) { int size = bitmap . get Width ( ) * bitmap . get Height ( ) * _ NUM ;  Byte Array Output Stream out = new  Byte Array Output Stream ( size ) ; try { bitmap . compress (  Bitmap .  Compress Format .  PNG , _ NUM , out ) ; out . flush ( ) ; out . close ( ) ; return out . to Byte Array ( ) ; } catch (  IOException e ) {  Log . w (  TAG , _ STR ) ; return null ; } }
public void write Jar From Content ( final  String class Name , final  String content , final  File output File ) throws  IOException {  File Output Stream file Output Stream = new  File Output Stream ( output File ) ; write Jar From Content ( class Name , content , file Output Stream ) ; file Output Stream . close ( ) ; }
@  Override public  Enumeration <  Option > list Options ( ) {  Vector <  Option > new Vector = new  Vector <  Option > ( ) ; new Vector . add Element ( new  Option ( _ STR + _ STR , _ STR , _ NUM , _ STR ) ) ; new Vector . add Element ( new  Option ( _ STR , _ STR , _ NUM , _ STR ) ) ; new Vector . add All (  Collections . list ( super . list Options ( ) ) ) ; return new Vector . elements ( ) ; }
public void read Nodes ( final int [ ] columns Indices , final  Buffered Reader reader ) throws  IOException {  String line = reader . read Line ( ) ; while ( line != null && line . length ( ) > _ NUM ) { final  String [ ] parts = line . split ( _ STR ) ;  Node node =  Network Utils . create Node (  Id . create Node Id ( parts [ columns Indices [ _ NUM ] ] ) ) ; node . set Coord ( new  Coord (  Double . parse Double ( parts [ columns Indices [ _ NUM ] ] ) ,  Double . parse Double ( parts [ columns Indices [ _ NUM ] ] ) ) ) ; network . add Node ( node ) ; line = reader . read Line ( ) ; } }
protected static void place Some Terrain (  IBoard board , int terrain Type , int prob More , int min Hexes , int max Hexes ,  Hash Map <  IHex ,  Point > reverse Hex , boolean exclusive ) {  Point p = new  Point (  Compute . random Int ( board . get Width ( ) ) ,  Compute . random Int ( board . get Height ( ) ) ) ; int count = min Hexes ; if ( ( max Hexes - min Hexes ) > _ NUM ) { count +=  Compute . random Int ( max Hexes - min Hexes ) ; }  IHex field ;  Hash Set <  IHex > already Used = new  Hash Set <  IHex > ( ) ;  Hash Set <  IHex > un Used = new  Hash Set <  IHex > ( ) ; field = board . get Hex ( p . x , p . y ) ; if ( ! field . contains Terrain ( terrain Type ) ) { un Used . add ( field ) ; } else { find All Unused ( board , terrain Type , already Used , un Used , field , reverse Hex ) ; }  ITerrain Factory f =  Terrains . get Terrain Factory ( ) ; for ( int i = _ NUM ; i < count ; i ++ ) { if ( un Used . is Empty ( ) ) { return ; } int which =  Compute . random Int ( un Used . size ( ) ) ;  Iterator <  IHex > iter = un Used . iterator ( ) ; for ( int n = _ NUM ; n < ( which - _ NUM ) ; n ++ ) { iter . next ( ) ; } field = iter . next ( ) ; if ( exclusive ) { field . remove All Terrains ( ) ; } int temp Int = (  Compute . random Int ( _ NUM ) < prob More ) ? _ NUM : _ NUM ;  ITerrain temp Terrain = f . create Terrain ( terrain Type , temp Int ) ; field . add Terrain ( temp Terrain ) ; un Used . remove ( field ) ; find All Unused ( board , terrain Type , already Used , un Used , field , reverse Hex ) ; } if ( terrain Type ==  Terrains .  WATER ) { int min =  Integer .  MAX_ VALUE ;  Iterator <  IHex > iter = un Used . iterator ( ) ; while ( iter . has Next ( ) ) { field = iter . next ( ) ; if ( field . get Level ( ) < min ) { min = field . get Level ( ) ; } } iter = already Used . iterator ( ) ; while ( iter . has Next ( ) ) { field = iter . next ( ) ; field . set Level ( min ) ; } } }
public boolean remove Module (  Module Handle module Handle ) { boolean no Loaded Modules = _ BOOL ; boolean was Module Removed = _ BOOL ; synchronized ( private Instance Lock ) { if ( modules . remove ( module Handle ) ) { was Module Removed = _ BOOL ; no Loaded Modules = ( modules . size ( ) == _ NUM ) ; } } if ( no Loaded Modules ) { set Terminated ( _ BOOL ) ; } return was Module Removed ; }
private static void expand2 Digit Number (  String number String ,  Word Relation word Relation ) { if ( number String . char At ( _ NUM ) == _ STR ) { if ( number String . char At ( _ NUM ) == _ STR ) { } else {  String number = digit2num [ number String . char At ( _ NUM ) - _ STR ] ; word Relation . add Word ( number ) ; } } else if ( number String . char At ( _ NUM ) == _ STR ) {  String number = digit2enty [ number String . char At ( _ NUM ) - _ STR ] ; word Relation . add Word ( number ) ; } else if ( number String . char At ( _ NUM ) == _ STR ) {  String number = digit2teen [ number String . char At ( _ NUM ) - _ STR ] ; word Relation . add Word ( number ) ; } else {  String enty = digit2enty [ number String . char At ( _ NUM ) - _ STR ] ; word Relation . add Word ( enty ) ; expand Digits ( number String . substring ( _ NUM , number String . length ( ) ) , word Relation ) ; } }
protected int find UTCSign (  String buffer , int start , int end ) { int c ; for ( int i = start ; i < end ; i ++ ) { c = buffer . char At ( i ) ; if ( c == _ STR || c == _ STR || c == _ STR ) { return i ; } } return - _ NUM ; }
@  Override public boolean is Enabled ( ) { if ( ( attribute Selection Panel != null ) && ! is Value Only ( ) ) { return attribute Selection Panel . is Enabled ( ) ; } else { if ( this . check Box != null ) { return check Box . is Enabled ( ) ; } } return _ BOOL ; }
public double pdf ( double x ) { double diff = x - mean ; return  SQRT_ INV *  Math . exp ( - ( diff * diff ) / ( _ NUM * variance ) ) ; }
private void handle Json Create Quotation (  Request And Response request And Response ) throws  IOException ,  Servlet Exception { request And Response . set Response Content Type Json ( ) ;  String url ;  String title ;  String quotation ;  String note ;  String session Id ; try { final  Json Node Helper json = get Json Node ( request And Response ) ; url = json . get String (  Db Logic .  Constants . url ) ; title = json . get String (  Db Logic .  Constants . title ) ; quotation = json . get String (  Db Logic .  Constants . quotation ) ; note = json . get String (  Db Logic .  Constants . note ) ; session Id = json . get String ( _ STR ) ; } catch ( final  IOException e ) { return Json400 ( request And Response , servlet Text . error Json ( ) ) ; return ; } if ( !  Entry Attribute Validator . is Note Valid ( note ) ) { return Json400 ( request And Response , servlet Text . error Note Is Invalid ( ) ) ; return ; } if ( !  Entry Attribute Validator . is Quotation Valid ( quotation ) ) { return Json400 ( request And Response , servlet Text . error Quotation Is Invalid ( ) ) ; return ; } if ( !  Entry Attribute Validator . is Url Valid ( url ) ) { return Json400 ( request And Response , servlet Text . error Url Is Invalid ( ) ) ; return ; } if ( !  Entry Attribute Validator . is Source Title Valid ( title ) ) { return Json400 ( request And Response , servlet Text . error Title Is Invalid ( ) ) ; return ; } final  Errors errors = new  Errors ( ) ; try { final  Long time = new  Long (  System . current Time Millis ( ) ) ;  String user Id = null ; if ( session Manager != null ) { final  Http Session session = session Manager . get Session ( session Id ) ; if ( session != null && session . get Attribute ( session User Id Attribute ) != null ) { user Id = (  String ) session . get Attribute ( session User Id Attribute ) ; } } final  User user = db Logic . get User By Id ( user Id ) ; if ( user == null ) { return Json400 ( request And Response , servlet Text . error No Account Found ( ) ) ; return ; } if ( user . get Is Account Closed ( ) ) { return Json400 ( request And Response , servlet Text . error Account Is Closed ( ) ) ; return ; } final  Entry source = db Logic . update Or Create Source ( user , null , url , title , time , time , is User An Admin ( request And Response ) , errors ) ; if ( source == null ) { return Json400 ( request And Response , errors ) ; return ; } final  Entry entry = db Logic . create Entry Quotation ( user , source , quotation , note , time , is User An Admin ( request And Response ) , errors ) ; if ( entry == null ) { return Json400 ( request And Response , errors ) ; return ; } request And Response . print ( _ STR + _ STR + entry . get Id ( ) + _ STR + _ STR + source . get Id ( ) + _ STR ) ; db Logic . commit ( ) ; } catch ( final  Persistence Exception e ) { logger . log (  Level .  INFO , _ STR , e ) ; return Json500 ( request And Response , servlet Text . error Internal Database ( ) ) ; } }
@  Override public void send Train List ( ) {  List <  Train > train List = tm . get Trains By Name List ( ) ;  Array List <  Attribute > a Train ; for (  Train train : train List ) { a Train = new  Array List <  Attribute > ( _ NUM ) ; a Train . add ( new  Attribute (  TRAINS , train . get Name ( ) ) ) ; try { send Message ( a Train ) ; } catch (  IOException ioe ) { log . debug ( _ STR + train . get Name ( ) ) ; } } }
@  Override public boolean execute ( @  Not Null  Psi Element pe , @  Not Null  Resolve State state ) { if ( pe instanceof  Psi Variable ) { final  Psi Variable pvar = (  Psi Variable ) pe ; final  String pvar_name = pvar . get Name ( ) ; if ( pvar_name . starts With ( my Prefix ) ) { if ( ! my Static Sensitive Flag || ( ! my Static Scope Flag || pvar . has Modifier Property (  Psi Modifier .  STATIC ) ) ) { my Result List . add ( pvar ) ; } } } return _ BOOL ; }
static public  Input Stream find Cluster XSLSchema (  String _cluster XSLSchema ) throws  Cluster Configuration Exception {  String schema Name To Be Used = _cluster XSLSchema ; if ( schema Name To Be Used . equals Ignore Case (  Cluster XML .  CLUSTER_ SCHEMA_ NAME_ PARTITIONED_ SYNC2 BACKUP ) ) schema Name To Be Used =  Cluster XML .  CLUSTER_ SCHEMA_ NAME_ PARTITIONED ;  Input Stream schema Input Stream ;  String schema File Path =  Constants .  Container .  CONTAINER_ CONFIG_ DIRECTORY + _ STR +  Constants .  Schemas .  SCHEMAS_ FOLDER + _ STR + schema Name To Be Used +  Cluster XML .  CLUSTER_ SCHEMA_ XSL_ FILE_ SUFFIX ; schema Input Stream = get Resource Stream ( schema File Path ) ; if ( schema Input Stream != null ) { if ( _logger . is Loggable (  Level .  FINE ) ) { _logger . fine ( _ STR + get Resource URL ( schema File Path ) + _ STR ) ; } return schema Input Stream ; } else {  String missing Schema Msg = _ STR + _cluster XSLSchema ; throw new  Cluster Configuration Exception ( missing Schema Msg ) ; } }
public static  Async World wrap (  World world ) { if ( world instanceof  Async World ) { return (  Async World ) world ; } return new  Async World ( world , _ BOOL ) ; }
public void clear ( ) {  Arrays . fill ( ritems , _ NUM , rsize , null ) ;  Arrays . fill ( pitems , _ NUM , psize , null ) ; rsize = _ NUM ; psize = _ NUM ; psorted = _ BOOL ; }
private  String parse Format Description ( final  String pattern , final  Parse Position pos ) { final int start = pos . get Index ( ) ; seek Non Ws ( pattern , pos ) ; final int text = pos . get Index ( ) ; int depth = _ NUM ; for ( ; pos . get Index ( ) < pattern . length ( ) ; next ( pos ) ) { switch ( pattern . char At ( pos . get Index ( ) ) ) { case  START_ FE : depth ++ ; break ; case  END_ FE : depth -- ; if ( depth == _ NUM ) { return pattern . substring ( text , pos . get Index ( ) ) ; } break ; case  QUOTE : get Quoted String ( pattern , pos ) ; break ; default : break ; } } throw new  Illegal Argument Exception ( _ STR + start ) ; }
@  Override public void write ( byte [ ] buf , int offset , int length , boolean is End ) throws  IOException { if ( _os == null ) { if ( _s == null ) { return ; } _os = _s . get Output Stream ( ) ; } try { _needs Flush = _ BOOL ; _os . write ( buf , offset , length ) ; _total Write Bytes += length ; } catch (  IOException e ) {  IOException exn =  Client Disconnect Exception . create ( this + _ STR + e , e ) ; try { close ( ) ; } catch (  IOException e1 ) { } throw exn ; } }
protected  String generate Label String (  Category Dataset dataset , int row , int column ) {  Param Checks . null Not Permitted ( dataset , _ STR ) ;  String result ;  Object [ ] items = create Item Array ( dataset , row , column ) ; result =  Message Format . format ( this . label Format , items ) ; return result ; }
protected abstract void loop ( ) ;
public  Process exec (  String [ ] prog Array ) throws java . io .  IOException { return exec ( prog Array , null , null ) ; }
public void load (  File file ) throws  IOException {  Input Stream in Stream = new  File Input Stream ( file ) ; properties . load ( in Stream ) ; }
public void initialize Document (  Document doc ) {  Map <  String ,  Double > d = new  Hashtable <  String ,  Double > ( ) ; double num Docs = wordlex == null ? _ NUM : wordlex . get Num Docs ( ) ; for ( int i = _ NUM ; i < doc . tags . length ; i ++ ) { if ( wordlex == null ) { int rindex = random . next Int ( doc . words . length + _ NUM ) ; if ( rindex < doc . words . length ) { doc . reason [ i ] = doc . words [ rindex ] ; } else { doc . reason [ i ] =  Tag Allocation Model .  NOISE ; } } else { d . clear ( ) ; double sample Weight = _ NUM ; for ( int j = _ NUM ; j < doc . words . length ; j ++ ) {  Word w = wordlex . get Word ( doc . words [ j ] ) ; if ( w != null ) { double idf = num Docs / w . get Document Frequency ( ) ; d . put ( doc . words [ j ] , idf ) ; sample Weight += idf ; } } d . put (  Tag Allocation Model .  NOISE , sample Weight / d . size ( ) ) ; doc . reason [ i ] = sample ( d ) ; } if ( ! locked ) { ntw . inc ( doc . tags [ i ] , doc . reason [ i ] , _ NUM ) ; } } for (  String word : doc . words ) { nw . inc ( word , doc . tags . length ) ; } }
public  Notifications action (  Action ... actions ) { this . actions = actions == null ?  FXCollections . <  Action > observable Array List ( ) :  FXCollections . observable Array List ( actions ) ; return this ; }
public  List <  String > word Break (  String s ,  Set <  String > dict ) {  List <  String > words = new  Array List <  String > ( ) ; int len = s . length ( ) ; for ( int i = _ NUM ; i <= len ; i ++ ) {  String pref = s . substring ( _ NUM , i ) ; if ( dict . contains ( pref ) ) { if ( i == len ) { words . add ( pref ) ; } else {  String remain = s . substring ( i , len ) ;  List <  String > remain Decomp = res . contains Key ( remain ) ? res . get ( remain ) : word Break ( remain , dict ) ; if ( remain Decomp != null ) { for (  String w : remain Decomp ) { words . add ( pref + _ STR + w ) ; } res . put ( remain , remain Decomp ) ; } } } } return words ; }
public int do Final ( byte [ ] out , int out Off ) { byte padding Byte = ( byte ) (  M . length - m Off ) ; for ( int i = m Off ; i <  M . length ; i ++ ) {  M [ i ] = padding Byte ; } process Check Sum (  M ) ; process Block (  M ) ; process Block (  C ) ;  System . arraycopy (  X , x Off , out , out Off , _ NUM ) ; reset ( ) ; return  DIGEST_ LENGTH ; }
protected void wait For Messages To Be Delivered ( ) { long max Wait Time = _ NUM ; long wait Time = max Wait Time ; long start = ( max Wait Time <= _ NUM ) ? _ NUM :  System . current Time Millis ( ) ; synchronized ( lock ) { while ( messages . size ( ) < data . length && wait Time >= _ NUM ) { try { lock . wait ( _ NUM ) ; } catch (  Interrupted Exception e ) { e . print Stack Trace ( ) ; } wait Time = max Wait Time - (  System . current Time Millis ( ) - start ) ; } } }
public static  Date parse ISO ( final  String str ) {  QL . require ( str . length ( ) == _ NUM && str . char At ( _ NUM ) == _ STR && str . char At ( _ NUM ) == _ STR , _ STR ) ; final int year =  Integer . parse Int ( str . substring ( _ NUM , _ NUM ) ) ; final int month =  Integer . parse Int ( str . substring ( _ NUM , _ NUM ) ) ; final int day =  Integer . parse Int ( str . substring ( _ NUM , _ NUM ) ) ; final  Date date = new  Date ( day ,  Month . value Of ( month ) , year ) ; return date ; }
public static void move File ( final  File src , final  File dst ) throws  IOException { copy File ( src , dst ) ; src . delete ( ) ; }
public  Map (  Pokemon Go api ) { this . api = api ; cached Map Objects = new  Map Objects ( api ) ; last Map Update = _ NUM ; }
public void test Sorts Same Attributes ( ) throws  Exception {  Xpp Dom dom1 =  Xpp Factory . build Dom ( _ STR ) ;  Xpp Dom dom2 =  Xpp Factory . build Dom ( _ STR ) ; assert Equals ( - _ NUM , comparator . compare ( dom1 , dom2 ) ) ; assert Equals ( _ STR , xpath . get ( ) ) ; assert Equals ( _ NUM , comparator . compare ( dom2 , dom1 ) ) ; assert Equals ( _ STR , xpath . get ( ) ) ; }
public static  Endpoint Entry lookup (  Endpoint ep ) { synchronized ( endpoint Table ) {  Endpoint Entry entry = endpoint Table . get ( ep ) ; if ( entry == null ) { entry = new  Endpoint Entry ( ep ) ; endpoint Table . put ( ep , entry ) ; if ( gc Latency Request == null ) { gc Latency Request =  GC . request Latency ( gc Interval ) ; } } return entry ; } }
boolean name Refs Are Legal ( ) { assert ( arity >= _ NUM && arity <= names . length ) ; assert ( result >= - _ NUM && result < names . length ) ; for ( int i = _ NUM ; i < arity ; i ++ ) {  Name n = names [ i ] ; assert ( n . index ( ) == i ) :  Arrays . as List ( n . index ( ) , i ) ; assert ( n . is Param ( ) ) ; } for ( int i = arity ; i < names . length ; i ++ ) {  Name n = names [ i ] ; assert ( n . index ( ) == i ) ; for (  Object arg : n . arguments ) { if ( arg instanceof  Name ) {  Name n2 = (  Name ) arg ; int i2 = n2 . index ; assert ( _ NUM <= i2 && i2 < names . length ) : n . debug String ( ) + _ STR + i2 + _ STR + names . length ; assert ( names [ i2 ] == n2 ) :  Arrays . as List ( _ STR , i , _ STR , n . debug String ( ) , _ STR , i2 , _ STR , n2 . debug String ( ) , _ STR , names [ i2 ] . debug String ( ) , _ STR , this ) ; assert ( i2 < i ) ; } } } return _ BOOL ; }
public void remove Value From Domain (  Variable var ,  Object value ) {  Domain curr Domain = get Domain ( var ) ;  List <  Object > values = new  Array List <  Object > ( curr Domain . size ( ) ) ; for (  Object v : curr Domain ) if ( ! v . equals ( value ) ) values . add ( v ) ; set Domain ( var , new  Domain ( values ) ) ; }
private void sort ( int column Index , int sort Count ) {  Sort Order order =  Sort Order . values ( ) [ sort Count % _ NUM ] ;  List <  Row Sorter .  Sort Key > sort Keys = new  Array List < > ( ) ; if ( column Index != _ NUM ) { sort Keys . add ( new  Row Sorter .  Sort Key ( _ NUM ,  Sort Order .  DESCENDING ) ) ; } sort Keys . add ( new  Row Sorter .  Sort Key ( column Index , order ) ) ; sorter . set Sort Keys ( sort Keys ) ; this . sort Count = sort Count ; sorted Column = column Index ; }
private void upload ( ) throws  Exception { final  String zookeeper Url = topology Properties . get Property (  Kafka With ZKComponent .  ZOOKEEPER_ PROPERTY ) ; try (  Curator Framework client = get Client ( zookeeper Url ) ) { client . start ( ) ; upload Global Config ( client ) ; upload Profiler Config ( client ) ; } }
public void add Cell ( final  String cell Content ) { tool Tip . append ( _ STR ) ; tool Tip . append ( cell Content ) ; tool Tip . append ( _ STR ) ; }
public static void copy Properties (  Properties from ,  Properties to ) {  Enumeration <  Object > keys = from . keys ( ) ; while ( keys . has More Elements ( ) ) {  String key = (  String ) keys . next Element ( ) ; to . put ( key , from . get Property ( key ) ) ; } }
@  Override public void close ( ) throws  IOException { if ( in != null ) { in . close ( ) ; in = null ; buf = null ; } }
private static  SSLSocket Factory trust All Hosts (  Https URLConnection connection ) {  SSLSocket Factory old Factory = connection . get SSLSocket Factory ( ) ; try {  SSLContext sc =  SSLContext . get Instance ( _ STR ) ; sc . init ( null , trust All Certs , new java . security .  Secure Random ( ) ) ;  SSLSocket Factory new Factory = sc . get Socket Factory ( ) ; connection . set SSLSocket Factory ( new Factory ) ; } catch (  Exception e ) {  Log . e (  LOG_ TAG , e . get Message ( ) , e ) ; } return old Factory ; }
@  Transactional public void process Success Msg ( final  Receipt Header online Payment Receipt Header , final  Payment Response payment Response ) { final  List <  Receipt Detail > existing Receipt Details = new  Array List <  Receipt Detail > ( _ NUM ) ; for ( final  Receipt Detail receipt Detail : online Payment Receipt Header . get Receipt Details ( ) ) if ( !  Financials Util . is Revenue Account Head ( receipt Detail . get Accounthead ( ) , chart Of Accounts Hibernate DAO . get Bank Chartof Account Code List ( ) , persistence Service ) ) { final  Receipt Detail new Receipt Detail = new  Receipt Detail ( ) ; if ( receipt Detail . get Ordernumber ( ) != null ) new Receipt Detail . set Ordernumber ( receipt Detail . get Ordernumber ( ) ) ; if ( receipt Detail . get Description ( ) != null ) new Receipt Detail . set Description ( receipt Detail . get Description ( ) ) ; if ( receipt Detail . get Is Actual Demand ( ) != null ) new Receipt Detail . set Is Actual Demand ( receipt Detail . get Is Actual Demand ( ) ) ; if ( receipt Detail . get Function ( ) != null ) new Receipt Detail . set Function ( receipt Detail . get Function ( ) ) ; if ( receipt Detail . get Cramount To Be Paid ( ) != null ) new Receipt Detail . set Cramount To Be Paid ( receipt Detail . get Cramount To Be Paid ( ) ) ; new Receipt Detail . set Cramount ( receipt Detail . get Cramount ( ) ) ; new Receipt Detail . set Accounthead ( receipt Detail . get Accounthead ( ) ) ; new Receipt Detail . set Dramount ( receipt Detail . get Dramount ( ) ) ; new Receipt Detail . set Purpose ( receipt Detail . get Purpose ( ) ) ; existing Receipt Details . add ( new Receipt Detail ) ; } final  List <  Receipt Detail > reconstructed List = collections Util . reconstruct Receipt Detail ( online Payment Receipt Header , existing Receipt Details ) ;  Receipt Detail debit Account Detail = null ; if ( reconstructed List != null ) debit Account Detail = collection Common . add Debit Account Head Details ( online Payment Receipt Header . get Total Amount ( ) , online Payment Receipt Header ,  Big Decimal .  ZERO , online Payment Receipt Header . get Total Amount ( ) ,  Collection Constants .  INSTRUMENTTYPE_ ONLINE ) ; receipt Header Service . reconcile Online Success Payment ( online Payment Receipt Header , payment Response . get Txn Date ( ) , payment Response . get Txn Reference No ( ) , payment Response . get Txn Amount ( ) , payment Response . get Auth Status ( ) , reconstructed List , debit Account Detail ) ;  LOGGER . debug ( _ STR ) ; }
public void test Creation Ambiguous ( ) {  Instances data ;  Array List <  Attribute > atts ;  String rel Name ; rel Name = _ STR ; atts = new  Array List <  Attribute > ( ) ; atts . add ( new  Attribute ( _ STR ) ) ; atts . add ( new  Attribute ( _ STR ) ) ; atts . add ( new  Attribute ( _ STR , _ STR ) ) ; atts . add ( new  Attribute ( _ STR , new  Array List <  String > (  Arrays . as List ( new  String [ ] { _ STR , _ STR , _ STR } ) ) ) ) ; atts . add ( new  Attribute ( _ STR , new  Array List <  String > (  Arrays . as List ( new  String [ ] { _ STR , _ STR } ) ) ) ) ; atts . add ( new  Attribute ( _ STR , (  Array List <  String > ) null ) ) ; try { data = new  Instances ( rel Name , atts , _ NUM ) ; } catch (  Illegal Argument Exception e ) { data = null ; } assert Null ( _ STR , data ) ; }
public  Host List Panel ( ) { m_ List = new  JList ( ) ; m_ List . set Model ( new  Default List Model ( ) ) ; m_ Delete But . set Enabled ( _ BOOL ) ; m_ Delete But . add Action Listener ( this ) ; m_ Host Field . add Action Listener ( this ) ; set Layout ( new  Border Layout ( ) ) ; set Border (  Border Factory . create Titled Border ( _ STR ) ) ;  JPanel top Lab = new  JPanel ( ) ;  Grid Bag Layout gb = new  Grid Bag Layout ( ) ;  Grid Bag Constraints constraints = new  Grid Bag Constraints ( ) ; top Lab . set Border (  Border Factory . create Empty Border ( _ NUM , _ NUM , _ NUM , _ NUM ) ) ; top Lab . set Layout ( gb ) ; constraints . gridx = _ NUM ; constraints . gridy = _ NUM ; constraints . weightx = _ NUM ; constraints . fill =  Grid Bag Constraints .  HORIZONTAL ; constraints . gridwidth = _ NUM ; constraints . gridheight = _ NUM ; constraints . insets = new  Insets ( _ NUM , _ NUM , _ NUM , _ NUM ) ; top Lab . add ( m_ Delete But , constraints ) ; constraints . gridx = _ NUM ; constraints . gridy = _ NUM ; constraints . weightx = _ NUM ; constraints . gridwidth = _ NUM ; constraints . gridheight = _ NUM ; top Lab . add ( m_ Host Field , constraints ) ; add ( top Lab ,  Border Layout .  NORTH ) ; add ( new  JScroll Pane ( m_ List ) ,  Border Layout .  CENTER ) ; }
public void apply Format (  File file ) throws  IOException { byte [ ] raw Bytes =  Files . read All Bytes ( file . to Path ( ) ) ;  String raw = new  String ( raw Bytes , encoding ) ;  String raw Unix =  Line Ending . to Unix ( raw ) ;  String formatted Unix = apply Steps ( raw Unix , file ) ;  String formatted = apply Line Endings ( formatted Unix , file ) ; byte [ ] formatted Bytes = formatted . get Bytes ( encoding ) ; if ( !  Arrays . equals ( raw Bytes , formatted Bytes ) ) {  Files . write ( file . to Path ( ) , formatted Bytes ,  Standard Open Option .  TRUNCATE_ EXISTING ) ; } }
private void handle Channel Info Result Error (  String stream ,  Request Type type , int response Code ) { if ( type ==  Request Type .  CHANNEL ) { if ( response Code == _ NUM ) { result Listener . received Channel Info ( stream , null ,  Request Result .  NOT_ FOUND ) ; } else { result Listener . received Channel Info ( stream , null ,  Request Result .  FAILED ) ; } } else { if ( response Code == _ NUM ) { result Listener . put Channel Info Result (  Request Result .  NOT_ FOUND ) ; } else if ( response Code == _ NUM || response Code == _ NUM ) {  LOGGER . warning ( _ STR ) ; result Listener . put Channel Info Result (  Request Result .  ACCESS_ DENIED ) ; access Denied ( ) ; } else if ( response Code == _ NUM ) {  LOGGER . warning ( _ STR ) ; result Listener . put Channel Info Result (  Request Result .  INVALID_ STREAM_ STATUS ) ; } else {  LOGGER . warning ( _ STR + response Code + _ STR ) ; result Listener . put Channel Info Result (  Request Result .  FAILED ) ; } } }
void output Variables (  List <  Var Holder > vars ) { boolean first = _ BOOL ; for (  Var Holder vh : vars ) { if ( vh . name != null ) { if ( first ) { gen . out ( _ STR , vh . name ) ; first = _ BOOL ; } else { gen . out ( _ STR , vh . name ) ; } } else if ( vh . destr != null && vh . vars != null ) { for (  Tree .  Variable v : vh . vars ) { final  String vname = names . name ( v . get Declaration Model ( ) ) ; if ( first ) { gen . out ( _ STR , vname ) ; first = _ BOOL ; } else { gen . out ( _ STR , vname ) ; } } } } if ( ! first ) { gen . end Line ( _ BOOL ) ; } }
public static double regularized Gamma P ( final double a , final double x ) { if (  Double . is Infinite ( a ) ||  Double . is Infinite ( x ) || ! ( a > _ NUM ) || ! ( x >= _ NUM ) ) { return  Double .  Na N ; } if ( x == _ NUM ) { return _ NUM ; } if ( x >= a + _ NUM ) { return _ NUM - regularized Gamma Q ( a , x ) ; } double term = _ NUM / a ; double sum = term ; for ( int n = _ NUM ; n <  MAX_ ITERATIONS ; n ++ ) { term = x / ( a + n ) * term ; sum = sum + term ; if ( sum ==  Double .  POSITIVE_ INFINITY ) { return _ NUM ; } if (  Math . abs ( term / sum ) <  NUM_ PRECISION ) { break ; } } return  Math . exp ( - x + ( a *  Math . log ( x ) ) - log Gamma ( a ) ) * sum ; }
protected boolean is Active Slot (  String slot ) { if ( logger . is Debug Enabled ( ) ||  Testing .  DEBUG ) {  String active Slot List String = null ; for (  String slot Name : this . active Slots List ) { if ( active Slot List String == null ) { active Slot List String = slot Name ; } else { active Slot List String += _ STR + slot Name ; } } logger . info ( _ STR + slot ) ; logger . info ( _ STR + active Slot List String ) ; } if ( ( active Slots List != null ) && ! active Slots List . is Empty ( ) && slot != null ) { return active Slots List . contains ( slot ) ; } return _ BOOL ; }
static  String primitive Type Label ( char type Char ) { switch ( type Char ) { case _ STR : return _ STR ; case _ STR : return _ STR ; case _ STR : return _ STR ; case _ STR : return _ STR ; case _ STR : return _ STR ; case _ STR : return _ STR ; case _ STR : return _ STR ; case _ STR : return _ STR ; case _ STR : return _ STR ; default :  System . err . println ( _ STR + type Char ) ; assert _ BOOL ; return _ STR ; } }
public static boolean is Hidden ( final  String key ) { return key . starts With (  HIDDEN_ PREFIX ) ; }
public  Json Value from Token (  Token token ) { if ( token == null ) { return null ; }  String data = blob Utils . get Blob As String ( token ) ; if ( data == null ) { return null ; }  Json Value r ; try { r = new  Json Value ( serialisation . deserialise ( data ,  Map . class ) ) ; } catch (  Illegal State Exception e ) { return null ; } return r ; }
String to String (  Class < ? > [ ] types ) {  String Builder result = new  String Builder ( ) ; if ( types . length != _ NUM ) { append Type Name ( result , types [ _ NUM ] ) ; for ( int i = _ NUM ; i < types . length ; i ++ ) { result . append ( _ STR ) ; append Type Name ( result , types [ i ] ) ; } } return result . to String ( ) ; }
public static double incomplete Beta Fraction2 ( double a , double b , double x ) { double xk , pk , pkm1 , pkm2 , qk , qkm1 , qkm2 ; double k1 , k2 , k3 , k4 , k5 , k6 , k7 , k8 ; double r , t , ans , z , thresh ; int n ; k1 = a ; k2 = b - _ NUM ; k3 = a ; k4 = a + _ NUM ; k5 = _ NUM ; k6 = a + b ; k7 = a + _ NUM ; ; k8 = a + _ NUM ; pkm2 = _ NUM ; qkm2 = _ NUM ; pkm1 = _ NUM ; qkm1 = _ NUM ; z = x / ( _ NUM - x ) ; ans = _ NUM ; r = _ NUM ; n = _ NUM ; thresh = _ NUM *  MACHEP ; do { xk = - ( z * k1 * k2 ) / ( k3 * k4 ) ; pk = pkm1 + pkm2 * xk ; qk = qkm1 + qkm2 * xk ; pkm2 = pkm1 ; pkm1 = pk ; qkm2 = qkm1 ; qkm1 = qk ; xk = ( z * k5 * k6 ) / ( k7 * k8 ) ; pk = pkm1 + pkm2 * xk ; qk = qkm1 + qkm2 * xk ; pkm2 = pkm1 ; pkm1 = pk ; qkm2 = qkm1 ; qkm1 = qk ; if ( qk != _ NUM ) r = pk / qk ; if ( r != _ NUM ) { t =  Math . abs ( ( ans - r ) / r ) ; ans = r ; } else t = _ NUM ; if ( t < thresh ) return ans ; k1 += _ NUM ; k2 -= _ NUM ; k3 += _ NUM ; k4 += _ NUM ; k5 += _ NUM ; k6 += _ NUM ; k7 += _ NUM ; k8 += _ NUM ; if ( (  Math . abs ( qk ) +  Math . abs ( pk ) ) > big ) { pkm2 *= biginv ; pkm1 *= biginv ; qkm2 *= biginv ; qkm1 *= biginv ; } if ( (  Math . abs ( qk ) < biginv ) || (  Math . abs ( pk ) < biginv ) ) { pkm2 *= big ; pkm1 *= big ; qkm2 *= big ; qkm1 *= big ; } } while ( ++ n < _ NUM ) ; return ans ; }
private  String read Value ( char delimiter , boolean resolve Entities , boolean throw On Resolve Failure ,  Value Context value Context ) throws  IOException ,  Xml Pull Parser Exception { int start = position ;  String Builder result = null ; if ( value Context ==  Value Context .  TEXT && text != null ) { result = new  String Builder ( ) ; result . append ( text ) ; } while ( _ BOOL ) { if ( position >= limit ) { if ( start < position ) { if ( result == null ) { result = new  String Builder ( ) ; } result . append ( buffer , start , position - start ) ; } if ( ! fill Buffer ( _ NUM ) ) { return result != null ? result . to String ( ) : _ STR ; } start = position ; } char c = buffer [ position ] ; if ( c == delimiter || ( delimiter == _ STR && ( c <= _ STR || c == _ STR ) ) || c == _ STR && ! resolve Entities ) { break ; } if ( c != _ STR && ( c != _ STR || value Context !=  Value Context .  ATTRIBUTE ) && c != _ STR && c != _ STR && ( c != _ STR || value Context !=  Value Context .  TEXT ) && ( c != _ STR || value Context !=  Value Context .  ENTITY_ DECLARATION ) ) { is Whitespace &= ( c <= _ STR ) ; position ++ ; continue ; } if ( result == null ) { result = new  String Builder ( ) ; } result . append ( buffer , start , position - start ) ; if ( c == _ STR ) { if ( ( position + _ NUM < limit || fill Buffer ( _ NUM ) ) && buffer [ position + _ NUM ] == _ STR ) { position ++ ; } c = ( value Context ==  Value Context .  ATTRIBUTE ) ? _ STR : _ STR ; } else if ( c == _ STR ) { c = _ STR ; } else if ( c == _ STR ) { is Whitespace = _ BOOL ; read Entity ( result , _ BOOL , throw On Resolve Failure , value Context ) ; start = position ; continue ; } else if ( c == _ STR ) { if ( value Context ==  Value Context .  ATTRIBUTE ) { check Relaxed ( _ STR ) ; } is Whitespace = _ BOOL ; } else if ( c == _ STR ) { if ( ( position + _ NUM < limit || fill Buffer ( _ NUM ) ) && buffer [ position + _ NUM ] == _ STR && buffer [ position + _ NUM ] == _ STR ) { check Relaxed ( _ STR ) ; } is Whitespace = _ BOOL ; } else if ( c == _ STR ) { throw new  Xml Pull Parser Exception ( _ STR , this , null ) ; } else { throw new  Assertion Error ( ) ; } position ++ ; result . append ( c ) ; start = position ; } if ( result == null ) { return string Pool . get ( buffer , start , position - start ) ; } else { result . append ( buffer , start , position - start ) ; return result . to String ( ) ; } }
private  Boot Util ( ) { throw new  Assertion Error ( _ STR ) ; }
public boolean is Empty ( ) { return children == null || children . is Empty ( ) ; }
private  Shape [ ] create Vertical Block ( double x0 , double width , double y0 , double y1 , boolean inverted ) {  Shape [ ] result = new  Shape [ _ NUM ] ;  Point2 D p00 = new  Point2 D .  Double ( x0 , y0 ) ;  Point2 D p01 = new  Point2 D .  Double ( x0 + width , y0 ) ;  Point2 D p02 = new  Point2 D .  Double ( p01 . get X ( ) + get XOffset ( ) , p01 . get Y ( ) - get YOffset ( ) ) ;  Point2 D p03 = new  Point2 D .  Double ( p00 . get X ( ) + get XOffset ( ) , p00 . get Y ( ) - get YOffset ( ) ) ;  Point2 D p0 = new  Point2 D .  Double ( x0 , y1 ) ;  Point2 D p1 = new  Point2 D .  Double ( x0 + width , y1 ) ;  Point2 D p2 = new  Point2 D .  Double ( p1 . get X ( ) + get XOffset ( ) , p1 . get Y ( ) - get YOffset ( ) ) ;  Point2 D p3 = new  Point2 D .  Double ( p0 . get X ( ) + get XOffset ( ) , p0 . get Y ( ) - get YOffset ( ) ) ;  General Path right = new  General Path ( ) ; right . move To ( ( float ) p1 . get X ( ) , ( float ) p1 . get Y ( ) ) ; right . line To ( ( float ) p01 . get X ( ) , ( float ) p01 . get Y ( ) ) ; right . line To ( ( float ) p02 . get X ( ) , ( float ) p02 . get Y ( ) ) ; right . line To ( ( float ) p2 . get X ( ) , ( float ) p2 . get Y ( ) ) ; right . close Path ( ) ;  General Path left = new  General Path ( ) ; left . move To ( ( float ) p0 . get X ( ) , ( float ) p0 . get Y ( ) ) ; left . line To ( ( float ) p00 . get X ( ) , ( float ) p00 . get Y ( ) ) ; left . line To ( ( float ) p03 . get X ( ) , ( float ) p03 . get Y ( ) ) ; left . line To ( ( float ) p3 . get X ( ) , ( float ) p3 . get Y ( ) ) ; left . close Path ( ) ;  General Path back = new  General Path ( ) ; back . move To ( ( float ) p2 . get X ( ) , ( float ) p2 . get Y ( ) ) ; back . line To ( ( float ) p02 . get X ( ) , ( float ) p02 . get Y ( ) ) ; back . line To ( ( float ) p03 . get X ( ) , ( float ) p03 . get Y ( ) ) ; back . line To ( ( float ) p3 . get X ( ) , ( float ) p3 . get Y ( ) ) ; back . close Path ( ) ;  General Path front = new  General Path ( ) ; front . move To ( ( float ) p0 . get X ( ) , ( float ) p0 . get Y ( ) ) ; front . line To ( ( float ) p1 . get X ( ) , ( float ) p1 . get Y ( ) ) ; front . line To ( ( float ) p01 . get X ( ) , ( float ) p01 . get Y ( ) ) ; front . line To ( ( float ) p00 . get X ( ) , ( float ) p00 . get Y ( ) ) ; front . close Path ( ) ;  General Path top = new  General Path ( ) ; top . move To ( ( float ) p0 . get X ( ) , ( float ) p0 . get Y ( ) ) ; top . line To ( ( float ) p1 . get X ( ) , ( float ) p1 . get Y ( ) ) ; top . line To ( ( float ) p2 . get X ( ) , ( float ) p2 . get Y ( ) ) ; top . line To ( ( float ) p3 . get X ( ) , ( float ) p3 . get Y ( ) ) ; top . close Path ( ) ;  General Path bottom = new  General Path ( ) ; bottom . move To ( ( float ) p00 . get X ( ) , ( float ) p00 . get Y ( ) ) ; bottom . line To ( ( float ) p01 . get X ( ) , ( float ) p01 . get Y ( ) ) ; bottom . line To ( ( float ) p02 . get X ( ) , ( float ) p02 . get Y ( ) ) ; bottom . line To ( ( float ) p03 . get X ( ) , ( float ) p03 . get Y ( ) ) ; bottom . close Path ( ) ; result [ _ NUM ] = bottom ; result [ _ NUM ] = back ; result [ _ NUM ] = left ; result [ _ NUM ] = right ; result [ _ NUM ] = top ; result [ _ NUM ] = front ; if ( inverted ) { result [ _ NUM ] = top ; result [ _ NUM ] = bottom ; } return result ; }
public static void stop (  Thread thread ) { if ( thread != null ) { thread . interrupt ( ) ; } }
private void write Object ( java . io .  Object Output Stream s ) throws java . io .  IOException { s . write Object ( my Syntax ) ; s . write Int ( size ( ) ) ;  Enumeration <  String > comps = get All ( ) ; while ( comps . has More Elements ( ) ) { s . write Object ( comps . next Element ( ) ) ; } }
private  JPanel create Control Panel ( ) {  JPanel control Panel = new  JPanel ( ) ; control Panel . set Layout ( new  Border Layout ( ) ) ;  Container zoom Panel = new  Container ( ) ; zoom Panel . set Layout ( new  Border Layout ( ) ) ;  JButton plus = new  JButton ( _ STR ) ; plus . add Mouse Listener ( new  Custom Mouse Listener ( new  Zoom Action (  Zoom Direction .  IN ) ) ) ; zoom Panel . add ( plus ,  Border Layout .  NORTH ) ;  JButton minus = new  JButton ( _ STR ) ; minus . add Mouse Listener ( new  Custom Mouse Listener ( new  Zoom Action (  Zoom Direction .  OUT ) ) ) ; zoom Panel . add ( minus ,  Border Layout .  SOUTH ) ; control Panel . add ( zoom Panel ,  Border Layout .  WEST ) ; control Panel . add ( new  JSeparator (  Swing Constants .  VERTICAL ) ,  Border Layout .  CENTER ) ;  Container translation Panel = new  Container ( ) ; translation Panel . set Layout ( new  Border Layout ( ) ) ;  JButton up = new  Basic Arrow Button (  Swing Constants .  NORTH ) ; up . add Mouse Listener ( new  Custom Mouse Listener ( new  Translation Action (  Translation Direction .  NORTH ) ) ) ; translation Panel . add ( up ,  Border Layout .  NORTH ) ;  JButton west = new  Basic Arrow Button (  Swing Constants .  WEST ) ; west . add Mouse Listener ( new  Custom Mouse Listener ( new  Translation Action (  Translation Direction .  WEST ) ) ) ; translation Panel . add ( west ,  Border Layout .  WEST ) ; translation Panel . add ( new  JLabel ( _ STR ) ,  Border Layout .  CENTER ) ;  JButton east = new  Basic Arrow Button (  Swing Constants .  EAST ) ; east . add Mouse Listener ( new  Custom Mouse Listener ( new  Translation Action (  Translation Direction .  EAST ) ) ) ; translation Panel . add ( east ,  Border Layout .  EAST ) ;  JButton south = new  Basic Arrow Button (  Swing Constants .  SOUTH ) ; south . add Mouse Listener ( new  Custom Mouse Listener ( new  Translation Action (  Translation Direction .  SOUTH ) ) ) ; translation Panel . add ( south ,  Border Layout .  SOUTH ) ; control Panel . add ( translation Panel ,  Border Layout .  EAST ) ; control Panel . set Border ( new  Compound Border (  Border Factory . create Titled Border ( _ STR ) ,  Border Factory . create Empty Border ( _ NUM , _ NUM , _ NUM , _ NUM ) ) ) ; return control Panel ; }
public static  Object [ ] put All ( ) { try {  Region region = cache . get Region (  Region .  SEPARATOR +  REGION_ NAME ) ; assert Not Null ( region ) ;  Map map = new  Linked Hash Map ( ) ; map . put (  PUTALL_ KEY1 , _ STR ) ; map . put (  PUTALL_ KEY2 , _ STR ) ; map . put (  PUTALL_ KEY3 , _ STR ) ; map . put (  PUTALL_ KEY4 , _ STR ) ; map . put (  PUTALL_ KEY5 , _ STR ) ; region . put All ( map ) ;  Thread . sleep ( _ NUM ) ;  Event ID [ ] evids = new  Event ID [ _ NUM ] ; evids [ _ NUM ] = put Allevent Id1 ; evids [ _ NUM ] = put Allevent Id2 ; evids [ _ NUM ] = put Allevent Id3 ; evids [ _ NUM ] = put Allevent Id4 ; evids [ _ NUM ] = put Allevent Id5 ; assert Not Null ( evids [ _ NUM ] ) ; assert Not Null ( evids [ _ NUM ] ) ; assert Not Null ( evids [ _ NUM ] ) ; assert Not Null ( evids [ _ NUM ] ) ; assert Not Null ( evids [ _ NUM ] ) ; return evids ; } catch (  Exception e ) { fail ( _ STR , e ) ; } return null ; }
public void load Layout (  Input Stream is , boolean new Tab ,  String flow Name ) throws  Exception {  Input Stream Reader isr = new  Input Stream Reader ( is ) ; load Layout ( isr , new Tab , flow Name ) ; }
private synchronized void add Tracker (  String path ,  Object marker ,  File Delete Strategy delete Strategy ) { if ( exit When Finished ) { throw new  Illegal State Exception ( _ STR ) ; } if ( reaper == null ) { reaper = new  Reaper ( ) ; reaper . start ( ) ; } trackers . add ( new  Tracker ( path , delete Strategy , marker , q ) ) ; }
public static boolean has Parameter (  String parameter Name ) { return parameter Map . contains Key ( parameter Name ) ; }
protected long release Memory ( ) { long memory Freed = _ NUM ; while ( ! windows For Free Memory . is Empty ( ) ) { long window Id = windows For Free Memory . poll ( ) ; long origin Size = key Stream . size ( ) + value Stream . size ( ) ; key Stream . complete Window ( window Id ) ; value Stream . complete Window ( window Id ) ; memory Freed += origin Size - ( key Stream . size ( ) + value Stream . size ( ) ) ; } if ( memory Freed > _ NUM ) {  LOG . debug ( _ STR , memory Freed ) ; size In Bytes . get And Add ( - memory Freed ) ; } return memory Freed ; }
public static boolean is SQL99 Reserved Keyword (  String identifier ) { if ( identifier == null ) { throw new  Null Pointer Exception ( _ STR ) ; } return  Arrays . binary Search (  SQL99_ RESERVED , identifier . to Upper Case ( ) ) >= _ NUM ; }
private static  Byte Buffer decode Percent Encoded Octets (  String s , int i ,  Byte Buffer bb ) { if ( bb == null ) { bb =  Byte Buffer . allocate ( _ NUM ) ; } else { bb . clear ( ) ; } while ( _ BOOL ) { bb . put ( ( byte ) ( decode Hex ( s , i ++ ) << _ NUM | decode Hex ( s , i ++ ) ) ) ; if ( i == s . length ( ) ) { break ; } if ( s . char At ( i ++ ) != _ STR ) { break ; } if ( bb . position ( ) == bb . capacity ( ) ) { bb . flip ( ) ;  Byte Buffer bb_new =  Byte Buffer . allocate ( s . length ( ) / _ NUM ) ; bb_new . put ( bb ) ; bb = bb_new ; } } bb . flip ( ) ; return bb ; }
@  Override protected void before Execute (  Thread t ,  Runnable r ) { if ( is Append Task Name ( ) ) {  Named Thread Pool Helper . change Name Before Execute ( t , r ) ; } super . before Execute ( t , r ) ; }
public static  String escape Element Entities (  String str ) { if ( str == null ) return null ;  String Buffer buffer ; char ch ;  String entity ; buffer = null ; for ( int i = _ NUM ; i < str . length ( ) ; i ++ ) { ch = str . char At ( i ) ; switch ( ch ) { case _ STR : entity = _ STR ; break ; case _ STR : entity = _ STR ; break ; case _ STR : entity = _ STR ; break ; case _ STR : entity = _ STR ; break ; default : entity = null ; break ; } if ( buffer == null ) { if ( entity != null ) { buffer = new  String Buffer ( str . length ( ) + _ NUM ) ; buffer . append ( str . substring ( _ NUM , i ) ) ; buffer . append ( entity ) ; } } else { if ( entity == null ) { buffer . append ( ch ) ; } else { buffer . append ( entity ) ; } } } return ( buffer == null ) ? str : buffer . to String ( ) ; }
public static int find Global Peak Location ( double [ ] data ) { double max =  Double .  Na N ; int imax = - _ NUM ; for ( int i = _ NUM ; i < data . length ; i ++ ) { if (  Double . is Na N ( data [ i ] ) ) continue ; if (  Double . is Na N ( max ) || data [ i ] > max ) { max = data [ i ] ; imax = i ; } } return imax ; }
private  String extract Boundary (  String line ) { int index = line . last Index Of ( _ STR ) ; if ( index == - _ NUM ) { return null ; }  String boundary = line . substring ( index + _ NUM ) ; if ( boundary . char At ( _ NUM ) == _ STR ) { index = boundary . last Index Of ( _ STR ) ; boundary = boundary . substring ( _ NUM , index ) ; } boundary = _ STR + boundary ; return boundary ; }
public int read Int ( ) throws  IOException { return ( ( _is . read ( ) << _ NUM ) | ( _is . read ( ) << _ NUM ) | ( _is . read ( ) << _ NUM ) | ( _is . read ( ) ) ) ; }
@  Override public void add ( int index ,  Instance instance ) {  Instance new Instance = (  Instance ) instance . copy ( ) ; new Instance . set Dataset ( this ) ; m_ Instances . add ( index , new Instance ) ; }
protected static  String extract Bucket (  String s3uri ) { return s3uri . substring ( s3uri . index Of ( _ STR ) + _ NUM , s3uri . index Of ( _ STR , s3uri . index Of ( _ STR ) ) ) ; }
public boolean do Transaction (  DB db ,  Object threadstate ) throws  Workload Exception { boolean ret = _ BOOL ; long st =  System . nano Time ( ) ;  String op = operationchooser . next String ( ) ; if ( op . compare To ( _ STR ) == _ NUM ) { ret = do Transaction Read ( db ) ; } else if ( op . compare To ( _ STR ) == _ NUM ) { ret = do Transaction Update ( db ) ; } else if ( op . compare To ( _ STR ) == _ NUM ) { ret = do Transaction Insert ( db ) ; } else if ( op . compare To ( _ STR ) == _ NUM ) { ret = do Transaction Scan ( db ) ; } else { ret = do Transaction Read Modify Write ( db ) ; } long en =  System . nano Time ( ) ; _measurements . measure ( _operations . get ( op ) , ( int ) ( ( en - st ) / _ NUM ) ) ; if ( ret ) _measurements . report Return Code ( _operations . get ( op ) , - _ NUM ) ; else { _measurements . report Return Code ( _operations . get ( op ) , _ NUM ) ; } return ret ; }
public static void copy With Gap (  Object src ,  Object dst , int old Size , int gap Index ) { if ( gap Index > _ NUM ) {  System . arraycopy ( src , _ NUM , dst , _ NUM , gap Index ) ; } if ( gap Index < old Size ) {  System . arraycopy ( src , gap Index , dst , gap Index + _ NUM , old Size - gap Index ) ; } }
public static  String build Scenario (  List <  String > url List ) { if ( url List == null || url List . is Empty ( ) ) { return null ; }  String Builder strb = new  String Builder ( ) ; strb . append ( build Header ( ) ) ;  Iterator <  String > iter = url List . iterator ( ) ; while ( iter . has Next ( ) ) { strb . append ( build Get Step ( ( iter . next ( ) ) ) ) ; if ( iter . has Next ( ) ) { strb . append (  COMMA ) ; } } strb . append ( build Footer ( ) ) ; return strb . to String ( ) ; }
public  Optional <  Blaze Edge > edge ( final  Object edge Id ) { try (  Closeable Iterator <  Edge > it = edges ( edge Id ) ) { final  Optional <  Blaze Edge > e = it . has Next ( ) ?  Optional . of ( (  Blaze Edge ) it . next ( ) ) :  Optional . empty ( ) ; if ( it . has Next ( ) ) { throw new  Illegal State Exception ( _ STR + edge Id ) ; } return e ; } }
static void add Cap (  Ring Buffer .  Sequence sequence , long to Add ) { long u , r ; do { r = sequence . get As Long ( ) ; if ( r ==  Long .  MAX_ VALUE ) { return ; } u =  Operators . add Cap ( r , to Add ) ; } while ( ! sequence . compare And Set ( r , u ) ) ; }
private void add (  Http Servlet Request request ,  Http Servlet Response response ) throws  IOException {  Print Writer out = response . get Writer ( ) ;  String label = request . get Parameter ( _ STR ) ;  String units = request . get Parameter ( _ STR ) ;  String value = request . get Parameter ( _ STR ) ;  String detail = request . get Parameter ( _ STR ) ;  Double val = to Double ( value ) ; if ( is Empty ( label ) || is Empty ( units ) || is Empty ( val ) ) { out . println (  ERROR + _ STR ) ; out . println ( _ STR ) ; } else {  Mon Key key = get Mon Key ( label , detail , units ) ;  Monitor mon =  Monitor Factory . add ( key , val ) ; out . println (  OK + _ STR + label + _ STR + mon ) ; } }
public double norm ( ) { if ( m_ Elements != null ) { int n = m_ Elements . length ; double sum = _ NUM ; for ( int i = _ NUM ; i < n ; i ++ ) { sum += m_ Elements [ i ] * m_ Elements [ i ] ; } return  Math . pow ( sum , _ NUM ) ; } else return _ NUM ; }
public static double p ( double  Y [ ] [ ] , int j , int k ) { int  N =  Y . length ; double p = _ NUM ; for ( int i = _ NUM ; i <  N ; i ++ ) { if ( ( int )  Math . round (  Y [ i ] [ j ] ) == k ) { p += _ NUM ; } } return p /  N ; }
public void test Write2 ( ) throws  Exception { byte [ ] data = new byte [ ] { - _ NUM , - _ NUM , - _ NUM , - _ NUM , - _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM } ;  Test Output Stream tos = new  Test Output Stream ( ) ;  Cipher Output Stream cos = new  Cipher Output Stream ( tos , new  Null Cipher ( ) ) ; cos . write ( data ) ; cos . flush ( ) ; byte [ ] result = tos . to Byte Array ( ) ; if ( !  Arrays . equals ( result , data ) ) { fail ( _ STR ) ; } try { cos . write ( null ) ; fail ( _ STR ) ; } catch (  Null Pointer Exception e ) { } }
public  Closeable Animated Bitmap (  List <  Bitmap > bitmaps ,  List <  Integer > durations ,  Resource Releaser <  Bitmap > resource Releaser ) {  Preconditions . check Not Null ( bitmaps ) ;  Preconditions . check State ( bitmaps . size ( ) >= _ NUM , _ STR ) ; m Bitmaps = new  Array List < > ( bitmaps . size ( ) ) ; m Bitmap References = new  Array List < > ( bitmaps . size ( ) ) ; for (  Bitmap bitmap : bitmaps ) { m Bitmap References . add (  Closeable Reference . of ( bitmap , resource Releaser ) ) ; m Bitmaps . add ( bitmap ) ; } m Durations =  Preconditions . check Not Null ( durations ) ;  Preconditions . check State ( m Durations . size ( ) == m Bitmaps . size ( ) , _ STR ) ; }
public static  Vector <  String > read File Into Vector (  String file Path ) throws  Exception {  Vector <  String > result = new  Vector <  String > ( ) ;  File f = new  File ( file Path ) ; if ( ! f . exists ( ) ) throw new  Exception ( _ STR + file Path + _ STR ) ;  Buffered Reader br = new  Buffered Reader ( new  File Reader ( f ) ) ;  String line = _ STR ; while ( ( line = br . read Line ( ) ) != null ) { result . add ( line ) ; } br . close ( ) ; return result ; }
public static byte [ ] unsigned Copy And Increment ( final byte [ ] input ) { byte [ ] copy = copy ( input ) ; if ( copy == null ) { throw new  Illegal Argument Exception ( _ STR ) ; } for ( int i = copy . length - _ NUM ; i >= _ NUM ; -- i ) { if ( copy [ i ] == - _ NUM ) { copy [ i ] = _ NUM ; } else { ++ copy [ i ] ; return copy ; } } byte [ ] out = new byte [ copy . length + _ NUM ] ; out [ _ NUM ] = _ NUM ;  System . arraycopy ( copy , _ NUM , out , _ NUM , copy . length ) ; return out ; }
public  String to XML ( final  XStream xstream , final  Object obj ) throws  Object Stream Exception { final  Writer writer = new  String Writer ( ) ; try { to XML ( xstream , obj , writer ) ; } catch ( final  Object Stream Exception e ) { throw e ; } catch ( final  IOException e ) { throw new  Stream Exception ( _ STR , e ) ; } return writer . to String ( ) ; }
protected void respond Vanished (  Mailbox Session session ,  Message Manager mailbox ,  List <  Message Range > ranges , long changed Since ,  Meta Data meta Data ,  Responder responder ) throws  Mailbox Exception { if ( meta Data . get Highest Mod Seq ( ) > changed Since ) {  Search Query search Query = new  Search Query ( ) ;  Search Query .  Uid Range [ ] n Ranges = new  Search Query .  Uid Range [ ranges . size ( ) ] ;  Set <  Message Uid > vanished Uids = new  Hash Set <  Message Uid > ( ) ; for ( int i = _ NUM ; i < ranges . size ( ) ; i ++ ) {  Message Range r = ranges . get ( i ) ;  Search Query .  Uid Range nr ; if ( r . get Type ( ) ==  Type .  ONE ) { nr = new  Search Query .  Uid Range ( r . get Uid From ( ) ) ; } else { nr = new  Search Query .  Uid Range ( r . get Uid From ( ) , r . get Uid To ( ) ) ; }  Message Uid from = nr . get Low Value ( ) ;  Message Uid to = nr . get High Value ( ) ; while ( from . compare To ( to ) <= _ NUM ) { vanished Uids . add ( from ) ; from = from . next ( ) ; } n Ranges [ i ] = nr ; } search Query . and Criteria (  Search Query . uid ( n Ranges ) ) ; search Query . and Criteria (  Search Query . mod Seq Greater Than ( changed Since ) ) ;  Iterator <  Message Uid > uids = mailbox . search ( search Query , session ) ; while ( uids . has Next ( ) ) { vanished Uids . remove ( uids . next ( ) ) ; }  Uid Range [ ] vanished Id Ranges = uid Ranges (  Message Range . to Ranges ( vanished Uids ) ) ; responder . respond ( new  Vanished Response ( vanished Id Ranges , _ BOOL ) ) ; } }
public  ESRIRecord [ ] locate Records ( double xmin , double ymin , double xmax , double ymax ) throws  IOException ,  Format Exception { boolean gather Bounds = _ BOOL ; if ( bounds == null ) { bounds = new  ESRIBounding Box ( ) ; gather Bounds = _ BOOL ; } if ( logger . is Loggable (  Level .  FINE ) ) { logger . fine ( _ STR + xmin + _ STR + ymin + _ STR + xmax + _ STR + ymax ) ; } byte ix Record [ ] = new byte [  SPATIAL_ INDEX_ RECORD_ LENGTH ] ; int rec Num = _ NUM ;  Vector <  ESRIRecord > v = new  Vector <  ESRIRecord > ( ) ; int s Record Size =  DEFAULT_ SHAPE_ RECORD_ SIZE ; byte s Record [ ] = new byte [ s Record Size ] ; if ( shp File Name == null ) { return null ; }  Binary Buffered File ssx = new  Binary Buffered File ( ssx ( shp File Name ) ) ; if ( shp == null ) { shp = get Shp File ( shp File Name ) ; } ssx . seek ( _ NUM ) ; ssx . byte Order ( _ BOOL ) ; int shape Type = ssx . read Integer ( ) ; ssx . seek ( _ NUM ) ; while ( _ BOOL ) { int result = ssx . read ( ix Record , _ NUM ,  SPATIAL_ INDEX_ RECORD_ LENGTH ) ; if ( result <= _ NUM ) { break ; } else { rec Num ++ ; double xmin2 = read LEDouble ( ix Record , _ NUM ) ; double ymin2 = read LEDouble ( ix Record , _ NUM ) ; double xmax2 = read LEDouble ( ix Record , _ NUM ) ; double ymax2 = read LEDouble ( ix Record , _ NUM ) ; if ( logger . is Loggable (  Level .  FINER ) ) { logger . finer ( _ STR + rec Num ) ; logger . finer ( _ STR + xmin2 + _ STR + ymin2 + _ STR + xmax2 + _ STR + ymax2 ) ; } if ( gather Bounds ) { bounds . add Point ( xmin2 , ymin2 ) ; bounds . add Point ( xmax2 , ymax2 ) ; } if ( intersects ( xmin , ymin , xmax , ymax , xmin2 , ymin2 , xmax2 , ymax2 ) ) { int offset = read BEInt ( ix Record , _ NUM ) ; int byte Offset = offset * _ NUM ; int content Length = read BEInt ( ix Record , _ NUM ) ; int record Size = ( content Length * _ NUM ) + _ NUM ; if ( record Size < _ NUM ) { logger . warning ( _ STR + record Size ) ; break ; } if ( record Size > s Record Size ) { s Record Size = record Size ; if ( logger . is Loggable (  Level .  FINER ) ) { logger . finer ( _ STR + s Record Size ) ; } s Record = new byte [ s Record Size ] ; } if ( logger . is Loggable (  Level .  FINE ) ) { logger . fine ( _ STR + byte Offset + _ STR + record Size + _ STR + offset + _ STR + shape Type ) ; } try { shp . seek ( byte Offset ) ; int n Bytes = shp . read ( s Record , _ NUM , record Size ) ; if ( n Bytes < record Size ) { logger . warning ( _ STR + record Size + _ STR + n Bytes + _ STR ) ; }  ESRIRecord record = make ESRIRecord ( shape Type , s Record , _ NUM ) ; v . add Element ( record ) ; } catch (  IOException ioe ) { logger . warning ( _ STR ) ; ioe . print Stack Trace ( ) ; break ; } } } } if ( logger . is Loggable (  Level .  FINE ) ) { logger . fine ( _ STR + rec Num + _ STR ) ; logger . fine ( _ STR + v . size ( ) + _ STR ) ; } int n Records = v . size ( ) ; ssx . close ( ) ; shp . close ( ) ; shp = null ;  ESRIRecord result [ ] = new  ESRIRecord [ n Records ] ; v . copy Into ( result ) ; return result ; }
private boolean match Filter (  String string ,  String pattern ) { if ( pattern . equals ( _ STR ) || pattern . equals ( string ) ) { return _ BOOL ; } int length = pattern . length ( ) ; int wild Card Index = pattern . index Of ( _ STR ) ; if ( wild Card Index >= _ NUM ) {  String pattern Sub Str = pattern . substring ( _ NUM , wild Card Index ) ; if ( ! string . starts With ( pattern Sub Str , _ NUM ) ) { return _ BOOL ; } int begin Index = pattern Sub Str . length ( ) + _ NUM ; int string Index = _ NUM ; if ( wild Card Index > _ NUM ) { string Index = begin Index ; }  String sub = pattern . substring ( begin Index , length ) ; while ( ( wild Card Index = pattern . index Of ( _ STR , begin Index ) ) != - _ NUM ) { pattern Sub Str = pattern . substring ( begin Index , wild Card Index ) ; if ( string . index Of ( pattern Sub Str , string Index ) == - _ NUM ) { return _ BOOL ; } begin Index = wild Card Index + _ NUM ; string Index = string Index + pattern Sub Str . length ( ) + _ NUM ; sub = pattern . substring ( begin Index , length ) ; } if ( string . ends With ( sub ) ) { return _ BOOL ; } } return _ BOOL ; }
private void add Source Code Remark (  Test Solution test Solution ,  Element element ,  String message ,  String default Lang ,  String current Lang ,  String detected Lang ,  String tested Text ) { if ( test Solution . equals (  Test Solution .  PASSED ) ||  String Utils . is Blank ( message ) ) { return ; }  List <  Evidence Element > evidence Element List = new  Array List < > ( ) ; if (  String Utils . is Not Blank ( current Lang ) ) { evidence Element List . add ( get Evidence Element (  DEFAULT_ LANGUAGE_ EE , default Lang ) ) ; evidence Element List . add ( get Evidence Element (  CURRENT_ LANGUAGE_ EE , current Lang ) ) ; } else { evidence Element List . add ( get Evidence Element (  LANGUAGE_ EE , default Lang ) ) ; } evidence Element List . add ( get Evidence Element (  DETECTED_ LANGUAGE_ EE , detected Lang ) ) ; if ( tested Text . length ( ) >  DISPLAYABLE_ TEXT_ SIZE ) { tested Text = tested Text . substring ( _ NUM ,  DISPLAYABLE_ TEXT_ SIZE ) ; } evidence Element List . add ( get Evidence Element (  EXTRACTED_ TEXT_ EE , tested Text ) ) ; add Source Code Remark ( test Solution , element , message , evidence Element List ) ; }
public void mouse Pressed (  Mouse Event e ) {  Visualization Viewer < ? , ? > vv = (  Visualization Viewer < ? , ? > ) e . get Source ( ) ; boolean accepted = check Modifiers ( e ) ; down = e . get Point ( ) ; if ( accepted ) { vv . set Cursor ( cursor ) ; } }
public  File create New Folder (  File containing Dir ) throws  IOException { if ( containing Dir == null ) { throw new  IOException ( _ STR ) ; }  File new Folder ; new Folder = create File Object ( containing Dir , new Folder String ) ; int i = _ NUM ; while ( new Folder . exists ( ) && i < _ NUM ) { new Folder = create File Object ( containing Dir ,  Message Format . format ( new Folder Next String , new  Integer ( i ) ) ) ; i ++ ; } if ( new Folder . exists ( ) ) { throw new  IOException ( _ STR + new Folder . get Absolute Path ( ) ) ; } else { new Folder . mkdirs ( ) ; } return new Folder ; }
private void parse (  XMLStream Reader parser ,  Handler handler ,  Map <  String ,  Object > values ,  Stack <  Set <  String > > stack , boolean record Started ) throws  IOException ,  XMLStream Exception {  Set <  String > values Addedin This Frame = null ; if ( is Record ) { record Started = _ BOOL ; values Addedin This Frame = new  Hash Set < > ( ) ; stack . push ( values Addedin This Frame ) ; } else if ( record Started ) { values Addedin This Frame = stack . peek ( ) ; } try { if ( attributes != null ) { for (  Node node : attributes ) {  String value = parser . get Attribute Value ( null , node . name ) ; if ( value != null || ( record Started && ! is Record ) ) { put Text ( values , value , node . field Name , node . multi Valued ) ; values Addedin This Frame . add ( node . field Name ) ; } } }  Set <  Node > children Found = new  Hash Set < > ( ) ; int event = - _ NUM ; int flattened Starts = _ NUM ;  String Builder text = new  String Builder ( ) ; while ( _ BOOL ) { event = parser . next ( ) ; if ( event ==  END_ ELEMENT ) { if ( flattened Starts > _ NUM ) flattened Starts -- ; else { if ( has Text && values Addedin This Frame != null ) { values Addedin This Frame . add ( field Name ) ; put Text ( values , text . to String ( ) , field Name , multi Valued ) ; } if ( is Record ) handler . handle ( get Deep Copy ( values ) , for Each Path ) ; if ( child Nodes != null && record Started && ! is Record && ! children Found . contains All ( child Nodes ) ) { for (  Node n : child Nodes ) { if ( ! children Found . contains ( n ) ) n . put Nulls ( values , values Addedin This Frame ) ; } } return ; } } else if ( has Text && ( event ==  CDATA || event ==  CHARACTERS || event ==  SPACE ) ) { text . append ( parser . get Text ( ) ) ; } else if ( event ==  START_ ELEMENT ) { if ( flatten ) flattened Starts ++ ; else handle Start Element ( parser , children Found , handler , values , stack , record Started ) ; } else if ( event ==  END_ DOCUMENT ) return ; } } finally { if ( ( is Record || ! record Started ) && ! stack . empty ( ) ) {  Set <  String > clean This = stack . pop ( ) ; if ( clean This != null ) { for (  String fld : clean This ) values . remove ( fld ) ; } } } }
@  Override public boolean equals (  Object object ) { if ( object == this ) { return _ BOOL ; } if ( object instanceof  Resizable Double Array == _ BOOL ) { return _ BOOL ; } boolean result = _ BOOL ; final  Resizable Double Array other = (  Resizable Double Array ) object ; result = result && ( other . contraction Criterion == contraction Criterion ) ; result = result && ( other . expansion Factor == expansion Factor ) ; result = result && ( other . expansion Mode == expansion Mode ) ; result = result && ( other . num Elements == num Elements ) ; result = result && ( other . start Index == start Index ) ; if ( ! result ) { return _ BOOL ; } else { return  Arrays . equals ( internal Array , other . internal Array ) ; } }
public  Ind Test Probabilistic Verbose (  Data Set data Set ,  Print Writer out ,  Ind Test DSep dsep Test ) { this . out = out ; this . dsep Test = dsep Test ; if ( ! data Set . is Discrete ( ) ) { throw new  Illegal Argument Exception ( _ STR ) ; } this . data = data Set ; int [ ] node Dimensions = new int [ data Set . get Num Columns ( ) + _ NUM ] ; for ( int j = _ NUM ; j < data Set . get Num Columns ( ) ; j ++ ) {  Discrete Variable variable = (  Discrete Variable ) ( data Set . get Variable ( j ) ) ; int num Categories = variable . get Num Categories ( ) ; node Dimensions [ j + _ NUM ] = num Categories ; } int [ ] [ ] cases = new int [ data Set . get Num Rows ( ) + _ NUM ] [ data Set . get Num Columns ( ) + _ NUM ] ; for ( int i = _ NUM ; i < data Set . get Num Rows ( ) ; i ++ ) { for ( int j = _ NUM ; j < data Set . get Num Columns ( ) ; j ++ ) { cases [ i + _ NUM ] [ j + _ NUM ] = data Set . get Int ( i , j ) + _ NUM ; } } bci = new  BCInference ( cases , node Dimensions ) ; nodes = data Set . get Variables ( ) ; indices = new  Hash Map < > ( ) ; for ( int i = _ NUM ; i < nodes . size ( ) ; i ++ ) { indices . put ( nodes . get ( i ) , i ) ; } this .  H = new  Hash Map < > ( ) ; }
public static  Array List <  Long > load Workspace Screens Db (  Context context ) { final  Content Resolver content Resolver = context . get Content Resolver ( ) ; final  Uri screens Uri =  Launcher Settings .  Workspace Screens .  CONTENT_ URI ; final  Cursor sc = content Resolver . query ( screens Uri , null , null , null ,  Launcher Settings .  Workspace Screens .  SCREEN_ RANK ) ;  Array List <  Long > screen Ids = new  Array List <  Long > ( ) ; try { final int id Index = sc . get Column Index Or Throw (  Launcher Settings .  Workspace Screens . _ ID ) ; while ( sc . move To Next ( ) ) { try { screen Ids . add ( sc . get Long ( id Index ) ) ; } catch (  Exception e ) {  Launcher . add Dump Log (  TAG , _ STR + _ STR + e , _ BOOL ) ; } } } finally { sc . close ( ) ; } return screen Ids ; }
public boolean render (  Internal Context Adapter context ,  Writer writer ) throws  IOException ,  Method Invocation Exception { if ( reference Type ==  RUNT ) { writer . write ( root String ) ; return _ BOOL ; }  Object value = execute ( null , context ) ; if ( escaped ) { if ( value == null ) { writer . write ( esc Prefix ) ; writer . write ( _ STR ) ; writer . write ( null String ) ; } else { writer . write ( esc Prefix ) ; writer . write ( null String ) ; } return _ BOOL ; }  Event Cartridge ec = context . get Event Cartridge ( ) ; if ( ec != null ) { value = ec . reference Insert ( literal , value ) ; } if ( value == null ) { writer . write ( esc Prefix ) ; writer . write ( esc Prefix ) ; writer . write ( more Prefix ) ; writer . write ( null String ) ; if ( reference Type !=  QUIET_ REFERENCE && rsvc . get Boolean (  Runtime Constants .  RUNTIME_ LOG_ REFERENCE_ LOG_ INVALID , _ BOOL ) ) { rsvc . warn ( new  Reference Exception ( _ STR + context . get Current Template Name ( ) , this ) ) ; } return _ BOOL ; } else { writer . write ( esc Prefix ) ; writer . write ( more Prefix ) ; writer . write ( value . to String ( ) ) ; return _ BOOL ; } }
protected  String e (  String s ) throws  Exception { return fmt . format ( parser . parse ( s ) ) ; }
public static boolean equals ( float [ ] field1 , float [ ] field2 ) { if ( field1 == null || field1 . length == _ NUM ) { return field2 == null || field2 . length == _ NUM ; } else { return  Arrays . equals ( field1 , field2 ) ; } }
private static void fix Rectangle Orientation ( double [ ] m ,  Rectangle2 D clip ) { if ( clip . get Width ( ) > _ NUM != ( m [ _ NUM ] - m [ _ NUM ] > _ NUM ) ) { double t = m [ _ NUM ] ; m [ _ NUM ] = m [ _ NUM ] ; m [ _ NUM ] = t ; } if ( clip . get Height ( ) > _ NUM != ( m [ _ NUM ] - m [ _ NUM ] > _ NUM ) ) { double t = m [ _ NUM ] ; m [ _ NUM ] = m [ _ NUM ] ; m [ _ NUM ] = t ; } }
public  Link Icon ( boolean linked ) { this . linked = linked ; link = linked ? linked Im Ic . get Image ( ) : unlinked Im Ic . get Image ( ) ; add Mouse Listener ( this ) ;  Dimension dim = new  Dimension ( ( int ) link . get Width ( null ) , link . get Height ( null ) ) ; set Preferred Size ( dim ) ; set Minimum Size ( dim ) ; set Maximum Size ( dim ) ; set Size ( dim ) ; set Layout ( null ) ; repaint ( ) ; }
public static boolean intersects Circle (  Geo p1 ,  Geo p2 ,  Geo center , double radius ) { double d1 =  Geo . distance ( p1 , center ) ; if ( d1 < radius ) return _ BOOL ; double d2 =  Geo . distance ( p2 , center ) ; if ( d2 < radius ) return _ BOOL ; double dist = point Circle Distance ( p1 , p2 , center ) ; if ( dist > radius ) return _ BOOL ;  Geo g = p1 . cross ( p2 ) ;  Geo f = center . cross ( g ) ;  Geo i = f . cross Normalize ( g , g ) ; double d =  Geo . distance ( p1 , p2 ) ; if ( center . distance ( i ) < radius ) { double d11 =  Geo . distance ( p1 , i ) ; double d12 =  Geo . distance ( p2 , i ) ; return ( d11 <= d && d12 <= d &&  Math . abs ( d11 + d12 - d ) < _ NUM ) ; }  Geo i2 = i . antipode ( i ) ; if ( center . distance ( i2 ) < radius ) { double d21 =  Geo . distance ( p1 , i2 ) ; double d22 =  Geo . distance ( p2 , i2 ) ; return ( d21 <= d && d22 <= d &&  Math . abs ( d21 + d22 - d ) < _ NUM ) ; } return _ BOOL ; }
public void record Start Time ( ) { _current Request Start Time . set (  System . current Time Millis ( ) ) ; }
private boolean is Accessible User Filter (  Set <  String > filters ,  String request Path ) {  String index = normalize Url Path ( request Path ) ;  String [ ] array = filters . to Array ( new  String [ _ NUM ] ) ; for (  String filter : array ) { if ( index . matches ( filter ) ) { return _ BOOL ; } } return _ BOOL ; }
public boolean add Row (  Table Entry entry ) { try { int row = list . size ( ) ; list . add ( entry ) ; fire Table Rows Inserted ( row , row ) ; } catch (  Exception e ) { return _ BOOL ; } return _ BOOL ; }
protected boolean write Fields (  Data Output Stream dd ) throws  IOException { field_info fi ; int i ; for ( i = _ NUM ; i < fields_count ; i ++ ) { fi = fields [ i ] ; dd . write Short ( fi . access_flags ) ; dd . write Short ( fi . name_index ) ; dd . write Short ( fi . descriptor_index ) ; dd . write Short ( fi . attributes_count ) ; if ( fi . attributes_count > _ NUM ) { write Attributes ( dd , fi . attributes_count , fi . attributes ) ; } } return _ BOOL ; }
public boolean login ( final  String user Name , final  String hashed Password ) { final  Connection con =  Database . get Connection ( ) ; try {  Prepared Statement ps = con . prepare Statement ( _ STR ) ; ps . set String ( _ NUM , user Name ) ; ps . set String ( _ NUM , hashed Password ) ; final  Result Set rs = ps . execute Query ( ) ; if ( ! rs . next ( ) ) { return _ BOOL ; } ps . close ( ) ; rs . close ( ) ; ps = con . prepare Statement ( _ STR ) ; ps . set Timestamp ( _ NUM , new  Timestamp (  System . current Time Millis ( ) ) ) ; ps . set String ( _ NUM , user Name ) ; ps . execute ( ) ; ps . close ( ) ; return _ BOOL ; } catch ( final  SQLException sqle ) { s_logger . log (  Level .  SEVERE , _ STR + user Name + _ STR + _ STR + hashed Password , sqle ) ; throw new  Illegal State Exception ( sqle . get Message ( ) ) ; } finally {  Db Util . close Connection ( con ) ; } }
public static  Http URLConnection to Http Connection (  Request Batch requests ) { for (  Request request : requests ) { request . validate ( ) ; }  URL url = null ; try { if ( requests . size ( ) == _ NUM ) {  Request request = requests . get ( _ NUM ) ; url = new  URL ( request . get Url For Single Request ( ) ) ; } else { url = new  URL (  Server Protocol . get Graph Url Base ( ) ) ; } } catch (  Malformed URLException e ) { throw new  Facebook Exception ( _ STR , e ) ; }  Http URLConnection connection ; try { connection = create Connection ( url ) ; serialize To Url Connection ( requests , connection ) ; } catch (  IOException e ) { throw new  Facebook Exception ( _ STR , e ) ; } catch (  JSONException e ) { throw new  Facebook Exception ( _ STR , e ) ; } return connection ; }
Server Member update (  Status status ,  Instant time ) { if ( this . status != status ) { this . status =  Assert . not Null ( status , _ STR ) ; if ( time . is After ( updated ) ) { this . updated =  Assert . not Null ( time , _ STR ) ; } if ( status Change Listeners != null ) { status Change Listeners . accept ( status ) ; } } return this ; }
public static boolean is Client Level Only ( int  AD_ Client_ ID , int  AD_ Table_ ID ) {  Boolean share = is Shared (  AD_ Client_ ID ,  AD_ Table_ ID ) ; if ( share != null ) return share . boolean Value ( ) ; return _ BOOL ; }
@  Override public void action Performed (  Action Event event ) {  String command = event . get Action Command ( ) ; if ( command . equals ( _ STR ) ) { validate Tick Unit ( ) ; } else { super . action Performed ( event ) ; } }
public void run ( ) { byte [ ] buf = new byte [ _ NUM ] ; int count ; try { while ( ( count = in . read ( buf ) ) != - _ NUM ) { write ( buf , _ NUM , count ) ; }  String last In Buffer = buf Out . to String ( ) ; buf Out . reset ( ) ; if ( last In Buffer . length ( ) > _ NUM ) { out . println ( create Annotation ( ) + last In Buffer ) ; out . flush ( ) ; } } catch (  IOException e ) { } }
void bind If Not Bound (  String mod Name ,  Module Pointer mod Pointer ) { if ( context . get ( mod Name ) == null ) context . put ( mod Name , mod Pointer ) ; }
private static  File unpack Nar ( final  File nar , final  File base Working Directory ) throws  IOException { final  File nar Working Directory = new  File ( base Working Directory , nar . get Name ( ) + _ STR ) ; if ( ! nar Working Directory . exists ( ) ) { unpack ( nar , nar Working Directory , calculate Md5sum ( nar ) ) ; } else { final byte [ ] nar Md5 = calculate Md5sum ( nar ) ; final  File working Hash File = new  File ( nar Working Directory ,  HASH_ FILENAME ) ; if ( ! working Hash File . exists ( ) ) {  File Utils . delete File ( nar Working Directory , _ BOOL ) ; unpack ( nar , nar Working Directory , nar Md5 ) ; } else { final byte [ ] hash File Contents =  Files . read All Bytes ( working Hash File . to Path ( ) ) ; if ( !  Arrays . equals ( hash File Contents , nar Md5 ) ) { logger . info ( _ STR , new  Object [ ] { nar . get Absolute Path ( ) } ) ;  File Utils . delete File ( nar Working Directory , _ BOOL ) ; unpack ( nar , nar Working Directory , nar Md5 ) ; } } } return nar Working Directory ; }
public boolean has Incompatible Super Type (  Reference Binding other Type ) { if ( this == other Type ) return _ BOOL ;  Reference Binding [ ] interfaces To Visit = null ; int next Position = _ NUM ;  Reference Binding current Type = this ;  Type Binding match ; do { match = other Type . find Super Type Originating From ( current Type ) ; if ( match != null && match . is Provably Distinct ( current Type ) ) return _ BOOL ;  Reference Binding [ ] its Interfaces = current Type . super Interfaces ( ) ; if ( its Interfaces != null && its Interfaces !=  Binding .  NO_ SUPERINTERFACES ) { if ( interfaces To Visit == null ) { interfaces To Visit = its Interfaces ; next Position = interfaces To Visit . length ; } else { int its Length = its Interfaces . length ; if ( next Position + its Length >= interfaces To Visit . length )  System . arraycopy ( interfaces To Visit , _ NUM , interfaces To Visit = new  Reference Binding [ next Position + its Length + _ NUM ] , _ NUM , next Position ) ; next Interface : for ( int a = _ NUM ; a < its Length ; a ++ ) {  Reference Binding next = its Interfaces [ a ] ; for ( int b = _ NUM ; b < next Position ; b ++ ) if ( next == interfaces To Visit [ b ] ) continue next Interface ; interfaces To Visit [ next Position ++ ] = next ; } } } } while ( ( current Type = current Type . superclass ( ) ) != null ) ; for ( int i = _ NUM ; i < next Position ; i ++ ) { current Type = interfaces To Visit [ i ] ; if ( current Type == other Type ) return _ BOOL ; match = other Type . find Super Type Originating From ( current Type ) ; if ( match != null && match . is Provably Distinct ( current Type ) ) return _ BOOL ;  Reference Binding [ ] its Interfaces = current Type . super Interfaces ( ) ; if ( its Interfaces != null && its Interfaces !=  Binding .  NO_ SUPERINTERFACES ) { int its Length = its Interfaces . length ; if ( next Position + its Length >= interfaces To Visit . length )  System . arraycopy ( interfaces To Visit , _ NUM , interfaces To Visit = new  Reference Binding [ next Position + its Length + _ NUM ] , _ NUM , next Position ) ; next Interface : for ( int a = _ NUM ; a < its Length ; a ++ ) {  Reference Binding next = its Interfaces [ a ] ; for ( int b = _ NUM ; b < next Position ; b ++ ) if ( next == interfaces To Visit [ b ] ) continue next Interface ; interfaces To Visit [ next Position ++ ] = next ; } } } return _ BOOL ; }
private boolean is In Radius ( float x , float y , float radius ) {  Vector2f point = new  Vector2f ( x , y ) ; return  Math . abs ( point . length ( ) ) <= radius ; }
public void test Merge One Filter Into Empty Document ( ) throws  Exception {  String src Xml = _ STR ;  Web Xml src Web Xml =  Web Xml Io . parse Web Xml ( new  Byte Array Input Stream ( src Xml . get Bytes ( _ STR ) ) , null ) ;  String merge Xml = _ STR + _ STR + _ STR + _ STR + _ STR + _ STR ;  Web Xml merge Web Xml =  Web Xml Io . parse Web Xml ( new  Byte Array Input Stream ( merge Xml . get Bytes ( _ STR ) ) , null ) ;  Web Xml Merger merger = new  Web Xml Merger ( src Web Xml ) ; merger . merge Filters ( merge Web Xml ) ; assert True (  Web Xml Utils . has Filter ( src Web Xml , _ STR ) ) ; }
public static  Rectangle inverse Transform Rect (  Affine Transform af ,  Rectangle src ) {  Rectangle dest = new  Rectangle ( _ NUM , _ NUM , _ NUM , _ NUM ) ; src = abs Rect ( src ) ;  Point p1 = new  Point ( src . x , src . y ) ; p1 = inverse Transform Point ( af , p1 ) ; dest . x = p1 . x ; dest . y = p1 . y ; dest . width = ( int ) ( src . width / af . get Scale X ( ) ) ; dest . height = ( int ) ( src . height / af . get Scale Y ( ) ) ; return dest ; }
public void if Cmp ( final  Type type , final int mode , final  Label label ) { switch ( type . get Sort ( ) ) { case  Type .  LONG : mv . visit Insn (  Opcodes .  LCMP ) ; break ; case  Type .  DOUBLE : mv . visit Insn ( mode ==  GE || mode ==  GT ?  Opcodes .  DCMPL :  Opcodes .  DCMPG ) ; break ; case  Type .  FLOAT : mv . visit Insn ( mode ==  GE || mode ==  GT ?  Opcodes .  FCMPL :  Opcodes .  FCMPG ) ; break ; case  Type .  ARRAY : case  Type .  OBJECT : switch ( mode ) { case  EQ : mv . visit Jump Insn (  Opcodes .  IF_ ACMPEQ , label ) ; return ; case  NE : mv . visit Jump Insn (  Opcodes .  IF_ ACMPNE , label ) ; return ; } throw new  Illegal Argument Exception ( _ STR + type ) ; default : int int Op = - _ NUM ; switch ( mode ) { case  EQ : int Op =  Opcodes .  IF_ ICMPEQ ; break ; case  NE : int Op =  Opcodes .  IF_ ICMPNE ; break ; case  GE : int Op =  Opcodes .  IF_ ICMPGE ; break ; case  LT : int Op =  Opcodes .  IF_ ICMPLT ; break ; case  LE : int Op =  Opcodes .  IF_ ICMPLE ; break ; case  GT : int Op =  Opcodes .  IF_ ICMPGT ; break ; } mv . visit Jump Insn ( int Op , label ) ; return ; } mv . visit Jump Insn ( mode , label ) ; }
Standard Text Source ( char [ ] chars , int start , int len , int cstart , int clen , int level , int flags ,  Font font ,  Font Render Context frc ,  Core Metrics cm ) { if ( chars == null ) { throw new  Illegal Argument Exception ( _ STR ) ; } if ( cstart < _ NUM ) { throw new  Illegal Argument Exception ( _ STR + cstart ) ; } if ( start < cstart ) { throw new  Illegal Argument Exception ( _ STR + start + _ STR + cstart ) ; } if ( clen < _ NUM ) { throw new  Illegal Argument Exception ( _ STR + clen ) ; } if ( cstart + clen > chars . length ) { throw new  Illegal Argument Exception ( _ STR + clen + _ STR + cstart + _ STR + chars . length ) ; } if ( len < _ NUM ) { throw new  Illegal Argument Exception ( _ STR + len ) ; } if ( ( start + len ) > ( cstart + clen ) ) { throw new  Illegal Argument Exception ( _ STR + len + _ STR + start + _ STR + cstart + _ STR + clen ) ; } if ( font == null ) { throw new  Illegal Argument Exception ( _ STR ) ; } if ( frc == null ) { throw new  Illegal Argument Exception ( _ STR ) ; } this . chars = chars ; this . start = start ; this . len = len ; this . cstart = cstart ; this . clen = clen ; this . level = level ; this . flags = flags ; this . font = font ; this . frc = frc ; if ( cm != null ) { this . cm = cm ; } else {  Line Metrics metrics = font . get Line Metrics ( chars , cstart , clen , frc ) ; this . cm = ( (  Font Line Metrics ) metrics ) . cm ; } }
public static  String left Pad (  String s , int min Length , char filling ) { int ln = s . length ( ) ; if ( min Length <= ln ) { return s ; }  String Builder res = new  String Builder ( min Length ) ; int dif = min Length - ln ; for ( int i = _ NUM ; i < dif ; i ++ ) { res . append ( filling ) ; } res . append ( s ) ; return res . to String ( ) ; }
protected  String parse (  Reader reader ) throws  IOException { if ( ! reader . mark Supported ( ) ) { reader = new  Buffered Reader ( reader ) ; }  String Writer sw = new  String Writer ( ) ; start Script ( sw ) ; int c ; while ( ( c = reader . read ( ) ) != - _ NUM ) { if ( c == _ STR ) { reader . mark ( _ NUM ) ; c = reader . read ( ) ; if ( c != _ STR ) { sw . write ( _ STR ) ; reader . reset ( ) ; } else { reader . mark ( _ NUM ) ; c = reader . read ( ) ; if ( c == _ STR ) { groovy Expression ( reader , sw ) ; } else { reader . reset ( ) ; groovy Section ( reader , sw ) ; } } continue ; } if ( c == _ STR ) { reader . mark ( _ NUM ) ; c = reader . read ( ) ; if ( c != _ STR ) { sw . write ( _ STR ) ; reader . reset ( ) ; } else { reader . mark ( _ NUM ) ; sw . write ( _ STR ) ; process GSstring ( reader , sw ) ; } continue ; } if ( c == _ STR ) { sw . write ( _ STR ) ; } if ( c == _ STR || c == _ STR ) { if ( c == _ STR ) { reader . mark ( _ NUM ) ; c = reader . read ( ) ; if ( c != _ STR ) { reader . reset ( ) ; } } sw . write ( _ STR ) ; continue ; } sw . write ( c ) ; } end Script ( sw ) ; return sw . to String ( ) ; }
public  String to HTML ( ) {  String Builder builder = new  String Builder ( ) ; int num Classes = classes . size ( ) ; builder . append ( _ STR ) ; builder . append ( _ STR ) ; builder . append (  String . format ( _ STR , num Classes + _ NUM ) ) ; builder . append ( _ STR ) ; for (  T predicted : classes ) { builder . append ( _ STR ) ; builder . append ( predicted ) ; builder . append ( _ STR ) ; } builder . append ( _ STR ) ; builder . append ( _ STR ) ;  String first Column Label =  String . format ( _ STR , num Classes + _ NUM ) ; for (  T actual : classes ) { builder . append ( first Column Label ) ; first Column Label = _ STR ; builder . append (  String . format ( _ STR , actual ) ) ; for (  T predicted : classes ) { builder . append ( _ STR ) ; builder . append ( get Count ( actual , predicted ) ) ; builder . append ( _ STR ) ; } builder . append ( _ STR ) ; builder . append ( get Actual Total ( actual ) ) ; builder . append ( _ STR ) ; builder . append ( _ STR ) ; } builder . append ( _ STR ) ; for (  T predicted : classes ) { builder . append ( _ STR ) ; builder . append ( get Predicted Total ( predicted ) ) ; builder . append ( _ STR ) ; } builder . append ( _ STR ) ; builder . append ( _ STR ) ; builder . append ( _ STR ) ; return builder . to String ( ) ; }
public  Inhibit Any Policy Extension (  Boolean critical ,  Object value ) throws  IOException { this . extension Id =  PKIXExtensions .  Inhibit Any Policy_ Id ; if ( ! critical . boolean Value ( ) ) throw new  IOException ( _ STR + _ STR ) ; this . critical = critical . boolean Value ( ) ; this . extension Value = ( byte [ ] ) value ;  Der Value val = new  Der Value ( this . extension Value ) ; if ( val . tag !=  Der Value . tag_ Integer ) throw new  IOException ( _ STR + _ STR ) ; if ( val . data == null ) throw new  IOException ( _ STR + _ STR ) ; int skip Certs Value = val . get Integer ( ) ; if ( skip Certs Value < - _ NUM ) throw new  IOException ( _ STR ) ; if ( skip Certs Value == - _ NUM ) { this . skip Certs =  Integer .  MAX_ VALUE ; } else { this . skip Certs = skip Certs Value ; } }
@  Override public final boolean is Open ( ) { return is Open . get ( ) ; }
public static  Map <  String ,  Object > perform Find List (  Dispatch Context dctx ,  Map <  String ,  Object > context ) {  Integer view Size = (  Integer ) context . get ( _ STR ) ; if ( view Size == null ) view Size =  Integer . value Of ( _ NUM ) ; context . put ( _ STR , view Size ) ;  Integer view Index = (  Integer ) context . get ( _ STR ) ; if ( view Index == null ) view Index =  Integer . value Of ( _ NUM ) ; context . put ( _ STR , view Index ) ;  Map <  String ,  Object > result = perform Find ( dctx , context ) ; int start = view Index . int Value ( ) * view Size . int Value ( ) ;  List <  Generic Value > list = null ;  Integer list Size = null ; try {  Entity List Iterator it = (  Entity List Iterator ) result . get ( _ STR ) ; list = it . get Partial List ( start + _ NUM , view Size ) ; list Size = it . get Results Size After Partial List ( ) ; it . close ( ) ; } catch (  Exception e ) {  Debug . log Info ( _ STR + e , module ) ; } result . put ( _ STR , list Size ) ; result . put ( _ STR , list ) ; result . remove ( _ STR ) ; return result ; }
public static void flag Document As Corrected (  Element element ) {  Document doc = element . get Owner Document ( ) ; if ( doc != null ) { doc . set User Data ( _ STR , _ STR , null ) ; } }
@  Override public void flush ( ) { super . flush ( ) ; try { if ( out != null ) synchronized ( out ) { out . flush ( ) ; } } catch (  Socket Exception se ) { close ( ) ; } catch (  IOException ioe ) { ioe . print Stack Trace ( ) ; close ( ) ; } }
public void verify Equals Contract Positive (  Object x ,  Object y ,  Object z ) {  Assert . assert True ( x . equals ( x ) ) ;  Assert . assert True ( x . equals ( y ) && y . equals ( x ) ) ;  Assert . assert True ( x . equals ( y ) && y . equals ( z ) && x . equals ( z ) ) ;  Assert . assert True ( x . equals ( y ) ) ;  Assert . assert True ( x . equals ( y ) ) ;  Assert . assert True ( x . equals ( y ) ) ;  Assert . assert True ( y . equals ( z ) ) ;  Assert . assert True ( y . equals ( z ) ) ;  Assert . assert True ( y . equals ( z ) ) ;  Assert . assert False ( x . equals ( null ) ) ;  Assert . assert False ( y . equals ( null ) ) ;  Assert . assert False ( z . equals ( null ) ) ; }
@  Override public final void write Char ( int v ) throws  IOException { work [ _ NUM ] = ( byte ) v ; work [ _ NUM ] = ( byte ) ( v > > _ NUM ) ; dis . write ( work , _ NUM , _ NUM ) ; }
public void load From File (  String s File Name ) throws  File Not Found Exception ,  IOException {  File Reader fr File = new  File Reader ( s File Name ) ;  String s Text = _ STR ; int c = fr File . read ( ) ; while ( c != - _ NUM ) { s Text += c ; c = fr File . read ( ) ; } add Text ( s Text ) ; fr File . close ( ) ; }
public void test Find Spring Attributes Open Ldap ( ) {  Ldap Proxy proxy = get Ldap Open Ldap ( ) ;  List result = null ; try { result = proxy . find ( get Ldap Search VO ( _ STR ,  Ldap Constants .  NO_ SEARCH_ LIMIT , null , null , new  String [ ] { _ STR } ,  Ldap Scope Constants .  SCOPE_ SUBTREE ) ) ; } catch (  Exception e ) { } assert Not Null ( result ) ; assert Equals ( _ NUM , result . size ( ) ) ; }
public  Time Table XYDataset ( ) { this (  Time Zone . get Default ( ) ,  Locale . get Default ( ) ) ; }
public boolean extract Eigenvectors (  Vec3 result1 ,  Vec3 result2 ,  Vec3 result3 ) { if ( result1 == null || result2 == null || result3 == null ) { throw new  Illegal Argument Exception (  Logger . log Message (  Logger .  ERROR , _ STR , _ STR , _ STR ) ) ; } if ( this . m [ _ NUM ] != this . m [ _ NUM ] || this . m [ _ NUM ] != this . m [ _ NUM ] || this . m [ _ NUM ] != this . m [ _ NUM ] ) { return _ BOOL ; } final double  EPSILON = _ NUM ; final int  MAX_ SWEEPS = _ NUM ; double m11 = this . m [ _ NUM ] ; double m12 = this . m [ _ NUM ] ; double m13 = this . m [ _ NUM ] ; double m22 = this . m [ _ NUM ] ; double m23 = this . m [ _ NUM ] ; double m33 = this . m [ _ NUM ] ; double [ ] [ ] r = new double [ _ NUM ] [ _ NUM ] ; r [ _ NUM ] [ _ NUM ] = r [ _ NUM ] [ _ NUM ] = r [ _ NUM ] [ _ NUM ] = _ NUM ; for ( int a = _ NUM ; a <  MAX_ SWEEPS ; a ++ ) { if (  Math . abs ( m12 ) <  EPSILON &&  Math . abs ( m13 ) <  EPSILON &&  Math . abs ( m23 ) <  EPSILON ) { break ; } if ( m12 != _ NUM ) { double u = ( m22 - m11 ) * _ NUM / m12 ; double u2 = u * u ; double u2p1 = u2 + _ NUM ; double t = ( u2p1 != u2 ) ? ( ( u < _ NUM ) ? - _ NUM : _ NUM ) * (  Math . sqrt ( u2p1 ) -  Math . abs ( u ) ) : _ NUM / u ; double c = _ NUM /  Math . sqrt ( t * t + _ NUM ) ; double s = c * t ; m11 -= t * m12 ; m22 += t * m12 ; m12 = _ NUM ; double temp = c * m13 - s * m23 ; m23 = s * m13 + c * m23 ; m13 = temp ; for ( int i = _ NUM ; i < _ NUM ; i ++ ) { temp = c * r [ i ] [ _ NUM ] - s * r [ i ] [ _ NUM ] ; r [ i ] [ _ NUM ] = s * r [ i ] [ _ NUM ] + c * r [ i ] [ _ NUM ] ; r [ i ] [ _ NUM ] = temp ; } } if ( m13 != _ NUM ) { double u = ( m33 - m11 ) * _ NUM / m13 ; double u2 = u * u ; double u2p1 = u2 + _ NUM ; double t = ( u2p1 != u2 ) ? ( ( u < _ NUM ) ? - _ NUM : _ NUM ) * (  Math . sqrt ( u2p1 ) -  Math . abs ( u ) ) : _ NUM / u ; double c = _ NUM /  Math . sqrt ( t * t + _ NUM ) ; double s = c * t ; m11 -= t * m13 ; m33 += t * m13 ; m13 = _ NUM ; double temp = c * m12 - s * m23 ; m23 = s * m12 + c * m23 ; m12 = temp ; for ( int i = _ NUM ; i < _ NUM ; i ++ ) { temp = c * r [ i ] [ _ NUM ] - s * r [ i ] [ _ NUM ] ; r [ i ] [ _ NUM ] = s * r [ i ] [ _ NUM ] + c * r [ i ] [ _ NUM ] ; r [ i ] [ _ NUM ] = temp ; } } if ( m23 != _ NUM ) { double u = ( m33 - m22 ) * _ NUM / m23 ; double u2 = u * u ; double u2p1 = u2 + _ NUM ; double t = ( u2p1 != u2 ) ? ( ( u < _ NUM ) ? - _ NUM : _ NUM ) * (  Math . sqrt ( u2p1 ) -  Math . abs ( u ) ) : _ NUM / u ; double c = _ NUM /  Math . sqrt ( t * t + _ NUM ) ; double s = c * t ; m22 -= t * m23 ; m33 += t * m23 ; m23 = _ NUM ; double temp = c * m12 - s * m13 ; m13 = s * m12 + c * m13 ; m12 = temp ; for ( int i = _ NUM ; i < _ NUM ; i ++ ) { temp = c * r [ i ] [ _ NUM ] - s * r [ i ] [ _ NUM ] ; r [ i ] [ _ NUM ] = s * r [ i ] [ _ NUM ] + c * r [ i ] [ _ NUM ] ; r [ i ] [ _ NUM ] = temp ; } } } int i1 = _ NUM ; int i2 = _ NUM ; int i3 = _ NUM ; int itemp ; double temp ; if ( m11 < m22 ) { temp = m11 ; m11 = m22 ; m22 = temp ; itemp = i1 ; i1 = i2 ; i2 = itemp ; } if ( m22 < m33 ) { temp = m22 ; m22 = m33 ; m33 = temp ; itemp = i2 ; i2 = i3 ; i3 = itemp ; } if ( m11 < m22 ) { temp = m11 ; m11 = m22 ; m22 = temp ; itemp = i1 ; i1 = i2 ; i2 = itemp ; } result1 . set ( r [ _ NUM ] [ i1 ] , r [ _ NUM ] [ i1 ] , r [ _ NUM ] [ i1 ] ) ; result2 . set ( r [ _ NUM ] [ i2 ] , r [ _ NUM ] [ i2 ] , r [ _ NUM ] [ i2 ] ) ; result3 . set ( r [ _ NUM ] [ i3 ] , r [ _ NUM ] [ i3 ] , r [ _ NUM ] [ i3 ] ) ; result1 . normalize ( ) ; result2 . normalize ( ) ; result3 . normalize ( ) ; result1 . multiply ( m11 ) ; result2 . multiply ( m22 ) ; result3 . multiply ( m33 ) ; return _ BOOL ; }
public static void write Swapped Integer (  Output Stream output , int value ) throws  IOException { output . write ( ( byte ) ( ( value > > _ NUM ) & _ NUM ) ) ; output . write ( ( byte ) ( ( value > > _ NUM ) & _ NUM ) ) ; output . write ( ( byte ) ( ( value > > _ NUM ) & _ NUM ) ) ; output . write ( ( byte ) ( ( value > > _ NUM ) & _ NUM ) ) ; }
public static void queue Column Load (  ICubic World world ,  Cube IO loader , int x , int z ,  Consumer <  Column > runnable ) {  Queued Column key = new  Queued Column ( x , z , world ) ;  Async Column IOProvider task = column Tasks . get ( key ) ; if ( task == null ) { task = new  Async Column IOProvider ( key , loader ) ; task . add Callback ( runnable ) ; column Tasks . put ( key , task ) ; pool . execute ( task ) ; } else { task . add Callback ( runnable ) ; } }
private boolean is Category Visible In Shop ( final  Long category Id ) { final  Set <  Long > cat Ids = shop Service . get Shop Categories Ids (  Shop Code Context . get Shop Id ( ) ) ;  Category category = category Service . get By Id ( category Id ) ; final  Date now = new  Date ( ) ; while ( category != null &&  Domain Api Utils . is Object Available Now ( _ BOOL , category . get Availablefrom ( ) , category . get Availableto ( ) , now ) && category . get Category Id ( ) != category . get Parent Id ( ) ) { if ( cat Ids . contains ( category Id ) ) { return _ BOOL ; } category = category Service . get By Id ( category . get Parent Id ( ) ) ; } return _ BOOL ; }
public void action Performed (  Action Event e ) {  Action Map map = tab Pane . get Action Map ( ) ; if ( map != null ) {  String action Key ; if ( e . get Source ( ) == scroll Forward Button ) { action Key = _ STR ; } else { action Key = _ STR ; }  Action action = map . get ( action Key ) ; if ( action != null && action . is Enabled ( ) ) { action . action Performed ( new  Action Event ( tab Pane ,  Action Event .  ACTION_ PERFORMED , null , e . get When ( ) , e . get Modifiers ( ) ) ) ; } } }
private  String lookup Local Address ( ) { long timeout = _ NUM * _ NUM ; long expire Time =  Current Time . current Time ( ) + timeout ;  String address ; while ( ( address = allocate Local Address ( ) ) == null &&  Current Time . current Time ( ) < expire Time ) { try {  Thread . sleep ( _ NUM ) ; } catch (  Exception e ) { } } if ( address == null ) { throw new  Config Exception (  L . l ( _ STR + _ STR + _ STR , _server Bartender . get Id ( ) , _server Bartender . get Address ( ) ) ) ; } return address ; }
public void remove Change Listener (  Change Listener l ) { listeners . remove ( l ) ; }
public static  Request Log copy ( ) {  Request Log current =  RLOG . get ( ) ; return new  Request Log ( current ) ; }
public static  String html Decode (  String str ) { if ( str == null ) { return null ; } try { str =  URLDecoder . decode ( str , _ STR ) ; } catch ( final  Throwable e ) { e . print Stack Trace ( ) ; } return  Encoding . html Only Decode ( str ) ; }
public void test Then Accept Both_source Cancelled ( ) throws  Throwable { for (  Execution Mode m :  Execution Mode . values ( ) ) for ( boolean may Interrupt If Running : new boolean [ ] { _ BOOL , _ BOOL } ) for ( boolean f First : new boolean [ ] { _ BOOL , _ BOOL } ) for ( boolean fail First : new boolean [ ] { _ BOOL , _ BOOL } ) for (  Integer v1 : new  Integer [ ] { _ NUM , null } ) { final  Completable Future <  Integer > f = new  Completable Future < > ( ) ; final  Completable Future <  Integer > g = new  Completable Future < > ( ) ; final  Subtract Action r1 = new  Subtract Action ( m ) ; final  Subtract Action r2 = new  Subtract Action ( m ) ; final  Subtract Action r3 = new  Subtract Action ( m ) ; final  Completable Future <  Integer > fst = f First ? f : g ; final  Completable Future <  Integer > snd = ! f First ? f : g ; final  Callable <  Boolean > complete1 = fail First ? null : null ; final  Callable <  Boolean > complete2 = fail First ? null : null ; final  Completable Future <  Void > h1 = m . then Accept Both ( f , g , r1 ) ; assert True ( complete1 . call ( ) ) ; final  Completable Future <  Void > h2 = m . then Accept Both ( f , g , r2 ) ; check Incomplete ( h1 ) ; check Incomplete ( h2 ) ; assert True ( complete2 . call ( ) ) ; final  Completable Future <  Void > h3 = m . then Accept Both ( f , g , r3 ) ; check Completed With Wrapped Cancellation Exception ( h1 ) ; check Completed With Wrapped Cancellation Exception ( h2 ) ; check Completed With Wrapped Cancellation Exception ( h3 ) ; r1 . assert Not Invoked ( ) ; r2 . assert Not Invoked ( ) ; r3 . assert Not Invoked ( ) ; check Completed Normally ( fail First ? snd : fst , v1 ) ; check Cancelled ( fail First ? fst : snd ) ; } }
private void read Properties ( ) {  Properties props ;  Enumeration < ? > enm ;  String name ;  String [ ] laf ;  String tmp Str ; int i ;  Memory mem ; m_ Info . clear ( ) ; props =  System . get Properties ( ) ; enm = props . property Names ( ) ; while ( enm . has More Elements ( ) ) { name = (  String ) enm . next Element ( ) ; m_ Info . put ( name , (  String ) props . get ( name ) ) ; } m_ Info . put ( _ STR ,  Version .  VERSION ) ; laf =  Look And Feel . get Installed Look And Feels ( ) ; tmp Str = _ STR ; for ( i = _ NUM ; i < laf . length ; i ++ ) { if ( i > _ NUM ) { tmp Str += _ STR ; } tmp Str += laf [ i ] ; } m_ Info . put ( _ STR , tmp Str ) ; m_ Info . put ( _ STR ,  Look And Feel . get System Look And Feel ( ) ) ; mem = new  Memory ( ) ; m_ Info . put ( _ STR , _ STR +  Utils . double To String (  Memory . to Mega Byte ( mem . get Initial ( ) ) , _ NUM ) + _ STR + _ STR + mem . get Initial ( ) + _ STR ) ; m_ Info . put ( _ STR , _ STR +  Utils . double To String (  Memory . to Mega Byte ( mem . get Max ( ) ) , _ NUM ) + _ STR + _ STR + mem . get Max ( ) + _ STR ) ; }
public boolean table Exists (  String table ) throws  Database Exception { boolean result = _ BOOL ;  Result Set rs = null ; try {  Database Meta Data dbm = connection . get Meta Data ( ) ;  String types [ ] = { _ STR } ; rs = dbm . get Tables ( null , null , table , types ) ; result = rs . next ( ) ; rs . close ( ) ; } catch (  SQLException e ) { throw ( new  Database Exception ( e ) ) ; } finally { if ( rs != null ) { try { rs . close ( ) ; } catch (  SQLException e ) { } } } return result ; }
public void add All (  Collection < ? extends  T > collection ) { if ( m Event Delegate != null ) m Event Delegate . add Data ( collection == null ? _ NUM : collection . size ( ) ) ; if ( collection != null && collection . size ( ) != _ NUM ) { synchronized ( m Lock ) { m Objects . add All ( collection ) ; } } int data Count = collection == null ? _ NUM : collection . size ( ) ; if ( m Observer != null ) m Observer . on Item Range Inserted ( get Count ( ) - data Count + _ NUM , data Count ) ; if ( m Notify On Change ) notify Item Range Inserted ( headers . size ( ) + get Count ( ) - data Count + _ NUM , data Count ) ; log ( _ STR + ( headers . size ( ) + get Count ( ) - data Count + _ NUM ) + _ STR + ( data Count ) ) ; }
public static void add To Current File List (  String old File Name ,  String new File Name ,  String log Name ) {  Array List file List = (  Array List ) current File List . get (  PREFIX + log Name ) ; if ( file List == null ) { file List = new  Array List ( ) ; } current File List . remove (  PREFIX + log Name ) ; file List . remove (  PREFIX + old File Name ) ; file List . add (  PREFIX + new File Name ) ; if ( ! old File Name . equals ( new File Name ) ) { file List . add (  PREFIX + old File Name ) ; } current File List . put (  PREFIX + log Name , file List ) ; }
public  View Property Action (  Application app , @  Nullable  View view ,  String property Name ,  Object property Value ) { this ( app , view , property Name , property Value . get Class ( ) , property Value ) ; }
public static synchronized boolean execute (  String sql Statement ) { boolean execute Ok = _ BOOL ; logger . trace (  String . format ( _ STR , sql Statement ) ) ; final  Statement  S = get Statement ( ) ; if (  S == null ) { logger . error ( _ STR ) ; return _ BOOL ; } try { execute Ok =  S . execute ( sql Statement ) ; } catch (  Throwable t ) { surface Throwable (  String . format ( _ STR , sql Statement ) , t ) ; } finally { cleanup (  S ) ; } logger . trace ( _ STR + execute Ok ) ; return execute Ok ; }
public void write ( byte [ ] buf , int off , int len ) throws  IOException { output . write ( buf , off , len ) ; bytes Written += len ; }
@  Suppress Warnings ( _ STR ) public static  String url Encode (  String s ) { try { return  URLEncoder . encode ( s , _ STR ) ; } catch (  Unsupported Encoding Exception e ) { return  URLEncoder . encode ( s ) ; } }
public static void import Expression Types ( final  CConnection connection , final int raw Module Id , final int module Id ) throws  SQLException { final  String query = _ STR +  CTable Names .  EXPRESSION_ TYPES_ TABLE + _ STR + module Id + _ STR + _ STR +  String . format (  CTable Names .  RAW_ EXPRESSION_ TYPES_ TABLE , raw Module Id ) ; connection . execute Update ( query , _ BOOL ) ; }
public static void assume Currency Support (  String ... codes ) { try { for (  String code : codes ) {  Currency obj =  Currency . get Instance ( code ) ; assert Not Null ( code , obj ) ; } } catch (  Illegal Argument Exception e ) {  Assume . assume No Exception ( e ) ; } }
public static  Float string To Float (  String s ,  Float default Value ) { try { return  Float . parse Float ( s ) ; } catch (  Number Format Exception nfe ) { return default Value ; } }
public static void show Dialog If ( @  Nullable  Dialog dialog , boolean show ) { if ( dialog != null ) { if ( show ) { dialog . show ( ) ; } else { dialog . hide ( ) ; } } }
@  Override protected boolean parameters Are Valid ( ) { boolean all Is Ok ; all Is Ok = _ BOOL ;  String text ; int junk ; boolean temp ; temp = int Parameter Is Valid ( bootload , _ NUM , _ NUM ) ; all Is Ok &= temp ; if ( ! temp ) { log . info ( _ STR + bootload . get Text ( ) ) ; } temp = int Parameter Is Valid ( mfg , _ NUM , _ NUM ) ; all Is Ok &= temp ; if ( ! temp ) { log . info ( _ STR + mfg . get Text ( ) ) ; } temp = int Parameter Is Valid ( developer , _ NUM , _ NUM ) ; all Is Ok &= temp ; if ( ! temp ) { log . info ( _ STR + bootload . get Text ( ) ) ; } temp = int Parameter Is Valid ( product , _ NUM , _ NUM ) ; all Is Ok &= temp ; if ( ! temp ) { log . info ( _ STR + product . get Text ( ) ) ; } temp = int Parameter Is Valid ( hardware , _ NUM , _ NUM ) ; all Is Ok &= temp ; if ( ! temp ) { log . info ( _ STR + hardware . get Text ( ) ) ; } temp = int Parameter Is Valid ( software , _ NUM , _ NUM ) ; all Is Ok &= temp ; if ( ! temp ) { log . info ( _ STR + software . get Text ( ) ) ; } temp = int Parameter Is Valid ( delay ,  Integer . parse Int (  MIN_ DELAY_ VALUE ) ,  Integer . parse Int (  MAX_ DELAY_ VALUE ) ) ; all Is Ok &= temp ; if ( ! temp ) { log . info ( _ STR + delay . get Text ( ) ) ; } temp = ( hardgroup . get Selection ( ) != null ) ; all Is Ok &= temp ; if ( ! temp ) { log . info ( _ STR ) ; } temp = ( softgroup . get Selection ( ) != null ) ; all Is Ok &= temp ; if ( ! temp ) { log . info ( _ STR ) ; } temp = _ BOOL ; eestart . set Foreground (  Color . black ) ; text = eestart . get Text ( ) ; if ( text . equals ( _ STR ) ) { eestart . set Text ( _ STR ) ; eestart . set Foreground (  Color . red ) ; temp = _ BOOL ; } else { try { junk =  Integer . parse Int ( text , _ NUM ) ; } catch (  Number Format Exception ex ) { junk = - _ NUM ; } if ( ( junk <  Integer . parse Int (  MIN_ EESTART_ VALUE , _ NUM ) ) || ( ( junk % _ NUM ) != _ NUM ) || ( junk >  Integer . parse Int (  MAX_ EESTART_ VALUE , _ NUM ) ) ) { eestart . set Foreground (  Color . red ) ; temp = _ BOOL ; } else { eestart . set Foreground (  Color . black ) ; temp = _ BOOL ; } } eestart . update UI ( ) ; all Is Ok &= temp ; if ( all Is Ok == _ BOOL ) { log . debug ( _ STR ) ; } return all Is Ok ; }
public static double enlargement (  Spatial Comparable exist ,  Spatial Comparable addit ) { final int dim = assert Same Dimensionality ( exist , addit ) ; double v1 = _ NUM ; double v2 = _ NUM ; for ( int i = _ NUM ; i < dim ; i ++ ) { final double emin = exist . get Min ( i ) ; final double emax = exist . get Max ( i ) ; final double amin = addit . get Min ( i ) ; final double amax = addit . get Max ( i ) ; final double min =  Math . min ( emin , amin ) ; final double max =  Math . max ( emax , amax ) ; v1 *= ( max - min ) ; v2 *= ( emax - emin ) ; } return v2 - v1 ; }
public boolean can Get (  Class type ) { if ( type == null ) return _ BOOL ; if ( m_column Type . is Primitive ( ) ) { boolean prim Types = type . is Assignable From ( m_column Type ) || (  Type Lib . is Numeric Type ( m_column Type ) &&  Type Lib . is Numeric Type ( type ) ) ; return prim Types || type . is Assignable From (  Type Lib . get Wrapper Type ( m_column Type ) ) || type . is Assignable From (  String . class ) ; } else { return type . is Assignable From ( m_column Type ) ; } }
public static  String pad Right (  String s , int len , char pad_ch ) { if ( s . length ( ) >= len ) { return s ; } else {  String Builder sb = new  String Builder ( ) ; int n = len - s . length ( ) ; sb . append ( s ) ; for ( int i = _ NUM ; i < n ; i ++ ) { sb . append ( pad_ch ) ; } return sb . to String ( ) ; } }
public static void assert Equals (  String message ,  Nominal Mapping expected ,  Nominal Mapping actual , boolean ignore Order ) { if ( expected == actual ) { return ; }  Assert . assert True ( expected == null && actual == null || expected != null && actual != null ) ; if ( expected == null || actual == null ) { return ; }  Assert . assert Equals ( message + _ STR , expected . size ( ) , actual . size ( ) ) ;  List <  String > expected Values = expected . get Values ( ) ;  List <  String > actual Values = actual . get Values ( ) ;  Set <  String > expected Values Set = new  Hash Set <  String > ( expected Values ) ;  Set <  String > actual Values Set = new  Hash Set <  String > ( actual Values ) ;  Assert . assert Equals ( message + _ STR , expected Values Set , actual Values Set ) ; if ( ! ignore Order ) {  Iterator <  String > expected It = expected Values . iterator ( ) ; while ( expected It . has Next ( ) ) {  String expected Value = expected It . next ( ) ;  Assert . assert Equals ( message + _ STR + expected Value + _ STR , expected . map String ( expected Value ) , actual . map String ( expected Value ) ) ; } } }
public static  Throwable should Fail (  Class clazz ,  String script ) {  Throwable th = null ; try {  Groovy Shell shell = new  Groovy Shell ( ) ; shell . evaluate ( script , generic Script Name ( ) ) ; } catch (  Groovy Runtime Exception gre ) { th =  Script Bytecode Adapter . unwrap ( gre ) ; } catch (  Throwable e ) { th = e ; } if ( th == null ) { fail ( _ STR + clazz . get Name ( ) ) ; } else if ( ! clazz . is Instance ( th ) ) { fail ( _ STR + clazz . get Name ( ) + _ STR + th ) ; } return th ; }
public  Name Search find Matching Name ( final  Set <  String > names ) { final  Name Search ret = new  Name Search ( names ) ;  Expression name = get Object ( _ NUM ) ; if ( name != null ) { if ( ret . search ( name ) ) { return ret ; } } if ( ! ret . found ( ) ) { name = get Subject ( _ NUM ) ; if ( name != null ) { if ( ret . search ( name ) ) { return ret ; } } } if ( ! ret . found ( ) ) { name = get Subject ( _ NUM ) ; if ( name != null ) { if ( ret . search ( name ) ) { return ret ; } } } if ( ! ret . found ( ) ) { name = get Unknown Type Expression ( _ NUM ) ; if ( name != null ) { if ( ! name . has Amount ( ) ) {  Expression num = get Numeral ( _ NUM ) ; if ( num != null ) { name . set Amount ( num . get Amount ( ) ) ; } } if ( ret . search ( name ) ) { return ret ; } } } return ret ; }
public void request Password Expiration Warned Time ( ) { operations . add (  Password Policy State Operation Type .  GET_ PASSWORD_ EXPIRATION_ WARNED_ TIME ) ; }
public synchronized void update Path (  Property Change Listener listener ,  Object new Object ,  Set update Set ) { if ( current Object != new Object ) { remove Listeners ( ) ; } if ( ( children != null ) && ( children . length > _ NUM ) ) { try {  Object new Value = null ; if ( new Object != null ) { update Set . add ( new Object ) ; new Value = extract New Value ( new Object ) ; } for (  Bind Path child : children ) { child . update Path ( listener , new Value , update Set ) ; } } catch (  Exception e ) { } } if ( current Object != new Object ) { add Listeners ( listener , new Object , update Set ) ; } }
public static  String pad (  String str , int total Chars ) { if ( str == null ) str = _ STR ; int slen = str . length ( ) ;  String Builder sb = new  String Builder ( str ) ; for ( int i = _ NUM ; i < total Chars - slen ; i ++ ) { sb . append ( _ STR ) ; } return sb . to String ( ) ; }
private boolean check Resource (  Collection <  Integer > list , int id ) { boolean flag = _ BOOL ; if ( list == null || id < _ NUM ) { return flag ; }  Integer obj = null ;  Iterator <  Integer > it = list . iterator ( ) ; while ( it . has Next ( ) ) { obj = it . next ( ) ; if ( obj . int Value ( ) == id ) { flag = _ BOOL ; break ; } } return flag ; }
protected double kernel ( int n , char [ ] s , int end Index S , char [ ] t , int end Index T ) { if (  Math . min ( end Index S + _ NUM , end Index T + _ NUM ) < n ) { return get Return Value ( n ) ; } double result = _ NUM ; for ( int i S = end Index S ; i S > n - _ NUM ; i S -- ) { double buf = _ NUM ; char x = s [ i S ] ; for ( int j = _ NUM ; j <= end Index T ; j ++ ) { if ( t [ j ] == x ) { buf += kernel Helper ( n - _ NUM , s , i S - _ NUM , t , j - _ NUM ) ; } } result += buf * m_powers Oflambda [ _ NUM ] ; } return result ; }
private  Connection open Connection ( boolean autocommit ) throws  SQLException {  Connection conn = data Src != null ? data Src . get Connection ( ) :  Driver Manager . get Connection ( conn Url , user , passwd ) ; if ( test Mode ) opened . increment ( ) ; conn . set Auto Commit ( autocommit ) ; return conn ; }
protected void sparse To Dense ( ) { if ( ! is Sparse ) { return ; } coordinates = new float [ dimension ] ; for ( int i = _ NUM ; i < dimension ; ++ i ) { coordinates [ i ] = _ NUM ; } for ( int i = _ NUM ; i < sparse Offsets . length ; ++ i ) { coordinates [  Math . abs ( sparse Offsets [ i ] ) - _ NUM ] =  Math . signum ( sparse Offsets [ i ] ) ; } is Sparse = _ BOOL ; }
public void add Queen At (  XYLocation l ) { if ( ! ( queen Exists At ( l ) ) ) squares [ l . get XCo Ordinate ( ) ] [ l . get YCo Ordinate ( ) ] = _ NUM ; }
public void add Header View (  View v ,  Object data , boolean is Selectable ) { if ( m Adapter != null && ! ( m Adapter instanceof  Header View List Adapter ) ) { throw new  Illegal State Exception ( _ STR ) ; }  Fixed View Info info = new  Fixed View Info ( ) ; info . view = v ; info . data = data ; info . is Selectable = is Selectable ; m Header View Infos . add ( info ) ; if ( m Adapter != null && m Observer != null ) { m Observer . on Changed ( ) ; } }
public void login (  Native App Driver driver ,  String email ,  String password ,  String sign In Button , boolean is Android ) { driver . clear Input By Id ( email ) ; if ( ! ( email . is Empty ( ) ) ) { driver . clear Input By Id ( email ) ; } driver . clear Input By Id ( password ) ; if ( ! ( password . is Empty ( ) ) ) { driver . clear Input By Id ( password ) ; } driver . enter Text To Element By Id ( email , email Id ) ; if ( is Android ) { driver . hide Keyboard ( ) ; } driver . enter Text To Element By Id ( password , this . password ) ; if ( is Android ) { driver . hide Keyboard ( ) ; } driver . click Element By Id ( sign In Button ) ; }
protected void put Option ( final  Class option Class , final  String [ ] names ) {  Check . is True ( names . length > _ NUM , _ STR ) ; _options To Canonical Names . put ( option Class , names [ _ NUM ] ) ; for ( int i = _ NUM ; i < names . length ; i ++ ) { _aliases To Options . put ( names [ i ] , option Class ) ; } }
@  Override protected void write Column Auto Increment Stmt (  Table table ,  Column column ,  String Builder ddl ) { ddl . append ( _ STR ) ; }
private static void save Confirmed Stack Traces (  Weak Reference <  Context > weak Context ) {  Context context = null ; if ( weak Context != null ) { context = weak Context . get ( ) ; if ( context != null ) { try {  String [ ] filenames = search For Report ( ) ;  Shared Preferences preferences = context . get Shared Preferences (  ARTISAN_ SDK ,  Context .  MODE_ PRIVATE ) ;  Editor editor = preferences . edit ( ) ; editor . put String ( _ STR , join Array ( filenames , _ STR ) ) ; editor . apply ( ) ; } catch (  Exception e ) { } } } }
private void paint Background (  Graphics2 D g ,  JComponent c , int x , int y , int width , int height ) {  Color color = c . get Background ( ) ; if ( state ==  Which .  BACKGROUND_ ENABLED ) { color = (  Color ) component Colors [ _ NUM ] ; } else if ( type ==  Common Control State .  DISABLED ) { color = new  Color ( color . get Red ( ) , color . get Green ( ) , color . get Blue ( ) , _ NUM ) ; }  Shape s = shape Generator . create Round Rectangle ( x + _ NUM , y + _ NUM , width - _ NUM , height - _ NUM ,  Corner Size .  BORDER ) ; g . set Paint ( color ) ; g . fill ( s ) ; if ( is Paint Line Seperators ( c ) ) { paint Line Separator ( g , c , width , height ) ; } }
public static void add Sub Schema (  String service Name ,  String sub Schema ,  String schema Type ,  String file Name ) throws  Upgrade Exception {  String class Method = _ STR ; if ( debug . message Enabled ( ) ) { debug . message ( class Method + _ STR + file Name + _ STR + service Name ) ; } try {  Service Schema ss = get Service Schema ( service Name , sub Schema , schema Type ) ; ss . add Sub Schema ( new  File Input Stream ( file Name ) ) ; } catch (  IOException ioe ) { throw new  Upgrade Exception ( _ STR ) ; } catch (  SSOException ssoe ) { throw new  Upgrade Exception ( _ STR ) ; } catch (  SMSException ssoe ) { throw new  Upgrade Exception ( _ STR ) ; } }
private  String Builder encode Product (  String Builder tokens ) {  List Iterator it = product Tokens . list Iterator ( ) ; while ( it . has Next ( ) ) { tokens . append ( (  String ) it . next ( ) ) ; } return tokens ; }
public boolean by Pass Control To Processor ( boolean flag ) { return _ BOOL ; }
public  Options put (  String option ,  Boolean value ) { if ( value == null ) { return remove ( option ) ; } options . put ( option ,  Boolean . to String ( value ) ) ; return this ; }
private final  String _decode Short Unicode Name ( int len ) throws  IOException { int out Ptr = _ NUM ; char [ ] out Buf = _text Buffer . empty And Get Current Segment ( ) ; int in Ptr = _input Ptr ; _input Ptr += len ; final int [ ] codes =  Smile Constants . s Utf8 Unit Lengths ; final byte [ ] in Buf = _input Buffer ; for ( int end = in Ptr + len ; in Ptr < end ; ) { int i = in Buf [ in Ptr ++ ] & _ NUM ; int code = codes [ i ] ; if ( code != _ NUM ) { switch ( code ) { case _ NUM : i = ( ( i & _ NUM ) << _ NUM ) | ( in Buf [ in Ptr ++ ] & _ NUM ) ; break ; case _ NUM : i = ( ( i & _ NUM ) << _ NUM ) | ( ( in Buf [ in Ptr ++ ] & _ NUM ) << _ NUM ) | ( in Buf [ in Ptr ++ ] & _ NUM ) ; break ; case _ NUM : i = ( ( i & _ NUM ) << _ NUM ) | ( ( in Buf [ in Ptr ++ ] & _ NUM ) << _ NUM ) | ( ( in Buf [ in Ptr ++ ] & _ NUM ) << _ NUM ) | ( in Buf [ in Ptr ++ ] & _ NUM ) ; i -= _ NUM ; out Buf [ out Ptr ++ ] = ( char ) ( _ NUM | ( i > > _ NUM ) ) ; i = _ NUM | ( i & _ NUM ) ; break ; default : _report Error ( _ STR +  Integer . to Hex String ( i ) + _ STR ) ; } } out Buf [ out Ptr ++ ] = ( char ) i ; } _text Buffer . set Current Length ( out Ptr ) ; return _text Buffer . contents As String ( ) ; }
private void check Or Mark Private Access (  Expression source ,  Method Node mn ) { if ( mn == null ) { return ; }  Class Node declaring Class = mn . get Declaring Class ( ) ;  Class Node enclosing Class Node = type Checking Context . get Enclosing Class Node ( ) ; if ( declaring Class != enclosing Class Node || type Checking Context . get Enclosing Closure ( ) != null ) { int mods = mn . get Modifiers ( ) ; boolean same Module = declaring Class . get Module ( ) == enclosing Class Node . get Module ( ) ;  String package Name = declaring Class . get Package Name ( ) ; if ( package Name == null ) { package Name = _ STR ; } if ( (  Modifier . is Private ( mods ) && same Module ) ) { add Private Field Or Method Access ( source , declaring Class ,  Static Types Marker .  PV_ METHODS_ ACCESS , mn ) ; } else if (  Modifier . is Protected ( mods ) && ! package Name . equals ( enclosing Class Node . get Package Name ( ) ) && ! implements Interface Or Is Subclass Of ( enclosing Class Node , declaring Class ) ) {  Class Node cn = enclosing Class Node ; while ( ( cn = cn . get Outer Class ( ) ) != null ) { if ( implements Interface Or Is Subclass Of ( cn , declaring Class ) ) { add Private Field Or Method Access ( source , cn ,  Static Types Marker .  PV_ METHODS_ ACCESS , mn ) ; break ; } } } } }
public static  String construct Config Name (  String config Name ,  String Map scope ) {  String Builder builder = new  String Builder ( ) ; for (  Map .  Entry <  String ,  String > entry : scope . entry Set ( ) ) { builder . append ( entry . get Key ( ) ) ; builder . append ( _ STR ) ; builder . append ( entry . get Value ( ) ) ; builder . append ( _ STR ) ; } builder . append ( config Name ) ; return builder . to String ( ) ; }
public void sort (  Comparator <  Fragment Data > comparator ) { check Transaction ( ) ; save Old Order ( ) ; if ( comparator == null ) {  Collections . sort ( m Fragment Datas ) ; } else {  Collections . sort ( this . m Fragment Datas , comparator ) ; } check Position Change ( ) ; }
public static  Event Bean [ ] add To Array (  Event Bean [ ] array ,  Event Bean event To Add ) {  Event Bean [ ] new Array = new  Event Bean [ array . length + _ NUM ] ;  System . arraycopy ( array , _ NUM , new Array , _ NUM , array . length ) ; new Array [ new Array . length - _ NUM ] = event To Add ; return new Array ; }
public static  String replace (  String a ,  String b ,  String c ) {  String Buffer result = new  String Buffer ( c . length ( ) ) ; int i = _ NUM ; int j = c . index Of ( a ) ; while ( j >= i ) { result . append ( c . substring ( i , j ) ) ; result . append ( b ) ; i = j + a . length ( ) ; j = c . index Of ( a , i ) ; } result . append ( c . substring ( i , c . length ( ) ) ) ; return result . to String ( ) ; }
protected void on Page Scrolled ( int position , float offset , int offset Pixels ) { if ( m Decor Child Count > _ NUM ) { final int scroll Y = get Scroll Y ( ) ; int padding Top = get Padding Top ( ) ; int padding Bottom = get Padding Bottom ( ) ; final int height = get Height ( ) ; final int child Count = get Child Count ( ) ; for ( int i = _ NUM ; i < child Count ; i ++ ) { final  View child = get Child At ( i ) ; final  Layout Params lp = (  Layout Params ) child . get Layout Params ( ) ; if ( ! lp . is Decor ) continue ; final int vgrav = lp . gravity &  Gravity .  VERTICAL_ GRAVITY_ MASK ; int child Top = _ NUM ; switch ( vgrav ) { default : child Top = padding Top ; break ; case  Gravity .  TOP : child Top = padding Top ; padding Top += child . get Height ( ) ; break ; case  Gravity .  CENTER_ VERTICAL : child Top =  Math . max ( ( height - child . get Measured Height ( ) ) / _ NUM , padding Top ) ; break ; case  Gravity .  BOTTOM : child Top = height - padding Bottom - child . get Measured Height ( ) ; padding Bottom += child . get Measured Height ( ) ; break ; } child Top += scroll Y ; final int child Offset = child Top - child . get Top ( ) ; if ( child Offset != _ NUM ) { child . offset Top And Bottom ( child Offset ) ; } } } if ( m On Page Change Listener != null ) { m On Page Change Listener . on Page Scrolled ( position , offset , offset Pixels ) ; } if ( m Internal Page Change Listener != null ) { m Internal Page Change Listener . on Page Scrolled ( position , offset , offset Pixels ) ; } if ( m Page Transformer != null ) { final int scroll Y = get Scroll Y ( ) ; final int child Count = get Child Count ( ) ; for ( int i = _ NUM ; i < child Count ; i ++ ) { final  View child = get Child At ( i ) ; final  Layout Params lp = (  Layout Params ) child . get Layout Params ( ) ; if ( lp . is Decor ) continue ; final float transform Pos = ( float ) ( child . get Top ( ) - scroll Y ) / get Client Height ( ) ; m Page Transformer . transform Page ( child , transform Pos ) ; } } m Called Super = _ BOOL ; }
private void reflect Member Variables In Right Button ( ) { final boolean last Page Reached = ( view Pager . get Current Item ( ) + _ NUM ) == pages . size ( ) ; final boolean button Should Be Invisible = last Page Reached || right Button Disabled ; final boolean button Is Currently Invisible = right Button . get Visibility ( ) ==  View .  INVISIBLE ; final boolean should Update Button = button Should Be Invisible != button Is Currently Invisible ; if ( should Update Button ) { final  Animator button Animator = button Should Be Invisible ? button Animator Factory . new Right Button Disappear Animator ( right Button ) : button Animator Factory . new Right Button Appear Animator ( right Button ) ; if ( button Should Be Invisible ) { disable Button ( button Animator , right Button ) ; } else { enable Button ( button Animator , right Button ) ; } } }
public void test Decoder5 ( ) { boolean res ;  String original App Id Name = m App Id Name ; int original Content Type Value = m Content Type Value ;  Random rd = new  Random ( ) ; for ( int i = _ NUM ; i < _ NUM ; i ++ ) { m App Id Value = rd . next Int ( _ NUM ) ; m Content Type Value = rd . next Int ( _ NUM ) ; byte [ ] pdu = create PDU ( _ NUM ) ;  Wsp Type Decoder pdu Decoder = new  Wsp Type Decoder ( pdu ) ; res = pdu Decoder . seek XWap Application Id ( m Wsp Header Start , m Wsp Header Start + m Wsp Header Len - _ NUM ) ; assert True ( res ) ; int index = ( int ) pdu Decoder . get Value32 ( ) ; res = pdu Decoder . decode XWap Application Id ( index ) ; assert True ( res ) ;  Log . d (  LOG_ TAG , _ STR + m App Id Name + _ STR + pdu Decoder . get Value String ( ) + _ STR ) ; assert True ( m App Id Name . equals ( pdu Decoder . get Value String ( ) ) ) ; } m App Id Name = original App Id Name ; m Content Type Value = original Content Type Value ; }
public static boolean is Writable ( @  Non Null final  File file ) { boolean is Existing = file . exists ( ) ; try {  File Output Stream output = new  File Output Stream ( file , _ BOOL ) ; try { output . close ( ) ; } catch (  IOException e ) { } } catch (  File Not Found Exception e ) { if ( ! file . is Directory ( ) ) { return _ BOOL ; } } boolean result = file . can Write ( ) ; if ( ! is Existing ) { file . delete ( ) ; } return result ; }
public  Builder ( ) { }
@  Request Mapping ( value = _ STR , method = {  Request Method .  GET ,  Request Method .  POST } ) public void sso SSLDummy (  Locale locale ,  Model model , @  Path Variable ( value = _ STR )  String tenant ,  Http Servlet Request request ,  Http Servlet Response response ) throws  IOException { logger . info ( _ STR + tenant ) ; try {  Relying Party rp = validate Relying Party ( request , tenant ) ; if ( rp != null ) { logger . info ( _ STR + rp . get Url ( ) ) ;  URL rp Url = new  URL ( rp . get Url ( ) ) ;  URL redirect Url = new  URL ( rp Url . get Protocol ( ) , rp Url . get Host ( ) , rp Url . get Port ( ) , _ STR ) ;  String redirect Url Str = redirect Url . to String ( ) + _ STR + sso SSLDummy Query String ( request ) ; response . send Redirect ( redirect Url Str ) ; } else { logger . error ( _ STR + tenant + _ STR ) ; send Error ( locale , response , _ STR ) ; } } catch (  Exception e ) { logger . error ( _ STR , e ) ; send Error ( locale , response , e . get Localized Message ( ) ) ; } }
public void rotate X ( double theta ) {  Matrix3 D tmp = new  Matrix3 D ( ) ; double c =  Math . cos ( theta ) ; double s =  Math . sin ( theta ) ; tmp . set ( _ NUM , _ NUM , c ) ; tmp . set ( _ NUM , _ NUM , - s ) ; tmp . set ( _ NUM , _ NUM , s ) ; tmp . set ( _ NUM , _ NUM , c ) ; pre Multiply ( tmp ) ; }
public  Service Host start Factory (  Class < ? extends  Service > inst Service Class ,  Supplier <  Factory Service > factory Creator ) {  URI factory Uri =  Uri Utils . build Factory Uri ( this , inst Service Class ) ; return start Factory ( factory Creator , factory Uri . get Path ( ) ) ; }
private void wake In ( ) {  State In Pipe state Old ;  State In Pipe state New ; do { state Old = _state In Ref . get ( ) ; if ( state Old . is Active ( ) ) { return ; } state New = state Old . to Wake ( ) ; } while ( ! _state In Ref . compare And Set ( state Old , state New ) ) ; if ( state Old ==  State In Pipe .  IDLE ) { try (  Outbox Amp outbox =  Outbox Amp . current Or Create ( _services ) ) {  Objects . require Non Null ( outbox ) ;  Pipe Wake In Message <  T > msg = new  Pipe Wake In Message < > ( outbox , _in Ref , this ) ; outbox . offer ( msg ) ; } } }
protected  Set <  FIs A > create Initial Assignment Constraints ( final  Annotated Type Mirror assigned To , final  Annotated Type Mirror boxed Return Type , final  Annotated Type Factory type Factory , final  Set <  Type Variable > targets ) { final  Set <  FIs A > result = new  Linked Hash Set < > ( ) ; if ( assigned To != null ) { final  Set <  AFConstraint > reduced Constraints = new  Linked Hash Set < > ( ) ; final  Queue <  AFConstraint > constraints = new  Linked List < > ( ) ; constraints . add ( new  F2 A ( boxed Return Type , assigned To ) ) ; reduce Af Constraints ( type Factory , reduced Constraints , constraints , targets ) ; for ( final  AFConstraint reduced Constraint : reduced Constraints ) { if ( reduced Constraint instanceof  FIs A ) { result . add ( (  FIs A ) reduced Constraint ) ; } } } return result ; }
private static double parse Time (  String s ) throws  Number Format Exception { if ( s . length ( ) > _ NUM ) throw new  Number Format Exception ( _ STR + s + _ STR ) ; double result = _ NUM ; char [ ] c = s . to Char Array ( ) ; char [ ] x = new char [ ] { _ STR , _ STR , _ STR , _ STR } ; for ( int i = _ NUM ; i < c . length ; i ++ ) x [ i + _ NUM - c . length ] = c [ i ] ; try { int hours =  Integer . parse Int ( _ STR + x [ _ NUM ] + x [ _ NUM ] ) ; int minutes =  Integer . parse Int ( _ STR + x [ _ NUM ] + x [ _ NUM ] ) ; result = hours * _ NUM + minutes * _ NUM ; } catch (  Number Format Exception e ) { throw new  Number Format Exception ( _ STR + s + _ STR ) ; } if ( result < ( _ NUM * _ NUM ) ) result += ( _ NUM * _ NUM ) ; return result ; }
public  Core Descriptor (  Core Container container ,  String name ,  Path instance Dir ,  Map <  String ,  String > core Props ) { this . core Container = container ; this . instance Dir = instance Dir ; original Core Properties . set Property (  CORE_ NAME , name ) ;  Properties container Properties = container . get Container Properties ( ) ; name =  Properties Util . substitute Property ( check Property Is Not Empty ( name ,  CORE_ NAME ) , container Properties ) ; core Properties . put All ( default Properties ) ; core Properties . put (  CORE_ NAME , name ) ; for (  String propname : core Props . key Set ( ) ) {  String propvalue = core Props . get ( propname ) ; if ( is User Defined Property ( propname ) ) original Extra Properties . put ( propname , propvalue ) ; else original Core Properties . put ( propname , propvalue ) ; if ( ! required Properties . contains ( propname ) ) core Properties . set Property ( propname ,  Properties Util . substitute Property ( propvalue , container Properties ) ) ; } load Extra Properties ( ) ; build Substitutable Properties ( ) ; if ( container . is Zoo Keeper Aware ( ) ) { cloud Desc = new  Cloud Descriptor ( name , core Properties , this ) ; } else { cloud Desc = null ; } log . debug ( _ STR + core Properties ) ; }
private static int parse Or0 (  Matcher m ,  String group ) {  String matched = m . group ( group ) ; if ( matched == null ) { return _ NUM ; } return parse Int ( matched ) ; }
public  Pla Direction (  Pla Vector Int p_vector ) { this (  Big Integer . value Of ( p_vector . v_x ) ,  Big Integer . value Of ( p_vector . v_y ) ) ; }
@  Override public void execute (  Runnable command ) { tasks . add ( command ) ; if ( selecting && signal . compare And Set ( _ BOOL , _ BOOL ) ) { selector . wakeup ( ) ; } }
@  Suppress Warnings ( { _ STR , _ STR } ) public static int calculate Max Bitmap Size ( @  Non Null  Context context ) {  Window Manager wm = (  Window Manager ) context . get System Service (  Context .  WINDOW_ SERVICE ) ;  Display display = wm . get Default Display ( ) ;  Point size = new  Point ( ) ; int width , height ; if (  Build .  VERSION .  SDK_ INT >=  Build .  VERSION_ CODES .  HONEYCOMB_ MR2 ) { display . get Size ( size ) ; width = size . x ; height = size . y ; } else { width = display . get Width ( ) ; height = display . get Height ( ) ; } int screen Diagonal = ( int )  Math . sqrt (  Math . pow ( width , _ NUM ) +  Math . pow ( height , _ NUM ) ) ;  Canvas canvas = new  Canvas ( ) ; return  Math . min ( screen Diagonal * _ NUM ,  Math . min ( canvas . get Maximum Bitmap Width ( ) , canvas . get Maximum Bitmap Height ( ) ) ) ; }
public void add Tele Missile Attack (  Attack Action ea ) { pending Tele Missile Attacks . add Element ( ea ) ; process Game Event ( new  Game New Action Event ( this , ea ) ) ; }
public void test Overwrite With Tokens ( ) throws  Exception {  File config Home = new  File ( configuration . get Home ( ) ) ; assert True ( _ STR , config Home . exists ( ) && config Home . is Directory ( ) ) ;  File existing File = create File ( config Home , _ STR , _ STR ) ; assert Equals ( _ STR , read File ( existing File ) ) ;  String file Name = _ STR ;  String file Contents = _ STR ;  File file1 = create File ( config File Directory , file Name , file Contents ) ;  File Config config File = new  File Config ( ) ; config File . set File ( get Absolute Path ( file1 ) ) ; config File . set To File ( _ STR ) ; config File . set Overwrite ( _ STR ) ; config File . set Configfile ( _ STR ) ; configuration . set Property ( _ STR , _ STR ) ; test Copy ( config File , _ STR , _ STR ) ; assert Equals ( _ STR , read File ( existing File ) ) ; }
public void init ( ) { int len =  Constants .  FILE_ BLOCK_ SIZE ; byte [ ] salt ; byte [ ] magic =  HEADER . get Bytes (  Constants .  UTF8 ) ; if ( length ( ) <  HEADER_ LENGTH ) { checked Writing = _ BOOL ; write Direct ( magic , _ NUM , len ) ; salt = generate Salt ( ) ; write Direct ( salt , _ NUM , len ) ; init Key ( salt ) ; write ( magic , _ NUM , len ) ; checked Writing = _ BOOL ; } else { seek ( _ NUM ) ; byte [ ] buff = new byte [ len ] ; read Fully Direct ( buff , _ NUM , len ) ; if ( !  Arrays . equals ( buff , magic ) ) { throw  Db Exception . get (  Error Code .  FILE_ VERSION_ ERROR_1 , name ) ; } salt = new byte [ len ] ; read Fully Direct ( salt , _ NUM , len ) ; init Key ( salt ) ; read Fully ( buff , _ NUM ,  Constants .  FILE_ BLOCK_ SIZE ) ; if ( !  Arrays . equals ( buff , magic ) ) { throw  Db Exception . get (  Error Code .  FILE_ ENCRYPTION_ ERROR_1 , name ) ; } } }
public void add Listener ( final  Trainer Listener trainer Listener ) { if ( listeners == null ) { listeners = new  Array List <  Trainer Listener > ( ) ; } listeners . add ( trainer Listener ) ; }
private void check Query (  String query String ) throws  Exception {  Parsed Query query = parser . parse Query ( query String , null ) ;  Tuple Expr tuple Expr = query . get Tuple Expr ( ) ;  Collection <  Search Query Evaluator > queries = process ( interpreter , tuple Expr ) ; assert Equals ( _ STR , _ NUM , queries . size ( ) ) ; }
public void test Sub List And Non Structural Changes ( ) {  Copy On Write Array List <  String > list = new  Copy On Write Array List <  String > ( ) ; list . add All (  Arrays . as List ( _ STR , _ STR , _ STR , _ STR , _ STR ) ) ;  List <  String > bcd = list . sub List ( _ NUM , _ NUM ) ; list . set ( _ NUM , _ STR ) ; try { bcd . get ( _ NUM ) ; fail ( ) ; } catch (  Concurrent Modification Exception expected ) { } }
public void add Message (  Message message ) { messages . add ( message . render Text View ( context ) ) ; if ( messages . size ( ) > history Size ) { messages . remove ( _ NUM ) ; } notify Data Set Changed ( ) ; }
@  Override public boolean on Schedule (  Packing Plan packing ) {  LOG . info ( _ STR +  Local Context . topology Name ( config ) ) ; synchronized ( process To Container ) {  LOG . info ( _ STR ) ; start Executor ( _ NUM ) ; for (  Packing Plan .  Container Plan container : packing . get Containers ( ) ) { start Executor ( container . get Id ( ) ) ; } }  LOG . info ( _ STR ) ; return _ BOOL ; }
public static  Date string To Date (  String strdate , @  Suppress Warnings ( _ STR )  String format ) {  Date date = null ;  Simple Date Format formatter = new  Simple Date Format ( format ) ; try { date = formatter . parse ( strdate ) ; } catch (  Parse Exception e ) { e . print Stack Trace ( ) ; } return date ; }
public static void generate List Of Modules (  String Builder builder ) {  Iterator <  String > entry Iterator =  EXTENSIONS_ FQN . iterator ( ) ; while ( entry Iterator . has Next ( ) ) {  String gin Module FQN = entry Iterator . next ( ) ;  String has Comma = entry Iterator . has Next ( ) ? _ STR : _ STR ; builder . append (  Generator Utils .  TAB + gin Module FQN + _ STR + has Comma + _ STR ) ; } }
public  String preview ( ) {  String shortname = resource . get Shortname ( ) ; try {  File eml File = data Dir . resource Eml File ( shortname ) ;  LOG . debug ( _ STR + eml File . get Absolute Path ( ) ) ;  Input Stream in = new  File Input Stream ( eml File ) ; eml =  Eml Factory . build ( in ) ; } catch (  File Not Found Exception e ) {  LOG . error ( _ STR + get String Version ( ) + _ STR + shortname + _ STR ) ; return  NOT_ FOUND ; } catch (  IOException e ) {  String msg = get Text ( _ STR , new  String [ ] { get String Version ( ) , shortname } ) ;  LOG . error ( msg ) ; add Action Error ( msg ) ; return  ERROR ; } catch (  SAXException e ) {  String msg = get Text ( _ STR , new  String [ ] { get String Version ( ) , shortname } ) ;  LOG . error ( msg ) ; add Action Error ( msg ) ; return  ERROR ; } catch (  Parser Configuration Exception e ) {  String msg = get Text ( _ STR , new  String [ ] { get String Version ( ) , shortname } ) ;  LOG . error ( msg ) ; add Action Error ( msg ) ; return  ERROR ; }  Big Decimal next Version = resource . get Next Version ( ) ; resource = generate Preview Resource ( resource , eml , next Version ) ; finish Loading Detail ( resource , eml , next Version ) ; set Preview ( _ BOOL ) ; return  SUCCESS ; }
public int read ( char [ ] cbuf , int off , int len ) throws  IOException { int num = _ NUM ; int val ; if ( bo == _ STR ) { while ( num < len ) { if ( ( val = is . read ( ) ) < _ NUM ) { return ( num != _ NUM ) ? num : - _ NUM ; } cbuf [ off ++ ] = ( char ) ( ( val << _ NUM ) | ( is . read ( ) & _ NUM ) ) ; num ++ ; } } else { while ( num < len ) { if ( ( val = is . read ( ) ) < _ NUM ) { return ( num != _ NUM ) ? num : - _ NUM ; } cbuf [ off ++ ] = ( char ) ( ( is . read ( ) << _ NUM ) | ( val & _ NUM ) ) ; num ++ ; } } return num ; }
private boolean verify Value Range Upper Bound Input (  JComponent input ) {  JText Field text Field = (  JText Field ) input ;  String input String = text Field . get Text ( ) ; try { double value Upper Bound ; if ( input String . starts With ( _ STR ) ) { value Upper Bound =  Double . parse Double ( input String . substring ( _ NUM ) ) ; value Upper Bound = - value Upper Bound ; } else { value Upper Bound =  Double . parse Double ( input String ) ; } } catch (  Number Format Exception e ) { text Field . set Foreground (  Color .  RED ) ; return _ BOOL ; } text Field . set Foreground (  Color .  BLACK ) ; return _ BOOL ; }
@  Override public  Enumeration <  Option > list Options ( ) {  Vector <  Option > result = new  Vector <  Option > ( ) ; result . add Element ( new  Option ( _ STR , _ STR , _ NUM , _ STR ) ) ; result . add All (  Collections . list ( super . list Options ( ) ) ) ; return result . elements ( ) ; }
public  Client Properties Builder with Service Uri (  String service Uri ) { properties . set Property (  CLIENT_ SERVICE_ URI , service Uri ) ; return this ; }
public static void verify Getter Methods (  Class < ? > clazz ,  Mapped Field ... fields ) { for (  Mapped Field field : fields ) {  String field Name = field . get Name ( ) ;  Class < ? > field Type = field . get Type ( ) ;  String custom Get = field . get Method ( ) ; if ( ! is Null ( custom Get ) && ! custom Get . equals (  Constants .  DEFAULT_ ACCESSOR_ VALUE ) ) try { clazz . get Method ( custom Get ) ; continue ; } catch (  Exception e ) {  Error . custom Method ( _ STR , custom Get , clazz ) ; }  String method Name = get Method ( field Type , field Name ) ; try { clazz . get Method ( method Name ) ; } catch (  Exception e ) { if ( ! is Boolean ( field Type ) )  Error . method ( method Name , field Name , clazz ) ; try { method Name = ( m Get ( field Name ) ) ; clazz . get Method ( method Name ) ; } catch (  Exception e1 ) {  Error . method ( method Name , field Name , clazz ) ; } } field . get Method ( method Name ) ; } }
public  String random Positive Float (  Object owhole ,  Object odecimal ) { int whole =  Function Handler . get Int ( owhole ) ; int decimal =  Function Handler . get Int ( odecimal ) ;  String Builder output = new  String Builder ( ) ; output . append ( rnd . next Int ( _ NUM ) + _ NUM ) ; for ( int i = _ NUM ; i < whole - _ NUM ; i ++ ) { output . append ( rnd . next Int ( _ NUM ) ) ; } output . append ( _ STR ) ; for ( int i = _ NUM ; i < decimal ; i ++ ) { output . append ( rnd . next Int ( _ NUM ) ) ; } return output . to String ( ) ; }
private static int sum Row Sum Lt Ge Col Sum Gt Le ( double value , double [ ] bv ,  Binary Operator b Op ) throws  DMLRuntime Exception { int ix =  Arrays . binary Search ( bv , value ) ; int cnt = _ NUM ; if ( ix >= _ NUM ) { while ( value == bv [ ix ++ ] && ix < bv . length ) ; ix += ( value == bv [ bv . length - _ NUM ] ) ? _ NUM : _ NUM ; } cnt = bv . length -  Math . abs ( ix ) + _ NUM ; if ( b Op . fn instanceof  Less Than Equals || b Op . fn instanceof  Greater Than Equals ) cnt = bv . length - cnt ; return cnt ; }
private void check Points (  Collection <  Cache .  Entry <  Integer ,  Enemy Camp > > res ,  String ... points ) {  Set <  String > set = new  Hash Set < > (  Arrays . as List ( points ) ) ; assert Equals ( set . size ( ) , res . size ( ) ) ; for (  Cache .  Entry <  Integer ,  Enemy Camp > e : res ) assert True ( set . remove ( e . get Value ( ) . name ) ) ; }
public  IDevice learn Entity ( long mac Address ,  Short vlan ,  Integer ipv4 Address ,  Long switch DPID ,  Integer switch Port , boolean process Updates ) {  List <  IDevice Listener > listeners = device Listeners . get Ordered Listeners ( ) ; if ( ! process Updates ) { device Listeners . clear Listeners ( ) ; }  Vlan Vid v ;  IPv4 Address i ;  Datapath Id d ;  OFPort p ; if ( vlan != null && vlan . short Value ( ) <= _ NUM ) vlan = null ; if ( ipv4 Address != null && ipv4 Address == _ NUM ) ipv4 Address = null ; if ( vlan == null ) { v =  Vlan Vid . of Vlan ( - _ NUM ) ; } else { v =  Vlan Vid . of Vlan ( vlan ) ; } if ( ipv4 Address == null ) { i =  IPv4 Address .  NONE ; } else { i =  IPv4 Address . of ( ipv4 Address ) ; } if ( switch DPID == null ) { d =  Datapath Id . of ( _ NUM ) ; } else { d =  Datapath Id . of ( switch DPID . long Value ( ) ) ; } if ( switch Port == null ) { p =  OFPort .  ZERO ; } else { p =  OFPort . of ( switch Port ) ; }  IDevice res = learn Device By Entity ( new  Entity (  Mac Address . of ( mac Address ) , v , i , d , p , new  Date ( ) ) ) ; if ( listeners != null ) { for (  IDevice Listener listener : listeners ) { device Listeners . add Listener ( _ STR , listener ) ; } } return res ; }
private static  Buffer concat (  List <  Buffer > buffers ) { int total Length = _ NUM ;  Buffer largest Buffer = null ; for (  Buffer buffer : buffers ) { total Length += buffer . length ; if ( largest Buffer == null || buffer . array . length > largest Buffer . array . length ) { largest Buffer = buffer ; } } if ( largest Buffer == null ) { return new  Buffer ( _ NUM ) ; } int [ ] docs = largest Buffer . array ; if ( docs . length < total Length + _ NUM ) { docs =  Arrays . copy Of ( docs , total Length + _ NUM ) ; } total Length = largest Buffer . length ; for (  Buffer buffer : buffers ) { if ( buffer != largest Buffer ) {  System . arraycopy ( buffer . array , _ NUM , docs , total Length , buffer . length ) ; total Length += buffer . length ; } } return new  Buffer ( docs , total Length ) ; }
public  String show Switch Wwn ( ) throws  Network Device Controller Exception {  SSHPrompt [ ] prompts = {  SSHPrompt .  POUND ,  SSHPrompt .  GREATER_ THAN ,  SSHPrompt .  MDS_ CONFIG ,  SSHPrompt .  MDS_ CONFIG_ IVR_ ZONE ,  SSHPrompt .  MDS_ CONFIG_ IVR_ ZONESET } ;  String Builder buf = new  String Builder ( ) ; send Wait For (  MDSDialog Properties . get String ( _ STR ) , default Timeout , prompts , buf ) ;  String [ ] lines = get Lines ( buf ) ;  String [ ] regex = {  MDSDialog Properties . get String ( _ STR ) } ;  String switch Wwn = null ;  String [ ] groups = new  String [ _ NUM ] ; for (  String line : lines ) { int index = match ( line , regex , groups ) ; switch ( index ) { case _ NUM : switch Wwn = groups [ _ NUM ] ; break ; } if ( switch Wwn != null ) { break ; } } return switch Wwn ; }
public static  String [ ] split (  String string , char c ) { if ( count Matches ( string , c ) <= _ NUM ) return new  String [ ] { string } ;  String s = string + c ;  String [ ] sa = new  String [ count Matches ( string , c ) + _ NUM ] ;  String Builder sb = new  String Builder ( ) ; char [ ] ca = s . to Char Array ( ) ; int n = _ NUM , x ; for ( x = _ NUM ; x < ca . length ; x ++ ) { if ( ca [ x ] == c ) { sa [ n ] = sb . to String ( ) ; sb = new  String Builder ( ) ; n ++ ; } else { sb . append ( ca [ x ] ) ; } } return sa ; }
private  Image Icon add Space To Icon (  Image Icon icon ) { int width = icon . get Icon Width ( ) ; int height = icon . get Icon Height ( ) ; int hspace = _ NUM ;  Buffered Image res = new  Buffered Image ( width + hspace , height ,  Buffered Image .  TYPE_ INT_ ARGB ) ;  Graphics g = res . get Graphics ( ) ; g . draw Image ( icon . get Image ( ) , _ NUM , _ NUM , null ) ; g . dispose ( ) ; return new  Image Icon ( res ) ; }
public static byte [ ] read All (  Input Stream in Str ) throws  IOException {  Byte Array Output Stream buf = new  Byte Array Output Stream ( ) ; pipe All ( in Str , buf ) ; return buf . to Byte Array ( ) ; }
public static boolean starts With Ignore Case (  String search In , int start At ,  String search For ) { return search In . region Matches ( _ BOOL , start At , search For , _ NUM , search For . length ( ) ) ; }
@  Suppress Warnings ( _ STR ) private  Class validate Class (  Client Config cfg ) {  Class clazz = null ; try { clazz =  Class . for Name ( cfg . get Access Request Handler Classname ( ) ) ; } catch ( final  Class Not Found Exception e ) {  LOG . error ( _ STR + cfg . get Access Request Handler Classname ( ) + _ STR + cfg . get Name ( ) + _ STR , e ) ; return null ; }  Object inst = null ; try { inst =  Injector Holder . get Instance ( clazz ) ; } catch (  Configuration Exception |  Provision Exception e ) {  LOG . error ( _ STR + cfg . get Access Request Handler Classname ( ) + _ STR + cfg . get Name ( ) + _ STR , e ) ; return null ; }  Access Request Handler handler = null ; try { handler = (  Access Request Handler ) inst ; } catch ( final  Class Cast Exception e ) {  LOG . error ( _ STR + cfg . get Access Request Handler Classname ( ) + _ STR + cfg . get Name ( ) + _ STR , e ) ; return null ; } return clazz ; }
public synchronized void start (  Callback callback ) { if ( callback == null ) throw new  Illegal Argument Exception ( _ STR ) ; if ( m Thread != null || m Process != null ) throw new  Illegal State Exception ( _ STR ) ; m Callback = callback ; m Run = _ BOOL ; m Thread = new  Thread ( this ) ; m Thread . start ( ) ; }
@  Override public  Env Var add New Env Var (  String name ,  Class < ? > type ,  String value ) {  Env Var env Var = null ; if ( ! exist ( name ) ) { env Var = new  Env Var ( name , type , _ BOOL ) ; env Var . set Value ( value ) ; env Var List . add ( env Var ) ; } return env Var ; }
static private  String calc Threshold ( double score Threshold , double lambda ) { final double log Prob Threshold =  Math . log ( _ NUM - score Threshold / _ NUM ) ; int max Num = _ NUM ; if ( calc Log Prob ( max Num , _ BOOL , lambda ) > log Prob Threshold ) { return _ STR ; } int min Num = _ NUM ; while ( min Num < max Num ) { final int mid Num = ( max Num + min Num ) / _ NUM ; final boolean pass Threshold = calc Log Prob ( mid Num , _ BOOL , lambda ) <= log Prob Threshold ; if ( pass Threshold ) { max Num = mid Num ; } else { if ( mid Num == min Num ) { break ; } min Num = mid Num ; } } return  Integer . to String ( max Num ) ; }
public static int index Of Last Separator (  String filename ) { if ( filename == null ) { return - _ NUM ; } int last Unix Pos = filename . last Index Of (  UNIX_ SEPARATOR ) ; int last Windows Pos = filename . last Index Of (  WINDOWS_ SEPARATOR ) ; return  Math . max ( last Unix Pos , last Windows Pos ) ; }
@  Category (  Flaky Test . class ) @  Test public void test Put_ Validate Data On Member_ Primary Secondary_ Datastore ( ) { member1 . invoke ( null ) ;  Fixed Partition Attributes fpa1 =  Fixed Partition Attributes . create Fixed Partition (  Quarter1 , _ BOOL , _ NUM ) ;  Fixed Partition Attributes fpa2 =  Fixed Partition Attributes . create Fixed Partition (  Quarter2 , _ BOOL , _ NUM ) ;  List <  Fixed Partition Attributes > fpa List = new  Array List <  Fixed Partition Attributes > ( ) ; fpa List . add ( fpa1 ) ; fpa List . add ( fpa2 ) ; member1 . invoke ( null ) ; member2 . invoke ( null ) ; fpa1 =  Fixed Partition Attributes . create Fixed Partition (  Quarter2 , _ BOOL , _ NUM ) ; fpa2 =  Fixed Partition Attributes . create Fixed Partition (  Quarter3 , _ BOOL , _ NUM ) ; fpa List . clear ( ) ; fpa List . add ( fpa1 ) ; fpa List . add ( fpa2 ) ; member2 . invoke ( null ) ; member3 . invoke ( null ) ; fpa1 =  Fixed Partition Attributes . create Fixed Partition (  Quarter3 , _ BOOL , _ NUM ) ; fpa2 =  Fixed Partition Attributes . create Fixed Partition (  Quarter4 , _ BOOL , _ NUM ) ; fpa List . clear ( ) ; fpa List . add ( fpa1 ) ; fpa List . add ( fpa2 ) ; member3 . invoke ( null ) ; member4 . invoke ( null ) ; fpa1 =  Fixed Partition Attributes . create Fixed Partition (  Quarter4 , _ BOOL , _ NUM ) ; fpa2 =  Fixed Partition Attributes . create Fixed Partition (  Quarter1 , _ BOOL , _ NUM ) ; fpa List . clear ( ) ; fpa List . add ( fpa1 ) ; fpa List . add ( fpa2 ) ; member4 . invoke ( null ) ; member1 . invoke ( null ) ; member1 . invoke ( null ) ; member2 . invoke ( null ) ; member3 . invoke ( null ) ; member4 . invoke ( null ) ; member1 . invoke ( null ) ; member2 . invoke ( null ) ; member3 . invoke ( null ) ; member4 . invoke ( null ) ; }
public static  Prototype intern (  String descriptor ) { if ( descriptor == null ) { throw new  Null Pointer Exception ( _ STR ) ; }  Prototype result ; synchronized ( intern Table ) { result = intern Table . get ( descriptor ) ; } if ( result != null ) { return result ; }  Type [ ] params = make Parameter Array ( descriptor ) ; int param Count = _ NUM ; int at = _ NUM ; for ( ; ; ) { int start At = at ; char c = descriptor . char At ( at ) ; if ( c == _ STR ) { at ++ ; break ; } while ( c == _ STR ) { at ++ ; c = descriptor . char At ( at ) ; } if ( c == _ STR ) { int end At = descriptor . index Of ( _ STR , at ) ; if ( end At == - _ NUM ) { throw new  Illegal Argument Exception ( _ STR ) ; } at = end At + _ NUM ; } else { at ++ ; } params [ param Count ] =  Type . intern ( descriptor . substring ( start At , at ) ) ; param Count ++ ; }  Type return Type =  Type . intern Return Type ( descriptor . substring ( at ) ) ;  Std Type List parameter Types = new  Std Type List ( param Count ) ; for ( int i = _ NUM ; i < param Count ; i ++ ) { parameter Types . set ( i , params [ i ] ) ; } result = new  Prototype ( descriptor , return Type , parameter Types ) ; return put Intern ( result ) ; }
public void delete Share (  String id ,  String zone Name ) throws  Isilon Exception {  String uri With Zone Name = get URIWith Zone Name ( id , zone Name ) ; delete ( _base Url . resolve (  URI_ SMB_ SHARES ) , uri With Zone Name , _ STR ) ; }
public static  Map <  String ,  String > add Auth Header (  String username ,  String password ,  Map <  String ,  String > params ) {  String creds =  String . format ( _ STR , username , password ) ;  String encoded =  Base64 . encode To String ( creds . get Bytes ( ) ,  Base64 .  NO_ WRAP ) ; params . put ( _ STR , _ STR + encoded ) ; return params ; }
private void disable All ( ) { acs Txt . set Enabled ( _ BOOL ) ; cert Txt . set Enabled ( _ BOOL ) ; rel Txt . set Enabled ( _ BOOL ) ; combo . set Enabled ( _ BOOL ) ; acs Lbl . set Enabled ( _ BOOL ) ; cert Lbl . set Enabled ( _ BOOL ) ; lbl Loc . set Enabled ( _ BOOL ) ; rel Lbl . set Enabled ( _ BOOL ) ; dep Check . set Enabled ( _ BOOL ) ; browse Btn . set Enabled ( _ BOOL ) ; new Cert Btn . set Enabled ( _ BOOL ) ; location . set Enabled ( _ BOOL ) ; requires Https Check . set Enabled ( _ BOOL ) ; embed Cert Check . set Enabled ( _ BOOL ) ; cert Info Txt . set Enabled ( _ BOOL ) ; }
public void reload (  Solr Core core ,  Solr Index Searcher searcher ) throws  IOException {  LOG . info ( _ STR + name + _ STR ) ; if ( dictionary == null && store Dir != null ) {  File lookup File = get Store File ( ) ; if ( lookup File . exists ( ) ) {  File Input Stream is = new  File Input Stream ( lookup File ) ; try { if ( lookup . load ( is ) ) { return ; } } finally {  IOUtils . close While Handling Exception ( is ) ; } } else {  LOG . info ( _ STR ) ; } } }
public  Element root From File (  File file ) throws  JDOMException ,  IOException { if ( log . is Debug Enabled ( ) ) { log . debug ( _ STR + file . get Path ( ) ) ; }  File Input Stream fs = new  File Input Stream ( file ) ; try { return get Root ( verify , fs ) ; } finally { fs . close ( ) ; } }
public  String [ ] granted Permissions ( ) {  List <  String > list = new  Array List ( ) ; for ( int i = _ NUM ; i < m Perms . size ( ) ; i ++ ) { if ( m Perms . get ( m User Permission . get ( i ) ) ==  Package Manager .  PERMISSION_ GRANTED ) list . add ( m User Permission . get ( i ) ) ; } return list . to Array ( new  String [ list . size ( ) ] ) ; }
public void execute (  Runnable task ) {  Executor executor = get Executor ( ) ; if ( executor == null ) task . run ( ) ; else executor . execute ( task ) ; }
private static  String convert Functional Color (  String raw , boolean alpha ) { if ( !  Text Utils . is Empty ( raw ) ) { raw = remove Leading Space ( raw ) ; if ( ( ! alpha && raw . starts With (  FUNCTIONAL_ RGB_ PREFIX ) && ! raw . starts With (  FUNCTIONAL_ RGBA_ PREFIX ) ) || ( alpha && raw . starts With (  FUNCTIONAL_ RGBA_ PREFIX ) ) ) { int start = raw . index Of (  OPEN_ PAREN ) ; int end = raw . last Index Of (  CLOSE_ PAREN ) ; if ( start != - _ NUM && end != - _ NUM ) { raw = raw . substring ( start + _ NUM , end ) ;  String [ ] gradients = raw . split (  COMMA ) ; int gradient_num = alpha ?  NUM_ FUNC_ RGBA_ GRADIENT :  NUM_ FUNC_ RGB_ GRADIENT ; if ( gradients != null && ( gradients . length == gradient_num ) ) {  String Builder rrggbb Builder = new  String Builder (  HEX_ PREFIX ) ; rrggbb Builder . append ( parse RGB ( gradients ) ) ; if ( alpha ) { rrggbb Builder . insert ( _ NUM , parse Alpha ( gradients [  NUM_ FUNC_ RGBA_ GRADIENT - _ NUM ] ) ) ; } return rrggbb Builder . to String ( ) ; } } } } return null ; }
public static boolean is Final ( final  Field field ) { return  Modifier . is Final ( field . get Modifiers ( ) ) ; }
public boolean is Session Token (  String site ,  String token ) { if ( ! site . contains ( _ STR ) ) { site = site + ( _ STR ) ; }  Http Session Tokens Set site Tokens = session Tokens . get ( site ) ; if ( site Tokens == null ) return _ BOOL ; return site Tokens . is Session Token ( token ) ; }
protected void fill Kernel Ordinates (  Complex Array ordinates , double band Width ) { final int length = ordinates . length ; final double a = _ NUM / (  Math . sqrt ( _ NUM *  Math .  PI ) * band Width ) ; final double precision = - _ NUM / ( band Width * band Width ) ; for ( int i = _ NUM ; i < length ; i ++ ) { final double x = ordinates . real [ i ] ; ordinates . real [ i ] = a *  Math . exp ( x * x * precision ) ; } }
public void export (  Data Output Stream out ) throws  IOException { out . write Int ( seq Id ) ; if ( info . is Row Block Enabled ( ) ) out . write Int ( n Rows ) ; export ( out , primary Key ) ; for (  Byte Array cb : cell Blocks ) { export ( out , cb ) ; } }
private  Hash Map <  String ,  Object > create Header Details (  String index Number ,  String transaction ) {  Simple Date Format sdf = new  Simple Date Format ( _ STR ) ;  String description = _ STR + index Number + _ STR + transaction + _ STR + sdf . format ( new  Date ( ) ) ;  String source URL =  URL_ FOR_ DCB + index Number ;  Hash Map <  String ,  Object > headerdetails = new  Hash Map <  String ,  Object > ( ) ; headerdetails . put (  Voucher Constant .  VOUCHERNAME ,  VOUCHERNAME ) ; headerdetails . put (  Voucher Constant .  VOUCHERTYPE ,  VOUCHERTYPE ) ; headerdetails . put (  Voucher Constant .  DESCRIPTION , description ) ; headerdetails . put (  Voucher Constant .  VOUCHERNUMBER ,  VOUCHERNUMBER ) ; headerdetails . put (  Voucher Constant .  VOUCHERDATE , new  Date ( ) ) ; headerdetails . put (  Voucher Constant .  STATUS , _ NUM ) ; headerdetails . put (  Voucher Constant .  MODULEID ,  PTIS_ EG_ MODULES_ ID ) ; headerdetails . put (  Voucher Constant .  DEPARTMENTCODE ,  DEPT_ CODE_ TAX ) ; headerdetails . put (  Voucher Constant .  FUNDCODE , get Fund Code ( ) ) ; headerdetails . put (  Voucher Constant .  SOURCEPATH , source URL ) ; return headerdetails ; }
private void update Radio Links ( ) { if ( m_ Exp != null ) { m_ Exp . set Split By Data Set ( m_split By Data Set . is Selected ( ) ) ; } }
public static  External App Id determine External Intent Source (  String package Name ,  Intent intent ) {  String app Id =  Intent Utils . safe Get String Extra ( intent ,  Browser .  EXTRA_ APPLICATION_ ID ) ;  External App Id external Id =  External App Id .  OTHER ; if ( app Id == null ) {  String url = get Url From Intent ( intent ) ; if ( url != null && url . starts With (  TWITTER_ LINK_ PREFIX ) ) { external Id =  External App Id .  TWITTER ; } else if ( url != null && url . starts With (  FACEBOOK_ LINK_ PREFIX ) ) { external Id =  External App Id .  FACEBOOK ; } else if ( url != null && url . starts With (  NEWS_ LINK_ PREFIX ) ) { external Id =  External App Id .  NEWS ; } } else { if ( app Id . equals (  PACKAGE_ PLUS ) ) { external Id =  External App Id .  PLUS ; } else if ( app Id . equals (  PACKAGE_ GMAIL ) ) { external Id =  External App Id .  GMAIL ; } else if ( app Id . equals (  PACKAGE_ HANGOUTS ) ) { external Id =  External App Id .  HANGOUTS ; } else if ( app Id . equals (  PACKAGE_ MESSENGER ) ) { external Id =  External App Id .  MESSENGER ; } else if ( app Id . equals (  PACKAGE_ LINE ) ) { external Id =  External App Id .  LINE ; } else if ( app Id . equals (  PACKAGE_ WHATSAPP ) ) { external Id =  External App Id .  WHATSAPP ; } else if ( app Id . equals (  PACKAGE_ GSA ) ) { external Id =  External App Id .  GSA ; } else if ( app Id . equals ( package Name ) ) { external Id =  External App Id .  CHROME ; } } return external Id ; }
public  List <  Properties > find All Properties (  String uri ) throws  IOException {  String fulluri = _path + uri ;  List <  Properties > properties = new  Array List < > ( ) ;  Enumeration <  URL > resources = get Resources ( fulluri ) ; while ( resources . has More Elements ( ) ) {  URL url = resources . next Element ( ) ;  Properties props = load Properties ( url ) ; properties . add ( props ) ; } return properties ; }
public void resolve Classpath Entries (  List <  Classpath Entry Dto > entries ) { libs = new  Hash Set < > ( ) ; containers = new  Hash Set < > ( ) ; sources = new  Hash Set < > ( ) ; projects = new  Hash Set < > ( ) ; for (  Classpath Entry Dto entry : entries ) { switch ( entry . get Entry Kind ( ) ) { case  Classpath Entry Kind .  LIBRARY : libs . add ( entry . get Path ( ) ) ; break ; case  Classpath Entry Kind .  CONTAINER : containers . add ( entry ) ; break ; case  Classpath Entry Kind .  SOURCE : sources . add ( entry . get Path ( ) ) ; break ; case  Classpath Entry Kind .  PROJECT : projects . add (  WORKSPACE_ PATH + entry . get Path ( ) ) ; break ; default : } } }
public static  Source from File (  File f ,  Charset cs ) throws  IOException { try (  Input Stream is = new  File Input Stream ( f ) ) { return from Stream ( is , f . to URI ( ) , cs ) ; } }
public void test Merge One Servlet Into Empty Document ( ) throws  Exception {  String src Xml = _ STR ;  Web Xml src Web Xml =  Web Xml Io . parse Web Xml ( new  Byte Array Input Stream ( src Xml . get Bytes ( _ STR ) ) , null ) ;  String merge Xml = _ STR + _ STR + _ STR + _ STR + _ STR + _ STR ;  Web Xml merge Web Xml =  Web Xml Io . parse Web Xml ( new  Byte Array Input Stream ( merge Xml . get Bytes ( _ STR ) ) , null ) ;  Web Xml Merger merger = new  Web Xml Merger ( src Web Xml ) ; merger . merge ( merge Web Xml ) ; assert True (  Web Xml Utils . has Servlet ( src Web Xml , _ STR ) ) ; }
private  RE union REs (  Set <  RE > coll ) throws  Interrupted Exception { if ( coll . is Empty ( ) ) { return  RE . empty ; }  RE acc =  RE . empty ; for (  RE re : coll ) { acc = acc . union ( re ) ; } return acc ; }
public  Attr Set read ( java . security .  Principal principal ,  Guid guid ,  String attr Names [ ] ) throws  UMSException {  String id = guid . get Dn ( ) ;  Connection Entry Reader entry Reader ;  Search Request request =  LDAPRequests . new Search Request ( id ,  Search Scope .  BASE_ OBJECT , _ STR , attr Names ) ; entry Reader = read LDAPEntry ( principal , request ) ; if ( entry Reader == null ) { throw new  Access Rights Exception ( id ) ; }  Collection <  Attribute > attrs = new  Array List < > ( ) ; try (  Connection Entry Reader reader = entry Reader ) { while ( reader . has Next ( ) ) { if ( reader . is Reference ( ) ) { reader . read Reference ( ) ; }  Search Result Entry entry = entry Reader . read Entry ( ) ; for (  Attribute attr : entry . get All Attributes ( ) ) { attrs . add ( attr ) ; } } if ( attrs . is Empty ( ) ) { throw new  Entry Not Found Exception ( i18n . get String (  IUMSConstants .  ENTRY_ NOT_ FOUND , new  String [ ] { id } ) ) ; } return new  Attr Set ( attrs ) ; } catch (  IOException e ) { throw new  UMSException ( i18n . get String (  IUMSConstants .  UNABLE_ TO_ READ_ ENTRY , new  String [ ] { id } ) , e ) ; } }
public void register Fix ( @  Not Null  Intention Action fix , @  Nullable  Text Range range , @  Nullable final  Highlight Display Key key ) { if ( range == null ) { range = new  Text Range ( my Start Offset , my End Offset ) ; } if ( my Quick Fixes == null ) { my Quick Fixes = new  Array List <  Quick Fix Info > ( ) ; } my Quick Fixes . add ( new  Quick Fix Info ( fix , range , key ) ) ; }
protected void create Container (  IPath pathname ) { if ( directory Entry Cache . contains Key ( pathname ) ) { return ; }  Zip Entry parent ; if ( pathname . segment Count ( ) == _ NUM ) { parent = root ; } else { parent = (  Zip Entry ) directory Entry Cache . get ( pathname . remove Last Segments ( _ NUM ) ) ; }  Zip Entry new Entry = new  Zip Entry ( pathname . to String ( ) ) ; directory Entry Cache . put ( pathname , new Entry ) ; add To Children ( parent , new Entry ) ; }
public void test Has Attributes1 ( ) throws  Throwable {  Document doc ;  Element element ;  Node List element List ; boolean has Attributes ; doc = (  Document ) load ( _ STR , builder ) ; element List = doc . get Elements By Tag Name ( _ STR ) ; element = (  Element ) element List . item ( _ NUM ) ; has Attributes = element . has Attributes ( ) ; assert False ( _ STR , has Attributes ) ; element List = doc . get Elements By Tag Name ( _ STR ) ; element = (  Element ) element List . item ( _ NUM ) ; has Attributes = element . has Attributes ( ) ; assert True ( _ STR , has Attributes ) ; }
public void ignorable Whitespace (  XMLString text ,  Augmentations augs ) throws  XNIException { try { if ( f Document Handler != null ) { f Document Handler . ignorable Whitespace ( text . ch , text . offset , text . length ) ; } if ( f Content Handler != null ) { f Content Handler . ignorable Whitespace ( text . ch , text . offset , text . length ) ; } } catch (  SAXException e ) { throw new  XNIException ( e ) ; } }
protected  String encode Cookie (  Serializable Cookie cookie ) { if ( cookie == null ) return null ;  Byte Array Output Stream os = new  Byte Array Output Stream ( ) ; try {  Object Output Stream output Stream = new  Object Output Stream ( os ) ; output Stream . write Object ( cookie ) ; } catch (  IOException e ) { e . print Stack Trace ( ) ; return null ; } return byte Array To Hex String ( os . to Byte Array ( ) ) ; }
public void add Observer (  Notification Observer observer ) { if ( ! observers . contains ( observer ) ) { observers . add ( observer ) ; } }
@  Api Operation ( value = _ STR ) @  Request Mapping ( value = _ STR , method =  Request Method .  PUT ) @  Response Status (  Http Status .  NO_ CONTENT ) @  Response Body public final void put Heartbeat ( @  Path Variable ( _ STR )  String engine Name , @  Api Param ( value = _ STR ) @  Request Param ( value =  Web Constants .  SECURITY_ TOKEN )  String security Token , @  Request Body  Heartbeat heartbeat ) {  ISymmetric Engine engine = get Symmetric Engine ( engine Name ) ; if ( security Verified ( heartbeat . get Node Id ( ) , engine , security Token ) ) { heartbeat Impl ( engine , heartbeat ) ; } else { throw new  Not Allowed Exception ( ) ; } }
@  Override public void serialize (  String name , byte [ ] message ,  Output Stream out ) throws  IOException { byte [ ] header = new byte [ _ NUM +  COMMAND_ LEN + _ NUM + _ NUM ] ; uint32 To Byte Array BE ( params . get Packet Magic ( ) , header , _ NUM ) ; for ( int i = _ NUM ; i < name . length ( ) && i <  COMMAND_ LEN ; i ++ ) { header [ _ NUM + i ] = ( byte ) ( name . code Point At ( i ) & _ NUM ) ; }  Utils . uint32 To Byte Array LE ( message . length , header , _ NUM +  COMMAND_ LEN ) ; byte [ ] hash =  Sha256 Hash . hash Twice ( message ) ;  System . arraycopy ( hash , _ NUM , header , _ NUM +  COMMAND_ LEN + _ NUM , _ NUM ) ; out . write ( header ) ; out . write ( message ) ; if ( log . is Debug Enabled ( ) ) log . debug ( _ STR , name ,  HEX . encode ( header ) +  HEX . encode ( message ) ) ; }
public  SSLSocket Factory build SSLSocket Factory ( ) throws  Key Store Exception {  SSLContext ssl Context = null ; try {  Key Manager Factory key Manager Factory =  Key Manager Factory . get Instance (  Key Manager Factory . get Default Algorithm ( ) ) ; key Manager Factory . init ( key Store ,  SSL_ KEYSTORE_ SECRET ) ;  Key Manager [ ] key Managers = key Manager Factory . get Key Managers ( ) ;  Trust Manager [ ] trust Managers = new  Trust Manager [ ] { create Trust Manager From Default JDKTrust Store ( ) } ; ssl Context =  SSLContext . get Instance ( _ STR ) ; ssl Context . init ( key Managers , trust Managers , null ) ;  SSLContext . set Default ( ssl Context ) ; } catch (  General Security Exception |  IOException e ) { throw new  Key Store Exception ( _ STR , e ) ; } return ssl Context . get Socket Factory ( ) ; }
public  List Data Event (  Object source , int type , int index0 , int index1 ) { super ( source ) ; this . type = type ; this . index0 =  Math . min ( index0 , index1 ) ; this . index1 =  Math . max ( index0 , index1 ) ; }
public  Category (  Wikipedia wiki ,  String p Name ) throws  Wiki Api Exception { if ( p Name == null || p Name . length ( ) == _ NUM ) { throw new  Wiki Page Not Found Exception ( ) ; } this . wiki = wiki ; cat DAO = new  Category DAO ( wiki ) ;  Title cat Title = new  Title ( p Name ) ; create Category ( cat Title ) ; }
private static  String escape JSON (  String text ) {  String Builder builder = new  String Builder ( ) ; builder . append ( _ STR ) ; for ( int index = _ NUM ; index < text . length ( ) ; index ++ ) { char chr = text . char At ( index ) ; switch ( chr ) { case _ STR : case _ STR : builder . append ( _ STR ) ; builder . append ( chr ) ; break ; case _ STR : builder . append ( _ STR ) ; break ; case _ STR : builder . append ( _ STR ) ; break ; case _ STR : builder . append ( _ STR ) ; break ; case _ STR : builder . append ( _ STR ) ; break ; default : if ( chr < _ STR ) {  String t = _ STR +  Integer . to Hex String ( chr ) ; builder . append ( _ STR + t . substring ( t . length ( ) - _ NUM ) ) ; } else { builder . append ( chr ) ; } break ; } } builder . append ( _ STR ) ; return builder . to String ( ) ; }
protected void draw Axis Line (  Graphics2 D g2 , double cursor ,  Rectangle2 D data Area ,  Rectangle Edge edge ) {  Line2 D axis Line = null ; double x = data Area . get X ( ) ; double y = data Area . get Y ( ) ; if ( edge ==  Rectangle Edge .  TOP ) { axis Line = new  Line2 D .  Double ( x , cursor , data Area . get Max X ( ) , cursor ) ; } else if ( edge ==  Rectangle Edge .  BOTTOM ) { axis Line = new  Line2 D .  Double ( x , cursor , data Area . get Max X ( ) , cursor ) ; } else if ( edge ==  Rectangle Edge .  LEFT ) { axis Line = new  Line2 D .  Double ( cursor , y , cursor , data Area . get Max Y ( ) ) ; } else if ( edge ==  Rectangle Edge .  RIGHT ) { axis Line = new  Line2 D .  Double ( cursor , y , cursor , data Area . get Max Y ( ) ) ; } g2 . set Paint ( this . axis Line Paint ) ; g2 . set Stroke ( this . axis Line Stroke ) ;  Object saved = g2 . get Rendering Hint (  Rendering Hints .  KEY_ STROKE_ CONTROL ) ; g2 . set Rendering Hint (  Rendering Hints .  KEY_ STROKE_ CONTROL ,  Rendering Hints .  VALUE_ STROKE_ NORMALIZE ) ; g2 . draw ( axis Line ) ; g2 . set Rendering Hint (  Rendering Hints .  KEY_ STROKE_ CONTROL , saved ) ; }
public static void save KOML (  File save To ,  Object model ,  Instances header ) throws  Exception {  Vector <  Object > v = new  Vector <  Object > ( ) ; v . add ( model ) ; if ( header != null ) { v . add ( header ) ; } v . trim To Size ( ) ;  KOML . write ( save To . get Absolute Path ( ) , v ) ; }
protected static  Span find Root Or Server Span (  String tenant Id ,  Span span ,  Span Cache span Cache ) { while ( span != null && ! span . server Span ( ) && ! span . top Level Span ( ) ) { span = span Cache . get ( tenant Id , span . get Parent Id ( ) ) ; } return span ; }
public int split By Distance (  Array Modifiable DBIDs ind , int begin , int end ,  Double Data Store tpro ,  Random rand ) {  DBIDArray Iter it = ind . iter ( ) ; double rmin =  Double .  MAX_ VALUE * _ NUM , rmax = -  Double .  MAX_ VALUE * _ NUM ; int min Ind = begin , max Ind = end - _ NUM ; for ( it . seek ( begin ) ; it . get Offset ( ) < end ; it . advance ( ) ) { double curr Ele = tpro . double Value ( it ) ; rmin =  Math . min ( curr Ele , rmin ) ; rmax =  Math . max ( curr Ele , rmax ) ; } if ( rmin != rmax ) { double rs = rmin + rand . next Double ( ) * ( rmax - rmin ) ; while ( min Ind < max Ind ) { double curr Ele = tpro . double Value ( it . seek ( min Ind ) ) ; if ( curr Ele > rs ) { while ( min Ind < max Ind && tpro . double Value ( it . seek ( max Ind ) ) > rs ) { max Ind -- ; } if ( min Ind == max Ind ) { break ; } ind . swap ( min Ind , max Ind ) ; max Ind -- ; } min Ind ++ ; } } else { min Ind = ( begin + end ) > > > _ NUM ; } return min Ind ; }
public static  String no Prefix (  String path ,  String prefix ) { return path . starts With ( prefix ) ? path . substring ( prefix . length ( ) ) : path ; }
protected void subscribe ( ) throws  IOException { if ( sample Client Sub == null ) { try { sample Client Sub = new  Sample Async Wait ( url , client Id Sub , clean Session , quiet Mode , user Name , password ) ; } catch (  Mqtt Exception e ) { e . print Stack Trace ( ) ; } } if ( sample Client Sub != null ) {  String topic = _ STR ; int qos = _ NUM ; try { sample Client Sub . subscribe ( topic , qos ) ; } catch (  Throwable e ) { e . print Stack Trace ( ) ; } } }
public  Adaptable List add (  IAdaptable a ) { children . add ( a ) ; return this ; }
public static  Double Stream concat (  Double Stream a ,  Double Stream b ) {  Objects . require Non Null ( a ) ;  Objects . require Non Null ( b ) ;  Spliterator .  Of Double split = new  Streams .  Concat Spliterator .  Of Double ( a . spliterator ( ) , b . spliterator ( ) ) ;  Double Stream stream =  Stream Support . double Stream ( split , a . is Parallel ( ) || b . is Parallel ( ) ) ; return stream . on Close (  Streams . composed Close ( a , b ) ) ; }
public final void populate Properties (  Internal Session old Session ,  Internal Session new Session , boolean force Auth ) {  Enumeration <  String > all Properties = old Session . get Property Names ( ) ; while ( all Properties . has More Elements ( ) ) {  String key = all Properties . next Element ( ) ;  String value = (  String ) old Session . get Property ( key ) ; if ( should Copy ( key ) ) { if ( ! force Auth ) { update Property ( new Session , key , value ) ; } else { update Property ( old Session , key , value ) ; } } } }
@  Method Desc ( description = _ STR , usage = _ STR ) public  Map <  String ,  String > replicator Status ( @  Param Desc ( name = _ STR , description = _ STR )  String name ) throws  Exception {  Open Replicator Manager MBean mgr = replicators . get ( name ) ; if ( mgr == null ) { throw new  Exception (  String . format ( _ STR , name ) ) ; } return mgr . status ( ) ; }
public boolean write Characteristic (  String address ,  String service UUID ,  String characteristic UUID ,  String value ) {  Bluetooth Gatt bluetooth Gatt = m Bluetooth Gatt Map . get ( address ) ; if ( bluetooth Gatt != null ) {  Bluetooth Gatt Service service = bluetooth Gatt . get Service (  UUID . from String ( service UUID ) ) ;  Bluetooth Gatt Characteristic characteristic = service . get Characteristic (  UUID . from String ( characteristic UUID ) ) ; characteristic . set Value ( value ) ; return bluetooth Gatt . write Characteristic ( characteristic ) ; } return _ BOOL ; }
public static  IStatus validate Simple Module Name (  String simple Name ) {  String compliance Level =  Java Core . get Option ( _ STR ) ;  String source Level =  Java Core . get Option ( _ STR ) ; if ( simple Name . index Of ( _ STR ) != - _ NUM ) { return  Util . new Error Status ( _ STR ) ; }  IStatus name Status =  Java Conventions . validate Java Type Name ( simple Name , compliance Level , source Level ) ; if ( name Status . matches (  IStatus .  ERROR ) ) { return  Util . new Error Status ( _ STR ) ; } return  Status .  OK_ STATUS ; }
private static  List <  String > extract Text Items ( ) {  List <  String > ret List = new  Array List <  String > ( ) ;  SFile Chooser chooser = new  SFile Chooser ( get Dictionary Directory ( ) , _ STR , _ STR ) ; chooser . add Extension ( _ STR ) ;  File the File = chooser . show Open Dialog ( ) ; if ( the File != null ) {  Scanner scanner ; try { scanner = new  Scanner ( new  File Reader ( the File ) ) ; try { while ( scanner . has Next Line ( ) ) {  Scanner line Scan = new  Scanner ( scanner . next Line ( ) ) ; while ( line Scan . has Next ( ) ) {  String word = line Scan . next ( ) ; ret List . add ( word ) ; } } } finally { scanner . close ( ) ; set Dictionary Directory ( chooser . get Current Location ( ) ) ; } } catch (  File Not Found Exception e ) { e . print Stack Trace ( ) ; } } return ret List ; }
public void add (  Json Element element ) { if ( element == null ) { element =  Json Null .  INSTANCE ; } elements . add ( element ) ; }
public  TSink <  String > send String (  TStream <  String > stream ) {  Objects . require Non Null ( stream , _ STR ) ; return send Text ( stream , null ) ; }
public void add (  Carbon Level level ,  Carbon Query .  Sort Type sort Type ,  List <  Carbon Measure Filter > msr Filters ,  Carbon Dimension Level Filter dim Level Filter ) {  Carbon Level Holder holder = new  Carbon Level Holder ( level , sort Type ) ; holder . set Msr Filters ( msr Filters ) ; holder . set Dim Level Filter ( dim Level Filter ) ; dims . add ( holder ) ; }
public boolean is Authn Context Matching (  List requested ACClass Refs ,  String ac Class Ref ,  String comparison ,  String realm ,  String host Entity ID ) {  Map auth Ref Map = get Auth Ref Map ( realm , host Entity ID ) ; return  SAML2 Utils . is Authn Context Matching ( requested ACClass Refs , ac Class Ref , comparison , auth Ref Map ) ; }
private  List <  Integer > compute Condition Indexes Not Covered Two Ways ( final  Test Chromosome test , final  Path Condition collected Path Condition ) {  List <  Integer > condition Indexes Not Covered Two Ways = new  Linked List <  Integer > ( ) ; for ( int condition Index = _ NUM ; condition Index < collected Path Condition . size ( ) ; condition Index ++ ) {  Branch Condition b = collected Path Condition . get ( condition Index ) ; if ( ! is Covered Two Ways ( test , b . get Branch Index ( ) ) ) { condition Indexes Not Covered Two Ways . add ( condition Index ) ; } } return condition Indexes Not Covered Two Ways ; }
public void test_journal_one Index Random Data ( ) throws  IOException ,  Interrupted Exception ,  Execution Exception { final  File out =  File . create Temp File ( get Name ( ) ,  Options .  JNL ) ; try { final  Journal src = get Store ( get Properties ( ) ) ; try { final  String  NAME = _ STR ; src . register Index ( new  Index Metadata (  NAME ,  UUID . random UUID ( ) ) ) ; {  BTree ndx = src . get Index (  NAME ) ;  KV [ ] a =  Abstract BTree Test Case . get Random Key Values ( _ NUM ) ; for (  KV kv : a ) { ndx . insert ( kv . key , kv . val ) ; } } src . commit ( ) ;  Future <  Journal > f = src . compact ( out ) ;  Journal new Journal = f . get ( ) ; try { assert Not Null ( new Journal . get Index (  NAME ) ) ;  Abstract BTree Test Case . assert Same BTree ( src . get Index (  NAME ) , new Journal . get Index (  NAME ) ) ; } finally { new Journal . destroy ( ) ; } } finally { src . destroy ( ) ; } } finally { out . delete ( ) ; } }
public static void wrap Thread Loader (  Class Loader ldr ,  Runnable c ) {  Thread cur Thread =  Thread . current Thread ( ) ;  Class Loader ctx Ldr = cur Thread . get Context Class Loader ( ) ; try { cur Thread . set Context Class Loader ( ldr ) ; c . run ( ) ; } finally { cur Thread . set Context Class Loader ( ctx Ldr ) ; } }
protected boolean match Word ( ) {  IDocument doc = f Text . get Document ( ) ; try { int pos = cur Pos ; char c ; while ( pos >= _ NUM ) { c = doc . get Char ( pos ) ; if ( !  Character . is Java Identifier Part ( c ) ) break ; -- pos ; } start Pos = pos ; pos = cur Pos ; int length = doc . get Length ( ) ; while ( pos < length ) { c = doc . get Char ( pos ) ; if ( !  Character . is Java Identifier Part ( c ) ) break ; ++ pos ; } end Pos = pos ; return _ BOOL ; } catch (  Bad Location Exception x ) { log . debug ( x ) ; } return _ BOOL ; }
public void reset ( ) { m Recordable = m Source Recordable ; set Identifier ( m Source ) ; m Priority =  Priority .  DEFAULT_ PRIORITY ;  List <  Metadata Type > to Remove = new  Array List < > ( ) ; for (  Metadata Type type : m Metadata . key Set ( ) ) {  Metadata metadata = m Metadata . get ( type ) ; if ( metadata != null ) { if ( metadata . is Temporal ( ) ) { to Remove . add ( type ) ; } else { process Metadata ( metadata ) ; } } } for (  Metadata Type type : to Remove ) { m Metadata . remove ( type ) ; } m Updated = _ BOOL ; }
public static byte [ ] bitmap To Byte (  Bitmap b ) { if ( b == null ) { return null ; }  Byte Array Output Stream o = new  Byte Array Output Stream ( ) ; b . compress (  Bitmap .  Compress Format .  PNG , _ NUM , o ) ; return o . to Byte Array ( ) ; }
private  View make Controller View ( ) {  Layout Inflater inflate = (  Layout Inflater ) m Context . get System Service (  Context .  LAYOUT_ INFLATER_ SERVICE ) ; m Root View = inflate . inflate (  R . layout . media_controller , null ) ; init Controller View ( ) ; return m Root View ; }
public void add Handler (  Warning Handler handler ) { _handlers . add ( handler ) ; }
private static void conditional Copy ( final  List <  NV > anns , final  Properties query Hints , final  String name ) { if ( query Hints == null ) return ; final  Object val = query Hints . get Property ( name ) ; if ( val != null ) { anns . add ( new  NV ( name , val ) ) ; } }
final private  String match Rule Def2 Match Rule Desc (  Attributes attrs ) throws  Naming Exception {  String Buffer match Rule Desc = new  String Buffer ( _ STR ) ;  Attribute attr = null ; int count = _ NUM ; attr = attrs . get (  NUMERICOID_ ID ) ; if ( attr != null ) { match Rule Desc . append ( write Numeric OID ( attr ) ) ; count ++ ; } else { throw new  Configuration Exception ( _ STR + _ STR ) ; } attr = attrs . get (  NAME_ ID ) ; if ( attr != null ) { match Rule Desc . append ( write QDescrs ( attr ) ) ; count ++ ; } attr = attrs . get (  DESC_ ID ) ; if ( attr != null ) { match Rule Desc . append ( write QDString ( attr ) ) ; count ++ ; } attr = attrs . get (  OBSOLETE_ ID ) ; if ( attr != null ) { match Rule Desc . append ( write Boolean ( attr ) ) ; count ++ ; } attr = attrs . get (  SYNTAX_ ID ) ; if ( attr != null ) { match Rule Desc . append ( write WOID ( attr ) ) ; count ++ ; } else { throw new  Configuration Exception ( _ STR + _ STR ) ; } if ( count < attrs . size ( ) ) {  String attr Id = null ; for (  Naming Enumeration < ? extends  Attribute > ae = attrs . get All ( ) ; ae . has More Elements ( ) ; ) { attr = ae . next ( ) ; attr Id = attr . get ID ( ) ; if ( attr Id . equals (  NUMERICOID_ ID ) || attr Id . equals (  NAME_ ID ) || attr Id . equals (  SYNTAX_ ID ) || attr Id . equals (  DESC_ ID ) || attr Id . equals (  OBSOLETE_ ID ) ) { continue ; } else { match Rule Desc . append ( write QDStrings ( attr ) ) ; } } } match Rule Desc . append ( _ STR ) ; return match Rule Desc . to String ( ) ; }
@  Override public void write ( byte [ ] buf , int offset , int length , boolean is End ) throws  IOException { if ( _s == null ) { return ; } try { _needs Flush = _ BOOL ; while ( length > _ NUM ) { _write Buffer . clear ( ) ; int sublen =  Math . min ( length , _write Buffer . remaining ( ) ) ; _write Buffer . put ( buf , offset , sublen ) ; _write Buffer . flip ( ) ; _s . write ( _write Buffer ) ; length -= sublen ; offset += sublen ; } _total Write Bytes += length ; } catch (  IOException e ) {  IOException exn =  Client Disconnect Exception . create ( this + _ STR + e , e ) ; try { close ( ) ; } catch (  IOException e1 ) { } throw exn ; } }
@  Suppress Warnings ( _ STR ) public static  Object parse Member Value (  Class < ? > member Type ,  Byte Buffer buf ,  Constant Pool const Pool ,  Class < ? > container ) {  Object result = null ; int tag = buf . get ( ) ; switch ( tag ) { case _ STR : return parse Enum Value ( (  Class < ? extends  Enum < ? > > ) member Type , buf , const Pool , container ) ; case _ STR : result = parse Class Value ( buf , const Pool , container ) ; break ; case _ STR : result = parse Annotation ( buf , const Pool , container , _ BOOL ) ; break ; case _ STR : return parse Array ( member Type , buf , const Pool , container ) ; default : result = parse Const ( tag , buf , const Pool ) ; } if ( ! ( result instanceof  Exception Proxy ) && ! member Type . is Instance ( result ) ) result = new  Annotation Type Mismatch Exception Proxy ( result . get Class ( ) + _ STR + result + _ STR ) ; return result ; }
protected static void compute Cartesian (  List <  Event Bean [ ] > stream One , int [ ] sub Stream Nums One ,  List <  Event Bean [ ] > stream Two , int [ ] sub Stream Nums Two ,  List <  Event Bean [ ] > result List ) { if ( ( stream Two == null ) || ( stream Two . is Empty ( ) ) ) { if ( ( stream One == null ) || ( stream One . is Empty ( ) ) ) { return ; } result List . add All ( stream One ) ; return ; } if ( ( stream One == null ) || ( stream One . is Empty ( ) ) ) { result List . add All ( stream Two ) ; return ; } int stream One Size = stream One . size ( ) ; int stream Two Size = stream Two . size ( ) ; if ( stream One Size == _ NUM ) { copy To Each ( sub Stream Nums One , stream One . get ( _ NUM ) , stream Two ) ; result List . add All ( stream Two ) ; return ; } if ( stream Two Size == _ NUM ) { copy To Each ( sub Stream Nums Two , stream Two . get ( _ NUM ) , stream One ) ; result List . add All ( stream One ) ; return ; } if ( stream Two Size > stream One Size ) {  List <  Event Bean [ ] > hold Rows = stream One ; int hold Size = stream One Size ; stream One = stream Two ; stream One Size = stream Two Size ; stream Two = hold Rows ; stream Two Size = hold Size ; sub Stream Nums Two = sub Stream Nums One ; } int cartesian Total Rows = stream One Size * stream Two Size ; int num Columns = stream One . get ( _ NUM ) . length ;  Event Bean [ ] [ ] results = new  Event Bean [ cartesian Total Rows ] [ ] ; int stream One Count = _ NUM ; for (  Event Bean [ ] row : stream One ) { results [ stream One Count ] = row ; for ( int i = _ NUM ; i < stream Two Size ; i ++ ) {  Event Bean [ ] dup Row = new  Event Bean [ num Columns ] ;  System . arraycopy ( row , _ NUM , dup Row , _ NUM , num Columns ) ; int index = stream One Size * i + stream One Count ; results [ index ] = dup Row ; } stream One Count ++ ; } int stream Two Count = _ NUM ; for (  Event Bean [ ] row : stream Two ) { for ( int i = _ NUM ; i < stream One Size ; i ++ ) { int index = stream Two Count * stream One Size + i ; copy ( sub Stream Nums Two , row , results [ index ] ) ; } stream Two Count ++ ; } result List . add All (  Arrays . as List ( results ) ) ; }
public  Date Time to Date Time (  Config config ,  Element el ,  String attribute Name ) {  String str = el . get Attribute ( attribute Name ) ; if ( str == null ) return null ; return  Date Caster . to Date Advanced ( str ,  Thread Local Page Context . get Time Zone ( config ) , null ) ; }
private int adjust Column ( int row , int col ) { if ( col < _ NUM ) { return _ NUM ; } if ( row == get Row Count ( ) - _ NUM ) { int last Row Count = model . get Byte Count ( ) % _ NUM ; if ( last Row Count == _ NUM ) { last Row Count = _ NUM ; } if ( last Row Count < _ NUM ) { return  Math . min ( col , ( model . get Byte Count ( ) % _ NUM ) - _ NUM ) ; } } return  Math . min ( col , get Column Count ( ) - _ NUM - _ NUM ) ; }
public static  String [ ] ls Files Recursive (  String directory ,  Filename Filter filter ) throws  IOException {  File dir = new  File ( directory ) ;  Array List <  String > files = new  Array List < > ( ) ; for (  File filepath : dir . list Files ( filter ) ) { if ( is File ( filepath . get Absolute Path ( ) ) ) files . add ( filepath . get Absolute Path ( ) ) ; else if ( is Directory ( filepath . get Absolute Path ( ) ) ) files . add All (  Arrays . as List ( ls Files Recursive ( filepath . get Absolute Path ( ) , filter ) ) ) ; } return files . to Array ( new  String [ files . size ( ) ] ) ; }
public  String generate Create (  String table ) throws  Database Exception {  String Buffer result = new  String Buffer ( ) ; try {  String Buffer sql = new  String Buffer ( ) ; sql . append ( _ STR ) ; sql . append ( table ) ;  Result Set rs = execute Query ( sql . to String ( ) ) ;  Result Set Meta Data md = rs . get Meta Data ( ) ; result . append ( _ STR ) ; result . append ( table ) ; result . append ( _ STR ) ; for ( int i = _ NUM ; i <= md . get Column Count ( ) ; i ++ ) { if ( i != _ NUM ) { result . append ( _ STR ) ; } result . append ( md . get Column Name ( i ) ) ; result . append ( _ STR ) ;  String type = process Type ( md . get Column Type Name ( i ) , md . get Precision ( i ) ) ; result . append ( type ) ; } result . append ( _ STR ) ; rs . close ( ) ; } catch (  SQLException e ) { throw ( new  Database Exception ( e ) ) ; } return result . to String ( ) ; }
public void process Event (  Monitor mon ) {  Iterator iter = listener List . iterator ( ) ; while ( iter . has Next ( ) ) {  JAMon Listener listener = (  JAMon Listener ) iter . next ( ) ; listener . process Event ( mon ) ; } }
private void refresh Index For Dimension Key (  String row Id ) { try {  String all Values Key =  Dimension Store Key Utils . get All Values Key ( ) ;  String dimension Rows = key Value Store . get ( all Values Key ) ;  Set <  String > dimension Rows Set = new  Linked Hash Set < > ( ) ; if ( dimension Rows != null ) { dimension Rows Set . add All (  Arrays . as List ( object Mapper . read Value ( dimension Rows ,  String [ ] . class ) ) ) ; } dimension Rows Set . add ( row Id ) ;  String dim Rows = object Mapper . write Value As String ( dimension Rows Set ) ; key Value Store . put ( all Values Key , dim Rows ) ; } catch (  IOException e ) {  LOG . error ( _ STR , e ) ; throw new  Runtime Exception ( e ) ; } }
public  Element simulate ( final  List <  Instruction > instructions ) { lock . lock ( ) ; try { return Element = null ; return simulate Internal ( instructions ) ; } finally { lock . unlock ( ) ; } }
public static boolean nodes Equal (  Node this Node ,  Node other Node ) { if ( this Node == other Node ) { return _ BOOL ; } if ( this Node . get Node Type ( ) != other Node . get Node Type ( ) ) { return _ BOOL ; } return _ BOOL ; }
public void test Case15 ( ) { byte a Bytes [ ] = { _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM } ; byte b Bytes [ ] = { _ NUM } ; int a Sign = _ NUM ; int b Sign = _ NUM ;  Big Integer a Number = new  Big Integer ( a Sign , a Bytes ) ;  Big Integer b Number = new  Big Integer ( b Sign , b Bytes ) ; try { a Number . remainder ( b Number ) ; fail ( _ STR ) ; } catch (  Arithmetic Exception e ) { } }
public int add Point (  Grab Point gp , int position ) { if ( gp == null ) { return - _ NUM ; } int x = gp . get X ( ) ; int y = gp . get Y ( ) ; int render Type = poly . get Render Type ( ) ;  Projection proj = get Projection ( ) ; if ( render Type ==  OMGraphic .  RENDERTYPE_ LATLON ) {  Debug . message ( _ STR , _ STR ) ; if ( proj != null ) { double [ ] ll = poly . get Lat Lon Array ( ) ; int actual Position = ( position ==  Integer .  MAX_ VALUE ? ll . length : position * _ NUM ) ;  Lat Lon Point llpnt = proj . inverse ( x , y , new  Lat Lon Point .  Double ( ) ) ; if (  Debug . debugging ( _ STR ) ) {  Debug . output ( _ STR + x + _ STR + y + _ STR + llpnt + _ STR ) ; for ( int j = _ NUM ; j < ll . length ; j += _ NUM ) {  Debug . output ( ll [ j ] + _ STR + ll [ j + _ NUM ] ) ; } } double [ ] newll = new double [ ll . length + _ NUM ] ; double newlat = llpnt . get Rad Lat ( ) ; double newlon = llpnt . get Rad Lon ( ) ; if ( actual Position >= ll . length ) { if ( ll . length != _ NUM ) {  System . arraycopy ( ll , _ NUM , newll , _ NUM , ll . length ) ; } newll [ ll . length ] = newlat ; newll [ ll . length + _ NUM ] = newlon ; position = ll . length / _ NUM ; } else if ( actual Position <= _ NUM ) {  System . arraycopy ( ll , _ NUM , newll , _ NUM , ll . length ) ; newll [ _ NUM ] = newlat ; newll [ _ NUM ] = newlon ; position = _ NUM ; } else { newll [ actual Position ] = newlat ; newll [ actual Position + _ NUM ] = newlon ;  System . arraycopy ( ll , _ NUM , newll , _ NUM , actual Position ) ;  System . arraycopy ( ll , actual Position , newll , actual Position + _ NUM , ll . length - actual Position ) ; } poly . set Location ( newll ,  OMGraphic .  RADIANS ) ; } } else if ( render Type ==  OMGraphic .  RENDERTYPE_ XY ) {  Debug . message ( _ STR , _ STR ) ; int current Length = poly . xs . length ; int [ ] newxs = new int [ current Length + _ NUM ] ; int [ ] newys = new int [ current Length + _ NUM ] ; if ( position >= current Length ) {  System . arraycopy ( poly . xs , _ NUM , newxs , _ NUM , current Length ) ;  System . arraycopy ( poly . ys , _ NUM , newys , _ NUM , current Length ) ; newxs [ current Length ] = x ; newys [ current Length ] = y ; position = current Length ; } else if ( position <= _ NUM ) {  System . arraycopy ( poly . xs , _ NUM , newxs , _ NUM , current Length ) ;  System . arraycopy ( poly . ys , _ NUM , newys , _ NUM , current Length ) ; newxs [ _ NUM ] = x ; newys [ _ NUM ] = y ; position = _ NUM ; } else { newxs [ position ] = x ; newys [ position ] = y ;  System . arraycopy ( poly . xs , _ NUM , newxs , _ NUM , position ) ;  System . arraycopy ( poly . xs , position , newxs , position + _ NUM , current Length - position ) ;  System . arraycopy ( poly . ys , _ NUM , newys , _ NUM , position ) ;  System . arraycopy ( poly . ys , position , newys , position + _ NUM , current Length - position ) ; } poly . set Location ( newxs , newys ) ; } else {  Debug . message ( _ STR , _ STR ) ; int current Length = poly . xs . length ; int [ ] newxs = new int [ current Length + _ NUM ] ; int [ ] newys = new int [ current Length + _ NUM ] ; if ( position >= current Length ) { position = current Length ;  System . arraycopy ( poly . xs , _ NUM , newxs , _ NUM , current Length ) ;  System . arraycopy ( poly . ys , _ NUM , newys , _ NUM , current Length ) ; } else if ( position <= _ NUM ) { position = _ NUM ;  System . arraycopy ( poly . xs , _ NUM , newxs , _ NUM , current Length ) ;  System . arraycopy ( poly . ys , _ NUM , newys , _ NUM , current Length ) ; } else {  System . arraycopy ( poly . xs , _ NUM , newxs , _ NUM , position ) ;  System . arraycopy ( poly . xs , position , newxs , position + _ NUM , current Length - position ) ;  System . arraycopy ( poly . ys , _ NUM , newys , _ NUM , position ) ;  System . arraycopy ( poly . ys , position , newys , position + _ NUM , current Length - position ) ; } int offset X ; int offset Y ; if ( gpo . get X ( ) == - _ NUM && gpo . get Y ( ) == - _ NUM ) { offset X = proj . get Width ( ) / _ NUM ; offset Y = proj . get Height ( ) / _ NUM ; } else { offset X = gpo . get X ( ) ; offset Y = gpo . get Y ( ) ; } if ( poly . coord Mode ==  OMPoly .  COORDMODE_ ORIGIN || position == _ NUM ) { newxs [ position ] = x - offset X ; newys [ position ] = y - offset Y ; } else { newxs [ position ] = x - offset X - newxs [ position - _ NUM ] ; newys [ position ] = y - offset Y - newys [ position - _ NUM ] ; } if ( position == _ NUM ) {  Lat Lon Point llpnt = proj . inverse ( offset X , offset Y , new  Lat Lon Point .  Double ( ) ) ; poly . lat = llpnt . get Rad Lat ( ) ; poly . lon = llpnt . get Rad Lon ( ) ; } poly . set Location ( poly . lat , poly . lon ,  OMGraphic .  RADIANS , newxs , newys ) ; }  OMArrow Head omah = poly . get Arrow Head ( ) ; poly . set Arrow Head ( null ) ; poly . set Arrow Head ( omah ) ; poly Grab Points . add ( position , gp ) ; if ( gpo != null ) { gpo . add Grab Point ( gp ) ; } poly . regenerate ( proj ) ; gp . generate ( proj ) ; return position ; }
public  Text Editor replace All (  Pattern pattern ,  Replacement replacement ) {  Matcher m = pattern . matcher ( text ) ; int last Index = _ NUM ;  String Buffer sb = new  String Buffer ( ) ; while ( m . find ( ) ) { sb . append ( text . sub Sequence ( last Index , m . start ( ) ) ) ; sb . append ( replacement . replacement ( m ) ) ; last Index = m . end ( ) ; } sb . append ( text . sub Sequence ( last Index , text . length ( ) ) ) ; text = sb ; return this ; }
public static double cdf ( double val , double rate ) { final double v = _ NUM *  Math . exp ( - rate * val ) ; return ( val < _ NUM ) ? v : _ NUM - v ; }
public static  Data Set read Discrete (  File file , char delimiter ) throws  IOException { return read In Discrete Data ( file , delimiter ,  Collections . singleton ( _ STR ) ) ; }
public static  String r Frame Rate To Edit Rate (  String r Frame Rate ) {  String [ ] parts = r Frame Rate . split ( _ STR ) ; if ( parts . length == _ NUM ) { return  String . format ( _ STR , parts [ _ NUM ] , parts [ _ NUM ] ) ; } return  String . format ( _ STR , r Frame Rate , _ NUM ) ; }
protected boolean can Paths Be Removed (  Tree Path [ ] paths ) { if ( row Mapper == null || selection == null || selection Mode ==  Tree Selection Model .  DISCONTIGUOUS_ TREE_ SELECTION ) return _ BOOL ; else {  Bit Set bit Set = new  Bit Set ( ) ; int counter ; int path Count = paths . length ; int an Index ; int min = - _ NUM ; int valid Count = _ NUM ;  Tree Path [ ] temp Path = new  Tree Path [ _ NUM ] ; int [ ] rows ; last Paths . clear ( ) ; for ( counter = _ NUM ; counter < path Count ; counter ++ ) { if ( paths [ counter ] != null ) { last Paths . put ( paths [ counter ] ,  Boolean .  TRUE ) ; } } for ( counter = selection . length - _ NUM ; counter >= _ NUM ; counter -- ) { if ( last Paths . get ( selection [ counter ] ) == null ) { temp Path [ _ NUM ] = selection [ counter ] ; rows = row Mapper . get Rows For Paths ( temp Path ) ; if ( rows != null && rows [ _ NUM ] != - _ NUM && ! bit Set . get ( rows [ _ NUM ] ) ) { valid Count ++ ; if ( min == - _ NUM ) min = rows [ _ NUM ] ; else min =  Math . min ( min , rows [ _ NUM ] ) ; bit Set . set ( rows [ _ NUM ] ) ; } } } last Paths . clear ( ) ; if ( valid Count > _ NUM ) { for ( counter = min + valid Count - _ NUM ; counter >= min ; counter -- ) if ( ! bit Set . get ( counter ) ) return _ BOOL ; } } return _ BOOL ; }
public  Simple String Reader (  String s ) { this . str = s ; this . length = s . length ( ) ; }
private void update Search Style (  JText Component c ,  Sea Glass Context context ,  String prefix ) { search Icon Width = _ NUM ;  Object o = style . get ( context , prefix + _ STR ) ; if ( o != null && o instanceof  Integer ) { search Icon Width = (  Integer ) o ; } popup Icon Width = _ NUM ; o = style . get ( context , prefix + _ STR ) ; if ( o != null && o instanceof  Integer ) { popup Icon Width = (  Integer ) o ; } cancel Icon Width = _ NUM ; o = style . get ( context , prefix + _ STR ) ; if ( o != null && o instanceof  Integer ) { cancel Icon Width = (  Integer ) o ; } search Left Inner Margin = _ NUM ; o = style . get ( context , prefix + _ STR ) ; if ( o != null && o instanceof  Integer ) { search Left Inner Margin = (  Integer ) o ; } search Right Inner Margin = _ NUM ; o = style . get ( context , prefix + _ STR ) ; if ( o != null && o instanceof  Integer ) { search Right Inner Margin = (  Integer ) o ; } placeholder Color =  Color .  GRAY ; o = style . get ( context , _ STR ) ; if ( o != null && o instanceof  Color ) { placeholder Color = (  Color ) o ; }  Border border = c . get Border ( ) ; if ( border == null || border instanceof  UIResource && ! ( border instanceof  Text Field Border ) ) { c . set Border ( create Text Field Border ( context ) ) ; } if ( is Search Field . is In State ( c ) ) { o = c . get Client Property ( _ STR ) ; if ( o != null && o instanceof  String ) { placeholder Text = (  String ) o ; } else if ( placeholder Text != null ) { placeholder Text = null ; } o = c . get Client Property ( _ STR ) ; if ( o != null && o instanceof  Action Listener ) { if ( find Action == null ) { find Action = (  Action Listener ) o ; } } o = c . get Client Property ( _ STR ) ; if ( o != null && o instanceof  JPopup Menu ) { if ( find Popup == null ) { find Popup = (  JPopup Menu ) o ; } } o = c . get Client Property ( _ STR ) ; if ( o != null && o instanceof  Action Listener ) { if ( cancel Action == null ) { cancel Action = (  Action Listener ) o ; } } install Mouse Listeners ( ) ; } else { placeholder Text = null ; if ( find Action != null ) { find Action = null ; } if ( find Popup != null ) { find Popup = null ; } if ( cancel Action != null ) { cancel Action = null ; } uninstall Mouse Listeners ( ) ; } }
@  Override protected void on Layout ( boolean changed , int l , int t , int r , int b ) { m Lines . clear ( ) ; m Line Heights . clear ( ) ; m Line Margins . clear ( ) ; int width = get Width ( ) ; int height = get Height ( ) ; int lines Sum = get Padding Top ( ) ; int line Width = _ NUM ; int line Height = _ NUM ;  List <  View > line Views = new  Array List <  View > ( ) ; float horizontal Gravity Factor ; switch ( ( m Gravity &  Gravity .  HORIZONTAL_ GRAVITY_ MASK ) ) { case  Gravity .  LEFT : default : horizontal Gravity Factor = _ NUM ; break ; case  Gravity .  CENTER_ HORIZONTAL : horizontal Gravity Factor = _ NUM ; break ; case  Gravity .  RIGHT : horizontal Gravity Factor = _ NUM ; break ; } for ( int i = _ NUM ; i < get Child Count ( ) ; i ++ ) {  View Group child = (  View Group ) get Child At ( i ) ; if ( child . get Visibility ( ) ==  View .  GONE ) { continue ; }  Layout Params lp = (  Layout Params ) child . get Layout Params ( ) ; int child Width = child . get Measured Width ( ) + lp . left Margin + lp . right Margin ; int child Height = child . get Measured Height ( ) + lp . bottom Margin + lp . top Margin ; if ( line Width + child Width > width ) { m Line Heights . add ( line Height ) ; m Lines . add ( line Views ) ; m Line Margins . add ( ( int ) ( ( width - line Width ) * horizontal Gravity Factor ) + get Padding Left ( ) ) ; lines Sum += line Height ; line Height = _ NUM ; line Width = _ NUM ; line Views = new  Array List < > ( ) ; } line Width += child Width ; line Height =  Math . max ( line Height , child Height ) ; line Views . add ( child ) ; } m Line Heights . add ( line Height ) ; m Lines . add ( line Views ) ; m Line Margins . add ( ( int ) ( ( width - line Width ) * horizontal Gravity Factor ) + get Padding Left ( ) ) ; lines Sum += line Height ; int vertical Gravity Margin = _ NUM ; switch ( ( m Gravity &  Gravity .  VERTICAL_ GRAVITY_ MASK ) ) { case  Gravity .  TOP : default : break ; case  Gravity .  CENTER_ VERTICAL : vertical Gravity Margin = ( height - lines Sum ) / _ NUM ; break ; case  Gravity .  BOTTOM : vertical Gravity Margin = height - lines Sum ; break ; } int num Lines = m Lines . size ( ) ; int left ; int top = get Padding Top ( ) ; for ( int i = _ NUM ; i < num Lines ; i ++ ) { line Height = m Line Heights . get ( i ) ; line Views = m Lines . get ( i ) ; left = m Line Margins . get ( i ) ; int children = line Views . size ( ) ; for ( int j = _ NUM ; j < children ; j ++ ) {  View child = line Views . get ( j ) ; if ( child . get Visibility ( ) ==  View .  GONE ) { continue ; }  Layout Params lp = (  Layout Params ) child . get Layout Params ( ) ; if ( lp . height ==  Layout Params .  MATCH_ PARENT ) { int child Width Mode =  Measure Spec .  AT_ MOST ; int child Width Size = line Width ; if ( lp . width ==  Layout Params .  MATCH_ PARENT ) { child Width Mode =  Measure Spec .  EXACTLY ; } else if ( lp . width >= _ NUM ) { child Width Mode =  Measure Spec .  EXACTLY ; child Width Size = lp . width ; } child . measure (  Measure Spec . make Measure Spec ( child Width Size , child Width Mode ) ,  Measure Spec . make Measure Spec ( line Height - lp . top Margin - lp . bottom Margin ,  Measure Spec .  EXACTLY ) ) ; } int child Width = child . get Measured Width ( ) ; int child Height = child . get Measured Height ( ) ; int gravity Margin = _ NUM ; if (  Gravity . is Vertical ( lp . gravity ) ) { switch ( lp . gravity ) { case  Gravity .  TOP : default : break ; case  Gravity .  CENTER_ VERTICAL : case  Gravity .  CENTER : gravity Margin = ( line Height - child Height - lp . top Margin - lp . bottom Margin ) / _ NUM ; break ; case  Gravity .  BOTTOM : gravity Margin = line Height - child Height - lp . top Margin - lp . bottom Margin ; break ; } } child . layout ( left + lp . left Margin , top + lp . top Margin + gravity Margin + vertical Gravity Margin , left + child Width + lp . left Margin , top + child Height + lp . top Margin + gravity Margin + vertical Gravity Margin ) ; left += child Width + lp . left Margin + lp . right Margin ; } top += line Height ; } }
public final void wait ( long timeout ) throws java . lang .  Interrupted Exception { wait ( timeout , _ NUM ) ; }
public  Multi Match Query Builder field (  String field , float boost ) { fields . add ( field ) ; if ( fields Boosts == null ) { fields Boosts = new  Object Float Hash Map < > ( ) ; } fields Boosts . put ( field , boost ) ; return this ; }
protected void init Max Pings ( ) {  String max Pings Param = get Init Parameter ( _ STR ) ; set Max Pings ( ( max Pings Param == null ) ?  DEFAULT_ MAX_ PINGS :  Integer . parse Int ( max Pings Param ) ) ; if ( is Debug ( ) ) { log ( _ STR + get Max Pings ( ) ) ; } }
public void register Sensor (  Sensor s , int i ) { if ( ( i < _ NUM ) || ( i > ( input Bytes [ node Type ] * _ NUM - _ NUM ) ) || ( i >  MAXSENSORS ) ) { log . error ( _ STR +  Integer . to String ( i + _ NUM ) ) ; return ; } has Active Sensors = _ BOOL ; if ( sensor Array [ i ] == null ) { sensor Array [ i ] = s ; if ( last Used Sensor < i ) { last Used Sensor = i ; } } else { log . warn ( _ STR +  Integer . to String ( ( get Node Address ( ) *  Serial Sensor Manager .  SENSORSPERNODE ) + i + _ NUM ) ) ; } }
public static  Object parse Primitive Value (  String value ,  Primitive Type primitive Type ) throws  OData Exception { switch ( primitive Type ) { case  BOOLEAN : return  Boolean . value Of ( value ) ; case  BYTE : try { final  Integer v =  Integer . value Of ( value ) ; if ( v < _ NUM || v >  PARSE_ INDEX ) { throw Parse Exception ( value , primitive Type , null ) ; } return v . byte Value ( ) ; } catch (  Number Format Exception e ) { throw Parse Exception ( value , primitive Type , e ) ; } break ; case  DATE : try { return  Local Date . parse ( value ) ; } catch (  Illegal Argument Exception e ) { throw Parse Exception ( value , primitive Type , e ) ; } break ; case  DATE_ TIME_ OFFSET : try { return  Zoned Date Time . parse ( value ) ; } catch (  Illegal Argument Exception e ) { throw Parse Exception ( value , primitive Type , e ) ; } break ; case  DURATION : try { return  Period . parse ( value ) ; } catch (  Illegal Argument Exception e ) { throw Parse Exception ( value , primitive Type , e ) ; } break ; case  TIME_ OF_ DAY : try { return  Local Time . parse ( value ) ; } catch (  Illegal Argument Exception e ) { throw Parse Exception ( value , primitive Type , e ) ; } break ; case  DECIMAL : try { return new  Big Decimal ( value ) ; } catch (  Number Format Exception e ) { throw Parse Exception ( value , primitive Type , e ) ; } break ; case  DOUBLE : try { return  Double . parse Double ( value ) ; } catch (  Number Format Exception e ) { throw Parse Exception ( value , primitive Type , e ) ; } break ; case  SINGLE : try { return  Float . parse Float ( value ) ; } catch (  Number Format Exception e ) { throw Parse Exception ( value , primitive Type , e ) ; } break ; case  GUID : try { return  UUID . from String ( value ) ; } catch (  Illegal Argument Exception e ) { throw Parse Exception ( value , primitive Type , e ) ; } break ; case  INT16 : try { return  Short . value Of ( value ) ; } catch (  Number Format Exception e ) { throw Parse Exception ( value , primitive Type , e ) ; } break ; case  INT32 : try { return  Integer . value Of ( value ) ; } catch (  Number Format Exception e ) { throw Parse Exception ( value , primitive Type , e ) ; } break ; case  INT64 : try { return  Long . value Of ( value ) ; } catch (  Number Format Exception e ) { throw Parse Exception ( value , primitive Type , e ) ; } break ; case  STRING : return value ; case  SBYTE : try { return  Byte . value Of ( value ) ; } catch (  Number Format Exception e ) { throw Parse Exception ( value , primitive Type , e ) ; } break ; default : throw new  OData Not Implemented Exception ( _ STR + primitive Type + _ STR + value ) ; } return null ; }
public final void sample ( ) { long count = _count . get ( ) ; long last Count = _last Avg Count . get And Set ( count ) ; long time = _time . get ( ) ; long last Time = _last Avg Time . get And Set ( time ) ; if ( count == last Count ) _value = _ NUM ; else _value = _scale * ( time - last Time ) / ( double ) ( count - last Count ) ; }
@  Suppress Warnings ( _ STR ) private boolean is Token Valid For Compression ( byte [ ] blob ) { if ( blob == null ) { return _ BOOL ; }  String contents ; try { contents = blob Utils . to UTF8 ( blob ) ; } catch (  Unsupported Encoding Exception e ) { return _ BOOL ; } if ( ! contents . starts With ( _ STR ) ) { return _ BOOL ; } if ( ! contents . ends With ( _ STR ) ) { return _ BOOL ; }  Set <  String > keys = new  Hash Set <  String > ( ) ; keys . add All ( replacement . key Set ( ) ) ; keys . add All ( replacement . values ( ) ) ; for (  String key : keys ) { if ( contents . contains ( key ) ) { return _ BOOL ; } } return _ BOOL ; }
public static  Encryption Key [ ] acquire Secret Keys (  Principal Name princ ,  String keytab ) { if ( princ == null ) throw new  Illegal Argument Exception ( _ STR ) ;  Key Tab ktab =  Key Tab . get Instance ( keytab ) ; return ktab . read Service Keys ( princ ) ; }
private  String collapse Slashes (  String path ) { int length = path . length ( ) ; if ( length < _ NUM ) return path ; if ( path . index Of ( _ STR , _ NUM ) == - _ NUM ) return path ; char [ ] result = new char [ path . length ( ) ] ; int count = _ NUM ; boolean has Previous = _ BOOL ; char [ ] characters = path . to Char Array ( ) ; for ( int index = _ NUM ; index < characters . length ; index ++ ) { char c = characters [ index ] ; if ( c ==  SEPARATOR ) { if ( has Previous ) { if ( device == null && index == _ NUM ) { result [ count ] = c ; count ++ ; } } else { has Previous = _ BOOL ; result [ count ] = c ; count ++ ; } } else { has Previous = _ BOOL ; result [ count ] = c ; count ++ ; } } return new  String ( result , _ NUM , count ) ; }
public static <  T >  List <  T > [ ] split (  Collection <  T > set , double [ ] weights ) { if ( set . size ( ) >= weights . length ) { @  Suppress Warnings ( _ STR )  List <  T > [ ] arrays = new  List [ weights . length ] ; double totalweight = _ NUM ; for ( double w : weights ) totalweight += w ; double [ ] relative Weight = new double [ weights . length ] ; for ( int i = _ NUM ; i < weights . length ; i ++ ) relative Weight [ i ] = weights [ i ] / totalweight ; int [ ] list Sizes = new int [ weights . length ] ; for ( int i = _ NUM ; i < weights . length ; i ++ ) list Sizes [ i ] = ( int ) ( weights [ i ] / totalweight * ( double ) set . size ( ) ) ; int allocated = _ NUM ; for ( int ls : list Sizes ) allocated += ls ; int remainder = set . size ( ) - allocated ; list Sizes [ _ NUM ] += remainder ;  Iterator <  T > it = set . iterator ( ) ; for ( int i = _ NUM ; i < list Sizes . length ; i ++ ) {  List <  T > segment = new  Array List < > ( list Sizes [ i ] ) ; for ( int k = _ NUM ; k < list Sizes [ i ] ; k ++ ) { segment . add ( it . next ( ) ) ; } arrays [ i ] = segment ; } return arrays ; } else { throw new  Illegal Argument Exception ( _ STR ) ; } }
public  Cache put (  String host ,  Inet Address [ ] addresses ) { int policy = get Policy ( ) ; if ( policy ==  Inet Address Cache Policy .  NEVER ) { return this ; } if ( policy !=  Inet Address Cache Policy .  FOREVER ) {  Linked List <  String > expired = new  Linked List < > ( ) ; long now =  System . current Time Millis ( ) ; for (  String key : cache . key Set ( ) ) {  Cache Entry entry = cache . get ( key ) ; if ( entry . expiration >= _ NUM && entry . expiration < now ) { expired . add ( key ) ; } else { break ; } } for (  String key : expired ) { cache . remove ( key ) ; } } long expiration ; if ( policy ==  Inet Address Cache Policy .  FOREVER ) { expiration = - _ NUM ; } else { expiration =  System . current Time Millis ( ) + ( policy * _ NUM ) ; }  Cache Entry entry = new  Cache Entry ( addresses , expiration ) ; cache . put ( host , entry ) ; return this ; }
private  String collapse Slashes (  String path ) { int length = path . length ( ) ; if ( length < _ NUM ) return path ; if ( path . index Of ( _ STR , _ NUM ) == - _ NUM ) return path ; char [ ] result = new char [ path . length ( ) ] ; int count = _ NUM ; boolean has Previous = _ BOOL ; char [ ] characters = path . to Char Array ( ) ; for ( int index = _ NUM ; index < characters . length ; index ++ ) { char c = characters [ index ] ; if ( c ==  SEPARATOR ) { if ( has Previous ) { if ( device == null && index == _ NUM ) { result [ count ] = c ; count ++ ; } } else { has Previous = _ BOOL ; result [ count ] = c ; count ++ ; } } else { has Previous = _ BOOL ; result [ count ] = c ; count ++ ; } } return new  String ( result , _ NUM , count ) ; }
protected byte [ ] _read Last Chunk ( long index ) throws  IOException ,  Invalid Key Exception ,  Invalid Algorithm Parameter Exception ,  Illegal Block Size Exception ,  Bad Padding Exception ,  File Encryption Exception ,  Short Buffer Exception { long n Remaining = backing Random Access File . length ( ) - ( chunk Offset ( index ) ) ; if ( n Remaining >  CHUNK_ ENC_ SIZE ) { throw new  File Encryption Exception ( _ STR ) ; } else if ( n Remaining <=  CHUNK_ IV_ SIZE ) { return new byte [ ] { } ; } long oldpos = backing Random Access File . get File Pointer ( ) ; backing Random Access File . seek ( chunk Offset ( index ) ) ; byte [ ] iv = new byte [  CHUNK_ IV_ SIZE ] ; int ret = backing Random Access File . read ( iv ) ; if ( ret !=  CHUNK_ IV_ SIZE ) { throw new  File Encryption Exception ( _ STR ) ; }  Iv Parameter Spec spec = new  Iv Parameter Spec ( iv ) ; last Chunk Cipher . init (  Cipher .  DECRYPT_ MODE , get File Key ( ) , spec ) ; n Remaining -=  CHUNK_ IV_ SIZE ; byte [ ] buf = new byte [ ( int ) n Remaining ] ; byte [ ] res ; ret = backing Random Access File . read ( buf ) ; backing Random Access File . seek ( oldpos ) ; if ( ret != n Remaining ) { throw new  File Encryption Exception ( _ STR ) ; } res = last Chunk Cipher . do Final ( buf ) ; if ( ( res == null ) || ( res . length != ( n Remaining -  CHUNK_ TLEN ) ) ) { throw new  File Encryption Exception ( _ STR ) ; } else { return res ; } }
public static  Media Size Name find Media (  Media [ ] media , float x , float y , int units ) { if ( x <= _ NUM || y <= _ NUM || units < _ NUM ) { throw new  Illegal Argument Exception ( _ STR ) ; } if ( media == null || media . length == _ NUM ) { throw new  Illegal Argument Exception ( _ STR ) ; } int size = _ NUM ;  Media Size Name [ ] msn = new  Media Size Name [ media . length ] ; for ( int i = _ NUM ; i < media . length ; i ++ ) { if ( media [ i ] instanceof  Media Size Name ) { msn [ size ++ ] = (  Media Size Name ) media [ i ] ; } } if ( size == _ NUM ) { return null ; } int match = _ NUM ; double ls = x * x + y * y ; double tmp_ls ; float [ ] dim ; float diffx = x ; float diffy = y ; for ( int i = _ NUM ; i < size ; i ++ ) {  Media Size media Size =  Media Size . get Media Size For Name ( msn [ i ] ) ; if ( media Size == null ) { continue ; } dim = media Size . get Size ( units ) ; if ( x == dim [ _ NUM ] && y == dim [ _ NUM ] ) { match = i ; break ; } else { diffx = x - dim [ _ NUM ] ; diffy = y - dim [ _ NUM ] ; tmp_ls = diffx * diffx + diffy * diffy ; if ( tmp_ls < ls ) { ls = tmp_ls ; match = i ; } } } return msn [ match ] ; }
public  Dependencies add (  Dependency dependency ) { dependencies . add ( require Non Null ( dependency , _ STR ) ) ; if ( ! is New ( ) ) { add Dependency To XML ( dependency ) ; } return this ; }
public static boolean is Network Available (  Context context ) {  Connectivity Manager connectivity Manager = (  Connectivity Manager ) context . get System Service (  Context .  CONNECTIVITY_ SERVICE ) ;  Network Info info = connectivity Manager . get Active Network Info ( ) ; return ( info != null && info . is Connected ( ) ) ; }
public static  String random Regexpish String (  Random r , int max Length ) { final  String Builder regexp = new  String Builder ( max Length ) ; for ( int i = next Int ( r , _ NUM , max Length ) ; i > _ NUM ; i -- ) { if ( r . next Boolean ( ) ) { regexp . append ( ( char )  Random Numbers . random Int Between ( r , _ STR , _ STR ) ) ; } else { regexp . append (  Random Picks . random From ( r , ops ) ) ; } } return regexp . to String ( ) ; }
@  Override public  Expected Partition Values Information create Expected Partition Values (  Expected Partition Values Create Request expected Partition Values Create Request ) { validate Expected Partition Values Create Request ( expected Partition Values Create Request ) ;  Partition Key Group Entity partition Key Group Entity = partition Key Group Dao Helper . get Partition Key Group Entity ( expected Partition Values Create Request . get Partition Key Group Key ( ) ) ;  Map <  String ,  Expected Partition Value Entity > expected Partition Value Entity Map = get Expected Partition Value Entity Map ( partition Key Group Entity . get Expected Partition Values ( ) ) ; for (  String expected Partition Value : expected Partition Values Create Request . get Expected Partition Values ( ) ) { if ( expected Partition Value Entity Map . contains Key ( expected Partition Value ) ) { throw new  Illegal Argument Exception (  String . format ( _ STR , expected Partition Value , partition Key Group Entity . get Partition Key Group Name ( ) ) ) ; } }  Collection <  Expected Partition Value Entity > created Expected Partition Value Entities = new  Array List < > ( ) ; for (  String expected Partition Value : expected Partition Values Create Request . get Expected Partition Values ( ) ) {  Expected Partition Value Entity expected Partition Value Entity = new  Expected Partition Value Entity ( ) ; created Expected Partition Value Entities . add ( expected Partition Value Entity ) ; expected Partition Value Entity . set Partition Key Group ( partition Key Group Entity ) ; expected Partition Value Entity . set Partition Value ( expected Partition Value ) ; expected Partition Value Dao . save And Refresh ( expected Partition Value Entity ) ; } expected Partition Value Dao . save And Refresh ( partition Key Group Entity ) ; return create Expected Partition Values Information From Entities ( partition Key Group Entity , created Expected Partition Value Entities ) ; }
public  String to String ( ) {  String Buffer text = new  String Buffer ( ) ; text . append ( _ STR ) ; return text . to String ( ) ; }
public void add Details Loaded Listener ( @  Not Null  Runnable runnable ) { my Loading Finished Listeners . add ( runnable ) ; }
public  Object extract Hard Ref (  Object o ) {  Weak Reference w = (  Weak Reference ) o ; if ( w != null ) { return w . get ( ) ; } return null ; }
public static  String format Integer ( int number ) { return int Format . format ( number ) ; }
public static void write Single Byte (  Output Stream out , int b ) throws  IOException { byte [ ] buffer = new byte [ _ NUM ] ; buffer [ _ NUM ] = ( byte ) ( b & _ NUM ) ; out . write ( buffer ) ; }
public void write Raw Bytes ( final byte [ ] value , int offset , int length ) throws  IOException { if ( limit - position >= length ) {  System . arraycopy ( value , offset , buffer , position , length ) ; position += length ; } else { final int bytes Written = limit - position ;  System . arraycopy ( value , offset , buffer , position , bytes Written ) ; offset += bytes Written ; length -= bytes Written ; position = limit ; refresh Buffer ( ) ; if ( length <= limit ) {  System . arraycopy ( value , offset , buffer , _ NUM , length ) ; position = length ; } else { output . write ( value , offset , length ) ; } } }
private void check Preload ( ) throws  Exception { assert cache Mode ==  PARTITIONED ; start Up ( ) ;  Collection <  Igfs File > files = write ( ) ;  Map <  UUID ,  Integer > exp Sizes = new  Hash Map < > (  GRID_ CNT , _ NUM ) ; for (  Igfs File file : files ) { for (  Igfs Block block : file . blocks ( ) ) {  Collection <  UUID > ids = primary Or Backups ( block . key ( ) ) ; for (  UUID id : ids ) { if ( exp Sizes . get ( id ) == null ) exp Sizes . put ( id , block . length ( ) ) ; else exp Sizes . put ( id , exp Sizes . get ( id ) + block . length ( ) ) ; } } } info ( _ STR + exp Sizes ) ; for ( int i = _ NUM ; i <  GRID_ CNT ; i ++ ) {  UUID id = grid ( i ) . local Node ( ) . id ( ) ;  Grid Cache Adapter <  Igfs Block Key , byte [ ] > cache = cache ( id ) ; int exp Size = exp Sizes . get ( id ) != null ? exp Sizes . get ( id ) : _ NUM ; assert Equals ( exp Size , cache . igfs Data Space Used ( ) ) ; }  Ignite g = start Grid (  GRID_ CNT ) ; info ( _ STR + g . cluster ( ) . local Node ( ) . id ( ) ) ; await Partition Map Exchange ( ) ; exp Sizes . clear ( ) ; for (  Igfs File file : files ) { for (  Igfs Block block : file . blocks ( ) ) {  Collection <  UUID > ids = primary Or Backups ( block . key ( ) ) ; assert ! ids . is Empty ( ) ; for (  UUID id : ids ) { if ( exp Sizes . get ( id ) == null ) exp Sizes . put ( id , block . length ( ) ) ; else exp Sizes . put ( id , exp Sizes . get ( id ) + block . length ( ) ) ; } } } info ( _ STR + exp Sizes ) ; for ( int i = _ NUM ; i <  GRID_ CNT - _ NUM ; i ++ ) {  UUID id = grid ( i ) . local Node ( ) . id ( ) ;  Grid Cache Adapter <  Igfs Block Key , byte [ ] > cache = cache ( id ) ; int exp Size = exp Sizes . get ( id ) != null ? exp Sizes . get ( id ) : _ NUM ; assert Equals ( _ STR + id , exp Size , cache . igfs Data Space Used ( ) ) ; } }
@  Request Mapping ( value = _ STR ) public void slo Error (  Locale locale , @  Path Variable ( value = _ STR )  String tenant ,  Http Servlet Response response ) throws  IOException { logger . info ( _ STR + locale . to String ( ) + _ STR + tenant ) ; slo Default Tenant Binding Error ( locale , response ) ; }
public synchronized void check State (  State required State ) throws  Illegal State Exception { if ( required State != current State ) { throw new  Illegal State Exception (  String . format (  Locale .  US , _ STR , required State , current State ) ) ; } }
@  Override public void on Bind View Holder (  Movie View Holder holder , int position ) {  Movie movie = movies . get ( position ) ; holder . set Movie ( movie ) ; }
public  Date Query Parser (  String [ ] date Fields ) { this . date Fields = date Fields . clone ( ) ; this . solr Date Math Pattern =  Pattern . compile ( _ STR ) ; this . instant Date Pattern =  Pattern . compile ( _ STR ) ; }
private boolean poll Stats Broker Topic (  Destination topic ) { stats Message Listener . set Destination ( topic ) ;  LOGGER . info ( _ STR + get Queue Name ( topic ) ) ; jms Template . execute (  STATS_ BROKER_ DESTINATION + get Topic Name ( topic ) , new  Producer Callback Impl ( stats Queue ) ) ; try {  Thread . sleep ( _ NUM * _ NUM ) ; } catch (  Interrupted Exception e ) { e . print Stack Trace ( ) ; } return stats Message Listener . get Stats ( ) != null ; }
public static  String resolve Pathname ( final  String pathname ) { return (  String Utils . is Blank ( pathname ) ? pathname :  IOUtils . try Get Canonical Path Else Get Absolute Path ( new  File ( pathname ) ) ) ; }
public  String ruby Type Name (  Type Ref type Ref ) { switch ( type Ref . get Kind ( ) ) { case  TYPE_ MESSAGE : return ruby Type Name For Proto Element ( type Ref . get Message Type ( ) ) ; case  TYPE_ ENUM : return ruby Type Name For Proto Element ( type Ref . get Enum Type ( ) ) ; default : {  String name =  PRIMITIVE_ TYPE_ NAMES . get ( type Ref . get Kind ( ) ) ; if ( !  Strings . is Null Or Empty ( name ) ) { return name ; } throw new  Illegal Argument Exception ( _ STR + type Ref . get Kind ( ) ) ; } } }
public  Set <  State > init And Start (  State Machine state Machine ) {  Context context = new  RAMContext (  System . current Time Millis ( ) , null , state Machine ) ; final  List <  String > triggered Events = events DAO . find Triggered Events Names By SMId ( state Machine . get Id ( ) ) ;  Set <  State > initial States = context . get Initial States ( new  Hash Set < > ( triggered Events ) ) ; execute States ( state Machine . get Id ( ) , initial States ) ; return initial States ; }
protected void linear Layout (  Visual Table labels ) {  Rectangle2 D b = get Layout Bounds ( ) ; double breadth = get Breadth ( b ) ; double span = m_hi - m_lo ; double pspan = m_prevhi - m_prevlo ; double vlo = _ NUM ; if ( m_lo >= _ NUM ) { vlo =  Math . pow ( _ NUM ,  Math . floor (  Math Lib . log10 ( m_lo ) ) ) ; } else { vlo = -  Math . pow ( _ NUM , _ NUM +  Math . floor (  Math Lib . log10 ( - m_lo ) ) ) ; }  Iterator iter = labels . tuples ( ) ; while ( iter . has Next ( ) ) {  Visual Item item = (  Visual Item ) iter . next ( ) ; reset ( item ) ; double v = item . get Double (  VALUE ) ; double x = span == _ NUM ? _ NUM : ( ( v - m_lo ) / span ) * breadth ; set ( item , x , b ) ; }  Index index = labels . index (  VALUE ) ; double step = get Linear Step ( span , span == _ NUM ? _ NUM : breadth / span ) ; if ( step == _ NUM ) step = _ NUM ; int r ; for ( double x , v = vlo ; v <= m_hi ; v += step ) { x = ( ( v - m_lo ) / span ) * breadth ; if ( x < - _ NUM ) { continue ; } else if ( ( r = index . get ( v ) ) >= _ NUM ) {  Visual Item item = labels . get Item ( r ) ; item . set Visible ( _ BOOL ) ; item . set End Visible ( _ BOOL ) ; } else {  Visual Item item = labels . add Item ( ) ; item . set (  LABEL , m_nf . format ( v ) ) ; item . set Double (  VALUE , v ) ; double f = pspan == _ NUM ? _ NUM : ( ( v - m_prevlo ) / pspan ) ; if ( f <= _ NUM || f >= _ NUM ) item . set Start Visible ( _ BOOL ) ; set ( item , f * breadth , b ) ; set ( item , x , b ) ; } } }
public  Attribute Filler (  Attributes Impl attributes ) { attributes . clear ( ) ; atts = attributes ; po = null ; }
public static non_terminal find (  String with_name ) { if ( with_name == null ) return null ; else return ( non_terminal ) _all . get ( with_name ) ; }
public @  Check For Null  Block create New Block ( @  Nonnull  String system Name , @  Check For Null  String user Name ) throws  Illegal Argument Exception {  Block r ; if ( user Name != null && ! user Name . equals ( _ STR ) ) { r = get By User Name ( user Name ) ; if ( r != null ) { return null ; } } r = get By System Name ( system Name ) ; if ( r != null ) { return null ; }  String s Name = system Name . to Upper Case ( ) ; r = new  Block ( s Name , user Name ) ; register ( r ) ; if ( system Name . starts With ( _ STR ) ) { try { int auto Number =  Integer . parse Int ( system Name . substring ( _ NUM ) ) ; if ( auto Number > last Auto Block Ref ) { last Auto Block Ref = auto Number ; } } catch (  Number Format Exception e ) { log . warn ( _ STR + system Name + _ STR ) ; } } try { r . set Block Speed ( _ STR ) ; } catch ( jmri .  Jmri Exception ex ) { log . error ( ex . to String ( ) ) ; } return r ; }
@  Override public byte process (  Target target ) {  Element word = navigator . get Element ( target ) ; if ( word == null ) return values . get ( _ STR ) ;  String pos = word . get Attribute ( _ STR ) ; if ( pos == null ) return values . get ( _ STR ) ; pos = pos . trim ( ) ; if ( pos Converter . contains Key ( pos ) ) { pos = pos Converter . get ( pos ) ; } if ( ! values . contains ( pos ) ) return values . get ( _ STR ) ; return values . get ( pos ) ; }
private static  String substitute Properties (  String str ) { str = str . trim ( ) ;  Matcher matcher =  PROP_ REGEX . matcher ( str ) ;  String Buffer buf = new  String Buffer ( ) ; while ( matcher . find ( ) ) {  String match = matcher . group ( ) ; if ( match . length ( ) >= _ NUM ) {  String key = match . substring ( _ NUM , match . length ( ) - _ NUM ) ;  String val =  System . getenv ( key ) ; if ( val == null ) val =  System . get Property ( key ) ; if ( val != null ) { match = val . replace All ( _ STR , _ STR ) ; } else if ( match . starts With ( _ STR ) ) match = match . replace ( _ STR , _ STR ) ; } matcher . append Replacement ( buf , match ) ; } matcher . append Tail ( buf ) ; return buf . to String ( ) ; }
public  Char Buffer (  String string , int offset , int length ) { int capacity =  Math . max ( length ,  MIN_ CAPACITY ) ; init ( new char [ capacity ] , _ NUM , length ) ; string . get Chars ( offset , length , buffer ( ) , _ NUM ) ; }
private void update Promo Visibility ( float percentage ) { if ( is Promo Visible ( ) ) { m Promo Visible = _ BOOL ; m Promo Height Px =  Math . round (  Math Utils . clamp ( percentage * m Promo Content Height Px , _ NUM , m Promo Content Height Px ) ) ; m Promo Opacity = percentage ; } else { m Promo Visible = _ BOOL ; m Promo Height Px = _ NUM ; m Promo Opacity = _ NUM ; } }
public void update Geometry ( int row ,  Geometry geometry ) { set Value At ( geometry , row , get Geometry Field Index ( ) ) ; }
@  Override public void do_after_propagation ( ) { for (  Pt Ins Interval Manager pim : pt_objs . values ( ) ) { pim . flush ( ) ; } new_pts = new  Hash Map <  Alloc Node ,  Pt Ins Interval Manager > ( ) ; }
List <  String > lines To Statements (  List <  String > lines ) {  List <  String > statements = new  Array List < > ( ) ;  Delimiter non Standard Delimiter = null ;  Cql Statement Builder cql Statement Builder = new  Cql Statement Builder ( ) ; for ( int line Number = _ NUM ; line Number <= lines . size ( ) ; line Number ++ ) {  String line = lines . get ( line Number - _ NUM ) ; if ( cql Statement Builder . is Empty ( ) ) { if ( !  String Utils . has Text ( line ) ) { continue ; }  Delimiter new Delimiter = cql Statement Builder . extract New Delimiter From Line ( line ) ; if ( new Delimiter != null ) { non Standard Delimiter = new Delimiter ; continue ; } cql Statement Builder . set Line Number ( line Number ) ; if ( non Standard Delimiter != null ) { cql Statement Builder . set Delimiter ( non Standard Delimiter ) ; } } cql Statement Builder . add Line ( line ) ; if ( cql Statement Builder . is Terminated ( ) ) {  String cql Statement = cql Statement Builder . get Cql Statement ( ) ; statements . add ( cql Statement ) ;  LOG . debug ( _ STR + cql Statement ) ; cql Statement Builder = new  Cql Statement Builder ( ) ; } else if ( cql Statement Builder . can Discard ( ) ) { cql Statement Builder = new  Cql Statement Builder ( ) ; } } if ( ! cql Statement Builder . is Empty ( ) ) { statements . add ( cql Statement Builder . get Cql Statement ( ) ) ; } return statements ; }
public static void create Resized Image ( final  File source File , final  File dest File , final int width , final int height , final float quality ) throws  IOException {  Buffered Image image =  Image IO . read ( source File ) ;  Dimension dimension = new  Dimension ( width , height ) ; if ( image . get Height ( ) == dimension . height && image . get Width ( ) == dimension . width ) { write Untouched Image ( source File , dest File ) ; } else { resize Image ( image , dimension . width , dimension . height , quality , dest File ) ; } }
public boolean dyn Init ( ) { return m_data . load ( ) ; }
public static void each File Recurse ( final  Path self , final  File Type file Type , @  Closure Params ( value =  Simple Type . class , options = _ STR ) final  Closure closure ) throws  IOException { check Dir ( self ) ; try (  Directory Stream <  Path > stream =  Files . new Directory Stream ( self ) ) { for (  Path path : stream ) { if (  Files . is Directory ( path ) ) { if ( file Type !=  File Type .  FILES ) closure . call ( path ) ; each File Recurse ( path , file Type , closure ) ; } else if ( file Type !=  File Type .  DIRECTORIES ) { closure . call ( path ) ; } } } }
private void baseline Layout ( int origin , int size ) { int ascent ; int descent ; if ( baseline Anchored To Top ) { ascent = pref Ascent ; descent = size - ascent ; } else { ascent = size - pref Descent ; descent = pref Descent ; } for ( int counter = springs . size ( ) - _ NUM ; counter >= _ NUM ; counter -- ) {  Spring spring = get Spring ( counter ) ; int alignment = spring . get Alignment ( ) ; if ( alignment ==  NO_ ALIGNMENT || alignment ==  BASELINE ) { int baseline = spring . get Baseline ( ) ; if ( baseline >= _ NUM ) { int spring Max = spring . get Maximum Size (  VERTICAL ) ; int spring Pref = spring . get Preferred Size (  VERTICAL ) ; int height = spring Pref ; int y ; switch ( spring . get Baseline Resize Behavior ( ) ) { case  Component .  BRB_ CONSTANT_ ASCENT : y = origin + ascent - baseline ; height =  Math . min ( descent , spring Max - baseline ) + baseline ; break ; case  Component .  BRB_ CONSTANT_ DESCENT : height =  Math . min ( ascent , spring Max - spring Pref + baseline ) + ( spring Pref - baseline ) ; y = origin + ascent + ( spring Pref - baseline ) - height ; break ; default : y = origin + ascent - baseline ; break ; } spring . set Size (  VERTICAL , y , height ) ; } else { set Child Size ( spring ,  VERTICAL , origin , size ) ; } } else { set Child Size ( spring ,  VERTICAL , origin , size ) ; } } }
public static double read Double ( final  JSONArray json Array , final int index , final boolean required , final boolean not Null ) throws  JSONException { if ( required ) { return json Array . get Double ( index ) ; } if ( not Null && json Array . is Null ( index ) ) { throw new  JSONException (  String . format (  Locale .  US ,  NULL_ VALUE_ FORMAT_ ARRAY , index ) ) ; } double value = _ NUM ; if ( ! json Array . is Null ( index ) ) { value = json Array . get Double ( index ) ; } return value ; }
public static void copy (  String in ,  Charset charset ,  Output Stream out ) throws  IOException {  Assert . not Null ( in , _ STR ) ;  Assert . not Null ( charset , _ STR ) ;  Assert . not Null ( out , _ STR ) ;  Writer writer = new  Output Stream Writer ( out , charset ) ; writer . write ( in ) ; writer . flush ( ) ; }
@  Override public  String to String ( ) { assign Leaf Model Numbers ( _ NUM ) ; try {  String Buffer text = new  String Buffer ( ) ; if ( m_is Leaf ) { text . append ( _ STR ) ; text . append ( _ STR + m_leaf Model Num + _ STR + get Model Parameters ( ) ) ; } else { dump Tree ( _ NUM , text ) ; } text . append ( _ STR + num Leaves ( ) + _ STR ) ; text . append ( _ STR + num Nodes ( ) + _ STR ) ; text . append ( models To String ( ) ) ; return text . to String ( ) ; } catch (  Exception e ) { return _ STR ; } }
public  Object new Non Movable Array (  Class < ? > component Type , int length ) { return  Array . new Instance ( component Type , length ) ; }
public static boolean any Misbehave (  Formatter formatter ,  List <  File > problem Files ) { long start =  System . current Time Millis ( ) ; for (  File problem : problem Files ) {  Padded Cell padded =  Padded Cell . check ( formatter , problem ) ; if ( padded . misbehaved ( ) ) { return _ BOOL ; } if (  System . current Time Millis ( ) - start >  MAX_ MS_ DETERMINING_ MISBEHAVIOR ) { return _ BOOL ; } } return _ BOOL ; }
public void label Distances (  Hypergraph <  V ,  E > graph ,  Set <  V > root Set ) { initialize ( graph , root Set ) ; int distance = _ NUM ; while ( _ BOOL ) {  List <  V > new List = new  Array List <  V > ( ) ; for (  V current Vertex : m Current List ) { if ( graph . contains Vertex ( current Vertex ) ) { for (  V next : graph . get Successors ( current Vertex ) ) { visit New Vertex ( current Vertex , next , distance , new List ) ; } } } if ( new List . size ( ) == _ NUM ) break ; m Current List = new List ; distance ++ ; } for (  V v : m Unvisited Vertices ) { distance Decorator . put ( v , new  Integer ( - _ NUM ) ) ; } }
public static java . lang .  String to String ( double d ) { double m =  Math . abs ( d ) ; if ( d ==  POSITIVE_ INFINITY ) { return _ STR ; } else if ( d ==  NEGATIVE_ INFINITY ) { return _ STR ; } else if ( d == _ NUM ) { return _ STR ; } else if ( m >= _ NUM && m < _ NUM ) {  String str = to String Impl ( d , _ BOOL ) ; char [ ] chars = str . to Char Array ( ) ; int i = chars . length - _ NUM ; char c ; while ( i >= _ NUM && ( c = chars [ i ] ) == _ STR ) { i -- ; } if ( i < _ NUM || str . index Of ( _ STR ) == - _ NUM ) { return str ; } else if ( chars [ i ] == _ STR || chars [ i ] == _ STR ) { i ++ ; } return str . substring ( _ NUM , i + _ NUM ) ; } else { return to String Impl ( d , _ BOOL ) ; } }
public  Log Stream print ( char c ) { if ( ps != null ) { indent ( ) ; line Buffer . append ( c ) ; if ( c == _ STR ) { if ( line Buffer . index Of (  LINE_ SEPARATOR , line Buffer . length ( ) -  LINE_ SEPARATOR . length ( ) ) != - _ NUM ) { flush Line ( _ BOOL ) ; } } } return this ; }
public final static  Header Element [ ] parse Elements ( final  String value ,  Header Value Parser parser ) throws  Parse Exception { if ( value == null ) { throw new  Illegal Argument Exception ( _ STR ) ; } if ( parser == null ) parser =  Save Header Value Parser .  DEFAULT ;  Char Array Buffer buffer = new  Char Array Buffer ( value . length ( ) ) ; buffer . append ( value ) ;  Save Parser Cursor cursor = new  Save Parser Cursor ( _ NUM , value . length ( ) ) ; return parser . parse Elements ( buffer , cursor ) ; }
public  Interval gap (  Readable Interval interval ) { interval =  Date Time Utils . get Readable Interval ( interval ) ; long other Start = interval . get Start Millis ( ) ; long other End = interval . get End Millis ( ) ; long this Start = get Start Millis ( ) ; long this End = get End Millis ( ) ; if ( this Start > other End ) { return new  Interval ( other End , this Start , get Chronology ( ) ) ; } else if ( other Start > this End ) { return new  Interval ( this End , other Start , get Chronology ( ) ) ; } else { return null ; } }
public void test Has Attributes1 ( ) throws  Throwable {  Document doc ;  Element element ;  Node List element List ; boolean has Attributes ; doc = (  Document ) load ( _ STR , builder ) ; element List = doc . get Elements By Tag Name ( _ STR ) ; element = (  Element ) element List . item ( _ NUM ) ; has Attributes = element . has Attributes ( ) ; assert False ( _ STR , has Attributes ) ; element List = doc . get Elements By Tag Name ( _ STR ) ; element = (  Element ) element List . item ( _ NUM ) ; has Attributes = element . has Attributes ( ) ; assert True ( _ STR , has Attributes ) ; }
public boolean is Question ( ) { return type String . starts With (  QUESTION ) ; }
public  Servlet Binding (  Http Servlet Request request ,  Http Servlet Response response ,  Servlet Context context ) { super . set Variable ( _ STR , request ) ; super . set Variable ( _ STR , response ) ; super . set Variable ( _ STR , context ) ; super . set Variable ( _ STR , context ) ; super . set Variable ( _ STR , request . get Session ( _ BOOL ) ) ;  Map params = collect Params ( request ) ; super . set Variable ( _ STR , params ) ;  Map <  String ,  String > headers = new  Linked Hash Map <  String ,  String > ( ) ; for (  Enumeration names = request . get Header Names ( ) ; names . has More Elements ( ) ; ) {  String header Name = (  String ) names . next Element ( ) ;  String header Value = request . get Header ( header Name ) ; headers . put ( header Name , header Value ) ; } super . set Variable ( _ STR , headers ) ; }
private long download Index Files ( boolean download Complete Index ,  Directory index Dir ,  Directory tmp Index Dir , long latest Generation ) throws  Exception { if (  LOG . is Debug Enabled ( ) ) {  LOG . debug ( _ STR +  Arrays . as List ( index Dir . list All ( ) ) ) ; } long bytes Downloaded = _ NUM ; for (  Map <  String ,  Object > file : files To Download ) {  String filename = (  String ) file . get (  NAME ) ; long size = (  Long ) file . get (  SIZE ) ;  Compare Result compare Result = compare File ( index Dir , filename , size , (  Long ) file . get (  CHECKSUM ) ) ; if ( ! compare Result . equal || download Complete Index || files To Always Download If No Checksums ( filename , size , compare Result ) ) { dir File Fetcher = new  Directory File Fetcher ( tmp Index Dir , file , (  String ) file . get (  NAME ) ,  FILE , latest Generation ) ; current File = file ; dir File Fetcher . fetch File ( ) ; bytes Downloaded += dir File Fetcher . get Bytes Downloaded ( ) ; files Downloaded . add ( new  Hash Map < > ( file ) ) ; } else {  LOG . info ( _ STR + file . get (  NAME ) + _ STR ) ; } } return bytes Downloaded ; }
private static  Windows File Attributes from File Information ( long address , int reparse Tag ) { int file Attrs = unsafe . get Int ( address +  OFFSETOF_ FILE_ INFORMATION_ ATTRIBUTES ) ; long creation Time = unsafe . get Long ( address +  OFFSETOF_ FILE_ INFORMATION_ CREATETIME ) ; long last Access Time = unsafe . get Long ( address +  OFFSETOF_ FILE_ INFORMATION_ LASTACCESSTIME ) ; long last Write Time = unsafe . get Long ( address +  OFFSETOF_ FILE_ INFORMATION_ LASTWRITETIME ) ; long size = ( ( long ) ( unsafe . get Int ( address +  OFFSETOF_ FILE_ INFORMATION_ SIZEHIGH ) ) << _ NUM ) + ( unsafe . get Int ( address +  OFFSETOF_ FILE_ INFORMATION_ SIZELOW ) & _ NUM ) ; int vol Serial Number = unsafe . get Int ( address +  OFFSETOF_ FILE_ INFORMATION_ VOLSERIALNUM ) ; int file Index High = unsafe . get Int ( address +  OFFSETOF_ FILE_ INFORMATION_ INDEXHIGH ) ; int file Index Low = unsafe . get Int ( address +  OFFSETOF_ FILE_ INFORMATION_ INDEXLOW ) ; return new  Windows File Attributes ( file Attrs , creation Time , last Access Time , last Write Time , size , reparse Tag , vol Serial Number , file Index High , file Index Low ) ; }
protected void rollback From Within Callback ( boolean indoubt , boolean heuristic ) throws  Heur Commit Exception ,  Heur Mixed Exception ,  Sys Exception ,  Heur Hazard Exception , java . lang .  Illegal State Exception {  Coordinator State Handler next State Handler = null ; try { coordinator_ . set State (  Tx State .  ABORTING ) ; committed_ = new  Boolean ( _ BOOL ) ;  Vector <  Participant > participants = coordinator_ . get Participants ( ) ; int count = ( participants . size ( ) - read Only Table_ . size ( ) ) ;  Termination Result rollbackresult = new  Termination Result ( count ) ;  Enumeration <  Participant > enumm = participants . elements ( ) ; while ( enumm . has More Elements ( ) ) {  Participant p = enumm . next Element ( ) ; if ( ! read Only Table_ . contains ( p ) ) {  Rollback Message rm = new  Rollback Message ( p , rollbackresult , indoubt ) ; propagator_ . submit Propagation Message ( rm ) ; } } rollbackresult . wait For Replies ( ) ; int res = rollbackresult . get Result ( ) ; if ( indoubt && res !=  Termination Result .  ALL_ OK ) { if ( res ==  Termination Result .  HEUR_ MIXED ) {  Set <  Participant > hazards = rollbackresult . get Possibly Indoubts ( ) ; next State Handler = new  Heur Mixed State Handler ( this , hazards ) ; coordinator_ . set State Handler ( next State Handler ) ; throw new  Heur Mixed Exception ( ) ; } else if ( res ==  Termination Result .  HEUR_ COMMIT ) { next State Handler = new  Heur Committed State Handler ( this ) ; coordinator_ . set State Handler ( next State Handler ) ; throw new  Heur Commit Exception ( ) ; } else if ( res ==  Termination Result .  HEUR_ HAZARD ) {  Set <  Participant > hazards = rollbackresult . get Possibly Indoubts ( ) ; next State Handler = new  Heur Hazard State Handler ( this , hazards ) ; coordinator_ . set State Handler ( next State Handler ) ; throw new  Heur Hazard Exception ( ) ; } } else { if ( heuristic ) { next State Handler = new  Heur Aborted State Handler ( this ) ; } else next State Handler = new  Terminated State Handler ( this ) ; coordinator_ . set State Handler ( next State Handler ) ; } } catch (  Runtime Exception runerr ) { throw new  Sys Exception ( _ STR + runerr . get Message ( ) , runerr ) ; } catch (  Interrupted Exception e ) {  Interrupted Exception Helper . handle Interrupted Exception ( e ) ; throw new  Sys Exception ( _ STR + e . get Message ( ) , e ) ; } }
public static  JPanel create Radiobox (  String boxlabel ,  String [ ] buttons , int initially Selected ,  Action Listener al ) {  JPanel jp = create Palette JPanel ( boxlabel ) ;  Button Group buttongroup = new  Button Group ( ) ; for ( int j = _ NUM ; j < buttons . length ; j ++ ) {  JRadio Button jrb = new  JRadio Button ( buttons [ j ] ) ; jrb . set Action Command ( _ STR + j ) ; jp . add ( jrb ) ; buttongroup . add ( jrb ) ; if ( al != null ) { jrb . add Action Listener ( al ) ; } if ( j == initially Selected ) { jrb . set Selected ( _ BOOL ) ; } else { jrb . set Selected ( _ BOOL ) ; } } return jp ; }
public void store State ( ) { if ( intervals Known ) { if ( stored Intervals == null ) { stored Intervals = new double [ intervals . length ] ; } if ( stored Lineage Counts == null ) { stored Lineage Counts = new int [ lineage Counts . length ] ; } if ( super Store ) { if ( stored Indices == null ) { stored Indices = new int [ indices . length ] ; } if ( stored Times == null ) { stored Times = new double [ times . length ] ; } }  System . arraycopy ( intervals , _ NUM , stored Intervals , _ NUM , intervals . length ) ;  System . arraycopy ( lineage Counts , _ NUM , stored Lineage Counts , _ NUM , lineage Counts . length ) ; if ( super Store ) {  System . arraycopy ( indices , _ NUM , stored Indices , _ NUM , indices . length ) ;  System . arraycopy ( times , _ NUM , stored Times , _ NUM , times . length ) ; } } stored Intervals Known = intervals Known ; }
public static void recompute Covariance Matrices (  Relation < ? extends  Number Vector > relation ,  Writable Data Store < double [ ] > prob Cluster IGiven X ,  List < ? extends  EMCluster Model < ? > > models ) { for (  EMCluster Model < ? > m : models ) { m . begin EStep ( ) ; } double [ ] wsum = new double [ models . size ( ) ] ; for (  DBIDIter iditer = relation . iter DBIDs ( ) ; iditer . valid ( ) ; iditer . advance ( ) ) { double [ ] cluster Probabilities = prob Cluster IGiven X . get ( iditer ) ;  Number Vector instance = relation . get ( iditer ) ; int i = _ NUM ; for (  EMCluster Model < ? > m : models ) { final double prior = cluster Probabilities [ i ] ; if ( prior > _ NUM ) { m . update E ( instance , prior ) ; } wsum [ i ] += prior ; ++ i ; } } int i = _ NUM ; for (  EMCluster Model < ? > m : models ) { m . finalize EStep ( ) ; m . set Weight ( wsum [ i ] / relation . size ( ) ) ; i ++ ; } }
public static  URI uri (  String value ) { return ( value != null && value . length ( ) > _ NUM ) ?  URI . create ( value ) : null ; }
public  JPEGHuffman Table ( short [ ] lengths , short [ ] values ) { if ( lengths == null || values == null || lengths . length == _ NUM || values . length == _ NUM || lengths . length > _ NUM || values . length > _ NUM ) { throw new  Illegal Argument Exception ( _ STR ) ; } for ( int i = _ NUM ; i < lengths . length ; i ++ ) { if ( lengths [ i ] < _ NUM ) { throw new  Illegal Argument Exception ( _ STR + i + _ STR ) ; } } for ( int i = _ NUM ; i < values . length ; i ++ ) { if ( values [ i ] < _ NUM ) { throw new  Illegal Argument Exception ( _ STR + i + _ STR ) ; } } this . lengths =  Arrays . copy Of ( lengths , lengths . length ) ; this . values =  Arrays . copy Of ( values , values . length ) ; validate ( ) ; }
private void partition Class (  GVCongruence Class partition ) {  Iterator <  Value Graph Vertex > i = partition . iterator ( ) ;  Value Graph Vertex first = i . next ( ) ;  Array List <  GVCongruence Class > new Classes = new  Array List <  GVCongruence Class > ( ) ;  Array List <  Value Graph Vertex > to Remove = new  Array List <  Value Graph Vertex > ( ) ; while ( i . has Next ( ) ) {  Value Graph Vertex v = i . next ( ) ; if ( ! check Congruence ( first , v ) ) { int index = find Congruence Match ( new Classes , v ) ; if ( index > - _ NUM ) {  GVCongruence Class match =  B . get ( index ) ; match . add Vertex ( v ) ; v . set Value Number ( match . get Value Number ( ) ) ; } else {  GVCongruence Class c = create Congruence Class ( v ) ; new Classes . add ( c ) ; c . add Vertex ( v ) ; v . set Value Number ( c . get Value Number ( ) ) ; } to Remove . add ( v ) ; } } for (  Value Graph Vertex v : to Remove ) { partition . remove Vertex ( v ) ; } if ( ( ! new Classes . is Empty ( ) ) && ( partition . size ( ) > _ NUM ) ) { work List . push ( partition ) ; } for (  GVCongruence Class c : new Classes ) { if ( c . size ( ) > _ NUM ) { work List . push ( c ) ; } add Dependent Classes To Worklist ( c ) ; } }
private void create Storage Adapter (  Storage HADomain adapter ,  CIMInstance adapter Instance ,  Access Profile profile ) throws  URISyntax Exception ,  IOException { if ( null == adapter ) { adapter = new  Storage HADomain ( ) ; adapter . set Id (  URIUtil . create Id (  Storage HADomain . class ) ) ; adapter . set Storage Device URI ( profile . get System Id ( ) ) ; adapter . set Name ( get CIMProperty Value ( adapter Instance ,  NAME ) ) ; adapter . set Adapter Name ( get CIMProperty Value ( adapter Instance ,  EMCADAPTERNAME ) ) ; adapter . set Native Guid (  Native GUIDGenerator . generate Native Guid ( _db Client , adapter ) ) ; } adapter . set Numberof Ports ( get CIMProperty Value ( adapter Instance ,  EMCNUMPORTS ) ) ; adapter . set Protocol ( get CIMProperty Value ( adapter Instance ,  EMCPROTOCOL ) ) ; adapter . set Slot Number ( get CIMProperty Value ( adapter Instance ,  EMCSLOTNUMBER ) ) ;  String [ ] roles = (  String [ ] ) adapter Instance . get Property Value (  ROLES ) ; adapter . set Adapter Type (  HADomain Type . get HADomain Type Name ( roles [ _ NUM ] ) ) ; _storage Adapter List . add ( adapter ) ; }
public void write File Content (  String content ,  Path path ) throws  Command Exception { try {  Files . write ( content , path . to File ( ) ,  Standard Charsets .  UTF_8 ) ; } catch (  IOException e ) { throw new  Command Exception ( _ STR + path . to String ( ) , e ) ; } }
@  Override public void apply (  Nexus Stream Parser np ) throws  Exception { np . match Ignore Case ( _ STR ) ;  String which = np . get Word Matches Ignoring Case ( _ STR ) ; np . match Ignore Case ( _ STR ) ;  Inspector Window inspector Window = (  Inspector Window ) get Viewer ( ) ; inspector Window . set Sort Reads Alphabetically ( which . equals Ignore Case ( _ STR ) ) ; }
private void handle Operand (  String tok ) throws  Exception { if ( tok . index Of ( _ STR ) != - _ NUM ) { m_post Fix Exp Vector . add Element ( new  Attribute Operand ( tok , m_sign Mod ) ) ; } else { try { m_post Fix Exp Vector . add Element ( new  Numeric Operand ( tok , m_sign Mod ) ) ; } catch (  Number Format Exception ne ) { throw new  Exception ( _ STR ) ; } } m_sign Mod = _ BOOL ; }
public void remove ( final  T object ) { synchronized ( m Lock ) { m List . remove ( object ) ; } notify Data Set Changed ( ) ; }
public static boolean compare Cell Value (  Double v1 ,  Double v2 , double t , boolean ignore Na N ) { if ( v1 == null ) v1 = _ NUM ; if ( v2 == null ) v2 = _ NUM ; if ( ignore Na N && ( v1 . is Na N ( ) || v1 . is Infinite ( ) || v2 . is Na N ( ) || v2 . is Infinite ( ) ) ) return _ BOOL ; if ( v1 . equals ( v2 ) ) return _ BOOL ; return  Math . abs ( v1 - v2 ) <= t ; }
public boolean exists ( @  Not Null final  URL url ) { require Non Null ( url , _ STR ) ; try { final  URLConnection url Connection = url . open Connection ( ) ; url Connection . set Connect Timeout (  CONNECTION_ TIMEOUT ) ; if ( url Connection instanceof  Http URLConnection ) { return exists ( (  Http URLConnection ) url Connection ) ; } else { url Connection . connect ( ) ; return _ BOOL ; } } catch (  IOException ioe ) {  LOG . debug (  UNABLE_ TO_ CHECK_ MESSAGE , url , ioe ) ; return _ BOOL ; } }
private void on Datatype Element (  Element xsd Element ,  Document Factory parent Factory ) {  String name = xsd Element . attribute Value ( _ STR ) ;  String type = xsd Element . attribute Value ( _ STR ) ;  QName qname = get QName ( name ) ;  Datatype Element Factory factory = get Datatype Element Factory ( qname ) ; if ( type != null ) {  XSDatatype data Type = get Type By Name ( type ) ; if ( data Type != null ) { factory . set Child Element XSDatatype ( qname , data Type ) ; } else {  QName type QName = get QName ( type ) ; named Type Resolver . register Typed Element ( xsd Element , type QName , parent Factory ) ; } return ; }  Element xsd Simple Type = xsd Element . element (  XSD_ SIMPLETYPE ) ; if ( xsd Simple Type != null ) {  XSDatatype data Type = load XSDatatype From Simple Type ( xsd Simple Type ) ; if ( data Type != null ) { factory . set Child Element XSDatatype ( qname , data Type ) ; } }  Element schema Complex Type = xsd Element . element (  XSD_ COMPLEXTYPE ) ; if ( schema Complex Type != null ) { on Schema Complex Type ( schema Complex Type , factory ) ; }  Iterator <  Element > iter = xsd Element . element Iterator (  XSD_ ATTRIBUTE ) ; if ( iter . has Next ( ) ) { do { on Datatype Attribute ( xsd Element , factory , iter . next ( ) ) ; } while ( iter . has Next ( ) ) ; } }
public void create (  String xliff Path ,  String skeleton Path ,  Locale Id src Loc ,  Locale Id trg Loc ,  String data Type ,  String original ,  String message ) { if ( writer != null ) { close ( ) ; } this . skeleton Path = skeleton Path ; this . original = original ; this . src Loc = src Loc ; this . trg Loc = trg Loc ; this . data Type = data Type ; if ( output Stream == null ) { writer = new  XMLWriter ( xliff Path ) ; } else if ( output Stream != null ) { writer = new  XMLWriter ( new  Output Stream Writer ( output Stream ,  Standard Charsets .  UTF_8 ) ) ; } writer . write Start Document ( ) ; writer . write Start Element ( _ STR ) ; writer . write Attribute String ( _ STR , _ STR ) ; writer . write Attribute String ( _ STR ,  Namespaces .  NS_ XLIFF12 ) ; writer . write Attribute String ( _ STR ,  Namespaces .  NS_ XLIFFOKAPI ) ; if ( params . get Include Its ( ) ) { writer . write Attribute String ( _ STR +  Namespaces .  ITS_ NS_ PREFIX ,  Namespaces .  ITS_ NS_ URI ) ; writer . write Attribute String ( _ STR +  Namespaces .  ITSXLF_ NS_ PREFIX ,  Namespaces .  ITSXLF_ NS_ URI ) ; writer . write Attribute String (  Namespaces .  ITS_ NS_ PREFIX + _ STR , _ STR ) ; } write Annotators Ref If Needed ( ) ; if ( !  Util . is Empty ( message ) ) { writer . write Line Break ( ) ; writer . write Comment ( message , _ BOOL ) ; } writer . write Line Break ( ) ; its Cont For Unit = new  ITSContent ( xliff Cont . get Charset Encoder ( ) , _ BOOL , _ BOOL ) ; its Cont For Src Cont = new  ITSContent ( xliff Cont . get Charset Encoder ( ) , _ BOOL , _ BOOL ) ; its Cont For Trg Cont = new  ITSContent ( xliff Cont . get Charset Encoder ( ) , _ BOOL , _ BOOL ) ; its Cont For Alt Trg Cont = new  ITSContent ( xliff Cont . get Charset Encoder ( ) , _ BOOL , _ BOOL ) ; annotators Ref = new  Stack <  String > ( ) ; annotators Ref . push ( null ) ; need Annotators Ref = _ BOOL ; }
public  Resource from Properties (  Properties properties ) {  String name = properties . get Property (  Resource Property Set .  RESOURCE_ NAME ) ;  String type = properties . get Property (  Resource Property Set .  RESOURCE_ TYPE ) ;  Resource resource = new  Resource ( name , type ) ; if ( properties . contains Key (  Resource Property Set .  RESOURCE_ CLASS ) ) {  String class Name = properties . get Property (  Resource Property Set .  RESOURCE_ CLASS ) ; resource . set Class Name ( class Name ) ; } if ( properties . contains Key (  Resource Property Set .  RESOURCE_ ID ) ) {  String id = properties . get Property (  Resource Property Set .  RESOURCE_ ID ) ; resource . set Id ( id ) ; } else { resource . set Id ( create Id From Jndi Location If Not Null ( name ) ) ; }  String parameters As ASemicolon Delimited String = properties . get Property (  Resource Property Set .  PARAMETERS ) ; resource . set Parameters (  Property Utils . to Map ( get Parameters From String (  Property Utils . escape Back Slashes If Not Null ( parameters As ASemicolon Delimited String ) ) ) ) ; return resource ; }
private void sequence Bounded Linearizable Query (  Query Entry entry ,  Server Session Context session ,  Completable Future <  Query Response > future ) { if ( entry . get Sequence ( ) > session . get Command Sequence ( ) ) { session . register Sequence Query ( entry . get Sequence ( ) , null ) ; } else { apply Query ( entry , future ) ; } }
public static <  T >  T select Randomly From List (  List <  T > l ) { return l . get ( _r . next Int ( l . size ( ) ) ) ; }
public void find And Init (  Object some Obj ) { if ( some Obj instanceof  Map Bean ) { set Map ( (  Map Bean ) some Obj ) ; } }
private boolean filter Date (  ILog Entry log Entry ,  Date start Date ,  Date end Date ) {  Date date = log Entry . get Date ( ) ; if ( date == null ) { return _ BOOL ; } if ( ( start Date != null ) && date . before ( start Date ) ) { return _ BOOL ; } if ( ( end Date != null ) && date . after ( end Date ) ) { return _ BOOL ; } return _ BOOL ; }
public  Multi Percolate Request add (  Percolate Request request ) { if ( request . indices ( ) == null && indices != null ) { request . indices ( indices ) ; } if ( request . document Type ( ) == null && document Type != null ) { request . document Type ( document Type ) ; } if ( request . indices Options ( ) ==  Indices Options . strict Expand Open And Forbid Closed ( ) && indices Options !=  Indices Options . strict Expand Open And Forbid Closed ( ) ) { request . indices Options ( indices Options ) ; } requests . add ( request ) ; return this ; }
public  Shape model To View ( int pos ,  Shape a ,  Position .  Bias b ) throws  Bad Location Exception {  Rectangle alloc = a . get Bounds ( ) ; alloc . height = metrics . get Height ( ) ; alloc . width = _ NUM ; int p0 = get Start Offset ( ) ; if ( pos < p0 || pos > get End Offset ( ) ) { throw new  Bad Location Exception ( _ STR , pos ) ; } int test P = ( b ==  Position .  Bias .  Forward ) ? pos :  Math . max ( p0 , pos - _ NUM ) ; int line = _ NUM ; int [ ] line Ends = get Line Ends ( ) ; if ( line Ends != null ) { line = find Line ( test P - p0 ) ; if ( line > _ NUM ) { p0 += line Ends [ line - _ NUM ] ; } alloc . y += alloc . height * line ; } if ( pos > p0 ) {  Segment segment =  Segment Cache . get Shared Segment ( ) ; load Text ( segment , p0 , pos ) ; alloc . x +=  Utilities . get Tabbed Text Width ( segment , metrics , alloc . x ,  Wrapped Plain View . this , p0 ) ;  Segment Cache . release Shared Segment ( segment ) ; } return alloc ; }
public synchronized void on Draw Frame (  GL10 gl ) { if (  DRAW_ TEXTURE && m Texture Ids == null ) { m Texture Ids = new int [ _ NUM ] ; gl . gl Gen Textures ( _ NUM , m Texture Ids , _ NUM ) ; for ( int texture Id : m Texture Ids ) { gl . gl Bind Texture (  GL10 .  GL_ TEXTURE_2 D , texture Id ) ; gl . gl Tex Parameterf (  GL10 .  GL_ TEXTURE_2 D ,  GL10 .  GL_ TEXTURE_ MIN_ FILTER ,  GL10 .  GL_ NEAREST ) ; gl . gl Tex Parameterf (  GL10 .  GL_ TEXTURE_2 D ,  GL10 .  GL_ TEXTURE_ MAG_ FILTER ,  GL10 .  GL_ NEAREST ) ; gl . gl Tex Parameterf (  GL10 .  GL_ TEXTURE_2 D ,  GL10 .  GL_ TEXTURE_ WRAP_ S ,  GL10 .  GL_ CLAMP_ TO_ EDGE ) ; gl . gl Tex Parameterf (  GL10 .  GL_ TEXTURE_2 D ,  GL10 .  GL_ TEXTURE_ WRAP_ T ,  GL10 .  GL_ CLAMP_ TO_ EDGE ) ; } } if (  DRAW_ TEXTURE && m Texture Page . get Textures Changed ( ) ) { gl . gl Bind Texture (  GL10 .  GL_ TEXTURE_2 D , m Texture Ids [ _ NUM ] ) ;  Bitmap texture = m Texture Page . get Texture ( m Texture Rect Front ,  Curl Page .  SIDE_ FRONT ) ;  GLUtils . tex Image2 D (  GL10 .  GL_ TEXTURE_2 D , _ NUM , texture , _ NUM ) ; texture . recycle ( ) ; m Texture Back = m Texture Page . has Back Texture ( ) ; if ( m Texture Back ) { gl . gl Bind Texture (  GL10 .  GL_ TEXTURE_2 D , m Texture Ids [ _ NUM ] ) ; texture = m Texture Page . get Texture ( m Texture Rect Back ,  Curl Page .  SIDE_ BACK ) ;  GLUtils . tex Image2 D (  GL10 .  GL_ TEXTURE_2 D , _ NUM , texture , _ NUM ) ; texture . recycle ( ) ; } else { m Texture Rect Back . set ( m Texture Rect Front ) ; } m Texture Page . recycle ( ) ; reset ( ) ; } gl . gl Enable Client State (  GL10 .  GL_ VERTEX_ ARRAY ) ; if (  DRAW_ SHADOW ) { gl . gl Disable (  GL10 .  GL_ TEXTURE_2 D ) ; gl . gl Enable (  GL10 .  GL_ BLEND ) ; gl . gl Blend Func (  GL10 .  GL_ SRC_ ALPHA ,  GL10 .  GL_ ONE_ MINUS_ SRC_ ALPHA ) ; gl . gl Enable Client State (  GL10 .  GL_ COLOR_ ARRAY ) ; gl . gl Color Pointer ( _ NUM ,  GL10 .  GL_ FLOAT , _ NUM , m Buf Shadow Colors ) ; gl . gl Vertex Pointer ( _ NUM ,  GL10 .  GL_ FLOAT , _ NUM , m Buf Shadow Vertices ) ; gl . gl Draw Arrays (  GL10 .  GL_ TRIANGLE_ STRIP , _ NUM , m Drop Shadow Count ) ; gl . gl Disable Client State (  GL10 .  GL_ COLOR_ ARRAY ) ; gl . gl Disable (  GL10 .  GL_ BLEND ) ; } if (  DRAW_ TEXTURE ) { gl . gl Enable Client State (  GL10 .  GL_ TEXTURE_ COORD_ ARRAY ) ; gl . gl Tex Coord Pointer ( _ NUM ,  GL10 .  GL_ FLOAT , _ NUM , m Buf Tex Coords ) ; } gl . gl Vertex Pointer ( _ NUM ,  GL10 .  GL_ FLOAT , _ NUM , m Buf Vertices ) ; gl . gl Enable Client State (  GL10 .  GL_ COLOR_ ARRAY ) ; gl . gl Color Pointer ( _ NUM ,  GL10 .  GL_ FLOAT , _ NUM , m Buf Colors ) ; gl . gl Disable (  GL10 .  GL_ TEXTURE_2 D ) ; gl . gl Draw Arrays (  GL10 .  GL_ TRIANGLE_ STRIP , _ NUM , m Vertices Count Front ) ; if (  DRAW_ TEXTURE ) { gl . gl Enable (  GL10 .  GL_ BLEND ) ; gl . gl Enable (  GL10 .  GL_ TEXTURE_2 D ) ; if ( ! m Flip Texture || ! m Texture Back ) { gl . gl Bind Texture (  GL10 .  GL_ TEXTURE_2 D , m Texture Ids [ _ NUM ] ) ; } else { gl . gl Bind Texture (  GL10 .  GL_ TEXTURE_2 D , m Texture Ids [ _ NUM ] ) ; } gl . gl Blend Func (  GL10 .  GL_ SRC_ ALPHA ,  GL10 .  GL_ ONE_ MINUS_ SRC_ ALPHA ) ; gl . gl Draw Arrays (  GL10 .  GL_ TRIANGLE_ STRIP , _ NUM , m Vertices Count Front ) ; gl . gl Disable (  GL10 .  GL_ BLEND ) ; gl . gl Disable (  GL10 .  GL_ TEXTURE_2 D ) ; } int back Start Idx =  Math . max ( _ NUM , m Vertices Count Front - _ NUM ) ; int back Count = m Vertices Count Front + m Vertices Count Back - back Start Idx ; gl . gl Draw Arrays (  GL10 .  GL_ TRIANGLE_ STRIP , back Start Idx , back Count ) ; if (  DRAW_ TEXTURE ) { gl . gl Enable (  GL10 .  GL_ BLEND ) ; gl . gl Enable (  GL10 .  GL_ TEXTURE_2 D ) ; if ( m Flip Texture || ! m Texture Back ) { gl . gl Bind Texture (  GL10 .  GL_ TEXTURE_2 D , m Texture Ids [ _ NUM ] ) ; } else { gl . gl Bind Texture (  GL10 .  GL_ TEXTURE_2 D , m Texture Ids [ _ NUM ] ) ; } gl . gl Blend Func (  GL10 .  GL_ SRC_ ALPHA ,  GL10 .  GL_ ONE_ MINUS_ SRC_ ALPHA ) ; gl . gl Draw Arrays (  GL10 .  GL_ TRIANGLE_ STRIP , back Start Idx , back Count ) ; gl . gl Disable (  GL10 .  GL_ BLEND ) ; gl . gl Disable (  GL10 .  GL_ TEXTURE_2 D ) ; } gl . gl Disable Client State (  GL10 .  GL_ TEXTURE_ COORD_ ARRAY ) ; gl . gl Disable Client State (  GL10 .  GL_ COLOR_ ARRAY ) ; if (  DRAW_ POLYGON_ OUTLINES ) { gl . gl Enable (  GL10 .  GL_ BLEND ) ; gl . gl Blend Func (  GL10 .  GL_ SRC_ ALPHA ,  GL10 .  GL_ ONE_ MINUS_ SRC_ ALPHA ) ; gl . gl Line Width ( _ NUM ) ; gl . gl Color4f ( _ NUM , _ NUM , _ NUM , _ NUM ) ; gl . gl Vertex Pointer ( _ NUM ,  GL10 .  GL_ FLOAT , _ NUM , m Buf Vertices ) ; gl . gl Draw Arrays (  GL10 .  GL_ LINE_ STRIP , _ NUM , m Vertices Count Front ) ; gl . gl Disable (  GL10 .  GL_ BLEND ) ; } if (  DRAW_ CURL_ POSITION ) { gl . gl Enable (  GL10 .  GL_ BLEND ) ; gl . gl Blend Func (  GL10 .  GL_ SRC_ ALPHA ,  GL10 .  GL_ ONE_ MINUS_ SRC_ ALPHA ) ; gl . gl Line Width ( _ NUM ) ; gl . gl Color4f ( _ NUM , _ NUM , _ NUM , _ NUM ) ; gl . gl Vertex Pointer ( _ NUM ,  GL10 .  GL_ FLOAT , _ NUM , m Buf Curl Position Lines ) ; gl . gl Draw Arrays (  GL10 .  GL_ LINES , _ NUM , m Curl Position Lines Count * _ NUM ) ; gl . gl Disable (  GL10 .  GL_ BLEND ) ; } if (  DRAW_ SHADOW ) { gl . gl Enable (  GL10 .  GL_ BLEND ) ; gl . gl Blend Func (  GL10 .  GL_ SRC_ ALPHA ,  GL10 .  GL_ ONE_ MINUS_ SRC_ ALPHA ) ; gl . gl Enable Client State (  GL10 .  GL_ COLOR_ ARRAY ) ; gl . gl Color Pointer ( _ NUM ,  GL10 .  GL_ FLOAT , _ NUM , m Buf Shadow Colors ) ; gl . gl Vertex Pointer ( _ NUM ,  GL10 .  GL_ FLOAT , _ NUM , m Buf Shadow Vertices ) ; gl . gl Draw Arrays (  GL10 .  GL_ TRIANGLE_ STRIP , m Drop Shadow Count , m Self Shadow Count ) ; gl . gl Disable Client State (  GL10 .  GL_ COLOR_ ARRAY ) ; gl . gl Disable (  GL10 .  GL_ BLEND ) ; } gl . gl Disable Client State (  GL10 .  GL_ VERTEX_ ARRAY ) ; }
public static double quantile ( double q , double [ ] x , int [ ] indices ) { if ( q < _ NUM || q > _ NUM ) throw new  Illegal Argument Exception ( _ STR ) ; if ( q == _ NUM ) { return x [ indices [ _ NUM ] ] - _ NUM ; } return x [ indices [ ( int )  Math . ceil ( q * indices . length ) - _ NUM ] ] ; }
private void init Jar (  File local ) {  File jar = new  File (  Command Loader . class Path ( ) ) ; load From Jar ( jar ) ; }
private  String find Vfiler Name (  File Share fs ) {  String port Group = null ;  URI port = fs . get Storage Port ( ) ; if ( port == null ) { _log . info ( _ STR ) ; } else {  Storage Port st Port = _db Client . query Object (  Storage Port . class , port ) ; if ( st Port != null ) {  URI ha Domain Uri = st Port . get Storage HADomain ( ) ; if ( ha Domain Uri == null ) { _log . info ( _ STR , port ) ; } else {  Storage HADomain ha Domain = _db Client . query Object (  Storage HADomain . class , ha Domain Uri ) ; if ( ha Domain != null && ha Domain . get Virtual ( ) == _ BOOL ) { port Group = st Port . get Port Group ( ) ; _log . debug ( _ STR , st Port . get Port Network Id ( ) , port Group ) ; } } } } return port Group ; }
protected void write Iterator (  Output out ,  Iterator <  Object > it ) {  Linked List <  Object > list = new  Linked List <  Object > ( ) ; while ( it . has Next ( ) ) { list . add Last ( it . next ( ) ) ; } out . write Array ( list , this ) ; }
private  Map replace Map Key (  Map attributes ,  Set attribute Names ) { if ( attribute Names != null ) {  Iterator iter = attribute Names . iterator ( ) ; while ( iter . has Next ( ) ) {  String attr Name = (  String ) iter . next ( ) ;  String attr Name Lower = attr Name . to Lower Case ( ) ; if ( attributes . contains Key ( attr Name Lower ) ) {  Object attr Value = attributes . get ( attr Name Lower ) ; attributes . remove ( attr Name Lower ) ; attributes . put ( attr Name , attr Value ) ; } } } return attributes ; }
public void start (  Stage stage ) throws  Exception { stage . set Scene ( new  Scene ( new  My Demo Pane ( ) ) ) ; stage . set Title ( _ STR ) ; stage . set Width ( _ NUM ) ; stage . set Height ( _ NUM ) ; stage . show ( ) ; }
public void test_copy Stream_full Block Plus One ( ) throws  IOException { final  String id = _ STR ; final int version = _ NUM ;  Random r = new  Random ( ) ; final byte [ ] expected = new byte [  BLOCK_ SIZE + _ NUM ] ; r . next Bytes ( expected ) ; assert Equals ( _ STR , expected . length , repo . copy Stream ( id , version , new  Byte Array Input Stream ( expected ) ) ) ; assert Equals ( _ STR , _ NUM , repo . get Block Count ( id , version ) ) ; assert Same Iterator ( _ STR , new  Long [ ] { _ NUM , _ NUM } , repo . blocks ( id , version ) ) ; assert Equals ( _ STR , expected , read ( repo . input Stream ( id , version ) ) ) ; }
public static  DLSocket Address deserialize (  String lock Id ) throws  IOException {  String parts [ ] = lock Id . split (  SEP ) ; if ( _ NUM != parts . length ) { throw new  IOException ( _ STR + lock Id ) ; } int version ; try { version =  Integer . parse Int ( parts [ _ NUM ] ) ; } catch (  Number Format Exception nfe ) { throw new  IOException ( _ STR + lock Id , nfe ) ; } if (  VERSION != version ) { throw new  IOException ( _ STR + version + _ STR + lock Id + _ STR +  VERSION ) ; } int shard Id ; try { shard Id =  Integer . parse Int ( parts [ _ NUM ] ) ; } catch (  Number Format Exception nfe ) { throw new  IOException ( _ STR + lock Id , nfe ) ; }  Inet Socket Address address = parse Socket Address ( parts [ _ NUM ] ) ; return new  DLSocket Address ( shard Id , address ) ; }
protected void request (  Request Context context ,  String key ,  String message ) { try {  Http Servlet Request request = context . get Request ( ) ;  String filename = request . get Remote Addr ( ) ; start ( filename , key , _ STR + request . get Method ( ) + _ STR + request . get Request URI ( ) + _ STR + message ) ; } catch (  Exception e ) { } }
protected  Http URLConnection create Undeploy Connection (  WAR war ) throws  IOException {  String undeploy URL = this . deployer Url + _ STR + war . get Context ( ) ;  URL url = new  URL ( undeploy URL ) ;  Http URLConnection connection = (  Http URLConnection ) url . open Connection ( ) ; connection . set Allow User Interaction ( _ BOOL ) ; connection . set Do Input ( _ BOOL ) ; connection . set Do Output ( _ BOOL ) ; connection . set Use Caches ( _ BOOL ) ; connection . set Do Output ( _ BOOL ) ; connection . set Request Method ( _ STR ) ; if ( this . username != null ) {  String authorization = to Authorization ( this . username , this . password ) ; connection . set Request Property ( _ STR , authorization ) ; } connection . connect ( ) ; return connection ; }
@  Override public void add Handshake Completed Listener (  Handshake Completed Listener listener ) { if ( listener == null ) { throw new  Illegal Argument Exception ( _ STR ) ; } if ( listeners == null ) { listeners = new  Array List <  Handshake Completed Listener > ( ) ; } listeners . add ( listener ) ; }
protected static @  Not Null  String convert Map To Groovy Source ( @  Not Null  Map <  String ,  Object > map ) {  String Builder sb = new  String Builder ( ) ; for (  Map .  Entry <  String ,  Object > entry : map . entry Set ( ) ) { if ( sb . length ( ) > _ NUM ) { sb . append ( _ STR ) ; } sb . append ( entry . get Key ( ) ) ; sb . append ( _ STR ) ; sb . append ( convert Value To Groovy Source ( entry . get Value ( ) ) ) ; } return sb . to String ( ) ; }
@  Override public void add New Subscription ( final  Subscription new Subscription ) { final  String client ID = new Subscription . get Client Id ( ) ;  List <  Client Topic Couple > client Subscriptions = subscriptions . get ( client ID ) ; if ( client Subscriptions == null ) { client Subscriptions = new  Array List < > ( ) ; subscriptions . put ( client ID , client Subscriptions ) ; } client Subscriptions . add ( new Subscription . as Client Topic Couple ( ) ) ; }
private static int modifier Description To Reflected Type (  String name ,  String key ,  String value ) { switch ( key ) { case  MODIFIER_ ABSTRACT : return value . equals ( _ STR ) ?  Modifier .  ABSTRACT : _ NUM ; case  MODIFIER_ FINAL : return value . equals ( _ STR ) ?  Modifier .  FINAL : _ NUM ; case  MODIFIER_ NATIVE : return value . equals ( _ STR ) ?  Modifier .  NATIVE : _ NUM ; case  MODIFIER_ STATIC : return value . equals ( _ STR ) ?  Modifier .  STATIC : _ NUM ; case  MODIFIER_ SYNCHRONIZED : return value . equals ( _ STR ) ?  Modifier .  SYNCHRONIZED : _ NUM ; case  MODIFIER_ TRANSIENT : return value . equals ( _ STR ) ?  Modifier .  TRANSIENT : _ NUM ; case  MODIFIER_ VOLATILE : return value . equals ( _ STR ) ?  Modifier .  VOLATILE : _ NUM ; case  MODIFIER_ VISIBILITY : switch ( value ) { case  MODIFIER_ PRIVATE : throw new  Runtime Exception ( _ STR + name ) ; case  MODIFIER_ PROTECTED : return  Modifier .  PROTECTED ; case  MODIFIER_ PUBLIC : return  Modifier .  PUBLIC ; case _ STR : return _ NUM ; default : throw new  Runtime Exception ( _ STR + value ) ; } } return _ NUM ; }
private final boolean use Sync Writes ( boolean force Async ) { if ( force Async ) { return _ BOOL ; } if ( this . async Queuing In Progress ) { return _ BOOL ; } if ( this . is Receiver ) { return _ BOOL ; } if ( ! this . preserve Order ) { return _ BOOL ; } if ( this . async Distribution Timeout == _ NUM ) { return _ BOOL ; } return _ BOOL ; }
protected  Light Icon add Light ( ) {  Light Icon l = new  Light Icon ( this ) ;  Icon Adder editor = get Icon Editor ( _ STR ) ; l . set Off Icon ( editor . get Icon ( _ STR ) ) ; l . set On Icon ( editor . get Icon ( _ STR ) ) ; l . set Inconsistent Icon ( editor . get Icon ( _ STR ) ) ; l . set Unknown Icon ( editor . get Icon ( _ STR ) ) ; l . set Light ( (  Light ) editor . get Table Selection ( ) ) ; l . set Display Level (  LIGHTS ) ; set Next Location ( l ) ; put Item ( l ) ; return l ; }
private void draw Zoom Rectangle (  Graphics2 D g2 , boolean xor ) { if ( this . zoom Rectangle != null ) { if ( xor ) { g2 . set XORMode (  Color . gray ) ; } if ( this . fill Zoom Rectangle ) { g2 . set Paint ( this . zoom Fill Paint ) ; g2 . fill ( this . zoom Rectangle ) ; } else { g2 . set Paint ( this . zoom Outline Paint ) ; g2 . draw ( this . zoom Rectangle ) ; } if ( xor ) { g2 . set Paint Mode ( ) ; } } }
public  Conversion Exception (  Throwable cause ) { super ( cause . get Message ( ) ) ; this . cause = cause ; }
protected void process Initiators (  Export Group export Group ,  Collection <  Initiator > initiators ,  Collection <  String > port Names ,  Map <  String ,  URI > port Name To Initiator URI ,  Collection <  URI > host URIs ,  List Multimap <  String ,  String > compute Resource To Port Names ) { for (  Initiator initiator : initiators ) {  String normalized Name =  Initiator . normalize Port ( initiator . get Initiator Port ( ) ) ; port Names . add ( normalized Name ) ; port Name To Initiator URI . put ( normalized Name , initiator . get Id ( ) ) ; if ( host URIs != null ) { if ( !  Null Column Value Getter . is Null URI ( initiator . get Host ( ) ) && ! host URIs . contains ( initiator . get Host ( ) ) ) { host URIs . add ( initiator . get Host ( ) ) ; } } if ( compute Resource To Port Names != null ) {  String compute Resource Id ; if ( export Group != null && export Group . for Cluster ( ) ) { compute Resource Id = initiator . get Cluster Name ( ) ; } else {  URI host URI = initiator . get Host ( ) ; if ( host URI == null ) { host URI =  Null Column Value Getter . get Null URI ( ) ; } compute Resource Id = host URI . to String ( ) ; } compute Resource To Port Names . put ( compute Resource Id , normalized Name ) ; } } }
private  List <  Rich Translation <  TK ,  FV > > standard Nbest (  Beam <  Derivation <  TK ,  FV > > beam ,  Recombination History <  Derivation <  TK ,  FV > > recombination History ,  Input Properties source Input Properties , int source Input Id ,  List <  Sequence <  TK > > targets ,  Output Space <  TK ,  FV > output Space , int size , boolean distinct ) {  List <  Derivation <  TK ,  FV > > goal States = new  Array List < > ( beam . size ( ) ) ; for (  Derivation <  TK ,  FV > derivation : beam ) goal States . add ( derivation ) ; final  State Lattice Decoder <  Derivation <  TK ,  FV > > lattice Decoder = new  State Lattice Decoder < > ( goal States , recombination History ) ; final boolean prefix Decoding = source Input Properties . contains Key (  Input Property .  Target Prefix ) ; final boolean prefix Diversity = distinct && prefix Decoding ; final  Sequence <  TK > prefix = prefix Decoding ? targets . get ( _ NUM ) : null ; final  Set <  Sequence <  TK > > distinct Surface Translations = distinct ? new  Hash Set < > ( size ) : null ; final  List <  Rich Translation <  TK ,  FV > > translations = new  Array List < > ( size ) ; int num Extracted = _ NUM ; long nbest Id = _ NUM ; for (  List <  Derivation <  TK ,  FV > > lattice Path : lattice Decoder ) { ++ num Extracted ; if ( num Extracted >  MAX_ POPPED_ ITEMS ) break ; if ( distinct ) {  Sequence <  TK > path Target = extract Target ( lattice Path ) ; if ( prefix Diversity ) { int start = prefix . size ( ) ; int end =  Math . min ( path Target . size ( ) , prefix . size ( ) +  PREFIX_ DIVERSITY_ SIZE ) ; if ( start < end ) path Target = path Target . subsequence ( start , end ) ; } if ( distinct Surface Translations . contains ( path Target ) ) continue ; distinct Surface Translations . add ( path Target ) ; } boolean with DTUs = _ BOOL ; final  Set <  Rule <  TK > > seen Options = new  Hash Set < > ( ) ;  Derivation <  TK ,  FV > goal Hyp = null ; for (  Derivation <  TK ,  FV > node : lattice Path ) { if ( goal Hyp == null ) { goal Hyp = node ; continue ; } with DTUs = with DTUs || node . rule . abstract Rule instanceof  DTURule ; goal Hyp = with DTUs ? new  DTUHypothesis < > ( source Input Id , node . rule , goal Hyp . length , goal Hyp , node , featurizer , scorer , heuristic , seen Options , output Space ) : new  Derivation < > ( source Input Id , node . rule , goal Hyp . length , goal Hyp , featurizer , scorer , heuristic , output Space ) ; } if ( goal Hyp == null || goal Hyp . featurizable == null ) { logger . warn ( _ STR , source Input Id ) ; return null ; } if ( with DTUs ) {  DTUHypothesis <  TK ,  FV > dtu Hyp = (  DTUHypothesis <  TK ,  FV > ) goal Hyp ; if ( ! dtu Hyp . is Done ( ) || dtu Hyp . has Expired ( ) ) logger . warn ( _ STR , translations . size ( ) , dtu Hyp . has Expired ( ) , goal Hyp ) ; }  Rich Translation <  TK ,  FV > t = new  Rich Translation < > ( goal Hyp . featurizable , goal Hyp . score ,  Feature Values . combine ( goal Hyp ) , nbest Id ++ ) ; translations . add ( t ) ; if ( translations . size ( ) >= size ) break ; }  Collections . sort ( translations , translation Comparator ) ; logger . info ( _ STR , source Input Id , num Extracted , lattice Decoder . max Agenda Size ) ; return translations ; }
public void test Negate Math Context Positive ( ) {  String a = _ STR ; int a Scale = _ NUM ; int precision = _ NUM ;  Rounding Mode rm =  Rounding Mode .  FLOOR ;  Math Context mc = new  Math Context ( precision , rm ) ;  String c = _ STR ; int c Scale = _ NUM ;  Big Decimal a Number = new  Big Decimal ( new  Big Integer ( a ) , a Scale ) ;  Big Decimal res = a Number . negate ( mc ) ; assert Equals ( _ STR , c , res . to String ( ) ) ; assert Equals ( _ STR , c Scale , res . scale ( ) ) ; }
private static  IAbstract Node convert And ( final  Common Tree ast ) throws  Recognition Exception { final  List <  IAbstract Node > children = new  Array List <  IAbstract Node > ( ) ; for ( final  Object child Object : ast . get Children ( ) ) { children . add ( convert ( (  Common Tree ) child Object ) ) ; } return new  CAbstract And Expression ( children ) ; }
@  Override public void run ( ) { am IActive = _ BOOL ; panel = new  Coordinate Transform Dialog ( my Host ) ; if ( my Host instanceof  JFrame ) {  JDialog dialog = new  JDialog ( (  JFrame ) my Host , _ STR , _ BOOL ) ;  Container content Pane = dialog . get Content Pane ( ) ; content Pane . add ( panel ,  Border Layout .  CENTER ) ; dialog . set Default Close Operation (  JFrame .  DISPOSE_ ON_ CLOSE ) ; dialog . pack ( ) ; dialog . set Location Relative To ( null ) ; dialog . set Visible ( _ BOOL ) ; } else {  JFrame frame = new  JFrame ( _ STR ) ;  Container content Pane = frame . get Content Pane ( ) ; content Pane . add ( panel ,  Border Layout .  CENTER ) ; frame . set Default Close Operation (  JFrame .  DISPOSE_ ON_ CLOSE ) ; frame . pack ( ) ; frame . set Location Relative To ( null ) ; frame . set Visible ( _ BOOL ) ; } }
public  Builder add Token Filter (  Class < ? extends  Token Filter Factory > factory ,  Map <  String ,  String > params ) throws  IOException {  Objects . require Non Null ( factory , _ STR ) ; token Filters . add ( apply Resource Loader ( new Factory Class Instance ( factory , apply Default Params ( params ) ) ) ) ; components Added = _ BOOL ; return this ; }
public void update ( int fps , float angle ) { double speed = (  SPEED /  FPS ) *  Math . log ( radius ) ; y -= speed ; x += amp *  Math . sin ( freq * ( step ++ * speed ) ) + skew ; if ( radius < max Radius ) { radius += max Radius / ( ( ( float ) fps /  SPEED ) * radius ) ; if ( radius > max Radius ) radius = max Radius ; } }
private void display Changed ( ) { clock . set12 Hour Display ( display Check Box . is Selected ( ) , _ BOOL ) ; changed = _ BOOL ; }
public  String to String Rfc3339 ( ) {  String Builder sb = new  String Builder ( ) ;  Calendar date Time = new  Gregorian Calendar (  GMT ) ; long local Time = value + ( tz Shift * _ NUM ) ; date Time . set Time In Millis ( local Time ) ; append Int ( sb , date Time . get (  Calendar .  YEAR ) , _ NUM ) ; sb . append ( _ STR ) ; append Int ( sb , date Time . get (  Calendar .  MONTH ) + _ NUM , _ NUM ) ; sb . append ( _ STR ) ; append Int ( sb , date Time . get (  Calendar .  DAY_ OF_ MONTH ) , _ NUM ) ; if ( ! date Only ) { sb . append ( _ STR ) ; append Int ( sb , date Time . get (  Calendar .  HOUR_ OF_ DAY ) , _ NUM ) ; sb . append ( _ STR ) ; append Int ( sb , date Time . get (  Calendar .  MINUTE ) , _ NUM ) ; sb . append ( _ STR ) ; append Int ( sb , date Time . get (  Calendar .  SECOND ) , _ NUM ) ; if ( date Time . is Set (  Calendar .  MILLISECOND ) ) { sb . append ( _ STR ) ; append Int ( sb , date Time . get (  Calendar .  MILLISECOND ) , _ NUM ) ; } if ( tz Shift == _ NUM ) { sb . append ( _ STR ) ; } else { int abs Tz Shift = tz Shift ; if ( tz Shift > _ NUM ) { sb . append ( _ STR ) ; } else { sb . append ( _ STR ) ; abs Tz Shift = - abs Tz Shift ; } int tz Hours = abs Tz Shift / _ NUM ; int tz Minutes = abs Tz Shift % _ NUM ; append Int ( sb , tz Hours , _ NUM ) ; sb . append ( _ STR ) ; append Int ( sb , tz Minutes , _ NUM ) ; } } return sb . to String ( ) ; }
private static  Class register Type Mapping (  RPCServer server ,  Class clazz ) { java . lang . reflect .  Method [ ] methods = clazz . get Methods ( ) ; java . lang . reflect .  Method method ;  Class [ ] params ; for ( int i = _ NUM ; i < methods . length ; i ++ ) { method = methods [ i ] ; if ( method . get Declaring Class ( ) == clazz ) { _register Type Mapping ( server , method . get Return Type ( ) ) ; params = method . get Parameter Types ( ) ; for ( int y = _ NUM ; y < params . length ; y ++ ) { _register Type Mapping ( server , params [ y ] ) ; } } } return clazz ; }
@  Override public void create Redis App Key (  Application application ,  String docker Manager IP ,  String server Port ,  String server Manager Port ) {  String suffix Cloud Unit = application . get Suffix Cloud Unit IO ( ) ;  Jedis Pool pool = null ;  Jedis jedis = null ; try { pool = new  Jedis Pool ( new  Jedis Pool Config ( ) , redis Ip ,  Integer . parse Int ( redis Port ) , _ NUM ) ; jedis = pool . get Resource ( ) ;  String sub Name Space = concat Sub Name Space ( application ) ;  String key = sub Name Space + suffix Cloud Unit ;  String frontend = _ STR + key . to Lower Case ( ) ; jedis . rpush ( frontend , key . to Lower Case ( ) ) ; jedis . rpush ( frontend , _ STR + docker Manager IP + _ STR + server Port ) ;  String frontend Server Manager = _ STR + key . to Lower Case ( ) ; jedis . rpush ( frontend Server Manager , key . to Lower Case ( ) ) ; jedis . rpush ( frontend Server Manager , _ STR + docker Manager IP + _ STR + server Manager Port ) ; } catch (  Jedis Connection Exception |  Unsupported Encoding Exception e ) { logger . error ( _ STR , e ) ; } finally { if ( jedis != null ) { pool . destroy ( ) ; } } }
public  Kml Feature remove Item ( int item Position ) { return m Items . remove ( item Position ) ; }
private static  List <  List <  Trace Register > > load Trace Event Values ( final  CConnection connection , final  Trace List trace List ) throws  SQLException { final  List <  List <  Trace Register > > values = new  Array List < > ( ) ; final  String query = _ STR +  CTable Names .  TRACE_ EVENT_ VALUES_ TABLE + _ STR + trace List . get Id ( ) + _ STR ; final  Result Set result Set = connection . execute Query ( query , _ BOOL ) ; int current Position = - _ NUM ; try {  List <  Trace Register > registers = new  Array List <  Trace Register > ( ) ; while ( result Set . next ( ) ) { final int position = result Set . get Int ( _ STR ) ; if ( position != current Position ) { if ( ! registers . is Empty ( ) ) { values . add (  Lists . new Array List ( registers ) ) ; registers = new  Filled List <  Trace Register > ( ) ; } current Position = position ; } final  String name =  Postgre SQLHelpers . read String ( result Set , _ STR ) ; final long value = result Set . get Long ( _ STR ) ; final byte [ ] memory = result Set . get Bytes ( _ STR ) ; registers . add ( new  Trace Register ( name , new  CAddress ( value ) , memory ) ) ; } if ( ! registers . is Empty ( ) ) { values . add (  Lists . new Array List ( registers ) ) ; } } finally { result Set . close ( ) ; } return values ; }
protected boolean handle Remote Event (  Event Context pc ) {  Event event = pc . get Event ( ) ; boolean for Us = _ BOOL ;  String destination = event . to ( ) ; if ( destination != null ) { for Us = destination . equals ( get Id ( ) ) ; if ( ! for Us ) { forward To ( event , destination ) ; } } else {  Set <  String > forward To = event . get Forward To ( ) ; if ( ! forward To . is Empty ( ) ) { for Us = forward To . remove ( get Id ( ) ) ; if ( forward To . size ( ) > _ NUM ) { forward To ( event , forward To ) ; } } else { for Us = _ BOOL ; } } return for Us ; }
public  Storage Pool select Pool (  List <  Storage Pool > pool List ) { if ( pool List == null || pool List . is Empty ( ) ) { return null ; } _port Metrics Processor . compute Storage Pools Avg Port Metrics ( pool List ) ;  Collections . sort ( pool List , _storage Pool Comparator ) ; return pool List . get ( _ NUM ) ; }
public void select Next Overlay ( ) { if ( m Current Overlay Index ==  NO_ OVERLAY ) { if ( m Overlays . is Empty ( ) ) { return ; } m Current Overlay Index = _ NUM ; } else { m Current Overlay Index = ++ m Current Overlay Index % m Overlays . size ( ) ; if ( m Current Overlay Index == _ NUM ) { m Current Overlay Index =  NO_ OVERLAY ; } } do Set Overlay ( get Current Overlay ( ) ) ; }
public static  String create Ignore Pattern For Resource ( final  IResource resource ) {  Check . not Null ( resource , _ STR ) ; final  String path =  TPIgnore Cache . create Resource Match String ( resource ) ;  String pattern String =  Pattern . quote ( path ) ; if ( resource . get Type ( ) ==  IResource .  FOLDER || resource . get Type ( ) ==  IResource .  PROJECT ) { pattern String = pattern String + _ STR ; } return pattern String ; }
@  Override protected boolean accept (  String property Value ) { int major ; int minor ;  Matcher matcher =  MAJOR_ MINOR_ VERSION_ PATTERN . matcher ( property Value ) ; if ( matcher . matches ( ) ) { major =  Integer . parse Int ( matcher . group ( _ NUM ) ) ; minor =  Integer . parse Int ( matcher . group ( _ NUM ) ) ; } else { throw new  Runtime Exception ( _ STR + property Value + _ STR ) ; } return unicode Version . major Version > major || ( unicode Version . major Version == major && unicode Version . minor Version >= minor ) ; }
@  Override public  Enumeration <  Option > list Options ( ) {  Vector <  Option > new Vector = new  Vector <  Option > ( _ NUM ) ; new Vector . add Element ( new  Option ( _ STR , _ STR , _ NUM , _ STR ) ) ; new Vector . add Element ( new  Option ( _ STR , _ STR , _ NUM , _ STR ) ) ; new Vector . add Element ( new  Option ( _ STR , _ STR , _ NUM , _ STR ) ) ; new Vector . add Element ( new  Option ( _ STR , _ STR , _ NUM , _ STR ) ) ; new Vector . add All (  Collections . list ( super . list Options ( ) ) ) ; return new Vector . elements ( ) ; }
public static  String python Escape (  String s ) {  String Builder sb = new  String Builder ( ) ; for ( int i = _ NUM ; i < s . length ( ) ; i ++ ) { char c = s . char At ( i ) ; switch ( c ) { case _ STR : sb . append ( _ STR ) ; break ; case _ STR : sb . append ( _ STR ) ; break ; case _ STR : sb . append ( _ STR ) ; break ; case _ STR : sb . append ( _ STR ) ; break ; case _ STR : sb . append ( _ STR ) ; break ; case _ STR : sb . append ( _ STR ) ; break ; default : sb . append ( c ) ; } } return sb . to String ( ) ; }
private void convergence Step ( final  Vec [ ] xit , int i , final boolean [ ] converged , final int [ ] designations , final  Vec scratch , final  Kernel Function k ) { double denom = _ NUM ;  Vec x Cur = xit [ i ] ;  List < ? extends  Vec Paired <  Vec Paired <  Vec ,  Integer > ,  Double > > contrib = mkde . get Nearby Raw ( x Cur ) ; if ( contrib . size ( ) == _ NUM ) { converged [ i ] = _ BOOL ; designations [ i ] = - _ NUM ; } else { scratch . zero Out ( ) ; for (  Vec Paired <  Vec Paired <  Vec ,  Integer > ,  Double > v : contrib ) { double g = - k . k Prime ( v . get Pair ( ) ) ; denom += g ; scratch . mutable Add ( g , v ) ; } scratch . mutable Divide ( denom ) ; if (  Math . abs ( scratch . p Norm Dist ( _ NUM , x Cur ) ) < _ NUM ) converged [ i ] = _ BOOL ; scratch . copy To ( x Cur ) ; } }
public  Pid File ( final  File directory , final  String filename ) throws  File Not Found Exception { if ( ! directory . is Directory ( ) && directory . exists ( ) ) { throw new  Illegal Argument Exception ( _ STR + directory + _ STR ) ; } final  File file = new  File ( directory , filename ) ; if ( ! file . exists ( ) || file . is Directory ( ) ) { throw new  File Not Found Exception ( _ STR + filename + _ STR + directory ) ; } this . pid File = file ; }
public static boolean compare Results (  Solr Server control Server ,  Solr Server cloud Server ) throws  Solr Server Exception { return compare Results ( control Server , cloud Server , null , null ) ; }
public  String  Get Element Attr (  String x Path Expression ) { try { org . jdom .  Attribute node = (  Attribute )  XPath . select Single Node ( this . xml Document , x Path Expression ) ; return node . get Value ( ) ; } catch (  Exception ex ) {  LOG . error ( _ STR + ex . get Message ( ) , ex ) ; return _ STR ; } }
private void build Lookup Table ( ) { final  Set <  Integer > seen_child_ids = new  Hash Set < > ( ) ;  Trie previous_trie = null ; boolean first = _ BOOL ; for ( final  Trie trie : this . tries ) { if ( ! first ) { if ( ! have Same Source Side ( previous_trie , trie ) || ! have Same Arity ( previous_trie , trie ) ) { throw new  Runtime Exception ( _ STR ) ; } } else { first = _ BOOL ; } previous_trie = trie ; if ( trie . has Rules ( ) ) { if ( trie With Rules != null ) { throw new  Runtime Exception ( _ STR ) ; } trie With Rules = trie ; } final  Hash Map <  Integer , ? extends  Trie > children = trie . get Children ( ) ; for ( int id : children . key Set ( ) ) { if ( seen_child_ids . contains ( id ) ) { throw new  Runtime Exception ( _ STR ) ; } seen_child_ids . add ( id ) ; lookup . put ( id , children . get ( id ) ) ; } } }
private void expand Tree ( ) { if ( tree Expand . is Selected ( ) ) { for ( int row = _ NUM ; row < tree . get Row Count ( ) ; row ++ ) tree . expand Row ( row ) ; } else { for ( int row = tree . get Row Count ( ) ; row > _ NUM ; row -- ) tree . collapse Row ( row ) ; } }
@  Suppress Warnings ( _ STR ) private static void replace Player Cape (  Abstract Client Player player ) { final  String display Name = player . get Display Name String ( ) ; final  Network Player Info player Info ; try { player Info = (  Network Player Info )  GET_ PLAYER_ INFO . invoke Exact ( player ) ; } catch (  Throwable throwable ) {  Logger . fatal ( throwable , _ STR , display Name ) ; return ; } if ( player Info == null ) {  Logger . fatal ( _ STR , display Name ) ; return ; } final  Map <  Minecraft Profile Texture .  Type ,  Resource Location > player Textures ; try { player Textures = (  Map <  Minecraft Profile Texture .  Type ,  Resource Location > )  GET_ PLAYER_ TEXTURES . invoke Exact ( player Info ) ; } catch (  Throwable throwable ) {  Logger . fatal ( throwable , _ STR , display Name ) ; return ; } player Textures . put (  Minecraft Profile Texture .  Type .  CAPE ,  CAPE_ LOCATION ) ;  Logger . info ( _ STR , display Name ) ; }
public void remove Vetoable Change Listener (  String property Name ,  Vetoable Change Listener listener ) { if ( listener != null ) { synchronized ( this ) { if ( vetoable Support != null ) { vetoable Support . remove Vetoable Change Listener ( property Name , listener ) ; } } } }
public  String finished (  Logger log ) { if ( m_av Insts Per Sec == _ NUM ) { compute Update (  System . current Time Millis ( ) ) ; } int n S = m_num Samples > _ NUM ? m_num Samples : _ NUM ;  String msg = _ STR + m_instance Count + _ STR + m_av Insts Per Sec / n S + _ STR ; if ( log != null ) { log . status Message ( m_status Message Prefix + msg ) ; } return msg ; }
protected void parse Command ( final  String ... args ) { if ( args != null ) { for (  String arg : args ) {  Command command =  Command . value Of Name ( arg ) ; if ( command != null ) { set Command ( command ) ; break ; } } } }
@  Request Mapping ( method =  Request Method .  POST )  Response Entity <  Bookmark > add Bookmark ( @  Path Variable ( value = _ STR )  String username , @  Request Body  Bookmark bookmark ) throws  User Not Found Exception {  Optional <  User > optional = users Repository . find By Username ( username ) ; if ( optional . is Present ( ) ) {  User user = optional . get ( ) ; user . add Bookmark ( bookmark ) ; bookmark . set User ( user ) ; bookmarks Repository . save ( bookmark ) ; return new  Response Entity < > ( bookmark ,  Http Status .  CREATED ) ; } else { throw new  User Not Found Exception ( username ) ; } }
static int [ ] find Nanp Phone Numbers (  Char Sequence text ) {  Array List <  Integer > list = new  Array List <  Integer > ( ) ; int start Pos = _ NUM ; int end Pos = text . length ( ) -  NANP_ MIN_ DIGITS + _ NUM ; if ( end Pos < _ NUM ) { return new int [ ] { } ; } while ( start Pos < end Pos ) { while (  Character . is Whitespace ( text . char At ( start Pos ) ) && start Pos < end Pos ) { start Pos ++ ; } if ( start Pos == end Pos ) { break ; } int match End = find Nanp Match End ( text , start Pos ) ; if ( match End > start Pos ) { list . add ( start Pos ) ; list . add ( match End ) ; start Pos = match End ; } else { while ( !  Character . is Whitespace ( text . char At ( start Pos ) ) && start Pos < end Pos ) { start Pos ++ ; } } } int [ ] result = new int [ list . size ( ) ] ; for ( int i = list . size ( ) - _ NUM ; i >= _ NUM ; i -- ) { result [ i ] = list . get ( i ) ; } return result ; }
private static void draw Table Layout Guidelines (  View Transform transform ,  Graphics2 D g ,  Constraint Table Layout table ) {  Graphics2 D g2 = (  Graphics2 D ) g . create ( ) ;  Array List <  Guideline > vertical = table . get Vertical Guidelines ( ) ;  Array List <  Guideline > horizontal = table . get Horizontal Guidelines ( ) ; g2 . set Stroke (  Snap Draw . s Thin Dashed Stroke ) ; int l = transform . get Swing X ( table . get Draw X ( ) ) ; int t = transform . get Swing Y ( table . get Draw Y ( ) ) ; int r = transform . get Swing X ( table . get Draw X ( ) + table . get Draw Width ( ) ) ; int b = transform . get Swing Y ( table . get Draw Y ( ) + table . get Draw Height ( ) ) ; for (  Constraint Widget v : vertical ) { int x = transform . get Swing X ( v . get X ( ) ) + l ; g2 . draw Line ( x , t , x , b ) ; } for (  Constraint Widget h : horizontal ) { int y = transform . get Swing Y ( h . get Y ( ) ) + t ; g2 . draw Line ( l , y , r , y ) ; } g2 . dispose ( ) ; }
public  String to String ( ) {  Object target = get Target ( ) ;  String method Name = get Method Name ( ) ;  Object [ ] arguments = get Arguments ( ) ; if ( arguments == null ) { arguments = empty Array ; }  String Buffer result = new  String Buffer ( instance Name ( target ) + _ STR + method Name + _ STR ) ; int n = arguments . length ; for ( int i = _ NUM ; i < n ; i ++ ) { result . append ( instance Name ( arguments [ i ] ) ) ; if ( i != n - _ NUM ) { result . append ( _ STR ) ; } } result . append ( _ STR ) ; return result . to String ( ) ; }
int find End Text (  String source , int ofs ) { for ( int i = ofs ; i < source . length ( ) ; i ++ ) { if ( is Alpha ( source . char At ( i ) ) == _ BOOL && is Numeric ( source . char At ( i ) ) == _ BOOL ) { return i ; } } return - _ NUM ; }
private void process Input ( boolean end Of Input ) throws  IOException { decoder In . flip ( ) ;  Coder Result coder Result ; while ( _ BOOL ) { coder Result = decoder . decode ( decoder In , decoder Out , end Of Input ) ; if ( coder Result . is Overflow ( ) ) { flush Output ( ) ; } else if ( coder Result . is Underflow ( ) ) { break ; } else { throw new  IOException ( _ STR ) ; } } decoder In . compact ( ) ; }
public static  Prototype intern (  String descriptor ) { if ( descriptor == null ) { throw new  Null Pointer Exception ( _ STR ) ; }  Prototype result ; synchronized ( intern Table ) { result = intern Table . get ( descriptor ) ; } if ( result != null ) { return result ; }  Type [ ] params = make Parameter Array ( descriptor ) ; int param Count = _ NUM ; int at = _ NUM ; for ( ; ; ) { int start At = at ; char c = descriptor . char At ( at ) ; if ( c == _ STR ) { at ++ ; break ; } while ( c == _ STR ) { at ++ ; c = descriptor . char At ( at ) ; } if ( c == _ STR ) { int end At = descriptor . index Of ( _ STR , at ) ; if ( end At == - _ NUM ) { throw new  Illegal Argument Exception ( _ STR ) ; } at = end At + _ NUM ; } else { at ++ ; } params [ param Count ] =  Type . intern ( descriptor . substring ( start At , at ) ) ; param Count ++ ; }  Type return Type =  Type . intern Return Type ( descriptor . substring ( at ) ) ;  Std Type List parameter Types = new  Std Type List ( param Count ) ; for ( int i = _ NUM ; i < param Count ; i ++ ) { parameter Types . set ( i , params [ i ] ) ; } result = new  Prototype ( descriptor , return Type , parameter Types ) ; return put Intern ( result ) ; }
public void add Point ( final  T point ) { points . add ( point ) ; }
private void load Org Access Add (  Array List <  Org Access > list ,  Org Access oa ) { if ( list . contains ( oa ) ) return ; list . add ( oa ) ; if ( get AD_ Tree_ Org_ ID ( ) == _ NUM ) return ;  MOrg org =  MOrg . get ( get Ctx ( ) , oa .  AD_ Org_ ID ) ; if ( ! org . is Summary ( ) ) return ;  MTree_ Base tree =  MTree_ Base . get ( get Ctx ( ) , get AD_ Tree_ Org_ ID ( ) , get_ Trx Name ( ) ) ;  String sql = _ STR + _ STR + tree . get Node Table Name ( ) + _ STR ;  Prepared Statement pstmt = null ;  Result Set rs = null ; try { pstmt =  DB . prepare Statement ( sql , get_ Trx Name ( ) ) ; pstmt . set Int ( _ NUM , tree . get AD_ Tree_ ID ( ) ) ; pstmt . set Int ( _ NUM , org . get AD_ Org_ ID ( ) ) ; rs = pstmt . execute Query ( ) ; while ( rs . next ( ) ) { int  AD_ Client_ ID = rs . get Int ( _ NUM ) ; int  AD_ Org_ ID = rs . get Int ( _ NUM ) ; load Org Access Add ( list , new  Org Access (  AD_ Client_ ID ,  AD_ Org_ ID , oa . read Only ) ) ; } } catch (  Exception e ) { log . log (  Level .  SEVERE , sql , e ) ; } finally {  DB . close ( rs , pstmt ) ; rs = null ; pstmt = null ; } }
public void test Incremental Pojo Reading ( ) throws  IOException {  Json Factory jf = new  Mapping Json Factory ( ) ; final  String  JSON = _ STR ;  Json Parser jp = jf . create Json Parser ( new  String Reader (  JSON ) ) ; assert Token (  Json Token .  START_ ARRAY , jp . next Token ( ) ) ; assert Token (  Json Token .  VALUE_ NUMBER_ INT , jp . next Token ( ) ) ; assert Equals (  Integer . value Of ( _ NUM ) , jp . read Value As (  Integer . class ) ) ; assert Equals (  Boolean .  TRUE , jp . read Value As (  Boolean . class ) ) ; assert Null ( jp . read Value As (  Object . class ) ) ; assert Equals (  Json Token .  VALUE_ NULL , jp . get Last Cleared Token ( ) ) ; assert Equals ( _ STR , jp . read Value As (  String . class ) ) ; assert Null ( jp . read Value As (  Object . class ) ) ; assert Equals (  Json Token .  END_ ARRAY , jp . get Last Cleared Token ( ) ) ; assert Null ( jp . next Token ( ) ) ; jp . close ( ) ; }
public static  String to Pretty String (  Object value ) { if ( value == null ) { return  String Pool .  NULL ; }  Class < ? > type = value . get Class ( ) ; if ( type . is Array ( ) ) {  Class component Type = type . get Component Type ( ) ; if ( component Type . is Primitive ( ) ) {  String Builder sb = new  String Builder ( ) ; sb . append ( _ STR ) ; if ( component Type == int . class ) { sb . append (  Arrays Util . to String ( ( int [ ] ) value ) ) ; } else if ( component Type == long . class ) { sb . append (  Arrays Util . to String ( ( long [ ] ) value ) ) ; } else if ( component Type == double . class ) { sb . append (  Arrays Util . to String ( ( double [ ] ) value ) ) ; } else if ( component Type == float . class ) { sb . append (  Arrays Util . to String ( ( float [ ] ) value ) ) ; } else if ( component Type == boolean . class ) { sb . append (  Arrays Util . to String ( ( boolean [ ] ) value ) ) ; } else if ( component Type == short . class ) { sb . append (  Arrays Util . to String ( ( short [ ] ) value ) ) ; } else if ( component Type == byte . class ) { sb . append (  Arrays Util . to String ( ( byte [ ] ) value ) ) ; } else { throw new  Illegal Argument Exception ( ) ; } sb . append ( _ STR ) ; return sb . to String ( ) ; } else {  String Builder sb = new  String Builder ( ) ; sb . append ( _ STR ) ;  Object [ ] array = (  Object [ ] ) value ; for ( int i = _ NUM ; i < array . length ; i ++ ) { if ( i > _ NUM ) { sb . append ( _ STR ) ; } sb . append ( to Pretty String ( array [ i ] ) ) ; } sb . append ( _ STR ) ; return sb . to String ( ) ; } } else if ( value instanceof  Iterable ) {  Iterable iterable = (  Iterable ) value ;  String Builder sb = new  String Builder ( ) ; sb . append ( _ STR ) ; int i = _ NUM ; for (  Object o : iterable ) { if ( i > _ NUM ) { sb . append ( _ STR ) ; } sb . append ( to Pretty String ( o ) ) ; i ++ ; } sb . append ( _ STR ) ; return sb . to String ( ) ; } return value . to String ( ) ; }
@  Override public  List <  Period > generate Rolling Periods (  Date Time Unit date Time Unit ) {  Calendar cal = get Calendar ( ) ; date Time Unit . set Day ( _ NUM ) ; date Time Unit = cal . minus Months ( date Time Unit , ( date Time Unit . get Month ( ) % _ NUM ) + _ NUM ) ;  List <  Period > periods =  Lists . new Array List ( ) ; for ( int i = _ NUM ; i < _ NUM ; i ++ ) { periods . add ( create Period ( date Time Unit , cal ) ) ; date Time Unit = cal . plus Months ( date Time Unit , _ NUM ) ; } return periods ; }
protected boolean can Paths Be Removed (  Tree Path [ ] paths ) { if ( row Mapper == null || selection == null || selection Mode ==  Tree Selection Model .  DISCONTIGUOUS_ TREE_ SELECTION ) return _ BOOL ; else {  Bit Set bit Set = new  Bit Set ( ) ; int counter ; int path Count = paths . length ; int an Index ; int min = - _ NUM ; int valid Count = _ NUM ;  Tree Path [ ] temp Path = new  Tree Path [ _ NUM ] ; int [ ] rows ; last Paths . clear ( ) ; for ( counter = _ NUM ; counter < path Count ; counter ++ ) { if ( paths [ counter ] != null ) { last Paths . put ( paths [ counter ] ,  Boolean .  TRUE ) ; } } for ( counter = selection . length - _ NUM ; counter >= _ NUM ; counter -- ) { if ( last Paths . get ( selection [ counter ] ) == null ) { temp Path [ _ NUM ] = selection [ counter ] ; rows = row Mapper . get Rows For Paths ( temp Path ) ; if ( rows != null && rows [ _ NUM ] != - _ NUM && ! bit Set . get ( rows [ _ NUM ] ) ) { valid Count ++ ; if ( min == - _ NUM ) min = rows [ _ NUM ] ; else min =  Math . min ( min , rows [ _ NUM ] ) ; bit Set . set ( rows [ _ NUM ] ) ; } } } last Paths . clear ( ) ; if ( valid Count > _ NUM ) { for ( counter = min + valid Count - _ NUM ; counter >= min ; counter -- ) if ( ! bit Set . get ( counter ) ) return _ BOOL ; } } return _ BOOL ; }
public static  Uri add Message To Uri (  Content Resolver resolver ,  Uri uri ,  String address ,  String body ,  String subject ,  Long date , boolean read , boolean delivery Report ) { return add Message To Uri ( resolver , uri , address , body , subject , date , read , delivery Report , - _ NUM ) ; }
protected void compute Doubles For All Zoom Levels ( ) { int num Frames = m Sound File . get Num Frames ( ) ; float max Gain = _ NUM ; for ( int i = _ NUM ; i < num Frames ; i ++ ) { float gain = get Gain ( i , num Frames , m Sound File . get Frame Gains ( ) ) ; if ( gain > max Gain ) { max Gain = gain ; } } scale Factor = _ NUM ; if ( max Gain > _ NUM ) { scale Factor = _ NUM / max Gain ; } max Gain = _ NUM ; int gain Hist [ ] = new int [ _ NUM ] ; for ( int i = _ NUM ; i < num Frames ; i ++ ) { int smoothed Gain = ( int ) ( get Gain ( i , num Frames , m Sound File . get Frame Gains ( ) ) * scale Factor ) ; if ( smoothed Gain < _ NUM ) smoothed Gain = _ NUM ; if ( smoothed Gain > _ NUM ) smoothed Gain = _ NUM ; if ( smoothed Gain > max Gain ) max Gain = smoothed Gain ; gain Hist [ smoothed Gain ] ++ ; } min Gain = _ NUM ; int sum = _ NUM ; while ( min Gain < _ NUM && sum < num Frames / _ NUM ) { sum += gain Hist [ ( int ) min Gain ] ; min Gain ++ ; } sum = _ NUM ; while ( max Gain > _ NUM && sum < num Frames / _ NUM ) { sum += gain Hist [ ( int ) max Gain ] ; max Gain -- ; } range = max Gain - min Gain ; m Num Zoom Levels = _ NUM ; m Len By Zoom Level = new int [ _ NUM ] ; m Zoom Factor By Zoom Level = new float [ _ NUM ] ; float ratio = get Measured Width ( ) / ( float ) num Frames ; if ( ratio < _ NUM ) { m Len By Zoom Level [ _ NUM ] =  Math . round ( num Frames * ratio ) ; m Zoom Factor By Zoom Level [ _ NUM ] = ratio ; m Len By Zoom Level [ _ NUM ] = num Frames ; m Zoom Factor By Zoom Level [ _ NUM ] = _ NUM ; m Len By Zoom Level [ _ NUM ] = num Frames * _ NUM ; m Zoom Factor By Zoom Level [ _ NUM ] = _ NUM ; m Len By Zoom Level [ _ NUM ] = num Frames * _ NUM ; m Zoom Factor By Zoom Level [ _ NUM ] = _ NUM ; m Zoom Level = _ NUM ; } else { m Len By Zoom Level [ _ NUM ] = num Frames ; m Zoom Factor By Zoom Level [ _ NUM ] = _ NUM ; m Len By Zoom Level [ _ NUM ] = num Frames * _ NUM ; m Zoom Factor By Zoom Level [ _ NUM ] = _ NUM ; m Len By Zoom Level [ _ NUM ] = num Frames * _ NUM ; m Zoom Factor By Zoom Level [ _ NUM ] = _ NUM ; m Len By Zoom Level [ _ NUM ] = num Frames * _ NUM ; m Zoom Factor By Zoom Level [ _ NUM ] = _ NUM ; m Zoom Level = _ NUM ; for ( int i = _ NUM ; i < _ NUM ; i ++ ) { if ( m Len By Zoom Level [ m Zoom Level ] - get Measured Width ( ) > _ NUM ) { break ; } else { m Zoom Level = i ; } } } m Initialized = _ BOOL ; }
public void run Queue ( ) { synchronized ( sync ) { while ( ! queue . is Empty ( ) ) {  Runnable r = queue . poll ( ) ; if ( r != null ) { try { r . run ( ) ; } catch (  Exception e ) {  Logging Util . exception ( e ) ; } } else {  Logging Util . warning ( _ STR ) ; } } } }
public static void write File ( final  File file , final  File Output output , final  IProgress Monitor monitor ) throws  Core Exception {  File Output Stream fout = null ; try { fout = new  File Output Stream ( file ) ;  Buffered Output Stream bout = new  Buffered Output Stream ( fout ) ; if ( monitor != null ) { monitor . sub Task ( _ STR + file . get Name ( ) ) ; } output . write File ( bout ) ; bout . flush ( ) ; } catch (  IOException e ) {  IStatus status =  Findbugs Plugin . create Error Status ( _ STR + output . get Task Description ( ) , e ) ; throw new  Core Exception ( status ) ; } finally { close Quietly ( fout ) ; } }
public static  List <  Entry > load Entries From File (  String path ) {  File sdcard =  Environment . get External Storage Directory ( ) ;  File file = new  File ( sdcard , path ) ;  List <  Entry > entries = new  Array List <  Entry > ( ) ; try { @  Suppress Warnings ( _ STR )  Buffered Reader br = new  Buffered Reader ( new  File Reader ( file ) ) ;  String line ; while ( ( line = br . read Line ( ) ) != null ) {  String [ ] split = line . split ( _ STR ) ; if ( split . length <= _ NUM ) { entries . add ( new  Entry (  Float . parse Float ( split [ _ NUM ] ) ,  Integer . parse Int ( split [ _ NUM ] ) ) ) ; } else { float [ ] vals = new float [ split . length - _ NUM ] ; for ( int i = _ NUM ; i < vals . length ; i ++ ) { vals [ i ] =  Float . parse Float ( split [ i ] ) ; } entries . add ( new  Bar Entry ( vals ,  Integer . parse Int ( split [ split . length - _ NUM ] ) ) ) ; } } } catch (  IOException e ) {  Log . e (  LOG , e . to String ( ) ) ; } return entries ; }
public static void append Connections (  Vector <  Bean Connection > connections , int tab ) { if ( tab <  TABBED_ CONNECTIONS . size ( ) ) {  Vector <  Bean Connection > cons =  TABBED_ CONNECTIONS . get ( tab ) ; for ( int i = _ NUM ; i < connections . size ( ) ; i ++ ) { cons . add ( connections . get ( i ) ) ; } } }
protected void paint Origin Point (  Point2 D origin Pnt ,  Graphics graphics ,  Map Bean the Map ) { if ( the Map != null && origin Pnt != null ) {  OMPoint pt = new  OMPoint ( origin Pnt . get Y ( ) , origin Pnt . get X ( ) ) ; prepare Point ( pt ) ; pt . generate ( the Map . get Rotated Projection ( ) ) ; pt . render ( graphics ) ; } }
protected int check Close Tag And Get Length (  Char Sequence buffer , int offset , int buffer End ) { if ( offset >= buffer End ) { return - _ NUM ; }  String end Tag = get End Tag ( ) ; if ( is Buffer At String ( buffer , offset , end Tag ) ) { return end Tag . length ( ) ; } if (  String Util . contains Char (  CHOMP_ MODIFIERS , buffer . char At ( offset ) ) && is Buffer At String ( buffer , offset + _ NUM , end Tag ) ) { return end Tag . length ( ) + _ NUM ; } return - _ NUM ; }
@  Override public  Trie optimize (  Trie orig ) {  List <  Char Sequence > cmds = orig . cmds ;  List <  Row > rows = new  Array List < > ( ) ;  List <  Row > orows = orig . rows ; int remap [ ] = new int [ orows . size ( ) ] ;  Arrays . fill ( remap , _ NUM ) ; for ( int j = orows . size ( ) - _ NUM ; j >= _ NUM ; j -- ) { if ( eat ( orows . get ( j ) , remap ) ) { remap [ j ] = _ NUM ; } }  Arrays . fill ( remap , - _ NUM ) ; rows = remove Gaps ( orig . root , orows , new  Array List <  Row > ( ) , remap ) ; return new  Trie ( orig . forward , remap [ orig . root ] , cmds , rows ) ; }
protected void execute Tasks ( final  Access Path Task [ ] tasks ) throws  Exception { if ( executor == null ) { for (  Access Path Task task : tasks ) { task . call ( ) ; } return ; } final  List <  Future Task <  Void > > future Tasks = new  Linked List <  Future Task <  Void > > ( ) ; for (  Access Path Task task : tasks ) { final  Future Task <  Void > ft = new  Future Task Mon <  Void > ( task ) ; future Tasks . add ( ft ) ; } try { for (  Future Task <  Void > ft : future Tasks ) { halted ( ) ; executor . execute ( ft ) ; } for (  Future Task <  Void > ft : future Tasks ) { if ( ! is Done ( ) ) ft . get ( ) ; } } finally { for (  Future Task <  Void > ft : future Tasks ) { ft . cancel ( _ BOOL ) ; } } }
public void unregister Client Interest (  String region Name ,  List keys Of Interest , boolean is Closing ,  Client Proxy Membership ID membership ID , boolean keepalive ) { if ( logger . is Debug Enabled ( ) ) { logger . debug ( _ STR , membership ID , region Name , keys Of Interest ) ; }  Cache Client Proxy proxy = get Client Proxy ( membership ID ) ; if ( proxy != null ) { proxy . set Keep Alive ( keepalive ) ; proxy . unregister Client Interest ( region Name , keys Of Interest , is Closing ) ; } }
@  Override public  Storage create Storage (  Storage Create Request storage Create Request ) { validate Storage Create Request ( storage Create Request ) ;  Storage Platform Entity storage Platform Entity = storage Platform Helper . get Storage Platform Entity ( storage Create Request . get Storage Platform Name ( ) ) ;  Storage Entity storage Entity = storage Dao . get Storage By Name ( storage Create Request . get Name ( ) ) ; if ( storage Entity != null ) { throw new  Already Exists Exception (  String . format ( _ STR , storage Create Request . get Name ( ) ) ) ; } storage Entity = new  Storage Entity ( ) ; storage Entity . set Name ( storage Create Request . get Name ( ) ) ; storage Entity . set Storage Platform ( storage Platform Entity ) ; if ( !  Collection Utils . is Empty ( storage Create Request . get Attributes ( ) ) ) {  List <  Storage Attribute Entity > attribute Entities = new  Array List < > ( ) ; storage Entity . set Attributes ( attribute Entities ) ; for (  Attribute attribute : storage Create Request . get Attributes ( ) ) {  Storage Attribute Entity attribute Entity = new  Storage Attribute Entity ( ) ; attribute Entities . add ( attribute Entity ) ; attribute Entity . set Storage ( storage Entity ) ; attribute Entity . set Name ( attribute . get Name ( ) ) ; attribute Entity . set Value ( attribute . get Value ( ) ) ; } } storage Entity = storage Dao . save And Refresh ( storage Entity ) ; return create Storage From Entity ( storage Entity ) ; }
public void mouse Moved (  Mouse Event e ) { mouse Support . fire Map Mouse Moved ( e ) ; if ( e . get Source ( ) instanceof  Map Bean ) { if ( draw Distance Objects && the Map != null ) { double lat1 , lat2 , long1 , long2 ; r Point2 = the Map . get Coordinates ( e ) ; the Map . repaint ( ) ; if ( info Delegator != null ) {  Debug . message ( _ STR , _ STR ) ; lat1 = r Point1 . get Y ( ) ; long1 = r Point1 . get X ( ) ; lat2 = r Point2 . get Y ( ) ; long2 = r Point2 . get X ( ) ; distance =  Great Circle . spherical Distance (  Proj Math . deg To Rad ( lat1 ) ,  Proj Math . deg To Rad ( long1 ) ,  Proj Math . deg To Rad ( lat2 ) ,  Proj Math . deg To Rad ( long2 ) ) ; double azimuth = get Spherical Azimuth ( lat1 , long1 , lat2 , long2 ) ; double tmp Distance = total Distance + distance ;  String info Line = create Distance Information Line ( r Point2 , tmp Distance , azimuth ) ;  Info Display Event info = new  Info Display Event ( this , info Line ,  Information Delegator .  COORDINATE_ INFO_ LINE ) ; info Delegator . request Info Line ( info ) ; } } else { fire Mouse Location ( e ) ; } } }
public void test Signer String ( ) throws  Exception {  Signer s = new  Signer Stub ( _ STR ) ; assert Not Null ( s ) ; assert Equals ( _ STR , s . get Name ( ) ) ; assert Null ( s . get Private Key ( ) ) ;  Signer s2 = new  Signer Stub ( null ) ; assert Null ( s2 . get Name ( ) ) ; }
public  TSink <  String > send String (  TStream <  String > stream ) {  Objects . require Non Null ( stream , _ STR ) ; return send Text ( stream , null ) ; }
protected static  Method resolve Java Method (  Bsh Class Manager bcm ,  Class clas ,  String name ,  Class [ ] types , boolean static Only ) throws  Util Eval Error { if ( clas == null ) throw new  Interpreter Error ( _ STR ) ;  Method method = null ; if ( bcm == null )  Interpreter . debug ( _ STR ) ; else method = bcm . get Resolved Method ( clas , name , types , static Only ) ; if ( method == null ) { boolean public Only = !  Capabilities . have Accessibility ( ) ; try { method = find Overloaded Method ( clas , name , types , public Only ) ; } catch (  Security Exception e ) { throw new  Util Target Error ( _ STR + clas , e ) ; } check Found Static Method ( method , static Only , clas ) ; if ( method != null && ! public Only ) { try {  Reflect Manager .  RMSet Accessible ( method ) ; } catch (  Util Eval Error e ) { } } if ( method != null && bcm != null ) bcm . cache Resolved Method ( clas , types , method ) ; } return method ; }
protected  Abstract Regex NPAnnotator (  String pattern , int matcher Group , boolean case Sensitive , double confidence ) { this (  Pattern . compile ( pattern , case Sensitive ? _ NUM :  Pattern .  CASE_ INSENSITIVE ) , matcher Group , confidence ) ; }
public static void delete Invisible Nodes ( final  Zy Graph graph ) {  Preconditions . check Not Null ( graph , _ STR ) ; graph . delete Nodes (  Node Functions . get Invisible Nodes ( graph ) ) ; }
@  Override public void on Bind View Holder (  K holder , int position ) { holder . bind Item ( items . get ( position ) ) ; }
public static  Date days After (  Date date Inst , int num Days ) { if ( ( num Days <= _ NUM ) || ( date Inst == null ) ) { throw new  Illegal Argument Exception ( ) ; } final  Calendar cal = new  Gregorian Calendar ( ) ; cal . set Time ( date Inst ) ; cal . add (  Calendar .  DAY_ OF_ YEAR , num Days ) ; return cal . get Time ( ) ; }
public int purge ( ) { if ( capacity >= _ NUM ) { int start = size ( ) ;  Object [ ] cache = message Cache . to Array ( ) ; for ( int i = start - _ NUM ; i >= capacity ; i -- ) { message Cache . remove ( (  IMessage ) cache [ i ] ) ; } return start - size ( ) ; } return _ NUM ; }
@  Override public void write External (  Object Output out ) throws  IOException { super . write External ( out ) ; out . write Object ( conservative Approximation ) ; out . write Object ( progressive Approximation ) ; }
@  Override public void delete Rows ( int start , int len ) throws  Fits Exception { try { if ( this . n Rows == _ NUM || start < _ NUM || start >= this . n Rows || len <= _ NUM ) { return ; } if ( start + len > this . n Rows ) { len = this . n Rows - start ; } ensure Data ( ) ; for ( int i = _ NUM ; i < this . n Fields ; i += _ NUM ) {  Object o =  Array Funcs . new Instance ( this . types [ i ] , this . n Rows - len ) ;  System . arraycopy ( this . data [ i ] , _ NUM , o , _ NUM , start ) ;  System . arraycopy ( this . data [ i ] , start + len , o , start , this . n Rows - len - start ) ; this . data [ i ] = o ; } this . n Rows -= len ; } catch (  Fits Exception e ) { throw e ; } catch (  Exception e ) { throw new  Fits Exception ( _ STR + e . get Message ( ) , e ) ; } }
private void paint Drop Lines (  Sea Glass Context context ,  Graphics g ) {  JTable .  Drop Location loc = table . get Drop Location ( ) ; if ( loc == null ) { return ; }  Color color = (  Color ) style . get ( context , _ STR ) ;  Color short Color = (  Color ) style . get ( context , _ STR ) ; if ( color == null && short Color == null ) { return ; }  Rectangle rect ; rect = get HDrop Line Rect ( loc ) ; if ( rect != null ) { int x = rect . x ; int w = rect . width ; if ( color != null ) { extend Rect ( rect , _ BOOL ) ; g . set Color ( color ) ; g . fill Rect ( rect . x , rect . y , rect . width , rect . height ) ; } if ( ! loc . is Insert Column ( ) && short Color != null ) { g . set Color ( short Color ) ; g . fill Rect ( x , rect . y , w , rect . height ) ; } } rect = get VDrop Line Rect ( loc ) ; if ( rect != null ) { int y = rect . y ; int h = rect . height ; if ( color != null ) { extend Rect ( rect , _ BOOL ) ; g . set Color ( color ) ; g . fill Rect ( rect . x , rect . y , rect . width , rect . height ) ; } if ( ! loc . is Insert Row ( ) && short Color != null ) { g . set Color ( short Color ) ; g . fill Rect ( rect . x , y , rect . width , h ) ; } } }
public static  String response ( final  String c Question , final  String c Title , final  String c Default , final boolean b Password , final  String c Label ) { final  Border Layout layout = new  Border Layout ( ) ; layout . set Hgap ( _ NUM ) ; final  JPanel panel = new  JPanel ( layout ) ; final  JLabel question = new  JLabel ( c Question ) ; final  JText Field field ; if ( b Password ) { field = new  JPassword Field ( ) ; } else { field = new  JText Field ( ) ; } if ( c Default != null ) { field . set Text ( c Default ) ; } final  String title ; if ( c Title != null ) { title = c Title ; } else { title = _ STR ; } panel . add ( question ,  Border Layout .  NORTH ) ; if ( c Label != null ) { final  JLabel label = new  JLabel ( c Label ) ; panel . add ( label ,  Border Layout .  WEST ) ; } panel . add ( field ,  Border Layout .  CENTER ) ; final  String [ ] options = { _ STR , _ STR } ; final int option =  JOption Pane . show Option Dialog ( null , panel , title ,  JOption Pane .  NO_ OPTION ,  JOption Pane .  PLAIN_ MESSAGE , null , options , options [ _ NUM ] ) ; if ( option == _ NUM ) { return field . get Text ( ) ; } else { return null ; } }
private void on Sensor Data Start (  Attributes attributes ) { sensor Name = attributes . get Value (  ATTRIBUTE_ NAME ) ; }
protected  Script Builder big Num ( int index , long num ) { final byte [ ] data ; if ( num == _ NUM ) { data = new byte [ _ NUM ] ; } else {  Stack <  Byte > result = new  Stack <  Byte > ( ) ; final boolean neg = num < _ NUM ; long absvalue =  Math . abs ( num ) ; while ( absvalue != _ NUM ) { result . push ( ( byte ) ( absvalue & _ NUM ) ) ; absvalue >>= _ NUM ; } if ( ( result . peek ( ) & _ NUM ) != _ NUM ) { result . push ( ( byte ) ( neg ? _ NUM : _ NUM ) ) ; } else if ( neg ) { result . push ( ( byte ) ( result . pop ( ) | _ NUM ) ) ; } data = new byte [ result . size ( ) ] ; for ( int byte Idx = _ NUM ; byte Idx < data . length ; byte Idx ++ ) { data [ byte Idx ] = result . get ( byte Idx ) ; } } return add Chunk ( index , new  Script Chunk ( data . length , data ) ) ; }
public void add (  IResource [ ] resources ,  IProgress Monitor monitor ) throws  Team Exception { if ( monitor == null ) { monitor = new  Null Progress Monitor ( ) ; }  Map table = get Provider Mapping ( resources ) ; if ( table . get ( null ) != null ) { throw new  SVNException (  Policy . bind ( _ STR ) ) ; }  Set key Set = table . key Set ( ) ; monitor . begin Task ( _ STR , key Set . size ( ) * _ NUM ) ; monitor . set Task Name (  Policy . bind ( _ STR ) ) ;  Iterator iterator = key Set . iterator ( ) ; while ( iterator . has Next ( ) ) {  IProgress Monitor sub Monitor = new  Sub Progress Monitor ( monitor , _ NUM ) ;  SVNTeam Provider provider = (  SVNTeam Provider ) iterator . next ( ) ;  List list = (  List ) table . get ( provider ) ;  IResource [ ] provider Resources = (  IResource [ ] ) list . to Array ( new  IResource [ list . size ( ) ] ) ; provider . add ( provider Resources ,  IResource .  DEPTH_ ZERO , sub Monitor ) ; } }
private boolean is New Workers Required ( ) { stats Util . poll Stats Broker Job Queue ( ) ; final  Stats Message Listener stats Message Listener = stats Util . get Stats Message Listener ( ) ; if (  LOGGER . is Debug Enabled ( ) ) {  LOGGER . debug ( _ STR + stats Message Listener . get Stats ( ) ) ; } boolean quick Spawn Mode = _ BOOL ; int total Remote Worker Spawned = get Number Of Workers ( ) ; int consumer Count = stats Message Listener . get Consumers ( ) ; int remote Worker Count = consumer Count - max Concurrent In Vm Worker Count ; int queue Size = stats Message Listener . get Queue Size ( ) ; if ( verbose Log Level > _ NUM ) {  Utilities . verbose Log ( _ STR + max Consumer Size + _ STR + consumer Count + _ STR + queue Size + _ STR + total Remote Worker Spawned + _ STR + remote Worker Count + _ STR + queue Consumer Ratio + _ STR + life Remaining ( ) ) ; } if ( consumer Count < queue Size ) { if ( remote Worker Count > _ NUM ) { quick Spawn Mode = ( queue Size / remote Worker Count ) > max Concurrent In Vm Worker Count ; } else { quick Spawn Mode = queue Size > max Concurrent In Vm Worker Count ; } if (  LOGGER . is Debug Enabled ( ) ) {  LOGGER . debug ( _ STR + quick Spawn Mode ) ; } if ( verbose Log Level > _ NUM ) {  Utilities . verbose Log ( _ STR + max Consumer Size + _ STR + remote Worker Count + _ STR + queue Consumer Ratio + _ STR + quick Spawn Mode + _ STR + life Remaining ( ) / completion Factor ) ; } return ( stats Message Listener . new Workers Required ( ( int ) ( life Remaining ( ) / completion Factor ) ) && ( consumer Count < max Consumer Size ) && ( consumer Count < queue Size / queue Consumer Ratio ) ) || ( quick Spawn Mode ) ; } return _ BOOL ; }
@  Override public boolean equals (  Object object ) { if ( object == null ) { return _ BOOL ; } if ( object == this ) { return _ BOOL ; } if ( super . equals ( object ) && object instanceof  Middle Pin Needle ) { return _ BOOL ; } return _ BOOL ; }
@  Override public final int compare To (  Term other ) { if ( field . equals ( other . field ) ) { return bytes . compare To ( other . bytes ) ; } else { return field . compare To ( other . field ) ; } }
protected  String use Kernel (  Instances data ) throws  Exception {  Kernel kernel = null ;  String Buffer text = new  String Buffer ( ) ; try { kernel =  Kernel . make Copy ( m_ Kernel ) ; } catch (  Exception e ) { e . print Stack Trace ( ) ; fail ( _ STR + e ) ; } kernel . build Kernel ( data ) ; for ( int n = _ NUM ; n < data . num Instances ( ) ; n ++ ) { for ( int i = n ; i < data . num Instances ( ) ; i ++ ) { text . append ( ( n + _ NUM ) + _ STR + ( i + _ NUM ) + _ STR + kernel . eval ( n , i , data . instance ( i ) ) + _ STR ) ; } } return text . to String ( ) ; }
public final <  T > void insert Internal (  List <  T > list ,  T object , final int position ) { list . add ( position , object ) ; int g = position ; if ( has Header View ( ) ) g ++ ; notify Item Inserted ( g ) ; }
public  Base Perf Test (  String name ) { super ( name ) ; }
public boolean by Pass Control To Processor ( boolean flag ) { return _ BOOL ; }
private  Array List <  Neuron > initialize Layer (  Neuron Update Rule node Type , int nodes ) {  Array List <  Neuron > layer = new  Array List <  Neuron > ( nodes ) ; for ( int i = _ NUM ; i < nodes ; i ++ ) {  Neuron node = new  Neuron ( get Parent Network ( ) , node Type ) ; node Type . set Increment ( _ NUM ) ; layer . add ( node ) ; } return layer ; }
private void add Fillet (  Coordinate p ,  Coordinate p0 ,  Coordinate p1 , int direction , double radius ) { double dx0 = p0 . x - p . x ; double dy0 = p0 . y - p . y ; double start Angle =  Math . atan2 ( dy0 , dx0 ) ; double dx1 = p1 . x - p . x ; double dy1 = p1 . y - p . y ; double end Angle =  Math . atan2 ( dy1 , dx1 ) ; if ( direction ==  CGAlgorithms .  CLOCKWISE ) { if ( start Angle <= end Angle ) start Angle += _ NUM *  Math .  PI ; } else { if ( start Angle >= end Angle ) start Angle -= _ NUM *  Math .  PI ; } seg List . add Pt ( p0 ) ; add Fillet ( p , start Angle , end Angle , direction , radius ) ; seg List . add Pt ( p1 ) ; }
public void add Neuron Listener ( final  Neuron Listener listener ) { neuron Listeners . add ( listener ) ; }
public void import Certs (  String [ ] cert File Names ,  String alias Prefix ) throws  Certificate Exception ,  IOException ,  Key Store Exception ,  No Such Algorithm Exception { if ( cert File Names == null ) { return ; }  Certificate Factory cert Factory =  Certificate Factory . get Instance ( _ STR ) ; for (  String fn : cert File Names ) {  Input Stream in Stream = new  File Input Stream ( fn ) ;  X509 Certificate cert = (  X509 Certificate ) cert Factory . generate Certificate ( in Stream ) ; in Stream . close ( ) ;  String alias = alias Prefix == null ? fn : alias Prefix + fn ; _key Store . set Certificate Entry ( alias , cert ) ; } }
void handle Selection Changed (  String selection ) { if ( m Did Expand Selection ) { m Selected Text = selection ; m Did Expand Selection = _ BOOL ; return ; } if ( selection == null || selection . is Empty ( ) ) { schedule Invalid Tap Notification ( ) ; if ( m Selection Type ==  Selection Type .  TAP ) { reset Selection States ( ) ; return ; } } if ( ! selection . is Empty ( ) ) { unschedule Invalid Tap Notification ( ) ; } m Selected Text = selection ; if ( m Was Tap Gesture Detected ) { m Selection Type =  Selection Type .  TAP ; handle Selection ( selection , m Selection Type ) ; m Was Tap Gesture Detected = _ BOOL ; } else { m Handler . handle Selection Modification ( selection , is Valid Selection ( selection ) , m X , m Y ) ; } }
public  Is Composing Parser parse ( ) throws  Parser Configuration Exception ,  SAXException ,  Parse Failure Exception { try {  SAXParser Factory factory =  SAXParser Factory . new Instance ( ) ;  SAXParser parser = factory . new SAXParser ( ) ; parser . parse ( m Input Source , this ) ; return this ; } catch (  IOException e ) { throw new  Parse Failure Exception ( _ STR , e ) ; } }
private boolean parse Html (  String html ) {  Pattern p =  Pattern . compile ( _ STR ) ;  Matcher m = p . matcher ( html ) ; if ( ! m . find ( ) ) { p =  Pattern . compile ( _ STR ) ; m = p . matcher ( html ) ; } if ( ! m . find ( ) ) { return _ BOOL ; } delay =  Integer . parse Int ( m . group ( _ NUM ) ) ; url = m . group ( _ NUM ) ; return _ BOOL ; }
private void skip To End ( ) throws  IOException {  Input Stream is = get Input Stream ( ) ; if ( is == null ) return ; if ( chunk Length > _ NUM ) is . skip ( chunk Length ) ; for ( int tag = is . read ( ) ; tag >= _ NUM ; tag = is . read ( ) ) { switch ( tag ) { case _ STR : server . free Read Lock ( ) ; this . is = is = server . read Channel ( channel ) ; if ( is == null ) { this . server = null ; return ; } break ; case _ STR : server . free Read Lock ( ) ; this . is = null ; this . server = null ; return ; case - _ NUM : server . free Read Lock ( ) ; this . is = null ; this . server = null ; return ; default : int length = ( is . read ( ) << _ NUM ) + is . read ( ) ; is . skip ( length ) ; break ; } } }
private  Response Packet execute Delete (  Query Template Packet template ,  ISpace Proxy space ,  Transaction txn ) throws  Remote Exception ,  Transaction Exception ,  Unusable Entry Exception ,  Interrupted Exception {  Response Packet packet = new  Response Packet ( ) ; template . set Operation ID ( get Operation ID ( ) ) ; template . set Explain Plan ( get Explain Plan ( ) ) ; if ( is Return Result ( ) ) { int max = get Rownum Limit ( ) ;  Array List <  IEntry Packet > entries = template . take ( space , get Routing ( ) , get Projection Template ( ) , txn , get Timeout ( ) , get Read Modifier ( ) , get If Exists ( ) , max , get Min Entries To Wait For ( ) , get Query Result Type ( ) ) ; packet . set Result Set ( entries ) ; packet . set Int Result ( entries . size ( ) ) ; } else { template . set Routing ( get Routing ( ) ) ; int cleared = _executor . clear ( template , space , txn , get Read Modifier ( ) ) ; packet . set Int Result ( cleared ) ; } return packet ; }
protected double compute Random Projection ( int rp Index , int class Index ,  Instance instance ) { double sum = _ NUM ; for ( int i = _ NUM ; i < instance . num Values ( ) ; i ++ ) { int index = instance . index ( i ) ; if ( index != class Index ) { double value = instance . value Sparse ( i ) ; if ( !  Utils . is Missing Value ( value ) ) { sum += m_rmatrix [ rp Index ] [ index ] * value ; } } } return sum ; }
public void put (  Unique String key ,  Object val ) { int loc = key . get Defn Loc ( ) ; if ( loc == - _ NUM ) { loc = defn Idx ++ ; key . set Loc ( loc ) ; } if ( loc >= this . table . length ) { int old Size = this . table . length ; int new Size =  Math . max ( _ NUM * old Size , loc + _ NUM ) ;  Object [ ] old = this . table ; this . table = new  Object [ new Size ] ;  System . arraycopy ( old , _ NUM , this . table , _ NUM , old . length ) ; } this . table [ loc ] = val ; }
public  Byte Array Data Source (  String string Data ,  String char Set Name ,  String type ) { if ( char Set Name == null || char Set Name . length ( ) == _ NUM ) char Set Name = _ STR ; try { m_data = string Data . get Bytes ( char Set Name ) ; } catch (  Unsupported Encoding Exception uex ) { log . log (  Level .  WARNING , _ STR + char Set Name , uex ) ; } if ( type != null && type . length ( ) > _ NUM ) m_type = type ; }
public static int deflate ( byte [ ] previous , int previous Length , byte [ ] current , int current Length , byte [ ] result ) { if ( previous == null ) {  System . arraycopy ( current , _ NUM , result , _ NUM , current Length ) ; return current Length ; } int length = _ NUM ; int start1 = _ NUM ; int start2 = _ NUM ; while ( start1 < previous Length && start2 < current Length ) { int end1 = start1 ; int end2 = start2 ; while ( end1 <= previous Length && end2 <= current Length ) { byte c1 = ( end1 < previous Length ? previous [ end1 ] : ( byte ) _ STR ) ; byte c2 = ( end2 < current Length ? current [ end2 ] : ( byte ) _ STR ) ; if ( c1 == c2 ) { if ( c1 == _ STR ) { result [ length ++ ] = _ STR ; break ; } else { end1 ++ ; end2 ++ ; } } else { while ( end1 < previous Length && previous [ end1 ] != _ STR ) { end1 ++ ; } while ( end2 < current Length && current [ end2 ] != _ STR ) { end2 ++ ; } for ( int i = start2 ; i < end2 ; i ++ ) result [ length ++ ] = current [ i ] ; break ; } } start1 = end1 + _ NUM ; start2 = end2 + _ NUM ; if ( start2 < current Length ) result [ length ++ ] = _ STR ; } return length ; }
private int add Labels Internal (  GL10 gl ,  Paint text Paint , boolean draw To Canvas ,  Label Data [ ] labels ) { int u = _ NUM ; int v = _ NUM ; int line Height = _ NUM ; for (  Label Data label : labels ) { int ascent = _ NUM ; int descent = _ NUM ; int measured Text Width = _ NUM ; int height = _ NUM ; int width = _ NUM ; int font Size = label . get Font Size ( ) ; do { text Paint . set Color ( _ NUM | label . get Color ( ) ) ; text Paint . set Text Size ( font Size * m Res . get Display Metrics ( ) . density ) ; ascent = ( int )  Math . ceil ( - text Paint . ascent ( ) ) ; descent = ( int )  Math . ceil ( text Paint . descent ( ) ) ; measured Text Width = ( int )  Math . ceil ( text Paint . measure Text ( label . get Text ( ) ) ) ; height = ascent + descent ; width = measured Text Width ; font Size -- ; } while ( font Size > _ NUM && width > m Res . get Display Metrics ( ) . width Pixels ) ; int next U ; if ( u + width > m Strike Width ) { u = _ NUM ; next U = width ; v += line Height ; line Height = _ NUM ; } else { next U = u + width ; } line Height =  Math . max ( line Height , height ) ; if ( v + line Height > m Strike Height && draw To Canvas ) { throw new  Illegal Argument Exception ( _ STR ) ; } int v Base = v + ascent ; if ( draw To Canvas ) { m Canvas . draw Text ( label . get Text ( ) , u , v Base , text Paint ) ; label . set Texture Data ( width , height , u , v + height , width , - height , m Texel Width , m Texel Height ) ; } u = next U ; } return v + line Height ; }
private void generate Chunks For Table (  Table table , long table Chunk Size ,  String [ ] columns ) throws  Replicator Exception ,  Interrupted Exception { long chunk Size ;  Integer pk Type = get PKType ( table ) ; if ( table Chunk Size == _ NUM ) { chunks . put ( new  No Chunk ( table , columns ) ) ; return ; } else if ( table Chunk Size < _ NUM ) { chunk Size = this . chunk Size ; } else { chunk Size = table Chunk Size ; } if ( logger . is Debug Enabled ( ) ) logger . debug ( _ STR + table . get Schema ( ) + _ STR + table . get Name ( ) ) ; if ( pk Type == null ) chunk Limit ( table ) ; else if ( pk Type ==  Types .  NUMERIC ) chunk Numeric PK ( table , columns , chunk Size ) ; else if ( pk Type ==  Types .  VARCHAR ) chunk Varchar PK ( table ) ; }
@  Override public  String to String ( ) {  String Buffer sb = new  String Buffer ( _ STR ) ; sb . append ( this . label ) ; sb . append ( _ STR ) ; sb . append ( this . value ) ; sb . append ( _ STR ) ; return ( sb . to String ( ) ) ; }
protected int read Application Data ( byte [ ] buf , int offset , int len ) throws  IOException { if ( len < _ NUM ) { return _ NUM ; } while ( application Data Queue . available ( ) == _ NUM ) { if ( this . closed ) { if ( this . failed With Error ) { throw new  IOException (  TLS_ ERROR_ MESSAGE ) ; } return - _ NUM ; } safe Read Record ( ) ; } len =  Math . min ( len , application Data Queue . available ( ) ) ; application Data Queue . remove Data ( buf , offset , len , _ NUM ) ; return len ; }
private void perform Frame Tasks ( ) { synchronized ( m Frame Task Queue ) {  AFrame Task task = m Frame Task Queue . poll ( ) ; while ( task != null ) { task . run ( ) ; task = m Frame Task Queue . poll ( ) ; } } }
public  List <  Page > expand Pages (  List <  Page > pages ) {  List <  Page > expanded Pages = new  Array List <  Page > ( ) ;  Set <  String > in And Out Links = new  Hash Set <  String > ( ) ; for ( int i = _ NUM ; i < pages . size ( ) ; i ++ ) {  Page curr P = pages . get ( i ) ; if ( ! expanded Pages . contains ( curr P ) ) { expanded Pages . add ( curr P ) ; }  List <  String > curr Inlinks = curr P . get Inlinks ( ) ; for ( int j = _ NUM ; j < curr Inlinks . size ( ) ; j ++ ) { in And Out Links . add ( curr Inlinks . get ( i ) ) ; }  List <  String > curr Outlinks = curr P . get Outlinks ( ) ; for ( int j = _ NUM ; j < curr Outlinks . size ( ) ; j ++ ) { in And Out Links . add ( curr Outlinks . get ( i ) ) ; } }  Iterator <  String > it = in And Out Links . iterator ( ) ; while ( it . has Next ( ) ) {  String addr = it . next ( ) ;  Page p = p Table . get ( addr ) ; if ( p != null && ! expanded Pages . contains ( p ) ) { expanded Pages . add ( p ) ; } } return expanded Pages ; }
@  Override protected  List <  String > create New Export Mask Workflow For Initiators (  List <  URI > initiator URIs ,  Export Group export Group ,  Workflow workflow ,  Map <  URI ,  Integer > volume Map ,  Storage System storage ,  String token ,  String previous Step ) throws  Exception {  List <  String > new Steps = new  Array List < > ( ) ; if ( ! initiator URIs . is Empty ( ) ) {  Map <  String ,  List <  URI > > compute Resource To Initiators = map Initiators To Compute Resource ( export Group , initiator URIs ) ; for (  Map .  Entry <  String ,  List <  URI > > resource Entry : compute Resource To Initiators . entry Set ( ) ) {  String compute Key = resource Entry . get Key ( ) ;  List <  URI > compute Initiator URIs = resource Entry . get Value ( ) ; _log . info (  String . format ( _ STR , compute Key ) ) ;  Gen Export Mask Create Workflow Result result = generate Device Specific Export Mask Create Work Flow ( workflow , previous Step , storage , export Group , compute Initiator URIs , volume Map , token ) ; previous Step = result . get Step Id ( ) ; } } new Steps . add ( previous Step ) ; return new Steps ; }
public boolean is Greater Then (  Percent  Percent ) { assert Defined ( ) ;  Big Decimal this Value = not Null ( this ) ;  Big Decimal parameter = not Null (  Percent ) ; return ( this Value . compare To ( parameter ) > _ NUM ) ; }
@  Override public  URI to Vertex URI ( final  Object key ) { return to URI ( key . to String ( ) ) ; }
public static  List <  INavi Module > load Modules ( final  Abstract SQLProvider provider , final  List <  INavi Raw Module > raw Modules , final  Debugger Template Manager debugger Manager ) throws  Couldnt Load Data Exception {  Preconditions . check Not Null ( raw Modules , _ STR ) ;  Postgre SQLDatabase Functions . check Arguments ( provider , debugger Manager ) ; final  List <  CModule > modules = new  Array List < > ( ) ; final  CConnection connection = provider . get Connection ( ) ; if ( !  Postgre SQLHelpers . has Table ( connection ,  CTable Names .  MODULES_ TABLE ) ) { return new  Array List <  INavi Module > ( modules ) ; } final  String query = _ STR +  CTable Names .  MODULES_ TABLE + _ STR + _ STR + _ STR + _ STR +  CTable Names .  FUNCTIONS_ TABLE + _ STR + _ STR +  CTable Names .  FUNCTIONS_ TABLE + _ STR + _ STR + _ STR +  CTable Names .  MODULE_ VIEWS_ TABLE + _ STR +  CTable Names .  VIEWS_ TABLE + _ STR + _ STR +  CTable Names .  MODULES_ TABLE + _ STR + _ STR +  CTable Names .  MODULES_ TABLE + _ STR + _ STR ; try (  Result Set result Set = connection . execute Query ( query , _ BOOL ) ) { while ( result Set . next ( ) ) { final int module Id = result Set . get Int ( _ STR ) ; final  String name =  Postgre SQLHelpers . read String ( result Set , _ STR ) ; final  String md5 =  Postgre SQLHelpers . read String ( result Set , _ STR ) ; final  String sha1 =  Postgre SQLHelpers . read String ( result Set , _ STR ) ; final  String comment =  Postgre SQLHelpers . read String ( result Set , _ STR ) ; final  Timestamp timestamp = result Set . get Timestamp ( _ STR ) ; final  Timestamp modification Date = result Set . get Timestamp ( _ STR ) ; int function Count = result Set . get Int ( _ STR ) ; final int view Count = result Set . get Int ( _ STR ) ; final  IAddress image Base =  Postgre SQLHelpers . load Address ( result Set , _ STR ) ; final  IAddress file Base =  Postgre SQLHelpers . load Address ( result Set , _ STR ) ; final int debugger Id = result Set . get Int ( _ STR ) ; final boolean is Stared = result Set . get Boolean ( _ STR ) ; final int initialization State = result Set . get Int ( _ STR ) ; final  Debugger Template description = debugger Manager . find Debugger ( debugger Id ) ; final int raw Module Id = result Set . get Int ( _ STR ) ; final  INavi Raw Module raw Module =  Postgre SQLDatabase Functions . find Raw Module ( raw Module Id , raw Modules ) ; if ( ( function Count == _ NUM ) && ( raw Module != null ) ) { function Count = raw Module . get Function Count ( ) ; } modules . add ( new  CModule ( module Id , name , comment , timestamp , modification Date , md5 , sha1 , function Count , view Count , file Base , image Base , description , raw Module , initialization State , is Stared , provider ) ) ; } } catch ( final  SQLException e ) { throw new  Couldnt Load Data Exception ( e ) ; } return new  Array List <  INavi Module > ( modules ) ; }
public static  String serialize Address List (  List <  String > address List ) {  String Builder sb = new  String Builder ( ) ; for (  String s : address List ) { if ( sb . length ( ) != _ NUM ) { sb . append ( _ STR ) ; } sb . append ( s ) ; } return sb . to String ( ) ; }
@  Override protected  Node remove From Frontier ( ) { clean Up Frontier ( ) ;  Node result = frontier . remove ( ) ; explored . add ( result . get State ( ) ) ; update Metrics ( frontier . size ( ) ) ; return result ; }
public static boolean verify File Existence (  String path ) {  File file = new  File ( path ) ; return file . exists ( ) && file . is File ( ) ; }
public boolean equals (  Object object ) { if ( ! ( object instanceof  Attribute ) ) { return _ BOOL ; }  Attribute val = (  Attribute ) object ; if ( value == null ) { if ( val . get Value ( ) == null ) { return name . equals ( val . get Name ( ) ) ; } else { return _ BOOL ; } } return ( ( name . equals ( val . get Name ( ) ) ) && ( value . equals ( val . get Value ( ) ) ) ) ; }
private  Jni Server Socket Impl (  String host , int port ) throws  IOException { _fd = bind Port ( host , port ) ; _id = host + _ STR + port ; _host = host ; if ( _fd != _ NUM ) { } else if ( port < _ NUM ) { throw new  IOException (  L . l ( _ STR , host , port ,  System . get Property ( _ STR ) ) ) ; } else { throw new  IOException (  L . l ( _ STR , host , port ,  System . get Property ( _ STR ) ) ) ; } }
public  Set <  String > add Content (  String variable ,  Value value ) { if ( ! paused ) { cur State . add To State ( new  Assignment ( variable , value ) ) ; return update ( ) ; } else { log . info ( _ STR + variable + _ STR + value ) ; return  Collections . empty Set ( ) ; } }
public  Input Stream download (  String artifact ,  String version ) throws  IOException {  Path path = get Artifact ( artifact , version ) ; if ( !  Files . exists ( path ) ) { throw new  Artifact Not Found Exception ( artifact , version ) ; } return new  Buffered Input Stream (  Files . new Input Stream ( path ) ) ; }
@  Override public  String to String ( ) {  String Builder result = new  String Builder ( ) ; result . append ( type . to String ( ) ) ; result . append ( _ STR ) ; result . append ( name ) ; result . append ( _ STR ) ; if ( fields Data != null ) { result . append ( fields Data ) ; } result . append ( _ STR ) ; return result . to String ( ) ; }
protected  String create Error Message (  String message ) { return  String . format (  Locale .  US , _ STR , locator . get Line Number ( ) , locator . get Column Number ( ) , message ) ; }
public static <  T extends  Throwable >  T read Stack Trace (  T throwable ,  Stream Input in ) throws  IOException { final int stack Trace Elements = in . read VInt ( ) ;  Stack Trace Element [ ] stack Trace = new  Stack Trace Element [ stack Trace Elements ] ; for ( int i = _ NUM ; i < stack Trace Elements ; i ++ ) { final  String declaring Classs = in . read String ( ) ; final  String file Name = in . read Optional String ( ) ; final  String method Name = in . read String ( ) ; final int line Number = in . read VInt ( ) ; stack Trace [ i ] = new  Stack Trace Element ( declaring Classs , method Name , file Name , line Number ) ; } throwable . set Stack Trace ( stack Trace ) ; int num Suppressed = in . read VInt ( ) ; for ( int i = _ NUM ; i < num Suppressed ; i ++ ) { throwable . add Suppressed ( in . read Throwable ( ) ) ; } return throwable ; }
public static void edit Type Instance Comment ( final  SQLProvider provider , final int module Id , final  Integer comment Id , final  Integer user Id , final  String comment Text ) throws  Couldnt Save Data Exception {  Preconditions . check Not Null ( provider , _ STR ) ;  Preconditions . check Argument ( module Id > _ NUM , _ STR ) ;  Preconditions . check Not Null ( comment Id , _ STR ) ;  Preconditions . check Not Null ( user Id , _ STR ) ;  Preconditions . check Not Null ( comment Text , _ STR ) ;  Postgre SQLComment Functions . edit Comment ( provider , comment Id , user Id , comment Text ) ; }
private  Print Element create Image Element (  MPrint Format Item item ) {  Object obj = m_data . get Node ( new  Integer ( item . get AD_ Column_ ID ( ) ) ) ; if ( obj == null ) return null ; else if ( obj instanceof  Print Data Element ) ; else { log . log (  Level .  SEVERE , _ STR + obj . get Class ( ) ) ; return null ; }  Print Data Element data = (  Print Data Element ) obj ; if ( data . is Null ( ) && item . is Suppress Null ( ) ) return null ;  String url = data . get Value Display ( m_format . get Language ( ) ) ; if ( ( url == null || url . length ( ) == _ NUM ) ) { if ( item . is Suppress Null ( ) ) return null ; else return null ; }  Image Element element = null ; if ( data . get Display Type ( ) ==  Display Type .  Image ) { element =  Image Element . get ( data , url ) ; } else { element =  Image Element . get ( url ) ; } return element ; }
public  Register Values ( final com . google . security . zynamics . binnavi . debug . models . targetinformation .  Register Values register Values ) { final  List <  Thread Register Values > values = new  Array List <  Thread Register Values > ( ) ; for ( final  Thread Registers thread Register Values : register Values ) { values . add ( new  Thread Register Values ( thread Register Values ) ) ; } this . values = values ; }
default  Map <  String ,  String > snapshot ( ) { final  Map <  String ,  String > map = new  Linked Hash Map < > ( ) ; for Each ( null ) ; return  Collections . unmodifiable Map ( map ) ; }
public void add All ( int [ ] data ) { int data Len = data . length ; if ( data Len == _ NUM ) { return ; } int newcap = size + ( int ) ( data Len * _ NUM ) + _ NUM ; ensure Capacity ( newcap ) ;  System . arraycopy ( data , _ NUM , array , size , data Len ) ; size += data Len ; }
public int read ( byte b [ ] ) throws  IOException { if ( input Stream == null ) { throw new  IOException ( _ STR ) ; } return input Stream . read ( b , _ NUM , b . length ) ; }
public void add Scanning Callback (  One Sheeld Scanning Callback scanning Callback ) { if ( scanning Callback != null && ! scanning Callbacks . contains ( scanning Callback ) ) scanning Callbacks . add ( scanning Callback ) ; }
public void paint (  Graphics g ,  JComponent c ) {  Rectangle bounds = c . get Bounds ( ) ; check ( bounds ) ; int h = c . get Height ( ) ; int w = c . get Width ( ) ; g . draw Image ( m_back Image , _ NUM , _ NUM , w , h , bounds . x , bounds . y , bounds . x + w , bounds . y + h , c ) ; }
@  Override public final void sample ( ) { long count = _count . get ( ) ; long last Count = _last Count . get And Set ( count ) ; _value = count - last Count ; }
public  List <  Integer > expected_token_ids ( ) {  List <  Integer > ret = new  Linked List <  Integer > ( ) ; int parse_state = ( (  Symbol ) stack . peek ( ) ) . parse_state ; short [ ] row = action_tab [ parse_state ] ; for ( int i = _ NUM ; i < row . length ; i += _ NUM ) { if ( row [ i ] == - _ NUM ) continue ; if ( ! validate_expected_symbol ( row [ i ] ) ) continue ; ret . add ( new  Integer ( row [ i ] ) ) ; } return ret ; }
void join Pool (  Executor Service pool ) { try { pool . shutdown ( ) ; if ( ! pool . await Termination ( _ NUM *  LONG_ DELAY_ MS ,  MILLISECONDS ) ) { try { thread Fail ( _ STR + pool + _ STR ) ; } finally { pool . shutdown Now ( ) ; pool . await Termination (  MEDIUM_ DELAY_ MS ,  MILLISECONDS ) ; } } } catch (  Security Exception ok ) { } catch (  Interrupted Exception fail ) { thread Fail ( _ STR ) ; } }
public static boolean is Lower Case ( char ch ) { return  Character . to Lower Case ( ch ) == ch ; }
public static void o (  Z a ) { o ( a ,  Parameters .  Output Field Width ,  Parameters .  Output Frac Places ) ; }
public int search (  String txt ) { int m = pat . length ( ) ; int n = txt . length ( ) ; int skip ; for ( int i = _ NUM ; i <= n - m ; i += skip ) { skip = _ NUM ; for ( int j = m - _ NUM ; j >= _ NUM ; j -- ) { if ( pat . char At ( j ) != txt . char At ( i + j ) ) { skip =  Math . max ( _ NUM , j - right [ txt . char At ( i + j ) ] ) ; break ; } } if ( skip == _ NUM ) return i ; } return n ; }
protected  Instances determine Output Format (  Instances input Format ) throws  Exception { int i ; int [ ] indices ;  String Builder order ;  Instances output ; m_ Attribute Indices . set Upper ( input Format . num Attributes ( ) - _ NUM ) ; order = new  String Builder ( ) ; indices = m_ Attribute Indices . get Selection ( ) ; if ( indices . length == _ NUM ) throw new  Weka Exception ( _ STR ) ; for ( i = _ NUM ; i < indices . length ; i ++ ) { if ( i > _ NUM ) order . append ( _ STR ) ; order . append ( _ STR + ( indices [ i ] + _ NUM ) ) ; } for ( i = _ NUM ; i < input Format . num Attributes ( ) ; i ++ ) { if ( m_ Attribute Indices . is In Range ( i ) ) continue ; order . append ( _ STR ) ; order . append ( _ STR + ( i + _ NUM ) ) ; } m_ Reorder . set Attribute Indices ( order . to String ( ) ) ; m_ Reorder . set Input Format ( input Format ) ; output = m_ Reorder . get Output Format ( ) ; output . set Class Index ( indices . length ) ; output . set Relation Name ( _ STR + indices . length ) ; return output ; }
public static  String remove Trailing Zeros ( final  String str ) {  String result = str ; if ( str != null && str . length ( ) != _ NUM ) { int end Index = str . length ( ) ; while ( end Index > _ NUM ) { final char ch = str . char At ( end Index - _ NUM ) ; if ( ch != _ STR ) { break ; } end Index -- ; } if ( end Index < str . length ( ) ) { result = str . substring ( _ NUM , end Index ) ; } } return result ; }
public synchronized void clear Transactions (  Date from Date ) { lock . lock ( ) ; try { if ( from Date == null ) { unspent . clear ( ) ; spent . clear ( ) ; pending . clear ( ) ; dead . clear ( ) ; } else { remove Entries After Date ( unspent , from Date ) ; remove Entries After Date ( spent , from Date ) ; remove Entries After Date ( pending , from Date ) ; remove Entries After Date ( dead , from Date ) ; } } finally { lock . unlock ( ) ; } }
public void delete ( final  Player player , final  List <  String > args ) { int i ; try { i =  Integer . parse Int ( args . get ( _ NUM ) ) ; } catch ( final  Number Format Exception e ) { sandbox . private Text ( player , _ STR ) ; return ; } final  Sign sign = storage . get (  Integer . value Of ( i ) ) ; if ( sign != null ) { storage . remove (  Integer . value Of ( i ) ) ; sandbox . remove ( sign ) ; final  String Builder sb = new  String Builder ( ) ; sb . append ( _ STR ) ; sign To String ( sb , sign ) ; sandbox . private Text ( player , sb . to String ( ) ) ; } else { sandbox . private Text ( player , _ STR + i + _ STR ) ; } }
public boolean is Finished ( ) { return finished Flag . get ( ) ; }
public static  Intent forge Intent To Open Conversation (  Context context ,  Contact Id contact ) {  Intent intent = new  Intent ( context ,  One To One Talk View . class ) ; intent . set Action (  OPEN_ TALK ) ; intent . add Flags (  Intent .  FLAG_ ACTIVITY_ CLEAR_ TOP |  Intent .  FLAG_ ACTIVITY_ NEW_ TASK ) ; intent . put Extra (  EXTRA_ CONTACT , (  Parcelable ) contact ) ; return intent ; }
public synchronized void store Resource Config (  String cluster Name ,  Resource Type resource Type ,  Tungsten Properties resource Props ) throws  Configuration Exception { if ( get Cluster Home ( ) == null ) { throw new  Configuration Exception ( _ STR + get Module Properties File Name (  Configuration Constants .  TR_ PROPERTIES , get Cluster Home ( ) ) ) ; }  String resource Dir = get Resource Config Dir Name ( get Cluster Home ( ) , cluster Name , resource Type ) ;  File resources = new  File ( resource Dir ) ; if ( ! resources . is Directory ( ) ) { if ( resources . mkdirs ( ) ) { logger . info (  String . format ( _ STR , resource Dir ) ) ; } else {  String msg =  String . format ( _ STR , get Resource Config Dir Name ( get Cluster Home ( ) , cluster Name , resource Type ) ) ; logger . error ( msg ) ; throw new  Configuration Exception ( msg ) ; } }  String out File Name = resources . get Absolute Path ( ) +  File . separator + resource Props . get String ( _ STR ) + _ STR ; store ( resource Props , out File Name ) ; }
public  Grid Tcp Rest Nio Listener (  Ignite Logger log ,  Grid Tcp Rest Protocol proto ,  Grid Rest Protocol Handler hnd ,  Grid Kernal Context ctx ) { memcached Lsnr = new  Grid Tcp Memcached Nio Listener ( log , hnd , ctx ) ; this . log = log ; this . proto = proto ; this . hnd = hnd ; }
private void add Tab ( final  JTabbed Pane tab , final  String tab Header , final  CAbstract Settings Panel panel ) { final  JPanel parent Panel = new  JPanel ( new  Border Layout ( ) ) ; parent Panel . add ( panel ,  Border Layout .  NORTH ) ; tab . add Tab ( tab Header , new  JScroll Pane ( parent Panel ) ) ; m_settings Panel . add ( panel ) ; }
public static double generate Random Double Between ( double lower Limit , double upper Limit ) { return lower Limit + ( ( upper Limit - lower Limit ) * _r . next Double ( ) ) ; }
public  Types Item Provider Adapter Factory ( ) { supported Types . add (  IEditing Domain Item Provider . class ) ; supported Types . add (  IStructured Item Content Provider . class ) ; supported Types . add (  ITree Item Content Provider . class ) ; supported Types . add (  IItem Label Provider . class ) ; supported Types . add (  IItem Property Source . class ) ; }
private double kd KNNSearch ( int left , int right , int axis ,  O query ,  KNNHeap knns ,  DBIDArray Iter iter , double maxdist ) { if ( right - left <= leafsize ) { for ( iter . seek ( left ) ; iter . get Offset ( ) < right ; iter . advance ( ) ) { double dist = norm . distance ( query , relation . get ( iter ) ) ; count Object Access ( ) ; count Distance Computation ( ) ; if ( dist <= maxdist ) { knns . insert ( dist , iter ) ; } maxdist = knns . get KNNDistance ( ) ; } return maxdist ; } final int middle = ( left + right ) > > > _ NUM ;  O split = relation . get ( iter . seek ( middle ) ) ; count Object Access ( ) ; final double delta = split . double Value ( axis ) - query . double Value ( axis ) ; final boolean onleft = ( delta >= _ NUM ) ; final boolean onright = ( delta <= _ NUM ) ; final int next = ( axis + _ NUM ) % dims ; if ( onleft && onright ) { double dist = norm . distance ( query , split ) ; count Distance Computation ( ) ; if ( dist <= maxdist ) { assert ( iter . get Offset ( ) == middle ) ; knns . insert ( dist , iter ) ; maxdist = knns . get KNNDistance ( ) ; } if ( left < middle ) { maxdist = kd KNNSearch ( left , middle , next , query , knns , iter , maxdist ) ; } if ( middle + _ NUM < right ) { maxdist = kd KNNSearch ( middle + _ NUM , right , next , query , knns , iter , maxdist ) ; } } else { if ( onleft ) { if ( left < middle ) { maxdist = kd KNNSearch ( left , middle , next , query , knns , iter , maxdist ) ; } if (  Math . abs ( delta ) <= maxdist ) { double dist = norm . distance ( query , split ) ; count Distance Computation ( ) ; if ( dist <= maxdist ) { knns . insert ( dist , iter . seek ( middle ) ) ; maxdist = knns . get KNNDistance ( ) ; } } if ( ( middle + _ NUM < right ) && (  Math . abs ( delta ) <= maxdist ) ) { maxdist = kd KNNSearch ( middle + _ NUM , right , next , query , knns , iter , maxdist ) ; } } else { if ( middle + _ NUM < right ) { maxdist = kd KNNSearch ( middle + _ NUM , right , next , query , knns , iter , maxdist ) ; } if (  Math . abs ( delta ) <= maxdist ) { double dist = norm . distance ( query , split ) ; count Distance Computation ( ) ; if ( dist <= maxdist ) { knns . insert ( dist , iter . seek ( middle ) ) ; maxdist = knns . get KNNDistance ( ) ; } } if ( ( left < middle ) && (  Math . abs ( delta ) <= maxdist ) ) { maxdist = kd KNNSearch ( left , middle , next , query , knns , iter , maxdist ) ; } } } return maxdist ; }
private void parse (  XMLStream Reader parser ,  Handler handler ,  Map <  String ,  Object > values ,  Stack <  Set <  String > > stack , boolean record Started ) throws  IOException ,  XMLStream Exception {  Set <  String > values Addedin This Frame = null ; if ( is Record ) { record Started = _ BOOL ; values Addedin This Frame = new  Hash Set < > ( ) ; stack . push ( values Addedin This Frame ) ; } else if ( record Started ) { values Addedin This Frame = stack . peek ( ) ; } try { if ( attributes != null ) { for (  Node node : attributes ) {  String value = parser . get Attribute Value ( null , node . name ) ; if ( value != null || ( record Started && ! is Record ) ) { put Text ( values , value , node . field Name , node . multi Valued ) ; values Addedin This Frame . add ( node . field Name ) ; } } }  Set <  Node > children Found = new  Hash Set < > ( ) ; int event = - _ NUM ; int flattened Starts = _ NUM ;  String Builder text = new  String Builder ( ) ; while ( _ BOOL ) { event = parser . next ( ) ; if ( event ==  END_ ELEMENT ) { if ( flattened Starts > _ NUM ) flattened Starts -- ; else { if ( has Text && values Addedin This Frame != null ) { values Addedin This Frame . add ( field Name ) ; put Text ( values , text . to String ( ) , field Name , multi Valued ) ; } if ( is Record ) handler . handle ( get Deep Copy ( values ) , for Each Path ) ; if ( child Nodes != null && record Started && ! is Record && ! children Found . contains All ( child Nodes ) ) { for (  Node n : child Nodes ) { if ( ! children Found . contains ( n ) ) n . put Nulls ( values , values Addedin This Frame ) ; } } return ; } } else if ( has Text && ( event ==  CDATA || event ==  CHARACTERS || event ==  SPACE ) ) { text . append ( parser . get Text ( ) ) ; } else if ( event ==  START_ ELEMENT ) { if ( flatten ) flattened Starts ++ ; else handle Start Element ( parser , children Found , handler , values , stack , record Started ) ; } else if ( event ==  END_ DOCUMENT ) return ; } } finally { if ( ( is Record || ! record Started ) && ! stack . empty ( ) ) {  Set <  String > clean This = stack . pop ( ) ; if ( clean This != null ) { for (  String fld : clean This ) values . remove ( fld ) ; } } } }
private void update Info ( ) { connect Address = broker Address Value . get Text ( ) ; will Topic = will Topic Value . get Text ( ) ; will Message = will Message Value . get Text ( ) ; client Id = client Id Value . get Text ( ) ; will Qos =  Integer . parse Int ( will Qos Drop . get Text ( ) ) ; will Retain = will Retain Check Box . get Selection ( ) ; username = username Value . get Text ( ) ; password = password Value . get Text ( ) ; try { connect Port =  Integer . parse Int ( broker Port Value . get Text ( ) ) ; } catch (  Number Format Exception e ) { } try { keep Alive =  Short . parse Short ( keep Alive Value . get Text ( ) ) ; } catch (  Number Format Exception e ) { } }
synchronized void remove Tracer (  Tracer tracer ) { if ( cur Tracers . remove ( tracer ) ) {  LOG . trace ( to String ( ) + _ STR + tracer . to String ( ) ) ; if ( cur Tracers . size ( ) == _ NUM ) { remove And Close All Span Receivers ( ) ; } } }
private void try Grow (  Object [ ] array , int old Cap ) { lock . unlock ( ) ;  Object [ ] new Array = null ; if ( allocation Spin Lock == _ NUM &&  UNSAFE . compare And Swap Int ( this , allocation Spin Lock Offset , _ NUM , _ NUM ) ) { try { int new Cap = old Cap + ( ( old Cap < _ NUM ) ? ( old Cap + _ NUM ) : ( old Cap > > _ NUM ) ) ; if ( new Cap -  MAX_ ARRAY_ SIZE > _ NUM ) { int min Cap = old Cap + _ NUM ; if ( min Cap < _ NUM || min Cap >  MAX_ ARRAY_ SIZE ) throw new  Out Of Memory Error ( ) ; new Cap =  MAX_ ARRAY_ SIZE ; } if ( new Cap > old Cap && queue == array ) new Array = new  Object [ new Cap ] ; } finally { allocation Spin Lock = _ NUM ; } } if ( new Array == null )  Thread . yield ( ) ; lock . lock ( ) ; if ( new Array != null && queue == array ) { queue = new Array ;  System . arraycopy ( array , _ NUM , new Array , _ NUM , old Cap ) ; } }
public void restore ( double value ) { set Value (  Math . min ( max Value , get Value ( ) + value ) ) ; }
@  Ignore @  Test public void test Region Factory Properties Region Attributes ( ) { }
public void add Sub Tree ( int index ,  List <  Node > children ) {  List <  Node Descriptor > node Descriptors = convert Tree Nodes Helper ( children ) ; roots . add Children ( index , node Descriptors ) ;  List <  Node > nodes = new  Array List < > ( ) ; for (  Node Descriptor child : node Descriptors ) { nodes . add ( child . get Node ( ) ) ; } if ( ! nodes . is Empty ( ) ) { fire Event ( new  Store Add Event ( index , nodes ) ) ; } }
public static  String append Version Suffix (  String api Version ,  String version Suffix ) { return  Strings . is Null Or Empty ( version Suffix ) ? api Version : api Version + version Suffix ; }
@  Override public void incoming Object (  IAnalyzed Interval analyzed Interval ) throws  Ade Exception { for (  IAnalyzed Message Summary ams : analyzed Interval . get Analyzed Messages ( ) ) { final  String id = ams . get Message Id ( ) ;  Msg Data data = m_msg Data . get ( id ) ; if ( data == null ) { data = new  Msg Data ( ) ; m_msg Data . put ( id , data ) ; } if ( ! is Clustered ( ams ) ) { data . m_total Log Counts +=  Math . log ( ams . get Number Of Appearances ( ) ) ; data . m_interval Count ++ ; } data . m_all Count += ams . get Number Of Appearances ( ) ; data . m_interval All Count ++ ; if ( data . m_max Num Appearance < ams . get Number Of Appearances ( ) ) { data . m_max Num Appearance = ams . get Number Of Appearances ( ) ; } } ++ m_total Interval Count ; }
private static  Writer init Writer (  File file ,  Object encoding , boolean append ) throws  IOException { if ( file == null ) { throw new  Null Pointer Exception ( _ STR ) ; } if ( encoding == null ) { throw new  Null Pointer Exception ( _ STR ) ; } boolean file Existed Already = file . exists ( ) ;  Output Stream stream = null ;  Writer writer = null ; try { stream = new  File Output Stream ( file , append ) ; if ( encoding instanceof  Charset ) { writer = new  Output Stream Writer ( stream , (  Charset ) encoding ) ; } else if ( encoding instanceof  Charset Encoder ) { writer = new  Output Stream Writer ( stream , (  Charset Encoder ) encoding ) ; } else { writer = new  Output Stream Writer ( stream , (  String ) encoding ) ; } } catch (  IOException ex ) {  IOUtils . close Quietly ( writer ) ;  IOUtils . close Quietly ( stream ) ; if ( file Existed Already == _ BOOL ) {  File Utils . delete Quietly ( file ) ; } throw ex ; } catch (  Runtime Exception ex ) {  IOUtils . close Quietly ( writer ) ;  IOUtils . close Quietly ( stream ) ; if ( file Existed Already == _ BOOL ) {  File Utils . delete Quietly ( file ) ; } throw ex ; } return writer ; }
public  Bayes Estimator Editor (  Bayes Estimator Wrapper bayes Est Wrapper ) { this ( bayes Est Wrapper . get Estimated Bayes Im ( ) , bayes Est Wrapper . get Data Set ( ) ) ; }
public void mark Key For Preload ( int idx ) { if ( preload Keys == null ) preload Keys = new  Bit Set ( ) ; preload Keys . set ( idx , _ BOOL ) ; }
public static int id (  String token ) { long attempt_read_lock = lock . try Optimistic Read ( ) ; if ( string To Id . contains Key ( token ) ) { int result Id = string To Id . get ( token ) ; if ( lock . validate ( attempt_read_lock ) ) { return result Id ; } } long read_lock_stamp = lock . read Lock ( ) ; try { if ( string To Id . contains Key ( token ) ) { return string To Id . get ( token ) ; } } finally { lock . unlock Read ( read_lock_stamp ) ; } long write_lock_stamp = lock . write Lock ( ) ; try { if ( string To Id . contains Key ( token ) ) { return string To Id . get ( token ) ; } int id = id To String . size ( ) * (  Format Utils . is Nonterminal ( token ) ? - _ NUM : _ NUM ) ; for (  NGram Language Model lm :  LMs ) lm . register Word ( token ,  Math . abs ( id ) ) ; id To String . add ( token ) ; string To Id . put ( token , id ) ; return id ; } finally { lock . unlock Write ( write_lock_stamp ) ; } }
protected boolean apply Peephole Branch Opts (  IR ir ) { boolean did Something = _ BOOL ; for (  Enumeration <  Basic Block > e = ir . get Basic Blocks ( ) ; e . has More Elements ( ) ; ) {  Basic Block bb = e . next Element ( ) ; if ( ! bb . is Empty ( ) ) { for (  Enumeration <  Instruction > ie = bb . enumerate Branch Instructions ( ) ; ie . has More Elements ( ) ; ) {  Instruction s = ie . next Element ( ) ; if ( optimize Branch Instruction ( ir , s , bb ) ) { did Something = _ BOOL ; ie = bb . enumerate Branch Instructions ( ) ; } } } } return did Something ; }
public static void sleep ( long sleep Time ) { try {  Thread . sleep ( sleep Time ) ; } catch (  Interrupted Exception e ) {  LOG . error ( _ STR ) ; } }
@  Suppress Warnings ( _ STR ) public void add Value (  Object v , float b ) { if ( value == null ) { if ( v instanceof  Collection ) {  Collection <  Object > c = new  Array List < > ( _ NUM ) ; for (  Object o : (  Collection <  Object > ) v ) { c . add ( o ) ; } set Value ( c , b ) ; } else { set Value ( v , b ) ; } return ; } boost *= b ;  Collection <  Object > vals = null ; if ( value instanceof  Collection ) { vals = (  Collection <  Object > ) value ; } else { vals = new  Array List < > ( _ NUM ) ; vals . add ( value ) ; value = vals ; } if ( v instanceof  Iterable ) { for (  Object o : (  Iterable <  Object > ) v ) { vals . add ( o ) ; } } else if ( v instanceof  Object [ ] ) { for (  Object o : (  Object [ ] ) v ) { vals . add ( o ) ; } } else { vals . add ( v ) ; } }
@  Override public void remove Request ( int interrupt Number ) { synchronized ( interrupt Request Queue ) {  Interrupt Request request To Remove = null ; for (  Interrupt Request interrupt Request : interrupt Request Queue ) { if ( interrupt Request . get Interrupt Number ( ) == interrupt Number ) { request To Remove = interrupt Request ; break ; } } if ( request To Remove != null ) { interrupt Request Queue . remove ( request To Remove ) ; } } }
@  Override public final void on Heatmap Failed ( ) { m Update Pending = _ BOOL ; }
public static <  T extends  Related Resource Rep >  T find Ref (  Collection <  T > resources ,  URI id ) { if ( ( resources != null ) && ( id != null ) ) { for (  T resource : resources ) { if ( id . equals ( id ( resource ) ) ) { return resource ; } } } return null ; }
public long object Field Offset (  Field field ) { if (  Modifier . is Static ( field . get Modifiers ( ) ) ) { throw new  Illegal Argument Exception ( _ STR ) ; } return object Field Offset0 ( field ) ; }
protected synchronized void read ( long offset , byte [ ] b ) throws  IOException { if ( byte Buffer != null ) { byte Buffer . position ( ( int ) offset ) ; byte Buffer . get ( b ) ; } else { throw new  IOException ( _ STR + get Path ( ) + _ STR ) ; } }
public  Log Entry (  String timestamp ,  String contents , boolean suppress Blanks ) { this . timestamp = timestamp ; this . contents = contents . trim ( ) ; this . suppress Blanks = suppress Blanks ; }
public  Server Managed Object Decoding Exception (  Server Managed Object < ? > partial Managed Object ,  Collection <  Property Exception > causes ) { super ( create Message ( partial Managed Object , causes ) ) ; this . partial Managed Object = partial Managed Object ; this . causes =  Collections . unmodifiable List ( new  Linked List <  Property Exception > ( causes ) ) ; }
public  Edge find Edge (  Coordinate p0 ,  Coordinate p1 ) { for ( int i = _ NUM ; i < edges . size ( ) ; i ++ ) {  Edge e = (  Edge ) edges . get ( i ) ;  Coordinate [ ] e Coord = e . get Coordinates ( ) ; if ( p0 . equals ( e Coord [ _ NUM ] ) && p1 . equals ( e Coord [ _ NUM ] ) ) return e ; } return null ; }
private char choose Next Character ( final  Int Unary Operator random In Range , final  String sequence ) throws  No Such Element Exception { final  Map <  Character ,  Integer > probabilities = sequence Probabilities . get ( sequence ) ; if ( probabilities == null ) { throw new  No Such Element Exception ( _ STR ) ; }  Integer highest Probability = null ; final  List <  Character > highest Strings = new  Array List < > ( ) ; for ( final  Map .  Entry <  Character ,  Integer > entry : probabilities . entry Set ( ) ) { if ( highest Probability == null ) { highest Strings . add ( entry . get Key ( ) ) ; highest Probability = entry . get Value ( ) ; } else { if ( entry . get Value ( ) > highest Probability ) { highest Strings . clear ( ) ; highest Strings . add ( entry . get Key ( ) ) ; highest Probability = entry . get Value ( ) ; } else { highest Strings . add ( entry . get Key ( ) ) ; } } } final int random Index = random In Range . apply As Int ( highest Strings . size ( ) ) ; return highest Strings . get ( random Index ) ; }
protected final void report Issue (  Health Issue health Issue ) {  Event Bus event Bus ; synchronized ( m Lock ) { if ( m Health Event Bus == null ) {  LOG . w ( _ STR + _ STR , health Issue . to String ( ) ) ; return ; } m Active Issues . add ( health Issue ) ; event Bus = m Health Event Bus ; } event Bus . post ( health Issue . discovered ) ; }
private static void warm Up Pool (  ODatabase Document Pool pool ,  String db URL ,  String user ,  String password , int min Size ) { logger . trace ( _ STR ,  Integer . value Of ( min Size ) ) ;  List <  ODatabase Document Tx > list = new  Array List <  ODatabase Document Tx > ( ) ; for ( int count = _ NUM ; count < min Size ; count ++ ) { logger . trace ( _ STR ,  Integer . value Of ( count ) ) ; try { list . add ( pool . acquire ( db URL , user , password ) ) ; } catch (  Exception ex ) { logger . warn ( _ STR ,  Integer . value Of ( count ) , ex ) ; } } for (  ODatabase Document Tx entry : list ) { try { if ( entry != null ) { entry . close ( ) ; } } catch (  Exception ex ) { logger . warn ( _ STR , entry , ex ) ; } } }
@  Override public void agg (  Object new Val ) { if ( new Val instanceof byte [ ] ) {  Byte Buffer buffer =  Byte Buffer . wrap ( ( byte [ ] ) new Val ) ; buffer . rewind ( ) ; while ( buffer . has Remaining ( ) ) { byte [ ] value Byte = new byte [ buffer . get Int ( ) ] ; buffer . get ( value Byte ) ;  Big Decimal value Big Decimal =  Data Type Util . byte To Big Decimal ( value Byte ) ; agg Val = agg Val . add ( value Big Decimal ) ; count += buffer . get Double ( ) ; first Time = _ BOOL ; } return ; } if ( first Time ) { agg Val = (  Big Decimal ) new Val ; first Time = _ BOOL ; } else { agg Val = agg Val . add ( (  Big Decimal ) new Val ) ; } count ++ ; }
protected  HSSFRich Text String escape Column Value ( final  Object raw Value ) { if ( raw Value == null ) { return null ; }  String return String =  Object Utils . to String ( raw Value ) ; return String =  String Escape Utils . escape Java (  String Utils . trim To Empty ( return String ) ) ; return String =  String Utils . replace (  String Utils . trim ( return String ) , _ STR , _ STR ) ; return String =  String Utils . replace (  String Utils . trim ( return String ) , _ STR , _ STR ) ; return String =  String Escape Utils . unescape Java ( return String ) ; return String = remove Html Tags And Spaces ( return String ) ; return new  HSSFRich Text String ( return String ) ; }
public boolean is Entity Decl In External Subset (  String entity Name ) {  Entity entity = (  Entity ) f Entities . get ( entity Name ) ; if ( entity == null ) { return _ BOOL ; } return entity . is Entity Decl In External Subset ( ) ; }
public void process Key Event (  Key Event evt ) { if ( evt . get Key Code ( ) ==  Key Event .  VK_ UP || evt . get Key Code ( ) ==  Key Event .  VK_ DOWN ) evt . consume ( ) ; super . process Key Event ( evt ) ; if ( dict != null ) { switch ( evt . get ID ( ) ) { case  Key Event .  KEY_ PRESSED : switch ( evt . get Key Code ( ) ) { case  Key Event .  VK_ UP : if ( popup != null ) entry List . decrement Selection ( ) ; else show Popup ( dict . iterator ( ) ) ; break ; case  Key Event .  VK_ DOWN : if ( popup != null ) entry List . increment Selection ( ) ; else show Popup ( dict . iterator ( ) ) ; break ; case  Key Event .  VK_ ESCAPE : if ( popup != null ) { hide Popup ( ) ; select All ( ) ; } break ; } break ; case  Key Event .  KEY_ TYPED : switch ( evt . get Key Char ( ) ) { case  Key Event .  VK_ ENTER : break ; default : auto Complete Input ( ) ; } } } }
public void add Request Header (  String key ,  String value ) { if ( user Headers == null ) { user Headers = new  Hashtable ( ) ; } if ( key . equals Ignore Case ( _ STR ) ) { set Content Type ( value ) ; } else { user Headers . put ( key , value ) ; } }
public boolean is Completed ( ) { for (  Aborting Runnable ar : tasks ) { synchronized ( ar ) { if ( ! ar . done ) { return _ BOOL ; } } } return _ BOOL ; }
default  Byte Buffer serialize (  H type Handler ,  T value ) {  Byte Buffer buffer =  Byte Buffer . allocate ( size ( type Handler , value ) ) ; serialize ( type Handler , value , buffer ) ; return buffer ; }
@  Contract ( pure = _ BOOL ) public static int difference ( @  Not Null  String s1 , @  Not Null  String s2 ) { int [ ] [ ] a = new int [ s1 . length ( ) ] [ s2 . length ( ) ] ; for ( int i = _ NUM ; i < s1 . length ( ) ; i ++ ) { a [ i ] [ _ NUM ] = i ; } for ( int j = _ NUM ; j < s2 . length ( ) ; j ++ ) { a [ _ NUM ] [ j ] = j ; } for ( int i = _ NUM ; i < s1 . length ( ) ; i ++ ) { for ( int j = _ NUM ; j < s2 . length ( ) ; j ++ ) { a [ i ] [ j ] =  Math . min (  Math . min ( a [ i - _ NUM ] [ j - _ NUM ] + ( s1 . char At ( i ) == s2 . char At ( j ) ? _ NUM : _ NUM ) , a [ i - _ NUM ] [ j ] + _ NUM ) , a [ i ] [ j - _ NUM ] + _ NUM ) ; } } return a [ s1 . length ( ) - _ NUM ] [ s2 . length ( ) - _ NUM ] ; }
private void append Time Zone (  String Buffer buffer , int count , boolean general Time Zone ) { if ( general Time Zone ) {  Time Zone tz = calendar . get Time Zone ( ) ; boolean daylight = ( calendar . get (  Calendar .  DST_ OFFSET ) != _ NUM ) ; int style = count < _ NUM ?  Time Zone .  SHORT :  Time Zone .  LONG ; if ( ! format Data . custom Zone Strings ) { buffer . append ( tz . get Display Name ( daylight , style , format Data . locale ) ) ; return ; }  String custom =  Time Zone Names . get Display Name ( format Data . zone Strings , tz . get ID ( ) , daylight , style ) ; if ( custom != null ) { buffer . append ( custom ) ; return ; } } append Numeric Time Zone ( buffer , count , general Time Zone ) ; }
public boolean on Touch Event (  Motion Event event ) { try { int pointer Count = multi Touch Supported ? (  Integer ) m_get Pointer Count . invoke ( event ) : _ NUM ; if ( get Mode ( ) ==  MODE_ NOTHING && ! handle Single Touch Events && pointer Count == _ NUM ) return _ BOOL ; int action = event . get Action ( ) ; int hist Len = event . get History Size ( ) / pointer Count ; for ( int hist Idx = _ NUM ; hist Idx <= hist Len ; hist Idx ++ ) { boolean processing Hist = hist Idx < hist Len ; if ( ! multi Touch Supported || pointer Count == _ NUM ) { x Vals [ _ NUM ] = processing Hist ? event . get Historical X ( hist Idx ) : event . get X ( ) ; y Vals [ _ NUM ] = processing Hist ? event . get Historical Y ( hist Idx ) : event . get Y ( ) ; pressure Vals [ _ NUM ] = processing Hist ? event . get Historical Pressure ( hist Idx ) : event . get Pressure ( ) ; } else { int num Pointers =  Math . min ( pointer Count ,  MAX_ TOUCH_ POINTS ) ; for ( int ptr Idx = _ NUM ; ptr Idx < num Pointers ; ptr Idx ++ ) { int ptr Id = (  Integer ) m_get Pointer Id . invoke ( event , ptr Idx ) ; pointer Ids [ ptr Idx ] = ptr Id ; x Vals [ ptr Idx ] = (  Float ) ( processing Hist ? m_get Historical X . invoke ( event , ptr Idx , hist Idx ) : m_get X . invoke ( event , ptr Idx ) ) ; y Vals [ ptr Idx ] = (  Float ) ( processing Hist ? m_get Historical Y . invoke ( event , ptr Idx , hist Idx ) : m_get Y . invoke ( event , ptr Idx ) ) ; pressure Vals [ ptr Idx ] = (  Float ) ( processing Hist ? m_get Historical Pressure . invoke ( event , ptr Idx , hist Idx ) : m_get Pressure . invoke ( event , ptr Idx ) ) ; } } decode Touch Event ( pointer Count , x Vals , y Vals , pressure Vals , pointer Ids , processing Hist ?  Motion Event .  ACTION_ MOVE : action , processing Hist ? _ BOOL : action !=  Motion Event .  ACTION_ UP && ( action & ( ( _ NUM <<  ACTION_ POINTER_ INDEX_ SHIFT ) - _ NUM ) ) !=  ACTION_ POINTER_ UP && action !=  Motion Event .  ACTION_ CANCEL , processing Hist ? event . get Historical Event Time ( hist Idx ) : event . get Event Time ( ) ) ; } return _ BOOL ; } catch (  Exception e ) {  Log . e (  TAG , _ STR , e ) ; return _ BOOL ; } }
public void write Golomb ( int divisor , int value ) throws  IOException { int q = value / divisor ; for ( int i = _ NUM ; i < q ; i ++ ) { write Bit ( _ BOOL ,  MAX_ PROBABILITY / _ NUM ) ; } write Bit ( _ BOOL ,  MAX_ PROBABILITY / _ NUM ) ; int r = value - q * divisor ; int bit = _ NUM -  Integer . number Of Leading Zeros ( divisor - _ NUM ) ; if ( r < ( ( _ NUM << bit ) - divisor ) ) { bit -- ; } else { r += ( _ NUM << bit ) - divisor ; } for ( ; bit >= _ NUM ; bit -- ) { write Bit ( ( ( r > > > bit ) & _ NUM ) == _ NUM ,  MAX_ PROBABILITY / _ NUM ) ; } }
public static int [ ] create Normalized Map ( int [ ] values , byte [ ] levels , int start , int limit ) { if ( values != null ) { if ( start != _ NUM || limit != values . length ) { boolean copy Range , canonical ; byte primary Level ; if ( levels == null ) { primary Level = ( byte ) _ NUM ; copy Range = _ BOOL ; canonical = _ BOOL ; } else { if ( levels [ start ] == levels [ limit - _ NUM ] ) { primary Level = levels [ start ] ; canonical = ( primary Level & ( byte ) _ NUM ) == _ NUM ; int i ; for ( i = start ; i < limit ; i ++ ) { if ( levels [ i ] < primary Level ) { break ; } if ( canonical ) { canonical = levels [ i ] == primary Level ; } } copy Range = ( i == limit ) ; } else { copy Range = _ BOOL ; primary Level = ( byte ) _ NUM ; canonical = _ BOOL ; } } if ( copy Range ) { if ( canonical ) { return null ; } int [ ] result = new int [ limit - start ] ; int base Value ; if ( ( primary Level & ( byte ) _ NUM ) != _ NUM ) { base Value = values [ limit - _ NUM ] ; } else { base Value = values [ start ] ; } if ( base Value == _ NUM ) {  System . arraycopy ( values , start , result , _ NUM , limit - start ) ; } else { for ( int j = _ NUM ; j < result . length ; j ++ ) { result [ j ] = values [ j + start ] - base Value ; } } return result ; } else { return compute Contiguous Order ( values , start , limit ) ; } } else { return values ; } } return null ; }
private int min ( int a , int b ) { if ( a < b ) return a ; return b ; }
public void add Tree Model Listener (  Tree Model Listener l ) { tree Model Listeners . add Element ( l ) ; }
public static  URIName name Constraint (  Der Value value ) throws  IOException {  URI uri ;  String name = value . get IA5 String ( ) ; try { uri = new  URI ( name ) ; } catch (  URISyntax Exception use ) { throw new  IOException ( _ STR + name , use ) ; } if ( uri . get Scheme ( ) == null ) {  String host = uri . get Scheme Specific Part ( ) ; try {  DNSName host DNS ; if ( host . starts With ( _ STR ) ) { host DNS = new  DNSName ( host . substring ( _ NUM ) ) ; } else { host DNS = new  DNSName ( host ) ; } return new  URIName ( uri , host , host DNS ) ; } catch (  IOException ioe ) { throw new  IOException ( _ STR + name , ioe ) ; } } else { throw new  IOException ( _ STR + _ STR + name ) ; } }
public  Projected Stream add View (  String namespace ,  String name ,  Expression ... parameters ) { views . add (  View . create ( namespace , name , parameters ) ) ; return this ; }
protected int read (  Speech Record recorder , byte [ ] buffer ) { int len = buffer . length ; int num Of Bytes = recorder . read ( buffer , _ NUM , len ) ; int status = get Status ( num Of Bytes , len ) ; if ( status == _ NUM && num Of Bytes >= _ NUM ) {  System . arraycopy ( buffer , _ NUM , m Recording , m Recorded Length , num Of Bytes ) ; m Recorded Length += len ; } return status ; }
public void touch ( ) { next Check =  System . current Time Millis ( ) + (  MILLIS_ PER_ SECOND * modification Check Interval ) ; }
void tidy ( int window Start Year ) { if ( last Rule List . size ( ) == _ NUM ) { throw new  Illegal State Exception ( _ STR ) ; } if ( window End . equals (  Local Date Time .  MAX ) ) { max Last Rule Start Year =  Math . max ( max Last Rule Start Year , window Start Year ) + _ NUM ; for (  TZRule last Rule : last Rule List ) { add Rule ( last Rule . year , max Last Rule Start Year , last Rule . month , last Rule . day Of Month Indicator , last Rule . day Of Week , last Rule . time , last Rule . time End Of Day , last Rule . time Definition , last Rule . saving Amount Secs ) ; last Rule . year = max Last Rule Start Year + _ NUM ; } if ( max Last Rule Start Year ==  YEAR_ MAX_ VALUE ) { last Rule List . clear ( ) ; } else { max Last Rule Start Year ++ ; } } else { int end Year = window End . get Year ( ) ; for (  TZRule last Rule : last Rule List ) { add Rule ( last Rule . year , end Year + _ NUM , last Rule . month , last Rule . day Of Month Indicator , last Rule . day Of Week , last Rule . time , last Rule . time End Of Day , last Rule . time Definition , last Rule . saving Amount Secs ) ; } last Rule List . clear ( ) ; max Last Rule Start Year =  YEAR_ MAX_ VALUE ; }  Collections . sort ( rule List ) ;  Collections . sort ( last Rule List ) ; if ( rule List . size ( ) == _ NUM && fixed Saving Amount Secs == null ) { fixed Saving Amount Secs = _ NUM ; } }
protected int hash (  Object o ) { int h = o == null ? _ NUM : o . hash Code ( ) ; h += ( h << _ NUM ) ^ _ NUM ; h ^= ( h > > > _ NUM ) ; h += ( h << _ NUM ) ; h ^= ( h > > > _ NUM ) ; h += ( h << _ NUM ) + ( h << _ NUM ) ; return h ^ ( h > > > _ NUM ) ; }
public boolean scan And Generate ( ) throws  Interrupted Exception ,  Replicator Exception ,  SQLException ,  IOException {  Writer writer = null ; try { scanner . parse Template ( template File ) ; } catch (  Replicator Exception e ) { println ( e . get Message ( ) ) ; return _ BOOL ; } if ( rename Definitions != null ) { try { scanner . parse Rename Definitions ( rename Definitions ) ; } catch (  IOException e ) { println ( e . get Message ( ) ) ; return _ BOOL ; } } if ( table File != null ) tables = table File To Regex ( table File ) ; if ( out File == null ) writer = new  String Writer ( ) ; else writer = new  Buffered Writer ( new  File Writer ( new  File ( out File ) ) ) ; if ( tables != null && out File != null ) println ( _ STR + tables ) ; scanner . scan ( tables , template Options , writer ) ; writer . flush ( ) ; writer . close ( ) ; if ( out File == null ) println ( writer . to String ( ) ) ; else println ( _ STR + out File ) ; return _ BOOL ; }
private  Bitmap create Photo Thumbnail (  Input Stream image Stream , int rotation Angle ) {  Bitmap bitmap Ret Value = null ; final int  MAX_ SIZE = _ NUM ,  SAMPLE_ SIZE = _ NUM ,  QUALITY = _ NUM ;  Bitmap Factory .  Options options = new  Bitmap Factory .  Options ( ) ; options . in Preferred Config =  Bitmap .  Config .  ARGB_8888 ; options . out Width = - _ NUM ; options . out Height = - _ NUM ; try {  Input Stream stream =  Image Utils . resize Image ( image Stream ,  MAX_ SIZE ,  SAMPLE_ SIZE ,  QUALITY ) ; image Stream . close ( ) ; bitmap Ret Value =  Bitmap Factory . decode Stream ( stream , null , options ) ; if ( _ NUM != rotation Angle ) { android . graphics .  Matrix bitmap Matrix = new android . graphics .  Matrix ( ) ; bitmap Matrix . post Rotate ( rotation Angle ) ; bitmap Ret Value =  Bitmap . create Bitmap ( bitmap Ret Value , _ NUM , _ NUM , bitmap Ret Value . get Width ( ) , bitmap Ret Value . get Height ( ) , bitmap Matrix , _ BOOL ) ; }  System . gc ( ) ; } catch (  Out Of Memory Error e ) {  Log . e (  LOG_ TAG , _ STR ) ; } catch (  Exception e ) {  Log . e (  LOG_ TAG , _ STR + e . get Message ( ) ) ; } return bitmap Ret Value ; }
public  Object Name pre Register (  MBean Server server ,  Object Name name ) throws  Exception { if ( name == null ) { if ( config == null ) return null ; if ( config . get Name ( ) == null ) return null ; name =  Scan Manager . make MBean Name (  Scan Dir Config MXBean . class , config . get Name ( ) ) ; } object Name = name ; mbean Server = server ; synchronized ( this ) { configname = name . get Key Property ( _ STR ) ; if ( config == null ) config = new  Scan Manager Config ( configname ) ; else config = config . copy ( configname ) ; } return name ; }
public static  String extract Group Name (  String group Name ) {  Pattern p =  Pattern . compile ( _ STR ) ;  Matcher matcher = p . matcher ( group Name ) ; if ( matcher . matches ( ) ) { return matcher . group ( _ NUM ) ; } return group Name ; }
private static byte [ ] convert Audio Endianness ( byte [ ] audio Data , boolean two Byte Samples ) {  Byte Buffer out =  Byte Buffer . allocate ( audio Data . length ) ; out . order (  Byte Order . native Order ( ) ) ;  Byte Buffer in =  Byte Buffer . wrap ( audio Data ) ; in . order (  Byte Order .  LITTLE_ ENDIAN ) ; if ( two Byte Samples ) {  Short Buffer out Short = out . as Short Buffer ( ) ;  Short Buffer in Short = in . as Short Buffer ( ) ; while ( in Short . has Remaining ( ) ) { out Short . put ( in Short . get ( ) ) ; } } else { while ( in . has Remaining ( ) ) { out . put ( in . get ( ) ) ; } } out . rewind ( ) ; if ( ! out . has Array ( ) ) { byte [ ] array = new byte [ out . capacity ( ) ] ; out . get ( array ) ; out . clear ( ) ; return array ; } return out . array ( ) ; }
public static boolean equals (  Collection < ? > actual ,  Object ... reference ) { final  Collection <  Object > collection = new  Hash Set < > ( ) ;  Collections . add All ( collection , reference ) ; if ( actual == collection ) { return _ BOOL ; } if ( actual == null ) { return _ BOOL ; } if ( actual . size ( ) != collection . size ( ) ) { log . warn ( _ STR + actual . size ( ) + _ STR + collection . size ( ) ) ; return _ BOOL ; } for (  Object object : actual ) { if ( ! collection . contains ( object ) ) { log . warn ( _ STR + object ) ; return _ BOOL ; } } for (  Object object : collection ) { if ( ! actual . contains ( object ) ) { log . warn ( _ STR + object ) ; return _ BOOL ; } } return _ BOOL ; }
public void put String (  String s ) { ensure Capacity ( ( s . length ( ) * _ NUM ) + _ NUM ) ;  System . arraycopy ( s . get Bytes ( ) , _ NUM , this . byte Buffer , this . position , s . length ( ) ) ; this . position += s . length ( ) ; this . byte Buffer [ this . position ++ ] = _ NUM ; }
@  Override public void external Entity Decl (  String name ,  XMLResource Identifier identifier ,  Augmentations augs ) throws  XNIException { try { if ( f Decl Handler != null ) {  String public Id = identifier . get Public Id ( ) ;  String system Id = f Resolve DTDURIs ? identifier . get Expanded System Id ( ) : identifier . get Literal System Id ( ) ; f Decl Handler . external Entity Decl ( name , public Id , system Id ) ; } } catch (  SAXException e ) { throw new  XNIException ( e ) ; } }
public  EWMA ( double alpha , long interval ,  Time Unit interval Unit ) { this . interval = interval Unit . to Nanos ( interval ) ; this . alpha = alpha ; }
private  String prepare HTMLContent For Clipboard (  String html ) { int start = html . index Of ( _ STR ) ; int end = html . index Of ( _ STR , start ) ; if ( _ NUM < start && start < end && end < html . length ( ) ) return html . substring ( _ NUM , start ) + html . substring ( end , html . length ( ) ) ; return html ; }
private static  Get Images Response check Get Images Response (  Get Images Response get Images Response ) throws  Rpc Exception { logger . info ( _ STR , get Images Response ) ; switch ( get Images Response . get Result ( ) ) { case  OK : break ; case  DATASTORE_ NOT_ FOUND : throw new  Datastore Not Found Exception ( get Images Response . get Error ( ) ) ; case  SYSTEM_ ERROR : throw new  System Error Exception ( get Images Response . get Error ( ) ) ; default : throw new  Rpc Exception (  String . format ( _ STR , get Images Response . get Result ( ) ) ) ; } return get Images Response ; }
public void schedule (  Timer Task task ,  Date when , long period ) { if ( period <= _ NUM || when . get Time ( ) < _ NUM ) { throw new  Illegal Argument Exception ( ) ; } long delay = when . get Time ( ) -  System . current Time Millis ( ) ; schedule Impl ( task , delay < _ NUM ? _ NUM : delay , period , _ BOOL ) ; }
public void ellipse ( double x , double y , double semi Major Axis , double semi Minor Axis ) { if ( semi Major Axis < _ NUM ) throw new  Illegal Argument Exception ( _ STR ) ; if ( semi Minor Axis < _ NUM ) throw new  Illegal Argument Exception ( _ STR ) ; double xs = scale X ( x ) ; double ys = scale Y ( y ) ; double ws = factor X ( _ NUM * semi Major Axis ) ; double hs = factor Y ( _ NUM * semi Minor Axis ) ; if ( ws <= _ NUM && hs <= _ NUM ) pixel ( x , y ) ; else offscreen . draw ( new  Ellipse2 D .  Double ( xs - ws / _ NUM , ys - hs / _ NUM , ws , hs ) ) ; draw ( ) ; }
public void request Cursor ( java . awt .  Cursor cursor ) { if ( cursor == null ) { if ( show Wait Cursor && ! waiting For Layers ) reset Cursor ( ) ; current Map Bean Cursor = null ; } else if ( this . map != null ) {  Cursor new Cursor ; if ( show Wait Cursor && waiting For Layers ) { new Cursor =  Cursor . get Predefined Cursor (  Cursor .  WAIT_ CURSOR ) ; current Map Bean Cursor = cursor ; } else new Cursor = cursor ; map . set Cursor ( new Cursor ) ; } }
private void wake Up ( ) { flush Lock . lock ( ) ; try { can Flush . signal All ( ) ; } finally { flush Lock . unlock ( ) ; } }
public static boolean is Primitive Or Wrapper (  Class clazz ) {  Assert . not Null ( clazz , _ STR ) ; return ( clazz . is Primitive ( ) || is Primitive Wrapper ( clazz ) ) ; }
private  String generate Serial Number (  String str ) { int value = str . hash Code ( ) ;  String serial Number = null ; if ( value < _ NUM ) { value = - value ; serial Number =  String . format ( _ STR , value ) ; serial Number = _ STR + serial Number ; } else { serial Number =  String . format ( _ STR , value ) ; } return serial Number ; }
public  Writable Raster create Writable Child ( int x , int y , int width , int height , int x0 , int y0 , int [ ] band List ) { if ( x < this . min X ) { throw new  Raster Format Exception ( _ STR ) ; } if ( y < this . min Y ) { throw new  Raster Format Exception ( _ STR ) ; } if ( ( x + width < x ) || ( x + width > this . min X + this . width ) ) { throw new  Raster Format Exception ( _ STR ) ; } if ( ( y + height < y ) || ( y + height > this . min Y + this . height ) ) { throw new  Raster Format Exception ( _ STR ) ; }  Sample Model sm ; if ( band List != null ) sm = sample Model . create Subset Sample Model ( band List ) ; else sm = sample Model ; int delta X = x0 - x ; int delta Y = y0 - y ; return new  Byte Interleaved Raster ( sm , data Buffer , new  Rectangle ( x0 , y0 , width , height ) , new  Point ( sample Model Translate X + delta X , sample Model Translate Y + delta Y ) , this ) ; }
private static  List <  Condition Node > create Operator ( final  Common Tree ast ) throws  Recognition Exception { final  List <  Condition Node > children = new  Array List < > ( ) ; for ( final  Object child : ast . get Children ( ) ) { children . add ( convert ( (  Common Tree ) child ) ) ; } return children ; }
public static int poisson ( double lambda ) { if ( ! ( lambda > _ NUM ) ) throw new  Illegal Argument Exception ( _ STR ) ; if (  Double . is Infinite ( lambda ) ) throw new  Illegal Argument Exception ( _ STR ) ; int k = _ NUM ; double p = _ NUM ; double  L =  Math . exp ( - lambda ) ; do { k ++ ; p *= uniform ( ) ; } while ( p >=  L ) ; return k - _ NUM ; }
private static int index Of Unicode Escape ( @  Not Null  String text , int offset ) { final int length = text . length ( ) ; for ( int i = _ NUM ; i < length ; i ++ ) { final char c = text . char At ( i ) ; if ( c != _ STR ) { continue ; } boolean is Escape = _ BOOL ; int previous Char = i - _ NUM ; while ( previous Char >= _ NUM && text . char At ( previous Char ) == _ STR ) { is Escape = ! is Escape ; previous Char -- ; } if ( ! is Escape ) { continue ; } int next Char = i ; do { next Char ++ ; if ( next Char >= length ) { break ; } } while ( text . char At ( next Char ) == _ STR ) ; if ( next Char == i + _ NUM || next Char + _ NUM >= length ) { break ; } if (  String Util . is Hex Digit ( text . char At ( next Char ) ) &&  String Util . is Hex Digit ( text . char At ( next Char + _ NUM ) ) &&  String Util . is Hex Digit ( text . char At ( next Char + _ NUM ) ) &&  String Util . is Hex Digit ( text . char At ( next Char + _ NUM ) ) ) { final int escape End = next Char + _ NUM ; if ( offset <= escape End ) { return i ; } } } return - _ NUM ; }
protected boolean play User Sound (  String sound Identifier ) {  Object sound = builtin Sounds . get ( sound Identifier ) ; if ( sound == null ) { return _ BOOL ; } return _ BOOL ; }
public void write Bundle Stream (  Bundle Stream Source source ,  Writable Byte Channel output ) throws  IOException {  Byte Buffer buffer =  Byte Buffer . allocate Direct (  INITIAL_ BUFFER ) ;  DBIDVar var =  DBIDUtil . new Var ( ) ;  Byte Buffer Serializer < ? > [ ] serializers = null ; loop : while ( _ BOOL ) {  Bundle Stream Source .  Event ev = source . next Event ( ) ; switch ( ev ) { case  NEXT_ OBJECT : if ( serializers == null ) { serializers = write Header ( source , buffer , output ) ; } if ( serializers [ _ NUM ] != null ) { if ( ! source . assign DBID ( var ) ) { throw new  Abort Exception ( _ STR ) ; }  DBID id =  DBIDUtil . deref ( var ) ; @  Suppress Warnings ( _ STR )  Byte Buffer Serializer <  DBID > ser = (  Byte Buffer Serializer <  DBID > ) serializers [ _ NUM ] ; int size = ser . get Byte Size ( id ) ; buffer = ensure Buffer ( size , buffer , output ) ; ser . to Byte Buffer ( buffer , id ) ; } for ( int i = _ NUM , j = _ NUM ; i < serializers . length ; ++ i , ++ j ) { @  Suppress Warnings ( _ STR )  Byte Buffer Serializer <  Object > ser = (  Byte Buffer Serializer <  Object > ) serializers [ i ] ; int size = ser . get Byte Size ( source . data ( j ) ) ; buffer = ensure Buffer ( size , buffer , output ) ; ser . to Byte Buffer ( buffer , source . data ( j ) ) ; } break ; case  META_ CHANGED : if ( serializers != null ) { throw new  Abort Exception ( _ STR ) ; } break ; case  END_ OF_ STREAM : break loop ; default :  LOG . warning ( _ STR + ev ) ; break ; } } if ( buffer . position ( ) > _ NUM ) { flush Buffer ( buffer , output ) ; } }
private  Lambda Form put In Cache (  Transform key ,  Lambda Form form ) { key = key . with Result ( form ) ; for ( int pass = _ NUM ; ; pass ++ ) {  Object c = lambda Form . transform Cache ; if ( c instanceof  Concurrent Hash Map ) { @  Suppress Warnings ( _ STR )  Concurrent Hash Map <  Transform ,  Transform > m = (  Concurrent Hash Map <  Transform ,  Transform > ) c ;  Transform k = m . put If Absent ( key , key ) ; if ( k == null ) return form ;  Lambda Form result = k . get ( ) ; if ( result != null ) { return result ; } else { if ( m . replace ( key , k , key ) ) { return form ; } else { continue ; } } } assert ( pass == _ NUM ) ; synchronized ( lambda Form ) { c = lambda Form . transform Cache ; if ( c instanceof  Concurrent Hash Map ) continue ; if ( c == null ) { lambda Form . transform Cache = key ; return form ; }  Transform [ ] ta ; if ( c instanceof  Transform ) {  Transform k = (  Transform ) c ; if ( k . equals ( key ) ) {  Lambda Form result = k . get ( ) ; if ( result == null ) { lambda Form . transform Cache = key ; return form ; } else { return result ; } } else if ( k . get ( ) == null ) { lambda Form . transform Cache = key ; return form ; } ta = new  Transform [  MIN_ CACHE_ ARRAY_ SIZE ] ; ta [ _ NUM ] = k ; lambda Form . transform Cache = ta ; } else { ta = (  Transform [ ] ) c ; } int len = ta . length ; int stale = - _ NUM ; int i ; for ( i = _ NUM ; i < len ; i ++ ) {  Transform k = ta [ i ] ; if ( k == null ) { break ; } if ( k . equals ( key ) ) {  Lambda Form result = k . get ( ) ; if ( result == null ) { ta [ i ] = key ; return form ; } else { return result ; } } else if ( stale < _ NUM && k . get ( ) == null ) { stale = i ; } } if ( i < len || stale >= _ NUM ) { } else if ( len <  MAX_ CACHE_ ARRAY_ SIZE ) { len =  Math . min ( len * _ NUM ,  MAX_ CACHE_ ARRAY_ SIZE ) ; ta =  Arrays . copy Of ( ta , len ) ; lambda Form . transform Cache = ta ; } else {  Concurrent Hash Map <  Transform ,  Transform > m = new  Concurrent Hash Map < > (  MAX_ CACHE_ ARRAY_ SIZE * _ NUM ) ; for (  Transform k : ta ) { m . put ( k , k ) ; } lambda Form . transform Cache = m ; continue ; } int idx = ( stale >= _ NUM ) ? stale : i ; ta [ idx ] = key ; return form ; } } }
public boolean is Shutdown ( ) { return shutdown . get ( ) ; }
public  Edge Effect (  Context context ) { m Paint . set Anti Alias ( _ BOOL ) ; final int theme Color =  Color .  RED ; m Paint . set Color ( ( theme Color & _ NUM ) | _ NUM ) ; m Paint . set Style (  Paint .  Style .  FILL ) ; m Paint . set Xfermode ( new  Porter Duff Xfermode (  Porter Duff .  Mode .  SRC_ ATOP ) ) ; m Interpolator = new  Decelerate Interpolator ( ) ; }
public static java . util .  Date parse Date Time (  String date ,  String format ,  String locale ,  String time Zone ) {  Simple Date Format date Format = get Date Format ( format , locale , time Zone ) ; try { synchronized ( date Format ) { return date Format . parse ( date ) ; } } catch (  Exception e ) { throw  Db Exception . get (  Error Code .  PARSE_ ERROR_1 , e , date ) ; } }
protected  Key Pair Generator (  String algorithm ) { this . algorithm = algorithm ; }
private void create Gui ( ) { final  JPanel top Panel = new  JPanel ( new  Border Layout ( ) ) ; final  JPanel inner Top Panel = new  JPanel ( new  Border Layout ( ) ) ; top Panel . add ( inner Top Panel ) ; inner Top Panel . add ( m_std Edit Panel ) ; inner Top Panel . add ( m_debugger Panel ,  Border Layout .  SOUTH ) ; final  JPanel button Panel = new  JPanel ( new  Grid Layout ( _ NUM , _ NUM ) ) ; button Panel . set Border ( new  Empty Border ( _ NUM , _ NUM , _ NUM , _ NUM ) ) ; button Panel . add ( new  JPanel ( ) ) ; button Panel . add ( m_save Button ) ; top Panel . add ( button Panel ,  Border Layout .  SOUTH ) ; final  JPanel inner Sp = new  JPanel ( new  Border Layout ( ) ) ; m_middle Panel . set Preferred Size ( new  Dimension ( m_middle Panel . get Preferred Size ( ) . width , _ NUM ) ) ; inner Sp . add ( m_middle Panel ,  Border Layout .  NORTH ) ; inner Sp . add ( m_bottom Panel ,  Border Layout .  CENTER ) ; final  JSplit Pane outer Sp = new  JSplit Pane (  JSplit Pane .  VERTICAL_ SPLIT , _ BOOL , top Panel , inner Sp ) ; outer Sp . set One Touch Expandable ( _ BOOL ) ; outer Sp . set Divider Location ( outer Sp . get Minimum Divider Location ( ) ) ; outer Sp . set Resize Weight ( _ NUM ) ; final  JPanel inner Panel = new  JPanel ( new  Border Layout ( ) ) ; inner Panel . add ( outer Sp ) ; add ( inner Panel ) ; }
private void validate Group Acls (  DBGroup target Group ,  List <  DBAcl > acls ) throws  Invalid Request Exception ,  SQLException { if ( acls . is Empty ( ) ) { throw new  Invalid Request Exception ( _ STR ) ; }  Hash Set <  Integer > unique Member Identities = new  Hash Set < > ( ) ;  Hash Set <  Integer > unique Member Groups = new  Hash Set < > ( ) ; for (  DBAcl acl : acls ) { if ( acl . get Group Id ( ) . get Id ( ) != target Group . get Id ( ) ) { throw new  Invalid Request Exception ( _ STR ) ; } boolean is Identity Acl = acl . get Member Identity Id ( ) != null ; boolean is Group Acl = acl . get Member Group Id ( ) != null ; if ( ! ( is Identity Acl ^ is Group Acl ) ) { throw new  Invalid Request Exception ( _ STR + _ STR + is Identity Acl + _ STR + is Group Acl ) ; } if ( is Identity Acl ) { assert ! is Group Acl ; if ( ! unique Member Identities . add ( acl . get Member Identity Id ( ) . get Id ( ) ) ) { throw new  Invalid Request Exception ( _ STR + acl . get Member Identity Id ( ) . get Id ( ) ) ; } } else { assert ! is Identity Acl ; if ( ! unique Member Groups . add ( acl . get Member Group Id ( ) . get Id ( ) ) ) { throw new  Invalid Request Exception ( _ STR + acl . get Member Group Id ( ) . get Id ( ) ) ; } } } if ( ! unique Member Identities . is Empty ( ) ) { if (  DBIdentity . get User Names From Ids ( manager , unique Member Identities ) . size ( ) != unique Member Identities . size ( ) ) { throw new  Invalid Request Exception ( _ STR ) ; } } if ( ! unique Member Groups . is Empty ( ) ) {  Query Builder <  DBGroup ,  Integer > group Query = get Directly Accessible Groups Query ( unique Member Groups ) ; if ( group Query . count Of ( ) != unique Member Groups . size ( ) ) { throw new  Invalid Request Exception ( _ STR ) ; } } }
public  Http Request content Length ( final  String content Length ) { return content Length (  Integer . parse Int ( content Length ) ) ; }
static public  String handle (  String request ) {  String Builder response = new  String Builder ( ) ;  JSONTokener tokener = new  JSONTokener ( request ) ; try {  Object token = tokener . next Value ( ) ; response . append ( _ STR ) ; if ( token instanceof  JSONArray ) {  JSONArray array = (  JSONArray ) token ; for ( int i = _ NUM ; i < array . length ( ) ; i ++ ) {  JSONObject object = (  JSONObject ) array . get ( i ) ; response . append ( _ STR + object . get String ( _ STR ) + _ STR ) ; exec ( object , response ) ; if ( i != array . length ( ) - _ NUM ) response . append ( _ STR ) ; } } else if ( token instanceof  JSONObject ) {  JSONObject object = (  JSONObject ) token ; response . append ( _ STR + object . get String ( _ STR ) + _ STR ) ; exec ( object , response ) ; } response . append ( _ STR ) ; } catch (  Exception e ) {  Log . e (  TAG , _ STR + request ) ; e . print Stack Trace ( ) ; return _ STR ; }  Log . d (  TAG , _ STR + request ) ;  Log . d (  TAG , _ STR + response . to String ( ) ) ; return response . to String ( ) ; }
public  Follower Info (  Follower .  Type type ,  String stream ,  List <  Follower > followers , int total ) { this . type = type ; this . followers = followers ; this . total = total ; this . time =  System . current Time Millis ( ) ; this . stream = stream ; this . request Error = _ BOOL ; this . request Error Description = null ; }
void remove View (  View view ) { int index = m Callback . index Of Child ( view ) ; if ( index < _ NUM ) { return ; } m Callback . remove View At ( index ) ; if ( m Bucket . remove ( index ) ) { m Hidden Views . remove ( view ) ; } if (  DEBUG ) {  Log . d (  TAG , _ STR + index + _ STR + this ) ; } }
public static byte [ ] hex String To Byte Array2 ( final  String config ) { final int offset = _ NUM ; final int len = config . length ( ) / _ NUM ; final byte [ ] ret = new byte [ len + _ NUM ] ; for ( int i = offset ; i < ret . length ; i ++ ) { final char first = config . char At ( ( i - offset ) * _ NUM ) ; final char second = config . char At ( ( i - offset ) * _ NUM + _ NUM ) ; int value =  Integer . parse Int ( new  String ( new byte [ ] { ( byte ) first } ) , _ NUM ) << _ NUM ; value += second ; ret [ i ] = ( byte )  Integer . parse Int ( new  String ( new byte [ ] { ( byte ) second } ) , _ NUM ) ; } final  Data Buffer databuffer = new  Data Buffer ( ret , _ NUM , _ NUM ) ; databuffer . write Int ( len ) ; return ret ; }
private void serialize Test Summary (  KXml Serializer serializer ) throws  IOException { serializer . start Tag ( ns ,  SUMMARY_ TAG ) ; serializer . attribute ( ns ,  HAS_ CRASH_ ATTR , get Has Crash ( ) ) ; serializer . attribute ( ns ,  CRASH_ FILE_ ATTR , get Crash File ( ) ) ; serializer . attribute ( ns ,  DURATION_ ATTR , get Duration ( ) ) ; serializer . attribute (  Cts Xml Result Reporter . ns ,  RESULT_ ATTR , get Result ( ) ) ; serializer . end Tag ( ns ,  SUMMARY_ TAG ) ; }
@  Override public boolean is Component Enabled (  Resolve Info resolve Info ) { if ( resolve Info != null && resolve Info . service Info != null && !  Text Utils . is Empty ( resolve Info . service Info . package Name ) ) { if ( m Permitted Package Names == null || is System App ( resolve Info . service Info . application Info ) ) { return _ BOOL ; } else { return m Permitted Package Names . contains ( resolve Info . service Info . package Name ) ; } } return _ BOOL ; }
public  Verified Download (  Logger log ,  Artifact Context context ,  File Content Store file Content Store ,  Node node ) { this . log = log ; this . context = context ; parent =  Node Utils . first Parent ( node ) ; if ( parent == null ) { throw new  Illegal Argument Exception ( _ STR + node ) ; } this . node = node ; this . file Content Store = file Content Store ;  File f ;  File parent Dir = file Content Store . get File ( parent ) ; parent Dir . mkdirs ( ) ; try { f =  File . create Temp File ( node . get Label ( ) + _ STR , _ STR , parent Dir ) ; } catch (  IOException e ) { e . print Stack Trace ( ) ; log . debug ( _ STR + e ) ; f = new  File ( parent Dir , node . get Label ( ) +  Abstract Node Repository Manager .  VALIDATING ) ;  File Util . delete ( f ) ; } f . delete On Exit ( ) ; temp Node = parent . get Child ( f . get Name ( ) ) ; temp File = file Content Store . get File ( temp Node ) ; }
public static byte [ ] hex String To Byte ( final  String source ) { byte [ ] bytes = null ; if ( source != null ) { bytes = new byte [ source . length ( ) / _ NUM ] ; int i = _ NUM ; while ( i < bytes . length ) { bytes [ i ] = ( byte ) (  Integer . parse Int ( source . substring ( i * _ NUM , ( i + _ NUM ) * _ NUM ) , _ NUM ) ) ; i ++ ; } } return bytes ; }
@  Override protected final boolean write Data (  Byte Buffer data ) { synchronized ( guard ) {  Ls Server Packet packet = send Msg Queue . poll First ( ) ; if ( packet == null ) { return _ BOOL ; } packet . write ( this , data ) ; return _ BOOL ; } }
public synchronized boolean generate (  Projection proj ) { double up Lat ; int columns = get Columns ( ) ; int rows = get Rows ( ) ; super . clear ( ) ; set Shape ( null ) ; if ( render Type ==  RENDERTYPE_ LATLON ) { double right Lon ; right Lon = longitude + columns * horizontal Resolution ; up Lat = latitude + rows * vertical Resolution ; point1 = (  Point ) proj . forward ( up Lat , longitude , new  Point ( ) ) ; point2 = (  Point ) proj . forward ( latitude , right Lon , new  Point ( ) ) ; height = point2 . y - point1 . y ; width = point2 . x - point1 . x ; if (  Debug . debugging ( _ STR ) ) {  Debug . output ( _ STR + height + _ STR + width ) ; } } else if ( render Type ==  RENDERTYPE_ XY || render Type ==  RENDERTYPE_ OFFSET ) { width = ( int )  Math . round ( columns * horizontal Resolution ) ; height = ( int )  Math . round ( rows * vertical Resolution ) ; if ( render Type ==  RENDERTYPE_ OFFSET ) { up Lat = latitude + columns * vertical Resolution ; point1 = (  Point ) proj . forward ( up Lat , longitude , new  Point ( ) ) ; point1 . x += point . x ; point1 . y += point . y ; } else { point1 = point ; } point2 = new  Point ( point1 . x + width , point1 . y + height ) ; } else { return _ BOOL ; } if (  Debug . debugging ( _ STR ) ) {  Debug . output ( _ STR + point1 + _ STR + point2 + _ STR + height + _ STR + width ) ; } set Shape ( ) ; if ( generator != null && generator . need Generate To Render ( ) ) { add ( generator . generate ( this , proj ) ) ; } else if ( grid Objects != null ) { add ( generate Grid Objects ( proj ) ) ; } set Label Location ( get Shape ( ) , proj ) ; set Need To Regenerate ( _ BOOL ) ; return _ BOOL ; }
private final void extend Bounds ( float [ ] location ) { if ( min Limit == null ) { min Limit = new float [ dimensions ] ;  System . arraycopy ( location , _ NUM , min Limit , _ NUM , dimensions ) ; max Limit = new float [ dimensions ] ;  System . arraycopy ( location , _ NUM , max Limit , _ NUM , dimensions ) ; return ; } for ( int i = _ NUM ; i < dimensions ; i ++ ) { if (  Float . is Na N ( location [ i ] ) ) { min Limit [ i ] =  Float .  Na N ; max Limit [ i ] =  Float .  Na N ; singularity = _ BOOL ; } else if ( min Limit [ i ] > location [ i ] ) { min Limit [ i ] = location [ i ] ; singularity = _ BOOL ; } else if ( max Limit [ i ] < location [ i ] ) { max Limit [ i ] = location [ i ] ; singularity = _ BOOL ; } } }
public java . lang .  String Buffer insert ( int offset , java . lang .  Object obj ) { internal . insert ( offset , obj ) ; return this ; }
public void write Files (  IFile tla File ,  IFile cfg File ,  IProgress Monitor monitor ) throws  Core Exception { tla Buffer . append (  Resource Helper . get Module Closing Tag ( ) ) ; cfg Buffer . append (  Resource Helper . get Config Closing Tag ( ) ) ;  Resource Helper . replace Content ( tla File , tla Buffer , monitor ) ;  Resource Helper . replace Content ( cfg File , cfg Buffer , monitor ) ; }
@  Suppress Warnings ( _ STR ) private boolean execute Reveal ( @  Non Null  Deco Event event ) { if ( ( event . get Event Type ( ) !=  Deco Event .  Event Type .  EVENT_ SHOW ) && ( event . get Event Type ( ) !=  Deco Event .  Event Type .  EVENT_ HIDE ) ) { return _ BOOL ; } if ( event . get Event Type ( ) ==  Deco Event .  Event Type .  EVENT_ SHOW ) { set Visibility (  View .  VISIBLE ) ; } if ( m Chart Series != null ) { for ( int i = _ NUM ; i < m Chart Series . size ( ) ; i ++ ) { if ( ( event . get Index Position ( ) == i ) || ( event . get Index Position ( ) < _ NUM ) ) {  Chart Series chart Series = m Chart Series . get ( i ) ; chart Series . start Animate Hide Show ( event , event . get Event Type ( ) ==  Deco Event .  Event Type .  EVENT_ SHOW ) ; } } } return _ BOOL ; }
protected void on Mouse Click ( ) { if ( on Mouse Click != null ) { on Mouse Click . run ( ) ; } }
public void init All Day Heights ( ) { if ( m Max Allday Events <= m Max Unexpanded Allday Event Count ) { return ; } if ( m Show All All Day Events ) { int max ADHeight = m View Height -  DAY_ HEADER_ HEIGHT -  MIN_ HOURS_ HEIGHT ; max ADHeight =  Math . min ( max ADHeight , ( int ) ( m Max Allday Events *  MIN_ UNEXPANDED_ ALLDAY_ EVENT_ HEIGHT ) ) ; m Animate Day Event Height = max ADHeight / m Max Allday Events ; } else { m Animate Day Event Height = ( int )  MIN_ UNEXPANDED_ ALLDAY_ EVENT_ HEIGHT ; } }
private void send Response (  UUID node Id ,  Igfs Communication Message msg ) { try { send With Retries ( node Id , msg ) ; } catch (  Ignite Checked Exception e ) { if ( e . has Cause (  Cluster Topology Checked Exception . class ) ) { if ( log . is Debug Enabled ( ) ) log . debug ( _ STR + _ STR + node Id ) ; } else  U . error ( log , _ STR + node Id , e ) ; } }
public boolean show Next Notification ( ) { int i = get Selected Index ( ) ; if ( i != - _ NUM && i < get Notfication Count ( ) - _ NUM ) { model . set Selected Item ( model . get Element At ( i + _ NUM ) ) ; return _ BOOL ; } return _ BOOL ; }
@  Override public void write External (  Object Output out ) throws  IOException { super . write External ( out ) ; out . write Int (  DBIDUtil . as Integer ( routing Object ID ) ) ; out . write Double ( parent Distance ) ; out . write Double ( covering Radius ) ; }
public void add Input Node (  BNode input Node ) { if ( input Node == this ) { log . warning ( _ STR + node Id ) ; } if ( contains Cycles ( input Node ) ) { log . warning ( _ STR + input Node . get Id ( ) + _ STR + node Id ) ; } if ( this instanceof  Action Node ) { log . warning ( _ STR ) ; } if ( input Node instanceof  Utility Node ) { log . warning ( _ STR + input Node . get Id ( ) + _ STR + node Id + _ STR ) ; } add Input Node_internal ( input Node ) ; input Node . add Output Node_internal ( this ) ; }
public static  CConnection connect ( final  CDatabase Configuration configuration ) throws  Couldnt Load Driver Exception ,  Couldnt Connect Exception { check Driver ( configuration ) ; try { return new  CConnection ( configuration ) ; } catch ( final  SQLException e ) {  CUtility Functions . log Exception ( e ) ; throw new  Couldnt Connect Exception ( e , e . get Error Code ( ) , e . get SQLState ( ) ) ; } }
public  Map <  Integer ,  Set <  String > > show Topology ( ) throws  Network Device Controller Exception {  Map <  Integer ,  Set <  String > > peer Devices Map = new  Hash Map <  Integer ,  Set <  String > > ( ) ;  SSHPrompt [ ] prompts = {  SSHPrompt .  POUND ,  SSHPrompt .  GREATER_ THAN } ;  String Builder buf = new  String Builder ( ) ; send Wait For (  MDSDialog Properties . get String ( _ STR ) , _ NUM , prompts , buf ) ;  String [ ] lines = get Lines ( buf ) ;  Integer vsan Id = null ;  String [ ] regex = {  MDSDialog Properties . get String ( _ STR ) ,  MDSDialog Properties . get String ( _ STR ) } ;  String [ ] groups = new  String [ _ NUM ] ; for (  String line : lines ) { int index = match ( line , regex , groups ) ; switch ( index ) { case _ NUM : vsan Id = new  Integer ( groups [ _ NUM ] ) ; break ; case _ NUM :  Set <  String > peer Devices Ip Addr = peer Devices Map . get ( vsan Id ) ; if ( peer Devices Ip Addr == null ) { peer Devices Ip Addr =  Sets . new Hash Set ( ) ; peer Devices Map . put ( vsan Id , peer Devices Ip Addr ) ; }  String peer Device = groups [ _ NUM ] + groups [ _ NUM ] ; peer Devices Ip Addr . add ( peer Device ) ; break ; } } return peer Devices Map ; }
@  Nullable private  List <  String > to Array ( @  Nullable  String s , @  Not Null  String separators , @  Nullable  List <  Boolean > markers ) { if ( s == null ) return null ; s = s . trim ( ) ; if ( s . is Empty ( ) ) return null ; boolean p2nl = markers != null && my Settings .  JD_ P_ AT_ EMPTY_ LINES ;  List <  String > list = new  Array List <  String > ( ) ;  String Tokenizer st = new  String Tokenizer ( s , separators , _ BOOL ) ; boolean first = _ BOOL ; int pre Count = _ NUM ; int cur Pos = _ NUM ; while ( st . has More Tokens ( ) ) {  String token = st . next Token ( ) ; cur Pos += token . length ( ) ; if ( separators . contains ( token ) ) { if ( ! first ) { list . add ( _ STR ) ; if ( markers != null ) markers . add (  Boolean . value Of ( pre Count > _ NUM ) ) ; } first = _ BOOL ; } else { first = _ BOOL ; if ( p2nl ) { if ( is Para Tag ( token ) && s . index Of (  P_ END_ TAG , cur Pos ) < _ NUM ) { list . add ( _ STR ) ; markers . add (  Boolean . value Of ( pre Count > _ NUM ) ) ; continue ; } } if ( pre Count == _ NUM ) token = token . trim ( ) ; list . add ( token ) ; if ( markers != null ) { if ( token . contains (  PRE_ TAG_ START ) ) pre Count ++ ; markers . add (  Boolean . value Of ( pre Count > _ NUM ) ) ; if ( token . contains (  PRE_ TAG_ END ) ) pre Count -- ; } } } return list ; }
public  Rect update Fast Scroller Bounds ( int last Touch Y ) { m Invalidate Rect . set ( m Bg Bounds ) ; if ( is Visible ( ) ) { int edge Padding = m Rv . get Max Scrollbar Width ( ) ; int bg Padding = ( m Bg Original Size - m Text Bounds . height ( ) ) / _ NUM ; int bg Height = m Bg Original Size ; int bg Width =  Math . max ( m Bg Original Size , m Text Bounds . width ( ) + ( _ NUM * bg Padding ) ) ; if (  Utilities . is Rtl ( m Res ) ) { m Bg Bounds . left = m Rv . get Background Padding ( ) . left + ( _ NUM * m Rv . get Max Scrollbar Width ( ) ) ; m Bg Bounds . right = m Bg Bounds . left + bg Width ; } else { m Bg Bounds . right = m Rv . get Width ( ) - m Rv . get Background Padding ( ) . right - ( _ NUM * m Rv . get Max Scrollbar Width ( ) ) ; m Bg Bounds . left = m Bg Bounds . right - bg Width ; } m Bg Bounds . top = last Touch Y - ( int ) (  FAST_ SCROLL_ OVERLAY_ Y_ OFFSET_ FACTOR * bg Height ) ; m Bg Bounds . top =  Math . max ( edge Padding ,  Math . min ( m Bg Bounds . top , m Rv . get Height ( ) - edge Padding - bg Height ) ) ; m Bg Bounds . bottom = m Bg Bounds . top + bg Height ; } else { m Bg Bounds . set Empty ( ) ; } m Invalidate Rect . union ( m Bg Bounds ) ; return m Invalidate Rect ; }
public void test_get Prepared Properties Compatibility ( ) throws  Exception {  String namespace = _ STR ;  Properties properties = new  Properties ( ) ; properties . put (  Remote Repository .  OPTION_ CREATE_ KB_ NAMESPACE , namespace ) ; final  Properties p = m_mgr . get Prepared Properties ( namespace , properties ) ; properties . put ( _ STR , _ STR ) ; properties . put ( _ STR , _ STR ) ; try { m_mgr . get Prepared Properties ( namespace , properties ) ; fail ( _ STR +  Http Servlet Response .  SC_ INTERNAL_ SERVER_ ERROR ) ; } catch (  Http Exception ex ) { assert Equals (  Http Servlet Response .  SC_ INTERNAL_ SERVER_ ERROR , ex . get Status Code ( ) ) ; } }
public void remove Memberships (  String universal Id ,  Set membership ) throws  AMConsole Exception { if ( ( membership == null ) || membership . is Empty ( ) ) { throw new  AMConsole Exception ( _ STR ) ; }  SSOToken sso Token = get User SSOToken ( ) ;  String current Id = _ STR ; try {  AMIdentity amid =  Id Utils . get Identity ( sso Token , universal Id ) ;  String [ ] params = new  String [ _ NUM ] ; params [ _ NUM ] = universal Id ; for (  Iterator iter = membership . iterator ( ) ; iter . has Next ( ) ; ) {  String id = (  String ) iter . next ( ) ;  AMIdentity amidentity =  Id Utils . get Identity ( sso Token , id ) ; current Id = id ; params [ _ NUM ] = id ; log Event ( _ STR , params ) ; amidentity . remove Member ( amid ) ; log Event ( _ STR , params ) ; } } catch (  SSOException e ) {  String [ ] params Ex = { current Id , universal Id , get Error String ( e ) } ; log Event ( _ STR , params Ex ) ; debug . warning ( _ STR , e ) ; throw new  AMConsole Exception ( get Error String ( e ) ) ; } catch (  Id Repo Exception e ) {  String [ ] params Ex = { current Id , universal Id , get Error String ( e ) } ; log Event ( _ STR , params Ex ) ; debug . warning ( _ STR , e ) ; throw new  AMConsole Exception ( get Error String ( e ) ) ; } }
private static  Address  Get Byte Array Elements (  JNIEnvironment env , int array JREF ,  Address is Copy Address ) { if ( trace JNI )  VM . sys Write ( _ STR ) ;  Runtime Entrypoints . check JNICount Down To GC ( ) ; try { byte [ ] source Array = ( byte [ ] ) env . get JNIRef ( array JREF ) ; int size = source Array . length ; if (  Memory Manager . will Never Move ( source Array ) ) {  JNIGeneric Helpers . set Bool Star ( is Copy Address , _ BOOL ) ; return  Magic . object As Address ( source Array ) ; } else {  Address copy Buffer = sys Call . sys Malloc ( size ) ; if ( copy Buffer . is Zero ( ) ) { env . record Exception ( new  Out Of Memory Error ( ) ) ; return  Address . zero ( ) ; }  Memory . memcopy ( copy Buffer ,  Magic . object As Address ( source Array ) , size ) ;  JNIGeneric Helpers . set Bool Star ( is Copy Address , _ BOOL ) ; return copy Buffer ; } } catch (  Throwable unexpected ) { if ( trace JNI ) unexpected . print Stack Trace (  System . err ) ; env . record Exception ( unexpected ) ; return  Address . zero ( ) ; } }
public  String preview Next Char ( ) { if ( position < text . length ( ) ) { return text . substring ( position , position + _ NUM ) ; } else if ( position == text . length ( ) ) { return text . substring ( _ NUM , _ NUM ) ; } return _ STR ; }
private void prepare Transfers ( ) throws  Lib Usb Exception { if ( m Available Transfers == null ) { m Available Transfers = new  Linked Transfer Queue < > ( ) ; for ( int x = _ NUM ; x <  TRANSFER_ BUFFER_ POOL_ SIZE ; x ++ ) {  Transfer transfer =  Lib Usb . alloc Transfer ( ) ; if ( transfer == null ) { throw new  Lib Usb Exception ( _ STR ,  Lib Usb .  ERROR_ NO_ MEM ) ; } final  Byte Buffer buffer =  Byte Buffer . allocate Direct ( m Buffer Size ) ;  Lib Usb . fill Bulk Transfer ( transfer , m Device Handle ,  USB_ ENDPOINT , buffer ,  Buffer Processor . this , _ STR ,  USB_ TIMEOUT_ MS ) ; m Available Transfers . add ( transfer ) ; } } }
private void flush Left ( ) throws  IOException { append Newline If Necessary ( left Buf , left Column ) ; while ( left Buf . length ( ) != _ NUM ) { right Column . write ( _ STR ) ; output Full Lines ( ) ; } }
@  Deprecated public static  String format ( double amount ) { try { return format (  Big Decimal . value Of ( amount ) ) ; } catch (  Number Format Exception e ) { logger . log (  Level .  WARNING , _ STR + amount + _ STR + e . get Message ( ) , e ) ; return _ STR ; } }
private void clear ( ) { web Container . unregister ( context Root ) ; logger . debug ( _ STR , context Root ) ; }
public  Builder delete Nick Name ( ) { delete Fields . add ( _ STR ) ; return this ; }
public static void reduce Method List (  Array List <  Integer > values ,  Array List <  String > labels ,  String allowed Methods ) {  String [ ] allowed Strings = allowed Methods . split ( _ STR ) ; int [ ] allowed Values = new int [ allowed Strings . length ] ; for ( int i = _ NUM ; i < allowed Values . length ; i ++ ) { try { allowed Values [ i ] =  Integer . parse Int ( allowed Strings [ i ] , _ NUM ) ; } catch (  Number Format Exception nfe ) {  Log . w (  TAG , _ STR + allowed Strings [ i ] + _ STR + allowed Methods + _ STR ) ; return ; } } for ( int i = values . size ( ) - _ NUM ; i >= _ NUM ; i -- ) { int val = values . get ( i ) ; int j ; for ( j = allowed Values . length - _ NUM ; j >= _ NUM ; j -- ) { if ( val == allowed Values [ j ] ) { break ; } } if ( j < _ NUM ) { values . remove ( i ) ; labels . remove ( i ) ; } } }
public static void add Lifecycle Listener (  Lifecycle Listener l ) { if ( listeners == null ) { listeners = new  Array List <  Lifecycle Listener > ( ) ; } listeners . add ( l ) ; }
long resize Lun ( long size , boolean force ) {  Na Element elem = new  Na Element ( _ STR ) ; elem . add New Child ( _ STR ,  Boolean . to String ( force ) ) ; elem . add New Child ( _ STR , path ) ; elem . add New Child ( _ STR ,  Long . to String ( size ) ) ;  Na Element result = null ; try { result = server . invoke Elem ( elem ) ; return result . get Child Long Value ( _ STR , - _ NUM ) ; } catch (  Exception e ) {  String msg = _ STR + path ; log . error ( msg , e ) ; throw new  Net App Exception ( msg , e ) ; } }
protected boolean launch DMLYarn Appmaster ( ) throws  IOException ,  DMLScript Exception { boolean ret = _ BOOL ;  String hdfs WD = null ; try {  Timing time = new  Timing ( _ BOOL ) ;  Yarn Configuration yconf = new  Yarn Configuration ( ) ;  Yarn Client yarn Client =  Yarn Client . create Yarn Client ( ) ; yarn Client . init ( yconf ) ; yarn Client . start ( ) ;  Yarn Client Application app = yarn Client . create Application ( ) ;  Application Submission Context app Context = app . get Application Submission Context ( ) ;  Application Id app Id = app Context . get Application Id ( ) ;  LOG . debug ( _ STR + app Id + _ STR ) ; hdfs WD =  DMLApp Master Utils . construct HDFSWorking Dir ( _dml Config , app Id ) ; copy Resources To Hdfs Working Dir ( yconf , hdfs WD ) ;  String command = construct AMCommand ( _args , _dml Config ) ;  LOG . debug ( _ STR + command ) ;  Container Launch Context am Container =  Records . new Record (  Container Launch Context . class ) ; am Container . set Commands (  Collections . singleton List ( command ) ) ; am Container . set Local Resources ( construct Local Resource Map ( yconf ) ) ; am Container . set Environment ( construct Envionment Map ( yconf ) ) ; int mem Heap = _dml Config . get Int Value (  DMLConfig .  YARN_ APPMASTERMEM ) ; int mem Alloc = ( int ) compute Memory Allocation ( mem Heap ) ;  Resource capability =  Records . new Record (  Resource . class ) ; capability . set Memory ( mem Alloc ) ; capability . set Virtual Cores (  NUM_ CORES ) ;  LOG . debug ( _ STR + mem Alloc + _ STR +  NUM_ CORES ) ;  String qname = _dml Config . get Text Value (  DMLConfig .  YARN_ APPQUEUE ) ; app Context . set Application Name (  APPMASTER_ NAME ) ; app Context . set AMContainer Spec ( am Container ) ; app Context . set Resource ( capability ) ; app Context . set Queue ( qname ) ;  LOG . debug ( _ STR +  APPMASTER_ NAME + _ STR + qname ) ; yarn Client . submit Application ( app Context ) ;  Application Report app Report = yarn Client . get Application Report ( app Id ) ;  LOG . info ( _ STR + app Report . get Tracking Url ( ) ) ;  Yarn Application State app State = app Report . get Yarn Application State ( ) ;  Yarn Application State old State = app State ;  LOG . info ( _ STR + app State ) ; while ( app State !=  Yarn Application State .  FINISHED && app State !=  Yarn Application State .  KILLED && app State !=  Yarn Application State .  FAILED ) {  Thread . sleep (  APP_ STATE_ INTERVAL ) ; app Report = yarn Client . get Application Report ( app Id ) ; app State = app Report . get Yarn Application State ( ) ; if ( app State != old State ) { old State = app State ;  LOG . info ( _ STR + app State ) ; } }  Final Application Status final State = app Report . get Final Application Status ( ) ;  LOG . info ( _ STR + final State ) ; double app Runtime = ( double ) ( app Report . get Finish Time ( ) - app Report . get Start Time ( ) ) / _ NUM ;  LOG . info ( _ STR + app Runtime + _ STR ) ;  LOG . info ( _ STR +  String . format ( _ STR , time . stop ( ) / _ NUM ) + _ STR ) ; if ( final State !=  Final Application Status .  SUCCEEDED ) {  String stop_msg = read Message To HDFSWorking Dir ( _dml Config , yconf , app Id ) ; if ( stop_msg != null ) throw new  DMLScript Exception ( stop_msg ) ; throw new  DMLRuntime Exception ( _ STR + final State + _ STR ) ; } ret = _ BOOL ; } catch (  DMLScript Exception ex ) { throw ex ; } catch (  Exception ex ) {  LOG . error ( _ STR , ex ) ; ret = _ BOOL ; } finally { if ( hdfs WD != null )  Map Reduce Tool . delete File If Exist On HDFS ( hdfs WD ) ; } return ret ; }
public static void skip Fully (  Input Stream in , long bytes ) throws  IOException { if ( bytes < _ NUM ) { throw new  Illegal Argument Exception ( _ STR + bytes + _ STR ) ; } long remaining = bytes ; while ( remaining > _ NUM ) { long skipped = in . skip ( remaining ) ; if ( skipped <= _ NUM ) { throw new  EOFException ( _ STR + bytes ) ; } remaining -= skipped ; } }
public static  String now (  String date Format ) {  Calendar cal =  Calendar . get Instance ( ) ;  Simple Date Format sdf = new  Simple Date Format ( date Format ) ; return sdf . format ( cal . get Time ( ) ) ; }
protected abstract int main Exec (  Output Stream out ,  Log Stream log ) throws  IOException ;
protected  String Buffer construct Statement (  Row Change Data .  Action Type action ,  String schema Name ,  String table Name ,  Array List <  One Row Change .  Column Spec > columns ,  Array List <  One Row Change .  Column Spec > keys ,  Array List <  One Row Change .  Column Val > key Values ,  Array List <  One Row Change .  Column Val > col Values ) {  String Buffer stmt = new  String Buffer ( ) ; if ( action ==  Row Change Data .  Action Type .  INSERT ) { stmt . append ( _ STR ) ; stmt . append ( conn . get Database Object Name ( schema Name ) + _ STR + conn . get Database Object Name ( table Name ) ) ; stmt . append ( _ STR ) ; print Column Spec ( stmt , columns , null , col Values ,  Print Mode .  NAMES_ ONLY , _ STR ) ; stmt . append ( _ STR ) ; stmt . append ( _ STR ) ; print Column Spec ( stmt , columns , null , col Values ,  Print Mode .  PLACE_ HOLDER , _ STR ) ; stmt . append ( _ STR ) ; } else if ( action ==  Row Change Data .  Action Type .  UPDATE ) { stmt . append ( _ STR ) ; stmt . append ( conn . get Database Object Name ( schema Name ) + _ STR + conn . get Database Object Name ( table Name ) ) ; stmt . append ( _ STR ) ; print Column Spec ( stmt , columns , null , col Values ,  Print Mode .  ASSIGNMENT , _ STR ) ; stmt . append ( _ STR ) ; print Column Spec ( stmt , keys , key Values , col Values ,  Print Mode .  ASSIGNMENT , _ STR ) ; } else if ( action ==  Row Change Data .  Action Type .  DELETE ) { stmt . append ( _ STR ) ; stmt . append ( conn . get Database Object Name ( schema Name ) + _ STR + conn . get Database Object Name ( table Name ) ) ; stmt . append ( _ STR ) ; print Column Spec ( stmt , keys , key Values , col Values ,  Print Mode .  ASSIGNMENT , _ STR ) ; } return stmt ; }
public static void clear (  String realm Name ) { boolean is Default = is Default Org ( realm Name ) ; if ( ( auth Ctx Obj Hash != null ) && ( ! auth Ctx Obj Hash . is Empty ( ) ) ) {  Enumeration keys = auth Ctx Obj Hash . keys ( ) ; while ( keys . has More Elements ( ) ) {  String key = (  String ) keys . next Element ( ) ; if ( key . index Of ( _ STR + realm Name ) != - _ NUM ) { auth Ctx Obj Hash . remove ( key ) ; } if ( is Default && key . ends With ( _ STR ) ) { auth Ctx Obj Hash . remove ( key ) ; } } } if ( ( auth Context Hash != null ) && ( ! auth Context Hash . is Empty ( ) ) ) {  Enumeration keys = auth Context Hash . keys ( ) ; while ( keys . has More Elements ( ) ) {  String key = (  String ) keys . next Element ( ) ; if ( key . index Of ( _ STR + realm Name ) != - _ NUM ) { auth Context Hash . remove ( key ) ; } if ( is Default && key . ends With ( _ STR ) ) { auth Ctx Obj Hash . remove ( key ) ; } } } }
public synchronized void remove OFChannel Handler (  OFChannel Handler h ) { connected Channel Handlers . remove ( h ) ; }
public static boolean stream To File ( final  Input Stream input Stream , final  File target File , final boolean do Append ) { if ( input Stream == null || ! is Writable ( target File , _ BOOL ) ) {  Log . e (  File Utils . class , _ STR ) ; return _ BOOL ; } boolean is Succeed = _ BOOL ; final int buffer_size = _ NUM ;  Output Stream output Stream = null ; try { output Stream = new  File Output Stream ( target File , do Append ) ; byte [ ] bytes = new byte [ buffer_size ] ; int count = _ NUM ; while ( ( count = input Stream . read ( bytes , _ NUM , buffer_size ) ) > _ NUM ) output Stream . write ( bytes , _ NUM , count ) ; is Succeed = _ BOOL ; output Stream . flush ( ) ; } catch (  File Not Found Exception e ) { e . print Stack Trace ( ) ; } catch (  Index Out Of Bounds Exception e ) { e . print Stack Trace ( ) ; } catch (  IOException e ) { e . print Stack Trace ( ) ; } finally { if ( output Stream != null ) try { sync ( output Stream ) ; output Stream . close ( ) ; } catch (  IOException e ) { } } return is Succeed ; }
public  Command add Argument (  String arg ) { arguments . add ( arg ) ; return this ; }
private void recompute Seperation ( double [ ] [ ] means , double [ ] [ ] cdist , int [ ] [ ] cnum ,  Long Statistic diststat ) { final int k = means . length ; for ( int i = _ NUM ; i < k ; i ++ ) {  Double Vector mi =  Double Vector . wrap ( means [ i ] ) ; for ( int j = _ NUM ; j < i ; j ++ ) { cdist [ i ] [ j ] = cdist [ j ] [ i ] = distance Function . distance ( mi ,  Double Vector . wrap ( means [ j ] ) ) ; } } double [ ] buf = new double [ k - _ NUM ] ; for ( int i = _ NUM ; i < k ; i ++ ) {  System . arraycopy ( cdist [ i ] , _ NUM , buf , _ NUM , i ) ;  System . arraycopy ( cdist [ i ] , i + _ NUM , buf , i , k - i - _ NUM ) ; for ( int j = _ NUM ; j < buf . length ; j ++ ) { cnum [ i ] [ j ] = j < i ? j : ( j + _ NUM ) ; }  Double Integer Array Quick Sort . sort ( buf , cnum [ i ] , k - _ NUM ) ; } if ( diststat != null ) { diststat . increment ( ( k * ( k - _ NUM ) ) > > _ NUM ) ; } }
public  Extended Type ( int nodetype ,  String namespace ,  String local Name ) { this . nodetype = nodetype ; this . namespace = namespace ; this . local Name = local Name ; this . hash = nodetype + namespace . hash Code ( ) + local Name . hash Code ( ) ; }
private double [ ] [ ]  Calc Constant Coef (  Variogram variogarm ,  List <  Kriging Point >  NNPoints ) { int n =  NNPoints . size ( ) ; double [ ] [ ] mat = new double [ n + _ NUM ] [ n + _ NUM ] ; double dist = _ NUM ; for ( int i = _ NUM ; i < n ; i ++ ) { for ( int j = i ; j < n ; j ++ ) { dist =  Math . sqrt (  Math . abs (  Math . pow (  NNPoints . get ( i ) . x -  NNPoints . get ( j ) . x , _ NUM ) ) +  Math . abs (  Math . pow (  NNPoints . get ( i ) . y -  NNPoints . get ( j ) . y , _ NUM ) ) ) ; mat [ i ] [ j ] = get Theoretical SVValue ( dist , variogarm ) ; mat [ j ] [ i ] = mat [ i ] [ j ] ; } } for ( int i = _ NUM ; i < n ; i ++ ) { mat [ i ] [ n ] = _ NUM ; mat [ n ] [ i ] = _ NUM ; } return mat ; }
public static  Object deserialization (  String file Path ) {  Object Input Stream in = null ; try { in = new  Object Input Stream ( new  File Input Stream ( file Path ) ) ;  Object o = in . read Object ( ) ; in . close ( ) ; return o ; } catch (  File Not Found Exception e ) { throw new  Runtime Exception ( _ STR , e ) ; } catch (  Class Not Found Exception e ) { throw new  Runtime Exception ( _ STR , e ) ; } catch (  IOException e ) { throw new  Runtime Exception ( _ STR , e ) ; } finally {  IOUtil . close ( in ) ; } }
public  String finished (  Logger log ) { if ( m_av Insts Per Sec == _ NUM ) { compute Update (  System . current Time Millis ( ) ) ; } int n S = m_num Samples > _ NUM ? m_num Samples : _ NUM ;  String msg = _ STR + m_instance Count + _ STR + m_av Insts Per Sec / n S + _ STR ; if ( log != null ) { log . status Message ( m_status Message Prefix + msg ) ; } return msg ; }
private boolean matches ( final  Path path , final  Array Deque <  Path Matcher > matchers ) { for (  Path Matcher matcher : matchers ) { if ( matcher . matches ( path ) ) { return _ BOOL ; } } return _ BOOL ; }
public  Array List <  Mech Summary > generate Units ( int num ) { return generate Units ( num , null ) ; }
public static  Automaton random Automaton (  Random random ) {  Automaton a1 = random Single Automaton ( random ) ;  Automaton a2 = random Single Automaton ( random ) ; switch ( random . next Int ( _ NUM ) ) { case _ NUM : return  Operations . concatenate ( a1 , a2 ) ; case _ NUM : return  Operations . union ( a1 , a2 ) ; case _ NUM : return  Operations . intersection ( a1 , a2 ) ; default : return  Operations . minus ( a1 , a2 ,  DEFAULT_ MAX_ DETERMINIZED_ STATES ) ; } }
public void add ( final  Object element ) {  Set old Selection = new  Hash Set ( selection ) ; boolean rv = selection . add ( element ) ; if ( rv ) { fire Selection Changed ( old Selection , selection ) ; } old Selection = null ; }
public void count Data ( int index ,  Instances uncovered , double [ ] [ ] prev Rule Stats ) { if ( ( m_ Filtered != null ) || ( m_ Ruleset == null ) ) { return ; } int size = m_ Ruleset . size ( ) ; m_ Filtered = new  Array List <  Instances [ ] > ( size ) ; m_ Simple Stats = new  Array List < double [ ] > ( size ) ;  Instances [ ] data = new  Instances [ _ NUM ] ; data [ _ NUM ] = uncovered ; for ( int i = _ NUM ; i < index ; i ++ ) { m_ Simple Stats . add ( prev Rule Stats [ i ] ) ; if ( i + _ NUM == index ) { m_ Filtered . add ( data ) ; } else { m_ Filtered . add ( new  Instances [ _ NUM ] ) ; } } for ( int j = index ; j < size ; j ++ ) { double [ ] stats = new double [ _ NUM ] ;  Instances [ ] filtered = compute Simple Stats ( j , data [ _ NUM ] , stats , null ) ; m_ Filtered . add ( filtered ) ; m_ Simple Stats . add ( stats ) ; data = filtered ; } }
public  List <  Type > random Split (  Random rand , double ... splits ) { if ( splits . length < _ NUM ) throw new  Illegal Argument Exception ( _ STR ) ;  Int List rand Order = new  Int List ( get Sample Size ( ) ) ;  List Utils . add Range ( rand Order , _ NUM , get Sample Size ( ) , _ NUM ) ;  Collections . shuffle ( rand Order , rand ) ; int [ ] stops = new int [ splits . length ] ; double sum = _ NUM ; for ( int i = _ NUM ; i < splits . length ; i ++ ) { sum += splits [ i ] ; if ( sum >= _ NUM ) throw new  Illegal Argument Exception ( _ STR + i + _ STR + sum ) ; stops [ i ] = ( int )  Math . round ( sum * rand Order . size ( ) ) ; }  List <  Type > datasets = new  Array List <  Type > ( splits . length ) ; int prev = _ NUM ; for ( int i = _ NUM ; i < stops . length ; i ++ ) { datasets . add ( get Subset ( rand Order . sub List ( prev , stops [ i ] ) ) ) ; prev = stops [ i ] ; } return datasets ; }
private void read Object (  Object Input Stream oos ) throws  IOException ,  Class Not Found Exception { i Instant = (  Date Time ) oos . read Object ( ) ;  Date Time Field Type type = (  Date Time Field Type ) oos . read Object ( ) ; i Field = type . get Field ( i Instant . get Chronology ( ) ) ; }
public  String pre Process User Input (  String user Input ,  IState Access state , boolean is Req ) throws  Install Exception {  String proc Res = null ; if ( is Req ) { proc Res = pre Proc User Input If Required ( user Input , state ) ; } else { proc Res = pre Proc User Input If Optional ( user Input , state ) ; } return proc Res ; }
public static short read Little Endian Short (  Data Input Stream dis ) throws  IOException { short bits = ( short ) ( _ NUM & dis . read Byte ( ) ) ; bits |= ( ( ( short ) ( _ NUM & dis . read Byte ( ) ) ) << _ NUM ) ; return bits ; }
public byte [ ] decrypt ( byte [ ] bytes To Decode ,  Char Sequence password ) throws  Key Crypter Exception { try { byte [ ] salt = new byte [  SALT_ LENGTH ] ;  System . arraycopy ( bytes To Decode , _ NUM , salt , _ NUM ,  SALT_ LENGTH ) ; byte [ ] cipher Bytes = new byte [ bytes To Decode . length -  SALT_ LENGTH ] ;  System . arraycopy ( bytes To Decode ,  SALT_ LENGTH , cipher Bytes , _ NUM , bytes To Decode . length -  SALT_ LENGTH ) ;  Parameters With IV key = (  Parameters With IV ) get AESPassword Key ( password , salt ) ;  Buffered Block Cipher cipher = new  Padded Buffered Block Cipher ( new  CBCBlock Cipher ( new  AESFast Engine ( ) ) ) ; cipher . init ( _ BOOL , key ) ; byte [ ] decrypted Bytes = new byte [ cipher . get Output Size ( cipher Bytes . length ) ] ; final int process Length = cipher . process Bytes ( cipher Bytes , _ NUM , cipher Bytes . length , decrypted Bytes , _ NUM ) ; final int do Final Length = cipher . do Final ( decrypted Bytes , process Length ) ; return  Arrays . copy Of ( decrypted Bytes , process Length + do Final Length ) ; } catch (  Exception e ) { throw new  Key Crypter Exception ( _ STR , e ) ; } }
public void add Temp Emoticon (  Emoticon emote ) { twitch Emotes By Id . put ( emote . numeric Id , emote ) ; }
public boolean is Function Allowed (  Name name ) { return functions Allowed . contains ( name ) ; }
public void store (  Element root ) {  Element values ;  List <  String > names = get Consist Name List ( ) ; if (  Control . backward Compatible ) { root . add Content ( values = new  Element (  Xml .  CONSISTS ) ) ; for (  String name : names ) {  String consist Names = name + _ STR ; values . add Content ( consist Names ) ; } }  Element consists = new  Element (  Xml .  NEW_ CONSISTS ) ; for (  String name : names ) {  Element consist = new  Element (  Xml .  CONSIST ) ; consist . set Attribute ( new  Attribute (  Xml .  NAME , name ) ) ; consists . add Content ( consist ) ; } root . add Content ( consists ) ; root . add Content ( values = new  Element (  Xml .  ENGINES ) ) ; for (  Rolling Stock rs : get By Road Name List ( ) ) {  Engine eng = (  Engine ) rs ; values . add Content ( eng . store ( ) ) ; } }
public void test Constructor Sign Bytes Zero Null1 ( ) { byte a Bytes [ ] = { } ; int a Sign = - _ NUM ; byte r Bytes [ ] = { _ NUM } ;  Big Integer a Number = new  Big Integer ( a Sign , a Bytes ) ; byte res Bytes [ ] = new byte [ r Bytes . length ] ; res Bytes = a Number . to Byte Array ( ) ; for ( int i = _ NUM ; i < res Bytes . length ; i ++ ) { assert True ( res Bytes [ i ] == r Bytes [ i ] ) ; } assert Equals ( _ STR , _ NUM , a Number . signum ( ) ) ; }
private  List <  File Descriptor > prepare File Descriptors (  List <  File Share > filesystems ,  Virtual Pool Capability Values Wrapper cos Capabilities ,  String suggested Id ) { final  List <  File Descriptor > file Descriptors = new  Array List <  File Descriptor > ( ) ; for (  File Share filesystem : filesystems ) {  File Descriptor desc = new  File Descriptor (  File Descriptor .  Type .  FILE_ DATA , filesystem . get Storage Device ( ) , filesystem . get Id ( ) , filesystem . get Pool ( ) , filesystem . get Capacity ( ) , cos Capabilities , null , suggested Id ) ; file Descriptors . add ( desc ) ; } return file Descriptors ; }
public static void write (  File file ,  NSObject root ) throws  IOException {  Output Stream out = new  File Output Stream ( file ) ; write ( out , root ) ; out . close ( ) ; }
@  Override public void push Message Async (  Message msg ) throws org . apache . thrift .  TException { push Message Sync ( msg ) ; return ; }
@  HLEUnimplemented @  HLEFunction ( nid = _ NUM , version = _ NUM , check Inside Interrupt = _ BOOL ) public int __sce Sas Set Triangular Wave ( int sas Core , int voice , int unknown ) { check Sas And Voice Handles Good ( sas Core , voice ) ; return _ NUM ; }
public void handle Tbl Request Handler List Button Add Request (  Request Invocation Event event ) throws  Model Control Exception { try {  Map values = get Values ( ) ; on Before Save Profile ( values ) ; set Page Session Attribute (  PROPERTY_ ATTRIBUTE , (  Hash Map ) values ) ;  SCSOAPBinding Request Handler List Add View Bean vb = (  SCSOAPBinding Request Handler List Add View Bean ) get View Bean (  SCSOAPBinding Request Handler List Add View Bean . class ) ; unlock Page Trail ( ) ; pass Pg Session Map ( vb ) ; vb . forward To ( get Request Context ( ) ) ; } catch (  AMConsole Exception e ) { set Inline Alert Message (  CCAlert .  TYPE_ ERROR , _ STR , e . get Message ( ) ) ; } }
protected static void draw Data Point ( double x , double y , int size , int shape ,  Graphics gx ) {  Font lf = new  Font ( _ STR ,  Font .  PLAIN , _ NUM ) ;  Font Metrics fm = gx . get Font Metrics ( lf ) ; if ( size == _ NUM ) { size = _ NUM ; } if ( shape !=  ERROR_ SHAPE && shape !=  MISSING_ SHAPE ) { shape = shape % _ NUM ; } switch ( shape ) { case  X_ SHAPE : draw X ( gx , x , y , size ) ; break ; case  PLUS_ SHAPE : draw Plus ( gx , x , y , size ) ; break ; case  DIAMOND_ SHAPE : draw Diamond ( gx , x , y , size ) ; break ; case  TRIANGLEUP_ SHAPE : draw Triangle Up ( gx , x , y , size ) ; break ; case  TRIANGLEDOWN_ SHAPE : draw Triangle Down ( gx , x , y , size ) ; break ; case  ERROR_ SHAPE : gx . draw Rect ( ( int ) ( x - size ) , ( int ) ( y - size ) , ( size * _ NUM ) , ( size * _ NUM ) ) ; break ; case  MISSING_ SHAPE : int hf = fm . get Ascent ( ) ; int width = fm . string Width ( _ STR ) ; gx . draw String ( _ STR , ( int ) ( x - ( width / _ NUM ) ) , ( int ) ( y + ( hf / _ NUM ) ) ) ; break ; } }
@  Override public int hash Code ( ) { int result = _ NUM ;  Iterator < ? > it = iterator ( ) ; while ( it . has Next ( ) ) {  Object next = it . next ( ) ; result += next == null ? _ NUM : next . hash Code ( ) ; } return result ; }
void init (  List <  Column Meta Data > column Meta Data ) { this . column Meta Data = column Meta Data ; column Roles . clear ( ) ; column Names . clear ( ) ; int column Index = _ NUM ; for (  Column Meta Data column : column Meta Data ) { add Column To Columns Maps ( column Index , column ) ; if ( ! column . is Removed ( ) ) { selected Columns . add ( column Index ) ; } column Index ++ ; } check For Duplicates ( ) ; }
private static  Field find Field (  Object instance ,  String name ) throws  No Such Field Exception { for (  Class < ? > clazz = instance . get Class ( ) ; clazz != null ; clazz = clazz . get Superclass ( ) ) { try {  Field field = clazz . get Declared Field ( name ) ; if ( ! field . is Accessible ( ) ) { field . set Accessible ( _ BOOL ) ; } return field ; } catch (  No Such Field Exception e ) { } } throw new  No Such Field Exception ( _ STR + name + _ STR + instance . get Class ( ) ) ; }
public void add To TDA (  String file ) { tda Panel . add Dump File ( file ) ; }
private static boolean date By Ordinal (  Date Time Formatter Builder bld ,  Collection <  Date Time Field Type > fields , boolean extended , boolean strict ISO ) { boolean reduced Prec = _ BOOL ; if ( fields . remove (  Date Time Field Type . year ( ) ) ) { bld . append (  Constants . ye ) ; if ( fields . remove (  Date Time Field Type . day Of Year ( ) ) ) { append Separator ( bld , extended ) ; bld . append Day Of Year ( _ NUM ) ; } else { reduced Prec = _ BOOL ; } } else if ( fields . remove (  Date Time Field Type . day Of Year ( ) ) ) { bld . append Literal ( _ STR ) ; bld . append Day Of Year ( _ NUM ) ; } return reduced Prec ; }
private static void conditional Copy ( final  List <  NV > anns , final  Properties query Hints , final  String name ) { if ( query Hints == null ) return ; final  Object val = query Hints . get Property ( name ) ; if ( val != null ) { anns . add ( new  NV ( name , val ) ) ; } }
public  Page Range add Single Page ( int page Number ) { sequence Starts . add ( page Number ) ; sequence Ends . add ( page Number ) ; return this ; }
public static  List <  Dimensional Item Object > as List (  Collection < ? extends  Dimensional Item Object > collection ) {  List <  Dimensional Item Object > list = new  Array List < > ( ) ; list . add All ( collection ) ; return list ; }
public  Create Index Request aliases (  XContent Builder source ) { return aliases ( source . bytes ( ) ) ; }
private static  Table Info create Table Info (  String table Name ,  Integer page Number , int flags ,  Short type ,  String linked Db Name ,  String linked Table Name ) { if (  TYPE_ LINKED_ TABLE . equals ( type ) ) { return new  Linked Table Info ( page Number , table Name , flags , linked Db Name , linked Table Name ) ; } return new  Table Info ( page Number , table Name , flags ) ; }
private static byte [ ] decode_base64 ( final  String s , final int maxolen ) throws  Illegal Argument Exception { final  String Buffer rs = new  String Buffer ( ) ; int off = _ NUM ; final int slen = s . length ( ) ; int olen = _ NUM ; byte ret [ ] ; byte c1 , c2 , c3 , c4 , o ; if ( maxolen <= _ NUM ) { throw new  Illegal Argument Exception ( _ STR ) ; } while ( off < slen - _ NUM && olen < maxolen ) { c1 = char64 ( s . char At ( off ++ ) ) ; c2 = char64 ( s . char At ( off ++ ) ) ; if ( c1 == - _ NUM || c2 == - _ NUM ) { break ; } o = ( byte ) ( c1 << _ NUM ) ; o |= ( c2 & _ NUM ) > > _ NUM ; rs . append ( ( char ) o ) ; if ( ++ olen >= maxolen || off >= slen ) { break ; } c3 = char64 ( s . char At ( off ++ ) ) ; if ( c3 == - _ NUM ) { break ; } o = ( byte ) ( ( c2 & _ NUM ) << _ NUM ) ; o |= ( c3 & _ NUM ) > > _ NUM ; rs . append ( ( char ) o ) ; if ( ++ olen >= maxolen || off >= slen ) { break ; } c4 = char64 ( s . char At ( off ++ ) ) ; o = ( byte ) ( ( c3 & _ NUM ) << _ NUM ) ; o |= c4 ; rs . append ( ( char ) o ) ; ++ olen ; } ret = new byte [ olen ] ; for ( off = _ NUM ; off < olen ; off ++ ) { ret [ off ] = ( byte ) rs . char At ( off ) ; } return ret ; }
public void add Listener ( @  Not Null  Configuration Listener listener ) { if ( my Listeners == null ) { my Listeners = new  Array List < > ( ) ; } my Listeners . add ( listener ) ; }
public void do Window Open ( ) { }
public boolean submit No Wake (  Runnable task ,  Class Loader loader ) { boolean is Priority = _ BOOL ; boolean is Queue = _ BOOL ; boolean is Wake = _ BOOL ; return schedule Impl ( task , loader ,  MAX_ EXPIRE , is Priority , is Queue , is Wake ) ; }
public static int hash3 ( int hash ,  Object x ,  Object y ,  Object z ) { return _ NUM | ( hash + _ NUM *  System . identity Hash Code ( x ) + _ NUM *  System . identity Hash Code ( y ) + _ NUM *  System . identity Hash Code ( z ) ) ; }
public void import Data ( final  File the File ) { try {  CSVParser the Parser = new  CSVParser ( new  File Input Stream ( the File ) , _ STR , _ STR , _ STR ) ;  String [ ] [ ] values = the Parser . get All Values ( ) ;  String [ ] line ; double [ ] vector ; int dimension = values [ _ NUM ] . length ; init ( dimension ) ; for ( int i = _ NUM ; i < values . length ; i ++ ) { line = values [ i ] ; vector = new double [ values [ _ NUM ] . length ] ; for ( int j = _ NUM ; j < line . length ; j ++ ) { vector [ j ] =  Double . parse Double ( line [ j ] ) ; } add Datapoint ( new  Data Point Colored ( vector ) ) ; } } catch (  IOException e ) { throw new  Runtime Exception ( e ) ; } projection Method . init ( ) ; projection Method . project ( ) ; fire Projector Data Changed ( ) ; }
public static  Double Stream concat (  Double Stream a ,  Double Stream b ) {  Objects . require Non Null ( a ) ;  Objects . require Non Null ( b ) ;  Spliterator .  Of Double split = new  Streams .  Concat Spliterator .  Of Double ( a . spliterator ( ) , b . spliterator ( ) ) ;  Double Stream stream =  Stream Support . double Stream ( split , a . is Parallel ( ) || b . is Parallel ( ) ) ; return stream . on Close (  Streams . composed Close ( a , b ) ) ; }
private void do Test ( int num Of Users , int num Of Puts , boolean [ ] post Authz Allowed , final  Authz Credential Generator authz Generator , final  Boolean keep Alive ) throws  Exception {  Credential Generator credential Generator = authz Generator . get Credential Generator ( ) ;  Properties extra Auth Props = credential Generator . get System Properties ( ) ;  Properties java Props = credential Generator . get Java Properties ( ) ;  Properties extra Authz Props = authz Generator . get System Properties ( ) ;  String authenticator = credential Generator . get Authenticator ( ) ;  String accessor = authz Generator . get Authorization Callback ( ) ;  String auth Init = credential Generator . get Auth Init ( ) ;  Test Authz Credential Generator tgen = new  Test Authz Credential Generator ( authz Generator ) ;  Properties server Props = build Properties ( authenticator , accessor , _ BOOL , extra Auth Props , extra Authz Props ) ;  Properties op Credentials ; credential Generator = tgen . get Credential Generator ( ) ; final  Properties java Props2 = credential Generator != null ? credential Generator . get Java Properties ( ) : null ; int [ ] indices = new int [ num Of Puts ] ; for ( int index = _ NUM ; index < num Of Puts ; ++ index ) { indices [ index ] = index ; }  Random random = new  Random ( ) ;  Properties [ ] auth Props = new  Properties [ num Of Users ] ;  String durable Client Id = _ STR ;  Properties client2 Credentials = null ; for ( int i = _ NUM ; i < num Of Users ; i ++ ) { int rand = random . next Int ( _ NUM ) + _ NUM ; if ( post Authz Allowed [ i ] ) { op Credentials = tgen . get Allowed Credentials ( new  Operation Code [ ] {  Operation Code .  EXECUTE_ CQ ,  Operation Code .  GET } , new  String [ ] { region Name } , indices , rand ) ; } else { op Credentials = tgen . get Disallowed Credentials ( new  Operation Code [ ] {  Operation Code .  GET } , new  String [ ] { region Name } , indices , rand ) ; } auth Props [ i ] = concat Properties ( new  Properties [ ] { op Credentials , extra Auth Props , extra Authz Props } ) ; if ( client2 Credentials == null ) { client2 Credentials = tgen . get Allowed Credentials ( new  Operation Code [ ] {  Operation Code .  PUT } , new  String [ ] { region Name } , indices , rand ) ; } } int [ ] random Available TCPPorts =  Available Port Helper . get Random Available TCPPorts ( _ NUM ) ; int port1 = random Available TCPPorts [ _ NUM ] ; int port2 = random Available TCPPorts [ _ NUM ] ; int locator Port = random Available TCPPorts [ _ NUM ] ; server1 . invoke ( null ) ; server2 . invoke ( null ) ; server1 . invoke ( null ) ; client1 . invoke ( null ) ; client1 . invoke ( null ) ; client1 . invoke ( null ) ; client1 . invoke ( null ) ; if ( keep Alive == null ) { client1 . invoke ( null ) ; } else { client1 . invoke ( null ) ; } server1 . invoke ( null ) ; client1 . invoke ( null ) ; client1 . invoke ( null ) ; client1 . invoke ( null ) ; client1 . invoke ( null ) ; if ( ! post Authz Allowed [ _ NUM ] || keep Alive == null || ! keep Alive ) {  Thread . sleep ( _ NUM ) ; } else { client1 . invoke ( null ) ; } int num Of Creates = keep Alive == null ? _ NUM : ( keep Alive ? num Of Puts + _ NUM : _ NUM ) ; client1 . invoke ( null ) ; client1 . invoke ( null ) ; client1 . invoke ( null ) ; client1 . invoke ( null ) ; client1 . invoke ( null ) ; server1 . invoke ( null ) ; if ( ! post Authz Allowed [ _ NUM ] || keep Alive == null || ! keep Alive ) {  Thread . sleep ( _ NUM ) ; } else { client1 . invoke ( null ) ; } int num Of Updates = num Of Puts + _ NUM ; client1 . invoke ( null ) ; }
public static void trim Lines ( final  Document doc , final int line Count ) { if ( doc . get Length ( ) < line Count ) { return ; } try { final  String text = doc . get Text ( _ NUM , doc . get Length ( ) ) ; int returns Found = _ NUM ; for ( int i = text . length ( ) - _ NUM ; i >= _ NUM ; i -- ) { if ( text . char At ( i ) == _ STR ) { returns Found ++ ; } if ( returns Found == line Count ) { doc . remove ( _ NUM , i ) ; return ; } } } catch ( final  Bad Location Exception e ) {  Client Logger . log Error ( _ STR , e ) ; } }
private void adjust Column Widths (  JTable table ) {  Table Column Model model = table . get Column Model ( ) ; for ( int column = _ NUM ; column < table . get Column Count ( ) ; column ++ ) {  Table Column tc = model . get Column ( column ) ; int width = tc . get Width ( ) ; for ( int row = _ NUM ; row < table . get Row Count ( ) ; row ++ ) {  Component comp = table . prepare Renderer ( table . get Cell Renderer ( row , column ) , row , column ) ; width =  Math . max ( width , comp . get Preferred Size ( ) . width ) ; } tc . set Preferred Width ( width ) ; } }
public static  List <  Volume > query Volumes By Iterative Query (  Db Client db Client ,  List <  URI > volume URIs ) {  List <  Volume > volumes = new  Array List <  Volume > ( ) ; @  Suppress Warnings ( _ STR )  Iterator <  Volume > volume Iterator = db Client . query Iterative Objects (  Volume . class , volume URIs ) ; while ( volume Iterator . has Next ( ) ) { volumes . add ( volume Iterator . next ( ) ) ; } return volumes ; }
public  Hyperpoint (  String s ) {  Array List <  String > al = new  Array List <  String > ( ) ;  String Tokenizer st = new  String Tokenizer ( s , _ STR ) ; while ( st . has More Tokens ( ) ) { al . add ( st . next Token ( ) ) ; } dimensionality = al . size ( ) ; values = new double [ dimensionality ] ; for ( int i = _ NUM ; i <= dimensionality ; i ++ ) { values [ i - _ NUM ] =  Double . value Of ( al . get ( i - _ NUM ) ) ; } }
private void disable Index Form ( ) { edit Index Index = - _ NUM ; index Name . set Text ( _ STR ) ; index Type . set Text ( _ STR ) ; selected Columns . remove All ( ) ; index Name . set Enabled ( _ BOOL ) ; index Type . set Enabled ( _ BOOL ) ; selected Columns . set Enabled ( _ BOOL ) ; del Index . set Enabled ( _ BOOL ) ; index Add Button . set Enabled ( _ BOOL ) ; index Remove Button . set Enabled ( _ BOOL ) ; index Up Button . set Enabled ( _ BOOL ) ; index Down Button . set Enabled ( _ BOOL ) ; }
public static void srs_print_bytes (  String tag ,  Byte Buffer bb , int size ) {  String Builder sb = new  String Builder ( ) ; int i = _ NUM ; int bytes_in_line = _ NUM ; int max = bb . remaining ( ) ; for ( i = _ NUM ; i < size && i < max ; i ++ ) { sb . append (  String . format ( _ STR ,  Integer . to Hex String ( bb . get ( i ) & _ NUM ) ) ) ; if ( ( ( i + _ NUM ) % bytes_in_line ) == _ NUM ) {  Log . i ( tag ,  String . format ( _ STR , i / bytes_in_line * bytes_in_line , i , sb . to String ( ) ) ) ; sb = new  String Builder ( ) ; } } if ( sb . length ( ) > _ NUM ) {  Log . i ( tag ,  String . format ( _ STR , size / bytes_in_line * bytes_in_line , i - _ NUM , sb . to String ( ) ) ) ; } }
public void interrupt ( ) { final  Thread t = thread Var . get ( ) ; if ( t != null ) { t . interrupt ( ) ; while ( t . is Alive ( ) ) { try {  Thread . sleep ( _ NUM ) ; } catch ( final  Interrupted Exception e ) {  Log Writer . write Log ( _ STR + e . get Message ( ) ) ; } } } thread Var . clear ( ) ; }
private void create Esxi Session (  Image Server Dialog d ,  Compute Image Job job ,  Compute Image ci ,  Compute Image Server image Server ) {  String s =  Image Server Utils . get Resource As String (  ESXI5 X_ UUID_ TEMPLATE ) ;  String Builder sb = new  String Builder ( s ) ;  Image Server Utils . replace All ( sb , _ STR , ci . get Image Name ( ) ) ;  Image Server Utils . replace All ( sb , _ STR , ci . get Path To Directory ( ) ) ;  Image Server Utils . replace All ( sb , _ STR , job . get Pxe Boot Identifier ( ) ) ;  String content = sb . to String ( ) ; log . trace ( content ) ; d . write File ( image Server . get Tftp Boot Dir ( ) +  PXELINUX_ CFG_ DIR + job . get Pxe Boot Identifier ( ) , content ) ; s = d . read File ( image Server . get Tftp Boot Dir ( ) + ci . get Path To Directory ( ) + _ STR ) ; sb = new  String Builder ( s . trim ( ) ) ;  Image Server Utils . replace All ( sb , _ STR , _ STR + ci . get Path To Directory ( ) ) ;  Image Server Utils . replace All ( sb , _ STR , _ STR + image Server . get Image Server Second Ip ( ) + _ STR + image Server . get Image Server Http Port ( ) + _ STR + job . get Pxe Boot Identifier ( ) + _ STR ) ; content = sb . to String ( ) ; log . trace ( content ) ; d . write File ( image Server . get Tftp Boot Dir ( ) +  PXELINUX_ CFG_ DIR + job . get Pxe Boot Identifier ( ) + _ STR , content ) ; content = generate Kickstart ( job , ci , image Server ) ; d . write File ( image Server . get Tftp Boot Dir ( ) +  HTTP_ KICKSTART_ DIR + job . get Pxe Boot Identifier ( ) , content ) ; content = generate Firstboot ( job , ci ) ; d . write File ( image Server . get Tftp Boot Dir ( ) +  HTTP_ FIRSTBOOT_ DIR + job . get Pxe Boot Identifier ( ) , content ) ; d . rm ( image Server . get Tftp Boot Dir ( ) +  HTTP_ SUCCESS_ DIR + job . get Pxe Boot Identifier ( ) ) ; d . rm ( image Server . get Tftp Boot Dir ( ) +  HTTP_ FAILURE_ DIR + job . get Pxe Boot Identifier ( ) ) ; }
public void on Draw Frame (  GL10 gl ) { gl . gl Clear (  GL10 .  GL_ COLOR_ BUFFER_ BIT ) ; gl . gl Matrix Mode (  GL10 .  GL_ MODELVIEW ) ; gl . gl Load Identity ( ) ; if ( show Cube Inside Out ) { float dist = _ NUM ; gl . gl Translatef ( _ NUM , _ NUM , - dist ) ; if ( orientation Provider != null ) {  Quaternion q = orientation Provider . get Quaternion ( ) ; gl . gl Rotatef ( ( float ) ( _ NUM *  Math . acos ( q . get W ( ) ) * _ NUM /  Math .  PI ) , q . get X ( ) , q . get Y ( ) , q . get Z ( ) ) ; } gl . gl Enable Client State (  GL10 .  GL_ VERTEX_ ARRAY ) ; gl . gl Enable Client State (  GL10 .  GL_ COLOR_ ARRAY ) ; m Cube . draw ( gl ) ; } else { if ( orientation Provider != null ) {  Quaternion q = orientation Provider . get Quaternion ( ) ; gl . gl Rotatef ( ( float ) ( _ NUM *  Math . acos ( q . get W ( ) ) * _ NUM /  Math .  PI ) , q . get X ( ) , q . get Y ( ) , q . get Z ( ) ) ; } float dist = _ NUM ; draw Translated Cube ( gl , _ NUM , _ NUM , - dist ) ; draw Translated Cube ( gl , _ NUM , _ NUM , dist ) ; draw Translated Cube ( gl , _ NUM , - dist , _ NUM ) ; draw Translated Cube ( gl , _ NUM , dist , _ NUM ) ; draw Translated Cube ( gl , - dist , _ NUM , _ NUM ) ; draw Translated Cube ( gl , dist , _ NUM , _ NUM ) ; } gl . gl Enable Client State (  GL10 .  GL_ VERTEX_ ARRAY ) ; gl . gl Enable Client State (  GL10 .  GL_ COLOR_ ARRAY ) ; m Cube . draw ( gl ) ; }
public static  Object invoke (  Invocation State invocation State ,  Class < ? > target Class ,  Object o ,  Object functional Object ,  Class < ? > invoker ,  String method , boolean [ ] primitives ,  Object [ ] args ) throws  Throwable { if ( primitives . length != args . length ) throw new  Lt Bug ( _ STR ) ;  List <  Method > method List = new  Array List < > ( ) ;  Queue <  Class < ? > > interfaces = new  Array Deque < > ( ) ;  Class < ? > c = o == null ? target Class : o . get Class ( ) ; while ( c != null ) {  Collections . add All ( interfaces , c . get Interfaces ( ) ) ; fill Method Candidates ( c , invoker , method , args , method List , o == null ) ; c = c . get Superclass ( ) ; } c = o == null ? target Class : o . get Class ( ) ;  Collections . add All ( interfaces , c . get Interfaces ( ) ) ; while ( ! interfaces . is Empty ( ) ) {  Class < ? > i = interfaces . remove ( ) ; fill Method Candidates ( i , invoker , method , args , method List , o == null ) ;  Collections . add All ( interfaces , i . get Interfaces ( ) ) ; } if ( method List . is Empty ( ) ) { if ( c . is Array ( ) ) { if ( method . equals ( _ STR ) && args . length >= _ NUM && args [ _ NUM ] instanceof  Integer ) {  Object res =  Array . get ( o , (  Integer ) args [ _ NUM ] ) ; if ( args . length == _ NUM ) return res ; boolean [ ] bs = new boolean [ primitives . length - _ NUM ] ;  Object [ ] as = new  Object [ args . length - _ NUM ] ; for ( int i = _ NUM ; i < args . length ; ++ i ) { bs [ i - _ NUM ] = primitives [ i ] ; as [ i - _ NUM ] = args [ i ] ; } return invoke ( invocation State , target Class , res , null , invoker , _ STR , bs , as ) ; } else if ( method . equals ( _ STR ) && args . length >= _ NUM && args [ _ NUM ] instanceof  Integer ) { if ( args . length == _ NUM ) {  Array . set ( o , (  Integer ) args [ _ NUM ] , args [ _ NUM ] ) ; return args [ _ NUM ] ; } else {  Object elem =  Array . get ( o , (  Integer ) args [ _ NUM ] ) ; boolean [ ] bs = new boolean [ primitives . length - _ NUM ] ;  Object [ ] as = new  Object [ args . length - _ NUM ] ; for ( int i = _ NUM ; i < args . length ; ++ i ) { bs [ i - _ NUM ] = primitives [ i ] ; as [ i - _ NUM ] = args [ i ] ; } return invoke ( invocation State , target Class , elem , null , invoker , _ STR , bs , as ) ; } } } else { if ( args . length == _ NUM && is Box Type ( c ) && is Box Type ( args [ _ NUM ] . get Class ( ) ) ) { return invoke Primitive ( o , method , args [ _ NUM ] ) ; } else if ( args . length == _ NUM && is Box Type ( c ) ) { return invoke Primitive ( o , method ) ; } else if ( method . equals ( _ STR ) && args . length == _ NUM && ( args [ _ NUM ] instanceof  String || o instanceof  String ) ) { return  String . value Of ( o ) +  String . value Of ( args [ _ NUM ] ) ; } else if ( method . equals ( _ STR ) ) { return invoke ( invocation State , target Class , o , functional Object , invoker , _ STR , primitives , args ) ; } else if ( method . equals ( _ STR ) && args . length == _ NUM ) { return !  Lt Runtime . cast To Bool ( o ) ; } } if ( ! invocation State . is Calling Reverse ) { if ( o != null && args . length == _ NUM && args [ _ NUM ] != null ) {  String method Name = _ STR + method ;  Object _2 = args [ _ NUM ] ;  Invocation State reverse Invocation State = new  Invocation State ( ) ; reverse Invocation State . is Calling Reverse = _ BOOL ; try { return invoke ( reverse Invocation State , _2 . get Class ( ) , _2 , null , invoker , method Name , new boolean [ ] { _ BOOL } , new  Object [ ] { o } ) ; } catch (  Throwable t ) { if ( reverse Invocation State . method Found ) { throw t ; } } } if ( functional Object != null ) {  Invocation State call Functional State = new  Invocation State ( ) ; try { return call Functional Object ( call Functional State , functional Object , invoker , args ) ; } catch (  Throwable t ) { if ( call Functional State . method Found ) throw t ; } } invocation State . method Found = _ BOOL ;  Method call = null ; try {  Class < ? > cc = target Class ; if ( o != null ) { cc = o . get Class ( ) ; } call = cc . get Method ( _ STR ,  Object . class ,  String . class , boolean [ ] . class ,  Object [ ] . class ) ; if (  Modifier . is Static ( call . get Modifiers ( ) ) && ! call . get Return Type ( ) . equals ( void . class ) ) { invocation State . method Found = _ BOOL ; } } catch (  No Such Method Exception ignore ) { } if ( invocation State . method Found ) { assert call != null ; try { return call . invoke ( null , o , method , primitives , args ) ; } catch (  Invocation Target Exception e ) { throw e . get Target Exception ( ) ; } } } if ( ! invocation State . from Field && ! invocation State . is Calling Reverse ) {  Object result =  Lt Runtime . get Field ( o , method , invoker ) ; if ( result != null && ! result . equals (  Unit . get ( ) ) ) { invocation State . method Found = _ BOOL ; return call Functional Object ( result , invoker , args ) ; } }  String Builder sb = new  String Builder ( ) . append ( o == null ? target Class . get Name ( ) : o . get Class ( ) . get Name ( ) ) . append ( _ STR ) . append ( method ) . append ( _ STR ) ; boolean is First = _ BOOL ; for (  Object arg : args ) { if ( is First ) is First = _ BOOL ; else sb . append ( _ STR ) ; sb . append ( arg == null ? _ STR : arg . get Class ( ) . get Name ( ) ) ; } sb . append ( _ STR ) ; throw new  Lt Runtime Exception ( _ STR + sb . to String ( ) ) ; }  Method method To Invoke = find Best Match ( method List , args , primitives ) ; invocation State . method Found = _ BOOL ; trans To Required Type ( args , method To Invoke . get Parameter Types ( ) ) ; method To Invoke . set Accessible ( _ BOOL ) ; try {  Object res = method To Invoke . invoke ( o , args ) ; if ( method To Invoke . get Return Type ( ) == void . class ) return  Unit . get ( ) ; else return res ; } catch (  Invocation Target Exception e ) { throw e . get Target Exception ( ) ; } }
public boolean submit No Wake (  Runnable task ,  Class Loader loader ) { boolean is Priority = _ BOOL ; boolean is Queue = _ BOOL ; boolean is Wake = _ BOOL ; return schedule Impl ( task , loader ,  MAX_ EXPIRE , is Priority , is Queue , is Wake ) ; }
@  Override public int hash Code ( ) { int code = _ NUM ; if ( name != null ) { code += name . hash Code ( ) ; } if ( entitlement != null ) { code += entitlement . hash Code ( ) ; } if ( e Subject != null ) { code += e Subject . hash Code ( ) ; } if ( e Condition != null ) { code += e Condition . hash Code ( ) ; } if ( e Resource Attributes != null ) { code += e Resource Attributes . hash Code ( ) ; } return code ; }
public  Builder add Action (  String action Type ,  Action action ) { m Actions . add ( new  Action Pair ( action Type , action ) ) ; return this ; }
public  IGroup Info find Exact Group (  List <  String > initiators ) { if ( log . is Debug Enabled ( ) ) { log . debug ( _ STR + initiators ) ; }  IGroup Info not Found = new  IGroup Info ( ) ; not Found . set Name ( null ) ;  IGroup igroup = new  IGroup ( server . get Na Server ( ) , null ) ; for (  IGroup Info info : igroup . list Initiator Groups ( _ BOOL ) ) {  Array List <  String > list = new  Array List <  String > ( initiators ) ; for (  String initiator : info . get Initiators ( ) ) { if ( ! list . remove ( initiator ) ) { list . add ( _ STR ) ; } else { not Found . set Os Type ( info . get Os Type ( ) ) ; } } if ( list . is Empty ( ) ) { return info ; } } return not Found ; }
public  Point2 D forward (  Point2 D llp ,  Point2 D pt ) { return forward ( llp . get Y ( ) , llp . get X ( ) , pt ) ; }
protected static void remove All Triggers (  Connection conn ,  String prefix ) throws  SQLException {  Statement stat = conn . create Statement ( ) ;  Result Set rs = stat . execute Query ( _ STR ) ;  Statement stat2 = conn . create Statement ( ) ; while ( rs . next ( ) ) {  String schema = rs . get String ( _ STR ) ;  String name = rs . get String ( _ STR ) ; if ( name . starts With ( prefix ) ) { name =  String Utils . quote Identifier ( schema ) + _ STR +  String Utils . quote Identifier ( name ) ; stat2 . execute ( _ STR + name ) ; } } }
public boolean has Category (  String category ) { if ( category == null ) { return _ BOOL ; } return categories . contains (  String Util . to Lower Case ( category ) ) ; }
public static boolean is Volume CGFull Copy Source (  Volume volume ,  Db Client db Client ) { boolean is Full Copy Source = _ BOOL ;  String Set full Copy Ids = volume . get Full Copies ( ) ; if ( ( full Copy Ids != null ) && ( ! full Copy Ids . is Empty ( ) ) ) {  Iterator <  String > full Copy Ids Iter = full Copy Ids . iterator ( ) ; while ( full Copy Ids Iter . has Next ( ) ) {  URI full Copy URI =  URI . create ( full Copy Ids Iter . next ( ) ) ;  Volume full Copy Volume = db Client . query Object (  Volume . class , full Copy URI ) ; if ( ( full Copy Volume != null ) && ( ! full Copy Volume . get Inactive ( ) ) ) {  String group Name = full Copy Volume . get Replication Group Instance ( ) ; if (  Null Column Value Getter . is Not Null Value ( group Name ) ||  VPlex Util . is Backend Full Copy In Replication Group ( full Copy Volume , db Client ) ) { is Full Copy Source = _ BOOL ; break ; } } } } return is Full Copy Source ; }
@  Override public void assert Equals (  String message ,  Object expected Obj ,  Object actual Obj ) {  ANOVAMatrix expected = (  ANOVAMatrix ) expected Obj ;  ANOVAMatrix actual = (  ANOVAMatrix ) actual Obj ; message = message + _ STR + actual . get Source ( ) + _ STR ; double [ ] [ ] expected Probabilities = expected . get Probabilities ( ) ; double [ ] [ ] actual Probabilities = actual . get Probabilities ( ) ; for ( int i = _ NUM ; i < expected Probabilities . length ; i ++ ) { for ( int j = _ NUM ; j < expected Probabilities [ i ] . length ; j ++ ) {  Assert . assert Equals ( message + _ STR , expected Probabilities [ i ] [ j ] , actual Probabilities [ i ] [ j ] , _ NUM ) ; } }  Assert . assert Equals ( message + _ STR , expected . get Significance Level ( ) , actual . get Significance Level ( ) , _ NUM ) ; }
public void test_member Add_terminate Client ( ) throws  Interrupted Exception { final  Quorum < ? , ? > quorum = quorums [ _ NUM ] ; final  Quorum Member < ? > client = clients [ _ NUM ] ; final  Quorum Actor < ? , ? > actor = actors [ _ NUM ] ; final  UUID service Id = client . get Service Id ( ) ; assert False ( client . is Member ( ) ) ; assert Equals ( new  UUID [ ] { } , quorum . get Members ( ) ) ; actor . member Add ( ) ; fixture . await Deque ( ) ; assert True ( client . is Member ( ) ) ; assert Equals ( new  UUID [ ] { service Id } , quorum . get Members ( ) ) ; assert Equals ( client , quorum . get Client ( ) ) ; quorum . terminate ( ) ; try { quorum . get Client ( ) ; } catch (  Illegal State Exception ex ) { log . info ( _ STR + ex ) ; } assert Equals (  Quorum .  NO_ QUORUM , quorum . token ( ) ) ; assert Equals (  Quorum .  NO_ QUORUM , quorum . last Valid Token ( ) ) ; assert Equals ( new  UUID [ ] { } , quorum . get Members ( ) ) ; assert Equals ( new  UUID [ ] { } , quorum . get Joined ( ) ) ; assert Equals ( new  UUID [ ] { } , quorum . get Pipeline ( ) ) ; assert Equals (  Collections . empty Map ( ) , quorum . get Votes ( ) ) ; try { assert False ( client . is Member ( ) ) ; } catch (  Illegal State Exception ex ) { log . info ( _ STR + ex ) ; } quorum . terminate ( ) ; }
public void request After Explanation ( @  Non Null  String [ ] permissions ) {  Array List <  String > permissions To Request = new  Array List < > ( ) ; for (  String permission Name : permissions ) { if ( is Permission Declined ( permission Name ) ) { permissions To Request . add ( permission Name ) ; } else { permission Callback . on Permission Pre Granted ( permission Name ) ; } } if ( permissions To Request . is Empty ( ) ) return ; permissions = permissions To Request . to Array ( new  String [ permissions To Request . size ( ) ] ) ;  Activity Compat . request Permissions ( context , permissions ,  REQUEST_ PERMISSIONS ) ; }
static void pause Thread ( long duration ) { try {  Thread . sleep ( duration ) ; } catch (  Exception e ) { _log . warn ( _ STR , e ) ; } }
final public void println (  Object v ) { try { _out . println ( v ) ; } catch (  IOException e ) { log . log (  Level .  FINE , e . to String ( ) , e ) ; } }
public int read ( char [ ] cbuf ) throws java . io .  IOException { return read ( cbuf , _ NUM , cbuf . length ) ; }
public int read ( char [ ] cbuf , int off , int len ) throws  IOException { int num = _ NUM ; int val ; while ( num < len ) { if ( ( val = is . read ( ) ) < _ NUM ) { return ( num != _ NUM ) ? num : - _ NUM ; } switch ( val & _ NUM ) { case _ NUM : case _ NUM : cbuf [ off ++ ] = ( char ) ( ( ( val & _ NUM ) << _ NUM ) | ( is . read ( ) & _ NUM ) ) ; break ; case _ NUM : cbuf [ off ++ ] = ( char ) ( ( ( val & _ NUM ) << _ NUM ) | ( ( is . read ( ) & _ NUM ) << _ NUM ) | ( is . read ( ) & _ NUM ) ) ; break ; case _ NUM : throw new  Unsupported Encoding Exception ( _ STR ) ; default : cbuf [ off ++ ] = ( char ) val ; break ; } num ++ ; } return num ; }
private static boolean  Call Boolean Method V (  JNIEnvironment env , int obj JREF , int method ID ,  Address arg Address ) throws  Exception { if ( trace JNI )  VM . sys Write ( _ STR ) ;  Runtime Entrypoints . check JNICount Down To GC ( ) ; try {  Object obj = env . get JNIRef ( obj JREF ) ;  Object return Obj =  JNIHelpers . invoke With Var Arg ( obj , method ID , arg Address ,  Type Reference .  Boolean , _ BOOL ) ; return  Reflection . unwrap Boolean ( return Obj ) ; } catch (  Throwable unexpected ) { if ( trace JNI ) unexpected . print Stack Trace (  System . err ) ; env . record Exception ( unexpected ) ; return _ BOOL ; } }
public static  Array List <  Program Block > rcreate Deep Copy Program Blocks (  Array List <  Program Block > child Blocks , long pid , int  IDPrefix ,  Hash Set <  String > fn Stack ,  Hash Set <  String > fn Created , boolean plain , boolean force Deep Copy ) throws  DMLRuntime Exception {  Array List <  Program Block > tmp = new  Array List <  Program Block > ( ) ; for (  Program Block pb : child Blocks ) {  Program prog = pb . get Program ( ) ;  Program Block tmp PB = null ; if ( pb instanceof  While Program Block ) { tmp PB = create Deep Copy While Program Block ( (  While Program Block ) pb , pid ,  IDPrefix , prog , fn Stack , fn Created , plain , force Deep Copy ) ; } else if ( pb instanceof  For Program Block && ! ( pb instanceof  Par For Program Block ) ) { tmp PB = create Deep Copy For Program Block ( (  For Program Block ) pb , pid ,  IDPrefix , prog , fn Stack , fn Created , plain , force Deep Copy ) ; } else if ( pb instanceof  Par For Program Block ) {  Par For Program Block pfpb = (  Par For Program Block ) pb ; if (  Par For Program Block .  ALLOW_ NESTED_ PARALLELISM ) tmp PB = create Deep Copy Par For Program Block ( pfpb , pid ,  IDPrefix , prog , fn Stack , fn Created , plain , force Deep Copy ) ; else tmp PB = create Deep Copy For Program Block ( (  For Program Block ) pb , pid ,  IDPrefix , prog , fn Stack , fn Created , plain , force Deep Copy ) ; } else if ( pb instanceof  If Program Block ) { tmp PB = create Deep Copy If Program Block ( (  If Program Block ) pb , pid ,  IDPrefix , prog , fn Stack , fn Created , plain , force Deep Copy ) ; } else { tmp PB = new  Program Block ( prog ) ; tmp PB . set Statement Block ( create Statement Block Copy ( pb . get Statement Block ( ) , pid , plain , force Deep Copy ) ) ; tmp PB . set Thread ID ( pid ) ; } tmp PB . set Instructions ( create Deep Copy Instruction Set ( pb . get Instructions ( ) , pid ,  IDPrefix , prog , fn Stack , fn Created , plain , _ BOOL ) ) ; tmp . add ( tmp PB ) ; } return tmp ; }
protected void init ( ) throws  Value Storage Exception { try { this . contains Java Files = has Java Files In Folder ( root Folder ) ; } catch (  Illegal State Exception e ) { throw new  Value Storage Exception (  String . format ( _ STR , root Folder . get Name ( ) ) + e . get Message ( ) ) ; } this . initialized = _ BOOL ; }
public void test Doubles Round Trip ( ) { byte [ ] encoded = new byte [  Double .  BYTES ] ; for ( int i = _ NUM ; i < _ NUM ; i ++ ) { double value =  Double . long Bits To Double (  Test Util . next Long ( random ( ) ,  Long .  MIN_ VALUE ,  Long .  MAX_ VALUE ) ) ;  Numeric Utils . long To Sortable Bytes (  Numeric Utils . double To Sortable Long ( value ) , encoded , _ NUM ) ; double actual =  Numeric Utils . sortable Long To Double (  Numeric Utils . sortable Bytes To Long ( encoded , _ NUM ) ) ; assert Equals (  Double . double To Long Bits ( value ) ,  Double . double To Long Bits ( actual ) ) ; } }
public static boolean is Cglib Proxy Class (  Class < ? > clazz ) { return ( clazz != null && is Cglib Proxy Class Name ( clazz . get Name ( ) ) ) ; }
private static  Pair <  String ,  String > post Indexed ASR ( final long offset , final  ITranslation Environment environment , final  List <  Reil Instruction > instructions , final  String register Node Value1 , final  String register Node Value2 , final  String immediate Node Value ) { final  String address = environment . get Next Variable String ( ) ; final  String index = environment . get Next Variable String ( ) ; final  String tmp Var = environment . get Next Variable String ( ) ; long base Offset = offset ; instructions . add (  Reil Helpers . create Str ( base Offset ++ , dw , register Node Value1 , dw , address ) ) ; if ( immediate Node Value . equals ( _ STR ) ) { final  String is Zero Condition = environment . get Next Variable String ( ) ; final  String tmp Var1 = environment . get Next Variable String ( ) ; instructions . add (  Reil Helpers . create Bsh ( base Offset ++ , dw , register Node Value2 , wd ,  String . value Of ( - _ NUM ) , dw , tmp Var1 ) ) ; instructions . add (  Reil Helpers . create Bisz ( base Offset ++ , dw , tmp Var1 , bt , is Zero Condition ) ) ; instructions . add (  Reil Helpers . create Sub ( base Offset ++ , dw ,  String . value Of ( _ NUM ) , bt , is Zero Condition , dw , index ) ) ; } else { final  String tmp Var1 = environment . get Next Variable String ( ) ; final  String tmp Var2 = environment . get Next Variable String ( ) ; final  String tmp Var3 = environment . get Next Variable String ( ) ; final  String tmp Var4 = environment . get Next Variable String ( ) ; instructions . add (  Reil Helpers . create Add ( base Offset ++ , dw , register Node Value2 , dw ,  String . value Of ( _ NUM ) , dw , tmp Var1 ) ) ; instructions . add (  Reil Helpers . create Bsh ( base Offset ++ , dw , tmp Var1 , dw , _ STR + immediate Node Value , dw , tmp Var2 ) ) ; instructions . add (  Reil Helpers . create Bsh ( base Offset ++ , dw ,  String . value Of ( _ NUM ) , dw , _ STR + immediate Node Value , dw , tmp Var3 ) ) ; instructions . add (  Reil Helpers . create Sub ( base Offset ++ , dw , tmp Var2 , dw , tmp Var3 , qw , tmp Var4 ) ) ; instructions . add (  Reil Helpers . create And ( base Offset ++ , qw , tmp Var4 , dw , d Word Bit Mask , dw , index ) ) ; } instructions . add (  Reil Helpers . create Add ( base Offset ++ , dw , register Node Value1 , dw , index , dw , tmp Var ) ) ; instructions . add (  Reil Helpers . create And ( base Offset ++ , dw , tmp Var , dw , d Word Bit Mask , dw , register Node Value1 ) ) ; return new  Pair <  String ,  String > ( address , register Node Value1 ) ; }
public  Class < ? > load Class (  String name ) throws  Class Not Found Exception { return init Class Loader . load Class ( name ) ; }
public void add Operator (  Operator operator , int index ) { if ( operator == null ) { throw new  Null Pointer Exception ( _ STR ) ; } if ( operator instanceof  Process Root Operator ) { throw new  Illegal Argument Exception ( _ STR ) ; } operators . add ( index , operator ) ; register Operator ( operator , _ BOOL ) ; }
protected boolean is Any Test Component In Target (  Geometry test Geom ) {  List coords =  Component Coordinate Extracter . get Coordinates ( test Geom ) ; for (  Iterator i = coords . iterator ( ) ; i . has Next ( ) ; ) {  Coordinate p = (  Coordinate ) i . next ( ) ; int loc = target Point Locator . locate ( p ) ; if ( loc !=  Location .  EXTERIOR ) return _ BOOL ; } return _ BOOL ; }
private  Simple Object search Inner (  Request Context context , long snapshot Time ) throws  Response Exception {  List <  Simple Object > results = new  Array List < > ( ) ; for (  T item : search Impl ( context , snapshot Time ) ) { results . add ( convert To Json ( item , context , snapshot Time ) ) ; }  Simple Object response = new  Simple Object ( ) ; response . put ( _ STR , results ) ; response . put ( _ STR ,  Utils . to Iso8601 ( new  Date ( snapshot Time ) ) ) ; return response ; }
public void total Reset ( ) { if ( wants Events ( ) ) { set Wants Events ( _ BOOL ) ; if ( unpick Btn != null ) { unpick Btn . do Click ( ) ; } if ( mouse Delegator != null ) {  Map Mouse Mode [ ] modes = mouse Delegator . get Mouse Modes ( ) ; if ( modes != null && modes . length > _ NUM ) mouse Delegator . set Active Mouse Mode ( modes [ _ NUM ] ) ; } } }
protected  Value parse QName Or Boolean ( ) throws  IOException ,  RDFParse Exception { int c = read Code Point ( ) ; if ( c == - _ NUM ) { throw EOFException ( ) ; } if ( c != _ STR && !  Turtle Util . is Prefix Start Char ( c ) ) { report Error ( _ STR + new  String (  Character . to Chars ( c ) ) + _ STR ,  Basic Parser Settings .  VERIFY_ RELATIVE_ URIS ) ; }  String namespace = null ; if ( c == _ STR ) { namespace = get Namespace ( _ STR ) ; } else {  String Builder prefix = new  String Builder ( _ NUM ) ; append Codepoint ( prefix , c ) ; int previous Char = c ; c = read Code Point ( ) ; while (  Turtle Util . is Prefix Char ( c ) ) { append Codepoint ( prefix , c ) ; previous Char = c ; c = read Code Point ( ) ; } if ( c != _ STR ) {  String value = prefix . to String ( ) ; if ( value . equals ( _ STR ) || value . equals ( _ STR ) ) { unread ( c ) ; return create Literal ( value , null ,  XMLSchema .  BOOLEAN , get Line Number ( ) , - _ NUM ) ; } } else { if ( previous Char == _ STR ) { report Fatal Error ( _ STR ) ; } } verify Character Or Fail ( c , _ STR ) ; namespace = get Namespace ( prefix . to String ( ) ) ; }  String Builder local Name = new  String Builder ( _ NUM ) ; c = read Code Point ( ) ; if (  Turtle Util . is Name Start Char ( c ) ) { if ( c == _ STR ) { local Name . append ( read Local Escaped Char ( ) ) ; } else { append Codepoint ( local Name , c ) ; } int previous Char = c ; c = read Code Point ( ) ; while (  Turtle Util . is Name Char ( c ) ) { if ( c == _ STR ) { local Name . append ( read Local Escaped Char ( ) ) ; } else { append Codepoint ( local Name , c ) ; } previous Char = c ; c = read Code Point ( ) ; } unread ( c ) ; if ( previous Char == _ STR ) { unread ( previous Char ) ; local Name . delete Char At ( local Name . length ( ) - _ NUM ) ; } } else { unread ( c ) ; }  String local Name String = local Name . to String ( ) ; for ( int i = _ NUM ; i < local Name String . length ( ) ; i ++ ) { if ( local Name String . char At ( i ) == _ STR ) { if ( i > local Name String . length ( ) - _ NUM || !  ASCIIUtil . is Hex ( local Name String . char At ( i + _ NUM ) ) || !  ASCIIUtil . is Hex ( local Name String . char At ( i + _ NUM ) ) ) { report Fatal Error ( _ STR + local Name String ) ; } } } return create URI ( namespace + local Name String ) ; }
public  Time Series Collection (  Time Series series ) { this ( series ,  Time Zone . get Default ( ) ) ; }
public static <  E >  List <  E > of (  E e1 ,  E e2 ) {  List <  E > list = new  Array List < > ( ) ; list . add ( e1 ) ; list . add ( e2 ) ; return list ; }
@  Override public void add Attribute (  String name , double value ) {  String str =  Double . to String ( value ) ; if ( str . ends With ( _ STR ) ) str = str . substring ( _ NUM , str . length ( ) - _ NUM ) ; current . set Attribute ( name , str ) ; }
@  Request Mapping ( value = _ STR , method =  Request Method .  GET ) public @  Response Body  List <  Message > list Messages For Application ( @  Path Variable final  String application Name , @  Path Variable final  Integer nb Rows ) throws  Service Exception ,  Check Exception { if ( logger . is Debug Enabled ( ) ) { logger . debug ( _ STR ) ; logger . debug ( _ STR + application Name ) ; logger . debug ( _ STR + nb Rows ) ; }  User user = authentification Utils . get Authentificated User ( ) ;  String application Name Local = application Name . replace All ( _ STR , _ STR ) ; return message Service . list By App ( user , application Name Local , nb Rows ) ; }
public void fill_area (  Pla Point Float [ ] [ ] p_point_lists ,  Graphics p_g ,  Color p_color , double p_translucency_factor ) { if ( p_color == null ) return ;  General Path draw_path = new  General Path (  General Path .  WIND_ EVEN_ ODD ) ; for ( int jndex = _ NUM ; jndex < p_point_lists . length ; ++ jndex ) {  Polygon draw_polygon = new  Polygon ( ) ;  Pla Point Float [ ] curr_point_list = p_point_lists [ jndex ] ; for ( int index = _ NUM ; index < curr_point_list . length ; index ++ ) {  Point2 D curr_corner = coordinate_transform . board_to_screen ( curr_point_list [ index ] ) ; draw_polygon . add Point ( ( int )  Math . round ( curr_corner . get X ( ) ) , ( int )  Math . round ( curr_corner . get Y ( ) ) ) ; } draw_path . append ( draw_polygon , _ BOOL ) ; }  Graphics2 D g2 = (  Graphics2 D ) p_g ; g2 . set Color ( p_color ) ; set_translucency ( g2 , p_translucency_factor ) ; g2 . set Rendering Hint (  Rendering Hints .  KEY_ ANTIALIASING ,  Rendering Hints .  VALUE_ ANTIALIAS_ ON ) ; g2 . fill ( draw_path ) ; }
@  Override public void zoom Domain Axes ( double factor ,  Plot Rendering Info info ,  Point2 D source ) { zoom Domain Axes ( factor , info , source , _ BOOL ) ; }
@  Override public void on Bind View Holder (  Category View Holder holder , int position ) { int amount Due = _ NUM ; if ( position == _ NUM ) { for (  Category category : m Categories ) { amount Due += m Due Challenge Counts . get ( category . get Id ( ) ) ; } holder . bind All Categories Card ( amount Due ) ; } else { final  Category category = m Categories . get ( position - _ NUM ) ; holder . bind Card ( category , m Due Challenge Counts . get ( category . get Id ( ) ) ) ; } }
public  Array ( final double [ ] array ) { this ( array ,  Enum Set . none Of (  Address .  Flags . class ) ) ; }
public static  Buffered Image crop Image (  Buffered Image image , int crop Width , int crop Height ) {  Buffered Image ret Img = null ; int width = _ NUM ; int height = _ NUM ; width = image . get Width ( ) ; height = image . get Height ( ) ; ret Img = new  Buffered Image ( crop Width , crop Height ,  Buffered Image .  TYPE_ INT_ RGB ) ; for ( int i = _ NUM ; i < crop Width ; i ++ ) { for ( int j = _ NUM ; j < crop Height ; j ++ ) { if ( i < width && j < height ) { ret Img . set RGB ( i , j , image . get RGB ( i , j ) ) ; } else { ret Img . set RGB ( i , j , _ NUM ) ; } } } return ret Img ; }
private  Encrypted Properties (  String password ) {  PBEParameter Spec ps = new javax . crypto . spec .  PBEParameter Spec ( salt , _ NUM ) ;  Secret Key Factory kf ; try { kf =  Secret Key Factory . get Instance ( _ STR ) ;  Secret Key k = kf . generate Secret ( new javax . crypto . spec .  PBEKey Spec ( password . to Char Array ( ) ) ) ; encrypter =  Cipher . get Instance ( _ STR ) ; decrypter =  Cipher . get Instance ( _ STR ) ; encrypter . init (  Cipher .  ENCRYPT_ MODE , k , ps ) ; decrypter . init (  Cipher .  DECRYPT_ MODE , k , ps ) ; } catch (  No Such Algorithm Exception e ) { e . print Stack Trace ( ) ; } catch (  No Such Padding Exception e ) { e . print Stack Trace ( ) ; } catch (  Invalid Key Spec Exception e ) { e . print Stack Trace ( ) ; } catch (  Invalid Key Exception e ) { e . print Stack Trace ( ) ; } catch (  Invalid Algorithm Parameter Exception e ) { e . print Stack Trace ( ) ; } }
static  String encode Entities (  String source ) {  String Buffer buffer = new  String Buffer ( ) ;  String encoded ; for ( int index = _ NUM ; index < source . length ( ) ; index ++ ) { char ch = source . char At ( index ) ; if ( ( encoded = encode Entity ( ch ) ) != null ) { buffer . append ( encoded ) ; } else { buffer . append ( ch ) ; } } return buffer . to String ( ) ; }
public static boolean is File Type Supported ( int file Type ,  Sequence sequence ) {  List providers = get Midi File Writers ( ) ; for ( int i = _ NUM ; i < providers . size ( ) ; i ++ ) {  Midi File Writer writer = (  Midi File Writer ) providers . get ( i ) ; if ( writer . is File Type Supported ( file Type , sequence ) ) { return _ BOOL ; } } return _ BOOL ; }
public void create (  SSOToken token ,  String obj Name ,  Map attrs ) throws  SMSException ,  SSOException { if ( obj Name == null || obj Name . length ( ) == _ NUM || attrs == null ) { throw new  Illegal Argument Exception ( _ STR + _ STR ) ; }  String obj Key = obj Name . to Lower Case ( ) ;  String filepath = null ; m RWLock . read Request ( ) ; try { filepath = m Name Map . get Property ( obj Key ) ; if ( filepath != null ) {  String errmsg = _ STR + obj Name + _ STR + filepath ; m Debug . error ( errmsg ) ; throw new  Service Already Exists Exception ( errmsg ) ; } } finally { m RWLock . read Done ( ) ; } m RWLock . write Request ( ) ; try { filepath = m Name Map . get Property ( obj Key ) ; if ( filepath != null ) {  String errmsg = _ STR + obj Name + _ STR + filepath ; m Debug . error ( errmsg ) ; throw new  Service Already Exists Exception ( errmsg ) ; } filepath = get Attr File ( obj Name ) ;  File filehandle = new  File ( filepath ) ;  File parent Dir = filehandle . get Parent File ( ) ; if ( parent Dir . is Directory ( ) ) {  String errmsg = _ STR + obj Name + _ STR + parent Dir . get Path ( ) + _ STR ; m Debug . error ( errmsg ) ; throw new  Service Already Exists Exception ( errmsg ) ; }  Set sunserviceids = null ;  Set sunxmlkeyvals = null ;  Properties props = new  Properties ( ) ;  Set keys = attrs . key Set ( ) ; if ( keys != null ) { for (  Iterator i = keys . iterator ( ) ; i . has Next ( ) ; ) {  String key = (  String ) i . next ( ) ;  Set vals = (  Set ) attrs . get ( key ) ; if ( key . equals Ignore Case (  SMSEntry .  ATTR_ SERVICE_ ID ) ) { sunserviceids = vals ; } else if ( key . equals Ignore Case (  SMSEntry .  ATTR_ XML_ KEYVAL ) ) { sunxmlkeyvals = vals ; } props . put ( key , to Val String ( vals ) ) ; } } try { if ( ! parent Dir . mkdirs ( ) ) {  String errmsg = _ STR + obj Name + _ STR + parent Dir . get Path ( ) ; m Debug . error ( errmsg ) ; throw new  SMSException ( errmsg ) ; } try { if ( ! filehandle . create New File ( ) ) {  String errmsg = _ STR + obj Name + _ STR + filepath ; m Debug . error ( errmsg ) ; throw new  SMSException ( errmsg ) ; } } catch (  IOException e ) {  String errmsg = _ STR + obj Name + _ STR + filehandle . get Path ( ) + _ STR + e . get Message ( ) ; m Debug . error ( _ STR , e ) ; throw new  SMSException ( errmsg ) ; } save Properties ( props , filehandle , obj Name ) ; if ( sunserviceids != null && ! sunserviceids . is Empty ( ) ) { create Sun Service Id Files ( parent Dir , sunserviceids ) ; } if ( sunxmlkeyvals != null && ! sunxmlkeyvals . is Empty ( ) ) { create Sun Xml Key Val Files ( parent Dir , sunxmlkeyvals ) ; } m Name Map . set Property ( obj Key , filepath ) ; save Properties ( m Name Map , m Name Map Handle , null ) ; } catch (  SMSException e ) { delete Dir ( parent Dir ) ; m Name Map . remove ( obj Key ) ; throw e ; } } finally { m RWLock . write Done ( ) ; } }
public static int run Open DSSetup (  Map map ) {  String [ ] setup Cmd = { _ STR , _ STR , _ STR , _ STR ,  Constants .  DEFAULT_ ROOT_ SUFFIX , _ STR , _ STR , _ STR , _ STR , _ STR , _ STR , _ STR , _ STR , _ STR , _ STR , _ STR , _ STR , _ STR , _ STR , _ STR , _ STR } ; setup Cmd [ _ NUM ] = (  String ) map . get (  Setup Constants .  CONFIG_ VAR_ DIRECTORY_ ADMIN_ SERVER_ PORT ) ; setup Cmd [ _ NUM ] = (  String ) map . get (  Setup Constants .  CONFIG_ VAR_ ROOT_ SUFFIX ) ; setup Cmd [ _ NUM ] = (  String ) map . get (  Setup Constants .  CONFIG_ VAR_ DS_ MGR_ DN ) ; setup Cmd [ _ NUM ] = (  String ) map . get (  Setup Constants .  CONFIG_ VAR_ DIRECTORY_ SERVER_ PORT ) ; setup Cmd [ _ NUM ] = (  String ) map . get (  Setup Constants .  CONFIG_ VAR_ DIRECTORY_ JMX_ SERVER_ PORT ) ; setup Cmd [ _ NUM ] = get Open DJHost Name ( map ) ; setup Cmd [ _ NUM ] =  System Properties . get (  Setup Constants .  DJ_ BACKEND_ TYPE_ CONFIG_ NAME ,  Setup Constants .  DJ_ BACKEND_ TYPE_ DEFAULT ) ;  Object [ ] params = { concat ( setup Cmd ) } ;  Setup Progress . report Start ( _ STR , params ) ; setup Cmd [ _ NUM ] = (  String ) map . get (  Setup Constants .  CONFIG_ VAR_ DS_ MGR_ PWD ) ; int ret =  Install DS . main CLI ( setup Cmd ,  Setup Progress . get Output Stream ( ) ,  Setup Progress . get Output Stream ( ) ,  Temp Log File . new Temp Log File ( _ STR ) ) ; if ( ret == _ NUM ) {  Setup Progress . report End ( _ STR , null ) ; } else {  Setup Progress . report End ( _ STR , null ) ; } return ret ; }
public void specify Lines ( int line_num ) { int child Num = _ NUM ; if ( line_num > line Num List . size ( ) ) { line_num = line Num List . size ( ) ; } for ( int i = _ NUM ; i < line_num ; i ++ ) { child Num += line Num List . get ( i ) ; }  List <  View > view List = new  Array List < > ( ) ; for ( int i = _ NUM ; i < child Num ; i ++ ) { view List . add ( get Child At ( i ) ) ; } remove All Views ( ) ; for (  View v : view List ) { add View ( v ) ; } }
public  File create File Object (  String path ) { if ( path . length ( ) >= _ NUM && path . char At ( _ NUM ) == _ STR &&  Character . is Letter ( path . char At ( _ NUM ) ) ) { if ( path . length ( ) == _ NUM ) { path += _ STR ; } else if ( path . char At ( _ NUM ) != _ STR ) { path = path . substring ( _ NUM , _ NUM ) + _ STR + path . substring ( _ NUM ) ; } } return super . create File Object ( path ) ; }
private boolean compute Any Visible (  Viewer viewer ,  Object [ ] elements ) { boolean element Found = _ BOOL ; for ( int i = _ NUM ; i < elements . length && ! element Found ; i ++ ) {  Object element = elements [ i ] ; element Found = is Element Visible ( viewer , element ) ; } return element Found ; }
private boolean parse Attribute (  Attributes Impl attrs ) throws  Jasper Exception {  String q Name = parse Name ( ) ; if ( q Name == null ) return _ BOOL ;  String local Name = q Name ;  String uri = _ STR ; int index = q Name . index Of ( _ STR ) ; if ( index != - _ NUM ) {  String prefix = q Name . substring ( _ NUM , index ) ; uri = page Info . get URI ( prefix ) ; if ( uri == null ) { err . jsp Error ( reader . mark ( ) , _ STR , prefix ) ; } local Name = q Name . substring ( index + _ NUM ) ; } reader . skip Spaces ( ) ; if ( ! reader . matches ( _ STR ) ) err . jsp Error ( reader . mark ( ) , _ STR ) ; reader . skip Spaces ( ) ; char quote = ( char ) reader . next Char ( ) ; if ( quote != _ STR && quote != _ STR ) err . jsp Error ( reader . mark ( ) , _ STR ) ;  String watch String = _ STR ; if ( reader . matches ( _ STR ) ) watch String = _ STR ; watch String = watch String + quote ;  String attr Value = parse Attribute Value ( watch String ) ; attrs . add Attribute ( uri , local Name , q Name , _ STR , attr Value ) ; return _ BOOL ; }
public static byte [ ] strip Continue From Requests ( byte [ ] input ) { byte [ ] result = input ; while ( _ BOOL ) {  String initial Part = new  String ( result , _ NUM ,  Math . min (  MAX_ HEADER_ SIZE , result . length ) ) ;  Matcher m =  CONTINUE_ PATTERN . matcher ( initial Part ) ; if ( m . find ( ) ) { int string Index = m . start ( ) ; final int string Length = m . end ( ) - m . start ( ) ; result = new byte [ input . length - string Length ] ;  System . arraycopy ( input , _ NUM , result , _ NUM , string Index ) ;  System . arraycopy ( input , string Index + string Length , result , string Index , input . length - ( string Index + string Length ) ) ; } else { break ; } } return result ; }
@  Suppress Warnings ( _ STR ) public void test_stream API2 ( ) { final  List <  IBinding Set > expected Solutions = new  Array List <  IBinding Set > ( ) ; { final  IBinding Set expected = new  List Binding Set ( ) ; expected . set (  Var . var ( _ STR ) , new  Constant <  IV > ( term Id ) ) ; expected Solutions . add ( expected ) ; } { final  IBinding Set expected = new  List Binding Set ( ) ; expected Solutions . add ( expected ) ; } { final  IBinding Set expected = new  List Binding Set ( ) ; expected . set (  Var . var ( _ STR ) , new  Constant <  IV > ( term Id ) ) ; expected . set (  Var . var ( _ STR ) , new  Constant <  IV > ( blob IV ) ) ; expected Solutions . add ( expected ) ; } do Encode Decode Test ( expected Solutions ) ; }
@  Override public  String to String ( ) {  String Buffer buffer = new  String Buffer ( ) ; if ( terms . size ( ) > _ NUM ) { buffer . append ( _ STR ) ; boolean first Term = _ BOOL ; for (  Split Condition condition : terms ) { if ( ! first Term ) { buffer . append ( _ STR ) ; } buffer . append ( condition . to String ( ) ) ; first Term = _ BOOL ; } buffer . append ( _ STR ) ; } else { buffer . append ( _ STR ) ; } buffer . append ( label Name ) ; if ( frequencies != null ) { buffer . append ( _ STR ) ; for ( int i = _ NUM ; i < frequencies . length ; i ++ ) { if ( i != _ NUM ) { buffer . append ( _ STR ) ; } buffer . append ( frequencies [ i ] ) ; } buffer . append ( _ STR ) ; } return buffer . to String ( ) ; }
public void insert Index Interval ( int index , int length , boolean before ) { int ins Min Index = ( before ) ? index : index + _ NUM ; int ins Max Index = ( ins Min Index + length ) - _ NUM ; for ( int i = max Index ; i >= ins Min Index ; i -- ) { set State ( i + length , value . get ( i ) ) ; } boolean set Inserted Values = ( ( get Selection Mode ( ) ==  SINGLE_ SELECTION ) ? _ BOOL : value . get ( index ) ) ; for ( int i = ins Min Index ; i <= ins Max Index ; i ++ ) { set State ( i , set Inserted Values ) ; } int lead Index = this . lead Index ; if ( lead Index > index || ( before && lead Index == index ) ) { lead Index = this . lead Index + length ; } int anchor Index = this . anchor Index ; if ( anchor Index > index || ( before && anchor Index == index ) ) { anchor Index = this . anchor Index + length ; } if ( lead Index != this . lead Index || anchor Index != this . anchor Index ) { update Lead Anchor Indices ( anchor Index , lead Index ) ; } fire Value Changed ( ) ; }
public static  Spatial Index locate And Set Shape Data (  String shape File Name ) {  Spatial Index spi = null ; if ( shape File Name == null ) { return null ; } int appendix Index = shape File Name . index Of ( _ STR ) ; if ( logger . is Loggable (  Level .  FINE ) ) { logger . fine ( _ STR + shape File Name ) ; } if ( appendix Index != - _ NUM ) { if (  Binary File . exists ( shape File Name ) ) {  String spatial Index File Name = ssx ( shape File Name ) ; if ( logger . is Loggable (  Level .  FINE ) ) { logger . fine ( _ STR + spatial Index File Name ) ; } try { spi = new  Spatial Index ( shape File Name ) ; } catch ( java . io .  IOException ioe ) { logger . warning ( ioe . get Message ( ) ) ; ioe . print Stack Trace ( ) ; spi = null ; } } else { logger . warning ( _ STR + shape File Name ) ; } } else { if ( logger . is Loggable (  Level .  FINE ) ) { logger . fine ( _ STR + shape File Name + _ STR ) ; } } return spi ; }
@  Override public  Object clone ( ) throws  Clone Not Supported Exception {  Category Axis clone = (  Category Axis ) super . clone ( ) ; clone . tick Label Font Map = new  Hash Map ( this . tick Label Font Map ) ; clone . tick Label Paint Map = new  Hash Map ( this . tick Label Paint Map ) ; clone . category Label Tool Tips = new  Hash Map ( this . category Label Tool Tips ) ; clone . category Label URLs = new  Hash Map ( this . category Label Tool Tips ) ; return clone ; }
public static boolean does File Exist (  File file ) { if ( file == null ) { return _ BOOL ; } boolean does File Exist ; try { does File Exist = file . exists ( ) ; } catch (  Exception e ) { logger . debug ( e . to String ( ) +  System . line Separator ( ) +  Stack Trace . get String From Stack Trace ( e ) ) ; does File Exist = _ BOOL ; } return does File Exist ; }
public int read ( byte [ ] bytes , int offset , int count ) throws  IOException { if ( bytes == null ) throw new  Illegal Argument Exception ( _ STR ) ; int starting Count = count ; int copy Count =  Math . min ( limit - position , count ) ; while ( _ BOOL ) {  System . arraycopy ( buffer , position , bytes , offset , copy Count ) ; position += copy Count ; count -= copy Count ; if ( count == _ NUM ) break ; offset += copy Count ; copy Count = optional ( count ) ; if ( copy Count == - _ NUM ) { if ( starting Count == count ) return - _ NUM ; break ; } if ( position == limit ) break ; } return starting Count - count ; }
private void handle Local Associated Other ( ) { for (  Array List <  Register Spec > specs : local Variables . values ( ) ) { int rop Reg = param Range End ; boolean done = _ BOOL ; do { int max Category = _ NUM ; int sz = specs . size ( ) ; for ( int i = _ NUM ; i < sz ; i ++ ) {  Register Spec ssa Spec = specs . get ( i ) ; int category = ssa Spec . get Category ( ) ; if ( ! ssa Regs Mapped . get ( ssa Spec . get Reg ( ) ) && category > max Category ) { max Category = category ; } } rop Reg = find Rop Reg For Local ( rop Reg , max Category ) ; if ( can Map Regs ( specs , rop Reg ) ) { done = try Map Regs ( specs , rop Reg , max Category , _ BOOL ) ; } rop Reg ++ ; } while ( ! done ) ; } }
public static void register (  Resource Resolver Spi resource Resolver Spi , boolean start ) {  Java Utils . check Register Permission ( ) ; synchronized ( resolver List ) { if ( start ) { resolver List . add ( _ NUM , new  Resource Resolver ( resource Resolver Spi ) ) ; } else { resolver List . add ( new  Resource Resolver ( resource Resolver Spi ) ) ; } } if ( log . is Loggable ( java . util . logging .  Level .  FINE ) ) { log . log ( java . util . logging .  Level .  FINE , _ STR + resource Resolver Spi . to String ( ) ) ; } }
private boolean process Authentication Response ( final  Http Method method ) {  LOG . trace ( _ STR + _ STR ) ; try { switch ( method . get Status Code ( ) ) { case  Http Status .  SC_ UNAUTHORIZED : return process WWWAuth Challenge ( method ) ; case  Http Status .  SC_ PROXY_ AUTHENTICATION_ REQUIRED : return process Proxy Auth Challenge ( method ) ; default : return _ BOOL ; } } catch ( final  Exception e ) { if (  LOG . is Error Enabled ( ) ) {  LOG . error ( e . get Message ( ) , e ) ; } return _ BOOL ; } }
public static  String to Hex String ( byte [ ] byte Array ) { if ( byte Array != null && byte Array . length != _ NUM ) {  String Builder builder = new  String Builder ( byte Array . length * _ NUM ) ; for ( int i = _ NUM ; i < byte Array . length ; i ++ ) { builder . append (  String . format ( _ STR , _ NUM & byte Array [ i ] ) ) ; if ( i < byte Array . length - _ NUM ) { builder . append ( _ STR ) ; } } return builder . to String ( ) ; } else { return _ STR ; } }
public <  T extends  Pipeline < ? > >  T apply (  T stream ) { stream . prev =  Optional . of ( this ) ; return stream ; }
@  Override public void draw Domain Marker (  Graphics2 D g2 ,  XYPlot plot ,  Value Axis domain Axis ,  Marker marker ,  Rectangle2 D data Area ) { if ( marker instanceof  Value Marker ) {  Value Marker vm = (  Value Marker ) marker ; double value = vm . get Value ( ) ;  Range range = domain Axis . get Range ( ) ; if ( ! range . contains ( value ) ) { return ; } double v = domain Axis . value To Java2 D ( value , data Area , plot . get Domain Axis Edge ( ) ) ;  Plot Orientation orientation = plot . get Orientation ( ) ;  Line2 D line = null ; if ( orientation ==  Plot Orientation .  HORIZONTAL ) { line = new  Line2 D .  Double ( data Area . get Min X ( ) , v , data Area . get Max X ( ) , v ) ; } else if ( orientation ==  Plot Orientation .  VERTICAL ) { line = new  Line2 D .  Double ( v , data Area . get Min Y ( ) , v , data Area . get Max Y ( ) ) ; } else { throw new  Illegal State Exception ( _ STR ) ; } final  Composite original Composite = g2 . get Composite ( ) ; g2 . set Composite (  Alpha Composite . get Instance (  Alpha Composite .  SRC_ OVER , marker . get Alpha ( ) ) ) ; g2 . set Paint ( marker . get Paint ( ) ) ; g2 . set Stroke ( marker . get Stroke ( ) ) ; g2 . draw ( line ) ;  String label = marker . get Label ( ) ;  Rectangle Anchor anchor = marker . get Label Anchor ( ) ; if ( label != null ) {  Font label Font = marker . get Label Font ( ) ; g2 . set Font ( label Font ) ;  Point2 D coords = calculate Domain Marker Text Anchor Point ( g2 , orientation , data Area , line . get Bounds2 D ( ) , marker . get Label Offset ( ) ,  Length Adjustment Type .  EXPAND , anchor ) ;  Rectangle2 D r =  Text Utils . calc Aligned String Bounds ( label , g2 , ( float ) coords . get X ( ) , ( float ) coords . get Y ( ) , marker . get Label Text Anchor ( ) ) ; g2 . set Paint ( marker . get Label Background Color ( ) ) ; g2 . fill ( r ) ; g2 . set Paint ( marker . get Label Paint ( ) ) ;  Text Utils . draw Aligned String ( label , g2 , ( float ) coords . get X ( ) , ( float ) coords . get Y ( ) , marker . get Label Text Anchor ( ) ) ; } g2 . set Composite ( original Composite ) ; } else if ( marker instanceof  Interval Marker ) {  Interval Marker im = (  Interval Marker ) marker ; double start = im . get Start Value ( ) ; double end = im . get End Value ( ) ;  Range range = domain Axis . get Range ( ) ; if ( ! ( range . intersects ( start , end ) ) ) { return ; } double start2d = domain Axis . value To Java2 D ( start , data Area , plot . get Domain Axis Edge ( ) ) ; double end2d = domain Axis . value To Java2 D ( end , data Area , plot . get Domain Axis Edge ( ) ) ; double low =  Math . min ( start2d , end2d ) ; double high =  Math . max ( start2d , end2d ) ;  Plot Orientation orientation = plot . get Orientation ( ) ;  Rectangle2 D rect = null ; if ( orientation ==  Plot Orientation .  HORIZONTAL ) { low =  Math . max ( low , data Area . get Min Y ( ) ) ; high =  Math . min ( high , data Area . get Max Y ( ) ) ; rect = new  Rectangle2 D .  Double ( data Area . get Min X ( ) , low , data Area . get Width ( ) , high - low ) ; } else if ( orientation ==  Plot Orientation .  VERTICAL ) { low =  Math . max ( low , data Area . get Min X ( ) ) ; high =  Math . min ( high , data Area . get Max X ( ) ) ; rect = new  Rectangle2 D .  Double ( low , data Area . get Min Y ( ) , high - low , data Area . get Height ( ) ) ; } final  Composite original Composite = g2 . get Composite ( ) ; g2 . set Composite (  Alpha Composite . get Instance (  Alpha Composite .  SRC_ OVER , marker . get Alpha ( ) ) ) ;  Paint p = marker . get Paint ( ) ; if ( p instanceof  Gradient Paint ) {  Gradient Paint gp = (  Gradient Paint ) p ;  Gradient Paint Transformer t = im . get Gradient Paint Transformer ( ) ; if ( t != null ) { gp = t . transform ( gp , rect ) ; } g2 . set Paint ( gp ) ; } else { g2 . set Paint ( p ) ; } g2 . fill ( rect ) ; if ( im . get Outline Paint ( ) != null && im . get Outline Stroke ( ) != null ) { if ( orientation ==  Plot Orientation .  VERTICAL ) {  Line2 D line = new  Line2 D .  Double ( ) ; double y0 = data Area . get Min Y ( ) ; double y1 = data Area . get Max Y ( ) ; g2 . set Paint ( im . get Outline Paint ( ) ) ; g2 . set Stroke ( im . get Outline Stroke ( ) ) ; if ( range . contains ( start ) ) { line . set Line ( start2d , y0 , start2d , y1 ) ; g2 . draw ( line ) ; } if ( range . contains ( end ) ) { line . set Line ( end2d , y0 , end2d , y1 ) ; g2 . draw ( line ) ; } } else {  Line2 D line = new  Line2 D .  Double ( ) ; double x0 = data Area . get Min X ( ) ; double x1 = data Area . get Max X ( ) ; g2 . set Paint ( im . get Outline Paint ( ) ) ; g2 . set Stroke ( im . get Outline Stroke ( ) ) ; if ( range . contains ( start ) ) { line . set Line ( x0 , start2d , x1 , start2d ) ; g2 . draw ( line ) ; } if ( range . contains ( end ) ) { line . set Line ( x0 , end2d , x1 , end2d ) ; g2 . draw ( line ) ; } } }  String label = marker . get Label ( ) ;  Rectangle Anchor anchor = marker . get Label Anchor ( ) ; if ( label != null ) {  Font label Font = marker . get Label Font ( ) ; g2 . set Font ( label Font ) ;  Point2 D coords = calculate Domain Marker Text Anchor Point ( g2 , orientation , data Area , rect , marker . get Label Offset ( ) , marker . get Label Offset Type ( ) , anchor ) ;  Rectangle2 D r =  Text Utils . calc Aligned String Bounds ( label , g2 , ( float ) coords . get X ( ) , ( float ) coords . get Y ( ) , marker . get Label Text Anchor ( ) ) ; g2 . set Paint ( marker . get Label Background Color ( ) ) ; g2 . fill ( r ) ; g2 . set Paint ( marker . get Label Paint ( ) ) ;  Text Utilities . draw Aligned String ( label , g2 , ( float ) coords . get X ( ) , ( float ) coords . get Y ( ) , marker . get Label Text Anchor ( ) ) ; } g2 . set Composite ( original Composite ) ; } }
public void init ( ) { if ( ! _initialized ) { super . init ( ) ; _detect Panel = new  Detection Panel ( this ) ;  JPanel panel = new  JPanel ( ) ; panel . set Layout ( new  Box Layout ( panel ,  Box Layout .  Y_ AXIS ) ) ; panel . add (  Box . create Vertical Glue ( ) ) ; panel . add ( _detect Panel ) ; add ( panel , _ NUM ) ; } }
@  Transactional public  String add Order ( final  JSONObject order ) throws  Service Exception { try { order . put (  Order .  ORDER_ CONFIRM_ TIME , _ NUM ) ; order . put (  Order .  ORDER_ CREATE_ TIME ,  System . current Time Millis ( ) ) ; order . put (  Order .  ORDER_ HANDLER_ ID , _ STR ) ; order . put (  Order .  ORDER_ STATUS ,  Order .  ORDER_ STATUS_ C_ INIT ) ; return order Repository . add ( order ) ; } catch ( final  Repository Exception e ) {  LOGGER . log (  Level .  ERROR , _ STR , e ) ; throw new  Service Exception ( e ) ; } }
private void copy To Buffer (  Buffer b Dest ) { if ( reassembled Data Full Size <=  MAX_ H264_ FRAME_ SIZE ) { byte [ ] final Data = new byte [ reassembled Data Full Size + _ NUM ] ; int final Data Pos = _ NUM ; final Data [ final Data Pos ] = reassembled Data NALHeader ; final Data Pos += _ NUM ; int pos Current = reassembled Data Pos Seq Start ; int pos Seq = _ NUM ; while ( ( pos Current &  VIDEO_ DECODER_ MAX_ PAYLOADS_ CHUNKS_ MASK ) != reassembled Data Pos Seq End ) { pos Seq = pos Current &  VIDEO_ DECODER_ MAX_ PAYLOADS_ CHUNKS_ MASK ;  System . arraycopy ( reassembled Data [ pos Seq ] , _ NUM , final Data , final Data Pos , reassembled Data Size [ pos Seq ] ) ; final Data Pos += reassembled Data Size [ pos Seq ] ; pos Current ++ ; }  System . arraycopy ( reassembled Data [ reassembled Data Pos Seq End ] , _ NUM , final Data , final Data Pos , reassembled Data Size [ reassembled Data Pos Seq End ] ) ; b Dest . set Data ( final Data ) ; b Dest . set Length ( reassembled Data Size [ reassembled Data Pos Seq End ] ) ; b Dest . set Offset ( _ NUM ) ; b Dest . set Timestamp ( timestamp ) ; b Dest . set Format ( format ) ; b Dest . set Flags (  Buffer .  FLAG_ RTP_ MARKER |  Buffer .  FLAG_ RTP_ TIME ) ; b Dest . set Video Orientation ( video Orientation ) ; b Dest . set Sequence Number ( seq Number ) ; } reassembled Data = null ; }
public static final void write Int Array Xml ( int [ ] val ,  String name ,  Xml Serializer out ) throws  Xml Pull Parser Exception , java . io .  IOException { if ( val == null ) { out . start Tag ( null , _ STR ) ; out . end Tag ( null , _ STR ) ; return ; } out . start Tag ( null , _ STR ) ; if ( name != null ) { out . attribute ( null , _ STR , name ) ; } final int  N = val . length ; out . attribute ( null , _ STR ,  Integer . to String (  N ) ) ; for ( int i = _ NUM ; i <  N ; i ++ ) { out . start Tag ( null , _ STR ) ; out . attribute ( null , _ STR ,  Integer . to String ( val [ i ] ) ) ; out . end Tag ( null , _ STR ) ; } out . end Tag ( null , _ STR ) ; }
private void unify Username By Email (  Map <  String ,  List <  Log Commit Info > > username Map ) { for (  Entry <  String ,  List <  Log Commit Info > > entry : username Map . entry Set ( ) ) {  List <  String > names = get Names List ( entry . get Value ( ) ) ;  String new User Name = names . get ( _ NUM ) ; if ( names . size ( ) > _ NUM ) new User Name = get New Name ( names ) ; for (  Log Commit Info commit : entry . get Value ( ) ) { commit . set User Name ( new User Name ) ; } } }
public static  Connection ensure Table Exists ( final  Table table ) throws  SQLException { establish Connection ( ) ; try ( final  Statement stmt = connection . create Statement ( ) ) { stmt . execute ( table . get Creation Statement ( ) ) ; return connection ; } }
public  ELFFormatter ( ) {  String timestamp Generator Class = lmanager . get Property (  Log Constants .  SECURE_ TIMESTAMP_ GENERATOR ) ; try {  Class clz =  Class . for Name ( timestamp Generator Class ) ; secure Timestamp Generator = (  ITimestamp Generator ) clz . new Instance ( ) ; } catch (  Class Not Found Exception cnfe ) {  Debug . error ( _ STR + _ STR , cnfe ) ; } catch (  Instantiation Exception ie ) {  Debug . error ( _ STR + _ STR , ie ) ; } catch (  Illegal Access Exception iae ) {  Debug . error ( _ STR + _ STR , iae ) ; } }
public static  String read All ( final  URL url ) throws  IOException { try (  Input Stream input = url . open Stream ( ) ) { return read All ( input ) ; } }
public static  Data Network init Network ( ) {  Random random = new  Random (  System . current Time Millis ( ) ) ; int id = random . next Int ( ) ; while ( used Ids . contains ( id ) ) { id = random . next Int ( ) ; } ;  Data Network net = new  Data Network ( ) ; used Ids . add ( id ) ; net . network ID = id ; return net ; }
public static  String format File Size ( int bytes ) { if ( bytes <= _ NUM ) return null ; if ( bytes < _ NUM ) { return bytes + _ STR ; } else if ( bytes < _ NUM * _ NUM ) { return  String . format ( _ STR , bytes / _ NUM ) ; } else if ( bytes < _ NUM * _ NUM * _ NUM ) { return  String . format ( _ STR , bytes / ( _ NUM * _ NUM ) ) ; } else { return  String . format ( _ STR , bytes / ( _ NUM * _ NUM * _ NUM ) ) ; } }
void update Usb Mass Storage Notification ( boolean available ) { if ( available ) {  Intent intent = new  Intent ( ) ; intent . set Class ( m Context , com . android . systemui . usb .  Usb Storage Activity . class ) ; intent . set Flags (  Intent .  FLAG_ ACTIVITY_ NEW_ TASK ) ;  Pending Intent pi =  Pending Intent . get Activity ( m Context , _ NUM , intent , _ NUM ) ; set Usb Storage Notification ( com . android . internal .  R . string . usb_storage_notification_title , com . android . internal .  R . string . usb_storage_notification_message , com . android . internal .  R . drawable . stat_sys_data_usb , _ BOOL , _ BOOL , pi ) ; } else { set Usb Storage Notification ( _ NUM , _ NUM , _ NUM , _ BOOL , _ BOOL , null ) ; } }
public static  NV [ ] concat ( final  NV [ ] a , final  NV [ ] b ) { if ( a == null && b == null ) return a ; if ( a == null ) return b ; if ( b == null ) return a ; final  NV [ ] c = new  NV [ a . length + b . length ] ;  System . arraycopy ( a , _ NUM , c , _ NUM , a . length ) ;  System . arraycopy ( b , _ NUM , c , a . length , b . length ) ; return c ; }
public void delete By App Id (  Long app Id ) {  List <  Config > configs = config Dao . list By App Id ( app Id , _ NUM , _ NUM ) ; if ( configs != null && ! configs . is Empty ( ) ) { for (  Config config : configs ) { delete ( config ) ; } } }
protected int check IPHistory ( ) { int ret Val = _ NUM ;  String ip History Values = null ;  String new History = client IP ; int history Count = _ NUM ; if (  IPHistory Attribute != null ) { ip History Values = get Identity Attribute String (  IPHistory Attribute ) ; if ( debug . message Enabled ( ) ) { debug . message ( _ STR ,  ADAPTIVE , client IP , ip History Values ) ; } if ( ip History Values != null ) {  String Tokenizer st = new  String Tokenizer ( ip History Values , _ STR ) ; while ( st . has More Tokens ( ) ) {  String the IP = st . next Token ( ) ; history Count += _ NUM ; if ( history Count <  IPHistory Count ) { new History += _ STR + the IP ; } if ( client IP . equals ( the IP ) ) { ret Val =  IPHistory Score ; } } } } if (  IPHistory Save && ret Val == _ NUM ) { post Auth NMap . put ( _ STR , new History ) ; post Auth NMap . put ( _ STR ,  IPHistory Attribute ) ; } if ( !  IPHistory Invert ) { ret Val =  IPHistory Score - ret Val ; } return ret Val ; }
private  View move Selection ( int delta , int children Left , int children Right ) { if (  DEBUG )  Log . i (  TAG , _ STR + delta + _ STR + children Left +  CHILDREN_ RIGHT + children Right +  M_ FIRST_ POSITION + m First Position ) ; final int fading Edge Length = get Horizontal Fading Edge Length ( ) ; final int selected Position = m Selected Position ; final int num Rows = m Num Rows ; final int horizontal Spacing = m Horizontal Spacing ; int old Column Start ; int column Start ; int column End = - _ NUM ; if ( ! m Stack From Bottom ) { old Column Start = ( selected Position - delta ) - ( ( selected Position - delta ) % num Rows ) ; column Start = selected Position - ( selected Position % num Rows ) ; } else { int inverted Selection = m Item Count - _ NUM - selected Position ; column End = m Item Count - _ NUM - ( inverted Selection - ( inverted Selection % num Rows ) ) ; column Start =  Math . max ( _ NUM , column End - num Rows + _ NUM ) ; inverted Selection = m Item Count - _ NUM - ( selected Position - delta ) ; old Column Start = m Item Count - _ NUM - ( inverted Selection - ( inverted Selection % num Rows ) ) ; old Column Start =  Math . max ( _ NUM , old Column Start - num Rows + _ NUM ) ; } final int row Delta = column Start - old Column Start ; final int left Selection Pixel = get Left Selection Pixel ( children Left , fading Edge Length , column Start ) ; final int right Selection Pixel = get Right Selection Pixel ( children Right , fading Edge Length , num Rows , column Start ) ; m First Position = column Start ;  View sel ;  View reference View ; if ( row Delta > _ NUM ) { final int old Right = m Reference View In Selected Row == null ? _ NUM : m Reference View In Selected Row . get Right ( ) ; sel = make Column ( m Stack From Bottom ? column End : column Start , old Right + horizontal Spacing , _ BOOL ) ; reference View = m Reference View ; adjust For Right Fading Edge ( reference View , left Selection Pixel , right Selection Pixel ) ; } else if ( row Delta < _ NUM ) { final int old Top = m Reference View In Selected Row == null ? _ NUM : m Reference View In Selected Row . get Left ( ) ; sel = make Column ( m Stack From Bottom ? column End : column Start , old Top - horizontal Spacing , _ BOOL ) ; reference View = m Reference View ; adjust For Left Fading Edge ( reference View , left Selection Pixel , right Selection Pixel ) ; } else { final int old Top = m Reference View In Selected Row == null ? _ NUM : m Reference View In Selected Row . get Left ( ) ; sel = make Column ( m Stack From Bottom ? column End : column Start , old Top , _ BOOL ) ; reference View = m Reference View ; } if ( ! m Stack From Bottom ) { fill Left ( column Start - num Rows , reference View . get Left ( ) - horizontal Spacing ) ; adjust Views Left Or Right ( ) ; fill Right ( column Start + num Rows , reference View . get Right ( ) + horizontal Spacing ) ; } else { fill Right ( column Start + num Rows , reference View . get Right ( ) + horizontal Spacing ) ; adjust Views Left Or Right ( ) ; fill Left ( column Start - _ NUM , reference View . get Left ( ) - horizontal Spacing ) ; } return sel ; }
@  Override public  Shape Tile Simplex intersection (  Shape Tile Simplex p_other ) { if ( is_empty ( ) || p_other . is_empty ( ) ) return  EMPTY ;  Array List <  Pla Line Int > new_arr = new  Array List <  Pla Line Int > ( lines_size ( ) + p_other . lines_size ( ) ) ; new_arr . add All ( lines_list ) ; new_arr . add All ( p_other . lines_list ) ;  Shape Tile Simplex result = new  Shape Tile Simplex ( new_arr ) ; return result . remove_redundant_lines ( ) ; }
public static void change UID ( long old UID , long new UID ,  String from File ,  String to File ) throws  Exception {  String input File ;  String temp File ;  File file ;  String content ;  String line ;  Buffered Reader reader ;  Buffered Writer writer ; if ( ! is KOML ( from File ) ) { input File = from File + _ STR ; binary To KOML ( from File , input File ) ; } else { input File = from File ; } reader = new  Buffered Reader ( new  File Reader ( input File ) ) ; content = _ STR ; while ( ( line = reader . read Line ( ) ) != null ) { if ( ! content . equals ( _ STR ) ) content += _ STR ; content += line ; } reader . close ( ) ; content = content . replace All ( _ STR +  Long . to String ( old UID ) + _ STR , _ STR +  Long . to String ( new UID ) + _ STR ) ; temp File = input File + _ STR ; writer = new  Buffered Writer ( new  File Writer ( temp File ) ) ; writer . write ( content ) ; writer . flush ( ) ; writer . close ( ) ; if ( ! is KOML ( to File ) ) { koml To Binary ( temp File , to File ) ; } else { writer = new  Buffered Writer ( new  File Writer ( to File ) ) ; writer . write ( content ) ; writer . flush ( ) ; writer . close ( ) ; } file = new  File ( temp File ) ; file . delete ( ) ; }
public static double create Double Setting ( final  Map <  String ,  String > raw Settings , final  String setting Name , final double default Value ) { final  String setting String = raw Settings . get ( setting Name ) ; if ( setting String == null ) { return default Value ; } else { try { return  Double . parse Double ( setting String ) ; } catch ( final  Number Format Exception exception ) {  CUtility Functions . log Exception ( exception ) ; return default Value ; } } }
private  Item lookup Do (  Template tmpl ) { if ( is Empty ( tmpl . service Types ) || tmpl . service ID != null ) {  Item Iter iter = matching Items ( tmpl ) ; if ( iter . has Next ( ) ) return iter . next ( ) ; return null ; }  List services = matching Services ( tmpl . service Types ) ; long now =  System Time . time Millis ( ) ; int slen = services . size ( ) ; if ( slen == _ NUM ) return null ; int srand = random . next Int (  Integer .  MAX_ VALUE ) % slen ; for ( int i = _ NUM ; i < slen ; i ++ ) {  Svc Reg reg = (  Svc Reg ) services . get ( ( i + srand ) % slen ) ; if ( reg . lease Expiration > now && match Attributes ( tmpl , reg . item ) ) return reg . item ; } return null ; }
@  Override public boolean run After (  List tasks , int size ) { for ( int i = _ NUM ; i < size ; i ++ ) {  Cache Task t = (  Cache Task ) tasks . get ( i ) ; if ( t instanceof  Register Listener Task || t instanceof  Lookup Task || t instanceof  Notify Event Task ) {  Proxy Reg other Reg = t . get Proxy Reg ( ) ; if ( reg . equals ( other Reg ) ) { if ( this Task Seq N > t . get Seq N ( ) ) return _ BOOL ; } } } return super . run After ( tasks , size ) ; }
private void create Index (  String index Name , boolean unique , boolean scalar Required , boolean lax ,  Json Path [ ] columns ,  String language ) throws  Oracle Exception {  Prepared Statement stmt = null ; if ( index Name == null ) throw  SODAUtils . make Exception (  SODAMessage .  EX_ ARG_ CANNOT_ BE_ NULL , _ STR ) ; index Name =  Collection Descriptor . string To Identifier ( index Name ) ;  String sqltext = null ; if ( columns == null || columns . length == _ NUM ) { if ( ( options . content Data Type ==  Collection Descriptor .  NCHAR_ CONTENT ) || ( options . content Data Type ==  Collection Descriptor .  NCLOB_ CONTENT ) ) { throw  SODAUtils . make Exception (  SODAMessage .  EX_ UNSUPPORTED_ INDEX_ CREATE , options . get Content Data Type ( ) ) ; } else if ( options . content Lob Encrypt !=  Collection Descriptor .  LOB_ ENCRYPT_ NONE ) { throw  SODAUtils . make Exception (  SODAMessage .  EX_ UNSUPPORTED_ ENCRYPTED_ INDEX_ CREATE ) ; } else if ( options . key Data Type ==  Collection Descriptor .  NCHAR_ KEY ) { throw  SODAUtils . make Exception (  SODAMessage .  EX_ UNSUPPORTED_ INDEX_ CREATE2 ) ; } sqltext = build CTXIndex DDL ( index Name , language ) ; } else { sqltext = build Index DDL ( index Name , unique , scalar Required , lax , columns ) ; } try { metrics . start Timing ( ) ; if (  Oracle Log . is Logging Enabled ( ) ) log . info ( _ STR + sqltext ) ; stmt = conn . prepare Statement ( sqltext ) ; stmt . execute ( ) ; if (  Oracle Log . is Logging Enabled ( ) ) log . info ( _ STR + index Name ) ; stmt . close ( ) ; stmt = null ; metrics . record DDL ( ) ; } catch (  SQLException e ) { if ( e . get Error Code ( ) ==  ORA_ SQL_ OBJECT_ EXISTS ) { if (  Oracle Log . is Logging Enabled ( ) ) log . warning ( e . to String ( ) ) ; } else { if (  Oracle Log . is Logging Enabled ( ) ) log . warning ( e . to String ( ) ) ; throw  SODAUtils . make Exception With SQLText ( e , sqltext ) ; } } finally { for (  String message :  SODAUtils . close Cursor ( stmt , null ) ) { if (  Oracle Log . is Logging Enabled ( ) ) log . severe ( message ) ; } } }
public double p Norm ( double p ) { if ( p <= _ NUM ) throw new  Illegal Argument Exception ( _ STR + p ) ; double result = _ NUM ; if ( p == _ NUM ) { for (  Index Value iv : this ) result += abs ( iv . get Value ( ) ) ; } else if ( p == _ NUM ) { for (  Index Value iv : this ) result += iv . get Value ( ) * iv . get Value ( ) ; result =  Math . sqrt ( result ) ; } else if (  Double . is Infinite ( p ) ) { for (  Index Value iv : this ) result =  Math . max ( result , abs ( iv . get Value ( ) ) ) ; } else { for (  Index Value iv : this ) result += pow ( abs ( iv . get Value ( ) ) , p ) ; result = pow ( result , _ NUM / p ) ; } return result ; }
public static  File create Testing File (  Path relative Path ) {  Path path = relative Path . to Absolute Path ( ) ; if ( ! in Target Dir ( path ) ) { throw new  Illegal State Exception ( _ STR + relative Path + _ STR ) ; } return  Io Util . create File ( path ) ; }
public static  String remove Cross Reference (  String text ) { if (  Strings . is Null Or Empty ( text ) ) { return _ STR ; }  Pattern pattern =  Pattern . compile ( _ STR + _ STR ) ;  Matcher matcher = pattern . matcher ( text ) ;  String Buffer result = new  String Buffer ( ) ; while ( matcher . find ( ) ) {  String replacement Text = matcher . group ( _ STR ) ; replacement Text =  Matcher . quote Replacement ( replacement Text ) ; matcher . append Replacement ( result , replacement Text ) ; } matcher . append Tail ( result ) ; return result . to String ( ) ; }
public static  String row To String (  JSONArray ja ) {  String Buffer sb = new  String Buffer ( ) ; for ( int i = _ NUM ; i < ja . length ( ) ; i += _ NUM ) { if ( i > _ NUM ) { sb . append ( _ STR ) ; }  Object object = ja . opt ( i ) ; if ( object != null ) {  String string = object . to String ( ) ; if ( string . length ( ) > _ NUM && ( string . index Of ( _ STR ) >= _ NUM || string . index Of ( _ STR ) >= _ NUM || string . index Of ( _ STR ) >= _ NUM || string . index Of ( _ NUM ) >= _ NUM || string . char At ( _ NUM ) == _ STR ) ) { sb . append ( _ STR ) ; int length = string . length ( ) ; for ( int j = _ NUM ; j < length ; j += _ NUM ) { char c = string . char At ( j ) ; if ( c >= _ STR && c != _ STR ) { sb . append ( c ) ; } } sb . append ( _ STR ) ; } else { sb . append ( string ) ; } } } sb . append ( _ STR ) ; return sb . to String ( ) ; }
protected boolean update Attachment Point ( ) { boolean moved = _ BOOL ; this . old APs = attachment Points ; if ( attachment Points == null || attachment Points . is Empty ( ) ) { return _ BOOL ; }  List <  Attachment Point > ap List = new  Array List <  Attachment Point > ( ) ; if ( attachment Points != null ) { ap List . add All ( attachment Points ) ; }  Map <  Datapath Id ,  Attachment Point > new Map = get APMap ( ap List ) ; if ( new Map == null || new Map . size ( ) != ap List . size ( ) ) { moved = _ BOOL ; } if ( moved ) { log . info ( _ STR , attachment Points , new Map ) ;  List <  Attachment Point > new APList = new  Array List <  Attachment Point > ( ) ; if ( new Map != null ) { new APList . add All ( new Map . values ( ) ) ; } this . attachment Points = new APList ; } return moved ; }
public void add All (  List <  Soft Wrap Impl > soft Wraps ) { my Wraps . add All ( soft Wraps ) ; }
public static  String convert Bytes To GBIn Str (  Long size ) { if ( size == null ) { return  String . format ( _ STR ) ; } return  String . format ( _ STR , ( size / ( double )  GB ) ) ; }
public static  String truncate ( final  String string , final int max Len ) { if ( string . length ( ) <= max Len ) return string ; else return string . substring ( _ NUM , max Len ) ; }
public void perform Ranking Update (  Map <  Integer ,  Integer > legion Ranking ) { log . info ( _ STR ) ; long start Time =  System . current Time Millis ( ) ;  Iterator <  Legion > legions Iterator = all Cached Legions . iterator ( ) ; int legions Updated = _ NUM ; this . legion Ranking = legion Ranking ; while ( legions Iterator . has Next ( ) ) {  Legion legion = legions Iterator . next ( ) ; if ( legion Ranking . contains Key ( legion . get Legion Id ( ) ) ) { legion . set Legion Rank ( legion Ranking . get ( legion . get Legion Id ( ) ) ) ;  Packet Send Utility . broadcast Packet To Legion ( legion , new  SM_ LEGION_ EDIT ( _ NUM , legion ) ) ; } legions Updated ++ ; } long work Time =  System . current Time Millis ( ) - start Time ; log . info ( _ STR + work Time + _ STR + legions Updated ) ; }
public static void upto ( float self ,  Number to , @  Closure Params (  First Param . class )  Closure closure ) { float to1 = to . float Value ( ) ; if ( self <= to1 ) { for ( float i = self ; i <= to1 ; i ++ ) { closure . call ( i ) ; } } else throw new  Groovy Runtime Exception ( _ STR + to + _ STR + self + _ STR ) ; }
protected void parse DOMElement (  Element element ) throws  SAML2 Exception {  Assertion Factory assertion Factory =  Assertion Factory . get Instance ( ) ;  Protocol Factory proto Factory =  Protocol Factory . get Instance ( ) ; request Id = element . get Attribute (  SAML2 Constants .  ID ) ; validate ID ( request Id ) ; version = element . get Attribute (  SAML2 Constants .  VERSION ) ; validate Version ( version ) ;  String issue Instant Str = element . get Attribute (  SAML2 Constants .  ISSUE_ INSTANT ) ; validate Issue Instant ( issue Instant Str ) ; destination URI = element . get Attribute (  SAML2 Constants .  DESTINATION ) ; consent = element . get Attribute (  SAML2 Constants .  CONSENT ) ;  Node List n List = element . get Child Nodes ( ) ; if ( ( n List != null ) && ( n List . get Length ( ) > _ NUM ) ) { for ( int i = _ NUM ; i < n List . get Length ( ) ; i ++ ) {  Node child Node = n List . item ( i ) ;  String c Name = child Node . get Local Name ( ) ; if ( c Name != null ) { if ( c Name . equals (  SAML2 Constants .  ISSUER ) ) { validate Issuer ( ) ; name ID = assertion Factory . create Issuer ( (  Element ) child Node ) ; } else if ( c Name . equals (  SAML2 Constants .  SIGNATURE ) ) { validate Signature ( ) ; signature String =  XMLUtils . print ( (  Element ) child Node ) ; is Signed = _ BOOL ; } else if ( c Name . equals (  SAML2 Constants .  EXTENSIONS ) ) { validate Extensions ( ) ; extensions = proto Factory . create Extensions ( (  Element ) child Node ) ; } else if ( c Name . equals (  SAML2 Constants .  SUBJECT ) ) { validate Subject ( ) ; subject = assertion Factory . create Subject ( (  Element ) child Node ) ; } else if ( c Name . equals (  SAML2 Constants .  NAMEIDPOLICY ) ) { validate Name IDPolicy ( ) ; name IDPolicy = proto Factory . create Name IDPolicy ( (  Element ) child Node ) ; } else if ( c Name . equals (  SAML2 Constants .  CONDITIONS ) ) { validate Conditions ( ) ; conditions = assertion Factory . create Conditions ( (  Element ) child Node ) ; } else if ( c Name . equals (  SAML2 Constants .  REQ_ AUTHN_ CONTEXT ) ) { validate Req Authn Context ( ) ; req Authn Context = proto Factory . create Requested Authn Context ( (  Element ) child Node ) ; } else if ( c Name . equals (  SAML2 Constants .  SCOPING ) ) { validate Scoping ( ) ; scoping = proto Factory . create Scoping ( (  Element ) child Node ) ; } } } }  String force Authn Attr = element . get Attribute (  SAML2 Constants .  FORCEAUTHN ) ; if ( ( force Authn Attr != null ) && ( force Authn Attr . length ( ) > _ NUM ) ) { force Authn =  SAML2 SDKUtils . boolean Value Of ( force Authn Attr ) ; }  String is Passive Attr = element . get Attribute (  SAML2 Constants .  ISPASSIVE ) ; if ( ( is Passive Attr != null ) && ( is Passive Attr . length ( ) > _ NUM ) ) { is Passive =  SAML2 SDKUtils . boolean Value Of ( is Passive Attr ) ; } protocol Binding = element . get Attribute (  SAML2 Constants .  PROTOBINDING ) ;  String index = element . get Attribute (  SAML2 Constants .  ASSERTION_ CONSUMER_ SVC_ INDEX ) ; if ( ( index != null ) && ( index . length ( ) > _ NUM ) ) { assertion Consumer Svc Index = new  Integer ( index ) ; validate Assertion Consumer Service Index ( assertion Consumer Svc Index ) ; } assertion Consumer Service URL =  XMLUtils . unescape Special Characters ( element . get Attribute (  SAML2 Constants .  ASSERTION_ CONSUMER_ SVC_ URL ) ) ; index = element . get Attribute (  SAML2 Constants .  ATTR_ CONSUMING_ SVC_ INDEX ) ; if ( ( index != null ) && ( index . length ( ) > _ NUM ) ) { attr Consuming Svc Index = new  Integer ( index ) ; validate Attribute Consuming Service Index ( attr Consuming Svc Index ) ; } provider Name = element . get Attribute (  SAML2 Constants .  PROVIDER_ NAME ) ; }
Input Stream locate Script File (  String path ,  String pkg ,  String name ) throws  File Not Found Exception { if ( m_source Locator != null ) { m_source Locator Change Count = m_source Locator . get Change Count ( ) ;  Input Stream is = m_source Locator . locate Source ( path , pkg , name ) ; if ( is != null ) return is ; } path = path . replace ( _ STR ,  File . separator Char ) ; pkg = pkg . replace ( _ STR ,  File . separator Char ) ;  File f ; if ( path . length ( ) > _ NUM ) { try {  String pkg And Name = _ STR ; if ( pkg . length ( ) > _ NUM ) pkg And Name += pkg +  File . separator Char ; pkg And Name += name ; f = new  File ( path , pkg And Name ) ; if ( f . exists ( ) ) return new  File Input Stream ( f ) ; } catch (  Null Pointer Exception npe ) { } } if ( pkg . length ( ) > _ NUM ) { f = new  File ( pkg , name ) ; if ( f . exists ( ) ) return new  File Input Stream ( f ) ; } f = new  File ( name ) ; if ( f . exists ( ) ) return new  File Input Stream ( f ) ; return null ; }
public void add (  T item ) { if ( items . add ( item ) ) { notify Data Set Changed ( ) ; } }
private void update NFSACLs In DB (  Nfs ACLUpdate Params param ,  File Share fs ,  File Device Input Output args ) { try {  List <  Nfs ACE > ace Add = param . get Aces To Add ( ) ; if ( ace Add != null && ! ace Add . is Empty ( ) ) { for (  Nfs ACE ace : ace Add ) {  NFSShare ACL db Nfs Acl = new  NFSShare ACL ( ) ; db Nfs Acl . set Id (  URIUtil . create Id (  NFSShare ACL . class ) ) ; copy To Persist Nfs ACL ( ace , db Nfs Acl , fs , args ) ; _log . info ( _ STR , db Nfs Acl ) ; _db Client . create Object ( db Nfs Acl ) ; } }  List <  Nfs ACE > ace Modify = param . get Aces To Modify ( ) ; if ( ace Modify != null && ! ace Modify . is Empty ( ) ) { for (  Nfs ACE ace : ace Modify ) {  NFSShare ACL db Nfs Acl = new  NFSShare ACL ( ) ; copy To Persist Nfs ACL ( ace , db Nfs Acl , fs , args ) ;  NFSShare ACL db Nfs Acl Temp = get Existing Nfs Acl From DB ( db Nfs Acl , args . get File Operation ( ) ) ; if ( db Nfs Acl Temp != null ) { db Nfs Acl . set Id ( db Nfs Acl Temp . get Id ( ) ) ; _log . info ( _ STR , db Nfs Acl ) ; _db Client . update Object ( db Nfs Acl ) ; } } }  List <  Nfs ACE > ace Delete = param . get Aces To Delete ( ) ; if ( ace Delete != null && ! ace Delete . is Empty ( ) ) { for (  Nfs ACE ace : ace Delete ) {  NFSShare ACL db Nfs Acl = new  NFSShare ACL ( ) ; copy To Persist Nfs ACL ( ace , db Nfs Acl , fs , args ) ;  NFSShare ACL db Nfs Acl Temp = get Existing Nfs Acl From DB ( db Nfs Acl , args . get File Operation ( ) ) ; if ( db Nfs Acl Temp != null ) { db Nfs Acl . set Id ( db Nfs Acl Temp . get Id ( ) ) ; db Nfs Acl . set Inactive ( _ BOOL ) ; _log . info ( _ STR , db Nfs Acl ) ; _db Client . update Object ( db Nfs Acl ) ; } } } } catch (  Exception e ) { _log . error ( _ STR , e ) ; } }
public  Is Composing Parser parse ( ) throws  Parser Configuration Exception ,  SAXException ,  Parse Failure Exception { try {  SAXParser Factory factory =  SAXParser Factory . new Instance ( ) ;  SAXParser parser = factory . new SAXParser ( ) ; parser . parse ( m Input Source , this ) ; return this ; } catch (  IOException e ) { throw new  Parse Failure Exception ( _ STR , e ) ; } }
public  Builder delete Nick Name ( ) { delete Fields . add ( _ STR ) ; return this ; }
protected void incorporate Signature Value ( ) { signature Value Dom =  DSSXMLUtils . add Element ( document Dom , signature Dom ,  XMLNS ,  DS_ SIGNATURE_ VALUE ) ; signature Value Dom . set Attribute (  ID , _ STR + deterministic Id ) ; }
public static double mean ( double [ ] data , int [ ] inds ) { double mean = _ NUM ; for ( int i = _ NUM ; i < inds . length ; i ++ ) { if (  Double . is Na N ( data [ inds [ i ] ] ) ) throw new  Illegal Argument Exception ( _ STR ) ; mean += data [ inds [ i ] ] ; } mean /= inds . length ; return mean ; }
public final static int write Security Buffer And Update Pointer (  Byte Array Output Stream baos , short len , int pointer ) throws  IOException { baos . write ( write Security Buffer ( len , pointer ) ) ; return pointer + len ; }
@  Override public  Result do Comparison Test ( final  Properties properties ) throws  Exception { final long timeout =  Long . parse Long ( properties . get Property (  Test Options .  TIMEOUT ) ) ; final int nclients =  Integer . parse Int ( properties . get Property (  Test Options .  NCLIENTS ) ) ; final int ntrials =  Integer . parse Int ( properties . get Property (  Test Options .  NTRIALS ) ) ; final int key Len =  Integer . parse Int ( properties . get Property (  Test Options .  KEYLEN ) ) ; final int nops =  Integer . parse Int ( properties . get Property (  Test Options .  NOPS ) ) ; final double abort Rate =  Double . parse Double ( properties . get Property (  Test Options .  ABORT_ RATE ) ) ; final  Result result = do Concurrent Client Test ( journal , timeout , nclients , ntrials , key Len , nops , abort Rate ) ; return result ; }
private void import Text ( ) {  JFile Chooser jc = new  JFile Chooser ( ) ; jc . set Dialog Title (  Msg . get Msg (  Env . get Ctx ( ) , _ STR ) ) ; jc . set Dialog Type (  JFile Chooser .  OPEN_ DIALOG ) ; jc . set File Selection Mode (  JFile Chooser .  FILES_ ONLY ) ; if ( jc . show Open Dialog ( this ) !=  JFile Chooser .  APPROVE_ OPTION ) return ;  String Buffer sb = new  String Buffer ( ) ; try {  Input Stream Reader in = new  Input Stream Reader ( new  File Input Stream ( jc . get Selected File ( ) ) ) ; char [ ] cbuf = new char [ _ NUM ] ; int count ; while ( ( count = in . read ( cbuf ) ) > _ NUM ) sb . append ( cbuf , _ NUM , count ) ; in . close ( ) ; } catch (  Exception e ) { log . log (  Level .  WARNING , e . get Message ( ) ) ; return ; } text Area . set Text ( sb . to String ( ) ) ; update Status Bar ( ) ; }
private  List <  String > fetch Block Cos Id List ( ) throws  SOSFailure { final  String method Name = _ STR ; log . trace ( method Name + _ STR ) ; final  String  BLOCK_ COS_ URI = _ STR ;  List <  String > block Cos Id List = new  Array List <  String > ( ) ; try {  Co SList cos Elem List = _client . query Object (  BLOCK_ COS_ URI ,  Co SList . class ) ; if ( cos Elem List != null && cos Elem List . get Cos Elements ( ) != null ) { for (  Co SElement elem : cos Elem List . get Cos Elements ( ) ) { if ( elem != null ) { block Cos Id List . add ( elem . get Id ( ) ) ; } } } log . trace ( method Name + _ STR + block Cos Id List ) ; if ( cos Elem List != null && block Cos Id List != null ) { log . trace ( method Name + _ STR + block Cos Id List . size ( ) + _ STR ) ; return block Cos Id List ; } log . trace ( method Name + _ STR ) ; return new  Array List <  String > ( ) ; } catch (  No Such Algorithm Exception e ) { log . error ( method Name + _ STR , e ) ; throw new  SOSFailure ( e ) ; } catch (  Uniform Interface Exception e ) { log . error ( method Name + _ STR , e ) ; throw new  SOSFailure ( e ) ; } }
public synchronized void run Task (  Runnable task ) { if ( ! is Alive ) { throw new  Illegal State Exception ( ) ; } if ( task != null ) { task Queue . add ( task ) ; notify ( ) ; } }
public final double sample Max ( ) { synchronized ( _lock ) { long max = _max . get And Set ( _ NUM ) ; return _scale * max ; } }
public boolean save As Geo JSON (  File file ) { try {  File Writer fw = new  File Writer ( file ) ;  Buffered Writer writer = new  Buffered Writer ( fw , _ NUM ) ; boolean result = save As Geo JSON ( writer ) ; writer . close ( ) ; return result ; } catch (  IOException e ) { e . print Stack Trace ( ) ; return _ BOOL ; } }
public synchronized void insert Chunk Auth Tag ( int chunk Idx , byte [ ] chunk Auth Tag ) throws  File Encryption Exception { if ( chunk Idx < _ NUM || chunk Auth Tag == null || chunk Auth Tag . length !=  CHUNK_ AUTH_ TAG_ LENGTH ) { throw new  File Encryption Exception ( _ STR ) ; } else { if ( atag List . size ( ) <= chunk Idx ) { atag List . ensure Capacity ( chunk Idx + _ NUM ) ; pad To ( atag List , chunk Idx ) ; atag List . add ( chunk Idx ,  Arrays . copy Of ( chunk Auth Tag ,  CHUNK_ AUTH_ TAG_ LENGTH ) ) ; } else { atag List . set ( chunk Idx ,  Arrays . copy Of ( chunk Auth Tag ,  CHUNK_ AUTH_ TAG_ LENGTH ) ) ; } } }
public <  Annotation Type extends  Annotation > void register (  Field Binder <  Annotation Type > field Binder ) {  Set <  Annotated Field <  Annotation Type > > annotated Fields =  Annotated Fields . get ( field Binder . get Annotation Class ( ) , annotated Type ) ; if ( ! annotated Fields . is Empty ( ) ) { object Binders . add ( new  Annotated Field Binder < > ( field Binder , annotated Fields ) ) ; } }
public static  String file Name Clean (  String s ) { char [ ] chars = s . to Char Array ( ) ;  String Buffer sb = new  String Buffer ( ) ; for ( int i = _ NUM ; i < chars . length ; i ++ ) { char c = chars [ i ] ; if ( ( c >= _ STR && c <= _ STR ) || ( c >= _ STR && c <= _ STR ) || ( c >= _ STR && c <= _ STR ) || ( c == _ STR ) ) { sb . append ( c ) ; } else { if ( c == _ STR || c == _ STR ) { sb . append ( _ STR ) ; } else { sb . append ( _ STR + ( int ) c + _ STR ) ; } } } return sb . to String ( ) ; }
public static  Document load Document (  Input Stream stream ) throws  Exception {  Document Builder Factory factory =  Document Builder Factory . new Instance ( ) ;  Document Builder builder = factory . new Document Builder ( ) ; return builder . parse ( stream ) ; }
public void add DTEDDirectory Handler (  DTEDDirectory Handler handler ) { directories . add ( handler ) ; }
@  Override public long add File (  String file Name ,  Input Stream input Stream , long file Size ) throws  IOException ,  Name Taken Exception ,  Internal Exception { try {  String image Path = get Image File Path ( file Name ) ; logger . info ( _ STR , image Path ) ; try (  Nfc File Output Stream output Stream = nfc Client . put File ( image Path , file Size ) ) { for ( int i = _ NUM ; i < file Size ; i ++ ) { output Stream . write ( input Stream . read ( ) ) ; } } return file Size ; } finally { if ( input Stream != null ) { input Stream . close ( ) ; } } }
public  Snmp Var Bind [ ] decode Var Bind List (  Ber Decoder bdec ) throws  Ber Exception { bdec . open Sequence ( ) ;  Vector <  Snmp Var Bind > tmp = new  Vector <  Snmp Var Bind > ( ) ; while ( bdec . cannot Close Sequence ( ) ) {  Snmp Var Bind bind = new  Snmp Var Bind ( ) ; bdec . open Sequence ( ) ; bind . oid = new  Snmp Oid ( bdec . fetch Oid ( ) ) ; bind . set Snmp Value ( decode Var Bind Value ( bdec ) ) ; bdec . close Sequence ( ) ; tmp . add Element ( bind ) ; } bdec . close Sequence ( ) ;  Snmp Var Bind [ ] var Bind List = new  Snmp Var Bind [ tmp . size ( ) ] ; tmp . copy Into ( var Bind List ) ; return var Bind List ; }
public static void init Urban Sim Zone Writer ( ) { try { log . info ( _ STR ) ; parcel Writer =  IOUtils . get Buffered Writer (  Internal Constants .  MATSIM_4_ OPUS_ TEMP +  FILE_ NAME ) ; log . info ( _ STR +  Internal Constants .  MATSIM_4_ OPUS_ TEMP +  FILE_ NAME + _ STR ) ; parcel Writer . write (  Internal Constants .  PARCEL_ ID + _ STR +  Internal Constants .  ACCESSIBILITY_ BY_ FREESPEED + _ STR +  Internal Constants .  ACCESSIBILITY_ BY_ CAR + _ STR +  Internal Constants .  ACCESSIBILITY_ BY_ BIKE + _ STR +  Internal Constants .  ACCESSIBILITY_ BY_ WALK ) ; parcel Writer . new Line ( ) ; log . info ( _ STR ) ; } catch (  Exception e ) { e . print Stack Trace ( ) ; } }
public static void execute In Bulk ( @  Not Null  Document document , final boolean execute In Bulk , @  Not Null  Runnable task ) { if ( ! ( document instanceof  Document Ex ) ) { task . run ( ) ; return ; }  Document Ex document Ex = (  Document Ex ) document ; if ( execute In Bulk == document Ex . is In Bulk Update ( ) ) { task . run ( ) ; return ; } document Ex . set In Bulk Update ( execute In Bulk ) ; try { task . run ( ) ; } finally { document Ex . set In Bulk Update ( ! execute In Bulk ) ; } }
public static <  T extends  Entity >  T create (  Cursor cursor ,  Class <  T > cls ) { try {  T entity = cls . new Instance ( ) ;  Field [ ] fields = cls . get Declared Fields ( ) ; return create ( entity , cursor , cls , fields ) ; } catch (  Exception e ) { e . print Stack Trace ( ) ; return null ; } }
private void capture Different String (  String old Name ,  String new Name ,  String app Name ,  Map <  String ,  String > map ,  String default Value ) {  Reject . if Null ( app Name ) ;  Reject . if Null ( map ) ; if ( old Name == null && new Name == null ) { map . put ( app Name , default Value ) ; } else if ( new Name != null && ! new Name . equals ( old Name ) ) { map . put ( app Name , new Name ) ; } }
@  Override protected void draw XLabels (  List <  Double > x Labels ,  Double [ ] x Text Label Locations ,  Canvas canvas ,  Paint paint , int left , int top , int bottom , double x Pixels Per Unit , double min X , double max X ) { int length = x Labels . size ( ) ; if ( length > _ NUM ) { boolean show Labels = m Renderer . is Show Labels ( ) ; boolean show Grid Y = m Renderer . is Show Grid Y ( ) ; boolean show Tick Marks = m Renderer . is Show Tick Marks ( ) ;  Date Format format = get Date Format ( x Labels . get ( _ NUM ) , x Labels . get ( length - _ NUM ) ) ; for ( int i = _ NUM ; i < length ; i ++ ) { long label =  Math . round ( x Labels . get ( i ) ) ; float x Label = ( float ) ( left + x Pixels Per Unit * ( label - min X ) ) ; if ( show Labels ) { paint . set Color ( m Renderer . get XLabels Color ( ) ) ; if ( show Tick Marks ) { canvas . draw Line ( x Label , bottom , x Label , bottom + m Renderer . get Labels Text Size ( ) / _ NUM , paint ) ; } draw Text ( canvas , format . format ( new  Date ( label ) ) , x Label , bottom + m Renderer . get Labels Text Size ( ) * _ NUM / _ NUM + m Renderer . get XLabels Padding ( ) , paint , m Renderer . get XLabels Angle ( ) ) ; } if ( show Grid Y ) { paint . set Color ( m Renderer . get Grid Color ( _ NUM ) ) ; canvas . draw Line ( x Label , bottom , x Label , top , paint ) ; } } } draw XText Labels ( x Text Label Locations , canvas , paint , _ BOOL , left , top , bottom , x Pixels Per Unit , min X , max X ) ; }
public static byte [ ] decode From String (  String src ) { if ( src == null ) { return null ; } if ( src . length ( ) == _ NUM ) { return new byte [ _ NUM ] ; } byte [ ] result ; try { result = delegate . decode ( src . get Bytes (  DEFAULT_ CHARSET . display Name ( ) ) ) ; } catch (  Unsupported Encoding Exception e ) { throw new  Illegal State Exception ( e ) ; } return result ; }
public void run ( ) throws  Exception {  Task task = get Task ( ) ; int size = get Loop Count ( ) ; if ( size <= _ NUM || task == null ) { return ; } long [ ] times = new long [ size ] ; for ( int i = _ NUM ; i < size ; i ++ ) { long start =  System . current Time Millis ( ) ; task . run ( ) ; long end =  System . current Time Millis ( ) ; times [ i ] = end - start ; } print Summary ( times ) ; }
public static  Class Node [ ] make (  Class [ ] classes ) {  Class Node [ ] cns = new  Class Node [ classes . length ] ; for ( int i = _ NUM ; i < cns . length ; i ++ ) { cns [ i ] = make ( classes [ i ] ) ; } return cns ; }
private void load Mapped Binary (  File Input Stream is ) throws  IOException {  File Channel fc = is . get Channel ( ) ;  Mapped Byte Buffer bb = fc . map (  File Channel .  Map Mode .  READ_ ONLY , _ NUM , ( int ) fc . size ( ) ) ; bb . load ( ) ; load Database ( bb ) ; is . close ( ) ; }
private static void primitive2b (  Method Visitor mv ,  Class Node type ) {  Label true Label = new  Label ( ) ;  Label false Label = new  Label ( ) ; if ( type ==  Class Helper . double_ TYPE ) { mv . visit Insn (  DCONST_0 ) ; mv . visit Insn (  DCMPL ) ; } else if ( type ==  Class Helper . long_ TYPE ) { mv . visit Insn (  LCONST_0 ) ; mv . visit Insn (  LCMP ) ; } else if ( type ==  Class Helper . float_ TYPE ) { mv . visit Insn (  FCONST_0 ) ; mv . visit Insn (  FCMPL ) ; } else if ( type ==  Class Helper . int_ TYPE ) { } mv . visit Jump Insn (  IFEQ , false Label ) ; mv . visit Insn (  ICONST_1 ) ; mv . visit Jump Insn (  GOTO , true Label ) ; mv . visit Label ( false Label ) ; mv . visit Insn (  ICONST_0 ) ; mv . visit Label ( true Label ) ; }
public void remove Section ( final  Section  SECTION ) { if ( null ==  SECTION ) return ; sections . remove (  SECTION ) ;  Collections . sort ( sections , new  Section Comparator ( ) ) ; fire Update Event (  SECTION_ EVENT ) ; }
private static byte [ ] read One Block (  Input Stream is ) throws  IOException { int c = is . read ( ) ; if ( c == - _ NUM ) { return null ; } if ( c ==  Der Value . tag_ Sequence ) {  Byte Array Output Stream bout = new  Byte Array Output Stream ( _ NUM ) ; bout . write ( c ) ; read BERInternal ( is , bout , c ) ; return bout . to Byte Array ( ) ; } else { char [ ] data = new char [ _ NUM ] ; int pos = _ NUM ; int hyphen = ( c == _ STR ) ? _ NUM : _ NUM ; int last = ( c == _ STR ) ? - _ NUM : c ; while ( _ BOOL ) { int next = is . read ( ) ; if ( next == - _ NUM ) { return null ; } if ( next == _ STR ) { hyphen ++ ; } else { hyphen = _ NUM ; last = next ; } if ( hyphen == _ NUM && ( last == - _ NUM || last == _ STR || last == _ STR ) ) { break ; } } int end ;  String Builder header = new  String Builder ( _ STR ) ; while ( _ BOOL ) { int next = is . read ( ) ; if ( next == - _ NUM ) { throw new  IOException ( _ STR ) ; } if ( next == _ STR ) { end = _ STR ; break ; } if ( next == _ STR ) { next = is . read ( ) ; if ( next == - _ NUM ) { throw new  IOException ( _ STR ) ; } if ( next == _ STR ) { end = _ STR ; } else { end = _ STR ; data [ pos ++ ] = ( char ) next ; } break ; } header . append ( ( char ) next ) ; } while ( _ BOOL ) { int next = is . read ( ) ; if ( next == - _ NUM ) { throw new  IOException ( _ STR ) ; } if ( next != _ STR ) { data [ pos ++ ] = ( char ) next ; if ( pos >= data . length ) { data =  Arrays . copy Of ( data , data . length + _ NUM ) ; } } else { break ; } }  String Builder footer = new  String Builder ( _ STR ) ; while ( _ BOOL ) { int next = is . read ( ) ; if ( next == - _ NUM || next == end || next == _ STR ) { break ; } if ( next != _ STR ) footer . append ( ( char ) next ) ; } check Header Footer ( header . to String ( ) , footer . to String ( ) ) ; return  Pem . decode ( new  String ( data , _ NUM , pos ) ) ; } }
@  Override public  Session create Session (  Principal Id principal ,  Authn Method auth Method ,  String external IDPSession Id ,  String idp Ent Id ) throws  Saml Service Exception {  Validate . not Null ( principal , _ STR ) ;  Calendar calendar = new  Gregorian Calendar ( ) ; calendar . add (  Calendar .  MINUTE ,  Shared .  SESSION_ LIFETIME_ MINUTES ) ;  Date session End Time = calendar . get Time ( ) ; try {  Session current Session = new  Session ( principal , session End Time , auth Method ) ; if ( external IDPSession Id != null ) {  Validate . not Empty ( idp Ent Id , _ STR ) ; current Session . set Using Ext IDP ( _ BOOL ) ; current Session . set Ext IDPTo Used ( new  IDPConfig ( idp Ent Id ) ) ; current Session . set Ext IDPSession ID ( external IDPSession Id ) ; } add ( current Session ) ; return current Session ; } catch (  No Such Algorithm Exception e ) { throw new  Saml Service Exception ( e ) ; } }
public boolean equals (  Object o ) { if ( o == null ) { return _ BOOL ; } if ( get Class ( ) != o . get Class ( ) ) { return _ BOOL ; } final  Coverage Int Vdt civ = (  Coverage Int Vdt ) o ; return ( ( table == civ . table ) && ( attribute == civ . attribute ) && ( value == civ . value ) ) ; }
private void process2 ( final  File file ) throws  Interrupted Exception { if ( file . is Hidden ( ) ) { return ; } if ( file . is Directory ( ) ) { if ( log . is Info Enabled ( ) ) log . info ( _ STR + file ) ; final  File [ ] files = filter == null ? file . list Files ( ) : file . list Files ( filter ) ; for ( final  File f : files ) { process2 ( f ) ; } } else { accept ( file ) ; } }
public void test One One ( ) { byte a Bytes [ ] = { _ NUM } ; byte b Bytes [ ] = { _ NUM } ; int a Sign = _ NUM ; int b Sign = _ NUM ; byte r Bytes [ ] = { _ NUM } ;  Big Integer a Number = new  Big Integer ( a Sign , a Bytes ) ;  Big Integer b Number = new  Big Integer ( b Sign , b Bytes ) ;  Big Integer result = a Number . or ( b Number ) ; byte res Bytes [ ] = new byte [ r Bytes . length ] ; res Bytes = result . to Byte Array ( ) ; for ( int i = _ NUM ; i < res Bytes . length ; i ++ ) { assert True ( res Bytes [ i ] == r Bytes [ i ] ) ; } assert Equals ( _ STR , _ NUM , result . signum ( ) ) ; }
@  Requires Permission (  PERMISSION ) @  Override public boolean request Send ( ) {  Activity activity = m Activity . get ( ) ; if ( activity == null ) return _ BOOL ; if (  Log . is Loggable (  Log .  VERBOSE ) )  Log . v ( _ STR ) ; if ( check Self Permission ( activity ,  PERMISSION ) !=  Package Manager .  PERMISSION_ GRANTED ) { request Permissions ( activity , new  String [ ] {  PERMISSION } ,  PERMISSION_ REQUEST_ CODE ) ; return _ BOOL ; } return get Fresh Location ( new  Sender Location Listener ( this ) ) ; }
@  Override public synchronized void stop ( ) {  LOGGER . info ( _ STR ) ; timer . cancel ( ) ; running = _ BOOL ; }
protected static  URL append Url Path (  URL url ,  String append ) throws  Malformed URLException { return new  URL ( url . get Protocol ( ) + _ STR + url . get Authority ( ) + url . get Path ( ) + append + ( url . get Query ( ) != null ? _ STR + url . get Query ( ) : _ STR ) ) ; }
public static  Mosaic Definition create Mosaic Definition ( final  Account creator , final  Mosaic Levy levy ) { return create Mosaic Definition ( creator ,  Utils . create Mosaic Id ( _ STR , _ STR ) , create Mosaic Properties ( ) , levy ) ; }
public void init ( ) { int  One Day Minutes = _ NUM * _ NUM ; _scheduler . schedule At Fixed Rate ( new  Password Expire Mail Notifier ( ) , get First Delay In Min ( ) ,  One Day Minutes ,  Time Unit .  MINUTES ) ; }
public static _ Fields find By Thrift Id ( int field Id ) { switch ( field Id ) { case _ NUM : return  PATH ; case _ NUM : return  BLOCK_ SIZE_ BYTES ; case _ NUM : return  TOTAL_ LBA_ BLOCKS ; case _ NUM : return  TOTAL_ SPACE ; default : return null ; } }
public void test Multiple Creators ( ) throws  Exception {  Multi Bean bean =  MAPPER . read Value ( _ STR ,  Multi Bean . class ) ; assert Equals (  Integer . value Of ( _ NUM ) , bean . value ) ; bean =  MAPPER . read Value ( quote ( _ STR ) ,  Multi Bean . class ) ; assert Equals ( _ STR , bean . value ) ; bean =  MAPPER . read Value ( _ STR ,  Multi Bean . class ) ; assert Equals (  Double . value Of ( _ NUM ) , bean . value ) ; }
public final void build Signed Directory ( ) throws  Exception { try (  Byte Array Output Stream mime Content = new  Byte Array Output Stream ( ) ) { build ( mime Content ) ; log . debug ( _ STR , mime Content . to String ( ) ) ; byte [ ] content Bytes = mime Content . to Byte Array ( ) ; mime Content . reset ( ) ; sign ( content Bytes , mime Content ) ;  Files . write ( temp Conf Path , mime Content . to Byte Array ( ) ) ; log . debug ( _ STR , temp Conf Path ) ; } }
public final int index Of ( java . lang .  Char Sequence csq , int from Index ) { if ( ( _offset + from Index + csq . length ( ) - _ NUM ) >= ( _offset + _length ) ) throw new  Index Out Of Bounds Exception (  String . format ( _ STR , from Index ) ) ; final char c = csq . char At ( _ NUM ) ; final int csq Length = csq . length ( ) ; for ( int i = _offset + from Index , end = _offset + _length - csq Length + _ NUM ; i < end ; i ++ ) { if ( _array [ i ] == c ) { boolean match = _ BOOL ; for ( int j = _ NUM ; j < csq Length ; j ++ ) { if ( _array [ i + j ] != csq . char At ( j ) ) { match = _ BOOL ; break ; } } if ( match ) { return i - _offset ; } } } return - _ NUM ; }
public static  Object deserialize Object ( final byte [ ] obj Bytes ) throws  IOException ,  Class Not Found Exception {  Object Input Stream obj In = null ; try { obj In = new  Object Input Stream ( new  Byte Array Input Stream ( obj Bytes ) ) ; return obj In . read Object ( ) ; } finally { close ( obj In ) ; } }
public  String to String ( ) {  String s = super . to String ( ) + _ STR ; if ( id != null ) { s += id . to String ( ) ; } if ( names != null ) { s += names . to String ( ) + _ STR ; } if ( serial Num != null ) { s += serial Num . to String ( ) + _ STR ; } return ( s + _ STR ) ; }
public static  String dictionary To String (  Dictionary <  Object ,  Object > dict ) {  Enumeration <  Object > keys = dict . keys ( ) ;  Object key , value ;  String Buffer result = new  String Buffer ( ) ; while ( keys . has More Elements ( ) ) { key = keys . next Element ( ) ; value = dict . get ( key ) ; result . append ( key . to String ( ) ) ; result . append ( _ STR ) ; result . append ( value . to String ( ) ) ; result . append ( _ STR ) ; } return result . to String ( ) ; }
public  List <  Shopping Cart Item > items ( ) {  List <  Shopping Cart Item > result =  Fast List . new Instance ( ) ; result . add All ( cart Lines ) ; return result ; }
private void save (  File file ,  String extension ) throws  IOException { java . awt .  Color paper = fx To AWTColor ( background ) ; java . awt .  Color ink = fx To AWTColor ( foreground ) ;  Buffered Image image = new  Buffered Image ( ( barcode . get Width ( ) * zoom ) + ( _ NUM * border ) , ( barcode . get Height ( ) * zoom ) + ( _ NUM * border ) ,  Buffered Image .  TYPE_ INT_ RGB ) ;  Graphics2 D g2d = image . create Graphics ( ) ; g2d . set Rendering Hint (  Rendering Hints .  KEY_ ANTIALIASING ,  Rendering Hints .  VALUE_ ANTIALIAS_ ON ) ; g2d . set Color ( paper ) ; g2d . fill Rect ( _ NUM , _ NUM , ( barcode . get Width ( ) * zoom ) + ( _ NUM * border ) , ( barcode . get Height ( ) * zoom ) + ( _ NUM * border ) ) ;  Java2 DRenderer renderer = new  Java2 DRenderer ( g2d , zoom , border , paper , ink ) ; renderer . render ( barcode ) ;  Image IO . write ( image , extension , file ) ; }
@  Override public void put (  Mean other ) { if ( other instanceof  Statistical Moments ) {  Statistical Moments othe = (  Statistical Moments ) other ; final double nn = othe . n + this . n ; final double delta = othe . m1 - this . m1 ; final double delta_nn = delta / nn ; final double delta_nn2 = delta_nn * delta_nn ; final double delta_nn3 = delta_nn2 * delta_nn ; final double na2 = this . n * this . n ; final double nb2 = othe . n * othe . n ; final double ntn = this . n * othe . n ; this . m4 += othe . m4 + delta * delta_nn3 * ntn * ( na2 - ntn + nb2 ) + _ NUM * ( na2 * othe . m2 + nb2 * this . m2 ) * delta_nn2 + _ NUM * ( this . n * othe . m3 - othe . n * this . m3 ) * delta_nn ; this . m3 += othe . m3 + delta * delta_nn2 * ntn * ( this . n - othe . n ) + _ NUM * ( this . n * othe . m2 - othe . n * this . m2 ) * delta_nn ; this . m2 += othe . m2 + delta * delta_nn * this . n * othe . n ; this . m1 += othe . n * delta_nn ; this . n = nn ; min =  Math . min ( min , othe . min ) ; max =  Math . max ( max , othe . max ) ; } else { throw new  Abort Exception ( _ STR ) ; } }
private void check Contains (  Spanned text ,  String [ ] spans ,  String span Name , int start , int end ) throws  Exception { for (  String i : spans ) { if ( i . equals ( span Name ) ) { assert Equals ( start , text . get Span Start ( i ) ) ; assert Equals ( end , text . get Span End ( i ) ) ; return ; } } fail ( ) ; }
public static void save Bitmap To File (  Bitmap bmp ,  String full Path With File Name ) throws  IOException {  File Output Stream out = null ; try { out = new  File Output Stream ( create Parent Dir If Not Exists ( full Path With File Name ) ) ; bmp . compress (  Bitmap .  Compress Format .  PNG , _ NUM , out ) ; } finally { try { if ( out != null ) { out . close ( ) ; } } catch (  IOException e ) { e . print Stack Trace ( ) ; } } }
private void validate Cloumns (  Map <  String ,  Object > column Name To Type Map ) { if ( column Name To Type Map == null ) { throw new  Illegal Argument Exception ( _ STR ) ; } for (  Map .  Entry <  String ,  Object > entry : column Name To Type Map . entry Set ( ) ) {  Object obj Value = entry . get Value ( ) ; if ( obj Value == null ) { throw new  Illegal Argument Exception ( _ STR + entry . get Key ( ) + _ STR ) ; } if ( obj Value instanceof  Class < ? > ) { continue ; } if ( obj Value instanceof  String ) { try { entry . set Value (  Class . for Name ( (  String ) obj Value ) ) ; } catch (  Class Not Found Exception e ) { throw new  Illegal Argument Exception ( _ STR , e ) ; } } } }
protected void close Dialog Ok ( ) { dispose ( ) ; }
public  String ( byte [ ] bytes , java . lang .  String enc ) throws java . io .  Unsupported Encoding Exception { this ( bytes To Chars ( bytes , _ NUM , bytes . length , enc ) ) ; }
public  List <  Message > remove With Selector (  String selector ) throws  Mail Queue Exception {  Connection connection = null ;  Session session = null ;  Message message = null ;  Message Consumer consumer = null ; boolean first = _ BOOL ;  List <  Message > messages = new  Array List <  Message > ( ) ; try { connection = connection Factory . create Connection ( ) ; connection . start ( ) ; session = connection . create Session ( _ BOOL ,  Session .  SESSION_ TRANSACTED ) ;  Queue queue = session . create Queue ( queue Name ) ; consumer = session . create Consumer ( queue , selector ) ; while ( first || message != null ) { if ( first ) { message = consumer . receive ( _ NUM ) ; } else { message = consumer . receive No Wait ( ) ; } first = _ BOOL ; if ( message != null ) { messages . add ( message ) ; } } session . commit ( ) ; return messages ; } catch (  Exception e ) { try { session . rollback ( ) ; } catch (  JMSException e1 ) { } throw new  Mail Queue Exception ( _ STR , e ) ; } finally { if ( consumer != null ) { try { consumer . close ( ) ; } catch (  JMSException e1 ) { } } try { if ( session != null ) session . close ( ) ; } catch (  JMSException e1 ) { } try { if ( connection != null ) connection . close ( ) ; } catch (  JMSException e1 ) { } } }
public  String decode (  Abstract Message msg ,  Boolean ext , int header ) {  String str =  Cbus Op Codes . decode ( msg , ext , header ) ; return ( str ) ; }
private boolean classify Example (  Instance example ) throws  Exception { double class Value = - _ NUM ; for (  Enumeration <  Rule List > e = new  Weka Enumeration <  Rule List > ( m_ Decision List ) ; e . has More Elements ( ) && class Value < _ NUM ; ) {  Rule List rl = e . next Element ( ) ; class Value = rl . classify Instance ( example ) ; } if ( class Value >= _ NUM ) { example . set Class Value ( class Value ) ; return _ BOOL ; } else { return _ BOOL ; } }
@  Override public int hash Code ( ) { return  System . identity Hash Code ( this ) ; }
private  Ascii Funcs ( ) { }
@  Override public boolean check AESKey (  Key Parameter aes Key ) { lock . lock ( ) ; try { if ( hash To Keys . is Empty ( ) ) return _ BOOL ; check State ( key Crypter != null , _ STR ) ;  ECKey first = null ; for (  ECKey key : hash To Keys . values ( ) ) { if ( key . is Encrypted ( ) ) { first = key ; break ; } } check State ( first != null , _ STR ) ; try {  ECKey reborn Key = first . decrypt ( aes Key ) ; return  Arrays . equals ( first . get Pub Key ( ) , reborn Key . get Pub Key ( ) ) ; } catch (  Key Crypter Exception e ) { return _ BOOL ; } } finally { lock . unlock ( ) ; } }
public static  Script create Multi Sig Input Script Bytes (  List < byte [ ] > signatures , @  Nullable byte [ ] multisig Program Bytes ) { check Argument ( signatures . size ( ) <= _ NUM ) ;  Script Builder builder = new  Script Builder ( ) ; builder . small Num ( _ NUM ) ; for ( byte [ ] signature : signatures ) builder . data ( signature ) ; if ( multisig Program Bytes != null ) builder . data ( multisig Program Bytes ) ; return builder . build ( ) ; }
public static void write Tag Dict ( final  Map <  String ,  Collection <  Category > > tag Dict , final  File file ) throws  File Not Found Exception ,  Unsupported Encoding Exception { final  Print Writer writer = new  Print Writer ( file , _ STR ) ; for ( final java . util .  Map .  Entry <  String ,  Collection <  Category > > entry : tag Dict . entry Set ( ) ) { writer . print ( entry . get Key ( ) ) ; for ( final  Category c : entry . get Value ( ) ) { writer . print ( _ STR + c . to String ( ) ) ; } writer . println ( ) ; } writer . close ( ) ; }
@  Gen Ignore static  Record create Record (  String name ,  String address ,  Class type ,  Json Object metadata ) { return create Record ( name , address , type != null ? type . get Name ( ) : null , metadata ) ; }
public  Thread Deadlock Detector ( ) { this (  Management Factory . get Thread MXBean ( ) ) ; }
public synchronized void insert Audio (  String inputtype ,  String locale ,  String voice ,  String outputparams ,  String style ,  String effects ,  String inputtext , byte [ ] audio ) throws  SQLException { if ( inputtype == null || locale == null || voice == null || inputtext == null ) { throw new  Null Pointer Exception ( _ STR ) ; } if ( lookup Audio ( inputtype , locale , voice , outputparams , style , effects , inputtext ) != null ) { return ; }  String query = _ STR + inputtype + _ STR + locale + _ STR + voice + _ STR + outputparams + _ STR + style + _ STR + effects + _ STR ;  Prepared Statement st = connection . prepare Statement ( query ) ; st . set String ( _ NUM , inputtext ) ; st . set Bytes ( _ NUM , audio ) ; st . execute Update ( ) ; st . close ( ) ; }
public void add Qualifier And Condition (  String qualifier ,  Condition condition ) {  List <  Condition > conditions = qualifiers And Conditions . get ( qualifier ) ; if ( conditions == null ) { conditions = new  Array List <  Condition > ( ) ; qualifiers And Conditions . put ( qualifier , conditions ) ; } conditions . add ( condition ) ; }
public boolean seek (  Byte Buffer byte Buffer ) { byte [ ] buffer = new byte [  FIELD_ TAGID_ LENGTH ] ; byte Buffer . get ( buffer , _ NUM ,  FIELD_ TAGID_ LENGTH ) ; if ( ! (  Arrays . equals ( buffer ,  TAG_ ID ) ) ) { return _ BOOL ; } byte Buffer . position (  FIELD_ TRACK_ INDICATOR_ POS ) ; if ( byte Buffer . get ( ) !=  END_ OF_ FIELD ) { return _ BOOL ; } return byte Buffer . get ( ) !=  END_ OF_ FIELD ; }
public void find Package And Class ( ) throws  IOException { package Name = null ; class Name = null ;  Line Number Reader reader = new  Line Number Reader ( new  File Reader ( input File ) ) ; while ( class Name == null || package Name == null ) {  String line = reader . read Line ( ) ; if ( line == null ) break ; if ( package Name == null ) { int index = line . index Of ( _ STR ) ; if ( index >= _ NUM ) { index += _ NUM ; int end = line . index Of ( _ STR , index ) ; if ( end >= index ) { package Name = line . substring ( index , end ) ; package Name = package Name . trim ( ) ; } } } if ( class Name == null ) { int index = line . index Of ( _ STR ) ; if ( index >= _ NUM ) { index += _ NUM ; class Name = line . substring ( index ) ; class Name = class Name . trim ( ) ; } } } if ( class Name == null ) class Name = _ STR ; }
public static  Set <  URI > fetch SRDFTarget Virtual Pools (  Db Client db Client ) {  Set <  URI > srdf Protected Target VPools = new  Hash Set <  URI > ( ) ; try {  List <  URI > vpool Remote Setting URIs = db Client . query By Type (  Vpool Remote Copy Protection Settings . class , _ BOOL ) ;  Iterator <  Vpool Remote Copy Protection Settings > v Pool Remote Settings Itr = db Client . query Iterative Objects (  Vpool Remote Copy Protection Settings . class , vpool Remote Setting URIs , _ BOOL ) ; while ( v Pool Remote Settings Itr . has Next ( ) ) {  Vpool Remote Copy Protection Settings r Setting = v Pool Remote Settings Itr . next ( ) ; if ( null != r Setting && !  Null Column Value Getter . is Null URI ( r Setting . get Virtual Pool ( ) ) ) { srdf Protected Target VPools . add ( r Setting . get Virtual Pool ( ) ) ; } } } catch (  Exception ex ) { log . error ( _ STR , ex ) ; } return srdf Protected Target VPools ; }
public static int cardinality ( long [ ] v ) { int sum = _ NUM ; for ( int i = _ NUM ; i < v . length ; i ++ ) { sum +=  Long . bit Count ( v [ i ] ) ; } return sum ; }
public static  String literal To String ( long lit ,  Arg Type type ) { if ( type == null || ! type . is Type Known ( ) ) {  String n =  Long . to String ( lit ) ; if (  Math . abs ( lit ) > _ NUM ) { n += _ STR +  Long . to Hex String ( lit ) + _ STR +  Float . int Bits To Float ( ( int ) lit ) + _ STR +  Double . long Bits To Double ( lit ) ; } return n ; } switch ( type . get Primitive Type ( ) ) { case  BOOLEAN : return lit == _ NUM ? _ STR : _ STR ; case  CHAR : return  String Utils . unescape Char ( ( char ) lit ) ; case  BYTE : return format Byte ( ( byte ) lit ) ; case  SHORT : return format Short ( ( short ) lit ) ; case  INT : return format Integer ( ( int ) lit ) ; case  LONG : return format Long ( lit ) ; case  FLOAT : return format Float (  Float . int Bits To Float ( ( int ) lit ) ) ; case  DOUBLE : return format Double (  Double . long Bits To Double ( lit ) ) ; case  OBJECT : case  ARRAY : if ( lit != _ NUM ) {  LOG . warn ( _ STR , lit , type ) ; return  Long . to String ( lit ) ; } return _ STR ; default : throw new  Jadx Runtime Exception ( _ STR + type ) ; } }
public static void w (  String msg ,  Object ... args ) { if ( ! allow W ) return ;  Stack Trace Element caller = get Caller Stack Trace Element ( ) ;  String tag = generate Tag ( caller ) ; if ( s Level >  LEVEL_ WARNING ) { return ; } if ( args . length > _ NUM ) { msg =  String . format ( msg , args ) ; }  Log . w ( tag , msg ) ; }
public  DOpen Pkcs11 Key Store (  JFrame parent ) { super ( parent ,  Dialog .  Modality Type .  DOCUMENT_ MODAL ) ; set Title ( res . get String ( _ STR ) ) ; init Components ( ) ; }
private int insert Test Data Offset DTTypes (  Prepared Statement pstmt ) throws  Exception { pstmt . set Int ( _ NUM , _ NUM ) ; pstmt . set Object ( _ NUM , test Offset Time ,  JDBCType .  VARCHAR ) ; pstmt . set Object ( _ NUM , test Offset Time ) ; pstmt . set Object ( _ NUM , test Offset Date Time ,  JDBCType .  VARCHAR ) ; pstmt . set Object ( _ NUM , test Offset Date Time ) ; assert Equals ( _ NUM , pstmt . execute Update ( ) ) ; if ( pstmt instanceof  Callable Statement ) {  Callable Statement cstmt = (  Callable Statement ) pstmt ; cstmt . set Int ( _ STR , _ NUM ) ; cstmt . set Object ( _ STR , test Offset Time ,  JDBCType .  VARCHAR ) ; cstmt . set Object ( _ STR , test Offset Time ) ; cstmt . set Object ( _ STR , test Offset Date Time ,  JDBCType .  VARCHAR ) ; cstmt . set Object ( _ STR , test Offset Date Time ) ; assert Equals ( _ NUM , cstmt . execute Update ( ) ) ; return _ NUM ; } return _ NUM ; }
public void add Listener ( final  L listener ) {  Validate . not Null ( listener , _ STR ) ; listeners . add ( listener ) ; }
private void keep Alive ( ) {  Thread current =  Thread . current Thread ( ) ; try { heart Beat ( ) ; while ( current == keep Alive Thread ) {  Thread . sleep (  HEART_ BEAT ) ; heart Beat ( ) ; } } catch (  Interrupted Exception e ) { log . warn ( _ STR , e ) ; } }
private synchronized void read Object ( java . io .  Object Input Stream s ) throws  IOException ,  Class Not Found Exception { s . default Read Object ( ) ; init ( get Name ( ) , get Mask ( actions ) ) ; }
public  Multiple Composite Space Predicate (  List <  ISpace Predicate > operands ) { if ( operands == null ) throw new  Illegal Argument Exception ( _ STR ) ; for ( int i = _ NUM ; i < operands . size ( ) ; i ++ ) if ( operands . get ( i ) == null ) throw new  Illegal Argument Exception ( _ STR + i + _ STR ) ; this . _operands List = operands ; }
public static void play Sound Buffer ( byte [ ] wav Data ) { jmri . jmrit . sound .  Wav Buffer wb = new jmri . jmrit . sound .  Wav Buffer ( wav Data ) ; float sample Rate = wb . get Sample Rate ( ) ; int sample Size In Bits = wb . get Sample Size In Bits ( ) ; int channels = wb . get Channels ( ) ; boolean signed = wb . get Signed ( ) ; boolean big Endian = wb . get Big Endian ( ) ;  Audio Format format = new  Audio Format ( sample Rate , sample Size In Bits , channels , signed , big Endian ) ;  Source Data Line line ;  Data Line .  Info info = new  Data Line .  Info (  Source Data Line . class , format ) ; if ( !  Audio System . is Line Supported ( info ) ) { log . warn ( _ STR + info ) ; return ; } try { line = (  Source Data Line )  Audio System . get Line ( info ) ; line . open ( format ) ; } catch (  Line Unavailable Exception ex ) { log . error ( _ STR + ex ) ; return ; } line . start ( ) ; line . write ( wav Data , _ NUM , wav Data . length ) ; }
public static byte [ ] decode (  String s ) { return decode ( s ,  NO_ OPTIONS ) ; }
public static boolean time Stamp Changed (  String location ) { synchronized ( install Lock ) { if ( fg Has Changed . contains ( location ) ) { return _ BOOL ; }  File file = new  File ( location ) ; if ( file . exists ( ) ) { if ( fg Install Time Map == null ) { read Install Info ( ) ; }  Long stamp = fg Install Time Map . get ( location ) ; long fstamp = file . last Modified ( ) ; if ( stamp != null ) { if ( stamp . long Value ( ) == fstamp ) { return _ BOOL ; } } stamp = new  Long ( fstamp ) ; fg Install Time Map . put ( location , stamp ) ; write Install Info ( ) ; fg Has Changed . add ( location ) ; return _ BOOL ; } } return _ BOOL ; }
public  Sample Set (  String Tokenizer tok ,  Buffered Reader reader ) { try { int num Samples =  Integer . parse Int ( tok . next Token ( ) ) ; int num Channels =  Integer . parse Int ( tok . next Token ( ) ) ; int sample Rate =  Integer . parse Int ( tok . next Token ( ) ) ; float coeff Min =  Float . parse Float ( tok . next Token ( ) ) ; float coeff Range =  Float . parse Float ( tok . next Token ( ) ) ; float post Emphasis =  Float . parse Float ( tok . next Token ( ) ) ; int residual Fold =  Integer . parse Int ( tok . next Token ( ) ) ; samples = new  Sample [ num Samples ] ; sample Info = new  Sample Info ( sample Rate , num Channels , residual Fold , coeff Min , coeff Range , post Emphasis ) ; for ( int i = _ NUM ; i < num Samples ; i ++ ) { samples [ i ] = new  Sample ( reader , num Channels ) ; } } catch (  No Such Element Exception nse ) { throw new  Error ( _ STR + nse . get Message ( ) ) ; } }
@  Override public  Env Var add New Env Var (  String name ,  Class < ? > type ,  String value ) {  Env Var env Var = null ; if ( ! exist ( name ) ) { env Var = new  Env Var ( name , type , _ BOOL ) ; env Var . set Value ( value ) ; env Var List . add ( env Var ) ; } return env Var ; }
public void make Class (  String str , boolean caseless ) { for ( int i = _ NUM ; i < str . length ( ) ; ) { int ch = str . code Point At ( i ) ; make Class ( ch , caseless ) ; i +=  Character . char Count ( ch ) ; } }
public boolean create Locally ( final  Bucket Region bucket Region , final  Entry Event Impl event , boolean if New , boolean if Old , boolean require Old Value , final long last Modified ) throws  Force Reattempt Exception { boolean result = _ BOOL ; try { event . set Region ( bucket Region ) ; if ( event . is Origin Remote ( ) ) { result = bucket Region . basic Update ( event , if New , if Old , last Modified , _ BOOL ) ; } else { result = bucket Region . virtual Put ( event , if New , if Old , null , require Old Value , last Modified , _ BOOL ) ; } bucket Region . check Readiness ( ) ; } catch (  Region Destroyed Exception rde ) { check Region Destroyed On Bucket ( bucket Region , event . is Origin Remote ( ) , rde ) ; } return result ; }
private static int do Regex Search ( final  Object element , final  String line Text , final int line Counter , final  String local Search String , final int start Position , final boolean case Sensitive , final  List <  Search Result > results ) { final  Pattern pattern = case Sensitive ?  Pattern . compile ( local Search String ) :  Pattern . compile ( local Search String ,  Pattern .  CASE_ INSENSITIVE ) ; final  Matcher matcher = pattern . matcher ( line Text ) ; final boolean found = matcher . find ( start Position ) ; if ( found ) { final int start = matcher . start ( ) ; final int end = matcher . end ( ) ; if ( start != end ) { results . add ( new  Search Result ( element , line Counter , start , end - start ) ) ; } if ( matcher . end ( ) == line Text . length ( ) ) { return - _ NUM ; } if ( start == end ) { return end + _ NUM ; } return end ; } else { return - _ NUM ; } }
protected static byte [ ] input Stream To Byte Array (  Input Stream str ) throws  IOException { try (  Byte Array Output Stream baos = new  Byte Array Output Stream ( ) ) { int len = _ NUM ; byte [ ] buf = new byte [ _ NUM ] ; while ( ( len = str . read ( buf ) ) != - _ NUM ) { baos . write ( buf , _ NUM , len ) ; } return baos . to Byte Array ( ) ; } }
public  Builder add Content Item (  Content Item content Item ) { if ( content Items == null ) { content Items = new  Array List <  Content Item > ( ) ; content Type =  Http Media Type .  APPLICATION_ JSON ; } content Items . add ( content Item ) ; return this ; }
public void put Object (  String key ,  Object value ) throws  IOException ,  Stream Corrupted Exception ,  Optional Data Exception {  Byte Array Output Stream b = new  Byte Array Output Stream ( ) ;  Object Output Stream o = new  Object Output Stream ( b ) ; o . write Object ( value ) ; o . close ( ) ; put ( key , new  String (  Base64 . encode ( b . to Byte Array ( ) ,  Base64 .  DEFAULT ) ) ) ; }
public double min ( ) { if ( is Sparse ( ) && nnz ( ) < length ( ) ) { double min = _ NUM ; for (  Index Value iv : this ) min =  Math . min ( min , iv . get Value ( ) ) ; return min ; } else { double min = get ( _ NUM ) ; for ( int i = _ NUM ; i < length ( ) ; i ++ ) min =  Math . min ( min , get ( i ) ) ; return min ; } }
public static void write UINT16 ( int number ,  Output Stream out ) throws  IOException { if ( number < _ NUM ) { throw new  Illegal Argument Exception ( _ STR ) ; } byte [ ] to Write = new byte [ _ NUM ] ; for ( int i = _ NUM ; i <= _ NUM ; i += _ NUM ) { to Write [ i / _ NUM ] = ( byte ) ( ( number > > i ) & _ NUM ) ; } out . write ( to Write ) ; }
public void test_validate ( ) { }
private void build First Line (  Line Path path ,  Rect r ) { int [ ] range = new int [ ] { - r . left , - r . top , r . right , r . bottom } ; int max = - _ NUM ; int max Id = _ NUM ; for ( int i = _ NUM ; i < _ NUM ; i ++ ) { if ( range [ i ] > max ) { max = range [ i ] ; max Id = i ; } } switch ( max Id ) { case _ NUM : path . set End Point ( r . left ,  Utils . next Int ( r . height ( ) ) + r . top ) ; break ; case _ NUM : path . set End Point (  Utils . next Int ( r . width ( ) ) + r . left , r . top ) ; break ; case _ NUM : path . set End Point ( r . right ,  Utils . next Int ( r . height ( ) ) + r . top ) ; break ; case _ NUM : path . set End Point (  Utils . next Int ( r . width ( ) ) + r . left , r . bottom ) ; break ; } path . line To End ( ) ; }
private static  Char Handler parse International Codes (  String [ ] code Strings ) { if ( code Strings . length != _ NUM ) { throw new  Illegal State Exception ( _ STR +  Arrays . as List ( code Strings ) ) ; } return new  International Char Handler ( codes To Bytes ( code Strings [ _ NUM ] , _ BOOL ) , codes To Bytes ( code Strings [ _ NUM ] , _ BOOL ) ) ; }
private  String [ ] parse Line (  String next Line , boolean multi ) throws  IOException { if ( ! multi && pending != null ) { pending = null ; } if ( next Line == null ) { if ( pending != null ) {  String s = pending ; pending = null ; return new  String [ ] { s } ; } else { return null ; } }  List <  String > tokens On This Line = new  Array List < > (  Carbon Common Constants .  DEFAULT_ COLLECTION_ SIZE ) ;  String Builder sb = new  String Builder (  INITIAL_ READ_ SIZE ) ; boolean in Quotes = _ BOOL ; if ( pending != null ) { sb . append ( pending ) ; pending = null ; in Quotes = ! this . ignore Quotations ; } in Quotes = check For Quotes ( next Line , tokens On This Line , sb , in Quotes ) ; if ( ( in Quotes && ! ignore Quotations ) ) { if ( multi ) { sb . append ( _ STR ) ; char Count Inside Quote = sb . length ( ) - ( sb . index Of ( _ STR ) + _ NUM ) ; if ( char Count Inside Quote >= _ NUM ) { throw new  IOException ( _ STR ) ; } pending = sb . to String ( ) ; sb = null ; } else { throw new  IOException ( _ STR ) ; } } else { in Field = _ BOOL ; char Count Inside Quote = _ NUM ; } if ( sb != null ) { tokens On This Line . add ( sb . to String ( ) ) ; } return tokens On This Line . to Array ( new  String [ tokens On This Line . size ( ) ] ) ; }
@  Suppress Warnings ( _ STR ) public static float percentage To Value ( float percentage , float start Value , float end Value ) { float min =  Math . min ( start Value , end Value ) ; float max =  Math . max ( start Value , end Value ) ; float delta = max - min ; return ( delta * ( percentage / _ NUM ) ) + min ; }
public static boolean is Network Connected (  Context context ) { if ( context == null ) { return _ BOOL ; }  Connectivity Manager cm = (  Connectivity Manager ) context . get System Service (  Context .  CONNECTIVITY_ SERVICE ) ;  Network Info network Info = cm . get Active Network Info ( ) ; return ( network Info != null && network Info . is Connected ( ) ) ; }
public void update Item ( int position ,  Object o ) { if ( ! is Data List Empty ( ) && position >= _ NUM && position < m Data List . size ( ) ) { m Data List . set ( position , o ) ; notify Item Changed ( position ) ; } }
private int extract ( final int index , final byte a [ ] , final int offset , final int length ) { final  Backing Buffer bb = this . bb ; final int delta = index % ratio ; final int start Pos = p [ index / ratio ] ; int pos , prev Array Pos , curr Len = _ NUM , actual Common ; int array Length = bb . read Int ( pos = start Pos ) ; if ( delta == _ NUM ) { pos = p [ index / ratio ] + count ( array Length ) ; bb . arraycopy ( pos , a , offset ,  Math . min ( length , array Length ) ) ; return array Length ; } int common = _ NUM ; for ( int i = _ NUM ; i < delta ; i ++ ) { prev Array Pos = pos + count ( array Length ) + ( i != _ NUM ? count ( common ) : _ NUM ) ; pos = prev Array Pos + array Length ; array Length = bb . read Int ( pos ) ; common = bb . read Int ( pos + count ( array Length ) ) ; actual Common =  Math . min ( common , length ) ; if ( actual Common <= curr Len ) curr Len = actual Common ; else { bb . arraycopy ( prev Array Pos , a , curr Len + offset , actual Common - curr Len ) ; curr Len = actual Common ; } } if ( curr Len < length ) bb . arraycopy ( pos + count ( array Length ) + count ( common ) , a , curr Len + offset ,  Math . min ( array Length , length - curr Len ) ) ; return array Length + common ; }
private void apply Image Matrix ( float width , float height , boolean center , boolean animate ) { if ( m Bitmap != null && width > _ NUM && height > _ NUM ) { m Image Matrix . invert ( m Image Inverse Matrix ) ;  Rect F crop Rect = m Crop Overlay View . get Crop Window Rect ( ) ; m Image Inverse Matrix . map Rect ( crop Rect ) ; m Image Matrix . reset ( ) ; m Image Matrix . post Translate ( ( width - m Bitmap . get Width ( ) ) / _ NUM , ( height - m Bitmap . get Height ( ) ) / _ NUM ) ; map Image Points By Image Matrix ( ) ; if ( m Degrees Rotated > _ NUM ) { m Image Matrix . post Rotate ( m Degrees Rotated ,  Bitmap Utils . get Rect Center X ( m Image Points ) ,  Bitmap Utils . get Rect Center Y ( m Image Points ) ) ; map Image Points By Image Matrix ( ) ; } float scale =  Math . min ( width /  Bitmap Utils . get Rect Width ( m Image Points ) , height /  Bitmap Utils . get Rect Height ( m Image Points ) ) ; if ( m Scale Type ==  Scale Type .  FIT_ CENTER || ( m Scale Type ==  Scale Type .  CENTER_ INSIDE && scale < _ NUM ) || ( scale > _ NUM && m Auto Zoom Enabled ) ) { m Image Matrix . post Scale ( scale , scale ,  Bitmap Utils . get Rect Center X ( m Image Points ) ,  Bitmap Utils . get Rect Center Y ( m Image Points ) ) ; map Image Points By Image Matrix ( ) ; } m Image Matrix . post Scale ( m Zoom , m Zoom ,  Bitmap Utils . get Rect Center X ( m Image Points ) ,  Bitmap Utils . get Rect Center Y ( m Image Points ) ) ; map Image Points By Image Matrix ( ) ; m Image Matrix . map Rect ( crop Rect ) ; if ( center ) { m Zoom Offset X = width >  Bitmap Utils . get Rect Width ( m Image Points ) ? _ NUM :  Math . max (  Math . min ( width / _ NUM - crop Rect . center X ( ) , -  Bitmap Utils . get Rect Left ( m Image Points ) ) , get Width ( ) -  Bitmap Utils . get Rect Right ( m Image Points ) ) / m Zoom ; m Zoom Offset Y = height >  Bitmap Utils . get Rect Height ( m Image Points ) ? _ NUM :  Math . max (  Math . min ( height / _ NUM - crop Rect . center Y ( ) , -  Bitmap Utils . get Rect Top ( m Image Points ) ) , get Height ( ) -  Bitmap Utils . get Rect Bottom ( m Image Points ) ) / m Zoom ; } else { m Zoom Offset X =  Math . min (  Math . max ( m Zoom Offset X * m Zoom , - crop Rect . left ) , - crop Rect . right + width ) / m Zoom ; m Zoom Offset Y =  Math . min (  Math . max ( m Zoom Offset Y * m Zoom , - crop Rect . top ) , - crop Rect . bottom + height ) / m Zoom ; } m Image Matrix . post Translate ( m Zoom Offset X * m Zoom , m Zoom Offset Y * m Zoom ) ; crop Rect . offset ( m Zoom Offset X * m Zoom , m Zoom Offset Y * m Zoom ) ; m Crop Overlay View . set Crop Window Rect ( crop Rect ) ; map Image Points By Image Matrix ( ) ; if ( animate ) { m Animation . set End State ( m Image Points , m Image Matrix ) ; m Image View . start Animation ( m Animation ) ; } else { m Image View . set Image Matrix ( m Image Matrix ) ; } update Image Bounds ( _ BOOL ) ; } }
public static void add Startup Listener (  Start Up Listener s ) { s_startup Listeners . add ( s ) ; }
public static void close Quiet ( @  Nullable  Context rsrc ) { if ( rsrc != null ) try { rsrc . close ( ) ; } catch (  Naming Exception ignored ) { } }
public  Completable Future < ? > optimize Old Files ( ) { synchronized ( this ) { if ( optimize Old Files ) return  Completable Future . completed Future ( null ) ;  Completable Future < ? > task = new  Completable Future < > ( ) ;  Thread thr = new  Thread ( null ) ; thr . set Daemon ( _ BOOL ) ; thr . start ( ) ; pending Tasks . add ( task ) ; optimize Old Files = _ BOOL ; task . when Complete ( null ) ; return task ; } }
private static  Key create DESKey ( final byte [ ] bytes , final int offset ) { final byte [ ] key Bytes = new byte [ _ NUM ] ;  System . arraycopy ( bytes , offset , key Bytes , _ NUM , _ NUM ) ; final byte [ ] material = new byte [ _ NUM ] ; material [ _ NUM ] = key Bytes [ _ NUM ] ; material [ _ NUM ] = ( byte ) ( key Bytes [ _ NUM ] << _ NUM | ( key Bytes [ _ NUM ] & _ NUM ) > > > _ NUM ) ; material [ _ NUM ] = ( byte ) ( key Bytes [ _ NUM ] << _ NUM | ( key Bytes [ _ NUM ] & _ NUM ) > > > _ NUM ) ; material [ _ NUM ] = ( byte ) ( key Bytes [ _ NUM ] << _ NUM | ( key Bytes [ _ NUM ] & _ NUM ) > > > _ NUM ) ; material [ _ NUM ] = ( byte ) ( key Bytes [ _ NUM ] << _ NUM | ( key Bytes [ _ NUM ] & _ NUM ) > > > _ NUM ) ; material [ _ NUM ] = ( byte ) ( key Bytes [ _ NUM ] << _ NUM | ( key Bytes [ _ NUM ] & _ NUM ) > > > _ NUM ) ; material [ _ NUM ] = ( byte ) ( key Bytes [ _ NUM ] << _ NUM | ( key Bytes [ _ NUM ] & _ NUM ) > > > _ NUM ) ; material [ _ NUM ] = ( byte ) ( key Bytes [ _ NUM ] << _ NUM ) ; odd Parity ( material ) ; return new  Secret Key Spec ( material , _ STR ) ; }
protected boolean filter Modules (  Collection <  Module > modules ) { if ( task . get No Mtime Check ( ) || is Output Repository URL ( ) ) { return _ BOOL ; }  Iterator <  Module > iterator = modules . iterator ( ) ; while ( iterator . has Next ( ) ) {  Module m = iterator . next ( ) ;  Module module = find Module ( m . get Name ( ) ) ; if ( module == null || module . get Version ( ) == null ) { task . log ( _ STR + m . get Name ( ) + _ STR ,  Project .  MSG_ VERBOSE ) ; continue ; } long newest =  Math . max ( newest File ( task . get Src ( ) , module . to Dir ( ) ) , newest File ( task . get Resource ( ) , module . to Dir ( ) ) ) ;  File out Module Dir = get Artifact Dir ( module ) ; long oldest = oldest Output Artifact (  Long .  MAX_ VALUE , out Module Dir ) ; task . log ( _ STR + out Module Dir + _ STR + new  Date ( oldest ) ,  Project .  MSG_ DEBUG ) ; if ( newest !=  Long .  MIN_ VALUE && oldest !=  Long .  MAX_ VALUE && newest < oldest ) { task . log ( _ STR + module + _ STR ) ; iterator . remove ( ) ; } } return modules . size ( ) == _ NUM ; }
public  String html All ( boolean set Included ) {  String Builder sb = new  String Builder ( ) ; for (  Node node : nodes ) { sb . append ( set Included ? node . get Html ( ) : node . get Inner Html ( ) ) ; } return sb . to String ( ) ; }
private boolean scan Expr (  Symbol Table symbol Table ,  Tokens tokens ,  String data , int current Offset , int end Offset ) throws  XNIException { int ch ; int name Offset ;  String name Handle = null ; while ( _ BOOL ) { if ( current Offset == end Offset ) { break ; } ch = data . char At ( current Offset ) ; byte chartype = ( ch >= _ NUM ) ?  CHARTYPE_ NONASCII : f ASCIIChar Map [ ch ] ; switch ( chartype ) { case  CHARTYPE_ SLASH : if ( ++ current Offset == end Offset ) { return _ BOOL ; } add Token ( tokens ,  Tokens .  XPTRTOKEN_ ELEM_ CHILD ) ; ch = data . char At ( current Offset ) ; int child = _ NUM ; while ( ch >= _ STR && ch <= _ STR ) { child = ( child * _ NUM ) + ( ch - _ STR ) ; if ( ++ current Offset == end Offset ) { break ; } ch = data . char At ( current Offset ) ; } if ( child == _ NUM ) { report Error ( _ STR , new  Object [ ] { new  Character ( ( char ) ch ) } ) ; return _ BOOL ; } tokens . add Token ( child ) ; break ; case  CHARTYPE_ DIGIT : case  CHARTYPE_ LETTER : case  CHARTYPE_ MINUS : case  CHARTYPE_ NONASCII : case  CHARTYPE_ OTHER : case  CHARTYPE_ PERIOD : case  CHARTYPE_ UNDERSCORE : name Offset = current Offset ; current Offset = scan NCName ( data , end Offset , current Offset ) ; if ( current Offset == name Offset ) { report Error ( _ STR , new  Object [ ] { data } ) ; return _ BOOL ; } if ( current Offset < end Offset ) { ch = data . char At ( current Offset ) ; } else { ch = - _ NUM ; } name Handle = symbol Table . add Symbol ( data . substring ( name Offset , current Offset ) ) ; add Token ( tokens ,  Tokens .  XPTRTOKEN_ ELEM_ NCNAME ) ; tokens . add Token ( name Handle ) ; break ; } } return _ BOOL ; }
public static  String repeat Char ( char character , int repeat Count ) {  String Buffer string Buffer = new  String Buffer ( repeat Count ) ; for ( int i = _ NUM ; i <= repeat Count ; i ++ ) { string Buffer . append ( character ) ; } return string Buffer . to String ( ) ; }
public  String ( java . lang .  String Buffer buffer ) { this . offset = _ NUM ; this . count = buffer . length ( ) ; this . value = new char [ count ] ; buffer . get Chars ( _ NUM , count , value , _ NUM ) ; }
public static  Range iterate To Find Range Bounds (  XYDataset dataset ,  List visible Series Keys ,  Range x Range , boolean include Interval ) {  Param Checks . null Not Permitted ( dataset , _ STR ) ;  Param Checks . null Not Permitted ( visible Series Keys , _ STR ) ;  Param Checks . null Not Permitted ( x Range , _ STR ) ; double minimum =  Double .  POSITIVE_ INFINITY ; double maximum =  Double .  NEGATIVE_ INFINITY ; if ( include Interval && dataset instanceof  OHLCDataset ) {  OHLCDataset ohlc = (  OHLCDataset ) dataset ;  Iterator iterator = visible Series Keys . iterator ( ) ; while ( iterator . has Next ( ) ) {  Comparable series Key = (  Comparable ) iterator . next ( ) ; int series = dataset . index Of ( series Key ) ; int item Count = dataset . get Item Count ( series ) ; for ( int item = _ NUM ; item < item Count ; item ++ ) { double x = ohlc . get XValue ( series , item ) ; if ( x Range . contains ( x ) ) { double lvalue = ohlc . get Low Value ( series , item ) ; double uvalue = ohlc . get High Value ( series , item ) ; if ( !  Double . is Na N ( lvalue ) ) { minimum =  Math . min ( minimum , lvalue ) ; } if ( !  Double . is Na N ( uvalue ) ) { maximum =  Math . max ( maximum , uvalue ) ; } } } } } else if ( include Interval && dataset instanceof  Box And Whisker XYDataset ) {  Box And Whisker XYDataset bx = (  Box And Whisker XYDataset ) dataset ;  Iterator iterator = visible Series Keys . iterator ( ) ; while ( iterator . has Next ( ) ) {  Comparable series Key = (  Comparable ) iterator . next ( ) ; int series = dataset . index Of ( series Key ) ; int item Count = dataset . get Item Count ( series ) ; for ( int item = _ NUM ; item < item Count ; item ++ ) { double x = bx . get XValue ( series , item ) ; if ( x Range . contains ( x ) ) {  Number lvalue = bx . get Min Regular Value ( series , item ) ;  Number uvalue = bx . get Max Regular Value ( series , item ) ; if ( lvalue != null ) { minimum =  Math . min ( minimum , lvalue . double Value ( ) ) ; } if ( uvalue != null ) { maximum =  Math . max ( maximum , uvalue . double Value ( ) ) ; } } } } } else if ( include Interval && dataset instanceof  Interval XYDataset ) {  Interval XYDataset ixyd = (  Interval XYDataset ) dataset ;  Iterator iterator = visible Series Keys . iterator ( ) ; while ( iterator . has Next ( ) ) {  Comparable series Key = (  Comparable ) iterator . next ( ) ; int series = dataset . index Of ( series Key ) ; int item Count = dataset . get Item Count ( series ) ; for ( int item = _ NUM ; item < item Count ; item ++ ) { double x = ixyd . get XValue ( series , item ) ; if ( x Range . contains ( x ) ) { double yvalue = ixyd . get YValue ( series , item ) ; double lvalue = ixyd . get Start YValue ( series , item ) ; double uvalue = ixyd . get End YValue ( series , item ) ; if ( !  Double . is Na N ( yvalue ) ) { minimum =  Math . min ( minimum , yvalue ) ; maximum =  Math . max ( maximum , yvalue ) ; } if ( !  Double . is Na N ( lvalue ) ) { minimum =  Math . min ( minimum , lvalue ) ; } if ( !  Double . is Na N ( uvalue ) ) { maximum =  Math . max ( maximum , uvalue ) ; } } } } } else {  Iterator iterator = visible Series Keys . iterator ( ) ; while ( iterator . has Next ( ) ) {  Comparable series Key = (  Comparable ) iterator . next ( ) ; int series = dataset . index Of ( series Key ) ; int item Count = dataset . get Item Count ( series ) ; for ( int item = _ NUM ; item < item Count ; item ++ ) { double x = dataset . get XValue ( series , item ) ; double y = dataset . get YValue ( series , item ) ; if ( x Range . contains ( x ) ) { if ( !  Double . is Na N ( y ) ) { minimum =  Math . min ( minimum , y ) ; maximum =  Math . max ( maximum , y ) ; } } } } } if ( minimum ==  Double .  POSITIVE_ INFINITY ) { return null ; } else { return new  Range ( minimum , maximum ) ; } }
public  Builder ( ) { }
protected void verify Attributes (  Attr Set attr Set ) throws  AMException {  String user Status = attr Set . get Value (  USER_ STATUS_ ATTRIBUTE ) ; if ( user Status != null && user Status . equals Ignore Case ( _ STR ) ) { debug . warning ( _ STR +  USER_ STATUS_ ATTRIBUTE + _ STR + user Status ) ; throw new  AMException (  AMSDKBundle . get String ( _ STR ) , _ STR ) ; } }
private void update Zoning Map (  Un Managed Export Mask mask ,  List < com . emc . storageos . db . client . model .  Initiator > initiators ,  List < com . emc . storageos . db . client . model .  Storage Port > storage Ports ) {  Zone Info Map zoning Map = network Device Controller . get Initiators Zone Info Map ( initiators , storage Ports ) ; for (  Zone Info zone Info : zoning Map . values ( ) ) { log . info ( _ STR , zone Info . get Zone Name ( ) , zone Info . get Initiator Wwn ( ) , zone Info . get Port Wwn ( ) ) ; } mask . set Zoning Map ( zoning Map ) ; }
public void reject Session ( ) { reject Session (  Invitation Status .  INVITATION_ REJECTED_ BUSY_ HERE ) ; }
protected  Rectangle calculate BBox (  List <  Point > points ) { double min X =  Double .  MAX_ VALUE ; double min Y =  Double .  MAX_ VALUE ; double max X = -  Double .  MAX_ VALUE ; double max Y = -  Double .  MAX_ VALUE ; for (  Point p : points ) { min X =  Math . min ( p . get X ( ) , min X ) ; min Y =  Math . min ( p . get Y ( ) , min Y ) ; max X =  Math . max ( p . get X ( ) , max X ) ; max Y =  Math . max ( p . get Y ( ) , max Y ) ; } return new  Rectangle ( ( float ) min X , ( float ) min Y , ( float ) ( max X - min X ) , ( float ) ( max Y - min Y ) ) ; }
public  Matrix compute (  Matrix loghyper ,  Matrix  X ) { if ( loghyper . get Column Dimension ( ) != _ NUM || loghyper . get Row Dimension ( ) != num Parameters ( ) ) throw new  Illegal Argument Exception ( _ STR + loghyper . get Row Dimension ( ) + _ STR + num Parameters ( ) ) ; final double ell =  Math . exp ( loghyper . get ( _ NUM , _ NUM ) ) ; final double em2 = _ NUM / ( ell * ell ) ; final double oneplusem2 = _ NUM + em2 ; final double sf2 =  Math . exp ( _ NUM * loghyper . get ( _ NUM , _ NUM ) ) ; final int m =  X . get Row Dimension ( ) ; final int n =  X . get Column Dimension ( ) ; double [ ] [ ] x =  X . get Array ( ) ; q = new double [ m ] [ m ] ; for ( int i = _ NUM ; i < m ; i ++ ) { for ( int j = _ NUM ; j < m ; j ++ ) { double t = _ NUM ; for ( int k = _ NUM ; k < n ; k ++ ) { t += x [ i ] [ k ] * x [ j ] [ k ] * em2 ; } q [ i ] [ j ] = t ; } } double [ ] dq = new double [ m ] ; for ( int i = _ NUM ; i < m ; i ++ ) { dq [ i ] =  Math . sqrt ( oneplusem2 + q [ i ] [ i ] ) ; }  Matrix  A = new  Matrix ( m , m ) ; double [ ] [ ] k = new double [ m ] [ m ] ; double [ ] [ ] a =  A . get Array ( ) ; for ( int i = _ NUM ; i < m ; i ++ ) { final double dqi = dq [ i ] ; for ( int j = _ NUM ; j < m ; j ++ ) { final double t = ( em2 + q [ i ] [ j ] ) / ( dqi * dq [ j ] ) ; k [ i ] [ j ] = t ; a [ i ] [ j ] = sf2 *  Math . asin ( t ) ; } } return  A ; }
private void read ASCII ( final  Buffered Reader buffer ) throws  Number Format Exception ,  IOException {  Raj Log . i ( _ STR ) ; final  List <  Float > vertices = new  Array List <  Float > ( ) ; final  List <  Float > normals = new  Array List <  Float > ( ) ; final float [ ] temp Norms = new float [ _ NUM ] ; int next Offset , prev Offset , i , insert ;  String line ; line = buffer . read Line ( ) ; while ( ( line = buffer . read Line ( ) ) != null ) { if ( line . contains ( _ STR ) ) { next Offset = line . last Index Of ( _ STR ) ; temp Norms [ _ NUM ] =  Float . parse Float ( line . substring ( next Offset + _ NUM ) ) ; prev Offset = next Offset ; next Offset = line . last Index Of ( _ STR , prev Offset - _ NUM ) ; temp Norms [ _ NUM ] =  Float . parse Float ( line . substring ( next Offset + _ NUM , prev Offset ) ) ; prev Offset = next Offset ; next Offset = line . last Index Of ( _ STR , prev Offset - _ NUM ) ; temp Norms [ _ NUM ] =  Float . parse Float ( line . substring ( next Offset + _ NUM , prev Offset ) ) ; for ( i = _ NUM ; i < _ NUM ; i ++ ) { normals . add ( temp Norms [ _ NUM ] ) ; normals . add ( temp Norms [ _ NUM ] ) ; normals . add ( temp Norms [ _ NUM ] ) ; } } else if ( line . contains ( _ STR ) ) { insert = vertices . size ( ) ; next Offset = line . last Index Of ( _ STR ) ; vertices . add (  Float . parse Float ( line . substring ( next Offset + _ NUM ) ) ) ; prev Offset = next Offset ; next Offset = line . last Index Of ( _ STR , prev Offset - _ NUM ) ; vertices . add ( insert ,  Float . parse Float ( line . substring ( next Offset + _ NUM , prev Offset ) ) ) ; prev Offset = next Offset ; next Offset = line . last Index Of ( _ STR , prev Offset - _ NUM ) ; vertices . add ( insert ,  Float . parse Float ( line . substring ( next Offset + _ NUM , prev Offset ) ) ) ; } } float [ ] vertices Arr = new float [ vertices . size ( ) ] ; float [ ] normals Arr = new float [ normals . size ( ) ] ; for ( i = _ NUM ; i < vertices Arr . length ; i ++ ) { vertices Arr [ i ] = vertices . get ( i ) ; normals Arr [ i ] = normals . get ( i ) ; } vertices . clear ( ) ; normals . clear ( ) ; int [ ] indices Arr = new int [ vertices Arr . length / _ NUM ] ; for ( i = _ NUM ; i < indices Arr . length ; i ++ ) indices Arr [ i ] = i ; m Root Object . set Data ( vertices Arr , normals Arr , null , null , indices Arr , _ BOOL ) ; }
private static int max Points (  Point [ ] points ) { if ( points . length < _ NUM ) return points . length ; int res = _ NUM ;  Map <  String ,  Integer > map = new  Hash Map <  String ,  Integer > ( ) ; for ( int i = _ NUM ; i < points . length ; i ++ ) { int max = _ NUM ; int count Same = _ NUM ; for ( int j = i + _ NUM ; j < points . length ; j ++ ) { if ( points [ i ] . x == points [ j ] . x && points [ i ] . y == points [ j ] . y ) count Same ++ ; else {  String key = normalize ( points [ i ] , points [ j ] ) ; if ( map . contains Key ( key ) ) { int count = map . get ( key ) + _ NUM ; map . put ( key , count ) ; if ( count > max ) max = count ; } else { map . put ( key , _ NUM ) ; if ( max == _ NUM ) max ++ ; } } } res =  Math . max ( res , max + count Same + _ NUM ) ; map . clear ( ) ; } return res ; }
public static  Subject Type from String (  String type ) { if ( type != null ) { for (  Subject Type subject Type :  Subject Type . values ( ) ) { if ( type . equals Ignore Case ( subject Type . type ) ) { return subject Type ; } } } return null ; }
public static  Iterator create Shape3 D (  Shape shape , double baseline Height ,  Color color , boolean filled ) { int buffer Size =  DEFAULT_ NPOINTS_ BUFFER_ SIZE ; double [ ] data = expand Array D ( buffer Size , null ) ; int data Index = _ NUM ; int refresh Counter = buffer Size ; int [ ] strip Count = new int [ _ NUM ] ; strip Count [ _ NUM ] = _ NUM ;  Path Iterator pi2 = shape . get Path Iterator ( null ) ; float flatness = _ NUM ;  Flattening Path Iterator pi = new  Flattening Path Iterator ( pi2 , flatness ) ; double [ ] coords = new double [ _ NUM ] ; double pntx = _ NUM ; double pnty = _ NUM ; double pntz = baseline Height ;  Hash Set set = new  Hash Set ( ) ;  Shape3 D shape3 D = null ;  Debug . message ( _ STR , _ STR ) ; while ( ! pi . is Done ( ) ) { int type = pi . current Segment ( coords ) ; switch ( type ) { case  Path Iterator .  SEG_ MOVETO : if ( data Index != _ NUM ) { shape3 D = create Shape3 D ( data , data Index , strip Count , color , filled ) ; if ( shape3 D != null ) { set . add ( shape3 D ) ; } data = expand Array D ( buffer Size , null ) ; data Index = _ NUM ; } case  Path Iterator .  SEG_ LINETO : pntx = coords [ _ NUM ] ; pnty = coords [ _ NUM ] ; if (  Debug . debugging ( _ STR ) ) {  Debug . output ( _ STR + pntx + _ STR + pnty ) ; } if ( data Index >= data . length ) { data = expand Array D ( buffer Size , data ) ; refresh Counter = buffer Size ; } data [ data Index ++ ] = pntx ; data [ data Index ++ ] = pntz ; data [ data Index ++ ] = pnty ; strip Count [ _ NUM ] ++ ; refresh Counter -= _ NUM ; break ; default :  Debug . message ( _ STR , _ STR + coords [ _ NUM ] + _ STR + coords [ _ NUM ] + _ STR ) ; } pi . next ( ) ; } if ( data Index != _ NUM ) { shape3 D = create Shape3 D ( data , data Index , strip Count , color , filled ) ; if ( shape3 D != null ) { set . add ( shape3 D ) ; } } return set . iterator ( ) ; }
public static  String remove Package Name (  String fully_qualified_name_ ) { if ( fully_qualified_name_ == null ) return null ; int lastdot = fully_qualified_name_ . last Index Of ( _ STR ) ; if ( lastdot < _ NUM ) { return _ STR ; } else { return fully_qualified_name_ . substring ( lastdot + _ NUM ) ; } }
@  Override public void flip (  WComponent Peer peer ,  Component target ,  Volatile Image back Buffer , int x1 , int y1 , int x2 , int y2 ,  Buffer Capabilities .  Flip Contents flip Action ) { if ( flip Action ==  Buffer Capabilities .  Flip Contents .  COPIED ) {  Surface Manager vsm =  Surface Manager . get Manager ( back Buffer ) ;  Surface Data sd = vsm . get Primary Surface Data ( ) ; if ( sd instanceof  WGLVSync Off Screen Surface Data ) {  WGLVSync Off Screen Surface Data vsd = (  WGLVSync Off Screen Surface Data ) sd ;  Surface Data bbsd = vsd . get Flip Surface ( ) ;  Graphics2 D bbg = new  Sun Graphics2 D ( bbsd ,  Color . black ,  Color . white , null ) ; try { bbg . draw Image ( back Buffer , _ NUM , _ NUM , null ) ; } finally { bbg . dispose ( ) ; } } else {  Graphics g = peer . get Graphics ( ) ; try { g . draw Image ( back Buffer , x1 , y1 , x2 , y2 , x1 , y1 , x2 , y2 , null ) ; } finally { g . dispose ( ) ; } return ; } } else if ( flip Action ==  Buffer Capabilities .  Flip Contents .  PRIOR ) { return ; }  OGLSurface Data . swap Buffers ( peer . get Data ( ) ) ; if ( flip Action ==  Buffer Capabilities .  Flip Contents .  BACKGROUND ) {  Graphics g = back Buffer . get Graphics ( ) ; try { g . set Color ( target . get Background ( ) ) ; g . fill Rect ( _ NUM , _ NUM , back Buffer . get Width ( ) , back Buffer . get Height ( ) ) ; } finally { g . dispose ( ) ; } } }
public  PTProperty add Property ( final  PTProperty property ) { if ( properties . contains ( property ) ) { throw new  Illegal Argument Exception ( _ STR + property . get Name ( ) + _ STR ) ; } properties . add ( property ) ; property . set Parent Table ( this ) ; return property ; }
Speed Predictor ( ) { times = new double [  VECTOR_ LENGTH ] ;  Wt Window Manager wm =  Wt Window Manager . get Instance ( ) ; prediction =  Math Helper . parse Double Default ( wm . get Property (  SPEED_ PROPERTY ,  Double . to String (  INITIAL_ PREDICTED_ SPEED ) ) ,  INITIAL_ PREDICTED_ SPEED ) ; jitter =  Math Helper . parse Double ( wm . get Property (  JITTER_ PROPERTY , _ STR ) ) ; double average =  TURN_ LENGTH / prediction ; for ( int i = _ NUM ; i <  VECTOR_ LENGTH ; i ++ ) { times [ i ] = average ; } }
@  Override public void from Data (  Data Input in ) throws  IOException ,  Class Not Found Exception { super . from Data ( in ) ; refresh Interval = in . read Long ( ) ; alert Defs = (  Stat Alert Definition [ ] )  Data Serializer . read Object Array ( in ) ; }
public void redirect Subtree (  Content Handler child ,  String uri ,  String local ,  String qname ) throws  SAXException { redirect = child ; redirect . set Document Locator ( locator ) ; redirect . start Document ( ) ; for ( int i = _ NUM ; i < namespaces . size ( ) ; i += _ NUM ) redirect . start Prefix Mapping ( (  String ) namespaces . get ( i ) , (  String ) namespaces . get ( i + _ NUM ) ) ; redirect . start Element ( uri , local , qname , current Atts ) ; redirection Depth = _ NUM ; }
protected int [ ] read Color Table ( int ncolors ) { int nbytes = _ NUM * ncolors ; int [ ] tab = null ; byte [ ] c = new byte [ nbytes ] ; int n = _ NUM ; try { n = in . read ( c ) ; } catch (  IOException e ) { } if ( n < nbytes ) { status =  STATUS_ FORMAT_ ERROR ; } else { tab = new int [ _ NUM ] ; int i = _ NUM ; int j = _ NUM ; while ( i < ncolors ) { int r = ( ( int ) c [ j ++ ] ) & _ NUM ; int g = ( ( int ) c [ j ++ ] ) & _ NUM ; int b = ( ( int ) c [ j ++ ] ) & _ NUM ; tab [ i ++ ] = _ NUM | ( r << _ NUM ) | ( g << _ NUM ) | b ; } } return tab ; }
public static void save To Protected Store (  Private Key private Key ,  Certificate certificate ,  File store Location ,  String alias ,  String private Key Password ,  String key Store Password ,  String key Store Type ) throws  IOException ,  Key Store Exception ,  No Such Provider Exception ,  No Such Algorithm Exception ,  Certificate Exception {  Key Store store = null ; if ( key Store Type . equals ( _ STR ) ) { store =  Key Store . get Instance ( key Store Type ,  Crypto Util . get Security Provider Name (  Key Store . class ) ) ; } else store =  Key Store . get Instance ( key Store Type ) ; store . load ( null , null ) ;  Certificate [ ] chain = new  Certificate [ _ NUM ] ; chain [ _ NUM ] = certificate ; if ( private Key Password != null ) store . set Key Entry ( alias , private Key , private Key Password . to Char Array ( ) , chain ) ; else store . set Key Entry ( alias , private Key , null , chain ) ;  File Output Stream f Out = new  File Output Stream ( store Location ) ; try { store . store ( f Out , key Store Password == null ? null : key Store Password . to Char Array ( ) ) ; } finally { f Out . close ( ) ; } }
public synchronized boolean contains (  File file ) { return value . contains ( file ) ; }
protected int draw Legend (  Canvas canvas ,  Default Renderer renderer ,  String [ ] titles , int left , int right , int y , int width , int height , int legend Size ,  Paint paint , boolean calculate ) { float size = _ NUM ; if ( renderer . is Show Legend ( ) ) { float current X = left ; float current Y = y + height - legend Size + size ; paint . set Text Align (  Align .  LEFT ) ; paint . set Text Size ( renderer . get Legend Text Size ( ) ) ; int s Length =  Math . min ( titles . length , renderer . get Series Renderer Count ( ) ) ; for ( int i = _ NUM ; i < s Length ; i ++ ) {  Simple Series Renderer r = renderer . get Series Renderer At ( i ) ; final float line Size = get Legend Shape Width ( i ) ; if ( r . is Show Legend Item ( ) ) {  String text = titles [ i ] ; if ( titles . length == renderer . get Series Renderer Count ( ) ) { paint . set Color ( r . get Color ( ) ) ; } else { paint . set Color (  Color .  LTGRAY ) ; } float [ ] widths = new float [ text . length ( ) ] ; paint . get Text Widths ( text , widths ) ; float sum = _ NUM ; for ( float value : widths ) { sum += value ; } float extra Size = line Size + _ NUM + sum ; float current Width = current X + extra Size ; if ( i > _ NUM && get Exceed ( current Width , renderer , right , width ) ) { current X = left ; current Y += renderer . get Legend Text Size ( ) ; size += renderer . get Legend Text Size ( ) ; current Width = current X + extra Size ; } if ( get Exceed ( current Width , renderer , right , width ) ) { float max Width = right - current X - line Size - _ NUM ; if ( is Vertical ( renderer ) ) { max Width = width - current X - line Size - _ NUM ; } int nr = paint . break Text ( text , _ BOOL , max Width , widths ) ; text = text . substring ( _ NUM , nr ) + _ STR ; } if ( ! calculate ) { draw Legend Shape ( canvas , r , current X , current Y , i , paint ) ; draw String ( canvas , text , current X + line Size + _ NUM , current Y + _ NUM , paint ) ; } current X += extra Size ; } } } return  Math . round ( size + renderer . get Legend Text Size ( ) ) ; }
public abstract boolean is Search Compatible (  E element ,  Search Criteria search Criteria ,  Repository Definition repository Definition ) ;
private void disable Buttons ( ) { set Kick Enabled ( _ BOOL ) ; set Punch Enabled ( _ BOOL ) ; set Push Enabled ( _ BOOL ) ; set Trip Enabled ( _ BOOL ) ; set Grapple Enabled ( _ BOOL ) ; set Jump Jet Enabled ( _ BOOL ) ; set Club Enabled ( _ BOOL ) ; set Brush Off Enabled ( _ BOOL ) ; set Thrash Enabled ( _ BOOL ) ; set Dodge Enabled ( _ BOOL ) ; set Proto Enabled ( _ BOOL ) ; set Vibro Enabled ( _ BOOL ) ; set Explosives Enabled ( _ BOOL ) ; but Done . set Enabled ( _ BOOL ) ; set Next Enabled ( _ BOOL ) ; }
private boolean is Additive Number (  Big Integer num1 ,  Big Integer num2 , int start ,  String num ) { if ( start == num . length ( ) ) { return _ BOOL ; } num2 = num2 . add ( num1 ) ; num1 = num2 . subtract ( num1 ) ;  String sum = num2 . to String ( ) ; return num . starts With ( sum , start ) && is Additive Number ( num1 , num2 , start + sum . length ( ) , num ) ; }
static public void append Escaping CDATA ( final  String Buffer buf , final  String str ) { if ( str != null ) { int end = str . index Of (  CDATA_ END ) ; if ( end < _ NUM ) { buf . append ( str ) ; } else { int start = _ NUM ; while ( end > - _ NUM ) { buf . append ( str . substring ( start , end ) ) ; buf . append (  CDATA_ EMBEDED_ END ) ; start = end +  CDATA_ END_ LEN ; if ( start < str . length ( ) ) { end = str . index Of (  CDATA_ END , start ) ; } else { return ; } } buf . append ( str . substring ( start ) ) ; } } }
private  List < int [ ] > prepare Expected Data ( ) {  List < int [ ] > index List = new  Array List < > ( _ NUM ) ; int [ ] sort Index = { _ NUM , _ NUM , _ NUM , _ NUM , _ NUM } ; int [ ] sort Index Inverted = { _ NUM , _ NUM , _ NUM , _ NUM , _ NUM } ; index List . add ( _ NUM , sort Index ) ; index List . add ( _ NUM , sort Index Inverted ) ; return index List ; }
public void add Url Features (  Nutch Document doc ,  String url String ) { try {  URL url = new  URL ( url String ) ;  String Tokenizer names = new  String Tokenizer ( url . get Path ( ) , _ STR ) ; if ( names . has More Tokens ( ) ) names . next Token ( ) ; while ( names . has More Tokens ( ) ) {  String feature = names . next Token ( ) ; add Feature ( doc , feature ) ; } } catch (  Malformed URLException e ) { if (  LOG . is Warn Enabled ( ) ) {  LOG . warn ( _ STR + url String + _ STR + e ) ; } } }
@  Override protected void assert Valid Value (  String value ) { super . assert Valid Value ( value ) ; for ( int i = _ NUM ; i < value . length ( ) ; i ++ ) { char c = value . char At ( i ) ; if ( c == _ STR ) { throw invalid Raw Template String ( value ) ; } else if ( c == _ STR ) { if ( i + _ NUM < value . length ( ) && value . char At ( i + _ NUM ) == _ STR ) { throw invalid Raw Template String ( value ) ; } } } }
public void sort (  Comparator <  Fragment Data > comparator ) { check Transaction ( ) ; save Old Order ( ) ; if ( comparator == null ) {  Collections . sort ( m Fragment Datas ) ; } else {  Collections . sort ( this . m Fragment Datas , comparator ) ; } check Position Change ( ) ; }
void output Entity Decl (  String name ,  String value ) throws  IOException { final java . io .  Writer writer = m_writer ; writer . write ( _ STR ) ; writer . write ( name ) ; writer . write ( _ STR ) ; writer . write ( value ) ; writer . write ( _ STR ) ; writer . write ( m_line Sep , _ NUM , m_line Sep Len ) ; }
public static boolean is Legal Identifier (  String name ) { if ( name . is Empty ( ) ) { return _ BOOL ; } if ( !  Character . is Java Identifier Start ( name . char At ( _ NUM ) ) ) { return _ BOOL ; } int i = _ NUM ; while ( i < name . length ( ) ) { if ( !  Character . is Java Identifier Part ( name . char At ( i ) ) ) { return _ BOOL ; } i = i + _ NUM ; } return _ BOOL ; }
public  PWReset Exception (  Throwable t ) { super ( t ) ; err List = new  Array List ( _ NUM ) ; err List . add ( t . get Message ( ) ) ; }
public static  String [ ] concatenate (  String [ ] array1 ,  String [ ] array2 ) { if ( array1 == null ) { return array2 ; } if ( array2 == null ) { return array1 ; }  String [ ] result = new  String [ array1 . length + array2 . length ] ;  System . arraycopy ( array1 , _ NUM , result , _ NUM , array1 . length ) ;  System . arraycopy ( array2 , _ NUM , result , array1 . length , array2 . length ) ; return result ; }
static void remove Size Hints (  XDecorated Peer window , long mask ) { mask &=  XUtil Constants .  PMax Size |  XUtil Constants .  PMin Size ;  XToolkit . awt Lock ( ) ; try {  XSize Hints hints = window . get Hints ( ) ; if ( ( hints . get_flags ( ) & mask ) == _ NUM ) { return ; } hints . set_flags ( hints . get_flags ( ) & ~ mask ) ; if ( ins Log . is Loggable (  Platform Logger .  Level .  FINER ) ) { ins Log . finer ( _ STR +  Xlib Wrapper . hints To String ( hints . get_flags ( ) ) ) ; }  Xlib Wrapper .  XSet WMNormal Hints (  XToolkit . get Display ( ) , window . get Window ( ) , hints . p Data ) ; } finally {  XToolkit . awt Unlock ( ) ; } }
int find Ancestor (  XPath Context xctxt ,  XPath from Match Pattern ,  XPath count Match Pattern , int context ,  Elem Number namespace Context ) throws javax . xml . transform .  Transformer Exception {  DTM dtm = xctxt . get DTM ( context ) ; while (  DTM .  NULL != context ) { if ( null != from Match Pattern ) { if ( from Match Pattern . get Match Score ( xctxt , context ) !=  XPath .  MATCH_ SCORE_ NONE ) { break ; } } if ( null != count Match Pattern ) { if ( count Match Pattern . get Match Score ( xctxt , context ) !=  XPath .  MATCH_ SCORE_ NONE ) { break ; } } context = dtm . get Parent ( context ) ; } return context ; }
public  List <  Local Date > top ( int n ) {  List <  Local Date > top = new  Array List < > ( ) ; int [ ] values = data . to Int Array ( ) ;  Int Arrays . parallel Quick Sort ( values ,  Reverse Int Comparator . instance ( ) ) ; for ( int i = _ NUM ; i < n && i < values . length ; i ++ ) { top . add (  Packed Local Date . as Local Date ( values [ i ] ) ) ; } return top ; }
public static  String grab Name (  String signature ) {  Matcher matcher = sig RE . matcher ( signature ) ; boolean b = matcher . matches ( ) ; if ( ! b && matcher . group Count ( ) != _ NUM ) logger . error ( _ STR , signature ) ; return matcher . group ( _ NUM ) ; }
public static <  K ,  V >  Collector <  Entry <  K ,  V > , ? ,  Map <  K ,  V > > to Map ( ) { return  Collectors . to Map ( null , null ) ; }
@  Override public final boolean has More Elements ( ) { if ( m_ Counter < m_ Vector . size ( ) ) { return _ BOOL ; } return _ BOOL ; }
static  String escape Bytes ( final  Byte String input ) { final  String Builder builder = new  String Builder ( input . size ( ) ) ; for ( int i = _ NUM ; i < input . size ( ) ; i ++ ) { final byte b = input . byte At ( i ) ; switch ( b ) { case _ NUM : builder . append ( _ STR ) ; break ; case _ STR : builder . append ( _ STR ) ; break ; case _ STR : builder . append ( _ STR ) ; break ; case _ STR : builder . append ( _ STR ) ; break ; case _ STR : builder . append ( _ STR ) ; break ; case _ STR : builder . append ( _ STR ) ; break ; case _ NUM : builder . append ( _ STR ) ; break ; case _ STR : builder . append ( _ STR ) ; break ; case _ STR : builder . append ( _ STR ) ; break ; case _ STR : builder . append ( _ STR ) ; break ; default : if ( b >= _ NUM ) { builder . append ( ( char ) b ) ; } else { builder . append ( _ STR ) ; builder . append ( ( char ) ( _ STR + ( ( b > > > _ NUM ) & _ NUM ) ) ) ; builder . append ( ( char ) ( _ STR + ( ( b > > > _ NUM ) & _ NUM ) ) ) ; builder . append ( ( char ) ( _ STR + ( b & _ NUM ) ) ) ; } break ; } } return builder . to String ( ) ; }
public void add To Path Option (  String key ,  String to Append ) { if ( to Append == null ) { throw new  Illegal Argument Exception ( _ STR ) ; }  String path = options . get ( key ) ; if ( to Append . starts With (  File . path Separator ) ) { if ( path == null || path . is Empty ( ) ) { path = to Append . substring ( _ NUM , to Append . length ( ) ) ; } else { path += to Append ; } } else { if ( path == null || path . is Empty ( ) ) { path = to Append ; } else { path +=  File . path Separator + to Append ; } } add Option ( key , path ) ; }
public void handle Button3 Request (  Request Invocation Event event ) throws  Model Control Exception { try {  AMView Bean Base vb = (  AMView Bean Base ) get View Bean (  Class . for Name ( (  String ) get Page Session Attribute (  PG_ ATTR_ CONFIG_ PAGE ) ) ) ; remove Page Session Attribute (  PG_ ATTR_ CONFIG_ PAGE ) ; remove Page Session Attribute (  PG_ ATTR_ PROPERTY_ NAMES ) ; pass Pg Session Map ( vb ) ; vb . forward To ( get Request Context ( ) ) ; } catch (  Class Not Found Exception e ) { set Inline Alert Message (  CCAlert .  TYPE_ ERROR , _ STR , e . get Message ( ) ) ; } }
public  JSONException (  Throwable cause ) { super ( cause . get Message ( ) ) ; this . cause = cause ; }
public double distance (  Pla Point Int p_to_point ) { return  Math . sqrt ( distance_square ( p_to_point ) ) ; }
@  Override public void done ( ) { if ( done ) return ; if ( ! deflater . finished ( ) ) { deflater . finish ( ) ; while ( ! deflater . finished ( ) ) deflate ( ) ; } done = _ BOOL ; if ( idat Chunk Writer != null ) idat Chunk Writer . close ( ) ; }
public  Active MQThread Factory ( final  String group Name , final boolean daemon , final  Class Loader tccl ) { group = new  Thread Group ( group Name + _ STR +  System . identity Hash Code ( this ) ) ; this . thread Priority =  Thread .  NORM_ PRIORITY ; this . tccl = tccl ; this . daemon = daemon ; this . acc =  Access Controller . get Context ( ) ; }
private void verify Signature (  X509 Certificate cert ) throws  Cert Path Validator Exception {  String msg = _ STR ; if ( debug != null ) debug . println ( _ STR + msg + _ STR ) ; try { cert . verify ( prev Pub Key , sig Provider ) ; } catch (  Signature Exception e ) { throw new  Cert Path Validator Exception ( msg + _ STR , e , null , - _ NUM ,  Basic Reason .  INVALID_ SIGNATURE ) ; } catch (  General Security Exception e ) { throw new  Cert Path Validator Exception ( msg + _ STR , e ) ; } if ( debug != null ) debug . println ( msg + _ STR ) ; }
private  String random Hash ( final  String folder ) throws  Exception { try {  Message Digest algorithm =  Message Digest . get Instance ( _ STR ) ; algorithm . reset ( ) ; try { algorithm . update ( folder . get Bytes ( _ STR ) ) ; } catch (  Unsupported Encoding Exception e ) { if ( configuration . is Debug Mode ( ) ) { throw e ; } algorithm . update ( folder . get Bytes ( ) ) ; } byte [ ] message Digest = algorithm . digest ( ) ;  String Buffer hex String = new  String Buffer ( ) ; for ( int i = _ NUM ; i < message Digest . length ; i ++ ) { hex String . append (  Integer . to Hex String (  HASH & message Digest [ i ] ) ) ; } return hex String . to String ( ) ; } catch (  No Such Algorithm Exception e ) { if ( configuration . is Debug Mode ( ) ) { throw e ; } return _ STR ; } }
public  Pointer to Dense Matrix ( cusparse Handle cusparse Handle , cublas Handle cublas Handle , int rows , int cols ) throws  DMLRuntime Exception { long size = rows * cols *  Sizeof .  DOUBLE ;  Pointer  A =  JCuda Object . allocate ( size ) ; cusparse Dcsr2dense ( cusparse Handle , rows , cols , descr , val , row Ptr , col Ind ,  A , rows ) ; return  A ; }
public static  String to Hex String ( byte [ ] array ) { return to Hex String (  Byte Buffer . wrap ( array ) , _ NUM , array . length ) ; }
private byte [ ] write Checked Bytes (  Message Nano proto ) {  Checked Message wrapper = new  Checked Message ( ) ; wrapper . payload =  Message Nano . to Byte Array ( proto ) ;  CRC32 checksum = new  CRC32 ( ) ; checksum . update ( wrapper . payload ) ; wrapper . checksum = checksum . get Value ( ) ; return  Message Nano . to Byte Array ( wrapper ) ; }
protected void draw Html Text (  String text , int x , int y , int w , int h ,  Map <  String ,  Object > style ) { mx Lighweight Label text Renderer = mx Lighweight Label . get Shared Instance ( ) ; if ( text Renderer != null && renderer Pane != null ) { boolean horizontal = mx Utils . is True ( style , mx Constants .  STYLE_ HORIZONTAL , _ BOOL ) ; if ( g . hit Clip ( x , y , w , h ) ) {  Affine Transform at = g . get Transform ( ) ; if ( ! horizontal ) { g . rotate ( -  Math .  PI / _ NUM , x + w / _ NUM , y + h / _ NUM ) ; g . translate ( w / _ NUM - h / _ NUM , h / _ NUM - w / _ NUM ) ; int tmp = w ; w = h ; h = tmp ; } text Renderer . set Text ( mx Utils . create Html Document ( style , text ) ) ; g . scale ( scale , scale ) ; renderer Pane . paint Component ( g , text Renderer , renderer Pane , ( int ) ( x / scale ) + mx Constants .  LABEL_ INSET , ( int ) ( y / scale ) + mx Constants .  LABEL_ INSET , ( int ) ( w / scale ) , ( int ) ( h / scale ) , _ BOOL ) ; g . set Transform ( at ) ; } } }
protected boolean play User Sound (  String sound Identifier ) {  Object sound = builtin Sounds . get ( sound Identifier ) ; if ( sound == null ) { return _ BOOL ; } return _ BOOL ; }
@  Override public  String to String ( ) { if ( string != null ) { return string ; }  String Builder result = new  String Builder ( ) ; if ( scheme != null ) { result . append ( scheme ) ; result . append ( _ STR ) ; } if ( opaque ) { result . append ( scheme Specific Part ) ; } else { if ( authority != null ) { result . append ( _ STR ) ; result . append ( authority ) ; } if ( path != null ) { result . append ( path ) ; } if ( query != null ) { result . append ( _ STR ) ; result . append ( query ) ; } } if ( fragment != null ) { result . append ( _ STR ) ; result . append ( fragment ) ; } string = result . to String ( ) ; return string ; }
public static int find Name (  String name ,  String [ ] table ) { for ( int i = _ NUM ; i < table . length ; i ++ ) { if ( name . equals ( table [ i ] ) ) { return i ; } } return - _ NUM ; }
private static  Bitmap transform ( @  Non Null final  Matrix scaler , @  Non Null final  Bitmap source , final int target Width , final int target Height , final int options ) { final boolean scale Up = ( options &  OPTIONS_ SCALE_ UP ) != _ NUM ; final boolean recycle = ( options &  OPTIONS_ RECYCLE_ INPUT ) != _ NUM ; int delta X = source . get Width ( ) - target Width ; int delta Y = source . get Height ( ) - target Height ; if ( ! scale Up && ( delta X < _ NUM || delta Y < _ NUM ) ) {  Bitmap b2 =  Bitmap . create Bitmap ( target Width , target Height ,  Bitmap .  Config .  ARGB_8888 ) ;  Canvas c = new  Canvas ( b2 ) ; int delta XHalf =  Math . max ( _ NUM , delta X / _ NUM ) ; int delta YHalf =  Math . max ( _ NUM , delta Y / _ NUM ) ; final  Rect src = new  Rect ( delta XHalf , delta YHalf , delta XHalf +  Math . min ( target Width , source . get Width ( ) ) , delta YHalf +  Math . min ( target Height , source . get Height ( ) ) ) ; int dst X = ( target Width - src . width ( ) ) / _ NUM ; int dst Y = ( target Height - src . height ( ) ) / _ NUM ; final  Rect dst = new  Rect ( dst X , dst Y , target Width - dst X , target Height - dst Y ) ; c . draw Bitmap ( source , src , dst , null ) ; if ( recycle ) { source . recycle ( ) ; } c . set Bitmap ( null ) ; return b2 ; } float bitmap Width F = source . get Width ( ) ; float bitmap Height F = source . get Height ( ) ; float bitmap Aspect = bitmap Width F / bitmap Height F ; float view Aspect = ( float ) target Width / target Height ;  Matrix scaler Matrix = scaler ; if ( bitmap Aspect > view Aspect ) { float scale = target Height / bitmap Height F ; if ( scale < _ NUM || scale > _ NUM ) { scaler . set Scale ( scale , scale ) ; } else { scaler Matrix = null ; } } else { float scale = target Width / bitmap Width F ; if ( scale < _ NUM || scale > _ NUM ) { scaler . set Scale ( scale , scale ) ; } else { scaler Matrix = null ; } } final  Bitmap b1 ; if ( scaler Matrix != null ) { b1 =  Bitmap . create Bitmap ( source , _ NUM , _ NUM , source . get Width ( ) , source . get Height ( ) , scaler Matrix , _ BOOL ) ; } else { b1 = source ; } if ( recycle && b1 != source ) { source . recycle ( ) ; } final int dx1 =  Math . max ( _ NUM , b1 . get Width ( ) - target Width ) ; final int dy1 =  Math . max ( _ NUM , b1 . get Height ( ) - target Height ) ; final  Bitmap b2 =  Bitmap . create Bitmap ( b1 , dx1 / _ NUM , dy1 / _ NUM , target Width , target Height ) ; if ( b2 != b1 ) { if ( recycle || b1 != source ) { b1 . recycle ( ) ; } } return b2 ; }
private void score Waypoint Results (  Collection <  Waypoint > waypoints ,  Search Query query ,  Collection <  Scored Result > output ) { for (  Waypoint waypoint : waypoints ) { double score = score Waypoint Result ( query , waypoint ) ; output . add ( new  Scored Result ( waypoint , score ) ) ; } }
private static void call Timeout Tasks ( ) { if ( timeout Task Log . is Loggable (  Platform Logger .  Level .  FINER ) ) { timeout Task Log . finer ( _ STR + _ STR ,  Long . value Of (  System . current Time Millis ( ) ) , timeout Tasks ) ; } if ( timeout Tasks == null || timeout Tasks . is Empty ( ) ) { return ; }  Long current Time =  Long . value Of (  System . current Time Millis ( ) ) ;  Long time = (  Long ) timeout Tasks . first Key ( ) ; while ( time . compare To ( current Time ) <= _ NUM ) { java . util .  List tasks = ( java . util .  List ) timeout Tasks . remove ( time ) ; for (  Iterator iter = tasks . iterator ( ) ; iter . has Next ( ) ; ) {  Runnable task = (  Runnable ) iter . next ( ) ; if ( timeout Task Log . is Loggable (  Platform Logger .  Level .  FINER ) ) { timeout Task Log . finer ( _ STR + _ STR ,  Long . value Of ( current Time ) , task ) ; } try { task . run ( ) ; } catch (  Thread Death td ) { throw td ; } catch (  Throwable thr ) { process Exception ( thr ) ; } } if ( timeout Tasks . is Empty ( ) ) { break ; } time = (  Long ) timeout Tasks . first Key ( ) ; } }
public void test Int Conversion And Ordering ( ) throws  Exception {  Bytes Ref previous = null ;  Bytes Ref current = new  Bytes Ref ( new byte [  Integer .  BYTES ] ) ; for ( int value = - _ NUM ; value < _ NUM ; value ++ ) {  Numeric Utils . int To Sortable Bytes ( value , current . bytes , current . offset ) ; if ( previous == null ) { previous = new  Bytes Ref ( new byte [  Integer .  BYTES ] ) ; } else { assert True ( _ STR , previous . compare To ( current ) < _ NUM ) ; } assert Equals ( _ STR , value ,  Numeric Utils . sortable Bytes To Int ( current . bytes , current . offset ) ) ;  System . arraycopy ( current . bytes , current . offset , previous . bytes , previous . offset , current . length ) ; } }
public static void put Object Volatile (  Object obj , long off ,  Object val ) {  UNSAFE . put Object Volatile ( obj , off , val ) ; }
public void filled Circle ( double x , double y , double r ) { if ( r < _ NUM ) throw new  Illegal Argument Exception ( _ STR ) ; double xs = scale X ( x ) ; double ys = scale Y ( y ) ; double ws = factor X ( _ NUM * r ) ; double hs = factor Y ( _ NUM * r ) ; if ( ws <= _ NUM && hs <= _ NUM ) pixel ( x , y ) ; else offscreen . fill ( new  Ellipse2 D .  Double ( xs - ws / _ NUM , ys - hs / _ NUM , ws , hs ) ) ; draw ( ) ; }
final public void println ( int v ) {  Writer out = this . out ; if ( out == null ) return ; print ( v ) ; try { out . write ( _newline , _ NUM , _newline . length ) ; } catch (  IOException e ) { log . log (  Level .  FINE , e . to String ( ) , e ) ; } }
public void write UI32 ( long value ) throws  IOException { flush Bits ( ) ; out . write ( ( int ) ( value & _ NUM ) ) ; out . write ( ( int ) ( value > > _ NUM ) ) ; out . write ( ( int ) ( value > > _ NUM ) ) ; out . write ( ( int ) ( value > > _ NUM ) ) ; bytes Written += _ NUM ; }
private static  String quote (  String value ) { boolean needs Quotes = _ BOOL ; int length = value . length ( ) ; for ( int i = _ NUM ; ( i < length ) && ! needs Quotes ; ++ i ) { needs Quotes = ! is Token Char ( value . char At ( i ) ) ; } if ( needs Quotes ) {  String Builder buffer = new  String Builder ( ( int ) ( length * _ NUM ) ) ; buffer . append ( _ STR ) ; for ( int i = _ NUM ; i < length ; ++ i ) { char c = value . char At ( i ) ; if ( ( c == _ STR ) || ( c == _ STR ) ) { buffer . append ( _ STR ) ; } buffer . append ( c ) ; } buffer . append ( _ STR ) ; return buffer . to String ( ) ; } else { return value ; } }
public void add Doc Validate (  String table Name ,  Model Validator listener ) { if ( table Name == null || listener == null ) return ;  String property Name = m_global Validators . contains ( listener ) ? table Name + _ STR : table Name + listener . get AD_ Client_ ID ( ) ;  Array List <  Model Validator > list = (  Array List <  Model Validator > ) m_doc Validate Listeners . get ( property Name ) ; if ( list == null ) { list = new  Array List <  Model Validator > ( ) ; list . add ( listener ) ; m_doc Validate Listeners . put ( property Name , list ) ; } else if ( ! list . contains ( listener ) ) { list . add ( listener ) ; } }
public  Instances string Free Structure ( ) {  Array List <  Attribute > new Atts = new  Array List <  Attribute > ( ) ; for (  Attribute att : m_ Attributes ) { if ( att . type ( ) ==  Attribute .  STRING ) { new Atts . add ( new  Attribute ( att . name ( ) , (  List <  String > ) null , att . index ( ) ) ) ; } else if ( att . type ( ) ==  Attribute .  RELATIONAL ) { new Atts . add ( new  Attribute ( att . name ( ) , new  Instances ( att . relation ( ) , _ NUM ) , att . index ( ) ) ) ; } } if ( new Atts . size ( ) == _ NUM ) { return new  Instances ( this , _ NUM ) ; }  Array List <  Attribute > atts =  Utils . cast ( m_ Attributes . clone ( ) ) ; for (  Attribute att : new Atts ) { atts . set ( att . index ( ) , att ) ; }  Instances result = new  Instances ( this , _ NUM ) ; result . m_ Attributes = atts ; return result ; }
public void collect And Set Properties ( ) { if ( property Consumer != null ) {  String prefix = property Consumer . get Property Prefix ( ) ;  Properties props = collect Properties ( ) ; property Consumer . set Properties ( prefix , props ) ; } }
public void copy Header (  Input Stream in ,  Output Stream out ) throws  IOException {  Buffered Input Stream is = new  Buffered Input Stream ( in ) ; byte [ ] buf = new byte [ _ NUM * _ NUM ] ; int bytes Read ; while ( ( bytes Read = is . read ( buf ) ) != - _ NUM ) { out . write ( buf , _ NUM , bytes Read ) ; } }
private static  Date read Date (  Data Input data Input ) throws  IOException { if ( data Input . read Int ( ) != _ NUM ) { throw new  Illegal State Exception ( _ STR ) ; } byte [ ] buffer = new byte [ _ NUM ] ; data Input . read Fully ( buffer ) ; return unpack Date ( buffer ) ; }
Collection <  Var > outputs ( boolean pack ) { if ( pack ) {  Set <  Var > groupby_outputs =  Sets . new Hash Set ( outputs ) ; groupby_outputs . remove All ( aggregate ) ; groupby_outputs . add All ( groupby ) ; return groupby_outputs ; } else { return groupby ; } }
public boolean has Update Listeners ( ) { boolean is Empty = ! listeners . is Empty ( ) ; return is Empty ; }
protected  Client load Client (  String client Type ) {  Client client = null ; long st = current Time Millis ( ) ;  Map i Map = load Internal Client ( client Type ) ;  Map e Map = load External Client ( client Type ) ; if ( ( i Map == null ) && ( e Map == null ) ) { return client ; }  Map merged Map = merge Map ( i Map , e Map ) ;  String ct = client Type ;  String parent ID = get Parent ID ( merged Map ) ;  Ordered Set os = new  Ordered Set ( ) ; while ( ( parent ID != null ) && ( ! ( ct . equals ( parent ID ) ) ) ) { os . add ( parent ID ) ;  Map p Map = load Internal Client ( parent ID ) ; if ( p Map == null ) { break ; } else { merged Map = merge Map ( p Map , merged Map ) ; ct = get Client Type ( p Map ) ; parent ID = get Parent ID ( p Map ) ; } } if ( os . size ( ) > _ NUM ) { merged Map . put (  PARENT_ ID , os ) ; } merged Client Data . put ( client Type , merged Map ) ; client = new  Client ( client Type , merged Map ) ; loaded Clients Map . put ( client Type , client ) ; long end = current Time Millis ( ) ; if ( debug . message Enabled ( ) ) { debug . message (  CLASS + _ STR + client Type + _ STR + ( end - st ) ) ; } return client ; }
public static boolean can Function (  Tile Entity tile Entity ) { if ( ! ( tile Entity instanceof  IRedstone Control ) ) { return _ BOOL ; }  IRedstone Control control = (  IRedstone Control ) tile Entity ; switch ( control . get Control Type ( ) ) { case  DISABLED : return _ BOOL ; case  HIGH : return control . is Powered ( ) ; case  LOW : return ! control . is Powered ( ) ; case  PULSE : return control . is Powered ( ) && ! control . was Powered ( ) ; } return _ BOOL ; }
public  Add On Changes Result calculate Update Changes (  Add On add On ) {  Set <  Add On > add Ons = new  Hash Set < > ( ) ; add Ons . add ( add On ) ; return calculate Update Changes ( add Ons ) ; }
private void rederive Color ( ) {  Color src =  UIManager . get Color ( ui Default Parent Name ) ; if ( src != null ) { float [ ] tmp =  Color .  RGBto HSB ( src . get Red ( ) , src . get Green ( ) , src . get Blue ( ) , null ) ; tmp [ _ NUM ] = clamp ( tmp [ _ NUM ] + h Offset ) ; tmp [ _ NUM ] = clamp ( tmp [ _ NUM ] + s Offset ) ; tmp [ _ NUM ] = clamp ( tmp [ _ NUM ] + b Offset ) ; int alpha = clamp ( src . get Alpha ( ) + a Offset ) ; argb Value = (  Color .  HSBto RGB ( tmp [ _ NUM ] , tmp [ _ NUM ] , tmp [ _ NUM ] ) & _ NUM ) | ( alpha << _ NUM ) ; } else { float [ ] tmp = new float [ _ NUM ] ; tmp [ _ NUM ] = clamp ( h Offset ) ; tmp [ _ NUM ] = clamp ( s Offset ) ; tmp [ _ NUM ] = clamp ( b Offset ) ; int alpha = clamp ( a Offset ) ; argb Value = (  Color .  HSBto RGB ( tmp [ _ NUM ] , tmp [ _ NUM ] , tmp [ _ NUM ] ) & _ NUM ) | ( alpha << _ NUM ) ; } }
private boolean do Start ( ) { if ( ! _lifecycle . is Active ( ) ) { return _ BOOL ; } if ( ! is Enable ( ) ) { return _ BOOL ; } int starting Count = _starting Count . get ( ) ; int thread Count = _thread Count . get ( ) + starting Count ; if ( _thread Max < thread Count ) { on Thread Max ( ) ; return _ BOOL ; } else if ( ! is Idle Too Low ( starting Count ) ) { return _ BOOL ; } _idle Count . increment And Get ( ) ; start Connection ( ) ; return _ BOOL ; }
private void add Span (  Cache Span span ) {  Tree Set <  Cache Span > spans For Key = cached Spans . get ( span . key ) ; if ( spans For Key == null ) { spans For Key = new  Tree Set < > ( ) ; cached Spans . put ( span . key , spans For Key ) ; } spans For Key . add ( span ) ; total Space += span . length ; notify Span Added ( span ) ; }
@  Override public boolean equals (  Object obj ) { if ( ! ( obj instanceof  Xml Namespace ) ) { return _ BOOL ; }  Xml Namespace other = (  Xml Namespace ) obj ; if ( alias == null ) { return ( other . alias == null ) && uri . equals ( other . uri ) ; } else { return alias . equals ( other . alias ) && uri . equals ( other . uri ) ; } }
public static  Set <  Window > update UI ( ) {  Set <  Window > updated = new  Hash Set <  Window > ( ) ; for (  Container c : s_windows ) {  Window w = get Frame ( c ) ; if ( w == null ) continue ; if ( updated . contains ( w ) ) continue ;  Swing Utilities . update Component Tree UI ( w ) ; w . validate ( ) ;  Repaint Manager mgr =  Repaint Manager . current Manager ( w ) ;  Component childs [ ] = w . get Components ( ) ; for (  Component child : childs ) { if ( child instanceof  JComponent ) mgr . mark Completely Dirty ( (  JComponent ) child ) ; } w . repaint ( ) ; updated . add ( w ) ; } for (  Window w : s_hidden Windows ) { if ( updated . contains ( w ) ) continue ;  Swing Utilities . update Component Tree UI ( w ) ; w . validate ( ) ;  Repaint Manager mgr =  Repaint Manager . current Manager ( w ) ;  Component childs [ ] = w . get Components ( ) ; for (  Component child : childs ) { if ( child instanceof  JComponent ) mgr . mark Completely Dirty ( (  JComponent ) child ) ; } w . repaint ( ) ; updated . add ( w ) ; } return updated ; }
private  String match (  Pattern re ) { if ( index >= input . length ( ) ) { return null ; }  Matcher matcher = re . matcher ( input ) ; matcher . region ( index , input . length ( ) ) ; boolean m = matcher . find ( ) ; if ( m ) { index = matcher . end ( ) ; return matcher . group ( ) ; } else { return null ; } }
public static int count Argument Placeholders ( final  String message Pattern ) { if ( message Pattern == null ) { return _ NUM ; } final int delim = message Pattern . index Of (  DELIM_ START ) ; if ( delim == - _ NUM ) { return _ NUM ; } int result = _ NUM ; boolean is Escaped = _ BOOL ; for ( int i = _ NUM ; i < message Pattern . length ( ) ; i ++ ) { final char cur Char = message Pattern . char At ( i ) ; if ( cur Char ==  ESCAPE_ CHAR ) { is Escaped = ! is Escaped ; } else if ( cur Char ==  DELIM_ START ) { if ( ! is Escaped && i < message Pattern . length ( ) - _ NUM && message Pattern . char At ( i + _ NUM ) ==  DELIM_ STOP ) { result ++ ; i ++ ; } is Escaped = _ BOOL ; } else { is Escaped = _ BOOL ; } } return result ; }
public static  String format Reddit Url (  String url ) { url = url . replace First ( _ STR , _ STR ) ; if ( url . matches ( _ STR ) ) {  String subdomain = url . split ( _ STR , _ NUM ) [ _ NUM ] ;  String domain Regex = _ STR + subdomain + _ STR ; if ( subdomain . equals Ignore Case ( _ STR ) ) { url = url . replace First ( domain Regex , _ STR ) ; url = _ STR + url ; } else if ( subdomain . matches ( _ STR ) ) { return _ STR ; } else if ( subdomain . matches ( _ STR ) ) { url = url . replace First ( domain Regex , _ STR ) ; } else { url = url . replace First ( domain Regex , _ STR + subdomain ) ; } } if ( url . starts With ( _ STR ) ) url = _ STR + url ; if ( url . ends With ( _ STR ) ) url = url . substring ( _ NUM , url . length ( ) - _ NUM ) ; if ( url . matches ( _ STR ) ) { url = url . replace First ( _ STR , _ STR ) ; } return url ; }
public static  String extract CSVOutput Line Freq (  String csv Out ) {  String tokens [ ] = csv Out . split ( _ STR , - _ NUM ) ; return tokens [ _ NUM ] ; }
public void connect (  Ln Traffic Controller t ) { t . add Loco Net Listener ( ~ _ NUM , this ) ; }
@  Suppress Warnings ( _ STR ) public static boolean check ETag Validators ( final  Http Servlet Request req , final  Http Servlet Response resp , final  Method req Method , final  String etag ) { final  List <  String > if None Match List =  Collections . list ( req . get Headers ( _ STR ) ) ; if ( if None Match List . size ( ) > _ NUM && is Matching Etag ( if None Match List , etag ) ) { if ( req Method ==  Method .  GET || req Method ==  Method .  HEAD ) { send Not Modified ( resp ) ; } else { send Precondition Failed ( resp ) ; } return _ BOOL ; } final  List <  String > if Match List =  Collections . list ( req . get Headers ( _ STR ) ) ; if ( if Match List . size ( ) > _ NUM && ! is Matching Etag ( if Match List , etag ) ) { send Precondition Failed ( resp ) ; return _ BOOL ; } return _ BOOL ; }
public  List <  Ivr Zone > show Active Ivr Zone ( ) throws  Network Device Controller Exception { return show Ivr Zones ( _ BOOL ) ; }
@  Suppress Warnings ( _ STR ) public static <  K >  Immutable Array3 <  K > empty ( ) { return (  Immutable Array3 <  K > )  EMPTY ; }
void place At Position ( final  IGroup Member Node node , final  Integer position To Place ) { if ( position To Place == null ) { non Optional Non Minus Nodes . add Last ( node ) ; } else { non Optional Non Minus Nodes . add ( position To Place , node ) ; } }
void reapply Breakpoints ( ) { int count = breakpoint Count ( ) ; for ( int i = _ NUM ; i < count ; i ++ ) {  Break Action a = breakpoint At ( i ) ; a . clear Hits ( ) ; a . set Status (  Break Action .  UNRESOLVED ) ; }  String Builder sb = new  String Builder ( ) ; resolve Breakpoints ( sb ) ; out ( sb . to String ( ) ) ; }
private static int member Value Hash Code (  Object value ) {  Class < ? > type = value . get Class ( ) ; if ( ! type . is Array ( ) ) return value . hash Code ( ) ; if ( type == byte [ ] . class ) return  Arrays . hash Code ( ( byte [ ] ) value ) ; if ( type == char [ ] . class ) return  Arrays . hash Code ( ( char [ ] ) value ) ; if ( type == double [ ] . class ) return  Arrays . hash Code ( ( double [ ] ) value ) ; if ( type == float [ ] . class ) return  Arrays . hash Code ( ( float [ ] ) value ) ; if ( type == int [ ] . class ) return  Arrays . hash Code ( ( int [ ] ) value ) ; if ( type == long [ ] . class ) return  Arrays . hash Code ( ( long [ ] ) value ) ; if ( type == short [ ] . class ) return  Arrays . hash Code ( ( short [ ] ) value ) ; if ( type == boolean [ ] . class ) return  Arrays . hash Code ( ( boolean [ ] ) value ) ; return  Arrays . hash Code ( (  Object [ ] ) value ) ; }
public boolean delete Edge Reference (  Atlas Edge edge ,  Data Types .  Type Category type Category , boolean is Composite , boolean force Delete Struct Trait ) throws  Atlas Exception {  LOG . debug ( _ STR , string ( edge ) ) ; boolean force Delete = ( type Category ==  Data Types .  Type Category .  STRUCT || type Category ==  Data Types .  Type Category .  TRAIT ) ? force Delete Struct Trait : _ BOOL ; if ( type Category ==  Data Types .  Type Category .  STRUCT || type Category ==  Data Types .  Type Category .  TRAIT || ( type Category ==  Data Types .  Type Category .  CLASS && is Composite ) ) {  Atlas Vertex vertex For Delete = edge . get In Vertex ( ) ; delete Edge ( edge , _ BOOL , force Delete ) ; delete Type Vertex ( vertex For Delete , type Category , force Delete ) ; } else { delete Edge ( edge , _ BOOL , _ BOOL ) ; } return ! soft Delete || force Delete ; }
private static  List <  String > read Lines (  Reader in ) throws  IOException {  List <  String > lines = new  Array List < > ( ) ; try {  Buffered Reader bin = new  Buffered Reader ( in ) ; for (  String line = null ; ( line = bin . read Line ( ) ) != null ; lines . add ( line ) ) { } } finally { if ( in != null ) { try { in . close ( ) ; } catch (  IOException var2 ) { } } } return lines ; }
@  Method Desc ( description = _ STR , usage = _ STR ) public  Map <  String ,  String > replicator Status ( @  Param Desc ( name = _ STR , description = _ STR )  String name ) throws  Exception {  Open Replicator Manager MBean mgr = replicators . get ( name ) ; if ( mgr == null ) { throw new  Exception (  String . format ( _ STR , name ) ) ; } return mgr . status ( ) ; }
public static  String canonical Class Name (  Class < ? > c ,  Package pkg ,  String postfix ) {  String name = c . get Name ( ) ; if ( pkg != null ) {  String prefix = pkg . get Name ( ) + _ STR ; if ( name . starts With ( prefix ) ) { name = name . substring ( prefix . length ( ) ) ; } } if ( postfix != null && name . ends With ( postfix ) ) { name = name . substring ( _ NUM , name . length ( ) - postfix . length ( ) ) ; } return name ; }
@  Override public final int compare To (  Term other ) { if ( field . equals ( other . field ) ) { return bytes . compare To ( other . bytes ) ; } else { return field . compare To ( other . field ) ; } }
@  Override public boolean is Modified ( ) { long now =  Current Time . current Time ( ) ; long last Check Time = _last Check Time . get ( ) ; if ( now <= last Check Time + _check Interval ) { return _is Modified ; } if ( ! _last Check Time . compare And Set ( last Check Time , now ) ) { return _is Modified ; } if ( is Modified Impl ( ) ) { _is Modified = _ BOOL ; } else { _is Modified = _ BOOL ; } return _is Modified ; }
protected void store Image Replaced Element (  Element e ,  Replaced Element cc ,  String uri , final int css Width , final int css Height ) { if ( image Components == null ) { image Components = new  Hash Map ( ) ; }  Cache Key key = new  Cache Key ( e , uri , css Width , css Height ) ; image Components . put ( key , cc ) ; }
public boolean is Version Valid (  String version ) { if ( from Version != null && version != null ) { if ( version . compare To ( from Version ) < _ NUM ) { return _ BOOL ; } } if ( to Version != null ) { if ( version == null || version . compare To ( to Version ) >= _ NUM ) { return _ BOOL ; } } return _ BOOL ; }
@  Override public  Connection Pool Data Source create Connection Pool Data Source (  Properties properties ) throws  SQLException {  Properties properties Copy = new  Properties ( ) ; if ( properties != null ) { properties Copy . put All ( properties ) ; } reject Unsupported Options ( properties Copy ) ; reject Pooling Options ( properties Copy ) ;  Jdbc Data Source data Source = new  Jdbc Data Source ( ) ; setup H2 Data Source ( data Source , properties Copy ) ; return data Source ; }
static <  T >  T field Is Present (  Optional <  T > object ,  String name ) { if ( ! object . is Present ( ) ) { throw new  Missing Field ( name , _ STR ) ; } return object . get ( ) ; }
private void snap In Center ( ) { final  View Item current Item = m View Item [ m Current Item ] ; final int current View Center = current Item . get Center X ( ) ; if ( m Controller . is Scrolling ( ) || m Is User Scrolling || m Center X == current View Center ) { return ; } int snap In Time = ( int ) (  SNAP_ IN_ CENTER_ TIME_ MS * ( ( float )  Math . abs ( m Center X - current View Center ) ) / m Draw Area . width ( ) ) ; m Controller . scroll To Position ( current View Center , snap In Time , _ BOOL ) ; if ( get Current View Type ( ) ==  Image Data .  VIEW_ TYPE_ STICKY && ! m Controller . is Scaling ( ) && m Scale !=  FULL_ SCREEN_ SCALE ) { m Controller . go To Full Screen ( ) ; } }
public void delete Meta Object ( int index ) {  Meta Objects . set ( index , null ) ; }
public void remove Addendum (  String word ,  String part Of Speech ) { addenda . remove ( word + fix Part Of Speech ( part Of Speech ) ) ; }
public synchronized void remove Recent Item (  T item ) { item = from String ( to String ( item ) ) ; m_ Recent Items . remove ( item ) ; if ( m_ Ignore Changes ) return ; write Props ( ) ; update Menu ( ) ; }
public void test Timed Invoke All3 ( ) throws  Interrupted Exception {  Executor Service e = new  Fork Join Pool ( _ NUM ) ;  Pool Cleaner cleaner = null ; try { cleaner = cleaner ( e ) ;  List <  Callable <  String > > l = new  Array List <  Callable <  String > > ( ) ; l . add ( new  String Task ( ) ) ; l . add ( null ) ; try { e . invoke All ( l ,  MEDIUM_ DELAY_ MS ,  MILLISECONDS ) ; should Throw ( ) ; } catch (  Null Pointer Exception success ) { } } finally { if ( cleaner != null ) { cleaner . close ( ) ; } } }
public static  Method find Super Class Method (  Class clazz ,  String name ,  String desc ) {  Method m = find Super Method2 ( clazz . get Superclass ( ) , name , desc ) ; if ( m == null ) m = search Interfaces ( clazz , name , desc ) ; if ( m == null ) error ( clazz , name , desc ) ; return m ; }
@  Override public void close ( ) throws  IOException {  Input Stream input = m_streams . get ( ) ; if ( null != input ) { input . close ( ) ; } }
private void create Block Snapshot Data (  String name , int num Snapshots ) throws  Exception {  Volume volume = new  Volume ( ) ;  URI volume URI =  URIUtil . create Id (  Volume . class ) ; test Volume URIs . add ( volume URI ) ; volume . set Id ( volume URI ) ;  String vol Name = _ STR ; volume . set Label ( vol Name ) ;  URI cg Uri = create Block Consistency Group ( vol Name + _ STR ) ; volume . set Consistency Group ( cg Uri ) ; _db Client . create Object ( volume ) ; for ( int i = _ NUM ; i <= num Snapshots ; i ++ ) {  Block Snapshot block Snapshot = new  Block Snapshot ( ) ;  URI block Snapshot URI =  URIUtil . create Id (  Block Snapshot . class ) ; test Block Snapshot URIs . add ( block Snapshot URI ) ; block Snapshot . set Id ( block Snapshot URI ) ; block Snapshot . set Label ( name + i ) ; block Snapshot . set Snapset Label ( name + i ) ; block Snapshot . set Parent ( new  Named URI ( volume . get Id ( ) , name + i ) ) ; block Snapshot . set Consistency Group ( cg Uri ) ; _db Client . create Object ( block Snapshot ) ;  Block Snapshot query Snap = _db Client . query Object (  Block Snapshot . class , block Snapshot URI ) ; } }
@  Override public synchronized void stop ( ) { if ( running ) {  LOGGER . info ( _ STR ) ; for (  Endpoint ep : endpoints ) { ep . stop ( ) ; } running = _ BOOL ; } }
public  Json Array add (  String value ) { values . add ( value Of ( value ) ) ; return this ; }
public boolean retain All (  Abstract Long List other ) { if ( other . size ( ) == _ NUM ) { if ( size == _ NUM ) return _ BOOL ; set Size ( _ NUM ) ; return _ BOOL ; } int limit = other . size ( ) - _ NUM ; int j = _ NUM ; for ( int i = _ NUM ; i < size ; i ++ ) { if ( other . index Of From To ( get Quick ( i ) , _ NUM , limit ) >= _ NUM ) set Quick ( j ++ , get Quick ( i ) ) ; } boolean modified = ( j != size ) ; set Size ( j ) ; return modified ; }
private static final byte [ ] hash ( final byte [ ] value ) throws  No Such Algorithm Exception {  Message Digest md =  Message Digest . get Instance ( _ STR ) ; md . reset ( ) ; md . update ( value ) ; return md . digest ( ) ; }
public static  String explode (  Collection <  String > collection ,  String delimiter ) {  String Builder sb = new  String Builder ( ) ; if ( ! collection . is Empty ( ) ) {  Iterator <  String > i = collection . iterator ( ) ; sb . append ( i . next ( ) ) ; while ( i . has Next ( ) ) { sb . append ( delimiter ) ; sb . append ( i . next ( ) ) ; } } return sb . to String ( ) ; }
public static int between ( int val , int min , int max ) { return  Math . max (  Math . min ( val , max ) , min ) ; }
private static void encode Patterns (  IPath [ ] patterns ,  String tag ,  Map parameters ) { if ( patterns != null && patterns . length > _ NUM ) {  String Buffer rule = new  String Buffer ( _ NUM ) ; for ( int i = _ NUM , max = patterns . length ; i < max ; i ++ ) { if ( i > _ NUM ) rule . append ( _ STR ) ; rule . append ( patterns [ i ] ) ; } parameters . put ( tag ,  String . value Of ( rule ) ) ; } }
static void append Lang Item (  XMPNode array Node ,  String item Lang ,  String item Value ) throws  XMPException {  XMPNode new Item = new  XMPNode (  ARRAY_ ITEM_ NAME , item Value , null ) ;  XMPNode lang Qual = new  XMPNode (  XML_ LANG , item Lang , null ) ; new Item . add Qualifier ( lang Qual ) ; if ( !  X_ DEFAULT . equals ( lang Qual . get Value ( ) ) ) { array Node . add Child ( new Item ) ; } else { array Node . add Child ( _ NUM , new Item ) ; } }
public boolean is Discard If File Altered (  String frame ID ) { return discard If File Altered Frames . contains ( frame ID ) ; }
public  String [ ] parse Configuration (  URL xml URL ) throws  IOException ,  SAXException {  Input Stream is = xml URL . open Stream ( ) ;  Document document = null ; try { document = builder . parse ( is ) ; } finally { is . close ( ) ; } return ( parse Configuration ( document ) ) ; }
public double empirical HSIC (  Tetrad Matrix  Ky ,  Tetrad Matrix  Kx , int m ) {  Tetrad Matrix  Kyx =  Ky . times (  Kx ) ; double emp HSIC = _ NUM ; for ( int i = _ NUM ; i < m ; i ++ ) { emp HSIC +=  Kyx . get ( i , i ) ; } emp HSIC /=  Math . pow ( m - _ NUM , _ NUM ) ; return emp HSIC ; }
public void write (  String file Name ) throws  IOException {  File Output Stream output File ; byte profile Data [ ] ; profile Data = get Data ( ) ; output File = new  File Output Stream ( file Name ) ; output File . write ( profile Data ) ; output File . close ( ) ; }
void send Audio Events (  Object event ,  List listeners ) { if ( ( listeners == null ) || ( listeners . size ( ) == _ NUM ) ) { return ; } start ( ) ;  Event Info event Info = new  Event Info ( event , listeners ) ; post Event ( event Info ) ; }
private void compose Page JPG (  File output File ) throws  Exception {  File file Memory Block JPG = null ;  Buffered Image image Blocks = new  Buffered Image ( memory Width , memory Height ,  Buffered Image .  TYPE_ INT_ RGB ) ;  Graphics graphics = image Blocks . get Graphics ( ) ;  Buffered Image image = null ; for ( int i = memory Block Processed ; i < memory Block Total ; i ++ ) { file Memory Block JPG = new  File ( path , prefix + _ STR + i + _ STR ) ; image =  Image IO . read ( file Memory Block JPG ) ; graphics . draw Image (  Image IO . read ( file Memory Block JPG ) , _ NUM , memory Row , null ) ; file Memory Block JPG . delete ( ) ; memory Row += image . get Height ( ) ; } image Blocks . flush ( ) ; graphics . dispose ( ) ; num Page ++ ;  Image IO . write ( image Blocks , _ STR , output File ) ; add Temp File ( output File ) ; add Scan File ( output File ) ; }
private  CSVParser (  String path ,  Charset encoding ) throws  IOException { this (  Paths . get ( path ) , encoding ) ; }
protected boolean attach Input (  Input Stream is ) { boolean is Ofx1 = _ BOOL ; boolean result = _ BOOL ; try {  Buffered Reader reader = new  Buffered Reader ( new  Input Stream Reader ( is ) ) ; reader . mark (  HEADER_ SIZE + _ NUM ) ;  String header = _ STR ; for ( int i = _ NUM ; i <  HEADER_ SIZE ; i ++ ) { header = header + reader . read Line ( ) ; } if ( ( header . index Of ( _ STR ) != - _ NUM ) || ( header . index Of ( _ STR ) != - _ NUM ) ) { is Ofx1 = _ BOOL ; } else if ( ( header . index Of ( _ STR ) != - _ NUM ) || ( header . index Of ( _ STR ) != - _ NUM ) ) { is Ofx1 = _ BOOL ; } else { is Ofx1 = _ BOOL ; } reader . reset ( ) ; if ( is Ofx1 ) { m_reader = new  Buffered Reader ( new  Input Stream Reader ( new  OFX1 To XML ( reader ) ) ) ; } else { m_reader = reader ; } result = _ BOOL ; } catch (  IOException e ) { m_error Message = _ STR ; m_error Description = e . get Message ( ) ; return result ; } return result ; }
private void load Default Exclude Pattern ( final  String src Folder ) { if ( build Tool Name . equals Ignore Case ( _ STR ) ) { ignore File =  Ignore File . load ( src Folder ,  JDK_ IGNORE_ PATTERN ) ; } else if ( build Tool Name . equals Ignore Case ( _ STR ) ) { ignore File =  Ignore File . load ( src Folder ,  ANT_ IGNORE_ PATTERN ) ; } }
public void add Arg If Absent ( final  BOp arg ) { if ( arg == null ) throw new  Illegal Argument Exception ( ) ; if ( arg == this ) throw new  Illegal Argument Exception ( ) ; if ( ! args . contains ( arg ) ) { add Arg ( arg ) ; } }
private static int length Of Mime Names (  String val ) { int len = val . index Of ( _ STR ) ; if ( len < _ NUM ) len = val . length ( ) ; return len ; }
private void add Manifest Package (  String name ,  Attributes attr ) { if ( ! name . ends With ( _ STR ) && ! name . equals ( _ STR ) ) return ;  String spec Title = attr . get Value ( _ STR ) ;  String spec Version = attr . get Value ( _ STR ) ;  String spec Vendor = attr . get Value ( _ STR ) ;  String impl Title = attr . get Value ( _ STR ) ;  String impl Version = attr . get Value ( _ STR ) ;  String impl Vendor = attr . get Value ( _ STR ) ; if ( spec Title == null && spec Version == null && spec Vendor != null && impl Title == null && impl Version == null && impl Vendor != null ) return ;  Class Package pkg = new  Class Package ( name ) ; pkg . set Specification Title ( spec Title ) ; pkg . set Specification Version ( spec Version ) ; pkg . set Specification Vendor ( spec Vendor ) ; pkg . set Implementation Title ( impl Title ) ; pkg . set Implementation Version ( impl Version ) ; pkg . set Implementation Vendor ( impl Vendor ) ; _packages . add ( pkg ) ; }
public int update Note (  Note note ) {  SQLite Database db = get Writable Database ( ) ;  String spannable As Html =  Html . to Html ( note . get Spannable ( ) ) ;  String date = dt . format ( new  Date ( ) ) ;  Content Values values = new  Content Values ( ) ; values . put (  KEY_ IMAGE ,  Bitmap Converter . get Bytes ( note . get Image ( ) ) ) ; values . put (  KEY_ DATE_ UPDATED , date ) ; values . put (  KEY_ SPANNABLE_ NOTE , spannable As Html ) ; values . put (  KEY_ NOTE_ TITLE , note . get Title ( ) ) ; return db . update (  TABLE_ NOTES , values ,  KEY_ ID + _ STR , new  String [ ] {  String . value Of ( note . get Id ( ) ) } ) ; }
void add Previous (  Node <  T > n ) { prev Nodes . add ( n ) ;  Collections . sort ( prev Nodes , is Vertical ? vertical Comparator : horizontal Comparator ) ; }
protected void options Dialog Property Change (  Property Change Event event ) { log . debug ( _ STR ) ; fire Property Change (  Property Change ID .  OPTION_ CHANGE , event . get Old Value ( ) , event . get New Value ( ) ) ; }
public static final java . lang .  String read UTF ( java . io .  Data Input in ) throws java . io .  IOException { return decode UTF ( in . read Unsigned Short ( ) , in ) ; }
public void test Drain To ( ) {  Linked Blocking Queue q = populated Queue (  SIZE ) ;  Array List l = new  Array List ( ) ; q . drain To ( l ) ; assert Equals ( q . size ( ) , _ NUM ) ; assert Equals ( l . size ( ) ,  SIZE ) ; for ( int i = _ NUM ; i <  SIZE ; ++ i ) assert Equals ( l . get ( i ) , new  Integer ( i ) ) ; q . add ( zero ) ; q . add ( one ) ; assert False ( q . is Empty ( ) ) ; assert True ( q . contains ( zero ) ) ; assert True ( q . contains ( one ) ) ; l . clear ( ) ; q . drain To ( l ) ; assert Equals ( q . size ( ) , _ NUM ) ; assert Equals ( l . size ( ) , _ NUM ) ; for ( int i = _ NUM ; i < _ NUM ; ++ i ) assert Equals ( l . get ( i ) , new  Integer ( i ) ) ; }
public static void disable Double Buffering (  Component c ) {  Repaint Manager current Manager =  Repaint Manager . current Manager ( c ) ; current Manager . set Double Buffering Enabled ( _ BOOL ) ; }
private  List <  VPlex Initiator Info > find Initiators On Cluster (  String cluster Name ,  List <  Port Info > initiator Port Info ,  List <  Port Info > unfound Initiator Port Info ) throws  VPlex Api Exception {  List <  VPlex Initiator Info > initiator Info List = new  Array List <  VPlex Initiator Info > ( ) ;  VPlex Api Discovery Manager discovery Mgr = _vplex Api Client . get Discovery Manager ( ) ;  List <  VPlex Initiator Info > cluster Initiator Info List = discovery Mgr . get Initiator Info For Cluster ( cluster Name ) ; for (  Port Info port Info : initiator Port Info ) {  String port WWN = port Info . get Port WWN ( ) ; for (  VPlex Initiator Info cluster Initiator Info : cluster Initiator Info List ) { if ( port WWN . equals ( cluster Initiator Info . get Port Wwn ( ) ) ) { initiator Info List . add ( cluster Initiator Info ) ; if ( unfound Initiator Port Info != null ) { unfound Initiator Port Info . remove ( port Info ) ; }  String port Name = port Info . get Name ( ) ; if ( ( port Name != null ) && ( port Name . length ( ) != _ NUM ) ) { cluster Initiator Info . set Registration Name ( port Name ) ; } else { cluster Initiator Info . set Registration Name (  VPlex Api Constants .  REGISTERED_ INITIATOR_ PREFIX + cluster Initiator Info . get Port Wwn Raw ( ) ) ; }  Initiator_ Type initiator Type =  Initiator_ Type . value Of Type ( port Info . get Type ( ) ) ; if ( initiator Type == null ) { s_logger . info ( _ STR , port Info . get Type ( ) ) ; initiator Type =  Initiator_ Type .  DEFAULT ; } cluster Initiator Info . set Initiator Type ( initiator Type ) ; break ; } } } return initiator Info List ; }
@  Visible For Testing public static boolean is Plaintext (  Buffer buffer ) throws  EOFException { try {  Buffer prefix = new  Buffer ( ) ; long byte Count = buffer . size ( ) < _ NUM ? buffer . size ( ) : _ NUM ; buffer . copy To ( prefix , _ NUM , byte Count ) ; for ( int i = _ NUM ; i < _ NUM ; i ++ ) { if ( prefix . exhausted ( ) ) { break ; } int code Point = prefix . read Utf8 Code Point ( ) ; if (  Character . is ISOControl ( code Point ) && !  Character . is Whitespace ( code Point ) ) { return _ BOOL ; } } return _ BOOL ; } catch (  EOFException e ) { return _ BOOL ; } }
@  Override public boolean e Is Set ( int feature ID ) { switch ( feature ID ) { case  Eip Package .  INVOCABLE_ ENDPOINT__ NAME : return  NAME_ EDEFAULT == null ? name != null : !  NAME_ EDEFAULT . equals ( name ) ; case  Eip Package .  INVOCABLE_ ENDPOINT__ TO_ CHANNELS : return to Channels != null && ! to Channels . is Empty ( ) ; case  Eip Package .  INVOCABLE_ ENDPOINT__ FROM_ CHANNELS : return from Channels != null && ! from Channels . is Empty ( ) ; case  Eip Package .  INVOCABLE_ ENDPOINT__ OWNED_ SERVICE_ INVOCATIONS : return owned Service Invocations != null && ! owned Service Invocations . is Empty ( ) ; } return super . e Is Set ( feature ID ) ; }
public void remove Section ( final  Section  SECTION ) { if ( null ==  SECTION ) return ; sections . remove (  SECTION ) ;  Collections . sort ( sections , new  Section Comparator ( ) ) ; fire Update Event (  SECTION_ EVENT ) ; }
public boolean process ( @  Not Null  Editor editor , @  Not Null  Psi File psi File ) { final  Caret Model caret Model = editor . get Caret Model ( ) ; final  Pair <  Javadoc Helper .  Javadoc Parameter Info ,  List <  Javadoc Helper .  Javadoc Parameter Info > > pair = my Helper . parse ( psi File , editor , caret Model . get Offset ( ) ) ; if ( pair . first == null ) { return _ BOOL ; } final  Javadoc Helper .  Javadoc Parameter Info next = find Next ( pair . second , pair . first ) ; if ( next == null ) { final int line = pair . first . last Line + _ NUM ; final  Document document = editor . get Document ( ) ; if ( line < document . get Line Count ( ) ) {  String Builder indent = new  String Builder ( ) ; boolean insert Indent = _ BOOL ; final  Char Sequence text = document . get Chars Sequence ( ) ; for ( int i = document . get Line Start Offset ( line ) , max = document . get Line End Offset ( line ) ; i < max ; i ++ ) { final char c = text . char At ( i ) ; if ( c == _ STR || c == _ STR ) { indent . append ( c ) ; continue ; } else if ( c == _ STR ) { indent . append ( _ STR ) ; if ( i < max - _ NUM && text . char At ( i + _ NUM ) != _ STR ) { insert Indent = _ BOOL ; } } indent . append ( _ STR ) ; break ; } if ( insert Indent ) { document . insert String ( document . get Line Start Offset ( line ) , indent ) ; } } move Caret To The Line End If Possible ( editor , line ) ; return _ BOOL ; } if ( next . parameter Description Start Position != null ) { my Helper . navigate ( next . parameter Description Start Position , editor , psi File . get Project ( ) ) ; } else { final  Logical Position position = my Helper . calculate Description Start Position ( psi File , pair . second , next ) ; my Helper . navigate ( position , editor , psi File . get Project ( ) ) ; } return _ BOOL ; }
public void add All (  DVector v ) { expand For ( size + v . size - _ NUM , _ NUM ) ;  System . arraycopy ( v . vector , _ NUM , vector , size - v . size , v . size ) ; }
public static void drain (  Input Stream in Str ) throws  IOException { byte [ ] bs = new byte [  BUFFER_ SIZE ] ; while ( in Str . read ( bs , _ NUM , bs . length ) >= _ NUM ) { } }
public  Sentence parse ( final  Conversation Context ctx ) { if ( context . equals ( ctx ) ) { return this ; } else { return  Conversation Parser . parse ( original Text , ctx ) ; } }
public synchronized void start ( ) { if ( workers . size ( ) > _ NUM ) { throw new  Runtime Exception ( _ STR + _ STR ) ; } for ( int i = _ NUM ; i < num Workers ; i ++ ) {  Worker worker = new  Worker <  Job > ( worker Name , jobs To Run , this ) ; workers . add ( worker ) ; } for (  Worker w : workers ) { try {  Thread . sleep ( _ NUM ) ; } catch (  Exception e ) {  LOG . error ( e ) ; } w . start ( ) ; } }
public static  List <  String > split Lines (  String s ) {  Array List ret = new  Array List ( ) ;  String [ ] split = s . split ( _ STR ) ; ret . add All (  Arrays . as List ( split ) ) ; return ret ; }
static  String decode String (  Byte Buffer buffer ,  String charset ) { if ( buffer == null ) { return null ; } if ( charset == null ) { throw new  Illegal Argument Exception ( _ STR ) ; } try { return new  String ( buffer . array ( ) , buffer . position ( ) , buffer . limit ( ) - buffer . position ( ) , charset ) ; } catch (  Unsupported Encoding Exception e ) { throw new  Runtime Exception ( e ) ; } }
public void add Layer (  Layer layer ) { if ( all Layers == null ) { add Layer ( layer , _ NUM ) ; return ; } if ( ! all Layers . contains ( layer ) ) { all Layers . add ( layer ) ; } }
private  List <  Regex Rule > read Rules (  Reader reader ) throws  IOException ,  Illegal Argument Exception {  Buffered Reader in = new  Buffered Reader ( reader ) ;  List <  Regex Rule > rules = new  Array List <  Regex Rule > ( ) ;  String line ; while ( ( line = in . read Line ( ) ) != null ) { if ( line . length ( ) == _ NUM ) { continue ; } char first = line . char At ( _ NUM ) ; boolean sign = _ BOOL ; switch ( first ) { case _ STR : sign = _ BOOL ; break ; case _ STR : sign = _ BOOL ; break ; case _ STR : case _ STR : case _ STR : continue ; default : throw new  IOException ( _ STR + line ) ; }  String regex = line . substring ( _ NUM ) ; if (  LOG . is Trace Enabled ( ) ) {  LOG . trace ( _ STR + regex + _ STR ) ; }  Regex Rule rule = create Rule ( sign , regex ) ; rules . add ( rule ) ; } return rules ; }
public void write ( char c [ ] , int off , int len ) { if ( off < _ NUM || off > c . length || len < _ NUM || off + len > c . length || off + len < _ NUM ) { throw new  Index Out Of Bounds Exception ( ) ; } else if ( len == _ NUM ) { return ; } int newcount = count + len ; if ( newcount > buf . length ) { expand Capacity ( newcount ) ; }  System . arraycopy ( c , off , buf , count , len ) ; count = newcount ; }
public static  String remove Cross Reference (  String text ) { if (  Strings . is Null Or Empty ( text ) ) { return _ STR ; }  Pattern pattern =  Pattern . compile ( _ STR + _ STR ) ;  Matcher matcher = pattern . matcher ( text ) ;  String Buffer result = new  String Buffer ( ) ; while ( matcher . find ( ) ) {  String replacement Text = matcher . group ( _ STR ) ; replacement Text =  Matcher . quote Replacement ( replacement Text ) ; matcher . append Replacement ( result , replacement Text ) ; } matcher . append Tail ( result ) ; return result . to String ( ) ; }
public static  Typed Operation create Array Element Assignment (  Array Type array Type ) {  List <  Type > type List = new  Array List < > ( ) ; type List . add ( array Type ) ; type List . add (  Java Types .  INT_ TYPE ) ; type List . add ( array Type . get Component Type ( ) ) ;  Type Tuple input Types = new  Type Tuple ( type List ) ; return new  Typed Term Operation ( new  Array Element Set ( array Type . get Component Type ( ) ) , input Types ,  Java Types .  VOID_ TYPE ) ; }
public void remove Listener ( final  ISPARQLUpdate Listener l ) { if ( is Read Only ( ) ) throw new  Unsupported Operation Exception ( ) ; if ( l == null ) throw new  Illegal Argument Exception ( ) ; listeners . remove ( l ) ; }
public  Moving Average Processor (  String type , double alpha ) { if ( !  VALID_ TYPES . contains ( type ) ) { throw new  Illegal Argument Exception ( type + _ STR + _ STR ) ; } if ( ( alpha < _ NUM ) || ( alpha > _ NUM ) ) { throw new  Illegal Argument Exception ( _ STR ) ; } this . type = type ; this . alpha = alpha ; }
public boolean is All Space ( ) { boolean is All Space = _ BOOL ; for ( int i = _ NUM ; i < text . length ( ) ; i ++ ) { if ( !  Character . is Whitespace ( text . char At ( i ) ) ) { is All Space = _ BOOL ; break ; } } return is All Space ; }
public static boolean is Double (  String desc ) { return desc . ends With ( _ STR ) ; }
RSAPrivate Crt Key Impl ( byte [ ] encoded ) throws  Invalid Key Exception { decode ( encoded ) ;  RSAKey Factory . check RSAProvider Key Lengths ( n . bit Length ( ) , e ) ; }
public boolean by Pass Control To Processor ( boolean flag ) { return _ BOOL ; }
public void init ( ) { if ( ! _initialized ) { super . init ( ) ; _detect Panel = new  Detection Panel ( this ) ;  JPanel panel = new  JPanel ( ) ; panel . set Layout ( new  Box Layout ( panel ,  Box Layout .  Y_ AXIS ) ) ; panel . add (  Box . create Vertical Glue ( ) ) ; panel . add ( _detect Panel ) ; add ( panel , _ NUM ) ; } }
public static void write Line (  Buffered Writer writer ,  String line ) throws  IOException { writer . write ( line ) ; writer . new Line ( ) ; }
public void add (  WXDom Object child , int index ) { if ( child == null || index < - _ NUM || s Destroy . get ( ) ) { return ; } if ( children == null ) { children = new  Array List < > ( ) ; } int count = children . size ( ) ; index = index >= count ? - _ NUM : index ; if ( index == - _ NUM ) { children . add ( child ) ; super . add Child At ( child , super . get Child Count ( ) ) ; } else { children . add ( index , child ) ; super . add Child At ( child , index ) ; } child . parent = this ; }
public boolean may Alias (  Value v1 ,  Value v2 ,  Unit u ) {  Set <  Set <  Value > > res = get Flow Before ( u ) ; for (  Set <  Value > set : res ) { if ( set . contains ( v1 ) && set . contains ( v2 ) ) return _ BOOL ; } return _ BOOL ; }
public static  String [ ] from List (  String url List ) throws  Naming Exception {  String [ ] urls = new  String [ ( url List . length ( ) + _ NUM ) / _ NUM ] ; int i = _ NUM ;  String Tokenizer st = new  String Tokenizer ( url List , _ STR ) ; while ( st . has More Tokens ( ) ) { urls [ i ++ ] = st . next Token ( ) ; }  String [ ] trimmed = new  String [ i ] ;  System . arraycopy ( urls , _ NUM , trimmed , _ NUM , i ) ; return trimmed ; }
public  DSubject Alternative Name (  JDialog parent , byte [ ] value ) throws  IOException { super ( parent ) ; set Title ( res . get String ( _ STR ) ) ; init Components ( ) ; prepopulate With Value ( value ) ; }
public  Int Column ( int nrows , int capacity , int default Value ) { super ( int . class , new  Integer ( default Value ) ) ; if ( capacity < nrows ) { throw new  Illegal Argument Exception ( _ STR ) ; } m_values = new int [ capacity ] ;  Arrays . fill ( m_values , default Value ) ; m_size = nrows ; }
void read SIN ( ) throws  IOException { while ( _ BOOL ) {  String  S = isr . read Line ( ) ; if (  S == null ) return ; if (  S . starts With ( _ STR ) ) return ; } }
private void check Alter Partial Converters ( ) throws  Security Exception {  Security Manager sm =  System . get Security Manager ( ) ; if ( sm != null ) { sm . check Permission ( new  Joda Time Permission ( _ STR ) ) ; } }
public boolean equals ( final  Object obj ) { return this == obj || obj instanceof  Artifact Coordinates && equals ( (  Artifact Coordinates ) obj ) ; }
public void test From Date ( ) throws  Exception {  Time Zone . set Default (  Time Zone . get Time Zone ( _ STR ) ) ; final  Calendar date =  Calendar . get Instance ( ) ; date . set Time ( new  Date ( _ NUM ) ) ;  Assert . assert Equals ( _ STR ,  Calendar Serializer . serialize ( date ) ) ; final  Calendar date No Millis =  Calendar . get Instance ( ) ; date No Millis . set Time ( new  Date ( _ NUM ) ) ;  Assert . assert Equals ( _ STR ,  Calendar Serializer . serialize ( date No Millis ) ) ; }
protected  Document create Configuration Document (  AVList params ) {  Document doc = super . create Configuration Document ( params ) ; if ( doc == null || doc . get Document Element ( ) == null ) return doc ;  Data Configuration Utils . create WMSLayer Config Elements ( params , doc . get Document Element ( ) ) ; return doc ; }
@  Override public  Query new Prefix Query (  String text ) { if ( settings . lowercase Expanded Terms ( ) ) { text = text . to Lower Case ( settings . locale ( ) ) ; }  Boolean Query .  Builder bq = new  Boolean Query .  Builder ( ) ; bq . set Disable Coord ( _ BOOL ) ; for (  Map .  Entry <  String ,  Float > entry : weights . entry Set ( ) ) { try { if ( settings . analyze Wildcard ( ) ) {  Query analyzed Query = new Possibly Analyzed Query ( entry . get Key ( ) , text ) ; analyzed Query . set Boost ( entry . get Value ( ) ) ; bq . add ( analyzed Query ,  Boolean Clause .  Occur .  SHOULD ) ; } else {  Prefix Query prefix = new  Prefix Query ( new  Term ( entry . get Key ( ) , text ) ) ; prefix . set Boost ( entry . get Value ( ) ) ; bq . add ( prefix ,  Boolean Clause .  Occur .  SHOULD ) ; } } catch (  Runtime Exception e ) { return rethrow Unless Lenient ( e ) ; } } return super . simplify ( bq . build ( ) ) ; }
public  Source Call Chain Info (  Soot Method m ,  Stmt s ,  String type ) { this . type = type ; this . link = _ STR ; this . method = m ; this . stmt = s ; calls = _ NUM ; if ( type . equals ( _ STR ) ) syscalls = _ NUM ; }
public void discard Recording ( ) {  Log . d (  TAG , _ STR ) ; if ( (  STATE_ RECORDING == m Internal State ) && ( null != m Recorder ) ) { stop Recorder ( ) ; } else if ( (  STATE_ PLAYBACK == m Internal State ) && ( null != m Player ) ) { stop Player ( ) ; } if ( null != m Record File && ! m Is Recording File Saved ) { if ( ! m Record File . delete ( ) ) {  Log . d (  TAG , _ STR ) ; } m Record File = null ; m Record Start Time = _ NUM ; m Record Time = _ NUM ; } set State (  STATE_ IDLE ) ;  Log . d (  TAG , _ STR ) ; }
public double convexity Bias ( final double future Price , final double t , final double  T , final double sigma , final double a ) {  QL . require ( future Price >= _ NUM , _ STR ) ;  QL . require ( t >= _ NUM , _ STR ) ;  QL . require (  T >= t , _ STR ) ;  QL . require ( a >= _ NUM , _ STR ) ; final double delta T = (  T - t ) ; final double temp Delta T = ( _ NUM -  Math . exp ( - a * delta T ) ) / a ; final double half Sigma Square = sigma * sigma / _ NUM ; final double lambda = half Sigma Square * ( _ NUM -  Math . exp ( - _ NUM * a * t ) ) / a * temp Delta T * temp Delta T ; final double temp T = ( _ NUM -  Math . exp ( - a * t ) ) / a ; final double phi = half Sigma Square * temp Delta T * temp T * temp T ; final double z = lambda + phi ; final double future Rate = ( _ NUM - future Price ) / _ NUM ; return ( _ NUM -  Math . exp ( - z ) ) * ( future Rate + _ NUM / (  T - t ) ) ; }
public static void not Empty (  String string ) { if ( string == null || string . length ( ) == _ NUM ) throw new  Illegal Argument Exception ( _ STR ) ; }
@  Override public void add Statement ( final  Resource s , final  URI p , final  Value o , final  Resource ... contexts ) throws  Sail Exception { if ( log . is Debug Enabled ( ) ) log . debug ( _ STR + s + _ STR + p + _ STR + o + _ STR +  Arrays . to String ( contexts ) ) ;  Open RDFUtil . verify Context Not Null ( contexts ) ; if ( contexts . length == _ NUM ) { add Statement ( s , p , o , (  Resource ) null ) ; } if ( contexts . length == _ NUM && contexts [ _ NUM ] == null ) { add Statement ( s , p , o , (  Resource ) null ) ; } for (  Resource c : contexts ) { add Statement ( s , p , o , c ) ; } }
public static boolean equals (  Collection < ? > actual ,  Object ... reference ) { final  Collection <  Object > collection = new  Hash Set < > ( ) ;  Collections . add All ( collection , reference ) ; if ( actual == collection ) { return _ BOOL ; } if ( actual == null ) { return _ BOOL ; } if ( actual . size ( ) != collection . size ( ) ) { log . warn ( _ STR + actual . size ( ) + _ STR + collection . size ( ) ) ; return _ BOOL ; } for (  Object object : actual ) { if ( ! collection . contains ( object ) ) { log . warn ( _ STR + object ) ; return _ BOOL ; } } for (  Object object : collection ) { if ( ! actual . contains ( object ) ) { log . warn ( _ STR + object ) ; return _ BOOL ; } } return _ BOOL ; }
public boolean cancel Transfer (  String username ,  String submission ID ) { if ( cancel Upload ( username , submission ID ) ) return _ BOOL ; return cancel Download ( username , submission ID ) ; }
public static boolean unregister Service ( long id ) { boolean exit Status = _ BOOL ; if (  ID_ TO_ SERVICE_ MAP . get ( id ) == null ) {  LOG . warning ( _ STR ) ; } else {  Service < ? > service =  ID_ TO_ SERVICE_ MAP . put ( id , null ) ; if ( service != null ) {  SERVICE_ TO_ USER_ MAP . remove ( service ) ; } exit Status = _ BOOL ; } return exit Status ; }
public  Class Entry (  Dynamic Class Loader loader ,  String name ,  Path source Path ,  Path class Path ,  Code Source code Source ) { _loader = loader ; _name = name ; _class Path = class Path ; set Depend Path ( class Path ) ; if ( source Path != null && ! source Path . equals ( class Path ) ) { _source Path = source Path ; _source Last Modified = source Path . get Last Modified ( ) ; _source Length = source Path . length ( ) ; } _code Source = code Source ; }
private  Membership Key inner Join (  Inet Address group ,  Network Interface interf ,  Inet Address source ) throws  IOException { if ( ! group . is Multicast Address ( ) ) throw new  Illegal Argument Exception ( _ STR ) ; if ( group instanceof  Inet4 Address ) { if ( family ==  Standard Protocol Family .  INET6 && !  Net . can IPv6 Socket Join IPv4 Group ( ) ) throw new  Illegal Argument Exception ( _ STR ) ; } else if ( group instanceof  Inet6 Address ) { if ( family !=  Standard Protocol Family .  INET6 ) throw new  Illegal Argument Exception ( _ STR ) ; } else { throw new  Illegal Argument Exception ( _ STR ) ; } if ( source != null ) { if ( source . is Any Local Address ( ) ) throw new  Illegal Argument Exception ( _ STR ) ; if ( source . is Multicast Address ( ) ) throw new  Illegal Argument Exception ( _ STR ) ; if ( source . get Class ( ) != group . get Class ( ) ) throw new  Illegal Argument Exception ( _ STR ) ; }  Security Manager sm =  System . get Security Manager ( ) ; if ( sm != null ) sm . check Multicast ( group ) ; synchronized ( state Lock ) { if ( ! is Open ( ) ) throw new  Closed Channel Exception ( ) ; if ( registry == null ) { registry = new  Membership Registry ( ) ; } else {  Membership Key key = registry . check Membership ( group , interf , source ) ; if ( key != null ) return key ; }  Membership Key Impl key ; if ( ( family ==  Standard Protocol Family .  INET6 ) && ( ( group instanceof  Inet6 Address ) ||  Net . can Join6 With IPv4 Group ( ) ) ) { int index = interf . get Index ( ) ; if ( index == - _ NUM ) throw new  IOException ( _ STR ) ; byte [ ] group Address =  Net . inet6 As Byte Array ( group ) ; byte [ ] source Address = ( source == null ) ? null :  Net . inet6 As Byte Array ( source ) ; int n =  Net . join6 ( fd , group Address , index , source Address ) ; if ( n ==  IOStatus .  UNAVAILABLE ) throw new  Unsupported Operation Exception ( ) ; key = new  Membership Key Impl .  Type6 ( this , group , interf , source , group Address , index , source Address ) ; } else {  Inet4 Address target =  Net . any Inet4 Address ( interf ) ; if ( target == null ) throw new  IOException ( _ STR ) ; int group Address =  Net . inet4 As Int ( group ) ; int target Address =  Net . inet4 As Int ( target ) ; int source Address = ( source == null ) ? _ NUM :  Net . inet4 As Int ( source ) ; int n =  Net . join4 ( fd , group Address , target Address , source Address ) ; if ( n ==  IOStatus .  UNAVAILABLE ) throw new  Unsupported Operation Exception ( ) ; key = new  Membership Key Impl .  Type4 ( this , group , interf , source , group Address , target Address , source Address ) ; } registry . add ( key ) ; return key ; } }
public void close ( ) throws  IOException { super . close ( ) ; out . close ( ) ; }
@  Override public double calculate Distance ( double [ ] x1 , double [ ] x2 ) { double expression = norm2 ( x1 , x2 ) / sigma ; if ( expression > _ NUM ) { return _ NUM ; } else { double minus = _ NUM - expression ; return  Math . pow ( minus , degree ) ; } }
public static  String to String (  URI uri ,  Charset encoding ) throws  IOException { return to String ( uri . to URL ( ) ,  Charsets . to Charset ( encoding ) ) ; }
void put ( int field Number ,  Field Data data ) { int i = binary Search ( field Number ) ; if ( i >= _ NUM ) { m Data [ i ] = data ; } else { i = ~ i ; if ( i < m Size && m Data [ i ] ==  DELETED ) { m Field Numbers [ i ] = field Number ; m Data [ i ] = data ; return ; } if ( m Garbage && m Size >= m Field Numbers . length ) { gc ( ) ; i = ~ binary Search ( field Number ) ; } if ( m Size >= m Field Numbers . length ) { int n = ideal Int Array Size ( m Size + _ NUM ) ; int [ ] nkeys = new int [ n ] ;  Field Data [ ] nvalues = new  Field Data [ n ] ;  System . arraycopy ( m Field Numbers , _ NUM , nkeys , _ NUM , m Field Numbers . length ) ;  System . arraycopy ( m Data , _ NUM , nvalues , _ NUM , m Data . length ) ; m Field Numbers = nkeys ; m Data = nvalues ; } if ( m Size - i != _ NUM ) {  System . arraycopy ( m Field Numbers , i , m Field Numbers , i + _ NUM , m Size - i ) ;  System . arraycopy ( m Data , i , m Data , i + _ NUM , m Size - i ) ; } m Field Numbers [ i ] = field Number ; m Data [ i ] = data ; m Size ++ ; } }
private void hilite (  Graphics graphics ,  JComponent button ) { graphics . set Color ( style . get High Light Color ( ) ) ;  Insets insets = button . get Insets ( ) ; int width = button . get Width ( ) - insets . right - insets . left - _ NUM ; int height = button . get Height ( ) - insets . top - insets . bottom - _ NUM ; graphics . draw Rect ( insets . left , insets . top , width , height ) ; }
public void init (  String btxn ,  Business Txn Config btc ) {  Filter Processor fp = null ; if ( btc . get Filter ( ) != null ) { fp = new  Filter Processor ( btxn , btc ) ; } synchronized ( filter Map ) {  Filter Processor oldfp = filter Map . get ( btxn ) ; if ( oldfp != null ) { global Exclusion Filters . remove ( oldfp ) ; btxn Filters . remove ( oldfp ) ; } if ( fp != null ) { filter Map . put ( btxn , fp ) ; if ( fp . is Include All ( ) ) { global Exclusion Filters . add ( fp ) ; } else { btxn Filters . add ( fp ) ; } } else { filter Map . remove ( btxn ) ; } } }
public synchronized void add ( double x , double y , double value ) { super . add ( x , y ) ; m Value . add ( value ) ; update Range ( value ) ; }
public static int define Tag ( int ifd Id , short tag Id ) { return ( tag Id & _ NUM ) | ( ifd Id << _ NUM ) ; }
private void enable Stronger Defaults (  Socket socket ) { if ( is Secure ( socket ) ) {  SSLSocket ssl Socket = (  SSLSocket ) socket ; read SSLParameters ( ssl Socket ) ; if ( m Enable Stonger Default Protocal Version && m Protocols != null ) { ssl Socket . set Enabled Protocols ( m Protocols ) ; } if ( m Enable Stonger Default SSLCipher Suite && m Cipher Suites != null ) { ssl Socket . set Enabled Cipher Suites ( m Cipher Suites ) ; } } }
private static  Platform find Platform ( ) { try { try {  Class . for Name ( _ STR ) ; } catch (  Class Not Found Exception e ) {  Class . for Name ( _ STR ) ; }  Optional Method <  Socket > set Use Session Tickets = new  Optional Method < > ( null , _ STR , boolean . class ) ;  Optional Method <  Socket > set Hostname = new  Optional Method < > ( null , _ STR ,  String . class ) ;  Method traffic Stats Tag Socket = null ;  Method traffic Stats Untag Socket = null ;  Optional Method <  Socket > get Alpn Selected Protocol = null ;  Optional Method <  Socket > set Alpn Protocols = null ; try {  Class < ? > traffic Stats =  Class . for Name ( _ STR ) ; traffic Stats Tag Socket = traffic Stats . get Method ( _ STR ,  Socket . class ) ; traffic Stats Untag Socket = traffic Stats . get Method ( _ STR ,  Socket . class ) ; try {  Class . for Name ( _ STR ) ; get Alpn Selected Protocol = new  Optional Method < > ( byte [ ] . class , _ STR ) ; set Alpn Protocols = new  Optional Method < > ( null , _ STR , byte [ ] . class ) ; } catch (  Class Not Found Exception ignored ) { } } catch (  Class Not Found Exception |  No Such Method Exception ignored ) { } return new  Android ( set Use Session Tickets , set Hostname , traffic Stats Tag Socket , traffic Stats Untag Socket , get Alpn Selected Protocol , set Alpn Protocols ) ; } catch (  Class Not Found Exception ignored ) { } try {  String nego Class Name = _ STR ;  Class < ? > nego Class =  Class . for Name ( nego Class Name ) ;  Class < ? > provider Class =  Class . for Name ( nego Class Name + _ STR ) ;  Class < ? > client Provider Class =  Class . for Name ( nego Class Name + _ STR ) ;  Class < ? > server Provider Class =  Class . for Name ( nego Class Name + _ STR ) ;  Method put Method = nego Class . get Method ( _ STR ,  SSLSocket . class , provider Class ) ;  Method get Method = nego Class . get Method ( _ STR ,  SSLSocket . class ) ;  Method remove Method = nego Class . get Method ( _ STR ,  SSLSocket . class ) ; return new  Jdk With Jetty Boot Platform ( put Method , get Method , remove Method , client Provider Class , server Provider Class ) ; } catch (  Class Not Found Exception |  No Such Method Exception ignored ) { } return new  Platform ( ) ; }
public void halt All Tasks ( ) {  Linked List <  Thread > ending Threads = new  Linked List < > ( ) ; ending Threads . add All ( executions . values ( ) ) ; for (  Thread thread : ending Threads ) { while ( thread . is Alive ( ) && thread !=  Thread . current Thread ( ) ) {  LOGGER . info ( _ STR + thread ) ; thread . interrupt ( ) ; } } executions . clear ( ) ; }
public static double [ ] ln To Normalied Prob ( final double [ ] logs ) { final double [ ] prob = new double [ logs . length ] ; double max = logs [ _ NUM ] ; for ( int i = _ NUM ; i < logs . length ; i ++ ) { if ( max < logs [ i ] ) { max = logs [ i ] ; } } double sum = _ NUM ; for ( int i = _ NUM ; i < logs . length ; i ++ ) { final double v =  Math . exp ( logs [ i ] - max ) ; prob [ i ] = v ; sum += v ; } for ( int i = _ NUM ; i < logs . length ; i ++ ) { prob [ i ] = prob [ i ] / sum ; } return prob ; }
static  String to S ( float [ ] a ) {  String s = _ STR ; if ( a == null ) { return _ STR ; } for ( int i = _ NUM ; i < a . length ; i ++ ) { if ( i != _ NUM ) { s += _ STR ; }  String t = df . format ( a [ i ] ) + _ STR ; s += t . substring ( _ NUM , _ NUM ) ; } s += _ STR ; return s ; }
private void define Internal Frame Iconify Buttons (  UIDefaults d ) {  String p = _ STR ;  String c =  PAINTER_ PREFIX + _ STR ; d . put ( p + _ STR , _ STR ) ; d . put ( p + _ STR , new  Title Pane Iconify Button Window Not Focused State ( ) ) ; d . put ( p + _ STR , new  Title Pane Iconify Button Window Minimized State ( ) ) ; d . put ( p + _ STR , new  Insets UIResource ( _ NUM , _ NUM , _ NUM , _ NUM ) ) ; d . put ( p + _ STR , new  Lazy Painter ( c ,  Title Pane Iconify Button Painter .  Which .  BACKGROUND_ ENABLED ) ) ; d . put ( p + _ STR , new  Lazy Painter ( c ,  Title Pane Iconify Button Painter .  Which .  BACKGROUND_ DISABLED ) ) ; d . put ( p + _ STR , new  Lazy Painter ( c ,  Title Pane Iconify Button Painter .  Which .  BACKGROUND_ MOUSEOVER ) ) ; d . put ( p + _ STR , new  Lazy Painter ( c ,  Title Pane Iconify Button Painter .  Which .  BACKGROUND_ PRESSED ) ) ; d . put ( p + _ STR , new  Lazy Painter ( c ,  Title Pane Iconify Button Painter .  Which .  BACKGROUND_ ENABLED_ WINDOWNOTFOCUSED ) ) ; d . put ( p + _ STR , new  Lazy Painter ( c ,  Title Pane Iconify Button Painter .  Which .  BACKGROUND_ MOUSEOVER_ WINDOWNOTFOCUSED ) ) ; d . put ( p + _ STR , new  Lazy Painter ( c ,  Title Pane Iconify Button Painter .  Which .  BACKGROUND_ PRESSED_ WINDOWNOTFOCUSED ) ) ; d . put ( p + _ STR , new  Lazy Painter ( c ,  Title Pane Iconify Button Painter .  Which .  BACKGROUND_ MINIMIZED_ DISABLED ) ) ; d . put ( p + _ STR , new  Lazy Painter ( c ,  Title Pane Iconify Button Painter .  Which .  BACKGROUND_ MINIMIZED_ ENABLED ) ) ; d . put ( p + _ STR , new  Lazy Painter ( c ,  Title Pane Iconify Button Painter .  Which .  BACKGROUND_ MINIMIZED_ MOUSEOVER ) ) ; d . put ( p + _ STR , new  Lazy Painter ( c ,  Title Pane Iconify Button Painter .  Which .  BACKGROUND_ MINIMIZED_ PRESSED ) ) ; d . put ( p + _ STR , new  Lazy Painter ( c ,  Title Pane Iconify Button Painter .  Which .  BACKGROUND_ MINIMIZED_ ENABLED_ WINDOWNOTFOCUSED ) ) ; d . put ( p + _ STR , new  Lazy Painter ( c ,  Title Pane Iconify Button Painter .  Which .  BACKGROUND_ MINIMIZED_ MOUSEOVER_ WINDOWNOTFOCUSED ) ) ; d . put ( p + _ STR , new  Lazy Painter ( c ,  Title Pane Iconify Button Painter .  Which .  BACKGROUND_ MINIMIZED_ PRESSED_ WINDOWNOTFOCUSED ) ) ; d . put ( p + _ STR , new  Sea Glass Icon ( p , _ STR , _ NUM , _ NUM ) ) ; }
public static  Workflow .  Method resync Clone Method (  URI storage ,  List <  URI > clone ,  Boolean update Op Status , boolean is CG ) { return new  Workflow .  Method ( _ STR , storage , clone , update Op Status , is CG ) ; }
@  Override public synchronized void remove Data Source Listener (  Data Source Listener dsl ) { m_data Listeners . remove ( dsl ) ; }
public  String left Str (  String str , int length ) { return str . substring ( _ NUM ,  Math . min ( str . length ( ) , length ) ) ; }
public boolean contains Block (  Block b ) {  Array List <  Block > b List = get Internal Blocks List ( ) ; for ( int i = _ NUM ; i < b List . size ( ) ; i ++ ) { if ( b == b List . get ( i ) ) { return _ BOOL ; } } return _ BOOL ; }
public static <  T extends  Storable >  T unserialize (  Class <  T > clazz ,  Data data ) { try {  T storable Obj = clazz . new Instance ( ) ; storable Obj . load ( data ) ; return storable Obj ; } catch (  Exception e ) { throw new  Data Exception ( e ) ; } }
public static void main (  String [ ] args ) {  Timer timer = new  Timer ( _ STR ) ;  Timer overall Timer = new  Timer ( _ STR ) ; timer . show Times ( _ NUM ) ; overall Timer . start ( ) ; for ( int i = _ NUM ; i < _ NUM ; i ++ ) { timer . start ( ) ; try {  Thread . sleep ( i * _ NUM ) ; } catch (  Interrupted Exception e ) { } timer . stop ( _ BOOL ) ; } overall Timer . stop ( ) ; timer . show Times ( overall Timer . get Current Time ( ) ) ; overall Timer . show Times ( ) ; }
public void push Template Folder ( @  Not Null  File folder ) { my Last Template Folders . push ( folder ) ; }
public void print ( ) { print ( new  Print Writer (  System . out , _ BOOL ) ) ; }
protected void draw Cubic (  Canvas c ,  Line Data Set data Set ,  List <  Entry > entries ) {  Transformer trans = m Chart . get Transformer ( data Set . get Axis Dependency ( ) ) ;  Entry entry From = data Set . get Entry For XIndex ( m Min X ) ;  Entry entry To = data Set . get Entry For XIndex ( m Max X ) ; int minx = data Set . get Entry Position ( entry From ) ; int maxx =  Math . min ( data Set . get Entry Position ( entry To ) + _ NUM , entries . size ( ) ) ; float phase X = m Animator . get Phase X ( ) ; float phase Y = m Animator . get Phase Y ( ) ; float intensity = data Set . get Cubic Intensity ( ) ; cubic Path . reset ( ) ; int size = ( int )  Math . ceil ( ( maxx - minx ) * phase X + minx ) ; minx =  Math . max ( minx - _ NUM , _ NUM ) ; size =  Math . min ( size + _ NUM , entries . size ( ) ) ; if ( size - minx >= _ NUM ) { float prev Dx = _ NUM ; float prev Dy = _ NUM ; float cur Dx = _ NUM ; float cur Dy = _ NUM ;  Entry cur = entries . get ( minx ) ;  Entry next = entries . get ( minx + _ NUM ) ;  Entry prev = entries . get ( minx ) ;  Entry prev Prev = entries . get ( minx ) ; cubic Path . move To ( cur . get XIndex ( ) , cur . get Val ( ) * phase Y ) ; prev Dx = ( next . get XIndex ( ) - cur . get XIndex ( ) ) * intensity ; prev Dy = ( next . get Val ( ) - cur . get Val ( ) ) * intensity ; cur = entries . get ( minx + _ NUM ) ; next = entries . get ( minx + ( size - minx > _ NUM ? _ NUM : _ NUM ) ) ; cur Dx = ( next . get XIndex ( ) - prev . get XIndex ( ) ) * intensity ; cur Dy = ( next . get Val ( ) - prev . get Val ( ) ) * intensity ; cubic Path . cubic To ( prev . get XIndex ( ) + prev Dx , ( prev . get Val ( ) + prev Dy ) * phase Y , cur . get XIndex ( ) - cur Dx , ( cur . get Val ( ) - cur Dy ) * phase Y , cur . get XIndex ( ) , cur . get Val ( ) * phase Y ) ; for ( int j = minx + _ NUM ; j < size - _ NUM ; j ++ ) { prev Prev = entries . get ( j - _ NUM ) ; prev = entries . get ( j - _ NUM ) ; cur = entries . get ( j ) ; next = entries . get ( j + _ NUM ) ; prev Dx = ( cur . get XIndex ( ) - prev Prev . get XIndex ( ) ) * intensity ; prev Dy = ( cur . get Val ( ) - prev Prev . get Val ( ) ) * intensity ; cur Dx = ( next . get XIndex ( ) - prev . get XIndex ( ) ) * intensity ; cur Dy = ( next . get Val ( ) - prev . get Val ( ) ) * intensity ; cubic Path . cubic To ( prev . get XIndex ( ) + prev Dx , ( prev . get Val ( ) + prev Dy ) * phase Y , cur . get XIndex ( ) - cur Dx , ( cur . get Val ( ) - cur Dy ) * phase Y , cur . get XIndex ( ) , cur . get Val ( ) * phase Y ) ; } if ( size > entries . size ( ) - _ NUM ) { cur = entries . get ( entries . size ( ) - _ NUM ) ; prev = entries . get ( entries . size ( ) - _ NUM ) ; prev Prev = entries . get ( ( entries . size ( ) >= _ NUM ) ? entries . size ( ) - _ NUM : entries . size ( ) - _ NUM ) ; next = cur ; prev Dx = ( cur . get XIndex ( ) - prev Prev . get XIndex ( ) ) * intensity ; prev Dy = ( cur . get Val ( ) - prev Prev . get Val ( ) ) * intensity ; cur Dx = ( next . get XIndex ( ) - prev . get XIndex ( ) ) * intensity ; cur Dy = ( next . get Val ( ) - prev . get Val ( ) ) * intensity ; cubic Path . cubic To ( prev . get XIndex ( ) + prev Dx , ( prev . get Val ( ) + prev Dy ) * phase Y , cur . get XIndex ( ) - cur Dx , ( cur . get Val ( ) - cur Dy ) * phase Y , cur . get XIndex ( ) , cur . get Val ( ) * phase Y ) ; } } if ( data Set . is Draw Filled Enabled ( ) ) { cubic Fill Path . reset ( ) ; cubic Fill Path . add Path ( cubic Path ) ; draw Cubic Fill ( m Bitmap Canvas , data Set , cubic Fill Path , trans , entry From . get XIndex ( ) , entry From . get XIndex ( ) + size ) ; } m Render Paint . set Color ( data Set . get Color ( ) ) ; m Render Paint . set Style (  Paint .  Style .  STROKE ) ; trans . path Value To Pixel ( cubic Path ) ; m Bitmap Canvas . draw Path ( cubic Path , m Render Paint ) ; m Render Paint . set Path Effect ( null ) ; }
public void add Event First (  Sim Event new Event ) { new Event . set Serial ( _ NUM ) ; sorted Set . add ( new Event ) ; }
public  Attribute Selection Panel ( ) { this ( _ BOOL , _ BOOL , _ BOOL , _ BOOL ) ; }
public static void add River (  IBoard board ,  Hash Map <  IHex ,  Point > reverse Hex ) { int min Elevation =  Integer .  MAX_ VALUE ;  Hash Set <  IHex > river Hexes = new  Hash Set <  IHex > ( ) ;  IHex field ;  Point p = null ; int direction = _ NUM ; int next Left = _ NUM ; int next Right = _ NUM ; int width = board . get Width ( ) ; int height = board . get Height ( ) ; if ( ( width < _ NUM ) || ( height < _ NUM ) ) { return ; } switch (  Compute . random Int ( _ NUM ) ) { case _ NUM : p = new  Point ( _ NUM ,  Compute . random Int ( _ NUM ) - _ NUM + height / _ NUM ) ; direction =  Compute . random Int ( _ NUM ) + _ NUM ; next Left = direction - _ NUM ; next Right = direction + _ NUM ; break ; case _ NUM : p = new  Point ( width - _ NUM ,  Compute . random Int ( _ NUM ) - _ NUM + height / _ NUM ) ; direction =  Compute . random Int ( _ NUM ) + _ NUM ; next Left = direction - _ NUM ; next Right = ( direction + _ NUM ) % _ NUM ; break ; case _ NUM : case _ NUM : p = new  Point (  Compute . random Int ( _ NUM ) - _ NUM + width / _ NUM , _ NUM ) ; direction = _ NUM ; next Right = _ NUM ; next Left = _ NUM ; break ; } field = board . get Hex ( p . x , p . y ) ;  ITerrain Factory f =  Terrains . get Terrain Factory ( ) ; do { field . remove All Terrains ( ) ; field . add Terrain ( f . create Terrain (  Terrains .  WATER , _ NUM ) ) ; river Hexes . add ( field ) ; p = reverse Hex . get ( field ) ; river Hexes . add All ( extend River To Side ( board , p ,  Compute . random Int ( _ NUM ) , next Left , reverse Hex ) ) ; river Hexes . add All ( extend River To Side ( board , p ,  Compute . random Int ( _ NUM ) , next Right , reverse Hex ) ) ; switch (  Compute . random Int ( _ NUM ) ) { case _ NUM : field = board . get Hex In Dir ( p . x , p . y , ( direction + _ NUM ) % _ NUM ) ; break ; case _ NUM : field = board . get Hex In Dir ( p . x , p . y , ( direction + _ NUM ) % _ NUM ) ; break ; default : field = board . get Hex In Dir ( p . x , p . y , direction ) ; break ; } } while ( field != null ) ;  Hash Set <  IHex > tmp River Hexes = new  Hash Set <  IHex > ( river Hexes ) ; while ( ! tmp River Hexes . is Empty ( ) ) {  Iterator <  IHex > iter = tmp River Hexes . iterator ( ) ; field = iter . next ( ) ; if ( field . get Level ( ) < min Elevation ) { min Elevation = field . get Level ( ) ; } tmp River Hexes . remove ( field ) ;  Point this Hex = reverse Hex . get ( field ) ; for ( int i = _ NUM ; i < _ NUM ; i ++ ) { field = board . get Hex In Dir ( this Hex . x , this Hex . y , i ) ; if ( ( field != null ) && ( field . get Level ( ) < min Elevation ) ) { min Elevation = field . get Level ( ) ; } tmp River Hexes . remove ( field ) ; } }  Iterator <  IHex > iter = river Hexes . iterator ( ) ; while ( iter . has Next ( ) ) { field = iter . next ( ) ; field . set Level ( min Elevation ) ; } return ; }
public  Search Index Entry (  String search Term , char entity Type ,  String entity Name , int search Score ) { this . search Term = search Term . to Lower Case (  Locale .  ENGLISH ) ; this . entity Type = entity Type ; this . entity Name = entity Name ; this . search Score = search Score ; this . db Id = - _ NUM ; }
private void exit Process ( boolean ok ,  String message ) { logger . info ( message ) ; try {  File replicator Home =  Replicator Runtime Conf . locate Replicator Home Dir ( ) ;  File var Dir = new  File ( replicator Home , _ STR ) ;  File pid File = new  File ( var Dir , _ STR ) ; if ( pid File . exists ( ) ) { logger . info ( _ STR ) ; pid File . delete ( ) ; } } catch (  Throwable t ) { logger . warn ( _ STR , t ) ; } logger . info ( _ STR ) ; if ( ok )  System . exit ( _ NUM ) ; else  System . exit ( _ NUM ) ; }
public  Byte Array Data Source ( byte [ ] data ,  String type ) { m_data = data ; if ( type != null && type . length ( ) > _ NUM ) m_type = type ; }
private  DD compute EBy Taylor Series ( ) {  DD s =  DD . value Of ( _ NUM ) ;  DD t =  DD . value Of ( _ NUM ) ; double n = _ NUM ; int i = _ NUM ; while ( t . double Value ( ) >  DD .  EPS ) { i ++ ; n += _ NUM ; t = t . divide (  DD . value Of ( n ) ) ; s = s . add ( t ) ; } return s ; }
public java . lang .  String Buffer append ( java . lang .  Object obj ) { internal . append ( obj ) ; return this ; }
public static void ensure Directory (  String ... file Paths ) { if ( file Paths != null ) {  File file ; for (  String file Path : file Paths ) { file = new  File ( file Path ) ; if ( file . exists ( ) && ! file . is Directory ( ) ) { throw new  Illegal Argument Exception ( _ STR + file . get Absolute Path ( ) ) ; } else if ( ! file . exists ( ) ) { if ( ! file . mkdirs ( ) ) { throw new  Illegal State Exception ( _ STR + file . get Absolute Path ( ) ) ; } } } } }
public  String test Destination (  Location destination ,  Track track ) { return rs Test Destination ( destination , track ) ; }
@  Override public  Text Annotation next ( ) { if ( stack . is Empty ( ) && file Index >= file List . size ( ) ) throw new  No Such Element Exception ( ) ; if ( stack Index >= stack . size ( ) ) { stack Index = _ NUM ; do { try { stack = get Text Annotations From File ( file List . get ( file Index ++ ) ) ; } catch (  Exception e ) { e . print Stack Trace ( ) ; throw new  No Such Element Exception ( e . get Message ( ) ) ; } } while ( stack . is Empty ( ) && file Index < file List . size ( ) ) ; }  Text Annotation return Ta = stack . get ( stack Index ++ ) ; return return Ta ; }
private static  Object clone (  Object object ) { if ( object == null ) { return null ; }  Class c = object . get Class ( ) ;  Object result = null ; try {  Method m = c . get Method ( _ STR , (  Class [ ] ) null ) ; if (  Modifier . is Public ( m . get Modifiers ( ) ) ) { try { result = m . invoke ( object , (  Object [ ] ) null ) ; } catch (  Exception e ) { e . print Stack Trace ( ) ; } } } catch (  No Such Method Exception e ) { result = object ; } return result ; }
protected void add (  String field ) { record . add (  Objects . require Non Null ( field ) ) ; }
public final void on Before Start ( ) { if ( ! started Flag . compare And Set ( _ BOOL , _ BOOL ) ) throw new  Illegal State Exception ( _ STR + _ STR + _ STR + this + _ STR ) ; }
public  DOM4 JTest Document Builder Factory (  Document Builder Setting [ ] settings ) throws  DOMTest Incompatible Exception { super ( settings ) ; try {  Class Loader class Loader =  Class Loader . get System Class Loader ( ) ;  Class dom Factory Class = class Loader . load Class ( _ STR ) ;  Method get Instance = dom Factory Class . get Method ( _ STR , new  Class [ ] { } ) ; dom Factory = get Instance . invoke ( null , new  Object [ ] { } ) ; dom Impl = (  DOMImplementation ) dom Factory ;  Class sax Reader Class = class Loader . load Class ( _ STR ) ;  Constructor sax Reader Constructor = sax Reader Class . get Constructor ( new  Class [ ] { class Loader . load Class ( _ STR ) } ) ; sax Reader = sax Reader Constructor . new Instance ( new  Object [ ] { dom Factory } ) ;  Method get Reader Method = sax Reader Class . get Method ( _ STR , new  Class [ ] { } ) ; xml Reader = (  XMLReader ) get Reader Method . invoke ( sax Reader , new  Object [ _ NUM ] ) ; read Method = sax Reader Class . get Method ( _ STR , new  Class [ ] { java . net .  URL . class } ) ; } catch (  Invocation Target Exception ex ) { throw new  DOMTest Incompatible Exception ( ex . get Target Exception ( ) , null ) ; } catch (  Exception ex ) { throw new  DOMTest Incompatible Exception ( ex , null ) ; } }
public void write (  Input Stream stream ) { if ( is Final ) { log . warning ( _ STR ) ; return ; } try { int n Read ; byte [ ] buffer = new byte [ _ NUM * _ NUM ] ; while ( ( n Read = stream . read ( buffer , _ NUM , buffer . length ) ) != - _ NUM ) { byte [ ] new Data = new byte [ data . length + n Read ] ;  System . arraycopy ( data , _ NUM , new Data , _ NUM , data . length ) ;  System . arraycopy ( buffer , _ NUM , new Data , data . length , n Read ) ; data = new Data ; } } catch (  IOException e ) { log . warning ( _ STR ) ; } }
public  String parse (  String input Template ,  String intput Encoding ,  String output File ,  String output Encoding ,  String object ID ,  Object object ) throws  Exception { if ( object ID != null && object != null ) { control Context . put ( object ID , object ) ; }  Template template = get Template ( input Template , input Encoding != null ? input Encoding : this . input Encoding ) ; if ( output File == null || output File . equals ( _ STR ) ) {  String Writer sw = new  String Writer ( ) ; template . merge ( control Context , sw ) ; return sw . to String ( ) ; } else {  Writer writer = null ; if ( writers . get ( output File ) == null ) { writer = get Writer ( get Output Path ( ) +  File . separator + output File , output Encoding != null ? output Encoding : this . output Encoding ) ; writers . put ( output File , writer ) ; } else { writer = (  Writer ) writers . get ( output File ) ; }  Velocity Context vc = new  Velocity Context ( control Context ) ; template . merge ( vc , writer ) ; return _ STR ; } }
private void parse Menu (  Xml Pull Parser parser ,  Attribute Set attrs ,  Icon Data menu ) throws  Xml Pull Parser Exception ,  IOException {  Menu State menu State = new  Menu State ( menu ) ; int event Type = parser . get Event Type ( ) ;  String tag Name ; boolean looking For End Of Unknown Tag = _ BOOL ;  String unknown Tag Name = null ; do { if ( event Type ==  Xml Pull Parser .  START_ TAG ) { tag Name = parser . get Name ( ) ; if ( tag Name . equals (  XML_ MENU ) ) { event Type = parser . next ( ) ; break ; } throw new  Runtime Exception ( _ STR + tag Name ) ; } event Type = parser . next ( ) ; } while ( event Type !=  Xml Pull Parser .  END_ DOCUMENT ) ; boolean reached End Of Menu = _ BOOL ; while ( ! reached End Of Menu ) { switch ( event Type ) { case  Xml Pull Parser .  START_ TAG : if ( looking For End Of Unknown Tag ) { break ; } tag Name = parser . get Name ( ) ; if ( tag Name . equals (  XML_ GROUP ) ) { menu State . read Group ( attrs ) ; } else if ( tag Name . equals (  XML_ ITEM ) ) { menu State . read Item ( attrs ) ; } else if ( tag Name . equals (  XML_ MENU ) ) {  Icon Data sub Menu = menu State . add Sub Menu Item ( ) ; parse Menu ( parser , attrs , sub Menu ) ; } else { looking For End Of Unknown Tag = _ BOOL ; unknown Tag Name = tag Name ; } break ; case  Xml Pull Parser .  END_ TAG : tag Name = parser . get Name ( ) ; if ( looking For End Of Unknown Tag && tag Name . equals ( unknown Tag Name ) ) { looking For End Of Unknown Tag = _ BOOL ; unknown Tag Name = null ; } else if ( tag Name . equals (  XML_ GROUP ) ) { menu State . reset Group ( ) ; } else if ( tag Name . equals (  XML_ ITEM ) ) { if ( ! menu State . has Added Item ( ) ) { menu State . add Item ( ) ; } } else if ( tag Name . equals (  XML_ MENU ) ) { reached End Of Menu = _ BOOL ; } break ; case  Xml Pull Parser .  END_ DOCUMENT : throw new  Runtime Exception ( _ STR ) ; } event Type = parser . next ( ) ; } }
private byte [ ] add Exif ( byte [ ] jpeg ) {  Exif Interface exif = new  Exif Interface ( ) ; exif . add Date Time Stamp Tag (  Exif Interface .  TAG_ DATE_ TIME ,  System . current Time Millis ( ) ,  Time Zone . get Default ( ) ) ;  Byte Array Output Stream jpeg Out = new  Byte Array Output Stream ( ) ; try { exif . write Exif ( jpeg , jpeg Out ) ; } catch (  IOException e ) {  Log . e (  TAG , _ STR , e ) ; } return jpeg Out . to Byte Array ( ) ; }
@  Suppress Warnings ( _ STR ) public  List <  String > remove Initiator Details (  URI initiator Id ) {  List <  String > result =  Lists . new Array List ( ) ;  Initiator initiator = _db Client . query Object (  Initiator . class , initiator Id ) ; if ( initiator != null ) { result . add (  Compute System Dialog Properties . get Message ( _ STR , initiator . get Initiator Port ( ) ) ) ;  List <  Export Group > export Groups =  Compute System Controller Impl . get Export Groups ( _db Client , initiator . get Id ( ) ,  Lists . new Array List ( initiator ) ) ; for (  Export Group export : export Groups ) {  List <  URI > updated Initiators =  String Set Util . string Set To Uri List ( export . get Initiators ( ) ) ; if ( updated Initiators . remove ( initiator Id ) ) {  List <  Block Object Details > volume Details = get Block Object Details ( initiator . get Host ( ) , export . get Volumes ( ) ) ; result . add All ( get Volume Initiator Details ( volume Details , _ BOOL ) ) ; } } } return result ; }
public void add Extension (  String ext ) { synchronized ( exts ) { ext = ext . to Lower Case ( ) ; exts . add ( ext ) ; } }
public void add Observer (  Observer observer ) { if ( observer == null ) { throw new  Null Pointer Exception ( ) ; } synchronized ( this ) { if ( ! observers . contains ( observer ) ) observers . add ( observer ) ; } }
public double distance (  Vec x ,  List <  Double > qi , int k ) { if ( k >= mean Sqrd Norms . length || k < _ NUM ) throw new  Index Out Of Bounds Exception ( _ STR + mean Sqrd Norms . length + _ STR + k + _ STR ) ; return  Math . sqrt (  Math . max ( kernel . eval ( _ NUM , _ NUM ,  Arrays . as List ( x ) , qi ) - _ NUM / ownes [ k ] * eval Sum K ( x , qi , k , new Designations ) + mean Sqrd Norms [ k ] * norm Consts [ k ] , _ NUM ) ) ; }
public  String process Pattern (  String new Pattern ) throws  Illegal Argument Exception { int idx = _ NUM ; int offnum = - _ NUM ;  String Buffer outpat = new  String Buffer ( ) ; offsets = new int [  BUFSIZE ] ; arguments = new  String [  BUFSIZE ] ; max Offset = - _ NUM ; while ( _ BOOL ) { int ridx = - _ NUM ; int lidx = new Pattern . index Of ( ldel , idx ) ; if ( lidx >= _ NUM ) { ridx = new Pattern . index Of ( rdel , lidx + ldel . length ( ) ) ; } else { break ; } if ( ++ offnum >=  BUFSIZE ) { throw new  Illegal Argument Exception ( _ STR ) ; } if ( ridx < _ NUM ) { if ( exactmatch ) { throw new  Illegal Argument Exception ( _ STR ) ; } else { break ; } } outpat . append ( new Pattern . substring ( idx , lidx ) ) ; offsets [ offnum ] = outpat . length ( ) ; arguments [ offnum ] = new Pattern . substring ( lidx + ldel . length ( ) , ridx ) ; idx = ridx + rdel . length ( ) ; max Offset ++ ; } outpat . append ( new Pattern . substring ( idx ) ) ; return outpat . to String ( ) ; }
void retain (  Object owner ,  Field field ) { retain ( ) ;  Map <  String ,  Integer > fields = owners . get ( owner ) ; if ( fields == null ) { fields = new  Hash Map < > ( ) ; owners . put ( owner , fields ) ; }  Integer count = fields . get ( field . to Generic String ( ) ) ; if ( count == null ) { fields . put ( field . to Generic String ( ) , _ NUM ) ; } else { count ++ ; fields . put ( field . to Generic String ( ) , count ) ; } }
public static  List <  Annotation Dto > transform To Dto (  List <  Annotation > annotations ) { if ( annotations == null ) { throw new  Web Application Exception ( _ STR ,  Status .  INTERNAL_ SERVER_ ERROR ) ; }  List <  Annotation Dto > result = new  Array List < > ( ) ; for (  Annotation annotation : annotations ) { result . add ( transform To Dto ( annotation ) ) ; } return result ; }
final boolean claim ( ) {  Executor e = executor ; if ( compare And Set Fork Join Task Tag ( ( short ) _ NUM , ( short ) _ NUM ) ) { if ( e == null ) return _ BOOL ; executor = null ; e . execute ( this ) ; } return _ BOOL ; }
public void remove Group Properties Listener (  Group Properties Listener group Properties Listener ) { group Properties Listeners . remove ( group Properties Listener ) ; }
public static void edit Global Edge Comment ( final  Abstract SQLProvider provider , final  INavi Edge edge , final  Integer comment Id , final  Integer user Id , final  String new Comment ) throws  Couldnt Save Data Exception {  Preconditions . check Not Null ( provider , _ STR ) ;  Preconditions . check Not Null ( edge , _ STR ) ;  Preconditions . check Not Null ( comment Id , _ STR ) ;  Preconditions . check Not Null ( user Id , _ STR ) ;  Postgre SQLComment Functions . edit Comment ( provider , comment Id , user Id , new Comment ) ; }
public  Element store (  Object o ) {  Portal Icon p = (  Portal Icon ) o ; if ( ! p . is Active ( ) ) { return null ; }  Element element = new  Element ( _ STR ) ; store Common Attributes ( p , element ) ; element . set Attribute ( _ STR ,  String . value Of ( p . get Scale ( ) ) ) ; element . set Attribute ( _ STR ,  String . value Of ( p . get Degrees ( ) ) ) ;  Portal portal = p . get Portal ( ) ; if ( portal == null ) { log . info ( _ STR ) ; return null ; } element . set Attribute ( _ STR , portal . get Name ( ) ) ; if ( portal . get To Block ( ) != null ) { element . set Attribute ( _ STR , portal . get To Block Name ( ) ) ; } if ( portal . get From Block Name ( ) != null ) { element . set Attribute ( _ STR , portal . get From Block Name ( ) ) ; } element . set Attribute ( _ STR , _ STR + ( p . get Arrow Switch ( ) ? _ STR : _ STR ) ) ; element . set Attribute ( _ STR , _ STR + ( p . get Arrow Hide ( ) ? _ STR : _ STR ) ) ; element . set Attribute ( _ STR , _ STR ) ; return element ; }
public synchronized void clear Sessions (  Context context ,  Boolean clear Credentials ) { synchronized (  LOG_ TAG ) { while ( m MXSessions . size ( ) > _ NUM ) { clear Session ( context , m MXSessions . get ( _ NUM ) , clear Credentials ) ; } } }
protected void remove Domain (  SSOToken token ,  String org DN ) throws  AMException { try {  Persistent Object po =  UMSObject . get Object ( token , new  Guid ( org DN ) ) ; if ( ! ( po instanceof com . iplanet . ums .  Organization ) ) { if ( debug . message Enabled ( ) ) { debug . message ( _ STR + org DN + _ STR ) ; } return ; }  String domain Name = get Canonical Domain ( token , org DN ) ; if ( debug . message Enabled ( ) ) { debug . message ( _ STR + _ STR + domain Name ) ; } if ( ( domain Name != null ) && ( domain Name . length ( ) > _ NUM ) ) {  Domain Component Tree dc Tree = new  Domain Component Tree ( token , new  Guid (  DCTREE_ START_ DN ) ) ; if ( debug . message Enabled ( ) ) { debug . message ( _ STR + domain Name ) ; } dc Tree . remove Domain ( domain Name ) ; } else { if ( debug . warning Enabled ( ) ) { debug . warning ( _ STR + _ STR + org DN ) ; } } } catch (  UMSException ue ) { if ( debug . warning Enabled ( ) ) { debug . warning ( _ STR , ue ) ; } } }
private double [ ] line Intersect ( double x1 , double y1 , double x2 , double y2 , double x , double y , double offset ) { double xval ; double yval ; double xn = - _ NUM , yn = - _ NUM ; double change ; if ( x == _ NUM ) { if ( ( x1 <= offset && offset < x2 ) || ( x1 >= offset && offset > x2 ) ) { xval = x1 - x2 ; change = ( offset - x2 ) / xval ; yn = ( y1 - y2 ) * change + y2 ; if ( _ NUM <= yn && yn <= y ) { xn = offset ; } else { xn = - _ NUM ; } } } else if ( y == _ NUM ) { if ( ( y1 <= offset && offset < y2 ) || ( y1 >= offset && offset > y2 ) ) { yval = ( y1 - y2 ) ; change = ( offset - y2 ) / yval ; xn = ( x1 - x2 ) * change + x2 ; if ( _ NUM <= xn && xn <= x ) { yn = offset ; } else { xn = - _ NUM ; } } } double [ ] ret = new double [ _ NUM ] ; ret [ _ NUM ] = xn ; ret [ _ NUM ] = yn ; return ret ; }
private void create Partition Region (  List vm List , int start Index For Region , int end Index For Region , int local Max Memory , int redundancy ) {  Iterator node Iterator = vm List . iterator ( ) ; while ( node Iterator . has Next ( ) ) {  VM vm = (  VM ) node Iterator . next ( ) ; vm . invoke ( create Multiple PRWith Total Num Bucket Prop Set ( pr Prefix , start Index For Region , end Index For Region , redundancy , local Max Memory , _ NUM ) ) ; } }
public static  Z1 genc (  Zmat  A , int r1 , int r2 , int c ) throws  Jampack Exception { int i , ru ; double norm ; double s ;  Z scale ;  Z t = new  Z ( ) ;  Z t1 = new  Z ( ) ; c = c -  A . basex ; r1 = r1 -  A . basex ; r2 = r2 -  A . basex ; ru = r2 - r1 + _ NUM ;  Z1 u = new  Z1 ( r2 - r1 + _ NUM ) ; for ( i = r1 ; i <= r2 ; i ++ ) { u . put ( i - r1 ,  A . re [ i ] [ c ] ,  A . im [ i ] [ c ] ) ;  A . re [ i ] [ c ] = _ NUM ;  A . im [ i ] [ c ] = _ NUM ; } norm =  Norm . fro ( u ) ; if ( r1 == r2 || norm == _ NUM ) {  A . re [ r1 ] [ c ] = - u . re [ _ NUM ] ;  A . im [ r1 ] [ c ] = - u . im [ _ NUM ] ; u . put ( _ NUM ,  Math . sqrt ( _ NUM ) , _ NUM ) ; return u ; } scale = new  Z ( _ NUM / norm , _ NUM ) ; if ( u . re [ _ NUM ] != _ NUM || u . im [ _ NUM ] != _ NUM ) { t = u . get ( _ NUM ) ; scale .  Times ( scale , t .  Div ( t1 .  Conj ( t ) ,  Z . abs ( t ) ) ) ; }  A . put ( r1 +  A . basex , c +  A . basex , t .  Minus ( t .  Div (  Z .  ONE , scale ) ) ) ; for ( i = _ NUM ; i < ru ; i ++ ) { u .  Times ( i , scale ) ; } u . re [ _ NUM ] = u . re [ _ NUM ] + _ NUM ; u . im [ _ NUM ] = _ NUM ; s =  Math . sqrt ( _ NUM / u . re [ _ NUM ] ) ; for ( i = _ NUM ; i < ru ; i ++ ) { u . re [ i ] = s * u . re [ i ] ; u . im [ i ] = s * u . im [ i ] ; } return u ; }
private void build Network ( final  Network network , int [ ] nodes Per Layer ,  Point2 D initial Position , final  Neuron input Neuron Template ) { set Label ( _ STR ) ;  List <  Neuron > input Layer Neurons = new  Array List <  Neuron > ( ) ; for ( int i = _ NUM ; i < nodes Per Layer [ _ NUM ] ; i ++ ) { input Layer Neurons . add ( new  Neuron ( network , input Neuron Template ) ) ; }  Neuron Group input Layer = new  Neuron Group ( network , input Layer Neurons ) ; input Layer . set Clamped ( _ BOOL ) ; add Neuron Group ( input Layer ) ; input Layer . set Layout Based On Size ( initial Position ) ;  Synapse synapse =  Synapse . get Template Synapse ( new  Static Synapse Rule ( ) ) ; synapse . set Lower Bound ( - _ NUM ) ; synapse . set Upper Bound ( _ NUM ) ;  Neuron Group last Layer = input Layer ; for ( int i = _ NUM ; i < nodes Per Layer . length ; i ++ ) {  List <  Neuron > hidden Layer Neurons = new  Array List <  Neuron > ( ) ; for ( int j = _ NUM ; j < nodes Per Layer [ i ] ; j ++ ) {  Sigmoidal Rule rule = new  Sigmoidal Rule ( ) ;  Neuron neuron = new  Neuron ( network , rule ) ; rule . set Lower Bound ( _ NUM ) ; neuron . set Update Priority ( i ) ; hidden Layer Neurons . add ( neuron ) ; }  Neuron Group hidden Layer = new  Neuron Group ( network , hidden Layer Neurons ) ; hidden Layer . set Layout Based On Size ( ) ; add Neuron Group ( hidden Layer ) ;  Network Layout Manager . offset Neuron Group ( last Layer , hidden Layer ,  Direction .  NORTH , between Layer Interval ) ;  All To All connection = new  All To All ( ) ;  Synapse Group lh = connect Neuron Groups ( last Layer , hidden Layer , connection ) ; lh . randomize Connection Weights ( ) ; last Layer = hidden Layer ; } }
private static boolean are Equal ( int from Index ,  Char Sequence left ,  Char Sequence right ) { if ( left == right ) return _ BOOL ; if ( ( left == null ) || ( right == null ) ) return _ BOOL ; int n = left . length ( ) ; if ( right . length ( ) != n ) return _ BOOL ; for ( int i = n ; i > from Index ; ) { if ( left . char At ( -- i ) != right . char At ( i ) ) return _ BOOL ; } return _ BOOL ; }
public  Enumeration enumurate Queue ( ) {  Vector elements = new  Vector ( ) ; synchronized (  LOCK ) {  Enumeration e = pending . elements ( ) ; while ( e . has More Elements ( ) ) { elements . add Element ( e . next Element ( ) ) ; } } return elements . elements ( ) ; }
public void add Tight Source Node (  ASTNode reference ) { f Tight Source Range Nodes . add ( reference ) ;  List <  Structural Property Descriptor > properties = reference . structural Properties For Type ( ) ; for (  Iterator <  Structural Property Descriptor > iterator = properties . iterator ( ) ; iterator . has Next ( ) ; ) {  Structural Property Descriptor descriptor = iterator . next ( ) ; if ( descriptor . is Child Property ( ) ) {  ASTNode child = (  ASTNode ) reference . get Structural Property ( descriptor ) ; if ( child != null && is Extending ( child , reference ) ) { add Tight Source Node ( child ) ; } } else if ( descriptor . is Child List Property ( ) ) {  List < ? extends  ASTNode > children =  ASTNodes . get Child List Property ( reference , (  Child List Property Descriptor ) descriptor ) ; for (  Iterator < ? extends  ASTNode > iterator2 = children . iterator ( ) ; iterator2 . has Next ( ) ; ) {  ASTNode child = iterator2 . next ( ) ; if ( is Extending ( child , reference ) ) { add Tight Source Node ( child ) ; } } } } }
protected boolean is Event Disabled (  XEvent e ) { if ( enable Log . is Loggable (  Platform Logger .  Level .  FINEST ) ) { enable Log . finest ( _ STR , e , ( is Enabled ( ) ? _ STR : _ STR ) ) ; } if ( ! is Enabled ( ) ) { switch ( e . get_type ( ) ) { case  XConstants .  Button Press : case  XConstants .  Button Release : case  XConstants .  Key Press : case  XConstants .  Key Release : case  XConstants .  Enter Notify : case  XConstants .  Leave Notify : case  XConstants .  Motion Notify : if ( enable Log . is Loggable (  Platform Logger .  Level .  FINER ) ) { enable Log . finer ( _ STR , e ) ; } return _ BOOL ; } } switch ( e . get_type ( ) ) { case  XConstants .  Map Notify : case  XConstants .  Unmap Notify : return _ BOOL ; } return super . is Event Disabled ( e ) ; }
public  DSystem Information (  JFrame parent ) { super ( parent , res . get String ( _ STR ) ,  Modality Type .  DOCUMENT_ MODAL ) ; init Components ( ) ; }
public static void write (  OMLine line ,  Link link ,  Link Properties props ) throws  IOException { switch ( line . get Render Type ( ) ) { case  OMLine .  RENDERTYPE_ LATLON : double [ ] ll = line . get LL ( ) ;  Link Line . write ( ( float ) ll [ _ NUM ] , ( float ) ll [ _ NUM ] , ( float ) ll [ _ NUM ] , ( float ) ll [ _ NUM ] , line . get Line Type ( ) , line . get Num Segs ( ) , props , link . dos ) ; break ; case  OMLine .  RENDERTYPE_ XY : int [ ] pts = line . get Pts ( ) ;  Link Line . write ( pts [ _ NUM ] , pts [ _ NUM ] , pts [ _ NUM ] , pts [ _ NUM ] , props , link . dos ) ; break ; case  OMLine .  RENDERTYPE_ OFFSET : ll = line . get LL ( ) ; pts = line . get Pts ( ) ;  Link Line . write ( ( float ) ll [ _ NUM ] , ( float ) ll [ _ NUM ] , pts [ _ NUM ] , pts [ _ NUM ] , pts [ _ NUM ] , pts [ _ NUM ] , props , link . dos ) ; break ; default :  Debug . error ( _ STR ) ; } }
private void convert Outer Join ( final  String Builder target , final  Char Sequence outer Join ) throws  FBSQLParse Exception { target . append ( outer Join ) ; }
public void add Listener (  Tap Listener listener ) { if ( ! m Listeners . contains ( listener ) ) { m Listeners . add ( listener ) ; } }
public static  Tree build Tree (  Rule rule ,  List <  HGNode > tail Nodes , int max Depth ) {  Tree tree = get Fragment From Yield ( rule . get English Words ( ) ) ; if ( tree == null ) { tree = new  Tree (  String . format ( _ STR ,  Vocabulary . word ( rule . get LHS ( ) ) , rule . get English Words ( ) ) ) ; } else { tree = tree . shallow Clone ( ) ; } if ( tree != null && tail Nodes != null && tail Nodes . size ( ) > _ NUM && max Depth > _ NUM ) {  List <  Tree > frontier = tree . get Nonterminal Yield ( ) ;  Array List <  Integer > tail Indices = new  Array List < > ( ) ; int [ ] english Ints = rule . get English ( ) ; for ( int english Int : english Ints ) if ( english Int < _ NUM ) tail Indices . add ( - _ NUM * english Int - _ NUM ) ; for ( int i = _ NUM ; i < tail Nodes . size ( ) ; i ++ ) { try {  Tree frontier Tree = frontier . get ( tail Indices . get ( i ) ) ; frontier Tree . set Boundary ( _ BOOL ) ;  Hyper Edge edge = tail Nodes . get ( i ) . best Hyperedge ; if ( edge != null ) {  Tree child Tree = build Tree ( edge . get Rule ( ) , edge . get Tail Nodes ( ) , max Depth - _ NUM ) ; if ( child Tree != null ) frontier Tree . children = child Tree . children ; } else { frontier Tree . children = tree . children ; } } catch (  Index Out Of Bounds Exception e ) {  LOG . error ( _ STR , i ) ;  LOG . error ( _ STR , rule . get English Words ( ) , tree ) ;  LOG . error ( _ STR ) ; for (  Tree kid : frontier ) {  LOG . error ( _ STR , kid ) ; } throw new  Runtime Exception (  String . format ( _ STR , i ) , e ) ; } } } return tree ; }
public  Packet Output Stream write Date Length ( final  Calendar calendar ) { assure Buffer Capacity ( _ NUM ) ; buffer . put ( ( byte ) _ NUM ) ; buffer . put Short ( ( short ) calendar . get (  Calendar .  YEAR ) ) ; buffer . put ( ( byte ) ( ( calendar . get (  Calendar .  MONTH ) + _ NUM ) & _ NUM ) ) ; buffer . put ( ( byte ) ( calendar . get (  Calendar .  DAY_ OF_ MONTH ) & _ NUM ) ) ; buffer . put ( ( byte ) _ NUM ) ; buffer . put ( ( byte ) _ NUM ) ; buffer . put ( ( byte ) _ NUM ) ; return this ; }
public static void play ( double sample ) { if (  Double . is Na N ( sample ) ) throw new  Illegal Argument Exception ( _ STR ) ; if ( sample < - _ NUM ) sample = - _ NUM ; if ( sample > + _ NUM ) sample = + _ NUM ; short s = ( short ) (  MAX_16_ BIT * sample ) ; buffer [ buffer Size ++ ] = ( byte ) s ; buffer [ buffer Size ++ ] = ( byte ) ( s > > _ NUM ) ; if ( buffer Size >= buffer . length ) { line . write ( buffer , _ NUM , buffer . length ) ; buffer Size = _ NUM ; } }
private boolean is Message From User (  Message message ,  User user ) {  String user Id = null ; boolean is My Message = _ BOOL ; if ( message . user != null && message . user . user ID != null ) { user Id = message . user . user ID ; } else { user Id = message . user ID ; } if ( user Id . equals ( user . user ID ) ) { is My Message = _ BOOL ; } if ( message . type ==  Const .  Message Type .  TYPE_ NEW_ USER || message . type ==  Const .  Message Type .  TYPE_ USER_ LEAVE ) { is My Message = _ BOOL ; } return is My Message ; }
public static  Socket create Loopback Socket ( int port , boolean ssl ) throws  IOException {  Inet Address address = get Bind Address ( ) ; if ( address == null ) { address =  Inet Address . get Local Host ( ) ; } try { return create Socket ( get Host Address ( address ) , port , ssl ) ; } catch (  IOException e ) { try { return create Socket ( _ STR , port , ssl ) ; } catch (  IOException e2 ) { throw e ; } } }
private static  String correct Reserved Word (  String str ) { char first = str . char At ( _ NUM ) ; switch ( first ) { case _ STR : if ( str . equals ( _ STR ) ) return _ STR + str ; break ; case _ STR : if ( str . equals ( _ STR ) ) return _ STR + str ; else if ( str . equals ( _ STR ) ) return _ STR + str ; else if ( str . equals ( _ STR ) ) return _ STR + str ; break ; case _ STR : if ( str . equals ( _ STR ) ) return _ STR + str ; else if ( str . equals ( _ STR ) ) return _ STR + str ; else if ( str . equals ( _ STR ) ) return _ STR + str ; else if ( str . equals ( _ STR ) ) return _ STR + str ; else if ( str . equals ( _ STR ) ) return _ STR + str ; else if ( str . equals ( _ STR ) ) return _ STR + str ; break ; case _ STR : if ( str . equals ( _ STR ) ) return _ STR + str ; else if ( str . equals ( _ STR ) ) return _ STR + str ; else if ( str . equals ( _ STR ) ) return _ STR + str ; break ; case _ STR : if ( str . equals ( _ STR ) ) return _ STR + str ; else if ( str . equals ( _ STR ) ) return _ STR + str ; else if ( str . equals ( _ STR ) ) return _ STR + str ; break ; case _ STR : if ( str . equals ( _ STR ) ) return _ STR + str ; else if ( str . equals ( _ STR ) ) return _ STR + str ; else if ( str . equals ( _ STR ) ) return _ STR + str ; else if ( str . equals ( _ STR ) ) return _ STR + str ; else if ( str . equals ( _ STR ) ) return _ STR + str ; break ; case _ STR : if ( str . equals ( _ STR ) ) return _ STR + str ; break ; case _ STR : if ( str . equals ( _ STR ) ) return _ STR + str ; else if ( str . equals ( _ STR ) ) return _ STR + str ; else if ( str . equals ( _ STR ) ) return _ STR + str ; else if ( str . equals ( _ STR ) ) return _ STR + str ; else if ( str . equals ( _ STR ) ) return _ STR + str ; else if ( str . equals ( _ STR ) ) return _ STR + str ; break ; case _ STR : if ( str . equals ( _ STR ) ) return _ STR + str ; else if ( str . equals ( _ STR ) ) return _ STR + str ; else if ( str . equals ( _ STR ) ) return _ STR + str ; break ; case _ STR : if ( str . equals ( _ STR ) ) return _ STR + str ; else if ( str . equals ( _ STR ) ) return _ STR + str ; else if ( str . equals ( _ STR ) ) return _ STR + str ; else if ( str . equals ( _ STR ) ) return _ STR + str ; break ; case _ STR : if ( str . equals ( _ STR ) ) return _ STR + str ; break ; case _ STR : if ( str . equals ( _ STR ) ) return _ STR + str ; else if ( str . equals ( _ STR ) ) return _ STR + str ; else if ( str . equals ( _ STR ) ) return _ STR + str ; else if ( str . equals ( _ STR ) ) return _ STR + str ; else if ( str . equals ( _ STR ) ) return _ STR + str ; else if ( str . equals ( _ STR ) ) return _ STR + str ; break ; case _ STR : if ( str . equals ( _ STR ) ) return _ STR + str ; else if ( str . equals ( _ STR ) ) return _ STR + str ; else if ( str . equals ( _ STR ) ) return _ STR + str ; else if ( str . equals ( _ STR ) ) return _ STR + str ; else if ( str . equals ( _ STR ) ) return _ STR + str ; else if ( str . equals ( _ STR ) ) return _ STR + str ; break ; case _ STR : if ( str . equals ( _ STR ) ) return _ STR + str ; else if ( str . equals ( _ STR ) ) return _ STR + str ; break ; case _ STR : if ( str . equals ( _ STR ) ) return _ STR + str ; break ; } return str ; }
protected void handle Install Request Failure (  Member State member ,  Install Request request ,  Throwable error ) { fail Attempt ( member , error ) ; }
public  List <  Statistics > load All Deep From Cursor (  Cursor cursor ) { int count = cursor . get Count ( ) ;  List <  Statistics > list = new  Array List <  Statistics > ( count ) ; if ( cursor . move To First ( ) ) { if ( identity Scope != null ) { identity Scope . lock ( ) ; identity Scope . reserve Room ( count ) ; } try { do { list . add ( load Current Deep ( cursor , _ BOOL ) ) ; } while ( cursor . move To Next ( ) ) ; } finally { if ( identity Scope != null ) { identity Scope . unlock ( ) ; } } } return list ; }
public static  String decode (  Byte Buffer buff ) throws  Character Coding Exception {  Char Buffer chars =  UTF8 Decoder . decode ( buff ) ; return chars . to String ( ) ; }
protected void load Edits Single ( final  Map <  String ,  String > tags ) {  Linear Layout row Layout = (  Linear Layout ) get Our View ( ) ;  Linked Hash Map <  String ,  Array List <  String > > converted Tags = new  Linked Hash Map <  String ,  Array List <  String > > ( ) ; for (  String key : tags . key Set ( ) ) {  Array List <  String > v = new  Array List <  String > ( ) ; v . add ( tags . get ( key ) ) ; converted Tags . put ( key , v ) ; } load Edits ( row Layout , converted Tags ) ; }
public boolean write Next Part ( byte [ ] data ) throws  JPlag Exception { if ( remaining Bytes < data . length ) { throw new  JPlag Exception ( _ STR , _ STR + _ STR , _ STR ) ; } try {  File Output Stream out = new  File Output Stream ( file , _ BOOL ) ; out . write ( data ) ; out . close ( ) ; remaining Bytes -= data . length ; } catch (  IOException e ) { e . print Stack Trace ( ) ; throw new  JPlag Exception ( _ STR , _ STR + _ STR , _ STR ) ; } return remaining Bytes == _ NUM ; }
public boolean by Pass Control To Processor ( boolean flag ) { return _ BOOL ; }
public void update Width ( ) { if ( m_ Sum Of Weights > _ NUM ) { double mean = m_ Weighted Sum / m_ Sum Of Weights ; double variance = m_ Weighted Sum Squared / m_ Sum Of Weights - mean * mean ; if ( variance < _ NUM ) { variance = _ NUM ; } m_ Width =  Math . sqrt ( variance ) *  Math . pow ( m_ Sum Of Weights , m_ Exponent ) ; if ( m_ Width <= m_ Min Width ) { m_ Width = m_ Min Width ; } } else { m_ Width =  Double .  MAX_ VALUE ; } }
private  Group parse Group Result (  Result Set result Set ) throws  SQLException ,  Ade Internal Exception { int uid = result Set . get Int ( _ STR ) ;  String name = result Set . get String ( _ STR ) ;  Short group Type Val = result Set . get Short ( _ STR ) ;  Group Type group Type =  Group Type . get Group Type ( group Type Val ) ;  Short data Type Val = result Set . get Short ( _ STR ) ;  Data Type data Type =  Data Type . get Data Type ( data Type Val ) ; short evaluation Order = result Set . get Short ( _ STR ) ; int rid = result Set . get Int ( _ STR ) ;  String rule Name = get Rule Name ( rid ) ; return new  Group ( uid , name , group Type , data Type , evaluation Order , rule Name ) ; }
private void calcoffset ( int index , boolean do Extend ,  Point2 D result ) { double bx = data [ index - _ NUM ] ; double by = data [ index - _ NUM ] ; double px = result . get X ( ) - bx ; double py = result . get Y ( ) - by ; double dx = data [ index ] - bx ; double dy = data [ index + _ NUM ] - by ; double l = data [ index + _ NUM ] - data [ index - _ NUM ] ; double rx = ( px * dx + py * dy ) / l ; double ry = ( px * - dy + py * dx ) / l ; if ( ! do Extend ) { if ( rx < _ NUM ) rx = _ NUM ; else if ( rx > l ) rx = l ; } rx += data [ index - _ NUM ] ; result . set Location ( rx , ry ) ; }
public static int find Global Valley Location ( float [ ] data ) { float min =  Float .  Na N ; int imin = - _ NUM ; for ( int i = _ NUM ; i < data . length ; i ++ ) { if (  Float . is Na N ( data [ i ] ) ) continue ; if (  Float . is Na N ( min ) || data [ i ] < min ) { min = data [ i ] ; imin = i ; } } return imin ; }
protected void move Up Selected ( ) { int selected Index = table . get Selected Row ( ) ; if ( selected Index > - _ NUM ) { int index = data . move Up ( index To Model ( selected Index ) ) ; set Row Selected ( index To View ( index ) ) ; } }
private void copy Schedule Into Frontier ( final int min Capacity , final  Iterator <  Value > itr ) { backing . ensure Capacity ( min Capacity ) ; final  Value [ ] a = backing . array ( ) ; int nvertices = _ NUM ; while ( itr . has Next ( ) ) { final  Value v = itr . next ( ) ; a [ nvertices ++ ] = v ; } for ( int i = nvertices ; i < a . length ; i ++ ) { if ( a [ i ] == null ) break ; a [ i ] = null ; } this . vertices = backing . slice ( _ NUM , nvertices ) ; }
@  Override public void shutdown Now ( ) { if ( ! is Open ( ) ) return ; open = _ BOOL ; if ( log . is Info Enabled ( ) ) log . info ( _ STR ) ; final long begin =  System . current Time Millis ( ) ; tx Write Service . shutdown Now ( ) ; read Service . shutdown Now ( ) ; write Service . shutdown Now ( ) ; if ( sample Service != null ) sample Service . shutdown Now ( ) ; final long elapsed =  System . current Time Millis ( ) - begin ; if ( log . is Info Enabled ( ) ) log . info ( _ STR + elapsed + _ STR ) ; }
private static boolean update Index ( final  Project project , final  Virtual File root , final  Collection <  File Path > added , final  Collection <  File Path > removed , final  List <  Vcs Exception > exceptions ) { boolean rc = _ BOOL ; if ( ! added . is Empty ( ) ) { try {  Git File Utils . add Paths ( project , root , added ) ; } catch (  Vcs Exception ex ) { exceptions . add ( ex ) ; rc = _ BOOL ; } } if ( ! removed . is Empty ( ) ) { try {  Git File Utils . delete ( project , root , removed , _ STR ) ; } catch (  Vcs Exception ex ) { exceptions . add ( ex ) ; rc = _ BOOL ; } } return rc ; }
public static  Aion Client Packet handle (  Byte Buffer data ,  Login Connection client ) {  Aion Client Packet msg = null ;  State state = client . get State ( ) ; int id = data . get ( ) & _ NUM ; switch ( state ) { case  CONNECTED : { switch ( id ) { case _ NUM : msg = new  CM_ AUTH_ GG ( data , client ) ; break ; case _ NUM : msg = new  CM_ UPDATE_ SESSION ( data , client ) ; break ; default : unknown Packet ( state , id ) ; } break ; } case  AUTHED_ GG : { switch ( id ) { case _ NUM : msg = new  CM_ LOGIN ( data , client ) ; break ; default : unknown Packet ( state , id ) ; } break ; } case  AUTHED_ LOGIN : { switch ( id ) { case _ NUM : msg = new  CM_ SERVER_ LIST ( data , client ) ; break ; case _ NUM : msg = new  CM_ PLAY ( data , client ) ; break ; default : unknown Packet ( state , id ) ; } break ; } } return msg ; }
public static  Content Values [ ] values ( long restaurant Id ,  Place place ) {  List <  Opening Hours > hours = place . get Opening Hours ( ) ; if ( ! hours . is Empty ( ) ) { int size = hours . size ( ) ;  List <  Content Values > vals = new  Array List < > ( size * _ NUM ) ; for ( int i = _ NUM ; i < size ; i ++ ) {  Opening Hours hour = hours . get ( i ) ;  Day Of Week day = hour . get Open Day ( ) ; int time = hour . get Open Time ( ) ; if ( day != null && time >= _ NUM ) { vals . add ( values ( restaurant Id ,  OPEN , day , time ) ) ; } day = hour . get Close Day ( ) ; time = hour . get Close Time ( ) ; if ( day != null && time >= _ NUM ) { vals . add ( values ( restaurant Id ,  CLOSE , day , time ) ) ; } } return vals . to Array ( new  Content Values [ vals . size ( ) ] ) ; } return null ; }
public static  Vector3 ceil (  Vector3 o ) { return new  Vector3 (  Math . ceil ( o . x ) ,  Math . ceil ( o . y ) ,  Math . ceil ( o . z ) ) ; }
@  Override protected boolean is Frontier Empty ( ) { clean Up Frontier ( ) ; update Metrics ( frontier . size ( ) ) ; return frontier . is Empty ( ) ; }
private void parse Attributes (  Typed Array a ) { bar Width = ( int ) a . get Dimension (  R . styleable .  Progress Wheel_bar Width , bar Width ) ; rim Width = ( int ) a . get Dimension (  R . styleable .  Progress Wheel_rim Width , rim Width ) ; spin Speed = ( int ) a . get Dimension (  R . styleable .  Progress Wheel_spin Speed , spin Speed ) ; delay Millis = a . get Integer (  R . styleable .  Progress Wheel_delay Millis , delay Millis ) ; if ( delay Millis < _ NUM ) { delay Millis = _ NUM ; } bar Color = a . get Color (  R . styleable .  Progress Wheel_bar Color , bar Color ) ; bar Length = ( int ) a . get Dimension (  R . styleable .  Progress Wheel_bar Length , bar Length ) ; text Size = ( int ) a . get Dimension (  R . styleable .  Progress Wheel_text Size , text Size ) ; text Color = ( int ) a . get Color (  R . styleable .  Progress Wheel_text Color , text Color ) ; if ( a . has Value (  R . styleable .  Progress Wheel_text ) ) { set Text ( a . get String (  R . styleable .  Progress Wheel_text ) ) ; } rim Color = ( int ) a . get Color (  R . styleable .  Progress Wheel_rim Color , rim Color ) ; circle Color = ( int ) a . get Color (  R . styleable .  Progress Wheel_circle Color , circle Color ) ; contour Color = a . get Color (  R . styleable .  Progress Wheel_contour Color , contour Color ) ; contour Size = a . get Dimension (  R . styleable .  Progress Wheel_contour Size , contour Size ) ; a . recycle ( ) ; }
public static byte [ ] concatenate ( byte [ ] a , byte [ ] b ) { int length A = a . length ; int length B = b . length ; byte [ ] concat = new byte [ length A + length B ] ;  System . arraycopy ( a , _ NUM , concat , _ NUM , length A ) ;  System . arraycopy ( b , _ NUM , concat , length A , length B ) ; return concat ; }
private static void init Common Variable (  Calendar _calendar , boolean _trace Flag , int num User ) throws  Exception { initialize ( ) ; trace Flag = _trace Flag ; if ( _calendar == null ) { calendar =  Calendar . get Instance ( ) ; } else { calendar = _calendar ; }  Cloud Sim Shutdown shutdown = new  Cloud Sim Shutdown ( _ STR , num User ) ; shutdown Id = shutdown . get Id ( ) ; }
public static  Alert Dialog .  Builder show Update Available Dialog ( final  Activity activity ) { return show Update Available Dialog ( activity ,  R . string . you_are_not_updated_title ,  R . string . you_are_not_updated_message ,  R . string . yes ,  R . string . no ) ; }
public void map Volume To SCSIInitiator (  String volume Id ,  String initiator Id ) throws  Exception { log . info ( _ STR ) ;  String uri =  Scale IOConstants . get Map Volume To Scsi Initiator URI ( volume Id ) ;  Scale IOMap Volume To Scsi Initiator map Parm = new  Scale IOMap Volume To Scsi Initiator ( ) ; map Parm . set Scsi Initiator Id ( initiator Id ) ; map Parm . set Allow Multiple Mapp ( _ STR ) ; post (  URI . create ( uri ) , get Json For Entity ( map Parm ) ) ; }
public static <  T >  Collection <  T > not Empty (  Collection <  T > list ,  String name ) { not Null ( list , name ) ; if ( list . is Empty ( ) ) { throw new  Illegal Argument Exception (  String . format ( _ STR , name ) ) ; } return list ; }
public final void bounds ( int range ) { double x0 = cx0 ; double y0 = cy0 ; double x1 = cx0 + cx1 + cx2 + cx3 ; double y1 = cy0 + cy1 + cy2 + cy3 ; double minx =  Math . min ( x0 , x1 ) ; double miny =  Math . min ( y0 , y1 ) ; double maxx =  Math . max ( x0 , x1 ) ; double maxy =  Math . max ( y0 , y1 ) ; if ( cx3 != _ NUM ) { double t1 = - (  Math . sqrt ( cx2 * cx2 - _ NUM * cx1 * cx3 ) + cx2 ) / ( _ NUM * cx3 ) ; double t2 = (  Math . sqrt ( cx2 * cx2 - _ NUM * cx1 * cx3 ) - cx2 ) / ( _ NUM * cx3 ) ; if ( t1 > _ NUM && t1 < _ NUM ) { double x = eval X ( t1 ) ; minx =  Math . min ( x , minx ) ; maxx =  Math . max ( x , maxx ) ; } if ( t2 > _ NUM && t2 < _ NUM ) { double x = eval X ( t2 ) ; minx =  Math . min ( x , minx ) ; maxx =  Math . max ( x , maxx ) ; } } if ( cy3 != _ NUM ) { double t1 = - (  Math . sqrt ( cy2 * cy2 - _ NUM * cy1 * cy3 ) + cy2 ) / ( _ NUM * cy3 ) ; double t2 = (  Math . sqrt ( cy2 * cy2 - _ NUM * cy1 * cy3 ) - cy2 ) / ( _ NUM * cy3 ) ; if ( t1 > _ NUM && t1 < _ NUM ) { double y = eval Y ( t1 ) ; miny =  Math . min ( y , miny ) ; maxy =  Math . max ( y , maxy ) ; } if ( t2 > _ NUM && t2 < _ NUM ) { double y = eval Y ( t2 ) ; miny =  Math . min ( y , miny ) ; maxy =  Math . max ( y , maxy ) ; } } add Rect ( ( int ) minx - range , ( int ) miny - range , ( int ) ( maxx + range ) , ( int ) ( maxy + range ) ) ; }
public  Block split ( final  Line line ) { final  Block block = new  Block ( ) ; block . lines = this . lines ; block . line Tail = line ; this . lines = line . next ; line . next = null ; if ( this . lines == null ) { this . line Tail = null ; } else { this . lines . previous = null ; } if ( this . blocks == null ) { this . blocks = this . block Tail = block ; } else { this . block Tail . next = block ; this . block Tail = block ; } return block ; }
public static byte [ ] transceive And Get Response ( byte [ ] command ,  Iso Card iso Card ,  String get Response Apdu ) throws  IOException { byte [ ] resp = iso Card . transceive ( command ) ; byte [ ] buf = new byte [ _ NUM ] ; int offset = _ NUM ; while ( resp [ resp . length - _ NUM ] == _ NUM ) {  System . arraycopy ( resp , _ NUM , buf , offset , resp . length - _ NUM ) ; offset += resp . length - _ NUM ; resp = iso Card . transceive ( decode Hex ( get Response Apdu ) ) ; }  System . arraycopy ( resp , _ NUM , buf , offset , resp . length ) ; byte [ ] properly Sized = new byte [ offset + resp . length ] ;  System . arraycopy ( buf , _ NUM , properly Sized , _ NUM , properly Sized . length ) ; return properly Sized ; }
public void add Scanning Callback (  One Sheeld Scanning Callback scanning Callback ) { if ( scanning Callback != null && ! scanning Callbacks . contains ( scanning Callback ) ) scanning Callbacks . add ( scanning Callback ) ; }
public void write ( byte [ ] buf , int off , int len ) throws  TTransport Exception { if ( output Stream_ == null ) { throw new  TTransport Exception (  TTransport Exception .  NOT_ OPEN , _ STR ) ; } try { output Stream_ . write ( buf , off , len ) ; } catch (  IOException iox ) { throw new  TTransport Exception (  TTransport Exception .  UNKNOWN , iox ) ; } }
public void handle Gateway Receiver Stop (  Gateway Receiver recv ) throws  Management Exception { if ( ! is Service Initialised ( _ STR ) ) { return ; }  Gateway Receiver MBean mbean = (  Gateway Receiver MBean ) service . get Local Gateway Receiver MXBean ( ) ;  Gateway Receiver MBean Bridge bridge = mbean . get Bridge ( ) ; bridge . stop Server ( ) ;  Notification notification = new  Notification (  JMXNotification Type .  GATEWAY_ RECEIVER_ STOPPED , member Source ,  Sequence Number . next ( ) ,  System . current Time Millis ( ) ,  Management Constants .  GATEWAY_ RECEIVER_ STOPPED_ PREFIX ) ; member Level Notif Emitter . send Notification ( notification ) ; }
public static  List <  Property > diff (  Shape old Shape ,  Shape new Shape ) {  List <  Property > old List = old Shape . get Property List Internal ( _ BOOL ) ;  List <  Property > new List = new Shape . get Property List Internal ( _ BOOL ) ;  List <  Property > diff = new  Array List < > ( old List ) ; diff . add All ( new List ) ;  List <  Property > intersection = new  Array List < > ( old List ) ; intersection . retain All ( new List ) ; diff . remove All ( intersection ) ; return diff ; }
public static boolean is Readable ( final  File file ) { if ( file == null || ! file . is File ( ) ) {  Log . e (  File Utils . class , _ STR ) ; return _ BOOL ; } return file . exists ( ) && file . can Read ( ) ; }
final public int read ( final byte [ ] a , final int aoff , final int alen ) throws  IOException { if ( alen == _ NUM ) { return _ NUM ; } final int remaining = limit - off ; if ( remaining == _ NUM ) { return - _ NUM ; } final int n = remaining < alen ? remaining : alen ;  System . arraycopy ( buf , this . off , a , aoff , n ) ; this . off += n ; return n ; }
public void delete Static Groups (  Set group DNs ) throws  AMException ,  SSOException {  Iterator iter = group DNs . iterator ( ) ; while ( iter . has Next ( ) ) {  String group DN = (  String ) iter . next ( ) ;  AMStatic Group group = new  AMStatic Group Impl ( token , group DN ) ; group . delete ( ) ; } }
public  String ( byte [ ] bytes , java . lang .  String enc ) throws java . io .  Unsupported Encoding Exception { this ( bytes To Chars ( bytes , _ NUM , bytes . length , enc ) ) ; }
private  FPTree build FPTree ( final  Relation <  Bit Vector > relation , int [ ] iidx , final int items ) {  FPTree tree = new  FPTree ( items ) ;  Finite Progress prog =  LOG . is Verbose ( ) ? new  Finite Progress ( _ STR , relation . size ( ) ,  LOG ) : null ; int [ ] buf = new int [ items ] ; for (  DBIDIter iditer = relation . iter DBIDs ( ) ; iditer . valid ( ) ; iditer . advance ( ) ) { int l = _ NUM ;  Sparse Feature Vector < ? > bv = relation . get ( iditer ) ; for ( int it = bv . iter ( ) ; bv . iter Valid ( it ) ; it = bv . iter Advance ( it ) ) { int i = iidx [ bv . iter Dim ( it ) ] ; if ( i < _ NUM ) { continue ; } buf [ l ++ ] = i ; } if ( l >= minlength ) {  Arrays . sort ( buf , _ NUM , l ) ; tree . insert ( buf , _ NUM , l , _ NUM ) ; }  LOG . increment Processed ( prog ) ; }  LOG . ensure Completed ( prog ) ; return tree ; }
private static  String layout Menu Item (  JComponent c ,  Font Metrics fm ,  String text ,  Font Metrics fm Accel ,  String accelerator Text ,  Icon icon ,  Icon check Icon ,  Icon arrow Icon , int vertical Alignment , int horizontal Alignment , int vertical Text Position , int horizontal Text Position ,  Rectangle view R ,  Rectangle icon R ,  Rectangle text R ,  Rectangle accelerator R ,  Rectangle check Icon R ,  Rectangle arrow Icon R , int text Icon Gap , int menu Item Gap ) {  Swing Utilities . layout Compound Label ( c , fm , text , icon , vertical Alignment , horizontal Alignment , vertical Text Position , horizontal Text Position , view R , icon R , text R , text Icon Gap ) ; if ( ( accelerator Text == null ) || accelerator Text . equals ( _ STR ) ) { accelerator R . width = accelerator R . height = _ NUM ; accelerator Text = _ STR ; } else { accelerator R . width =  Swing Utilities2 . string Width ( c , fm Accel , accelerator Text ) ; accelerator R . height = fm Accel . get Height ( ) ; } if ( check Icon != null ) { check Icon R . width = check Icon . get Icon Width ( ) ; check Icon R . height = check Icon . get Icon Height ( ) ; } else { check Icon R . width = check Icon R . height = _ NUM ; } if ( arrow Icon != null ) { arrow Icon R . width = arrow Icon . get Icon Width ( ) ; arrow Icon R . height = arrow Icon . get Icon Height ( ) ; } else { arrow Icon R . width = arrow Icon R . height = _ NUM ; }  Rectangle label R = icon R . union ( text R ) ; if (  Motif Graphics Utils . is Left To Right ( c ) ) { text R . x += check Icon R . width + menu Item Gap ; icon R . x += check Icon R . width + menu Item Gap ; accelerator R . x = view R . x + view R . width - arrow Icon R . width - menu Item Gap - accelerator R . width ; check Icon R . x = view R . x ; arrow Icon R . x = view R . x + view R . width - menu Item Gap - arrow Icon R . width ; } else { text R . x -= ( check Icon R . width + menu Item Gap ) ; icon R . x -= ( check Icon R . width + menu Item Gap ) ; accelerator R . x = view R . x + arrow Icon R . width + menu Item Gap ; check Icon R . x = view R . x + view R . width - check Icon R . width ; arrow Icon R . x = view R . x + menu Item Gap ; } accelerator R . y = label R . y + ( label R . height / _ NUM ) - ( accelerator R . height / _ NUM ) ; arrow Icon R . y = label R . y + ( label R . height / _ NUM ) - ( arrow Icon R . height / _ NUM ) ; check Icon R . y = label R . y + ( label R . height / _ NUM ) - ( check Icon R . height / _ NUM ) ; return text ; }
protected int read (  Input Stream input Stream , byte [ ] buffer , int offset , int length ) throws  IOException { int read Length = input Stream . read ( buffer , offset , length ) ; if ( read Length != length ) { throw new  IOException ( _ STR ) ; } return read Length ; }
private  Cuboid (  String world Name , int x1 , int y1 , int z1 , int x2 , int y2 , int z2 ) { this . world Name = world Name ; this . x1 =  Math . min ( x1 , x2 ) ; this . x2 =  Math . max ( x1 , x2 ) ; this . y1 =  Math . min ( y1 , y2 ) ; this . y2 =  Math . max ( y1 , y2 ) ; this . z1 =  Math . min ( z1 , z2 ) ; this . z2 =  Math . max ( z1 , z2 ) ; }
public double log Marginal Likelihood Harmonic (  List <  Double > v ) { double sum = _ NUM ; final int size = v . size ( ) ; for ( int i = _ NUM ; i < size ; i ++ ) sum += v . get ( i ) ; double denominator =  Log Tricks . log Zero ; for ( int i = _ NUM ; i < size ; i ++ ) denominator =  Log Tricks . log Sum ( denominator , sum - v . get ( i ) ) ; return sum - denominator +  Strict Math . log ( size ) ; }
public boolean is Destroy Message ( ) { if ( message == null ) { throw new  Illegal State Exception ( _ STR ) ; } return ! callee . equals ( _ STR ) && ( message . equals ( _ STR ) || message . starts With ( _ STR ) ) ; }
public void test Bug20685022 ( ) throws  Exception { if ( ! is Community Edition ( ) ) { return ; } final  Properties props = new  Properties ( ) ; props . clear ( ) ; props . set Property ( _ STR , _ STR ) ; props . set Property ( _ STR , _ STR ) ; props . set Property ( _ STR , _ STR ) ; get Connection With Props ( props ) ; props . clear ( ) ; props . set Property ( _ STR , _ STR ) ; props . set Property ( _ STR , _ STR ) ; props . set Property ( _ STR , _ STR ) ; props . set Property ( _ STR , _ STR ) ; props . set Property ( _ STR , _ STR ) ; props . set Property ( _ STR , _ STR ) ; get Connection With Props ( props ) ; props . clear ( ) ; props . set Property ( _ STR , _ STR ) ; props . set Property ( _ STR , _ STR ) ; props . set Property ( _ STR , _ STR ) ;  String trust Store Path = _ STR ;  System . set Property ( _ STR , trust Store Path ) ;  System . set Property ( _ STR , _ STR ) ;  System . set Property ( _ STR , trust Store Path ) ;  System . set Property ( _ STR , _ STR ) ; get Connection With Props ( props ) ; }
public void update Headers (  Uri uri ,  Send Req send Req ) { synchronized (  PDU_ CACHE_ INSTANCE ) { if (  PDU_ CACHE_ INSTANCE . is Updating ( uri ) ) { if (  LOCAL_ LOGV )  Log . v (  TAG , _ STR + uri + _ STR ) ; try {  PDU_ CACHE_ INSTANCE . wait ( ) ; } catch (  Interrupted Exception e ) {  Log . e (  TAG , _ STR , e ) ; } } }  PDU_ CACHE_ INSTANCE . purge ( uri ) ;  Content Values values = new  Content Values ( _ NUM ) ; byte [ ] content Type = send Req . get Content Type ( ) ; if ( content Type != null ) { values . put ( _ STR , to Iso String ( content Type ) ) ; } long date = send Req . get Date ( ) ; if ( date != - _ NUM ) { values . put ( _ STR , date ) ; } int delivery Report = send Req . get Delivery Report ( ) ; if ( delivery Report != _ NUM ) { values . put ( _ STR , delivery Report ) ; } long expiry = send Req . get Expiry ( ) ; if ( expiry != - _ NUM ) { values . put ( _ STR , expiry ) ; } byte [ ] msg Class = send Req . get Message Class ( ) ; if ( msg Class != null ) { values . put ( _ STR , to Iso String ( msg Class ) ) ; } int priority = send Req . get Priority ( ) ; if ( priority != _ NUM ) { values . put ( _ STR , priority ) ; } int read Report = send Req . get Read Report ( ) ; if ( read Report != _ NUM ) { values . put ( _ STR , read Report ) ; } byte [ ] trans Id = send Req . get Transaction Id ( ) ; if ( trans Id != null ) { values . put ( _ STR , to Iso String ( trans Id ) ) ; }  Encoded String Value subject = send Req . get Subject ( ) ; if ( subject != null ) { values . put ( _ STR , to Iso String ( subject . get Text String ( ) ) ) ; values . put ( _ STR , subject . get Character Set ( ) ) ; } else { values . put ( _ STR , _ STR ) ; } long message Size = send Req . get Message Size ( ) ; if ( message Size > _ NUM ) { values . put ( _ STR , message Size ) ; }  Pdu Headers headers = send Req . get Pdu Headers ( ) ;  Hash Set <  String > recipients = new  Hash Set <  String > ( ) ; for ( int addr Type :  ADDRESS_ FIELDS ) {  Encoded String Value [ ] array = null ; if ( addr Type ==  Pdu Headers .  FROM ) {  Encoded String Value v = headers . get Encoded String Value ( addr Type ) ; if ( v != null ) { array = new  Encoded String Value [ _ NUM ] ; array [ _ NUM ] = v ; } } else { array = headers . get Encoded String Values ( addr Type ) ; } if ( array != null ) { long msg Id =  Content Uris . parse Id ( uri ) ; update Address ( msg Id , addr Type , array ) ; if ( addr Type ==  Pdu Headers .  TO ) { for (  Encoded String Value v : array ) { if ( v != null ) { recipients . add ( v . get String ( ) ) ; } } } } } if ( ! recipients . is Empty ( ) ) { long thread Id =  Utils . get Or Create Thread Id ( m Context , recipients ) ; values . put ( _ STR , thread Id ) ; }  Sqlite Wrapper . update ( m Context , m Content Resolver , uri , values , null , null ) ; }
public  DVariable (  String name ,  DValue value , int isolate Id ) { m_raw Name = name ; m_attribs = value . get Attributes ( ) ; if ( name != null ) { if ( ! is Attribute Set (  Variable Attribute .  PUBLIC_ SCOPE ) ) { int double Colon = name . last Index Of ( _ STR ) ; if ( double Colon >= _ NUM ) { m_namespace = name . substring ( _ NUM , double Colon ) ; int at = m_namespace . index Of ( _ STR ) ; if ( at != - _ NUM ) m_namespace = m_namespace . substring ( _ NUM , at ) ; name = name . substring ( double Colon + _ NUM ) ; } } } m_name = name ; m_non Proto Parent Id =  Value .  UNKNOWN_ ID ; m_value = value ; value . set Session ( m_session ) ; m_isolate Id = isolate Id ; }
public static  String refresh Lock (  Entity Manager em , long type ,  String key ,  String note ) {  Entity Transaction tx = null ; try { tx = em . get Transaction ( ) ; tx . begin ( ) ;  Global Interlock lock = _find And Refresh Lock ( em , type ) ; if ( lock == null ) { throw new  Global Interlock Exception ( _ STR + type + _ STR + key + _ STR ) ; }  String ref =  Long . to Hex String ( lock . lock Time ) ; if ( ref . equals Ignore Case ( key ) ) { lock . lock Time =  System . current Time Millis ( ) ; lock . note = note ; em . merge ( lock ) ; em . flush ( ) ; tx . commit ( ) ; return  Long . to Hex String ( lock . lock Time ) ; } throw new  Global Interlock Exception ( _ STR + type + _ STR + key + _ STR ) ; } finally { if ( tx != null && tx . is Active ( ) ) { tx . rollback ( ) ; } } }
public  Rule Net add (  String p_name , int p_subnet_number , boolean p_contains_plane ) { int new_net_no = net_list . size ( ) + _ NUM ; if ( new_net_no >= max_legal_net_no ) throw new  Illegal Argument Exception ( _ STR ) ;  Rule Net new_net = new  Rule Net ( p_name , p_subnet_number , new_net_no , this , p_contains_plane ) ; net_list . add ( new_net ) ; return new_net ; }
protected  Args Base ( ) { _argv = null ; _start Time = _ NUM ; _program Info = null ; _env = null ; }
@  Override public void element (  String element Name ,  Augmentations augs ) throws  XNIException { if ( f Mixed && f Validation ) { if ( f Mixed Element Types . contains ( element Name ) ) { f Error Reporter . report Error (  XMLMessage Formatter .  XML_ DOMAIN , _ STR , new  Object [ ] { f DTDElement Decl Name , element Name } ,  XMLError Reporter .  SEVERITY_ ERROR ) ; } else { f Mixed Element Types . add ( element Name ) ; } } if ( f DTDGrammar != null ) f DTDGrammar . element ( element Name , augs ) ; if ( f DTDContent Model Handler != null ) { f DTDContent Model Handler . element ( element Name , augs ) ; } }
private static  Point find Midnormal Point (  Point center ,  Point a ,  Point b ,  Rect area , int radius ) { if ( a . y == b . y ) { if ( a . y < center . y ) { return new  Point ( ( a . x + b . x ) / _ NUM , center . y + radius ) ; } return new  Point ( ( a . x + b . x ) / _ NUM , center . y - radius ) ; } if ( a . x == b . x ) { if ( a . x < center . x ) { return new  Point ( center . x + radius , ( a . y + b . y ) / _ NUM ) ; } return new  Point ( center . x - radius , ( a . y + b . y ) / _ NUM ) ; } double ab Slope = ( a . y - b . y ) / ( a . x - b . x * _ NUM ) ; double midnormal Slope = - _ NUM / ab Slope ; double radian =  Math . tan ( midnormal Slope ) ; int dy = ( int ) ( radius *  Math . sin ( radian ) ) ; int dx = ( int ) ( radius *  Math . cos ( radian ) ) ;  Point point = new  Point ( center . x + dx , center . y + dy ) ; if ( ! in Area ( point , area , _ NUM ) ) { point = new  Point ( center . x - dx , center . y - dy ) ; } return point ; }
protected  Abstract Site Map process Xml (  URL sitemap Url , byte [ ] xml Content ) throws  Unknown Format Exception {  BOMInput Stream bom Is = new  BOMInput Stream ( new  Byte Array Input Stream ( xml Content ) ) ;  Input Source is = new  Input Source ( ) ; try { is . set Character Stream ( new  Buffered Reader ( new  Input Stream Reader ( bom Is , _ STR ) ) ) ; } catch (  Unsupported Encoding Exception e ) {  IOUtils . close Quietly ( bom Is ) ; throw new  Runtime Exception ( _ STR , e ) ; } return process Xml ( sitemap Url , is ) ; }
public static void proxy Port ( final int port ) { final  String port Value =  Integer . to String ( port ) ; set Property ( _ STR , port Value ) ; set Property ( _ STR , port Value ) ; }
@  Override public void on Artist Update (  Provider Identifier provider ,  Artist a ) throws  Remote Exception { if ( a == null ) {  Log . w (  TAG , _ STR ) ; return ; }  Artist cached = m Cache . get Artist ( a . get Ref ( ) ) ; if ( cached == null ) { m Cache . put Artist ( provider , a ) ; post Artist For Update ( a ) ; } else if ( ! cached . is Identical ( a ) ) { cached . set Name ( a . get Name ( ) ) ;  Iterator <  String > it = a . albums ( ) ; while ( it . has Next ( ) ) { cached . add Album ( it . next ( ) ) ; } cached . set Is Loaded ( a . is Loaded ( ) ) ; post Artist For Update ( a ) ; } }
private  Properties read Properties ( final  String properties File Path ) throws  IOException {  Properties properties = new  Properties ( ) ;  File props File = new  File ( properties File Path ) ;  File Input Stream fis = null ; if ( props File . exists ( ) ) { try { fis = new  File Input Stream ( props File ) ; properties . load ( fis ) ; } finally { if ( fis != null ) { fis . close ( ) ; } } } return properties ; }
public  Tiled Grayscale Matrix ( final  Grayscale Matrix matrix , final int tile Width , final int tile Height ) { if ( matrix . get Width ( ) < tile Width || matrix . get Height ( ) < tile Height ) { throw new  Illegal Argument Exception ( _ STR ) ; } if ( tile Width <= _ NUM || tile Height <= _ NUM ) { throw new  Illegal Argument Exception ( _ STR ) ; } this . tile Width = tile Width ; this . tile Height = tile Height ; this . tiles X = matrix . get Width ( ) / tile Width ; this . tiles Y = matrix . get Height ( ) / tile Height ; int rounded Width = tiles X * tile Width ; int rounded Height = tiles Y * tile Height ; tiles = new  Array List <  Grayscale Matrix > ( rounded Width * rounded Height ) ; for ( int i = _ NUM ; i < tiles Y ; i ++ ) { for ( int j = _ NUM ; j < tiles X ; j ++ ) { tiles . add (  Grayscale Matrix . create From Region ( matrix , tile Width , tile Height , this . tile Width * j , this . tile Height * i ) ) ; } } }
public  Single Connection Transaction Manager ( @  Not Null  Connection connection , boolean inside Foreign Transaction ) { this . connection = require Non Null ( connection ) ; current Transaction = inside Foreign Transaction ?  Optional . of ( new  Default Transaction ( connection ) ) :  Optional . empty ( ) ; }
public static  Class generate Class Impl (  String name ,  Modifiers modifiers ,  Class [ ] interfaces ,  Class super Class ,  BSHBlock block , boolean is Interface ,  Call Stack callstack ,  Interpreter interpreter ) throws  Eval Error { try {  Capabilities . set Accessibility ( _ BOOL ) ; } catch (  Capabilities .  Unavailable e ) { throw new  Eval Error ( _ STR , block , callstack ) ; }  Name Space enclosing Name Space = callstack . top ( ) ;  String package Name = enclosing Name Space . get Package ( ) ;  String class Name = enclosing Name Space . is Class ? ( enclosing Name Space . get Name ( ) + _ STR + name ) : name ;  String fq Class Name = package Name == null ? class Name : package Name + _ STR + class Name ;  String bsh Static Field Name =  Class Generator Util .  BSHSTATIC + class Name ;  Bsh Class Manager bcm = interpreter . get Class Manager ( ) ; bcm . defining Class ( fq Class Name ) ;  Name Space class Static Name Space = new  Name Space ( enclosing Name Space , class Name ) ; class Static Name Space . is Class = _ BOOL ; callstack . push ( class Static Name Space ) ; block . eval Block ( callstack , interpreter , _ BOOL ,  Class Node Filter .  CLASSCLASSES ) ;  Variable [ ] variables = get Declared Variables ( block , callstack , interpreter , package Name ) ;  Delayed Eval Bsh Method [ ] methods = get Declared Methods ( block , callstack , interpreter , package Name ) ;  Class Generator Util class Generator = new  Class Generator Util ( modifiers , class Name , package Name , super Class , interfaces , variables , methods , is Interface ) ;  Class clas = bcm . get Associated Class ( fq Class Name ) ; if ( clas == null ) { byte [ ] code = class Generator . generate Class (  Interpreter . get Save Classes ( ) ) ; if (  Interpreter . get Save Classes ( ) ) save Classes ( class Name , code ) ; else clas = bcm . define Class ( fq Class Name , code ) ; } if ( !  Interpreter . get Save Classes ( ) ) { class Generator . init Static Name Space ( class Static Name Space , block ) ; enclosing Name Space . import Class ( fq Class Name . replace ( _ STR , _ STR ) ) ; class Static Name Space . set Class Static ( clas ) ; block . eval Block ( callstack , interpreter , _ BOOL ,  Class Node Filter .  CLASSSTATIC ) ; if ( ! clas . is Interface ( ) ) install Static Block ( clas , bsh Static Field Name , class Static Name Space , interpreter ) ; } callstack . pop ( ) ; bcm . done Defining Class ( fq Class Name ) ; return clas ; }
public void clear Account Disabled State ( ) { operations . add (  Password Policy State Operation Type .  CLEAR_ ACCOUNT_ DISABLED_ STATE ) ; }
public static  String format Text Box (  String text , int width ) { require Non Null ( text ) ; return format Text Box ( text , width ,  WORDS ,  Collections . empty Set ( ) ) ; }
public static  Explanation match ( float value ,  String description ,  Explanation ... details ) { return new  Explanation ( _ BOOL , value , description ,  Arrays . as List ( details ) ) ; }
@  Override protected  JTabbed Pane create Plot Tabs (  Plot plot ) {  JTabbed Pane tabs = super . create Plot Tabs ( plot ) ; tabs . insert Tab ( localization Resources . get String ( _ STR ) , null , create Plot Panel ( ) , null , _ NUM ) ; tabs . set Selected Index ( _ NUM ) ; return tabs ; }
protected static  String  URLencoded Sun Query Params String (  String query Params ,  String encoding ) {  String Builder sb = new  String Builder ( _ NUM ) ;  String Tokenizer st = new  String Tokenizer ( query Params , _ STR ) ; while ( st . has More Tokens ( ) ) {  String str = st . next Token ( ) ; if ( str . index Of ( _ STR ) != - _ NUM ) { int index = str . index Of ( _ STR ) ;  String parameter = str . substring ( _ NUM , index ) ;  String value = str . substring ( index + _ NUM ) ; if ( parameter . equals Ignore Case ( _ STR ) || parameter . equals Ignore Case ( _ STR ) || parameter . equals Ignore Case ( _ STR ) ) { value = get Char Decoded Field ( value , encoding ) ; } sb . append (  URLEnc Dec . encode ( parameter ) ) ; sb . append ( _ STR ) ; sb . append (  URLEnc Dec . encode ( value ) ) ; if ( st . has More Tokens ( ) ) { sb . append ( _ STR ) ; } } } return sb . to String ( ) ; }
@  Override public long position ( byte [ ] pattern , long start ) throws  SQLException { if ( is Debug Enabled ( ) ) { debug Code ( _ STR + quote Bytes ( pattern ) + _ STR + start + _ STR ) ; } if (  Constants .  BLOB_ SEARCH ) { try { check Closed ( ) ; if ( pattern == null ) { return - _ NUM ; } if ( pattern . length == _ NUM ) { return _ NUM ; }  Buffered Input Stream in = new  Buffered Input Stream ( value . get Input Stream ( ) ) ;  IOUtils . skip Fully ( in , start - _ NUM ) ; int pos = _ NUM ; int pattern Pos = _ NUM ; while ( _ BOOL ) { int x = in . read ( ) ; if ( x < _ NUM ) { break ; } if ( x == ( pattern [ pattern Pos ] & _ NUM ) ) { if ( pattern Pos == _ NUM ) { in . mark ( pattern . length ) ; } if ( pattern Pos == pattern . length ) { return pos - pattern Pos ; } pattern Pos ++ ; } else { if ( pattern Pos > _ NUM ) { in . reset ( ) ; pos -= pattern Pos ; } } pos ++ ; } return - _ NUM ; } catch (  Exception e ) { throw log And Convert ( e ) ; } } throw unsupported ( _ STR ) ; }
public static long size Of Directory (  File directory ) { check Directory ( directory ) ; final  File [ ] files = directory . list Files ( ) ; if ( files == null ) { return _ NUM ; } long size = _ NUM ; for ( final  File file : files ) { try { if ( ! is Symlink ( file ) ) { size += size Of ( file ) ; if ( size < _ NUM ) { break ; } } } catch (  IOException ioe ) { } } return size ; }
public byte [ ] decompress (  Input Stream is ) { inflater . reset ( ) ;  Inflater Input Stream iis = new  Inflater Input Stream ( is , inflater ) ;  Byte Array Output Stream baos = new  Byte Array Output Stream ( ) ; try { while ( _ BOOL ) { int b = iis . read ( ) ; if ( b == - _ NUM ) break ; baos . write ( b ) ; } } catch (  IOException ex ) { throw new  Runtime Exception ( ex ) ; } return baos . to Byte Array ( ) ; }
protected void write Column (  Table table ,  Column column ,  String Builder ddl ) { write Column Type Default Required ( table , column , ddl ) ; if ( column . is Primary Key ( ) && database Info . is Primary Key Embedded ( ) ) { write Column Embedded Primary Key ( table , column , ddl ) ; } if ( column . is Auto Increment ( ) && ! database Info . is Default Value Used For Identity Spec ( ) ) { if ( ! database Info . is Non PKIdentity Columns Supported ( ) && ! column . is Primary Key ( ) ) { throw new  Model Exception ( _ STR + column . get Name ( ) + _ STR + table . get Name ( ) + _ STR ) ; } ddl . append ( _ STR ) ; write Column Auto Increment Stmt ( table , column , ddl ) ; } }
private boolean read Port ( ) { _current Url Marker . set Index (  Url Part .  PORT , _buffer . length ( ) ) ; int port Len = _ NUM ; while ( ! _reader . eof ( ) ) { char curr = _reader . read ( ) ; port Len ++ ; if ( curr == _ STR ) { _buffer . append ( curr ) ; return read Path ( ) ; } else if ( curr == _ STR ) { _buffer . append ( curr ) ; return read Query String ( ) ; } else if ( curr == _ STR ) { _buffer . append ( curr ) ; return read Fragment ( ) ; } else if ( check Matching Character ( curr ) ==  Character Match .  Character Match Stop || !  Char Utils . is Numeric ( curr ) ) { _reader . go Back ( ) ; if ( port Len == _ NUM ) { _buffer . delete ( _buffer . length ( ) - _ NUM , _buffer . length ( ) ) ; } _current Url Marker . unset Index (  Url Part .  PORT ) ; return read End (  Read End State .  Valid Url ) ; } else { _buffer . append ( curr ) ; } } return read End (  Read End State .  Valid Url ) ; }
static  Token [ ] lexx ( final  String format ) { final  Array List <  Token > list = new  Array List <  Token > ( format . length ( ) ) ; boolean in Literal = _ BOOL ;  String Builder buffer = null ;  Token previous = null ; for ( int i = _ NUM ; i < format . length ( ) ; i ++ ) { final char ch = format . char At ( i ) ; if ( in Literal && ch != _ STR ) { buffer . append ( ch ) ; continue ; }  Object value = null ; switch ( ch ) { case _ STR : if ( in Literal ) { buffer = null ; in Literal = _ BOOL ; } else { buffer = new  String Builder ( ) ; list . add ( new  Token ( buffer ) ) ; in Literal = _ BOOL ; } break ; case _ STR : value = y ; break ; case _ STR : value =  M ; break ; case _ STR : value = d ; break ; case _ STR : value =  H ; break ; case _ STR : value = m ; break ; case _ STR : value = s ; break ; case _ STR : value =  S ; break ; default : if ( buffer == null ) { buffer = new  String Builder ( ) ; list . add ( new  Token ( buffer ) ) ; } buffer . append ( ch ) ; } if ( value != null ) { if ( previous != null && previous . get Value ( ) == value ) { previous . increment ( ) ; } else { final  Token token = new  Token ( value ) ; list . add ( token ) ; previous = token ; } buffer = null ; } } if ( in Literal ) { throw new  Illegal Argument Exception ( _ STR + format ) ; } return list . to Array ( new  Token [ list . size ( ) ] ) ; }
public static void save (  File file , byte [ ] bytes ) throws  IOException {  Output Stream os = new  File Output Stream ( file ) ; try { os = new  Buffered Output Stream ( os ) ; for ( int i = _ NUM ; i < bytes . length ; i += _ NUM ) { int len =  Math . min ( bytes . length - i , _ NUM ) ; os . write ( bytes , i , len ) ; } } finally { os . close ( ) ; } }
public void assert Joined ( final  UUID service Id ) { m_triggers . add ( new  Quorum Event Invariant (  Quorum Event Enum .  SERVICE_ LEAVE , service Id ) ) ; assert Membership ( m_quorum . get Joined ( ) , service Id ) ; }
public  Element parse (  Reader is ) { buff Offset = _ NUM ; buff Size = - _ NUM ; event Parser = _ BOOL ;  Element root Element = create New Element ( _ STR ) ; try { parse Tag Content ( root Element , is ) ; } catch (  IOException ioe ) { ioe . print Stack Trace ( ) ; } if ( root Element . get Num Children ( ) == _ NUM ) { notify Error (  Parser Callback .  ERROR_ NO_ ROOTS , null , null , null , _ STR ) ; return null ; } else if ( root Element . get Num Children ( ) > _ NUM ) {  String roots = _ STR ; for ( int i = _ NUM ; i < root Element . get Num Children ( ) ; i ++ ) {  Element elem = root Element . get Child At ( i ) ; if ( elem . is Text Element ( ) ) { roots += _ STR + elem . get Text ( ) + _ STR ; } else { roots += elem . get Tag Name ( ) + _ STR ; } } if ( roots . ends With ( _ STR ) ) { roots = roots . substring ( _ NUM , roots . length ( ) - _ NUM ) ; }  Element first Root = root Element . get Child At ( _ NUM ) ;  String str = null ; if ( first Root . is Text Element ( ) ) { str = _ STR + first Root . get Text ( ) ; } else { str = first Root . get Tag Name ( ) ; } notify Error (  Parser Callback .  ERROR_ MULTIPLE_ ROOTS , null , null , null , _ STR + str + _ STR + roots ) ; } root Element = root Element . get Child At ( _ NUM ) ; return root Element ; }
private void add Connections (  Collection <  Connection > connections ) throws  Guacamole Exception { for (  Connection connection : connections ) {  APIConnection Group parent = retrieved Groups . get ( connection . get Parent Identifier ( ) ) ; if ( parent != null ) {  Collection <  APIConnection > children = parent . get Child Connections ( ) ; if ( children == null ) { children = new  Array List <  APIConnection > ( ) ; parent . set Child Connections ( children ) ; }  APIConnection api Connection = new  APIConnection ( connection ) ; retrieved Connections . put ( connection . get Identifier ( ) , api Connection ) ; children . add ( api Connection ) ; } else logger . debug ( _ STR , connection . get Identifier ( ) , connection . get Parent Identifier ( ) ) ; } }
public void add Shape ( final  Geo Membership Shape shape ) { shapes . add ( shape ) ; }
public void add Decoration (  Shape Decoration decoration ) { decorations . add ( decoration ) ; }
public int parse Reference (  String s ) { this . input = s ; this . index = _ NUM ;  String dest ;  String title ; int match Chars ; int start Index = index ; match Chars = parse Link Label ( ) ; if ( match Chars == _ NUM ) { return _ NUM ; }  String raw Label = input . substring ( _ NUM , match Chars ) ; if ( peek ( ) != _ STR ) { return _ NUM ; } index ++ ; spnl ( ) ; dest = parse Link Destination ( ) ; if ( dest == null || dest . length ( ) == _ NUM ) { return _ NUM ; } int before Title = index ; spnl ( ) ; title = parse Link Title ( ) ; if ( title == null ) { index = before Title ; } boolean at Line End = _ BOOL ; if ( index != input . length ( ) && match (  LINE_ END ) == null ) { if ( title == null ) { at Line End = _ BOOL ; } else { title = null ; index = before Title ; at Line End = match (  LINE_ END ) != null ; } } if ( ! at Line End ) { return _ NUM ; }  String normalized Label =  Escaping . normalize Reference ( raw Label ) ; if ( normalized Label . is Empty ( ) ) { return _ NUM ; } if ( ! reference Map . contains Key ( normalized Label ) ) {  Link link = new  Link ( dest , title ) ; reference Map . put ( normalized Label , link ) ; } return index - start Index ; }
public void record Block Volume Operation (  Db Client db Client ,  Operation Type Enum op Type ,  Operation .  Status status ,  Object ... ext Param ) { try { boolean op Status = (  Operation .  Status . ready == status ) ? _ BOOL : _ BOOL ;  String ev Type ; ev Type = op Type . get Ev Type ( op Status ) ;  String ev Desc = op Type . get Description ( ) ;  String op Stage =  Audit Log Manager .  AUDITOP_ END ; _logger . info ( _ STR , op Type . to String ( ) , ev Type . to String ( ) + _ STR + ev Desc ) ; record Bourne Volume Event ( db Client , get Id ( ) , ev Type , status , ev Desc ) ;  String id = (  String ) ext Param [ _ NUM ] ; switch ( op Type ) { case  CREATE_ BLOCK_ VOLUME : case  DELETE_ BLOCK_ VOLUME :  Audit Block Util . audit Block ( db Client , op Type , op Status , op Stage , id ) ; break ; case  EXPAND_ BLOCK_ VOLUME :  String size = (  String ) ext Param [ _ NUM ] ;  Audit Block Util . audit Block ( db Client , op Type , op Status , op Stage , id , size ) ; break ; case  CREATE_ VOLUME_ FULL_ COPY :  Audit Block Util . audit Block ( db Client , op Type , op Status , op Stage , id ) ; break ; case  DETACH_ VOLUME_ FULL_ COPY :  Audit Block Util . audit Block ( db Client , op Type , op Status , op Stage , id ) ; break ; case  RESTORE_ VOLUME_ FULL_ COPY : case  RESYNCHRONIZE_ VOLUME_ FULL_ COPY : case  ACTIVATE_ VOLUME_ FULL_ COPY :  Audit Block Util . audit Block ( db Client , op Type , op Status , op Stage , id ) ; break ; default : _logger . error ( _ STR ) ; } } catch (  Exception e ) { _logger . error ( _ STR , op Type . to String ( ) , e ) ; } }
@  Override public void put ( double val , double weight ) { final double nn = weight + this . n ; final double delta = val - this . m1 ; final double otherm2 = val * val ; final double otherm3 = otherm2 * val ; final double otherm4 = otherm3 * val ; final double delta_nn = delta / nn ; final double delta_nn2 = delta_nn * delta_nn ; final double delta_nn3 = delta_nn2 * delta_nn ; final double na2 = this . n * this . n ; final double nb2 = weight * weight ; final double ntn = this . n * weight ; this . m4 += otherm4 + delta * delta_nn3 * ntn * ( na2 - ntn + nb2 ) + _ NUM * ( na2 * otherm2 + nb2 * this . m2 ) * delta_nn2 + _ NUM * ( this . n * otherm3 - weight * this . m3 ) * delta_nn ; this . m3 += otherm3 + delta * delta_nn2 * ntn * ( this . n - weight ) + _ NUM * ( this . n * otherm2 - weight * this . m2 ) * delta_nn ; this . m2 += otherm2 + delta * delta_nn * this . n * weight ; this . m1 += weight * delta_nn ; this . n = nn ; min =  Math . min ( min , val ) ; max =  Math . max ( max , val ) ; }
public void close ( ) throws  IOException { if ( ! closed ) { try { if ( ! eof ) { exhaust Input Stream ( this ) ; } } finally { eof = _ BOOL ; closed = _ BOOL ; } } }
protected synchronized int determine Minimum Number Of Parent Dirs ( ) { int result ;  Hash Set <  String > files ; int num ; int i ; int max ; result = - _ NUM ; max = _ NUM ; for ( i = _ NUM ; i < m_ Recent Items . size ( ) ; i ++ ) max =  Math . max ( max ,  File Utils . get Directory Depth ( m_ Recent Items . get ( i ) ) ) ; num = _ NUM ; do { files = new  Hash Set <  String > ( ) ; for ( i = _ NUM ; i < m_ Recent Items . size ( ) ; i ++ ) files . add (  File Utils . create Partial Filename ( m_ Recent Items . get ( i ) , num ) ) ; if ( files . size ( ) == m_ Recent Items . size ( ) ) result = num ; else num ++ ; } while ( ( files . size ( ) < m_ Recent Items . size ( ) ) && ( num <= max ) ) ; return result ; }
void output Variables (  List <  Var Holder > vars ) { boolean first = _ BOOL ; for (  Var Holder vh : vars ) { if ( vh . name != null ) { if ( first ) { gen . out ( _ STR , vh . name ) ; first = _ BOOL ; } else { gen . out ( _ STR , vh . name ) ; } } else if ( vh . destr != null && vh . vars != null ) { for (  Tree .  Variable v : vh . vars ) { final  String vname = names . name ( v . get Declaration Model ( ) ) ; if ( first ) { gen . out ( _ STR , vname ) ; first = _ BOOL ; } else { gen . out ( _ STR , vname ) ; } } } } if ( ! first ) { gen . end Line ( _ BOOL ) ; } }
public void handle Button1 Request (  Request Invocation Event event ) throws  Model Control Exception {  FSAuth Domains Model model = (  FSAuth Domains Model ) get Model ( ) ;  String name = (  String ) get Display Field Value ( model .  TF_ NAME ) ;  AMProperty Sheet ps = (  AMProperty Sheet ) get Child (  PROPERTY_ ATTRIBUTE ) ; try {  String realm = model . get Realm ( name ) ;  Map values = ps . get Attribute Values ( model . get Data Map ( ) , _ BOOL , model ) ; model . set Attribute Values ( realm , name , values ) ;  Serialized Field sz Cache = (  Serialized Field ) get Child (  SZ_ CACHE ) ;  Federation View Bean vb = (  Federation View Bean ) get View Bean (  Federation View Bean . class ) ;  CCAdd Remove add Remove List = (  CCAdd Remove ) get Child (  ADD_ REMOVE_ PROVIDERS ) ; add Remove List . restore State Data ( ) ;  CCAdd Remove Model add Remove Model = (  CCAdd Remove Model ) add Remove List . get Model ( ) ;  List list = new  Array List ( get Selected Values ( add Remove Model ) ) ; model . add Providers ( realm , name , list ) ; set Inline Alert Message (  CCAlert .  TYPE_ INFO , _ STR , _ STR ) ; forward To ( ) ; } catch (  AMConsole Exception e ) { set Inline Alert Message (  CCAlert .  TYPE_ ERROR , _ STR , e . get Message ( ) ) ; forward To ( ) ; } }
private void init ( ) { set Title ( _ STR ) ; wta Panel = new  WTAProperties Panel ( network Panel ) ; tab Logic . add ( wta Panel ) ; layout Panel = new  Main Layout Panel ( _ BOOL , this ) ; layout Panel . set Current Layout (  Winner Take All .  DEFAULT_ LAYOUT ) ; tab Layout . add ( layout Panel ) ; tabbed Pane . add Tab ( _ STR , tab Logic ) ; tabbed Pane . add Tab ( _ STR , tab Layout ) ; set Content Pane ( tabbed Pane ) ;  Action help Action = new  Show Help Action ( wta Panel . get Help Path ( ) ) ; add Button ( new  JButton ( help Action ) ) ; }
private static double  Internalgamma ( double z ) { double sum = _ NUM ; double [ ] c = { _ NUM , _ NUM , - _ NUM , - _ NUM , _ NUM , - _ NUM , - _ NUM , _ NUM , - _ NUM , - _ NUM , _ NUM , - _ NUM , - _ NUM , _ NUM , - _ NUM , _ NUM , _ NUM , - _ NUM , _ NUM , _ NUM , - _ NUM , _ NUM , - _ NUM , - _ NUM , _ NUM , _ NUM } ; for ( int i = _ NUM ; i < c . length ; i ++ ) { sum += c [ i ] *  Math . pow ( z , ( double ) ( i + _ NUM ) ) ; } return ( _ NUM / sum ) ; }
public int hash Code ( ) { int hash Code = this . hash Code ; if ( hash Code == _ NUM ) { hash Code = ( ( group Id . hash Code ( ) * _ NUM + artifact Id . hash Code ( ) ) * _ NUM + version . hash Code ( ) ) * _ NUM + classifier . hash Code ( ) ; if ( hash Code == _ NUM ) { hash Code = - _ NUM ; } this . hash Code = hash Code ; } return hash Code ; }
private void serialize Class (  Class clazz ,  Map <  String ,  List <  String > > class Fields ) throws  Runtime Exception {  File current = new  File ( get Current Directory ( ) ) ; if ( ! current . exists ( ) || ! current . is Directory ( ) ) { throw new  Illegal State Exception ( _ STR + current . get Absolute Path ( ) + _ STR + _ STR + _ STR ) ; } try {  Field field = clazz . get Declared Field ( _ STR ) ; int modifiers = field . get Modifiers ( ) ; boolean _static =  Modifier . is Static ( modifiers ) ; boolean _final =  Modifier . is Final ( modifiers ) ; field . set Accessible ( _ BOOL ) ; if ( ! _static || ! _final || ! ( _ NUM == field . get Long ( null ) ) ) { throw new  Runtime Exception ( _ STR + clazz + _ STR + _ STR ) ; } int num Fields = get Num Non Serial Version UIDFields ( clazz ) ; if ( num Fields > _ NUM ) {  Method method = clazz . get Method ( _ STR ) ;  Object object = method . invoke ( null ) ;  File file = new  File ( current , clazz . get Name ( ) + _ STR ) ; boolean created = file . create New File ( ) ;  File Output Stream out = new  File Output Stream ( file ) ;  Object Output Stream obj Out = new  Object Output Stream ( out ) ; obj Out . write Object ( object ) ; out . close ( ) ; }  Object Stream Class object Stream Class =  Object Stream Class . lookup ( clazz ) ;  String class Name = object Stream Class . get Name ( ) ;  Object Stream Field [ ] fields = object Stream Class . get Fields ( ) ; @  Suppress Warnings ( _ STR )  List <  String > field List = new  Array List < > ( ) ; for (  Object Stream Field object Stream Field : fields ) {  String field Name = object Stream Field . get Name ( ) ; field List . add ( field Name ) ; } class Fields . put ( class Name , field List ) ; } catch (  No Such Field Exception e ) { throw new  Runtime Exception ( ( _ STR + _ STR + clazz + _ STR + _ STR ) ) ; } catch (  No Such Method Exception e ) { } catch (  Illegal Access Exception e ) { throw new  Runtime Exception ( _ STR + _ STR + clazz + _ STR , e ) ; } catch (  Invocation Target Exception e ) { throw new  Runtime Exception ( _ STR + _ STR + clazz + _ STR , e ) ; } catch (  IOException e ) { throw new  Runtime Exception ( _ STR + _ STR + get Current Directory ( ) + _ STR + clazz + _ STR , e ) ; } }
private static  List find Intersection Nodes (  Polygonize Directed Edge start DE , long label ) {  Polygonize Directed Edge de = start DE ;  List int Nodes = null ; do {  Node node = de . get From Node ( ) ; if ( get Degree ( node , label ) > _ NUM ) { if ( int Nodes == null ) int Nodes = new  Array List ( ) ; int Nodes . add ( node ) ; } de = de . get Next ( ) ;  Assert . is True ( de != null , _ STR ) ;  Assert . is True ( de == start DE || ! de . is In Ring ( ) , _ STR ) ; } while ( de != start DE ) ; return int Nodes ; }
public byte [ ] encrypt ( byte [ ] data ) throws  Crypto Exception { try { byte [ ] ciphertext ; if ( use Explicit Iv ) { ciphertext =  Array Converter . concatenate ( encrypt Iv . get IV ( ) , encrypt Cipher . do Final ( data ) ) ; } else { encrypt Cipher . init (  Cipher .  ENCRYPT_ MODE , encrypt Key , encrypt Iv ) ; ciphertext = encrypt Cipher . do Final ( data ) ; encrypt Iv = new  Iv Parameter Spec (  Arrays . copy Of Range ( ciphertext , ciphertext . length - decrypt Cipher . get Block Size ( ) , ciphertext . length ) ) ; } return ciphertext ; } catch (  Bad Padding Exception |  Illegal Block Size Exception |  Invalid Algorithm Parameter Exception |  Invalid Key Exception ex ) { throw new  Crypto Exception ( ex ) ; } }
public void remove Event Listener (  Video Sharing Listener listener ) throws  Rcs Service Not Available Exception ,  Rcs Generic Exception { if ( m Api == null ) { throw new  Rcs Service Not Available Exception ( ) ; } try {  Weak Reference <  IVideo Sharing Listener > weak Ref = m Video Sharing Listeners . remove ( listener ) ; if ( weak Ref == null ) { return ; }  IVideo Sharing Listener rcs Listener = weak Ref . get ( ) ; if ( rcs Listener != null ) { m Api . remove Event Listener2 ( rcs Listener ) ; } } catch (  Exception e ) {  Rcs Illegal Argument Exception . assert Exception ( e ) ; throw new  Rcs Generic Exception ( e ) ; } }
private void write (  FCDCommand command ) throws  Lib Usb Exception {  Byte Buffer buffer =  Byte Buffer . allocate Direct ( _ NUM ) ; buffer . put ( _ NUM , command . get Command ( ) ) ; buffer . put ( _ NUM , ( byte ) _ NUM ) ; write ( buffer ) ; }
public boolean matches Ignore Case (  String sa ) { if ( _length != sa . length ( ) ) return _ BOOL ; char [ ] buffer = _buffer ; int offset = _offset ; for ( int i = _length - _ NUM ; i >= _ NUM ; i -- ) { char ca = buffer [ offset + i ] ; char cb = sa . char At ( i ) ; if ( ca != cb &&  Character . to Lower Case ( ca ) !=  Character . to Lower Case ( cb ) ) return _ BOOL ; } return _ BOOL ; }
@  Override public void control Event ( int event ) { if ( ( event ==  Wrapper Manager .  WRAPPER_ CTRL_ LOGOFF_ EVENT ) &&  Wrapper Manager . is Launched As Service ( ) ) { if ( logger . is Info Enabled ( ) ) { logger . info ( _ STR + event + _ STR ) ; } } else { if ( logger . is Info Enabled ( ) ) { logger . info ( _ STR + event + _ STR ) ; }  Wrapper Manager . stop ( _ NUM ) ; } }
@  Override public double [ ] sample ( ) { double [ ] centre = points [ sampler . next Int ( points . length ) ] ; double [ ] new Point = new double [ bandwidths . length ] ; double total = _ NUM ; double shift = _ NUM ; for ( int i = _ NUM ; i < centre . length ; i ++ ) { new Point [ i ] = ( sampler . next Gaussian ( ) * sampling Deviation [ i ] ) + centre [ i ] ; total += new Point [ i ] ; if ( new Point [ i ] < shift ) { shift = new Point [ i ] ; } } if ( is Bounded ) { for ( int i = _ NUM ; i < centre . length ; i ++ ) { new Point [ i ] = ( new Point [ i ] - shift ) / ( total - shift * centre . length ) ; } } return new Point ; }
public void remove Channel (  Channel channel ) { if ( channel != null ) { switch ( channel . get Channel Type ( ) ) { case  STANDARD : int index = m Channels . index Of ( channel ) ; m Channels . remove ( channel ) ; if ( index >= _ NUM ) { fire Table Rows Deleted ( index , index ) ; } break ; case  TRAFFIC : m Traffic Channels . remove ( channel ) ; break ; default : break ; } broadcast ( new  Channel Event ( channel ,  Event .  NOTIFICATION_ DELETE ) ) ; } }
public static  String join (  Object [ ] array ,  String separator ) { if ( array == null ) { return null ; } if ( array . length == _ NUM ) { return  String Pool .  EMPTY ; } if ( array . length == _ NUM ) { return  String . value Of ( array [ _ NUM ] ) ; } final  String Builder sb = new  String Builder ( array . length * _ NUM ) ; for ( int i = _ NUM ; i < array . length ; i ++ ) { if ( i > _ NUM ) { sb . append ( separator ) ; } sb . append ( array [ i ] ) ; } return sb . to String ( ) ; }
public static boolean contains ( final  Type type ) {  Set <  Type > generated Values = thread Local . get ( ) ; return generated Values . contains ( type ) ; }
protected void create Supply ( int  AD_ Org_ ID , int  PP_ MRP_ ID ,  MProduct product ,  Big Decimal  Qty Planned ,  Timestamp  Demand Date Start Schedule ,  String trx Name ) throws  Adempiere Exception ,  SQLException { if ( is Synchronize ( ) && m_product_planning . get DD_ Network Distribution_ ID ( ) > _ NUM ) { create DDOrder (  AD_ Org_ ID ,  PP_ MRP_ ID , product ,  Qty Planned ,  Demand Date Start Schedule , trx Name ) ; } else if ( product . is Purchased ( ) ) { create Requisition (  AD_ Org_ ID ,  PP_ MRP_ ID , product ,  Qty Planned ,  Demand Date Start Schedule , trx Name ) ; } else if ( product . is BOM ( ) ) { create PPOrder (  AD_ Org_ ID ,  PP_ MRP_ ID , product ,  Qty Planned ,  Demand Date Start Schedule , trx Name ) ; } else { throw new  Illegal State Exception ( _ STR + _ STR + product + _ STR + m_product_planning + _ STR ) ; } }
public  List <  Local Date > top ( int n ) {  List <  Local Date > top = new  Array List < > ( ) ; int [ ] values = data . to Int Array ( ) ;  Int Arrays . parallel Quick Sort ( values ,  Reverse Int Comparator . instance ( ) ) ; for ( int i = _ NUM ; i < n && i < values . length ; i ++ ) { top . add (  Packed Local Date . as Local Date ( values [ i ] ) ) ; } return top ; }
@  Override public void load XML (  Node stepnode ,  List <  Database Meta > databases ,  Map <  String ,  Counter > counters ) throws  Kettle XMLException { try { database Name =  XMLHandler . get Tag Value ( stepnode , _ STR ) ; tabel Name =  XMLHandler . get Tag Value ( stepnode , _ STR ) ; mdkey Size =  XMLHandler . get Tag Value ( stepnode , _ STR ) ; measure Count =  XMLHandler . get Tag Value ( stepnode , _ STR ) ; heir And Key Size =  XMLHandler . get Tag Value ( stepnode , _ STR ) ; table Name =  XMLHandler . get Tag Value ( stepnode , _ STR ) ; group By Enabled =  XMLHandler . get Tag Value ( stepnode , _ STR ) ; aggregator Class String =  XMLHandler . get Tag Value ( stepnode , _ STR ) ; aggregator String =  XMLHandler . get Tag Value ( stepnode , _ STR ) ; fact Dim Lens String =  XMLHandler . get Tag Value ( stepnode , _ STR ) ; level Anddata Type String =  XMLHandler . get Tag Value ( stepnode , _ STR ) ; partition ID =  XMLHandler . get Tag Value ( stepnode , _ STR ) ; segment Id =  XMLHandler . get Tag Value ( stepnode , _ STR ) ; task No =  XMLHandler . get Tag Value ( stepnode , _ STR ) ; } catch (  Exception e ) { throw new  Kettle XMLException ( _ STR , e ) ; } }
public void read Data (  Data Input din ) throws  IOException { reference = din . read Unsigned Short ( ) ; bit Count = din . read Unsigned Short ( ) ; }
public static double [ ] random ( int m ) { double [ ] res = new double [ m ] ; for ( int i = _ NUM ; i < m ; ++ i ) { res [ i ] =  Math . random ( ) ; } return ( res ) ; }
public static double dev (  Double List doubles ) { if ( doubles . is Empty ( ) ) { return  Double .  Na N ; } return  Math . sqrt ( variance ( doubles ) ) ; }
public int [ ] value Array ( int [ ] array ) { if ( array == null || array . length != size ( ) ) { array = new int [ count ] ; }  System . arraycopy ( values , _ NUM , array , _ NUM , count ) ; return array ; }
public static int compare (  Date left ,  Date right ) { return compare ( left . get Time ( ) / _ NUM , right . get Time ( ) / _ NUM ) ; }
@  Suppress Warnings ( _ STR ) private void transfer Chunk ( ) { final  Linked List <  V > c = new  Linked List <  V > ( ) ; queue . drain To ( c , buffer . get Minimum Chunk Size ( ) ) ; final int chunk Size = c . size ( ) ; if ( chunk Size == _ NUM ) return ; final  V [ ] a = (  V [ ] ) java . lang . reflect .  Array . new Instance ( c . get First ( ) . get Class ( ) , chunk Size ) ; int i = _ NUM ; for (  V v : c ) { assert v != null : _ STR + i ; a [ i ++ ] = v ; } assert i == chunk Size : _ STR + i + _ STR + chunk Size ; if ( log . is Info Enabled ( ) ) { log . info ( _ STR + chunk Size + _ STR + accept Count + _ STR + chunk Count ) ; } buffer . add ( a ) ; chunk Count . increment And Get ( ) ; }
private void init Connection ( ) throws  Replicator Exception { try { logger . info ( _ STR + server Port ) ;  Inet Address host =  Inet Address . get By Name ( _ STR ) ; socket = new  Socket ( host , server Port ) ; socket . set So Timeout ( timeout * _ NUM ) ; logger . debug ( _ STR + socket . get Receive Buffer Size ( ) ) ; logger . info ( _ STR + socket . get Remote Socket Address ( ) ) ; to Server = new  Print Writer ( socket . get Output Stream ( ) , _ BOOL ) ; from Server = new  Buffered Reader ( new  Input Stream Reader ( socket . get Input Stream ( ) ) ) ; } catch (  Unknown Host Exception e ) { throw new  Replicator Exception ( _ STR + e , e ) ; } catch (  IOException e ) { throw new  Replicator Exception ( _ STR + e , e ) ; } }
public static  String node Sub Type To String ( int sub Type ) {  String val = _ STR ; switch ( sub Type ) { case  Node Representation .  AND_ TYPE : val = _ STR ; break ; case  Node Representation .  OR_ TYPE : val = _ STR ; break ; case  Node Representation .  IMPLIES_ TYPE : val = _ STR ; break ; case  Node Representation .  FORALL_ TYPE : val = _ STR ; break ; case  Node Representation .  EXISTS_ TYPE : val = _ STR ; break ; case  Node Representation .  SQSUB_ TYPE : val = _ STR ; break ; case  Node Representation .  OTHER_ TYPE : val = _ STR ; break ; } return val ; }
private boolean is Debuggable (  Level level ) { if ( level . int Value ( ) < debug Level . int Value ( ) || debug Level ==  Level .  OFF ) { return _ BOOL ; } return _ BOOL ; }
static  Object [ ] compute Folder Non Java Resources (  IPackage Fragment Root root ,  IContainer folder , char [ ] [ ] inclusion Patterns , char [ ] [ ] exclusion Patterns ) throws  Java Model Exception {  IResource [ ] non Java Resources = new  IResource [ _ NUM ] ; int non Java Resources Counter = _ NUM ; try {  IResource [ ] members = folder . members ( ) ; int length = members . length ; if ( length > _ NUM ) {  IJava Project other Java Project =  Java Core . create ( folder . get Project ( ) ) ;  String source Level = other Java Project . get Option (  Java Core .  COMPILER_ SOURCE , _ BOOL ) ;  String compliance Level = other Java Project . get Option (  Java Core .  COMPILER_ COMPLIANCE , _ BOOL ) ;  Java Project java Project = (  Java Project ) root . get Java Project ( ) ;  IClasspath Entry [ ] classpath = java Project . get Resolved Classpath ( ) ; next Resource : for ( int i = _ NUM ; i < length ; i ++ ) {  IResource member = members [ i ] ; switch ( member . get Type ( ) ) { case  IResource .  FILE :  String file Name = member . get Name ( ) ; if (  Util . is Valid Compilation Unit Name ( file Name , source Level , compliance Level ) && !  Util . is Excluded ( member , inclusion Patterns , exclusion Patterns ) ) continue next Resource ; if (  Util . is Valid Class File Name ( file Name , source Level , compliance Level ) ) continue next Resource ; if ( is Classpath Entry ( member . get Full Path ( ) , classpath ) ) continue next Resource ; break ; case  IResource .  FOLDER : if (  Util . is Valid Folder Name For Package ( member . get Name ( ) , source Level , compliance Level ) && ( !  Util . is Excluded ( member , inclusion Patterns , exclusion Patterns ) || is Classpath Entry ( member . get Full Path ( ) , classpath ) ) ) continue next Resource ; break ; } if ( non Java Resources . length == non Java Resources Counter ) {  System . arraycopy ( non Java Resources , _ NUM , ( non Java Resources = new  IResource [ non Java Resources Counter * _ NUM ] ) , _ NUM , non Java Resources Counter ) ; } non Java Resources [ non Java Resources Counter ++ ] = member ; } } return non Java Resources ; } catch (  Core Exception e ) { throw new  Java Model Exception ( e ) ; } }
public void test Quoting ( ) {  String input ;  String output ; input = _ STR ; output =  Utils . quote ( input ) ; assert True ( _ STR , ! output . starts With ( _ STR ) && ! output . ends With ( _ STR ) ) ; input = _ STR ; output =  Utils . quote ( input ) ; assert True ( _ STR , output . starts With ( _ STR ) && output . ends With ( _ STR ) ) ; assert True ( _ STR , input . equals (  Utils . unquote ( output ) ) ) ; input = _ STR ; output =  Utils . quote ( input ) ; assert True ( _ STR , output . starts With ( _ STR ) && output . ends With ( _ STR ) ) ; assert True ( _ STR , input . equals (  Utils . unquote ( output ) ) ) ; input = _ STR ; output =  Utils . quote ( input ) ; assert True ( _ STR + input + _ STR , output . starts With ( _ STR ) && output . ends With ( _ STR ) ) ; assert True ( _ STR + input + _ STR , input . equals (  Utils . unquote ( output ) ) ) ; input = _ STR ; output =  Utils . quote ( input ) ; assert True ( _ STR + input + _ STR , output . starts With ( _ STR ) && output . ends With ( _ STR ) ) ; assert True ( _ STR + input + _ STR , input . equals (  Utils . unquote ( output ) ) ) ; input = _ STR ; output =  Utils . quote ( input ) ; assert True ( _ STR + input + _ STR , output . starts With ( _ STR ) && output . ends With ( _ STR ) ) ; assert True ( _ STR + input + _ STR , input . equals (  Utils . unquote ( output ) ) ) ; input = _ STR ; output =  Utils . quote ( input ) ; assert True ( _ STR + input + _ STR , output . starts With ( _ STR ) && output . ends With ( _ STR ) ) ; assert True ( _ STR + input + _ STR , input . equals (  Utils . unquote ( output ) ) ) ; input = _ STR ; output =  Utils . quote ( input ) ; assert True ( _ STR + input + _ STR , output . starts With ( _ STR ) && output . ends With ( _ STR ) ) ; assert True ( _ STR + input + _ STR , input . equals (  Utils . unquote ( output ) ) ) ; }
private void write Net Buffer ( ) throws  Ignite Checked Exception { try { ch . write ( out Net Buf ) ; } catch (  IOException e ) { throw new  Ignite Checked Exception ( _ STR , e ) ; } }
public static  Map <  String ,  Set <  String > > parse (  Command Manager mgr ,  String file Name ,  List list Attribute Values ) throws  CLIException {  Map <  String ,  Set <  String > > results = null ; if ( file Name != null ) { results = parse ( mgr , file Name ) ; } if ( ( list Attribute Values != null ) && ! list Attribute Values . is Empty ( ) ) { if ( results != null ) { results . put All ( parse ( mgr , list Attribute Values ) ) ; } else { results = parse ( mgr , list Attribute Values ) ; } } return ( results == null ) ? new  Hash Map <  String ,  Set <  String > > ( ) : results ; }
public synchronized void remove Consumer (  Image Consumer ic ) { the Consumers . remove Element ( ic ) ; }
private synchronized void refresh Sockets ( ) { refresh Aperture ( ) ; int n = pending Sockets + active Sockets . size ( ) ; if ( n < target Aperture && ! active Factories . is Empty ( ) ) { logger . debug ( _ STR , n , target Aperture , target Aperture - n ) ; add Sockets ( target Aperture - n ) ; } else if ( target Aperture < active Sockets . size ( ) ) { logger . debug ( _ STR , n , target Aperture ) ; quick Slowest RS ( ) ; } long now =  Clock . now ( ) ; if ( now - last Refresh < refresh Period ) { return ; } else { long prev = refresh Period ; refresh Period = ( long )  Math . min ( refresh Period * _ NUM , max Refresh Period ) ; logger . info ( _ STR , prev / _ NUM , refresh Period / _ NUM ) ; } last Refresh = now ; add Sockets ( _ NUM ) ; }
public void split Query (  I invocation ,  String raw URI ) throws  IOException { int p = raw URI . index Of ( _ STR ) ; if ( p > _ NUM ) { invocation . set Query String ( raw URI . substring ( p + _ NUM ) ) ; raw URI = raw URI . substring ( _ NUM , p ) ; } invocation . set Raw URI ( raw URI ) ;  String uri = normalize Uri ( raw URI ) ; invocation . set URI ( uri ) ; }
public void test Pawn Moves ( ) throws  Chess Parse Error {  String fen = _ STR ;  Position pos =  Text IO . read FEN ( fen ) ; assert Equals ( fen ,  Text IO . to FEN ( pos ) ) ;  List <  String > str Moves = get Move List ( pos , _ BOOL ) ; assert True ( str Moves . contains ( _ STR ) ) ; assert True ( str Moves . contains ( _ STR ) ) ; assert True ( str Moves . contains ( _ STR ) ) ; assert True ( str Moves . contains ( _ STR ) ) ; assert True ( str Moves . contains ( _ STR ) ) ; assert True ( str Moves . contains ( _ STR ) ) ; assert True ( str Moves . contains ( _ STR ) ) ; assert True ( str Moves . contains ( _ STR ) ) ; assert Equals ( _ NUM , str Moves . size ( ) ) ; pos . set Ep Square ( - _ NUM ) ; str Moves = get Move List ( pos , _ BOOL ) ; assert Equals ( _ NUM , str Moves . size ( ) ) ; pos . set White Move ( _ BOOL ) ; str Moves = get Move List ( pos , _ BOOL ) ; assert True ( str Moves . contains ( _ STR ) ) ; assert True ( str Moves . contains ( _ STR ) ) ; assert True ( str Moves . contains ( _ STR ) ) ; assert True ( str Moves . contains ( _ STR ) ) ; assert Equals ( _ NUM , str Moves . size ( ) ) ; pos . set Piece (  Position . get Square ( _ NUM , _ NUM ) ,  Piece .  BPAWN ) ; str Moves = get Move List ( pos , _ BOOL ) ; assert True ( str Moves . contains ( _ STR ) ) ; assert True ( str Moves . contains ( _ STR ) ) ; assert True ( str Moves . contains ( _ STR ) ) ; assert True ( str Moves . contains ( _ STR ) ) ; }
public static int check And Correct (  Binary Message frame , int start Index ) { int syndrome = get Syndrome ( frame , start Index ) ; if ( syndrome == _ NUM ) { return _ NUM ; }  Binary Message copy = frame . get Sub Message ( start Index , start Index + _ NUM ) ; int index = - _ NUM ; int syndrome Weight =  MAX_ CORRECTABLE_ ERRORS ; int errors = _ NUM ; while ( index < _ NUM ) { if ( index != - _ NUM ) { if ( index > _ NUM ) { copy . flip ( index - _ NUM ) ; } copy . flip ( index ) ; syndrome Weight =  MAX_ CORRECTABLE_ ERRORS - _ NUM ; } syndrome = get Syndrome ( copy , _ NUM ) ; if ( syndrome > _ NUM ) { for ( int i = _ NUM ; i < _ NUM ; i ++ ) { errors =  Integer . bit Count ( syndrome ) ; if ( errors <= syndrome Weight ) { copy . xor ( _ NUM , _ NUM , syndrome ) ; copy . rotate Right ( i , _ NUM , _ NUM ) ; if ( index >= _ NUM ) { errors ++ ; } int corrected = copy . get Int ( _ NUM , _ NUM ) ; int original = frame . get Int ( start Index , start Index + _ NUM ) ; int error Count =  Integer . bit Count ( original ^ corrected ) ; if ( error Count <= _ NUM ) { frame . load ( start Index , _ NUM , corrected ) ; } return error Count ; } else { copy . rotate Left ( _ NUM , _ NUM ) ; syndrome = get Syndrome ( copy , _ NUM ) ; } } index ++ ; } } return _ NUM ; }
public static  Expr Node [ ] validate (  String view Name ,  Event Type event Type ,  Statement Context statement Context ,  List <  Expr Node > expressions , boolean allow Constant Result ) throws  View Parameter Exception {  List <  Expr Node > results = new  Array List <  Expr Node > ( ) ; int expression Number = _ NUM ;  Stream Type Service stream Type Service = new  Stream Type Service Impl ( event Type , null , _ BOOL , statement Context . get Engine URI ( ) ) ; for (  Expr Node expr : expressions ) {  Expr Node validated = validate Expr ( view Name , statement Context , expr , stream Type Service , expression Number ) ; results . add ( validated ) ; if ( ( ! allow Constant Result ) && ( validated . is Constant Result ( ) ) ) {  String message = _ STR + expression Number + get View Desc ( view Name ) + _ STR ; log . error ( message ) ; throw new  View Parameter Exception ( message ) ; } expression Number ++ ; } return results . to Array ( new  Expr Node [ results . size ( ) ] ) ; }
public static  String strip Comments (  String s ,  Parse Result result ) { int comment Start = s . index Of ( _ STR ) ; if ( comment Start != - _ NUM ) { s = s . substring ( _ NUM , comment Start ) ; result . comment Start Pos = comment Start ; int index = s . index Of ( _ STR ) ; while ( index > - _ NUM ) { result . comment Start Pos -= _ NUM ; index = s . index Of ( _ STR , index + _ NUM ) ; } } return s . trim ( ) ; }
@  Override public  String generate URL (  XYDataset dataset , int series , int item ) {  String url = this . prefix ; boolean first Parameter = url . index Of ( _ STR ) == - _ NUM ; url += first Parameter ? _ STR : _ STR ; url += this . series Parameter Name + _ STR + series + _ STR + this . item Parameter Name + _ STR + item ; return url ; }
public boolean is Idle Expire ( ) { if ( ! _lifecycle . is Active ( ) ) { return _ BOOL ; } long now = get Current Time Actual ( ) ; long idle Expire = _thread Idle Expire Time . get ( ) ; int idle Count = _idle Count . get ( ) ; if ( _idle Min < idle Count ) { long next Idle Expire = now + _idle Timeout ; if ( _idle Max < idle Count && _idle Min < _idle Max ) { _thread Idle Expire Time . compare And Set ( idle Expire , next Idle Expire ) ; return _ BOOL ; } else if ( idle Expire < now && _thread Idle Expire Time . compare And Set ( idle Expire , next Idle Expire ) ) { return _ BOOL ; } } return _ BOOL ; }
public void handle Button1 Request (  Request Invocation Event event ) throws  Model Control Exception {  FSAuth Domains Model model = (  FSAuth Domains Model ) get Model ( ) ;  String name = (  String ) get Display Field Value ( model .  TF_ NAME ) ;  AMProperty Sheet ps = (  AMProperty Sheet ) get Child (  PROPERTY_ ATTRIBUTE ) ; try {  String realm = model . get Realm ( name ) ;  Map values = ps . get Attribute Values ( model . get Data Map ( ) , _ BOOL , model ) ; model . set Attribute Values ( realm , name , values ) ;  Serialized Field sz Cache = (  Serialized Field ) get Child (  SZ_ CACHE ) ;  Federation View Bean vb = (  Federation View Bean ) get View Bean (  Federation View Bean . class ) ;  CCAdd Remove add Remove List = (  CCAdd Remove ) get Child (  ADD_ REMOVE_ PROVIDERS ) ; add Remove List . restore State Data ( ) ;  CCAdd Remove Model add Remove Model = (  CCAdd Remove Model ) add Remove List . get Model ( ) ;  List list = new  Array List ( get Selected Values ( add Remove Model ) ) ; model . add Providers ( realm , name , list ) ; set Inline Alert Message (  CCAlert .  TYPE_ INFO , _ STR , _ STR ) ; forward To ( ) ; } catch (  AMConsole Exception e ) { set Inline Alert Message (  CCAlert .  TYPE_ ERROR , _ STR , e . get Message ( ) ) ; forward To ( ) ; } }
public boolean strip (  String infile ,  String outfile ) { if ( infile == null ) throw new  Null Pointer Exception ( _ STR ) ;  File in = new  File ( infile ) ;  File out = null ; if ( outfile != null ) out = new  File ( outfile ) ; return strip ( in , out ) ; }
void run (  String driver ,  String url ,  String user ,  String password ) throws  Exception {  Class . for Name ( driver ) ; conn =  Driver Manager . get Connection ( url , user , password ) ; stat = conn . create Statement ( ) ; try { stat . execute ( _ STR ) ; } catch (  SQLException e ) { } stat . execute ( _ STR + _ STR ) ; stat . execute ( _ STR ) ; stat . execute ( _ STR ) ; stat . execute ( _ STR ) ; login By Name Insecure ( ) ; if ( url . starts With ( _ STR ) ) { login Stored Procedure Insecure ( ) ; limit Row Access ( ) ; } login By Name Secure ( ) ; if ( url . starts With ( _ STR ) ) { stat . execute ( _ STR ) ; stat . execute ( _ STR ) ; stat . execute ( _ STR ) ; } login By Id Insecure ( ) ; login By Id Secure ( ) ; try { stat . execute ( _ STR ) ; } catch (  SQLException e ) { } stat . execute ( _ STR + _ STR ) ; stat . execute ( _ STR ) ; stat . execute ( _ STR ) ; stat . execute ( _ STR ) ; stat . execute ( _ STR ) ; stat . execute ( _ STR ) ; list Active Items ( ) ; if ( url . starts With ( _ STR ) ) { stat . execute ( _ STR ) ; stat . execute ( _ STR ) ; stat . execute ( _ STR ) ; stat . execute ( _ STR ) ; list Active Items Using Constants ( ) ; } list Items Sorted Insecure ( ) ; list Items Sorted Secure ( ) ; if ( url . starts With ( _ STR ) ) { list Items Sorted Secure Param ( ) ; store Password Hash With Salt ( ) ; } conn . close ( ) ; }
public boolean remove Job Group To Never Delete (  String group ) { return group != null && job Groups To Never Delete . remove ( group ) ; }
private  Mobile Doc create Layout (  Mobile Doc doc ,  MWorkflow wf , int active Node ,  MWFNode [ ] nodes ,  Array List nodes_ ID , int [ ] [ ] image Map ) { body b = doc . get Body ( ) ; b . add Element ( print Workflow ( active Node , wf , nodes , nodes_ ID , image Map ) ) ; b . add Element ( new hr ( ) ) ; b . add Element ( print Description ( active Node , wf , nodes , nodes_ ID ) ) ; b . add Element ( new br ( ) ) ; b . add Element ( print Control Panel ( active Node , wf , nodes , nodes_ ID ) ) ; return doc ; }
@  Override public void request Close Read ( ) { _state = _state . to Close Read ( ) ; try { request Loop ( ) ; } catch (  Exception e ) { log . log (  Level .  WARNING , e . to String ( ) , e ) ; } }
public  Multi Match Query Builder field (  String field , float boost ) { fields . add ( field ) ; if ( fields Boosts == null ) { fields Boosts = new  Object Float Hash Map < > ( ) ; } fields Boosts . put ( field , boost ) ; return this ; }
public void print String (  String v , int offset , int length ) throws  IOException { for ( int i = _ NUM ; i < length ; i ++ ) { char ch = v . char At ( i + offset ) ; if ( ch == _ STR ) { os . write ( _ STR ) ; os . write ( _ STR ) ; os . write ( _ STR ) ; os . write ( _ STR ) ; os . write ( _ STR ) ; } else if ( ch == _ STR ) { os . write ( _ STR ) ; os . write ( _ STR ) ; os . write ( _ STR ) ; os . write ( _ STR ) ; os . write ( _ STR ) ; } else if ( ch < _ NUM ) os . write ( ch ) ; else if ( ch < _ NUM ) { os . write ( _ NUM + ( ( ch > > _ NUM ) & _ NUM ) ) ; os . write ( _ NUM + ( ch & _ NUM ) ) ; } else { os . write ( _ NUM + ( ( ch > > _ NUM ) & _ NUM ) ) ; os . write ( _ NUM + ( ( ch > > _ NUM ) & _ NUM ) ) ; os . write ( _ NUM + ( ch & _ NUM ) ) ; } } }
public void await All Acks Received ( ) throws  Ignite Interrupted Checked Exception { lock . lock ( ) ; try { while ( ! ack Map . is Empty ( ) )  U . await ( all Acks Rcv Cond ) ; } finally { lock . unlock ( ) ; } }
public  String describe Attributes ( ) {  String Builder sb = new  String Builder ( ) ; sb . append ( _ STR ) ; boolean first = _ BOOL ; for (  Object key : attributes . key Set ( ) ) { if ( first ) { first = _ BOOL ; } else { sb . append ( _ STR ) ; } sb . append ( key ) ; sb . append ( _ STR ) ; sb . append ( attributes . get ( key ) ) ; } sb . append ( _ STR ) ; return sb . to String ( ) ; }
public int inflate Byte Array ( int number Of Bytes , byte [ ] source , byte [ ] target ) throws  Data Format Exception { if ( number Of Bytes == _ NUM ) return _ NUM ; if ( number Of Bytes < _ NUM ) {  System . arraycopy ( source , _ NUM , target , _ NUM , source . length ) ; return  Math . abs ( number Of Bytes ) ; } inflater . set Input ( source , _ NUM , number Of Bytes ) ; int result Length = inflater . inflate ( target ) ; inflater . reset ( ) ; return result Length ; }
public double linear Distance (  Location location ) { if ( location == null ) { throw new  Illegal Argument Exception (  Logger . log Message (  Logger .  ERROR , _ STR , _ STR , _ STR ) ) ; } double lat1 =  Math . to Radians ( this . latitude ) ; double lon1 =  Math . to Radians ( this . longitude ) ; double lat2 =  Math . to Radians ( location . latitude ) ; double lon2 =  Math . to Radians ( location . longitude ) ; if ( lat1 == lat2 && lon1 == lon2 ) { return _ NUM ; } double d Lat = lat2 - lat1 ; double d Lon = lon2 - lon1 ; if (  Math . abs ( d Lon ) >  Math .  PI ) { d Lon = d Lon > _ NUM ? - ( _ NUM *  Math .  PI - d Lon ) : ( _ NUM *  Math .  PI + d Lon ) ; } double distance Radians =  Math . sqrt ( d Lat * d Lat + d Lon * d Lon ) ; return  Double . is Na N ( distance Radians ) ? _ NUM : distance Radians ; }
private void read Mime File (  Reader mime File ) throws  IOException { mime Map = new  Hash Map <  String ,  Adaptive Rate > ( ) ;  Buffered Reader reader = new  Buffered Reader ( mime File ) ;  String line = null ;  String [ ] splits = null ; while ( ( line = reader . read Line ( ) ) != null ) { if (  String Utils . is Not Blank ( line ) && ! line . starts With ( _ STR ) ) { splits = line . split ( _ STR ) ; if ( splits . length == _ NUM ) { mime Map . put (  String Utils . lower Case ( splits [ _ NUM ] ) , new  Adaptive Rate ( new  Float ( splits [ _ NUM ] ) , new  Float ( splits [ _ NUM ] ) ) ) ; } else {  LOG . warn ( _ STR + line ) ; } } } }
private void draw ( final  Execution Unit process , final  Graphics2 D g2 , final  Process Renderer Model renderer Model , final boolean printing ) { if ( ! visualizer . is Active ( ) ) { return ; }  List <  Operator > selected Operators = renderer Model . get Selected Operators ( ) ; for (  Operator operator : process . get Operators ( ) ) { if ( selected Operators . contains ( operator ) ) { continue ; } draw Op Anno ( operator , g2 , renderer Model , printing ) ; } for (  Operator sel Op : selected Operators ) { if ( process . equals ( sel Op . get Execution Unit ( ) ) ) { draw Op Anno ( sel Op , g2 , renderer Model , printing ) ; } } }
@  Override public void modify Variable Id (  String old Id ,  String new Id ) { if ( variable . equals ( old Id ) ) { variable = new Id ; } if ( discrete Cache != null ) { discrete Cache . modify Variable Id ( old Id , new Id ) ; } }
protected void initialize ( ) {  List <  Add User Fields .  Attribute Spec > specs = m_filter . get Attribute Specs ( ) ; m_list Model = new  Default List Model ( ) ; m_list . set Model ( m_list Model ) ; if ( specs . size ( ) > _ NUM ) { m_up But . set Enabled ( _ BOOL ) ; m_down But . set Enabled ( _ BOOL ) ; for (  Add User Fields .  Attribute Spec s : specs ) {  Add User Fields .  Attribute Spec spec Copy = new  Add User Fields .  Attribute Spec ( s . to String Internal ( ) ) ; m_list Model . add Element ( spec Copy ) ; } m_list . repaint ( ) ; } else { m_name Field . set Enabled ( _ BOOL ) ; m_type Field . set Enabled ( _ BOOL ) ; m_date Format Field . set Enabled ( _ BOOL ) ; m_value Field . set Enabled ( _ BOOL ) ; } }
public static int parse Int Default ( final  String s , final int def ) { if ( s == null ) { return def ; } int r ; try { r =  Integer . parse Int ( s ) ; } catch ( final  Number Format Exception e ) { r = def ; } return r ; }
protected final void add Workers (  Collection <  Worker Thread > workers ) { for ( final  Iterator <  Worker Thread > iter = workers . iterator ( ) ; iter . has Next ( ) ; ) { final  Worker Thread worker = iter . next ( ) ; add Worker ( worker ) ; } }
public static <  V >  Mapping <  Map <  String ,  V > > map (  Mapping <  V > v Base ,  Constraint ... constraints ) { return map ( text ( ) , v Base , constraints ) ; }
public boolean equals (  Object object ) { if ( this == object ) { return _ BOOL ; } else if ( object instanceof  Namespace ) {  Namespace that = (  Namespace ) object ; if ( hash Code ( ) == that . hash Code ( ) ) { return uri . equals ( that . get URI ( ) ) && prefix . equals ( that . get Prefix ( ) ) ; } } return _ BOOL ; }
private boolean is On List (  Vector <  String > list ,  String name ) { if ( list . size ( ) == _ NUM ) return _ BOOL ; for ( int i = _ NUM ; i < list . size ( ) ; i ++ ) {  String list Name = (  String ) list . get ( i ) ; if ( name . ends With ( list Name ) ) { return _ BOOL ; } } return _ BOOL ; }
private static  String make Qualified Method Name (  String name ,  String [ ] params ) {  String Buffer sb = new  String Buffer ( name ) ; sb . append ( _ STR ) ; for ( int i = _ NUM ; i < params . length ; i ++ ) { sb . append ( _ STR ) ; sb . append ( params [ i ] ) ; } return sb . to String ( ) ; }
void write ( ) { clear Attributes ( ) ; if ( term Attribute . length ( ) < buffer . length ( ) ) { term Attribute . resize Buffer ( buffer . length ( ) ) ; } char termbuffer [ ] = term Attribute . buffer ( ) ; buffer . get Chars ( _ NUM , buffer . length ( ) , termbuffer , _ NUM ) ; term Attribute . set Length ( buffer . length ( ) ) ; if ( has Illegal Offsets ) { offset Attribute . set Offset ( saved Start Offset , saved End Offset ) ; } else { offset Attribute . set Offset ( start Offset , end Offset ) ; } pos Inc Attribute . set Position Increment ( position ( _ BOOL ) ) ; type Attribute . set Type ( saved Type ) ; accum Pos Inc = _ NUM ; }
public  Pattern extract Ip (  String str ) {  Pattern pattern = null ;  String [ ] ips = str . split ( _ STR ) ;  List <  Ip Node > ip Nodes = new  Array List < > ( ) ; for (  String ip : ips ) { ip = ip . trim ( ) ; if ( ip . index Of ( _ STR ) != - _ NUM ) { int mask =  Integer . value Of ( ip . substring ( ip . index Of ( _ STR ) + _ NUM ) ) ; ip = ip . substring ( _ NUM , ip . index Of ( _ STR ) ) ; while ( ip . split ( _ STR ) . length < _ NUM ) { ip += _ STR ; }  Ip Node node = new  Ip Node ( ip , mask ) ; ip Nodes . add ( node ) ; } else {  Ip Node node = new  Ip Node ( ip , _ NUM ) ; ip Nodes . add ( node ) ; } } pattern = new  Ip Pattern ( ip Nodes ) ; return pattern ; }
@  Override public void message Received (  Next Filter next Filter ,  Io Session session ,  Object message ) throws  Exception {  LOGGER . debug ( _ STR , session . get Id ( ) ) ; if ( ! ( message instanceof  Io Buffer ) ) { next Filter . message Received ( session , message ) ; return ; }  Io Buffer in = (  Io Buffer ) message ;  Protocol Decoder decoder = factory . get Decoder ( session ) ;  Protocol Decoder Output decoder Out = get Decoder Out ( session , next Filter ) ; while ( in . has Remaining ( ) ) { int old Pos = in . position ( ) ; try { lock . acquire ( ) ; decoder . decode ( session , in , decoder Out ) ; decoder Out . flush ( next Filter , session ) ; } catch (  Exception e ) {  Protocol Decoder Exception pde ; if ( e instanceof  Protocol Decoder Exception ) { pde = (  Protocol Decoder Exception ) e ; } else { pde = new  Protocol Decoder Exception ( e ) ; } if ( pde . get Hexdump ( ) == null ) { int cur Pos = in . position ( ) ; in . position ( old Pos ) ; pde . set Hexdump ( in . get Hex Dump ( ) ) ; in . position ( cur Pos ) ; } decoder Out . flush ( next Filter , session ) ; next Filter . exception Caught ( session , pde ) ; if ( ! ( e instanceof  Recoverable Protocol Decoder Exception ) || ( in . position ( ) == old Pos ) ) { break ; } } finally { lock . release ( ) ; } } }
public  Object parse Object (  String source ,  Parse Position pos ) { return null ; }
public  Stream <  T > stream ( ) { return  Stream Support . stream ( spliterator ( ) , _ BOOL ) ; }
public boolean rewrite Exif (  Byte Buffer buf ,  Collection <  Exif Tag > tags ) throws  IOException {  Exif Modifier mod = null ; try { mod = new  Exif Modifier ( buf , this ) ; for (  Exif Tag t : tags ) { mod . modify Tag ( t ) ; } return mod . commit ( ) ; } catch (  Exif Invalid Format Exception e ) { throw new  IOException ( _ STR + e ) ; } }
protected  Size2 D arrange NN (  Block Container container ,  Graphics2 D g2 ) { double max W = _ NUM ; double max H = _ NUM ;  List blocks = container . get Blocks ( ) ;  Iterator iterator = blocks . iterator ( ) ; while ( iterator . has Next ( ) ) {  Block b = (  Block ) iterator . next ( ) ; if ( b != null ) {  Size2 D s = b . arrange ( g2 ,  Rectangle Constraint .  NONE ) ; max W =  Math . max ( max W , s . width ) ; max H =  Math . max ( max H , s . height ) ; } } double width = this . columns * max W ; double height = this . rows * max H ;  Rectangle Constraint c = new  Rectangle Constraint ( width , height ) ; return arrange FF ( container , g2 , c ) ; }
public static boolean is File Transfer Over Http (  Sip Request request ) {  Cpim Message message = extract Cpim Message ( request ) ; if ( message == null ) { return _ BOOL ; }  String content Type = message . get Content Type ( ) ; return content Type != null && content Type . starts With (  File Transfer Http Info Document .  MIME_ TYPE ) ; }
public static org . opcfoundation . ua . transport . security .  Key Pair create Https Certificate (  String host Name ,  String application Uri , int days , org . opcfoundation . ua . transport . security .  Key Pair issuer Cert ) throws  IOException ,  General Security Exception { if ( application Uri == null ) throw new  Null Pointer Exception ( _ STR ) ; if ( logger . is Debug Enabled ( ) ) logger . debug ( _ STR ,  Arrays . to String (  Security . get Providers ( ) ) ) ;  Key Pair key Pair = generate Key Pair ( ) ;  X509 Certificate cert ; cert = generate Certificate ( _ STR + host Name , days , application Uri , key Pair . get Public ( ) , key Pair . get Private ( ) , issuer Cert ) ; return to Key Pair ( cert , key Pair . get Private ( ) ) ; }
@  Suppress Warnings ( _ STR ) public void handle Button1 Request (  Request Invocation Event event ) throws  Model Control Exception { submit Cycle = _ BOOL ;  String sub Config Name = (  String ) get Display Field Value (  TF_ EVENT_ HANDLER_ NAME ) ; if (  String Utils . is Blank ( sub Config Name ) ) { set Inline Alert Message (  CCAlert .  TYPE_ ERROR ,  ERROR_ MESSAGE , _ STR ) ; forward To ( ) ; }  Abstract Audit Model model = (  Abstract Audit Model ) get Model ( ) ; try {  AMProperty Sheet ps = (  AMProperty Sheet ) get Child (  PROPERTY_ ATTRIBUTE ) ;  String schema Name = (  String ) get Page Session Attribute (  AUDIT_ HANDLER_ TYPE ) ; @  Suppress Warnings ( _ STR )  Map <  String ,  Set <  String > > values = ps . get Attribute Values ( model . get Event Handler Attribute Names ( schema Name ) ) ; model . create Event Handler ( sub Config Name , schema Name , values ) ; back To Profile View Bean ( ) ; } catch (  AMConsole Exception e ) { set Inline Alert Message (  CCAlert .  TYPE_ ERROR ,  ERROR_ MESSAGE , e . get Message ( ) ) ; forward To ( ) ; } }
public static byte [ ] pattern To Hash (  List <  Lock Pattern View .  Cell > pattern ) { if ( pattern == null ) { return null ; } else { int size = pattern . size ( ) ; byte [ ] res = new byte [ size ] ; for ( int i = _ NUM ; i < size ; i ++ ) {  Lock Pattern View .  Cell cell = pattern . get ( i ) ; res [ i ] = ( byte ) cell . get Index ( ) ; }  Message Digest md = null ; try { md =  Message Digest . get Instance ( _ STR ) ; return md . digest ( res ) ; } catch (  No Such Algorithm Exception e ) { e . print Stack Trace ( ) ; return res ; } } }
public void children Removed (  Bean Context Membership Event bcme ) {  Iterator it = bcme . iterator ( ) ; while ( it . has Next ( ) ) { find And Undo ( it . next ( ) ) ; } }
public static void mkdirs (  File directory ) throws  Create Directory Exception { if ( directory . exists ( ) ) { if ( directory . is Directory ( ) ) { return ; } if ( ! directory . delete ( ) ) { throw new  Create Directory Exception ( directory . get Absolute Path ( ) , new  File Delete Exception ( directory . get Absolute Path ( ) ) ) ; } } if ( ! directory . mkdirs ( ) && ! directory . is Directory ( ) ) { throw new  Create Directory Exception ( directory . get Absolute Path ( ) ) ; } }
public  String to Clock ( ) {  String Builder s = new  String Builder ( ) ; s . append ( ( ( this . weeks * _ NUM + this . days ) * _ NUM + this . hours ) + _ STR ) ; if ( this . minutes < _ NUM ) { s . append ( _ STR ) ; } s . append ( this . minutes + _ STR ) ; if ( this . seconds < _ NUM ) { s . append ( _ STR ) ; } s . append ( this . seconds + _ STR ) ; if ( this . milliseconds < _ NUM ) { s . append ( _ STR ) ; } if ( this . milliseconds < _ NUM ) { s . append ( _ STR ) ; } s . append ( this . milliseconds ) ; return s . to String ( ) ; }
public static boolean check File Name (  String name ) { if ( name . contains ( _ STR ) || name . contains ( _ STR ) || name . contains ( _ STR ) || name . contains ( _ STR ) || name . contains ( _ STR ) || name . contains ( _ STR ) || name . contains ( _ STR ) || name . contains ( _ STR ) || name . contains ( _ STR ) || name . contains ( _ STR ) ) { return _ BOOL ; } return _ BOOL ; }
public static  Artifact Coordinates from String (  String string ) { final  Matcher matcher =  VALID_ PATTERN . matcher ( string ) ; if ( matcher . matches ( ) ) { if ( matcher . group ( _ NUM ) != null ) { return new  Artifact Coordinates ( matcher . group ( _ NUM ) , matcher . group ( _ NUM ) , matcher . group ( _ NUM ) , matcher . group ( _ NUM ) ) ; } else { return new  Artifact Coordinates ( matcher . group ( _ NUM ) , matcher . group ( _ NUM ) , matcher . group ( _ NUM ) ) ; } } else { throw new  Illegal Argument Exception ( string ) ; } }
public boolean equals (  Object other ) { if ( other == null ) return _ BOOL ; if ( get Class ( ) != other . get Class ( ) ) { return _ BOOL ; }  Host Port that = (  Host Port ) other ; return port == that . port && host . equals ( that . host ) ; }
String rename Type (  Type type ) { if ( type == null ) { return null ; } if ( type . get Sort ( ) ==  Type .  OBJECT ) {  String in = type . get Internal Name ( ) ; return _ STR + rename Internal Type ( in ) + _ STR ; } else if ( type . get Sort ( ) ==  Type .  ARRAY ) {  String Builder sb = new  String Builder ( ) ; for ( int n = type . get Dimensions ( ) ; n > _ NUM ; n -- ) { sb . append ( _ STR ) ; } sb . append ( rename Type ( type . get Element Type ( ) ) ) ; return sb . to String ( ) ; } return type . get Descriptor ( ) ; }
public static void write Element List (  XMLOutput xml Output ,  String tag Name ,  Iterator <  String > list Value Iterator ) throws  IOException { while ( list Value Iterator . has Next ( ) ) { xml Output . open Tag ( tag Name ) ; xml Output . write Text ( list Value Iterator . next ( ) ) ; xml Output . close Tag ( tag Name ) ; } }
public  DPolicy Constraints (  JDialog parent , byte [ ] value ) throws  IOException { super ( parent ) ; set Title ( res . get String ( _ STR ) ) ; init Components ( ) ; prepopulate With Value ( value ) ; }
@  Request Mapping ( value = _ STR , method =  POST , produces =  APPLICATION_ JSON_ VALUE ) public  Response Entity <  Page Response <  Role DTO > > find All ( @  Request Body  Page Request By Example <  Role DTO > prbe ) throws  URISyntax Exception {  Page Response <  Role DTO > page Response = role DTOService . find All ( prbe ) ; return new  Response Entity < > ( page Response , new  Http Headers ( ) ,  Http Status .  OK ) ; }
public static final void write Byte Array Xml ( byte [ ] val ,  String name ,  Xml Serializer out ) throws  Xml Pull Parser Exception ,  IOException { if ( val == null ) { out . start Tag ( null , _ STR ) ; out . end Tag ( null , _ STR ) ; return ; } out . start Tag ( null , _ STR ) ; if ( name != null ) { out . attribute ( null , _ STR , name ) ; } final int  N = val . length ; out . attribute ( null , _ STR ,  Integer . to String (  N ) ) ;  String Builder sb = new  String Builder ( val . length * _ NUM ) ; for ( int i = _ NUM ; i <  N ; i ++ ) { int b = val [ i ] ; int h = b > > _ NUM ; sb . append ( h >= _ NUM ? ( _ STR + h - _ NUM ) : ( _ STR + h ) ) ; h = b & _ NUM ; sb . append ( h >= _ NUM ? ( _ STR + h - _ NUM ) : ( _ STR + h ) ) ; } out . text ( sb . to String ( ) ) ; out . end Tag ( null , _ STR ) ; }
public void cancel Requests By TAG (  Object  TAG , boolean may Interrupt If Running ) { if (  TAG == null ) { log . d (  LOG_ TAG , _ STR ) ; return ; } for (  List <  Request Handle > request List : request Map . values ( ) ) { if ( request List != null ) { for (  Request Handle request Handle : request List ) { if (  TAG . equals ( request Handle . get Tag ( ) ) ) request Handle . cancel ( may Interrupt If Running ) ; } } } }
public static void draw Horizontal Margin Indicator (  Graphics2 D g ,  String text , int x1 , int x2 , int y ) { if ( x1 > x2 ) { int temp = x1 ; x1 = x2 ; x2 = temp ; } if ( text == null ) { g . draw Line ( x1 , y , x2 , y ) ; g . draw Line ( x1 , y , x1 +  CONNECTION_ ARROW_ SIZE , y -  CONNECTION_ ARROW_ SIZE ) ; g . draw Line ( x1 , y , x1 +  CONNECTION_ ARROW_ SIZE , y +  CONNECTION_ ARROW_ SIZE ) ; g . draw Line ( x2 , y , x2 -  CONNECTION_ ARROW_ SIZE , y -  CONNECTION_ ARROW_ SIZE ) ; g . draw Line ( x2 , y , x2 -  CONNECTION_ ARROW_ SIZE , y +  CONNECTION_ ARROW_ SIZE ) ; return ; }  Canvas c = new  Canvas ( ) ;  Font Metrics fm = c . get Font Metrics ( s Font ) ; g . set Font ( s Font ) ; int padding = _ NUM ;  Rectangle2 D bounds = fm . get String Bounds ( text , g ) ; int th = ( int ) bounds . get Height ( ) ; int tw = ( int ) bounds . get Width ( ) ; int offset = _ NUM *  CONNECTION_ ARROW_ SIZE ; int w = ( ( x2 - x1 ) - ( tw + _ NUM * padding ) ) / _ NUM ; if ( w <= padding ) { g . draw Line ( x1 , y , x2 , y ) ; g . draw String ( text , x1 + w + padding , y + offset ) ; g . draw Line ( x1 , y -  CONNECTION_ ARROW_ SIZE , x1 , y +  CONNECTION_ ARROW_ SIZE ) ; g . draw Line ( x2 , y -  CONNECTION_ ARROW_ SIZE , x2 , y +  CONNECTION_ ARROW_ SIZE ) ; } else { g . draw Line ( x1 , y , x1 + w , y ) ; g . draw Line ( x2 - w , y , x2 , y ) ; g . draw String ( text , x1 + w + padding , ( int ) ( y + ( bounds . get Height ( ) / _ NUM ) ) ) ; g . draw Line ( x1 , y , x1 +  CONNECTION_ ARROW_ SIZE , y -  CONNECTION_ ARROW_ SIZE ) ; g . draw Line ( x1 , y , x1 +  CONNECTION_ ARROW_ SIZE , y +  CONNECTION_ ARROW_ SIZE ) ; g . draw Line ( x2 , y , x2 -  CONNECTION_ ARROW_ SIZE , y -  CONNECTION_ ARROW_ SIZE ) ; g . draw Line ( x2 , y , x2 -  CONNECTION_ ARROW_ SIZE , y +  CONNECTION_ ARROW_ SIZE ) ; } }
public static boolean different (  Generic Record first ,  Generic Record second ,  List <  String > value Field Names ) { for (  String value Field Name : value Field Names ) {  Object first Value = first . get ( value Field Name ) ;  Object second Value = second . get ( value Field Name ) ; if ( first Value != null && second Value != null && ! first Value . equals ( second Value ) ) { return _ BOOL ; } if ( ( first Value != null && second Value == null ) || ( first Value == null && second Value != null ) ) { return _ BOOL ; } } return _ BOOL ; }
static public int cancel Operation ( int token ) { int canceled = _ NUM ; synchronized ( s Work Queue ) {  Iterator <  Operation Info > it = s Work Queue . iterator ( ) ; while ( it . has Next ( ) ) { if ( it . next ( ) . token == token ) { it . remove ( ) ; ++ canceled ; } } } if (  Async Query Service . local LOGV ) {  Log . d (  TAG , _ STR + token + _ STR + canceled ) ; } return canceled ; }
final void long Accumulate ( long x ,  Long Binary Operator fn , boolean was Uncontended ) { int h ; if ( ( h = get Probe ( ) ) == _ NUM ) {  Thread Local Random . current ( ) ; h = get Probe ( ) ; was Uncontended = _ BOOL ; } boolean collide = _ BOOL ; for ( ; ; ) {  Cell [ ] as ;  Cell a ; int n ; long v ; if ( ( as = cells ) != null && ( n = as . length ) > _ NUM ) { if ( ( a = as [ ( n - _ NUM ) & h ] ) == null ) { if ( cells Busy == _ NUM ) {  Cell r = new  Cell ( x ) ; if ( cells Busy == _ NUM && cas Cells Busy ( ) ) { boolean created = _ BOOL ; try {  Cell [ ] rs ; int m , j ; if ( ( rs = cells ) != null && ( m = rs . length ) > _ NUM && rs [ j = ( m - _ NUM ) & h ] == null ) { rs [ j ] = r ; created = _ BOOL ; } } finally { cells Busy = _ NUM ; } if ( created ) break ; continue ; } } collide = _ BOOL ; } else if ( ! was Uncontended ) was Uncontended = _ BOOL ; else if ( a . cas ( v = a . value , ( ( fn == null ) ? v + x : fn . apply As Long ( v , x ) ) ) ) break ; else if ( n >=  NCPU || cells != as ) collide = _ BOOL ; else if ( ! collide ) collide = _ BOOL ; else if ( cells Busy == _ NUM && cas Cells Busy ( ) ) { try { if ( cells == as ) {  Cell [ ] rs = new  Cell [ n << _ NUM ] ; for ( int i = _ NUM ; i < n ; ++ i ) rs [ i ] = as [ i ] ; cells = rs ; } } finally { cells Busy = _ NUM ; } collide = _ BOOL ; continue ; } h = advance Probe ( h ) ; } else if ( cells Busy == _ NUM && cells == as && cas Cells Busy ( ) ) { boolean init = _ BOOL ; try { if ( cells == as ) {  Cell [ ] rs = new  Cell [ _ NUM ] ; rs [ h & _ NUM ] = new  Cell ( x ) ; cells = rs ; init = _ BOOL ; } } finally { cells Busy = _ NUM ; } if ( init ) break ; } else if ( cas Base ( v = base , ( ( fn == null ) ? v + x : fn . apply As Long ( v , x ) ) ) ) break ; } }
private static  Shape scale ( final  Shape current Polygon , final double x Scale Factor , final double y Scale Factor ) { final  Point2 D centroid = get Centroid ( current Polygon ) ; final  Affine Transform transform =  Affine Transform . get Translate Instance ( ( _ NUM - x Scale Factor ) * centroid . get X ( ) , ( _ NUM - y Scale Factor ) * centroid . get Y ( ) ) ; transform . scale ( x Scale Factor , y Scale Factor ) ; final  Shape shape = transform . create Transformed Shape ( current Polygon ) ; return shape ; }
public void list (  Print Stream out , int indent ) { for ( int i = _ NUM ; i < indent ; i ++ ) { out . print ( _ STR ) ; } out . println ( this ) ; }
private void init ( ) { set Title ( _ STR ) ; competitive Panel =  Competitive Properties Panel . create Competitive Properties Panel ( network Panel ,  Competitive Props Panel Type .  CREATE_ NETWORK ) ; tab Logic . add ( competitive Panel ) ; layout Panel = new  Main Layout Panel ( _ BOOL , this ) ; layout Panel . set Current Layout ( new  Line Layout ( ) ) ; tab Layout . add ( layout Panel ) ; tabbed Pane . add Tab ( _ STR , tab Logic ) ; tabbed Pane . add Tab ( _ STR , layout Panel ) ; set Content Pane ( tabbed Pane ) ;  Action help Action = new  Show Help Action ( competitive Panel . get Help Path ( ) ) ; add Button ( new  JButton ( help Action ) ) ; }
public static  Revocation Status check (  X509 Certificate cert ,  X509 Certificate issuer Cert ,  URI responder URI ,  X509 Certificate responder Cert ,  Date date ) throws  IOException ,  Cert Path Validator Exception { return check ( cert , issuer Cert , responder URI , responder Cert , date ,  Collections . <  Extension > empty List ( ) ) ; }
public static void clear Rect (  Graphics2 D g ,  Rectangle rect ,  Color background ) { if ( background != null ) { g . set Color ( background ) ; g . fill Rect ( rect . x , rect . y , rect . width , rect . height ) ; } else { g . set Composite (  Alpha Composite . get Instance (  Alpha Composite .  CLEAR , _ NUM ) ) ; g . fill Rect ( rect . x , rect . y , rect . width , rect . height ) ; g . set Composite (  Alpha Composite .  Src Over ) ; } }
public static  State load Binary (  Data Input Stream dis ) throws  IOException {  String [ ] phone List ; int phone List Length = dis . read Int ( ) ; if ( phone List Length == _ NUM ) { phone List = null ; } else { phone List = new  String [ phone List Length ] ; } for ( int i = _ NUM ; i < phone List Length ; i ++ ) { int index = dis . read Int ( ) ; phone List [ i ] = (  String ) phoneme Table . get ( index ) ; } return new  Final State ( phone List ) ; }
public static  File rename File (  File file ,  String new Name ) {  String absolute Path = file . get Absolute Path ( ) ;  String file Name = file . get Name ( ) ;  String new Absolute Path = absolute Path . substring ( _ NUM , absolute Path . last Index Of ( file Name ) ) + new Name ; return new  File ( new Absolute Path ) ; }
private double deviation ( double [ ] delta , double [ ] [ ] beta ) { final double a = square Sum ( delta ) ; final double b = square Sum ( transpose Times ( beta , delta ) ) ; return ( a > b ) ?  Math . sqrt ( a - b ) : _ NUM ; }
private  Json Writer open (  Json Scope empty ,  String open Bracket ) throws  IOException { before Value ( _ BOOL ) ; stack . add ( empty ) ; out . write ( open Bracket ) ; return this ; }
static double mypdf ( double value , double shape , double scale ) { return  Math . exp ( ( shape - _ NUM ) *  Math . log ( value ) - value / scale -  Gamma Function . log Gamma ( shape ) - shape *  Math . log ( scale ) ) ; }
private static  Properties load Properties ( ) {  Properties properties = new  Properties ( ) ;  File file = new  File ( _ STR ) ;  File Input Stream fis = null ; try { if ( file . exists ( ) ) { fis = new  File Input Stream ( file ) ; properties . load ( fis ) ; } } catch (  Exception e ) {  LOGGER . error ( e , e . get Message ( ) ) ; } finally { if ( null != fis ) { try { fis . close ( ) ; } catch (  IOException e ) {  LOGGER . error ( e , e . get Message ( ) ) ; } } } return properties ; }
private void assert Zip And Unzip Of Directory Matches Original (  File source Dir ) throws  IOException {  File [ ] source Files = source Dir . list Files ( ) ;  Arrays . sort ( source Files ) ;  File zip File = create Zip File Handle ( ) ;  Zip Files . zip Directory ( source Dir , zip File ) ;  File output Dir =  Files . create Temp Dir ( ) ;  Zip Files . unzip File ( zip File , output Dir ) ;  File [ ] output Files = output Dir . list Files ( ) ;  Arrays . sort ( output Files ) ; assert That ( output Files , array With Size ( source Files . length ) ) ; for ( int i = _ NUM ; i < source Files . length ; i ++ ) { compare File Contents ( source Files [ i ] , output Files [ i ] ) ; } remove Recursive ( output Dir . to Path ( ) ) ; assert True ( zip File . delete ( ) ) ; }
public static void to Do ( @  Scope int scope ,  String tag ) {  List <  Long > tag Seen List = tag Last Seen Map . get ( tag ) ; if ( tag Seen List . is Empty ( ) ) { to Do Set . put ( tag ) ; return ; }  Long tag Last Seen = tag Seen List . get ( tag Seen List . size ( ) - _ NUM ) ; if ( scope ==  THIS_ APP_ VERSION && tag Last Seen <= last App Updated Time ) { to Do Set . put ( tag ) ; } }
public void show Badge At Index ( int item Index , int badge Text , @  Color Int int badge Color ) { if ( item Index < _ NUM || item Index > space Items . size ( ) ) { throw Array Index Out Of Bounds Exception ( item Index ) ; } else {  Relative Layout badge View = badge List . get ( item Index ) ; if (  Build .  VERSION .  SDK_ INT >=  Build .  VERSION_ CODES .  JELLY_ BEAN ) { badge View . set Background (  Badge Helper . make Shape Drawable ( badge Color ) ) ; } else { badge View . set Background Drawable (  Badge Helper . make Shape Drawable ( badge Color ) ) ; }  Badge Item badge Item = new  Badge Item ( item Index , badge Text , badge Color ) ;  Badge Helper . show Badge ( badge View , badge Item , should Show Badge With Nine Plus ) ; badge Save Instance Hash Map . put ( item Index , badge Item ) ; } }
public void touch ( ) { next Check =  System . current Time Millis ( ) + (  MILLIS_ PER_ SECOND * modification Check Interval ) ; }
public  Catalog Entry ( int type ,  Vector args ) throws  Catalog Exception { try {  Integer i Args = (  Integer ) entry Args . get ( type ) ; if ( i Args . int Value ( ) != args . size ( ) ) { throw new  Catalog Exception (  Catalog Exception .  INVALID_ ENTRY ) ; } } catch (  Array Index Out Of Bounds Exception e ) { throw new  Catalog Exception (  Catalog Exception .  INVALID_ ENTRY_ TYPE ) ; } entry Type = type ; this . args = args ; }
private static  Array List <  Object > read Amf Strict Array (  Parsable Byte Array data ) { int count = data . read Unsigned Int To Int ( ) ;  Array List <  Object > list = new  Array List < > ( count ) ; for ( int i = _ NUM ; i < count ; i ++ ) { int type = read Amf Type ( data ) ; list . add ( read Amf Data ( data , type ) ) ; } return list ; }
protected void end Prefix Mapping (  Namespace Stack stack , int stack Size ) throws  SAXException { while ( stack . size ( ) > stack Size ) {  Namespace namespace = stack . pop ( ) ; if ( namespace != null ) { content Handler . end Prefix Mapping ( namespace . get Prefix ( ) ) ; } } }
public void add Member (  Stream member ) { member Set . add ( member ) ; }
public  Wildcard Pattern (  String pattern , boolean is Case Sensitive ,  String delimiters ) { this ( pattern , is Case Sensitive , _ BOOL , delimiters ) ; }
public int hash Code ( ) { int hash = type . hash Code ( ) ; if ( name != null ) hash ^= name . hash Code ( ) ; if ( actions != null ) hash ^= actions . hash Code ( ) ; return hash ; }
public  AMService Profile Model Impl (  Http Servlet Request req ,  String service Name ,  Map map ) throws  AMConsole Exception { super ( req , map ) ; this . service Name = service Name ; try { xml Builder = new  Property XMLBuilder ( service Name , get Display Schema Types ( ) , this ) ; if ( service Name . equals (  ADMIN_ CONSOLE_ SERVICE ) &&  Service Manager . is Realm Enabled ( ) ) {  AMView Config config =  AMView Config . get Instance ( ) ; xml Builder . discard Attribute ( config . get Realm Enable Hidden Console Attr Names ( ) ) ; } } catch (  SMSException e ) { throw new  AMConsole Exception ( get Error String ( e ) ) ; } catch (  SSOException e ) { throw new  AMConsole Exception ( get Error String ( e ) ) ; } }
@  Override public boolean equals (  Object obj ) { if ( obj == this ) { return _ BOOL ; } if ( ! ( obj instanceof  Default Interval Category Dataset ) ) { return _ BOOL ; }  Default Interval Category Dataset that = (  Default Interval Category Dataset ) obj ; if ( !  Arrays . equals ( this . series Keys , that . series Keys ) ) { return _ BOOL ; } if ( !  Arrays . equals ( this . category Keys , that . category Keys ) ) { return _ BOOL ; } if ( ! equal ( this . start Data , that . start Data ) ) { return _ BOOL ; } if ( ! equal ( this . end Data , that . end Data ) ) { return _ BOOL ; } return _ BOOL ; }
public static int convert To Color Int (  String argb ) throws  Number Format Exception { if ( argb . starts With ( _ STR ) ) { argb = argb . replace ( _ STR , _ STR ) ; } int alpha = - _ NUM , red = - _ NUM , green = - _ NUM , blue = - _ NUM ; if ( argb . length ( ) == _ NUM ) { alpha =  Integer . parse Int ( argb . substring ( _ NUM , _ NUM ) , _ NUM ) ; red =  Integer . parse Int ( argb . substring ( _ NUM , _ NUM ) , _ NUM ) ; green =  Integer . parse Int ( argb . substring ( _ NUM , _ NUM ) , _ NUM ) ; blue =  Integer . parse Int ( argb . substring ( _ NUM , _ NUM ) , _ NUM ) ; } else if ( argb . length ( ) == _ NUM ) { alpha = _ NUM ; red =  Integer . parse Int ( argb . substring ( _ NUM , _ NUM ) , _ NUM ) ; green =  Integer . parse Int ( argb . substring ( _ NUM , _ NUM ) , _ NUM ) ; blue =  Integer . parse Int ( argb . substring ( _ NUM , _ NUM ) , _ NUM ) ; } return  Color . argb ( alpha , red , green , blue ) ; }
@  Override public void on Action ( ) { on Action (  Action Type .  LOOK_ CLOSELY ) ; }
public  Dimensional Node Iterator (  Dimensional Node node ) { if ( node == null ) { throw new  Null Pointer Exception ( _ STR ) ; } stack . add ( new  Moment ( node , left ) ) ; advance ( ) ; }
@  Override public void start Element (  String namespace URI ,  String local Name ,  String q Name ,  Attributes atts ) throws  SAXException { if ( q Name . equals (  KEY_ TAG ) ) { clear Current Text ( ) ; } else { throw new  SAXException ( _ STR + q Name ) ; } }
public synchronized void cancel All ( ) { for (  Task Progress progress : task Info ) progress . set Cancelled ( _ BOOL ) ; }
public void read Row ( final  Data Input Stream in , final double [ ] data , final  Column Type [ ] column Types , final boolean sparse , final double [ ] sparse Defaults ) throws  IOException { if ( sparse ) {  System . arraycopy ( sparse Defaults , _ NUM , data , _ NUM , sparse Defaults . length ) ; while ( _ BOOL ) { int index = in . read Int ( ) ; if ( index == - _ NUM ) { break ; } else { data [ index ] = read Datum ( in , column Types [ index ] ) ; } } } else { for ( int att Index = _ NUM ; att Index < column Types . length ; att Index ++ ) { data [ att Index ] = read Datum ( in , column Types [ att Index ] ) ; } } }
public void initialize (  Context context ,  Haptic Feedback Controller haptic Feedback Controller , int initial Hours Of Day , int initial Minutes , boolean is24 Hour Mode ) { if ( m Time Initialized ) {  Log . e (  TAG , _ STR ) ; return ; } m Haptic Feedback Controller = haptic Feedback Controller ; m Is24 Hour Mode = is24 Hour Mode ; m Hide Am Pm = m Accessibility Manager . is Touch Exploration Enabled ( ) || m Is24 Hour Mode ; m Circle View . initialize ( context , m Hide Am Pm ) ; m Circle View . invalidate ( ) ; if ( ! m Hide Am Pm ) { m Am Pm Circles View . initialize ( context , initial Hours Of Day < _ NUM ?  AM :  PM ) ; m Am Pm Circles View . invalidate ( ) ; }  Resources res = context . get Resources ( ) ; int [ ] hours = { _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM } ; int [ ] hours_24 = { _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM } ; int [ ] minutes = { _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM } ;  String [ ] hours Texts = new  String [ _ NUM ] ;  String [ ] inner Hours Texts = new  String [ _ NUM ] ;  String [ ] minutes Texts = new  String [ _ NUM ] ; for ( int i = _ NUM ; i < _ NUM ; i ++ ) { hours Texts [ i ] =  Language Utils . get Persian Numbers ( is24 Hour Mode ?  String . format ( _ STR , hours_24 [ i ] ) :  String . format ( _ STR , hours [ i ] ) ) ; inner Hours Texts [ i ] =  Language Utils . get Persian Numbers (  String . format ( _ STR , hours [ i ] ) ) ; minutes Texts [ i ] =  Language Utils . get Persian Numbers (  String . format ( _ STR , minutes [ i ] ) ) ; } m Hour Radial Texts View . initialize ( res , hours Texts , ( is24 Hour Mode ? inner Hours Texts : null ) , m Hide Am Pm , _ BOOL ) ; m Hour Radial Texts View . set Selection ( is24 Hour Mode ? initial Hours Of Day : initial Hours Of Day % _ NUM ) ; m Hour Radial Texts View . invalidate ( ) ; m Minute Radial Texts View . initialize ( res , minutes Texts , null , m Hide Am Pm , _ BOOL ) ; m Minute Radial Texts View . set Selection ( initial Minutes ) ; m Minute Radial Texts View . invalidate ( ) ; set Value For Item (  HOUR_ INDEX , initial Hours Of Day ) ; set Value For Item (  MINUTE_ INDEX , initial Minutes ) ; int hour Degrees = ( initial Hours Of Day % _ NUM ) *  HOUR_ VALUE_ TO_ DEGREES_ STEP_ SIZE ; m Hour Radial Selector View . initialize ( context , m Hide Am Pm , is24 Hour Mode , _ BOOL , hour Degrees , is Hour Inner Circle ( initial Hours Of Day ) ) ; int minute Degrees = initial Minutes *  MINUTE_ VALUE_ TO_ DEGREES_ STEP_ SIZE ; m Minute Radial Selector View . initialize ( context , m Hide Am Pm , _ BOOL , _ BOOL , minute Degrees , _ BOOL ) ; m Time Initialized = _ BOOL ; }
protected void decode Image Data ( ) { int  Null Code = - _ NUM ; int npix = iw * ih ; int available , clear , code_mask , code_size , end_of_information , in_code , old_code , bits , code , count , i , datum , data_size , first , top , bi , pi ; if ( ( pixels == null ) || ( pixels . length < npix ) ) { pixels = new byte [ npix ] ; } if ( prefix == null ) prefix = new short [  Max Stack Size ] ; if ( suffix == null ) suffix = new byte [  Max Stack Size ] ; if ( pixel Stack == null ) pixel Stack = new byte [  Max Stack Size + _ NUM ] ; data_size = read ( ) ; clear = _ NUM << data_size ; end_of_information = clear + _ NUM ; available = clear + _ NUM ; old_code =  Null Code ; code_size = data_size + _ NUM ; code_mask = ( _ NUM << code_size ) - _ NUM ; for ( code = _ NUM ; code < clear ; code ++ ) { prefix [ code ] = _ NUM ; suffix [ code ] = ( byte ) code ; } datum = bits = count = first = top = pi = bi = _ NUM ; for ( i = _ NUM ; i < npix ; ) { if ( top == _ NUM ) { if ( bits < code_size ) { if ( count == _ NUM ) { count = read Block ( ) ; if ( count <= _ NUM ) break ; bi = _ NUM ; } datum += ( block [ bi ] & _ NUM ) << bits ; bits += _ NUM ; bi ++ ; count -- ; continue ; } code = datum & code_mask ; datum >>= code_size ; bits -= code_size ; if ( ( code > available ) || ( code == end_of_information ) ) break ; if ( code == clear ) { code_size = data_size + _ NUM ; code_mask = ( _ NUM << code_size ) - _ NUM ; available = clear + _ NUM ; old_code =  Null Code ; continue ; } if ( old_code ==  Null Code ) { pixel Stack [ top ++ ] = suffix [ code ] ; old_code = code ; first = code ; continue ; } in_code = code ; if ( code == available ) { pixel Stack [ top ++ ] = ( byte ) first ; code = old_code ; } while ( code > clear ) { pixel Stack [ top ++ ] = suffix [ code ] ; code = prefix [ code ] ; } first = suffix [ code ] & _ NUM ; if ( available >=  Max Stack Size ) break ; pixel Stack [ top ++ ] = ( byte ) first ; prefix [ available ] = ( short ) old_code ; suffix [ available ] = ( byte ) first ; available ++ ; if ( ( ( available & code_mask ) == _ NUM ) && ( available <  Max Stack Size ) ) { code_size ++ ; code_mask += available ; } old_code = in_code ; } top -- ; pixels [ pi ++ ] = pixel Stack [ top ] ; i ++ ; } for ( i = pi ; i < npix ; i ++ ) { pixels [ i ] = _ NUM ; } }
public  String find Value (  String k ) { if ( k == null ) { for ( int i = nkeys ; -- i >= _ NUM ; ) if ( keys [ i ] == null ) return values [ i ] ; } else for ( int i = nkeys ; -- i >= _ NUM ; ) { if ( k . equals Ignore Case ( keys [ i ] ) ) return values [ i ] ; } return null ; }
public boolean cleanup ( ) throws  IOException {  File System file System =  File System . get ( config ) ; boolean success = _ BOOL ; for (  Path file : files ) { success &= file System . delete ( file , _ BOOL ) ; } return success ; }
public static  Annotated Type Mirror remove Prefix ( final  Elements elements , final  Annotated Type Mirror anno Type ) {  Annotated Type Mirror result = anno Type . deep Copy ( _ BOOL ) ;  Set <  Annotation Mirror > annos = anno Type . get Annotations ( ) ; for (  Annotation Mirror anno : annos ) {  Annotation Mirror cleaned Mirror = remove Prefix ( elements , anno ) ; if ( cleaned Mirror != null ) { result . add Annotation ( cleaned Mirror ) ; } else { result . add Annotation ( anno ) ; } } return result ; }
public static  Date string To Date (  String strdate , @  Suppress Warnings ( _ STR )  String format ) {  Date date = null ;  Simple Date Format formatter = new  Simple Date Format ( format ) ; try { date = formatter . parse ( strdate ) ; } catch (  Parse Exception e ) { e . print Stack Trace ( ) ; } return date ; }
public static  Grid Java Process exec (  Class cls ,  String params , @  Nullable  Ignite Logger log , @  Nullable  Ignite In Closure <  String > print C , @  Nullable  Grid Abs Closure proc Killed C ) throws  Exception { return exec ( cls . get Canonical Name ( ) , params , log , print C , proc Killed C , null , null , null ) ; }
@  Override public  Validation Result validate (  IResource resource , int kind ,  Validation State state ,  IProgress Monitor monitor ) {  Validation Result result = new  Validation Result ( ) ;  IIDEType Script Project ts Project = (  IIDEType Script Project ) state . get (  TYPESCRIPT_ VALIDATOR_ CONTEXT ) ; if ( ts Project != null &&  Type Script Resource Util . can Consume Tsserver ( resource ) && ts Project . is In Scope ( resource ) ) {  IReporter reporter = result . get Reporter ( monitor ) ;  IIDEType Script File ts File = null ; boolean was Opened = _ BOOL ; try { ts File = ts Project . get Opened File ( resource ) ; if ( ts File != null ) { was Opened = _ BOOL ; } else { try { ts File = ts Project . open File ( resource , null ) ; } catch (  Type Script Exception e ) {  Trace . trace (  Trace .  SEVERE , _ STR , e ) ; } } if ( ts File != null ) {  Type Script Validation Helper . validate ( ts File , reporter , this ) ; } } finally { if ( ! was Opened && ts File != null ) { try { ts File . close ( ) ; } catch (  Type Script Exception e ) {  Trace . trace (  Trace .  SEVERE , _ STR , e ) ; } } } } return result ; }
@  Request Mapping ( value =  Api Url .  CITIZEN_ PASSWORD_ RECOVER , method =  Request Method .  POST ) public  Response Entity <  String > password Recover (  Http Servlet Request request ) {  Api Response res =  Api Response . new Instance ( ) ; try {  String identity = request . get Parameter ( _ STR ) ;  String redirect URL = request . get Parameter ( _ STR ) ;  String token = request . get Parameter ( _ STR ) ;  String new Password , confirm Password ; if (  String Utils . is Empty ( identity ) ) { return res . error ( get Message ( _ STR ) ) ; } if ( !  String Utils . is Empty ( token ) ) { new Password = request . get Parameter ( _ STR ) ; confirm Password = request . get Parameter ( _ STR ) ; if (  String Utils . is Empty ( new Password ) ) { return res . error ( get Message ( _ STR ) ) ; } else if ( ! new Password . equals ( confirm Password ) ) { return res . error ( get Message ( _ STR ) ) ; } else if ( identity Recovery Service . validate And Reset Password ( token , new Password ) ) { return res . success ( _ STR , get Message ( _ STR ) ) ; } else { return res . error ( get Message ( _ STR ) ) ; } } if ( identity . matches ( _ STR ) ) { if ( ! identity . matches ( _ STR ) ) { return res . error ( get Message ( _ STR ) ) ; } } else if ( ! identity . matches ( _ STR ) ) { return res . error ( get Message ( _ STR ) ) ; }  Citizen citizen = citizen Service . get Citizen By User Name ( identity ) ; if ( citizen == null ) { return res . error ( get Message ( _ STR ) ) ; } if ( identity Recovery Service . generate And Send User Password Recovery ( identity , redirect URL + _ STR , _ BOOL ) ) { return res . success ( _ STR , _ STR + (  String Utils . is Empty ( citizen . get Email Id ( ) ) ? _ STR : _ STR ) ) ; } return res . error ( _ STR ) ; } catch (  Exception e ) {  LOGGER . error ( _ STR , e ) ; return res . error ( get Message ( _ STR ) ) ; } }
public void on Settings (  View v ) {  Intent intent = new  Intent ( this ,  Config Prefs Activity . class ) ; intent . put Extra (  Config Prefs .  PREFS_ TYPE ,  Config Prefs .  VIDEO_ AND_ CONNECTION ) ; intent . put Extra (  Config Prefs .  FIXED_ FRAME_ SIZE , _ BOOL ) ; intent . put Extra (  Config Prefs .  FIXED_ FRAME_ RATE , _ BOOL ) ; start Activity ( intent ) ; }
private void write (  Coordinate [ ] coords ,  Writer writer , int level ) throws  IOException { start Line ( level , writer ) ; start Geom Tag (  GMLConstants .  GML_ COORDINATES , null , writer ) ; int dim = _ NUM ; if ( coords . length > _ NUM ) { if ( ! (  Double . is Na N ( coords [ _ NUM ] . z ) ) ) dim = _ NUM ; } boolean is New Line = _ BOOL ; for ( int i = _ NUM ; i < coords . length ; i ++ ) { if ( is New Line ) { start Line ( level + _ NUM , writer ) ; is New Line = _ BOOL ; } if ( dim == _ NUM ) { writer . write ( _ STR + coords [ i ] . x ) ; writer . write ( coordinate Separator ) ; writer . write ( _ STR + coords [ i ] . y ) ; } else if ( dim == _ NUM ) { writer . write ( _ STR + coords [ i ] . x ) ; writer . write ( coordinate Separator ) ; writer . write ( _ STR + coords [ i ] . y ) ; writer . write ( coordinate Separator ) ; writer . write ( _ STR + coords [ i ] . z ) ; } writer . write ( tuple Separator ) ; if ( ( i + _ NUM ) % max Coordinates Per Line == _ NUM && i < coords . length - _ NUM ) { writer . write ( _ STR ) ; is New Line = _ BOOL ; } } if ( ! is New Line ) writer . write ( _ STR ) ; start Line ( level , writer ) ; end Geom Tag (  GMLConstants .  GML_ COORDINATES , writer ) ; }
private static boolean is Intended Exception (  Exception e ,  Class < ? > clazz ) { final  String message = e . get Message ( ) ; return ( !  Text Utils . is Empty ( message ) && message . starts With ( clazz . get Name ( ) ) ) ; }
public static void swap Pivot (  Matrix source , long diag ,  Matrix s ,  Matrix t ) { long swap Row = diag ; long swap Col = diag ; double max Value =  Math . abs ( source . get As Double ( diag , diag ) ) ; long rows = source . get Row Count ( ) ; long cols = source . get Column Count ( ) ; double abs = _ NUM ; for ( long row = diag ; row < rows ; row ++ ) { for ( long col = diag ; col < cols ; col ++ ) { abs =  Math . abs ( source . get As Double ( row , col ) ) ; if ( abs > max Value ) { max Value = abs ; swap Row = row ; swap Col = col ; } } } if ( swap Row != diag ) { swap Rows ( source , swap Row , diag ) ; swap Rows ( t , swap Row , diag ) ; } if ( swap Col != diag ) { swap Cols ( source , swap Col , diag ) ; swap Cols ( s , swap Col , diag ) ; } }
private boolean can Access Clipboard ( ) {  Security Manager sm =  System . get Security Manager ( ) ; if ( sm == null ) return _ BOOL ; try { sm . check Permission (  Security Constants .  AWT .  ACCESS_ CLIPBOARD_ PERMISSION ) ; return _ BOOL ; } catch (  Security Exception e ) { } return _ BOOL ; }
public  Job create Job From Activiti Xml (  String activiti Xml ,  List <  Parameter > parameters ) throws  Exception { job Definition Service Test Helper . create Job Definition For Activiti Xml ( activiti Xml ) ; return job Service . create And Start Job ( create Job Create Request (  Abstract Service Test .  TEST_ ACTIVITI_ NAMESPACE_ CD ,  Abstract Service Test .  TEST_ ACTIVITI_ JOB_ NAME , parameters ) ) ; }
protected  Set <  File > retrieve Matching Files (  File root Dir ,  String pattern ) throws  IOException { if ( ! root Dir . exists ( ) ) { if ( logger . is Debug Enabled ( ) ) { logger . debug ( _ STR + root Dir . get Absolute Path ( ) + _ STR ) ; } return  Collections . empty Set ( ) ; } if ( ! root Dir . is Directory ( ) ) { if ( logger . is Warn Enabled ( ) ) { logger . warn ( _ STR + root Dir . get Absolute Path ( ) + _ STR ) ; } return  Collections . empty Set ( ) ; } if ( ! root Dir . can Read ( ) ) { if ( logger . is Warn Enabled ( ) ) { logger . warn ( _ STR + root Dir . get Absolute Path ( ) + _ STR ) ; } return  Collections . empty Set ( ) ; }  String full Pattern =  String Utils . replace ( root Dir . get Absolute Path ( ) ,  File . separator , _ STR ) ; if ( ! pattern . starts With ( _ STR ) ) { full Pattern += _ STR ; } full Pattern = full Pattern +  String Utils . replace ( pattern ,  File . separator , _ STR ) ;  Set <  File > result = new  Linked Hash Set <  File > ( _ NUM ) ; do Retrieve Matching Files ( full Pattern , root Dir , result ) ; return result ; }
private  String as Reg Pattern (  String string ) {  String Buffer out = new  String Buffer ( string . length ( ) ) ; for ( int i = _ NUM , length = string . length ( ) ; i < length ; i ++ ) { char ch = string . char At ( i ) ; if ( ch == _ STR ) { out . append ( _ STR ) ; } else if ( ch == _ STR ) { out . append ( _ STR ) ; } else { out . append ( ch ) ; } } return out . to String ( ) ; }
public final void open Pdf File From Stream ( final  Object filename , final  String password ) throws  Pdf Exception { close On Exit = _ BOOL ; if ( filename instanceof  Image Input Stream ) { final  Image Input Stream iis = (  Image Input Stream ) filename ; if ( is Open ) { close Pdf File ( ) ; } is Open = _ BOOL ; this . filename = _ STR +  System . current Time Millis ( ) ; org . jpedal .  Dev Flags . current File = this . filename ; res . flush ( ) ; res . flush Objects ( ) ; object Store Ref . store File Name ( this . filename ) ; current Pdf File = new  Pdf Object Reader ( password ) ; current Pdf File . open Pdf File ( iis ) ; open Pdf File ( ) ; } else { throw new  Runtime Exception ( filename + _ STR ) ; } }
protected void notify Measurement Period ( ) { trim Time =  System . current Time Millis ( ) ; trim Values = read Values ( ( int [ ] ) null ) ; }
private boolean is Usable ( ) { if ( ( this . access &  Opcodes .  ACC_ SYNTHETIC ) != _ NUM ) return _ BOOL ; if ( ( this . access &  Opcodes .  ACC_ BRIDGE ) != _ NUM ) return _ BOOL ; if ( ( this . access &  Opcodes .  ACC_ NATIVE ) != _ NUM ) return _ BOOL ; if ( method Name . contains ( _ STR ) ) return _ BOOL ; if (  Properties .  P_ REFLECTION_ ON_ PRIVATE <= _ NUM ) { if ( method Name . contains ( _ STR ) && ( access &  Opcodes .  ACC_ PRIVATE ) ==  Opcodes .  ACC_ PRIVATE ) return _ BOOL ; } return _ BOOL ; }
public  Multi Bot Manager (  Executor Service bot Pool ) { check Not Null ( bot Pool , _ STR ) ; this . bot Pool =  More Executors . listening Decorator ( bot Pool ) ; this . manager Number =  MANAGER_ COUNT . get And Increment ( ) ; }
private void read Object (  Object Input Stream in ) throws  IOException ,  Class Not Found Exception { in . default Read Object ( ) ; if ( server == null ) { throw new  Invalid Object Exception ( _ STR ) ; } else if ( lease == null ) { throw new  Invalid Object Exception ( _ STR ) ; } }
public void add Line End Cap (  Coordinate p0 ,  Coordinate p1 ) {  Line Segment seg = new  Line Segment ( p0 , p1 ) ;  Line Segment offset L = new  Line Segment ( ) ; compute Offset Segment ( seg ,  Position .  LEFT , distance , offset L ) ;  Line Segment offset R = new  Line Segment ( ) ; compute Offset Segment ( seg ,  Position .  RIGHT , distance , offset R ) ; double dx = p1 . x - p0 . x ; double dy = p1 . y - p0 . y ; double angle =  Math . atan2 ( dy , dx ) ; switch ( buf Params . get End Cap Style ( ) ) { case  Buffer Parameters .  CAP_ ROUND : seg List . add Pt ( offset L . p1 ) ; add Fillet ( p1 , angle +  Math .  PI / _ NUM , angle -  Math .  PI / _ NUM ,  CGAlgorithms .  CLOCKWISE , distance ) ; seg List . add Pt ( offset R . p1 ) ; break ; case  Buffer Parameters .  CAP_ FLAT : seg List . add Pt ( offset L . p1 ) ; seg List . add Pt ( offset R . p1 ) ; break ; case  Buffer Parameters .  CAP_ SQUARE :  Coordinate square Cap Side Offset = new  Coordinate ( ) ; square Cap Side Offset . x =  Math . abs ( distance ) *  Math . cos ( angle ) ; square Cap Side Offset . y =  Math . abs ( distance ) *  Math . sin ( angle ) ;  Coordinate square Cap LOffset = new  Coordinate ( offset L . p1 . x + square Cap Side Offset . x , offset L . p1 . y + square Cap Side Offset . y ) ;  Coordinate square Cap ROffset = new  Coordinate ( offset R . p1 . x + square Cap Side Offset . x , offset R . p1 . y + square Cap Side Offset . y ) ; seg List . add Pt ( square Cap LOffset ) ; seg List . add Pt ( square Cap ROffset ) ; break ; } }
@  Override public  E remove ( int location ) {  E result ; if ( location < _ NUM || location >= size ) { throw new  Index Out Of Bounds Exception ( _ STR + location + _ STR + size ) ; } if ( location == _ NUM ) { result = array [ first Index ] ; array [ first Index ++ ] = null ; } else if ( location == size - _ NUM ) { int last Index = first Index + size - _ NUM ; result = array [ last Index ] ; array [ last Index ] = null ; } else { int element Index = first Index + location ; result = array [ element Index ] ; if ( location < size / _ NUM ) {  System . arraycopy ( array , first Index , array , first Index + _ NUM , location ) ; array [ first Index ++ ] = null ; } else {  System . arraycopy ( array , element Index + _ NUM , array , element Index , size - location - _ NUM ) ; array [ first Index + size - _ NUM ] = null ; } } size -- ; if ( size == _ NUM ) { first Index = _ NUM ; } mod Count ++ ; return result ; }
public void add Rule (  Rule rule ) throws  Name Already Exists Exception ,  Invalid Name Exception { if ( rule . get Name ( ) == null ) { rule . set Name ( _ STR +  Service Type Manager . generate Random Name ( ) ) ; } if ( rules . contains Key ( rule . get Name ( ) ) ) { throw ( new  Name Already Exists Exception (  Res Bundle Utils . rb Name , _ STR , null , rule . get Name ( ) ,  Policy Exception .  RULE ) ) ; } else if ( rules . contains Value ( rule ) ) { throw ( new  Name Already Exists Exception (  Res Bundle Utils . rb Name , _ STR , null , rule . get Name ( ) ,  Policy Exception .  RULE ) ) ; } rules . put ( rule . get Name ( ) , rule ) ; }
public static final byte [ ] to Octets (  Attribute Type type ,  String str ) { final byte [ ] s = str . get Bytes (  Standard Charsets .  UTF_8 ) ; byte [ ] octets ; if ( s . length >  Attribute .  MAX_ ATTRIBUTE_ VALUE_ LENGTH ) { octets = new byte [  Attribute .  MAX_ ATTRIBUTE_ LENGTH ] ; octets [ _ NUM ] = ( byte ) type . get Type Code ( ) ; octets [ _ NUM ] = ( byte )  Attribute .  MAX_ ATTRIBUTE_ LENGTH ;  System . arraycopy ( s , _ NUM , octets , _ NUM ,  Attribute .  MAX_ ATTRIBUTE_ VALUE_ LENGTH ) ; } else { octets = new byte [ s . length + _ NUM ] ; octets [ _ NUM ] = ( byte ) type . get Type Code ( ) ; octets [ _ NUM ] = ( byte ) ( s . length + _ NUM ) ;  System . arraycopy ( s , _ NUM , octets , _ NUM , s . length ) ; } return octets ; }
public float round ( float d , int decimal Place ) {  Big Decimal bd = new  Big Decimal (  Float . to String ( d ) ) ; bd = bd . set Scale ( decimal Place ,  Big Decimal .  ROUND_ HALF_ UP ) ; return bd . float Value ( ) ; }
@  Override public synchronized void flush ( ) throws  IOException { check Not Closed ( ) ; flush Internal ( ) ; out . flush ( ) ; }
private final  File locate (  String name ) {  String prefix = _ STR ;  File source File = null ; int idx = _ NUM ; while ( _ BOOL ) { if ( ( idx == _ NUM ) && (  Tool IO . get User Dir ( ) != null ) ) { source File = new  File (  Tool IO . get User Dir ( ) , name ) ; } else { source File = new  File ( prefix + name ) ; } if ( source File . exists ( ) ) break ; if ( idx >= library Path Entries . size ( ) ) break ; prefix = (  String ) library Path Entries . element At ( idx ++ ) ; } return source File ; }
static boolean is Octet String Valid (  String value , int max Length ) { if ( value == null ) return _ BOOL ; if ( value . length ( ) > max Length ) return _ BOOL ; return _ BOOL ; }
private static double [ ] next Point Around Line ( double lat1 , double lon1 , double lat2 , double lon2 ) { double x1 = lon1 ; double x2 = lon2 ; double y1 = lat1 ; double y2 = lat2 ; double min X =  Math . min ( x1 , x2 ) ; double max X =  Math . max ( x1 , x2 ) ; double min Y =  Math . min ( y1 , y2 ) ; double max Y =  Math . max ( y1 , y2 ) ; if ( min X == max X ) { return new double [ ] { next Latitude Between ( min Y , max Y ) , next Longitude Near ( min X , _ NUM * ( max Y - min Y ) ) } ; } else if ( min Y == max Y ) { return new double [ ] { next Latitude Near ( min Y , _ NUM * ( max X - min X ) ) , next Longitude Between ( min X , max X ) } ; } else { double x = next Longitude Between ( min X , max X ) ; double y = ( y1 - y2 ) / ( x1 - x2 ) * ( x - x1 ) + y1 ; if (  Double . is Finite ( y ) == _ BOOL ) { y =  Math . copy Sign ( _ NUM , x1 ) ; } double delta = ( max Y - min Y ) * _ NUM ; y =  Math . min ( _ NUM , y ) ; y =  Math . max ( - _ NUM , y ) ; return new double [ ] { next Latitude Near ( y , delta ) , x } ; } }
public void add Clear Graph Data Button ( ) {  JButton clear Button = new  JButton ( _ STR ) ; clear Button . set Action (  Time Series Plot Actions . get Clear Graph Action ( this ) ) ; button Panel . add ( clear Button ) ; }
private static float logistic ( double normalized Value , int min , int max ) { double t = normalized Value * _ NUM ; double result = ( max * min *  Math . exp ( min * t ) ) / ( max + min *  Math . exp ( min * t ) ) ; return ( float ) result ; }
private void write Header String (  Buffered Writer output ) throws  IOException { output . write ( _ STR ) ; output . write ( delimiter ) ; output . write ( _ STR ) ; output . write ( delimiter ) ; for ( int i = _ NUM ; i < _ NUM ; i ++ ) { output . write ( _ STR ) ; output . write (  String . value Of ( i ) ) ; output . write ( delimiter ) ; } for ( int i = _ NUM ; i < _ NUM ; i ++ ) { output . write ( _ STR ) ; output . write (  String . value Of ( i ) ) ; output . write ( delimiter ) ; } output . write ( _ STR ) ; output . new Line ( ) ; }
public boolean is Plural ( ) { return type String . contains (  SUFFIX_ PLURAL ) ; }
public void add Notification ( @  Not Null  Notification notification ) { notifications . add ( notification ) ;  Notification Container Item item = new  Notification Container Item ( notification , resources ) ; item . set Delegate ( this ) ; int index = n Grid . get Row Count ( ) ; n Grid . resize Rows ( index + _ NUM ) ; n Grid . set Widget ( index , _ NUM , item ) ; }
public void delete Nfs Datastore (  File Share Rest Rep file System ,  URI datacenter Id ,  Datastore datastore ) {  String datastore Name = datastore . get Name ( ) ;  List <  Host System > hosts = get Hosts For Datastore ( datastore ) ; if ( hosts . is Empty ( ) ) { throw new  Illegal State Exception ( _ STR ) ; } enter Maintenance Mode ( datastore ) ; set Storage IOControl ( datastore , _ BOOL ) ; for (  Host System host : hosts ) { execute ( new  Delete Datastore ( host , datastore ) ) ; } remove Nfs Datastore Tag ( file System , datacenter Id , datastore Name ) ; }
private void check Size ( final int i ) { if ( i >= max_size ) { final int old_size = max_size ; max_size += increment_size ; if ( max_size <= i ) { max_size = i + increment_size + _ NUM ; } final int [ ] [ ] temp = items ; items = new int [ max_size ] [ _ NUM ] ;  System . arraycopy ( temp , _ NUM , items , _ NUM , old_size ) ; increment_size = increment Size ( increment_size ) ; } }
private void forward Media File (  String mime Type ,  Uri media Uri ) {  String reshare Path = _ STR + media Uri . get Path ( ) ;  Intent share Intent = new  Intent ( context ,  Im Url Activity . class ) ; share Intent . set Action (  Intent .  ACTION_ SEND ) ; share Intent . set Data And Type (  Uri . parse ( reshare Path ) , mime Type ) ; context . start Activity ( share Intent ) ; }
protected void schedule Tasks (  Set <  Task Image Container > tasks ) { synchronized ( m Shadow Task Map ) { for (  Task Image Container task : tasks ) {  Image Shadow Task shadow Task = m Shadow Task Map . get ( task . m Session ) ; if ( shadow Task == null ) { throw new  Illegal State Exception ( _ STR ) ; } switch ( task . get Processing Priority ( ) ) { case  FAST : m Thread Pool Fast . execute ( new  Task Done Wrapper ( this , shadow Task , task ) ) ; break ; case  AVERAGE : m Thread Pool Average . execute ( new  Task Done Wrapper ( this , shadow Task , task ) ) ; break ; case  SLOW : m Thread Pool Slow . execute ( new  Task Done Wrapper ( this , shadow Task , task ) ) ; break ; default : m Thread Pool Slow . execute ( new  Task Done Wrapper ( this , shadow Task , task ) ) ; break ; } } } }
public static  String unquote (  String name ) { if ( ! name . is Empty ( ) && name . char At ( _ NUM ) == _ STR ) { return name . substring ( _ NUM ) ; } return name ; }
public  Group create Group (  String player Name ) { if ( get Group ( player Name ) != null ) { return null ; }  Group group = new  Group ( ) ; group . add Member ( player Name ) ; groups . add ( group ) ; return group ; }
private static  Object report Get (  Object r ) throws  Interrupted Exception ,  Execution Exception { if ( r == null ) throw new  Interrupted Exception ( ) ; if ( r instanceof  Alt Result ) {  Throwable x , cause ; if ( ( x = ( (  Alt Result ) r ) . ex ) == null ) return null ; if ( x instanceof  Cancellation Exception ) throw (  Cancellation Exception ) x ; if ( ( x instanceof  Completion Exception ) && ( cause = x . get Cause ( ) ) != null ) x = cause ; throw new  Execution Exception ( x ) ; } return r ; }
public int write ( final  Protein protein , final boolean standalone ) throws  IOException { check Entry Hierarchy ( ) ; if ( entry Hierarchy != null ) { for (  Protein Xref xref : protein . get Cross References ( ) ) { final  Simple Protein simple Protein =  Simple Protein . value Of ( protein , xref , entry Hierarchy ) ; if ( simple Protein != null ) { final  Simple Hash model = build Model Map ( simple Protein , entry Hierarchy , standalone ) ;  Writer writer = null ; try { final  Template temp = free Marker Config . get Template ( free Marker Template ) ; check Temp Directory ( temp Directory ) ; if ( ! temp Directory . ends With (  File . separator ) ) { temp Directory = temp Directory +  File . separator ; }  Url Friendly Id Generator gen =  Url Friendly Id Generator . get Instance ( ) ;  String url Friendly Id = gen . generate ( xref . get Identifier ( ) ) ; final  Path new Result File =  Paths . get ( temp Directory + url Friendly Id + _ STR ) ; result Files . add ( new Result File ) ; writer =  Files . new Buffered Writer ( new Result File , character Set ) ; temp . process ( model , writer ) ; writer . flush ( ) ; } catch (  Template Exception e ) { e . print Stack Trace ( ) ; } catch (  IOException e ) { e . print Stack Trace ( ) ; } finally { if ( writer != null ) { writer . close ( ) ; } } } } } return _ NUM ; }
public  String to String ( ) {  String Buffer sb = new  String Buffer ( ) ; char [ ] separator = { _ STR , _ STR } ; for ( int i = _ NUM ; i < components . length ; i ++ ) { sb . append ( separator ) ; sb . append ( components [ i ] ) ; separator [ _ NUM ] = _ STR ; } sb . append ( _ STR ) ; return sb . to String ( ) ; }
private boolean is Valid Registry Based Authority (  String authority ) { int index = _ NUM ; int end = authority . length ( ) ; char test Char ; while ( index < end ) { test Char = authority . char At ( index ) ; if ( test Char == _ STR ) { if ( index + _ NUM >= end || ! is Hex ( authority . char At ( index + _ NUM ) ) || ! is Hex ( authority . char At ( index + _ NUM ) ) ) { return _ BOOL ; } index += _ NUM ; } else if ( ! is Path Character ( test Char ) ) { return _ BOOL ; } ++ index ; } return _ BOOL ; }
private double [ ] interpolate Non Zero Values ( double [ ] contour ) { for ( int i = _ NUM ; i < contour . length ; i ++ ) { if ( contour [ i ] == _ NUM ) { int index = find Next Index Non Zero ( contour , i ) ; if ( index == - _ NUM ) { for ( int j = i ; j < contour . length ; j ++ ) { contour [ j ] = contour [ j - _ NUM ] ; } break ; } else { for ( int j = i ; j < index ; j ++ ) { if ( i == _ NUM ) { contour [ j ] = contour [ index ] ; } else { contour [ j ] = contour [ j - _ NUM ] + ( ( contour [ index ] - contour [ i - _ NUM ] ) / ( index - i ) ) ; } } i = index - _ NUM ; } } } return contour ; }
private void _deserialize Query Field (  Query query ,  Element field ) throws  Page Exception ,  Converter Exception {  String name = field . get Attribute ( _ STR ) ;  Node List list = field . get Child Nodes ( ) ; int len = list . get Length ( ) ; int count = _ NUM ; for ( int i = _ NUM ; i < len ; i ++ ) {  Node node = list . item ( i ) ; if ( node instanceof  Element ) { query . set At (  Key Impl . init ( name ) , ++ count , _deserialize ( (  Element ) node ) ) ; } } }
private  RE concat (  RE x ,  RE y ) { if ( rec ==  Recursion .  RIGHT ) { return x . concat ( y ) ; } else { return y . concat ( x ) ; } }
public void add ( final  Object element ) {  Set old Selection = new  Hash Set ( selection ) ; boolean rv = selection . add ( element ) ; if ( rv ) { fire Selection Changed ( old Selection , selection ) ; } old Selection = null ; }
@  Override public void mouse Exited (  Mouse Event evt ) { delegate . mouse Moved ( evt ) ; }
public static void printf (  Locale locale ,  String format ,  Object ... args ) { out . printf ( locale , format , args ) ; out . flush ( ) ; }
public void test Sorts Same Attributes ( ) throws  Exception {  Xpp Dom dom1 =  Xpp Factory . build Dom ( _ STR ) ;  Xpp Dom dom2 =  Xpp Factory . build Dom ( _ STR ) ; assert Equals ( - _ NUM , comparator . compare ( dom1 , dom2 ) ) ; assert Equals ( _ STR , xpath . get ( ) ) ; assert Equals ( _ NUM , comparator . compare ( dom2 , dom1 ) ) ; assert Equals ( _ STR , xpath . get ( ) ) ; }
public void add (  Dalv Insn insn ) { insns . add ( insn ) ; update Info ( insn ) ; }
private boolean is Valid State (  String key ) { if ( key == null ) { return _ BOOL ; } if ( key . equals ( rbean . get String ( _ STR ) ) || key . equals ( rbean . get String ( _ STR ) ) ) { if ( log . is Debug Enabled ( ) ) { log . debug ( key + _ STR ) ; } return _ BOOL ; } for ( int i = _ NUM ; i < _valid Key . length ; i ++ ) { if ( key . equals ( _valid Key [ i ] ) ) { if ( log . is Debug Enabled ( ) ) { log . debug ( key + _ STR ) ; } return _ BOOL ; } } if ( log . is Debug Enabled ( ) ) { log . debug ( key + _ STR ) ; } return _ BOOL ; }
public static  Number add (  Number a ,  Number b ) { if ( is Floating Point ( a ) || is Floating Point ( b ) ) { return a . double Value ( ) + b . double Value ( ) ; } else { return a . long Value ( ) + b . long Value ( ) ; } }
public  Builder optional Attributes ( final  String ... name Or OIDs ) { return optional Attributes (  Arrays . as List ( name Or OIDs ) ) ; }
private void show Flags Dialog ( ) { int [ ] old Indices = flags List_ . get Selected Indices ( ) ;  String [ ] buttons = { _ STR , _ STR } ; int result =  JOption Pane . show Option Dialog ( tool Window Content , flags List_ , _ STR ,  JOption Pane .  YES_ NO_ CANCEL_ OPTION ,  JOption Pane .  PLAIN_ MESSAGE , null , buttons , buttons [ _ NUM ] ) ; if ( result != _ NUM ) { flags List_ . set Selected Indices ( old Indices ) ; } else { if ( flags List_ . get Selected Indices ( ) . length > _ NUM && flags List_ . is Selected Index ( _ NUM ) ) { flags List_ . remove Selection Interval ( _ NUM , _ NUM ) ; } update Flags Text Field ( ) ; } }
private static byte [ ] read Resource (  Resource r ) throws  IOException {  Byte Array Output Stream baos = new  Byte Array Output Stream ( ) ; byte [ ] buffer = new byte [ _ NUM ] ;  Input Stream is = r . open ( ) ; try { for ( ; ; ) { int cnt = is . read ( buffer ) ; if ( cnt == - _ NUM ) break ; baos . write ( buffer , _ NUM , cnt ) ; } } finally { try { is . close ( ) ; } catch (  IOException ex ) { } } return baos . to Byte Array ( ) ; }
public <  T >  Lazy Future Stream <  T > from Publisher ( final  Publisher < ? extends  T > publisher ) {  Objects . require Non Null ( publisher ) ; final  Seq Subscriber <  T > sub =  Seq Subscriber . subscriber ( ) ; publisher . subscribe ( sub ) ; return sub . to Future Stream ( this ) ; }
public  Protobuf Parser (  Listener <  Message Type > handler ,  Message Type prototype , int max Message Size , int timeout Millis ) { this . handler = handler ; this . prototype = prototype ; this . max Message Size =  Math . min ( max Message Size ,  Integer .  MAX_ VALUE - _ NUM ) ; set Timeout Enabled ( _ BOOL ) ; set Socket Timeout ( timeout Millis ) ; }
public void member Joined (  Client Membership Event event ) {  Notification notification = new  Notification (  JMXNotification Type .  CLIENT_ JOINED , server Source ,  Sequence Number . next ( ) ,  System . current Time Millis ( ) ,  Management Constants .  CLIENT_ JOINED_ PREFIX + event . get Member Id ( ) ) ; server Level Notif Emitter . send Notification ( notification ) ; member Level Notif Emitter . send Notification ( notification ) ; }
public  Black2 Red Gradient ( int max Count ) { this . max Count = max Count ; factor = max Count /  Math . log ( max Count ) ; }
public static void write Histogram (  TDouble Double Hash Map map ,  String key Col ,  String val Col ,  String file , boolean descending ) throws  IOException {  Buffered Writer writer = new  Buffered Writer ( new  File Writer ( file ) ) ; writer . write ( key Col ) ; writer . write (  TAB ) ; writer . write ( val Col ) ; writer . new Line ( ) ; double [ ] keys = map . keys ( ) ;  Arrays . sort ( keys ) ; if ( descending )  Array Utils . reverse ( keys ) ; for ( double key : keys ) { writer . write (  String . value Of ( key ) ) ; writer . write (  TAB ) ; writer . write (  String . value Of ( map . get ( key ) ) ) ; writer . new Line ( ) ; } writer . close ( ) ; }
public static <  T >  Completion Stage <  T > dereference (  Completion Stage < ? extends  Completion Stage <  T > > stage ) { return stage . then Compose (  Function . identity ( ) ) ; }
public static  Number plus (  Number left ,  Character right ) { return  Number Number Plus . plus ( left ,  Integer . value Of ( right ) ) ; }
public static  String clip String (  JComponent c ,  Font Metrics fm ,  String string , int avail Text Width ) {  String clip String = _ STR ; avail Text Width -=  Swing Utilities2 . string Width ( c , fm , clip String ) ; if ( avail Text Width <= _ NUM ) { return clip String ; } boolean needs Text Layout ; synchronized ( chars Buffer Lock ) { int string Length = sync Chars Buffer ( string ) ; needs Text Layout = is Complex Layout ( chars Buffer , _ NUM , string Length ) ; if ( ! needs Text Layout ) { int width = _ NUM ; for ( int n Chars = _ NUM ; n Chars < string Length ; n Chars ++ ) { width += fm . char Width ( chars Buffer [ n Chars ] ) ; if ( width > avail Text Width ) { string = string . substring ( _ NUM , n Chars ) ; break ; } } } } if ( needs Text Layout ) {  Attributed String a String = new  Attributed String ( string ) ; if ( c != null ) { a String . add Attribute (  Text Attribute .  NUMERIC_ SHAPING , c . get Client Property (  Text Attribute .  NUMERIC_ SHAPING ) ) ; }  Line Break Measurer measurer = new  Line Break Measurer ( a String . get Iterator ( ) ,  Break Iterator . get Character Instance ( ) , get Font Render Context ( c , fm ) ) ; string = string . substring ( _ NUM , measurer . next Offset ( avail Text Width ) ) ; } return string + clip String ; }
public boolean add Element (  Object obj ) { synchronized ( actions ) { if ( allow To Change ) { return actions . add ( obj ) ; } } return _ BOOL ; }
public boolean equals (  Object object ) { if ( this == object ) { return _ BOOL ; } else if ( object == null || get Class ( ) != object . get Class ( ) ) { return _ BOOL ; } return principal . equals ( object . to String ( ) ) ; }
@  Override public void reset References ( ) { _refs . clear ( ) ; }
public void add Slide ( @  Non Null  Fragment fragment , @  Color Int int color ) { fragments . add ( fragment ) ; add Background Color ( color ) ; pager Adapter . notify Data Set Changed ( ) ; }
public static  Float Buffer create Float Buffer ( float [ ] coords ) {  Byte Buffer bb =  Byte Buffer . allocate Direct ( coords . length *  SIZEOF_ FLOAT ) ; bb . order (  Byte Order . native Order ( ) ) ;  Float Buffer fb = bb . as Float Buffer ( ) ; fb . put ( coords ) ; fb . position ( _ NUM ) ; return fb ; }
protected void subscribe ( ) throws  IOException { if ( sample Client Sub == null ) { try { sample Client Sub = new  Sample Async Wait ( url , client Id Sub , clean Session , quiet Mode , user Name , password ) ; } catch (  Mqtt Exception e ) { e . print Stack Trace ( ) ; } } if ( sample Client Sub != null ) {  String topic = _ STR ; int qos = _ NUM ; try { sample Client Sub . subscribe ( topic , qos ) ; } catch (  Throwable e ) { e . print Stack Trace ( ) ; } } }
private void wm Sub Band (  Image img , double [ ] wm , int n , double a , double threshold ) { for ( int i = _ NUM ; i < img . get Width ( ) * img . get Height ( ) ; i ++ ) { if (  Math . abs ( img . get Data ( ) [ i ] ) > threshold ) { img . get Data ( ) [ i ] += ( a *  Math . abs ( img . get Data ( ) [ i ] ) * wm [ i % n ] ) ; } } }
private  File find Absolute Path (  File file To Find ) {  File found File = file To Find ; try {  String cluster Home =  Cluster Configuration . get Cluster Home ( ) ; if ( file To Find . get Path ( ) == file To Find . get Name ( ) ) {  File candidate File = new  File ( cluster Home +  File . separator + _ STR +  File . separator + file To Find . get Name ( ) ) ; if ( candidate File . is File ( ) ) { found File = candidate File ; logger . debug (  Message Format . format ( _ STR , found File . get Absolute File ( ) ) ) ; } else throw new  Configuration Exception (  Message Format . format ( _ STR , candidate File . get Absolute Path ( ) ) ) ; } } catch (  Configuration Exception e ) { logger . debug (  Message Format . format ( _ STR , file To Find . get Name ( ) , e . get Message ( ) ) ) ; return file To Find ; } return found File ; }
protected boolean remove (  Linked List files ) { if ( files == null ) {  Debug . error ( _ STR ) ; return _ BOOL ; }  Iterator it = files . iterator ( ) ; while ( it . has Next ( ) ) {  File file = (  File ) it . next ( ) ;  Debug . output ( _ STR + file . get Absolute Path ( ) ) ; file . delete ( ) ; } return _ BOOL ; }
private void start File Based Merge ( ) throws  Carbon Sort Key And Group By Exception { try { data Sorter And Writer Executor Service . shutdown ( ) ; data Sorter And Writer Executor Service . await Termination ( _ NUM ,  Time Unit .  DAYS ) ; } catch (  Interrupted Exception e ) { throw new  Carbon Sort Key And Group By Exception ( _ STR , e ) ; } }
public  Corrupt Index Exception (  String message ,  String resource Description ,  Throwable cause ) { super (  Objects . to String ( message ) + _ STR + resource Description + _ STR , cause ) ; this . resource Description = resource Description ; this . message = message ; }
void deregister Spring (  Spring spring ) { if ( spring == null ) { throw new  Illegal Argument Exception ( _ STR ) ; } m Active Springs . remove ( spring ) ; m Spring Registry . remove ( spring . get Id ( ) ) ; }
public static int check Field ( int lua State ,  Object obj ,  String field Name ) throws  Lua Exception {  Lua State  L =  Lua State Factory . get Existing State ( lua State ) ; synchronized (  L ) {  Field field = null ;  Class obj Class ; if ( obj instanceof  Class ) { obj Class = (  Class ) obj ; } else { obj Class = obj . get Class ( ) ; } try { field = obj Class . get Field ( field Name ) ; } catch (  Exception e ) { return _ NUM ; } if ( field == null ) { return _ NUM ; }  Object ret = null ; try { ret = field . get ( obj ) ; } catch (  Exception e1 ) { return _ NUM ; } if ( obj == null ) { return _ NUM ; }  L . push Object Value ( ret ) ; return _ NUM ; } }
protected static  Pair <  String ,  String > asr Immediate ( final long offset , final  ITranslation Environment environment , final  List <  Reil Instruction > instructions , final  String register Node Value , final  String immediate Node Value ) { long base Offset = offset ; final  String shifter Operand = environment . get Next Variable String ( ) ; final  String shifter Carry Out = environment . get Next Variable String ( ) ; if ( immediate Node Value . equals ( _ STR ) ) { final  String tmp Var1 = environment . get Next Variable String ( ) ; instructions . add (  Reil Helpers . create Bsh ( base Offset ++ , d Word Size , register Node Value , word Size , thirty One Set , byte Size , tmp Var1 ) ) ; instructions . add (  Reil Helpers . create And ( base Offset ++ , byte Size , tmp Var1 , byte Size , one Set , byte Size , shifter Carry Out ) ) ; instructions . add (  Reil Helpers . create Sub ( base Offset ++ , byte Size , shifter Carry Out , byte Size ,  String . value Of ( _ NUM ) , d Word Size , shifter Operand ) ) ; return new  Pair <  String ,  String > ( shifter Operand , shifter Carry Out ) ; } else { final  String tmp Var1 = environment . get Next Variable String ( ) ; final  String tmp Var2 = environment . get Next Variable String ( ) ; final  String tmp Var3 = environment . get Next Variable String ( ) ; final  String tmp Var4 = environment . get Next Variable String ( ) ; final  String tmp Var5 = environment . get Next Variable String ( ) ; instructions . add (  Reil Helpers . create Add ( base Offset ++ , d Word Size , register Node Value , d Word Size , bit Mask Highest Bit Set , q Word Size , tmp Var1 ) ) ; instructions . add (  Reil Helpers . create Bsh ( base Offset ++ , q Word Size , tmp Var1 , word Size , _ STR + immediate Node Value , d Word Size , tmp Var2 ) ) ; instructions . add (  Reil Helpers . create Bsh ( base Offset ++ , d Word Size , bit Mask Highest Bit Set , word Size , _ STR + immediate Node Value , d Word Size , tmp Var3 ) ) ; instructions . add (  Reil Helpers . create Sub ( base Offset ++ , d Word Size , tmp Var2 , d Word Size , tmp Var3 , q Word Size , tmp Var4 ) ) ; instructions . add (  Reil Helpers . create And ( base Offset ++ , q Word Size , tmp Var4 , d Word Size , bit Mask All Bits Set , d Word Size , shifter Operand ) ) ; instructions . add (  Reil Helpers . create Bsh ( base Offset ++ , d Word Size , register Node Value , d Word Size ,  String . value Of ( - (  Integer . decode ( immediate Node Value ) - _ NUM ) ) , word Size , tmp Var5 ) ) ; instructions . add (  Reil Helpers . create And ( base Offset ++ , word Size , tmp Var5 , byte Size , one Set , byte Size , shifter Carry Out ) ) ; return new  Pair <  String ,  String > ( shifter Operand , shifter Carry Out ) ; } }
public static  Plain Text plain ( byte text ) { return plain (  Integer . to String ( text ) ) ; }
private static void adjust To Interval Lower Bound (  Calendar now ,  Schedule Interval interval , int multiple ) { now . set (  Calendar .  SECOND , _ NUM ) ; now . set (  Calendar .  MILLISECOND , _ NUM ) ; switch ( interval ) { case  MINUTE : now . set (  Calendar .  MINUTE , align Down ( now . get (  Calendar .  MINUTE ) , multiple , _ NUM ) ) ; break ; case  HOUR : now . set (  Calendar .  HOUR_ OF_ DAY , align Down ( now . get (  Calendar .  HOUR_ OF_ DAY ) , multiple , _ NUM ) ) ; now . set (  Calendar .  MINUTE , _ NUM ) ; break ; case  DAY : now . set (  Calendar .  DAY_ OF_ MONTH , align Down ( now . get (  Calendar .  DAY_ OF_ MONTH ) , multiple , _ NUM ) ) ; now . set (  Calendar .  HOUR_ OF_ DAY , _ NUM ) ; now . set (  Calendar .  MINUTE , _ NUM ) ; break ; case  WEEK : now . set (  Calendar .  WEEK_ OF_ YEAR , align Down ( now . get (  Calendar .  WEEK_ OF_ YEAR ) , multiple , _ NUM ) ) ; now . set (  Calendar .  DAY_ OF_ WEEK ,  Calendar .  SUNDAY ) ; now . set (  Calendar .  HOUR_ OF_ DAY , _ NUM ) ; now . set (  Calendar .  MINUTE , _ NUM ) ; break ; case  MONTH : now . set (  Calendar .  MONTH , align Down ( now . get (  Calendar .  MONTH ) , multiple ,  Calendar .  JANUARY ) ) ; now . set (  Calendar .  DAY_ OF_ MONTH , _ NUM ) ; now . set (  Calendar .  HOUR_ OF_ DAY , _ NUM ) ; now . set (  Calendar .  MINUTE , _ NUM ) ; break ; case  YEAR : now . set (  Calendar .  YEAR , align Down ( now . get (  Calendar .  YEAR ) , multiple , _ NUM ) ) ; now . set (  Calendar .  MONTH ,  Calendar .  JANUARY ) ; now . set (  Calendar .  DAY_ OF_ MONTH , _ NUM ) ; now . set (  Calendar .  HOUR_ OF_ DAY , _ NUM ) ; now . set (  Calendar .  MINUTE , _ NUM ) ; break ; default : throw new  Illegal Argument Exception (  String . format ( _ STR , interval . to String ( ) ) ) ; } }
public void start ( ) { managed Ports . add ( create Port ( ) ) ; fix Names ( ) ; ports . add Observer ( observer , _ BOOL ) ; }
protected void sprint ( short short Field ) { sprint (  String . value Of ( short Field ) ) ; }
public byte [ ] convert Nv21to Jpeg ( byte [ ] data_copy , int w , int h , int [ ] strides ) {  Log . e (  TAG , _ STR ) ;  Yuv Image yuv Image = new  Yuv Image ( data_copy ,  Image Format .  NV21 , w , h , strides ) ;  Byte Array Output Stream post View Bytes = new  Byte Array Output Stream ( ) ; yuv Image . compress To Jpeg ( new  Rect ( _ NUM , _ NUM , w , h ) , _ NUM , post View Bytes ) ; try { post View Bytes . flush ( ) ; } catch (  IOException e ) { e . print Stack Trace ( ) ; }  Log . e (  TAG , _ STR ) ; return post View Bytes . to Byte Array ( ) ; }
public static  String value Of ( double value ) { return  Double . to String ( value ) ; }
private  Storage Port choose Candidate (  Set <  Storage Port > candidates ,  Map <  Storage Port ,  Long > usage Map ) {  Storage Port chosen Port = null ; long min Usage =  Long .  MAX_ VALUE ; for (  Storage Port sp : candidates ) {  Long usage = usage Map . get ( sp ) ; _log . debug (  String . format ( _ STR , sp . get Port Name ( ) , usage ) ) ; if ( usage < min Usage ) { min Usage = usage ; chosen Port = sp ; } } return chosen Port ; }
public static void store To Binary File (  String file Name ,  List <  External Event > events ) throws  IOException { if ( ! file Name . ends With (  BINARY_ EXT ) ) { file Name += _ STR ; }  Object Output Stream out ;  File Output Stream fos = new  File Output Stream ( file Name ) ; out = new  Object Output Stream ( fos ) ; out . write Object ( new  Integer ( events . size ( ) ) ) ; for (  External Event ee : events ) { out . write Object ( ee ) ; } out . close ( ) ; }
public  String hidden To Encoded String ( ) {  String Builder buf = new  String Builder ( ) ; for (  Iterator <  String > i = hidden Bug Category Set . iterator ( ) ; i . has Next ( ) ; ) { buf . append ( i . next ( ) ) ; if ( i . has Next ( ) ) { buf . append (  LISTITEM_ DELIMITER ) ; } } buf . append (  FIELD_ DELIMITER ) ; return buf . to String ( ) ; }
public void update Combo Box (  JCombo Box <  Schedule > box ) { box . remove All Items ( ) ; box . add Item ( null ) ; for (  Schedule schedule : get Schedules By Name List ( ) ) { box . add Item ( schedule ) ; } }
public void disconnect ( final  IProject [ ] projects ) { disconnect ( projects , _ BOOL ) ; }
public final  String translate ( final  Char Sequence input ) { if ( input == null ) { return null ; } try { final  String Writer writer = new  String Writer ( input . length ( ) * _ NUM ) ; translate ( input , writer ) ; return writer . to String ( ) ; } catch ( final  IOException ioe ) { throw new  Runtime Exception ( ioe ) ; } }
public static synchronized void add Resource (  Recoverable Resource resource ) throws  Illegal State Exception { purge Resources ( ) ; if ( resources_ . contains Key ( resource . get Name ( ) ) ) throw new  Illegal State Exception ( _ STR + _ STR + resource . get Name ( ) ) ; resource . set Recovery Service ( recovery Service_ ) ; resources_ . put ( resource . get Name ( ) , resource ) ; resource List_ . add ( resource ) ; }
public boolean matches (  Function function ,  String id ) { return m Function == function && m ID != null && id != null && id . matches ( m ID . replace ( _ STR , _ STR ) ) ; }
public static void save (  Key Store key Store ,  File key Store File ,  Password password ) throws  Crypto Exception ,  IOException {  Key Store Type key Store Type =  Key Store Type . resolve Jce ( key Store . get Type ( ) ) ; if ( ! key Store Type . is File Based ( ) ) { throw new  Crypto Exception (  Message Format . format ( res . get String ( _ STR ) , key Store Type . jce ( ) ) ) ; }  File Output Stream fos = null ; fos = new  File Output Stream ( key Store File ) ; try { key Store . store ( fos , password . to Char Array ( ) ) ; } catch (  IOException ex ) { throw new  Crypto Exception ( res . get String ( _ STR ) , ex ) ; } catch (  Key Store Exception ex ) { throw new  Crypto Exception ( res . get String ( _ STR ) , ex ) ; } catch (  Certificate Exception ex ) { throw new  Crypto Exception ( res . get String ( _ STR ) , ex ) ; } catch (  No Such Algorithm Exception ex ) { throw new  Crypto Exception ( res . get String ( _ STR ) , ex ) ; } finally {  IOUtils . close Quietly ( fos ) ; } }
public long add And Get (  T obj , long delta ) { for ( ; ; ) { long current = get ( obj ) ; long next = current + delta ; if ( compare And Set ( obj , current , next ) ) return next ; } }
private static int [ ] [ ] successors ( final  List <  Vector3 D > vertices , final  List < int [ ] > facets , final int [ ] [ ] references ) { final int [ ] [ ] successors = new int [ vertices . size ( ) ] [ references [ _ NUM ] . length ] ; for ( final int [ ] s : successors ) {  Arrays . fill ( s , - _ NUM ) ; } for ( int v = _ NUM ; v < vertices . size ( ) ; ++ v ) { for ( int k = _ NUM ; k < successors [ v ] . length && references [ v ] [ k ] >= _ NUM ; ++ k ) { final int [ ] facet = facets . get ( references [ v ] [ k ] ) ; int i = _ NUM ; while ( i < facet . length && facet [ i ] != v ) { ++ i ; } successors [ v ] [ k ] = facet [ ( i + _ NUM ) % facet . length ] ; for ( int l = _ NUM ; l < k ; ++ l ) { if ( successors [ v ] [ l ] == successors [ v ] [ k ] ) { final  Vector3 D start = vertices . get ( v ) ; final  Vector3 D end = vertices . get ( successors [ v ] [ k ] ) ; throw new  Math Illegal Argument Exception (  Localized Geometry Formats .  FACET_ ORIENTATION_ MISMATCH , start . get X ( ) , start . get Y ( ) , start . get Z ( ) , end . get X ( ) , end . get Y ( ) , end . get Z ( ) ) ; } } } } return successors ; }
public static  Properties read Properties (  String name ) {  Properties props = new  Properties ( ) ; if ( global Loader != null ) {  Input Stream is = null ; try {  String service File = _ STR + name . to Lower Case ( ) + _ STR ;  Enumeration <  URL > locs = global Loader . get Resources ( service File ) ; while ( locs . has More Elements ( ) ) {  URL loc = locs . next Element ( ) ; if ( loc != null ) { try { is = loc . open Stream ( ) ;  Properties p = new  Properties ( ) ; p . load ( is ) ; props . put All ( p ) ; } finally { if ( is != null ) { is . close ( ) ; } } } } } catch (  IOException ex ) {  LOG . log (  Level .  SEVERE , null , ex ) ; } finally { try { if ( is != null ) { is . close ( ) ; } } catch (  IOException ex ) {  LOG . log (  Level .  SEVERE , null , ex ) ; } } } return props ; }
@  Override public void put ( double val , double weight ) { final double nn = weight + this . n ; final double delta = val - this . m1 ; final double otherm2 = val * val ; final double otherm3 = otherm2 * val ; final double otherm4 = otherm3 * val ; final double delta_nn = delta / nn ; final double delta_nn2 = delta_nn * delta_nn ; final double delta_nn3 = delta_nn2 * delta_nn ; final double na2 = this . n * this . n ; final double nb2 = weight * weight ; final double ntn = this . n * weight ; this . m4 += otherm4 + delta * delta_nn3 * ntn * ( na2 - ntn + nb2 ) + _ NUM * ( na2 * otherm2 + nb2 * this . m2 ) * delta_nn2 + _ NUM * ( this . n * otherm3 - weight * this . m3 ) * delta_nn ; this . m3 += otherm3 + delta * delta_nn2 * ntn * ( this . n - weight ) + _ NUM * ( this . n * otherm2 - weight * this . m2 ) * delta_nn ; this . m2 += otherm2 + delta * delta_nn * this . n * weight ; this . m1 += weight * delta_nn ; this . n = nn ; min =  Math . min ( min , val ) ; max =  Math . max ( max , val ) ; }
protected void select Value ( int value ) { if ( value > _ NUM ) { log . error ( _ STR + value ) ; } for ( int i = _ NUM ; i < _value Array . length ; i ++ ) { if ( _value Array [ i ] == value ) { _value . set Selected Index ( i ) ; return ; } } log . debug ( _ STR + value + _ STR + _value . get Item Count ( ) + _ STR + label ( ) ) ; _value . add Item ( _ STR + value ) ; int [ ] old Array = _value Array ; _value Array = new int [ old Array . length + _ NUM ] ; for ( int i = _ NUM ; i < old Array . length ; i ++ ) { _value Array [ i ] = old Array [ i ] ; } _value Array [ old Array . length ] = value ; _value . set Selected Item ( _ STR + value ) ; }
public static  String back Quote Chars (  String string , char [ ] find ,  String [ ] replace ) { int index ;  String Builder new Str ; int i ; if ( string == null ) return string ; for ( i = _ NUM ; i < find . length ; i ++ ) { if ( string . index Of ( find [ i ] ) != - _ NUM ) { new Str = new  String Builder ( ) ; while ( ( index = string . index Of ( find [ i ] ) ) != - _ NUM ) { if ( index > _ NUM ) new Str . append ( string . substring ( _ NUM , index ) ) ; new Str . append ( replace [ i ] ) ; if ( ( index + _ NUM ) < string . length ( ) ) string = string . substring ( index + _ NUM ) ; else string = _ STR ; } new Str . append ( string ) ; string = new Str . to String ( ) ; } } return string ; }
public static  String format Map Old (  String name ,  Map <  String ,  String > props ,  String header , boolean was Modified ) {  String indent = _ STR ;  String Builder builder = new  String Builder ( ) ; builder . append ( header ) ; builder . append (  String . format ( _ STR , name , modified Sign ( was Modified ) ) ) ; builder . append ( _ STR ) ; for (  String key : props . key Set ( ) ) { builder . append (  String . format ( _ STR , indent , key , props . get ( key ) ) ) ; } builder . append (  String . format ( _ STR ) ) ; return builder . to String ( ) ; }
static double mypdf ( double value , double shape , double scale ) { return  Math . exp ( ( shape - _ NUM ) *  Math . log ( value ) - value / scale -  Gamma Function . log Gamma ( shape ) - shape *  Math . log ( scale ) ) ; }
public static  Vector3 ceil (  Vector3 o ) { return new  Vector3 (  Math . ceil ( o . x ) ,  Math . ceil ( o . y ) ,  Math . ceil ( o . z ) ) ; }
public  Datagram Packet multicast Receive ( ) throws  IOException { byte [ ] buf = new byte [ _ NUM ] ;  Datagram Packet dp = new  Datagram Packet ( buf , buf . length ) ; multicast Socket . receive ( dp ) ; return dp ; }
@  Override protected void flush ( ) throws  IOException { zip Output Stream . flush ( ) ; zip Output Stream . finish ( ) ; finished = _ BOOL ; super . flush ( ) ; }
private static void do Sort ( float [ ] a , int left , int right , float [ ] work , int work Base , int work Len ) { if ( right - left <  QUICKSORT_ THRESHOLD ) { sort ( a , left , right , _ BOOL ) ; return ; } int [ ] run = new int [  MAX_ RUN_ COUNT + _ NUM ] ; int count = _ NUM ; run [ _ NUM ] = left ; for ( int k = left ; k < right ; run [ count ] = k ) { if ( a [ k ] < a [ k + _ NUM ] ) { while ( ++ k <= right && a [ k - _ NUM ] <= a [ k ] ) ; } else if ( a [ k ] > a [ k + _ NUM ] ) { while ( ++ k <= right && a [ k - _ NUM ] >= a [ k ] ) ; for ( int lo = run [ count ] - _ NUM , hi = k ; ++ lo < -- hi ; ) { float t = a [ lo ] ; a [ lo ] = a [ hi ] ; a [ hi ] = t ; } } else { for ( int m =  MAX_ RUN_ LENGTH ; ++ k <= right && a [ k - _ NUM ] == a [ k ] ; ) { if ( -- m == _ NUM ) { sort ( a , left , right , _ BOOL ) ; return ; } } } if ( ++ count ==  MAX_ RUN_ COUNT ) { sort ( a , left , right , _ BOOL ) ; return ; } } if ( run [ count ] == right ++ ) { run [ ++ count ] = right ; } else if ( count == _ NUM ) { return ; } byte odd = _ NUM ; for ( int n = _ NUM ; ( n <<= _ NUM ) < count ; odd ^= _ NUM ) ; float [ ] b ; int ao , bo ; int blen = right - left ; if ( work == null || work Len < blen || work Base + blen > work . length ) { work = new float [ blen ] ; work Base = _ NUM ; } if ( odd == _ NUM ) {  System . arraycopy ( a , left , work , work Base , blen ) ; b = a ; bo = _ NUM ; a = work ; ao = work Base - left ; } else { b = work ; ao = _ NUM ; bo = work Base - left ; } for ( int last ; count > _ NUM ; count = last ) { for ( int k = ( last = _ NUM ) + _ NUM ; k <= count ; k += _ NUM ) { int hi = run [ k ] , mi = run [ k - _ NUM ] ; for ( int i = run [ k - _ NUM ] , p = i , q = mi ; i < hi ; ++ i ) { if ( q >= hi || p < mi && a [ p + ao ] <= a [ q + ao ] ) { b [ i + bo ] = a [ p ++ + ao ] ; } else { b [ i + bo ] = a [ q ++ + ao ] ; } } run [ ++ last ] = hi ; } if ( ( count & _ NUM ) != _ NUM ) { for ( int i = right , lo = run [ count - _ NUM ] ; -- i >= lo ; b [ i + bo ] = a [ i + ao ] ) ; run [ ++ last ] = right ; } float [ ] t = a ; a = b ; b = t ; int o = ao ; ao = bo ; bo = o ; } }
public  Flux Map Fuseable (  Publisher < ? extends  T > source ,  Function < ? super  T , ? extends  R > mapper ) { super ( source ) ; this . mapper =  Objects . require Non Null ( mapper , _ STR ) ; }
public static boolean is Likely Channel (  String word ) { boolean result = _ BOOL ; if ( word != null ) {  Raptor String Tokenizer tok = new  Raptor String Tokenizer ( word ,  CHANNEL_ STRIP_ CHARS , _ BOOL ) ; if ( tok . has More Tokens ( ) ) {  String current = tok . next Token ( ) ; try { int channel =  Integer . parse Int ( current ) ; return channel >= _ NUM && channel <= _ NUM ; } catch (  Number Format Exception nfe ) { if ( tok . has More Tokens ( ) ) { try { current = tok . next Token ( ) ; int channel =  Integer . parse Int ( current ) ; return channel >= _ NUM && channel <= _ NUM ; } catch (  Number Format Exception nfe2 ) { if ( tok . has More Tokens ( ) ) { try { current = tok . next Token ( ) ; int channel =  Integer . parse Int ( current ) ; return channel >= _ NUM && channel <= _ NUM ; } catch (  Number Format Exception nfe3 ) { if ( tok . has More Tokens ( ) ) { try { current = tok . next Token ( ) ; int channel =  Integer . parse Int ( current ) ; return channel >= _ NUM && channel <= _ NUM ; } catch (  Number Format Exception nfe4 ) { } } } } } } } } } return result ; }
protected void close Channel (  Socket Channel channel ) { if ( channel == null ) return ;  Socket socket = channel . socket ( ) ; try { socket . shutdown Input ( ) ; socket . shutdown Output ( ) ; socket . close ( ) ; } catch (  IOException ex ) { if ( _logger . is Loggable (  Level .  FINE ) ) { _logger . log (  Level .  FINE , _ STR , ex ) ; } } finally { try { channel . close ( ) ; } catch (  IOException ex ) { if ( _logger . is Loggable (  Level .  FINE ) ) { _logger . log (  Level .  FINE , _ STR , ex ) ; } } } }
public  String sprintf ( ) {  Enumeration e = v Fmt . elements ( ) ;  Conversion Specification cs = null ; char c = _ NUM ;  String Builder sb = new  String Builder ( ) ; while ( e . has More Elements ( ) ) { cs = (  Conversion Specification ) e . next Element ( ) ; c = cs . get Conversion Character ( ) ; if ( c == _ STR ) sb . append ( cs . get Literal ( ) ) ; else if ( c == _ STR ) sb . append ( _ STR ) ; } return sb . to String ( ) ; }
private static  Table Info create Table Info (  String table Name ,  Integer page Number , int flags ,  Short type ,  String linked Db Name ,  String linked Table Name ) { if (  TYPE_ LINKED_ TABLE . equals ( type ) ) { return new  Linked Table Info ( page Number , table Name , flags , linked Db Name , linked Table Name ) ; } return new  Table Info ( page Number , table Name , flags ) ; }
protected void update Radio Links ( ) { m_ Set Test But . set Enabled ( m_ Test Split But . is Selected ( ) ) ; if ( ( m_ Set Test Frame != null ) && ( ! m_ Test Split But . is Selected ( ) ) ) { m_ Set Test Frame . set Visible ( _ BOOL ) ; } m_ CVText . set Enabled ( m_ CVBut . is Selected ( ) ) ; m_ CVLab . set Enabled ( m_ CVBut . is Selected ( ) ) ; m_ Percent Text . set Enabled ( m_ Percent But . is Selected ( ) ) ; m_ Percent Lab . set Enabled ( m_ Percent But . is Selected ( ) ) ; }
public  String format String ( final  String str To Format ) { if ( str To Format != null ) { if ( str To Format . equals Ignore Case ( _ STR ) ) return _ STR ; final  String valn1 = str To Format . replace All ( _ STR , _ STR ) ; final  String formt Str = valn1 . replace All ( _ STR , _ STR ) ; return formt Str . replace All ( _ STR , _ STR ) ; } else return _ STR ; }
public static  String convert String To Html (  String s ) { if ( s == null ) { return null ; } if ( s . length ( ) == _ NUM ) { return s ; }  String Builder buff = new  String Builder ( ) ; for ( int i = _ NUM ; i < s . length ( ) ; i ++ ) { char ch = s . char At ( i ) ;  String token =  CODE_ MAP . get ( ch ) ; if ( token == null ) { if ( ch < _ NUM ) { buff . append ( ch ) ; } else { buff . append ( _ STR ) ; buff . append ( _ STR ) ; buff . append ( ( int ) ch ) ; buff . append ( _ STR ) ; } } else { buff . append ( _ STR ) ; buff . append ( token ) ; buff . append ( _ STR ) ; } } return buff . to String ( ) ; }
public double evaluation For Single Instance ( double [ ] dist ,  Instance instance , boolean store Predictions ) throws  Exception { double pred ; if ( m_ Class Is Nominal ) { pred =  Utils . max Index ( dist ) ; if ( dist [ ( int ) pred ] <= _ NUM ) { pred =  Utils . missing Value ( ) ; } update Stats For Classifier ( dist , instance ) ; if ( store Predictions && ! m_ Discard Predictions ) { if ( m_ Predictions == null ) { m_ Predictions = new  Array List <  Prediction > ( ) ; } m_ Predictions . add ( new  Nominal Prediction ( instance . class Value ( ) , dist , instance . weight ( ) ) ) ; } } else { pred = dist [ _ NUM ] ; update Stats For Predictor ( pred , instance ) ; if ( store Predictions && ! m_ Discard Predictions ) { if ( m_ Predictions == null ) { m_ Predictions = new  Array List <  Prediction > ( ) ; } m_ Predictions . add ( new  Numeric Prediction ( instance . class Value ( ) , pred , instance . weight ( ) ) ) ; } } return pred ; }
public  File Listener (  Printer printer ,  File input File ,  Construct Lengths construct Lengths ,  Set <  Rules > enabled Rules ) throws  IOException { this . printer = printer ; this . input File = input File ; this . construct Lengths = construct Lengths ; this . reader = new  Line Number Reader (  Files . new Buffered Reader ( input File . to Path ( ) ) ) ; this . enabled Rules = enabled Rules ; }
public  String find Match (  Pattern pattern ,  String text , int group Num ) {  Matcher matcher = pattern . matcher ( text ) ; if ( matcher . find ( ) ) { return matcher . group ( group Num ) ; } else { return null ; } }
protected static  String normalize Url Ending (  String link ) { if ( link . index Of ( _ STR ) > - _ NUM ) link = link . substring ( _ NUM , link . index Of ( _ STR ) ) ; if ( link . ends With ( _ STR ) ) link = link . substring ( _ NUM , link . length ( ) - _ NUM ) ; if ( link . ends With ( _ STR ) ) link = link . substring ( _ NUM , link . length ( ) - _ NUM ) ; return link ; }
@  Override public long skip ( long bytes ) throws  IOException { if ( closed ) { throw new  File Upload Exception (  Item Skipped Exception ) ; } int av = available ( ) ; if ( av == _ NUM ) { av = make Available ( ) ; if ( av == _ NUM ) { return _ NUM ; } } long res =  Math . min ( av , bytes ) ; head += res ; return res ; }
protected void draw Center Text (  Canvas c ) {  String center Text = m Chart . get Center Text ( ) ; if ( m Chart . is Draw Center Text Enabled ( ) && center Text != null ) {  Point F center = m Chart . get Center Circle Box ( ) ;  String [ ] lines = center Text . split ( _ STR ) ; float maxlineheight = _ NUM ; for (  String line : lines ) { float cur Height =  Utils . calc Text Height ( m Center Text Paint , line ) ; if ( cur Height > maxlineheight ) maxlineheight = cur Height ; } float linespacing = maxlineheight * _ NUM ; float totalheight = maxlineheight * lines . length - linespacing * ( lines . length - _ NUM ) ; int cnt = lines . length ; float y = center . y ; for ( int i = _ NUM ; i < lines . length ; i ++ ) {  String line = lines [ lines . length - i - _ NUM ] ; c . draw Text ( line , center . x , y + maxlineheight * cnt - totalheight / _ NUM , m Center Text Paint ) ; cnt -- ; y -= linespacing ; } } }
void clear ( ) ;
protected void ensure Initialized ( ) { if ( ! initialized ) { create Custom View ( ) ; create Filter Toolbar ( ) ; final  JPanel tool Bar Panel ; if (  Application Manager . get Application ( ) != null ) { final  Action Toolbar pr Actions Toolbar = create Toolbar ( create Actions Group ( ) ) ; final  Action Toolbar feedback Actions Toolbar = create Toolbar ( create Feedback Group ( ) ) ; final  Action Toolbar options Actions Toolbar = create Toolbar ( create Options Group ( ) ) ; final  Flow Layout flow Layout = new  Flow Layout (  Flow Layout .  LEFT , _ NUM ,  JBUI . scale ( _ NUM ) ) ; final  JPanel tool Bar Panel Left = new  JPanel ( flow Layout ) ; tool Bar Panel Left . add ( pr Actions Toolbar . get Component ( ) ) ; tool Bar Panel Left . add ( search Filter ) ; add Custom Tools ( tool Bar Panel Left ) ; final  Flow Layout flow Layout2 = new  Flow Layout (  Flow Layout .  LEFT , _ NUM ,  JBUI . scale ( _ NUM ) ) ; final  JPanel tool Bar Panel Middle = new  JPanel ( flow Layout2 ) ; tool Bar Panel Middle . add ( options Actions Toolbar . get Component ( ) ) ;  Swing Helper . set Margin ( tool Bar Panel Middle , new  Insets (  JBUI . scale ( _ NUM ) ,  JBUI . scale ( _ NUM ) , _ NUM , _ NUM ) ) ; tool Bar Panel = new  JPanel ( new  Border Layout ( ) ) ; tool Bar Panel . add ( tool Bar Panel Left ,  Border Layout .  LINE_ START ) ; tool Bar Panel . add ( tool Bar Panel Middle ,  Border Layout .  CENTER ) ; tool Bar Panel . add ( feedback Actions Toolbar . get Component ( ) ,  Border Layout .  LINE_ END ) ; } else { tool Bar Panel = new  JPanel ( ) ; } final  JPanel status Panel = new  JPanel ( new  Flow Layout (  Flow Layout .  LEFT ) ) ; status Label = new  JLabel ( ) ; status Link = new  Hyperlink ( ) ; status Link . set Action Command (  CMD_ STATUS_ LINK ) ; status Panel . add ( status Label ) ; status Panel . add ( status Link ) ; tab Panel = new  JPanel ( new  Border Layout ( ) ) ; tab Panel . add ( tool Bar Panel ,  Border Layout .  PAGE_ START ) ; tab Panel . add ( scroll Panel ,  Border Layout .  CENTER ) ; tab Panel . add ( status Panel ,  Border Layout .  PAGE_ END ) ; this . initialized = _ BOOL ; } }
private void capacity ( int min Cap ) { counters . ensure Capacity ( min Cap ) ; while ( counters . size ( ) < min Cap ) counters . add ( _ NUM ) ; }
public void increment ( int position , double weight ) { left Label Weights [ position ] += weight ; right Label Weights [ position ] -= weight ; left Weight += weight ; right Weight -= weight ; }
public static  String [ ] split File Name (  String file Name ) { int pos = file Name . last Index Of ( _ STR ) ; if ( pos == - _ NUM ) { return new  String [ ] { file Name } ; } return new  String [ ] { file Name . substring ( _ NUM , pos ) , file Name . substring ( pos + _ NUM ) } ; }
public void delete (  String name ) throws  IOException { if ( name . equals Ignore Case (  PERMITTED_ SUBTREES ) ) { permitted = null ; } else if ( name . equals Ignore Case (  EXCLUDED_ SUBTREES ) ) { excluded = null ; } else { throw new  IOException ( _ STR + _ STR ) ; } encode This ( ) ; }
public static  Data Frame normalize (  Data Frame data Frame ) { return normalize ( data Frame , _ NUM , _ NUM ,  Collections . <  String > empty List ( ) ) ; }
private static boolean is Excluded (  Spatial s ,  Spatial exclude ) { if ( s . equals ( exclude ) ) { return _ BOOL ; } if ( s . get Parent ( ) != null ) { return is Excluded ( s . get Parent ( ) , exclude ) ; } return _ BOOL ; }
private void add Block Listeners (  Tracker tracker ) {  List <  OBlock > range = tracker . get Range ( ) ; if ( log . is Debug Enabled ( ) ) { log . debug ( _ STR + tracker . get Train Name ( ) + _ STR + range . size ( ) + _ STR ) ; }  Iterator <  OBlock > iter = range . iterator ( ) ; while ( iter . has Next ( ) ) { add Block Listener ( iter . next ( ) , tracker ) ; } }
public static  String add Luhn Digit (  String number ) { char [ ] digits = { _ STR , _ STR , _ STR , _ STR , _ STR , _ STR , _ STR , _ STR , _ STR , _ STR } ; int c = number . length ( ) ;  String Buffer try Number = new  String Buffer ( number + digits [ _ NUM ] ) ; int i ; for ( i = _ NUM ; i < _ NUM ; i ++ ) { try Number . set Char At ( c , digits [ i ] ) ; if ( luhn Check ( try Number . to String ( ) ) ) break ; } return try Number . to String ( ) ; }
public static  Bitmap shrink (  Bitmap src , int jpg Compression , long max Size ) { final float factor = _ NUM ;  Byte Array Output Stream stream = new  Byte Array Output Stream ( ) ; src . compress (  Bitmap .  Compress Format .  JPEG , jpg Compression , stream ) ; while ( max Size != - _ NUM && stream . size ( ) > max Size ) { int height = ( int ) ( src . get Height ( ) * factor ) ; int width = ( int ) ( src . get Width ( ) * factor ) ; stream . reset ( ) ; src =  Bitmap . create Scaled Bitmap ( src , width , height , _ BOOL ) ; src . compress (  Bitmap .  Compress Format .  JPEG , _ NUM , stream ) ; } return src ; }
public static  Endpoint Entry lookup (  Endpoint ep ) { synchronized ( endpoint Table ) {  Endpoint Entry entry = endpoint Table . get ( ep ) ; if ( entry == null ) { entry = new  Endpoint Entry ( ep ) ; endpoint Table . put ( ep , entry ) ; if ( gc Latency Request == null ) { gc Latency Request =  GC . request Latency ( gc Interval ) ; } } return entry ; } }
@  Override public synchronized  String to String ( ) { if ( element Count == _ NUM ) { return _ STR ; } int length = element Count - _ NUM ;  String Builder buffer = new  String Builder ( element Count * _ NUM ) ; buffer . append ( _ STR ) ; for ( int i = _ NUM ; i < length ; i ++ ) { if ( element Data [ i ] == this ) { buffer . append ( _ STR ) ; } else { buffer . append ( element Data [ i ] ) ; } buffer . append ( _ STR ) ; } if ( element Data [ length ] == this ) { buffer . append ( _ STR ) ; } else { buffer . append ( element Data [ length ] ) ; } buffer . append ( _ STR ) ; return buffer . to String ( ) ; }
public static byte [ ] encode ( byte [ ] data ) {  Byte Array Output Stream b Out = new  Byte Array Output Stream ( ) ; try { encoder . encode ( data , _ NUM , data . length , b Out ) ; } catch (  Exception e ) { throw new  Encoder Exception ( _ STR + e . get Message ( ) , e ) ; } return b Out . to Byte Array ( ) ; }
protected  Rectangle calculate BBox (  List <  Point > points ) { double min X =  Double .  MAX_ VALUE ; double min Y =  Double .  MAX_ VALUE ; double max X = -  Double .  MAX_ VALUE ; double max Y = -  Double .  MAX_ VALUE ; for (  Point p : points ) { min X =  Math . min ( p . get X ( ) , min X ) ; min Y =  Math . min ( p . get Y ( ) , min Y ) ; max X =  Math . max ( p . get X ( ) , max X ) ; max Y =  Math . max ( p . get Y ( ) , max Y ) ; } return new  Rectangle ( ( float ) min X , ( float ) min Y , ( float ) ( max X - min X ) , ( float ) ( max Y - min Y ) ) ; }
public  MAVLink Message (  MAVLink Schema schema , int msg ID , int system ID , int component ID ) { this . schema = schema ; this . definition = schema . get Message Definition ( msg ID ) ; if ( definition == null ) { throw new  Runtime Exception ( _ STR + msg ID ) ; } this . payload = new byte [ definition . payload Length ] ; this . payload BB =  Byte Buffer . wrap ( payload ) ; payload BB . order ( schema . get Byte Order ( ) ) ; this . system ID = system ID ; this . component ID = component ID ; this . msg ID = msg ID ; }
public static double log10 ( final double x ) { final double hi Prec [ ] = new double [ _ NUM ] ; final double lores = log ( x , hi Prec ) ; if (  Double . is Infinite ( lores ) ) { return lores ; } final double tmp = hi Prec [ _ NUM ] *  HEX_40000000 ; final double lna = hi Prec [ _ NUM ] + tmp - tmp ; final double lnb = hi Prec [ _ NUM ] - lna + hi Prec [ _ NUM ] ; final double rln10a = _ NUM ; final double rln10b = _ NUM ; return rln10b * lnb + rln10b * lna + rln10a * lnb + rln10a * lna ; }
public  Script Builder small Num ( int num ) { return small Num ( chunks . size ( ) , num ) ; }
public static int [ ] sort Values (  Matrix m ) { double [ ] v = new double [ m . get Column Dimension ( ) ] ; int [ ] index = new int [ v . length ] ; for ( int i = _ NUM ; i < v . length ; i ++ ) { v [ i ] = m . get ( i , i ) ; index [ i ] = i ; } for ( int i = _ NUM ; i < v . length ; i ++ ) { for ( int j = i + _ NUM ; j < v . length ; j ++ ) { if (  Math . abs ( v [ i ] ) <  Math . abs ( v [ j ] ) ) { double tmp Value = v [ j ] ; v [ j ] = v [ i ] ; v [ i ] = tmp Value ; int tmp Index = index [ j ] ; index [ j ] = index [ i ] ; index [ i ] = tmp Index ; } } } return index ; }
@  Override public void paint Component (  Graphics g ) { super . paint Component ( g ) ; if ( m_ Background != null ) { g . set Color (  Color .  WHITE ) ; g . clear Rect ( _ NUM , _ NUM , get Width ( ) , get Height ( ) ) ; int width = m_ Background . get Width ( null ) ; int height = m_ Background . get Height ( null ) ; int x = ( get Width ( ) - width ) / _ NUM ; int y = ( get Height ( ) - height ) / _ NUM ; g . draw Image ( m_ Background , x , y , width , height , this ) ; } }
public void add Tele Missile Attack (  Attack Action ea ) { pending Tele Missile Attacks . add Element ( ea ) ; process Game Event ( new  Game New Action Event ( this , ea ) ) ; }
public static  String read String ( final  JSONArray json Array , final int index , final boolean required , final boolean not Null ) throws  JSONException { if ( required ) { return json Array . get String ( index ) ; } if ( not Null && json Array . is Null ( index ) ) { throw new  JSONException (  String . format (  Locale .  US ,  NULL_ VALUE_ FORMAT_ ARRAY , index ) ) ; }  String value = null ; if ( ! json Array . is Null ( index ) ) { value = json Array . get String ( index ) ; } return value ; }
public static  Web Element find Element Clickable After (  Search Context parent ,  By by , int timeout In Seconds ) {  Preconditions . check Not Null ( parent ) ;  Preconditions . check Not Null ( by ) ; try {  Web Element Wait wait = new  Web Element Wait ( parent , timeout In Seconds ) ; return wait . until ( null ) ; } catch (  Timeout Exception e ) { throw new  Timeout Exception (  String . format ( _ STR , by , timeout In Seconds ) , e ) ; } }
public final  Test Subscriber assert Not Complete ( ) {  String prefix = _ STR ; boolean passed = _ BOOL ; if ( done . get Count ( ) != _ NUM ) { prefix = _ STR ; } long c = completions ; if ( c == _ NUM ) { fail ( prefix , _ STR , errors ) ; fail ( _ STR ) ; passed = _ BOOL ; } else if ( c > _ NUM ) { fail ( prefix , _ STR + c , errors ) ; fail ( _ STR ) ; passed = _ BOOL ; } pass ( _ STR , passed ) ; return this ; }
private static boolean url Matches (  String url ,  String template ) { if (  Text Utils . is Empty ( url ) ||  Text Utils . is Empty ( template ) ) { return _ BOOL ; }  String pattern = _ STR + template ; if ( template . char At ( template . length ( ) - _ NUM ) != _ STR ) { pattern += _ STR ; } pattern += _ STR ; return url . matches ( pattern ) ; }
public int add JSON (  JSONObject j ,  Table table ) { if ( ! m Db . below Mem Threshold ( ) ) {  Log . e (  LOGTAG , _ STR ) ; return  DB_ OUT_ OF_ MEMORY_ ERROR ; } final  String table Name = table . get Name ( ) ;  Cursor c = null ; int count =  DB_ UPDATE_ ERROR ; synchronized ( m Db ) { try { final  SQLite Database db = m Db . get Writable Database ( ) ; final  Content Values cv = new  Content Values ( ) ; cv . put (  KEY_ DATA , j . to String ( ) ) ; cv . put (  KEY_ CREATED_ AT ,  System . current Time Millis ( ) ) ; db . insert ( table Name , null , cv ) ; c = db . raw Query ( _ STR + table Name , null ) ; c . move To First ( ) ; count = c . get Int ( _ NUM ) ; } catch ( final  SQLite Exception e ) {  Log . e (  LOGTAG , _ STR + table Name + _ STR , e ) ; if ( c != null ) { c . close ( ) ; c = null ; } init DB ( ) ; } catch ( final  Illegal State Exception e ) {  Log . e (  LOGTAG , _ STR + table Name + _ STR , e ) ; if ( c != null ) { c . close ( ) ; c = null ; } init DB ( ) ; } finally { if ( c != null ) { c . close ( ) ; } m Db . close ( ) ; } } return count ; }
private void populate Sub Domain Hierarchy Lazy (  Space space ,  Dimension Index root ,  Axis axis ,  Array List <  Dimension Index > result ,  IDomain type ) throws  Interrupted Exception ,  Scope Exception {  Object adapter = type . get Adapter (  Domain . class ) ; if ( adapter != null && adapter instanceof  Domain ) {  Domain target = (  Domain ) adapter ; logger . info ( _ STR + target . to String ( ) + _ STR + space . to String ( ) ) ;  Axis source = axis ; try {  Dimension Index self = new  Dimension Index ( null , source ) ; subdomains . add ( self ) ; } catch (  Dimension Store Exception e ) { logger . error ( _ STR + target . to String ( ) + _ STR + space . to String ( ) ) ; } } else { logger . error ( _ STR ) ; if ( ! dimension Index In List ( result , axis ) ) { result . add (  Dimension Index Creation Utils . create Invalid Index ( root , axis , _ STR ) ) ; } } }
public static <  T ,  U extends  Input Stream >  T with Stream (  U stream , @  Closure Params ( value =  First Param . class )  Closure <  T > closure ) throws  IOException { try {  T result = closure . call ( stream ) ;  Input Stream temp = stream ; stream = null ; temp . close ( ) ; return result ; } finally { close With Warning ( stream ) ; } }
public void increment Counts ( double [ ] [ ] [ ] counts ,  List <  Transition State > full Viterbi State Seq ) { for ( int i = _ NUM ; i < full Viterbi State Seq . size ( ) ; ++ i ) {  Transition State curr Ts = full Viterbi State Seq . get ( i ) ;  Transition State Type curr Type = curr Ts . get Type ( ) ; if ( curr Type ==  Transition State Type .  TMPL ) { int language = curr Ts . get Language Index ( ) ; if ( language >= _ NUM ) { int lm Char = curr Ts . get Lm Char Index ( ) ; int glyph = glyph Index ( curr Ts . get Glyph Char ( ) ) ; counts [ language ] [ lm Char ] [ glyph ] += _ NUM ; } } else if ( curr Type ==  Transition State Type .  RMRGN_ HPHN_ INIT ) { int language = curr Ts . get Language Index ( ) ; if ( language >= _ NUM ) {  Glyph Char curr Glyph Char = curr Ts . get Glyph Char ( ) ; if ( curr Glyph Char . template Char Index == space Char Index ) { int glyph = glyph Index ( curr Glyph Char ) ; counts [ language ] [ hyphen Char Index ] [ glyph ] += _ NUM ; } } } } }
public boolean remove Container And Cancel If Necessary (  Image Container container ) { m Containers . remove ( container ) ; if ( m Containers . size ( ) == _ NUM ) { m Request . cancel ( ) ; return _ BOOL ; } return _ BOOL ; }
public  Poly Area (  Zone Name zone Name , int world Id ,  Collection <  Point2 D > points , float z Min , float z Max ) { this ( zone Name , world Id , points . to Array ( new  Point2 D [ points . size ( ) ] ) , z Min , z Max ) ; }
public static  Object serialize And Recover (  Object o ) { try {  Byte Array Output Stream bos = new  Byte Array Output Stream ( ) ;  Object Output Stream so = new  Object Output Stream ( bos ) ; so . write Object ( o ) ;  Byte Array Input Stream bis = new  Byte Array Input Stream ( bos . to Byte Array ( ) ) ;  Object Input Stream si = new  Object Input Stream ( bis ) ; return si . read Object ( ) ; } catch (  IOException ioe ) { return null ; } catch (  Class Not Found Exception cnfe ) { return null ; } }
public  Zip Entry (  String name ) { if ( name == null ) { throw new  Null Pointer Exception ( ) ; } if ( name . length ( ) > _ NUM ) { throw new  Illegal Argument Exception ( _ STR ) ; } this . name = name ; }
public  Result Set execute Query (  String sql ) throws  Database Exception {  Statement stmt = null ; try { stmt = connection . create Statement ( ) ; return stmt . execute Query ( sql ) ; } catch (  SQLException e ) { throw ( new  Database Exception ( e ) ) ; } finally { try { if ( stmt != null ) { stmt . close ( ) ; } } catch (  SQLException e ) { } } }
public void read Dictionary (  String filename ,  String suffix ,  Input Stream res ) throws  IOException {  Buffered Reader in = new  Buffered Reader ( new  Input Stream Reader ( res ) ) ;  String line ; while ( ( line = in . read Line ( ) ) != null ) {  String [ ] terms = splitter . split ( line ) ; if ( terms . length > max Phrase Length ) continue ; if ( terms . length == _ NUM ) continue ;  Gaz Entry ge = gaz . get ( terms [ _ NUM ] ) ; if ( ge == null ) { gaz . put ( terms [ _ NUM ] , new  Gaz Entry ( terms , _ NUM , filename + suffix ) ) ; } else { ge . add Child ( terms , _ NUM , filename + suffix ) ; } } in . close ( ) ; }
private  String aggregate Wildcard (  String target Token ) { int len = _ NUM ; if ( target Token == null || ( len = target Token . length ( ) ) == _ NUM ) { return target Token ; } char [ ] oldchars = target Token . to Char Array ( ) ; char [ ] newchars = new char [ len ] ; int i = _ NUM ; int j = _ NUM ; int k = _ NUM ; boolean found Wildcard = _ BOOL ; while ( i < len ) { if ( target Token . starts With ( one Level Wildcard , i ) ) { if ( ! found Wildcard ) { k = i ; while ( i < k + one Level Wildcard Length ) { newchars [ j ++ ] = oldchars [ i ++ ] ; } found Wildcard = _ BOOL ; } else { i = i + one Level Wildcard Length ; } } else { found Wildcard = _ BOOL ; newchars [ j ++ ] = oldchars [ i ++ ] ; } } return  String . value Of ( newchars , _ NUM , j ) ; }
private void partition Class (  GVCongruence Class partition ) {  Iterator <  Value Graph Vertex > i = partition . iterator ( ) ;  Value Graph Vertex first = i . next ( ) ;  Array List <  GVCongruence Class > new Classes = new  Array List <  GVCongruence Class > ( ) ;  Array List <  Value Graph Vertex > to Remove = new  Array List <  Value Graph Vertex > ( ) ; while ( i . has Next ( ) ) {  Value Graph Vertex v = i . next ( ) ; if ( ! check Congruence ( first , v ) ) { int index = find Congruence Match ( new Classes , v ) ; if ( index > - _ NUM ) {  GVCongruence Class match =  B . get ( index ) ; match . add Vertex ( v ) ; v . set Value Number ( match . get Value Number ( ) ) ; } else {  GVCongruence Class c = create Congruence Class ( v ) ; new Classes . add ( c ) ; c . add Vertex ( v ) ; v . set Value Number ( c . get Value Number ( ) ) ; } to Remove . add ( v ) ; } } for (  Value Graph Vertex v : to Remove ) { partition . remove Vertex ( v ) ; } if ( ( ! new Classes . is Empty ( ) ) && ( partition . size ( ) > _ NUM ) ) { work List . push ( partition ) ; } for (  GVCongruence Class c : new Classes ) { if ( c . size ( ) > _ NUM ) { work List . push ( c ) ; } add Dependent Classes To Worklist ( c ) ; } }
public void add Files (  Collection <  String > files ) { check File Names ( files ) ; for (  String f : files ) { set Files . add ( named For This Segment ( f ) ) ; } }
public static boolean is Windows ( ) {  String os Name =  System . get Property ( _ STR ) ; os Name = os Name . to Lower Case ( ) ; return os Name . index Of ( _ STR ) != - _ NUM ; }
public static boolean is Compatible With Throws Clause (  Throwable ex ,  Class < ? > [ ] declared Exceptions ) { if ( ! is Checked Exception ( ex ) ) return _ BOOL ; if ( declared Exceptions != null ) for (  Class < ? > declared Exception : declared Exceptions ) if ( declared Exception . is Assignable From ( ex . get Class ( ) ) ) return _ BOOL ; return _ BOOL ; }
protected void print ( double v ) throws  IOException { print (  String . value Of ( v ) ) ; }
public  Object2 Double Open Hash Map < int [ ] > support Map ( int support Threshold ) {  List <  Item Set > item Sets = learn ( ) ;  Object2 Double Open Hash Map < int [ ] > support Map = new  Object2 Double Open Hash Map < > ( item Sets . size ( ) ) ; for (  Item Set item Set : item Sets ) { if ( item Set . support >= support Threshold ) { support Map . put ( item Set . items , item Set . support ) ; } } return support Map ; }
public static boolean is All Cap (  String str ) { if ( str . length ( ) <= _ NUM ) { return _ BOOL ; } for ( int i = _ NUM ; i < str . length ( ) ; i ++ ) { if ( !  Character . is Letter ( str . char At ( i ) ) || !  Character . is Upper Case ( str . char At ( i ) ) ) { return _ BOOL ; } } return _ BOOL ; }
protected  N build Tree ( int [ ] msg , int cur , int parent ,  Array List <  N > nodes ) { int c = _ NUM ; for ( int i = _ NUM ; i < msg . length ; i += _ NUM ) { if ( msg [ i ] == cur && msg [ i + _ NUM ] != parent ) { c ++ ; } if ( msg [ i + _ NUM ] == cur && msg [ i ] != parent ) { c ++ ; } }  List <  N > children ; if ( c > _ NUM ) { children = new  Array List < > ( c ) ; } else { children =  Collections . empty List ( ) ; } for ( int i = _ NUM ; i < msg . length ; i += _ NUM ) { if ( msg [ i ] == cur && msg [ i + _ NUM ] != parent ) { c -- ; children . add ( build Tree ( msg , msg [ i + _ NUM ] , cur , nodes ) ) ; } if ( msg [ i + _ NUM ] == cur && msg [ i ] != parent ) { c -- ; children . add ( build Tree ( msg , msg [ i ] , cur , nodes ) ) ; } } assert ( c == _ NUM ) ;  N node = make Node ( cur , children ) ; nodes . set ( cur , node ) ; return node ; }
protected static int to Digit ( char ch , int index ) throws  Decoder Exception { int digit =  Character . digit ( ch , _ NUM ) ; if ( digit == - _ NUM ) { throw new  Decoder Exception ( _ STR + ch + _ STR + index ) ; } return digit ; }
static void load Library With Class Loader (  String lib Name ,  Class Loader loader ) {  Security Manager sc =  System . get Security Manager ( ) ; if ( sc != null ) { sc . check Link ( lib Name ) ; } if ( loader != null ) {  String full Lib Name = loader . find Library ( lib Name ) ; if ( full Lib Name != null ) { load Library ( full Lib Name , loader , null ) ; return ; } }  String path =  System . get Property ( _ STR , _ STR ) ; path +=  System . get Property ( _ STR , _ STR ) ; load Library ( lib Name , loader , path ) ; }
@  Override public  Enumeration <  Option > list Options ( ) {  Vector <  Option > new Vector = new  Vector <  Option > ( ) ; new Vector . add Element ( new  Option ( _ STR + _ STR , _ STR , _ NUM , _ STR ) ) ; new Vector . add Element ( new  Option ( _ STR , _ STR , _ NUM , _ STR ) ) ; new Vector . add All (  Collections . list ( super . list Options ( ) ) ) ; return new Vector . elements ( ) ; }
public static void save To Protected Store (  Private Key private Key ,  Certificate certificate ,  File store Location ,  String alias ,  String private Key Password ,  String key Store Password ,  String key Store Type ) throws  IOException ,  Key Store Exception ,  No Such Provider Exception ,  No Such Algorithm Exception ,  Certificate Exception {  Key Store store = null ; if ( key Store Type . equals ( _ STR ) ) { store =  Key Store . get Instance ( key Store Type ,  Crypto Util . get Security Provider Name (  Key Store . class ) ) ; } else store =  Key Store . get Instance ( key Store Type ) ; store . load ( null , null ) ;  Certificate [ ] chain = new  Certificate [ _ NUM ] ; chain [ _ NUM ] = certificate ; if ( private Key Password != null ) store . set Key Entry ( alias , private Key , private Key Password . to Char Array ( ) , chain ) ; else store . set Key Entry ( alias , private Key , null , chain ) ;  File Output Stream f Out = new  File Output Stream ( store Location ) ; try { store . store ( f Out , key Store Password == null ? null : key Store Password . to Char Array ( ) ) ; } finally { f Out . close ( ) ; } }
public  And Query Builder add (  Query Builder filter Builder ) { filters . add ( filter Builder ) ; return this ; }
void update ( long time , int rows ) { count ++ ; execution Time Min =  Math . min ( time , execution Time Min ) ; execution Time Max =  Math . max ( time , execution Time Max ) ; row Count Min =  Math . min ( rows , row Count Min ) ; row Count Max =  Math . max ( rows , row Count Max ) ; double delta = rows - row Count Mean ; row Count Mean += delta / count ; row Count M2 += delta * ( rows - row Count Mean ) ; delta = time - execution Time Mean ; execution Time Mean += delta / count ; execution Time M2 += delta * ( time - execution Time Mean ) ; execution Time Cumulative += time ; row Count Cumulative += rows ; last Update Time =  System . current Time Millis ( ) ; }
private static  Properties load Properties ( ) {  Properties properties = new  Properties ( ) ;  File file = new  File ( _ STR ) ;  File Input Stream fis = null ; try { if ( file . exists ( ) ) { fis = new  File Input Stream ( file ) ; properties . load ( fis ) ; } } catch (  Exception e ) {  LOGGER . error ( e , e . get Message ( ) ) ; } finally { if ( null != fis ) { try { fis . close ( ) ; } catch (  IOException e ) {  LOGGER . error ( e , e . get Message ( ) ) ; } } } return properties ; }
protected  String escape (  String s ) {  String Buffer result ; int i ; result = new  String Buffer ( ) ; for ( i = _ NUM ; i < s . length ( ) ; i ++ ) { if ( ( s . char At ( i ) == _ STR ) || ( s . char At ( i ) == _ STR ) ) { result . append ( _ STR ) ; } result . append ( s . char At ( i ) ) ; } return result . to String ( ) ; }
private  Set <  Pin Swappable > calculate_swap_pin_infos ( ) {  Tree Set <  Pin Swappable > result = new  Tree Set <  Pin Swappable > ( ) ; if ( target_set == null ) return result ; for (  Brd Item curr_item : target_set ) { if ( ! ( curr_item instanceof  Brd Abit Pin ) ) continue ;  Brd Abit Pin a_pin = (  Brd Abit Pin ) curr_item ;  Collection <  Brd Abit Pin > curr_swapppable_pins = a_pin . get_swappable_pins ( ) ; for (  Brd Abit Pin curr_swappable_pin : curr_swapppable_pins ) { result . add ( new  Pin Swappable ( r_board , curr_swappable_pin ) ) ; } }  Item Selection Filter selection_filter = new  Item Selection Filter (  Item Selection Choice .  PINS ) ;  Collection <  Brd Item > picked_items = r_board . pick_items ( prev_corner , layer_active_no , selection_filter ) ; for (  Brd Item curr_item : picked_items ) { if ( ! ( curr_item instanceof  Brd Abit Pin ) ) continue ;  Brd Abit Pin a_pin = (  Brd Abit Pin ) curr_item ;  Collection <  Brd Abit Pin > curr_swapppable_pins = a_pin . get_swappable_pins ( ) ; for (  Brd Abit Pin curr_swappable_pin : curr_swapppable_pins ) { result . add ( new  Pin Swappable ( r_board , curr_swappable_pin ) ) ; } } return result ; }
public void next Bytes ( byte [ ] bytes ) { final int length = bytes . length ; for ( int i = _ NUM ; i < length ; ) { for ( int rnd = next Int ( ) , n =  Math . min ( length - i ,  INTEGER_ SIZE /  BYTE_ SIZE ) ; n -- > _ NUM ; rnd >>=  BYTE_ SIZE ) { bytes [ i ++ ] = ( byte ) rnd ; } } }
public  Create Index Request aliases (  XContent Builder source ) { return aliases ( source . bytes ( ) ) ; }
private final void add User (  String channel ,  User user ) { channel = channel . to Lower Case ( ) ; synchronized ( _channels ) {  Hashtable <  User ,  User > users = _channels . get ( channel ) ; if ( users == null ) { users = new  Hashtable <  User ,  User > ( ) ; _channels . put ( channel , users ) ; } users . put ( user , user ) ; } }
void after Write (  Runnable task ) { write Buffer . add ( task ) ; drain Status . lazy Set (  REQUIRED ) ; try To Drain Buffers ( ) ; notify Listener ( ) ; }
protected boolean os File Move (  File dest ,  File source ) { if ( source . rename To ( dest ) ) { return _ BOOL ; } if ( source . exists ( ) && source . is File ( ) && source . can Read ( ) && source . can Write ( ) && ! dest . exists ( ) ) { if ( os File Copy ( dest , source ) ) { if ( os Delete File ( source ) ) { return _ BOOL ; } else { os Delete File ( dest ) ; } } } return _ BOOL ; }
public static  String properties Encode (  Properties pp ) {  Byte Array Output Stream bos = new  Byte Array Output Stream ( ) ; try { pp . store ( bos , _ STR ) ; } catch (  IOException e ) { log . log (  Level .  SEVERE , _ STR , e ) ; }  String result = new  String ( bos . to Byte Array ( ) ) ; try { result =  URLEncoder . encode ( result ,  Web Env .  ENCODING ) ; } catch (  Unsupported Encoding Exception e ) { log . log (  Level .  SEVERE , _ STR +  Web Env .  ENCODING , e ) ;  String enc =  System . get Property ( _ STR ) ; try { result =  URLEncoder . encode ( result , enc ) ; log . info ( _ STR + enc ) ; } catch (  Exception ex ) { log . log (  Level .  SEVERE , _ STR , ex ) ; } } return result ; }
public void generate (  Xml Writer w ,  Extension Profile ext Profile ) throws  IOException {  Array List <  Xml Writer .  Attribute > attrs = new  Array List <  Xml Writer .  Attribute > ( ) ; if ( row > _ NUM ) { attrs . add ( new  Xml Writer .  Attribute ( _ STR ,  String . value Of ( row ) ) ) ; } if ( col > _ NUM ) { attrs . add ( new  Xml Writer .  Attribute ( _ STR ,  String . value Of ( col ) ) ) ; } if ( input Value != null ) { attrs . add ( new  Xml Writer .  Attribute ( _ STR , input Value ) ) ; } if ( numeric Value != null ) { attrs . add ( new  Xml Writer .  Attribute ( _ STR , numeric Value . to String ( ) ) ) ; } w . simple Element (  Namespaces . g Spread Ns , _ STR , attrs , value ) ; }
public void test Sorts Same Attributes ( ) throws  Exception {  Xpp Dom dom1 =  Xpp Factory . build Dom ( _ STR ) ;  Xpp Dom dom2 =  Xpp Factory . build Dom ( _ STR ) ; assert Equals ( - _ NUM , comparator . compare ( dom1 , dom2 ) ) ; assert Equals ( _ STR , xpath . get ( ) ) ; assert Equals ( _ NUM , comparator . compare ( dom2 , dom1 ) ) ; assert Equals ( _ STR , xpath . get ( ) ) ; }
private static void delete Directory (  File file ) throws  IOException { if ( file . is Directory ( ) ) {  File [ ] files = file . list Files ( ) ; if ( files != null ) { for ( int i = _ NUM ; i < files . length ; i ++ ) { delete Directory ( files [ i ] ) ; } } } file . delete ( ) ; }
public static boolean is Assignable From (  Class < ? > destination ,  Class < ? > source ) { return destination . is Assignable From ( source ) || is Boxing ( destination , source ) || is Un Boxing ( destination , source ) ; }
private boolean is Date Format String (  String string ) { if ( string . length ( ) < _ NUM ) { return _ BOOL ; } final int str Length = string . length ( ) ; final char start Char = string . char At ( _ NUM ) ; final char end Char = string . char At ( str Length - _ NUM ) ; if ( start Char == _ STR || end Char == _ STR ) { return _ BOOL ; } else if (  Character . is Letter ( start Char ) && string . char At ( _ NUM ) == _ STR ) { return _ BOOL ; } final  Matcher date Format Matcher =  DATE_ FORMAT_ PATTERN . matcher ( string ) ; return date Format Matcher . find ( ) ; }
public void clear Values ( ) { values . clear ( ) ; }
public static double abs Average Link Diff (  Array List <  Event Log > event Log1 ,  Array List <  Event Log > event Log2 ) {  Hash Map <  Integer ,  Double [ ] > hm = new  Hash Map <  Integer ,  Double [ ] > ( ) ; assert event Log1 . size ( ) == event Log2 . size ( ) : _ STR + event Log1 . size ( ) + _ STR + event Log2 . size ( ) ; for ( int i = _ NUM ; i < event Log1 . size ( ) ; i ++ ) { int link1 = event Log1 . get ( i ) . get Link Id ( ) ; if ( ! hm . contains Key ( link1 ) ) {  Double [ ] d = new  Double [ _ NUM ] ; d [ _ NUM ] = _ NUM ; d [ _ NUM ] = _ NUM ; d [ _ NUM ] = _ NUM ; d [ _ NUM ] = _ NUM ; hm . put ( link1 , d ) ; } hm . get ( link1 ) [ _ NUM ] = event Log1 . get ( i ) . time - hm . get ( link1 ) [ _ NUM ] ; int link2 = event Log2 . get ( i ) . get Link Id ( ) ; if ( ! hm . contains Key ( link2 ) ) {  Double [ ] d = new  Double [ _ NUM ] ; d [ _ NUM ] = _ NUM ; d [ _ NUM ] = _ NUM ; d [ _ NUM ] = _ NUM ; d [ _ NUM ] = _ NUM ; hm . put ( link2 , d ) ; } hm . get ( link2 ) [ _ NUM ] = event Log2 . get ( i ) . time - hm . get ( link2 ) [ _ NUM ] ; } double abs Sum = _ NUM ; double abs Average = _ NUM ; for (  Double [ ] d : hm . values ( ) ) { abs Sum +=  Math . abs ( d [ _ NUM ] - d [ _ NUM ] ) ; } abs Average = abs Sum / hm . size ( ) ;  System . out . println ( _ STR + abs Sum ) ;  System . out . println ( _ STR + abs Average ) ; return abs Average ; }
@  Before Class public void init ( ) { if ( user Name . equals ( _ STR ) ) { user Name = app Properties . get Property ( _ STR ) ; } if ( password . equals ( _ STR ) ) { password = app Properties . get Property ( _ STR ) ; } if ( user Email . equals ( _ STR ) ) { user Email = app Properties . get Property ( _ STR ) ; } user Last Name = app Properties . get Property ( _ STR ) ; experiment =  Experiment Factory . create Experiment ( ) ; }
public void add Shutdown Hook (  Thread hook ) {  Security Manager sm =  System . get Security Manager ( ) ; if ( sm != null ) { sm . check Permission (  Runtime Permission Collection .  SHUTDOWN_ HOOKS_ PERMISSION ) ; } if ( hook == null ) throw new  Null Pointer Exception ( _ STR ) ; if ( hook . get State ( ) !=  Thread .  State .  NEW ) { throw new  Illegal Argument Exception ( ) ; } if (  VMState > _ NUM ) { throw new  Illegal State Exception ( ) ; } synchronized ( hooks List ) { if ( hooks List . contains ( hook ) ) { throw new  Illegal Argument Exception ( ) ; } hooks List . add ( hook ) ; } }
public double log Density ( double value ) { update Mean And Variance ( ) ; double val = - _ NUM * (  CONST +  Math . log ( m_ Variance ) + ( value - m_ Mean ) * ( value - m_ Mean ) / m_ Variance ) ; return val ; }
public static boolean check MD5 ( final  String md5 Hash , final  File file ) { if (  Text Utils . is Empty ( md5 Hash ) || file == null || !  File Utils . is Readable ( file ) ) {  Log . e ( _ STR ) ; return _ BOOL ; } final  String hash = get MD5 ( file ) ; if ( hash == null ) {  Log . e ( _ STR ) ; return _ BOOL ; } return hash . equals Ignore Case ( md5 Hash ) ; }
public void add Footer (  String key ,  String value ) { if ( header Out Special ( key , value ) ) { return ; } _footer Keys . add ( key ) ; _footer Values . add ( value ) ; }
public static boolean contains Any (  Char Sequence cs , char ... search Chars ) { if ( is Empty ( cs ) || is Empty ( search Chars ) ) { return _ BOOL ; } int cs Length = cs . length ( ) ; int search Length = search Chars . length ; int cs Last = cs Length - _ NUM ; int search Last = search Length - _ NUM ; for ( int i = _ NUM ; i < cs Length ; i ++ ) { char ch = cs . char At ( i ) ; for ( int j = _ NUM ; j < search Length ; j ++ ) { if ( search Chars [ j ] == ch ) { if (  Character . is High Surrogate ( ch ) ) { if ( j == search Last ) { return _ BOOL ; } if ( i < cs Last && search Chars [ j + _ NUM ] == cs . char At ( i + _ NUM ) ) { return _ BOOL ; } } else { return _ BOOL ; } } } } return _ BOOL ; }
private static void define Entity (  String name , char value ) { if ( _by Name . get ( name ) == null ) { _by Name . put ( name , new  Integer ( value ) ) ; _by Char . put ( new  Integer ( value ) , name ) ; } }
public static  Base Action parse (  String content ) {  String [ ] lines = content . split ( _ STR ) ; for ( int i = _ NUM ; i < lines . length ; i ++ ) { parse Line ( lines [ i ] ) ; }  Base Action main Action = parse Action ( _ STR , s Map . get ( _ STR ) ) ; return main Action ; }
protected  Entity Collection draw Title (  Title t ,  Graphics2 D g2 ,  Rectangle2 D area , boolean entities ) {  Param Checks . null Not Permitted ( t , _ STR ) ;  Param Checks . null Not Permitted ( area , _ STR ) ;  Rectangle2 D title Area ;  Rectangle Edge position = t . get Position ( ) ; double ww = area . get Width ( ) ; if ( ww <= _ NUM ) { return null ; } double hh = area . get Height ( ) ; if ( hh <= _ NUM ) { return null ; }  Rectangle Constraint constraint = new  Rectangle Constraint ( ww , new  Range ( _ NUM , ww ) ,  Length Constraint Type .  RANGE , hh , new  Range ( _ NUM , hh ) ,  Length Constraint Type .  RANGE ) ;  Object ret Value = null ;  Block Params p = new  Block Params ( ) ; p . set Generate Entities ( entities ) ; if ( position ==  Rectangle Edge .  TOP ) {  Size2 D size = t . arrange ( g2 , constraint ) ; title Area = create Aligned Rectangle2 D ( size , area , t . get Horizontal Alignment ( ) ,  Vertical Alignment .  TOP ) ; ret Value = t . draw ( g2 , title Area , p ) ; area . set Rect ( area . get X ( ) ,  Math . min ( area . get Y ( ) + size . height , area . get Max Y ( ) ) , area . get Width ( ) ,  Math . max ( area . get Height ( ) - size . height , _ NUM ) ) ; } else if ( position ==  Rectangle Edge .  BOTTOM ) {  Size2 D size = t . arrange ( g2 , constraint ) ; title Area = create Aligned Rectangle2 D ( size , area , t . get Horizontal Alignment ( ) ,  Vertical Alignment .  BOTTOM ) ; ret Value = t . draw ( g2 , title Area , p ) ; area . set Rect ( area . get X ( ) , area . get Y ( ) , area . get Width ( ) , area . get Height ( ) - size . height ) ; } else if ( position ==  Rectangle Edge .  RIGHT ) {  Size2 D size = t . arrange ( g2 , constraint ) ; title Area = create Aligned Rectangle2 D ( size , area ,  Horizontal Alignment .  RIGHT , t . get Vertical Alignment ( ) ) ; ret Value = t . draw ( g2 , title Area , p ) ; area . set Rect ( area . get X ( ) , area . get Y ( ) , area . get Width ( ) - size . width , area . get Height ( ) ) ; } else if ( position ==  Rectangle Edge .  LEFT ) {  Size2 D size = t . arrange ( g2 , constraint ) ; title Area = create Aligned Rectangle2 D ( size , area ,  Horizontal Alignment .  LEFT , t . get Vertical Alignment ( ) ) ; ret Value = t . draw ( g2 , title Area , p ) ; area . set Rect ( area . get X ( ) + size . width , area . get Y ( ) , area . get Width ( ) - size . width , area . get Height ( ) ) ; } else { throw new  Runtime Exception ( _ STR ) ; }  Entity Collection result = null ; if ( ret Value instanceof  Entity Block Result ) {  Entity Block Result ebr = (  Entity Block Result ) ret Value ; result = ebr . get Entity Collection ( ) ; } return result ; }
public void add Hole (  Linear Ring hole ) { if ( holes == null ) holes = new  Array List ( ) ; holes . add ( hole ) ; }
public  Document Handler ( ) { set Element Handler ( _ STR ,  Java Element Handler . class ) ; set Element Handler ( _ STR ,  Null Element Handler . class ) ; set Element Handler ( _ STR ,  Array Element Handler . class ) ; set Element Handler ( _ STR ,  Class Element Handler . class ) ; set Element Handler ( _ STR ,  String Element Handler . class ) ; set Element Handler ( _ STR ,  Object Element Handler . class ) ; set Element Handler ( _ STR ,  Void Element Handler . class ) ; set Element Handler ( _ STR ,  Char Element Handler . class ) ; set Element Handler ( _ STR ,  Byte Element Handler . class ) ; set Element Handler ( _ STR ,  Short Element Handler . class ) ; set Element Handler ( _ STR ,  Int Element Handler . class ) ; set Element Handler ( _ STR ,  Long Element Handler . class ) ; set Element Handler ( _ STR ,  Float Element Handler . class ) ; set Element Handler ( _ STR ,  Double Element Handler . class ) ; set Element Handler ( _ STR ,  Boolean Element Handler . class ) ; set Element Handler ( _ STR ,  New Element Handler . class ) ; set Element Handler ( _ STR ,  Var Element Handler . class ) ; set Element Handler ( _ STR ,  True Element Handler . class ) ; set Element Handler ( _ STR ,  False Element Handler . class ) ; set Element Handler ( _ STR ,  Field Element Handler . class ) ; set Element Handler ( _ STR ,  Method Element Handler . class ) ; set Element Handler ( _ STR ,  Property Element Handler . class ) ; }
private int read Input Data ( byte [ ] buf , int off , int len ) throws  IOException { cb Lock . lock ( ) ; try { return iis . read ( buf , off , len ) ; } finally { cb Lock . unlock ( ) ; } }
public byte [ ] generate160 Bit Hash Id ( ) throws  Crypto Exception { try {  DERBit String public Key Bit String = encode Public Key As Bit String ( public Key ) ; return  Digest Util . get Message Digest ( public Key Bit String . get Bytes ( ) ,  Digest Type .  SHA1 ) ; } catch (  IOException ex ) { throw new  Crypto Exception ( res . get String ( _ STR ) , ex ) ; } }
public static <  C extends  Configuration Client ,  S extends  Configuration >  Create Sub Command Handler <  C ,  S > create (  Sub Command Argument Parser parser ,  Managed Object Path < ? , ? > p ,  Set Relation Definition <  C ,  S > r ) throws  Argument Exception { return new  Create Sub Command Handler < > ( parser , p , r , null , p . child ( r ) ) ; }
public  DSubject Alternative Name (  JDialog parent , byte [ ] value ) throws  IOException { super ( parent ) ; set Title ( res . get String ( _ STR ) ) ; init Components ( ) ; prepopulate With Value ( value ) ; }
public void test Signer String ( ) throws  Exception {  Signer s = new  Signer Stub ( _ STR ) ; assert Not Null ( s ) ; assert Equals ( _ STR , s . get Name ( ) ) ; assert Null ( s . get Private Key ( ) ) ;  Signer s2 = new  Signer Stub ( null ) ; assert Null ( s2 . get Name ( ) ) ; }
private  Figure read Rect Element (  IXMLElement elem ) throws  IOException {  Hash Map <  Attribute Key ,  Object > a = new  Hash Map <  Attribute Key ,  Object > ( ) ; read Core Attributes ( elem , a ) ; read Transform Attribute ( elem , a ) ; read Opacity Attribute ( elem , a ) ; read Shape Attributes ( elem , a ) ; double x = to Number ( elem , read Attribute ( elem , _ STR , _ STR ) ) ; double y = to Number ( elem , read Attribute ( elem , _ STR , _ STR ) ) ; double w = to Width ( elem , read Attribute ( elem , _ STR , _ STR ) ) ; double h = to Height ( elem , read Attribute ( elem , _ STR , _ STR ) ) ;  String rx Value = read Attribute ( elem , _ STR , _ STR ) ;  String ry Value = read Attribute ( elem , _ STR , _ STR ) ; if ( rx Value . equals ( _ STR ) ) { rx Value = ry Value ; } if ( ry Value . equals ( _ STR ) ) { ry Value = rx Value ; } double rx = to Number ( elem , rx Value . equals ( _ STR ) ? _ STR : rx Value ) ; double ry = to Number ( elem , ry Value . equals ( _ STR ) ? _ STR : ry Value ) ;  Figure figure = factory . create Rect ( x , y , w , h , rx , ry , a ) ; element Objects . put ( elem , figure ) ; return figure ; }
public boolean is Set Message Type ( ) { return __isset_bit_vector . get ( __ MESSAGETYPE_ ISSET_ ID ) ; }
private  String read Resource As String (  Resource resource ) throws  IOException {  String Builder contents = new  String Builder ( ) ;  Reader reader = new  Input Stream Reader ( resource . as Stream ( ) , _ STR ) ; try { char buffer [ ] = new char [ _ NUM ] ; int length ; while ( ( length = reader . read ( buffer ) ) != - _ NUM ) { contents . append ( buffer , _ NUM , length ) ; } } finally { reader . close ( ) ; } return contents . to String ( ) ; }
public  JFile Image Chooser ( final  Shell parent , final int style , final  File working Dir ) { file Dialog = new  File Dialog ( parent , style ) ; if ( working Dir != null ) file Dialog . set Filter Path ( working Dir . get Absolute Path ( ) ) ; }
public void perform Book Keeping (  Map <  String ,  Storage System View Object > scanned Systems Native Guids Map ,  List <  URI > provider List ) {  Storage System storage System = null ;  List <  Storage System > systems To Persist = new  Array List <  Storage System > ( ) ;  List <  Storage System > systems To Create = new  Array List <  Storage System > ( ) ;  Set <  String > scanned System Native Guid Key Set ; synchronized ( scanned Systems Native Guids Map ) { scanned System Native Guid Key Set = new  Hash Set ( scanned Systems Native Guids Map . key Set ( ) ) ; }  Set <  URI > scanned Provider List = new  Hash Set <  URI > ( provider List ) ;  Map <  URI ,  List <  String > > providers To Update = new  Hash Map <  URI ,  List <  String > > ( ) ; for (  String scanned System Native Guid : scanned System Native Guid Key Set ) { try { _logger . info ( _ STR , scanned System Native Guid ) ;  List <  Storage System > systems =  Custom Query Utility . get Active Storage System By Native Guid ( _db Client , scanned System Native Guid ) ; if (  Decommissioned Resource . check Decommissioned ( _db Client , scanned System Native Guid ,  Storage System . class ) ) { scanned Systems Native Guids Map . remove ( scanned System Native Guid ) ; _logger . info ( _ STR , scanned System Native Guid ) ; continue ; } if ( null == systems || systems . is Empty ( ) ) { storage System = create Storage System ( scanned Systems Native Guids Map . get ( scanned System Native Guid ) , scanned System Native Guid , providers To Update ) ; if ( storage System != null ) { systems To Create . add ( storage System ) ; _logger . info ( _ STR , storage System . get Native Guid ( ) ) ; } } } catch (  Exception e ) { _logger . error ( e . get Message ( ) , e ) ; _logger . error ( _ STR , storage System != null ? storage System . get Id ( ) : _ STR , e . get Cause ( ) ) ; } } try { _db Client . create Object ( systems To Create ) ; } catch (  Database Exception ex ) { _logger . error ( _ STR , ex ) ; } update Active Provider Details In Db System ( scanned Systems Native Guids Map , systems To Persist , scanned Provider List , providers To Update ) ; persist All Systems And Providers ( systems To Persist , get SMISProviders With Updated Systems ( providers To Update ) ) ; }
public final int read Int ( ) throws java . io .  IOException { read Fully ( scratch , _ NUM , _ NUM ) ; return ( ( ( scratch [ _ NUM ] & _ NUM ) << _ NUM ) | ( ( scratch [ _ NUM ] & _ NUM ) << _ NUM ) | ( ( scratch [ _ NUM ] & _ NUM ) << _ NUM ) | ( ( scratch [ _ NUM ] & _ NUM ) << _ NUM ) ) ; }
public  Replication Job create Job For Copy Partition ( long audit Log Id , long audit Log Entry Create Time ,  Named Partition named Partition ) throws  State Update Exception {  String partition Name = named Partition . get Name ( ) ;  List <  String > partition Names = new  Array List < > ( ) ; partition Names . add ( partition Name ) ;  Replication Operation replication Operation =  Replication Operation .  COPY_ PARTITION ;  Map <  String ,  String > extras = new  Hash Map < > ( ) ; extras . put (  Persisted Job Info .  AUDIT_ LOG_ ID_ EXTRAS_ KEY ,  Long . to String ( audit Log Id ) ) ; extras . put (  Persisted Job Info .  AUDIT_ LOG_ ENTRY_ CREATE_ TIME_ KEY ,  Long . to String ( audit Log Entry Create Time ) ) ;  Partition partition = named Partition . get Partition ( ) ;  Hive Object Spec spec = new  Hive Object Spec ( named Partition ) ;  Persisted Job Info persisted Job Info = job Info Store . resilient Create ( replication Operation ,  Replication Status .  PENDING ,  Replication Utils . get Location ( partition ) , src Cluster . get Name ( ) , spec , partition Names ,  Replication Utils . get Tldt ( partition ) ,  Optional . empty ( ) ,  Optional . empty ( ) , extras ) ;  Replication Task replication Task = new  Copy Partition Task ( conf , destination Object Factory , object Conflict Handler , src Cluster , dest Cluster , spec ,  Replication Utils . get Location ( partition ) ,  Optional . <  Path > empty ( ) , directory Copier , _ BOOL ) ; return new  Replication Job ( conf , replication Task , on State Change Handler , persisted Job Info ) ; }
public static void write File (  String to Write ,  String file Name ) throws  File Not Found Exception ,  Unsupported Encoding Exception { logger . debug ( _ STR + file Name ) ;  Print Writer writer = null ; try { writer = new  Print Writer ( file Name , _ STR ) ; writer . println ( to Write ) ; } finally { if ( writer != null ) { writer . close ( ) ; } } }
public static  Map <  String ,  Object > create Content (  Dispatch Context dctx ,  Map <  String , ? extends  Object > context ) {  Map <  String ,  Object > result = create Content Method ( dctx , context ) ; return result ; }
public static boolean is File Exist (  String file Path ) { if (  Handler_ String . is Blank ( file Path ) ) { return _ BOOL ; }  File file = new  File ( file Path ) ; return ( file . exists ( ) && file . is File ( ) ) ; }
private static  String to String ( double [ ] [ ] m ,  Number Format nf ,  List <  String > variables ) {  String result ; if ( nf == null ) { throw new  Null Pointer Exception ( _ STR ) ; } if ( variables == null ) { variables = new  Array List < > ( ) ; for ( int i = _ NUM ; i < m [ _ NUM ] . length ; i ++ ) { variables . add ( _ STR + ( i + _ NUM ) ) ; } } if ( m == null ) { result = null Message ( ) ; } else {  Text Table text Table = new  Text Table ( m . length + _ NUM , m [ _ NUM ] . length ) ; for ( int i = _ NUM ; i < variables . size ( ) ; i ++ ) { text Table . set Token ( _ NUM , i , variables . get ( i ) ) ; } for ( int i = _ NUM ; i < m . length ; i ++ ) { for ( int j = _ NUM ; j < m [ _ NUM ] . length ; j ++ ) { text Table . set Token ( i + _ NUM , j , m [ i ] [ j ] == _ NUM ? _ STR : nf . format ( m [ i ] [ j ] ) ) ; } } result = _ STR + text Table . to String ( ) ; } return result ; }
private double [ ] calculate B ( ) { int length = m Extremal Indices . size ( ) ; double [ ] b = new double [ length ] ; for ( int k = _ NUM ; k < length ; k ++ ) { b [ k ] = _ NUM ; double xk = m Grid . get Cosine Frequency Grid ( ) [ m Extremal Indices . get ( k ) ] ; for ( int i = _ NUM ; i < length ; i ++ ) { if ( i != k ) { double xi = m Grid . get Cosine Frequency Grid ( ) [ m Extremal Indices . get ( i ) ] ; double denominator = xk - xi ; if (  Math . abs ( denominator ) < _ NUM ) { denominator = _ NUM ; } b [ k ] *= _ NUM / denominator ; } } } return b ; }
private void read Boot Json (  String basedir ) throws  IOException {  Bootstrap Config boot =  Bootstrap Config . from Json File ( basedir + _ STR ) ;  String dsame Password ;  String config Store Password ; try {  AMKey Provider am Key Provider = new  AMKey Provider ( boot . get Key Store Config ( _ STR ) ) ; dsame Password = am Key Provider . get Secret (  DSAME_ PWD_ KEY ) ; config Store Password = am Key Provider . get Secret (  CONFIG_ PWD_ KEY ) ; } catch (  Key Store Exception e ) { throw new  IOException ( _ STR , e ) ; }  String server_instance = boot . get Instance ( ) ; if ( server_instance == null ) { throw new  IOException ( _ STR ) ; }  String dsame_user = boot . get Dsame User ( ) ; for (  Config Store Properties cfp : boot . get Config Store List ( ) ) {  Map m = new  Hash Map ( ) ;  String proto = cfp . get Ldap Protocol ( ) + _ STR ; m . put (  PROTOCOL , proto ) ; m . put (  DS_ HOST , cfp . get Ldap Host ( ) ) ;  String port = _ STR + cfp . get Ldap Port ( ) ; m . put (  DS_ PORT , port ) ; m . put (  SERVER_ INSTANCE , server_instance ) ; m . put (  PWD , config Store Password ) ; m . put (  DS_ BASE_ DN , cfp . get Base DN ( ) ) ; m . put (  USER , dsame_user ) ; m . put (  DS_ MGR , cfp . get Dir Manager DN ( ) ) ; m . put (  DS_ PWD , dsame Password ) ;  String bootstrap = create Bootstrap Resource ( m , _ BOOL ) ; bootstrap =  String Utils . str Replace All ( bootstrap , _ STR ,  URLEncoder . encode ( dsame_user , _ STR ) ) ; data . add ( bootstrap ) ; } }
public byte [ ] put (  Input Stream in ) throws  IOException {  Byte Array Output Stream id = new  Byte Array Output Stream ( ) ; int level = _ NUM ; try { while ( _ BOOL ) { if ( put ( id , in , level ) ) { break ; } if ( id . size ( ) > max Block Size / _ NUM ) { id = put Indirect Id ( id ) ; level ++ ; } } } catch (  IOException e ) { remove ( id . to Byte Array ( ) ) ; throw e ; } if ( id . size ( ) > min Block Size * _ NUM ) { id = put Indirect Id ( id ) ; } return id . to Byte Array ( ) ; }
protected void save Buffer ( ) {  String Buffer sb = m_ History . get Selected Buffer ( ) ; if ( sb != null ) { if ( m_ Save Out . save ( sb ) ) {  JOption Pane . show Message Dialog ( this , _ STR , _ STR ,  JOption Pane .  INFORMATION_ MESSAGE ) ; } } else { m_ Save Out But . set Enabled ( _ BOOL ) ; } }
private  List <  Recommendation > create Metro Point Recommendations (  Virtual Array src Varray ,  List <  Virtual Array > tgt Varrays ,  Virtual Pool src Vpool ,  Virtual Array ha Varray ,  Virtual Pool ha Vpool ,  Project project ,  Virtual Pool Capability Values Wrapper capabilities ,  List <  Storage Pool > candidate Primary Pools ,  List <  Storage Pool > candidate Secondary Pools ,  Volume vpool Change Volume ) {  List <  Recommendation > recommendations = new  Array List <  Recommendation > ( ) ;  RPProtection Recommendation rp Protection Recommendaton = null ;  Map <  Virtual Array ,  List <  Storage Pool > > tgt Varray Storage Pools Map = get Vplex Target Matching Pools ( tgt Varrays , src Vpool , project , capabilities , vpool Change Volume ) ; rp Protection Recommendaton = create RPProtection Recommendation For Metro Point ( src Varray , tgt Varrays , src Vpool , ha Varray , ha Vpool , capabilities , candidate Primary Pools , candidate Secondary Pools , tgt Varray Storage Pools Map , vpool Change Volume , project ) ; _log . info (  String . format ( _ STR , rp Protection Recommendaton . get Resource Count ( ) ) ) ; recommendations . add ( rp Protection Recommendaton ) ; return recommendations ; }
@  Not Null public static  List <  String > complete Absolute Path ( @  Not Null  String prefix ,  Predicate <  File > accept ) {  String native Path = prefix . starts With ( _ STR ) &&  System Info Rt . is Windows ?  OSUtil . bash Compatible To Native ( prefix ) : prefix ;  File base = new  File ( native Path ) ; boolean dot Suffix = prefix . ends With ( _ STR ) && ! prefix . starts With ( _ STR ) ; if ( ! base . exists ( ) || dot Suffix ) { base = base . get Parent File ( ) ; if ( base == null || ! base . exists ( ) ) { return  Collections . empty List ( ) ; } }  File base Path ;  String match Prefix ; if ( base . is Directory ( ) ) { base Path = base ; match Prefix = _ STR ; } else { base Path = base . get Parent File ( ) ; match Prefix = base . get Name ( ) ; }  List <  String > result =  Lists . new Linked List ( ) ; for (  File file Candidate : collect Files ( base Path , match Prefix ) ) { if ( ! accept . apply ( file Candidate ) ) { continue ; }  String result Path ; if ( file Candidate . is Directory ( ) ) { result Path = file Candidate . get Absolute Path ( ) +  File . separator ; } else { result Path = file Candidate . get Absolute Path ( ) ; } result . add (  OSUtil . to Bash Compatible ( result Path ) ) ; } return result ; }
protected void add (  Instance inst ) { for ( int i = _ NUM ; i < m_ Specifiers . size ( ) ; i ++ ) {  Instance specifier = m_ Specifiers . get ( i ) ; boolean found = _ BOOL ; for ( int m_ Dataset Key Column : m_ Dataset Key Columns ) { if ( inst . value ( m_ Dataset Key Column ) != specifier . value ( m_ Dataset Key Column ) ) { found = _ BOOL ; } } if ( found ) { return ; } } m_ Specifiers . add ( inst ) ; }
public static  List <  Vm > create Vm List ( int broker Id , int vms Number ) {  List <  Vm > vms = new  Array List <  Vm > ( ) ; for ( int i = _ NUM ; i < vms Number ; i ++ ) { int vm Type = i / ( int )  Math . ceil ( ( double ) vms Number /  Constants .  VM_ TYPES ) ; vms . add ( new  Power Vm ( i , broker Id ,  Constants .  VM_ MIPS [ vm Type ] ,  Constants .  VM_ PES [ vm Type ] ,  Constants .  VM_ RAM [ vm Type ] ,  Constants .  VM_ BW ,  Constants .  VM_ SIZE , _ NUM , _ STR , new  Cloudlet Scheduler Dynamic Workload (  Constants .  VM_ MIPS [ vm Type ] ,  Constants .  VM_ PES [ vm Type ] ) ,  Constants .  SCHEDULING_ INTERVAL ) ) ; } return vms ; }
private void check Target Is Not Writable (  File target ,  Throwable exception ) throws  Core Exception { if ( ! target . can Write ( ) ) {  String message =  NLS . bind (  Messages . could Not Write , target . get Absolute Path ( ) ) ;  Policy . error (  EFS .  ERROR_ WRITE , message ) ; } }
private static long dos To Java Time ( long dtime ) { @  Suppress Warnings ( _ STR )  Date d = new  Date ( ( int ) ( ( ( dtime > > _ NUM ) & _ NUM ) + _ NUM ) , ( int ) ( ( ( dtime > > _ NUM ) & _ NUM ) - _ NUM ) , ( int ) ( ( dtime > > _ NUM ) & _ NUM ) , ( int ) ( ( dtime > > _ NUM ) & _ NUM ) , ( int ) ( ( dtime > > _ NUM ) & _ NUM ) , ( int ) ( ( dtime << _ NUM ) & _ NUM ) ) ; return d . get Time ( ) ; }
private int make Available ( ) throws  IOException { if ( pos != - _ NUM ) { return _ NUM ; } total += tail - head - pad ;  System . arraycopy ( buffer , tail - pad , buffer , _ NUM , pad ) ; head = _ NUM ; tail = pad ; for ( ; ; ) { int bytes Read = input . read ( buffer , tail , buf Size - tail ) ; if ( bytes Read == - _ NUM ) { final  String msg = _ STR ; throw new  Malformed Stream Exception ( msg ) ; } tail += bytes Read ; find Separator ( ) ; int av = available ( ) ; if ( av > _ NUM || pos != - _ NUM ) { return av ; } } }
double evaluate Instance Leave One Out (  Instance instance , double [ ] inst A ) throws  Exception {  Decision Table Hash Key thekey ; double [ ] temp Dist ; double [ ] norm Dist ; thekey = new  Decision Table Hash Key ( inst A ) ; if ( m_class Is Nominal ) { if ( ( temp Dist = m_entries . get ( thekey ) ) == null ) { throw new  Error ( _ STR ) ; } else { norm Dist = new double [ temp Dist . length ] ;  System . arraycopy ( temp Dist , _ NUM , norm Dist , _ NUM , temp Dist . length ) ; norm Dist [ ( int ) instance . class Value ( ) ] -= instance . weight ( ) ; boolean ok = _ BOOL ; for ( double element : norm Dist ) { if (  Utils . gr ( element , _ NUM ) ) { ok = _ BOOL ; break ; } } m_class Prior Counts [ ( int ) instance . class Value ( ) ] -= instance . weight ( ) ; double [ ] class Priors = m_class Prior Counts . clone ( ) ;  Utils . normalize ( class Priors ) ; if ( ! ok ) { norm Dist = class Priors ; } m_class Prior Counts [ ( int ) instance . class Value ( ) ] += instance . weight ( ) ;  Utils . normalize ( norm Dist ) ; if ( m_evaluation Measure ==  EVAL_ AUC ) { m_evaluation . evaluate Model Once And Record Prediction ( norm Dist , instance ) ; } else { m_evaluation . evaluate Model Once ( norm Dist , instance ) ; } return  Utils . max Index ( norm Dist ) ; } } else { if ( ( temp Dist = m_entries . get ( thekey ) ) != null ) { norm Dist = new double [ temp Dist . length ] ;  System . arraycopy ( temp Dist , _ NUM , norm Dist , _ NUM , temp Dist . length ) ; norm Dist [ _ NUM ] -= ( instance . class Value ( ) * instance . weight ( ) ) ; norm Dist [ _ NUM ] -= instance . weight ( ) ; if (  Utils . eq ( norm Dist [ _ NUM ] , _ NUM ) ) { double [ ] temp = new double [ _ NUM ] ; temp [ _ NUM ] = m_majority ; m_evaluation . evaluate Model Once ( temp , instance ) ; return m_majority ; } else { double [ ] temp = new double [ _ NUM ] ; temp [ _ NUM ] = norm Dist [ _ NUM ] / norm Dist [ _ NUM ] ; m_evaluation . evaluate Model Once ( temp , instance ) ; return temp [ _ NUM ] ; } } else { throw new  Error ( _ STR ) ; } } }
private  Group parse Group Result (  Result Set result Set ) throws  SQLException ,  Ade Internal Exception { int uid = result Set . get Int ( _ STR ) ;  String name = result Set . get String ( _ STR ) ;  Short group Type Val = result Set . get Short ( _ STR ) ;  Group Type group Type =  Group Type . get Group Type ( group Type Val ) ;  Short data Type Val = result Set . get Short ( _ STR ) ;  Data Type data Type =  Data Type . get Data Type ( data Type Val ) ; short evaluation Order = result Set . get Short ( _ STR ) ; int rid = result Set . get Int ( _ STR ) ;  String rule Name = get Rule Name ( rid ) ; return new  Group ( uid , name , group Type , data Type , evaluation Order , rule Name ) ; }
public long skip ( long n ) throws  IOException { if ( n < _ NUM ) throw new  Illegal Argument Exception ( _ STR ) ; int nn = ( int )  Math . min ( n , max Skip Buffer Size ) ; synchronized ( lock ) { if ( ( skip Buffer == null ) || ( skip Buffer . length < nn ) ) skip Buffer = new char [ nn ] ; long r = n ; while ( r > _ NUM ) { int nc = read ( skip Buffer , _ NUM , ( int )  Math . min ( r , nn ) ) ; if ( nc == - _ NUM ) break ; r -= nc ; } return n - r ; } }
private  Image Icon add Space To Icon (  Image Icon icon ) { int width = icon . get Icon Width ( ) ; int height = icon . get Icon Height ( ) ; int hspace = _ NUM ;  Buffered Image res = new  Buffered Image ( width + hspace , height ,  Buffered Image .  TYPE_ INT_ ARGB ) ;  Graphics g = res . get Graphics ( ) ; g . draw Image ( icon . get Image ( ) , _ NUM , _ NUM , null ) ; g . dispose ( ) ; return new  Image Icon ( res ) ; }
private boolean is Template Name Part ( char ch ) { return !  Character . is Whitespace ( ch ) && ch != _ STR && ch != _ STR && ch != _ STR && ch != _ STR && ch != _ STR && ch != _ STR ; }
private void handle Add Line ( final  String header , final  String line , final  Notification Type type ) { insert Newline ( ) ;  String date String = date Formatter . format ( new  Date ( ) ) ; insert Timestamp ( date String ) ; insert Header ( header ) ; insert Text ( line , type ) ; }
public static  String read String ( final  Result Set result Set , final  String column Name ) throws  SQLException { return result Set . get String ( column Name ) ; }
public static  Credential basic (  String user Name ,  String password ) { try {  String username And Password = user Name + _ STR + password ; byte [ ] bytes = username And Password . get Bytes ( _ STR ) ;  String encoded =  Base64 . encode ( bytes ) ; return new  Credential ( _ STR + encoded ) ; } catch (  Unsupported Encoding Exception e ) { throw new  Assertion Error ( ) ; } }
protected static  String guess Type (  File file ) {  String name = file . get Name ( ) ;  String suffix = name . substring ( name . last Index Of ( _ STR ) + _ NUM ) ;  String type = mime Map . get ( suffix . to Lower Case (  Locale .  ROOT ) ) ; return ( type != null ) ? type : _ STR ; }
public void test Next All Terms ( ) throws  Exception {  List <  String > terms List = new  Array List < > ( ) ; terms List . add All (  Arrays . as List ( common Terms ) ) ; terms List . add All (  Arrays . as List ( medium Terms ) ) ; terms List . add All (  Arrays . as List ( rare Terms ) ) ;  String terms [ ] = terms List . to Array ( new  String [ _ NUM ] ) ; for ( int min Nr Should Match = _ NUM ; min Nr Should Match <= terms . length ; min Nr Should Match ++ ) {  Scorer expected = scorer ( terms , min Nr Should Match ,  Mode .  DOC_ VALUES ) ;  Scorer actual = scorer ( terms , min Nr Should Match ,  Mode .  SCORER ) ; assert Next ( expected , actual ) ; expected = scorer ( terms , min Nr Should Match ,  Mode .  DOC_ VALUES ) ; actual = scorer ( terms , min Nr Should Match ,  Mode .  BULK_ SCORER ) ; assert Next ( expected , actual ) ; } }
public boolean is Public ( ) { return  Modifier . is Public ( _method . get Modifiers ( ) ) ; }
public void test Constr String Exception ( ) {  String a = _ STR ; try {  Big Decimal bd = new  Big Decimal ( a ) ; fail ( _ STR + bd . to String ( ) ) ; } catch (  Number Format Exception e ) { } }
native long create Drag Source (  Component component ,  Transferable transferable ,  Input Event native Trigger , int actions , long [ ] formats ,  Map format Map ) ;
private int put Length ( int len ,  Output Stream out ) throws  IOException { int ret Val = _ NUM ; if ( len < _ NUM ) { out . write ( ( byte ) len ) ; ret Val = _ NUM ; } else if ( len < ( _ NUM << _ NUM ) ) { out . write ( ( byte ) _ NUM ) ; out . write ( ( byte ) len ) ; ret Val = _ NUM ; } else if ( len < ( _ NUM << _ NUM ) ) { out . write ( ( byte ) _ NUM ) ; out . write ( ( byte ) ( len > > _ NUM ) ) ; out . write ( ( byte ) len ) ; ret Val = _ NUM ; } else if ( len < ( _ NUM << _ NUM ) ) { out . write ( ( byte ) _ NUM ) ; out . write ( ( byte ) ( len > > _ NUM ) ) ; out . write ( ( byte ) ( len > > _ NUM ) ) ; out . write ( ( byte ) len ) ; ret Val = _ NUM ; } else { out . write ( ( byte ) _ NUM ) ; out . write ( ( byte ) ( len > > _ NUM ) ) ; out . write ( ( byte ) ( len > > _ NUM ) ) ; out . write ( ( byte ) ( len > > _ NUM ) ) ; out . write ( ( byte ) len ) ; ret Val = _ NUM ; } return ret Val ; }
public static void add Font (  String font Key ,  Font font ) { if ( font Key != null ) { font Key = font Key . to Lower Case ( ) ; } else { if ( font . get Charset ( ) != null ) { throw new  Illegal Argument Exception ( _ STR ) ; } } fonts . put ( font Key , new  HTMLFont ( font Key , font ) ) ; }
public boolean write (  Type type ,  Object value ,  Node Map node ) {  Class actual = value . get Class ( ) ;  Class expect = type . get Type ( ) ;  Class real = actual ; if ( actual . is Array ( ) ) { real = write Array ( actual , value , node ) ; } if ( actual != expect ) { node . put ( label , real . get Name ( ) ) ; } return write Reference ( value , node ) ; }
public  String format (  Date Time Formatter formatter ) {  Objects . require Non Null ( formatter , _ STR ) ; return formatter . format ( this ) ; }
@  Dotted Class Name @  Suppress FBWarnings ( _ STR ) public static  String to Dotted Class Name ( @  Slashed Class Name ( when =  When .  UNKNOWN )  String class Name ) { if ( class Name . index Of ( _ STR ) >= _ NUM ) { return  Descriptor Factory . canonicalize String ( class Name . replace ( _ STR , _ STR ) ) ; } return class Name ; }
public  DSubject Key Identifier (  JDialog parent ,  Public Key subject Public Key ) { super ( parent ) ; set Title ( res . get String ( _ STR ) ) ; this . subject Public Key = subject Public Key ; init Components ( ) ; }
private void play Previous ( ) { if ( media Type ==  Config .  YOUTUBE_ MEDIA_ TYPE_ VIDEO ) { restart Video ( ) ; return ; } if ( next Was Called ) { iterator . previous ( ) ; next Was Called = _ BOOL ; } if ( ! iterator . has Previous ( ) ) { iterator = you Tube Videos . list Iterator ( you Tube Videos . size ( ) ) ; } video Item = iterator . previous ( ) ; previous Was Called = _ BOOL ; play Video ( ) ; }
public static  Object invoke Declared (  Class c ,  Object obj ,  String method ,  Class [ ] param Classes ,  Object [ ] params ) throws  Illegal Access Exception ,  No Such Method Exception ,  Invocation Target Exception {  Method m = c . get Declared Method ( method , param Classes ) ; m . set Accessible ( _ BOOL ) ; return m . invoke ( obj , params ) ; }
public static  Rotate Stream create (  String path ) throws  Config Exception { synchronized ( _format Streams ) {  Weak Reference <  Rotate Stream > ref = _format Streams . get ( path ) ;  Rotate Stream stream = ref != null ? ref . get ( ) : null ; if ( stream == null ) { stream = new  Rotate Stream ( path ) ; _format Streams . put ( path , new  Weak Reference <  Rotate Stream > ( stream ) ) ; } return stream ; } }
private void do Auto Shuffle Update ( ) { boolean notify = _ BOOL ; if ( m Play Pos > _ NUM ) { remove Tracks ( _ NUM , m Play Pos - _ NUM ) ; notify = _ BOOL ; } final int to Add = _ NUM - ( m Play List Len - ( m Play Pos < _ NUM ? - _ NUM : m Play Pos ) ) ; for ( int i = _ NUM ; i < to Add ; i ++ ) { int lookback = m History . size ( ) ; int idx = - _ NUM ; while ( _ BOOL ) { idx = m Shuffler . next Int ( m Auto Shuffle List . length ) ; if ( ! was Recently Used ( idx , lookback ) ) { break ; } lookback /= _ NUM ; } m History . add ( idx ) ; if ( m History . size ( ) >  MAX_ HISTORY_ SIZE ) { m History . remove ( _ NUM ) ; } ensure Play List Capacity ( m Play List Len + _ NUM ) ; m Play List [ m Play List Len ++ ] = m Auto Shuffle List [ idx ] ; notify = _ BOOL ; } if ( notify ) { notify Change (  QUEUE_ CHANGED ) ; } }
Parse Result (  Throwable throwable ) { this (  Optional . empty ( ) , singleton List ( new  Problem ( throwable . get Message ( ) ,  Optional . empty ( ) ,  Optional . of ( throwable ) ) ) ,  Optional . empty ( ) ,  Optional . empty ( ) ) ; }
@  Suppress Warnings ( _ STR ) private  String next Literal ( boolean assign Offsets Only ) throws  IOException {  String Builder builder = null ; value Pos = - _ NUM ; value Length = _ NUM ; int i = _ NUM ; find Non Literal Character : while ( _ BOOL ) { for ( ; pos + i < limit ; i ++ ) { switch ( buffer [ pos + i ] ) { case _ STR : case _ STR : case _ STR : case _ STR : case _ STR : check Lenient ( ) ; case _ STR : case _ STR : case _ STR : case _ STR : case _ STR : case _ STR : case _ STR : case _ STR : case _ STR : case _ STR : case _ STR : break find Non Literal Character ; } } if ( i < buffer . length ) { if ( fill Buffer ( i + _ NUM ) ) { continue ; } else { buffer [ limit ] = _ STR ; break ; } } if ( builder == null ) { builder = new  String Builder ( ) ; } builder . append ( buffer , pos , i ) ; value Length += i ; pos += i ; i = _ NUM ; if ( ! fill Buffer ( _ NUM ) ) { break ; } }  String result ; if ( assign Offsets Only && builder == null ) { value Pos = pos ; result = null ; } else if ( skipping ) { result = _ STR ; } else if ( builder == null ) { result = string Pool . get ( buffer , pos , i ) ; } else { builder . append ( buffer , pos , i ) ; result = builder . to String ( ) ; } value Length += i ; pos += i ; return result ; }
public boolean can Load (  Entity unit , boolean check Elev ) { if ( this instanceof  Infantry ) { return _ BOOL ; } if ( ! unit . is Enemy Of ( this ) ) {  Enumeration <  Transporter > iter = transports . elements ( ) ; while ( iter . has More Elements ( ) ) {  Transporter next = iter . next Element ( ) ; if ( next . can Load ( unit ) && ( ! check Elev || ( unit . get Elevation ( ) == get Elevation ( ) ) ) ) { return _ BOOL ; } } } return _ BOOL ; }
public static boolean read Boolean ( ) {  String s = read String ( ) ; if ( s . equals Ignore Case ( _ STR ) ) return _ BOOL ; if ( s . equals Ignore Case ( _ STR ) ) return _ BOOL ; if ( s . equals ( _ STR ) ) return _ BOOL ; if ( s . equals ( _ STR ) ) return _ BOOL ; throw new  Input Mismatch Exception ( ) ; }
@  Override public boolean e Is Set ( int feature ID ) { switch ( feature ID ) { case  Functionblock Package .  OPERATION__ NAME : return  NAME_ EDEFAULT == null ? name != null : !  NAME_ EDEFAULT . equals ( name ) ; case  Functionblock Package .  OPERATION__ PARAMS : return params != null && ! params . is Empty ( ) ; case  Functionblock Package .  OPERATION__ RETURN_ TYPE : return return Type != null ; case  Functionblock Package .  OPERATION__ DESCRIPTION : return  DESCRIPTION_ EDEFAULT == null ? description != null : !  DESCRIPTION_ EDEFAULT . equals ( description ) ; case  Functionblock Package .  OPERATION__ BREAKABLE : return breakable !=  BREAKABLE_ EDEFAULT ; } return super . e Is Set ( feature ID ) ; }
private void initialize Raw Source Code Map (  String raw Source ) { raw Source Code With Line = new  Linked Hash Map < > ( ) ; int line Number = _ NUM ;  String Reader sr = new  String Reader ( raw Source ) ;  Buffered Reader br = new  Buffered Reader ( sr ) ;  String line ; try { while ( ( line = br . read Line ( ) ) != null ) { if (  String Utils . is Not Blank ( line ) ) { raw Source Code With Line . put ( line Number , line ) ; line Number ++ ; } } } catch (  IOException ex ) {  LOGGER . error ( _ STR + ex . get Message ( ) ) ; } }
public static  Matrix back Sub (  Matrix  U ,  Matrix y ) { if ( y . rows ( ) !=  U . rows ( ) ) throw new  Arithmetic Exception ( _ STR ) ;  Matrix x = new  Dense Matrix (  U . cols ( ) , y . cols ( ) ) ; double [ ] x_col_k = new double [ y . rows ( ) ] ; final int start =  Math . min (  U . rows ( ) ,  U . cols ( ) ) - _ NUM ; for ( int k = _ NUM ; k < y . cols ( ) ; k ++ ) { for ( int i = start ; i >= _ NUM ; i -- ) { x_col_k [ i ] = y . get ( i , k ) ; for ( int j = i + _ NUM ; j <= start ; j ++ ) x_col_k [ i ] -=  U . get ( i , j ) * x_col_k [ j ] ; x_col_k [ i ] /=  U . get ( i , i ) ; } for ( int i = _ NUM ; i < x_col_k . length ; i ++ ) if (  Double . is Infinite ( x_col_k [ i ] ) ) x . set ( i , k , _ NUM ) ; else x . set ( i , k , x_col_k [ i ] ) ; } return x ; }
private void record Visit Field (  Object object ,  Field object Field ,  Field field ) {  Map <  String ,  Set <  String > > bag = visited Fields . get ( object ) ; if ( bag == null ) { bag = new  Hash Map < > ( ) ; visited Fields . put ( object , bag ) ; }  Set <  String > fields = bag . get ( object Field ) ;  String object Filed Key = object Field == null ? _ STR : object Field . to Generic String ( ) ; if ( fields == null ) { fields = new  Hash Set < > ( ) ; bag . put ( object Filed Key , fields ) ; } fields . add ( field . to Generic String ( ) ) ; }
public void remove Download (  Download Info Runnable download Info Runnable ) { m Completed List . remove ( download Info Runnable ) ; }
protected void add Shingled Phrase Queries ( final  Boolean Query .  Builder main Query , final  List <  Clause > clauses , final  Collection <  Field Params > fields , int shingle Size , final float tiebreaker , final int slop ) throws  Syntax Error { if ( null == fields || fields . is Empty ( ) || null == clauses || clauses . size ( ) < shingle Size ) return ; if ( _ NUM == shingle Size ) shingle Size = clauses . size ( ) ; final int last Clause Index = shingle Size - _ NUM ;  String Builder user Phrase Query = new  String Builder ( ) ; for ( int i = _ NUM ; i < clauses . size ( ) - last Clause Index ; i ++ ) { user Phrase Query . append ( _ STR ) ; for ( int j = _ NUM ; j <= last Clause Index ; j ++ ) { user Phrase Query . append ( clauses . get ( i + j ) . val ) ; user Phrase Query . append ( _ STR ) ; } user Phrase Query . append ( _ STR ) ; user Phrase Query . append ( _ STR ) ; }  Extended Solr Query Parser pp = create Edismax Query Parser ( this ,  IMPOSSIBLE_ FIELD_ NAME ) ; pp . add Alias (  IMPOSSIBLE_ FIELD_ NAME , tiebreaker , get Field Boosts ( fields ) ) ; pp . set Phrase Slop ( slop ) ; pp . set Remove Stop Filter ( _ BOOL ) ; pp . make Dismax = _ BOOL ; pp . min Clause Size = _ NUM ;  Query phrase = pp . parse ( user Phrase Query . to String ( ) ) ; if ( phrase != null ) { main Query . add ( phrase ,  Boolean Clause .  Occur .  SHOULD ) ; } }
public static  String encode Base64 ( byte [ ] input ) { return  Datatype Converter . print Base64 Binary ( input ) ; }
public boolean init Login ( ) { m_cc =  CConnection . get (  Adempiere . get Code Base Host ( ) ) ; host Field . set Value ( m_cc ) ; if (  Ini . is Property Bool (  Ini .  P_ VALIDATE_ CONNECTION_ ON_ STARTUP ) ) { validate Connection ( ) ; } user Text Field . set Text (  Ini . get Property (  Ini .  P_ UID ) ) ; if (  Ini . is Property Bool (  Ini .  P_ STORE_ PWD ) ) password Field . set Text (  Ini . get Property (  Ini .  P_ PWD ) ) ; else password Field . set Text ( _ STR ) ; language Combo . set Selected Item (  Ini . get Property (  Ini .  P_ LANGUAGE ) ) ; if (  Ini . is Property Bool (  Ini .  P_ A_ LOGIN ) ) { connection OK ( ) ; defaults OK ( ) ; if ( m_connection OK ) m_ok Pressed = _ BOOL ; return m_connection OK ; } return _ BOOL ; }
boolean create Snapshot (  String snapshot Name , boolean is Valid Lun Clone Snapshot , boolean async ) {  Na Element elem = new  Na Element ( _ STR ) ; elem . add New Child ( _ STR , name ) ; elem . add New Child ( _ STR , snapshot Name ) ; elem . add New Child ( _ STR ,  Boolean . to String ( async ) ) ; elem . add New Child ( _ STR ,  Boolean . to String ( is Valid Lun Clone Snapshot ) ) ; try { server . invoke Elem ( elem ) ; } catch (  Exception e ) {  String msg = _ STR + name ; log . error ( msg , e ) ; throw new  Net App Exception ( msg , e ) ; } return _ BOOL ; }
public final int store Session ( final  Session session , final boolean invalidate Active ) { if ( session == null ) {  Log . e (  TAG , _ STR ) ; return _ NUM ; } if ( invalidate Active ) { invalidate Active Sessions ( ) ; } final  Cursor cursor = content Resolver . query (  Content Uris . with Appended Id (  Content Provider .  CONTENT_ URI_ SESSION , session . get Id ( ) ) , null , null , null , null ) ; if ( ! cursor . move To Next ( ) ) { store Session ( session ) ; cursor . close ( ) ; return _ NUM ; } else {  Log . d (  TAG , _ STR + session . get Id ( ) ) ; final  Content Values values = new  Content Values ( ) ; values . put (  Schema .  COL_ CREATED_ AT , session . get Created At ( ) ) ; values . put (  Schema .  COL_ LAST_ UPDATED , session . get Last Updated ( ) ) ; values . put (  Schema .  COL_ DESCRIPTION , session . get Description ( ) ) ; values . put (  Schema .  COL_ HAS_ BEEN_ EXPORTED , session . has Been Exported ( ) ) ; values . put (  Schema .  COL_ IS_ ACTIVE , session . is Active ( ) ) ; values . put (  Schema .  COL_ NUMBER_ OF_ CELLS , session . get Cells Count ( ) ) ; values . put (  Schema .  COL_ NUMBER_ OF_ WIFIS , session . get Wifis Count ( ) ) ; values . put (  Schema .  COL_ NUMBER_ OF_ WAYPOINTS , session . get Waypoints Count ( ) ) ; cursor . close ( ) ; return content Resolver . update (  Content Provider .  CONTENT_ URI_ SESSION , values ,  Schema .  COL_ ID + _ STR , new  String [ ] {  String . value Of ( session . get Id ( ) ) } ) ; } }
public static  Map <  Integer ,  Properties > collect Properties (  Properties properties ) {  Map <  Integer ,  Properties > ret = new  Hash Map <  Integer ,  Properties > ( ) ; if ( properties != null ) { for (  String name : properties . string Property Names ( ) ) { int index = get Index ( name ) ; if ( index >= _ NUM ) {  Properties props = ret . get ( index ) ; if ( props == null ) { props = new  Properties ( ) ; ret . put ( index , props ) ; }  String new Name = drop Token ( name ) ; if ( new Name . length ( ) > _ NUM ) { props . set Property ( new Name , properties . get Property ( name ) ) ; } } } } return ret ; }
public  Builder delete Nick Name ( ) { delete Fields . add ( _ STR ) ; return this ; }
protected void process Play Request ( ) { try To Get Audio Focus ( ) ; if ( m State ==  State .  STOPPED ) { play Media ( ) ; } else if ( m State ==  State .  PAUSED ) { m State =  State .  PLAYING ; set Up As Foreground (  String . format ( get String (  R . string . media_state_playing ) , m File . get File Name ( ) ) ) ; config And Start Media Player ( ) ; } }
public  FSIDPAuthentication Context Info (  String info String ) throws  FSException { if ( info String == null ) { throw new  FSException ( _ STR , null ) ; }  String Tokenizer stk = new  String Tokenizer ( info String ,  IFSConstants .  ATTRIBUTE_ SEPARATOR ) ; while ( stk . has More Tokens ( ) ) {  String token = stk . next Token ( ) ; int equal Sign = token . index Of (  IFSConstants .  KEY_ VALUE_ SEPARATOR ) ; if ( equal Sign == - _ NUM ) { throw new  FSException ( _ STR , null ) ; } try {  String key = token . substring ( _ NUM , equal Sign ) ;  String value = token . substring ( equal Sign + _ NUM , token . length ( ) ) ; if ( key . equals Ignore Case (  IFSConstants .  AUTH_ CONTEXT_ NAME ) ) { authentication Context = value ; } else if ( key . equals Ignore Case (  IFSConstants .  MODULE_ INDICATOR_ KEY ) ) { module Indicator Key = value ; } else if ( key . equals Ignore Case (  IFSConstants .  MODULE_ INDICATOR_ VALUE ) ) { module Indicator Value = value ; } else if ( key . equals Ignore Case (  IFSConstants .  LEVEL ) ) { level =  Integer . parse Int ( value ) ; } else { throw new  FSException ( _ STR , null ) ; } } catch (  Index Out Of Bounds Exception ie ) { throw new  FSException ( _ STR , null ) ; } catch (  Number Format Exception ne ) { throw new  FSException ( _ STR , null ) ; } } if ( authentication Context == null || module Indicator Key == null || module Indicator Value == null || level == - _ NUM ) { throw new  FSException ( _ STR , null ) ; } }
static  Class Loader create Loader ( ) {  List <  URL > urls = new  Array List < > ( ) ; for (  String name : new  String [ ] { _ STR , _ STR } ) {  String value =  System . get Property ( name ) ; if ( value != null ) { add URLs From Path ( urls , value ) ; } } for ( int i = _ NUM ; add Patch Paths ( urls , i ) ; i ++ ) { } return new  URLClass Loader ( urls . to Array ( new  URL [ urls . size ( ) ] ) ) ; }
public long skip ( long n ) throws  IOException { return f Input Stream . skip ( n ) ; }
private  Point2 D _transform (  Point2 D graph Point ) { if ( graph Point == null ) return null ;  Point2 D view Center = get View Center ( ) ; double view Radius = get View Radius ( ) ; double ratio = get Ratio ( ) ;  Point2 D view Point = graph Point ; double dx = view Point . get X ( ) - view Center . get X ( ) ; double dy = view Point . get Y ( ) - view Center . get Y ( ) ; dx *= ratio ;  Point2 D point From Center = new  Point2 D .  Double ( dx , dy ) ;  Polar Point polar =  Polar Point . cartesian To Polar ( point From Center ) ; double theta = polar . get Theta ( ) ; double radius = polar . get Radius ( ) ; if ( radius > view Radius ) return view Point ; double mag =  Math . tan (  Math .  PI / _ NUM * magnification ) ; radius *= mag ; radius =  Math . min ( radius , view Radius ) ; radius /= view Radius ; radius *=  Math .  PI / _ NUM ; radius =  Math . abs (  Math . atan ( radius ) ) ; radius *= view Radius ;  Point2 D projected Point =  Polar Point . polar To Cartesian ( theta , radius ) ; projected Point . set Location ( projected Point . get X ( ) / ratio , projected Point . get Y ( ) ) ;  Point2 D translated Back = new  Point2 D .  Double ( projected Point . get X ( ) + view Center . get X ( ) , projected Point . get Y ( ) + view Center . get Y ( ) ) ; return translated Back ; }
public static  Gapless Info create From Comment (  String name ,  String data ) { if ( !  GAPLESS_ COMMENT_ ID . equals ( name ) ) { return null ; }  Matcher matcher =  GAPLESS_ COMMENT_ PATTERN . matcher ( data ) ; if ( matcher . find ( ) ) { try { int encoder Delay =  Integer . parse Int ( matcher . group ( _ NUM ) , _ NUM ) ; int encoder Padding =  Integer . parse Int ( matcher . group ( _ NUM ) , _ NUM ) ; return encoder Delay == _ NUM && encoder Padding == _ NUM ? null : new  Gapless Info ( encoder Delay , encoder Padding ) ; } catch (  Number Format Exception e ) { } } return null ; }
public void add Header (  String name ,  String value ) { if ( custom Headers == null ) { custom Headers = new  Hash Map < > ( _ NUM ) ; }  List <  String > header = custom Headers . get ( name ) ; if ( header == null ) { header = new  Array List < > ( ) ; custom Headers . put ( name , header ) ; } header . add ( value ) ; }
public  Matrix compute (  Matrix loghyper ,  Matrix  X ) { if ( loghyper . get Column Dimension ( ) != _ NUM || loghyper . get Row Dimension ( ) != num Parameters ( ) ) throw new  Illegal Argument Exception ( _ STR + loghyper . get Row Dimension ( ) + _ STR + num Parameters ( ) ) ; final double ell =  Math . exp ( loghyper . get ( _ NUM , _ NUM ) ) ; final double em2 = _ NUM / ( ell * ell ) ; final double oneplusem2 = _ NUM + em2 ; final double sf2 =  Math . exp ( _ NUM * loghyper . get ( _ NUM , _ NUM ) ) ; final double s2 =  Math . exp ( _ NUM * loghyper . get ( _ NUM , _ NUM ) ) ; final int m =  X . get Row Dimension ( ) ; final int n =  X . get Column Dimension ( ) ; double [ ] [ ] x =  X . get Array ( ) ; q = new double [ m ] [ m ] ; for ( int i = _ NUM ; i < m ; i ++ ) { for ( int j = _ NUM ; j < m ; j ++ ) { double t = _ NUM ; for ( int k = _ NUM ; k < n ; k ++ ) { t += x [ i ] [ k ] * x [ j ] [ k ] * em2 ; } q [ i ] [ j ] = t ; } } double [ ] dq = new double [ m ] ; for ( int i = _ NUM ; i < m ; i ++ ) { dq [ i ] =  Math . sqrt ( oneplusem2 + q [ i ] [ i ] ) ; }  Matrix  A = new  Matrix ( m , m ) ; k = new double [ m ] [ m ] ; double [ ] [ ] a =  A . get Array ( ) ; for ( int i = _ NUM ; i < m ; i ++ ) { final double dqi = dq [ i ] ; for ( int j = _ NUM ; j < m ; j ++ ) { final double t = ( em2 + q [ i ] [ j ] ) / ( dqi * dq [ j ] ) ; k [ i ] [ j ] = t ; a [ i ] [ j ] = sf2 *  Math . asin ( t ) ; } a [ i ] [ i ] += s2 ; } return  A ; }
public static  String convert String To Html (  String s ) { if ( s == null ) { return null ; } if ( s . length ( ) == _ NUM ) { return s ; }  String Builder buff = new  String Builder ( ) ; for ( int i = _ NUM ; i < s . length ( ) ; i ++ ) { char ch = s . char At ( i ) ;  String token =  CODE_ MAP . get ( ch ) ; if ( token == null ) { if ( ch < _ NUM ) { buff . append ( ch ) ; } else { buff . append ( _ STR ) ; buff . append ( _ STR ) ; buff . append ( ( int ) ch ) ; buff . append ( _ STR ) ; } } else { buff . append ( _ STR ) ; buff . append ( token ) ; buff . append ( _ STR ) ; } } return buff . to String ( ) ; }
public static int [ ] execute Batch (  Connection connection ,  String raw Sql Query , int parameters Per Batch ,  List <  Object > parameters ) throws  SQLException {  Preconditions . check Argument ( parameters . size ( ) % parameters Per Batch == _ NUM ) ;  Prepared Statement stmt = null ; try { stmt = connection . prepare Statement ( raw Sql Query ) ; int num Batches = parameters . size ( ) / parameters Per Batch ; for ( int batch = _ NUM ; batch < num Batches ; batch ++ ) { for ( int param = _ NUM ; param < parameters Per Batch ; param ++ ) {  Jdbc Utils . bind Parameter ( stmt , param + _ NUM , parameters . get ( batch * parameters Per Batch + param ) ) ; } stmt . add Batch ( ) ; } return stmt . execute Batch ( ) ; } finally {  Jdbc Utils . close Statement ( stmt ) ; } }
public final  T end ( int i ) { while ( i -- > _ NUM && ! tag Stack . is Empty ( ) ) { end ( ) ; } return get Self ( ) ; }
public  Replication Job create Job For Drop Table ( long audit Log Id , long audit Log Entry Create Time ,  Table table ) throws  State Update Exception {  Replication Operation replication Operation =  Replication Operation .  DROP_ TABLE ;  Map <  String ,  String > extras = new  Hash Map < > ( ) ; extras . put (  Persisted Job Info .  AUDIT_ LOG_ ID_ EXTRAS_ KEY ,  Long . to String ( audit Log Id ) ) ; extras . put (  Persisted Job Info .  AUDIT_ LOG_ ENTRY_ CREATE_ TIME_ KEY ,  Long . to String ( audit Log Entry Create Time ) ) ;  Hive Object Spec table Spec = new  Hive Object Spec ( table ) ;  Persisted Job Info persisted Job Info = job Info Store . resilient Create ( replication Operation ,  Replication Status .  PENDING ,  Replication Utils . get Location ( table ) , src Cluster . get Name ( ) , table Spec ,  Collections . empty List ( ) ,  Replication Utils . get Tldt ( table ) ,  Optional . empty ( ) ,  Optional . empty ( ) , extras ) ; return new  Replication Job ( conf , new  Drop Table Task ( src Cluster , dest Cluster , table Spec ,  Replication Utils . get Tldt ( table ) ) , on State Change Handler , persisted Job Info ) ; }
public final  String encode ( ) {  String Buffer buffer = new  String Buffer ( ) ;  Default Alignment alignment Default = is Horizontal ( ) ?  Column Spec .  DEFAULT :  Row Spec .  DEFAULT ; if ( ! alignment Default . equals ( default Alignment ) ) { buffer . append ( default Alignment . abbreviation ( ) ) ; buffer . append ( _ STR ) ; } buffer . append ( size . encode ( ) ) ; if ( resize Weight ==  NO_ GROW ) { } else if ( resize Weight ==  DEFAULT_ GROW ) { buffer . append ( _ STR ) ; buffer . append ( _ STR ) ; } else { buffer . append ( _ STR ) ; buffer . append ( _ STR ) ; buffer . append ( resize Weight ) ; buffer . append ( _ STR ) ; } return buffer . to String ( ) ; }
public  List <  T > find All ( ) throws  Data Access Exception {  Dynamo DBScan Expression dynamo DBScan Expression = new  Dynamo DBScan Expression ( ) ;  Dynamo DBMapper Config config = new  Dynamo DBMapper Config (  Dynamo DBMapper Config .  Pagination Loading Strategy .  EAGER_ LOADING ) ;  Paginated Scan List <  T > paginated Scan List = dynamo DBMapper . scan ( get Type ( ) , dynamo DBScan Expression , config ) ; paginated Scan List . load All Results ( ) ;  List <  T > list = new  Array List <  T > ( paginated Scan List . size ( ) ) ;  Iterator <  T > iterator = paginated Scan List . iterator ( ) ; while ( iterator . has Next ( ) ) {  T element = iterator . next ( ) ; list . add ( element ) ; } return list ; }
@  Override public void draw Item (  Graphics2 D g2 ,  XYItem Renderer State state ,  Rectangle2 D data Area ,  Plot Rendering Info info ,  XYPlot plot ,  Value Axis domain Axis ,  Value Axis range Axis ,  XYDataset dataset , int series , int item ,  Crosshair State crosshair State , int pass ) { if ( ! get Item Visible ( series , item ) ) { return ; } double x = dataset . get XValue ( series , item ) ; double y = dataset . get YValue ( series , item ) ; double adjx = ( this . dot Width - _ NUM ) / _ NUM ; double adjy = ( this . dot Height - _ NUM ) / _ NUM ; if ( !  Double . is Na N ( y ) ) {  Rectangle Edge x Axis Location = plot . get Domain Axis Edge ( ) ;  Rectangle Edge y Axis Location = plot . get Range Axis Edge ( ) ; double trans X = domain Axis . value To Java2 D ( x , data Area , x Axis Location ) - adjx ; double trans Y = range Axis . value To Java2 D ( y , data Area , y Axis Location ) - adjy ; g2 . set Paint ( get Item Paint ( series , item ) ) ;  Plot Orientation orientation = plot . get Orientation ( ) ; if ( orientation ==  Plot Orientation .  HORIZONTAL ) { g2 . fill Rect ( ( int ) trans Y , ( int ) trans X , this . dot Height , this . dot Width ) ; } else if ( orientation ==  Plot Orientation .  VERTICAL ) { g2 . fill Rect ( ( int ) trans X , ( int ) trans Y , this . dot Width , this . dot Height ) ; } int domain Axis Index = plot . get Domain Axis Index ( domain Axis ) ; int range Axis Index = plot . get Range Axis Index ( range Axis ) ; update Crosshair Values ( crosshair State , x , y , domain Axis Index , range Axis Index , trans X , trans Y , orientation ) ; } }
public void write Field (  String name , double value ) throws java . io .  IOException { write Field ( name ,  Double . to String ( value ) ) ; }
public void remove Players Monsters ( ) { for ( final  Creature creature : spawned Creatures ) { final  Stendhal RPZone monster Zone = creature . get Zone ( ) ; if ( monster Zone != null ) { monster Zone . remove ( creature ) ; } } }
public void before (  Property Info Rest Rep old Props ,  Property Info Rest Rep new Props ) { if ( ! is Property Changed ( old Props , new Props , _property Name ) ) { return ; }  String new Value = new Props . get Property ( _property Name ) ;  Argument Validator . check Range (  Integer . parse Int ( new Value ) ,  Constants .  MIN_ AUTH_ LOCKOUT_ TIME_ IN_ MINUTES ,  Constants .  MAX_ AUTH_ LOCKOUT_ TIME_ IN_ MINUTES , _property Name ) ; }
@  Override @  Graph Transaction public void delete Trait (  String guid ,  String trait Name To Be Deleted ) throws  Trait Not Found Exception ,  Entity Not Found Exception ,  Repository Exception {  LOG . debug ( _ STR , trait Name To Be Deleted , guid ) ;  Atlas Vertex instance Vertex = graph Helper . get Vertex For GUID ( guid ) ;  List <  String > trait Names =  Graph Helper . get Trait Names ( instance Vertex ) ; if ( ! trait Names . contains ( trait Name To Be Deleted ) ) { throw new  Trait Not Found Exception ( _ STR + trait Name To Be Deleted + _ STR + guid ) ; } try { final  String entity Type Name =  Graph Helper . get Type Name ( instance Vertex ) ;  String relationship Label =  Graph Helper . get Trait Label ( entity Type Name , trait Name To Be Deleted ) ;  Atlas Edge edge = graph Helper . get Edge For Label ( instance Vertex , relationship Label ) ; if ( edge != null ) { delete Handler . delete Edge Reference ( edge ,  Data Types .  Type Category .  TRAIT , _ BOOL , _ BOOL ) ; trait Names . remove ( trait Name To Be Deleted ) ; update Traits ( instance Vertex , trait Names ) ; } } catch (  Exception e ) { throw new  Repository Exception ( e ) ; } }
public void add Foreign Keys (  Collection <  Foreign Key > foreign Keys ) { for (  Iterator <  Foreign Key > it = foreign Keys . iterator ( ) ; it . has Next ( ) ; ) { add Foreign Key ( (  Foreign Key ) it . next ( ) ) ; } }
void save Offset In External Store (  String topic , int partition , long offset ) { try {  File Writer writer = new  File Writer ( storage Name ( topic , partition ) , _ BOOL ) ;  Buffered Writer buffered Writer = new  Buffered Writer ( writer ) ; buffered Writer . write ( offset + _ STR ) ; buffered Writer . flush ( ) ; buffered Writer . close ( ) ; } catch (  Exception e ) { e . print Stack Trace ( ) ; throw new  Runtime Exception ( e ) ; } }
public static  String slurp URLNo Exceptions (  URL u ) { try { return slurp URL ( u ) ; } catch (  Exception e ) { e . print Stack Trace ( ) ; return null ; } }
public  Isolated Class Loader delete Loader ( ) {  Isolated Class Loader l = loader ; if ( loader != null ) { loader . clear ( ) ; } loader = null ; return l ; }
void remove Item ( final  Rounded Tool Item rounded Tool Item ) { check Widget ( ) ; items . remove ( rounded Tool Item ) ; }
public void add Attribute (  String alias ,  String type Uri ,  String value ) throws  Message Exception { if ( alias . index Of ( _ STR ) > - _ NUM || alias . index Of ( _ STR ) > - _ NUM || alias . index Of ( _ STR ) > - _ NUM || alias . index Of ( _ STR ) > - _ NUM ) throw new  Message Exception ( _ STR + alias ) ; int count = get Count ( alias ) ;  String index = _ STR ; switch ( count ) { case _ NUM : _parameters . set ( new  Parameter ( _ STR + alias , type Uri ) ) ; break ; case _ NUM : _parameters . set ( new  Parameter ( _ STR + alias + _ STR , get Parameter Value ( _ STR + alias ) ) ) ; _parameters . remove Parameters ( _ STR + alias ) ; index = _ STR ; break ; default : index = _ STR +  Integer . to String ( count + _ NUM ) ; } _parameters . set ( new  Parameter ( _ STR + alias + index , value ) ) ; set Count ( alias , ++ count ) ; if (  DEBUG ) _log . debug ( _ STR + type Uri + _ STR + alias + _ STR + count ) ; }
protected void execute Tasks ( final  Access Path Task [ ] tasks ) throws  Exception { if ( executor == null ) { for (  Access Path Task task : tasks ) { task . call ( ) ; } return ; } final  List <  Future Task <  Void > > future Tasks = new  Linked List <  Future Task <  Void > > ( ) ; for (  Access Path Task task : tasks ) { final  Future Task <  Void > ft = new  Future Task <  Void > ( task ) ; future Tasks . add ( ft ) ; } try { for (  Future Task <  Void > ft : future Tasks ) { if ( halt ) throw new  Runtime Exception ( first Cause . get ( ) ) ; executor . execute ( ft ) ; } for (  Future Task <  Void > ft : future Tasks ) { if ( ! halt ) ft . get ( ) ; } } finally { for (  Future Task <  Void > ft : future Tasks ) { ft . cancel ( _ BOOL ) ; } } }
public void encode Params ( ) { for (  Map .  Entry <  String ,  String > e : params . entry Set ( ) ) { try { params . put ( e . get Key ( ) ,  URLEncoder . encode ( e . get Value ( ) , _ STR ) ) ; } catch (  Unsupported Encoding Exception e1 ) { e1 . print Stack Trace ( ) ; } } }
static private  String user Id From Range With Mod (  String [ ] values , boolean include ) { int min Id =  Integer . parse Int ( values [ _ NUM ] ) ; int max Id =  Integer . parse Int ( values [ _ NUM ] ) ; int mod =  Integer . parse Int ( values [ _ NUM ] ) ;  Stack <  Integer > stack = get Stack With Mods ( min Id , max Id , mod , include ) ; if ( stack . size ( ) > _ NUM ) { return  Integer . to String ( stack . pop ( ) ) ; } throw new  Illegal Argument Exception ( _ STR ) ; }
public boolean wait Until Started ( int timeout ) { int cnt = _ NUM ; while ( cnt < timeout ) { if ( is Started ( ) ) { log . info ( _ STR ) ; return _ BOOL ; } sleep ( _ NUM ) ; cnt ++ ; } return _ BOOL ; }
public static void write Parity Flag ( final  ITranslation Environment environment , final long offset , final  Operand Size result Size , final  String result , final  List <  Reil Instruction > instructions ) throws  Illegal Argument Exception {  Preconditions . check Not Null ( environment , _ STR ) ;  Preconditions . check Not Null ( result Size , _ STR ) ;  Preconditions . check Not Null ( result , _ STR ) ;  Preconditions . check Not Null ( instructions , _ STR ) ; final  String temp Reg = environment . get Next Variable String ( ) ; instructions . add (  Reil Helpers . create Str ( offset , result Size , result , result Size , temp Reg ) ) ; instructions . add (  Reil Helpers . create Bsh ( offset + _ NUM , result Size , temp Reg ,  Operand Size .  BYTE , _ STR , result Size ,  Helpers .  PARITY_ FLAG ) ) ; instructions . add (  Reil Helpers . create Xor ( offset + _ NUM , result Size , temp Reg , result Size ,  Helpers .  PARITY_ FLAG , result Size ,  Helpers .  PARITY_ FLAG ) ) ; instructions . add (  Reil Helpers . create And ( offset + _ NUM , result Size ,  Helpers .  PARITY_ FLAG , result Size ,  String . value Of ( _ NUM ) ,  Operand Size .  WORD ,  Helpers .  PARITY_ FLAG ) ) ; instructions . add (  Reil Helpers . create Bsh ( offset + _ NUM ,  Operand Size .  WORD ,  String . value Of ( _ NUM ) ,  Operand Size .  WORD ,  Helpers .  PARITY_ FLAG ,  Operand Size .  WORD ,  Helpers .  PARITY_ FLAG ) ) ; instructions . add (  Reil Helpers . create And ( offset + _ NUM ,  Operand Size .  WORD ,  Helpers .  PARITY_ FLAG ,  Operand Size .  WORD ,  String . value Of ( _ NUM ) ,  Operand Size .  WORD ,  Helpers .  PARITY_ FLAG ) ) ; instructions . add (  Reil Helpers . create Bsh ( offset + _ NUM ,  Operand Size .  WORD ,  Helpers .  PARITY_ FLAG ,  Operand Size .  BYTE , _ STR ,  Operand Size .  BYTE ,  Helpers .  PARITY_ FLAG ) ) ; }
@  Override public void apply (  Nexus Stream Parser np ) throws  Exception { np . match Ignore Case ( get Syntax ( ) ) ; if ( get Parent ( ) instanceof  Overlap Graph Viewer ) { final  Overlap Graph Viewer overlap Graph Viewer = (  Overlap Graph Viewer ) get Parent ( ) ; final  Graph View graph View = overlap Graph Viewer . get Graph View ( ) ; final  Node Map <  String > node2 Read Name Map = overlap Graph Viewer . get Node2 Read Name Map ( ) ; final  Set <  String > previous Selection =  Project Manager . get Previously Selected Node Labels ( ) ; if ( previous Selection . size ( ) > _ NUM ) {  Graph graph = graph View . get Graph ( ) ;  Node Set to Select = new  Node Set ( graph ) ; for (  Node v = graph . get First Node ( ) ; v != null ; v = graph . get Next Node ( v ) ) {  String label = node2 Read Name Map . get ( v ) ; if ( label != null && previous Selection . contains ( label ) ) to Select . add ( v ) ; } if ( to Select . size ( ) > _ NUM ) { graph View . set Selected ( to Select , _ BOOL ) ; graph View . repaint ( ) ; } } } }
public static boolean contains Type Parameter (  Type type ) { if ( type . is Type Parameter ( ) ) return _ BOOL ; for (  Type pt : type . get Type Argument List ( ) ) { if ( contains Type Parameter ( pt ) ) { return _ BOOL ; } } if ( type . is Intersection ( ) ) {  List <  Type > types = type . get Satisfied Types ( ) ; for ( int i = _ NUM , l = types . size ( ) ; i < l ; i ++ ) { if ( contains Type Parameter ( types . get ( i ) ) ) return _ BOOL ; } return _ BOOL ; } if ( type . is Union ( ) ) {  List <  Type > types = type . get Case Types ( ) ; for ( int i = _ NUM , l = types . size ( ) ; i < l ; i ++ ) { if ( contains Type Parameter ( types . get ( i ) ) ) return _ BOOL ; } return _ BOOL ; } return _ BOOL ; }
public static void load Excludes Resource (  String resource Name ) throws  IOException { excludes . clear ( ) ; excludes . put All ( load Properties From Resource ( resource Name ) ) ; }
public static void safe Close Stream (  Output Stream out ) { if ( out != null ) { try { out . close ( ) ; } catch (  Exception e ) { log . error ( e . get Message ( ) , e ) ; } } }
public static  Stream <  Transaction > stream Self And All Transactions ( final  Transaction transaction ) { final  List <  Transaction > all Transactions = new  Array List < > ( ) ; all Transactions . add ( transaction ) ; add Transactions Recursive ( all Transactions , transaction . get Child Transactions ( ) ) ; return all Transactions . stream ( ) ; }
public char skip Until (  String skip ) throws  IOException { char ch ; do { ch = read Character ( ) ; } while ( skip . index Of ( ch ) == - _ NUM ) ; return ch ; }
private boolean contains Mapping (  Object key ,  Object value ) { if ( key == null ) {  Hash Map Entry <  K ,  V > e = entry For Null Key ; return e != null &&  Objects . equals ( value , e . value ) ; } int hash = secondary Hash ( key ) ;  Hash Map Entry <  K ,  V > [ ] tab = table ; int index = hash & ( tab . length - _ NUM ) ; for (  Hash Map Entry <  K ,  V > e = tab [ index ] ; e != null ; e = e . next ) { if ( e . hash == hash && key . equals ( e . key ) ) { return  Objects . equals ( value , e . value ) ; } } return _ BOOL ; }
public void sync Download Poi Box ( final  Box box ) { if (  Flavor Utils . is Poi Storage ( ) ) { sync Download Poi Types ( ) ; }  List <  Poi > pois = backend . get Pois In Box ( box ) ; if ( pois . size ( ) > _ NUM ) {  Timber . d ( _ STR , pois . size ( ) ) ; poi Manager . merge From Osm Pois ( pois , box ) ; } else {  Timber . d ( _ STR ) ; } }
private void create Element (  Document doc ,  Element parent Element ,  String element Name , int value ) {  Element element = doc . create Element ( element Name ) ; element . append Child ( doc . create Text Node (  Integer . to String ( value ) ) ) ; parent Element . append Child ( element ) ; }
public static void to Do ( @  Scope int scope ,  String tag ) {  List <  Long > tag Seen List = tag Last Seen Map . get ( tag ) ; if ( tag Seen List . is Empty ( ) ) { to Do Set . put ( tag ) ; return ; }  Long tag Last Seen = tag Seen List . get ( tag Seen List . size ( ) - _ NUM ) ; if ( scope ==  THIS_ APP_ VERSION && tag Last Seen <= last App Updated Time ) { to Do Set . put ( tag ) ; } }
void variable Negation Changed ( int row ,  String oper ) {  Conditional Variable variable = _variable List . get ( row ) ; boolean state = variable . is Negated ( ) ; if ( oper == null ) { variable . set Negation ( _ BOOL ) ; } else { variable . set Negation ( oper . equals (  Bundle . get Message ( _ STR ) ) ) ; } if ( variable . is Negated ( ) != state ) { make Antecedent ( ) ; } }
private static void analyze String Sets (  String Set a ,  String Set b ,  String name ,  Hash Map <  String ,  Change > changes ) { if ( a != null ) {  Iterator <  String > iter = a . iterator ( ) ; while ( iter . has Next ( ) ) {  String val = iter . next ( ) ; if ( b != null && b . contains ( val ) ) { continue ; }  String key = name + _ STR + val ;  Change change = new  Change ( key , val , null , name ) ; changes . put ( key , change ) ; } } if ( b != null ) {  Iterator <  String > iter = b . iterator ( ) ; while ( iter . has Next ( ) ) {  String val = iter . next ( ) ; if ( a != null && a . contains ( val ) ) { continue ; }  String key = name + _ STR + val ;  Change change = new  Change ( key , null , val , name ) ; changes . put ( key , change ) ; } } }
public boolean add Callback (  Uri uri ,  Item Loaded Callback callback ) { if (  Log . is Loggable (  TAG ,  Log .  DEBUG ) ) {  Log . d (  TAG , _ STR + callback ) ; } if ( uri == null ) { throw new  Null Pointer Exception ( _ STR ) ; } if ( callback == null ) { throw new  Null Pointer Exception ( _ STR ) ; }  Set <  Item Loaded Callback > callbacks = m Callbacks . get ( uri ) ; if ( callbacks == null ) { callbacks = new  Hash Set <  Item Loaded Callback > ( _ NUM ) ; m Callbacks . put ( uri , callbacks ) ; } callbacks . add ( callback ) ; return _ BOOL ; }
View find Hidden Non Removed View ( int position , int type ) { final int count = m Hidden Views . size ( ) ; for ( int i = _ NUM ; i < count ; i ++ ) { final  View view = m Hidden Views . get ( i ) ;  Recycler View .  View Holder holder = m Callback . get Child View Holder ( view ) ; if ( holder . get Position ( ) == position && ! holder . is Invalid ( ) && ( type ==  Recycler View .  INVALID_ TYPE || holder . get Item View Type ( ) == type ) ) { return view ; } } return null ; }
public static boolean delete Recursive (  File file Or Directory ) { if ( file Or Directory . is Directory ( ) ) {  File [ ] list = file Or Directory . list Files ( ) ; if ( list == null ) { return _ BOOL ; } for (  File f : list ) { if ( ! delete Recursive ( f ) ) { return _ BOOL ; } } } if ( ! file Or Directory . delete ( ) ) { if ( file Or Directory . exists ( ) ) { return _ BOOL ; } } return _ BOOL ; }
private void burrow Cave (  Point point ,  Layer Definition layer ) {  Queue <  Point > branch Points = new  Linked List <  Point > ( ) ;  Hash Set <  Point > visited = new  Hash Set <  Point > ( ) ; branch Points . add ( point ) ;  List <  Point > neighbours = get Unvisited Neighbours ( point , visited ) ; do { visited . add ( point ) ; if ( neighbours . size ( ) > _ NUM ) {  Point next =  Rand . rand ( neighbours ) ; branch Points . add ( next ) ; int diffx =  Integer . signum ( next . x - point . x ) ; int diffy =  Integer . signum ( next . y - point . y ) ; for ( int i = _ NUM ; i <=  WALL_ THICKNESS ; i ++ ) { set Collide ( layer , point . x + i * diffx , point . y + i * diffy , _ BOOL ) ; } point = next ; } else { point = branch Points . poll ( ) ; } neighbours = get Unvisited Neighbours ( point , visited ) ; } while ( point != null ) ; }
private  Priority Queue <  Score Term > create Queue (  Map <  String ,  Int > words ,  String ... field Names ) throws  IOException { int num Docs = ir . num Docs ( ) ; final int limit =  Math . min ( max Query Terms , words . size ( ) ) ;  Freq Q queue = new  Freq Q ( limit ) ; for (  String word : words . key Set ( ) ) { int tf = words . get ( word ) . x ; if ( min Term Freq > _ NUM && tf < min Term Freq ) { continue ; }  String top Field = field Names [ _ NUM ] ; int doc Freq = _ NUM ; for (  String field Name : field Names ) { int freq = ir . doc Freq ( new  Term ( field Name , word ) ) ; top Field = ( freq > doc Freq ) ? field Name : top Field ; doc Freq = ( freq > doc Freq ) ? freq : doc Freq ; } if ( min Doc Freq > _ NUM && doc Freq < min Doc Freq ) { continue ; } if ( doc Freq > max Doc Freq ) { continue ; } if ( doc Freq == _ NUM ) { continue ; } float idf = similarity . idf ( doc Freq , num Docs ) ; float score = tf * idf ; if ( queue . size ( ) < limit ) { queue . add ( new  Score Term ( word , top Field , score , idf , doc Freq , tf ) ) ; } else {  Score Term term = queue . top ( ) ; if ( term . score < score ) { term . update ( word , top Field , score , idf , doc Freq , tf ) ; queue . update Top ( ) ; } } } return queue ; }
@  Suppress Warnings ( _ STR ) public static <  Value T >  Value T to Object (  Byte Buffer bf ) throws  IOException ,  Class Not Found Exception {  Object obj = null ;  Input Stream is = null ;  Object Input Stream ois = null ; try { is = new  Byte Buffer Backed Input Stream ( bf ) ; ois = new  Object Input Stream ( is ) ; obj = ois . read Object ( ) ; } finally { if ( is != null ) { is . close ( ) ; } if ( ois != null ) { ois . close ( ) ; } } return (  Value T ) obj ; }
public static void system Exit ( int status ) {  System . exit ( status ) ; }
public static  Lat Lng translate Point (  Lat Lng point , double distance , double bearing ) { distance = distance / _ NUM ; double lat =  Math . to Radians ( point . latitude ) ; double lng =  Math . to Radians ( point . longitude ) ; bearing =  Math . to Radians ( bearing ) ; double  Lat2 =  Math . asin ( (  Math . sin ( lat ) *  Math . cos ( distance /  EARTH ) ) + (  Math . cos ( lat ) *  Math . sin ( distance /  EARTH ) *  Math . cos ( bearing ) ) ) ; double  Long2 = lng +  Math . atan2 (  Math . sin ( bearing ) *  Math . sin ( distance /  EARTH ) *  Math . cos ( lat ) ,  Math . cos ( distance /  EARTH ) - (  Math . sin ( lat ) *  Math . sin (  Lat2 ) ) ) ;  Lat2 =  Math . to Degrees (  Lat2 ) ;  Long2 =  Math . to Degrees (  Long2 ) ; return new  Lat Lng (  Lat2 ,  Long2 ) ; }
@  Override public void process Challenge ( final  String challenge ) throws  Malformed Challenge Exception { final  String s =  Auth Challenge Parser . extract Scheme ( challenge ) ; if ( ! s . equals Ignore Case ( get Scheme Name ( ) ) ) { throw new  Malformed Challenge Exception ( _ STR + get Scheme Name ( ) + _ STR + challenge ) ; } params =  Auth Challenge Parser . extract Params ( challenge ) ; }
public static  Big Integer calculate Gx (  Big Integer p ,  Big Integer g ,  Big Integer x ) { return g . mod Pow ( x , p ) ; }
public static boolean create Shipment (  MAcct Schema as , int  AD_ Org_ ID , int  M_ Product_ ID , int  M_ Attribute Set Instance_ ID , int  M_ In Out Line_ ID , int  M_ Cost Element_ ID ,  Big Decimal  Amt ,  Big Decimal  Qty ,  String  Description , boolean  Is SOTrx ,  String trx Name ) {  String sql = _ STR + _ STR + _ STR +  M_ In Out Line_ ID + _ STR + as . get C_ Acct Schema_ ID ( ) + _ STR +  M_ Attribute Set Instance_ ID ; int no =  DB . execute Update ( sql , trx Name ) ; if ( no != _ NUM ) s_log . config ( _ STR + no ) ;  MCost Detail cd = get ( as . get Ctx ( ) , _ STR ,  M_ In Out Line_ ID ,  M_ Attribute Set Instance_ ID , as . get C_ Acct Schema_ ID ( ) , trx Name ) ; if ( cd == null ) { cd = new  MCost Detail ( as ,  AD_ Org_ ID ,  M_ Product_ ID ,  M_ Attribute Set Instance_ ID ,  M_ Cost Element_ ID ,  Amt ,  Qty ,  Description , trx Name ) ; cd . set M_ In Out Line_ ID (  M_ In Out Line_ ID ) ; cd . set Is SOTrx (  Is SOTrx ) ; } else { cd . set Delta Amt (  Amt . subtract ( cd . get Amt ( ) ) ) ; cd . set Delta Qty (  Qty . subtract ( cd . get Qty ( ) ) ) ; if ( cd . is Delta ( ) ) { cd . set Processed ( _ BOOL ) ; cd . set Amt (  Amt ) ; cd . set Qty (  Qty ) ; } else return _ BOOL ; } boolean ok = cd . save ( ) ; if ( ok && ! cd . is Processed ( ) ) {  MClient client =  MClient . get ( as . get Ctx ( ) , as . get AD_ Client_ ID ( ) ) ; if ( client . is Cost Immediate ( ) ) cd . process ( ) ; } s_log . config ( _ STR + ok + _ STR + cd ) ; return ok ; }
private void seeking Write All (  Table Id table ,  List <  Insert All Request .  Row To Insert > elements ,  String topic ,  Set <  Schema > schemas ) throws  Big Query Connect Exception ,  Interrupted Exception { logger . debug ( _ STR ) ; int current Index = _ NUM ; int successful Call Count = _ NUM ; while ( current Index < elements . size ( ) ) { int end Index =  Math . min ( current Index + current Batch Size , elements . size ( ) ) ;  List <  Insert All Request .  Row To Insert > current Batch Elements = elements . sub List ( current Index , end Index ) ; try { writer . write Rows ( table , current Batch Elements , topic , schemas ) ; successful Call Count ++ ; current Index = end Index ; if ( current Batch Size ==  MAXIMUM_ BATCH_ SIZE ) { seeking = _ BOOL ; logger . debug ( _ STR , current Batch Size ) ; established Write All ( table , elements . sub List ( current Index , elements . size ( ) ) , topic , schemas ) ; return ; } if ( current Index < elements . size ( ) ) { increase Batch Size ( table ) ; } } catch (  Big Query Exception exception ) { if ( is Batch Size Error ( exception ) ) { decrease Batch Size ( table ) ; if ( successful Call Count > _ NUM ) { seeking = _ BOOL ; logger . debug ( _ STR , current Batch Size ) ; established Write All ( table , elements . sub List ( current Index , elements . size ( ) ) , topic , schemas ) ; return ; } } else { throw new  Big Query Connect Exception (  String . format ( _ STR , table ) , exception ) ; } } } if ( successful Call Count == _ NUM ) { seeking = _ BOOL ; logger . debug ( _ STR , current Batch Size ) ; } }
static double evaluate (  Problem problem ,  Nondominated Population approximation Set ) { boolean is Inverted = _ BOOL ; boolean is Custom Hypervolume = (  Settings . get Hypervolume ( ) != null ) && ( problem . get Number Of Objectives ( ) > _ NUM ) ; if ( is Custom Hypervolume ) { is Inverted =  Settings . is Hypervolume Inverted ( ) ; }  List <  Solution > solutions = new  Array List <  Solution > ( ) ; for (  Solution solution : approximation Set ) { for ( int i = _ NUM ; i < solution . get Number Of Objectives ( ) ; i ++ ) { if ( solution . get Objective ( i ) > _ NUM ) { continue ; } }  Solution clone = solution . copy ( ) ; if ( is Inverted ) { invert ( problem , clone ) ; } solutions . add ( clone ) ; } if ( is Custom Hypervolume ) { return invoke Native Hypervolume ( problem , solutions , is Inverted ) ; } else { return calculate Hypervolume ( solutions , solutions . size ( ) , problem . get Number Of Objectives ( ) ) ; } }
public  List <  Snapshot > snapshots (  String repository Name ) {  Set <  Snapshot > snapshot Set = new Hash Set ( ) ;  List <  Snapshots In Progress .  Entry > entries = current Snapshots ( repository Name , null ) ; for (  Snapshots In Progress .  Entry entry : entries ) { snapshot Set . add ( in Progress Snapshot ( entry ) ) ; }  Repository repository = repositories Service . repository ( repository Name ) ;  List <  Snapshot Id > snapshot Ids = repository . snapshots ( ) ; for (  Snapshot Id snapshot Id : snapshot Ids ) { snapshot Set . add ( repository . read Snapshot ( snapshot Id ) ) ; }  Array List <  Snapshot > snapshot List = new  Array List < > ( snapshot Set ) ;  Collection Util . tim Sort ( snapshot List ) ; return  Collections . unmodifiable List ( snapshot List ) ; }
protected  Class Node infer Return Type Generics (  Class Node receiver ,  Method Node method ,  Expression arguments ) { return infer Return Type Generics ( receiver , method , arguments , null ) ; }
@  Override protected void paint Text (  Graphics temp G , int tab Placement ,  Font font ,  Font Metrics metrics , int tab Index ,  String title ,  Rectangle text Rect , boolean is Selected ) {  Graphics2 D g = (  Graphics2 D ) temp G ; g . set Rendering Hint (  Rendering Hints .  KEY_ ANTIALIASING ,  Rendering Hints .  VALUE_ ANTIALIAS_ ON ) ; if ( is Selected && tab Placement ==  TOP ) { g . set Color (  Color .  BLACK ) ; } else { g . set Color (  Color .  BLACK ) ; } g . draw String ( title , text Rect . x , text Rect . y + metrics . get Ascent ( ) ) ; }
public  Frontier Query build Frontier Query (  Bytes Ref Hash collector Terms ,  Integer frontier Size ) { if ( collector Terms == null || collector Terms . size ( ) == _ NUM ) { return null ; } else {  Query q = null ; if ( use Autn ) {  Automaton autn = build Automaton ( collector Terms ) ;  Automaton Query autn Query = new  Automaton Query ( new  Term ( from Field ) , autn ) ; q = autn Query ; } else {  List <  Bytes Ref > term List = new  Array List < > ( collector Terms . size ( ) ) ; for ( int i = _ NUM ; i < collector Terms . size ( ) ; i ++ ) {  Bytes Ref ref = new  Bytes Ref ( ) ; collector Terms . get ( i , ref ) ; term List . add ( ref ) ; } q = new  Terms Query ( from Field , term List ) ; } if ( traversal Filter != null ) {  Boolean Query .  Builder builder = new  Boolean Query .  Builder ( ) ; builder . add ( q ,  Occur .  MUST ) ; builder . add ( traversal Filter ,  Occur .  MUST ) ; q = builder . build ( ) ; }  Frontier Query frontier = new  Frontier Query ( q , frontier Size ) ; return frontier ; } }
protected  Range find Domain Bounds (  XYDataset dataset , boolean include Interval ) { if ( dataset == null ) { return null ; } if ( get Data Bounds Includes Visible Series Only ( ) ) {  List visible Series Keys = new  Array List ( ) ; int series Count = dataset . get Series Count ( ) ; for ( int s = _ NUM ; s < series Count ; s ++ ) { if ( is Series Visible ( s ) ) { visible Series Keys . add ( dataset . get Series Key ( s ) ) ; } } return  Dataset Utilities . find Domain Bounds ( dataset , visible Series Keys , include Interval ) ; } return  Dataset Utilities . find Domain Bounds ( dataset , include Interval ) ; }
public synchronized void shutdown ( ) { if ( server != null ) { try { server . shutdown ( ) ;  LOGGER . info ( _ STR , broker Id , get Connection ( ) ) ; } finally { server = null ; port = desired Port ; } } }
public void remove Role (  AMRole role ) throws  AMException ,  SSOException { remove Role ( role . get DN ( ) ) ; }
protected void write Change Record ( ) throws  IOException { boolean has New Styles = has Style && ( fill Styles . size ( ) > _ NUM || line Styles . size ( ) > _ NUM ) ; boolean has Move To = ( move XY != null ) ; boolean has Fill Style0 = fill0 Index >= _ NUM ; boolean has Fill Style1 = fill1 Index >= _ NUM ; boolean has Line Style = line Index >= _ NUM ; if ( ( ! has Style ) && has Fill Style0 ) { has Fill Style1 = _ BOOL ; } if ( has New Styles ) { out . write UBits ( _ NUM , _ NUM ) ; out . write UBits ( _ NUM , _ NUM ) ; out . write UBits ( _ NUM , _ NUM ) ; out . write UBits ( _ NUM , _ NUM ) ; out . write UBits ( _ NUM , _ NUM ) ; out . write UBits ( _ NUM , _ NUM ) ; write Move XY ( _ NUM , _ NUM ) ; out . write UBits ( fill Bits , _ NUM ) ; out . write UBits ( fill Bits , _ NUM ) ; out . write UBits ( line Bits , _ NUM ) ; if ( fill0 Index == _ NUM ) { fill0 Index = - _ NUM ; } if ( fill1 Index == _ NUM ) { fill1 Index = - _ NUM ; } if ( line Index == _ NUM ) { line Index = - _ NUM ; } fill Bits =  Out Stream . determine Unsigned Bit Size ( fill Styles . size ( ) ) ; line Bits =  Out Stream . determine Unsigned Bit Size ( line Styles . size ( ) ) ; write Styles ( fill Styles ) ; write Styles ( line Styles ) ; out . write UBits ( _ NUM , fill Bits ) ; out . write UBits ( _ NUM , line Bits ) ; write Change Record ( ) ; return ; } if ( has Fill Style0 || has Fill Style1 || has Line Style || has Move To ) { out . write UBits ( _ NUM , _ NUM ) ; out . write UBits ( _ NUM , _ NUM ) ; out . write UBits ( _ NUM , has Line Style ? _ NUM : _ NUM ) ; out . write UBits ( _ NUM , has Fill Style1 ? _ NUM : _ NUM ) ; out . write UBits ( _ NUM , has Fill Style0 ? _ NUM : _ NUM ) ; out . write UBits ( _ NUM , has Move To ? _ NUM : _ NUM ) ; if ( has Move To ) { int move X = move XY [ _ NUM ] ; int move Y = move XY [ _ NUM ] ; write Move XY ( move X , move Y ) ; } if ( has Fill Style0 ) { out . write UBits ( fill Bits , fill0 Index ) ; } if ( has Fill Style1 ) { out . write UBits ( fill Bits , fill1 Index ) ; } if ( has Line Style ) { out . write UBits ( line Bits , line Index ) ; } move XY = null ; fill0 Index = - _ NUM ; fill1 Index = - _ NUM ; line Index = - _ NUM ; } }
public static <  T > byte [ ] to Byte Array (  T value ,  Coder <  T > coder ) {  Byte Array Output Stream baos = new  Byte Array Output Stream ( ) ; try { coder . encode ( value , baos , new  Coder .  Context ( _ BOOL ) ) ; } catch (  IOException e ) { throw new  Illegal State Exception ( _ STR + value , e ) ; } return baos . to Byte Array ( ) ; }
public void test_single Resource Locking_default Concurrency20 ( ) throws  Exception {  Properties properties = new  Properties ( ) ; properties . set Property (  Test Options .  NTHREADS , _ STR ) ; properties . set Property (  Test Options .  NTASKS , _ STR ) ; properties . set Property (  Test Options .  NRESOURCES , _ STR ) ; properties . set Property (  Test Options .  MIN_ LOCKS , _ STR ) ; properties . set Property (  Test Options .  MAX_ LOCKS , _ STR ) ; properties . set Property (  Test Options .  PREDECLARE_ LOCKS , _ STR ) ; properties . set Property (  Test Options .  SORT_ LOCK_ REQUESTS , _ STR ) ; do Comparison Test ( properties ) ; }
private static final void run (  Runnable runnable ) { runnable . run ( ) ; }
public void start (  Resource xml File ,  String sax Parser Cass ) throws  Page Exception {  Input Stream is = null ; try {  XMLReader xml Reader =  XMLUtil . create XMLReader ( sax Parser Cass ) ; xml Reader . set Content Handler ( this ) ; xml Reader . set Error Handler ( this ) ; xml Reader . parse ( new  Input Source ( is =  IOUtil . to Buffered Input Stream ( xml File . get Input Stream ( ) ) ) ) ; } catch (  Exception e ) { throw  Caster . to Page Exception ( e ) ; } finally {  IOUtil . close EL ( is ) ; } }
public static final byte [ ] encode Url (  Bit Set urlsafe , byte [ ] bytes ) { if ( bytes == null ) { return null ; } if ( urlsafe == null ) { urlsafe =  WWW_ FORM_ URL ; }  Byte Array Output Stream buffer = new  Byte Array Output Stream ( ) ; for ( int i = _ NUM ; i < bytes . length ; i ++ ) { int b = bytes [ i ] ; if ( b < _ NUM ) { b = _ NUM + b ; } if ( urlsafe . get ( b ) ) { if ( b == _ STR ) { b = _ STR ; } buffer . write ( b ) ; } else { buffer . write ( _ STR ) ; char hex1 =  Character . to Upper Case (  Character . for Digit ( ( b > > _ NUM ) & _ NUM , _ NUM ) ) ; char hex2 =  Character . to Upper Case (  Character . for Digit ( b & _ NUM , _ NUM ) ) ; buffer . write ( hex1 ) ; buffer . write ( hex2 ) ; } } return buffer . to Byte Array ( ) ; }
public void test Case20 ( ) { byte a Bytes [ ] = { _ NUM } ; byte b Bytes [ ] = { _ NUM } ; byte r Bytes [ ] = { _ NUM } ; int a Sign = _ NUM ; int b Sign = _ NUM ;  Big Integer a Number = new  Big Integer ( a Sign , a Bytes ) ;  Big Integer b Number = new  Big Integer ( b Sign , b Bytes ) ;  Big Integer result = a Number . subtract ( b Number ) ; byte res Bytes [ ] = new byte [ r Bytes . length ] ; res Bytes = result . to Byte Array ( ) ; for ( int i = _ NUM ; i < res Bytes . length ; i ++ ) { assert True ( res Bytes [ i ] == r Bytes [ i ] ) ; } assert Equals ( _ NUM , result . signum ( ) ) ; }
public static boolean implements Zero Arg Method (  Class Node class Node ,  String method Name ) { return implements Method ( class Node , method Name , new  Class [ _ NUM ] ) ; }
public static  String format (  String message ,  Object argument ) { return  Message Format . format ( message , new  Object [ ] { argument } ) ; }
public static int parse Lower Map (  String s ) throws  Number Format Exception { int lower Case =  MAP_ UNDEFINED ; int length = s . length ( ) ; if ( length >= _ NUM && length <= _ NUM ) { lower Case =  Integer . parse Int ( s , _ NUM ) ; } else if ( s . length ( ) != _ NUM ) { throw new  Number Format Exception ( ) ; } return lower Case ; }
@  Override public void run ( ) { while ( ! is Interrupted ( ) ) { try {  Value Holder <  K ,  V > ref = (  Value Holder <  K ,  V > ) _queue . remove ( ) ; _table . remove ( ref . get Key ( ) ) ; } catch (  Interrupted Exception e ) { interrupt ( ) ; break ; } } }
private static  String unique Algorithm (  List names ,  String base Name ,  String sep ) {  String new Name = base Name ; int unique = _ NUM ; while ( names . contains ( new Name ) ) {  String ins = ( sep == null ? _ STR : sep ) ; new Name = base Name + ins +  String . value Of ( ++ unique ) ; } names . add ( new Name ) ; return new Name ; }
public static  Print Data parse XML (  Properties ctx ,  File input ) { log . config ( input . to String ( ) ) ;  Print Data pd = null ; try {  Print Data Handler handler = new  Print Data Handler ( ctx ) ;  SAXParser Factory factory =  SAXParser Factory . new Instance ( ) ;  SAXParser parser = factory . new SAXParser ( ) ; parser . parse ( input , handler ) ; pd = handler . get Print Data ( ) ; } catch (  Exception e ) { log . log (  Level .  SEVERE , _ STR , e ) ; } return pd ; }
@  Override public  Query Response Wrapper query (  Parsed Query query ) throws  Index Parse Exception {  Result Set results = session . execute ( generate Query Statement ( query , - _ NUM ) ) ;  Array List <  Document > to Return = new  Array List < > ( ) ;  Iterator <  Row > ite = results . iterator ( ) ; while ( ite . has Next ( ) ) {  Row row = ite . next ( ) ; to Return . add (  Document Persistance Utils . marshal Row ( row ) ) ; } return new  Query Response Wrapper ( to Return , _ NUM ) ; }
public org . smpte_ra . schemas . st2067_2_2013 .  Digest Method Type build Default Digest Method Type ( ) { org . smpte_ra . schemas . st2067_2_2013 .  Digest Method Type digest Method Type = new org . smpte_ra . schemas . st2067_2_2013 .  Digest Method Type ( ) ; digest Method Type . set Algorithm (  Composition Playlist Builder_2013 . default Hash Algorithm ) ; return digest Method Type ; }
public static <  V extends  Sampled Vertex >  Set <  V > create Sampled Partition (  Collection <  V > vertices , int iteration ) {  Set <  V > partition = new  Hash Set <  V > ( ) ; for (  V vertex : vertices ) { if ( vertex . is Sampled ( ) ) { if ( vertex . get Iteration Sampled ( ) == iteration ) partition . add ( vertex ) ; } } return partition ; }
public  Barabasi Albert Generator (  Supplier <  Graph <  V ,  E > > graph Factory ,  Supplier <  V > vertex Factory ,  Supplier <  E > edge Factory , int init_vertices , int num Edges To Attach ,  Set <  V > seed Vertices ) { this ( graph Factory , vertex Factory , edge Factory , init_vertices , num Edges To Attach , ( int )  System . current Time Millis ( ) , seed Vertices ) ; }
public static  Vector <  Object > inputs (  Vector <  Object > subset ,  Integer ... tab ) {  Vector <  Object > result = new  Vector <  Object > ( ) ; for ( int i = _ NUM ; i < subset . size ( ) ; i ++ ) {  Bean Instance temp = (  Bean Instance ) subset . element At ( i ) ; if ( check Target Constraint ( temp , subset , tab ) ) { result . add ( temp ) ; } } return result ; }
@  Override public  Generator <  ILine Segment > construct (  String [ ] args ) { return new  Hub Generator (  Double . value Of ( args [ _ NUM ] ) ,  Double . value Of ( args [ _ NUM ] ) ,  Double . value Of ( args [ _ NUM ] ) ) ; }
public static  Class Node [ ] make (  Class [ ] classes ) {  Class Node [ ] cns = new  Class Node [ classes . length ] ; for ( int i = _ NUM ; i < cns . length ; i ++ ) { cns [ i ] = make ( classes [ i ] ) ; } return cns ; }
@  Override void inserted Text (  Character Data Impl node , int offset , int count ) { if ( ranges != null ) { notify Ranges Inserted Text ( node , offset , count ) ; } }
public  Lucene50 Stored Fields Format (  Mode mode ) { this . mode =  Objects . require Non Null ( mode ) ; }
public  Completable Future <  String > publish ( final  String topic , final  Message message ) { final  Topic Queue queue = topics . compute If Absent ( topic , null ) ; final  Completable Future <  String > future = queue . send ( message ) ; listener . publishing Message ( this , topic , message , future ) ; return future ; }
public static boolean is Assignable From (  Class < ? > destination ,  Class < ? > source ) { return destination . is Assignable From ( source ) || is Boxing ( destination , source ) || is Un Boxing ( destination , source ) ; }
private void load Org Access Add (  Array List <  Org Access > list ,  Org Access oa ) { if ( list . contains ( oa ) ) return ; list . add ( oa ) ; if ( get AD_ Tree_ Org_ ID ( ) == _ NUM ) return ;  MOrg org =  MOrg . get ( get Ctx ( ) , oa .  AD_ Org_ ID ) ; if ( ! org . is Summary ( ) ) return ;  MTree_ Base tree =  MTree_ Base . get ( get Ctx ( ) , get AD_ Tree_ Org_ ID ( ) , get_ Trx Name ( ) ) ;  String sql = _ STR + _ STR + tree . get Node Table Name ( ) + _ STR ;  Prepared Statement pstmt = null ;  Result Set rs = null ; try { pstmt =  DB . prepare Statement ( sql , get_ Trx Name ( ) ) ; pstmt . set Int ( _ NUM , tree . get AD_ Tree_ ID ( ) ) ; pstmt . set Int ( _ NUM , org . get AD_ Org_ ID ( ) ) ; rs = pstmt . execute Query ( ) ; while ( rs . next ( ) ) { int  AD_ Client_ ID = rs . get Int ( _ NUM ) ; int  AD_ Org_ ID = rs . get Int ( _ NUM ) ; load Org Access Add ( list , new  Org Access (  AD_ Client_ ID ,  AD_ Org_ ID , oa . read Only ) ) ; } } catch (  Exception e ) { log . log (  Level .  SEVERE , sql , e ) ; } finally {  DB . close ( rs , pstmt ) ; rs = null ; pstmt = null ; } }
@  Override public  String secure Protocol ( ) {  SSLSocket ssl Socket = _ssl Socket ; if ( ssl Socket == null ) { return super . secure Protocol ( ) ; }  SSLSession ssl Session = ssl Socket . get Session ( ) ; if ( ssl Session != null ) { return ssl Session . get Protocol ( ) ; } else { return null ; } }
@  Suppress Warnings ( _ STR ) public static boolean equals ( cn . nukkit . level .  Location a , cn . nukkit . level .  Location b ) { if (  Math . abs ( a . get X ( ) - b . get X ( ) ) >  EQUALS_ PRECISION ) return _ BOOL ; if (  Math . abs ( a . get Y ( ) - b . get Y ( ) ) >  EQUALS_ PRECISION ) return _ BOOL ; if (  Math . abs ( a . get Z ( ) - b . get Z ( ) ) >  EQUALS_ PRECISION ) return _ BOOL ; return _ BOOL ; }
public static void wait For Process Output (  Process self ,  Appendable output ,  Appendable error ) {  Thread tout = consume Process Output Stream ( self , output ) ;  Thread terr = consume Process Error Stream ( self , error ) ; try { tout . join ( ) ; } catch (  Interrupted Exception ignore ) { } try { terr . join ( ) ; } catch (  Interrupted Exception ignore ) { } try { self . wait For ( ) ; } catch (  Interrupted Exception ignore ) { } close Streams ( self ) ; }
@  Override final  Node <  K ,  V > find ( int h ,  Object k ) { if ( k != null ) { for (  Node <  K ,  V > e = first ; e != null ; e = e . next ) { int s ;  K ek ; if ( ( ( s = lock State ) & (  WAITER |  WRITER ) ) != _ NUM ) { if ( e . hash == h && ( ( ek = e . key ) == k || ( ek != null && k . equals ( ek ) ) ) ) return e ; } else if (  U . compare And Swap Int ( this ,  LOCKSTATE , s , s +  READER ) ) {  Tree Node <  K ,  V > r , p ; try { p = ( ( r = root ) == null ? null : r . find Tree Node ( h , k , null ) ) ; } finally {  Thread w ; int ls ; do { } while ( !  U . compare And Swap Int ( this ,  LOCKSTATE , ls = lock State , ls -  READER ) ) ; if ( ls == (  READER |  WAITER ) && ( w = waiter ) != null )  Lock Support . unpark ( w ) ; } return p ; } } } return null ; }
@  Override public  Axis State draw (  Graphics2 D g2 , double cursor ,  Rectangle2 D plot Area ,  Rectangle2 D data Area ,  Rectangle Edge edge ,  Plot Rendering Info plot State ) { if ( ! is Visible ( ) ) { return new  Axis State ( cursor ) ; } if ( is Axis Line Visible ( ) ) { draw Axis Line ( g2 , cursor , data Area , edge ) ; }  Axis State state = new  Axis State ( cursor ) ; state = draw Sub Category Labels ( g2 , plot Area , data Area , edge , state , plot State ) ; state = draw Category Labels ( g2 , plot Area , data Area , edge , state , plot State ) ; if ( get Attributed Label ( ) != null ) { state = draw Attributed Label ( get Attributed Label ( ) , g2 , plot Area , data Area , edge , state ) ; } else { state = draw Label ( get Label ( ) , g2 , plot Area , data Area , edge , state ) ; } return state ; }
public void test Filter ( ) throws  IOException ,  Exception {  Array List <  URLCrawl Datum > list = new  Array List <  URLCrawl Datum > ( ) ; list . add ( create URLCrawl Datum ( _ STR , _ NUM , _ NUM ) ) ; list . add ( create URLCrawl Datum ( _ STR , _ NUM , _ NUM ) ) ; list . add ( create URLCrawl Datum ( _ STR , _ NUM , _ NUM ) ) ; create Crawl DB ( list ) ;  Configuration my Configuration = new  Configuration ( conf ) ; my Configuration . set ( _ STR , _ STR ) ;  Path generated Segment = generate Fetchlist (  Integer .  MAX_ VALUE , my Configuration , _ BOOL ) ; assert Null ( _ STR , generated Segment ) ; generated Segment = generate Fetchlist (  Integer .  MAX_ VALUE , my Configuration , _ BOOL ) ;  Path fetchlist Path = new  Path ( new  Path ( generated Segment ,  Crawl Datum .  GENERATE_ DIR_ NAME ) , _ STR ) ;  Array List <  URLCrawl Datum > fetch List = read Contents ( fetchlist Path ) ; assert Equals ( list . size ( ) , fetch List . size ( ) ) ; }
public static  Color reduce Color Brightness (  Color color ) { int r , g , b ; float [ ] hsb = new float [ _ NUM ] ; r = color . get Red ( ) ; g = color . get Green ( ) ; b = color . get Blue ( ) ;  Color .  RGBto HSB ( r , g , b , hsb ) ; hsb [ _ NUM ] *= _ NUM ; hsb [ _ NUM ] *= _ NUM ; return  Color . get HSBColor ( hsb [ _ NUM ] , hsb [ _ NUM ] , hsb [ _ NUM ] ) ; }
private boolean is Category Visible In Shop ( final  Long category Id ) { final  Set <  Long > cat Ids = shop Service . get Shop Categories Ids (  Shop Code Context . get Shop Id ( ) ) ;  Category category = category Service . get By Id ( category Id ) ; final  Date now = new  Date ( ) ; while ( category != null &&  Domain Api Utils . is Object Available Now ( _ BOOL , category . get Availablefrom ( ) , category . get Availableto ( ) , now ) && category . get Category Id ( ) != category . get Parent Id ( ) ) { if ( cat Ids . contains ( category Id ) ) { return _ BOOL ; } category = category Service . get By Id ( category . get Parent Id ( ) ) ; } return _ BOOL ; }
static  Object value Of ( final  Class < ? > type , final  String str ) { if ( ! is Valid Enum ( type ) ) { return null ; } try { final  String value Of Method = _ STR ; final  Method m = type . get Method ( value Of Method ,  String . class ) ; if ( !  Modifier . is Static ( m . get Modifiers ( ) ) ) { return null ; } final  Class < ? > return Type = m . get Return Type ( ) ; if ( ! type . is Assignable From ( return Type ) ) { return null ; } return m . invoke ( null , str ) ; } catch ( final  No Such Method Exception |  Invocation Target Exception |  Illegal Access Exception e ) { throw new  Runtime Exception ( e ) ; } }
protected void save Properties (  Properties props ,  File filehandle ,  String header ) throws  SMSException {  File Output Stream fileostr = null ; try { fileostr = new  File Output Stream ( filehandle ) ; props . store ( fileostr , header ) ; } catch (  File Not Found Exception e ) {  String errmsg = _ STR + ( header == null ? _ STR : header + _ STR ) + _ STR + filehandle . get Path ( ) + _ STR + e . get Message ( ) ; m Debug . error ( _ STR , e ) ; throw new  Service Not Found Exception ( errmsg ) ; } catch (  IOException e ) {  String errmsg = _ STR + ( header == null ? _ STR : header + _ STR ) + _ STR + filehandle . get Path ( ) + _ STR + e . get Message ( ) ; m Debug . error ( _ STR , e ) ; throw new  Service Not Found Exception ( errmsg ) ; } finally { try { fileostr . close ( ) ; } catch (  IOException e ) { } } }
private static void create Thread Pool ( ) { if ( m Thread Pool Size <= _ NUM ) { m Executor Service =  Executors . new Cached Thread Pool ( ) ; } else { m Executor Service =  Executors . new Fixed Thread Pool ( m Thread Pool Size ) ; } }
public void remove CSPState Listener (  CSPState Listener listener ) { listeners . remove ( listener ) ; }
public void display Message And Usage Reference ( final  Print Stream print Stream , final  Localizable Message message ) { print Wrapped Text ( print Stream , message ) ; print Stream . println ( ) ; print Wrapped Text ( print Stream , get Help Usage Reference ( ) ) ; }
public static void process Image (  Network Table table ) {  Array List <  Mat Of Point > contours = new  Array List <  Mat Of Point > ( ) ; double x , y , target X , target Y , distance , azimuth ; int  Frame Count = _ NUM ; long before =  System . current Time Millis ( ) ; while (  Frame Count < _ NUM ) { contours . clear ( ) ; video Capture . read ( mat Original ) ;  Imgproc . cvt Color ( mat Original , mat HSV ,  Imgproc .  COLOR_ BGR2 HSV ) ;  Core . in Range ( mat HSV ,  LOWER_ BOUNDS ,  UPPER_ BOUNDS , mat Thresh ) ;  Imgproc . find Contours ( mat Thresh , contours , mat Heirarchy ,  Imgproc .  RETR_ EXTERNAL ,  Imgproc .  CHAIN_ APPROX_ SIMPLE ) ; for (  Mat Of Point mop : contours ) {  Rect rec =  Imgproc . bounding Rect ( mop ) ;  Imgproc . rectangle ( mat Original , rec . br ( ) , rec . tl ( ) ,  RED ) ; } for (  Iterator <  Mat Of Point > iterator = contours . iterator ( ) ; iterator . has Next ( ) ; ) {  Mat Of Point mat Of Point = (  Mat Of Point ) iterator . next ( ) ;  Rect rec =  Imgproc . bounding Rect ( mat Of Point ) ; if ( rec . height < _ NUM || rec . width < _ NUM ) { iterator . remove ( ) ; continue ; } float aspect = ( float ) rec . width / ( float ) rec . height ; if ( aspect < _ NUM ) iterator . remove ( ) ; } table . put Number ( _ STR , contours . size ( ) ) ; table . flush ( ) ; if ( contours . size ( ) == _ NUM ) {  Rect rec =  Imgproc . bounding Rect ( contours . get ( _ NUM ) ) ; y = rec . br ( ) . y + rec . height / _ NUM ; y = - ( ( _ NUM * ( y / mat Original . height ( ) ) ) - _ NUM ) ; distance = (  TOP_ TARGET_ HEIGHT -  TOP_ CAMERA_ HEIGHT ) /  Math . tan ( ( y *  VERTICAL_ FOV / _ NUM +  CAMERA_ ANGLE ) *  Math .  PI / _ NUM ) ; target X = rec . tl ( ) . x + rec . width / _ NUM ; target X = ( _ NUM * ( target X / mat Original . width ( ) ) ) - _ NUM ; azimuth = normalize360 ( target X *  HORIZONTAL_ FOV / _ NUM + _ NUM ) ;  Point center = new  Point ( rec . br ( ) . x - rec . width / _ NUM - _ NUM , rec . br ( ) . y - rec . height / _ NUM ) ;  Point centerw = new  Point ( rec . br ( ) . x - rec . width / _ NUM - _ NUM , rec . br ( ) . y - rec . height / _ NUM - _ NUM ) ; table . put Number ( _ STR , distance -  ROBOT_ OFFSET_ TO_ FRONT ) ; table . put Number ( _ STR , azimuth ) ; }  Imgcodecs . imwrite ( _ STR , mat Original ) ; } }
public  Instance place Symbol (  Symbol symbol ,  Transform matrix2 ,  Alpha Transform cxform , int ratio , int clip Depth ) {  Transform matrix = matrix2 ; int depth = timeline . get Available Depth ( ) ;  Instance inst = new  Instance ( symbol , depth ) ; timeline . set Available Depth ( depth + _ NUM ) ; if ( matrix == null ) { matrix = new  Transform ( ) ; }  Placement placement = new  Placement ( inst , matrix , cxform , null , ratio , clip Depth , frame Number , _ BOOL , _ BOOL , null ) ; placements . add ( placement ) ; return inst ; }
protected boolean before Delete ( ) { if ( is Store Attachments On File System ) { for ( int i = _ NUM ; i < m_items . size ( ) ; i ++ ) { final  MAttachment Entry entry = m_items . get ( i ) ; final  File file = entry . get File ( ) ; if ( file != null && file . exists ( ) ) { if ( ! file . delete ( ) ) { log . warning ( _ STR + file . get Absolute Path ( ) ) ; } } } final  File folder = new  File ( m_attachment Path Root + get Attachment Path Snippet ( ) ) ; if ( folder . exists ( ) ) { if ( ! folder . delete ( ) ) { log . warning ( _ STR + folder . get Absolute Path ( ) ) ; } } } return _ BOOL ; }
public static <  T >  List <  T > as List (  T ... values ) { if ( values == null ) { return new  Array List <  T > ( _ NUM ) ; } else { return new  Array List <  T > (  Arrays . as List ( values ) ) ; } }
private boolean recover Failed Instance (  String instance Id ,  Instance State state ) { try { if ( state . get State ( ) ==  Instance State .  STATE_ RUNNING ) { state . update Detected Down ( ) ; state . clear Recovery Attempts ( ) ; } state . set State (  Instance State .  STATE_ PROCESSING_ DOWN ) ; state . set Recovering Instance Id ( this . instance Id ) ; state . update Recovering Timestamp ( ) ; state . start Recovery ( ) ; update Instance State ( instance Id , state ) ; } catch (  Resource Exception e ) { if ( e . get Code ( ) !=  Resource Exception .  CONFLICT ) { logger . warn ( _ STR , e ) ; } return _ BOOL ; }  Cluster Event recovery Event = new  Cluster Event (  Cluster Event Type .  RECOVERY_ INITIATED , instance Id ) ; boolean success = send Event To Listeners ( recovery Event ) ; if ( success ) { logger . info ( _ STR , instance Id ) ; try {  Instance State new State = get Instance State ( instance Id ) ; new State . set State (  Instance State .  STATE_ DOWN ) ; new State . finish Recovery ( ) ; update Instance State ( instance Id , new State ) ; } catch (  Resource Exception e ) { if ( e . get Code ( ) !=  Resource Exception .  CONFLICT ) { logger . warn ( _ STR , e ) ; } return _ BOOL ; } } else { logger . warn ( _ STR , instance Id ) ; return _ BOOL ; } return _ BOOL ; }
@  Request Mapping ( value = _ STR , method =  Request Method .  DELETE , produces =  Media Type .  APPLICATION_ JSON_ VALUE ) @  Timed @  Secured (  Authorities Constants .  ADMIN ) public  Response Entity <  Void > delete User ( @  Path Variable  String login ) { }
public final void register Extension (  Bridge Extension ext ) { @  Suppress Warnings ( _ STR )  Iterator <  String > i = ext . get Implemented Extensions ( ) ; while ( i . has Next ( ) ) extensions . add ( i . next ( ) ) ; }
public  Builder delete Nick Name ( ) { delete Fields . add ( _ STR ) ; return this ; }
public  Query limit ( int limit , int offset ) { return limit ( limit < _ NUM ?  NO_ LIMIT :  Field . <  Integer > field (  Integer . to String ( limit ) ) , offset < _ NUM ?  NO_ OFFSET :  Field . <  Integer > field (  Integer . to String ( offset ) ) ) ; }
public static boolean file Exists (  String file ) {  File tmp = new  File ( file ) ; return ( tmp . is File ( ) && tmp . exists ( ) ) ; }
public void add Method (  Mapped Member mm ) { methods . add ( mm ) ; }
public static  Doc Viewer Component open (  Input Stream input , final  String name , final  String format ) {  Doc Viewer Component comp = new  Doc Viewer Component ( name ) ;  Buffered Reader br ; br = new  Buffered Reader ( new  Input Stream Reader ( input ,  Charset . for Name ( _ STR ) ) ) ;  String line ;  String text = new  String ( ) ; try { while ( ( line = br . read Line ( ) ) != null ) { text = text . concat ( line + _ STR ) ; } } catch (  IOException e ) { e . print Stack Trace ( ) ; } comp . set Text ( text ) ; return comp ; }
private void copy Stream (  Input Stream is ,  Output Stream os ) throws  IOException { try { byte [ ] buffer = new byte [ _ NUM ] ; int len ; while ( ( len = is . read ( buffer ) ) != - _ NUM ) { os . write ( buffer , _ NUM , len ) ; } } catch (  IOException e ) { throw new  IOException ( _ STR , e ) ; } }
public void assign Service (  Map map ) throws  AMConsole Exception {  String [ ] params = { current Realm , service Name } ; log Event ( _ STR , params ) ; try {  AMIdentity Repository repo = new  AMIdentity Repository ( get User SSOToken ( ) , current Realm ) ;  AMIdentity realm Identity = repo . get Realm Identity ( ) ;  Set services From Id Repo = realm Identity . get Assignable Services ( ) ; if ( services From Id Repo . contains ( service Name ) ) { realm Identity . assign Service ( service Name , map ) ; } else {  Organization Config Manager org Cfg Mgr = new  Organization Config Manager ( get User SSOToken ( ) , current Realm ) ; org Cfg Mgr . assign Service ( service Name , map ) ; } log Event ( _ STR , params ) ; } catch (  SSOException e ) {  String str Error = get Error String ( e ) ;  String [ ] params Ex = { current Realm , service Name , str Error } ; log Event ( _ STR , params Ex ) ; throw new  AMConsole Exception ( str Error ) ; } catch (  Id Repo Exception e ) {  String str Error = get Error String ( e ) ;  String [ ] params Ex = { current Realm , service Name , str Error } ; log Event ( _ STR , params Ex ) ; throw new  AMConsole Exception ( str Error ) ; } catch (  SMSException e ) {  String str Error = get Error String ( e ) ;  String [ ] params Ex = { current Realm , service Name , str Error } ; log Event ( _ STR , params Ex ) ; throw new  AMConsole Exception ( str Error ) ; } }
public  Writable Raster create Writable Child ( int x , int y , int width , int height , int x0 , int y0 , int [ ] band List ) { if ( x < this . min X ) { throw new  Raster Format Exception ( _ STR ) ; } if ( y < this . min Y ) { throw new  Raster Format Exception ( _ STR ) ; } if ( ( x + width < x ) || ( x + width > this . min X + this . width ) ) { throw new  Raster Format Exception ( _ STR ) ; } if ( ( y + height < y ) || ( y + height > this . min Y + this . height ) ) { throw new  Raster Format Exception ( _ STR ) ; }  Sample Model sm ; if ( band List != null ) sm = sample Model . create Subset Sample Model ( band List ) ; else sm = sample Model ; int delta X = x0 - x ; int delta Y = y0 - y ; return new  Byte Interleaved Raster ( sm , data Buffer , new  Rectangle ( x0 , y0 , width , height ) , new  Point ( sample Model Translate X + delta X , sample Model Translate Y + delta Y ) , this ) ; }
private void copy To (  Byte Buffer buf ,  Output Stream out ) throws  IOException { if ( ! buf . has Remaining ( ) ) { return ; } if ( buf . has Array ( ) ) { out . write ( buf . array ( ) , buf . array Offset ( ) + buf . position ( ) , buf . remaining ( ) ) ; } else { byte [ ] bytes = new byte [ _ NUM ] ; do { buf . get ( bytes , _ NUM ,  Math . min ( bytes . length , buf . remaining ( ) ) ) ; out . write ( bytes ) ; } while ( buf . has Remaining ( ) ) ; } }
public void dispatch Event (  Event event ) {  Assertions . assert Condition ( event . is Initialized ( ) , _ STR ) ; boolean event Handled = _ BOOL ; for (  Event Dispatcher Listener listener : m Listeners ) { if ( listener . on Event Dispatch ( event ) ) { event Handled = _ BOOL ; } } if ( event Handled ) { return ; } synchronized ( m Events Staging Lock ) { m Event Staging . add ( event ) ;  Systrace . start Async Flow (  Systrace .  TRACE_ TAG_ REACT_ JAVA_ BRIDGE , event . get Event Name ( ) , event . get Unique ID ( ) ) ; } if ( m RCTEvent Emitter != null ) { m Current Frame Callback . maybe Post From Non UI ( ) ; } else { } }
public  User Config update Icon (  String file ,  User Config config ) { config . add Credentials ( this ) ;  String xml =  POSTIMAGE ( this . url + _ STR , file , _ STR , config . to XML ( ) ) ;  Element root = parse ( xml ) ; if ( root == null ) { return null ; } try { config = new  User Config ( ) ; config . parse XML ( root ) ; return config ; } catch (  Exception exception ) { this . exception =  SDKException . parse Failure ( exception ) ; throw this . exception ; } }
@  Override public int compare ( final  String string1 , final  String string2 ) {  String string1 Copy = string1 . to Lower Case ( ) ;  String string2 Copy = string2 . to Lower Case ( ) ; int len1 = string1 . length ( ) ; int len2 = string2 . length ( ) ;  String liczba1 = _ STR ;  String liczba2 = _ STR ; for ( int i = _ NUM ; i < ( ( len1 > len2 ) ? len1 : len2 ) ; i ++ ) { if ( i == len1 && len2 > len1 ) { return - _ NUM ; } if ( i == len2 && len1 > len2 ) { return _ NUM ; }  Character c1 = string1 Copy . char At ( i ) ;  Character c2 = string2 Copy . char At ( i ) ; if ( is Digit ( c1 ) && is Digit ( c2 ) ) { liczba1 += c1 ; liczba2 += c2 ; } else if ( is Digit ( c1 ) && liczba1 . length ( ) > _ NUM ) { return _ NUM ; } else if ( is Digit ( c2 ) && liczba1 . length ( ) > _ NUM ) { return - _ NUM ; } else { if ( ! liczba1 . equals ( liczba2 ) ) { return liczba1 . compare To ( liczba2 ) ; } liczba1 = _ STR ; liczba2 = _ STR ; if ( ! c1 . equals ( c2 ) ) { return c1 . compare To ( c2 ) ; } } } return string1 Copy . compare To ( string2 Copy ) ; }
protected boolean validate Blob ( int id , byte [ ] base Content , int required Size ) throws  SQLException {  Connection con = get Connection Via Driver Manager ( ) ;  Callable Statement cstmt = null ; try { cstmt = con . prepare Call (  EXECUTE_ CHECK_ BINARY_ BLOB ) ; cstmt . set Int ( _ NUM , id ) ; cstmt . set Bytes ( _ NUM , base Content ) ; cstmt . set Int ( _ NUM , required Size ) ; cstmt . execute ( ) ; return cstmt . get Boolean ( _ NUM ) ; } finally { close Quietly ( cstmt ) ; close Quietly ( con ) ; } }
private  List <  String > update Status (  List <  String > unsent Reg Ids ,  Map <  String ,  Result > all Results ,  Multicast Result multicast Result ) {  List <  Result > results = multicast Result . get Results ( ) ; if ( results . size ( ) != unsent Reg Ids . size ( ) ) { throw new  Runtime Exception ( _ STR + _ STR + results + _ STR + unsent Reg Ids ) ; }  List <  String > new Unsent Reg Ids = new  Array List <  String > ( ) ; for ( int i = _ NUM ; i < unsent Reg Ids . size ( ) ; i ++ ) {  String reg Id = unsent Reg Ids . get ( i ) ;  Result result = results . get ( i ) ; all Results . put ( reg Id , result ) ;  String error = result . get Error Code Name ( ) ; if ( error != null && ( error . equals (  Constants .  ERROR_ UNAVAILABLE ) || error . equals (  Constants .  ERROR_ INTERNAL_ SERVER_ ERROR ) ) ) { new Unsent Reg Ids . add ( reg Id ) ; } } return new Unsent Reg Ids ; }
public  Statement using (  Object ... columns ) { statement . append ( _ STR ) ; append Clauses ( columns ) ; statement . append ( _ STR ) ; return this ; }
public void clear ( ) { process Queue ( ) ; map . clear ( ) ; }
public void delete Favorite ( ) {  Fm Radio Station . update Station To Db ( m Context , m Dlg Station Name ,  Fm Radio Station .  STATION_ TYPE_ SEARCHED , m Dlg Station Freq ) ; m Adapter . notify Data Set Changed ( ) ; }
@  Override public int add All Absent ( @  Not Null  Collection < ? extends  E > c ) {  Object [ ] cs = c . to Array ( ) ; if ( cs . length == _ NUM ) { return _ NUM ; }  Object [ ] uniq = new  Object [ cs . length ] ;  Object [ ] elements ;  Object [ ] new Elements ; int added ; do { elements = array ; int len = elements . length ; added = _ NUM ; for (  Object e : cs ) { if ( index Of ( e , elements , _ NUM , len ) < _ NUM && index Of ( e , uniq , _ NUM , added ) < _ NUM ) { uniq [ added ++ ] = e ; } } if ( added == _ NUM ) { return _ NUM ; } new Elements =  Arrays . copy Of ( elements , len + added ,  Object [ ] . class ) ;  System . arraycopy ( uniq , _ NUM , new Elements , len , added ) ; } while ( ! replace Array ( elements , new Elements ) ) ; return added ; }
public  Iterator <  Capability > capabilities ( ) { return m_ Capabilities . iterator ( ) ; }
private void update Notification (  String content ) {  String ticker =  String . format ( get String (  R . string . media_notif_ticker ) , get String (  R . string . app_name ) ) ;  Intent show Details Intent = new  Intent ( this ,  File Display Activity . class ) ; show Details Intent . put Extra (  File Activity .  EXTRA_ FILE , m File ) ; show Details Intent . put Extra (  File Activity .  EXTRA_ ACCOUNT , m Account ) ; show Details Intent . set Flags (  Intent .  FLAG_ ACTIVITY_ CLEAR_ TOP ) ; m Notification Builder . set Content Intent (  Pending Intent . get Activity ( get Application Context ( ) , ( int )  System . current Time Millis ( ) , show Details Intent ,  Pending Intent .  FLAG_ UPDATE_ CURRENT ) ) ; m Notification Builder . set When (  System . current Time Millis ( ) ) ; m Notification Builder . set Ticker ( ticker ) ; m Notification Builder . set Content Title ( ticker ) ; m Notification Builder . set Content Text ( content ) ; m Notification Manager . notify (  R . string . media_notif_ticker , m Notification Builder . build ( ) ) ; }
public static long find Number (  String str , int offset ) throws  Tag Exception { if ( str == null ) { throw new  Null Pointer Exception ( _ STR ) ; } if ( ( offset < _ NUM ) || ( offset >= str . length ( ) ) ) { throw new  Index Out Of Bounds Exception ( _ STR + offset + _ STR + str . length ( ) ) ; } int i ; int j ; long num ; i = offset ; while ( i < str . length ( ) ) { if ( ( ( str . char At ( i ) >= _ STR ) && ( str . char At ( i ) <= _ STR ) ) || ( str . char At ( i ) == _ STR ) ) { break ; } i ++ ; } j = i + _ NUM ; while ( j < str . length ( ) ) { if ( ( ( str . char At ( j ) < _ STR ) || ( str . char At ( j ) > _ STR ) ) ) { break ; } j ++ ; } if ( ( j <= str . length ( ) ) && ( j > i ) ) { num =  Long . parse Long ( str . substring ( i , j ) ) ; } else { throw new  Tag Exception ( _ STR + str ) ; } return num ; }
public static <  T >  Future W <  T > of Error ( final  Throwable error ) { final  Completable Future <  T > cf = new  Completable Future < > ( ) ; cf . complete Exceptionally ( error ) ; return  Future W . <  T > of ( cf ) ; }
private void send Request To Server (  Http URLConnection url Connection ,  String xml ) throws  Request Failure Exception { try {  Output Stream out = new  Buffered Output Stream ( url Connection . get Output Stream ( ) ) ;  Output Stream Writer writer = new  Output Stream Writer ( out ) ; writer . write ( xml , _ NUM , xml . length ( ) ) ; writer . close ( ) ; check Server Response Code ( url Connection ) ; } catch (  IOException e ) { throw new  Request Failure Exception ( _ STR , e ) ; } }
public static void prepend Resource Source (  Resource Source source ) {  ALL_ RESOURCE_ SOURCES . add First ( source ) ; }
private void commit Changes ( ) { network Properties Panel . commit Changes ( ) ; quick Connect Panel . commit Changes ( ) ; }
private boolean via_try_snap_smd_center ( int p_layer ) {  Item Selection Filter selection_filter = new  Item Selection Filter (  Item Selection Choice .  PINS ) ;  Collection <  Brd Item > picked_items = r_board . pick_items ( prev_corner , p_layer , selection_filter ) ;  Brd Abit Pin found_smd_pin = null ; for (  Brd Item curr_item : picked_items ) { if ( ! ( curr_item instanceof  Brd Abit Pin ) ) continue ;  Brd Abit Pin a_pin = (  Brd Abit Pin ) curr_item ; if ( ! a_pin . shares_net_no ( net_nos ) ) continue ; if ( a_pin . first_layer ( ) == p_layer && a_pin . last_layer ( ) == p_layer ) { found_smd_pin = a_pin ; break ; } } if ( found_smd_pin == null ) return _ BOOL ;  Pla Point Int pin_center = found_smd_pin . center_get ( ) ; if ( itera_connect ( prev_corner , pin_center ) ) { prev_corner = pin_center ; } return _ BOOL ; }
@  Override public boolean on Intercept Touch Event (  Motion Event ev ) { final int action = ev . get Action ( ) &  Motion Event .  ACTION_ MASK ; if ( action ==  Motion Event .  ACTION_ CANCEL || action ==  Motion Event .  ACTION_ UP ) { m Is Being Dragged = _ BOOL ; m Is Unable To Drag = _ BOOL ; return _ BOOL ; } if ( action !=  Motion Event .  ACTION_ DOWN ) { if ( m Is Being Dragged ) { return _ BOOL ; } if ( m Is Unable To Drag ) { return _ BOOL ; } } switch ( action ) { case  Motion Event .  ACTION_ MOVE : { final float x = ev . get X ( ) ; final float dx = x - m Last Motion X ; final float x Diff =  Math . abs ( dx ) ; final float y = ev . get Y ( ) ; final float y Diff =  Math . abs ( y - m Last Motion Y ) ; if ( x Diff > m Touch Slop && x Diff > y Diff ) { m Is Being Dragged = _ BOOL ; m Last Motion X = x ; } else { if ( y Diff > m Touch Slop ) { m Is Unable To Drag = _ BOOL ; } } break ; } case  Motion Event .  ACTION_ DOWN : { if ( ! m Scroller . is Finished ( ) ) { return _ BOOL ; } m Last Motion X = ev . get X ( ) ; m Last Motion Y = ev . get Y ( ) ; m Is Being Dragged = _ BOOL ; m Is Unable To Drag = _ BOOL ; break ; } } return m Is Being Dragged ; }
public boolean add Svf (  Owl Class target Class ) { target Class . add Svf Restriction ( this ) ; return svf Classes . add ( target Class ) ; }
private boolean compute Any Visible (  Viewer viewer ,  Object [ ] elements ) { boolean element Found = _ BOOL ; for ( int i = _ NUM ; i < elements . length && ! element Found ; i ++ ) {  Object element = elements [ i ] ; element Found = is Element Visible ( viewer , element ) ; } return element Found ; }
public static boolean is DWMComposition Enabled ( ) { return is DWMComposition Enabled ; }
private void serializable ( final  Isolation Levels level ) throws  Exception { clear ( store ) ; final  Value Factory vf = store . get Value Factory ( ) ; final  IRI subj = vf . create IRI ( _ STR ) ; final  IRI pred = vf . create IRI ( _ STR ) ;  Sail Connection prep = store . get Connection ( ) ; try { prep . begin ( level ) ; prep . add Statement ( subj , pred , vf . create Literal ( _ NUM ) ) ; prep . commit ( ) ; } finally { prep . close ( ) ; } final  Count Down Latch start = new  Count Down Latch ( _ NUM ) ; final  Count Down Latch observed = new  Count Down Latch ( _ NUM ) ;  Thread t1 = increment By ( start , observed , level , vf , subj , pred , _ NUM ) ;  Thread t2 = increment By ( start , observed , level , vf , subj , pred , _ NUM ) ; t2 . start ( ) ; t1 . start ( ) ; t2 . join ( ) ; t1 . join ( ) ; assert Not Failed ( ) ;  Sail Connection check = store . get Connection ( ) ; try { check . begin ( level ) ;  Literal lit = read Literal ( check , subj , pred ) ; int val = lit . int Value ( ) ; if ( val != _ NUM && val != _ NUM ) {  Assert . assert Equals ( _ NUM , val ) ; } check . commit ( ) ; } finally { check . close ( ) ; } }
public static  Array list To Array (  String list , char delimiter ) { if ( list . length ( ) == _ NUM ) return new  Array Impl ( ) ; int len = list . length ( ) ; int last = _ NUM ;  Array array = new  Array Impl ( ) ; try { for ( int i = _ NUM ; i < len ; i ++ ) { if ( list . char At ( i ) == delimiter ) { array . append ( list . substring ( last , i ) ) ; last = i + _ NUM ; } } if ( last <= len ) array . append ( list . substring ( last ) ) ; } catch (  Page Exception e ) { } return array ; }
public static <  T extends  Object & java . lang .  Comparable < ? super  T > >  T min (  Collection < ? extends  T > collection ) {  Iterator < ? extends  T > it = collection . iterator ( ) ;  T min = it . next ( ) ; if (  Number Comparator . is Number ( min ) ) { return (  T ) max ( collection ,  Number Comparator . create Comparator ( min . get Class ( ) ) ) ; } while ( it . has Next ( ) ) {  T next = it . next ( ) ; if ( min . compare To ( next ) > _ NUM ) { min = next ; } } return min ; }
public static  Socket create Socket (  String server , int default Port , boolean ssl ) throws  IOException { int port = default Port ; int start Index = server . starts With ( _ STR ) ? server . index Of ( _ STR ) : _ NUM ; int idx = server . index Of ( _ STR , start Index ) ; if ( idx >= _ NUM ) { port =  Integer . decode ( server . substring ( idx + _ NUM ) ) ; server = server . substring ( _ NUM , idx ) ; }  Inet Address address =  Inet Address . get By Name ( server ) ; return create Socket ( address , port , ssl ) ; }
public void test To String ( ) {  Linked Blocking Deque q = populated Deque (  SIZE ) ;  String s = q . to String ( ) ; for ( int i = _ NUM ; i <  SIZE ; ++ i ) { assert True ( s . index Of (  String . value Of ( i ) ) >= _ NUM ) ; } }
public static  String create Link Failure Message Based On Heuristics (  My SQLConnection conn , long last Packet Sent Time Ms , long last Packet Received Time Ms ,  Exception underlying Exception ) { long server Timeout Seconds = _ NUM ; boolean is Interactive Client = _ BOOL ; if ( conn != null ) { is Interactive Client = conn . get Interactive Client ( ) ;  String server Timeout Seconds Str = null ; if ( is Interactive Client ) { server Timeout Seconds Str = conn . get Server Variable ( _ STR ) ; } else { server Timeout Seconds Str = conn . get Server Variable ( _ STR ) ; } if ( server Timeout Seconds Str != null ) { try { server Timeout Seconds =  Long . parse Long ( server Timeout Seconds Str ) ; } catch (  Number Format Exception nfe ) { server Timeout Seconds = _ NUM ; } } }  String Builder exception Message Buf = new  String Builder ( ) ; long now Ms =  System . current Time Millis ( ) ; if ( last Packet Sent Time Ms == _ NUM ) { last Packet Sent Time Ms = now Ms ; } long time Since Last Packet Sent Ms = ( now Ms - last Packet Sent Time Ms ) ; long time Since Last Packet Seconds = time Since Last Packet Sent Ms / _ NUM ; long time Since Last Packet Received Ms = ( now Ms - last Packet Received Time Ms ) ; int due To Timeout =  DUE_ TO_ TIMEOUT_ FALSE ;  String Builder timeout Message Buf = null ; if ( server Timeout Seconds != _ NUM ) { if ( time Since Last Packet Seconds > server Timeout Seconds ) { due To Timeout =  DUE_ TO_ TIMEOUT_ TRUE ; timeout Message Buf = new  String Builder ( ) ; timeout Message Buf . append (  Messages . get String ( _ STR ) ) ; if ( ! is Interactive Client ) { timeout Message Buf . append (  Messages . get String ( _ STR ) ) ; } else { timeout Message Buf . append (  Messages . get String ( _ STR ) ) ; } } } else if ( time Since Last Packet Seconds >  DEFAULT_ WAIT_ TIMEOUT_ SECONDS ) { due To Timeout =  DUE_ TO_ TIMEOUT_ MAYBE ; timeout Message Buf = new  String Builder ( ) ; timeout Message Buf . append (  Messages . get String ( _ STR ) ) ; timeout Message Buf . append (  Messages . get String ( _ STR ) ) ; timeout Message Buf . append (  Messages . get String ( _ STR ) ) ; timeout Message Buf . append (  Messages . get String ( _ STR ) ) ; } if ( due To Timeout ==  DUE_ TO_ TIMEOUT_ TRUE || due To Timeout ==  DUE_ TO_ TIMEOUT_ MAYBE ) { if ( last Packet Received Time Ms != _ NUM ) {  Object [ ] timing Info = {  Long . value Of ( time Since Last Packet Received Ms ) ,  Long . value Of ( time Since Last Packet Sent Ms ) } ; exception Message Buf . append (  Messages . get String ( _ STR , timing Info ) ) ; } else { exception Message Buf . append (  Messages . get String ( _ STR , new  Object [ ] {  Long . value Of ( time Since Last Packet Sent Ms ) } ) ) ; } if ( timeout Message Buf != null ) { exception Message Buf . append ( timeout Message Buf ) ; } exception Message Buf . append (  Messages . get String ( _ STR ) ) ; exception Message Buf . append (  Messages . get String ( _ STR ) ) ; exception Message Buf . append (  Messages . get String ( _ STR ) ) ; } else { if ( underlying Exception instanceof  Bind Exception ) { if ( conn . get Local Socket Address ( ) != null && !  Util . interface Exists ( conn . get Local Socket Address ( ) ) ) { exception Message Buf . append (  Messages . get String ( _ STR ) ) ; } else { exception Message Buf . append (  Messages . get String ( _ STR ) ) ; } } } if ( exception Message Buf . length ( ) == _ NUM ) { exception Message Buf . append (  Messages . get String ( _ STR ) ) ; if ( conn != null && conn . get Maintain Time Stats ( ) && ! conn . get Paranoid ( ) ) { exception Message Buf . append ( _ STR ) ; if ( last Packet Received Time Ms != _ NUM ) {  Object [ ] timing Info = {  Long . value Of ( time Since Last Packet Received Ms ) ,  Long . value Of ( time Since Last Packet Sent Ms ) } ; exception Message Buf . append (  Messages . get String ( _ STR , timing Info ) ) ; } else { exception Message Buf . append (  Messages . get String ( _ STR , new  Object [ ] {  Long . value Of ( time Since Last Packet Sent Ms ) } ) ) ; } } } return exception Message Buf . to String ( ) ; }
public void test_session Protection ( ) { final  Journal store = (  Journal ) get Store ( ) ; try { final  RWStrategy bs = (  RWStrategy ) store . get Buffer Strategy ( ) ; final  RWStore rw = bs . get Store ( ) ; final byte [ ] buf = new byte [ _ NUM ] ; r . next Bytes ( buf ) ; final  Byte Buffer bb =  Byte Buffer . wrap ( buf ) ; long faddr = bs . write ( bb ) ;  IRaw Tx tx = rw . new Tx ( ) ; bs . delete ( faddr ) ; bb . position ( _ NUM ) ; final  Byte Buffer rd Buf = bs . read ( faddr ) ; assert Equals ( bb , rd Buf ) ; tx . close ( ) ; store . commit ( ) ; } finally { store . destroy ( ) ; } }
void incoming ( ) throws  IOException { write Line (  String . format ( _ STR , host Id ) ) ;  String line = read Line ( ) ; if ( network Tracing ) { logger . info ( _ STR , host Id , line ) ; }  Matcher matcher = make Call Pattern . matcher ( line ) ; if ( matcher . find ( ) ) { make Call = _ BOOL ; from Member Id =  Integer . parse Int ( matcher . group ( _ NUM ) ) ; to Member Id =  Integer . parse Int ( matcher . group ( _ NUM ) ) ; } else { matcher = request Call Back Pattern . matcher ( line ) ; if ( matcher . find ( ) ) { from Member Id =  Integer . parse Int ( matcher . group ( _ NUM ) ) ; to Member Id =  Integer . parse Int ( matcher . group ( _ NUM ) ) ; } else { throw new  Illegal State Exception ( _ STR + line ) ; } } }
public static synchronized  Collection <  String > all Local Ips ( ) {  List <  String > ips = new  Array List < > ( _ NUM ) ; try {  Enumeration <  Network Interface > itfs =  Network Interface . get Network Interfaces ( ) ; if ( itfs != null ) { for (  Network Interface itf : as Iterable ( itfs ) ) { if ( ! itf . is Loopback ( ) ) {  Enumeration <  Inet Address > addrs = itf . get Inet Addresses ( ) ; for (  Inet Address addr : as Iterable ( addrs ) ) {  String host Addr = addr . get Host Address ( ) ; if ( ! addr . is Loopback Address ( ) && ! ips . contains ( host Addr ) ) ips . add ( host Addr ) ; } } } } } catch (  Socket Exception ignore ) { return  Collections . empty List ( ) ; }  Collections . sort ( ips ) ; return ips ; }
public static void show Profile (  Fragment fragment ,  String pilot Id , @  Nullable  Hash Map <  String ,  String > extras ) { if ( ( pilot Id == null || pilot Id . is Empty ( ) ) &&  Air Map . has Valid Authenticated User ( ) ) { pilot Id =  Air Map . get User Id ( ) ; }  Intent intent = new  Intent ( fragment . get Activity ( ) ,  Profile Activity . class ) ; intent . put Extra (  Profile Activity .  ARG_ PILOT_ ID , pilot Id ) ; if ( extras != null ) { intent . put Extra (  Create Flight Activity .  KEY_ VALUE_ EXTRAS , extras ) ; } fragment . start Activity ( intent ) ; }
private void change Resolution ( boolean faster ) { if ( faster ) { current Resolution -= _ NUM ; } else { current Resolution += _ NUM ; } current Resolution =  Math . max ( current Resolution , _ NUM ) ; current Resolution =  Math . min ( current Resolution , _ NUM ) ; start Timer ( current Resolution ) ; }
public static  Array List <  Product Status Bean > search Products (  Properties ctx , int ad Org Id ,  String name Search ,  String desc Search ,  String trx Name ) throws  Operation Exception { int price List Id =  POSTerminal Manager . get SOPrice List Id ( ctx ) ; int warehouse Id =  POSTerminal Manager . get Warehouse Id ( ctx ) ; return search Products ( ctx , ad Org Id , name Search , desc Search , price List Id , warehouse Id , trx Name ) ; }
public static byte [ ] pattern To Hash (  List <  Lock Pattern View .  Cell > pattern ) { if ( pattern == null ) { return null ; } else { int size = pattern . size ( ) ; byte [ ] res = new byte [ size ] ; for ( int i = _ NUM ; i < size ; i ++ ) {  Lock Pattern View .  Cell cell = pattern . get ( i ) ; res [ i ] = ( byte ) cell . get Index ( ) ; }  Message Digest md = null ; try { md =  Message Digest . get Instance ( _ STR ) ; return md . digest ( res ) ; } catch (  No Such Algorithm Exception e ) { e . print Stack Trace ( ) ; return res ; } } }
public  List <  Object > serialize ( ) {  List <  Object > serialized = new  Array List < > ( ) ; serialized . add ( actions ) ; serialized . add ( timestamps ) ;  List <  Object > serialized Funnel Steps = new  Array List < > ( ) ; for (  Set e : funnel Steps ) { serialized Funnel Steps . add All ( e ) ; serialized Funnel Steps . add ( null ) ; } serialized . add ( serialized Funnel Steps ) ; return serialized ; }
public static  String rename (  String desc ,  String oldname ,  String newname ) { if ( desc . index Of ( oldname ) < _ NUM ) return desc ;  String Buffer newdesc = new  String Buffer ( ) ; int head = _ NUM ; int i = _ NUM ; for ( ; ; ) { int j = desc . index Of ( _ STR , i ) ; if ( j < _ NUM ) break ; else if ( desc . starts With ( oldname , j + _ NUM ) && desc . char At ( j + oldname . length ( ) + _ NUM ) == _ STR ) { newdesc . append ( desc . substring ( head , j ) ) ; newdesc . append ( _ STR ) ; newdesc . append ( newname ) ; newdesc . append ( _ STR ) ; head = i = j + oldname . length ( ) + _ NUM ; } else { i = desc . index Of ( _ STR , j ) + _ NUM ; if ( i < _ NUM ) break ; } } if ( head == _ NUM ) return desc ; else { int len = desc . length ( ) ; if ( head < len ) newdesc . append ( desc . substring ( head , len ) ) ; return newdesc . to String ( ) ; } }
public  Filter Pred (  Filter Pred Clause clause ) { clauses . add ( clause ) ; }
public static void stream Content To Browser (  Http Servlet Response response , byte [ ] bytes ,  String content Type ,  String file Name ) throws  IOException { set Response Browser Proxy No Cache ( response ) ; response . set Content Length ( bytes . length ) ; if ( content Type != null ) { response . set Content Type ( content Type ) ; } if ( file Name != null ) { response . set Header ( _ STR , _ STR + file Name ) ; }  Output Stream out = response . get Output Stream ( ) ;  Input Stream in = new  Byte Array Input Stream ( bytes ) ; try { stream Content ( out , in , bytes . length ) ; } catch (  IOException e ) { in . close ( ) ; out . close ( ) ; throw e ; } in . close ( ) ; out . flush ( ) ; out . close ( ) ; }
public void put And Unlock (  Object key ,  Object value ) {  String uid =  String . value Of ( key ) ;  Transaction tr = locked UIDHash Map . get ( uid ) ; if ( tr == null ) { map . put ( key , value , null ,  Integer .  MAX_ VALUE ) ; return ; } try { map . put ( key , value , tr ,  Integer .  MAX_ VALUE ) ; tr . commit ( ) ; } catch (  Throwable t ) { logger . warn ( _ STR + key + _ STR , t ) ; } finally { locked UIDHash Map . remove ( uid ) ; } }
private  Option Scan Node build Tree From Node List (  List <  Option Scan Node > node List , int tree Node Type ,  Option Scan Node last Scan Node ) { if ( node List . size ( ) == m Degree ) { node List . add ( last Scan Node ) ;  List <  Option Scan Node > children = node List . sub List ( _ NUM , node List . size ( ) - _ NUM ) ;  Option Scan Node last Child = create Tree ( node List . sub List ( node List . size ( ) - _ NUM , node List . size ( ) ) , tree Node Type ) ; children . add ( last Child ) ; return create Tree ( children , tree Node Type ) ; } else if ( node List . size ( ) < m Degree ) { node List . add ( last Scan Node ) ; return create Tree ( node List , tree Node Type ) ; } else {  List <  Option Scan Node > subtrees = new  Array List < > ( ) ; int elem Num = node List . size ( ) / m Degree ; int elem Remainder = node List . size ( ) % m Degree ; int start Index = _ NUM , end Index = _ NUM ;  List <  Option Scan Node > subtree Nodes ; while ( start Index < node List . size ( ) ) { end Index = ( elem Remainder > _ NUM ) ? end Index + elem Num + _ NUM : end Index + elem Num ; elem Remainder -- ; subtree Nodes = new  Array List < > ( node List . sub List ( start Index , end Index ) ) ; if ( ( subtree Nodes . size ( ) == _ NUM ) && ( end Index < node List . size ( ) ) ) { subtrees . add ( subtree Nodes . get ( _ NUM ) ) ; } else { subtrees . add ( build Tree From Node List ( subtree Nodes , tree Node Type , last Scan Node ) ) ; } start Index = end Index ; } return create Tree ( subtrees , tree Node Type ) ; } }
public void wait For Schema Agreement (  String target Schema Version , int node Count ) { long start =  System . current Time Millis ( ) ;  Map <  String ,  List <  String > > versions = null ; while (  System . current Time Millis ( ) - start <  MAX_ SCHEMA_ WAIT_ MS ) { log . info ( _ STR , target Schema Version , node Count ) ; versions = get Schema Versions ( ) ; if ( versions . size ( ) == _ NUM ) { if ( ! versions . contains Key ( target Schema Version ) ) { log . warn ( _ STR , versions , target Schema Version ) ; return ; } if ( node Count != - _ NUM ) {  List <  String > hosts = null ; for (  Entry <  String ,  List <  String > > entry : versions . entry Set ( ) ) { hosts = entry . get Value ( ) ; } if ( hosts != null && hosts . size ( ) == node Count ) { log . info ( _ STR , target Schema Version , node Count ) ; return ; } } else { log . info ( _ STR , target Schema Version ) ; return ; } } log . info ( _ STR ) ; try {  Thread . sleep (  SCHEMA_ RETRY_ SLEEP_ MILLIS ) ; } catch (  Interrupted Exception ex ) { } } log . warn ( _ STR , versions ) ; }
public void clear ( ) { m Search Results . clear ( ) ; m All Songs . clear ( ) ; m All Artists . clear ( ) ; m All Playlists . clear ( ) ; m All Albums . clear ( ) ; m Sorted Songs . clear ( ) ; m Sorted Artists . clear ( ) ; m Sorted Playlists . clear ( ) ; m Sorted Albums . clear ( ) ; }
@  Override protected void build Sprites (  IEntity entity , final  Map <  Object ,  Sprite > map ) { final  Sprite Store store =  Sprite Store . get ( ) ;  Zone Info info =  Zone Info . get ( ) ; final  Sprite tiles = store . get Modified Sprite ( _ STR + entity . get Entity Class ( ) + _ STR , info . get Zone Color ( ) , info . get Color Method ( ) ) ; final int theight = tiles . get Height ( ) ; int i = _ NUM ; for ( int y = _ NUM ; y < theight ; y +=  IGame Screen .  SIZE_ UNIT_ PIXELS ) { map . put (  Integer . value Of ( i ++ ) , store . get Tile ( tiles , _ NUM , y ,  IGame Screen .  SIZE_ UNIT_ PIXELS ,  IGame Screen .  SIZE_ UNIT_ PIXELS ) ) ; } }
public static  String comparable Qualifier (  String qualifier ) { int i = _ QUALIFIERS . index Of ( qualifier ) ; return i == - _ NUM ? ( _ QUALIFIERS . size ( ) + _ STR + qualifier ) :  String . value Of ( i ) ; }
public static  Object evaluate (  Object context ,  Object self ,  String expr ,  List <  String > engine Configs ) throws  Draft3 Expression Exception {  String trimmed Expr =  String Utils . trim ( expr ) ; if ( trimmed Expr . starts With ( _ STR ) ) { trimmed Expr = trimmed Expr . substring ( _ NUM ) ; }  String function = trimmed Expr ; if ( trimmed Expr . starts With ( _ STR ) ) { function = _ STR ; function = function . replace ( _ STR , trimmed Expr ) ; }  Context cx =  Context . enter ( ) ; cx . set Optimization Level (  OPTIMIZATION_ LEVEL ) ; cx . set Maximum Interpreter Stack Depth (  MAX_ STACK_ DEPTH ) ; cx . set Class Shutter ( new  Draft3 Expression Deny All Class Shutter ( ) ) ; try {  Scriptable global Scope = cx . init Standard Objects ( ) ; if ( engine Configs != null ) { for ( int i = _ NUM ; i < engine Configs . size ( ) ; i ++ ) {  Reader engine Config Reader = new  String Reader ( engine Configs . get ( i ) ) ; cx . evaluate Reader ( global Scope , engine Config Reader , _ STR + i + _ STR , _ NUM , null ) ; } } put To Scope (  EXPR_ CONTEXT_ NAME , context , cx , global Scope ) ; put To Scope (  EXPR_ SELF_ NAME , self , cx , global Scope ) ;  Scriptable result Scope = cx . new Object ( global Scope ) ; result Scope . set Prototype ( global Scope ) ; result Scope . set Parent Scope ( global Scope ) ;  Object result = cx . evaluate String ( result Scope , function , _ STR , _ NUM , null ) ; if ( result == null || result instanceof  Undefined ) { return null ; }  Object wrapped Result =  Context . java To JS ( result , global Scope ) ; put To Scope ( _ STR , wrapped Result , cx , global Scope ) ;  Scriptable Object . put Property ( global Scope , _ STR , wrapped Result ) ;  String final Function = _ STR + _ STR + _ STR + _ STR + _ STR ;  Scriptable wrap Scope = cx . new Object ( global Scope ) ; wrap Scope . set Prototype ( global Scope ) ; wrap Scope . set Parent Scope ( global Scope ) ; result = cx . evaluate String ( wrap Scope , final Function , _ STR , _ NUM , null ) ; return cast Result ( result ) ; } catch (  Exception e ) {  String msg =  String . format ( _ STR , expr ) ; throw new  Draft3 Expression Exception ( msg , e ) ; } finally {  Context . exit ( ) ; } }
private  Parse Node [ ] parse Args (  Entry in Entry , char close ) throws  Configuration Exception ,  IOException {  List args = new  Array List ( _ NUM ) ; int t = st . next Token ( ) ; boolean array Args = close == _ STR ; if ( t != close ) { if ( t == _ STR && array Args ) { t = st . next Token ( ) ; if ( t != close ) { syntax ( _ STR + close + _ STR ) ; } } else { st . push Back ( ) ; while ( _ BOOL ) { args . add ( parse Expr ( in Entry ) ) ; t = st . next Token ( ) ; if ( t == close ) { break ; } else if ( t != _ STR ) { syntax ( _ STR + close + _ STR ) ; } else if ( array Args ) { t = st . next Token ( ) ; if ( t == close ) { break ; } else { st . push Back ( ) ; } } } } } return (  Parse Node [ ] ) args . to Array ( new  Parse Node [ args . size ( ) ] ) ; }
public static boolean is File URL (  URL url ) {  String protocol = url . get Protocol ( ) ; return (  URL_ PROTOCOL_ FILE . equals ( protocol ) ||  URL_ PROTOCOL_ VFSFILE . equals ( protocol ) ||  URL_ PROTOCOL_ VFS . equals ( protocol ) ) ; }
public boolean equals (  Object o ) { if ( o instanceof  LDAPGroups ) {  LDAPGroups g = (  LDAPGroups ) o ; if ( ( selected Group DNs != null ) && ( g . selected Group DNs != null ) && ( selected Group DNs . equals ( g . selected Group DNs ) ) ) { return _ BOOL ; } } return _ BOOL ; }
private void apply Set Timestamp (  Long timestamp ) throws  SQLException { if ( timestamp != null && conn . supports Control Timestamp ( ) ) { if ( timestamp . long Value ( ) != current Timestamp ) { current Timestamp = timestamp . long Value ( ) ; statement . add Batch ( conn . get Control Timestamp Query ( timestamp ) ) ; } } }
public  Object invoke (  String method Name ,  Class [ ] types ,  Object [ ] arguments ) {  Method method = null ; try { method = f Class . get Declared Method ( method Name , types ) ; } catch (  Security Exception e ) { fail ( ) ; } catch (  No Such Method Exception ex ) { fail ( ) ; }  Assert . is Not Null ( method ) ; method . set Accessible ( _ BOOL ) ; try { return method . invoke ( f Instance , arguments ) ; } catch (  Illegal Argument Exception e ) { fail ( ) ; } catch (  Invocation Target Exception e ) { fail ( ) ; } catch (  Illegal Access Exception e ) { fail ( ) ; } return null ; }
public static  List <  Base Mqtt Message > process Message Log ( final  List <  Logged Mqtt Message > list , final  Progress Updater progress , final long current , final long max ) { final  List <  Base Mqtt Message > mqtt Message List = new  Array List <  Base Mqtt Message > ( ) ; long item = _ NUM ; for ( final  Logged Mqtt Message logged Message : list ) { if ( progress != null ) { if ( progress . is Cancelled ( ) ) { logger . info ( _ STR ) ; return null ; } item ++ ; if ( item % _ NUM == _ NUM ) { progress . update ( current + item , max ) ; } } mqtt Message List . add ( convert To Base Mqtt Message ( logged Message ) ) ; } logger . info ( _ STR , list . size ( ) ) ; return mqtt Message List ; }
public void start ( final  Char Sequence message ) { if ( message != null ) logger . log ( priority , message ) ; start = last Log =  System . current Time Millis ( ) ; count = _ NUM ; stop = - _ NUM ; }
public void add Row (  Object [ ] row ) throws  Carbon Sort Key And Group By Exception { int current Size = entry Count ; if ( sort Buffer Size == current Size ) {  LOGGER . debug ( _ STR ) ; intermediate File Merger . start Merging If Possible ( ) ;  Object [ ] [ ] record Holder List Local = record Holder List ; try { semaphore . acquire ( ) ; data Sorter And Writer Executor Service . submit ( new  Data Sorter And Writer ( record Holder List Local ) ) ; } catch (  Interrupted Exception e ) {  LOGGER . error ( _ STR + e . get Message ( ) ) ; throw new  Carbon Sort Key And Group By Exception ( e . get Message ( ) ) ; } this . record Holder List = new  Object [ this . sort Buffer Size ] [ ] ; this . entry Count = _ NUM ; } record Holder List [ entry Count ++ ] = row ; }
public static void dump Stack (  Address fp ) { if (  VM .  Verify Assertions ) {  VM . _assert (  VM . running VM ) ; }  Address ip =  Magic . get Return Address ( fp ) ; fp =  Magic . get Caller Frame Pointer ( fp ) ; dump Stack ( ip , fp ) ; }
@  Override public  Path Impl scheme Walk (  String user Path ,  Map <  String ,  Object > attributes ,  String file Path , int offset ) {  String canonical Path = file Path ; if ( offset < file Path . length ( ) && file Path . char At ( offset ) == _ STR ) { } else { canonical Path = normalize Path ( _pathname , file Path , offset , _separator Char ) ; } return fs Walk ( user Path , attributes , canonical Path ) ; }
public static boolean is Mime Type Image (  String mime Type ) { if ( mime Type . equals (  Const .  Content Types .  IMAGE_ GIF ) ) { return _ BOOL ; } else if ( mime Type . equals (  Const .  Content Types .  IMAGE_ JPG ) ) { return _ BOOL ; } else if ( mime Type . equals (  Const .  Content Types .  IMAGE_ PNG ) ) { return _ BOOL ; } return _ BOOL ; }
public  FXDialog ( final  Stage parent , final  Modality modality , final  Parent content , final double width , final double height ) { init ( parent , modality , content ) ; dialog . set Width ( width ) ; dialog . set Height ( height ) ; final  Scene scene = new  Scene ( content , width , height ) ; set Scene ( scene ) ; }
public static  Matrix construct With Copy ( double [ ] [ ]  A ) { int m =  A . length ; int n =  A [ _ NUM ] . length ;  Matrix  X = new  Matrix ( m , n ) ; double [ ] [ ]  C =  X . get Array ( ) ; for ( int i = _ NUM ; i < m ; i ++ ) { if (  A [ i ] . length != n ) { throw new  Illegal Argument Exception ( _ STR ) ; } for ( int j = _ NUM ; j < n ; j ++ ) {  C [ i ] [ j ] =  A [ i ] [ j ] ; } } return  X ; }
public void remove Attribute (  String attr Name ,  String value ) throws  SMSException {  Set attr = null ; if ( ( attr Set == null ) || ( ( attr = (  Set ) attr Set . get ( attr Name ) ) == null ) || ( ! attr . contains ( value ) ) ) { throw ( new  SMSException (  Ldap Exception . new Ldap Exception (  Result Code .  ATTRIBUTE_ OR_ VALUE_ EXISTS , get Bundle String (  IUMSConstants .  SMS_ ATTR_ OR_ VAL_ EXISTS ) ) , _ STR ) ) ; } attr . remove ( value ) ; attr Set . put ( attr Name , attr ) ; if ( mod Set == null ) { mod Set = new  Hash Set ( ) ; } mod Set . add ( new  Modification Item (  Dir Context .  REMOVE_ ATTRIBUTE , new  Basic Attribute ( attr Name , value ) ) ) ; }
public static int compile Shader ( final int shader Type , final  String shader Source ) { int shader Handle =  GLES20 . gl Create Shader ( shader Type ) ; if ( shader Handle != _ NUM ) {  GLES20 . gl Shader Source ( shader Handle , shader Source ) ;  GLES20 . gl Compile Shader ( shader Handle ) ; final int [ ] compile Status = new int [ _ NUM ] ;  GLES20 . gl Get Shaderiv ( shader Handle ,  GLES20 .  GL_ COMPILE_ STATUS , compile Status , _ NUM ) ; if ( compile Status [ _ NUM ] == _ NUM ) {  Log . e (  TAG , _ STR +  GLES20 . gl Get Shader Info Log ( shader Handle ) ) ;  GLES20 . gl Delete Shader ( shader Handle ) ; shader Handle = _ NUM ; } } if ( shader Handle == _ NUM ) { throw new  Runtime Exception ( _ STR ) ; } return shader Handle ; }
private void add Node (  Node node ) throws  Sync Exception {  Short node Id = node . get Node Id ( ) ; if ( all Nodes . get ( node Id ) != null ) { throw new  Sync Exception ( _ STR + node + _ STR ) ; } all Nodes . put ( node Id , node ) ;  Short domain Id = node . get Domain Id ( ) ;  List <  Node > local Domain = local Domains . get ( domain Id ) ; if ( local Domain == null ) { local Domains . put ( domain Id , local Domain = new  Array List <  Node > ( ) ) ; } local Domain . add ( node ) ; }
public  Image rotate90 Degrees (  Image image , boolean maintain Opacity ) { int [ ] rgb = image . get RGB ( ) ; int [ ] new RGB = new int [ rgb . length ] ; int width = image . get Width ( ) ; int height = image . get Height ( ) ; for ( int y = _ NUM ; y < height ; y ++ ) { for ( int x = _ NUM ; x < width ; x ++ ) { int dest X = height - y - _ NUM ; new RGB [ dest X + x * height ] = rgb [ x + y * width ] ; } } return  Encoded Image . create From RGB ( new RGB , height , width , ! maintain Opacity ) ; }
@  Override public void fire (  Connection conn ,  Object [ ] old Row ,  Object [ ] new Row ) throws  SQLException {  Big Decimal diff = null ; if ( new Row != null ) { diff = (  Big Decimal ) new Row [ _ NUM ] ; } if ( old Row != null ) {  Big Decimal m = (  Big Decimal ) old Row [ _ NUM ] ; diff = diff == null ? m . negate ( ) : diff . subtract ( m ) ; }  Prepared Statement prep = conn . prepare Statement ( _ STR ) ; prep . set Big Decimal ( _ NUM , diff ) ; prep . execute ( ) ; }
private boolean cmd_save ( ) { log . config ( _ STR ) ;  Calendar date = new  Gregorian Calendar ( ) ; get Date And Time From ( date ) ;  Timestamp assign Date From = new  Timestamp ( date . get Time In Millis ( ) ) ;  Big Decimal qty = f Qty . get Value ( ) ;  List Item list Item = f Resource . get Selected Item ( ) ;  Key Name Pair resource = list Item != null ? new  Key Name Pair ( (  Integer ) list Item . get Value ( ) , list Item . get Label ( ) ) : null ;  Key Name Pair uom = (  Key Name Pair ) m_lookup . get ( resource ) ; int minutes =  MUOMConversion . convert To Minutes (  Env . get Ctx ( ) , uom . get Key ( ) , qty ) ;  Timestamp assign Date To =  Time Util . add Minutess ( assign Date From , minutes ) ; m_m Assignment . set Assign Date To ( assign Date To ) ; return m_m Assignment . save ( ) ; }
private  General Path to Path (  Coordinate [ ] coordinates ) {  General Path path = new  General Path (  General Path .  WIND_ EVEN_ ODD , coordinates . length ) ; if ( coordinates . length > _ NUM ) { path . move To ( ( float ) coordinates [ _ NUM ] . x , ( float ) coordinates [ _ NUM ] . y ) ; for ( int i = _ NUM ; i < coordinates . length ; i ++ ) { path . line To ( ( float ) coordinates [ i ] . x , ( float ) coordinates [ i ] . y ) ; } } return path ; }
public final synchronized boolean close When Possible ( ) throws  IOException { do Close . set ( _ BOOL ) ; if ( reading Count . get ( ) == _ NUM ) { close ( ) ; } return closed . get ( ) ; }
@  Override public boolean connection Allowed (  String event Name ) { if ( ! event Name . equals ( _ STR ) && ! event Name . equals ( _ STR ) && ! event Name . equals ( _ STR ) && ! event Name . equals ( _ STR ) ) { return _ BOOL ; } if ( m_listenee != null ) { return _ BOOL ; } return _ BOOL ; }
public void add Flakes ( int quantity ) { for ( int i = _ NUM ; i < quantity ; ++ i ) { flakes . add (  Flake . create Flake ( get Width ( ) , droid , get Context ( ) ) ) ; } set Num Flakes ( num Flakes + quantity ) ; }
public boolean not Required Resource Name (  Policy policy ,  String realm Name ,  String name ) { get Svc Type Name To Actions Map ( policy , realm Name ) ; return not Required Resource Name Service . contains ( name ) ; }
public static void main (  String ... args ) throws  SQLException {  Self Destructor . start Countdown ( _ NUM ) ; if ( args . length == _ NUM ) {  System . exit ( _ NUM ) ; }  String url = args [ _ NUM ] ;  Test Exit . execute ( url ) ; }
protected  String r (  String s ,  String u ) throws  Exception {  Date dt =  Date Math Parser . parse Math ( null , s + _ STR + u ) ; return fmt . format ( dt . to Instant ( ) ) ; }
public static boolean contains Entry (  File file ,  String entry Path ) { if ( file . can Read ( ) ) { try {  Jar File jar File = new  Jar File ( file ) ; try { return jar File . get Entry ( entry Path ) != null ; } finally { jar File . close ( ) ; } } catch (  IOException ignored ) { } } return _ BOOL ; }
public static boolean validate Email List (  String value ) {  String [ ] emails = value . split ( _ STR ) ; for (  String email : emails ) { if ( validate Email ( email . trim ( ) ) == _ BOOL ) { return _ BOOL ; } } return _ BOOL ; }
public void log It (  String [ ] s , int type ,  String message Name ,  Hashtable sso Properties ) { if ( log Status && ( s != null ) ) { try {  Log Message Provider Base provider = (  Log Message Provider Base )  Message Provider Factory . get Provider ( _ STR ) ; com . sun . identity . log .  Log Record lr = null ;  SSOToken ssot =  Access Controller . do Privileged (  Admin Token Action . get Instance ( ) ) ; if ( sso Properties == null ) { lr = provider . create Log Record ( message Name , s , ssot ) ; } else { lr = provider . create Log Record ( message Name , s , sso Properties ) ; } com . sun . identity . log .  Logger logger ; switch ( type ) { case  LOG_ ACCESS : logger = ( com . sun . identity . log .  Logger )  Logger . get Logger ( _ STR ) ; logger . log ( lr , ssot ) ; break ; case  LOG_ ERROR : logger = ( com . sun . identity . log .  Logger )  Logger . get Logger ( _ STR ) ; logger . log ( lr , ssot ) ; break ; default : logger = ( com . sun . identity . log .  Logger )  Logger . get Logger ( _ STR ) ; logger . log ( lr , ssot ) ; break ; } } catch (  IOException ex ) { ex . print Stack Trace ( ) ; debug . error ( _ STR + ex . get Message ( ) ) ; } } }
public static boolean is Digit (  Character self ) { return  Character . is Digit ( self ) ; }
private static  String massage URI (  String uri ) { uri = uri . trim ( ) ; int protocol End = uri . index Of ( _ STR ) ; if ( protocol End < _ NUM ) { uri = _ STR + uri ; } else if ( is Colon Followed By Port Number ( uri , protocol End ) ) { uri = _ STR + uri ; } return uri ; }
private boolean is Identifier (  String token ) { int size = token . length ( ) ; for ( int i = _ NUM ; i < size ; i ++ ) { char c = token . char At ( i ) ; if ( is Operator ( c ) ) return _ BOOL ; } if ( token . starts With ( _ STR ) && token . ends With ( _ STR ) ) return _ BOOL ; else { try { new  Big Decimal ( token ) ; return _ BOOL ; } catch (  Number Format Exception e ) { } } if ( is SQLFunctions ( token ) ) return _ BOOL ; return _ BOOL ; }
public void initialize Reference (  Object conc_object ) { if ( this . is Initialized ) { throw new  Illegal State Exception ( _ STR ) ; } this . concrete Value = conc_object ; this . conc Identity Hash Code =  System . identity Hash Code ( conc_object ) ; this . is Initialized = _ BOOL ; }
static  Part from (  String encoded ,  String decoded ) { if ( encoded == null ) { return  NULL ; } if ( encoded . length ( ) == _ NUM ) { return  EMPTY ; } if ( decoded == null ) { return  NULL ; } if ( decoded . length ( ) == _ NUM ) { return  EMPTY ; } return new  Part ( encoded , decoded ) ; }
public static  String node Sub Type To String ( int sub Type ) {  String val = _ STR ; switch ( sub Type ) { case  Node Representation .  AND_ TYPE : val = _ STR ; break ; case  Node Representation .  OR_ TYPE : val = _ STR ; break ; case  Node Representation .  IMPLIES_ TYPE : val = _ STR ; break ; case  Node Representation .  FORALL_ TYPE : val = _ STR ; break ; case  Node Representation .  EXISTS_ TYPE : val = _ STR ; break ; case  Node Representation .  SQSUB_ TYPE : val = _ STR ; break ; case  Node Representation .  OTHER_ TYPE : val = _ STR ; break ; } return val ; }
@  Override public  Vector what Can Go Here ( int [ ] state ) { int cur State = state [ _ NUM ] ; if ( cur State < _ NUM ) cur State = state [ _ NUM ] ;  Occurence o = ( f Counting States != null ) ? f Counting States [ cur State ] : null ; int count = state [ _ NUM ] ;  Vector ret = new  Vector ( ) ; for ( int elem Index = _ NUM ; elem Index < f Elem Map Size ; elem Index ++ ) { int next State = f Trans Table [ cur State ] [ elem Index ] ; if ( next State != - _ NUM ) { if ( o != null ) { if ( cur State == next State ) { if ( count >= o . max Occurs && o . max Occurs !=  Schema Symbols .  OCCURRENCE_ UNBOUNDED ) { continue ; } } else if ( count < o . min Occurs ) { continue ; } } ret . add Element ( f Elem Map [ elem Index ] ) ; } } return ret ; }
public boolean remove ( int location ,  Image Info object ) { final boolean removed = data . remove ( object ) ; notify Item Range Removed ( location , data . size ( ) ) ; return removed ; }
public  Secure Random Pool (  String algorithm , int pool Size ,  Secure Random seed ) { if ( algorithm == null ) { throw new  Illegal Argument Exception ( _ STR ) ; } pool = new  Array List <  Secure Random > ( pool Size ) ; seed Source = get Seed Source ( algorithm , ( seed != null ) ? seed : new  Secure Random ( ) ) ; try { for ( int i = _ NUM ; i < pool Size ; i ++ ) { byte [ ] seed Bytes = new byte [ _ NUM ] ; seed Source . next Bytes ( seed Bytes ) ;  Secure Random random =  Secure Random . get Instance ( algorithm ) ; random . set Seed ( seed Bytes ) ; pool . add ( random ) ; } } catch (  No Such Algorithm Exception e ) {  String msg = _ STR + algorithm + _ STR ; log . error ( msg , e ) ; throw new  Runtime Exception ( msg , e ) ; } }
public static void check Field Value From Enum ( final  String value , final  String field Name ,  Class < ? extends  Enum > enum Type ) { if ( value != null ) { check Field Value From Enum ( value , field Name ,  Enum Set . all Of ( enum Type ) ) ; } }
public void remove Events ( ) { scene . set On Key Pressed ( null ) ; scene . set On Key Released ( null ) ; up = down = left = right = sprint = jump = shoot Fireball = _ BOOL ; }
public void write Collection State (  URI backup Loc ,  String backup Id ,  String collection Name ,  Doc Collection collection State ) throws  IOException {  URI dest = repository . resolve ( backup Loc , backup Id ,  ZK_ STATE_ DIR ,  COLLECTION_ PROPS_ FILE ) ; try (  Output Stream collection State Os = repository . create Output ( dest ) ) { collection State Os . write (  Utils . to JSON (  Collections . singleton Map ( collection Name , collection State ) ) ) ; } }
static public void fill Random Uniform (  IDouble Vector vec ,  Random rand , double min , double max ) { final double delta = max - min ; for ( int i = _ NUM ; i < vec . get Length ( ) ; ++ i ) { vec . set ( i , min + rand . next Double ( ) * delta ) ; } }
public static void dump (  Result Set rs ) throws  SQLException {  Result Set Meta Data md = rs . get Meta Data ( ) ; for ( int i = _ NUM ; i < md . get Column Count ( ) ; i ++ ) { int index = i + _ NUM ;  String info = md . get Column Label ( index ) ;  String name = md . get Column Name ( index ) ; if ( info == null ) info = name ; else if ( name != null && ! name . equals ( info ) ) info += _ STR + name + _ STR ; info += _ STR + rs . get String ( index ) ; info += _ STR + md . get Column Type Name ( index ) + _ STR + md . get Precision ( index ) ; if ( md . get Scale ( index ) != _ NUM ) info += _ STR + md . get Scale ( index ) ; info += _ STR ; log . fine ( info ) ; } }
public  Rule Net add (  String p_name , int p_subnet_number , boolean p_contains_plane ) { int new_net_no = net_list . size ( ) + _ NUM ; if ( new_net_no >= max_legal_net_no ) throw new  Illegal Argument Exception ( _ STR ) ;  Rule Net new_net = new  Rule Net ( p_name , p_subnet_number , new_net_no , this , p_contains_plane ) ; net_list . add ( new_net ) ; return new_net ; }
protected void draw Range Markers (  Graphics2 D g2 ,  Rectangle2 D data Area , int index ,  Layer layer ) {  Category Item Renderer r = get Renderer ( index ) ; if ( r == null ) { return ; }  Collection markers = get Range Markers ( index , layer ) ;  Value Axis axis = get Range Axis For Dataset ( index ) ; if ( markers != null && axis != null ) {  Iterator iterator = markers . iterator ( ) ; while ( iterator . has Next ( ) ) {  Marker marker = (  Marker ) iterator . next ( ) ; r . draw Range Marker ( g2 , this , axis , marker , data Area ) ; } } }
public  VPFFeature Layer ( ) { set Projection Change Policy ( new com . bbn . openmap . layer . policy .  List Reset PCPolicy ( this ) ) ; set Mouse Mode IDs For Events ( new  String [ ] { _ STR } ) ; warehouse = new  VPFAuto Feature Graphic Warehouse ( ) ; }
protected void release (  Pooled Connection con ) { if ( con == null ) return ; try { con . lock ( ) ; if ( con . release ( ) ) { size . add And Get ( - _ NUM ) ; con . set Handler ( null ) ; } } finally { con . unlock ( ) ; } if ( waitcount . get ( ) > _ NUM ) { idle . offer ( create ( _ BOOL ) ) ; } }
private static float [ ] rgb To HLS ( int rgb , float [ ] hls ) { float r = ( ( rgb & _ NUM ) > > _ NUM ) / _ NUM ; float g = ( ( rgb & _ NUM ) > > _ NUM ) / _ NUM ; float b = ( rgb & _ NUM ) / _ NUM ; float max =  Math . max (  Math . max ( r , g ) , b ) ; float min =  Math . min (  Math . min ( r , g ) , b ) ; float l = ( max + min ) / _ NUM ; float s = _ NUM ; float h = _ NUM ; if ( max != min ) { float delta = max - min ; s = ( l <= _ NUM ) ? ( delta / ( max + min ) ) : ( delta / ( _ NUM - max - min ) ) ; if ( r == max ) { h = ( g - b ) / delta ; } else if ( g == max ) { h = _ NUM + ( b - r ) / delta ; } else { h = _ NUM + ( r - g ) / delta ; } h *= _ NUM ; if ( h < _ NUM ) { h += _ NUM ; } } if ( hls == null ) { hls = new float [ _ NUM ] ; } hls [ _ NUM ] = h ; hls [ _ NUM ] = l ; hls [ _ NUM ] = s ; return hls ; }
private static  Future < ? > direct Execute (  Runnable runnable , long delay ) {  Future < ? > future = null ; if ( delay > _ NUM ) { if ( ! ( executor instanceof  Scheduled Executor Service ) ) { throw new  Illegal Argument Exception ( _ STR ) ; }  Scheduled Executor Service scheduled Executor Service = (  Scheduled Executor Service ) executor ; future = scheduled Executor Service . schedule ( runnable , delay ,  Time Unit .  MILLISECONDS ) ; } else { if ( executor instanceof  Executor Service ) {  Executor Service executor Service = (  Executor Service ) executor ; future = executor Service . submit ( runnable ) ; } else { executor . execute ( runnable ) ; } } return future ; }
public long file Size (  String path ) throws  Illegal State Exception ,  IOException ,  FTPIllegal Reply Exception ,  FTPException { synchronized ( lock ) { if ( ! connected ) { throw new  Illegal State Exception ( _ STR ) ; } if ( ! authenticated ) { throw new  Illegal State Exception ( _ STR ) ; } communication . send FTPCommand ( _ STR ) ;  FTPReply r = communication . read FTPReply ( ) ; touch Auto Noop Timer ( ) ; if ( ! r . is Success Code ( ) ) { throw new  FTPException ( r ) ; } communication . send FTPCommand ( _ STR + path ) ; r = communication . read FTPReply ( ) ; touch Auto Noop Timer ( ) ; if ( ! r . is Success Code ( ) ) { throw new  FTPException ( r ) ; }  String [ ] messages = r . get Messages ( ) ; if ( messages . length != _ NUM ) { throw new  FTPIllegal Reply Exception ( ) ; } else { try { return  Long . parse Long ( messages [ _ NUM ] ) ; } catch (  Throwable t ) { throw new  FTPIllegal Reply Exception ( ) ; } } } }
protected void write Column Default Value Stmt (  Table table ,  Column column ,  String Builder ddl ) {  Object parsed Default = column . get Parsed Default Value ( ) ; if ( parsed Default != null ) { if ( ! database Info . is Default Values For Long Types Supported ( ) && ( ( column . get Mapped Type Code ( ) ==  Types .  LONGVARBINARY ) || ( column . get Mapped Type Code ( ) ==  Types .  LONGVARCHAR ) ) ) { throw new  Model Exception ( _ STR ) ; } if ( is Valid Default Value ( column . get Default Value ( ) , column . get Mapped Type Code ( ) ) ) { ddl . append ( _ STR ) ; write Column Default Value ( table , column , ddl ) ; } } else if ( database Info . is Default Value Used For Identity Spec ( ) && column . is Auto Increment ( ) ) { ddl . append ( _ STR ) ; write Column Default Value ( table , column , ddl ) ; } else if ( !  String Utils . is Blank ( column . get Default Value ( ) ) ) { ddl . append ( _ STR ) ; write Column Default Value ( table , column , ddl ) ; } }
private boolean start Compact Mode (  String type ) { long time Passed =  System . current Time Millis ( ) - compact Mode Start ; if ( time Passed >  MAX_ COMPACTMODE_ TIME ) { close Compact Mode ( ) ; } if ( ! type . equals ( compact Mode ) ) { close Compact Mode ( ) ; } if ( compact Mode == null ) { compact Mode = type ; compact Mode Start =  System . current Time Millis ( ) ; compact Mode Length = _ NUM ; return _ BOOL ; } return _ BOOL ; }
public <  K ,  V >  Grid Closeable Iterator <  Ignite Bi Tuple <  K ,  V > > query (  String qry ,  Indexing Query Filter filters ) throws  Ignite Checked Exception {  Index Reader reader ; try { long updates = update Cntr . get ( ) ; if ( updates != _ NUM ) { writer . commit ( ) ; update Cntr . add And Get ( - updates ) ; } reader =  Index Reader . open ( writer , _ BOOL ) ; } catch (  IOException e ) { throw new  Ignite Checked Exception ( e ) ; }  Index Searcher searcher = new  Index Searcher ( reader ) ;  Multi Field Query Parser parser = new  Multi Field Query Parser (  Version .  LUCENE_30 , idxd Fields , writer . get Analyzer ( ) ) ;  Filter f = new  Term Range Filter (  EXPIRATION_ TIME_ FIELD_ NAME ,  Date Tools . time To String (  U . current Time Millis ( ) ,  Date Tools .  Resolution .  MILLISECOND ) , null , _ BOOL , _ BOOL ) ;  Top Docs docs ; try { docs = searcher . search ( parser . parse ( qry ) , f ,  Integer .  MAX_ VALUE ) ; } catch (  Exception e ) { throw new  Ignite Checked Exception ( e ) ; }  Ignite Bi Predicate <  K ,  V > fltr = null ; if ( filters != null ) fltr = filters . for Space ( space Name ) ; return new  It < > ( reader , searcher , docs . score Docs , fltr ) ; }
public  String format String ( final  String str To Format ) { if ( str To Format != null ) { if ( str To Format . equals Ignore Case ( _ STR ) ) return _ STR ; final  String valn1 = str To Format . replace All ( _ STR , _ STR ) ; final  String formt Str = valn1 . replace All ( _ STR , _ STR ) ; return formt Str . replace All ( _ STR , _ STR ) ; } else return _ STR ; }
@  Request Mapping ( value = { _ STR , _ STR } , method =  Request Method .  GET ) @  Response Body public  Rest Wrapper list ( @  Request Param ( value = _ STR , default Value = _ STR ) int start Page , @  Request Param ( value = _ STR , default Value = _ STR ) int page Size ,  Principal principal ) {  Rest Wrapper rest Wrapper = null ; try {  List <  Properties Template > get Properties Template = properties Template DAO . list Property Template ( start Page , page Size ) ; rest Wrapper = new  Rest Wrapper ( get Properties Template ,  Rest Wrapper .  OK ) ;  LOGGER . info ( _ STR + principal . get Name ( ) ) ; } catch (  Exception e ) {  LOGGER . error ( e ) ; rest Wrapper = new  Rest Wrapper ( e . get Message ( ) ,  Rest Wrapper .  ERROR ) ; } return rest Wrapper ; }
public static byte [ ] read File (  URL url ) throws  IOException {  Byte Queue q = new  Byte Queue ( ) ;  Input Stream is = url . open Stream ( ) ; try { byte [ ] buf = new byte [ _ NUM ] ; for ( ; ; ) { int bytes Read = is . read ( buf ) ; if ( bytes Read == - _ NUM ) break ; q . put ( buf , _ NUM , bytes Read ) ; } byte [ ] result = new byte [ ( int ) q . get Bytes Written ( ) ] ; q . get ( result ) ; return result ; } finally { is . close ( ) ; } }
public final void open Fallback Output Stream ( ) throws  Data Fallback Exception { if ( output == null ) { if (  LOG . is Debug Enabled ( ) )  LOG . debug ( _ STR + data File . get Name ( ) + _ STR ) ; try { output = new  Buffered Writer ( new  File Writer ( data File , _ BOOL ) ) ; } catch (  IOException e ) { throw new  Data Fallback Exception ( e . get Message ( ) ) ; } } }
public void add Memory Listener ( final  IMemory Listener listener ) {  Preconditions . check Not Null ( listener , _ STR ) ; m_listeners . add ( listener ) ; }
static public  Serial Sensor Manager instance ( ) { if ( _instance == null ) { _instance = new  Serial Sensor Manager ( ) ; } return _instance ; }
private static void verify Device (  IDevice d , long mac ,  Short vlan ,  Integer ip , long sw Id , int port ) { assert Not Null ( d ) ; assert Equals ( mac , d . get MACAddress ( ) ) ; if ( vlan == null ) assert Array Equals ( new  Short [ _ NUM ] , d . get Vlan Id ( ) ) ; else assert Array Equals ( new  Short [ ] { vlan } , d . get Vlan Id ( ) ) ; if ( ip == null ) assert Array Equals ( new  Integer [ _ NUM ] , d . get IPv4 Addresses ( ) ) ; else assert Array Equals ( new  Integer [ ] { ip } , d . get IPv4 Addresses ( ) ) ;  Switch Port expected Ap = new  Switch Port ( sw Id , port ) ; assert Array Equals ( new  Switch Port [ ] { expected Ap } , d . get Attachment Points ( ) ) ; }
public static  String extract Host Id (  String host Id ) {  Assert Util . assert Not Null ( host Id , _ STR ) ; int idx = host Id . index Of (  HOST_ ID_ TENANT_ SEPARATOR ) ;  String id = host Id ; if ( idx != - _ NUM ) { id = host Id . substring ( idx +  HOST_ ID_ TENANT_ SEPARATOR . length ( ) ) ; } return id ; }
public boolean is Free ( long pos , int length ) { int start = get Block ( pos ) ; int blocks = get Block Count ( length ) ; for ( int i = start ; i < start + blocks ; i ++ ) { if ( set . get ( i ) ) { return _ BOOL ; } } return _ BOOL ; }
public  Cholesky Decomposition (  Matrix  Arg ) { double [ ] [ ]  A =  Arg . get Array ( ) ; n =  Arg . get Row Dimension ( ) ;  L = new double [ n ] [ n ] ; isspd = (  Arg . get Column Dimension ( ) == n ) ; for ( int j = _ NUM ; j < n ; j ++ ) { double [ ]  Lrowj =  L [ j ] ; double d = _ NUM ; for ( int k = _ NUM ; k < j ; k ++ ) { double [ ]  Lrowk =  L [ k ] ; double s = _ NUM ; for ( int i = _ NUM ; i < k ; i ++ ) { s +=  Lrowk [ i ] *  Lrowj [ i ] ; }  Lrowj [ k ] = s = (  A [ j ] [ k ] - s ) /  L [ k ] [ k ] ; d = d + s * s ; isspd = isspd & (  A [ k ] [ j ] ==  A [ j ] [ k ] ) ; } d =  A [ j ] [ j ] - d ; isspd = isspd & ( d > _ NUM ) ;  L [ j ] [ j ] =  Math . sqrt (  Math . max ( d , _ NUM ) ) ; for ( int k = j + _ NUM ; k < n ; k ++ ) {  L [ j ] [ k ] = _ NUM ; } } }
public static int read As Int ( byte [ ] bytes , int offset , final int length ) { if ( offset + length > bytes . length ) { throw new  Illegal Argument Exception ( _ STR + offset + _ STR + length + _ STR + _ STR + bytes . length ) ; } int n = _ NUM ; for ( int i = offset ; i < ( offset + length ) ; i ++ ) { n <<= _ NUM ; n ^= bytes [ i ] & _ NUM ; } return n ; }
@  Override public void agg (  Object new Val ) { value Set . add ( new Val instanceof  Double ? (  Double ) new Val : new  Double ( new Val . to String ( ) ) ) ; first Time = _ BOOL ; }
private boolean can Change Announcement (  Legion Member legion Member ,  String announcement ) { return legion Member . has Rights (  Legion Permissions Mask .  EDIT ) && ( announcement . is Empty ( ) || is Valid Announcement ( announcement ) ) ; }
public static char [ ] clone Char Array ( char [ ] chars ) { if ( chars == null ) { return null ; } int len = chars . length ; if ( len == _ NUM ) { return chars ; } char [ ] copy = new char [ len ] ;  System . arraycopy ( chars , _ NUM , copy , _ NUM , len ) ; return copy ; }
public  Set <  Soot Method > resolve Abstract Dispatch (  Soot Class abstract Type ,  Soot Method m ) {  String method Sig = m . get Sub Signature ( ) ;  Hash Set <  Soot Class > resolved = new  Hash Set <  Soot Class > ( ) ;  Hash Set <  Soot Method > ret = new  Hash Set <  Soot Method > ( ) ;  Linked List <  Soot Class > worklist = new  Linked List <  Soot Class > ( ) ; worklist . add ( abstract Type ) ; while ( ! worklist . is Empty ( ) ) {  Soot Class concrete Type = (  Soot Class ) worklist . remove First ( ) ;  Soot Class saved Concrete Type = concrete Type ; if ( concrete Type . is Interface ( ) ) { worklist . add All ( get All Implementers Of Interface ( concrete Type ) ) ; continue ; }  Collection <  Soot Class > c = class To Subclasses . get ( concrete Type ) ; if ( c != null ) worklist . add All ( c ) ; if ( ! concrete Type . is Abstract ( ) ) { while ( _ BOOL ) { if ( resolved . contains ( concrete Type ) ) break ; resolved . add ( concrete Type ) ;  Soot Method method = concrete Type . get Method Unsafe ( method Sig ) ; if ( method != null ) { if ( is Visible ( concrete Type , m ) ) { if ( method . is Abstract ( ) ) throw new  Runtime Exception ( _ STR + abstract Type + _ STR + saved Concrete Type + _ STR + m ) ; else { ret . add ( method ) ; break ; } } } if ( ! concrete Type . has Superclass ( ) ) { if ( concrete Type . is Phantom ( ) ) break ; else throw new  Runtime Exception ( _ STR + abstract Type + _ STR + saved Concrete Type + _ STR + m ) ; } concrete Type = concrete Type . get Superclass ( ) ; } } } return ret ; }
public  String next Token ( ) throws  No Such Element Exception { if ( pos < len && delim . index Of ( str . char At ( pos ) ) >= _ NUM ) { if ( ret Delims ) return str . substring ( pos , ++ pos ) ; while ( ++ pos < len && delim . index Of ( str . char At ( pos ) ) >= _ NUM ) ; } if ( pos < len ) { int start = pos ; while ( ++ pos < len && delim . index Of ( str . char At ( pos ) ) < _ NUM ) ; return str . substring ( start , pos ) ; } throw new  No Such Element Exception ( ) ; }
public synchronized void delete Closed Connections ( ) { final  Iterator iter = free Connections . iterator ( ) ; while ( iter . has Next ( ) ) { final  Http Connection conn = (  Http Connection ) iter . next ( ) ; if ( ! conn . is Open ( ) ) { iter . remove ( ) ; delete Connection ( conn ) ; } } }
public static  String remove Empty Lines (  String text ) { text = text . replace All ( _ STR +  Chinese Language Constants .  SPACE [ _ NUM ] + _ STR , _ STR ) ; text = text . replace All ( _ STR +  Chinese Language Constants .  SPACE [ _ NUM ] + _ STR , _ STR ) ; return text ; }
private boolean step2 ( ) { if (  RV == null ) return _ BOOL ; if (  RV . length ( ) >= _ NUM ) { if ( suffix (  RV , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  RV , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  RV , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  RV , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  RV , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  RV , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } } if (  RV . length ( ) >= _ NUM ) { if ( suffix (  RV , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  RV , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  RV , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  RV , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  RV , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  RV , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  RV , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  RV , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  RV , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  RV , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  RV , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  RV , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  RV , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } } if (  RV . length ( ) >= _ NUM ) { if ( suffix (  RV , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  RV , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  RV , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  RV , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  RV , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  RV , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  RV , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  RV , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  RV , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  RV , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  RV , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  RV , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  RV , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  RV , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  RV , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  RV , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  RV , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  RV , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  RV , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  RV , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  RV , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  RV , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  RV , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  RV , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  RV , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  RV , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  RV , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } } if (  RV . length ( ) >= _ NUM ) { if ( suffix (  RV , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  RV , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  RV , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  RV , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  RV , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  RV , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  RV , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  RV , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  RV , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  RV , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  RV , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  RV , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  RV , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  RV , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  RV , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  RV , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  RV , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  RV , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  RV , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  RV , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  RV , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  RV , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  RV , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  RV , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  RV , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  RV , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  RV , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  RV , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  RV , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  RV , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  RV , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  RV , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  RV , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  RV , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  RV , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  RV , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  RV , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  RV , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  RV , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  RV , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  RV , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } } if (  RV . length ( ) >= _ NUM ) { if ( suffix (  RV , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  RV , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  RV , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  RV , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  RV , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  RV , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  RV , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  RV , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  RV , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  RV , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  RV , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  RV , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  RV , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } } if (  RV . length ( ) >= _ NUM ) { if ( suffix (  RV , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  RV , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  RV , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  RV , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  RV , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  RV , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  RV , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  RV , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  RV , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  RV , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  RV , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  RV , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  RV , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  RV , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } } return _ BOOL ; }
void open ( int context Prec , int own Prec ) throws  IOException { if ( own Prec < context Prec ) out . write ( _ STR ) ; }
public void draw Rendered Image (  Rendered Image img ,  Affine Transform xform ) { if ( img == null ) { return ; } if ( img instanceof  Buffered Image ) {  Buffered Image buf Img = (  Buffered Image ) img ; draw Image ( buf Img , xform , null ) ; return ; } boolean is Integer Translate = ( transform State <=  TRANSFORM_ INT_ TRANSLATE ) && is Integer Translation ( xform ) ; int pad = is Integer Translate ? _ NUM : _ NUM ;  Region clip ; try { clip = get Comp Clip ( ) ; } catch (  Invalid Pipe Exception e ) { return ; }  Rectangle region = get Image Region ( img , clip , transform , xform , pad , pad ) ; if ( region . width <= _ NUM || region . height <= _ NUM ) { return ; } if ( is Integer Translate ) { draw Translated Rendered Image ( img , region , ( int ) xform . get Translate X ( ) , ( int ) xform . get Translate Y ( ) ) ; return ; }  Raster raster = img . get Data ( region ) ;  Writable Raster w Raster =  Raster . create Writable Raster ( raster . get Sample Model ( ) , raster . get Data Buffer ( ) , null ) ; int min X = raster . get Min X ( ) ; int min Y = raster . get Min Y ( ) ; int width = raster . get Width ( ) ; int height = raster . get Height ( ) ; int px = min X - raster . get Sample Model Translate X ( ) ; int py = min Y - raster . get Sample Model Translate Y ( ) ; if ( px != _ NUM || py != _ NUM || width != w Raster . get Width ( ) || height != w Raster . get Height ( ) ) { w Raster = w Raster . create Writable Child ( px , py , width , height , _ NUM , _ NUM , null ) ; }  Affine Transform trans Xform = (  Affine Transform ) xform . clone ( ) ; trans Xform . translate ( min X , min Y ) ;  Color Model cm = img . get Color Model ( ) ;  Buffered Image buf Img = new  Buffered Image ( cm , w Raster , cm . is Alpha Premultiplied ( ) , null ) ; draw Image ( buf Img , trans Xform , null ) ; }
public boolean remove All ( ) { lock . lock ( ) ; try { if ( cookie Jar . is Empty ( ) ) { return _ BOOL ; } cookie Jar . clear ( ) ; domain Index . clear ( ) ; uri Index . clear ( ) ; } finally { lock . unlock ( ) ; } return _ BOOL ; }
@  Override default  Completable Future <  Optional Double > max Double ( final  To Double Function < ? super  T > fn ) { return  Completable Future . supply Async ( null , get Exec ( ) ) ; }
@  Override public  List <  Writable > next ( ) {  List <  String > next = data Iter . next ( ) ; invoke Listeners ( next ) ;  List <  Writable > ret = new  Array List < > ( ) ; for (  String s : next ) ret . add ( new  Text ( s ) ) ; return ret ; }
public static  Document read Xml (  Input Stream is ) throws  SAXException ,  IOException ,  Parser Configuration Exception {  Document Builder Factory dbf =  Document Builder Factory . new Instance ( ) ; dbf . set Validating ( _ BOOL ) ; dbf . set Ignoring Comments ( _ BOOL ) ; dbf . set Ignoring Element Content Whitespace ( _ BOOL ) ; dbf . set Namespace Aware ( _ BOOL ) ;  Document Builder db = null ; db = dbf . new Document Builder ( ) ; db . set Entity Resolver ( new  Null Resolver ( ) ) ; return db . parse ( is ) ; }
public static  List <  JSONObject > create JSONInput (  File System fs ) {  String input JSONFile =  System Configuration . get Property (  Distributed Test Driver .  JSON_ PIR_ INPUT_ FILE_ PROPERTY ) ; logger . info ( _ STR + input JSONFile ) ;  List <  JSONObject > data Elements JSON = create JSONData Elements ( ) ;  HDFS . write File ( data Elements JSON , fs , input JSONFile , _ BOOL ) ; logger . info ( _ STR ) ; return data Elements JSON ; }
private void update Part Tab (  Part Presenter part ) { if ( ! parts . contains ( part ) ) { throw new  Illegal Argument Exception ( _ STR + part . get Title ( ) ) ; } int index = parts . index Of ( part ) ; view . update Tab Item ( index , part . decorate Icon ( part . get Title SVGImage ( ) != null ? new  SVGImage ( part . get Title SVGImage ( ) ) : null ) , part . get Title ( ) , part . get Title Tool Tip ( ) , part . get Title Widget ( ) ) ; }
private int merge Movements Available ( ) { final  Atomic Integer pairs Of Mergeable Tiles = new  Atomic Integer ( ) ; int cont = _ NUM ;  Direction direction =  Direction .  UP ; do { for (  Integer x : grid Operator . get Traverse X ( ) ) { for (  Integer y : grid Operator . get Traverse Y ( ) ) {  Location thisloc = new  Location ( x , y ) ;  Tile tile = game Grid . get ( thisloc ) ; if ( tile != null ) {  Tile offset Tile = game Grid . get ( thisloc . offset ( direction ) ) ; if ( offset Tile != null && tile . is Mergeable ( offset Tile ) ) { pairs Of Mergeable Tiles . increment And Get ( ) ; } } } } direction =  Direction .  LEFT ; cont ++ ; } while ( cont < _ NUM ) ; return pairs Of Mergeable Tiles . get ( ) ; }
public  Training Set Panel ( ) { final  JSplit Pane split = new  JSplit Pane (  JSplit Pane .  HORIZONTAL_ SPLIT ) ;  JPanel filler1 = new  JPanel ( ) ; filler1 . set Background (  Color . light Gray ) ;  JPanel filler2 = new  JPanel ( ) ; filler2 . set Background (  Color . light Gray ) ; split . set Left Component ( filler1 ) ; split . set Right Component ( filler2 ) ; split . set Resize Weight ( _ NUM ) ; split . set Border ( null ) ; set Layout ( new  Grid Bag Layout ( ) ) ;  Grid Bag Constraints whole Panel Constraints = new  Grid Bag Constraints ( ) ; whole Panel Constraints . fill =  Grid Bag Constraints .  BOTH ; whole Panel Constraints . weightx = _ NUM ; whole Panel Constraints . weighty = _ NUM ; whole Panel Constraints . gridx = _ NUM ; whole Panel Constraints . gridy = _ NUM ; add ( split , whole Panel Constraints ) ; }
public static  Cert Chain create (  String instance Identifier ,  X509 Certificate [ ] chain ) { if ( chain . length < _ NUM ) { throw new  Coded Exception (  X_ CANNOT_ CREATE_ CERT_ PATH , _ STR + _ STR ) ; }  X509 Certificate trust Anchor = chain [ chain . length - _ NUM ] ;  List <  X509 Certificate > additional Certs = new  Array List < > ( ) ; if ( chain . length > _ NUM ) { additional Certs . add All (  Arrays . as List (  Arrays . copy Of Range ( chain , _ NUM , chain . length - _ NUM ) ) ) ; } try { return new  Cert Chain ( instance Identifier , chain [ _ NUM ] , trust Anchor , additional Certs ) ; } catch (  Exception ex ) { throw translate With Prefix (  X_ CANNOT_ CREATE_ CERT_ PATH , ex ) ; } }
@  Suppress Warnings ( _ STR ) public  Registry Context (  String host , int port ,  Hashtable < ? , ? > env ) throws  Naming Exception { environment = ( env == null ) ? new  Hashtable <  String ,  Object > ( _ NUM ) : (  Hashtable <  String ,  Object > ) env ; if ( environment . get (  SECURITY_ MGR ) != null ) { install Security Mgr ( ) ; } if ( ( host != null ) && ( host . char At ( _ NUM ) == _ STR ) ) { host = host . substring ( _ NUM , host . length ( ) - _ NUM ) ; }  RMIClient Socket Factory socket Factory = (  RMIClient Socket Factory ) environment . get (  SOCKET_ FACTORY ) ; registry = get Registry ( host , port , socket Factory ) ; this . host = host ; this . port = port ; }
private final boolean add Direction (  Array List <  Move > move List ,  Position pos , int sq0 , int max Steps , int delta ) { int sq = sq0 ; boolean wtm = pos . white Move ; final int o King = ( wtm ?  Piece .  BKING :  Piece .  WKING ) ; while ( max Steps > _ NUM ) { sq += delta ; int p = pos . get Piece ( sq ) ; if ( p ==  Piece .  EMPTY ) { move List . add ( get Move Obj ( sq0 , sq ,  Piece .  EMPTY ) ) ; } else { if (  Piece . is White ( p ) != wtm ) { if ( p == o King ) { return Move List ( move List ) ; move List = get Move List Obj ( ) ; move List . add ( get Move Obj ( sq0 , sq ,  Piece .  EMPTY ) ) ; return _ BOOL ; } else { move List . add ( get Move Obj ( sq0 , sq ,  Piece .  EMPTY ) ) ; } } break ; } max Steps -- ; } return _ BOOL ; }
public static <  T >  T assert And Cast (  Class < ? extends  T > clazz ,  Object o ) { assert Not Null ( clazz ) ; assert Not Null ( o ) ; assert True ( clazz . is Instance ( o ) ) ; return clazz . cast ( o ) ; }
private static  Element add Bean (  Document doc ,  Node parent ,  Class < ? > cls ) {  Element elem = doc . create Element ( _ STR ) ; elem . set Attribute ( _ STR , cls . get Name ( ) ) ; parent . append Child ( elem ) ; return elem ; }
public static void copy Bytes To Stream (  Input Stream input Stream ,  Output Stream output Stream , int length ) throws  IOException { final int  BUFFER_ SIZE = _ NUM ; byte [ ] buffer = new byte [  BUFFER_ SIZE ] ; int total Read = _ NUM ; do { int read Req Len = ( length == - _ NUM ) ?  BUFFER_ SIZE :  Math . min (  BUFFER_ SIZE , length - total Read ) ; int read = input Stream . read ( buffer , _ NUM , read Req Len ) ; if ( read == - _ NUM ) { if ( length != - _ NUM ) { throw create Failed To Read Expected ( length , total Read ) ; } else { return ; } } total Read += read ; output Stream . write ( buffer , _ NUM , read ) ; } while ( total Read != length ) ; }
private boolean check Tracked Branches Configured ( ) {  LOG . info ( _ STR ) ; for (  Git Repository repository : my Repositories ) {  Virtual File root = repository . get Root ( ) ; final  Git Local Branch branch = repository . get Current Branch ( ) ; if ( branch == null ) {  LOG . info ( _ STR + repository ) ; notify Important Error ( my Project , _ STR , _ STR + root String If Needed ( root ) + _ STR ) ; return _ BOOL ; }  Git Branch Track Info track Info =  Git Branch Util . get Track Info For Branch ( repository , branch ) ; if ( track Info == null ) { final  String branch Name = branch . get Name ( ) ;  LOG . info (  String . format ( _ STR , branch , repository ) ) ; notify Important Error ( my Project , _ STR , _ STR + code ( branch Name ) + root String If Needed ( root ) + _ STR + _ STR + branch Name + _ STR + branch Name + _ STR ) ; return _ BOOL ; } my Tracked Branches . put ( root , new  Git Branch Pair ( branch , track Info . get Remote Branch ( ) ) ) ; } return _ BOOL ; }
public static  String encrypt With Symmetric Key (  String data ,  String enc Algorithm ,  String secret ) throws  Exception { try {  String algorithm = enc Algorithm ; if ( ! algorithm . starts With ( _ STR ) ) { algorithm = _ STR + enc Algorithm ; }  Secret Key Factory sk Factory =  Secret Key Factory . get Instance ( algorithm ) ;  PBEKey Spec pbe Key Spec = new  PBEKey Spec ( secret . to Char Array ( ) ) ;  Secret Key s Key = sk Factory . generate Secret ( pbe Key Spec ) ;  Cipher cipher =  Cipher . get Instance ( algorithm ) ; cipher . init (  Cipher .  ENCRYPT_ MODE , s Key , pbe Parameter Spec ) ; byte [ ] enc Data = cipher . do Final ( data . get Bytes ( _ STR ) ) ; enc Data = add Prefix ( enc Data ) ; return  Base64 . encode ( enc Data ) ; } catch (  No Such Algorithm Exception nse ) { throw new  Exception ( nse . get Message ( ) ) ; } }
public static  String left Pad (  String original , int length , char pad Char ) { if ( original . length ( ) >= length ) { return original ; } return string Of Char ( pad Char , length - original . length ( ) ) + original ; }
protected void transform Page (  View view , float position ) { int page Width = view . get Width ( ) ; if ( position < - _ NUM ) { view . set Alpha ( _ NUM ) ; } else if ( position <= _ NUM ) { view . set Alpha ( _ NUM ) ; if ( virtual Pos > _ NUM ) { view . set Translation X ( page Width * - position * _ NUM ) ; } else { view . set Translation X ( _ NUM ) ; } float scale Factor =  MIN_ SCALE + ( _ NUM -  MIN_ SCALE ) * ( _ NUM -  Math . abs ( position ) ) ; view . set Scale X ( scale Factor ) ; view . set Scale Y ( scale Factor ) ; } else if ( position <= _ NUM ) { view . set Alpha ( _ NUM - position ) ; view . set Translation X ( page Width * - position ) ; float scale Factor =  MIN_ SCALE + ( _ NUM -  MIN_ SCALE ) * ( _ NUM -  Math . abs ( position ) ) ; view . set Scale X ( scale Factor ) ; view . set Scale Y ( scale Factor ) ; } else { view . set Alpha ( _ NUM ) ; } }
void reset ( ) {  System . arraycopy ( iv , _ NUM , counter , _ NUM , block Size ) ; used = block Size ; }
private static void fix Rectangle Orientation ( double [ ] m ,  Rectangle2 D clip ) { if ( clip . get Width ( ) > _ NUM != ( m [ _ NUM ] - m [ _ NUM ] > _ NUM ) ) { double t = m [ _ NUM ] ; m [ _ NUM ] = m [ _ NUM ] ; m [ _ NUM ] = t ; } if ( clip . get Height ( ) > _ NUM != ( m [ _ NUM ] - m [ _ NUM ] > _ NUM ) ) { double t = m [ _ NUM ] ; m [ _ NUM ] = m [ _ NUM ] ; m [ _ NUM ] = t ; } }
private void bind Session ( ) {  Session Factory session Factory = (  Session Factory ) get Bean ( _ STR ) ;  Session session = session Factory . open Session ( ) ;  Transaction Synchronization Manager . bind Resource ( session Factory , new  Session Holder ( session ) ) ; }
public  CUn Inline Action ( final  JFrame parent , final  Zy Graph graph , final  INavi Code Node node ) { super (  String . format ( _ STR , get Parent Function ( node ) ) ) ; m_parent =  Preconditions . check Not Null ( parent , _ STR ) ; m_graph =  Preconditions . check Not Null ( graph , _ STR ) ; m_node =  Preconditions . check Not Null ( node , _ STR ) ; }
public void append ( byte [ ] bytes , int offset , int len ) { ensure Capacity ( length + len ) ;  System . arraycopy ( bytes , offset , buffer , length , len ) ; length += len ; }
private static void add Common Permissions (  Permissions permissions ) { permissions . add ( new  Audio Permission ( _ STR ) ) ; permissions . add ( new  AWTPermission ( _ STR ) ) ; permissions . add ( new  AWTPermission ( _ STR ) ) ; permissions . add ( new  AWTPermission ( _ STR ) ) ; permissions . add ( new  Logging Permission ( _ STR , _ STR ) ) ; permissions . add ( new  Socket Permission ( _ STR , _ STR ) ) ; permissions . add ( new  URLPermission ( _ STR , _ STR ) ) ; permissions . add ( new  URLPermission ( _ STR , _ STR ) ) ; permissions . add ( new  Runtime Permission ( _ STR ) ) ; permissions . add ( new  Runtime Permission ( _ STR ) ) ; permissions . add ( new  Runtime Permission ( _ STR ) ) ; permissions . add ( new  Runtime Permission ( _ STR ) ) ; permissions . add ( new  Runtime Permission ( _ STR ) ) ; permissions . add ( new  Runtime Permission ( _ STR ) ) ; permissions . add ( new  Runtime Permission ( _ STR ) ) ; }
private final void init Matrix ( ) { log . info ( _ STR ) ;  Set <  Id > zids = new  Hash Set <  Id > ( ) ; for (  Id zid : l2z Mapping . values ( ) ) { zids . add ( zid ) ; } matrix . clear ( ) ; for (  Id fzone : zids ) { for (  Id tzone : zids ) {  String key = fzone . to String ( ) + _ STR + tzone . to String ( ) ; matrix . put ( key , _ STR ) ; } } log . info ( _ STR ) ; }
public static void print Raw Lines (  Print Writer writer ,  String msg ) { int nl ; while ( ( nl = msg . index Of ( _ STR ) ) != - _ NUM ) { writer . println ( msg . substring ( _ NUM , nl ) ) ; msg = msg . substring ( nl + _ NUM ) ; } if ( msg . length ( ) != _ NUM ) writer . println ( msg ) ; }
private  List <  Facet Result > facets With Search ( ) throws  IOException {  Directory Reader index Reader =  Directory Reader . open ( index Dir ) ;  Index Searcher searcher = new  Index Searcher ( index Reader ) ;  Taxonomy Reader taxo Reader = new  Directory Taxonomy Reader ( taxo Dir ) ;  Facets Collector fc = new  Facets Collector ( ) ;  Facets Collector . search ( searcher , new  Match All Docs Query ( ) , _ NUM , fc ) ;  List <  Facet Result > results = new  Array List < > ( ) ;  Facets facets = new  Fast Taxonomy Facet Counts ( taxo Reader , config , fc ) ; results . add ( facets . get Top Children ( _ NUM , _ STR ) ) ; results . add ( facets . get Top Children ( _ NUM , _ STR ) ) ; index Reader . close ( ) ; taxo Reader . close ( ) ; return results ; }
public  Dictionary (  Directory temp Dir ,  String temp File Name Prefix ,  Input Stream affix ,  Input Stream dictionary ) throws  IOException ,  Parse Exception { this ( temp Dir , temp File Name Prefix , affix ,  Collections . singleton List ( dictionary ) , _ BOOL ) ; }
public static  String construct Config Name (  String config Name ,  String Map scope ) {  String Builder builder = new  String Builder ( ) ; for (  Map .  Entry <  String ,  String > entry : scope . entry Set ( ) ) { builder . append ( entry . get Key ( ) ) ; builder . append ( _ STR ) ; builder . append ( entry . get Value ( ) ) ; builder . append ( _ STR ) ; } builder . append ( config Name ) ; return builder . to String ( ) ; }
protected  String Property Matcher (  String property Name ,  Mode mode ,  Boolean ignore Case ,  String expected Pattern ,  Function <  Issue ,  String > get Actual Value ) { super ( property Name ) ; this . mode = mode ; this . ignore Case =  Objects . require Non Null ( ignore Case ) ; this . expected Pattern = safe Get Value ( expected Pattern ) ; this . get Actual Value =  Objects . require Non Null ( get Actual Value ) ; }
public synchronized boolean safe Count ( int partition , long offset ) throws  IOException {  Atomic Long counter = null ; if ( partition >= this . counters . length ) { this . counters =  Arrays . copy Of ( this . counters , this . counters . length +  GROWBY ) ; } counter = counters [ partition ] ; if ( null == counter ) { counter = new  Atomic Long ( _ NUM ) ; counters [ partition ] = counter ; counter . set ( offset ) ; if ( null != committed Offsets && committed Offsets . length > partition && committed Offsets [ partition ] >= _ NUM && _ NUM < ( offset - committed Offsets [ partition ] ) ) { labels . clear ( ) ; labels . put (  Sensision Constants .  SENSISION_ LABEL_ TOPIC , this . topic ) ; labels . put (  Sensision Constants .  SENSISION_ LABEL_ GROUPID , this . groupid ) ; labels . put (  Sensision Constants .  SENSISION_ LABEL_ PARTITION ,  Integer . to String ( partition ) ) ;  Sensision . update (  Sensision Constants .  SENSISION_ CLASS_ WARP_ KAFKA_ CONSUMER_ OFFSET_ FORWARD_ LEAPS , labels , _ NUM ) ; throw new  IOException ( _ STR + offset + _ STR + committed Offsets [ partition ] ) ; } } else { long previous Offset = counter . get And Set ( offset ) ; if ( _ NUM < ( offset - previous Offset ) ) { labels . clear ( ) ; labels . put (  Sensision Constants .  SENSISION_ LABEL_ TOPIC , this . topic ) ; labels . put (  Sensision Constants .  SENSISION_ LABEL_ GROUPID , this . groupid ) ; labels . put (  Sensision Constants .  SENSISION_ LABEL_ PARTITION ,  Integer . to String ( partition ) ) ;  Sensision . update (  Sensision Constants .  SENSISION_ CLASS_ WARP_ KAFKA_ CONSUMER_ OFFSET_ FORWARD_ LEAPS , labels , _ NUM ) ; throw new  IOException ( _ STR + offset + _ STR + previous Offset ) ; } } if ( null != committed Offsets && committed Offsets . length > partition && offset <= committed Offsets [ partition ] ) { labels . clear ( ) ; labels . put (  Sensision Constants .  SENSISION_ LABEL_ TOPIC , this . topic ) ; labels . put (  Sensision Constants .  SENSISION_ LABEL_ GROUPID , this . groupid ) ; labels . put (  Sensision Constants .  SENSISION_ LABEL_ PARTITION ,  Integer . to String ( partition ) ) ;  Sensision . update (  Sensision Constants .  SENSISION_ CLASS_ WARP_ KAFKA_ CONSUMER_ OFFSET_ BACKWARD_ LEAPS , labels , _ NUM ) ; return _ BOOL ; } return _ BOOL ; }
public  Vector transform2 D ( double angle , double about X , double about Z , double translate X , double translate Z ) { angle =  Math . to Radians ( angle ) ; double x = this . x - about X ; double z = this . z - about Z ; double x2 = x *  Math . cos ( angle ) - z *  Math . sin ( angle ) ; double z2 = x *  Math . sin ( angle ) + z *  Math . cos ( angle ) ; return new  Vector ( x2 + about X + translate X , y , z2 + about Z + translate Z ) ; }
public void disconnect ( ) { connected = _ BOOL ; synchronized ( conn Lost Wait ) { conn Lost Wait . notify ( ) ; } if ( mqtt != null ) { try { mqtt . disconnect ( ) ; } catch (  Exception ex ) { set Title Text ( _ STR ) ; ex . print Stack Trace ( ) ;  System . exit ( _ NUM ) ; } } if ( led . is Flashing ( ) ) { led . set Flash ( ) ; } led . set Red ( ) ; set Connected ( _ BOOL ) ; synchronized ( this ) { write Logln ( _ STR ) ; } }
public boolean contains Header Out (  String name ) {  Array List <  String > header Keys = _header Keys Out ; int size = header Keys . size ( ) ; for ( int i = _ NUM ; i < size ; i ++ ) {  String old Key = header Keys . get ( i ) ; if ( old Key . equals Ignore Case ( name ) ) { return _ BOOL ; } } if ( name . equals Ignore Case ( _ STR ) ) { return _content Type Out != null ; } if ( name . equals Ignore Case ( _ STR ) ) { return _content Length Out >= _ NUM ; } return _ BOOL ; }
private static void write Properties (  Properties props ,  String key Prefix ,  Map <  String ,  Boolean > filters ) { int counter = _ NUM ;  Set <  Entry <  String ,  Boolean > > entry Set = filters . entry Set ( ) ; for (  Entry <  String ,  Boolean > entry : entry Set ) { props . set Property ( key Prefix + counter , entry . get Key ( ) +  BOOL_ SEPARATOR + entry . get Value ( ) ) ; counter ++ ; } boolean key Found = _ BOOL ; while ( key Found ) {  String key = key Prefix + counter ;  String property = props . get Property ( key ) ; if ( property == null ) { key Found = _ BOOL ; } else { props . remove ( key ) ; } } }
public org . w3c . dom .  Element sign With SAMLToken ( org . w3c . dom .  Document doc , java . security . cert .  Certificate cert ,  String assertion ID , java . lang .  String algorithm , java . util .  List ids ) throws  XMLSignature Exception { return null ; }
@  Ignore @  Test public void b6460701_b6431651 ( ) throws  Exception {  URL [ ] urls = new  URL [ ] { new  URL ( _ STR ) } ;  My URLClass Loader ucl = new  My URLClass Loader ( urls ) ; ucl . add URL ( null ) ; ucl . add URL ( new  URL ( _ STR ) ) ; ucl . add URL ( null ) ; ucl . add URL ( new  URL ( _ STR ) ) ; ucl . add URL ( null ) ; ucl . add URL ( new  URL ( _ STR ) ) ; urls = ucl . get URLs ( ) ; if ( urls . length != _ NUM ) throw new  Runtime Exception ( _ STR ) ;  URL url ; for ( int i = _ NUM ; i < urls . length ; i ++ ) { url = urls [ i ] ; if ( url == null || ! url . equals ( new  URL ( _ STR ) ) ) throw new  Runtime Exception ( _ STR ) ; } }
public int min Cut (  String s ) { if ( s == null || s . length ( ) == _ NUM ) return _ NUM ; int len = s . length ( ) ; boolean [ ] [ ] p = new boolean [ len ] [ len ] ; for ( int i = _ NUM ; i < len ; i ++ )  Arrays . fill ( p [ i ] , _ BOOL ) ; int [ ] results = new int [ len ] ; for ( int start = len - _ NUM ; start >= _ NUM ; start -- ) { results [ start ] = len - start - _ NUM ; for ( int end = start ; end < len ; end ++ ) { if ( s . char At ( start ) == s . char At ( end ) ) { if ( end - start < _ NUM ) p [ start ] [ end ] = _ BOOL ; else p [ start ] [ end ] = p [ start + _ NUM ] [ end - _ NUM ] ; } if ( p [ start ] [ end ] ) { if ( end = len - _ NUM ) results [ start ] = _ NUM ; else results [ start ] =  Math . min ( results [ start ] , results [ end + _ NUM ] + _ NUM ) ; } } } return results [ _ NUM ] ; }
public void dim On List Row Menu Swiped ( float alpha ) { alpha =  Math . max ( alpha , max Alpha ) ; menu Indicator View . set Alpha ( alpha ) ; left Indicator View . set Alpha ( alpha ) ; right Indicator View . set Alpha ( alpha ) ; text View . set Alpha ( alpha ) ; }
protected void insert Newline ( ) { final  Document doc = text Pane . get Document ( ) ; try { doc . insert String ( doc . get Length ( ) , _ STR , get Style (  Color . black , _ STR ) ) ; } catch ( final  Bad Location Exception e ) { logger . error ( _ STR , e ) ; } }
public void draw Shape ( int x , int y , int w , int h ,  Map <  String ,  Object > style ) {  Color pen Color = mx Utils . get Color ( style , mx Constants .  STYLE_ STROKECOLOR ) ; float pen Width = mx Utils . get Float ( style , mx Constants .  STYLE_ STROKEWIDTH , _ NUM ) ; int pw = ( int )  Math . ceil ( pen Width * scale ) ; if ( g . hit Clip ( x - pw , y - pw , w + _ NUM * pw , h + _ NUM * pw ) ) { boolean shadow = mx Utils . is True ( style , mx Constants .  STYLE_ SHADOW , _ BOOL ) ;  Color fill Color = mx Utils . get Style Fill Color ( style ) ;  Paint fill Paint = get Fill Paint ( new  Rectangle ( x , y , w , h ) , fill Color , style ) ; if ( pen Width > _ NUM ) { set Stroke ( pen Width , style ) ; }  String shape = mx Utils . get String ( style , mx Constants .  STYLE_ SHAPE , _ STR ) ; if ( shape . equals ( mx Constants .  SHAPE_ IMAGE ) ) {  String img = get Image For Style ( style ) ; if ( img != null ) { draw Image ( x , y , w , h , img ) ; } } else if ( shape . equals ( mx Constants .  SHAPE_ LINE ) ) { if ( pen Color != null ) { g . set Color ( pen Color ) ;  String direction = mx Utils . get String ( style , mx Constants .  STYLE_ DIRECTION , mx Constants .  DIRECTION_ EAST ) ; if ( direction . equals ( mx Constants .  DIRECTION_ EAST ) || direction . equals ( mx Constants .  DIRECTION_ WEST ) ) { int mid = ( int ) ( y + h / _ NUM ) ; draw Line ( x , mid , x + w , mid ) ; } else { int mid = ( int ) ( x + w / _ NUM ) ; draw Line ( mid , y , mid , y + h ) ; } } } else if ( shape . equals ( mx Constants .  SHAPE_ ELLIPSE ) ) { draw Oval ( x , y , w , h , fill Color , fill Paint , pen Color , shadow ) ; } else if ( shape . equals ( mx Constants .  SHAPE_ DOUBLE_ ELLIPSE ) ) { draw Oval ( x , y , w , h , fill Color , fill Paint , pen Color , shadow ) ; int inset = ( int ) ( ( _ NUM + pen Width ) * scale ) ; x += inset ; y += inset ; w -= _ NUM * inset ; h -= _ NUM * inset ; draw Oval ( x , y , w , h , null , null , pen Color , _ BOOL ) ; } else if ( shape . equals ( mx Constants .  SHAPE_ RHOMBUS ) ) { draw Rhombus ( x , y , w , h , fill Color , fill Paint , pen Color , shadow ) ; } else if ( shape . equals ( mx Constants .  SHAPE_ CYLINDER ) ) { draw Cylinder ( x , y , w , h , fill Color , fill Paint , pen Color , shadow ) ; } else if ( shape . equals ( mx Constants .  SHAPE_ ACTOR ) ) { draw Actor ( x , y , w , h , fill Color , fill Paint , pen Color , shadow ) ; } else if ( shape . equals ( mx Constants .  SHAPE_ CLOUD ) ) { draw Cloud ( x , y , w , h , fill Color , fill Paint , pen Color , shadow ) ; } else if ( shape . equals ( mx Constants .  SHAPE_ TRIANGLE ) ) {  String direction = mx Utils . get String ( style , mx Constants .  STYLE_ DIRECTION , _ STR ) ; draw Triangle ( x , y , w , h , fill Color , fill Paint , pen Color , shadow , direction ) ; } else if ( shape . equals ( mx Constants .  SHAPE_ HEXAGON ) ) {  String direction = mx Utils . get String ( style , mx Constants .  STYLE_ DIRECTION , _ STR ) ; draw Hexagon ( x , y , w , h , fill Color , fill Paint , pen Color , shadow , direction ) ; } else { draw Rect ( x , y , w , h , fill Color , fill Paint , pen Color , shadow , mx Utils . is True ( style , mx Constants .  STYLE_ ROUNDED ) ) ; if ( shape . equals ( mx Constants .  SHAPE_ LABEL ) ) {  String img = get Image For Style ( style ) ; if ( img != null ) {  String img Align = mx Utils . get String ( style , mx Constants .  STYLE_ IMAGE_ ALIGN , mx Constants .  ALIGN_ CENTER ) ;  String img Valign = mx Utils . get String ( style , mx Constants .  STYLE_ IMAGE_ VERTICAL_ ALIGN , mx Constants .  ALIGN_ MIDDLE ) ; int img Width = ( int ) ( mx Utils . get Int ( style , mx Constants .  STYLE_ IMAGE_ WIDTH , mx Constants .  DEFAULT_ IMAGESIZE ) * scale ) ; int img Height = ( int ) ( mx Utils . get Int ( style , mx Constants .  STYLE_ IMAGE_ HEIGHT , mx Constants .  DEFAULT_ IMAGESIZE ) * scale ) ; int spacing = ( int ) ( mx Utils . get Int ( style , mx Constants .  STYLE_ SPACING , _ NUM ) * scale ) ; int img X = x ; if ( img Align . equals ( mx Constants .  ALIGN_ LEFT ) ) { img X += spacing ; } else if ( img Align . equals ( mx Constants .  ALIGN_ RIGHT ) ) { img X += w - img Width - spacing ; } else { img X += ( w - img Width ) / _ NUM ; } int img Y = y ; if ( img Valign . equals ( mx Constants .  ALIGN_ TOP ) ) { img Y += spacing ; } else if ( img Valign . equals ( mx Constants .  ALIGN_ BOTTOM ) ) { img Y += h - img Height - spacing ; } else { img Y += ( h - img Height ) / _ NUM ; } draw Image ( img X , img Y , img Width , img Height , img ) ; } } } } }
private boolean is Transient (  Field field ) { int modifier = field . get Modifiers ( ) ; if (  Modifier . is Transient ( modifier ) ) { return _ BOOL ; } return _ BOOL ; }
private void enqueue Send ( ) { final int current Outstanding = outstanding . get ( ) ; if ( current Outstanding < concurrency ) { send Batch ( ) ; return ; } pending = _ BOOL ; pending Topics . offer ( this ) ; listener . topic Pending (  Publisher . this , topic , current Outstanding , concurrency ) ; send Pending ( ) ; }
public static void print ( final  Print Stream out , final  String name , final  Percentile p ) { if ( p . is Ready ( ) ) { try { final  String Builder sb = new  String Builder ( _ NUM ) ; final float [ ] q = p . get Quantiles ( ) ; final float [ ] e = p . get Estimates ( ) ; final int  SCREENWIDTH = _ NUM ; sb . append ( name ) ; sb . append ( _ STR ) ; sb . append ( p . get Min ( ) ) ; sb . append ( _ STR ) ; sb . append ( p . get Max ( ) ) ; sb . append ( _ STR ) ; sb . append ( _ STR ) ; final float max = e [ e . length - _ NUM ] ; for ( int i = _ NUM ; i < q . length ; i ++ ) { sb . append (  String . format ( _ STR , q [ i ] ) ) ; sb . append ( _ STR ) ; final int len = ( int ) ( e [ i ] / max *  SCREENWIDTH ) ; for ( int j = _ NUM ; j < len ; j ++ ) { sb . append ( _ STR ) ; } sb . append ( _ STR ) ; sb . append (  String . format ( _ STR , e [ i ] ) ) ; } out . println ( sb . to String ( ) ) ; } catch (  Insufficient Samples Exception e ) { } } }
public void init (  String component Name ) throws  Log Exception { access Logger = ( com . sun . identity . log .  Logger )  Logger . get Logger ( component Name + _ STR ) ; error Logger = ( com . sun . identity . log .  Logger )  Logger . get Logger ( component Name + _ STR ) ; try { msg Provider =  Message Provider Factory . get Provider ( component Name ) ; } catch (  IOException e ) { debug . error ( _ STR , e ) ; } }
private  View fill Right ( int pos , int next Left ) {  View selected View = null ; int end = ( get Right ( ) - get Left ( ) ) ; while ( next Left < end && pos < m Item Count ) { boolean selected = pos == m Selected Position ;  View child = make And Add View ( pos , next Left , _ BOOL , m List Padding . top , selected ) ; next Left = child . get Right ( ) + m Divider Width ; if ( selected ) { selected View = child ; } pos ++ ; } set Visible Range Hint ( m First Position , m First Position + get Child Count ( ) - _ NUM ) ; return selected View ; }
public void add Default Value (  String value ) throws  SMSException ,  SSOException {  Set default Values = get Default Values ( ) ; if ( default Values !=  Collections .  EMPTY_ SET ) { default Values . add ( value ) ; } else { default Values = new  Hash Set ( ) ; default Values . add ( value ) ; } update Default Values ( default Values ) ; }
public static int key Binding Description To Key Modifier (  String key Binding Description ) { if (  String Utils . is Blank ( key Binding Description ) ) { return _ NUM ; } else if ( key Binding Description . starts With ( _ STR ) ) { return  SWT .  ALT ; } else if ( key Binding Description . starts With ( _ STR ) ) { return  SWT .  CTRL ; } else if ( key Binding Description . starts With ( _ STR ) ) { return  SWT .  COMMAND ; } else { return _ NUM ; } }
public void test Partitioned Mixed ( ) throws  Exception { mode =  PARTITIONED ; near Enabled = _ BOOL ; filter = new  Eviction Filter ( ) ;  Ignite g = start Grid ( ) ;  Ignite Cache <  Object ,  Object > cache = g . cache ( null ) ; try { int id = _ NUM ; cache . put ( id ++ , _ NUM ) ; cache . put ( id ++ , _ NUM ) ; for ( int i = id + _ NUM ; i < _ NUM ; i ++ ) { cache . put ( id , id ) ; cache . put ( i ,  String . value Of ( i ) ) ; } info ( _ STR + cache . get ( _ NUM ) ) ; info ( _ STR + cache . get ( _ NUM ) ) ; info ( _ STR + cache . get ( _ NUM ) ) ; } finally { stop Grid ( ) ; } }
protected double multiply ( double [ ] [ ] mat , double [ ] in , double [ ] out ) { double l = _ NUM ; for ( int d1 = _ NUM ; d1 < in . length ; d1 ++ ) { final double [ ] row = mat [ d1 ] ; double t = _ NUM ; for ( int d2 = _ NUM ; d2 < in . length ; d2 ++ ) { t += row [ d2 ] * in [ d2 ] ; } out [ d1 ] = t ; l += t * t ; } return l > _ NUM ?  Math . sqrt ( l ) : _ NUM ; }
public  Gridify Runtime Exception (  Throwable cause ) { this ( cause . get Message ( ) , cause ) ; }
public boolean equals (  Object obj ) { if ( this == obj ) return _ BOOL ; if ( ! ( obj instanceof  Channel Binding ) ) return _ BOOL ;  Channel Binding cb = (  Channel Binding ) obj ; if ( ( initiator != null && cb . initiator == null ) || ( initiator == null && cb . initiator != null ) ) return _ BOOL ; if ( initiator != null && ! initiator . equals ( cb . initiator ) ) return _ BOOL ; if ( ( acceptor != null && cb . acceptor == null ) || ( acceptor == null && cb . acceptor != null ) ) return _ BOOL ; if ( acceptor != null && ! acceptor . equals ( cb . acceptor ) ) return _ BOOL ; return  Arrays . equals ( app Data , cb . app Data ) ; }
private  Option resolve Option (  String opt ) { opt =  Util . strip Leading Hyphens ( opt ) ; for (  Iterator it = options . iterator ( ) ; it . has Next ( ) ; ) {  Option option = (  Option ) it . next ( ) ; if ( opt . equals ( option . get Opt ( ) ) ) { return option ; } if ( opt . equals ( option . get Long Opt ( ) ) ) { return option ; } } return null ; }
@  Ignore ( _ STR ) @  Test public void test Instantiators Event Id Verification Clients And Servers ( ) throws  Exception {  PORT1 = init Server Cache ( server1 , _ NUM ) ;  PORT2 = init Server Cache ( server2 , _ NUM ) ; create Client Cache_ Event Id (  Network Utils . get Server Host Name ( server1 . get Host ( ) ) , new  Integer (  PORT1 ) ) ; unregister Instantiators In All VMs ( ) ; client2 . invoke ( null ) ; set Client Server Observer1 ( ) ; client2 . invoke ( null ) ; register Test Object19 ( ) ;  Wait . pause ( _ NUM ) ;  Boolean pass = (  Boolean ) client2 . invoke ( null ) ; assert True ( _ STR , pass . boolean Value ( ) ) ;  Pool Impl .  IS_ INSTANTIATOR_ CALLBACK = _ BOOL ; }
public void property Change (  Property Change Event pce ) { if ( pce . get Property Name ( ) ==  Map Bean .  Background Property ) { map Bean . set Bckgrnd ( (  Paint ) pce . get New Value ( ) ) ; } }
public  Section Builder add Frame ( int image Resource ) { m Frames . add ( image Resource ) ; return this ; }
public  List <  Class < ? > > find Available Classes (  String uri ) throws  IOException { _resources Not Loaded . clear ( ) ;  List <  Class < ? > > classes = new  Array List < > ( ) ;  List <  String > strings = find Available Strings ( uri ) ; for (  String class Name : strings ) { try {  Class < ? > clazz = _class Loader . load Class ( class Name ) ; classes . add ( clazz ) ; } catch (  Exception not Available ) { _resources Not Loaded . add ( class Name ) ; } } return classes ; }
private boolean diffuse Skylight In Block Column (  Cube cube ,  Mutable Block Pos pos , int min Block Y , int max Block Y ,  Int2 Object Map <  Fast Cube Block Access > block Access Map ) {  ICubic World world = cube . get Cubic World ( ) ; int cube Min Block Y = cube To Min Block ( cube . get Y ( ) ) ; int cube Max Block Y = cube To Max Block ( cube . get Y ( ) ) ; int max Block YIn Cube =  Math . min ( cube Max Block Y , max Block Y ) ; int min Block YIn Cube =  Math . max ( cube Min Block Y , min Block Y ) ;  Fast Cube Block Access block Access = block Access Map . get ( cube . get Y ( ) ) ; if ( block Access == null ) { block Access = new  Fast Cube Block Access ( this . cache , cube ,  UPDATE_ BUFFER_ RADIUS ) ; block Access Map . put ( cube . get Y ( ) , block Access ) ; } for ( int block Y = max Block YIn Cube ; block Y >= min Block YIn Cube ; -- block Y ) { pos . set Y ( block Y ) ; if ( ! needs Skylight Update ( block Access , pos ) ) { continue ; } if ( ! world . check Light For (  Enum Sky Block .  SKY , pos ) ) { return _ BOOL ; } } return _ BOOL ; }
public  String to String ( ) {  String Buffer buffer = new  String Buffer ( ) ; buffer . append ( to String ( get Class ( ) ) ) ; buffer . append ( _ STR ) ; buffer . append ( is Use Default ( ) ) ; buffer . append ( _ STR ) ; buffer . append ( use Locale Format ) ; if ( display Patterns != null ) { buffer . append ( _ STR ) ; buffer . append ( display Patterns ) ; buffer . append ( _ STR ) ; } if ( locale != null ) { buffer . append ( _ STR ) ; buffer . append ( locale ) ; } if ( time Zone != null ) { buffer . append ( _ STR ) ; buffer . append ( time Zone ) ; } buffer . append ( _ STR ) ; return buffer . to String ( ) ; }
@  Override public  Clustering <  Mean Model > run (  Database database ,  Relation <  V > relation ) { final  DBIDs ids = relation . get DBIDs ( ) ; double [ ] [ ] means = initializer . choose Initial Means ( database , relation , k , get Distance Function ( ) ) ;  List <  Modifiable DBIDs > clusters = new  Array List < > ( ) ; for ( int i = _ NUM ; i < k ; i ++ ) { clusters . add (  DBIDUtil . new Hash Set ( relation . size ( ) / k + _ NUM ) ) ; } final  Writable Data Store <  Meta > metas = initialize Meta ( relation , means ) ;  Array Modifiable DBIDs tids = initial Assignment ( clusters , metas , ids ) ; means = means ( clusters , means , relation ) ; means = refine Result ( relation , means , clusters , metas , tids ) ;  Clustering <  Mean Model > result = new  Clustering < > ( _ STR , _ STR ) ; for ( int i = _ NUM ; i < clusters . size ( ) ; i ++ ) { result . add Toplevel Cluster ( new  Cluster < > ( clusters . get ( i ) , new  Mean Model ( means [ i ] ) ) ) ; } return result ; }
public double do Operation ( ) throws  Operator Failed Exception { double logq ; final double alpha = ( arctan Transform ?  Math . atan ( bias ) *  SCALE_ ALPHA :  Math . log ( bias ) ) ; final  Node Ref root = tree . get Root ( ) ; double max Height = tree . get Node Height ( root ) ;  Node Ref i ;  Node Ref i P = null ;  Node Ref  Ci P = null ;  Node Ref  Pi P = null ; double height =  Double .  Na N ;  List <  Node Ref > destinations = null ; do { i = tree . get Node (  Math Utils . next Int ( tree . get Node Count ( ) ) ) ; } while ( root == i || tree . get Parent ( i ) == root ) ; i P = tree . get Parent ( i ) ;  Ci P = get Other Child ( tree , i P , i ) ;  Pi P = tree . get Parent ( i P ) ; height = tree . get Node Height ( i P ) ; destinations = get Intersecting Edges ( tree , height ) ; if ( destinations . size ( ) == _ NUM ) { throw new  Operator Failed Exception ( _ STR ) ; } double [ ] pdf = get Destination Probabilities ( tree , i , height , max Height , destinations , alpha ) ; destinations . remove ( i ) ; destinations . remove (  Ci P ) ; int r =  Math Utils . random Choice PDF ( pdf ) ; double forward Probability = pdf [ r ] ; final  Node Ref j = destinations . get ( r ) ; final  Node Ref j P = tree . get Parent ( j ) ; tree . begin Tree Edit ( ) ; tree . remove Child ( i P ,  Ci P ) ; tree . remove Child (  Pi P , i P ) ; tree . add Child (  Pi P ,  Ci P ) ; tree . remove Child ( j P , j ) ; tree . add Child ( i P , j ) ; tree . add Child ( j P , i P ) ; tree . end Tree Edit ( ) ; final  List <  Node Ref > reverse Destinations = get Intersecting Edges ( tree , height ) ; double reverse Probability = get Reverse Probability ( tree ,  Ci P , j , height , max Height , reverse Destinations , alpha ) ; logq =  Math . log ( reverse Probability ) -  Math . log ( forward Probability ) ; return logq ; }
public boolean is Initialized ( ) { return initiailized ; }
public  String to String ( ) { return  Double . to String ( get Value ( ) ) ; }
private static  List <  Size Pair > generate Valid Preview Size List (  Camera camera ) {  Camera .  Parameters parameters = camera . get Parameters ( ) ;  List < android . hardware .  Camera .  Size > supported Preview Sizes = parameters . get Supported Preview Sizes ( ) ;  List < android . hardware .  Camera .  Size > supported Picture Sizes = parameters . get Supported Picture Sizes ( ) ;  List <  Size Pair > valid Preview Sizes = new  Array List < > ( ) ; for ( android . hardware .  Camera .  Size preview Size : supported Preview Sizes ) { float preview Aspect Ratio = ( float ) preview Size . width / ( float ) preview Size . height ; for ( android . hardware .  Camera .  Size picture Size : supported Picture Sizes ) { float picture Aspect Ratio = ( float ) picture Size . width / ( float ) picture Size . height ; if (  Math . abs ( preview Aspect Ratio - picture Aspect Ratio ) <  ASPECT_ RATIO_ TOLERANCE ) { valid Preview Sizes . add ( new  Size Pair ( preview Size , picture Size ) ) ; break ; } } } if ( valid Preview Sizes . size ( ) == _ NUM ) {  Log . w (  TAG , _ STR ) ; for ( android . hardware .  Camera .  Size preview Size : supported Preview Sizes ) { valid Preview Sizes . add ( new  Size Pair ( preview Size , null ) ) ; } } return valid Preview Sizes ; }
public static  String join (  List < ? > things ,  String delim ) {  String Builder builder = new  String Builder ( ) ; boolean first = _ BOOL ; for (  Object thing : things ) { if ( first ) { first = _ BOOL ; } else { builder . append ( delim ) ; } builder . append ( thing . to String ( ) ) ; } return builder . to String ( ) ; }
public static final byte [ ] inflate ( byte [ ] in ) throws  IOException {  Byte Array Output Stream out Stream = new  Byte Array Output Stream (  EXPECTED_ COMPRESSION_ RATIO * in . length ) ;  Inflater Input Stream in Stream = new  Inflater Input Stream ( new  Byte Array Input Stream ( in ) ) ; byte [ ] buf = new byte [  BUF_ SIZE ] ; while ( _ BOOL ) { int size = in Stream . read ( buf ) ; if ( size <= _ NUM ) break ; out Stream . write ( buf , _ NUM , size ) ; } out Stream . close ( ) ; return out Stream . to Byte Array ( ) ; }
public  Script List Table script List ( ) { if ( script List Table . get ( ) == null ) { script List Table . compare And Set ( null , gsub . create Script List ( ) ) ; } return script List Table . get ( ) ; }
public final void sample ( ) { synchronized ( _lock ) { long count = _total Count . get ( ) ; long last Count = _last Avg Total Count ; _last Avg Total Count = count ; long sum = _sum . get ( ) ; double last Sum = _last Avg Sum ; _last Avg Sum = sum ; if ( count == last Count ) { _avg = _ NUM ; } else { _avg = _scale * ( sum - last Sum ) / ( double ) ( count - last Count ) ; } } }
public boolean contains (  String a Pattern ) { if (  Text Utils . is Empty ( a Pattern ) ) { return _ BOOL ; } boolean res = _ BOOL ; if ( !  Text Utils . is Empty ( m Lower Case Display Name ) ) { res = m Lower Case Display Name . contains ( a Pattern ) ; } if ( ! res && !  Text Utils . is Empty ( m Lower Case Matrix Id ) ) { res = m Lower Case Matrix Id . contains ( a Pattern ) ; } if ( ! res && ( null != m Contact ) ) { res = m Contact . contains ( a Pattern ) ; } return res ; }
public void execute (  String desc ,  Consumer <  Mongo Client > operation ) { while ( _ BOOL ) {  Mongo Client primary = primary Connection Supplier . get ( ) ; try { operation . accept ( primary ) ; return ; } catch (  Throwable t ) { error Handler . accept ( desc , t ) ; } } }
public void write ( char [ ] cbuf , int off , int len ) throws java . io .  IOException { write ( new  String ( cbuf , off , len ) ) ; }
private  Control create Details Viewer ( final  Composite parent ) { if ( details == null ) { return null ; } final  Text text = new  Text ( parent ,  SWT .  MULTI |  SWT .  READ_ ONLY |  SWT .  BORDER |  SWT .  H_ SCROLL |  SWT .  V_ SCROLL ) ; text . set Layout Data ( new  Grid Data (  Grid Data .  FILL_ BOTH ) ) ; final  String Writer writer = new  String Writer ( _ NUM ) ; if ( details instanceof  Throwable ) { append Exception ( new  Print Writer ( writer ) , (  Throwable ) details ) ; } else if ( details instanceof  IStatus ) { append Command Status ( new  Print Writer ( writer ) , (  IStatus ) details , _ NUM ) ; } text . set Text ( writer . to String ( ) ) ; return text ; }
Object Stream Field (  String name ,  String signature , boolean unshared ) { if ( name == null ) { throw new  Null Pointer Exception ( ) ; } this . name = name ; this . signature = signature . intern ( ) ; this . unshared = unshared ; field = null ; switch ( signature . char At ( _ NUM ) ) { case _ STR : type =  Boolean .  TYPE ; break ; case _ STR : type =  Byte .  TYPE ; break ; case _ STR : type =  Character .  TYPE ; break ; case _ STR : type =  Short .  TYPE ; break ; case _ STR : type =  Integer .  TYPE ; break ; case _ STR : type =  Long .  TYPE ; break ; case _ STR : type =  Float .  TYPE ; break ; case _ STR : type =  Double .  TYPE ; break ; case _ STR : case _ STR : type =  Object . class ; break ; default : throw new  Illegal Argument Exception ( _ STR ) ; } }
protected boolean [ ] can Handle Missing ( boolean nominal Predictor , boolean numeric Predictor , boolean string Predictor , boolean date Predictor , boolean relational Predictor , boolean multi Instance , int class Type , boolean predictor Missing , boolean class Missing , int missing Level ) { if ( missing Level == _ NUM ) { print ( _ STR ) ; } print ( _ STR ) ; if ( predictor Missing ) { print ( _ STR ) ; if ( class Missing ) { print ( _ STR ) ; } } if ( class Missing ) { print ( _ STR ) ; } print ( _ STR ) ; print Attribute Summary ( nominal Predictor , numeric Predictor , string Predictor , date Predictor , relational Predictor , multi Instance , class Type ) ; print ( _ STR ) ;  Array List <  String > accepts = new  Array List <  String > ( ) ; accepts . add ( _ STR ) ; accepts . add ( _ STR ) ; accepts . add ( _ STR ) ; int num Train = get Num Instances ( ) , num Classes = _ NUM ; return run Basic Test ( nominal Predictor , numeric Predictor , string Predictor , date Predictor , relational Predictor , multi Instance , class Type , missing Level , predictor Missing , class Missing , num Train , num Classes , accepts ) ; }
private void disable Buttons ( ) { set Arty Enabled ( _ NUM ) ; but Done . set Enabled ( _ BOOL ) ; }
public  Artifact load (  Artifact Name artifact Name ,  File path ) throws  IOException {  Preconditions . check Argument ( path . exists ( ) , _ STR + path ) ;  Preconditions . check Argument ( path . is File ( ) || path . is Directory ( ) , _ STR + path ) ; if ( path . is File ( ) ) { return load From Jar ( artifact Name , path ) ; } return load From Directory ( artifact Name , path ) ; }
public static  String mask Right (  String s , int len , char mask_ch ) { if ( len <= _ NUM ) { return s ; } len =  Math . min ( len , s . length ( ) ) ;  String Builder sb = new  String Builder ( ) ; sb . append ( s . substring ( _ NUM , s . length ( ) - len ) ) ; for ( int i = _ NUM ; i < len ; i ++ ) { sb . append ( mask_ch ) ; } return sb . to String ( ) ; }
@  Override public  Enumeration <  Option > list Options ( ) {  Vector <  Option > result = new  Vector <  Option > ( ) ; result . add Element ( new  Option ( _ STR , _ STR , _ NUM , _ STR ) ) ; result . add Element ( new  Option ( _ STR + _ STR , _ STR , _ NUM , _ STR ) ) ; result . add Element ( new  Option ( _ STR + _ STR , _ STR , _ NUM , _ STR ) ) ; result . add Element ( new  Option ( _ STR , _ STR , _ NUM , _ STR ) ) ; return result . elements ( ) ; }
public  Monitor Train (  Transit Section Action tsa ) { _tsa = tsa ; }
public  DSubject Key Identifier (  JDialog parent ,  Public Key subject Public Key ) { super ( parent ) ; set Title ( res . get String ( _ STR ) ) ; this . subject Public Key = subject Public Key ; init Components ( ) ; }
public void add (  Two DNode dn ) { if ( in Progress ) { throw new  Concurrent Modification Exception ( _ STR ) ; } nodes . add ( dn ) ; }
private  Verification Result verify Signature (  Auth Success auth Resp ,  Discovery Information discovered ,  Verification Result result ) throws  Association Exception ,  Message Exception ,  Discovery Exception { if ( discovered == null || auth Resp == null ) { _log . error ( _ STR + _ STR ) ; result . set Status Msg ( _ STR + _ STR ) ; return result ; }  Identifier claimed Id = discovered . is Version2 ( ) ? _discovery . parse Identifier ( auth Resp . get Claimed ( ) ) : discovered . get Claimed Identifier ( ) ;  String handle = auth Resp . get Handle ( ) ;  URL op = discovered . get OPEndpoint ( ) ;  Association assoc = _associations . load ( op . to String ( ) , handle ) ; if ( assoc != null ) { _log . info ( _ STR + assoc . get Handle ( ) + _ STR ) ;  String text = auth Resp . get Signed Text ( ) ;  String signature = auth Resp . get Signature ( ) ; if ( assoc . verify Signature ( text , signature ) ) { result . set Verified Id ( claimed Id ) ; if (  DEBUG ) _log . debug ( _ STR ) ; } else { result . set Status Msg ( _ STR ) ; if (  DEBUG ) _log . debug ( _ STR ) ; } } else { _log . info ( _ STR + _ STR ) ;  Verify Request vrfy =  Verify Request . create Verify Request ( auth Resp ) ;  Parameter List response Params = new  Parameter List ( ) ; int resp Code = call ( op . to String ( ) , vrfy , response Params ) ; if (  Http Status .  SC_ OK == resp Code ) {  Verify Response vrfy Resp =  Verify Response . create Verify Response ( response Params ) ; vrfy Resp . validate ( ) ; if ( vrfy Resp . is Signature Verified ( ) ) {  String invalidate Handle = vrfy Resp . get Invalidate Handle ( ) ; if ( invalidate Handle != null ) _associations . remove ( op . to String ( ) , invalidate Handle ) ; result . set Verified Id ( claimed Id ) ; if (  DEBUG ) _log . debug ( _ STR + _ STR + op ) ; } else { if (  DEBUG ) _log . debug ( _ STR + _ STR + op ) ; result . set Status Msg ( _ STR ) ; } } else {  Direct Error err =  Direct Error . create Direct Error ( response Params ) ; if (  DEBUG ) _log . debug ( _ STR + op + _ STR + err . key Value Form Encoding ( ) ) ; result . set Status Msg ( _ STR + err . get Error Msg ( ) ) ; } }  Identifier verified ID = result . get Verified Id ( ) ; if ( verified ID != null ) _log . info ( _ STR + verified ID ) ; else _log . error ( _ STR + auth Resp . get Claimed ( ) + _ STR + result . get Status Msg ( ) ) ; return result ; }
private final synchronized void connect ( ) { if ( socket == null ) {  String host = null ;  String port = null ; boolean ok = _ BOOL ; if (  Engine Util . is Net Engine ( file Name ) ) { try {  String [ ] lines =  Util . read File ( file Name ) ; if ( lines . length >= _ NUM ) { host = lines [ _ NUM ] ; port = lines [ _ NUM ] ; ok = _ BOOL ; } } catch (  IOException e1 ) { } } if ( ! ok ) { is Error = _ BOOL ; report . report Error ( context . get String (  R . string . network_engine_config_error ) ) ; } else { try { int port Nr =  Integer . parse Int ( port ) ; socket = new  Socket ( host , port Nr ) ; socket . set Tcp No Delay ( _ BOOL ) ; } catch (  Unknown Host Exception e ) { is Error = _ BOOL ; report . report Error ( e . get Message ( ) ) ; } catch (  Number Format Exception nfe ) { is Error = _ BOOL ; report . report Error ( context . get String (  R . string . invalid_network_port ) ) ; } catch (  IOException e ) { is Error = _ BOOL ; report . report Error ( e . get Message ( ) ) ; } } if ( socket == null ) socket = new  Socket ( ) ; } }
protected void build Profiles ( ) { m Current Profile View . set Visibility (  View .  INVISIBLE ) ; m Account Header Text Section . set Visibility (  View .  INVISIBLE ) ; m Account Switcher Arrow . set Visibility (  View .  INVISIBLE ) ; m Profile First View . set Visibility (  View .  GONE ) ; m Profile First View . set On Click Listener ( null ) ; m Profile Second View . set Visibility (  View .  GONE ) ; m Profile Second View . set On Click Listener ( null ) ; m Profile Third View . set Visibility (  View .  GONE ) ; m Profile Third View . set On Click Listener ( null ) ; m Current Profile Name . set Text ( _ STR ) ; m Current Profile Email . set Text ( _ STR ) ; handle Selection View ( m Current Profile , _ BOOL ) ; if ( m Current Profile != null ) { if ( ( m Profile Images Visible || m Only Main Profile Image Visible ) && ! m Only Small Profile Images Visible ) { set Image Or Placeholder ( m Current Profile View , m Current Profile . get Icon ( ) ) ; if ( m Profile Images Clickable ) { m Current Profile View . set On Click Listener ( on Current Profile Click Listener ) ; m Current Profile View . set On Long Click Listener ( on Current Profile Long Click Listener ) ; m Current Profile View . disable Touch Feedback ( _ BOOL ) ; } else { m Current Profile View . disable Touch Feedback ( _ BOOL ) ; } m Current Profile View . set Visibility (  View .  VISIBLE ) ; m Current Profile View . invalidate ( ) ; } else if ( m Compact Style ) { m Current Profile View . set Visibility (  View .  GONE ) ; } m Account Header Text Section . set Visibility (  View .  VISIBLE ) ; handle Selection View ( m Current Profile , _ BOOL ) ; m Account Switcher Arrow . set Visibility (  View .  VISIBLE ) ; m Current Profile View . set Tag (  R . id . material_drawer_profile_header , m Current Profile ) ;  String Holder . apply To ( m Current Profile . get Name ( ) , m Current Profile Name ) ;  String Holder . apply To ( m Current Profile . get Email ( ) , m Current Profile Email ) ; if ( m Profile First != null && m Profile Images Visible && ! m Only Main Profile Image Visible ) { set Image Or Placeholder ( m Profile First View , m Profile First . get Icon ( ) ) ; m Profile First View . set Tag (  R . id . material_drawer_profile_header , m Profile First ) ; if ( m Profile Images Clickable ) { m Profile First View . set On Click Listener ( on Profile Click Listener ) ; m Profile First View . set On Long Click Listener ( on Profile Long Click Listener ) ; m Profile First View . disable Touch Feedback ( _ BOOL ) ; } else { m Profile First View . disable Touch Feedback ( _ BOOL ) ; } m Profile First View . set Visibility (  View .  VISIBLE ) ; m Profile First View . invalidate ( ) ; } if ( m Profile Second != null && m Profile Images Visible && ! m Only Main Profile Image Visible ) { set Image Or Placeholder ( m Profile Second View , m Profile Second . get Icon ( ) ) ; m Profile Second View . set Tag (  R . id . material_drawer_profile_header , m Profile Second ) ; if ( m Profile Images Clickable ) { m Profile Second View . set On Click Listener ( on Profile Click Listener ) ; m Profile Second View . set On Long Click Listener ( on Profile Long Click Listener ) ; m Profile Second View . disable Touch Feedback ( _ BOOL ) ; } else { m Profile Second View . disable Touch Feedback ( _ BOOL ) ; } m Profile Second View . set Visibility (  View .  VISIBLE ) ; m Profile Second View . invalidate ( ) ; } if ( m Profile Third != null && m Three Small Profile Images && m Profile Images Visible && ! m Only Main Profile Image Visible ) { set Image Or Placeholder ( m Profile Third View , m Profile Third . get Icon ( ) ) ; m Profile Third View . set Tag (  R . id . material_drawer_profile_header , m Profile Third ) ; if ( m Profile Images Clickable ) { m Profile Third View . set On Click Listener ( on Profile Click Listener ) ; m Profile Third View . set On Long Click Listener ( on Profile Long Click Listener ) ; m Profile Third View . disable Touch Feedback ( _ BOOL ) ; } else { m Profile Third View . disable Touch Feedback ( _ BOOL ) ; } m Profile Third View . set Visibility (  View .  VISIBLE ) ; m Profile Third View . invalidate ( ) ; } } else if ( m Profiles != null && m Profiles . size ( ) > _ NUM ) {  IProfile profile = m Profiles . get ( _ NUM ) ; m Account Header Text Section . set Tag (  R . id . material_drawer_profile_header , profile ) ; m Account Header Text Section . set Visibility (  View .  VISIBLE ) ; handle Selection View ( m Current Profile , _ BOOL ) ; m Account Switcher Arrow . set Visibility (  View .  VISIBLE ) ; if ( m Current Profile != null ) {  String Holder . apply To ( m Current Profile . get Name ( ) , m Current Profile Name ) ;  String Holder . apply To ( m Current Profile . get Email ( ) , m Current Profile Email ) ; } } if ( ! m Selection First Line Shown ) { m Current Profile Name . set Visibility (  View .  GONE ) ; } if ( !  Text Utils . is Empty ( m Selection First Line ) ) { m Current Profile Name . set Text ( m Selection First Line ) ; m Account Header Text Section . set Visibility (  View .  VISIBLE ) ; } if ( ! m Selection Second Line Shown ) { m Current Profile Email . set Visibility (  View .  GONE ) ; } if ( !  Text Utils . is Empty ( m Selection Second Line ) ) { m Current Profile Email . set Text ( m Selection Second Line ) ; m Account Header Text Section . set Visibility (  View .  VISIBLE ) ; } if ( ! m Selection List Enabled ) { m Account Switcher Arrow . set Visibility (  View .  INVISIBLE ) ; handle Selection View ( null , _ BOOL ) ; } if ( ! m Selection List Enabled For Single Profile && m Profile First == null && ( m Profiles == null || m Profiles . size ( ) == _ NUM ) ) { m Account Switcher Arrow . set Visibility (  View .  INVISIBLE ) ; handle Selection View ( null , _ BOOL ) ; } if ( m On Account Header Selection View Click Listener != null ) { handle Selection View ( m Current Profile , _ BOOL ) ; } }
public void commit If Prepared (  Ignite Internal Tx tx ,  Set <  UUID > failed Node Ids ) { assert tx instanceof  Grid Dht Tx Local || tx instanceof  Grid Dht Tx Remote : tx ; assert !  F . is Empty ( tx . transaction Nodes ( ) ) : tx ; assert tx . near Xid Version ( ) != null : tx ;  Grid Cache Tx Recovery Future fut = new  Grid Cache Tx Recovery Future ( cctx , tx , failed Node Ids , tx . transaction Nodes ( ) ) ; cctx . mvcc ( ) . add Future ( fut , fut . future Id ( ) ) ; if ( log . is Debug Enabled ( ) ) log . debug ( _ STR + tx + _ STR + fut + _ STR ) ; fut . prepare ( ) ; }
public static byte [ ] encode ( byte [ ] data ,  String pub_key ) { try {  Cipher cipher =  Cipher . get Instance ( _ STR ) ; java . security .  Key k = get Public Key ( pub_key ) ; cipher . init (  Cipher .  ENCRYPT_ MODE , k ) ; byte [ ] en Bytes = cipher . do Final ( data ) ; return en Bytes ; } catch (  Exception e ) { log . error ( _ STR + pub_key + _ STR + data . length , e ) ; } return null ; }
static int derive ARGB (  Color color1 ,  Color color2 , float mid Point ) { int r = color1 . get Red ( ) + ( int ) ( ( color2 . get Red ( ) - color1 . get Red ( ) ) * mid Point + _ NUM ) ; int g = color1 . get Green ( ) + ( int ) ( ( color2 . get Green ( ) - color1 . get Green ( ) ) * mid Point + _ NUM ) ; int b = color1 . get Blue ( ) + ( int ) ( ( color2 . get Blue ( ) - color1 . get Blue ( ) ) * mid Point + _ NUM ) ; int a = color1 . get Alpha ( ) + ( int ) ( ( color2 . get Alpha ( ) - color1 . get Alpha ( ) ) * mid Point + _ NUM ) ; return ( ( a & _ NUM ) << _ NUM ) | ( ( r & _ NUM ) << _ NUM ) | ( ( g & _ NUM ) << _ NUM ) | ( b & _ NUM ) ; }
public void update Position (  Particle particle , long elapsed Time ) {  Vector3f speed = particle . get Speed ( ) ; float delta = elapsed Time / _ NUM ; float dx = speed . x * delta ; float dy = speed . y * delta ; float dz = speed . z * delta ;  Vector3f pos = particle . get Position ( ) ; particle . set Position ( pos . x + dx , pos . y + dy , pos . z + dz ) ; }
private static  Pair <  String ,  String > parse Strategy (  String desc ) {  String [ ] arg = desc . split ( _ STR ) ;  Pair <  String ,  String > rval = new  Pair <  String ,  String > ( arg [ _ NUM ] , _ STR ) ; if ( arg . length > _ NUM ) { rval . set Second ( arg [ _ NUM ] ) ; } return rval ; }
protected void notify Locator (  L locator ) { synchronized ( this ) { if ( ! known Locators . add ( locator . get Partition Id ( ) ) ) { throw new  Illegal State Exception ( _ STR + locator ) ; } } }
private  Event filter (  Event event ) { if ( tags . is Empty ( ) && ttl == _ NUM ) { return event ; } final  String host = event . get Host ( ) != null ? event . get Host ( ) : this . host ; final  Map <  String ,  String > merged Tags =  Maps . new Hash Map ( tags ) ; merged Tags . put All ( event . get Tags ( ) ) ; final  Set <  String > merged Riemann Tags =  Sets . new Hash Set ( riemann Tags ) ; merged Riemann Tags . add All ( event . get Riemann Tags ( ) ) ; final  Date time = event . get Time ( ) != null ? event . get Time ( ) : new  Date ( ) ; final  Long ttl = event . get Ttl ( ) != _ NUM ? event . get Ttl ( ) : this . ttl ; return new  Event ( event . get Key ( ) , event . get Value ( ) , time , ttl , event . get State ( ) , event . get Description ( ) , host , merged Riemann Tags , merged Tags ) ; }
private void add Processor Options (  Map <  Plugin Util .  Checker Prop ,  Object > opts ,  IPreference Store store ) {  String skip Uses = store . get String (  Checker Preferences .  PREF_ CHECKER_ A_ SKIP_ CLASSES ) ; if ( ! skip Uses . is Empty ( ) ) { opts . put (  Plugin Util .  Checker Prop .  A_ SKIP , skip Uses ) ; }  String lint Opts = store . get String (  Checker Preferences .  PREF_ CHECKER_ A_ LINT ) ; if ( ! lint Opts . is Empty ( ) ) { opts . put (  Plugin Util .  Checker Prop .  A_ LINT , lint Opts ) ; } if ( store . get Boolean (  Checker Preferences .  PREF_ CHECKER_ A_ WARNS ) ) { opts . put (  Plugin Util .  Checker Prop .  A_ WARNS ,  Boolean .  TRUE ) ; } if ( store . get Boolean (  Checker Preferences .  PREF_ CHECKER_ A_ NO_ MSG_ TEXT ) ) opts . put (  Plugin Util .  Checker Prop .  A_ NO_ MSG_ TXT ,  Boolean .  TRUE ) ; if ( store . get Boolean (  Checker Preferences .  PREF_ CHECKER_ A_ SHOW_ CHECKS ) ) opts . put (  Plugin Util .  Checker Prop .  A_ SHOW_ CHECKS ,  Boolean .  TRUE ) ; if ( store . get Boolean (  Checker Preferences .  PREF_ CHECKER_ A_ FILENAMES ) ) opts . put (  Plugin Util .  Checker Prop .  A_ FILENAMES ,  Boolean .  TRUE ) ; }
public  List <  Gsm Service Parameter > create Process Parameter For Organization (  Integer org Id ) { init Graph ( org Id ) ;  List <  Cn ATree Element > right Element List = get Right Hand Elements ( org Id ) ;  List <  Cn ATree Element > left Element List = get Left Hand Elements ( org Id ) ; if (  LOG . is Info Enabled ( ) ) {  LOG . info ( right Element List . size ( ) + _ STR ) ;  LOG . info ( left Element List . size ( ) + _ STR ) ; }  List <  Gsm Service Parameter > all Parameter List = new  Linked List <  Gsm Service Parameter > ( ) ; for (  Cn ATree Element control Group : right Element List ) { for (  Cn ATree Element left Element : left Element List ) {  List <  Execution Impl > process List = find Processes ( left Element , control Group ) ; if ( process List != null && ! process List . is Empty ( ) ) { delete Processes ( process List ) ; }  List <  Gsm Service Parameter > parameter List = create Parameter ( left Element , control Group ) ;  String uuid Org = load Org Uuid ( org Id ) ; for (  Gsm Service Parameter parameter : parameter List ) { parameter . set Uuid Org ( uuid Org ) ; all Parameter List . add ( parameter ) ; } } } if (  LOG . is Info Enabled ( ) ) {  LOG . info ( all Parameter List . size ( ) + _ STR ) ; } return all Parameter List ; }
public void list (  Print Writer out ) { out . println ( _ STR ) ;  Hashtable <  String ,  Object > h = new  Hashtable < > ( ) ; enumerate ( h ) ; for (  Enumeration <  String > e = h . keys ( ) ; e . has More Elements ( ) ; ) {  String key = e . next Element ( ) ;  String val = (  String ) h . get ( key ) ; if ( val . length ( ) > _ NUM ) { val = val . substring ( _ NUM , _ NUM ) + _ STR ; } out . println ( key + _ STR + val ) ; } }
@  Nullable public static  String file Md5 ( @  Nullable  File file , @  Nullable  Ignite Logger log ) {  String md5 = null ; if ( file != null ) { if ( ! file . is File ( ) ) {  U . warn ( log , _ STR + file ) ; return null ; }  Input Stream in = null ; try { in = new  Buffered Input Stream ( new  File Input Stream ( file ) ) ; md5 =  Digest Utils . md5 Hex ( in ) ; } catch (  IOException e ) {  U . warn ( log , _ STR + e . get Message ( ) ) ; } finally {  U . close Quiet ( in ) ; } } return md5 ; }
@  Override public void add Scanned Result (  List <  List Based Result Wrapper > list Based Result ) { this . current Row Pointer = list Based Result ; total Number Of Records = list Based Result . size ( ) ; all Rows Result . add ( list Based Result ) ; }
public void trim To Size ( ) { if ( names != null ) names . trim To Size ( ) ; if ( required Children != null ) { required Children . trim To Size ( ) ; for (  Gaz Entry nextkey : required Children . values ( ) ) { nextkey . trim To Size ( ) ; } } }
public void clear Sections ( ) { sections . clear ( ) ; fire Update Event (  SECTION_ EVENT ) ; }
public static  Set parse Response Attributes (  Node p Node ) throws  Policy Exception {  Set node Set =  XMLUtils . get Child Nodes ( p Node ,  ATTRIBUTE ) ; if ( node Set == null ) { debug . error ( _ STR + _ STR +  ATTRIBUTE ) ;  String objs [ ] = {  ATTRIBUTE } ; throw new  Policy Exception (  Res Bundle Utils . rb Name , _ STR , objs , null ) ; }  Hash Set attrs = new  Hash Set ( ) ;  Node node = null ;  Iterator nodes = node Set . iterator ( ) ; while ( nodes . has Next ( ) ) { node = (  Node ) nodes . next ( ) ;  String attr Name =  XMLUtils . get Node Attribute Value ( node ,  ATTRIBUTE_ NAME ) ; if ( attr Name == null ) { debug . error ( _ STR + _ STR +  ATTRIBUTE_ NAME ) ;  String objs [ ] = {  ATTRIBUTE_ NAME } ; throw new  Policy Exception (  Res Bundle Utils . rb Name , _ STR , objs , null ) ; } attrs . add ( attr Name ) ; } return attrs ; }
public void test_thread Safe ( ) throws  Interrupted Exception ,  Execution Exception { final long event History Millis = _ NUM ; final  Event BTree event BTree =  Event BTree . create Transient ( ) ; final  Event Receiver event Receiver = new  Event Receiver ( event History Millis , event BTree ) ; final  IBigdata Federation fed = new  Mock Federation ( event Receiver ) ; final  Executor Service ex Service =  Executors . new Cached Thread Pool (  Daemon Thread Factory . default Thread Factory ( ) ) ; final int nthreads = _ NUM ; final int nevents = _ NUM ; try { final  List <  Callable <  Void > > tasks = new  Linked List <  Callable <  Void > > ( ) ; for ( int i = _ NUM ; i < nthreads ; i ++ ) { tasks . add ( new  Event Factory ( fed , nevents ) ) ; } tasks . add ( new  Event Consumer ( event Receiver ) ) ; final  List <  Future <  Void > > futures = ex Service . invoke All ( tasks ) ; for (  Future f : futures ) { f . get ( ) ; } } finally { ex Service . shutdown Now ( ) ; } }
public static  List <  Vm > create Vm List ( int broker Id , int vms Number ) {  List <  Vm > vms = new  Array List <  Vm > ( ) ; for ( int i = _ NUM ; i < vms Number ; i ++ ) { int vm Type = i / ( int )  Math . ceil ( ( double ) vms Number /  Constants .  VM_ TYPES ) ; vms . add ( new  Power Vm ( i , broker Id ,  Constants .  VM_ MIPS [ vm Type ] ,  Constants .  VM_ PES [ vm Type ] ,  Constants .  VM_ RAM [ vm Type ] ,  Constants .  VM_ BW ,  Constants .  VM_ SIZE , _ NUM , _ STR , new  Cloudlet Scheduler Dynamic Workload (  Constants .  VM_ MIPS [ vm Type ] ,  Constants .  VM_ PES [ vm Type ] ) ,  Constants .  SCHEDULING_ INTERVAL ) ) ; } return vms ; }
private  List <  Storage Port > sort Ports (  List <  Storage Port > storage Ports ,  Map <  Initiator ,  List <  Storage Port > > existing Assignments ,  List <  Storage Port > new Ports ) {  Set <  URI > included Ports = new  Hash Set <  URI > ( ) ;  List <  Storage Port > sorted Ports = new  Array List <  Storage Port > ( ) ;  Map <  URI ,  Storage Port > ports Map =  Data Object Utils . to Map ( storage Ports ) ; for ( int num Ports = _ NUM ; num Ports >= _ NUM ; num Ports -- ) { for (  List <  Storage Port > ports : existing Assignments . values ( ) ) { if ( ports . size ( ) >= num Ports ) { for (  Storage Port port : ports ) { if ( ! included Ports . contains ( port . get Id ( ) ) && ports Map . contains Key ( port . get Id ( ) ) ) { sorted Ports . add ( port ) ; included Ports . add ( port . get Id ( ) ) ; } } } } } for (  Storage Port port : storage Ports ) { if ( ! included Ports . contains ( port . get Id ( ) ) ) { sorted Ports . add ( port ) ; included Ports . add ( port . get Id ( ) ) ; new Ports . add ( port ) ; } } if ( sorted Ports . size ( ) != storage Ports . size ( ) ) { _log . error ( _ STR ) ; _log . error ( sorted Ports . to String ( ) ) ; _log . error ( storage Ports . to String ( ) ) ; return null ; } return sorted Ports ; }
@  Override public  V put (  K key ,  V value ) { if ( key == null ) { return put Value For Null Key ( value ) ; } int hash = secondary Hash ( key ) ;  Hash Map Entry <  K ,  V > [ ] tab = table ; int index = hash & ( tab . length - _ NUM ) ; for (  Hash Map Entry <  K ,  V > e = tab [ index ] ; e != null ; e = e . next ) { if ( e . hash == hash && key . equals ( e . key ) ) { pre Modify ( e ) ;  V old Value = e . value ; e . value = value ; return old Value ; } } mod Count ++ ; if ( size ++ > threshold ) { tab = double Capacity ( ) ; index = hash & ( tab . length - _ NUM ) ; } add New Entry ( key , value , hash , index ) ; return null ; }
public void add Model Change (  String table Name ,  Model Validator listener ) { if ( table Name == null || listener == null ) return ;  String property Name = m_global Validators . contains ( listener ) ? table Name + _ STR : table Name + listener . get AD_ Client_ ID ( ) ;  Array List <  Model Validator > list = (  Array List <  Model Validator > ) m_model Change Listeners . get ( property Name ) ; if ( list == null ) { list = new  Array List <  Model Validator > ( ) ; list . add ( listener ) ; m_model Change Listeners . put ( property Name , list ) ; } else list . add ( listener ) ; }
static  Pair < byte [ ] ,  Long > decompose Name (  Column column ) {  Byte Buffer name Buffer ; if ( column . is Set Name ( ) ) { name Buffer = column . buffer For Name ( ) ; } else { name Buffer =  Byte Buffer . wrap ( column . get Name ( ) ) ; } return decompose ( name Buffer ) ; }
private  Object execute Plus (  Page Context pc ,  SQL sql ,  Query qr ,  Operation2 expression , int row ) throws  Page Exception {  Object left = execute Exp ( pc , sql , qr , expression . get Left ( ) , row ) ;  Object right = execute Exp ( pc , sql , qr , expression . get Right ( ) , row ) ; try { return new  Double (  Caster . to Double Value ( left ) +  Caster . to Double Value ( right ) ) ; } catch (  Page Exception e ) { return  Caster . to String ( left ) +  Caster . to String ( right ) ; } }
@  POST @  Produces ( {  Media Type .  APPLICATION_ XML ,  Media Type .  APPLICATION_ JSON } ) @  Path ( _ STR ) @  Check Permission ( roles = {  Role .  SYSTEM_ ADMIN ,  Role .  RESTRICTED_ SYSTEM_ ADMIN } ) public  Task Resource Rep discover Compute System ( @  Path Param ( _ STR )  URI id ) {  Arg Validator . check Field Uri Type ( id ,  Compute System . class , _ STR ) ;  Compute System cs = query Object (  Compute System . class , id , _ BOOL ) ; return do Discover Compute System ( cs ) ; }
public int read ( byte [ ] b , int off , int len ) throws  IOException { ensure Open ( ) ; if ( b == null ) { throw new  Null Pointer Exception ( _ STR ) ; } else if ( off < _ NUM || len < _ NUM || len > b . length - off ) { throw new  Index Out Of Bounds Exception ( ) ; } else if ( len == _ NUM ) { return _ NUM ; } int cnt = _ NUM ; while ( len > _ NUM && ! def . finished ( ) ) { int n ; if ( def . needs Input ( ) ) { n = in . read ( buf , _ NUM , buf . length ) ; if ( n < _ NUM ) { def . finish ( ) ; } else if ( n > _ NUM ) { def . set Input ( buf , _ NUM , n ) ; } } n = def . deflate ( b , off , len ) ; cnt += n ; off += n ; len -= n ; } if ( cnt == _ NUM && def . finished ( ) ) { reach EOF = _ BOOL ; cnt = - _ NUM ; } return cnt ; }
private void draw Line To Touch Point (  Canvas canvas ) { if ( touch Point . height ( ) > _ NUM && touch Point . width ( ) > _ NUM ) { draw Line ( canvas , circles [ connection Order . get ( connection Order . size ( ) - _ NUM ) ] , touch Point ) ; } }
public  Map <  String , byte [ ] > compile (  String file Name ,  String source ) throws  IOException { try (  Memory Java File Manager manager = new  Memory Java File Manager ( std Manager ) ) {  Java File Object java File Object = manager . make String Source ( file Name , source ) ;  Compilation Task task = compiler . get Task ( null , manager , null , null , null ,  Arrays . as List ( java File Object ) ) ;  Boolean result = task . call ( ) ; if ( result == null || ! result . boolean Value ( ) ) { throw new  Runtime Exception ( _ STR ) ; } return manager . get Class Bytes ( ) ; } }
public static  Buffered Image create RGBAImage From RGBA (  Raster rgba Raster ,  ICC_ Profile rgba Profile ) {  Buffered Image image ; int w = rgba Raster . get Width ( ) ; int h = rgba Raster . get Height ( ) ; rgba Profile = null ; { int [ ] rgb = new int [ w * h ] ; int [ ]  R = rgba Raster . get Samples ( _ NUM , _ NUM , w , h , _ NUM , ( int [ ] ) null ) ; int [ ]  G = rgba Raster . get Samples ( _ NUM , _ NUM , w , h , _ NUM , ( int [ ] ) null ) ; int [ ]  B = rgba Raster . get Samples ( _ NUM , _ NUM , w , h , _ NUM , ( int [ ] ) null ) ; int [ ]  A = rgba Raster . get Samples ( _ NUM , _ NUM , w , h , _ NUM , ( int [ ] ) null ) ; for ( int i = _ NUM , imax =  R . length ; i < imax ; i ++ ) { rgb [ i ] =  A [ i ] << _ NUM |  R [ i ] << _ NUM |  G [ i ] << _ NUM |  B [ i ] ; }  Raster rgb Raster =  Raster . create Packed Raster ( new  Data Buffer Int ( rgb , rgb . length ) , w , h , w , new int [ ] { _ NUM , _ NUM , _ NUM , _ NUM } , null ) ;  Color Space cs =  Color Space . get Instance (  Color Space .  CS_s RGB ) ;  Color Model cm = new  Direct Color Model ( cs , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ BOOL ,  Data Buffer .  TYPE_ INT ) ; image = new  Buffered Image ( cm , (  Writable Raster ) rgb Raster , _ BOOL , null ) ; } return image ; }
public static  Left Indexed Power Law Multi Segment Bipartite Graph build Random Multi Segment Bipartite Graph ( int max Num Segments , int max Num Edges Per Segment , int left Size , int right Size , double edge Probability ,  Random random ) {  Left Indexed Power Law Multi Segment Bipartite Graph multi Segment Left Indexed Power Law Bipartite Graph = new  Left Indexed Power Law Multi Segment Bipartite Graph ( max Num Segments , max Num Edges Per Segment , left Size / _ NUM , ( int ) ( right Size * edge Probability / _ NUM ) , _ NUM , right Size / _ NUM , new  Identity Edge Type Mask ( ) , new  Null Stats Receiver ( ) ) ; for ( int i = _ NUM ; i < left Size ; i ++ ) { for ( int j = _ NUM ; j < right Size ; j ++ ) { if ( random . next Double ( ) < edge Probability ) { multi Segment Left Indexed Power Law Bipartite Graph . add Edge ( i , j , ( byte ) _ NUM ) ; } } } return multi Segment Left Indexed Power Law Bipartite Graph ; }
public static  String execute (  String command ) { return execute ( command , null ) ; }
public static  Range iterate Range Bounds (  Category Dataset dataset , boolean include Interval ) { double minimum =  Double .  POSITIVE_ INFINITY ; double maximum =  Double .  NEGATIVE_ INFINITY ; int row Count = dataset . get Row Count ( ) ; int column Count = dataset . get Column Count ( ) ; if ( include Interval && dataset instanceof  Interval Category Dataset ) {  Interval Category Dataset icd = (  Interval Category Dataset ) dataset ;  Number value , lvalue , uvalue ; for ( int row = _ NUM ; row < row Count ; row ++ ) { for ( int column = _ NUM ; column < column Count ; column ++ ) { value = icd . get Value ( row , column ) ; double v ; if ( ( value != null ) && !  Double . is Na N ( v = value . double Value ( ) ) ) { minimum =  Math . min ( v , minimum ) ; maximum =  Math . max ( v , maximum ) ; } lvalue = icd . get Start Value ( row , column ) ; if ( lvalue != null && !  Double . is Na N ( v = lvalue . double Value ( ) ) ) { minimum =  Math . min ( v , minimum ) ; maximum =  Math . max ( v , maximum ) ; } uvalue = icd . get End Value ( row , column ) ; if ( uvalue != null && !  Double . is Na N ( v = uvalue . double Value ( ) ) ) { minimum =  Math . min ( v , minimum ) ; maximum =  Math . max ( v , maximum ) ; } } } } else { for ( int row = _ NUM ; row < row Count ; row ++ ) { for ( int column = _ NUM ; column < column Count ; column ++ ) {  Number value = dataset . get Value ( row , column ) ; if ( value != null ) { double v = value . double Value ( ) ; if ( !  Double . is Na N ( v ) ) { minimum =  Math . min ( minimum , v ) ; maximum =  Math . max ( maximum , v ) ; } } } } } if ( minimum ==  Double .  POSITIVE_ INFINITY ) { return null ; } else { return new  Range ( minimum , maximum ) ; } }
@  Suppress Warnings ( _ STR ) protected  Context Handler create Context (  String filename ) throws  Exception {  Resource resource =  Resource . new Resource ( filename ) ; if ( ! resource . exists ( ) ) { return null ; }  Xml Configuration xml Configuration = new  Xml Configuration ( resource . get URL ( ) ) ;  Hash Map properties = new  Hash Map ( ) ; properties . put ( _ STR , _contexts . get Server ( ) ) ; if ( _config Mgr != null ) { properties . put All ( _config Mgr . get Properties ( ) ) ; } xml Configuration . set Properties ( properties ) ;  Context Handler context = (  Context Handler ) xml Configuration . configure ( ) ;  Enumeration < ? > names = _attributes . get Attribute Names ( ) ; while ( names . has More Elements ( ) ) {  String name = (  String ) names . next Element ( ) ; context . set Attribute ( name , _attributes . get Attribute ( name ) ) ; } return context ; }
public boolean starts With ( java . lang .  String prefix ) { return starts With ( prefix , _ NUM ) ; }
static  String gen Initializers ( ) { return initializers . to String ( ) ; }
public static  Temp Path create Directory (  Path dir ) throws  IOException { return wrap (  Files . create Temp Directory ( dir ,  PREFIX ) ) ; }
public static  String to String ( int [ ] oid ) {  String Builder sb = new  String Builder ( _ NUM * oid . length ) ; for ( int i = _ NUM ; i < oid . length - _ NUM ; ++ i ) { sb . append ( oid [ i ] ) ; sb . append ( _ STR ) ; } sb . append ( oid [ oid . length - _ NUM ] ) ; return sb . to String ( ) ; }
public static boolean is Category Top (  Servlet Request request ,  String product Category Id ) { return is Category Top ( (  Delegator ) request . get Attribute ( _ STR ) , (  Local Dispatcher ) request . get Attribute ( _ STR ) , product Category Id ) ; }
@  Override public boolean input (  Instance instance ) { if ( get Input Format ( ) == null ) { throw new  Illegal State Exception ( _ STR ) ; } if ( m_ New Batch ) { reset Queue ( ) ; m_ New Batch = _ BOOL ; } if ( is First Batch Done ( ) ) { push ( instance ) ; return _ BOOL ; } else { buffer Input ( instance ) ; return _ BOOL ; } }
public  Collection <  String > list Tables ( ) throws  Database Exception {  Collection <  String > result = new  Array List <  String > ( ) ;  Result Set rs = null ; try {  Database Meta Data dbm = connection . get Meta Data ( ) ;  String types [ ] = { _ STR } ; rs = dbm . get Tables ( null , null , null , types ) ; while ( rs . next ( ) ) {  String str = rs . get String ( _ STR ) ; result . add ( str ) ; } } catch (  SQLException e ) { throw ( new  Database Exception ( e ) ) ; } finally { if ( rs != null ) { try { rs . close ( ) ; } catch (  SQLException e ) { } } } return result ; }
public void add Preexisting Resource (  Resource resource ) { resource List . add ( resource ) ; }
public void wait For Event ( long timeout ) {  Thread thread =  Thread . current Thread ( ) ;  Semaphore semaphore = _semaphores . get ( thread ) ; if ( semaphore == null ) { semaphore = new  Semaphore ( _ NUM , _ BOOL ) ; semaphore . drain Permits ( ) ; _semaphores . put If Absent ( thread , semaphore ) ; } semaphore = _semaphores . get ( thread ) ; try { semaphore . try Acquire ( timeout ,  Time Unit .  MILLISECONDS ) ; } catch (  Interrupted Exception exception ) { logger . log (  Level .  FINER , _ STR , exception ) ; } }
@  Override public boolean equals (  Object obj ) { if ( obj == this ) { return _ BOOL ; } if ( ! ( obj instanceof  Pie Dataset ) ) { return _ BOOL ; }  Pie Dataset that = (  Pie Dataset ) obj ; int count = get Item Count ( ) ; if ( that . get Item Count ( ) != count ) { return _ BOOL ; } for ( int i = _ NUM ; i < count ; i ++ ) {  Comparable k1 = get Key ( i ) ;  Comparable k2 = that . get Key ( i ) ; if ( ! k1 . equals ( k2 ) ) { return _ BOOL ; }  Number v1 = get Value ( i ) ;  Number v2 = that . get Value ( i ) ; if ( v1 == null ) { if ( v2 != null ) { return _ BOOL ; } } else { if ( ! v1 . equals ( v2 ) ) { return _ BOOL ; } } } return _ BOOL ; }
protected boolean are All Dbsvc Active ( ) {  Coordinator Client coordinator Client = coordinator . get Coordinator Client ( ) ;  List <  Service > active Dbsvcs = coordinator Client . locate All Svcs All Vers (  Constants .  DBSVC_ NAME ) ;  List <  String > active Dbsvc Ids = new  Array List < > ( active Dbsvcs . size ( ) ) ; for (  Service active Dbsvc : active Dbsvcs ) { active Dbsvc Ids . add ( active Dbsvc . get Id ( ) ) ; } log . info ( _ STR , active Dbsvc Ids , node Count ) ; boolean all Active = active Dbsvcs . size ( ) == node Count ; if ( ! all Active ) { log . info ( _ STR ) ; } return all Active ; }
public static void moniter Test (  Context context , int interval , int test Time ) { long start Time =  System . current Time Millis ( ) ; while ( (  System . current Time Millis ( ) - start Time ) < test Time ) {  String memory Usage String = get My Tracks Pss Memory Info ( context ) ;  String battery Usage String = get Battery Usage Info ( context ) ;  String one Info =  String . format ( _ STR ,  String . format ( _ STR , new  Date ( ) ) , memory Usage String , battery Usage String ) ; write To File ( one Info , _ BOOL ) ;  Log . d (  TAG , one Info ) ;  End To End Test Utils . sleep ( interval ) ; } }
public boolean is Stop Requested ( ) { if ( stop Requested . get ( ) == _ BOOL ) return _ BOOL ; else return _ BOOL ; }
@  Suppress Warnings ( { _ STR } ) public static <  T >  T [ ] join (  Class <  T > component Type ,  T [ ] [ ] arrays ) { if ( arrays . length == _ NUM ) { return arrays [ _ NUM ] ; } int length = _ NUM ; for (  T [ ] array : arrays ) { length += array . length ; }  T [ ] result = (  T [ ] )  Array . new Instance ( component Type , length ) ; length = _ NUM ; for (  T [ ] array : arrays ) {  System . arraycopy ( array , _ NUM , result , length , array . length ) ; length += array . length ; } return result ; }
private  Set <  T > convert Results (  Collection <  Token > tokens ) {  Set <  T > results = new  Hash Set <  T > ( ) ; for (  Token token : tokens ) { results . add ( adapter . from Token ( token ) ) ; } return results ; }
public  Action Forward validate User (  Action Mapping mapping ,  Action Form form ,  Http Servlet Request request ,  Http Servlet Response response ) throws  Exception {  Properties ctx =  Tmk JSPEnv . get Ctx ( request ) ;  Default Form df = (  Default Form ) form ;  Login Bean bean = (  Login Bean ) df . get Bean ( ) ;  Http Session session = request . get Session ( ) ;  Web User Info info = null ;  Web User wu = null ; try { wu = bd . check Login Password ( ctx , bean ) ; info = bd . login ( ctx , wu ) ;  MSession c Session =  MSession . get ( ctx , request . get Remote Addr ( ) , request . get Remote Host ( ) , session . get Id ( ) ) ; if ( c Session != null ) c Session . set Web Store Session ( _ BOOL ) ; session . set Attribute (  Web User Info .  NAME , info ) ;  Array List my Roles =  Role Manager . get My Roles ( ctx ) ; if ( my Roles . size ( ) == _ NUM ) {  Key Name Pair pair = (  Key Name Pair ) my Roles . get ( _ NUM ) ;  Env . set Context ( ctx , _ STR , pair . get Key ( ) ) ;  Session Storage . put Menus ( ctx , request ) ;  Session Storage . put Org ( ctx , request ) ; return mapping . find Forward (  LOGIN_ SUCCESS ) ; } } catch (  User Not Found Exception unfe ) { post Global Error ( _ STR , request ) ; return ( mapping . get Input Forward ( ) ) ; } catch (  Not Logged In Exception e ) { post Global Error ( _ STR , request ) ; return ( mapping . get Input Forward ( ) ) ; } catch (  Invalid Role Exception ire ) { post Global Error ( _ STR , request ) ; return ( mapping . get Input Forward ( ) ) ; } catch (  User Inactive Exception unae ) { post Global Error ( _ STR , request ) ; return ( mapping . get Input Forward ( ) ) ; } return mapping . find Forward (  INIT_ CHOOSE_ ROLE ) ; }
protected void notify ( final  IChange Record record ) { final  Bigdata Graph Edit edit = to Graph Edit ( record ) ; if ( edit != null ) { for (  Bigdata Graph Listener listener : listeners ) { listener . graph Edited ( edit , record . to String ( ) ) ; } } }
public void add Job (  Runnable job ) { m Jobs . add ( job ) ; }
public  Class Constant add Class (  String name ) {  Class Constant entry = get Class ( name ) ; if ( entry != null ) return entry ;  Utf8 Constant utf8 = add UTF8 ( name ) ; entry = new  Class Constant ( this , _entries . size ( ) , utf8 . get Index ( ) ) ; add Constant ( entry ) ; return entry ; }
void write External (  Data Output out ) throws  IOException { final int time Secs = ( time End Of Day ? _ NUM : time . to Second Of Day ( ) ) ; final int std Offset = standard Offset . get Total Seconds ( ) ; final int before Diff = offset Before . get Total Seconds ( ) - std Offset ; final int after Diff = offset After . get Total Seconds ( ) - std Offset ; final int time Byte = ( time Secs % _ NUM == _ NUM ? ( time End Of Day ? _ NUM : time . get Hour ( ) ) : _ NUM ) ; final int std Offset Byte = ( std Offset % _ NUM == _ NUM ? std Offset / _ NUM + _ NUM : _ NUM ) ; final int before Byte = ( before Diff == _ NUM || before Diff == _ NUM || before Diff == _ NUM ? before Diff / _ NUM : _ NUM ) ; final int after Byte = ( after Diff == _ NUM || after Diff == _ NUM || after Diff == _ NUM ? after Diff / _ NUM : _ NUM ) ; final int dow Byte = ( dow == null ? _ NUM : dow . get Value ( ) ) ; int b = ( month . get Value ( ) << _ NUM ) + ( ( dom + _ NUM ) << _ NUM ) + ( dow Byte << _ NUM ) + ( time Byte << _ NUM ) + ( time Definition . ordinal ( ) << _ NUM ) + ( std Offset Byte << _ NUM ) + ( before Byte << _ NUM ) + after Byte ; out . write Int ( b ) ; if ( time Byte == _ NUM ) { out . write Int ( time Secs ) ; } if ( std Offset Byte == _ NUM ) { out . write Int ( std Offset ) ; } if ( before Byte == _ NUM ) { out . write Int ( offset Before . get Total Seconds ( ) ) ; } if ( after Byte == _ NUM ) { out . write Int ( offset After . get Total Seconds ( ) ) ; } }
@  Suppress Warnings ( { _ STR } ) public static <  T extends  Serializable >  T deserialize Jdk ( byte [ ] bytes ) throws  IOException ,  Class Not Found Exception {  Object Input Stream in = null ; try { in = new  Object Input Stream ( new  Byte Array Input Stream ( bytes ) ) ; return (  T ) in . read Object ( ) ; } finally { close ( in ) ; } }
public void test Case20 ( ) { byte a Bytes [ ] = { _ NUM } ; byte b Bytes [ ] = { _ NUM } ; byte r Bytes [ ] = { _ NUM } ; int a Sign = _ NUM ; int b Sign = _ NUM ;  Big Integer a Number = new  Big Integer ( a Sign , a Bytes ) ;  Big Integer b Number = new  Big Integer ( b Sign , b Bytes ) ;  Big Integer result = a Number . subtract ( b Number ) ; byte res Bytes [ ] = new byte [ r Bytes . length ] ; res Bytes = result . to Byte Array ( ) ; for ( int i = _ NUM ; i < res Bytes . length ; i ++ ) { assert True ( res Bytes [ i ] == r Bytes [ i ] ) ; } assert Equals ( _ NUM , result . signum ( ) ) ; }
@  Override public void run ( ) { am IActive = _ BOOL ; panel = new  Coordinate Transform Dialog ( my Host ) ; if ( my Host instanceof  JFrame ) {  JDialog dialog = new  JDialog ( (  JFrame ) my Host , _ STR , _ BOOL ) ;  Container content Pane = dialog . get Content Pane ( ) ; content Pane . add ( panel ,  Border Layout .  CENTER ) ; dialog . set Default Close Operation (  JFrame .  DISPOSE_ ON_ CLOSE ) ; dialog . pack ( ) ; dialog . set Location Relative To ( null ) ; dialog . set Visible ( _ BOOL ) ; } else {  JFrame frame = new  JFrame ( _ STR ) ;  Container content Pane = frame . get Content Pane ( ) ; content Pane . add ( panel ,  Border Layout .  CENTER ) ; frame . set Default Close Operation (  JFrame .  DISPOSE_ ON_ CLOSE ) ; frame . pack ( ) ; frame . set Location Relative To ( null ) ; frame . set Visible ( _ BOOL ) ; } }
public void decrypt ( byte [ ] in , int length ) { int pos = _ NUM ; while ( pos < in . length && pos < length ) { decrypt Block ( in , pos , length ) ; pos += block Size ; } }
private static  Class register Type Mapping (  RPCServer server ,  Class clazz ) { java . lang . reflect .  Method [ ] methods = clazz . get Methods ( ) ; java . lang . reflect .  Method method ;  Class [ ] params ; for ( int i = _ NUM ; i < methods . length ; i ++ ) { method = methods [ i ] ; if ( method . get Declaring Class ( ) == clazz ) { _register Type Mapping ( server , method . get Return Type ( ) ) ; params = method . get Parameter Types ( ) ; for ( int y = _ NUM ; y < params . length ; y ++ ) { _register Type Mapping ( server , params [ y ] ) ; } } } return clazz ; }
private  Ascii Funcs ( ) { }
protected  String safe Get Template Name (  Template template ) { if ( template == null ) return null ;  String name = template . get Name ( ) ; if ( name == null ) return null ;  String decoded Name = name ; if ( decoded Name . index Of ( _ STR ) != - _ NUM ) { decoded Name =  String Util . replace ( decoded Name , _ STR , _ STR , _ BOOL , _ BOOL ) ; decoded Name =  String Util . replace ( decoded Name , _ STR , _ STR , _ BOOL , _ BOOL ) ; decoded Name =  String Util . replace ( decoded Name , _ STR , _ STR , _ BOOL , _ BOOL ) ; decoded Name =  String Util . replace ( decoded Name , _ STR , _ STR , _ BOOL , _ BOOL ) ; decoded Name =  String Util . replace ( decoded Name , _ STR , _ STR , _ BOOL , _ BOOL ) ; decoded Name =  String Util . replace ( decoded Name , _ STR , _ STR , _ BOOL , _ BOOL ) ; } int dot Dot Idx = decoded Name . index Of ( _ STR ) ; if ( dot Dot Idx != - _ NUM ) { int before = dot Dot Idx - _ NUM >= _ NUM ? decoded Name . char At ( dot Dot Idx - _ NUM ) : - _ NUM ; int after = dot Dot Idx + _ NUM < decoded Name . length ( ) ? decoded Name . char At ( dot Dot Idx + _ NUM ) : - _ NUM ; if ( ( before == - _ NUM || before == _ STR || before == _ STR ) && ( after == - _ NUM || after == _ STR || after == _ STR ) ) { return null ; } } return name . starts With ( _ STR ) ? name . substring ( _ NUM ) : name ; }
public  Cut Action ( final  Network Panel network Panel ) { super ( network Panel , _ STR ,  Enabling Condition .  NEURONS ) ;  Toolkit toolkit =  Toolkit . get Default Toolkit ( ) ;  Key Stroke key Stroke =  Key Stroke . get Key Stroke (  Key Event .  VK_ X , toolkit . get Menu Shortcut Key Mask ( ) ) ; put Value (  ACCELERATOR_ KEY , key Stroke ) ; put Value (  SMALL_ ICON ,  Resource Manager . get Image Icon ( _ STR ) ) ; put Value (  SHORT_ DESCRIPTION , _ STR ) ; }
public static boolean place Image Url (  Link link ) {  String url = link . get Url ( ) ; if ( ! url . starts With ( _ STR ) ) { url += _ STR ; }  String domain = link . get Domain ( ) ; if ( domain . contains ( _ STR ) ) { if ( url . contains ( _ STR ) ) { return _ BOOL ; } else if ( ends With Image Extension ( url ,  GIFV ) ) { return _ BOOL ; } else if ( url . contains ( _ STR ) ) { return _ BOOL ; } else if ( url . contains ( _ STR ) ) { return _ BOOL ; } else if ( ! check Is Image Url ( url ) ) { if ( url . char At ( url . length ( ) - _ NUM ) == _ STR ) { url = url . substring ( _ NUM , url . length ( ) - _ NUM ) ; } url += _ STR ; } } boolean is Image = check Is Image Url ( url ) ; if ( ! is Image ) { return _ BOOL ; } link . set Url ( url ) ; return _ BOOL ; }
private  Set <  Eg Demand Details > create All Dmd Details ( final  List <  Installment > inst List , final  Hash Map <  Installment ,  Tax Calculation Info > inst Tax Map ) {  LOGGER . debug ( _ STR ) ; final  Set <  Eg Demand Details > dmd Det Set = new  Hash Set <  Eg Demand Details > ( ) ; for ( final  Installment inst : inst List ) { final  Tax Calculation Info tax Calc Info = inst Tax Map . get ( inst ) ; final  Map <  String ,  Big Decimal > tax Map = tax Calculator . get Misc Taxes For Prop ( tax Calc Info . get Unit Tax Calculation Infos ( ) ) ; for ( final  Map .  Entry <  String ,  Big Decimal > tax : tax Map . entry Set ( ) ) { final  Eg Demand Reason eg Dmd Rsn = property Tax Util . get Demand Reason By Code And Installment ( tax . get Key ( ) , inst ) ; dmd Det Set . add ( create Demand Details ( tax . get Value ( ) , eg Dmd Rsn , inst ) ) ; } }  LOGGER . debug ( _ STR + dmd Det Set ) ; return dmd Det Set ; }
public static boolean is Email Id Valid (  String email ) {  String expression = _ STR ;  Pattern pattern =  Pattern . compile ( expression ,  Pattern .  CASE_ INSENSITIVE ) ;  Matcher matcher = pattern . matcher ( email ) ; return matcher . matches ( ) ; }
public void add (  String category ,  String [ ] titles , double [ ] values ) { m Categories . add ( category ) ; m Titles . add ( titles ) ; m Values . add ( values ) ; }
public static  Web Xml parse Web Xml From File (  File the File ,  Entity Resolver the Entity Resolver ) throws  IOException ,  JDOMException {  Input Stream in = null ; try { in = new  File Input Stream ( the File ) ; return parse Web Xml ( in , the Entity Resolver ) ; } finally { if ( in != null ) { try { in . close ( ) ; } catch (  IOException ioe ) { } } } }
protected void close Channel (  Socket Channel channel ) { if ( channel == null ) return ;  Socket socket = channel . socket ( ) ; try { socket . shutdown Input ( ) ; socket . shutdown Output ( ) ; socket . close ( ) ; } catch (  IOException ex ) { if ( _logger . is Loggable (  Level .  FINE ) ) { _logger . log (  Level .  FINE , _ STR , ex ) ; } } finally { try { channel . close ( ) ; } catch (  IOException ex ) { if ( _logger . is Loggable (  Level .  FINE ) ) { _logger . log (  Level .  FINE , _ STR , ex ) ; } } } }
public  String attributes To String ( ) {  String Buffer text = new  String Buffer ( ) ; int j = _ NUM ; for ( int i = _ NUM ; i < m_attributes . length ; i ++ ) { if ( m_attributes [ i ] ) { if ( is Gaussian ( ) ) { text . append ( _ STR + i ) ; text . append ( _ STR + m_mean Value [ j ] ) ; text . append ( _ STR + m_stddev Value [ j ] + _ STR ) ; } else { text . append ( _ STR + i ) ; text . append ( _ STR + m_min Value [ j ] ) ; text . append ( _ STR + m_max Value [ j ] + _ STR ) ; } j ++ ; } } return text . to String ( ) ; }
public void add Subscription To Store ( final  String topic , final  String client Id ) { final  Client Topic Couple subscription = new  Client Topic Couple ( client Id , topic ) ; if ( ! topics . contains ( topic ) ) { logger . debug ( _ STR + topic + _ STR + client Id + _ STR ) ; subscriptions Store . add ( subscription ) ; topics . add ( topic ) ; } }
public boolean copy (  String to Rpf Dir ) {  File to Dir = new  File ( to Rpf Dir ) ; boolean ret = _ BOOL ;  String source Rpf Dir = get Rpf Dir ( ) ; if ( ( to Dir . exists ( ) || to Dir . mkdirs ( ) ) && frame List != null ) { if ( verbose ) {  Debug . output ( _ STR + source Rpf Dir + _ STR + to Rpf Dir + _ STR ) ; } for (  Iterator <  String > it = frame List . iterator ( ) ; it . has Next ( ) ; ) {  String relative File Path = _ STR + it . next ( ) ;  File from File = new  File ( source Rpf Dir + relative File Path ) ;  File to File = new  File ( to Rpf Dir + relative File Path ) ;  File to Parent = to File . get Parent File ( ) ; if ( ! to Parent . exists ( ) ) { to Parent . mkdirs ( ) ; } if ( verbose ) {  Debug . output ( _ STR + relative File Path ) ; } try {  File Utils . copy ( from File , to File , _ NUM ) ; } catch (  IOException ioe ) {  Debug . error ( _ STR + ioe . get Message ( ) ) ; return _ BOOL ; } } ret = _ BOOL ; } return ret ; }
private  Hash Map <  Integer ,  Boolean > generate Expanded State Map (  List <  Object > item List ) {  Hash Map <  Integer ,  Boolean > parent Object Hash Map = new  Hash Map < > ( ) ; int child Count = _ NUM ; for ( int i = _ NUM ; i < item List . size ( ) ; i ++ ) { if ( item List . get ( i ) != null ) {  Object helper Item = get Helper Item ( i ) ; if ( helper Item instanceof  Parent Wrapper ) {  Parent Wrapper parent Wrapper = (  Parent Wrapper ) helper Item ; parent Object Hash Map . put ( i - child Count , parent Wrapper . is Expanded ( ) ) ; } else { child Count ++ ; } } } return parent Object Hash Map ; }
public static void add Listener (  Listener listener ) { listeners . add Last ( listener ) ; }
public  Freshest CRLExtension (  Boolean critical ,  Object value ) throws  IOException { super (  PKIXExtensions .  Freshest CRL_ Id , critical . boolean Value ( ) , value ,  NAME ) ; }
public  Minecraft Directory (  File root Dir ) {  Objects . require Non Null ( root Dir ) ; this . root Dir = root Dir . get Absolute File ( ) ; }
private  String print OFormat ( long x ) {  String sx = null ; if ( x ==  Long .  MIN_ VALUE ) sx = _ STR ; else if ( x < _ NUM ) {  String t =  Long . to String ( ( ~ ( - x - _ NUM ) ) ^  Long .  MIN_ VALUE , _ NUM ) ; switch ( t . length ( ) ) { case _ NUM : sx = _ STR + t ; break ; case _ NUM : sx = _ STR + t ; break ; case _ NUM : sx = _ STR + t ; break ; case _ NUM : sx = _ STR + t ; break ; case _ NUM : sx = _ STR + t ; break ; case _ NUM : sx = _ STR + t ; break ; case _ NUM : sx = _ STR + t ; break ; case _ NUM : sx = _ STR + t ; break ; case _ NUM : sx = _ STR + t ; break ; case _ NUM : sx = _ STR + t ; break ; case _ NUM : sx = _ STR + t ; break ; case _ NUM : sx = _ STR + t ; break ; case _ NUM : sx = _ STR + t ; break ; case _ NUM : sx = _ STR + t ; break ; case _ NUM : sx = _ STR + t ; break ; case _ NUM : sx = _ STR + t ; break ; case _ NUM : sx = _ STR + t ; break ; case _ NUM : sx = _ STR + t ; break ; case _ NUM : sx = _ STR + t ; break ; case _ NUM : sx = _ STR + t ; break ; case _ NUM : sx = _ STR + t ; break ; } } else sx =  Long . to String ( x , _ NUM ) ; return print OFormat ( sx ) ; }
void remove Callback (  JSObject source ,  String method , boolean async ) {  String key = source . to JSPointer ( ) + _ STR + method ; callbacks . remove ( key ) ;  String js = _ STR + source . to JSPointer ( ) + _ STR + method ; exec ( js , async ) ; }
protected boolean remove (  Object s ) { boolean found = _ BOOL ; for ( int i = _ NUM ; i < sensor Image . size ( ) ; i ++ ) { if ( s == sensor Image . get ( i ) ) { sensor Image . remove ( i ) ; found = _ BOOL ; break ; } } for ( int i = _ NUM ; i < sensor List . size ( ) ; i ++ ) { if ( s == sensor List . get ( i ) ) { sensor List . remove ( i ) ; found = _ BOOL ; break ; } } for ( int i = _ NUM ; i < background Image . size ( ) ; i ++ ) { if ( s == background Image . get ( i ) ) { background Image . remove ( i ) ; found = _ BOOL ; break ; } } for ( int i = _ NUM ; i < memory Label List . size ( ) ; i ++ ) { if ( s == memory Label List . get ( i ) ) { memory Label List . remove ( i ) ; found = _ BOOL ; break ; } } for ( int i = _ NUM ; i < block Contents Label List . size ( ) ; i ++ ) { if ( s == block Contents Label List . get ( i ) ) { block Contents Label List . remove ( i ) ; found = _ BOOL ; break ; } } for ( int i = _ NUM ; i < signal List . size ( ) ; i ++ ) { if ( s == signal List . get ( i ) ) { signal List . remove ( i ) ; found = _ BOOL ; break ; } } for ( int i = _ NUM ; i < signal Mast List . size ( ) ; i ++ ) { if ( s == signal Mast List . get ( i ) ) { if ( remove Signal Mast ( (  Signal Mast Icon ) s ) ) { signal Mast List . remove ( i ) ; found = _ BOOL ; break ; } else { return _ BOOL ; } } } for ( int i = _ NUM ; i < multi Sensors . size ( ) ; i ++ ) { if ( s == multi Sensors . get ( i ) ) { multi Sensors . remove ( i ) ; found = _ BOOL ; break ; } } for ( int i = _ NUM ; i < clocks . size ( ) ; i ++ ) { if ( s == clocks . get ( i ) ) { clocks . remove ( i ) ; found = _ BOOL ; break ; } } for ( int i = _ NUM ; i < signal Head Image . size ( ) ; i ++ ) { if ( s == signal Head Image . get ( i ) ) { signal Head Image . remove ( i ) ; found = _ BOOL ; break ; } } for ( int i = _ NUM ; i < label Image . size ( ) ; i ++ ) { if ( s == label Image . get ( i ) ) { label Image . remove ( i ) ; found = _ BOOL ; break ; } } super . remove From Contents ( (  Positionable ) s ) ; if ( found ) { set Dirty ( _ BOOL ) ; repaint ( ) ; } return found ; }
public static  String read File To String (  Path file ) throws  IOException { byte [ ] file Array =  Files . read All Bytes ( file ) ; return new  String ( file Array ,  Standard Charsets .  UTF_8 ) ; }
private static void collect ( final  INavi Operand Tree Node current Node , final  List <  INavi Operand Tree Node > nodes ) { nodes . add ( current Node ) ; for ( final  INavi Operand Tree Node child : current Node . get Children ( ) ) { collect ( child , nodes ) ; } }
@  Override public void on Value Selected ( int picker Index , int new Value , boolean auto Advance ) { if ( picker Index ==  HOUR_ INDEX ) { set Hour ( new Value , _ BOOL ) ;  String announcement =  String . format ( _ STR , new Value ) ; if ( m Allow Auto Advance && auto Advance ) { set Current Item Showing (  MINUTE_ INDEX , _ BOOL , _ BOOL , _ BOOL ) ; announcement += _ STR + m Select Minutes ; } else { m Time Picker . set Content Description ( m Hour Picker Description + _ STR + new Value ) ; }  Utils . try Accessibility Announce ( m Time Picker , announcement ) ; } else if ( picker Index ==  MINUTE_ INDEX ) { set Minute ( new Value ) ; m Time Picker . set Content Description ( m Minute Picker Description + _ STR + new Value ) ; } else if ( picker Index ==  AMPM_ INDEX ) { update Half Day ( new Value ) ; } else if ( picker Index ==  ENABLE_ PICKER_ INDEX ) { if ( ! is Typed Time Fully Legal ( ) ) { m Typed Times . clear ( ) ; } } }
public static double point Circle Distance (  Geo p1 ,  Geo p2 ,  Geo center ) {  Geo n =  Geo . cross Normalize ( p1 , p2 , new  Geo ( ) ) ;  Geo c = center . normalize ( new  Geo ( ) ) ; double cos Theta =  Geo . dot ( n , c ) ; double theta =  Math . acos ( cos Theta ) ; return  Math . abs (  Math .  PI / _ NUM - theta ) ; }
public void add Action (  Network Update Action action ) { action List . add ( action ) ; for (  Update Manager Listener listener : listeners ) { listener . action Added ( action ) ; } }
private void load (  Byte Buffer bb ) throws  Buffer Underflow Exception ,  Mary Configuration Exception { int num Idx = bb . get Int ( ) ; idx Interval = bb . get Int ( ) ; if ( idx Interval <= _ NUM ) { throw new  Mary Configuration Exception ( _ STR ) ; } byte Ptrs = new long [ num Idx ] ; time Ptrs = new long [ num Idx ] ; for ( int i = _ NUM ; i < num Idx ; i ++ ) { byte Ptrs [ i ] = bb . get Long ( ) ; time Ptrs [ i ] = bb . get Long ( ) ; if ( i > _ NUM ) { if ( byte Ptrs [ i ] < byte Ptrs [ i - _ NUM ] || time Ptrs [ i ] < time Ptrs [ i - _ NUM ] ) { throw new  Mary Configuration Exception ( _ STR ) ; } } } bb . get Long ( ) ; bb . get Long ( ) ; }
protected void clean Cache ( long time Window ) { long current Time =  System . current Time Millis ( ) ;  Enumeration keys = timestamps . keys ( ) ; while ( keys . has More Elements ( ) ) {  Object tester = keys . next Element ( ) ;  Long time = (  Long ) timestamps . get ( tester ) ; if ( ( current Time - time . long Value ( ) ) >= time Window ) { caches . remove ( tester ) ; timestamps . remove ( tester ) ; view Attribute Lists . remove ( tester ) ; if (  Debug . debugging ( _ STR ) ) {  Debug . output ( _ STR + caches . size ( ) + _ STR ) ; } } } }
private  String create Non CGSrdf Pair Steps On Populated Group (  List <  Volume Descriptor > source Descriptors ,  List <  Volume Descriptor > target Descriptors ,  Remote Director Group group ,  Map <  URI ,  Volume > uri Volume Map ,  String wait For ,  Workflow workflow ) {  Storage System system = db Client . query Object (  Storage System . class , group . get Source Storage System Uri ( ) ) ;  URI vpool Change Uri = get Virtual Pool Change Volume ( source Descriptors ) ; log . info ( _ STR , vpool Change Uri ) ;  List <  URI > source URIs =  Volume Descriptor . get Volume URIs ( source Descriptors ) ;  List <  URI > target URIs = new  Array List < > ( ) ; for (  URI source URI : source URIs ) {  Volume source = uri Volume Map . get ( source URI ) ;  String Set srdf Targets = source . get Srdf Targets ( ) ; for (  String target Str : srdf Targets ) {  URI target URI =  URI . create ( target Str ) ; target URIs . add ( target URI ) ; } }  Method suspend Group Method = suspend SRDFGroup Method ( system . get Id ( ) , group , source URIs , target URIs ) ;  Method resume Rollback Method = resume SRDFGroup Method ( system . get Id ( ) , group , source URIs , target URIs ) ;  String suspend Group Step = workflow . create Step (  CREATE_ SRDF_ ACTIVE_ VOLUME_ PAIR_ STEP_ GROUP ,  SUSPEND_ SRDF_ MIRRORS_ STEP_ DESC , wait For , system . get Id ( ) , system . get System Type ( ) , get Class ( ) , suspend Group Method , resume Rollback Method , null ) ;  Method create List Method = create List Replicas Method ( system . get Id ( ) , source URIs , target URIs , vpool Change Uri , _ BOOL ) ;  Method rollback Method = rollback SRDFLinks Method ( system . get Id ( ) , source URIs , target URIs , _ BOOL ) ;  String create List Replica Step = workflow . create Step (  CREATE_ SRDF_ ACTIVE_ VOLUME_ PAIR_ STEP_ GROUP ,  CREATE_ SRDF_ ACTIVE_ VOLUME_ PAIR_ STEP_ DESC , suspend Group Step , system . get Id ( ) , system . get System Type ( ) , get Class ( ) , create List Method , rollback Method , null ) ;  Method resume Group Method = resume SRDFGroup Method ( system . get Id ( ) , group , source URIs , target URIs ) ;  String resume Group Step = workflow . create Step (  CREATE_ SRDF_ ACTIVE_ VOLUME_ PAIR_ STEP_ GROUP ,  RESUME_ SRDF_ MIRRORS_ STEP_ DESC , create List Replica Step , system . get Id ( ) , system . get System Type ( ) , get Class ( ) , resume Group Method , rollback Method Null Method ( ) , null ) ; return resume Group Step ; }
private static  Statistics Provider stats Init (  List <  Object > args ) { int window Size = _ NUM ; if ( args . size ( ) > _ NUM && args . get ( _ NUM ) instanceof  Number ) { window Size = convert ( args . get ( _ NUM ) ,  Integer . class ) ; } if ( window Size > _ NUM ) { return new  Windowed Statistics Provider ( window Size ) ; } return new  Online Statistics Provider ( ) ; }
public  String print List (  My Idx List points ) { if ( points == null || points . length ( ) == _ NUM ) { return _ STR ; }  String Buffer bf = new  String Buffer ( ) ; try {  List Node temp ; for ( int i = _ NUM ; i < points . size ( ) ; i ++ ) { temp = points . get ( i ) ; if ( i == _ NUM ) { bf . append ( _ STR + temp . idx ) ; } else { bf . append ( _ STR + temp . idx ) ; } } } catch (  Exception ex ) { ex . print Stack Trace ( ) ; } return bf . to String ( ) ; }
public static  File extract Archive (  File archive ,  File destination ) {  File directory = get Unique File ( destination , archive . get Name ( ) ) ;  Zip File zip File = null ; try { prepare Directory ( directory ) ; zip File = new  Zip File ( archive ) ;  Enumeration < ? extends  Zip Entry > entries = zip File . entries ( ) ; while ( entries . has More Elements ( ) ) {  Zip Entry entry = entries . next Element ( ) ;  File Output Stream fos = null ;  Input Stream is = null ; try { is = zip File . get Input Stream ( entry ) ; fos = new  File Output Stream ( new  File ( directory , entry . get Name ( ) ) ) ; int bytes ; byte [ ] packet = new byte [  COPY_ PACKET_ SIZE ] ; while ( ( bytes = is . read ( packet , _ NUM ,  COPY_ PACKET_ SIZE ) ) != - _ NUM ) fos . write ( packet , _ NUM , bytes ) ; } finally { try { if ( fos != null ) fos . close ( ) ; } catch (  Exception e ) {  LOGGER . log (  Level .  SEVERE , _ STR , e ) ; } try { if ( is != null ) is . close ( ) ; } catch (  Exception e ) {  LOGGER . log (  Level .  SEVERE , _ STR , e ) ; } } } } catch (  Exception e ) {  LOGGER . log (  Level .  SEVERE , _ STR , e ) ; return null ; } finally { try { if ( zip File != null ) zip File . close ( ) ; } catch (  Exception e ) {  LOGGER . log (  Level .  SEVERE , _ STR , e ) ; } } return directory ; }
public int scan (  String table ,  String startkey , int recordcount ,  Set <  String > fields ,  Vector <  Hash Map <  String ,  Byte Iterator > > result ) { long st =  System . nano Time ( ) ; int res = _db . scan ( table , startkey , recordcount , fields , result ) ; long en =  System . nano Time ( ) ; _measurements . measure ( _ STR , ( int ) ( ( en - st ) / _ NUM ) ) ; _measurements . report Return Code ( _ STR , res ) ; return res ; }
private  String normalize (  String str ) {  String rpt3 = _ STR ;  String rpt4 = _ STR ;  String rpt5 = _ STR ;  String rpt6 = _ STR ; str = str . replace All ( _ STR , _ STR ) ; str = str . replace All ( _ STR , _ STR ) ; str = str . replace All ( _ STR , _ STR ) ; str = str . replace All ( _ STR , _ STR ) ; str = str . replace All ( _ STR , _ STR ) ; str = str . replace All ( _ STR , _ STR ) ; str = str . replace All ( _ STR , _ STR ) ; str = str . replace All ( _ STR , _ STR ) ; str = str . replace All ( _ STR , _ STR ) ; str = str . replace All ( _ STR , _ STR ) ; str = str . replace All ( _ STR , _ STR ) ; str = str . replace All ( _ STR , _ STR ) ; str = str . replace All ( _ STR , _ STR ) ; str = str . replace All ( _ STR , _ STR ) ; str = str . replace All ( rpt4 , _ STR ) ; str = str . replace All ( rpt3 , _ STR ) ; str = str . replace All ( rpt5 , _ STR ) ; str = str . replace All ( rpt6 , _ STR ) ; str = replace Inlist ( str ) ; return str ; }
public static long spooky4 ( final  Bit Vector bv , final long prefix Length , final long seed , final long [ ] state ) { long h0 , h1 , h2 , h3 ; h0 = seed ; h1 = seed ; h2 =  ARBITRARY_ BITS ; h3 =  ARBITRARY_ BITS ; long pos ; if ( prefix Length >= _ NUM *  Long .  SIZE ) { final int p = _ NUM * ( int ) ( ( prefix Length - _ NUM *  Long .  SIZE ) / ( _ NUM *  Long .  SIZE ) ) ; h0 = state [ p + _ NUM ] ; h1 = state [ p + _ NUM ] ; h2 = state [ p + _ NUM ] ; h3 = state [ p + _ NUM ] ; pos = p *  Long .  SIZE + _ NUM *  Long .  SIZE ; } else pos = _ NUM ; long remaining = prefix Length - pos ; if ( remaining >=  Long .  SIZE * _ NUM ) { h0 += bv . get Long ( pos + _ NUM *  Long .  SIZE , pos + _ NUM *  Long .  SIZE ) ; h1 += bv . get Long ( pos + _ NUM *  Long .  SIZE , pos + _ NUM *  Long .  SIZE ) ; remaining -= _ NUM *  Long .  SIZE ; pos += _ NUM *  Long .  SIZE ; } if ( remaining >  Long .  SIZE ) { h2 += bv . get Long ( pos + _ NUM *  Long .  SIZE , pos + _ NUM *  Long .  SIZE ) ; h3 += bv . get Long ( pos + _ NUM *  Long .  SIZE , prefix Length ) ; } else if ( remaining > _ NUM ) { h2 += bv . get Long ( pos , prefix Length ) ; } else { h2 +=  ARBITRARY_ BITS ; h3 +=  ARBITRARY_ BITS ; } h0 += prefix Length ; h3 ^= h2 ; h2 =  Long . rotate Left ( h2 , _ NUM ) ; h3 += h2 ; h0 ^= h3 ; h3 =  Long . rotate Left ( h3 , _ NUM ) ; h0 += h3 ; h1 ^= h0 ; h0 =  Long . rotate Left ( h0 , _ NUM ) ; h1 += h0 ; h2 ^= h1 ; h1 =  Long . rotate Left ( h1 , _ NUM ) ; h2 += h1 ; h3 ^= h2 ; h2 =  Long . rotate Left ( h2 , _ NUM ) ; h3 += h2 ; h0 ^= h3 ; h3 =  Long . rotate Left ( h3 , _ NUM ) ; h0 += h3 ; h1 ^= h0 ; h0 =  Long . rotate Left ( h0 , _ NUM ) ; h1 += h0 ; h2 ^= h1 ; h1 =  Long . rotate Left ( h1 , _ NUM ) ; h2 += h1 ; h3 ^= h2 ; h2 =  Long . rotate Left ( h2 , _ NUM ) ; h3 += h2 ; h0 ^= h3 ; h3 =  Long . rotate Left ( h3 , _ NUM ) ; h0 += h3 ; h1 ^= h0 ; h0 =  Long . rotate Left ( h0 , _ NUM ) ; h1 += h0 ; return h0 ; }
public  Free Cell Node next ( ) {  String line = sc . next Line ( ) ;  String Tokenizer st = new  String Tokenizer ( line , _ STR ) ; int val =  Integer . value Of ( st . next Token ( ) ) ; if ( val != deal ) { throw new  No Such Element Exception ( _ STR + deal + _ STR ) ; } int [ ] deals = new int [ _ NUM ] ; int idx = _ NUM ; while ( st . has More Tokens ( ) ) { deals [ idx ++ ] =  Integer . value Of ( st . next Token ( ) ) ; } deal ++ ; return  Deal . initialize ( deals ) ; }
private void add To Map (  Map <  String ,  Collection <  Cluster Node > > cache Map ,  String cache Name ,  Cluster Node rich ) {  Collection <  Cluster Node > cache Nodes = cache Map . get ( cache Name ) ; if ( cache Nodes == null ) { cache Nodes = new  Array List < > ( all Nodes . size ( ) ) ; cache Map . put ( cache Name , cache Nodes ) ; } cache Nodes . add ( rich ) ; }
private static void adjust (  Object [ ] array ,  Comparator c , int lower , int upper ) { int j , k ;  Object temp ; j = lower ; k = lower * _ NUM ; while ( k <= upper ) { if ( ( k < upper ) && ( c . compare ( array [ k - _ NUM ] , array [ k ] ) < _ NUM ) ) { k += _ NUM ; } if ( c . compare ( array [ j - _ NUM ] , array [ k - _ NUM ] ) < _ NUM ) { temp = array [ j - _ NUM ] ; array [ j - _ NUM ] = array [ k - _ NUM ] ; array [ k - _ NUM ] = temp ; } j = k ; k *= _ NUM ; } }
public synchronized int index Of (  IAudio Processor processor ) { return processors . index Of ( processor ) ; }
public static void add To Trie (  Trie Node root ,  String str ,  String value ) { int index = _ NUM ; while ( index < str . length ( ) ) { root = root . get Or Create Child ( str . char At ( index ++ ) ) ; } root . set Value ( value ) ; }
protected void notify Locator (  L locator ) { synchronized ( this ) { if ( ! known Locators . add ( locator . get Partition Id ( ) ) ) { throw new  Illegal State Exception ( _ STR + locator ) ; } } }
private static void task Queued (  Progress Thread task ) { for (  Progress Thread State Listener l : listener . get Listeners (  Progress Thread State Listener . class ) ) { l . progress Thread Queued ( task ) ; } }
public static final void is XMLChar WF (  DOMError Handler error Handler ,  DOMError Impl error ,  DOMLocator Impl locator ,  String datavalue , boolean is XML11 Version ) { if ( datavalue == null || ( datavalue . length ( ) == _ NUM ) ) { return ; } char [ ] dataarray = datavalue . to Char Array ( ) ; int datalength = dataarray . length ; if ( is XML11 Version ) { int i = _ NUM ; while ( i < datalength ) { if (  XML11 Char . is XML11 Invalid ( dataarray [ i ++ ] ) ) { char ch = dataarray [ i - _ NUM ] ; if (  XMLChar . is High Surrogate ( ch ) && i < datalength ) { char ch2 = dataarray [ i ++ ] ; if (  XMLChar . is Low Surrogate ( ch2 ) &&  XMLChar . is Supplemental (  XMLChar . supplemental ( ch , ch2 ) ) ) { continue ; } }  String msg =  DOMMessage Formatter . format Message (  DOMMessage Formatter .  DOM_ DOMAIN , _ STR , new  Object [ ] {  Integer . to String ( dataarray [ i - _ NUM ] , _ NUM ) } ) ; report DOMError ( error Handler , error , locator , msg ,  DOMError .  SEVERITY_ ERROR , _ STR ) ; } } } else { int i = _ NUM ; while ( i < datalength ) { if (  XMLChar . is Invalid ( dataarray [ i ++ ] ) ) { char ch = dataarray [ i - _ NUM ] ; if (  XMLChar . is High Surrogate ( ch ) && i < datalength ) { char ch2 = dataarray [ i ++ ] ; if (  XMLChar . is Low Surrogate ( ch2 ) &&  XMLChar . is Supplemental (  XMLChar . supplemental ( ch , ch2 ) ) ) { continue ; } }  String msg =  DOMMessage Formatter . format Message (  DOMMessage Formatter .  DOM_ DOMAIN , _ STR , new  Object [ ] {  Integer . to String ( dataarray [ i - _ NUM ] , _ NUM ) } ) ; report DOMError ( error Handler , error , locator , msg ,  DOMError .  SEVERITY_ ERROR , _ STR ) ; } } } }
public  Http Request (  Method method ,  Http URI uri , boolean async ) { this . id = next Id ++ ; if ( uri == null ) {  LOG . severe ( _ STR ) ; throw new  Illegal Argument Exception ( _ STR ) ; } if ( method == null ) {  LOG . severe ( _ STR ) ; throw new  Illegal Argument Exception ( _ STR ) ; } this . method = method ; this . uri = uri ; this . async = async ; }
public  Properties load Properties (  String artifact ,  String version ) throws  IOException {  Properties props = new  Properties ( ) ;  Path properties File = get Properties File ( artifact , version ) ; if ( !  Files . exists ( properties File ) ) { throw new  Artifact Not Found Exception ( artifact , version ) ; } try (  Input Stream in = new  Buffered Input Stream (  Files . new Input Stream ( properties File ) ) ) { props . load ( in ) ; } return props ; }
public  Long File Getter In Memory (  File file ) throws  IOException { limit = file . length ( ) / _ NUM ; data = new long [ ( int ) ( ( limit > > >  BITS ) ) + _ NUM ] [ ] ; final int length0 = ( _ NUM <<  BITS ) ; for ( int i = _ NUM ; i < data . length ; i ++ ) { int length = ( i < data . length - _ NUM ? length0 : ( int ) ( limit &  BIT_ MASK ) + _ NUM ) ; data [ i ] = new long [ length ] ; } try (  Buffered Input Stream ins = new  Buffered Input Stream ( new  File Input Stream ( file ) ) ;  Progress Percentage progress = new  Progress Percentage ( _ STR + file , limit ) ) { int which Array = _ NUM ; int index In Array = _ NUM ; for ( long index = _ NUM ; index < limit ; index ++ ) { data [ which Array ] [ index In Array ] = ( ( ( long ) ins . read ( ) ) << _ NUM ) | ( ( ( long ) ins . read ( ) ) << _ NUM ) | ( ( ( long ) ins . read ( ) ) << _ NUM ) | ( ( ( long ) ins . read ( ) ) << _ NUM ) | ( ( ( long ) ins . read ( ) ) << _ NUM ) | ( ( ( long ) ins . read ( ) & _ NUM ) << _ NUM ) | ( ( ( long ) ins . read ( ) & _ NUM ) << _ NUM ) | ( ( ( long ) ins . read ( ) & _ NUM ) ) ; if ( ++ index In Array == length0 ) { which Array ++ ; index In Array = _ NUM ; } progress . set Progress ( index ) ; } } }
static int accum Single ( int counts [ ] , int doc Base ,  Field Facet Stats [ ] facet Stats ,  Sorted Doc Values si ,  Doc Id Set Iterator disi , int sub Index ,  Ordinal Map map ) throws  IOException { final  Long Values ord Map = map == null ? null : map . get Global Ords ( sub Index ) ; int missing Doc Count = _ NUM ; int doc ; while ( ( doc = disi . next Doc ( ) ) !=  Doc Id Set Iterator .  NO_ MORE_ DOCS ) { int term = si . get Ord ( doc ) ; if ( term >= _ NUM ) { if ( map != null ) { term = ( int ) ord Map . get ( term ) ; } counts [ term ] ++ ; for (  Field Facet Stats f : facet Stats ) { f . facet Term Num ( doc Base + doc , term ) ; } } else { for (  Field Facet Stats f : facet Stats ) { f . facet Missing Num ( doc Base + doc ) ; } missing Doc Count ++ ; } } return missing Doc Count ; }
public static  Element parse XML (  String xml ) throws  DSTException { try {  Document doc =  XMLUtils . to DOMDocument ( xml , debug ) ; return doc . get Document Element ( ) ; } catch (  Exception ex ) { debug . error ( _ STR , ex ) ; throw new  DSTException ( ex ) ; } }
public void mouse Release ( int x , int y , int mouse Button ) { mouse X = x ; mouse Y = y ; if (  Math . abs ( velocity ) > _ NUM ) { amplitude = _ NUM * velocity ; timestamp =  System . current Time Millis ( ) ; double length =  Math . sqrt ( last Dx * last Dx + last Dy * last Dy ) ; last Dx /= length ; last Dy /= length ; } else { amplitude = _ NUM ; update Look At ( ) ; } }
@  Override public  Multivariate Table to Discrete ( ) { if ( discrete Cache == null ) {  Multivariate Table .  Builder probs = new  Multivariate Table .  Builder ( ) ; double incr = _ NUM / samples . size ( ) ; for (  Assignment sample : samples ) {  Assignment trimmed = sample . get Trimmed ( variables ) ; probs . increment Row ( trimmed , incr ) ; } discrete Cache = probs . build ( ) ; } return discrete Cache ; }
@  Suppress Warnings ( _ STR ) public static  Collection <  X509 Certificate > read Certificates (  String base64data ) throws  Exception { try (  Input Stream is = new  Byte Array Input Stream ( decode Base64 ( base64data ) ) ) { return (  Collection <  X509 Certificate > )  CERT_ FACTORY . generate Certificates ( is ) ; } }
public synchronized void init ( ) { if ( _stats On ) { return ; } _stats On = _ BOOL ; executor =  Executors . new Single Thread Scheduled Executor ( new  Customizable Thread Factory (  STAT_ THREAD_ NAME ) ) ; executor . schedule At Fixed Rate ( new  Stat Logger ( ) , _display Rate In Mins , _display Rate In Mins ,  Time Unit .  MINUTES ) ; executor . schedule At Fixed Rate ( new  Per Minute Processing ( ) , _ NUM , _ NUM ,  Time Unit .  SECONDS ) ; executor . schedule At Fixed Rate ( new  Per Hour Processing ( ) , _ NUM , _ NUM ,  Time Unit .  SECONDS ) ; executor . schedule At Fixed Rate ( new  Per Day Processing ( ) , _ NUM , _ NUM ,  Time Unit .  SECONDS ) ; }
default  B with (  String key ,  Object value ) { return with ( key , value != null ? value . to String ( ) : null ) ; }
private void generate Chunks For Table (  Table table , long table Chunk Size ,  String [ ] columns ) throws  Replicator Exception ,  Interrupted Exception { long chunk Size ;  Integer pk Type = get PKType ( table ) ; if ( table Chunk Size == _ NUM ) { chunks . put ( new  No Chunk ( table , columns ) ) ; return ; } else if ( table Chunk Size < _ NUM ) { chunk Size = this . chunk Size ; } else { chunk Size = table Chunk Size ; } if ( logger . is Debug Enabled ( ) ) logger . debug ( _ STR + table . get Schema ( ) + _ STR + table . get Name ( ) ) ; if ( pk Type == null ) chunk Limit ( table ) ; else if ( pk Type ==  Types .  NUMERIC ) chunk Numeric PK ( table , columns , chunk Size ) ; else if ( pk Type ==  Types .  VARCHAR ) chunk Varchar PK ( table ) ; }
public static  String last (  String list , char delimiter ) { int len = list . length ( ) ; if ( len == _ NUM ) return _ STR ; int index = _ NUM ; while ( _ BOOL ) { index = list . last Index Of ( delimiter ) ; if ( index == - _ NUM ) { return list ; } else if ( index + _ NUM == len ) { list = list . substring ( _ NUM , len - _ NUM ) ; len -- ; } else { return list . substring ( index + _ NUM ) ; } } }
public void add Layout (  Loading Layout layout ) { if ( null != layout ) { m Loading Layouts . add ( layout ) ; } }
private void determine Global Extremum Type ( ) { final double f = function ( alpha Extremum ) ; double [ ] alpha_1 = new double [ alpha Extremum . length ] ; double [ ] alpha_2 = new double [ alpha Extremum . length ] ; for ( int i = _ NUM ; i < alpha Extremum . length ; i ++ ) { alpha_1 [ i ] =  Math . random ( ) *  Math .  PI ; alpha_2 [ i ] =  Math . random ( ) *  Math .  PI ; } double f1 = function ( alpha_1 ) ; double f2 = function ( alpha_2 ) ; if ( f1 < f && f2 < f ) { extremum Type =  Extremum Type .  MAXIMUM ; } else if ( f1 > f && f2 > f ) { extremum Type =  Extremum Type .  MINIMUM ; } else if (  Math . abs ( f1 - f ) <  DELTA &&  Math . abs ( f2 - f ) <  DELTA ) { extremum Type =  Extremum Type .  CONSTANT ; } else { throw new  Illegal State Exception ( _ STR + _ STR + this + _ STR +  Format Util . format ( alpha Extremum ) + _ STR + f + _ STR + f1 + _ STR + f2 ) ; } }
public static  Method find Instance Method (  Class < ? > type ,  String name ,  Class < ? > ... args ) throws  No Such Method Exception {  Method method = find Method ( type , name , args ) ; if (  Modifier . is Static ( method . get Modifiers ( ) ) ) { throw new  No Such Method Exception ( _ STR + name + _ STR ) ; } return method ; }
private void fetch Search Service Cards From Server (  String keyword ) { final  Map <  String ,  String > params = new  Hash Map <  String ,  String > ( _ NUM ) ; params . put (  Http Constants .  LATITUDE ,  Shared Preference Helper . get String (  R . string . pref_latitude ) ) ; params . put (  Http Constants .  LONGITUDE ,  Shared Preference Helper . get String (  R . string . pref_longitude ) ) ; params . put (  Http Constants .  TYPE ,  Http Constants .  Search Type .  SERVICE_ CARD ) ; params . put (  Http Constants .  PER , _ STR ) ; params . put (  Http Constants .  RADIUS , _ STR ) ; params . put (  Http Constants .  TITLE , keyword ) ;  Retro Callback retro Callback ; retro Callback = new  Retro Callback ( this ) ; retro Callback . set Request Id (  Http Constants .  Api Response Codes .  SEARCH_ SERVICES ) ; retro Callback List . add ( retro Callback ) ; params . put (  Http Constants .  PAGE , _ STR ) ; m Yelo Api . get Service Cards ( params , retro Callback ) ; m Swipe Refresh Layout . set Refreshing ( _ BOOL ) ; }
public void add Phone Number (  Phone Type type ,  String number ,  String description ) { final  Ngn Phone Number phone Number = new  Ngn Phone Number ( type , number , description ) ; if ( type ==  Phone Type .  MOBILE ) { m Phone Numbers . add ( _ NUM , phone Number ) ; } else { m Phone Numbers . add ( phone Number ) ; } }
public static final  String digits And Plus Only (  Matcher Compat matcher ) {  String Builder buffer = new  String Builder ( ) ;  String matching Region = matcher . group ( ) ; for ( int i = _ NUM , size = matching Region . length ( ) ; i < size ; i ++ ) { char character = matching Region . char At ( i ) ; if ( character == _ STR ||  Character . is Digit ( character ) ) { buffer . append ( character ) ; } } return buffer . to String ( ) ; }
public static boolean equal ( double [ ] [ ] a , double [ ] [ ] b ) { if ( a == null ) { return ( b == null ) ; } if ( b == null ) { return _ BOOL ; } if ( a . length != b . length ) { return _ BOOL ; } for ( int i = _ NUM ; i < a . length ; i ++ ) { if ( !  Arrays . equals ( a [ i ] , b [ i ] ) ) { return _ BOOL ; } } return _ BOOL ; }
private  List clone Sequence ( ) { if ( marker Sequence == null ) { return null ; }  List retval = new  Array List ( marker Sequence . size ( ) ) ;  Iterator iter = marker Sequence . iterator ( ) ; while ( iter . has Next ( ) ) {  Marker Segment seg = (  Marker Segment ) iter . next ( ) ; retval . add ( seg . clone ( ) ) ; } return retval ; }
@  Suppress Warnings ( _ STR ) public static void main (  String [ ] args ) {  Options options = handle Options (  Options . class , args ) ;  Wikibase Uris uris = new  Wikibase Uris ( options . wikibase Host ( ) ) ;  Munger munger = munger From Options ( options ) ; int port = parse Port ( options . to ( ) ) ;  Output Picker <  Writer > to ;  Httpd httpd = null ; try { if ( options . chunk Size ( ) > _ NUM ) { if ( port > _ NUM ) {  Blocking Queue <  Input Stream > queue = new  Array Blocking Queue < > ( _ NUM ) ; httpd = new  Httpd ( port , queue ) ; to = new  Chunked Piped Writer Output Picker ( queue , options . chunk Size ( ) ) ; } else { to = new  Chunked File Writer Output Picker ( options . to ( ) , options . chunk Size ( ) ) ; } } else { if ( port > _ NUM ) {  Piped Input Stream to Http = new  Piped Input Stream ( ) ;  Writer writer = utf8 ( new  Piped Output Stream ( to Http ) ) ;  Blocking Queue <  Input Stream > queue = new  Array Blocking Queue < > ( _ NUM ) ; queue . put ( to Http ) ; httpd = new  Httpd ( port , queue ) ; to = new  Always Output Picker < > ( writer ) ; } else { to = new  Always Output Picker < > (  Cli Utils . writer ( options . to ( ) ) ) ; } } if ( httpd != null ) { log . info ( _ STR , port ) ; log . info ( _ STR ) ; httpd . start ( ) ; } } catch (  IOException e ) { log . error ( _ STR , e ) ;  System . exit ( _ NUM ) ; return ; } catch (  Interrupted Exception e ) { log . error ( _ STR , e ) ;  System . exit ( _ NUM ) ; return ; } try {  Munge munge = new  Munge ( uris , munger , open Input ( options . from ( ) ) , to ) ; munge . run ( ) ; } catch (  Runtime Exception e ) { log . error ( _ STR , e ) ;  System . exit ( _ NUM ) ; } wait For Httpd To Shut Down If Needed ( httpd ) ; }
public  Publisher Concat Array <  T > concat Additional Source Last (  Publisher < ? extends  T > source ) { int n = array . length ; @  Suppress Warnings ( _ STR )  Publisher < ? extends  T > [ ] new Array = new  Publisher [ n + _ NUM ] ;  System . arraycopy ( array , _ NUM , new Array , _ NUM , n ) ; new Array [ n ] = source ; return new  Publisher Concat Array < > ( delay Error , new Array ) ; }
Binary Class load File (  Class File file ) throws  IOException { long tm =  System . current Time Millis ( ) ;  Input Stream input = file . get Input Stream ( ) ;  Binary Class c = null ; if ( tracing ) dt Enter ( _ STR + file ) ; try {  Data Input Stream is = new  Data Input Stream ( new  Buffered Input Stream ( input ) ) ; c =  Binary Class . load ( new  Environment ( this , file ) , is , load File Flags ( ) ) ; } catch (  Class Format Error e ) { error ( _ NUM , _ STR , file . get Path ( ) , e . get Message ( ) ) ; if ( tracing ) dt Exit ( _ STR + file ) ; return null ; } catch ( java . io .  EOFException e ) { error ( _ NUM , _ STR , file . get Path ( ) ) ; return null ; } input . close ( ) ; if ( verbose ( ) ) { tm =  System . current Time Millis ( ) - tm ; output (  Main . get Text ( _ STR , file . get Path ( ) ,  Long . to String ( tm ) ) ) ; } if ( tracing ) dt Exit ( _ STR + file ) ; return c ; }
@  Override public boolean e Is Set ( int feature ID ) { switch ( feature ID ) { case  Mapping Package .  STEREO_ TYPE_ TARGET__ NAME : return  NAME_ EDEFAULT == null ? name != null : !  NAME_ EDEFAULT . equals ( name ) ; case  Mapping Package .  STEREO_ TYPE_ TARGET__ ATTRIBUTES : return attributes != null && ! attributes . is Empty ( ) ; } return super . e Is Set ( feature ID ) ; }
public static  String decode ( final  String escaped , final  String charset ) throws  URIException { return  Coder . decode ( escaped . to Char Array ( ) , charset ) ; }
public  Policy Constraints Extension (  Boolean critical ,  Object value ) throws  IOException { this . extension Id =  PKIXExtensions .  Policy Constraints_ Id ; this . critical = critical . boolean Value ( ) ; this . extension Value = ( byte [ ] ) value ;  Der Value val = new  Der Value ( this . extension Value ) ; if ( val . tag !=  Der Value . tag_ Sequence ) { throw new  IOException ( _ STR ) ; }  Der Input Stream in = val . data ; while ( in != null && in . available ( ) != _ NUM ) {  Der Value next = in . get Der Value ( ) ; if ( next . is Context Specific (  TAG_ REQUIRE ) && ! next . is Constructed ( ) ) { if ( this . require != - _ NUM ) throw new  IOException ( _ STR + _ STR ) ; next . reset Tag (  Der Value . tag_ Integer ) ; this . require = next . get Integer ( ) ; } else if ( next . is Context Specific (  TAG_ INHIBIT ) && ! next . is Constructed ( ) ) { if ( this . inhibit != - _ NUM ) throw new  IOException ( _ STR + _ STR ) ; next . reset Tag (  Der Value . tag_ Integer ) ; this . inhibit = next . get Integer ( ) ; } else throw new  IOException ( _ STR ) ; } }
public static  Secret Key generate Key (  String algorithm ) throws  Encoding Exception { try {  Key Generator kgen =  Key Generator . get Instance ( algorithm ) ; kgen . init ( _ NUM ) ;  Secret Key key = kgen . generate Key ( ) ; return key ; } catch (  Exception e ) { throw new  Encoding Exception ( e ) ; } }
public void load (  Http Servlet Request request ) {  Cookie [ ] cookies = request . get Cookies ( ) ; if ( cookies != null && cookies . length > _ NUM ) { for (  Cookie cookie : cookies ) {  String name = cookie . get Name ( ) ;  String value = cookie . get Value ( ) ; if ( name . starts With ( _ STR ) ) { if (  IS_ QUICK_ SALES . equals Ignore Case ( name ) ) { try { is Quick Sales =  Boolean . parse Boolean ( value ) ; } catch (  Exception e ) { log . log (  Level .  WARNING , _ STR +  IS_ QUICK_ SALES + _ STR + is Quick Sales , e ) ; } } if (  IS_ CUSTOMER_ COMPULSORY . equals Ignore Case ( name ) ) { try { is Customer Compulsory =  Boolean . parse Boolean ( value ) ; } catch (  Exception e ) { log . log (  Level .  WARNING , _ STR +  IS_ CUSTOMER_ COMPULSORY + _ STR + is Customer Compulsory , e ) ; } } if (  ALLOW_ CREDIT_ SALES . equals Ignore Case ( name ) ) { try { allow Credit Sales =  Boolean . parse Boolean ( value ) ; } catch (  Exception e ) { log . log (  Level .  WARNING , _ STR +  ALLOW_ CREDIT_ SALES + _ STR + allow Credit Sales , e ) ; } } if (  ALLOW_ CUSTOMER_ RETURN_ ORDER . equals Ignore Case ( name ) ) { try { allow Customer Return Order =  Boolean . parse Boolean ( value ) ; } catch (  Exception e ) { log . log (  Level .  WARNING , _ STR +  ALLOW_ CUSTOMER_ RETURN_ ORDER + _ STR + allow Customer Return Order , e ) ; } } if (  ALLOW_ INVOKE_ CUSTOMER_ RETURN_ ORDER . equals Ignore Case ( name ) ) { try { allow Invoke Customer Return Order =  Boolean . parse Boolean ( value ) ; } catch (  Exception e ) { log . log (  Level .  WARNING , _ STR +  ALLOW_ INVOKE_ CUSTOMER_ RETURN_ ORDER + _ STR + allow Invoke Customer Return Order , e ) ; } } if (  PAYMENT_ RULE . equals Ignore Case ( name ) ) { if ( value . equals Ignore Case (  Constants .  PAYMENT_ RULE_ CASH ) || value . equals Ignore Case (  Constants .  PAYMENT_ RULE_ CARD ) || value . equals Ignore Case (  Constants .  PAYMENT_ RULE_ CHEQUE ) || value . equals Ignore Case (  Constants .  PAYMENT_ RULE_ MIXED ) ) { payment Rule = value ; } else { log . log (  Level .  WARNING , _ STR +  PAYMENT_ RULE + _ STR + payment Rule ) ; } } if (  SEARCH_ PRODUCT_ BY . equals Ignore Case ( name ) ) { if ( value . equals Ignore Case ( _ STR ) || value . equals Ignore Case ( _ STR ) || value . equals Ignore Case ( _ STR ) ) { search Product By = value ; } else { log . log (  Level .  WARNING , _ STR +  SEARCH_ PRODUCT_ BY + _ STR + search Product By ) ; } } } } } }
public  Spy Versions load Versions ( ) throws  XMLException { set Loading ( _ BOOL ) ; try { final  URL url = new  URL ( property Loader . get Property (  Base Property Names .  VERSION_ INFO_ URL ) ) ; versions = (  Spy Versions ) load From Input Stream ( url . open Stream ( ) ) ; } catch (  IOException |  Null Pointer Exception e ) { throw new  XMLException ( _ STR + property Loader . get Property (  Base Property Names .  VERSION_ INFO_ URL ) , e ) ; } set Loading ( _ BOOL ) ; return versions ; }
@  Request Mapping ( value = _ STR , method =  POST , produces =  APPLICATION_ JSON_ VALUE ) public  Response Entity <  Page Response <  Role DTO > > find All ( @  Request Body  Page Request By Example <  Role DTO > prbe ) throws  URISyntax Exception {  Page Response <  Role DTO > page Response = role DTOService . find All ( prbe ) ; return new  Response Entity < > ( page Response , new  Http Headers ( ) ,  Http Status .  OK ) ; }
public void add Footer View (  View view ) { m Footer Views . add ( view ) ; }
public static boolean check Connection (  Connection conn ) {  String sql = _ STR ;  Statement stmt = null ;  Result Set rs = null ; try { stmt = conn . create Statement ( ) ; stmt . set Query Timeout ( _ NUM ) ; rs = stmt . execute Query ( sql ) ; if ( rs != null && rs . next ( ) ) return _ BOOL ; return _ BOOL ; } catch (  Exception ex ) { } finally { close ( rs ) ; close ( stmt ) ; } return _ BOOL ; }
public void test Recovered Handled Dropped Offer ( ) {  Atomic Integer calls = new  Atomic Integer ( ) ;  Submission Publisher <  Integer > p = new  Submission Publisher <  Integer > ( basic Executor , _ NUM ) ;  Test Subscriber s1 = new  Test Subscriber ( ) ; s1 . request = _ BOOL ;  Test Subscriber s2 = new  Test Subscriber ( ) ; s2 . request = _ BOOL ; p . subscribe ( s1 ) ; p . subscribe ( s2 ) ; s2 . await Subscribe ( ) ; s1 . await Subscribe ( ) ; int n = _ NUM ; for ( int i = _ NUM ; i <= _ NUM ; ++ i ) { int d = p . offer ( i , null ) ; n = n + _ NUM + ( d < _ NUM ? d : _ NUM ) ; } p . close ( ) ; s2 . await Complete ( ) ; s1 . await Complete ( ) ; assert Equals ( n , s1 . nexts + s2 . nexts ) ; assert True ( calls . get ( ) >= _ NUM ) ; }
void declare (  String name ,  Type type ) { if ( reserved Words . contains ( name ) ) throw new  Runtime Exception ( name + _ STR ) ; if ( table . contains Key ( name ) ) throw new  Runtime Exception ( _ STR + name + _ STR ) ;  Symbol symbol = new  Symbol ( this , name , type ) ; table . put ( name , symbol ) ; stack Map . add ( new  Declaration ( symbol ) ) ; }
private void exit Process ( boolean ok ,  String message ) { logger . info ( message ) ; try {  File replicator Home =  Replicator Runtime Conf . locate Replicator Home Dir ( ) ;  File var Dir = new  File ( replicator Home , _ STR ) ;  File pid File = new  File ( var Dir , _ STR ) ; if ( pid File . exists ( ) ) { logger . info ( _ STR ) ; pid File . delete ( ) ; } } catch (  Throwable t ) { logger . warn ( _ STR , t ) ; } logger . info ( _ STR ) ; if ( ok )  System . exit ( _ NUM ) ; else  System . exit ( _ NUM ) ; }
private int test In Range ( long actual , long expected , long epsilon ) { long min = expected - epsilon ; long max = expected + epsilon ; return actual < min ? - _ NUM : actual > max ? _ NUM : _ NUM ; }
public  Spider Html Parser (  Spider Param params ) { super ( ) ; if ( params == null ) { throw new  Illegal Argument Exception ( _ STR ) ; } this . params = params ; }
public void print ( boolean x ) { out . print ( x ) ; out . flush ( ) ; }
public  Iterable find All (  Iterable ids ) { final  List entities = new  Linked List ( ) ; log . info ( _ STR ) ; log . debug ( ids ) ; for (  Object id : ids ) { final  Object found = find One ( (  Serializable ) id ) ; if ( found != null ) { log . trace ( _ STR + id + _ STR ) ; entities . add ( found ) ; } } return entities ; }
protected boolean [ ] dataset Integrity ( boolean nominal Predictor , boolean numeric Predictor , boolean string Predictor , boolean date Predictor , boolean relational Predictor , boolean multi Instance , int class Type , boolean predictor Missing , boolean class Missing ) { print ( _ STR ) ; print Attribute Summary ( nominal Predictor , numeric Predictor , string Predictor , date Predictor , relational Predictor , multi Instance , class Type ) ; print ( _ STR ) ; int num Train = get Num Instances ( ) , num Test = get Num Instances ( ) , num Classes = _ NUM , missing Level = _ NUM ; boolean [ ] result = new boolean [ _ NUM ] ;  Instances train = null ;  Instances test = null ;  Classifier classifier = null ;  Evaluation evaluation = null ; boolean built = _ BOOL ; try { train = make Test Dataset ( _ NUM , num Train , nominal Predictor ? get Num Nominal ( ) : _ NUM , numeric Predictor ? get Num Numeric ( ) : _ NUM , string Predictor ? get Num String ( ) : _ NUM , date Predictor ? get Num Date ( ) : _ NUM , relational Predictor ? get Num Relational ( ) : _ NUM , num Classes , class Type , multi Instance ) ; test = make Test Dataset ( _ NUM , num Test , nominal Predictor ? get Num Nominal ( ) : _ NUM , numeric Predictor ? get Num Numeric ( ) : _ NUM , string Predictor ? get Num String ( ) : _ NUM , date Predictor ? get Num Date ( ) : _ NUM , relational Predictor ? get Num Relational ( ) : _ NUM , num Classes , class Type , multi Instance ) ; if ( missing Level > _ NUM ) { add Missing ( train , missing Level , predictor Missing , class Missing ) ; add Missing ( test ,  Math . min ( missing Level , _ NUM ) , predictor Missing , class Missing ) ; } classifier =  Abstract Classifier . make Copies ( get Classifier ( ) , _ NUM ) [ _ NUM ] ; evaluation = new  Evaluation ( train ) ; } catch (  Exception ex ) { throw new  Error ( _ STR + ex . get Message ( ) ) ; } try {  Instances train Copy = new  Instances ( train ) ;  Instances test Copy = new  Instances ( test ) ; classifier . build Classifier ( train Copy ) ; compare Datasets ( train , train Copy ) ; built = _ BOOL ; test WRTZero R ( classifier , evaluation , train Copy , test Copy ) ; compare Datasets ( test , test Copy ) ; println ( _ STR ) ; result [ _ NUM ] = _ BOOL ; } catch (  Exception ex ) { println ( _ STR ) ; result [ _ NUM ] = _ BOOL ; if ( m_ Debug ) { println ( _ STR ) ; print ( _ STR ) ; if ( built ) { print ( _ STR ) ; } else { print ( _ STR ) ; } println ( _ STR + ex . get Message ( ) + _ STR ) ; println ( _ STR ) ; println ( _ STR + train . to String ( ) + _ STR ) ; println ( _ STR + test . to String ( ) + _ STR ) ; } } return result ; }
public  Accessibility Event dequeue ( ) { if ( m Event Queue . is Empty ( ) ) { return null ; } final  Accessibility Event event = m Event Queue . remove ( _ NUM ) ; if ( event != null &&  Accessibility Event Utils . event Matches Any Type ( event ,  MASK_ LIMITED_ EVENT_ TYPES ) ) { final int event Type = event . get Event Type ( ) ; final int event Count Of Type = m Qualifying Events . get ( event Type , _ NUM ) ; m Qualifying Events . put ( event Type , ( event Count Of Type - _ NUM ) ) ; } return event ; }
public static void print Stack ( ) { print Stack ( _ BOOL , _ BOOL ) ; }
private void debug Segment Entries (  Write Stream out ,  Read Stream is ,  Segment Extent extent ,  Table Entry table ) throws  IOException {  Temp Buffer t Buf =  Temp Buffer . create ( ) ; byte [ ] buffer = t Buf . buffer ( ) ; for ( long ptr = extent . length ( ) -  BLOCK_ SIZE ; ptr > _ NUM ; ptr -=  BLOCK_ SIZE ) { is . position ( ptr ) ; is . read All ( buffer , _ NUM ,  BLOCK_ SIZE ) ; long seq =  Bits Util . read Long ( buffer , _ NUM ) ; int head = _ NUM ; byte [ ] table Key = new byte [ _ NUM ] ;  System . arraycopy ( buffer , head , table Key , _ NUM , table Key . length ) ; is . read All ( table Key , _ NUM , table Key . length ) ; head += table Key . length ; int offset =  BLOCK_ SIZE - _ NUM ; int tail =  Bits Util . read Int16 ( buffer , offset ) ; offset += _ NUM ; boolean is Cont = buffer [ offset ] == _ NUM ; if ( seq <= _ NUM || tail <= _ NUM ) { return ; } while ( ( head = debug Segment Index ( out , is , buffer , extent . address ( ) , ptr , head , table ) ) < tail ) { } if ( ! is Cont ) { break ; } } }
private void process Initiators (  List <  String > initiator Names ,  Map <  URI ,  Set <  URI > > host To Initiator Map ) { for (  String initiator WWNStr : initiator Names ) {  Initiator initiator = fetch Initiator By Name ( initiator WWNStr ) ; if ( null != initiator ) {  Set <  URI > initiators = host To Initiator Map . get ( initiator . get Host ( ) ) ; if ( initiators == null ) { initiators = new  Hash Set <  URI > ( ) ; host To Initiator Map . put ( initiator . get Host ( ) , initiators ) ; } initiators . add ( initiator . get Id ( ) ) ; } } }
protected void process Converts (  List <  Convert Metadata > converts ,  Database Mapping mapping ,  Metadata Class reference Class , boolean is For Map Key ) { if ( converts != null ) { for (  Convert Metadata convert : converts ) { convert . process ( mapping , reference Class , get Class Accessor ( ) , is For Map Key ) ; } } }
public void push (  Namespace namespace ) { namespace Stack . add ( namespace ) ; namespace Cache List . add ( null ) ; current Namespace Cache = null ;  String prefix = namespace . get Prefix ( ) ; if ( ( prefix == null ) || ( prefix . length ( ) == _ NUM ) ) { default Namespace = namespace ; } }
public static boolean contains (  Data Flavor [ ] array ,  Data Flavor flavor ) { for ( int i = _ NUM ; i < array . length ; i ++ ) { if ( flavor . equals ( array [ i ] ) ) { return _ BOOL ; } } return _ BOOL ; }
public void test Choice Missing Icon Error Handling ( ) {  String xml = _ STR ; xml += create Start Mission Xml ( _ STR , _ STR ) ; xml += create Start Choice Moment Xml ( _ STR , _ NUM , _ STR , _ STR ) ; xml += create Choice Xml ( _ STR , _ STR , _ STR , _ BOOL , _ BOOL , _ STR ) ; xml += create Choice Xml ( _ STR , _ STR , _ STR , _ BOOL , _ BOOL , null ) ; xml += create End Choice Moment Xml ( ) ; xml += create End Mission Xml ( ) ;  Utils . log Debug (  TAG , xml ) ;  Input Stream moment Input Stream = new  Byte Array Input Stream ( xml . get Bytes ( ) ) ; m Mission = new  Mission ( m Mission Data ) ; boolean did Mission Parse Fail = _ BOOL ; try { m Mission . read Moments ( moment Input Stream ) ; } catch (  Mission Parse Exception e ) { e . print Stack Trace ( ) ; did Mission Parse Fail = _ BOOL ; }  Assert . assert Equals ( _ BOOL , did Mission Parse Fail ) ; }
String decompile ( int indent , int flags ) {  String Buffer sb = new  String Buffer ( ) ; boolean justbody = ( _ NUM != ( flags &  Decompiler .  ONLY_ BODY_ FLAG ) ) ; if ( ! justbody ) { sb . append ( _ STR ) ; sb . append ( get Function Name ( ) ) ; sb . append ( _ STR ) ; } sb . append ( _ STR ) ; sb . append ( get Arity ( ) ) ; sb . append ( _ STR ) ; if ( ! justbody ) { sb . append ( _ STR ) ; } return sb . to String ( ) ; }
public static int next Message ID ( ) { int next ID = next Message ID . get And Increment ( ) ; if ( next ID ==  Integer .  MAX_ VALUE ) { next Message ID . set ( _ NUM ) ; } return next ID ; }
private void fill Field Values ( ) { if ( is Creation Panel ) { phrase . set Text ( _ STR +  Speech .  DEFAULT_ PHRASE ) ; threshold . set Text ( _ STR +  Speech .  DEFAULT_ THRESHOLD ) ; } else { phrase . set Text ( _ STR + speech Effector . get Phrase ( ) ) ; threshold . set Text ( _ STR + speech Effector . get Threshold ( ) ) ; } }
public static  String decode Endpoint Operation (  String endpoint , boolean stripped ) { int ind = endpoint . index Of ( _ STR ) ; if ( ind != - _ NUM ) { if ( stripped ) { return endpoint . substring ( ind + _ NUM , endpoint . length ( ) - _ NUM ) ; } return endpoint . substring ( ind ) ; } return null ; }
public boolean retain All (  Abstract Long List other ) { if ( other . size ( ) == _ NUM ) { if ( size == _ NUM ) return _ BOOL ; set Size ( _ NUM ) ; return _ BOOL ; } int limit = other . size ( ) - _ NUM ; int j = _ NUM ; for ( int i = _ NUM ; i < size ; i ++ ) { if ( other . index Of From To ( get Quick ( i ) , _ NUM , limit ) >= _ NUM ) set Quick ( j ++ , get Quick ( i ) ) ; } boolean modified = ( j != size ) ; set Size ( j ) ; return modified ; }
private static  List <  Row > make Table Data (  String table Id , int num Rows ) { service . create Table ( table Id ) ;  Map <  Byte String ,  Byte String > test Data = service . get Table ( table Id ) ;  List <  Row > test Rows = new  Array List < > ( num Rows ) ; for ( int i = _ NUM ; i < num Rows ; ++ i ) {  Byte String key =  Byte String . copy From Utf8 (  String . format ( _ STR , i ) ) ;  Byte String value =  Byte String . copy From Utf8 (  String . format ( _ STR , i ) ) ; test Data . put ( key , value ) ; test Rows . add ( make Row ( key , value ) ) ; } return test Rows ; }
void add Index (  Index index ) { indexes . add ( index ) ; }
public  Builder with Key Store Path (  String key Store Path ) { properties . set Property (  Netty Options .  SSL_ KEY_ STORE_ PATH ,  Assert . not Null ( key Store Path , _ STR ) ) ; return this ; }
public  Distributed Data Manager Impl (  Zk Connection conn ,  String base Path , long max Nodes ) { _zk Client = conn . curator ( ) ; if (  String Utils . is Empty ( base Path ) || ! base Path . starts With ( _ STR ) || ( base Path . length ( ) < _ NUM ) || base Path . ends With ( _ STR ) ) { throw new  Illegal Argument Exception ( _ STR ) ; } _base Path = base Path ; _max Nodes = max Nodes ; _log . info ( _ STR , _base Path , _max Nodes ) ; ensure Cache Started ( ) ; }
public static boolean is Binary Instruction ( final  String mnemonic ) { return mnemonic . equals (  Reil Helpers .  OPCODE_ ADD ) || mnemonic . equals (  Reil Helpers .  OPCODE_ SUB ) || mnemonic . equals (  Reil Helpers .  OPCODE_ MUL ) || mnemonic . equals (  Reil Helpers .  OPCODE_ DIV ) || mnemonic . equals (  Reil Helpers .  OPCODE_ BSH ) || mnemonic . equals (  Reil Helpers .  OPCODE_ AND ) || mnemonic . equals (  Reil Helpers .  OPCODE_ OR ) || mnemonic . equals (  Reil Helpers .  OPCODE_ XOR ) ; }
public void clean Result ( ) { cons G . clear ( ) ; pointers . clear ( ) ; allocations . clear ( ) ; constraints . clear ( ) ; func2int . clear ( ) ; int2func . clear ( ) ; edge Mapping . clear ( ) ; has Transformed = _ BOOL ; has Executed = _ BOOL ;  System . gc ( ) ;  System . gc ( ) ;  System . gc ( ) ;  System . gc ( ) ; }
private  Node delete (  Node x ,  Key key ) { int cmp = key . compare To ( x . key ) ; if ( cmp < _ NUM ) { x . left = delete ( x . left , key ) ; } else if ( cmp > _ NUM ) { x . right = delete ( x . right , key ) ; } else { if ( x . left == null ) { return x . right ; } else if ( x . right == null ) { return x . left ; } else {  Node y = x ; x = min ( y . right ) ; x . right = delete Min ( y . right ) ; x . left = y . left ; } } x . size = _ NUM + size ( x . left ) + size ( x . right ) ; x . height = _ NUM +  Math . max ( height ( x . left ) , height ( x . right ) ) ; return balance ( x ) ; }
public static void statistics ( ) {  String Buffer line = new  String Buffer ( errors + _ STR ) ; if ( errors != _ NUM ) line . append ( _ STR ) ; line . append ( _ STR + warnings + _ STR ) ; if ( warnings != _ NUM ) line . append ( _ STR ) ; line . append ( _ STR ) ; err ( line . to String ( ) ) ; }
public static void copy (  String source ,  String target ) {  Input Stream in = null ;  Output Stream out = null ; try { in = new  Buffered Input Stream ( new  File Input Stream ( source ) ) ; out = new  Buffered Output Stream ( new  File Output Stream ( target ) ) ; for ( int c = read ( in ) ; c != - _ NUM ; c = read ( in ) ) { write ( out , c ) ; } } catch (  File Not Found Exception e ) { throw new  Runtime Exception ( e . get Message ( ) , e ) ; } finally { close ( in ) ; close ( out ) ; } close ( in ) ; close ( out ) ; }
public boolean check Valid Dest (  Layout Block current Block ,  Layout Block next Block ,  Layout Block dest Block ,  Layout Block dest Blockn1 , int path Method ) throws jmri .  Jmri Exception {  List <  Layout Block > dest List = new  Array List <  Layout Block > ( ) ; if ( dest Blockn1 != null ) { dest List . add ( dest Blockn1 ) ; } try { return check Valid Dest ( current Block , next Block , dest Block , dest List , path Method ) ; } catch ( jmri .  Jmri Exception e ) { throw e ; } }
private void stop Timer (  Timer timer ) { if ( timer != null && timer . is Running ( ) ) { timer . stop ( ) ; } }
@  Override public int compare To (  Value o ) { return hash Code ( ) - o . hash Code ( ) ; }
public void bind (  Boolean Binding binding ) { if ( ! is Achieved ( ) ) achieved . bind ( binding ) ; }
public void run ( ) {  JScroll Bar jsb = scroller . get Vertical Scroll Bar ( ) ; while ( running ) { try { synchronized ( hist Data ) { hist Data . wait ( ) ; }  Thread . sleep ( _ NUM ) ; } catch (  Exception e ) { } jsb . set Value ( jsb . get Maximum ( ) ) ; } }
private void connect ( final  String database Url , final  Properties properties ) throws  SQLException { if ( m_connection != null ) { close Connection ( ) ; } try { m_connection =  Driver Manager . get Connection ( database Url , properties ) ; } catch ( final  SQLException exception ) {  Navi Logger . severe ( _ STR , exception ) ; throw exception ; } }
public  Bayes Estimator Editor (  Bayes Estimator Wrapper bayes Est Wrapper ) { this ( bayes Est Wrapper . get Estimated Bayes Im ( ) , bayes Est Wrapper . get Data Set ( ) ) ; }
public void add Timeout Listener (  Action Listener listener ) { comm Timer . add Action Listener ( listener ) ; }
public static boolean is Char At Equal (  String string , int index , char char To Compare ) { if ( ( index < _ NUM ) || ( index >= string . length ( ) ) ) { return _ BOOL ; } return string . char At ( index ) == char To Compare ; }
protected  Granularity generate Granularity ( @  Not Null  String granularity , @  Not Null  Date Time Zone date Time Zone , @  Not Null  Granularity Parser granularity Parser ) throws  Bad Api Request Exception { try { return granularity Parser . parse Granularity ( granularity , date Time Zone ) ; } catch (  Granularity Parse Exception e ) {  LOG . error (  UNKNOWN_ GRANULARITY . log Format ( granularity ) , granularity ) ; throw new  Bad Api Request Exception ( e . get Message ( ) ) ; } }
public  Time Table XYDataset ( ) { this (  Time Zone . get Default ( ) ,  Locale . get Default ( ) ) ; }
public static  Treebank Node select Matching Leaf (  JCas j Cas ,  Annotation annotation ) {  Treebank Node leaf = null ; for (  Treebank Node node :  JCas Util . select Covered ( j Cas ,  Treebank Node . class , annotation ) ) { if ( node . get Leaf ( ) && node . get Begin ( ) == annotation . get Begin ( ) && node . get End ( ) == annotation . get End ( ) ) { if ( leaf == null ) { leaf = node ; } else { throw new  Illegal Argument Exception (  String . format ( _ STR , annotation ,  Arrays . as List ( leaf , node ) ) ) ; } } } return leaf ; }
private void do Pull File (  String remote Path ,  String local Path ,  ISync Progress Monitor monitor ) throws  IOException ,  Sync Exception ,  Timeout Exception { byte [ ] msg ; byte [ ] pull Result = new byte [ _ NUM ] ; final int time Out =  Ddm Preferences . get Time Out ( ) ; try { byte [ ] remote Path Content = remote Path . get Bytes (  Adb Helper .  DEFAULT_ ENCODING ) ; if ( remote Path Content . length >  REMOTE_ PATH_ MAX_ LENGTH ) { throw new  Sync Exception (  Sync Error .  REMOTE_ PATH_ LENGTH ) ; } msg = create File Req (  ID_ RECV , remote Path Content ) ;  Adb Helper . write ( m Channel , msg , - _ NUM , time Out ) ;  Adb Helper . read ( m Channel , pull Result , - _ NUM , time Out ) ; if ( ! check Result ( pull Result ,  ID_ DATA ) && ! check Result ( pull Result ,  ID_ DONE ) ) { throw new  Sync Exception (  Sync Error .  TRANSFER_ PROTOCOL_ ERROR , read Error Message ( pull Result , time Out ) ) ; } } catch (  Unsupported Encoding Exception e ) { throw new  Sync Exception (  Sync Error .  REMOTE_ PATH_ ENCODING , e ) ; }  File f = new  File ( local Path ) ; try (  File Output Stream fos = new  File Output Stream ( f ) ) { byte [ ] data = new byte [  SYNC_ DATA_ MAX ] ; while ( _ BOOL ) { if ( monitor . is Canceled ( ) ) { throw new  Sync Exception (  Sync Error .  CANCELED ) ; } if ( check Result ( pull Result ,  ID_ DONE ) ) { break ; } if ( ! check Result ( pull Result ,  ID_ DATA ) ) { throw new  Sync Exception (  Sync Error .  TRANSFER_ PROTOCOL_ ERROR , read Error Message ( pull Result , time Out ) ) ; } int length =  Array Helper . swap32bit From Array ( pull Result , _ NUM ) ; if ( length >  SYNC_ DATA_ MAX ) { throw new  Sync Exception (  Sync Error .  BUFFER_ OVERRUN ) ; }  Adb Helper . read ( m Channel , data , length , time Out ) ;  Adb Helper . read ( m Channel , pull Result , - _ NUM , time Out ) ; fos . write ( data , _ NUM , length ) ; monitor . advance ( length ) ; } fos . flush ( ) ; } catch (  IOException e ) {  Log . e ( _ STR ,  String . format ( _ STR , f . get Absolute Path ( ) , e . to String ( ) ) ) ; throw new  Sync Exception (  Sync Error .  FILE_ WRITE_ ERROR ) ; } }
public  String process (  Item item ) throws  Process Exception { if ( is Accented ( item ) ) { return _ STR ; } else { return _ STR ; } }
private static  Byte Buffer resample To16 Bit Pcm (  Byte Buffer buffer , int offset , int size , int source Encoding ,  Byte Buffer out ) { int resampled Size ; switch ( source Encoding ) { case  C .  ENCODING_ PCM_8 BIT : resampled Size = size * _ NUM ; break ; case  C .  ENCODING_ PCM_24 BIT : resampled Size = ( size / _ NUM ) * _ NUM ; break ; case  C .  ENCODING_ PCM_32 BIT : resampled Size = size / _ NUM ; break ; default : throw new  Illegal State Exception ( ) ; }  Byte Buffer resampled Buffer = out ; if ( resampled Buffer == null || resampled Buffer . capacity ( ) < resampled Size ) { resampled Buffer =  Byte Buffer . allocate Direct ( resampled Size ) ; } resampled Buffer . position ( _ NUM ) ; resampled Buffer . limit ( resampled Size ) ; int limit = offset + size ; switch ( source Encoding ) { case  C .  ENCODING_ PCM_8 BIT : for ( int i = offset ; i < limit ; i ++ ) { resampled Buffer . put ( ( byte ) _ NUM ) ; resampled Buffer . put ( ( byte ) ( ( buffer . get ( i ) & _ NUM ) - _ NUM ) ) ; } break ; case  C .  ENCODING_ PCM_24 BIT : for ( int i = offset ; i < limit ; i += _ NUM ) { resampled Buffer . put ( buffer . get ( i + _ NUM ) ) ; resampled Buffer . put ( buffer . get ( i + _ NUM ) ) ; } break ; case  C .  ENCODING_ PCM_32 BIT : for ( int i = offset ; i < limit ; i += _ NUM ) { resampled Buffer . put ( buffer . get ( i + _ NUM ) ) ; resampled Buffer . put ( buffer . get ( i + _ NUM ) ) ; } break ; default : throw new  Illegal State Exception ( ) ; } resampled Buffer . position ( _ NUM ) ; return resampled Buffer ; }
public static void delete Contents (  File dir ) throws  IOException {  File [ ] files = dir . list Files ( ) ; if ( files != null ) { for (  File file : files ) { if ( file . is Directory ( ) ) { delete Contents ( file ) ; } file . delete ( ) ; } } }
public void remove Bandwidth (  String name ) { if ( name == null ) { throw new  Null Pointer Exception ( _ STR ) ; } else { int i = _ NUM ; for ( i = _ NUM ; i < bandwidth Fields . size ( ) ; i ++ ) {  Bandwidth Field bandwidth Field = (  Bandwidth Field ) bandwidth Fields . element At ( i ) ;  String type = bandwidth Field . get Bwtype ( ) ; if ( type != null && type . equals ( name ) ) break ; } if ( i < bandwidth Fields . size ( ) ) bandwidth Fields . remove Element At ( i ) ; } }
public static long log (  Logger logger ,  String message ) { long now = _ NUM ; if ( logger . is Trace Enabled ( ) ) { now =  System . current Time Millis ( ) ; logger . trace ( _ STR , now , message ) ; } return now ; }
public static  String Buffer string Substitution (  String arg Str ,  Map vars ) {  String Buffer arg Buf = new  String Buffer ( ) ; for ( int c Idx = _ NUM ; c Idx < arg Str . length ( ) ; ) { char ch = arg Str . char At ( c Idx ) ; switch ( ch ) { case _ STR :  String Buffer name Buf = new  String Buffer ( ) ; for ( ++ c Idx ; c Idx < arg Str . length ( ) ; ++ c Idx ) { ch = arg Str . char At ( c Idx ) ; if ( ch == _ STR ||  Character . is Letter Or Digit ( ch ) ) name Buf . append ( ch ) ; else break ; } if ( name Buf . length ( ) > _ NUM ) {  String value = (  String ) vars . get ( name Buf . to String ( ) ) ; if ( value != null ) { arg Buf . append ( value ) ; } } break ; default : arg Buf . append ( ch ) ; ++ c Idx ; break ; } } return arg Buf ; }
public static void add To Trie (  Trie Node root ,  String str ,  String value ) { int index = _ NUM ; while ( index < str . length ( ) ) { root = root . get Or Create Child ( str . char At ( index ++ ) ) ; } root . set Value ( value ) ; }
@  Override public int number Of Clusters ( ) throws  Exception { if ( m_num_clusters == - _ NUM ) { throw new  Exception ( _ STR ) ; } return m_num_clusters ; }
public static  Map <  String ,  Slice > load All From Map (  Map <  String ,  Object > generic Slices ) { if ( generic Slices == null ) return  Collections . empty Map ( ) ;  Map <  String ,  Slice > result = new  Linked Hash Map < > ( generic Slices . size ( ) ) ; for (  Map .  Entry <  String ,  Object > entry : generic Slices . entry Set ( ) ) {  String name = entry . get Key ( ) ;  Object val = entry . get Value ( ) ; if ( val instanceof  Slice ) { result . put ( name , (  Slice ) val ) ; } else if ( val instanceof  Map ) { result . put ( name , new  Slice ( name , null , (  Map <  String ,  Object > ) val ) ) ; } } return result ; }
public  Inline Menu Row Builder <  T > new Row ( ) { return new  Inline Menu Row Builder < > ( instance ( ) , rows . size ( ) ) ; }
public void init (  String component Name ) throws  Log Exception { access Logger = ( com . sun . identity . log .  Logger )  Logger . get Logger ( component Name + _ STR ) ; error Logger = ( com . sun . identity . log .  Logger )  Logger . get Logger ( component Name + _ STR ) ; try { msg Provider =  Message Provider Factory . get Provider ( component Name ) ; } catch (  IOException e ) { debug . error ( _ STR , e ) ; } }
public void sort (  Comparator <  Fragment Data > comparator ) { check Transaction ( ) ; save Old Order ( ) ; if ( comparator == null ) {  Collections . sort ( m Fragment Datas ) ; } else {  Collections . sort ( this . m Fragment Datas , comparator ) ; } check Position Change ( ) ; }
public  Standard Pie Section Label Generator (  String label Format ,  Locale locale ) { this ( label Format ,  Number Format . get Number Instance ( locale ) ,  Number Format . get Percent Instance ( locale ) ) ; }
public static  Stream Ex <  String > split (  Char Sequence str , char delimiter , boolean trim Empty ) { if ( str . length ( ) == _ NUM ) return of ( _ STR ) ; return of ( new  Char Spliterator ( str , delimiter , trim Empty ) ) ; }
protected  CCCall Func (  Object t ,  String s ,  Class < ? > [ ] p ) { target Callback = t ; selector = s ; partypes = p ; if ( partypes == null ) { try {  Class < ? > cls = target Callback . get Class ( ) ; invocation = cls . get Method ( selector ) ; } catch (  No Such Method Exception e ) { e . print Stack Trace ( ) ; } } else { try {  Class < ? > cls = target Callback . get Class ( ) ; invocation = cls . get Method ( selector , partypes ) ; } catch (  No Such Method Exception e ) { e . print Stack Trace ( ) ; } } }
private static  Map <  String ,  Set <  Integer > > read Config File (  File config File ) throws  IOException {  Map <  String ,  Set <  Integer > > entries = new  Hash Map < > ( ) ; for (  String line :  File Utils . read Lines ( config File ) ) {  String [ ] fields = line . split (  FIELDSEPARATOR_ CONFIGFILE ) ; if ( fields . length < _ NUM ) { throw new  Illegal State Exception (  String . format ( _ STR , config File , line ) ) ; } if ( entries . contains Key ( fields [ _ NUM ] ) ) { throw new  Illegal State Exception (  String . format ( _ STR , config File , fields [ _ NUM ] ) ) ; }  Set <  Integer > topic Counts = new  Hash Set < > ( fields . length - _ NUM ) ; for ( int i = _ NUM ; i < fields . length ; i ++ ) { try { topic Counts . add (  Integer . parse Int ( fields [ i ] ) ) ; } catch (  Number Format Exception e ) { throw new  Illegal State Exception (  String . format ( _ STR , config File , fields [ i ] ) ) ; } } entries . put ( fields [ _ NUM ] , topic Counts ) ; } return entries ; }
private  String compute ( double left ,  String right , boolean is Integer ) { if (  Double . is Na N ( left ) && right == null ) { return null ; } if ( is Integer && left == ( int ) left ) { return ( int ) left + ( right == null ? _ STR : right ) ; } else if (  Double . is Infinite ( left ) ) { return  Tools . format Number ( left ) + ( right == null ? _ STR : right ) ; } else { return (  Double . is Na N ( left ) ? _ STR : left ) + ( right == null ? _ STR : right ) ; } }
public void remove Property Change Listener ( final  String property Name , final  Property Change Listener listener ) { property Change Support . remove Property Change Listener ( property Name , listener ) ; }
public void load XML (  Node stepnode ,  List <  Database Meta > databases ,  Map <  String ,  Counter > counters ) throws  Kettle XMLException { try { this . tabel Name =  XMLHandler . get Tag Value ( stepnode , _ STR ) ; this . output Row Size =  XMLHandler . get Tag Value ( stepnode , _ STR ) ; this . fact Dim Lens String =  XMLHandler . get Tag Value ( stepnode , _ STR ) ; this . cube Name =  XMLHandler . get Tag Value ( stepnode , _ STR ) ; this . schema Name =  XMLHandler . get Tag Value ( stepnode , _ STR ) ; this . dimension Count =  XMLHandler . get Tag Value ( stepnode , _ STR ) ; this . no Dictionary Dims =  XMLHandler . get Tag Value ( stepnode , _ STR ) ; this . no Dictionary Dims Mapping =  XMLHandler . get Tag Value ( stepnode , _ STR ) ; this . complex Dimension Count =  XMLHandler . get Tag Value ( stepnode , _ STR ) ; this . measure Count =  XMLHandler . get Tag Value ( stepnode , _ STR ) ; this . update Member Request =  XMLHandler . get Tag Value ( stepnode , _ STR ) ; this . measure Data Type =  XMLHandler . get Tag Value ( stepnode , _ STR ) ; current Restruct Number =  Integer . parse Int (  XMLHandler . get Tag Value ( stepnode , _ STR ) ) ; this . partition ID =  XMLHandler . get Tag Value ( stepnode , _ STR ) ; this . segment Id =  XMLHandler . get Tag Value ( stepnode , _ STR ) ; this . task No =  XMLHandler . get Tag Value ( stepnode , _ STR ) ; } catch (  Exception e ) { throw new  Kettle XMLException ( _ STR , e ) ; } }
public boolean verify Signature ( byte [ ] message , byte [ ] signature ) { short [ ] sig Int = new short [ signature . length ] ; short tmp ; for ( int i = _ NUM ; i < signature . length ; i ++ ) { tmp = ( short ) signature [ i ] ; tmp &= ( short ) _ NUM ; sig Int [ i ] = tmp ; } short [ ] msg Hash Val = make Message Representative ( message ) ; short [ ] verification Result = verify Signature Intern ( sig Int ) ; boolean verified = _ BOOL ; if ( msg Hash Val . length != verification Result . length ) { return _ BOOL ; } for ( int i = _ NUM ; i < msg Hash Val . length ; i ++ ) { verified = verified && msg Hash Val [ i ] == verification Result [ i ] ; } return verified ; }
public static  Insn List cast ( final  Type from , final  Type to ) {  Insn List list = new  Insn List ( ) ; if ( from != to ) { if ( from ==  Type .  DOUBLE_ TYPE ) { if ( to ==  Type .  FLOAT_ TYPE ) { list . add ( new  Insn Node (  Opcodes .  D2 F ) ) ; } else if ( to ==  Type .  LONG_ TYPE ) { list . add ( new  Insn Node (  Opcodes .  D2 L ) ) ; } else { list . add ( new  Insn Node (  Opcodes .  D2 I ) ) ; list . add ( cast (  Type .  INT_ TYPE , to ) ) ; } } else if ( from ==  Type .  FLOAT_ TYPE ) { if ( to ==  Type .  DOUBLE_ TYPE ) { list . add ( new  Insn Node (  Opcodes .  F2 D ) ) ; } else if ( to ==  Type .  LONG_ TYPE ) { list . add ( new  Insn Node (  Opcodes .  F2 L ) ) ; } else { list . add ( new  Insn Node (  Opcodes .  F2 I ) ) ; list . add ( cast (  Type .  INT_ TYPE , to ) ) ; } } else if ( from ==  Type .  LONG_ TYPE ) { if ( to ==  Type .  DOUBLE_ TYPE ) { list . add ( new  Insn Node (  Opcodes .  L2 D ) ) ; } else if ( to ==  Type .  FLOAT_ TYPE ) { list . add ( new  Insn Node (  Opcodes .  L2 F ) ) ; } else { list . add ( new  Insn Node (  Opcodes .  L2 I ) ) ; list . add ( cast (  Type .  INT_ TYPE , to ) ) ; } } else { if ( to ==  Type .  BYTE_ TYPE ) { list . add ( new  Insn Node (  Opcodes .  I2 B ) ) ; } else if ( to ==  Type .  CHAR_ TYPE ) { list . add ( new  Insn Node (  Opcodes .  I2 C ) ) ; } else if ( to ==  Type .  DOUBLE_ TYPE ) { list . add ( new  Insn Node (  Opcodes .  I2 D ) ) ; } else if ( to ==  Type .  FLOAT_ TYPE ) { list . add ( new  Insn Node (  Opcodes .  I2 F ) ) ; } else if ( to ==  Type .  LONG_ TYPE ) { list . add ( new  Insn Node (  Opcodes .  I2 L ) ) ; } else if ( to ==  Type .  SHORT_ TYPE ) { list . add ( new  Insn Node (  Opcodes .  I2 S ) ) ; } } } return list ; }
public void update Hash For Group ( final  String hash , final  String group Name ) { not Null ( group Name ) ; this . current Hash = hash ; if ( is Changed Hash ( ) ) {  LOG . debug ( _ STR , group Name ) ; groups . clear ( ) ; } }
private  String process Scanned Files ( final  String path , final  String file Name ) throws  Exception { if ( ! is Error ) { if ( scan Mode ==  Scan Mode Constants .  SCAN_ MODE_ FILE ) { if ( ( temp Files != null ) && ! temp Files . is Empty ( ) ) {  File file = (  File ) temp Files . get ( _ NUM ) ;  File new File = new  File ( path , this . prefix ) ; if ( new File . exists ( ) ) { new File . delete ( ) ; } file . rename To ( new File ) ; clear Temp Files ( ) ; return file Name ; } else { return null ; } } else if ( ( scan Mode ==  Scan Mode Constants .  SCAN_ MODE_ NATIVE ) || ( scan Mode ==  Scan Mode Constants .  SCAN_ MODE_ MEMORY ) ) { if ( ( temp Files != null ) && ! temp Files . is Empty ( ) ) {  File new File = new  File ( path , this . prefix ) ; if ( new File . exists ( ) ) { new File . delete ( ) ; }  File Output Stream fos = null ;  Document document = null ; try { fos = new  File Output Stream ( new File ) ; document = new  Document ( ) ;  Pdf Writer . get Instance ( document , fos ) ; document . open ( ) ;  File file Properties = (  File ) temp Files . get ( _ NUM ) ;  Image image Properties =  Image . get Instance ( file Properties . get Path ( ) ) ; document . set Page Size ( image Properties ) ; document . set Margins ( _ NUM , _ NUM , _ NUM , _ NUM ) ;  File file = null ;  Image image = null ;  Iterator it = temp Files . iterator ( ) ; while ( it . has Next ( ) ) { file = (  File ) it . next ( ) ; document . new Page ( ) ; image =  Image . get Instance ( file . get Path ( ) ) ; document . add ( image ) ; } } catch (  Exception e ) { throw e ; } finally { if ( document != null ) { document . close ( ) ; } if ( fos != null ) { fos . close ( ) ; } } clear Temp Files ( ) ; return new File . get Path ( ) ; } else { return null ; } } } else { clear Temp Files ( ) ; } return null ; }
void add (  Undo Log Record entry ) { records . add ( entry ) ; if ( large Transactions ) { memory Undo ++ ; if ( memory Undo > database . get Max Memory Undo ( ) && database . is Persistent ( ) && ! database . is Multi Version ( ) ) { if ( file == null ) {  String file Name = database . create Temp File ( ) ; file = database . open File ( file Name , _ STR , _ BOOL ) ; file . set Checked Writing ( _ BOOL ) ; file . set Length (  File Store .  HEADER_ LENGTH ) ; }  Data buff =  Data . create ( database ,  Constants .  DEFAULT_ PAGE_ SIZE ) ; for ( int i = _ NUM ; i < records . size ( ) ; i ++ ) {  Undo Log Record r = records . get ( i ) ; buff . check Capacity (  Constants .  DEFAULT_ PAGE_ SIZE ) ; r . append ( buff , this ) ; if ( i == records . size ( ) - _ NUM || buff . length ( ) >  Constants .  UNDO_ BLOCK_ SIZE ) { stored Entries Pos . add ( file . get File Pointer ( ) ) ; file . write ( buff . get Bytes ( ) , _ NUM , buff . length ( ) ) ; buff . reset ( ) ; } } stored Entries += records . size ( ) ; memory Undo = _ NUM ; records . clear ( ) ; file . auto Delete ( ) ; return ; } } else { if ( ! entry . is Stored ( ) ) { memory Undo ++ ; } if ( memory Undo > database . get Max Memory Undo ( ) && database . is Persistent ( ) && ! database . is Multi Version ( ) ) { if ( file == null ) {  String file Name = database . create Temp File ( ) ; file = database . open File ( file Name , _ STR , _ BOOL ) ; file . set Checked Writing ( _ BOOL ) ; file . seek (  File Store .  HEADER_ LENGTH ) ; row Buff =  Data . create ( database ,  Constants .  DEFAULT_ PAGE_ SIZE ) ;  Data buff = row Buff ; for ( int i = _ NUM ; i < records . size ( ) ; i ++ ) {  Undo Log Record r = records . get ( i ) ; save If Possible ( r , buff ) ; } } else { save If Possible ( entry , row Buff ) ; } file . auto Delete ( ) ; } } }
public void test Submit Runnable2 ( ) throws  Throwable {  Executor Service e = new  Fork Join Pool ( _ NUM ) ;  Pool Cleaner cleaner = null ; try { cleaner = cleaner ( e ) ;  Future <  String > future = e . submit ( new  No Op Runnable ( ) ,  TEST_ STRING ) ; assert Same (  TEST_ STRING , future . get ( ) ) ; assert True ( future . is Done ( ) ) ; assert False ( future . is Cancelled ( ) ) ; } finally { if ( cleaner != null ) { cleaner . close ( ) ; } } }
public  Rectangle2 D expand (  Rectangle2 D area ,  Rectangle2 D result ) { if ( result == null ) { result = new  Rectangle2 D .  Double ( ) ; } result . set Rect ( area . get X ( ) - this . left , area . get Y ( ) - this . top , area . get Width ( ) + this . left + this . right , area . get Height ( ) + this . top + this . bottom ) ; return result ; }
protected void assert Func Equals ( final  String ... inputs ) throws  Exception {  Solr Query Request req = req ( ) ; try { assert Func Equals ( req , inputs ) ; } finally { req . close ( ) ; } }
protected boolean handle Chunk ( final  E [ ] chunk ) throws  Execution Exception ,  Interrupted Exception ,  IOException { assert chunk != null ; assert chunk . length > _ NUM ; final int chunk Size = chunk . length ; final long begin Nanos =  System . nano Time ( ) ; try { for (  E e : chunk ) { master . add Pending ( e , this , locator ) ; } try { client Task . accept ( chunk ) ; } catch (  Throwable t ) { master . halt ( t ) ; throw new  Runtime Exception ( t ) ; } if ( log . is Debug Enabled ( ) ) log . debug ( stats ) ; return _ BOOL ; } finally { final long elapsed Nanos =  System . nano Time ( ) - begin Nanos ; synchronized ( stats ) { stats . chunks Out . increment And Get ( ) ; stats . elements Out . add And Get ( chunk Size ) ; stats . elapsed Chunk Writing Nanos += elapsed Nanos ; } synchronized ( master . stats ) { master . stats . chunks Out . increment And Get ( ) ; master . stats . elements Out . add And Get ( chunk Size ) ; master . stats . elapsed Sink Chunk Writing Nanos += elapsed Nanos ; } } }
@  Override public void run ( ) { am IActive = _ BOOL ;  String dem Header = null ;  String upslope Area Creek Header = null ;  String output Header = null ; int num Rows ; int num Cols ; double elevation , elevation Neighbour ; int x , y ; double slope , max Slope ; int flow Dir ; int i ;  List <  Stream Flow > stream Flow List = new  Array List < > ( ) ;  List <  Stream Flow > copy Stream Flow List ;  Stream Flow stream Flow2 ;  List <  Double > upstream Values = new  Array List < > ( ) ; float progress = _ NUM ; if ( args . length <= _ NUM ) { show Feedback ( _ STR ) ; return ; } for ( i = _ NUM ; i < args . length ; i ++ ) { if ( i == _ NUM ) { dem Header = args [ i ] ; } else if ( i == _ NUM ) { upslope Area Creek Header = args [ i ] ; } else if ( i == _ NUM ) { output Header = args [ i ] ; } } if ( ( dem Header == null ) || ( upslope Area Creek Header == null ) || ( output Header == null ) ) { show Feedback ( _ STR ) ; return ; } try { dem = new  Whitebox Raster ( dem Header , _ STR ) ; upslope Area Creek = new  Whitebox Raster ( upslope Area Creek Header , _ STR ) ; num Rows = dem . get Number Rows ( ) ; num Cols = dem . get Number Columns ( ) ; grid Res = dem . get Cell Size X ( ) ; median Upstream Area = new  Whitebox Raster ( output Header , _ STR , dem Header ,  Whitebox Raster .  Data Type .  FLOAT , _ NUM ) ; median Upstream Area . set Preferred Palette ( _ STR ) ; median Upstream Area . set Data Scale (  Whitebox Raster Base .  Data Scale .  CONTINUOUS ) ; median Upstream Area . set ZUnits ( _ STR ) ; tmp Direct Upstream Creek Cell Count = new  Whitebox Raster ( output Header . replace ( _ STR , _ STR ) , _ STR , dem Header ,  Whitebox Raster .  Data Type .  FLOAT , _ NUM ) ; tmp Direct Upstream Creek Cell Count . is Temporary File = _ BOOL ; update Progress ( _ STR , _ NUM ) ; for ( int row = _ NUM ; row < num Rows ; row ++ ) { for ( int col = _ NUM ; col < num Cols ; col ++ ) { if ( upslope Area Creek . get Value ( row , col ) == upslope Area Creek . get No Data Value ( ) ) { median Upstream Area . set Value ( row , col , upslope Area Creek . get No Data Value ( ) ) ; } } if ( cancel Op ) { cancel Operation ( ) ; return ; } progress = ( float ) ( _ NUM * row / ( num Rows - _ NUM ) ) ; update Progress ( _ STR , ( int ) progress ) ; } update Progress ( _ STR , _ NUM ) ; for ( int row = _ NUM ; row < num Rows ; row ++ ) { for ( int col = _ NUM ; col < num Cols ; col ++ ) { max Slope =  Double .  MIN_ VALUE ; flow Dir = - _ NUM ; if ( upslope Area Creek . get Value ( row , col ) > _ NUM ) { elevation = dem . get Value ( row , col ) ; for ( int c = _ NUM ; c < _ NUM ; c ++ ) { x = col + xd [ c ] ; y = row + yd [ c ] ; elevation Neighbour = dem . get Value ( y , x ) ; if ( upslope Area Creek . get Value ( y , x ) > _ NUM && elevation Neighbour < elevation ) { slope = ( elevation - elevation Neighbour ) / dd [ c ] ; if ( slope > max Slope ) { max Slope = slope ; flow Dir = c ; } } } for ( int c = _ NUM ; c < _ NUM ; c ++ ) { if ( c == flow Dir ) { x = col + xd [ c ] ; y = row + yd [ c ] ; tmp Direct Upstream Creek Cell Count . increment Value ( y , x , _ NUM ) ; stream Flow List . add ( new  Stream Flow ( col , row , x , y , elevation ) ) ; } } } } if ( cancel Op ) { cancel Operation ( ) ; return ; } progress = ( float ) ( _ NUM * row / ( num Rows - _ NUM ) ) ; update Progress ( _ STR , ( int ) progress ) ; } stream Flow List =  Order Stream Flow List ( stream Flow List ) ; copy Stream Flow List = new  Array List < > ( stream Flow List . sub List ( _ NUM , stream Flow List . size ( ) ) ) ; update Progress ( _ STR , _ NUM ) ; for (  Stream Flow stream Flow : stream Flow List ) { i = stream Flow List . index Of ( stream Flow ) ; if ( median Upstream Area . get Value ( stream Flow .  Get To Y ( ) , stream Flow .  Get To X ( ) ) == _ NUM ) { upstream Values = new  Array List < > ( ) ;  Filter Stream Flow List ( copy Stream Flow List , stream Flow ) ;  Make Upstream List ( copy Stream Flow List , stream Flow .  Get To X ( ) , stream Flow .  Get To Y ( ) , upstream Values ) ;  Collections . sort ( upstream Values ) ; median Upstream Area . set Value ( stream Flow .  Get To Y ( ) , stream Flow .  Get To X ( ) ,  Get Median ( upstream Values ) ) ; stream Flow2 = stream Flow ; while ( ( tmp Direct Upstream Creek Cell Count . get Value ( stream Flow2 .  Get To Y ( ) , stream Flow2 .  Get To X ( ) ) == _ NUM ) & ( upstream Values . size ( ) > _ NUM ) ) { upstream Values . remove ( upslope Area Creek . get Value ( stream Flow2 .  Get To Y ( ) , stream Flow2 .  Get To X ( ) ) ) ; median Upstream Area . set Value ( stream Flow2 .  Get From Y ( ) , stream Flow2 .  Get From X ( ) ,  Get Median ( upstream Values ) ) ; x = stream Flow2 .  Get From X ( ) ; y = stream Flow2 .  Get From Y ( ) ; for (  Stream Flow temp Stream Flow : copy Stream Flow List ) { if ( temp Stream Flow .  Get To X ( ) == x && temp Stream Flow .  Get To Y ( ) == y ) { stream Flow2 = temp Stream Flow ; break ; } } } if ( tmp Direct Upstream Creek Cell Count . get Value ( stream Flow2 .  Get From Y ( ) , stream Flow2 .  Get From X ( ) ) == _ NUM ) { x = stream Flow2 .  Get From X ( ) ; y = stream Flow2 .  Get From Y ( ) ; median Upstream Area . set Value ( y , x , upslope Area Creek . get Value ( y , x ) ) ; } } if ( cancel Op ) { cancel Operation ( ) ; return ; } progress = ( float ) ( _ NUM * ( i + _ NUM ) / stream Flow List . size ( ) ) ; update Progress ( _ STR , ( int ) progress ) ; } median Upstream Area . add Metadata Entry ( _ STR + get Descriptive Name ( ) + _ STR ) ; median Upstream Area . add Metadata Entry ( _ STR + new  Date ( ) ) ; dem . close ( ) ; upslope Area Creek . close ( ) ; median Upstream Area . close ( ) ; tmp Direct Upstream Creek Cell Count . close ( ) ; return Data ( output Header ) ; } catch (  Exception e ) { show Feedback ( e . get Message ( ) ) ; } finally { update Progress ( _ STR , _ NUM ) ; am IActive = _ BOOL ; my Host . plugin Complete ( ) ; } }
protected <  T >  Database make Simple Database (  String filename , int expected Size ) { return make Simple Database ( filename , expected Size , new  List Parameterization ( ) , null ) ; }
public static _ Fields find By Thrift Id ( int field Id ) { switch ( field Id ) { case _ NUM : return  BEGIN_ IN_ BOTH ; case _ NUM : return  OLD_ STRING ; case _ NUM : return  END_ IN_ BOTH ; default : return null ; } }
protected  Size2 D arrange NN (  Block Container container ,  Graphics2 D g2 ) { double max W = _ NUM ; double max H = _ NUM ;  List blocks = container . get Blocks ( ) ;  Iterator iterator = blocks . iterator ( ) ; while ( iterator . has Next ( ) ) {  Block b = (  Block ) iterator . next ( ) ; if ( b != null ) {  Size2 D s = b . arrange ( g2 ,  Rectangle Constraint .  NONE ) ; max W =  Math . max ( max W , s . width ) ; max H =  Math . max ( max H , s . height ) ; } } double width = this . columns * max W ; double height = this . rows * max H ;  Rectangle Constraint c = new  Rectangle Constraint ( width , height ) ; return arrange FF ( container , g2 , c ) ; }
public  Object invoke (  Object proxy ,  Method method ,  Object [ ] args ) throws  Throwable { return invoke ( proxy , new  Standard Method ( method ) , args ) ; }
public int index Of ( java . lang .  String string ) { int start = _ NUM ; int sub Count = string . count ; int _count = count ; if ( sub Count > _ NUM ) { if ( sub Count > _count ) { return - _ NUM ; } char [ ] target = string . value ; int sub Offset = string . offset ; char first Char = target [ sub Offset ] ; int end = sub Offset + sub Count ; while ( _ BOOL ) { int i = index Of ( first Char , start ) ; if ( i == - _ NUM || sub Count + i > _count ) { return - _ NUM ; } int o1 = offset + i , o2 = sub Offset ; char [ ] _value = value ; while ( ++ o2 < end && _value [ ++ o1 ] == target [ o2 ] ) { } if ( o2 == end ) { return i ; } start = i + _ NUM ; } } return start < _count ? start : _count ; }
@  Override public double [ ] [ ] predict Intervals ( double conf ) { update Width ( ) ; double val =  Statistics . normal Inverse ( _ NUM - ( _ NUM - conf ) / _ NUM ) ; double min = m_ TM . first Key ( ) - val * m_ Width ; double max = m_ TM . last Key ( ) + val * m_ Width ; double delta = ( max - min ) / m_ Num Intervals ; double [ ] probabilities = new double [ m_ Num Intervals ] ; double left Val =  Math . exp ( log Density ( min ) ) ; for ( int i = _ NUM ; i < m_ Num Intervals ; i ++ ) { double right Val =  Math . exp ( log Density ( min + ( i + _ NUM ) * delta ) ) ; probabilities [ i ] = _ NUM * ( left Val + right Val ) * delta ; left Val = right Val ; } int [ ] sorted Indices =  Utils . sort ( probabilities ) ; double sum = _ NUM ; boolean [ ] to Use = new boolean [ probabilities . length ] ; int k = _ NUM ; while ( ( sum < conf ) && ( k < to Use . length ) ) { to Use [ sorted Indices [ to Use . length - ( k + _ NUM ) ] ] = _ BOOL ; sum += probabilities [ sorted Indices [ to Use . length - ( k + _ NUM ) ] ] ; k ++ ; } probabilities = null ;  Array List < double [ ] > intervals = new  Array List < double [ ] > ( ) ; double [ ] interval = null ; boolean have Started Interval = _ BOOL ; for ( int i = _ NUM ; i < m_ Num Intervals ; i ++ ) { if ( to Use [ i ] ) { if ( have Started Interval == _ BOOL ) { have Started Interval = _ BOOL ; interval = new double [ _ NUM ] ; interval [ _ NUM ] = min + i * delta ; } interval [ _ NUM ] = min + ( i + _ NUM ) * delta ; } else { if ( have Started Interval ) { have Started Interval = _ BOOL ; intervals . add ( interval ) ; } } } if ( have Started Interval ) { intervals . add ( interval ) ; } return intervals . to Array ( new double [ _ NUM ] [ _ NUM ] ) ; }
public void send (  String the String ) { send ( the String . get Bytes ( ) ) ; }
public void key Typed (  Key Event evt ) { int modifiers = evt . get Modifiers ( ) ; char c = evt . get Key Char ( ) ; if ( c !=  Key Event .  CHAR_ UNDEFINED && ( modifiers &  Key Event .  ALT_ MASK ) == _ NUM ) { if ( c >= _ NUM && c != _ NUM ) {  Key Stroke key Stroke =  Key Stroke . get Key Stroke (  Character . to Upper Case ( c ) ) ;  Object o = current Bindings . get ( key Stroke ) ; if ( o instanceof  Hashtable ) { current Bindings = (  Hashtable ) o ; return ; } else if ( o instanceof  Action Listener ) { current Bindings = bindings ; execute Action ( (  Action Listener ) o , evt . get Source ( ) ,  String . value Of ( c ) , modifiers ) ; return ; } current Bindings = bindings ; if ( grab Action != null ) { handle Grab Action ( evt ) ; return ; } if ( repeat &&  Character . is Digit ( c ) ) { repeat Count *= _ NUM ; repeat Count += ( c - _ STR ) ; return ; } execute Action (  INSERT_ CHAR , evt . get Source ( ) ,  String . value Of ( evt . get Key Char ( ) ) , modifiers ) ; repeat Count = _ NUM ; repeat = _ BOOL ; } } }
public  Map <  String ,  Mapped Class > remap Class (  Mapped Class mc ,  Map <  String ,  Mapped Class > mappings ,  Mapping Mode mode ) { if ( mc . is Library ( ) || remapped . contains ( mc . get Original Name ( ) ) ) { return mappings ; } if ( mc . has Parent ( ) ) { mappings = remap Class ( mc . get Parent ( ) , mappings , mode ) ; } for (  Mapped Class interfaze : mc . get Interfaces ( ) ) { mappings = remap Class ( interfaze , mappings , mode ) ; } if ( mc . is Inner Class ( ) ) { mappings = remap Class ( mc . get Outer Class ( ) , mappings , mode ) ; } if ( ! mc . is Inner Class ( ) ) { mc . set New Name ( mode . get Class Name ( mc ) ) ; } else {  Mapped Class outter = mc . get Outer Class ( ) ;  String new Name = mode . get Class Name ( mc ) ;  String post = new Name . contains ( _ STR ) ? new Name . substring ( new Name . last Index Of ( _ STR ) + _ NUM , new Name . length ( ) ) : new Name ; mc . set New Name ( outter . get New Name ( ) + _ STR + post ) ; } for (  Mapped Member mm : mc . get Fields ( ) ) { mm . set New Name ( mode . get Field Name ( mm ) ) ; } for (  Mapped Member mm : mc . get Methods ( ) ) { if ( keep Name ( mm ) || mm . is Library ( ) ) { continue ; }  Mapped Member override =  Parent Utils . find Method Override ( mm ) ; if ( override . equals ( mm ) ) { mm . set New Name ( mode . get Method Name ( mm ) ) ; } else { mm . set New Name ( override . get New Name ( ) ) ; if ( mm . does Override ( ) && ! mm . is Overriden ( ) ) { fix Override Names ( mm , override ) ; } }  Method Node mn = mm . get Method Node ( ) ; update Strings ( mn , mappings ) ; } remapped . add ( mc . get Original Name ( ) ) ; return mappings ; }
private void read Object (  Object Input Stream s ) throws  IOException ,  Class Not Found Exception { s . default Read Object ( ) ; try { init ( ) ; } catch (  Runtime Exception e ) { if ( e instanceof  Null Pointer Exception || e instanceof  Illegal Argument Exception ) {  Invalid Object Exception ee = new  Invalid Object Exception ( e . get Message ( ) ) ; ee . init Cause ( e ) ; throw ee ; } throw e ; } }
public static  Script create Multi Sig Input Script Bytes (  List < byte [ ] > signatures , @  Nullable byte [ ] multisig Program Bytes ) { check Argument ( signatures . size ( ) <= _ NUM ) ;  Script Builder builder = new  Script Builder ( ) ; builder . small Num ( _ NUM ) ; for ( byte [ ] signature : signatures ) builder . data ( signature ) ; if ( multisig Program Bytes != null ) builder . data ( multisig Program Bytes ) ; return builder . build ( ) ; }
static boolean compatible Methods (  Class c1 ,  Class c2 ) {  Method [ ] meths = c1 . get Methods ( ) ; for ( int i = meths . length ; -- i >= _ NUM ; ) {  Method m1 = meths [ i ] ; try {  Method m2 = c2 . get Method ( m1 . get Name ( ) , m1 . get Parameter Types ( ) ) ; if ( m2 != null && m1 . get Return Type ( ) != m2 . get Return Type ( ) ) { return _ BOOL ; } } catch (  No Such Method Exception e ) { } } return _ BOOL ; }
public static boolean strictly Between (  Date base Date ,  Date start Date ,  Date end Date ) { if ( start Date . equals ( end Date ) || end Date . before ( start Date ) ) { return _ BOOL ; } if ( start Date . before ( base Date ) && end Date . after ( base Date ) ) { return _ BOOL ; } return _ BOOL ; }
private void wait For Start ( long timeout ) throws  Communication Exception ,  Interrupted Exception { if (  SNMP_ ADAPTOR_ LOGGER . is Loggable (  Level .  FINER ) ) {  SNMP_ ADAPTOR_ LOGGER . logp (  Level .  FINER , dbg Tag , _ STR , _ STR + timeout + _ STR + get State String ( ) ) ; } final long start Time =  System . current Time Millis ( ) ; synchronized ( state Lock ) { while ( state ==  STARTING ) { final long elapsed =  System . current Time Millis ( ) - start Time ; final long remaining Time = timeout - elapsed ; if ( remaining Time < _ NUM ) { if (  SNMP_ ADAPTOR_ LOGGER . is Loggable (  Level .  FINER ) ) {  SNMP_ ADAPTOR_ LOGGER . logp (  Level .  FINER , dbg Tag , _ STR , _ STR ) ; } throw new  Interrupted Exception ( _ STR ) ; } try { state Lock . wait ( remaining Time ) ; } catch (  Interrupted Exception e ) { if (  SNMP_ ADAPTOR_ LOGGER . is Loggable (  Level .  FINER ) ) {  SNMP_ ADAPTOR_ LOGGER . logp (  Level .  FINER , dbg Tag , _ STR , _ STR ) ; } if ( state !=  ONLINE ) throw e ; } } if ( state ==  ONLINE ) { if (  SNMP_ ADAPTOR_ LOGGER . is Loggable (  Level .  FINER ) ) {  SNMP_ ADAPTOR_ LOGGER . logp (  Level .  FINER , dbg Tag , _ STR , _ STR ) ; } return ; } else if ( start Exception instanceof  Communication Exception ) { throw (  Communication Exception ) start Exception ; } else if ( start Exception instanceof  Interrupted Exception ) { throw (  Interrupted Exception ) start Exception ; } else if ( start Exception != null ) { throw new  Communication Exception ( start Exception , _ STR + start Exception ) ; } else { throw new  Communication Exception ( _ STR + get String For State ( state ) ) ; } } }
private void errors To Json (  Errors errors ,  String Builder result ) { result . append ( _ STR ) ; if ( errors != null && errors . has Errors ( ) ) { boolean first = _ BOOL ; for ( final  String text : errors . get Texts ( ) ) { if ( ! first ) { result . append ( _ STR ) ; } first = _ BOOL ; result . append (  Json Builder . quote ( text ) ) ; } } result . append ( _ STR ) ; }
public int read ( char [ ] buffer , int offset , int length ) { int read Length = _ NUM ; while ( length > _ NUM ) { if ( _length <= _offset ) { if ( _head == null ) return read Length == _ NUM ? - _ NUM : read Length ;  Temp Char Buffer next = _head . get Next ( ) ; if ( _is Free )  Temp Char Buffer . free ( _head ) ; _head = next ; if ( _head == null ) return read Length == _ NUM ? - _ NUM : read Length ; _buffer = _head . buffer ( ) ; _length = _head . get Length ( ) ; _offset = _ NUM ; } int sublen = _length - _offset ; if ( length < sublen ) sublen = length ;  System . arraycopy ( _buffer , _offset , buffer , offset , sublen ) ; _offset += sublen ; offset += sublen ; length -= sublen ; read Length += sublen ; } return read Length ; }
private boolean configure Connection For Http Post (  Http URLConnection connection ) throws  IOException {  String boundary = read Boundary ( ) ; if ( boundary == null ) { return _ BOOL ; } connection . set Do Output ( _ BOOL ) ; connection . set Request Property ( _ STR , _ STR ) ; connection . set Request Property ( _ STR , _ STR ) ; connection . set Request Property ( _ STR ,  String . format (  CONTENT_ TYPE_ TMPL , boundary ) ) ; return _ BOOL ; }
public  String to XMLProperty List ( ) {  String Builder xml = new  String Builder ( _ STR ) ; xml . append (  NSObject .  NEWLINE ) ; xml . append ( _ STR ) ; xml . append (  NSObject .  NEWLINE ) ; xml . append ( _ STR ) ; xml . append (  NSObject .  NEWLINE ) ; to XML ( xml , _ NUM ) ; xml . append (  NSObject .  NEWLINE ) ; xml . append ( _ STR ) ; return xml . to String ( ) ; }
public  Certificate Token (  X509 Certificate x509 Certificate ) { if ( x509 Certificate == null ) { throw new  Null Pointer Exception ( _ STR ) ; } this . x509 Certificate = x509 Certificate ; this . issuer X500 Principal = x509 Certificate . get Issuer X500 Principal ( ) ; this . signature Algorithm =  Signature Algorithm . for OID ( x509 Certificate . get Sig Alg OID ( ) ) ; this . digest Algorithm = signature Algorithm . get Digest Algorithm ( ) ; this . encryption Algorithm = signature Algorithm . get Encryption Algorithm ( ) ; super . extra Info = this . extra Info = new  Certificate Token Validation Extra Info ( ) ; }
@  Suppress Warnings ( _ STR ) private boolean is Token Valid For Compression ( byte [ ] blob ) { if ( blob == null ) { return _ BOOL ; }  String contents ; try { contents = blob Utils . to UTF8 ( blob ) ; } catch (  Unsupported Encoding Exception e ) { return _ BOOL ; } if ( ! contents . starts With ( _ STR ) ) { return _ BOOL ; } if ( ! contents . ends With ( _ STR ) ) { return _ BOOL ; }  Set <  String > keys = new  Hash Set <  String > ( ) ; keys . add All ( replacement . key Set ( ) ) ; keys . add All ( replacement . values ( ) ) ; for (  String key : keys ) { if ( contents . contains ( key ) ) { return _ BOOL ; } } return _ BOOL ; }
public void execute (  String sql ,  List <  Object > params ,  Closure process Results ) throws  SQLException {  Connection connection = create Connection ( ) ;  Prepared Statement statement = null ; try { statement = get Prepared Statement ( connection , sql , params ) ; boolean is Result Set = statement . execute ( ) ; int update Count = statement . get Update Count ( ) ; while ( is Result Set || update Count != - _ NUM ) { if ( process Results . get Maximum Number Of Parameters ( ) != _ NUM ) { throw new  SQLException ( _ STR ) ; } if ( is Result Set ) {  Result Set result Set = statement . get Result Set ( ) ;  List <  Groovy Row Result > row Result = result Set == null ? null : as List ( sql , result Set ) ; process Results . call ( is Result Set , row Result ) ; } else { process Results . call ( is Result Set , update Count ) ; } is Result Set = statement . get More Results ( ) ; update Count = statement . get Update Count ( ) ; } } catch (  SQLException e ) {  LOG . warning ( _ STR + sql + _ STR + e . get Message ( ) ) ; throw e ; } finally { close Resources ( connection , statement ) ; } }
@  Override public void write ( byte [ ] buffer , int offset , int length , boolean is End ) throws  IOException { int position = _position ; if ( length < _ NUM ) { throw new  Illegal Argument Exception ( ) ; } if ( _index Address < position + length ) { throw new  Illegal Argument Exception (  L . l ( _ STR ,  Long . to Hex String ( _position ) ,  Long . to Hex String ( length ) ,  Long . to Hex String ( _index Address ) ,  Long . to Hex String ( _segment . length ( ) ) , _segment ) ) ; } _s Out . write ( _segment . get Address ( ) + position , buffer , offset , length ) ; _position = position + length ; _is Dirty = _ BOOL ; }
private  Resource Index refresh Resource Index From Data Store (  Service Type resource Type ) throws  Policy Exception {  Resource Index resource Index = get Resource Index From Data Store ( resource Type ) ; resource Indices . put ( resource Type . get Name ( ) , resource Index ) ; return resource Index ; }
public void test Set Date_int_ Date ( ) throws  SQLException {  Calendar cal = new  Gregorian Calendar ( _ NUM , _ NUM , _ NUM ) ;  Date [ ] dates = { new  Date ( cal . get Time In Millis ( ) ) , new  Date (  Integer .  MAX_ VALUE ) , new  Date ( _ NUM ) } ;  Prepared Statement ps = null ;  Prepared Statement ps1 = null ; try {  String query = _ STR ; ps = conn . prepare Statement ( query ) ; for ( int i = _ NUM ; i < dates . length ; i ++ ) { ps . set Date ( _ NUM , dates [ i ] ) ; assert False ( ps . execute ( ) ) ; assert True ( ps . get Update Count ( ) > _ NUM ) ; } try { ps . set Date ( _ NUM , dates [ _ NUM ] ) ; fail ( _ STR ) ; } catch (  Exception sqle ) { } ps . close ( ) ; try { ps . set Date ( _ NUM , dates [ _ NUM ] ) ; fail ( _ STR ) ; } catch (  SQLException sqle ) { }  String query1 = _ STR ; ps1 = conn . prepare Statement ( query1 ) ; try { ps1 . set Date ( _ NUM , dates [ _ NUM ] ) ; fail ( _ STR ) ; } catch (  SQLException sqle ) { assert Equals ( _ STR , sqle . get Message ( ) ) ; } } finally { try { if ( ps != null ) ps . close ( ) ; if ( ps1 != null ) ps1 . close ( ) ; } catch (  SQLException ee ) { } } }
public static byte [ ] [ ] split Nal Units ( byte [ ] data ) { if ( ! is Nal Start Code ( data , _ NUM ) ) { return null ; }  List <  Integer > starts = new  Array List < > ( ) ; int nal Unit Index = _ NUM ; do { starts . add ( nal Unit Index ) ; nal Unit Index = find Nal Start Code ( data , nal Unit Index +  NAL_ START_ CODE . length ) ; } while ( nal Unit Index != - _ NUM ) ; byte [ ] [ ] split = new byte [ starts . size ( ) ] [ ] ; for ( int i = _ NUM ; i < starts . size ( ) ; i ++ ) { int start Index = starts . get ( i ) ; int end Index = i < starts . size ( ) - _ NUM ? starts . get ( i + _ NUM ) : data . length ; byte [ ] nal = new byte [ end Index - start Index ] ;  System . arraycopy ( data , start Index , nal , _ NUM , nal . length ) ; split [ i ] = nal ; } return split ; }
public final  Bean Event Type create Bean Type (  String name ,  Class clazz , boolean is Preconfigured Static , boolean is Preconfigured , boolean is Configured ) { if ( clazz == null ) { throw new  Illegal Argument Exception ( _ STR ) ; }  Bean Event Type event Type = null ; types Per Java Bean Lock . lock ( ) ; try { event Type = types Per Java Bean . get ( clazz ) ; if ( event Type != null ) { event Type Id Generator . assigned Type ( name , event Type ) ; return event Type ; }  Configuration Event Type Legacy legacy Def = class To Legacy Configs . get ( clazz . get Name ( ) ) ; if ( ( legacy Def == null ) && ( default Accessor Style !=  Configuration Event Type Legacy .  Accessor Style .  JAVABEAN ) ) { legacy Def = new  Configuration Event Type Legacy ( ) ; legacy Def . set Accessor Style ( default Accessor Style ) ; } int type Id = event Type Id Generator . get Type Id ( name ) ;  Event Type Metadata metadata =  Event Type Metadata . create Bean Type ( name , clazz , is Preconfigured Static , is Preconfigured , is Configured ,  Event Type Metadata .  Type Class .  APPLICATION ) ; event Type = new  Bean Event Type ( metadata , type Id , clazz , event Adapter Service , legacy Def ) ; types Per Java Bean . put ( clazz , event Type ) ; } catch (  Runtime Exception ex ) { throw ex ; } finally { types Per Java Bean Lock . unlock ( ) ; } return event Type ; }
private void update BP (  Hash Set <  Integer > bps ) { log . info ( _ STR + bps . size ( ) ) ;  Iterator <  Integer > it = bps . iterator ( ) ; while ( it . has Next ( ) ) { int  C_ BPartner_ ID = it . next ( ) ;  MBPartner bp = new  MBPartner ( get Ctx ( ) ,  C_ BPartner_ ID , get_ Trx Name ( ) ) ; bp . set Total Open Balance ( ) ; if ( bp . save ( ) ) log . fine ( bp . to String ( ) ) ; else log . log (  Level .  SEVERE , _ STR + bp ) ; } }
public static boolean use MSInterop ( ) {  String prop Value =  Access Controller . do Privileged ( new  Get Property Action ( _ STR , _ STR ) ) ; return ( ! prop Value . equals Ignore Case ( _ STR ) ) ; }
public void close Storage (  Storage Data storage Data ) throws  Business Exception ,  IOException ,  Serialization Exception {  Storage Data local = get Local Storage Data Object ( storage Data ) ; synchronized ( local ) { if ( ( storage Recorder . is Recording On ( ) || storage Recorder . is Recording Scheduled ( ) ) &&  Objects . equals ( local , recorder Storage Data ) ) { throw new  Business Exception ( _ STR + local + _ STR ,  Storage Error Code Enum .  STORAGE_ CAN_ NOT_ BE_ CLOSED ) ; } else if ( is Storage Closed ( local ) ) { throw new  Business Exception ( _ STR + local + _ STR ,  Storage Error Code Enum .  STORAGE_ ALREADY_ CLOSED ) ; }  Storage Writer writer = opened Storages Map . get ( local ) ; if ( writer != null ) { writer . close Storage Writer ( ) ; } opened Storages Map . remove ( local ) ; local . set Disk Size ( get Disk Size For Storage ( local ) ) ; local . mark Closed ( ) ; write Storage Data To Disk ( local ) ; } }
public  Request add (  Request request ) { request . set Request Queue ( this ) ; synchronized ( m Current Requests ) { m Current Requests . add ( request ) ; } request . set Sequence ( get Sequence Number ( ) ) ; request . add Marker ( _ STR ) ; if ( ! request . should Cache ( ) ) { m Network Queue . add ( request ) ; return request ; } synchronized ( m Waiting Requests ) {  String cache Key = request . get Cache Key ( ) ; if ( m Waiting Requests . contains Key ( cache Key ) ) {  Queue <  Request > staged Requests = m Waiting Requests . get ( cache Key ) ; if ( staged Requests == null ) { staged Requests = new  Linked List <  Request > ( ) ; } staged Requests . add ( request ) ; m Waiting Requests . put ( cache Key , staged Requests ) ; if (  Volley Log .  DEBUG ) {  Volley Log . v ( _ STR , cache Key ) ; } } else { m Waiting Requests . put ( cache Key , null ) ; m Cache Queue . add ( request ) ; } return request ; } }
@  Deprecated public static boolean check And Convert Identifier (  Psi Builder b , int l , @  Not Null  String identifier Value , @  Not Null  IElement Type token Type ) { if (  CONVERTABLE_ TOKENS . contains ( b . get Token Type ( ) ) && identifier Value . equals ( b . get Token Text ( ) ) ) {  Psi Builder .  Marker m = b . mark ( ) ; b . advance Lexer ( ) ; m . collapse ( token Type ) ; return _ BOOL ; } return _ BOOL ; }
@  Override public void count Example (  Example example ) { int label = class Name Map . get ( example . get Nominal Value ( label Attribute ) ) ; int plabel = class Name Map . get ( example . get Nominal Value ( predicted Label Attribute ) ) ; double weight = _ NUM ; if ( weight Attribute != null ) { weight = example . get Value ( weight Attribute ) ; } counter [ label ] [ plabel ] += weight ; }
private void load Binary Index (  URL url ) { diphone Index = new  Hash Map ( ) ; try {  Input Stream is =  Utilities . get Input Stream ( url ) ;  Data Input Stream dis = new  Data Input Stream ( is ) ; if ( dis . read Int ( ) !=  INDEX_ MAGIC ) { throw new  Error ( _ STR ) ; } int size = dis . read Int ( ) ; for ( int i = _ NUM ; i < size ; i ++ ) {  String diphone Name = dis . read UTF ( ) ; int pos = dis . read Int ( ) ; diphone Index . put ( diphone Name , new  Integer ( pos ) ) ; } dis . close ( ) ; } catch (  File Not Found Exception fe ) { throw new  Error ( _ STR + fe . get Message ( ) ) ; } catch (  IOException ioe ) { throw new  Error ( _ STR + ioe . get Message ( ) ) ; } }
public  VNXe Command Result delete Luns From Consistency Group (  String cg Id ,  List <  String > luns ) {  Lun Group Modify Param param = new  Lun Group Modify Param ( ) ;  List <  Lun Add Param > lun Delete = new  Array List <  Lun Add Param > ( ) ; for (  String lun Id : luns ) {  VNXe Base lun = new  VNXe Base ( lun Id ) ;  Lun Add Param lun Add = new  Lun Add Param ( ) ; lun Add . set Lun ( lun ) ; lun Delete . add ( lun Add ) ; } param . set Lun Delete ( lun Delete ) ;  Consistency Group Requests req = new  Consistency Group Requests ( _kh Client ) ; return req . modify Consistency Group Sync ( cg Id , param ) ; }
public void add Discovery Listener (  Discovery Listener l ) { if ( l == null ) { throw new  Null Pointer Exception ( _ STR ) ; } synchronized ( this ) { if ( terminated ) { throw new  Illegal State Exception ( _ STR ) ; } if ( listeners . contains ( l ) ) return ; listeners . add ( l ) ; if ( ! discovered Locators . is Empty ( ) ) {  Hash Map groups Map = new  Hash Map ( discovered Locators . size ( ) ) ;  Iterator iter = discovered Locators . iterator ( ) ; for ( int i = _ NUM ; iter . has Next ( ) ; i ++ ) {  Locator Reg reg = (  Locator Reg ) iter . next ( ) ; groups Map . put ( reg . proxy , reg . member Groups ) ; }  Array List list = new  Array List ( _ NUM ) ; list . add ( l ) ; add Notify ( list , groups Map , _ BOOL ) ; } } }
public boolean less Than (  Register Priority other ) { return ordinal ( ) < other . ordinal ( ) ; }
private void update Chart ( ) { main Panel . remove All ( ) ;  Grid Bag Constraints constraints = new  Grid Bag Constraints ( ) ; constraints . fill =  Grid Bag Constraints .  BOTH ; constraints . gridx = _ NUM ; constraints . gridy = _ NUM ; constraints . gridwidth = _ NUM ; constraints . weightx = _ NUM ; constraints . weighty = _ NUM ; constraints . anchor =  Grid Bag Constraints .  CENTER ;  JPanel chart Panel = create Chart Panel ( ) ; chart Panel . set Opaque ( _ BOOL ) ; chart Panel . set Background (  Color And Font Constants .  BACKGROUND_ COLOR ) ; chart Panel . set Foreground (  Color And Font Constants .  TEXT_ COLOR ) ; main Panel . add ( chart Panel , constraints ) ; }
public static final boolean is Oracle JCEProvider (  String provider Name ) { return provider Name != null && ( provider Name . equals ( _ STR ) || provider Name . equals ( _ STR ) || provider Name . equals ( _ STR ) || provider Name . starts With ( _ STR ) ) ; }
public static  Http URLConnection to Http Connection (  Request Batch requests ) { for (  Request request : requests ) { request . validate ( ) ; }  URL url = null ; try { if ( requests . size ( ) == _ NUM ) {  Request request = requests . get ( _ NUM ) ; url = new  URL ( request . get Url For Single Request ( ) ) ; } else { url = new  URL (  Server Protocol . get Graph Url Base ( ) ) ; } } catch (  Malformed URLException e ) { throw new  Facebook Exception ( _ STR , e ) ; }  Http URLConnection connection ; try { connection = create Connection ( url ) ; serialize To Url Connection ( requests , connection ) ; } catch (  IOException e ) { throw new  Facebook Exception ( _ STR , e ) ; } catch (  JSONException e ) { throw new  Facebook Exception ( _ STR , e ) ; } return connection ; }
public  Core Admin Handler ( final  Core Container core Container ) { this . core Container = core Container ;  Hash Map <  String ,  Map <  String ,  Task Object > > map = new  Hash Map < > ( _ NUM , _ NUM ) ; map . put (  RUNNING ,  Collections . synchronized Map ( new  Linked Hash Map <  String ,  Task Object > ( ) ) ) ; map . put (  COMPLETED ,  Collections . synchronized Map ( new  Linked Hash Map <  String ,  Task Object > ( ) ) ) ; map . put (  FAILED ,  Collections . synchronized Map ( new  Linked Hash Map <  String ,  Task Object > ( ) ) ) ; request Status Map =  Collections . unmodifiable Map ( map ) ; }
public static  TCPEndpoint read (  Object Input in ) throws  IOException ,  Class Not Found Exception {  String host ; int port ;  RMIClient Socket Factory csf = null ; byte format = in . read Byte ( ) ; switch ( format ) { case  FORMAT_ HOST_ PORT : host = in . read UTF ( ) ; port = in . read Int ( ) ; break ; case  FORMAT_ HOST_ PORT_ FACTORY : host = in . read UTF ( ) ; port = in . read Int ( ) ; csf = (  RMIClient Socket Factory ) in . read Object ( ) ; break ; default : throw new  IOException ( _ STR ) ; } return new  TCPEndpoint ( host , port , csf , null ) ; }
public void test Bug20687 ( ) throws  Exception { if ( version Meets Minimum ( _ NUM , _ NUM ) ) { create Table ( _ STR , _ STR ) ;  Connection pooling Conn = null ;  Properties props = new  Properties ( ) ; props . set Property ( _ STR , _ STR ) ; props . set Property ( _ STR , _ STR ) ;  Prepared Statement pstmt1 = null ;  Prepared Statement pstmt2 = null ; try { pooling Conn = get Connection With Props ( props ) ; pstmt1 = pooling Conn . prepare Statement ( _ STR ) ; this . rs = pstmt1 . execute Query ( ) ; pstmt1 . close ( ) ; pstmt2 = pooling Conn . prepare Statement ( _ STR ) ; this . rs = pstmt2 . execute Query ( ) ; assert True ( pstmt1 == pstmt2 ) ; pstmt2 . close ( ) ; } finally { if ( pstmt1 != null ) { pstmt1 . close ( ) ; } if ( pstmt2 != null ) { pstmt2 . close ( ) ; } if ( pooling Conn != null ) { pooling Conn . close ( ) ; } } } }
public  Program Rewriter (  Statement Block Rewrite Rule rewrite ) { _dag Rule Set = new  Array List <  Hop Rewrite Rule > ( ) ; _sb Rule Set = new  Array List <  Statement Block Rewrite Rule > ( ) ; _sb Rule Set . add ( rewrite ) ; }
private  JMenu create Bin Navi Menu ( ) { final  JMenu menu = new  JMenu ( _ STR ) ; menu . set Mnemonic ( _ STR ) ; menu . add (  CAction Proxy . proxy ( new  CAdd Database Action ( m_project Tree ) ) ) ; menu . add Separator ( ) ; menu . add (  CAction Proxy . proxy ( new  CAction Exit ( get Parent ( ) ) ) ) ; return menu ; }
void dump Binary (  Data Output Stream os ) throws  IOException { os . write Int ( type ) ; os . write Int ( phone ) ; os . write Int ( start ) ; os . write Int ( end ) ; os . write Int ( prev ) ; os . write Int ( next ) ; }
public static boolean is Punc (  String str ) { if ( str == null ) return _ BOOL ; str = str . trim ( ) ; for ( int i = _ NUM ; i < str . length ( ) ; ++ i ) { char c = str . char At ( i ) ; if (  Character . is Digit ( c ) ||  Character . is Letter ( c ) ) { return _ BOOL ; } } return _ BOOL ; }
private void handle Channel (  String [ ] args ,  Buffered Reader reader ) throws  IOException {  Tuple <  String ,  String > initial Payload = new  Tuple < > ( args [ _ NUM ] , args [ _ NUM ] ) ; if ( args . length == _ NUM ) { request Channel Fail . add ( initial Payload ) ; }  String line = reader . read Line ( ) ;  List <  String > commands = new  Array List < > ( ) ; while ( ! line . equals ( _ STR ) ) { commands . add ( line ) ; line = reader . read Line ( ) ; } request Channel Commands . put ( initial Payload , commands ) ; }
static void clean Legacy Checksums (  Directory directory , long new Version ) throws  IOException { synchronized ( directory ) { for (  String name : directory . list All ( ) ) { if ( is Checksum ( name ) ) { long current =  Long . parse Long ( name . substring (  CHECKSUMS_ PREFIX . length ( ) ) ) ; if ( current < new Version ) { try { directory . delete File ( name ) ; } catch (  IOException ex ) { logger . debug ( _ STR , ex , name ) ; } } } } } }
public static  Thread consume Process Error Stream (  Process self ,  Output Stream err ) {  Thread thread = new  Thread ( new  Byte Dumper ( self . get Error Stream ( ) , err ) ) ; thread . start ( ) ; return thread ; }
public  Str Builder delete First (  String str ) { int len = ( str == null ? _ NUM : str . length ( ) ) ; if ( len > _ NUM ) { int index = index Of ( str , _ NUM ) ; if ( index >= _ NUM ) { delete Impl ( index , index + len , len ) ; } } return this ; }
@  Reference ( authors = _ STR , title = _ STR , booktitle = _ STR , url = _ STR ) public static <  V extends  Number Vector > double log Likelihood Alternate (  Relation <  V > relation ,  Clustering < ? extends  Mean Model > clustering ,  Number Vector Distance Function < ? super  V > distance Function ) {  List < ? extends  Cluster < ? extends  Mean Model > > clusters = clustering . get All Clusters ( ) ; final int dim =  Relation Util . dimensionality ( relation ) ; final int m = clusters . size ( ) ; int n = _ NUM ; int [ ] n_i = new int [ m ] ; double [ ] d_i = new double [ m ] ;  Iterator < ? extends  Cluster < ? extends  Mean Model > > it = clusters . iterator ( ) ; for ( int i = _ NUM ; it . has Next ( ) ; ++ i ) {  Cluster < ? extends  Mean Model > cluster = it . next ( ) ; n += n_i [ i ] = cluster . size ( ) ; d_i [ i ] = variance Of Cluster ( cluster , distance Function , relation ) ; } double log Likelihood = _ NUM ; for ( int i = _ NUM ; i < m ; i ++ ) { log Likelihood += n_i [ i ] *  Math . log ( n_i [ i ] / ( double ) n ) - n_i [ i ] * dim * _ NUM *  Math Util .  LOGTWOPI - n_i [ i ] * _ NUM *  Math . log ( d_i [ i ] ) - ( n_i [ i ] - m ) * _ NUM ; } return log Likelihood ; }
private  Object [ ] unmarshal Parameters Unchecked (  Method method ,  Object Input in ) throws  IOException ,  Class Not Found Exception {  Class < ? > [ ] types = method . get Parameter Types ( ) ;  Object [ ] params = new  Object [ types . length ] ; for ( int i = _ NUM ; i < types . length ; i ++ ) { params [ i ] = unmarshal Value ( types [ i ] , in ) ; } return params ; }
public static void encode Multicast Announcement (  Multicast Announcement announcement ,  Datagram Buffer Factory bufs ) throws  IOException { try {  Linked List groups = new  Linked List ( ) ; groups . add All (  Arrays . as List ( announcement . get Groups ( ) ) ) ; do {  Byte Buffer buf = bufs . new Buffer ( ) ; int slim = buf . limit ( ) ; buf . limit ( slim -  SERVICE_ ID_ LEN ) ; buf . put Long ( announcement . get Sequence Number ( ) ) ; put Utf ( buf , announcement . get Host ( ) ) ; buf . put Short ( int To Ushort ( announcement . get Port ( ) ) ) ; int ngroups = _ NUM ; int ngroups Pos = buf . position ( ) ; buf . put Short ( ( short ) _ NUM ) ; try { while ( ! groups . is Empty ( ) && ngroups <  MAX_ USHORT ) { put Utf ( buf , (  String ) groups . get First ( ) ) ; groups . remove First ( ) ; ngroups ++ ; } } catch (  Buffer Overflow Exception e ) { if ( ngroups == _ NUM ) { throw e ; } } buf . put Short ( ngroups Pos , int To Ushort ( ngroups ) ) ;  Service ID id = announcement . get Service ID ( ) ; buf . limit ( slim ) ; buf . put Long ( id . get Most Significant Bits ( ) ) ; buf . put Long ( id . get Least Significant Bits ( ) ) ; } while ( ! groups . is Empty ( ) ) ; } catch (  Runtime Exception e ) { throw new  Discovery Protocol Exception ( null , e ) ; } }
public  String to String ( ) {  String Buffer printstring = new  String Buffer ( ) ; for (  String key : gaz . key Set ( ) ) {  Gaz Entry ge = gaz . get ( key ) ; ge . string Representation ( key , key , printstring ) ; } return printstring . to String ( ) ; }
public boolean contains None ( ) { return prompts . contains (  PROMPT_ NONE ) ; }
private static int select ( int [ ] array , int [ ] index , int left , int right , int k ) { if ( left == right ) { return left ; } else { int middle = partition ( array , index , left , right ) ; if ( ( middle - left + _ NUM ) >= k ) { return select ( array , index , left , middle , k ) ; } else { return select ( array , index , middle + _ NUM , right , k - ( middle - left + _ NUM ) ) ; } } }
public  Image rotate270 Degrees (  Image image , boolean maintain Opacity ) { int [ ] rgb = image . get RGB ( ) ; int [ ] new RGB = new int [ rgb . length ] ; int width = image . get Width ( ) ; int height = image . get Height ( ) ; for ( int y = _ NUM ; y < height ; y ++ ) { for ( int x = _ NUM ; x < width ; x ++ ) { new RGB [ y + x * height ] = rgb [ x + y * width ] ; } } return  Encoded Image . create From RGB ( new RGB , height , width , ! maintain Opacity ) ; }
public static boolean is File Transfer Over Http (  Sip Request request ) {  Cpim Message message = extract Cpim Message ( request ) ; if ( message == null ) { return _ BOOL ; }  String content Type = message . get Content Type ( ) ; return content Type != null && content Type . starts With (  File Transfer Http Info Document .  MIME_ TYPE ) ; }
private void debug Segment (  Write Stream out ,  Segment Service Impl segment Service ,  Segment Extent extent , byte [ ] debug Table Key ) throws  IOException { int length = extent . length ( ) ; try (  In Segment in = segment Service . open Read ( extent ) ) {  Read Stream is = new  Read Stream ( in ) ; is . position ( length -  BLOCK_ SIZE ) ; long seq =  Bits Util . read Long ( is ) ; if ( seq <= _ NUM ) { return ; } byte [ ] table Key = new byte [ _ NUM ] ; is . read All ( table Key , _ NUM , table Key . length ) ;  Table Entry table = segment Service . find Table ( table Key ) ; if ( table == null ) { return ; } if ( debug Table Key != null && !  Arrays . equals ( debug Table Key , table Key ) ) { return ; } out . println ( ) ;  String Builder sb = new  String Builder ( ) ;  Base64 Util . encode ( sb , seq ) ; long time = _id Gen . time ( seq ) ; out . println ( _ STR + extent . get Id ( ) + _ STR + sb + _ STR +  Hex . to Short Hex ( table Key ) + _ STR +  Long . to Hex String ( extent . address ( ) ) + _ STR +  Integer . to Hex String ( length ) + _ STR +  Local Date Time . of Epoch Second ( time / _ NUM , _ NUM ,  Zone Offset .  UTC ) + _ STR ) ; debug Segment Entries ( out , is , extent , table ) ; } }
public void add Exit Time ( double time ) { if ( exit Times == null ) { return ; } if ( time < _ NUM ) { time = _ NUM ; } exit Times . add (  Double . value Of ( time ) ) ; }
public static  Map <  String ,  String [ ] > to Multi Map (  Named List params ) {  Hash Map <  String ,  String [ ] > map = new  Hash Map < > ( ) ; for ( int i = _ NUM ; i < params . size ( ) ; i ++ ) {  String name = params . get Name ( i ) ;  Object val = params . get Val ( i ) ; if ( val instanceof  String [ ] ) {  Multi Map Solr Params . add Param ( name , (  String [ ] ) val , map ) ; } else if ( val instanceof  List ) {  List l = (  List ) val ;  String [ ] s = new  String [ l . size ( ) ] ; for ( int j = _ NUM ; j < l . size ( ) ; j ++ ) { s [ j ] = l . get ( j ) == null ? null :  String . value Of ( l . get ( j ) ) ; }  Multi Map Solr Params . add Param ( name , s , map ) ; } else {  Multi Map Solr Params . add Param ( name , val . to String ( ) , map ) ; } } return map ; }
private void _deserialize Query Field (  Query query ,  Element field ) throws  Page Exception ,  Converter Exception {  String name = field . get Attribute ( _ STR ) ;  Node List list = field . get Child Nodes ( ) ; int len = list . get Length ( ) ; int count = _ NUM ; for ( int i = _ NUM ; i < len ; i ++ ) {  Node node = list . item ( i ) ; if ( node instanceof  Element ) { query . set At (  Key Impl . init ( name ) , ++ count , _deserialize ( (  Element ) node ) ) ; } } }
public  Distributed Test CLI (  String [ ] args ) { cli Options = create Options ( ) ; try {  Command Line Parser parser = new  Gnu Parser ( ) ; command Line = parser . parse ( cli Options , args , _ BOOL ) ; if ( has Option ( _ STR ) ) { print Help ( ) ;  System . exit ( _ NUM ) ; } if ( ! has Option ( _ STR ) ) { logger . info ( _ STR ) ;  System . exit ( _ NUM ) ; } } catch (  Exception e ) { e . print Stack Trace ( ) ;  System . exit ( _ NUM ) ; } }
private static byte [ ] concat Bytes ( byte [ ] array1 , byte [ ] array2 ) { byte [ ] c Bytes = new byte [ array1 . length + array2 . length ] ; try {  System . arraycopy ( array1 , _ NUM , c Bytes , _ NUM , array1 . length ) ;  System . arraycopy ( array2 , _ NUM , c Bytes , array1 . length , array2 . length ) ; } catch (  Exception e ) { throw new  Faces Exception ( e ) ; } return c Bytes ; }
public  Result Set read For Update (  String full Id ,  String type ,  String local Id ,  Connection connection ) throws  Not Found Exception ,  SQLException {  Prepared Statement read For Update Statement = null ;  Result Set rs = null ; try { read For Update Statement = get Prepared Statement ( connection ,  Query Definition .  READFORUPDATEQUERYSTR ) ; logger . trace ( _ STR , read For Update Statement , full Id ) ; read For Update Statement . set String ( _ NUM , type ) ; read For Update Statement . set String ( _ NUM , local Id ) ; logger . debug ( _ STR , read For Update Statement ) ; rs = read For Update Statement . execute Query ( ) ; if ( rs . next ( ) ) { logger . debug ( _ STR , full Id ) ; return rs ; } else {  Cleanup Helper . logged Close ( rs ) ;  Cleanup Helper . logged Close ( read For Update Statement ) ; throw new  Not Found Exception ( _ STR + full Id + _ STR + type ) ; } } catch (  SQLException ex ) {  Cleanup Helper . logged Close ( rs ) ;  Cleanup Helper . logged Close ( read For Update Statement ) ; throw ex ; } }
private final double conditional Survival Probability ( int x , double v , int y , double t , double [ ] m ) { double mt = m [ _ NUM ] + m [ _ NUM ] ; if ( v < _ NUM || v > t ) { throw new  Illegal Argument Exception ( _ STR + v + _ STR + t ) ; } else { double a , b , c , d ; if ( x == y ) { a = m [ _ NUM ] * m [ _ NUM ] ; b = - a ; c = m [ _ NUM - x ] ; d = m [ x ] ; } else { a = m [ _ NUM - y ] ; b = m [ _ NUM - x ] ; c = _ NUM ; d = - _ NUM ; } double exponent = ( b * c - a * d ) / ( c * d * - mt ) ; double  C =  Math . pow ( c *  Math . exp ( - mt * t ) + d , - exponent ) ; return  C *  Math . exp ( b * v / d ) *  Math . pow ( d + c *  Math . exp ( - mt * ( t - v ) ) , exponent ) ; } }
public void add (  String category ,  String [ ] titles , double [ ] values ) { m Categories . add ( category ) ; m Titles . add ( titles ) ; m Values . add ( values ) ; }
public void remove Item Listener (  Item Listener a Listener ) { listener List . remove (  Item Listener . class , a Listener ) ; }
@  Override public  Enumeration <  Option > list Options ( ) {  Vector <  Option > result = new  Vector <  Option > ( ) ; result . add Element ( new  Option ( _ STR , _ STR , _ NUM , _ STR ) ) ; result . add Element ( new  Option ( _ STR + _ STR , _ STR , _ NUM , _ STR ) ) ; result . add Element ( new  Option ( _ STR + _ STR , _ STR , _ NUM , _ STR ) ) ; result . add Element ( new  Option ( _ STR , _ STR , _ NUM , _ STR ) ) ; return result . elements ( ) ; }
public static  Mosaic Id parse ( final  String mosaic Id ) { final  Matcher matcher =  MOSAIC_ ID_ PATTERN . matcher ( mosaic Id ) ; if ( ! matcher . matches ( ) ) { throw new  Illegal Argument Exception (  String . format ( _ STR , mosaic Id ) ) ; } return new  Mosaic Id ( new  Namespace Id ( matcher . group ( _ NUM ) ) , matcher . group ( _ NUM ) ) ; }
public static double [ ] from String (  String data ,  String separator ) {  String [ ] split = data . split ( separator ) ; double [ ] ret = new double [ split . length ] ; for ( int i = _ NUM ; i < split . length ; i ++ ) { ret [ i ] =  Double . parse Double ( split [ i ] ) ; } return ret ; }
public static <  T > boolean remove If (  Iterable <  T > remove From ,  Predicate < ? super  T > predicate ) { if ( remove From instanceof  Random Access && remove From instanceof  List ) { return remove If From Random Access List ( (  List <  T > ) remove From , check Not Null ( predicate ) ) ; } return  Iterators . remove If ( remove From . iterator ( ) , predicate ) ; }
private static void remove Margin Top Of Content Child (  View m Content Child , int status Bar Height ) { if ( m Content Child == null ) { return ; } if (  TAG_ MARGIN_ ADDED . equals ( m Content Child . get Tag ( ) ) ) {  Frame Layout .  Layout Params lp = (  Frame Layout .  Layout Params ) m Content Child . get Layout Params ( ) ; lp . top Margin -= status Bar Height ; m Content Child . set Layout Params ( lp ) ; m Content Child . set Tag ( null ) ; } }
public static byte [ ] hex String To Byte Array (  String s ) { int len = s . length ( ) ; byte [ ] data = new byte [ len / _ NUM ] ; for ( int i = _ NUM ; i < len ; i += _ NUM ) { data [ i / _ NUM ] = ( byte ) ( (  Character . digit ( s . char At ( i ) , _ NUM ) << _ NUM ) +  Character . digit ( s . char At ( i + _ NUM ) , _ NUM ) ) ; } return data ; }
private void fetch Features (  Gapis Features features ) throws  Execution Exception ,  Rpc Exception ,  Timeout Exception {  String [ ] list =  Rpc . get ( my Client . get Features ( ) ,  FETCH_ FEATURES_ TIMEOUT_ MS ,  Time Unit .  MILLISECONDS ) ; features . set Feature List ( list ) ;  LOG . info ( _ STR +  Arrays . to String ( list ) ) ; }
public  String dump ( ) {  String [ ] names = get Source Names ( ) ; double [ ] [ ] values = get Values ( ) ;  String Builder buffer = new  String Builder ( ) ; buffer . append ( format ( _ STR , _ NUM ) ) ; for (  String name : names ) { buffer . append ( format ( name , _ NUM ) ) ; } buffer . append ( _ STR ) ; for ( int i = _ NUM ; i < timestamps . length ; i ++ ) { buffer . append ( format (  Long . to String ( timestamps [ i ] ) , _ NUM ) ) ; for ( int j = _ NUM ; j < names . length ; j ++ ) { buffer . append ( format (  Util . format Double ( values [ j ] [ i ] ) , _ NUM ) ) ; } buffer . append ( _ STR ) ; } return buffer . to String ( ) ; }
@  Suppress Warnings ( _ STR )  Full Array (  Class <  L > linear Array Type ,  L real ,  L imag , int [ ] dimensions ) { _dimensions = dimensions ; _number Of Elements =  Array Utils . get Number Of Elements ( _dimensions ) ; _real = linear Array Type . cast ( real ) ; _imag = linear Array Type . cast ( imag ) ; _base Component Type = linear Array Type . get Component Type ( ) ; _linear Array Type = linear Array Type ; _output Array Type = (  Class <  T > )  Array Utils . get Array Class ( _base Component Type , dimensions . length ) ; }
public void validate (  List <  Path > parts ,  Partitioner Type partitioner Type , int num Shards ) throws  IOException { boolean has Non Empty Partition = _ BOOL ;  HColumn Descriptor column Descriptor = new  HColumn Descriptor ( ) ; column Descriptor . set Block Cache Enabled ( _ BOOL ) ; for ( int shard Index = _ NUM ; shard Index < parts . size ( ) ; shard Index ++ ) {  Path file To Be Validated = parts . get ( shard Index ) ;  HFile .  Reader reader = null ; try {  File System fs =  File System . new Instance ( file To Be Validated . to Uri ( ) , conf ) ;  Cache Config cc = new  Cache Config ( conf , column Descriptor ) ; reader =  HFile . create Reader ( fs , file To Be Validated , cc ) ;  Partitioner partitioner =  Partitioner Factory . get Partitioner ( partitioner Type ) ; byte [ ] row Key = reader . get First Row Key ( ) ; if ( row Key == null ) {  LOG . warn (  String . format ( _ STR , file To Be Validated . to String ( ) ) ) ; reader . close ( ) ; continue ; } has Non Empty Partition = _ BOOL ;  Bytes Writable key = new  Bytes Writable ( row Key ) ; int partition = partitioner . get Partition ( key , null , num Shards ) ; if ( partition != shard Index ) { throw new  Illegal Argument Exception (  String . format ( _ STR , partitioner Type . to String ( ) , new  String ( key . get Bytes ( ) ) , shard Index , partition ) ) ; } } finally { if ( reader != null ) { reader . close ( ) ; } } } if ( ! has Non Empty Partition ) { throw new  Illegal Argument Exception ( _ STR ) ; } }
public boolean wait For Applied Event (  String event , long timeout ) throws  Exception { long seqno = new  Long ( event ) ; if ( pipeline == null ) throw new  Replicator Exception ( _ STR + seqno + _ STR ) ;  Future <  Repl DBMSHeader > expected Event = pipeline . watch For Committed Sequence Number ( seqno , _ BOOL ) ;  Repl DBMSHeader repl Event = null ; try { if ( timeout <= _ NUM ) repl Event = expected Event . get ( ) ; else repl Event = expected Event . get ( timeout ,  Time Unit .  SECONDS ) ; logger . info ( _ STR + seqno + _ STR + repl Event . get Seqno ( ) ) ; } catch (  Timeout Exception e ) { return _ BOOL ; } finally { expected Event . cancel ( _ BOOL ) ; } return _ BOOL ; }
public void add Slide ( @  Non Null  Fragment fragment , @  Color Int int color ) { fragments . add ( fragment ) ; add Background Color ( color ) ; pager Adapter . notify Data Set Changed ( ) ; }
public  String process (  Item item ) throws  Process Exception { int count = _ NUM ;  Item ss = item . get Item As (  Relation .  SYLLABLE ) ;  Item first Syllable =  FIRST_ SYLLABLE_ PATH . find Item ( item ) ; for (  Item p = ss ; p != null ; p = p . get Previous ( ) , count ++ ) { if ( p . equals Shared ( first Syllable ) ) { break ; } } return  Integer . to String ( rail ( count ) ) ; }
public  E remove LRUEntry ( ) { if ( is Empty ( ) ) return null ;  Iterator <  E > i = iterator ( ) ;  E value = i . next ( ) ; i . remove ( ) ; return value ; }
private void parse Session String ( ) { if ( is Parsed ) { return ; } if ( is Null ( ) ) { throw new  Illegal Argument Exception ( _ STR ) ; }  String server ID = null ; try {  String sid String = encrypted String ; if ( is C66 Encoded ( ) ) { sid String = c66 Decode Cookie String ( encrypted String ) ; } int outer Index = sid String . last Index Of ( _ STR ) ; if ( outer Index == - _ NUM ) { is Parsed = _ BOOL ; return ; }  String outer = sid String . substring ( outer Index + _ NUM ) ; int tail Index = outer . index Of ( _ STR ) ; tail = outer . substring ( tail Index + _ NUM ) ; if ( tail Index != - _ NUM ) {  String extension Part = outer . substring ( _ NUM , tail Index ) ; extensions = new  Dynamic Session IDExtensions ( new  Legacy Session IDExtensions ( extension Part ) ) ; } else { extensions = new  Legacy Session IDExtensions ( ) ; } server ID = extensions . get Site ID ( ) ; if ( server ID != null ) { set Server ID ( server ID ) ; } } catch (  Exception e ) { debug . error ( _ STR + encrypted String + _ STR , e ) ; throw new  Illegal Argument Exception ( _ STR + encrypted String + _ STR + e ) ; } is Parsed = _ BOOL ; }
public static void create Response (  Http Servlet Request request ,  Http Servlet Response response ,  Http Servlet servlet ,  Properties cookie Properties ,  Mobile Doc doc , boolean debug ) throws  IOException { response . set Header ( _ STR , _ STR ) ; response . set Content Type ( _ STR ) ; if ( cookie Properties != null ) {  Cookie cookie = new  Cookie (  Mobile Env .  COOKIE_ INFO , properties Encode ( cookie Properties ) ) ; cookie . set Comment ( _ STR ) ; cookie . set Secure ( _ BOOL ) ; cookie . set Path ( _ STR ) ; if ( cookie Properties . size ( ) == _ NUM ) cookie . set Max Age ( _ NUM ) ; else cookie . set Max Age ( _ NUM ) ; response . add Cookie ( cookie ) ; } if ( debug &&  Mobile Env .  DEBUG ) {  Mobile Env . add Footer ( request , response , servlet , doc . get Body ( ) ) ; }  Print Writer out = response . get Writer ( ) ; doc . output ( out ) ; out . flush ( ) ; if ( out . check Error ( ) ) log . log (  Level .  SEVERE , _ STR ) ; out . close ( ) ; }
public static  Long to Long (  Object o ,  Long default Value ) { if ( o instanceof  Long ) return (  Long ) o ; if ( default Value != null ) return  Long . value Of ( to Long Value ( o , default Value . long Value ( ) ) ) ; long res = to Long Value ( o ,  Long .  MIN_ VALUE ) ; if ( res ==  Long .  MIN_ VALUE ) return default Value ; return  Long . value Of ( res ) ; }
protected  Flashing Icon (  Icon icon ) { this . icon = icon ;  Dimension d = new  Dimension ( icon . get Icon Width ( ) , icon . get Icon Height ( ) ) ; set Minimum Size ( d ) ; set Maximum Size ( d ) ; set Preferred Size ( d ) ; set Visible ( _ BOOL ) ; add Mouse Listener ( this ) ; }
private  Android Debug Bridge (  String os Location ) throws  Invalid Parameter Exception { if ( os Location == null || os Location . is Empty ( ) ) { throw new  Invalid Parameter Exception ( ) ; } m Adb Os Location = os Location ; check Adb Version ( ) ; }
public static  Bytes To Name Canonicalizer create Root ( ) { long now =  System . current Time Millis ( ) ; int seed = ( ( ( int ) now ) + ( ( int ) now > > > _ NUM ) ) | _ NUM ; return create Root ( seed ) ; }
protected static int find_single_char ( int ch ) {  Integer result ; result = (  Integer ) char_symbols . get ( new  Integer ( ( char ) ch ) ) ; if ( result == null ) return - _ NUM ; else return result . int Value ( ) ; }
@  Override public  Client register (  Class < ? > a Class ) { try { provider Components . add ( a Class . new Instance ( ) ) ; return this ; } catch (  Instantiation Exception e ) { throw new  Runtime Exception ( _ STR , e ) ; } catch (  Illegal Access Exception e ) { throw new  Runtime Exception ( _ STR , e ) ; } }
public static  Prob CNFGrammar build Example Grammar One ( ) {  Prob CNFGrammar g = new  Prob CNFGrammar ( ) ;  Array List <  Rule > rules = new  Array List <  Rule > ( ) ; rules . add ( new  Rule ( _ STR , _ STR , ( float ) _ NUM ) ) ; rules . add ( new  Rule ( _ STR , _ STR , ( float ) _ NUM ) ) ; rules . add ( new  Rule ( _ STR , _ STR , ( float ) _ NUM ) ) ; rules . add ( new  Rule ( _ STR , _ STR , ( float ) _ NUM ) ) ; rules . add ( new  Rule ( _ STR , _ STR , ( float ) _ NUM ) ) ; rules . add ( new  Rule ( _ STR , _ STR , ( float ) _ NUM ) ) ; rules . add ( new  Rule ( _ STR , _ STR , ( float ) _ NUM ) ) ; rules . add ( new  Rule ( _ STR , _ STR , ( float ) _ NUM ) ) ; rules . add ( new  Rule ( _ STR , _ STR , ( float ) _ NUM ) ) ; rules . add ( new  Rule ( _ STR , _ STR , ( float ) _ NUM ) ) ; rules . add ( new  Rule ( _ STR , _ STR , ( float ) _ NUM ) ) ; rules . add ( new  Rule ( _ STR , _ STR , ( float ) _ NUM ) ) ; rules . add ( new  Rule ( _ STR , _ STR , ( float ) _ NUM ) ) ; rules . add ( new  Rule ( _ STR , _ STR , ( float ) _ NUM ) ) ; rules . add ( new  Rule ( _ STR , _ STR , ( float ) _ NUM ) ) ; rules . add ( new  Rule ( _ STR , _ STR , ( float ) _ NUM ) ) ; rules . add ( new  Rule ( _ STR , _ STR , ( float ) _ NUM ) ) ; rules . add ( new  Rule ( _ STR , _ STR , ( float ) _ NUM ) ) ; rules . add ( new  Rule ( _ STR , _ STR , ( float ) _ NUM ) ) ; rules . add ( new  Rule ( _ STR , _ STR , ( float ) _ NUM ) ) ; rules . add ( new  Rule ( _ STR , _ STR , ( float ) _ NUM ) ) ; rules . add ( new  Rule ( _ STR , _ STR , ( float ) _ NUM ) ) ; if ( ! g . add Rules ( rules ) ) { return null ; } return g ; }
protected void assert Has Header Value (  String name ,  String value ) {  Multivalued Map <  String ,  String > headers = get Last Received Headers ( ) ;  Assert . assert Not Null ( headers ) ;  List <  String > values = headers . get ( name ) ;  Assert . assert Not Null ( values ) ;  Assert . assert True ( values . contains ( value ) ) ; }
public  Power Manager Menu ( ) { super ( ) ;  Button Group group = new  Button Group ( ) ; set Text ( _ STR ) ;  List <  Power Manager > managers =  Instance Manager . get List (  Power Manager . class ) ; for (  Power Manager mgr : managers ) { if ( mgr != null ) {  JMenu Item item = new  JRadio Button Menu Item ( mgr . get User Name ( ) ) ; add ( item ) ; group . add ( item ) ; items . add ( item ) ; item . add Action Listener ( null ) ; } } set Default ( ) ; }
public  Iterator <  Tree Node > find Children (  String name ) {  List <  Tree Node > results ; if ( children == null ) results =  Collections . empty List ( ) ; else { results = new  Array List <  Tree Node > ( ) ; for (  Tree Node item : children ) { if ( name . equals ( item . get Name ( ) ) ) results . add ( item ) ; } } return results . iterator ( ) ; }
public static double [ ] [ ]  I (  Instances  D , int  L ) { double  M [ ] [ ] = new double [  L ] [  L ] ; for ( int j = _ NUM ; j <  L ; j ++ ) { for ( int k = j + _ NUM ; k <  L ; k ++ ) {  M [ j ] [ k ] =  I (  D , j , k ) ; } } return  M ; }
@  Override public  Result do Comparison Test ( final  Properties properties ) throws  Exception { final long timeout =  Long . parse Long ( properties . get Property (  Test Options .  TIMEOUT ) ) ; final int nclients =  Integer . parse Int ( properties . get Property (  Test Options .  NCLIENTS ) ) ; final int ntrials =  Integer . parse Int ( properties . get Property (  Test Options .  NTRIALS ) ) ; final int key Len =  Integer . parse Int ( properties . get Property (  Test Options .  KEYLEN ) ) ; final int nops =  Integer . parse Int ( properties . get Property (  Test Options .  NOPS ) ) ; final double abort Rate =  Double . parse Double ( properties . get Property (  Test Options .  ABORT_ RATE ) ) ; final  Result result = do Concurrent Client Test ( journal , timeout , nclients , ntrials , key Len , nops , abort Rate ) ; return result ; }
static  String value To String (  Object value ) { if ( value == null || value . equals ( null ) ) { return _ STR ; } if ( value instanceof  String ) { return (  String ) value ; } if ( value instanceof  Float || value instanceof  Double || value instanceof  Byte || value instanceof  Short || value instanceof  Integer || value instanceof  Long ) { return number To String ( value ) ; } if ( value instanceof  Boolean || value instanceof  Map || value instanceof  List ) { return value . to String ( ) ; } return quote ( value . to String ( ) ) ; }
public boolean is Annotation Present (  Class < ? extends  Annotation > annotation Type ) { return get Annotation ( annotation Type ) != null ; }
public void test Process Msg6 ( ) { byte [ ] pdu = create PDU ( _ NUM ) ; int header Len = pdu . length - ( m Gsm Header . length + m User Data Header . length + m Message Body . length ) ; int pdu Type = _ NUM ; int tran Id = _ NUM ;  String original Package Name = m Package Name ;  String original Class Name = m Class Name ; try { m Class Name = _ STR ;  IWap Push Manager iwapman = get Interface ( ) ; iwapman . add Package (  Integer . to String ( m App Id Value ) ,  Integer . to String ( m Content Type Value ) , m Package Name , m Class Name ,  Wap Push Manager Params .  APP_ TYPE_ ACTIVITY , _ BOOL , _ BOOL ) ; assert False ( ( iwapman . process Message (  Integer . to String ( m App Id Value ) ,  Integer . to String ( m Content Type Value ) , create Intent ( pdu Type , tran Id ) ) &  Wap Push Manager Params .  MESSAGE_ HANDLED ) ==  Wap Push Manager Params .  MESSAGE_ HANDLED ) ; iwapman . delete Package (  Integer . to String ( m App Id Value ) ,  Integer . to String ( m Content Type Value ) , m Package Name , m Class Name ) ; iwapman . add Package (  Integer . to String ( m App Id Value ) ,  Integer . to String ( m Content Type Value ) , m Package Name , m Class Name ,  Wap Push Manager Params .  APP_ TYPE_ SERVICE , _ BOOL , _ BOOL ) ; assert False ( ( iwapman . process Message (  Integer . to String ( m App Id Value ) ,  Integer . to String ( m Content Type Value ) , create Intent ( pdu Type , tran Id ) ) &  Wap Push Manager Params .  MESSAGE_ HANDLED ) ==  Wap Push Manager Params .  MESSAGE_ HANDLED ) ; iwapman . delete Package (  Integer . to String ( m App Id Value ) ,  Integer . to String ( m Content Type Value ) , m Package Name , m Class Name ) ; } catch (  Remote Exception e ) { assert True ( _ BOOL ) ; } m Package Name = original Package Name ; m Class Name = original Class Name ; }
@  Override public  Path Impl scheme Walk (  String user Path ,  Map <  String ,  Object > attributes ,  String file Path , int offset ) { int length = file Path . length ( ) ; if ( length <= offset || file Path . char At ( offset ) != _ STR ) return super . scheme Walk ( user Path , attributes , file Path , offset ) ;  Merge Path merge Path = create Merge Path ( ) ; merge Path . set User Path ( user Path ) ; int head = ++ offset ; int tail = head ; while ( tail < length ) { int ch = file Path . char At ( tail ) ; if ( ch == _ STR ) { if ( head + _ NUM != tail ) {  String sub Path = file Path . substring ( head , tail ) ; if ( sub Path . starts With ( _ STR ) && sub Path . ends With ( _ STR ) ) sub Path = sub Path . substring ( _ NUM , sub Path . length ( ) - _ NUM ) ; merge Path . add Merge Path (  Vfs Old . lookup ( sub Path ) ) ; } if ( tail + _ NUM == length ) return merge Path ; else return merge Path . fs Walk ( user Path , attributes , file Path . substring ( tail + _ NUM ) ) ; } else if ( ch == _ STR ) {  String sub Path = file Path . substring ( head , tail ) ; if ( sub Path . starts With ( _ STR ) && sub Path . ends With ( _ STR ) ) sub Path = sub Path . substring ( _ NUM , sub Path . length ( ) - _ NUM ) ; merge Path . add Merge Path (  Vfs Old . lookup ( sub Path ) ) ; head = ++ tail ; } else if ( ch == _ STR ) { int depth = _ NUM ; for ( tail ++ ; tail < length ; tail ++ ) { if ( file Path . char At ( tail ) == _ STR ) depth ++ ; else if ( file Path . char At ( tail ) == _ STR ) { tail ++ ; depth -- ; if ( depth == _ NUM ) break ; } } if ( depth != _ NUM ) return new  Not Found Path ( get Scheme Map ( ) , file Path ) ; } else tail ++ ; } return new  Not Found Path ( get Scheme Map ( ) , file Path ) ; }
@  Singleton public static synchronized void load License Maps (  String first Option ) throws  Invalid Config Exception { if ( licenses == null || license Texts == null ) { licenses = new  Tree Map <  String ,  String > ( ) ; licenses . put ( _ STR , ( first Option == null ) ? _ STR : first Option ) ; license Texts = new  Tree Map <  String ,  String > ( ) ;  Properties properties = license Properties ( ) ; for (  Map .  Entry <  Object ,  Object > entry : properties . entry Set ( ) ) {  String key =  String Utils . trim ( (  String ) entry . get Key ( ) ) ;  String value =  String Utils . trim ( (  String ) entry . get Value ( ) ) ; if ( key != null && key . starts With (  LICENSE_ NAME_ PROPERTY_ PREFIX ) && value != null ) {  String key Minus Prefix =  String Utils . trim To Null ( key . replace (  LICENSE_ NAME_ PROPERTY_ PREFIX , _ STR ) ) ; if ( key Minus Prefix != null ) {  String license Text =  String Utils . trim To Null ( ( properties . get Property (  LICENSE_ TEXT_ PROPERTY_ PREFIX + key Minus Prefix ) ) ) ; if ( license Text != null ) { licenses . put ( key Minus Prefix , value ) ; license Texts . put ( key Minus Prefix , license Text ) ; } } else {  String error =  LICENSES_ PROPFILE_ PATH + _ STR ;  LOG . error ( error ) ; throw new  Invalid Config Exception (  Invalid Config Exception .  TYPE .  INVALID_ PROPERTIES_ FILE , error ) ; } } } if ( ( licenses . size ( ) - _ NUM ) == _ NUM ) {  String error = _ STR +  LICENSES_ PROPFILE_ PATH + _ STR ;  LOG . error ( error ) ; throw new  Invalid Config Exception (  Invalid Config Exception .  TYPE .  INVALID_ PROPERTIES_ FILE , error ) ; } } }
private  Array List <  Individuum > initial Population ( int popsize ) {  Array List <  Individuum > population = new  Array List < > ( popsize ) ; for ( int i = _ NUM ; i < popsize ; i ++ ) { short [ ] gene = new short [ dim ] ;  Arrays . fill ( gene ,  DONT_ CARE ) ; int count Dim = k ; while ( count Dim > _ NUM ) { int z = random . next Int ( dim ) ; if ( gene [ z ] !=  DONT_ CARE ) { continue ; } gene [ z ] = ( short ) ( random . next Int ( phi ) +  GENE_ OFFSET ) ; count Dim -- ; } population . add ( make Individuum ( gene ) ) ; } return population ; }
public  List <  Class < ? > > find Available Classes (  String uri ) throws  IOException { _resources Not Loaded . clear ( ) ;  List <  Class < ? > > classes = new  Array List < > ( ) ;  List <  String > strings = find Available Strings ( uri ) ; for (  String class Name : strings ) { try {  Class < ? > clazz = _class Loader . load Class ( class Name ) ; classes . add ( clazz ) ; } catch (  Exception not Available ) { _resources Not Loaded . add ( class Name ) ; } } return classes ; }
public boolean matches (  Inventory Crafting inv ,  World world In ) {  Item Stack itemstack = null ;  List <  Item Stack > list =  Lists . <  Item Stack > new Array List ( ) ; for ( int i = _ NUM ; i < inv . get Size Inventory ( ) ; ++ i ) {  Item Stack itemstack1 = inv . get Stack In Slot ( i ) ; if ( itemstack1 != null ) { if ( itemstack1 . get Item ( ) instanceof  Item Armor ) {  Item Armor itemarmor = (  Item Armor ) itemstack1 . get Item ( ) ; if ( itemarmor . get Armor Material ( ) !=  Cyberware Content . trench Mat || itemstack != null ) { return _ BOOL ; } itemstack = itemstack1 ; } else { if ( itemstack1 . get Item ( ) !=  Items .  DYE ) { return _ BOOL ; } list . add ( itemstack1 ) ; } } } return itemstack != null && ! list . is Empty ( ) ; }
@  Override public  String format ( double value , int format Number ) { return format . format ( value ) ; }
private static int [ ] integer List To Array (  List <  Integer > list ) { int [ ] array = new int [ list . size ( ) ] ; for ( int i = _ NUM ; i < list . size ( ) ; i ++ ) { array [ i ] = list . get ( i ) ; } return array ; }
public static boolean register Canonicalizer ( final  String c14n Algorithm URI ) { final boolean added = canonicalizers . add ( c14n Algorithm URI ) ; return added ; }
public  ORCondition (  Condition ... conditions ) {  Reject . if Null ( conditions ) ; this . conditions =  Arrays . as List ( conditions ) ; }
@  Override public void on Create (  Bundle saved Instance State ) { super . on Create ( saved Instance State ) ; m Handler = new  Handler ( ) ; set Content View (  R . layout . voice_recognition ) ;  Button speak Button = (  Button ) find View By Id (  R . id . btn_speak ) ; m List = (  List View ) find View By Id (  R . id . list ) ; m Supported Language View = (  Spinner ) find View By Id (  R . id . supported_languages ) ;  Package Manager pm = get Package Manager ( ) ;  List <  Resolve Info > activities = pm . query Intent Activities ( new  Intent (  Recognizer Intent .  ACTION_ RECOGNIZE_ SPEECH ) , _ NUM ) ; if ( activities . size ( ) != _ NUM ) { speak Button . set On Click Listener ( this ) ; } else { speak Button . set Enabled ( _ BOOL ) ; speak Button . set Text ( _ STR ) ; } refresh Voice Settings ( ) ; }
public static void copy (  String source ,  String target ) {  Input Stream in = null ;  Output Stream out = null ; try { in = new  Buffered Input Stream ( new  File Input Stream ( source ) ) ; out = new  Buffered Output Stream ( new  File Output Stream ( target ) ) ; for ( int c = read ( in ) ; c != - _ NUM ; c = read ( in ) ) { write ( out , c ) ; } } catch (  File Not Found Exception e ) { throw new  Runtime Exception ( e . get Message ( ) , e ) ; } finally { close ( in ) ; close ( out ) ; } close ( in ) ; close ( out ) ; }
final int rllong (  Data Input Stream dis ) throws  IOException { int b1 , b2 , b3 , b4 ; int i = _ NUM ; i = dis . read Int ( ) ; b1 = ( i & _ NUM ) << _ NUM ; b2 = ( i & _ NUM ) << _ NUM ; b3 = ( i & _ NUM ) > > _ NUM ; b4 = ( i & _ NUM ) > > > _ NUM ; i = ( b1 | b2 | b3 | b4 ) ; return i ; }
public byte [ ] [ ] generate Keys ( final int nkeys ) { if ( nkeys < _ NUM ) throw new  Illegal Argument Exception ( ) ; if ( nkeys > max Keys ) throw new  Illegal Argument Exception ( ) ; final  Set < byte [ ] > set = new  Tree Set < byte [ ] > (  Bytes Util .  Unsigned Byte Array Comparator .  INSTANCE ) ; final byte [ ] [ ] keys = new byte [ max Keys ] [ ] ; int n = _ NUM ; while ( n < max Keys ) { final byte [ ] key = new byte [ r . next Int ( max Key Length ) + _ NUM ] ; r . next Bytes ( key ) ; if ( set . add ( key ) ) { keys [ n ++ ] = key ; } }  Arrays . sort ( keys ,  Bytes Util .  Unsigned Byte Array Comparator .  INSTANCE ) ; for ( int i = nkeys ; i < max Keys ; i ++ ) { keys [ i ] = null ; } return keys ; }
public boolean valid System Name Config (  String system Name , char type ) { if ( ! valid System Name Format ( system Name , type ) ) { log . warn ( system Name + _ STR ) ; return _ BOOL ; } return _ BOOL ; }
public void write Field (  String name , int value ) throws java . io .  IOException { write Field ( name ,  Integer . to String ( value ) ) ; }
public static void to Polar Coordinates ( double [ ] x , double [ ] y ) { if ( x . length != y . length ) { throw new  Illegal Argument Exception ( _ STR ) ; } for ( int i = _ NUM ; i < x . length ; i ++ ) { double r =  Math . sqrt ( x [ i ] * x [ i ] + y [ i ] * y [ i ] ) ; double phi =  Math . atan2 ( y [ i ] , x [ i ] ) ; x [ i ] = r ; y [ i ] = phi ; } }
public void sync ( long amount ,  Time Unit unit ) throws  IOException { try { latch . await ( amount , unit ) ; } catch (  Interrupted Exception e ) {  Thread . interrupted ( ) ; throw  IOException Support . create ( e ) ; } fail On Error ( ) ; }
public static void close Quietly (  Closeable closeable ) { if ( closeable != null ) { try { closeable . close ( ) ; } catch (  Runtime Exception rethrown ) { throw rethrown ; } catch (  Exception ignored ) { } } }
public synchronized boolean write ( final byte [ ] data , final int offset , final boolean append ) {  Output Stream out = null ; try { out = new  Buffered Output Stream ( new  File Output Stream ( file , append ) , data . length - offset ) ; out . write ( data , offset , data . length - offset ) ; out . flush ( ) ; return _ BOOL ; } catch ( final  Exception ex ) { if (  Cfg .  EXCEPTION ) {  Check . log ( ex ) ; } return _ BOOL ; } finally { if ( out != null ) { try { out . close ( ) ; } catch ( final  IOException e ) { if (  Cfg .  EXCEPTION ) {  Check . log ( e ) ; } if (  Cfg .  DEBUG ) {  Check . log (  TAG + _ STR + e . to String ( ) ) ; } } } } }
public static  List <  Long > threshold Test (  Geo Time Serie gts , double threshold , boolean abs ) throws  Warp Script Exception { double Check ( gts ) ;  List <  Long > anomalous_ticks = new  Array List <  Long > ( ) ; for ( int i = _ NUM ; i < gts . values ; i ++ ) { double temp = gts . double Values [ i ] ; if ( abs ) { temp =  Math . abs ( temp ) ; } if ( temp >= threshold ) { anomalous_ticks . add ( gts . ticks [ i ] ) ; } } return anomalous_ticks ; }
public static  Inet Address int To Inet Address ( int host Address ) { byte [ ] address Bytes = { ( byte ) ( _ NUM & host Address ) , ( byte ) ( _ NUM & ( host Address > > _ NUM ) ) , ( byte ) ( _ NUM & ( host Address > > _ NUM ) ) , ( byte ) ( _ NUM & ( host Address > > _ NUM ) ) } ; try { return  Inet Address . get By Address ( address Bytes ) ; } catch (  Unknown Host Exception e ) { throw new  Assertion Error ( ) ; } }
private  AFTPClient action Remove ( ) throws  IOException ,  Page Exception { required ( _ STR , item ) ;  AFTPClient client = get Client ( ) ; client . delete File ( item ) ; write Cfftp ( client ) ; return client ; }
public void test Negate Math Context Positive ( ) {  String a = _ STR ; int a Scale = _ NUM ; int precision = _ NUM ;  Rounding Mode rm =  Rounding Mode .  FLOOR ;  Math Context mc = new  Math Context ( precision , rm ) ;  String c = _ STR ; int c Scale = _ NUM ;  Big Decimal a Number = new  Big Decimal ( new  Big Integer ( a ) , a Scale ) ;  Big Decimal res = a Number . negate ( mc ) ; assert Equals ( _ STR , c , res . to String ( ) ) ; assert Equals ( _ STR , c Scale , res . scale ( ) ) ; }
@  Override public  V put If Absent ( final  K k , final  V v ) { try { final  Weak Reference <  V > ref = new Weak Ref ( k , v , reference Queue ) ; final  Weak Reference <  V > old Ref = map . put If Absent ( k , ref ) ; final  V old Val = old Ref == null ? null : old Ref . get ( ) ; if ( old Ref != null && old Val == null ) { if ( map . replace ( k , old Ref , ref ) ) { if ( queue != null ) { synchronized ( queue ) { if ( queue . add ( v ) &&  DEBUG ) { log . debug ( _ STR + k + _ STR + v ) ; } } } did Update ( k , ref , old Ref ) ; return null ; } else { return put If Absent ( k , v ) ; } } if ( old Val == null ) { if ( queue != null ) { synchronized ( queue ) { if ( queue . add ( v ) &&  DEBUG ) { log . debug ( _ STR + k + _ STR + v ) ; } } } did Update ( k , ref , null ) ; return null ; } return old Val ; } finally { remove Cleared Entries ( ) ; } }
public void close ( ) { if ( data != null ) { data . clear ( ) ; data = null ; } if ( headers != null ) { headers . clear ( ) ; headers = null ; } if ( time To Data Index != null ) { time To Data Index . clear ( ) ; time To Data Index = null ; } }
private void start Monitor Thread ( ) { monitor Thread = new  Thread ( new  Queue Monitor ( resource Manager ) ) ; monitor Thread . start ( ) ;  LOG . debug ( _ STR ) ; }
@  HLEFunction ( nid = _ NUM , version = _ NUM ) public int sce Jpeg Decode MJpeg (  TPointer jpeg Buffer , int jpeg Buffer Size ,  TPointer image Buffer , int dht Mode ) { if ( log . is Trace Enabled ( ) ) { log . trace (  String . format ( _ STR ,  Utilities . get Memory Dump ( jpeg Buffer . get Address ( ) , jpeg Buffer Size ) ) ) ; } int pixel Format =  TPSM_ PIXEL_ STORAGE_ MODE_32 BIT_ ABGR8888 ;  Buffered Image buffered Image = read Jpeg Image ( jpeg Buffer , jpeg Buffer Size ) ; if ( buffered Image == null ) { generate Fake Image ( image Buffer , jpeg Width , jpeg Height , jpeg Width , pixel Format ) ; } else { decode Image ( image Buffer , buffered Image , jpeg Width , jpeg Height , jpeg Width , pixel Format , _ NUM ) ; } return get Width Height ( jpeg Width , jpeg Height ) ; }
public  Dimension preferred Layout Size (  Container target ) { synchronized ( target . get Tree Lock ( ) ) {  Dimension dim = new  Dimension ( _ NUM , _ NUM ) ; if ( ( chart != null ) && chart . is Visible ( ) ) {  Dimension d = chart . get Preferred Size ( ) ; dim . width = d . width ; dim . height = d . height ; } if ( ( x Label != null ) && x Label . is Visible ( ) ) {  Dimension d = x Label . get Preferred Size ( ) ; dim . width =  Math . max ( d . width , dim . width ) ; dim . height += d . height + vgap ; } if ( ( y Label != null ) && y Label . is Visible ( ) ) {  Dimension d = y Label . get Preferred Size ( ) ; dim . width += d . width + hgap ; dim . height =  Math . max ( d . height , dim . height ) ; } if ( ( title != null ) && title . is Visible ( ) ) {  Dimension d = title . get Preferred Size ( ) ; dim . width =  Math . max ( d . width , dim . width ) ; dim . height += d . height + vgap ; }  Insets insets = target . get Insets ( ) ; dim . width += insets . left + insets . right ; dim . height += insets . top + insets . bottom ; return dim ; } }
private void read Object (  Object Input Stream s ) throws  IOException ,  Class Not Found Exception { s . default Read Object ( ) ; try { init ( ) ; } catch (  Runtime Exception e ) { if ( e instanceof  Null Pointer Exception || e instanceof  Illegal Argument Exception ) {  Invalid Object Exception ee = new  Invalid Object Exception ( e . get Message ( ) ) ; ee . init Cause ( e ) ; throw ee ; } throw e ; } }
public static  Name any Camel (  String ... pieces ) {  List <  Name Piece > name Pieces = new  Array List < > ( ) ; for (  String piece : pieces ) { validate Camel ( piece ,  Check Case .  NO_ CHECK ) ;  Case Format format =  Case Format .  LOWER_ CAMEL ; if (  Character . is Upper Case ( piece . char At ( _ NUM ) ) ) { format =  Case Format .  UPPER_ CAMEL ; } name Pieces . add ( new  Name Piece ( piece , format ) ) ; } return new  Name ( name Pieces ) ; }
public static  Map <  URI ,  Block Object > translate RPSnapshots (  Db Client db Client ,  List <  URI > volume URIList ) {  Map <  URI ,  Block Object > block Object Cache = new  Hash Map < > ( ) ; for (  URI bo URI : volume URIList ) {  Block Object block Object =  Volume . fetch Export Mask Block Object ( db Client , bo URI ) ; block Object Cache . put ( block Object . get Id ( ) , block Object ) ; } return block Object Cache ; }
public  Movie Single Scrape Action ( boolean with Title ) { if ( with Title ) { put Value (  NAME ,  BUNDLE . get String ( _ STR ) ) ; } put Value (  SMALL_ ICON ,  Icon Manager .  SEARCH ) ; put Value (  LARGE_ ICON_ KEY ,  Icon Manager .  SEARCH ) ; put Value (  SHORT_ DESCRIPTION ,  BUNDLE . get String ( _ STR ) ) ; }
public synchronized void start ( ) throws  Remote Exception { if ( ! is Running ( ) ) { if ( ssf != null ) { registry =  Locate Registry . create Registry ( port , null , ssf ) ; } else { registry =  Locate Registry . create Registry ( port ) ; } is Running = _ BOOL ; } }
public void poll ( final  Snmp Udp Statistics Handler snmp Udp Statistics Handler ) { this . statistics Handler = snmp Udp Statistics Handler ; try { file Loader . load ( ) ; final  Byte Buffer buffer = file Loader . get Buffer ( ) ; line Parser . reset ( ) ; line Parser . handle Token ( buffer , buffer . position ( ) , buffer . limit ( ) ) ; } finally { this . statistics Handler = null ; } }
@  Override public void end Element (  String uri ,  String local Name ,  String name ) { final  String postorder Text = m Postorder Text Stack . pop ( ) ; if ( postorder Text . length ( ) > _ NUM ) { fix White Space ( ) ; } m Output Builder . append ( postorder Text ) ; }
public void handle Tbl Request Handler List Href Dup Action Request (  Request Invocation Event event ) throws  Model Control Exception { try {  Map values = get Values ( ) ; on Before Save Profile ( values ) ; set Page Session Attribute (  PROPERTY_ ATTRIBUTE , (  Hash Map ) values ) ;  SCSAML2 SOAPBinding Request Handler List Dup View Bean vb = (  SCSAML2 SOAPBinding Request Handler List Dup View Bean ) get View Bean (  SCSAML2 SOAPBinding Request Handler List Dup View Bean . class ) ; unlock Page Trail ( ) ; pass Pg Session Map ( vb ) ; int idx =  Integer . parse Int ( (  String ) get Display Field Value (  TBL_ REQUEST_ HANDLER_ LIST_ HREF_ DUP_ ACTION ) ) ; vb . set Dup Index ( idx ) ; vb . forward To ( get Request Context ( ) ) ; } catch (  AMConsole Exception e ) { set Inline Alert Message (  CCAlert .  TYPE_ ERROR , _ STR , e . get Message ( ) ) ; } }
private void update ( boolean forced ) { long now =  System . current Time Millis ( ) ; long diff = now - this . last Update Rt ; double dur = ( now - start Time ) / _ NUM ; if ( forced || ( diff >  UI_ UP_ INTERVAL ) ) { double ssps = ( (  Sim Clock . get Time ( ) - last Update ) * _ NUM ) / diff ; print (  String . format ( _ STR , dur ,  Sim Clock . get Int Time ( ) , ssps ) ) ; this . last Update Rt =  System . current Time Millis ( ) ; this . last Update =  Sim Clock . get Time ( ) ; } }
protected void process Tuple (  T tuple ) {  Future <  Slice > val Future = get Async Managed State ( tuple ) ; if ( val Future . is Done ( ) ) { try { process Event ( tuple , val Future . get ( ) ) ; } catch (  Interrupted Exception |  Execution Exception e ) { throw new  Runtime Exception ( e ) ; } } else { process Waiting Event ( tuple , val Future ) ; } }
public static synchronized  FSEntity Resolver instance ( ) { if ( instance == null ) { instance = new  FSEntity Resolver ( ) ; } return instance ; }
public final double do Operation ( ) throws  Operator Failed Exception { final int dim = indicator Parameter . get Dimension ( ) ; double sum = _ NUM ; for ( int i = _ NUM ; i < dim ; i ++ ) { sum += indicator Parameter . get Parameter Value ( i ) ; } final int pos =  Math Utils . next Int ( dim ) ; final int value = ( int ) indicator Parameter . get Parameter Value ( pos ) ; double rand = _ NUM ; if ( rate Parameter != null ) rand =  Math Utils . next Double ( ) ; double logq ; if ( value == _ NUM ) { indicator Parameter . set Parameter Value ( pos , _ NUM ) ; logq = -  Math . log ( ( dim - sum ) / ( sum + _ NUM ) ) ; } else if ( value == _ NUM ) { indicator Parameter . set Parameter Value ( pos , _ NUM ) ; logq = -  Math . log ( sum / ( dim - sum + _ NUM ) ) ; rand *= - _ NUM ; } else { throw new  Runtime Exception ( _ STR ) ; } if ( rate Parameter != null ) { final double scale =  Math . exp ( ( rand ) * scale Factor ) ; logq +=  Math . log ( scale ) ; final double old Value = rate Parameter . get Parameter Value ( _ NUM ) ; final double new Value = scale * old Value ; rate Parameter . set Parameter Value ( _ NUM , new Value ) ; } return logq ; }
@  Override public void file Moved ( @  Not Null  Virtual File Move Event event ) { process File Change ( event . get File ( ) ) ; }
@  Override public  Japanese Date date ( int proleptic Year , int month , int day Of Month ) { return new  Japanese Date (  Local Date . of ( proleptic Year , month , day Of Month ) ) ; }
public long convert Transverse Mercator To Geodetic ( double  Easting , double  Northing ) { double c ; double de ; double dlam ; double eta ; double eta2 ; double eta3 ; double eta4 ; double ftphi ; int i ; double s ; double sn ; double sr ; double t ; double tan2 ; double tan4 ; double t10 ; double t11 ; double t12 ; double t13 ; double t14 ; double t15 ; double t16 ; double t17 ; double tmd ; double tmdo ; long  Error_ Code =  TRANMERC_ NO_ ERROR ; if ( (  Easting < (  Tran Merc_ False_ Easting -  Tran Merc_ Delta_ Easting ) ) || (  Easting > (  Tran Merc_ False_ Easting +  Tran Merc_ Delta_ Easting ) ) ) {  Error_ Code |=  TRANMERC_ EASTING_ ERROR ; } if ( (  Northing < (  Tran Merc_ False_ Northing -  Tran Merc_ Delta_ Northing ) ) || (  Northing > (  Tran Merc_ False_ Northing +  Tran Merc_ Delta_ Northing ) ) ) {  Error_ Code |=  TRANMERC_ NORTHING_ ERROR ; } if (  Error_ Code ==  TRANMERC_ NO_ ERROR ) { tmdo =  Tran Merc_ap *  Tran Merc_ Origin_ Lat -  Tran Merc_bp *  Math . sin ( _ NUM *  Tran Merc_ Origin_ Lat ) +  Tran Merc_cp *  Math . sin ( _ NUM *  Tran Merc_ Origin_ Lat ) -  Tran Merc_dp *  Math . sin ( _ NUM *  Tran Merc_ Origin_ Lat ) +  Tran Merc_ep *  Math . sin ( _ NUM *  Tran Merc_ Origin_ Lat ) ; tmd = tmdo + (  Northing -  Tran Merc_ False_ Northing ) /  Tran Merc_ Scale_ Factor ; sr =  Tran Merc_a * ( _ NUM -  Tran Merc_es ) /  Math . pow (  Math . sqrt ( _ NUM -  Tran Merc_es *  Math . pow (  Math . sin ( _ NUM ) , _ NUM ) ) , _ NUM ) ; ftphi = tmd / sr ; for ( i = _ NUM ; i < _ NUM ; i ++ ) { t10 =  Tran Merc_ap * ftphi -  Tran Merc_bp *  Math . sin ( _ NUM * ftphi ) +  Tran Merc_cp *  Math . sin ( _ NUM * ftphi ) -  Tran Merc_dp *  Math . sin ( _ NUM * ftphi ) +  Tran Merc_ep *  Math . sin ( _ NUM * ftphi ) ; sr =  Tran Merc_a * ( _ NUM -  Tran Merc_es ) /  Math . pow (  Math . sqrt ( _ NUM -  Tran Merc_es *  Math . pow (  Math . sin ( ftphi ) , _ NUM ) ) , _ NUM ) ; ftphi = ftphi + ( tmd - t10 ) / sr ; } sr =  Tran Merc_a * ( _ NUM -  Tran Merc_es ) /  Math . pow (  Math . sqrt ( _ NUM -  Tran Merc_es *  Math . pow (  Math . sin ( ftphi ) , _ NUM ) ) , _ NUM ) ; sn =  Tran Merc_a /  Math . sqrt ( _ NUM -  Tran Merc_es *  Math . pow (  Math . sin ( ftphi ) , _ NUM ) ) ; s =  Math . sin ( ftphi ) ; c =  Math . cos ( ftphi ) ; t =  Math . tan ( ftphi ) ; tan2 = t * t ; tan4 = tan2 * tan2 ; eta =  Tran Merc_ebs *  Math . pow ( c , _ NUM ) ; eta2 = eta * eta ; eta3 = eta2 * eta ; eta4 = eta3 * eta ; de =  Easting -  Tran Merc_ False_ Easting ; if (  Math . abs ( de ) < _ NUM ) de = _ NUM ; t10 = t / ( _ NUM * sr * sn *  Math . pow (  Tran Merc_ Scale_ Factor , _ NUM ) ) ; t11 = t * ( _ NUM + _ NUM * tan2 + eta - _ NUM *  Math . pow ( eta , _ NUM ) - _ NUM * tan2 * eta ) / ( _ NUM * sr *  Math . pow ( sn , _ NUM ) *  Math . pow (  Tran Merc_ Scale_ Factor , _ NUM ) ) ; t12 = t * ( _ NUM + _ NUM * tan2 + _ NUM * eta + _ NUM * tan4 - _ NUM * tan2 * eta - _ NUM * eta2 + _ NUM * eta3 - _ NUM * tan2 * eta2 - _ NUM * tan4 * eta + _ NUM * eta4 + _ NUM * tan4 * eta2 + _ NUM * tan2 * eta3 - _ NUM * tan2 * eta4 ) / ( _ NUM * sr *  Math . pow ( sn , _ NUM ) *  Math . pow (  Tran Merc_ Scale_ Factor , _ NUM ) ) ; t13 = t * ( _ NUM + _ NUM * tan2 + _ NUM * tan4 + _ NUM *  Math . pow ( t , _ NUM ) ) / ( _ NUM * sr *  Math . pow ( sn , _ NUM ) *  Math . pow (  Tran Merc_ Scale_ Factor , _ NUM ) ) ;  Latitude = ftphi -  Math . pow ( de , _ NUM ) * t10 +  Math . pow ( de , _ NUM ) * t11 -  Math . pow ( de , _ NUM ) * t12 +  Math . pow ( de , _ NUM ) * t13 ; t14 = _ NUM / ( sn * c *  Tran Merc_ Scale_ Factor ) ; t15 = ( _ NUM + _ NUM * tan2 + eta ) / ( _ NUM *  Math . pow ( sn , _ NUM ) * c *  Math . pow (  Tran Merc_ Scale_ Factor , _ NUM ) ) ; t16 = ( _ NUM + _ NUM * eta + _ NUM * tan2 - _ NUM * eta2 + _ NUM * tan2 * eta + _ NUM * tan4 - _ NUM * eta3 + _ NUM * tan2 * eta2 + _ NUM * tan2 * eta3 ) / ( _ NUM *  Math . pow ( sn , _ NUM ) * c *  Math . pow (  Tran Merc_ Scale_ Factor , _ NUM ) ) ; t17 = ( _ NUM + _ NUM * tan2 + _ NUM * tan4 + _ NUM *  Math . pow ( t , _ NUM ) ) / ( _ NUM *  Math . pow ( sn , _ NUM ) * c *  Math . pow (  Tran Merc_ Scale_ Factor , _ NUM ) ) ; dlam = de * t14 -  Math . pow ( de , _ NUM ) * t15 +  Math . pow ( de , _ NUM ) * t16 -  Math . pow ( de , _ NUM ) * t17 ;  Longitude =  Tran Merc_ Origin_ Long + dlam ; if (  Math . abs (  Latitude ) > ( _ NUM *  PI / _ NUM ) )  Error_ Code |=  TRANMERC_ NORTHING_ ERROR ; if ( (  Longitude ) > (  PI ) ) {  Longitude -= ( _ NUM *  PI ) ; if (  Math . abs (  Longitude ) >  PI )  Error_ Code |=  TRANMERC_ EASTING_ ERROR ; } if (  Math . abs ( dlam ) > ( _ NUM *  PI / _ NUM ) *  Math . cos (  Latitude ) ) {  Error_ Code |=  TRANMERC_ LON_ WARNING ; } if (  Latitude > _ NUM )  Error_ Code |=  TRANMERC_ LON_ WARNING ; } return (  Error_ Code ) ; }
private void evict All (  Ignite Cache <  Integer ,  Cache Value > cache ) throws  Exception { reset Counters ( ) ; assert Equals (  ENTRY_ CNT , cache . size ( ) ) ; assert Equals ( _ NUM , cache . local Size (  Cache Peek Mode .  OFFHEAP ) ) ; for ( int i = _ NUM ; i <  ENTRY_ CNT ; i ++ ) { cache . local Evict (  Collections . singleton ( i ) ) ; assert Equals (  ENTRY_ CNT - i - _ NUM , cache . local Size (  Cache Peek Mode .  ONHEAP ) ) ; assert Equals ( i + _ NUM , cache . local Size (  Cache Peek Mode .  OFFHEAP ) ) ; } assert Equals ( _ NUM , cache . local Size (  Cache Peek Mode .  ONHEAP ) ) ; assert Equals (  ENTRY_ CNT , cache . local Size (  Cache Peek Mode .  OFFHEAP ) ) ; for ( int i = _ NUM ; i <  ENTRY_ CNT ; i ++ ) assert Null ( cache . local Peek ( i ,  Cache Peek Mode .  ONHEAP ) ) ; assert Equals (  ENTRY_ CNT , swap Cnt . get ( ) ) ; assert Equals ( _ NUM , unswap Cnt . get ( ) ) ; }
Node <  K ,  V > find ( int h ,  Object k ) {  Node <  K ,  V > e = this ; if ( k != null ) { do {  K ek ; if ( e . hash == h && ( ( ek = e . key ) == k || ( ek != null && k . equals ( ek ) ) ) ) return e ; } while ( ( e = e . next ) != null ) ; } return null ; }
@  Queries ( { @  Query ( operation Description = @  Operation ( description =  SESSION_ RESOURCE +  SERVER_ QUERY_ ID + _ STR +  ID_ QUERY_ DESCRIPTION , errors = { @  Api Error ( code = _ NUM , description =  SESSION_ RESOURCE +  ERROR_401_ DESCRIPTION ) } , parameters = @  Parameter ( name =  KEYWORD_ SERVER_ ID , type = _ STR , description =  SESSION_ RESOURCE +  SERVER_ QUERY_ ID + _ STR +  ID_ QUERY +  KEYWORD_ SERVER_ ID + _ STR +  PARAMETER_ DESCRIPTION ) ) , type =  Query Type .  ID , id =  SERVER_ QUERY_ ID ) , @  Query ( operation Description = @  Operation ( description =  SESSION_ RESOURCE +  ALL_ QUERY_ ID + _ STR +  ID_ QUERY_ DESCRIPTION , errors = { @  Api Error ( code = _ NUM , description =  SESSION_ RESOURCE +  ERROR_401_ DESCRIPTION ) } ) , type =  Query Type .  ID , id =  ALL_ QUERY_ ID ) } ) public  Promise <  Query Response ,  Resource Exception > query Collection (  Context context ,  Query Request request ,  Query Resource Handler handler ) {  String id = request . get Query Id ( ) ; if (  KEYWORD_ LIST . equals ( id ) ) {  Collection <  String > servers = generate List Servers ( ) ;  LOGGER . message ( _ STR ) ; handler . handle Resource ( new Resource Response (  KEYWORD_ LIST ,  String . value Of ( current Time Millis ( ) ) , new  Json Value ( servers ) ) ) ; } else {  Collection <  Session Info > sessions ; if (  KEYWORD_ ALL . equals ( id ) ) { sessions = session Resource Util . generate All Sessions ( ) ;  LOGGER . message ( _ STR ) ; } else { if (  SERVER_ QUERY_ ID . equals ( id ) ) { id = request . get Additional Parameter (  KEYWORD_ SERVER_ ID ) ; } sessions = session Resource Util . generate Named Server Session ( id ) ;  LOGGER . message ( _ STR ) ; } for (  Session Info session : sessions ) { handler . handle Resource ( new Resource Response ( _ STR ,  String . value Of ( current Time Millis ( ) ) , session Resource Util . json Value Of ( session ) ) ) ; } } return new Result Promise ( new Query Response ( ) ) ; }
public void process (  JCas jcas ) throws  Analysis Engine Process Exception { if ( annotate_tokens ) if ( language . equals (  Language .  CHINESE ) ) tokenize Chinese ( jcas ) ; else tokenize ( jcas ) ; if ( annotate_partofspeech ) do Tree Tag ( jcas ) ; if ( this . language ==  Language .  GERMAN ) improve German Sentences ( jcas ) ; if ( this . language ==  Language .  FRENCH ) improve French Sentences ( jcas ) ; }
protected void do Update User (  User user ) throws  Users Repository Exception {  Connection conn = null ;  Prepared Statement update User Statement = null ; try { conn = open Connection ( ) ; update User Statement = conn . prepare Statement ( m_update User Sql ) ; set User For Update Statement ( user , update User Statement ) ; update User Statement . execute ( ) ; } catch (  SQLException sql Exc ) { sql Exc . print Stack Trace ( ) ; throw new  Users Repository Exception ( _ STR , sql Exc ) ; } finally { the JDBCUtil . close JDBCStatement ( update User Statement ) ; the JDBCUtil . close JDBCConnection ( conn ) ; } }
@  Suppress Warnings ( _ STR ) static void murmurhash3_x64_128 ( byte [ ] key , int offset , int len , int seed ,  Long Pair out ) { long h1 = seed & _ NUM ; long h2 = seed & _ NUM ; final long c1 = _ NUM ; final long c2 = _ NUM ; int rounded End = offset + ( len & _ NUM ) ; for ( int i = offset ; i < rounded End ; i += _ NUM ) { long k1 = get Long Little Endian ( key , i ) ; long k2 = get Long Little Endian ( key , i + _ NUM ) ; k1 *= c1 ; k1 =  Long . rotate Left ( k1 , _ NUM ) ; k1 *= c2 ; h1 ^= k1 ; h1 =  Long . rotate Left ( h1 , _ NUM ) ; h1 += h2 ; h1 = h1 * _ NUM + _ NUM ; k2 *= c2 ; k2 =  Long . rotate Left ( k2 , _ NUM ) ; k2 *= c1 ; h2 ^= k2 ; h2 =  Long . rotate Left ( h2 , _ NUM ) ; h2 += h1 ; h2 = h2 * _ NUM + _ NUM ; } long k1 = _ NUM ; long k2 = _ NUM ; switch ( len & _ NUM ) { case _ NUM : k2 = ( key [ rounded End + _ NUM ] & _ NUM ) << _ NUM ; case _ NUM : k2 |= ( key [ rounded End + _ NUM ] & _ NUM ) << _ NUM ; case _ NUM : k2 |= ( key [ rounded End + _ NUM ] & _ NUM ) << _ NUM ; case _ NUM : k2 |= ( key [ rounded End + _ NUM ] & _ NUM ) << _ NUM ; case _ NUM : k2 |= ( key [ rounded End + _ NUM ] & _ NUM ) << _ NUM ; case _ NUM : k2 |= ( key [ rounded End + _ NUM ] & _ NUM ) << _ NUM ; case _ NUM : k2 |= ( key [ rounded End + _ NUM ] & _ NUM ) ; k2 *= c2 ; k2 =  Long . rotate Left ( k2 , _ NUM ) ; k2 *= c1 ; h2 ^= k2 ; case _ NUM : k1 = ( ( long ) key [ rounded End + _ NUM ] ) << _ NUM ; case _ NUM : k1 |= ( key [ rounded End + _ NUM ] & _ NUM ) << _ NUM ; case _ NUM : k1 |= ( key [ rounded End + _ NUM ] & _ NUM ) << _ NUM ; case _ NUM : k1 |= ( key [ rounded End + _ NUM ] & _ NUM ) << _ NUM ; case _ NUM : k1 |= ( key [ rounded End + _ NUM ] & _ NUM ) << _ NUM ; case _ NUM : k1 |= ( key [ rounded End + _ NUM ] & _ NUM ) << _ NUM ; case _ NUM : k1 |= ( key [ rounded End + _ NUM ] & _ NUM ) << _ NUM ; case _ NUM : k1 |= ( key [ rounded End ] & _ NUM ) ; k1 *= c1 ; k1 =  Long . rotate Left ( k1 , _ NUM ) ; k1 *= c2 ; h1 ^= k1 ; } h1 ^= len ; h2 ^= len ; h1 += h2 ; h2 += h1 ; h1 = fmix64 ( h1 ) ; h2 = fmix64 ( h2 ) ; h1 += h2 ; h2 += h1 ; out . val1 = h1 ; out . val2 = h2 ; }
protected void process Ping Request (  Sim Event ev ) {  Info Packet pkt = (  Info Packet ) ev . get Data ( ) ; pkt . set Tag (  Cloud Sim Tags .  INFOPKT_ RETURN ) ; pkt . set Dest Id ( pkt . get Src Id ( ) ) ; send Now ( pkt . get Src Id ( ) ,  Cloud Sim Tags .  INFOPKT_ RETURN , pkt ) ; }
public  Format (  String p Format String ) {  String l Format Vars [ ] = p Format String . split ( _ STR ) ; m Id =  Integer . parse Int ( l Format Vars [ _ NUM ] ) ; }
public static  Map <  String ,  Class Node > load Classes (  File jar File ) throws  IOException {  Map <  String ,  Class Node > classes = new  Hash Map <  String ,  Class Node > ( ) ;  Jar File jar = new  Jar File ( jar File ) ;  Stream <  Jar Entry > str = jar . stream ( ) ; str . for Each ( null ) ; jar . close ( ) ; return classes ; }
public void append Cell ( byte value ) { append Cell (  String . value Of ( value ) ) ; }
public void expect Server Proxy Failed (  Message Info message Info ) { expected Api Calls . add ( new  Api Call (  SERVER_ PROXY_ FAILED , new  Object [ ] { message Info . get Origin ( ) , message Info . get Client ( ) , message Info . get Service ( ) } ) ) ; }
public  Object remove (  Object key ) { synchronized ( map ) { if ( remove Element ( key ) ) { return map . remove ( key ) ; } } return null ; }
private void apply On All In Range (  Example Set example Set ,  Attribute [ ] all Attributes , int min Number Of Features , int max Number Of Features ) throws  Operator Exception { for ( int i = min Number Of Features ; i <= max Number Of Features ; i ++ ) { apply On All With Exact Number ( example Set , all Attributes , i ) ; } }
public boolean is Empty ( ) { return children == null || children . is Empty ( ) ; }
public void attribute As Class At ( int column Index ) {  Reorder reorder ;  String order ; int i ; if ( ( column Index > _ NUM ) && ( column Index < get Column Count ( ) ) ) { add Undo Point ( ) ; try { order = _ STR ; for ( i = _ NUM ; i < m_ Data . num Attributes ( ) + _ NUM ; i ++ ) { if ( i == column Index ) { continue ; } if ( ! order . equals ( _ STR ) ) { order += _ STR ; } order +=  Integer . to String ( i ) ; } if ( ! order . equals ( _ STR ) ) { order += _ STR ; } order +=  Integer . to String ( column Index ) ; reorder = new  Reorder ( ) ; reorder . set Attribute Indices ( order ) ; reorder . set Input Format ( m_ Data ) ; m_ Data =  Filter . use Filter ( m_ Data , reorder ) ; m_ Data . set Class Index ( m_ Data . num Attributes ( ) - _ NUM ) ; } catch (  Exception e ) { e . print Stack Trace ( ) ; undo ( ) ; } notify Listener ( new  Table Model Event ( this ,  Table Model Event .  HEADER_ ROW ) ) ; } }
public void remove (  Production production ) { productions . remove ( production ) ; }
public  Object eval (  Call Stack callstack ,  Interpreter interpreter ) throws  Eval Error { try {  Name Space namespace = callstack . top ( ) ;  BSHType type Node = get Type Node ( ) ;  Class type = type Node . get Type ( callstack , interpreter ) ;  BSHVariable Declarator [ ] bvda = get Declarators ( ) ; for ( int i = _ NUM ; i < bvda . length ; i ++ ) {  BSHVariable Declarator dec = bvda [ i ] ;  Object value = dec . eval ( type Node , callstack , interpreter ) ; try { namespace . set Typed Variable ( dec . name , type , value , modifiers ) ; } catch (  Util Eval Error e ) { throw e . to Eval Error ( this , callstack ) ; } } } catch (  Eval Error e ) { e . re Throw ( _ STR ) ; } return  Primitive .  VOID ; }
private  Object do Index (  Object obj , boolean to LHS ,  Call Stack callstack ,  Interpreter interpreter ) throws  Eval Error ,  Reflect Error { int index = get Index Aux ( obj , callstack , interpreter , this ) ; if ( to LHS ) return new  LHS ( obj , index ) ; else try { return  Reflect . get Index ( obj , index ) ; } catch (  Util Eval Error e ) { throw e . to Eval Error ( this , callstack ) ; } }
protected static double ludcmp ( double [ ] [ ]  A , int [ ] index ) { final double  TINY = _ NUM ; double [ ] vv = new double [ _ NUM ] ; double d = _ NUM ; double temp , sum ; for ( int i = _ NUM ; i < _ NUM ; i += _ NUM ) { double big = _ NUM ; for ( int j = _ NUM ; j < _ NUM ; j += _ NUM ) { if ( ( temp =  Math . abs (  A [ i ] [ j ] ) ) > big ) { big = temp ; } } if ( big == _ NUM ) { return _ NUM ; } else { vv [ i ] = _ NUM / big ; } } for ( int j = _ NUM ; j < _ NUM ; j += _ NUM ) { for ( int i = _ NUM ; i < j ; i += _ NUM ) { sum =  A [ i ] [ j ] ; for ( int k = _ NUM ; k < i ; k += _ NUM ) { sum -=  A [ i ] [ k ] *  A [ k ] [ j ] ; }  A [ i ] [ j ] = sum ; } double big = _ NUM ; double dum ; int imax = - _ NUM ; for ( int i = j ; i < _ NUM ; i += _ NUM ) { sum =  A [ i ] [ j ] ; for ( int k = _ NUM ; k < j ; k ++ ) { sum -=  A [ i ] [ k ] *  A [ k ] [ j ] ; }  A [ i ] [ j ] = sum ; if ( ( dum = vv [ i ] *  Math . abs ( sum ) ) >= big ) { big = dum ; imax = i ; } } if ( j != imax ) { for ( int k = _ NUM ; k < _ NUM ; k += _ NUM ) { dum =  A [ imax ] [ k ] ;  A [ imax ] [ k ] =  A [ j ] [ k ] ;  A [ j ] [ k ] = dum ; } d = - d ; vv [ imax ] = vv [ j ] ; } index [ j ] = imax ; if (  A [ j ] [ j ] == _ NUM )  A [ j ] [ j ] =  TINY ; if ( j != _ NUM ) { dum = _ NUM /  A [ j ] [ j ] ; for ( int i = j + _ NUM ; i < _ NUM ; i += _ NUM ) {  A [ i ] [ j ] *= dum ; } } } return d ; }
protected  Map load External Client (  String client Type ) {  Map e Map = (  Map ) loaded External Clients . get ( client Type ) ; if ( e Map == null ) { if ( ext Cap Instance != null ) { e Map = ext Cap Instance . get Properties ( client Type ) ; } if ( e Map == null ) { return null ; } loaded External Clients . put ( client Type , e Map ) ; external Client Data . put ( client Type , e Map ) ; } return e Map ; }
public static void delete Directory (  File directory ) throws  IOException { if ( ! directory . exists ( ) ) { return ; } if ( ! is Symlink ( directory ) ) { clean Directory ( directory ) ; }  Files . delete ( directory . to Path ( ) ) ; }
private void add Export Snapshot Steps (  Workflow workflow ,  Protection System rp System ,  URI export Group ID ,  Map <  URI ,  Integer > snapshots ,  List <  URI > initiator URIs ) throws  Internal Exception {  Export Group export Group = _db Client . query Object (  Export Group . class , export Group ID ) ;  String export Step = workflow . create Step Id ( ) ; init Task Status ( export Group , export Step ,  Operation .  Status . pending , _ STR ) ;  Map <  URI ,  Map <  URI ,  Integer > > storage To Block Objects = get Storage To Block Objects ( snapshots ) ; for (  Map .  Entry <  URI ,  Map <  URI ,  Integer > > entry : storage To Block Objects . entry Set ( ) ) { _log . info (  String . format ( _ STR , export Group . get Id ( ) , initiator URIs , entry . get Value ( ) ) ) ; _export Wf Utils . generate Export Group Create Workflow ( workflow , null ,  STEP_ ENABLE_ IMAGE_ ACCESS , entry . get Key ( ) , export Group ID , entry . get Value ( ) , initiator URIs ) ; } _log . info ( _ STR + export Group . get Id ( ) ) ; }
public static boolean debugging (  String token ) { return  Debug .  On && ( debug All || dbg Table . contains Key ( token ) ) ; }
private boolean are Swc File Checksums Equal ( ) { if ( swc File Checksums == null ) { if (  Trace . swc Checksum ) {  Trace . trace ( _ STR ) ; } return _ BOOL ; }  Map <  String ,  Virtual File > swc Files = swc Context . get Files ( ) ;  Set <  Map .  Entry <  String ,  Long > > data Set = swc File Checksums . entry Set ( ) ; if ( swc Files . size ( ) < data Set . size ( ) ) { if (  Trace . swc Checksum ) {  Trace . trace ( _ STR ) ; } return _ BOOL ; } for (  Map .  Entry <  String ,  Long > entry : data Set ) {  String filename = entry . get Key ( ) ;  Long data File Last Modified = entry . get Value ( ) ;  Long swc File Last Modified = null ;  Virtual File swc File = swc Files . get ( filename ) ; if ( swc File != null ) { swc File Last Modified = new  Long ( swc File . get Last Modified ( ) ) ; } if ( ! data File Last Modified . equals ( swc File Last Modified ) ) { if (  Trace . swc Checksum ) {  Trace . trace ( _ STR ) ;  Trace . trace ( _ STR + filename ) ;  Trace . trace ( _ STR + data File Last Modified ) ;  Trace . trace ( _ STR + swc File Last Modified ) ; } return _ BOOL ; } } if (  Trace . swc Checksum ) {  Trace . trace ( _ STR ) ; } return _ BOOL ; }
private void adjust Min Pref For Spanning Comps (  Dim Constraint [ ] specs ,  Float [ ] def Push ,  Flow Size Spec fss ,  Array List <  Linked Dim Group > [ ] groups Lists ) { for ( int r = groups Lists . length - _ NUM ; r >= _ NUM ; r -- ) {  Array List <  Linked Dim Group > groups = groups Lists [ r ] ; for (  Linked Dim Group group : groups ) { if ( group . span == _ NUM ) continue ; int [ ] sizes = group . get Min Pref Max ( ) ; for ( int s =  Layout Util .  MIN ; s <=  Layout Util .  PREF ; s ++ ) { int c Size = sizes [ s ] ; if ( c Size ==  Layout Util .  NOT_ SET ) continue ; int row Size = _ NUM ; int s Ix = ( r << _ NUM ) + _ NUM ; int len =  Math . min ( ( group . span << _ NUM ) , fss . sizes . length - s Ix ) - _ NUM ; for ( int j = s Ix ; j < s Ix + len ; j ++ ) { int sz = fss . sizes [ j ] [ s ] ; if ( sz !=  Layout Util .  NOT_ SET ) row Size += sz ; } if ( row Size < c Size && len > _ NUM ) { for ( int eagerness = _ NUM , new Row Size = _ NUM ; eagerness < _ NUM && new Row Size < c Size ; eagerness ++ ) new Row Size = fss . expand Sizes ( specs , def Push , c Size , s Ix , len , s , eagerness ) ; } } } } }
public static  String array To Hex String ( byte [ ] array , int offset , int limit ) {  String ret Val ; if ( array != null ) {  String Buffer hex String = new  String Buffer ( array . length ) ; int hex Val ; char hex Char ; int length =  Math . min ( limit , array . length ) ; for ( int i = offset ; i < length ; i ++ ) { hex Val = ( array [ i ] & _ NUM ) > > _ NUM ; hex Char = ( char ) ( ( hex Val > _ NUM ) ? ( _ STR + ( hex Val - _ NUM ) ) : ( _ STR + hex Val ) ) ; hex String . append ( hex Char ) ; hex Val = array [ i ] & _ NUM ; hex Char = ( char ) ( ( hex Val > _ NUM ) ? ( _ STR + ( hex Val - _ NUM ) ) : ( _ STR + hex Val ) ) ; hex String . append ( hex Char ) ; } ret Val = hex String . to String ( ) ; } else { ret Val = _ STR ; } return ret Val ; }
public static  String read File To String (  File file ) { if ( file == null ) { return null ; }  Buffered Reader reader = null ; try { reader = new  Buffered Reader ( new  File Reader ( file ) ) ;  String Builder file Contents = new  String Builder ( _ STR ) ; boolean is First Line = _ BOOL ;  String current Line = reader . read Line ( ) ; while ( current Line != null ) { if ( is First Line ) is First Line = _ BOOL ; else file Contents . append (  System . line Separator ( ) ) ; file Contents . append ( current Line ) ; current Line = reader . read Line ( ) ; } return file Contents . to String ( ) ; } catch (  Exception e ) { logger . debug ( e . to String ( ) +  System . line Separator ( ) +  Stack Trace . get String From Stack Trace ( e ) ) ; return null ; } finally { try { if ( reader != null ) { reader . close ( ) ; } } catch (  Exception e ) { logger . debug ( e . to String ( ) +  System . line Separator ( ) +  Stack Trace . get String From Stack Trace ( e ) ) ; } } }
private  Coder Result control Sequence ( short new Byte ) { if ( new Byte >= _ NUM && new Byte <= _ NUM ) { if ( state ==  CONTROL_ SEQUENCE_ IF ) { return malformed Input (  ERR_ CTRLPI ) ; } queue . write ( new Byte ) ; } else if ( new Byte >= _ NUM && new Byte <= _ NUM ) { state =  CONTROL_ SEQUENCE_ IF ; queue . write ( new Byte ) ; } else if ( new Byte >= _ NUM && new Byte <= _ NUM ) { state =  NORMAL_ BYTES ; queue . reset ( ) ; } else { return malformed Input (  ERR_ CTRLBYTE ) ; } return  Coder Result .  UNDERFLOW ; }
@  Nullable public static  Network Parameters from Pmt Protocol ID (  String pmt Protocol Id ) { if ( pmt Protocol Id . equals (  PAYMENT_ PROTOCOL_ ID_ MAINNET ) ) { return  Main Net Params . get ( ) ; } else if ( pmt Protocol Id . equals (  PAYMENT_ PROTOCOL_ ID_ TESTNET ) ) { return  Test Net3 Params . get ( ) ; } else if ( pmt Protocol Id . equals (  PAYMENT_ PROTOCOL_ ID_ UNIT_ TESTS ) ) { return  Unit Test Params . get ( ) ; } else if ( pmt Protocol Id . equals (  PAYMENT_ PROTOCOL_ ID_ REGTEST ) ) { return  Reg Test Params . get ( ) ; } else if ( pmt Protocol Id . equals (  PAYMENT_ PROTOCOL_ ID_ ALPHANET ) ) { return  Alpha Net Params . get ( ) ; } else { return null ; } }
public void add Certificates (  Store cert Store ) throws  CMSException { certs . add All (  CMSUtils . get Certificates From Store ( cert Store ) ) ; }
public void save (  Output Stream os ) throws  IOException {  Data Output Stream dos = null ; try { dos = new  Data Output Stream ( os ) ; dos . write Long (  FILE_ MAGIC_ NUMBER ) ; dos . write Int (  FILE_ VERSION ) ; save Extensions ( critical Extensions , dos ) ; save Extensions ( non Critical Extensions , dos ) ; } finally {  IOUtils . close Quietly ( dos ) ; } }
protected double angle Between (  Point2 D v1 ,  Point2 D v2 ) { double x1 = v1 . get X ( ) ; double y1 = v1 . get Y ( ) ; double x2 = v2 . get X ( ) ; double y2 = v2 . get Y ( ) ; double cross = x1 * y2 - x2 * y1 ; int cw = _ NUM ; if ( cross > _ NUM ) { cw = - _ NUM ; } double angle = cw *  Math . acos ( ( x1 * x2 + y1 * y2 ) / (  Math . sqrt ( x1 * x1 + y1 * y1 ) *  Math . sqrt ( x2 * x2 + y2 * y2 ) ) ) ; if (  Double . is Na N ( angle ) ) { angle = _ NUM ; } return angle ; }
boolean add Index Entry (  String resource Name ,  String policy Name ) {  Iterator iter = top Level Entries . iterator ( ) ; boolean processed = _ BOOL ; while ( ! processed && ( iter . has Next ( ) ) ) {  Resource Index Entry resource Index Entry = (  Resource Index Entry ) iter . next ( ) ; if ( resource Index Entry . add Index Entry ( resource Type , resource Name , policy Name ) ) { processed = _ BOOL ; } } if ( ! processed ) {  Resource Index Entry resource Index Entry = new  Resource Index Entry ( resource Name , policy Name ) ;  Set current Entries = new  Hash Set ( ) ; current Entries . add All ( top Level Entries ) ;  Iterator iter1 = current Entries . iterator ( ) ; while ( iter1 . has Next ( ) ) {  Resource Index Entry rie = (  Resource Index Entry ) iter1 . next ( ) ;  Resource Match rm = resource Type . compare ( resource Name , rie . get Resource Name ( ) , _ BOOL ) ; if ( rm . equals (  Resource Match .  SUB_ RESOURCE_ MATCH ) ) { rie . set Parent ( resource Index Entry ) ; top Level Entries . remove ( rie ) ; } } top Level Entries . add ( resource Index Entry ) ; processed = _ BOOL ; } return processed ; }
public byte [ ] bitcoin Serialize ( ) { if ( header Bytes Valid && transaction Bytes Valid ) {  Preconditions . check Not Null ( bytes , _ STR ) ; if ( length == bytes . length ) { return bytes ; } else { byte [ ] buf = new byte [ length ] ;  System . arraycopy ( bytes , offset , buf , _ NUM , length ) ; return buf ; } }  Byte Array Output Stream stream = new  Unsafe Byte Array Output Stream ( length ==  UNKNOWN_ LENGTH ?  HEADER_ SIZE + guess Transactions Length ( ) : length ) ; try { write Header ( stream ) ; write Transactions ( stream ) ; } catch (  IOException e ) { } return stream . to Byte Array ( ) ; }
@  Override public  List <  Period > generate Periods (  Date Time Unit date Time Unit ) {  Calendar calendar = get Calendar ( ) ; date Time Unit = calendar . minus Years ( date Time Unit , _ NUM ) ; date Time Unit . set Day ( _ NUM ) ; date Time Unit . set Month ( _ NUM ) ;  List <  Period > periods =  Lists . new Array List ( ) ; for ( int i = _ NUM ; i < _ NUM ; ++ i ) { periods . add ( create Period ( date Time Unit , calendar ) ) ; date Time Unit = calendar . plus Years ( date Time Unit , _ NUM ) ; } return periods ; }
@  Override public  Set <  String > vertex Match Pattern Labels ( ) { return labels . size ( ) == _ NUM ? labels :  Collections . empty Set ( ) ; }
public void move Child View ( int from Group Position , int from Child Position , int to Group Position , int to Child Position ) {  Array List <  Room Summary > from List = m Summary List By Group Position . get ( from Group Position ) ;  Array List <  Room Summary > to List = m Summary List By Group Position . get ( to Group Position ) ;  Room Summary summary = from List . get ( from Child Position ) ; from List . remove ( from Child Position ) ; if ( to Child Position >= to List . size ( ) ) { to List . add ( summary ) ; } else { to List . add ( to Child Position , summary ) ; } }
public void add Category (  Category category ) { if ( categories == null ) { categories = new  Array List <  Category > ( ) ; } categories . add ( category ) ; }
private static int  Call Object Method V (  JNIEnvironment env , int obj JREF , int method ID ,  Address arg Address ) throws  Exception { if ( trace JNI )  VM . sys Write ( _ STR ) ;  Runtime Entrypoints . check JNICount Down To GC ( ) ; try {  Object obj = env . get JNIRef ( obj JREF ) ;  Object return Obj =  JNIHelpers . invoke With Var Arg ( obj , method ID , arg Address , null , _ BOOL ) ; return env . push JNIRef ( return Obj ) ; } catch (  Throwable unexpected ) { if ( trace JNI ) unexpected . print Stack Trace (  System . err ) ; env . record Exception ( unexpected ) ; return _ NUM ; } }
private  Tuple <  Message ,  Connection > try Other Messages ( ) {  List <  Tuple <  Message ,  Connection > > messages = new  Array List <  Tuple <  Message ,  Connection > > ( ) ;  Collection <  Message > msg Collection = get Message Collection ( ) ; for (  Connection con : get Connections ( ) ) {  DTNHost other = con . get Other Node ( get Host ( ) ) ;  Prophet Router oth Router = (  Prophet Router ) other . get Router ( ) ; if ( oth Router . is Transferring ( ) ) { continue ; } for (  Message m : msg Collection ) { if ( oth Router . has Message ( m . get Id ( ) ) ) { continue ; } if ( oth Router . get Pred For ( m . get To ( ) ) > get Pred For ( m . get To ( ) ) ) { messages . add ( new  Tuple <  Message ,  Connection > ( m , con ) ) ; } } } if ( messages . size ( ) == _ NUM ) { return null ; }  Collections . sort ( messages , new  Tuple Comparator ( ) ) ; return try Messages For Connected ( messages ) ; }
private void test Infinite Streams ( ) {  Random rand = new  Random ( ) ;  Supplier <  Integer > random Integer Supplier = null ;  Stream <  Integer > random Int Stream =  Stream . generate ( random Integer Supplier ) ; random Int Stream . for Each ( null ) ;  Stream <  Double > random Stream =  Stream . generate ( null ) ; random Stream . for Each ( null ) ;  Stream <  Integer > whole Numbers =  Stream . iterate ( _ NUM , null ) ; whole Numbers . for Each ( null ) ; }
public static void cache Internal Item Id (  Consumer Bean consumer Bean ,  String client Id ,  Long internal Id ) { final  String client Id Key =  Mem Cache Keys . get Item Internal Id ( consumer Bean . get Short_name ( ) , client Id ) ;  Mem Cache Peer . put ( client Id Key , internal Id ,  Constants .  CACHING_ TIME ) ; }
static  String scan Public ID (  String Buffer public ID ,  IXMLReader reader ) throws  IOException ,  XMLParse Exception { if ( !  XMLUtil . check Literal ( reader , _ STR ) ) { return null ; }  XMLUtil . skip Whitespace ( reader , null ) ; public ID . append (  XMLUtil . scan String ( reader , _ STR , null ) ) ;  XMLUtil . skip Whitespace ( reader , null ) ; return  XMLUtil . scan String ( reader , _ STR , null ) ; }
@  Override final  Node <  K ,  V > find ( int h ,  Object k ) { if ( k != null ) { for (  Node <  K ,  V > e = first ; e != null ; e = e . next ) { int s ;  K ek ; if ( ( ( s = lock State ) & (  WAITER |  WRITER ) ) != _ NUM ) { if ( e . hash == h && ( ( ek = e . key ) == k || ( ek != null && k . equals ( ek ) ) ) ) return e ; } else if (  U . compare And Swap Int ( this ,  LOCKSTATE , s , s +  READER ) ) {  Tree Node <  K ,  V > r , p ; try { p = ( ( r = root ) == null ? null : r . find Tree Node ( h , k , null ) ) ; } finally {  Thread w ; int ls ; do { } while ( !  U . compare And Swap Int ( this ,  LOCKSTATE , ls = lock State , ls -  READER ) ) ; if ( ls == (  READER |  WAITER ) && ( w = waiter ) != null )  Lock Support . unpark ( w ) ; } return p ; } } } return null ; }
public boolean is Public ( ) { return  Modifier . is Public ( _method . get Modifiers ( ) ) ; }
@  Override public boolean receive Image (  Image To Process img ,  Set <  Task Image Container > tasks , boolean block Until Image Release , boolean close On Image Release ,  Optional <  Runnable > runnable When Done ) throws  Interrupted Exception { if ( tasks == null || tasks . size ( ) <= _ NUM ) { return _ BOOL ; } if ( img == null ) { throw new  Runtime Exception ( _ STR ) ; } int count Image Refs = num Propagated Image References ( img , tasks ) ; initialize Task Done ( tasks , runnable When Done ) ;  Image Release Protocol protocol = set Semaphore Reference Count ( img , count Image Refs , block Until Image Release , close On Image Release ) ; schedule Tasks ( tasks ) ; if ( protocol . block Until Release ) { protocol . block ( ) ; } return _ BOOL ; }
public void find Charge Element ID ( ) { m_ C_ Acct Schema_ ID =  Env . get Context As Int (  Env . get Ctx ( ) , _ STR ) ;  String sql = _ STR + _ STR + _ STR ; try {  Prepared Statement pstmt =  DB . prepare Statement ( sql , null ) ; pstmt . set Int ( _ NUM , m_ C_ Acct Schema_ ID ) ;  Result Set rs = pstmt . execute Query ( ) ; if ( rs . next ( ) ) { m_ C_ Element_ ID = rs . get Int ( _ NUM ) ; } rs . close ( ) ; pstmt . close ( ) ; } catch (  SQLException exception ) { log . log (  Level .  SEVERE , sql , exception ) ; } }
public  Cholesky Decomposition (  Matrix  Arg ) { double [ ] [ ]  A =  Arg . get Array ( ) ; n =  Arg . get Row Dimension ( ) ;  L = new double [ n ] [ n ] ; isspd = (  Arg . get Column Dimension ( ) == n ) ; for ( int j = _ NUM ; j < n ; j ++ ) { double [ ]  Lrowj =  L [ j ] ; double d = _ NUM ; for ( int k = _ NUM ; k < j ; k ++ ) { double [ ]  Lrowk =  L [ k ] ; double s = _ NUM ; for ( int i = _ NUM ; i < k ; i ++ ) { s +=  Lrowk [ i ] *  Lrowj [ i ] ; }  Lrowj [ k ] = s = (  A [ j ] [ k ] - s ) /  L [ k ] [ k ] ; d = d + s * s ; isspd = isspd & (  A [ k ] [ j ] ==  A [ j ] [ k ] ) ; } d =  A [ j ] [ j ] - d ; isspd = isspd & ( d > _ NUM ) ;  L [ j ] [ j ] =  Math . sqrt (  Math . max ( d , _ NUM ) ) ; for ( int k = j + _ NUM ; k < n ; k ++ ) {  L [ j ] [ k ] = _ NUM ; } } }
public static void open Projects ( final  JTree project Tree , final  INavi Project [ ] projects ) { for ( final  INavi Project project : projects ) {  CProject Loader . load Project ( project Tree , project ) ; } }
public void close ( ) throws  IOException { if ( stream != null ) { stream . close ( ) ; } else { reader . close ( ) ; } }
private void parse Helper (  String number To Parse ,  String default Region , boolean keep Raw Input , boolean check Region ,  Phone Number phone Number ) throws  Number Parse Exception { if ( number To Parse == null ) { throw new  Number Parse Exception (  Number Parse Exception .  Error Type .  NOT_ A_ NUMBER , _ STR ) ; } else if ( number To Parse . length ( ) >  MAX_ INPUT_ STRING_ LENGTH ) { throw new  Number Parse Exception (  Number Parse Exception .  Error Type .  TOO_ LONG , _ STR ) ; }  String Builder national Number = new  String Builder ( ) ; build National Number For Parsing ( number To Parse , national Number ) ; if ( ! is Viable Phone Number ( national Number . to String ( ) ) ) { throw new  Number Parse Exception (  Number Parse Exception .  Error Type .  NOT_ A_ NUMBER , _ STR ) ; } if ( check Region && ! check Region For Parsing ( national Number . to String ( ) , default Region ) ) { throw new  Number Parse Exception (  Number Parse Exception .  Error Type .  INVALID_ COUNTRY_ CODE , _ STR ) ; } if ( keep Raw Input ) { phone Number . set Raw Input ( number To Parse ) ; }  String extension = maybe Strip Extension ( national Number ) ; if ( extension . length ( ) > _ NUM ) { phone Number . set Extension ( extension ) ; }  Phone Metadata region Metadata = get Metadata For Region ( default Region ) ;  String Builder normalized National Number = new  String Builder ( ) ; int country Code = _ NUM ; try { country Code = maybe Extract Country Code ( national Number . to String ( ) , region Metadata , normalized National Number , keep Raw Input , phone Number ) ; } catch (  Number Parse Exception e ) {  Matcher matcher =  PLUS_ CHARS_ PATTERN . matcher ( national Number . to String ( ) ) ; if ( e . get Error Type ( ) ==  Number Parse Exception .  Error Type .  INVALID_ COUNTRY_ CODE && matcher . looking At ( ) ) { country Code = maybe Extract Country Code ( national Number . substring ( matcher . end ( ) ) , region Metadata , normalized National Number , keep Raw Input , phone Number ) ; if ( country Code == _ NUM ) { throw new  Number Parse Exception (  Number Parse Exception .  Error Type .  INVALID_ COUNTRY_ CODE , _ STR ) ; } } else { throw new  Number Parse Exception ( e . get Error Type ( ) , e . get Message ( ) ) ; } } if ( country Code != _ NUM ) {  String phone Number Region = get Region Code For Country Code ( country Code ) ; if ( ! phone Number Region . equals ( default Region ) ) { region Metadata = get Metadata For Region Or Calling Code ( country Code , phone Number Region ) ; } } else { normalize ( national Number ) ; normalized National Number . append ( national Number ) ; if ( default Region != null ) { country Code = region Metadata . get Country Code ( ) ; phone Number . set Country Code ( country Code ) ; } else if ( keep Raw Input ) { phone Number . clear Country Code Source ( ) ; } } if ( normalized National Number . length ( ) <  MIN_ LENGTH_ FOR_ NSN ) { throw new  Number Parse Exception (  Number Parse Exception .  Error Type .  TOO_ SHORT_ NSN , _ STR ) ; } if ( region Metadata != null ) {  String Builder carrier Code = new  String Builder ( ) ;  String Builder potential National Number = new  String Builder ( normalized National Number ) ; maybe Strip National Prefix And Carrier Code ( potential National Number , region Metadata , carrier Code ) ; if ( test Number Length ( potential National Number . to String ( ) , region Metadata . get General Desc ( ) ) !=  Validation Result .  TOO_ SHORT ) { normalized National Number = potential National Number ; if ( keep Raw Input && carrier Code . length ( ) > _ NUM ) { phone Number . set Preferred Domestic Carrier Code ( carrier Code . to String ( ) ) ; } } } int length Of National Number = normalized National Number . length ( ) ; if ( length Of National Number <  MIN_ LENGTH_ FOR_ NSN ) { throw new  Number Parse Exception (  Number Parse Exception .  Error Type .  TOO_ SHORT_ NSN , _ STR ) ; } if ( length Of National Number >  MAX_ LENGTH_ FOR_ NSN ) { throw new  Number Parse Exception (  Number Parse Exception .  Error Type .  TOO_ LONG , _ STR ) ; } set Italian Leading Zeros For Phone Number ( normalized National Number . to String ( ) , phone Number ) ; phone Number . set National Number (  Long . parse Long ( normalized National Number . to String ( ) ) ) ; }
public void increment In Steps ( long tick Ms , long total Ms ) { long start = now ; long end = start + total Ms ; while ( now < end ) { increment By (  Math . min ( tick Ms , end - now ) ) ; } }
public  Optional <  String > string Value ( ) { return  Optional . empty ( ) ; }
static public  JLabel create JLabel For Table ( ) {  JLabel label = new  JLabel ( ) ; set Plain ( label ) ; label . set Opaque ( _ BOOL ) ; label . set Foreground (  TABLE_ COMPONENT_ FG_ COLOR ) ; label . set Background (  TABLE_ COMPONENT_ BG_ COLOR ) ; return label ; }
@  Nullable public  Virtual File find File By Relative Path ( @  Not Null @  Non Nls  String rel Path ) { if ( rel Path . is Empty ( ) ) return this ; rel Path =  String Util . trim Start ( rel Path , _ STR ) ; int index = rel Path . index Of ( _ STR ) ; if ( index < _ NUM ) index = rel Path . length ( ) ;  String name = rel Path . substring ( _ NUM , index ) ;  Virtual File child ; if ( name . equals ( _ STR ) ) { child = this ; } else if ( name . equals ( _ STR ) ) { if ( is (  VFile Property .  SYMLINK ) ) { final  Virtual File canonical File = get Canonical File ( ) ; child = canonical File != null ? canonical File . get Parent ( ) : null ; } else { child = get Parent ( ) ; } } else { child = find Child ( name ) ; } if ( child == null ) return null ; if ( index < rel Path . length ( ) ) { return child . find File By Relative Path ( rel Path . substring ( index + _ NUM ) ) ; } return child ; }
private static  String trim Leading Slash (  String value ) { if ( value == null ) return _ STR ; while ( value . index Of ( _ STR ) > - _ NUM ) { value = value . substring ( value . index Of ( _ STR ) + _ NUM ) ; } return value ; }
public void test Execute Null Runnable ( ) {  Executor Service e = new  Fork Join Pool ( _ NUM ) ;  Pool Cleaner cleaner = null ; try { cleaner = cleaner ( e ) ; try { @  Suppress Warnings ( _ STR )  Future < ? > future = e . submit ( (  Runnable ) null ) ; should Throw ( ) ; } catch (  Null Pointer Exception success ) { } } finally { if ( cleaner != null ) { cleaner . close ( ) ; } } }
private static long read Long (  Input Stream in ) throws  IOException { int b0 = in . read ( ) ; int b1 = in . read ( ) ; int b2 = in . read ( ) ; int b3 = in . read ( ) ; if ( ( b0 | b1 | b2 | b3 ) == - _ NUM ) { throw new  EOFException ( ) ; } int upper = ( b0 << _ NUM ) | ( b1 << _ NUM ) | ( b2 << _ NUM ) | b3 ; b0 = in . read ( ) ; b1 = in . read ( ) ; b2 = in . read ( ) ; b3 = in . read ( ) ; if ( ( b0 | b1 | b2 | b3 ) == - _ NUM ) { throw new  EOFException ( ) ; } int lower = ( b0 << _ NUM ) | ( b1 << _ NUM ) | ( b2 << _ NUM ) | b3 ; return ( ( long ) upper << _ NUM ) | ( lower & _ NUM ) ; }
public synchronized  String format (  Date in Date ) { return format ( in Date . get Time ( ) ) ; }
public void clear Results ( ) { m_ Results . clear ( ) ; m_ Model . clear ( ) ; m_ Objs . clear ( ) ;  System . gc ( ) ; }
@  Override public  Graph Query has ( final  String key , final  Predicate predicate , final  Object value ) { if ( ! known Predicates . contains ( predicate . get Class ( ) ) ) { throw new  Illegal Argument Exception ( ) ; } criteria . add ( new  Has ( key , value ,  Bigdata Predicate . to Bigdata Predicate ( predicate ) ) ) ; return this ; }
public  Attr Set read ( java . security .  Principal principal ,  Guid guid ) throws  UMSException { return read ( principal , guid , null ) ; }
private static void write Input Stream To Output Stream (  Input Stream input Stream ,  Output Stream output Stream ) { try { try { final byte [ ] buffer = new byte [ _ NUM ] ; int read ; while ( ( read = input Stream . read ( buffer ) ) != - _ NUM ) { output Stream . write ( buffer , _ NUM , read ) ; } output Stream . flush ( ) ; } catch ( final  Exception e ) { e . print Stack Trace ( ) ; } finally { output Stream . close ( ) ; input Stream . close ( ) ; } } catch ( final  Exception e ) { e . print Stack Trace ( ) ; } }
public static  List < ? extends  Element > child Element List (  Element element ) { if ( element == null ) return null ;  List <  Element > elements = new  Linked List <  Element > ( ) ;  Node node = element . get First Child ( ) ; if ( node != null ) { do { if ( node . get Node Type ( ) ==  Node .  ELEMENT_ NODE ) {  Element child Element = (  Element ) node ; elements . add ( child Element ) ; } } while ( ( node = node . get Next Sibling ( ) ) != null ) ; } return elements ; }
public void fill Polygon (  Object graphics , int [ ] x Points , int [ ] y Points , int n Points ) { int [ ] intersections = new int [ n Points ] ; int intersections Count = _ NUM ; int y Max = ( int ) y Points [ _ NUM ] ; int y Min = ( int ) y Points [ _ NUM ] ; for ( int i = _ NUM ; i < n Points ; i ++ ) { y Max =  Math . max ( y Max , y Points [ i ] ) ; y Min =  Math . min ( y Min , y Points [ i ] ) ; } for ( int row = y Min ; row <= y Max ; row ++ ) { intersections Count = _ NUM ; for ( int i = _ NUM ; i < n Points ; i ++ ) { if ( check Intersection ( graphics , row , x Points [ i - _ NUM ] , x Points [ i ] , y Points [ i - _ NUM ] , y Points [ i ] , intersections , intersections Count ) ) { intersections Count ++ ; } } if ( check Intersection ( graphics , row , x Points [ n Points - _ NUM ] , x Points [ _ NUM ] , y Points [ n Points - _ NUM ] , y Points [ _ NUM ] , intersections , intersections Count ) ) { intersections Count ++ ; } for ( int j = _ NUM ; j < n Points ; j ++ ) { if ( row == y Points [ j ] ) { intersections Count += mark Intersection Edge ( graphics , j , y Points , x Points , n Points , intersections , intersections Count ) ; } } int swap = _ NUM ; for ( int i = _ NUM ; i < intersections Count ; i ++ ) { for ( int j = i ; j < intersections Count ; j ++ ) { if ( intersections [ j ] < intersections [ i ] ) { swap = intersections [ i ] ; intersections [ i ] = intersections [ j ] ; intersections [ j ] = swap ; } } } for ( int i = _ NUM ; i < intersections Count ; i = i + _ NUM ) { draw Line ( graphics , intersections [ i - _ NUM ] , row , intersections [ i ] , row ) ; } } }
@  Override public void mouse Released (  Mouse Event e ) { synchronized ( mouse Lock ) { mouse Pressed = _ BOOL ; } if ( e . get Button ( ) ==  Mouse Event .  BUTTON1 ) { for (  Draw Listener listener : listeners ) listener . mouse Released ( user X ( e . get X ( ) ) , user Y ( e . get Y ( ) ) ) ; } }
public java . util .  List create Headers (  String headers ) throws java . text .  Parse Exception { if ( headers == null ) throw new  Null Pointer Exception ( _ STR ) ;  String Msg Parser smp = new  String Msg Parser ( ) ;  SIPHeader shdr = smp . parse SIPHeader ( headers ) ; if ( shdr instanceof  SIPHeader List ) return (  SIPHeader List ) shdr ; else throw new  Parse Exception ( _ STR , _ NUM ) ; }
public static  String encode XML (  String text ) { if ( text == null ) { return null ; } final  String Builder result = new  String Builder ( ) ; final  String Character Iterator iterator = new  String Character Iterator ( text ) ; char character = iterator . current ( ) ; while ( character !=  Character Iterator .  DONE ) { if ( character == _ STR ) { result . append ( _ STR ) ; } else if ( character == _ STR ) { result . append ( _ STR ) ; } else if ( character == _ STR ) { result . append ( _ STR ) ; } else if ( character == _ STR ) { result . append ( _ STR ) ; } else if ( character == _ STR ) { result . append ( _ STR ) ; } else { result . append ( character ) ; } character = iterator . next ( ) ; } return result . to String ( ) ; }
public int exit_code ( ) { return  Integer . parse Int ( fields [ _ NUM ] ) ; }
protected void import Frames ( double [ ] frames , double step ) {  Array List <  Pitch Target > new Targets = new  Array List <  Pitch Target > ( ) ; double t = xmin ; for ( int i = _ NUM ; i < frames . length ; i ++ ) { if ( !  Double . is Na N ( frames [ i ] ) ) { new Targets . add ( new  Pitch Target ( t , frames [ i ] ) ) ; } t += step ; } targets = new Targets . to Array ( new  Pitch Target [ _ NUM ] ) ; num Targets = targets . length ; }
public static final void write Int Array Xml ( int [ ] val ,  String name ,  Xml Serializer out ) throws  Xml Pull Parser Exception , java . io .  IOException { if ( val == null ) { out . start Tag ( null , _ STR ) ; out . end Tag ( null , _ STR ) ; return ; } out . start Tag ( null , _ STR ) ; if ( name != null ) { out . attribute ( null , _ STR , name ) ; } final int n = val . length ; out . attribute ( null , _ STR ,  Integer . to String ( n ) ) ; for ( int i = _ NUM ; i < n ; i ++ ) { out . start Tag ( null , _ STR ) ; out . attribute ( null , _ STR ,  Integer . to String ( val [ i ] ) ) ; out . end Tag ( null , _ STR ) ; } out . end Tag ( null , _ STR ) ; }
private  Spannable highlight User Handles (  Spannable text ) { if ( text == null ) { return null ; } final  Matcher matcher =  PATTERN_ USER_ HANDLES . matcher ( text ) ; while ( matcher . find ( ) ) { final int start = matcher . start ( _ NUM ) ; final int end = matcher . end ( _ NUM ) ; text . set Span ( new  Foreground Color Span ( m Highlight Color ) , start , end ,  Spanned .  SPAN_ EXCLUSIVE_ EXCLUSIVE ) ; text . set Span ( new  Style Span ( android . graphics .  Typeface .  BOLD ) , start , end ,  Spanned .  SPAN_ EXCLUSIVE_ EXCLUSIVE ) ; } return text ; }
protected int read Block ( ) { block Size = read ( ) ; int n = _ NUM ; if ( block Size > _ NUM ) { try { int count = _ NUM ; while ( n < block Size ) { count = in . read ( block , n , block Size - n ) ; if ( count == - _ NUM ) break ; n += count ; } } catch (  IOException e ) { } if ( n < block Size ) { status =  STATUS_ FORMAT_ ERROR ; } } return n ; }
private  Match check Match ( final  String arg Name , final  Argument arg , final  String [ ] params ) { for (  String form : arg . get Forms ( ) ) { if ( form . equals ( arg Name ) && arg . get Parameter Count ( ) == params . length ) { return new  Match ( arg , form , params ) ; } } return null ; }
private  Http Entity execute Get (  String url ,  String [ ] [ ] get Params ,  String [ ] [ ] header Params ) throws  IOException { if ( get Params != null ) {  List <  Name Value Pair > formparams = new  Array List <  Name Value Pair > ( ) ; for (  String [ ] param : get Params ) { if ( param [ _ NUM ] != null && param [ _ NUM ] != null ) { formparams . add ( new  Basic Name Value Pair ( param [ _ NUM ] , param [ _ NUM ] ) ) ; } } url = url + _ STR +  URLEncoded Utils . format ( formparams , _ STR ) ; }  Http Get httpget = new  Http Get ( url ) ; if ( header Params != null ) { for (  String [ ] param : header Params ) { if ( param [ _ NUM ] != null && param [ _ NUM ] != null ) { httpget . set Header ( param [ _ NUM ] , param [ _ NUM ] ) ; } } } return execute Http Request ( httpget ) ; }
public  Image rotate270 Degrees (  Image image , boolean maintain Opacity ) { int [ ] rgb = image . get RGB ( ) ; int [ ] new RGB = new int [ rgb . length ] ; int width = image . get Width ( ) ; int height = image . get Height ( ) ; for ( int y = _ NUM ; y < height ; y ++ ) { for ( int x = _ NUM ; x < width ; x ++ ) { new RGB [ y + x * height ] = rgb [ x + y * width ] ; } } return  Encoded Image . create From RGB ( new RGB , height , width , ! maintain Opacity ) ; }
public  Whitespace Tokenizer Factory (  Map <  String ,  String > args ) { super ( args ) ; rule = get ( args , _ STR ,  RULE_ NAMES ,  RULE_ JAVA ) ; if ( ! args . is Empty ( ) ) { throw new  Illegal Argument Exception ( _ STR + args ) ; } }
public static <  T >  T wrap Throw (  Callable <  T > callable ) { try { return callable . call ( ) ; } catch (  Runtime Exception e ) { throw e ; } catch (  Exception e ) { throw new  Runtime Exception ( e ) ; } }
public static  String pad (  String str , int total Chars ) { if ( str == null ) str = _ STR ; int slen = str . length ( ) ;  String Buffer sb = new  String Buffer ( str ) ; for ( int i = _ NUM ; i < total Chars - slen ; i ++ ) { sb . append ( _ STR ) ; } return sb . to String ( ) ; }
protected void decode Image Data ( ) { int  Null Code = - _ NUM ; int npix = iw * ih ; int available , clear , code_mask , code_size , end_of_information , in_code , old_code , bits , code , count , i , datum , data_size , first , top , bi , pi ; if ( ( pixels == null ) || ( pixels . length < npix ) ) { pixels = new byte [ npix ] ; } if ( prefix == null ) prefix = new short [  Max Stack Size ] ; if ( suffix == null ) suffix = new byte [  Max Stack Size ] ; if ( pixel Stack == null ) pixel Stack = new byte [  Max Stack Size + _ NUM ] ; data_size = read ( ) ; clear = _ NUM << data_size ; end_of_information = clear + _ NUM ; available = clear + _ NUM ; old_code =  Null Code ; code_size = data_size + _ NUM ; code_mask = ( _ NUM << code_size ) - _ NUM ; for ( code = _ NUM ; code < clear ; code ++ ) { prefix [ code ] = _ NUM ; suffix [ code ] = ( byte ) code ; } datum = bits = count = first = top = pi = bi = _ NUM ; for ( i = _ NUM ; i < npix ; ) { if ( top == _ NUM ) { if ( bits < code_size ) { if ( count == _ NUM ) { count = read Block ( ) ; if ( count <= _ NUM ) break ; bi = _ NUM ; } datum += ( block [ bi ] & _ NUM ) << bits ; bits += _ NUM ; bi ++ ; count -- ; continue ; } code = datum & code_mask ; datum >>= code_size ; bits -= code_size ; if ( ( code > available ) || ( code == end_of_information ) ) break ; if ( code == clear ) { code_size = data_size + _ NUM ; code_mask = ( _ NUM << code_size ) - _ NUM ; available = clear + _ NUM ; old_code =  Null Code ; continue ; } if ( old_code ==  Null Code ) { pixel Stack [ top ++ ] = suffix [ code ] ; old_code = code ; first = code ; continue ; } in_code = code ; if ( code == available ) { pixel Stack [ top ++ ] = ( byte ) first ; code = old_code ; } while ( code > clear ) { pixel Stack [ top ++ ] = suffix [ code ] ; code = prefix [ code ] ; } first = suffix [ code ] & _ NUM ; if ( available >=  Max Stack Size ) break ; pixel Stack [ top ++ ] = ( byte ) first ; prefix [ available ] = ( short ) old_code ; suffix [ available ] = ( byte ) first ; available ++ ; if ( ( ( available & code_mask ) == _ NUM ) && ( available <  Max Stack Size ) ) { code_size ++ ; code_mask += available ; } old_code = in_code ; } top -- ; pixels [ pi ++ ] = pixel Stack [ top ] ; i ++ ; } for ( i = pi ; i < npix ; i ++ ) { pixels [ i ] = _ NUM ; } }
public int hash Code ( ) { if ( myhash == - _ NUM ) { myhash = timestamp . hash Code ( ) + signer Cert Path . hash Code ( ) ; } return myhash ; }
public  Console User ( ) { this ( new  Print Writer (  System . out ) , new  Input Stream Reader (  System . in ) ,  Resource Bundle . get Bundle (  LICENSE_ PROPERTIES ) ) ; }
private void read Not Missing Entry (  Data Set Row data Row ,  String [ ] row , int column Index , int row Index , final  Column Type column Type ,  Map <  Integer ,  Set <  Integer > > error Cells ) { try { switch ( column Type ) { case  DATE : row [ column Index ] =  Tools . format Date ( data Row . get Date ( column Index ) ) ; break ; case  DATETIME : row [ column Index ] =  Tools . format Date Time ( data Row . get Date ( column Index ) ) ; break ; case  TIME : row [ column Index ] =  Tools . format Time ( data Row . get Date ( column Index ) ) ; break ; case  REAL : row [ column Index ] =  Tools . format Number ( data Row . get Double ( column Index ) ) ; break ; case  INTEGER : row [ column Index ] =  Tools . format Integer If Possible (  Math . round ( data Row . get Double ( column Index ) ) ) ; break ; case  CATEGORICAL : row [ column Index ] =  Default Preview . shorten Display Value ( data Row . get String ( column Index ) ) ; break ; case  BINARY :  String value = data Row . get String ( column Index ) ; final  Set <  String > binary Entries = binary Mapping . get ( column Index ) ; if ( binary Entries . size ( ) == _ NUM && ! binary Entries . contains ( value ) ) { throw new  Parse Exception (  ALREADY_ TWO_ BINARY_ VALUES + binary Entries . to String ( ) ) ; } else { binary Entries . add ( value ) ; row [ column Index ] =  Default Preview . shorten Display Value ( value ) ; } break ; default : break ; } } catch (  Parse Exception e ) { row [ column Index ] = null ;  String original Value = null ; if ( column Type !=  Column Type .  CATEGORICAL ) { try { original Value = data Row . get String ( column Index ) ; } catch (  Parse Exception e1 ) { original Value = null ; } } parsing Error List . add ( new  Parsing Error ( column Index , row Index , original Value , e . get Message ( ) ) ) ;  Set <  Integer > errors = error Cells . get ( column Index ) ; if ( errors != null ) { errors . add ( row Index ) ; } else {  Set <  Integer > error Rows = new  Hash Set < > ( ) ; error Rows . add ( row Index ) ; error Cells . put ( column Index , error Rows ) ; } } }
private void remove Acked (  Array List <  Record Info > acks ) { for (  Record Info info : acks ) {  Ack Describe ack = (  Ack Describe )  Describe Journal . new Object Encoding ( info , null ) ;  Hash Map <  Long ,  Reference Describe > reference Describe Hash Map = message Refs . get ( info . id ) ; reference Describe Hash Map . remove ( ack . ref Encoding . queue ID ) ; if ( reference Describe Hash Map . size ( ) == _ NUM ) { messages . remove ( info . id ) ; message Refs . remove ( info . id ) ; } } }
Input Stream locate Script File (  String path ,  String pkg ,  String name ) throws  File Not Found Exception { if ( m_source Locator != null ) { m_source Locator Change Count = m_source Locator . get Change Count ( ) ;  Input Stream is = m_source Locator . locate Source ( path , pkg , name ) ; if ( is != null ) return is ; } path = path . replace ( _ STR ,  File . separator Char ) ; pkg = pkg . replace ( _ STR ,  File . separator Char ) ;  File f ; if ( path . length ( ) > _ NUM ) { try {  String pkg And Name = _ STR ; if ( pkg . length ( ) > _ NUM ) pkg And Name += pkg +  File . separator Char ; pkg And Name += name ; f = new  File ( path , pkg And Name ) ; if ( f . exists ( ) ) return new  File Input Stream ( f ) ; } catch (  Null Pointer Exception npe ) { } } if ( pkg . length ( ) > _ NUM ) { f = new  File ( pkg , name ) ; if ( f . exists ( ) ) return new  File Input Stream ( f ) ; } f = new  File ( name ) ; if ( f . exists ( ) ) return new  File Input Stream ( f ) ; return null ; }
@  Override public void action Performed (  Action Event ev ) { final megan . remote .  Remote Service Browser remote Service Browser = ( megan . remote .  Remote Service Browser ) get Viewer ( ) ; if ( remote Service Browser != null ) {  String url = remote Service Browser . get URL ( ) ; if ( url . length ( ) > _ NUM ) { execute ( _ STR + url + _ STR ) ; } } }
public static  List <  Verification Exception > verify Certificates (  Certificate [ ] certs ,  Key Store keystore ,  Collection <  CRL > crls ,  Calendar calendar ) {  List <  Verification Exception > result = new  Array List < > ( ) ; for ( int k = _ NUM ; k < certs . length ; ++ k ) {  X509 Certificate cert = (  X509 Certificate ) certs [ k ] ;  String err = verify Certificate ( cert , crls , calendar ) ; if ( err != null ) result . add ( new  Verification Exception ( cert , err ) ) ; try { for (  X509 Certificate cert Store X509 :  Sign Utils . get Certificates ( keystore ) ) { try { if ( verify Certificate ( cert Store X509 , crls , calendar ) != null ) continue ; try { cert . verify ( cert Store X509 . get Public Key ( ) ) ; return result ; } catch (  Exception e ) { continue ; } } catch (  Exception ex ) { } } } catch (  Exception e ) { } int j ; for ( j = _ NUM ; j < certs . length ; ++ j ) { if ( j == k ) continue ;  X509 Certificate cert Next = (  X509 Certificate ) certs [ j ] ; try { cert . verify ( cert Next . get Public Key ( ) ) ; break ; } catch (  Exception e ) { } } if ( j == certs . length ) { result . add ( new  Verification Exception ( cert , _ STR ) ) ; } } if ( result . size ( ) == _ NUM ) result . add ( new  Verification Exception ( (  Certificate ) null , _ STR ) ) ; return result ; }
public static void compress ( ) {  String input =  Binary Std In . read String ( ) ;  TST <  Integer > st = new  TST <  Integer > ( ) ; for ( int i = _ NUM ; i <  R ; i ++ ) st . put ( _ STR + ( char ) i , i ) ; int code =  R + _ NUM ; while ( input . length ( ) > _ NUM ) {  String s = st . longest Prefix Of ( input ) ;  Binary Std Out . write ( st . get ( s ) ,  W ) ; int t = s . length ( ) ; if ( t < input . length ( ) && code <  L ) st . put ( input . substring ( _ NUM , t + _ NUM ) , code ++ ) ; input = input . substring ( t ) ; }  Binary Std Out . write (  R ,  W ) ;  Binary Std Out . close ( ) ; }
@  Override public boolean has More Elements ( ) { return has Next ( ) ; }
static  String sanitize File Name (  String name ) {  String Buffer buffer = new  String Buffer ( name . length ( ) ) ; for ( int i = _ NUM ; i < name . length ( ) ; i ++ ) { int code Point = name . code Point At ( i ) ; char character = name . char At ( i ) ; if (  Character . is Letter Or Digit ( character ) || code Point > _ NUM || is Special Fat32 ( character ) ) { buffer . append Code Point ( code Point ) ; } else { buffer . append ( _ STR ) ; } }  String result = buffer . to String ( ) ; return result . replace All ( _ STR , _ STR ) ; }
@  Override public double [ ] make Inverse Cumulative Test Values ( ) { double [ ] points = make Cumulative Test Points ( ) ; double [ ] points2 = new double [ points . length - _ NUM ] ;  System . arraycopy ( points , _ NUM , points2 , _ NUM , points2 . length - _ NUM ) ; return points2 ; }
public java . lang .  String Buffer append ( boolean b ) { internal . append ( b ) ; return this ; }
public void update Server Config Inheritance (  String server Name ,  Set to Inherit ,  Set not To Inherit ) throws  AMConsole Exception {  String [ ] param = { server Name } ; log Event ( _ STR , param ) ; try {  SSOToken sso Token = get User SSOToken ( ) ;  Map default Values =  Server Configuration . get Defaults ( sso Token ) ;  Map svr Properties =  Server Configuration . get Server Instance ( sso Token , server Name ) ; if ( ( to Inherit != null ) && ! to Inherit . is Empty ( ) ) {  Set to Remove = new  Hash Set ( ) ; for (  Iterator i = to Inherit . iterator ( ) ; i . has Next ( ) ; ) {  String name = (  String ) i . next ( ) ; if ( svr Properties . contains Key ( name ) ) { to Remove . add ( name ) ; } } if ( ! to Remove . is Empty ( ) ) {  Server Configuration . remove Server Configuration ( sso Token , server Name , to Remove ) ; } } if ( ( not To Inherit != null ) && ! not To Inherit . is Empty ( ) ) {  Map to Add = new  Hash Map ( ) ; for (  Iterator i = not To Inherit . iterator ( ) ; i . has Next ( ) ; ) {  String name = (  String ) i . next ( ) ; if ( ! svr Properties . contains Key ( name ) ) { to Add . put ( name , default Values . get ( name ) ) ; } } if ( ! to Add . is Empty ( ) ) { try {  Server Configuration . set Server Instance ( sso Token , server Name , to Add ) ; } catch (  Unknown Property Name Exception ex ) { } } } log Event ( _ STR , param ) ; } catch (  Configuration Exception e ) {  String [ ] params = { server Name , e . get Message ( ) } ; log Event ( _ STR , params ) ; throw new  AMConsole Exception ( get Error String ( e ) ) ; } catch (  IOException e ) {  String [ ] params = { server Name , e . get Message ( ) } ; log Event ( _ STR , params ) ; throw new  AMConsole Exception ( get Error String ( e ) ) ; } catch (  SMSException e ) {  String [ ] params = { server Name , e . get Message ( ) } ; log Event ( _ STR , params ) ; throw new  AMConsole Exception ( get Error String ( e ) ) ; } catch (  SSOException e ) {  String [ ] params = { server Name , e . get Message ( ) } ; log Event ( _ STR , params ) ; throw new  AMConsole Exception ( get Error String ( e ) ) ; } }
protected void append ( int value ) { m Message . write ( value ) ; m Position ++ ; }
public boolean contains ( terminal sym ) throws internal_error { not_null ( sym ) ; return _elements . get ( sym . index ( ) ) ; }
private void create Base Node ( ) throws  Keeper Exception ,  Interrupted Exception { if ( null == zk . exists ( zoo Keeper Location , _ BOOL ) ) { zk . create ( zoo Keeper Location , new byte [ _ NUM ] ,  Ids .  OPEN_ ACL_ UNSAFE ,  Create Mode .  PERSISTENT ) ; } }
public void on Call Back (  Bundle bundle ) {  Message msg = m Handler . obtain Message ( bundle . get Int (  Fm Radio Listener .  CALLBACK_ FLAG ) ) ; msg . set Data ( bundle ) ; m Handler . send Message ( msg ) ; }
private  String read Prop Name (  Byte Buffer buffer ) { int name Length = buffer . get Short ( ) ; byte [ ] name Bytes =  Byte Util . get Bytes ( buffer , name Length ) ; return  Column Impl . decode Uncompressed Text ( name Bytes , _database . get Charset ( ) ) ; }
public int hash Code ( ) { if ( myhash == - _ NUM ) { myhash = timestamp . hash Code ( ) + signer Cert Path . hash Code ( ) ; } return myhash ; }
public  Type Variable BV type Variable (  Type Node type Node ) {  Type Variable BV result = type Variable Map . get ( type Node ) ; if ( result == null ) { int id = type Variable List . size ( ) ; type Variable List . add ( null ) ; result = new  Type Variable BV ( id , this , type Node ) ; type Variable List . set ( id , result ) ; type Variable Map . put ( type Node , result ) ; } return result ; }
public int process (  Callback [ ] callbacks , int state ) throws  Auth Login Exception { debug . message ( _ STR ) ; if ( error Msg Key != null ) { debug . message ( _ STR ) ; throw new  Auth Login Exception ( am Auth MSISDN , error Msg Key , null ) ; }  Http Servlet Request req = get Http Servlet Request ( ) ;  String gateway = null ;  String msisdn Number = null ; if ( req != null ) { gateway =  Client Utils . get Client IPAddress ( req ) ; msisdn Number = get MSISDNNumber From Request ( req ) ; } else { debug . message ( _ STR ) ;  Map map = send Callback ( ) ; if ( map != null ) { msisdn Number = (  String ) map . get ( _ STR ) ; gateway = (  String ) map . get ( _ STR ) ; } } if ( is Valid Gateway ( gateway ) && ( msisdn Number != null ) ) {  MSISDNValidation msisdn Validation = new  MSISDNValidation ( options , debug , bundle , locale ) ; user Token Id = msisdn Validation . get User Id ( msisdn Number ) ; store Username Passwd ( user Token Id , null ) ; } else { debug . error ( _ STR ) ; throw new  Auth Login Exception ( am Auth MSISDN , _ STR , null ) ; } return  ISAuth Constants .  LOGIN_ SUCCEED ; }
public static void upto (  Number self ,  Number to , @  Closure Params (  First Param . class )  Closure closure ) { int self1 = self . int Value ( ) ; int to1 = to . int Value ( ) ; if ( self1 <= to1 ) { for ( int i = self1 ; i <= to1 ; i ++ ) { closure . call ( i ) ; } } else throw new  Groovy Runtime Exception ( _ STR + to + _ STR + self + _ STR ) ; }
public void add All (  Collection <  Select Clause Element Raw > elements ) { select Clause Elements . add All ( elements ) ; }
public synchronized void remove Pv Change Listener (  Pv Change Listener l ) { ensure Pv Change Listeners ( ) ;  Pv Change Listeners . remove ( l ) ; allow Events = !  Pv Change Listeners . is Empty ( ) ; log . trace ( _ STR + to String ( ) + _ STR +  String . value Of ( l ) ) ; }
public static  Geo Time Serie b SAX (  Geo Time Serie gts , int alphabet Size , int word Len , int window Len , boolean standardize PAA ) throws  Warp Script Exception { if ( !  GTSHelper . is Bucketized ( gts ) || (  TYPE .  DOUBLE != gts . type &&  TYPE .  LONG != gts . type ) ) { throw new  Warp Script Exception ( _ STR ) ; } if ( window Len % word Len != _ NUM ) { throw new  Warp Script Exception ( _ STR ) ; } int levels = _ NUM ; if ( _ NUM == alphabet Size ) { throw new  Warp Script Exception ( _ STR ) ; } while ( _ NUM == ( alphabet Size & _ NUM ) ) { levels ++ ; alphabet Size >>>= _ NUM ; } if ( _ NUM != alphabet Size ) { throw new  Warp Script Exception ( _ STR ) ; } if ( levels < _ NUM || levels >  SAXUtils .  SAX_ MAX_ LEVELS ) { throw new  Warp Script Exception ( _ STR +  SAXUtils .  SAX_ MAX_ LEVELS ) ; } int paa Len = window Len / word Len ;  GTSHelper . sort ( gts ) ;  Geo Time Serie sax GTS = new  Geo Time Serie ( gts . lastbucket , gts . bucketcount , gts . bucketspan , gts . values ) ; sax GTS . set Metadata ( gts . get Metadata ( ) ) ; int [ ] symbols = new int [ word Len ] ; double paa Sum [ ] = new double [ word Len ] ; for ( int i = _ NUM ; i < gts . values - window Len + _ NUM ; i ++ ) { double sum = _ NUM ; double sumsq = _ NUM ; for ( int w = _ NUM ; w < word Len ; w ++ ) { paa Sum [ w ] = _ NUM ; for ( int k = _ NUM ; k < paa Len ; k ++ ) { paa Sum [ w ] +=  TYPE .  LONG == gts . type ? gts . long Values [ i + w * paa Len + k ] : gts . double Values [ i + w * paa Len + k ] ; } if ( ! standardize PAA ) { continue ; } double mean = paa Sum [ w ] / paa Len ; sum += mean ; sumsq += mean * mean ; } double mu = _ NUM ; double variance = _ NUM ; double sigma = _ NUM ; if ( standardize PAA ) { mu = sum / word Len ; variance = ( sumsq / word Len ) - ( sum * sum ) / ( ( double ) word Len * ( double ) word Len ) ; if ( word Len > _ NUM ) { variance = variance * word Len / ( word Len - _ NUM ) ; } sigma =  Math . sqrt ( variance ) ; } for ( int w = _ NUM ; w < word Len ; w ++ ) { if ( standardize PAA ) { symbols [ w ] =  SAXUtils .  SAX ( levels , sigma != _ NUM ? ( ( paa Sum [ w ] / paa Len ) - mu ) / sigma : ( ( paa Sum [ w ] / paa Len ) - mu ) ) ; } else { symbols [ w ] =  SAXUtils .  SAX ( levels , paa Sum [ w ] / paa Len ) ; } }  String word = new  String (  Order Preserving Base64 . encode (  SAXUtils . b SAX ( levels , symbols ) ) ,  Charsets .  US_ ASCII ) ;  GTSHelper . set Value ( sax GTS , gts . ticks [ i ] , word ) ; } return sax GTS ; }
public void save To Properties (  Properties properties ) { properties . set Property ( _ STR ,  Boolean . to String ( projected ) ) ; properties . set Property ( _ STR ,  String Util . double Array To String ( tie Point ) ) ; properties . set Property ( _ STR ,  String Util . double Array To String ( scale ) ) ; if ( globe == null ) { globe =  Layer Factory . default Globe ; } properties . set Property ( _ STR , globe ) ; properties . set Property ( _ STR ,  Integer . to String ( raster Width ) ) ; properties . set Property ( _ STR ,  Integer . to String ( raster Length ) ) ; properties . set Property ( _ STR , proj Linear Units ) ; if ( datum Code > _ NUM ) { properties . set Property ( _ STR ,  Integer . to String ( datum Code ) ) ; } if ( ellipsoid Code > _ NUM ) { properties . set Property ( _ STR ,  Integer . to String ( ellipsoid Code ) ) ; } if ( !  Double . is Na N ( semi Major Axis ) ) { properties . set Property ( _ STR ,  Double . to String ( semi Major Axis ) ) ; } if ( !  Double . is Na N ( semi Minor Axis ) ) { properties . set Property ( _ STR ,  Double . to String ( semi Minor Axis ) ) ; } if ( !  Double . is Na N ( inverse Flattening ) ) { properties . set Property ( _ STR ,  Double . to String ( inverse Flattening ) ) ; } if ( !  Double . is Na N ( gcs Prime Meridian Lon ) ) { properties . set Property ( _ STR ,  Double . to String ( gcs Prime Meridian Lon ) ) ; } if ( proj Code > _ NUM ) { properties . set Property ( _ STR ,  Integer . to String ( proj Code ) ) ; } if ( pcs Code > _ NUM ) { properties . set Property ( _ STR ,  Integer . to String ( pcs Code ) ) ; } if ( coord Transform Code > _ NUM ) { properties . set Property ( _ STR ,  Integer . to String ( coord Transform Code ) ) ; } if ( !  Double . is Na N ( std Parallel1 ) ) { properties . set Property ( _ STR ,  Double . to String ( std Parallel1 ) ) ; } if ( !  Double . is Na N ( std Parallel2 ) ) { properties . set Property ( _ STR ,  Double . to String ( std Parallel2 ) ) ; } if ( !  Double . is Na N ( natural Origin Lon ) ) { properties . set Property ( _ STR ,  Double . to String ( natural Origin Lon ) ) ; } if ( !  Double . is Na N ( natural Origin Lat ) ) { properties . set Property ( _ STR ,  Double . to String ( natural Origin Lat ) ) ; } if ( !  Double . is Na N ( false Origin Lon ) ) { properties . set Property ( _ STR ,  Double . to String ( false Origin Lon ) ) ; } if ( !  Double . is Na N ( false Origin Lat ) ) { properties . set Property ( _ STR ,  Double . to String ( false Origin Lat ) ) ; } if ( !  Double . is Na N ( false Easting ) ) { properties . set Property ( _ STR ,  Double . to String ( false Easting ) ) ; } if ( !  Double . is Na N ( false Northing ) ) { properties . set Property ( _ STR ,  Double . to String ( false Northing ) ) ; } if ( !  Double . is Na N ( center Easting ) ) { properties . set Property ( _ STR ,  Double . to String ( center Easting ) ) ; } if ( !  Double . is Na N ( center Northing ) ) { properties . set Property ( _ STR ,  Double . to String ( center Northing ) ) ; } if ( !  Double . is Na N ( center Lon ) ) { properties . set Property ( _ STR ,  Double . to String ( center Lon ) ) ; } if ( !  Double . is Na N ( center Lat ) ) { properties . set Property ( _ STR ,  Double . to String ( center Lat ) ) ; } if ( !  Double . is Na N ( scale At Natural Origin ) ) { properties . set Property ( _ STR ,  Double . to String ( scale At Natural Origin ) ) ; } if ( !  Double . is Na N ( scale At Center ) ) { properties . set Property ( _ STR ,  Double . to String ( scale At Center ) ) ; } if ( !  Double . is Na N ( azimuth ) ) { properties . set Property ( _ STR ,  Double . to String ( azimuth ) ) ; } if ( !  Double . is Na N ( straight Vert Pole Lon ) ) { properties . set Property ( _ STR ,  Double . to String ( straight Vert Pole Lon ) ) ; } if ( gcs Citation != null ) { properties . set Property ( _ STR , gcs Citation ) ; } if ( pcs Citation != null ) { properties . set Property ( _ STR , pcs Citation ) ; } }
static public double gamma ( double x ) throws  Arithmetic Exception { double  P [ ] = { _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM } ; double  Q [ ] = { - _ NUM , _ NUM , - _ NUM , _ NUM , _ NUM , - _ NUM , _ NUM , _ NUM } ; double p , z ; int i ; double q =  Math . abs ( x ) ; if ( q > _ NUM ) { if ( x < _ NUM ) { p =  Math . floor ( q ) ; if ( p == q ) throw new  Arithmetic Exception ( _ STR ) ; i = ( int ) p ; z = q - p ; if ( z > _ NUM ) { p += _ NUM ; z = q - p ; } z = q *  Math . sin (  Math .  PI * z ) ; if ( z == _ NUM ) throw new  Arithmetic Exception ( _ STR ) ; z =  Math . abs ( z ) ; z =  Math .  PI / ( z * stirling Formula ( q ) ) ; return - z ; } else { return stirling Formula ( x ) ; } } z = _ NUM ; while ( x >= _ NUM ) { x -= _ NUM ; z *= x ; } while ( x < _ NUM ) { if ( x == _ NUM ) { throw new  Arithmetic Exception ( _ STR ) ; } else if ( x > - _ NUM ) { return ( z / ( ( _ NUM + _ NUM * x ) * x ) ) ; } z /= x ; x += _ NUM ; } while ( x < _ NUM ) { if ( x == _ NUM ) { throw new  Arithmetic Exception ( _ STR ) ; } else if ( x < _ NUM ) { return ( z / ( ( _ NUM + _ NUM * x ) * x ) ) ; } z /= x ; x += _ NUM ; } if ( ( x == _ NUM ) || ( x == _ NUM ) ) return z ; x -= _ NUM ; p =  Polynomial . polevl ( x ,  P , _ NUM ) ; q =  Polynomial . polevl ( x ,  Q , _ NUM ) ; return z * p / q ; }
public  Time Stamp ( ) { start =  System . current Time Millis ( ) ; }
@  Inject public  Aggregator Parsers (  Set <  Aggregator .  Parser > agg Parsers ,  Set <  Pipeline Aggregator .  Parser > pipeline Aggregator Parsers ) {  Map Builder <  String ,  Aggregator .  Parser > agg Parsers Builder =  Map Builder . new Map Builder ( ) ; for (  Aggregator .  Parser parser : agg Parsers ) { agg Parsers Builder . put ( parser . type ( ) , parser ) ; } this . agg Parsers = agg Parsers Builder . immutable Map ( ) ;  Map Builder <  String ,  Pipeline Aggregator .  Parser > pipeline Aggregator Parsers Builder =  Map Builder . new Map Builder ( ) ; for (  Pipeline Aggregator .  Parser parser : pipeline Aggregator Parsers ) { pipeline Aggregator Parsers Builder . put ( parser . type ( ) , parser ) ; } this . pipeline Aggregator Parsers = pipeline Aggregator Parsers Builder . immutable Map ( ) ; }
@  Override public synchronized void close ( ) throws  IOException { buffer = null ; is Closed = _ BOOL ; notify All ( ) ; }
public  Builder add Section (  Section Builder section ) { m Sections . add ( section ) ; return this ; }
public static  Genome Relationships load (  Buffered Reader reader ) throws  IOException { final  Genome Relationships ped = new  Genome Relationships ( ) ;  String line ; while ( ( line = reader . read Line ( ) ) != null ) { line = line . trim ( ) ; if ( line . starts With ( _ STR ) || line . matches ( _ STR ) ) { continue ; } parse Ped Line ( ped , line ) ; } return ped ; }
public static int [ ] parse Int Array ( int [ ] dest ,  String value ) {  String [ ] parts = value . split ( _ STR ) ; if ( dest == null ) { dest = new int [ parts . length ] ; } for ( int i = _ NUM ; i < dest . length ; i ++ ) { dest [ i ] =  Integer . parse Int ( parts [ i ] ) ; } return dest ; }
public static boolean assert Equals ( final double a , final double b ) { if (  Double . is Na N ( a ) &&  Double . is Na N ( b ) ) { return _ BOOL ; } if ( a == b ) { return _ BOOL ; } throw new  Exam Exception ( a + _ STR + b ) ; }
public static  Map <  String ,  Object > read Json Model (  File js File ) throws  IOException { try (  Buffered Reader reader = new  Buffered Reader ( new  File Reader ( js File ) ) ) {  String line = null ; while ( ( line = reader . read Line ( ) ) != null ) { if ( ( line . starts With ( _ STR ) || line . starts With ( _ STR ) || line . starts With ( _ STR ) || line . starts With ( _ STR ) ) && line . ends With ( _ STR ) ) { line = line . substring ( line . index Of ( _ STR ) , line . length ( ) - _ NUM ) ; @  Suppress Warnings ( _ STR )  Map <  String ,  Object > rv = (  Map <  String ,  Object > )  JSONValue . parse ( line ) ; return rv ; } } return null ; } }
public int [ ] read Turn Overflow Absolute ( ) throws  IOException {  String line = br . read Line ( ) ; while ( line != null ) { if ( line . matches ( _ STR ) ) { return split Line ( line ) ; } line = br . read Line ( ) ; } return null ; }
private  List <  Volume > create Block Volumes (  String volume Name , int num Volumes ,  URI storage System ) {  List <  Volume > volumes = new  Array List <  Volume > ( ) ; for ( int i = _ NUM ; i <= num Volumes ; i ++ ) {  Volume volume = new  Volume ( ) ;  URI volume URI =  URIUtil . create Id (  Volume . class ) ; block Volume URIs . add ( volume URI ) ; volume . set Id ( volume URI ) ; volume . set Label ( volume Name + i ) ; volume . set Storage Controller ( storage System ) ; _db Client . create Object ( volume ) ; volumes . add ( volume ) ; } return volumes ; }
@  Suppress Warnings ( _ STR ) private <  T >  T read By Class (  Buffer Input < ? > buffer ) {  String name = buffer . read UTF8 ( ) ; if ( whitelist Required . get ( ) ) throw new  Serialization Exception ( _ STR + name ) ;  Class <  T > type = (  Class <  T > ) types . get ( name ) ; if ( type == null ) { try { type = (  Class <  T > )  Class . for Name ( name ) ; if ( type == null ) throw new  Serialization Exception ( _ STR ) ; types . put ( name , type ) ; } catch (  Class Not Found Exception e ) { throw new  Serialization Exception ( _ STR + name , e ) ; } }  Type Serializer <  T > serializer = get Serializer ( type ) ; if ( serializer == null ) throw new  Serialization Exception ( _ STR + name ) ; return serializer . read ( type , buffer , this ) ; }
private void search SMS (  String message ,  String contact Name ) {  Array List <  Contact > contacts ; send (  R . string . chat_sms_search_start ) ; contacts =  Contacts Manager . get Matching Contacts ( s Context , contact Name ) ; if ( contacts . size ( ) > _ NUM ) { send (  R . string . chat_sms_search , message , contacts . size ( ) ) ; for (  Contact contact : contacts ) {  Array List <  Sms > sms List = m Sms Manager . get Sms (  Contacts Manager . get Phones ( s Context , contact . ids ) , message ) ;  Collections . sort ( sms List ) ; if ( sms List . size ( ) > _ NUM ) { send Sms List On Xmpp ( sms List , contact . name , null ) ; } } send ( _ STR ) ; } else { send (  R . string . chat_no_match_for , message ) ; } }
static int [ ] find Nanp Phone Numbers (  Char Sequence text ) {  Array List <  Integer > list = new  Array List <  Integer > ( ) ; int start Pos = _ NUM ; int end Pos = text . length ( ) -  NANP_ MIN_ DIGITS + _ NUM ; if ( end Pos < _ NUM ) { return new int [ ] { } ; } while ( start Pos < end Pos ) { while (  Character . is Whitespace ( text . char At ( start Pos ) ) && start Pos < end Pos ) { start Pos ++ ; } if ( start Pos == end Pos ) { break ; } int match End = find Nanp Match End ( text , start Pos ) ; if ( match End > start Pos ) { list . add ( start Pos ) ; list . add ( match End ) ; start Pos = match End ; } else { while ( !  Character . is Whitespace ( text . char At ( start Pos ) ) && start Pos < end Pos ) { start Pos ++ ; } } } int [ ] result = new int [ list . size ( ) ] ; for ( int i = list . size ( ) - _ NUM ; i >= _ NUM ; i -- ) { result [ i ] = list . get ( i ) ; } return result ; }
public boolean check Error ( ) {  Writer delegate = out ; if ( delegate == null ) { return io Error ; } flush ( ) ; return io Error || delegate . check Error ( ) ; }
public  List <  Pdf Document > extract Page Ranges (  List <  Page Range > page Ranges ) {  List <  Pdf Document > split Documents = new  Array List < > ( ) ; for (  Page Range current Page Range : page Ranges ) {  Pdf Document current Pdf Document = create Pdf Document ( current Page Range ) ; split Documents . add ( current Pdf Document ) ; pdf Document . copy Pages To ( current Page Range . get All Pages ( ) , current Pdf Document ) ; } return split Documents ; }
private boolean validate Properties ( ) throws  Policy Exception { if ( ( properties == null ) || ( properties . key Set ( ) == null ) ) { throw new  Policy Exception (  Res Bundle Utils . rb Name , _ STR , null , null ) ; }  Set key Set = properties . key Set ( ) ; if ( ! key Set . contains (  AUTHENTICATE_ TO_ REALM ) ) {  String args [ ] = {  AUTHENTICATE_ TO_ REALM } ; throw new  Policy Exception (  Res Bundle Utils . rb Name , _ STR , args , null ) ; }  Iterator keys = key Set . iterator ( ) ; while ( keys . has Next ( ) ) {  String key = (  String ) keys . next ( ) ; if ( !  AUTHENTICATE_ TO_ REALM . equals ( key ) ) {  String args [ ] = { key } ; throw new  Policy Exception (  Res Bundle Utils . rb Name , _ STR , args , null ) ; } }  Set authn To Realm Set = null ; try { authn To Realm Set = (  Set ) properties . get (  AUTHENTICATE_ TO_ REALM ) ; } catch (  Class Cast Exception e ) {  String args [ ] = {  REQUEST_ AUTHENTICATED_ TO_ REALMS } ; throw new  Policy Exception (  Res Bundle Utils . rb Name , _ STR , args , e ) ; } if ( authn To Realm Set != null ) { validate Authn To Realms ( authn To Realm Set ) ; } return _ BOOL ; }
public static void check Operational Pattern1 ACompliance (  List <  Partition Pack > partition Packs ) {  IMFError Logger imf Error Logger = new  IMFError Logger Impl ( ) ; for (  Partition Pack partition Pack : partition Packs ) { byte [ ] bytes = partition Pack . get Operational Pattern ( ) ; for ( int i = _ NUM ; i < bytes . length ; i ++ ) { if ( (  MXFOperational Pattern1 A .  OPERATIONAL_ PATTERN1 A_ KEY_ MASK [ i ] != _ NUM ) && (  MXFOperational Pattern1 A .  OPERATIONAL_ PATTERN1 A_ KEY [ i ] != bytes [ i ] ) ) { imf Error Logger . add Error (  IMFError Logger .  IMFErrors .  Error Codes .  IMF_ ESSENCE_ COMPONENT_ ERROR ,  IMFError Logger .  IMFErrors .  Error Levels .  FATAL ,  MXFOperational Pattern1 A .  OP1 A_ EXCEPTION_ PREFIX +  String . format ( _ STR , bytes [ i ] , i ,  MXFOperational Pattern1 A .  OPERATIONAL_ PATTERN1 A_ KEY [ i ] ) ) ; } } if ( partition Pack . get Number Of Essence Container ULs ( ) < _ NUM ) { imf Error Logger . add Error (  IMFError Logger .  IMFErrors .  Error Codes .  IMF_ ESSENCE_ COMPONENT_ ERROR ,  IMFError Logger .  IMFErrors .  Error Levels .  FATAL ,  MXFOperational Pattern1 A .  OP1 A_ EXCEPTION_ PREFIX +  String . format ( _ STR , partition Pack . get Number Of Essence Container ULs ( ) ) ) ; } } if ( imf Error Logger . has Fatal Errors ( ) ) { throw new  MXFException (  String . format ( _ STR ) , imf Error Logger ) ; } }
public static  String read Line ( ) {  String line ; try { line = scanner . next Line ( ) ; } catch (  No Such Element Exception e ) { line = null ; } return line ; }
public static byte [ ] decode (  String s ) { return decode ( s ,  NO_ OPTIONS ) ; }
public static void fill And Draw Rect (  Graphics2 D gc , double x , double y , double width , double height , double label Angle ,  Color fill Color ,  Color draw Color ) {  Dimension the Size = new  Dimension ( ( int )  Math . round ( width ) , ( int )  Math . round ( height ) ) ;  Point2 D apt = new  Point2 D .  Float ( ( float ) x , ( float ) y ) ;  Affine Transform save Transform = gc . get Transform ( ) ; if ( label Angle >= _ NUM *  Math .  PI && label Angle <= _ NUM *  Math .  PI ) { apt =  Geometry . translate By Angle ( apt , label Angle , the Size . get Width ( ) ) ; gc . rotate (  Geometry . modulo Two PI ( label Angle -  Math .  PI ) , apt . get X ( ) , apt . get Y ( ) ) ; } else { gc . rotate ( label Angle , apt . get X ( ) , apt . get Y ( ) ) ; } gc . set Color ( fill Color ) ; gc . fill Rect ( ( int )  Math . round ( apt . get X ( ) ) , ( int )  Math . round ( apt . get Y ( ) ) - the Size . height , the Size . width , the Size . height ) ; gc . set Color ( draw Color ) ; gc . draw Rect ( ( int )  Math . round ( apt . get X ( ) ) , ( int )  Math . round ( apt . get Y ( ) ) - the Size . height , the Size . width , the Size . height ) ; gc . set Transform ( save Transform ) ; }
public static  List <  String > match Description Classes (  String desc ) {  String pattern = _ STR ;  Pattern pat =  Pattern . compile ( pattern ) ;  Matcher m = pat . matcher ( desc ) ;  List <  String > matches = new  Array List <  String > ( ) ; while ( m . find ( ) ) { matches . add ( m . group ( ) ) ; } return matches ; }
public  Struct Storage Stat [ ] list Storages (  Tracker Server tracker Server ,  String group Name ,  String storage Ip Addr ) throws  IOException { byte [ ] header ; byte [ ] b Group Name ; byte [ ] bs ; int len ; boolean b New Connection ;  Socket tracker Socket ; if ( tracker Server == null ) { tracker Server = get Connection ( ) ; if ( tracker Server == null ) { return null ; } b New Connection = _ BOOL ; } else { b New Connection = _ BOOL ; } tracker Socket = tracker Server . get Socket ( ) ;  Output Stream out = tracker Socket . get Output Stream ( ) ; try { bs = group Name . get Bytes (  Client Global . g_charset ) ; b Group Name = new byte [  Proto Common .  FDFS_ GROUP_ NAME_ MAX_ LEN ] ; if ( bs . length <=  Proto Common .  FDFS_ GROUP_ NAME_ MAX_ LEN ) { len = bs . length ; } else { len =  Proto Common .  FDFS_ GROUP_ NAME_ MAX_ LEN ; }  Arrays . fill ( b Group Name , ( byte ) _ NUM ) ;  System . arraycopy ( bs , _ NUM , b Group Name , _ NUM , len ) ; int ip Addr Len ; byte [ ] b Ip Addr ; if ( storage Ip Addr != null && storage Ip Addr . length ( ) > _ NUM ) { b Ip Addr = storage Ip Addr . get Bytes (  Client Global . g_charset ) ; if ( b Ip Addr . length <  Proto Common .  FDFS_ IPADDR_ SIZE ) { ip Addr Len = b Ip Addr . length ; } else { ip Addr Len =  Proto Common .  FDFS_ IPADDR_ SIZE - _ NUM ; } } else { b Ip Addr = null ; ip Addr Len = _ NUM ; } header =  Proto Common . pack Header (  Proto Common .  TRACKER_ PROTO_ CMD_ SERVER_ LIST_ STORAGE ,  Proto Common .  FDFS_ GROUP_ NAME_ MAX_ LEN + ip Addr Len , ( byte ) _ NUM ) ; byte [ ] whole Pkg = new byte [ header . length + b Group Name . length + ip Addr Len ] ;  System . arraycopy ( header , _ NUM , whole Pkg , _ NUM , header . length ) ;  System . arraycopy ( b Group Name , _ NUM , whole Pkg , header . length , b Group Name . length ) ; if ( ip Addr Len > _ NUM ) {  System . arraycopy ( b Ip Addr , _ NUM , whole Pkg , header . length + b Group Name . length , ip Addr Len ) ; } out . write ( whole Pkg ) ;  Proto Common .  Recv Package Info pkg Info =  Proto Common . recv Package ( tracker Socket . get Input Stream ( ) ,  Proto Common .  TRACKER_ PROTO_ CMD_ RESP , - _ NUM ) ; this . errno = pkg Info . errno ; if ( pkg Info . errno != _ NUM ) { return null ; }  Proto Struct Decoder <  Struct Storage Stat > decoder = new  Proto Struct Decoder <  Struct Storage Stat > ( ) ; return decoder . decode ( pkg Info . body ,  Struct Storage Stat . class ,  Struct Storage Stat . get Fields Total Size ( ) ) ; } catch (  IOException ex ) { if ( ! b New Connection ) { try { tracker Server . close ( ) ; } catch (  IOException ex1 ) { ex1 . print Stack Trace ( ) ; } } throw ex ; } catch (  Exception ex ) { ex . print Stack Trace ( ) ; this . errno =  Proto Common .  ERR_ NO_ EINVAL ; return null ; } finally { if ( b New Connection ) { try { tracker Server . close ( ) ; } catch (  IOException ex1 ) { ex1 . print Stack Trace ( ) ; } } } }
@  Override public  UUID create Exit Node (  UUID parent Node ) {  UUID uuid =  UUID . random UUID ( ) ; graph Server . add Vertex ( uuid ) ; graph Server . add Edge ( parent Node , uuid ) ; exit Node Map . put ( uuid , parent Node ) ; return uuid ; }
public static void write Tag Dict ( final  Map <  String ,  Collection <  Category > > tag Dict , final  File file ) throws  File Not Found Exception ,  Unsupported Encoding Exception { final  Print Writer writer = new  Print Writer ( file , _ STR ) ; for ( final java . util .  Map .  Entry <  String ,  Collection <  Category > > entry : tag Dict . entry Set ( ) ) { writer . print ( entry . get Key ( ) ) ; for ( final  Category c : entry . get Value ( ) ) { writer . print ( _ STR + c . to String ( ) ) ; } writer . println ( ) ; } writer . close ( ) ; }
private  Injector create Injector For ( final  Class < ? > [ ] classes ) throws  Initialization Error { final  List <  Module > modules = new  Array List < > ( ) ; if ( classes != null ) { for ( final  Class < ? > module :  Arrays . as List ( classes ) ) { try { modules . add ( (  Module ) module . new Instance ( ) ) ; } catch ( final  Reflective Operation Exception exception ) { throw new  Initialization Error ( exception ) ; } } } return  Guice . create Injector ( modules ) ; }
public static void store Image (  Bitmap image ,  File picture File ) { if ( picture File == null ) {  Log . d (  TAG , _ STR ) ; return ; } try {  File Output Stream fos = new  File Output Stream ( picture File ) ; image . compress (  Bitmap .  Compress Format .  PNG , _ NUM , fos ) ; fos . close ( ) ; } catch (  File Not Found Exception e ) {  Log . d (  TAG , _ STR + e . get Message ( ) ) ; } catch (  IOException e ) {  Log . d (  TAG , _ STR + e . get Message ( ) ) ; } }
protected  Conversation Parser ( final  Sentence Implementation sentence ) {  String text = sentence . get Original Text ( ) ; if ( text == null ) { text = _ STR ; } else if ( text . starts With ( _ STR ) ) { text = _ STR ; } final  String text Without Punctation = detect Sentence Type ( text , sentence ) ; tokenizer = new  String Tokenizer ( text Without Punctation ) ; }
protected int hash (  Object key1 ,  Object key2 ,  Object key3 ,  Object key4 ) { int h = _ NUM ; if ( key1 != null ) { h ^= key1 . hash Code ( ) ; } if ( key2 != null ) { h ^= key2 . hash Code ( ) ; } if ( key3 != null ) { h ^= key3 . hash Code ( ) ; } if ( key4 != null ) { h ^= key4 . hash Code ( ) ; } h += ~ ( h << _ NUM ) ; h ^= ( h > > > _ NUM ) ; h += ( h << _ NUM ) ; h ^= ( h > > > _ NUM ) ; return h ; }
public void flush ( ) throws java . io .  IOException { flush Buffer ( ) ; m_os . flush ( ) ; }
private void add Json For Entry ( final  String Builder result ,  Entry entry , boolean include Just Text Fields , boolean include User Was Sign In , boolean user Was Signed In , boolean force Quotation To Note ) throws  IOException { result . append ( _ STR +  Json Builder . quote ( entry . get Note Or Title ( _ STR ) ) + _ STR ) ; result . append ( _ STR +  Json Builder . quote ( entry . get Quotation ( _ STR ) ) + _ STR ) ; result . append ( _ STR + entry . get Is Public ( ) + _ STR ) ;  String type To Add = entry . get Type ( ) ; if ( type To Add . equals (  Db Logic .  Constants . quotation ) ) { type To Add =  Db Logic .  Constants . note ; } result . append ( _ STR + type To Add + _ STR ) ; if ( include User Was Sign In ) { result . append ( _ STR + user Was Signed In + _ STR ) ; } if ( include Just Text Fields ) { result . append ( _ STR +  Json Builder . quote ( get Note Html ( entry , _ BOOL , entry . has Quotation ( ) , _ BOOL ) ) + _ STR ) ; result . append ( _ STR +  Json Builder . quote ( get Quotation Html ( entry , _ BOOL ) ) + _ STR ) ; } else { final  String Builder inner Result = new  String Builder ( ) ; add Entry Html To Tree Simple ( entry , inner Result , null , _ NUM , ! entry . is Notebook ( ) ) ; result . append ( _ STR +  Json Builder . quote ( inner Result . to String ( ) ) + _ STR ) ; } }
protected  Panel State find Nearest Panel State From Height ( float desired Panel Height ) {  Panel State closest Panel State =  Panel State .  CLOSED ; float smallest Height Diff =  Float .  POSITIVE_ INFINITY ; for (  Panel State state :  Panel State . values ( ) ) { if ( ! is Valid State ( state ) ) { continue ; } if ( ! is Fullscreen Size Panel ( ) && state ==  Panel State .  EXPANDED ) { continue ; } float height = get Panel Height From State ( state ) ; float height Diff =  Math . abs ( desired Panel Height - height ) ; if ( height Diff < smallest Height Diff ) { closest Panel State = state ; smallest Height Diff = height Diff ; } } return closest Panel State ; }
public boolean save Configuration ( final  String path ) { if ( xml Config != null && ! errors . has Failed ( ) ) { boolean success = _ BOOL ;  File Writer writer = null ; try { writer = new  File Writer ( path ) ; writer . write ( xml Config . to String ( ) ) ; writer . flush ( ) ; } catch (  IOException ioe ) { ioe . print Stack Trace ( ) ; success = _ BOOL ; } finally { if ( writer != null ) { try { writer . close ( ) ; } catch (  IOException ioe ) { success = _ BOOL ; } } } return success ; } return _ BOOL ; }
public boolean content Equals (  Char Sequence chars ) { if ( chars == null ) return _ BOOL ; if ( this . _length != chars . length ( ) ) return _ BOOL ; for ( int i = _length , j = _offset + _length ; -- i >= _ NUM ; ) { if ( _array [ -- j ] != chars . char At ( i ) ) return _ BOOL ; } return _ BOOL ; }
protected void end ( ) { stream . println ( _ STR ) ; flush ( ) ; }
Thread new Started Thread (  Runnable runnable ) {  Thread t = new  Thread ( runnable ) ; t . set Daemon ( _ BOOL ) ; t . start ( ) ; return t ; }
public boolean is Shareable (  Class < ? > entity Class ) { return get Annotation ( entity Class ,  Share Permission . class ) != null ; }
public void deregister Service Provider (  Object provider ) { if ( provider == null ) { throw new  Illegal Argument Exception ( _ STR ) ; }  Iterator regs = get Sub Registries ( provider ) ; while ( regs . has Next ( ) ) {  Sub Registry reg = (  Sub Registry ) regs . next ( ) ; reg . deregister Service Provider ( provider ) ; } }
private synchronized boolean should Garbage Collect Peer (  Peer peer ) {  Date last Seen = peer . get Last Seen ( ) ;  Date now = new  Date ( ) ; long ms Since Seen = now . get Time ( ) - last Seen . get Time ( ) ; return ms Since Seen >  PEER_ TIMEOUT ; }
private void layout Item (  MTab Bar Item item ,  IStyle Provider styles ) { int content X = item . content Bounds . x + item . margin Width ; int content Y = item . content Bounds . y + item . margin Height ; int content Width = item . content Bounds . width - item . margin Width - item . margin Width ; int content Height = item . content Bounds . height - item . margin Height - item . margin Height ; if ( item . image Visible && item . text Visible ) { boolean item Vertical = ( item . text Position & (  SWT .  TOP |  SWT .  BOTTOM ) ) != _ NUM ; boolean image Leading = ( item . text Position & (  SWT .  RIGHT |  SWT .  BOTTOM ) ) != _ NUM ;  Point image Size = item . image Visible ? compute Image Size ( item . get Image ( ) ) : new  Point ( _ NUM , _ NUM ) ;  Point text Size = item . text Visible ? compute Text Size ( item . get Text ( ) , item . font ) : new  Point ( _ NUM , _ NUM ) ; int image WHint = styles . get Width ( item ,  MTab Bar Item .  IMAGE , item Vertical ? content Width :  SWT .  DEFAULT ) ; int image HHint = styles . get Height ( item ,  MTab Bar Item .  IMAGE , item Vertical ?  SWT .  DEFAULT : content Height ) ; int text WHint = styles . get Width ( item ,  MTab Bar Item .  TEXT , item Vertical ? content Width :  SWT .  DEFAULT ) ; int text HHint = styles . get Height ( item ,  MTab Bar Item .  TEXT , item Vertical ?  SWT .  DEFAULT : content Height ) ;  Point image Area Size = item . image Visible ? compute Preferred Size ( image Size . x , image Size . y , image WHint , image HHint ) : new  Point ( _ NUM , _ NUM ) ;  Point text Area Size = item . text Visible ? compute Preferred Size ( text Size . x , text Size . y , text WHint , text HHint ) : new  Point ( _ NUM , _ NUM ) ; if ( item Vertical ) { if ( image HHint > _ NUM && text HHint < _ NUM ) { text Area Size . y =  Math . max ( _ NUM , content Height - image Area Size . y - item . v Spacing ) ; } else if ( image HHint < _ NUM && text HHint > _ NUM ) { image Area Size . y =  Math . max ( _ NUM , content Height - text Area Size . y - item . v Spacing ) ; } } else { if ( image WHint > _ NUM && text WHint < _ NUM ) { text Area Size . x =  Math . max ( _ NUM , content Width - image Area Size . x - item . h Spacing ) ; } else if ( image WHint < _ NUM && text WHint > _ NUM ) { image Area Size . x =  Math . max ( _ NUM , content Width - text Area Size . x - item . h Spacing ) ; } } image Size = compute Constrained Size ( image Size . x , image Size . y , image Area Size . x , image Area Size . y ) ; text Size = compute Constrained Size ( text Size . x , text Size . y , text Area Size . x , text Area Size . y ) ; if ( item Vertical ) { item . image Bounds . x = content X + ( content Width - image Size . x ) / _ NUM ; item . image Bounds . y = content Y + ( image Area Size . y - image Size . y ) / _ NUM ; item . text Bounds . x = content X + ( content Width - text Size . x ) / _ NUM ; item . text Bounds . y = content Y + ( text Area Size . y - text Size . y ) / _ NUM ; if ( image Leading ) { item . text Bounds . y += image Area Size . y + item . v Spacing ; } else { item . image Bounds . y += text Area Size . y + item . v Spacing ; } } else { item . image Bounds . x = content X + ( image Area Size . x - image Size . x ) / _ NUM ; item . image Bounds . y = content Y + ( content Height - image Size . y ) / _ NUM ; item . text Bounds . x = content X + ( text Area Size . x - text Size . x ) / _ NUM ; item . text Bounds . y = content Y + ( text Area Size . y - text Size . y ) / _ NUM ; if ( image Leading ) { item . text Bounds . x += image Area Size . x + item . h Spacing ; } else { item . image Bounds . x += text Area Size . x + item . h Spacing ; } } item . image Bounds . width = image Size . x ; item . image Bounds . height = image Size . y ; item . text Bounds . width = text Size . x ; item . text Bounds . height = text Size . y ; } else if ( item . image Visible ) {  Point image Size = compute Image Size ( item . get Image ( ) ) ;  Point constrained Size = compute Constrained Size ( image Size . x , image Size . y , content Width , content Height ) ; item . image Bounds . x = content X + ( content Width - constrained Size . x ) / _ NUM ; item . image Bounds . y = content Y + ( content Height - constrained Size . y ) / _ NUM ; item . image Bounds . width = constrained Size . x ; item . image Bounds . height = constrained Size . y ; item . text Bounds . x = _ NUM ; item . text Bounds . y = _ NUM ; item . text Bounds . width = _ NUM ; item . text Bounds . height = _ NUM ; } else if ( item . text Visible ) {  Point text Size = compute Text Size ( item . get Text ( ) , item . font ) ;  Point constrained Size = compute Constrained Size ( text Size . x , text Size . y , content Width , content Height ) ; item . image Bounds . x = _ NUM ; item . image Bounds . y = _ NUM ; item . image Bounds . width = _ NUM ; item . image Bounds . height = _ NUM ; item . text Bounds . x = content X + ( content Width - constrained Size . x ) / _ NUM ; item . text Bounds . y = content Y + ( content Height - constrained Size . y ) / _ NUM ; item . text Bounds . width = constrained Size . x ; item . text Bounds . height = constrained Size . y ; } else { item . image Bounds . x = _ NUM ; item . image Bounds . y = _ NUM ; item . image Bounds . width = _ NUM ; item . image Bounds . height = _ NUM ; item . text Bounds . x = _ NUM ; item . text Bounds . y = _ NUM ; item . text Bounds . width = _ NUM ; item . text Bounds . height = _ NUM ; } }
public void write Field (  String name , int value ) throws java . io .  IOException { write Field ( name ,  Integer . to String ( value ) ) ; }
public byte [ ] encode Data ( byte [ ] data , int num Error Correction Bytes ) throws  Data Too Large Exception { if ( data == null || data . length == _ NUM ) { return null ; } if ( ( data . length + num Error Correction Bytes ) > _ NUM ) { throw new  Data Too Large Exception ( _ STR ) ; } int total Bytes = num Error Correction Bytes + data . length ; int [ ] data Ints = new int [ total Bytes ] ; for ( int i = _ NUM ; i < data . length ; i ++ ) { data Ints [ i ] = data [ i ] & _ NUM ; } encoder . encode ( data Ints , num Error Correction Bytes ) ;  Byte Array Output Stream bos = new  Byte Array Output Stream ( ) ; for ( int i : data Ints ) { bos . write ( i ) ; } return bos . to Byte Array ( ) ; }
public static  List <  String > split Lines (  String s ) {  Array List ret = new  Array List ( ) ;  String [ ] split = s . split ( _ STR ) ; ret . add All (  Arrays . as List ( split ) ) ; return ret ; }
public void on Configuration Changed ( ) { int cur First = pager . get Current Screen ( ) *  PAGE_ SIZE ; cal Page Size ( ) ; int new Page = cur First /  PAGE_ SIZE ; remove View At ( _ NUM ) ; after Platform List Got ( ) ; pager . set Current Screen ( new Page ) ; }
public boolean is Valid Contact (  String contact ) throws  Rcs Permission Denied Exception { if (  Text Utils . is Empty ( contact ) ) { return _ BOOL ; }  String stripped Contact = strip Separators ( contact ) ; if (  Text Utils . is Empty ( stripped Contact ) ) { return _ BOOL ; } if ( stripped Contact . starts With (  COUNTRY_ CODE_ PREFIX ) ) { return _ BOOL ; } if ( stripped Contact . starts With (  MSISDN_ PREFIX_ INTERNATIONAL ) ) { return _ BOOL ; } if ( m Country Code == null ) { try To Determine And Cache Country And Area Codes ( ) ; } return  Text Utils . is Empty ( m Country Area Code ) || stripped Contact . starts With ( m Country Area Code ) ; }
boolean add (  String src Filename , int src Line , int dst Line , boolean is Prefer Last ) { if ( _src Filename != null && ( ! _src Filename . equals ( src Filename ) || src Filename == null ) ) return _ BOOL ; if ( dst Line <= _dst Line ) { if ( ! is Prefer Last ) return _ BOOL ; else if ( _dst Increment == _ NUM && _repeat == _ NUM ) { _src Line = src Line ; return _ BOOL ; } else if ( _repeat > _ NUM ) { _repeat -- ; return _ BOOL ; } else if ( _dst Increment > _ NUM ) { _dst Increment -- ; return _ BOOL ; } else return _ BOOL ; } if ( src Line == _src Line ) { _dst Increment = dst Line - _dst Line + _ NUM ; return _ BOOL ; } else if ( dst Line - _dst Line == ( src Line - _src Line ) * _dst Increment ) { _repeat = src Line - _src Line + _ NUM ; return _ BOOL ; } else if ( src Line == _src Line + _ NUM && _repeat == _ NUM ) { _dst Increment = dst Line - _dst Line ; return _ BOOL ; } return _ BOOL ; }
public void add Notification ( @  Not Null  Notification notification ) { notifications . add ( notification ) ;  Notification Container Item item = new  Notification Container Item ( notification , resources ) ; item . set Delegate ( this ) ; int index = n Grid . get Row Count ( ) ; n Grid . resize Rows ( index + _ NUM ) ; n Grid . set Widget ( index , _ NUM , item ) ; }
@  Override public boolean print Dialog ( ) throws  Headless Exception { if (  Graphics Environment . is Headless ( ) ) { throw new  Headless Exception ( ) ; } if ( attributes == null ) { attributes = new  Hash Print Request Attribute Set ( ) ; } if ( ! ( get Print Service ( ) instanceof  Win32 Print Service ) ) { return super . print Dialog ( attributes ) ; } if ( no Default Printer == _ BOOL ) { return _ BOOL ; } else { return display Native Dialog ( ) ; } }
private static void process Annotations In Class ( boolean key ,  Class < ? > cls ,  Type Descriptor type , @  Nullable  Class Property parent ) { if (  U . is Jdk ( cls ) || is Geometry Class ( cls ) ) { if ( parent == null && ! key && is Sql Type ( cls ) ) {  String idx Name = _ VAL + _ STR ; type . add Index ( idx Name , is Geometry Class ( cls ) ?  GEO_ SPATIAL :  SORTED ) ; type . add Field To Index ( idx Name , _ VAL , _ NUM , _ BOOL ) ; } return ; } if ( parent != null && parent . knows Class ( cls ) ) throw new  Cache Exception ( _ STR + cls . get Name ( ) ) ; if ( parent == null ) {  Query Text Field txt Ann Cls = cls . get Annotation (  Query Text Field . class ) ; if ( txt Ann Cls != null ) type . value Text Index ( _ BOOL ) ;  Query Group Index grp Idx = cls . get Annotation (  Query Group Index . class ) ; if ( grp Idx != null ) type . add Index ( grp Idx . name ( ) ,  SORTED ) ;  Query Group Index .  List grp Idx List = cls . get Annotation (  Query Group Index .  List . class ) ; if ( grp Idx List != null && !  F . is Empty ( grp Idx List . value ( ) ) ) { for (  Query Group Index idx : grp Idx List . value ( ) ) type . add Index ( idx . name ( ) ,  SORTED ) ; } } for (  Class < ? > c = cls ; c != null && ! c . equals (  Object . class ) ; c = c . get Superclass ( ) ) { for (  Field field : c . get Declared Fields ( ) ) {  Query Sql Field sql Ann = field . get Annotation (  Query Sql Field . class ) ;  Query Text Field txt Ann = field . get Annotation (  Query Text Field . class ) ; if ( sql Ann != null || txt Ann != null ) {  Class Property prop = new  Class Property ( field ) ; prop . parent ( parent ) ; process Annotation ( key , sql Ann , txt Ann , field . get Type ( ) , prop , type ) ; type . add Property ( prop , _ BOOL ) ; } } for (  Method mtd : c . get Declared Methods ( ) ) { if ( mtd . is Bridge ( ) ) continue ;  Query Sql Field sql Ann = mtd . get Annotation (  Query Sql Field . class ) ;  Query Text Field txt Ann = mtd . get Annotation (  Query Text Field . class ) ; if ( sql Ann != null || txt Ann != null ) { if ( mtd . get Parameter Types ( ) . length != _ NUM ) throw new  Cache Exception ( _ STR + _ STR + mtd ) ;  Class Property prop = new  Class Property ( mtd ) ; prop . parent ( parent ) ; process Annotation ( key , sql Ann , txt Ann , mtd . get Return Type ( ) , prop , type ) ; type . add Property ( prop , _ BOOL ) ; } } } }
public void encode Params ( ) { for (  Map .  Entry <  String ,  String > e : params . entry Set ( ) ) { try { params . put ( e . get Key ( ) ,  URLEncoder . encode ( e . get Value ( ) , _ STR ) ) ; } catch (  Unsupported Encoding Exception e1 ) { e1 . print Stack Trace ( ) ; } } }
public  KNNDistance Order Result run (  Database database ,  Relation <  O > relation ) { final  Distance Query <  O > distance Query = database . get Distance Query ( relation , get Distance Function ( ) ) ; final  KNNQuery <  O > knn Query = database . get KNNQuery ( distance Query , k + _ NUM ) ; final int size = ( int ) ( ( sample <= _ NUM ) ?  Math . ceil ( relation . size ( ) * sample ) : sample ) ;  DBIDs sample =  DBIDUtil . random Sample ( relation . get DBIDs ( ) , size , rnd ) ;  Finite Progress prog =  LOG . is Verbose ( ) ? new  Finite Progress ( _ STR , size ,  LOG ) : null ; double [ ] knn Distances = new double [ size ] ; int i = _ NUM ; for (  DBIDIter iditer = sample . iter ( ) ; iditer . valid ( ) ; iditer . advance ( ) , i ++ ) { final  KNNList neighbors = knn Query . get KNNFor DBID ( iditer , k + _ NUM ) ; knn Distances [ i ] = neighbors . get KNNDistance ( ) ;  LOG . increment Processed ( prog ) ; }  LOG . ensure Completed ( prog ) ; return new  KNNDistance Order Result ( knn Distances , k ) ; }
protected int draw Host Address ( int host Range [ ] ) { if ( host Range [ _ NUM ] == host Range [ _ NUM ] ) { return host Range [ _ NUM ] ; } return host Range [ _ NUM ] + rng . next Int ( host Range [ _ NUM ] - host Range [ _ NUM ] ) ; }
public static  String grab Name (  String signature ) {  Matcher matcher = sig RE . matcher ( signature ) ; boolean b = matcher . matches ( ) ; if ( ! b && matcher . group Count ( ) != _ NUM ) logger . error ( _ STR , signature ) ; return matcher . group ( _ NUM ) ; }
public void insert (  Event Bean the Event ) { events . add ( the Event ) ;  Event Bean [ ] old Events = null ; if ( events . size ( ) > depth ) { old Events = new  Event Bean [ ] { events . remove ( _ NUM ) } ; } for (  View child : child Views ) { child . update ( new  Event Bean [ ] { the Event } , old Events ) ; } }
public  V put (  K key ,  V value ) { final int hash ; int index ; if ( key == null ) { hash = _ NUM ; index = index Of Null ( ) ; } else { hash = key . hash Code ( ) ; index = index Of ( key , hash ) ; } if ( index >= _ NUM ) { index = ( index << _ NUM ) + _ NUM ; final  V old = (  V ) m Array [ index ] ; m Array [ index ] = value ; return old ; } index = ~ index ; if ( m Size >= m Hashes . length ) { final int n = m Size >= (  BASE_ SIZE * _ NUM ) ? ( m Size + ( m Size > > _ NUM ) ) : ( m Size >=  BASE_ SIZE ? (  BASE_ SIZE * _ NUM ) :  BASE_ SIZE ) ; if (  DEBUG )  Log . d (  TAG , _ STR + m Hashes . length + _ STR + n ) ; final int [ ] ohashes = m Hashes ; final  Object [ ] oarray = m Array ; alloc Arrays ( n ) ; if ( m Hashes . length > _ NUM ) { if (  DEBUG )  Log . d (  TAG , _ STR + m Size + _ STR ) ;  System . arraycopy ( ohashes , _ NUM , m Hashes , _ NUM , ohashes . length ) ;  System . arraycopy ( oarray , _ NUM , m Array , _ NUM , oarray . length ) ; } free Arrays ( ohashes , oarray , m Size ) ; } if ( index < m Size ) { if (  DEBUG )  Log . d (  TAG , _ STR + index + _ STR + ( m Size - index ) + _ STR + ( index + _ NUM ) ) ;  System . arraycopy ( m Hashes , index , m Hashes , index + _ NUM , m Size - index ) ;  System . arraycopy ( m Array , index << _ NUM , m Array , ( index + _ NUM ) << _ NUM , ( m Size - index ) << _ NUM ) ; } m Hashes [ index ] = hash ; m Array [ index << _ NUM ] = key ; m Array [ ( index << _ NUM ) + _ NUM ] = value ; m Size ++ ; return null ; }
protected void put Long Volatile ( long pos , long val ) { unsafe . put Long Volatile ( null , pos + addr , val ) ; }
public boolean recreate RSet Step (  URI rp System Id ,  List <  URI > volume Ids ,  Map <  String ,  Recreate Replication Set Request Params > rset Params ,  String token ) throws  Internal Exception {  List <  String > replication Set Names = new  Array List <  String > ( ) ; try {  Protection System rp System = _db Client . query Object (  Protection System . class , rp System Id ) ; for (  URI volume Id : volume Ids ) {  Volume volume = _db Client . query Object (  Volume . class , volume Id ) ; replication Set Names . add ( volume . get RSet Name ( ) ) ; }  Recover Point Client rp =  RPHelper . get Recover Point Client ( rp System ) ; _log . info ( _ STR ) ; try {  Thread . sleep ( _ NUM ) ; } catch (  Interrupted Exception e ) { _log . warn ( _ STR ) ; } rp . recreate Replication Sets ( rset Params ) ;  Workflow Step Completer . step Succeded ( token ) ; } catch (  Exception e ) { _log . error (  String . format ( _ STR , replication Set Names . to String ( ) ) ) ; return step Failed ( token , e , _ STR ) ; } return _ BOOL ; }
synchronized boolean visit ( ) throws  IOException { if ( exc != null ) { return _ BOOL ; } if ( current == null ) { if ( iter . has Next ( ) == _ BOOL ) { c . close ( ) ; return _ BOOL ; }  Map .  Entry <  String ,  File Meta Data > next = iter . next ( ) ;  File Meta Data meta Data = next . get Value ( ) ;  String file Name = next . get Key ( ) ; long len = c . in . read VLong ( ) ; if ( len != meta Data . length ) { throw new  Illegal State Exception ( _ STR + file Name + _ STR + meta Data . length + _ STR + len ) ; } current = new  Copy One File ( c . in , dest , file Name , meta Data , copy Buffer ) ; } if ( current . visit ( ) ) { copied Files . put ( current . name , current . tmp Name ) ; tot Bytes Copied += current . get Bytes Copied ( ) ; assert tot Bytes Copied <= tot Bytes : _ STR + tot Bytes Copied + _ STR + tot Bytes ; current = null ; return _ BOOL ; } return _ BOOL ; }
public  String order (  Properties ctx , int  Window No ,  Grid Tab m Tab ,  Grid Field m Field ,  Object value ) {  Integer  C_ Order_ ID = (  Integer ) value ; if (  C_ Order_ ID == null ||  C_ Order_ ID . int Value ( ) == _ NUM ) return _ STR ; if ( is Callout Active ( ) ) return _ STR ;  MOrder order = new  MOrder ( ctx ,  C_ Order_ ID . int Value ( ) , null ) ; if ( order . get_ ID ( ) != _ NUM ) { m Tab . set Value ( _ STR , order . get Date Ordered ( ) ) ; m Tab . set Value ( _ STR , order . get POReference ( ) ) ; m Tab . set Value ( _ STR , new  Integer ( order . get AD_ Org_ ID ( ) ) ) ; m Tab . set Value ( _ STR , new  Integer ( order . get AD_ Org Trx_ ID ( ) ) ) ; m Tab . set Value ( _ STR , new  Integer ( order . get C_ Activity_ ID ( ) ) ) ; m Tab . set Value ( _ STR , new  Integer ( order . get C_ Campaign_ ID ( ) ) ) ; m Tab . set Value ( _ STR , new  Integer ( order . get C_ Project_ ID ( ) ) ) ; m Tab . set Value ( _ STR , new  Integer ( order . get User1_ ID ( ) ) ) ; m Tab . set Value ( _ STR , new  Integer ( order . get User2_ ID ( ) ) ) ; m Tab . set Value ( _ STR , new  Integer ( order . get M_ Warehouse_ ID ( ) ) ) ; m Tab . set Value ( _ STR , order . get Delivery Rule ( ) ) ; m Tab . set Value ( _ STR , order . get Delivery Via Rule ( ) ) ; m Tab . set Value ( _ STR , new  Integer ( order . get M_ Shipper_ ID ( ) ) ) ; m Tab . set Value ( _ STR , order . get Freight Cost Rule ( ) ) ; m Tab . set Value ( _ STR , order . get Freight Amt ( ) ) ; m Tab . set Value ( _ STR , new  Integer ( order . get C_ BPartner_ ID ( ) ) ) ; m Tab . set Value ( _ STR , new  Integer ( order . get C_ BPartner_ Location_ ID ( ) ) ) ; if ( order . get AD_ User_ ID ( ) > _ NUM ) m Tab . set Value ( _ STR , new  Integer ( order . get AD_ User_ ID ( ) ) ) ; else m Tab . set Value ( _ STR , null ) ; } return _ STR ; }
public final int read Int ( ) throws java . io .  IOException { read Fully ( scratch , _ NUM , _ NUM ) ; return ( ( ( scratch [ _ NUM ] & _ NUM ) << _ NUM ) | ( ( scratch [ _ NUM ] & _ NUM ) << _ NUM ) | ( ( scratch [ _ NUM ] & _ NUM ) << _ NUM ) | ( ( scratch [ _ NUM ] & _ NUM ) << _ NUM ) ) ; }
public void test Table Meta Data ( ) throws  Exception {  Statement stmt = con . create Statement (  Result Set .  TYPE_ SCROLL_ INSENSITIVE ,  Result Set .  CONCUR_ READ_ ONLY ) ;  Result Set rs = stmt . execute Query ( _ STR ) ; assert Not Null ( rs ) ;  Result Set Meta Data rsmd = rs . get Meta Data ( ) ;  Assert . assert Equals ( _ STR , rsmd . get Catalog Name ( _ NUM ) ) ;  Assert . assert Equals ( _ STR , rsmd . get Schema Name ( _ NUM ) ) ;  Assert . assert Equals ( _ STR , rsmd . get Table Name ( _ NUM ) ) ; stmt . close ( ) ; rs . close ( ) ; }
public  String to String ( ) { return ( super . to String ( ) + _ STR + ( ( not Before == null ) ? _ STR : _ STR + not Before . to String ( ) + _ STR ) + ( ( not After == null ) ? _ STR : _ STR + not After . to String ( ) ) + _ STR ) ; }
private void handle Json Create Quotation (  Request And Response request And Response ) throws  IOException ,  Servlet Exception { request And Response . set Response Content Type Json ( ) ;  String url ;  String title ;  String quotation ;  String note ;  String session Id ; try { final  Json Node Helper json = get Json Node ( request And Response ) ; url = json . get String (  Db Logic .  Constants . url ) ; title = json . get String (  Db Logic .  Constants . title ) ; quotation = json . get String (  Db Logic .  Constants . quotation ) ; note = json . get String (  Db Logic .  Constants . note ) ; session Id = json . get String ( _ STR ) ; } catch ( final  IOException e ) { return Json400 ( request And Response , servlet Text . error Json ( ) ) ; return ; } if ( !  Entry Attribute Validator . is Note Valid ( note ) ) { return Json400 ( request And Response , servlet Text . error Note Is Invalid ( ) ) ; return ; } if ( !  Entry Attribute Validator . is Quotation Valid ( quotation ) ) { return Json400 ( request And Response , servlet Text . error Quotation Is Invalid ( ) ) ; return ; } if ( !  Entry Attribute Validator . is Url Valid ( url ) ) { return Json400 ( request And Response , servlet Text . error Url Is Invalid ( ) ) ; return ; } if ( !  Entry Attribute Validator . is Source Title Valid ( title ) ) { return Json400 ( request And Response , servlet Text . error Title Is Invalid ( ) ) ; return ; } final  Errors errors = new  Errors ( ) ; try { final  Long time = new  Long (  System . current Time Millis ( ) ) ;  String user Id = null ; if ( session Manager != null ) { final  Http Session session = session Manager . get Session ( session Id ) ; if ( session != null && session . get Attribute ( session User Id Attribute ) != null ) { user Id = (  String ) session . get Attribute ( session User Id Attribute ) ; } } final  User user = db Logic . get User By Id ( user Id ) ; if ( user == null ) { return Json400 ( request And Response , servlet Text . error No Account Found ( ) ) ; return ; } if ( user . get Is Account Closed ( ) ) { return Json400 ( request And Response , servlet Text . error Account Is Closed ( ) ) ; return ; } final  Entry source = db Logic . update Or Create Source ( user , null , url , title , time , time , is User An Admin ( request And Response ) , errors ) ; if ( source == null ) { return Json400 ( request And Response , errors ) ; return ; } final  Entry entry = db Logic . create Entry Quotation ( user , source , quotation , note , time , is User An Admin ( request And Response ) , errors ) ; if ( entry == null ) { return Json400 ( request And Response , errors ) ; return ; } request And Response . print ( _ STR + _ STR + entry . get Id ( ) + _ STR + _ STR + source . get Id ( ) + _ STR ) ; db Logic . commit ( ) ; } catch ( final  Persistence Exception e ) { logger . log (  Level .  INFO , _ STR , e ) ; return Json500 ( request And Response , servlet Text . error Internal Database ( ) ) ; } }
private static  Class < ? > [ ] types (  Object ... values ) { if ( values == null ) { return new  Class [ _ NUM ] ; }  Class < ? > [ ] result = new  Class [ values . length ] ; for ( int i = _ NUM ; i < values . length ; i ++ ) {  Object value = values [ i ] ; result [ i ] = value == null ?  NULL . class : value . get Class ( ) ; } return result ; }
private static boolean is Hex Digit ( char c ) { return ( c >= _ STR && c <= _ STR || c >= _ STR && c <= _ STR || c >= _ STR && c <= _ STR ) ; }
private void enable Stronger Defaults (  Socket socket ) { if ( is Secure ( socket ) ) {  SSLSocket ssl Socket = (  SSLSocket ) socket ; read SSLParameters ( ssl Socket ) ; if ( m Enable Stonger Default Protocal Version && m Protocols != null ) { ssl Socket . set Enabled Protocols ( m Protocols ) ; } if ( m Enable Stonger Default SSLCipher Suite && m Cipher Suites != null ) { ssl Socket . set Enabled Cipher Suites ( m Cipher Suites ) ; } } }
protected boolean is White Space ( char ch ) { return ( ( ch == _ STR ) || ( ch == _ STR ) || ( ch == _ STR ) || ( ch == _ NUM ) || ( ch == _ NUM ) ) ; }
public  FSFont resolve Font (  Shared Context ctx ,  String [ ] families , float size ,  Ident Value weight ,  Ident Value style ,  Ident Value variant ) {  List <  Font > fonts = new  Array List <  Font > ( _ NUM ) ; if ( families != null ) { for ( int i = _ NUM ; i < families . length ; i ++ ) {  Font font = resolve Font ( ctx , families [ i ] , size , weight , style , variant ) ; if ( font != null ) { fonts . add ( font ) ; } } }  String family = _ STR ; if ( style ==  Ident Value .  ITALIC ) { family = _ STR ; }  Font fnt = create Font ( ctx , available Fonts Hash . get ( family ) , size , weight , style , variant ) ; instance Hash . put ( get Font Instance Hash Name ( ctx , family , size , weight , style , variant ) , fnt ) ; fonts . add ( fnt ) ; return new  AWTFSFont ( fonts , size ) ; }
public  Command checkout Command ( ) throws  Interrupted Exception {  Command command = pool . poll ( ) ; if ( command == null ) { command = new  Command ( gondola , this , cmember ) ; } return command ; }
public static boolean is Double (  String desc ) { return desc . ends With ( _ STR ) ; }
public static void move End (  JScroll Pane pane ) {  JScroll Bar bar = pane . get Vertical Scroll Bar ( ) ; bar . set Value ( bar . get Maximum ( ) ) ; }
public void add (  String arg Name ,  String desc , int expected Number Of Arguments , boolean expect Dashed Arguments ) {  Arg new Arg = new  Arg ( arg Name , desc , expected Number Of Arguments , expect Dashed Arguments ) ; args . add ( new Arg ) ; if (  Debug . debugging ( _ STR ) ) {  Debug . output ( _ STR + arg Name ) ; } }
private boolean add If Absent (  E e ,  Object [ ] snapshot ) { final  Reentrant Lock lock = this . lock ; lock . lock ( ) ; try {  Object [ ] current = get Array ( ) ; int len = current . length ; if ( snapshot != current ) { int common =  Math . min ( snapshot . length , len ) ; for ( int i = _ NUM ; i < common ; i ++ ) if ( current [ i ] != snapshot [ i ] && eq ( e , current [ i ] ) ) return _ BOOL ; if ( index Of ( e , current , common , len ) >= _ NUM ) return _ BOOL ; }  Object [ ] new Elements =  Arrays . copy Of ( current , len + _ NUM ) ; new Elements [ len ] = e ; set Array ( new Elements ) ; return _ BOOL ; } finally { lock . unlock ( ) ; } }
public void add Model (  Model model ) { models . add ( model ) ; }
public void open Out File In App Files Dir (  File p File ,  String p File Out ) {  File Output Stream fos = null ; try { fos = new  File Output Stream ( p File ) ; } catch (  File Not Found Exception e1 ) { fail Str ( _ STR + e1 ) ; return ; } try { fos . write ( p File Out . get Bytes ( ) ) ; fos . close ( ) ; } catch (  File Not Found Exception e ) { fail Str ( e . get Message ( ) ) ; } catch (  IOException e ) { fail Str ( e . get Message ( ) ) ; } int count = p File Out . get Bytes ( ) . length ; byte [ ] buffer = new byte [ count ] ; try {  File Input Stream fis = new  File Input Stream ( p File ) ; fis . read ( buffer , _ NUM , count ) ; fis . close ( ) ; } catch (  File Not Found Exception e ) { fail Str ( _ STR + e . get Message ( ) ) ; } catch (  IOException e ) { fail Str ( _ STR + e ) ; }  String str = new  String ( buffer ) ; assert Equals ( str , p File Out ) ; }
public int create Binomial ( final int n , final double p ) { double value = p ; final  String Builder bits = new  String Builder ( _ NUM ) ; double bit Value = _ NUM ; while ( value > _ NUM ) { if ( value >= bit Value ) { bits . append ( _ STR ) ; value -= bit Value ; } else { bits . append ( _ STR ) ; } bit Value /= _ NUM ; } final  Bit String p Bits = new  Bit String ( bits . to String ( ) ) ; int trials = n ; int total Successes = _ NUM ; int p Index = p Bits . get Length ( ) - _ NUM ; while ( trials > _ NUM && p Index >= _ NUM ) { final  Bit String bs = new  Bit String ( trials , generator ) ; final int successes = bs . count Set Bits ( ) ; trials -= successes ; if ( p Bits . get Bit ( p Index ) ) { total Successes += successes ; } -- p Index ; } return total Successes ; }
static void with Random ( long seed ,  Consumer <  Random > cons ) {  Random random = new  Random ( seed ) ; with Message ( _ STR + seed + _ STR , null ) ; }
@  Event Handler ( priority =  Event Priority .  HIGH , ignore Cancelled = _ BOOL ) public void on Bucket Fill (  Player Bucket Fill Event event ) {  Match match =  Cardinal . get Match ( event . get Player ( ) ) ; if ( match == null || ! match . has Player ( event . get Player ( ) ) ) { return ; } for (  Applied Region reg : get ( match ,  Apply Type .  BLOCK ,  Apply Type .  BLOCK_ BREAK ) ) {  Block evaluating = event . get Block Clicked ( ) ; if ( apply ( reg , evaluating . get Location ( ) , event . get Player ( ) , event , event , evaluating , event . get Player ( ) ) ) { break ; } } }
protected void ensure Rows Are Visible ( int begin Row , int end Row ) { if ( tree != null && begin Row >= _ NUM && end Row < get Row Count ( tree ) ) { boolean scroll Vert =  Default Lookup . get Boolean ( tree , this , _ STR , _ BOOL ) ; if ( begin Row == end Row ) {  Rectangle scroll Bounds = get Path Bounds ( tree , get Path For Row ( tree , begin Row ) ) ; if ( scroll Bounds != null ) { if ( ! scroll Vert ) { scroll Bounds . x = tree . get Visible Rect ( ) . x ; scroll Bounds . width = _ NUM ; } tree . scroll Rect To Visible ( scroll Bounds ) ; } } else {  Rectangle begin Rect = get Path Bounds ( tree , get Path For Row ( tree , begin Row ) ) ; if ( begin Rect != null ) {  Rectangle vis Rect = tree . get Visible Rect ( ) ;  Rectangle test Rect = begin Rect ; int begin Y = begin Rect . y ; int max Y = begin Y + vis Rect . height ; for ( int counter = begin Row + _ NUM ; counter <= end Row ; counter ++ ) { test Rect = get Path Bounds ( tree , get Path For Row ( tree , counter ) ) ; if ( test Rect == null ) { return ; } if ( ( test Rect . y + test Rect . height ) > max Y ) counter = end Row ; } tree . scroll Rect To Visible ( new  Rectangle ( vis Rect . x , begin Y , _ NUM , test Rect . y + test Rect . height - begin Y ) ) ; } } } }
@  Safe Varargs public final  Test Subscriber <  T > assert Values With (  Consumer <  T > ... expectations ) { if ( ! values Storage ) { throw new  Illegal State Exception ( _ STR ) ; } final int expected Value Count = expectations . length ; if ( expected Value Count != values . size ( ) ) { throw new  Assertion Error ( _ STR + expected Value Count + _ STR + value Count , null ) ; } for ( int i = _ NUM ; i < expected Value Count ; i ++ ) {  Consumer <  T > consumer = expectations [ i ] ;  T actual Value = values . get ( i ) ; consumer . accept ( actual Value ) ; } return this ; }
public boolean is Empty ( ) { return nodes . is Empty ( ) ; }
public static void click Button By Label (  String text ) { if ( verbose ) { log ( _ STR + text + _ STR ) ; }  Button b = (  Button ) find Label Text ( text ) ; wait For ( _ NUM ) ; b . pressed ( ) ; wait For ( _ NUM ) ; b . released ( ) ; wait For ( _ NUM ) ; }
public  Payload Score Query (  Span Query wrapped Query ,  Payload Function function , boolean include Span Score ) { this . wrapped Query =  Objects . require Non Null ( wrapped Query ) ; this . function =  Objects . require Non Null ( function ) ; this . include Span Score = include Span Score ; }
public static boolean debugging (  String token ) { return  Debug .  On && ( debug All || dbg Table . contains Key ( token ) ) ; }
public static  List <  File > sort In Batch (  File file ,  Comparator <  String > cmp , int maxtmpfiles ) throws  IOException {  List <  File > files = new  Array List <  File > ( ) ;  Buffered Reader fbr = new  Buffered Reader ( new  File Reader ( file ) ) ; long blocksize = estimate Best Size Of Blocks ( file , maxtmpfiles ) ; try {  List <  String > tmplist = new  Array List <  String > ( ) ;  String line = _ STR ; try { while ( line != null ) { long currentblocksize = _ NUM ; while ( ( currentblocksize < blocksize ) && ( ( line = fbr . read Line ( ) ) != null ) ) { tmplist . add ( line ) ; currentblocksize += line . length ( ) * _ NUM ; } files . add ( sort And Save ( tmplist , cmp ) ) ; tmplist . clear ( ) ; } } catch (  EOFException oef ) { if ( tmplist . size ( ) > _ NUM ) { files . add ( sort And Save ( tmplist , cmp ) ) ; tmplist . clear ( ) ; } } } finally { fbr . close ( ) ; } return files ; }
public void remove Directory Set (  Context context ,  String path ) {  Tiny DB tinydb = new  Tiny DB ( context ) ;  Array List <  String > file = tinydb . get List String ( _ STR ) ; file . remove ( path ) ; tinydb . put List String ( _ STR , file ) ; }
private  Concurrent Skip List Map .  Node <  K ,  V > lo Node ( ) { if ( lo == null ) return m . find First ( ) ; else if ( lo Inclusive ) return m . find Near ( lo ,  GT |  EQ ) ; else return m . find Near ( lo ,  GT ) ; }
public void run ( ) {  Buffered Reader tdin = null ;  Print Writer tdout = null ; if ( view Name == null ) {  Debug . error ( _ STR ) ; return ; } while ( ! this . shutdown ) { if (  DEBUG )  Debug . output ( _ STR ) ; try { tdin = new  Buffered Reader ( new  Input Stream Reader ( s . get Input Stream ( ) ) ) ; tdout = new  Print Writer ( s . get Output Stream ( ) , _ BOOL ) ; if (  DEBUG )  Debug . output ( _ STR + view Name ) ; tdout . println ( _ STR + view Name + _ STR ) ; s . set So Timeout ( _ NUM ) ; } catch (  Interrupted IOException e Connect Interrupted ) { continue ; } catch (  IOException e Connect ) {  Debug . error ( _ STR + e Connect . get Message ( ) + _ STR ) ; try {  Thread . sleep ( _ NUM ) ; } catch (  Exception e Sleep ) { } continue ; } if ( netmap Conn == null ) { continue ; } netmap Conn . connection Up ( ) ; while ( ! this . shutdown ) { try {  String line = null ; if ( ( line = tdin . read Line ( ) ) == null ) break ; if (  DEBUG_ VERBOSE )  Debug . output ( _ STR + line ) ;  Properties event Props = procline ( line ) ; if (  DEBUG_ VERBOSE )  Debug . output ( _ STR ) ; if ( ! event Props . is Empty ( ) ) { netmap Conn . distribute Event ( event Props ) ; if (  DEBUG_ VERBOSE )  Debug . output ( _ STR ) ; } else { if (  DEBUG_ VERBOSE )  Debug . output ( _ STR ) ; } } catch (  Interrupted IOException e Read Interrupted ) { continue ; } catch (  Exception e ) {  Debug . error ( _ STR + e . get Message ( ) + _ STR ) ; continue ; } } try { s . close ( ) ; netmap Conn . connection Down ( ) ; } catch (  Exception e Shutdown ) { } } }
private static void update Embedded Id Repo (  String org Name ,  String config Name ,  String entry ) throws  SMSException ,  SSOException {  SSOToken token =  Access Controller . do Privileged (  Admin Token Action . get Instance ( ) ) ;  Service Config Manager scm = new  Service Config Manager ( token ,  Id Constants .  REPO_ SERVICE , _ STR ) ;  Service Config sc = scm . get Organization Config ( org Name , null ) ; if ( sc != null ) {  Service Config sub Config = sc . get Sub Config ( config Name ) ; if ( sub Config != null ) {  Map <  String ,  Set <  String > > config Map = sub Config . get Attributes ( ) ;  Set <  String > vals = config Map . get ( _ STR ) ; vals . add ( entry ) ;  Hash Map <  String ,  Set <  String > > mp = new  Hash Map <  String ,  Set <  String > > ( _ NUM ) ; mp . put ( _ STR , vals ) ; sub Config . set Attributes ( mp ) ; } } }
public static  Description describe ( final char [ ] pin ) { if ( pin == null || pin . length == _ NUM ) { return new  Description ( _ NUM ,  Enum Set . none Of (  Character Class . class ) ) ; }  Enum Set <  Character Class > classes =  Enum Set . none Of (  Character Class . class ) ; for ( char ch : pin ) { classes . add (  Character Class . of ( ch ) ) ; } return new  Description ( pin . length , classes ) ; }
public static int count (  String string ,  String mark ) { if ( !  Text Utils . is Empty ( string ) && !  Text Utils . is Empty ( mark ) ) { int count = _ NUM ; int index = string . index Of ( mark ) ; while ( index != - _ NUM ) { count ++ ; string = string . substring ( index + mark . length ( ) ) ; index = string . index Of ( mark ) ; } return count ; } return _ NUM ; }
public  Shape paint Layer (  Graphics g , int offs0 , int offs1 ,  Shape bounds ,  JText Component c ,  View view ) { g . set Color ( get Color ( ) ) ; if ( offs0 == view . get Start Offset ( ) && offs1 == view . get End Offset ( ) ) {  Rectangle alloc ; if ( bounds instanceof  Rectangle ) alloc = (  Rectangle ) bounds ; else alloc = bounds . get Bounds ( ) ; paint Squiggle ( g , alloc ) ; return alloc ; } try {  Shape shape = view . model To View ( offs0 ,  Position .  Bias .  Forward , offs1 ,  Position .  Bias .  Backward , bounds ) ;  Rectangle r = ( shape instanceof  Rectangle ) ? (  Rectangle ) shape : shape . get Bounds ( ) ; paint Squiggle ( g , r ) ; return r ; } catch (  Bad Location Exception e ) { e . print Stack Trace ( ) ; } return null ; }
synchronized void receive ( char one Char ) throws  IOException { if ( buffer == null ) { throw new  IOException ( _ STR ) ; } if ( last Reader != null && ! last Reader . is Alive ( ) ) { throw new  IOException ( _ STR ) ; } last Writer =  Thread . current Thread ( ) ; try { while ( buffer != null && out == in ) { notify All ( ) ; wait ( _ NUM ) ; if ( last Reader != null && ! last Reader . is Alive ( ) ) { throw new  IOException ( _ STR ) ; } } } catch (  Interrupted Exception e ) {  Io Utils . throw Interrupted Io Exception ( ) ; } if ( buffer == null ) { throw new  IOException ( _ STR ) ; } if ( in == - _ NUM ) { in = _ NUM ; } buffer [ in ++ ] = one Char ; if ( in == buffer . length ) { in = _ NUM ; } }
static final  Byte Buffer  Buffer To Byte Buffer ( final byte [ ] buffer , final  Byte Order order , final int start , final int len ) { final  Byte Buffer ret Buff =  Byte Buffer . wrap ( buffer , start , len ) ; ret Buff . order ( order ) ; return ret Buff ; }
static protected  String host From Uri Str (  String uri Str ) { debug Out ( _ STR + uri Str + _ STR ) ;  String host = null ;  URI uri ; try { uri = new  URI ( uri Str ) ; host = uri . get Host ( ) ; } catch (  URISyntax Exception e ) { debug Out ( e . get Message ( ) ) ; } return host ; }
public void reset ( ) { current Time = _ NUM ; stored Time = _ NUM ; start Time =  System . current Time Millis ( ) ; }
public int read Word ( ) throws  IOException { length += _ NUM ; int k1 = in . read ( ) ; if ( k1 < _ NUM ) return _ NUM ; return ( k1 + ( in . read ( ) << _ NUM ) ) & _ NUM ; }
private void tag End ( ) throws  IOException { save Current ( _ NUM ) ; go ( _ NUM ) ; _col += _ NUM ; if ( is All Read ( ) ) { return ; }  String tag Name = identifier ( ) ; if ( transformations != null && transformations . has Transformation For Tag ( tag Name ) ) {  Tag Transformation tag Transformation = transformations . get Transformation ( tag Name ) ; if ( tag Transformation != null ) { tag Name = tag Transformation . get Dest Tag ( ) ; } } if ( tag Name != null ) {  ITag Info Provider tag Info Provider = cleaner . get Tag Info Provider ( ) ;  Tag Info tag Info = tag Info Provider . get Tag Info ( tag Name ) ; if ( ( tag Info == null && ! props . is Omit Unknown Tags ( ) && props . is Treat Unknown Tags As Content ( ) && ! is Reserved Tag ( tag Name ) && ! props . is Namespaces Aware ( ) ) || ( tag Info != null && tag Info . is Deprecated ( ) && ! props . is Omit Deprecated Tags ( ) && props . is Treat Deprecated Tags As Content ( ) ) ) { content ( ) ; return ; } } _current Tag Token = new  End Tag Token ( tag Name ) ; if ( _as Expected ) { skip Whitespaces ( ) ; tag Attributes ( ) ; if ( tag Name != null ) { add Token ( _current Tag Token ) ; } if ( is Char ( _ STR ) ) { go ( ) ; } if ( props . is Use Cdata For ( tag Name ) ) { _is Special Context = _ BOOL ; _is Special Context Name = tag Name ; } if ( tag Name != null && tag Name . equals Ignore Case ( _ STR ) ) { skip Whitespaces ( ) ; } _current Tag Token = null ; } else { add Saved As Content ( ) ; } }
public  String next String ( char quote ) throws  JSONException { char c ;  String Buffer sb = new  String Buffer ( ) ; for ( ; ; ) { c = next ( ) ; switch ( c ) { case _ NUM : case _ STR : case _ STR : throw syntax Error ( _ STR ) ; case _ STR : c = next ( ) ; switch ( c ) { case _ STR : sb . append ( _ STR ) ; break ; case _ STR : sb . append ( _ STR ) ; break ; case _ STR : sb . append ( _ STR ) ; break ; case _ STR : sb . append ( _ STR ) ; break ; case _ STR : sb . append ( _ STR ) ; break ; case _ STR : sb . append ( ( char )  Integer . parse Int ( next ( _ NUM ) , _ NUM ) ) ; break ; case _ STR : sb . append ( ( char )  Integer . parse Int ( next ( _ NUM ) , _ NUM ) ) ; break ; default : sb . append ( c ) ; } break ; default : if ( c == quote ) { return sb . to String ( ) ; } sb . append ( c ) ; } } }
public  NSData (  File file ) throws  IOException { bytes = new byte [ ( int ) file . length ( ) ] ;  Random Access File raf = new  Random Access File ( file , _ STR ) ; raf . read ( bytes ) ; raf . close ( ) ; }
public double evaluate (  Vector Instance x , double [ ] y ) throws  Exception { double dot Prod = x . dot Product ( y ) ; return  Math . pow ( m_gamma * dot Prod + m_coef0 , m_degree ) ; }
public boolean use Proxy ( ) { if (  String Utils . is Not Blank ( get Proxy Host ( ) ) ) { return _ BOOL ; } return _ BOOL ; }
public static  Array list To Array (  String list ,  String delimiter ) { if ( delimiter . length ( ) == _ NUM ) return list To Array ( list , delimiter . char At ( _ NUM ) ) ; if ( list . length ( ) == _ NUM ) return new  Array Impl ( ) ; if ( delimiter . length ( ) == _ NUM ) { int len = list . length ( ) ;  Array Impl array = new  Array Impl ( ) ; array . append EL ( _ STR ) ; for ( int i = _ NUM ; i < len ; i ++ ) { array . append EL ( list . char At ( i ) ) ; } array . append EL ( _ STR ) ; return array ; } int len = list . length ( ) ; int last = _ NUM ; char [ ] del = delimiter . to Char Array ( ) ; char c ;  Array Impl array = new  Array Impl ( ) ; try { for ( int i = _ NUM ; i < len ; i ++ ) { c = list . char At ( i ) ; for ( int y = _ NUM ; y < del . length ; y ++ ) { if ( c == del [ y ] ) { array . append EL ( list . substring ( last , i ) ) ; last = i + _ NUM ; break ; } } } if ( last <= len ) array . append ( list . substring ( last ) ) ; } catch (  Expression Exception e ) { } return array ; }
public static void generate Java Script Log Session Expired Relation (  Writer writer ,  String idioma ,  Long num Idioma ,  String message , int enabled ) throws  IOException { writer . write ( _ STR + message + _ STR ) ; if ( enabled == _ NUM ) { writer . write ( _ STR + idioma + _ STR + num Idioma + _ STR ) ; writer . write ( _ STR ) ; } else { writer . write ( _ STR + idioma + _ STR + num Idioma + _ STR ) ; } writer . write ( _ STR ) ; }
public  Tree <  String > extract Best Max Rule Parse1 ( int start , int end , int state ,  List <  String > sentence ) { int c State = maxc Child [ start ] [ end ] [ state ] ; if ( c State == - _ NUM ) { return extract Best Max Rule Parse2 ( start , end , state , sentence ) ; } else {  List <  Tree <  String > > child = new  Array List <  Tree <  String > > ( ) ; child . add ( extract Best Max Rule Parse2 ( start , end , c State , sentence ) ) ;  String state Str = (  String ) tag Numberer . object ( state ) ; if ( state Str . ends With ( _ STR ) ) state Str = state Str . substring ( _ NUM , state Str . length ( ) - _ NUM ) ; total Used Unaries ++ ; int intermediate Node = grammar . get Unary Intermediate ( ( short ) state , ( short ) c State ) ; if ( intermediate Node > _ NUM ) {  List <  Tree <  String > > restored Child = new  Array List <  Tree <  String > > ( ) ; n Times Restored Unaries ++ ;  String state Str2 = (  String ) tag Numberer . object ( intermediate Node ) ; if ( state Str2 . ends With ( _ STR ) ) state Str2 = state Str2 . substring ( _ NUM , state Str2 . length ( ) - _ NUM ) ; restored Child . add ( new  Tree <  String > ( state Str2 , child ) ) ; return new  Tree <  String > ( state Str , restored Child ) ; } return new  Tree <  String > ( state Str , child ) ; } }
protected void draw Center Text (  Canvas c ) {  String center Text = m Chart . get Center Text ( ) ; if ( m Chart . is Draw Center Text Enabled ( ) && center Text != null ) {  Point F center = m Chart . get Center Circle Box ( ) ;  String [ ] lines = center Text . split ( _ STR ) ; float maxlineheight = _ NUM ; for (  String line : lines ) { float cur Height =  Utils . calc Text Height ( m Center Text Paint , line ) ; if ( cur Height > maxlineheight ) maxlineheight = cur Height ; } float linespacing = maxlineheight * _ NUM ; float totalheight = maxlineheight * lines . length - linespacing * ( lines . length - _ NUM ) ; int cnt = lines . length ; float y = center . y ; for ( int i = _ NUM ; i < lines . length ; i ++ ) {  String line = lines [ lines . length - i - _ NUM ] ; c . draw Text ( line , center . x , y + maxlineheight * cnt - totalheight / _ NUM , m Center Text Paint ) ; cnt -- ; y -= linespacing ; } } }
public void start ( int conditions ) throws  IOException { super . start ( conditions ) ; int ptr = ( int ) tagout . get Bytes Written ( ) ; int offset = ptr - last Ptr ; offsets . add ( new int [ ] { last Ptr , offset } ) ; last Ptr = ptr ; tagout . write UI16 ( _ NUM ) ; tagout . write UI16 ( conditions ) ; }
private static  Result Code register Success Result Code ( final int int Value , final  Localizable Message name , final  Enum result Code Enum ) { final  Result Code t = new  Result Code ( int Value , name , _ BOOL , result Code Enum ) ;  ELEMENTS . put ( int Value , t ) ; return t ; }
public void clear ( ) { exception Set . clear ( ) ; explicit Set . clear ( ) ; universal Handler = _ BOOL ; common Supertype = null ; size = _ NUM ; }
@  HLEUnimplemented @  HLEFunction ( nid = _ NUM , version = _ NUM ) public int sce Kernel Register Sys Event Handler (  TPointer handler ) { psp Sys Event Handler sys Event Handler = new psp Sys Event Handler ( ) ; sys Event Handler . read ( handler ) ; if ( log . is Debug Enabled ( ) ) { log . debug (  String . format ( _ STR , sys Event Handler ) ) ; } return _ NUM ; }
public  String Body ( final  String text , final  String mime Type ,  Charset charset ) throws  Unsupported Encoding Exception { super ( mime Type ) ; if ( text == null ) { throw new  Illegal Argument Exception ( _ STR ) ; } if ( charset == null ) { charset =  Charset . for Name (  HTTP .  UTF_8 ) ; } this . content = text . get Bytes ( charset . name ( ) ) ; this . charset = charset ; }
public static <  T extends  Hierarchical Type >  List <  T > sort Types (  List <  T > types ) {  Map <  String ,  T > types By Name = new  Hash Map < > ( ) ; for (  T type : types ) { types By Name . put ( type . name , type ) ; }  List <  T > result = new  Array List < > ( types . size ( ) ) ;  Set <  T > processed = new  Hash Set < > ( ) ; for (  T type : types ) { add To Result ( type , result , processed , types By Name ) ; } return result ; }
static public void remove Notification Listener (  JMXConnector jmx Connector ,  Class < ? > mbean Interface ,  String mbean Name ,  Notification Listener notification Listener , boolean ignored ) throws  Exception {  MBean Server Connection mbsc = jmx Connector . get MBean Server Connection ( ) ;  Object Name object Name = generate MBean Object Name ( mbean Interface . get Name ( ) , mbean Name ) ; mbsc . remove Notification Listener ( object Name , notification Listener ) ; }
private void send Message (  Consumer Record <  String ,  String > record ) { try { bus . send ( bus Address ,  Kafka Event . create Event For Bus ( record ) ) ; } catch (  Exception ex ) {  String error =  String . format ( _ STR , record . to String ( ) ) ; logger . error ( error , ex ) ; bus . send (  Config Constants .  CONSUMER_ ERROR_ TOPIC , get Error String ( error , ex . get Message ( ) ) ) ; } }
public byte [ ] read Raw Bytes ( final int size ) throws  IOException { if ( size < _ NUM ) { throw  Invalid Protocol Buffer Exception . negative Size ( ) ; } if ( total Bytes Retired + buffer Pos + size > current Limit ) { skip Raw Bytes ( current Limit - total Bytes Retired - buffer Pos ) ; throw  Invalid Protocol Buffer Exception . truncated Message ( ) ; } if ( size <= buffer Size - buffer Pos ) { final byte [ ] bytes = new byte [ size ] ;  System . arraycopy ( buffer , buffer Pos , bytes , _ NUM , size ) ; buffer Pos += size ; return bytes ; } else if ( size <  BUFFER_ SIZE ) { final byte [ ] bytes = new byte [ size ] ; int pos = buffer Size - buffer Pos ;  System . arraycopy ( buffer , buffer Pos , bytes , _ NUM , pos ) ; buffer Pos = buffer Size ; refill Buffer ( _ BOOL ) ; while ( size - pos > buffer Size ) {  System . arraycopy ( buffer , _ NUM , bytes , pos , buffer Size ) ; pos += buffer Size ; buffer Pos = buffer Size ; refill Buffer ( _ BOOL ) ; }  System . arraycopy ( buffer , _ NUM , bytes , pos , size - pos ) ; buffer Pos = size - pos ; return bytes ; } else { final int original Buffer Pos = buffer Pos ; final int original Buffer Size = buffer Size ; total Bytes Retired += buffer Size ; buffer Pos = _ NUM ; buffer Size = _ NUM ; int size Left = size - ( original Buffer Size - original Buffer Pos ) ; final  List < byte [ ] > chunks = new  Array List < byte [ ] > ( ) ; while ( size Left > _ NUM ) { final byte [ ] chunk = new byte [  Math . min ( size Left ,  BUFFER_ SIZE ) ] ; int pos = _ NUM ; while ( pos < chunk . length ) { final int n = ( input == null ) ? - _ NUM : input . read ( chunk , pos , chunk . length - pos ) ; if ( n == - _ NUM ) { throw  Invalid Protocol Buffer Exception . truncated Message ( ) ; } total Bytes Retired += n ; pos += n ; } size Left -= chunk . length ; chunks . add ( chunk ) ; } final byte [ ] bytes = new byte [ size ] ; int pos = original Buffer Size - original Buffer Pos ;  System . arraycopy ( buffer , original Buffer Pos , bytes , _ NUM , pos ) ; for ( final byte [ ] chunk : chunks ) {  System . arraycopy ( chunk , _ NUM , bytes , pos , chunk . length ) ; pos += chunk . length ; } return bytes ; } }
private void delete Attrs (  Svc Reg reg ,  Entry Rep entry , boolean check Dups ) {  Entry Class eclass = entry . eclass ; delete Instance ( eclass ) ;  Object [ ] fields = entry . fields ; if ( fields . length == _ NUM ) {  Array List regs = (  Array List ) service By Empty Attr . get ( eclass ) ; if ( regs == null || ( check Dups && has Empty Attr ( reg , eclass ) ) ) return ; int idx = regs . index Of ( reg ) ; if ( idx >= _ NUM ) { regs . remove ( idx ) ; if ( regs . is Empty ( ) ) service By Empty Attr . remove ( eclass ) ; } return ; } for ( int fldidx = fields . length ; -- fldidx >= _ NUM ; ) { eclass = get Defining Class ( eclass , fldidx ) ;  Hash Map [ ] attr Maps = (  Hash Map [ ] ) service By Attr . get ( eclass ) ; if ( attr Maps == null || attr Maps [ fldidx ] == null || ( check Dups && has Attr ( reg , eclass , fldidx , fields [ fldidx ] ) ) ) continue ;  Hash Map map = attr Maps [ fldidx ] ;  Object value = fields [ fldidx ] ;  Array List regs = (  Array List ) map . get ( value ) ; if ( regs == null ) continue ; int idx = regs . index Of ( reg ) ; if ( idx < _ NUM ) continue ; regs . remove ( idx ) ; if ( ! regs . is Empty ( ) ) continue ; map . remove ( value ) ; if ( ! map . is Empty ( ) ) continue ; attr Maps [ fldidx ] = null ; if ( all Null ( attr Maps ) ) service By Attr . remove ( eclass ) ; } }
public static boolean implements Zero Arg Method (  Class Node class Node ,  String method Name ) { return implements Method ( class Node , method Name , new  Class [ _ NUM ] ) ; }
private void save Log File (  License license ,  Properties props ) {  File log File = get Log File ( license ) ; logger . fine ( _ STR + props ) ; try { final  Output Stream out = new  File Output Stream ( log File ) ; try { props . store ( out ,  String . format (  LOG_ HEADER , new Date ( ) ) ) ; } finally { out . close ( ) ; } } catch (  IOException ex ) { logger . log (  Level .  SEVERE , _ STR + log File . get Absolute Path ( ) , ex ) ; } }
public  Whitespace Tokenizer Factory (  Map <  String ,  String > args ) { super ( args ) ; rule = get ( args , _ STR ,  RULE_ NAMES ,  RULE_ JAVA ) ; if ( ! args . is Empty ( ) ) { throw new  Illegal Argument Exception ( _ STR + args ) ; } }
public static int update (  W q ,  V v ) {  String passwd = (  String ) v . value ( _ STR ) ; if ( !  X . is Empty ( passwd ) ) { passwd = encrypt ( passwd ) ; v . set ( _ STR , passwd , _ BOOL ) ; } else { v . remove ( _ STR ) ; } return  Helper . update ( q , v . set ( _ STR ,  System . current Time Millis ( ) ) ,  User . class ) ; }
@  Override public  String to String ( ) {  String Buffer text = new  String Buffer ( ) ; if ( m_train Instances == null ) { text . append ( _ STR ) ; } else { text . append ( _ STR ) ; if ( ! m_missing_merge ) { text . append ( _ STR ) ; } } text . append ( _ STR ) ; return text . to String ( ) ; }
public boolean is Private User Group ( ) { return is Private User Group ( this . type , this . auto Delete , this . name ) ; }
public void test_get Put Byte Array With Offset And Length ( ) { final int capacity = _ NUM ; final  Byte Array Buffer buf = new  Byte Array Buffer ( capacity ) ; assert Equals ( ( byte ) _ NUM , buf . get Byte ( _ NUM ) ) ; assert Equals ( ( byte ) _ NUM , buf . get Byte ( capacity - _ NUM ) ) ; final int pos = _ NUM ; for ( int i = _ NUM ; i <  LIMIT ; i ++ ) { final byte [ ] expected = new byte [ r . next Int ( capacity - _ NUM ) ] ; final int off = ( expected . length / _ NUM == _ NUM ? _ NUM : r . next Int ( expected . length / _ NUM ) ) ; final int len = ( expected . length == _ NUM ? _ NUM : r . next Int ( expected . length - off ) ) ; r . next Bytes ( expected ) ; buf . put ( pos , expected , off , len ) ; assert Equals ( _ NUM ,  Bytes Util . compare Bytes With Len And Offset ( off , len , expected , pos , len , buf . array ( ) ) ) ; final int dstoff = r . next Int ( _ NUM ) ; final byte [ ] actual = new byte [ expected . length + dstoff ] ; buf . get ( pos , actual , dstoff , expected . length ) ; assert Equals ( _ NUM ,  Bytes Util . compare Bytes With Len And Offset ( off , len , expected , dstoff , len , actual ) ) ; } assert Equals ( ( byte ) _ NUM , buf . get Byte ( _ NUM ) ) ; assert Equals ( ( byte ) _ NUM , buf . get Byte ( pos + capacity - _ NUM ) ) ; }
public void add Item ( int position ,  M model ) { m Datas . add ( position , model ) ; notify Data Set Changed ( ) ; }
public  Field Action (  String name ) { super (  I18n . tr ( name ) ) ; }
public static  Collection Id parse (  String str ) {  String [ ] parts = str . split ( _ STR + _ STR + _ STR ) ; if ( parts . length < _ NUM ) return null ; return new  Collection Id ( parts [ _ NUM ] , parts [ _ NUM ] , parts [ _ NUM ] ) ; }
public synchronized void unlisten ( final  Set <  Notification Channel > channel Names ) { m_channels . remove All ( channel Names ) ; }
private static <  T > void display Property Values (  Console Application app ,  Property Definition <  T > pd ,  Collection <  T > values ) {  Table Builder builder = new  Table Builder ( ) ;  Property Value Printer value Printer = new  Property Value Printer ( null , null , _ BOOL ) ; int sz = values . size ( ) ; boolean use Multiple Columns = ( sz >=  MULTI_ COLUMN_ THRESHOLD ) ; int rows = sz ; if ( use Multiple Columns ) { rows /= _ NUM ; rows += sz % _ NUM ; }  List <  T > vl = new  Array List < > ( values ) ; for ( int i = _ NUM , j = rows ; i < rows ; i ++ , j ++ ) { builder . start Row ( ) ; builder . append Cell ( _ STR ) ; builder . append Cell ( value Printer . print ( pd , vl . get ( i ) ) ) ; if ( use Multiple Columns && j < sz ) { builder . append Cell ( ) ; builder . append Cell ( _ STR ) ; builder . append Cell ( value Printer . print ( pd , vl . get ( j ) ) ) ; } }  Text Table Printer printer = new  Text Table Printer ( app . get Error Stream ( ) ) ; printer . set Display Headings ( _ BOOL ) ; printer . set Indent Width ( _ NUM ) ; printer . set Column Width ( _ NUM , _ NUM ) ; if ( use Multiple Columns ) { printer . set Column Width ( _ NUM , _ NUM ) ; printer . set Column Width ( _ NUM , _ NUM ) ; } builder . print ( printer ) ; }
@  Override default  Completable Future <  Optional Int > min Int ( final  To Int Function < ? super  T > fn ) { return  Completable Future . supply Async ( null , get Exec ( ) ) ; }
public void test Write1 ( ) throws  Exception { byte [ ] data = new byte [ ] { - _ NUM , - _ NUM , - _ NUM , - _ NUM , - _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM } ;  Test Output Stream tos = new  Test Output Stream ( ) ;  Cipher Output Stream cos = new  Cipher Output Stream ( tos , new  Null Cipher ( ) ) ; for ( int i = _ NUM ; i < data . length ; i ++ ) { cos . write ( data [ i ] ) ; } cos . flush ( ) ; byte [ ] result = tos . to Byte Array ( ) ; if ( !  Arrays . equals ( result , data ) ) { fail ( _ STR ) ; } }
public  Logging Event decode ( final  String data ) {  Document document = parse ( data ) ; if ( document == null ) { return null ; }  Vector events = decode Events ( document ) ; if ( events . size ( ) > _ NUM ) { return (  Logging Event ) events . first Element ( ) ; } return null ; }
private boolean check If Vplex Volume Has Active Associated Volumes (  Volume volume ) { boolean active Associated Volumes = _ BOOL ; if ( volume != null && volume . get Associated Volumes ( ) != null ) { for (  String associated Volume Uri : volume . get Associated Volumes ( ) ) {  Volume associated Volume = _db Client . query Object (  Volume . class ,  URI . create ( associated Volume Uri ) ) ; if ( associated Volume != null && ! associated Volume . get Inactive ( ) ) { _log . warn ( _ STR , volume . get Label ( ) , associated Volume . get Label ( ) ) ; if ( associated Volume . get Native Id ( ) == null ) { _log . warn ( _ STR , associated Volume . get Id ( ) , associated Volume . get Native Id ( ) ) ; _db Client . mark For Deletion ( associated Volume ) ; } else { active Associated Volumes = _ BOOL ; } } } } return active Associated Volumes ; }
public static void drop All (  Connection conn ) throws  SQLException {  Statement stat = conn . create Statement ( ) ; stat . execute ( _ STR +  SCHEMA ) ; remove All Triggers ( conn ,  TRIGGER_ PREFIX ) ; remove Index Files ( conn ) ; }
public static  String decode ( final  String escaped , final  String charset ) throws  URIException { return  Coder . decode ( escaped . to Char Array ( ) , charset ) ; }
public void run ( ) { _set Running ( _ BOOL ) ; while ( _keep Running ( ) ) { if ( _activity Count ( ) > _ NUM ) { long current Time =  System . current Time Millis ( ) ; long t = - _ NUM ; synchronized ( this ) { for ( int i = _ NUM ; i < m_activities . size ( ) ; i ++ ) {  Activity a = (  Activity ) m_activities . get ( i ) ; m_tmp . add ( a ) ; if ( current Time >= a . get Stop Time ( ) ) { m_activities . remove ( i -- ) ; a . set Scheduled ( _ BOOL ) ; } } if ( m_activities . size ( ) == _ NUM ) { m_next Time =  Long .  MAX_ VALUE ; } } for ( int i = _ NUM ; i < m_tmp . size ( ) ; i ++ ) {  Activity a = (  Activity ) m_tmp . get ( i ) ; long s = a . run Activity ( current Time ) ; t = ( s < _ NUM ? t : t < _ NUM ? s :  Math . min ( t , s ) ) ; } m_tmp . clear ( ) ; if ( t == - _ NUM ) continue ; try { synchronized ( this ) { wait ( t ) ; } } catch (  Interrupted Exception e ) { } } else { try { synchronized ( this ) { wait ( ) ; } } catch (  Interrupted Exception e ) { } } } }
public static void shift Mapping Vector (  Vector mvec , int shift ) { for ( int i = _ NUM ; i < mvec . size ( ) ; i ++ ) {  Vector line = (  Vector ) mvec . element At ( i ) ; for ( int j = _ NUM ; j < line . size ( ) ; j ++ ) {  Mapping Object mobj = (  Mapping Object ) line . element At ( j ) ; if ( mobj . type ==  BEGIN_ TLATOKEN ) {  Begin TLAToken obj = (  Begin TLAToken ) mobj ; obj . set Column ( obj . get Column ( ) + shift ) ; } else if ( mobj . type ==  END_ TLATOKEN ) {  End TLAToken obj = (  End TLAToken ) mobj ; obj . set Column ( obj . get Column ( ) + shift ) ; } else if ( mobj . type ==  SOURCE_ TOKEN ) {  Source Token obj = (  Source Token ) mobj ; obj . set Begin Column ( obj . get Begin Column ( ) + shift ) ; obj . set End Column ( obj . get End Column ( ) + shift ) ; } } } }
public static boolean match Name (  String query Name , byte [ ] line , int line Length ) { int start = _ NUM ; if ( line [ start ] == _ STR || line [ _ NUM ] == _ STR ) start ++ ; while (  Character . is Whitespace ( line [ start ] ) && start < line Length ) start ++ ; int end = start ; while ( !  Character . is Whitespace ( line [ end ] ) && end < line Length ) { end ++ ; } if ( end - start != query Name . length ( ) ) return _ BOOL ; for ( int i = _ NUM ; i < query Name . length ( ) ; i ++ ) { if ( query Name . char At ( i ) != ( char ) line [ start + i ] ) return _ BOOL ; } return _ BOOL ; }
public void add Message (  Localizable Message message ) { messages . add ( message ) ; }
public static  List <  Object > evaluate (  List <  Object > list ,  Bindings bindings ) throws  Expression Exception {  List <  Object > evaluated List = new  Array List < > ( ) ; for (  Object object : list ) { evaluated List . add ( evaluate ( object , bindings ) ) ; } return evaluated List ; }
public <  E extends  T >  E max (  Iterable <  E > iterable ) {  Iterator <  E > iterator = iterable . iterator ( ) ;  E max So Far = iterator . next ( ) ; while ( iterator . has Next ( ) ) { max So Far = max ( max So Far , iterator . next ( ) ) ; } return max So Far ; }
int read ( byte [ ] b , int off , int len , boolean copy ) throws  IOException { if ( len == _ NUM ) { return _ NUM ; } else if ( blkmode ) { if ( pos == end ) { refill ( ) ; } if ( end < _ NUM ) { return - _ NUM ; } int nread =  Math . min ( len , end - pos ) ;  System . arraycopy ( buf , pos , b , off , nread ) ; pos += nread ; return nread ; } else if ( copy ) { int nread = in . read ( buf , _ NUM ,  Math . min ( len ,  MAX_ BLOCK_ SIZE ) ) ; if ( nread > _ NUM ) {  System . arraycopy ( buf , _ NUM , b , off , nread ) ; } return nread ; } else { return in . read ( b , off , len ) ; } }
public boolean matches (  Inventory Crafting crafting ,  World world ) { final  List <  Item Stack > recipe List = new  Array List <  Item Stack > ( this . recipe Items ) ; for ( int i = _ NUM ; i < _ NUM ; ++ i ) { for ( int j = _ NUM ; j < _ NUM ; ++ j ) { final  Item Stack actual = crafting . get Stack In Row And Column ( j , i ) ; if ( actual != null ) { boolean flag = _ BOOL ; final  Iterator <  Item Stack > iterator = recipe List . iterator ( ) ; while ( iterator . has Next ( ) ) { final  Item Stack expected = iterator . next ( ) ; if ( comparator . equals ( expected , actual ) ) { flag = _ BOOL ; recipe List . remove ( expected ) ; break ; } } if ( ! flag ) { return _ BOOL ; } } } } return recipe List . is Empty ( ) ; }
public static int how Many Hours Old ( long time ) { return ( int ) ( (  System . current Time Millis ( ) - time ) /  Date Utils .  HOUR_ IN_ MILLIS ) ; }
protected boolean is WFXMLChar (  String chardata ,  Character ref Invalid Char ) { if ( chardata == null || ( chardata . length ( ) == _ NUM ) ) { return _ BOOL ; } char [ ] dataarray = chardata . to Char Array ( ) ; int datalength = dataarray . length ; if ( f Is XMLVersion11 ) { int i = _ NUM ; while ( i < datalength ) { if (  XML11 Char . is XML11 Invalid ( dataarray [ i ++ ] ) ) { char ch = dataarray [ i - _ NUM ] ; if (  XMLChar . is High Surrogate ( ch ) && i < datalength ) { char ch2 = dataarray [ i ++ ] ; if (  XMLChar . is Low Surrogate ( ch2 ) &&  XMLChar . is Supplemental (  XMLChar . supplemental ( ch , ch2 ) ) ) { continue ; } } ref Invalid Char = new  Character ( ch ) ; return _ BOOL ; } } } else { int i = _ NUM ; while ( i < datalength ) { if (  XMLChar . is Invalid ( dataarray [ i ++ ] ) ) { char ch = dataarray [ i - _ NUM ] ; if (  XMLChar . is High Surrogate ( ch ) && i < datalength ) { char ch2 = dataarray [ i ++ ] ; if (  XMLChar . is Low Surrogate ( ch2 ) &&  XMLChar . is Supplemental (  XMLChar . supplemental ( ch , ch2 ) ) ) { continue ; } } ref Invalid Char = new  Character ( ch ) ; return _ BOOL ; } } } return _ BOOL ; }
public void test Neg Pos Same Length ( ) {  String num A = _ STR ;  String num B = _ STR ;  String res = _ STR ;  Big Integer a Number = new  Big Integer ( num A ) ;  Big Integer b Number = new  Big Integer ( num B ) ;  Big Integer result = a Number . xor ( b Number ) ; assert True ( res . equals ( result . to String ( ) ) ) ; }
public final  Parallel Flux <  T > do On Subscribe (  Consumer < ? super  Subscription > on Subscribe ) {  Objects . require Non Null ( on Subscribe , _ STR ) ; return do On Signal ( this , null , null , null , null , null , on Subscribe , null , null ) ; }
protected void add Missing (  Instances data , int level , boolean attribute Missing , boolean class Missing , int attr Index ) { int class Index = data . class Index ( ) ;  Random random = new  Random ( _ NUM ) ; for ( int i = _ NUM ; i < data . num Instances ( ) ; i ++ ) {  Instance current = data . instance ( i ) ; for ( int j = _ NUM ; j < data . num Attributes ( ) ; j ++ ) { if ( ( ( j == class Index ) && class Missing ) || ( ( j == attr Index ) && attribute Missing ) ) { if (  Math . abs ( random . next Int ( ) ) % _ NUM < level ) { current . set Missing ( j ) ; } } } } }
public <  T extends  Data Object > void update In Batches (  List <  T > records , int partition Size ,  Db Client db Client ,  String type ) {  List <  List <  T > > volume_partitions =  Lists . partition ( records , partition Size ) ; for (  List <  T > partition : volume_partitions ) { try { db Client . update Object ( partition ) ; _log . info ( _ STR , partition . size ( ) , type ) ; } catch (  Database Exception e ) { _log . error ( _ STR , type , e ) ; } } }
public void create (  SSOToken token ,  String obj Name ,  Map attrs ) throws  SMSException ,  SSOException { if ( ( obj Name == null ) || ( obj Name . length ( ) == _ NUM ) || ( attrs == null ) ) { throw new  Illegal Argument Exception ( _ STR + _ STR ) ; }  String attribute File Name = null ; m RWLock . read Request ( ) ; try { if ( root . is Exists ( m Root Dir , obj Name ) ) {  String errmsg = _ STR + obj Name ; m Debug . error ( errmsg ) ; throw new  Service Already Exists Exception ( errmsg ) ; } } finally { m RWLock . read Done ( ) ; } m RWLock . write Request ( ) ; if ( root . is Exists ( m Root Dir , obj Name ) ) {  String errmsg = _ STR + obj Name ; m Debug . error ( errmsg ) ; throw new  Service Already Exists Exception ( errmsg ) ; }  SMSFlat File Tree Node node = new  SMSFlat File Tree Node ( obj Name ) ;  String filepath = node . get Attribute Filename ( m Root Dir ) ; try {  Set sunserviceids = null ;  Set sunxmlkeyvals = null ;  Properties props = new  Properties ( ) ;  Set keys = attrs . key Set ( ) ; if ( keys != null ) { for (  Iterator i = keys . iterator ( ) ; i . has Next ( ) ; ) {  String key = (  String ) i . next ( ) ;  Set vals = (  Set ) attrs . get ( key ) ; if ( key . equals Ignore Case (  SMSEntry .  ATTR_ SERVICE_ ID ) ) { sunserviceids = vals ; } else if ( key . equals Ignore Case (  SMSEntry .  ATTR_ XML_ KEYVAL ) ) { sunxmlkeyvals = vals ; } props . put ( key , to Val String ( vals ) ) ; } } try {  File attr File = new  File ( filepath ) ; try { if ( ! attr File . create New File ( ) ) {  String errmsg = _ STR + obj Name + _ STR + filepath ; m Debug . error ( errmsg ) ; throw new  SMSException ( errmsg ) ; } } catch (  IOException e ) {  String errmsg = _ STR + obj Name + _ STR + filepath + _ STR + e . get Message ( ) ; m Debug . error ( _ STR , e ) ; throw new  SMSException ( errmsg ) ; } save Properties ( props , attr File , obj Name ) ; create Sun Service Id Files ( node , sunserviceids ) ; create Sun Xml Key Val Files ( node , sunxmlkeyvals ) ; if ( ! root . add Child ( node ) ) { throw new  SMSException ( _ STR + obj Name ) ; } save Directory Tree ( ) ; } catch (  SMSException e ) {  File attr File = new  File ( filepath ) ; try { attr File . delete ( ) ; } catch (  Security Exception se ) { } throw e ; } } finally { m RWLock . write Done ( ) ; } }
public void add On Tab Selected Listener (  On Tab Selected Listener listener ) { if ( listener != null ) { m Listeners . add ( listener ) ; } }
public synchronized void create ( long seqno ) throws  Replicator Exception ,  Interrupted Exception { if ( file . exists ( ) ) { throw new  THLException ( _ STR + file . get Name ( ) ) ; } try { data Output = new  Buffered File Data Output ( file , buffer Size ) ; } catch (  IOException e ) { throw new  THLException ( _ STR + file . get Name ( ) , e ) ; } mode =  Access Mode . write ; try { write (  MAGIC_ NUMBER ) ; write (  MAJOR_ VERSION ) ; write (  MINOR_ VERSION ) ; write ( seqno ) ; flush ( ) ; } catch (  IOException e ) { throw new  THLException ( _ STR + file . get Name ( ) , e ) ; } base Seqno = seqno ; if ( log Flush Task != null ) log Flush Task . add Log File ( this ) ; }
private  CIMObject Path [ ] expose Paths With Volumes Only (  Storage System storage ,  URI export Mask URI ,  Volume URIHLU [ ] volume URIHLUs ) throws  Exception {  CIMArgument [ ] in Args = _helper . get Create Or Grow Storage Group Input Arguments ( storage , export Mask URI , volume URIHLUs , null , null ) ;  CIMArgument [ ] out Args = new  CIMArgument [ _ NUM ] ; _helper . invoke Method ( storage , _cim Path . get Controller Config Svc Path ( storage ) , _ STR , in Args , out Args ) ; return _cim Path . get Protocol Controllers From Output Args ( out Args ) ; }
public boolean is Selected ( ) { return check Box . is Selected ( ) ; }
public  Cycle Bound Tick ( boolean map To Last Cycle ,  Number number ,  String label ,  Text Anchor text Anchor ,  Text Anchor rotation Anchor , double angle ) { super ( number , label , text Anchor , rotation Anchor , angle ) ; this . map To Last Cycle = map To Last Cycle ; }
private boolean is Running ( ) { return thread != null ; }
private void log Multi Object Delete Exception (  Multi Object Delete Exception multi Object Delete Exception ) {  String Builder builder = new  String Builder ( _ NUM ) ; builder . append (  String . format ( _ STR ) ) ;  List <  Delete Error > delete Errors = multi Object Delete Exception . get Errors ( ) ; for (  Delete Error delete Error : delete Errors ) {  String key = delete Error . get Key ( ) ;  String version Id = delete Error . get Version Id ( ) ;  String code = delete Error . get Code ( ) ;  String message = delete Error . get Message ( ) ; builder . append (  String . format ( _ STR , key , version Id , code , message ) ) ; }  LOGGER . error ( builder . to String ( ) ) ; }
public void add Member (  Stream member ) { member Set . add ( member ) ; }
public boolean visible From (  Ct Class clazz ) { int mod = get Modifiers ( ) ; if (  Modifier . is Public ( mod ) ) return _ BOOL ; else if (  Modifier . is Private ( mod ) ) return clazz == declaring Class ; else {  String decl Name = declaring Class . get Package Name ( ) ;  String from Name = clazz . get Package Name ( ) ; boolean visible ; if ( decl Name == null ) visible = from Name == null ; else visible = decl Name . equals ( from Name ) ; if ( ! visible &&  Modifier . is Protected ( mod ) ) return clazz . subclass Of ( declaring Class ) ; return visible ; } }
public  JSONBuffer append Key Array (  Object key ) { if ( stack . empty ( ) || stack . peek ( ) !=  Operand .  HASH ) { throw new  JSONException ( _ STR ) ; } add Quoted String ( key ) ; buffer . append ( _ STR ) ; buffer . append ( _ STR ) ; stack . push (  Operand .  ARRAY ) ; return this ; }
public static  Tungsten Properties load Passwords From Authentication Info (  Authentication Info authentication Info ) throws  Server Runtime Exception { try {  String password File Location = authentication Info . get Password File Location ( ) ;  Tungsten Properties new Props = new  Tungsten Properties ( ) ; new Props . load ( new  File Input Stream ( password File Location ) , _ BOOL ) ; new Props . trim ( ) ; logger . debug (  Message Format . format ( _ STR , password File Location ) ) ; return new Props ; } catch (  File Not Found Exception e ) { throw new  Server Runtime Exception ( _ STR + authentication Info . get Password File Location ( ) , e ) ; } catch (  IOException e ) { throw new  Server Runtime Exception ( _ STR + authentication Info . get Password File Location ( ) , e ) ; } }
public void error (  Level level ,  String message Id ,  String data [ ] ,  Object session ,  Map props ) throws  Log Exception { if ( is Error Loggable ( level ) ) {  Log Record lr = new  Log Record ( level , format Message ( message Id , data , session ) ) ; error Logger . log ( lr ) ; } }
public synchronized int index Of (  IAudio Processor processor ) { return processors . index Of ( processor ) ; }
private int end Recover Animation (  Recycler View .  View Holder view Holder , boolean override ) { final int recover Anim Size = m Recover Animations . size ( ) ; for ( int i = recover Anim Size - _ NUM ; i >= _ NUM ; i -- ) { final  Recover Animation anim = m Recover Animations . get ( i ) ; if ( anim . m View Holder == view Holder ) { anim . m Overridden |= override ; if ( ! anim . m Ended ) { anim . cancel ( ) ; } m Recover Animations . remove ( i ) ; return anim . m Animation Type ; } } return _ NUM ; }
private boolean is Test Method (  Method m ) {  String name = m . get Name ( ) ;  Class [ ] parameters = m . get Parameter Types ( ) ;  Class return Type = m . get Return Type ( ) ; return parameters . length == _ NUM && name . starts With ( _ STR ) && return Type . equals (  Void .  TYPE ) ; }
void update Pressed (  Action Event e , boolean new Signal Group , boolean close ) { if ( cur Signal Group == null ) { if ( ! check New Names OK ( ) ) { return ; } } if ( ! check Valid Signal Mast ( ) ) { return ; }  String u Name = _user Name . get Text ( ) ;  Signal Group g = check Names OK ( ) ; if ( g == null ) { return ; } cur Signal Group = g ; g . set User Name ( u Name ) ; initialize Included List ( ) ; set Signal Information ( g ) ; set Mast Appearance Information ( g ) ; g . set Signal Mast ( (  Signal Mast ) main Signal . get Selected Bean ( ) , main Signal . get Selected Display Name ( ) ) ;  Signal Group Dirty = _ BOOL ; if ( close ) { finish Update ( ) ; } }
protected  String attribute Values String (  Instance instance ) {  String Buffer text = new  String Buffer ( ) ; if ( m_ Attributes != null ) { m_ Attributes . set Upper ( instance . num Attributes ( ) - _ NUM ) ; boolean first = _ BOOL ; for ( int i = _ NUM ; i < instance . num Attributes ( ) ; i ++ ) { if ( m_ Attributes . is In Range ( i ) && i != instance . class Index ( ) ) { if ( ! first ) { text . append ( m_ Delimiter ) ; } text . append ( instance . to String ( i ) ) ; first = _ BOOL ; } } } return text . to String ( ) ; }
private static void check For KOML ( ) { try {  Class . for Name ( _ STR ) ; m_ Present = _ BOOL ; } catch (  Exception e ) { m_ Present = _ BOOL ; } }
@  Target Api (  Build .  VERSION_ CODES .  GINGERBREAD_ MR1 ) private  Response <  Bitmap > do Parse (  Network Response response ) { byte [ ] data = response . data ;  Bitmap Factory .  Options decode Options = new  Bitmap Factory .  Options ( ) ; decode Options . in Input Shareable = _ BOOL ; decode Options . in Purgeable = _ BOOL ; decode Options . in Preferred Config = m Decode Config ;  Bitmap bitmap ; if ( m Max Width == _ NUM && m Max Height == _ NUM ) { bitmap =  Bitmap Factory . decode Byte Array ( data , _ NUM , data . length , decode Options ) ; } else { decode Options . in Just Decode Bounds = _ BOOL ;  Bitmap Factory . decode Byte Array ( data , _ NUM , data . length , decode Options ) ; int actual Width = decode Options . out Width ; int actual Height = decode Options . out Height ; int desired Width = get Resized Dimension ( m Max Width , m Max Height , actual Width , actual Height , m Scale Type ) ; int desired Height = get Resized Dimension ( m Max Height , m Max Width , actual Height , actual Width , m Scale Type ) ; decode Options . in Just Decode Bounds = _ BOOL ; if (  Utils . has Gingerbread MR1 ( ) ) { decode Options . in Prefer Quality Over Speed =  PREFER_ QUALITY_ OVER_ SPEED ; } decode Options . in Sample Size =  Image Utils . find Best Sample Size ( actual Width , actual Height , desired Width , desired Height ) ;  Bitmap temp Bitmap =  Bitmap Factory . decode Byte Array ( data , _ NUM , data . length , decode Options ) ; if ( temp Bitmap != null && ( temp Bitmap . get Width ( ) > desired Width || temp Bitmap . get Height ( ) > desired Height ) ) { bitmap =  Bitmap . create Scaled Bitmap ( temp Bitmap , desired Width , desired Height , _ BOOL ) ; temp Bitmap . recycle ( ) ; } else { bitmap = temp Bitmap ; } } if ( bitmap == null ) { return  Response . error ( new  Parse Error ( response ) ) ; } else { return  Response . success ( bitmap ,  Http Header Parser . parse Cache Headers ( response ) ) ; } }
public double evaluate (  Vector Instance x ,  Vector Instance y ) throws  Exception { double dot Prod = x . dot Product ( y ) ; double z = m_gamma * dot Prod + m_coef0 ; double a =  Math . exp ( z ) ; double b =  Math . exp ( - z ) ; return ( ( a - b ) / ( a + b ) ) ; }
@  Override public void batch Size ( int size ) {  A . ensure ( size > _ NUM , _ STR + size ) ; lock . lock ( ) ; try { batch Size = size ; } finally { lock . unlock ( ) ; } }
public void clear ( ) { m Search Results . clear ( ) ; m All Songs . clear ( ) ; m All Artists . clear ( ) ; m All Playlists . clear ( ) ; m All Albums . clear ( ) ; m Sorted Songs . clear ( ) ; m Sorted Artists . clear ( ) ; m Sorted Playlists . clear ( ) ; m Sorted Albums . clear ( ) ; }
public  FPSTexture View remove Child ( @  Non Null  Display Base display Base ) { display Base . disable ( ) ; boolean a = m Display List . remove ( display Base ) ; return this ; }
private double [ ] prune (  Tree tree ,  Node Ref node ,  Colour Change Matrix mm ) { double [ ] p = new double [ colour Count ] ; if ( tree . is External ( node ) ) { p [ get Colour ( node ) ] = _ NUM ; } else {  Node Ref left Child = tree . get Child ( node , _ NUM ) ;  Node Ref right Child = tree . get Child ( node , _ NUM ) ; double [ ] left = prune ( tree , left Child , mm ) ; double [ ] right = prune ( tree , right Child , mm ) ; double node Height = tree . get Node Height ( node ) ; double left Time = node Height - tree . get Node Height ( tree . get Child ( node , _ NUM ) ) ; double right Time = node Height - tree . get Node Height ( tree . get Child ( node , _ NUM ) ) ; double maxp = _ NUM ; for ( int i = _ NUM ; i < colour Count ; i ++ ) { double left Sum = _ NUM ; double right Sum = _ NUM ; for ( int j = _ NUM ; j < colour Count ; j ++ ) { left Sum += mm . forward Time Evolution ( i , j , left Time ) * left [ j ] ; right Sum += mm . forward Time Evolution ( i , j , right Time ) * right [ j ] ; } p [ i ] = left Sum * right Sum ; if ( p [ i ] > maxp ) { maxp = p [ i ] ; } } if ( maxp < _ NUM ) { for ( int i = _ NUM ; i < colour Count ; i ++ ) { p [ i ] *= _ NUM ; } log Node Partials Rescaling -=  Math . log ( _ NUM ) ; } } node Partials [ node . get Number ( ) ] = p ; if ( debug Node Partials ) { pretty Print ( _ STR + node . get Number ( ) + _ STR , p ) ; } return p ; }
private void bfs ( char [ ] [ ] grid , int i , int j ) {  Queue <  Point > queue = new  Array Deque < > ( ) ; grid [ i ] [ j ] = _ STR ; queue . add ( new  Point ( i , j ) ) ; while ( ! queue . is Empty ( ) ) {  Point p = queue . poll ( ) ; for ( int [ ] dir : dirs ) { int row = p . row + dir [ _ NUM ] ; int col = p . col + dir [ _ NUM ] ; if ( row >= _ NUM && row < grid . length && col >= _ NUM && col < grid [ row ] . length && grid [ row ] [ col ] == _ STR ) { grid [ row ] [ col ] = _ STR ; queue . add ( new  Point ( row , col ) ) ; } } } }
public  Time (  Date date ) {  Simple Time Zone tz = new  Simple Time Zone ( _ NUM , _ STR ) ;  Simple Date Format date F = new  Simple Date Format ( _ STR ) ; date F . set Time Zone ( tz ) ;  String d = date F . format ( date ) + _ STR ; int year =  Integer . parse Int ( d . substring ( _ NUM , _ NUM ) ) ; if ( year < _ NUM || year > _ NUM ) { time = new  DERGeneralized Time ( d ) ; } else { time = new  DERUTCTime ( d . substring ( _ NUM ) ) ; } }
public  DImport Key Pair Open Ssl (  JFrame parent ) { super ( parent ,  Dialog .  Modality Type .  DOCUMENT_ MODAL ) ; init Components ( ) ; }
public static  Automaton determinize Simple (  Automaton a ) {  Set <  Integer > initialset = new  Hash Set < > ( ) ; initialset . add ( _ NUM ) ; return determinize Simple ( a , initialset ) ; }
@  Override public boolean equals (  Object o ) { if ( this == o ) return _ BOOL ; if ( o == null || get Class ( ) != o . get Class ( ) ) return _ BOOL ;  Abstract Drawer Item < ? , ? > that = (  Abstract Drawer Item < ? , ? > ) o ; return m Identifier == that . m Identifier ; }
public void add Column (  Column previous Column ,  Column column ) { if ( column != null ) { if ( previous Column == null ) { columns . add ( _ NUM , column ) ; } else { columns . add ( columns . index Of ( previous Column ) , column ) ; } } }
protected double [ ] [ ] means With Treshhold (  List < ? extends  Modifiable Double DBIDList > clusters , double [ ] [ ] means ,  Relation <  V > database ,  Double tresh ) { double [ ] [ ] new Means = new double [ k ] [ ] ; for ( int i = _ NUM ; i < k ; i ++ ) {  Double DBIDList list = clusters . get ( i ) ; double [ ] raw = null ; int count = _ NUM ; for (  Double DBIDList Iter iter = list . iter ( ) ; iter . valid ( ) ; iter . advance ( ) ) { if ( iter . double Value ( ) >= tresh ) { continue ; }  Number Vector vec = database . get ( iter ) ; if ( raw == null ) { raw = vec . to Array ( ) ; } for ( int j = _ NUM ; j < raw . length ; j ++ ) { raw [ j ] += vec . double Value ( j ) ; } count ++ ; } new Means [ i ] = ( raw != null ) ?  VMath . times Equals ( raw , _ NUM / count ) : means [ i ] ; } return new Means ; }
public static  String build Selector From Elements And Attribute Value (  String element Name ,  String attribute Name ,  String attribute Value ) {  String Builder strb = new  String Builder ( ) ; strb . append ( element Name ) ; strb . append (  OPEN_ BRACKET ) ; strb . append ( attribute Name ) ; strb . append (  EQUAL ) ; strb . append ( attribute Value ) ; strb . append (  CLOSE_ BRACKET ) ; return strb . to String ( ) ; }
private void locate Uri Root (  File f ) {  String t Uri Base = uri Base ; if ( t Uri Base == null ) { t Uri Base = _ STR ; } try { if ( f . exists ( ) ) { f = new  File ( f . get Canonical Path ( ) ) ; while ( f != null ) {  File g = new  File ( f , _ STR ) ; if ( g . exists ( ) && g . is Directory ( ) ) { uri Root = f . get Canonical Path ( ) ; uri Base = t Uri Base ; if ( log . is Loggable (  Level .  INFO ) ) { log . info (  Localizer . get Message ( _ STR , uri Root ) ) ; } break ; } if ( f . exists ( ) && f . is Directory ( ) ) { t Uri Base = _ STR + f . get Name ( ) + _ STR + t Uri Base ; }  String f Parent = f . get Parent ( ) ; if ( f Parent == null ) { break ; } else { f = new  File ( f Parent ) ; } } if ( uri Root != null ) {  File froot = new  File ( uri Root ) ; uri Root = froot . get Canonical Path ( ) ; } } } catch (  IOException ioe ) { } }
@  Override public double calculate_ K ( int [ ] x_index , double [ ] x_att , int [ ] y_index , double [ ] y_att ) { return  Math . sqrt ( ( norm2 ( x_index , x_att , y_index , y_att ) / sigma ) + ( shift * shift ) ) ; }
@  Override public void close ( ) throws  IOException { synchronized ( lock ) { if ( is Closed ( ) ) { return ; }  Throwable thrown = null ; try { flush Internal ( ) ; } catch (  Throwable e ) { thrown = e ; } buf = null ; try { out . close ( ) ; } catch (  Throwable e ) { if ( thrown == null ) { thrown = e ; } } out = null ; if ( thrown != null ) {  Sneaky Throw . sneaky Throw ( thrown ) ; } } }
public static double cos ( double radians ) { return  Math . cos ( radians ) ; }
public static double ss Reg ( double [ ] residuals , double [ ] target Attribute ) { double mean = sum ( target Attribute ) / target Attribute . length ; double ret = _ NUM ; for ( int i = _ NUM ; i < residuals . length ; i ++ ) { ret +=  Math . pow ( residuals [ i ] - mean , _ NUM ) ; } return ret ; }
public void test Find Prefixes ( ) {  Vector <  String > prefixes = m_ Trie . get With Prefix ( _ STR ) ; assert Equals ( _ STR , _ NUM , prefixes . size ( ) ) ; prefixes = m_ Trie . get With Prefix ( _ STR ) ; assert Equals ( _ STR , _ NUM , prefixes . size ( ) ) ; }
public static  Timestamp convert Date Value To Timestamp ( long date Value , long time Nanos ) { long millis = time Nanos / _ NUM ; time Nanos -= millis * _ NUM ; long s = millis / _ NUM ; millis -= s * _ NUM ; long m = s / _ NUM ; s -= m * _ NUM ; long h = m / _ NUM ; m -= h * _ NUM ; long ms = get Millis ( null , year From Date Value ( date Value ) , month From Date Value ( date Value ) , day From Date Value ( date Value ) , ( int ) h , ( int ) m , ( int ) s , _ NUM ) ;  Timestamp ts = new  Timestamp ( ms ) ; ts . set Nanos ( ( int ) ( time Nanos + millis * _ NUM ) ) ; return ts ; }
public <  T extends  Enum <  T > >  T consume Enum (  String name , boolean required ,  Class <  T > enum Class ,  T default Value ) throws  Parse Exception {  String value = consume ( name , required ) ; if ( value == null ) { return default Value ; } try { return  Enum . value Of ( enum Class , value . to Upper Case ( ) ) ; } catch (  Illegal Argument Exception e ) {  Parse Exception pe = new  Parse Exception (  Core Error Domain .  ERR . invalid Attribute Value , e ) ; pe . set Internal Reason ( _ STR + name + _ STR ) ; throw pe ; } }
public final void copy ( byte [ ] bytes , int offset , int length ) { if ( this . bytes == null || this . bytes . length < length ) { this . bytes = new byte [ length ] ; }  System . arraycopy ( bytes , offset , this . bytes , _ NUM , length ) ; this . count = length ; }
public boolean has Key (  ECKey key ) { lock . lock ( ) ; try { return keychain . contains ( key ) ; } finally { lock . unlock ( ) ; } }
private void add Connection Group Descendants (  Collection <  Connection Group > parents ,  List <  Object Permission .  Type > permissions ) throws  Guacamole Exception { if ( parents . is Empty ( ) ) return ;  Collection <  String > child Connection Identifiers = new  Array List <  String > ( ) ;  Collection <  String > child Connection Group Identifiers = new  Array List <  String > ( ) ; for (  Connection Group parent : parents ) { child Connection Identifiers . add All ( parent . get Connection Identifiers ( ) ) ; child Connection Group Identifiers . add All ( parent . get Connection Group Identifiers ( ) ) ; } if ( permissions != null && ! permissions . is Empty ( ) ) child Connection Identifiers = connection Permissions . get Accessible Objects ( permissions , child Connection Identifiers ) ; if ( ! child Connection Identifiers . is Empty ( ) ) {  Collection <  Connection > child Connections = connection Directory . get All ( child Connection Identifiers ) ; add Connections ( child Connections ) ; add Connection Descendants ( child Connections , permissions ) ; } if ( ! child Connection Group Identifiers . is Empty ( ) ) {  Collection <  Connection Group > child Connection Groups = connection Group Directory . get All ( child Connection Group Identifiers ) ; add Connection Groups ( child Connection Groups ) ; add Connection Group Descendants ( child Connection Groups , permissions ) ; } }
public int skip Whitespace ( ) { try { int read Char = _ NUM ; char c =  SPACE ; while (  Character . is Whitespace ( c ) ) { reader . mark ( _ NUM ) ; read Char = reader . read ( ) ; c = ( char ) read Char ; } reader . reset ( ) ; return read Char ; } catch (  IOException ioe ) { throw new  Json Exception ( _ STR , ioe ) ; } }
public void add Doc Validate (  String table Name ,  Model Validator listener ) { if ( table Name == null || listener == null ) return ;  String property Name = m_global Validators . contains ( listener ) ? table Name + _ STR : table Name + listener . get AD_ Client_ ID ( ) ;  Array List <  Model Validator > list = (  Array List <  Model Validator > ) m_doc Validate Listeners . get ( property Name ) ; if ( list == null ) { list = new  Array List <  Model Validator > ( ) ; list . add ( listener ) ; m_doc Validate Listeners . put ( property Name , list ) ; } else if ( ! list . contains ( listener ) ) { list . add ( listener ) ; } }
public static void log Error Message (  String msg Id Name ,  String data [ ] ,  SSOToken token ) throws  SSOException { try { if ( msg Provider == null ) { msg Provider =  Message Provider Factory . get Provider ( _ STR ) ; } } catch (  IOException e ) { debug . error ( _ STR , e ) ; debug . error ( _ STR + _ STR ) ; log Status = _ BOOL ; } if ( ( error Logger != null ) && ( msg Provider != null ) ) {  Log Record lr = msg Provider . create Log Record ( msg Id Name , data , token ) ; if ( lr != null ) {  SSOToken sso Token = (  SSOToken )  Access Controller . do Privileged (  Admin Token Action . get Instance ( ) ) ; error Logger . log ( lr , sso Token ) ; } } }
public static boolean is Auto Scan Enabled (  Context context ) { final  Shared Preferences prefs =  Preference Manager . get Default Shared Preferences ( context ) ; return prefs . get Boolean ( context . get String (  R . string . pref_key_auto_scan_enabled ) ,  Boolean . parse Boolean ( context . get String (  R . string . pref_auto_scan_default_value ) ) ) ; }
Type Simplifier (  Types type Utils ,  String package Name ,  Set <  Type Mirror > types ,  Type Mirror base ) { this . type Utils = type Utils ;  Set <  Type Mirror > types Plus Base = new  Type Mirror Set ( types ) ; if ( base != null ) { types Plus Base . add ( base ) ; }  Set <  Type Mirror > referenced = referenced Class Types ( type Utils , types Plus Base ) ;  Set <  Type Mirror > defined = non Private Declared Types ( type Utils , base ) ; this . imports = find Imports ( type Utils , package Name , referenced , defined ) ; }
public static  Histogram subtract (  Histogram x , double y ) { return x . modify Event Counters ( null ) ; }
private  Point add Point (  Polygon arrow ,  Rectangle rect , int pos , boolean from ) { int x = rect . x ; int y = rect . y ;  Point point = null ; if ( pos ==  Swing Constants .  TOP ) { x += rect . width / _ NUM ; if ( from ) { arrow . add Point ( x - _ NUM , y ) ; arrow . add Point ( x + _ NUM , y ) ; } else arrow . add Point ( x , y ) ; point = new  Point ( x , y - _ NUM ) ; } else if ( pos ==  Swing Constants .  RIGHT ) { x += rect . width ; y += rect . height / _ NUM ; if ( from ) { arrow . add Point ( x , y - _ NUM ) ; arrow . add Point ( x , y + _ NUM ) ; } else arrow . add Point ( x , y ) ; point = new  Point ( x + _ NUM , y ) ; } else if ( pos ==  Swing Constants .  LEFT ) { y += rect . height / _ NUM ; if ( from ) { arrow . add Point ( x , y - _ NUM ) ; arrow . add Point ( x , y + _ NUM ) ; } else arrow . add Point ( x , y ) ; point = new  Point ( x - _ NUM , y ) ; } else { x += rect . width / _ NUM ; y += rect . height ; if ( from ) { arrow . add Point ( x - _ NUM , y ) ; arrow . add Point ( x + _ NUM , y ) ; } else arrow . add Point ( x , y ) ; point = new  Point ( x , y + _ NUM ) ; } return point ; }
private  Map <  UUID ,  Collection <  Hadoop Input Split > > mappers (  Collection <  Cluster Node > top ,  Collection <  UUID > top Ids ,  Iterable <  Hadoop Input Split > splits ) throws  Ignite Checked Exception {  Map <  UUID ,  Collection <  Hadoop Input Split > > mappers = new  Hash Map < > ( ) ;  Map <  String ,  Collection <  UUID > > nodes = group By Host ( top ) ;  Map <  UUID ,  Integer > node Loads = new  Hash Map < > ( top . size ( ) , _ NUM ) ; for (  UUID node Id : top Ids ) node Loads . put ( node Id , _ NUM ) ; for (  Hadoop Input Split split : splits ) {  UUID node Id = node For Split ( split , top Ids , nodes , node Loads ) ; if ( log . is Debug Enabled ( ) ) log . debug ( _ STR + split + _ STR + node Id + _ STR ) ;  Collection <  Hadoop Input Split > node Splits = mappers . get ( node Id ) ; if ( node Splits == null ) { node Splits = new  Array List < > ( ) ; mappers . put ( node Id , node Splits ) ; } node Splits . add ( split ) ; node Loads . put ( node Id , node Loads . get ( node Id ) + _ NUM ) ; } return mappers ; }
private void savepost Logout (  String post Location ,  String post Resp Location ,  List log List , com . sun . identity . saml2 . jaxb . metadata .  Object Factory obj Fact ) throws  JAXBException { if ( post Location != null && post Location . length ( ) > _ NUM ) {  Single Logout Service Element sls Elem Post = obj Fact . create Single Logout Service Element ( ) ; sls Elem Post . set Binding ( http Post Binding ) ; sls Elem Post . set Location ( post Location ) ; sls Elem Post . set Response Location ( post Resp Location ) ; log List . add ( sls Elem Post ) ; } }
public static  Intent create Take Picture Intent (  Activity ctx ,  Uri saving Uri ) { if ( saving Uri == null ) { throw new  Null Pointer Exception ( _ STR ) ; } final  List <  Intent > camera Intents = new  Array List <  Intent > ( ) ; final  Intent capture Intent = new  Intent (  Media Store .  ACTION_ IMAGE_ CAPTURE ) ; final  Package Manager package Manager = ctx . get Package Manager ( ) ; final  List <  Resolve Info > list Cam = package Manager . query Intent Activities ( capture Intent , _ NUM ) ; for (  Resolve Info res : list Cam ) { final  String package Name = res . activity Info . package Name ; final  Intent intent = new  Intent ( capture Intent ) ; intent . set Component ( new  Component Name ( res . activity Info . package Name , res . activity Info . name ) ) ; intent . set Package ( package Name ) ; intent . put Extra (  Media Store .  EXTRA_ OUTPUT , saving Uri ) ; camera Intents . add ( intent ) ; } final  Intent gallery Intent = new  Intent ( ) ; gallery Intent . set Type ( _ STR ) ; gallery Intent . set Action (  Intent .  ACTION_ GET_ CONTENT ) ; final  Intent chooser Intent =  Intent . create Chooser ( gallery Intent , _ STR ) ; chooser Intent . put Extra (  Intent .  EXTRA_ INITIAL_ INTENTS , camera Intents . to Array ( new  Parcelable [ ] { } ) ) ; return chooser Intent ; }
@  Not Null public  List <  Pair <  C ,  Collection <  Virtual File > > > create Configurations ( @  Not Null  Collection <  Virtual File > files , @  Not Null  Collection <  C > existent Facet Configurations ) { final  C configuration = create Configuration ( files ) ; if ( configuration != null ) { return  Collections . singleton List (  Pair . create ( configuration , files ) ) ; } return  Collections . empty List ( ) ; }
private static void install Security Mgr ( ) { try {  System . set Security Manager ( new  RMISecurity Manager ( ) ) ; } catch (  Exception e ) { } }
public static  Big Decimal available ( int p_ C_ Payment_ ID ) throws  SQLException { if ( p_ C_ Payment_ ID == _ NUM ) return null ; int  C_ Currency_ ID = _ NUM ; int  C_ Conversion Type_ ID = _ NUM ;  Big Decimal  Pay Amt = null ; int  C_ Charge_ ID = _ NUM ;  String sql = _ STR + _ STR + _ STR ;  Prepared Statement pstmt =  Adempiere . prepare Statement ( sql ) ; pstmt . set Int ( _ NUM , p_ C_ Payment_ ID ) ;  Result Set rs = pstmt . execute Query ( ) ; if ( rs . next ( ) ) {  C_ Currency_ ID = rs . get Int ( _ NUM ) ;  C_ Conversion Type_ ID = rs . get Int ( _ NUM ) ;  Pay Amt = rs . get Big Decimal ( _ NUM ) ;  C_ Charge_ ID = rs . get Int ( _ NUM ) ; } rs . close ( ) ; pstmt . close ( ) ; if (  Pay Amt == null ) return null ; if (  C_ Charge_ ID != _ NUM ) return  Adempiere .  ZERO ;  Big Decimal allocated Amt = get Allocated Amt ( p_ C_ Payment_ ID ,  C_ Currency_ ID ,  C_ Conversion Type_ ID ) ;  Big Decimal available =  Pay Amt . subtract ( allocated Amt ) ; return  Currency . round ( available ,  C_ Currency_ ID , null ) ; }
public static  Snmp Engine Id create Engine Id ( int port , int iana ) throws  Unknown Host Exception {  Inet Address address = null ; address =  Inet Address . get Local Host ( ) ; return create Engine Id ( address , port , iana ) ; }
public static  List <  Active Rule > import Configuration (  String configuration ,  List <  Rule > rules Repository ) {  Ruleset ruleset =  Delphi Rules Utils . build Rule Set From Xml ( configuration ) ;  List <  Active Rule > active Rules = new  Array List <  Active Rule > ( ) ; for (  Delphi Rule f Rule : ruleset . get Rules ( ) ) {  Active Rule active Rule = create Active Rule ( f Rule , rules Repository ) ; if ( active Rule != null ) { active Rules . add ( active Rule ) ; } } return active Rules ; }
public org . w3c . dom .  Element sign XML ( org . w3c . dom .  Document doc , java . lang .  String cert Alias , java . lang .  String algorithm , java . util .  List ids ) throws  XMLSignature Exception { return sign XML ( doc , cert Alias , algorithm , null , ids ) ; }
public void insert Child (  Node [ ] nodes , int index ) { for (  Node node : nodes ) { node . detach From Parent ( ) ; node . parent Node = this ; try { init Child Nodes ( node ) ; child Nodes . add ( index , node ) ; index ++ ; } catch (  Index Out Of Bounds Exception ignore ) { throw new  Lagarto DOMException ( _ STR + index ) ; } } reindex Children ( ) ; }
private static byte [ ] ntlm Hash (  String password ) throws  Exception { byte [ ] unicode Password = password . get Bytes ( _ STR ) ;  Message Digest md4 =  Message Digest . get Instance ( _ STR ) ; return md4 . digest ( unicode Password ) ; }
protected boolean add New Icon (  String name ) { if ( log . is Debug Enabled ( ) ) { log . debug ( _ STR + _icon Map . size ( ) ) ; } if ( name == null || name . length ( ) == _ NUM ) {  JOption Pane . show Message Dialog ( _parent . _palette Frame ,  Bundle . get Message ( _ STR ) ,  Bundle . get Message ( _ STR ) ,  JOption Pane .  WARNING_ MESSAGE ) ; return _ BOOL ; } else if ( _icon Map . get ( name ) != null ) {  JOption Pane . show Message Dialog ( _parent . _palette Frame ,  Bundle . get Message ( _ STR , name ) ,  Bundle . get Message ( _ STR ) ,  JOption Pane .  WARNING_ MESSAGE ) ; return _ BOOL ; }  String file Name = _ STR ;  Named Icon icon = new jmri . jmrit . catalog .  Named Icon ( file Name , file Name ) ; _icon Map . put ( name , icon ) ; return _ BOOL ; }
public static  Data convert Input Type (  String parameter Name ,  Object parameter Value ) { return convert Input Type ( parameter Name , parameter Value , null ) ; }
public void log Equals ( ) { for ( int i = _ NUM ; i <  A . length ; i ++ ) for ( int j = _ NUM ; j <  A [ i ] . length ; j ++ )  A [ i ] [ j ] =  Math . log (  A [ i ] [ j ] ) ; }
public static final  String copy String (  String str , int copies ) {  String result = _ STR ;  String power Of2 Copies = str ; int remaining = copies ; while ( remaining > _ NUM ) { if ( remaining % _ NUM != _ NUM ) { result = result + power Of2 Copies ; } remaining = remaining / _ NUM ; if ( remaining != _ NUM ) { power Of2 Copies = power Of2 Copies + power Of2 Copies ; } } return result ; }
public  Node List select Node List (  Node context Node ,  Node xpathnode ,  String str ,  Node namespace Node ) throws  Transformer Exception { if ( ! str . equals ( xpath Str ) || xpath Expression == null ) { if ( xpf == null ) { xpf =  XPath Factory . new Instance ( ) ; try { xpf . set Feature (  XMLConstants .  FEATURE_ SECURE_ PROCESSING ,  Boolean .  TRUE ) ; } catch (  XPath Factory Configuration Exception ex ) { throw new  Transformer Exception ( _ STR , ex ) ; } }  XPath xpath = xpf . new XPath ( ) ; xpath . set Namespace Context ( new  DOMNamespace Context ( namespace Node ) ) ; xpath Str = str ; try { xpath Expression = xpath . compile ( xpath Str ) ; } catch (  XPath Expression Exception ex ) { throw new  Transformer Exception ( _ STR , ex ) ; } } try { return (  Node List ) xpath Expression . evaluate ( context Node ,  XPath Constants .  NODESET ) ; } catch (  XPath Expression Exception ex ) { throw new  Transformer Exception ( _ STR , ex ) ; } }
private void generate Locator (  Distribution Locator Config config ) throws  SAXException {  Attributes Impl atts = new  Attributes Impl ( ) ; atts . add Attribute ( _ STR , _ STR ,  PORT , _ STR ,  String . value Of ( config . get Port ( ) ) ) ; handler . start Element ( _ STR ,  LOCATOR ,  LOCATOR , atts ) ; generate Entity Config ( config ) ; handler . end Element ( _ STR ,  LOCATOR ,  LOCATOR ) ; }
public  View Ref Resolver (  View Resolver < ? super  T > resolver ,  Class <  T > type , int priority ) {  Objects . require Non Null ( resolver ) ;  Objects . require Non Null ( type ) ; _resolver = resolver ; _type = type ; _priority = priority ; }
@  Override public void action Performed (  Action Event e ) { if ( e . get Source ( ) == ok ) { close Action =  ACTION_ OK ; } set Visible ( _ BOOL ) ; }
public void append XML (  Element to Element , boolean hide Default ,  Document doc ) { for (  String key : key To Type Map . key Set ( ) ) {  String value = key To Value Map . get ( key ) ;  Parameter Type type = key To Type Map . get ( key ) ;  Element param Element ; if ( type != null ) { param Element = type . get XML ( key , value , hide Default , doc ) ; } else { param Element = doc . create Element ( _ STR ) ; param Element . set Attribute ( _ STR , key ) ; param Element . set Attribute ( _ STR , value . to String ( ) ) ; } if ( param Element != null ) { to Element . append Child ( param Element ) ; } } }
public static  Map <  UUID ,  Collection <  Cluster Node > > neighbors (  Collection <  Cluster Node > top Snapshot ) {  Map <  String ,  Collection <  Cluster Node > > mac Map = new  Hash Map < > ( top Snapshot . size ( ) , _ NUM ) ; for (  Cluster Node node : top Snapshot ) {  String macs = node . attribute (  Ignite Node Attributes .  ATTR_ MACS ) ;  Collection <  Cluster Node > nodes = mac Map . get ( macs ) ; if ( nodes == null ) mac Map . put ( macs , nodes = new  Hash Set < > ( ) ) ; nodes . add ( node ) ; }  Map <  UUID ,  Collection <  Cluster Node > > neighbors = new  Hash Map < > ( top Snapshot . size ( ) , _ NUM ) ; for (  Collection <  Cluster Node > group : mac Map . values ( ) ) for (  Cluster Node node : group ) neighbors . put ( node . id ( ) , group ) ; return neighbors ; }
private boolean delete File (  String filepath ) { try { if ( filepath != null ) {  File file = new  File ( filepath ) ; if ( file . exists ( ) ) { if ( file . delete ( ) ) { logger . debug ( _ STR + file . get Path ( ) ) ; return _ BOOL ; } else { logger . warn ( _ STR + file . get Path ( ) ) ; } } else { logger . warn ( _ STR + file . get Path ( ) ) ; return _ BOOL ; } } } catch (  Exception e ) { logger . error ( e ) ; } return _ BOOL ; }
public void update League History ( ) {  Collections . sort ( team List , new  Team Comp Poll ( ) ) ;  String [ ] year Top10 = new  String [ _ NUM ] ;  Team tt ; for ( int i = _ NUM ; i < _ NUM ; ++ i ) { tt = team List . get ( i ) ; year Top10 [ i ] = tt . abbr + _ STR + tt . wins + _ STR + tt . losses + _ STR ; } league History . add ( year Top10 ) ; }
public void write String No Compression (  String str ) throws  IOException { if ( str == null ) { write Int ( _ NUM ) ; } else { write Int ( str . length ( ) ) ; for ( int i = _ NUM ; i < str . length ( ) ; i ++ ) outs . write ( ( byte ) str . char At ( i ) ) ; position += str . length ( ) ; } }
public  Part Of Speech Impl (  URL url ,  String default Part Of Speech ) throws  IOException {  Buffered Reader reader ;  String line ; part Of Speech Map = new  Hash Map ( ) ; this . default Part Of Speech = default Part Of Speech ; reader = new  Buffered Reader ( new  Input Stream Reader (  Utilities . get Input Stream ( url ) ) ) ; line = reader . read Line ( ) ; line Count ++ ; while ( line != null ) { if ( ! line . starts With ( _ STR ) ) { parse And Add ( line ) ; } line = reader . read Line ( ) ; } reader . close ( ) ; }
public static  Executor Service create Background Executor ( ) { final  Executor Service executor =  Executors . new Single Thread Executor ( new  Daemon Thread Factory (  DEFAULT_ BACKGROUND_ EXECUTOR_ NAME ) ) ;  BACKGROUND_ EXECUTORS . add ( executor ) ; return executor ; }
public static  Point normalize (  Point p , double length ) { double len =  Math . sqrt ( p . x * p . x + p . y * p . y ) ; length = length / len ; return new  Point ( p . x * length , p . y * length ) ; }
@  On Open public void on Connect ( final  Session session ) {  SESSIONS . add ( session ) ; }
private  Map <  URI ,  Storage System > build Array Map (  List <  Volume Descriptor > descriptors ,  Volume Descriptor .  Type type ) {  Map <  URI ,  Storage System > array Map = new  Hash Map <  URI ,  Storage System > ( ) ; if ( type != null ) { descriptors =  Volume Descriptor . filter By Type ( descriptors , new  Volume Descriptor .  Type [ ] { type } , new  Volume Descriptor .  Type [ ] { } ) ; } for (  Volume Descriptor desc : descriptors ) { if ( array Map . contains Key ( desc . get Device URI ( ) ) == _ BOOL ) {  Storage System array = get Data Object (  Storage System . class , desc . get Device URI ( ) , _db Client ) ; array Map . put ( desc . get Device URI ( ) , array ) ; } } return array Map ; }
private  String parse Ip From Ping (  String ping ) {  String ip = _ STR ; if ( ping . contains (  FROM_ PING ) || ping . contains (  SMALL_ FROM_ PING ) ) { int index = ping . index Of (  FROM_ PING ) ; if ( index == _ NUM ) { index = ping . index Of (  SMALL_ FROM_ PING ) ; } ip = ping . substring ( index + _ NUM ) ; if ( ip . contains (  PARENTHESE_ OPEN_ PING ) ) { int index Open = ip . index Of (  PARENTHESE_ OPEN_ PING ) ; int index Close = ip . index Of (  PARENTHESE_ CLOSE_ PING ) ; ip = ip . substring ( index Open + _ NUM , index Close ) ; } else { ip = ip . substring ( _ NUM , ip . index Of ( _ STR ) ) ; if ( ip . contains ( _ STR ) ) { index = ip . index Of ( _ STR ) ; } else { index = ip . index Of ( _ STR ) ; } ip = ip . substring ( _ NUM , index ) ; } } else { int index Open = ping . index Of (  PARENTHESE_ OPEN_ PING ) ; int index Close = ping . index Of (  PARENTHESE_ CLOSE_ PING ) ; ip = ping . substring ( index Open + _ NUM , index Close ) ; } return ip ; }
public static void globals Put All (  Template Hash Model hash Model ,  Set <  String > in Ex Keys ,  Boolean include ,  Environment env ) throws  Template Model Exception { vars Put All ( hash Model , in Ex Keys , include , new  Global Ftl Var Handler ( env ) , env ) ; }
public static  String join (  String separator , double ... elements ) { if ( elements == null || elements . length == _ NUM ) { return _ STR ; }  List <  Number > list = new  Array List <  Number > ( elements . length ) ; for (  Double elem : elements ) { list . add ( elem ) ; } return join ( separator , list ) ; }
public static void put Unsigned Byte (  Byte Buffer bb , short v , int offset ) { bb . put ( offset , ( byte ) ( v & _ NUM ) ) ; }
@  Override public  Trie optimize (  Trie orig ) {  List <  Char Sequence > cmds = orig . cmds ;  List <  Row > rows = new  Array List < > ( ) ;  List <  Row > orows = orig . rows ; int remap [ ] = new int [ orows . size ( ) ] ;  Arrays . fill ( remap , _ NUM ) ; for ( int j = orows . size ( ) - _ NUM ; j >= _ NUM ; j -- ) { if ( eat ( orows . get ( j ) , remap ) ) { remap [ j ] = _ NUM ; } }  Arrays . fill ( remap , - _ NUM ) ; rows = remove Gaps ( orig . root , orows , new  Array List <  Row > ( ) , remap ) ; return new  Trie ( orig . forward , remap [ orig . root ] , cmds , rows ) ; }
public boolean has Denied Permission ( ) { for ( int i = _ NUM ; i < m Perms . size ( ) ; i ++ ) { if ( m Perms . get ( m User Permission . get ( i ) ) ==  Package Manager .  PERMISSION_ DENIED ) return _ BOOL ; } return _ BOOL ; }
@  Override public  String to String Key ( ) {  String result ; int i ; result = _ STR ; for ( i = _ NUM ; i < get Col Count ( ) ; i ++ ) { if ( get Col Hidden ( i ) ) { continue ; } result +=  LEFT_ PARENTHESES + ( i + _ NUM ) +  RIGHT_ PARENTHESES + _ STR + remove Filter Name ( m_ Col Names [ i ] ) + _ STR ; } return result ; }
Date Time Formatter to Formatter (  Resolver Style resolver Style ,  Chronology chrono ) { return to Formatter (  Locale . get Default (  Locale .  Category .  FORMAT ) , resolver Style , chrono ) ; }
protected void wait For File To Grow (  File file ) throws  Exception { int current Wait Time = _ NUM ; while ( ! file . exists ( ) ) {  Log . i (  LOG_ TAG , _ STR ) ; current Wait Time = timeout Wait ( current Wait Time ,  WAIT_ FOR_ DOWNLOAD_ POLL_ TIME ,  MAX_ WAIT_ FOR_ DOWNLOAD_ TIME , _ STR ) ; } long original Size = file . length ( ) ; while ( file . length ( ) <= original Size ) {  Log . i (  LOG_ TAG , _ STR ) ; current Wait Time = timeout Wait ( current Wait Time ,  WAIT_ FOR_ DOWNLOAD_ POLL_ TIME ,  MAX_ WAIT_ FOR_ DOWNLOAD_ TIME , _ STR ) ; } }
@  Not Null static  String remove Common Package Prefix ( @  Not Null  String package Prefix , @  Not Null  String package Name ) {  String relative Package Name = package Name ; if ( package Name . equals ( package Prefix ) ) { relative Package Name = _ STR ; } else if ( package Name . length ( ) > package Prefix . length ( ) && package Name . starts With ( package Prefix ) && package Name . char At ( package Prefix . length ( ) ) == _ STR ) { relative Package Name = relative Package Name . substring ( package Prefix . length ( ) + _ NUM ) ; } return relative Package Name ; }
private void do Auto Shuffle Update ( ) { boolean notify = _ BOOL ; if ( m Play Pos > _ NUM ) { remove Tracks ( _ NUM , m Play Pos - _ NUM ) ; notify = _ BOOL ; } final int to Add = _ NUM - ( m Play List Len - ( m Play Pos < _ NUM ? - _ NUM : m Play Pos ) ) ; for ( int i = _ NUM ; i < to Add ; i ++ ) { int lookback = m History . size ( ) ; int idx = - _ NUM ; while ( _ BOOL ) { idx = m Shuffler . next Int ( m Auto Shuffle List . length ) ; if ( ! was Recently Used ( idx , lookback ) ) { break ; } lookback /= _ NUM ; } m History . add ( idx ) ; if ( m History . size ( ) >  MAX_ HISTORY_ SIZE ) { m History . remove ( _ NUM ) ; } ensure Play List Capacity ( m Play List Len + _ NUM ) ; m Play List [ m Play List Len ++ ] = m Auto Shuffle List [ idx ] ; notify = _ BOOL ; } if ( notify ) { notify Change (  QUEUE_ CHANGED ) ; } }
public void test Reverse Step By Two With Closure ( ) { final  List call Log = new  Array List ( ) ; final  Closure closure = new  Recording Closure ( call Log ) ; final  Range range = create Range ( _ NUM , _ NUM ) ; range . step ( _ NUM , closure ) ; assert Equals ( _ STR , _ NUM , call Log . size ( ) ) ; final  Iterator iter = call Log . iterator ( ) ; for ( int i = _ NUM ; i >= _ NUM ; i -= _ NUM ) { assert Equals ( _ STR , create Value ( i ) , iter . next ( ) ) ; } }
private static  Big Decimal normalize Decimal Value (  Big Decimal big Decimal , int allowed Precision ) { if ( big Decimal . precision ( ) > allowed Precision ) { return null ; } return big Decimal ; }
protected static  String serialize DOMSource (  DOMSource dom Source ) { try {  String Writer writer = new  String Writer ( ) ;  Stream Result result = new  Stream Result ( writer ) ;  Transformer Factory tf =  Transformer Factory . new Instance ( ) ;  Transformer transformer = tf . new Transformer ( ) ; transformer . set Output Property (  Output Keys .  ENCODING ,  DEFAULT_ ENCODING ) ; transformer . set Output Property (  Output Keys .  INDENT ,  DEFAULT_ INDENT ) ; transformer . transform ( dom Source , result ) ; writer . flush ( ) ; return writer . to String ( ) ; } catch (  Throwable e ) { log . log (  Level .  SEVERE , _ STR , e ) ; } return null ; }
public static void alert ( final  GTGEvent event , final boolean is On , final  Object obj ) { int i ; synchronized ( event Listeners ) { if ( event . is On == is On && obj == null ) return ; event . is On = is On ; event . obj = obj ; local Event Listeners . clear ( ) ; local Event Listeners . add All ( event Listeners . key Set ( ) ) ; i = local Event Listeners . size ( ) - _ NUM ; } for ( ; i >= _ NUM ; i -- ) {  GTGEvent Listener el ; el = local Event Listeners . get ( i ) ; if ( event . is On ) { if ( el . on GTGEvent ( event ) ) { alert ( event , _ BOOL ) ; break ; } } else el . off GTGEvent ( event ) ; } local Event Listeners . clear ( ) ; }
public static void thread Dump ( ) {  LOG . error ( _ STR ) ; final  Thread MXBean threads =  Management Factory . get Thread MXBean ( ) ; long [ ] thread Ids = threads . get All Thread Ids ( ) ;  Print Writer print Writer = null ; try { print Writer = new  Print Writer ( new  File Writer (  THREAD_ DUMP_ FILE_ PATH , _ BOOL ) ) ; print Writer . println ( _ STR + new  Date ( ) ) ; for ( long thread Id : thread Ids ) {  Thread Info thread Info = threads . get Thread Info ( thread Id , _ NUM ) ; print Writer . println ( _ STR + thread Info . get Thread Name ( ) + _ STR + thread Info . get Blocked Time ( ) + _ STR + thread Info . get Blocked Count ( ) + _ STR + thread Info . get Lock Name ( ) + _ STR + thread Info . get Waited Count ( ) + _ STR + thread Info . get Waited Time ( ) + _ STR + thread Info . is Suspended ( ) ) ;  Stack Trace Element [ ] stack Trace = thread Info . get Stack Trace ( ) ; for (  Stack Trace Element element : stack Trace ) { print Writer . println ( element ) ; } } } catch (  IOException ioe ) { ioe . print Stack Trace ( ) ; } finally { if ( print Writer != null ) { try { print Writer . flush ( ) ; print Writer . close ( ) ; } catch (  Exception e2 ) { } } } }
public  Revision next ( ) { try {  Revision revision = new  Revision ( result . get Int ( _ NUM ) ) ; this . primary Key = result . get Int ( _ NUM ) ; revision . set Primary Key ( this . primary Key ) ; revision . set Revision ID ( result . get Int ( _ NUM ) ) ; revision . set Article ID ( result . get Int ( _ NUM ) ) ; revision . set Time Stamp ( new  Timestamp ( result . get Long ( _ NUM ) ) ) ; revision . set Full Revision ID ( result . get Int ( _ NUM ) ) ; return revision ; } catch (  Exception e ) { e . print Stack Trace ( ) ; throw new  Runtime Exception ( e ) ; } }
private void add Line (  Grid Field field ,  WEditor editor , boolean mandatory ) { log . fine ( _ STR + field ) ;  Label label = editor . get Label ( ) ; editor . set Read Write ( _ BOOL ) ; editor . set Mandatory ( mandatory ) ; field . add Property Change Listener ( editor ) ; if ( m_new Row ) { m_row = new  Row ( ) ; m_row . set Style ( _ STR ) ; m_rows . append Child ( m_row ) ; }  Div div = new  Div ( ) ; div . set Style ( _ STR ) ; div . append Child ( label ) ; m_row . append Child ( div ) ; m_row . append Child ( editor . get Component ( ) ) ; editor . dynamic Display ( ) ; m_new Row = ! m_new Row ; }
public static void close EL (  Output Stream os ) { try { if ( os != null ) os . close ( ) ; } catch (  Throwable e ) { } }
public void remove Search Listener (  Search Listener l ) { m_ Search Listeners . remove ( l ) ; }
public boolean submit No Wake (  Runnable task ,  Class Loader loader ) { boolean is Priority = _ BOOL ; boolean is Queue = _ BOOL ; boolean is Wake = _ BOOL ; return schedule Impl ( task , loader ,  MAX_ EXPIRE , is Priority , is Queue , is Wake ) ; }
public void edit (  File file ) throws  IOException { check AWTPermission ( ) ; check Exec ( ) ; check Action Support (  Action .  EDIT ) ; file . can Write ( ) ; check File Validation ( file ) ; peer . edit ( file ) ; }
private  String parse Ip From Ping (  String ping ) {  String ip = _ STR ; if ( ping . contains (  FROM_ PING ) || ping . contains (  SMALL_ FROM_ PING ) ) { int index = ping . index Of (  FROM_ PING ) ; if ( index == _ NUM ) { index = ping . index Of (  SMALL_ FROM_ PING ) ; } ip = ping . substring ( index + _ NUM ) ; if ( ip . contains (  PARENTHESE_ OPEN_ PING ) ) { int index Open = ip . index Of (  PARENTHESE_ OPEN_ PING ) ; int index Close = ip . index Of (  PARENTHESE_ CLOSE_ PING ) ; ip = ip . substring ( index Open + _ NUM , index Close ) ; } else { ip = ip . substring ( _ NUM , ip . index Of ( _ STR ) ) ; if ( ip . contains ( _ STR ) ) { index = ip . index Of ( _ STR ) ; } else { index = ip . index Of ( _ STR ) ; } ip = ip . substring ( _ NUM , index ) ; } } else { int index Open = ping . index Of (  PARENTHESE_ OPEN_ PING ) ; int index Close = ping . index Of (  PARENTHESE_ CLOSE_ PING ) ; ip = ping . substring ( index Open + _ NUM , index Close ) ; } return ip ; }
@  Override public void toggle Selection (  Photo photo ) { if ( selected Photos . contains ( photo ) ) { selected Photos . remove ( photo ) ; } else { selected Photos . add ( photo ) ; } }
protected void post Response ( ) { }
private  String read Byte Array ( ) { final byte [ ] stream_ = this . stream ; final  String Buffer buf = new  String Buffer ( ) ; int count = _ NUM ; char w = ( char ) _ NUM ; for ( int to = stream_ . length ; ( loc < to ) && ( stream_ [ loc ] != _ STR ) ; ) { final char c = ( char ) stream_ [ loc ] ; byte b = ( byte ) _ NUM ; if ( c >= _ STR && c <= _ STR ) { b = ( byte ) ( c - _ STR ) ; } else if ( c >= _ STR && c <= _ STR ) { b = ( byte ) ( _ NUM + ( c - _ STR ) ) ; } else if ( c >= _ STR && c <= _ STR ) { b = ( byte ) ( _ NUM + ( c - _ STR ) ) ; } else { loc ++ ; continue ; } final int offset = _ NUM - ( count % _ NUM ) ; w |= ( _ NUM & b ) << ( offset << _ NUM ) ; if ( offset == _ NUM ) { buf . append ( w ) ; w = ( char ) _ NUM ; } ++ count ; ++ loc ; } ++ loc ; return buf . to String ( ) ; }
public static boolean check File Name (  String name ) { if ( name . contains ( _ STR ) || name . contains ( _ STR ) || name . contains ( _ STR ) || name . contains ( _ STR ) || name . contains ( _ STR ) || name . contains ( _ STR ) || name . contains ( _ STR ) || name . contains ( _ STR ) || name . contains ( _ STR ) || name . contains ( _ STR ) ) { return _ BOOL ; } return _ BOOL ; }
protected  Issue Matcher add Property Matcher (  Issue Property Matcher property Matcher ) { issue Matcher . add Property Matcher (  Objects . require Non Null ( property Matcher ) ) ; return issue Matcher ; }
public static <  T >  Key <  T > of (  Class <  T > type ,  Class < ? extends  Annotation > ann Type ) {  Objects . require Non Null ( type ) ;  Objects . require Non Null ( ann Type ) ; return new  Key < > ( type , new  Class [ ] { ann Type } ) ; }
private static int [ ]  Windows Reg Create Key Ex1 ( int h Key , byte [ ] sub Key ) { int [ ] result =  Windows Reg Create Key Ex ( h Key , sub Key ) ; if ( result [  ERROR_ CODE ] ==  ERROR_ SUCCESS ) { return result ; } else { long sleep Time =  INIT_ SLEEP_ TIME ; for ( int i = _ NUM ; i <  MAX_ ATTEMPTS ; i ++ ) { try {  Thread . sleep ( sleep Time ) ; } catch (  Interrupted Exception e ) { return result ; } sleep Time *= _ NUM ; result =  Windows Reg Create Key Ex ( h Key , sub Key ) ; if ( result [  ERROR_ CODE ] ==  ERROR_ SUCCESS ) { return result ; } } } return result ; }
public void remove Property Change Listener (  Scene Property Change Listener listener ) { if ( listener != null ) { logger . log (  Level .  FINE , _ STR , listener ) ; listeners . remove ( listener ) ; } }
@  Override public int following ( int offset ) {  Character Iterator text = get Text ( ) ; check Offset ( offset , text ) ; text . set Index ( offset ) ; if ( offset == text . get Begin Index ( ) ) { cached Last Known Break = handle Next ( ) ; return cached Last Known Break ; } int result = cached Last Known Break ; if ( result >= offset || result <=  Break Iterator .  DONE ) { result = handle Previous ( ) ; } else { text . set Index ( result ) ; } while ( result !=  Break Iterator .  DONE && result <= offset ) { result = handle Next ( ) ; } cached Last Known Break = result ; return result ; }
public static void draw Image Clip (  Graphics g ,  Buffered Image image ,  Image Observer observer ) {  Rectangle clip = g . get Clip Bounds ( ) ; if ( clip != null ) { int w = image . get Width ( ) ; int h = image . get Height ( ) ; int x =  Math . max ( _ NUM ,  Math . min ( clip . x , w ) ) ; int y =  Math . max ( _ NUM ,  Math . min ( clip . y , h ) ) ; w =  Math . min ( clip . width , w - x ) ; h =  Math . min ( clip . height , h - y ) ; if ( w > _ NUM && h > _ NUM ) { g . draw Image ( image . get Subimage ( x , y , w , h ) , clip . x , clip . y , observer ) ; } } else { g . draw Image ( image , _ NUM , _ NUM , observer ) ; } }
public boolean starts With (  Name n ) { if ( n instanceof  Composite Name ) { return ( impl . starts With ( n . size ( ) , n . get All ( ) ) ) ; } else { return _ BOOL ; } }
public  Null Info Registry add (  Null Info Registry other ) { if ( ( other . tag Bits &  NULL_ FLAG_ MASK ) == _ NUM ) { return this ; } this . tag Bits |=  NULL_ FLAG_ MASK ; this . null Bit1 |= other . null Bit1 ; this . null Bit2 |= other . null Bit2 ; this . null Bit3 |= other . null Bit3 ; this . null Bit4 |= other . null Bit4 ; if ( other . extra != null ) { if ( this . extra == null ) { this . extra = new long [ extra Length ] [ ] ; for ( int i = _ NUM , length = other . extra [ _ NUM ] . length ; i < extra Length ; i ++ ) {  System . arraycopy ( other . extra [ i ] , _ NUM , ( this . extra [ i ] = new long [ length ] ) , _ NUM , length ) ; } } else { int length = this . extra [ _ NUM ] . length , other Length = other . extra [ _ NUM ] . length ; if ( other Length > length ) { for ( int i = _ NUM ; i < extra Length ; i ++ ) {  System . arraycopy ( this . extra [ i ] , _ NUM , ( this . extra [ i ] = new long [ other Length ] ) , _ NUM , length ) ;  System . arraycopy ( other . extra [ i ] , length , this . extra [ i ] , length , other Length - length ) ; } } else if ( other Length < length ) { length = other Length ; } for ( int i = _ NUM ; i < extra Length ; i ++ ) { for ( int j = _ NUM ; j < length ; j ++ ) { this . extra [ i ] [ j ] |= other . extra [ i ] [ j ] ; } } } } return this ; }
public void test Invoke Any6 ( ) throws  Throwable {  Executor Service e = new  Fork Join Pool ( _ NUM ) ;  Pool Cleaner cleaner = null ; try { cleaner = cleaner ( e ) ;  List <  Callable <  String > > l = new  Array List <  Callable <  String > > ( ) ; l . add ( new  String Task ( ) ) ; l . add ( new  String Task ( ) ) ;  String result = e . invoke Any ( l ) ; assert Same (  TEST_ STRING , result ) ; } finally { if ( cleaner != null ) { cleaner . close ( ) ; } } }
public  Config Xml Provider (  File config File ) throws  Xml Parsing Exception ,  File Not Found Exception { if ( ! config File . is File ( ) ) { throw new  File Not Found Exception (  String . format ( _ STR , config File . get Absolute Path ( ) ) ) ; } this . config =  Xml Parser . parse ( config File , new  String [ ] {  CONFIG_ XSD } ,  CONFIG_ PACKAGE ,  Config Type . class ) ; }
public byte [ ] to ASN1 ( ) { try { byte [ ] priv Key Bytes = get Priv Key Bytes ( ) ;  Byte Array Output Stream baos = new  Byte Array Output Stream ( _ NUM ) ;  DERSequence Generator seq = new  DERSequence Generator ( baos ) ; seq . add Object ( new  ASN1 Integer ( _ NUM ) ) ; seq . add Object ( new  DEROctet String ( priv Key Bytes ) ) ; seq . add Object ( new  DERTagged Object ( _ NUM ,  CURVE_ PARAMS . to ASN1 Primitive ( ) ) ) ; seq . add Object ( new  DERTagged Object ( _ NUM , new  DERBit String ( get Pub Key ( ) ) ) ) ; seq . close ( ) ; return baos . to Byte Array ( ) ; } catch (  IOException e ) { throw new  Runtime Exception ( e ) ; } }
public void start (  Calendar start Time ,  Calendar end Time ) { if ( start Time == null || end Time == null || start Time . after ( end Time ) ) { throw new  Illegal Argument Exception ( _ STR ) ; } m Start Time = start Time ; start ( end Time ) ; }
JMenu create Insert Menu ( ) {  JMenu insert Menu = new  JMenu ( _ STR ) ; insert Menu . add ( action Manager . get New Neuron Action ( ) ) ; insert Menu . add ( action Manager . get New Activity Generator Action ( ) ) ; insert Menu . add Separator ( ) ; insert Menu . add ( new  Add Neurons Action ( this ) ) ; insert Menu . add Separator ( ) ; insert Menu . add ( action Manager . get New Group Menu ( ) ) ; insert Menu . add ( action Manager . get New Network Menu ( ) ) ; insert Menu . add Separator ( ) ; insert Menu . add ( action Manager . get Test Input Action ( ) ) ; insert Menu . add ( action Manager . get Show Weight Matrix Action ( ) ) ; return insert Menu ; }
public  Connector State current State ( int ... partitions ) {  Connector State current State = couchbase Reader . current State ( ) ; if ( partitions . length == _ NUM ) { return current State ; }  Connector State state = new  Connector State ( ) ; for ( int partition : partitions ) { state . put ( current State . get ( ( short ) partition ) ) ; } return state ; }
private boolean validate Old Product (  MProduct product ) { if ( ! product . is BOM ( ) ) return _ BOOL ; if ( m_products . contains ( product ) ) { log . warning ( m_product . get Name ( ) + _ STR + product . get Name ( ) ) ; return _ BOOL ; } m_products . add ( product ) ; log . fine ( product . get Name ( ) ) ;  MProduct BOM [ ] products BOMs =  MProduct BOM . get BOMLines ( product ) ; for ( int i = _ NUM ; i < products BOMs . length ; i ++ ) {  MProduct BOM products BOM = products BOMs [ i ] ;  MProduct pp = new  MProduct ( get Ctx ( ) , products BOM . get M_ Product BOM_ ID ( ) , get_ Trx Name ( ) ) ; if ( ! pp . is BOM ( ) ) log . finer ( pp . get Name ( ) ) ; else if ( ! validate Old Product ( pp ) ) return _ BOOL ; } return _ BOOL ; }
public static  String create Digest Hash Value (  String hash Type , boolean is Signed ) {  String Builder sb = new  String Builder ( hash Type ) ; sb . append ( is Signed ) ; return sb . to String ( ) ; }
@  Suppress Warnings ( { _ STR , _ STR , _ STR } ) public  Object parse Text (  String text ) { if ( text == null || text . length ( ) == _ NUM ) { throw new  Illegal Argument Exception ( _ STR ) ; } return parse ( new  Line Column Reader ( new  String Reader ( text ) ) ) ; }
protected <  T >  Database make Simple Database (  String filename , int expected Size ) { return make Simple Database ( filename , expected Size , new  List Parameterization ( ) , null ) ; }
public void action Performed (  Action Event e ) {  String m_value = m_text . get Text ( ) ; log . config ( m_value ) ;  String field Name = null ; if ( m_field != null ) field Name = m_field . get Header ( ) ; else field Name =  Msg . get Element (  Env . get Ctx ( ) , m_column Name ) ;  JFile Chooser chooser = new  JFile Chooser ( m_value ) ; chooser . set Multi Selection Enabled ( _ BOOL ) ; chooser . set File Selection Mode ( m_selection Mode ) ; chooser . set Dialog Title ( field Name ) ; chooser . set Dialog Type ( m_dialog Type ) ; int return Val = - _ NUM ; if ( m_dialog Type ==  JFile Chooser .  SAVE_ DIALOG ) return Val = chooser . show Save Dialog ( this ) ; else if ( m_dialog Type ==  JFile Chooser .  OPEN_ DIALOG ) return Val = chooser . show Open Dialog ( this ) ; else return Val = chooser . show Dialog ( this , field Name ) ; if ( return Val !=  JFile Chooser .  APPROVE_ OPTION ) return ;  File selected File = chooser . get Selected File ( ) ; m_text . set Text ( selected File . get Absolute Path ( ) ) ; try { fire Vetoable Change ( m_column Name , m_old Text , m_text . get Text ( ) ) ; } catch (  Property Veto Exception pve ) { } }
public void dispose ( ) { log Debug ( _ STR ) ; m Setup Done = _ BOOL ; if ( m Service Conn != null ) { log Debug ( _ STR ) ; if ( m Context != null && m Service != null ) m Context . unbind Service ( m Service Conn ) ; } m Disposed = _ BOOL ; m Context = null ; m Service Conn = null ; m Service = null ; m Purchase Listener = null ; }
public  String next Token ( ) {  String result = null ; synchronized ( this ) { if ( is Empty ( ) ) { return null ; } else { if ( is Eating Blocks Of Delimiters ) { trim Starting Delimiters ( ) ; } int nearest Delimeter = - _ NUM ; for ( int i = _ NUM ; i < delimiters . length ( ) ; i ++ ) { int delimiter = source . index Of ( delimiters . char At ( i ) , current Index ) ; if ( nearest Delimeter == - _ NUM || delimiter != - _ NUM && delimiter < nearest Delimeter ) { nearest Delimeter = delimiter ; } } if ( nearest Delimeter == - _ NUM ) { result = source . substring ( current Index ) ; current Index = source . length ( ) ; } else { result = source . substring ( current Index , nearest Delimeter ) ; current Index = nearest Delimeter + _ NUM ; if ( is Eating Blocks Of Delimiters ) { trim Starting Delimiters ( ) ; } } } } return result ; }
private boolean contains Rep Set UID (  List <  Replication Set UID > rset Uids ,  Replication Set UID rep Set UID ) { for (  Replication Set UID rset Uid : rset Uids ) { if ( rset Uid . get Id ( ) == rep Set UID . get Id ( ) ) { return _ BOOL ; } } return _ BOOL ; }
private void build Network ( final  Network network , int [ ] nodes Per Layer ,  Point2 D initial Position , final  Neuron input Neuron Template ) { set Label ( _ STR ) ;  List <  Neuron > input Layer Neurons = new  Array List <  Neuron > ( ) ; for ( int i = _ NUM ; i < nodes Per Layer [ _ NUM ] ; i ++ ) { input Layer Neurons . add ( new  Neuron ( network , input Neuron Template ) ) ; }  Neuron Group input Layer = new  Neuron Group ( network , input Layer Neurons ) ; input Layer . set Clamped ( _ BOOL ) ; add Neuron Group ( input Layer ) ; input Layer . set Layout Based On Size ( initial Position ) ;  Synapse synapse =  Synapse . get Template Synapse ( new  Static Synapse Rule ( ) ) ; synapse . set Lower Bound ( - _ NUM ) ; synapse . set Upper Bound ( _ NUM ) ;  Neuron Group last Layer = input Layer ; for ( int i = _ NUM ; i < nodes Per Layer . length ; i ++ ) {  List <  Neuron > hidden Layer Neurons = new  Array List <  Neuron > ( ) ; for ( int j = _ NUM ; j < nodes Per Layer [ i ] ; j ++ ) {  Sigmoidal Rule rule = new  Sigmoidal Rule ( ) ;  Neuron neuron = new  Neuron ( network , rule ) ; rule . set Lower Bound ( _ NUM ) ; neuron . set Update Priority ( i ) ; hidden Layer Neurons . add ( neuron ) ; }  Neuron Group hidden Layer = new  Neuron Group ( network , hidden Layer Neurons ) ; hidden Layer . set Layout Based On Size ( ) ; add Neuron Group ( hidden Layer ) ;  Network Layout Manager . offset Neuron Group ( last Layer , hidden Layer ,  Direction .  NORTH , between Layer Interval ) ;  All To All connection = new  All To All ( ) ;  Synapse Group lh = connect Neuron Groups ( last Layer , hidden Layer , connection ) ; lh . randomize Connection Weights ( ) ; last Layer = hidden Layer ; } }
static int compare ( char [ ] str1 , char [ ] str2 , int len1 , int len2 ) { int n =  Math . min ( len1 , len2 ) ; int i = _ NUM ; while ( n -- != _ NUM ) { char c1 = str1 [ i ] ; char c2 = str2 [ i ++ ] ; if ( c1 != c2 ) { return c1 - c2 ; } } return len1 - len2 ; }
public static  String ltrim (  String s ) { if ( s == null ) { return null ; } int index = _ NUM ; int len = s . length ( ) ; while ( index < len &&  Character . is Whitespace ( s . char At ( index ) ) ) { index ++ ; } return ( index >= len ) ? _ STR : s . substring ( index ) ; }
private  Value Wrapper (  Object value ) { this . value = value instanceof  Serializable ? (  Serializable ) value : null ; this . type = value != null ? value . get Class ( ) : null ; this . string Representation =  String . value Of ( value ) ; this . identity Hash Code =  System . identity Hash Code ( value ) ; }
public void create Accrual Based Journal Entries And Reversals For Loan ( final  Office office , final  String currency Code , final  Integer account Type To Be Debited , final  Integer account Type To Be Credited , final  Long loan Product Id , final  Long payment Type Id , final  Long loan Id , final  String transaction Id , final  Date transaction Date , final  Big Decimal amount , final  Boolean is Reversal ) { int account Type To Debit Id = account Type To Be Debited ; int account Type To Credit Id = account Type To Be Credited ; if ( is Reversal ) { account Type To Debit Id = account Type To Be Credited ; account Type To Credit Id = account Type To Be Debited ; } create Journal Entries For Loan ( office , currency Code , account Type To Debit Id , account Type To Credit Id , loan Product Id , payment Type Id , loan Id , transaction Id , transaction Date , amount ) ; }
public int read (  Byte Buffer dst , int dst Start , int dst Length ) throws  IOException { final int remaining = ( int )  Math . min ( this . length - this . position ,  Integer .  MAX_ VALUE ) ; final int read =  Math . min ( remaining , dst Length ) ; final int buffer Position = check Offset ( position , read ) ; final long src Address =  Platform Dependent . direct Buffer Address ( last Mapped ) + buffer Position ; if ( dst . is Direct ( ) ) { final long dst Address =  Platform Dependent . direct Buffer Address ( dst ) + dst Start ;  Platform Dependent . copy Memory ( src Address , dst Address , read ) ; } else { final byte [ ] dst Array = dst . array ( ) ;  Platform Dependent . copy Memory ( src Address , dst Array , dst Start , read ) ; } position += read ; return read ; }
public static  Calendar previous (  Calendar self ) {  Calendar result = (  Calendar ) self . clone ( ) ; result . add (  Calendar .  DAY_ OF_ YEAR , - _ NUM ) ; return result ; }
public double pdf ( int k ) { if ( k < _ NUM ) throw new  Illegal Argument Exception ( ) ; int r = this . n - k ; return  Math . exp ( this . log_n -  Arithmetic . log Factorial ( k ) -  Arithmetic . log Factorial ( r ) + this . log_p * k + this . log_q * r ) ; }
public static void append Unpadded Integer (  String Buffer buf , int value ) { if ( value < _ NUM ) { buf . append ( _ STR ) ; if ( value !=  Integer .  MIN_ VALUE ) { value = - value ; } else { buf . append ( _ STR + - ( long )  Integer .  MIN_ VALUE ) ; return ; } } if ( value < _ NUM ) { buf . append ( ( char ) ( value + _ STR ) ) ; } else if ( value < _ NUM ) { int d = ( ( value + _ NUM ) * _ NUM ) > > _ NUM ; buf . append ( ( char ) ( d + _ STR ) ) ; buf . append ( ( char ) ( value - ( d << _ NUM ) - ( d << _ NUM ) + _ STR ) ) ; } else { buf . append (  Integer . to String ( value ) ) ; } }
private void draw Text Elements (  Canvas canvas , float text Size ,  Typeface typeface ,  Color State List text Color ,  String [ ] texts , float [ ] text X , float [ ] text Y ,  Paint paint , int alpha , boolean show Activated , int activated Degrees , boolean activated Only ) { paint . set Text Size ( text Size ) ; paint . set Typeface ( typeface ) ; final float activated Index = activated Degrees / ( _ NUM /  NUM_ POSITIONS ) ; final int activated Floor = ( int ) activated Index ; final int activated Ceil = ( ( int )  Math . ceil ( activated Index ) ) %  NUM_ POSITIONS ; for ( int i = _ NUM ; i < _ NUM ; i ++ ) { final boolean activated = ( activated Floor == i || activated Ceil == i ) ; if ( activated Only && ! activated ) { continue ; } final int state Mask =  SUtils .  STATE_ ENABLED | ( show Activated && activated ?  SUtils .  STATE_ ACTIVATED : _ NUM ) ; final int color = text Color . get Color For State (  SUtils . resolve State Set ( state Mask ) , _ NUM ) ; paint . set Color ( color ) ; paint . set Alpha ( get Multiplied Alpha ( color , alpha ) ) ; canvas . draw Text ( texts [ i ] , text X [ i ] , text Y [ i ] , paint ) ; } }
public void test Find Spring Active Directory ( ) {  Ldap Proxy proxy = get Ldap AD ( ) ;  List result = null ; try { result = proxy . find ( get Ldap Search VO ( _ STR ,  Ldap Constants .  NO_ SEARCH_ LIMIT , null , null , null ,  Ldap Scope Constants .  SCOPE_ SUBTREE ) ) ; } catch (  Exception e ) { } assert Not Null ( result ) ; assert Equals ( _ NUM , result . size ( ) ) ; }
@  Override public void handle Mouse ( int transition State , int button , int x , int y , int delta ) { input Buffer . add ( new  Global Mouse Event ( this , transition State , button , buttons ^= button , x , y , delta ) ) ; }
public static boolean move Up (  Alignment alignment , int first Row , int last Row ) { last Row =  Math . min ( last Row , alignment . get Number Of Sequences ( ) ) ; if ( first Row <= _ NUM || first Row > last Row ) return _ BOOL ; else {  Integer [ ] array = new  Integer [ alignment . get Number Of Sequences ( ) ] ; for ( int i = _ NUM ; i < alignment . get Number Of Sequences ( ) ; i ++ ) array [ i ] = alignment . get Order ( i ) ; int replaced = array [ first Row - _ NUM ] ;  System . arraycopy ( array , first Row , array , first Row - _ NUM , last Row + _ NUM - first Row ) ; array [ last Row ] = replaced ; alignment . set Order (  Arrays . as List ( array ) ) ; return _ BOOL ; } }
public static  String add Asterisk (  String s , int index ) { if ( s != null ) { index =  Math . min ( index , s . length ( ) ) ; s = s . substring ( _ NUM , index ) + _ STR + s . substring ( index ) ; } return s ; }
protected  Connection State TLS (  SSLSession Impl session ) { try {  Cipher Suite cipher Suite = session . cipher Suite ; hash_size = cipher Suite . get MACLength ( ) ; boolean is_exportabe = cipher Suite . is Exportable ( ) ; int key_size = ( is_exportabe ) ? cipher Suite . key Material : cipher Suite . expanded Key Material ; int iv_size = cipher Suite . iv Size ; block_size = cipher Suite . get Block Size ( ) ;  String alg Name = cipher Suite . get Bulk Encryption Algorithm ( ) ;  String mac Name = cipher Suite . get Hmac Name ( ) ; if ( logger != null ) { logger . println ( _ STR ) ; logger . println ( _ STR + cipher Suite . get Name ( ) ) ; logger . println ( _ STR + alg Name ) ; logger . println ( _ STR + mac Name ) ; logger . println ( _ STR + hash_size ) ; logger . println ( _ STR + block_size ) ; logger . println ( _ STR + iv_size ) ; logger . println ( _ STR + key_size ) ; } byte [ ] client Random = session . client Random ; byte [ ] server Random = session . server Random ; byte [ ] key_block = new byte [ _ NUM * hash_size + _ NUM * key_size + _ NUM * iv_size ] ; byte [ ] seed = new byte [ client Random . length + server Random . length ] ;  System . arraycopy ( server Random , _ NUM , seed , _ NUM , server Random . length ) ;  System . arraycopy ( client Random , _ NUM , seed , server Random . length , client Random . length ) ;  PRF . compute PRF ( key_block , session . master_secret ,  KEY_ EXPANSION_ LABEL , seed ) ; byte [ ] client_mac_secret = new byte [ hash_size ] ; byte [ ] server_mac_secret = new byte [ hash_size ] ; byte [ ] client_key = new byte [ key_size ] ; byte [ ] server_key = new byte [ key_size ] ; boolean is_client = ! session . is Server ;  System . arraycopy ( key_block , _ NUM , client_mac_secret , _ NUM , hash_size ) ;  System . arraycopy ( key_block , hash_size , server_mac_secret , _ NUM , hash_size ) ;  System . arraycopy ( key_block , _ NUM * hash_size , client_key , _ NUM , key_size ) ;  System . arraycopy ( key_block , _ NUM * hash_size + key_size , server_key , _ NUM , key_size ) ;  Iv Parameter Spec client IV = null ;  Iv Parameter Spec server IV = null ; if ( is_exportabe ) {  System . arraycopy ( client Random , _ NUM , seed , _ NUM , client Random . length ) ;  System . arraycopy ( server Random , _ NUM , seed , client Random . length , server Random . length ) ; byte [ ] final_client_key = new byte [ cipher Suite . expanded Key Material ] ; byte [ ] final_server_key = new byte [ cipher Suite . expanded Key Material ] ;  PRF . compute PRF ( final_client_key , client_key ,  CLIENT_ WRITE_ KEY_ LABEL , seed ) ;  PRF . compute PRF ( final_server_key , server_key ,  SERVER_ WRITE_ KEY_ LABEL , seed ) ; client_key = final_client_key ; server_key = final_server_key ; if ( block_size != _ NUM ) { byte [ ] iv_block = new byte [ _ NUM * iv_size ] ;  PRF . compute PRF ( iv_block , null ,  IV_ BLOCK_ LABEL , seed ) ; client IV = new  Iv Parameter Spec ( iv_block , _ NUM , iv_size ) ; server IV = new  Iv Parameter Spec ( iv_block , iv_size , iv_size ) ; } } else if ( block_size != _ NUM ) { client IV = new  Iv Parameter Spec ( key_block , _ NUM * ( hash_size + key_size ) , iv_size ) ; server IV = new  Iv Parameter Spec ( key_block , _ NUM * ( hash_size + key_size ) + iv_size , iv_size ) ; } if ( logger != null ) { logger . println ( _ STR + is_exportabe ) ; logger . println ( _ STR ) ; logger . print ( session . master_secret ) ; logger . println ( _ STR ) ; logger . print ( client Random ) ; logger . println ( _ STR ) ; logger . print ( server Random ) ; logger . println ( _ STR ) ; logger . print ( client_mac_secret ) ; logger . println ( _ STR ) ; logger . print ( server_mac_secret ) ; logger . println ( _ STR ) ; logger . print ( client_key ) ; logger . println ( _ STR ) ; logger . print ( server_key ) ; if ( client IV == null ) { logger . println ( _ STR ) ; } else { logger . println ( _ STR ) ; logger . print ( client IV . get IV ( ) ) ; logger . println ( _ STR ) ; logger . print ( server IV . get IV ( ) ) ; } } if ( alg Name == null ) { enc Cipher = new  Null Cipher ( ) ; dec Cipher = new  Null Cipher ( ) ; } else { enc Cipher =  Cipher . get Instance ( alg Name ) ; dec Cipher =  Cipher . get Instance ( alg Name ) ; if ( is_client ) { enc Cipher . init (  Cipher .  ENCRYPT_ MODE , new  Secret Key Spec ( client_key , alg Name ) , client IV ) ; dec Cipher . init (  Cipher .  DECRYPT_ MODE , new  Secret Key Spec ( server_key , alg Name ) , server IV ) ; } else { enc Cipher . init (  Cipher .  ENCRYPT_ MODE , new  Secret Key Spec ( server_key , alg Name ) , server IV ) ; dec Cipher . init (  Cipher .  DECRYPT_ MODE , new  Secret Key Spec ( client_key , alg Name ) , client IV ) ; } } enc Mac =  Mac . get Instance ( mac Name ) ; dec Mac =  Mac . get Instance ( mac Name ) ; if ( is_client ) { enc Mac . init ( new  Secret Key Spec ( client_mac_secret , mac Name ) ) ; dec Mac . init ( new  Secret Key Spec ( server_mac_secret , mac Name ) ) ; } else { enc Mac . init ( new  Secret Key Spec ( server_mac_secret , mac Name ) ) ; dec Mac . init ( new  Secret Key Spec ( client_mac_secret , mac Name ) ) ; } } catch (  Exception e ) { e . print Stack Trace ( ) ; throw new  Alert Exception (  Alert Protocol .  INTERNAL_ ERROR , new  SSLProtocol Exception ( _ STR ) ) ; } }
public void compute Labelling (  Geometry Graph [ ] geom ) { super . compute Labelling ( geom ) ; label = new  Label (  Location .  NONE ) ; for (  Iterator it = iterator ( ) ; it . has Next ( ) ; ) {  Edge End ee = (  Edge End ) it . next ( ) ;  Edge e = ee . get Edge ( ) ;  Label e Label = e . get Label ( ) ; for ( int i = _ NUM ; i < _ NUM ; i ++ ) { int e Loc = e Label . get Location ( i ) ; if ( e Loc ==  Location .  INTERIOR || e Loc ==  Location .  BOUNDARY ) label . set Location ( i ,  Location .  INTERIOR ) ; } } }
public static long date Value From Date ( long ms ) {  Calendar cal = get Calendar ( ) ; cal . set Time In Millis ( ms ) ; return date Value From Calendar ( cal ) ; }
@  Override default  Completable Future <  Optional Long > min Long ( final  To Long Function < ? super  T > fn ) { return  Completable Future . supply Async ( null , get Exec ( ) ) ; }
protected  Account Creation Rules ( final  String username , final  String password , final  String email ) { this . username = username . trim ( ) ; this . password = password . trim ( ) ; this . email = email . trim ( ) ; }
public final static char [ ] [ ] split Type Levels Signature (  String type Signature ) { char [ ] source =  Signature . remove Capture ( type Signature . to Char Array ( ) ) ;  Char Operation . replace ( source , _ STR , _ STR ) ; char [ ] [ ] signatures = new char [ _ NUM ] [ ] ; int signatures Count = _ NUM ; int param Opening = _ NUM ; for ( int idx = _ NUM , ln = source . length ; idx < ln ; idx ++ ) { switch ( source [ idx ] ) { case _ STR : param Opening -- ; if ( param Opening == _ NUM ) { if ( signatures Count == signatures . length ) {  System . arraycopy ( signatures , _ NUM , signatures = new char [ signatures Count + _ NUM ] [ ] , _ NUM , signatures Count ) ; } } break ; case _ STR : param Opening ++ ; break ; case _ STR : if ( param Opening == _ NUM ) { if ( signatures Count == signatures . length ) {  System . arraycopy ( signatures , _ NUM , signatures = new char [ signatures Count + _ NUM ] [ ] , _ NUM , signatures Count ) ; } signatures [ signatures Count ] = new char [ idx + _ NUM ] ;  System . arraycopy ( source , _ NUM , signatures [ signatures Count ] , _ NUM , idx ) ; signatures [ signatures Count ] [ idx ] =  Signature .  C_ SEMICOLON ; signatures Count ++ ; } break ; case _ STR : source [ idx ] = _ STR ; break ; } } char [ ] [ ] type Signatures = new char [ signatures Count + _ NUM ] [ ] ; type Signatures [ _ NUM ] = source ; for ( int i = _ NUM , j = signatures Count - _ NUM ; i <= signatures Count ; i ++ , j -- ) { type Signatures [ i ] = signatures [ j ] ; } return type Signatures ; }
public void println (  Writer writer ) throws  IOException { print ( writer ) ; writer . write ( _ STR ) ; }
private void append To Buf ( char [ ] ch , int start , int end ) { if ( start == end ) { return ; } int needed Buf Len = pos + ( end - start ) ; if ( needed Buf Len > buf . length ) { char [ ] new Buf = new char [ needed Buf Len ] ;  System . arraycopy ( buf , _ NUM , new Buf , _ NUM , pos ) ; if ( buf Holder == null ) { buf Holder = buf ; } buf = new Buf ; }  System . arraycopy ( ch , start , buf , pos , end - start ) ; pos += ( end - start ) ; }
@  Override public void reset Distribution (  Instances data ) throws  Exception {  Instances insts = new  Instances ( data , data . num Instances ( ) ) ; for ( int i = _ NUM ; i < data . num Instances ( ) ; i ++ ) { if ( which Subset ( data . instance ( i ) ) > - _ NUM ) { insts . add ( data . instance ( i ) ) ; } }  Distribution new D = new  Distribution ( insts , this ) ; new D . add Inst With Unknown ( data , m_att Index ) ; m_distribution = new D ; }
@  Override protected  Node remove From Frontier ( ) {  Node result = frontier . remove ( ) ; explored . add ( result . get State ( ) ) ; frontier States . remove ( result . get State ( ) ) ; update Metrics ( frontier . size ( ) ) ; return result ; }
public static  String Builder format To (  String Builder buf , int [ ] d ,  String sep ) { if ( d == null ) { return buf . append ( _ STR ) ; } if ( d . length == _ NUM ) { return buf ; } buf . append ( d [ _ NUM ] ) ; for ( int i = _ NUM ; i < d . length ; i ++ ) { buf . append ( sep ) ; buf . append ( d [ i ] ) ; } return buf ; }
public void change Tick Font Size ( int delta ) {  Font f = get Tick Label Font ( ) ;  String f Name = f . get Font Name ( ) ;  Font new Font = new  Font ( f Name , f . get Style ( ) , ( f . get Size ( ) + delta ) ) ; set Tick Label Font ( new Font ) ; }
static boolean is Ignored File (  File file ) {  String name = file . get Name ( ) ; return name . equals ( _ STR ) || name . equals ( _ STR ) || name . equals ( _ STR ) || name . equals ( _ STR ) || name . ends With ( _ STR ) && name . length ( ) > _ NUM ; }
public  String to Simple String ( ) {  String Buffer buffer = new  String Buffer ( ) ; buffer . append ( _ STR + m Label + _ STR + m YVals . size ( ) + _ STR ) ; return buffer . to String ( ) ; }
public static <  T >  T unchecked (  Callable <  T > callable ) { try { return callable . call ( ) ; } catch (  Exception e ) { return sneaky Throw ( e ) ; } }
private void install Selector For Protocol (  Dict proxy Settings ,  Protocol Dispatch Selector ps ,  String protocol ) {  String prefix = protocol . trim ( ) ; if ( is Active ( proxy Settings . get ( prefix + _ STR ) ) ) {  String proxy Host = (  String ) proxy Settings . get ( prefix + _ STR ) ; int proxy Port = (  Integer ) proxy Settings . get ( prefix + _ STR ) ;  Fixed Proxy Selector fp = new  Fixed Proxy Selector ( proxy Host , proxy Port ) ; ps . set Selector ( protocol . to Lower Case ( ) , fp ) ;  Logger . log ( get Class ( ) ,  Log Level .  TRACE , _ STR , protocol , proxy Host , proxy Port ) ; } }
private static  List <  String > wrap (  String text , int width ) {  List <  String > lines =  Collections . singleton List ( text ) ; if ( text . length ( ) > width ) {  String [ ] chunks = text . split ( _ STR ) ; lines = new  Array List < > ( ) ;  String Builder line = new  String Builder ( ) ; for (  String chunk : chunks ) { if ( line . length ( ) + chunk . length ( ) > width ) { lines . add ( line . to String ( ) ) ; line . set Length ( _ NUM ) ; } if ( line . length ( ) != _ NUM ) { line . append ( _ STR ) ; }  String [ ] embedded Lines = chunk . split ( _ STR , - _ NUM ) ; if ( embedded Lines . length == _ NUM ) { line . append ( chunk ) ; } else { for ( int i = _ NUM ; i < embedded Lines . length ; i ++ ) { line . append ( embedded Lines [ i ] ) ; if ( i < embedded Lines . length - _ NUM ) { lines . add ( line . to String ( ) ) ; line . set Length ( _ NUM ) ; } } } } if ( line . length ( ) != _ NUM ) { lines . add ( line . to String ( ) ) ; } } return lines ; }
public static boolean is Monogamous (  Collection <  Family > families ) { final  Hash Set <  String > parents = new  Hash Set < > ( ) ; for (  Family f : families ) { if ( ! parents . add ( f . get Father ( ) ) ) { return _ BOOL ; } if ( ! parents . add ( f . get Mother ( ) ) ) { return _ BOOL ; } } return _ BOOL ; }
public static  String read File With Exceptions ( final  File file ) throws  IOException { final  Buffered Reader in = new  Buffered Reader ( new  File Reader ( file ) ) ; final  String Builder sb = new  String Builder ( ) ;  String content = _ STR ; boolean firstline = _ BOOL ; do { sb . append ( content ) ; content = in . read Line ( ) ; if ( content != null && ! firstline ) { sb . append (  String Literals .  NEWLINE ) ; } firstline = _ BOOL ; } while ( content != null ) ; in . close ( ) ; return sb . to String ( ) ; }
public static char [ ] [ ] load Image (  File file , char off Char ) throws  File Not Found Exception ,  Runtime Exception {  Array List <  String > rows =  Boolean Image Load . load Image Pad ( file , off Char ) ;  String s = rows . get ( _ NUM ) ; char [ ] [ ] img = new char [ rows . size ( ) ] [ s . length ( ) ] ; for ( int i = _ NUM ; i < rows . size ( ) ; i ++ ) { s = rows . get ( i ) ; for ( int j = _ NUM ; j < s . length ( ) ; j ++ ) { img [ i ] [ j ] = s . char At ( j ) ; } } return img ; }
public  IPsec Status check Status ( ) { log . info ( _ STR ) ;  IPsec Status status = new  IPsec Status ( ) ;  String vdc Config Version = load Vdc Config Version From ZK ( ) ; status . set Version ( vdc Config Version ) ;  String ipsec Key Updated Time = ipsec Config . get Ipsec Key Updated Time ( ) ;  String ipsec Status = ipsec Config . get Ipsec Status ( ) ; if ( ipsec Status != null && ipsec Status . equals (  STATUS_ DISABLED ) ) { status . set Status ( ipsec Status ) ; } else {  List <  String > disconnected Nodes = check IPsec Status ( ) ; if (  Collection Utils . is Empty ( disconnected Nodes ) ) { status . set Status (  STATUS_ GOOD ) ; } else { status . set Status (  STATUS_ DEGRADED ) ; status . set Disconnected Nodes ( disconnected Nodes ) ; } if ( ipsec Key Updated Time == null ) { ipsec Key Updated Time = vdc Config Version ; } status . set Updated Time ( ipsec Key Updated Time ) ; } return status ; }
void present Animations (  View parent , float offset , float offset In Pixel ) { int anim Map Size = m Animations . size ( ) ; for ( int i = _ NUM ; i < anim Map Size ; i ++ ) { int key = m Animations . key At ( i ) ;  Array List <  Animation > animations = m Animations . get ( key ) ; int anim List Size = animations . size ( ) ; for ( int j = _ NUM ; j < anim List Size ; j ++ ) {  Animation animation = animations . get ( j ) ; final  View view To Animate ; if ( key == parent . get Id ( ) || key ==  Animation .  FULL_ PAGE ) { view To Animate = parent ; } else { view To Animate = parent . find View By Id ( key ) ; } if ( animation == null || view To Animate == null ) { continue ; } animation . animate ( view To Animate , offset , offset In Pixel , - _ NUM ) ; } } }
@  Suppress Warnings ( _ STR ) @  Override protected  Object apply Updates To Managed Data (  Object updates ) { boolean made Changes = _ BOOL ;  List <  String > words = (  List <  String > ) updates ; log . info ( _ STR + words ) ; boolean ignore Case = get Ignore Case ( ) ; for (  String word : words ) { if ( ignore Case ) word = word . to Lower Case (  Locale .  ROOT ) ; if ( managed Words . add ( word ) ) { made Changes = _ BOOL ; log . info ( _ STR , word ) ; } } return made Changes ? managed Words : null ; }
public static  String random Realistic Unicode String (  Random r , int min Length , int max Length ) { final int end = next Int ( r , min Length , max Length ) ; final int block = r . next Int ( block Starts . length ) ;  String Builder sb = new  String Builder ( ) ; for ( int i = _ NUM ; i < end ; i ++ ) sb . append Code Point ( next Int ( r , block Starts [ block ] , block Ends [ block ] ) ) ; return sb . to String ( ) ; }
public  Stream Impl open Read Impl (  Path Impl path ) throws  IOException {  String path Name = path . get Path ( ) ; return open Read Impl ( path Name ) ; }
public  String register Name ( final  String name , final  Operator operator ) { if ( operator Name Map . get ( name ) != null ) {  String base Name = name ; int index = base Name . index Of ( _ STR ) ; if ( index >= _ NUM ) { base Name = base Name . substring ( _ NUM , index ) ; } int i = _ NUM ; while ( operator Name Map . get ( base Name + _ STR + i + _ STR ) != null ) { i ++ ; }  String new Name = base Name + _ STR + i + _ STR ; operator Name Map . put ( new Name , operator ) ; return new Name ; } else { operator Name Map . put ( name , operator ) ; return name ; } }
public void remove Column ( final int col Index ) { final  CSVInfo info = get Info ( ) ; if ( info . header ) { final  Array List <  String > cols = new  Array List < > (  Arrays . as List ( info . headers ) ) ; cols . remove ( col Index ) ; info . headers = cols . to Array ( new  String [ cols . size ( ) ] ) ; } info . cols -- ; for ( final  CSVRow row : rows ) { if ( ! row . is Comment Line ( ) ) { row . remove Element At ( col Index ) ; } } save Meta Data ( ) ; }
public static  Protection Set check Protection Set Exists In DB (  Db Client db Client ,  String native Guid ) throws  IOException {  List <  Protection Set > cgs =  Custom Query Utility . get Active Protection Set By Native Guid ( db Client , native Guid ) ;  Iterator <  Protection Set > cgs Itr = cgs . iterator ( ) ; if ( cgs Itr . has Next ( ) ) { return cgs Itr . next ( ) ; } return null ; }
private static boolean add File Digest (  File file ,  Message Digest digest , @  Nullable  Ignite Logger log ) { if ( ! file . is File ( ) ) {  U . error ( log , _ STR + file ) ; return _ BOOL ; }  Input Stream in = null ; try { in = new  Buffered Input Stream ( new  File Input Stream ( file ) ) ; byte [ ] buf = new byte [ _ NUM ] ; int read = in . read ( buf , _ NUM , _ NUM ) ; while ( read > - _ NUM ) { digest . update ( buf , _ NUM , read ) ; read = in . read ( buf , _ NUM , _ NUM ) ; } } catch (  IOException e ) {  U . error ( log , _ STR + file , e ) ; return _ BOOL ; } finally {  U . close Quiet ( in ) ; } return _ BOOL ; }
public final  V update And Get (  T obj ,  Unary Operator <  V > update Function ) {  V prev , next ; do { prev = get ( obj ) ; next = update Function . apply ( prev ) ; } while ( ! compare And Set ( obj , prev , next ) ) ; return next ; }
public void close ( ) throws  IOException { if ( closed ) { return ; } if ( gzipstream != null ) { gzipstream . close ( ) ; gzipstream = null ; } closed = _ BOOL ; }
@  Override synchronized public void shutdown ( ) { if ( ! is Open ( ) ) return ; open = _ BOOL ; if ( log . is Info Enabled ( ) ) log . info ( _ STR ) ; final long begin =  System . current Time Millis ( ) ; final long shutdown Timeout = this . shutdown Timeout == _ NUM ?  Long .  MAX_ VALUE : this . shutdown Timeout ; final  Time Unit unit =  Time Unit .  MILLISECONDS ; tx Write Service . shutdown ( ) ; read Service . shutdown ( ) ; write Service . shutdown ( ) ; if ( sample Service != null ) sample Service . shutdown ( ) ; try { if ( log . is Info Enabled ( ) ) log . info ( _ STR ) ; final long elapsed =  System . current Time Millis ( ) - begin ; if ( ! tx Write Service . await Termination ( shutdown Timeout - elapsed , unit ) ) { log . warn ( _ STR ) ; } } catch (  Interrupted Exception ex ) { log . warn ( _ STR , ex ) ; } try { if ( log . is Info Enabled ( ) ) log . info ( _ STR ) ; final long elapsed =  System . current Time Millis ( ) - begin ; if ( ! read Service . await Termination ( shutdown Timeout - elapsed , unit ) ) { log . warn ( _ STR ) ; } } catch (  Interrupted Exception ex ) { log . warn ( _ STR , ex ) ; } try { final long elapsed =  System . current Time Millis ( ) - begin ; final long timeout = shutdown Timeout - elapsed ; if ( log . is Info Enabled ( ) ) log . info ( _ STR + timeout + _ STR ) ; if ( ! write Service . await Termination ( timeout , unit ) ) { log . warn ( _ STR ) ; } } catch (  Interrupted Exception ex ) { log . warn ( _ STR , ex ) ; } final long elapsed =  System . current Time Millis ( ) - begin ; if ( log . is Info Enabled ( ) ) log . info ( _ STR + elapsed + _ STR ) ; }
public static  Object invoke (  Invocation State invocation State ,  Class < ? > target Class ,  Object o ,  Object functional Object ,  Class < ? > invoker ,  String method , boolean [ ] primitives ,  Object [ ] args ) throws  Throwable { if ( primitives . length != args . length ) throw new  Lt Bug ( _ STR ) ;  List <  Method > method List = new  Array List < > ( ) ;  Queue <  Class < ? > > interfaces = new  Array Deque < > ( ) ;  Class < ? > c = o == null ? target Class : o . get Class ( ) ; while ( c != null ) {  Collections . add All ( interfaces , c . get Interfaces ( ) ) ; fill Method Candidates ( c , invoker , method , args , method List , o == null ) ; c = c . get Superclass ( ) ; } c = o == null ? target Class : o . get Class ( ) ;  Collections . add All ( interfaces , c . get Interfaces ( ) ) ; while ( ! interfaces . is Empty ( ) ) {  Class < ? > i = interfaces . remove ( ) ; fill Method Candidates ( i , invoker , method , args , method List , o == null ) ;  Collections . add All ( interfaces , i . get Interfaces ( ) ) ; } if ( method List . is Empty ( ) ) { if ( c . is Array ( ) ) { if ( method . equals ( _ STR ) && args . length >= _ NUM && args [ _ NUM ] instanceof  Integer ) {  Object res =  Array . get ( o , (  Integer ) args [ _ NUM ] ) ; if ( args . length == _ NUM ) return res ; boolean [ ] bs = new boolean [ primitives . length - _ NUM ] ;  Object [ ] as = new  Object [ args . length - _ NUM ] ; for ( int i = _ NUM ; i < args . length ; ++ i ) { bs [ i - _ NUM ] = primitives [ i ] ; as [ i - _ NUM ] = args [ i ] ; } return invoke ( invocation State , target Class , res , null , invoker , _ STR , bs , as ) ; } else if ( method . equals ( _ STR ) && args . length >= _ NUM && args [ _ NUM ] instanceof  Integer ) { if ( args . length == _ NUM ) {  Array . set ( o , (  Integer ) args [ _ NUM ] , args [ _ NUM ] ) ; return args [ _ NUM ] ; } else {  Object elem =  Array . get ( o , (  Integer ) args [ _ NUM ] ) ; boolean [ ] bs = new boolean [ primitives . length - _ NUM ] ;  Object [ ] as = new  Object [ args . length - _ NUM ] ; for ( int i = _ NUM ; i < args . length ; ++ i ) { bs [ i - _ NUM ] = primitives [ i ] ; as [ i - _ NUM ] = args [ i ] ; } return invoke ( invocation State , target Class , elem , null , invoker , _ STR , bs , as ) ; } } } else { if ( args . length == _ NUM && is Box Type ( c ) && is Box Type ( args [ _ NUM ] . get Class ( ) ) ) { return invoke Primitive ( o , method , args [ _ NUM ] ) ; } else if ( args . length == _ NUM && is Box Type ( c ) ) { return invoke Primitive ( o , method ) ; } else if ( method . equals ( _ STR ) && args . length == _ NUM && ( args [ _ NUM ] instanceof  String || o instanceof  String ) ) { return  String . value Of ( o ) +  String . value Of ( args [ _ NUM ] ) ; } else if ( method . equals ( _ STR ) ) { return invoke ( invocation State , target Class , o , functional Object , invoker , _ STR , primitives , args ) ; } else if ( method . equals ( _ STR ) && args . length == _ NUM ) { return !  Lt Runtime . cast To Bool ( o ) ; } } if ( ! invocation State . is Calling Reverse ) { if ( o != null && args . length == _ NUM && args [ _ NUM ] != null ) {  String method Name = _ STR + method ;  Object _2 = args [ _ NUM ] ;  Invocation State reverse Invocation State = new  Invocation State ( ) ; reverse Invocation State . is Calling Reverse = _ BOOL ; try { return invoke ( reverse Invocation State , _2 . get Class ( ) , _2 , null , invoker , method Name , new boolean [ ] { _ BOOL } , new  Object [ ] { o } ) ; } catch (  Throwable t ) { if ( reverse Invocation State . method Found ) { throw t ; } } } if ( functional Object != null ) {  Invocation State call Functional State = new  Invocation State ( ) ; try { return call Functional Object ( call Functional State , functional Object , invoker , args ) ; } catch (  Throwable t ) { if ( call Functional State . method Found ) throw t ; } } invocation State . method Found = _ BOOL ;  Method call = null ; try {  Class < ? > cc = target Class ; if ( o != null ) { cc = o . get Class ( ) ; } call = cc . get Method ( _ STR ,  Object . class ,  String . class , boolean [ ] . class ,  Object [ ] . class ) ; if (  Modifier . is Static ( call . get Modifiers ( ) ) && ! call . get Return Type ( ) . equals ( void . class ) ) { invocation State . method Found = _ BOOL ; } } catch (  No Such Method Exception ignore ) { } if ( invocation State . method Found ) { assert call != null ; try { return call . invoke ( null , o , method , primitives , args ) ; } catch (  Invocation Target Exception e ) { throw e . get Target Exception ( ) ; } } } if ( ! invocation State . from Field && ! invocation State . is Calling Reverse ) {  Object result =  Lt Runtime . get Field ( o , method , invoker ) ; if ( result != null && ! result . equals (  Unit . get ( ) ) ) { invocation State . method Found = _ BOOL ; return call Functional Object ( result , invoker , args ) ; } }  String Builder sb = new  String Builder ( ) . append ( o == null ? target Class . get Name ( ) : o . get Class ( ) . get Name ( ) ) . append ( _ STR ) . append ( method ) . append ( _ STR ) ; boolean is First = _ BOOL ; for (  Object arg : args ) { if ( is First ) is First = _ BOOL ; else sb . append ( _ STR ) ; sb . append ( arg == null ? _ STR : arg . get Class ( ) . get Name ( ) ) ; } sb . append ( _ STR ) ; throw new  Lt Runtime Exception ( _ STR + sb . to String ( ) ) ; }  Method method To Invoke = find Best Match ( method List , args , primitives ) ; invocation State . method Found = _ BOOL ; trans To Required Type ( args , method To Invoke . get Parameter Types ( ) ) ; method To Invoke . set Accessible ( _ BOOL ) ; try {  Object res = method To Invoke . invoke ( o , args ) ; if ( method To Invoke . get Return Type ( ) == void . class ) return  Unit . get ( ) ; else return res ; } catch (  Invocation Target Exception e ) { throw e . get Target Exception ( ) ; } }
@  Override public  Constraint Widget mouse Pressed ( float x , float y ,  View Transform transform ,  Selection selection ) {  Constraint Table Layout table = (  Constraint Table Layout ) m Widget ; m Table Click Targets . clear ( ) ;  Array List <  Guideline > vertical = table . get Vertical Guidelines ( ) ; int l = transform . get Swing X ( table . get Draw X ( ) ) ; int t = transform . get Swing Y ( table . get Draw Y ( ) ) ; int column = _ NUM ;  Table Click Target first Target = new  Table Click Target ( table , column ++ , l , t - _ NUM - _ NUM , _ NUM , _ NUM ) ; m Table Click Targets . add ( first Target ) ; for (  Constraint Widget v : vertical ) { int bx = transform . get Swing X ( v . get X ( ) ) + l ;  Table Click Target target = new  Table Click Target ( table , column ++ , bx , t - _ NUM - _ NUM , _ NUM , _ NUM ) ; m Table Click Targets . add ( target ) ; }  Constraint Widget widget Hit = null ; if ( m Table Click Targets . size ( ) > _ NUM ) { for (  Table Click Target table Click Target : m Table Click Targets ) { if ( table Click Target . contains ( x , y ) ) { widget Hit = table Click Target . get Table ( ) ; break ; } } if ( selection . is Empty ( ) ) { m Table Click Targets . clear ( ) ; } } return widget Hit ; }
public  Windows Directory (  Path path ,  Lock Factory lock Factory ) throws  IOException { super ( path , lock Factory ) ; }
public static int find Minutes In Reminder List (  Array List <  Integer > values , int minutes ) { int index = values . index Of ( minutes ) ; if ( index == - _ NUM ) {  Log . e (  TAG , _ STR + minutes + _ STR ) ; return _ NUM ; } return index ; }
public void property Change (  Property Change Event e ) {  String property Name = e . get Property Name ( ) ; if ( property Name == _ STR || property Name == _ STR ) { if ( e . get New Value ( ) instanceof  JScroll Bar ) { set Scroll Bar Relations ( (  JScroll Bar ) e . get New Value ( ) ) ; } } }
public  Distribution ( float [ ] values ) { assert ( values != null && values . length > _ NUM ) ;  Arrays . sort ( values ) ; ordered Values = values . clone ( ) ; }
public  CGPoint inverse Transform (  CGPoint src ,  CGPoint dst ) throws  Noninvertible Transform Exception { double det = get Determinant ( ) ; if (  Math . abs ( det ) <  ZERO ) { throw new  Noninvertible Transform Exception ( _ STR ) ; } if ( dst == null ) { dst =  CGPoint . zero ( ) ; } double x = src . x - m02 ; double y = src . y - m12 ; dst . x = ( float ) ( ( x * m11 - y * m01 ) / det ) ; dst . y = ( float ) ( ( y * m00 - x * m10 ) / det ) ; return dst ; }
public static void rollback (  Connection conn ) throws  SQLException { if ( conn != null ) { conn . rollback ( ) ; } }
public void add Index (  IIndex index ) { if ( index != null ) { indices . add ( index ) ; } }
@  Override protected  Map <  String ,  Object > generate Config (  Http Servlet Request request ,  Http Servlet Response response ,  SSOToken sso Token ) throws  Authentication Exception { try { final  String token Idle Time = sso Token . get Property (  Jwt Session Module .  TOKEN_ IDLE_ TIME_ IN_ MINUTES_ CLAIM_ KEY ) ; final  String max Token Life = sso Token . get Property (  Jwt Session Module .  MAX_ TOKEN_ LIFE_ IN_ MINUTES_ KEY ) ; final boolean enforce Client IP =  Boolean . parse Boolean ( sso Token . get Property (  ENFORCE_ CLIENT_ IP_ SETTING_ KEY ) ) ; final  String realm = sso Token . get Property (  SSO_ TOKEN_ ORGANIZATION_ PROPERTY_ KEY ) ; boolean secure Cookie =  Boolean . parse Boolean ( sso Token . get Property (  SECURE_ COOKIE_ KEY ) ) ; boolean http Only Cookie =  Boolean . parse Boolean ( sso Token . get Property (  HTTP_ ONLY_ COOKIE_ KEY ) ) ;  String cookie Name = sso Token . get Property (  COOKIE_ NAME_ KEY ) ;  String cookie Domains String = sso Token . get Property (  COOKIE_ DOMAINS_ KEY ) ;  Collection <  String > cookie Domains ; if ( cookie Domains String . is Empty ( ) ) { cookie Domains =  Collections . singleton ( null ) ; } else { cookie Domains =  Arrays . as List ( cookie Domains String . split ( _ STR ) ) ; } final  String hmac Key =  Access Controller . do Privileged ( new  Decode Action ( sso Token . get Property (  HMAC_ KEY ) ) ) ; sso Token . set Property (  HMAC_ KEY , _ STR ) ; return persistent Cookie Module Wrapper . generate Config ( token Idle Time , max Token Life , enforce Client IP , realm , secure Cookie , http Only Cookie , cookie Name , cookie Domains , hmac Key ) ; } catch (  SSOException |  SMSException e ) {  DEBUG . error ( _ STR , e ) ; throw new  Authentication Exception ( e . get Localized Message ( ) ) ; } }
public static  List <  Object Model > load (  File model Dir ) { return load Objects From Dir ( model Dir ) ; }
private int decode Channel Wordlen ( int ch Num ) { int ret ;  Channel chan = ctx . channels [ ch Num ] ;  Channel ref Chan = ctx . channels [ _ NUM ] ; int weight Idx = _ NUM ; chan . fill Mode = _ NUM ; switch ( br . read ( _ NUM ) ) { case _ NUM : for ( int i = _ NUM ; i < ctx . num Quant Units ; i ++ ) { chan . qu Wordlen [ i ] = br . read ( _ NUM ) ; } break ; case _ NUM : if ( ch Num > _ NUM ) { ret = num Coded Units ( chan ) ; if ( ret < _ NUM ) { return ret ; } if ( chan . num Coded Vals > _ NUM ) {  VLC vlc Tab = wl_vlc_tabs [ br . read ( _ NUM ) ] ; for ( int i = _ NUM ; i < chan . num Coded Vals ; i ++ ) { int delta = vlc Tab . get VLC2 ( br ) ; chan . qu Wordlen [ i ] = ( ref Chan . qu Wordlen [ i ] + delta ) & _ NUM ; } } } else { weight Idx = br . read ( _ NUM ) ; ret = num Coded Units ( chan ) ; if ( ret < _ NUM ) { return ret ; } if ( chan . num Coded Vals > _ NUM ) { int pos = br . read ( _ NUM ) ; if ( pos > chan . num Coded Vals ) { log . error (  String . format ( _ STR , pos ) ) ; return  AT3 P_ ERROR ; } int delta Bits = br . read ( _ NUM ) ; int min Val = br . read ( _ NUM ) ; for ( int i = _ NUM ; i < pos ; i ++ ) { chan . qu Wordlen [ i ] = br . read ( _ NUM ) ; } for ( int i = pos ; i < chan . num Coded Vals ; i ++ ) { chan . qu Wordlen [ i ] = ( min Val + get Delta ( delta Bits ) ) & _ NUM ; } } } break ; case _ NUM : ret = num Coded Units ( chan ) ; if ( ret < _ NUM ) { return ret ; } if ( ch Num > _ NUM && chan . num Coded Vals > _ NUM ) {  VLC vlc Tab = wl_vlc_tabs [ br . read ( _ NUM ) ] ; int delta = vlc Tab . get VLC2 ( br ) ; chan . qu Wordlen [ _ NUM ] = ( ref Chan . qu Wordlen [ _ NUM ] + delta ) & _ NUM ; for ( int i = _ NUM ; i < chan . num Coded Vals ; i ++ ) { int diff = ref Chan . qu Wordlen [ i ] - ref Chan . qu Wordlen [ i - _ NUM ] ; delta = vlc Tab . get VLC2 ( br ) ; chan . qu Wordlen [ i ] = ( chan . qu Wordlen [ i - _ NUM ] + diff + delta ) & _ NUM ; } } else if ( chan . num Coded Vals > _ NUM ) { boolean flag = br . read Bool ( ) ;  VLC vlc Tab = wl_vlc_tabs [ br . read ( _ NUM ) ] ; int start Val = br . read ( _ NUM ) ; unpack Vq Shape ( start Val , atrac3p_wl_shapes [ start Val ] [ br . read ( _ NUM ) ] , chan . qu Wordlen , chan . num Coded Vals ) ; if ( ! flag ) { for ( int i = _ NUM ; i < chan . num Coded Vals ; i ++ ) { int delta = vlc Tab . get VLC2 ( br ) ; chan . qu Wordlen [ i ] = ( chan . qu Wordlen [ i ] + delta ) & _ NUM ; } } else { int i ; for ( i = _ NUM ; i < ( chan . num Coded Vals & - _ NUM ) ; i += _ NUM ) { if ( ! br . read Bool ( ) ) { chan . qu Wordlen [ i ] = ( chan . qu Wordlen [ i ] + vlc Tab . get VLC2 ( br ) ) & _ NUM ; chan . qu Wordlen [ i + _ NUM ] = ( chan . qu Wordlen [ i + _ NUM ] + vlc Tab . get VLC2 ( br ) ) & _ NUM ; } } if ( ( chan . num Coded Vals & _ NUM ) != _ NUM ) { chan . qu Wordlen [ i ] = ( chan . qu Wordlen [ i ] + vlc Tab . get VLC2 ( br ) ) & _ NUM ; } } } break ; case _ NUM : weight Idx = br . read ( _ NUM ) ; ret = num Coded Units ( chan ) ; if ( ret < _ NUM ) { return ret ; } if ( chan . num Coded Vals > _ NUM ) {  VLC vlc Tab = wl_vlc_tabs [ br . read ( _ NUM ) ] ; chan . qu Wordlen [ _ NUM ] = br . read ( _ NUM ) ; for ( int i = _ NUM ; i < chan . num Coded Vals ; i ++ ) { int delta = vlc Tab . get VLC2 ( br ) ; chan . qu Wordlen [ i ] = ( chan . qu Wordlen [ i - _ NUM ] + delta ) & _ NUM ; } } break ; } if ( chan . fill Mode == _ NUM ) { for ( int i = chan . num Coded Vals ; i < ctx . num Quant Units ; i ++ ) { chan . qu Wordlen [ i ] = ( ch Num > _ NUM ? br . read1 ( ) : _ NUM ) ; } } else if ( chan . fill Mode == _ NUM ) { int pos = ( ch Num > _ NUM ? chan . num Coded Vals + chan . split Point : ctx . num Quant Units - chan . split Point ) ; for ( int i = chan . num Coded Vals ; i < pos ; i ++ ) { chan . qu Wordlen [ i ] = _ NUM ; } } if ( weight Idx != _ NUM ) { return add Wordlen Weights ( chan , weight Idx ) ; } return _ NUM ; }
final void unfactor (  IR ir ) { for (  Enumeration <  Instruction > e = forward Real Instr Enumerator ( ) ; e . has More Elements ( ) ; ) {  Instruction s = e . next Element ( ) ;  Enumeration <  Basic Block > exp Outs = get Applicable Exceptional Out ( s ) ; if ( exp Outs . has More Elements ( ) && e . has More Elements ( ) ) {  Basic Block next = split Node With Links At ( s , ir ) ; next . unfactor ( ir ) ; prune Exceptional Out ( ir ) ; return ; } } }
protected void estimate Densities (  Relation <  O > rel ,  KNNQuery <  O > knnq , final  DBIDs ids ,  Writable Data Store < double [ ] > densities ) { final int dim = dimensionality ( rel ) ; final int knum = kmax + _ NUM - kmin ; for (  DBIDIter iter = ids . iter ( ) ; iter . valid ( ) ; iter . advance ( ) ) { densities . put ( iter , new double [ knum ] ) ; }  Finite Progress prog =  LOG . is Verbose ( ) ? new  Finite Progress ( _ STR , ids . size ( ) ,  LOG ) : null ; double iminbw = ( min Bandwidth > _ NUM ) ? _ NUM / ( min Bandwidth * scale ) :  Double .  POSITIVE_ INFINITY ; for (  DBIDIter iter = ids . iter ( ) ; iter . valid ( ) ; iter . advance ( ) ) {  KNNList neighbors = knnq . get KNNFor DBID ( iter , kmax + _ NUM ) ; int k = _ NUM , idx = _ NUM ; double sum = _ NUM ; for (  Double DBIDList Iter kneighbor = neighbors . iter ( ) ; k <= kmax && kneighbor . valid ( ) ; kneighbor . advance ( ) , k ++ ) { sum += kneighbor . double Value ( ) ; if ( k < kmin ) { continue ; } final double ibw =  Math . min ( k / ( sum * scale ) , iminbw ) ; final double sca =  Math Util . powi ( ibw , dim ) ; for (  Double DBIDList Iter neighbor = neighbors . iter ( ) ; neighbor . valid ( ) ; neighbor . advance ( ) ) { final double dens ; if ( sca <  Double .  POSITIVE_ INFINITY ) { dens = sca * kernel . density ( neighbor . double Value ( ) * ibw ) ; } else { dens = neighbor . double Value ( ) == _ NUM ? _ NUM : _ NUM ; } densities . get ( neighbor ) [ idx ] += dens ; if ( dens <  CUTOFF ) { break ; } } ++ idx ; }  LOG . increment Processed ( prog ) ; }  LOG . ensure Completed ( prog ) ; }
private  Boolean handle Execution Response (  Http URLConnection connection ) throws  IOException { int response Code = connection . get Response Code ( ) ; if ( is Successful ( response Code ) ) {  String response Content = get Response Content As String ( connection ) ;  String id = response Content != null ? response Content : _ STR ;  Log . i (  TAG , _ STR + m File To Upload . get Name ( ) + _ STR + id ) ; cleanup Minidump File ( ) ; try { append Uploaded Entry To Log ( id ) ; } catch (  IOException ioe ) {  Log . e (  TAG , _ STR ) ; } return _ BOOL ; } else {  String msg =  String . format (  Locale .  US , _ STR , m File To Upload . get Name ( ) , response Code , connection . get Response Message ( ) ) ;  Log . i (  TAG , msg ) ; return _ BOOL ; } }
public static  String build Scope (  String [ ] scopes ) {  String Builder builder = new  String Builder ( ) ; for ( int i = _ NUM ; i < scopes . length ; i ++ ) { builder . append ( scopes [ i ] ) ; if ( i < scopes . length - _ NUM ) { builder . append ( _ STR ) ; } } return builder . to String ( ) ; }
private int parse Header Tag ( final byte [ ] b , final int off ) throws  Parse Exception { final int len = b . length - off ; final  Crypto Algorithm crypto Algo =  Crypto Algorithm . deserialize ( crypto Algo Val_ ) ; final int tag Len = crypto Algo . get Tag Len ( ) ; if ( len >= tag Len ) { header Tag_ =  Arrays . copy Of Range ( b , off , off + tag Len ) ; return tag Len ; } else { throw new  Parse Exception ( _ STR ) ; } }
@  Benchmark public void no Coding ( ) { run ( ) ; }
private void r Move To ( float dx , float dy ) { dx += m Last X ; dy += m Last Y ; m Path . move To ( m Last X = dx , m Last Y = dy ) ; }
private  List <  String > read Lines ( final  Buffered Reader reader ) throws  IOException { final  List <  String > lines = new  Array List < > ( ) ;  String line ; for ( int line Number = _ NUM ; ( line = reader . read Line ( ) ) != null ; line Number ++ ) { if ( line . starts With ( _ STR ) ) { final int last Line Index = lines . size ( ) - _ NUM ; final  String previous Line = lines . get ( last Line Index ) ; if ( lines . is Empty ( ) || previous Line . is Empty ( ) ) { throw  Decode Exception . fatal Error (  ERR_ TEMPLATE_ FILE_ INVALID_ LEADING_ SPACE . get ( line Number , line ) ) ; } lines . set ( last Line Index , previous Line + line . substring ( _ NUM ) ) ; } else { lines . add ( line ) ; } } return lines ; }
protected void send End Of Header ( final  Output Stream out ) throws  IOException {  LOG . trace ( _ STR ) ; out . write (  CRLF_ BYTES ) ; out . write (  CRLF_ BYTES ) ; }
public void add Actual Allocation (  Big Decimal add ) { m_actual Allocation = m_actual Allocation . add ( add ) ; }
final public boolean ends With Ignore Case ( final  String suffix ) { final int l = suffix . length ( ) ; int length = length ( ) ; if ( l > length ) return _ BOOL ; int i = l ; final char [ ] a = array ; char c , d ; while ( i -- != _ NUM ) { c =  Character . to Lower Case (  Character . to Upper Case ( suffix . char At ( i ) ) ) ; d =  Character . to Lower Case (  Character . to Upper Case ( a [ -- length ] ) ) ; if ( c != d ) return _ BOOL ; } return _ BOOL ; }
@  Override public void print Stack Trace (  Print Writer s ) { if ( s != null ) { super . print Stack Trace ( s ) ;  SQLException next = get Next Exception ( ) ; for ( int i = _ NUM ; i < _ NUM && next != null ; i ++ ) { s . println ( next . to String ( ) ) ; next = next . get Next Exception ( ) ; } if ( next != null ) { s . println ( _ STR ) ; } } }
public static double distance (  Lat Lng point A ,  Lat Lng point B ) { double lat =  Math . to Radians ( point A . latitude ) ; double lat2 =  Math . to Radians ( point B . latitude ) ; double dif Lat =  Math . to Radians ( point B . latitude - point A . latitude ) ; double dif Long =  Math . to Radians ( point B . longitude - point A . longitude ) ; double a = (  Math . pow (  Math . sin ( dif Lat / _ NUM ) , _ NUM ) ) + (  Math . cos ( lat ) *  Math . cos ( lat2 ) *  Math . pow (  Math . sin ( dif Long / _ NUM ) , _ NUM ) ) ; double c = _ NUM *  Math . atan2 (  Math . sqrt ( a ) ,  Math . sqrt ( _ NUM - a ) ) ; return  EARTH * c ; }
public void read Data (  Data Input din ) throws  IOException { int byte Count = din . read Unsigned Byte ( ) ; int record Count = byte Count / _ NUM ; records = new  Record Request [ record Count ] ; for ( int i = _ NUM ; i < record Count ; i ++ ) { if ( din . read Byte ( ) != _ NUM ) { throw new  IOException ( ) ; } int file = din . read Unsigned Short ( ) ; int record = din . read Unsigned Short ( ) ; if ( record < _ NUM || record >= _ NUM ) { throw new  IOException ( ) ; } int count = din . read Unsigned Short ( ) ; records [ i ] = new  Record Request ( file , record , count ) ; } }
public void add ( int index ,  E element ) { final  Reentrant Lock lock = this . lock ; lock . lock ( ) ; try {  Object [ ] elements = get Array ( ) ; int len = elements . length ; if ( index > len || index < _ NUM ) throw new  Index Out Of Bounds Exception ( _ STR + index + _ STR + len ) ;  Object [ ] new Elements ; int num Moved = len - index ; if ( num Moved == _ NUM ) new Elements =  Arrays . copy Of ( elements , len + _ NUM ) ; else { new Elements = new  Object [ len + _ NUM ] ;  System . arraycopy ( elements , _ NUM , new Elements , _ NUM , index ) ;  System . arraycopy ( elements , index , new Elements , index + _ NUM , num Moved ) ; } new Elements [ index ] = element ; set Array ( new Elements ) ; } finally { lock . unlock ( ) ; } }
void create Edges (  String [ ] v ) { graph . add Edge ( new  Double (  Math . random ( ) ) , v [ _ NUM ] , v [ _ NUM ] ,  Edge Type .  DIRECTED ) ; graph . add Edge ( new  Double (  Math . random ( ) ) , v [ _ NUM ] , v [ _ NUM ] ,  Edge Type .  DIRECTED ) ; graph . add Edge ( new  Double (  Math . random ( ) ) , v [ _ NUM ] , v [ _ NUM ] ,  Edge Type .  DIRECTED ) ; graph . add Edge ( new  Double (  Math . random ( ) ) , v [ _ NUM ] , v [ _ NUM ] ,  Edge Type .  DIRECTED ) ; graph . add Edge ( new  Double (  Math . random ( ) ) , v [ _ NUM ] , v [ _ NUM ] ,  Edge Type .  DIRECTED ) ; graph . add Edge ( new  Double (  Math . random ( ) ) , v [ _ NUM ] , v [ _ NUM ] ,  Edge Type .  DIRECTED ) ; graph . add Edge ( new  Double (  Math . random ( ) ) , v [ _ NUM ] , v [ _ NUM ] ,  Edge Type .  DIRECTED ) ; graph . add Edge ( new  Double (  Math . random ( ) ) , v [ _ NUM ] , v [ _ NUM ] ,  Edge Type .  DIRECTED ) ; graph . add Edge ( new  Double (  Math . random ( ) ) , v [ _ NUM ] , v [ _ NUM ] ,  Edge Type .  DIRECTED ) ; graph . add Edge ( new  Double (  Math . random ( ) ) , v [ _ NUM ] , v [ _ NUM ] ,  Edge Type .  DIRECTED ) ; graph . add Edge ( new  Double (  Math . random ( ) ) , v [ _ NUM ] , v [ _ NUM ] ,  Edge Type .  DIRECTED ) ; graph . add Edge ( new  Double (  Math . random ( ) ) , v [ _ NUM ] , v [ _ NUM ] ,  Edge Type .  DIRECTED ) ; graph . add Edge ( new  Double (  Math . random ( ) ) , v [ _ NUM ] , v [ _ NUM ] ,  Edge Type .  DIRECTED ) ; graph . add Edge ( new  Double (  Math . random ( ) ) , v [ _ NUM ] , v [ _ NUM ] ,  Edge Type .  DIRECTED ) ; graph . add Edge ( new  Double (  Math . random ( ) ) , v [ _ NUM ] , v [ _ NUM ] ,  Edge Type .  DIRECTED ) ; graph . add Edge ( new  Double (  Math . random ( ) ) , v [ _ NUM ] , v [ _ NUM ] ,  Edge Type .  DIRECTED ) ; graph . add Edge ( new  Double (  Math . random ( ) ) , v [ _ NUM ] , v [ _ NUM ] ,  Edge Type .  DIRECTED ) ; }
@  Suppress Warnings ( _ STR ) public  Data Response paginate List (  Map <  String ,  String > request Params ,  Query query ,  String default Sort ,  Map <  String ,  Query Property > properties ) { return paginate List ( request Params , null , query , default Sort , properties ) ; }
private <  T extends  Component >  T build Row ( final  JPanel panel , final  IType Description description , final  String hint , final  T component , final boolean is Last ) { component . set Preferred Size ( new  Dimension (  COLORPANEL_ WIDTH ,  COLORPANEL_ HEIGHT ) ) ; final  JPanel row Panel = new  JPanel ( new  Border Layout ( ) ) ; row Panel . set Border ( new  Empty Border ( _ NUM , _ NUM , is Last ? _ NUM : _ NUM , _ NUM ) ) ; final  JPanel inner Panel = new  JPanel ( new  Grid Layout ( _ NUM , _ NUM ) ) ; inner Panel . add ( new  JCheck Box ( new  Checkbox Action ( description , description . get Description ( ) + _ STR ) ) ,  Border Layout .  CENTER ) ; inner Panel . add (  CHint Creator . create Hint Panel ( component , hint ) ,  Border Layout .  EAST ) ; row Panel . add ( inner Panel ,  Border Layout .  WEST ) ; panel . add ( row Panel ) ; return component ; }
public void arc To ( double rx , double ry , double x Axis Rotation , boolean large Arc Flag , boolean sweep Flag , double x , double y ) { if ( rx == _ NUM || ry == _ NUM ) { line To ( x , y ) ; return ; }  Node last Point = get ( size ( ) - _ NUM ) ; double x0 = ( ( last Point . mask &  C2_ MASK ) ==  C2_ MASK ) ? last Point . x [ _ NUM ] : last Point . x [ _ NUM ] ; double y0 = ( ( last Point . mask &  C2_ MASK ) ==  C2_ MASK ) ? last Point . y [ _ NUM ] : last Point . y [ _ NUM ] ; if ( x0 == x && y0 == y ) { return ; } double dx2 = ( x0 - x ) / _ NUM ; double dy2 = ( y0 - y ) / _ NUM ; double angle =  Math . to Radians ( x Axis Rotation ) ; double cos Angle =  Math . cos ( angle ) ; double sin Angle =  Math . sin ( angle ) ; double x1 = ( cos Angle * dx2 + sin Angle * dy2 ) ; double y1 = ( - sin Angle * dx2 + cos Angle * dy2 ) ; rx =  Math . abs ( rx ) ; ry =  Math . abs ( ry ) ; double  Prx = rx * rx ; double  Pry = ry * ry ; double  Px1 = x1 * x1 ; double  Py1 = y1 * y1 ; double radii Check =  Px1 /  Prx +  Py1 /  Pry ; if ( radii Check > _ NUM ) { rx =  Math . sqrt ( radii Check ) * rx ; ry =  Math . sqrt ( radii Check ) * ry ;  Prx = rx * rx ;  Pry = ry * ry ; } double sign = ( large Arc Flag == sweep Flag ) ? - _ NUM : _ NUM ; double sq = ( (  Prx *  Pry ) - (  Prx *  Py1 ) - (  Pry *  Px1 ) ) / ( (  Prx *  Py1 ) + (  Pry *  Px1 ) ) ; sq = ( sq < _ NUM ) ? _ NUM : sq ; double coef = ( sign *  Math . sqrt ( sq ) ) ; double cx1 = coef * ( ( rx * y1 ) / ry ) ; double cy1 = coef * - ( ( ry * x1 ) / rx ) ; double sx2 = ( x0 + x ) / _ NUM ; double sy2 = ( y0 + y ) / _ NUM ; double cx = sx2 + ( cos Angle * cx1 - sin Angle * cy1 ) ; double cy = sy2 + ( sin Angle * cx1 + cos Angle * cy1 ) ; double ux = ( x1 - cx1 ) / rx ; double uy = ( y1 - cy1 ) / ry ; double vx = ( - x1 - cx1 ) / rx ; double vy = ( - y1 - cy1 ) / ry ; double p , n ; n =  Math . sqrt ( ( ux * ux ) + ( uy * uy ) ) ; p = ux ; sign = ( uy < _ NUM ) ? - _ NUM : _ NUM ; double angle Start =  Math . to Degrees ( sign *  Math . acos ( p / n ) ) ; n =  Math . sqrt ( ( ux * ux + uy * uy ) * ( vx * vx + vy * vy ) ) ; p = ux * vx + uy * vy ; sign = ( ux * vy - uy * vx < _ NUM ) ? - _ NUM : _ NUM ; double angle Extent =  Math . to Degrees ( sign *  Math . acos ( p / n ) ) ; if ( ! sweep Flag && angle Extent > _ NUM ) { angle Extent -= _ NUM ; } else if ( sweep Flag && angle Extent < _ NUM ) { angle Extent += _ NUM ; } angle Extent %= _ NUM ; angle Start %= _ NUM ;  Arc2 D .  Double arc = new  Arc2 D .  Double ( cx - rx , cy - ry , rx * _ NUM , ry * _ NUM , - angle Start , - angle Extent ,  Arc2 D .  OPEN ) ;  Path Iterator i = arc . get Path Iterator (  Affine Transform . get Rotate Instance ( angle , arc . get Center X ( ) , arc . get Center Y ( ) ) ) ; double [ ] coords = new double [ _ NUM ] ; i . next ( ) ; while ( ! i . is Done ( ) ) { int type = i . current Segment ( coords ) ; switch ( type ) { case  Path Iterator .  SEG_ CLOSE : break ; case  Path Iterator .  SEG_ CUBICTO : curve To ( coords [ _ NUM ] , coords [ _ NUM ] , coords [ _ NUM ] , coords [ _ NUM ] , coords [ _ NUM ] , coords [ _ NUM ] ) ; break ; case  Path Iterator .  SEG_ LINETO : line To ( coords [ _ NUM ] , coords [ _ NUM ] ) ; break ; case  Path Iterator .  SEG_ MOVETO : break ; case  Path Iterator .  SEG_ QUADTO : quad To ( coords [ _ NUM ] , coords [ _ NUM ] , coords [ _ NUM ] , coords [ _ NUM ] ) ; break ; } i . next ( ) ; } }
protected  Bloom Filter read Bloom Filter ( ) throws  IOException { final long addr = checkpoint . addr Bloom ; if ( addr == _ NUM ) { return null ; } if ( store Cache != null ) { final  Bloom Filter bloom Filter = (  Bloom Filter ) store Cache . get ( addr ) ; if ( bloom Filter != null ) { return bloom Filter ; } } if ( log . is Info Enabled ( ) ) log . info ( _ STR + address Manager . to String ( addr ) ) ; final long off = address Manager . get Offset ( addr ) ; final int len = address Manager . get Byte Count ( addr ) ; final  Byte Buffer buf =  Byte Buffer . allocate ( len ) ; buf . limit ( len ) ; buf . position ( _ NUM ) ; try {  File Channel Utility . read All ( opener , buf , off ) ; buf . flip ( ) ; } catch (  IOException ex ) { throw new  Runtime Exception ( ex ) ; } assert buf . position ( ) == _ NUM ; assert buf . limit ( ) == len ; final  Bloom Filter bloom Filter = (  Bloom Filter )  Serializer Util . deserialize ( buf ) ; if ( log . is Info Enabled ( ) ) log . info ( _ STR + len ) ; if ( store Cache != null ) { store Cache . put If Absent ( addr , bloom Filter ) ; } return bloom Filter ; }
private void open Counter Data Output Stream ( ) throws  Data Fallback Exception { if ( d Output == null ) { if (  LOG . is Debug Enabled ( ) )  LOG . debug ( _ STR + counter File . get Name ( ) + _ STR ) ; try { d Output = new  Buffered Writer ( new  File Writer ( counter File ) ) ; } catch (  IOException e ) { throw new  Data Fallback Exception ( e . get Message ( ) ) ; } } }
private static  String parse Version Number (  String line ) {  String Tokenizer tokenizer = new  String Tokenizer ( line , _ STR ) ; if ( ! expect ( tokenizer , _ STR ) || ! expect ( tokenizer , _ STR ) || ! tokenizer . has More Tokens ( ) ) { return null ; } return tokenizer . next Token ( ) ; }
private static  String convert Ascii HDSWwn (  String wwn ) { if ( wwn . length ( ) % _ NUM != _ NUM ) { return null ; }  String Builder output = new  String Builder ( ) ; for ( int i = _ NUM ; i < wwn . length ( ) ; i += _ NUM ) {  String str = wwn . substring ( i , i + _ NUM ) ; output . append ( ( char )  Integer . parse Int ( str , _ NUM ) ) ; } return output . to String ( ) ; }
@  Override public  Array List <  Object > [ ] mine CARs (  Instances data ) throws  Exception { m_car = _ BOOL ; build Associations ( data ) ; return m_all The Rules ; }
public void test Float Value Pos ( ) {  String a = _ STR ;  Big Decimal a Number = new  Big Decimal ( a ) ; float result = _ NUM ; assert True ( _ STR , a Number . float Value ( ) == result ) ; }
public static  String replace Last (  String s ,  String sub ,  String with ) { int i = s . last Index Of ( sub ) ; if ( i == - _ NUM ) { return s ; } return s . substring ( _ NUM , i ) + with + s . substring ( i + sub . length ( ) ) ; }
private  Ascii Funcs ( ) { }
public void add Object (  Object o ) throws  Exception { inspect ( o . get Class ( ) ) ; }
public static void main (  String [ ] args ) {  System . set Property ( _ STR , _ STR ) ;  JFrame frame = new  JFrame ( ) ; frame . set Content Pane ( new  Bowler Studio3d Engine ( ) ) ; frame . set Size ( _ NUM , _ NUM ) ; frame . set Visible ( _ BOOL ) ; frame . set Default Close Operation (  JFrame .  EXIT_ ON_ CLOSE ) ; }
@  Override public int hash Code ( ) { return node Id . hash Code ( ) + action Values . hash Code ( ) ; }
public final void test Add All Helper Text Colors From Collection ( ) { int helper Text Color1 =  Color .  BLACK ; int helper Text Color2 =  Color .  GRAY ;  Collection <  Integer > helper Text Colors1 = new  Linked List < > ( ) ; helper Text Colors1 . add ( helper Text Color1 ) ; helper Text Colors1 . add ( helper Text Color2 ) ;  Password Edit Text password Edit Text = new  Password Edit Text ( get Context ( ) ) ; password Edit Text . add All Helper Text Colors ( helper Text Colors1 ) ; password Edit Text . add All Helper Text Colors ( helper Text Colors1 ) ;  Collection <  Integer > helper Text Colors2 = password Edit Text . get Helper Text Colors ( ) ; assert Equals ( helper Text Colors1 . size ( ) , helper Text Colors2 . size ( ) ) ;  Iterator <  Integer > iterator = helper Text Colors2 . iterator ( ) ; assert Equals ( helper Text Color1 , ( int ) iterator . next ( ) ) ; assert Equals ( helper Text Color2 , ( int ) iterator . next ( ) ) ; }
protected void append (  String s ) {  Buffered Writer writer ; if ( m_ Log File == null ) return ; try { writer = new  Buffered Writer ( new  File Writer ( m_ Log File , _ BOOL ) ) ; writer . write ( s ) ; writer . flush ( ) ; writer . close ( ) ; } catch (  Exception e ) { } }
public int hash Code ( ) { int hash Code = this . hash Code ; if ( hash Code == _ NUM ) { hash Code = ( ( group Id . hash Code ( ) * _ NUM + artifact Id . hash Code ( ) ) * _ NUM + version . hash Code ( ) ) * _ NUM + classifier . hash Code ( ) ; if ( hash Code == _ NUM ) { hash Code = - _ NUM ; } this . hash Code = hash Code ; } return hash Code ; }
public void write File (  String name ,  String mime Type ,  String file Name ,  Input Stream is ) throws  IOException { if ( is == null ) { throw new  Illegal Argument Exception ( _ STR ) ; } if ( file Name == null || file Name . is Empty ( ) ) { throw new  Illegal Argument Exception ( _ STR ) ; } out . write Bytes (  PREFIX ) ; out . write Bytes ( boundary ) ; out . write Bytes (  NEWLINE ) ; out . write Bytes ( _ STR + name + _ STR + file Name + _ STR ) ; out . write Bytes (  NEWLINE ) ; if ( mime Type != null ) { out . write Bytes ( _ STR + mime Type ) ; out . write Bytes (  NEWLINE ) ; } out . write Bytes (  NEWLINE ) ; byte [ ] data = new byte [ _ NUM ] ; int r = _ NUM ; while ( ( r = is . read ( data , _ NUM , data . length ) ) != - _ NUM ) { out . write ( data , _ NUM , r ) ; } is . close ( ) ; out . write Bytes (  NEWLINE ) ; out . flush ( ) ; }
@  Target Api (  Build .  VERSION_ CODES .  ICE_ CREAM_ SANDWICH_ MR1 ) private boolean needs Fallback Locale ( ) { if ( !  PACKAGE_ GOOGLE_ TTS . equals ( m Tts Engine ) || ( m Default Locale != null ) ) { return _ BOOL ; } if ( m Tts == null ) { return _ BOOL ; } final  Set <  String > features = m Tts . get Features ( m System Locale ) ; return ! ( ( ( features != null ) && features . contains (  Engine .  KEY_ FEATURE_ EMBEDDED_ SYNTHESIS ) ) || ! is Not Available Status ( m Tts . is Language Available ( m System Locale ) ) ) ; }
public  Geo Complex Polygon ( final  Planet Model planet Model , final  List <  List <  Geo Point > > points List , final  Geo Point test Point , final boolean test Point In Set ) { super ( planet Model ) ; this . test Point In Set = test Point In Set ; this . test Point = test Point ; this . test Point Fixed YPlane = new  Plane ( _ NUM , _ NUM , _ NUM , - test Point . y ) ; this . test Point Fixed XPlane = new  Plane ( _ NUM , _ NUM , _ NUM , - test Point . x ) ; this . test Point Fixed ZPlane = new  Plane ( _ NUM , _ NUM , _ NUM , - test Point . z ) ; this . test Point Fixed YAbove Plane = new  Plane ( test Point Fixed YPlane , _ BOOL ) ; this . test Point Fixed YBelow Plane = new  Plane ( test Point Fixed YPlane , _ BOOL ) ; this . test Point Fixed XAbove Plane = new  Plane ( test Point Fixed XPlane , _ BOOL ) ; this . test Point Fixed XBelow Plane = new  Plane ( test Point Fixed XPlane , _ BOOL ) ; this . test Point Fixed ZAbove Plane = new  Plane ( test Point Fixed ZPlane , _ BOOL ) ; this . test Point Fixed ZBelow Plane = new  Plane ( test Point Fixed ZPlane , _ BOOL ) ; this . edge Points = new  Geo Point [ points List . size ( ) ] ; this . shape Start Edges = new  Edge [ points List . size ( ) ] ; final  Array List <  Edge > all Edges = new  Array List < > ( ) ; int edge Point Index = _ NUM ; for ( final  List <  Geo Point > shape Points : points List ) { all Edges . ensure Capacity ( all Edges . size ( ) + shape Points . size ( ) ) ;  Geo Point last Geo Point = shape Points . get ( shape Points . size ( ) - _ NUM ) ; edge Points [ edge Point Index ] = last Geo Point ;  Edge last Edge = null ;  Edge first Edge = null ; for ( final  Geo Point this Geo Point : shape Points ) { final  Edge edge = new  Edge ( planet Model , last Geo Point , this Geo Point ) ; all Edges . add ( edge ) ; if ( first Edge == null ) { first Edge = edge ; } if ( last Edge != null ) { last Edge . next = edge ; edge . previous = last Edge ; } last Edge = edge ; last Geo Point = this Geo Point ; } first Edge . previous = last Edge ; last Edge . next = first Edge ; shape Start Edges [ edge Point Index ] = first Edge ; edge Point Index ++ ; } x Tree = new  XTree ( all Edges ) ; y Tree = new  YTree ( all Edges ) ; z Tree = new  ZTree ( all Edges ) ; }
protected  String parse Quoted String ( ) throws  IOException ,  RDFParse Exception {  String result = null ; int c1 = read Code Point ( ) ; verify Character Or Fail ( c1 , _ STR ) ; int c2 = read Code Point ( ) ; int c3 = read Code Point ( ) ; if ( ( c1 == _ STR && c2 == _ STR && c3 == _ STR ) || ( c1 == _ STR && c2 == _ STR && c3 == _ STR ) ) { result = parse Long String ( c2 ) ; } else { unread ( c3 ) ; unread ( c2 ) ; result = parse String ( c1 ) ; } try { result =  Turtle Util . decode String ( result ) ; } catch (  Illegal Argument Exception e ) { report Error ( e . get Message ( ) ,  Basic Parser Settings .  VERIFY_ DATATYPE_ VALUES ) ; } return result ; }
protected  String url ( int zoom Level , int x Tile , int y Tile ) {  String Builder sb = new  String Builder ( _url ) ; sb . append ( _ STR ) ; sb . append ( zoom Level ) ; sb . append ( _ STR ) ; sb . append ( x Tile ) ; sb . append ( _ STR ) ; sb . append ( y Tile ) ; sb . append ( _ STR ) ; return sb . to String ( ) ; }
public  Response Packet write Request Packet (  Request Packet packet ) throws  SQLException { long start =  System . current Time Millis ( ) ; boolean use Router = _ BOOL ; while ( _ BOOL ) { if ( ! use Router ) { try { return write Request Packet Internal ( packet ) ; } catch (  Remote Exception re ) { sleep ( _ NUM ) ; if (  System . current Time Millis ( ) - start >  EXECUTE_ RETRY_ TIMEOUT ) { use Router = _ BOOL ; } } } else { reinitialize ( ) ; start =  System . current Time Millis ( ) ; use Router = _ BOOL ; } } }
@  Override public void delete Columns ( int start , int len ) throws  Fits Exception { ensure Data ( ) ;  Object [ ] new Data = new  Object [ this . n Fields - len ] ; int [ ] new Offsets = new int [ this . n Fields - len ] ; int [ ] new Lengths = new int [ this . n Fields - len ] ;  Class < ? > [ ] new Types = new  Class [ this . n Fields - len ] ;  String [ ] new Nulls = new  String [ this . n Fields - len ] ;  System . arraycopy ( this . data , _ NUM , new Data , _ NUM , start ) ;  System . arraycopy ( this . lengths , _ NUM , new Lengths , _ NUM , start ) ;  System . arraycopy ( this . types , _ NUM , new Types , _ NUM , start ) ;  System . arraycopy ( this . nulls , _ NUM , new Nulls , _ NUM , start ) ;  System . arraycopy ( this . data , start + len , new Data , start , this . n Fields - start - len ) ;  System . arraycopy ( this . lengths , start + len , new Lengths , start , this . n Fields - start - len ) ;  System . arraycopy ( this . types , start + len , new Types , start , this . n Fields - start - len ) ;  System . arraycopy ( this . nulls , start + len , new Nulls , start , this . n Fields - start - len ) ; for ( int i = start ; i < start + len ; i += _ NUM ) { this . row Len -= this . lengths [ i ] + _ NUM ; } this . data = new Data ; this . offsets = new Offsets ; this . lengths = new Lengths ; this . types = new Types ; this . nulls = new Nulls ; if ( this . is Null != null ) { boolean found = _ BOOL ; boolean [ ] new Is Null = new boolean [ this . n Rows * ( this . n Fields - len ) ] ; for ( int i = _ NUM ; i < this . n Rows ; i += _ NUM ) { int old Off = this . n Fields * i ; int new Off = ( this . n Fields - len ) * i ; for ( int col = _ NUM ; col < start ; col += _ NUM ) { new Is Null [ new Off + col ] = this . is Null [ old Off + col ] ; found = found || this . is Null [ old Off + col ] ; } for ( int col = start + len ; col < this . n Fields ; col += _ NUM ) { new Is Null [ new Off + col - len ] = this . is Null [ old Off + col ] ; found = found || this . is Null [ old Off + col ] ; } } if ( found ) { this . is Null = new Is Null ; } else { this . is Null = null ; } } this . buffer = null ; this . n Fields -= len ; }
public static  String remove Chars (  String src , char ... chars ) { int i = src . length ( ) ;  String Builder sb = new  String Builder ( i ) ; mainloop : for ( int j = _ NUM ; j < i ; j ++ ) { char c = src . char At ( j ) ; for ( char a Char : chars ) { if ( c == a Char ) { continue mainloop ; } } sb . append ( c ) ; } return sb . to String ( ) ; }
private void add Indexed Columns ( ) throws  SQLException {  Database Meta Data meta Data = get Database Meta Data ( ) ;  Arrays . sort ( column Indexes ) ;  List <  String > columns = new  Array List < > ( ) ; try (  Result Set rs = meta Data . get Columns ( null , null , normalize Object Name ( statement Model . get Table Name ( ) ) , null ) ) { while ( rs . next ( ) ) { if (  Arrays . binary Search ( column Indexes , rs . get Int (  IDX_ ORDINAL_ POSITION ) ) >= _ NUM ) { columns . add ( quote Object Name ( rs . get String (  IDX_ COLUMN_ NAME ) ) ) ; } } } column Names = columns . to Array ( new  String [ _ NUM ] ) ; add Returning Clause ( ) ; }
public void load Ham NSpam (  Connection conn ) throws java . sql .  SQLException {  Prepared Statement pstmt = null ;  Result Set rs = null ; try { pstmt = conn . prepare Statement ( sql Queries . get Sql String ( _ STR , _ BOOL ) ) ; rs = pstmt . execute Query ( ) ;  Map <  String ,  Integer > ham = get Ham Token Counts ( ) ; while ( rs . next ( ) ) {  String token = rs . get String ( _ NUM ) ; int count = rs . get Int ( _ NUM ) ; if ( count > _ NUM ) { ham . put ( token , count ) ; } } delegated Log ( _ STR + ham . size ( ) ) ; rs . close ( ) ; pstmt . close ( ) ; pstmt = conn . prepare Statement ( sql Queries . get Sql String ( _ STR , _ BOOL ) ) ; rs = pstmt . execute Query ( ) ;  Map <  String ,  Integer > spam = get Spam Token Counts ( ) ; while ( rs . next ( ) ) {  String token = rs . get String ( _ NUM ) ; int count = rs . get Int ( _ NUM ) ; if ( count > _ NUM ) { spam . put ( token , count ) ; } } delegated Log ( _ STR + spam . size ( ) ) ; rs . close ( ) ; pstmt . close ( ) ; pstmt = conn . prepare Statement ( sql Queries . get Sql String ( _ STR , _ BOOL ) ) ; rs = pstmt . execute Query ( ) ; if ( rs . next ( ) ) { set Ham Message Count ( rs . get Int ( _ NUM ) ) ; set Spam Message Count ( rs . get Int ( _ NUM ) ) ; } rs . close ( ) ; pstmt . close ( ) ; } finally { if ( rs != null ) { try { rs . close ( ) ; } catch ( java . sql .  SQLException se ) { } rs = null ; } if ( pstmt != null ) { try { pstmt . close ( ) ; } catch ( java . sql .  SQLException se ) { } pstmt = null ; } } }
public static void flush ( final  Input Stream source , final  Output Stream dest ) throws  IOException { final byte [ ] buf = new byte [ _ NUM ] ; int read ; while ( ( read = source . read ( buf ) ) != - _ NUM ) { dest . write ( buf , _ NUM , read ) ; } }
public void repaint Panel ( ) { remove All ( ) ; initialize Layout ( ) ; repaint ( ) ; }
public void test Scalars With Typing ( ) throws  Exception {  Object Mapper m = new  Object Mapper ( ) ;  String json ;  Dynamic Wrapper result ; json = m . write Value As String ( new  Dynamic Wrapper (  Integer . value Of ( _ NUM ) ) ) ; result = m . read Value ( json ,  Dynamic Wrapper . class ) ; assert Equals (  Integer . value Of ( _ NUM ) , result . value ) ; json = m . write Value As String ( new  Dynamic Wrapper ( _ STR ) ) ; result = m . read Value ( json ,  Dynamic Wrapper . class ) ; assert Equals ( _ STR , result . value ) ; json = m . write Value As String ( new  Dynamic Wrapper ( _ STR ) ) ; result = m . read Value ( json ,  Dynamic Wrapper . class ) ; assert Equals ( _ STR , result . value ) ; json = m . write Value As String ( new  Dynamic Wrapper (  Boolean .  TRUE ) ) ; result = m . read Value ( json ,  Dynamic Wrapper . class ) ; assert Equals (  Boolean .  TRUE , result . value ) ; json = m . write Value As String ( new  Dynamic Wrapper (  Long . value Of ( _ NUM ) ) ) ; result = m . read Value ( json ,  Dynamic Wrapper . class ) ; assert Equals (  Long . value Of ( _ NUM ) , result . value ) ; json = m . write Value As String ( new  Dynamic Wrapper (  Test Enum .  B ) ) ; result = m . read Value ( json ,  Dynamic Wrapper . class ) ; assert Equals (  Test Enum .  B , result . value ) ; }
public  Command Editor (  Action Command cmd ,  Editable Resources res ,  String ui Name ,  List < com . codename1 . ui .  Command > commands ,  Properties project Generator Settings , boolean java5 ) { this . java5 = java5 ; this . project Generator Settings = project Generator Settings ; this . ui Name = ui Name ; init Components ( ) ; go To Source . set Enabled ( project Generator Settings != null ) ; com . codename1 . ui .  Command [ ] existing = new com . codename1 . ui .  Command [ commands . size ( ) + _ NUM ] ; existing [ _ NUM ] = null ; for ( int iter = _ NUM ; iter < existing . length ; iter ++ ) { existing [ iter ] = commands . get ( iter - _ NUM ) ; }  Vector post Actions = new  Vector ( ) ; post Actions . add Element ( _ STR ) ;  Vector actions = new  Vector ( ) ; actions . add Element ( _ STR ) ; actions . add Element ( _ STR ) ; actions . add Element ( _ STR ) ; actions . add Element ( _ STR ) ; actions . add Element ( _ STR ) ; back Command . set Selected ( cmd . is Back Command ( ) ) ;  String [ ] ui Entries = new  String [ res . get UIResource Names ( ) . length ] ;  System . arraycopy ( res . get UIResource Names ( ) , _ NUM , ui Entries , _ NUM , ui Entries . length ) ;  Arrays . sort ( ui Entries ) ; for (  String uis : ui Entries ) { if ( ! ui Name . equals ( uis ) ) { actions . add Element ( uis ) ; post Actions . add Element ( uis ) ; } } action . set Model ( new  Default Combo Box Model ( actions ) ) ; post Action . set Model ( new  Default Combo Box Model ( post Actions ) ) ;  String a = cmd . get Action ( ) ; if ( a != null ) { if ( a . starts With ( _ STR ) ) { a = a . substring ( _ NUM ) ; asynchronous . set Selected ( _ BOOL ) ; } else { if ( a . starts With ( _ STR ) ) { a = a . substring ( _ NUM ) ;  String [ ] arr = a . split ( _ STR ) ; action . set Selected Item ( arr [ _ NUM ] ) ; post Action . set Selected Item ( arr [ _ NUM ] ) ; } else { if ( a . starts With ( _ STR ) ) { a = a . substring ( _ NUM ) ; } } } } action . set Selected Item ( a ) ; name . set Text ( cmd . get Command Name ( ) ) ; id . set Model ( new  Spinner Number Model ( cmd . get Id ( ) , - _ NUM ,  Integer .  MAX_ VALUE , _ NUM ) ) ;  Resource Editor View . init Images Combo Box ( icon , res , _ BOOL , _ BOOL ) ; icon . set Selected Item ( cmd . get Icon ( ) ) ;  Resource Editor View . init Images Combo Box ( rollover , res , _ BOOL , _ BOOL ) ; rollover . set Selected Item ( cmd . get Rollover Icon ( ) ) ;  Resource Editor View . init Images Combo Box ( pressed , res , _ BOOL , _ BOOL ) ; pressed . set Selected Item ( cmd . get Pressed Icon ( ) ) ;  Resource Editor View . init Images Combo Box ( disabled , res , _ BOOL , _ BOOL ) ; disabled . set Selected Item ( cmd . get Disabled Icon ( ) ) ; }
private static  Big Decimal determine Billing Account Amount (  String billing Account Id ,  String billing Account Amount ,  Local Dispatcher dispatcher ) {  Big Decimal billing Account Amt = null ; if (  Util Validate . is Not Empty ( billing Account Id ) ) { if (  Util Validate . is Not Empty ( billing Account Amount ) ) { try { billing Account Amt = new  Big Decimal ( billing Account Amount ) ; } catch (  Number Format Exception e ) { return null ; } } if ( billing Account Amt == null ) { billing Account Amt =  Big Decimal .  ZERO ; }  Big Decimal available Balance =  Check Out Helper . available Account Balance ( billing Account Id , dispatcher ) ;  Big Decimal charge Amount =  Big Decimal .  ZERO ; if ( billing Account Amt . compare To ( available Balance ) < _ NUM ) { charge Amount = billing Account Amt ; } else { charge Amount = available Balance ; } if ( charge Amount . compare To (  Big Decimal .  ZERO ) < _ NUM ) { charge Amount =  Big Decimal .  ZERO ; } return charge Amount ; } else { return null ; } }
public  T remove Index ( int index ) { if ( index >= size ) throw new  Index Out Of Bounds Exception (  String . value Of ( index ) ) ;  T [ ] items = this . items ;  T value = (  T ) items [ index ] ; size -- ; if ( ordered )  System . arraycopy ( items , index + _ NUM , items , index , size - index ) ; else items [ index ] = items [ size ] ; items [ size ] = null ; return value ; }
public static  Symbol Variant symbol Variant (  Char Sequence symbol ) { int length = symbol . length ( ) ; if ( length == _ NUM ) { throw new  Empty Symbol Exception ( ) ; } if ( is Identifier Keyword ( symbol ) ) { return  Symbol Variant .  QUOTED ; } char c = symbol . char At ( _ NUM ) ; if ( is Identifier Start ( c ) ) { for ( int ii = _ NUM ; ii < length ; ii ++ ) { c = symbol . char At ( ii ) ; if ( ( c == _ STR || c < _ NUM || c > _ NUM ) || ! is Identifier Part ( c ) ) { return  Symbol Variant .  QUOTED ; } } return  Symbol Variant .  IDENTIFIER ; } if ( is Operator Part ( c ) ) { for ( int ii = _ NUM ; ii < length ; ii ++ ) { c = symbol . char At ( ii ) ; if ( ! is Operator Part ( c ) ) { return  Symbol Variant .  QUOTED ; } } return  Symbol Variant .  OPERATOR ; } return  Symbol Variant .  QUOTED ; }
public static boolean is Signing Related (  String name ) { name = name . to Upper Case (  Locale .  ENGLISH ) ; if ( ! name . starts With ( _ STR ) ) { return _ BOOL ; } name = name . substring ( _ NUM ) ; if ( name . index Of ( _ STR ) != - _ NUM ) { return _ BOOL ; } if ( is Block Or SF ( name ) || name . equals ( _ STR ) ) { return _ BOOL ; } else if ( name . starts With ( _ STR ) ) { int ext Index = name . last Index Of ( _ STR ) ; if ( ext Index != - _ NUM ) {  String ext = name . substring ( ext Index + _ NUM ) ; if ( ext . length ( ) > _ NUM || ext . length ( ) < _ NUM ) { return _ BOOL ; } for ( int index = _ NUM ; index < ext . length ( ) ; index ++ ) { char cc = ext . char At ( index ) ; if ( ( cc < _ STR || cc > _ STR ) && ( cc < _ STR || cc > _ STR ) ) { return _ BOOL ; } } } return _ BOOL ; } return _ BOOL ; }
public static  Document load Document (  Input Stream stream ) throws  Exception {  Document Builder Factory factory =  Document Builder Factory . new Instance ( ) ;  Document Builder builder = factory . new Document Builder ( ) ; return builder . parse ( stream ) ; }
private  Node next Node (  Node x ,  XMLWriter xml ) {  Node n , c ; if ( ( c = x . get Child ( _ NUM ) ) != null ) { } else if ( ( c = x . get Next Sibling ( ) ) != null ) { xml . end ( ) ; } else { c = x . get Parent ( ) ; xml . end ( ) ; while ( c != null ) { if ( ( n = c . get Next Sibling ( ) ) != null ) { c = n ; xml . end ( ) ; break ; } c = c . get Parent ( ) ; xml . end ( ) ; } } return c ; }
@  Deprecated public  Boolean is Hod ( final  Long assign Id ) { final  List <  Head Of Departments > hod List = employee Department Repository . get All Hod Departments ( assign Id ) ; return ! hod List . is Empty ( ) ; }
public  Munger limit Label Languages (  String ... languages ) { return limit Label Languages (  Arrays . as List ( languages ) ) ; }
Combo Value (  List value List ) { this ( (  Stat Value [ ] ) value List . to Array ( new  Stat Value [ value List . size ( ) ] ) ) ; }
protected double category Utility ( ) throws  Exception { if ( m_children == null ) { throw new  Exception ( _ STR ) ; } double total CU = _ NUM ; for ( int i = _ NUM ; i < m_children . size ( ) ; i ++ ) {  CNode child = m_children . get ( i ) ; total CU += category Utility Child ( child ) ; } total CU /= m_children . size ( ) ; return total CU ; }
protected void bezier To ( float control1x , float control1y , float control2x , float control2y , float end X , float end Y ) { m PSStream . println ( trunc ( control1x ) + _ STR + trunc ( control1y ) + _ STR + trunc ( control2x ) + _ STR + trunc ( control2y ) + _ STR + trunc ( end X ) + _ STR + trunc ( end Y ) +  CURVETO_ STR ) ; m Pen X = end X ; m Pen Y = end Y ; }
public  Tv Show Episode Scrape Task (  List <  Tv Show Episode > episodes ,  Media Scraper media Scraper , boolean scrape Thumb ) { super (  BUNDLE . get String ( _ STR ) , episodes . size ( ) ,  Task Type .  BACKGROUND_ TASK ) ; this . episodes = episodes ; this . media Scraper = media Scraper ; this . scrape Thumb = scrape Thumb ; }
public  Model MBean Info Support (  String class Name ,  String description ,  Model MBean Attribute Info [ ] attributes ,  Model MBean Constructor Info [ ] constructors ,  Model MBean Operation Info [ ] operations ,  Model MBean Notification Info [ ] notifications ) { this ( class Name , description , attributes , constructors , operations , notifications , null ) ; }
public  Builder task (  Object id ,  Runnable runnable ) { tasks . add ( new  Task Wrapper ( null , id , runnable ) ) ; return this ; }
private void adjust Bottom (  Rect F rect , float bottom ,  Rect F bounds , int view Height , float snap Margin , float aspect Ratio , boolean left Moves , boolean right Moves ) { float new Bottom = bottom ; if ( new Bottom > view Height ) { new Bottom = view Height + ( new Bottom - view Height ) / _ NUM ; m Touch Offset . y -= ( new Bottom - view Height ) / _ NUM ; } if ( new Bottom > bounds . bottom ) { m Touch Offset . y -= ( new Bottom - bounds . bottom ) / _ NUM ; } if ( bounds . bottom - new Bottom < snap Margin ) { new Bottom = bounds . bottom ; } if ( new Bottom - rect . top < m Min Crop Height ) { new Bottom = rect . top + m Min Crop Height ; } if ( new Bottom - rect . top > m Max Crop Height ) { new Bottom = rect . top + m Max Crop Height ; } if ( bounds . bottom - new Bottom < snap Margin ) { new Bottom = bounds . bottom ; } if ( aspect Ratio > _ NUM ) { float new Width = ( new Bottom - rect . top ) * aspect Ratio ; if ( new Width < m Min Crop Width ) { new Bottom =  Math . min ( bounds . bottom , rect . top + m Min Crop Width / aspect Ratio ) ; new Width = ( new Bottom - rect . top ) * aspect Ratio ; } if ( new Width > m Max Crop Width ) { new Bottom =  Math . min ( bounds . bottom , rect . top + m Max Crop Width / aspect Ratio ) ; new Width = ( new Bottom - rect . top ) * aspect Ratio ; } if ( left Moves && right Moves ) { new Bottom =  Math . min ( new Bottom ,  Math . min ( bounds . bottom , rect . top + bounds . width ( ) / aspect Ratio ) ) ; } else { if ( left Moves && rect . right - new Width < bounds . left ) { new Bottom =  Math . min ( bounds . bottom , rect . top + ( rect . right - bounds . left ) / aspect Ratio ) ; new Width = ( new Bottom - rect . top ) * aspect Ratio ; } if ( right Moves && rect . left + new Width > bounds . right ) { new Bottom =  Math . min ( new Bottom ,  Math . min ( bounds . bottom , rect . top + ( bounds . right - rect . left ) / aspect Ratio ) ) ; } } } rect . bottom = new Bottom ; }
public void send Exception ( final  Exception exception , final  Map <  String ,  String > properties ) { final  Property Map Builder builder = new  Property Map Builder ( properties ) ; logger . debug (  String . format ( _ STR , exception . get Message ( ) , builder . to String ( ) ) ) ; if ( telemetry Client != null ) { telemetry Client . track Exception ( exception , builder . build ( ) , null ) ; } }
public void handle Header Column Left Click (  Point p ) {  JTable Header th =  TABLE . get Table Header ( ) ; int col = th . column At Point ( p ) ; int c =  TABLE . convert Column Index To Model ( col ) ; int old C =  DATA_ MODEL . get Sort Column ( ) ; if ( c != - _ NUM ) { sort And Maintain Selection ( c ) ; th . repaint ( th . get Header Rect ( col ) ) ; if ( old C != - _ NUM && old C != c ) { int old Col =  TABLE . convert Column Index To View ( old C ) ; th . repaint ( th . get Header Rect ( old Col ) ) ; } } }
public static boolean bulks Insert Episodes (  Context context ,  List <  Episode > episode List ) {  Log . d (  TAG , _ STR + episode List . size ( ) ) ;  Content Resolver content Resolver = context . get Content Resolver ( ) ;  Content Values [ ] records = new  Content Values [ episode List . size ( ) ] ; for ( int i = _ NUM ; i < records . length ; i ++ ) { records [ i ] =  Episode Model . from Episode ( episode List . get ( i ) ) ; } return content Resolver . bulk Insert (  Premo Contract .  Episode Entry .  CONTENT_ URI , records ) > _ NUM ; }
public  Tracked Entity Instance Query Params add Filters If Not Exist (  List <  Query Item > filtrs ) { for (  Query Item filter : filtrs ) { if ( filters != null && ! filters . contains ( filter ) ) { filters . add ( filter ) ; } } return this ; }
public static  List <  String > file List (  String directory Path , boolean include Full Path ) {  List <  String > file List = new  Array List <  String > ( ) ;  String dir = directory Path . substring ( _ NUM , directory Path . last Index Of (  File . separator ) ) ;  String pattern =  String Utils . substring After Last ( directory Path ,  File . separator ) ;  File directory = new  File ( dir ) ; if ( directory . is Directory ( ) ) {  File [ ] files = directory . list Files ( ) ; for ( int i = _ NUM ; i < files . length ; i ++ ) {  File f = files [ i ] ; if ( f . is File ( ) ) {  String file Name = f . get Name ( ) ;  String full Path = dir +  File . separator + file Name ; if ( file Name . matches ( convert Glob To Reg Ex ( pattern ) ) ) { if ( include Full Path ) { file List . add ( full Path ) ; } else { file List . add ( file Name ) ; } } } } } return file List ; }
public static int hash (  Object object ) { return object == null ? _ NUM : object . hash Code ( ) ; }
public  Resource from Properties (  Properties properties ) {  String name = properties . get Property (  Resource Property Set .  RESOURCE_ NAME ) ;  String type = properties . get Property (  Resource Property Set .  RESOURCE_ TYPE ) ;  Resource resource = new  Resource ( name , type ) ; if ( properties . contains Key (  Resource Property Set .  RESOURCE_ CLASS ) ) {  String class Name = properties . get Property (  Resource Property Set .  RESOURCE_ CLASS ) ; resource . set Class Name ( class Name ) ; } if ( properties . contains Key (  Resource Property Set .  RESOURCE_ ID ) ) {  String id = properties . get Property (  Resource Property Set .  RESOURCE_ ID ) ; resource . set Id ( id ) ; } else { resource . set Id ( create Id From Jndi Location If Not Null ( name ) ) ; }  String parameters As ASemicolon Delimited String = properties . get Property (  Resource Property Set .  PARAMETERS ) ; resource . set Parameters (  Property Utils . to Map ( get Parameters From String (  Property Utils . escape Back Slashes If Not Null ( parameters As ASemicolon Delimited String ) ) ) ) ; return resource ; }
public static double sum ( final  List < ? extends  Number > list ) { double sum = _ NUM ; for (  Number number : list ) { sum += number . double Value ( ) ; } return sum ; }
public static  String to Hex ( byte [ ] data ) { return new  String (  Hex . encode Hex ( data ) ) ; }
@  Visible For Testing public void disable Browser Override For Test ( ) { m Disable Browser Override = _ BOOL ; m Persistent Control Tokens . clear ( ) ; m Handler . remove Messages (  MSG_ ID_ HIDE_ CONTROLS ) ; if ( m Control Animation != null ) { m Control Animation . cancel ( ) ; m Control Animation = null ; } m Browser Control Offset =  Float .  Na N ; update Visuals ( ) ; }
public static  String htmlentities ( final  String str ) { if ( str == null ) { return _ STR ; } if ( htmlentities_map . is Empty ( ) ) { initialize Entities Tables ( ) ; } final  String Builder buf = new  String Builder ( ) ; for ( int i = _ NUM ; i < str . length ( ) ; ++ i ) { final char ch = str . char At ( i ) ; final  String entity = htmlentities_map . get ( new  Integer ( ch ) ) ; if ( entity == null ) { if ( ch > _ NUM ) { buf . append ( _ STR + ( int ) ch + _ STR ) ; } else { buf . append ( ch ) ; } } else { buf . append ( entity ) ; } } return buf . to String ( ) ; }
static public boolean start (  ASync Process parent ,  Process Info pi ) { if ( pi . get AD_ Process_ ID ( ) == _ NUM ) return start Document Print (  Report Engine .  ORDER , null , pi . get Record_ ID ( ) , null ) ; if ( pi . get AD_ Process_ ID ( ) ==  MProcess . get Process_ ID ( _ STR , null ) ) return start Document Print (  Report Engine .  MANUFACTURING_ ORDER , null , pi . get Record_ ID ( ) , null ) ; if ( pi . get AD_ Process_ ID ( ) ==  MProcess . get Process_ ID ( _ STR , null ) ) return start Document Print (  Report Engine .  DISTRIBUTION_ ORDER , null , pi . get Record_ ID ( ) , null ) ; else if ( pi . get AD_ Process_ ID ( ) == _ NUM ) return start Document Print (  Report Engine .  INVOICE , null , pi . get Record_ ID ( ) , null ) ; else if ( pi . get AD_ Process_ ID ( ) == _ NUM ) return start Document Print (  Report Engine .  SHIPMENT , null , pi . get Record_ ID ( ) , null ) ; else if ( pi . get AD_ Process_ ID ( ) == _ NUM ) return start Document Print (  Report Engine .  PROJECT , null , pi . get Record_ ID ( ) , null ) ; else if ( pi . get AD_ Process_ ID ( ) == _ NUM ) return start Document Print (  Report Engine .  RFQ , null , pi . get Record_ ID ( ) , null ) ; else if ( pi . get AD_ Process_ ID ( ) == _ NUM ) return start Document Print (  Report Engine .  DUNNING , null , pi . get Record_ ID ( ) , null ) ; else if ( pi . get AD_ Process_ ID ( ) == _ NUM || pi . get AD_ Process_ ID ( ) == _ NUM ) return start Fin Report ( pi ) ; return start Standard Report ( pi ) ; }
private  Map <  URI ,  Storage System > build Array Map (  List <  Volume Descriptor > descriptors ,  Volume Descriptor .  Type type ) {  Map <  URI ,  Storage System > array Map = new  Hash Map <  URI ,  Storage System > ( ) ; if ( type != null ) { descriptors =  Volume Descriptor . filter By Type ( descriptors , new  Volume Descriptor .  Type [ ] { type } , new  Volume Descriptor .  Type [ ] { } ) ; } for (  Volume Descriptor desc : descriptors ) { if ( array Map . contains Key ( desc . get Device URI ( ) ) == _ BOOL ) {  Storage System array = get Data Object (  Storage System . class , desc . get Device URI ( ) , _db Client ) ; array Map . put ( desc . get Device URI ( ) , array ) ; } } return array Map ; }
public byte [ ] decrypt ( byte [ ] bytes To Decode ,  Char Sequence password ) throws  Key Crypter Exception { try { byte [ ] salt = new byte [  SALT_ LENGTH ] ;  System . arraycopy ( bytes To Decode , _ NUM , salt , _ NUM ,  SALT_ LENGTH ) ; byte [ ] cipher Bytes = new byte [ bytes To Decode . length -  SALT_ LENGTH ] ;  System . arraycopy ( bytes To Decode ,  SALT_ LENGTH , cipher Bytes , _ NUM , bytes To Decode . length -  SALT_ LENGTH ) ;  Parameters With IV key = (  Parameters With IV ) get AESPassword Key ( password , salt ) ;  Buffered Block Cipher cipher = new  Padded Buffered Block Cipher ( new  CBCBlock Cipher ( new  AESFast Engine ( ) ) ) ; cipher . init ( _ BOOL , key ) ; byte [ ] decrypted Bytes = new byte [ cipher . get Output Size ( cipher Bytes . length ) ] ; final int process Length = cipher . process Bytes ( cipher Bytes , _ NUM , cipher Bytes . length , decrypted Bytes , _ NUM ) ; final int do Final Length = cipher . do Final ( decrypted Bytes , process Length ) ; return  Arrays . copy Of ( decrypted Bytes , process Length + do Final Length ) ; } catch (  Exception e ) { throw new  Key Crypter Exception ( _ STR , e ) ; } }
public final  Array List <  Wifi Record > load Wifis Overview Within ( final int session , final  Double min Lon , final  Double max Lon , final  Double min Lat , final  Double max Lat ) { final  Array List <  Wifi Record > wifis = new  Array List < > ( ) ;  String selection = null ;  String [ ] selection Args = null ; if ( min Lon != null && max Lon != null && min Lat != null && max Lat != null ) { selection = _ STR +  Schema .  COL_ LONGITUDE + _ STR + _ STR +  Schema .  COL_ LONGITUDE + _ STR + _ STR +  Schema .  COL_ LATITUDE + _ STR + _ STR +  Schema .  COL_ LATITUDE + _ STR ; selection Args = new  String [ ] {  String . value Of ( min Lon ) ,  String . value Of ( max Lon ) ,  String . value Of ( min Lat ) ,  String . value Of ( max Lat ) } ; } final  Cursor cursor = content Resolver . query (  Content Uris . with Appended Id (  Uri . with Appended Path (  Content Provider .  CONTENT_ URI_ WIFI ,  Content Provider .  CONTENT_ URI_ OVERVIEW_ SUFFIX ) , session ) , null , selection , selection Args , null ) ; final int column Index = cursor . get Column Index (  Schema .  COL_ BSSID ) ; final int column Index2 = cursor . get Column Index (  Schema .  COL_ SSID ) ; final int column Index3 = cursor . get Column Index (  Schema .  COL_ CAPABILITIES ) ; final int column Index4 = cursor . get Column Index (  Schema .  COL_ FREQUENCY ) ; final int column Index5 = cursor . get Column Index (  Schema .  COL_ MAX_ LEVEL ) ; final int column Index6 = cursor . get Column Index (  Schema .  COL_ TIMESTAMP ) ; final int column Index7 = cursor . get Column Index (  Schema .  COL_ BEGIN_ POSITION_ ID ) ; final int column Index8 = cursor . get Column Index (  Schema .  COL_ END_ POSITION_ ID ) ; final int column Index9 = cursor . get Column Index (  Schema .  COL_ KNOWN_ WIFI ) ; while ( cursor . move To Next ( ) ) { final  Wifi Record wifi = new  Wifi Record ( ) ; wifi . set Bssid ( cursor . get String ( column Index ) ) ; wifi . set Ssid ( cursor . get String ( column Index2 ) ) ; wifi . set Capabilities ( cursor . get String ( column Index3 ) ) ; wifi . set Frequency ( cursor . get Int ( column Index4 ) ) ; wifi . set Level ( cursor . get Int ( column Index5 ) ) ; wifi . set Open Bmap Timestamp ( cursor . get Long ( column Index6 ) ) ; wifi . set Begin Position ( load Position By Id ( cursor . get String ( column Index7 ) ) ) ; wifi . set End Position ( load Position By Id ( cursor . get String ( column Index8 ) ) ) ; wifi . set Catalog Status (  Catalog Status . values ( ) [ cursor . get Int ( column Index9 ) ] ) ; wifis . add ( wifi ) ; } cursor . close ( ) ; return wifis ; }
public static _ Fields find By Thrift Id ( int field Id ) { switch ( field Id ) { case _ NUM : return  MESSAGE ; case _ NUM : return  TYPE ; default : return null ; } }
@  Override public void install (  JEditor Pane editor ) { super . install ( editor ) ; editor . add Key Listener ( this ) ; }
@  Override public boolean is Secure ( ) { if ( _s == null || _ssl Socket Class == null ) return _ BOOL ; else return _ssl Socket Class . is Assignable From ( _s . get Class ( ) ) ; }
protected void go To (  Image Tile [ ] selected Tiles2 ) { if ( map Bean == null ) {  Map Handler bc = (  Map Handler ) get Bean Context ( ) ; if ( bc != null ) { map Bean = (  Map Bean ) bc . get ( com . bbn . openmap .  Map Bean . class ) ; } } if ( map Bean != null ) { if ( selected Tiles != null && selected Tiles . length > _ NUM ) {  Rectangle2 D rec = null ; for ( int i = selected Tiles2 . length - _ NUM ; i >= _ NUM ; i -- ) {  Image Tile tile = selected Tiles2 [ i ] ; if ( rec == null ) { rec = new  Rectangle2 D .  Double ( tile . get LRLon ( ) , tile . get LRLat ( ) , _ NUM , _ NUM ) ; rec . add ( tile . get ULLon ( ) , tile . get ULLat ( ) ) ; } else { rec . add ( tile . get ULLon ( ) , tile . get ULLat ( ) ) ; rec . add ( tile . get LRLon ( ) , tile . get LRLat ( ) ) ; } } if ( rec != null ) {  Point2 D center = new  Point2 D .  Double ( rec . get Center X ( ) , rec . get Center Y ( ) ) ;  Point2 D anchor1 = new  Point2 D .  Double ( rec . get Min X ( ) , rec . get Max Y ( ) ) ;  Point2 D anchor2 = new  Point2 D .  Double ( rec . get Max X ( ) , rec . get Min Y ( ) ) ;  Proj proj = (  Proj ) map Bean . get Projection ( ) ; float scale = proj . get Scale ( anchor1 , anchor2 , proj . forward ( anchor1 ) , proj . forward ( anchor2 ) ) ; if ( logger . is Loggable (  Level .  FINE ) ) { logger . fine ( _ STR + anchor1 + _ STR + anchor2 + _ STR + scale ) ; } proj . set Center ( center ) ; proj . set Scale ( scale ) ; map Bean . set Projection ( proj ) ; } } } }
public  URI create Tenant (  Keystone Tenant tenant ) {  Tenant Org Rest Rep tenant Resp = _internal Tenant Service Client . create Tenant ( _keystone Utils Service . prepare Tenant Param ( tenant ) ) ; return tenant Resp . get Id ( ) ; }
public static  String to Tool Tip Text (  Color c ) { if ( formatter == null ) { formatter = new  Color Tool Tip Text Formatter ( ) ; } try { return formatter . value To String ( c ) ; } catch (  Parse Exception ex ) {  Internal Error error = new  Internal Error ( _ STR + c ) ; error . init Cause ( ex ) ; throw error ; } }
@  Override public void draw Node (  Graphics g , int w , int h ) { if ( ( m_type &  PURE_ INPUT ) ==  PURE_ INPUT ) { g . set Color (  Color . green ) ; } else { g . set Color (  Color . orange ) ; }  Font Metrics fm = g . get Font Metrics ( ) ; int l = ( int ) ( m_x * w ) - fm . string Width ( m_id ) / _ NUM ; int t = ( int ) ( m_y * h ) - fm . get Height ( ) / _ NUM ; g . fill3 DRect ( l , t , fm . string Width ( m_id ) + _ NUM , fm . get Height ( ) + fm . get Descent ( ) + _ NUM , _ BOOL ) ; g . set Color (  Color . black ) ; g . draw String ( m_id , l + _ NUM , t + fm . get Height ( ) + _ NUM ) ; }
public void read External (  Object Input in ) throws  IOException ,  Class Not Found Exception { id = (  Activation ID ) in . read Object ( ) ; ref = null ;  String class Name = in . read UTF ( ) ; if ( class Name . equals ( _ STR ) ) return ; try {  Class < ? > ref Class =  Class . for Name (  Remote Ref . package Prefix + _ STR + class Name ) ; ref = (  Remote Ref ) ref Class . new Instance ( ) ; ref . read External ( in ) ; } catch (  Instantiation Exception e ) { throw new  Unmarshal Exception ( _ STR , e ) ; } catch (  Illegal Access Exception e ) { throw new  Unmarshal Exception ( _ STR ) ; } }
public double empirical HSICincomplete Cholesky (  Tetrad Matrix  Gy ,  Tetrad Matrix  Gx , int m ) { int ky =  Gy . columns ( ) ; int kx =  Gx . columns ( ) ;  Tetrad Matrix  H =  Kernel Utils . construct H ( m ) ;  Tetrad Matrix  Gcy =  H . times (  Gy ) ;  Tetrad Matrix  Gcx =  H . times (  Gx ) ;  Tetrad Matrix  Gcyt =  Gcy . transpose ( ) ;  Tetrad Matrix  A =  Gcyt . times (  Gcx ) ;  Tetrad Matrix  B =  Gcy . times (  A ) ;  Tetrad Matrix  Gcxt =  Gcx . transpose ( ) ; double emp HSIC = _ NUM ; for ( int i = _ NUM ; i < m ; i ++ ) { emp HSIC += matrix Product Entry (  B ,  Gcxt , i , i ) ; } emp HSIC /=  Math . pow ( m - _ NUM , _ NUM ) ; return emp HSIC ; }
public static  String parse (  String [ ] options ,  String option ,  String def Value ) throws  Exception {  String value =  Utils . get Option ( option , options ) ; if ( value . is Empty ( ) ) return def Value ; else return value ; }
public boolean is Source Balanced ( ) { if ( m_lines . size ( ) == _ NUM || m_doc . is Multi Currency ( ) ) return _ BOOL ;  Big Decimal balance = get Source Balance ( ) ; boolean ret Value = balance . signum ( ) == _ NUM ; if ( ret Value ) log . finer ( to String ( ) ) ; else log . warning ( _ STR + balance + _ STR + to String ( ) ) ; return ret Value ; }
private void grow ( int min Capacity ) { int old Capacity = element Data . length ; int new Capacity = old Capacity + ( old Capacity > > _ NUM ) ; if ( new Capacity - min Capacity < _ NUM ) { new Capacity = min Capacity ; } if ( new Capacity -  MAX_ ARRAY_ SIZE > _ NUM ) { new Capacity = huge Capacity ( min Capacity ) ; } element Data =  Arrays . copy Of ( element Data , new Capacity ) ; }
private static  Method find Method (  Object instance ,  String name ,  Class < ? > ... parameter Types ) throws  No Such Method Exception { for (  Class < ? > clazz = instance . get Class ( ) ; clazz != null ; clazz = clazz . get Superclass ( ) ) { try {  Method method = clazz . get Declared Method ( name , parameter Types ) ; if ( ! method . is Accessible ( ) ) { method . set Accessible ( _ BOOL ) ; } return method ; } catch (  No Such Method Exception e ) { } } throw new  No Such Method Exception ( _ STR + name + _ STR +  Arrays . as List ( parameter Types ) + _ STR + instance . get Class ( ) ) ; }
public static byte [ ] compress ( byte [ ] data ) throws  IOException {  Deflater deflater = new  Deflater ( _ NUM ,  Boolean .  TRUE ) ; deflater . set Input ( data ) ;  Byte Array Output Stream output Stream = new  Byte Array Output Stream ( data . length ) ; deflater . finish ( ) ; byte [ ] buffer = new byte [ _ NUM ] ; while ( ! deflater . finished ( ) ) { int count = deflater . deflate ( buffer ) ; output Stream . write ( buffer , _ NUM , count ) ; } output Stream . close ( ) ; byte [ ] output = output Stream . to Byte Array ( ) ; deflater . end ( ) ; return output ; }
protected final void drag Exit ( final int x , final int y ) {  Drag Source Event event = new  Drag Source Event ( get Drag Source Context ( ) , x , y ) ;  Event Dispatcher dispatcher = new  Event Dispatcher (  DISPATCH_ EXIT , event ) ;  Sun Toolkit . invoke Later On App Context (  Sun Toolkit . target To App Context ( get Component ( ) ) , dispatcher ) ; start Secondary Event Loop ( ) ; }
@  Override public  Object create Statement (  Object proxy ,  Method method ,  Object [ ] args ,  Object statement , long time ) { try {  String name = method . get Name ( ) ;  Constructor < ? > constructor = null ;  String sql = null ; if ( compare (  CREATE_ STATEMENT , name ) ) { constructor = get Constructor (  CREATE_ STATEMENT_ IDX ,  Statement . class ) ; } else if ( compare (  PREPARE_ STATEMENT , name ) ) { constructor = get Constructor (  PREPARE_ STATEMENT_ IDX ,  Prepared Statement . class ) ; sql = (  String ) args [ _ NUM ] ; } else if ( compare (  PREPARE_ CALL , name ) ) { constructor = get Constructor (  PREPARE_ CALL_ IDX ,  Callable Statement . class ) ; sql = (  String ) args [ _ NUM ] ; } else { return statement ; } return create Decorator ( proxy , method , args , statement , constructor , sql ) ; } catch (  Exception x ) { if ( x instanceof  Invocation Target Exception ) {  Throwable cause = x . get Cause ( ) ; if ( cause instanceof  Thread Death ) { throw (  Thread Death ) cause ; } if ( cause instanceof  Virtual Machine Error ) { throw (  Virtual Machine Error ) cause ; } } logger . warn ( _ STR , x ) ; } return statement ; }
private  Tag Lib Factory (  String sax Parser ,  Tag Lib lib ,  Resource res ,  Identification id ) throws  Tag Lib Exception { this . id = id ; this . lib = lib == null ? new  Tag Lib ( ) : lib ;  Reader r = null ; try {  Input Source is = new  Input Source ( r =  IOUtil . get Reader ( res . get Input Stream ( ) , (  Charset ) null ) ) ; is . set System Id ( res . get Path ( ) ) ; init ( sax Parser , is ) ; } catch (  IOException e ) { throw new  Tag Lib Exception ( e ) ; } finally {  IOUtil . close EL ( r ) ; } }
public void clear ( ) { set URL ( m_ Db Utils . get Database URL ( ) ) ; set User ( m_ Db Utils . get Username ( ) ) ; set Password ( m_ Db Utils . get Password ( ) ) ; }
public  Service Call <  Void > update Profile ( final  Conversation conversation , final  Map <  String ,  String > profile ) {  Validator . not Null ( conversation , _ STR ) ; return update Profile ( conversation . get Dialog Id ( ) , conversation . get Client Id ( ) , profile ) ; }
public void datasource (  String name ,  String rpn Expression ) { sources . add ( new  CDef ( name , rpn Expression ) ) ; }
private void parse Wild Cards ( ) { if ( f Pattern . starts With ( _ STR ) ) f Has Leading Star = _ BOOL ; if ( f Pattern . ends With ( _ STR ) ) { if ( f Length > _ NUM && f Pattern . char At ( f Length - _ NUM ) != _ STR ) { f Has Trailing Star = _ BOOL ; } }  Vector <  String > temp = new  Vector <  String > ( ) ; int pos = _ NUM ;  String Buffer buf = new  String Buffer ( ) ; while ( pos < f Length ) { char c = f Pattern . char At ( pos ++ ) ; switch ( c ) { case _ STR : if ( pos >= f Length ) { buf . append ( c ) ; } else { char next = f Pattern . char At ( pos ++ ) ; if ( next == _ STR || next == _ STR || next == _ STR ) { buf . append ( next ) ; } else { buf . append ( c ) ; buf . append ( next ) ; } } break ; case _ STR : if ( buf . length ( ) > _ NUM ) { temp . add Element ( buf . to String ( ) ) ; f Bound += buf . length ( ) ; buf . set Length ( _ NUM ) ; } break ; case _ STR : buf . append ( f Single Wild Card ) ; break ; default : buf . append ( c ) ; } } if ( buf . length ( ) > _ NUM ) { temp . add Element ( buf . to String ( ) ) ; f Bound += buf . length ( ) ; } f Segments = new  String [ temp . size ( ) ] ; temp . copy Into ( f Segments ) ; }
public static byte [ ] base64 To Bytes (  String base64 ) throws  Illegal Argument Exception { if ( base64 == null ) { return null ; } try { return  Base64 . decode ( base64 ,  Base64 .  NO_ WRAP ) ; } catch (  Illegal Argument Exception e ) { log . error ( _ STR + base64 ) ; return null ; } }
@  Override public void draw Series (  Canvas canvas ,  Paint paint ,  List <  Float > points ,  XYSeries Renderer series Renderer , float y Axis Value , int series Index , int start Index ) { int series Nr = m Dataset . get Series Count ( ) ; int length = points . size ( ) ; paint . set Color ( series Renderer . get Color ( ) ) ; paint . set Style (  Style .  FILL ) ; float half Diff X = get Half Diff X ( points , length , series Nr ) ; for ( int i = _ NUM ; i < length ; i += _ NUM ) { float x = points . get ( i ) ; float y = points . get ( i + _ NUM ) ; draw Bar ( canvas , x , y Axis Value , x , y , half Diff X , series Nr , series Index , paint ) ; } paint . set Color ( series Renderer . get Color ( ) ) ; }
public boolean prepare Connection (  String server ,  String ports ,  String channel ) {  String username = settings . get String ( _ STR ) ;  String password = settings . get String ( _ STR ) ; boolean use Password = settings . get Boolean ( _ STR ) ;  String token = settings . get String ( _ STR ) ;  String login = _ STR + token ; if ( token . is Empty ( ) ) { login = _ STR ; } if ( use Password ) { login = password ;  LOGGER . info ( _ STR ) ; } return prepare Connection ( username , login , channel , server , ports ) ; }
public static boolean is Byte Code Class Name (  String class Name ) { return ( ( class Name . starts With ( _ STR ) || class Name . starts With ( _ STR ) ) && class Name . ends With ( _ STR ) && ( ( class Name . index Of ( _ STR ) != - _ NUM || class Name . index Of ( _ STR ) == - _ NUM ) ) ) ; }
@  Suppress Warnings ( _ STR ) public void notify Changed Slot (  Loco Net Slot s ) { if ( s . get Slot ( ) !=  Ln Constants .  FC_ SLOT ) { return ; } if ( ! correct Fast Clock && ! synchronize With Internal Clock && ! set Internal ) { return ; } if ( log . is Debug Enabled ( ) ) { log . debug ( _ STR + s ) ; } cur Days = s . get Fc Days ( ) ; cur Hours = s . get Fc Hours ( ) ; cur Minutes = s . get Fc Minutes ( ) ; int tem Rate = s . get Fc Rate ( ) ; if ( ( tem Rate != cur Rate ) && ! set Internal ) { set Rate ( cur Rate ) ; } else if ( ( tem Rate != cur Rate ) && set Internal ) { try { clock . user Set Rate ( tem Rate ) ; } catch ( jmri .  Timebase Rate Exception e ) { if ( ! timebase Error Reported ) { timebase Error Reported = _ BOOL ; log . warn ( _ STR ) ; } } } cur Fractional Minutes = s . get Fc Frac Mins ( ) ;  Date tem = clock . get Time ( ) ; int c Hours = tem . get Hours ( ) ; long c Num MSec = tem . get Time ( ) ; long n Num MSec = ( ( c Num MSec /  MSECPERHOUR ) *  MSECPERHOUR ) - ( c Hours *  MSECPERHOUR ) + ( cur Hours *  MSECPERHOUR ) + ( cur Minutes *  MSECPERMINUTE ) ; if ( read In Progress && ! in Sync With Internal Fast Clock ) { n Num MSec += ( long ) ( ( (  CORRECTION - cur Fractional Minutes ) /  CORRECTION *  MSECPERMINUTE ) ) ; clock . set Time ( new  Date ( n Num MSec ) ) ; } else if ( set Internal ) { clock . set Time ( new  Date ( n Num MSec ) ) ; } in Sync With Internal Fast Clock = _ BOOL ; }
private boolean is Job Scheduling Needed (  URI id ,  String type , boolean in Progress , boolean is Error , boolean scheduler , long last Time , long next Time ) { long system Time =  System . current Time Millis ( ) ; long tolerance =  Long . parse Long ( _config Info . get (  TOLERANCE ) ) * _ NUM ; _logger . info ( _ STR , next Time , last Time ) ; long refresh Interval = get Refresh Interval ( type ) ; if ( ! in Progress ) { if ( scheduler ) { if ( system Time < next Time - tolerance ) { _logger . info ( _ STR , id + _ STR + type , new  Date ( next Time ) ) ; _logger . info ( _ STR , new  Date ( system Time ) , tolerance ) ; return _ BOOL ; } } if ( ! scheduler && is Error && last Time > _ NUM ) { _logger . info ( _ STR , type , id ) ; return _ BOOL ; } if ( system Time - last Time < refresh Interval * _ NUM ) { _logger . info ( _ STR , id , type ) ; return _ BOOL ; } } else if ( ! scheduler && ( system Time - last Time > refresh Interval * _ NUM ) && last Time > _ NUM ) { _logger . info ( _ STR , type , id ) ; } else if ( scheduler && ( system Time - last Time > refresh Interval * _ NUM ) && next Time > _ NUM &&  System . current Time Millis ( ) - next Time >=  Job Intervals . get Max Idle Interval ( ) * _ NUM ) { _logger . info ( _ STR , type , id ) ; } else { _logger . info ( _ STR , type , id ) ; return _ BOOL ; } return _ BOOL ; }
private void add Breakpoints ( final  Set <  Breakpoint Address > addresses , final  Breakpoint Status status , final  Breakpoint Storage storage , final  Breakpoint Type type ) {  Preconditions . check Not Null ( addresses , _ STR ) ;  Preconditions . check Not Null ( status , _ STR ) ;  Preconditions . check Not Null ( storage , _ STR ) ;  Preconditions . check Not Null ( type , _ STR ) ; if ( addresses . size ( ) == _ NUM ) { return ; } final  List <  Breakpoint > breakpoints = new  Array List < > ( ) ; for ( final  Breakpoint Address address : addresses ) { final  Breakpoint breakpoint = new  Breakpoint ( type , address ) ; storage . add ( breakpoint , status ) ; breakpoints . add ( breakpoint ) ; } for ( final  Breakpoint Manager Listener listener : listeners ) { try { listener . breakpoints Added ( breakpoints ) ; } catch ( final  Exception e ) {  CUtility Functions . log Exception ( e ) ; } } }
public void replace Creation Template (  Creation Template template ,  Guid org Guid ) throws  UMSException { if ( template == null ) { return ; }  String template Name = template . get Name ( ) ; if ( template Name == null ) {  String msg = i18n . get String (  IUMSConstants .  MISSING_ TEMPL_ NAME ) ; throw new  Illegal Argument Exception ( msg ) ; }  Attr Set attr Set = to Attr Set ( template ) ; try { m_config Manager . replace Creation Template ( org Guid , template Name , attr Set ) ; } catch (  Config Manager Exception e ) { throw new  UMSException ( e . get Message ( ) ) ; } }
private static  Entry [ ] unmarshal Attributes (  Object Input Stream in ) throws  IOException ,  Class Not Found Exception {  Array List attributes = new  Array List ( ) ;  Marshalled Instance mi = null ; while ( ( mi = (  Marshalled Instance ) in . read Object ( ) ) != null ) { try { attributes . add ( (  Entry ) mi . get ( _ BOOL ) ) ; } catch (  Throwable e ) { if ( e instanceof  Error &&  Throwable Constants . retryable ( e ) ==  Throwable Constants .  BAD_ OBJECT ) { throw (  Error ) e ; } logger . log (  Level .  WARNING , _ STR , e ) ; } }  Entry [ ] attrs = new  Entry [ attributes . size ( ) ] ; return (  Entry [ ] ) attributes . to Array ( attrs ) ; }
public  Sc Physical Server create Server (  String ssn ,  String host Name , boolean is Iscsi ,  String os Id ) throws  Storage Center APIException {  Parameters params = new  Parameters ( ) ; params . add ( _ STR , host Name ) ; params . add ( _ STR , ssn ) ; params . add ( _ STR ,  NOTES_ STRING ) ; params . add ( _ STR , os Id ) ;  Rest Result rr = rest Client . post ( _ STR , params . to Json ( ) ) ; if ( ! check Results ( rr ) ) {  String error =  String . format ( _ STR , host Name , rr . get Error Msg ( ) ) ; throw new  Storage Center APIException ( error ) ; } return gson . from Json ( rr . get Result ( ) ,  Sc Physical Server . class ) ; }
public void test Completed Stage ( ) {  Atomic Integer x = new  Atomic Integer ( _ NUM ) ;  Atomic Reference <  Throwable > r = new  Atomic Reference <  Throwable > ( ) ;  Completion Stage <  Integer > f =  Completable Future . completed Stage ( _ NUM ) ; f . when Complete ( null ) ; assert Equals ( x . get ( ) , _ NUM ) ; assert Null ( r . get ( ) ) ; }
private void write Directory Post Resource (  String Builder sb ,  String path ) { sb . append ( _ STR +  DIR_ RESOURCE_ SET + _ STR ) ; sb . append ( path . replace ( _ STR , _ STR ) ) ; }
public static int find Name (  String name ,  String [ ] table ) { for ( int i = _ NUM ; i < table . length ; i ++ ) { if ( name . equals ( table [ i ] ) ) { return i ; } } return - _ NUM ; }
public synchronized void add Curl Mesh (  Curl Mesh mesh ) { remove Curl Mesh ( mesh ) ; m Curl Meshes . add ( mesh ) ; }
static public  List <  List <  Sequence <  IString > > > read References (  String [ ] reference Filenames ) throws  IOException { return read References ( reference Filenames , _ BOOL ) ; }
public boolean is Closed ( ) throws  SQLException { return this . is Closed ; }
public void insert Sleep Time ( ) {  Script Step sleep Time Script Step =  Script Step Factory . create Sleep Time ( get Sleep Time ( ) ) ; steps . add ( get Insert Index ( ) , sleep Time Script Step ) ; sleep Time = _ STR ; reindex Script Steps ( ) ; }
private void fix Up Phi Predecessors (  Array List <  Instruction > phi Instructions ,  Basic Block unoptimized Loop Exit ,  Basic Block optimized Loop Exit ) { if ( unoptimized Loop Exit != null ) { for (  Instruction instruction : phi Instructions ) {  Phi . set Pred ( instruction ,  OPTIMIZED_ LOOP_ OPERAND , new  Basic Block Operand ( optimized Loop Exit ) ) ;  Phi . set Pred ( instruction ,  UNOPTIMIZED_ LOOP_ OPERAND , new  Basic Block Operand ( unoptimized Loop Exit ) ) ; } } else { for (  Instruction instruction : phi Instructions ) {  Operand operand =  Phi . get Value ( instruction ,  OPTIMIZED_ LOOP_ OPERAND ) ;  Phi . resize Number Of Preds ( instruction , _ NUM ) ;  Phi . resize Number Of Values ( instruction , _ NUM ) ;  Phi . set Value ( instruction ,  OPTIMIZED_ LOOP_ OPERAND , operand ) ;  Phi . set Pred ( instruction ,  OPTIMIZED_ LOOP_ OPERAND , new  Basic Block Operand ( optimized Loop Exit ) ) ; } } }
public void append ( byte [ ] buffer , int offset , int length ) { if ( _length + length >= _capacity ) ensure Capacity ( _length + length ) ;  System . arraycopy ( buffer , offset , _buffer , _length , length ) ; _length += length ; }
private <  T >  T read Object (  Json Node source ,  Class <  T > clazz , boolean handle Relationships ) throws  IOException ,  Illegal Access Exception ,  Instantiation Exception {  String identifier = create Identifier ( source ) ;  T result = (  T ) resource Cache . get ( identifier ) ; if ( result == null ) {  Class < ? > type = get Actual Type ( source , clazz ) ; if ( source . has (  ATTRIBUTES ) ) { result = (  T ) object Mapper . tree To Value ( source . get (  ATTRIBUTES ) , type ) ; } else { if ( type . is Interface ( ) ) { result = null ; } else { result = (  T ) object Mapper . tree To Value ( object Mapper . create Object Node ( ) , type ) ; } } if ( source . has (  META ) ) {  Field field = configuration . get Meta Field ( type ) ; if ( field != null ) {  Class < ? > meta Type = configuration . get Meta Type ( type ) ;  Object meta Object = object Mapper . tree To Value ( source . get (  META ) , meta Type ) ; field . set ( result , meta Object ) ; } } if ( source . has (  LINKS ) ) {  Field link Field = configuration . get Links Field ( type ) ; if ( link Field != null ) { link Field . set ( result , new  Links ( map Links ( source . get (  LINKS ) ) ) ) ; } } if ( result != null ) { resource Cache . cache ( identifier , result ) ; set Id Value ( result , source . get (  ID ) ) ; if ( handle Relationships ) { handle Relationships ( source , result ) ; } } } return result ; }
public void remove Actions For ( int entity Id ) {  Vector <  Entity Action > to Keep = new  Vector <  Entity Action > ( actions . size ( ) ) ; for (  Entity Action ea : actions ) { if ( ea . get Entity Id ( ) != entity Id ) { to Keep . add Element ( ea ) ; } } actions = to Keep ; }
private void clean Up Database Resources (  Database conn ,  Statement st ,  Result Set rs ) { if ( rs != null ) { try { rs . close ( ) ; } catch (  SQLException ignore ) { } } if ( st != null ) { try { st . close ( ) ; } catch (  SQLException ignore ) { } } if ( conn != null ) conn . close ( ) ; }
public  OMScaling Icon ( double center Lat , double center Lon ,  Image Icon ii ) { this ( center Lat , center Lon , ii . get Image ( ) ) ; }
@  Override protected  Void do In Background (  Void ... voids ) {  Https URLConnection con = null ;  Input Stream input Stream = null ;  File Output Stream output Stream = null ; try { con =  Net Cipher . get Https URLConnection ( file URL ) ; int response Code = con . get Response Code ( ) ; if ( response Code ==  Http URLConnection .  HTTP_ OK ) { file Size = con . get Content Length ( ) ; input Stream = new  Buffered Input Stream ( con . get Input Stream ( ) ) ; output Stream = new  File Output Stream ( save File Path ) ; int buffer Size = _ NUM ; int downloaded = _ NUM ; int bytes Read = - _ NUM ; byte [ ] buffer = new byte [ buffer Size ] ; while ( ( bytes Read = input Stream . read ( buffer ) ) != - _ NUM ) { output Stream . write ( buffer , _ NUM , bytes Read ) ; downloaded += bytes Read ; if ( downloaded % _ NUM < buffer Size ) { publish Progress ( downloaded ) ; } } publish Progress ( buffer Size ) ; } else {  Log . i (  TAG , _ STR + response Code ) ; } } catch (  IOException e ) {  Log . e (  TAG , _ STR , e ) ; e . print Stack Trace ( ) ; } finally { try { if ( output Stream != null ) { output Stream . close ( ) ; } if ( input Stream != null ) { input Stream . close ( ) ; } } catch (  IOException e ) { e . print Stack Trace ( ) ; } if ( con != null ) { con . disconnect ( ) ; } } return null ; }
private  Widget pack Widget ( int dpi ,  Widget Preview Loader preview Loader ,  Icon Cache icon Cache ,  Component Name provider ) { final  App Widget Provider Info info = find App Widget Provider Info ( provider ) ;  Widget widget = new  Widget ( ) ; widget . provider = provider . flatten To Short String ( ) ; widget . label = info . label ; widget . configure = info . configure != null ; if ( info . icon != _ NUM ) { widget . icon = new  Resource ( ) ;  Drawable full Res Icon = icon Cache . get Full Res Icon ( provider . get Package Name ( ) , info . icon ) ;  Bitmap icon =  Utilities . create Icon Bitmap ( full Res Icon , m Context ) ;  Byte Array Output Stream os = new  Byte Array Output Stream ( ) ; if ( icon . compress (  IMAGE_ FORMAT ,  IMAGE_ COMPRESSION_ QUALITY , os ) ) { widget . icon . data = os . to Byte Array ( ) ; widget . icon . dpi = dpi ; } } if ( info . preview Image != _ NUM ) { widget . preview = new  Resource ( ) ;  Bitmap preview = preview Loader . generate Widget Preview ( info , null ) ;  Byte Array Output Stream os = new  Byte Array Output Stream ( ) ; if ( preview . compress (  IMAGE_ FORMAT ,  IMAGE_ COMPRESSION_ QUALITY , os ) ) { widget . preview . data = os . to Byte Array ( ) ; widget . preview . dpi = dpi ; } } return widget ; }
protected  String parse Long String ( int closing Character ) throws  IOException ,  RDFParse Exception {  String Builder sb = get Builder ( ) ; int double Quote Count = _ NUM ; int c ; while ( double Quote Count < _ NUM ) { c = read Code Point ( ) ; if ( c == - _ NUM ) { throw EOFException ( ) ; } else if ( c == closing Character ) { double Quote Count ++ ; } else { double Quote Count = _ NUM ; } append Codepoint ( sb , c ) ; if ( c == _ STR ) { c = read Code Point ( ) ; if ( c == - _ NUM ) { throw EOFException ( ) ; } append Codepoint ( sb , c ) ; } } return sb . substring ( _ NUM , sb . length ( ) - _ NUM ) ; }
private void code Wrap Argument (  Class < ? > type , int slot ,  Data Output Stream out ) throws  IOException { if ( type . is Primitive ( ) ) {  Primitive Type Info prim =  Primitive Type Info . get ( type ) ; if ( type == int . class || type == boolean . class || type == byte . class || type == char . class || type == short . class ) { code_iload ( slot , out ) ; } else if ( type == long . class ) { code_lload ( slot , out ) ; } else if ( type == float . class ) { code_fload ( slot , out ) ; } else if ( type == double . class ) { code_dload ( slot , out ) ; } else { throw new  Assertion Error ( ) ; } out . write Byte ( opc_invokestatic ) ; out . write Short ( cp . get Method Ref ( prim . wrapper Class Name , _ STR , prim . wrapper Value Of Desc ) ) ; } else { code_aload ( slot , out ) ; } }
private static float [ ] derive Text Bounds Anchor Offsets (  Graphics2 D g2 ,  String text ,  Text Anchor anchor ) { float [ ] result = new float [ _ NUM ] ;  Font Render Context frc = g2 . get Font Render Context ( ) ;  Font f = g2 . get Font ( ) ;  Font Metrics fm = g2 . get Font Metrics ( f ) ;  Rectangle2 D bounds = get Text Bounds ( text , fm ) ;  Line Metrics metrics = f . get Line Metrics ( text , frc ) ; float ascent = metrics . get Ascent ( ) ; float half Ascent = ascent / _ NUM ; float descent = metrics . get Descent ( ) ; float leading = metrics . get Leading ( ) ; float x Adj = _ NUM ; float y Adj = _ NUM ; if ( anchor . is Horizontal Center ( ) ) { x Adj = ( float ) - bounds . get Width ( ) / _ NUM ; } else if ( anchor . is Right ( ) ) { x Adj = ( float ) - bounds . get Width ( ) ; } if ( anchor . is Top ( ) ) { y Adj = - descent - leading + ( float ) bounds . get Height ( ) ; } else if ( anchor . is Half Ascent ( ) ) { y Adj = half Ascent ; } else if ( anchor . is Vertical Center ( ) ) { y Adj = - descent - leading + ( float ) ( bounds . get Height ( ) / _ NUM ) ; } else if ( anchor . is Baseline ( ) ) { y Adj = _ NUM ; } else if ( anchor . is Bottom ( ) ) { y Adj = - metrics . get Descent ( ) - metrics . get Leading ( ) ; } result [ _ NUM ] = x Adj ; result [ _ NUM ] = y Adj ; return result ; }
@  Suppress Lint ( _ STR ) public static  String format Number (  String phone Number ,  String default Country Iso ) { if ( phone Number . starts With ( _ STR ) || phone Number . starts With ( _ STR ) ) { return phone Number ; }  Phone Number Util util =  Phone Number Util . get Instance ( ) ;  String result = null ; try {  Phonenumber .  Phone Number pn = util . parse And Keep Raw Input ( phone Number , default Country Iso ) ; result = util . format In Original Format ( pn , default Country Iso ) ; } catch (  Number Parse Exception e ) { } return result ; }
public  Whitelist (  Collection <  String > patterns , int status Code ) { if ( patterns == null || patterns . is Empty ( ) ) { this . patterns =  Collections . empty List ( ) ; } else {  Immutable List .  Builder <  Pattern > builder =  Immutable List . builder ( ) ; for (  String pattern : patterns ) { builder . add (  Pattern . compile ( pattern ) ) ; } this . patterns = builder . build ( ) ; } this . status Code = status Code ; this . enabled = _ BOOL ; }
public static  String [ ] ls Files Recursive (  String directory ,  Filename Filter filter ) throws  IOException {  File dir = new  File ( directory ) ;  Array List <  String > files = new  Array List < > ( ) ; for (  File filepath : dir . list Files ( filter ) ) { if ( is File ( filepath . get Absolute Path ( ) ) ) files . add ( filepath . get Absolute Path ( ) ) ; else if ( is Directory ( filepath . get Absolute Path ( ) ) ) files . add All (  Arrays . as List ( ls Files Recursive ( filepath . get Absolute Path ( ) , filter ) ) ) ; } return files . to Array ( new  String [ files . size ( ) ] ) ; }
private static int parse Int (  String value , int begin Index , int end Index ) throws  Number Format Exception { if ( begin Index < _ NUM || end Index > value . length ( ) || begin Index > end Index ) { throw new  Number Format Exception ( value ) ; } int i = begin Index ; int result = _ NUM ; int digit ; if ( i < end Index ) { digit =  Character . digit ( value . char At ( i ++ ) , _ NUM ) ; if ( digit < _ NUM ) { throw new  Number Format Exception ( _ STR + value ) ; } result = - digit ; } while ( i < end Index ) { digit =  Character . digit ( value . char At ( i ++ ) , _ NUM ) ; if ( digit < _ NUM ) { throw new  Number Format Exception ( _ STR + value ) ; } result *= _ NUM ; result -= digit ; } return - result ; }
public  E put ( int key ,  E value ) { if ( value == null ) { throw new  Null Pointer Exception ( ) ; } synchronized ( this ) {  Object [ ] arr = array ;  E prev ; if ( key < arr . length ) { prev = (  E ) arr [ key ] ; } else { arr =  Arrays . copy Of ( arr , key * _ NUM / _ NUM + _ NUM ) ; prev = null ; } if ( prev == null ) { size ++ ; } arr [ key ] = value ; array = arr ; return prev ; } }
public void remove Foreign Key (  Foreign Key foreign Key ) { if ( foreign Key != null ) { foreign Keys . remove ( foreign Key ) ; } }
public java . lang .  String Buffer insert ( int offset , java . lang .  Object obj ) { internal . insert ( offset , obj ) ; return this ; }
public static  Collection <  String > names (  Flags flags ) { final  Collection <  String > results = new  Array List <  String > ( ) ; if ( flags . contains (  Flags .  Flag .  ANSWERED ) ) { results . add (  ANSWERED_ OUTPUT_ CAPITALISED ) ; } if ( flags . contains (  Flags .  Flag .  DELETED ) ) { results . add (  DELETED_ OUTPUT_ CAPITALISED ) ; } if ( flags . contains (  Flags .  Flag .  DRAFT ) ) { results . add (  DRAFT_ OUTPUT_ CAPITALISED ) ; } if ( flags . contains (  Flags .  Flag .  FLAGGED ) ) { results . add (  FLAGGED_ OUTPUT_ CAPITALISED ) ; } if ( flags . contains (  Flags .  Flag .  RECENT ) ) { results . add (  RECENT_ OUTPUT_ CAPITALISED ) ; } if ( flags . contains (  Flags .  Flag .  SEEN ) ) { results . add (  SEEN_ OUTPUT_ CAPITALISED ) ; }  String [ ] user Flags = flags . get User Flags ( ) ;  Collections . add All ( results , user Flags ) ; if ( flags . contains (  Flags .  Flag .  USER ) ) { results . add (  USER_ OUTPUT_ CAPITALISED ) ; } return results ; }
@  Override public  Path Impl scheme Walk (  String user Path ,  Map <  String ,  Object > attributes ,  String file Path , int offset ) { int length = file Path . length ( ) ; if ( length <= offset || file Path . char At ( offset ) != _ STR ) return super . scheme Walk ( user Path , attributes , file Path , offset ) ;  Merge Path merge Path = create Merge Path ( ) ; merge Path . set User Path ( user Path ) ; int head = ++ offset ; int tail = head ; while ( tail < length ) { int ch = file Path . char At ( tail ) ; if ( ch == _ STR ) { if ( head + _ NUM != tail ) {  String sub Path = file Path . substring ( head , tail ) ; if ( sub Path . starts With ( _ STR ) && sub Path . ends With ( _ STR ) ) sub Path = sub Path . substring ( _ NUM , sub Path . length ( ) - _ NUM ) ; merge Path . add Merge Path (  Vfs Old . lookup ( sub Path ) ) ; } if ( tail + _ NUM == length ) return merge Path ; else return merge Path . fs Walk ( user Path , attributes , file Path . substring ( tail + _ NUM ) ) ; } else if ( ch == _ STR ) {  String sub Path = file Path . substring ( head , tail ) ; if ( sub Path . starts With ( _ STR ) && sub Path . ends With ( _ STR ) ) sub Path = sub Path . substring ( _ NUM , sub Path . length ( ) - _ NUM ) ; merge Path . add Merge Path (  Vfs Old . lookup ( sub Path ) ) ; head = ++ tail ; } else if ( ch == _ STR ) { int depth = _ NUM ; for ( tail ++ ; tail < length ; tail ++ ) { if ( file Path . char At ( tail ) == _ STR ) depth ++ ; else if ( file Path . char At ( tail ) == _ STR ) { tail ++ ; depth -- ; if ( depth == _ NUM ) break ; } } if ( depth != _ NUM ) return new  Not Found Path ( get Scheme Map ( ) , file Path ) ; } else tail ++ ; } return new  Not Found Path ( get Scheme Map ( ) , file Path ) ; }
public static double log10 ( final double x ) { final double hi Prec [ ] = new double [ _ NUM ] ; final double lores = log ( x , hi Prec ) ; if (  Double . is Infinite ( lores ) ) { return lores ; } final double tmp = hi Prec [ _ NUM ] *  HEX_40000000 ; final double lna = hi Prec [ _ NUM ] + tmp - tmp ; final double lnb = hi Prec [ _ NUM ] - lna + hi Prec [ _ NUM ] ; final double rln10a = _ NUM ; final double rln10b = _ NUM ; return rln10b * lnb + rln10b * lna + rln10a * lnb + rln10a * lna ; }
protected  Node unbox (  Node node ) { if (  Types Utils . is Boxed Primitive ( node . get Type ( ) ) ) {  Member Select Tree prim Value Select = tree Builder . build Prim Value Method Access ( node . get Tree ( ) ) ; handle Artificial Tree ( prim Value Select ) ;  Method Access Node prim Value Access = new  Method Access Node ( prim Value Select , node ) ; prim Value Access . set In Source ( _ BOOL ) ;  Type Element npe Element = elements . get Type Element ( _ STR ) ; insert Node With Exceptions After ( prim Value Access ,  Collections . singleton ( npe Element . as Type ( ) ) , node ) ;  Method Invocation Tree prim Value Call = tree Builder . build Method Invocation ( prim Value Select ) ; handle Artificial Tree ( prim Value Call ) ;  Node unboxed = new  Method Invocation Node ( prim Value Call , prim Value Access ,  Collections . <  Node > empty List ( ) , get Current Path ( ) ) ; unboxed . set In Source ( _ BOOL ) ;  Type Element throwable Element = elements . get Type Element ( _ STR ) ; add To Converted Lookup Map ( node . get Tree ( ) , unboxed ) ; insert Node With Exceptions After ( unboxed ,  Collections . singleton ( throwable Element . as Type ( ) ) , prim Value Access ) ; return unboxed ; } else { return node ; } }
private static  URI cookie Uri (  URI uri ,  Http Cookie cookie ) {  URI cookie Uri = uri ; if ( cookie . get Domain ( ) != null ) {  String domain = cookie . get Domain ( ) ; if ( domain . char At ( _ NUM ) == _ STR ) { domain = domain . substring ( _ NUM ) ; } try { cookie Uri = new  URI ( uri . get Scheme ( ) == null ? _ STR : uri . get Scheme ( ) , domain , cookie . get Path ( ) == null ? _ STR : cookie . get Path ( ) , null ) ; } catch (  URISyntax Exception e ) {  Log . w (  TAG , e ) ; } } return cookie Uri ; }
public synchronized void shutdown ( ) { shutdown = _ BOOL ; notify All ( ) ; }
protected synchronized long lastchunkpointer ( ) throws  IOException { long len = backing Random Access File . length ( ) ; if ( len < f Header . header Size ( ) ) { return - _ NUM ; } else { len -= f Header . header Size ( ) ; int offset = ( int ) ( len %  CHUNK_ ENC_ SIZE ) ; if ( ( offset == _ NUM ) && ( len == _ NUM ) ) { return _ NUM ; } else if ( ( len != _ NUM ) && ( offset == _ NUM ) ) { return ( ( len /  CHUNK_ ENC_ SIZE ) - _ NUM ) ; } else { return ( len /  CHUNK_ ENC_ SIZE ) ; } } }
public void internal Entity Decl (  String name ,  XMLString text ,  XMLString non Normalized Text ,  Augmentations augs ) throws  XNIException { try { if ( f Decl Handler != null ) { f Decl Handler . internal Entity Decl ( name , text . to String ( ) ) ; } } catch (  SAXException e ) { throw new  XNIException ( e ) ; } }
protected boolean is File Exist (  String log Name ) {  String full Path = debug Directory +  File . separator + log Name ;  File f = new  File ( full Path ) ; return f . exists ( ) && ! f . is Directory ( ) ; }
public  String next Token ( ) throws  No Such Element Exception { if ( pos < len && delim . index Of ( str . char At ( pos ) ) >= _ NUM ) { if ( ret Delims ) return str . substring ( pos , ++ pos ) ; while ( ++ pos < len && delim . index Of ( str . char At ( pos ) ) >= _ NUM ) ; } if ( pos < len ) { int start = pos ; while ( ++ pos < len && delim . index Of ( str . char At ( pos ) ) < _ NUM ) ; return str . substring ( start , pos ) ; } throw new  No Such Element Exception ( ) ; }
public  Permission Request Object ask ( int req Code ) { m Request Code = req Code ; int length = m Permission Names . length ; m Permissions We Dont Have = new  Array List < > ( length ) ; for (  String m Permission Name : m Permission Names ) { m Permissions We Dont Have . add ( new  Single Permission ( m Permission Name ) ) ; } if ( need To Ask ( ) ) {  Log . i (  TAG , _ STR ) ; if ( m Activity != null ) {  Activity Compat . request Permissions ( m Activity , m Permission Names , req Code ) ; } else { m Fragment . request Permissions ( m Permission Names , req Code ) ; } } else {  Log . i (  TAG , _ STR ) ; if ( m Grant Func != null ) { m Grant Func . call ( ) ; } } return this ; }
protected static  List <  String > parse Roles (  String roles As String ) {  List <  String > roles = new  Array List <  String > ( ) ;  String Tokenizer role Tokens = new  String Tokenizer ( roles As String , _ STR ) ; while ( role Tokens . has More Tokens ( ) ) {  String role Token = role Tokens . next Token ( ) ; roles . add ( role Token ) ; } return roles ; }
public static int calc RLen ( int diff ) { return ( int )  Math . round ( _ NUM *  Math . log ( rand . next Int ( diff + _ NUM ) + _ NUM ) + rand . next Int ( _ NUM ) ) ; }
private static byte [ ] bytes ( int ... vals ) { final byte [ ] octets = new byte [ vals . length ] ; for ( int i = _ NUM ; i < vals . length ; i ++ ) { octets [ i ] = ( byte ) vals [ i ] ; } return octets ; }
private  JPanel create Project Tree Panel ( ) { final  JPanel project Tree Panel = new  JPanel ( new  Border Layout ( ) ) ; project Tree Panel . set Border ( null ) ; project Tree Panel . set Background (  Color .  WHITE ) ; m_project Tree . set Border ( new  Empty Border ( _ NUM , _ NUM , _ NUM , _ NUM ) ) ; m_project Tree . add Tree Selection Listener ( new  Internal Tree Selection Listener ( ) ) ; final  JScroll Pane pane = new  JScroll Pane ( m_project Tree ) ; pane . set Vertical Scroll Bar Policy (  Scroll Pane Constants .  VERTICAL_ SCROLLBAR_ AS_ NEEDED ) ; pane . set Horizontal Scroll Bar Policy (  Scroll Pane Constants .  HORIZONTAL_ SCROLLBAR_ AS_ NEEDED ) ; pane . set Border ( null ) ; project Tree Panel . add ( pane ,  Border Layout .  CENTER ) ; return project Tree Panel ; }
public static double correlation ( double [ ] x , double [ ] y ) { if ( x . length == y . length ) { double mx =  Math Utils . mean ( x ) ; double my =  Math Utils . mean ( y ) ; double sx =  Math . sqrt (  Math Utils . variance ( x ) ) ; double sy =  Math . sqrt (  Math Utils . variance ( y ) ) ; int n = x . length ; double nval = _ NUM ; for ( int i = _ NUM ; i < n ; i ++ ) { nval += ( x [ i ] - mx ) * ( y [ i ] - my ) ; } double r = nval / ( ( n - _ NUM ) * sx * sy ) ; return r ; } else throw new  Illegal Argument Exception ( _ STR ) ; }
public <  K ,  V > void produce (  String producer Name , int message Count ,  Serializer <  K > key Serializer ,  Serializer <  V > value Serializer ,  Runnable completion Callback ,  Supplier <  Producer Record <  K ,  V > > message Supplier ) {  Properties props = get Producer Properties ( producer Name ) ;  Thread t = new  Thread ( null ) ; t . set Name ( producer Name + _ STR ) ; t . start ( ) ; }
@  Override public double distance (  Instance first ,  Instance second ,  Performance Stats stats ) { return  Math . pow ( distance ( first , second ,  Double .  POSITIVE_ INFINITY , stats ) , _ NUM / m_ Order ) ; }
public  Set <  Statement > find Transitive Property (  Resource subj ,  URI prop ,  Value obj ,  Resource ... contxts ) throws  Inference Engine Exception { if ( transitive Property Set . contains ( prop ) ) {  Set <  Statement > sts = new  Hash Set ( ) ; boolean go Up = subj == null ; chain Transitive Property ( subj , prop , obj , ( go Up ) ? ( obj ) : ( subj ) , sts , go Up , contxts ) ; return sts ; } else return null ; }
protected static void remove All Triggers (  Connection conn ,  String prefix ) throws  SQLException {  Statement stat = conn . create Statement ( ) ;  Result Set rs = stat . execute Query ( _ STR ) ;  Statement stat2 = conn . create Statement ( ) ; while ( rs . next ( ) ) {  String schema = rs . get String ( _ STR ) ;  String name = rs . get String ( _ STR ) ; if ( name . starts With ( prefix ) ) { name =  String Utils . quote Identifier ( schema ) + _ STR +  String Utils . quote Identifier ( name ) ; stat2 . execute ( _ STR + name ) ; } } }
private void copy Members (  Date Format Symbols src ,  Date Format Symbols dst ) { dst . locale = src . locale ; dst . eras =  Arrays . copy Of ( src . eras , src . eras . length ) ; dst . months =  Arrays . copy Of ( src . months , src . months . length ) ; dst . short Months =  Arrays . copy Of ( src . short Months , src . short Months . length ) ; dst . weekdays =  Arrays . copy Of ( src . weekdays , src . weekdays . length ) ; dst . short Weekdays =  Arrays . copy Of ( src . short Weekdays , src . short Weekdays . length ) ; dst . ampms =  Arrays . copy Of ( src . ampms , src . ampms . length ) ; if ( src . zone Strings != null ) { dst . zone Strings = src . get Zone Strings Impl ( _ BOOL ) ; } else { dst . zone Strings = null ; } dst . local Pattern Chars = src . local Pattern Chars ; dst . cached Hash Code = _ NUM ; }
public static double log10 ( double x ) { return  Math . log ( x ) /  LOG10 ; }
public static  String shard Name From DBName (  String db Name ) {  String [ ] tokens = db Name . split ( _ STR ) ; return tokens [ _ NUM ] ; }
public  String  Use This Var (  String id ,  String context ) {  Sym Tab Entry se = null ; int i =  Find Sym ( id , context ) ; if ( i == symtab . size ( ) ) return id ; se = (  Sym Tab Entry ) symtab . element At ( i ) ; if ( se . type ==  GLOBAL || se . type ==  PROCESSVAR || se . type ==  PROCEDUREVAR || se . type ==  PARAMETER ) return se . use This ; i =  Find Sym ( id , _ STR ) ; if ( se . type ==  GLOBAL ) return se . use This ; return id ; }
private float x (  Touch State s ) { final float curr To Tan = ( float )  Math . sqrt ( ( s . distance * s . distance ) - ( m Scaled Touch Slop * m Scaled Touch Slop ) ) ; return curr To Tan * ( curr To Tan / s . distance ) ; }
private byte [ ] uint8_4 From Data ( int offset ) { return  Arrays . copy Of Range ( data ( ) , offset , offset + _ NUM ) ; }
protected static  Pair <  String ,  String > lsl Register ( final long offset , final  ITranslation Environment environment , final  List <  Reil Instruction > instructions , final  String register Node Value1 , final  String register Node Value2 ) { final  String shifter Operand = environment . get Next Variable String ( ) ; final  String shifter Carry Out = environment . get Next Variable String ( ) ; long base Offset = offset ; final  String tmp Var1 = environment . get Next Variable String ( ) ; final  String tmp Var2 = environment . get Next Variable String ( ) ; final  String tmp Var3 = environment . get Next Variable String ( ) ; final  String tmp Var4 = environment . get Next Variable String ( ) ; final  String tmp Var5 = environment . get Next Variable String ( ) ; final  String tmp Var6 = environment . get Next Variable String ( ) ; final  String tmp Var7 = environment . get Next Variable String ( ) ; final  String is Zero Condition = environment . get Next Variable String ( ) ; final  String shifter Carry Out Tmp1 = environment . get Next Variable String ( ) ; final  String shifter Carry Out Tmp2 = environment . get Next Variable String ( ) ; final  String shifter Carry Out Tmp3 = environment . get Next Variable String ( ) ; final  String shifter Carry Out Tmp4 = environment . get Next Variable String ( ) ; instructions . add (  Reil Helpers . create And ( base Offset ++ , d Word Size , register Node Value2 , d Word Size ,  String . value Of ( _ NUM ) , d Word Size , tmp Var1 ) ) ; instructions . add (  Reil Helpers . create Bsh ( base Offset ++ , d Word Size , register Node Value1 , d Word Size , tmp Var1 , q Word Size , tmp Var2 ) ) ; instructions . add (  Reil Helpers . create And ( base Offset ++ , q Word Size , tmp Var2 , d Word Size , bit Mask All Bits Set , d Word Size , shifter Operand ) ) ; instructions . add (  Reil Helpers . create Bisz ( base Offset ++ , d Word Size , tmp Var1 , byte Size , is Zero Condition ) ) ; instructions . add (  Reil Helpers . create And ( base Offset ++ , byte Size , is Zero Condition , byte Size , _ STR , byte Size , shifter Carry Out Tmp1 ) ) ; instructions . add (  Reil Helpers . create Xor ( base Offset ++ , d Word Size , tmp Var1 , word Size ,  String . value Of ( _ NUM ) , d Word Size , tmp Var3 ) ) ; instructions . add (  Reil Helpers . create Bisz ( base Offset ++ , d Word Size , tmp Var3 , byte Size , is Zero Condition ) ) ; instructions . add (  Reil Helpers . create And ( base Offset ++ , d Word Size , register Node Value1 , d Word Size , one Set , byte Size , tmp Var4 ) ) ; instructions . add (  Reil Helpers . create And ( base Offset ++ , byte Size , is Zero Condition , byte Size , tmp Var4 , byte Size , shifter Carry Out Tmp2 ) ) ; instructions . add (  Reil Helpers . create And ( base Offset ++ , d Word Size , tmp Var1 , d Word Size , not Thirty One Set , d Word Size , tmp Var5 ) ) ; instructions . add (  Reil Helpers . create Bisz ( base Offset ++ , d Word Size , tmp Var5 , byte Size , is Zero Condition ) ) ; instructions . add (  Reil Helpers . create Sub ( base Offset ++ , d Word Size ,  String . value Of ( _ NUM ) , d Word Size , tmp Var1 , d Word Size , tmp Var6 ) ) ; instructions . add (  Reil Helpers . create Bsh ( base Offset ++ , d Word Size , register Node Value1 , d Word Size , _ STR + tmp Var6 , byte Size , tmp Var7 ) ) ; instructions . add (  Reil Helpers . create And ( base Offset ++ , byte Size , is Zero Condition , byte Size , tmp Var7 , byte Size , shifter Carry Out Tmp3 ) ) ; instructions . add (  Reil Helpers . create Or ( base Offset ++ , byte Size , shifter Carry Out Tmp1 , byte Size , shifter Carry Out Tmp2 , byte Size , shifter Carry Out Tmp4 ) ) ; instructions . add (  Reil Helpers . create Or ( base Offset ++ , byte Size , shifter Carry Out Tmp3 , byte Size , shifter Carry Out Tmp4 , byte Size , shifter Carry Out ) ) ; return new  Pair <  String ,  String > ( shifter Operand , shifter Carry Out ) ; }
public static boolean is On (  String option ) { if ( args == null ) { return _ BOOL ; } else { int n = _ NUM ; option = option . to Lower Case (  Locale .  ENGLISH ) ; if ( args . index Of ( _ STR ) != - _ NUM ) { return _ BOOL ; } else if ( ( n = args . index Of ( _ STR ) ) != - _ NUM ) { if ( args . index Of ( _ STR , n ) == - _ NUM ) { if ( ! ( option . equals ( _ STR ) || option . equals ( _ STR ) || option . equals ( _ STR ) ) ) { return _ BOOL ; } } } return ( args . index Of ( option ) != - _ NUM ) ; } }
@  Override public  String generate Label (  Category Dataset dataset , int series ) {  Param Checks . null Not Permitted ( dataset , _ STR ) ;  String label =  Message Format . format ( this . format Pattern , create Item Array ( dataset , series ) ) ; return label ; }
private static  String canonize Tree String (  String str ) {  String canon = str . trim ( ) ;  Pattern pattern =  Pattern . compile ( _ STR ) ;  Matcher matcher = pattern . matcher ( canon ) ; while ( matcher . find ( ) ) { canon = matcher . replace First ( matcher . group ( _ NUM ) ) ; matcher . reset ( canon ) ; } return canon . trim ( ) ; }
public  Dimension preferred Layout Size (  Container target ) { synchronized ( target . get Tree Lock ( ) ) {  Dimension dim = new  Dimension ( _ NUM , _ NUM ) ; if ( ( chart != null ) && chart . is Visible ( ) ) {  Dimension d = chart . get Preferred Size ( ) ; dim . width = d . width ; dim . height = d . height ; } if ( ( x Label != null ) && x Label . is Visible ( ) ) {  Dimension d = x Label . get Preferred Size ( ) ; dim . width =  Math . max ( d . width , dim . width ) ; dim . height += d . height + vgap ; } if ( ( y Label != null ) && y Label . is Visible ( ) ) {  Dimension d = y Label . get Preferred Size ( ) ; dim . width += d . width + hgap ; dim . height =  Math . max ( d . height , dim . height ) ; } if ( ( title != null ) && title . is Visible ( ) ) {  Dimension d = title . get Preferred Size ( ) ; dim . width =  Math . max ( d . width , dim . width ) ; dim . height += d . height + vgap ; }  Insets insets = target . get Insets ( ) ; dim . width += insets . left + insets . right ; dim . height += insets . top + insets . bottom ; return dim ; } }
private  String make Getter Method Name (  Field field ) {  String getter Method Prefix ;  String field Name = field . get Name ( ) ; if ( is Primitive Boolean Type ( field ) ) { if ( field Name . matches ( _ STR ) ) { field Name = field Name . substring ( _ NUM ) ; } getter Method Prefix = _ STR ; } else { getter Method Prefix = _ STR ; } if ( field Name . matches ( _ STR ) ) { return getter Method Prefix + field Name ; } else { return getter Method Prefix +  Base Utility . capitalize ( field Name ) ; } }
public  Year (  Date time ,  Time Zone zone ) { this ( time , zone ,  Locale . get Default ( ) ) ; }
public  Rrd Graph Def ( ) { set Time Span (  Util . get Timestamps (  DEFAULT_ START ,  DEFAULT_ END ) ) ; }
default  B with Default (  String key , long value ) { return with Default ( key ,  Long . to String ( value ) ) ; }
public static  String read String ( final  JSONArray json Array , final int index , final boolean required , final boolean not Null ) throws  JSONException { if ( required ) { return json Array . get String ( index ) ; } if ( not Null && json Array . is Null ( index ) ) { throw new  JSONException (  String . format (  Locale .  US ,  NULL_ VALUE_ FORMAT_ ARRAY , index ) ) ; }  String value = null ; if ( ! json Array . is Null ( index ) ) { value = json Array . get String ( index ) ; } return value ; }
private void throw Ex Int Param (  Method Visitor mv ,  Class < ? > ex Cls ) {  String ex Sig =  Type . get Internal Name ( ex Cls ) ; mv . visit Type Insn (  NEW , ex Sig ) ; mv . visit Insn (  DUP ) ; mv . visit Ldc Insn ( _ STR + this . class Name + _ STR ) ; mv . visit Var Insn (  ILOAD , _ NUM ) ; mv . visit Method Insn (  INVOKESTATIC , _ STR , _ STR , _ STR ) ; mv . visit Method Insn (  INVOKEVIRTUAL , _ STR , _ STR , _ STR ) ; mv . visit Method Insn (  INVOKESPECIAL , ex Sig , _ STR , _ STR ) ; mv . visit Insn (  ATHROW ) ; }
public static  File write Data To File ( final byte [ ] data , final  File file , final boolean append ) { try (  File Output Stream out = new  File Output Stream ( file , append ) ) { out . write ( data ) ; out . close ( ) ; return file ; } catch (  Exception e ) {  JKException Util . handle ( e ) ; return null ; } }
public static void main (  String [ ] args ) {  Main m = new  Main ( ) ; int ret = m . run ( args ) ; if ( ( ret != _ NUM ) || ( cmd Line Test Flag ) )  System . exit ( ret ) ; }
boolean await Exchange (  E e , int start ) { for ( int step = _ NUM , total Spins = _ NUM ; ( step <  ARENA_ LENGTH ) && ( total Spins <  SPINS ) ; step ++ ) { int index = ( start + step ) &  ARENA_ MASK ;  Atomic Reference <  Object > slot = arena [ index ] ;  Object found = slot . get ( ) ; if ( ( found ==  WAITER ) && slot . compare And Set (  WAITER , e ) ) { return _ BOOL ; } else if ( ( found ==  FREE ) && slot . compare And Set (  FREE , e ) ) { int slot Spins = _ NUM ; for ( ; ; ) { found = slot . get ( ) ; if ( found != e ) { return _ BOOL ; } else if ( ( slot Spins >=  SPINS_ PER_ STEP ) && ( slot . compare And Set ( e ,  FREE ) ) ) { total Spins += slot Spins ; break ; } slot Spins ++ ; } } } return _ BOOL ; }
protected  Array List <  Array List <  DBIDs > > build Ranges (  Relation <  V > relation ) { final int dim =  Relation Util . dimensionality ( relation ) ; final int size = relation . size ( ) ; final  Array List <  Array List <  DBIDs > > ranges = new  Array List < > ( ) ;  Array Modifiable DBIDs ids =  DBIDUtil . new Array ( relation . get DBIDs ( ) ) ;  Sort DBIDs By Single Dimension sorter = new  Sort DBIDs By Single Dimension ( relation ) ; final double part = size * _ NUM / phi ; for ( int d = _ NUM ; d < dim ; d ++ ) { sorter . set Dimension ( d ) ; ids . sort ( sorter ) ;  Array List <  DBIDs > dimranges = new  Array List < > ( phi + _ NUM ) ; int start = _ NUM ;  DBIDArray Iter iter = ids . iter ( ) ; for ( int r = _ NUM ; r <= phi ; r ++ ) { int end = ( r < phi ) ? ( int ) ( part * r ) : size ;  Array Modifiable DBIDs currange =  DBIDUtil . new Array ( end - start ) ; for ( iter . seek ( start ) ; iter . get Offset ( ) < end ; iter . advance ( ) ) { currange . add ( iter ) ; } start = end ; dimranges . add ( currange ) ; } ranges . add ( dimranges ) ; } return ranges ; }
public static int find Next New Line Char (  Char Sequence s , int start ) { for ( int i = start ; i < s . length ( ) ; i ++ ) { if ( s . char At ( i ) == _ STR ) { return i ; } } return - _ NUM ; }
protected void assert Func Equals ( final  String ... inputs ) throws  Exception {  Solr Query Request req = req ( ) ; try { assert Func Equals ( req , inputs ) ; } finally { req . close ( ) ; } }
private void create Matrices ( ) { final int w = ( int ) ( current_image . get Width ( ) / scaling ) ; final int h = ( int ) ( current_image . get Height ( ) / scaling ) ;  Trm = new float [ _ NUM ] [ _ NUM ] ;  Trm [ _ NUM ] [ _ NUM ] = (  CTM [ _ NUM ] [ _ NUM ] / w ) ;  Trm [ _ NUM ] [ _ NUM ] = (  CTM [ _ NUM ] [ _ NUM ] / w ) ;  Trm [ _ NUM ] [ _ NUM ] = _ NUM ;  Trm [ _ NUM ] [ _ NUM ] = (  CTM [ _ NUM ] [ _ NUM ] / h ) ;  Trm [ _ NUM ] [ _ NUM ] = (  CTM [ _ NUM ] [ _ NUM ] / h ) ;  Trm [ _ NUM ] [ _ NUM ] = _ NUM ;  Trm [ _ NUM ] [ _ NUM ] =  CTM [ _ NUM ] [ _ NUM ] ;  Trm [ _ NUM ] [ _ NUM ] =  CTM [ _ NUM ] [ _ NUM ] ;  Trm [ _ NUM ] [ _ NUM ] = _ NUM ; for ( int y = _ NUM ; y < _ NUM ; y ++ ) { for ( int x = _ NUM ; x < _ NUM ; x ++ ) { if ( (  Trm [ x ] [ y ] > _ NUM ) & (  Trm [ x ] [ y ] < _ NUM ) ) {  Trm [ x ] [ y ] = _ NUM ; } } }  Trm1 = new float [ _ NUM ] [ _ NUM ] ;  Trm2 = new float [ _ NUM ] [ _ NUM ] ; float x1 , x2 , y1 , y2 ; x1 =  CTM [ _ NUM ] [ _ NUM ] ; if ( x1 < _ NUM ) { x1 = - x1 ; } x2 =  CTM [ _ NUM ] [ _ NUM ] ; if ( x2 < _ NUM ) { x2 = - x2 ; } y1 =  CTM [ _ NUM ] [ _ NUM ] ; if ( y1 < _ NUM ) { y1 = - y1 ; } y2 =  CTM [ _ NUM ] [ _ NUM ] ; if ( y2 < _ NUM ) { y2 = - y2 ; } if (  CTM [ _ NUM ] [ _ NUM ] == _ NUM ||  CTM [ _ NUM ] [ _ NUM ] == _ NUM ) {  Trm1 =  Trm ; } else if ( (  CTM [ _ NUM ] [ _ NUM ] == _ NUM ) && (  CTM [ _ NUM ] [ _ NUM ] == _ NUM ) ) {  Trm1 [ _ NUM ] [ _ NUM ] = w / (  CTM [ _ NUM ] [ _ NUM ] ) ;  Trm1 [ _ NUM ] [ _ NUM ] = _ NUM ;  Trm1 [ _ NUM ] [ _ NUM ] = _ NUM ;  Trm1 [ _ NUM ] [ _ NUM ] = _ NUM ;  Trm1 [ _ NUM ] [ _ NUM ] = h / (  CTM [ _ NUM ] [ _ NUM ] ) ;  Trm1 [ _ NUM ] [ _ NUM ] = _ NUM ;  Trm1 [ _ NUM ] [ _ NUM ] = _ NUM ;  Trm1 [ _ NUM ] [ _ NUM ] = _ NUM ;  Trm1 [ _ NUM ] [ _ NUM ] = _ NUM ;  Trm1 =  Matrix . multiply (  Trm ,  Trm1 ) ; for ( int y = _ NUM ; y < _ NUM ; y ++ ) { for ( int x = _ NUM ; x < _ NUM ; x ++ ) { if ( (  Trm1 [ x ] [ y ] > _ NUM ) & (  Trm1 [ x ] [ y ] < _ NUM ) ) {  Trm1 [ x ] [ y ] = _ NUM ; } } } if (  Trm1 [ _ NUM ] [ _ NUM ] < _ NUM &&  Trm1 [ _ NUM ] [ _ NUM ] > _ NUM &&  CTM [ _ NUM ] [ _ NUM ] < _ NUM ) {  Trm1 [ _ NUM ] [ _ NUM ] = _ NUM ;  Trm1 [ _ NUM ] [ _ NUM ] = - _ NUM ; } if (  Trm1 [ _ NUM ] [ _ NUM ] < _ NUM &&  Trm1 [ _ NUM ] [ _ NUM ] > _ NUM &&  CTM [ _ NUM ] [ _ NUM ] < _ NUM &&  CTM [ _ NUM ] [ _ NUM ] < _ NUM ) {  Trm1 [ _ NUM ] [ _ NUM ] = _ NUM ;  Trm1 [ _ NUM ] [ _ NUM ] = - _ NUM ; } } else { if ( x1 > x2 ) {  Trm1 [ _ NUM ] [ _ NUM ] = w / (  CTM [ _ NUM ] [ _ NUM ] ) ; } else {  Trm1 [ _ NUM ] [ _ NUM ] = w / (  CTM [ _ NUM ] [ _ NUM ] ) ; } if (  Trm1 [ _ NUM ] [ _ NUM ] < _ NUM ) {  Trm1 [ _ NUM ] [ _ NUM ] = -  Trm1 [ _ NUM ] [ _ NUM ] ; }  Trm1 [ _ NUM ] [ _ NUM ] = _ NUM ;  Trm1 [ _ NUM ] [ _ NUM ] = _ NUM ;  Trm1 [ _ NUM ] [ _ NUM ] = _ NUM ; if ( y1 > y2 ) {  Trm1 [ _ NUM ] [ _ NUM ] = h / (  CTM [ _ NUM ] [ _ NUM ] ) ; } else {  Trm1 [ _ NUM ] [ _ NUM ] = h / (  CTM [ _ NUM ] [ _ NUM ] ) ; } if (  Trm1 [ _ NUM ] [ _ NUM ] < _ NUM ) {  Trm1 [ _ NUM ] [ _ NUM ] = -  Trm1 [ _ NUM ] [ _ NUM ] ; }  Trm1 [ _ NUM ] [ _ NUM ] = _ NUM ;  Trm1 [ _ NUM ] [ _ NUM ] = _ NUM ;  Trm1 [ _ NUM ] [ _ NUM ] = _ NUM ;  Trm1 [ _ NUM ] [ _ NUM ] = _ NUM ;  Trm1 =  Matrix . multiply (  Trm ,  Trm1 ) ; for ( int y = _ NUM ; y < _ NUM ; y ++ ) { for ( int x = _ NUM ; x < _ NUM ; x ++ ) { if ( (  Trm1 [ x ] [ y ] > _ NUM ) & (  Trm1 [ x ] [ y ] < _ NUM ) ) {  Trm1 [ x ] [ y ] = _ NUM ; } } } } if ( x1 > x2 ) {  Trm2 [ _ NUM ] [ _ NUM ] = (  CTM [ _ NUM ] [ _ NUM ] / w ) ; } else {  Trm2 [ _ NUM ] [ _ NUM ] = (  CTM [ _ NUM ] [ _ NUM ] / w ) ; } if (  Trm2 [ _ NUM ] [ _ NUM ] < _ NUM ) {  Trm2 [ _ NUM ] [ _ NUM ] = -  Trm2 [ _ NUM ] [ _ NUM ] ; }  Trm2 [ _ NUM ] [ _ NUM ] = _ NUM ;  Trm2 [ _ NUM ] [ _ NUM ] = _ NUM ;  Trm2 [ _ NUM ] [ _ NUM ] = _ NUM ; if ( y1 > y2 ) {  Trm2 [ _ NUM ] [ _ NUM ] = (  CTM [ _ NUM ] [ _ NUM ] / h ) ; } else {  Trm2 [ _ NUM ] [ _ NUM ] = (  CTM [ _ NUM ] [ _ NUM ] / h ) ; } if (  Trm2 [ _ NUM ] [ _ NUM ] < _ NUM ) {  Trm2 [ _ NUM ] [ _ NUM ] = -  Trm2 [ _ NUM ] [ _ NUM ] ; }  Trm2 [ _ NUM ] [ _ NUM ] = _ NUM ;  Trm2 [ _ NUM ] [ _ NUM ] = _ NUM ;  Trm2 [ _ NUM ] [ _ NUM ] = _ NUM ;  Trm2 [ _ NUM ] [ _ NUM ] = _ NUM ; for ( int y = _ NUM ; y < _ NUM ; y ++ ) { for ( int x = _ NUM ; x < _ NUM ; x ++ ) { if ( (  Trm2 [ x ] [ y ] > _ NUM ) & (  Trm2 [ x ] [ y ] < _ NUM ) ) {  Trm2 [ x ] [ y ] = _ NUM ; } } } }
public void render (  Writer w ) throws  IOException { { final  String summary = _ STR + t . units ; w . write ( _ STR + attrib ( summary ) + _ STR ) ; } { w . write ( _ STR ) ; w . write ( _ STR ) ; w . write ( _ STR + _ STR + cdata ( formatter . date ( t . first Timestamp ) ) + _ STR ) ; w . write ( _ STR + _ STR + cdata ( formatter . date ( t . last Timestamp ) ) + _ STR ) ; w . write ( _ STR ) ; w . write ( _ STR ) ; w . write ( _ STR ) ; for (  ICounter counter : t . a ) { w . write ( _ STR ) ; formatter . write Full Path ( w , counter . get Path ( ) ) ; w . write ( _ STR ) ; } w . write ( _ STR ) ; w . write ( _ STR ) ; w . write ( _ STR ) ; for (  ICounter counter : t . a ) { final  String [ ] groups =  Query Util . get Captured Groups ( pattern , counter ) ; final  String label ; if ( groups != null ) { final  String Builder sb = new  String Builder ( ) ; for ( int i = _ NUM ; i < groups . length ; i ++ ) { final  String s = groups [ i ] ; if ( i > _ NUM ) sb . append ( _ STR ) ; sb . append ( s ) ; } label = sb . to String ( ) ; } else { label = counter . get Name ( ) ; } w . write ( _ STR + cdata ( label ) + _ STR ) ; } w . write ( _ STR ) ; } for ( int row = _ NUM ; row < t . nrows ; row ++ ) { final  String [ ] val Str = new  String [ t . a . length ] ; for ( int col = _ NUM ; col < t . ncols ; col ++ ) { final  ICounter c = t . a [ col ] ; final  IHistory Entry e = t . data [ row ] [ col ] ; val Str [ col ] = formatter . value ( c , e == null ? _ STR : e . get Value ( ) ) ; } final long timestamp = t . get Timestamp ( row ) ; w . write ( _ STR ) ; w . write ( _ STR + cdata ( formatter . date ( timestamp ) ) + _ STR ) ; for (  String s : val Str ) { w . write ( _ STR + s + _ STR ) ; } w . write ( _ STR ) ; } w . write ( _ STR ) ; }
protected int to Julian ( java . util .  Date date ) {  YMD ymd = null ; synchronized ( gc ) { gc . set Time ( date ) ; ymd = new  YMD ( gc . get (  Gregorian Calendar .  YEAR ) , gc . get (  Gregorian Calendar .  MONTH ) + _ NUM , gc . get (  Gregorian Calendar .  DAY_ OF_ MONTH ) ) ; } return ymd . julian ( ) ; }
public synchronized void add (  K obj ) { int len = array . length ; array =  Arrays . copy Of ( array , len + _ NUM ) ; array [ len ] = obj ; }
private boolean serialize Compact RDFAttr Props (  XMPNode parent Node , int indent ) throws  IOException { boolean all Are Attrs = _ BOOL ; for (  Iterator it = parent Node . iterate Children ( ) ; it . has Next ( ) ; ) {  XMPNode prop = (  XMPNode ) it . next ( ) ; if ( can Be RDFAttr Prop ( prop ) ) { write Newline ( ) ; write Indent ( indent ) ; write ( prop . get Name ( ) ) ; write ( _ STR ) ; append Node Value ( prop . get Value ( ) , _ BOOL ) ; write ( _ STR ) ; } else { all Are Attrs = _ BOOL ; } } return all Are Attrs ; }
public default  Utility Table query Util (  BNetwork network ,  String query Var ) { return query Util ( new  Query .  Util Query ( network ,  Arrays . as List ( query Var ) , new  Assignment ( ) ) ) ; }
private int init (  File f ) throws  IOException {  Runtime rt =  Runtime . get Runtime ( ) ; long pre Phrase Table Load Mem Used = rt . total Memory ( ) - rt . free Memory ( ) ; final long start Time =  System . nano Time ( ) ;  Line Number Reader reader =  IOTools . get Reader From File ( f ) ; int num Scores = - _ NUM ; for (  String line ; ( line = reader . read Line ( ) ) != null ; ) {  List <  List <  String > > fields =  String Utils . split Fields Fast ( line ,  Compiled Phrase Table .  FIELD_ DELIM ) ; assert fields . size ( ) == _ NUM :  String . format ( _ STR , reader . get Line Number ( ) , fields . size ( ) ) ;  Sequence <  IString > source =  IStrings . to IString Sequence ( fields . get ( _ NUM ) ) ;  Sequence <  IString > target =  IStrings . to IString Sequence ( fields . get ( _ NUM ) ) ;  String target Constellation =  String Utils . join ( fields . get ( _ NUM ) ) ;  List <  String > score List = fields . get ( _ NUM ) ; if ( num Scores < _ NUM ) { num Scores = score List . size ( ) ; } else if ( num Scores != score List . size ( ) ) { throw new  Runtime Exception (  String . format ( _ STR + _ STR , reader . get Line Number ( ) , num Scores , score List . size ( ) ) ) ; } float [ ] scores ; try { scores =  IOTools . string List To Numeric ( score List ) ; } catch (  Number Format Exception e ) { e . print Stack Trace ( ) ; throw new  Runtime Exception (  String . format ( _ STR , reader . get Line Number ( ) ) ) ; } if ( target Constellation . equals ( _ STR ) ) { add Entry ( source , target , null , scores ) ; } else { add Entry ( source , target ,  Phrase Alignment . get Phrase Alignment ( target Constellation ) , scores ) ; } if ( source . size ( ) > longest Source Phrase ) { longest Source Phrase = source . size ( ) ; } if ( target . size ( ) > longest Target Phrase ) { longest Target Phrase = target . size ( ) ; } } reader . close ( ) ; long post Phrase Table Load Mem Used = rt . total Memory ( ) - rt . free Memory ( ) ; double elapsed Time = ( ( double )  System . nano Time ( ) - start Time ) / _ NUM ;  System . err . printf ( _ STR , f . get Absolute Path ( ) , ( post Phrase Table Load Mem Used - pre Phrase Table Load Mem Used ) / ( _ NUM * _ NUM ) , elapsed Time ) ;  System . err . println ( _ STR + longest Source Phrase ) ; return num Scores ; }
@  Override public void previous ( ) { current Image =  Optional . of ( add Index And Get Image By Offset ( - _ NUM ) ) ; event Bus . post ( new  Source Has Pending Update Event ( this ) ) ; }
public static  NBT_ Tag make (  Input Stream is ) throws  Exception {  NBT_ Tag ret = null ;  Data Input Stream stream = new  Data Input Stream ( is ) ; byte t = stream . read Byte ( ) ; int type = ( int ) t ;  String name = _ STR ; if ( type > _ NUM ) name = stream . read UTF ( ) ; switch ( type ) { case _ NUM : ret = new  TAG_ End ( name ) ; break ; case _ NUM : ret = new  TAG_ Byte ( name ) ; break ; case _ NUM : ret = new  TAG_ Short ( name ) ; break ; case _ NUM : ret = new  TAG_ Int ( name ) ; break ; case _ NUM : ret = new  TAG_ Long ( name ) ; break ; case _ NUM : ret = new  TAG_ Float ( name ) ; break ; case _ NUM : ret = new  TAG_ Double ( name ) ; break ; case _ NUM : ret = new  TAG_ Byte_ Array ( name ) ; break ; case _ NUM : ret = new  TAG_ String ( name ) ; break ; case _ NUM : ret = new  TAG_ List ( name ) ; break ; case _ NUM : ret = new  TAG_ Compound ( name ) ; break ; case _ NUM : ret = new  TAG_ Int_ Array ( name ) ; break ; default : throw ( new  Exception ( _ STR + type ) ) ; } ret . parse ( stream ) ; return ret ; }
static public  List <  Range > compact Ranges (  List <  Range > ranges ) {  List <  Range > new Ranges = new  Linked List < > ( ) ; if ( ranges . is Empty ( ) ) { return new Ranges ; }  Collections . sort ( ranges ) ;  Range prev Range = new  Range ( ranges . get ( _ NUM ) . start Index , ranges . get ( _ NUM ) . end Index ) ; for ( int i = _ NUM ; i < ranges . size ( ) ; i ++ ) {  Range current Range = ranges . get ( i ) ; if ( current Range . start Index == prev Range . end Index + _ NUM ) { prev Range . end Index = current Range . end Index ; } else { new Ranges . add ( prev Range ) ; prev Range = new  Range ( current Range . start Index , current Range . end Index ) ; } } new Ranges . add ( prev Range ) ; return new Ranges ; }
public void write Int ( int value ) throws  IOException { check Write Primitive Types ( ) ; primitive Types . write Int ( value ) ; }
private static boolean is Empty (  String val ) { return val == null || val . is Empty ( ) ; }
public void on Register Click (  View view ) { if ( view != null ) {  Intent register = new  Intent (  Intent .  ACTION_ VIEW ,  Uri . parse ( get String (  R . string . welcome_link_url ) ) ) ; set Result (  RESULT_ CANCELED ) ; start Activity ( register ) ; } }
public  Email subject (  String subject ) { if ( subject == null ) throw new  Illegal Argument Exception ( _ STR ) ; this . subject = subject ; return this ; }
public static  String trim Name (  String line ) { int idx = line . index Of ( _ STR ) ; if ( idx != - _ NUM ) { line = line . substring ( _ NUM , idx ) ; } line = trim Line ( line ) ; idx = line . index Of ( _ STR ) ; if ( idx == - _ NUM ) { idx = line . index Of ( _ STR ) ; } if ( idx != - _ NUM ) { line = line . substring ( _ NUM , idx ) ; } return line . trim ( ) ; }
public double distance ( double p1 , double p2 ) { double d = ( p1 - p2 ) * ( p1 - p2 ) ; return  Math . sqrt ( d ) ; }
public  Optional <  T > first ( ) {  Iterator <  T > iterator = iterator ( ) ; return iterator . has Next ( ) ?  Optional . of ( iterator . next ( ) ) :  Optional . <  T > empty ( ) ; }
private void store Cookies ( ) { lock . lock ( ) ;  Shared Preferences .  Editor editor = spe Preferences . edit ( ) ; editor . put String Set (  COOKIE_ JAR , cookie List To String Set ( cookie Jar ) ) ;  Set <  URI > uris = uri Index . key Set ( ) ; if ( ! uris . is Empty ( ) ) editor . put String Set (  URI_ LIST ,  URITo String Set ( uris ) ) ; for (  URI uri : uris ) { editor . put String Set ( uri . to String ( ) , cookie List To String Set ( uri Index . get ( uri ) ) ) ; }  Set <  String > domains = domain Index . key Set ( ) ; if ( ! domains . is Empty ( ) ) editor . put String Set (  STRING_ LIST , domains ) ; for (  String domain : domains ) { editor . put String Set ( domain , cookie List To String Set ( domain Index . get ( domain ) ) ) ; } editor . apply ( ) ; lock . unlock ( ) ; }
public static int identify Regions ( char [ ] [ ] img , char off Char ) { for ( int i = _ NUM ; i < img . length ; i ++ ) { for ( int j = _ NUM ; j < img [ _ NUM ] . length ; j ++ ) { if ( img [ i ] [ j ] != off Char ) { img [ i ] [ j ] =  ON ; } } } char next =  First Region ;  IConvex Hull alg = new  Convex Hull Scan ( ) ; while ( _ BOOL ) {  IPoint p = locate ( img ) ; if ( p == null ) return ( next -  First Region ) ;  Collection <  IPoint > points = new  Linked List <  IPoint > ( ) ; points . add ( p ) ; spread ( img , ( int ) p . get X ( ) , ( int ) p . get Y ( ) , points , next ) ;  IPoint [ ] raw = points . to Array ( new  Two DPoint [ ] { } ) ;  IPoint [ ] hull = alg . compute ( raw ) ; for (  IPoint h : hull ) { img [ ( int ) h . get X ( ) ] [ ( int ) h . get Y ( ) ] =  HULL ; } next ++ ; } }
protected  Abstract Skeleton (  Class api Class ) { _api Class = api Class ;  Method [ ] method List = api Class . get Methods ( ) ; for ( int i = _ NUM ; i < method List . length ; i ++ ) {  Method method = method List [ i ] ; if ( _method Map . get ( method . get Name ( ) ) == null ) _method Map . put ( method . get Name ( ) , method List [ i ] ) ;  Class [ ] param = method . get Parameter Types ( ) ;  String mangled Name = method . get Name ( ) + _ STR + param . length ; _method Map . put ( mangled Name , method List [ i ] ) ; _method Map . put ( mangle Name ( method , _ BOOL ) , method List [ i ] ) ; } }
public long start_brk ( ) { return  Long . parse Long ( fields [ _ NUM ] ) ; }
public final  Json Serializer < ? > find Serializer By Lookup (  Java Type type ,  Serialization Config config ,  Basic Bean Description bean Desc ,  Bean Property property , boolean static Typing ) {  Class < ? > raw = type . get Raw Class ( ) ;  String cls Name = raw . get Name ( ) ;  Json Serializer < ? > ser = _concrete . get ( cls Name ) ; if ( ser != null ) { return ser ; }  Class < ? extends  Json Serializer < ? > > ser Class = _concrete Lazy . get ( cls Name ) ; if ( ser Class != null ) { try { return ser Class . new Instance ( ) ; } catch (  Exception e ) { throw new  Illegal State Exception ( _ STR + ser Class . get Name ( ) + _ STR + e . get Message ( ) , e ) ; } } return null ; }
public static void save As XML (  NSObject root ,  Output Stream out ) throws  IOException {  Output Stream Writer w = new  Output Stream Writer ( out , _ STR ) ; w . write ( root . to XMLProperty List ( ) ) ; w . close ( ) ; }
public boolean bound Scroll Raw ( ) { float cur Scroll = get Stack Scroll ( ) ; float new Scroll = get Bounded Stack Scroll ( cur Scroll ) ; if (  Float . compare ( new Scroll , cur Scroll ) != _ NUM ) { set Stack Scroll Raw ( new Scroll ) ; return _ BOOL ; } return _ BOOL ; }
public  Service Call <  Input Stream > synthesize ( final  String text , final  Voice voice ) { return synthesize ( text , voice , null ) ; }
public void append ( int key , float value ) { if ( m Size != _ NUM && key <= m Keys [ m Size - _ NUM ] ) { put ( key , value ) ; return ; } int pos = m Size ; if ( pos >= m Keys . length ) { int n =  Array Utils . ideal Int Array Size ( pos + _ NUM ) ; int [ ] nkeys = new int [ n ] ; float [ ] nvalues = new float [ n ] ;  System . arraycopy ( m Keys , _ NUM , nkeys , _ NUM , m Keys . length ) ;  System . arraycopy ( m Values , _ NUM , nvalues , _ NUM , m Values . length ) ; m Keys = nkeys ; m Values = nvalues ; } m Keys [ pos ] = key ; m Values [ pos ] = value ; m Size = pos + _ NUM ; }
public synchronized void add Image Listener (  Image Listener cl ) { m_image Listeners . add ( cl ) ; }
public final float read Float ( ) throws java . io .  IOException { return  Float . int Bits To Float ( read Int ( ) ) ; }
public static void sync Modification Times (  Configuration conf ,  Path src ,  Path dest ,  Optional <  Path Filter > filter ) throws  IOException {  Set <  File Status > src File Statuses = get File Statuses Recursive ( conf , src , filter ) ;  Map <  String ,  Long > src File Modification Times = null ; try { src File Modification Times = get Relative Path To Modification Time ( src , src File Statuses ) ; } catch (  Argument Exception e ) { throw new  IOException ( _ STR , e ) ; }  File System dest Fs = dest . get File System ( conf ) ; for (  String file : src File Modification Times . key Set ( ) ) { dest Fs . set Times ( new  Path ( dest , file ) , src File Modification Times . get ( file ) , - _ NUM ) ; } }
private void convert Values Impl (  Blackboard bb ,  Sql Call values ,  Rel Data Type target Row Type ) {  Rel Node values Rel = convert Row Values ( bb , values , values . get Operand List ( ) , _ BOOL , target Row Type ) ; if ( values Rel != null ) { bb . set Root ( values Rel , _ BOOL ) ; return ; } final  List <  Rel Node > union Rels = new  Array List < > ( ) ; for (  Sql Node row Constructor1 : values . get Operand List ( ) ) {  Sql Call row Constructor = (  Sql Call ) row Constructor1 ;  Blackboard tmp Bb = create Blackboard ( bb . scope , null , _ BOOL ) ; replace Subqueries ( tmp Bb , row Constructor ,  Rel Opt Util .  Logic .  TRUE_ FALSE_ UNKNOWN ) ; final  List <  Pair <  Rex Node ,  String > > exps = new  Array List < > ( ) ; for (  Ord <  Sql Node > operand :  Ord . zip ( row Constructor . get Operand List ( ) ) ) { exps . add (  Pair . of ( tmp Bb . convert Expression ( operand . e ) , validator . derive Alias ( operand . e , operand . i ) ) ) ; }  Rel Node in = ( null == tmp Bb . root ) ?  Logical Values . create One Row ( cluster ) : tmp Bb . root ; union Rels . add (  Rel Opt Util . create Project ( in ,  Pair . left ( exps ) ,  Pair . right ( exps ) , _ BOOL ) ) ; } if ( union Rels . size ( ) == _ NUM ) { throw  Util . new Internal ( _ STR ) ; } else if ( union Rels . size ( ) == _ NUM ) { bb . set Root ( union Rels . get ( _ NUM ) , _ BOOL ) ; } else { bb . set Root (  Logical Union . create ( union Rels , _ BOOL ) , _ BOOL ) ; } }
public void zoom To Camera ( float z Offset ) { if ( z Offset > (  Z_ FAR - _ NUM ) ) { z Offset =  Z_ FAR - _ NUM ; logger . info ( _ STR + z Offset ) ; } if ( z Offset < (  ZOOM_ MAX ) ) { z Offset =  ZOOM_ MAX ; logger . info ( _ STR + z Offset ) ; } target Zoff = z Offset ; is Scene Changed = _ BOOL ; }
private void configure Button (  JButton button ) {  Font button Font = (  Font )  Default Lookup . get ( option Pane , this , _ STR ) ; if ( button Font != null ) { button . set Font ( button Font ) ; } }
default  Filterable <  T > retain All ( final  Stream < ? extends  T > stream ) { final  Set <  T > set = stream . collect (  Collectors . to Set ( ) ) ; return filter ( null ) ; }
public void draw Shape ( int x , int y , int w , int h ,  Map <  String ,  Object > style ) {  Color pen Color = mx Utils . get Color ( style , mx Constants .  STYLE_ STROKECOLOR ) ; float pen Width = mx Utils . get Float ( style , mx Constants .  STYLE_ STROKEWIDTH , _ NUM ) ; int pw = ( int )  Math . ceil ( pen Width * scale ) ; if ( g . hit Clip ( x - pw , y - pw , w + _ NUM * pw , h + _ NUM * pw ) ) { boolean shadow = mx Utils . is True ( style , mx Constants .  STYLE_ SHADOW , _ BOOL ) ;  Color fill Color = mx Utils . get Style Fill Color ( style ) ;  Paint fill Paint = get Fill Paint ( new  Rectangle ( x , y , w , h ) , fill Color , style ) ; if ( pen Width > _ NUM ) { set Stroke ( pen Width , style ) ; }  String shape = mx Utils . get String ( style , mx Constants .  STYLE_ SHAPE , _ STR ) ; if ( shape . equals ( mx Constants .  SHAPE_ IMAGE ) ) {  String img = get Image For Style ( style ) ; if ( img != null ) { draw Image ( x , y , w , h , img ) ; } } else if ( shape . equals ( mx Constants .  SHAPE_ LINE ) ) { if ( pen Color != null ) { g . set Color ( pen Color ) ;  String direction = mx Utils . get String ( style , mx Constants .  STYLE_ DIRECTION , mx Constants .  DIRECTION_ EAST ) ; if ( direction . equals ( mx Constants .  DIRECTION_ EAST ) || direction . equals ( mx Constants .  DIRECTION_ WEST ) ) { int mid = ( int ) ( y + h / _ NUM ) ; draw Line ( x , mid , x + w , mid ) ; } else { int mid = ( int ) ( x + w / _ NUM ) ; draw Line ( mid , y , mid , y + h ) ; } } } else if ( shape . equals ( mx Constants .  SHAPE_ ELLIPSE ) ) { draw Oval ( x , y , w , h , fill Color , fill Paint , pen Color , shadow ) ; } else if ( shape . equals ( mx Constants .  SHAPE_ DOUBLE_ ELLIPSE ) ) { draw Oval ( x , y , w , h , fill Color , fill Paint , pen Color , shadow ) ; int inset = ( int ) ( ( _ NUM + pen Width ) * scale ) ; x += inset ; y += inset ; w -= _ NUM * inset ; h -= _ NUM * inset ; draw Oval ( x , y , w , h , null , null , pen Color , _ BOOL ) ; } else if ( shape . equals ( mx Constants .  SHAPE_ RHOMBUS ) ) { draw Rhombus ( x , y , w , h , fill Color , fill Paint , pen Color , shadow ) ; } else if ( shape . equals ( mx Constants .  SHAPE_ CYLINDER ) ) { draw Cylinder ( x , y , w , h , fill Color , fill Paint , pen Color , shadow ) ; } else if ( shape . equals ( mx Constants .  SHAPE_ ACTOR ) ) { draw Actor ( x , y , w , h , fill Color , fill Paint , pen Color , shadow ) ; } else if ( shape . equals ( mx Constants .  SHAPE_ CLOUD ) ) { draw Cloud ( x , y , w , h , fill Color , fill Paint , pen Color , shadow ) ; } else if ( shape . equals ( mx Constants .  SHAPE_ TRIANGLE ) ) {  String direction = mx Utils . get String ( style , mx Constants .  STYLE_ DIRECTION , _ STR ) ; draw Triangle ( x , y , w , h , fill Color , fill Paint , pen Color , shadow , direction ) ; } else if ( shape . equals ( mx Constants .  SHAPE_ HEXAGON ) ) {  String direction = mx Utils . get String ( style , mx Constants .  STYLE_ DIRECTION , _ STR ) ; draw Hexagon ( x , y , w , h , fill Color , fill Paint , pen Color , shadow , direction ) ; } else { draw Rect ( x , y , w , h , fill Color , fill Paint , pen Color , shadow , mx Utils . is True ( style , mx Constants .  STYLE_ ROUNDED ) ) ; if ( shape . equals ( mx Constants .  SHAPE_ LABEL ) ) {  String img = get Image For Style ( style ) ; if ( img != null ) {  String img Align = mx Utils . get String ( style , mx Constants .  STYLE_ IMAGE_ ALIGN , mx Constants .  ALIGN_ CENTER ) ;  String img Valign = mx Utils . get String ( style , mx Constants .  STYLE_ IMAGE_ VERTICAL_ ALIGN , mx Constants .  ALIGN_ MIDDLE ) ; int img Width = ( int ) ( mx Utils . get Int ( style , mx Constants .  STYLE_ IMAGE_ WIDTH , mx Constants .  DEFAULT_ IMAGESIZE ) * scale ) ; int img Height = ( int ) ( mx Utils . get Int ( style , mx Constants .  STYLE_ IMAGE_ HEIGHT , mx Constants .  DEFAULT_ IMAGESIZE ) * scale ) ; int spacing = ( int ) ( mx Utils . get Int ( style , mx Constants .  STYLE_ SPACING , _ NUM ) * scale ) ; int img X = x ; if ( img Align . equals ( mx Constants .  ALIGN_ LEFT ) ) { img X += spacing ; } else if ( img Align . equals ( mx Constants .  ALIGN_ RIGHT ) ) { img X += w - img Width - spacing ; } else { img X += ( w - img Width ) / _ NUM ; } int img Y = y ; if ( img Valign . equals ( mx Constants .  ALIGN_ TOP ) ) { img Y += spacing ; } else if ( img Valign . equals ( mx Constants .  ALIGN_ BOTTOM ) ) { img Y += h - img Height - spacing ; } else { img Y += ( h - img Height ) / _ NUM ; } draw Image ( img X , img Y , img Width , img Height , img ) ; } } } } }
public  Rectangle ( double top , double left , double bottom , double right ) { double width =  Math . abs ( right - left ) ; double height =  Math . abs ( bottom - top ) ;  Point center = new  Point ( left + ( width / _ NUM ) , top + ( height / _ NUM ) ) ; set Rect ( new  Rect ( ( int ) ( center . x - ( width / _ NUM ) ) , ( int ) ( center . y - ( height / _ NUM ) ) , ( int ) width , ( int ) height ) ) ; }
public void flush ( ) throws java . io .  IOException { flush Buffer ( ) ; m_os . flush ( ) ; }
private static void quick Sort1 ( double x [ ] , int off , int len ,  Double Comparator comp ) { if ( len <  SMALL ) { for ( int i = off ; i < len + off ; i ++ ) for ( int j = i ; j > off && comp . compare ( x [ j - _ NUM ] , x [ j ] ) > _ NUM ; j -- ) swap ( x , j , j - _ NUM ) ; return ; } int m = off + len / _ NUM ; if ( len >  SMALL ) { int l = off ; int n = off + len - _ NUM ; if ( len >  MEDIUM ) { int s = len / _ NUM ; l = med3 ( x , l , l + s , l + _ NUM * s , comp ) ; m = med3 ( x , m - s , m , m + s , comp ) ; n = med3 ( x , n - _ NUM * s , n - s , n , comp ) ; } m = med3 ( x , l , m , n , comp ) ; } double v = x [ m ] ; int a = off , b = a , c = off + len - _ NUM , d = c ; while ( _ BOOL ) { int comparison ; while ( b <= c && ( comparison = comp . compare ( x [ b ] , v ) ) <= _ NUM ) { if ( comparison == _ NUM ) swap ( x , a ++ , b ) ; b ++ ; } while ( c >= b && ( comparison = comp . compare ( x [ c ] , v ) ) >= _ NUM ) { if ( comparison == _ NUM ) swap ( x , c , d -- ) ; c -- ; } if ( b > c ) break ; swap ( x , b ++ , c -- ) ; } int s , n = off + len ; s =  Math . min ( a - off , b - a ) ; vecswap ( x , off , b - s , s ) ; s =  Math . min ( d - c , n - d - _ NUM ) ; vecswap ( x , b , n - s , s ) ; if ( ( s = b - a ) > _ NUM ) quick Sort1 ( x , off , s , comp ) ; if ( ( s = d - c ) > _ NUM ) quick Sort1 ( x , n - s , s , comp ) ; }
public double border Distance ( double lat , double lon ) { double nsdistance ; double ewdistance ; if ( south <= lat && lat <= north ) { nsdistance = _ NUM ; } else { nsdistance =  Math . min ( (  Math . abs ( lat - north ) ) , (  Math . abs ( lat - south ) ) ) ; } if ( west <= lon && lon <= east ) { ewdistance = _ NUM ; } else { ewdistance =  Math . min ( (  Math . abs ( lon - east ) ) , (  Math . abs ( lon - west ) ) ) ; } return  Math . sqrt (  Math . pow ( nsdistance , _ NUM ) +  Math . pow ( ewdistance , _ NUM ) ) ; }
public void combine (  Stats o ) { max =  Math . max ( max , o . max ) ; min =  Math . min ( min , o . min ) ; m = m * ( n / ( double ) ( n + o . n ) ) + o . m * ( o . n / ( double ) ( n + o . n ) ) ; s =  Double .  Na N ; n += o . n ; }
public boolean put Register Content ( int register Number ,  String content ) { try { registers [ register Number ] =  Double . parse Double ( content ) ; } catch (  Number Format Exception nfe ) { return _ BOOL ; } return _ BOOL ; }
private void add (  Session ID session ID ) { remote Session Set . add ( session ID ) ; }
@  Override public boolean contains (  Object value ) { if ( value == null ) { return _ BOOL ; } final  Iterator it = new  Step Iterator ( this , step Size ) ; while ( it . has Next ( ) ) { if ( compare Equal ( value , it . next ( ) ) ) { return _ BOOL ; } } return _ BOOL ; }
final static  String  HMAC_ MD5 ( byte [ ] key , byte [ ] text ) throws  No Such Algorithm Exception {  Message Digest md5 =  Message Digest . get Instance ( _ STR ) ; if ( key . length >  MD5_ BLOCKSIZE ) { key = md5 . digest ( key ) ; } byte [ ] ipad = new byte [  MD5_ BLOCKSIZE ] ; byte [ ] opad = new byte [  MD5_ BLOCKSIZE ] ; byte [ ] digest ; int i ; for ( i = _ NUM ; i < key . length ; i ++ ) { ipad [ i ] = key [ i ] ; opad [ i ] = key [ i ] ; } for ( i = _ NUM ; i <  MD5_ BLOCKSIZE ; i ++ ) { ipad [ i ] ^= _ NUM ; opad [ i ] ^= _ NUM ; } md5 . update ( ipad ) ; md5 . update ( text ) ; digest = md5 . digest ( ) ; md5 . update ( opad ) ; md5 . update ( digest ) ; digest = md5 . digest ( ) ;  String Buffer digest String = new  String Buffer ( ) ; for ( i = _ NUM ; i < digest . length ; i ++ ) { if ( ( digest [ i ] & _ NUM ) < _ NUM ) { digest String . append ( _ STR +  Integer . to Hex String ( digest [ i ] & _ NUM ) ) ; } else { digest String . append (  Integer . to Hex String ( digest [ i ] & _ NUM ) ) ; } }  Arrays . fill ( ipad , ( byte ) _ NUM ) ;  Arrays . fill ( opad , ( byte ) _ NUM ) ; ipad = null ; opad = null ; return ( digest String . to String ( ) ) ; }
public boolean ends With (  String string ) { if ( string == null ) return _ BOOL ; int strlen = string . length ( ) ; if ( _length < strlen ) return _ BOOL ; char [ ] buffer = _buffer ; int offset = _offset + _length - strlen ; while ( -- strlen >= _ NUM ) { if ( buffer [ offset + strlen ] != string . char At ( strlen ) ) return _ BOOL ; } return _ BOOL ; }
public void write Raw Bytes ( final byte [ ] value , int offset , int length ) throws  IOException { if ( limit - position >= length ) {  System . arraycopy ( value , offset , buffer , position , length ) ; position += length ; total Bytes Written += length ; } else { final int bytes Written = limit - position ;  System . arraycopy ( value , offset , buffer , position , bytes Written ) ; offset += bytes Written ; length -= bytes Written ; position = limit ; total Bytes Written += bytes Written ; refresh Buffer ( ) ; if ( length <= limit ) {  System . arraycopy ( value , offset , buffer , _ NUM , length ) ; position = length ; } else { output . write ( value , offset , length ) ; } total Bytes Written += length ; } }
public boolean is Src Class (  Soot Class clz ) { return is Src Class ( clz . get Name ( ) ) ; }
private boolean line To Speech (  String path ) { boolean ok = _ BOOL ; voice . start Batch ( ) ; try {  Buffered Reader reader = new  Buffered Reader ( new  File Reader ( path ) ) ;  String line ; while ( ( line = reader . read Line ( ) ) != null && ok ) { ok = text To Speech ( line ) ; } reader . close ( ) ; } catch (  IOException ioe ) { voice . error ( _ STR + path ) ; } voice . end Batch ( ) ; return ok ; }
public static void add Col Times (  Matrix matrix , long diag , long from Row , long col , double factor ) { long rows = matrix . get Row Count ( ) ; for ( long row = from Row ; row < rows ; row ++ ) { matrix . set As Double ( matrix . get As Double ( row , col ) - factor * matrix . get As Double ( row , diag ) , row , col ) ; } }
void release If Locked (  Object name ,  Internal Distributed Member owner , int lock Id ) throws  Interrupted Exception { wait While Initializing ( ) ; if ( ! acquire Destroy Read Lock ( _ NUM ) ) { wait Until Destroyed ( ) ; check Destroyed ( ) ; } try { check Destroyed ( ) ; get And Release Grant If Locked By ( name , owner , lock Id ) ; } finally { release Destroy Read Lock ( ) ; } }
public final  Array List <  Wifi Record > load Wifis Overview Within ( final int session , final  Double min Lon , final  Double max Lon , final  Double min Lat , final  Double max Lat ) { final  Array List <  Wifi Record > wifis = new  Array List < > ( ) ;  String selection = null ;  String [ ] selection Args = null ; if ( min Lon != null && max Lon != null && min Lat != null && max Lat != null ) { selection = _ STR +  Schema .  COL_ LONGITUDE + _ STR + _ STR +  Schema .  COL_ LONGITUDE + _ STR + _ STR +  Schema .  COL_ LATITUDE + _ STR + _ STR +  Schema .  COL_ LATITUDE + _ STR ; selection Args = new  String [ ] {  String . value Of ( min Lon ) ,  String . value Of ( max Lon ) ,  String . value Of ( min Lat ) ,  String . value Of ( max Lat ) } ; } final  Cursor cursor = content Resolver . query (  Content Uris . with Appended Id (  Uri . with Appended Path (  Content Provider .  CONTENT_ URI_ WIFI ,  Content Provider .  CONTENT_ URI_ OVERVIEW_ SUFFIX ) , session ) , null , selection , selection Args , null ) ; final int column Index = cursor . get Column Index (  Schema .  COL_ BSSID ) ; final int column Index2 = cursor . get Column Index (  Schema .  COL_ SSID ) ; final int column Index3 = cursor . get Column Index (  Schema .  COL_ CAPABILITIES ) ; final int column Index4 = cursor . get Column Index (  Schema .  COL_ FREQUENCY ) ; final int column Index5 = cursor . get Column Index (  Schema .  COL_ MAX_ LEVEL ) ; final int column Index6 = cursor . get Column Index (  Schema .  COL_ TIMESTAMP ) ; final int column Index7 = cursor . get Column Index (  Schema .  COL_ BEGIN_ POSITION_ ID ) ; final int column Index8 = cursor . get Column Index (  Schema .  COL_ END_ POSITION_ ID ) ; final int column Index9 = cursor . get Column Index (  Schema .  COL_ KNOWN_ WIFI ) ; while ( cursor . move To Next ( ) ) { final  Wifi Record wifi = new  Wifi Record ( ) ; wifi . set Bssid ( cursor . get String ( column Index ) ) ; wifi . set Ssid ( cursor . get String ( column Index2 ) ) ; wifi . set Capabilities ( cursor . get String ( column Index3 ) ) ; wifi . set Frequency ( cursor . get Int ( column Index4 ) ) ; wifi . set Level ( cursor . get Int ( column Index5 ) ) ; wifi . set Open Bmap Timestamp ( cursor . get Long ( column Index6 ) ) ; wifi . set Begin Position ( load Position By Id ( cursor . get String ( column Index7 ) ) ) ; wifi . set End Position ( load Position By Id ( cursor . get String ( column Index8 ) ) ) ; wifi . set Catalog Status (  Catalog Status . values ( ) [ cursor . get Int ( column Index9 ) ] ) ; wifis . add ( wifi ) ; } cursor . close ( ) ; return wifis ; }
void add Check Box (  String key ,  Check Box cb ,  String value ) { if ( cb . is Selected ( ) ) { default Checked Buttons . add Element ( cb ) ; } else { default Unchecked Buttons . add Element ( cb ) ; } if ( key == null ) { return ; }  Hashtable internal = (  Hashtable ) comps . get ( key ) ; if ( internal == null ) { internal = new  Hashtable ( ) ; comps . put ( key , internal ) ; } internal . put ( cb , value ) ; }
private  File create New Format ( int  AD_ Table_ ID ,  Http Servlet Request request ,  Grid Tab m_cur Tab ,  MQuery m_query ) {  Web Session Ctx wsc =  Web Session Ctx . get ( request ) ;  MPrint Format pf =  MPrint Format . create From Table ( wsc . ctx ,  AD_ Table_ ID ) ;  File file = launch Report ( pf , request , m_cur Tab , m_query ) ; return file ; }
public static  Job Definition retryable Cron Job Definition ( final  String job Type , final  String job Name , final  String description , final  String cron , final int restarts , final int retries , final  Duration retry Delay , final  Optional <  Duration > max Age ) { return new  Default Job Definition ( job Type , job Name , description , max Age ,  Optional . empty ( ) ,  Optional . of ( cron ) , restarts , retries ,  Optional . of ( retry Delay ) ) ; }
public static _ Fields find By Thrift Id ( int field Id ) { switch ( field Id ) { case _ NUM : return  MESSAGE ; case _ NUM : return  TYPE ; default : return null ; } }
public static void put Long LE ( long addr , long val ) { if (  UNALIGNED )  UNSAFE . put Long ( addr ,  Long . reverse Bytes ( val ) ) ; else put Long By Byte ( addr , val , _ BOOL ) ; }
public void write Population And Attributes (  String input Folder ,  String province Name ) throws  IOException {  String path = input Folder . ends With ( _ STR ) ? _ STR : _ STR ;  File output Folder = new  File ( input Folder + path + province Name + path ) ; if ( output Folder . exists ( ) ) { throw new  IOException ( _ STR + output Folder . get Absolute Path ( ) ) ; } else { output Folder . mkdirs ( ) ; } write Households ( output Folder . get Absolute Path ( ) ) ; write Population ( output Folder . get Absolute Path ( ) ) ; }
public org . w3c . dom .  Element sign XML ( org . w3c . dom .  Document doc , java . lang .  String cert Alias , java . lang .  String algorithm , java . util .  List ids ) throws  XMLSignature Exception { return sign XML ( doc , cert Alias , algorithm , null , ids ) ; }
protected  Cell Editor create Cell Editor On (  Composite composite ) { try {  Constructor constructor = editor Type . get Constructor ( new  Class [ ] {  Composite . class } ) ; return (  Cell Editor ) constructor . new Instance ( new  Object [ ] { composite } ) ; } catch (  Exception e ) { return null ; } }
public  Index File ( final  File dir ) throws  IOException { m Preread Arm =  Preread Arm .  UNKNOWN ; m Preread Type =  Preread Type .  UNKNOWN ; m Sdf Id = new  Sdf Id ( _ NUM ) ; final  File index = new  File ( dir ,  Sdf File Utils .  INDEX_ FILENAME ) ; try (  Data Input Stream index Stream = new  Data Input Stream ( new  Buffered Input Stream ( new  File Input Stream ( index ) ,  File Utils .  BUFFERED_ STREAM_ SIZE ) ) ) { final  Preread Hash Function header Hash = new  Preread Hash Function ( ) ; version1 Load ( index Stream , header Hash , dir ) ; if ( m Version >  VERSION ) { throw new  No Talkback Slim Exception ( _ STR + dir . to String ( ) + _ STR ) ; } load Version3 Fields ( index Stream , header Hash ) ; load Version4 Fields ( index Stream , header Hash , dir ) ; load Version6 Fields ( index Stream , header Hash ) ; load Version8 Fields ( index Stream , header Hash ) ; load Version9 Fields ( ) ; load Version10 Fields ( index Stream , header Hash ) ; load Version12 Fields ( index Stream , header Hash ) ; load Version13 Fields ( index Stream , header Hash ) ; checksum Load ( index Stream , header Hash , dir ) ; } catch ( final  EOFException e ) { throw new  Corrupt Sdf Exception ( dir ) ; } }
public static boolean can See (  IGame game ,  Entity ae ,  Targetable target ) { return can See ( game , ae , target , _ BOOL , null , null ) ; }
public void fix Conversion (  String rep ) { if ( s Hash Code != rep . hash Code ( ) ) throw new  Runtime Exception ( _ STR ) ; if ( s == null ) { s = rep ; } }
public void add Change Listener (  Property Change Listener new Listener ) { listener . add ( new Listener ) ; }
@  Deprecated public  Shapeless Recipe remove Ingredient ( int count ,  Material ingredient , int rawdata ) {  Iterator <  Item Stack > iterator = ingredients . iterator ( ) ; while ( count > _ NUM && iterator . has Next ( ) ) {  Item Stack stack = iterator . next ( ) ; if ( stack . get Type ( ) == ingredient && stack . get Durability ( ) == rawdata ) { iterator . remove ( ) ; count -- ; } } return this ; }
public  String orderby ( ) { if ( order != null && order . size ( ) > _ NUM ) {  String Builder sb = new  String Builder ( _ STR ) ; for ( int i = _ NUM ; i < order . size ( ) ; i ++ ) {  Entity e = order . get ( i ) ; if ( i > _ NUM ) { sb . append ( _ STR ) ; } sb . append ( e . name ) ; if (  X . to Int ( e . value ) < _ NUM ) { sb . append ( _ STR ) ; } } return sb . to String ( ) ; } return null ; }
public static  String trim Size (  String str , int size ) { if ( str == null ) return str ; if ( size <= _ NUM ) throw new  Illegal Argument Exception ( _ STR + size ) ; int length = str . length ( ) ; if ( length < size / _ NUM ) return str ; try { byte [ ] bytes = str . get Bytes ( _ STR ) ; if ( bytes . length <= size ) return str ; byte [ ] result = new byte [ size ] ;  System . arraycopy ( bytes , _ NUM , result , _ NUM , size ) ; return new  String ( result , _ STR ) ; } catch (  Unsupported Encoding Exception e ) { log . log (  Level .  SEVERE , str , e ) ; } return str ; }
private static int length Of Mime Names (  String val ) { int len = val . index Of ( _ STR ) ; if ( len < _ NUM ) len = val . length ( ) ; return len ; }
public int execute Process ( ) { final  List <  String > process Strings = tokenize String ( exec Command ) ; process Strings . add All ( tokenize String ( script ) ) ; logger . info (  Message Format . format ( _ STR , process Strings ) ) ; final  Process Builder process Builder = new  Process Builder ( process Strings ) ; if ( working Directory != null ) { final  Path dir =  Paths . get ( working Directory ) ; if (  Files . not Exists ( dir ) ) { try {  Files . create Directories ( dir ) ; } catch (  IOException e ) { logger . warning ( _ STR + working Directory ) ; return - _ NUM ; } } else if ( !  Files . is Directory ( dir ) ) { logger . warning ( working Directory + _ STR ) ; return - _ NUM ; } final  File directory = dir . to File ( ) ; process Builder . directory ( directory ) ; } process Builder . redirect Error Stream ( _ BOOL ) ;  Integer exit Value ; try { logger . info ( _ STR ) ; final  Process process = process Builder . start ( ) ; send Input String To Process ( process ) ; handle Process Output ( process ) ; try { exit Value = process . wait For ( ) ; } catch (  Interrupted Exception e ) { logger . warning ( _ STR ) ; process . destroy ( ) ; exit Value = - _ NUM ; } logger . info ( _ STR + exit Value + _ STR ) ; } catch (  IOException e ) { logger . log (  SEVERE , _ STR , e . get Cause ( ) ) ; exit Value = - _ NUM ; } return exit Value ; }
public void add Meta (  T meta ) { if ( meta != null ) { if ( m Meta == null ) { m Meta = new  Array List < > ( ) ; } m Meta . add ( meta ) ; } }
private  Matches lookup Do (  Template tmpl , int max Matches ) { if ( max Matches < _ NUM ) throw new  Illegal Argument Exception ( _ STR ) ; int total Matches = _ NUM ;  Array List <  Item > matches = null ;  Item Iter iter = matching Items ( tmpl ) ; if ( max Matches > _ NUM || iter . dups Possible ) { int suggested Size = iter . suggested Size ( ) ; suggested Size = max Matches < suggested Size ? max Matches : suggested Size ; matches = new  Array List <  Item > ( suggested Size ) ; } if ( iter . dups Possible ) { while ( iter . has Next ( ) ) {  Item item = iter . next ( ) ; if ( ! matches . contains ( item ) ) matches . add ( item ) ; } total Matches = matches . size ( ) ; if ( max Matches > _ NUM ) { for ( int i = matches . size ( ) ; -- i >= max Matches ; ) matches . remove ( i ) ; for ( int i = matches . size ( ) ; -- i >= _ NUM ; ) { matches . set ( i , copy Item ( matches . get ( i ) ) ) ; } } else { matches = null ; } } else { while ( iter . has Next ( ) ) {  Item item = iter . next ( ) ; total Matches ++ ; if ( -- max Matches >= _ NUM ) matches . add ( copy Item ( item ) ) ; } } return new  Matches ( matches , total Matches ) ; }
public static  List <  History > find History By Job And Status (  Entity Manager em ,  JPAEntity job ,  Big Integer limit ,  Job Status job Status ) { require Argument ( em != null , _ STR ) ; require Argument ( job != null , _ STR ) ;  Typed Query <  History > query = em . create Named Query ( _ STR ,  History . class ) ; if ( limit != null ) { query . set Max Results ( limit . int Value ( ) ) ; } try { query . set Parameter ( _ STR , job ) ; query . set Parameter ( _ STR , job Status ) ; return query . get Result List ( ) ; } catch (  No Result Exception ex ) { return new  Array List <  History > ( _ NUM ) ; } }
protected boolean is WFXMLChar (  String chardata ,  Character ref Invalid Char ) { if ( chardata == null || ( chardata . length ( ) == _ NUM ) ) { return _ BOOL ; } char [ ] dataarray = chardata . to Char Array ( ) ; int datalength = dataarray . length ; if ( f Is XMLVersion11 ) { int i = _ NUM ; while ( i < datalength ) { if (  XML11 Char . is XML11 Invalid ( dataarray [ i ++ ] ) ) { char ch = dataarray [ i - _ NUM ] ; if (  XMLChar . is High Surrogate ( ch ) && i < datalength ) { char ch2 = dataarray [ i ++ ] ; if (  XMLChar . is Low Surrogate ( ch2 ) &&  XMLChar . is Supplemental (  XMLChar . supplemental ( ch , ch2 ) ) ) { continue ; } } ref Invalid Char = new  Character ( ch ) ; return _ BOOL ; } } } else { int i = _ NUM ; while ( i < datalength ) { if (  XMLChar . is Invalid ( dataarray [ i ++ ] ) ) { char ch = dataarray [ i - _ NUM ] ; if (  XMLChar . is High Surrogate ( ch ) && i < datalength ) { char ch2 = dataarray [ i ++ ] ; if (  XMLChar . is Low Surrogate ( ch2 ) &&  XMLChar . is Supplemental (  XMLChar . supplemental ( ch , ch2 ) ) ) { continue ; } } ref Invalid Char = new  Character ( ch ) ; return _ BOOL ; } } } return _ BOOL ; }
void update Pending Nodes ( final int new Landmark Index , final  Node to Node , final  Router Priority Queue <  Node > pending Nodes ) {  Iterator <  Node > it = pending Nodes . iterator ( ) ;  Pre Process Landmarks .  Landmarks Data to Role = get Pre Process Data ( to Node ) ;  Array List <  Double > new Est Rem Trav Costs = new  Array List <  Double > ( ) ;  Array List <  Node > nodes To Be Updated = new  Array List <  Node > ( ) ; while ( it . has Next ( ) ) {  Node node = it . next ( ) ;  AStar Node Data role = get Data ( node ) ;  Pre Process Landmarks .  Landmarks Data pp Role = get Pre Process Data ( node ) ; double est Rem Trav Cost = role . get Expected Remaining Cost ( ) ; double new Est Rem Trav Cost = estimate Remaining Travel Cost ( pp Role , to Role , new Landmark Index ) ; if ( new Est Rem Trav Cost > est Rem Trav Cost ) { nodes To Be Updated . add ( node ) ; new Est Rem Trav Costs . add ( new Est Rem Trav Cost ) ; } } for (  Node node : nodes To Be Updated ) { pending Nodes . remove ( node ) ; } for ( int i = _ NUM ; i < nodes To Be Updated . size ( ) ; i ++ ) {  Node node = nodes To Be Updated . get ( i ) ;  AStar Node Data data = get Data ( node ) ; data . set Expected Remaining Cost ( new Est Rem Trav Costs . get ( i ) ) ; pending Nodes . add ( node , get Priority ( data ) ) ; } }
public static  String normalize ( char [ ] chars , int start , int length ) {  String Buffer buff = new  String Buffer ( ) ; for ( int i = start ; i < start + length ; i ++ ) { char c = chars [ i ] ; switch ( c ) { case _ STR : buff . append ( _ STR ) ; break ; case _ STR : buff . append ( _ STR ) ; break ; case _ STR : buff . append ( _ STR ) ; break ; case _ STR : buff . append ( _ STR ) ; break ; case _ STR : buff . append ( _ STR ) ; break ; default : buff . append ( _ STR + c ) ; break ; } } return buff . to String ( ) ; }
private void draw Overflow Indicator ( final  Workflow Annotation anno , final  Graphics2 D g , final  Rectangle2 D loc , final boolean printing ) { if ( printing ) { return ; }  Graphics2 D g2 = (  Graphics2 D ) g . create ( ) ; int size = _ NUM ; int x Offset = _ NUM ; int y Offset = _ NUM ; int step Size = size / _ NUM ; int dot Size = _ NUM ; int x = ( int ) loc . get Max X ( ) - size - x Offset ; int y = ( int ) loc . get Max Y ( ) - size - y Offset ;  Gradient Paint gp = new  Gradient Paint ( x , y ,  Color .  WHITE , x , y + size * _ NUM ,  Color .  LIGHT_ GRAY ) ; g2 . set Paint ( gp ) ; g2 . fill Rect ( x , y , size , size ) ; g2 . set Color (  Color .  BLACK ) ; g2 . draw Rect ( x , y , size , size ) ; g2 . fill Oval ( x + step Size , y + step Size * _ NUM , dot Size , dot Size ) ; g2 . fill Oval ( x + step Size * _ NUM , y + step Size * _ NUM , dot Size , dot Size ) ; g2 . fill Oval ( x + step Size * _ NUM , y + step Size * _ NUM , dot Size , dot Size ) ; g2 . dispose ( ) ; }
public void write Line ( long time , double [ ] column ) {  String str =  Long . to String ( time ) ; for ( int i = _ NUM ; i < column . length ; ++ i ) { str += _ STR + column [ i ] ; } writer . println ( str ) ; }
public static boolean is PEM ( byte [ ] byte Array ) { try {  String start PEM = _ STR ; int header Length = _ NUM ; byte [ ] preamble = new byte [ header Length ] ;  System . arraycopy ( byte Array , _ NUM , preamble , _ NUM , header Length ) ;  String start Array = new  String ( preamble ) ; return start Array . starts With ( start PEM ) ; } catch (  Exception e ) { throw new  DSSException ( _ STR ) ; } }
public void class Loader Destroy (  Dynamic Class Loader loader ) {  Object resource = _resource Ref . get ( ) ; if ( resource == null ) return ;  Method destroy =  Close Listener . get Destroy Method ( resource . get Class ( ) ) ; if ( destroy == null ) return ; try { destroy . invoke ( resource , (  Object [ ] ) null ) ; } catch (  Throwable e ) { log . log (  Level .  WARNING , e . to String ( ) , e ) ; } }
@  Override public  Delete Request routing (  String routing ) { if ( routing != null && routing . length ( ) == _ NUM ) { this . routing = null ; } else { this . routing = routing ; } return this ; }
public byte [ ] receive ( ) throws  IOException { if ( connection != null ) { packet . set Length (  Datagram Connection .  DEFAULT_ DATAGRAM_ SIZE ) ; connection . receive ( packet ) ; int packet Length = packet . get Length ( ) ; byte [ ] data = new byte [ packet Length ] ;  System . arraycopy ( packet . get Data ( ) , _ NUM , data , _ NUM , packet Length ) ; return data ; } else { throw new  IOException ( _ STR ) ; } }
@  Override protected void force Insert Attribute At ( int position ) { double [ ] new Values = new double [ m_ Att Values . length + _ NUM ] ;  System . arraycopy ( m_ Att Values , _ NUM , new Values , _ NUM , position ) ; new Values [ position ] =  Utils . missing Value ( ) ;  System . arraycopy ( m_ Att Values , position , new Values , position + _ NUM , m_ Att Values . length - position ) ; m_ Att Values = new Values ; }
protected  Key engine Translate Key (  Key key ) throws  Invalid Key Exception { if ( key == null ) { throw new  Invalid Key Exception ( _ STR ) ; }  String key Alg = key . get Algorithm ( ) ; if ( key Alg . equals ( _ STR ) == _ BOOL ) { throw new  Invalid Key Exception ( _ STR + key Alg ) ; } if ( key instanceof  Public Key ) { return translate Public Key ( (  Public Key ) key ) ; } else if ( key instanceof  Private Key ) { return translate Private Key ( (  Private Key ) key ) ; } else { throw new  Invalid Key Exception ( _ STR ) ; } }
@  Override public double [ ] distribution For Instance (  Instance instance ) throws  Exception { instance = (  Instance ) instance . copy ( ) ; instance . set Dataset ( m_numeric Data Header ) ; return probs ( get Fs ( instance ) ) ; }
void start Scrolling Instance ( ) { if ( log . is Loggable (  Platform Logger .  Level .  FINER ) ) { log . finer ( _ STR + this ) ; } scroll ( ) ; i_scroller . set Scrollbar ( this ) ; i_scroller . start ( ) ; }
public static  Class < ? > load Proxy Class (  String codebase ,  String [ ] interfaces ,  Class Loader default Loader ) throws  Malformed URLException ,  Class Not Found Exception { if ( loader Log . is Loggable (  Log .  BRIEF ) ) { loader Log . log (  Log .  BRIEF , _ STR +  Arrays . as List ( interfaces ) + _ STR + _ STR + ( codebase != null ? codebase : _ STR ) + _ STR + ( default Loader != null ? _ STR + default Loader : _ STR ) ) ; }  Class Loader parent = get RMIContext Class Loader ( ) ; if ( loader Log . is Loggable (  Log .  VERBOSE ) ) { loader Log . log (  Log .  VERBOSE , _ STR + parent + _ STR ) ; }  URL [ ] urls ; if ( codebase != null ) { urls = path To URLs ( codebase ) ; } else { urls = get Default Codebase URLs ( ) ; }  Security Manager sm =  System . get Security Manager ( ) ; if ( sm == null ) { try {  Class < ? > c = load Proxy Class ( interfaces , default Loader , parent , _ BOOL ) ; if ( loader Log . is Loggable (  Log .  VERBOSE ) ) { loader Log . log (  Log .  VERBOSE , _ STR + _ STR + c . get Class Loader ( ) ) ; } return c ; } catch (  Class Not Found Exception e ) { if ( loader Log . is Loggable (  Log .  BRIEF ) ) { loader Log . log (  Log .  BRIEF , _ STR + _ STR , e ) ; } throw new  Class Not Found Exception ( e . get Message ( ) + _ STR , e . get Exception ( ) ) ; } }  Loader loader = lookup Loader ( urls , parent ) ; try { if ( loader != null ) { loader . check Permissions ( ) ; } } catch (  Security Exception e ) { try {  Class < ? > c = load Proxy Class ( interfaces , default Loader , parent , _ BOOL ) ; if ( loader Log . is Loggable (  Log .  VERBOSE ) ) { loader Log . log (  Log .  VERBOSE , _ STR + _ STR + c . get Class Loader ( ) ) ; } return c ; } catch (  Class Not Found Exception unimportant ) { if ( loader Log . is Loggable (  Log .  BRIEF ) ) { loader Log . log (  Log .  BRIEF , _ STR + _ STR , e ) ; } throw new  Class Not Found Exception ( _ STR , e ) ; } } try {  Class < ? > c = load Proxy Class ( interfaces , default Loader , loader , _ BOOL ) ; if ( loader Log . is Loggable (  Log .  VERBOSE ) ) { loader Log . log (  Log .  VERBOSE , _ STR + c . get Class Loader ( ) ) ; } return c ; } catch (  Class Not Found Exception e ) { if ( loader Log . is Loggable (  Log .  BRIEF ) ) { loader Log . log (  Log .  BRIEF , _ STR , e ) ; } throw e ; } }
public static  List <  INavi Module > load Modules ( final  Abstract SQLProvider provider , final  List <  INavi Raw Module > raw Modules , final  Debugger Template Manager debugger Manager ) throws  Couldnt Load Data Exception {  Preconditions . check Not Null ( raw Modules , _ STR ) ;  Postgre SQLDatabase Functions . check Arguments ( provider , debugger Manager ) ; final  List <  CModule > modules = new  Array List < > ( ) ; final  CConnection connection = provider . get Connection ( ) ; if ( !  Postgre SQLHelpers . has Table ( connection ,  CTable Names .  MODULES_ TABLE ) ) { return new  Array List <  INavi Module > ( modules ) ; } final  String query = _ STR +  CTable Names .  MODULES_ TABLE + _ STR + _ STR + _ STR + _ STR +  CTable Names .  FUNCTIONS_ TABLE + _ STR + _ STR +  CTable Names .  FUNCTIONS_ TABLE + _ STR + _ STR + _ STR +  CTable Names .  MODULE_ VIEWS_ TABLE + _ STR +  CTable Names .  VIEWS_ TABLE + _ STR + _ STR +  CTable Names .  MODULES_ TABLE + _ STR + _ STR +  CTable Names .  MODULES_ TABLE + _ STR + _ STR ; try (  Result Set result Set = connection . execute Query ( query , _ BOOL ) ) { while ( result Set . next ( ) ) { final int module Id = result Set . get Int ( _ STR ) ; final  String name =  Postgre SQLHelpers . read String ( result Set , _ STR ) ; final  String md5 =  Postgre SQLHelpers . read String ( result Set , _ STR ) ; final  String sha1 =  Postgre SQLHelpers . read String ( result Set , _ STR ) ; final  String comment =  Postgre SQLHelpers . read String ( result Set , _ STR ) ; final  Timestamp timestamp = result Set . get Timestamp ( _ STR ) ; final  Timestamp modification Date = result Set . get Timestamp ( _ STR ) ; int function Count = result Set . get Int ( _ STR ) ; final int view Count = result Set . get Int ( _ STR ) ; final  IAddress image Base =  Postgre SQLHelpers . load Address ( result Set , _ STR ) ; final  IAddress file Base =  Postgre SQLHelpers . load Address ( result Set , _ STR ) ; final int debugger Id = result Set . get Int ( _ STR ) ; final boolean is Stared = result Set . get Boolean ( _ STR ) ; final int initialization State = result Set . get Int ( _ STR ) ; final  Debugger Template description = debugger Manager . find Debugger ( debugger Id ) ; final int raw Module Id = result Set . get Int ( _ STR ) ; final  INavi Raw Module raw Module =  Postgre SQLDatabase Functions . find Raw Module ( raw Module Id , raw Modules ) ; if ( ( function Count == _ NUM ) && ( raw Module != null ) ) { function Count = raw Module . get Function Count ( ) ; } modules . add ( new  CModule ( module Id , name , comment , timestamp , modification Date , md5 , sha1 , function Count , view Count , file Base , image Base , description , raw Module , initialization State , is Stared , provider ) ) ; } } catch ( final  SQLException e ) { throw new  Couldnt Load Data Exception ( e ) ; } return new  Array List <  INavi Module > ( modules ) ; }
void write (  Image Output Stream ios ) throws  IOException { length = _ NUM + ( ( data != null ) ? data . length : _ NUM ) ; write Tag ( ios ) ; if ( data != null ) { ios . write ( data ) ; } }
private static  Debugger Options parse Options Information ( final  Node node ) throws  Message Parser Exception { final  Node List nodes = node . get Child Nodes ( ) ; final  Debugger Options Builder builder = new  Debugger Options Builder ( ) ; for ( int i = _ NUM ; i < nodes . get Length ( ) ; ++ i ) { final  Node child = nodes . item ( i ) ; final  String name = get Attribute ( child , _ STR ) ; switch (  Target Information Debugger Options . get Enum ( name ) ) { case  CAN_ DETACH : builder . can Detach ( parse Boolean Option ( child ) ) ; break ; case  CAN_ ATTACH : builder . can Attach ( parse Boolean Option ( child ) ) ; break ; case  CAN_ TERMINATE : builder . can Terminate ( parse Boolean Option ( child ) ) ; break ; case  HAS_ STACK : builder . stack Available ( parse Boolean Option ( child ) ) ; break ; case  CAN_ VALIDATE_ MEMORY : builder . can Validate Memory ( parse Boolean Option ( child ) ) ; break ; case  CAN_ HALT : builder . can Halt ( parse Boolean Option ( child ) ) ; break ; case  CAN_ HALT_ BEFORE_ COMMUNICATING : builder . can Halt Before Communicating ( parse Boolean Option ( child ) ) ; break ; case  CAN_ MULTI_ THREAD : builder . can Multithread ( parse Boolean Option ( child ) ) ; break ; case  CAN_ SOFTWARE_ BREAKPOINTS : builder . can Software Breakpoints ( parse Boolean Option ( child ) ) ; break ; case  BREAKPOINT_ COUNT : builder . breakpoint Counter ( parse Int Option ( child , _ STR ) ) ; break ; case  PAGE_ SIZE : builder . page Size ( parse Int Option ( child , _ STR ) ) ; break ; case  CAN_ BREAK_ ON_ MODULE_ LOAD : builder . can Break On Module Load ( parse Boolean Option ( child ) ) ; break ; case  CAN_ BREAK_ ON_ MODULE_ UNLOAD : builder . can Break On Module Unload ( parse Boolean Option ( child ) ) ; break ; case  EXCEPTION : builder . add Exception ( parse Exception Option ( child ) ) ; break ; case  CAN_ TRACE_ COUNT : builder . can Trace Counts ( parse Boolean Option ( child ) ) ; break ; case  CAN_ MEMMAP : builder . can Memmap ( parse Boolean Option ( child ) ) ; break ; default : throw new  Message Parser Exception (  String . format ( _ STR , name ) ) ; } } return builder . build ( ) ; }
public  Named Thread Factory (  String name Prefix ) { this . _name Prefix = name Prefix ; _delegate =  Executors . default Thread Factory ( ) ; }
public void test_metric_heartbeat_uint32 ( ) { final  IGanglia Metadata Message decl = new  Ganglia Metadata Message ( _ STR , _ STR , _ BOOL ,  Ganglia Message Type Enum .  UINT32 , _ STR , _ STR ,  Ganglia Slope Enum . unspecified , _ NUM , _ NUM ,  Abstract Metrics . get Map (  IGanglia Attributes .  GROUP_ CORE , _ STR , _ STR ) ) ; assert Encode Decode ( null , decl ) ; final  IGanglia Metric Message expected = new  Ganglia Metric Message (  Ganglia Message Type Enum .  UINT32 , _ STR , _ STR , _ BOOL , _ STR ,  Long . value Of ( _ NUM ) ) ; final byte [ ] actual Data = assert Encode Decode ( decl , expected ) ; final byte [ ] expected Data = new byte [ ] { _ NUM , _ NUM , _ NUM , - _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , - _ NUM } ; if ( !  Arrays . equals ( expected Data , actual Data ) ) { fail ( _ STR +  Arrays . to String ( expected Data ) + _ STR +  Arrays . to String ( actual Data ) ) ; } }
@  Override public void delete Columns ( int start , int len ) throws  Fits Exception { ensure Data ( ) ;  Object [ ] new Data = new  Object [ this . n Fields - len ] ; int [ ] new Offsets = new int [ this . n Fields - len ] ; int [ ] new Lengths = new int [ this . n Fields - len ] ;  Class < ? > [ ] new Types = new  Class [ this . n Fields - len ] ;  String [ ] new Nulls = new  String [ this . n Fields - len ] ;  System . arraycopy ( this . data , _ NUM , new Data , _ NUM , start ) ;  System . arraycopy ( this . lengths , _ NUM , new Lengths , _ NUM , start ) ;  System . arraycopy ( this . types , _ NUM , new Types , _ NUM , start ) ;  System . arraycopy ( this . nulls , _ NUM , new Nulls , _ NUM , start ) ;  System . arraycopy ( this . data , start + len , new Data , start , this . n Fields - start - len ) ;  System . arraycopy ( this . lengths , start + len , new Lengths , start , this . n Fields - start - len ) ;  System . arraycopy ( this . types , start + len , new Types , start , this . n Fields - start - len ) ;  System . arraycopy ( this . nulls , start + len , new Nulls , start , this . n Fields - start - len ) ; for ( int i = start ; i < start + len ; i += _ NUM ) { this . row Len -= this . lengths [ i ] + _ NUM ; } this . data = new Data ; this . offsets = new Offsets ; this . lengths = new Lengths ; this . types = new Types ; this . nulls = new Nulls ; if ( this . is Null != null ) { boolean found = _ BOOL ; boolean [ ] new Is Null = new boolean [ this . n Rows * ( this . n Fields - len ) ] ; for ( int i = _ NUM ; i < this . n Rows ; i += _ NUM ) { int old Off = this . n Fields * i ; int new Off = ( this . n Fields - len ) * i ; for ( int col = _ NUM ; col < start ; col += _ NUM ) { new Is Null [ new Off + col ] = this . is Null [ old Off + col ] ; found = found || this . is Null [ old Off + col ] ; } for ( int col = start + len ; col < this . n Fields ; col += _ NUM ) { new Is Null [ new Off + col - len ] = this . is Null [ old Off + col ] ; found = found || this . is Null [ old Off + col ] ; } } if ( found ) { this . is Null = new Is Null ; } else { this . is Null = null ; } } this . buffer = null ; this . n Fields -= len ; }
void dce (  Method m ) {  Deque <  Block > code = dfs ( m . entry . to ) ; cp ( code ) ;  Bit Set marked = new  Bit Set ( ) ; for (  Block b : code ) for (  Expr e : b ) if ( has Side Effect ( e ) ) dce_mark ( marked , e ) ; for (  Block b : code ) for (  Iterator <  Expr > i = b . iterator ( ) ; i . has Next ( ) ; ) if ( ! marked . get ( i . next ( ) . id ) ) { i . remove ( ) ; } }
public void add Extension Method (  String extension Method ) { if ( extension Method . equals (  Request .  NOTIFY ) ) { if ( logger . is Logging Enabled (  Log Writer .  TRACE_ DEBUG ) ) logger . log Debug ( _ STR ) ; } else { dialog Creating Methods . add (  Utils . to Upper Case ( extension Method . trim ( ) ) ) ; } }
private void keep Alive ( ) {  Thread current =  Thread . current Thread ( ) ; try { heart Beat ( ) ; while ( current == keep Alive Thread ) {  Thread . sleep (  HEART_ BEAT ) ; heart Beat ( ) ; } } catch (  Interrupted Exception e ) { log . warn ( _ STR , e ) ; } }
public void test Split And Join Multiple Properties On Pipe ( ) {  Properties inner =  Property Utils . split Properties On Pipe (  ONE_ PIPE_ TWO ) ; assert Equals ( _ STR , inner . get Property ( _ STR ) ) ; assert Equals ( _ STR , inner . get Property ( _ STR ) ) ; assert Equals ( _ NUM , inner . size ( ) ) ; try { assert Equals (  ONE_ PIPE_ TWO ,  Property Utils . join On Pipe (  Property Utils . to Map ( inner ) ) ) ; } catch (  Comparison Failure e ) { assert Equals (  TWO_ PIPE_ ONE ,  Property Utils . join On Pipe (  Property Utils . to Map ( inner ) ) ) ; } }
public void test Getter Inheritance ( ) throws  Exception {  Object Mapper m = new  Object Mapper ( ) ;  Map <  String ,  Object > result = write And Map ( m , new  Sub Class Bean ( ) ) ; assert Equals ( _ NUM , result . size ( ) ) ; assert Equals (  Integer . value Of ( _ NUM ) , result . get ( _ STR ) ) ; assert Equals (  Integer . value Of ( _ NUM ) , result . get ( _ STR ) ) ; assert Equals (  Integer . value Of ( _ NUM ) , result . get ( _ STR ) ) ; }
public static final void decode (  Input Stream is ,  Output Stream os ) throws  Base64 Decoding Exception ,  IOException { byte b1 = _ NUM , b2 = _ NUM , b3 = _ NUM , b4 = _ NUM ; int index = _ NUM ; byte [ ] data = new byte [ _ NUM ] ; int read ; while ( ( read = is . read ( ) ) > _ NUM ) { byte readed = ( byte ) read ; if ( is White Space ( readed ) ) { continue ; } if ( is Pad ( readed ) ) { data [ index ++ ] = readed ; if ( index == _ NUM ) { data [ index ++ ] = ( byte ) is . read ( ) ; } break ; } if ( ( data [ index ++ ] = readed ) == - _ NUM ) { throw new  Base64 Decoding Exception ( _ STR ) ; } if ( index != _ NUM ) { continue ; } index = _ NUM ; b1 = base64 Alphabet [ data [ _ NUM ] ] ; b2 = base64 Alphabet [ data [ _ NUM ] ] ; b3 = base64 Alphabet [ data [ _ NUM ] ] ; b4 = base64 Alphabet [ data [ _ NUM ] ] ; os . write ( ( byte ) ( b1 << _ NUM | b2 > > _ NUM ) ) ; os . write ( ( byte ) ( ( ( b2 & _ NUM ) << _ NUM ) | ( ( b3 > > _ NUM ) & _ NUM ) ) ) ; os . write ( ( byte ) ( b3 << _ NUM | b4 ) ) ; } byte d1 = data [ _ NUM ] , d2 = data [ _ NUM ] , d3 = data [ _ NUM ] , d4 = data [ _ NUM ] ; b1 = base64 Alphabet [ d1 ] ; b2 = base64 Alphabet [ d2 ] ; b3 = base64 Alphabet [ d3 ] ; b4 = base64 Alphabet [ d4 ] ; if ( ( b3 == - _ NUM ) || ( b4 == - _ NUM ) ) { if ( is Pad ( d3 ) && is Pad ( d4 ) ) { if ( ( b2 & _ NUM ) != _ NUM ) { throw new  Base64 Decoding Exception ( _ STR ) ; } os . write ( ( byte ) ( b1 << _ NUM | b2 > > _ NUM ) ) ; } else if ( ! is Pad ( d3 ) && is Pad ( d4 ) ) { b3 = base64 Alphabet [ d3 ] ; if ( ( b3 & _ NUM ) != _ NUM ) { throw new  Base64 Decoding Exception ( _ STR ) ; } os . write ( ( byte ) ( b1 << _ NUM | b2 > > _ NUM ) ) ; os . write ( ( byte ) ( ( ( b2 & _ NUM ) << _ NUM ) | ( ( b3 > > _ NUM ) & _ NUM ) ) ) ; } else { throw new  Base64 Decoding Exception ( _ STR ) ; } } else { os . write ( ( byte ) ( b1 << _ NUM | b2 > > _ NUM ) ) ; os . write ( ( byte ) ( ( ( b2 & _ NUM ) << _ NUM ) | ( ( b3 > > _ NUM ) & _ NUM ) ) ) ; os . write ( ( byte ) ( b3 << _ NUM | b4 ) ) ; } }
public  Connection Quality register (  Connection Class State Change Listener listener ) { if ( listener != null ) { m Listener List . add ( listener ) ; } return m Current Bandwidth Connection Quality . get ( ) ; }
public void test Merge One Servlet Into Empty Document ( ) throws  Exception {  String src Xml = _ STR ;  Web Xml src Web Xml =  Web Xml Io . parse Web Xml ( new  Byte Array Input Stream ( src Xml . get Bytes ( _ STR ) ) , null ) ;  String merge Xml = _ STR + _ STR + _ STR + _ STR + _ STR + _ STR ;  Web Xml merge Web Xml =  Web Xml Io . parse Web Xml ( new  Byte Array Input Stream ( merge Xml . get Bytes ( _ STR ) ) , null ) ;  Web Xml Merger merger = new  Web Xml Merger ( src Web Xml ) ; merger . merge ( merge Web Xml ) ; assert True (  Web Xml Utils . has Servlet ( src Web Xml , _ STR ) ) ; }
private  Diff Part decode Replace ( final int block Size_ S , final int block Size_ E , final int block Size_ L ) throws  Unsupported Encoding Exception ,  Decoding Exception { if ( block Size_ S < _ NUM || block Size_ E < _ NUM || block Size_ L < _ NUM ) { throw new  Decoding Exception ( _ STR + block Size_ S + _ STR + block Size_ E + _ STR + block Size_ L ) ; } int s = r . read ( block Size_ S ) ; int e = r . read ( block Size_ E ) ; int l = r . read ( block Size_ L ) ;  Byte Array Output Stream output = new  Byte Array Output Stream ( ) ; for ( int i = _ NUM ; i < l ; i ++ ) { output . write ( r . read Byte ( ) ) ; }  Diff Part part = new  Diff Part (  Diff Action .  REPLACE ) ; part . set Start ( s ) ; part . set Length ( e ) ; part . set Text ( output . to String (  WIKIPEDIA_ ENCODING ) ) ; return part ; }
Node clone Or Import Node ( short operation ,  Node node , boolean deep ) {  Node Impl copy = shallow Copy ( operation , node ) ; if ( deep ) {  Node List list = node . get Child Nodes ( ) ; for ( int i = _ NUM ; i < list . get Length ( ) ; i ++ ) { copy . append Child ( clone Or Import Node ( operation , list . item ( i ) , deep ) ) ; } } notify User Data Handlers ( operation , node , copy ) ; return copy ; }
private void load Corpus (  Parallel Corpus corpus ) { logger . info ( _ STR ) ;  Time Keeper timer =  Timing Utils . start ( ) ; num Sentences = corpus . size ( ) ; int num Source Positions = corpus . num Source Positions ( ) ; int num Target Positions = corpus . num Target Positions ( ) ; int src Length = num Source Positions + num Sentences ; src Bitext = new int [ src Length ] ; f2e = new int [ src Length ] ; int tgt Length = num Target Positions + num Sentences ; tgt Bitext = new int [ tgt Length ] ; e2f = new int [ tgt Length ] ; int src Offset = _ NUM ; int tgt Offset = _ NUM ; for (  Aligned Sentence sentence : corpus ) {  System . arraycopy ( sentence . source , _ NUM , src Bitext , src Offset , sentence . source Length ( ) ) ;  System . arraycopy ( sentence . f2e , _ NUM , f2e , src Offset , sentence . f2e . length ) ;  System . arraycopy ( sentence . target , _ NUM , tgt Bitext , tgt Offset , sentence . target Length ( ) ) ;  System . arraycopy ( sentence . e2f , _ NUM , e2f , tgt Offset , sentence . e2f . length ) ; src Offset += sentence . source Length ( ) ; tgt Offset += sentence . target Length ( ) ; src Bitext [ src Offset ] = to Sentence Offset ( tgt Offset ) ; tgt Bitext [ tgt Offset ] = to Sentence Offset ( src Offset ) ; ++ src Offset ; ++ tgt Offset ; } vocabulary = corpus . get Vocabulary ( ) ; timer . mark ( _ STR ) ; logger . info ( _ STR , timer ) ; }
float [ ] calculate Size And Xy Amount ( float mouse Delta X , float mouse Delta Y , float rotation ) { float mouse Drag Angle =  Math Utils . atan2 ( mouse Delta Y , mouse Delta X ) *  Math Utils . rad Deg ; float delta A = rotation - mouse Drag Angle ; float c = ( float )  Math . sqrt ( mouse Delta X * mouse Delta X + mouse Delta Y * mouse Delta Y ) ; float a = c *  Math Utils . cos Deg ( delta A ) ; float x Component = a *  Math Utils . cos Deg ( rotation ) ; float y Component = a *  Math Utils . sin Deg ( rotation ) ; return new float [ ] { a , x Component , y Component } ; }
protected  Object decode Response (  Input Stream input Stream ,  String content Type ) throws  IOException {  Object value ; if ( content Type . starts With (  JSON_ MIME_ TYPE ) ) {  JSONDecoder decoder = new  JSONDecoder ( ) ; value = decoder . read Value ( input Stream ) ; } else if ( content Type . starts With (  TEXT_ MIME_ TYPE_ PREFIX ) ) {  Text Decoder decoder = new  Text Decoder ( ) ; value = decoder . read Value ( input Stream ) ; } else { value = null ; } return value ; }
public long time ( int i ) { long offset = _ NUM ; for ( int j = indices . length - _ NUM ; j >= _ NUM ; j -- ) { if ( i >= indices [ j ] ) { offset = offsets [ j ] ; break ; } } return offset + rtimes [ i ] ; }
private  List <  Volume > create VPlex Volumes (  String name , int number Of Vols ,  URI storage System ) {  List <  Volume > volumes = new  Array List <  Volume > ( ) ; for ( int i = _ NUM ; i <= number Of Vols ; i ++ ) {  Volume vplex Volume = new  Volume ( ) ;  URI vplex Volume Uri =  URIUtil . create Id (  Volume . class ) ; vplex Volume URIs . add ( vplex Volume Uri ) ; vplex Volume . set Id ( vplex Volume Uri ) ; vplex Volume . set Label ( name + i ) ; vplex Volume . set Native Id ( _ STR + i ) ; vplex Volume . set Storage Controller ( storage System ) ;  String Set associated Volumes = new  String Set ( ) ; associated Volumes . add ( _ STR ) ; vplex Volume . set Associated Volumes ( associated Volumes ) ; volumes . add ( vplex Volume ) ; } return volumes ; }
private void update Effective Size ( ) { try { int r =  Integer . value Of ( rows . get Text ( ) ) ; int c =  Integer . value Of ( columns . get Text ( ) ) ; int h =  Integer . value Of ( receptive Field Height . get Text ( ) ) ; int w =  Integer . value Of ( receptive Field Width . get Text ( ) ) ; effective Size . set Text ( ( c * w ) + _ STR + ( r * h ) ) ; } catch (  Number Format Exception e ) { effective Size . set Text ( _ STR ) ; } }
public static  Double zing (  Number value ) { if ( value == null ) { return null ; } return  Math . max ( _ NUM , value . double Value ( ) ) ; }
public static <  T >  T show Dialog (  Window Based Text GUI text GUI ,  String title ,  String description , int list Box Height ,  T ... items ) { int width = _ NUM ; for (  T item : items ) { width =  Math . max ( width ,  Terminal Text Utils . get Column Width ( item . to String ( ) ) ) ; } width += _ NUM ; return show Dialog ( text GUI , title , description , new  Terminal Size ( width , list Box Height ) , items ) ; }
private boolean is Handler Request ( final  Http Servlet Request request ) {  String api Handler Value = request . get Parameter (  PATH_ API ) ; return  PATH_ HANDLER . equals ( api Handler Value ) && retrieve Cache Key ( request ) != null ; }
public  Abstract Sequencer ( int buffer Size ,  Wait Strategy wait Strategy ) { if ( buffer Size < _ NUM ) { throw new  Illegal Argument Exception ( _ STR ) ; } if (  Integer . bit Count ( buffer Size ) != _ NUM ) { throw new  Illegal Argument Exception ( _ STR ) ; } this . buffer Size = buffer Size ; this . wait Strategy = wait Strategy ; }
private void fill Conversations ( ) { conversations . add ( _ STR ) ; conversations . add ( _ STR ) ; conversations . add ( _ STR ) ; conversations . add ( _ STR ) ; conversations . add ( _ STR ) ; conversations . add ( _ STR ) ; conversations . add ( _ STR ) ; conversations . add ( _ STR ) ; conversations . add ( _ STR ) ; conversations . add ( _ STR ) ; conversations . add ( _ STR ) ; conversations . add ( _ STR ) ; }
public void shutdown ( ) { if (  VERBOSE )  Util . verbose ( _ STR ) ; disable ( ) ; discard Jobs ( null ) ;  Thread thread = this . processing Thread ; try { if ( thread != null ) { synchronized ( this ) { this . processing Thread = null ; notify All ( ) ; } thread . join ( ) ; }  Job job = this . progress Job ; if ( job != null ) { job . cancel ( ) ; job . join ( ) ; } } catch (  Interrupted Exception e ) { } }
public void end Element (  String uri ,  String local Name ,  String q Name ) throws  SAXException { if ( q Name . equals (  Print Data .  XML_ TAG ) ) { pop ( ) ; } else if ( q Name . equals (  Print Data Element .  XML_ TAG ) ) { m_cur PD . add Node ( new  Print Data Element ( m_cur PDEname , m_cur PDEvalue . to String ( ) , _ NUM , null ) ) ; } }
private void draw String (  Object native Graphics ,  Object native Font ,  String str , int x , int y , int text Decoration , int font Height ) { if ( str . length ( ) == _ NUM ) { return ; } if ( text Decoration != _ NUM ) { boolean raised = ( text Decoration &  Style .  TEXT_ DECORATION_3 D ) != _ NUM ; boolean lowerd = ( text Decoration &  Style .  TEXT_ DECORATION_3 D_ LOWERED ) != _ NUM ; boolean north = ( text Decoration &  Style .  TEXT_ DECORATION_3 D_ SHADOW_ NORTH ) != _ NUM ; if ( raised || lowerd || north ) { text Decoration = text Decoration & ( ~  Style .  TEXT_ DECORATION_3 D ) & ( ~  Style .  TEXT_ DECORATION_3 D_ LOWERED ) & ( ~  Style .  TEXT_ DECORATION_3 D_ SHADOW_ NORTH ) ; int c = get Color ( native Graphics ) ; int a = get Alpha ( native Graphics ) ; int new Color = _ NUM ; int offset = - _ NUM ; if ( lowerd ) { offset = _ NUM ; new Color = _ NUM ; } else if ( north ) { offset = _ NUM ; } set Color ( native Graphics , new Color ) ; if ( a == _ NUM ) { set Alpha ( native Graphics , _ NUM ) ; } draw String ( native Graphics , native Font , str , x , y + offset , text Decoration , font Height ) ; set Alpha ( native Graphics , a ) ; set Color ( native Graphics , c ) ; draw String ( native Graphics , native Font , str , x , y , text Decoration , font Height ) ; return ; } draw String ( native Graphics , str , x , y ) ; if ( ( text Decoration &  Style .  TEXT_ DECORATION_ UNDERLINE ) != _ NUM ) { draw Line ( native Graphics , x , y + font Height - _ NUM , x + string Width ( native Font , str ) , y + font Height - _ NUM ) ; } if ( ( text Decoration &  Style .  TEXT_ DECORATION_ STRIKETHRU ) != _ NUM ) { draw Line ( native Graphics , x , y + font Height / _ NUM , x + string Width ( native Font , str ) , y + font Height / _ NUM ) ; } if ( ( text Decoration &  Style .  TEXT_ DECORATION_ OVERLINE ) != _ NUM ) { draw Line ( native Graphics , x , y , x + string Width ( native Font , str ) , y ) ; } } else { draw String ( native Graphics , str , x , y ) ; } }
public  String build Nonce Counter ( ) {  String result =  Integer . to Hex String ( m Cnonce Counter ) ; while ( result . length ( ) != _ NUM ) { result = _ STR + result ; } return result ; }
@  Override public void accept Instance (  Instance Event e ) { m_busy = _ BOOL ; if ( e . get Status ( ) ==  Instance Event .  FORMAT_ AVAILABLE ) { m_throughput = new  Stream Throughput ( status Message Prefix ( ) ) ;  Instances structure = e . get Structure ( ) ; try { make Output Structure ( structure ) ; } catch (  Exception ex ) {  String msg = status Message Prefix ( ) + _ STR ; if ( m_log != null ) { m_log . status Message ( msg ) ; m_log . log Message ( _ STR + ex . get Message ( ) ) ; } stop ( ) ; ex . print Stack Trace ( ) ; m_busy = _ BOOL ; return ; } if ( ! e . m_format Notification Only ) { if ( m_log != null ) { m_log . status Message ( status Message Prefix ( ) + _ STR ) ; } } m_ie . set Structure ( m_matches . get Output Structure ( ) ) ; m_ie . m_format Notification Only = e . m_format Notification Only ; notify Instance Listeners ( m_ie ) ; } else {  Instance inst = e . get Instance ( ) ;  Instance out = null ; if ( inst != null ) { m_throughput . update Start ( ) ; try { out = m_matches . make Output Instance ( inst , _ BOOL ) ; } catch (  Exception e1 ) { e1 . print Stack Trace ( ) ; } m_throughput . update End ( m_log ) ; } if ( inst == null || out != null || e . get Status ( ) ==  Instance Event .  BATCH_ FINISHED ) { m_ie . set Instance ( out ) ; m_ie . set Status ( e . get Status ( ) ) ; notify Instance Listeners ( m_ie ) ; } if ( e . get Status ( ) ==  Instance Event .  BATCH_ FINISHED || inst == null ) { m_throughput . finished ( m_log ) ; } } m_busy = _ BOOL ; }
protected  Map <  String ,  List <  Storage Pool > > sort Pools By VPlex Storage System (  List <  Storage Pool > storage Pools ,  String varray Id ,  String cluster ) {  Map <  String ,  List <  Storage Pool > > vplex Pool Map = new  Hash Map <  String ,  List <  Storage Pool > > ( ) ;  Map <  URI ,  List <  Storage Pool > > pools By System = get Pools By System ( storage Pools ) ; for (  URI system Uri : pools By System . key Set ( ) ) {  Set <  URI > vplex System URIs =  Connectivity Util . get VPlex Systems Associated With Array ( _db Client , system Uri , new  Hash Set <  String > (  Arrays . as List ( varray Id ) ) , cluster ) ; for (  URI vplex Uri : vplex System URIs ) {  Storage System vplex System = _db Client . query Object (  Storage System . class , vplex Uri ) ;  String vplex Id = vplex Uri . to String ( ) ; if ( vplex System != null ) { if ( ! vplex Pool Map . contains Key ( vplex Id ) ) {  List <  Storage Pool > vplex Pool List = new  Array List <  Storage Pool > ( ) ; vplex Pool List . add All ( pools By System . get ( system Uri ) ) ; vplex Pool Map . put ( vplex Id , vplex Pool List ) ; } else {  List <  Storage Pool > vplex Pool List = vplex Pool Map . get ( vplex Id ) ; vplex Pool List . add All ( pools By System . get ( system Uri ) ) ; } } } } return vplex Pool Map ; }
public static boolean can Player Afford Trading Fee (  Player player , int price ) {  Big Decimal fee = calculate Fee ( player , price ) ;  List <  Item > all Equipped = player . get All Equipped ( _ STR ) ; int owned Money = _ NUM ; for (  Item item : all Equipped ) {  Money m = (  Money ) item ; owned Money += m . get Quantity ( ) ; } return fee . int Value ( ) <= owned Money ; }
private void update Info ( ) { connect Address = broker Address Value . get Text ( ) ; will Topic = will Topic Value . get Text ( ) ; will Message = will Message Value . get Text ( ) ; client Id = client Id Value . get Text ( ) ; will Qos =  Integer . parse Int ( will Qos Drop . get Text ( ) ) ; will Retain = will Retain Check Box . get Selection ( ) ; username = username Value . get Text ( ) ; password = password Value . get Text ( ) ; try { connect Port =  Integer . parse Int ( broker Port Value . get Text ( ) ) ; } catch (  Number Format Exception e ) { } try { keep Alive =  Short . parse Short ( keep Alive Value . get Text ( ) ) ; } catch (  Number Format Exception e ) { } }
void load Cache ( ) { boolean worked = _ BOOL ;  Array List <  Source File > files = new  Array List <  Source File > ( ) ;  Swf Info [ ] swfs = get All Swfs ( ) ; for ( int i = _ NUM ; i < swfs . length ; i ++ ) { if ( swfs [ i ] != null ) worked = load Swf Files ( files , swfs [ i ] ) ? worked : _ BOOL ; }  Array List <  Source File > fa = trim File List ( files ) ; m_files = fa . to Array ( new  Source File [ fa . size ( ) ] ) ;  Arrays . sort ( m_files , this ) ; if ( worked ) m_swfs Loaded = swfs . length ; }
public static  String join ( boolean [ ] self ,  String separator ) {  String Builder buffer = new  String Builder ( ) ; boolean first = _ BOOL ; if ( separator == null ) separator = _ STR ; for ( boolean next : self ) { if ( first ) { first = _ BOOL ; } else { buffer . append ( separator ) ; } buffer . append ( next ) ; } return buffer . to String ( ) ; }
public  Query include (  Contact .  Field ... fields ) { include . clear ( ) ; include . add All (  Arrays . as List ( fields ) ) ; return this ; }
public  Stemmed String (  String orig ,  Char Sequence stemmed ) { str Orig = orig ; str Stemmed = stemmed . to String ( ) ; }
public  Log Stream Merger (  Log Request req ,  Log Svc Properties Loader properties Loader ) { logger . trace ( _ STR ) ; this . request = req ;  Log File Finder file Finder = new  Log File Finder ( properties Loader . get Log File Paths ( ) , properties Loader . get Excluded Log File Paths ( ) ) ;  Map <  String ,  List <  File > > grouped Log Files = file Finder . find Files Grouped By Base Name ( ) ;  List <  String > groups = req . get Base Names ( ) ; if ( groups == null || groups . is Empty ( ) ) { groups = new  Array List < > ( grouped Log Files . key Set ( ) ) ; } logger . debug ( _ STR , groups ) ; if ( groups . retain All ( grouped Log Files . key Set ( ) ) ) { logger . info ( _ STR , groups ) ; } int size = groups . size ( ) ; log Stream List = new  Log File Stream [ size ] ; log Heads = new  Log Message [ size ] ; for ( int i = _ NUM ; i < size ; i ++ ) {  String service = groups . get ( i ) ; log Stream List [ i ] = new  Log File Stream ( service , grouped Log Files . get ( service ) , req , status ) ; log Heads [ i ] = null ; } }
public static  String [ ] unpack Cipher Suites (  String ciphers ) { if ( ciphers == null ) return null ;  Vector c = new  Vector ( ) ; int i = ciphers . index Of ( _ STR ) ; int j = _ NUM ; while ( i > - _ NUM ) { c . add ( ciphers . substring ( j , i ) ) ; j = i + _ NUM ; i = ciphers . index Of ( _ STR , j ) ; } c . add ( ciphers . substring ( j ) ) ;  String [ ] s = new  String [ c . size ( ) ] ; c . to Array ( s ) ; return s ; }
public  Default File Filter (  String extension ,  String description ) { ext = extension . to Lower Case ( ) ; desc = description ; }
private boolean is Named Param (  String arg ) { return arg . starts With ( _ STR ) && ( arg . index Of ( _ STR ) > _ NUM && valid First Char ( arg . char At ( _ NUM ) ) ) ; }
Node clone Or Import Node ( short operation ,  Node node , boolean deep ) {  Node Impl copy = shallow Copy ( operation , node ) ; if ( deep ) {  Node List list = node . get Child Nodes ( ) ; for ( int i = _ NUM ; i < list . get Length ( ) ; i ++ ) { copy . append Child ( clone Or Import Node ( operation , list . item ( i ) , deep ) ) ; } } notify User Data Handlers ( operation , node , copy ) ; return copy ; }
private boolean does Match (  String pattern , int pp ,  String result , int rp ) { for ( ; ; ) { if ( pp == pattern . length ( ) && rp == result . length ( ) ) return _ BOOL ; if ( pp == pattern . length ( ) ) return _ BOOL ; char pc = pattern . char At ( pp ) ; if ( pc == _ STR ) { if ( rp == result . length ( ) ) return _ BOOL ; pp ++ ; rp ++ ; } else if ( pc == _ STR ) { if ( pp == pattern . length ( ) - _ NUM ) { return _ BOOL ; } for ( int sp = rp ; sp < result . length ( ) ; sp ++ ) { if ( does Match ( pattern , pp + _ NUM , result , sp ) ) { return _ BOOL ; } } return _ BOOL ; } else { if ( rp == result . length ( ) ) return _ BOOL ; if ( pc != result . char At ( rp ) ) { return _ BOOL ; } pp ++ ; rp ++ ; } } }
public static void columns For (  Result Set result Set ,  Consumer <  Column > consumer ) throws  SQLException {  Result Set Meta Data metadata = result Set . get Meta Data ( ) ;  Column Editor column =  Column . editor ( ) ; for ( int position = _ NUM ; position <= metadata . get Column Count ( ) ; ++ position ) {  String column Label = metadata . get Column Label ( position ) ; column . name ( column Label != null ? column Label : metadata . get Column Name ( position ) ) ; column . type ( metadata . get Column Type Name ( position ) ) ; column . jdbc Type ( metadata . get Column Type ( position ) ) ; column . length ( metadata . get Precision ( position ) ) ; column . scale ( metadata . get Scale ( position ) ) ; column . optional ( is Nullable ( metadata . is Nullable ( position ) ) ) ; column . auto Incremented ( metadata . is Auto Increment ( position ) ) ; column . generated ( _ BOOL ) ; consumer . accept ( column . create ( ) ) ; } }
private void write To File ( final  Input Stream input , final  File output ) throws  IOException { try (  File Writer writer = new  File Writer ( output ) ) {  Buffered Reader reader = new  Buffered Reader ( new  Input Stream Reader ( input ) ) ;  String line ; while ( ( line = reader . read Line ( ) ) != null ) { writer . write ( line ) ; writer . write (  EOL ) ; } } }
private void send File Info In New Session (  String file Transfer Id ,  String file Info ,  One To One File Transfer Impl one To One File Transfer ) throws  Payload Exception ,  Network Exception { long timestamp =  System . current Time Millis ( ) ; long timestamp Sent = timestamp ; m Messaging Log . set File Transfer Timestamps ( file Transfer Id , timestamp , timestamp Sent ) ;  Chat Message first Msg =  Chat Utils . create File Transfer Message ( get Remote Contact ( ) , file Info , file Transfer Id , timestamp , timestamp Sent ) ;  One To One Chat Session chat Session = m Im Service . create One To One Chat Session ( get Remote Contact ( ) , first Msg ) ; chat Session . start Session ( ) ; m Im Service . receive One One Chat Session Initiation ( chat Session ) ; one To One File Transfer . on File Info Dequeued ( get Remote Contact ( ) ) ; }
private final boolean add Direction (  Array List <  Move > move List ,  Position pos , int sq0 , int max Steps , int delta ) { int sq = sq0 ; boolean wtm = pos . white Move ; final int o King = ( wtm ?  Piece .  BKING :  Piece .  WKING ) ; while ( max Steps > _ NUM ) { sq += delta ; int p = pos . get Piece ( sq ) ; if ( p ==  Piece .  EMPTY ) { move List . add ( get Move Obj ( sq0 , sq ,  Piece .  EMPTY ) ) ; } else { if (  Piece . is White ( p ) != wtm ) { if ( p == o King ) { return Move List ( move List ) ; move List = get Move List Obj ( ) ; move List . add ( get Move Obj ( sq0 , sq ,  Piece .  EMPTY ) ) ; return _ BOOL ; } else { move List . add ( get Move Obj ( sq0 , sq ,  Piece .  EMPTY ) ) ; } } break ; } max Steps -- ; } return _ BOOL ; }
private void handle Static Stop Trees (  Static Metadata .  Stop Tree Request request ,  Transport Network transport Network ,  Task Statistics ts ) {  Static Metadata static Metadata = new  Static Metadata ( request . request , transport Network ) ; if ( request . request . bucket != null ) { try {  Output Stream os =  Static Data Store . get Output Stream ( request . request , _ STR , _ STR ) ; static Metadata . write Stop Trees ( os ) ; os . close ( ) ; } catch (  IOException e ) {  LOG . error ( _ STR , e ) ; } delete Request ( request ) ; } else { try {  Piped Input Stream pis = new  Piped Input Stream ( ) ;  Piped Output Stream pos = new  Piped Output Stream ( pis ) ; finish Priority Task ( request , pis ) ; static Metadata . write Stop Trees ( pos ) ; pos . close ( ) ; } catch (  IOException e ) {  LOG . error ( _ STR , e ) ; } } }
public synchronized void add Room (  String room ) { if ( !  Helper . validate Stream ( room ) ) { return ; } connect ( ) ; room = room . to Lower Case ( ) ; if ( rooms . add ( room ) ) { sub Room ( room ) ; } }
public void remove All ( final  Collection elements ) { adjusting = _ BOOL ;  Set old Selection = new  Hash Set ( selection ) ; boolean rv = selection . remove All ( elements ) ; adjusting = _ BOOL ; if ( rv ) { fire Selection Changed ( old Selection , selection ) ; } }
@  Override public boolean has Feature (  String feature ,  String version ) { boolean result = super . has Feature ( feature , version ) ; if ( ! result ) { boolean any Version = version == null || version . length ( ) == _ NUM ; if ( feature . starts With ( _ STR ) ) { feature = feature . substring ( _ NUM ) ; } return ( ( feature . equals Ignore Case ( _ STR ) && ( any Version || version . equals ( _ STR ) ) ) || ( feature . equals Ignore Case ( _ STR ) && ( any Version || version . equals ( _ STR ) ) ) || ( feature . equals Ignore Case ( _ STR ) && ( any Version || version . equals ( _ STR ) ) ) || ( feature . equals Ignore Case ( _ STR ) && ( any Version || version . equals ( _ STR ) ) ) || ( feature . equals Ignore Case ( _ STR ) && ( any Version || version . equals ( _ STR ) ) ) ) ; } return result ; }
public  Set <  Integer > primary Partitions (  UUID node Id ) {  Set <  Integer > set = primary . get ( node Id ) ; return set == null ?  Collections . <  Integer > empty Set ( ) : set ; }
public java . lang .  String Buffer insert ( int offset , java . lang .  Object obj ) { internal . insert ( offset , obj ) ; return this ; }
Resource Thread (  String image Url ,  Component img Label ,  HTMLComponent html C ,  Resource Thread Queue thread Queue ) { this . image Url = image Url ; this . img Label = img Label ; this . handler = html C . get Request Handler ( ) ; this . thread Queue = thread Queue ; this . html C = html C ; }
private void inverse ( double [ ] rinv , int nreq ) { int pos = nreq * ( nreq - _ NUM ) / _ NUM - _ NUM ; int pos1 = - _ NUM ; int pos2 = - _ NUM ; double total = _ NUM ;  Arrays . fill ( rinv ,  Double .  Na N ) ; for ( int row = nreq - _ NUM ; row > _ NUM ; -- row ) { if ( ! this . lindep [ row ] ) { final int start = ( row - _ NUM ) * ( nvars + nvars - row ) / _ NUM ; for ( int col = nreq ; col > row ; -- col ) { pos1 = start ; pos2 = pos ; total = _ NUM ; for ( int k = row ; k < col - _ NUM ; k ++ ) { pos2 += nreq - k - _ NUM ; if ( ! this . lindep [ k ] ) { total += - r [ pos1 ] * rinv [ pos2 ] ; } ++ pos1 ; } rinv [ pos ] = total - r [ pos1 ] ; -- pos ; } } else { pos -= nreq - row ; } } }
public  Bidi (  Attributed Character Iterator paragraph ) { if ( paragraph == null ) { throw new  Illegal Argument Exception ( _ STR ) ; } bidi Base = new  Bidi Base ( _ NUM , _ NUM ) ; bidi Base . set Para ( paragraph ) ; }
public static  Array List <  File > list All Files (  File folder ) {  Array List <  File > list = new  Array List <  File > ( ) ; if ( ! folder . exists ( ) || folder . list Files ( ) == null || folder . list Files ( ) . length <= _ NUM || ! folder . can Read ( ) ) { return list ; }  File [ ] listf = folder . list Files ( ) ; for (  File f : listf ) { if ( f . is File ( ) ) { list . add ( f ) ; } else { if ( list All Files ( f ) != null ) for (  File f1 : list All Files ( f ) ) { list . add ( f1 ) ; } } } return list ; }
protected void fill Kernel Ordinates (  Complex Array ordinates , double band Width ) { final int length = ordinates . length ; final double a = _ NUM / (  Math . sqrt ( _ NUM *  Math .  PI ) * band Width ) ; final double precision = - _ NUM / ( band Width * band Width ) ; for ( int i = _ NUM ; i < length ; i ++ ) { final double x = ordinates . real [ i ] ; ordinates . real [ i ] = a *  Math . exp ( x * x * precision ) ; } }
public static void migrate Downloads (  Properties ctx ) {  String sql = _ STR ; int no =  DB . get SQLValue ( null , sql ) ; if ( no > _ NUM ) return ; int count = _ NUM ; sql = _ STR + _ STR + _ STR ;  Prepared Statement pstmt = null ; try { pstmt =  DB . prepare Statement ( sql , null ) ;  Result Set rs = pstmt . execute Query ( ) ; while ( rs . next ( ) ) { int  AD_ Client_ ID = rs . get Int ( _ NUM ) ; int  AD_ Org_ ID = rs . get Int ( _ NUM ) ; int  M_ Product_ ID = rs . get Int ( _ NUM ) ;  String  Name = rs . get String ( _ NUM ) ;  String  Download URL = rs . get String ( _ NUM ) ;  MProduct Download pdl = new  MProduct Download ( ctx , _ NUM , null ) ; pdl . set Client Org (  AD_ Client_ ID ,  AD_ Org_ ID ) ; pdl . set M_ Product_ ID (  M_ Product_ ID ) ; pdl . set Name (  Name ) ; pdl . set Download URL (  Download URL ) ; if ( pdl . save ( ) ) { count ++ ;  String sql Update = _ STR +  M_ Product_ ID ; int updated =  DB . execute Update ( sql Update , null ) ; if ( updated != _ NUM ) s_log . warning ( _ STR ) ; } else s_log . warning ( _ STR +  M_ Product_ ID ) ; } rs . close ( ) ; pstmt . close ( ) ; pstmt = null ; } catch (  Exception e ) { s_log . log (  Level .  SEVERE , sql , e ) ; } try { if ( pstmt != null ) pstmt . close ( ) ; pstmt = null ; } catch (  Exception e ) { pstmt = null ; } s_log . info ( _ STR + count ) ; }
public  All Stats Table Single (  Dataset Generator dataset Generator ,  Locker locker ) {  Argument Checking . not Null ( dataset Generator , _ STR ) ; init Components ( ) ; table . set Default Renderer (  JLabel . class , new  Renderer ( ) ) ; table . set Column Selection Allowed ( _ BOOL ) ; table . set Row Selection Allowed ( _ BOOL ) ;  JTable Header header = table . get Table Header ( ) ; header . set Reordering Allowed ( _ BOOL ) ;  GUIUtilities . set Table Header ( header ) ; model = new  Model ( dataset Generator ) ; table . set Model ( model ) ; this . locker = locker ; }
public void download (  String remote File Name ,  File local File , long restart At ,  FTPData Transfer Listener listener ) throws  Illegal State Exception ,  File Not Found Exception ,  IOException ,  FTPIllegal Reply Exception ,  FTPException ,  FTPData Transfer Exception ,  FTPAborted Exception {  Output Stream output Stream = null ; try { output Stream = new  File Output Stream ( local File , restart At > _ NUM ) ; } catch (  IOException e ) { throw new  FTPData Transfer Exception ( e ) ; } try { download ( remote File Name , output Stream , restart At , listener ) ; } catch (  Illegal State Exception e ) { throw e ; } catch (  IOException e ) { throw e ; } catch (  FTPIllegal Reply Exception e ) { throw e ; } catch (  FTPException e ) { throw e ; } catch (  FTPData Transfer Exception e ) { throw e ; } catch (  FTPAborted Exception e ) { throw e ; } finally { if ( output Stream != null ) { try { output Stream . close ( ) ; } catch (  Throwable t ) { ; } } } }
public static boolean is Maven Module (  String name ) { return name != null && name . index Of ( _ STR ) != - _ NUM ; }
public void load ( ) throws  File Not Found Exception ,  IOException {  Buffered Reader is = new  Buffered Reader ( new  Input Stream Reader ( new  File Input Stream ( file ) ) ) ;  Array List <  String > buf = new  Array List < > ( ) ; while ( is . ready ( ) ) {  String line = is . read Line ( ) ; if ( line . starts With (  COMMENT_ PREFIX ) ) { continue ; } if ( line . length ( ) == _ NUM && ! buf . is Empty ( ) ) {  String title = buf . remove ( _ NUM ) ; store . add ( new  Pair < > ( title , buf ) ) ; buf = new  Array List < > ( ) ; } else { buf . add ( line ) ; } } if ( ! buf . is Empty ( ) ) {  String title = buf . remove ( _ NUM ) ; store . add ( new  Pair < > ( title , buf ) ) ; buf = new  Array List < > ( ) ; } is . close ( ) ; }
private void load Properties ( ) {  String property =  System . get Property ( _ STR ) ; if ( null == property ) { property =  Carbon Common Constants .  CARBON_ PROPERTIES_ FILE_ PATH ; }  File file = new  File ( property ) ;  LOGGER . info ( _ STR + file . get Absolute Path ( ) ) ;  File Input Stream fis = null ; try { if ( file . exists ( ) ) { fis = new  File Input Stream ( file ) ; carbon Properties . load ( fis ) ; } } catch (  File Not Found Exception e ) {  LOGGER . error ( _ STR +  Carbon Common Constants .  CARBON_ PROPERTIES_ FILE_ PATH + _ STR ) ; } catch (  IOException e ) {  LOGGER . error ( _ STR +  Carbon Common Constants .  CARBON_ PROPERTIES_ FILE_ PATH ) ; } finally { if ( null != fis ) { try { fis . close ( ) ; } catch (  IOException e ) {  LOGGER . error ( _ STR +  Carbon Common Constants .  CARBON_ PROPERTIES_ FILE_ PATH ) ; } } } print ( ) ; }
public void to EPL (  String Writer writer ) { writer . write ( _ STR ) ; writer . write ( window Name ) ;  Projected Stream . to EPLViews ( writer , views ) ; }
protected void clear Intent Or Intent Filter ( ) { m Actions . clear ( ) ; m Add Action Button . set Enabled ( _ BOOL ) ; m Categories . clear ( ) ; m Data Schemes . clear ( ) ; m Data Types . clear ( ) ; }
public void add Generic Attr (  Generic Attr g ) { generic . add Element ( g ) ; g . resolve ( this ) ; }
private void update Targets In Export Mask (  Storage System storage ,  Volume volume ,  Map <  Volume ,  Map <  String ,  List <  String > > > volume To Initiator Target Map From Attach Response ,  List <  Initiator > fc Initiator List ,  Export Mask export Mask ) throws  Exception { log . debug ( _ STR ) ;  Map <  URI ,  List <  URI > > map Filtered Initiator URIVs Target URIList = new  Hash Map <  URI ,  List <  URI > > ( ) ;  Map <  String ,  URI > initiators WWNVs URI = get WWNvs URIFCInitiators Map ( fc Initiator List ) ;  URI varray URI = volume . get Virtual Array ( ) ;  Map <  String ,  URI > map Varray Tagged Port WWNVs URI = get Varray Tagged Storage Port WWNs ( storage , varray URI ) ;  Set <  String > varray Tagged Port WWNs = map Varray Tagged Port WWNVs URI . key Set ( ) ;  URI vpool URI = volume . get Virtual Pool ( ) ;  Virtual Pool vpool = db Client . query Object (  Virtual Pool . class , vpool URI ) ; int paths Per Initiator = vpool . get Paths Per Initiator ( ) ;  Set <  Volume > volume Keys Set = volume To Initiator Target Map From Attach Response . key Set ( ) ; for (  Volume volume Res : volume Keys Set ) { log . info (  String . format ( _ STR , volume Res . get Id ( ) , volume Res . get Label ( ) ) ) ;  Map <  String ,  List <  String > > initiator Target Map = volume To Initiator Target Map From Attach Response . get ( volume Res ) ;  Set <  String > initiator Keys Set = initiator Target Map . key Set ( ) ; for (  String initiator Key : initiator Keys Set ) {  List <  String > filtered Target List = filter Targets From Response ( varray Tagged Port WWNs , initiator Target Map , initiator Key ) ; log . info (  String . format ( _ STR , initiator Key , filtered Target List . to String ( ) ) ) ;  List <  String > tmp Target List = null ; if ( ! is Vplex ( volume Res ) ) { tmp Target List = check Paths Per Initiator ( paths Per Initiator , filtered Target List ) ; if ( null == tmp Target List ) { throw new  Exception (  String . format ( _ STR + _ STR , initiator Key ,  String . value Of ( filtered Target List . size ( ) ) ,  String . value Of ( paths Per Initiator ) ) ) ; } } else { tmp Target List = filtered Target List ; } populate Initiator Target URIMap ( map Filtered Initiator URIVs Target URIList , initiators WWNVs URI , map Varray Tagged Port WWNVs URI , initiator Key , tmp Target List ) ; } }  List <  URI > storage Port List From Mask =  String Set Util . string Set To Uri List ( export Mask . get Storage Ports ( ) ) ; for (  URI remove Uri : storage Port List From Mask ) { export Mask . remove Target ( remove Uri ) ; } export Mask . set Storage Ports ( null ) ;  Set <  URI > initiator URIKeys = map Filtered Initiator URIVs Target URIList . key Set ( ) ; for (  URI initiator URI : initiator URIKeys ) {  List <  URI > storage Port URIList = map Filtered Initiator URIVs Target URIList . get ( initiator URI ) ; for (  URI port URI : storage Port URIList ) { export Mask . add Target ( port URI ) ; } } log . debug ( _ STR ) ; }
public void test Hash Generaton ( ) { check Hash ( _ STR , - _ NUM ) ; check Hash ( _ STR , - _ NUM ) ; check Hash ( _ STR , - _ NUM ) ; check Hash ( _ STR , - _ NUM ) ; check Hash ( _ STR , - _ NUM ) ; check Hash ( _ BOOL , _ NUM ) ; check Hash ( _ BOOL , - _ NUM ) ; check Hash ( _ NUM , _ NUM ) ; check Hash ( _ NUM , - _ NUM ) ; check Hash ( _ NUM , _ NUM ) ; check Hash ( _ NUM , - _ NUM ) ; check Hash ( _ NUM , _ NUM ) ; check Hash ( _ NUM , - _ NUM ) ; check Hash ( _ NUM , _ NUM ) ; check Hash ( _ NUM , _ NUM ) ; check Hash ( _ NUM , _ NUM ) ; check Hash ( _ NUM , - _ NUM ) ; check Hash (  UUID . from String ( _ STR ) , - _ NUM ) ; check UUID ( _ STR , _ NUM ) ; check UUID ( _ STR , - _ NUM ) ; check UUID ( _ STR , - _ NUM ) ; check UUID ( _ STR , - _ NUM ) ; check UUID ( _ STR , - _ NUM ) ; check UUID ( _ STR , - _ NUM ) ; check UUID ( _ STR , - _ NUM ) ; }
public  Caching Stream ( ) throws  IOException { super ( null ) ;  Path temp File =  Default Filepaths . create Temp File ( _ STR , null ) ; channel =  Files . new Byte Channel ( temp File ,  Standard Open Option .  CREATE ,  Standard Open Option .  WRITE ,  Standard Open Option .  TRUNCATE_ EXISTING ,  Standard Open Option .  READ ,  Standard Open Option .  DELETE_ ON_ CLOSE ) ; out =  Channels . new Output Stream ( channel ) ; }
boolean check Server Up (  String server Id ) { if ( ( server Id == null ) || ( server Id . is Empty ( ) ) ) { return _ BOOL ; } if ( server Id . equals Ignore Case ( local Server Id ) ) { return _ BOOL ; } if ( ( servers == null ) || servers . is Empty ( ) ) { return _ BOOL ; }  State Info info = servers . get ( server Id ) ; info . is Up = check Server Up ( info ) ; return info . is Up ; }
private void write Object (  Object Output Stream p_stream ) throws  IOException { p_stream . default Write Object ( ) ; item_color_table . write_object ( p_stream ) ; other_color_table . write_object ( p_stream ) ; }
public  Mock Low Level Http Response add Header (  String name ,  String value ) { header Names . add (  Preconditions . check Not Null ( name ) ) ; header Values . add (  Preconditions . check Not Null ( value ) ) ; return this ; }
public static double standard Normal Cdf ( double x ) { double a = ( x ) / (  Math . sqrt ( _ NUM ) ) ; return _ NUM * ( _ NUM +  Error Function . erf ( a ) ) ; }
public void update Result (  String name ) {  String Buffer buff = m_ Results . get ( name ) ; if ( buff == null ) { return ; } if ( m_ Single Name == name ) { m_ Single Text . set Text ( buff . to String ( ) ) ; }  JText Component current Text = m_ Framed Output . get ( name ) ; if ( current Text != null ) { current Text . set Text ( buff . to String ( ) ) ; } }
private synchronized void manage Menu ( ) { if ( ( game != null ) || ( has Board && ( null == client ) ) ) { file Game New . set Enabled ( _ BOOL ) ; file Game Open . set Enabled ( _ BOOL ) ; file Game Scenario . set Enabled ( _ BOOL ) ; file Game Connect Bot . set Enabled ( _ BOOL ) ; file Game Connect . set Enabled ( _ BOOL ) ; replace Player . set Enabled ( _ BOOL ) ; if ( ( phase !=  IGame .  Phase .  PHASE_ UNKNOWN ) && ( phase !=  IGame .  Phase .  PHASE_ LOUNGE ) && ( phase !=  IGame .  Phase .  PHASE_ SELECTION ) && ( phase !=  IGame .  Phase .  PHASE_ EXCHANGE ) && ( phase !=  IGame .  Phase .  PHASE_ VICTORY ) && ( phase !=  IGame .  Phase .  PHASE_ STARTING_ SCENARIO ) ) { file Game Save . set Enabled ( _ BOOL ) ; file Game Save Server . set Enabled ( _ BOOL ) ; replace Player . set Enabled ( _ BOOL ) ; } else { file Game Save . set Enabled ( _ BOOL ) ; file Game Save Server . set Enabled ( _ BOOL ) ; replace Player . set Enabled ( _ BOOL ) ; } } else { file Game New . set Enabled ( _ BOOL ) ; file Game Open . set Enabled ( _ BOOL ) ; file Game Save . set Enabled ( _ BOOL ) ; file Game Save Server . set Enabled ( _ BOOL ) ; file Game Scenario . set Enabled ( _ BOOL ) ; file Game Connect Bot . set Enabled ( _ BOOL ) ; file Game Connect . set Enabled ( _ BOOL ) ; replace Player . set Enabled ( _ BOOL ) ; } if ( game != null ) { view Game Options . set Enabled ( _ BOOL ) ; view Player Settings . set Enabled ( _ BOOL ) ; } else { view Game Options . set Enabled ( _ BOOL ) ; view Player Settings . set Enabled ( _ BOOL ) ; } file Print . set Enabled ( _ BOOL ) ; if ( client != null ) { file Board New . set Enabled ( _ BOOL ) ; file Board Open . set Enabled ( _ BOOL ) ; file Board Save . set Enabled ( _ BOOL ) ; file Board Save As . set Enabled ( _ BOOL ) ; file Board Save As Image . set Enabled ( _ BOOL ) ; } else { file Board New . set Enabled ( _ BOOL ) ; file Board Open . set Enabled ( _ BOOL ) ; file Board Save . set Enabled ( _ BOOL ) ; file Board Save As . set Enabled ( _ BOOL ) ; file Board Save As Image . set Enabled ( _ BOOL ) ; } if ( has Board ) { file Board Save . set Enabled ( _ BOOL ) ; file Board Save As . set Enabled ( _ BOOL ) ; file Board Save As Image . set Enabled ( _ BOOL ) ; view Mini Map . set Enabled ( _ BOOL ) ; view Zoom In . set Enabled ( _ BOOL ) ; view Zoom Out . set Enabled ( _ BOOL ) ; } else { file Board Save . set Enabled ( _ BOOL ) ; file Board Save As . set Enabled ( _ BOOL ) ; file Board Save As Image . set Enabled ( _ BOOL ) ; view Mini Map . set Enabled ( _ BOOL ) ; view Zoom In . set Enabled ( _ BOOL ) ; view Zoom Out . set Enabled ( _ BOOL ) ; } if ( has Unit List ) { file Units Open . set Enabled ( phase ==  IGame .  Phase .  PHASE_ LOUNGE ) ; file Units Clear . set Enabled ( phase ==  IGame .  Phase .  PHASE_ LOUNGE ) ; } else { file Units Open . set Enabled ( phase ==  IGame .  Phase .  PHASE_ LOUNGE ) ; file Units Clear . set Enabled ( _ BOOL ) ; } file Units Reinforce . set Enabled ( phase !=  IGame .  Phase .  PHASE_ LOUNGE ) ; file Units Reinforce RAT . set Enabled ( phase !=  IGame .  Phase .  PHASE_ LOUNGE ) ; if ( entity != null ) { view Mek Display . set Enabled ( _ BOOL ) ; } else { view Mek Display . set Enabled ( _ BOOL ) ; } if ( ( client == null ) && has Board ) { view LOSSetting . set Enabled ( _ BOOL ) ; view Unit Overview . set Enabled ( _ BOOL ) ; view Player List . set Enabled ( _ BOOL ) ; } else if ( ( phase ==  IGame .  Phase .  PHASE_ SET_ ARTYAUTOHITHEXES ) || ( phase ==  IGame .  Phase .  PHASE_ DEPLOY_ MINEFIELDS ) || ( phase ==  IGame .  Phase .  PHASE_ MOVEMENT ) || ( phase ==  IGame .  Phase .  PHASE_ FIRING ) || ( phase ==  IGame .  Phase .  PHASE_ PHYSICAL ) || ( phase ==  IGame .  Phase .  PHASE_ OFFBOARD ) || ( phase ==  IGame .  Phase .  PHASE_ TARGETING ) || ( phase ==  IGame .  Phase .  PHASE_ DEPLOYMENT ) ) { view LOSSetting . set Enabled ( _ BOOL ) ; view Mini Map . set Enabled ( _ BOOL ) ; view Zoom In . set Enabled ( _ BOOL ) ; view Zoom Out . set Enabled ( _ BOOL ) ; view Unit Overview . set Enabled ( _ BOOL ) ; view Player List . set Enabled ( _ BOOL ) ; } else { view LOSSetting . set Enabled ( _ BOOL ) ; view Mini Map . set Enabled ( _ BOOL ) ; view Zoom In . set Enabled ( _ BOOL ) ; view Zoom Out . set Enabled ( _ BOOL ) ; view Unit Overview . set Enabled ( _ BOOL ) ; view Player List . set Enabled ( _ BOOL ) ; } if ( ( phase ==  IGame .  Phase .  PHASE_ INITIATIVE ) || ( phase ==  IGame .  Phase .  PHASE_ MOVEMENT ) || ( phase ==  IGame .  Phase .  PHASE_ FIRING ) || ( phase ==  IGame .  Phase .  PHASE_ PHYSICAL ) || ( phase ==  IGame .  Phase .  PHASE_ OFFBOARD ) || ( phase ==  IGame .  Phase .  PHASE_ TARGETING ) || ( phase ==  IGame .  Phase .  PHASE_ END ) || ( phase ==  IGame .  Phase .  PHASE_ DEPLOYMENT ) ) { view Round Report . set Enabled ( _ BOOL ) ; } else { view Round Report . set Enabled ( _ BOOL ) ; } view Client Settings . set Enabled ( _ BOOL ) ; if ( ( phase !=  IGame .  Phase .  PHASE_ FIRING ) || ( entity == null ) ) { fire Cancel . set Enabled ( _ BOOL ) ; } else { fire Cancel . set Enabled ( _ BOOL ) ; } update Save Weapon Order Menu Item ( ) ; }
public  Instance sample (  Random random ) { double [ ] center = get Center ( ) ; final int dimensions = center . length ; final double sin [ ] = new double [ dimensions - _ NUM ] ; final double cos [ ] = new double [ dimensions - _ NUM ] ; final double length = random . next Double ( ) * get Radius ( ) ; double last Value = _ NUM ; for ( int i = _ NUM ; i < dimensions - _ NUM ; i ++ ) { double angle = random . next Double ( ) * _ NUM *  Math .  PI ; sin [ i ] = last Value *  Math . sin ( angle ) ; cos [ i ] =  Math . cos ( angle ) ; last Value = sin [ i ] ; } double res [ ] = new double [ dimensions ] ; res [ _ NUM ] = center [ _ NUM ] + length * cos [ _ NUM ] ; for ( int i = _ NUM ; i < dimensions - _ NUM ; i ++ ) { res [ i ] = center [ i ] + length * sin [ i - _ NUM ] * cos [ i ] ; } res [ dimensions - _ NUM ] = center [ dimensions - _ NUM ] + length * sin [ dimensions - _ NUM ] ; return new  Dense Instance ( _ NUM , res ) ; }
public  DExport Key Pair (  JFrame parent ,  String entry Alias ,  Password Quality Config password Quality Config ) { super ( parent ,  Dialog .  Modality Type .  DOCUMENT_ MODAL ) ; this . entry Alias = entry Alias ; this . password Quality Config = password Quality Config ; init Components ( ) ; }
public  SQLQuery (  Class <  T > type ,  String sql Expression ) { this ( sql Expression , type . get Name ( ) , null ,  DEFAULT_ QUERY_ RESULT_ TYPE , null ) ; }
public  Rect update Fast Scroller Bounds ( int last Touch Y ) { m Invalidate Rect . set ( m Bg Bounds ) ; if ( is Visible ( ) ) { int edge Padding = m Rv . get Max Scrollbar Width ( ) ; int bg Padding = ( m Bg Original Size - m Text Bounds . height ( ) ) / _ NUM ; int bg Height = m Bg Original Size ; int bg Width =  Math . max ( m Bg Original Size , m Text Bounds . width ( ) + ( _ NUM * bg Padding ) ) ; if (  Utilities . is Rtl ( m Res ) ) { m Bg Bounds . left = m Rv . get Background Padding ( ) . left + ( _ NUM * m Rv . get Max Scrollbar Width ( ) ) ; m Bg Bounds . right = m Bg Bounds . left + bg Width ; } else { m Bg Bounds . right = m Rv . get Width ( ) - m Rv . get Background Padding ( ) . right - ( _ NUM * m Rv . get Max Scrollbar Width ( ) ) ; m Bg Bounds . left = m Bg Bounds . right - bg Width ; } m Bg Bounds . top = last Touch Y - ( int ) (  FAST_ SCROLL_ OVERLAY_ Y_ OFFSET_ FACTOR * bg Height ) ; m Bg Bounds . top =  Math . max ( edge Padding ,  Math . min ( m Bg Bounds . top , m Rv . get Height ( ) - edge Padding - bg Height ) ) ; m Bg Bounds . bottom = m Bg Bounds . top + bg Height ; } else { m Bg Bounds . set Empty ( ) ; } m Invalidate Rect . union ( m Bg Bounds ) ; return m Invalidate Rect ; }
public  Vector2 rotate ( float angle ) { float rad = angle *  Math Utils . degrees To Radians ; float cos = ( float )  Math . cos ( rad ) ; float sin = ( float )  Math . sin ( rad ) ; float new X = this . x * cos - this . y * sin ; float new Y = this . x * sin + this . y * cos ; this . x = new X ; this . y = new Y ; return this ; }
private void write File (  List <  String > lines ,  File file ) throws  Exception { try (  Print Writer writer = new  Print Writer ( new  File Output Stream ( file ) ) ) { for (  String line : lines ) { writer . println ( line ) ; } } }
public static  String now ( ) {  Calendar cal =  Calendar . get Instance ( ) ;  Simple Date Format sdf = new  Simple Date Format ( _ STR ) ; return sdf . format ( cal . get Time ( ) ) ; }
public void init (  Context context ) throws  Lib Vlc Exception {  Log . v (  TAG , _ STR ) ; if ( ! m Is Initialized ) { if ( !  Lib Vlc Util . has Compatible CPU ( context ) ) {  Log . e (  TAG ,  Lib Vlc Util . get Error Msg ( ) ) ; throw new  Lib Vlc Exception ( ) ; }  File cache Dir = context . get Cache Dir ( ) ; m Cache Path = ( cache Dir != null ) ? cache Dir . get Absolute Path ( ) : null ; native Init ( ) ; set Event Handler (  Event Handler . get Instance ( ) ) ; m Is Initialized = _ BOOL ; } }
@  Override public  Enumeration <  Option > list Options ( ) {  Vector <  Option > new Vector = new  Vector <  Option > ( _ NUM ) ; new Vector . add Element ( new  Option ( _ STR , _ STR , _ NUM , _ STR ) ) ; new Vector . add Element ( new  Option ( _ STR + _ STR , _ STR , _ NUM , _ STR ) ) ; new Vector . add Element ( new  Option ( _ STR , _ STR , _ NUM , _ STR ) ) ; new Vector . add Element ( new  Option ( _ STR , _ STR , _ NUM , _ STR ) ) ; return new Vector . elements ( ) ; }
public boolean remove Entry ( int x Index , int data Set Index ) { if ( data Set Index >= m Data Sets . size ( ) ) return _ BOOL ;  T data Set = m Data Sets . get ( data Set Index ) ;  Entry e = data Set . get Entry For XIndex ( x Index ) ; if ( e == null || e . get XIndex ( ) != x Index ) return _ BOOL ; return remove Entry ( e , data Set Index ) ; }
private void write File (  File file , byte [ ] input ,  Compression Mode mode ) throws  IOException { try (  Output Stream os = get Output Stream For Mode ( mode , new  File Output Stream ( file ) ) ) { os . write ( input ) ; } }
public static void close ( @  Nullable  Selector rsrc , @  Nullable  Ignite Logger log ) { if ( rsrc != null ) try { if ( rsrc . is Open ( ) ) rsrc . close ( ) ; } catch (  IOException e ) { warn ( log , _ STR + e . get Message ( ) ) ; } }
public  Writable Raster create Compatible Writable Raster ( int w , int h ) { if ( w <= _ NUM || h <= _ NUM ) { throw new  Raster Format Exception ( _ STR + ( ( w <= _ NUM ) ? _ STR : _ STR ) ) ; }  Sample Model sm = sample Model . create Compatible Sample Model ( w , h ) ; return new  Short Interleaved Raster ( sm , new  Point ( _ NUM , _ NUM ) ) ; }
public static  String [ ] executor Command (  Config config ,  Config runtime , int container Index ,  List <  Integer > free Ports ) { if ( free Ports . size ( ) <  PORTS_ REQUIRED_ FOR_ EXECUTOR ) { throw new  Runtime Exception ( _ STR ) ; } for ( int port : free Ports ) { if ( port == - _ NUM ) { throw new  Runtime Exception ( _ STR ) ; } }  List <  String > ports = new  Linked List < > ( ) ; for ( int port : free Ports ) { ports . add (  Integer . to String ( port ) ) ; } return get Executor Command ( config , runtime , container Index , ports ) ; }
public  Update Request add ( final  Collection <  Solr Input Document > docs ) { if ( documents == null ) { documents = new  Linked Hash Map < > ( ) ; } for (  Solr Input Document doc : docs ) {  Objects . require Non Null ( doc , _ STR ) ; documents . put ( doc , null ) ; } return this ; }
protected  Key engine Translate Key (  Key key ) throws  Invalid Key Exception { if ( key == null ) { throw new  Invalid Key Exception ( _ STR ) ; }  String key Alg = key . get Algorithm ( ) ; if ( key Alg . equals ( _ STR ) == _ BOOL ) { throw new  Invalid Key Exception ( _ STR + key Alg ) ; } if ( key instanceof  Public Key ) { return translate Public Key ( (  Public Key ) key ) ; } else if ( key instanceof  Private Key ) { return translate Private Key ( (  Private Key ) key ) ; } else { throw new  Invalid Key Exception ( _ STR ) ; } }
public  Builder ( ) { }
@  Override public final void add Bezier Curve C ( final float x , final float y , final float x2 , final float y2 , final float x3 , final float y3 ) { elements . add ( new  Cubic Curve To ( x , y , x2 , y2 , x3 , y3 ) ) ; current Pos [ _ NUM ] = x3 ; current Pos [ _ NUM ] = y3 ; }
private void save Bucket (  Auto Mix Bucket bucket ) { if ( ! bucket . is Playlist Session Error ( ) ) {  Shared Preferences prefs = get Prefs ( ) ;  Shared Preferences .  Editor editor = prefs . edit ( ) ; final  String id = bucket . get Session Id ( ) ; if ( id != null ) { editor . put String (  PREF_ PREFIX_ NAME + id , bucket . m Name ) ; editor . put Float (  PREF_ PREFIX_ ADVENTUROUS + id , bucket . m Adventurousness ) ; editor . put Float (  PREF_ PREFIX_ ENERGY + id , bucket . m Energy ) ; editor . put Float (  PREF_ PREFIX_ FAMILIAR + id , bucket . m Familiar ) ; editor . put String (  PREF_ PREFIX_ MOODS + id ,  Utils . implode ( bucket . m Moods , _ STR ) ) ; editor . put String (  PREF_ PREFIX_ SONG_ TYPES + id ,  Utils . implode ( bucket . m Song Types , _ STR ) ) ; editor . put Float (  PREF_ PREFIX_ SPEECHINESS + id , bucket . m Speechiness ) ; editor . put String (  PREF_ PREFIX_ STYLES + id ,  Utils . implode ( bucket . m Styles , _ STR ) ) ; editor . put Boolean (  PREF_ PREFIX_ TASTE + id , bucket . m Use Taste ) ;  Set <  String > set = new  Tree Set < > ( prefs . get String Set (  PREF_ BUCKETS_ IDS , new  Tree Set <  String > ( ) ) ) ; set . add ( id ) ; editor . put String Set (  PREF_ BUCKETS_ IDS , set ) ; editor . apply ( ) ; } } else {  Log . e (  TAG , _ STR ) ; } }
@  Override public void accept Offer (  Offer offer ) { future Accepted Offers . on Next ( offer ) ; offers . remove ( offer ) ; accepted Offers . add ( offer ) ; }
private void inject Dependencies ( ) {  Sample Application easy MVPApplication = (  Sample Application ) get Application ( ) ;  List <  Object > activity Scope Modules = ( get Modules ( ) != null ) ? get Modules ( ) : new  Array List < > ( ) ; activity Scope Modules . add ( new  Activity Module ( this ) ) ; activity Scope Modules . add ( new  Presenter Module ( ) ) ; activity Scope Graph = easy MVPApplication . build Graph With Aditional Modules ( activity Scope Modules ) ; inject ( this ) ; }
public synchronized void read Request ( ) { if ( current Writers == _ NUM && writer Locks . size ( ) == _ NUM ) { ++ current Readers ; } else { ++ queued Readers ; try { wait ( ) ; } catch (  Interrupted Exception e ) { } } }
public long read UTCDate ( ) throws  IOException { expect Start Tag ( _ STR ) ; if ( utc Calendar == null ) utc Calendar =  Calendar . get Instance (  Time Zone . get Time Zone ( _ STR ) ) ; long value = parse Date ( utc Calendar ) ; expect End Tag ( _ STR ) ; return value ; }
public void remove Selection Listener ( final  Selection Listener listener ) { check Widget ( ) ; if ( listener == null ) {  SWT . error (  SWT .  ERROR_ NULL_ ARGUMENT ) ; } selection Listeners . remove ( listener ) ; }
public  String read File Content (  File file ) {  String Builder file Content Builder = new  String Builder ( ) ; if ( file . exists ( ) ) {  String string Line ; try {  File Reader file Reader = new  File Reader ( file ) ;  Buffered Reader buffered Reader = new  Buffered Reader ( file Reader ) ; boolean new Line = _ BOOL ; while ( ( string Line = buffered Reader . read Line ( ) ) != null ) { if ( new Line ) { file Content Builder . append ( _ STR ) ; } file Content Builder . append ( string Line ) ; new Line = _ BOOL ; } buffered Reader . close ( ) ; file Reader . close ( ) ; } catch (  File Not Found Exception e ) { e . print Stack Trace ( ) ; } catch (  IOException e ) { e . print Stack Trace ( ) ; } } return file Content Builder . to String ( ) ; }
public boolean revision Contains Template Names ( int rev Id ,  List <  String > template Names ) throws  Wiki Api Exception {  List <  String > tpl List = get Template Names From Revision ( rev Id ) ; for (  String tpl : tpl List ) { for (  String template Name : template Names ) { if ( tpl . equals Ignore Case ( template Name ) ) { return _ BOOL ; } } } return _ BOOL ; }
private static boolean within Three (  INode n ,  INode goal ) {  Double Linked List <  IMove > moves = n . valid Moves ( ) ; for (  Iterator <  IMove > it = moves . iterator ( ) ; it . has Next ( ) ; ) {  IMove move = it . next ( ) ;  INode successor = n . copy ( ) ; move . execute ( successor ) ; if ( within Two ( successor , goal ) ) { return _ BOOL ; } } return _ BOOL ; }
private  Map <  String ,  Team Explorer Section Config [ ] > discover Sections ( ) { final  Map <  String ,  List <  Team Explorer Section Config > > map ; map = new  Hash Map <  String ,  List <  Team Explorer Section Config > > ( ) ; for ( final  IConfiguration Element element : get Extensions (  SECTION_ EXTENSION_ POINT_ ID ) ) { final  Team Explorer Section Config section =  Team Explorer Section Config . from Configuration Element ( element ) ;  List <  Team Explorer Section Config > sections = map . get ( section . get Page ID ( ) ) ; if ( sections == null ) { sections = new  Array List <  Team Explorer Section Config > ( ) ; map . put ( section . get Page ID ( ) , sections ) ; } sections . add ( section ) ; } final  Map <  String ,  Team Explorer Section Config [ ] > to Return ; to Return = new  Hash Map <  String ,  Team Explorer Section Config [ ] > ( ) ; for ( final  String page ID : map . key Set ( ) ) { final  List <  Team Explorer Section Config > list = map . get ( page ID ) ; final  Team Explorer Section Config [ ] sections = list . to Array ( new  Team Explorer Section Config [ list . size ( ) ] ) ;  Arrays . sort ( sections , new  Team Explorer Ordered Component Comparator ( ) ) ; to Return . put ( page ID , sections ) ; } return to Return ; }
@  Override public void close Write ( ) throws  IOException { if ( _is Close Write ) { return ; } _is Close Write = _ BOOL ; boolean is Shutdown Output = _ BOOL ; if ( _s != null ) { try { _s . shutdown Output ( ) ; is Shutdown Output = _ BOOL ; } catch (  Unsupported Operation Exception e ) { log . log (  Level .  FINEST , e . to String ( ) , e ) ; } catch (  Exception e ) { log . finer ( e . to String ( ) ) ; log . log (  Level .  FINEST , e . to String ( ) , e ) ; } } }
private void prefetch Statement Data (  Statement Data data ) throws  Replicator Exception { statements ++ ;  String sql Query = null ; try { if ( data . get Query ( ) != null ) sql Query = data . get Query ( ) ; else { try { sql Query = new  String ( data . get Query As Bytes ( ) , data . get Charset ( ) ) ; } catch (  Unsupported Encoding Exception e ) { sql Query = new  String ( data . get Query As Bytes ( ) ) ; } } statement . clear Batch ( ) ; boolean has Transform = _ BOOL ; boolean fetch Secondary Indexes = _ BOOL ; if ( logger . is Debug Enabled ( ) ) { logger . debug ( _ STR + sql Query ) ; }  Sql Operation parsing = (  Sql Operation ) data . get Parsing Metadata ( ) ; if ( parsing . get Operation ( ) ==  Sql Operation .  INSERT ) {  Matcher m = insert . matcher ( sql Query ) ; if ( m . matches ( ) ) { if ( m . group ( _ NUM ) != null ) sql Query = m . group ( _ NUM ) ; else sql Query = m . group ( _ NUM ) ; if ( logger . is Debug Enabled ( ) ) logger . debug ( _ STR + sql Query ) ; transformed ++ ; has Transform = _ BOOL ; } else { if ( logger . is Debug Enabled ( ) ) logger . debug ( _ STR + sql Query ) ; } } else if ( parsing . get Operation ( ) ==  Sql Operation .  DELETE ) {  Matcher m = delete . matcher ( sql Query ) ; if ( m . matches ( ) ) { sql Query = _ STR + m . group ( _ NUM ) ; if ( logger . is Debug Enabled ( ) ) logger . debug ( _ STR + sql Query ) ; transformed ++ ; has Transform = _ BOOL ; fetch Secondary Indexes = _ BOOL ; } else { if ( logger . is Debug Enabled ( ) ) logger . debug ( _ STR + sql Query ) ; } } else if ( parsing . get Operation ( ) ==  Sql Operation .  UPDATE ) {  Matcher m = update . matcher ( sql Query ) ; if ( m . matches ( ) ) { sql Query = _ STR + m . group ( _ NUM ) + _ STR + m . group ( _ NUM ) ; if ( logger . is Debug Enabled ( ) ) logger . debug ( _ STR + sql Query ) ; transformed ++ ; has Transform = _ BOOL ; fetch Secondary Indexes = _ BOOL ; } else { if ( logger . is Debug Enabled ( ) ) logger . debug ( _ STR + sql Query ) ; } } else if ( parsing . get Operation ( ) ==  Sql Operation .  SET ) { if ( logger . is Debug Enabled ( ) ) logger . debug ( _ STR + sql Query ) ; has Transform = _ BOOL ; } else { if ( logger . is Debug Enabled ( ) ) logger . debug ( _ STR + sql Query ) ; }  String schema = data . get Default Schema ( ) ;  Long timestamp = data . get Timestamp ( ) ;  List <  Repl Option > options = data . get Options ( ) ; apply Use Schema ( schema ) ; apply Set Timestamp ( timestamp ) ; apply Session Variables ( options ) ; try { statement . execute Batch ( ) ; } catch (  SQLWarning e ) {  String msg = _ STR + data . to String ( ) + _ STR + e . get Message ( ) ; logger . warn ( msg ) ; } catch (  SQLException e ) { if ( data . get Error Code ( ) == _ NUM ) {  String msg = _ STR + data . to String ( ) ;  SQLException sql Exception = new  SQLException ( msg ) ; sql Exception . init Cause ( e ) ; throw sql Exception ; } } finally { statement . clear Batch ( ) ; }  Result Set rs = null ; if ( has Transform ) { if ( prefetch Row Limit > _ NUM ) sql Query = prefetch Transformer . add Limit To Query ( sql Query , prefetch Row Limit ) ; try { if ( logger . is Debug Enabled ( ) ) logger . debug ( _ STR + sql Query ) ; rs = statement . execute Query ( sql Query ) ; prefetched Queries ++ ; if ( fetch Secondary Indexes ) { prefetch Indexes For Statement ( data , parsing , rs ) ; } } finally { close Result Set ( rs ) ; } } } catch (  SQLException e ) { log Failed Statement SQL ( data . get Query ( ) , e ) ; throw new  Applier Exception ( e ) ; } }
public boolean save (  String filename ) { try { m Output = new  File Output Stream ( filename ) ; byte [ ] output = new byte [  BUFFER_ SIZE ] ; while ( m Input . available ( ) > _ NUM ) { int size = read ( output ) ; if ( size > _ NUM ) { m Output . write ( output , _ NUM , size ) ; } else break ; } m Input . close ( ) ; m Output . close ( ) ; return _ BOOL ; } catch (  Exception e ) { e . print Stack Trace ( ) ; } try { if ( m Input != null ) m Input . close ( ) ; if ( m Output != null ) m Output . close ( ) ; } catch (  IOException e ) { e . print Stack Trace ( ) ; } return _ BOOL ; }
private void update Search Style (  JText Component c ,  Sea Glass Context context ,  String prefix ) { search Icon Width = _ NUM ;  Object o = style . get ( context , prefix + _ STR ) ; if ( o != null && o instanceof  Integer ) { search Icon Width = (  Integer ) o ; } popup Icon Width = _ NUM ; o = style . get ( context , prefix + _ STR ) ; if ( o != null && o instanceof  Integer ) { popup Icon Width = (  Integer ) o ; } cancel Icon Width = _ NUM ; o = style . get ( context , prefix + _ STR ) ; if ( o != null && o instanceof  Integer ) { cancel Icon Width = (  Integer ) o ; } search Left Inner Margin = _ NUM ; o = style . get ( context , prefix + _ STR ) ; if ( o != null && o instanceof  Integer ) { search Left Inner Margin = (  Integer ) o ; } search Right Inner Margin = _ NUM ; o = style . get ( context , prefix + _ STR ) ; if ( o != null && o instanceof  Integer ) { search Right Inner Margin = (  Integer ) o ; } placeholder Color =  Color .  GRAY ; o = style . get ( context , _ STR ) ; if ( o != null && o instanceof  Color ) { placeholder Color = (  Color ) o ; }  Border border = c . get Border ( ) ; if ( border == null || border instanceof  UIResource && ! ( border instanceof  Text Field Border ) ) { c . set Border ( create Text Field Border ( context ) ) ; } if ( is Search Field . is In State ( c ) ) { o = c . get Client Property ( _ STR ) ; if ( o != null && o instanceof  String ) { placeholder Text = (  String ) o ; } else if ( placeholder Text != null ) { placeholder Text = null ; } o = c . get Client Property ( _ STR ) ; if ( o != null && o instanceof  Action Listener ) { if ( find Action == null ) { find Action = (  Action Listener ) o ; } } o = c . get Client Property ( _ STR ) ; if ( o != null && o instanceof  JPopup Menu ) { if ( find Popup == null ) { find Popup = (  JPopup Menu ) o ; } } o = c . get Client Property ( _ STR ) ; if ( o != null && o instanceof  Action Listener ) { if ( cancel Action == null ) { cancel Action = (  Action Listener ) o ; } } install Mouse Listeners ( ) ; } else { placeholder Text = null ; if ( find Action != null ) { find Action = null ; } if ( find Popup != null ) { find Popup = null ; } if ( cancel Action != null ) { cancel Action = null ; } uninstall Mouse Listeners ( ) ; } }
public final boolean is Valid ( ) { return !  Float . is Na N ( x ) && !  Float . is Infinite ( x ) && !  Float . is Na N ( y ) && !  Float . is Infinite ( y ) ; }
private void visualize RTree Entry (  SVGPlot svgp ,  Element layer ,  Projection Parallel proj ,  Abstract RStar Tree < ? extends  N ,  E , ? > rtree ,  E entry , int depth , int step ) { final int dim = proj . get Visible Dimensions ( ) ; double [ ] min = proj . fast Project Data To Render Space (  Spatial Util . get Min ( entry ) ) ; double [ ] max = proj . fast Project Data To Render Space (  Spatial Util . get Max ( entry ) ) ; assert ( min . length == dim && max . length == dim ) ;  SVGPath path = new  SVGPath ( ) ; for ( int i = _ NUM ; i < dim ; i ++ ) { path . draw To ( get Visible Axis X ( i ) ,  Math . max ( min [ i ] , max [ i ] ) ) ; } for ( int i = dim - _ NUM ; i >= _ NUM ; i -- ) { path . draw To ( get Visible Axis X ( i ) ,  Math . min ( min [ i ] , max [ i ] ) ) ; } path . close ( ) ;  Element intervals = path . make Element ( svgp ) ;  SVGUtil . add CSSClass ( intervals ,  INDEX + depth ) ; layer . append Child ( intervals ) ; if ( ! entry . is Leaf Entry ( ) ) {  N node = rtree . get Node ( entry ) ; for ( int i = _ NUM ; i < node . get Num Entries ( ) ; i ++ ) {  E child = node . get Entry ( i ) ; if ( ! child . is Leaf Entry ( ) ) { visualize RTree Entry ( svgp , layer , proj , rtree , child , depth + _ NUM , ++ step ) ; } } } }
public static  URL [ ] path To URLs (  String path ) {  String Tokenizer st = new  String Tokenizer ( path ,  File . path Separator ) ;  URL [ ] urls = new  URL [ st . count Tokens ( ) ] ; int count = _ NUM ; while ( st . has More Tokens ( ) ) {  URL url = file To URL ( new  File ( st . next Token ( ) ) ) ; if ( url != null ) { urls [ count ++ ] = url ; } } urls =  Arrays . copy Of ( urls , count ) ; return urls ; }
public double [ ] distribution For Instance (  Instance inst ) throws  Exception { m_ Replace Missing Values . input ( inst ) ; m_ Replace Missing Values . batch Finished ( ) ; inst = m_ Replace Missing Values . output ( ) ; m_ Nominal To Binary . input ( inst ) ; m_ Nominal To Binary . batch Finished ( ) ; inst = m_ Nominal To Binary . output ( ) ; double output = _ NUM , sum So Far = _ NUM ; if ( m_ K > _ NUM ) { for ( int i = _ NUM ; i <= m_ K ; i ++ ) { if ( sum So Far < _ NUM ) { output -= m_ Weights [ i ] ; } else { output += m_ Weights [ i ] ; } if ( m_ Is Addition [ i ] ) { sum So Far += inner Product ( m_ Train . instance ( m_ Additions [ i ] ) , inst ) ; } else { sum So Far -= inner Product ( m_ Train . instance ( m_ Additions [ i ] ) , inst ) ; } } } double [ ] result = new double [ _ NUM ] ; result [ _ NUM ] = _ NUM / ( _ NUM +  Math . exp ( - output ) ) ; result [ _ NUM ] = _ NUM - result [ _ NUM ] ; return result ; }
protected void fire Fatal Connection Error (  SQLException ex ) {  Connection Event evt = new  Connection Event ( this , ex ) ; for (  Connection Event Listener listener : connection Event Listeners ) { listener . connection Error Occurred ( evt ) ; } }
public static void put Object Volatile (  Object obj , long off ,  Object val ) {  UNSAFE . put Object Volatile ( obj , off , val ) ; }
protected  Http Host determine Proxy (  Http Host target ,  Http Request request ,  Http Context context ) throws  Http Exception {  Proxy Selector psel = this . proxy Selector ; if ( psel == null ) psel =  Proxy Selector . get Default ( ) ; if ( psel == null ) return null ;  URI target URI = null ; try { target URI = new  URI ( target . to URI ( ) ) ; } catch (  URISyntax Exception usx ) { throw new  Http Exception ( _ STR + target , usx ) ; }  List <  Proxy > proxies = psel . select ( target URI ) ;  Proxy p = choose Proxy ( proxies , target , request , context ) ;  Http Host result = null ; if ( p . type ( ) ==  Proxy .  Type .  HTTP ) { if ( ! ( p . address ( ) instanceof  Inet Socket Address ) ) { throw new  Http Exception ( _ STR + p . address ( ) ) ; } final  Inet Socket Address isa = (  Inet Socket Address ) p . address ( ) ; result = new  Http Host ( get Host ( isa ) , isa . get Port ( ) ) ; } return result ; }
private void check Chart (  JFree Chart chart ) {  Plot plot = chart . get Plot ( ) ; if ( ! ( plot instanceof  Polar Plot ) ) { throw new  Illegal Argument Exception ( _ STR ) ; } }
public void add Column (  String header ) { if ( get Model ( ) instanceof  Default Table Model ) {  Default Table Model model = (  Default Table Model ) get Model ( ) ; model . add Column (  Util . clean Amp ( header ) ) ; } else throw new  Illegal Argument Exception ( _ STR ) ; }
private void fill Ordinal To Block Mapping For Dimension ( ) { int block Ordinal = - _ NUM ;  Carbon Dimension dimension = null ; int index = _ NUM ; int prvcolumn Group Id = - _ NUM ; while ( index < dimensions . size ( ) ) { dimension = dimensions . get ( index ) ; if ( dimension . is Columnar ( ) || dimension . column Group Id ( ) != prvcolumn Group Id ) { block Ordinal ++ ; } dimension Ordinal To Block Mapping . put ( dimension . get Ordinal ( ) , block Ordinal ) ; prvcolumn Group Id = dimension . column Group Id ( ) ; index ++ ; } index = _ NUM ; while ( index < complex Dimensions . size ( ) ) { dimension = complex Dimensions . get ( index ) ; dimension Ordinal To Block Mapping . put ( dimension . get Ordinal ( ) , ++ block Ordinal ) ; block Ordinal = fill Complex Dimension Child Block Index ( block Ordinal , dimension ) ; index ++ ; } fill Block To Dimension Ordinal Mapping ( ) ; }
private void create Element (  Document doc ,  Element parent Element ,  String element Name , int value ) {  Element element = doc . create Element ( element Name ) ; element . append Child ( doc . create Text Node (  Integer . to String ( value ) ) ) ; parent Element . append Child ( element ) ; }
public static  Data Type create Object (  String class Name ,  String value ) { try {  Class < ? > the Class =  Class . for Name ( class Name ) ;  Class < ? > [ ] constructor Parameters = new  Class [ _ NUM ] ; constructor Parameters [ _ NUM ] =  Class . for Name ( _ STR ) ;  Constructor < ? > class Constructor = the Class . get Constructor ( constructor Parameters ) ; return (  Data Type ) class Constructor . new Instance ( value ) ; } catch (  Exception ex ) {  Log . e ( _ STR , _ STR + class Name + _ STR + value ) ; } return null ; }
public final boolean remove Child (  Text Edit child ) { if ( f Children == null ) return _ BOOL ; boolean result = f Children . remove ( child ) ; if ( result ) { child . internal Set Parent ( null ) ; if ( f Children . is Empty ( ) ) f Children = null ; } return result ; }
private void process Run Completed Tag (  String identifier ) {  Pattern time Pattern =  Pattern . compile ( _ STR ) ;  Matcher time = time Pattern . matcher ( identifier ) ; if ( time . find ( ) ) { try { m Total Run Time =  Long . parse Long ( time . group ( _ NUM ) ) ; } catch (  Number Format Exception e ) {  Log . e (  LOG_ TAG , _ STR + time . group ( _ NUM ) ) ; } } report Test Run Ended ( ) ; m Test Run In Progress = _ BOOL ; }
public  Str Builder insert ( int index , char chars [ ] , int offset , int length ) { validate Index ( index ) ; if ( chars == null ) { return insert ( index , null Text ) ; } if ( offset < _ NUM || offset > chars . length ) { throw new  String Index Out Of Bounds Exception ( _ STR + offset ) ; } if ( length < _ NUM || offset + length > chars . length ) { throw new  String Index Out Of Bounds Exception ( _ STR + length ) ; } if ( length > _ NUM ) { ensure Capacity ( size + length ) ;  System . arraycopy ( buffer , index , buffer , index + length , size - index ) ;  System . arraycopy ( chars , offset , buffer , index , length ) ; size += length ; } return this ; }
public boolean add Root (  File dir ) { boolean changed = deselected . remove ( dir ) ; for (  File root : roots ) { if (  File Utils . is Ancestor ( root , dir ) ) { if ( root . equals ( dir ) ) { if ( changed ) { directory Tree Model . value For Path Changed ( get Tree Path ( dir ) , null ) ; } return changed ; } remove From Path ( dir ) ;  Tree Path path = get Tree Path ( dir ) ; directory Tree . scroll Path To Visible ( path ) ; return changed ; } else if (  File Utils . is Ancestor ( dir , root ) ) { remove Root ( root ) ; add Dir To Tree ( dir ) ; set Expanded ( root ) ; set Expanded ( root . get Parent File ( ) ) ; return _ BOOL ; } } add Dir To Tree ( dir ) ; set Root Expanded ( ) ; return _ BOOL ; }
public void expand Object (  Object element Or Tree Path , int level ) { if ( check Busy ( ) ) { return ; }  Object parent = get Parent Element ( element Or Tree Path ) ; if ( ! ( ( ( parent != null ) && get Expanded State ( parent ) ) || is Root Element ( element Or Tree Path ) ) ) {  List <  Object > objects To Expand = create Object List ( parent , new  Array List < > ( ) ) ; if ( ! objects To Expand . is Empty ( ) ) { objects To Be Expanded . add All ( objects To Expand ) ; } } objects To Be Expanded . add ( element Or Tree Path ) ;  Widget w = internal Expand ( element Or Tree Path , _ BOOL ) ; if ( w != null ) { internal Expand To Level ( w , level ) ; } }
public void append Cell ( byte value ) { append Cell (  String . value Of ( value ) ) ; }
public  File Reader Source (  File file ,  Compiler Configuration configuration ) { super ( configuration ) ; this . file = file ; }
protected void check Bounds (  Component comp , int x , int y , int width , int height ) { if ( comp != null ) { if ( width <= _ NUM ) { width = comp . get Width ( ) ; } if ( max Width > _ NUM && width > max Width ) { width = max Width ; } if ( height <= _ NUM ) { height = comp . get Height ( ) ; } if ( max Height > _ NUM && height > max Height ) { height = max Height ; } comp . set Bounds ( x , y , width , height ) ; } }
public static  String normalize (  Char Sequence src , java . text .  Normalizer .  Form form , int option ) { return  Normalizer Base . normalize ( src . to String ( ) , form , option ) ; }
private  String escapify (  String s ) {  String Buffer result = new  String Buffer ( s . length ( ) * _ NUM ) ; for ( int i = _ NUM ; i < s . length ( ) ; i ++ ) { char c = s . char At ( i ) ; switch ( c ) { case _ STR : result . append ( _ STR ) ; break ; case _ STR : result . append ( _ STR ) ; break ; case _ STR : result . append ( _ STR ) ; break ; case _ STR : result . append ( _ STR ) ; break ; case _ STR : if ( i + _ NUM == s . length ( ) || s . char At ( i + _ NUM ) != _ STR ) result . append ( _ STR ) ; break ; case _ STR : result . append ( _ STR ) ; break ; default : result . append ( c ) ; } } return result . to String ( ) ; }
public static  String escape Som (  String s ) { if ( s == null ) return _ STR ; int idx = s . index Of ( _ STR ) ; if ( idx < _ NUM ) return s ;  String Builder sb = new  String Builder ( ) ; int last = _ NUM ; while ( idx >= _ NUM ) { sb . append ( s . substring ( last , idx ) ) ; sb . append ( _ STR ) ; last = idx ; idx = s . index Of ( _ STR , idx + _ NUM ) ; } sb . append ( s . substring ( last ) ) ; return sb . to String ( ) ; }
default  Optional <  Column Entity > single Result (  Column Query query ) throws  Non Unique Result Exception ,  Null Pointer Exception {  List <  Column Entity > entities = find ( query ) ; if ( entities . is Empty ( ) ) { return  Optional . empty ( ) ; } if ( entities . size ( ) == _ NUM ) { return  Optional . of ( entities . get ( _ NUM ) ) ; } throw new  Non Unique Result Exception ( _ STR + query ) ; }
public static <  T extends  Throwable >  T read Stack Trace (  T throwable ,  Stream Input in ) throws  IOException { final int stack Trace Elements = in . read VInt ( ) ;  Stack Trace Element [ ] stack Trace = new  Stack Trace Element [ stack Trace Elements ] ; for ( int i = _ NUM ; i < stack Trace Elements ; i ++ ) { final  String declaring Classs = in . read String ( ) ; final  String file Name = in . read Optional String ( ) ; final  String method Name = in . read String ( ) ; final int line Number = in . read VInt ( ) ; stack Trace [ i ] = new  Stack Trace Element ( declaring Classs , method Name , file Name , line Number ) ; } throwable . set Stack Trace ( stack Trace ) ; int num Suppressed = in . read VInt ( ) ; for ( int i = _ NUM ; i < num Suppressed ; i ++ ) { throwable . add Suppressed ( in . read Throwable ( ) ) ; } return throwable ; }
private  Json Writer close (  Json Scope empty ,  Json Scope nonempty ,  String close Bracket ) throws  IOException {  Json Scope context = peek ( ) ; if ( context != nonempty && context != empty ) { throw new  Illegal State Exception ( _ STR + stack ) ; } if ( deferred Name != null ) { throw new  Illegal State Exception ( _ STR + deferred Name ) ; } stack . remove ( stack . size ( ) - _ NUM ) ; if ( context == nonempty ) { newline ( ) ; } out . write ( close Bracket ) ; return this ; }
public  Array List <  String > parse Column Names ( ) {  Array List <  String > columns = new  Array List <  String > ( ) ;  Token token = scan Token ( ) ; if ( token ==  Token .  LPAREN ) { do { columns . add ( parse Identifier ( ) ) ; token = scan Token ( ) ; } while ( token ==  Token .  COMMA ) ; if ( token !=  Token .  RPAREN ) { throw error ( _ STR , token ) ; } } else if ( token ==  Token .  IDENTIFIER ) { columns . add ( _lexeme ) ; _token = token ; } else { throw error ( _ STR , token ) ; } return columns ; }
public static int darker ( int color , float factor ) { int a =  Color . alpha ( color ) ; int r =  Color . red ( color ) ; int g =  Color . green ( color ) ; int b =  Color . blue ( color ) ; return  Color . argb ( a ,  Math . max ( ( int ) ( r * factor ) , _ NUM ) ,  Math . max ( ( int ) ( g * factor ) , _ NUM ) ,  Math . max ( ( int ) ( b * factor ) , _ NUM ) ) ; }
public static  Map <  String ,  String > parse Named Parameters (  String tag Value ) {  Map <  String ,  String > param Map = new  Linked Hash Map <  String ,  String > ( ) ;  Stream Tokenizer tokenizer = make Tokenizer ( tag Value ) ; try { while ( tokenizer . next Token ( ) ==  Stream Tokenizer .  TT_ WORD ) {  String key = tokenizer . sval ; if ( tokenizer . next Token ( ) != _ STR ) { break ; } switch ( tokenizer . next Token ( ) ) { case  Stream Tokenizer .  TT_ WORD : case _ STR : case _ STR : param Map . put ( key , tokenizer . sval ) ; default : break ; } } } catch (  IOException e ) { } return param Map ; }
static  String internal To Binary Class Name (  String class Name ) { if ( class Name == null ) { return null ; } else { return class Name . replace ( _ STR , _ STR ) ; } }
protected synchronized void add All Data Series ( ) { for (  Indexed Process Var pv : (  Iterable <  Indexed Process Var > ) pvs . values ( ) ) {  XYSeries series = (  XYSeries ) pv . get (  FID_ DATA_ SERIES ) ; if ( series == null ) { series = new  XYSeries (  String . value Of ( pv . get (  Ecu Data Pv .  FID_ DESCRIPT ) ) ) ; pv . put (  FID_ DATA_ SERIES , series ) ; pv . add Pv Change Listener ( this ,  Pv Change Event .  PV_ MODIFIED ) ; } } }
private static void assert Field NS (  String field NS ) throws  XMPException { if ( field NS == null || field NS . length ( ) == _ NUM ) { throw new  XMPException ( _ STR ,  XMPError .  BADSCHEMA ) ; } }
public static  String Builder format To (  String Builder buf , double [ ] d ,  String sep ,  Number Format nf ) { if ( d == null ) { return buf . append ( _ STR ) ; } if ( d . length == _ NUM ) { return buf ; } buf . append ( nf . format ( d [ _ NUM ] ) ) ; for ( int i = _ NUM ; i < d . length ; i ++ ) { buf . append ( sep ) ; buf . append ( nf . format ( d [ i ] ) ) ; } return buf ; }
public void next Viewpoint ( ) { if ( viewpoint List . size ( ) == _ NUM ) { return ; } viewpoint Index ++ ; if ( viewpoint Index >= viewpoint List . size ( ) ) { viewpoint Index = _ NUM ; } viewpoint Node . set Viewpoint ( viewpoint List . get ( viewpoint Index ) , _ BOOL , _ BOOL ) ; }
private void search Hex ( ) { final  String text = m_input Field . get Text ( ) ; if ( ( text . length ( ) % _ NUM ) != _ NUM ) { m_input Field . set Background (  Color .  RED ) ; return ; } m_input Field . set Background (  Color .  WHITE ) ; final byte [ ] data = new byte [ text . length ( ) / _ NUM ] ; for ( int i = _ NUM ; i < text . length ( ) ; i += _ NUM ) { final  String substr = text . substring ( i , i + _ NUM ) ; data [ i / _ NUM ] = ( byte ) ( int )  Integer . value Of ( substr , _ NUM ) ; } search ( data ) ; }
public void add Ignored View (  View v ) { ignored Views . add ( v ) ; }
public boolean write Header (  Output Stream os ) { try { write Int ( os ,  CACHE_ MAGIC ) ; write String ( os , key ) ; write String ( os , etag == null ? _ STR : etag ) ; write Long ( os , server Date ) ; write Long ( os , last Modified ) ; write Long ( os , ttl ) ; write Long ( os , soft Ttl ) ; write String String Map ( response Headers , os ) ; os . flush ( ) ; return _ BOOL ; } catch (  IOException e ) {  Volley Log . d ( _ STR , e . to String ( ) ) ; return _ BOOL ; } }
public static boolean is Uri Param Resource (  String resource ) { if ( resource == null ) { return _ BOOL ; } resource =  Naming Helper . clean Leading And Trailing New Line And Chars ( resource . to Lower Case ( ) ) ; if ( resource . starts With ( _ STR ) && resource . ends With ( _ STR ) ) { return _ BOOL ; } else { return _ BOOL ; } }
View create Section Header If Needed (  Recycler View .  Recycler recycler , int section Index ) { if ( adapter . does Section Have Header ( section Index ) ) { for ( int i = _ NUM , n = get Child Count ( ) ; i < n ; i ++ ) {  View view = get Child At ( i ) ; if ( get View Base Type ( view ) ==  Sectioning Adapter .  TYPE_ HEADER && get View Section Index ( view ) == section Index ) { return view ; } } int header Adapter Position = adapter . get Adapter Position For Section Header ( section Index ) ;  View header View = recycler . get View For Position ( header Adapter Position ) ; header Views . add ( header View ) ; add View ( header View ) ; measure Child With Margins ( header View , _ NUM , _ NUM ) ; return header View ; } return null ; }
public  String trim Audio (  String path , double start , double length ) throws  Exception {  Array List <  String > cmd = new  Array List <  String > ( ) ;  File file = new  File ( path ) ;  String out File = file . get Canonical Path ( ) + _ STR ; cmd . add ( sox Bin ) ; cmd . add ( path ) ; cmd . add ( _ STR ) ; cmd . add ( _ STR ) ; cmd . add ( _ STR ) ; cmd . add ( _ STR ) ; cmd . add ( out File ) ; cmd . add ( _ STR ) ; cmd . add ( start + _ STR ) ; if ( length != - _ NUM ) cmd . add ( length + _ STR ) ; int rc = exec Sox ( cmd , callback ) ; if ( rc != _ NUM ) { out File = null ; } if ( file . exists ( ) ) return out File ; else return null ; }
void start Scrolling Instance ( ) { if ( log . is Loggable (  Platform Logger .  Level .  FINER ) ) { log . finer ( _ STR + this ) ; } scroll ( ) ; i_scroller . set Scrollbar ( this ) ; i_scroller . start ( ) ; }
@ edu . umd . cs . findbugs . annotations .  Suppress FBWarnings ( value = _ STR , justification = _ STR ) protected void notify Target Intensity Change ( double intensity ) { double old Value = m Current Intensity ; m Current Intensity = intensity ; if ( old Value != intensity ) { fire Property Change ( _ STR ,  Double . value Of ( old Value ) ,  Double . value Of ( intensity ) ) ; } }
private static boolean contents Equals (  Input Stream in1 ,  Input Stream in2 ) throws  IOException { if ( ! ( in1 instanceof  Buffered Input Stream ) ) { in1 = new  Buffered Input Stream ( in1 ) ; } if ( ! ( in2 instanceof  Buffered Input Stream ) ) { in2 = new  Buffered Input Stream ( in2 ) ; } int ch = in1 . read ( ) ; while ( ch != - _ NUM ) { int ch2 = in2 . read ( ) ; if ( ch != ch2 ) { return _ BOOL ; } ch = in1 . read ( ) ; } int ch2 = in2 . read ( ) ; return ch2 == - _ NUM ; }
public  Response new Fixed Length Response (  String msg ) { return new Fixed Length Response (  Response .  Status .  OK ,  Nano HTTPD .  MIME_ HTML , msg ) ; }
@  Override public  XMLEvent next Event ( ) throws  XMLStream Exception { log . log (  Level .  FINE , _ STR ) ; current Event = next Event ; if ( current Event . get Event Type ( ) !=  XMLStream Constants .  END_ DOCUMENT ) { next Event = construct Event ( stream . next ( ) , stream ) ; } else { next Event = null ; } log . log (  Level .  FINE , _ STR , current Event ) ; return current Event ; }
public static  String format Reddit Url (  String url ) { url = url . replace First ( _ STR , _ STR ) ; if ( url . matches ( _ STR ) ) {  String subdomain = url . split ( _ STR , _ NUM ) [ _ NUM ] ;  String domain Regex = _ STR + subdomain + _ STR ; if ( subdomain . equals Ignore Case ( _ STR ) ) { url = url . replace First ( domain Regex , _ STR ) ; url = _ STR + url ; } else if ( subdomain . matches ( _ STR ) ) { return _ STR ; } else if ( subdomain . matches ( _ STR ) ) { url = url . replace First ( domain Regex , _ STR ) ; } else { url = url . replace First ( domain Regex , _ STR + subdomain ) ; } } if ( url . starts With ( _ STR ) ) url = _ STR + url ; if ( url . ends With ( _ STR ) ) url = url . substring ( _ NUM , url . length ( ) - _ NUM ) ; if ( url . matches ( _ STR ) ) { url = url . replace First ( _ STR , _ STR ) ; } return url ; }
public static double magnitude ( final double x , final double y , final double z ) { return  Math . sqrt ( x * x + y * y + z * z ) ; }
private void update Arrow ( ) { path1 . reset ( ) ; path2 . reset ( ) ; path3 . reset ( ) ; path1 . move To ( m Real Left + radius , m Arrow Start ) ; path1 . line To ( m Real Left + radius , m Arrow Start + radius ) ; path2 . move To ( m Real Left + radius , m Arrow Start + radius ) ; path2 . line To ( ( float ) ( m Real Left + radius -  Math . tan (  Math . to Radians ( _ NUM ) ) * radius * _ NUM ) , m Arrow Start + radius - radius * _ NUM ) ; path3 . move To ( m Real Left + radius , m Arrow Start + radius ) ; path3 . line To ( ( float ) ( m Real Left + radius +  Math . tan (  Math . to Radians ( _ NUM ) ) * radius * _ NUM ) , m Arrow Start + radius - radius * _ NUM ) ; path Measure1 . set Path ( path1 , _ BOOL ) ; path Measure2 . set Path ( path2 , _ BOOL ) ; path Measure3 . set Path ( path3 , _ BOOL ) ; m Arrow_center_length = path Measure1 . get Length ( ) ; m Arrow_left_length = path Measure2 . get Length ( ) ; m Arrow_right_length = path Measure3 . get Length ( ) ; }
private static  SSLContext create Easy SSLContext ( ) {  SSLContext context ; try { context =  SSLContext . get Instance ( _ STR ) ; context . init ( null , _trust Managers , new  Secure Random ( ) ) ;  Https URLConnection . set Default SSLSocket Factory ( context . get Socket Factory ( ) ) ; } catch ( final  General Security Exception gse ) { throw new  Illegal State Exception ( gse . get Message ( ) ) ; } return context ; }
protected  List <  String > convert List To Lower Case (  List <  String > list ) {  List <  String > lower Case List = new  Array List < > ( ) ; for (  String value : list ) { lower Case List . add ( value . to Lower Case ( ) ) ; } return lower Case List ; }
public void add (  Simple Name ref ) {  String type Name = ref . get Identifier ( ) ; if ( f Imports Added . contains ( type Name ) ) { return ; }  IBinding binding = ref . resolve Binding ( ) ; if ( binding != null ) { if ( binding . get Kind ( ) !=  IBinding .  TYPE ) { return ; }  IType Binding type Binding = (  IType Binding ) binding ; if ( type Binding . is Array ( ) ) { type Binding = type Binding . get Element Type ( ) ; } type Binding = type Binding . get Type Declaration ( ) ; if ( ! type Binding . is Recovered ( ) ) { if ( needs Import ( type Binding , ref ) ) { f Imp Structure . add Import ( type Binding ) ; f Imports Added . add ( type Name ) ; } return ; } } else { if ( f Do Ignore Lower Case Names && type Name . length ( ) > _ NUM ) { char ch = type Name . char At ( _ NUM ) ; if (  Character . is Lower Case ( ch ) &&  Character . is Letter ( ch ) ) { return ; } } } f Imports Added . add ( type Name ) ; f Unresolved Types . put ( type Name , new  Unresolved Type Data ( ref ) ) ; }
public static  Gapless Info parse Udta (  Atom .  Leaf Atom udta Atom , boolean is Quick Time ) { if ( is Quick Time ) { return null ; }  Parsable Byte Array udta Data = udta Atom . data ; udta Data . set Position (  Atom .  HEADER_ SIZE ) ; while ( udta Data . bytes Left ( ) >=  Atom .  HEADER_ SIZE ) { int atom Size = udta Data . read Int ( ) ; int atom Type = udta Data . read Int ( ) ; if ( atom Type ==  Atom .  TYPE_meta ) { udta Data . set Position ( udta Data . get Position ( ) -  Atom .  HEADER_ SIZE ) ; udta Data . set Limit ( udta Data . get Position ( ) + atom Size ) ; return parse Meta Atom ( udta Data ) ; } else { udta Data . skip Bytes ( atom Size -  Atom .  HEADER_ SIZE ) ; } } return null ; }
public  String post (  String url ,  String json , final int expected Status Code ) { return post ( url , json ,  Collections . <  String ,  String > empty Map ( ) , expected Status Code ) ; }
private void compute Scores ( ) { final int max = get Max Value ( ) ; m_l Max =  Math . log ( max ) ; m_ll Max = -  Math . log ( ( double ) max / m Points ) ; if ( max > m_minimal Max && ( ( double ) m Points ) / m Point Differences . size ( ) > m_minimal Concentration ) { m_point Scores = new  Tree Map <  Integer ,  Double > ( ) ; for (  Entry <  Integer ,  Integer > entry : m Point Differences . entry Set ( ) ) { final  Integer v = entry . get Value ( ) ; if ( v > _ NUM ) { m_point Scores . put ( entry . get Key ( ) , m_l Max -  Math . log ( v ) ) ; } } } }
@  Override public boolean prune Values ( double threshold ) {  Map <  Value ,  Double > new Table = new  Hash Map <  Value ,  Double > ( ) ; boolean changed = _ BOOL ; for (  Value row : table . key Set ( ) ) { double prob = table . get ( row ) ; if ( prob >= threshold ) { new Table . put ( row , prob ) ; } else { changed = _ BOOL ; } } if ( changed ) { table =  Inference Utils . normalise ( new Table ) ; } intervals = null ; return changed ; }
public void config (  Configuration config ,  String prefix ,  String name ) { items = config . get Prefix Property List ( prefix , name + _ STR ) ; }
private  Map map Name To Display Name (  Set names ) {  Map map = new  Hash Map ( names . size ( ) * _ NUM ) ;  AMView Config v Config =  AMView Config . get Instance ( ) ; for (  Iterator iter = names . iterator ( ) ; iter . has Next ( ) ; ) {  String name = (  String ) iter . next ( ) ; if ( v Config . is Service Visible ( name ) ) {  String display Name = get Localized Service Name ( name ) ; if ( ! name . equals ( display Name ) ) { map . put ( name , display Name ) ; } } } return map ; }
@  Override public  String to String ( ) {  String Builder string Builder = new  String Builder ( _ STR ) ; for (  Node Collection parent : parents ) { string Builder . append ( parent . get Id ( ) + _ STR ) ; } string Builder . append ( _ STR ) ; for (  Node Collection child : children ) { string Builder . append ( child . get Id ( ) + _ STR ) ; } string Builder . append ( _ STR ) ; return string Builder . to String ( ) ; }
public static boolean cancel Potential Work (  Object data ,  Image View image View ) { final  Bitmap Worker Task bitmap Worker Task = get Bitmap Worker Task ( image View ) ; if ( bitmap Worker Task != null ) { final  Object bitmap Data = bitmap Worker Task . m Data ; if ( bitmap Data == null || ! bitmap Data . equals ( data ) ) { bitmap Worker Task . cancel ( _ BOOL ) ; } else { return _ BOOL ; } } return _ BOOL ; }
public void put ( final  Resources res , final  String key ,  Recycling Bitmap Drawable bmp , final boolean as PNG ) { boolean is Default Art = _ BOOL ; final  String clean Key = sanitize Key ( key ) ; if ( bmp == null ) { bmp = new  Recycling Bitmap Drawable ( res , m Default Art . copy ( m Default Art . get Config ( ) , _ BOOL ) ) ; is Default Art = _ BOOL ; } if (  USE_ MEMORY_ CACHE ) { m Memory Cache . put ( clean Key , bmp ) ; } if ( ! is Default Art ) { try {  File Output Stream out = new  File Output Stream ( m Cache Dir . get Absolute Path ( ) + _ STR + clean Key ) ;  Bitmap bitmap = bmp . get Bitmap ( ) ; boolean should Recycle = _ BOOL ; final float max Size = _ NUM ; if ( bitmap . get Width ( ) > max Size && bitmap . get Height ( ) > max Size ) { float ratio = ( bitmap . get Width ( ) < bitmap . get Height ( ) ) ? bitmap . get Width ( ) / max Size : bitmap . get Height ( ) / max Size ; final int s Width = ( int ) ( bitmap . get Width ( ) / ratio ) ; final int s Height = ( int ) ( bitmap . get Height ( ) / ratio ) ; bitmap =  Bitmap . create Scaled Bitmap ( bitmap , s Width , s Height , _ BOOL ) ; should Recycle = _ BOOL ;  Log . d (  TAG , _ STR + s Width + _ STR + s Height ) ; } bitmap . compress ( as PNG ?  Bitmap .  Compress Format .  PNG :  Bitmap .  Compress Format .  JPEG , _ NUM , out ) ; out . close ( ) ; if ( should Recycle ) { bitmap . recycle ( ) ; } } catch (  IOException e ) {  Log . e (  TAG , _ STR , e ) ; } synchronized ( m Entries ) { m Entries . add ( clean Key ) ; } } }
public void add Listener ( final  INavi Graph Listener listener ) { super . add Listener ( listener ) ; m_listeners . add Listener ( listener ) ; m_synchronizer . add Listener ( listener ) ; }
private int make Available ( ) throws  IOException { if ( pos != - _ NUM ) { return _ NUM ; } total += tail - head - pad ;  System . arraycopy ( buffer , tail - pad , buffer , _ NUM , pad ) ; head = _ NUM ; tail = pad ; for ( ; ; ) { int bytes Read = input . read ( buffer , tail , buf Size - tail ) ; if ( bytes Read == - _ NUM ) { final  String msg = _ STR ; throw new  Malformed Stream Exception ( msg ) ; } tail += bytes Read ; find Separator ( ) ; int av = available ( ) ; if ( av > _ NUM || pos != - _ NUM ) { return av ; } } }
public  Id Query (  String type Name ,  Object id ,  Object routing ,  Query Result Type query Result Type , int version ) { if ( type Name == null || type Name . length ( ) == _ NUM ) throw new  Illegal Argument Exception ( _ STR ) ; if ( id == null ) throw new  Illegal Argument Exception ( _ STR ) ; if ( query Result Type == null ) throw new  Illegal Argument Exception ( _ STR ) ; if ( version < _ NUM ) throw new  Illegal Argument Exception ( _ STR ) ; this . _type Name = type Name ; this . _id = id ; this . _routing = routing ; this . _query Result Type = query Result Type ; this . _version = version ; }
@  Override public boolean domain Match ( final  String host , final  String domain ) { final boolean match = host . equals ( domain ) || ( domain . starts With ( _ STR ) && host . ends With ( domain ) ) ; return match ; }
private void orthes ( ) { int low = _ NUM ; int high = n - _ NUM ; for ( int m = low + _ NUM ; m <= high - _ NUM ; m ++ ) { double scale = _ NUM ; for ( int i = m ; i <= high ; i ++ ) { scale = scale +  Math . abs (  H [ i ] [ m - _ NUM ] ) ; } if ( scale != _ NUM ) { double h = _ NUM ; for ( int i = high ; i >= m ; i -- ) { ort [ i ] =  H [ i ] [ m - _ NUM ] / scale ; h += ort [ i ] * ort [ i ] ; } double g =  Math . sqrt ( h ) ; if ( ort [ m ] > _ NUM ) { g = - g ; } h = h - ort [ m ] * g ; ort [ m ] = ort [ m ] - g ; for ( int j = m ; j < n ; j ++ ) { double f = _ NUM ; for ( int i = high ; i >= m ; i -- ) { f += ort [ i ] *  H [ i ] [ j ] ; } f = f / h ; for ( int i = m ; i <= high ; i ++ ) {  H [ i ] [ j ] -= f * ort [ i ] ; } } for ( int i = _ NUM ; i <= high ; i ++ ) { double f = _ NUM ; for ( int j = high ; j >= m ; j -- ) { f += ort [ j ] *  H [ i ] [ j ] ; } f = f / h ; for ( int j = m ; j <= high ; j ++ ) {  H [ i ] [ j ] -= f * ort [ j ] ; } } ort [ m ] = scale * ort [ m ] ;  H [ m ] [ m - _ NUM ] = scale * g ; } } for ( int i = _ NUM ; i < n ; i ++ ) { for ( int j = _ NUM ; j < n ; j ++ ) {  V [ i ] [ j ] = ( i == j ? _ NUM : _ NUM ) ; } } for ( int m = high - _ NUM ; m >= low + _ NUM ; m -- ) { if (  H [ m ] [ m - _ NUM ] != _ NUM ) { for ( int i = m + _ NUM ; i <= high ; i ++ ) { ort [ i ] =  H [ i ] [ m - _ NUM ] ; } for ( int j = m ; j <= high ; j ++ ) { double g = _ NUM ; for ( int i = m ; i <= high ; i ++ ) { g += ort [ i ] *  V [ i ] [ j ] ; } g = ( g / ort [ m ] ) /  H [ m ] [ m - _ NUM ] ; for ( int i = m ; i <= high ; i ++ ) {  V [ i ] [ j ] += g * ort [ i ] ; } } } } }
public void write Timer Report (  XMLWriter writer ) { writer . write Open Tag ( _ STR ) ; writer . write Open Tag ( _ STR , new  Attribute .  Default <  String > ( _ STR , _ STR ) ) ; writer . write IDref ( _ STR , _ STR ) ; writer . write Close Tag ( _ STR ) ; writer . write Close Tag ( _ STR ) ; }
protected  Object open Object ( ) { if ( m_ File Chooser == null ) { create File Chooser ( ) ; } int return Val = m_ File Chooser . show Open Dialog ( this ) ; if ( return Val ==  JFile Chooser .  APPROVE_ OPTION ) {  File selected = m_ File Chooser . get Selected File ( ) ; try {  Object Input Stream oi = new  Object Input Stream ( new  Buffered Input Stream ( new  File Input Stream ( selected ) ) ) ;  Object obj = oi . read Object ( ) ; oi . close ( ) ; if ( ! m_ Class Type . is Assignable From ( obj . get Class ( ) ) ) { throw new  Exception ( _ STR + m_ Class Type . get Name ( ) ) ; } return obj ; } catch (  Exception ex ) {  JOption Pane . show Message Dialog ( this , _ STR + selected . get Name ( ) + _ STR + ex . get Message ( ) , _ STR ,  JOption Pane .  ERROR_ MESSAGE ) ; } } return null ; }
public int read ( char cbuf [ ] , int off , int len ) throws  IOException { synchronized ( lock ) { ensure Open ( ) ; if ( ( off < _ NUM ) || ( off > cbuf . length ) || ( len < _ NUM ) || ( ( off + len ) > cbuf . length ) || ( ( off + len ) < _ NUM ) ) { throw new  Index Out Of Bounds Exception ( ) ; } else if ( len == _ NUM ) { return _ NUM ; } if ( next >= length ) return - _ NUM ; int n =  Math . min ( length - next , len ) ; str . get Chars ( next , next + n , cbuf , off ) ; next += n ; return n ; } }
private  String align ( final  String data , final  Alignment alignment , final int width ) { final  String raw Data = data . trim ( ) ; final int padding = width - raw Data . length ( ) ; if ( padding <= _ NUM ) { return raw Data ; } switch ( alignment ) { case  RIGHT : return pad ( padding , raw Data , _ NUM ) ; case  LEFT : return pad ( _ NUM , raw Data , padding ) ; case  CENTER : final int padding Before = padding / _ NUM ; return pad ( padding Before , raw Data , padding - padding Before ) ; default : return _ STR ; } }
@  Override public  String to Parsable String (  Type declaring Type ,  Type Tuple input Types ,  Type output Type ) { return declaring Type . get Name ( ) + _ STR + field . get Name ( ) + _ STR ; }
public  Audio Module (  Dialogue System system ) { this . system = system ; }
public  Moving Button Container ( ) { set Layout ( new java . awt .  Flow Layout ( ) ) ; timer = new  Timer ( _ NUM , this ) ; button = new  JButton ( _ STR ) ; button . set Opaque ( _ BOOL ) ; button . add Action Listener ( this ) ; add ( button ) ; }
protected boolean is Block Tag (  Attribute Set attr ) {  Object o = attr . get Attribute (  Style Constants .  Name Attribute ) ; if ( o instanceof  HTML .  Tag ) {  HTML .  Tag name = (  HTML .  Tag ) o ; return name . is Block ( ) ; } return _ BOOL ; }
public  Business Object Data Key create Business Object Data Key (  Business Object Data business Object Data ) {  Business Object Data Key business Object Data Key = new  Business Object Data Key ( ) ; business Object Data Key . set Namespace ( business Object Data . get Namespace ( ) ) ; business Object Data Key . set Business Object Definition Name ( business Object Data . get Business Object Definition Name ( ) ) ; business Object Data Key . set Business Object Format Usage ( business Object Data . get Business Object Format Usage ( ) ) ; business Object Data Key . set Business Object Format File Type ( business Object Data . get Business Object Format File Type ( ) ) ; business Object Data Key . set Business Object Format Version ( business Object Data . get Business Object Format Version ( ) ) ; business Object Data Key . set Partition Value ( business Object Data . get Partition Value ( ) ) ; business Object Data Key . set Sub Partition Values ( business Object Data . get Sub Partition Values ( ) ) ; business Object Data Key . set Business Object Data Version ( business Object Data . get Version ( ) ) ; return business Object Data Key ; }
@  Suppress Warnings ( _ STR ) public  CLImage2 D create Image2 D (  CLMem .  Usage usage ,  CLImage Format format , long width , long height , long row Pitch ,  Buffer buffer , boolean copy ) { }
public void accept (  Context context ) { if ( null != call Reference ) {  Respoke Call call = call Reference . get ( ) ; if ( null != call ) { call . direct Connection Did Accept ( context ) ; } } }
public void dump Created Resource Bundles (  String location ) {  Hashtable bundle Hash = get Create Hash ( ) ; for (  Enumeration enumeration = bundle Hash . keys ( ) ; enumeration . has More Elements ( ) ; ) {  String key = (  String ) enumeration . next Element ( ) ;  Properties props = (  Properties ) bundle Hash . get ( key ) ; try {  File prop File = new  File ( location + _ STR + key ) ;  File parent Dir = new  File ( prop File . get Parent ( ) ) ; parent Dir . mkdirs ( ) ; prop File . create New File ( ) ;  File Output Stream fos = new  File Output Stream ( prop File ) ; props . store ( fos , _ STR ) ; fos . close ( ) ; } catch (  File Not Found Exception fnfe ) { fnfe . print Stack Trace ( ) ; } catch (  IOException e ) { e . print Stack Trace ( ) ; } } }
public static void audit File (  Db Client db Client ,  Operation Type Enum audit Type , boolean operational Status ,  String description ,  Object ... descparams ) {  Audit Log Manager audit Mgr =  Audit Log Manager Factory . get Audit Log Manager ( ) ; audit Mgr . set Db Client ( db Client ) ; audit Mgr . record Audit Log ( null , null ,  EVENT_ SERVICE_ TYPE , audit Type ,  System . current Time Millis ( ) , operational Status ?  Audit Log Manager .  AUDITLOG_ SUCCESS :  Audit Log Manager .  AUDITLOG_ FAILURE , description , descparams ) ; }
Index Entry (  Byte Provider byte Provider ) throws  IOException {  MXFProperty Populator . populate Field ( byte Provider , this , _ STR ) ;  MXFProperty Populator . populate Field ( byte Provider , this , _ STR ) ;  MXFProperty Populator . populate Field ( byte Provider , this , _ STR ) ;  MXFProperty Populator . populate Field ( byte Provider , this , _ STR ) ; }
public boolean recognizes (  String txt ) {  Directed DFS dfs = new  Directed DFS ( graph , _ NUM ) ;  Bag <  Integer > pc = new  Bag <  Integer > ( ) ; for ( int v = _ NUM ; v < graph .  V ( ) ; v ++ ) if ( dfs . marked ( v ) ) pc . add ( v ) ; for ( int i = _ NUM ; i < txt . length ( ) ; i ++ ) { if ( txt . char At ( i ) == _ STR || txt . char At ( i ) == _ STR || txt . char At ( i ) == _ STR || txt . char At ( i ) == _ STR ) throw new  Illegal Argument Exception ( _ STR + txt . char At ( i ) + _ STR ) ;  Bag <  Integer > match = new  Bag <  Integer > ( ) ; for ( int v : pc ) { if ( v == m ) continue ; if ( ( regexp . char At ( v ) == txt . char At ( i ) ) || regexp . char At ( v ) == _ STR ) match . add ( v + _ NUM ) ; } dfs = new  Directed DFS ( graph , match ) ; pc = new  Bag <  Integer > ( ) ; for ( int v = _ NUM ; v < graph .  V ( ) ; v ++ ) if ( dfs . marked ( v ) ) pc . add ( v ) ; if ( pc . size ( ) == _ NUM ) return _ BOOL ; } for ( int v : pc ) if ( v == m ) return _ BOOL ; return _ BOOL ; }
public  Set <  String > post Processing Fields ( ) {  Set <  String > fields = new  Linked Hash Set < > ( ) ; query . for Each ( null ) ; sort . for Each ( null ) ; return fields ; }
public static void write Uuid (  Byte Buf buf ,  UUID uuid ) { buf . write Long ( uuid . get Most Significant Bits ( ) ) ; buf . write Long ( uuid . get Least Significant Bits ( ) ) ; }
public  Flux Concat Array <  T > concat Additional Source Last (  Publisher < ? extends  T > source ) { int n = array . length ; @  Suppress Warnings ( _ STR )  Publisher < ? extends  T > [ ] new Array = new  Publisher [ n + _ NUM ] ;  System . arraycopy ( array , _ NUM , new Array , _ NUM , n ) ; new Array [ n ] = source ; return new  Flux Concat Array < > ( delay Error , new Array ) ; }
@  Override public void shutdown ( ) { m Thread Pool Slow . shutdown ( ) ; m Thread Pool Fast . shutdown ( ) ; }
synchronized  String create Local Id ( ) { long local Id Number = random . next Long ( ) ;  String local Id = _ STR +  Long . to Hex String ( local Id Number ) ; if ( ! is Local Id ( local Id ) ) { throw new  Illegal State Exception ( _ STR + local Id + _ STR + _ STR ) ; } return local Id ; }
public void bind (  Server Socket Bar ss ) throws  IOException {  Objects . require Non Null ( ss ) ; _is Bind . set ( _ BOOL ) ; if ( _protocol == null ) throw new  Illegal State Exception (  L . l ( _ STR , this ) ) ; if ( _throttle == null ) _throttle = new  Throttle Socket ( ) ; _server Socket = ss ;  String scheme = _protocol . name ( ) ; if ( _address != null ) log . info ( scheme + _ STR + _address + _ STR + _port ) ; else log . info ( scheme + _ STR + _port ) ; if ( _ssl Factory != null ) { try { _server Socket = _ssl Factory . bind ( _server Socket ) ; } catch (  Runtime Exception e ) { throw e ; } catch (  IOException e ) { throw e ; } catch (  Exception e ) { throw new  IOException ( e ) ; } } }
private void display Message On Monitor ( ) {  String Builder string Builder = new  String Builder ( ) ; string Builder . append ( _ STR ) ; string Builder . append ( files Count + _ NUM ) ; string Builder . append ( _ STR ) ; string Builder . append ( files . size ( ) ) ; string Builder . append ( _ STR ) ; string Builder . append (  Number Formatter . human Readable Byte Count ( total Bytes Transfered ) ) ; if ( ! gzip Compression ) { string Builder . append ( _ STR ) ; string Builder . append (  Number Formatter . human Readable Byte Count ( total Size ) ) ; } string Builder . append ( _ STR ) ; string Builder . append (  Number Formatter . human Readable Byte Count ( ( long ) get Average Transfer Rate ( ) ) ) ; string Builder . append ( _ STR ) ; if ( gzip Compression ) { string Builder . append ( _ STR ) ; } long quasi Bytes Left = total Size - finished Files Size ; if ( current File Real < current File Size ) { quasi Bytes Left -= current File Real ; } else { quasi Bytes Left -= current File Size ; } long millis Left = get Millis Left ( quasi Bytes Left ) ; millis Left += millis Left % _ NUM ; string Builder . append (  Number Formatter . human Readable Millis Count ( millis Left , _ BOOL ) ) ; sub Monitor . sub Task ( string Builder . to String ( ) ) ; }
public void generate All Dot Desc For Wagon (  Print Writer out ,  Set <  String > features To Ignore ) { out . println ( _ STR ) ; out . println ( _ STR ) ; for ( int i = _ NUM , n = get Number Of Features ( ) ; i < n ; i ++ ) { out . print ( _ STR ) ;  String feature Name = get Feature Name ( i ) ; out . print ( feature Name ) ; if ( features To Ignore != null && features To Ignore . contains ( feature Name ) ) { out . print ( _ STR ) ; } if ( i < num Byte Features + num Short Features ) { for ( int v = _ NUM , vmax = get Number Of Values ( i ) ; v < vmax ; v ++ ) { out . print ( _ STR ) ;  String val = get Feature Value As String ( i , v ) ; if ( val . index Of ( _ STR ) != - _ NUM ) {  String Builder buf = new  String Builder ( ) ; for ( int c = _ NUM ; c < val . length ( ) ; c ++ ) { char ch = val . char At ( c ) ; if ( ch == _ STR ) buf . append ( _ STR ) ; else buf . append ( ch ) ; } val = buf . to String ( ) ; } out . print ( _ STR + val + _ STR ) ; } out . println ( _ STR ) ; } else { out . println ( _ STR ) ; } } out . println ( _ STR ) ; }
public void write (  String filename ) { logger . info ( _ STR ) ; try { open File ( filename ) ; write Xml Head ( ) ; start Carriers ( this . writer ) ; for (  Carrier carrier : carriers ) { start Carrier ( carrier , this . writer ) ; write Vehicles And Their Types ( carrier , this . writer ) ; write Shipments ( carrier , this . writer ) ; write Services ( carrier , this . writer ) ; write Plans ( carrier , this . writer ) ; end Carrier ( this . writer ) ; } end Carriers ( this . writer ) ; close ( ) ; logger . info ( _ STR ) ; } catch (  IOException e ) { e . print Stack Trace ( ) ; logger . error ( e ) ;  System . exit ( _ NUM ) ; } }
public void add Resource Listener (  Resource Events Listener listener ) { resource Listeners . add ( listener ) ; }
public void test Missing Main Activity ( ) throws  Exception { m Enabled . add (  Launcher Activity Detector .  ISSUE_ MORE_ THAN_ ONE_ LAUNCHER ) ; m Enabled . add (  Launcher Activity Detector .  ISSUE_ MISSING_ LAUNCHER ) ; m Enabled . add (  Launcher Activity Detector .  ISSUE_ LAUNCHER_ ACTIVITY_ IN_ LIBRARY ) ;  String expected = _ STR + _ STR + _ STR + _ STR + _ STR ;  String result = lint Project ( xml (  FN_ ANDROID_ MANIFEST_ XML , _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR ) ) ; assert Equals ( expected , result ) ; }
static public  String strip Char (  String str , char ch ) { if ( str != null ) { char [ ] buffer = new char [ str . length ( ) ] ; int next = _ NUM ; for ( int i = _ NUM ; i < str . length ( ) ; i ++ ) { if ( str . char At ( i ) != ch ) { buffer [ next ++ ] = str . char At ( i ) ; } } return new  String ( buffer , _ NUM , next ) ; } else { return null ; } }
public  Resource from Properties (  Properties properties ) {  String name = properties . get Property (  Resource Property Set .  RESOURCE_ NAME ) ;  String type = properties . get Property (  Resource Property Set .  RESOURCE_ TYPE ) ;  Resource resource = new  Resource ( name , type ) ; if ( properties . contains Key (  Resource Property Set .  RESOURCE_ CLASS ) ) {  String class Name = properties . get Property (  Resource Property Set .  RESOURCE_ CLASS ) ; resource . set Class Name ( class Name ) ; } if ( properties . contains Key (  Resource Property Set .  RESOURCE_ ID ) ) {  String id = properties . get Property (  Resource Property Set .  RESOURCE_ ID ) ; resource . set Id ( id ) ; } else { resource . set Id ( create Id From Jndi Location If Not Null ( name ) ) ; }  String parameters As ASemicolon Delimited String = properties . get Property (  Resource Property Set .  PARAMETERS ) ; resource . set Parameters (  Property Utils . to Map ( get Parameters From String (  Property Utils . escape Back Slashes If Not Null ( parameters As ASemicolon Delimited String ) ) ) ) ; return resource ; }
Tree Bin (  Tree Node <  K ,  V > b ) { super (  TREEBIN , null , null , null ) ; this . first = b ;  Tree Node <  K ,  V > r = null ; for (  Tree Node <  K ,  V > x = b , next ; x != null ; x = next ) { next = (  Tree Node <  K ,  V > ) x . next ; x . left = x . right = null ; if ( r == null ) { x . parent = null ; x . red = _ BOOL ; r = x ; } else {  K k = x . key ; int h = x . hash ;  Class < ? > kc = null ; for (  Tree Node <  K ,  V > p = r ; ; ) { int dir , ph ;  K pk = p . key ; if ( ( ph = p . hash ) > h ) dir = - _ NUM ; else if ( ph < h ) dir = _ NUM ; else if ( ( kc == null && ( kc = comparable Class For ( k ) ) == null ) || ( dir = compare Comparables ( kc , k , pk ) ) == _ NUM ) dir = tie Break Order ( k , pk ) ;  Tree Node <  K ,  V > xp = p ; if ( ( p = ( dir <= _ NUM ) ? p . left : p . right ) == null ) { x . parent = xp ; if ( dir <= _ NUM ) xp . left = x ; else xp . right = x ; r = balance Insertion ( r , x ) ; break ; } } } } this . root = r ; assert check Invariants ( root ) ; }
boolean name Refs Are Legal ( ) { assert ( arity >= _ NUM && arity <= names . length ) ; assert ( result >= - _ NUM && result < names . length ) ; for ( int i = _ NUM ; i < arity ; i ++ ) {  Name n = names [ i ] ; assert ( n . index ( ) == i ) :  Arrays . as List ( n . index ( ) , i ) ; assert ( n . is Param ( ) ) ; } for ( int i = arity ; i < names . length ; i ++ ) {  Name n = names [ i ] ; assert ( n . index ( ) == i ) ; for (  Object arg : n . arguments ) { if ( arg instanceof  Name ) {  Name n2 = (  Name ) arg ; int i2 = n2 . index ; assert ( _ NUM <= i2 && i2 < names . length ) : n . debug String ( ) + _ STR + i2 + _ STR + names . length ; assert ( names [ i2 ] == n2 ) :  Arrays . as List ( _ STR , i , _ STR , n . debug String ( ) , _ STR , i2 , _ STR , n2 . debug String ( ) , _ STR , names [ i2 ] . debug String ( ) , _ STR , this ) ; assert ( i2 < i ) ; } } } return _ BOOL ; }
protected static void launch (  Class < ? extends  Activity > activity ) { final  Intent intent = new  Intent ( application , activity ) ; intent . put Extra (  CONTENT , content Layout View ) ; intent . put Extra (  BG_ COLOR , background Color ) ; intent . put Extra (  INIT_ ACTIVITY , init Activity Name ) ; intent . set Flags (  Intent .  FLAG_ ACTIVITY_ CLEAR_ TASK |  Intent .  FLAG_ ACTIVITY_ NEW_ TASK ) ; application . start Activity ( intent ) ; }
public  Set entry Set ( ) {  Set entries = super . entry Set ( ) ;  Hash Set set = new  Hash Set ( ) ;  Iterator iter = entries . iterator ( ) ; while ( iter . has Next ( ) ) {  Map .  Entry entry = (  Map .  Entry ) iter . next ( ) ; set . add ( new  Entry ( entry ) ) ; } return set ; }
public void add View To Fade List (  View view ) { if ( m Fade View List == null ) { m Fade View List = new  Linked List <  View > ( ) ; } if ( view != null ) { m Fade View List . add ( view ) ; } }
String serialize To String ( ) { final  String Builder sb = new  String Builder ( ) ; sb . append (  String . format ( _ STR , num Active , keys . length ) ) ; for ( int i = _ NUM ; i < keys . length ; i ++ ) { if ( states [ i ] != _ NUM ) { sb . append (  String . format ( _ STR , keys [ i ] , values [ i ] ) ) ; } } return sb . to String ( ) ; }
public void play Stream (  Input Stream stream ) { try { byte [ ] data = convert Stream To Byte Array ( stream ) ; if ( data . length > _ NUM ) { sample Rate = read Int ( data , _ NUM ) ; } int head Size = _ NUM , meta Data Size = _ NUM ; int dest Pos = head Size + meta Data Size ; int raw Length = data . length - dest Pos ; byte [ ] d = new byte [ raw Length ] ;  System . arraycopy ( data , dest Pos , d , _ NUM , raw Length ) ; init Player ( ) ; audio Track . write ( d , _ NUM , d . length ) ; stream . close ( ) ; if ( audio Track != null && audio Track . get State ( ) !=  Audio Track .  STATE_ UNINITIALIZED ) { audio Track . release ( ) ; } } catch (  IOException e2 ) {  Log . e (  TAG , e2 . get Message ( ) ) ; } }
public static void tql2 ( int n , double [ ] d , double [ ] e , double [ ] [ ]  V ) { for ( int i = _ NUM ; i < n ; i ++ ) { e [ i - _ NUM ] = e [ i ] ; } e [ n - _ NUM ] = _ NUM ; double f = _ NUM ; double tst1 = _ NUM ; double eps =  Math . pow ( _ NUM , - _ NUM ) ; for ( int l = _ NUM ; l < n ; l ++ ) { tst1 =  Math . max ( tst1 ,  Math . abs ( d [ l ] ) +  Math . abs ( e [ l ] ) ) ; int m = l ; while ( m < n ) { if (  Math . abs ( e [ m ] ) <= eps * tst1 ) { break ; } m ++ ; } if ( m > l ) { int iter = _ NUM ; do { iter = iter + _ NUM ; double g = d [ l ] ; double p = ( d [ l + _ NUM ] - g ) / ( _ NUM * e [ l ] ) ; double r = hypot ( p , _ NUM ) ; if ( p < _ NUM ) { r = - r ; } d [ l ] = e [ l ] / ( p + r ) ; d [ l + _ NUM ] = e [ l ] * ( p + r ) ; double dl1 = d [ l + _ NUM ] ; double h = g - d [ l ] ; for ( int i = l + _ NUM ; i < n ; i ++ ) { d [ i ] -= h ; } f = f + h ; p = d [ m ] ; double c = _ NUM ; double c2 = c ; double c3 = c ; double el1 = e [ l + _ NUM ] ; double s = _ NUM ; double s2 = _ NUM ; for ( int i = m - _ NUM ; i >= l ; i -- ) { c3 = c2 ; c2 = c ; s2 = s ; g = c * e [ i ] ; h = c * p ; r = hypot ( p , e [ i ] ) ; e [ i + _ NUM ] = s * r ; s = e [ i ] / r ; c = p / r ; p = c * d [ i ] - s * g ; d [ i + _ NUM ] = h + s * ( c * g + s * d [ i ] ) ; for ( int k = _ NUM ; k < n ; k ++ ) { h =  V [ k ] [ i + _ NUM ] ;  V [ k ] [ i + _ NUM ] = s *  V [ k ] [ i ] + c * h ;  V [ k ] [ i ] = c *  V [ k ] [ i ] - s * h ; } } p = - s * s2 * c3 * el1 * e [ l ] / dl1 ; e [ l ] = s * p ; d [ l ] = c * p ; } while (  Math . abs ( e [ l ] ) > eps * tst1 ) ; } d [ l ] = d [ l ] + f ; e [ l ] = _ NUM ; } for ( int i = _ NUM ; i < n - _ NUM ; i ++ ) { int k = i ; double p = d [ i ] ; for ( int j = i + _ NUM ; j < n ; j ++ ) { if ( d [ j ] < p ) { k = j ; p = d [ j ] ; } } if ( k != i ) { d [ k ] = d [ i ] ; d [ i ] = p ; for ( int j = _ NUM ; j < n ; j ++ ) { p =  V [ j ] [ i ] ;  V [ j ] [ i ] =  V [ j ] [ k ] ;  V [ j ] [ k ] = p ; } } } }
public static double calculate Column Total (  Values2 D data , int column ) {  Param Checks . null Not Permitted ( data , _ STR ) ; double total = _ NUM ; int row Count = data . get Row Count ( ) ; for ( int r = _ NUM ; r < row Count ; r ++ ) {  Number n = data . get Value ( r , column ) ; if ( n != null ) { total += n . double Value ( ) ; } } return total ; }
public static boolean check File ( final  File f ) { return f . exists ( ) && f . is File ( ) && f . can Read ( ) ; }
public void children Removed (  Bean Context Membership Event bcme ) {  Iterator it = bcme . iterator ( ) ; while ( it . has Next ( ) ) { find And Undo ( it . next ( ) ) ; } }
public  String process (  Item item ) throws  Process Exception { int count = _ NUM ;  Item ss = item . get Item As (  Relation .  SYLLABLE ) ;  Item first Syllable =  FIRST_ SYLLABLE_ PATH . find Item ( item ) ; for (  Item p = ss ; p != null ; p = p . get Previous ( ) , count ++ ) { if ( p . equals Shared ( first Syllable ) ) { break ; } } return  Integer . to String ( rail ( count ) ) ; }
private void remove Instances From Containers (  Array List <  Container > containers ,  Map <  Integer ,  List <  Instance Id > > allocation ,  Map <  String ,  Integer > components To Scale Down ) {  Array List <  Ram Requirement > ram Requirements = get Sorted RAMInstances ( components To Scale Down ) ; for (  Ram Requirement ram Requirement : ram Requirements ) {  String component = ram Requirement . get Component Name ( ) ; int num Instances To Remove = - components To Scale Down . get ( component ) ; for ( int j = _ NUM ; j < num Instances To Remove ; j ++ ) {  Pair <  Integer ,  Instance Id > id Pair = remove FFDInstance ( containers , component ) ;  List <  Instance Id > instances = allocation . get ( id Pair . first ) ; instances . remove ( id Pair . second ) ; allocation . put ( id Pair . first , instances ) ; } } }
private void draw Lifeline Part (  Draw Handler draw Handler , final double center X , final double start Y , boolean active Count Inc Start , final double end Y , boolean active Count Inc End , int active Count ,  List Iterator <  Line1 D > interrupted Areas ) { double next Start Y = start Y ; boolean draw Head = _ BOOL ; if ( interrupted Areas . has Next ( ) ) {  Line1 D area = interrupted Areas . next ( ) ; if ( area . contains ( next Start Y ) ) { draw Head = _ BOOL ; next Start Y = area . get High ( ) ; } else { interrupted Areas . previous ( ) ; } } boolean drawing Finished = _ BOOL ; boolean draw End = _ BOOL ; double current End Y ; double current Start Y ; while ( ! drawing Finished ) { current Start Y = next Start Y ; if ( interrupted Areas . has Next ( ) ) {  Line1 D area = interrupted Areas . next ( ) ; if ( area . get Low ( ) < end Y ) { current End Y = area . get Low ( ) ; next Start Y = area . get High ( ) ; if ( area . get High ( ) > end Y ) { drawing Finished = _ BOOL ; interrupted Areas . previous ( ) ; } } else { interrupted Areas . previous ( ) ; drawing Finished = _ BOOL ; draw End = _ BOOL ; current End Y = end Y ; } } else { drawing Finished = _ BOOL ; draw End = _ BOOL ; current End Y = end Y ; } if ( active Count == _ NUM ) { draw Handler . set Line Type (  Line Type .  DASHED ) ; draw Handler . draw Line ( center X , current Start Y , center X , current End Y ) ; } else { draw Handler . set Line Type (  Line Type .  SOLID ) ; double line X = center X -  EXECUTIONSPECIFICATION_ WIDTH / _ NUM ; draw Handler . draw Line ( line X , current Start Y , line X , current End Y ) ; for ( int i = _ NUM ; i < active Count - _ NUM ; i ++ ) { line X +=  EXECUTIONSPECIFICATION_ WIDTH -  EXECUTIONSPECIFICATION_ OVERLAPP ; draw Handler . draw Line ( line X , current Start Y , line X , current End Y ) ; } line X +=  EXECUTIONSPECIFICATION_ WIDTH ; draw Handler . draw Line ( line X , current Start Y , line X , current End Y ) ; if ( draw Head && active Count Inc Start ) { draw Handler . draw Line ( line X -  EXECUTIONSPECIFICATION_ WIDTH , current Start Y , line X , current Start Y ) ; } if ( draw End && ! active Count Inc End ) { draw Handler . draw Line ( line X -  EXECUTIONSPECIFICATION_ WIDTH , current End Y , line X , current End Y ) ; } } draw Head = _ BOOL ; } }
public void notify Changed Slot (  Loco Net Slot s ) {  Dcc Throttle throttle = new  Loco Net Throttle ( (  Loco Net System Connection Memo ) adapter Memo , s ) ; notify Throttle Known ( throttle , new  Dcc Loco Address ( s . loco Addr ( ) , is Long Address ( s . loco Addr ( ) ) ) ) ; if ( waiting For Notification . contains Key ( s . loco Addr ( ) ) ) {  Thread r = waiting For Notification . get ( s . loco Addr ( ) ) ; synchronized ( r ) { r . interrupt ( ) ; } waiting For Notification . remove ( s . loco Addr ( ) ) ; } }
private static void start Listening ( final  Ignite ignite ,  Ignite Messaging imsg ) throws  Ignite Exception { imsg . remote Listen (  TOPIC .  ORDERED , null ) ; imsg . remote Listen (  TOPIC .  UNORDERED , null ) ; }
public static void register Experimental Flags (  CFlags flags ) { reset Accessed Status ( ) ; final  String [ ] cat = flags . get Categories ( ) ; if ( cat != null ) { final  String [ ] copy =  Arrays . copy Of ( cat , cat . length + _ NUM ) ; copy [ copy . length - _ NUM ] =  CATEGORY ; flags . set Categories ( flags . get Help Category ( ) , copy ) ; } for ( final  Flag flag :  FLAGS ) { flags . register ( flag ) ; } s Flags = flags ; }
@  Suppress Warnings ( _ STR ) private void dtdelm ( ) throws  Exception { wsskip ( ) ; name ( m Is NSAware ) ; char ch ; while ( _ BOOL ) { ch = getch ( ) ; switch ( ch ) { case _ STR : bkch ( ) ; return ; case  EOS : panic (  FAULT ) ; default : break ; } } }
boolean sentence Match Expression ( final  Expression other ) { final  String match String = other . get Normalized ( ) ; if ( match String . contains (  JOKER ) ) { if ( match String . equals (  JOKER ) ) { if ( ! matches Joker String ( get Type String ( ) , other . get Type String ( ) ) ) { return _ BOOL ; } } else { if ( ! matches Joker String ( get Normalized ( ) , match String ) ) { return _ BOOL ; } } } else if ( other . get Matcher ( ) != null ) { return original . equals ( other . original ) ; } else if ( ! matches Normalized ( other ) ) { return _ BOOL ; } return _ BOOL ; }
public static  String format Time (  String millis ) {  String result ; try { long time =  Long . value Of ( millis ) ; result = format Time ( time ) ; } catch (  Number Format Exception e ) { throw new  Illegal Argument Exception ( _ STR + millis ) ; } return result ; }
public static byte [ ] decode (  String input ) throws  Parse Exception { if ( input . length ( ) == _ NUM ) { return new byte [ _ NUM ] ; } byte [ ] input58 = new byte [ input . length ( ) ] ; for ( int i = _ NUM ; i < input . length ( ) ; ++ i ) { char c = input . char At ( i ) ; int digit = c < _ NUM ?  INDEXES [ c ] : - _ NUM ; if ( digit < _ NUM ) { throw new  Parse Exception ( _ STR + c + _ STR + i , i ) ; } input58 [ i ] = ( byte ) digit ; } int zeros = _ NUM ; while ( zeros < input58 . length && input58 [ zeros ] == _ NUM ) { ++ zeros ; } byte [ ] decoded = new byte [ input . length ( ) ] ; int output Start = decoded . length ; for ( int input Start = zeros ; input Start < input58 . length ; ) { decoded [ -- output Start ] = divmod ( input58 , input Start , _ NUM , _ NUM ) ; if ( input58 [ input Start ] == _ NUM ) { ++ input Start ; } } while ( output Start < decoded . length && decoded [ output Start ] == _ NUM ) { ++ output Start ; } return  Arrays . copy Of Range ( decoded , output Start - zeros , decoded . length ) ; }
private boolean remove Groups Int (  String [ ] old Groups ) { boolean removed = _ BOOL ; for ( int i = _ NUM ; i < old Groups . length ; i ++ ) { removed |= groups . remove ( old Groups [ i ] ) ; } return removed ; }
public  Gaussian Density Function ( double [ ] mean , double [ ] variance ) { this . mean = mean ; if ( mean . length != variance . length ) { log . warning ( _ STR ) ; } std Dev = new double [ variance . length ] ; for ( int i = _ NUM ; i < variance . length ; i ++ ) { if ( variance [ i ] < _ NUM ) { log . warning ( _ STR + variance ) ; } std Dev [ i ] =  Math . sqrt ( variance [ i ] ) ; } this . variance = variance ; }
public  String to String ( ) {  String Builder buf = new  String Builder ( ) ; for (  Node node1 : nodes To Variables . key Set ( ) ) { buf . append ( _ STR ) ; buf . append ( ( node1 ) ) ; buf . append ( _ STR ) ;  Discrete Variable variable = nodes To Variables . get ( ( node1 ) ) ; for ( int j = _ NUM ; j < variable . get Num Categories ( ) ; j ++ ) { buf . append ( variable . get Category ( j ) ) ; if ( j < variable . get Num Categories ( ) - _ NUM ) { buf . append ( _ STR ) ; } } } return buf . to String ( ) ; }
public  Stream Resource Bundle (  Input Stream stream ) throws  IOException { props = new  Properties ( ) ; props . load ( stream ) ; }
private  Attribute Schema Impl check And Update Choice Values (  Attribute Schema Impl existing Attr ,  Attribute Schema Impl new Attr ,  List <  String > new Choices ) throws  Upgrade Exception {  List <  String > choices = new  Array List < > (  Arrays . as List ( existing Attr . get Choice Values ( ) ) ) ; if ( choices . contains All ( new Choices ) ) { return null ; } else { choices . add All ( new Choices ) ; update Choice Values ( new Attr , choices ) ; } return new Attr ; }
public final boolean is Registered ( ) { return ! canonical Name . starts With ( _ STR ) && ! canonical Name . starts With ( _ STR ) ; }
private void startup Acceptor ( ) throws  Interrupted Exception { if ( ! selectable ) { register Queue . clear ( ) ; cancel Queue . clear ( ) ; }  Acceptor acceptor = acceptor Ref . get ( ) ; if ( acceptor == null ) { lock . acquire ( ) ; acceptor = new  Acceptor ( ) ; if ( acceptor Ref . compare And Set ( null , acceptor ) ) { execute Worker ( acceptor ) ; } else { lock . release ( ) ; } } }
public static  String replace All (  String str ,  String original Token ,  String replacement Token ) { return str . replace All (  Pattern . quote ( original Token ) ,  Matcher . quote Replacement ( replacement Token ) ) ; }
public static  List <  Container > create Container List ( int broker Id , int containers Number ) {  Array List <  Container > containers = new  Array List <  Container > ( ) ; for ( int i = _ NUM ; i < containers Number ; ++ i ) { int container Type = i / ( int )  Math . ceil ( ( double ) containers Number / _ NUM ) ; containers . add ( new  Power Container (  IDs . poll Id (  Container . class ) , broker Id , ( double )  Constants Examples .  CONTAINER_ MIPS [ container Type ] ,  Constants Examples .  CONTAINER_ PES [ container Type ] ,  Constants Examples .  CONTAINER_ RAM [ container Type ] ,  Constants Examples .  CONTAINER_ BW , _ NUM , _ STR , new  Container Cloudlet Scheduler Dynamic Workload (  Constants Examples .  CONTAINER_ MIPS [ container Type ] ,  Constants Examples .  CONTAINER_ PES [ container Type ] ) ,  Constants Examples .  SCHEDULING_ INTERVAL ) ) ; } return containers ; }
public static boolean is Local Resource Uri ( @  Nullable  Uri uri ) { final  String scheme = get Scheme Or Null ( uri ) ; return  LOCAL_ RESOURCE_ SCHEME . equals ( scheme ) ; }
protected  Data Input Stream open File On Mounted Obb (  String obb Path ,  String file Name ) { assert True ( _ STR , m Sm . is Obb Mounted ( obb Path ) ) ;  String path = m Sm . get Mounted Obb Path ( obb Path ) ; assert True ( _ STR , path != null ) ;  File in File = new  File ( path , file Name ) ;  Data Input Stream in Stream = null ; try { in Stream = new  Data Input Stream ( new  File Input Stream ( in File ) ) ;  Log . i (  LOG_ TAG , _ STR + file Name + _ STR + path ) ; } catch (  File Not Found Exception e ) {  Log . e (  LOG_ TAG , e . to String ( ) ) ; return null ; } catch (  Security Exception e ) {  Log . e (  LOG_ TAG , e . to String ( ) ) ; return null ; } return in Stream ; }
public static  String read Payload (  Buffered Reader socket Reader , int payload Length ) throws  IOException ,  Replicator Exception { if ( payload Length == _ NUM ) { return _ STR ; } else if ( payload Length == - _ NUM ) { return null ; } char [ ] buf = new char [ _ NUM ] ;  String Builder payload = new  String Builder ( ) ; do { int bytes Read = socket Reader . read ( buf , _ NUM , buf . length ) ; if ( bytes Read > _ NUM ) payload . append ( new  String ( buf , _ NUM , bytes Read ) ) ; } while ( payload . length ( ) < payload Length ) ; if ( payload . length ( ) != payload Length ) { throw new  Replicator Exception ( _ STR + payload Length + _ STR + payload . length ( ) + _ STR + payload ) ; } return payload . to String ( ) ; }
private boolean is Source And Target Different ( ) { boolean result = _ BOOL ;  String source Vendor = _ STR ;  String target Vendor = _ STR ;  String source Url = _ STR ;  String target Url = _ STR ;  String source Catalog = _ STR ;  String target Catalog = _ STR ;  String source Schema = _ STR ;  String target Schema = _ STR ; if ( m_source . get Vendor ( ) != null ) source Vendor = m_source . get Vendor ( ) ; if ( m_target . get Vendor ( ) != null ) target Vendor = m_target . get Vendor ( ) ; if ( m_source . get Url ( ) != null ) source Url = m_source . get Url ( ) ; if ( m_target . get Url ( ) != null ) target Url = m_target . get Url ( ) ; if ( m_source . get Catalog ( ) != null ) source Catalog = m_source . get Catalog ( ) ; if ( m_target . get Catalog ( ) != null ) target Catalog = m_target . get Catalog ( ) ; if ( m_source . get Schema ( ) != null ) source Schema = m_source . get Schema ( ) ; if ( m_target . get Schema ( ) != null ) target Schema = m_target . get Schema ( ) ; if ( ! source Vendor . equals Ignore Case ( target Vendor ) ) result = _ BOOL ; else if ( ! source Url . equals Ignore Case ( target Url ) ) result = _ BOOL ; else if ( ! source Catalog . equals Ignore Case ( target Catalog ) ) result = _ BOOL ; else if ( ! source Schema . equals Ignore Case ( target Schema ) ) result = _ BOOL ; if ( ! result ) s_logger . log (  Level .  SEVERE , _ STR ) ; return result ; }
public static byte [ ]  SHA1 ( final byte [ ] message , final int offset , final int length ) {  Message Digest digest ; try { digest =  Message Digest . get Instance ( _ STR ) ; digest . update ( message , offset , length ) ; final byte [ ] sha1 = digest . digest ( ) ; return sha1 ; } catch ( final  No Such Algorithm Exception e ) { if (  Cfg .  EXCEPTION ) {  Check . log ( e ) ; } } return null ; }
@  Override public  Table Dto create ( @  Nonnull  Qualified Name name ) {  Table Dto result = null ; log . info ( _ STR , name ) ;  Optional <  Table Dto > o Table = table Service . get ( name , _ BOOL ) ; if ( o Table . is Present ( ) ) {  Table Dto table = o Table . get ( ) ;  String view Name = create View Name ( name ) ;  Qualified Name target Name =  Qualified Name . of Table ( name . get Catalog Name ( ) ,  VIEW_ DB_ NAME , view Name ) ; log . info ( _ STR , target Name ) ;  Optional <  Table Dto > o View Table =  Optional . empty ( ) ; try { o View Table = table Service . get ( target Name , _ BOOL ) ; } catch (  Not Found Exception ignored ) { } if ( ! o View Table . is Present ( ) ) { log . info ( _ STR , target Name ) ; result = table Service . copy ( table , target Name ) ; } else { result = o View Table . get ( ) ; } } else { throw new  Table Not Found Exception ( new  Schema Table Name ( name . get Database Name ( ) , name . get Table Name ( ) ) ) ; } return result ; }
public void delete Users (  Set users ) throws  AMException ,  SSOException {  Iterator iter = users . iterator ( ) ; while ( iter . has Next ( ) ) {  String user DN = (  String ) iter . next ( ) ;  AMUser user = new  AMUser Impl ( super . token , user DN ) ; user . delete ( ) ; } }
private void test Count Messages In Mailbox ( ) throws  Exception {  LOG . info ( _ STR ) ; long message Count = message Mapper . count Messages In Mailbox (  MBOXES . get ( _ NUM ) ) ; assert Equals (  MESSAGE_ NO . size ( ) , message Count ) ; }
public void assert All Consumed ( ) throws  Parse Exception {  String Buffer message = new  String Buffer ( ) ; if ( ! attrs . is Empty ( ) ) { message . append ( _ STR ) ; if ( attrs . size ( ) > _ NUM ) { message . append ( _ STR ) ; } message . append ( _ STR ) ; for (  String name : attrs . key Set ( ) ) { message . append ( _ STR ) ; message . append ( name ) ; message . append ( _ STR ) ; } } if ( ! dups . is Empty ( ) ) { message . append ( _ STR ) ; if ( dups . size ( ) > _ NUM ) { message . append ( _ STR ) ; } message . append ( _ STR ) ; for (  String dup : dups ) { message . append ( _ STR ) ; message . append ( dup ) ; message . append ( _ STR ) ; } } if ( ! content Consumed && content != null && content . length ( ) != _ NUM ) { message . append ( _ STR ) ; } if ( message . length ( ) != _ NUM ) { throw new  Parse Exception ( message . to String ( ) ) ; } }
public static <  V >  Map <  String ,  V > remove Multi Form Parameters (  Map <  String ,  V > parameters ) {  Map <  String ,  V > filtered Parameters = new  Hash Map <  String ,  V > ( ) ; for (  Map .  Entry <  String ,  V > entry : parameters . entry Set ( ) ) {  String key = entry . get Key ( ) ; if ( key != null && ( key . index Of (  MULTI_ ROW_ DELIMITER ) != - _ NUM || key . index Of ( _ STR ) != - _ NUM || key . index Of ( _ STR ) != - _ NUM ) ) { continue ; } filtered Parameters . put ( key , entry . get Value ( ) ) ; } return filtered Parameters ; }
public  String query (  String handler ,  Solr Query Request req ) throws  Exception { try {  Solr Core core = req . get Core ( ) ;  Solr Query Response rsp = new  Solr Query Response ( ) ;  Solr Request Info . set Request Info ( new  Solr Request Info ( req , rsp ) ) ; core . execute ( core . get Request Handler ( handler ) , req , rsp ) ; if ( rsp . get Exception ( ) != null ) { throw rsp . get Exception ( ) ; }  String Writer sw = new  String Writer ( _ NUM ) ;  Query Response Writer response Writer = core . get Query Response Writer ( req ) ; response Writer . write ( sw , req , rsp ) ; return sw . to String ( ) ; } finally { req . close ( ) ;  Solr Request Info . clear Request Info ( ) ; } }
private boolean parse Autolink ( ) {  String m ; if ( ( m = match (  EMAIL_ AUTOLINK ) ) != null ) {  String dest = m . substring ( _ NUM , m . length ( ) - _ NUM ) ;  Link node = new  Link ( _ STR + dest , null ) ; node . append Child ( new  Text ( dest ) ) ; append Node ( node ) ; return _ BOOL ; } else if ( ( m = match (  AUTOLINK ) ) != null ) {  String dest = m . substring ( _ NUM , m . length ( ) - _ NUM ) ;  Link node = new  Link ( dest , null ) ; node . append Child ( new  Text ( dest ) ) ; append Node ( node ) ; return _ BOOL ; } else { return _ BOOL ; } }
public static  String join Punctuation Marks (  String line ) {  String result = line ; result = result . replace ( _ STR , _ STR ) ; result = result . replace ( _ STR , _ STR ) ; result = result . replace ( _ STR , _ STR ) ; result = result . replace ( _ STR , _ STR ) ; result = result . replace ( _ STR , _ STR ) ; result = result . replace ( _ STR , _ STR ) ; result = result . replace ( _ STR , _ STR ) ; result = result . replace ( _ STR , _ STR ) ; result = result . replace ( _ STR , _ STR ) ; result = result . replace ( _ STR , _ STR ) ; result = result . replace ( _ STR , _ STR ) ; result = result . replace ( _ STR , _ STR ) ; result = result . replace ( _ STR , _ STR ) ; result = result . replace ( _ STR , _ STR ) ; return result ; }
@  Suppress Warnings ( { _ STR , _ STR } ) private static  Object to Set (  Object value ,  Class < ? > parameter Type ) throws  Gf Json Exception { try {  JSONArray array = (  JSONArray ) value ;  Set set = new  Hash Set ( ) ; for ( int i = _ NUM ; i < array . length ( ) ; i ++ ) {  Object element = array . get ( i ) ; if ( is Primitive Or Wrapper ( element . get Class ( ) ) ) { set . add ( element ) ; } else throw new  Gf Json Exception ( _ STR ) ; } return set ; } catch (  JSONException e ) { throw new  Gf Json Exception ( e ) ; } }
public  Money add (  Money money ) { assert Defined ( ) ; if ( null == m_value ) { if ( null == money . get Big Decimal Value ( ) ) { return new  Money ( ) ; } else { return new  Money ( money . get Big Decimal Value ( ) ) ; } }  Big Decimal value = m_value . add ( money . get Big Decimal Value ( ) ) ; return new  Money ( value ) ; }
private void delete Instance (  Entry Class eclass ) { int idx = entry Classes . index Of ( eclass ) ; if ( idx < _ NUM ) { return ; } eclass = entry Classes . get ( idx ) ; int num = eclass . get Num Instances ( ) - _ NUM ; if ( num == _ NUM ) entry Classes . remove ( idx ) ; eclass . set Num Instances ( num ) ; }
public void log Severe (  String message ) { logger . severe ( log Prefix + message ) ; }
public static  Byte Array List read As Bytes (  Input Stream is ) throws  IOException {  Byte Array List buf = new  Byte Array List ( ) ; byte [ ] b = new byte [ _ NUM ] ; int nread = - _ NUM ; while ( ( nread = is . read ( b ) ) >= _ NUM ) { buf . add ( b , _ NUM , nread ) ; } return buf ; }
public  Array Real Vector ( int size , double preset ) { data = new double [ size ] ;  Arrays . fill ( data , preset ) ; }
public static synchronized void register Transaction Service Plugin (  Transaction Service Plugin l ) { if ( service_ != null ) { service_ . add TSListener ( l ) ; } ts Listeners List_ . add ( l ) ; }
private void priority Layout2 ( int level [ ] , int priorities [ ] , int b Centers [ ] , int hor Positions [ ] ) { int desc Order [ ] = new int [ priorities . length ] ; desc Order [ _ NUM ] = _ NUM ; for ( int i = _ NUM ; i < priorities . length - _ NUM ; i ++ ) { int j = i ; int temp = i + _ NUM ; while ( j > - _ NUM && priorities [ desc Order [ j ] ] < priorities [ temp ] ) { desc Order [ j + _ NUM ] = desc Order [ j ] ; j -- ; } j ++ ; desc Order [ j ] = temp ; } for ( int k = _ NUM ; k < desc Order . length ; k ++ ) { for ( int i = _ NUM ; i < desc Order . length ; i ++ ) { int left Count = _ NUM , right Count = _ NUM , left Nodes [ ] , right Nodes [ ] ; for ( int j = _ NUM ; j < priorities . length ; j ++ ) { if ( hor Positions [ level [ desc Order [ i ] ] ] > hor Positions [ level [ j ] ] ) { left Count ++ ; } else if ( hor Positions [ level [ desc Order [ i ] ] ] < hor Positions [ level [ j ] ] ) { right Count ++ ; } } left Nodes = new int [ left Count ] ; right Nodes = new int [ right Count ] ; for ( int j = _ NUM , l = _ NUM , r = _ NUM ; j < priorities . length ; j ++ ) { if ( hor Positions [ level [ desc Order [ i ] ] ] > hor Positions [ level [ j ] ] ) { left Nodes [ l ++ ] = j ; } else if ( hor Positions [ level [ desc Order [ i ] ] ] < hor Positions [ level [ j ] ] ) { right Nodes [ r ++ ] = j ; } } while (  Math . abs ( hor Positions [ level [ desc Order [ i ] ] ] - _ NUM - b Centers [ desc Order [ i ] ] ) <  Math . abs ( hor Positions [ level [ desc Order [ i ] ] ] - b Centers [ desc Order [ i ] ] ) ) { int temp = hor Positions [ level [ desc Order [ i ] ] ] ; boolean cant Move = _ BOOL ; for ( int j = left Nodes . length - _ NUM ; j >= _ NUM ; j -- ) { if ( temp - hor Positions [ level [ left Nodes [ j ] ] ] > _ NUM ) { break ; } else if ( priorities [ desc Order [ i ] ] <= priorities [ left Nodes [ j ] ] ) { cant Move = _ BOOL ; break ; } else { temp = hor Positions [ level [ left Nodes [ j ] ] ] ; } } if ( cant Move ) { break ; } temp = hor Positions [ level [ desc Order [ i ] ] ] - _ NUM ; for ( int j = left Nodes . length - _ NUM ; j >= _ NUM ; j -- ) { if ( temp == hor Positions [ level [ left Nodes [ j ] ] ] ) { hor Positions [ level [ left Nodes [ j ] ] ] = temp = hor Positions [ level [ left Nodes [ j ] ] ] - _ NUM ; } } hor Positions [ level [ desc Order [ i ] ] ] = hor Positions [ level [ desc Order [ i ] ] ] - _ NUM ; } while (  Math . abs ( hor Positions [ level [ desc Order [ i ] ] ] + _ NUM - b Centers [ desc Order [ i ] ] ) <  Math . abs ( hor Positions [ level [ desc Order [ i ] ] ] - b Centers [ desc Order [ i ] ] ) ) { int temp = hor Positions [ level [ desc Order [ i ] ] ] ; boolean cant Move = _ BOOL ; for ( int right Node : right Nodes ) { if ( hor Positions [ level [ right Node ] ] - temp > _ NUM ) { break ; } else if ( priorities [ desc Order [ i ] ] <= priorities [ right Node ] ) { cant Move = _ BOOL ; break ; } else { temp = hor Positions [ level [ right Node ] ] ; } } if ( cant Move ) { break ; } temp = hor Positions [ level [ desc Order [ i ] ] ] + _ NUM ; for ( int j = _ NUM ; j < right Nodes . length ; j ++ ) { if ( temp == hor Positions [ level [ right Nodes [ j ] ] ] ) { hor Positions [ level [ right Nodes [ j ] ] ] = temp = hor Positions [ level [ right Nodes [ j ] ] ] + _ NUM ; } } hor Positions [ level [ desc Order [ i ] ] ] = hor Positions [ level [ desc Order [ i ] ] ] + _ NUM ; } } } }
private void reassess Model ( ) { if ( this . model Param Types == null ) { return ; } for (  Class clazz : this . model Param Types ) { if ( clazz == null ) { return ; } }  List <  Class < ? extends  Object > > list1 = new  Array List < > ( ) ; for (  Session Node node : this . parents ) {  Object model = node . get Model ( ) ; if ( model != null ) { list1 . add ( model . get Class ( ) ) ; } }  List <  Class > list2 =  Arrays . as List ( this . model Param Types ) ; if ( ! list1 . contains ( list2 ) || ! list2 . contains ( list1 ) ) { destroy Model ( ) ; } }
public void find And Init (  Object some Obj ) { if ( some Obj instanceof  Map Bean ) { set Map ( (  Map Bean ) some Obj ) ; } }
public void add Layer (  Layer layer , int min Zoom Level , int max Zoom Level ) { _layers . add Element ( new  Layer With Zoom Levels ( layer , min Zoom Level , max Zoom Level ) ) ; refresh Layers = _ BOOL ; super . repaint ( ) ; }
private void write Object ( final  Object Output Stream oos ) throws  IOException { oos . default Write Object ( ) ; }
public int compare (  Object o1 ,  Object o2 ) { if ( o1 == null ) throw new  Illegal Argument Exception ( _ STR ) ; if ( o2 == null ) throw new  Illegal Argument Exception ( _ STR ) ;  MRf QResponse Line Qty q1 = null ;  MRf QResponse Line Qty q2 = null ; if ( o1 instanceof  MRf QResponse Line Qty ) q1 = (  MRf QResponse Line Qty ) o1 ; else throw new  Class Cast Exception ( _ STR ) ; if ( o2 instanceof  MRf QResponse Line Qty ) q2 = (  MRf QResponse Line Qty ) o2 ; else throw new  Class Cast Exception ( _ STR ) ; if ( ! q1 . is Valid Amt ( ) ) return - _ NUM ; if ( ! q2 . is Valid Amt ( ) ) return + _ NUM ;  Big Decimal net1 = q1 . get Net Amt ( ) ; if ( net1 == null ) return - _ NUM ;  Big Decimal net2 = q2 . get Net Amt ( ) ; if ( net2 == null ) return + _ NUM ; return net1 . compare To ( net2 ) ; }
public static void verify Getter Methods (  Class < ? > clazz ,  Mapped Field ... fields ) { for (  Mapped Field field : fields ) {  String field Name = field . get Name ( ) ;  Class < ? > field Type = field . get Type ( ) ;  String custom Get = field . get Method ( ) ; if ( ! is Null ( custom Get ) && ! custom Get . equals (  Constants .  DEFAULT_ ACCESSOR_ VALUE ) ) try { clazz . get Method ( custom Get ) ; continue ; } catch (  Exception e ) {  Error . custom Method ( _ STR , custom Get , clazz ) ; }  String method Name = get Method ( field Type , field Name ) ; try { clazz . get Method ( method Name ) ; } catch (  Exception e ) { if ( ! is Boolean ( field Type ) )  Error . method ( method Name , field Name , clazz ) ; try { method Name = ( m Get ( field Name ) ) ; clazz . get Method ( method Name ) ; } catch (  Exception e1 ) {  Error . method ( method Name , field Name , clazz ) ; } } field . get Method ( method Name ) ; } }
public static boolean addresses Are Equal (  String host1 ,  String host2 ) { try {  Host Address host1 Address = get By Name ( host1 ) ;  Host Address host2 Address = get By Name ( host2 ) ; byte [ ] host1 Raw = host1 Address . get Address ( ) ; byte [ ] host2 Raw = host2 Address . get Address ( ) ; for ( int octet = _ NUM ; octet < _ NUM ; octet ++ ) { if ( host1 Raw [ octet ] != host2 Raw [ octet ] ) return _ BOOL ; } return _ BOOL ; } catch (  Exception e ) {  CLUtils . println (  String . format ( _ STR , host1 , host2 , e ) ) ; return _ BOOL ; } }
public void remove Membership Listener (  Membership Listener listener ) { membership Listeners . remove ( listener ) ; }
public static  Uri add Message To Uri (  Content Resolver resolver ,  Uri uri ,  String address ,  String body ,  String subject ,  Long date , boolean read , boolean delivery Report ) { return add Message To Uri ( resolver , uri , address , body , subject , date , read , delivery Report , - _ NUM ) ; }
private void present ( ) { gl Use Program ( quad Program ) ; gl Bind Vertex Array ( vao ) ; gl Bind Texture (  GL_ TEXTURE_2 D , tex ) ; gl Bind Sampler ( _ NUM , this . sampler ) ; gl Draw Arrays (  GL_ TRIANGLES , _ NUM , _ NUM ) ; gl Bind Sampler ( _ NUM , _ NUM ) ; gl Bind Texture (  GL_ TEXTURE_2 D , _ NUM ) ; gl Bind Vertex Array ( _ NUM ) ; gl Use Program ( _ NUM ) ; }
public static  Calendar previous (  Calendar self ) {  Calendar result = (  Calendar ) self . clone ( ) ; result . add (  Calendar .  DAY_ OF_ YEAR , - _ NUM ) ; return result ; }
public static void register Horse Armor (  Resource Location id ,  Horse Armor Type type ) {  Automatic Namespaced Registry <  Resource Location ,  Horse Armor Type > registry =  Registries . get (  Horse Armor Type . class ) ; if ( type == null ) { throw new  Null Pointer Exception ( _ STR ) ; } else if ( id == null ) { throw new  Null Pointer Exception ( _ STR ) ; } else if ( registry . contains Key ( id ) ) { throw new  Illegal Argument Exception (  String . format ( _ STR , id ) ) ; } registry . register ( id , type ) ; }
public static <  T > void remove All (  List <  T > list ,  Integer ... indexes ) {  List <  Integer > inx = new  Array List < > (  Arrays . as List ( indexes ) ) ; remove All ( list , inx ) ; }
public  CView Selection Tree ( final  Window dialog , final  IView Container container ) { final  Default Tree Model model = new  Default Tree Model ( null ) ; set Model ( model ) ; set Root Visible ( _ BOOL ) ; model . set Root ( new  CRoot Node ( dialog , container , model ) ) ;  Preconditions . check Not Null ( container , _ STR ) ; set Root Visible ( _ BOOL ) ; set Cell Renderer ( new  Icon Node Renderer ( ) ) ; add Mouse Listener ( new  Internal Mouse Listener ( ) ) ; }
public boolean is Question ( ) { return type String . starts With (  QUESTION ) ; }
public void clear Mods Already Requested (  String channel ) { if ( channel == null ) { mods Already Requested . clear ( ) ; } else { mods Already Requested . remove ( channel ) ; } }
public  Big Decimal invoke (  MDepreciation Workfile assetwk ,  MAsset Acct asset Acct , int  A_ Current_ Period ,  Big Decimal  Accum_ Dep ) {  String depreciation Type = get Depreciation Type ( ) ;  Big Decimal ret Value = null ; if (  CLog Mgt . is Level Finest ( ) ) { log . fine ( _ STR + depreciation Type + _ STR + assetwk + _ STR + asset Acct + _ STR +  A_ Current_ Period + _ STR +  Accum_ Dep ) ; } if ( ! can Invoke ( assetwk , asset Acct ,  A_ Current_ Period ,  Accum_ Dep ) ) { return  Big Decimal .  ZERO ; } if ( depreciation Type . equals Ignore Case ( _ STR ) ) { ret Value = apply_ SL ( assetwk , asset Acct ,  A_ Current_ Period ,  Accum_ Dep ) ; } else if ( depreciation Type . equals Ignore Case ( _ STR ) ) { ret Value = apply_ ARH_ VAR ( assetwk , asset Acct ,  A_ Current_ Period ,  Accum_ Dep ) ; } else if ( depreciation Type . equals Ignore Case ( _ STR ) ) { ret Value = apply_ ARH_ AD1 ( assetwk , asset Acct ,  A_ Current_ Period ,  Accum_ Dep ) ; } else if ( depreciation Type . equals Ignore Case ( _ STR ) ) { ret Value = apply_ ARH_ AD2 ( assetwk , asset Acct ,  A_ Current_ Period ,  Accum_ Dep ) ; } else if ( depreciation Type . equals Ignore Case ( _ STR ) ) { ret Value = apply_ ARH_ ZERO ( assetwk , asset Acct ,  A_ Current_ Period ,  Accum_ Dep ) ; } else { throw new  Asset Not Supported Exception (  COLUMNNAME_ Depreciation Type , depreciation Type ) ; } if ( ret Value == null ) { ret Value =  Big Decimal .  ZERO ; } ret Value = ret Value . set Scale ( get Precision ( ) ,  Rounding Mode .  HALF_ UP ) ; if (  CLog Mgt . is Level Finest ( ) ) log . fine ( _ STR + ret Value ) ; return ret Value ; }
@  Override public boolean contains (  Object value ) { if ( value == null ) { return _ BOOL ; } final  Iterator it = new  Step Iterator ( this , step Size ) ; while ( it . has Next ( ) ) { if ( compare Equal ( value , it . next ( ) ) ) { return _ BOOL ; } } return _ BOOL ; }
public synchronized void delete File (  JDBCSequential File file ) throws  SQLException { try { connection . set Auto Commit ( _ BOOL ) ; delete File . set Int ( _ NUM , file . get Id ( ) ) ; delete File . execute Update ( ) ; connection . commit ( ) ; } catch (  SQLException e ) { connection . rollback ( ) ; throw e ; } }
@  Override public boolean truncate (  String file Name , long valid Data End Offset ) {  Data Output Stream data Output Stream = null ;  Data Input Stream data Input Stream = null ; boolean file Truncated Successfully = _ BOOL ; int buffer Size = valid Data End Offset >  Carbon Common Constants .  BYTE_ TO_ KB_ CONVERSION_ FACTOR ?  Carbon Common Constants .  BYTE_ TO_ KB_ CONVERSION_ FACTOR : ( int ) valid Data End Offset ;  String temp Write File Path = file Name +  Carbon Common Constants .  TEMPWRITEFILEEXTENSION ;  File Factory .  File Type file Type =  File Factory . get File Type ( file Name ) ; try {  Carbon File temp File = null ; if (  File Factory . is File Exist ( temp Write File Path , file Type ) ) { temp File =  File Factory . get Carbon File ( temp Write File Path , file Type ) ; temp File . delete ( ) ; }  File Factory . create New File ( temp Write File Path , file Type ) ; temp File =  File Factory . get Carbon File ( temp Write File Path , file Type ) ; byte [ ] buff = new byte [ buffer Size ] ; data Input Stream =  File Factory . get Data Input Stream ( file Name , file Type ) ; int read = data Input Stream . read ( buff , _ NUM , buff . length ) ; data Output Stream =  File Factory . get Data Output Stream ( temp Write File Path , file Type ) ; data Output Stream . write ( buff , _ NUM , read ) ; long remaining = valid Data End Offset - read ; while ( remaining > _ NUM ) { if ( remaining > buffer Size ) { buff = new byte [ buffer Size ] ; } else { buff = new byte [ ( int ) remaining ] ; } read = data Input Stream . read ( buff , _ NUM , buff . length ) ; data Output Stream . write ( buff , _ NUM , read ) ; remaining = remaining - read ; }  Carbon Util . close Streams ( data Input Stream , data Output Stream ) ; temp File . rename Force ( file Name ) ; file Truncated Successfully = _ BOOL ; } catch (  IOException e ) {  LOGGER . error ( _ STR + e . get Message ( ) ) ; } finally {  Carbon Util . close Streams ( data Output Stream , data Input Stream ) ; } return file Truncated Successfully ; }
public static void shutdown Active (  Exit Code exit Code ,  String msg ) { shutdown Active (  Shutdown Mode Amp .  GRACEFUL , exit Code , msg , null ) ; }
public void add ( final  Sensor sensor ) {  Set <  Sensor > old Selection = new  Hash Set <  Sensor > ( selection ) ; boolean rv = selection . add ( sensor ) ; if ( rv ) { fire Selection Changed ( old Selection , selection ) ; } }
@  Override public void visit Map Way (  Map Way way ) {  Default Entity View Info p Info = (  Default Entity View Info ) way . get View Info ( ) ;  List <  Map Node > nodes = get Way Nodes ( way ) ; if ( ! nodes . is Empty ( ) && p Info . way Color != null ) { if ( p Info . way Fill Color != null && nodes . get ( _ NUM ) == nodes . get ( nodes . size ( ) - _ NUM ) && ( way . is Area ( ) || ! p Info . fill Areas Only ) ) area Buffer . add ( way ) ; else way Buffer . add ( way ) ; } if ( p Info . is Way Icon && p Info . icon != null ) node Buffer . add ( way ) ; }
static  Element create Parent Element (  Path path ,  Element root Element ) throws  Parse Exception {  Preconditions . check Not Null ( path , _ STR ) ;  Preconditions . check Not Null ( root Element , _ STR ) ;  List <  Metadata Key < ? > > steps = path . get Steps ( ) ; if ( steps . is Empty ( ) ) { return null ; }  Element parent = root Element ; for ( int i = _ NUM ; i < steps . size ( ) - _ NUM ; i ++ ) {  Element Key < ? , ? > child Key = (  Element Key < ? , ? > ) steps . get ( i ) ; parent = get Or Create Child ( parent , child Key ) ; } return parent ; }
private static boolean is Out Of Memory (  Throwable t ) { boolean is Out Of Memory = _ BOOL ; while ( ! is Out Of Memory && t != null ) { if ( t instanceof  Out Of Memory Error ) { is Out Of Memory = _ BOOL ; } else if ( t instanceof  IOException ) { final  String msg = t . to String ( ) ; if ( msg != null ) { is Out Of Memory = msg . contains ( _ STR ) ; } } t = t . get Cause ( ) ; } return is Out Of Memory ; }
public int hash Code ( ) { throw new  Unsupported Operation Exception ( _ STR ) ; }
@  Suppress Warnings ( _ STR ) public  Create Index Request source (  Map <  String , ? > source ) { boolean found = _ BOOL ; for (  Map .  Entry <  String , ? > entry : source . entry Set ( ) ) {  String name = entry . get Key ( ) ; if ( name . equals ( _ STR ) ) { found = _ BOOL ; settings ( (  Map <  String ,  Object > ) entry . get Value ( ) ) ; } else if ( name . equals ( _ STR ) ) { found = _ BOOL ;  Map <  String ,  Object > mappings = (  Map <  String ,  Object > ) entry . get Value ( ) ; for (  Map .  Entry <  String ,  Object > entry1 : mappings . entry Set ( ) ) { mapping ( entry1 . get Key ( ) , (  Map <  String ,  Object > ) entry1 . get Value ( ) ) ; } } else if ( name . equals ( _ STR ) ) { found = _ BOOL ; aliases ( (  Map <  String ,  Object > ) entry . get Value ( ) ) ; } else {  Index Meta Data .  Custom proto =  Index Meta Data . lookup Prototype ( name ) ; if ( proto != null ) { found = _ BOOL ; try { customs . put ( name , proto . from Map ( (  Map <  String ,  Object > ) entry . get Value ( ) ) ) ; } catch (  IOException e ) { throw new  Elasticsearch Parse Exception ( _ STR , name ) ; } } } } if ( ! found ) { settings ( source ) ; } return this ; }
public static  String validate Credit Card Number (  String credit Card Number ) { if ( credit Card Number == null || credit Card Number . length ( ) == _ NUM ) return _ STR ;  String cc Number1 = check Numeric ( credit Card Number ) ; int cc Length = cc Number1 . length ( ) ;  String Buffer buf = new  String Buffer ( ) ; for ( int i = cc Length ; i != _ NUM ; i -- ) buf . append ( cc Number1 . char At ( i - _ NUM ) ) ;  String cc Number = buf . to String ( ) ; int sum = _ NUM ; for ( int i = _ NUM ; i < cc Length ; i ++ ) { int digit =  Character . get Numeric Value ( cc Number . char At ( i ) ) ; if ( i % _ NUM == _ NUM ) { digit *= _ NUM ; if ( digit > _ NUM ) digit -= _ NUM ; } sum += digit ; } if ( sum % _ NUM == _ NUM ) return _ STR ; s_log . fine ( _ STR + credit Card Number + _ STR + cc Number + _ STR + sum ) ; return _ STR ; }
public static void unpack (  File source Zip , final  File target Dir ) throws  IOException {  Zip File zip File = null ; try { zip File = new  Zip File ( source Zip ) ;  Enumeration < ? extends  Zip Entry > entries Enum = zip File . entries ( ) ; while ( entries Enum . has More Elements ( ) ) { unpack Entry ( zip File , entries Enum . next Element ( ) , target Dir ) ; } } finally { try { if ( zip File != null ) { zip File . close ( ) ; } } catch (  IOException e ) { } } }
public static  File resolve Absolute Path (  String root ,  String path ) {  File file = new  File ( normalize File Name ( path ) ) ; if ( ! file . is Absolute ( ) ) {  String root Path = normalize File Name ( root ) ; if ( ! root Path . ends With ( _ STR ) ) { root Path = root Path . concat ( _ STR ) ; } file = new  File ( root Path + path ) ; } return file ; }
public  Tokenizer (  Char Sequence text ) { this . text = text ; matcher =  WHITESPACE . matcher ( text ) ; skip Whitespace ( ) ; next Token ( ) ; }
private void send Request Teardown ( ) throws  IOException {  String request = _ STR + m Parameters . host + _ STR + m Parameters . port + m Parameters . path + _ STR + add Headers ( ) ;  Log . i (  TAG , request . substring ( _ NUM , request . index Of ( _ STR ) ) ) ; m Output Stream . write ( request . get Bytes ( _ STR ) ) ; }
public int [ ] check Sum Range ( ) { synchronized ( this . checksum Lock ) { if ( this . checksum Range != null && checksum Range . length > _ NUM ) { return  Arrays . copy Of ( this . checksum Range , this . checksum Range . length ) ; } return new int [ _ NUM ] ; } }
@  Override public boolean equals ( final  Object o ) { if ( this == o ) return _ BOOL ; if ( ! ( o instanceof  Header ) ) { return _ BOOL ; } return name . equals ( ( (  Header ) o ) . name ) ; }
public boolean wait For Wifi State ( int expected State , long timeout ) { long start Time =  System . current Time Millis ( ) ; while ( _ BOOL ) { if ( (  System . current Time Millis ( ) - start Time ) > timeout ) { if ( m Wifi State != expected State ) { return _ BOOL ; } else { return _ BOOL ; } }  Log . v (  LOG_ TAG , _ STR + expected State ) ; synchronized ( m Wifi Monitor ) { try { m Wifi Monitor . wait (  SHORT_ TIMEOUT ) ; } catch (  Interrupted Exception e ) { e . print Stack Trace ( ) ; } if ( m Wifi State != expected State ) {  Log . v (  LOG_ TAG , _ STR + m Wifi State ) ; continue ; } return _ BOOL ; } } }
private static boolean in King Section Like Hash (  String key ,  String value ) {  String hash Value = (  String ) king Section Like Hash . get ( key ) ; if ( hash Value != null ) { return ( hash Value . equals ( value ) ) ; } else { return _ BOOL ; } }
public void add Diagram Change Listener ( mx Diagram Change Listener listener ) { if ( diagram Change Listeners == null ) { diagram Change Listeners = new  Array List < mx Diagram Change Listener > ( ) ; } diagram Change Listeners . add ( listener ) ; }
public static void restore Default Setting (  String key ) {  Object object =  DEFAULT_ MAP . get ( key ) ; if ( object != null ) { if ( object instanceof  String ) {  SIMBRAIN_ PREFERENCES . put ( key , (  String ) object ) ; } else if ( object instanceof  Double ) {  SIMBRAIN_ PREFERENCES . put Double ( key , (  Double ) object ) ; } else if ( object instanceof  Integer ) {  SIMBRAIN_ PREFERENCES . put Int ( key , (  Integer ) object ) ; } else if ( object instanceof  Float ) {  SIMBRAIN_ PREFERENCES . put Float ( key , (  Float ) object ) ; } } }
private static  String capital First ( @  Nullable  String str ) { return str == null ? null : str . is Empty ( ) ? _ STR :  Character . to Upper Case ( str . char At ( _ NUM ) ) + str . substring ( _ NUM ) ; }
public static boolean assert Probability ( final double p ) { if ( p >= _ NUM && p <= _ NUM && !  Double . is Na N ( p ) ) { return _ BOOL ; } throw new  Exam .  Exam Exception (  Utils . real Format ( p ) ) ; }
void start Scrolling Instance ( ) { if ( log . is Loggable (  Platform Logger .  Level .  FINER ) ) { log . finer ( _ STR + this ) ; } scroll ( ) ; i_scroller . set Scrollbar ( this ) ; i_scroller . start ( ) ; }
public void start (  Stage stage ) throws  Exception { stage . set Scene ( new  Scene ( new  My Demo Pane ( ) ) ) ; stage . set Title ( _ STR ) ; stage . set Width ( _ NUM ) ; stage . set Height ( _ NUM ) ; stage . show ( ) ; }
public void accept Data Point ( double [ ] data Point ) { if ( m_output Frame != null && ( m_x Count % m_refresh Frequency == _ NUM ) ) { double [ ] dp = new double [ data Point . length + _ NUM ] ; dp [ dp . length - _ NUM ] = m_x Count ;  System . arraycopy ( data Point , _ NUM , dp , _ NUM , data Point . length ) ; for ( double element : data Point ) { if ( element < m_min ) { m_old Min = m_min ; m_min = element ; m_y Scale Update = _ BOOL ; } if ( element > m_max ) { m_old Max = m_max ; m_max = element ; m_y Scale Update = _ BOOL ; } } if ( m_y Scale Update ) { m_scale Panel . repaint ( ) ; m_y Scale Update = _ BOOL ; } synchronized ( m_data List ) { m_data List . add ( m_data List . size ( ) , dp ) ; m_data List . notify All ( ) ; } } }
public void add Attribute (  Attributed Character Iterator .  Attribute attribute ,  Object value , int start , int end ) { if ( attribute == null ) { throw new  Null Pointer Exception ( _ STR ) ; } if ( start < _ NUM || end > text . length ( ) || start >= end ) { throw new  Illegal Argument Exception ( ) ; } if ( value == null ) { return ; }  List <  Range > ranges = attribute Map . get ( attribute ) ; if ( ranges == null ) { ranges = new  Array List <  Range > ( _ NUM ) ; ranges . add ( new  Range ( start , end , value ) ) ; attribute Map . put ( attribute , ranges ) ; return ; }  List Iterator <  Range > it = ranges . list Iterator ( ) ; while ( it . has Next ( ) ) {  Range range = it . next ( ) ; if ( end <= range . start ) { it . previous ( ) ; break ; } else if ( start < range . end || ( start == range . end && value . equals ( range . value ) ) ) {  Range r1 = null , r3 ; it . remove ( ) ; r1 = new  Range ( range . start , start , range . value ) ; r3 = new  Range ( end , range . end , range . value ) ; while ( end > range . end && it . has Next ( ) ) { range = it . next ( ) ; if ( end <= range . end ) { if ( end > range . start || ( end == range . start && value . equals ( range . value ) ) ) { it . remove ( ) ; r3 = new  Range ( end , range . end , range . value ) ; break ; } } else { it . remove ( ) ; } } if ( value . equals ( r1 . value ) ) { if ( value . equals ( r3 . value ) ) { it . add ( new  Range ( r1 . start < start ? r1 . start : start , r3 . end > end ? r3 . end : end , r1 . value ) ) ; } else { it . add ( new  Range ( r1 . start < start ? r1 . start : start , end , r1 . value ) ) ; if ( r3 . start < r3 . end ) { it . add ( r3 ) ; } } } else { if ( value . equals ( r3 . value ) ) { if ( r1 . start < r1 . end ) { it . add ( r1 ) ; } it . add ( new  Range ( start , r3 . end > end ? r3 . end : end , r3 . value ) ) ; } else { if ( r1 . start < r1 . end ) { it . add ( r1 ) ; } it . add ( new  Range ( start , end , value ) ) ; if ( r3 . start < r3 . end ) { it . add ( r3 ) ; } } } return ; } } it . add ( new  Range ( start , end , value ) ) ; }
public static boolean is Solaris ( ) { return os Name . index Of ( _ STR ) > - _ NUM || os Name . index Of ( _ STR ) > - _ NUM ; }
public  DView Crl (  JFrame parent ,  String title ,  X509 CRL crl ) { super ( parent , title ,  Dialog .  Modality Type .  DOCUMENT_ MODAL ) ; this . crl = crl ; init Components ( ) ; }
public static  String remove Non Words ( final  String value ) { validate ( value ,  NULL_ STRING_ PREDICATE ,  NULL_ STRING_ MSG_ SUPPLIER ) ; return value . replace All ( _ STR , _ STR ) ; }
public synchronized void add Object (  Object obj ) { fifo . add Element ( obj ) ; nb Objects ++ ; notify All ( ) ; }
public void dispose ( ) { m Run Button . set Selected ( _ BOOL ) ; super . dispose ( ) ; }
public double distance_signed (  Pla Point Float p_point ) { double dx = point_b . v_x - point_a . v_x ; double dy = point_b . v_y - point_a . v_y ; double det = dy * ( p_point . v_x - point_a . v_x ) - dx * ( p_point . v_y - point_a . v_y ) ; double length =  Math . sqrt ( dx * dx + dy * dy ) ; return det / length ; }
public static void expand Real (  String number String ,  Word Relation word Relation ) { int string Length = number String . length ( ) ; int position ; if ( number String . char At ( _ NUM ) == _ STR ) { word Relation . add Word ( _ STR ) ; expand Real ( number String . substring ( _ NUM , string Length ) , word Relation ) ; } else if ( number String . char At ( _ NUM ) == _ STR ) { word Relation . add Word ( _ STR ) ; expand Real ( number String . substring ( _ NUM , string Length ) , word Relation ) ; } else if ( ( position = number String . index Of ( _ STR ) ) != - _ NUM || ( position = number String . index Of ( _ STR ) ) != - _ NUM ) { expand Real ( number String . substring ( _ NUM , position ) , word Relation ) ; word Relation . add Word ( _ STR ) ; expand Real ( number String . substring ( position + _ NUM ) , word Relation ) ; } else if ( ( position = number String . index Of ( _ STR ) ) != - _ NUM ) {  String before Dot = number String . substring ( _ NUM , position ) ; if ( before Dot . length ( ) > _ NUM ) { expand Real ( before Dot , word Relation ) ; } word Relation . add Word ( _ STR ) ;  String after Dot = number String . substring ( position + _ NUM ) ; if ( after Dot . length ( ) > _ NUM ) { expand Digits ( after Dot , word Relation ) ; } } else { expand Number ( number String , word Relation ) ; } }
public static double  P_ Recall Macro ( int  Y [ ] [ ] , int  Ypred [ ] [ ] ) { int  L =  Y [ _ NUM ] . length ; double m = _ NUM ; for ( int j = _ NUM ; j <  L ; j ++ ) { int [ ] y_j =  Matrix Utils . get Col (  Y , j ) ; int [ ] p_j =  Matrix Utils . get Col (  Ypred , j ) ; if ( all Missing ( y_j ) ) {  L -- ; continue ; } int [ ] [ ] aligned = align ( y_j , p_j ) ; int [ ] y_j Aligned = aligned [ _ NUM ] ; int [ ] p_j Aligned = aligned [ _ NUM ] ; double cur Recall =  P_ Recall ( y_j Aligned , p_j Aligned ) ; if (  Double . is Na N ( cur Recall ) ) { continue ; } m += cur Recall ; } return m /  L ; }
public void test Compute Location When Ejb Packaging ( ) throws  Exception {  Deployable deployable Element = new  Deployable ( ) ; deployable Element . set Group Id ( _ STR ) ; deployable Element . set Artifact Id ( _ STR ) ; deployable Element . set Type ( _ STR ) ;  String location = deployable Element . compute Location ( create Default Project ( _ STR , null ) ) ; assert True ( location . ends With ( _ STR ) ) ; }
private static <  T > void execute Script ( final  File file , final  T plugin Interface ) { final  List <  Pair <  String ,  Object > > bindings = new  Array List < > ( ) ; final  Console Writer console Writer = new  Console Writer ( new  String Writer ( ) ) ; bindings . add ( new  Pair <  String ,  Object > ( _ STR , plugin Interface ) ) ; bindings . add ( new  Pair <  String ,  Object > ( _ STR , console Writer ) ) ; try {  Script Runner . run Script ( file , bindings ) ; if ( console Writer . get Output ( ) != null ) {  Navi Logger . info ( console Writer . get Output ( ) ) ; } } catch ( final  Exception exception ) { final  String message = _ STR + _ STR ; final  String description =  CUtility Functions . create Description (  String . format ( _ STR + _ STR + _ STR , file . get Absolute File ( ) ) , new  String [ ] { _ STR } , new  String [ ] { _ STR + _ STR } ) ;  Navi Logger . severe ( message ) ;  CUtility Functions . log Exception ( exception ) ;  Navi Logger . severe ( console Writer . get Output ( ) ) ;  Navi Error Dialog . show ( null , message , description , exception ) ; } }
public static  Delete Sub Command Handler create (  Sub Command Argument Parser parser ,  Managed Object Path < ? , ? > p ,  Optional Relation Definition < ? , ? > r ) throws  Argument Exception { return new  Delete Sub Command Handler ( parser , p , r , p . child ( r ) ) ; }
public static int [ ] topo Sort States (  Automaton a ) { if ( a . get Num States ( ) == _ NUM ) { return new int [ _ NUM ] ; } int num States = a . get Num States ( ) ; int [ ] states = new int [ num States ] ; final  Bit Set visited = new  Bit Set ( num States ) ; int upto = topo Sort States Recurse ( a , visited , states , _ NUM , _ NUM ) ; if ( upto < states . length ) { int [ ] new States = new int [ upto ] ;  System . arraycopy ( states , _ NUM , new States , _ NUM , upto ) ; states = new States ; } for ( int i = _ NUM ; i < states . length / _ NUM ; i ++ ) { int s = states [ i ] ; states [ i ] = states [ states . length - _ NUM - i ] ; states [ states . length - _ NUM - i ] = s ; } return states ; }
public  String to String (  Double Matrix3 D matrix ) {  String Buffer buf = new  String Buffer ( ) ; boolean old Print Shape = this . print Shape ; this . print Shape = _ BOOL ; for ( int slice = _ NUM ; slice < matrix . slices ( ) ; slice ++ ) { if ( slice != _ NUM ) buf . append ( slice Separator ) ; buf . append ( to String ( matrix . view Slice ( slice ) ) ) ; } this . print Shape = old Print Shape ; if ( print Shape ) buf . insert ( _ NUM , shape ( matrix ) + _ STR ) ; return buf . to String ( ) ; }
@  Override public synchronized void start Manager ( ) { try { if ( logger . is Debug Enabled ( ) ) { logger . debug ( _ STR ) ; }  Runtime rt =  Runtime . get Runtime ( ) ; this . pooled Membership Executor =  Executors . new Fixed Thread Pool ( rt . available Processors ( ) ) ; running = _ BOOL ; start Managing Activity ( ) ; messenger . broadcast Manager Info ( ) ; } catch (  Interrupted Exception e ) { running = _ BOOL ; throw new  Management Exception ( e ) ; } catch (  Exception e ) { running = _ BOOL ; throw new  Management Exception ( e ) ; } }
default  Map <  String ,  String > snapshot ( ) { final  Map <  String ,  String > map = new  Linked Hash Map < > ( ) ; for Each ( null ) ; return  Collections . unmodifiable Map ( map ) ; }
protected  Class < ? > resolve Proxy Class (  String [ ] interfaces ) throws  IOException ,  Class Not Found Exception {  Stream Checker checker = stream Checker ; if ( checker != null ) { checker . check Proxy Interface Names ( interfaces ) ; }  Object annotation = read Location ( ) ;  Class Loader default Loader = skip Default Resolve Class ? null : latest User Defined Loader ( ) ;  String codebase = null ; if ( ! use Codebase Only && annotation instanceof  String ) { codebase = (  String ) annotation ; } return  RMIClass Loader . load Proxy Class ( codebase , interfaces , default Loader ) ; }
public  Point2 D translate To True Arena Coords (  Point2 D point ) { final double dpi Scale Factor =  Shoot OFFController . get Dpi Scale Factor For Screen ( ) ; final  Point2 D origin = arena Pane . get Arena Screen Origin ( ) ; return new  Point2 D ( origin . get X ( ) + ( point . get X ( ) * dpi Scale Factor ) , origin . get Y ( ) + ( point . get Y ( ) * dpi Scale Factor ) ) ; }
public void append ( byte [ ] buffer , int offset , int length ) { if ( _length + length >= _capacity ) ensure Capacity ( _length + length ) ;  System . arraycopy ( buffer , offset , _buffer , _length , length ) ; _length += length ; }
public boolean by Pass Control To Processor ( boolean flag ) { return _ BOOL ; }
public static void rename Cube For Deletion ( int partition Count ,  String store Path ,  String schema Name ,  String cube Name ) {  String cube Name With Partition = _ STR ;  String schema Name With Partition = _ STR ;  String full Path = _ STR ;  String new File Path = _ STR ;  String new File Name = _ STR ;  Callable <  Void > c = null ; long time =  System . current Time Millis ( ) ;  File Factory .  File Type file Type = null ;  Executor Service executor Service =  Executors . new Fixed Thread Pool ( _ NUM ) ; for ( int i = _ NUM ; i < partition Count ; i ++ ) { schema Name With Partition = schema Name + _ STR + i ; cube Name With Partition = cube Name + _ STR + i ; new File Name = cube Name With Partition + _ STR + time ; full Path = store Path +  File . separator + schema Name With Partition +  File . separator + cube Name With Partition ; new File Path = store Path +  File . separator + schema Name With Partition +  File . separator + new File Name ; file Type =  File Factory . get File Type ( full Path ) ; try { if (  File Factory . is File Exist ( full Path , file Type ) ) {  Carbon File file =  File Factory . get Carbon File ( full Path , file Type ) ; boolean is Rename Successfull = file . rename To ( new File Path ) ; if ( ! is Rename Successfull ) {  LOGGER . error ( _ STR + full Path ) ; c = new  Delete Cube ( file ) ; executor Service . submit ( c ) ; } else { c = new  Delete Cube (  File Factory . get Carbon File ( new File Path , file Type ) ) ; executor Service . submit ( c ) ; } } } catch (  IOException e ) {  LOGGER . error ( _ STR + full Path ) ; } } executor Service . shutdown ( ) ; }
protected void do Validate Int Contents (  String path ,  String filename , int start , int end ) {  File in File = new  File ( path , filename ) ;  Data Input Stream in Stream = null ;  Log . i (  LOG_ TAG , _ STR + filename + _ STR + path ) ; try { in Stream = new  Data Input Stream ( new  File Input Stream ( in File ) ) ; for ( int i = start ; i < end ; ++ i ) { if ( in Stream . read Int ( ) != i ) { fail ( _ STR ) ; } } if ( in Stream != null ) { in Stream . close ( ) ; }  Log . i (  LOG_ TAG , _ STR + filename ) ; } catch (  File Not Found Exception e ) { fail ( _ STR + in File + _ STR + e . to String ( ) ) ; } catch (  IOException e ) { fail ( _ STR + in File + _ STR + e . to String ( ) ) ; } }
public static  NBT_ Tag make (  Input Stream is ) throws  Exception {  NBT_ Tag ret = null ;  Data Input Stream stream = new  Data Input Stream ( is ) ; byte t = stream . read Byte ( ) ; int type = ( int ) t ;  String name = _ STR ; if ( type > _ NUM ) name = stream . read UTF ( ) ; switch ( type ) { case _ NUM : ret = new  TAG_ End ( name ) ; break ; case _ NUM : ret = new  TAG_ Byte ( name ) ; break ; case _ NUM : ret = new  TAG_ Short ( name ) ; break ; case _ NUM : ret = new  TAG_ Int ( name ) ; break ; case _ NUM : ret = new  TAG_ Long ( name ) ; break ; case _ NUM : ret = new  TAG_ Float ( name ) ; break ; case _ NUM : ret = new  TAG_ Double ( name ) ; break ; case _ NUM : ret = new  TAG_ Byte_ Array ( name ) ; break ; case _ NUM : ret = new  TAG_ String ( name ) ; break ; case _ NUM : ret = new  TAG_ List ( name ) ; break ; case _ NUM : ret = new  TAG_ Compound ( name ) ; break ; case _ NUM : ret = new  TAG_ Int_ Array ( name ) ; break ; default : throw ( new  Exception ( _ STR + type ) ) ; } ret . parse ( stream ) ; return ret ; }
public  Format Result apply Mask (  String mask ,  String value ,  String old Value ,  Integer cursor Index ) { if ( mask == null || value == null ) { return null ; } if ( old Value . length ( ) > value . length ( ) ) { return new  Format Result ( value , null ) ; } value = (  String ) get Mask Or Get Cursor Index ( mask , value , cursor Index , _ BOOL ) ; cursor Index = (  Integer ) get Mask Or Get Cursor Index ( mask , value , cursor Index , _ BOOL ) ; return new  Format Result ( value , cursor Index ) ; }
public  Effect Layer ( int duration ) { this . duration = duration ; timestamp =  System . current Time Millis ( ) ; }
protected boolean read Data Record ( int lon_index ) { try { if ( bin File == null ) { if ( ! reopen ( ) ) { return _ BOOL ; } } bin File . seek (  UHL_ SIZE +  DSI_ SIZE +  ACC_ SIZE + ( lon_index * ( _ NUM + ( _ NUM * uhl . num_lat_points ) ) ) ) ; bin File . read ( ) ; bin File . skip Bytes ( _ NUM ) ; bin File . read Short ( ) ; bin File . read Short ( ) ; elevations [ lon_index ] = new short [ uhl . num_lat_points ] ; for ( int j = _ NUM ; j < uhl . num_lat_points ; j ++ ) { elevations [ lon_index ] [ j ] = bin File . read Short Data ( ) ; } } catch (  IOException e3 ) {  Debug . error ( _ STR ) ; e3 . print Stack Trace ( ) ; elevations [ lon_index ] = null ; return _ BOOL ; } catch (  Format Exception f ) {  Debug . error ( _ STR ) ; elevations [ lon_index ] = null ; return _ BOOL ; } return _ BOOL ; }
protected  Image standard Image Bytes To Image ( byte [ ] bytes ,  String mime Type ) throws  IOException {  Iterator reader Iterator =  Image IO . get Image Readers By MIMEType ( mime Type ) ; if ( ! reader Iterator . has Next ( ) ) { throw new  IOException ( _ STR + _ STR + mime Type ) ; }  IOException ioe = null ; while ( reader Iterator . has Next ( ) ) {  Image Reader image Reader = (  Image Reader ) reader Iterator . next ( ) ; try (  Byte Array Input Stream bais = new  Byte Array Input Stream ( bytes ) ) {  Image Input Stream image Input Stream =  Image IO . create Image Input Stream ( bais ) ; try {  Image Read Param param = image Reader . get Default Read Param ( ) ; image Reader . set Input ( image Input Stream , _ BOOL , _ BOOL ) ;  Buffered Image buffered Image = image Reader . read ( image Reader . get Min Index ( ) , param ) ; if ( buffered Image != null ) { return buffered Image ; } } finally { image Input Stream . close ( ) ; image Reader . dispose ( ) ; } } catch (  IOException e ) { ioe = e ; continue ; } } if ( ioe == null ) { ioe = new  IOException ( _ STR + _ STR + mime Type ) ; } throw ioe ; }
private static float alignment Probability (  Rectangle [ ] widget ) { float [ ] start = new float [ widget . length ] ; float [ ] center = new float [ widget . length ] ; float [ ] end = new float [ widget . length ] ; float width Sum = _ NUM ; int count = _ NUM ; for ( int i = _ NUM ; i < end . length ; i ++ ) { if ( widget [ i ] == null ) { start [ i ] =  Float .  Na N ; end [ i ] =  Float .  Na N ; center [ i ] =  Float .  Na N ; continue ; } start [ i ] = widget [ i ] . x ; end [ i ] = start [ i ] + widget [ i ] . width ; center [ i ] = ( start [ i ] + end [ i ] ) / _ NUM ; width Sum += widget [ i ] . width ; count ++ ; } float start Div = standard Deviation ( start ) ; float center Div = standard Deviation ( center ) ; float end Div = standard Deviation ( end ) ; if ( count > _ NUM ) { return _ NUM -  Math . min ( start Div ,  Math . min ( center Div , end Div ) ) / ( width Sum / count ) ; } return _ NUM ; }
