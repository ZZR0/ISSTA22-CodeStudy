protected boolean [ ] dataset Integrity ( boolean nominal Predictor , boolean numeric Predictor , boolean string Predictor , boolean date Predictor , boolean relational Predictor , boolean multi Instance , int class Type , boolean predictor Missing , boolean class Missing ) { print ( _ STR ) ; print Attribute Summary ( nominal Predictor , numeric Predictor , string Predictor , date Predictor , relational Predictor , multi Instance , class Type ) ; print ( _ STR ) ; int num Train = get Num Instances ( ) , num Classes = _ NUM , missing Level = _ NUM ; boolean [ ] result = new boolean [ _ NUM ] ;  Instances train = null ;  Kernel kernel = null ; try { train = make Test Dataset ( _ NUM , num Train , nominal Predictor ? get Num Nominal ( ) : _ NUM , numeric Predictor ? get Num Numeric ( ) : _ NUM , string Predictor ? get Num String ( ) : _ NUM , date Predictor ? get Num Date ( ) : _ NUM , relational Predictor ? get Num Relational ( ) : _ NUM , num Classes , class Type , multi Instance ) ; if ( missing Level > _ NUM ) { add Missing ( train , missing Level , predictor Missing , class Missing ) ; } kernel =  Kernel . make Copies ( get Kernel ( ) , _ NUM ) [ _ NUM ] ; } catch (  Exception ex ) { throw new  Error ( _ STR + ex . get Message ( ) ) ; } try {  Instances train Copy = new  Instances ( train ) ; kernel . build Kernel ( train Copy ) ; compare Datasets ( train , train Copy ) ; println ( _ STR ) ; result [ _ NUM ] = _ BOOL ; } catch (  Exception ex ) { println ( _ STR ) ; result [ _ NUM ] = _ BOOL ; if ( m_ Debug ) { println ( _ STR ) ; print ( _ STR ) ; println ( _ STR + ex . get Message ( ) + _ STR ) ; println ( _ STR ) ; println ( _ STR + train . to String ( ) + _ STR ) ; } } return result ; }
public static int union Size ( long [ ] x , long [ ] y ) { final int lx = x . length , ly = y . length ; final int min = ( lx < ly ) ? lx : ly ; int i = _ NUM , res = _ NUM ; for ( ; i < min ; i ++ ) { res +=  Long . bit Count ( x [ i ] | y [ i ] ) ; } for ( ; i < lx ; i ++ ) { res +=  Long . bit Count ( x [ i ] ) ; } for ( ; i < ly ; i ++ ) { res +=  Long . bit Count ( y [ i ] ) ; } return res ; }
public void test Reverse Order4 ( ) throws  Exception {  UUID id =  UUID . random UUID ( ) ;  Grid Cache Adapter <  String ,  String > cache = grid . internal Cache ( ) ;  Grid Cache Context <  String ,  String > ctx = cache . context ( ) ;  Grid Cache Test Entry Ex entry1 = new  Grid Cache Test Entry Ex ( ctx , _ STR ) ;  Grid Cache Test Entry Ex entry2 = new  Grid Cache Test Entry Ex ( ctx , _ STR ) ;  Grid Cache Version ver1 = version ( _ NUM ) ;  Grid Cache Version ver2 = version ( _ NUM ) ;  Grid Cache Version ver3 = version ( _ NUM ) ;  Grid Cache Mvcc Candidate v3k1 = entry1 . add Local ( _ NUM , ver3 , _ NUM , _ BOOL , _ BOOL ) ;  Grid Cache Mvcc Candidate v3k2 = entry2 . add Local ( _ NUM , ver3 , _ NUM , _ BOOL , _ BOOL ) ; link Candidates ( ctx , v3k1 , v3k2 ) ; entry1 . ready Local ( ver3 ) ; check Local ( v3k1 , ver3 , _ BOOL , _ BOOL , _ BOOL ) ; check Local ( v3k2 , ver3 , _ BOOL , _ BOOL , _ BOOL ) ;  Grid Cache Mvcc Candidate v1k1 = entry1 . add Local ( _ NUM , ver1 , _ NUM , _ BOOL , _ BOOL ) ;  Grid Cache Mvcc Candidate v1k2 = entry2 . add Local ( _ NUM , ver1 , _ NUM , _ BOOL , _ BOOL ) ; link Candidates ( ctx , v1k1 , v1k2 ) ; entry1 . ready Local ( ver1 ) ; entry2 . ready Local ( ver1 ) ; check Local ( v3k1 , ver3 , _ BOOL , _ BOOL , _ BOOL ) ; check Local ( v3k2 , ver3 , _ BOOL , _ BOOL , _ BOOL ) ; check Local ( v1k1 , ver1 , _ BOOL , _ BOOL , _ BOOL ) ; check Local ( v1k2 , ver1 , _ BOOL , _ BOOL , _ BOOL ) ;  Grid Cache Mvcc Candidate v2k2 = entry2 . add Remote ( id , _ NUM , ver2 , _ NUM , _ BOOL , _ BOOL ) ; check Remote ( v2k2 , ver2 , _ BOOL , _ BOOL ) ; entry2 . ready Local ( v3k2 ) ; check Local ( v3k1 , ver3 , _ BOOL , _ BOOL , _ BOOL ) ; check Local ( v3k2 , ver3 , _ BOOL , _ BOOL , _ BOOL ) ; }
@  Override public void closing OK ( ) {  List <  Add User Fields .  Attribute Spec > specs = new  Array List <  Add User Fields .  Attribute Spec > ( ) ; for ( int i = _ NUM ; i < m_list Model . size ( ) ; i ++ ) {  Add User Fields .  Attribute Spec a = (  Add User Fields .  Attribute Spec ) m_list Model . element At ( i ) ; specs . add ( a ) ; } if ( m_modify L != null ) { m_modify L . set Modified Status (  Add User Fields Customizer . this , _ BOOL ) ; } m_filter . set Attribute Specs ( specs ) ; }
public  String to String ( ) {  String Buffer text = new  String Buffer ( ) ; if ( ( m_class Attribute == null ) ) { return _ STR ; } try { text . append ( _ STR ) ; text . append ( _ STR + m_kernel . to String ( ) + _ STR ) ; for ( int i = _ NUM ; i < m_class Attribute . num Values ( ) ; i ++ ) { for ( int j = i + _ NUM ; j < m_class Attribute . num Values ( ) ; j ++ ) { text . append ( _ STR + m_class Attribute . value ( i ) + _ STR + m_class Attribute . value ( j ) + _ STR ) ; text . append ( m_classifiers [ i ] [ j ] ) ; if ( m_fit Logistic Models ) { text . append ( _ STR ) ; if ( m_classifiers [ i ] [ j ] . m_logistic == null ) { text . append ( _ STR ) ; } else { text . append ( m_classifiers [ i ] [ j ] . m_logistic ) ; } } text . append ( _ STR ) ; } } } catch (  Exception e ) { return _ STR ; } return text . to String ( ) ; }
private static boolean is Double Equal ( double value , double value To Compare ) { return (  Math . abs ( value - value To Compare ) < _ NUM ) ; }
@  Override public void dataset Changed (  Dataset Change Event event ) { super . dataset Changed ( event ) ; if ( this . subplots == null ) { return ; }  XYDataset dataset = null ; if ( event . get Dataset ( ) instanceof  XYDataset ) { dataset = (  XYDataset ) event . get Dataset ( ) ; } for (  XYPlot subplot : this . subplots ) { if ( subplot . index Of ( dataset ) >= _ NUM ) { subplot . configure Range Axes ( ) ; } } }
public boolean on Schedule As Library (  Config config ,  Config runtime ,  IScheduler scheduler ,  Packing Plan packing ) { boolean ret = _ BOOL ; try { scheduler . initialize ( config , runtime ) ; ret = scheduler . on Schedule ( packing ) ; if ( ret ) { ret =  Scheduler Utils . set Lib Scheduler Location ( runtime , scheduler , _ BOOL ) ; } else {  LOG . severe ( _ STR ) ; } } finally { scheduler . close ( ) ; } return ret ; }
public static boolean is String Type (  Type t ) { return t . equals (  Ref Type . v ( _ STR ) ) ; }
public  Entry update Or Create Source (  User user ,  String id ,  String url ,  String title ,  Long mod Time ,  Long create Time , boolean is Admin ,  Errors errors ) { if ( user == null ) {  Errors . add ( errors , error Messages . error User Is Null ( ) ) ; return null ; } if ( url == null ) {  Errors . add ( errors , error Messages . error Url Is Null ( ) ) ; return null ; }  Entry source = get Entry By User Id And Url ( user . get Id ( ) , url ) ; if ( source == null ) { if ( url . is Empty ( ) ) {  Errors . add ( errors , error Messages . error Url Is Empty ( ) ) ; return null ; } if ( title == null ) {  Errors . add ( errors , error Messages . error Title Is Null ( ) ) ; return null ; } if ( title . is Empty ( ) ) {  Errors . add ( errors , error Messages . error Title Is Empty ( ) ) ; return null ; } if ( mod Time == null ) {  Errors . add ( errors , error Messages . error Mod Time Is Null ( ) ) ; return null ; } if ( create Time == null ) {  Errors . add ( errors , error Messages . error Create Time Is Null ( ) ) ; return null ; } if ( id != null && ! id Generator . is Id Well Formed ( id ) ) {  Errors . add ( errors , error Messages . error Id Is Invalid ( ) ) ; return null ; } if ( create Time . long Value ( ) > mod Time . long Value ( ) ) { mod Time = create Time ; } if ( url != null ) { url = clean Up Text ( url ) ; } if ( title != null ) { title = clean Up Text ( title ) ; } source = new  Entry ( ) ; source . set Db ( db ) ; if ( id == null ) { id = id Generator . get Another Id ( ) ; } source . set Id ( id ) ; source . set Source Url ( url ) ; source . set Source Title ( title ) ; source . set Create Time ( create Time ) ; source . set Type (  Constants . source ) ; source . set User Id ( user . get Id ( ) ) ; db . persist Entry ( source ) ; } else if ( ! can User Modify Entry ( user , source , is Admin ) ) {  Errors . add ( errors , error Messages . error User Is Not Entitled To Modify The Source ( ) ) ; return null ; } source . set Mod Time ( mod Time ) ; return source ; }
private void validate Sql Statement (  String sql , int jdbc Statement Index ) {  Assert . is True (  String Utils . is Not Blank ( sql ) , _ STR + jdbc Statement Index + _ STR ) ; }
public static  Long [ ] values Of ( long [ ] array ) {  Long [ ] dest = new  Long [ array . length ] ; for ( int i = _ NUM ; i < array . length ; i ++ ) { dest [ i ] =  Long . value Of ( array [ i ] ) ; } return dest ; }
@  Override public boolean is Trace Enabled ( ) { return logger . is Loggable (  Level .  FINEST ) ; }
private static void use Missile (  Player player ) {  Stackable Item projectiles Item = null ; if ( player . get Range Weapon ( ) != null ) { projectiles Item = player . get Ammunition ( ) ; } if ( projectiles Item == null ) { projectiles Item = player . get Missile If Not Holding Other Weapon ( ) ; } if ( projectiles Item != null ) { projectiles Item . remove One ( ) ; } }
public  Tcp Matcher ( final  Network Config config ) { super ( config ) ; }
private int determine Max Level Rec ( int level ,  Node v ) { int new Level = level ; for (  Edge e = v . get First Out Edge ( ) ; e != null ; e = v . get Next Out Edge ( e ) ) { new Level =  Math . max ( new Level , determine Max Level Rec ( level , e . get Target ( ) ) + _ NUM ) ; } return new Level ; }
private synchronized void put Map Entry (  String local Id ,  Map Entry entry ) { if ( ! is Local Id ( local Id ) ) { throw new  Illegal State Exception ( _ STR + local Id + _ STR ) ; }  JSONObject json = new  JSONObject ( ) ; try { json . put ( _ STR , entry . retain Count ) ; if ( entry . object Id != null ) { json . put ( _ STR , entry . object Id ) ; } } catch (  JSONException je ) { throw new  Illegal State Exception ( _ STR , je ) ; }  File file = new  File ( disk Path , local Id ) ; if ( ! disk Path . exists ( ) ) { disk Path . mkdirs ( ) ; } try {  Parse File Utils . write JSONObject To File ( file , json ) ; } catch (  IOException e ) { } }
public static void f (  String msg ,  Object ... args ) { if ( ! allow Wtf ) return ;  Stack Trace Element caller = get Caller Stack Trace Element ( ) ;  String tag = generate Tag ( caller ) ; if ( s Level >  LEVEL_ FATAL ) { return ; } if ( args . length > _ NUM ) { msg =  String . format ( msg , args ) ; }  Log . wtf ( tag , msg ) ; }
public void delete Leaves (  String name ) { for ( int i = _ NUM ; i < _leaves . size ( ) ; i ++ ) {  Catalog Tree Leaf leaf = _leaves . get ( i ) ; if ( name . equals ( leaf . get Name ( ) ) ) { _leaves . remove ( i ) ; } } }
public  String to String ( ) { final  String Buffer s = new  String Buffer ( ) ; final int size = size ( ) ; for ( int i = _ NUM ; i < size ; i ++ ) s . append ( get Int ( i ) ) ; return s . to String ( ) ; }
protected boolean validate ( final char [ ] component , final int soffset , int eoffset , final  Bit Set generous ) { if ( eoffset == - _ NUM ) { eoffset = component . length - _ NUM ; } for ( int i = soffset ; i <= eoffset ; i ++ ) { if ( ! generous . get ( component [ i ] ) ) { return _ BOOL ; } } return _ BOOL ; }
public boolean remove Shutdown Hook (  Thread hook ) {  Security Manager sm =  System . get Security Manager ( ) ; if ( sm != null ) { sm . check Permission (  Runtime Permission Collection .  SHUTDOWN_ HOOKS_ PERMISSION ) ; } if ( hook == null ) throw new  Null Pointer Exception ( _ STR ) ; if (  VMState > _ NUM ) { throw new  Illegal State Exception ( ) ; } synchronized ( hooks List ) { return hooks List . remove ( hook ) ; } }
public void run ( ) { while ( m_keyboard Stream != null ) { try { if ( m_keyboard Read Request ) {  String s = m_keyboard Stream . read Line ( ) ; m_keyboard Input . add ( s ) ; m_keyboard Read Request = _ BOOL ; synchronized ( this ) { notify All ( ) ; } } else try {  Thread . sleep ( _ NUM ) ; } catch (  Interrupted Exception ie ) { } } catch (  IOException io ) { } } }
public boolean bound Scroll ( ) { float cur Scroll = get Stack Scroll ( ) ; float new Scroll = get Bounded Stack Scroll ( cur Scroll ) ; if (  Float . compare ( new Scroll , cur Scroll ) != _ NUM ) { set Stack Scroll ( new Scroll ) ; return _ BOOL ; } return _ BOOL ; }
@  Override public  Aggregateable Evaluation aggregate (  Evaluation evaluation ) { m_ Incorrect += evaluation . incorrect ( ) ; m_ Correct += evaluation . correct ( ) ; m_ Unclassified += evaluation . unclassified ( ) ; m_ Missing Class += evaluation . m_ Missing Class ; m_ With Class += evaluation . m_ With Class ; if ( evaluation . m_ Confusion Matrix != null ) { double [ ] [ ] new Matrix = evaluation . confusion Matrix ( ) ; if ( new Matrix != null ) { for ( int i = _ NUM ; i < m_ Confusion Matrix . length ; i ++ ) { for ( int j = _ NUM ; j < m_ Confusion Matrix [ i ] . length ; j ++ ) { m_ Confusion Matrix [ i ] [ j ] += new Matrix [ i ] [ j ] ; } } } } double [ ] new Class Priors = evaluation . m_ Class Priors ; if ( new Class Priors != null && m_ Class Priors != null ) { for ( int i = _ NUM ; i < this . m_ Class Priors . length ; i ++ ) { m_ Class Priors [ i ] = new Class Priors [ i ] ; } } m_ Class Priors Sum = evaluation . m_ Class Priors Sum ; m_ Total Cost += evaluation . total Cost ( ) ; m_ Sum Err += evaluation . m_ Sum Err ; m_ Sum Abs Err += evaluation . m_ Sum Abs Err ; m_ Sum Sqr Err += evaluation . m_ Sum Sqr Err ; m_ Sum Class += evaluation . m_ Sum Class ; m_ Sum Sqr Class += evaluation . m_ Sum Sqr Class ; m_ Sum Predicted += evaluation . m_ Sum Predicted ; m_ Sum Sqr Predicted += evaluation . m_ Sum Sqr Predicted ; m_ Sum Class Predicted += evaluation . m_ Sum Class Predicted ; m_ Sum Prior Abs Err += evaluation . m_ Sum Prior Abs Err ; m_ Sum Prior Sqr Err += evaluation . m_ Sum Prior Sqr Err ; m_ Sum KBInfo += evaluation . m_ Sum KBInfo ; double [ ] new Margin Counts = evaluation . m_ Margin Counts ; if ( new Margin Counts != null ) { for ( int i = _ NUM ; i < m_ Margin Counts . length ; i ++ ) { m_ Margin Counts [ i ] += new Margin Counts [ i ] ; } } m_ Complexity Statistics Available = evaluation . m_ Complexity Statistics Available ; m_ Coverage Statistics Available = evaluation . m_ Coverage Statistics Available ; m_ Sum Prior Entropy += evaluation . m_ Sum Prior Entropy ; m_ Sum Scheme Entropy += evaluation . m_ Sum Scheme Entropy ; m_ Total Size Of Regions += evaluation . m_ Total Size Of Regions ; m_ Total Coverage += evaluation . m_ Total Coverage ;  Array List <  Prediction > preds To Add = evaluation . m_ Predictions ; if ( preds To Add != null ) { if ( m_ Predictions == null ) { m_ Predictions = new  Array List <  Prediction > ( ) ; } for ( int i = _ NUM ; i < preds To Add . size ( ) ; i ++ ) { m_ Predictions . add ( preds To Add . get ( i ) ) ; } } return this ; }
public void wait For Volumes To Be Visible (  CGRequest Params request ) { scan ( request . get Copies ( ) , request . get Rsets ( ) ) ; }
protected void start Additional Services ( final  Cache cache , final  Map <  String ,  Object > options ) throws  Exception { }
public void update View ( ) { if ( f Input Element != null && f Parent Composite != null ) {  Indicator View State old State = f State Map . get ( f Input Element ) ; boolean reload = f Files To Reoad . contains ( f Input Element ) ; if ( reload || old State == null ) {  Json Object json Object =  Droidsafe Plugin Utilities . parse Indicator File ( f Input Element ) ; if ( json Object == null ) return ; f Files To Reoad . remove ( f Input Element ) ; f State = new  Indicator View State ( f Input Element , json Object , get Security Spec ( ) , old State ) ; f State Map . put ( f Input Element , f State ) ; } else { f State = old State ; } set Part Name ( f State . indicator Type ) ; show Page (  PAGE_ VIEWER ) ; f Tree Viewer . set Input ( f State . json Object ) ; if ( f Tree Viewer . get Sorter ( ) == null ) sort By Field ( get Sort By Field ( ) ) ; } else { set Part Name (  DEFAULT_ PART_ NAME ) ; } }
@  Override public void paint (  Graphics g ) { g . draw Image ( image , _ NUM , _ NUM , this ) ; if ( ! paint Called ) { paint Called = _ BOOL ; synchronized ( this ) { notify All ( ) ; } } }
@  Override public boolean connection Allowed (  String event Name ) { if ( m_listenees . contains Key ( event Name ) ) { return _ BOOL ; } return _ BOOL ; }
public boolean is Prefixed ( ) { return name . index Of ( _ STR ) >= _ NUM ; }
public void release Any Connection (  Connection connection ) throws  SQLException { try { connection . close ( ) ; } catch (  Exception ex ) { throw new  Runtime Exception ( ex ) ; } }
public  Quick Action View add Actions (  Collection <  Action > actions ) { check Shown ( ) ; m Actions . add All ( actions ) ; return this ; }
protected <  T extends  Abstract Option Value < ? , ? > >  Abstract Options (  Function <  T ,  T > value Filter ,  Abstract Options base Options ,  Iterable <  T > values ) { require Non Null ( base Options , _ STR ) ; require Non Null ( value Filter , _ STR ) ; require Non Null ( values , _ STR ) ; value Map = new  Identity Hash Map < > ( base Options . value Map ) ; put All ( value Filter ,  Stream Support . stream ( values . spliterator ( ) , _ BOOL ) ) ; }
public  Char Seq concat (  Char Seq another ) { return new  Char Seq ( str + another . str ) ; }
@  Override protected void do Get (  Http Servlet Request req ,  Http Servlet Response resp ) throws  Servlet Exception ,  IOException { resp . set Content Type ( _ STR ) ;  Print Writer send To Client = resp . get Writer ( ) ; for (  Video v : this . videos ) { send To Client . write ( v . get Name ( ) + _ STR + v . get Url ( ) + _ STR ) ; } }
protected void notify State Change ( int old State , int new State ) { m State = new State ; if ( old State != new State ) { fire Property Change ( _ STR ,  Integer . value Of ( old State ) ,  Integer . value Of ( new State ) ) ; } }
private void format And Log Throwable (  Logging Level level ,  Color color ,  String msg ,  Throwable t ) { if ( !  USE_ COLORS ) { format And Log Throwable ( level , msg , t ) ; return ; } if (  Photon Logger . level . id < level . id ) { return ; }  Local Date Time date Time =  Local Date Time . now ( ) ;  String formatted = format Log Line ( level , date Time , msg ) ;  Logging Service . log Throwable ( date Time , t , formatted , color ) ; }
public static  String construct Queue Redis Key (  String queue Name ,  String shard Name , int priority ,  Pin Later Job State state ) { return  String . format ( _ STR ,  PINLATER_ QUEUE_ KEY_ PREFIX , shard Name , queue Name , priority , state . get Value ( ) ) ; }
public static  String decode Charset (  String s ,  String charset ) { if ( s == null ) { return null ; } try { byte buf [ ] = s . get Bytes (  ASCII_ CHARSET ) ; return ( new  String ( buf , _ NUM , buf . length , charset ) ) ; } catch (  Unsupported Encoding Exception uee ) { return s ; } }
public void add Restricted Domain (  String domain Name ) { if (  String Utils . is Empty ( domain Name ) ) { return ; } if ( restricted Domains == null ) { restricted Domains = new  Array List < > ( ) ; } restricted Domains . add ( domain Name ) ; }
Stoppable Read Lock (  Read Write Lock lock ,  Cancel Criterion stopper ) { this . lock = lock . read Lock ( ) ; this . stopper = stopper ; }
private long compute Interface Hash ( ) { long hash = _ NUM ;  Byte Array Output Stream sink = new  Byte Array Output Stream ( _ NUM ) ; try {  Message Digest md =  Message Digest . get Instance ( _ STR ) ;  Data Output Stream out = new  Data Output Stream ( new  Digest Output Stream ( sink , md ) ) ; out . write Int (  INTERFACE_ HASH_ STUB_ VERSION ) ; for (  Method method : remote Methods ) {  Method Doc method Doc = method . method Doc ( ) ; out . write UTF ( method Doc . name ( ) ) ; out . write UTF (  Util . method Descriptor Of ( method Doc ) ) ;  Class Doc exceptions [ ] = method Doc . thrown Exceptions ( ) ;  Arrays . sort ( exceptions , new  Class Doc Comparator ( ) ) ; for (  Class Doc ex : exceptions ) { out . write UTF (  Util . binary Name Of ( ex ) ) ; } } out . flush ( ) ; byte hash Array [ ] = md . digest ( ) ; for ( int i = _ NUM ; i <  Math . min ( _ NUM , hash Array . length ) ; i ++ ) { hash += ( ( long ) ( hash Array [ i ] & _ NUM ) ) << ( i * _ NUM ) ; } } catch (  IOException e ) { throw new  Assertion Error ( e ) ; } catch (  No Such Algorithm Exception e ) { throw new  Assertion Error ( e ) ; } return hash ; }
private static native boolean render Frame ( int [ ] pixels , long gif File In Ptr , int [ ] meta Data ) ;
private  Service Registrar [ ] build Service Registrar ( ) { int k = _ NUM ;  Service Registrar [ ] proxys = new  Service Registrar [ proxy Reg Set . size ( ) ] ;  Iterator iter = proxy Reg Set . iterator ( ) ; while ( iter . has Next ( ) ) {  Proxy Reg reg = (  Proxy Reg ) iter . next ( ) ; proxys [ k ++ ] = reg . proxy ; } return proxys ; }
private static boolean check Value (  String val ) throws  Malformed Object Name Exception { if ( val == null ) throw new  Null Pointer Exception ( _ STR ) ; final int len = val . length ( ) ; if ( len == _ NUM ) return _ BOOL ; final char [ ] s = val . to Char Array ( ) ; final int [ ] result = parse Value ( s , _ NUM ) ; final int end Value = result [ _ NUM ] ; final boolean value_pattern = result [ _ NUM ] == _ NUM ; if ( end Value < len ) throw new  Malformed Object Name Exception ( _ STR + s [ end Value ] + _ STR ) ; return value_pattern ; }
protected void recover Primary (  Set excluded Servers ) { if ( pool . get Pool Or Cache Cancel In Progress ( ) != null ) { return ; } final boolean is Debug Enabled = logger . is Debug Enabled ( ) ; if ( queue Connections . get Primary ( ) != null ) { if ( is Debug Enabled ) { logger . debug ( _ STR ) ; } return ; } if ( is Debug Enabled ) { logger . debug ( _ STR ) ; } if ( print Recovering Primary ) { logger . info (  Localized Message . create (  Localized Strings .  Queue Manager Impl_ SUBSCRIPTION_ MANAGER_ REDUNDANCY_ SATISFIER_ PRIMARY_ ENDPOINT_ HAS_ BEEN_ LOST_ ATTEMPTIMG_ TO_ RECOVER ) ) ; print Recovering Primary = _ BOOL ; }  Queue Connection Impl new Primary = null ; while ( new Primary == null && pool . get Pool Or Cache Cancel In Progress ( ) == null ) {  List backups = queue Connections . get Backups ( ) ; new Primary = promote Backup To Primary ( backups ) ; if ( new Primary == null ) { break ; } if ( ! add To Connection List ( new Primary , _ BOOL ) ) { synchronized ( lock ) { queue Connections = queue Connections . remove Connection ( new Primary ) ; } new Primary = null ; } } if ( new Primary != null ) { if ( is Debug Enabled ) { logger . debug ( _ STR , new Primary . get Endpoint ( ) ) ; } if (  Pool Impl .  AFTER_ PRIMARY_ RECOVERED_ CALLBACK_ FLAG ) {  Client Server Observer bo =  Client Server Observer Holder . get Instance ( ) ; bo . after Primary Recovered ( new Primary . get Server ( ) ) ; } cqs Connected ( ) ; print Primary Not Found Error = _ BOOL ; print Recovering Primary = _ BOOL ; return ; } while ( new Primary == null ) { new Primary = create New Primary ( excluded Servers ) ; if ( new Primary == null ) { break ; } if ( ! add To Connection List ( new Primary , _ BOOL ) ) { excluded Servers . add ( new Primary . get Server ( ) ) ; new Primary = null ; } if ( new Primary != null ) { if ( is Debug Enabled ) { logger . debug ( _ STR , new Primary . get Endpoint ( ) ) ; } if ( ! recover Interest ( new Primary , _ BOOL ) ) { excluded Servers . add ( new Primary . get Server ( ) ) ; new Primary = null ; } cqs Connected ( ) ; } if ( new Primary != null &&  Pool Impl .  AFTER_ PRIMARY_ RECOVERED_ CALLBACK_ FLAG ) {  Client Server Observer bo =  Client Server Observer Holder . get Instance ( ) ; bo . after Primary Recovered ( new Primary . get Server ( ) ) ; } print Primary Not Found Error = _ BOOL ; print Recovering Primary = _ BOOL ; return ; } cqs Disconnected ( ) ; if ( is Debug Enabled ) { logger . debug ( _ STR ) ; } synchronized ( lock ) { queue Connections = queue Connections . set Primary Discovery Failed ( null ) ; lock . notify All ( ) ; } }
public void add Nodes In Doc Order (  DTMIterator iterator ,  XPath Context support ) { if ( ! m_mutable ) throw new  Runtime Exception (  XSLMessages . create XPATHMessage (  XPATHError Resources .  ER_ NODESETDTM_ NOT_ MUTABLE , null ) ) ; int node ; while (  DTM .  NULL != ( node = iterator . next Node ( ) ) ) { add Node In Doc Order ( node , support ) ; } }
protected boolean need To Refetch Data ( ) { long now =  System . current Time Millis ( ) ; long last = last Data Fetch Time ; if ( ( last + fetch Interval Millis ) < now ) { last Data Fetch Time = now ; return _ BOOL ; } return _ BOOL ; }
@  Override public  Document Type create Document Type (  String qualified Name ,  String public ID ,  String system ID ) { check QName ( qualified Name ) ; return new  Document Type Impl ( null , qualified Name , public ID , system ID ) ; }
public void handle Request (  Request Context rc ) throws  CLIException { super . handle Request ( rc ) ; ldap Login ( ) ;  SSOToken admin SSOToken = get Admin SSOToken ( ) ;  IOutput output Writer = get Output Writer ( ) ;  String realm = get String Option Value (  IArgument .  REALM_ NAME ) ;  String pattern Type = get String Option Value (  IArgument .  AGENT_ TYPE ) ;  String filter = get String Option Value (  IArgument .  FILTER ) ; if ( pattern Type == null ) { pattern Type = _ STR ; } if ( ( filter == null ) || ( filter . length ( ) == _ NUM ) ) { filter = _ STR ; }  String [ ] params = { realm , pattern Type , filter } ; write Log (  Log Writer .  LOG_ ACCESS ,  Level .  INFO , _ STR , params ) ; try {  AMIdentity Repository amir = new  AMIdentity Repository ( admin SSOToken , realm ) ;  Id Search Results isr = amir . search Identities (  Id Type .  AGENTONLY , filter , new  Id Search Control ( ) ) ;  Set results = isr . get Search Results ( ) ; if ( ( results != null ) && ! results . is Empty ( ) ) { for (  Iterator i = results . iterator ( ) ; i . has Next ( ) ; ) {  AMIdentity amid = (  AMIdentity ) i . next ( ) ; if ( ! match Type ( amid , pattern Type ) ) { i . remove ( ) ; } } } if ( ( results != null ) && ! results . is Empty ( ) ) { for (  Iterator i = results . iterator ( ) ; i . has Next ( ) ; ) {  AMIdentity amid = (  AMIdentity ) i . next ( ) ;  Object [ ] args = { amid . get Name ( ) , amid . get Universal Id ( ) } ; output Writer . println Message (  Message Format . format ( get Resource String ( _ STR ) , args ) ) ; } } else { output Writer . println Message ( get Resource String ( _ STR ) ) ; } write Log (  Log Writer .  LOG_ ACCESS ,  Level .  INFO , _ STR , params ) ; } catch (  Id Repo Exception e ) {  String [ ] args = { realm , pattern Type , filter , e . get Message ( ) } ; debug Error ( _ STR , e ) ; write Log (  Log Writer .  LOG_ ERROR ,  Level .  INFO , _ STR , args ) ; throw new  CLIException ( e ,  Exit Codes .  REQUEST_ CANNOT_ BE_ PROCESSED ) ; } catch (  SSOException e ) {  String [ ] args = { realm , pattern Type , filter , e . get Message ( ) } ; debug Error ( _ STR , e ) ; write Log (  Log Writer .  LOG_ ERROR ,  Level .  INFO , _ STR , args ) ; throw new  CLIException ( e ,  Exit Codes .  REQUEST_ CANNOT_ BE_ PROCESSED ) ; } }
public byte [ ] to Bytes ( ) { try {  Byte Array Output Stream out = new  Byte Array Output Stream ( ) ; _field . store ( out , null ) ; return out . to Byte Array ( ) ; } catch (  IOException e ) { throw new  Illegal State Exception ( e ) ; } }
@  Suppress Warnings ( _ STR ) public static <  E extends  Enum < ? extends  Style .  Has Css Name > >  E from Style Name ( final  String style Name , final  Class <  E > enum Class , final  E default Value ) { if ( style Name == null || enum Class == null ) { return default Value ; } for ( final  Enum < ? extends  Style .  Has Css Name > constant : enum Class . get Enum Constants ( ) ) { final  Style .  Has Css Name an Enum = (  Style .  Has Css Name ) constant ; final  String css Class = an Enum . get Css Name ( ) ; if ( css Class != null &&  Style Helper . contains Style ( style Name , css Class ) ) { return (  E ) an Enum ; } } return default Value ; }
@  HLEUnimplemented @  HLEFunction ( nid = _ NUM , version = _ NUM , check Inside Interrupt = _ BOOL ) public int sce Mpeg Next Avc Rp Au ( @  Check Argument ( _ STR ) int mpeg , int stream Uid ) { if ( ! stream Map . contains Key ( stream Uid ) ) { log . warn (  String . format ( _ STR , stream Uid ) ) ; return - _ NUM ; } int result = hle Mpeg Get Avc Au ( null ) ; if ( result != _ NUM ) { if ( log . is Debug Enabled ( ) ) { log . debug (  String . format ( _ STR , result ) ) ; } return result ; } video Frame Count ++ ; started Mpeg = _ BOOL ; return _ NUM ; }
private  Map <  URI ,  Export Mask > create Export Mask Map (  Set <  URI > placed Masks ) {  Map <  URI ,  Export Mask > export Mask Map = new  Hash Map < > ( ) ;  Iterator <  Export Mask > export Mask Iterator = db Client . query Iterative Objects (  Export Mask . class , placed Masks , _ BOOL ) ; while ( export Mask Iterator . has Next ( ) ) {  Export Mask export Mask = export Mask Iterator . next ( ) ; export Mask Map . put ( export Mask . get Id ( ) , export Mask ) ; } return export Mask Map ; }
public  Immutable Array2 <  K > insert ( int index ,  K obj ) { int len = length + _ NUM ; int new Len = len ; boolean extendable ; if ( index == len - _ NUM ) {  Atomic Boolean x = can Extend ; if ( x != null ) { can Extend = null ; if ( array . length > index && x . get And Set ( _ BOOL ) ) { array [ index ] = obj ; return new  Immutable Array2 <  K > ( array , len , _ BOOL ) ; } } extendable = _ BOOL ; new Len = len + _ NUM ; } else { extendable = _ BOOL ; } @  Suppress Warnings ( _ STR )  K [ ] a2 = (  K [ ] ) new  Object [ new Len ] ;  Data Utils . copy With Gap ( array , a2 , length , index ) ; a2 [ index ] = obj ; return new  Immutable Array2 <  K > ( a2 , len , extendable ) ; }
public void write No Scale (  Image c ,  Component i ) { if ( page == null ) { newpage ( ) ; } int x = x0 + width - ( c . get Width ( null ) + charwidth ) ; int y = y0 + ( linenum * lineheight ) + lineascent ; if ( page != null && pagenum >= pr First ) { page . draw Image ( c , x , y , c . get Width ( null ) , c . get Height ( null ) , null ) ; } }
public static void copy (  Input Stream is ,  Resource out , boolean close IS ) throws  IOException {  Output Stream os = null ; try { os = to Buffered Output Stream ( out . get Output Stream ( ) ) ; } catch (  IOException ioe ) {  IOUtil . close EL ( os ) ; throw ioe ; } copy ( is , os , close IS , _ BOOL ) ; }
public  String fade Audio (  String path ,  String type , double fade In Length , double stop Time , double fade Out Length ) throws  IOException { final  List <  String > curves =  Arrays . as List ( new  String [ ] { _ STR , _ STR , _ STR , _ STR , _ STR } ) ; if ( ! curves . contains ( type ) ) { throw new  Runtime Exception ( _ STR + type ) ; }  File file = new  File ( path ) ;  String out File = file . get Canonical Path ( ) + _ STR ;  Array List <  String > cmd = new  Array List <  String > ( ) ; cmd . add ( sox Bin ) ; cmd . add ( path ) ; cmd . add ( out File ) ; cmd . add ( _ STR ) ; cmd . add ( type ) ; cmd . add ( fade In Length + _ STR ) ; if ( stop Time != - _ NUM ) cmd . add ( stop Time + _ STR ) ; if ( fade Out Length != - _ NUM ) cmd . add ( fade Out Length + _ STR ) ; try { int rc = exec Sox ( cmd , callback ) ; if ( rc != _ NUM ) { out File = null ; } } catch (  IOException e ) { e . print Stack Trace ( ) ; } catch (  Interrupted Exception e ) { e . print Stack Trace ( ) ; } return out File ; }
@  Override public void draw (  Canvas canvas ) { super . draw ( canvas ) ; if ( m Edge Glow Top != null ) { final int scroll X = get Scroll X ( ) ; if ( ! m Edge Glow Top . is Finished ( ) ) { final int restore Count = canvas . save ( ) ; final int top Padding = m List Padding . top + m Glow Padding Top ; final int bottom Padding = m List Padding . bottom + m Glow Padding Bottom ; final int height = get Height ( ) - top Padding - bottom Padding ; int edge X =  Math . min ( _ NUM , scroll X + m First Position Distance Guess ) ; canvas . rotate ( - _ NUM ) ; canvas . translate ( - get Height ( ) + top Padding , edge X ) ; m Edge Glow Top . set Size ( height , height ) ; if ( m Edge Glow Top . draw ( canvas ) ) { invalidate ( ) ; } canvas . restore To Count ( restore Count ) ; } if ( ! m Edge Glow Bottom . is Finished ( ) ) { final int restore Count = canvas . save ( ) ; final int top Padding = m List Padding . left + m Glow Padding Top ; final int bottom Padding = m List Padding . right + m Glow Padding Bottom ; final int height = get Height ( ) - top Padding - bottom Padding ; final int width = get Width ( ) ; int edge X =  Math . max ( width , scroll X + m Last Position Distance Guess ) ; canvas . rotate ( _ NUM ) ; canvas . translate ( - top Padding , - edge X ) ; m Edge Glow Bottom . set Size ( height , height ) ; if ( m Edge Glow Bottom . draw ( canvas ) ) { invalidate ( ) ; } canvas . restore To Count ( restore Count ) ; } } }
public static  Class Properties load Properties (  Class [ ] cls ,  Properties properties , boolean inherit ) {  Class Properties cp = new  Class Properties ( properties ) ; for (  Class c : cls ) { cp . load ( c , inherit ) ; } return cp ; }
private static void fix GPSTime Stamp (  XMPNode exif Schema ) throws  XMPException {  XMPNode gps Date Time =  XMPNode Utils . find Child Node ( exif Schema , _ STR , _ BOOL ) ; if ( gps Date Time == null ) { return ; } try {  XMPDate Time bin GPSStamp ;  XMPDate Time bin Other Date ; bin GPSStamp =  XMPUtils . convert To Date ( gps Date Time . get Value ( ) ) ; if ( bin GPSStamp . get Year ( ) != _ NUM || bin GPSStamp . get Month ( ) != _ NUM || bin GPSStamp . get Day ( ) != _ NUM ) { return ; }  XMPNode other Date =  XMPNode Utils . find Child Node ( exif Schema , _ STR , _ BOOL ) ; if ( other Date == null ) { other Date =  XMPNode Utils . find Child Node ( exif Schema , _ STR , _ BOOL ) ; } bin Other Date =  XMPUtils . convert To Date ( other Date . get Value ( ) ) ;  Calendar cal = bin GPSStamp . get Calendar ( ) ; cal . set (  Calendar .  YEAR , bin Other Date . get Year ( ) ) ; cal . set (  Calendar .  MONTH , bin Other Date . get Month ( ) ) ; cal . set (  Calendar .  DAY_ OF_ MONTH , bin Other Date . get Day ( ) ) ; bin GPSStamp = new  XMPDate Time Impl ( cal ) ; gps Date Time . set Value (  XMPUtils . convert From Date ( bin GPSStamp ) ) ; } catch (  XMPException e ) { return ; } }
protected boolean cell Consumes Event Type (  Cell < ? > cell ,  String event Type ) {  Set <  String > consumed Events = cell . get Consumed Events ( ) ; return consumed Events != null && consumed Events . contains ( event Type ) ; }
public int read ( ) throws  IOException { int b0 = f Input Stream . read ( ) ; if ( b0 > _ NUM ) { throw new  IOException (  Localizer . get Message ( _ STR ,  Integer . to String ( b0 ) ) ) ; } return b0 ; }
protected void create_y_axis ( int i ) {  Log . e ( _ STR , i + _ STR ) ; float ver_height = ( ( graphheight / label_size ) * i ) + border ; if ( i == largest_value_set . size ( ) - _ NUM ) canvas . draw Line ( horstart , ver_height , width - ( border ) , ver_height , paint ) ; else canvas . draw Line ( horstart , ver_height , border , ver_height , paint ) ; paint . set Color (  Color .  BLACK ) ; int  Y_labels = ( int ) size - _ NUM - i ;  String y_labels =  String . format ( _ STR ,  Y_labels * y_axis_ratio ) ; paint . set Text Align (  Paint .  Align .  RIGHT ) ; canvas . draw Text ( y_labels , horstart - _ NUM , ver_height - _ NUM , paint ) ; paint . set Text Align (  Paint .  Align .  LEFT ) ; }
public long max ( ) { return delta Max . get ( ) ; }
public void print (  File file ) throws  IOException { check Exec ( ) ;  Security Manager sm =  System . get Security Manager ( ) ; if ( sm != null ) { sm . check Print Job Access ( ) ; } check Action Support (  Action .  PRINT ) ; check File Validation ( file ) ; peer . print ( file ) ; }
public void extend (  Rule Grounding other ) { if ( other . is Failed ( ) ) { groundings . clear ( ) ; return ; } extend ( other . get Alternatives ( ) ) ; }
@  Override public  String expect (  Pattern pattern ) { final  String token = read ( pattern ) ; if ( token == null ) { throw new  Parser Exception ( _ STR + pattern . pattern ( ) + _ STR + document ) ; } return token ; }
public void test Get Table Types Order ( ) throws  Exception {  Database Meta Data dmd = con . get Meta Data ( ) ;  Result Set rs = dmd . get Table Types ( ) ;  String previous Type = _ STR ; while ( rs . next ( ) ) {  String type = rs . get String ( _ NUM ) ; assert True ( type . compare To ( previous Type ) >= _ NUM ) ; previous Type = type ; } rs . close ( ) ; }
public void add Parameters ( final  Name Value Pair [ ] parameters ) {  LOG . trace ( _ STR ) ; if ( parameters == null ) {  LOG . warn ( _ STR ) ; } else { super . clear Request Body ( ) ; for ( int i = _ NUM ; i < parameters . length ; i ++ ) { params . add ( parameters [ i ] ) ; } } }
@  Pure public  Atom annotation Interface To Annotation Class ( ) { byte [ ] annotation Class Name_tmp = new byte [ val . length + _ NUM ] ;  System . arraycopy ( val , _ NUM , annotation Class Name_tmp , _ NUM , val . length - _ NUM ) ; annotation Class Name_tmp [ val . length - _ NUM ] = _ STR ; annotation Class Name_tmp [ val . length ] = _ STR ; annotation Class Name_tmp [ val . length + _ NUM ] = _ STR ; return  Atom . find Or Create Utf8 Atom ( annotation Class Name_tmp ) ; }
public boolean resource Support AR (  Integer id ) { if ( id == null ) { return _ BOOL ; } return resource Support AR ( id . int Value ( ) ) ; }
public  Pattern Guard Expr (  String namespace ,  String name ,  Expression [ ] parameters ,  Pattern Expr guarded ) { this ( namespace , name ,  Arrays . as List ( parameters ) , guarded ) ; }
public static int unix Timestamp ( ) { return ( int ) (  System . current Time Millis ( ) / _ NUM ) ; }
public boolean is PDFLicense ( ) {  String key = get Summary ( ) ; return key != null && key . length ( ) > _ NUM ; }
public  Zip Stream Impl open Read Impl (  Path Impl path ) throws  IOException {  String path Name = path . get Path ( ) ; return open Read Impl ( path Name ) ; }
@  Override public void on Tmp Files Copied (  Result Code result ) { dismiss Loading Dialog ( ) ; finish ( ) ; }
public synchronized  OMGraphic List prepare ( ) {  Projection projection = get Projection ( ) ; boolean  DEBUG_ FINE = logger . is Loggable (  Level .  FINE ) ; if ( projection == null ) { if (  DEBUG_ FINE ) { logger . fine ( get Name ( ) + _ STR ) ; } return new  OMGraphic List ( ) ; } if ( spatial Index == null ) { if (  DEBUG_ FINE ) { logger . fine ( get Name ( ) + _ STR ) ; }  OMGraphic List list = get List ( ) ; if ( list != null ) { list . generate ( projection , _ BOOL ) ; return list ; } else { return new  OMGraphic List ( ) ; } }  Point2 D ul = projection . get Upper Left ( ) ;  Point2 D lr = projection . get Lower Right ( ) ; double ul Lat = ul . get Y ( ) ; double ul Lon = ul . get X ( ) ; double lr Lat = lr . get Y ( ) ; double lr Lon = lr . get X ( ) ;  OMGraphic List list = new  OMGraphic List ( ) ; if (  Proj Math . is Crossing Dateline ( ul Lon , lr Lon , projection . get Scale ( ) ) ) { if (  DEBUG_ FINE ) { logger . fine ( _ STR ) ; } double ymin =  Math . min ( ul Lat , lr Lat ) ; double ymax =  Math . max ( ul Lat , lr Lat ) ; try { list = spatial Index . get OMGraphics ( ul Lon , ymin , _ NUM , ymax , list , drawing Attributes , projection , coord Transform ) ; list = spatial Index . get OMGraphics ( - _ NUM , ymin , lr Lon , ymax , list , drawing Attributes , projection , coord Transform ) ; } catch (  Interrupted IOException iioe ) { list = null ; } catch (  IOException ex ) { if (  DEBUG_ FINE ) { ex . print Stack Trace ( ) ; } } catch (  Format Exception fe ) { if (  DEBUG_ FINE ) { fe . print Stack Trace ( ) ; } } catch (  Null Pointer Exception npe ) { if (  DEBUG_ FINE ) { npe . print Stack Trace ( ) ; } } } else { double xmin =  Math . min ( ul Lon , lr Lon ) ; double xmax =  Math . max ( ul Lon , lr Lon ) ; double ymin =  Math . min ( ul Lat , lr Lat ) ; double ymax =  Math . max ( ul Lat , lr Lat ) ; try { list = spatial Index . get OMGraphics ( xmin , ymin , xmax , ymax , list , drawing Attributes , projection , coord Transform ) ; } catch (  Interrupted IOException iioe ) { list = null ; } catch ( java . io .  IOException ex ) { if (  DEBUG_ FINE ) { ex . print Stack Trace ( ) ; } } catch (  Format Exception fe ) { if (  DEBUG_ FINE ) { fe . print Stack Trace ( ) ; } } catch (  Null Pointer Exception npe ) { if (  DEBUG_ FINE ) { npe . print Stack Trace ( ) ; } } } return list ; }
private boolean is Field Package Private (  Element attribute ) {  Set <  Modifier > modifiers = attribute . get Modifiers ( ) ; return ! modifiers . contains (  PUBLIC ) && ! modifiers . contains (  PROTECTED ) && ! modifiers . contains (  PRIVATE ) ; }
public void test Divide Round Half Up Pos ( ) {  String a = _ STR ; int a Scale = - _ NUM ;  String b = _ STR ; int b Scale = _ NUM ;  String c = _ STR ; int res Scale = - _ NUM ;  Big Decimal a Number = new  Big Decimal ( new  Big Integer ( a ) , a Scale ) ;  Big Decimal b Number = new  Big Decimal ( new  Big Integer ( b ) , b Scale ) ;  Big Decimal result = a Number . divide ( b Number , res Scale ,  Big Decimal .  ROUND_ HALF_ UP ) ; assert Equals ( _ STR , c , result . to String ( ) ) ; assert Equals ( _ STR , res Scale , result . scale ( ) ) ; }
public boolean really Restore Ms Word List Format For User (  String user Id ,  Input Stream Reader stream Reader , boolean is Admin ,  Errors errors ) { if ( user Id == null ) {  Errors . add ( errors , error Messages . errors User Id Is Null ( ) ) ; return _ BOOL ; } if ( stream Reader == null ) {  Errors . add ( errors , error Messages . errors The Input Stream Reader Is Null ( ) ) ; return _ BOOL ; }  Buffered Reader bf = new  Buffered Reader ( stream Reader ) ; final  User user = get User By Id ( user Id ) ; if ( user == null ) { return _ BOOL ; } boolean created Any Children = _ BOOL ; try { final long now =  System . current Time Millis ( ) ;  Entry notebook = create Entry Note Book ( user , _ STR , now , null , null , _ BOOL , _ BOOL , _ BOOL , is Admin , _ BOOL , errors ) ; if ( notebook == null ) { return _ BOOL ; }  Entry root = get Entry By Id ( notebook . get Root Id ( ) ) ;  Array List <  Entry > parents = new  Array List <  Entry > ( ) ;  Hash Map <  String ,  Integer > bullet To Depth = new  Hash Map <  String ,  Integer > ( ) ;  String line = null ;  Integer previous Depth = _ NUM ; parents . add ( root ) ; while ( ( line = bf . read Line ( ) ) != null ) { line = line . trim ( ) ; if ( line . is Empty ( ) ) { continue ; }  String note = line ;  Integer depth = _ NUM ; if ( line . length ( ) > _ NUM && line . char At ( _ NUM ) == _ STR ) {  String bullet = line . substring ( _ NUM , _ NUM ) ; note = line . substring ( _ NUM ) ; depth = bullet To Depth . get ( bullet ) ; if ( depth == null ) { depth = new  Integer ( bullet To Depth . size ( ) + _ NUM ) ; bullet To Depth . put ( bullet , depth ) ; } for ( int i = parents . size ( ) ; i > depth . int Value ( ) ; -- i ) { parents . remove ( i - _ NUM ) ; } depth = new  Integer ( parents . size ( ) + _ NUM ) ; } else { previous Depth = _ NUM ; while ( parents . size ( ) > _ NUM ) { parents . remove ( parents . size ( ) - _ NUM ) ; } } if ( parents . is Empty ( ) ) { return _ BOOL ; }  Entry parent = parents . get ( parents . size ( ) - _ NUM ) ;  Entry entry = create Simple Entry ( user , note , now , parent . get Id ( ) ,  Tree Rel Type .  Parent , _ BOOL , _ BOOL , _ BOOL , is Admin ,  Constants . note , errors , null ) ; if ( entry == null ) { return _ BOOL ; } if ( previous Depth . int Value ( ) != depth . int Value ( ) ) { parents . add ( entry ) ; } else { parents . set ( parents . size ( ) - _ NUM , entry ) ; } created Any Children = _ BOOL ; } } catch (  IOException e ) {  Errors . add ( errors , error Messages . error Problem Reading Input ( ) ) ; } return created Any Children ; }
public static  String convert Codes (  String string ) { if ( string == null ) return string ; int current = _ NUM ; char [ ] cs = string . to Char Array ( ) ;  String Builder sb = new  String Builder ( ) ; for ( char c : cs ) { if ( current <= cs . length && c == _ STR ) { char tc =  Character . to Lower Case ( cs [ current + _ NUM ] ) ; if ( tc == _ STR || tc == _ STR || tc == _ STR || tc == _ STR || tc == _ STR || tc == _ STR || tc == _ STR || tc == _ STR || tc == _ STR || tc == _ STR || tc == _ STR || tc == _ STR || tc == _ STR || tc == _ STR || tc == _ STR || tc == _ STR || tc == _ STR || tc == _ STR || tc == _ STR || tc == _ STR || tc == _ STR ) { sb . append ( _ STR ) ; } else { sb . append ( c ) ; } } else { sb . append ( c ) ; } current ++ ; } return sb . to String ( ) ; }
private void load Text (  Input Stream is ) {  Buffered Reader reader ;  String line ; unit List = new  Array List ( ) ; unit Types List = new  Array List ( ) ; if ( is == null ) { throw new  Error ( _ STR ) ; } reader = new  Buffered Reader ( new  Input Stream Reader ( is ) ) ; try { line = reader . read Line ( ) ; line Count ++ ; while ( line != null ) { if ( ! line . starts With ( _ STR ) ) { parse And Add ( line , reader ) ; } line = reader . read Line ( ) ; } reader . close ( ) ; units = new  Database Cluster Unit [ unit List . size ( ) ] ; units = (  Database Cluster Unit [ ] ) unit List . to Array ( units ) ; unit List = null ; unit Types = new  Unit Type [ unit Types List . size ( ) ] ; unit Types = (  Unit Type [ ] ) unit Types List . to Array ( unit Types ) ; unit Types List = null ; } catch (  IOException e ) { throw new  Error ( e . get Message ( ) + _ STR + line Count ) ; } finally { } }
private int measure Width ( int measure Spec ) { int result ; int spec Mode =  Measure Spec . get Mode ( measure Spec ) ; int spec Size =  Measure Spec . get Size ( measure Spec ) ; if ( spec Mode ==  Measure Spec .  EXACTLY ) { result = spec Size ; } else { result = ( int ) m Text Paint . measure Text ( m Text ) + get Padding Left ( ) + get Padding Right ( ) ; if ( spec Mode ==  Measure Spec .  AT_ MOST ) { result =  Math . min ( result , spec Size ) ; } } return result ; }
public void test_get Put Byte Array ( ) { final int capacity = _ NUM ; final  Byte Array Buffer buf = new  Byte Array Buffer ( capacity ) ; assert Equals ( ( byte ) _ NUM , buf . get Byte ( _ NUM ) ) ; assert Equals ( ( byte ) _ NUM , buf . get Byte ( capacity - _ NUM ) ) ; final int pos = _ NUM ; for ( int i = _ NUM ; i <  LIMIT ; i ++ ) { final byte [ ] expected = new byte [ r . next Int ( capacity - _ NUM ) ] ; r . next Bytes ( expected ) ; buf . put ( pos , expected ) ; assert Equals ( _ NUM ,  Bytes Util . compare Bytes With Len And Offset ( _ NUM , expected . length , expected , pos , expected . length , buf . array ( ) ) ) ; final byte [ ] actual = new byte [ expected . length ] ; buf . get ( pos , actual ) ; assert True (  Bytes Util . bytes Equal ( expected , actual ) ) ; } assert Equals ( ( byte ) _ NUM , buf . get Byte ( _ NUM ) ) ; assert Equals ( ( byte ) _ NUM , buf . get Byte ( pos + capacity - _ NUM ) ) ; }
@  Override public void on Added ( final  RPObject object ) { if ( is User ( object ) ) { if ( object . has ( _ STR ) ) { adminlevel = object . get Int ( _ STR ) ; } } }
private  String local_number ( ) throws  Parse Exception {  String Builder s = new  String Builder ( ) ; if ( debug ) dbg_enter ( _ STR ) ; try { int lc = _ NUM ; while ( lexer . has More Chars ( ) ) { char la = lexer . look Ahead ( _ NUM ) ; if ( la == _ STR || la == _ STR || la == _ STR || la == _ STR || la == _ STR || la == _ STR ||  Lexer . is Hex Digit ( la ) ) { lexer . consume ( _ NUM ) ; s . append ( la ) ; lc ++ ; } else if ( lc > _ NUM ) break ; else throw create Parse Exception ( _ STR + la ) ; } return s . to String ( ) ; } finally { if ( debug ) dbg_leave ( _ STR ) ; } }
public static void slide In From Top Animator ( @  Non Null  List <  Animator > animators , @  Non Null  View view ,  Recycler View recycler View ) { alpha Animator ( animators , view , _ NUM ) ; animators . add (  Object Animator . of Float ( view , _ STR , - recycler View . get Measured Height ( ) > > _ NUM , _ NUM ) ) ; if (  Flexible Adapter .  DEBUG )  Log . v (  TAG , _ STR ) ; }
Mutable Big Integer (  Mutable Big Integer val ) { int Len = val . int Len ; value =  Arrays . copy Of Range ( val . value , val . offset , val . offset + int Len ) ; }
@  Request Mapping ( value = _ STR ) public void sso Binding Error (  Locale locale , @  Path Variable ( value = _ STR )  String tenant ,  Http Servlet Response response ) throws  IOException { logger . info ( _ STR + locale . to String ( ) + _ STR + tenant ) ; sso Default Tenant Error ( locale , response ) ; }
public  Checkpoint Manager (  Network Parameters params , @  Nullable  Input Stream input Stream ) throws  IOException { this . params = check Not Null ( params ) ; if ( input Stream == null ) input Stream = open Stream ( params ) ; check Not Null ( input Stream ) ; input Stream = new  Buffered Input Stream ( input Stream ) ; input Stream . mark ( _ NUM ) ; int first = input Stream . read ( ) ; input Stream . reset ( ) ; if ( first ==  BINARY_ MAGIC . char At ( _ NUM ) ) data Hash = read Binary ( input Stream ) ; else if ( first ==  TEXTUAL_ MAGIC . char At ( _ NUM ) ) data Hash = read Textual ( input Stream ) ; else throw new  IOException ( _ STR ) ; }
public  Index Segment Index (  IRaw Store store ,  Checkpoint checkpoint ,  Index Metadata metadata , boolean read Only ) { super ( store , checkpoint , metadata , read Only ) ; }
private  String liveness ( ) { boolean is Closed = _ BOOL ; try { if ( is Closed ( ) ) { is Closed = _ BOOL ; } } catch (  SQLException s ) { is Closed = _ BOOL ; } if ( is Closed ) { return _ STR ; } return _ STR ; }
private static void insert Value ( final  Map <  String ,  List <  String > > params Map , final  String param Val , final  String parameter Name ) { if ( param Val != null ) {  List <  String > list = new  Array List < > ( ) ; list . add ( param Val ) ; params Map . put ( parameter Name , list ) ; } }
public  Dimension minimum Layout Size (  Container target ) {  Dimension size ; synchronized ( this ) { check Container ( target ) ; check Requests ( ) ; size = new  Dimension ( x Total . minimum , y Total . minimum ) ; }  Insets insets = target . get Insets ( ) ; size . width = ( int )  Math . min ( ( long ) size . width + ( long ) insets . left + ( long ) insets . right ,  Integer .  MAX_ VALUE ) ; size . height = ( int )  Math . min ( ( long ) size . height + ( long ) insets . top + ( long ) insets . bottom ,  Integer .  MAX_ VALUE ) ; return size ; }
private static void solve_l2r_l1l2_svr (  Problem prob , double [ ] w ,  Parameter param ) { int l = prob . l ; double  C = param .  C ; double p = param . p ; int w_size = prob . n ; double eps = param . eps ; int i , s , iter = _ NUM ; int max_iter = param . get Max Iters ( ) ; int active_size = l ; int [ ] index = new int [ l ] ; double d ,  G ,  H ; double  Gmax_old =  Double .  POSITIVE_ INFINITY ; double  Gmax_new ,  Gnorm1_new ; double  Gnorm1_init = - _ NUM ; double [ ] beta = new double [ l ] ; double [ ]  QD = new double [ l ] ; double [ ] y = prob . y ; double [ ] lambda = new double [ ] { _ NUM /  C } ; double [ ] upper_bound = new double [ ] {  Double .  POSITIVE_ INFINITY } ; if ( param . solver Type ==  Solver Type .  L2 R_ L1 LOSS_ SVR_ DUAL ) { lambda [ _ NUM ] = _ NUM ; upper_bound [ _ NUM ] =  C ; } for ( i = _ NUM ; i < l ; i ++ ) beta [ i ] = _ NUM ; for ( i = _ NUM ; i < w_size ; i ++ ) w [ i ] = _ NUM ; for ( i = _ NUM ; i < l ; i ++ ) {  QD [ i ] = _ NUM ; for (  Feature xi : prob . x [ i ] ) { double val = xi . get Value ( ) ;  QD [ i ] += val * val ; w [ xi . get Index ( ) - _ NUM ] += beta [ i ] * val ; } index [ i ] = i ; } while ( iter < max_iter ) {  Gmax_new = _ NUM ;  Gnorm1_new = _ NUM ; for ( i = _ NUM ; i < active_size ; i ++ ) { int j = i + random . next Int ( active_size - i ) ; swap ( index , i , j ) ; } for ( s = _ NUM ; s < active_size ; s ++ ) { i = index [ s ] ;  G = - y [ i ] + lambda [  GETI_ SVR ( i ) ] * beta [ i ] ;  H =  QD [ i ] + lambda [  GETI_ SVR ( i ) ] ; for (  Feature xi : prob . x [ i ] ) { int ind = xi . get Index ( ) - _ NUM ; double val = xi . get Value ( ) ;  G += val * w [ ind ] ; } double  Gp =  G + p ; double  Gn =  G - p ; double violation = _ NUM ; if ( beta [ i ] == _ NUM ) { if (  Gp < _ NUM ) violation = -  Gp ; else if (  Gn > _ NUM ) violation =  Gn ; else if (  Gp >  Gmax_old &&  Gn < -  Gmax_old ) { active_size -- ; swap ( index , s , active_size ) ; s -- ; continue ; } } else if ( beta [ i ] >= upper_bound [  GETI_ SVR ( i ) ] ) { if (  Gp > _ NUM ) violation =  Gp ; else if (  Gp < -  Gmax_old ) { active_size -- ; swap ( index , s , active_size ) ; s -- ; continue ; } } else if ( beta [ i ] <= - upper_bound [  GETI_ SVR ( i ) ] ) { if (  Gn < _ NUM ) violation = -  Gn ; else if (  Gn >  Gmax_old ) { active_size -- ; swap ( index , s , active_size ) ; s -- ; continue ; } } else if ( beta [ i ] > _ NUM ) violation =  Math . abs (  Gp ) ; else violation =  Math . abs (  Gn ) ;  Gmax_new =  Math . max (  Gmax_new , violation ) ;  Gnorm1_new += violation ; if (  Gp <  H * beta [ i ] ) d = -  Gp /  H ; else if (  Gn >  H * beta [ i ] ) d = -  Gn /  H ; else d = - beta [ i ] ; if (  Math . abs ( d ) < _ NUM ) continue ; double beta_old = beta [ i ] ; beta [ i ] =  Math . min (  Math . max ( beta [ i ] + d , - upper_bound [  GETI_ SVR ( i ) ] ) , upper_bound [  GETI_ SVR ( i ) ] ) ; d = beta [ i ] - beta_old ; if ( d != _ NUM ) { for (  Feature xi : prob . x [ i ] ) { w [ xi . get Index ( ) - _ NUM ] += d * xi . get Value ( ) ; } } } if ( iter == _ NUM )  Gnorm1_init =  Gnorm1_new ; iter ++ ; if ( iter % _ NUM == _ NUM ) info ( _ STR ) ; if (  Gnorm1_new <= eps *  Gnorm1_init ) { if ( active_size == l ) break ; else { active_size = l ; info ( _ STR ) ;  Gmax_old =  Double .  POSITIVE_ INFINITY ; continue ; } }  Gmax_old =  Gmax_new ; } info ( _ STR , iter ) ; if ( iter >= max_iter ) info ( _ STR ) ; double v = _ NUM ; int n SV = _ NUM ; for ( i = _ NUM ; i < w_size ; i ++ ) v += w [ i ] * w [ i ] ; v = _ NUM * v ; for ( i = _ NUM ; i < l ; i ++ ) { v += p *  Math . abs ( beta [ i ] ) - y [ i ] * beta [ i ] + _ NUM * lambda [  GETI_ SVR ( i ) ] * beta [ i ] * beta [ i ] ; if ( beta [ i ] != _ NUM ) n SV ++ ; } info ( _ STR , v ) ; info ( _ STR , n SV ) ; }
public boolean select ( int position ) {  View v = m All List . get ( position ) ; if ( m Multi Choice Adapter != null ) { perform Vibrate ( ) ; perform Select ( v , position , _ BOOL ) ; return _ BOOL ; } return _ BOOL ; }
@  Override public void ignorable Whitespace (  XMLString text ,  Augmentations augs ) throws  XNIException { if ( ! f Include Ignorable Whitespace || f Filter Reject ) { return ; } if ( ! f Defer Node Expansion ) {  Node child = f Current Node . get Last Child ( ) ; if ( child != null && child . get Node Type ( ) ==  Node .  TEXT_ NODE ) {  Text text Node = (  Text ) child ; text Node . append Data ( text . to String ( ) ) ; } else {  Text text Node = f Document . create Text Node ( text . to String ( ) ) ; if ( f Document Impl != null ) {  Text Impl text Node Impl = (  Text Impl ) text Node ; text Node Impl . set Ignorable Whitespace ( _ BOOL ) ; } f Current Node . append Child ( text Node ) ; } } else { int txt = f Deferred Document Impl . create Deferred Text Node ( text . to String ( ) , _ BOOL ) ; f Deferred Document Impl . append Child ( f Current Node Index , txt ) ; } }
private static final void wait For Editor To Be Active (  IEditor Part internal File Editor ,  IWorkbench Page page ) { long start =  System . current Time Millis ( ) ; long end = start ; do { end =  System . current Time Millis ( ) ; } while ( page . get Active Editor ( ) != internal File Editor && ( end - start ) < _ NUM ) ; if ( page . get Active Editor ( ) != internal File Editor ) logger . warn ( _ STR ) ; }
private  Solution largest Objective Value ( int objective ,  Population population ) {  Solution largest = null ; double value =  Double .  NEGATIVE_ INFINITY ; for (  Solution solution : population ) { if ( solution . get Objective ( objective ) > value ) { largest = solution ; value = solution . get Objective ( objective ) ; } } return largest ; }
public static int convert Latm To Y ( int latm ) { long v =  Math . round ( (  Mercator .  MAX_ Y -  Mercator . lat2y ( latm /  LATLON_ TO_ LATLONM ) ) *  MAX_ AP_ UNITS / (  Mercator .  MAX_ Y * _ NUM ) ) ; if ( v >  MAX_ AP_ UNITS ) return  MAX_ AP_ UNITS ; if ( v < _ NUM ) return - _ NUM ; return ( int ) v ; }
public void register Callback Handler (  SMSObject Listener change Listener ) throws  SMSException { object Listener = change Listener ; if ( ! notification Initialized ) {  String notification Flag =  System Properties . get (  NOTIFICATION_ PROPERTY , _ STR ) ; if ( notification Flag . equals Ignore Case ( _ STR ) ) { try {  URL url =  Webtop Naming . get Notification URL ( ) ;  PLLClient . add Notification Handler (  JAXRPCUtil .  SMS_ SERVICE , new  SMSNotification Handler ( ) ) ; client . send ( _ STR , url . to String ( ) , null , null ) ; if ( debug . message Enabled ( ) ) { debug . message ( _ STR + _ STR + url ) ; } } catch (  Exception e ) { if ( debug . warning Enabled ( ) ) { debug . warning ( _ STR + _ STR + e . get Message ( ) + _ STR ) ; } start Polling Thread If Enabled ( get Cache Polling Interval ( ) ) ; } } else { start Polling Thread If Enabled ( get Cache Polling Interval ( ) ) ; } notification Initialized = _ BOOL ; } }
protected double current Score Function ( ) { double score = _ NUM ; for ( int i = _ NUM ; i < this . values [ this . current Var1 ] . length ; i ++ ) { for ( int j = _ NUM ; j < this . values [ this . current Var2 ] . length ; j ++ ) { score -= this . current Counts [ this . current Var1 ] [ this . current Var2 ] [ i ] [ j ] *  Math . log ( this . current Pi [ i ] [ j ] ) ; } } return score ; }
public grammaticality Estimator (  Set  File Names , int i Min Char , int i Max Char , int i Char Window , int i Min Word , int i Max Word , int i Word Window ) { i Min Char NGram = i Min Char ; i Max Char NGram = i Max Char ; i Min Word NGram = i Min Word ; i Max Word NGram = i Max Word ; i Word Dist = i Word Window ; i Char Dist = i Char Window ;  Distro Docs = new  Tree Map <  Integer ,  Distribution Document > ( ) ;  Distro Word Docs = new  Tree Map <  Integer ,  Distribution Word Document > ( ) ;  String Buffer sb = new  String Buffer ( ) ;  Iterator i Texts =  File Names . iterator ( ) ; while ( i Texts . has Next ( ) ) {  String s File = (  String ) i Texts . next ( ) ; try {  Buffered Reader bf = new  Buffered Reader ( new  File Reader ( s File ) ) ;  String s Tmp ; while ( ( s Tmp = bf . read Line ( ) ) != null ) sb . append ( s Tmp ) ; bf . close ( ) ; } catch (  File Not Found Exception ex ) { ex . print Stack Trace (  System . err ) ; } catch (  IOException ex ) { ex . print Stack Trace (  System . err ) ; } sb . append ( ( char ) _ NUM ) ; }  Full Text Data String = sb . to String ( ) ; for ( int i Cnt = i Min Char NGram ; i Cnt <= i Max Char NGram ; i Cnt ++ ) {  Distro Docs . put ( i Cnt , new  Distribution Document ( i Char Dist , i Cnt ) ) ; } for ( int i Cnt = i Min Word NGram ; i Cnt <= i Max Word NGram ; i Cnt ++ ) {  Distro Word Docs . put ( i Cnt , new  Distribution Word Document ( i Word Dist , i Cnt ) ) ; } }
private int check Zone Link (  Spannable String Builder out ,  String in , int start ) { int pos = start + _ NUM ;  String Builder temp = new  String Builder ( ) ;  String target String = in . substring ( pos ,  Math . min ( in . length ( ) , pos + _ NUM ) ) ; boolean prev Is Dash = _ BOOL ; for ( int i = _ NUM ; i < target String . length ( ) ; i ++ ) { char c = target String . char At ( i ) ; if ( ( c >= _ STR && c <= _ STR ) || ( c >= _ STR && c <= _ STR ) ) { temp . append ( c ) ; prev Is Dash = _ BOOL ; } else if ( c == _ STR ) { if ( i == _ NUM ) { return - _ NUM ; } if ( prev Is Dash ) { temp . delete Char At ( temp . length ( ) - _ NUM ) ; break ; } temp . append ( c ) ; prev Is Dash = _ BOOL ; } else { if ( prev Is Dash ) { temp . delete Char At ( temp . length ( ) - _ NUM ) ; } break ; } }  String zone = temp . to String ( ) ; if ( zone . length ( ) < _ NUM || zone . equals Ignore Case ( _ STR ) ) { return - _ NUM ; } out . append ( zone ) ; return pos + zone . length ( ) - _ NUM ; }
public void check Next Poisson Consistency ( double mean ) { final int sample Size = _ NUM ; final int min Expected Count = _ NUM ; long max Observed Value = _ NUM ; final double alpha = _ NUM ;  Unit Test Utils .  Frequency <  Long > frequency = new  Unit Test Utils .  Frequency <  Long > ( ) ; for ( int i = _ NUM ; i < sample Size ; i ++ ) { long value = random Data . next Poisson ( mean ) ; if ( value > max Observed Value ) { max Observed Value = value ; } frequency . add Value ( value ) ; }  Poisson Distribution poisson Distribution = new  Poisson Distribution ( mean ) ; int lower = _ NUM ; while ( poisson Distribution . cumulative Probability ( lower - _ NUM ) * sample Size < min Expected Count ) { lower ++ ; } int upper = ( int ) ( _ NUM * mean ) ; while ( ( _ NUM - poisson Distribution . cumulative Probability ( upper - _ NUM ) ) * sample Size < min Expected Count ) { upper -- ; } int bin Width = _ NUM ; boolean width Sufficient = _ BOOL ; double lower Bin Mass = _ NUM ; double upper Bin Mass = _ NUM ; while ( ! width Sufficient ) { bin Width ++ ; lower Bin Mass = poisson Distribution . probability ( lower - _ NUM , lower + bin Width - _ NUM ) ; upper Bin Mass = poisson Distribution . probability ( upper - bin Width - _ NUM , upper - _ NUM ) ; width Sufficient =  Fast Math . min ( lower Bin Mass , upper Bin Mass ) * sample Size >= min Expected Count ; }  List <  Integer > bin Bounds = new  Array List <  Integer > ( ) ; bin Bounds . add ( lower ) ; int bound = lower + bin Width ; while ( bound < upper - bin Width ) { bin Bounds . add ( bound ) ; bound += bin Width ; } bin Bounds . add ( upper ) ; final int bin Count = bin Bounds . size ( ) + _ NUM ; long [ ] observed = new long [ bin Count ] ; double [ ] expected = new double [ bin Count ] ; observed [ _ NUM ] = _ NUM ; for ( int i = _ NUM ; i < lower ; i ++ ) { observed [ _ NUM ] += frequency . get Count ( ( long ) i ) ; } expected [ _ NUM ] = poisson Distribution . cumulative Probability ( lower - _ NUM ) * sample Size ; observed [ bin Count - _ NUM ] = _ NUM ; for ( int i = upper ; i <= max Observed Value ; i ++ ) { observed [ bin Count - _ NUM ] += frequency . get Count ( ( long ) i ) ; } expected [ bin Count - _ NUM ] = ( _ NUM - poisson Distribution . cumulative Probability ( upper - _ NUM ) ) * sample Size ; for ( int i = _ NUM ; i < bin Count - _ NUM ; i ++ ) { observed [ i ] = _ NUM ; for ( int j = bin Bounds . get ( i - _ NUM ) ; j < bin Bounds . get ( i ) ; j ++ ) { observed [ i ] += frequency . get Count ( ( long ) j ) ; } expected [ i ] = ( poisson Distribution . cumulative Probability ( bin Bounds . get ( i ) - _ NUM ) - poisson Distribution . cumulative Probability ( bin Bounds . get ( i - _ NUM ) - _ NUM ) ) * sample Size ; } if (  Unit Test Utils . chi Square Test ( expected , observed ) < alpha ) {  String Builder msg Buffer = new  String Builder ( ) ;  Decimal Format df = new  Decimal Format ( _ STR ) ; msg Buffer . append ( _ STR ) ; msg Buffer . append ( mean ) ; msg Buffer . append ( _ STR ) ; msg Buffer . append (  Unit Test Utils . chi Square Test ( expected , observed ) ) ; msg Buffer . append ( _ STR ) ; msg Buffer . append (  Unit Test Utils . chi Square ( expected , observed ) ) ; msg Buffer . append ( _ STR ) ; msg Buffer . append ( _ STR ) ; for ( int i = _ NUM ; i < expected . length ; i ++ ) { msg Buffer . append ( _ STR ) ; msg Buffer . append ( i == _ NUM ? _ NUM : bin Bounds . get ( i - _ NUM ) ) ; msg Buffer . append ( _ STR ) ; msg Buffer . append ( i == bin Bounds . size ( ) ? _ STR : bin Bounds . get ( i ) ) ; msg Buffer . append ( _ STR ) ; msg Buffer . append ( _ STR ) ; msg Buffer . append ( df . format ( expected [ i ] ) ) ; msg Buffer . append ( _ STR ) ; msg Buffer . append ( observed [ i ] ) ; msg Buffer . append ( _ STR ) ; } msg Buffer . append ( _ STR ) ; msg Buffer . append ( alpha ) ; msg Buffer . append ( _ STR ) ;  Assert . fail ( msg Buffer . to String ( ) ) ; } }
public static void check Valid ( double [ ] x ) { for ( double v : x ) { if (  Double . is Na N ( v ) ) { throw new  Runtime Exception ( _ STR + v ) ; } } }
protected void process Connection Event (  Connection Event event ) { for (  Enumeration <  Connection Listener > e = connection Listeners . elements ( ) ; e . has More Elements ( ) ; ) {  Connection Listener l = e . next Element ( ) ; switch ( event . get Type ( ) ) { case  Connection Event .  CONNECTED : l . connected ( (  Connected Event ) event ) ; break ; case  Connection Event .  DISCONNECTED : l . disconnected ( (  Disconnected Event ) event ) ; break ; case  Connection Event .  PACKET_ RECEIVED : l . packet Received ( (  Packet Received Event ) event ) ; break ; } } }
public double percentage (  Constant Range range ) {  Sorted Set <  Constant > sorted = values ( ) ;  Sorted Set <  Constant > contained = new  Tree Set <  Constant > ( ) ;  Constant prev = null ; for (  Constant pct : sorted ) { if ( range . contains ( pct ) ) contained . add ( pct ) ; else if ( contained . is Empty ( ) ) prev = pct ; } if ( contained . size ( ) == _ NUM ) return _ NUM ; double prev Percent = prev == null ? _ NUM : pcts . get ( prev ) ; return pcts . get ( contained . last ( ) ) - prev Percent ; }
public static void close Quiet ( @  Nullable  Closeable closeable ) { if ( closeable != null ) { try { closeable . close ( ) ; } catch (  IOException ignored ) { } } }
@  Override public void release Lucee Page Context (  Page Context pc , boolean register ) { if ( pc . get Id ( ) < _ NUM ) return ; pc . release ( ) ;  Thread Local Page Context . release ( ) ; running Pcs . remove (  Integer . value Of ( pc . get Id ( ) ) ) ; if ( pcs . size ( ) < _ NUM && pc . get Request Timeout Exception ( ) == null ) pcs . push ( pc ) ; }
private static byte [ ] string To Byte Array (  String str ) { if ( str == null ) { return null ; } byte [ ] src Byte = str . get Bytes ( ) ; int src Length = src Byte . length ; byte [ ] result = new byte [ src Length + _ NUM ] ;  System . arraycopy ( src Byte , _ NUM , result , _ NUM , src Length ) ; result [ src Length ] = _ NUM ; return result ; }
public static  Properties load Properties (  Class Loader class Loader ,  String classpath Resource ) { return load Properties ( null , classpath Resource ) ; }
@  Override public boolean equals (  Object o ) { if ( o instanceof  Graph ) { return string . equals ( o . to String ( ) ) ; } return _ BOOL ; }
public final static  Name Value Pair parse Name Value Pair ( final  String value ,  Header Value Parser parser ) throws  Parse Exception { if ( value == null ) { throw new  Illegal Argument Exception ( _ STR ) ; } if ( parser == null ) parser =  Save Header Value Parser .  DEFAULT ;  Char Array Buffer buffer = new  Char Array Buffer ( value . length ( ) ) ; buffer . append ( value ) ;  Save Parser Cursor cursor = new  Save Parser Cursor ( _ NUM , value . length ( ) ) ; return parser . parse Name Value Pair ( buffer , cursor ) ; }
private static  Mapping Object  Object At (  PCal Location loc ,  Mapping Object [ ] [ ] map ) { return map [ loc . get Line ( ) ] [ loc . get Column ( ) ] ; }
public  String parse (  File file ,  JSON m ) { try {  Template template = get Template ( file ) ; if ( template != null ) {  String Writer w = new  String Writer ( ) ;  Buffered Writer writer = new  Buffered Writer ( w ) ; template . merge ( new  Velocity Context ( m ) , writer ) ; writer . flush ( ) ; writer . close ( ) ; return w . to String ( ) ; } } catch (  Exception e ) { log . error ( e . get Message ( ) , e ) ; } return null ; }
public  Repository (  String domain , boolean fair Lock ) { lock = new  Reentrant Read Write Lock ( fair Lock ) ; domain Tb = new  Hash Map <  String ,  Map <  String ,  Named Object > > ( _ NUM ) ; if ( domain != null && domain . length ( ) != _ NUM ) this . domain = domain . intern ( ) ; else this . domain =  Service Name .  DOMAIN ; domain Tb . put ( this . domain , new  Hash Map <  String ,  Named Object > ( ) ) ; }
public static synchronized void index Document (  Code Index Document code Index Document ) throws  IOException {  Queue <  Code Index Document > queue = new  Concurrent Linked Queue < > ( ) ; queue . add ( code Index Document ) ; index Documents ( queue ) ; queue = null ; }
private void update Volume Labels (  Volume trusted Src ,  Volume invalid Tgt ) {  Virtual Array invalid Tgt VA = db Client . query Object (  Virtual Array . class , invalid Tgt . get Virtual Array ( ) ) ;  String Builder new Label = new  String Builder ( ) ; new Label . append ( trusted Src . get Label ( ) ) ; new Label . append ( _ STR ) ; new Label . append ( invalid Tgt VA . get Label ( ) ) ; log . info ( _ STR + new Label . to String ( ) ) ; invalid Tgt . set Label ( new Label . to String ( ) ) ;  Named URI project URI = invalid Tgt . get Project ( ) ; project URI . set Name ( new Label . to String ( ) ) ; invalid Tgt . set Project ( project URI ) ;  Named URI tenant URI = invalid Tgt . get Tenant ( ) ; tenant URI . set Name ( new Label . to String ( ) ) ; invalid Tgt . set Tenant ( tenant URI ) ;  Volume tgt Vplex Volume =  VPlex Srdf Util . get Vplex Volume From Srdf Volume ( db Client , invalid Tgt ) ; if ( tgt Vplex Volume != null ) {  Volume src Vplex Volume =  VPlex Srdf Util . get Vplex Volume From Srdf Volume ( db Client , trusted Src ) ; if ( src Vplex Volume != null ) { new Label . set Length ( _ NUM ) ; new Label . append ( src Vplex Volume . get Label ( ) ) ; new Label . append ( _ STR ) ; new Label . append ( invalid Tgt VA . get Label ( ) ) ; log . info ( _ STR + new Label . to String ( ) ) ; tgt Vplex Volume . set Label ( new Label . to String ( ) ) ; project URI = tgt Vplex Volume . get Project ( ) ; project URI . set Name ( new Label . to String ( ) ) ; tgt Vplex Volume . set Project ( project URI ) ; tenant URI = tgt Vplex Volume . get Tenant ( ) ; tenant URI . set Name ( new Label . to String ( ) ) ; tgt Vplex Volume . set Tenant ( tenant URI ) ; db Client . update And Reindex Object ( tgt Vplex Volume ) ; } } }
protected void handle (  Exception exception ,  String title ,  String message ) {  Utils . handle Error ( get Shell ( ) , exception , title , message ) ; }
private void read Object (  Object Input Stream in ) throws  IOException ,  Class Not Found Exception { in . default Read Object ( ) ; i18n =  Environment . get I18n ( ) ; bean Context Child Support = new  Bean Context Child Support ( this ) ; }
private void paint Foreground Enabled (  Graphics2 D g , int width , int height ) {  Shape s = decode Arrow Path ( width , height ) ; g . set Paint ( enabled Color ) ; g . fill ( s ) ; }
public boolean allows Trailing Arguments ( ) { return allows Trailing Arguments ; }
private void evaluate Popup (  Mouse Event e ) { if ( e . is Popup Trigger ( ) ) {  JPopup Menu menu = create Bookmark Popup Menu ( ) ; if ( menu != null ) { menu . show ( this , e . get X ( ) , e . get Y ( ) ) ; } } }
private boolean remove Task (  Task t , int min ) { for ( int i = tasks . size ( ) ; -- i >= min ; ) { if ( tasks . get ( i ) == t ) { tasks . remove ( i ) ; if ( i < first Pending ) { first Pending -- ; for ( int j = threads . size ( ) ; -- j >= _ NUM ; ) {  Task Thread thread = threads . get ( j ) ; if ( thread . task == t ) { if ( thread !=  Thread . current Thread ( ) ) thread . interrupt ( ) ; break ; } } } return _ BOOL ; } } return _ BOOL ; }
protected void ensure Path Exists (  String path ) {  String [ ] paths = path . split ( _ STR ) ;  String Buffer spath = new  String Buffer ( _ STR ) ; for (  String temp : paths ) { if (  String Utils . is Blank ( temp ) ) { continue ; } spath . append ( temp ) ; ensure Exists ( spath . to String ( ) , null , acl ,  Create Mode .  PERSISTENT ) ; spath . append ( _ STR ) ; } }
public  Class < ? > load Class (  String name , boolean resolve ) throws  Class Not Found Exception { int i = name . last Index Of ( _ STR ) ; if ( i != - _ NUM ) {  Security Manager sm =  System . get Security Manager ( ) ; if ( sm != null ) { sm . check Package Access ( name . substring ( _ NUM , i ) ) ; } } if ( ucp . known To Not Exist ( name ) ) {  Class < ? > c = find Loaded Class ( name ) ; if ( c != null ) { if ( resolve ) { resolve Class ( c ) ; } return c ; } throw new  Class Not Found Exception ( name ) ; } return ( super . load Class ( name , resolve ) ) ; }
Rules (  Workspace workspace ) { this . root = workspace . get Root ( ) ; this . team Hook = workspace . get Team Hook ( ) ; }
public void add ( @  Non Null  T item ) { synchronized ( lock ) { if ( items == null ) { items = new  Array List < > ( ) ; } items . add ( item ) ; } if ( notify On Change ) { notify Item Inserted ( items . size ( ) ) ; } }
private void check Pending Custom Messages ( ) { if ( joining Nodes . is Empty ( ) && is Local Node Coordinator ( ) ) {  Tcp Discovery Custom Event Message msg ; while ( ( msg = pending Custom Msgs . poll ( ) ) != null ) { process Custom Message ( msg ) ; if ( msg . verified ( ) ) msg Hist . add ( msg ) ; } } }
protected int parse And Add Node (  Xml Resource Parser parser ,  Hash Map <  String ,  Tag Parser > tag Parser Map ,  Array List <  Long > screen Ids ) throws  Xml Pull Parser Exception ,  IOException { if (  TAG_ INCLUDE . equals ( parser . get Name ( ) ) ) { final int res Id = get Attribute Resource Value ( parser ,  ATTR_ WORKSPACE , _ NUM ) ; if ( res Id != _ NUM ) { return parse Layout ( res Id , screen Ids ) ; } else { return _ NUM ; } } m Values . clear ( ) ; parse Container And Screen ( parser , m Temp ) ; final long container = m Temp [ _ NUM ] ; final long screen Id = m Temp [ _ NUM ] ; m Values . put (  Favorites .  CONTAINER , container ) ; m Values . put (  Favorites .  SCREEN , screen Id ) ; m Values . put (  Favorites .  CELLX , convert To Distance From End ( get Attribute Value ( parser ,  ATTR_ X ) , m Column Count ) ) ; m Values . put (  Favorites .  CELLY , convert To Distance From End ( get Attribute Value ( parser ,  ATTR_ Y ) , m Row Count ) ) ;  Tag Parser tag Parser = tag Parser Map . get ( parser . get Name ( ) ) ; if ( tag Parser == null ) { if (  LOGD )  Log . d (  TAG , _ STR + parser . get Name ( ) ) ; return _ NUM ; } long new Element Id = tag Parser . parse And Add ( parser ) ; if ( new Element Id >= _ NUM ) { if ( ! screen Ids . contains ( screen Id ) && container ==  Favorites .  CONTAINER_ DESKTOP ) { screen Ids . add ( screen Id ) ; } return _ NUM ; } return _ NUM ; }
private float calculate Scramble Image Height Multiplier ( float multiplier ) { switch ( current Puzzle ) { case  Puzzle Utils .  TYPE_777 : case  Puzzle Utils .  TYPE_666 : case  Puzzle Utils .  TYPE_555 : case  Puzzle Utils .  TYPE_222 : case  Puzzle Utils .  TYPE_444 : case  Puzzle Utils .  TYPE_333 : return ( multiplier / _ NUM ) * _ NUM ; case  Puzzle Utils .  TYPE_ CLOCK : return multiplier / _ NUM ; case  Puzzle Utils .  TYPE_ MEGA : return ( multiplier / _ NUM ) ; case  Puzzle Utils .  TYPE_ PYRA : return ( float ) ( multiplier /  Math . sqrt ( _ NUM ) ) ; case  Puzzle Utils .  TYPE_ SKEWB : return ( multiplier / _ NUM ) * _ NUM ; case  Puzzle Utils .  TYPE_ SQUARE1 : return multiplier ; } return multiplier ; }
public void test Numeric Scalars ( ) throws  Exception {  Object Mapper m = new  Object Mapper ( ) ; m . enable Default Typing ( ) ; assert Equals ( _ STR , m . write Value As String ( new  Object [ ] {  Integer . value Of ( _ NUM ) } ) ) ; assert Equals ( _ STR , m . write Value As String ( new  Object [ ] {  Long . value Of ( _ NUM ) } ) ) ; assert Equals ( _ STR , m . write Value As String ( new  Object [ ] {  Double . value Of ( _ NUM ) } ) ) ; assert Equals ( _ STR , m . write Value As String ( new  Object [ ] {  Float . value Of ( _ NUM ) } ) ) ; }
protected void close Callbacks Except Listener ( ) { close Cache Callback ( get Cache Loader ( ) ) ; close Cache Callback ( get Cache Writer ( ) ) ; close Cache Callback ( get Eviction Controller ( ) ) ; }
private void populate Profiles ( final  Profile List profiles ) { profiles Combo Box . remove All Items ( ) ; for (  Profile p : profiles ) { profiles Combo Box . add Item ( p ) ; } final int count = profiles Combo Box . get Item Count ( ) ; if ( count != _ NUM ) { profiles Combo Box . set Selected Index ( count - _ NUM ) ; } }
private long check File Header (  Buffered File Data Input bfdi ) throws  Replicator Exception ,  Interrupted Exception { int magic = _ NUM ; short major = _ NUM ; short minor = _ NUM ; try { bfdi . wait Available (  HEADER_ LENGTH ,  HEADER_ WAIT_ MILLIS ) ; magic = bfdi . read Int ( ) ; major = bfdi . read Short ( ) ; minor = bfdi . read Short ( ) ; base Seqno = bfdi . read Long ( ) ; } catch (  IOException e ) { throw new  THLException ( _ STR + file . get Absolute Path ( ) , e ) ; } if ( magic !=  MAGIC_ NUMBER ) throw new  THLException ( _ STR + file . get Absolute Path ( ) + _ STR ) ; if ( major !=  MAJOR_ VERSION ) throw new  THLException ( _ STR + file . get Absolute Path ( ) + _ STR ) ; if ( minor !=  MINOR_ VERSION ) logger . warn ( _ STR + file . get Absolute Path ( ) + _ STR + major + _ STR + minor + _ STR +  MAJOR_ VERSION + _ STR +  MINOR_ VERSION ) ; return base Seqno ; }
public float real Absolute ( ) { return  Math . abs ( m Left ) ; }
private  Extremum Type extremum Type ( int n , double [ ] alpha_extreme ,  Hyper Bounding Box interval ) { if ( n == alpha_extreme . length - _ NUM ) { return extremum Type ; } double [ ] alpha_extreme_l = new double [ alpha_extreme . length ] ; double [ ] alpha_extreme_r = new double [ alpha_extreme . length ] ; double [ ] alpha_extreme_c = new double [ alpha_extreme . length ] ;  System . arraycopy ( alpha_extreme , _ NUM , alpha_extreme_l , _ NUM , alpha_extreme . length ) ;  System . arraycopy ( alpha_extreme , _ NUM , alpha_extreme_r , _ NUM , alpha_extreme . length ) ;  System . arraycopy ( alpha_extreme , _ NUM , alpha_extreme_c , _ NUM , alpha_extreme . length ) ; double [ ] centroid =  Spatial Util . centroid ( interval ) ; for ( int i = _ NUM ; i < n ; i ++ ) { alpha_extreme_l [ i ] = centroid [ i ] ; alpha_extreme_r [ i ] = centroid [ i ] ; alpha_extreme_c [ i ] = centroid [ i ] ; } double interval Length = interval . get Max ( n ) - interval . get Min ( n ) ; alpha_extreme_l [ n ] =  Math . random ( ) * interval Length + interval . get Min ( n ) ; alpha_extreme_r [ n ] =  Math . random ( ) * interval Length + interval . get Min ( n ) ; double f_c = function ( alpha_extreme_c ) ; double f_l = function ( alpha_extreme_l ) ; double f_r = function ( alpha_extreme_r ) ; if ( f_l < f_c ) { if ( f_r < f_c ||  Math . abs ( f_r - f_c ) <  DELTA ) { return  Extremum Type .  MAXIMUM ; } } if ( f_r < f_c ) { if ( f_l < f_c ||  Math . abs ( f_l - f_c ) <  DELTA ) { return  Extremum Type .  MAXIMUM ; } } if ( f_l > f_c ) { if ( f_r > f_c ||  Math . abs ( f_r - f_c ) <  DELTA ) { return  Extremum Type .  MINIMUM ; } } if ( f_r > f_c ) { if ( f_l > f_c ||  Math . abs ( f_l - f_c ) <  DELTA ) { return  Extremum Type .  MINIMUM ; } } if (  Math . abs ( f_l - f_c ) <  DELTA &&  Math . abs ( f_r - f_c ) <  DELTA ) { return  Extremum Type .  CONSTANT ; } throw new  Illegal Argument Exception ( _ STR + this + _ STR + _ STR + f_l + _ STR + _ STR + f_c + _ STR + _ STR + f_r + _ STR + _ STR + vec . to Array ( ) + _ STR + _ STR +  Format Util . format ( alpha_extreme_c ) + _ STR + _ STR +  Format Util . format ( alpha_extreme_l ) + _ STR + _ STR +  Format Util . format ( alpha_extreme_r ) + _ STR + _ STR + n ) ; }
public static  String map2 OID (  String alg Name ) { return alg2 Oid Map . get ( alg Name . to Upper Case (  Locale .  US ) ) ; }
@  Override public  Generator <  ICircle > construct (  String [ ] args ) { return new  Uniform Generator (  Double . value Of ( args [ _ NUM ] ) ) ; }
protected void process Mouse Event (  Mouse Event e ) { if ( my Inplace Component != null && (  Mouse Event .  MOUSE_ PRESSED == e . get ID ( ) ||  Mouse Event .  MOUSE_ RELEASED == e . get ID ( ) ) ) { finish Editing ( _ BOOL ) ; } super . process Mouse Event ( e ) ; }
protected boolean has All Tables ( ) throws  Couldnt Load Data Exception ,  Invalid Database Exception {  Navi Logger . info ( _ STR ) ; final int counter =  Postgre SQLHelpers . get Table Count ( get Connection ( ) ,  Lists . new Array List (  TABLES ) ) ; if ( counter == _ NUM ) { return _ BOOL ; } else if ( counter ==  TABLES . length ) { return _ BOOL ; } else { throw new  Invalid Database Exception (  String . format ( _ STR , counter ,  TABLES . length ) ) ; } }
public  List <  String > classify (  List <  List <  Feature > > features ) throws  Cleartk Processing Exception {  String [ ] [ ] feature String Array = to Strings ( features ) ;  Pipe pipe = transducer . get Input Pipe ( ) ;  Instance instance = new  Instance ( feature String Array , null , null , null ) ; instance = pipe . instance From ( instance ) ;  Sequence < ? > data = (  Sequence < ? > ) instance . get Data ( ) ;  Sequence < ? > untyped Sequence = transducer . transduce ( data ) ;  Sequence <  String > sequence =  Reflection Util . unchecked Cast ( untyped Sequence ) ;  List <  String > return Values = new  Array List <  String > ( ) ; for ( int i = _ NUM ; i < sequence . size ( ) ; i ++ ) {  String encoded Outcome = sequence . get ( i ) ; return Values . add ( outcome Encoder . decode ( encoded Outcome ) ) ; } return return Values ; }
public void on Bind Header View Holder (  Recycler View .  View Holder holder , int position ) { on Bind Header View Holder ( holder , position ,  Collections . empty List ( ) ) ; }
private void update Line List ( ) { if ( horizontal Line Radiobutton . is Selected ( ) ) { set Horizontal Line Selected ( ) ; } else { set Vertical Line Selected ( ) ; } update Button States ( ) ; }
public void rectangle ( double x , double y , double half Width , double half Height ) { if ( half Width < _ NUM ) throw new  Illegal Argument Exception ( _ STR ) ; if ( half Height < _ NUM ) throw new  Illegal Argument Exception ( _ STR ) ; double xs = scale X ( x ) ; double ys = scale Y ( y ) ; double ws = factor X ( _ NUM * half Width ) ; double hs = factor Y ( _ NUM * half Height ) ; if ( ws <= _ NUM && hs <= _ NUM ) pixel ( x , y ) ; else offscreen . draw ( new  Rectangle2 D .  Double ( xs - ws / _ NUM , ys - hs / _ NUM , ws , hs ) ) ; draw ( ) ; }
public void replace Split Element ( int a Index ,  Fragment a Split Element ) { splits . set ( a Index , a Split Element ) ; }
private void start Item List (  String Builder result ,  String root Id ) { result . append ( _ STR + _ STR + root Id + _ STR ) ; }
private static int num Initial Splits ( long num Records ) { final int max Splits = _ NUM ; final long records Per Split = _ NUM ; return ( int )  Math . min ( max Splits , num Records / records Per Split + _ NUM ) ; }
public void mouse Clicked (  Mouse Event e ) { if ( e . get Click Count ( ) > _ NUM ) {  System . gc ( ) ; } }
private static  String [ ] scan For Sources ( final  File source Dir , final  Set <  String > source Includes , final  Set <  String > source Excludes ) { final  Directory Scanner ds = new  Directory Scanner ( ) ; ds . set Follow Symlinks ( _ BOOL ) ; ds . set Basedir ( source Dir ) ; ds . set Includes ( source Includes . to Array ( new  String [ source Includes . size ( ) ] ) ) ; ds . set Excludes ( source Excludes . to Array ( new  String [ source Excludes . size ( ) ] ) ) ; ds . add Default Excludes ( ) ; try { ds . scan ( ) ; } catch (  Illegal State Exception e ) { return new  String [ _ NUM ] ; } return ds . get Included Files ( ) ; }
public boolean has Single Element ( ) { return m Selected Widgets . size ( ) == _ NUM ; }
public  Igfs Path (  URI uri ) {  A . not Null ( uri , _ STR ) ; path = normalize Path ( uri . get Path ( ) ) ; }
public int to Int (  Element el ,  String attribute Name ) { return  Caster . to Int Value ( el . get Attribute ( attribute Name ) ,  Integer .  MIN_ VALUE ) ; }
public void add Getters ( int assigned Property Number ,  String property Name ) { for (  Event Type type : known Types ) {  Event Property Getter getter = type . get Getter ( property Name ) ;  Variant Property Getter Row row = all Getters . get ( type ) ; if ( row == null ) { synchronized ( this ) { row = new  Variant Property Getter Row ( type , new  Event Property Getter [ assigned Property Number + _ NUM ] ) ; all Getters . put ( type , row ) ; } } row . add Getter ( assigned Property Number , getter ) ; } properties . add ( property Name ) ; }
protected void mark Used (  Entry entry ) { entry . last Used =  System . nano Time ( ) ; }
@  Override public  String execute ( ) { return  SUCCESS ; }
private void handle State Left (  Inet Address endpoint ,  String [ ] pieces ) { assert pieces . length >= _ NUM ;  Collection <  Token > tokens = get Tokens For ( endpoint ) ; if ( logger . is Debug Enabled ( ) ) logger . debug ( _ STR , endpoint , tokens ) ; excise ( tokens , endpoint , extract Expire Time ( pieces ) ) ; }
public static void register (  String algorithm URI ,  Class < ? extends  Signature Algorithm Spi > implementing Class ) throws  Algorithm Already Registered Exception ,  Class Not Found Exception ,  XMLSignature Exception {  Java Utils . check Register Permission ( ) ; if ( log . is Loggable ( java . util . logging .  Level .  FINE ) ) { log . log ( java . util . logging .  Level .  FINE , _ STR + algorithm URI + _ STR + implementing Class ) ; }  Class < ? extends  Signature Algorithm Spi > registered Class = algorithm Hash . get ( algorithm URI ) ; if ( registered Class != null ) {  Object ex Args [ ] = { algorithm URI , registered Class } ; throw new  Algorithm Already Registered Exception ( _ STR , ex Args ) ; } algorithm Hash . put ( algorithm URI , implementing Class ) ; }
@  Suppress Warnings ( _ STR ) public  Key Value Persistence Settings (  File settings File ) {  Input Stream in ; try { in = new  File Input Stream ( settings File ) ; } catch (  IOException e ) { throw new  Ignite Exception ( _ STR + settings File . get Absolute Path ( ) , e ) ; } init ( load Settings ( in ) ) ; }
public boolean contains Word Breaking Char ( final @  Non Null  Char Sequence input ) { if ( !  Text Utils . is Empty ( input ) ) { for ( int i = _ NUM ; i < input . length ( ) ; i ++ ) { char c = input . char At ( i ) ; if ( is Word Breaking Char ( c ) ) { return _ BOOL ; } } } return _ BOOL ; }
private void check Interior Intersections ( ) { for (  Iterator i = seg Strings . iterator ( ) ; i . has Next ( ) ; ) {  Segment String ss0 = (  Segment String ) i . next ( ) ; for (  Iterator j = seg Strings . iterator ( ) ; j . has Next ( ) ; ) {  Segment String ss1 = (  Segment String ) j . next ( ) ; check Interior Intersections ( ss0 , ss1 ) ; } } }
private <  T >  Unary Operator <  T > compose (  Unary Operator <  T > before ,  Unary Operator <  T > after ) { return null ; }
private void add Cdc Col Specs (  Array List <  Column Spec > cdc Specs ,  One Row Change cdc Row Change Data ) { int cdc Pos = cdc Specs . size ( ) ; if ( cdc Columns At Front ) cdc Pos = _ NUM ;  Column Spec spec = cdc Row Change Data . new  Column Spec ( ) ; spec . set Index ( cdc Pos + _ NUM ) ; spec . set Name ( _ STR ) ; spec . set Type ( java . sql .  Types .  VARCHAR ) ; spec . set Length ( _ NUM ) ; cdc Specs . add ( cdc Pos , spec ) ; spec = cdc Row Change Data . new  Column Spec ( ) ; spec . set Index ( cdc Pos + _ NUM + _ NUM ) ; spec . set Name ( _ STR ) ; spec . set Type ( java . sql .  Types .  TIMESTAMP ) ; cdc Specs . add ( cdc Pos + _ NUM , spec ) ; spec = cdc Row Change Data . new  Column Spec ( ) ; spec . set Index ( cdc Pos + _ NUM + _ NUM ) ; spec . set Name ( _ STR ) ; spec . set Type ( java . sql .  Types .  BIGINT ) ; cdc Specs . add ( cdc Pos + _ NUM , spec ) ; }
public static  String convert To Java Field Name (  String name ) { int dot Index = name . index Of ( _ STR ) ; if ( dot Index >= _ NUM ) { name = name . substring ( _ NUM , dot Index ) ; }  String [ ] split = name . split ( _ STR ) ;  String Builder out = new  String Builder ( ) ; boolean first = _ BOOL ; for (  String section : split ) { if ( first ) { first = _ BOOL ; out . append ( section ) ; } else { out . append (  String Util . capitalize ( section ) ) ; } } return out . to String ( ) ; }
protected void execute (  String [ ] sqls ,  SQLite Database db ) {  String throw SQL = _ STR ; try { if ( sqls != null ) { for (  String sql : sqls ) { throw SQL = sql ; db . exec SQL (  Base Utility . change Case ( sql ) ) ; } } } catch (  SQLException e ) { throw new  Database Generate Exception (  Database Generate Exception .  SQL_ ERROR + throw SQL ) ; } }
private void refresh Done Button ( boolean done ) { but Done . set Text ( done ?  Messages . get String ( _ STR ) :  Messages . get String ( _ STR ) ) ; }
private void create Migration Task Page ( ) {  Migration Task Editor migration Task Editor = new  Migration Task Editor ( migration Task , get Container ( ) ) ; int index = add Page ( migration Task Editor . get Control ( ) ) ; set Page Text ( index , _ STR ) ; task Listeners . add ( migration Task Editor ) ; }
private boolean has Next (  Pattern pattern ) { if ( ! has Next ( ) ) { return _ BOOL ; }  Matcher matcher = pattern . matcher ( gser Value . substring ( pos , length ) ) ; return matcher . find ( ) ; }
void push Int ( int i ) { switch ( i ) { case - _ NUM : mv . visit Insn (  ICONST_ M1 ) ; return ; case _ NUM : mv . visit Insn (  ICONST_0 ) ; return ; case _ NUM : mv . visit Insn (  ICONST_1 ) ; return ; case _ NUM : mv . visit Insn (  ICONST_2 ) ; return ; case _ NUM : mv . visit Insn (  ICONST_3 ) ; return ; case _ NUM : mv . visit Insn (  ICONST_4 ) ; return ; case _ NUM : mv . visit Insn (  ICONST_5 ) ; return ; } if ( i >=  Byte .  MIN_ VALUE && i <=  Byte .  MAX_ VALUE ) { mv . visit Int Insn (  BIPUSH , i ) ; return ; } if ( i >=  Short .  MIN_ VALUE && i <=  Short .  MAX_ VALUE ) { mv . visit Int Insn (  SIPUSH , i ) ; return ; } mv . visit Ldc Insn (  Integer . value Of ( i ) ) ; }
public static  String xml Node (  String name ,  String attributes ,  String content , boolean indent ) {  String start = attributes == null ? name : name + attributes ; if ( content == null ) { return _ STR + start + _ STR ; } if ( indent && content . index Of ( _ STR ) >= _ NUM ) { content = _ STR + indent ( content ) ; } return _ STR + start + _ STR + content + _ STR + name + _ STR ; }
public void add ( int position , @  Non Null  T item ) { synchronized ( lock ) { if ( items == null ) { items = new  Array List < > ( ) ; } items . add ( position , item ) ; } if ( notify On Change ) { notify Item Inserted ( position ) ; } }
public  List <  String > split String With Default Delimiter Escaped (  String input String ) {  String delimiter = configuration Helper . get Property (  Configuration Value .  FIELD_ DATA_ DELIMITER ) ;  String escape Char = configuration Helper . get Property (  Configuration Value .  FIELD_ DATA_ DELIMITER_ ESCAPE_ CHAR ) ;  List <  String > split String = new  Array List < > ( ) ; if (  String Utils . is Not Blank ( input String ) ) {  String regex = _ STR +  Pattern . quote ( escape Char ) + _ STR +  Pattern . quote ( delimiter ) ; for (  String s : input String . split ( regex ) ) { split String . add ( s . replace ( escape Char + delimiter , delimiter ) ) ; } } return split String ; }
protected final boolean read Available Blocking ( ) throws  IOException { char [ ] buffer = my Buffer ;  String Builder token = my Text Buffer ; token . set Length ( _ NUM ) ; boolean read = _ BOOL ; int n ; while ( ( n = my Reader . read ( buffer ) ) > _ NUM ) { if ( my Scheduled Submitter != null ) my Scheduled Submitter . cancel ( _ BOOL ) ; read = _ BOOL ; synchronized ( my Text Buffer ) { process Line ( buffer , token , n ) ; } my Scheduled Submitter = my Executor Service . submit ( my Token Submitter ) ; } submit Token ( ) ; return read ; }
public void delete Obligation ( final  Obligation obligation , int basic Block Id ) throws  Obligation Acquired Or Released In Loop Exception {  Map <  Obligation Set ,  State > updated State Map = new  Hash Map <  Obligation Set ,  State > ( ) ; for (  Iterator <  State > i = state Iterator ( ) ; i . has Next ( ) ; ) {  State state = i . next ( ) ; check Circularity ( state , obligation , basic Block Id ) ;  Obligation Set obligation Set = state . get Obligation Set ( ) ; obligation Set . remove ( obligation ) ; if ( ! obligation Set . is Empty ( ) ) { updated State Map . put ( obligation Set , state ) ; } } replace Map ( updated State Map ) ; }
public  Content Impl create Compound Package Content (  Ole Blob Impl blob ,  String pretty Name ,  String class Name ,  String type Name ,  Byte Buffer blob Bb , int data Block Len ) { return new  Compound Content Impl ( blob , pretty Name , class Name , type Name , blob Bb . position ( ) , data Block Len ) ; }
protected boolean check Coverage ( ) { int i ; int n ; int [ ] count ;  Range r ;  String attr Index ;  Subspace Cluster Definition cl ; count = new int [ get Num Attributes ( ) ] ; for ( i = _ NUM ; i < get Num Attributes ( ) ; i ++ ) { for ( n = _ NUM ; n < get Clusters ( ) . length ; n ++ ) { cl = (  Subspace Cluster Definition ) get Clusters ( ) [ n ] ; r = new  Range ( cl . get Attr Index Range ( ) ) ; r . set Upper ( get Num Attributes ( ) ) ; if ( r . is In Range ( i ) ) { count [ i ] ++ ; } } } attr Index = _ STR ; for ( i = _ NUM ; i < count . length ; i ++ ) { if ( count [ i ] == _ NUM ) { if ( attr Index . length ( ) != _ NUM ) { attr Index += _ STR ; } attr Index += ( i + _ NUM ) ; } } if ( attr Index . length ( ) != _ NUM ) { throw new  Illegal Argument Exception ( _ STR + _ STR + attr Index + _ STR ) ; } return _ BOOL ; }
private  Set <  Integer > find Values (  String string ) {  Set <  Integer > results = new  Tree Set <  Integer > ( ) ; for (  String str : string . split ( _ STR ) ) { if ( ! str . equals ( _ STR ) ) { results . add ( find Value ( str ) ) ; } } return results ; }
@  Deprecated public void append ( final  String name , final  String value ) {  List <  String > l = map . get ( name ) ; if ( l != null ) { l . add ( value ) ; } else { l =  Lists . new Array List ( value ) ; map . put ( name , l ) ; } }
public  Statement between (  Object former ,  Object later ) { statement . append ( _ STR ) ; append ( former ) ; statement . append ( _ STR ) ; append ( later ) ; return this ; }
public byte [ ] encode1 ( final  String s ) { final  Byte Array Buffer tmp = new  Byte Array Buffer ( s . length ( ) ) ; final int nwritten = uc . encode ( s , tmp ) ; final int npack =  Long Packer . get Byte Length ( nwritten ) ; final byte [ ] a = new byte [ npack + nwritten ] ; final  Data Output Buffer dob = new  Data Output Buffer ( _ NUM , a ) ; try { dob . pack Long ( nwritten ) ; dob . append ( tmp . array ( ) , _ NUM , tmp . pos ( ) ) ; return a ; } finally { try { dob . close ( ) ; } catch (  IOException e ) { throw new  Runtime Exception ( e ) ; } } }
public static  Map <  Object ,  Long > value Histogram (  Geo Time Serie gts ) {  Map <  Object ,  Long > occurrences = new  Hash Map <  Object ,  Long > ( ) ; for ( int i = _ NUM ; i < gts . values ; i ++ ) {  Object value =  GTSHelper . value At Index ( gts , i ) ; if ( ! occurrences . contains Key ( value ) ) { occurrences . put ( value , _ NUM ) ; } else { occurrences . put ( value , _ NUM + occurrences . get ( value ) ) ; } } if (  GTSHelper . is Bucketized ( gts ) && gts . bucketcount != gts . values ) { occurrences . put ( null , ( long ) ( gts . bucketcount - gts . values ) ) ; } return occurrences ; }
public  Query String Query Builder field (  String field ) { if ( fields == null ) { fields = new  Array List < > ( ) ; } fields . add ( field ) ; return this ; }
public static <  R ,  A ,  B >  Completion Stage <  R > combine (  Completion Stage <  A > a ,  Completion Stage <  B > b ,  Bi Function <  A ,  B ,  R > function ) { return a . then Combine ( b , function ) ; }
protected  String build Create Schema Statement ( ) throws  Replicator Exception { return null ; }
public void test Neg Pos First Shorter ( ) { byte a Bytes [ ] = { - _ NUM , - _ NUM , - _ NUM , - _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM } ; byte b Bytes [ ] = { - _ NUM , _ NUM , _ NUM , _ NUM , - _ NUM , - _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , - _ NUM , _ NUM , _ NUM , - _ NUM , _ NUM , _ NUM , - _ NUM , - _ NUM } ; int a Sign = - _ NUM ; int b Sign = _ NUM ; byte r Bytes [ ] = { _ NUM , - _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , - _ NUM , _ NUM , _ NUM , - _ NUM , _ NUM , _ NUM , - _ NUM , - _ NUM } ;  Big Integer a Number = new  Big Integer ( a Sign , a Bytes ) ;  Big Integer b Number = new  Big Integer ( b Sign , b Bytes ) ;  Big Integer result = a Number . and ( b Number ) ; byte res Bytes [ ] = new byte [ r Bytes . length ] ; res Bytes = result . to Byte Array ( ) ; for ( int i = _ NUM ; i < res Bytes . length ; i ++ ) { assert True ( res Bytes [ i ] == r Bytes [ i ] ) ; } assert Equals ( _ STR , _ NUM , result . signum ( ) ) ; }
public  Stream Info Manager (  Twitch Api api ,  Stream Info Listener listener ) { this . listener = listener ; this . api = api ; pending Requests = new  Hash Map < > ( ) ; invalid Stream Info = new  Stream Info ( _ STR , listener ) ; invalid Stream Info . set Requested ( ) ; }
public  Sentence as Sentence ( ) { return  Sentence . new Conjunction ( sentences ) ; }
public boolean is Pronoun ( ) { return type String . contains (  SUFFIX_ PRONOUN ) ; }
protected void append Short Type (  String Builder sb ,  Field Type field Type , int field Width ) { sb . append ( _ STR ) ; }
public static  Vector tokenize String (  String source ,  String separator ) { if ( separator . length ( ) == _ NUM ) { return tokenize String ( source , separator . char At ( _ NUM ) ) ; }  Vector tokenized = new  Vector ( ) ; int len = source . length ( ) ;  String Builder buf = new  String Builder ( ) ; for ( int iter = _ NUM ; iter < len ; iter ++ ) { char current = source . char At ( iter ) ; if ( separator . index Of ( current ) > - _ NUM ) { if ( buf . length ( ) > _ NUM ) { tokenized . add Element ( buf . to String ( ) ) ; buf = new  String Builder ( ) ; } } else { buf . append ( current ) ; } } if ( buf . length ( ) > _ NUM ) { tokenized . add Element ( buf . to String ( ) ) ; } return tokenized ; }
private void backup Favorites (  Backup Data Output data ) throws  IOException {  Content Resolver cr = m Context . get Content Resolver ( ) ;  Cursor cursor = cr . query (  Favorites .  CONTENT_ URI ,  FAVORITE_ PROJECTION , get User Selection Arg ( ) , null , null ) ; try { cursor . move To Position ( - _ NUM ) ; while ( cursor . move To Next ( ) ) { final long id = cursor . get Long (  ID_ INDEX ) ; final long update Time = cursor . get Long (  ID_ MODIFIED ) ;  Key key = get Key (  Key .  FAVORITE , id ) ; m Keys . add ( key ) ; final  String backup Key = key To Backup Key ( key ) ; if ( ! m Existing Keys . contains ( backup Key ) || update Time >= m Last Backup Restore Time ) { write Row To Backup ( key , pack Favorite ( cursor ) , data ) ; } else { if (  DEBUG )  Log . d (  TAG , _ STR + id ) ; } } } finally { cursor . close ( ) ; } }
public void update ( ) { if ( last Time != - _ NUM ) { long delta =  System . nano Time ( ) - last Time ; rolling Average . add Value ( delta ) ; } last Time =  System . nano Time ( ) ; }
public  List <  Validation Error Message > validate ( ) { error Message Ids . clear ( ) ; if ( payment Product == null ) { throw new  Null Pointer Exception ( _ STR ) ; } for (  Payment Product Field field : payment Product . get Payment Product Fields ( ) ) { if ( ! is Field In Account On File And Not Altered ( field ) ) { error Message Ids . add All ( field . validate Value ( get Value ( field . get Id ( ) ) ) ) ; } } return error Message Ids ; }
Key Store State ( ) { }
Crypto Result ( final  T result , final  List <  K > master Keys , final  Ciphertext Headers headers ) { result_ = result ; master Keys_ =  Collections . unmodifiable List ( master Keys ) ; headers_ = headers ; encryption Context_ = headers_ . get Encryption Context Map ( ) ; }
public void state Changed (  Change Event e ) { if ( ignore Update ) { return ; } double value = ( double ) ( _ NUM - setpoint Slider . get Value ( ) ) / _ NUM ; set Set Point ( value ) ; sim . set Set Point ( value ) ; }
public static  String [ ] parse Delimited List (  String list , char delimiter ) {  String delim = _ STR + delimiter ;  String Tokenizer st = new  String Tokenizer ( list + delim + _ STR , delim , _ BOOL ) ;  Array List <  String > v = new  Array List <  String > ( ) ;  String last Token = _ STR ;  String word = _ STR ; while ( st . has More Tokens ( ) ) {  String tok = st . next Token ( ) ; if ( last Token != null ) { if ( tok . equals ( delim ) ) { word = word + last Token ; if ( last Token . equals ( delim ) ) tok = null ; } else { if ( ! word . equals ( _ STR ) ) v . add ( word ) ; word = _ STR ; } } last Token = tok ; } return v . to Array ( new  String [ _ NUM ] ) ; }
private void initialize Layout ( ) {  Grid Layout gl = new  Grid Layout ( _ NUM , _ NUM ) ; gl . set Vgap ( _ NUM ) ; set Layout ( gl ) ; add ( new  JLabel ( _ STR ) ) ; add ( frozen DD ) ; add ( new  JLabel ( _ STR ) ) ; add ( tf Up Bound ) ; add ( new  JLabel ( _ STR ) ) ; add ( tf Low Bound ) ; add ( new  JLabel ( _ STR ) ) ; add ( tf Increment ) ; add ( new  JLabel ( _ STR ) ) ; add ( tf Delay ) ; set Border (  Border Factory . create Empty Border ( _ NUM , _ NUM , _ NUM , _ NUM ) ) ; }
@  Override public boolean is Running ( ) { return ( frame != null && frame . is Visible ( ) ) ; }
public static  Mosaic Definition create Mosaic Definition ( final  Account creator ) { return create Mosaic Definition ( creator ,  Utils . create Mosaic Id ( _ STR , _ STR ) , create Mosaic Properties ( ) ) ; }
public  Result result (  Sql Node node ,  Collection <  Clause > clauses ,  Rel Node rel ) { final  String alias2 =  Sql Validator Util . get Alias ( node , - _ NUM ) ; final  String alias3 = alias2 != null ? alias2 : _ STR ; final  String alias4 =  Sql Validator Util . uniquify ( alias3 , alias Set ,  Sql Validator Util .  EXPR_ SUGGESTER ) ; final  String alias5 = alias2 == null || ! alias2 . equals ( alias4 ) ? alias4 : null ; return new  Result ( node , clauses , alias5 ,  Collections . singleton List (  Pair . of ( alias4 , rel . get Row Type ( ) ) ) ) ; }
private static void _trust All Https Certificates ( ) {  SSLContext context ; if ( _trust Managers == null ) { _trust Managers = new  Trust Manager [ ] { new  Fake X509 Trust Manager ( ) } ; } try { context =  SSLContext . get Instance ( _ STR ) ; context . init ( null , _trust Managers , new  Secure Random ( ) ) ; } catch (  General Security Exception gse ) { throw new  Illegal State Exception ( gse . get Message ( ) ) ; }  Https URLConnection . set Default SSLSocket Factory ( context . get Socket Factory ( ) ) ; }
private static boolean is In Need Of Form (  UIComponent component ) { return ( component instanceof  Action Source || component instanceof  Action Source2 || component instanceof  Editable Value Holder ) ; }
private void add Internal Listeners ( ) { cb Distribution . add Item Listener ( cb Item Listener ) ; }
public static long run Multi Threaded (  Iterable <  Callable < ? > > calls ,  Grid Test Safe Thread Factory thread Factory ) throws  Exception { if ( ! busy Lock . enter Busy ( ) ) throw new  Illegal State Exception ( _ STR ) ;  Collection <  Thread > threads = new  Array List < > ( ) ; long time ; try { for (  Callable < ? > call : calls ) threads . add ( thread Factory . new Thread ( call ) ) ; time =  System . current Time Millis ( ) ; for (  Thread t : threads ) t . start ( ) ; } finally { busy Lock . leave Busy ( ) ; } for (  Thread t : threads ) t . join ( ) ; time =  System . current Time Millis ( ) - time ; thread Factory . check Error ( ) ; return time ; }
private void bappend ( char ch ) { try { m Buff [ ++ m Buff Idx ] = ch ; } catch (  Exception exp ) { char buff [ ] = new char [ m Buff . length << _ NUM ] ;  System . arraycopy ( m Buff , _ NUM , buff , _ NUM , m Buff . length ) ; m Buff = buff ; m Buff [ m Buff Idx ] = ch ; } }
public void initialize Owner References For Field (  State Manager sm ,  Field Meta Data fmd ) { if ( fmd . get Association Type ( ) ==  Field Meta Data .  ONE_ TO_ MANY ) {  Collection < ? > collection = (  Collection < ? > ) sm . fetch ( fmd . get Index ( ) ) ; if ( collection != null ) { for (  Object item : collection ) { if ( item != null ) { _relations Manager . set Owner State Manager For Persistent Instance ( item , sm , fmd ) ; } } } } else if ( fmd . get Association Type ( ) ==  Field Meta Data .  ONE_ TO_ ONE || fmd . is Embedded PC ( ) ) {  Object value = sm . fetch ( fmd . get Index ( ) ) ; if ( value != null ) { _relations Manager . set Owner State Manager For Persistent Instance ( value , sm , fmd ) ; } } }
public  Node (  Coordinate pt ) { this ( pt , new  Directed Edge Star ( ) ) ; }
public synchronized void increase ( ) { if ( accuracy > _ NUM ) { long time Passed =  System . current Time Millis ( ) - last Added ; if ( time Passed > accuracy ) { clear Up ( ) ; if ( count > _ NUM ) { data . add First ( last Added + accuracy ) ; } last Added =  System . current Time Millis ( ) ; count = _ NUM ; } count ++ ; } else { clear Up ( ) ; data . add First (  System . current Time Millis ( ) ) ; } }
public void revert ( final  Virtual File root , final  List <  File Path > files ) throws  Vcs Exception { for (  List <  String > paths :  Vcs File Util . chunk Paths ( root , files ) ) {  Git Simple Handler handler = new  Git Simple Handler ( my Project , root ,  Git Command .  CHECKOUT ) ; handler . add Parameters ( _ STR ) ; handler . end Options ( ) ; handler . add Parameters ( paths ) ; handler . run ( ) ; } }
public  Tagged Value Iterator ( final  String a Line , final boolean attempt First Word , final  String ... tags ) { this . a Line = a Line ; this . attempt First Word = attempt First Word ; this . tags = tags ; tag Pos = _ NUM ; next Result = get Next Result ( ) ; if ( attempt First Word ) { int a = _ NUM ; while ( a < a Line . length ( ) ) { if ( a Line . char At ( a ) == _ STR || a Line . char At ( a ) == _ STR ||  Character . is Whitespace ( a Line . char At ( a ) ) ) a ++ ; else break ; } int b = a + _ NUM ; while ( b < a Line . length ( ) ) { if (  Character . is Letter Or Digit ( a Line . char At ( b ) ) || a Line . char At ( b ) == _ STR ) b ++ ; else break ; } if ( b - a > _ NUM ) { next Result = a Line . substring ( a , b ) ; } tag Pos = b ; } }
public void ascend Tree ( ) { if ( null != parent Path ) { parent Path . append (  PARENT_ PATH ) ; return ; }  File parent Tree = calc Parent Tree ( ) ; if ( null != parent Tree ) { tree File = parent Tree ; return ; } parent Path = new  String Builder ( provide Last Name ( ) ) ; parent Path . append (  PARENT_ PATH ) ; }
public boolean can Read ( ) { return _is != null ; }
void on Item Dismissed ( final int position ) { final  T removed = m Data . get ( position ) ; final boolean was Removed = remove ( position ) ; if ( was Removed && m Data Change Listener != null ) { m Data Change Listener . on Item Removed ( removed , position ) ; } }
public static double normal PDF ( double x , double variance , double mean Value ) { double standard Deviation =  Math . sqrt ( variance ) ; return ( _ NUM / ( standard Deviation *  Math . sqrt ( _ NUM *  Math .  PI ) ) ) *  Math . pow (  Math .  E , - ( ( x - mean Value ) * ( x - mean Value ) ) / ( _ NUM * variance ) ) ; }
private void clear Registers (  Instruction start ,  Instruction end ) { for (  Instruction p = start ; ; p = p . next Instruction In Code Order ( ) ) { for (  Enumeration <  Operand > ops = p . get Operands ( ) ; ops . has More Elements ( ) ; ) {  Operand op = ops . next Element ( ) ; if ( op instanceof  Register Operand ) {  Register Operand r Op = (  Register Operand ) op ; clear Dep Graph Node For Register ( r Op . get Register ( ) ) ; } } if ( p == end ) break ; } for (  Enumeration <  Register > e =  Generic Physical Def Use . enumerate All Implicit Def Uses ( ir ) ; e . has More Elements ( ) ; ) {  Register r = e . next Element ( ) ; clear Dep Graph Node For Register ( r ) ; } }
public void fire Annotation Selected (  Workflow Annotation anno ) {  List <  Workflow Annotation > list = new  Linked List < > ( ) ; list . add ( anno ) ; fire Annotations Changed (  Annotation Event .  SELECTED_ ANNOTATION_ CHANGED , list ) ; }
public boolean update Stats And Return If Allowed ( ) { long now =  System Clock . elapsed Realtime ( ) ; long delta Ms = now - m Last Request Timestamp ; if ( delta Ms < m Delay Ms ) return _ BOOL ; m Last Request Timestamp = now ; if ( delta Ms < _ NUM * m Delay Ms ) { m Delay Ms =  Math . min (  MAX_ DELAY , m Delay Ms * _ NUM ) ; } else { m Delay Ms =  MIN_ DELAY ; } return _ BOOL ; }
public boolean verify Server Evidence Message (  Big Integer server M2 ) throws  Crypto Exception { if ( ( this .  A == null ) || ( this .  M1 == null ) || ( this .  S == null ) ) { throw new  Crypto Exception ( _ STR + _ STR ) ; }  Big Integer computed M2 =  SRP6 Util . calculate M2 ( digest ,  N ,  A ,  M1 ,  S ) ; if ( computed M2 . equals ( server M2 ) ) { this .  M2 = server M2 ; return _ BOOL ; } return _ BOOL ; }
public void handle Text (  String text ) { if ( skipping Characters > _ NUM ) { if ( skipping Characters >= text . length ( ) ) { skipping Characters -= text . length ( ) ; return ; } else { text = text . substring ( skipping Characters ) ; skipping Characters = _ NUM ; } } if ( rtf Destination != null ) { rtf Destination . handle Text ( text ) ; return ; } warning ( _ STR ) ; }
public final boolean remove ( final  URI service URI ) { boolean modified = _ BOOL ; synchronized ( this ) { if ( aliases . remove ( service URI ) != null ) { modified = _ BOOL ; } final  Service Factory factory = services . remove ( service URI ) ; if ( factory != null ) { modified = _ BOOL ; if ( factory instanceof  Custom Service Factory ) { custom Services . remove ( factory ) ; } } } return modified ; }
@  Nullable private static  String reference To Attribute (  String attrib , boolean include Dummies ) { while ( attrib . starts With ( _ STR ) ) { attrib = attrib . substring ( _ NUM ) ; } if ( attrib . starts With ( _ STR ) ) { if ( include Dummies ) { attrib = attrib . substring ( _ NUM ) ; } else return null ; } if ( !  String Util . starts With Char ( attrib , _ STR ) ) { return null ; } attrib = attrib . substring ( _ NUM ) ; if (  String Util . starts With Char ( attrib , _ STR ) ) {  String clean Attribute = null ; for ( int i = _ NUM ; i < attrib . length ( ) ; i ++ ) { char curr Char = attrib . char At ( i ) ; if ( curr Char == _ STR || curr Char == _ STR ) { clean Attribute = null ; break ; } else if ( curr Char == _ STR ) { clean Attribute = attrib . substring ( _ NUM , i ) ; break ; } } attrib = clean Attribute ; } else { for ( int i = _ NUM ; i < attrib . length ( ) ; i ++ ) { char curr Char = attrib . char At ( i ) ; if ( curr Char == _ STR || curr Char == _ STR || curr Char == _ STR ) { attrib = attrib . substring ( _ NUM , i ) ; break ; } } } return attrib ; }
public void record (  Record Builder Impl record Builder ) { store Bitmap ( record Builder ) ;  Output Stream view Hierarchy Dump = null ; try { view Hierarchy Dump = m Album . open View Hierarchy File ( record Builder . get Name ( ) ) ; m View Hierarchy . deflate ( record Builder . get View ( ) , view Hierarchy Dump ) ; m Album . add Record ( record Builder ) ; } catch (  IOException e ) { throw new  Runtime Exception ( e ) ; } finally { if ( view Hierarchy Dump != null ) { try { view Hierarchy Dump . close ( ) ; } catch (  IOException e ) {  Log . e ( _ STR , _ STR , e ) ; } } } }
protected boolean is Correct Method (  Method method ,  Object [ ] args ) { return ( proxy Signature . equals ( method . get Name ( ) ) && args . length == _ NUM ) ; }
public void test Case17 ( ) { byte a Bytes [ ] = { - _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , - _ NUM , _ NUM , - _ NUM , _ NUM , _ NUM } ; byte b Bytes [ ] = { _ NUM , - _ NUM , _ NUM , _ NUM , _ NUM } ; int a Sign = _ NUM ; int b Sign = _ NUM ; byte r Bytes [ ] = { _ NUM , - _ NUM , _ NUM , _ NUM , _ NUM } ;  Big Integer a Number = new  Big Integer ( a Sign , a Bytes ) ;  Big Integer b Number = new  Big Integer ( b Sign , b Bytes ) ;  Big Integer result = a Number . remainder ( b Number ) ; byte res Bytes [ ] = new byte [ r Bytes . length ] ; res Bytes = result . to Byte Array ( ) ; for ( int i = _ NUM ; i < res Bytes . length ; i ++ ) { assert True ( res Bytes [ i ] == r Bytes [ i ] ) ; } assert Equals ( _ STR , _ NUM , result . signum ( ) ) ; }
public  Metadata .  Property .  Builder clear ( ) {  Metadata_ Property_ Builder _defaults = new  Metadata .  Property .  Builder ( ) ; type = _defaults . type ; boxed Type = _defaults . boxed Type ; name = _defaults . name ; capitalized Name = _defaults . capitalized Name ; all Caps Name = _defaults . all Caps Name ; getter Name = _defaults . getter Name ; code Generator = _defaults . code Generator ; fully Checked Cast = _defaults . fully Checked Cast ; accessor Annotations . clear ( ) ; _unset Properties . clear ( ) ; _unset Properties . add All ( _defaults . _unset Properties ) ; return (  Metadata .  Property .  Builder ) this ; }
public static float r_distance ( vec3 a , vec3 b ) { float x = a . m [ _ NUM ] - b . m [ _ NUM ] ; float y = a . m [ _ NUM ] - b . m [ _ NUM ] ; float z = a . m [ _ NUM ] - b . m [ _ NUM ] ; float result = ( float )  Math . sqrt ( x * x + y * y + z * z ) ; return result ; }
public void check Backup Info ( final  File backup Info File , boolean backup In Multi Vdc ) { try (  Input Stream fis = new  File Input Stream ( backup Info File ) ) {  Properties properties = new  Properties ( ) ; properties . load ( fis ) ; check Version ( properties ) ; check Hosts ( properties , backup In Multi Vdc ) ; } catch (  IOException ex ) { log . warn ( _ STR , ex ) ; } }
static  String to Lower Case (  String s ) { int len = s . length ( ) ;  String Builder sb = null ; for ( int i = _ NUM ; i < len ; i ++ ) { char c = s . char At ( i ) ; if ( ( c >= _ STR && c <= _ STR ) || ( c == _ STR ) ) { if ( sb != null ) sb . append ( c ) ; } else if ( ( c >= _ STR && c <= _ STR ) || ( c == _ STR ) ) { if ( sb != null ) sb . append ( c ) ; } else if ( c >= _ STR && c <= _ STR ) { if ( sb == null ) { sb = new  String Builder ( len ) ; sb . append ( s , _ NUM , i ) ; } sb . append ( ( char ) ( c -  CASE_ DIFF ) ) ; } else { throw new  Illegal Argument Exception ( _ STR ) ; } } return sb == null ? s : sb . to String ( ) ; }
public static void assert Props (  Uniform Pair <  Event Bean > received ,  String [ ] property Names ,  Object [ ] expected Insert ,  Object [ ] expected Removed ) { assert Props ( received . get First ( ) , property Names , expected Insert ) ; assert Props ( received . get Second ( ) , property Names , expected Removed ) ; }
public int size ( ) { return al . size ( ) ; }
public static  String to Upper Case (  String src ) { if ( src == null ) { return null ; } else { return src . to Upper Case ( ) ; } }
public final  Iterator <  Knowledge Edge > required Edges Iterator ( ) {  Set <  Knowledge Edge > edges = new  Hash Set < > ( ) ; for (  Ordered Pair <  Set <  My Node > > o : required Rules Specs ) { final  Set <  My Node > first = o . get First ( ) ; for (  My Node s1 : first ) { final  Set <  My Node > second = o . get Second ( ) ; for (  My Node s2 : second ) { if ( ! s1 . equals ( s2 ) ) { edges . add ( new  Knowledge Edge ( s1 . get Name ( ) , s2 . get Name ( ) ) ) ; } } } } return edges . iterator ( ) ; }
@  Deprecated public void unlock (  Lock State <  T > lock State ) { if ( lock State == null ) { throw new  Illegal Argument Exception ( _ STR ) ; } if ( lock State . set Lock != this ) { throw new  Illegal Argument Exception ( _ STR ) ; } if ( lock State . thread !=  Thread . current Thread ( ) ) { throw new  Illegal Argument Exception ( _ STR ) ; } thread Set . remove (  Thread . current Thread ( ) ) ; for (  Reentrant Lock lock : lock State . locks ) { lock . unlock ( ) ; } }
private static  String force Number String To Two Digits (  String text ) { while ( text . length ( ) < _ NUM ) { text = _ STR + text ; } if ( text . length ( ) > _ NUM ) { text = text . substring ( text . length ( ) - _ NUM , text . length ( ) ) ; } return text ; }
public void add Drop Item ( final  String name , final double probability , final int min , final int max ) { drops Items . add ( new  Drop Item ( name , probability , min , max ) ) ; }
public static <  E extends  Identifiable >  List <  E > find By Primary Keys (  Entity Manager em ,  List <  Big Integer > ids ,  Class <  E > type ) { require Argument ( em != null , _ STR ) ; require Argument ( ids != null && ! ids . is Empty ( ) , _ STR ) ; require Argument ( type != null , _ STR ) ;  Typed Query <  E > query = em . create Named Query ( _ STR , type ) ; query . set Hint ( _ STR , _ STR ) ; try { query . set Parameter ( _ STR , ids ) ; query . set Parameter ( _ STR , _ BOOL ) ; return query . get Result List ( ) ; } catch (  No Result Exception ex ) { return new  Array List < > ( _ NUM ) ; } }
public int hash Code ( ) { int h = hash ; if ( h == - _ NUM ) { try { h =  Arrays . hash Code (  X509 Cert Impl . get Encoded Internal ( this ) ) ; } catch (  Certificate Exception e ) { h = _ NUM ; } hash = h ; } return h ; }
public static boolean verify ( byte [ ] data , byte [ ] signature , byte [ ] pub ) {  Preconditions . check Argument ( data . length == _ NUM && signature . length <= _ NUM && pub . length <= _ NUM ) ;  Byte Buffer byte Buff = native ECDSABuffer . get ( ) ; if ( byte Buff == null ) { byte Buff =  Byte Buffer . allocate Direct ( _ NUM + _ NUM + _ NUM + _ NUM ) ; byte Buff . order (  Byte Order . native Order ( ) ) ; native ECDSABuffer . set ( byte Buff ) ; } byte Buff . rewind ( ) ; byte Buff . put ( data ) ; byte Buff . put Int ( signature . length ) ; byte Buff . put Int ( pub . length ) ; byte Buff . put ( signature ) ; byte Buff . put ( pub ) ; return secp256k1_ecdsa_verify ( byte Buff ) == _ NUM ; }
@  Suppress Warnings ( _ STR ) static public void assert Same Iterator Any Order ( final  Object [ ] expected , final  Iterator actual ) { assert Same Iterator Any Order ( _ STR , expected , actual ) ; }
public static  String formatting Finished Percentage ( final  Rollout Group rollout Group , final float finished Percentage ) { float tmp Finished Percentage = _ NUM ; switch ( rollout Group . get Status ( ) ) { case  READY : case  SCHEDULED : case  ERROR : tmp Finished Percentage = _ NUM ; break ; case  FINISHED : tmp Finished Percentage = _ NUM ; break ; case  RUNNING : tmp Finished Percentage = finished Percentage ; break ; default : break ; } return  String . format ( _ STR , tmp Finished Percentage ) ; }
public static  String generate Host Name (  String vm Name ,  String host Id ) {  String hostname = vm Name + _ STR + host Id ;  Preconditions . check State ( hostname . equals ( hostname . to Lower Case ( ) ) , _ STR ) ; return hostname ; }
protected void transfer From File (  File id File ) throws  IOException { try (  Buffered Reader br = new  Buffered Reader ( new  File Reader ( id File ) ) ) {  String line ; while ( ( line = br . read Line ( ) ) != null ) { line = line . trim ( ) ; if ( line . length ( ) > _ NUM ) { transfer ( line ) ; } } } }
private static  String unwrap (  String expression ) { if ( expression . starts With ( _ STR ) ) { expression = expression . substring ( expression . index Of ( _ STR ) + _ NUM , expression . length ( ) - _ NUM ) ; if ( expression . ends With ( _ STR ) ) { expression = expression . substring ( _ NUM , expression . last Index Of ( _ STR ) ) ; } else { expression = expression . substring ( _ NUM , expression . last Index Of ( _ STR ) ) ; } } return expression ; }
protected int draw Next Event Time Diff ( ) { int time Diff = msg Interval [ _ NUM ] == msg Interval [ _ NUM ] ? _ NUM : rng . next Int ( msg Interval [ _ NUM ] - msg Interval [ _ NUM ] ) ; return msg Interval [ _ NUM ] + time Diff ; }
public static  String to Bits ( final long x ) { final  String Builder sb = new  String Builder ( ) ; long t = x ; for ( int i = _ NUM ; i < _ NUM ; i ++ ) { if ( ( i & _ NUM ) == _ NUM && i > _ NUM ) { sb . append ( _ STR ) ; } sb . append ( t < _ NUM ? _ STR : _ STR ) ; t = t << _ NUM ; } assert t == _ NUM ; return sb . to String ( ) ; }
public  Message Tokenizer (  IDiscord Client client ,  String content ) { if ( content == null ) throw new  Illegal Argument Exception ( _ STR ) ; if ( content . length ( ) == _ NUM ) throw new  Illegal Argument Exception ( _ STR ) ; if ( client == null ) throw new  Illegal Argument Exception ( _ STR ) ; this . content = content ; this . client = client ; step Forward ( _ NUM ) ; }
public void await ( int  ID ) throws  Interrupted Exception { if ( parties == _ NUM ) return ; final boolean start Condition = competition Condition ; int competing For = ( locks . length * _ NUM - _ NUM -  ID ) / _ NUM ; while ( competing For >= _ NUM ) { final  Lock node = locks [ competing For ] ; if ( node . try Lock ( ) ) { synchronized ( node ) { while ( competition Condition == start Condition ) node . wait ( ) ; } node . unlock ( ) ; wake Up Target ( competing For * _ NUM + _ NUM ) ; wake Up Target ( competing For * _ NUM + _ NUM ) ; return ; } else { if ( competing For == _ NUM ) break ; competing For = ( competing For - _ NUM ) / _ NUM ; } } competition Condition = ! competition Condition ; wake Up Target ( _ NUM ) ; }
private void load Translations Cache If Empty ( ) { if ( translation Cache . is Empty ( ) ) { for (  Object Translation translation : translations ) { if ( translation . get Locale ( ) != null && translation . get Property ( ) != null && !  String Utils . is Empty ( translation . get Value ( ) ) ) {  String key =  Object Translation . get Cache Key ( translation . get Locale ( ) , translation . get Property ( ) ) ; translation Cache . put ( key , translation . get Value ( ) ) ; } } } }
public  Nav Mouse Mode ( boolean should Consume Events ) { super ( mode ID , should Consume Events ) ; set Mode Cursor (  Cursor . get Predefined Cursor (  Cursor .  CROSSHAIR_ CURSOR ) ) ; rect Attributes . set Line Paint (  Color .  GRAY ) ; rect Attributes . set Matting Paint (  Color .  LIGHT_ GRAY ) ; rect Attributes . set Matted ( _ BOOL ) ; }
public void add Event (  Sim Event new Event ) { new Event . set Serial ( serial ++ ) ; sorted Set . add ( new Event ) ; }
public  String to String Summary ( ) { int resultset Length ;  String result ;  String titles ; int i ; int j ; if ( m_ Non Sig Wins == null ) return _ STR ; resultset Length = _ NUM +  Math . max ( ( int ) (  Math . log ( get Col Count ( ) ) /  Math . log ( _ NUM ) ) , ( int ) (  Math . log ( get Row Count ( ) ) /  Math . log ( _ NUM ) ) ) ; result = _ STR ; titles = _ STR ; result += _ STR ; result += _ STR + _ STR ; result += _ STR ; result += _ STR ; for ( i = _ NUM ; i < get Col Count ( ) ; i ++ ) { if ( get Col Hidden ( i ) ) continue ; titles += _ STR ; result += _ STR ; titles += _ STR +  Utils . pad Left ( _ STR + get Summary Title ( i ) , resultset Length * _ NUM + _ NUM ) ; } result += _ STR ; result += titles + _ STR ; for ( i = _ NUM ; i < get Col Count ( ) ; i ++ ) { if ( get Col Hidden ( i ) ) continue ; for ( j = _ NUM ; j < get Col Count ( ) ; j ++ ) { if ( get Col Hidden ( j ) ) continue ; if ( j == _ NUM ) result += ( char ) ( ( int ) _ STR + i % _ NUM ) ; if ( j == i ) result += _ STR ; else result += _ STR + m_ Non Sig Wins [ i ] [ j ] + _ STR + m_ Wins [ i ] [ j ] + _ STR ; } result += _ STR ; } result += _ STR ; return result ; }
public static  File create Temp Path (  String path ) throws  IOException {  String sep =  File . separator ;  File temp Dir = new  File (  System . get Property ( _ STR ) + sep + path ) ; if ( ! temp Dir . exists ( ) ) if ( ! temp Dir . mkdirs ( ) ) { boolean status = temp Dir . delete ( ) ; throw new  IOException ( _ STR + temp Dir + _ STR + status ) ; } temp Dir . delete On Exit ( ) ; return temp Dir ; }
public void hspan ( double start , double end ,  Paint color ,  String legend ) {  Legend Text legend Text = new  Legend Text ( color , legend ) ; comments . add ( legend Text ) ; plot Elements . add ( new  HSpan ( start , end , color , legend Text ) ) ; }
public  State Interactive extent_to_whole_connections ( ) {  Set <  Brd Item > selected_items = new  Tree Set <  Brd Item > ( ) ; for (  Brd Item curr_item : items_list ) { if ( curr_item instanceof  Brd Connectable ) { selected_items . add All ( curr_item . get_connection_items ( ) ) ; } } if ( selected_items . is Empty ( ) ) { return return_state ; } items_list = selected_items ; actlog_start_scope (  Logfile Scope .  EXTEND_ TO_ WHOLE_ CONNECTIONS ) ; filter ( ) ; i_brd . repaint ( ) ; return this ; }
public static  IKey Builder new Instance ( int capacity ,  Collator Enum collator Choice ,  Locale locale ,  Object strength ,  Decomposition Enum mode ) { if ( collator Choice ==  Collator Enum .  ASCII ) { return new  Key Builder ( capacity ) ; } if ( locale == null ) { locale =  Locale . get Default ( ) ; if ( log . is Info Enabled ( ) ) log . info ( _ STR + locale . get Display Name ( ) ) ; } final boolean icu = collator Choice ==  Collator Enum .  ICU ; if ( icu && !  Default Key Builder Factory . is ICUAvailable ( ) ) { throw new  Unsupported Operation Exception (  Default Key Builder Factory .  ICU_ NOT_ AVAILABLE ) ; } final byte [ ] buf = create Buffer ( capacity ) ; final int len = _ NUM ; switch ( collator Choice ) { case  ICU : return new  Key Builder ( new  ICUSort Key Generator ( locale , strength , mode ) , len , buf ) ; case  JDK : return new  Key Builder ( new  JDKSort Key Generator ( locale , strength , mode ) , len , buf ) ; default : throw new  Unsupported Operation Exception ( _ STR + collator Choice ) ; } }
protected void configure From Properties (  Input Stream is ,  String root Directory ) throws  IOException {  Properties props = new  Properties ( ) ; props . load ( is ) ; props . put (  ROOT_ DIR_ PATH_ PROPERTY , root Directory ) ;  String old Prefix = get Property Prefix ( ) ; set Properties ( null , props ) ; set Property Prefix ( old Prefix ) ; }
Connection open New Connection ( ) throws  SQLException {  Connection new Conn =  Driver Manager . get Connection ( url , user , password ) ; if ( url . starts With ( _ STR ) ) { try (  Statement s = new Conn . create Statement ( ) ) { } } else if ( url . starts With ( _ STR ) ) { try (  Statement s = new Conn . create Statement ( ) ) { s . execute ( _ STR ) ; } } return new Conn ; }
@  Override public void add Relations (  Task task ,  Iterable <  Object Id > project Ids ,  String field Name ) {  List <  Project > new Project List = new  Linked List < > ( ) ;  Iterable <  Project > projects To Add = project Repository . find All ( project Ids , null ) ; for (  Project project : projects To Add ) { new Project List . add ( project ) ; } try { if (  Property Utils . get Property ( task , field Name ) != null ) {  Iterable <  Project > projects = (  Iterable <  Project > )  Property Utils . get Property ( task , field Name ) ; for (  Project project : projects ) { new Project List . add ( project ) ; } } } catch (  Exception e ) { throw new  Runtime Exception ( e ) ; } try {  Property Utils . set Property ( task , field Name , new Project List ) ; } catch (  Exception e ) { throw new  Runtime Exception ( e ) ; } task Repository . save ( task ) ; }
protected void do Flood BDDP ( long pin Switch ,  OFPacket In pi ,  Floodlight Context cntx ) {  Topology Instance ti = get Current Instance ( _ BOOL ) ;  Set <  Long > switches = ti . get Switches In Openflow Domain ( pin Switch ) ; if ( switches == null ) { switches = new  Hash Set <  Long > ( ) ; switches . add ( pin Switch ) ; } for ( long sid : switches ) {  IOFSwitch sw = floodlight Provider . get Switch ( sid ) ; if ( sw == null ) continue ;  Collection <  Short > enabled Ports = sw . get Enabled Port Numbers ( ) ; if ( enabled Ports == null ) continue ;  Set <  Short > ports = new  Hash Set <  Short > ( ) ; ports . add All ( enabled Ports ) ;  Set <  Short > ports Known To Topo = ti . get Ports With Links ( sid ) ; if ( ports Known To Topo != null ) { for ( short p : ports Known To Topo ) {  Node Port Tuple npt = new  Node Port Tuple ( sid , p ) ; if ( ti . is Broadcast Domain Port ( npt ) == _ BOOL ) { ports . remove ( p ) ; } } }  Set <  Short > ports To Eliminate = get Ports To Eliminate For BDDP ( sid ) ; if ( ports To Eliminate != null ) { ports . remove All ( ports To Eliminate ) ; } if ( pin Switch == sid ) { ports . remove ( pi . get In Port ( ) ) ; } do Multi Action Packet Out ( pi . get Packet Data ( ) , sw , ports , cntx ) ; } }
public void sleep Millis ( final long millis ) { try {  Thread . sleep ( millis ) ; } catch ( final  Interrupted Exception e ) { logger . error ( e , e ) ; } }
private static void verify Write Set Not Found ( final  BTree btree ) { log . info ( _ STR ) ; for ( int i = _ NUM ; i < _ NUM ; i ++ ) { if ( btree . contains ( i ) ) { throw new  Runtime Exception ( _ STR + i ) ; } } }
private double calculate Entropy ( double ... masses ) { double res = _ NUM ; for ( double d : masses ) { res -= ( d == _ NUM ) ? _ NUM : d *  Math . log ( d ) ; } return res /  LOG2 ; }
@  Override public void mouse Pressed (  Mouse Event e ) { m_frame Limiter . set Repeats ( _ BOOL ) ; if ( ( e . get Modifiers ( ) &  Input Event .  BUTTON1_ MASK ) != _ NUM && ! e . is Alt Down ( ) && m_mouse State == _ NUM && m_scaling == _ NUM ) { if ( ( ( e . get Modifiers ( ) &  Input Event .  CTRL_ MASK ) != _ NUM ) && ( ( e . get Modifiers ( ) &  Input Event .  SHIFT_ MASK ) == _ NUM ) ) { m_mouse State = _ NUM ; } else if ( ( ( e . get Modifiers ( ) &  Input Event .  SHIFT_ MASK ) != _ NUM ) && ( ( e . get Modifiers ( ) &  Input Event .  CTRL_ MASK ) == _ NUM ) ) { m_old Mouse Pos . width = e . get X ( ) ; m_old Mouse Pos . height = e . get Y ( ) ; m_new Mouse Pos . width = e . get X ( ) ; m_new Mouse Pos . height = e . get Y ( ) ; m_mouse State = _ NUM ;  Graphics g = get Graphics ( ) ; if ( m_ Zoom Box Color == null ) { g . set Color (  Color . black ) ; } else { g . set Color ( m_ Zoom Box Color ) ; } if ( m_ Zoom Box XORColor == null ) { g . set XORMode (  Color . white ) ; } else { g . set XORMode ( m_ Zoom Box XORColor ) ; } g . draw Rect ( m_old Mouse Pos . width , m_old Mouse Pos . height , m_new Mouse Pos . width - m_old Mouse Pos . width , m_new Mouse Pos . height - m_old Mouse Pos . height ) ; g . dispose ( ) ; } else { m_old Mouse Pos . width = e . get X ( ) ; m_old Mouse Pos . height = e . get Y ( ) ; m_new Mouse Pos . width = e . get X ( ) ; m_new Mouse Pos . height = e . get Y ( ) ; m_mouse State = _ NUM ; m_frame Limiter . start ( ) ; } } else if ( ( e . get Button ( ) ==  Mouse Event .  BUTTON1 ) && e . is Alt Down ( ) && e . is Shift Down ( ) && ! e . is Control Down ( ) ) { save Component ( ) ; } else if ( m_mouse State == _ NUM && m_scaling == _ NUM ) { } }
private static double parse Double Value (  String parse String ,  String open Tag ,  String close Tag ,  Data Type Validation Exception exception ) throws  Data Type Validation Exception {  String tag Value ; tag Value = parse String Value ( parse String , open Tag , close Tag , exception ) ; double double Value ; try { double Value =  Double . parse Double ( tag Value ) ; } catch (  Number Format Exception e ) { throw e ; } return double Value ; }
public void put String (  String s ) throws  Array Index Out Of Bounds Exception ,  Unsupported Encoding Exception { byte [ ] bytes = s . get Bytes ( _ STR ) ; int length = bytes . length ; int end At = m_index + length + _ NUM ; if ( end At > m_content . length ) throw new  Array Index Out Of Bounds Exception ( end At + _ STR + m_content . length ) ;  System . arraycopy ( bytes , _ NUM , m_content , m_index , length ) ; m_index += length ; m_content [ m_index ++ ] = _ STR ; debug Append String ( s ) ; }
public void add Rtcp Listener (  Rtcp Event Listener listener ) { listeners . add Element ( listener ) ; }
@  Override protected void ensure Number Of Columns ( int number Of Columns ) { if ( data . length >= number Of Columns ) { return ; } double [ ] new Data = new double [ number Of Columns ] ;  System . arraycopy ( data , _ NUM , new Data , _ NUM , data . length ) ; data = new Data ; }
@  Override public void error (  String domain ,  String key ,  XMLParse Exception exception ) throws  XNIException { if ( f Error Handler != null ) {  SAXParse Exception sax Exception = create SAXParse Exception ( exception ) ; try { f Error Handler . error ( sax Exception ) ; } catch (  SAXParse Exception e ) { throw create XMLParse Exception ( e ) ; } catch (  SAXException e ) { throw create XNIException ( e ) ; } } }
public  CStatus Panel ( final  Back End Debugger Provider debugger Provider ) { super ( new  Border Layout ( ) ) ;  Preconditions . check Not Null ( debugger Provider , _ STR ) ; m_label . set Foreground (  Color .  BLACK ) ; add ( m_label ) ; m_synchronizer = new  CStatus Label Synchronizer ( m_label , debugger Provider ) ; }
@  Override public boolean open (  String access ) { if ( access . equals ( _ STR ) ) { try { i Stream = new  File Image Input Stream ( new  File ( file Path ) ) ; parser = new  Label Parser ( ) ; metadata = parser . parse Header ( i Stream ) ; i Stream . close ( ) ; i Stream = null ; } catch (  IOException e ) { try { i Stream . close ( ) ; } catch (  Exception x ) { } return ( _ BOOL ) ; } } return ( super . open ( access ) ) ; }
@  Nullable public  String file Name ( ) { return  Java Logger . file Name ( delegate ) ; }
public static  BNode parse BNode (  String n Triples BNode ,  Value Factory value Factory ) throws  Illegal Argument Exception { if ( n Triples BNode . starts With ( _ STR ) ) { return value Factory . create BNode ( n Triples BNode . substring ( _ NUM ) ) ; } else { throw new  Illegal Argument Exception ( _ STR + n Triples BNode ) ; } }
public void reset PSRs ( ) { pilot Rolls . remove All Elements ( ) ; }
public static void sort ( byte [ ] array ) {  Dual Pivot Quicksort . sort ( array ) ; }
public void free Object ( int id ) { if ( cache Id == id ) { cache Id = - _ NUM ; cache = null ; } map . remove ( id ) ; }
private void stretch View Vertically (  View view , int cross Size ) {  Layout Params lp = (  Layout Params ) view . get Layout Params ( ) ; int new Height = cross Size - lp . top Margin - lp . bottom Margin ; new Height =  Math . max ( new Height , _ NUM ) ; view . measure (  Measure Spec . make Measure Spec ( view . get Measured Width ( ) ,  Measure Spec .  EXACTLY ) ,  Measure Spec . make Measure Spec ( new Height ,  Measure Spec .  EXACTLY ) ) ; }
public static  Inet Address hex To Inet6 Address (  String addr Hex String ) throws  Illegal Argument Exception { try { return numeric To Inet Address (  String . format ( _ STR , addr Hex String . substring ( _ NUM , _ NUM ) , addr Hex String . substring ( _ NUM , _ NUM ) , addr Hex String . substring ( _ NUM , _ NUM ) , addr Hex String . substring ( _ NUM , _ NUM ) , addr Hex String . substring ( _ NUM , _ NUM ) , addr Hex String . substring ( _ NUM , _ NUM ) , addr Hex String . substring ( _ NUM , _ NUM ) , addr Hex String . substring ( _ NUM , _ NUM ) ) ) ; } catch (  Exception e ) {  Log . e ( _ STR , _ STR + addr Hex String + _ STR + e ) ; throw new  Illegal Argument Exception ( e ) ; } }
public double read Double ( ) throws  IOException { return primitive Types . read Double ( ) ; }
private boolean is At Maximum (  Adjustable bar ) { return ( bar . get Value ( ) + bar . get Visible Amount ( ) >= bar . get Maximum ( ) ) ; }
protected void parse And Add Map Tile Set (  URL tile Set Properties ) throws  IOException ,  Malformed URLException {  Properties desc Props = new  Properties ( ) ;  Logger logger = get Logger ( ) ; logger . info ( _ STR ) ;  Input Stream desc URLStream = tile Set Properties . open Stream ( ) ; desc Props . load ( desc URLStream ) ; logger . info ( _ STR + tile Set Properties . to String ( ) + _ STR + desc Props . to String ( ) ) ;  Map Tile Set mts = create Map Tile Set From Properties ( desc Props ) ; if ( mts != null && mts . all Good ( ) ) {  String mts Name = mts . get Name ( ) ; map Tile Sets . put ( mts . get Name ( ) , mts ) ; logger . info ( _ STR + mts Name + _ STR ) ; } desc URLStream . close ( ) ; }
protected  Date compute ( double value ) { if (  Double . is Na N ( value ) ) { return null ; } long date Long = ( long ) value ;  Date date = new  Date ( date Long ) ;  Calendar cal =  Calendar . get Instance ( ) ; cal . set Time ( date ) ; return cal . get Time ( ) ; }
public void enable Pan (  Bluetooth Adapter adapter ) { if ( m Pan == null ) m Pan = (  Bluetooth Pan ) connect Proxy ( adapter ,  Bluetooth Profile .  PAN ) ; assert Not Null ( m Pan ) ; long start =  System . current Time Millis ( ) ; m Pan . set Bluetooth Tethering ( _ BOOL ) ; long stop =  System . current Time Millis ( ) ; assert True ( m Pan . is Tethering On ( ) ) ; write Output (  String . format ( _ STR , ( stop - start ) ) ) ; }
private int dist Between Points ( int x1 , int z1 , int x2 , int z2 , boolean b Allow Diags ) { int w =  Math . abs ( x2 - x1 ) ; int h =  Math . abs ( z2 - z1 ) ; if ( b Allow Diags ) { if ( w < h ) w = _ NUM ; else h = _ NUM ; } return w + h + _ NUM ; }
private  Workflow .  Method create Volumes Method (  URI system URI ,  URI pool URI ,  List <  URI > volume URIs ,  Virtual Pool Capability Values Wrapper capabilities ) { return new  Workflow .  Method ( _ STR , system URI , pool URI , volume URIs , capabilities ) ; }
public  File Command Info ( int fd ,  String command , int result ,  String parameters ) { this ( _ BOOL , fd , command , result , parameters ) ; }
public void init (  Gui Manual Herblore manual ) { for (  Manual Widget Base widget : widgets ) widget . init ( manual ) ; }
public final double sample Max ( ) { return _active Count Max . get And Set ( _active Count . get ( ) ) ; }
@  Get public  Representation user Code Form ( ) throws  OAuth2 Restlet Exception ,  Invalid Grant Exception ,  Not Found Exception ,  Server Exception { final  OAuth2 Request request = request Factory . create ( get Request ( ) ) ; if ( request . get Parameter (  OAuth2 Constants .  Device Code .  USER_ CODE ) != null ) { return verify ( null ) ; } else { return get Template Representation (  FORM , request , null ) ; } }
public void test Mission Name Construction ( ) {  String xml = _ STR ; xml += create Start Mission Xml ( _ STR , _ STR ) ; xml += create End Mission Xml ( ) ;  Input Stream mission Input Stream = new  Byte Array Input Stream ( xml . get Bytes ( ) ) ;  String mission Name = null ; try { mission Name =  Mission Parser . get Mission Name ( mission Input Stream ) ; } catch (  Mission Parse Exception e ) { e . print Stack Trace ( ) ; }  Assert . assert Equals ( _ STR , mission Name ) ; }
public double unsafe Sabr Volatility ( final double strike , final double forward , final double expiry Time , final double alpha , final double beta , final double nu , final double rho ) { final double one Minus Beta = _ NUM - beta ; final double  A =  Math . pow ( forward * strike , one Minus Beta ) ; final double sqrt A =  Math . sqrt (  A ) ; double log M ; if ( ! is Close ( forward , strike ) ) log M =  Math . log ( forward / strike ) ; else { final double epsilon = ( forward - strike ) / strike ; log M = epsilon - _ NUM * epsilon * epsilon ; } final double z = ( nu / alpha ) * sqrt A * log M ; final double  B = _ NUM - _ NUM * rho * z + z * z ; final double  C = one Minus Beta * one Minus Beta * log M * log M ; final double tmp = (  Math . sqrt (  B ) + z - rho ) / ( _ NUM - rho ) ; final double xx =  Math . log ( tmp ) ; final double  D = sqrt A * ( _ NUM +  C / _ NUM +  C *  C / _ NUM ) ; final double d = _ NUM + expiry Time * ( one Minus Beta * one Minus Beta * alpha * alpha / ( _ NUM *  A ) + _ NUM * rho * beta * nu * alpha / sqrt A + ( _ NUM - _ NUM * rho * rho ) * ( nu * nu / _ NUM ) ) ; double multiplier ; final double m = _ NUM ; if (  Math . abs ( z * z ) >  Constants .  QL_ EPSILON * m ) multiplier = z / xx ; else { final double talpha = ( _ NUM - rho * rho ) / ( _ NUM - rho ) ; final double tbeta = alpha - _ NUM ; final double tgamma = rho / ( _ NUM - rho ) ; multiplier = _ NUM - beta * z + ( tgamma - talpha + tbeta * tbeta * _ NUM ) * z * z ; } return ( alpha /  D ) * multiplier * d ; }
public void close ( ) { while ( ! m Receivers . is Empty ( ) ) { m Context . unregister Receiver ( m Receivers . remove ( _ NUM ) ) ; } if ( m Output Writer != null ) { try { m Output Writer . close ( ) ; } catch (  IOException e ) {  Log . w ( m Tag , _ STR , e ) ; } } }
private void resolve Files (  List <  String > classpaths ,  Map <  String ,  String > files ,  String [ ] paths ,  String prefix ) { for (  String path : paths ) {  String relative Path = file Handler . get Name ( path ) ; if ( prefix != null ) { relative Path = file Handler . append ( prefix , relative Path ) ; } if ( classpaths != null ) { classpaths . add ( relative Path ) ; } if ( file Handler . is Directory ( path ) ) {  String [ ] children = file Handler . get Children ( path ) ; if ( children != null && children . length != _ NUM ) { resolve Files ( null , files , children , relative Path ) ; } } else { files . put ( relative Path , path ) ; } } }
public synchronized void reload Configuration ( ) { properties = null ; final Parameters . clear ( ) ; }
protected void remove Message Processor (  Message Processor old Message Processor ) { synchronized ( message Processors ) { if ( message Processors . remove ( old Message Processor ) ) { old Message Processor . stop ( ) ; } } }
X509 Issuer Serial (  X509 Certificate cert ) { this ( cert . get Issuer X500 Principal ( ) , cert . get Serial Number ( ) ) ; }
private void add To Set (  Object Xml Persist persist ,  IFile file ,  String set Name ) throws  IOException ,  Core Exception {  Collection <  Graph Edge Matcher Descriptor > update Set = load Edge Matchers ( persist , file ) ; persist Updated Bundle ( persist , file , update Set , set Name ) ; }
public void put Bytes ( byte [ ] bytes ) { ensure Capacity ( bytes . length ) ;  System . arraycopy ( bytes , _ NUM , this . byte Buffer , this . position , bytes . length ) ; this . position += bytes . length ; }
public static  String array To Delimited String (  Object [ ] arr ,  String delim ) { if ( arr == null ) { return _ STR ; }  String Buffer sb = new  String Buffer ( ) ; for ( int i = _ NUM ; i < arr . length ; i ++ ) { if ( i > _ NUM ) { sb . append ( delim ) ; } sb . append ( arr [ i ] ) ; } return sb . to String ( ) ; }
public static  Compiere Color parse (  String attributes ) {  Compiere Color cc = new  Compiere Color ( ) ; try { if ( attributes != null && attributes . length ( ) > _ NUM ) cc . parse Attributres ( attributes ) ; } catch (  Exception e ) { log . severe ( _ STR + attributes + _ STR + e . to String ( ) ) ; } return cc ; }
public synchronized static  Lua State new Lua State ( ) { int i = get Next State Index ( ) ;  Lua State  L = new  Lua State ( i ) ; states . add ( i ,  L ) ; return  L ; }
static long check Preamble Size (  Memory mem ) { final long cap = mem . get Capacity ( ) ; if ( cap < _ NUM ) { throw Not Big Enough ( cap , _ NUM ) ; } final long pre0 = mem . get Long ( _ NUM ) ; final int pre Longs = ( int ) ( pre0 & _ NUM ) ; final int required =  Math . max ( pre Longs << _ NUM , _ NUM ) ; if ( cap < required ) { throw Not Big Enough ( cap , required ) ; } return pre0 ; }
public int read ( ) throws  IOException { if ( input Stream == null ) { reopen ( ) ; } count ( _ NUM ) ; return input Stream . read ( ) ; }
public void shutdown ( ) { final long begin =  System . current Time Millis ( ) ; log . info ( _ STR ) ; log . info ( _ STR + get Task Count ( scheduled Pool ) + _ STR ) ; log . info ( _ STR + get Task Count ( instant Pool ) + _ STR ) ; log . info ( _ STR + get Task Count ( long Running Pool ) + _ STR ) ; log . info ( _ STR + ( work Stealing Pool . get Queued Task Count ( ) + work Stealing Pool . get Queued Submission Count ( ) ) + _ STR ) ; scheduled Pool . shutdown ( ) ; instant Pool . shutdown ( ) ; long Running Pool . shutdown ( ) ; work Stealing Pool . shutdown ( ) ; boolean success = _ BOOL ; try { success |= await Termination ( _ NUM ) ; scheduled Pool . set Execute Existing Delayed Tasks After Shutdown Policy ( _ BOOL ) ; scheduled Pool . set Continue Existing Periodic Tasks After Shutdown Policy ( _ BOOL ) ; success |= await Termination ( _ NUM ) ; } catch (  Interrupted Exception e ) { e . print Stack Trace ( ) ; } log . info ( _ STR + success + _ STR + (  System . current Time Millis ( ) - begin ) + _ STR ) ; log . info ( _ STR + get Task Count ( scheduled Pool ) + _ STR ) ; log . info ( _ STR + get Task Count ( instant Pool ) + _ STR ) ; log . info ( _ STR + get Task Count ( long Running Pool ) + _ STR ) ; log . info ( _ STR + ( work Stealing Pool . get Queued Task Count ( ) + work Stealing Pool . get Queued Submission Count ( ) ) + _ STR ) ; work Stealing Pool . shutdown Now ( ) ; }
public static  Collection <  Inet Address > to Inet Addresses (  Collection <  String > addrs ,  Collection <  String > host Names ) throws  Ignite Checked Exception {  Set <  Inet Address > res = new  Hash Set < > ( addrs . size ( ) ) ;  Iterator <  String > host Names It = host Names . iterator ( ) ; for (  String addr : addrs ) {  String host Name = host Names It . has Next ( ) ? host Names It . next ( ) : null ;  Inet Address inet Addr = null ; if ( !  F . is Empty ( host Name ) ) { try { inet Addr =  Inet Address . get By Name ( host Name ) ; } catch (  Unknown Host Exception ignored ) { } } if ( inet Addr == null || inet Addr . is Loopback Address ( ) ) { try { inet Addr =  Inet Address . get By Name ( addr ) ; } catch (  Unknown Host Exception ignored ) { } } if ( inet Addr != null ) res . add ( inet Addr ) ; } if ( res . is Empty ( ) ) throw new  Ignite Checked Exception ( _ STR + addrs + _ STR + host Names + _ STR ) ; return res ; }
public static  String remove New Line Chars (  String s ) {  String ret String = null ; if ( ( s != null ) && ( s . length ( ) > _ NUM ) && ( s . index Of ( _ STR ) != - _ NUM ) ) { char [ ] chars = s . to Char Array ( ) ; int len = chars . length ;  String Buffer sb = new  String Buffer ( len ) ; for ( int i = _ NUM ; i < len ; i ++ ) { char c = chars [ i ] ; if ( c != _ STR ) { sb . append ( c ) ; } } ret String = sb . to String ( ) ; } else { ret String = s ; } return ret String ; }
void calculate Counters ( ) { if ( ! is DBAvailable ( ) ) return ; long time =  System . current Time Millis ( ) ; int total = _ NUM ; write . lock ( ) ; try { count Reset Feeds And Categories ( ) ; total += count Feeds With Unread ( ) ; count Categories With Unread ( ) ; count Special Categories ( total ) ; } finally { write . unlock ( ) ; }  Log . i (  TAG ,  String . format ( _ STR , total , (  System . current Time Millis ( ) - time ) ) ) ; }
protected void append HTML ( final  String Builder sbuf , final char ch ) { switch ( ch ) { case _ STR : sbuf . append ( _ STR ) ; break ; case _ STR : sbuf . append ( _ STR ) ; break ; case _ STR : sbuf . append ( _ STR ) ; break ; default : sbuf . append ( ch ) ; break ; } }
private  Collection <  Var > migrate Columns (  SQLTable current Table ) {  List <  Var > vars = new  Array List < > ( ) ;  String table Type = current Table . get Entity Type ( ) ;  Map <  String ,  Resource Type .  Data Type > columns = current Table . get Columns ( ) ;  Map <  String ,  String > foreign Columns = current Table . get Foreign Key Columns ( ) ; for (  String column : columns . key Set ( ) ) {  Resource Type .  Data Type column Type = columns . get ( column ) ; if ( foreign Columns . contains Key ( column ) ) { vars . add All ( migrate As Relation ( table Type , column , foreign Columns . get ( column ) ) ) ; } else { vars . add All ( migrate As Resource ( table Type , column Type , column ) ) ; } } return vars ; }
public int retrieve Row Count (  String table Name ) throws  SQLException {  Result Set rs = null ; int row Count = - _ NUM ; try { rs = statement . execute Query ( _ STR + table Name ) ; rs . next ( ) ; row Count = rs . get Int ( _ NUM ) ; } finally { if ( rs != null ) { rs . close ( ) ; } } return row Count ; }
@  Override public int add Attribute (  Attribute a ) { if ( a == null ) { throw new  Illegal Argument Exception ( _ STR ) ; } else { int index = - _ NUM ;  Attribute original = a ; a = (  Attribute ) a . clone ( ) ; if ( unused Column List . size ( ) > _ NUM ) { synchronized ( unused Column List ) { if ( unused Column List . size ( ) > _ NUM ) { index = unused Column List . remove ( _ NUM ) ; attributes . set ( index , a ) ; } else { index = attributes . size ( ) ; attributes . add ( a ) ; } } } else { index = attributes . size ( ) ; attributes . add ( a ) ; } a . set Table Index ( index ) ; original . set Table Index ( index ) ; return index ; } }
default  B with (  String key , int value ) { return with ( key ,  Integer . to String ( value ) ) ; }
public static <  X > void sort Top N (  X [ ] array , int offset , int limit ,  Comparator < ? super  X > comp ) { partition Top N ( array , offset , limit , comp ) ;  Arrays . sort ( array , offset , ( int )  Math . min ( ( long ) offset + limit , array . length ) , comp ) ; }
protected boolean is Server Transaction ( ) { return this instanceof  SIPServer Transaction ; }
public static void read Fully (  Input Stream in , byte buf [ ] , int off , int len ) throws  IOException { int to Read = len ; while ( to Read > _ NUM ) { int ret = in . read ( buf , off , to Read ) ; if ( ret < _ NUM ) { throw new  IOException ( _ STR ) ; } to Read -= ret ; off += ret ; } }
public static void assume True (  Boolean Supplier assumption Supplier ,  Supplier <  String > message Supplier ) throws  Test Aborted Exception { if ( ! assumption Supplier . get As Boolean ( ) ) { throw Test Aborted Exception ( message Supplier . get ( ) ) ; } }
public static  String add To Cart Bulk (  Http Servlet Request request ,  Http Servlet Response response ) {  String category Id = request . get Parameter ( _ STR ) ;  Shopping Cart cart = get Cart Object ( request ) ;  Delegator delegator = (  Delegator ) request . get Attribute ( _ STR ) ;  Local Dispatcher dispatcher = (  Local Dispatcher ) request . get Attribute ( _ STR ) ;  Shopping Cart Helper cart Helper = new  Shopping Cart Helper ( delegator , dispatcher , cart ) ;  String control Directive ;  Map <  String ,  Object > result ;  Map <  String ,  Object > param Map =  Util Http . get Parameter Map ( request ) ;  String catalog Id =  Catalog Worker . get Current Catalog Id ( request ) ; result = cart Helper . add To Cart Bulk ( catalog Id , category Id , param Map ) ; control Directive = process Result ( result , request ) ; if ( control Directive . equals (  ERROR ) ) { return _ STR ; } else { return _ STR ; } }
public void add Frequent Set (  Frequent Item Set item Set ) { frequent Sets . add ( item Set ) ; maximum Set Size =  Math . max ( item Set . get Number Of Items ( ) , maximum Set Size ) ; }
private int skip From Peek Buffer ( int length ) { int bytes Skipped =  Math . min ( peek Buffer Length , length ) ; update Peek Buffer ( bytes Skipped ) ; return bytes Skipped ; }
protected  Workflow .  Method create Remove Volumes From CGMethod (  URI vplex URI ,  URI cg URI ,  List <  URI > vplex Volume URIs ) { return new  Workflow .  Method (  REMOVE_ VOLUMES_ FROM_ CG_ STEP , vplex URI , cg URI , vplex Volume URIs ) ; }
private static int show Urls Prompt (  Component parent ,  List <  String > urls ) {  String text = _ STR ; for (  String url : urls ) { url = split Url ( url ) ; text += url + _ STR ; }  String ok Option = _ STR ; if ( urls . size ( ) > _ NUM ) { ok Option = _ STR + urls . size ( ) + _ STR ; }  String [ ] options = { ok Option , _ STR } ; if ( urls . size ( ) == _ NUM ) { options = new  String [ ] { ok Option , _ STR , _ STR } ; } int chosen Option =  JOption Pane . show Option Dialog ( parent , text , _ STR ,  JOption Pane .  OK_ CANCEL_ OPTION ,  JOption Pane .  QUESTION_ MESSAGE , null , options , _ NUM ) ; return chosen Option ; }
int convert Mouse (  Mouse Event event ) { int result ; if ( panel Font == null ) return (  NO_ MOUSE ) ; int col Off = event . get X ( ) -  GRID_ WIDTH -  PANEL_ MARGIN ; int col Num = col Off / horiz Step ; int col Rem = col Off % horiz Step ; if ( ( col Num >= panel Columns ) || ( col Rem <  TEXT_ MARGIN ) || ( col Rem > ( horiz Step -  GRID_ WIDTH -  TEXT_ MARGIN ) ) ) { return (  NO_ MOUSE ) ; } int row Off = event . get Y ( ) -  GRID_ WIDTH -  PANEL_ MARGIN ; int row Num = row Off / verti Step ; int row Rem = row Off % verti Step ; if ( ( row Rem <  TEXT_ MARGIN ) || ( row Rem > ( verti Step -  GRID_ WIDTH -  TEXT_ MARGIN ) ) ) { return (  NO_ MOUSE ) ; } result = corner Index + ( row Num * panel Columns ) + col Num ; if ( result >= cell Count ) return (  NO_ MOUSE ) ; return ( result ) ; }
private static  String compute Regex String (  String original String ,  String old Name ,  String new Name ) {  String Builder builder = new  String Builder ( original String . length ( ) ) ;  String old Name Or New Name Reg Ex =  String . format ( _ STR ,  Pattern . quote ( old Name ) ,  Pattern . quote ( new Name ) ) ; int i = original String . index Of ( old Name ) ; if ( i >= _ NUM ) { int prev I = _ NUM ; while ( i >= _ NUM ) { builder . append (  Pattern . quote ( original String . substring ( prev I , i ) ) ) ; builder . append ( old Name Or New Name Reg Ex ) ; prev I = i ; i = original String . index Of ( old Name , i + old Name . length ( ) ) ; } builder . append (  Pattern . quote ( original String . substring ( prev I + old Name . length ( ) , original String . length ( ) ) ) ) ; } return builder . to String ( ) ; }
public synchronized  String generate Call Identifier (  String address ) {  String date =  Long . to String (  System . current Time Millis ( ) + call IDCounter ++ + rand . next Long ( ) ) ; byte cid [ ] = digester . digest ( date . get Bytes ( ) ) ;  String cid String =  Utils . to Hex String ( cid ) ; return cid String + _ STR + address ; }
public void do History (  Key Event e ) { if ( e . get Source ( ) == m_ Input ) { switch ( e . get Key Code ( ) ) { case  Key Event .  VK_ UP : if ( m_ History Pos > _ NUM ) { m_ History Pos -- ;  String command = m_ Command History . element At ( m_ History Pos ) ; m_ Input . set Text ( command ) ; } break ; case  Key Event .  VK_ DOWN : if ( m_ History Pos < m_ Command History . size ( ) ) { m_ History Pos ++ ;  String command = _ STR ; if ( m_ History Pos < m_ Command History . size ( ) ) { command = m_ Command History . element At ( m_ History Pos ) ; } m_ Input . set Text ( command ) ; } break ; default : break ; } } }
public static  Reference Binding [ ] substitute (  Substitution substitution ,  Reference Binding [ ] original Types ) { if ( original Types == null ) return null ;  Reference Binding [ ] substituted Types = original Types ; for ( int i = _ NUM , length = original Types . length ; i < length ; i ++ ) {  Reference Binding original Type = original Types [ i ] ;  Type Binding substituted Type = substitute ( substitution , original Type ) ; if ( ! ( substituted Type instanceof  Reference Binding ) ) { return null ; } if ( substituted Type != original Type ) { if ( substituted Types == original Types ) {  System . arraycopy ( original Types , _ NUM , substituted Types = new  Reference Binding [ length ] , _ NUM , i ) ; } substituted Types [ i ] = (  Reference Binding ) substituted Type ; } else if ( substituted Types != original Types ) { substituted Types [ i ] = original Type ; } } return substituted Types ; }
@  Override protected void on Draw (  Canvas canvas ) { super . on Draw ( canvas ) ; if ( m Bitmap Shader == null ) return ; canvas . draw Circle ( m Center X , m Center Y , m Cover Radius , m Cover Paint ) ; canvas . draw Circle ( m Center X , m Center Y , m Cover Radius , m Cover Front Paint ) ; m Duration Text = seconds To Time ( m Duration Seconds Current ) ; m Duration Paint . get Text Bounds ( m Duration Text , _ NUM , m Duration Text . length ( ) , m Rect Duration ) ; canvas . draw Text ( m Duration Text , ( m Center X - ( m Rect Duration . width ( ) / _ NUM ) ) , ( m Center Y + ( m Rect Duration . height ( ) / _ NUM ) ) , m Duration Paint ) ; if ( m Bitmap Unselected Action1 != null && m Bitmap Selected Action1 != null ) { canvas . draw Bitmap ( is Action1 Selected ? m Bitmap Selected Action1 : m Bitmap Unselected Action1 , ( m Center X - ( _ NUM * ( m Center X / _ NUM ) ) ) , m Center Y + ( m Center Y / _ NUM ) - ( m Center Y / _ NUM ) , m Action Paint ) ; } if ( m Bitmap Unselected Action2 != null && m Bitmap Selected Action2 != null ) { canvas . draw Bitmap ( is Action2 Selected ? m Bitmap Selected Action2 : m Bitmap Unselected Action2 , m Center X - ( m Center X / _ NUM ) , m Center Y + ( m Center Y / _ NUM ) - ( m Center Y / _ NUM ) , m Action Paint ) ; } if ( m Bitmap Unselected Action3 != null && m Bitmap Selected Action3 != null ) { canvas . draw Bitmap ( is Action3 Selected ? m Bitmap Selected Action3 : m Bitmap Unselected Action3 , ( int ) ( m Center X + ( _ NUM * ( m Center X / _ NUM ) ) ) , m Center Y + ( m Center Y / _ NUM ) - ( m Center Y / _ NUM ) , m Action Paint ) ; } canvas . draw Arc ( m Progress Rect F , _ NUM , _ NUM , _ BOOL , m Paint Empty Progress ) ; canvas . draw Arc ( m Progress Rect F , _ NUM , calculate Past Progress ( ) , _ BOOL , m Paint Loaded Progress ) ; canvas . draw Circle ( ( float ) ( m Center X + ( ( m Center X - _ NUM ) *  Math . cos (  Math . to Radians ( calculate Past Progress ( ) - _ NUM ) ) ) ) , ( float ) ( m Center Y + ( ( m Center X - _ NUM ) *  Math . sin (  Math . to Radians ( calculate Past Progress ( ) - _ NUM ) ) ) ) , m Radius Toggle , m Paint Progress Toggle ) ; }
private static  Collection <  TCPTransport > all Known Transports ( ) {  Set <  TCPTransport > s ; synchronized ( local Endpoints ) { s = new  Hash Set <  TCPTransport > ( local Endpoints . size ( ) ) ; for (  Linked List <  TCPEndpoint > ep List : local Endpoints . values ( ) ) {  TCPEndpoint ep = ep List . get First ( ) ; s . add ( ep . transport ) ; } } return s ; }
public void request Seconds Until Idle Lockout ( ) { operations . add (  Password Policy State Operation Type .  GET_ SECONDS_ UNTIL_ IDLE_ LOCKOUT ) ; }
@  Request Mapping ( value = _ STR , method = {  Request Method .  GET } ) @  Response Body private static  List <  String > show Hive Databases ( ) throws  IOException {  IHive Client hive Client =  Hive Client Factory . get Hive Client ( ) ;  List <  String > results = null ; try { results = hive Client . get Hive Db Names ( ) ; } catch (  Exception e ) { e . print Stack Trace ( ) ; throw new  IOException ( e ) ; } return results ; }
public void test Neg Neg First Shorter ( ) { byte a Bytes [ ] = { - _ NUM , - _ NUM , - _ NUM , - _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM } ; byte b Bytes [ ] = { - _ NUM , _ NUM , _ NUM , _ NUM , - _ NUM , - _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , - _ NUM , _ NUM , _ NUM , - _ NUM , _ NUM , _ NUM , - _ NUM , - _ NUM } ; int a Sign = - _ NUM ; int b Sign = - _ NUM ; byte r Bytes [ ] = { - _ NUM , _ NUM , - _ NUM , - _ NUM , - _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , - _ NUM , - _ NUM , _ NUM , - _ NUM , - _ NUM , _ NUM , - _ NUM , - _ NUM , _ NUM , _ NUM } ;  Big Integer a Number = new  Big Integer ( a Sign , a Bytes ) ;  Big Integer b Number = new  Big Integer ( b Sign , b Bytes ) ;  Big Integer result = a Number . and ( b Number ) ; byte res Bytes [ ] = new byte [ r Bytes . length ] ; res Bytes = result . to Byte Array ( ) ; for ( int i = _ NUM ; i < res Bytes . length ; i ++ ) { assert True ( res Bytes [ i ] == r Bytes [ i ] ) ; } assert Equals ( _ STR , - _ NUM , result . signum ( ) ) ; }
private static double hacky Adjuster ( double f ) { double tmp =  Math . sqrt ( _ NUM - f ) ; return ( f <= _ NUM ) ? tmp : tmp + ( _ NUM * ( f - _ NUM ) ) ; }
private boolean copy Document (  Search Document new Document ,  Search Document document ,  Map <  String ,  Set <  String > > removed Properties ) { boolean mutated = _ BOOL ; for (  String old Field Name : document . get Property Names ( ) ) { new Document . add Property ( old Field Name ) ;  List <  String > old Values = document . get Property ( old Field Name ) ; if ( old Values != null ) {  Set <  String > objects Removed = ( removed Properties != null ) ? removed Properties . get ( old Field Name ) : null ; for (  String old Value : old Values ) { if ( ( objects Removed != null ) && ( objects Removed . contains ( old Value ) ) ) { mutated = _ BOOL ; } else { add Property ( old Field Name , old Value , new Document ) ; } } } } return mutated ; }
public  SVDMatrix (  Matrix  Arg ) { this (  Arg , _ BOOL , _ BOOL , _ BOOL ) ; }
public void unlock For Clear (  Internal Distributed Member locker ) { synchronized ( this . clear Lock Sync ) {  Internal Distributed System instance =  Internal Distributed System . get Any Instance ( ) ; if ( instance != null && logger . is Debug Enabled ( ) ) { logger . debug ( _ STR , locker ,  System . identity Hash Code ( this ) ) ; } if ( this . lock Owner != null && ! locker . equals ( this . lock Owner ) ) { if ( instance != null && logger . is Debug Enabled ( ) ) { logger . debug ( _ STR , lock Owner ) ; } return ; } unlock Version Generation ( locker ) ; } }
public  Unicast Ref ( ) { }
private static int last Index Of (  Object o , @  Not Null  Object [ ] elements , int index ) { if ( o == null ) { for ( int i = index ; i >= _ NUM ; i -- ) { if ( elements [ i ] == null ) { return i ; } } } else { for ( int i = index ; i >= _ NUM ; i -- ) { if ( o . equals ( elements [ i ] ) ) { return i ; } } } return - _ NUM ; }
public void write (  Byte Buffer buffer ) throws  IOException { buffer . position ( _ NUM ) ; if ( m File Channel . size ( ) + buffer . capacity ( ) < m Max Size ) { while ( buffer . has Remaining ( ) ) { m File Channel . write ( buffer ) ; } update Wave File Size ( ) ; } else { int remaining = ( int ) ( m Max Size - m File Channel . size ( ) ) ; remaining -= ( int ) ( remaining % m Audio Format . get Frame Size ( ) ) ; byte [ ] bytes = buffer . array ( ) ;  Byte Buffer current =  Byte Buffer . wrap (  Arrays . copy Of ( bytes , remaining ) ) ;  Byte Buffer next =  Byte Buffer . wrap (  Arrays . copy Of Range ( bytes , remaining , bytes . length ) ) ; while ( current . has Remaining ( ) ) { m File Channel . write ( current ) ; } update Wave File Size ( ) ; rollover ( ) ; while ( next . has Remaining ( ) ) { m File Channel . write ( next ) ; } update Wave File Size ( ) ; } }
public static double dmod_d ( double lhs , double rhs ) { return rhs != _ NUM ? lhs - rhs *  Math . floor ( lhs / rhs ) :  Double .  Na N ; }
private synchronized void block ( boolean tf ) { if ( tf ) { try { if ( m_io Thread . is Alive ( ) && m_state !=  IDLE ) { wait ( ) ; } } catch (  Interrupted Exception ex ) { } } else { notify All ( ) ; } }
public void move (  Mouse Event e ) {  Point2 D pnt = get Projection Point ( e ) ; int x = ( int ) pnt . get X ( ) ; int y = ( int ) pnt . get Y ( ) ; if ( poly . get Render Type ( ) ==  OMGraphic .  RENDERTYPE_ OFFSET ) { gpm = new  Offset Grab Point ( x , y ) ; gpm . clear ( ) ; } else { gpm = gpo ; gpm . clear ( ) ; gpm . set ( x , y ) ; } add Poly Grab Points To OGP ( gpm ) ; moving Point = gpm ; }
public static boolean contain IP ( int cidr Prefix , int cidr Mask Bits , int ip ) { boolean matched = _ BOOL ; int bits To Shift = _ NUM - cidr Mask Bits ; if ( bits To Shift > _ NUM ) { cidr Prefix = cidr Prefix > > bits To Shift ; ip = ip > > bits To Shift ; cidr Prefix = cidr Prefix << bits To Shift ; ip = ip << bits To Shift ; } if ( cidr Prefix != ip ) { matched = _ BOOL ; } return matched ; }
protected static  Boolean lock (  String service Name ,  Object name ) {  Distributed Lock Service service =  Distributed Lock Service . get Service Named ( service Name ) ; boolean locked = service . lock ( name , _ NUM , - _ NUM ) ; return  Boolean . value Of ( locked ) ; }
protected int check Known Cookie ( ) { int ret Val = _ NUM ; debug . message ( _ STR ,  ADAPTIVE ) ;  Http Servlet Request req = get Http Servlet Request ( ) ; if ( req != null ) {  Cookie cookie =  Cookie Utils . get Cookie From Req ( req , known Cookie Name ) ; if ( cookie != null ) { if ( known Cookie Value . equals Ignore Case (  Cookie Utils . get Cookie Value ( cookie ) ) ) { ret Val = known Cookie Score ; } } } if ( known Cookie Value == null ) { known Cookie Value = _ STR ; } if ( known Cookie Save ) { post Auth NMap . put ( _ STR , known Cookie Name ) ; post Auth NMap . put ( _ STR , known Cookie Value ) ; } if ( ! known Cookie Invert ) { ret Val = known Cookie Score - ret Val ; } return ret Val ; }
public  File [ ] select Import Files ( final  String title , boolean multiple Selection ,  File Name Extension Filter [ ] file Name Extension Filters ) { if (  Boolean . parse Boolean (  System . get Property ( _ STR ,  Boolean . to String (  OSType . is Mac ( ) ) ) ) ) {  File Dialog import Dialog = file Dialogs . get ( title ) ; if ( import Dialog == null ) { import Dialog = new  File Dialog ( this , title ,  File Dialog .  LOAD ) ; file Dialogs . put ( title , import Dialog ) ; } import Dialog . set Visible ( _ BOOL ) ; if ( import Dialog . get File ( ) != null ) { return new  File [ ] { new  File ( import Dialog . get Directory ( ) , import Dialog . get File ( ) ) } ; } } else {  JFile Chooser import Chooser = file Choosers . get ( title ) ; if ( import Chooser == null ) { import Chooser = new  JFile Chooser (  Utils . get CWD ( ) ) ; import Chooser . set Multi Selection Enabled ( multiple Selection ) ; for (  File Name Extension Filter file Name Extension Filter : file Name Extension Filters ) { import Chooser . set File Filter ( file Name Extension Filter ) ; } import Chooser . set Dialog Title ( title ) ; file Choosers . put ( title , import Chooser ) ; } int return Val = import Chooser . show Open Dialog ( this ) ; if ( return Val ==  JFile Chooser .  APPROVE_ OPTION ) { if ( import Chooser . is Multi Selection Enabled ( ) ) { return import Chooser . get Selected Files ( ) ; } else { return new  File [ ] { import Chooser . get Selected File ( ) } ; } } } return null ; }
public  GT_ Meta Generated_ Item (  String a Unlocalized , short a Offset , short a Item Amount ) { super ( a Unlocalized ) ; set Creative Tab (  Greg Tech_ API .  TAB_ GREGTECH_ MATERIALS ) ; set Has Subtypes ( _ BOOL ) ; set Max Damage ( _ NUM ) ; m Enabled Items = new  Bit Set ( a Item Amount ) ; m Visible Items = new  Bit Set ( a Item Amount ) ; m Offset = ( short )  Math . min ( _ NUM , a Offset ) ; m Item Amount = ( short )  Math . min ( a Item Amount , _ NUM - m Offset ) ; m Icon List = new  IIcon [ a Item Amount ] [ _ NUM ] ; s Instances . put ( get Unlocalized Name ( ) , this ) ; }
@  Override public  Enumeration <  Option > list Options ( ) {  Vector <  Option > new Vector = new  Vector <  Option > ( _ NUM ) ; new Vector . add Element ( new  Option ( _ STR + _ STR , _ STR , _ NUM , _ STR ) ) ; new Vector . add Element ( new  Option ( _ STR + _ STR , _ STR , _ NUM , _ STR ) ) ; new Vector . add Element ( new  Option ( _ STR , _ STR , _ NUM , _ STR ) ) ; new Vector . add Element ( new  Option ( _ STR + _ STR + _ STR , _ STR , _ NUM , _ STR ) ) ; new Vector . add Element ( new  Option ( _ STR , _ STR , _ NUM , _ STR ) ) ; new Vector . add Element ( new  Option ( _ STR , _ STR , _ NUM , _ STR ) ) ; new Vector . add Element ( new  Option ( _ STR , _ STR , _ NUM , _ STR ) ) ; new Vector . add Element ( new  Option ( _ STR , _ STR , _ NUM , _ STR ) ) ; new Vector . add Element ( new  Option ( _ STR , _ STR , _ NUM , _ STR ) ) ; new Vector . add All (  Collections . list ( super . list Options ( ) ) ) ; return new Vector . elements ( ) ; }
public static  Parsed Sql parse Sql Statement (  String sql ) {  Set <  String > named Parameters = new  Hash Set <  String > ( ) ;  Parsed Sql parsed Sql = new  Parsed Sql ( sql ) ; char [ ] statement = sql . to Char Array ( ) ; int named Parameter Count = _ NUM ; int unnamed Parameter Count = _ NUM ; int total Parameter Count = _ NUM ; int i = _ NUM ; while ( i < statement . length ) { int skip To Position = skip Comments And Quotes ( statement , i ) ; if ( i != skip To Position ) { if ( skip To Position >= statement . length ) { break ; } i = skip To Position ; } char c = statement [ i ] ; if ( c == _ STR || c == _ STR ) { int j = i + _ NUM ; if ( j < statement . length && statement [ j ] == _ STR && c == _ STR ) { i = i + _ NUM ; continue ; } while ( j < statement . length && ! is Parameter Separator ( statement [ j ] ) ) { j ++ ; } if ( j - i > _ NUM ) {  String parameter = sql . substring ( i + _ NUM , j ) ; if ( ! named Parameters . contains ( parameter ) ) { named Parameters . add ( parameter ) ; named Parameter Count ++ ; } parsed Sql . add Named Parameter ( parameter , i , j ) ; total Parameter Count ++ ; } i = j - _ NUM ; } else { if ( c == _ STR ) { unnamed Parameter Count ++ ; total Parameter Count ++ ; } } i ++ ; } parsed Sql . set Named Parameter Count ( named Parameter Count ) ; parsed Sql . set Unnamed Parameter Count ( unnamed Parameter Count ) ; parsed Sql . set Total Parameter Count ( total Parameter Count ) ; return parsed Sql ; }
final void put Long ( int offset , long value ) { unsafe . put Long ( offset + address , value ) ; }
public boolean on Event (  Action Result result ) { synchronized ( this ) {  String request Id = result . get Response Info ( ) . m Request Id ; if ( request Id == null ) { return _ BOOL ; } boolean event Removed = m Request Ids . remove ( request Id ) ; if ( event Removed ) {  Class key = null ; for (  Class type : m Last Request Id By Type . key Set ( ) ) { if ( request Id . equals ( m Last Request Id By Type . get ( type ) ) ) { key = type ; break ; } } if ( key != null ) { m Last Request Id By Type . remove ( key ) ; } } return event Removed ; } }
public static  String gensalt ( int log_rounds ,  Secure Random random ) {  String Buffer rs = new  String Buffer ( ) ; byte rnd [ ] = new byte [  BCRYPT_ SALT_ LEN ] ; random . next Bytes ( rnd ) ; rs . append ( _ STR ) ; if ( log_rounds < _ NUM ) { rs . append ( _ STR ) ; } if ( log_rounds > _ NUM ) { throw new  Illegal Argument Exception ( _ STR ) ; } rs . append (  Integer . to String ( log_rounds ) ) ; rs . append ( _ STR ) ; rs . append ( encode_base64 ( rnd , rnd . length ) ) ; return rs . to String ( ) ; }
public  String Buffer number To String ( final  String str Number To Convert ) {  String str Number = _ STR , sign Bit = _ STR ; if ( str Number To Convert . starts With ( _ STR ) ) { str Number = _ STR + str Number To Convert . substring ( _ NUM , str Number To Convert . length ( ) ) ; sign Bit = _ STR ; } else str Number = _ STR + str Number To Convert ; final  Decimal Format dft = new  Decimal Format ( _ STR ) ; final  String strtemp = _ STR + dft . format (  Double . parse Double ( str Number ) ) ;  String Buffer strb Number = new  String Buffer ( strtemp ) ; final int int Len = strb Number . length ( ) ; for ( int i = int Len - _ NUM ; i > _ NUM ; i = i - _ NUM ) strb Number . insert ( i , _ STR ) ; if ( sign Bit . equals ( _ STR ) ) strb Number = strb Number . insert ( _ NUM , _ STR ) ; return strb Number ; }
private void run Init Script If Required (  String url ,  Connection connection ) throws  SQLException {  Matcher matcher =  INITSCRIPT_ MATCHING_ PATTERN . matcher ( url ) ; if ( matcher . matches ( ) ) {  String init Script Path = matcher . group ( _ NUM ) ; try {  URL resource =  Resources . get Resource ( init Script Path ) ;  String sql =  Resources . to String ( resource ,  Charsets .  UTF_8 ) ;  Script Utils . execute Sql Script ( connection , init Script Path , sql ) ; } catch (  IOException |  Illegal Argument Exception e ) {  LOGGER . warn ( _ STR , init Script Path ) ; throw new  SQLException ( _ STR + init Script Path , e ) ; } catch (  Script Exception e ) {  LOGGER . error ( _ STR , init Script Path , e ) ; throw new  SQLException ( _ STR + init Script Path , e ) ; } } }
public static void check Finite ( final double [ ] val ) throws  Math Illegal Argument Exception { for ( int i = _ NUM ; i < val . length ; i ++ ) { final double x = val [ i ] ; if (  Double . is Infinite ( x ) ||  Double . is Na N ( x ) ) { throw new  Math Illegal Argument Exception (  Localized Core Formats .  NOT_ FINITE_ NUMBER , x ) ; } } }
private void init Keyboard Buttons (  Keyboard View view ) { m Buttons = new  Array List < > ( ) ; m Buttons . add ( (  Keyboard Button View ) view . find View By Id (  R . id . pin_code_button_0 ) ) ; m Buttons . add ( (  Keyboard Button View ) view . find View By Id (  R . id . pin_code_button_1 ) ) ; m Buttons . add ( (  Keyboard Button View ) view . find View By Id (  R . id . pin_code_button_2 ) ) ; m Buttons . add ( (  Keyboard Button View ) view . find View By Id (  R . id . pin_code_button_3 ) ) ; m Buttons . add ( (  Keyboard Button View ) view . find View By Id (  R . id . pin_code_button_4 ) ) ; m Buttons . add ( (  Keyboard Button View ) view . find View By Id (  R . id . pin_code_button_5 ) ) ; m Buttons . add ( (  Keyboard Button View ) view . find View By Id (  R . id . pin_code_button_6 ) ) ; m Buttons . add ( (  Keyboard Button View ) view . find View By Id (  R . id . pin_code_button_7 ) ) ; m Buttons . add ( (  Keyboard Button View ) view . find View By Id (  R . id . pin_code_button_8 ) ) ; m Buttons . add ( (  Keyboard Button View ) view . find View By Id (  R . id . pin_code_button_9 ) ) ; m Buttons . add ( (  Keyboard Button View ) view . find View By Id (  R . id . pin_code_button_clear ) ) ; for (  View button : m Buttons ) { button . set On Click Listener ( this ) ; } }
public static boolean is Auto New (  Properties ctx , int  Window No ) { if ( ctx == null ) throw new  Illegal Argument Exception ( _ STR ) ;  String s = get Context ( ctx ,  Window No , _ STR , _ BOOL ) ; if ( s != null ) { if ( s . equals ( _ STR ) ) return _ BOOL ; else return _ BOOL ; } return is Auto New ( ctx ) ; }
private static  String find Relative Path (  String file Path ,  String dir Path ) {  String rel Path ; if ( ! dir Path . ends With (  File . separator ) ) { dir Path = dir Path +  File . separator ; } if ( file Path . starts With ( dir Path ) ) { rel Path = file Path . substring ( dir Path . length ( ) ) ; } else { rel Path = file Path ; } return rel Path ; }
public boolean init ( ) { log . config ( _ STR ) ;  MClient client =  MClient . get (  Env . get Ctx ( ) ) ;  String  ASPFilter = _ STR ; if ( client . is Use ASP ( ) )  ASPFilter = _ STR + _ STR + _ STR + _ STR + _ STR + client . get AD_ Client_ ID ( ) + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + client . get AD_ Client_ ID ( ) + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + client . get AD_ Client_ ID ( ) + _ STR + _ STR + _ STR + _ STR + _ STR ;  String sql = null ; if (  Env . is Base Language (  Env . get Ctx ( ) , _ STR ) ) sql = _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR +  ASPFilter + _ STR ; else sql = _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR +  Env . get AD_ Language (  Env . get Ctx ( ) ) + _ STR + _ STR +  ASPFilter + _ STR ; boolean has Fields = _ BOOL ;  Rows rows = new  Rows ( ) ; try {  Prepared Statement pstmt =  DB . prepare Statement ( sql , null ) ; pstmt . set Int ( _ NUM , m_process Info . get AD_ Process_ ID ( ) ) ;  Result Set rs = pstmt . execute Query ( ) ; while ( rs . next ( ) ) { has Fields = _ BOOL ; create Field ( rs , rows ) ; is Pair = ! is Pair ; } rs . close ( ) ; pstmt . close ( ) ; } catch (  SQLException e ) { log . log (  Level .  SEVERE , sql , e ) ; } if ( m_m Fields . size ( ) != m_m Fields2 . size ( ) || m_m Fields . size ( ) != m_w Editors . size ( ) || m_m Fields2 . size ( ) != m_w Editors2 . size ( ) ) log . log (  Level .  SEVERE , _ STR ) ; if ( has Fields ) { center Panel . append Child ( rows ) ; dynamic Display ( ) ; } else dispose ( ) ; return has Fields ; }
public void reset Singleton ( ) { root = null ; tmp File Counter . set ( _ NUM ) ; accessed Files . clear ( ) ; should All Throw IOException = _ BOOL ; classes That Should Throw IOException . clear ( ) ; synchronized ( leaking Resources ) { for (  Leaking Resource resource : leaking Resources ) { try { resource . release ( ) ; } catch (  Exception e ) { logger . warn ( _ STR + e . get Message ( ) , e ) ; } } leaking Resources . clear ( ) ; } }
public void test And Not Neg Neg First Longer ( ) { byte a Bytes [ ] = { - _ NUM , _ NUM , _ NUM , _ NUM , - _ NUM , - _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , - _ NUM , _ NUM , _ NUM , - _ NUM , _ NUM , _ NUM , - _ NUM , - _ NUM } ; byte b Bytes [ ] = { - _ NUM , - _ NUM , - _ NUM , - _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM } ; int a Sign = - _ NUM ; int b Sign = - _ NUM ; byte r Bytes [ ] = { _ NUM , - _ NUM , - _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM } ;  Big Integer a Number = new  Big Integer ( a Sign , a Bytes ) ;  Big Integer b Number = new  Big Integer ( b Sign , b Bytes ) ;  Big Integer result = a Number . and Not ( b Number ) ; byte res Bytes [ ] = new byte [ r Bytes . length ] ; res Bytes = result . to Byte Array ( ) ; for ( int i = _ NUM ; i < res Bytes . length ; i ++ ) { assert True ( res Bytes [ i ] == r Bytes [ i ] ) ; } assert Equals ( _ STR , _ NUM , result . signum ( ) ) ; }
public static  String generate String Of Characters ( int count ) {  String Builder sb = new  String Builder ( ) ; for ( int i = _ NUM ; i < count ; i ++ ) { sb . append (  CHARACTERS . char At ( ( int ) (  Math . random ( ) *  CHARACTERS . length ( ) ) ) ) ; } return sb . to String ( ) ; }
private  Exchange Rate Manager ( ) { if (  System . get Property ( _ STR ) == null ) throw new  Unsupported Operation Exception ( _ STR ) ; add Known Rates ( ) ; }
public void remove Attribute (  String name ) { if ( name != null ) if ( attributes List != null ) { for ( int i = _ NUM ; i < attributes List . size ( ) ; i ++ ) {  Object o = attributes List . element At ( i ) ; if ( o instanceof  Attribute Field ) {  Attribute Field a = (  Attribute Field ) o ; try {  String n = a . get Name ( ) ; if ( n != null ) { if ( name . equals ( n ) ) { attributes List . remove ( a ) ; } } } catch (  Sdp Parse Exception e ) { } } } } }
@  Override public void evict (  String key ) { key = safety Key ( key ) ; final  File file = new  File ( cache Directory , key ) ; file . delete ( ) ; }
public static boolean is Unique Contraint Error (  Exception e ) { if (  DB . is Postgre SQL ( ) ) return is SQLState ( e , _ STR ) ; return is Error Code ( e , _ NUM ) ; }
private void insert Used Context Prefixes ( ) { int unknown Prefixes Count = unknown Prefixes In XMLLiteral . size ( ) ; if ( unknown Prefixes Count > _ NUM ) {  String Builder context Prefixes = new  String Builder ( _ NUM ) ;  Element Info top Element = peek Stack ( ) ; for ( int i = _ NUM ; i < unknown Prefixes Count ; i ++ ) {  String prefix = unknown Prefixes In XMLLiteral . get ( i ) ;  String namespace = top Element . get Namespace ( prefix ) ; if ( namespace != null ) { append Namespace Decl ( context Prefixes , prefix , namespace ) ; } } int end Of First Start Tag = char Buf . index Of ( _ STR ) ; char Buf . insert ( end Of First Start Tag , context Prefixes . to String ( ) ) ; } unknown Prefixes In XMLLiteral . clear ( ) ; }
public void add Put Time Nanos ( long duration ) { put Time Nanos . add And Get ( duration ) ; if ( delegate != null ) delegate . add Put Time Nanos ( duration ) ; }
public static  List <  Integer > precompute Hashes ( byte [ ] data , long tweak ) {  Array List <  Integer > list = new  Array List < > (  MAX_ HASH_ FUNCS ) ; for ( int i = _ NUM ; i <  MAX_ HASH_ FUNCS ; ++ i ) { list . add ( murmurhash3bit ( i , data , tweak ) ) ; } return list ; }
@  Request Processing ( value = _ STR , method =  HTTPRequest Method .  GET ) @  Before ( advice Class = {  Stopwatch Start Advice . class ,  Anonymous View Check . class ,  User Block Check . class } ) @  After ( advice Class =  Stopwatch End Advice . class ) public void show Home Following Tags ( final  HTTPRequest Context context , final  Http Servlet Request request , final  Http Servlet Response response , final  String user Name ) throws  Exception { final  JSONObject user = (  JSONObject ) request . get Attribute (  User .  USER ) ; request . set Attribute (  Keys .  TEMAPLTE_ DIR_ NAME ,  Symphonys . get ( _ STR ) ) ; final  Abstract Free Marker Renderer renderer = new  Skin Renderer ( ) ; context . set Renderer ( renderer ) ; renderer . set Template Name ( _ STR ) ; final  Map <  String ,  Object > data Model = renderer . get Data Model ( ) ; filler . fill Header And Footer ( request , response , data Model ) ;  String page Num Str = request . get Parameter ( _ STR ) ; if (  Strings . is Empty Or Null ( page Num Str ) || !  Strings . is Numeric ( page Num Str ) ) { page Num Str = _ STR ; } final int page Num =  Integer . value Of ( page Num Str ) ; final int page Size =  Symphonys . get Int ( _ STR ) ; final int window Size =  Symphonys . get Int ( _ STR ) ; fill Home User ( data Model , user ) ; final  String following Id = user . opt String (  Keys .  OBJECT_ ID ) ; data Model . put (  Follow .  FOLLOWING_ ID , following Id ) ; avatar Query Service . fill User Avatar URL ( user ) ; final  JSONObject following Tags Result = follow Query Service . get Following Tags ( following Id , page Num , page Size ) ; final  List <  JSONObject > following Tags = (  List <  JSONObject > ) following Tags Result . opt (  Keys .  RESULTS ) ; data Model . put (  Common .  USER_ HOME_ FOLLOWING_ TAGS , following Tags ) ; final boolean is Logged In = (  Boolean ) data Model . get (  Common .  IS_ LOGGED_ IN ) ; if ( is Logged In ) { final  JSONObject current User = (  JSONObject ) data Model . get (  Common .  CURRENT_ USER ) ; final  String follower Id = current User . opt String (  Keys .  OBJECT_ ID ) ; final boolean is Following = follow Query Service . is Following ( follower Id , following Id ) ; data Model . put (  Common .  IS_ FOLLOWING , is Following ) ; for ( final  JSONObject following Tag : following Tags ) { final  String home User Following Tag Id = following Tag . opt String (  Keys .  OBJECT_ ID ) ; following Tag . put (  Common .  IS_ FOLLOWING , follow Query Service . is Following ( follower Id , home User Following Tag Id ) ) ; } } user . put (  User Ext .  USER_ T_ CREATE_ TIME , new  Date ( user . get Long (  Keys .  OBJECT_ ID ) ) ) ; final int following Tag Cnt = following Tags Result . opt Int (  Pagination .  PAGINATION_ RECORD_ COUNT ) ; final int page Count = ( int )  Math . ceil ( following Tag Cnt / ( double ) page Size ) ; final  List <  Integer > page Nums =  Paginator . paginate ( page Num , page Size , page Count , window Size ) ; if ( ! page Nums . is Empty ( ) ) { data Model . put (  Pagination .  PAGINATION_ FIRST_ PAGE_ NUM , page Nums . get ( _ NUM ) ) ; data Model . put (  Pagination .  PAGINATION_ LAST_ PAGE_ NUM , page Nums . get ( page Nums . size ( ) - _ NUM ) ) ; } data Model . put (  Pagination .  PAGINATION_ CURRENT_ PAGE_ NUM , page Num ) ; data Model . put (  Pagination .  PAGINATION_ PAGE_ COUNT , page Count ) ; data Model . put (  Pagination .  PAGINATION_ PAGE_ NUMS , page Nums ) ; }
public int elevation At ( float lat , float lon ) { if ( frame_is_valid == _ BOOL ) { if ( lat >= dsi . sw_lat && lat <= dsi . ne_lat && lon >= dsi . sw_lon && lon <= dsi . ne_lon ) { int lat_index =  Math . round ( ( lat - dsi . sw_lat ) * _ NUM / uhl . lat_post_interval ) ; int lon_index =  Math . round ( ( lon - dsi . sw_lon ) * _ NUM / uhl . lon_post_interval ) ; if ( elevations [ lon_index ] == null ) read Data Record ( lon_index ) ; return ( int ) elevations [ lon_index ] [ lat_index ] ; } } return - _ NUM ; }
Observed Object create Observed Object (  Object Name object ) { return new  Observed Object ( object ) ; }
private void save Initial Child State (  Faces Context faces Context ,  UIComponent component ) { if ( component instanceof  Editable Value Holder && ! component . is Transient ( ) ) {  String client Id = component . get Client Id ( faces Context ) ;  Saved State state = new  Saved State ( ) ; initial Child State . put ( client Id , state ) ; state . populate ( (  Editable Value Holder ) component ) ; }  Iterator <  UIComponent > iterator = component . get Facets And Children ( ) ; while ( iterator . has Next ( ) ) { save Child State ( faces Context , iterator . next ( ) ) ; } }
public boolean is_overlap ( ) {  Set <  Brd Item > start_contacts = get_start_contacts ( ) ;  Set <  Brd Item > end_contacts = get_end_contacts ( ) ; for (  Brd Item end_contact : end_contacts ) { if ( start_contacts . contains ( end_contact ) ) return _ BOOL ; } return _ BOOL ; }
static  Object ensure Not Null (  Location location ,  Object value ) { if ( value == null ) { throw new  Eval Exception ( location , _ STR ) ; } return value ; }
private static  String pad Right (  String s , int min Length ) { return  String . format ( _ STR + min Length + _ STR , s ) ; }
protected synchronized void on Send Task Completed (  Record Buffer <  R > buffer ) { logger . trace ( _ STR , name ( ) , buffer ) ; active Send Tasks . decrement And Get ( ) ; }
public void add Preferences Button ( ) {  JButton prefs Button = new  JButton ( _ STR ) ; prefs Button . set Hide Action Text ( _ BOOL ) ; prefs Button . set Action (  Raster Plot Actions . get Properties Dialog Action ( this ) ) ; button Panel . add ( prefs Button ) ; }
public void clear Unused (  Config Impl config ) {  System Out . print Date ( config . get Out Writer ( ) , _ STR + size ( ) + _ STR + max Size + _ STR ) ; if ( size ( ) > max Size ) {  Object [ ] keys = keys ( ) ;  Long Key List list = new  Long Key List ( ) ; for ( int i = _ NUM ; i < keys . length ; i ++ ) {  Page Source ps = get Page Source ( keys [ i ] , _ BOOL ) ; long update Time = ps . get Last Access Time ( ) ; if ( update Time + timeout <  System . current Time Millis ( ) ) { long add = ( ( ps . get Access Count ( ) - _ NUM ) * _ NUM ) ; if ( add > timeout ) add = timeout ; list . add ( update Time + add , keys [ i ] ) ; } } while ( size ( ) > max Size ) {  Object key = list . shift ( ) ; if ( key == null ) break ; remove ( key ) ; } } }
public static  Grid Field [ ] create Fields (  Properties ctx , int  Window No , int  Tab No , int  AD_ Tab_ ID ) {  Array List <  Grid Field VO > list VO = new  Array List <  Grid Field VO > ( ) ; int  AD_ Window_ ID = _ NUM ; boolean read Only = _ BOOL ;  String sql =  Grid Field VO . get SQL ( ctx ) ;  Prepared Statement pstmt = null ; try { pstmt =  DB . prepare Statement ( sql , null ) ; pstmt . set Int ( _ NUM ,  AD_ Tab_ ID ) ;  Result Set rs = pstmt . execute Query ( ) ; while ( rs . next ( ) ) {  Grid Field VO vo =  Grid Field VO . create ( ctx ,  Window No ,  Tab No ,  AD_ Window_ ID ,  AD_ Tab_ ID , read Only , rs ) ; list VO . add ( vo ) ; } rs . close ( ) ; pstmt . close ( ) ; pstmt = null ; } catch (  Exception e ) { log . log (  Level .  SEVERE , sql , e ) ; } try { if ( pstmt != null ) pstmt . close ( ) ; pstmt = null ; } catch (  Exception e ) { pstmt = null ; }  Grid Field [ ] ret Value = new  Grid Field [ list VO . size ( ) ] ; for ( int i = _ NUM ; i < list VO . size ( ) ; i ++ ) ret Value [ i ] = new  Grid Field ( (  Grid Field VO ) list VO . get ( i ) ) ; return ret Value ; }
public  Short Interleaved Raster (  Sample Model sample Model ,  Data Buffer data Buffer ,  Point origin ) { this ( sample Model , data Buffer , new  Rectangle ( origin . x , origin . y , sample Model . get Width ( ) , sample Model . get Height ( ) ) , origin , null ) ; }
@  Override public boolean fling Backward (  Selector obj , boolean is Vertical ) throws  Ui Object Not Found Exception {  Ui Scrollable scrollable = new  Ui Scrollable ( obj . to Ui Selector ( ) ) ; if ( is Vertical ) scrollable . set As Vertical List ( ) ; else scrollable . set As Horizontal List ( ) ; return scrollable . fling Backward ( ) ; }
protected static double to Double (  String s ) { try { return  Double . parse Double ( s ) ; } catch (  Exception e ) {  Test Case . fail ( _ STR + s + _ STR + throwable To String ( e ) ) ; return  Double .  Na N ; } }
public void add Listener ( final  IFilter Panel Listener <  T > listener ) { m_listeners . add Listener ( listener ) ; }
public void testmirror (  File orig ,  File origni ,  File truecolor ) {  File mirror =  Test Support . add Suffix To Name ( orig , _ STR ) ;  File recov =  Test Support . add Suffix To Name ( orig , _ STR ) ; long crc0 = _ NUM ; boolean interlaced ; boolean palete ; {  Png Reader pngr = new  Png Reader ( orig ) ;  Png Writer pngw = null ; try { if ( rand . next Boolean ( ) ) pngr . set Line Set Factory (  Image Line Set Default . get Factory Byte ( ) ) ; palete = pngr . img Info . indexed ; pngr . prepare Simple Digest Computation ( ) ; interlaced = pngr . is Interlaced ( ) ; pngw = new  Png Writer ( mirror , pngr . img Info , _ BOOL ) ; pngw . set Filter Type (  Filter Type .  FILTER_ CYCLIC ) ; pngw . copy Chunks From ( pngr . get Chunks List ( ) ) ;  IImage Line Set < ? extends  IImage Line > lines = pngr . read Rows ( ) ; for ( int row = _ NUM ; row < pngr . img Info . rows ; row ++ ) { mirror Line ( lines . get Image Line ( row ) , pngr . img Info ) ; pngw . write Row ( lines . get Image Line ( row ) ) ; } pngr . end ( ) ; crc0 =  Png Helper Internal . get Digest ( pngr ) ; pngw . end ( ) ; } finally { pngr . close ( ) ; if ( pngw != null ) pngw . close ( ) ; } } {  Png Reader pngr2 = new  Png Reader ( mirror ) ;  Png Writer pngw = null ; try { if ( pngr2 . img Info . bit Depth < _ NUM && rand . next Boolean ( ) ) pngr2 . set Line Set Factory (  Image Line Set Default . get Factory Byte ( ) ) ; pngw = new  Png Writer ( recov , pngr2 . img Info , _ BOOL ) ; pngw . set Filter Type (  Filter Type .  FILTER_ DEFAULT ) ; pngw . copy Chunks From ( pngr2 . get Chunks List ( ) ) ; for ( int row = _ NUM ; row < pngr2 . img Info . rows ; row ++ ) {  IImage Line line = pngr2 . read Row ( ) ; mirror Line ( line , pngr2 . img Info ) ; pngw . write Row ( line ) ; } pngr2 . end ( ) ; pngw . end ( ) ; } finally { pngr2 . close ( ) ; if ( pngw != null ) pngw . close ( ) ; } } if ( ! interlaced )  Test Support . test Crc Equals ( recov , crc0 ) ; else  Test Support . test Same Crc ( recov , origni ) ; if ( interlaced ) additional Test Interlaced ( orig , origni ) ; if ( palete && truecolor . exists ( ) ) additional Test Palette ( orig , truecolor ) ; }
public boolean is Stable ( ) { return my Features . contains (  FEATURE_ STABLE ) ; }
public static void calc Text Size (  Paint paint ,  String demo Text ,  FSize output FSize ) {  Rect r = m Calc Text Size Rect ; r . set ( _ NUM , _ NUM , _ NUM , _ NUM ) ; paint . get Text Bounds ( demo Text , _ NUM , demo Text . length ( ) , r ) ; output FSize . width = r . width ( ) ; output FSize . height = r . height ( ) ; }
protected void perform Defaults ( ) { super . perform Defaults ( ) ; initialize Values ( ) ; verify Validation ( ) ; }
public static void write ( int x1 , int y1 ,  Image image , int image_width , int image_height ,  Link Properties properties ,  Data Output Stream dos ) throws  IOException ,  Interrupted Exception { int [ ] pixels = new int [ image_width * image_height ] ;  Pixel Grabber pixelgrabber = new  Pixel Grabber ( image , _ NUM , _ NUM , image_width , image_height , pixels , _ NUM , image_width ) ; pixelgrabber . grab Pixels ( ) ;  Link Raster . write ( x1 , y1 , image_width , image_height , pixels , properties , dos ) ; }
@  Suppress Warnings ( _ STR ) public void test Projection Predicate Different Class Loaders ( ) throws  Exception { final  Ignite ignite3 = start Grid ( _ NUM ) ;  URL [ ] cls Ldr Urls ; try { cls Ldr Urls = new  URL [ ] { new  URL (  Grid Test Properties . get Property ( _ STR ) ) } ; } catch (  Malformed URLException e ) { throw new  Runtime Exception ( _ STR , e ) ; }  Class Loader ldr1 = new  URLClass Loader ( cls Ldr Urls , get Class ( ) . get Class Loader ( ) ) ;  Class task Cls = ldr1 . load Class ( _ STR ) ;  Class node Filter Cls = ldr1 . load Class ( _ STR ) ;  Ignite Predicate <  Cluster Node > node Filter = (  Ignite Predicate <  Cluster Node > ) node Filter Cls . get Constructor (  UUID . class ) . new Instance ( ignite2 . cluster ( ) . local Node ( ) . id ( ) ) ;  Map <  UUID ,  Integer > ret = (  Map <  UUID ,  Integer > ) execute Async ( compute ( ignite1 . cluster ( ) . for Predicate ( node Filter ) ) , task Cls , null ) . get (  TASK_ EXEC_ TIMEOUT_ MS ) ; assert ret != null ; assert ret . get ( ignite1 . cluster ( ) . local Node ( ) . id ( ) ) != null && ret . get ( ignite1 . cluster ( ) . local Node ( ) . id ( ) ) == _ NUM : ret . get ( ignite1 . cluster ( ) . local Node ( ) . id ( ) ) ; assert ret . get ( ignite3 . cluster ( ) . local Node ( ) . id ( ) ) != null && ret . get ( ignite3 . cluster ( ) . local Node ( ) . id ( ) ) == _ NUM : ret . get ( ignite3 . cluster ( ) . local Node ( ) . id ( ) ) ; }
public static void write To File (  String content ,  File dst File ) throws  IOException {  Buffered Writer buffered Writer = new  Buffered Writer ( new  File Writer ( dst File , _ BOOL ) ) ; buffered Writer . write ( content ) ; buffered Writer . close ( ) ; }
private void update Status (  String relay State , int current Status ) {  Integer tmp = (  Integer ) current Status Map . get ( relay State ) ; if ( tmp != null ) { int previous Status = tmp . int Value ( ) ; switch ( previous Status ) { case  LOGOUT_ SUCCEEDED_ STATUS : if ( current Status > previous Status ) { current Status Map . put ( relay State , new  Integer ( current Status ) ) ; } break ; case  LOGOUT_ FAILED_ STATUS : if ( current Status <  LOGOUT_ FAILED_ STATUS ) { current Status Map . put ( relay State , new  Integer (  LOGOUT_ PARTIAL_ STATUS ) ) ; } break ; default : break ; } } else { current Status Map . put ( relay State , new  Integer ( current Status ) ) ; } }
public static  Set <  String > list Servers (  SSOToken sso Token ,  String site Name ) throws  SMSException ,  SSOException ,  Configuration Exception {  Set <  String > members = new  Hash Set < > ( ) ;  String site Id = get Site Id ( sso Token , site Name ) ; if ( site Id != null ) {  Set <  String > all Servers =  Server Configuration . get Servers ( sso Token ) ; for (  String svr : all Servers ) { if (  Server Configuration . belong To Site ( sso Token , svr , site Name ) ) { members . add ( svr ) ; } } } return members ; }
public static  Generic Object Editor Dialog create Dialog (  Container parent ) { return create Dialog ( parent , null ) ; }
public static boolean contains In Line Features (  Styled Layer Descriptor sld ) { if ( sld != null ) { for (  Styled Layer layer : sld . layers ( ) ) { if ( layer instanceof  User Layer ) {  User Layer user Layer = (  User Layer ) layer ; if ( user Layer . get Inline Feature Datastore ( ) != null ) { return _ BOOL ; } } } } return _ BOOL ; }
public static void run Finalization ( ) {  RUNTIME . run Finalization ( ) ; }
private void display All String Defined In String Xml ( ) {  Simple Icon Font Text View text View = (  Simple Icon Font Text View ) find View By Id (  R . id . text_view_1 ) ;  List <  String > list = new  Array List < > ( ) ; list . add ( get String (  R . string . gems_logo ) ) ;  String text =  Text Utils . join ( _ STR , list ) ; text View . set Text ( text ) ; }
public static void check HTTPRequest Length (  Http Servlet Request request ) throws  Servlet Exception { int max Content Length =  SAMLUtils . get Max Content Length ( ) ; if ( max Content Length != _ NUM ) { int length = request . get Content Length ( ) ; if ( length == - _ NUM ) { throw new  Servlet Exception ( bundle . get String ( _ STR ) ) ; } if ( length > max Content Length ) { if ( debug . message Enabled ( ) ) { debug . message ( _ STR + _ STR + length ) ; } throw new  Servlet Exception ( bundle . get String ( _ STR ) ) ; } } }
public void add Foreign Key Constraint (  String name ,  String source Field ,  String target Field ,  String target Table ) {  Foreign Key Constraint foreign Key = new  Foreign Key Constraint ( name , source Field , target Field , target Table ) ; add Foreign Key Constraint ( foreign Key ) ; }
public void push (  Notification notification ,  Notification Response Listener listener ) { final  String notification Topic = notification . get Topic ( ) ; final  String topic = notification Topic == null ? default Topic : notification Topic ;  Request req =  Utils . build Request ( client , topic , notification , gateway ) ; semaphore . acquire Uninterruptibly ( ) ; req . send ( new  Response Listener ( semaphore , notification , listener ) ) ; }
public void update From Resource ( ) { for (  String resource : resources ) {  Input Stream is =  Class Loader . get System Resource As Stream ( resource ) ;  Linked Hash Map <  Entry Type ,  Linked Hash Map <  String ,  Config Entry > > parse Result = parse ( is ) ; for (  Entry Type type : my Map . key Set ( ) ) {  Linked Hash Map <  String ,  Config Entry > data Mappings = my Map . get ( type ) ;  Linked Hash Map <  String ,  Config Entry > resource Mappings = parse Result . get ( type ) ;  Linked Hash Map <  String ,  Config Entry > temp Mappings = new  Linked Hash Map <  String ,  Config Entry > ( ) ;  Linked Hash Set <  String > keys = new  Linked Hash Set <  String > ( ) ; keys . add All ( data Mappings . key Set ( ) ) ; keys . add All ( resource Mappings . key Set ( ) ) ; for (  String key : keys ) { if ( resource Mappings . contains Key ( key ) ) { temp Mappings . put ( key , resource Mappings . get ( key ) ) ; } else { temp Mappings . put ( key , data Mappings . get ( key ) ) ; } } my Map . put ( type , temp Mappings ) ; } } }
private void deselect ( final int index , final boolean should Fire Events ) { check Widget ( ) ; if ( index < _ NUM || index >= items . size ( ) ) { return ; } final  DLItem item = selection . remove ( index ) ; if ( should Fire Events ) { fire Selection Event ( item ) ; } final  List <  DLItem > deselected Items = new  Array List <  DLItem > ( ) ; item . set Last Action (  LAST_ ACTION .  DESELECTION ) ; deselected Items . add ( item ) ; if ( should Fire Events ) { fire Selection Change Event ( deselected Items ) ; } redraw Tables ( ) ; }
public boolean is Leaf (  Object nd ) {  Node node = (  Node ) nd ; return ! node . has Child Nodes ( ) ; }
public void add Listener (  Listener listener ) { m Listeners . add ( listener ) ; notify Service Discovered ( m Matching Drones ) ; }
@  Override boolean equals (  Object obj ) ;
private double [ ] parse Vector (  String s ) {  String [ ] entries =  WHITESPACE_ PATTERN . split ( s ) ; double [ ] d = new double [ entries . length ] ; for ( int i = _ NUM ; i < entries . length ; i ++ ) { try { d [ i ] =  Parse Util . parse Double ( entries [ i ] ) ; } catch (  Number Format Exception e ) { throw new  Abort Exception ( _ STR ) ; } } return d ; }
public void test_create_update ( ) throws  IOException { final  String id = _ STR ; final  Map <  String ,  Object > metadata = new  Hash Map <  String ,  Object > ( ) ; metadata . put (  File Metadata Schema .  ID , id ) ; metadata . put ( _ STR , _ STR ) ; final int version0 ; final long create Time0 ; final byte [ ] expected0 = new byte [ ] { _ NUM , _ NUM , _ NUM } ; { version0 = repo . create ( metadata ) ; metadata . put (  File Metadata Schema .  VERSION ,  Integer . value Of ( version0 ) ) ; assert Equals ( _ STR , _ NUM , version0 ) ;  Repository Document Impl doc = (  Repository Document Impl ) repo . read ( id ) ; create Time0 = doc . get Version Create Time ( ) ;  Map <  String ,  Object > actual = doc . as Map ( ) ; assert Equals ( _ STR , id , actual . get (  File Metadata Schema .  ID ) ) ; assert Equals ( _ STR , version0 , actual . get (  File Metadata Schema .  VERSION ) ) ; assert Equals ( _ STR , _ STR , actual . get ( _ STR ) ) ; assert Equals ( _ STR , metadata . size ( ) , actual . size ( ) ) ; repo . copy Stream ( id , version0 , new  Byte Array Input Stream ( expected0 ) ) ; assert Equals ( _ STR , expected0 , read ( repo . input Stream ( id , version0 ) ) ) ; } final int version1 ; final long create Time1 ; final byte [ ] expected1 = new byte [ ] { _ NUM , _ NUM , _ NUM } ; { metadata . put ( _ STR , _ STR ) ;  Document Impl doc1 = new  Document Impl ( metadata ) ; doc1 . copy Stream ( expected1 ) ; version1 = repo . update ( doc1 ) ; assert Equals ( _ STR , _ NUM , version1 ) ; metadata . put (  File Metadata Schema .  VERSION ,  Integer . value Of ( version1 ) ) ;  Repository Document Impl doc = (  Repository Document Impl ) repo . read ( id ) ; create Time1 = doc . get Version Create Time ( ) ; assert Not Same ( _ STR , _ NUM , create Time1 ) ; assert Not Same ( _ STR , create Time0 , create Time1 ) ;  Map <  String ,  Object > actual = doc . as Map ( ) ; assert Equals ( _ STR , id , actual . get (  File Metadata Schema .  ID ) ) ; assert Equals ( _ STR , version1 , actual . get (  File Metadata Schema .  VERSION ) ) ; assert Equals ( _ STR , _ STR , actual . get ( _ STR ) ) ; assert Equals ( _ STR , metadata . size ( ) , actual . size ( ) ) ; assert Equals ( _ STR , expected1 , read ( repo . input Stream ( id , version1 ) ) ) ; assert Equals ( _ STR , new byte [ ] { } , read ( repo . input Stream ( id , version0 ) ) ) ; {  ITPS tps = repo . read Metadata ( id , create Time1 - _ NUM ) ;  ITPV tpv = tps . get (  File Metadata Schema .  VERSION ) ; assert Equals ( _ STR , null , tpv . get Value ( ) ) ; } } }
public  Session Wrapper (  Session ses ) { this . ses = ses ; this . time =  System . current Time Millis ( ) ; }
public static  List <  Batch Response > post With Single Request ( final  Request Specification request Spec , final  Response Specification response Spec , final  Batch Request br ) { final  List <  Batch Request > batch Requests = new  Array List < > ( ) ; batch Requests . add ( br ) ; final  String jsonified Request =  Batch Helper . to Json String ( batch Requests ) ; final  List <  Batch Response > response =  Batch Helper . post Batch Requests Without Enclosing Transaction ( request Spec , response Spec , jsonified Request ) ;  Assert . assert Not Null ( response ) ;  Assert . assert True ( response . size ( ) > _ NUM ) ; return response ; }
public  File program Directory ( ) { return program Directory ; }
@  Override public void clear Route Sensors ( ) { _control Sensor List = new  Array List < > ( ) ; }
public static  KEYSTORE_ TYPE from String (  String x ) throws  Configuration Exception { for (  KEYSTORE_ TYPE current Type :  KEYSTORE_ TYPE . values ( ) ) { if ( x . equals Ignore Case ( current Type . to String ( ) ) ) return current Type ; } throw new  Configuration Exception (  Message Format . format ( _ STR , x ) ) ; }
public  Object Mapper next Level (  Object Mapper level ) {  Object Mapper previous = level Stack . peek ( ) ; level Stack . push ( level ) ; return previous ; }
protected static int to Digit ( final char ch , final int index ) throws  Hex Decode Exception { final int digit =  Character . digit ( ch , _ NUM ) ; if ( digit == - _ NUM ) { throw new  Hex Decode Exception ( _ STR + ch + _ STR + index ) ; } return digit ; }
public  JSONObject to Json ( ) throws  JSONException {  JSONObject json = new  JSONObject ( ) ;  JSONArray jpods = new  JSONArray ( ) ; for (  Diaspora Pod pod : pods ) { jpods . put ( pod . to Json ( ) ) ; } json . put ( _ STR , jpods ) ; json . put ( _ STR ,  System . current Time Millis ( ) ) ; return json ; }
public static  Key Store load (  File key Store File ,  Password password ) throws  Crypto Exception ,  File Not Found Exception {  Key Store Type key Store Type = null ; try { key Store Type =  Crypto File Util . detect Key Store Type ( new  File Input Stream ( key Store File ) ) ; } catch (  File Not Found Exception ex ) { throw ex ; } catch (  IOException ex ) { throw new  Crypto Exception ( res . get String ( _ STR ) , ex ) ; } if ( key Store Type == null ) { return null ; } return load ( key Store File , password , key Store Type ) ; }
@  Visible For Testing static boolean is Precaching Enabled (  Context context ) {  Shared Preferences prefs =  Preference Manager . get Default Shared Preferences ( context ) ; return prefs . get Boolean (  PREF_ IS_ PRECACHING_ ENABLED , _ BOOL ) ; }
public void and (  Long Bit Set other ) { int pos =  Math . min ( num Words , other . num Words ) ; while ( -- pos >= _ NUM ) { bits [ pos ] &= other . bits [ pos ] ; } if ( num Words > other . num Words ) {  Arrays . fill ( bits , other . num Words , num Words , _ NUM ) ; } }
@  Override public boolean equals (  Object obj ) { if ( this == obj ) return _ BOOL ; if ( ! ( obj instanceof  Principal Entry ) ) return _ BOOL ;  Principal Entry that = (  Principal Entry ) obj ; return ( principal Class . equals ( that . principal Class ) && principal Name . equals ( that . principal Name ) ) ; }
public boolean is Valid Lockdown Profile ( ) { try { return _ BOOL ; } catch (  Illegal Argument Exception e ) {  Log . w (  TAG , _ STR , e ) ; return _ BOOL ; } }
private int read Server Response ( ) throws  IOException {  String Buffer reply Buf = new  String Buffer ( _ NUM ) ; int c ; int continuing Code = - _ NUM ; int code ;  String response ; server Response . set Size ( _ NUM ) ; while ( _ BOOL ) { while ( ( c = in . read ( ) ) != - _ NUM ) { if ( c == _ STR ) { if ( ( c = in . read ( ) ) != _ STR ) { reply Buf . append ( _ STR ) ; } } reply Buf . append ( ( char ) c ) ; if ( c == _ STR ) { break ; } } response = reply Buf . to String ( ) ; reply Buf . set Length ( _ NUM ) ; if ( logger . is Loggable (  Platform Logger .  Level .  FINEST ) ) { logger . finest ( _ STR + server Addr + _ STR + response ) ; } if ( response . length ( ) == _ NUM ) { code = - _ NUM ; } else { try { code =  Integer . parse Int ( response . substring ( _ NUM , _ NUM ) ) ; } catch (  Number Format Exception e ) { code = - _ NUM ; } catch (  String Index Out Of Bounds Exception e ) { continue ; } } server Response . add Element ( response ) ; if ( continuing Code != - _ NUM ) { if ( code != continuing Code || ( response . length ( ) >= _ NUM && response . char At ( _ NUM ) == _ STR ) ) { continue ; } else { continuing Code = - _ NUM ; break ; } } else if ( response . length ( ) >= _ NUM && response . char At ( _ NUM ) == _ STR ) { continuing Code = code ; continue ; } else { break ; } } return code ; }
public  From Clause (  Stream stream One ,  Outer Join Qualifier outer Join Qualifier ,  Stream stream Two ) { this ( stream One ) ; add ( stream Two ) ; outer Join Qualifiers . add ( outer Join Qualifier ) ; }
public static  Kdb Database create Kdb Database (  Credentials credentials ,  Kdb Header kdb Header ,  Input Stream input Stream ) throws  IOException {  Data Input data Input = new  Little Endian Data Input Stream ( input Stream ) ; check Signature ( data Input ) ; deserialize Header ( kdb Header , data Input ) ;  Input Stream decrypted Input Stream = kdb Header . create Decrypted Input Stream ( credentials . get Key ( ) , input Stream ) ;  Message Digest digest =  Encryption . get Message Digest Instance ( ) ;  Digest Input Stream digest Input Stream = new  Digest Input Stream ( decrypted Input Stream , digest ) ; data Input = new  Little Endian Data Input Stream ( digest Input Stream ) ;  Kdb Database kdb Database = new  Kdb Database ( ) ;  Kdb Group last Group = (  Kdb Group ) kdb Database . get Root Group ( ) ; for ( long group = _ NUM ; group < kdb Header . get Group Count ( ) ; group ++ ) { last Group = deserialize Group ( last Group , data Input ) ; } for ( long entry = _ NUM ; entry < kdb Header . get Entry Count ( ) ; entry ++ ) { deserialize Entry ( kdb Database , data Input ) ; } if ( !  Arrays . equals ( digest . digest ( ) , kdb Header . get Content Hash ( ) ) ) { throw new  Illegal State Exception ( _ STR ) ; } digest Input Stream . close ( ) ; return kdb Database ; }
private  Diff Part decode Add ( final int block Size_ S , final int block Size_ L ) throws  Unsupported Encoding Exception ,  Decoding Exception { if ( block Size_ S < _ NUM || block Size_ L < _ NUM ) { throw new  Decoding Exception ( _ STR + block Size_ S + _ STR + block Size_ L ) ; } int s = r . read ( block Size_ S ) ; int l = r . read ( block Size_ L ) ;  Byte Array Output Stream output = new  Byte Array Output Stream ( ) ; for ( int i = _ NUM ; i < l ; i ++ ) { output . write ( r . read Byte ( ) ) ; }  Diff Part part = new  Diff Part (  Diff Action .  INSERT ) ; part . set Start ( s ) ; part . set Text ( output . to String (  WIKIPEDIA_ ENCODING ) ) ; return part ; }
public void rebuild Panel ( ) { if ( active Worker != null && ! active Worker . is Done ( ) ) { active Worker . cancel ( _ BOOL ) ; } panel Images . remove All ( ) ; panel Images . revalidate ( ) ; scroll Pane . repaint ( ) ; active Worker = new  Image Loader ( media Files ) ; active Worker . execute ( ) ; }
protected void process Bytes ( byte [ ] buf , int off , int len ) { n Bytes In += len ; if ( len < _ NUM || state . is Done ( ) ) return ; if ( state ==  State .  ROW_ READY ) throw new  Pngj Input Exception ( _ STR ) ; if ( inf . needs Dictionary ( ) || ! inf . needs Input ( ) ) throw new  Runtime Exception ( _ STR ) ; inf . set Input ( buf , off , len ) ; if ( is Callback Mode ( ) ) { while ( inflate Data ( ) ) { int next Row Len = process Row Callback ( ) ; prepare For Next Row ( next Row Len ) ; if ( is Done ( ) ) process Done Callback ( ) ; } } else inflate Data ( ) ; }
@  Override protected  String to String (  File obj ) { return obj . get Absolute Path ( ) ; }
public final void go To Next Page ( ) { final boolean is Last Page = view Pager . get Current Item ( ) == ( pages . size ( ) - _ NUM ) ; if ( ! is Last Page ) { view Pager . set Current Item ( view Pager . get Current Item ( ) + _ NUM , _ BOOL ) ; } }
public  List <  Type Id < ? > > as List ( ) { return  Collections . unmodifiable List (  Arrays . as List ( types ) ) ; }
private static void delete Rules (  List <  String > batch List ,  List <  Rule > rules To Delete ) {  String delete Statement = _ STR +  RULES_ TABLE + _ STR ; for (  Rule rule : rules To Delete ) { batch List . add (  String . format ( delete Statement , rule . get Uid ( ) ) ) ; } }
public boolean is Visited (  Object element ) { return my Visited Elements . contains Key ( element ) ; }
public  Aws Iot Connection (  Abstract Aws Iot Client client ) { this . client = client ; }
public static <  T >  Completable Future <  T > exceptionally Completed Future (  Throwable throwable ) { final  Completable Future <  T > future = new  Completable Future <  T > ( ) ; future . complete Exceptionally ( throwable ) ; return future ; }
protected void init Forecast Errors (  Array List <  Float > model ,  Time Series .  Data Sequence data ) { double sum Err = _ NUM ; double sum Abs Err = _ NUM ; double sum Abs Percent Err = _ NUM ; double sum Err Squared = _ NUM ; int processed Points = _ NUM ; int n = data . size ( ) ; for ( int i = _ NUM ; i < n ; i ++ ) { double error = model . get ( i ) - data . get ( i ) . value ; sum Err += error ; sum Abs Err +=  Math . abs ( error ) ; sum Abs Percent Err +=  Math . abs ( error / data . get ( i ) . value ) ; sum Err Squared += error * error ; processed Points ++ ; } this . bias = sum Err / processed Points ; this . mad = sum Abs Err / processed Points ; this . mape = sum Abs Percent Err / processed Points ; this . mse = sum Err Squared / processed Points ; this . sae = sum Abs Err ; errors Init = _ BOOL ; }
public boolean check Modifiers (  Mouse Event e ) { return e . get Modifiers ( ) == modifiers ; }
public void emit Retained Vars (  Generate Js Visitor gen ) { if ( ! retained Vars . is Empty ( ) ) { gen . out ( _ STR ) ; boolean first = _ BOOL ; for (  String var Name : retained Vars ) { if ( ! first ) { gen . out ( _ STR ) ; } first = _ BOOL ; gen . out ( var Name ) ; } gen . end Line ( _ BOOL ) ; retained Vars . clear ( ) ; } }
public  List <  Structured Translation >  Kbest Extract On HG (  Hyper Graph hg , int top N ) { reset State ( ) ; if ( hg == null || hg . goal Node == null ) { return empty List ( ) ; } final  List <  Structured Translation > kbest = new  Array List < > ( top N ) ; for ( int k = _ NUM ; k <= top N ; k ++ ) {  Structured Translation translation = get Kth Structured Translation ( hg . goal Node , k ) ; if ( translation == null ) { break ; } kbest . add ( translation ) ; } return kbest ; }
public static boolean is Snapshot Full Copy Supported (  URI block Snap URI ,  Db Client db Client ) {  Block Snapshot block Obj = db Client . query Object (  Block Snapshot . class , block Snap URI ) ;  Storage System storage = db Client . query Object (  Storage System . class , block Obj . get Storage Controller ( ) ) ; return ( storage != null && ( storage . device Is Type (  Type . openstack ) || storage . device Is Type (  Type . vnxblock ) || storage . device Is Type (  Type . ibmxiv ) || storage . device Is Type (  Type . vmax ) ) ) ; }
public  Iterable <  Service Descriptor > list Services ( ) {  Array List <  Service Descriptor > service Descriptors = new  Array List <  Service Descriptor > ( ) ; for (  File Descriptor file Descriptor : file Descriptors ) { service Descriptors . add All ( file Descriptor . get Services ( ) ) ; } return service Descriptors ; }
private  String strip Code Value Sentences (  String string ) { return string . replace All ( _ STR , _ STR ) ; }
public static double quantile ( double p , double alpha , double beta ) { if (  Double . is Na N ( alpha ) ||  Double . is Na N ( beta ) ||  Double . is Na N ( p ) || alpha < _ NUM || beta < _ NUM ) { return  Double .  Na N ; } if ( p < _ NUM || p > _ NUM ) { return  Double .  Na N ; } if ( p == _ NUM ) { return _ NUM ; } if ( p == _ NUM ) { return _ NUM ; } if ( p > _ NUM ) { return _ NUM - raw Quantile ( _ NUM - p , beta , alpha , log Beta ( beta , alpha ) ) ; } else { return raw Quantile ( p , alpha , beta , log Beta ( alpha , beta ) ) ; } }
public boolean validate (  String cert ,  String signed Data ,  String signature ) throws  No Such Algorithm Exception ,  IOException ,  Exception { byte [ ] cert Bytes =  Base64 . decode ( cert ) ; byte [ ] signed Data Bytes =  Base64 . decode ( signed Data ) ; byte [ ] signature Bytes =  Base64 . decode ( signature ) ; return validate ( cert Bytes , signed Data Bytes , signature Bytes ) ; }
private  Shared Deployment create New Deployment (  Grid Deployment Metadata meta , boolean is Cache ) { assert  Thread . holds Lock ( mux ) ; assert meta . parent Loader ( ) == null ;  Ignite Uuid ldr Id =  Ignite Uuid . from Uuid ( ctx . local Node Id ( ) ) ;  Grid Deployment Class Loader cls Ldr ; if ( meta . deployment Mode ( ) ==  CONTINUOUS || meta . participants ( ) == null ) { cls Ldr = new  Grid Deployment Class Loader ( ldr Id , meta . user Version ( ) , meta . deployment Mode ( ) , _ BOOL , ctx , ctx . config ( ) . get Class Loader ( ) != null ? ctx . config ( ) . get Class Loader ( ) :  U . grid Class Loader ( ) , meta . class Loader Id ( ) , meta . sender Node Id ( ) , comm , ctx . config ( ) . get Network Timeout ( ) , log , ctx . config ( ) . get Peer Class Loading Local Class Path Exclude ( ) , ctx . config ( ) . get Peer Class Loading Missed Resources Cache Size ( ) , meta . deployment Mode ( ) ==  CONTINUOUS , _ BOOL ) ; if ( meta . participants ( ) != null ) for (  Map .  Entry <  UUID ,  Ignite Uuid > e : meta . participants ( ) . entry Set ( ) ) cls Ldr . register ( e . get Key ( ) , e . get Value ( ) ) ; if ( log . is Debug Enabled ( ) ) log . debug ( _ STR + _ STR + cls Ldr + _ STR + meta + _ STR ) ; } else { assert meta . deployment Mode ( ) ==  SHARED ; cls Ldr = new  Grid Deployment Class Loader ( ldr Id , meta . user Version ( ) , meta . deployment Mode ( ) , _ BOOL , ctx ,  U . grid Class Loader ( ) , meta . participants ( ) , comm , ctx . config ( ) . get Network Timeout ( ) , log , ctx . config ( ) . get Peer Class Loading Local Class Path Exclude ( ) , ctx . config ( ) . get Peer Class Loading Missed Resources Cache Size ( ) , _ BOOL , _ BOOL ) ; if ( log . is Debug Enabled ( ) ) log . debug ( _ STR + _ STR + cls Ldr + _ STR + meta + _ STR ) ; }  Shared Deployment dep = new  Shared Deployment ( meta . deployment Mode ( ) , cls Ldr , ldr Id , meta . user Version ( ) , meta . alias ( ) ) ; if ( log . is Debug Enabled ( ) ) log . debug ( _ STR + dep ) ; if ( is Cache ) {  List <  Shared Deployment > deps =  F . add If Absent ( cache , meta . user Version ( ) , new  Linked List <  Shared Deployment > ( ) ) ; assert deps != null ; deps . add ( dep ) ; if ( log . is Debug Enabled ( ) ) log . debug ( _ STR + cache ) ; } return dep ; }
public void test Add Servlet Run As Role ( ) throws  Exception {  String xml =  WEBAPP_ TEST_ HEADER + _ STR + _ STR + _ STR + _ STR + _ STR ;  Web Xml web Xml =  Web Xml Io . parse Web Xml ( new  Byte Array Input Stream ( xml . get Bytes ( _ STR ) ) , get Entity Resolver ( ) ) ;  Web Xml Utils . add Servlet Run As Role Name ( web Xml , _ STR , _ STR ) ;  String role Name =  Web Xml Utils . get Servlet Run As Role Name ( web Xml , _ STR ) ; assert Equals ( _ STR , role Name ) ; }
public  Multi Term Query ( final  String field ) { this . field =  Objects . require Non Null ( field , _ STR ) ; }
public static void print Line (  Object message ) { if ( ! is Disabled ( ) ) { print Line (  String . value Of ( message ) ) ; } }
public void test Invalid Xml ( ) throws  Exception { test Invalid Gpx (  INVALID_ XML_ GPX ) ; }
public  String to String ( boolean expand ) {  String Builder acc = new  String Builder ( ) ; to String ( acc , _ NUM , expand ) ; return acc . to String ( ) ; }
public static boolean is Accessor Pair (  TMember member ,  TMember member2 ) { return ( member instanceof  TGetter && member2 instanceof  TSetter ) || ( member instanceof  TSetter && member2 instanceof  TGetter ) ; }
public static  Date Format create UTCDate Formatter (  String date Format ) {  Date Format formatter = new  Simple Date Format ( date Format ) ; formatter . set Time Zone (  Time Zone . get Time Zone ( _ STR ) ) ; return formatter ; }
public void write Linked Kml ( final  String filename , final  Kml Type kml ) { if ( filename . equals ( _ STR ) ) { throw new  Illegal Argument Exception ( _ STR ) ; } if ( filename . equals ( _ STR ) ) { throw new  Illegal Argument Exception ( _ STR ) ; } write Kml ( filename , kml ) ; }
String destination File Path ( ) { return destination File Path ; }
public  Boot Panel ( ) { init Components ( ) ; }
private  List <  Header > default Headers ( ) {  Date Format date Format = new  Simple Date Format ( _ STR ) ;  List <  Header > headers = new  Array List < > ( ) ; headers . add ( new  Basic Header ( _ STR , date Format . format ( new  Date ( ) ) ) ) ; return headers ; }
public  Aem Parsys clear ( ) {  List <  Web Element > list = current Scope . find Elements (  By . css Selector (  SELECTOR_ FOR_ COMPONENT_ IN_ PARSYS ) ) ; list . for Each ( null ) ; return this ; }
private void register New Client (  Json Object j Data ) {  Client new Client = gson . from Json ( j Data ,  Client . class ) ; if ( new Client . is Valid ( ) ) { add Client ( new Client ) ; broadcast New Client ( new Client ) ; send Client List ( new Client ) ; } else { logger . log (  Level .  WARNING , _ STR ) ; } }
@  Override public void parse (  Input Stream in ,  String base URI ) throws  IOException ,  RDFParse Exception ,  RDFHandler Exception { if ( in == null ) { throw new  Illegal Argument Exception ( _ STR ) ; } if ( base URI == null ) { throw new  Illegal Argument Exception ( _ STR ) ; }  Input Source input Source = new  Input Source ( new  BOMInput Stream ( in , _ BOOL ) ) ; input Source . set System Id ( base URI ) ; parse ( input Source ) ; }
public static  Date parse Date (  String date Value ,  Collection date Formats ) throws  Date Parse Exception { if ( date Value == null ) { throw new  Illegal Argument Exception ( _ STR ) ; } if ( date Formats == null ) { date Formats =  DEFAULT_ PATTERNS ; } if ( date Value . length ( ) > _ NUM && date Value . starts With ( _ STR ) && date Value . ends With ( _ STR ) ) { date Value = date Value . substring ( _ NUM , date Value . length ( ) - _ NUM ) ; }  Simple Date Format date Parser = null ; final  Iterator format Iter = date Formats . iterator ( ) ; while ( format Iter . has Next ( ) ) { final  String format = (  String ) format Iter . next ( ) ; if ( date Parser == null ) { date Parser = new  Simple Date Format ( format ,  Locale .  US ) ; date Parser . set Time Zone (  Time Zone . get Time Zone ( _ STR ) ) ; } else { date Parser . apply Pattern ( format ) ; } try { return date Parser . parse ( date Value ) ; } catch ( final  Parse Exception pe ) { } } throw new  Date Parse Exception ( _ STR + date Value ) ; }
public  JSONObject remove (  String name ) { if ( name == null ) { throw new  Null Pointer Exception ( _ STR ) ; } int index = index Of ( name ) ; if ( index != - _ NUM ) { table . remove ( index ) ; names . remove ( index ) ; values . remove ( index ) ; } return this ; }
Edge Map <  Block > find Loops (  Deque <  Block > code ,  Map <  Block ,  Block > idom ,  Set Map <  Block ,  Edge > pred ) {  Edge Map <  Block > loops = new  Edge Map <  Block > ( ) ; for (  Block b : code ) for (  Edge s : b . succ ( ) ) if ( is Loop ( s , idom ) ) { verbose Status ( _ STR + s ) ;  Block h = s . to ;  Set <  Block > loop = loops . get ( h ) ;  Set <  Block > work = new  Tree Set <  Block > ( ) ; for (  Edge p : pred . get ( h ) ) { if ( is Loop ( p , idom ) && ! loop . contains ( p . from ) && p . from != h ) { loop . add ( p . from ) ; work . add ( p . from ) ; } } while ( ! work . is Empty ( ) ) {  Block x = get Block ( work ) ; for (  Edge p : pred . get ( x ) ) { if ( p . from != h && ! loop . contains ( p . from ) ) { loop . add ( p . from ) ; work . add ( p . from ) ; } } } } return loops ; }
public int [ ] read Line ( ) { int record [ ] = new int [  MAX_ LEN ] ; int checksum = _ NUM ; try { while ( ( ( char In = buff In . read ( ) ) == _ NUM ) || ( char In == _ NUM ) ) { } if ( char In != _ STR ) { if ( log . is Debug Enabled ( ) ) { log . debug ( _ STR + line No ) ; } return new int [ ] { - _ NUM } ; } } catch (  IOException e ) {  JOption Pane . show Message Dialog ( this , _ STR , _ STR ,  JOption Pane .  ERROR_ MESSAGE ) ; if ( log . is Debug Enabled ( ) ) { log . debug ( _ STR + e . to String ( ) ) ; } } record [  LEN ] = rd Hex Byte ( ) ; checksum += record [  LEN ] ; record [  ADDRH ] = rd Hex Byte ( ) ; checksum += record [  ADDRH ] ; record [  ADDRL ] = rd Hex Byte ( ) ; checksum += record [  ADDRL ] ; record [  TYPE ] = rd Hex Byte ( ) ; checksum += record [  TYPE ] ; address = ( address & _ NUM ) + record [  ADDRH ] * _ NUM + record [  ADDRL ] ; type = record [  TYPE ] ; if ( type !=  END ) { len = record [  LEN ] ; for ( int i = _ NUM ; i <= len ; i ++ ) { record [  TYPE + i ] = rd Hex Byte ( ) ; checksum += record [  TYPE + i ] ; } } int file Check = rd Hex Byte ( ) ; if ( ( ( checksum + file Check ) & _ NUM ) != _ NUM ) { log . error ( _ STR + line No ) ; } line No ++ ; return record ; }
private void generate Hive Test Files ( ) throws  File Not Found Exception { try (  Print Writer writer A = new  Print Writer ( new  File ( test Work Dir , _ STR ) ) ;  Print Writer writer B = new  Print Writer ( new  File ( test Work Dir , _ STR ) ) ) { char sep = _ STR ; int id B = _ NUM ; int id A = _ NUM ; int v = _ NUM ; for ( int i = _ NUM ; i < _ NUM ; i ++ ) { writer A . print ( id A ++ ) ; writer A . print ( sep ) ; writer A . println ( id B ) ; writer B . print ( id B ++ ) ; writer B . print ( sep ) ; writer B . println ( v += _ NUM ) ; writer B . print ( id B ++ ) ; writer B . print ( sep ) ; writer B . println ( v += _ NUM ) ; } writer A . flush ( ) ; writer B . flush ( ) ; } }
public void rename Editor Panel (  Editor panel ) { if ( panels List . size ( ) == _ NUM ) { return ; } for ( int i = _ NUM ; i < panels List . size ( ) ; i ++ ) {  Object o = panels List . get ( i ) ; if ( o == panel ) {  JCheck Box Menu Item r = (  JCheck Box Menu Item ) panels Sub Menu . get Item ( i ) ; r . set Text ( panel . get Title ( ) ) ; return ; } } }
private boolean fits As Single Line ( int col ) { return ( col + single Line Width ( ) <=  Pcal TLAGen . wrap Column ) || ( body Formulas . sf == null && ( prcd Formulas == null || prcd Formulas . size ( ) == _ NUM ) ) ; }
public void spherical To World (  Vector3 vec ) { if ( pj Unprojected == null ) {  String proj Str = _ STR + proj Info . get Semi Major Axis ( ) + _ STR + proj Info . get Semi Minor Axis ( ) + _ STR ; pj Unprojected =  Proj4 . new Instance ( proj Str ) ; } if ( pj Projected == null ) { pj Projected =  Proj4 . new Instance ( proj4 String ) ; } try { vec . to Array ( coord ) ; coord [ _ NUM ] =  Math . to Radians ( coord [ _ NUM ] ) ; coord [ _ NUM ] =  Math . to Radians ( coord [ _ NUM ] ) ; pj Unprojected . transform ( pj Projected , coord ) ; vec . set X ( coord [ _ NUM ] ) ; vec . set Y ( coord [ _ NUM ] ) ; } catch (  Exception e ) { e . print Stack Trace ( ) ; } }
public static  String encode Url ( final  String str ) { return encode ( str , _ STR ) ; }
public void draw Rendered Image (  Rendered Image img ,  Affine Transform xform ) { if ( img == null ) { return ; } m Print Metrics . draw Image ( this , img ) ; m Drawing Area . add Infinite ( ) ; }
private long build Size ( int duration In Seconds ,  Link Info linfo ) { long result = - _ NUM ; double bit Rate Sum = _ NUM ; switch ( linfo . fmt ) { case _ NUM : bit Rate Sum = _ NUM + _ NUM / _ NUM ; break ; case _ NUM : bit Rate Sum = _ NUM + _ NUM / _ NUM ; break ; case _ NUM : bit Rate Sum = _ NUM + _ NUM / _ NUM ; break ; case _ NUM : bit Rate Sum = _ NUM + _ NUM / _ NUM ; break ; case _ NUM : bit Rate Sum = _ NUM + _ NUM / _ NUM ; break ; case _ NUM : bit Rate Sum = _ NUM + _ NUM / _ NUM ; break ; case _ NUM : bit Rate Sum = _ NUM + _ NUM / _ NUM ; break ; case _ NUM : bit Rate Sum = _ NUM + _ NUM / _ NUM ; break ; case _ NUM : bit Rate Sum = _ NUM + _ NUM / _ NUM ; break ; case _ NUM : bit Rate Sum = _ NUM + _ NUM / _ NUM ; break ; case _ NUM : bit Rate Sum = _ NUM + _ NUM / _ NUM ; break ; case _ NUM : bit Rate Sum = _ NUM + _ NUM / _ NUM ; break ; case _ NUM : bit Rate Sum = _ NUM + _ NUM / _ NUM ; break ; case _ NUM : bit Rate Sum = _ NUM + _ NUM / _ NUM ; break ; case _ NUM : bit Rate Sum = _ NUM + _ NUM / _ NUM ; break ; case _ NUM : bit Rate Sum = _ NUM + _ NUM / _ NUM ; break ; case _ NUM : bit Rate Sum = _ NUM + _ NUM / _ NUM ; break ; case _ NUM : bit Rate Sum = _ NUM + _ NUM / _ NUM ; break ; case _ NUM : bit Rate Sum = _ NUM + _ NUM / _ NUM ; break ; case _ NUM : bit Rate Sum = _ NUM + _ NUM / _ NUM ; break ; case _ NUM : bit Rate Sum = _ NUM + _ NUM / _ NUM ; break ; case _ NUM : bit Rate Sum = _ NUM + _ NUM / _ NUM ; break ; case _ NUM : bit Rate Sum = _ NUM + _ NUM / _ NUM ; break ; case _ NUM : bit Rate Sum = _ NUM + _ NUM / _ NUM ; break ; case _ NUM : bit Rate Sum = _ NUM + _ NUM / _ NUM ; break ; case _ NUM : bit Rate Sum = _ NUM + _ NUM / _ NUM ; break ; case _ NUM : bit Rate Sum = _ NUM / _ NUM ; break ; case _ NUM : bit Rate Sum = _ NUM / _ NUM ; break ; case _ NUM : bit Rate Sum = _ NUM / _ NUM ; break ; } bit Rate Sum = bit Rate Sum * _ NUM * _ NUM ; result = ( long ) (  Math . ceil ( ( bit Rate Sum * duration In Seconds ) / _ NUM ) ) ; return result ; }
@  Override public void act On (  File f ) {  Buffered Reader reader = null ; try { reader = new  Buffered Reader ( new  File Reader ( f ) ) ; announce Seeds From Reader ( reader ) ; } catch (  File Not Found Exception fnf ) { logger . log (  Level .  SEVERE , _ STR , fnf ) ; } finally {  IOUtils . close Quietly ( reader ) ; } }
public void add Property Change Listener (  String property Name ,  Property Change Listener listener ) { property Change Support . add Property Change Listener ( property Name , listener ) ; }
public  File create New Folder (  File containing Dir ) throws  IOException { if ( containing Dir == null ) { throw new  IOException ( _ STR ) ; }  File new Folder = create File Object ( containing Dir , new Folder String ) ; int i = _ NUM ; while ( new Folder . exists ( ) && i < _ NUM ) { new Folder = create File Object ( containing Dir ,  Message Format . format ( new Folder Next String , new  Integer ( i ) ) ) ; i ++ ; } if ( new Folder . exists ( ) ) { throw new  IOException ( _ STR + new Folder . get Absolute Path ( ) ) ; } else { new Folder . mkdirs ( ) ; } return new Folder ; }
public  Resources Poet add Typed Array (  String name , @  Not Null  List <  String > values ) {  Element element = document . create Element ( _ STR ) ; element . set Attribute ( _ STR , name ) ; for (  String value : values ) {  Element value Element = document . create Element ( _ STR ) ; value Element . append Child ( document . create Text Node ( value ) ) ; element . append Child ( value Element ) ; } resource Element . append Child ( element ) ; return this ; }
public boolean add Sub Action ( final  Conf Action action Conf ) throws  General Exception ,  Configuration Exception { if ( action Conf . get Type ( ) != null ) { final  Sub Action sub =  Sub Action . factory ( action Conf . get Type ( ) , action Conf ) ; if ( sub == null ) { if (  Cfg .  DEBUG ) {  Check . log (  TAG + _ STR + action Conf . get Type ( ) ) ; } return _ BOOL ; } list . add ( sub ) ; if ( sub instanceof  Sub Action Slow ) { set Queue (  MAIN_ QUEUE ) ; } return _ BOOL ; } else { if (  Cfg .  DEBUG ) {  Check . log (  TAG + _ STR ) ; } return _ BOOL ; } }
void fill Entry Tree (  Set <  Page Leaf Entry > entries ,  Row row ) { int ptr = _row Head ; byte [ ] buffer = _buffer ; while ( ptr <  BLOCK_ SIZE ) { int code = buffer [ ptr ] &  CODE_ MASK ; int len = get Length ( code , row ) ; if ( code ==  INSERT || code ==  REMOVE ) {  Page Leaf Entry entry = new  Page Leaf Entry ( this , row , ptr , len , code ) ; entries . add ( entry ) ; } ptr += len ; } }
public static <  S > boolean contains Atleast One (  Collection <  S > left ,  Collection <  S > right ) { if ( left == null || right == null ) { return _ BOOL ; } for (  S id : left ) { if ( right . contains ( id ) ) { return _ BOOL ; } } return _ BOOL ; }
public void log Diff (  String id ,  String field ,  String db ,  String hw ) {  String Buffer diff Buffer = new  String Buffer (  String . format ( _ STR , id , field ) ) ; if ( db == null || db . is Empty ( ) || db . equals Ignore Case (  NO_ MATCHING_ ENTRY ) ) { diff Buffer . append (  String . format ( _ STR , hw ) ) ; } else if ( hw == null || hw . is Empty ( ) || hw . equals Ignore Case (  NO_ MATCHING_ ENTRY ) ) { diff Buffer . append (  String . format ( _ STR , db ) ) ; } else { diff Buffer . append (  String . format ( _ STR , db != null ? db : _ STR , hw != null ? hw : _ STR ) ) ; } msgs . append ( diff Buffer . to String ( ) + _ STR ) ; if ( log != null ) { log . info ( diff Buffer . to String ( ) ) ; } }
public  Field Frame Body IMG (  Lyrics3 Image image ) { images . add ( image ) ; }
public  Abstract Resource (  String mimetype ) { this ( mimetype ,  System . current Time Millis ( ) ) ; }
private  Parameters ( ) { for (  Iterator i = arguments . iterator ( ) ; i . has Next ( ) ; ) {  String arg = (  String ) i . next ( ) ; arg = arg . to Lower Case ( ) ; if ( ! arg . starts With ( _ STR ) ) throw new  Illegal Argument Exception ( _ STR + arg ) ; int colon Index = arg . index Of ( _ STR ) ;  String key ;  String value ; if ( colon Index >= _ NUM ) { key = arg . substring ( _ NUM , colon Index ) ; value = arg . substring ( colon Index + _ NUM ) ; } else { key = arg . substring ( _ NUM ) ; value = _ STR ; } if ( ! allowed Keys . contains ( key ) ) throw new  Illegal Argument Exception ( _ STR + arg . substring ( _ NUM ) + _ STR +  String Util . to Comma Delimited String ( allowed Keys ) ) ; hashtable . put ( key , value ) ; } for (  Iterator i = required Keys . iterator ( ) ; i . has Next ( ) ; ) {  String required Key = (  String ) i . next ( ) ; if ( ! hashtable . contains Key ( required Key ) ) throw new  Illegal Argument Exception ( _ STR + required Key ) ; } }
public  List <  TLV > init Respond Smp (  String question ,  String secret , boolean initiating ) throws  Otr Exception { if ( question != null && ! initiating ) throw new  Illegal Argument Exception ( _ STR ) ; byte [ ] our_fp =  Hex . decode ( key Manager . get Local Fingerprint ( session ID ) ) ;  String remote Fingerprint = key Manager . get Remote Fingerprint ( session ID ) ; if ( remote Fingerprint == null ) throw new  Otr Exception ( _ STR ) ; byte [ ] their_fp =  Hex . decode ( remote Fingerprint ) ; byte [ ] session Id ; try { session Id = compute Session Id ( session . get S ( ) ) ; } catch (  SMException ex ) { throw new  Otr Exception ( ex ) ; } byte [ ] bytes = secret . get Bytes (  Serialization Utils .  UTF8 ) ; int combined_buf_len = _ NUM + session Id . length + bytes . length ; byte [ ] combined_buf = new byte [ combined_buf_len ] ; combined_buf [ _ NUM ] = _ NUM ; if ( initiating ) {  System . arraycopy ( our_fp , _ NUM , combined_buf , _ NUM , _ NUM ) ;  System . arraycopy ( their_fp , _ NUM , combined_buf , _ NUM , _ NUM ) ; } else {  System . arraycopy ( their_fp , _ NUM , combined_buf , _ NUM , _ NUM ) ;  System . arraycopy ( our_fp , _ NUM , combined_buf , _ NUM , _ NUM ) ; }  System . arraycopy ( session Id , _ NUM , combined_buf , _ NUM , session Id . length ) ;  System . arraycopy ( bytes , _ NUM , combined_buf , _ NUM + session Id . length , bytes . length ) ;  Message Digest sha256 ; try { sha256 =  Message Digest . get Instance ( _ STR ) ; } catch (  No Such Algorithm Exception ex ) { throw new  Otr Exception ( ex ) ; } byte [ ] combined_secret = sha256 . digest ( combined_buf ) ; byte [ ] smpmsg ; try { if ( initiating ) { smpmsg =  SM . step1 ( smstate , combined_secret ) ; } else { smpmsg =  SM . step2b ( smstate , combined_secret ) ; } } catch (  SMException ex ) { throw new  Otr Exception ( ex ) ; } if ( question != null ) { bytes = question . get Bytes (  Serialization Utils .  UTF8 ) ; byte [ ] qsmpmsg = new byte [ bytes . length + _ NUM + smpmsg . length ] ;  System . arraycopy ( bytes , _ NUM , qsmpmsg , _ NUM , bytes . length ) ;  System . arraycopy ( smpmsg , _ NUM , qsmpmsg , bytes . length + _ NUM , smpmsg . length ) ; smpmsg = qsmpmsg ; }  TLV sendtlv = new  TLV ( initiating ? ( question != null ?  TLV .  SMP1 Q :  TLV .  SMP1 ) :  TLV .  SMP2 , smpmsg ) ; smstate . next Expected = initiating ?  SM .  EXPECT2 :  SM .  EXPECT3 ; return make Tlv List ( sendtlv ) ; }
private double mel To Lin Freq ( double input Freq ) { return ( _ NUM * (  Math . pow ( _ NUM , ( input Freq / _ NUM ) ) - _ NUM ) ) ; }
public  Rounded Icon Generator ( int icon Width Px , int icon Height Px , int corner Radius Px , int background Color , float text Size Px ) { m Icon Width Px = icon Width Px ; m Icon Height Px = icon Height Px ; m Corner Radius Px = corner Radius Px ; m Background Rect = new  Rect F ( _ NUM , _ NUM , m Icon Width Px , m Icon Height Px ) ; m Background Paint = new  Paint (  Paint .  ANTI_ ALIAS_ FLAG ) ; m Background Paint . set Color ( background Color ) ; m Text Paint = new  Text Paint (  Paint .  ANTI_ ALIAS_ FLAG ) ; m Text Paint . set Color (  Color .  WHITE ) ; m Text Paint . set Fake Bold Text ( _ BOOL ) ; m Text Paint . set Text Size ( text Size Px ) ;  Font Metrics text Font Metrics = m Text Paint . get Font Metrics ( ) ; m Text Height = ( float )  Math . ceil ( text Font Metrics . bottom - text Font Metrics . top ) ; m Text YOffset = - text Font Metrics . top ; }
public static byte [ ] random Bytes ( int size ) { byte [ ] bytes = new byte [ size ] ; seeded Random . next Bytes ( bytes ) ; return bytes ; }
@  Override public  String to String ( ) {  String Buffer  Bf String = new  String Buffer ( ) ;  Bf String . append ( _ STR ) ; if ( m_starting != null ) {  Bf String . append ( _ STR ) ;  Bf String . append ( start Set To String ( ) ) ;  Bf String . append ( _ STR ) ; } if ( m_threshold != -  Double .  MAX_ VALUE ) {  Bf String . append ( _ STR +  Utils . double To String ( m_threshold , _ NUM , _ NUM ) + _ STR ) ; } return  Bf String . to String ( ) ; }
protected void arraycopy ( byte [ ] buf , int pos , int length ) { m Message . write ( buf , pos , length ) ; m Position = m Position + length ; }
public boolean expired ( ) { return  System . current Time Millis ( ) - time >  DFLT_ EXPIRATION_ TIMEOUT ; }
private void handle Selection (  View view ,  Item item , int position ) { if ( ! item . is Selectable ( ) ) { return ; } if ( item . is Selected ( ) && ! m Allow Deselection ) { return ; } boolean selected = _ BOOL ; if ( m Position Based State Management ) { selected = m Selections . contains ( position ) ; } else { selected = item . is Selected ( ) ; } if ( m Select With Item Update || view == null ) { if ( ! m Multi Select ) { deselect ( ) ; } if ( selected ) { deselect ( position ) ; } else { select ( position ) ; } } else { if ( ! m Multi Select ) { if ( m Position Based State Management ) {  Iterator <  Integer > entries = m Selections . iterator ( ) ; while ( entries . has Next ( ) ) {  Integer pos = entries . next ( ) ; if ( pos != position ) { deselect ( pos , entries ) ; } } } else {  Set <  Integer > selections = get Selections ( ) ; for ( int pos : selections ) { if ( pos != position ) { deselect ( pos ) ; } } } } item . with Set Selected ( ! selected ) ; view . set Selected ( ! selected ) ; if ( m Selection Listener != null ) m Selection Listener . on Selection Changed ( item , ! selected ) ; if ( m Position Based State Management ) { if ( selected ) { if ( m Selections . contains ( position ) ) { m Selections . remove ( position ) ; } } else { m Selections . add ( position ) ; } } } }
public boolean can Invoke (  MDepreciation Workfile assetwk ,  MAsset Acct asset Acct , int  A_ Current_ Period ,  Big Decimal  Accum_ Dep ) { if ( assetwk == null ) { log . warning ( _ STR ) ; return _ BOOL ; } int offset = _ NUM ; int life Periods = assetwk . get Use Life Months ( assetwk . is Fiscal ( ) ) ; boolean ok = ( offset <=  A_ Current_ Period ) ; if (  CLog Mgt . is Level Finest ( ) ) log . finest ( _ STR +  A_ Current_ Period + _ STR + life Periods + _ STR + offset + _ STR + ok ) ; return ok ; }
public  Tree Map <  Float ,  List <  List <  Integer > > > pack Modified First Fit Descending ( ) { throw new  Unsupported Operation Exception ( _ STR ) ; }
public void add Text Change Listener ( final  Filter Query Change Listener text Change Listener ) { listeners . add ( text Change Listener ) ; }
@  Override public  Iterator <  Profile > iterator ( ) { return profiles . iterator ( ) ; }
private boolean starts With Space (  String str ) { return str . length ( ) != _ NUM && str . char At ( _ NUM ) == _ STR ; }
private int key To Level (  String key ) {  String [ ] token = key . split ( _ STR ) ; return ( token . length - _ NUM ) ; }
public boolean mouse Dragged (  Mouse Event e ) { if ( grabbed_plot_graphics_ ) { int x = e . get X ( ) ; int y = e . get Y ( ) ; int dx = x - prev X ; int dy = y - prev Y ; plot X += dx ; plot Y += dy ; prev X = x ; prev Y = y ; graph . resize ( plot X , plot Y , plot Width , plot Height ) ;  OMGraphic List plot Graphics = graph . get Plot Graphics ( ) ; plot Graphics . generate ( get Projection ( ) , _ BOOL ) ; repaint ( ) ; } return _ BOOL ; }
public void load (  General Subtrees general Subtrees ) {  List <  General Subtree > general Subtrees List = general Subtrees . get General Subtrees ( ) ;  Collections . sort ( general Subtrees List , new  General Subtree Base Comparator ( ) ) ; data = new  Object [ general Subtrees List . size ( ) ] [ _ NUM ] ; int i = _ NUM ; for (  General Subtree general Subtree : general Subtrees List ) { data [ i ] [ _ NUM ] = general Subtree ; data [ i ] [ _ NUM ] = general Subtree ; data [ i ] [ _ NUM ] = general Subtree ; i ++ ; } fire Table Data Changed ( ) ; }
public boolean is Ping Disabled ( ) { return ( null != healthcheck && ! healthcheck . exists ( ) ) ; }
public static void write To File (  File file ,  String contents ) throws  IOException {  File Output Stream fos = new  File Output Stream ( file ) ; fos . write ( contents . get Bytes ( ) ) ; fos . close ( ) ; }
public void make Tree Of Writables (  Iterable <  Pair <  String ,  Integer > > flat Data ) {  Text key = new  Text ( ) ; for (  Pair <  String ,  Integer > pair : flat Data ) { key . set ( pair . key ) ;  Array List <  Int Writable > val List ; if ( ! mock Input . contains Key ( key ) ) { val List = new  Array List < > ( ) ; mock Input . put ( key , val List ) ; key = new  Text ( ) ; } else val List = (  Array List <  Int Writable > ) mock Input . get ( key ) ; val List . add ( new  Int Writable ( pair . value ( ) ) ) ; } }
public static double angle (  Coordinate p0 ,  Coordinate p1 ) { double dx = p1 . x - p0 . x ; double dy = p1 . y - p0 . y ; return  Math . atan2 ( dy , dx ) ; }
public  In Memory Cursor (  String [ ] column Names ) { m Current Position = - _ NUM ; m Column Names = column Names ; }
@  Override public boolean is Enabled ( ) { if ( ( attribute Selection Panel != null ) && ! is Value Only ( ) ) { return attribute Selection Panel . is Enabled ( ) ; } else { if ( slider != null ) { return slider . is Enabled ( ) ; } } return _ BOOL ; }
private void render Foreground ( final  Execution Unit process , final  Graphics2 D g2 , boolean printing ) { if ( draw Highlight && ! printing && ( model . is Drag Started ( ) || model . is Drop Target Set ( ) && model . is Import Dragged ( ) ) || model . is Operator Source Hovered ( ) ) { switch (  Rapid Miner GUI . get Drag Highlighte Mode ( ) ) { case  FULL : case  BORDER : draw Drag Border ( process , g2 ) ; break ; case  NONE : default : break ; } } }
public  Modbus Transaction create Transaction ( ) {  Modbus Serial Transaction transaction = new  Modbus Serial Transaction ( ) ; transaction . set Transport ( this ) ; return transaction ; }
public void start ( ) { if ( runner == null ) { runner = new  Thread ( this , _ STR ) ; runner . start ( ) ; } }
protected final  File create DBFFDCDirectory ( ) {  File dbffdc Dir = new  File ( ffdc Directory Name ) ; if ( ! dbffdc Dir . exists ( ) ) { final boolean is DBFFDc Dir Created = dbffdc Dir . mkdirs ( ) ; if ( is DBFFDc Dir Created ) { dbffdc Dir = new  File ( ffdc Directory Name ) ; return dbffdc Dir ; } } else if ( ! dbffdc Dir . is Directory ( ) ) { return null ; } return dbffdc Dir ; }
public static  String read Character Sized String (  Input Stream stream ) throws  IOException {  String Builder result = new  String Builder ( ) ; int str Len = read UINT16 ( stream ) ; int character = stream . read ( ) ; character |= stream . read ( ) << _ NUM ; do { if ( character != _ NUM ) { result . append ( ( char ) character ) ; character = stream . read ( ) ; character |= stream . read ( ) << _ NUM ; } } while ( character != _ NUM || ( result . length ( ) + _ NUM ) > str Len ) ; if ( str Len != ( result . length ( ) + _ NUM ) ) { throw new  Illegal State Exception ( _ STR ) ; } return result . to String ( ) ; }
protected void process Children (  Query Node query Tree ) throws  Query Node Exception {  List <  Query Node > children = query Tree . get Children ( ) ;  Children List new Children ; if ( children != null && children . size ( ) > _ NUM ) { new Children = allocate Children List ( ) ; try { for (  Query Node child : children ) { child = process Iteration ( child ) ; if ( child == null ) { throw new  Null Pointer Exception ( ) ; } new Children . add ( child ) ; }  List <  Query Node > ordered Children List = set Children Order ( new Children ) ; query Tree . set ( ordered Children List ) ; } finally { new Children . being Used = _ BOOL ; } } }
private void initialize Messages (  List <  String > messages ) { messages . add All (  Arrays . as List (  Tip Of The Day Messages . get General Messages ( ) ) ) ; if (  OSUtils . is Windows ( ) ) { messages . add All (  Arrays . as List (  Tip Of The Day Messages . get Windows Messages ( ) ) ) ; } else if (  OSUtils . is Mac OSX ( ) ) { messages . add All (  Arrays . as List (  Tip Of The Day Messages . get Mac OSXMessages ( ) ) ) ; } else if (  OSUtils . is Linux ( ) ) { messages . add All (  Arrays . as List (  Tip Of The Day Messages . get Linux Messages ( ) ) ) ; } else { messages . add All (  Arrays . as List (  Tip Of The Day Messages . get Other Messages ( ) ) ) ; } if ( !  OSUtils . is Mac OSX ( ) ) { messages . add All (  Arrays . as List (  Tip Of The Day Messages . get Non Mac OSXMessages ( ) ) ) ; } messages . add All (  Arrays . as List (  Tip Of The Day Messages . get Frost Wire Messages ( ) ) ) ;  Collections . shuffle ( messages ) ; _current Tip = - _ NUM ; }
public  Persisted Queue ( final  File queue Env Path , final  String queue Name , final int cache Size ) { queue Env Path . mkdirs ( ) ; final  Environment Config db Env Config = new  Environment Config ( ) ; db Env Config . set Transactional ( _ BOOL ) ; db Env Config . set Allow Create ( _ BOOL ) ; this . db Env = new  Environment ( queue Env Path , db Env Config ) ;  Database Config db Config = new  Database Config ( ) ; db Config . set Transactional ( _ BOOL ) ; db Config . set Allow Create ( _ BOOL ) ; db Config . set Deferred Write ( _ BOOL ) ; this . queue Database = db Env . open Database ( null , queue Name , db Config ) ; this . queue Name = queue Name ; this . cache Size = cache Size ; this . ops Counter = _ NUM ; }
protected final  String Builder write (  String Builder sb , final  Object ... objects ) { for (  Object string : objects ) sb . append ( string ) ; return sb ; }
public void read External (  Object Input in ) throws  IOException ,  Class Not Found Exception { int vocab Size = in . read Int ( ) ; for ( int i = _ NUM ; i < vocab Size ; i ++ ) {  String line = in . read UTF ( ) ;  Vocabulary . id ( line ) ; } num Tokens = in . read Double ( ) ; count Funcs = new long [ in . read Int ( ) ] [ _ NUM ] ; for ( int i = _ NUM ; i < count Funcs . length ; i ++ ) { count Funcs [ i ] [ _ NUM ] = in . read Long ( ) ; count Funcs [ i ] [ _ NUM ] = in . read Long ( ) ; } types Funcs = new long [ in . read Int ( ) ] [ _ NUM ] ; for ( int i = _ NUM ; i < types Funcs . length ; i ++ ) { types Funcs [ i ] [ _ NUM ] = in . read Long ( ) ; types Funcs [ i ] [ _ NUM ] = in . read Long ( ) ; } quantization Base = in . read Double ( ) ; bf = new  Bloom Filter ( ) ; bf . read External ( in ) ; }
public static double compute MAD ( double [ ] x , double median ) { for ( int i = _ NUM ; i < x . length ; i ++ ) { x [ i ] =  Math . abs ( x [ i ] - median ) ; } double mad =  Quick Select . median ( x ) ; if ( ! ( mad > _ NUM ) ) { double min =  Double .  POSITIVE_ INFINITY ; for ( double xi : x ) { if ( xi > _ NUM && xi < min ) { min = xi ; } } if ( min <  Double .  POSITIVE_ INFINITY ) { mad = min ; } else { mad = _ NUM ; } } if ( mad ==  Double .  POSITIVE_ INFINITY ) { double max = _ NUM ; for ( double xi : x ) { if ( xi <  Double .  POSITIVE_ INFINITY && xi > max ) { max = xi ; } } if ( max <  Double .  POSITIVE_ INFINITY ) { mad = max ; } else { mad = _ NUM ; } } return mad ; }
public  Sdp Exception (  Throwable root Cause ) { super ( root Cause . get Localized Message ( ) ) ; }
protected void notify Property Change Listener (  String property ,  Object old Value ,  Object new Value ) {  Set <  Property Change Listener > v ; synchronized ( this ) { v = new  Hash Set < > ( listeners ) ; } for (  Property Change Listener listener : v ) { listener . property Change ( new  Property Change Event ( this , property , old Value , new Value ) ) ; } }
public boolean indicate Dirty Read (  ITemplate Holder template ) { return ( ( template . is Read Operation ( ) && _use Dirty Read ) || template . is Dirty Read Requested ( ) ) ; }
protected void apply Attributes To Symbol (  Tactical Graphic Attributes graphic Attributes ,  Tactical Symbol Attributes symbol Attributes ) {  Double value = graphic Attributes . get Interior Opacity ( ) ; if ( value != null ) { symbol Attributes . set Opacity ( value ) ; } value = graphic Attributes . get Scale ( ) ; if ( value != null ) { symbol Attributes . set Scale ( value ) ; }  Material material = graphic Attributes . get Interior Material ( ) ; symbol Attributes . set Interior Material ( material ) ;  Font font = graphic Attributes . get Text Modifier Font ( ) ; if ( font != null ) { symbol Attributes . set Text Modifier Font ( font ) ; } material = graphic Attributes . get Text Modifier Material ( ) ; if ( material != null ) { symbol Attributes . set Text Modifier Material ( material ) ; } }
public  Remote Service Descriptor (  String base Url ,  Http Json Request Factory request Factory ) throws  Illegal Argument Exception { this . base Url = base Url ; this . request Factory = request Factory ; try { final  URL base Url URL = new  URL ( base Url ) ; final  String protocol = base Url URL . get Protocol ( ) ; if ( ! ( protocol . equals ( _ STR ) || protocol . equals ( _ STR ) ) ) { throw new  Illegal Argument Exception (  String . format ( _ STR , base Url ) ) ; } } catch (  Malformed URLException e ) { throw new  Illegal Argument Exception (  String . format ( _ STR , base Url ) ) ; } }
public  Server start ( ) throws  SQLException { try { started = _ BOOL ; service . start ( ) ;  String name = service . get Name ( ) + _ STR + service . get URL ( ) + _ STR ;  Thread t = new  Thread ( this , name ) ; t . set Daemon ( service . is Daemon ( ) ) ; t . start ( ) ; for ( int i = _ NUM ; i < _ NUM ; i += i ) { wait ( i ) ; if ( is Running ( _ BOOL ) ) { return this ; } } if ( is Running ( _ BOOL ) ) { return this ; } throw  Db Exception . get (  Error Code .  EXCEPTION_ OPENING_ PORT_2 , name , _ STR + _ STR ) ; } catch (  Db Exception e ) { throw  Db Exception . to SQLException ( e ) ; } }
@  Override public boolean is Complete ( ) { return _ BOOL ; }
public  Byte Matrix encode (  String contents , int width , int height ,  Map <  Encode Hint Type ,  Object > hints ) throws  Writer Exception { if ( contents == null || contents . length ( ) == _ NUM ) { throw new  Illegal Argument Exception ( _ STR ) ; } if ( width < _ NUM || height < _ NUM ) { throw new  Illegal Argument Exception ( _ STR + width + _ STR + height ) ; }  Error Correction Level error Correction Level =  Error Correction Level .  L ; if ( hints != null ) {  Error Correction Level requested ECLevel = (  Error Correction Level ) hints . get (  Encode Hint Type .  ERROR_ CORRECTION ) ; if ( requested ECLevel != null ) { error Correction Level = requested ECLevel ; } }  QRCode code = new  QRCode ( ) ;  Encoder . encode ( contents , error Correction Level , hints , code ) ; return render Result ( code , width , height ) ; }
public  Request header (  String key ,  String value ) {  Objects . require Non Null ( key ) ;  Objects . require Non Null ( value ) ; _headers . put ( key , value ) ; return this ; }
public void update UI ( ) { super . update UI ( ) ; set Background ( new  Color ( _ NUM , _ NUM , _ NUM , _ NUM ) ) ; set Wrap Style Word ( _ BOOL ) ; set Highlighter ( null ) ; set Editable ( _ BOOL ) ;  Look And Feel . install Border ( this , _ STR ) ;  Look And Feel . install Colors And Font ( this , _ STR , _ STR , _ STR ) ; if ( resize Handler != null ) { resize Handler . component Resized ( null ) ; }  Size Policy policy = (  Size Policy ) get Client Property (  Size Policy . class ) ; if ( policy != null ) {  GUIUtils . restrict Size ( this , policy ) ; } }
public static void generate Extension Manager (  File root Folder ) throws  IOException {  File out File = new  File ( root Folder ,  REGISTRY_ PATH ) ;  String Builder builder = new  String Builder ( ) ; builder . append ( _ STR ) ; generate Imports ( builder ) ; generate Class ( builder ) ;  File Utils . write String To File ( out File , builder . to String ( ) ) ; }
public synchronized  Future <  V > submit (  Callable <  V > task ) throws  Rejected Execution Exception { return pool . submit ( task ) ; }
private void check Bucket Name (  String name ) throws  Invalid Bucket Name Exception { if ( name == null ) { throw new  Invalid Bucket Name Exception (  NULL_ STRING , _ STR ) ; } if ( name . length ( ) < _ NUM || name . length ( ) > _ NUM ) {  String msg = _ STR ; throw new  Invalid Bucket Name Exception ( name , msg ) ; } if ( name . matches ( _ STR ) ) {  String msg = _ STR + _ STR ; throw new  Invalid Bucket Name Exception ( name , msg ) ; } if ( ! name . matches ( _ STR ) ) {  String msg = _ STR + _ STR ; throw new  Invalid Bucket Name Exception ( name , msg ) ; } }
private void validate User Namespace Authorization Create Request (  User Namespace Authorization Create Request request ) {  Assert . not Null ( request , _ STR ) ; validate User Namespace Authorization Key ( request . get User Namespace Authorization Key ( ) ) ; validate Namespace Permissions ( request . get Namespace Permissions ( ) ) ; }
protected  String format (  Object o ) { return o . to String ( ) ; }
public void calculate Derived ( ) { x Stats . calculate Derived ( ) ; y Stats . calculate Derived ( ) ; differences Stats . calculate Derived ( ) ; correlation =  Double .  Na N ; if ( !  Double . is Na N ( x Stats . std Dev ) && !  Double . is Na N ( y Stats . std Dev ) && !  Utils . eq ( x Stats . std Dev , _ NUM ) ) { double slope = ( xy Sum - x Stats . sum * y Stats . sum / count ) / ( x Stats . sum Sq - x Stats . sum * x Stats . mean ) ; if ( !  Utils . eq ( y Stats . std Dev , _ NUM ) ) { correlation = slope * x Stats . std Dev / y Stats . std Dev ; } else { correlation = _ NUM ; } } if (  Utils . gr ( differences Stats . std Dev , _ NUM ) ) { double tval = differences Stats . mean *  Math . sqrt ( count ) / differences Stats . std Dev ; if ( m_degrees Of Freedom >= _ NUM ) { differences Probability =  Statistics .  FProbability ( tval * tval , _ NUM , m_degrees Of Freedom ) ; } else { if ( count > _ NUM ) { differences Probability =  Statistics .  FProbability ( tval * tval , _ NUM , ( int ) count - _ NUM ) ; } else { differences Probability = _ NUM ; } } } else { if ( differences Stats . sum Sq == _ NUM ) { differences Probability = _ NUM ; } else { differences Probability = _ NUM ; } } differences Significance = _ NUM ; if ( differences Probability <= sig Level ) { if ( x Stats . mean > y Stats . mean ) { differences Significance = _ NUM ; } else { differences Significance = - _ NUM ; } } }
protected boolean can Delete Consistency Group ( final  Block Consistency Group consistency Group ) { return ( ! consistency Group . get Inactive ( ) && ! consistency Group . created ( ) ) ; }
public  Amqp Message receive No Wait ( ) throws  Exception { check Closed ( ) ; return prefetch . poll ( ) ; }
private boolean zz Refill ( ) throws java . io .  IOException { if ( zz Start Read > _ NUM ) {  System . arraycopy ( zz Buffer , zz Start Read , zz Buffer , _ NUM , zz End Read - zz Start Read ) ; zz End Read -= zz Start Read ; zz Current Pos -= zz Start Read ; zz Marked Pos -= zz Start Read ; zz Pushback Pos -= zz Start Read ; zz Start Read = _ NUM ; } if ( zz Current Pos >= zz Buffer . length ) { final char new Buffer [ ] = new char [ zz Current Pos * _ NUM ] ;  System . arraycopy ( zz Buffer , _ NUM , new Buffer , _ NUM , zz Buffer . length ) ; zz Buffer = new Buffer ; } final int num Read = zz Reader . read ( zz Buffer , zz End Read , zz Buffer . length - zz End Read ) ; if ( num Read < _ NUM ) { return _ BOOL ; } else { zz End Read += num Read ; return _ BOOL ; } }
private void check Duplicate Names During Delete (  List <  Integer > ids ) {  Array List <  Entity > my Entities = game . get Player Entities ( game . get Player ( local Player Number ) , _ BOOL ) ;  Hashtable <  String ,  Array List <  Integer > > raw Name To Id = new  Hashtable <  String ,  Array List <  Integer > > ( ( int ) ( my Entities . size ( ) * _ NUM ) ) ; for (  Entity e : my Entities ) {  String raw Name = e . get Short Name Raw ( ) ;  Array List <  Integer > named Ids = raw Name To Id . get ( raw Name ) ; if ( named Ids == null ) { named Ids = new  Array List <  Integer > ( ) ; } named Ids . add ( e . get Id ( ) ) ; raw Name To Id . put ( raw Name , named Ids ) ; } for ( int id : ids ) {  Entity removed Entity = game . get Entity ( id ) ; if ( removed Entity == null ) { continue ; }  String removed Raw Name = removed Entity . get Short Name Raw ( ) ;  Integer count = duplicate Name Hash . get ( removed Entity . get Short Name Raw ( ) ) ; if ( ( count != null ) && ( count > _ NUM ) ) {  Array List <  Integer > named Ids = raw Name To Id . get ( removed Raw Name ) ; for (  Integer i : named Ids ) {  Entity e = game . get Entity ( i ) ;  String e Raw Name = e . get Short Name Raw ( ) ; if ( e Raw Name . equals ( removed Raw Name ) && ( e . duplicate Marker > removed Entity . duplicate Marker ) ) { e . duplicate Marker -- ; e . generate Short Name ( ) ; e . generate Display Name ( ) ; if ( ! ids . contains ( e . get Id ( ) ) ) { send Update Entity ( e ) ; } } } duplicate Name Hash . put ( removed Entity . get Short Name Raw ( ) , new  Integer ( count - _ NUM ) ) ; } else if ( count != null ) { duplicate Name Hash . remove ( removed Entity . get Short Name Raw ( ) ) ; } } }
protected void stop BKCluster ( ) throws  Exception { if ( bkc != null ) { bkc . close ( ) ; } for (  Bookie Server server : bs ) { server . shutdown ( ) ;  Auto Recovery Main auto Recovery = auto Recovery Processes . get ( server ) ; if ( auto Recovery != null && is Auto Recovery Enabled ( ) ) { auto Recovery . shutdown ( ) ;  LOG . debug ( _ STR + server . get Local Address ( ) ) ; } } bs . clear ( ) ; for (  File f : tmp Dirs ) {  File Utils . delete Directory ( f ) ; } }
public void release Selections (  Set <  Entity > items ) { for (  Entity item : items ) { release Selection ( item ) ; } }
public  Hub Link Mapping (  String file Name , int number Of Hubs ,  Network network ) { this . number Of Hubs = number Of Hubs ; if ( file Name . contains ( _ STR ) ) { read Mapping Table ( file Name ) ; un Mapped Links At Zero Hub = _ BOOL ; return ; } handle Unmapped Links Start ( ) ; try {  File Reader fr = new  File Reader ( file Name ) ;  Buffered Reader br = new  Buffered Reader ( fr ) ;  String line ;  String Tokenizer tokenizer ;  String token ; int link Id ; line = br . read Line ( ) ; while ( line != null ) { tokenizer = new  String Tokenizer ( line ) ; for ( int i = _ NUM ; i < this . number Of Hubs ; i ++ ) { token = tokenizer . next Token ( ) ; link Id = ( int )  Double . parse Double ( token ) ; link Hub Mapping . put (  Integer . to String ( link Id ) , i ) ; } if ( tokenizer . has More Tokens ( ) ) { throw new  Runtime Exception ( _ STR ) ; } line = br . read Line ( ) ; } } catch (  Runtime Exception e ) { throw e ; } catch (  Exception e ) { throw new  Runtime Exception ( _ STR ) ; } link Hub Mapping . remove ( _ STR ) ; handle Unmapped Links End ( network ) ; }
public boolean delete Load Name (  String load ) { if ( ! _load List . contains ( load ) ) { return _ BOOL ; } _load List . remove ( load ) ; log . debug ( _ STR + get Name ( ) + _ STR + load ) ; set Dirty And Fire Property Change (  LOADS_ CHANGED_ PROPERTY , _load List . size ( ) + _ NUM , _load List . size ( ) ) ; return _ BOOL ; }
private  Compute State validate Compute Name (  String aws Id ,  String vm Name ) throws  Throwable { if ( this . is Aws Client Mock ) { return null ; }  Compute State compute State = get Compute By AWSId ( this . host , aws Id ) ;  String tag Name Value = compute State . name ; assert Not Null ( _ STR , tag Name Value ) ; assert Equals ( vm Name , tag Name Value ) ; return compute State ; }
public static  String from Tag (  Int Array Tag tag ) {  String Builder builder = new  String Builder ( ) ; builder . append (  ARRAY_ START ) ; boolean start = _ BOOL ; for ( int value : tag . get Value ( ) ) {  Int Tag i = new  Int Tag ( value ) ; if ( start ) { start = _ BOOL ; } else { builder . append (  ELEMENT_ SEPERATOR ) ; } builder . append ( from Tag ( i ) ) ; } builder . append (  ARRAY_ END ) ; return builder . to String ( ) ; }
public static int remove Args And Return Insertion Index (  List <  String > args , int arg Index , boolean try Removing Arg Value ) { if ( arg Index < _ NUM || arg Index >= args . size ( ) ) { return _ NUM ; } if ( try Removing Arg Value ) {  String arg Value = get Arg Value ( args , arg Index + _ NUM ) ; if ( arg Value != null ) { args . remove ( arg Index + _ NUM ) ; } } args . remove ( arg Index ) ; return arg Index ; }
void replace Policy In Resource Tree (  Service Type Manager svtm ,  SSOToken token ,  Policy old Policy ,  Policy new Policy ) throws  Policy Exception ,  SSOException { remove Policy From Resource Tree ( svtm , token , old Policy ) ; add Policy To Resource Tree ( svtm , token , new Policy ) ; }
public  Atomic Double Array ( int length ) { larray = new  Atomic Long Array ( length ) ; long  ZERO =  Double . double To Raw Long Bits ( _ NUM ) ; for ( int i = _ NUM ; i < length ; i ++ ) larray . set ( i ,  ZERO ) ; }
private void recompute Seperation ( double [ ] [ ] means , double [ ] [ ] cdist ,  Long Statistic diststat ) { final int k = means . length ; for ( int i = _ NUM ; i < k ; i ++ ) {  Double Vector mi =  Double Vector . wrap ( means [ i ] ) ; for ( int j = _ NUM ; j < i ; j ++ ) { cdist [ i ] [ j ] = cdist [ j ] [ i ] = distance Function . distance ( mi ,  Double Vector . wrap ( means [ j ] ) ) ; } } if ( diststat != null ) { diststat . increment ( ( k * ( k - _ NUM ) ) > > _ NUM ) ; } }
private static  Buffered Image make Square (  Buffered Image input ) { if ( input . get Height ( ) == input . get Width ( ) ) { return input ; } else { int max =  Math . max ( input . get Height ( ) , input . get Width ( ) ) ; int dx = ( max - input . get Width ( ) ) / _ NUM ; int dy = ( max - input . get Height ( ) ) / _ NUM ; return create Img ( max , max , input . get Type ( ) , null ) ; } }
public void write Start Element (  String local Name ) throws  XMLStream Exception { if ( local Name == null || local Name . length ( ) == _ NUM ) { throw new  XMLStream Exception ( _ STR ) ; } _state =  STATE_ ELEMENT ; if ( _current Ele != null && _current Ele . get State ( ) ==  ELEMENT_ STARTTAG_ OPEN ) { close Start Tag ( ) ; } _current Ele = new  Element ( _current Ele , local Name , _ BOOL ) ; open Start Tag ( ) ; _writer . write ( local Name ) ; }
public void add Process Interaction Listener ( final  Process Interaction Listener l ) { if ( l == null ) { throw new  Illegal Argument Exception ( _ STR ) ; } process Interaction Listeners . add ( l ) ; }
private void traverse Internal (  Object root , boolean yield Root ,  Identity Hash Map <  Object ,  Object > seen ) { if ( root == null || seen . contains Key ( root ) ) { return ; } if ( yield Root ) { if ( ! visit ( root ) ) { return ; } } seen . put ( root , root ) ; if ( root instanceof  JSONObject ) {  JSONObject json = (  JSONObject ) root ;  Iterator <  String > keys = json . keys ( ) ; while ( keys . has Next ( ) ) {  String key = keys . next ( ) ; try { traverse Internal ( json . get ( key ) , _ BOOL , seen ) ; } catch (  JSONException e ) { throw new  Runtime Exception ( e ) ; } } } else if ( root instanceof  JSONArray ) {  JSONArray array = (  JSONArray ) root ; for ( int i = _ NUM ; i < array . length ( ) ; ++ i ) { try { traverse Internal ( array . get ( i ) , _ BOOL , seen ) ; } catch (  JSONException e ) { throw new  Runtime Exception ( e ) ; } } } else if ( root instanceof  Map ) {  Map < ? , ? > map = (  Map < ? , ? > ) root ; for (  Object value : map . values ( ) ) { traverse Internal ( value , _ BOOL , seen ) ; } } else if ( root instanceof  List ) {  List < ? > list = (  List < ? > ) root ; for (  Object value : list ) { traverse Internal ( value , _ BOOL , seen ) ; } } else if ( root instanceof  Parse Object ) { if ( traverse Parse Objects ) {  Parse Object object = (  Parse Object ) root ; for (  String key : object . key Set ( ) ) { traverse Internal ( object . get ( key ) , _ BOOL , seen ) ; } } } else if ( root instanceof  Parse ACL ) {  Parse ACL acl = (  Parse ACL ) root ;  Parse User user = acl . get Unresolved User ( ) ; if ( user != null && user . is Current User ( ) ) { traverse Internal ( user , _ BOOL , seen ) ; } } }
public  Str Builder replace First ( final  String search Str , final  String replace Str ) { final int search Len = ( search Str == null ? _ NUM : search Str . length ( ) ) ; if ( search Len > _ NUM ) { final int index = index Of ( search Str , _ NUM ) ; if ( index >= _ NUM ) { final int replace Len = ( replace Str == null ? _ NUM : replace Str . length ( ) ) ; replace Impl ( index , index + search Len , search Len , replace Str , replace Len ) ; } } return this ; }
protected abstract void internal Put ( int index , byte b ) ;
public  Common Turnout Operation Config (  Turnout Operation op ) { super ( op ) ; my Op = (  Common Turnout Operation ) op ; max Tries Spinner = new  JSpinner ( ) ; interval Spinner = new  JSpinner ( ) ;  Box vbox =  Box . create Vertical Box ( ) ;  Box hbox1 =  Box . create Horizontal Box ( ) ;  Box hbox2 =  Box . create Horizontal Box ( ) ; vbox . add ( hbox2 ) ; vbox . add ( hbox1 ) ; vbox . add (  Box . create Vertical Glue ( ) ) ; hbox1 . add ( new  JLabel (  Bundle . get Message ( _ STR ) ) ) ; hbox1 . add (  Box . create Horizontal Glue ( ) ) ; interval Spinner . set Minimum Size ( new  Dimension ( _ NUM , _ NUM ) ) ; interval Spinner . set Model ( new  Spinner Number Model ( my Op . get Interval ( ) ,  Common Turnout Operation . min Interval ,  Common Turnout Operation . max Interval ,  Common Turnout Operation . interval Step Size ) ) ; hbox1 . add ( interval Spinner ) ; hbox2 . add ( new  JLabel (  Bundle . get Message ( _ STR ) ) ) ; hbox2 . add (  Box . create Horizontal Glue ( ) ) ; max Tries Spinner . set Minimum Size ( new  Dimension ( _ NUM , _ NUM ) ) ; max Tries Spinner . set Model ( new  Spinner Number Model ( my Op . get Max Tries ( ) ,  Common Turnout Operation . min Max Tries ,  Common Turnout Operation . max Max Tries , _ NUM ) ) ; hbox2 . add ( max Tries Spinner ) ;  Box hbox3 =  Box . create Horizontal Box ( ) ; hbox3 . add (  Box . create Horizontal Strut ( _ NUM ) ) ; vbox . add ( hbox3 ) ; add ( vbox ) ; }
public  String find Interlanguage Link (  String lang ) { int start = page . index Of ( _ STR + lang + _ STR ) ; if ( start < _ NUM ) return null ; int end = page . index Of ( _ STR , start ) ; if ( end < _ NUM ) return null ;  String link = page . substring ( start + _ NUM + lang . length ( ) , end ) ; if ( link . index Of ( _ STR ) != - _ NUM ) { return null ; } if ( link . length ( ) == _ NUM ) return null ; return link ; }
private void update Actions ( final  INavi Address Space address Space ) { m_load Address Space Action . set Enabled ( ! address Space . is Loaded ( ) ) ; }
public static <  T >  Parallel Flux <  T > from (  Publisher < ? extends  T > source , int parallelism ) { return from ( source , parallelism ,  Queue Supplier .  SMALL_ BUFFER_ SIZE ,  Queue Supplier . small ( ) ) ; }
private void add Gumball ( float x Pos , float y Pos ) {  Gumball gumball = new  Gumball ( ) ; gumball . m XInit Pos = x Pos ; gumball . m YInit Pos = y Pos ; gumball . m Sound Pool Id =  UUID . random UUID ( ) ; m Sound Pool Id . put ( gumball . m Sound Pool Id , _ BOOL ) ; m Game View . add Gumball ( gumball ) ; m Sound Pool . play ( m Sound Ball Drop , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM ) ; }
int put (  T segment ,  List < ? super  T > recycle Bin ) { int count ; if ( last Count == _ NUM ) { count = _ NUM ; last Count = _ NUM ; last = segment ; } else if (  Objects . deep Equals ( last , segment ) ) { ++ last Count ; count = _ NUM ; recycle Bin . add ( segment ) ; } else { count = last Count ; last Count = _ NUM ; last = segment ; } return count ; }
public  Channel chan ( final  String topic , final  Json Node payload ) {  LOG . log (  Level .  FINE , _ STR , new  Object [ ] { topic , payload } ) ; final  Channel channel = new  Channel ( topic , payload ,  Socket . this ) ; synchronized ( channels ) { channels . add ( channel ) ; } return channel ; }
public  Pla Point Float change_size ( double p_new_size ) { if ( v_x == _ NUM && v_y == _ NUM ) { return this ; } double length =  Math . sqrt ( v_x * v_x + v_y * v_y ) ; double new_x = ( v_x * p_new_size ) / length ; double new_y = ( v_y * p_new_size ) / length ; return new  Pla Point Float ( new_x , new_y ) ; }
int insert (  Row row , byte [ ] source Buffer , int source Offset ,  Blob Output Stream [ ] blobs ) { int row Head = _row Head ; int blob Tail = _blob Tail ; int row Length = row . length ( ) ; row Head -= row Length ; if ( row Head < blob Tail ) { return - _ NUM ; } byte [ ] buffer = _buffer ;  System . arraycopy ( source Buffer , source Offset , buffer , row Head , row Length ) ; buffer [ row Head ] = ( byte ) ( ( buffer [ row Head ] & ~  CODE_ MASK ) |  INSERT ) ; blob Tail = row . insert Blobs ( buffer , row Head , blob Tail , blobs ) ; if ( blob Tail < _ NUM ) { return - _ NUM ; } set Blob Tail ( blob Tail ) ; row Head ( row Head ) ; validate Block ( row ) ; return row Head ; }
private void add Default Uri ( ) throws  Ignite Spi Exception { assert uri Encoded List != null ;  URI uri ; try { uri =  U . resolve Work Directory (  DFLT_ DEPLOY_ DIR , _ BOOL ) . to URI ( ) ; } catch (  Ignite Checked Exception e ) { throw new  Ignite Spi Exception ( _ STR , e ) ; } uri Encoded List . add ( uri ) ; }
protected void transfer (  String seq Range ) throws  IOException { try { final int range Pos = seq Range . index Of ( _ STR ) ; if ( range Pos == - _ NUM ) { transfer (  Long . parse Long ( seq Range ) ) ; } else { final  String start = seq Range . substring ( _ NUM , range Pos ) ; final  String end = seq Range . substring ( range Pos + _ NUM ) ; final long start Idx ; if ( start . length ( ) == _ NUM ) { start Idx = _ NUM ; } else { start Idx =  Long . parse Long ( start ) ; } final long end Idx ; if ( end . length ( ) == _ NUM ) { end Idx = m Reader . number Sequences ( ) - _ NUM ; } else { end Idx =  Long . parse Long ( end ) ; } if ( start Idx > end Idx ) { throw new  Number Format Exception ( _ STR + seq Range ) ; } for ( long i = start Idx ; i <= end Idx ; i ++ ) { transfer ( i ) ; } } } catch ( final  Number Format Exception e ) { warn Invalid Sequence ( seq Range ) ; } }
public static double distance Point Line Perpendicular (  Coordinate p ,  Coordinate  A ,  Coordinate  B ) { double len2 = (  B . x -  A . x ) * (  B . x -  A . x ) + (  B . y -  A . y ) * (  B . y -  A . y ) ; double s = ( (  A . y - p . y ) * (  B . x -  A . x ) - (  A . x - p . x ) * (  B . y -  A . y ) ) / len2 ; return  Math . abs ( s ) *  Math . sqrt ( len2 ) ; }
public  String patch Fix Ids ( ) { return properties . get Property ( _ STR ) ; }
public final void read Fully ( byte [ ] b ) throws java . io .  IOException { read Fully ( b , _ NUM , b . length ) ; }
private void create Gui ( ) { final  JPanel outer Name Panel = new  JPanel ( new  Border Layout ( ) ) ; outer Name Panel . set Border ( new  Titled Border ( _ STR ) ) ; final  JPanel name Panel = new  JPanel ( new  Border Layout ( ) ) ; name Panel . set Border ( new  Empty Border ( _ NUM , _ NUM , _ NUM , _ NUM ) ) ; final  JLabel name Label = new  CHelp Label ( _ STR + _ STR , new  CName Help ( ) ) ; name Label . set Preferred Size ( new  Dimension ( _ NUM , _ NUM ) ) ; name Panel . add ( name Label ,  Border Layout .  WEST ) ; name Panel . add ( m_name Text Field ,  Border Layout .  CENTER ) ; outer Name Panel . add ( name Panel ,  Border Layout .  CENTER ) ; final  JPanel outer Description Panel = new  JPanel ( new  Border Layout ( ) ) ; outer Description Panel . set Border ( new  Empty Border ( _ NUM , _ NUM , _ NUM , _ NUM ) ) ; final  JPanel description Panel = new  JPanel ( new  Border Layout ( ) ) ; description Panel . set Border ( new  Titled Border ( _ STR ) ) ; description Panel . set Minimum Size ( new  Dimension ( _ NUM , _ NUM ) ) ; description Panel . add ( new  JScroll Pane ( m_description Field ) ) ; outer Description Panel . add ( description Panel ,  Border Layout .  CENTER ) ; final  JPanel button Panel = new  JPanel ( new  Grid Layout ( _ NUM , _ NUM ) ) ; button Panel . add ( new  JPanel ( ) ) ; button Panel . set Border ( new  Empty Border ( _ NUM , _ NUM , _ NUM , _ NUM ) ) ; button Panel . add ( m_save Button ) ; final  JPanel top Panel = new  JPanel ( new  Border Layout ( ) ) ; top Panel . add ( outer Name Panel ,  Border Layout .  NORTH ) ; top Panel . add ( outer Description Panel ,  Border Layout .  CENTER ) ; top Panel . add ( button Panel ,  Border Layout .  SOUTH ) ; final  JPanel bottom Panel = new  JPanel ( new  Border Layout ( ) ) ; bottom Panel . set Border ( m_table Border ) ; final  JScroll Pane scroll Pane = new  JScroll Pane ( m_children Tag Table ) ; bottom Panel . add ( scroll Pane ,  Border Layout .  CENTER ) ; final  JSplit Pane split Pane = new  JSplit Pane (  JSplit Pane .  VERTICAL_ SPLIT , _ BOOL , top Panel , bottom Panel ) ; split Pane . set One Touch Expandable ( _ BOOL ) ; split Pane . set Divider Location ( split Pane . get Minimum Divider Location ( ) ) ; split Pane . set Resize Weight ( _ NUM ) ; add ( split Pane ) ; }
public static boolean is Jellybean Or Later ( ) { return  Build .  VERSION .  SDK_ INT >=  Build .  VERSION_ CODES .  JELLY_ BEAN ; }
public  Partial Correlation Pdf ( int n , int k ) { this . n = n ; this . k = k ; double gamma Ratio = gamma Ratio ( n , k ) ; this . constant = ( _ NUM /  Math . pow (  Math .  PI , _ NUM ) ) * gamma Ratio ; this . outside Exp = ( double ) ( n - k - _ NUM ) / _ NUM ; }
private static boolean is Enabled ( ) { if (  System Utils .  IS_ OS_ WINDOWS ) { return _ BOOL ; } try {  List <  String > lines =  Command Util . execute Command And Get Lines (  Collections . singleton List ( _ STR ) ) ; for (  String line : lines ) { if ( line . contains ( _ STR ) ) { if ( line . contains ( _ STR ) ) {  Logger . info ( _ STR ) ; return _ BOOL ; } return _ BOOL ; } } } catch (  Exception ex ) { } return _ BOOL ; }
public boolean validate ( ) { output File = new  File ( output Path ) ; if ( output File . exists ( ) || output File . is Directory ( ) ) { invalid Message = _ STR ; return valid = _ BOOL ; } if ( ! sign Mode ) { key File = new  File ( key File Path ) ; if ( ! key File . exists ( ) || key File . is Directory ( ) ) { invalid Message = _ STR ; return valid = _ BOOL ; } } return valid = _ BOOL ; }
public void add Response Code Listener (  Action Listener a ) { response Code Listeners . add Element ( a ) ; }
public double calculate Log Likelihood ( ) { double log L = _ NUM ; for (  Statistic statistic : data List ) { for ( int j = _ NUM ; j < statistic . get Dimension ( ) ; j ++ ) { log L -=  Math . log ( statistic . get Statistic Value ( j ) ) ; } } return log L ; }
public static boolean has Dead States From Initial (  Automaton a ) {  Bit Set reachable From Initial = get Live States From Initial ( a ) ;  Bit Set reachable From Accept = get Live States To Accept ( a ) ; reachable From Initial . and Not ( reachable From Accept ) ; return reachable From Initial . is Empty ( ) == _ BOOL ; }
public  Decimal subtract (  Decimal decimal ) { assert Defined ( ) ; if ( null == m_value ) { return ( decimal ) ; }  Big Decimal value = m_value . subtract ( decimal . get Big Decimal Value ( ) ) ; return new  Decimal ( value ,  SCALE ) ; }
public final boolean equals (  Object object ) { if ( object == null ) { return _ BOOL ; } if ( ! ( object instanceof  Knowledge Edge ) ) { return _ BOOL ; }  Knowledge Edge pair = (  Knowledge Edge ) object ; return from . equals ( pair . from ) && to . equals ( pair . to ) ; }
protected int skip Line ( int c ) throws  IOException { while ( c != - _ NUM && c != _ STR && c != _ STR ) { c = reader . read ( ) ; } if ( c == _ STR ) { c = reader . read ( ) ; line No ++ ; report Location ( line No , _ NUM ) ; } else if ( c == _ STR ) { c = reader . read ( ) ; if ( c == _ STR ) { c = reader . read ( ) ; } line No ++ ; report Location ( line No , _ NUM ) ; } return c ; }
@  Override public void list Volumes (  Command Input input ,  Completion Handler completion Handler ) { create Or Update Target Ssl ( input ) ;  URI uri =  Uri Utils . extend Uri ( input . get Docker Uri ( ) , _ STR ) ; send Get ( uri , null , completion Handler ) ; }
public static  Byte Buffer base64 String To Byte Buffer (  String base64 Encoded Key ) { return  Byte Buffer . wrap ( base64 Decode String ( base64 Encoded Key ) ) ; }
public boolean step ( ) { long current =  System . current Time Millis ( ) ; if ( m Start == _ NUM || ( current - m Start < _ NUM ) ) { m Progress = _ NUM ; } else if ( current - m Start > m Duration ) { if ( m Loop ) { m Progress = _ NUM ; start ( ) ; return _ BOOL ; } m Progress = _ NUM ; return _ BOOL ; } else { m Progress = ( current - m Start ) / ( double ) m Duration ; } return _ BOOL ; }
protected void load_raw_characters (  String Builder sb ) throws  IOException { int c = read_char ( ) ; for ( ; ; ) { c = read_char ( ) ; switch ( c ) { case  Character Sequence .  CHAR_ SEQ_ ESCAPED_ NEWLINE_ SEQUENCE_1 : case  Character Sequence .  CHAR_ SEQ_ ESCAPED_ NEWLINE_ SEQUENCE_2 : case  Character Sequence .  CHAR_ SEQ_ ESCAPED_ NEWLINE_ SEQUENCE_3 : continue ; case - _ NUM : return ; default : if ( !  Ion Token Consts X . is7bit Value ( c ) ) { c = read_large_char_sequence ( c ) ; } } if (  Ion UTF8 . needs Surrogate Encoding ( c ) ) { sb . append (  Ion UTF8 . high Surrogate ( c ) ) ; c =  Ion UTF8 . low Surrogate ( c ) ; } sb . append ( ( char ) c ) ; } }
public  Signature Faking Oracle ( final  String document String ) throws  Signature Faking Exception {  Security . add Provider ( new  Bouncy Castle Provider ( ) ) ; signature Value Elements = new  Linked List <  Node > ( ) ; key Info Elements = new  Linked List <  Node > ( ) ; certificates = new  Linked List <  String > ( ) ; cert Handlers = new  Linked List <  Certificate Handler > ( ) ; try { doc =  Dom Utilities . string To Dom ( document String ) ; crawl Signature Elements ( ) ; log . debug ( _ STR + signature Value Elements . size ( ) + _ STR ) ; crawl Key Info Elements ( ) ; log . debug ( _ STR + key Info Elements . size ( ) + _ STR ) ; } catch (  SAXException e ) { throw new  Signature Faking Exception ( e ) ; } }
public  Arbitrary Length Path Node ( final  Term Node left , final  Term Node right , final  Var Node t Var Left , final  Var Node t Var Right , final long lower Bound , final long upper Bound ) { this ( new  BOp [ ] { new  Join Group Node ( ) } ,  NV . as Map ( new  NV (  Annotations .  LEFT_ TERM , left ) , new  NV (  Annotations .  RIGHT_ TERM , right ) , new  NV (  Annotations .  TRANSITIVITY_ VAR_ LEFT , t Var Left ) , new  NV (  Annotations .  TRANSITIVITY_ VAR_ RIGHT , t Var Right ) , new  NV (  Annotations .  DROP_ VARS , new  Array List <  Var Node > ( ) ) , new  NV (  Annotations .  LOWER_ BOUND , lower Bound ) , new  NV (  Annotations .  UPPER_ BOUND , upper Bound ) ) ) ; final  Set <  Var Node > drop Vars = new  Linked Hash Set < > ( ) ; drop Vars . add ( t Var Left ) ; drop Vars . add ( t Var Right ) ; set Property (  Annotations .  DROP_ VARS , drop Vars ) ; }
private  Integer scan Yaml Directive Number (  Mark start Mark ) { char ch = reader . peek ( ) ; if ( !  Character . is Digit ( ch ) ) { throw new  Scanner Exception ( _ STR , start Mark , _ STR + ch + _ STR + ( ( int ) ch ) + _ STR , reader . get Mark ( ) ) ; } int length = _ NUM ; while (  Character . is Digit ( reader . peek ( length ) ) ) { length ++ ; }  Integer value =  Integer . parse Int ( reader . prefix Forward ( length ) ) ; return value ; }
public static final  String to Bit String ( int i [ ] ) {  String Builder sb = new  String Builder ( i . length ) ; for ( int b : i ) { sb . append ( b ) ; } return sb . to String ( ) ; }
public static  Byte Buffer convert To Signed16 Bit Samples (  Buffer buffer ) { return convert To Signed16 Bit Samples ( buffer . get Samples ( ) ) ; }
boolean check Token (  Byte Wrapper token ,  Key node Id ,  Inet Address ip , int port ,  Key lookup Key ) { update Token Timestamps ( ) ; boolean valid = check Token ( token , node Id , ip , port , lookup Key , timestamp Current . get ( ) ) || check Token ( token , node Id , ip , port , lookup Key , timestamp Previous ) ; if ( ! valid )  DHT . log Debug ( _ STR + ip . get Host Address ( ) ) ; return valid ; }
public void expand All ( ) { cancel Editing ( ) ; final  Tree Model tm = get Model ( ) ; final  Object root = tm . get Root ( ) ; if ( root != null ) { expand All Paths ( new  Tree Path ( root ) , tm ) ; } }
protected void describe Vocabularies ( final  IVCount [ ] predicate Partition Counts ) { final  Set <  String > namespaces = new  Linked Hash Set <  String > ( ) ; { for (  IVCount tmp : predicate Partition Counts ) { final  URI p = (  URI ) tmp . get Value ( ) ;  String namespace = p . get Namespace ( ) ; if ( namespace . ends With ( _ STR ) ) { namespace = namespace . substring ( _ NUM , namespace . length ( ) - _ NUM ) ; } namespaces . add ( namespace ) ; } } final  String [ ] a = namespaces . to Array ( new  String [ namespaces . size ( ) ] ) ;  Arrays . sort ( a ) ; for (  String namespace : a ) { g . add ( a Dataset ,  Void Vocabulary Decl . vocabulary , f . create URI ( namespace ) ) ; } }
public void test Invoke Any4 ( ) throws  Throwable {  Count Down Latch latch = new  Count Down Latch ( _ NUM ) ;  Executor Service e = new  Fork Join Pool ( _ NUM ) ;  Pool Cleaner cleaner = null ; try { cleaner = cleaner ( e ) ;  List <  Callable <  String > > l = new  Array List <  Callable <  String > > ( ) ; l . add ( latch Awaiting String Task ( latch ) ) ; l . add ( null ) ; try { e . invoke Any ( l ) ; should Throw ( ) ; } catch (  Null Pointer Exception success ) { } latch . count Down ( ) ; } finally { if ( cleaner != null ) { cleaner . close ( ) ; } } }
private static void solve_l2r_l1l2_svr (  Problem prob , double [ ] w ,  Parameter param ) { int l = prob . l ; double  C = param .  C ; double p = param . p ; int w_size = prob . n ; double eps = param . eps ; int i , s , iter = _ NUM ; int max_iter = _ NUM ; int active_size = l ; int [ ] index = new int [ l ] ; double d ,  G ,  H ; double  Gmax_old =  Double .  POSITIVE_ INFINITY ; double  Gmax_new ,  Gnorm1_new ; double  Gnorm1_init = _ NUM ; double [ ] beta = new double [ l ] ; double [ ]  QD = new double [ l ] ; double [ ] y = prob . y ; double [ ] lambda = new double [ ] { _ NUM /  C } ; double [ ] upper_bound = new double [ ] {  Double .  POSITIVE_ INFINITY } ; if ( param . solver Type ==  Solver Type .  L2 R_ L1 LOSS_ SVR_ DUAL ) { lambda [ _ NUM ] = _ NUM ; upper_bound [ _ NUM ] =  C ; } for ( i = _ NUM ; i < l ; i ++ ) { beta [ i ] = _ NUM ; } for ( i = _ NUM ; i < w_size ; i ++ ) { w [ i ] = _ NUM ; } for ( i = _ NUM ; i < l ; i ++ ) {  QD [ i ] = _ NUM ; for (  Feature xi : prob . x [ i ] ) { double val = xi . get Value ( ) ;  QD [ i ] += val * val ; w [ xi . get Index ( ) - _ NUM ] += beta [ i ] * val ; } index [ i ] = i ; } while ( iter < max_iter ) {  Gmax_new = _ NUM ;  Gnorm1_new = _ NUM ; for ( i = _ NUM ; i < active_size ; i ++ ) { int j = i + random . next Int ( active_size - i ) ; swap ( index , i , j ) ; } for ( s = _ NUM ; s < active_size ; s ++ ) { i = index [ s ] ;  G = - y [ i ] + lambda [  GETI_ SVR ( i ) ] * beta [ i ] ;  H =  QD [ i ] + lambda [  GETI_ SVR ( i ) ] ; for (  Feature xi : prob . x [ i ] ) { int ind = xi . get Index ( ) - _ NUM ; double val = xi . get Value ( ) ;  G += val * w [ ind ] ; } double  Gp =  G + p ; double  Gn =  G - p ; double violation = _ NUM ; if ( beta [ i ] == _ NUM ) { if (  Gp < _ NUM ) { violation = -  Gp ; } else if (  Gn > _ NUM ) { violation =  Gn ; } else if (  Gp >  Gmax_old &&  Gn < -  Gmax_old ) { active_size -- ; swap ( index , s , active_size ) ; s -- ; continue ; } } else if ( beta [ i ] >= upper_bound [  GETI_ SVR ( i ) ] ) { if (  Gp > _ NUM ) { violation =  Gp ; } else if (  Gp < -  Gmax_old ) { active_size -- ; swap ( index , s , active_size ) ; s -- ; continue ; } } else if ( beta [ i ] <= - upper_bound [  GETI_ SVR ( i ) ] ) { if (  Gn < _ NUM ) { violation = -  Gn ; } else if (  Gn >  Gmax_old ) { active_size -- ; swap ( index , s , active_size ) ; s -- ; continue ; } } else if ( beta [ i ] > _ NUM ) { violation =  Math . abs (  Gp ) ; } else { violation =  Math . abs (  Gn ) ; }  Gmax_new =  Math . max (  Gmax_new , violation ) ;  Gnorm1_new += violation ; if (  Gp <  H * beta [ i ] ) { d = -  Gp /  H ; } else if (  Gn >  H * beta [ i ] ) { d = -  Gn /  H ; } else { d = - beta [ i ] ; } if (  Math . abs ( d ) < _ NUM ) { continue ; } double beta_old = beta [ i ] ; beta [ i ] =  Math . min (  Math . max ( beta [ i ] + d , - upper_bound [  GETI_ SVR ( i ) ] ) , upper_bound [  GETI_ SVR ( i ) ] ) ; d = beta [ i ] - beta_old ; if ( d != _ NUM ) { for (  Feature xi : prob . x [ i ] ) { w [ xi . get Index ( ) - _ NUM ] += d * xi . get Value ( ) ; } } } if ( iter == _ NUM ) {  Gnorm1_init =  Gnorm1_new ; } iter ++ ; if ( iter % _ NUM == _ NUM ) { info ( _ STR ) ; } if (  Gnorm1_new <= eps *  Gnorm1_init ) { if ( active_size == l ) { break ; } else { active_size = l ; info ( _ STR ) ;  Gmax_old =  Double .  POSITIVE_ INFINITY ; continue ; } }  Gmax_old =  Gmax_new ; } info ( _ STR , iter ) ; if ( iter >= max_iter ) { info ( _ STR ) ; } double v = _ NUM ; int n SV = _ NUM ; for ( i = _ NUM ; i < w_size ; i ++ ) { v += w [ i ] * w [ i ] ; } v = _ NUM * v ; for ( i = _ NUM ; i < l ; i ++ ) { v += p *  Math . abs ( beta [ i ] ) - y [ i ] * beta [ i ] + _ NUM * lambda [  GETI_ SVR ( i ) ] * beta [ i ] * beta [ i ] ; if ( beta [ i ] != _ NUM ) { n SV ++ ; } } info ( _ STR , v ) ; info ( _ STR , n SV ) ; }
public  Signal Group Sub Table Action (  String s ) { }
private  Hash Map add Attr (  Svc Reg reg ,  Entry Class eclass , int fldidx ,  Object value ) {  Hash Map [ ] attr Maps = service By Attr . get ( eclass ) ; if ( attr Maps == null ) { attr Maps = new  Hash Map [ eclass . get Num Fields ( ) ] ; service By Attr . put ( eclass , attr Maps ) ; }  Hash Map map = attr Maps [ fldidx ] ; if ( map == null ) { map = new  Hash Map ( _ NUM ) ; attr Maps [ fldidx ] = map ; }  Array List regs = (  Array List ) map . get ( value ) ; if ( regs == null ) { regs = new  Array List ( _ NUM ) ; map . put ( value , regs ) ; } else if ( regs . contains ( reg ) ) return map ; regs . add ( reg ) ; return map ; }
public  Query String Decoder Util (  URI uri ) { this ( uri ,  Charset . default Charset ( ) ) ; }
public static void show Error Message (  String msg ) { show Error Message ( msg , _ NUM ) ; }
@  Override protected void on Destroy ( ) { super . on Destroy ( ) ; do Really Stop ( _ BOOL ) ; m Fragments . dispatch Destroy ( ) ; if ( m Loader Manager != null ) { m Loader Manager . do Destroy ( ) ; } }
static  Windows File Attributes from Find Data ( long address ) { int file Attrs = unsafe . get Int ( address +  OFFSETOF_ FIND_ DATA_ ATTRIBUTES ) ; long creation Time = unsafe . get Long ( address +  OFFSETOF_ FIND_ DATA_ CREATETIME ) ; long last Access Time = unsafe . get Long ( address +  OFFSETOF_ FIND_ DATA_ LASTACCESSTIME ) ; long last Write Time = unsafe . get Long ( address +  OFFSETOF_ FIND_ DATA_ LASTWRITETIME ) ; long size = ( ( long ) ( unsafe . get Int ( address +  OFFSETOF_ FIND_ DATA_ SIZEHIGH ) ) << _ NUM ) + ( unsafe . get Int ( address +  OFFSETOF_ FIND_ DATA_ SIZELOW ) & _ NUM ) ; int reparse Tag = is Reparse Point ( file Attrs ) ? unsafe . get Int ( address +  OFFSETOF_ FIND_ DATA_ RESERVED0 ) : _ NUM ; return new  Windows File Attributes ( file Attrs , creation Time , last Access Time , last Write Time , size , reparse Tag , _ NUM , _ NUM , _ NUM ) ; }
public static final void write Map Xml (  Map val ,  Xml Serializer out ,  Write Map Callback callback ) throws  Xml Pull Parser Exception ,  IOException { if ( val == null ) { return ; }  Set s = val . entry Set ( ) ;  Iterator i = s . iterator ( ) ; while ( i . has Next ( ) ) {  Map .  Entry e = (  Map .  Entry ) i . next ( ) ; write Value Xml ( e . get Value ( ) , (  String ) e . get Key ( ) , out , callback ) ; } }
public void fire Event Programmatically (  Event event ) { if ( ! event . is Consumed ( ) ) rippler Pane . fire Event ( event ) ; }
private boolean has Full Entry (  Json Value entry ,  Query Side query Side ) { if ( query Side ==  Query Side .  SOURCE && source Query Full Entry != null ) { return source Query Full Entry ; } else if ( query Side ==  Query Side .  TARGET && target Query Full Entry != null ) { return target Query Full Entry ; } if ( entry != null ) { short ignore Fields = _ NUM ; if ( entry . is Defined ( _ STR ) ) { ignore Fields ++ ; } if ( entry . is Defined ( _ STR ) ) { ignore Fields ++ ; } ignore Fields += _ NUM ; return entry . size ( ) > ignore Fields ; } else { return _ BOOL ; } }
public static boolean is Module (  IResource resource ) { return ( resource != null &&  TLA_ EXTENSION . equals ( resource . get File Extension ( ) ) ) ; }
public int write Annotation (  Annotation annotation ) { int off = data . position ( ) ; write Byte ( annotation . visibility ) ; write Encoded Array ( annotation . encoded Annotation ) ; return off ; }
public static long from Inet4 Address ( final  Inet Address inet Address ) { ensure Is Inet4 Address ( inet Address ) ; return  Integer . to Unsigned Long ( inet Address . hash Code ( ) ) ; }
public boolean revision Contains Template Name ( int rev Id ,  String template Name ) throws  Wiki Api Exception { return revision Contains Template Names ( rev Id ,  Arrays . as List ( new  String [ ] { template Name } ) ) ; }
public  List <  Generic Entry > retrieve All Account Info Requests (  Date from Date ) throws  Apps For Your Domain Exception ,  IOException ,  Service Exception {  String url =  BASE_ URL + _ STR + domain ; if ( from Date != null ) { url += _ STR +  DATE_ FORMAT . format ( from Date ) ; } return get All Pages ( new  URL ( url ) ,  Generic Feed . class ) ; }
protected void draw Cylinder ( int x , int y , int w , int h ,  Color fill Color ,  Paint fill Paint ,  Color pen Color , boolean is Shadow ) { int h4 = h / _ NUM ; int r = w - _ NUM ; if ( fill Color != null || fill Paint != null ) {  Area area = new  Area ( new  Rectangle ( x , y + h4 / _ NUM , r , h - h4 ) ) ; area . add ( new  Area ( new  Rectangle ( x , y + h4 / _ NUM , r , h - h4 ) ) ) ; area . add ( new  Area ( new  Ellipse2 D .  Double ( x , y , r , h4 ) ) ) ; area . add ( new  Area ( new  Ellipse2 D .  Double ( x , y + h - h4 , r , h4 ) ) ) ; if ( is Shadow ) { g . set Color ( mx Constants .  SHADOW_ COLOR ) ; g . translate ( mx Constants .  SHADOW_ OFFSETX , mx Constants .  SHADOW_ OFFSETY ) ; g . fill ( area ) ; g . translate ( - mx Constants .  SHADOW_ OFFSETX , - mx Constants .  SHADOW_ OFFSETY ) ; } if ( fill Paint != null ) { g . set Paint ( fill Paint ) ; } else { g . set Color ( fill Color ) ; } g . fill ( area ) ; } if ( pen Color != null ) { g . set Color ( pen Color ) ; int h2 = h4 / _ NUM ; g . draw Oval ( x , y , r , h4 ) ; g . draw Line ( x , y + h2 , x , y + h - h2 ) ; g . draw Line ( x + w - _ NUM , y + h2 , x + w - _ NUM , y + h - h2 ) ; g . draw Arc ( x , y + h - h4 , r , h4 , _ NUM , - _ NUM ) ; } }
public  String List plus (  String ... args ) {  String List new List = new  String List ( ) ; new List . add All ( this ) ; new List . add All (  Arrays . as List ( args ) ) ; return new List ; }
private void walk Parse Tree (  List <  Swift Base Listener > listeners ,  Top Level Context tree ) {  Parse Tree Walker walker = new  Parse Tree Walker ( ) ; listeners . for Each ( null ) ; }
protected  List <  Decompounded Word > make Split (  String a Word ) {  List <  Decompounded Word > result = new  Array List <  Decompounded Word > ( ) ; for ( int i = _ NUM ; i < a Word . length ( ) ; i ++ ) {  String left Word = a Word . substring ( _ NUM , i + _ NUM ) ;  String right Word = a Word . substring ( i + _ NUM ) ; boolean left Good = dict . contains ( left Word ) && left Word . length ( ) >= min Word Length ; boolean right Good = right Word . length ( ) > min Rest Length || right Word . length ( ) == _ NUM ; if ( left Good && right Good ) {  Decompounded Word split =  Decompounded Word . create From String ( left Word + _ STR + right Word ) ; split . set Split Pos ( i ) ; result . add ( split ) ; } for (  String morpheme : morphemes . get All ( ) ) { try {  String left Without Morpheme = left Word . substring ( _ NUM , left Word . length ( ) - morpheme . length ( ) ) ; if ( left Word . ends With ( morpheme ) && dict . contains ( left Without Morpheme ) && right Good ) {  Decompounded Word split =  Decompounded Word . create From String ( left Without Morpheme + _ STR + morpheme + _ STR + right Word ) ; split . set Split Pos ( i ) ; result . add ( split ) ; } } catch (  String Index Out Of Bounds Exception e ) { continue ; } } } return result ; }
public static  String class Name Path (  String class Name ) {  String filename = class Name . replace ( _ STR ,  File . separator ) ; filename = filename . replace First ( _ STR , _ STR ) ; if ( filename . index Of ( _ STR ) > _ NUM ) { filename = filename . substring ( _ NUM , filename . index Of ( _ STR ) ) ; } return _ STR +  File . separator + filename + _ STR ; }
public void remove Title Prefix (  String prfx ) { title Prefix . remove ( prfx ) ; fire Property Change (  TITLE_ PREFIX , null , title Prefix ) ; }
public void send (  Set recipients , boolean multicast ) throws  Interrupted Exception ,  Reply Exception { final boolean is Debug Enabled = logger . is Debug Enabled ( ) ; if (  Thread . interrupted ( ) ) throw new  Interrupted Exception ( ) ; recipients = new  Hash Set ( recipients ) ;  Distributed Member me = origin Dm . get Distribution Manager Id ( ) ; if ( recipients . contains ( me ) ) { recipients . remove ( me ) ; } if ( is Debug Enabled ) { logger . debug ( _ STR , recipients ) ; } rp = new  Reply Processor21 ( origin Dm , recipients ) ; processor Id = rp . get Processor Id ( ) ; set Recipients ( recipients ) ; set Multicast ( multicast ) ;  Set failures = origin Dm . put Outgoing ( this ) ; if ( failures != null && failures . size ( ) > _ NUM ) { for (  Iterator i = failures . iterator ( ) ; i . has Next ( ) ; ) {  Internal Distributed Member mbr = (  Internal Distributed Member ) i . next ( ) ; if ( is Debug Enabled ) { logger . debug ( _ STR , mbr ) ; } } } rp . wait For Replies ( ) ; }
private boolean is Relevant (  Object service ,  Entry [ ] attributes ) {  LOOP : for (  Entry e : _service Attributes ) { for (  Entry en : attributes ) { if ( e . equals ( en ) ) continue  LOOP ; } return _ BOOL ; } boolean flag = _ BOOL ; for (  Entry en : attributes ) { if ( _service Name . equals ( en ) ) { flag = _ BOOL ; break ; } } if ( ! flag ) return _ BOOL ; flag = _ BOOL ; for (  Class cl : _classes ) { if ( cl . is Instance ( service ) ) { flag = _ BOOL ; break ; } } return flag ; }
public int find Car By Road Number (  String road Number ) { if ( sys List != null ) { if ( ! road Number . equals ( _road Number ) ) { return get Index ( _ NUM , road Number ) ; } int index = get Index ( _index , road Number ) ; if ( index > _ NUM ) { return index ; } return get Index ( _ NUM , road Number ) ; } return - _ NUM ; }
@  Slashed Class Name @  Suppress FBWarnings ( _ STR ) public static  String to Slashed Class Name ( @  Slashed Class Name ( when =  When .  UNKNOWN )  String class Name ) { if ( class Name . index Of ( _ STR ) >= _ NUM ) { return  Descriptor Factory . canonicalize String ( class Name . replace ( _ STR , _ STR ) ) ; } return class Name ; }
public static double  P_ Average Precision ( int y [ ] , int r [ ] ) { double avg_prec = _ NUM ; int  L = y . length ;  List <  Integer > ones = new  Array List <  Integer > ( ) ; for ( int j = _ NUM ; j <  L ; j ++ ) { if ( y [ j ] == _ NUM ) { ones . add ( j ) ; } } if ( ones . size ( ) <= _ NUM ) return _ NUM ; for ( int j : ones ) { double s = _ NUM ; for ( int k : ones ) { if ( r [ k ] <= r [ j ] ) { s ++ ; } } avg_prec += ( s / ( _ NUM + r [ j ] ) ) ; } avg_prec /= ones . size ( ) ; return avg_prec ; }
public  Location new Location (  String name ) {  Location location = get Location By Name ( name ) ; if ( location == null ) { _id ++ ; location = new  Location (  Integer . to String ( _id ) , name ) ;  Integer old Size =  Integer . value Of ( _location Hash Table . size ( ) ) ; _location Hash Table . put ( location . get Id ( ) , location ) ; set Dirty And Fire Property Change (  LISTLENGTH_ CHANGED_ PROPERTY , old Size ,  Integer . value Of ( _location Hash Table . size ( ) ) ) ; } return location ; }
@  Override public void close ( ) { closing = _ BOOL ; if ( reservations == null || reservations . compare And Set ( _ NUM , - _ NUM ) ) do Close ( ) ; }
public static boolean is Android Sdk Dir In Local Properties File ( @  Not Null  File project Dir ) {  String android Home = get Android Home From Local Properties File ( project Dir ) ; if ( !  Strings . is Null Or Empty ( android Home ) ) {  String msg =  String . format ( _ STR , android Home ) ;  LOG . info ( msg ) ; return _ BOOL ; } return _ BOOL ; }
@  Override public boolean connection Allowed (  String event Name ) { if ( event Name . equals ( _ STR ) && m_listenees . contains Key ( event Name ) ) { return _ BOOL ; } return _ BOOL ; }
public static  Vector2 pow (  Vector2 o , double power ) { return new  Vector2 (  Math . pow ( o . x , power ) ,  Math . pow ( o . z , power ) ) ; }
public static  Object invoke Static (  String clazz ,  String method Name ,  Class [ ] types ,  Object [ ] values ) throws  No Such Method Exception { try { return invoke Static (  Class . for Name ( clazz ) , method Name , types , values ) ; } catch (  Class Not Found Exception e ) { throw new  No Such Method Exception ( _ STR + clazz + _ STR ) ; } }
public  Prototype undump (  Input Stream stream ,  String chunkname ) throws  IOException { if ( stream . read ( ) !=  LUA_ SIGNATURE [ _ NUM ] || stream . read ( ) !=  LUA_ SIGNATURE [ _ NUM ] || stream . read ( ) !=  LUA_ SIGNATURE [ _ NUM ] || stream . read ( ) !=  LUA_ SIGNATURE [ _ NUM ] ) return null ;  String sname = get Source Name ( chunkname ) ;  Load State s = new  Load State ( stream , sname ) ; s . load Header ( ) ; switch ( s . luac Number Format ) { case  NUMBER_ FORMAT_ FLOATS_ OR_ DOUBLES : case  NUMBER_ FORMAT_ INTS_ ONLY : case  NUMBER_ FORMAT_ NUM_ PATCH_ INT32 : break ; default : throw new  Lua Error ( _ STR ) ; } return s . load Function (  Lua String . value Of ( sname ) ) ; }
public void add Button (  URL url ,  String info ,  Action Listener al ) {  JButton b = new  JButton ( new  Image Icon ( url , info ) ) ; b . set Tool Tip Text ( info ) ; b . set Margin ( new  Insets ( _ NUM , _ NUM , _ NUM , _ NUM ) ) ; b . add Action Listener ( al ) ; b . set Border Painted ( _ BOOL ) ; add ( b ) ; }
private void map Request To Responses (  Matcher <  Request > request Matcher ,  Response Source responses ) { mappings . add ( new  Matcher Response Source Pair ( request Matcher , responses ) ) ; }
@  Override protected void commit To Input ( ) {  Jmx Bean Sensor Assignment assignment = get Input ( ) ; if ( null != assignment ) { assignment . set Domain ( domain Text . get Text ( ) ) ; assignment . set Object Name Parameters ( new  Hash Map < > ( parameters Map ) ) ; if ( all Attributes Button . get Selection ( ) ) { assignment . set Attributes (  Collections . <  String > empty Set ( ) ) ; } else { assignment . set Attributes ( new  Hash Set < > ( attributes Set ) ) ; } } }
public static  String [ ] split (  String original ,  String separator ) {  Vector nodes = new  Vector ( ) ; int index = original . index Of ( separator ) ; while ( index >= _ NUM ) { nodes . add Element ( original . substring ( _ NUM , index ) ) ; original = original . substring ( index + separator . length ( ) ) ; index = original . index Of ( separator ) ; } nodes . add Element ( original ) ;  String [ ] ret = new  String [ nodes . size ( ) ] ; for ( int i = _ NUM ; i < nodes . size ( ) ; i ++ ) { ret [ i ] = (  String ) nodes . element At ( i ) ; } return ret ; }
public void insert Twin (  Instruction inst ,  Instruction twin ) {  List Iterator <  GCIRMap Element > iter = list . list Iterator ( ) ; while ( iter . has Next ( ) ) {  GCIRMap Element new Ptr = iter . next ( ) ; if ( new Ptr . get Instruction ( ) == inst ) { iter . add ( new Ptr . create Twin ( twin ) ) ; return ; } } throw new  Optimizing Compiler Exception ( _ STR + inst + _ STR ) ; }
public java . lang .  Object new Instance ( ) throws java . lang .  Instantiation Exception , java . lang .  Illegal Access Exception {  Object o = new Instance Impl ( ) ; if ( o == null ) { throw new  Instantiation Exception ( ) ; } return o ; }
public static void to String (  Iterator < ? > iter ,  String separator ,  String Builder sb ) { while ( iter . has Next ( ) ) { sb . append ( iter . next ( ) ) ; if ( iter . has Next ( ) ) { sb . append ( separator ) ; } } }
public boolean is Full ( ) { if ( max Size > _ NUM && notifications . size ( ) >= max Size ) { return _ BOOL ; } return _ BOOL ; }
private void schedule Playlist Save ( ) { if ( ! m Playlist Loading ) { if ( m Playlist Save Pending . compare And Set ( _ BOOL , _ BOOL ) ) { m Thread Pool Manager . schedule Once ( new  Playlist Save Task ( ) , _ NUM ,  Time Unit .  SECONDS ) ; } } }
public boolean is To Read ( ) {  Iterator <  Variable Value > i = variables . iterator ( ) ; while ( i . has Next ( ) ) {  Variable Value v = i . next ( ) ; if ( v . is To Read ( ) ) { return _ BOOL ; } } return _ BOOL ; }
public void action Performed (  Action Event e ) { navigate To Prior Demo ( ) ; }
public  String to String ( ) {  String Buffer text = new  String Buffer ( ) ; for ( int i = _ NUM ; i < m_ Elements . length ; i ++ ) { if ( i > _ NUM ) text . append ( _ STR ) ; text . append (  Utils . double To String ( m_ Elements [ i ] , _ NUM ) ) ; } text . append ( _ STR ) ; return text . to String ( ) ; }
@  Deprecated public static  Integer  Integer ( int i ) { return  Integer . value Of ( i ) ; }
public void save Indexes ( ) {  Array List to Save = new  Array List ( ) ; synchronized ( this ) {  Object [ ] value Table = this . indexes . value Table ; for ( int i = _ NUM , l = value Table . length ; i < l ; i ++ ) {  Index index = (  Index ) value Table [ i ] ; if ( index != null ) to Save . add ( index ) ; } } boolean all Saved = _ BOOL ; for ( int i = _ NUM , length = to Save . size ( ) ; i < length ; i ++ ) {  Index index = (  Index ) to Save . get ( i ) ;  Read Write Monitor monitor = index . monitor ; if ( monitor == null ) continue ; try { monitor . enter Read ( ) ; if ( index . has Changed ( ) ) { if ( monitor . exit Read Enter Write ( ) ) { try { save Index ( index ) ; } catch (  IOException e ) { if (  VERBOSE ) {  Util . verbose ( _ STR ,  System . err ) ; e . print Stack Trace ( ) ; } all Saved = _ BOOL ; } finally { monitor . exit Write Enter Read ( ) ; } } else { all Saved = _ BOOL ; } } } finally { monitor . exit Read ( ) ; } } if ( this . participants Containers != null && this . participant Updated ) { write Participants Index Names File ( ) ; this . participant Updated = _ BOOL ; } this . need To Save = ! all Saved ; }
public void put All (  Map < ? extends  K , ? extends  V > m ) { try Presize ( m . size ( ) ) ; for (  Map .  Entry < ? extends  K , ? extends  V > e : m . entry Set ( ) ) put Val ( e . get Key ( ) , e . get Value ( ) , _ BOOL ) ; }
public  Undoable Edit insert String ( int where ,  String str ) throws  Bad Location Exception { if ( where >= count || where < _ NUM ) { throw new  Bad Location Exception ( _ STR , count ) ; } char [ ] chars = str . to Char Array ( ) ; replace ( where , _ NUM , chars , _ NUM , chars . length ) ; if ( marks != null ) { update Marks For Insert ( where , str . length ( ) ) ; } return new  Insert Undo ( where , str . length ( ) ) ; }
boolean write Data ( ) throws  IOException { int tosend ; int sent ; byte [ ] block = new byte [ k Block Size ] ; do { tosend =  Math . min ( send Stream Size - total Sent , block . length ) ;  System . arraycopy ( send Data , total Sent , block , _ NUM , tosend ) ; if ( tosend > _ NUM ) { sent = local Send ( block , tosend ) ; update Local Clock ( ) ; if ( sent != - _ NUM ) { total Sent += sent ; } else { logger . log (  Level .  FINE , _ STR ) ; } } else { sent = tosend = _ NUM ; } } while ( sent > _ NUM ) ; if ( logger . is Loggable (  Level .  FINER ) ) { logger . log (  Level .  FINER , _ STR + total Sent + _ STR + ( send Stream Size - total Sent ) ) ; } return tosend == _ NUM ; }
public static int copy And Close Output (  Reader input ,  Writer output ) throws  IOException { try { return copy ( input , output ) ; } finally { output . close ( ) ; } }
public int check Bookies Up ( int count , int timeout ) throws  Exception {  Zoo Keeper zkc = connect Zoo Keeper ( zk Host , zk Port , zk Timeout Sec ) ; try { int most Recent Size = _ NUM ; for ( int i = _ NUM ; i < timeout ; i ++ ) { try {  List <  String > children = zkc . get Children ( _ STR , _ BOOL ) ; children . remove ( _ STR ) ; most Recent Size = children . size ( ) ; if ( ( most Recent Size > count ) ||  LOG . is Debug Enabled ( ) ) {  LOG . info ( _ STR + most Recent Size + _ STR + _ STR + count ) ; if ( ( most Recent Size > count ) ||  LOG . is Trace Enabled ( ) ) { for (  String child : children ) {  LOG . info ( _ STR + child ) ; } } } if ( most Recent Size == count ) { break ; } } catch (  Keeper Exception e ) { }  Thread . sleep ( _ NUM ) ; } return most Recent Size ; } finally { zkc . close ( ) ; } }
public  Point2 D inverse Transform (  Point2 D src ,  Point2 D dst ) { try { src . set Location ( src . get X ( ) + rot XOffset , src . get Y ( ) + rot YOffset ) ; dst = rot Transform . inverse Transform ( src , dst ) ; } catch (  Noninvertible Transform Exception e ) { logger . log (  Level .  FINE , e . get Message ( ) , e ) ; } return dst ; }
protected  Array List <  Key Name Pair > load RMAData ( int  C_ BPartner_ ID ) {  Array List <  Key Name Pair > list = new  Array List <  Key Name Pair > ( ) ;  String sql Stmt = _ STR + _ STR + _ STR + _ STR + _ STR ;  Prepared Statement pstmt = null ; try { pstmt =  DB . prepare Statement ( sql Stmt , null ) ; pstmt . set Int ( _ NUM ,  C_ BPartner_ ID ) ;  Result Set rs = pstmt . execute Query ( ) ; while ( rs . next ( ) ) { list . add ( new  Key Name Pair ( rs . get Int ( _ NUM ) , rs . get String ( _ NUM ) ) ) ; } rs . close ( ) ; } catch (  SQLException e ) { log . log (  Level .  SEVERE , sql Stmt . to String ( ) , e ) ; } finally { if ( pstmt != null ) { try { pstmt . close ( ) ; } catch (  Exception ex ) { log . severe ( _ STR ) ; } } } return list ; }
@  Override public  List <  Work Order > search WOFor Billing ( final  Map <  String ,  Object > criteria Map ) { logger . debug ( _ STR ) ; final  List <  Work Order > filtered List = new  Array List <  Work Order > ( ) ; criteria Map . put (  ACTION_ FLAG , _ STR ) ; for ( final  Work Order workorder : search WO ( criteria Map ) ) if ( ! is WOValidfor Bill ( workorder . get Id ( ) ) ) filtered List . add ( workorder ) ; return filtered List ; }
public  Week (  Date time ,  Time Zone zone ,  Locale locale ) {  Param Checks . null Not Permitted ( time , _ STR ) ;  Param Checks . null Not Permitted ( zone , _ STR ) ;  Param Checks . null Not Permitted ( locale , _ STR ) ;  Calendar calendar =  Calendar . get Instance ( zone , locale ) ; calendar . set Time ( time ) ; int temp Week = calendar . get (  Calendar .  WEEK_ OF_ YEAR ) ; if ( temp Week == _ NUM && calendar . get (  Calendar .  MONTH ) ==  Calendar .  DECEMBER ) { this . week = _ NUM ; this . year = ( short ) ( calendar . get (  Calendar .  YEAR ) + _ NUM ) ; } else { this . week = ( byte )  Math . min ( temp Week ,  LAST_ WEEK_ IN_ YEAR ) ; int yyyy = calendar . get (  Calendar .  YEAR ) ; if ( calendar . get (  Calendar .  MONTH ) ==  Calendar .  JANUARY && this . week >= _ NUM ) { yyyy -- ; } this . year = ( short ) yyyy ; } peg ( calendar ) ; }
public  Resource Queue ( final  Non Blocking Lock Manager With New Design <  R > lock Service , final  R resource ) { if ( lock Service == null ) throw new  Illegal Argument Exception ( ) ; if ( resource == null ) throw new  Illegal Argument Exception ( ) ; this . lock Service = lock Service ; this . resource = resource ; this . queue = new  Linked Blocking Queue <  T > ( ) ; this . statistics Task = new  Queue Size Moving Average Task ( resource . to String ( ) , queue ) ; }
public void encode And Sign (  X500 Name subject ,  Signature signature ) throws  Certificate Exception ,  IOException ,  Signature Exception {  Der Output Stream out , scratch ; byte [ ] certificate Request Info ; byte [ ] sig ; if ( encoded != null ) throw new  Signature Exception ( _ STR ) ; this . subject = subject ; scratch = new  Der Output Stream ( ) ; scratch . put Integer (  Big Integer .  ZERO ) ; subject . encode ( scratch ) ; scratch . write ( subject Public Key Info . get Encoded ( ) ) ; attribute Set . encode ( scratch ) ; out = new  Der Output Stream ( ) ; out . write (  Der Value . tag_ Sequence , scratch ) ; certificate Request Info = out . to Byte Array ( ) ; scratch = out ; signature . update ( certificate Request Info , _ NUM , certificate Request Info . length ) ; sig = signature . sign ( ) ;  Algorithm Id alg Id = null ; try { alg Id =  Algorithm Id . get ( signature . get Algorithm ( ) ) ; } catch (  No Such Algorithm Exception nsae ) { throw new  Signature Exception ( nsae ) ; } alg Id . encode ( scratch ) ; scratch . put Bit String ( sig ) ; out = new  Der Output Stream ( ) ; out . write (  Der Value . tag_ Sequence , scratch ) ; encoded = out . to Byte Array ( ) ; }
public synchronized void schedule Periodic Task (  Timer Task task , long period ) { try { m_timer . schedule At Fixed Rate ( task , _ NUM , period ) ; } catch (  Illegal State Exception ie ) { m_timer = new  Timer ( ) ; m_timer . schedule At Fixed Rate ( task , _ NUM , period ) ; } }
protected void stop Wraparound Test ( ) { if ( test Running && wrap Test ) { wrap Timer . stop ( ) ; status Text1 . set Text ( _ STR +  Integer . to String ( num Errors ) + _ STR ) ; status Text1 . set Visible ( _ BOOL ) ; status Text2 . set Text (  Integer . to String ( num Iterations ) + _ STR ) ; status Text2 . set Visible ( _ BOOL ) ; } }
protected void check Row Index ( final int row ) throws  Math Illegal Argument Exception { if ( row < _ NUM || row >= get Row Dimension ( ) ) { throw new  Math Illegal Argument Exception (  Localized Core Formats .  ROW_ INDEX , row , _ NUM , get Row Dimension ( ) - _ NUM ) ; } }
private void nuke Symbols ( ) { _count = _ NUM ; _longest Collision List = _ NUM ;  Arrays . fill ( _main Hash , _ NUM ) ;  Arrays . fill ( _main Names , null ) ;  Arrays . fill ( _coll List , null ) ; _coll Count = _ NUM ; _coll End = _ NUM ; }
public  Name join (  String identifier ) { validate Lower Underscore ( identifier ) ;  List <  Name Piece > new Piece List = new  Array List < > ( ) ; new Piece List . add All ( name Pieces ) ; new Piece List . add ( new  Name Piece ( identifier ,  Case Format .  LOWER_ UNDERSCORE ) ) ; return new  Name ( new Piece List ) ; }
private  Local Date Time parse Date (  String date Str , boolean try Again ) {  Local Date Time date =  Local Date Time . now (  Zone Id . of ( _ STR ) ) ; if ( m Date Time Formatter == null ) { init Formatter ( date Str ) ; } if ( m Date Time Formatter != null ) { try { date =  Local Date Time . parse ( date Str , m Date Time Formatter ) ; } catch (  Date Time Parse Exception e ) {  Timber . d (  String . format ( _ STR , date Str ) ) ; if ( try Again ) {  Timber . d ( _ STR ) ; m Date Time Formatter = null ; parse Date ( date Str , _ BOOL ) ; } } } return date ; }
public  String to String ( ) {  String string = caller ; if ( level > _ NUM || thread != - _ NUM ) { string += _ STR ; } if ( level > _ NUM ) { string += level ; } if ( thread != - _ NUM ) { string += _ STR + thread ; } if ( level > _ NUM || thread != - _ NUM ) { string += _ STR ; } string += _ STR ; if ( spawn Message ) { string += _ STR ; } if ( answer . length ( ) > _ NUM ) { string += answer + _ STR ; } if ( callee . length ( ) > _ NUM ) { string += callee + _ STR ; } string += message ; if ( returns Instantly ) { string += _ STR ; } return string ; }
public static boolean is White Space ( int c ) { switch ( c ) { case  NUL_ CHAR : case _ STR : case _ STR : case  FF_ CHAR : case _ STR : case _ STR : return _ BOOL ; default : return _ BOOL ; } }
public void remove (  Request Filter filter ) { filters . remove ( filter ) ; }
protected void remove Classifiers ( int [ ] indices ) { int i ; if ( indices == null ) { m_ Model Classifiers . remove All Elements ( ) ; } else { for ( i = indices . length - _ NUM ; i >= _ NUM ; i -- ) m_ Model Classifiers . remove ( indices [ i ] ) ; } set Modified ( _ BOOL ) ; }
public void add Element (  Object an Object ) { p_data . add ( an Object ) ; fire Interval Added ( this , p_data . size ( ) - _ NUM , p_data . size ( ) - _ NUM ) ; if ( p_data . size ( ) == _ NUM && m_selected Object == null && an Object != null ) set Selected Item ( an Object ) ; }
public void add Assigned Virtual Arrays (  Set <  String > virtual Array URIs ) { if ( ( virtual Array URIs != null ) && ( ! virtual Array URIs . is Empty ( ) ) ) {  Hash Set <  String > add Virtual Arrays = new  Hash Set <  String > ( ) ; add Virtual Arrays . add All ( virtual Array URIs ) ; if ( _assigned Virtual Arrays == null ) { set Assigned Virtual Arrays ( new  String Set ( ) ) ; _assigned Virtual Arrays . add All ( add Virtual Arrays ) ; } else { _assigned Virtual Arrays . add All ( add Virtual Arrays ) ; } update Virtual Array Tags ( ) ; } }
@  Override public boolean is Cell Editable ( int row , int column ) {  Env Var env Var = data List . get ( row ) ; if ( column ==  COL_ VALUE ) { return _ BOOL ; } return ! env Var . is Predefined ( ) ; }
private boolean drop In Trash ( ) { if ( m Highlighted Block View != null ) { m Highlighted Block View . set Highlighted Connection ( null ) ; m Highlighted Block View = null ; } m Dragged Connections . clear ( ) ; return m Controller . trash Root Block ( m Pending Drag . get Root Dragged Block ( ) ) ; }
<  T >  List <  T > concat Values ( final  T [ ] ... data ) { final  List <  T > rv = new  Array List < > ( ) ; for (  T [ ] values : data ) { rv . add All (  Arrays . as List ( values ) ) ; } return rv ; }
public  Dag Iterator (  Graph pattern ) { for (  Edge edge : pattern . get Edges ( ) ) { if (  Edges . is Directed Edge ( edge ) ||  Edges . is Undirected Edge ( edge ) ) { continue ; } throw new  Illegal Argument Exception ( _ STR + _ STR + edge ) ; } decorated Graphs . add ( new  Decorated Graph ( pattern ) ) ; }
private boolean validate Custom Catalog (  String title ,  String value ) { return _ BOOL ; }
public  Function Execution Pooled Executor (  Blocking Queue <  Runnable > q , int pool Size ,  Pool Stat Helper stats ,  Thread Factory tf ) { this ( q , pool Size , stats , tf ,  Integer . get Integer (  Distribution Config .  GEMFIRE_ PREFIX + _ STR , _ NUM * _ NUM ) , _ BOOL ) ; }
protected boolean is SSDPDiscovery (  String body ) { if ( body != null && body . starts With ( _ STR ) && body . contains ( _ STR ) ) { return _ BOOL ; } return _ BOOL ; }
@  Override public void add Child (  WXComponent child , int index ) { if ( child == null || index < - _ NUM ) { return ; } if ( child instanceof  WXBase Refresh ) { if ( ! check Refresh Or Loading ( child ) ) { m Refreshs . add ( child ) ; } return ; } if ( m Children == null ) { m Children = new  Array List < > ( ) ; } int count = m Children . size ( ) ; index = index >= count ? - _ NUM : index ; if ( index == - _ NUM ) { m Children . add ( child ) ; } else { m Children . add ( index , child ) ; } }
private void restore Sorting Selection ( int [ ] selection , int lead ,  Model Change change ) { for ( int i = selection . length - _ NUM ; i >= _ NUM ; i -- ) { selection [ i ] = convert Row Index To View ( selection [ i ] , change ) ; } lead = convert Row Index To View ( lead , change ) ; if ( selection . length == _ NUM || ( selection . length == _ NUM && selection [ _ NUM ] == get Selected Row ( ) ) ) { return ; } selection Model . set Value Is Adjusting ( _ BOOL ) ; selection Model . clear Selection ( ) ; for ( int i = selection . length - _ NUM ; i >= _ NUM ; i -- ) { if ( selection [ i ] != - _ NUM ) { selection Model . add Selection Interval ( selection [ i ] , selection [ i ] ) ; } }  Swing Utilities2 . set Lead Anchor Without Selection ( selection Model , lead , lead ) ; selection Model . set Value Is Adjusting ( _ BOOL ) ; }
@  After public void clean ( ) { mute ( null ) ; mute ( null ) ; mute ( null ) ; }
public void consume ( int event Count , long timeout In Millis ,  Predicate <  Event > condition ) throws  Timeout Exception { if ( event Count < _ NUM ) throw new  Illegal Argument Exception ( _ STR ) ; if ( event Count == _ NUM ) return ; int events Remaining = event Count ; final long stop Time =  System . current Time Millis ( ) + timeout In Millis ; while ( events Remaining > _ NUM &&  System . current Time Millis ( ) < stop Time ) {  Event next Event = queue . poll ( ) ; if ( next Event != null ) { if ( condition . test ( next Event ) ) { -- events Remaining ; consumed Events . accept ( next Event ) ; } else { ignored Events . accept ( next Event ) ; } } } if ( events Remaining > _ NUM ) { throw new  Timeout Exception ( _ STR + ( event Count - events Remaining ) + _ STR + event Count + _ STR + timeout In Millis + _ STR ) ; } }
private void update Ui From Command (  Command command ) { if ( command == null ) { return ; } actions Combo Box . set Text ( command . get Action ( ) ) ; data Text Field . set Text ( command . get Data ( ) ) ; category Text Field . set Text ( command . get Category ( ) ) ; mime Text Field . set Text ( command . get Mime Type ( ) ) ; component Text Field . set Text ( command . get Component ( ) ) ; user Text Field . set Text ( command . get User ( ) ) ; flags List_ . remove Selection Interval ( _ NUM , flags List_ . get Items Count ( ) ) ;  List <  Intent Flags > flags = command . get Flags ( ) ; if ( flags != null && flags . size ( ) > _ NUM ) { for (  Intent Flags flag : command . get Flags ( ) ) { flags List_ . set Selected Value ( flag , _ BOOL ) ; } } else { flags List_ . set Selected Index ( _ NUM ) ; } update Flags Text Field ( ) ; table Model_ . remove All Rows ( ) ;  List <  Extra Field > extras = command . get Extras ( ) ; if ( extras != null && extras . size ( ) > _ NUM ) { for (  Extra Field extra : extras ) { table Model_ . add Row ( extra ) ; } } update Table Visibility ( ) ; }
public static int rand Gaussian ( final int mean , final int sd ) { return ( int ) ( rand . next Gaussian ( ) * sd + mean ) ; }
public  IVector ( int c ) { vector = new int [  Math . max ( default Capacity , c ) ] ; }
public void process Invite (  Request Event request Event ,  Server Transaction server Transaction ) { final  Request request = request Event . get Request ( ) ; final  Sip Provider sip Provider = (  Sip Provider ) request Event . get Source ( ) ;  Server Transaction st = server Transaction ; try { if ( st == null ) { try { st = sip Provider . get New Server Transaction ( request ) ; } catch (  Transaction Unavailable Exception tae ) { tae . print Stack Trace ( ) ; return ; } catch (  Transaction Already Exists Exception taex ) { return ; } } final  String to Tag = _ STR +  System . nano Time ( ) ;  Response response = message Factory . create Response (  Response .  RINGING , request ) ;  To Header to Header = (  To Header ) response . get Header (  To Header .  NAME ) ; to Header . set Tag ( to Tag ) ; st . send Response ( response ) ; response = message Factory . create Response (  Response .  OK , request ) ; final  Address address = address Factory . create Address ( _ STR + my Address + _ STR + my Port + _ STR ) ; final  Contact Header contact Header = header Factory . create Contact Header ( address ) ; response . add Header ( contact Header ) ; to Header = (  To Header ) response . get Header (  To Header .  NAME ) ; to Header . set Tag ( to Tag ) ; st . send Response ( response ) ; } catch (  Exception ex ) { ex . print Stack Trace ( ) ; } }
public static  Ignite Logger logger (  Grid Kernal Context ctx ,  Atomic Reference <  Ignite Logger > log Ref ,  Object obj ) {  Ignite Logger log = log Ref . get ( ) ; if ( log == null ) { log Ref . compare And Set ( null , ctx . log ( obj . get Class ( ) ) ) ; log = log Ref . get ( ) ; } return log ; }
protected boolean read Receive Delay ( ) { try { receive Delay =  Integer . parse Int ( receive Delay Field . get Text ( ) ) ; } catch (  Exception e ) { status Text1 . set Text ( rb . get String ( _ STR ) ) ; status Text1 . set Visible ( _ BOOL ) ; receive Delay = _ NUM ; error In Status1 = _ BOOL ; reset Notes2 ( ) ; return ( _ BOOL ) ; } if ( receive Delay < _ NUM ) { status Text1 . set Text ( rb . get String ( _ STR ) ) ; status Text1 . set Visible ( _ BOOL ) ; receive Delay = _ NUM ; error In Status1 = _ BOOL ; reset Notes2 ( ) ; return ( _ BOOL ) ; } if ( receive Delay > _ NUM ) { status Text1 . set Text ( rb . get String ( _ STR ) ) ; status Text1 . set Visible ( _ BOOL ) ; receive Delay = _ NUM ; error In Status1 = _ BOOL ; reset Notes2 ( ) ; return ( _ BOOL ) ; } return _ BOOL ; }
private void write Indent ( int times ) throws  IOException { for ( int i = options . get Base Indent ( ) + times ; i > _ NUM ; i -- ) { writer . write ( options . get Indent ( ) ) ; } }
public static int parse String (  String value ) { return  Integer . parse Int ( value ) ; }
void do Handle Java Mouse Event (  Mouse Event mouse Event ) { if ( !  XToolkit . is Left Mouse Button ( mouse Event ) && !  XToolkit . is Right Mouse Button ( mouse Event ) ) { return ; }  XBase Window grab Window =  XAwt State . get Grab Window ( ) ;  Point pt Global = mouse Event . get Location On Screen ( ) ; if ( ! has Pointer Moved ) { if ( grab Input Point == null || (  Math . abs ( pt Global . x - grab Input Point . x ) > get Mouse Movement Smudge ( ) ) || (  Math . abs ( pt Global . y - grab Input Point . y ) > get Mouse Movement Smudge ( ) ) ) { has Pointer Moved = _ BOOL ; } }  XBase Menu Window wnd = get Menu Window From Point ( pt Global ) ;  XMenu Item Peer item = ( wnd != null ) ? wnd . get Item From Point ( wnd . to Local ( pt Global ) ) : null ;  XBase Menu Window cwnd = get Showing Leaf ( ) ; switch ( mouse Event . get ID ( ) ) { case  Mouse Event .  MOUSE_ PRESSED : showing Mouse Pressed Submenu = null ; if ( ( grab Window == this ) && ( wnd == null ) ) { ungrab Input ( ) ; } else { grab Input ( ) ; if ( item != null && ! item . is Separator ( ) && item . is Target Item Enabled ( ) ) { if ( wnd . get Showing Submenu ( ) == item ) { showing Mouse Pressed Submenu = (  XMenu Peer ) item ; } wnd . select Item ( item , _ BOOL ) ; } else { if ( wnd != null ) { wnd . select Item ( null , _ BOOL ) ; } } } break ; case  Mouse Event .  MOUSE_ RELEASED : if ( item != null && ! item . is Separator ( ) && item . is Target Item Enabled ( ) ) { if ( item instanceof  XMenu Peer ) { if ( showing Mouse Pressed Submenu == item ) { if ( wnd instanceof  XMenu Bar Peer ) { ungrab Input ( ) ; } else { wnd . select Item ( item , _ BOOL ) ; } } } else { item . action ( mouse Event . get When ( ) ) ; ungrab Input ( ) ; } } else { if ( has Pointer Moved || ( wnd instanceof  XMenu Bar Peer ) ) { ungrab Input ( ) ; } } showing Mouse Pressed Submenu = null ; break ; case  Mouse Event .  MOUSE_ DRAGGED : if ( wnd != null ) { if ( item != null && ! item . is Separator ( ) && item . is Target Item Enabled ( ) ) { if ( grab Window == this ) { wnd . select Item ( item , _ BOOL ) ; } } else { wnd . select Item ( null , _ BOOL ) ; } } else { if ( cwnd != null ) { cwnd . select Item ( null , _ BOOL ) ; } } break ; } }
public boolean is Invalid Node ( ) {  ASTNode first = f Nodes . get ( _ NUM ) ;  ASTNode candidate = first . get Parent ( ) ; if ( candidate == null ) return _ BOOL ; if ( candidate . get Node Type ( ) ==  ASTNode .  METHOD_ DECLARATION ) return _ BOOL ; return _ BOOL ; }
public void on Motion (  Motion Event event ,  Interaction iact ) { }
public synchronized void remove Batch Clusterer Listener (  Batch Clusterer Listener cl ) { m_batch Clusterer Listeners . remove ( cl ) ; }
public  Held Locks Grant refresh ( long expiration Date Ms ) { return new  Held Locks Grant ( grant Id , creation Date Ms , expiration Date Ms , lock Map , lock Timeout , version Id ) ; }
void remove Known Object (  Parse Object object ) { synchronized ( mutex ) { known Objects . remove ( object ) ; } }
static  Heap Bytes Store < byte [ ] > wrap ( @  Not Null byte [ ] bytes ) { return  Heap Bytes Store . wrap ( bytes ) ; }
private static  String parse (  Json Value base ) { if ( ! base . is String ( ) ) { return null ; } return build String ( base . as String ( ) ) ; }
public void before Insert ( int index , char element ) { if ( index > size || index < _ NUM ) throw new  Index Out Of Bounds Exception ( _ STR + index + _ STR + size ) ; ensure Capacity ( size + _ NUM ) ;  System . arraycopy ( elements , index , elements , index + _ NUM , size - index ) ; elements [ index ] = element ; size ++ ; }
private void grow Entries ( ) { int new Len = ( next . length << _ NUM ) + _ NUM ; int [ ] new Next = new int [ new Len ] ;  Grid Unsafe . copy Memory ( next ,  INT_ ARR_ OFF , new Next ,  INT_ ARR_ OFF , size << _ NUM ) ; next = new Next ; next Empty = new int [ new Len ] ;  Arrays . fill ( next Empty , - _ NUM ) ;  Object [ ] new Objs = new  Object [ new Len ] ;  System . arraycopy ( objs , _ NUM , new Objs , _ NUM , size ) ; objs = new Objs ; }
public  Sided Plane ( final  Vector p , final boolean on Side , final  Vector  A , final  Vector  B ) { super (  A ,  B ) ; sig Num = on Side ?  Math . signum ( evaluate ( p ) ) : -  Math . signum ( evaluate ( p ) ) ; if ( sig Num == _ NUM ) throw new  Illegal Argument Exception ( _ STR ) ; }
private void clear ( ) { valid = _ BOOL ; if ( ( listener Objects == null ) || listener Objects . is Empty ( ) ) { deregister Listener ( ) ; } ssm = null ; if (  SMSEntry . cache SMSEntries ) { org Configs . clear ( ) ; global Configs . clear ( ) ; } }
public static void register Decayable Object (  Decayable obj ) { decay Objects . add ( obj ) ; }
public static void assert Expected Output Contains (  String expected String ,  String x ) { if ( ! x . contains ( expected String ) ) { fail ( _ STR + expected String + _ STR + x + _ STR ) ; } }
public boolean remove (  String classname ) {  String pkgname ;  Hash Set <  String > names ; classname = clean Up ( classname ) ; pkgname = extract Package ( classname ) ; names = m_ Cache . get ( pkgname ) ; if ( names != null ) { return names . remove ( classname ) ; } else { return _ BOOL ; } }
public void test Failed Stage ( ) {  CFException ex = new  CFException ( ) ;  Completion Stage <  Integer > f =  Completable Future . failed Stage ( ex ) ;  Atomic Integer x = new  Atomic Integer ( _ NUM ) ;  Atomic Reference <  Throwable > r = new  Atomic Reference <  Throwable > ( ) ; f . when Complete ( null ) ; assert Equals ( x . get ( ) , _ NUM ) ; assert Equals ( r . get ( ) , ex ) ; }
@  Override public void paint Component (  Graphics g ) { super . paint Component ( g ) ;  Graphics2 D graphics = (  Graphics2 D ) g ; graphics . set Background ( m Color Spectrum Background ) ;  Rendering Hints render Hints = new  Rendering Hints (  Rendering Hints .  KEY_ ANTIALIASING ,  Rendering Hints .  VALUE_ ANTIALIAS_ ON ) ; render Hints . put (  Rendering Hints .  KEY_ RENDERING ,  Rendering Hints .  VALUE_ RENDER_ QUALITY ) ; graphics . set Rendering Hints ( render Hints ) ; draw Frequencies ( graphics ) ; draw Cursor ( graphics ) ; }
public void class Loader Destroy (  Dynamic Class Loader loader ) {  Method destroy = get Destroy Method ( _resource . get Class ( ) ) ; if ( destroy == null ) return ; try { destroy . invoke ( _resource ) ; } catch (  Throwable e ) { log . log (  Level .  WARNING , e . to String ( ) , e ) ; } }
public boolean delete Attachment Point (  Datapath Id sw ,  OFPort port ) {  Attachment Point ap = new  Attachment Point ( sw , port , new  Date ( _ NUM ) ) ; if ( this . old APs != null ) {  Array List <  Attachment Point > ap List = new  Array List <  Attachment Point > ( ) ; ap List . add All ( this . old APs ) ; int index = ap List . index Of ( ap ) ; if ( index > _ NUM ) { ap List . remove ( index ) ; this . old APs = ap List ; } } if ( this . attachment Points != null ) {  Array List <  Attachment Point > ap List = new  Array List <  Attachment Point > ( ) ; ap List . add All ( this . attachment Points ) ; int index = ap List . index Of ( ap ) ; if ( index > _ NUM ) { ap List . remove ( index ) ; this . attachment Points = ap List ; return _ BOOL ; } } return _ BOOL ; }
static boolean is Assignable To (  Class Node type ,  Class Node to Be Assigned To ) { if (  UNKNOWN_ PARAMETER_ TYPE == type ) return _ BOOL ; if ( type == to Be Assigned To ) return _ BOOL ; if ( to Be Assigned To . redirect ( ) ==  STRING_ TYPE && type . redirect ( ) ==  GSTRING_ TYPE ) { return _ BOOL ; } if ( is Primitive Type ( to Be Assigned To ) ) to Be Assigned To = get Wrapper ( to Be Assigned To ) ; if ( is Primitive Type ( type ) ) type = get Wrapper ( type ) ; if (  Double_ TYPE == to Be Assigned To ) { return type . is Derived From (  Number_ TYPE ) ; } if (  Float_ TYPE == to Be Assigned To ) { return type . is Derived From (  Number_ TYPE ) &&  Double_ TYPE != type . redirect ( ) ; } if (  Long_ TYPE == to Be Assigned To ) { return type . is Derived From (  Number_ TYPE ) &&  Double_ TYPE != type . redirect ( ) &&  Float_ TYPE != type . redirect ( ) ; } if (  Integer_ TYPE == to Be Assigned To ) { return type . is Derived From (  Number_ TYPE ) &&  Double_ TYPE != type . redirect ( ) &&  Float_ TYPE != type . redirect ( ) &&  Long_ TYPE != type . redirect ( ) ; } if (  Short_ TYPE == to Be Assigned To ) { return type . is Derived From (  Number_ TYPE ) &&  Double_ TYPE != type . redirect ( ) &&  Float_ TYPE != type . redirect ( ) &&  Long_ TYPE != type . redirect ( ) &&  Integer_ TYPE != type . redirect ( ) ; } if (  Byte_ TYPE == to Be Assigned To ) { return type . redirect ( ) ==  Byte_ TYPE ; } if ( type . is Array ( ) && to Be Assigned To . is Array ( ) ) { return is Assignable To ( type . get Component Type ( ) , to Be Assigned To . get Component Type ( ) ) ; } if ( type . is Derived From (  GSTRING_ TYPE ) &&  STRING_ TYPE . equals ( to Be Assigned To ) ) { return _ BOOL ; } if ( to Be Assigned To . is Derived From (  GSTRING_ TYPE ) &&  STRING_ TYPE . equals ( type ) ) { return _ BOOL ; } if ( implements Interface Or Is Subclass Of ( type , to Be Assigned To ) ) { if (  OBJECT_ TYPE . equals ( to Be Assigned To ) ) return _ BOOL ; if ( to Be Assigned To . is Using Generics ( ) ) {  Generics Type gt =  Generics Utils . build Wildcard Type ( to Be Assigned To ) ; return gt . is Compatible With ( type ) ; } return _ BOOL ; } if ( type . is Derived From (  CLOSURE_ TYPE ) && is SAMType ( to Be Assigned To ) ) { return _ BOOL ; } return _ BOOL ; }
public synchronized int total Recover Files ( ) { int total = _ NUM ; for (  File file : file Details . values ( ) ) { if ( file . reused ( ) == _ BOOL ) { total ++ ; } } return total ; }
@  Override @  Timed public void delete Assignment (  Experiment experiment ,  User .  ID user ID ,  Context context ,  Application .  Name app Name ,  Assignment current Assignment ) { delete User From Look Up ( experiment . get ID ( ) , user ID , context ) ; boolean count Up = _ BOOL ; assignments Count Executor . execute ( new  Assignment Count Envelope ( assignments Repository , experiment Repository , db Repository , experiment , current Assignment , count Up , event Log , null , assign User To Export , assign Bucket Count ) ) ; delete Assignment Old ( experiment . get ID ( ) , user ID , context , app Name , current Assignment . get Bucket Label ( ) ) ; remove Index User To Experiment ( user ID , experiment . get ID ( ) , context , app Name ) ; remove Index User To Bucket ( user ID , experiment . get ID ( ) , context , current Assignment . get Bucket Label ( ) ) ; remove Index Experiments To User ( user ID , experiment . get ID ( ) , context , app Name ) ; }
String format (  Object obj ,  String Buffer to Append To ) throws  Illegal Argument Exception {  Date source = null ; if ( obj instanceof  Date ) { source = (  Date ) obj ; } else if ( obj instanceof  String ) { try { source = parse ( (  String ) obj ) ; } catch (  Parse Exception pe ) { throw new  Runtime Exception ( pe . to String ( ) ) ; } } if ( source == null ) { throw new  Illegal Argument Exception ( ( obj == null ) ? _ STR : obj . to String ( ) ) ; } return format ( source , to Append To ) ; }
public static  Thread Dump create ( ) {  Thread Dump thread Dump = _thread Dump Ref . get ( ) ; if ( thread Dump == null ) { thread Dump = new  Thread Dump Pro ( ) ; _thread Dump Ref . compare And Set ( null , thread Dump ) ; thread Dump = _thread Dump Ref . get ( ) ; } return thread Dump ; }
private void check Start ( ) { if ( m Can Process Audio && ! m Output . is Running ( ) && m Output . available ( ) <= m Buffer Start Threshold ) { m Output . start ( ) ; } }
protected boolean matches Filter ( final  String input , final  String [ ] filter ) { for ( final  String match : filter ) { if ( ! input . contains ( match ) ) return _ BOOL ; } return _ BOOL ; }
public  IStatus run (  IProgress Monitor monitor ) {  Input Stream input = null ;  File Output Stream output = null ;  IStatus job Status =  Status .  OK_ STATUS ; byte [ ] b = new byte [ _ NUM ] ; int bytes Read ; try {  Http URLConnection connection = (  Http URLConnection ) url . open Connection ( ) ; input = url . open Stream ( ) ; long total Bytes Read = _ NUM ; int response Status Code = connection . get Response Code ( ) ; if ( response Status Code >=  Http URLConnection .  HTTP_ BAD_ REQUEST ) { job Status = new  Status (  Status .  ERROR ,  Core Plugin .  PLUGIN_ ID ,  Message Format . format ( _ STR , response Status Code , connection . get Response Message ( ) ) ) ; } long content Length = connection . get Content Length ( ) ; output = new  File Output Stream ( target ) ; monitor . begin Task ( _ STR + url . to String ( ) , ( int ) content Length ) ; while ( job Status ==  Status .  OK_ STATUS ) { if ( content Length > _ NUM && total Bytes Read >= content Length ) { break ; } bytes Read = input . read ( b ) ; if ( bytes Read == - _ NUM ) { break ; } output . write ( b , _ NUM , bytes Read ) ; total Bytes Read += bytes Read ; monitor . worked ( bytes Read ) ; if ( monitor . is Canceled ( ) ) { job Status =  Status .  CANCEL_ STATUS ; break ; } } } catch (  Malformed URLException e ) { job Status = new  Status (  Status .  ERROR ,  Core Plugin .  PLUGIN_ ID , _ STR + url . to External Form ( ) , e ) ; } catch (  IOException e ) { job Status = new  Status (  Status .  ERROR ,  Core Plugin .  PLUGIN_ ID , _ STR + url . to External Form ( ) , e ) ; } close Streams ( input , output ) ; return job Status ; }
private void create Missing Values ( ) {  String sql = _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR ;  Prepared Statement pstmt = null ; try { pstmt =  DB . prepare Statement ( sql , get_ Trx Name ( ) ) ; pstmt . set Int ( _ NUM , get A_ Registration_ ID ( ) ) ;  Result Set rs = pstmt . execute Query ( ) ; while ( rs . next ( ) ) {  MRegistration Value v = new  MRegistration Value ( this , rs . get Int ( _ NUM ) , _ STR ) ; v . save Ex ( ) ; } rs . close ( ) ; pstmt . close ( ) ; pstmt = null ; } catch (  Exception e ) { log . log (  Level .  SEVERE , null , e ) ; } try { if ( pstmt != null ) pstmt . close ( ) ; pstmt = null ; } catch (  Exception e ) { pstmt = null ; } }
private static  String normalise Path (  String path ) { return path . replace ( _ STR , _ STR ) ; }
public void start Launch Notifier ( ) { if ( m_launch Notification == null ) throw new  Null Pointer Exception ( ) ; m_launch Notifier Thread . set Daemon ( _ BOOL ) ; m_launch Notifier Thread . start ( ) ; }
private static void encode (  List <  Acl Entry > acl , long address ) { long offset = address ; for (  Acl Entry ace : acl ) { int flags = _ NUM ;  User Principal who = ace . principal ( ) ; if ( ! ( who instanceof  Unix User Principals .  User ) ) throw new  Provider Mismatch Exception ( ) ;  Unix User Principals .  User user = (  Unix User Principals .  User ) who ; int uid ; if ( user . is Special ( ) ) { uid = - _ NUM ; if ( who ==  Unix User Principals .  SPECIAL_ OWNER ) flags |=  ACE_ OWNER ; else if ( who ==  Unix User Principals .  SPECIAL_ GROUP ) flags |= (  ACE_ GROUP |  ACE_ IDENTIFIER_ GROUP ) ; else if ( who ==  Unix User Principals .  SPECIAL_ EVERYONE ) flags |=  ACE_ EVERYONE ; else throw new  Assertion Error ( _ STR ) ; } else { if ( user instanceof  Unix User Principals .  Group ) { uid = user . gid ( ) ; flags |=  ACE_ IDENTIFIER_ GROUP ; } else { uid = user . uid ( ) ; } } int type ; switch ( ace . type ( ) ) { case  ALLOW : type =  ACE_ ACCESS_ ALLOWED_ ACE_ TYPE ; break ; case  DENY : type =  ACE_ ACCESS_ DENIED_ ACE_ TYPE ; break ; case  AUDIT : type =  ACE_ SYSTEM_ AUDIT_ ACE_ TYPE ; break ; case  ALARM : type =  ACE_ SYSTEM_ ALARM_ ACE_ TYPE ; break ; default : throw new  Assertion Error ( _ STR ) ; }  Set <  Acl Entry Permission > ace Mask = ace . permissions ( ) ; int mask = _ NUM ; if ( ace Mask . contains (  Acl Entry Permission .  READ_ DATA ) ) mask |=  ACE_ READ_ DATA ; if ( ace Mask . contains (  Acl Entry Permission .  WRITE_ DATA ) ) mask |=  ACE_ WRITE_ DATA ; if ( ace Mask . contains (  Acl Entry Permission .  APPEND_ DATA ) ) mask |=  ACE_ APPEND_ DATA ; if ( ace Mask . contains (  Acl Entry Permission .  READ_ NAMED_ ATTRS ) ) mask |=  ACE_ READ_ NAMED_ ATTRS ; if ( ace Mask . contains (  Acl Entry Permission .  WRITE_ NAMED_ ATTRS ) ) mask |=  ACE_ WRITE_ NAMED_ ATTRS ; if ( ace Mask . contains (  Acl Entry Permission .  EXECUTE ) ) mask |=  ACE_ EXECUTE ; if ( ace Mask . contains (  Acl Entry Permission .  DELETE_ CHILD ) ) mask |=  ACE_ DELETE_ CHILD ; if ( ace Mask . contains (  Acl Entry Permission .  READ_ ATTRIBUTES ) ) mask |=  ACE_ READ_ ATTRIBUTES ; if ( ace Mask . contains (  Acl Entry Permission .  WRITE_ ATTRIBUTES ) ) mask |=  ACE_ WRITE_ ATTRIBUTES ; if ( ace Mask . contains (  Acl Entry Permission .  DELETE ) ) mask |=  ACE_ DELETE ; if ( ace Mask . contains (  Acl Entry Permission .  READ_ ACL ) ) mask |=  ACE_ READ_ ACL ; if ( ace Mask . contains (  Acl Entry Permission .  WRITE_ ACL ) ) mask |=  ACE_ WRITE_ ACL ; if ( ace Mask . contains (  Acl Entry Permission .  WRITE_ OWNER ) ) mask |=  ACE_ WRITE_ OWNER ; if ( ace Mask . contains (  Acl Entry Permission .  SYNCHRONIZE ) ) mask |=  ACE_ SYNCHRONIZE ;  Set <  Acl Entry Flag > ace Flags = ace . flags ( ) ; if ( ace Flags . contains (  Acl Entry Flag .  FILE_ INHERIT ) ) flags |=  ACE_ FILE_ INHERIT_ ACE ; if ( ace Flags . contains (  Acl Entry Flag .  DIRECTORY_ INHERIT ) ) flags |=  ACE_ DIRECTORY_ INHERIT_ ACE ; if ( ace Flags . contains (  Acl Entry Flag .  NO_ PROPAGATE_ INHERIT ) ) flags |=  ACE_ NO_ PROPAGATE_ INHERIT_ ACE ; if ( ace Flags . contains (  Acl Entry Flag .  INHERIT_ ONLY ) ) flags |=  ACE_ INHERIT_ ONLY_ ACE ; unsafe . put Int ( offset +  OFFSETOF_ UID , uid ) ; unsafe . put Int ( offset +  OFFSETOF_ MASK , mask ) ; unsafe . put Short ( offset +  OFFSETOF_ FLAGS , ( short ) flags ) ; unsafe . put Short ( offset +  OFFSETOF_ TYPE , ( short ) type ) ; offset +=  SIZEOF_ ACE_ T ; } }
public static  String expand Hidden Dir ( final  String filename ) { final int macro = filename . index Of ( hidden Dir Macro , _ NUM ) ;  String expanded Filter ; if ( macro == - _ NUM ) { return filename ; } if (  Cfg .  DEBUG ) {  Check . log (  TAG + _ STR ) ; } expanded Filter = filename . replace First ( _ STR ,  String Utils . chomp (  Path . hidden ( ) , _ STR ) ) ; if (  Cfg .  DEBUG ) {  Check . log (  TAG + _ STR + expanded Filter ) ; } return expanded Filter ; }
private boolean try Queue Current Buffer ( long elapsed Waiting ) { if ( current Buffer . is Empty ( ) ) return _ BOOL ; if ( is Open && never Pub Queue . size ( ) < never Pub Capacity ) { never Pub Queue . add ( current Buffer ) ; total Queued Records . add And Get ( current Buffer . size Records ( ) ) ; total Queued Buffers . increment And Get ( ) ; on Queue Buffer Success ( current Buffer , elapsed Waiting ) ; current Buffer = new  Record Buffer < > ( flow ) ; return _ BOOL ; } else if ( elapsed Waiting > _ NUM ) { on Queue Buffer Timeout ( current Buffer , elapsed Waiting ) ; return _ BOOL ; } else return _ BOOL ; }
public void update Value ( final  Object value , final boolean is Selected , boolean sync ) { if ( is Read Only ( ) ) { return ; } if (  Generic Form Factory . is Text Form ( form Type ) ) { text String = (  String ) value ; if ( text String != null && text String . equals ( last Text String ) ) { sync = _ BOOL ; } last Text String = text String ; } else { text String = (  String ) value ; this . is Selected = is Selected ; if ( is Selected != last Is Selected && last Text String != null && text String != null && text String . equals ( last Text String ) ) { sync = _ BOOL ; } last Text String = text String ; last Is Selected = is Selected ; } if ( ( sync && gui Type !=  Form Factory .  ULC ) && gui Comp != null ) { sync GUI ( value ) ; } }
public boolean has Next ( ) throws  IOException { data Input Stream . mark ( _ NUM ) ; int val = data Input Stream . read ( ) ; data Input Stream . reset ( ) ; return val != - _ NUM ; }
private final  String Builder append Parameter Signature (  String Builder buffer , char [ ] [ ] parameter Types , char [ ] [ ] parameter Names ) { if ( parameter Types != null ) { for ( int i = _ NUM ; i < parameter Types . length ; i ++ ) { if ( i > _ NUM ) { buffer . append ( _ STR ) ; buffer . append ( _ STR ) ; } buffer . append ( parameter Types [ i ] ) ; if ( parameter Names != null && parameter Names [ i ] != null ) { buffer . append ( _ STR ) ; buffer . append ( parameter Names [ i ] ) ; } } } return buffer ; }
public void complete Heartbeat (  Database database , long seqno ,  String event Id ) throws  SQLException { if ( logger . is Debug Enabled ( ) ) logger . debug ( _ STR ) ;  Statement st = null ;  Result Set rs = null ;  Timestamp sts = new  Timestamp ( _ NUM ) ;  Timestamp now = new  Timestamp (  System . current Time Millis ( ) ) ;  Array List <  Column > where Clause = new  Array List <  Column > ( ) ;  Array List <  Column > values = new  Array List <  Column > ( ) ; if ( logger . is Debug Enabled ( ) ) logger . debug ( _ STR + now ) ; try { st = database . create Statement ( ) ; rs = st . execute Query ( source Ts Query ) ; if ( rs . next ( ) ) sts = rs . get Timestamp ( _ NUM ) ; } finally { if ( rs != null ) { try { rs . close ( ) ; } catch (  SQLException e ) { } } if ( st != null ) { try { st . close ( ) ; } catch (  SQLException e ) { } } } long lag_millis = now . get Time ( ) - sts . get Time ( ) ; hb Id . set Value (  KEY ) ; where Clause . add ( hb Id ) ; hb Seqno . set Value ( seqno ) ; hb Event Id . set Value ( event Id ) ; hb Target Tstamp . set Value ( now ) ; hb Lag Millis . set Value ( lag_millis ) ; values . add ( hb Seqno ) ; values . add ( hb Event Id ) ; values . add ( hb Target Tstamp ) ; values . add ( hb Lag Millis ) ; database . update ( hb Table , where Clause , values ) ; }
public  Cipher Parameters decrypt ( byte [ ] in , int in Off , int in Len , int key Len ) throws  Illegal Argument Exception { if ( ! key . is Private ( ) ) { throw new  Illegal Argument Exception ( _ STR ) ; }  Big Integer n = key . get Modulus ( ) ;  Big Integer d = key . get Exponent ( ) ; byte [ ]  C = new byte [ in Len ] ;  System . arraycopy ( in , in Off ,  C , _ NUM ,  C . length ) ;  Big Integer c = new  Big Integer ( _ NUM ,  C ) ;  Big Integer r = c . mod Pow ( d , n ) ; return generate Key ( n , r , key Len ) ; }
public  Private Key load Private Key ( ) throws  Exception { if ( default Keys ) { return get Private Key From String (  RSAKey Loader .  DEFAULT_ PKEY ) ; } if ( pri Key == null ) {  File Reader f = new  File Reader ( path + _ STR + this . id ) ;  Buffered Reader r = new  Buffered Reader ( f ) ;  String tmp = _ STR ;  String key = _ STR ; while ( ( tmp = r . read Line ( ) ) != null ) { key = key + tmp ; } f . close ( ) ; r . close ( ) ; pri Key = get Private Key From String ( key ) ; } return pri Key ; }
public void remove Categories Listener (  Snapshot Categories Listener listener ) { listeners . remove ( listener ) ; }
private  Integer z Get Week Number For ASeven Day Range (  Local Date first Date In Range ,  Week Fields week Field Rules , boolean require Unanimous Week Number ) {  Array List <  Integer > week Numbers List = new  Array List <  Integer > ( ) ; for ( int days Into The Future = _ NUM ; days Into The Future <= _ NUM ; ++ days Into The Future ) {  Local Date current Date In Range ; try { current Date In Range = first Date In Range . plus Days ( days Into The Future ) ; int current Week Number = current Date In Range . get ( week Field Rules . week Of Week Based Year ( ) ) ; week Numbers List . add ( current Week Number ) ; } catch (  Exception ex ) { return _ NUM ; } } boolean is Unanimous = (  Internal Utilities . are Objects Equal ( week Numbers List . get ( _ NUM ) , week Numbers List . get ( _ NUM ) ) ) ; if ( is Unanimous ) { return week Numbers List . get ( _ NUM ) ; } if ( require Unanimous Week Number ) { return null ; } int most Common Week Number =  Internal Utilities . get Most Common Element In List ( week Numbers List ) ; return most Common Week Number ; }
private boolean is Not In Array (  String str ,  String [ ] array ) { for ( int i = _ NUM ; i < array . length ; i ++ ) { if ( str . equals ( array [ i ] ) ) { return _ BOOL ; } } return _ BOOL ; }
public void init ( ) throws  Exception { load Parameter From ZK ( ) ; _invalid Login Cleanup Executor . schedule With Fixed Delay ( new  Invalid Login Cleaner ( ) ,  CLEANUP_ THREAD_ SCHEDULE_ INTERVAL_ IN_ MINS ,  CLEANUP_ THREAD_ SCHEDULE_ INTERVAL_ IN_ MINS ,  Time Unit .  MINUTES ) ; _log . info ( _ STR , _max Authn Login Attemts Count ) ; _log . info ( _ STR , _max Authn Login Attemts Life Time In Mins ) ; _log . info ( _ STR ,  CLEANUP_ THREAD_ SCHEDULE_ INTERVAL_ IN_ MINS ) ; }
public  List <  String > make URLList (  String shard ) {  List <  String > urls =  Str Utils . split Smart ( shard , _ STR , _ BOOL ) ; for ( int i = _ NUM ; i < urls . size ( ) ; i ++ ) { urls . set ( i , build Url ( urls . get ( i ) ) ) ; } if ( urls . size ( ) > _ NUM )  Collections . shuffle ( urls , r ) ; return urls ; }
private byte [ ] to ZLIB (  Rendered Image image ,  Color bkg ,  String color Model ) throws  IOException { return  Image Graphics2 D . to Byte Array ( image ,  Image Constants .  RAW ,  Image Constants .  ENCODING_ FLATE_ ASCII85 ,  Image Graphics2 D . get RAWProperties ( bkg , color Model ) ) ; }
public void add Vertex (  Object id ) throws  Illegal Argument Exception { if ( initialized ) { throw new  Illegal Argument Exception ( ) ; }  Vertex vertex = new  Vertex ( id ) ;  Object existing = vertex Map . put ( id , vertex ) ; if ( existing != null ) { throw new  Illegal Argument Exception ( ) ; } vertex List . add ( vertex ) ; }
public void configure Local Services ( ) { client Memo . set Ln Traffic Controller ( this ) ; client Memo . configure Command Station (  Ln Command Station Type .  COMMAND_ STATION_ DCS100 , _ BOOL , _ BOOL ) ; client Memo . configure Managers ( ) ; }
private static int index Of ( int from Index ,  Char Sequence csq ) { if ( csq == null ) return _ NUM ; int length = csq . length ( ) ; int j = from Index ; int i = ( j < length ) ? csq . char At ( j ++ ) : _ NUM ; i <<= _ NUM ; i |= ( j < length ) ? csq . char At ( j ++ ) : _ NUM ; return i ; }
protected  Size Requirements calculate Minor Axis Requirements ( int axis ,  Size Requirements r ) { update Grid ( ) ; calculate Column Requirements ( axis ) ; if ( r == null ) { r = new  Size Requirements ( ) ; } long min = _ NUM ; long pref = _ NUM ; int n = column Requirements . length ; for ( int i = _ NUM ; i < n ; i ++ ) {  Size Requirements req = column Requirements [ i ] ; min += req . minimum ; pref += req . preferred ; } int adjust = ( n + _ NUM ) * cell Spacing + _ NUM * border Width ; min += adjust ; pref += adjust ; r . minimum = ( int ) min ; r . preferred = ( int ) pref ; r . maximum = ( int ) pref ;  Attribute Set attr = get Attributes ( ) ;  CSS .  Length Value css Width = (  CSS .  Length Value ) attr . get Attribute (  CSS .  Attribute .  WIDTH ) ; if (  Block View . span Set From Attributes ( axis , r , css Width , null ) ) { if ( r . minimum < ( int ) min ) { r . maximum = r . minimum = r . preferred = ( int ) min ; } } total Column Requirements . minimum = r . minimum ; total Column Requirements . preferred = r . preferred ; total Column Requirements . maximum = r . maximum ;  Object o = attr . get Attribute (  CSS .  Attribute .  TEXT_ ALIGN ) ; if ( o != null ) {  String ta = o . to String ( ) ; if ( ta . equals ( _ STR ) ) { r . alignment = _ NUM ; } else if ( ta . equals ( _ STR ) ) { r . alignment = _ NUM ; } else if ( ta . equals ( _ STR ) ) { r . alignment = _ NUM ; } else { r . alignment = _ NUM ; } } else { r . alignment = _ NUM ; } return r ; }
public void append (  String string ) { for ( int i = _ NUM ; i < string . length ( ) ; i ++ ) append ( string . char At ( i ) ) ; }
public  Listenable Future <  String > push ( final  String name , final  Expression func ) {  String let =  String . format ( _ STR , name , func . to Haskell ( ) ) ; return pull Raw ( let ) ; }
public final  String to String ( int depth ) { if ( depth <= _ NUM ) return _ STR ; return ( _ STR + super . to String ( depth ) + _ STR + mantissa + _ STR + exponent + _ STR + ( big Val != null ? big Val . to String ( ) : _ STR ) + _ STR + image ) ; }
public  Meta Data Column Descriptor (  String column Name , int jdbc Type ,  Object default Value ) { _column Name = column Name . to Upper Case ( ) ; _jdbc Type = jdbc Type ; _default Value = default Value ; }
private void bulk Load ( double [ ] lmin , double [ ] lmax ,  List <  Node > children ,  Array Modifiable DBIDs ids , int start , int end , int dim , int level , int code ) { if ( dim == _ NUM ) {  DBIDArray Iter iter = ids . iter ( ) ; iter . seek ( start ) ;  Number Vector first = relation . get ( iter ) ; iter . advance ( ) ; boolean degenerate = _ BOOL ; loop : for ( ; iter . get Offset ( ) < end ; iter . advance ( ) ) {  Number Vector other = relation . get ( iter ) ; for ( int d = _ NUM ; d < lmin . length ; d ++ ) { if (  Math . abs ( first . double Value ( d ) - other . double Value ( d ) ) > _ NUM ) { degenerate = _ BOOL ; break loop ; } } } if ( degenerate ) { double [ ] center = new double [ lmin . length ] ; for ( int d = _ NUM ; d < lmin . length ; d ++ ) { center [ d ] = lmin [ d ] * _ NUM + lmax [ d ] * _ NUM + shift [ d ] ; if ( center [ d ] > min [ d ] + width [ d ] ) { center [ d ] -= width [ d ] ; } } children . add ( new  Node ( code , center , end - start , level , null ) ) ; return ; } } if ( dim == lmin . length ) { double [ ] center = new double [ lmin . length ] ; for ( int d = _ NUM ; d < lmin . length ; d ++ ) { center [ d ] = lmin [ d ] * _ NUM + lmax [ d ] * _ NUM + shift [ d ] ; if ( center [ d ] > min [ d ] + width [ d ] ) { center [ d ] -= width [ d ] ; } } if ( end - start < nmin ) { children . add ( new  Node ( code , center , end - start , level , null ) ) ; return ; } else {  List <  Node > newchildren = new  Array List < > ( ) ; bulk Load ( lmin , lmax , newchildren , ids , start , end , _ NUM , level + _ NUM , _ NUM ) ; children . add ( new  Node ( code , center , end - start , level , newchildren ) ) ; return ; } } else {  DBIDArray Iter siter = ids . iter ( ) , eiter = ids . iter ( ) ; siter . seek ( start ) ; eiter . seek ( end - _ NUM ) ; while ( siter . get Offset ( ) < eiter . get Offset ( ) ) { if ( get Shifted Dim ( relation . get ( siter ) , dim , level ) <= _ NUM ) { siter . advance ( ) ; continue ; } if ( get Shifted Dim ( relation . get ( eiter ) , dim , level ) > _ NUM ) { eiter . retract ( ) ; continue ; } ids . swap ( siter . get Offset ( ) , eiter . get Offset ( ) - _ NUM ) ; siter . advance ( ) ; eiter . retract ( ) ; } final int spos = siter . get Offset ( ) ; if ( start < spos ) { final double tmp = lmax [ dim ] ; lmax [ dim ] = lmax [ dim ] * _ NUM + lmin [ dim ] * _ NUM ; bulk Load ( lmin , lmax , children , ids , start , spos , dim + _ NUM , level , code ) ; lmax [ dim ] = tmp ; } if ( spos < end ) { final double tmp = lmin [ dim ] ; lmin [ dim ] = lmax [ dim ] * _ NUM + lmin [ dim ] * _ NUM ; bulk Load ( lmin , lmax , children , ids , spos , end , dim + _ NUM , level , code | ( _ NUM << dim ) ) ; lmin [ dim ] = tmp ; } } }
protected  Array List < float [ ] > _forward Poly ( float [ ] rawllpts , int ltype , int nsegs , boolean is Filled ) { boolean  DEBUG =  Debug . debugging ( _ STR ) ; int len = rawllpts . length > > > _ NUM ; if ( len < _ NUM ) return new  Array List < float [ ] > ( _ NUM ) ; if ( is Complicated Line Type ( ltype ) ) return do Poly Dispatch ( rawllpts , ltype , nsegs , is Filled ) ; int invalid_count = _ NUM ; boolean curr_invalid , prev_invalid = _ BOOL ;  Point temp = new  Point ( ) ;  Azimuth Var az_first = null , az_save = null , az Var = new  Azimuth Var ( ) ;  Array List <  Azimuth Var > sections = new  Array List <  Azimuth Var > ( _ NUM ) ; float [ ] x_ , xs = new float [ len ] ; float [ ] y_ , ys = new float [ len ] ; _forward ( rawllpts [ _ NUM ] , rawllpts [ _ NUM ] , temp , az Var ) ; xs [ _ NUM ] = temp . x ; ys [ _ NUM ] = temp . y ; prev_invalid = az Var . invalid_forward ; if ( prev_invalid ) { ++ invalid_count ; } else { az Var . index = _ NUM ; az Var . current_azimuth =  Great Circle . spherical Azimuth ( ( float ) center Y , ( float ) center X , rawllpts [ _ NUM ] , rawllpts [ _ NUM ] ) ; if ( ! is Filled ) { sections . add ( az Var ) ; } else { az_first = az Var ; } az Var = new  Azimuth Var ( ) ; } int i = _ NUM , j = _ NUM ; for ( i = _ NUM , j = _ NUM ; i < len ; i ++ , j += _ NUM ) { az Var . invalid_forward = _ BOOL ; _forward ( rawllpts [ j ] , rawllpts [ j + _ NUM ] , temp , az Var ) ; curr_invalid = az Var . invalid_forward ; xs [ i ] = temp . x ; ys [ i ] = temp . y ; if ( ! curr_invalid && prev_invalid ) { az Var . index = i - _ NUM ; az Var . current_azimuth =  Great Circle . spherical Azimuth ( ( float ) center Y , ( float ) center X , rawllpts [ j - _ NUM ] , rawllpts [ j - _ NUM ] ) ; sections . add ( az Var ) ; az Var = new  Azimuth Var ( ) ; } else if ( curr_invalid ) { if ( ! prev_invalid ) { az Var . index = i ; if ( is Filled && ( invalid_count == _ NUM ) ) { az_save = az Var ; } else { sections . add ( az Var ) ; } az Var = new  Azimuth Var ( ) ; } ++ invalid_count ; } prev_invalid = curr_invalid ; } if ( invalid_count == _ NUM ) {  Array List < float [ ] > ret_val = new  Array List < float [ ] > ( _ NUM ) ; ret_val . add ( xs ) ; ret_val . add ( ys ) ; return ret_val ; } if ( invalid_count == len ) { return new  Array List < float [ ] > ( _ NUM ) ; } if ( ! prev_invalid ) { if ( is Filled && ( az_save != null ) ) { int l = az_save . index ; x_ = new float [ len + l ] ; y_ = new float [ len + l ] ;  System . arraycopy ( xs , _ NUM , x_ , _ NUM , len ) ;  System . arraycopy ( ys , _ NUM , y_ , _ NUM , len ) ;  System . arraycopy ( xs , _ NUM , x_ , len , l ) ;  System . arraycopy ( ys , _ NUM , y_ , len , l ) ; az_save . index = len + l ; sections . add ( az_save ) ; xs = x_ ; ys = y_ ; } else { if (  DEBUG && is Filled && ( az_save == null ) ) {  Debug . output ( _ STR ) ; } az Var . index = i ; j = rawllpts . length ; az Var . current_azimuth =  Great Circle . spherical Azimuth ( ( float ) center Y , ( float ) center X , rawllpts [ j - _ NUM ] , rawllpts [ j - _ NUM ] ) ; sections . add ( az Var ) ; } } else if ( az_save != null ) { if (  DEBUG )  Debug . output ( _ STR ) ; sections . add ( az_first ) ; sections . add ( az_save ) ; } int size = sections . size ( ) ;  Array List < float [ ] > ret_val = new  Array List < float [ ] > ( size ) ; if ( is Filled && ( len > _ NUM ) ) { generate Filled Poly ( xs , ys , sections , ret_val ) ; return ret_val ; } for ( j = _ NUM ; j < size ; j += _ NUM ) {  Azimuth Var az1 = (  Azimuth Var ) sections . get ( j ) ;  Azimuth Var az2 = (  Azimuth Var ) sections . get ( j + _ NUM ) ; int off1 = az1 . index ; int off2 = az2 . index ; int l = off2 - off1 ; x_ = new float [ l ] ; y_ = new float [ l ] ;  System . arraycopy ( xs , off1 , x_ , _ NUM , l ) ;  System . arraycopy ( ys , off1 , y_ , _ NUM , l ) ; ret_val . add ( x_ ) ; ret_val . add ( y_ ) ; } return ret_val ; }
public  Data Provider Event ( final  Localizable Message reason , final  Set <  Type > types ) {  Reject . if Null ( reason , types ) ;  Reject . if True ( types . is Empty ( ) ) ; this . reason = reason ; final  Enum Set <  Type > tmp =  Enum Set . none Of (  Type . class ) ; tmp . add All ( types ) ; this . types =  Collections . unmodifiable Set ( tmp ) ; }
public <  T >  List <  String > validate Bean (  T bean ,  String err If Bean Null ) {  List <  String > errors = new  Array List <  String > ( ) ; if ( bean == null ) { errors . add ( err If Bean Null ) ; return errors ; }  Set <  Constraint Violation <  T > > violations = validator . validate ( bean ) ; for (  Constraint Violation <  T > violation : violations ) { errors . add ( violation . get Message ( ) ) ; } return errors ; }
protected void smart Insert After Bracket (  IDocument document ,  Document Command command ) { if ( command . offset == - _ NUM || document . get Length ( ) == _ NUM ) { return ; } try { int p = ( command . offset == document . get Length ( ) ? command . offset - _ NUM : command . offset ) ; int line = document . get Line Of Offset ( p ) ; int start = document . get Line Offset ( line ) ; int whiteend = find End Of White Space ( document , start , command . offset ) ; if ( whiteend == command . offset ) { int ind Line = find Matching Open Bracket ( document , line , command . offset , _ NUM ) ; if ( ind Line != - _ NUM && ind Line != line ) {  String Buffer replace Text = new  String Buffer ( get Indent Of Line ( document , ind Line ) ) ; replace Text . append ( document . get ( whiteend , command . offset - whiteend ) ) ; replace Text . append ( command . text ) ; command . length = command . offset - start ; command . offset = start ; command . text = replace Text . to String ( ) ; } } } catch (  Bad Location Exception e ) {  GWTPlugin Log . log Error ( e ) ; } }
private  String attempt To Choose Formatting Pattern ( ) { if ( national Number . length ( ) >=  MIN_ LEADING_ DIGITS_ LENGTH ) { get Available Formats ( national Number . to String ( ) ) ;  String formatted Number = attempt To Format Accrued Digits ( ) ; if ( formatted Number . length ( ) > _ NUM ) { return formatted Number ; } return maybe Create New Template ( ) ? input Accrued National Number ( ) : accrued Input . to String ( ) ; } else { return append National Number ( national Number . to String ( ) ) ; } }
private void fill Picks ( ) throws  Exception {  MLookup org L =  MLookup Factory . get (  Env . get Ctx ( ) , m_ Window No , _ NUM , _ NUM ,  Display Type .  Table Dir ) ; f Warehouse = new  VLookup ( _ STR , _ BOOL , _ BOOL , _ BOOL , org L ) ; l Warehouse . set Text (  Msg . translate (  Env . get Ctx ( ) , _ STR ) ) ; f Warehouse . add Vetoable Change Listener ( this ) ; m_ M_ Warehouse_ ID = f Warehouse . get Value ( ) ;  MLookup bp L =  MLookup Factory . get (  Env . get Ctx ( ) , m_ Window No , _ NUM , _ NUM ,  Display Type .  Search ) ; f BPartner = new  VLookup ( _ STR , _ BOOL , _ BOOL , _ BOOL , bp L ) ; l BPartner . set Text (  Msg . translate (  Env . get Ctx ( ) , _ STR ) ) ; f BPartner . add Vetoable Change Listener ( this ) ; l Doc Type . set Text (  Msg . translate (  Env . get Ctx ( ) , _ STR ) ) ; cmb Doc Type . add Item ( new  Key Name Pair (  MOrder .  Table_ ID ,  Msg . translate (  Env . get Ctx ( ) , _ STR ) ) ) ; cmb Doc Type . add Item ( new  Key Name Pair (  MRMA .  Table_ ID ,  Msg . translate (  Env . get Ctx ( ) , _ STR ) ) ) ; cmb Doc Type . add Action Listener ( this ) ; }
@  Override protected  Field Config Base create Copy (  Field Config Base field Config Base ) {  Field Config Font Preview copy = null ; if ( field Config Base != null ) { copy = new  Field Config Font Preview ( field Config Base . get Common Data ( ) ) ; } return copy ; }
private void print Annotation From Editor ( final  Workflow Annotation anno , final  Graphics2 D g2 ) {  Graphics2 D g Pr = (  Graphics2 D ) g2 . create ( ) ;  Rectangle2 D loc = anno . get Location ( ) ; g Pr . translate ( loc . get X ( ) , loc . get Y ( ) ) ; g Pr . set Clip ( _ NUM , _ NUM , ( int ) loc . get Width ( ) , ( int ) loc . get Height ( ) ) ;  Dimension size = new  Dimension ( ( int ) loc . get Width ( ) , ( int ) loc . get Height ( ) ) ; pane . set Size ( size ) ; pane . set Text (  Annotation Draw Utils . create Styled Comment String ( anno ) ) ; pane . set Caret Position ( _ NUM ) ; pane . paint ( g Pr ) ; g Pr . dispose ( ) ; }
public void add (  IPoint pt ) { if ( in Progress ) { throw new  Concurrent Modification Exception ( _ STR ) ; } points . add ( pt ) ; }
public static  Configuration load (  Reader reader ) throws  IOException { try {  Properties properties = new  Properties ( ) ; properties . load ( reader ) ; return from ( properties ) ; } finally { reader . close ( ) ; } }
public void add (  Offsetted Item item ) { throw If Prepared ( ) ; try { if ( item . get Alignment ( ) > get Alignment ( ) ) { throw new  Illegal Argument Exception ( _ STR ) ; } } catch (  Null Pointer Exception ex ) { throw new  Null Pointer Exception ( _ STR ) ; } items . add ( item ) ; }
public static void add Annotation To XML (  Element annotations Element ,  String name ,  String value ) { if ( value == null ) { delete Annotation From XML ( annotations Element , name ) ; } else { final  Document doc = annotations Element . get Owner Document ( ) ;  Element elem = doc . create Element ( _ STR ) ; annotations Element . append Child ( elem ) ; elem . set Attribute ( _ STR , name ) ; elem . set Text Content ( value ) ; } }
public boolean read Boolean ( ) throws  IOException { return primitive Types . read Boolean ( ) ; }
public  Enumeration <  String > enumerate Measures ( ) {  Vector <  String > new Vector = new  Vector <  String > ( _ NUM ) ; new Vector . add Element ( _ STR ) ; return new Vector . elements ( ) ; }
@  Override public  Instances define Data Format ( ) throws  Exception {  Array List <  Attribute > atts ;  Array List <  String > att Values ; int i ; m_ Random = new  Random ( get Seed ( ) ) ; m_next Class Should Be Zero = _ BOOL ; m_last Label =  Double .  Na N ; set Num Examples Act ( get Num Examples ( ) ) ; atts = new  Array List <  Attribute > ( ) ; atts . add ( new  Attribute ( _ STR ) ) ; atts . add ( new  Attribute ( _ STR ) ) ; atts . add ( new  Attribute ( _ STR ) ) ; att Values = new  Array List <  String > ( ) ; for ( i = _ NUM ; i < _ NUM ; i ++ ) { att Values . add ( _ STR + i ) ; } atts . add ( new  Attribute ( _ STR , att Values ) ) ; att Values = new  Array List <  String > ( ) ; for ( i = _ NUM ; i <= _ NUM ; i ++ ) { att Values . add ( _ STR + i ) ; } atts . add ( new  Attribute ( _ STR , att Values ) ) ; att Values = new  Array List <  String > ( ) ; for ( i = _ NUM ; i < _ NUM ; i ++ ) { att Values . add ( _ STR + i ) ; } atts . add ( new  Attribute ( _ STR , att Values ) ) ; atts . add ( new  Attribute ( _ STR ) ) ; atts . add ( new  Attribute ( _ STR ) ) ; atts . add ( new  Attribute ( _ STR ) ) ; att Values = new  Array List <  String > ( ) ; for ( i = _ NUM ; i < _ NUM ; i ++ ) { att Values . add ( _ STR + i ) ; } atts . add ( new  Attribute ( _ STR , att Values ) ) ; m_ Dataset Format = new  Instances ( get Relation Name To Use ( ) , atts , _ NUM ) ; return m_ Dataset Format ; }
public static double ln Gamma ( double alpha ) { double x = alpha , f = _ NUM , z ; if ( x < _ NUM ) { f = _ NUM ; z = x - _ NUM ; while ( ++ z < _ NUM ) { f *= z ; } x = z ; f = -  Math . log ( f ) ; } z = _ NUM / ( x * x ) ; return f + ( x - _ NUM ) *  Math . log ( x ) - x + _ NUM + ( ( ( - _ NUM * z + _ NUM ) * z - _ NUM ) * z + _ NUM ) / x ; }
public void start Ticker ( long delay , boolean right To Left ) { if ( ! ticker Enabled ) { return ; } if ( ! is Cell Renderer ( ) ) {  Form parent = get Component Form ( ) ; if ( parent != null ) { parent . register Animated Internal ( this ) ; } } ticker Start Time =  System . current Time Millis ( ) ; ticker Delay = delay ; ticker Running = _ BOOL ; this . right To Left = right To Left ; if ( is RTL ( ) ) { this . right To Left = ! this . right To Left ; } }
static  Cipher Suite value Of ( int id1 , int id2 ) { id1 &= _ NUM ; id2 &= _ NUM ; int id = ( id1 << _ NUM ) | id2 ;  Cipher Suite c = id Map . get ( id ) ; if ( c == null ) {  String h1 =  Integer . to String ( id1 , _ NUM ) ;  String h2 =  Integer . to String ( id2 , _ NUM ) ; c = new  Cipher Suite ( _ STR + h1 + _ STR + h2 , id ) ; } return c ; }
public static  Context create Pending Action Context (  Context context ,  Recon Action action ,  String mapping Name ,  Json Value source Object ,  String recon Id ,  Situation situation ) {  Map <  String ,  Object > pending Action Map = new  Hash Map <  String ,  Object > ( ) ; pending Action Map . put (  MAPPING_ NAME , mapping Name ) ; pending Action Map . put (  SOURCE_ OBJECT , source Object ) ; pending Action Map . put (  RECON_ ID , recon Id ) ; pending Action Map . put (  ORIGINAL_ SITUATION , situation . to String ( ) ) ;  Pending Action Context pending Action Context = new  Pending Action Context ( context , pending Action Map , action . to String ( ) ) ; return pending Action Context ; }
public void show Droidsafe Text Markers (  IEditor Part opened Editor ,  String class Name ) { if ( opened Editor != null && opened Editor instanceof  IText Editor && f Processed Classes != null ) {  IText Editor editor = (  IText Editor ) opened Editor ; if ( f Processed Classes . contains ( class Name ) ) { if ( f Classes Need Update . contains ( class Name ) ) {  Class Marker Processor class Processor = get ( class Name ) ; class Processor . update Taint Markers ( editor ) ; f Classes Need Update . remove ( class Name ) ; } } else { f Processed Classes . add ( class Name ) ;  Map <  String ,  Map <  Int Range ,  Map <  String ,  Set <  Call Location Model > > > > class Tainted Data Map = f Tainted Data Map . get ( class Name ) ;  Map <  String ,  Set <  Int Range > > class Unreachable Method Map = f Unreachable Source Method Map . get ( class Name ) ; if ( class Tainted Data Map != null || class Unreachable Method Map != null ) {  IEditor Input input = editor . get Editor Input ( ) ; if ( input instanceof  File Editor Input ) {  Class Marker Processor class Processor = get ( class Name ) ; class Processor . show Droidsafe Text Markers ( editor ) ; } } } } }
private static void resolve New Expression (  New Expression obj Subject Expression ,  Hash Set <  String > obj Types Set ) {  Class Reference obj Class Ref = obj Subject Expression . get Class Reference ( ) ; if ( null == obj Class Ref || null == obj Class Ref . get FQN ( ) ) { obj Types Set . add (  Types . str Resolving Aborted On Psi Level ) ; return ; } obj Types Set . add ( obj Class Ref . get FQN ( ) ) ; }
private static  List <  Size > pick Up To Three (  List <  Size > sizes ) {  List <  Size > result = new  Array List <  Size > ( ) ;  Size largest = sizes . get ( _ NUM ) ; result . add ( largest ) ;  Size last Size = largest ; for (  Size size : sizes ) { double target Area =  Math . pow ( _ NUM , result . size ( ) ) * area ( largest ) ; if ( area ( size ) < target Area ) { if ( ! result . contains ( last Size ) && ( target Area - area ( last Size ) < area ( size ) - target Area ) ) { result . add ( last Size ) ; } else { result . add ( size ) ; } } last Size = size ; if ( result . size ( ) == _ NUM ) { break ; } } if ( result . size ( ) < _ NUM && ! result . contains ( last Size ) ) { result . add ( last Size ) ; } return result ; }
public static void copy To Clipboard (  Transferable t ) {  Clipboard Helper . copy To Clipboard ( t ) ; }
public static  String format Percent ( int download Size , int file Size ) { float num = ( float ) download Size / file Size ; float percent = ( ( float ) ( int ) ( num * _ NUM ) ) / _ NUM ; return  String . value Of ( percent + _ STR ) ; }
final private  String attr Def2 Attr Desc (  Attributes attrs ) throws  Naming Exception {  String Buffer attr Desc = new  String Buffer ( _ STR ) ;  Attribute attr = null ; int count = _ NUM ; attr = attrs . get (  NUMERICOID_ ID ) ; if ( attr != null ) { attr Desc . append ( write Numeric OID ( attr ) ) ; count ++ ; } else { throw new  Configuration Exception ( _ STR + _ STR ) ; } attr = attrs . get (  NAME_ ID ) ; if ( attr != null ) { attr Desc . append ( write QDescrs ( attr ) ) ; count ++ ; } attr = attrs . get (  DESC_ ID ) ; if ( attr != null ) { attr Desc . append ( write QDString ( attr ) ) ; count ++ ; } attr = attrs . get (  OBSOLETE_ ID ) ; if ( attr != null ) { attr Desc . append ( write Boolean ( attr ) ) ; count ++ ; } attr = attrs . get (  SUP_ ID ) ; if ( attr != null ) { attr Desc . append ( write WOID ( attr ) ) ; count ++ ; } attr = attrs . get (  EQUALITY_ ID ) ; if ( attr != null ) { attr Desc . append ( write WOID ( attr ) ) ; count ++ ; } attr = attrs . get (  ORDERING_ ID ) ; if ( attr != null ) { attr Desc . append ( write WOID ( attr ) ) ; count ++ ; } attr = attrs . get (  SUBSTR_ ID ) ; if ( attr != null ) { attr Desc . append ( write WOID ( attr ) ) ; count ++ ; } attr = attrs . get (  SYNTAX_ ID ) ; if ( attr != null ) { attr Desc . append ( write WOID ( attr ) ) ; count ++ ; } attr = attrs . get (  SINGLE_ VAL_ ID ) ; if ( attr != null ) { attr Desc . append ( write Boolean ( attr ) ) ; count ++ ; } attr = attrs . get (  COLLECTIVE_ ID ) ; if ( attr != null ) { attr Desc . append ( write Boolean ( attr ) ) ; count ++ ; } attr = attrs . get (  NO_ USER_ MOD_ ID ) ; if ( attr != null ) { attr Desc . append ( write Boolean ( attr ) ) ; count ++ ; } attr = attrs . get (  USAGE_ ID ) ; if ( attr != null ) { attr Desc . append ( write QDString ( attr ) ) ; count ++ ; } if ( count < attrs . size ( ) ) {  String attr Id = null ; for (  Naming Enumeration < ? extends  Attribute > ae = attrs . get All ( ) ; ae . has More Elements ( ) ; ) { attr = ae . next ( ) ; attr Id = attr . get ID ( ) ; if ( attr Id . equals (  NUMERICOID_ ID ) || attr Id . equals (  NAME_ ID ) || attr Id . equals (  SYNTAX_ ID ) || attr Id . equals (  DESC_ ID ) || attr Id . equals (  SINGLE_ VAL_ ID ) || attr Id . equals (  EQUALITY_ ID ) || attr Id . equals (  ORDERING_ ID ) || attr Id . equals (  SUBSTR_ ID ) || attr Id . equals (  NO_ USER_ MOD_ ID ) || attr Id . equals (  USAGE_ ID ) || attr Id . equals (  SUP_ ID ) || attr Id . equals (  COLLECTIVE_ ID ) || attr Id . equals (  OBSOLETE_ ID ) ) { continue ; } else { attr Desc . append ( write QDStrings ( attr ) ) ; } } } attr Desc . append ( _ STR ) ; return attr Desc . to String ( ) ; }
public static <  T >  Collection <  T > make Immutable (  Collection <  T > mutable Collection ) {  Collection <  T > new Collection ; try { @  Suppress Warnings ( _ STR )  Class <  Collection <  T > > cls = (  Class <  Collection <  T > > ) mutable Collection . get Class ( ) ; new Collection = cls . new Instance ( ) ; } catch (  Instantiation Exception |  Illegal Access Exception e ) { throw new  Illegal State Exception ( e ) ; } for (  T element : mutable Collection ) { new Collection . add (  Utils . make Immutable ( element ) ) ; } return  Collections . unmodifiable Collection ( new Collection ) ; }
public synchronized void track Hex Images (  IHex hex ,  Media Tracker tracker ) {  Image base = hex To Image Cache . get ( hex ) ;  List <  Image > super Imgs = hex To Image List Cache . get ( hex ) ;  List <  Image > ortho Imgs = ortho List Cache . get ( hex ) ; tracker . add Image ( base , _ NUM ) ; if ( super Imgs != null ) { for (  Iterator <  Image > i = super Imgs . iterator ( ) ; i . has Next ( ) ; ) { tracker . add Image ( i . next ( ) , _ NUM ) ; } } if ( ortho Imgs != null ) { for (  Iterator <  Image > i = ortho Imgs . iterator ( ) ; i . has Next ( ) ; ) { tracker . add Image ( i . next ( ) , _ NUM ) ; } } }
public static  Date parse Text (  String date Str ) { try { return m Simple Text Format . parse ( date Str ) ; } catch (  Parse Exception e ) { e . print Stack Trace ( ) ; throw new  Runtime Exception ( _ STR ) ; } }
public boolean is Processed (  Trace trace ,  Node node ,  Direction direction ) { boolean ret = _ BOOL ; if ( processor . get Node Type ( ) == node . get Type ( ) && processor . get Direction ( ) == direction ) { if ( uri Filter == null || uri Filter . test ( node . get Uri ( ) ) ) { ret = _ BOOL ; } } if ( log . is Loggable (  Level .  FINEST ) ) { log . finest ( _ STR + trace + _ STR + node + _ STR + direction + _ STR + ret ) ; } return ret ; }
@  Override public synchronized void power On Self Test ( ) throws  Error { for (  Iterator <  Waveform Synthesizer > it = waveform Synthesizers . iterator ( ) ; it . has Next ( ) ; ) {  Waveform Synthesizer ws = it . next ( ) ; ws . power On Self Test ( ) ; } }
private  Quad Edge [ ] fetch Triangle To Visit (  Quad Edge edge ,  Stack edge Stack , boolean include Frame ,  Set visited Edges ) {  Quad Edge curr = edge ; int edge Count = _ NUM ; boolean is Frame = _ BOOL ; do { tri Edges [ edge Count ] = curr ; if ( is Frame Edge ( curr ) ) is Frame = _ BOOL ;  Quad Edge sym = curr . sym ( ) ; if ( ! visited Edges . contains ( sym ) ) edge Stack . push ( sym ) ; visited Edges . add ( curr ) ; edge Count ++ ; curr = curr . l Next ( ) ; } while ( curr != edge ) ; if ( is Frame && ! include Frame ) return null ; return tri Edges ; }
public void delete Entity Config (  String realm ,  String federation Id ) throws  WSFederation Meta Exception { if ( federation Id == null ) { return ; } if ( realm == null ) { realm = _ STR ; }  String [ ] objs = { federation Id , realm } ; try {  Map old Attrs = config Inst . get Configuration ( realm , federation Id ) ;  Set old Values = (  Set ) old Attrs . get (  ATTR_ ENTITY_ CONFIG ) ; if ( old Values == null || old Values . is Empty ( ) ) {  Log Util . error (  Level .  INFO ,  Log Util .  NO_ ENTITY_ DESCRIPTOR_ DELETE_ ENTITY_ CONFIG , objs , null ) ; throw new  WSFederation Meta Exception ( _ STR , objs ) ; }  IDPSSOConfig Element idpconfig = get IDPSSOConfig ( realm , federation Id ) ; if ( idpconfig != null ) { remove From Circle Of Trust ( idpconfig , realm , federation Id ) ; }  SPSSOConfig Element spconfig = get SPSSOConfig ( realm , federation Id ) ; if ( spconfig != null ) { remove From Circle Of Trust ( spconfig , realm , federation Id ) ; }  Set attr = new  Hash Set ( ) ; attr . add (  ATTR_ ENTITY_ CONFIG ) ; config Inst . delete Configuration ( realm , federation Id , attr ) ;  Log Util . access (  Level .  INFO ,  Log Util .  ENTITY_ CONFIG_ DELETED , objs , null ) ;  WSFederation Meta Cache . put Entity Config ( realm , federation Id , null ) ; } catch (  Configuration Exception e ) { debug . error ( _ STR , e ) ;  String [ ] data = { e . get Message ( ) , federation Id , realm } ;  Log Util . error (  Level .  INFO ,  Log Util .  CONFIG_ ERROR_ DELETE_ ENTITY_ CONFIG , data , null ) ; throw new  WSFederation Meta Exception ( e ) ; } }
public static synchronized  Data Source Views Manager shared Instance ( ) { if ( shared Instance == null ) shared Instance = new  Data Source Views Manager ( ) ; return shared Instance ; }
public  String tag (  String inner ,  String c1 ,  String c2 ) { boolean color = ( ( attr &  ATTR_ COLOR ) ==  ATTR_ COLOR ) &&  Toast Bootstrap . color ;  String s = _ STR ; if ( color ) s += _ STR + c1 + _ STR ; s += inner ; if ( color ) s += _ STR + c2 + _ STR ; s += _ STR ; if ( color ) s += _ STR + c1 + _ STR ; return color ?  Pretty . format ( s ) : s ; }
private final  String load Xml Definition ( ) { final  Cache cache =  Cache Factory . get Any Instance ( ) ; final  String Writer string Writer = new  String Writer ( ) ; final  Print Writer print Writer = new  Print Writer ( string Writer ) ;  Cache Xml Generator . generate ( cache , print Writer , _ BOOL , _ BOOL , _ BOOL ) ; print Writer . close ( ) ; return load Xml Definition ( string Writer . to String ( ) ) ; }
private  Long id (  Http Servlet Request request ) {  Long id = null ;  String path Info = request . get Path Info ( ) ; if ( path Info != null && path Info . length ( ) > _ NUM ) {  String id String = path Info . substring ( _ NUM ) ; id =  Long . value Of ( id String ) ; } return id ; }
public void uncompress ( ) { data . position ( _ NUM ) ;  Inflater Input Stream inflater = new  Inflater Input Stream ( data . as Input Stream ( ) ) ; byte [ ] buffer = new byte [ _ NUM ] ;  Io Buffer tmp =  Io Buffer . allocate ( _ NUM ) ; tmp . set Auto Expand ( _ BOOL ) ; try { while ( inflater . available ( ) > _ NUM ) { int decompressed = inflater . read ( buffer ) ; if ( decompressed <= _ NUM ) { break ; } tmp . put ( buffer , _ NUM , decompressed ) ; } } catch (  IOException e ) { tmp . free ( ) ; throw new  Runtime Exception ( _ STR , e ) ; } finally { if ( inflater != null ) { try { inflater . close ( ) ; } catch (  IOException e1 ) { } } } data . free ( ) ; data = tmp ; data . flip ( ) ; prepare IO ( ) ; }
public void poll ( final  Tcp Socket Statistics Handler handler ) { this . statistics Handler = handler ; try { file Loader . load ( ) ; final  Byte Buffer buffer = file Loader . get Buffer ( ) ; line Parser . reset ( ) ; line Parser . handle Token ( buffer , buffer . position ( ) , buffer . limit ( ) ) ; } finally { this . statistics Handler = null ; } monitored Sockets . purge Entries Older Than ( update Count ) ; update Count ++ ; }
public int compare To (  Char Buffer other Buffer ) { int compare Remaining = ( remaining ( ) < other Buffer . remaining ( ) ) ? remaining ( ) : other Buffer . remaining ( ) ; int this Pos = position ; int other Pos = other Buffer . position ; char this Byte , other Byte ; while ( compare Remaining > _ NUM ) { this Byte = get ( this Pos ) ; other Byte = other Buffer . get ( other Pos ) ; if ( this Byte != other Byte ) { return this Byte < other Byte ? - _ NUM : _ NUM ; } this Pos ++ ; other Pos ++ ; compare Remaining -- ; } return remaining ( ) - other Buffer . remaining ( ) ; }
public  Urban Sim Zone CSVWriter V2 (  String matsim4opus Temp Directory ,  String matsim Output Directory ) { this . matsim4opus Temp Directory = matsim4opus Temp Directory ; this . matsim Output Directory = matsim Output Directory ; try { log . info ( _ STR ) ; zone Writer =  IOUtils . get Buffered Writer ( matsim4opus Temp Directory +  FILE_ NAME ) ; log . info ( _ STR + matsim4opus Temp Directory +  FILE_ NAME + _ STR ) ; zone Writer . write (  Labels .  ZONE_ ID + _ STR +  Labels .  ACCESSIBILITY_ BY_ FREESPEED + _ STR +  Labels .  ACCESSIBILITY_ BY_ CAR + _ STR +  Labels .  ACCESSIBILITY_ BY_ BIKE + _ STR +  Labels .  ACCESSIBILITY_ BY_ WALK + _ STR +  Labels .  ACCESSIBILITY_ BY_ PT ) ; zone Writer . new Line ( ) ; log . info ( _ STR ) ; } catch (  Exception e ) { e . print Stack Trace ( ) ; } }
@  Override public void agg (  Object new Val ) { if ( new Val instanceof byte [ ] ) {  Byte Buffer buffer =  Byte Buffer . wrap ( ( byte [ ] ) new Val ) ; buffer . rewind ( ) ; while ( buffer . has Remaining ( ) ) { agg Val += buffer . get Long ( ) ; count += buffer . get Double ( ) ; first Time = _ BOOL ; } return ; } agg Val += (  Long ) new Val ; count ++ ; first Time = _ BOOL ; }
private static  Policy Notification extract Policy Notification (  String xml ) throws  Policy Evaluation Exception {  Policy Notification policy Notification = null ; try {  String notification Data Block = get Notification Data Block ( xml ) ; if ( notification Data Block != null ) {  Document doc =  XMLUtils . get XMLDocument ( new  Byte Array Input Stream ( notification Data Block . get Bytes ( ) ) ) ;  Node root Node =  XMLUtils . get Root Node ( doc ,  NODE_ POLICY_ SERVICE ) ; if ( root Node != null ) {  Node notification Node =  XMLUtils . get Child Node ( root Node ,  NODE_ POLICY_ NOTIFICATION ) ; if ( notification Node != null ) { policy Notification =  Policy Notification . parse XML ( notification Node ) ; } else { debug . error ( _ STR + _ STR + _ STR ) ; throw new  Policy Evaluation Exception (  Res Bundle Utils . rb Name , _ STR , null , null ) ; } } else { debug . error ( _ STR + _ STR ) ; } } else { debug . error ( _ STR + _ STR + _ STR ) ; } } catch (  Exception xe ) { debug . error ( _ STR , xe ) ; throw new  Policy Evaluation Exception (  Res Bundle Utils . rb Name , _ STR , null , xe ) ; } return policy Notification ; }
private  Object find Parcel ( @  Non Null byte [ ] object Array , @  Non Null  String class Name ) { try {  Class class Tmp = get Class For Name ( class Name ) ;  Constructor declared Constructor = class Tmp . get Declared Constructor (  Parcel . class ) ; declared Constructor . set Accessible ( _ BOOL ) ; return declared Constructor . new Instance (  Wear Bus Tools . byte To Parcel ( object Array ) ) ; } catch (  Exception e ) {  Log . d (  Wear Bus Tools .  BUSWEAR_ TAG , _ STR + e . get Message ( ) ) ; } return null ; }
private static final  String decode Field Name ( final  String p Xml Field Name ) {  String Builder str = new  String Builder ( ) ; int field Name Length = p Xml Field Name . length ( ) ; char current Char ; for ( int i = _ NUM ; i < field Name Length ; i ++ ) { current Char = p Xml Field Name . char At ( i ) ; if ( current Char == _ STR ) { str . append (  Character . to Upper Case ( p Xml Field Name . char At ( ++ i ) ) ) ; } else { str . append ( current Char ) ; } } return str . to String ( ) ; }
public boolean is Login Set ( ) { return ( username != null && ( password != null && ! username . equals ( _ STR ) && ! password . equals ( _ STR ) ) ) || oauth ; }
public void add Content Item (  Content Item content Item ) { if ( content Items == null ) { content Items = new  Array List <  Content Item > ( ) ; } content Items . add ( content Item ) ; }
public static  String canonicalize Class Name (  String name ) {  String classname = name . replace ( _ STR , _ STR ) ; classname = classname . replace ( _ STR , _ STR ) ; if ( classname . starts With ( _ STR ) ) classname = classname . substring ( _ NUM ) ; if ( classname . ends With ( _ STR ) ) classname = classname . substring ( _ NUM , classname . length ( ) - _ NUM ) ; return classname ; }
public static final void pause ( final int milliseconds ) { if ( milliseconds >= _ NUM || logger . is Debug Enabled ( ) ) { logger . info ( _ STR , milliseconds ) ; } final long target =  System . current Time Millis ( ) + milliseconds ; try { for ( ; ; ) { long ms Left = target -  System . current Time Millis ( ) ; if ( ms Left <= _ NUM ) { break ; }  Thread . sleep ( ms Left ) ; } } catch (  Interrupted Exception e ) {  Assert . fail ( _ STR , e ) ; } }
public boolean is Highlight With Invisible Edge ( ) { return highlight With Invisible Edge ; }
private  Configuration prepare Job For Cancelling ( ) throws  Exception { prepare File ( _ STR , _ NUM ) ; executed Tasks . set ( _ NUM ) ; cancelled Tasks . set ( _ NUM ) ; fail Mapper Id . set ( _ NUM ) ; splits Count . set ( _ NUM ) ;  Configuration cfg = new  Configuration ( ) ; setup File Systems ( cfg ) ;  Job job =  Job . get Instance ( cfg ) ; job . set Output Key Class (  Text . class ) ; job . set Output Value Class (  Int Writable . class ) ; job . set Mapper Class (  Cancelling Test Mapper . class ) ; job . set Num Reduce Tasks ( _ NUM ) ; job . set Input Format Class (  In Format . class ) ;  File Input Format . set Input Paths ( job , new  Path ( _ STR + get Test Grid Name ( _ NUM ) + _ STR ) ) ;  File Output Format . set Output Path ( job , new  Path ( _ STR + get Test Grid Name ( _ NUM ) + _ STR ) ) ; job . set Jar By Class ( get Class ( ) ) ; return job . get Configuration ( ) ; }
public static double [ ] lsf2lpc ( double [ ] lsf ) {  Math Utils . quick Sort ( lsf ) ; int  P = lsf . length ; int half_order =  P / _ NUM ; int i , j ; double xf , xx ; double [ ] a = new double [  P / _ NUM + _ NUM ] ; double [ ] a1 = new double [  P / _ NUM + _ NUM ] ; double [ ] a2 = new double [  P / _ NUM + _ NUM ] ; double [ ] b = new double [  P / _ NUM + _ NUM ] ; double [ ] b1 = new double [  P / _ NUM + _ NUM ] ; double [ ] b2 = new double [  P / _ NUM + _ NUM ] ; double [ ] p = new double [  P / _ NUM ] ; double [ ] q = new double [  P / _ NUM ] ; double [ ] one Minus A = new double [  P + _ NUM ] ; one Minus A [ _ NUM ] = _ NUM ; if ( ( lsf [ _ NUM ] <= _ NUM ) || ( lsf [ _ NUM ] >= _ NUM ) ) { throw new  Illegal Argument Exception ( _ STR + lsf [ _ NUM ] ) ; } for ( i = _ NUM ; i <  P ; i ++ ) { if ( lsf [ i ] <= lsf [ i - _ NUM ] ) throw new  Illegal Argument Exception ( _ STR ) ; if ( ( lsf [ i ] <= _ NUM ) || ( lsf [ i ] >= _ NUM ) ) throw new  Illegal Argument Exception ( _ STR + i + _ STR + lsf [ i ] ) ; } for ( i = _ NUM ; i < half_order ; i ++ ) { p [ i ] = - _ NUM *  Math . cos (  Math Utils .  TWOPI * lsf [ _ NUM * i ] ) ; q [ i ] = - _ NUM *  Math . cos (  Math Utils .  TWOPI * lsf [ _ NUM * i + _ NUM ] ) ; } xf = _ NUM ; for ( i = _ NUM ; i <=  P ; i ++ ) { if ( i == _ NUM ) xx = _ NUM ; else xx = _ NUM ; a [ _ NUM ] = xx + xf ; b [ _ NUM ] = xx - xf ; xf = xx ; for ( j = _ NUM ; j < half_order ; j ++ ) { a [ j + _ NUM ] = a [ j ] + p [ j ] * a1 [ j ] + a2 [ j ] ; b [ j + _ NUM ] = b [ j ] + q [ j ] * b1 [ j ] + b2 [ j ] ; a2 [ j ] = a1 [ j ] ; a1 [ j ] = a [ j ] ; b2 [ j ] = b1 [ j ] ; b1 [ j ] = b [ j ] ; } if ( i > _ NUM ) one Minus A [ i ] = _ NUM * ( a [ half_order ] + b [ half_order ] ) ; } return one Minus A ; }
protected void generate Fields ( ) { for (  Iterator <  Element > iterator = m Elements . iterator ( ) ; iterator . has Next ( ) ; ) {  Element element = iterator . next ( ) ; if ( ! element . used ) { iterator . remove ( ) ; continue ; }  Psi Field [ ] fields = m Class . get Fields ( ) ; boolean duplicate Field = _ BOOL ; for (  Psi Field field : fields ) {  String name = field . get Name ( ) ; if ( name != null && name . equals ( element . get Field Name ( ) ) ) { duplicate Field = _ BOOL ; break ; } } if ( duplicate Field ) { iterator . remove ( ) ; continue ; } m Class . add ( m Factory . create Field From Text ( _ STR + element . name + _ STR + element . get Field Name ( ) + _ STR , m Class ) ) ; } }
public boolean is Flying ( ) { return ( fly Through Dialog != null ) ; }
public synchronized void init ( ) { channel Factory = new  Nio Client Socket Channel Factory (  Executors . new Cached Thread Pool ( ) ,  Executors . new Cached Thread Pool ( ) ) ; datagram Channel Factory = new  Nio Datagram Channel Factory (  Executors . new Cached Thread Pool ( ) ) ; timer = new  Hashed Wheel Timer ( ) ; }
private void consume Nested Scroll ( int dx Unconsumed , int dy Unconsumed , int dx Final Unconsumed , int dy Final Unconsumed ) { if ( m Over Scroll Effect ==  Over Scroll Effect .  BOUNCE && dy Final Unconsumed != _ NUM ) { m Unconsumed Over Scroll Offset += - dy Final Unconsumed ; int max Offset = m Over Scroll Offset Limit ; if ( m Unconsumed Over Scroll Offset > _ NUM ) { m Unconsumed Over Scroll Offset =  Math . min ( max Offset , m Unconsumed Over Scroll Offset ) ; } else if ( m Unconsumed Over Scroll Offset < _ NUM ) { m Unconsumed Over Scroll Offset =  Math . max ( - max Offset , m Unconsumed Over Scroll Offset ) ; } set Scrolling Offset ( get Unconsumed Scrolling Offset ( ) ) ; } pull Edge Effects ( dx Unconsumed , dy Unconsumed ) ; }
private void retrieve Waypoints (  Search Query query ,  Array List <  Waypoint > waypoints ) {  String query Like Selection2 = _ STR + query . text Query + _ STR ;  String [ ] waypoint Selection Args = new  String [ ] { query Like Selection2 , query Like Selection2 , query Like Selection2 } ;  Cursor cursor = null ; try { cursor = provider Utils . get Waypoint Cursor (  WAYPOINT_ SELECTION_ QUERY , waypoint Selection Args ,  WAYPOINT_ SELECTION_ ORDER ,  MAX_ SCORED_ WAYPOINTS ) ; if ( cursor != null ) { waypoints . ensure Capacity ( cursor . get Count ( ) ) ; while ( cursor . move To Next ( ) ) {  Waypoint waypoint = provider Utils . create Waypoint ( cursor ) ; if (  Location Utils . is Valid Location ( waypoint . get Location ( ) ) ) { waypoints . add ( waypoint ) ; } } } } finally { if ( cursor != null ) { cursor . close ( ) ; } } }
void release ( ) { image Loader . cancel Pending Requests ( ) ; loading = new boolean [ nox Items . size ( ) ] ; }
public void add (  String name , long cnt ) { if ( _values == null ) { _values = new  Array List < > ( _ NUM ) ; } _values . add ( new  Count ( this , name , cnt ) ) ; }
void close Dialog ( ) ;
public void add Param (  Ast Node param ) { assert Not Null ( param ) ; if ( params == null ) { params = new  Array List <  Ast Node > ( ) ; } params . add ( param ) ; param . set Parent ( this ) ; }
Delete Event ( @  Non Null  JSONObject json ) throws  JSONException { super (  TYPE_ DELETE , json ) ; if (  Text Utils . is Empty ( m Block Id ) ) { throw new  JSONException (  TYPENAME_ DELETE + _ STR +  JSON_ BLOCK_ ID ) ; } m Old Xml = json . opt String (  JSON_ OLD_ VALUE ) ;  JSONArray ids = json . get JSONArray (  JSON_ IDS ) ; int count = ids . length ( ) ;  List <  String > temp = new  Array List < > ( count ) ; for ( int i = _ NUM ; i < count ; ++ i ) { temp . add ( ids . get String ( i ) ) ; } m Ids =  Collections . unmodifiable List ( temp ) ; }
public static boolean is Full Copy Restorable (  Volume volume ,  Db Client db Client ) { boolean result = _ BOOL ;  String replica State = volume . get Replica State ( ) ; if ( is Volume Full Copy ( volume , db Client ) && replica State != null && ! replica State . is Empty ( ) ) {  Replication State state =  Replication State . get Enum Value ( replica State ) ; if ( state != null && state ==  Replication State .  SYNCHRONIZED ) { result = _ BOOL ; } } return result ; }
private final static  String [ ] read QDStrings (  String string , int [ ] pos ) throws  Naming Exception { return read QDescrs ( string , pos ) ; }
private static boolean is Buffer Too Large (  Byte Buffer buf ) { return is Buffer Too Large ( buf . capacity ( ) ) ; }
public static void reset Index Buffer Time ( ) {  SAFE_ QUERY_ TIME . set ( _ NUM ) ; }
protected abstract  Admin Response create Response (  Distribution Manager dm ) ;
protected boolean check External Storage And Notify (  String file Name ) { if ( file Name != null && file Name . starts With ( _ STR ) ) { alert Download Failure (  R . string . download_no_sdcard_dlg_title ) ; return _ BOOL ; }  String status =  Environment . get External Storage State ( ) ; if ( ! status . equals (  Environment .  MEDIA_ MOUNTED ) ) { int title ; if ( status . equals (  Environment .  MEDIA_ SHARED ) ) { title =  R . string . download_sdcard_busy_dlg_title ; } else { title =  R . string . download_no_sdcard_dlg_title ; } alert Download Failure ( title ) ; return _ BOOL ; } return _ BOOL ; }
public static  String plnoun ( final int quantity , final  String noun ) { final  String enoun = full Form ( noun ) ; if ( quantity == _ NUM ) { return singular ( enoun ) ; } else { return plural ( noun ) ; } }
public boolean verify XMLSignature ( org . w3c . dom .  Element element , java . lang .  String cert Alias ) throws  XMLSignature Exception { return verify XMLSignature ( element ,  DEF_ ID_ ATTRIBUTE , cert Alias ) ; }
public void read Transport Systems ( final int [ ] columns Indices , final  Buffered Reader reader ) throws  IOException {  String line = reader . read Line ( ) ; while ( line != null && line . length ( ) > _ NUM ) { line = reader . read Line ( ) ; } }
public  Component Config Builder add Item In Multifield (  String multifield Label , int index ,  String item Type ,  String item Label ,  String value ) {  String type =  String . format ( _ STR , index , item Type ) ;  String label =  String . format ( _ STR , multifield Label , item Label ) ; config . add ( new  Configuration Entry ( current Tab , type , label , value ) ) ; return this ; }
private void parse Parameters (  String parameters ) {  Log . v ( _ STR , _ STR + _ STR + parameters ) ; if ( parameters != null ) { int i ; do { i = parameters . index Of ( _ STR ) ; if ( i < _ NUM ) { parse Parameter ( parameters ) ; } else { parse Parameter ( parameters . substring ( _ NUM , i ) ) ; parameters = parameters . substring ( i + _ NUM ) ; } } while ( i >= _ NUM ) ; } }
public void add Http Session Token (  String site ,  String token ) { if ( ! site . contains ( _ STR ) ) { site = site + ( _ STR ) ; }  Http Session Tokens Set site Tokens = session Tokens . get ( site ) ; if ( site Tokens == null ) { site Tokens = new  Http Session Tokens Set ( ) ; session Tokens . put ( site , site Tokens ) ; } log . info ( _ STR + site + _ STR + token ) ; site Tokens . add Token ( token ) ; unmark Removed Default Session Token ( site , token ) ; }
public  Gradle Distribution deserialize From String (  String distribution String ) {  Preconditions . check Not Null ( distribution String ) ;  String local Installation Prefix = _ STR ; if ( distribution String . starts With ( local Installation Prefix ) && distribution String . ends With ( _ STR ) ) {  String local Installation Dir = distribution String . substring ( local Installation Prefix . length ( ) , distribution String . length ( ) - _ NUM ) ; return  Gradle Distribution . for Local Installation ( new  File ( local Installation Dir ) ) ; }  String remote Distribution Prefix = _ STR ; if ( distribution String . starts With ( remote Distribution Prefix ) && distribution String . ends With ( _ STR ) ) {  String remote Distribution Uri = distribution String . substring ( remote Distribution Prefix . length ( ) , distribution String . length ( ) - _ NUM ) ; return  Gradle Distribution . for Remote Distribution ( create URI ( remote Distribution Uri ) ) ; }  String version Prefix = _ STR ; if ( distribution String . starts With ( version Prefix ) && distribution String . ends With ( _ STR ) ) {  String version = distribution String . substring ( version Prefix . length ( ) , distribution String . length ( ) - _ NUM ) ; return  Gradle Distribution . for Version ( version ) ; }  String wrapper String = _ STR ; if ( distribution String . equals ( wrapper String ) ) { return  Gradle Distribution . from Build ( ) ; }  String message =  String . format ( _ STR , distribution String ) ; throw new  Runtime Exception ( message ) ; }
public double meters To Pixels ( ) { double screen Center Lat = screen Top Left . latitude - screen Size . latitude / _ NUM ; double meters To Lon = _ NUM / (  Util .  LON_ TO_ METERS_ AT_ EQUATOR *  Math . cos ( screen Center Lat / _ NUM *  Math .  PI ) ) ; return screen Size . longitude / window Width * meters To Lon ; }
public boolean send Via Data Socket ( byte [ ] bytes , int start , int len ) { if ( data Output Stream == null ) {  Log . i (  TAG , _ STR ) ; return _ BOOL ; } if ( len == _ NUM ) { return _ BOOL ; } try { data Output Stream . write ( bytes , start , len ) ; } catch (  IOException e ) {  Log . i (  TAG , _ STR ) ;  Log . i (  TAG , e . to String ( ) ) ; return _ BOOL ; } local Data Socket . report Traffic ( len ) ; return _ BOOL ; }
private void push Context (  Base Context c ) { context Stack . push ( c ) ; }
@  Override public void bookmarks Or History Picker (  Combo Views start View ) { if ( m Tab Control . get Current Web View ( ) == null ) { return ; } if ( is In Custom Action Mode ( ) ) { end Action Mode ( ) ; }  Bundle extras = new  Bundle ( ) ; extras . put Boolean (  Browser Bookmarks Page .  EXTRA_ DISABLE_ WINDOW , ! m Tab Control . can Create New Tab ( ) ) ; m Ui . show Combo View ( start View , extras ) ; }
public  FST (  String file Name ,  String encoding , boolean verbose ) throws  IOException {  File Input Stream fis = new  File Input Stream ( file Name ) ; try { load Headerless ( fis , encoding , verbose ) ; } finally { fis . close ( ) ; } }
public static double [ ] normalize Zscore ( double [ ] x ) { double mn = mean ( x , _ NUM ) ; double sd = standard Deviation ( x , _ NUM ) ; for ( int i = _ NUM ; i < x . length ; i ++ ) if ( !  Double . is Na N ( x [ i ] ) ) x [ i ] = ( x [ i ] - mn ) / sd ; return x ; }
void add Location (  String location ) { if ( f Location List . contains ( location ) ) { return ; } f Location List . add ( location ) ; f Table Viewer . refresh ( ) ; f Table Viewer . set Checked ( location , _ BOOL ) ; f Table Viewer . set Selection ( new  Structured Selection ( location ) ) ; validate Locations ( ) ; }
public  Java Formatter (  String line Delimiter , int initial Indent Level , boolean use Code Formatter ,  IJava Project project ) { f Line Delimiter = line Delimiter ; f Use Code Formatter = use Code Formatter ; f Initial Indent Level = initial Indent Level ; f Project = project ; }
private static void check Path Need ( ) { if ( sampling Interval == - _ NUM ) { last Preload Time = read More Paths ( ) ; } if ( !  Double . is Na N ( last Preload Time ) &&  Sim Clock . get Time ( ) >= last Preload Time - ( sampling Interval *  MIN_ AHEAD_ INTERVALS ) ) { for ( int i = _ NUM ; i < nrof Preload && !  Double . is Na N ( last Preload Time ) ; i ++ ) { last Preload Time = read More Paths ( ) ; } } }
public double wide (  Prior prior ,  Likelihood likelihood ) throws  Operator Failed Exception { final int node Count = tree . get Node Count ( ) ; final  Node Ref root = tree . get Root ( ) ;  Node Ref i ; int index I ; do { index I =  Math Utils . next Int ( node Count ) ; i = tree . get Node ( index I ) ; } while ( root == i || ( tree . get Parent ( i ) == root && tree . get Node Height ( i ) > tree . get Node Height ( get Other Child ( tree , tree . get Parent ( i ) , i ) ) ) ) ;  List <  Integer > second Node Indices = new  Array List <  Integer > ( ) ;  List <  Double > probabilities = new  Array List <  Double > ( ) ;  Node Ref j , j P ;  Node Ref i P = tree . get Parent ( i ) ; double height IP = tree . get Node Height ( i P ) ; double height I = tree . get Node Height ( i ) ; double sum = _ NUM ; double backward = calculate Tree Likelihood ( prior , likelihood , tree ) ; int offset = ( int ) - backward ; backward =  Math . exp ( backward + offset ) ; for ( int n = _ NUM ; n < node Count ; n ++ ) { j = tree . get Node ( n ) ; if ( j != root ) { j P = tree . get Parent ( j ) ; if ( ( i P != j P ) && ( tree . get Node Height ( j ) < height IP ) && ( height I < tree . get Node Height ( j P ) ) ) { second Node Indices . add ( n ) ; swap ( tree , i , j , i P , j P ) ; double prob =  Math . exp ( calculate Tree Likelihood ( prior , likelihood , tree ) + offset ) ; probabilities . add ( prob ) ; swap ( tree , i , j , j P , i P ) ; sum += prob ; } } } if ( sum <= _ NUM ) { throw new  Operator Failed Exception ( _ STR ) ; } double ran =  Math . random ( ) * sum ; int index = _ NUM ; while ( ran > _ NUM ) { ran -= probabilities . get ( index ) ; index ++ ; } index -- ; j = tree . get Node ( second Node Indices . get ( index ) ) ; j P = tree . get Parent ( j ) ; double height JP = tree . get Node Height ( j P ) ; double height J = tree . get Node Height ( j ) ; double sum Forward2 = _ NUM ;  Node Ref k , k P ; for ( int n = _ NUM ; n < node Count ; n ++ ) { k = tree . get Node ( n ) ; if ( k != root ) { k P = tree . get Parent ( k ) ; if ( ( j P != k P ) && ( tree . get Node Height ( k ) < height JP ) && ( height J < tree . get Node Height ( k P ) ) ) { swap ( tree , j , k , j P , k P ) ; double prob =  Math . exp ( calculate Tree Likelihood ( prior , likelihood , tree ) + offset ) ; sum Forward2 += prob ; swap ( tree , j , k , k P , j P ) ; } } } swap ( tree , i , j , i P , j P ) ; double forward = probabilities . get ( index ) ; i P = j P ; height IP = height JP ; double sum Backward = _ NUM ; for ( int n = _ NUM ; n < node Count ; n ++ ) { j = tree . get Node ( n ) ; if ( j != root ) { j P = tree . get Parent ( j ) ; if ( ( i P != j P ) && ( tree . get Node Height ( j ) < height IP ) && ( height I < tree . get Node Height ( j P ) ) ) { swap ( tree , i , j , i P , j P ) ; double prob =  Math . exp ( calculate Tree Likelihood ( prior , likelihood , tree ) + offset ) ; sum Backward += prob ; swap ( tree , i , j , j P , i P ) ; } } } double sum Backward2 = _ NUM ; j = tree . get Node ( second Node Indices . get ( index ) ) ; j P = tree . get Parent ( j ) ; height JP = tree . get Node Height ( j P ) ; height J = tree . get Node Height ( j ) ; for ( int n = _ NUM ; n < node Count ; n ++ ) { k = tree . get Node ( n ) ; if ( k != root ) { k P = tree . get Parent ( k ) ; if ( ( j P != k P ) && ( tree . get Node Height ( k ) < height JP ) && ( height J < tree . get Node Height ( k P ) ) ) { swap ( tree , j , k , j P , k P ) ; double prob =  Math . exp ( calculate Tree Likelihood ( prior , likelihood , tree ) + offset ) ; sum Backward2 += prob ; swap ( tree , j , k , k P , j P ) ; } } } double forward Prob = ( forward / sum ) + ( forward / sum Forward2 ) ; double backward Prob = ( backward / sum Backward ) + ( backward / sum Backward2 ) ; double hastings Ratio =  Math . log ( backward Prob / forward Prob ) ; return hastings Ratio ; }
public boolean is Input Column Name Allowed (  String column Name ) { if ( column Name == null || column Name . length ( ) == _ NUM ) return _ BOOL ; get Input Column Names ( _ BOOL ) ; for ( int i = _ NUM ; i < m_inputcolumnnames . length ; i ++ ) { if ( column Name . equals ( m_inputcolumnnames [ i ] ) ) return _ BOOL ; } return _ BOOL ; }
public void test Empty Or Null Blob ( ) throws  Exception { try {  Prepared Statement stmt = connection . prepare Statement ( _ STR ) ; try { stmt . set Int ( _ NUM , _ NUM ) ; stmt . set Bytes ( _ NUM , new byte [ _ NUM ] ) ; int inserted Count = stmt . execute Update ( ) ; assert True ( _ STR , inserted Count == _ NUM ) ; stmt . set Int ( _ NUM , _ NUM ) ; stmt . set Null ( _ NUM ,  Types .  BINARY ) ; inserted Count = stmt . execute Update ( ) ; assert True ( _ STR , inserted Count == _ NUM ) ; } finally { stmt . close ( ) ; } stmt = connection . prepare Statement ( _ STR ) ; stmt . set Int ( _ NUM , _ NUM ) ; try {  Result Set rs = stmt . execute Query ( ) ; assert True ( _ STR , rs . next ( ) ) ; assert True ( _ STR ,  Arrays . equals ( rs . get Bytes ( _ NUM ) , new byte [ _ NUM ] ) ) ; rs . close ( ) ; stmt . set Int ( _ NUM , _ NUM ) ; rs = stmt . execute Query ( ) ; assert True ( _ STR , rs . next ( ) ) ; assert True ( _ STR , rs . get Object ( _ NUM ) == null ) ; rs . close ( ) ; } finally { stmt . close ( ) ; } } catch (  Exception ex ) { ex . print Stack Trace ( ) ; throw ex ; } }
private synchronized void rebuild Journal ( ) throws  IOException { if ( journal Writer != null ) { journal Writer . close ( ) ; }  Writer writer = new  Buffered Writer ( new  Output Stream Writer ( new  File Output Stream ( journal File Tmp ) ,  Utils .  US_ ASCII ) ) ; try { writer . write (  MAGIC ) ; writer . write ( _ STR ) ; writer . write (  VERSION_1 ) ; writer . write ( _ STR ) ; writer . write (  Integer . to String ( app Version ) ) ; writer . write ( _ STR ) ; writer . write (  Integer . to String ( value Count ) ) ; writer . write ( _ STR ) ; writer . write ( _ STR ) ; for (  Entry entry : lru Entries . values ( ) ) { if ( entry . current Editor != null ) { writer . write (  DIRTY + _ STR + entry . key + _ STR ) ; } else { writer . write (  CLEAN + _ STR + entry . key + entry . get Lengths ( ) + _ STR ) ; } } } finally { writer . close ( ) ; } if ( journal File . exists ( ) ) { rename To ( journal File , journal File Backup , _ BOOL ) ; } rename To ( journal File Tmp , journal File , _ BOOL ) ; journal File Backup . delete ( ) ; journal Writer = new  Buffered Writer ( new  Output Stream Writer ( new  File Output Stream ( journal File , _ BOOL ) ,  Utils .  US_ ASCII ) ) ; }
@  Suppress Warnings ( _ STR ) public void restore (  String file Name ) throws  IOException ,  Class Not Found Exception {  Object Input Stream ois = new  Object Input Stream ( new  File Input Stream ( file Name ) ) ; locations = (  Map <  V ,  Point > ) ois . read Object ( ) ; ois . close ( ) ; initialize Locations ( ) ; locked = _ BOOL ; fire State Changed ( ) ; }
public void wait For Data ( ) { if ( this . initialized ) { return ; } wait On Initialization ( this . initialization Latch After Get Initial Image ) ; }
private void blackman Harris4s Min ( int size ) { int start = ( window Function . length - size ) / _ NUM ; int stop = ( window Function . length + size ) / _ NUM ; double scale = _ NUM / ( double ) size / _ NUM ; for ( int i = _ NUM ; start < stop ; start ++ , i ++ ) window Function [ i ] = scale * ( _ NUM - _ NUM *  Math . cos ( two PI * i / size ) + _ NUM *  Math . cos ( _ NUM * two PI * i / size ) - _ NUM *  Math . cos ( _ NUM * two PI * i / size ) ) ; }
public int hash Code ( ) { return _lower Nick . hash Code ( ) ; }
public boolean increment Received ( ) {  Long diff =  System . current Time Millis ( ) - start Time ; if ( diff >= _ NUM ) { packets Per Second = interval Packets ; start Time =  System . current Time Millis ( ) ; interval Packets = _ NUM ; return _ BOOL ; } else { interval Packets ++ ; } this . received Packets ++ ; return _ BOOL ; }
Sentence parse Sentence ( final  String text , final  Conversation Context ctx ) { if ( is Empty ( ) ) { return  Conversation Parser . parse ( text , ctx ) ; }  String txt = text . trim ( ) ; final  Sentence sentence = new  Sentence Implementation ( ctx , txt ) ; txt =  Conversation Parser . detect Sentence Type ( txt , sentence ) ; if ( type Matching ) { read Type Match Expressions ( txt , ctx , sentence ) ; } else if ( exact Matching ) { read Simple Expressions ( txt , ctx , sentence ) ; } else if ( similar Matching ) { read Simple Expressions ( txt , ctx , sentence ) ; } else if ( joker Matching ) { read Joker Expressions ( txt , ctx , sentence ) ; } else if ( case Insensitive ) { read Simple Expressions ( txt , ctx , sentence ) ; } return sentence ; }
public  Kafka Cluster using Directory (  File data Dir ) { if ( running ) throw new  Illegal State Exception ( _ STR ) ; if ( data Dir != null && data Dir . exists ( ) && ! data Dir . is Directory ( ) && ! data Dir . can Write ( ) && ! data Dir . can Read ( ) ) { throw new  Illegal Argument Exception ( _ STR ) ; } this . data Dir = data Dir ; return this ; }
protected boolean check Prosodic Position (  Element current Rule Part ,  String prosodic Position Type ) {  Named Node Map att Nodes = current Rule Part . get Attributes ( ) ; for ( int z = _ NUM ; z < att Nodes . get Length ( ) ; z ++ ) {  Node el = att Nodes . item ( z ) ;  String current Att = el . get Node Name ( ) ;  String current Val = el . get Node Value ( ) ; if ( current Att . equals ( _ STR ) ) { if ( ! current Val . starts With ( _ STR ) ) { if ( ! prosodic Position Type . equals ( current Val ) ) return _ BOOL ; } else { current Val = current Val . substring ( _ NUM , current Val . length ( ) ) ; if ( prosodic Position Type . equals ( current Val ) ) return _ BOOL ; } } } return _ BOOL ; }
public static void register Operators (  String name ,  Input Stream operators XML ,  Class Loader class Loader ) { register Operators ( name , operators XML , class Loader , null ) ; }
public void delete Sub Group Containers (  Set group Containers ) throws  AMException ,  SSOException {  Iterator iter = group Containers . iterator ( ) ; while ( iter . has Next ( ) ) {  String group Container DN = (  String ) iter . next ( ) ;  AMGroup Container group Container = new  AMGroup Container Impl ( token , group Container DN ) ; group Container . delete ( ) ; } }
public  Glow Task (  Plugin owner ,  Runnable task , boolean sync , long delay , long period ) { super ( task , null ) ; task Id = next Task Id . get And Increment ( ) ; description = task . to String ( ) ; this . owner = owner ; this . delay = delay ; this . period = period ; counter = _ NUM ; this . sync = sync ; }
public static void init (  String [ ] args ) { try { compiler . init Compiler ( args ) ; if (  VM .  Build For Adaptive System &&  VM .  Build With Base Boot Image Compiler ) { opt Compiler . init Compiler ( args ) ; } } catch (  Throwable e ) { while ( e != null ) { e . print Stack Trace ( ) ; e = e . get Cause ( ) ; } } }
static native boolean open Dev ( ) ;
public static  String encode (  Serializable o ) {  Byte Array Output Stream bos = new  Byte Array Output Stream ( ) ; try {  Object Output Stream oos = new  Object Output Stream ( bos ) ; try { oos . write Object ( o ) ; oos . flush ( ) ; } finally { oos . close ( ) ; } return  Base64 . encode Bytes ( bos . to Byte Array ( ) ) ; } catch (  IOException e ) { throw new  Runtime Exception ( e ) ; } }
private static boolean is Identifier Name (  String k ) { int n = k . length ( ) ; if ( n == _ NUM ) { return _ BOOL ; } if ( !  Character . is Java Identifier Start ( k . char At ( _ NUM ) ) ) { return _ BOOL ; } for ( int i = _ NUM ; i < n ; ++ i ) { if ( !  Character . is Java Identifier Part ( k . char At ( i ) ) ) { return _ BOOL ; } } return _ BOOL ; }
static boolean less Than Unsigned Long ( long x1 , long x2 ) { return ( x1 +  Long .  MIN_ VALUE ) < ( x2 +  Long .  MIN_ VALUE ) ; }
private void move Single Node (  Object source ,  Point new Point ) {  Display Node node = (  Display Node ) source ; int delta X = new Point . x - click Point . x ; int delta Y = new Point . y - click Point . y ; int new X = node . get Location ( ) . x + delta X ; int new Y = node . get Location ( ) . y + delta Y ; node . set Location ( new X , new Y ) ; }
@  Suppress Warnings ( _ STR ) protected  Kafka Spout Wrapper create Kafka Spout (  Map conf ,  Topology Context context ,  Spout Output Collector collector , final  String topic ,  String scheme Cls Name ,  Spout Spec spout Spec ,  Map <  String ,  Stream Definition > sds ) throws  Exception {  String kafka Broker Zk Quorum = config . get String ( _ STR ) ;  Broker Hosts hosts = null ; if ( config . has Path ( _ STR ) ) { hosts = new  Zk Hosts ( kafka Broker Zk Quorum , config . get String ( _ STR ) ) ; } else { hosts = new  Zk Hosts ( kafka Broker Zk Quorum ) ; }  String transaction Zk Root =  DEFAULT_ STORM_ KAFKA_ TRANSACTION_ ZK_ ROOT ; if ( config . has Path ( _ STR ) ) { transaction Zk Root = config . get String ( _ STR ) ; }  String zk State Transaction Rel Path =  DEFAULT_ STORM_ KAFKA_ TRANSACTION_ ZK_ RELATIVE_ PATH ; if ( config . has Path ( _ STR ) ) { zk State Transaction Rel Path = config . get String ( _ STR ) ; }  Spout Config spout Config = new  Spout Config ( hosts , topic , transaction Zk Root , zk State Transaction Rel Path + _ STR + topic + _ STR + topology Id ) ; boolean storm Kafka Use Same Zk Quorum With Kafka Broker = config . get Boolean ( _ STR ) ; if ( storm Kafka Use Same Zk Quorum With Kafka Broker ) {  Zk Server Port Utils utils = new  Zk Server Port Utils ( kafka Broker Zk Quorum ) ; spout Config . zk Servers = utils . get Zk Hosts ( ) ; spout Config . zk Port = utils . get Zk Port ( ) ; } else {  Zk Server Port Utils utils = new  Zk Server Port Utils ( config . get String ( _ STR ) ) ; spout Config . zk Servers = utils . get Zk Hosts ( ) ; spout Config . zk Port = utils . get Zk Port ( ) ; } spout Config . state Update Interval Ms = config . has Path ( _ STR ) ? config . get Int ( _ STR ) : _ NUM ; spout Config . fetch Size Bytes = config . has Path ( _ STR ) ? config . get Int ( _ STR ) : _ NUM ; if ( config . has Path ( _ STR ) ) { spout Config . start Offset Time = config . get Int ( _ STR ) ; } spout Config . scheme = create Multi Scheme ( conf , topic , scheme Cls Name ) ;  Kafka Spout Wrapper wrapper = new  Kafka Spout Wrapper ( spout Config , kafka Spout Metric ) ;  Spout Output Collector Wrapper collector Wrapper = new  Spout Output Collector Wrapper ( this , collector , topic , spout Spec , num Of Router Bolts , sds , this . serializer ) ; wrapper . open ( conf , context , collector Wrapper ) ; if (  LOG . is Info Enabled ( ) ) {  LOG . info ( _ STR , topic , scheme Cls Name ) ; } return wrapper ; }
public  Builder add Email (  Email email ) { emails . add ( email ) ; return this ; }
public static  Hash Provider best (  Hash Parameters params ) { return best ( params ,  Enum Set . of (  Hash Support .  STATEFUL ) ) ; }
public byte [ ] read Raw Bytes ( final int size ) throws  IOException { if ( size < _ NUM ) { throw  Invalid Protocol Buffer Nano Exception . negative Size ( ) ; } if ( buffer Pos + size > current Limit ) { skip Raw Bytes ( current Limit - buffer Pos ) ; throw  Invalid Protocol Buffer Nano Exception . truncated Message ( ) ; } if ( size <= buffer Size - buffer Pos ) { final byte [ ] bytes = new byte [ size ] ;  System . arraycopy ( buffer , buffer Pos , bytes , _ NUM , size ) ; buffer Pos += size ; return bytes ; } else { throw  Invalid Protocol Buffer Nano Exception . truncated Message ( ) ; } }
static boolean pair Sum ( int ar [ ] , int x ) {  Arrays . sort ( ar ) ; int len = ar . length ; for ( int i = _ NUM , j = len - _ NUM ; i < j ; ) { if ( ar [ i ] + ar [ j ] == x ) { return _ BOOL ; } else if ( ar [ i ] + ar [ j ] < x ) { i ++ ; } else { j -- ; } } return _ BOOL ; }
public synchronized void load From File ( ) { entries . clear ( ) ;  Path file =  Paths . get ( file Name ) ; try (  Buffered Reader reader =  Files . new Buffered Reader ( file ,  CHARSET ) ) {  String line ; do { line = reader . read Line ( ) ;  Addressbook Entry parsed Entry = parse Line ( line ) ; if ( parsed Entry != null ) { entries . put ( parsed Entry . get Name ( ) , parsed Entry ) ; } } while ( line != null ) ; } catch (  IOException ex ) {  LOGGER . warning ( _ STR + ex . get Localized Message ( ) ) ; }  LOGGER . info ( _ STR + entries . size ( ) + _ STR + file Name ) ; scan Categories ( ) ; }
public double local Score ( int i , int ... parents ) { for ( int p : parents ) if ( forbidden . contains ( p ) ) return  Double .  Na N ; double residual Variance = covariances . get ( i , i ) ; int n = get Sample Size ( ) ; int p = parents . length ;  Matrix covxx = get Selection1 ( covariances , parents ) ; try {  Matrix covxx Inv = covxx . inverse ( ) ;  Matrix covxy = get Selection2 ( covariances , parents , i ) ;  Matrix b = covxx Inv . times ( covxy ) ; double dot = _ NUM ; for ( int j = _ NUM ; j < covxy . get Row Dimension ( ) ; j ++ ) { for ( int k = _ NUM ; k < covxy . get Column Dimension ( ) ; k ++ ) { dot += covxy . get ( j , k ) * b . get ( j , k ) ; } } residual Variance -= dot ; if ( residual Variance <= _ NUM ) { if ( is Verbose ( ) ) { out . println ( _ STR + ( residual Variance / covariances . get ( i , i ) ) ) ; } return  Double .  Na N ; } double c = get Penalty Discount ( ) ; return score ( residual Variance , n , logn , p , c ) ; } catch (  Exception e ) { boolean removed One = _ BOOL ; while ( removed One ) {  List <  Integer > _parents = new  Array List < > ( ) ; for ( int y = _ NUM ; y < parents . length ; y ++ ) _parents . add ( parents [ y ] ) ; _parents . remove All ( forbidden ) ; parents = new int [ _parents . size ( ) ] ; for ( int y = _ NUM ; y < _parents . size ( ) ; y ++ ) parents [ y ] = _parents . get ( y ) ; removed One = print Minimal Linearly Dependent Set ( parents , covariances ) ; } return  Double .  Na N ; } }
public boolean remove ( final int position ) { final  Adapter Transaction remove Transaction = new  Remove Transaction < > ( this , position ) ; final boolean success = remove Transaction . perform ( ) ; m Transactions . offer ( remove Transaction ) ; return success ; }
private void encode Types (  List <  Type > types ,  Map <  String ,  Object > m ,  String key ,  Declaration from ) { if ( types == null || types . is Empty ( ) ) return ;  List <  Map <  String ,  Object > > sats = new  Array List < > ( types . size ( ) ) ; for (  Type st : types ) { sats . add ( type Map ( st , from ) ) ; } m . put ( key , sats ) ; }
public static void clear Assertion Information ( ) { _ Assert Infos . clear ( ) ; _ Assert Occured = _ BOOL ; }
public void build (  String code ,  String custom Status ) { try { if ( custom Status != null ) { result . put ( resources . get String (  R . string . intent_extra_status ) , custom Status ) ; } else { result . put ( resources . get String (  R . string . intent_extra_status ) , resources . get String (  R . string . shared_pref_default_status ) ) ; } result . put ( resources . get String (  R . string . intent_extra_code ) , code ) ; operation List Result . put ( result ) ; } catch (  JSONException e ) {  Log . e (  TAG , _ STR + e . to String ( ) ) ; } }
public static  Operator generate Branch Plan (  Akiban Information Schema ais ,  Table table ) { final  Operator index Scan = generate Index Scan ( ais , table ) ; final  Schema schema =  Schema Cache . global Schema ( ais ) ;  Primary Key pkey = table . get Primary Key Including Internal ( ) ;  Index Row Type index Type = schema . index Row Type ( pkey . get Index ( ) ) ; return generate Branch Plan ( table , index Scan , index Type ) ; }
public long startstack ( ) { return  Long . parse Long ( fields [ _ NUM ] ) ; }
public static void copy Realm Privileges From Parent (  SSOToken token ,  Organization Config Manager parent ,  Organization Config Manager child ) throws  SSOException ,  Delegation Exception { if ( debug . message Enabled ( ) ) { debug . message ( _ STR + _ STR + parent . get Organization Name ( ) + _ STR + child . get Organization Name ( ) ) ; }  Delegation Manager pdm = new  Delegation Manager ( token , parent . get Organization Name ( ) ) ;  Delegation Manager cdm = new  Delegation Manager ( token , child . get Organization Name ( ) ) ;  String child Org Name =  DNMapper . org Name To DN ( child . get Organization Name ( ) ) ;  Set pdps = pdm . get Privileges ( ) ; if ( pdps == null || pdps . is Empty ( ) ) { if ( debug . message Enabled ( ) ) { debug . message ( _ STR + _ STR ) ; } return ; } for (  Iterator items = pdps . iterator ( ) ; items . has Next ( ) ; ) {  Delegation Privilege dp = (  Delegation Privilege ) items . next ( ) ;  Set subjects = dp . get Subjects ( ) ; if ( subjects == null || subjects . is Empty ( ) ) { if ( debug . message Enabled ( ) ) { debug . message ( _ STR + _ STR + dp ) ; } continue ; }  Set new Subjects = new  Hash Set ( ) ; for (  Iterator subs = subjects . iterator ( ) ; subs . has Next ( ) ; ) {  String s Name = (  String ) subs . next ( ) ; try {  AMIdentity id =  Id Utils . get Identity ( token , s Name ) ;  AMIdentity new Id = new  AMIdentity ( token , id . get Name ( ) , id . get Type ( ) , child Org Name , id . get DN ( ) ) ; new Subjects . add (  Id Utils . get Universal Id ( new Id ) ) ; } catch (  Id Repo Exception ide ) { if ( debug . message Enabled ( ) ) { debug . message ( _ STR + _ STR + dp , ide ) ; } continue ; } } dp . set Subjects ( new Subjects ) ;  Set permissions = dp . get Permissions ( ) ; if ( ( permissions != null ) && ( ! permissions . is Empty ( ) ) ) {  Iterator it = permissions . iterator ( ) ; while ( it . has Next ( ) ) {  Delegation Permission perm = (  Delegation Permission ) it . next ( ) ; perm . set Organization Name ( _ STR + child Org Name ) ; } } cdm . add Privilege ( dp ) ; if ( debug . message Enabled ( ) ) { debug . message ( _ STR + _ STR + dp ) ; } } }
public boolean match (  Mime Type other ) { if ( this == other ) return _ BOOL ; if ( type != null && other . type != null && ! type . equals ( other . type ) ) return _ BOOL ; if ( subtype != null && other . subtype != null && ! subtype . equals ( other . subtype ) ) return _ BOOL ; return _ BOOL ; }
@  Override public boolean is Armed ( ) { return other . is Armed ( ) ; }
public  Encoder Test Suite Builder valid ( int min , int max ) { _valid . set ( min , max + _ NUM ) ; _invalid . clear ( min , max + _ NUM ) ; _encoded . clear ( min , max + _ NUM ) ; return this ; }
protected  List <  Volume Descriptor > create Change Virtual Pool Descriptors (  Storage System vplex System ,  Volume volume ,  Virtual Pool new Vpool ,  String task Id ,  List <  Recommendation > recommendations ,  Virtual Pool Capability Values Wrapper capabilities ,  Controller Operation Values Wrapper operations Wrapper ) throws  Internal Exception {  URI volume Varray URI = volume . get Virtual Array ( ) ;  Virtual Array volume Varray = _db Client . query Object (  Virtual Array . class , volume Varray URI ) ; s_logger . info ( _ STR , volume Varray URI ) ;  URI volume Vpool URI = volume . get Virtual Pool ( ) ;  Virtual Pool current Vpool = _db Client . query Object (  Virtual Pool . class , volume Vpool URI ) ;  List <  Volume Descriptor > descriptors = new  Array List <  Volume Descriptor > ( ) ;  Volume Descriptor vplex Virtual Volume Desc = new  Volume Descriptor (  Volume Descriptor .  Type .  VPLEX_ VIRT_ VOLUME , volume . get Storage Controller ( ) , volume . get Id ( ) , volume . get Pool ( ) , null ) ;  Map <  String ,  Object > volume Params = new  Hash Map <  String ,  Object > ( ) ; volume Params . put (  Volume Descriptor .  PARAM_ VPOOL_ CHANGE_ EXISTING_ VOLUME_ ID , volume . get Id ( ) ) ; volume Params . put (  Volume Descriptor .  PARAM_ VPOOL_ CHANGE_ NEW_ VPOOL_ ID , new Vpool . get Id ( ) ) ; volume Params . put (  Volume Descriptor .  PARAM_ VPOOL_ CHANGE_ OLD_ VPOOL_ ID , volume . get Virtual Pool ( ) ) ; if ( operations Wrapper != null ) { if ( operations Wrapper . get Migration Suspend Before Commit ( ) != null ) { volume Params . put (  Volume Descriptor .  PARAM_ MIGRATION_ SUSPEND_ BEFORE_ COMMIT , operations Wrapper . get Migration Suspend Before Commit ( ) ) ; } if ( operations Wrapper . get Migration Suspend Before Delete Source ( ) != null ) { volume Params . put (  Volume Descriptor .  PARAM_ MIGRATION_ SUSPEND_ BEFORE_ DELETE_ SOURCE , operations Wrapper . get Migration Suspend Before Delete Source ( ) ) ; } } vplex Virtual Volume Desc . set Parameters ( volume Params ) ; descriptors . add ( vplex Virtual Volume Desc ) ; if (  Virtual Pool Change Analyzer . vpool Change Requires Migration ( current Vpool , new Vpool ) ) {  Volume mig Src Volume = get Associated Volume In VArray ( volume , volume Varray URI ) ; descriptors . add All ( create Backend Volume Migration Descriptors ( vplex System , volume , mig Src Volume , volume Varray , new Vpool , get Volume Capacity ( mig Src Volume != null ? mig Src Volume : volume ) , task Id , recommendations , _ BOOL , capabilities ) ) ; }  URI ha Varray URI =  Virtual Pool Change Analyzer . get Ha Varray URI ( current Vpool ) ; if ( ha Varray URI != null ) {  Virtual Array ha Varray = _db Client . query Object (  Virtual Array . class , ha Varray URI ) ;  Virtual Pool current Ha Vpool =  Virtual Pool Change Analyzer . get Ha Vpool ( current Vpool , _db Client ) ;  Virtual Pool new Ha Vpool =  Virtual Pool Change Analyzer . get New Ha Vpool ( current Vpool , new Vpool , _db Client ) ; if (  Virtual Pool Change Analyzer . vpool Change Requires Migration ( current Ha Vpool , new Ha Vpool ) ) {  Volume mig Src Volume = get Associated Volume In VArray ( volume , ha Varray URI ) ; descriptors . add All ( create Backend Volume Migration Descriptors ( vplex System , volume , mig Src Volume , ha Varray , new Ha Vpool , get Volume Capacity ( mig Src Volume != null ? mig Src Volume : volume ) , task Id , recommendations , _ BOOL , capabilities ) ) ; } } return descriptors ; }
public static boolean is Java Script Enabled (  Http Servlet Request request ) {  Http Session session = request . get Session ( ) ;  Boolean java Script Enabled = (  Boolean ) session . get Attribute ( _ STR ) ; if ( java Script Enabled != null ) { return java Script Enabled . boolean Value ( ) ; } return _ BOOL ; }
public boolean equals (  Object obj ) { if ( this == obj ) return _ BOOL ; if ( obj instanceof  ECField Fp ) { return ( p . equals ( ( (  ECField Fp ) obj ) . p ) ) ; } return _ BOOL ; }
private static  String checksum MD5 (  String data ) {  Message Digest md5 = null ; try { md5 =  Message Digest . get Instance ( _ STR ) ; } catch (  No Such Algorithm Exception ex ) { throw new  Runtime Exception ( _ STR , ex ) ; } return hex Encode ( md5 . digest ( data . get Bytes ( ) ) ) ; }
public static boolean valid Skin Spec File (  String file Name ) {  File file = new  File (  Configuration . skins Dir ( ) , file Name ) ; if ( ! file . exists ( ) || ! file . is File ( ) ) { return _ BOOL ; }  Document Builder Factory dbf =  Document Builder Factory . new Instance ( ) ; try {  Document Builder builder = dbf . new Document Builder ( ) ;  Document doc = builder . parse ( file ) ;  Node List list Of Components = doc . get Elements By Tag Name (  UI_ ELEMENT ) ; if ( list Of Components . get Length ( ) > _ NUM ) { return _ BOOL ; } else { return _ BOOL ; } } catch (  Exception e ) { return _ BOOL ; } }
public  Str Builder insert ( final int index , final  Object obj ) { if ( obj == null ) { return insert ( index , null Text ) ; } return insert ( index , obj . to String ( ) ) ; }
@  Override public void handle Mouse Moved (  Chart Canvas canvas ,  Mouse Event e ) { if ( ! canvas . is Tooltip Enabled ( ) ) { return ; }  String text = get Tooltip Text ( canvas , e . get X ( ) , e . get Y ( ) ) ; canvas . set Tooltip ( text , e . get Screen X ( ) , e . get Screen Y ( ) ) ; }
private boolean load Unpacked UMD (  String filename ) throws  IOException ,  General Jpcsp Exception { if ( do Umd Buffering ) { return _ BOOL ; }  File file = new  File ( filename ) ; if ( file . exists ( ) ) {  Random Access File raf = new  Random Access File ( file , _ STR ) ;  File Channel ro Channel = raf . get Channel ( ) ;  Byte Buffer readbuffer = ro Channel . map (  File Channel .  Map Mode .  READ_ ONLY , _ NUM , ( int ) ro Channel . size ( ) ) ; emulator . load ( _ STR , readbuffer ) ; raf . close ( ) ; log . info ( _ STR ) ; return _ BOOL ; } return _ BOOL ; }
public boolean disable VMAX3 Compression (  URI block Object URI ,  Storage System storage System ) {  Virtual Pool virtual Pool = null ;  Storage Pool storage Pool = null ;  Volume volume = null ; if (  URIUtil . is Type ( block Object URI ,  Volume . class ) ) { volume = _db Client . query Object (  Volume . class , block Object URI ) ; } else if (  URIUtil . is Type ( block Object URI ,  Block Snapshot . class ) ) {  Block Snapshot snapshot = _db Client . query Object (  Block Snapshot . class , block Object URI ) ; volume = _db Client . query Object (  Volume . class , snapshot . get Parent ( ) ) ; } else if (  URIUtil . is Type ( block Object URI ,  Block Mirror . class ) ) {  Block Mirror mirror = _db Client . query Object (  Block Mirror . class , block Object URI ) ; virtual Pool = _db Client . query Object (  Virtual Pool . class , mirror . get Virtual Pool ( ) ) ; storage Pool = _db Client . query Object (  Storage Pool . class , mirror . get Pool ( ) ) ; } if ( volume != null ) { virtual Pool = _db Client . query Object (  Virtual Pool . class , volume . get Virtual Pool ( ) ) ; storage Pool = _db Client . query Object (  Storage Pool . class , volume . get Pool ( ) ) ; } return ( check If Provider Supports Compression Operations ( storage System ) && ! virtual Pool . get Compression Enabled ( ) && storage Pool . get Compression Enabled ( ) ) ; }
public static  Lat Lon rhumb End Position (  Lat Lon p , double rhumb Azimuth Radians , double path Length Radians ) { if ( p == null ) { throw new  Illegal Argument Exception ( _ STR ) ; } return rhumb End Position ( p ,  Angle . from Radians ( rhumb Azimuth Radians ) ,  Angle . from Radians ( path Length Radians ) ) ; }
public  Dimension maximum Layout Size (  Container target ) { return new  Dimension (  Integer .  MAX_ VALUE ,  Integer .  MAX_ VALUE ) ; }
public static  String read Stream (  Input Stream in ) {  Buffered Reader reader = new  Buffered Reader ( new  Input Stream Reader ( in ) ) ;  String Builder sb = new  String Builder ( ) ;  String line = null ; try { while ( ( line = reader . read Line ( ) ) != null ) { sb . append ( line + _ STR ) ; } } catch (  IOException e ) {  Fresh Air Log . e ( _ STR , e ) ; } finally { try { in . close ( ) ; } catch (  IOException e ) { } try { reader . close ( ) ; } catch (  IOException e ) { } } return sb . to String ( ) ; }
private void log Expiration (  Entry e ) { if ( e . renewals Done ( ) ) { logger . log (  Level .  FINE , _ STR , e . lease ) ; } else { logger . log (  Levels .  FAILED , _ STR , e . lease ) ; } }
void remove Ripple (  Ripple ripple ) { final  Ripple [ ] ripples = m Exiting Ripples ; final int count = m Exiting Ripples Count ; final int index = get Ripple Index ( ripple ) ; if ( index >= _ NUM ) {  System . arraycopy ( ripples , index + _ NUM , ripples , index , count - ( index + _ NUM ) ) ; ripples [ count - _ NUM ] = null ; m Exiting Ripples Count -- ; invalidate Self ( ) ; } }
protected final void write S (  Byte Buffer buf ,  String text ) { if ( text == null ) { buf . put Char ( _ STR ) ; } else { final int len = text . length ( ) ; for ( int i = _ NUM ; i < len ; i ++ ) { buf . put Char ( text . char At ( i ) ) ; } buf . put Char ( _ STR ) ; } }
@  Override public void on Draw Eye (  Eye eye ) {  GLES20 . gl Clear (  GLES20 .  GL_ COLOR_ BUFFER_ BIT |  GLES20 .  GL_ DEPTH_ BUFFER_ BIT ) ;  Engine . check GLError ( _ STR ) ; if ( ! pref Orientation Provider String . equals ( _ STR ) ) { if ( first On Draw Eye > _ NUM ) { first On Draw Eye -- ; float [ ] m = new float [ _ NUM ] ;  Matrix . invert M ( m , _ NUM , m Head View SDK , _ NUM ) ;  Matrix . multiply MM ( m , _ NUM , eye . get Eye View ( ) , _ NUM , m , _ NUM ) ; if ( eye . get Type ( ) ==  Eye .  Type .  RIGHT ) { m Eye Right View = m ; } else if ( eye . get Type ( ) ==  Eye .  Type .  LEFT ) { m Eye Left View = m ; } return ; } float [ ] m = new float [ _ NUM ] ; if ( eye . get Type ( ) ==  Eye .  Type .  RIGHT ) {  Matrix . multiply MM ( m , _ NUM , m Head View Use , _ NUM , m Eye Right View , _ NUM ) ; } else {  Matrix . multiply MM ( m , _ NUM , m Head View Use , _ NUM , m Eye Left View , _ NUM ) ; }  Matrix . multiply MM ( m View , _ NUM , m , _ NUM , m Camera , _ NUM ) ; } else {  Matrix . multiply MM ( m View , _ NUM , eye . get Eye View ( ) , _ NUM , m Camera , _ NUM ) ; } float [ ] perspective = eye . get Perspective (  Z_ NEAR ,  Z_ FAR ) ;  GLES20 . gl Enable (  GLES20 .  GL_ DEPTH_ TEST ) ;  GLES20 . gl Blend Func (  GLES20 .  GL_ SRC_ ALPHA ,  GLES20 .  GL_ ONE_ MINUS_ SRC_ ALPHA ) ;  GLES20 . gl Enable (  GLES20 .  GL_ BLEND ) ; if ( pref Show Env && bg Env . is Ready ( ) ) {  Matrix . multiply MM ( m Model View , _ NUM , m View , _ NUM , bg Env . model , _ NUM ) ;  Matrix . multiply MM ( m Model View Projection , _ NUM , perspective , _ NUM , m Model View , _ NUM ) ; bg Env . draw ( eye . get Type ( ) , m Model View Projection ) ; }  GLES20 . gl Disable (  GLES20 .  GL_ DEPTH_ TEST ) ;  Matrix . multiply MM ( m Model View Projection , _ NUM , perspective , _ NUM , camera Preview . model , _ NUM ) ; camera Preview . draw ( eye . get Type ( ) , m Model View Projection ) ;  Matrix . multiply MM ( m Model View , _ NUM , m View , _ NUM , screen . model , _ NUM ) ;  Matrix . multiply MM ( m Model View Projection , _ NUM , perspective , _ NUM , m Model View , _ NUM ) ; screen . draw ( eye . get Type ( ) , m Model View Projection ) ; for (  Button Thing button : button List ) {  Matrix . multiply MM ( m Model View , _ NUM , m View , _ NUM , button . model , _ NUM ) ;  Matrix . multiply MM ( m Model View Projection , _ NUM , perspective , _ NUM , m Model View , _ NUM ) ; button . draw ( eye . get Type ( ) , m Model View Projection ) ; }  Matrix . multiply MM ( m Model View Projection , _ NUM , perspective , _ NUM , aim Point . model , _ NUM ) ; aim Point . draw (  Eye .  Type .  MONOCULAR , m Model View Projection ) ; }
protected  Source Records consume Records By Topic ( int num Records ) throws  Interrupted Exception {  Source Records records = new  Source Records ( ) ; consume Records ( num Records , null ) ; return records ; }
@  Override public boolean equals (  Object o ) { if ( this == o ) { return _ BOOL ; } if ( ! ( o instanceof  Prototype Size ) ) { return _ BOOL ; }  Prototype Size size = (  Prototype Size ) o ; return prototype . equals ( size . prototype ) ; }
private static int compare Version (  String version Str1 ,  String version Str2 ) { if ( version Str1 == null ) { throw new  MLContext Exception ( _ STR ) ; } if ( version Str2 == null ) { throw new  MLContext Exception ( _ STR ) ; }  Scanner scanner1 = null ;  Scanner scanner2 = null ; try { scanner1 = new  Scanner ( version Str1 ) ; scanner2 = new  Scanner ( version Str2 ) ; scanner1 . use Delimiter ( _ STR ) ; scanner2 . use Delimiter ( _ STR ) ; while ( scanner1 . has Next Int ( ) && scanner2 . has Next Int ( ) ) { int version1 = scanner1 . next Int ( ) ; int version2 = scanner2 . next Int ( ) ; if ( version1 < version2 ) { return - _ NUM ; } else if ( version1 > version2 ) { return _ NUM ; } } return scanner1 . has Next Int ( ) ? _ NUM : _ NUM ; } finally { scanner1 . close ( ) ; scanner2 . close ( ) ; } }
public static boolean is Valid Vector (  Vector2f vector ) { if ( vector == null ) { return _ BOOL ; } if (  Float . is Na N ( vector . x ) ||  Float . is Na N ( vector . y ) ) { return _ BOOL ; } if (  Float . is Infinite ( vector . x ) ||  Float . is Infinite ( vector . y ) ) { return _ BOOL ; } return _ BOOL ; }
public boolean is Obsessional ( ) { return type String . contains (  SUFFIX_ OBSESSIONAL ) ; }
@ edu . umd . cs . findbugs . annotations .  Suppress FBWarnings ( value = _ STR , justification = _ STR ) public void change Loco Speed (  Dcc Throttle t ,  Block blk , float speed ) { if ( blk == referenced && speed == desired Speed Step ) { return ; } float block Length = blk . get Length Mm ( ) ; if ( blk == referenced ) { distance Remaining = distance Remaining - get Distance Travelled ( _throttle . get Is Forward ( ) , _throttle . get Speed Setting ( ) , ( ( float ) (  System . nano Time ( ) - last Time Timer Started ) / _ NUM ) ) ; block Length = distance Remaining ; log . debug ( _ STR ) ; } else { referenced = blk ; } change Loco Speed ( t , block Length , speed ) ; }
public boolean remove (  Object target Child ) { return remove ( target Child , _ BOOL ) ; }
private void notify Class Observers (  Class Descriptor class Descriptor ) { for (  IClass Observer observer : class Observer List ) { observer . observe Class ( class Descriptor ) ; } }
public void dup2 ( ) { mv . visit Insn (  Opcodes .  DUP2 ) ; }
public static  Native Page create Native Page For URL (  String url ,  Native Page candidate Page ,  Tab tab ,  Tab Model Selector tab Model Selector ,  Activity activity ) { return create Native Page For URL ( url , candidate Page , tab , tab Model Selector , activity , tab . is Incognito ( ) ) ; }
protected void throw Parse Exception (  Parse Exception e ) throws  Parse Exception { if ( locator != null ) {  String element Location = _ STR ; if ( cur Handler != null ) { element Location += _ STR + cur Handler . q Name ; }  String location = _ STR +  String . value Of ( locator . get Line Number ( ) ) + _ STR +  String . value Of ( locator . get Column Number ( ) ) + element Location + _ STR ;  Log Utils . log Exception ( logger ,  Level .  FINE , location , e ) ; throw new  Parse Exception ( location + e . get Message ( ) , e ) ; } else {  Log Utils . log Exception ( logger ,  Level .  FINE , null , e ) ; throw e ; } }
public  Custom Editor ( ) { set Layout ( new  Border Layout ( ) ) ; add ( m_ Label ,  Border Layout .  CENTER ) ; m_ Delete But . add Action Listener ( m_ Inner Action Listener ) ; m_ Edit But . add Action Listener ( m_ Inner Action Listener ) ; m_ Up But . add Action Listener ( m_ Inner Action Listener ) ; m_ Down But . add Action Listener ( m_ Inner Action Listener ) ; m_ Add But . add Action Listener ( m_ Inner Action Listener ) ; m_ Element List . add List Selection Listener ( m_ Inner Selection Listener ) ; m_ Element List . add Mouse Listener ( m_ Inner Mouse Listener ) ; m_ Add But . set Tool Tip Text ( _ STR ) ; m_ Delete But . set Tool Tip Text ( _ STR ) ; m_ Edit But . set Tool Tip Text ( _ STR ) ; m_ Up But . set Tool Tip Text ( _ STR ) ; m_ Down But . set Tool Tip Text ( _ STR ) ; }
public  Memoid One (  Function < ? super  Input , ? extends  Output > fn ,  Bi Predicate <  Input ,  Input > equality ) { fn_ =  Objects . require Non Null ( fn ) ; equality_ =  Objects . require Non Null ( equality ) ; }
public static  EPType single Value (  Class single Value Type ) { if ( single Value Type != null && single Value Type . is Array ( ) ) { return new  Class Multi Valued EPType ( single Value Type , single Value Type . get Component Type ( ) ) ; } return new  Class EPType ( single Value Type ) ; }
private static  Class < ? > convert Field Type (  String field Type ) { if ( field Type Map . contains Key ( field Type ) ) { return field Type Map . get ( field Type ) ; } return null ; }
void add XMLElement After Token Index ( int last Token Index ,  XMLElement element , boolean add After New Line ) throws  Exception { add XMLElement After Token Index ( last Token Index , element , add After New Line , _ BOOL ) ; }
public static boolean array Equals (  Object x ,  Object y , double tolf , double told ) { if ( x == null && y == null ) { return _ BOOL ; } if ( x == null || y == null ) { return _ BOOL ; }  Class < ? > x Class = x . get Class ( ) ;  Class < ? > y Class = y . get Class ( ) ; if ( x Class != y Class ) { return _ BOOL ; } if ( ! x Class . is Array ( ) ) { return x . equals ( y ) ; } else { if ( x Class . equals ( int [ ] . class ) ) { return  Arrays . equals ( ( int [ ] ) x , ( int [ ] ) y ) ; } else if ( x Class . equals ( double [ ] . class ) ) { if ( told == _ NUM ) { return  Arrays . equals ( ( double [ ] ) x , ( double [ ] ) y ) ; } else { return double Array Equals ( ( double [ ] ) x , ( double [ ] ) y , told ) ; } } else if ( x Class . equals ( long [ ] . class ) ) { return  Arrays . equals ( ( long [ ] ) x , ( long [ ] ) y ) ; } else if ( x Class . equals ( float [ ] . class ) ) { if ( tolf == _ NUM ) { return  Arrays . equals ( ( float [ ] ) x , ( float [ ] ) y ) ; } else { return float Array Equals ( ( float [ ] ) x , ( float [ ] ) y , ( float ) tolf ) ; } } else if ( x Class . equals ( byte [ ] . class ) ) { return  Arrays . equals ( ( byte [ ] ) x , ( byte [ ] ) y ) ; } else if ( x Class . equals ( short [ ] . class ) ) { return  Arrays . equals ( ( short [ ] ) x , ( short [ ] ) y ) ; } else if ( x Class . equals ( char [ ] . class ) ) { return  Arrays . equals ( ( char [ ] ) x , ( char [ ] ) y ) ; } else if ( x Class . equals ( boolean [ ] . class ) ) { return  Arrays . equals ( ( boolean [ ] ) x , ( boolean [ ] ) y ) ; } else {  Object [ ] xo = (  Object [ ] ) x ;  Object [ ] yo = (  Object [ ] ) y ; if ( xo . length != yo . length ) { return _ BOOL ; } for ( int i = _ NUM ; i < xo . length ; i += _ NUM ) { if ( ! array Equals ( xo [ i ] , yo [ i ] , tolf , told ) ) { return _ BOOL ; } } return _ BOOL ; } } }
public  Dictionary (  Directory temp Dir ,  String temp File Name Prefix ,  Input Stream affix ,  List <  Input Stream > dictionaries , boolean ignore Case ) throws  IOException ,  Parse Exception { this . ignore Case = ignore Case ; this . needs Input Cleaning = ignore Case ; this . needs Output Cleaning = _ BOOL ; flag Lookup . add ( new  Bytes Ref ( ) ) ;  Path aff =  Files . create Temp File ( temp Path , _ STR , _ STR ) ;  Output Stream out = new  Buffered Output Stream (  Files . new Output Stream ( aff ) ) ;  Input Stream aff1 = null ;  Input Stream aff2 = null ; boolean success = _ BOOL ; try { final byte [ ] buffer = new byte [ _ NUM * _ NUM ] ; int len ; while ( ( len = affix . read ( buffer ) ) > _ NUM ) { out . write ( buffer , _ NUM , len ) ; } out . close ( ) ; aff1 = new  Buffered Input Stream (  Files . new Input Stream ( aff ) ) ;  String encoding = get Dictionary Encoding ( aff1 ) ;  Charset Decoder decoder = get Java Encoding ( encoding ) ; aff2 = new  Buffered Input Stream (  Files . new Input Stream ( aff ) ) ; read Affix File ( aff2 , decoder ) ;  Int Sequence Outputs o =  Int Sequence Outputs . get Singleton ( ) ;  Builder <  Ints Ref > b = new  Builder < > (  FST .  INPUT_ TYPE .  BYTE4 , o ) ; read Dictionary Files ( temp Dir , temp File Name Prefix , dictionaries , decoder , b ) ; words = b . finish ( ) ; aliases = null ; morph Aliases = null ; success = _ BOOL ; } finally {  IOUtils . close While Handling Exception ( out , aff1 , aff2 ) ; if ( success ) {  Files . delete ( aff ) ; } else {  IOUtils . delete Files Ignoring Exceptions ( aff ) ; } } }
public void collapse Building (  Building bldg ) { buildings . remove Element ( bldg ) ;  Enumeration <  Coords > bldg Coords = bldg . get Coords ( ) ; while ( bldg Coords . has More Elements ( ) ) { final  Coords coords = bldg Coords . next Element ( ) ; collapse Building ( coords ) ; } }
@  Rpc Method public void detach ISO (  String vm Id , boolean is Delete File ,  Async Method Callback <  Host .  Async Client . detach_iso_call > handler ) throws  Rpc Exception { ensure Client ( ) ;  Detach ISORequest detach ISORequest = new  Detach ISORequest ( vm Id ) ; detach ISORequest . set Delete_file ( is Delete File ) ; client Proxy . set Timeout (  DETACH_ ISO_ TIMEOUT_ MS ) ; logger . info ( _ STR , vm Id , get Host Ip ( ) , detach ISORequest ) ; try { client Proxy . detach_iso ( detach ISORequest , handler ) ; } catch (  TException e ) { throw new  Rpc Exception ( e . get Message ( ) ) ; } }
private  String read Nfc Error Msg (  Byte Buffer reply ) throws  IOException { int error Type = reply . get Int ( ) ; int error Code = reply . get Int ( ) ; int msg Len = reply . get Int ( ) ; if ( msg Len == _ NUM ) { return _ STR ; }  Byte Buffer msg Buffer =  Byte Buffer . allocate ( msg Len ) ; read Fully ( msg Buffer ) ;  String error Msg = new  String ( msg Buffer . array ( ) , _ NUM , msg Len - _ NUM ,  Charsets .  US_ ASCII ) ; return  String . format ( _ STR , error Type , error Code , error Msg ) ; }
private void show ( boolean show ) { if ( show ) { if ( m XFade != null ) { m XFade . cancel ( ) ; } m State =  STATE_ PIE ; m Current Item = null ;  Pie Item root = get Root ( ) ; for (  Pie Item open Item : m Open ) { if ( open Item . has Items ( ) ) { for (  Pie Item item : open Item . get Items ( ) ) { item . set Selected ( _ BOOL ) ; } } } m Label . set Text ( _ STR ) ; m Open . clear ( ) ; m Open . add ( root ) ; layout Pie ( ) ; fade In ( ) ; } else { m State =  STATE_ IDLE ; m Tap Mode = _ BOOL ; if ( m XFade != null ) { m XFade . cancel ( ) ; } if ( m Label != null ) { m Label . set Text ( _ STR ) ; } } set Visible ( show ) ; m Handler . send Empty Message ( show ?  MSG_ OPEN :  MSG_ CLOSE ) ; }
private synchronized void persist Profile And Notify Change (  Authn Provider modified Provider , boolean new Object ) { modified Provider . set Last Modified (  System . current Time Millis ( ) ) ; if ( new Object ) { _db Client . create Object ( modified Provider ) ; } else { _db Client . persist Object ( modified Provider ) ; } notify Change ( ) ; }
public void add Undoable Action (  Undoable Action action ) { undo Stack . push ( action ) ; redo Stack . remove All Elements ( ) ; }
public  Int Array List ( int [ ] data ) { array = new int [ ( int ) ( data . length * _ NUM ) + _ NUM ] ; size = data . length ;  System . arraycopy ( data , _ NUM , array , _ NUM , size ) ; }
private void add Ping Time Data ( long sample ) { last Ping Times Lock . lock ( ) ; try { if ( last Ping Times == null ) { last Ping Times = new long [  PING_ MOVING_ AVERAGE_ WINDOW ] ;  Arrays . fill ( last Ping Times , sample ) ; } else {  System . arraycopy ( last Ping Times , _ NUM , last Ping Times , _ NUM , last Ping Times . length - _ NUM ) ; last Ping Times [ last Ping Times . length - _ NUM ] = sample ; } } finally { last Ping Times Lock . unlock ( ) ; } }
public  String Builder encode Body (  String Builder buffer ) { return buffer . append ( content Encoding ) ; }
protected void tear Down ( ) { try { ds . close ( ) ; sds . close ( ) ; } catch (  Exception e ) { } }
public  String substring (  String subject , int start , int stop ) { if ( stop == - _ NUM || stop >= subject . length ( ) ) { return subject . substring ( start ) ; } return subject . substring ( start , stop ) ; }
public boolean control Run Train ( int idx ) { if ( log . is Debug Enabled ( ) ) { log . debug ( _ STR + idx + _ STR + _run Mode + _ STR + get Display Name ( ) ) ; } boolean ret = _ BOOL ; int old Index = -  MODE_ MANUAL ; if ( _engineer == null ) { switch ( idx ) { case  HALT : case  RESUME : case  RETRY : ret = _ BOOL ; break ; case  ABORT : if ( _run Mode ==  Warrant .  MODE_ LEARN ) { fire Property Change ( _ STR ,  Integer . value Of ( -  MODE_ LEARN ) ,  Integer . value Of ( _idx Current Order ) ) ; } else { stop Warrant ( _ BOOL ) ; } break ; } } else { synchronized ( _engineer ) { old Index = _engineer . get Run State ( ) ; switch ( idx ) { case  HALT : _engineer . set Halt ( _ BOOL ) ; break ; case  RESUME : _engineer . set Halt ( _ BOOL ) ; restart ( ) ; ret = move Into Next Block (  MID ) ; break ; case  RETRY :  Block Order bo = get Block Order At ( _idx Current Order + _ NUM ) ; ret = _ BOOL ; if ( bo != null ) {  OBlock b = bo . get Block ( ) ; if ( b . allocate ( this ) == null && ( b . get State ( ) &  OBlock .  OCCUPIED ) != _ NUM ) { _idx Current Order ++ ; if ( b . equals ( _stopping Block ) ) { _stopping Block . remove Property Change Listener ( this ) ; _stopping Block = null ; } bo . set Path ( this ) ; restart ( ) ; going Active ( b ) ; ret = _ BOOL ; } } break ; case  ABORT : stop Warrant ( _ BOOL ) ; break ; } } } if ( ret ) { fire Property Change ( _ STR ,  Integer . value Of ( old Index ) ,  Integer . value Of ( idx ) ) ; } return ret ; }
public void remove Custom Sash Form Listener (  ICustom Sash Form Listener listener ) { if ( custom Sash Form Listeners != null ) { custom Sash Form Listeners . remove ( listener ) ; } }
@  Override public void close ( ) throws  IOException { if ( m Buffer Count > _ NUM ) { try { m Queue . write ( m Buffer , _ NUM , m Buffer Count ) ; } catch (  Interrupted Exception e ) { throw new  IOException ( _ STR ) ; } m Buffer Count = _ NUM ; } m Queue . close ( ) ; try { m Thread . join ( ) ; } catch (  Interrupted Exception e ) { throw new  IOException ( _ STR ) ; } finally { super . close ( ) ; } check Exception ( ) ; }
public static int parse String As Int (  String in ) throws  Index Parse Field Exception { try { return  Integer . parse Int ( in ) ; } catch (  Number Format Exception e ) { throw new  Index Parse Field Exception ( in , e ) ; } }
public void write All (  Result Set rs , boolean include Column Names , boolean trim ) throws  SQLException ,  IOException { if ( include Column Names ) { write Column Names ( rs ) ; } while ( rs . next ( ) ) { write Next ( result Service . get Column Values ( rs , trim ) ) ; } }
public  Zone Rules Builder add Window (  Zone Offset standard Offset ,  Local Date Time until ,  Time Definition until Definition ) {  Objects . require Non Null ( standard Offset , _ STR ) ;  Objects . require Non Null ( until , _ STR ) ;  Objects . require Non Null ( until Definition , _ STR ) ;  TZWindow window = new  TZWindow ( standard Offset , until , until Definition ) ; if ( window List . size ( ) > _ NUM ) {  TZWindow previous = window List . get ( window List . size ( ) - _ NUM ) ; window . validate Window Order ( previous ) ; } window List . add ( window ) ; return this ; }
public  Hashtable <  IPoint ,  List <  ILine Segment > > intersections (  Iterator <  ILine Segment > it ) {  Collection <  ILine Segment > c = new  Array List <  ILine Segment > ( ) ; while ( it . has Next ( ) ) { c . add ( it . next ( ) ) ; } return intersections ( c . to Array ( new  ILine Segment [ ] { } ) ) ; }
public boolean is TTFNative Font ( ) { return ttf ; }
private void register Providers ( ) { final  Dev Machine dev Machine = app Context . get Dev Machine ( ) ; if ( dev Machine == null ) { return ; } final  Set <  Macro > providers = get Macros ( dev Machine ) ; check Not Null ( providers ) ; if ( providers . is Empty ( ) ) { return ; } provider Registry . register ( providers ) ; }
protected void populate Stream Blob ( int test Id , byte [ ] base Content , int required Size ) throws  SQLException { final byte [ ] test Bytes = generate Blob Content ( base Content , required Size ) ; try (  Fb Database db = create Database Connection ( ) ) { listener = new  Simple Statement Listener ( ) ; transaction = get Transaction ( db ) ; try { statement = db . create Statement ( transaction ) ; statement . add Statement Listener ( listener ) ; final  Blob Parameter Buffer blob Parameter Buffer = db . create Blob Parameter Buffer ( ) ; blob Parameter Buffer . add Argument (  Blob Parameter Buffer .  TYPE ,  Blob Parameter Buffer .  TYPE_ STREAM ) ; final  Fb Blob blob = db . create Blob For Output ( transaction , blob Parameter Buffer ) ; blob . open ( ) ; int bytes Written = _ NUM ; while ( bytes Written < test Bytes . length ) { byte [ ] buffer = new byte [  Math . min ( blob . get Maximum Segment Size ( ) , test Bytes . length - bytes Written ) ] ;  System . arraycopy ( test Bytes , bytes Written , buffer , _ NUM , buffer . length ) ; blob . put Segment ( buffer ) ; bytes Written += buffer . length ; } blob . close ( ) ; statement . prepare (  INSERT_ BLOB_ TABLE ) ; final  Datatype Coder datatype Coder = db . get Datatype Coder ( ) ;  Field Value param1 = new  Field Value ( datatype Coder . encode Int ( test Id ) ) ;  Field Value param2 = new  Field Value ( datatype Coder . encode Long ( blob . get Blob Id ( ) ) ) ; statement . execute (  Row Value . of ( param1 , param2 ) ) ; statement . close ( ) ; } finally { transaction . commit ( ) ; } } }
private static long sign From Bit_anti Cyclic ( final double value ) { return  Double . double To Raw Long Bits ( value ) > > _ NUM | _ NUM ; }
public void add Near Key (  Key Cache Object key ,  Grid Cache Shared Context ctx ) throws  Ignite Checked Exception { near Keys . add ( key ) ; }
private void analyze Class Fields (  String class Name , int action ) { try {  Class < ? > dynamic Class =  Class . for Name ( class Name ) ;  Field [ ] fields = dynamic Class . get Declared Fields ( ) ; for (  Field field : fields ) { if ( is Private And Non Primitive ( field ) ) { one To Any Conditions ( class Name , field , action ) ; many To Any Conditions ( class Name , field , action ) ; } } } catch (  Class Not Found Exception ex ) { ex . print Stack Trace ( ) ; throw new  Database Generate Exception (  Database Generate Exception .  CLASS_ NOT_ FOUND + class Name ) ; } }
public static void load All ( final  JFrame parent , final  IDebugger debugger , final  IAddress offset , final int size ) { check Arguments ( parent , debugger , offset ) ; final  CDump All Waiter waiter = new  CDump All Waiter ( debugger , offset , size ) ;  CProgress Dialog . show Endless ( parent , _ STR + _ STR , waiter ) ; if ( waiter . get Exception ( ) != null ) {  CUtility Functions . log Exception ( waiter . get Exception ( ) ) ; final  String inner Message = _ STR + _ STR ; final  String inner Description =  CUtility Functions . create Description (  String . format ( _ STR , offset . to Hex String ( ) ) , new  String [ ] { _ STR } , new  String [ ] { _ STR } ) ;  Navi Error Dialog . show ( parent , inner Message , inner Description , waiter . get Exception ( ) ) ; } }
public static boolean delete Directory (  String directory , boolean use OSNative Delete ) throws  IOException { boolean result = _ BOOL ; if ( ! use OSNative Delete ) {  File dir = new  File ( directory ) ; for (  File file : dir . list Files ( ) ) { if ( file . delete ( ) ) { log . debug ( _ STR , file . get Name ( ) ) ; } else { log . debug ( _ STR , file . get Name ( ) ) ; file . delete On Exit ( ) ; } file = null ; } if ( dir . delete ( ) ) { log . debug ( _ STR ) ; result = _ BOOL ; } else { log . debug ( _ STR ) ; dir . delete On Exit ( ) ; } dir = null ; } else {  Process p = null ;  Thread std = null ; try {  Runtime run Time =  Runtime . get Runtime ( ) ; log . debug ( _ STR ) ; if (  File . separator Char == _ STR ) { p = run Time . exec ( _ STR + directory . replace ( _ STR , _ STR ) + _ STR ) ; } else { p = run Time . exec ( _ STR + directory . replace ( _ STR ,  File . separator Char ) ) ; } std = std Out ( p ) ; while ( std . is Alive ( ) ) { try {  Thread . sleep ( _ NUM ) ; } catch (  Exception e ) { } } log . debug ( _ STR ) ; result = _ BOOL ; } catch (  Exception e ) { log . error ( _ STR , e ) ; } finally { if ( null != p ) { log . debug ( _ STR ) ; p . destroy ( ) ; p = null ; } std = null ; } } return result ; }
public static  String find Edit Table (  String tables ) { if ( !  String Utils . is Empty ( tables ) ) { int spacepos = tables . index Of ( _ STR ) ; int commapos = tables . index Of ( _ STR ) ; if ( spacepos > _ NUM && ( spacepos < commapos || commapos < _ NUM ) ) { return tables . substring ( _ NUM , spacepos ) ; } else if ( commapos > _ NUM && ( commapos < spacepos || spacepos < _ NUM ) ) { return tables . substring ( _ NUM , commapos ) ; } return tables ; } else { throw new  Illegal State Exception ( _ STR ) ; } }
public void write Operations Car File ( ) { make Backup File ( default Operations Filename ( ) ) ; try { if ( ! check File ( default Operations Filename ( ) ) ) { java . io .  File file = new java . io .  File ( default Operations Filename ( ) ) ; java . io .  File parent Dir = file . get Parent File ( ) ; if ( ! parent Dir . exists ( ) ) { if ( ! parent Dir . mkdir ( ) ) { log . error ( _ STR ) ; } } if ( file . create New File ( ) ) { log . debug ( _ STR ) ; } } write File ( default Operations Filename ( ) ) ; } catch (  Exception e ) { log . error ( _ STR + e ) ; } }
private boolean has New Followers (  List <  Follower > followers ) { return ! followers . is Empty ( ) && followers . get ( _ NUM ) . new Follower ; }
private void on Track Point Element Start (  Attributes attributes ) throws  SAXException {  String latitude = attributes . get Value (  ATT_ LAT ) ;  String longitude = attributes . get Value (  ATT_ LON ) ; if ( latitude == null || longitude == null ) { throw new  SAXException ( create Error Message ( _ STR ) ) ; } try { latitude Value =  Double . parse Double ( latitude ) ; longitude Value =  Double . parse Double ( longitude ) ; } catch (  Number Format Exception e ) { throw new  SAXException ( create Error Message ( _ STR + latitude + _ STR + longitude ) , e ) ; } }
protected final void fire Property Change (  Property Change Event evt ) { pcs . fire Property Change ( evt ) ; }
public static void sort Fields (  Field Binding [ ] sorted Fields , int left , int right ) {  Arrays . sort ( sorted Fields , left , right ,  FIELD_ COMPARATOR ) ; }
private void draw Background ( final  Graphics g ) { g . set Color ( m_bg Color Offset ) ; g . fill Rect ( - m_first Column * m_char Width , _ NUM , m_offset View Width , get Height ( ) ) ; }
public void add Unique Attribute ( final  String element Name , final  String attr Name ) { if ( ( element Name != null ) && ( attr Name != null ) ) { _unique Element Attr Map . put ( element Name , attr Name ) ; } }
private static  Delete Vm Response check Delete Vm Response (  Delete Vm Response delete Vm Response ) throws  Rpc Exception { logger . info ( _ STR , delete Vm Response ) ; switch ( delete Vm Response . get Result ( ) ) { case  OK : break ; case  SYSTEM_ ERROR : throw new  System Error Exception ( delete Vm Response . get Error ( ) ) ; case  VM_ NOT_ FOUND : throw new  Vm Not Found Exception ( delete Vm Response . get Error ( ) ) ; case  VM_ NOT_ POWERED_ OFF : throw new  Vm Not Powered Off Exception ( delete Vm Response . get Error ( ) ) ; default : throw new  Rpc Exception (  String . format ( _ STR , delete Vm Response . get Result ( ) ) ) ; } return delete Vm Response ; }
public  Blaze Value Factory value Factory ( ) { return vf ; }
public  Stateful Refresh Token (  Json Value token ) throws  Invalid Grant Exception { super ( token ) ; if ( !  OAUTH_ REFRESH_ TOKEN . equals ( get Token Name ( ) ) ) { throw new  Invalid Grant Exception ( _ STR + get Token Id ( ) ) ; } }
public void put Style (  String style Id ,  Style Selector style Selector ) { try { int id =  Integer . parse Int ( style Id ) ; m Max Style Id =  Math . max ( m Max Style Id , id ) ; } catch (  Number Format Exception e ) { } m Styles . put ( style Id , style Selector ) ; }
private static  String extract Client Name (  String client Id ,  String host ) {  String host Excluded Id = _ STR ; if ( ( is IPv6 ( host ) || is IPv4 ( host ) ) && client Id . starts With ( host ) ) { host Excluded Id = client Id . substring ( host . length ( ) ) ; } else { int first Dot Index = host . index Of ( _ STR ) ; if ( first Dot Index != - _ NUM ) {  String host Short Name = host . substring ( _ NUM , first Dot Index ) ; host Excluded Id = client Id . substring ( host Short Name . length ( ) ) ; } }  String vm PIDAnd Kind Regex = _ STR ;  String regex = _ STR ;  String name =  NOT_ AVAILABLE ;  String temp = host Excluded Id ; int open Index = temp . index Of ( _ STR ) ; if ( open Index != - _ NUM ) { regex = vm PIDAnd Kind Regex + regex ; } if ( temp . matches ( regex ) ) {  String [ ] splitted = temp . split ( _ STR ) ; name = splitted [ splitted . length - _ NUM ] ; } return name ; }
public static <  T >  Fast Future <  T > from Completable Future ( final  Completable Future <  T > cf ) { final  Fast Future <  T > f = new  Fast Future < > ( ) ; cf . then Accept ( null ) ; cf . exceptionally ( null ) ; return f ; }
public static boolean is Place Action (  Inventory Action action ) { switch ( action ) { case  SWAP_ WITH_ CURSOR : case  PLACE_ ONE : case  PLACE_ ALL : case  PLACE_ SOME : return _ BOOL ; } return _ BOOL ; }
public static byte [ ] read Input Stream (  Input Stream i ) throws  IOException {  Byte Array Output Stream b = new  Byte Array Output Stream ( ) ; copy ( i , b ) ; return b . to Byte Array ( ) ; }
public void play Media ( boolean show Player Window ) {  String filename = stop And Prepare Filename ( ) ; if ( filename . length ( ) > _ NUM ) {  MPlayer Mediator mplayer Mediator =  MPlayer Mediator . instance ( ) ; if ( mplayer Mediator != null ) { mplayer Mediator . show Player Window ( show Player Window ) ; } mplayer . open ( filename , get Adjusted Volume ( ) ) ; } notify State ( get State ( ) ) ; }
public static  String to UTF8 String (  String s ) { return new  String ( s . get Bytes ( ) ,  Charset . for Name (  Panbox Constants .  STANDARD_ CHARSET ) ) ; }
public static int encode Cache Flags (  Collection <  Grid Client Cache Flag > flag Set ) { int bits = _ NUM ; if ( flag Set . contains (  Grid Client Cache Flag .  SKIP_ STORE ) ) bits |= _ NUM ; return bits ; }
public void add (  Data Source source , boolean visible ) { add ( data . size ( ) , source , visible ) ; }
@  Override public void add Value ( double value , double weight ) { m_ Weighted Sum += value * weight ; m_ Weighted Sum Squared += value * value * weight ; m_ Sum Of Weights += weight ; if ( m_ TM . get ( value ) == null ) { m_ TM . put ( value , weight ) ; } else { m_ TM . put ( value , m_ TM . get ( value ) + weight ) ; } }
private static synchronized  String format And Parse (  Simple Date Format format Date ,  Simple Date Format parse Date ,  String text ) { try {  Date date = parse Date . parse ( text ) ;  String result = format Date . format ( date ) ; return result ; } catch (  Parse Exception e ) { logger . warning ( _ STR + text ) ; } return _ STR ; }
private void throw Array Index Out Of Bounds Exception ( int item Index ) { throw new  Array Index Out Of Bounds Exception ( _ STR + _ STR + space Items . size ( ) + _ STR + item Index ) ; }
private  Locus Info create Next Uncovered Locus Info ( final  Locus stop Before Locus ) { while ( last Reference Sequence <= stop Before Locus . get Sequence Index ( ) && last Reference Sequence <= reference Sequence Mask . get Max Sequence Index ( ) ) { if ( last Reference Sequence == stop Before Locus . get Sequence Index ( ) && last Position + _ NUM >= stop Before Locus . get Position ( ) ) { return null ; } final int nextbit = reference Sequence Mask . next Position ( last Reference Sequence , last Position ) ; if ( nextbit == - _ NUM ) { if ( last Reference Sequence == stop Before Locus . get Sequence Index ( ) ) { last Position = stop Before Locus . get Position ( ) ; return null ; } last Reference Sequence ++ ; last Position = _ NUM ; } else if ( last Reference Sequence < stop Before Locus . get Sequence Index ( ) || nextbit < stop Before Locus . get Position ( ) ) { last Position = nextbit ; return new  Locus Info ( get Reference Sequence ( last Reference Sequence ) , last Position ) ; } else if ( nextbit >= stop Before Locus . get Position ( ) ) { return null ; } } return null ; }
public void global Config Changed (  String service Name ,  String version ,  String group Name ,  String service Component , int change Type ) { }
public static void launch Email Intent ( final  Activity activity ,  String addr ,  String text ) {  Log . i (  LOG_ TAG , _ STR + activity . get Local Class Name ( ) ) ;  Intent email Intent = new  Intent (  Intent .  ACTION_ SEND ) ; email Intent . put Extra (  Intent .  EXTRA_ EMAIL , new  String [ ] { addr } ) ; email Intent . set Type ( _ STR ) ;  Package Manager emailpackage Manager = activity . get Package Manager ( ) ;  List <  Resolve Info > emailresolve Infos = emailpackage Manager . query Intent Activities ( email Intent , _ NUM ) ; if ( emailresolve Infos . size ( ) > _ NUM ) { activity . start Activity ( email Intent ) ; } }
public int count ( ) { return n ; }
public void write LEChars (  String s ) throws  IOException { int length = s . length ( ) ; for ( int i = _ NUM ; i < length ; i ++ ) { int c = s . char At ( i ) ; out . write ( c & _ NUM ) ; out . write ( ( c > > > _ NUM ) & _ NUM ) ; } written += length * _ NUM ; }
public void write To File (  String filename ) {  Grid Utils . write Spatial Grid Table ( this , filename ) ; }
public void add Footer View (  View v ,  Object data , boolean is Selectable ) {  Fixed View Info info = new  Fixed View Info ( ) ; info . view = v ; info . data = data ; info . is Selectable = is Selectable ; m Footer View Infos . add ( info ) ; if ( m Adapter != null && m Data Set Observer != null ) { m Data Set Observer . on Changed ( ) ; } }
public void read Config (  String filename ) throws  File Not Found Exception { if ( filename == null || filename . equals ( _ STR ) ) return ; read Config ( new  File Reader ( filename ) ) ; }
private void apply Trading Bonus (  Player player ) { player . increment Tradescore ( ) ; }
private static void create Combined Trace ( final  Trace List new Trace , final  List <  Trace List > traces , final  Set <  Breakpoint Address > addresses ) { final  Set <  Breakpoint Address > visited Addresses = new  Linked Hash Set <  Breakpoint Address > ( ) ; for ( final  Trace List trace : traces ) { for ( final  ITrace Event event : trace ) { final  Breakpoint Address address = event . get Offset ( ) ; if ( ! addresses . contains ( address ) ) { continue ; } if ( visited Addresses . contains ( address ) ) { continue ; } visited Addresses . add ( address ) ; new Trace . add Event ( event ) ; } } }
public void interrupt All ( ) { synchronized ( known Actor Tasks ) { for (  Future <  Void > ft : known Actor Tasks ) { ft . cancel ( _ BOOL ) ; } thread Guard . interrupt All ( ) ; } }
@  Suppress Warnings ( _ STR ) public void register Default Device Types ( ) { final  Hash Map <  String ,  String > devices List =  Default Platform . get Device Service Map ( ) ; for (  Hash Map .  Entry <  String ,  String > entry : devices List . entry Set ( ) ) {  String key = entry . get Key ( ) ;  String value = entry . get Value ( ) ; try { register Device Service ( (  Class <  Device Service > )  Class . for Name ( key ) , (  Class <  Discovery Provider > )  Class . for Name ( value ) ) ; } catch (  Class Not Found Exception e ) { e . print Stack Trace ( ) ; } } }
private static void remove Dependency Subsets (  String swc Location ,  Map <  String ,  Set <  String > > dependency Map ,  Swc Dependency Info Impl dep Info ) {  Set <  String > remove Set = new  Hash Set <  String > ( ) ;  Swc External Script Info external Info = dep Info . get Swc External Script Info ( swc Location ) ;  Map <  String ,  Set <  String > > externals By Swc = new  Hash Map <  String ,  Set <  String > > ( ) ; for (  String swc Depend Location : dependency Map . get ( swc Location ) ) { for (  String swc Depend Location2 : dependency Map . get ( swc Location ) ) { if ( swc Depend Location . equals ( swc Depend Location2 ) ) continue ;  Set <  String > external Scripts = externals By Swc . get ( swc Depend Location ) ;  Set <  String > external Scripts2 = externals By Swc . get ( swc Depend Location2 ) ; if ( external Scripts == null ) { external Scripts = external Info . get External Scripts ( swc Depend Location ) ; externals By Swc . put ( swc Depend Location , external Scripts ) ; } if ( external Scripts2 == null ) { external Scripts2 = external Info . get External Scripts ( swc Depend Location2 ) ; externals By Swc . put ( swc Depend Location2 , external Scripts2 ) ; } if ( external Scripts2 . size ( ) > external Scripts . size ( ) && external Scripts2 . contains All ( external Scripts ) ) { remove Set . add ( swc Depend Location ) ; break ; } } }  Set <  String > dependency Set = dependency Map . get ( swc Location ) ; dependency Set . remove All ( remove Set ) ; }
public void test Find Spring Open Ldap ( ) {  Ldap Proxy proxy = get Ldap Open Ldap ( ) ;  List result = null ; try { result = proxy . find ( get Ldap Search VO ( _ STR ,  Ldap Constants .  NO_ SEARCH_ LIMIT , null , null , null ,  Ldap Scope Constants .  SCOPE_ SUBTREE ) ) ; } catch (  Exception e ) { } assert Not Null ( result ) ; assert Equals ( _ NUM , result . size ( ) ) ; }
public void delete (  SSOToken token ,  String dn ) throws  SMSException ,  SSOException { for (  String entry : sub Entries ( token , dn , _ STR , _ NUM , _ BOOL , _ BOOL ) ) { debug . message ( _ STR , entry ) ; delete ( token , get Naming Attribute ( ) + _ STR + entry + _ STR + dn ) ; } for (  String sub Org : search Sub Org Names ( token , dn , _ STR , _ NUM , _ BOOL , _ BOOL , _ BOOL ) ) { debug . message ( _ STR , sub Org ) ; delete ( token , sub Org ) ; } delete ( token . get Principal ( ) , dn ) ; object Changed ( dn ,  DELETE ) ; }
private static <  T extends  Abstract Block Base <  T > > void enqueue Successors (  T block ,  Priority Queue <  T > worklist ,  Bit Set visited Blocks ) { for (  T successor : block . get Successors ( ) ) { if ( ! visited Blocks . get ( successor . get Id ( ) ) ) { visited Blocks . set ( successor . get Id ( ) ) ; worklist . add ( successor ) ; } } }
public void add Role (  String role ) { if ( role != null ) { roles . add ( role ) ; } }
public  CModules Check Box Panel ( final  CModules Table Model modules Table Model ) { super ( new  Border Layout ( ) ) ; final  JCheck Box check Box = new  JCheck Box ( _ STR ) ; check Box . add Item Listener ( new  Internal Checkbox Listener ( ) ) ; add ( check Box ) ; m_modules Table Model = modules Table Model ; }
public  QDate ( ) { this ( _gmt Time Zone ) ; }
protected void response Sent (  Stream Response Message response Message ) { if ( sync Protocol != null ) sync Protocol . response Sent ( response Message ) ; }
protected  Tuple <  Blob Store Index Shard Snapshots ,  Integer > build Blob Store Index Shard Snapshots (  Map <  String ,  Blob Meta Data > blobs ) { int latest = - _ NUM ; for (  String name : blobs . key Set ( ) ) { if ( name . starts With (  SNAPSHOT_ INDEX_ PREFIX ) ) { try { int gen =  Integer . parse Int ( name . substring (  SNAPSHOT_ INDEX_ PREFIX . length ( ) ) ) ; if ( gen > latest ) { latest = gen ; } } catch (  Number Format Exception ex ) { logger . warn ( _ STR , name ) ; } } } if ( latest >= _ NUM ) { try { return new  Tuple < > ( index Shard Snapshots Format . read ( blob Container ,  Integer . to String ( latest ) ) , latest ) ; } catch (  IOException e ) { logger . warn ( _ STR , e ,  SNAPSHOT_ INDEX_ PREFIX + latest ) ; } }  List <  Snapshot Files > snapshots = new  Array List < > ( ) ; for (  String name : blobs . key Set ( ) ) { try {  Blob Store Index Shard Snapshot snapshot = null ; if ( name . starts With (  SNAPSHOT_ PREFIX ) ) { snapshot = index Shard Snapshot Format . read Blob ( blob Container , name ) ; } else if ( name . starts With (  LEGACY_ SNAPSHOT_ PREFIX ) ) { snapshot = index Shard Snapshot Legacy Format . read Blob ( blob Container , name ) ; } if ( snapshot != null ) { snapshots . add ( new  Snapshot Files ( snapshot . snapshot ( ) , snapshot . index Files ( ) ) ) ; } } catch (  IOException e ) { logger . warn ( _ STR , e , name ) ; } } return new  Tuple < > ( new  Blob Store Index Shard Snapshots ( snapshots ) , - _ NUM ) ; }
protected  Maple Quest Requirement (  Maple Quest quest ,  Read Bin data ) throws  IOException { this . quest = quest ; this . day By Day = data . read Byte ( ) > _ NUM ; this . normal Auto Start = data . read Byte ( ) > _ NUM ; this . lvmin = data . read Short ( ) ; this . lvmax = data . read Short ( ) ; this . mbmin = data . read Short ( ) ; this . charisma Min = data . read Short ( ) ; this . charm Min = data . read Short ( ) ; this . craft Min = data . read Short ( ) ; this . insight Min = data . read Short ( ) ; this . sense Min = data . read Short ( ) ; this . will Min = data . read Short ( ) ; this . pop = data . read Short ( ) ; this . pettamenessmin = data . read Short ( ) ; this . sub Job Flag = data . read Short ( ) ; this . npc = data . read Int ( ) ; this . interval = data . read Int ( ) ; this . end = data . read String ( ) ; this . startscript = data . read String ( ) ; this . endscript = data . read String ( ) ; short size = data . read Short ( ) ; for ( int i = _ NUM ; i < size ; i ++ ) { int field = data . read Int ( ) ; field Enter . add ( field ) ; } size = data . read Short ( ) ; for ( int i = _ NUM ; i < size ; i ++ ) { short job = data . read Short ( ) ; jobs . add ( job ) ; } size = data . read Short ( ) ; for ( int i = _ NUM ; i < size ; i ++ ) { int id = data . read Int ( ) ; boolean acquire = data . read Byte ( ) > _ NUM ; skills . put ( id , acquire ) ; } size = data . read Short ( ) ; for ( int i = _ NUM ; i < size ; i ++ ) { int id = data . read Int ( ) ; byte state = data . read Byte ( ) ; byte order = data . read Byte ( ) ; quests . put ( id , state ) ; } size = data . read Short ( ) ; for ( int i = _ NUM ; i < size ; i ++ ) { int id = data . read Int ( ) ; int count = data . read Int ( ) ; byte order = data . read Byte ( ) ; items . put ( id , count ) ; } size = data . read Short ( ) ; for ( int i = _ NUM ; i < size ; i ++ ) { int id = data . read Int ( ) ; int count = data . read Int ( ) ; mobs . put ( id , count ) ; } size = data . read Short ( ) ; for ( int i = _ NUM ; i < size ; i ++ ) { int id = data . read Int ( ) ; pets . add ( id ) ; } }
public boolean is Armed ( ) { return other . is Armed ( ) ; }
public static  Attrib Key for Html Attrib (  El Key el ,  String local Name ) { return new  Attrib Key ( el ,  HTML_ NS , local Name ) ; }
Sparse Array (  Class <  L > linear Array Type , int [ ] row Indices , int [ ] col Indices ,  L real Values ,  L imag Values , int num Rows , int num Cols ) { validate User Supplied Parameters ( linear Array Type , row Indices , col Indices , real Values , imag Values ) ; _base Component Type = linear Array Type . get Component Type ( ) ; _output Array Type = (  Class <  L [ ] > )  Array Utils . get Array Class ( _base Component Type , _ NUM ) ;  Map <  Sparse Key ,  Sparse Value > sparse Map = create Sparse Map ( linear Array Type , row Indices , col Indices , real Values , imag Values , num Rows , num Cols ) ; _num Rows = num Rows ; _num Cols = num Cols ;  Array List <  Sparse Key > keys = new  Array List <  Sparse Key > ( sparse Map . key Set ( ) ) ;  Collections . sort ( keys ) ; _row Indices = new int [ keys . size ( ) ] ; _col Indices = new int [ keys . size ( ) ] ; _linear Indices = new int [ keys . size ( ) ] ; _real Values = linear Array Type . cast (  Array . new Instance ( _base Component Type , keys . size ( ) ) ) ; _imag Values = imag Values == null ? null : linear Array Type . cast (  Array . new Instance ( _base Component Type , keys . size ( ) ) ) ; for ( int i = _ NUM ; i < keys . size ( ) ; i ++ ) {  Sparse Key key = keys . get ( i ) ; _row Indices [ i ] = key . row ; _col Indices [ i ] = key . col ; _linear Indices [ i ] = key . linear Index ;  Sparse Value value = sparse Map . get ( key ) ; set Sparse Value ( value , _real Values , _imag Values , i ) ; } }
protected void update Radio Links ( ) { m_ CVBut . set Enabled ( _ BOOL ) ; m_ CVText . set Enabled ( m_ CVBut . is Selected ( ) ) ; m_ CVLab . set Enabled ( m_ CVBut . is Selected ( ) ) ; m_ Seed Text . set Enabled ( m_ CVBut . is Selected ( ) ) ; m_ Seed Lab . set Enabled ( m_ CVBut . is Selected ( ) ) ; if ( m_ Attribute Evaluator Editor . get Value ( ) instanceof  Attribute Transformer ) { m_ CVBut . set Selected ( _ BOOL ) ; m_ CVBut . set Enabled ( _ BOOL ) ; m_ CVText . set Enabled ( _ BOOL ) ; m_ CVLab . set Enabled ( _ BOOL ) ; m_ Seed Text . set Enabled ( _ BOOL ) ; m_ Seed Lab . set Enabled ( _ BOOL ) ; m_ Train But . set Selected ( _ BOOL ) ; } }
private  String id String ( int id1 , int id2 ) { return _ STR +  Integer . to Hex String ( id2 & _ NUM ) + _ STR +  Integer . to Hex String ( id1 & _ NUM ) + _ STR + ( ( id2 & _ NUM ) * _ NUM + ( id1 & _ NUM ) ) + _ STR ; }
public  Etag Cache reset Stats ( ) { hits . set ( _ NUM ) ; misses . set ( _ NUM ) ; return this ; }
public void test Other To String Default ( ) {  Number Converter converter = make Converter ( ) ; assert Equals ( _ STR , _ STR , converter . convert (  String . class , new  String Buffer ( _ STR ) ) ) ; }
private void show Filter Dialog (  Filter filter ) { int sort Order = m Adapter . get Count ( ) - _ NUM ; if ( filter == null ) {  Edit Filter Activity . create New Filter ( get Activity ( ) , sort Order ) ; } else {  Edit Filter Activity . edit Filter ( get Activity ( ) , filter , sort Order ) ; } }
public static int num Pixels Between ( int x1 , int y1 , int x2 , int y2 ) { return ( int )  Math . sqrt (  Math . pow ( ( double ) ( x1 - x2 ) , _ NUM ) +  Math . pow ( ( double ) ( y1 - y2 ) , _ NUM ) ) ; }
static boolean allows Popup (  Form Object form Object ) { switch ( form Object . get Parameter Constant (  Pdf Dictionary .  Subtype ) ) { case  Pdf Dictionary .  Text : case  Pdf Dictionary .  Square : case  Pdf Dictionary .  Highlight : case  Pdf Dictionary .  Underline : case  Pdf Dictionary .  Strick Out : case  Pdf Dictionary .  Stamp : return _ BOOL ; default : return _ BOOL ; } }
public static  Local Git Repo from Current Dir (  String remote Url ) throws  Validation Exception {  Git git ;  File git Dir = new  File ( _ STR ) ; try { git =  Git . open ( git Dir ) ; } catch (  Repository Not Found Exception rnfe ) {  String full Path Of Current Dir = path Of ( git Dir ) ;  File git Root = get Git Root If It Exists In One Of The Parent Directories ( new  File ( full Path Of Current Dir ) ) ;  String summary ;  List <  String > messages = new  Array List <  String > ( ) ; if ( git Root == null ) { summary = _ STR ; messages . add ( summary ) ; messages . add ( full Path Of Current Dir + _ STR ) ; } else { summary = _ STR ; messages . add ( summary ) ; messages . add ( full Path Of Current Dir + _ STR ) ; messages . add ( _ STR + path Of ( git Root ) ) ; } throw new  Validation Exception ( summary , messages ) ; } catch (  Exception e ) { throw new  Validation Exception ( _ STR + path Of ( git Dir ) + _ STR ,  Arrays . as List ( _ STR , e . to String ( ) ) ) ; } return new  Local Git Repo ( git , remote Url ) ; }
public static  Vector2 min (  Vector2 o1 ,  Vector2 o2 ) { return new  Vector2 (  Math . min ( o1 . x , o2 . x ) ,  Math . min ( o1 . z , o2 . z ) ) ; }
public void add Test Call (  Generic Accessible Object < ? > call ) throws  Illegal Argument Exception {  Inputs . check Null ( call ) ; test Methods . add ( call ) ; }
public void serialize (  KXml Serializer serializer ) throws  IOException { m Device Info . serialize ( serializer ) ; serialize Host Info ( serializer ) ; serialize Test Summary ( serializer ) ; monkey Tag . serialize ( serializer ) ;  List <  Test Package Result > pkgs = new  Array List <  Test Package Result > ( m Package Map . values ( ) ) ;  Collections . sort ( pkgs , new  Pkg Comparator ( ) ) ; for (  Test Package Result r : pkgs ) { r . serialize ( serializer ) ; } }
private void verify Block Mirror Migration ( ) throws  Exception { log . info ( _ STR ) ;  Iterator <  Block Mirror > block Mirror Itr = _db Client . query Iterative Objects (  Block Mirror . class , block Mirror URIs ) ;  List <  Block Object > block Objects = new  Array List <  Block Object > ( ) ; while ( block Mirror Itr . has Next ( ) ) { block Objects . add ( block Mirror Itr . next ( ) ) ; } verify Block Objects ( block Objects ) ; }
public  Log Formatter (  Logger log ) { if ( log == null ) log =  Logger . get Logger (  Logger .  GLOBAL_ LOGGER_ NAME ) ;  Level lvl = null ; while ( log != null ) { lvl = log . get Level ( ) ; if ( lvl != null ) break ; log = log . get Parent ( ) ; } ; if ( lvl == null ) lvl =  Level .  WARNING ; this . level = lvl ; }
private  Element create IDPEntity Descriptor ( boolean export Private Data ) throws  Exception {  Element ent Ele = doc . create Element NS ( null ,  SAMLNames .  ENTDESCRIPTOR ) ;  String id = idm Client . get Entity ID ( tenant Name ) ;  String alias = idm Client . get Local IDPAlias ( tenant Name ) ; if ( id == null ) { id = tenant Name ; } ent Ele . set Attribute (  SAMLNames .  ENTID , id ) ;  Element idp SSO = create IDPSSODescriptor ( export Private Data ) ; ent Ele . append Child ( idp SSO ) ; if ( export Private Data ) { if ( alias == null || alias . is Empty ( ) ) { alias = id ; }  Element org Ele = create Organization ( tenant Name , tenant Name , alias ,  SAMLNames .  ENGLISH ) ; ent Ele . append Child ( org Ele ) ; } return ent Ele ; }
public void clear ( ) { info Queue . clear ( ) ; while ( ! data Queue . is Empty ( ) ) { allocator . release ( data Queue . remove ( ) ) ; } total Bytes Dropped = _ NUM ; total Bytes Written = _ NUM ; last Allocation = null ; last Allocation Offset = allocation Length ; }
public void apply Camera (  GL2 gl ) { gl . gl Matrix Mode (  GL2 .  GL_ PROJECTION ) ; gl . gl Load Identity ( ) ; glu . glu Perspective ( _ NUM , width / ( float ) height , _ NUM , _ NUM ) ; eye [ _ NUM ] = ( float )  Math . sin ( theta ) * _ NUM ; eye [ _ NUM ] = _ NUM ; eye [ _ NUM ] = ( float )  Math . cos ( theta ) * _ NUM ; glu . glu Look At ( eye [ _ NUM ] , eye [ _ NUM ] , eye [ _ NUM ] , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM ) ; gl . gl Matrix Mode (  GL2 .  GL_ MODELVIEW ) ; gl . gl Load Identity ( ) ; gl . gl Viewport ( _ NUM , _ NUM , width , height ) ; }
public static  Result Set point Table ( double x , double y ) {  Geometry Factory factory = new  Geometry Factory ( ) ;  Simple Result Set rs = new  Simple Result Set ( ) ; rs . add Column ( _ STR ,  Types .  JAVA_ OBJECT , _ STR , _ NUM , _ NUM ) ; rs . add Row ( factory . create Point ( new  Coordinate ( x , y ) ) ) ; return rs ; }
public void add To Existing Volumes If Absent (  Map <  String ,  Integer > volume WWNs ) { if ( _existing Volumes == null ) { _existing Volumes = new  String Map ( ) ; } for (  String wwn : volume WWNs . key Set ( ) ) {  String normalized WWN =  Block Object . normalize WWN ( wwn ) ; if ( ! _existing Volumes . contains Key ( normalized WWN ) && ( _user Added Volumes == null || ! _user Added Volumes . contains Key ( normalized WWN ) ) ) {  String hlu Str =  Export Group .  LUN_ UNASSIGNED_ STR ;  Integer hlu = volume WWNs . get ( normalized WWN ) ; if ( hlu != null ) { hlu Str = hlu . to String ( ) ; } _existing Volumes . put ( normalized WWN , hlu Str ) ; } } }
public  Path Impl create Temp File (  String prefix ,  String suffix ) throws  IOException { if ( prefix == null || prefix . length ( ) == _ NUM ) prefix = _ STR ; if ( suffix == null ) suffix = _ STR ; synchronized (  LOCK ) { for ( int i = _ NUM ; i < _ NUM ; i ++ ) { int r =  Math . abs ( ( int )  Random Util . get Random Long ( ) ) ;  Path Impl file = lookup ( prefix + r + suffix ) ; if ( file . create New File ( ) ) return file ; } } throw new  IOException ( _ STR ) ; }
static  Map <  Target Type ,  List <  Type Compound > > partition By Target Type (  Collection <  Type Compound > annos ,  List <  Type Compound > unmatched ,  Target Type ... target Types ) { final  Map <  Target Type ,  List <  Type Compound > > target Type To Annos = new  Hash Map < > ( ) ; for (  Target Type target Type : target Types ) { target Type To Annos . put ( target Type , new  Array List <  Type Compound > ( _ NUM ) ) ; } for ( final  Type Compound anno : annos ) { final  List <  Type Compound > anno Set = target Type To Annos . get ( anno . get Position ( ) . type ) ; if ( anno Set != null ) { anno Set . add ( anno ) ; } else if ( unmatched != null ) { unmatched . add ( anno ) ; } } return target Type To Annos ; }
public void load ( ) { try { if ( file Channel == null ) { file Channel =  File Channel . open ( path ,  Standard Open Option .  READ ) ; } file Channel . position ( _ NUM ) ; buffer . clear ( ) ; tmp . clear ( ) ; while ( file Channel . read ( tmp ) > _ NUM ) { tmp . flip ( ) ; if ( tmp . remaining ( ) > buffer . capacity ( ) - buffer . position ( ) ) { final  Byte Buffer next =  Byte Buffer . allocate Direct (  Math . max ( buffer . capacity ( ) * _ NUM , tmp . remaining ( ) ) ) ; buffer . flip ( ) ; next . put ( buffer ) ; buffer = next ; } buffer . put ( tmp ) ; tmp . clear ( ) ; } buffer . flip ( ) ; } catch ( final  IOException e ) { throw new  Unchecked IOException ( e ) ; } }
private void on HPChange ( final int amount ) { if (  User . squared Distance To ( x , y ) <  HEARING_ DISTANCE_ SQ ) { if ( amount > _ NUM ) { add Text Indicator ( _ STR + amount ,  Notification Type .  POSITIVE ) ; } else { add Text Indicator (  String . value Of ( amount ) ,  Notification Type .  NEGATIVE ) ; } } }
@  Not Null private  File resolve Name ( @  Not Null  String name ) throws  IOException {  File file ; if ( name . starts With (  ROOT ) ) { file = new  File ( my Template Root Folder , name . substring (  ROOT . length ( ) ) ) ; } else if ( my Last Template Folders != null ) { file = new  File ( my Last Template Folders . peek ( ) , name ) ; } else { file = new  File ( my Template Root Folder , name ) ; } return file . get Canonical File ( ) ; }
public void init Tool Tip ( ) { if ( ttmanager == null ) { ttmanager =  Tool Tip Manager . shared Instance ( ) ; ttmanager . register Component ( map ) ; ttmanager . set Enabled ( _ BOOL ) ; return ; } if ( map != null ) { map . set Tool Tip Text ( null ) ; } }
public static  String [ ] decode Array (  String encoded Array ) {  String [ ] items = encoded Array . split ( _ STR ) ;  Array List <  String > list = new  Array List <  String > ( ) ; for ( int i = _ NUM ; i < items . length ; i ++ ) {  String item = items [ i ] ; item = gsub ( _ STR , _ STR , item ) ; if ( ! item . equals ( _ STR ) ) { list . add ( item ) ; } } return list . to Array ( new  String [ list . size ( ) ] ) ; }
private void send Resource ( final  UUID uuid , final  Object resource , final long length , final  Input Stream is ) throws  IOException { assert uuid != null ; assert resource != null ; assert length >= _ NUM ; assert is != null ; assert ! sent Status ; long bytes Written = _ NUM ; final long begin =  System . nano Time ( ) ; final  Output Stream os = s . get Output Stream ( ) ; try { { final  Data Output Stream dos = new  Data Output Stream ( os ) ; dos . write ( new byte [ ] {  Status Enum .  OK . get ( ) } ) ; dos . write Long ( length ) ; dos . flush ( ) ; bytes Written += _ NUM +  Bytes .  SIZEOF_ LONG ; sent Status = _ BOOL ; } final long checksum ; { final int  BUFSIZE =  Bytes . kilobyte32 * _ NUM ; final  Checked Input Stream cis = new  Checked Input Stream ( new  Buffered Input Stream ( is ) , new  Adler32 ( ) ) ; final byte [ ] buff = new byte [  BUFSIZE ] ; while ( _ BOOL ) { final int read = cis . read ( buff , _ NUM ,  BUFSIZE ) ; if ( read <= _ NUM ) break ; os . write ( buff , _ NUM , read ) ; bytes Written += read ; } checksum = cis . get Checksum ( ) . get Value ( ) ; } { final  Data Output Stream dos = new  Data Output Stream ( os ) ; dos . write Long ( checksum ) ; bytes Written +=  Bytes .  SIZEOF_ LONG ; dos . flush ( ) ; } os . flush ( ) ; if ( log . is Info Enabled ( ) ) log . info ( _ STR + uuid + _ STR + resource + _ STR + length + _ STR + checksum + _ STR +  Time Unit .  NANOSECONDS . to Millis (  System . nano Time ( ) - begin ) + _ STR ) ; } finally { try { os . close ( ) ; } catch (  Throwable t ) { } counters . bytes Written . add ( bytes Written ) ; counters . elapsed Write Nanos . add (  System . nano Time ( ) - begin ) ; synchronized ( counters . max Write Size Lock ) { counters . max Write Size =  Math . max ( counters . max Write Size , bytes Written ) ; } } }
public long sigignore ( ) { return  Long . parse Long ( fields [ _ NUM ] ) ; }
private static byte [ ] generate Seed ( ) { try { final  Byte Array Output Stream seed Buffer = new  Byte Array Output Stream ( ) ; final  Data Output Stream seed Buffer Out = new  Data Output Stream ( seed Buffer ) ; seed Buffer Out . write Long (  System . current Time Millis ( ) ) ; seed Buffer Out . write Long (  System . nano Time ( ) ) ; seed Buffer Out . write Int (  Process . my Pid ( ) ) ; seed Buffer Out . write Int (  Process . my Uid ( ) ) ; seed Buffer Out . write (  BUILD_ FINGERPRINT_ AND_ DEVICE_ SERIAL ) ; seed Buffer Out . close ( ) ; return seed Buffer . to Byte Array ( ) ; } catch ( final  IOException e ) { throw new  Security Exception ( _ STR , e ) ; } }
public  String render (  Value Expr the Expr ) throws  Exception { the Expr . visit ( this ) ; return m Buffer . to String ( ) ; }
public void stop Sampling ( ) { if ( m Sampling Counter . decrement And Get ( ) == _ NUM ) { m Handler . stop Sampling Thread ( ) ; add Final Sample ( ) ; } }
public  DSign Csr (  JFrame parent ,  PKCS10 Certification Request pkcs10 Csr ,  File csr File ,  Private Key sign Private Key ,  Key Pair Type sign Key Pair Type ,  X509 Certificate verification Certificate ,  Provider provider ) throws  Crypto Exception { super ( parent ,  Dialog .  Modality Type .  DOCUMENT_ MODAL ) ; this . pkcs10 Csr = pkcs10 Csr ; this . csr File = csr File ; this . sign Private Key = sign Private Key ; this . sign Key Pair Type = sign Key Pair Type ; this . verification Certificate = verification Certificate ; this . provider = provider ; set Title ( res . get String ( _ STR ) ) ; init Components ( ) ; }
public static  String parse Volume Host Directory (  String volume ) { if (  String Utils . is Empty ( volume ) ) { return volume ; } if ( ! volume . contains (  HOST_ CONTAINER_ DIR_ DELIMITER ) ) { return volume ; }  String [ ] host Container Dir = volume . split (  HOST_ CONTAINER_ DIR_ DELIMITER ) ; if ( host Container Dir . length != _ NUM ) { throw new  Illegal Argument Exception ( _ STR ) ; }  String host Dir = host Container Dir [ _ NUM ] ; return host Dir ; }
private  String fmt Time ( double time ) { return  Utilities . pad ( time Formatter . format ( time ) + _ STR , _ NUM ) ; }
public static  String right (  String s , int width , char fill Char ) { if ( s . length ( ) >= width ) { return s ; }  String Buffer sb = new  String Buffer ( width ) ; for ( int i = width - s . length ( ) ; -- i >= _ NUM ; ) { sb . append ( fill Char ) ; } sb . append ( s ) ; return sb . to String ( ) ; }
public synchronized boolean add All (  Collection < ? extends  E > c ) { mod Count ++ ;  Object [ ] a = c . to Array ( ) ; int num New = a . length ; ensure Capacity Helper ( element Count + num New ) ;  System . arraycopy ( a , _ NUM , element Data , element Count , num New ) ; element Count += num New ; return num New != _ NUM ; }
@  Override public void update (  Default Application State trans State ) { new Checkpoint ( trans State . get State ( ) , trans State . get State Hash ( ) , trans State . get Last Checkpoint CID ( ) ) ; set Last Checkpoint CID ( trans State . get Last Checkpoint CID ( ) ) ; }
private  List <  Pair <  String ,  Object > > to Pair List ( final  Map <  String ,  Object > bindings ) { final  List <  Pair <  String ,  Object > > blist = new  Array List <  Pair <  String ,  Object > > ( ) ; for ( final  Map .  Entry <  String ,  Object > pair : bindings . entry Set ( ) ) { blist . add ( new  Pair <  String ,  Object > ( pair . get Key ( ) , pair . get Value ( ) ) ) ; } return blist ; }
public void add Message Observer ( final  Message Observer observer ) { if ( observer == null ) { throw new  Null Pointer Exception ( ) ; } else if ( message Observers == null ) { init Message Observer List ( ) ; } message Observers . add ( observer ) ; }
public void show ( char initial Char ) { initial String = initial String . append ( initial Char ) ; show ( ) ; if (  SWT . get Platform ( ) != _ STR ) { set Edit Text ( initial String . to String ( ) ) ; } }
private static void byte2hex ( byte b ,  String Buffer buf ) { int high = ( ( b & _ NUM ) > > _ NUM ) ; int low = ( b & _ NUM ) ; buf . append (  HEX_ DIGITS [ high ] ) ; buf . append (  HEX_ DIGITS [ low ] ) ; }
public  E remove ( int index ) { hash Code Up To Date = _ BOOL ; mod Count ++ ;  E old Value = element Data ( index ) ; int num Moved = size - index - _ NUM ; if ( num Moved > _ NUM )  System . arraycopy ( element Data , index + _ NUM , element Data , index , num Moved ) ; element Data [ -- size ] = null ; return old Value ; }
public static  Double Vector rnorm ( int n , double mean , double sd ,  Random random ) { if ( sd < _ NUM ) throw new  Illegal Argument Exception ( _ STR ) ; if ( sd == _ NUM ) return new  Double Vector ( n , mean ) ;  Double Vector v = new  Double Vector ( n ) ; for ( int i = _ NUM ; i < n ; i ++ ) v . set ( i , ( random . next Gaussian ( ) + mean ) / sd ) ; return v ; }
private  Pdf Object read Compressed Stream (  Pdf Object root Obj , int pointer , final  Pdf File Reader current Pdf File , final  Object Reader object Reader , final  Pdf Object linear Obj ) throws  Pdf Exception { while ( pointer != - _ NUM ) { move Pointer ( pointer ) ; final byte [ ] raw = object Reader . read Object Data ( - _ NUM , null ) ; final  String Builder object Name = new  String Builder ( ) ; char current1 , last = _ STR ; int matched = _ NUM , i1 = _ NUM ; while ( i1 < raw . length ) { current1 = ( char ) raw [ i1 ] ; if ( current1 == _ NUM || current1 == _ NUM ) { current1 = _ STR ; } if ( current1 == _ STR && last == _ STR ) { matched = _ NUM ; } else if ( current1 == pattern . char At ( matched ) ) { matched ++ ; } else { matched = _ NUM ; object Name . append ( current1 ) ; } if ( matched == _ NUM ) { break ; } last = current1 ; i1 ++ ; } object Name . append ( _ STR ) ; final  Pdf Object pdf Object = new  Compressed Object ( object Name . to String ( ) ) ; pdf Object . set Compressed Stream ( _ BOOL ) ; final  Object Decoder object Decoder = new  Object Decoder ( current Pdf File ) ; object Decoder . read Dictionary As Object ( pdf Object , _ NUM , raw ) ; final int [ ] field Sizes = pdf Object . get Int Array (  Pdf Dictionary .  W ) ; byte [ ] xrefs = pdf Object . get Decoded Stream ( ) ; if ( xrefs == null ) { xrefs = current Pdf File . read Stream ( pdf Object , _ BOOL , _ BOOL , _ BOOL , _ BOOL , _ BOOL , null ) ; } final int [ ]  Index = pdf Object . get Int Array (  Pdf Dictionary .  Index ) ; if (  Index == null ) {  Compressed Objects . read Compressed Offsets ( _ NUM , _ NUM , pdf Object . get Int (  Pdf Dictionary .  Size ) , field Sizes , xrefs , offset , pdf_datafile ) ; } else { final int count =  Index . length ; int pntr = _ NUM ; for ( int aa = _ NUM ; aa < count ; aa += _ NUM ) { pntr =  Compressed Objects . read Compressed Offsets ( pntr ,  Index [ aa ] ,  Index [ aa + _ NUM ] , field Sizes , xrefs , offset , pdf_datafile ) ; } } if ( root Obj == null ) { root Obj = pdf Object . get Dictionary (  Pdf Dictionary .  Root ) ; encrypt Obj = pdf Object . get Dictionary (  Pdf Dictionary .  Encrypt ) ; if ( encrypt Obj != null ) { final byte [ ] [ ]  IDs = pdf Object . get String Array (  Pdf Dictionary .  ID ) ; if (  IDs != null && this .  ID == null ) { this .  ID =  IDs [ _ NUM ] ; } } info Object = pdf Object . get Dictionary (  Pdf Dictionary .  Info ) ; } if ( linear Obj != null ) { pointer = - _ NUM ; } else { pointer = pdf Object . get Int (  Pdf Dictionary .  Prev ) ; if ( pointer != - _ NUM && ! is Compressed Stream ( pointer , ( int ) eof ) ) { return read Legacy Reference Table ( root Obj , pointer , ( int ) eof , current Pdf File ) ; } } } return root Obj ; }
protected void warning Occurred ( int code ) { cb Lock . lock ( ) ; try { if ( ( code < _ NUM ) || ( code >  MAX_ WARNING ) ) { throw new  Internal Error ( _ STR ) ; } process Warning Occurred ( _ STR ,  Integer . to String ( code ) ) ; } finally { cb Lock . unlock ( ) ; } }
public boolean is Known Sub (  String sub Name ) { return  KNOWN_ SUBS . contains ( sub Name ) ; }
public boolean is Stored ( ) { return  Integer . signum ( id ) != - _ NUM ; }
public boolean is Search Light Bit ( int bit ) { if ( node Type !=  SMINI ) { log . error ( _ STR ) ; return ( _ BOOL ) ; } if ( ( bit < _ NUM ) || ( bit > _ NUM ) ) { log . error ( _ STR +  Integer . to String ( bit ) ) ; return ( _ BOOL ) ; } if ( loc Search Light Bits [ bit ] == _ NUM ) { return ( _ BOOL ) ; } return ( _ BOOL ) ; }
public void calc Major Tick ( ) { major Tick = _ NUM ; major Tick Count = ( int )  Math . round ( log10 ( max Tick / min Tick ) ) + _ NUM ; }
public void put (  String sample ,  Hidden Attribute attribute ,  Object value ) { put ( sample , attribute . to String ( ) , value ) ; }
void post Message (  List <  Jetstream Message > msgs ,  Dispatch Queue Stats stats ) throws  Message Service Exception { m_msg Rcv Counter . add And Get ( msgs . size ( ) ) ; if ( ( monitor Upstream Queue And Pause Traffic ( ) ==  Upstream Queue State .  FULL ) && ( m_paused . get ( ) ) ) { if ( ! m_msg Processor . has Available Capacity ( m_twenty Percent Capacity ) ) { m_total Msgs Dropped . increment ( ) ; return ; } }  List <  Runnable > requests = new  Array List <  Runnable > ( msgs . size ( ) ) ; for ( int i = _ NUM , t = msgs . size ( ) ; i < t ; i ++ ) {  Jetstream Message tm = msgs . get ( i ) ; if ( tm . get Topic ( ) == null ) { m_total Msgs Dropped . increment ( ) ; if (  LOGGER . is Debug Enabled ( ) ) {  LOGGER . debug ( _ STR ) ; } continue ; }  Message Service Request msr = new  Message Service Request ( tm ) ; msr . set Priority ( tm . get Priority ( ) ) ; msr . set Sequenceid ( tm . get Sequence Id ( ) ) ; if ( msr . get Priority ( ) ==  Jetstream Message .  INTERNAL_ MSG_ PRIORITY ) { if ( ! m_internal Msg Processor . process Request ( msr ) ) { m_total Msgs Dropped . increment ( ) ; throw new  Message Service Exception (  Message Service Exception .  BUFFER_ FULL , _ STR ) ; } if ( m_msgs Rcvd Per Sec . add And Get ( _ NUM ) < _ NUM ) m_msgs Rcvd Per Sec . set ( _ NUM ) ; m_total Msgs Rcvd . increment ( ) ; } else { requests . add ( msr ) ; } } if ( ! requests . is Empty ( ) ) { int batchsize = requests . size ( ) ; if ( ! m_msg Processor . process Batch ( requests ) ) { m_total Msgs Dropped . add And Get ( batchsize ) ; throw new  Message Service Exception (  Message Service Exception .  BUFFER_ FULL , _ STR + _ STR + batchsize + _ STR + m_msg Processor . get Available Capacity ( ) ) ; } m_avg Msgs Rcvd Per Sec . add ( batchsize ) ; m_total Msgs Rcvd . add And Get ( batchsize ) ; } if ( stats != null ) { stats . set High Priority Queue Depth ( ( int ) m_msg Processor . get Pending Requests ( ) ) ; stats . set Low Priority Queue Depth ( ( int ) m_msg Processor . get Pending Requests ( ) ) ; stats . set Max Queue Depth ( ( int ) m_msg Processor . get Max Queue Sz ( ) ) ; } }
public boolean unset Ordering (  Object first ,  Object second ) {  Digraph Node first PONode = (  Digraph Node ) po Nodes . get ( first ) ;  Digraph Node second PONode = (  Digraph Node ) po Nodes . get ( second ) ; return first PONode . remove Edge ( second PONode ) || second PONode . remove Edge ( first PONode ) ; }
public  String convert SWFTo HTML (  Input Stream in ) throws  Exception {  String Writer out1 = new  String Writer ( ) ; output = new  Print Writer ( out1 ) ;  Tag Parser parser = new  Tag Parser ( this ) ;  SWFReader reader = new  SWFReader ( parser , in ) ; reader . read File ( ) ; in . close ( ) ; size Count = reader . size ; final  String ret = _ STR + ( headerstr . is Empty ( ) ? _ STR : _ STR + headerstr + _ STR ) + out1 . to String ( ) + _ STR ; return ret ; }
public  Shape great Circle Line Shape ( ) {  General Path path = null ; if ( llpts != null && llpts . length >= _ NUM && llpts . length % _ NUM == _ NUM ) { double y1 = llpts [ _ NUM ] ; double x1 = llpts [ _ NUM ] ; path = new  General Path (  General Path .  WIND_ EVEN_ ODD , llpts . length / _ NUM ) ; boolean first Coords = _ BOOL ; for ( int i = _ NUM ; i < llpts . length ; i += _ NUM ) { double y2 = llpts [ i ] ; double x2 = llpts [ i + _ NUM ] ; double rad Dist =  Great Circle . spherical Distance ( y1 , x1 , y2 , x2 ) ; int nsegs = ( int ) (  Proj Math . rad To Deg ( rad Dist ) * segs Per Deg ) ; if ( nsegs == _ NUM ) { nsegs = _ NUM ; } double [ ] coords =  Great Circle . great Circle ( y1 , x1 , y2 , x2 , nsegs , _ BOOL ) ; if ( return Degrees ) {  Proj Math . array Rad To Deg ( coords ) ; } for ( int j = _ NUM ; j <= coords . length - _ NUM ; j += _ NUM ) { if ( first Coords ) { path . move To ( coords [ j + _ NUM ] , coords [ j ] ) ; first Coords = _ BOOL ; } else { path . line To ( coords [ j + _ NUM ] , coords [ j ] ) ; } } x1 = x2 ; y1 = y2 ; } if ( return Degrees ) { path . line To (  Proj Math . rad To Deg ( x1 ) ,  Proj Math . rad To Deg ( y1 ) ) ; } else { path . line To ( x1 , y1 ) ; } } return path ; }
public  Connection ( final  Inet Socket Address peer Address ) { this ( peer Address , (  Handshaker ) null ) ; }
protected static  Vector convert To Vector ( final  Object [ ] an Array ) { if ( an Array == null ) { return null ; } final  Vector v = new  Vector ( an Array . length ) ; for ( final  Object element : an Array ) { v . add Element ( element ) ; } return v ; }
protected synchronized void notify Version (  Sprog Version v ) { ver = v ; for (  Sprog Version Listener listener : get Copy Of Listeners ( ) ) { try { listener . notify Version ( ver ) ; version Listeners . remove ( listener ) ; } catch (  Exception e ) { log . warn ( _ STR + listener + _ STR + e ) ; } } }
protected void accept Drop ( int drop Operation ) {  Drop Target Context Peer peer = get Drop Target Context Peer ( ) ; if ( peer != null ) { peer . accept Drop ( drop Operation ) ; } }
@  Override public  String to String ( ) {  String result ; result = super . to String ( ) ; if ( m_ Capabilities Filter != null ) { init Capabilities ( ) ; if ( m_ Capabilities != null ) { if ( m_ Capabilities . supports Maybe ( m_ Capabilities Filter ) && ! m_ Capabilities . supports ( m_ Capabilities Filter ) ) { result = _ STR +  MAYBE_ SUPPORT + _ STR + result + _ STR ; } else if ( ! m_ Capabilities . supports ( m_ Capabilities Filter ) ) { result = _ STR +  NO_ SUPPORT + _ STR + result + _ STR ; } } } return result ; }
public void split Node (  KDTree Node node , int num Nodes Created , double [ ] [ ] node Ranges , double [ ] [ ] universe ) throws  Exception { correctly Initialized ( ) ; if ( node . m_ Nodes Rect Bounds == null ) { node . m_ Nodes Rect Bounds = new double [ _ NUM ] [ node . m_ Node Ranges . length ] ; for ( int i = _ NUM ; i < node . m_ Node Ranges . length ; i ++ ) { node . m_ Nodes Rect Bounds [  MIN ] [ i ] = node . m_ Node Ranges [ i ] [  MIN ] ; node . m_ Nodes Rect Bounds [  MAX ] [ i ] = node . m_ Node Ranges [ i ] [  MAX ] ; } } double max Rect Width =  Double .  NEGATIVE_ INFINITY , max Pt Width =  Double .  NEGATIVE_ INFINITY , tempval ; int split Dim = - _ NUM , class Idx = m_ Instances . class Index ( ) ; for ( int i = _ NUM ; i < node . m_ Nodes Rect Bounds [ _ NUM ] . length ; i ++ ) { if ( i == class Idx ) continue ; tempval = node . m_ Nodes Rect Bounds [  MAX ] [ i ] - node . m_ Nodes Rect Bounds [  MIN ] [ i ] ; if ( m_ Normalize Node Width ) { tempval = tempval / universe [ i ] [  WIDTH ] ; } if ( tempval > max Rect Width && node . m_ Node Ranges [ i ] [  WIDTH ] > _ NUM ) max Rect Width = tempval ; } for ( int i = _ NUM ; i < node . m_ Nodes Rect Bounds [ _ NUM ] . length ; i ++ ) { if ( i == class Idx ) continue ; tempval = node . m_ Nodes Rect Bounds [  MAX ] [ i ] - node . m_ Nodes Rect Bounds [  MIN ] [ i ] ; if ( m_ Normalize Node Width ) { tempval = tempval / universe [ i ] [  WIDTH ] ; } if ( tempval >= max Rect Width * ( _ NUM -  ERR ) && node . m_ Node Ranges [ i ] [  WIDTH ] > _ NUM ) { if ( node . m_ Node Ranges [ i ] [  WIDTH ] > max Pt Width ) { max Pt Width = node . m_ Node Ranges [ i ] [  WIDTH ] ; if ( m_ Normalize Node Width ) max Pt Width = max Pt Width / universe [ i ] [  WIDTH ] ; split Dim = i ; } } } double split Val = node . m_ Nodes Rect Bounds [  MIN ] [ split Dim ] + ( node . m_ Nodes Rect Bounds [  MAX ] [ split Dim ] - node . m_ Nodes Rect Bounds [  MIN ] [ split Dim ] ) * _ NUM ; if ( split Val < node . m_ Node Ranges [ split Dim ] [  MIN ] ) split Val = node . m_ Node Ranges [ split Dim ] [  MIN ] ; else if ( split Val >= node . m_ Node Ranges [ split Dim ] [  MAX ] ) split Val = node . m_ Node Ranges [ split Dim ] [  MAX ] - node . m_ Node Ranges [ split Dim ] [  WIDTH ] * _ NUM ; int right Start = rearrange Points ( m_ Inst List , node . m_ Start , node . m_ End , split Dim , split Val ) ; if ( right Start == node . m_ Start || right Start > node . m_ End ) { if ( right Start == node . m_ Start ) throw new  Exception ( _ STR + node . m_ Node Number + _ STR + _ STR + _ STR ) ; else throw new  Exception ( _ STR + node . m_ Node Number + _ STR + _ STR + _ STR ) ; } node . m_ Split Dim = split Dim ; node . m_ Split Value = split Val ; double [ ] [ ] widths = new double [ _ NUM ] [ node . m_ Nodes Rect Bounds [ _ NUM ] . length ] ;  System . arraycopy ( node . m_ Nodes Rect Bounds [  MIN ] , _ NUM , widths [  MIN ] , _ NUM , node . m_ Nodes Rect Bounds [  MIN ] . length ) ;  System . arraycopy ( node . m_ Nodes Rect Bounds [  MAX ] , _ NUM , widths [  MAX ] , _ NUM , node . m_ Nodes Rect Bounds [  MAX ] . length ) ; widths [  MAX ] [ split Dim ] = split Val ; node . m_ Left = new  KDTree Node ( num Nodes Created + _ NUM , node . m_ Start , right Start - _ NUM , m_ Euclidean Distance . initialize Ranges ( m_ Inst List , node . m_ Start , right Start - _ NUM ) , widths ) ; widths = new double [ _ NUM ] [ node . m_ Nodes Rect Bounds [ _ NUM ] . length ] ;  System . arraycopy ( node . m_ Nodes Rect Bounds [  MIN ] , _ NUM , widths [  MIN ] , _ NUM , node . m_ Nodes Rect Bounds [  MIN ] . length ) ;  System . arraycopy ( node . m_ Nodes Rect Bounds [  MAX ] , _ NUM , widths [  MAX ] , _ NUM , node . m_ Nodes Rect Bounds [  MAX ] . length ) ; widths [  MIN ] [ split Dim ] = split Val ; node . m_ Right = new  KDTree Node ( num Nodes Created + _ NUM , right Start , node . m_ End , m_ Euclidean Distance . initialize Ranges ( m_ Inst List , right Start , node . m_ End ) , widths ) ; }
public  Date modified Date (  String path ) throws  Illegal State Exception ,  IOException ,  FTPIllegal Reply Exception ,  FTPException { synchronized ( lock ) { if ( ! connected ) { throw new  Illegal State Exception ( _ STR ) ; } if ( ! authenticated ) { throw new  Illegal State Exception ( _ STR ) ; } communication . send FTPCommand ( _ STR + path ) ;  FTPReply r = communication . read FTPReply ( ) ; touch Auto Noop Timer ( ) ; if ( ! r . is Success Code ( ) ) { throw new  FTPException ( r ) ; }  String [ ] messages = r . get Messages ( ) ; if ( messages . length != _ NUM ) { throw new  FTPIllegal Reply Exception ( ) ; } else { try { return  MDTM_ DATE_ FORMAT . parse ( messages [ _ NUM ] ) ; } catch (  Parse Exception e ) { throw new  FTPIllegal Reply Exception ( ) ; } } } }
public boolean import Pkcs8 ( ) { return jrb Pkcs8 . is Selected ( ) ; }
public  Control Flow Graph run (  Compilation Unit Tree root ,  Processing Environment env ,  Method Tree tree ,  Class Tree class Tree ) {  Underlying AST underlying AST = new  CFGMethod ( tree , class Tree ) ; return run ( root , env , underlying AST ) ; }
private boolean is Valid Engine ( ) { if ( has Flag ( ~ (  CLAN_ ENGINE |  TANK_ ENGINE |  LARGE_ ENGINE |  SUPERHEAVY_ ENGINE |  SUPPORT_ VEE_ ENGINE ) ) ) { problem . append ( _ STR + engine Flags ) ; return _ BOOL ; } if ( has Flag (  SUPPORT_ VEE_ ENGINE ) && ( engine Type !=  STEAM ) && ( engine Type !=  COMBUSTION_ ENGINE ) && ( engine Type !=  BATTERY ) && ( engine Type !=  FUEL_ CELL ) && ( engine Type !=  SOLAR ) && ( engine Type !=  FISSION ) && ( engine Type !=  NORMAL_ ENGINE ) && ( engine Type !=  NONE ) ) { problem . append ( _ STR ) ; return _ BOOL ; } if ( ( ( ( int )  Math . ceil ( engine Rating / _ NUM ) >  ENGINE_ RATINGS . length ) || ( engine Rating < _ NUM ) ) && ! has Flag (  SUPPORT_ VEE_ ENGINE ) ) { problem . append ( _ STR + engine Rating ) ; return _ BOOL ; } if ( ( engine Rating > _ NUM ) && ! has Flag (  SUPPORT_ VEE_ ENGINE ) ) { engine Flags |=  LARGE_ ENGINE ; } switch ( engine Type ) { case  COMBUSTION_ ENGINE : case  NORMAL_ ENGINE : case  XL_ ENGINE : case  XXL_ ENGINE : case  FUEL_ CELL : case  NONE : case  MAGLEV : case  BATTERY : case  SOLAR : break ; case  COMPACT_ ENGINE : if ( has Flag (  LARGE_ ENGINE ) ) { problem . append (  Messages . get String ( _ STR ) ) ; return _ BOOL ; } break ; case  LIGHT_ ENGINE : case  FISSION : if ( has Flag (  CLAN_ ENGINE ) ) { problem . append (  Messages . get String ( _ STR ) ) ; return _ BOOL ; } break ; default : problem . append ( _ STR + engine Type ) ; return _ BOOL ; } return _ BOOL ; }
private void calculate D ( double [ ] b ) { int length = m Extremal Indices . size ( ) - _ NUM ; m D = new double [ length ] ; for ( int k = _ NUM ; k < length ; k ++ ) { m D [ k ] = b [ k ] * ( m Grid . get Cosine Frequency Grid ( ) [ m Extremal Indices . get ( k ) ] - m Grid . get Cosine Frequency Grid ( ) [ m Extremal Indices . get ( length ) ] ) ; } }
public static byte [ ] base64decode (  String coded ) { if ( null == coded ) return null ; byte [ ] src = coded . get Bytes ( ) ; int len = src . length ; int dlen = len - ( len / _ NUM ) ; dlen = ( dlen > > > _ NUM ) + ( dlen > > > _ NUM ) ; int rem = _ NUM ; if ( _ NUM == src [ len - _ NUM ] ) rem ++ ; if ( _ NUM == src [ len - _ NUM ] ) rem ++ ; dlen -= rem ; byte [ ] dst = new byte [ dlen ] ; int pos = _ NUM ; int dpos = _ NUM ; int col = _ NUM ; len -= _ NUM ; while ( pos < len ) { byte b0 = _base64de [ src [ pos ++ ] ] ; byte b1 = _base64de [ src [ pos ++ ] ] ; byte b2 = _base64de [ src [ pos ++ ] ] ; byte b3 = _base64de [ src [ pos ++ ] ] ; if (  B64 INV == b0 ||  B64 INV == b1 ||  B64 INV == b2 ||  B64 INV == b3 ) throw new  Runtime Exception ( _ STR + pos ) ; dst [ dpos ++ ] = ( byte ) ( ( b0 << _ NUM ) | ( ( b1 > > > _ NUM ) & _ NUM ) ) ; dst [ dpos ++ ] = ( byte ) ( ( b1 << _ NUM ) | ( ( b2 > > > _ NUM ) & _ NUM ) ) ; dst [ dpos ++ ] = ( byte ) ( ( b2 << _ NUM ) | ( b3 & _ NUM ) ) ; col += _ NUM ; if ( _ NUM == col ) { if ( _ NUM != src [ pos ++ ] ) throw new  Runtime Exception ( _ STR + ( pos - _ NUM ) ) ; col = _ NUM ; } } byte b0 = _base64de [ src [ pos ++ ] ] ; byte b1 = _base64de [ src [ pos ++ ] ] ; byte b2 = _base64de [ src [ pos ++ ] ] ; byte b3 = _base64de [ src [ pos ++ ] ] ; if (  B64 INV == b0 ||  B64 INV == b1 ||  B64 INV == b2 ||  B64 INV == b3 ) throw new  Runtime Exception ( _ STR + pos ) ; dst [ dpos ++ ] = ( byte ) ( ( b0 << _ NUM ) | ( ( b1 > > > _ NUM ) & _ NUM ) ) ; if ( _ NUM == rem ) return dst ; dst [ dpos ++ ] = ( byte ) ( ( b1 << _ NUM ) | ( ( b2 > > > _ NUM ) & _ NUM ) ) ; if ( _ NUM == rem ) return dst ; dst [ dpos ++ ] = ( byte ) ( ( b2 << _ NUM ) | ( b3 & _ NUM ) ) ; return dst ; }
private static  Properties load Properties (  String properties File ) {  Properties properties = new  Properties ( ) ; try (  Input Stream is = new  File Input Stream ( properties File ) ) { properties . load ( is ) ; } catch (  IOException e ) { throw new  Runtime Exception ( _ STR , e ) ; } return properties ; }
public  Map <  String ,  Map <  String ,  String > > list (  String service Name ) {  Map <  String ,  Map <  String ,  String > > results = new  Hash Map <  String ,  Map <  String ,  String > > ( ) ;  Service Info [ ] infos = jmdns . list ( _ STR + service Name + _ STR ) ; for (  Service Info info : infos ) { _log . info ( _ STR , info ) ; final  String [ ] host Addrs = info . get Host Addresses ( ) ; final  String Buffer buf = new  String Buffer ( ) ; for (  String host Addr : host Addrs ) { buf . append ( host Addr ) ; buf . append ( _ STR ) ; } final  String key = buf . to String ( ) ; _log . info ( _ STR , key ) ; final  Map <  String ,  String > values = new  Hash Map <  String ,  String > ( ) ; for (  Enumeration <  String > e = info . get Property Names ( ) ; e . has More Elements ( ) ; ) { final  String prop = e . next Element ( ) ; final  String value = new  String ( info . get Property Bytes ( prop ) ) ; _log . info ( _ STR , prop , value ) ; values . put ( prop , value ) ; } if ( values . is Empty ( ) ) { _log . warn ( _ STR , key ) ; } results . put ( key , values . is Empty ( ) ? null : values ) ; } return results ; }
@  Suppress Warnings ( { _ STR } ) @  Override default  Lazy Future Stream <  U > concat ( final  Stream < ? extends  U > other ) { return from Stream (  Stream . concat (  Stream Support . stream (  Spliterators . spliterator Unknown Size ( iterator ( ) ,  Spliterator .  ORDERED ) , _ BOOL ) ,  Stream Support . stream (  Spliterators . spliterator Unknown Size ( other . iterator ( ) ,  Spliterator .  ORDERED ) , _ BOOL ) ) ) ; }
private int move Components (  Container target , int x , int y , int width , int height , int row Start , int row End , boolean ltr , boolean use Baseline , int [ ] ascent , int [ ] descent ) { switch ( new Align ) { case  LEFT : x += ltr ? _ NUM : width ; break ; case  CENTER : x += width / _ NUM ; break ; case  RIGHT : x += ltr ? width : _ NUM ; break ; case  LEADING : break ; case  TRAILING : x += width ; break ; } int max Ascent = _ NUM ; int nonbaseline Height = _ NUM ; int baseline Offset = _ NUM ; if ( use Baseline ) { int max Descent = _ NUM ; for ( int i = row Start ; i < row End ; i ++ ) {  Component m = target . get Component ( i ) ; if ( m . visible ) { if ( ascent [ i ] >= _ NUM ) { max Ascent =  Math . max ( max Ascent , ascent [ i ] ) ; max Descent =  Math . max ( max Descent , descent [ i ] ) ; } else { nonbaseline Height =  Math . max ( m . get Height ( ) , nonbaseline Height ) ; } } } height =  Math . max ( max Ascent + max Descent , nonbaseline Height ) ; baseline Offset = ( height - max Ascent - max Descent ) / _ NUM ; } for ( int i = row Start ; i < row End ; i ++ ) {  Component m = target . get Component ( i ) ; if ( m . is Visible ( ) ) { int cy ; if ( use Baseline && ascent [ i ] >= _ NUM ) { cy = y + baseline Offset + max Ascent - ascent [ i ] ; } else { cy = y + ( height - m . height ) / _ NUM ; } if ( ltr ) { m . set Location ( x , cy ) ; } else { m . set Location ( target . width - x - m . width , cy ) ; } x += m . width + hgap ; } } return height ; }
@  Override public void read External (  Object Input in ) throws  IOException { path =  Igfs Utils . read Path ( in ) ; block Size = in . read Int ( ) ; grp Block Size = in . read Long ( ) ; len = in . read Long ( ) ; props =  U . read String Map ( in ) ; access Time = in . read Long ( ) ; modification Time = in . read Long ( ) ; flags = in . read Byte ( ) ; }
public  Standard XYItem Label Generator ( ) { this (  DEFAULT_ ITEM_ LABEL_ FORMAT ,  Number Format . get Number Instance ( ) ,  Number Format . get Number Instance ( ) ) ; }
public double adjusted Pow10 ( double val ) { boolean neg Flag = ( val < _ NUM ) ; if ( neg Flag ) { val = - val ; } double res ; if ( val < _ NUM ) { res = (  Math . pow ( _ NUM , val + _ NUM ) - _ NUM ) / _ NUM ; } else { res =  Math . pow ( _ NUM , val ) ; } return neg Flag ? ( - res ) : res ; }
public boolean is Last Invoice ( ) {  String cm = get Costing Method ( ) ; return cm != null && cm . equals (  COSTINGMETHOD_ Last Invoice ) ; }
public static  String fetch Cluster Name (  String cluster Cg Name ) {  String cluster Name = null ; if ( cluster Cg Name != null && ! cluster Cg Name . is Empty ( ) ) {  String [ ] tmp = cluster Cg Name . split (  SPLITTER ) ; cluster Name = tmp [ _ NUM ] ; } return cluster Name ; }
private void fetch My Service Cards From Server ( ) {  Retro Callback retro Callback ; retro Callback = new  Retro Callback ( this ) ; retro Callback . set Request Id (  Http Constants .  Api Response Codes .  GET_ MY_ SERVICES ) ; retro Callback List . add ( retro Callback ) ; m Yelo Api . get My Service Cards ( retro Callback ) ; }
public  DView Asymmetric Key Fields (  JDialog parent ,  String title ,  RSAPublic Key rsa Public Key ) { super ( parent , title ,  Dialog .  Modality Type .  DOCUMENT_ MODAL ) ; key = rsa Public Key ; init Fields ( ) ; }
public  List <  Colour Change > sample Conditional Migration Events2 ( int parent Colour , double parent Height , int child Colour , double child Height , double [ ] m ) {  List <  Colour Change > colour Changes = new  Array List <  Colour Change > ( ) ; if ( parent Height < child Height ) { throw new  Illegal Argument Exception ( _ STR + parent Height + _ STR + child Height + _ STR ) ; } try { int current Colour = parent Colour ; double current Height = parent Height ; while ( _ BOOL ) {  Colour Change next Event = random Conditional Migration Event ( current Colour , current Height , child Colour , child Height , m ) ; current Height = next Event . get Time ( ) ; current Colour = next Event . get Colour Above ( ) ; colour Changes . add ( next Event ) ; } } catch (  No Event Exception nee ) { } reverse Colour Change List ( colour Changes , parent Colour ) ; return colour Changes ; }
public static boolean is Attribute (  Object obj Value ) { if ( obj Value instanceof  String ) {  String string Value = (  String ) obj Value ; if ( string Value . starts With (  ATTRIBUTE_ START ) && string Value . ends With (  ATTRIBUTE_ END ) ) { return _ BOOL ; } } return _ BOOL ; }
public static  String decode ASCII ( final byte [ ] key , final int off , final int len ) { final byte [ ] b = new byte [ len ] ;  System . arraycopy ( key , off , b , _ NUM , len ) ; for ( int i = _ NUM ; i < len ; i ++ ) { b [ i ] = decode Byte ( b [ i ] ) ; } try { return new  String ( b , _ STR ) ; } catch (  Unsupported Encoding Exception e ) { throw new  Runtime Exception ( e ) ; } }
@  Override public void value Changed (  Tree Selection Event e ) { if ( prevent Event ) { return ; } if ( main Frame != null ) {  List <  Operator > selected Operators = get Selected Operators ( ) ; if ( selected Operators != null && ! selected Operators . is Empty ( ) ) { main Frame . select Operators ( selected Operators ) ; } } }
public synchronized void remove Property Change Listener (  Property Change Listener listener ) { listeners . remove ( listener ) ; }
private static  Intent create Share Intent (  Context context , final  String share Text ) { final  Intent share Intent = new  Intent (  Intent .  ACTION_ SEND ) ; share Intent . put Extra ( android . content .  Intent .  EXTRA_ SUBJECT , context . get String (  R . string . share_subject ) ) ; share Intent . put Extra ( android . content .  Intent .  EXTRA_ TEXT , share Text ) ; share Intent . set Type ( _ STR ) ; return share Intent ; }
public static <  U >  Atomic Integer Field Updater <  U > new Updater (  Class <  U > tclass ,  String field Name ) { if (  Unsafe Holder . is Available ( ) ) { return new  Atomic Integer Field Updater Impl <  U > ( tclass , field Name ) ; } return  Atomic Integer Field Updater . new Updater ( tclass , field Name ) ; }
private boolean try Step ( final double t0 , final double [ ] y0 , final double step , final int k , final double [ ] scale , final double [ ] [ ] f , final double [ ] y Middle , final double [ ] y End ) throws  Math Illegal Argument Exception ,  Math Illegal State Exception { final int n = sequence [ k ] ; final double sub Step = step / n ; final double sub Step2 = _ NUM * sub Step ; double t = t0 + sub Step ; for ( int i = _ NUM ; i < y0 . length ; ++ i ) { y End [ i ] = y0 [ i ] + sub Step * f [ _ NUM ] [ i ] ; } f [ _ NUM ] = compute Derivatives ( t , y End ) ; final double [ ] y Tmp = y0 . clone ( ) ; for ( int j = _ NUM ; j < n ; ++ j ) { if ( _ NUM * j == n ) {  System . arraycopy ( y End , _ NUM , y Middle , _ NUM , y0 . length ) ; } t += sub Step ; for ( int i = _ NUM ; i < y0 . length ; ++ i ) { final double middle = y End [ i ] ; y End [ i ] = y Tmp [ i ] + sub Step2 * f [ j ] [ i ] ; y Tmp [ i ] = middle ; } f [ j + _ NUM ] = compute Derivatives ( t , y End ) ; if ( perform Test && ( j <= max Checks ) && ( k < max Iter ) ) { double initial Norm = _ NUM ; for ( int l = _ NUM ; l < scale . length ; ++ l ) { final double ratio = f [ _ NUM ] [ l ] / scale [ l ] ; initial Norm += ratio * ratio ; } double delta Norm = _ NUM ; for ( int l = _ NUM ; l < scale . length ; ++ l ) { final double ratio = ( f [ j + _ NUM ] [ l ] - f [ _ NUM ] [ l ] ) / scale [ l ] ; delta Norm += ratio * ratio ; } if ( delta Norm > _ NUM *  Fast Math . max ( _ NUM , initial Norm ) ) { return _ BOOL ; } } } for ( int i = _ NUM ; i < y0 . length ; ++ i ) { y End [ i ] = _ NUM * ( y Tmp [ i ] + y End [ i ] + sub Step * f [ n ] [ i ] ) ; } return _ BOOL ; }
private static  Pair <  String ,  String > offset LSR ( final long offset , final  ITranslation Environment environment , final  List <  Reil Instruction > instructions , final  String register Node Value1 , final  String register Node Value2 , final  String immediate Node Value ) { final  String address = environment . get Next Variable String ( ) ; final  String tmp Var1 = environment . get Next Variable String ( ) ; final  String tmp Var2 = environment . get Next Variable String ( ) ; final  String index = environment . get Next Variable String ( ) ; long base Offset = offset ; instructions . add (  Reil Helpers . create Bsh ( base Offset ++ , dw , register Node Value2 , dw , _ STR + immediate Node Value , qw , tmp Var1 ) ) ; instructions . add (  Reil Helpers . create And ( base Offset ++ , qw , tmp Var1 , dw , d Word Bit Mask , dw , index ) ) ; instructions . add (  Reil Helpers . create Add ( base Offset ++ , dw , register Node Value1 , dw , index , dw , tmp Var2 ) ) ; instructions . add (  Reil Helpers . create And ( base Offset ++ , dw , tmp Var2 , dw , d Word Bit Mask , dw , address ) ) ; return new  Pair <  String ,  String > ( address , register Node Value1 ) ; }
public static  Row Limit Spec build Row Limit Spec (  Esper EPL2 Grammar Parser .  Row Limit Context ctx ) {  Object num Rows ;  Object offset ; if ( ctx . o != null ) { num Rows = parse Num Or Variable Ident ( ctx . n1 , ctx . i1 ) ; offset = parse Num Or Variable Ident ( ctx . n2 , ctx . i2 ) ; } else if ( ctx . c != null ) { offset = parse Num Or Variable Ident ( ctx . n1 , ctx . i1 ) ; num Rows = parse Num Or Variable Ident ( ctx . n2 , ctx . i2 ) ; } else { num Rows = parse Num Or Variable Ident ( ctx . n1 , ctx . i1 ) ; offset = null ; }  Integer num Rows Int = null ;  String num Rows Variable = null ; if ( num Rows instanceof  String ) { num Rows Variable = (  String ) num Rows ; } else { num Rows Int = (  Integer ) num Rows ; }  Integer offset Int = null ;  String offset Variable = null ; if ( offset instanceof  String ) { offset Variable = (  String ) offset ; } else { offset Int = (  Integer ) offset ; } return new  Row Limit Spec ( num Rows Int , offset Int , num Rows Variable , offset Variable ) ; }
public final int first_common_layer (  Brd Item p_other ) { int max_first_layer =  Math . max ( first_layer ( ) , p_other . first_layer ( ) ) ; int min_last_layer =  Math . min ( last_layer ( ) , p_other . last_layer ( ) ) ; if ( max_first_layer > min_last_layer ) { return - _ NUM ; } return max_first_layer ; }
public  Item Stack remove Items (  Item Stack drive ,  Item Stack stack , int amount Wanted ) { if ( get Max Kilobits ( drive ) == - _ NUM ) return null ; int stored = get Amount Stored ( drive , stack ) ; int amount Given =  Math . min ( amount Wanted , stored ) ; if ( amount Given > _ NUM ) { set Amount Stored ( drive , stack , stored - amount Given ) ; stack . stack Size += amount Given ; mark Dirty ( drive ) ; } return stack ; }
public void save Indexes ( ) {  Array List to Save = new  Array List ( ) ; synchronized ( this ) {  Object [ ] value Table = this . indexes . value Table ; for ( int i = _ NUM , l = value Table . length ; i < l ; i ++ ) {  Index index = (  Index ) value Table [ i ] ; if ( index != null ) to Save . add ( index ) ; } } boolean all Saved = _ BOOL ; for ( int i = _ NUM , length = to Save . size ( ) ; i < length ; i ++ ) {  Index index = (  Index ) to Save . get ( i ) ;  Read Write Monitor monitor = index . monitor ; if ( monitor == null ) continue ; try { monitor . enter Read ( ) ; if ( index . has Changed ( ) ) { if ( monitor . exit Read Enter Write ( ) ) { try { save Index ( index ) ; } catch (  IOException e ) { if (  Job Manager .  VERBOSE ) {  Util . verbose ( _ STR ,  System . err ) ; e . print Stack Trace ( ) ; } all Saved = _ BOOL ; } finally { monitor . exit Write Enter Read ( ) ; } } else { all Saved = _ BOOL ; } } } finally { monitor . exit Read ( ) ; } } if ( this . participants Containers != null && this . participant Updated ) { write Participants Index Names File ( ) ; this . participant Updated = _ BOOL ; } this . need To Save = ! all Saved ; }
public void add Item (  Artist artist , int position ) { if ( artist == null ) throw new  Null Pointer Exception ( _ STR ) ; if ( position < get Item Count ( ) || position > get Item Count ( ) ) throw new  Illegal Argument Exception ( _ STR ) ; artists . add ( position , artist ) ; notify Item Inserted ( position ) ; }
public void expand And Select If Exists (  Repository Location location ) { if ( location . parent ( ) != null ) { expand If Exists ( location . parent ( ) , location . get Name ( ) ) ; } else { expand If Exists ( location , null ) ; } scroll Path To Visible ( get Selection Path ( ) ) ; }
public static void save Provisioning Validity (  Context context , long validity ) { if ( validity <= _ NUM ) { return ; } long next =  System . current Time Millis ( ) + validity ;  Shared Preferences preferences = context . get Shared Preferences (  Android Registry Factory .  RCS_ PREFS_ NAME ,  Activity .  MODE_ PRIVATE ) ;  Shared Preferences .  Editor editor = preferences . edit ( ) ; editor . put Long (  REGISTRY_ PROVISIONING_ VALIDITY , validity ) ; editor . put Long (  REGISTRY_ PROVISIONING_ EXPIRATION , next ) ; editor . commit ( ) ; }
public void encode (  Output Stream out ) throws  IOException {  Der Output Stream tmp = new  Der Output Stream ( ) ; if ( this . extension Value == null ) { this . extension Id =  PKIXExtensions .  Reason Code_ Id ; this . critical = _ BOOL ; encode This ( ) ; } super . encode ( tmp ) ; out . write ( tmp . to Byte Array ( ) ) ; }
public  Driver Task unexport Volumes From Initiators (  List <  Initiator > initiators ,  List <  Storage Volume > volumes ) {  LOG . info ( _ STR ) ;  Driver Task task = new  Dell SCDriver Task ( _ STR ) ;  Sc Server server = null ;  String Builder err Buffer = new  String Builder ( ) ; int volumes Unmapped = _ NUM ; for (  Storage Volume volume : volumes ) {  String ssn = volume . get Storage System Id ( ) ; boolean is Snapshot =  String Utils . count Matches ( volume . get Native Id ( ) , _ STR ) == _ NUM ; try {  Storage Center API api = connection Manager . get Connection ( ssn ) ;  Sc Volume sc Vol = null ; if ( is Snapshot ) { sc Vol = api . find Replay View ( volume . get Native Id ( ) ) ; if ( sc Vol != null ) { api . delete Volume ( sc Vol . instance Id ) ; volumes Unmapped ++ ; continue ; } } else { sc Vol = api . get Volume ( volume . get Native Id ( ) ) ; } if ( sc Vol == null ) { throw new  Dell SCDriver Exception (  String . format ( _ STR , volume . get Native Id ( ) ) ) ; } if ( server == null ) { server = find Sc Server ( api , ssn , initiators ) ; } if ( server == null ) { throw new  Dell SCDriver Exception (  SERVER_ CREATE_ FAIL_ MSG ) ; }  Sc Mapping Profile [ ] mapping Profiles = api . find Mapping Profiles ( server . instance Id , sc Vol . instance Id ) ; for (  Sc Mapping Profile mapping Profile : mapping Profiles ) { api . delete Mapping Profile ( mapping Profile . instance Id ) ; } volumes Unmapped ++ ;  LOG . info ( _ STR , sc Vol . name , server . name ) ; } catch (  Storage Center APIException |  Dell SCDriver Exception dex ) {  String error =  String . format ( _ STR , volume . get Display Name ( ) , dex ) ;  LOG . error ( error ) ; err Buffer . append (  String . format ( _ STR , error ) ) ; if (  SERVER_ CREATE_ FAIL_ MSG . equals ( dex . get Message ( ) ) ) { break ; } } } task . set Message ( err Buffer . to String ( ) ) ; if ( volumes Unmapped == volumes . size ( ) ) { task . set Status (  Task Status .  READY ) ; } else if ( volumes Unmapped == _ NUM ) { task . set Status (  Task Status .  FAILED ) ; } else { task . set Status (  Task Status .  PARTIALLY_ FAILED ) ; } return task ; }
public void create Cluster Async ( final  String project Id , final  Cluster Create Spec cluster Create Spec , final  Future Callback <  Task > response Callback ) throws  IOException {  String path =  String . format ( _ STR , get Base Path ( ) , project Id ) ; create Object Async ( path , serialize Object As Json ( cluster Create Spec ) , response Callback ) ; }
public static  Dereference Aliases Policy value Of ( final int int Value ) { if ( int Value < _ NUM || int Value >=  ELEMENTS . length ) { return null ; } return  ELEMENTS [ int Value ] ; }
public static void write Unsafe (  Packet Output Stream out ,  String value , boolean no Backslash Escapes ) throws  IOException { byte [ ] bytes = value . get Bytes ( _ STR ) ; out . write Unsafe (  QUOTE ) ; write Bytes Escaped Unsafe ( out , bytes , bytes . length , no Backslash Escapes ) ; out . write Unsafe (  QUOTE ) ; }
public void add ( final  SAMRecord read , final int position ) { record And Offsets . add ( new  Record And Offset ( read , position ) ) ; }
private  Sha256 Hash calculate Hash ( ) { try {  Byte Array Output Stream bos = new  Unsafe Byte Array Output Stream (  HEADER_ SIZE ) ; write Header ( bos ) ; return new  Sha256 Hash (  Utils . reverse Bytes ( double Digest ( bos . to Byte Array ( ) ) ) ) ; } catch (  IOException e ) { throw new  Runtime Exception ( e ) ; } }
private void add Property Type (  URI p ,  Resource t ) {  Owl Property prop = get Property ( p ) ; if ( t . equals (  OWL .  TRANSITIVEPROPERTY ) ) { prop . set Transitive ( ) ; } else if ( t . equals (  OWL .  SYMMETRICPROPERTY ) ) { prop . set Symmetric ( ) ; } else if ( t . equals (  OWL2 .  ASYMMETRICPROPERTY ) ) { prop . set Asymmetric ( ) ; } else if ( t . equals (  OWL .  FUNCTIONALPROPERTY ) ) { prop . set Functional ( ) ; } else if ( t . equals (  OWL .  INVERSEFUNCTIONALPROPERTY ) ) { prop . set Inverse Functional ( ) ; } else if ( t . equals (  OWL2 .  IRREFLEXIVEPROPERTY ) ) { prop . set Irreflexive ( ) ; } }
public static void equals (  Object object1 ,  Object object2 ) { check Assertion ( object1 . equals ( object2 ) , null ) ; }
protected void pre Add Interruptibly (  Object o ) throws  Interrupted Exception { }
private  OData Feed read Feed Log Perf (  String query ,  Map <  String ,  String > params ) throws  IOException ,  OData Exception { long delta_time =  System . current Time Millis ( ) ;  OData Feed feed = client . read Feed ( query , params ) ; log (  Level .  DEBUG , _ STR + query + _ STR + delta_time + _ STR ) ; return feed ; }
public  Dependencies resolve From File (  File file ,  String class Name ,  Soot Class sc ) {  Dexlib Wrapper wrapper = cache . get ( file ) ; if ( wrapper == null ) { wrapper = new  Dexlib Wrapper ( file ) ; cache . put ( file , wrapper ) ; wrapper . initialize ( ) ; }  Dependencies deps = wrapper . make Soot Class ( sc , class Name ) ; add Source File Tag ( sc , _ STR + file . get Name ( ) ) ; return deps ; }
public static  String build Response Url (  String tenant ,  Logout State logout State ) {  String retval = null ;  Logout Response saml Response = logout State . generate Response For Tenant ( tenant , logout State . get Message Source ( ) , logout State . get Locale ( ) ) ; if ( saml Response != null ) { log . info ( _ STR + saml Response . to String ( ) ) ; retval = logout State . generate Response Url For Tenant ( saml Response , tenant ) ; } return retval ; }
public static void assert Label ( int [ ] path ,  String text ) { if ( verbose ) { log ( _ STR + to String ( path ) + _ STR + text + _ STR ) ; }  Label l = (  Label ) get Component By Path ( path ) ; assert Bool ( l != null , _ STR + text ) ; assert Bool ( text == l . get Text ( ) || text . equals ( l . get Text ( ) ) , ( _ STR + l . get Text ( ) ) + _ STR + text ) ; }
private void interpolate Result List (  Array List <  Path Parser .  Path Data Node > list ) { if ( list == null || list . size ( ) <= _ NUM ) return ; float [ ] [ ] list Pen Pos =  Path Node Utils . calculate Pen Position ( list ) ;  Array List <  Path Parser .  Path Data Node > sub List = new  Array List < > ( ) ; int size = list . size ( ) ;  Path Parser .  Path Data Node current Node = null ; int i = _ NUM ; while ( i < size - _ NUM ) { current Node = list . get ( i ) ; if ( ! is Interpolatable Command ( current Node . m Type ) ) { i ++ ; continue ; } boolean valid Sequence = _ BOOL ; int k = i ; for ( int j = i ; j < size && valid Sequence ; j ++ ) { if ( current Node . m Type == list . get ( j ) . m Type ) { k = j ; if ( !  Arrays . equals ( current Node . m Params , list . get ( j ) . m Params ) ) break ; } else valid Sequence = _ BOOL ; } if ( k - i > _ NUM ) { interpolate Sub List ( list . sub List ( i , k + _ NUM ) ) ; } i ++ ; } }
private void init Tokenizer (  Stream Tokenizer tokenizer ) { tokenizer . reset Syntax ( ) ; tokenizer . whitespace Chars ( _ NUM , ( _ STR - _ NUM ) ) ; tokenizer . word Chars ( _ STR , _ STR ) ; tokenizer . whitespace Chars ( _ STR , _ STR ) ; tokenizer . whitespace Chars ( _ STR , _ STR ) ; tokenizer . comment Char ( _ STR ) ; tokenizer . whitespace Chars ( _ STR , _ STR ) ; tokenizer . quote Char ( _ STR ) ; tokenizer . quote Char ( _ STR ) ; tokenizer . eol Is Significant ( _ BOOL ) ; }
protected void run_ Thread Size Loop ( ) throws  Exception { for ( int i = _ NUM ; i <= _ NUM ; i += _ NUM ) { set Num Workers ( i ) ; try {  Thread . sleep ( _ NUM * _ NUM ) ; } catch (  Interrupted Exception e ) { } } }
protected boolean read ( ) { if ( ! n Reuse Header ) {  Debug . message ( _ STR , _ STR ) ; return read Header ( ) ; } byte [ ] temp Data = new byte [ n Data Size - n Field Offset ] ; int n Read Bytes = po Module . read ( temp Data , _ NUM , temp Data . length ) ;  System . arraycopy ( pach Data , n Field Offset , temp Data , _ NUM , temp Data . length ) ; if ( n Read Bytes != ( int ) ( n Data Size - n Field Offset ) && n Read Bytes == - _ NUM ) { return _ BOOL ; } else if ( n Read Bytes != ( int ) ( n Data Size - n Field Offset ) ) {  Debug . error ( _ STR ) ; return _ BOOL ; } return _ BOOL ; }
@  Override public boolean lock ( ) { try { if ( !  File Factory . is File Exist ( location ,  File Factory . get File Type ( tmp Path ) ) ) {  File Factory . mkdirs ( location ,  File Factory . get File Type ( tmp Path ) ) ; }  String lock File Path = location +  Carbon Common Constants .  FILE_ SEPARATOR + lock File ; if ( !  File Factory . is File Exist ( lock File Path ,  File Factory . get File Type ( location ) ) ) {  File Factory . create New Lock File ( lock File Path ,  File Factory . get File Type ( location ) ) ; } file Output Stream = new  File Output Stream ( lock File Path ) ; channel = file Output Stream . get Channel ( ) ; try { file Lock = channel . try Lock ( ) ; } catch (  Overlapping File Lock Exception e ) { return _ BOOL ; } if ( null != file Lock ) { return _ BOOL ; } else { return _ BOOL ; } } catch (  IOException e ) { return _ BOOL ; } }
public  MLResults execute (  Script script ) {  Script Executor script Executor = new  Script Executor ( spark Monitoring Util ) ; script Executor . set Explain ( explain ) ; script Executor . set Explain Level ( explain Level ) ; script Executor . set Statistics ( statistics ) ; script Executor . set Init ( script History Strings . is Empty ( ) ) ; return execute ( script , script Executor ) ; }
public void disable (  Rich Formatter Feature feature ) { features . remove ( feature ) ; }
public void remove Event Listener (  ZWave Event Listener event Listener ) { synchronized ( zwave Event Listeners ) { zwave Event Listeners . remove ( event Listener ) ; } }
private static double python Time ( ) { return  System . current Time Millis ( ) / _ NUM ; }
@  Safe Varargs public final void add (  T ... new Items ) { add (  Arrays . as List ( new Items ) ) ; }
public static  String quote If Java Keyword (  String name ) { return  JVMModule Util . quote If Java Keyword ( name ) ; }
private static <  T ,  ID > void add Drop Table Statements (  Database Type database Type ,  Table Info <  T ,  ID > table Info ,  List <  String > statements ) {  List <  String > statements Before = new  Array List <  String > ( ) ;  List <  String > statements After = new  Array List <  String > ( ) ; for (  Field Type field Type : table Info . get Field Types ( ) ) { database Type . drop Column Arg ( field Type , statements Before , statements After ) ; }  String Builder sb = new  String Builder ( _ NUM ) ; sb . append ( _ STR ) ; database Type . append Escaped Entity Name ( sb , table Info . get Table Name ( ) ) ; sb . append ( _ STR ) ; statements . add All ( statements Before ) ; statements . add ( sb . to String ( ) ) ; statements . add All ( statements After ) ; }
private static  Class Info find Or Create Class (  String t ) { if ( ! t . ends With ( _ STR ) ) { return  Class Info . find Or Create Class ( t ) ; } else {  String base Type = t . substring ( _ NUM , t . index Of ( _ STR ) ) ; int level = ( t . length ( ) - t . index Of ( _ STR ) ) / _ NUM ;  String s = _ STR ; for ( int i = _ NUM ; i < level ; ++ i ) s += _ STR ; if ( base Type . equals ( _ STR ) ) s += _ STR ; else if ( base Type . equals ( _ STR ) ) s += _ STR ; else s += _ STR + base Type + _ STR ; return  Class Info . find Or Create Class ( s ) ; } }
@  HLEFunction ( nid = _ NUM , version = _ NUM ) public int sce Rtc Set Tick (  TPointer time Addr ,  TPointer64 ticks Addr ) { long ticks = ticks Addr . get Value ( ) - rtc Magic Offset ;  Sce Psp Date Time time =  Sce Psp Date Time . from Micros ( ticks ) ; time . write ( time Addr ) ; return _ NUM ; }
private void populate Nav Drawer ( ) { m Nav Drawer Items . clear ( ) ; m Nav Drawer Items . add (  NAVDRAWER_ ITEM_ HOME ) ; m Nav Drawer Items . add (  NAVDRAWER_ ITEM_ SEPARATOR ) ; m Nav Drawer Items . add (  NAVDRAWER_ ITEM_ MY_ FOLLOWING ) ; m Nav Drawer Items . add (  NAVDRAWER_ ITEM_ MY_ SHOTS ) ; m Nav Drawer Items . add (  NAVDRAWER_ ITEM_ MY_ BUCKETS ) ; m Nav Drawer Items . add (  NAVDRAWER_ ITEM_ MY_ PROJECTS ) ; m Nav Drawer Items . add (  NAVDRAWER_ ITEM_ MY_ TEAMS ) ; m Nav Drawer Items . add (  NAVDRAWER_ ITEM_ MY_ LIKES ) ; m Nav Drawer Items . add (  NAVDRAWER_ ITEM_ SEPARATOR_ SPECIAL ) ; m Nav Drawer Items . add (  NAVDRAWER_ ITEM_ SETTINGS ) ; create Nav Drawer Items ( ) ; }
private  Big Integer odd Mod Pow (  Big Integer y ,  Big Integer z ) { if ( y . equals (  ONE ) ) return this ; if ( signum == _ NUM ) return  ZERO ; int [ ] base = mag . clone ( ) ; int [ ] exp = y . mag ; int [ ] mod = z . mag ; int mod Len = mod . length ; if ( ( mod Len & _ NUM ) != _ NUM ) { int [ ] x = new int [ mod Len + _ NUM ] ;  System . arraycopy ( mod , _ NUM , x , _ NUM , mod Len ) ; mod = x ; mod Len ++ ; } int wbits = _ NUM ; int ebits = bit Length ( exp , exp . length ) ; if ( ( ebits != _ NUM ) || ( exp [ _ NUM ] != _ NUM ) ) { while ( ebits > bn Exp Mod Thresh Table [ wbits ] ) { wbits ++ ; } } int tblmask = _ NUM << wbits ; int [ ] [ ] table = new int [ tblmask ] [ ] ; for ( int i = _ NUM ; i < tblmask ; i ++ ) table [ i ] = new int [ mod Len ] ; long n0 = ( mod [ mod Len - _ NUM ] &  LONG_ MASK ) + ( ( mod [ mod Len - _ NUM ] &  LONG_ MASK ) << _ NUM ) ; long inv = -  Mutable Big Integer . inverse Mod64 ( n0 ) ; int [ ] a = left Shift ( base , base . length , mod Len << _ NUM ) ;  Mutable Big Integer q = new  Mutable Big Integer ( ) , a2 = new  Mutable Big Integer ( a ) , b2 = new  Mutable Big Integer ( mod ) ; b2 . normalize ( ) ;  Mutable Big Integer r = a2 . divide ( b2 , q ) ; table [ _ NUM ] = r . to Int Array ( ) ; if ( table [ _ NUM ] . length < mod Len ) { int offset = mod Len - table [ _ NUM ] . length ; int [ ] t2 = new int [ mod Len ] ;  System . arraycopy ( table [ _ NUM ] , _ NUM , t2 , offset , table [ _ NUM ] . length ) ; table [ _ NUM ] = t2 ; } int [ ] b = montgomery Square ( table [ _ NUM ] , mod , mod Len , inv , null ) ; int [ ] t =  Arrays . copy Of ( b , mod Len ) ; for ( int i = _ NUM ; i < tblmask ; i ++ ) { table [ i ] = montgomery Multiply ( t , table [ i - _ NUM ] , mod , mod Len , inv , null ) ; } int bitpos = _ NUM << ( ( ebits - _ NUM ) & ( _ NUM - _ NUM ) ) ; int buf = _ NUM ; int elen = exp . length ; int e Index = _ NUM ; for ( int i = _ NUM ; i <= wbits ; i ++ ) { buf = ( buf << _ NUM ) | ( ( ( exp [ e Index ] & bitpos ) != _ NUM ) ? _ NUM : _ NUM ) ; bitpos >>>= _ NUM ; if ( bitpos == _ NUM ) { e Index ++ ; bitpos = _ NUM << ( _ NUM - _ NUM ) ; elen -- ; } } int multpos = ebits ; ebits -- ; boolean isone = _ BOOL ; multpos = ebits - wbits ; while ( ( buf & _ NUM ) == _ NUM ) { buf >>>= _ NUM ; multpos ++ ; } int [ ] mult = table [ buf > > > _ NUM ] ; buf = _ NUM ; if ( multpos == ebits ) isone = _ BOOL ; while ( _ BOOL ) { ebits -- ; buf <<= _ NUM ; if ( elen != _ NUM ) { buf |= ( ( exp [ e Index ] & bitpos ) != _ NUM ) ? _ NUM : _ NUM ; bitpos >>>= _ NUM ; if ( bitpos == _ NUM ) { e Index ++ ; bitpos = _ NUM << ( _ NUM - _ NUM ) ; elen -- ; } } if ( ( buf & tblmask ) != _ NUM ) { multpos = ebits - wbits ; while ( ( buf & _ NUM ) == _ NUM ) { buf >>>= _ NUM ; multpos ++ ; } mult = table [ buf > > > _ NUM ] ; buf = _ NUM ; } if ( ebits == multpos ) { if ( isone ) { b = mult . clone ( ) ; isone = _ BOOL ; } else { t = b ; a = montgomery Multiply ( t , mult , mod , mod Len , inv , a ) ; t = a ; a = b ; b = t ; } } if ( ebits == _ NUM ) break ; if ( ! isone ) { t = b ; a = montgomery Square ( t , mod , mod Len , inv , a ) ; t = a ; a = b ; b = t ; } } int [ ] t2 = new int [ _ NUM * mod Len ] ;  System . arraycopy ( b , _ NUM , t2 , mod Len , mod Len ) ; b = mont Reduce ( t2 , mod , mod Len , ( int ) inv ) ; t2 =  Arrays . copy Of ( b , mod Len ) ; return new  Big Integer ( _ NUM , t2 ) ; }
public int next Token ( ) { while ( index < length &&  Character . is Whitespace ( expr [ index ] ) ) { index ++ ; } token Val = null ; if ( index == length ) return  TOKEN_ END ; int start = index ; char current Char = expr [ index ] ; char next Char = ( char ) _ NUM ; index ++ ; if ( index < length ) next Char = expr [ index ] ; switch ( current Char ) { case _ STR : return  TOKEN_ LBRACE ; case _ STR : return  TOKEN_ RBRACE ; case _ STR : return  TOKEN_ EQ ; case _ STR : if ( next Char == _ STR ) { index ++ ; return  TOKEN_ NOT_ EQ ; } return  TOKEN_ NOT ; case _ STR : if ( next Char == _ STR ) { index ++ ; return  TOKEN_ OR ; } break ; case _ STR : if ( next Char == _ STR ) { index ++ ; return  TOKEN_ AND ; } break ; case _ STR : if ( next Char == _ STR ) { index ++ ; return  TOKEN_ GE ; } return  TOKEN_ GT ; case _ STR : if ( next Char == _ STR ) { index ++ ; return  TOKEN_ LE ; } return  TOKEN_ LT ; default : break ; } int end = index ; if ( current Char == _ STR || current Char == _ STR ) { char end Char = current Char ; boolean escaped = _ BOOL ; start ++ ; for ( ; index < length ; index ++ ) { if ( expr [ index ] == _ STR && ! escaped ) { escaped = _ BOOL ; continue ; } if ( expr [ index ] == end Char && ! escaped ) break ; escaped = _ BOOL ; } end = index ; index ++ ; } else if ( current Char == _ STR ) { char end Char = current Char ; boolean escaped = _ BOOL ; for ( ; index < length ; index ++ ) { if ( expr [ index ] == _ STR && ! escaped ) { escaped = _ BOOL ; continue ; } if ( expr [ index ] == end Char && ! escaped ) break ; escaped = _ BOOL ; } end = ++ index ; } else { for ( ; index < length ; index ++ ) { if ( is Meta Char ( expr [ index ] ) ) break ; } end = index ; } this . token Val = new  String ( expr , start , end - start ) ; return  TOKEN_ STRING ; }
public static  Byte [ ] values Of ( byte [ ] array ) {  Byte [ ] dest = new  Byte [ array . length ] ; for ( int i = _ NUM ; i < array . length ; i ++ ) { dest [ i ] =  Byte . value Of ( array [ i ] ) ; } return dest ; }
public void audit Callhome (  Operation Type Enum audit Type ,  String operational Status ,  String description ,  Object ... descparams ) { _audit Mgr . record Audit Log ( null , null ,  EVENT_ SERVICE_ TYPE , audit Type ,  System . current Time Millis ( ) , operational Status , description , descparams ) ; }
public static float mean ( float [ ] data , int start Index , int end Index ) { float mean = _ NUM ; int total = _ NUM ; start Index =  Math . max ( start Index , _ NUM ) ; start Index =  Math . min ( start Index , data . length - _ NUM ) ; end Index =  Math . max ( end Index , _ NUM ) ; end Index =  Math . min ( end Index , data . length - _ NUM ) ; if ( start Index > end Index ) start Index = end Index ; for ( int i = start Index ; i <= end Index ; i ++ ) { if (  Float . is Na N ( data [ i ] ) ) throw new  Illegal Argument Exception ( _ STR ) ; mean += data [ i ] ; total ++ ; } mean /= total ; return mean ; }
public static  String construct NTPtime ( long date ) { long ntp Time = _ NUM ; long start Time = ( date /  SECONDS_ TO_ MILLISECONDS_ CONVERSION_ RATE ) + ntp Time ; return  String . value Of ( start Time ) ; }
protected  Media Type select Media Type (  Server Web Exchange exchange ,  List <  Media Type > producible Types ) {  List <  Media Type > acceptable Types = get Acceptable Types ( exchange ) ; producible Types = get Producible Types ( exchange , producible Types ) ;  Set <  Media Type > compatible Media Types = new  Linked Hash Set < > ( ) ; for (  Media Type acceptable : acceptable Types ) { for (  Media Type producible : producible Types ) { if ( acceptable . is Compatible With ( producible ) ) { compatible Media Types . add ( select More Specific Media Type ( acceptable , producible ) ) ; } } }  List <  Media Type > result = new  Array List < > ( compatible Media Types ) ;  Media Type . sort By Specificity And Quality ( result ) ; for (  Media Type media Type : compatible Media Types ) { if ( media Type . is Concrete ( ) ) { return media Type ; } else if ( media Type . equals (  Media Type .  ALL ) || media Type . equals (  MEDIA_ TYPE_ APPLICATION_ ALL ) ) { return  Media Type .  APPLICATION_ OCTET_ STREAM ; } } return null ; }
public void paint Border (  Component c ,  Graphics g , int x , int y , int width , int height ) { if ( ! ( c instanceof  JPopup Menu ) ) { return ; }  Font orig Font = g . get Font ( ) ;  Color orig Color = g . get Color ( ) ;  JPopup Menu popup = (  JPopup Menu ) c ;  String title = popup . get Label ( ) ; if ( title == null ) { return ; } g . set Font ( font ) ;  Font Metrics fm =  Swing Utilities2 . get Font Metrics ( popup , g , font ) ; int font Height = fm . get Height ( ) ; int descent = fm . get Descent ( ) ; int ascent = fm . get Ascent ( ) ;  Point text Loc = new  Point ( ) ; int string Width =  Swing Utilities2 . string Width ( popup , fm , title ) ; text Loc . y = y + ascent +  TEXT_ SPACING ; text Loc . x = x + ( ( width - string Width ) / _ NUM ) ; g . set Color ( background ) ; g . fill Rect ( text Loc . x -  TEXT_ SPACING , text Loc . y - ( font Height - descent ) , string Width + ( _ NUM *  TEXT_ SPACING ) , font Height - descent ) ; g . set Color ( foreground ) ;  Swing Utilities2 . draw String ( popup , g , title , text Loc . x , text Loc . y ) ;  Motif Graphics Utils . draw Groove ( g , x , text Loc . y +  TEXT_ SPACING , width ,  GROOVE_ HEIGHT , shadow Color , highlight Color ) ; g . set Font ( orig Font ) ; g . set Color ( orig Color ) ; }
public void ensure Capacity ( int mincap ) { if ( mincap > array . length ) { int newcap = ( ( array . length * _ NUM ) > > _ NUM ) + _ NUM ; int [ ] olddata = array ; array = new int [ newcap < mincap ? mincap : newcap ] ;  System . arraycopy ( olddata , _ NUM , array , _ NUM , size ) ; } }
public void invalidate And Unmap (  Byte Buffer ... bufs ) throws  IOException { if ( cleaner != null ) { invalidated = _ BOOL ; barrier . lazy Set ( _ NUM ) ;  Thread . yield ( ) ; for (  Byte Buffer b : bufs ) { cleaner . free Buffer ( resource Description , b ) ; } } }
public int add Dir (  File file ) { if ( ! file . exists ( ) ) { return _ NUM ; }  String [ ] names = get Names ( get Files ( file , _ STR ) ) ; load Class ( file , names ) ; return _ NUM ; }
@  Override public boolean equals (  Object obj ) { if ( obj == this ) { return _ BOOL ; } if ( ! ( obj instanceof  Bubble XYItem Label Generator ) ) { return _ BOOL ; } if ( ! super . equals ( obj ) ) { return _ BOOL ; }  Bubble XYItem Label Generator that = (  Bubble XYItem Label Generator ) obj ; if ( !  Object Utilities . equal ( this . z Format , that . z Format ) ) { return _ BOOL ; } if ( !  Object Utilities . equal ( this . z Date Format , that . z Date Format ) ) { return _ BOOL ; } return _ BOOL ; }
public static boolean has Element Child (  Node node ) {  Node List nl = node . get Child Nodes ( ) ;  Node child = null ; int length = nl . get Length ( ) ; for ( int i = _ NUM ; i < length ; i ++ ) { child = nl . item ( i ) ; if ( child . get Node Type ( ) ==  Node .  ELEMENT_ NODE ) { return _ BOOL ; } } return _ BOOL ; }
public void del Item ( int index ) { synchronized ( get Menu Tree Lock ( ) ) { if ( selected Index == index ) { select Item ( null , _ BOOL ) ; } else if ( selected Index > index ) { selected Index -- ; } if ( index < items . size ( ) ) { items . remove ( index ) ; } else { if ( log . is Loggable (  Platform Logger .  Level .  FINE ) ) { log . fine ( _ STR + index + _ STR + items . size ( ) ) ; } } } update Size ( ) ; }
public static int count CSSPrimitive Names ( ) { return  ALL_ PRIMITIVE_ PROPERTY_ NAMES . size ( ) ; }
private void check Permission (  Object object ,  Namespace Permission Enum [ ] permissions ,  List <  Access Denied Exception > access Denied Exceptions ) { if ( object != null ) { if ( object instanceof  Collection ) {  Collection < ? > collection = (  Collection < ? > ) object ; for (  Object element : collection ) { check Permission ( element , permissions , access Denied Exceptions ) ; } } else if ( object instanceof  String ) { try { check Permission ( (  String ) object , permissions ) ; } catch (  Access Denied Exception access Denied Exception ) { access Denied Exceptions . add ( access Denied Exception ) ; } } else { throw new  Illegal State Exception (  String . format ( _ STR ,  String . class ,  Collection . class , object . get Class ( ) ) ) ; } } }
private static  Intent create Map Activity Intent (  Context context ,  URLSpan [ ] url Spans ) { for ( int span_i = _ NUM ; span_i < url Spans . length ; span_i ++ ) {  URLSpan url Span = url Spans [ span_i ] ;  String url String = url Span . get URL ( ) ; if ( url String . starts With (  GEO_ PREFIX ) ) {  Intent geo Intent = new  Intent (  Intent .  ACTION_ VIEW ,  Uri . parse ( url String ) ) ; geo Intent . add Flags (  Intent .  FLAG_ ACTIVITY_ NEW_ TASK ) ; return geo Intent ; } } return null ; }
private  String Builder generate Parameters ( ) {  String Builder parameters = new  String Builder ( ) ; if ( filter Map == null && expand Parameters == null ) { return parameters ; } parameters . append ( _ STR ) ; int filter Parameter Counter = _ NUM ; if ( filter Map != null && ! filter Map . is Empty ( ) ) { parameters . append (  FILTER_ PREFIX ) ; for (  Map .  Entry <  String ,  String > filter Entry : filter Map . entry Set ( ) ) { parameters . append (  String . format ( _ STR , filter Entry . get Key ( ) , filter Entry . get Value ( ) ) ) ; if ( ++ filter Parameter Counter < filter Map . size ( ) ) { parameters . append ( _ STR ) ; } } if ( expand Parameters != null ) { parameters . append ( _ STR ) ; } } if ( expand Parameters != null ) { parameters . append (  EXPAND_ PREFIX ) ;  Iterator iterator = expand Parameters . iterator ( ) ; parameters . append (  String . format ( _ STR , iterator . next ( ) ) ) ; while ( iterator . has Next ( ) ) { parameters . append (  String . format ( _ STR , iterator . next ( ) ) ) ; } } return parameters ; }
public static @  Check For Null @  Slashed Class Name  String from Field Signature (  String signature ) { if ( signature . char At ( _ NUM ) != _ STR ) { return null ; } return signature . substring ( _ NUM , signature . length ( ) - _ NUM ) ; }
private void paint Preview ( int dx , int dy , float zoomfactor ) { if ( image != null ) {  Graphics2 D g2 = (  Graphics2 D ) get Graphics ( ) ;  UColor bg = renderer . get Background Color ( ) ; g2 . set Background ( new  Color ( bg . get Red ( ) , bg . get Green ( ) , bg . get Blue ( ) , bg . get Alpha ( ) ) ) ; int new Width =  Math . round ( image . get Width ( null ) * zoomfactor ) ; int new Height = ( int )  Math . round ( image . get Height ( null ) * zoomfactor ) ; g2 . draw Image ( image , dx , dy , new Width , new Height , null ) ; if ( dx > _ NUM ) g2 . clear Rect ( _ NUM , _ NUM , dx , get Height ( ) ) ; else g2 . clear Rect ( get Width ( ) + dx , _ NUM , get Width ( ) , get Height ( ) ) ; if ( dy > _ NUM ) g2 . clear Rect ( _ NUM , _ NUM , get Width ( ) , dy ) ; else g2 . clear Rect ( _ NUM , get Height ( ) + dy , get Width ( ) , get Height ( ) ) ; } }
public static  List <  List <  Double > > partition Variable (  List <  Double > arr , int chunk ) { int count = _ NUM ;  List <  List <  Double > > ret = new  Array List <  List <  Double > > ( ) ; while ( count < arr . size ( ) ) {  List <  Double > sublist = arr . sub List ( count , count + chunk ) ; count += chunk ; ret . add ( sublist ) ; } for (  List <  Double > lists : ret ) { if ( lists . size ( ) < chunk ) ret . remove ( lists ) ; } return ret ; }
private static void update Window UI (  Window window ) {  Swing Utilities . update Component Tree UI ( window ) ;  Window owned Wins [ ] = window . get Owned Windows ( ) ; for (  Window owned Win : owned Wins ) { update Window UI ( owned Win ) ; } }
public  Array List <  Constraint Widget > find Widgets (  Widget Container container , int x , int y , int width , int height ) {  Array List <  Constraint Widget > found = new  Array List < > ( ) ;  Rectangle area = new  Rectangle ( x , y , width , height ) ; for (  Constraint Widget widget : container . get Children ( ) ) {  Widget Companion companion = (  Widget Companion ) widget . get Companion Widget ( ) ;  Widget Decorator decorator = companion . get Widget Decorator (  Widget Decorator .  BLUEPRINT_ STYLE ) ; if ( ! decorator . is Visible ( ) ) { continue ; }  Rectangle bounds = new  Rectangle ( widget . get Draw X ( ) , widget . get Draw Y ( ) , widget . get Width ( ) , widget . get Height ( ) ) ; if ( area . intersects ( bounds ) ) { found . add ( widget ) ; } } return found ; }
public final void print Symbol (  Char Sequence text ) throws  IOException { if ( text == null ) { append Ascii ( _ STR ) ; } else if ( text . length ( ) == _ NUM ) { throw new  Empty Symbol Exception ( ) ; } else if ( symbol Needs Quoting ( text , _ BOOL ) ) { append Ascii ( _ STR ) ; print Code Points ( text ,  SYMBOL_ ESCAPE_ CODES ) ; append Ascii ( _ STR ) ; } else { append Ascii ( text ) ; } }
@  Override public  String to String ( ) {  Map <  Assignment ,  Double > sorted Table =  Inference Utils . get NBest ( table ,  Math . max ( table . size ( ) , _ NUM ) ) ;  String str = _ STR ; for (  Entry <  Assignment ,  Double > entry : sorted Table . entry Set ( ) ) {  String prob =  String Utils . get Short Form ( entry . get Value ( ) ) ; str += _ STR + entry . get Key ( ) + _ STR + prob + _ STR ; } return ( str . length ( ) > _ NUM ) ? str . substring ( _ NUM , str . length ( ) - _ NUM ) : str ; }
protected final void update Border Text ( final  String text ) {  Preconditions . check Not Null ( text , _ STR ) ; m_titled Border . set Title ( text ) ; update UI ( ) ; }
private void add Classes (  Class < ? > [ ] classes ,  Hash Set <  Class < ? > > result ,  String field Name ) { if ( classes == null || classes . length == _ NUM )  Error . classes Absent ( field Name , configured Class ) ; for (  Class < ? > classe : classes ) result . add ( classe ) ; }
public void reset References ( ) { if ( _refs != null ) _refs . clear ( ) ; }
public void schema Changed (  String service Name ,  String version ) { synchronized ( map Realm To Format ) { map Realm To Format . remove (  ROOT ) ; } }
protected  Date Time Data parse (  String str ) throws  Schema Date Time Exception {  Date Time Data date = new  Date Time Data ( str , this ) ; int len = str . length ( ) ; date . year =  YEAR ; date . day =  DAY ; if ( str . char At ( _ NUM ) != _ STR || str . char At ( _ NUM ) != _ STR ) { throw new  Schema Date Time Exception ( _ STR + str ) ; } int stop = _ NUM ; date . month = parse Int ( str , _ NUM , stop ) ; if ( str . length ( ) >= stop + _ NUM && str . char At ( stop ) == _ STR && str . char At ( stop + _ NUM ) == _ STR ) { stop += _ NUM ; } if ( stop < len ) { if ( ! is Next Char UTCSign ( str , stop , len ) ) { throw new  Schema Date Time Exception ( _ STR + str ) ; } else { get Time Zone ( str , date , stop , len ) ; } } validate Date Time ( date ) ; save Unnormalized ( date ) ; if ( date . utc != _ NUM && date . utc != _ STR ) { normalize ( date ) ; } date . position = _ NUM ; return date ; }
private void add To Queue (  Serial Message serial Message ) { if ( serial Message == null ) { return ; } if ( ! msg Queue . contains ( serial Message ) && msg Queue . remaining Capacity ( ) > _ NUM ) { msg Queue . add ( serial Message ) ; } send Message ( ) ; }
private  DBID string To DBID (  String query ) { return  DBIDUtil . import Integer (  Integer . value Of ( query ) ) ; }
@  Override public final void write Short ( int v ) throws  IOException { work [ _ NUM ] = ( byte ) v ; work [ _ NUM ] = ( byte ) ( v > > _ NUM ) ; dis . write ( work , _ NUM , _ NUM ) ; }
final public void println ( long v ) {  Writer out = this . out ; if ( out == null ) return ; print ( v ) ; try { out . write ( _newline , _ NUM , _newline . length ) ; } catch (  IOException e ) { log . log (  Level .  FINE , e . to String ( ) , e ) ; } }
public  Thrift Service Metadata (  Class < ? > service Type ) { require Non Null ( service Type , _ STR ) ; interfaces = init ( null ,  Collections . singleton ( service Type ) ) ; }
public  Writable Raster create Compatible Writable Raster ( int w , int h ) { if ( w <= _ NUM || h <= _ NUM ) { throw new  Raster Format Exception ( _ STR + ( ( w <= _ NUM ) ? _ STR : _ STR ) ) ; }  Sample Model sm = sample Model . create Compatible Sample Model ( w , h ) ; return new  Byte Packed Raster ( sm , new  Point ( _ NUM , _ NUM ) ) ; }
public static  Response invalid Entity (  Constraint Violation Exception e ) {  String Builder error Message = new  String Builder ( ) ; boolean first Pass = _ BOOL ; for (  Constraint Violation error : e . get Constraint Violations ( ) ) { if ( ! first Pass ) { error Message . append ( _ STR ) ; } error Message . append (  String . format ( _ STR , error . get Property Path ( ) , error . get Message ( ) , error . get Invalid Value ( ) ) ) ; first Pass = _ BOOL ; }  External Exception external Exception = new  External Exception (  Error Code .  INVALID_ ENTITY , error Message . to String ( ) , null ) ; return external Exception ( external Exception ) ; }
public  String check Start Block ( int mode ) { if ( log . is Debug Enabled ( ) ) log . debug ( _ STR + get Display Name ( ) + _ STR ) ;  Block Order bo = _orders . get ( _ NUM ) ;  OBlock block = bo . get Block ( ) ;  String msg = block . allocate ( this ) ; if ( msg != null ) { return msg ; } msg = bo . set Path ( this ) ; if ( msg != null ) { return msg ; } int state = block . get State ( ) ; if ( ( state &  OBlock .  DARK ) != _ NUM || _temp Run Blind ) { msg =  Bundle . get Message ( _ STR , block . get Display Name ( ) ) ; } else if ( ( state &  OBlock .  OCCUPIED ) == _ NUM ) { if ( mode ==  MODE_ LEARN ) { msg = _ STR ; } else { msg = _ STR ; } msg =  Bundle . get Message ( msg , get Train Name ( ) , block . get Display Name ( ) ) ; } else {  Tracker Table Action . stop Tracker In ( block ) ; } return msg ; }
private void parse Switch ( int indent , boolean first Content ,  String header ,  Layout layout ,  List <  Elem > elems ) {  Token Stream tokens = new  Token Stream ( header ) ;  Elem selector = parse Expr ( tokens ) ; tokens . check At End ( ) ;  Immutable List .  Builder <  Case > cases =  Immutable List . builder ( ) ;  List <  Elem > default Elems = null ; boolean done ;  String line = get Next Line ( ) ;  Matcher matcher =  COMMAND_ LINE . matcher ( line ) ;  String command ;  String rest ; if ( matcher . find ( ) ) { command = matcher . group (  COMMAND_ NAME_ GROUP ) ; rest = line . substring ( matcher . end ( ) ) ; done = _ BOOL ; } else { error ( _ STR ) ; done = _ BOOL ; command = null ; rest = null ; } while ( ! done ) { switch ( command ) { case  END_ COMMAND : check Header Empty ( command , rest ) ; done = _ BOOL ; break ; case  DEFAULT_ COMMAND : check Header Empty ( command , rest ) ; if ( default Elems != null ) { error ( _ STR ) ; } default Elems = parse Until ( indent , layout ,  END_ COMMAND ) ; command = last Terminator ; rest = last Terminator Header ; done = last Terminator == null ; break ; case  CASE_ COMMAND : tokens = new  Token Stream ( rest ) ;  Elem value = parse Expr ( tokens ) ; tokens . check At End ( ) ;  List <  Elem > case Elems = parse Until ( indent , layout ,  END_ COMMAND ,  CASE_ COMMAND ,  DEFAULT_ COMMAND ) ; if ( value != null ) { cases . add (  Case . create ( value , case Elems ) ) ; } command = last Terminator ; rest = last Terminator Header ; done = last Terminator == null ; break ; default : unexpected Command Error ( command ) ; done = _ BOOL ; break ; } } if ( selector != null ) { elems . add (  Block . create ( ! first Content ,  Switch . create ( input . location ( ) , selector , cases . build ( ) , default Elems ) ) ) ; } }
public void init (  String prefix , java . net .  URL url ) { try { java . io .  Input Stream in = url . open Stream ( ) ;  Properties props = new  Properties ( ) ; props . load ( in ) ; init ( get Layers ( prefix , props ) ) ; } catch ( java . net .  Malformed URLException murle ) { logger . warning ( _ STR + url + _ STR ) ; } catch ( java . io .  IOException e ) { logger . warning ( _ STR ) ; } }
public static  Properties create Properties ( final  Map <  String ,  String > map ) {  Properties properties = new  Properties ( ) ; if ( ! ( map == null || map . is Empty ( ) ) ) { for (  Entry <  String ,  String > entry : map . entry Set ( ) ) { properties . set Property ( entry . get Key ( ) , entry . get Value ( ) ) ; } } return properties ; }
public  Node select First (  String query ) {  List <  Node > selected Nodes = select ( query ) ; if ( selected Nodes . is Empty ( ) ) { return null ; } return selected Nodes . get ( _ NUM ) ; }
public static  String [ ] string Array From Properties (  Properties p ,  String prop Name ,  String tok ) {  String [ ] ret = null ;  String raw = p . get Property ( prop Name ) ; if ( raw != null && raw . length ( ) > _ NUM ) { try {  String Tokenizer token = new  String Tokenizer ( raw , tok ) ; int num Paths = token . count Tokens ( ) ; ret = new  String [ num Paths ] ; for ( int i = _ NUM ; i < num Paths ; i ++ ) { ret [ i ] = token . next Token ( ) ; } return ret ; } catch ( java . util .  No Such Element Exception e ) { e . print Stack Trace ( ) ; } } return ret ; }
public void generate ( int x1 , int y1 , int x2 , int y2 ) {  Point mid Point = new  Point ( ) ;  Point arc Center = new  Point ( ) ;  Point2 D peak Point = new  Point2 D .  Float ( ) ; double distance =  Math . sqrt (  Math . pow (  Math . abs ( y2 - y1 ) , _ NUM ) +  Math . pow (  Math . abs ( x2 - x1 ) , _ NUM ) ) ; double straight Line Slope =  Math . atan ( ( double ) ( y2 - y1 ) / ( double ) ( x2 - x1 ) ) ; double inverse Slope = straight Line Slope - (  Math .  PI / _ NUM ) ; if (  Debug . debugging ( _ STR ) ) {  Debug . output ( _ STR +  Math . to Degrees ( straight Line Slope ) + _ STR + distance + _ STR ) ; } mid Point . set Location ( x1 + ( ( x2 - x1 ) / _ NUM ) , y1 + ( ( y2 - y1 ) / _ NUM ) ) ; if (  Debug . debugging ( _ STR ) ) {  Debug . output ( _ STR + x1 + _ STR + y1 + _ STR + x2 + _ STR + y2 + _ STR + mid Point . x + _ STR + mid Point . y + _ STR ) ; } double arccos =  Math . cos ( arc Angle ) ; double arc Radius ; if ( arccos != _ NUM ) { arc Radius = distance /  Math . sqrt ( _ NUM * ( _ NUM -  Math . cos ( arc Angle ) ) ) ; } else { arc Radius = distance /  Math . sqrt ( _ NUM ) ; } if (  Debug . debugging ( _ STR ) ) {  Debug . output ( _ STR + arc Radius ) ; } double x = arc Radius - arc Radius *  Math . cos ( arc Angle ) ; double r Prime = ( distance / _ NUM ) * (  Math . sqrt ( _ NUM -  Math . pow ( x / distance , _ NUM ) ) ) /  Math . sin ( arc Angle / _ NUM ) ; if (  Debug . debugging ( _ STR ) ) {  Debug . output ( _ STR + r Prime ) ; } int direction = _ NUM ; if ( arc Up ) direction = - _ NUM ; arc Center . x = mid Point . x + ( direction * ( int ) ( r Prime *  Math . cos ( inverse Slope ) ) ) ; arc Center . y = mid Point . y + ( direction * ( int ) ( r Prime *  Math . sin ( inverse Slope ) ) ) ; if (  Debug . debugging ( _ STR ) ) {  Debug . output ( _ STR ) ; arc Graphics = new  OMGraphic List ( ) ; double dist1 =  Math . sqrt (  Math . pow ( ( double ) ( arc Center . x - x1 ) , _ NUM ) +  Math . pow ( ( double ) ( arc Center . y - y1 ) , _ NUM ) ) ; double dist2 =  Math . sqrt (  Math . pow ( ( double ) ( arc Center . x - x2 ) , _ NUM ) +  Math . pow ( ( double ) ( arc Center . y - y2 ) , _ NUM ) ) ;  Debug . output ( _ STR + arc Center . x + _ STR + arc Center . y + _ STR +  Math . to Degrees ( inverse Slope ) + _ STR ) ;  Debug . output ( _ STR + dist1 + _ STR + dist2 ) ;  OMRect point1 = new  OMRect ( x1 - _ NUM , y1 - _ NUM , x1 + _ NUM , y1 + _ NUM ) ;  OMRect point2 = new  OMRect ( x2 - _ NUM , y2 - _ NUM , x2 + _ NUM , y2 + _ NUM ) ;  OMRect arc Point = new  OMRect ( arc Center . x - _ NUM , arc Center . y - _ NUM , arc Center . x + _ NUM , arc Center . y + _ NUM ) ; point1 . set Line Paint (  OMColor . red ) ; point2 . set Line Paint (  OMColor . red ) ; arc Point . set Line Paint (  OMColor . blue ) ; arc Graphics . add ( point1 ) ; arc Graphics . add ( point2 ) ; arc Graphics . add ( arc Point ) ;  OMLine line1 = new  OMLine ( x1 , y1 , x2 , y2 ) ;  OMLine line2 = new  OMLine ( mid Point . x , mid Point . y , arc Center . x , arc Center . y ) ; arc Graphics . add ( line1 ) ; arc Graphics . add ( line2 ) ; } int real Count = _ NUM ; double start Slope = get Real Angle ( ( float ) arc Center . get X ( ) , ( float ) arc Center . get Y ( ) , x1 , y1 ) ; double end Slope = get Real Angle ( ( float ) arc Center . get X ( ) , ( float ) arc Center . get Y ( ) , x2 , y2 ) ; double small Slope , large Slope ; double angle Increment ; small Slope = ( start Slope > end Slope ) ? end Slope : start Slope ; large Slope = ( small Slope == start Slope ) ? end Slope : start Slope ; while (  Math . abs ( small Slope - large Slope ) >  Math .  PI ) { if (  Math . abs ( large Slope - small Slope -  Math .  PI ) < _ NUM ) { break ; }  Debug . message ( _ STR , _ STR ) ; double tmp Slope = small Slope +  More Math .  TWO_ PI ; small Slope = large Slope ; large Slope = tmp Slope ; } if (  More Math . approximately_equal ( arc Angle ,  Math .  PI ) && arc Up ) {  Debug . message ( _ STR , _ STR ) ; double tmp Slope = small Slope +  More Math .  TWO_ PI ; small Slope = large Slope ; large Slope = tmp Slope ; } if (  Math . abs ( y2 - y1 ) <  Math . abs ( x2 - x1 ) ) { angle Increment =  Math .  PI /  Math . abs ( x2 - x1 ) ; } else { angle Increment =  Math .  PI /  Math . abs ( y2 - y1 ) ; } int num Points = ( int ) (  Math . abs ( small Slope - large Slope ) / angle Increment + _ NUM ) ; float [ ] x Points = new float [ num Points ] ; float [ ] y Points = new float [ num Points ] ; if (  Debug . debugging ( _ STR ) ) {  Debug . output ( _ STR + start Slope + _ STR +  Math . to Degrees ( start Slope ) + _ STR + end Slope + _ STR +  Math . to Degrees ( end Slope ) + _ STR ) ;  Debug . output ( _ STR + small Slope + _ STR +  Math . to Degrees ( small Slope ) + _ STR + large Slope + _ STR +  Math . to Degrees ( large Slope ) + _ STR + angle Increment + _ STR +  Math . to Degrees ( angle Increment ) + _ STR ) ; } reversed = _ BOOL ; while ( small Slope < large Slope && real Count < num Points ) { x Points [ real Count ] = arc Center . x + ( int ) ( arc Radius *  Math . cos ( small Slope ) ) ; y Points [ real Count ] = arc Center . y + ( int ) ( arc Radius *  Math . sin ( small Slope ) ) ; if ( real Count == _ NUM && x Points [ real Count ] == x2 ) {  Debug . message ( _ STR , _ STR ) ; reversed = _ BOOL ; } if (  Debug . debugging ( _ STR ) && real Count == _ NUM ) {  OMLine start Line = new  OMLine ( arc Center . x , arc Center . y , ( int ) x Points [ _ NUM ] , ( int ) y Points [ _ NUM ] ) ; start Line . set Line Paint (  OMColor . white ) ; arc Graphics . add ( start Line ) ; } else if (  Debug . debugging ( _ STR ) ) {  Debug . output ( _ STR + small Slope + _ STR + small Slope * _ NUM /  Math .  PI + _ STR + x Points [ real Count ] + _ STR + y Points [ real Count ] ) ; } if (  Math . abs ( large Slope - small Slope - ( arc Angle / _ NUM ) ) < angle Increment ) { peak Point . set Location ( x Points [ real Count ] , y Points [ real Count ] ) ;  Debug . message ( _ STR , _ STR ) ; } small Slope += angle Increment ; real Count ++ ; } xpoints = new float [ real Count ] ; ypoints = new float [ real Count ] ;  System . arraycopy ( x Points , _ NUM , xpoints , _ NUM , real Count ) ;  System . arraycopy ( y Points , _ NUM , ypoints , _ NUM , real Count ) ; }
private static int compare Locales (  Locale primary ,  Locale other ) { final  String lang = primary . get Language ( ) ; if ( ( lang == null ) || ! lang . equals ( other . get Language ( ) ) ) { return _ NUM ; } final  String country = primary . get Country ( ) ; if ( ( country == null ) || ! country . equals ( other . get Country ( ) ) ) { return _ NUM ; } final  String variant = primary . get Variant ( ) ; if ( ( variant == null ) || ! variant . equals ( other . get Variant ( ) ) ) { return _ NUM ; } return _ NUM ; }
void query Read Result (  Prepared Statement prep ) throws  SQLException {  Result Set rs = prep . execute Query ( ) ;  Result Set Meta Data meta = rs . get Meta Data ( ) ; int column Count = meta . get Column Count ( ) ; while ( rs . next ( ) ) { for ( int i = _ NUM ; i < column Count ; i ++ ) { rs . get String ( i + _ NUM ) ; } } }
public boolean equals (  Object obj ) { if ( obj instanceof  MSort ) {  MSort ms = (  MSort ) obj ; if ( data == ms . data ) return _ BOOL ; } return _ BOOL ; }
public static void end Transaction ( final  CConnection connection ) throws  SQLException { end Transaction ( connection . get Connection ( ) ) ; }
public  CCross References Panel ( ) { super ( new  Border Layout ( ) ) ; m_table . set Selection Mode (  List Selection Model .  SINGLE_ SELECTION ) ; add ( new  JScroll Pane ( m_table ) ) ; m_table . add Mouse Listener ( new  Internal Mouse Listener ( ) ) ; }
private void change Open AMDebug Folder (  String new Open AMDebug Folder ) {  System Properties Manager . initialize Properties (  Debug Constants .  CONFIG_ DEBUG_ DIRECTORY , new Open AMDebug Folder ) ; }
protected  String compute Full Url (  URL base Url ,  String link ) { if ( link == null || link . length ( ) == _ NUM ) { return null ; } if ( ! link . starts With ( _ STR ) ) { if ( link . starts With ( _ STR ) ) { link = base Url . get Protocol ( ) + _ STR + base Url . get Authority ( ) + link ; } else { if ( link . contains ( _ STR ) ) { return null ; }  String path = base Url . get Path ( ) ; if ( ! path . ends With ( _ STR ) ) { int sep = path . last Index Of ( _ STR ) ;  String file = path . substring ( sep + _ NUM ) ; if ( file . contains ( _ STR ) || file . contains ( _ STR ) ) path = path . substring ( _ NUM , sep ) ; } link = base Url . get Protocol ( ) + _ STR + base Url . get Authority ( ) + path + _ STR + link ; } } link = normalize Url Ending ( link ) ;  String l = link . to Lower Case (  Locale .  ROOT ) ; if ( l . ends With ( _ STR ) || l . ends With ( _ STR ) || l . ends With ( _ STR ) || l . ends With ( _ STR ) ) { return null ; } return link ; }
private void load Manifest ( ) { if ( _is Manifest Read ) return ; synchronized ( this ) { if ( _is Manifest Read ) return ; try { _manifest = _jar Path . get Manifest ( ) ; if ( _manifest == null ) return ;  Attributes attr = _manifest . get Main Attributes ( ) ; if ( attr != null ) add Manifest Package ( _ STR , attr ) ;  Map <  String ,  Attributes > entries = _manifest . get Entries ( ) ; for (  Map .  Entry <  String ,  Attributes > entry : entries . entry Set ( ) ) {  String pkg = entry . get Key ( ) ; attr = entry . get Value ( ) ; if ( attr == null ) continue ; add Manifest Package ( pkg , attr ) ; } } catch (  IOException e ) { log . log (  Level .  WARNING , e . to String ( ) , e ) ; } finally { _is Manifest Read = _ BOOL ; } } }
public  Reference Binding [ ] convert To Raw Types (  Reference Binding [ ] original Types , boolean force Erasure , boolean force Raw Enclosing Type ) { if ( original Types == null ) return null ;  Reference Binding [ ] converted Types = original Types ; for ( int i = _ NUM , length = original Types . length ; i < length ; i ++ ) {  Reference Binding original Type = original Types [ i ] ;  Reference Binding converted Type = (  Reference Binding ) convert To Raw Type ( force Erasure ? original Type . erasure ( ) : original Type , force Raw Enclosing Type ) ; if ( converted Type != original Type ) { if ( converted Types == original Types ) {  System . arraycopy ( original Types , _ NUM , converted Types = new  Reference Binding [ length ] , _ NUM , i ) ; } converted Types [ i ] = converted Type ; } else if ( converted Types != original Types ) { converted Types [ i ] = original Type ; } } return converted Types ; }
public void add Column ( int idx ,  Column column ) { if ( column != null ) { columns . add ( idx , column ) ; } }
boolean remove Display (  Display display ) { return m_displays . remove ( display ) ; }
public double next Gaussian ( ) { if ( m Have Next Next Gaussian ) { m Have Next Next Gaussian = _ BOOL ; return m Next Next Gaussian ; } else { double v1 , v2 , s ; do { v1 = _ NUM * next Double ( ) - _ NUM ; v2 = _ NUM * next Double ( ) - _ NUM ; s = v1 * v1 + v2 * v2 ; } while ( s >= _ NUM || s == _ NUM ) ; final double multiplier =  Strict Math . sqrt ( - _ NUM *  Strict Math . log ( s ) / s ) ; m Next Next Gaussian = v2 * multiplier ; m Have Next Next Gaussian = _ BOOL ; return v1 * multiplier ; } }
private void fire Event ( final  IRunning Query q ) { if ( q == null ) throw new  Illegal Argument Exception ( ) ; if ( listeners . is Empty ( ) ) { return ; } final  IRunning Query Listener [ ] a = listeners . to Array ( new  IRunning Query Listener [ _ NUM ] ) ; for (  IRunning Query Listener l : a ) { final  IRunning Query Listener listener = l ; try { listener . notify ( q ) ; } catch (  Throwable t ) { if (  Inner Cause . is Inner Cause ( t ,  Interrupted Exception . class ) ) { throw new  Runtime Exception ( t ) ; } log . error ( t , t ) ; } } }
private void update Contact Header Port ( int local Port ,  SIPMessage message ) { if ( message != null && message . get Contact Header ( ) != null ) {  Contact Header contact Header = message . get Contact Header ( ) ;  Address contact Address = contact Header . get Address ( ) ; contact Address . set Port ( local Port ) ; } }
@  Nullable  Grid Cache Mvcc Candidate add Entry (  Grid Local Cache Entry entry ) throws  Grid Cache Entry Removed Exception {  Grid Cache Mvcc Candidate c = entry . add Local ( thread Id , lock Ver , null , null , timeout , ! in Tx ( ) , in Tx ( ) , implicit Single ( ) , _ BOOL ) ; entries . add ( entry ) ; if ( c == null && timeout < _ NUM ) { if ( log . is Debug Enabled ( ) ) log . debug ( _ STR + entry ) ; on Failed ( ) ; return null ; } if ( c != null ) { entry . ready Local ( c ) ; } return c ; }
@  Override public void visit Vertex (  Street Router .  State state ) {  Integer edge Idx = state . back Edge ; if ( ! ( edge Idx == null || edge Idx == - _ NUM ) ) {  Edge Store .  Edge edge = edge Store . get Cursor ( edge Idx ) ;  Geo Json Feature feature = new  Geo Json Feature ( edge . get Geometry ( ) ) ; feature . add Property ( _ STR , state . weight ) ; feature . add Property ( _ STR , state . street Mode ) ; feature . add Property ( _ STR , state . back Edge ) ; features . add ( feature ) ; } }
public void test_ BSBM_ Q1_no Solutions ( ) throws  Exception { final  Test Helper helper = new  Test Helper ( _ STR , _ STR , new  String [ ] { } , _ STR ) ; assert Same Join Order ( new int [ ] { _ NUM , _ NUM , _ NUM , _ NUM , _ NUM } , helper ) ; }
public static void delete File Or Log (  File file ) { if ( ! file . delete ( ) ) { logger . warn (  FAILED_ DELETING_ FILE + file . get Path ( ) ) ; } }
public  Gitlab Group Member add Group Member (  Gitlab Group group ,  Gitlab User user ,  Gitlab Access Level access Level ) throws  IOException { return add Group Member ( group . get Id ( ) , user . get Id ( ) , access Level ) ; }
protected  Logger (  String name ,  String resource Bundle Name ) { super ( name , resource Bundle Name ) ; }
@  Override public void increment ( double coord , short val ) { int bin = get Bin Nr ( coord ) ; if ( bin < _ NUM ) { if ( size - bin > data . length ) { short [ ] tmpdata = new short [ grow Size ( data . length , size - bin ) ] ;  System . arraycopy ( data , _ NUM , tmpdata , - bin , size ) ; data = tmpdata ; } else {  System . arraycopy ( data , _ NUM , data , - bin , size ) ;  Arrays . fill ( data , _ NUM , - bin , ( short ) _ NUM ) ; } data [ _ NUM ] = val ; assert ( data . length >= size - bin ) ; offset -= bin ; size -= bin ; } else if ( bin >= data . length ) { short [ ] tmpdata = new short [ grow Size ( data . length , bin + _ NUM ) ] ;  System . arraycopy ( data , _ NUM , tmpdata , _ NUM , size ) ; tmpdata [ bin ] = val ; data = tmpdata ; size = bin + _ NUM ; max =  Double .  MAX_ VALUE ; } else { if ( bin >= size ) { size = bin + _ NUM ; } data [ bin ] += val ; } }
default  Document put All (  Map < ? extends  Char Sequence ,  Object > fields ) { if ( fields != null ) { for (  Map .  Entry < ? extends  Char Sequence ,  Object > entry : fields . entry Set ( ) ) { set ( entry . get Key ( ) , entry . get Value ( ) ) ; } } return this ; }
public static double compute MAD ( double [ ] x , double median ) { for ( int i = _ NUM ; i < x . length ; i ++ ) { x [ i ] =  Math . abs ( x [ i ] - median ) ; } double mad =  Quick Select . median ( x ) ; if ( ! ( mad > _ NUM ) ) { double min =  Double .  POSITIVE_ INFINITY ; for ( double xi : x ) { if ( xi > _ NUM && xi < min ) { min = xi ; } } if ( min <  Double .  POSITIVE_ INFINITY ) { mad = min ; } else { mad = _ NUM ; } } return mad ; }
private static <  T > void initialize Known Plugins ( final  T plugin Interface , final  IPlugin Registry <  IPlugin <  T > > registry , final  List <  Plugin Config Item > xml Plugin Order , final  List <  Pair <  IPlugin <  T > ,  Plugin Status > > validated Plugins , final  List <  Pair <  IPlugin <  T > ,  Exception > > initialized Plugins , final  Set <  Long > processed Plugins ) { for ( final  Plugin Config Item pt : xml Plugin Order ) { processed Plugins . add ( pt . get GUID ( ) ) ; final  IPlugin <  T > plugin = find Plugin ( validated Plugins , pt . get GUID ( ) ) ; if ( plugin != null ) { if ( pt . is Load ( ) ) { initialize Plugin ( plugin , plugin Interface , registry , initialized Plugins ) ; } else { registry . add Disabled Plugin ( plugin ,  Disabled Plugin Reason .  Not Loaded ) ; } } } }
public static void session Stop ( ) { if ( m Process == null ) return ; m Process . destroy ( ) ; m Process = null ; }
public static  Request new Upload Video Request (  Session session ,  File file ,  Callback callback ) throws  File Not Found Exception {  Parcel File Descriptor descriptor =  Parcel File Descriptor . open ( file ,  Parcel File Descriptor .  MODE_ READ_ ONLY ) ;  Bundle parameters = new  Bundle ( _ NUM ) ; parameters . put Parcelable ( file . get Name ( ) , descriptor ) ; return new  Request ( session ,  MY_ VIDEOS , parameters ,  Http Method .  POST , callback ) ; }
private  Multicast Socket create Socket ( ) throws  IOException {  Multicast Socket sock = new  Multicast Socket ( mcast Port ) ; sock . set Loopback Mode ( _ BOOL ) ; if ( sock Itf != null ) sock . set Interface ( sock Itf ) ; if ( sock . get Loopback Mode ( ) )  U . warn ( log , _ STR + _ STR ) ; sock . join Group ( mcast Grp ) ; if ( ttl != - _ NUM ) sock . set Time To Live ( ttl ) ; return sock ; }
void copy Node Structure (  Array List <  Node > destination ) { while ( destination . size ( ) < nodes . size ( ) ) destination . add ( new  Node ( ) ) ; while ( destination . size ( ) > nodes . size ( ) ) destination . remove ( _ NUM ) ; int n = nodes . size ( ) ; for ( int i = _ NUM ; i < n ; i ++ ) {  Node node0 = nodes . get ( i ) ;  Node node1 = destination . get ( i ) ; node1 . height Parameter = node0 . height Parameter ; node1 . rate Parameter = node0 . rate Parameter ; node1 . trait Parameter = node0 . trait Parameter ; node1 . partitioning = node0 . partitioning ; node1 . taxon = node0 . taxon ; node1 . bifurcation = node0 . bifurcation ; node1 . number = node0 . number ; node1 . my Hash Code = node0 . my Hash Code ; if ( node0 . left Parent != null ) { node1 . left Parent = stored Nodes . get ( nodes . index Of ( node0 . left Parent ) ) ; } else { node1 . left Parent = null ; } if ( node0 . right Parent != null ) { node1 . right Parent = stored Nodes . get ( nodes . index Of ( node0 . right Parent ) ) ; } else { node1 . right Parent = null ; } if ( node0 . left Child != null ) { node1 . left Child = stored Nodes . get ( nodes . index Of ( node0 . left Child ) ) ; } else { node1 . left Child = null ; } if ( node0 . right Child != null ) { node1 . right Child = stored Nodes . get ( nodes . index Of ( node0 . right Child ) ) ; } else { node1 . right Child = null ; } } }
protected void check Selected Subset Meta Data (  Example Set Meta Data subset Meta Data ) { }
private void validate Will (  String dest ,  Object payload ) { if ( ( dest == null ) || ( payload == null ) ) { throw new  Illegal Argument Exception ( ) ; }  Mqtt Topic . validate ( dest , _ BOOL ) ; }
private  Member next Member (  Member .  Type type ) { return new  Test Member ( type , new  Address ( _ STR , ++ port ) , new  Address ( _ STR , port + _ NUM ) ) ; }
boolean is System Font ( ) { return system Font ; }
public void add To Be Loaded ( final  String url ) { if ( to Be Loaded == null ) { to Be Loaded = new  Array List <  String > ( ) ; } if (  String Utils . is Not Blank ( url ) ) { to Be Loaded . add ( url ) ; } }
default  Document put All (  Iterator <  Field > fields ) { while ( fields . has Next ( ) ) {  Field field = fields . next ( ) ; set Value ( field . get Name ( ) , field . get Value ( ) ) ; } return this ; }
public  Appraise Git Review Client (  Repository repo ) { this . repo = repo ; this . author = new  Person Ident ( repo ) ; }
public  Root Block View ( final boolean root Block0 , final  Byte Buffer buf , final  Checksum Utility checker ) throws  Root Block Exception { if ( buf == null ) throw new  Illegal Argument Exception ( ) ; if ( buf . remaining ( ) !=  SIZEOF_ ROOT_ BLOCK ) { throw new  Illegal Argument Exception ( _ STR +  SIZEOF_ ROOT_ BLOCK + _ STR + buf . remaining ( ) ) ; } this . buf = buf . as Read Only Buffer ( ) ; this . root Block0 = root Block0 ; switch ( get Store Type ( ) ) { case  RW : { am = new  RWAddress Manager ( null ) ; break ; } case  WORM : { final int offset Bits = get Offset Bits ( ) ; am = new  Worm Address Manager ( offset Bits ) ; break ; } default : throw new  Root Block Exception ( _ STR + get Store Type ( ) ) ; } if ( checker == null ) { log . warn ( _ STR ) ; } this . checker = checker ; valid ( ) ; }
protected  SOAPRequest create SOAPRequest ( final  String method Name , final  SOAPMethod Request Writer request Writer ) { final  Post Method method = new  Post Method ( endpoint . to String ( ) ) ; method . set Content Chunked ( _ BOOL ) ; set Request Headers ( method , method Name ) ; final  SOAPRequest Entity request Entity = build Request Entity ( method Name , request Writer ) ; request Entity . set SOAPHeader Provider ( soap Header Provider ) ; final  Buffered SOAPRequest Entity buffered Entity = new  Buffered SOAPRequest Entity ( request Entity ) ; method . set Request Entity ( buffered Entity ) ; return new  SOAPRequest ( method , request Entity ) ; }
@  Suppress Warnings ( _ STR ) @  Test public void inner Enum ( ) {  Class < ? > pc =  Playing Card . class ;  List <  Enum < ? > > include = new  Array List < > ( ) ;  List <  Enum < ? > > exclude = new  Array List < > ( ) ; for (  Class < ? > c : pc . get Declared Classes ( ) ) { int mods = c . get Modifiers ( ) ; if ( c . is Enum ( ) ) { if (  Modifier . is Public ( mods ) ) { include . add All ( as List ( c . get Enum Constants ( ) ) ) ; } else { exclude . add All ( as List ( c . get Enum Constants ( ) ) ) ; } } }  Set <  Typed Operation > actual = get Concrete Operations ( pc ) ; assert Equals ( _ STR , include . size ( ) + _ NUM , actual . size ( ) ) ; for (  Enum < ? > e : include ) { assert True ( _ STR + e . name ( ) + _ STR , actual . contains ( create Enum Operation ( e ) ) ) ; } for (  Enum < ? > e : exclude ) { assert False ( _ STR + e . name ( ) + _ STR , actual . contains ( create Enum Operation ( e ) ) ) ; } }
public static boolean in Target Dir (  File file ) { return in Target Dir ( file . to Path ( ) ) ; }
public final boolean skip Any ( char c ,  Char Sequence csq ) { int i = index ; int n = csq . length ( ) ; for ( ; ( i < n ) && ( csq . char At ( i ) == c ) ; i ++ ) { } if ( i == index ) return _ BOOL ; index = i ; return _ BOOL ; }
private void generate Uniform Integer Examples (  Instances format , int num Instances ,  Subspace Cluster Definition cl ,  String c Name ) {  Instance example = null ; int num Atts = m_ Num Attributes ; if ( get Class Flag ( ) ) { num Atts ++ ; } example = new  Dense Instance ( num Atts ) ; example . set Dataset ( format ) ; boolean [ ] attributes = cl . get Attributes ( ) ; double [ ] min Value = cl . get Min Value ( ) ; double [ ] max Value = cl . get Max Value ( ) ; int [ ] min Int = new int [ min Value . length ] ; int [ ] max Int = new int [ max Value . length ] ; int [ ] int Value = new int [ max Value . length ] ; int [ ] num Int = new int [ min Value . length ] ; int num = _ NUM ; for ( int i = _ NUM ; i < min Value . length ; i ++ ) { min Int [ i ] = ( int )  Math . ceil ( min Value [ i ] ) ; max Int [ i ] = ( int )  Math . floor ( max Value [ i ] ) ; num Int [ i ] = ( max Int [ i ] - min Int [ i ] + _ NUM ) ; num = num * num Int [ i ] ; } int num Each = num Instances / num ; int rest = num Instances - num Each * num ; for ( int i = _ NUM ; i < m_ Num Attributes ; i ++ ) { if ( attributes [ i ] ) { example . set Value ( i , min Int [ i ] ) ; int Value [ i ] = min Int [ i ] ; } else { example . set Missing ( i ) ; } } if ( get Class Flag ( ) ) { example . set Class Value ( c Name ) ; } int added = _ NUM ; int attr = _ NUM ; do { for ( int k = _ NUM ; k < num Each ; k ++ ) { format . add ( example ) ; example = (  Instance ) example . copy ( ) ; added ++ ; } if ( rest > _ NUM ) { format . add ( example ) ; example = (  Instance ) example . copy ( ) ; added ++ ; rest -- ; } if ( added >= num Instances ) { break ; } boolean done = _ BOOL ; do { if ( attributes [ attr ] && ( int Value [ attr ] + _ NUM <= max Int [ attr ] ) ) { int Value [ attr ] ++ ; done = _ BOOL ; } else { attr ++ ; } } while ( ! done ) ; example . set Value ( attr , int Value [ attr ] ) ; } while ( added < num Instances ) ; }
public synchronized boolean remove All (  Collection c ) {  Object [ ] elements = get Array ( ) ; int len = elements . length ; if ( len != _ NUM ) { int newlen = _ NUM ;  Object [ ] temp = new  Object [ len ] ; for ( int i = _ NUM ; i < len ; ++ i ) {  Object element = elements [ i ] ; if ( ! c . contains ( element ) ) temp [ newlen ++ ] = element ; } if ( newlen != len ) { set Array ( copy Of Range ( temp , _ NUM , newlen ,  Object [ ] . class ) ) ; return _ BOOL ; } } return _ BOOL ; }
public  Phone create Phone (  String value ) {  Phone Field phone Impl = new  Phone Field ( ) ; try { phone Impl . set Value ( value ) ; } catch (  Sdp Exception s ) { s . print Stack Trace ( ) ; } return phone Impl ; }
private  String convert To Html ( final  String string ) { return _ STR + string . replace All ( _ STR , _ STR ) + _ STR ; }
private void reload Model With New Value ( final  Long new Value ) { final long new Value As Primitive = new Value == null ? get Model Update Period ( ) : new Value ; for ( final  Property Change Listener listener : model Update Period Listeners ) { final  Property Change Event event = new  Property Change Event ( this , _ STR , get Model Update Period ( ) , new Value As Primitive ) ; listener . property Change ( event ) ; } }
public static void write String To Writer (  String string ,  Writer writer ) throws  IOException {  Buffered Writer bw = new  Buffered Writer ( writer ) ; try { bw . write ( string ) ; } finally { bw . close ( ) ; } }
public final void dec Ref ( ) throws  IOException { ensure Open ( ) ; final int rc = ref Count . decrement And Get ( ) ; if ( rc == _ NUM ) { boolean success = _ BOOL ; try { do Close ( ) ; closed = _ BOOL ; success = _ BOOL ; } finally { if ( ! success ) { ref Count . increment And Get ( ) ; } } } else if ( rc < _ NUM ) { throw new  Illegal State Exception ( _ STR + rc + _ STR ) ; } }
public static  X500 Name x500 Principal To X500 Name (  X500 Principal principal ) { return  X500 Name . get Instance (  Kse X500 Name Style .  INSTANCE , principal . get Encoded ( ) ) ; }
private void assert Described Resource ( final  Bigdata Value described Resource , final  IDescribe Cache describe Cache , final  Test Helper h ) { final  Graph actual Graph = describe Cache . lookup ( described Resource . get IV ( ) ) ; assert Not Null ( actual Graph ) ; final  Set <  Statement > expected Graph = get Expected Description ( described Resource , h ) ; h . compare Graphs ( new  Hash Set <  Statement > ( actual Graph ) , expected Graph ) ; for (  Statement stmt : actual Graph ) { assert True ( stmt instanceof  Bigdata Statement ) ; final  Bigdata Statement st = (  Bigdata Statement ) stmt ; assert Not Null ( st . s ( ) ) ; assert Not Null ( st . p ( ) ) ; assert Not Null ( st . o ( ) ) ; if ( st . get Context ( ) != null ) { assert Not Null ( st . c ( ) ) ; } } }
public boolean is Flat ( ) { return  TYPE_ FLAT . equals ( get Type ( ) ) ; }
@  Deprecated private  List <  Char Sequence > build Limited Networks List ( ) { final  Context context = get Activity ( ) ; final  Array List <  Char Sequence > limited =  Lists . new Array List ( ) ; if ( has Subscription ( context ) ) { final  String subscriber Id = get Active Subscriber Id ( context ) ; if ( m Policy Editor . has Limited Policy ( build Template Mobile All ( subscriber Id ) ) ) { limited . add ( get Text (  R . string . data_usage_list_mobile ) ) ; } if ( m Policy Editor . has Limited Policy ( build Template Mobile3g Lower ( subscriber Id ) ) ) { limited . add ( get Text (  R . string . data_usage_tab_3g ) ) ; } if ( m Policy Editor . has Limited Policy ( build Template Mobile4g ( subscriber Id ) ) ) { limited . add ( get Text (  R . string . data_usage_tab_4g ) ) ; } } if ( m Policy Editor . has Limited Policy ( build Template Wifi Wildcard ( ) ) ) { limited . add ( get Text (  R . string . data_usage_tab_wifi ) ) ; } if ( m Policy Editor . has Limited Policy ( build Template Ethernet ( ) ) ) { limited . add ( get Text (  R . string . data_usage_tab_ethernet ) ) ; } return limited ; }
public int eval RPN (  String [ ] tokens ) { if ( tokens == null || tokens . length == _ NUM ) return _ NUM ;  Stack <  String > s = new  Stack <  String > ( ) ; int len = tokens . length ; for ( int i = _ NUM ; i < len ; i ++ ) {  String cur = tokens [ i ] ; if ( is Operator ( cur ) ) { int t2 =  Integer . parse Int ( s . pop ( ) ) ; int t1 =  Integer . parse Int ( s . pop ( ) ) ; int res = calculate ( t1 , t2 , cur ) ; s . push (  Integer . to String ( res ) ) ; } else s . push ( cur ) ; } return  Integer . value Of ( s . peek ( ) ) ; }
private static void exit (  String err Msg ,  Options options , int exit Code ) { if ( err Msg != null ) echo ( _ STR + err Msg ) ;  String runner =  System . get Property (  IGNITE_ PROG_ NAME , _ STR ) ; int space = runner . index Of ( _ STR ) ; runner = runner . substring ( _ NUM , space == - _ NUM ? runner . length ( ) : space ) ; if ( options != null ) {  Help Formatter formatter = new  Help Formatter ( ) ; formatter . print Help ( runner , options ) ; }  System . exit ( exit Code ) ; }
@  Override public int compare (  New Split Emitted Term term1 ,  New Split Emitted Term term2 ) { return term1 . compare To ( term2 ) ; }
public  AABB merge (  AABB other ) { min X =  Math . min ( min X , other . min X ) ; max X =  Math . max ( max X , other . max X ) ; min Y =  Math . min ( min Y , other . min Y ) ; max Y =  Math . max ( max Y , other . max Y ) ; min Z =  Math . min ( min Z , other . min Z ) ; max Z =  Math . max ( max Z , other . max Z ) ; return this ; }
public static  String generate Auto Tag ( int stack Offset ) {  Stack Trace Element [ ] current Stack = get Current Stack ( ) ;  Stack Trace Element element = current Stack [ stack Offset ] ;  String class Name = element . get Class Name ( ) ;  String pkg Path [ ] = class Name . split ( _ STR ) ; if ( pkg Path . length > _ NUM ) { class Name = pkg Path [ pkg Path . length - _ NUM ] ; }  String Builder sb Inner Class = new  String Builder ( ) ; int index ;  String str Loop = class Name ; while ( ( index = str Loop . last Index Of ( _ STR ) ) != - _ NUM ) {  String piece = str Loop . substring ( index + _ NUM ) ; sb Inner Class . insert ( _ NUM , piece ) ; if ( ! piece . matches ( _ STR ) ) { break ; } sb Inner Class . insert ( _ NUM , _ STR ) ; str Loop = str Loop . substring ( _ NUM , index ) ; } if ( sb Inner Class . length ( ) > _ NUM && sb Inner Class . char At ( _ NUM ) == _ STR ) { sb Inner Class . delete Char At ( _ NUM ) ; }  String inner Class Name = sb Inner Class . to String ( ) ; if (  Text Utils . is Digits Only ( inner Class Name ) ) { inner Class Name = null ; } return  Text Utils . is Empty ( inner Class Name ) ? class Name : inner Class Name ; }
private void handle Subscribe (  String [ ] args ) { switch ( args [ _ NUM ] ) { case _ STR :  Test Subscriber <  Payload > rrsub = new  Test Subscriber < > ( _ NUM ) ; payload Subscribers . put ( args [ _ NUM ] , rrsub ) ; id To Type . put ( args [ _ NUM ] , args [ _ NUM ] ) ;  Reactive Socket rrclient = create Client . get ( ) ;  Publisher <  Payload > rrpub = rrclient . request Response ( new  Payload Impl ( args [ _ NUM ] , args [ _ NUM ] ) ) ; rrpub . subscribe ( rrsub ) ; break ; case _ STR :  Test Subscriber <  Payload > rssub = new  Test Subscriber < > ( _ NUM ) ; payload Subscribers . put ( args [ _ NUM ] , rssub ) ; id To Type . put ( args [ _ NUM ] , args [ _ NUM ] ) ;  Reactive Socket rsclient = create Client . get ( ) ;  Publisher <  Payload > rspub = rsclient . request Stream ( new  Payload Impl ( args [ _ NUM ] , args [ _ NUM ] ) ) ; rspub . subscribe ( rssub ) ; break ; case _ STR :  Test Subscriber <  Payload > rsubsub = new  Test Subscriber < > ( _ NUM ) ; payload Subscribers . put ( args [ _ NUM ] , rsubsub ) ; id To Type . put ( args [ _ NUM ] , args [ _ NUM ] ) ;  Reactive Socket rsubclient = create Client . get ( ) ;  Publisher <  Payload > rsubpub = rsubclient . request Subscription ( new  Payload Impl ( args [ _ NUM ] , args [ _ NUM ] ) ) ; rsubpub . subscribe ( rsubsub ) ; break ; case _ STR :  Test Subscriber <  Void > fnfsub = new  Test Subscriber < > ( _ NUM ) ; fnf Subscribers . put ( args [ _ NUM ] , fnfsub ) ; id To Type . put ( args [ _ NUM ] , args [ _ NUM ] ) ;  Reactive Socket fnfclient = create Client . get ( ) ;  Publisher <  Void > fnfpub = fnfclient . fire And Forget ( new  Payload Impl ( args [ _ NUM ] , args [ _ NUM ] ) ) ; fnfpub . subscribe ( fnfsub ) ; break ; default : break ; } }
@  Post Construct public void init ( ) { configuration Views . add ( default Distribution Set Type Layout ) ; configuration Views . add ( authentication Configuration View ) ; configuration Views . add ( polling Configuration View ) ; }
@  Override public void start ( ) { for ( int i = _ NUM ; i < thread Count ; ++ i ) {  Set <  System Stream Partition > thread Ssps = new  Hash Set <  System Stream Partition > ( ) ; for (  System Stream Partition ssp : ssps ) { if (  Math . abs ( ssp . hash Code ( ) ) % thread Count == i ) { thread Ssps . add ( ssp ) ; } }  Thread thread = new  Thread ( new  Mock System Consumer Runnable ( thread Ssps ) , _ STR + i ) ; thread . set Daemon ( _ BOOL ) ; threads . add ( thread ) ; thread . start ( ) ; } }
private  List < double [ ] > initialize Weights ND ( ) { int  N = _ NUM ;  List < double [ ] > candidates = new  Array List < double [ ] > ( number Of Points *  N ) ; for ( int i = _ NUM ; i < number Of Points *  N ; i ++ ) { double [ ] weight = new double [ number Of Objectives ] ; for ( int j = _ NUM ; j < number Of Objectives ; j ++ ) { weight [ j ] =  PRNG . next Double ( ) ; } double sum =  Stat Utils . sum ( weight ) ; for ( int j = _ NUM ; j < number Of Objectives ; j ++ ) { weight [ j ] /= sum ; } candidates . add ( weight ) ; }  List < double [ ] > weights = new  Array List < double [ ] > ( number Of Points *  N ) ; for ( int i = _ NUM ; i < number Of Objectives ; i ++ ) { double [ ] weight = new double [ number Of Objectives ] ; weight [ i ] = _ NUM ; weights . add ( weight ) ; } while ( weights . size ( ) < number Of Points ) { double [ ] weight = null ; double distance =  Double .  NEGATIVE_ INFINITY ; for ( int i = _ NUM ; i < candidates . size ( ) ; i ++ ) { double d =  Double .  POSITIVE_ INFINITY ; for ( int j = _ NUM ; j < weights . size ( ) ; j ++ ) { d =  Math . min ( d ,  Math Arrays . distance ( candidates . get ( i ) , weights . get ( j ) ) ) ; } if ( d > distance ) { weight = candidates . get ( i ) ; distance = d ; } } weights . add ( weight ) ; candidates . remove ( weight ) ; } return weights ; }
public void remove Column (  Column column ) { if ( column != null ) { columns . remove ( column ) ; } }
public  String info ( ) {  String Builder sb = new  String Builder ( _ STR + table Size + _ STR + elements + _ STR + load Factor + _ STR + threshold ) ; sb . append ( _ STR + num Empty ) ; int size = _ NUM ; int min = elements ; int max = - _ NUM ; for ( int i = _ NUM ; i < table Size ; i ++ ) {  Linked List <  String > list = bins [ i ] ; if ( list != null ) { int sz = list . size ( ) ; size += sz ; if ( sz < min ) { min = sz ; } if ( sz > max ) { max = sz ; } } } float avg = size ; int base = ( table Size - num Empty ) ; if ( base == _ NUM ) { sb . append ( _ STR ) ; sb . append ( _ STR ) ; sb . append ( _ STR ) ; } else { avg /= base ; sb . append ( _ STR + avg ) ; sb . append ( _ STR + min ) ; sb . append ( _ STR + max ) ; } return sb . to String ( ) ; }
public boolean peek Sample (  Media Codec .  Buffer Info out_buffer Info ) { update ( ) ; boolean result = _ BOOL ; if ( ! m Available Output Buffers . is Empty ( ) ) { int index = m Available Output Buffers . peek ( ) ;  Media Codec .  Buffer Info info = m Output Buffer Info [ index ] ; out_buffer Info . set ( info . offset , info . size , info . presentation Time Us , info . flags ) ; result = _ BOOL ; } return result ; }
@  Override public  Abstract Scanned Result scan Blocklet (  Blocks Chunk Holder blocks Chunk Holder ) throws  Query Execution Exception { try { fill Scanned Result ( blocks Chunk Holder ) ; } catch (  Filter Unsupported Exception e ) { throw new  Query Execution Exception ( e . get Message ( ) ) ; } return scanned Result ; }
@  Override public int hash Code ( ) { return subconditions . hash Code ( ) - operator . hash Code ( ) ; }
public void balance Segments ( ) {  MAcct Schema Element [ ] elements = m_acct Schema . get Acct Schema Elements ( ) ; for ( int i = _ NUM ; i < elements . length ; i ++ ) {  MAcct Schema Element ase = elements [ i ] ; if ( ase . is Balanced ( ) ) balance Segment ( ase . get Element Type ( ) ) ; } }
public  Annotation Drawer ( final  Annotations Model model , final  Process Renderer Model renderer Model ) { this . model = model ; this . renderer Model = renderer Model ; this . display Cache = new  Hash Map < > ( ) ; this . cached ID = new  Hash Map < > ( ) ; pane = new  JEditor Pane ( _ STR , _ STR ) ; pane . set Border ( null ) ; pane . set Opaque ( _ BOOL ) ; }
public boolean has User Partitions ( ) { return ! user Output . is Empty ( ) ; }
@  Override public void insert String ( final int offs , final  String str , final  Attribute Set attr ) { if ( offs < _ NUM ) { return ; } if ( str . length ( ) > _ NUM ) { int i ; for ( i = _ NUM ; i < str . length ( ) ; i ++ ) { if ( str . char At ( i ) == _ STR ) { remaining Text String = str . substring ( i + _ NUM ) ; remaining Text Attr = attr ; input Key Listener . key Pressed ( new  Key Event ( new  Container ( ) ,  Key Event .  KEY_ PRESSED , _ NUM , _ NUM ,  Key Event .  VK_ ENTER , _ STR ) ) ; break ; } else { insert Char ( offs + i , _ STR + str . char At ( i ) ) ; } } } else if ( str . length ( ) == _ NUM ) { insert Char ( offs , str ) ; } }
public static int put Int ( byte [ ] bytes , int offset , int val ) { if ( little Endian ) { val =  Integer . reverse Bytes ( val ) ; } the Unsafe . put Int ( bytes , offset +  BYTE_ ARRAY_ BASE_ OFFSET , val ) ; return offset +  Bytes .  SIZEOF_ INT ; }
public  Item (  Drawable symbol ,  String label Text ,  Font font ) { double font Size = font . get Size2 D ( ) ; set Layout ( new  Edge Layout ( font Size , _ NUM ) ) ; this . symbol = symbol ; add ( symbol ,  Location .  WEST ) ; label = new  Label ( label Text ) ; label . set Font ( font ) ; label . set Alignment X ( _ NUM ) ; label . set Alignment Y ( _ NUM ) ; add ( label ,  Location .  CENTER ) ; }
void tag (  String tag ) ;
private  Delegate delegate ( ) throws  Hadoop Igfs Communication Exception {  Exception err Shmem = null ;  Exception err Tcp = null ;  Delegate cur Delegate = delegate Ref . get ( ) ; if ( cur Delegate != null ) return cur Delegate ; boolean skip In Proc = parameter ( conf ,  PARAM_ IGFS_ ENDPOINT_ NO_ EMBED , authority , _ BOOL ) ; if ( ! skip In Proc ) {  Igfs Ex igfs = get Igfs Ex ( endpoint . grid ( ) , endpoint . igfs ( ) ) ; if ( igfs != null ) {  Hadoop Igfs Ex hadoop = null ; try { hadoop = new  Hadoop Igfs In Proc ( igfs , log , user Name ) ; cur Delegate = new  Delegate ( hadoop , hadoop . handshake ( log Dir ) ) ; } catch (  IOException |  Ignite Checked Exception e ) { if ( e instanceof  Hadoop Igfs Communication Exception ) if ( hadoop != null ) hadoop . close ( _ BOOL ) ; if ( log . is Debug Enabled ( ) ) log . debug ( _ STR , e ) ; } } } boolean skip Loc Shmem = parameter ( conf ,  PARAM_ IGFS_ ENDPOINT_ NO_ LOCAL_ SHMEM , authority , _ BOOL ) ; if ( cur Delegate == null && ! skip Loc Shmem && !  U . is Windows ( ) ) {  Hadoop Igfs Ex hadoop = null ; try { hadoop = new  Hadoop Igfs Out Proc ( endpoint . port ( ) , endpoint . grid ( ) , endpoint . igfs ( ) , log , user Name ) ; cur Delegate = new  Delegate ( hadoop , hadoop . handshake ( log Dir ) ) ; } catch (  IOException |  Ignite Checked Exception e ) { if ( e instanceof  Hadoop Igfs Communication Exception ) hadoop . close ( _ BOOL ) ; if ( log . is Debug Enabled ( ) ) log . debug ( _ STR + endpoint . port ( ) + _ STR , e ) ; err Shmem = e ; } } boolean skip Loc Tcp = parameter ( conf ,  PARAM_ IGFS_ ENDPOINT_ NO_ LOCAL_ TCP , authority , _ BOOL ) ; if ( cur Delegate == null && ! skip Loc Tcp ) {  Hadoop Igfs Ex hadoop = null ; try { hadoop = new  Hadoop Igfs Out Proc (  LOCALHOST , endpoint . port ( ) , endpoint . grid ( ) , endpoint . igfs ( ) , log , user Name ) ; cur Delegate = new  Delegate ( hadoop , hadoop . handshake ( log Dir ) ) ; } catch (  IOException |  Ignite Checked Exception e ) { if ( e instanceof  Hadoop Igfs Communication Exception ) hadoop . close ( _ BOOL ) ; if ( log . is Debug Enabled ( ) ) log . debug ( _ STR + endpoint . host ( ) + _ STR + endpoint . port ( ) + _ STR , e ) ; err Tcp = e ; } } if ( cur Delegate == null && ( skip Loc Tcp || !  F . eq (  LOCALHOST , endpoint . host ( ) ) ) ) {  Hadoop Igfs Ex hadoop = null ; try { hadoop = new  Hadoop Igfs Out Proc ( endpoint . host ( ) , endpoint . port ( ) , endpoint . grid ( ) , endpoint . igfs ( ) , log , user Name ) ; cur Delegate = new  Delegate ( hadoop , hadoop . handshake ( log Dir ) ) ; } catch (  IOException |  Ignite Checked Exception e ) { if ( e instanceof  Hadoop Igfs Communication Exception ) hadoop . close ( _ BOOL ) ; if ( log . is Debug Enabled ( ) ) log . debug ( _ STR + endpoint . host ( ) + _ STR + endpoint . port ( ) + _ STR , e ) ; err Tcp = e ; } } if ( cur Delegate != null ) { if ( ! delegate Ref . compare And Set ( null , cur Delegate ) ) cur Delegate . doomed = _ BOOL ; return cur Delegate ; } else {  SB err Msg = new  SB ( _ STR + authority + _ STR ) ; if ( err Shmem != null ) err Msg . a ( _ STR + endpoint . port ( ) + _ STR + err Shmem + _ STR ) ; err Msg . a ( _ STR + endpoint . host ( ) + _ STR + endpoint . port ( ) + _ STR + err Tcp + _ STR ) ; err Msg . a ( _ STR + _ STR ) ; throw new  Hadoop Igfs Communication Exception ( err Msg . to String ( ) ) ; } }
public  From Clause add (  Outer Join Qualifier outer Join Qualifier ) { outer Join Qualifiers . add ( outer Join Qualifier ) ; return this ; }
private static final  File [ ] encode (  String src ) { if ( src == null || src . length ( ) == _ NUM ) { return ( new  File [ _ NUM ] ) ; }  String Tokenizer tokenizer = new  String Tokenizer ( src , _ STR ) ;  File [ ] dirs = new  File [ tokenizer . count Tokens ( ) ] ; for ( int i = _ NUM ; i < dirs . length ; i ++ ) { dirs [ i ] = new  File ( tokenizer . next Token ( ) ) ; } return dirs ; }
public  E poll ( long timeout ,  Time Unit unit ) throws  Interrupted Exception { long nanos = unit . to Nanos ( timeout ) ; final  Reentrant Lock lock = this . lock ; lock . lock Interruptibly ( ) ; long t = now ( ) ;  Tenant Queue .  Item item = null ; try { for ( ; ; ) {  Tenant Queue q = next Queue ( t ) ; if ( q == null ) { if ( nanos <= _ NUM ) return null ; else nanos = available . await Nanos ( nanos ) ; } else { long delay = q . next - t ; if ( delay <= _ NUM ) { item = q . poll ( t ) ; return item == null ? null : item . element ; } if ( nanos <= _ NUM ) return null ; if ( nanos < delay || leader != null ) nanos = available . await Nanos ( nanos ) ; else {  Thread this Thread =  Thread . current Thread ( ) ; leader = this Thread ; try { long time Left = available . await Nanos ( delay ) ; nanos -= delay - time Left ; } finally { if ( leader == this Thread ) leader = null ; } } } t =  System . nano Time ( ) ; } } finally { if ( leader == null && has Next ( ) ) available . signal ( ) ; lock . unlock ( ) ; done ( item , t ) ; } }
public int size ( ) { return patterns . size ( ) ; }
private  Sublime Base Menu Item add Internal ( int pivot ID ,  Positioned positioned ,  Sublime Base Menu Item new Item ) { int new Item Group Id = new Item . get Group Id ( ) ; check Existence Of Group ( new Item Group Id ) ; int pivot Index = find Item Index ( pivot ID ) ;  Sublime Base Menu Item pivot = m Items . get ( pivot Index ) ; if ( new Item . get Item Type ( ) ==  Sublime Base Menu Item .  Item Type .  GROUP_ HEADER ) { check If Group Header Already Exists For Group ( new Item Group Id ) ; int index = find Group Index ( new Item Group Id ) ; if ( index >= _ NUM ) { m Items . add ( index , new Item ) ; } else { if ( positioned ==  Positioned .  BEFORE ) { if ( pivot . get Group Id ( ) ==  NO_ GROUP_ ID || pivot . get Item Type ( ) ==  Sublime Base Menu Item .  Item Type .  GROUP_ HEADER ) { m Items . add ( pivot Index , new Item ) ; } else { m Items . add ( new Item ) ; } } else if ( positioned ==  Positioned .  AFTER ) { if ( pivot . get Group Id ( ) ==  NO_ GROUP_ ID || pivot Index == find Last Group Index ( new Item Group Id ) ) { m Items . add ( pivot Index + _ NUM , new Item ) ; } else { m Items . add ( new Item ) ; } } } } else { if ( new Item Group Id !=  NO_ GROUP_ ID ) { int last Group Index = find Last Group Index ( new Item Group Id ) ; if ( last Group Index == m Items . size ( ) ) { if ( positioned ==  Positioned .  BEFORE ) { if ( pivot . get Group Id ( ) ==  NO_ GROUP_ ID || pivot Index == find Group Index ( pivot . get Group Id ( ) ) ) { m Items . add ( pivot Index , new Item ) ; } else { m Items . add ( new Item ) ; } } else if ( positioned ==  Positioned .  AFTER ) { if ( pivot . get Group Id ( ) ==  NO_ GROUP_ ID || pivot Index == find Last Group Index ( pivot . get Group Id ( ) ) ) { m Items . add ( pivot Index + _ NUM , new Item ) ; } else { m Items . add ( new Item ) ; } } } else { if ( new Item Group Id == pivot . get Group Id ( ) ) { if ( positioned ==  Positioned .  BEFORE ) { if ( pivot . get Item Type ( ) !=  Sublime Base Menu Item .  Item Type .  GROUP_ HEADER ) { m Items . add ( pivot Index , new Item ) ; } else { m Items . add ( last Group Index + _ NUM , new Item ) ; } } else if ( positioned ==  Positioned .  AFTER ) { m Items . add ( pivot Index + _ NUM , new Item ) ; } } else { m Items . add ( last Group Index + _ NUM , new Item ) ; } } } else { if ( positioned ==  Positioned .  BEFORE ) { if ( pivot . get Group Id ( ) ==  NO_ GROUP_ ID || find Group Index ( pivot . get Group Id ( ) ) == pivot Index ) { m Items . add ( pivot Index , new Item ) ; } else { m Items . add ( new Item ) ; } } else if ( positioned ==  Positioned .  AFTER ) { if ( pivot . get Group Id ( ) ==  NO_ GROUP_ ID || pivot Index == find Last Group Index ( pivot . get Group Id ( ) ) ) { m Items . add ( pivot Index + _ NUM , new Item ) ; } else { m Items . add ( new Item ) ; } } } } on Items Changed ( ) ; return new Item ; }
public static void write Uint8 (  Output Stream the Os , int the Value ) throws  IOException { the Os . write ( the Value ) ; }
@  Override public void add Header ( final  String header , final  String value ) { m Headers Options . add ( new  Header Option ( header , value ) ) ; }
public void store ( ) throws  SAMLException { try { key Provider . store ( ) ; } catch (  Key Store Exception e ) { throw new  SAMLException ( e . get Message ( ) ) ; } catch (  Certificate Exception e ) { throw new  SAMLException ( e . get Message ( ) ) ; } catch (  No Such Algorithm Exception e ) { throw new  SAMLException ( e . get Message ( ) ) ; } catch (  IOException e ) { throw new  SAMLException ( e . get Message ( ) ) ; } }
static void append To Pointer Hierarchy ( final  Base Type type , final  Base Type pointer ) {  Preconditions . check Not Null ( type , _ STR ) ;  Preconditions . check Not Null ( pointer , _ STR ) ;  Preconditions . check Argument ( type != pointer , _ STR ) ;  Preconditions . check Argument ( pointer . pointed To By != type , _ STR ) ;  Preconditions . check Argument ( type . points To != pointer , _ STR ) ; pointer . points To = type ; type . pointed To By = pointer ; }
public static void sort ( long [ ] a ) { do Sort ( a , _ NUM , a . length - _ NUM ) ; }
public  String to String ( ) { return _ STR +  String . format ( _ STR ,  Value Similarity * _ NUM ) + _ STR +  String . format ( _ STR ,  Containment Similarity * _ NUM ) + _ STR +  String . format ( _ STR ,  Size Similarity * _ NUM ) ; }
public  Optional <  T > last ( ) {  Iterator <  T > iterator = iterator ( ) ;  T value = null ; while ( iterator . has Next ( ) ) value = iterator . next ( ) ; return  Optional . of ( value ) ; }
public static void thread Sleep ( long millis ) { try {  Thread . sleep ( millis ) ; } catch (  Interrupted Exception ex ) {  Log . e ( _ STR ,  String Utils . exception Stack Trace To String ( ex ) ) ; } }
static boolean is Package Access ( final int modifiers ) { return ( modifiers &  ACCESS_ TEST ) == _ NUM ; }
Managed Window Decorator (  Window window ,  String window Id ) { this . window = window ; name = _ STR + window Id ; }
boolean handle Remote Can Rebalance ( long size ) { return _ BOOL ; }
public static  File to SLDFile ( final  File file ) { final  String path = file . get Absolute Path ( ) ; final  String base = path . substring ( _ NUM , path . length ( ) - _ NUM ) ;  String new Path = base + _ STR ;  File sld = new  File ( new Path ) ; if ( sld . exists ( ) ) { return sld ; } new Path = base + _ STR ; sld = new  File ( new Path ) ; if ( sld . exists ( ) ) { return sld ; } return null ; }
private  String insert Properties (  String template ,  Map <  String ,  String > properties ) { for (  Entry <  String ,  String > entry : properties . entry Set ( ) ) { template = template . replace ( entry . get Key ( ) , entry . get Value ( ) ) ; } return template ; }
public static void change Font (  JComponent comp , int style ) {  Font font = comp . get Font ( ) ; comp . set Font ( font . derive Font ( style ) ) ; }
public void draw Contours (  Mat img ,  Color color ) {  Drawing . draw Contours ( img , contours , color ) ; }
public static void save X509 Cert (  String cert Str ,  File cert File ) throws  IOException {  Buffered Writer writer = new  Buffered Writer ( new  File Writer ( cert File ) ) ; writer . write (  BEGIN_ CERT ) ; writer . new Line ( ) ; writer . write ( cert Str ) ; writer . new Line ( ) ; writer . write (  END_ CERT ) ; writer . new Line ( ) ; writer . close ( ) ; }
public void clear On Central Position Changed Listener ( ) { m On Central Position Changed Listeners . clear ( ) ; }
public static  Object invoke Static (  Class clazz ,  String method Name ) throws  No Such Method Exception { try {  Method method = clazz . get Method ( method Name , new  Class [ _ NUM ] ) ;  Object result = method . invoke ( null , new  Object [ _ NUM ] ) ; return result ; } catch (  Illegal Access Exception e ) { throw new  No Such Method Exception ( method Name + _ STR ) ; } catch (  Invocation Target Exception e ) { throw new  Internal Error ( e . get Message ( ) ) ; } }
public static _ Fields find By Thrift Id ( int field Id ) { switch ( field Id ) { case _ NUM : return  NOTE_ ID ; case _ NUM : return  CLASS_ NAME ; case _ NUM : return  INTERPRETER_ CONTEXT ; default : return null ; } }
public static boolean is Stanza (  Packet packet ) { if ( packet instanceof  Message ) return _ BOOL ; if ( packet instanceof  IQ ) return _ BOOL ; if ( packet instanceof  Presence ) return _ BOOL ; return _ BOOL ; }
@  Override public int execute ( final  Form Object form , final int type , final  String code , final int event Type , final char key Pressed ) { int message Code =  Action Handler .  NOMESSAGE ; if ( code instanceof  String ) { final  String js = code ; final  String [ ] args =  JSFunction . convert To Array ( js ) ; final  String command = args [ _ NUM ] ; if ( command . starts With ( _ STR ) ) { message Code = handle AFCommands ( form , command , js , args , event Type , key Pressed ) ; } } return message Code ; }
private boolean needs Update (  Long bundle Version ,  String bean Version ) { if ( bean Version . contains ( _ STR ) ) {  Log . i (  TAG , _ STR + bundle Version ) ;  Log . i (  TAG , _ STR + bean Version ) ; return _ BOOL ; } else { try { long parsed Version =  Long . parse Long ( bean Version . split ( _ STR ) [ _ NUM ] ) ;  Log . i (  TAG , _ STR + bundle Version ) ;  Log . i (  TAG , _ STR + parsed Version ) ; if ( bundle Version > parsed Version ) { return _ BOOL ; } else {  Log . i (  TAG , _ STR ) ; } } catch (  Number Format Exception e ) {  Log . e (  TAG , _ STR + bean Version ) ; fail (  Bean Error .  UNPARSABLE_ FW_ VERSION ) ; } } return _ BOOL ; }
public void clear (  Faces Context faces Context ,  Map <  String ,  Object > view Map ) { if (  LOGGER . is Loggable (  Level .  FINEST ) ) {  LOGGER . log (  Level .  FINEST , _ STR ) ; }  Map <  String ,  View Scope Context Object > context Map = get Context Map ( faces Context , view Map ) ; if ( context Map != null ) { destroy Beans ( view Map , context Map ) ; } }
public void load Logical Tables With Granularities (  Map <  String ,  Table Group > name Group Map ,  Set < ? extends  Granularity > valid Grains ,  Resource Dictionaries dictionaries ) { for (  Map .  Entry <  String ,  Table Group > entry : name Group Map . entry Set ( ) ) {  String logical Table Name = entry . get Key ( ) ;  Table Group group = entry . get Value ( ) ; load Logical Table With Granularities ( logical Table Name , group , valid Grains , dictionaries ) ; } }
public  Process ( final  String xml String ) throws  IOException ,  XMLException { init Context ( ) ;  String Reader in = new  String Reader ( xml String ) ; read Process ( in ) ; in . close ( ) ; }
public  Consul Topology Fraction ( ) { this . url =  DEFAULT_ URL ; }
protected  String build Qualifier Regex (  String qualifier Value ) {  String Builder sb = new  String Builder ( ) ; sb . append ( _ STR ) ; sb . append ( qualifier Value ) ; sb . append ( _ STR ) ; return sb . to String ( ) ; }
public  String shorten Name (  String name , int desired Length ) { int original Length = name . length ( ) ; if ( ( desired Length <= _ NUM ) || ( original Length <= desired Length ) ) { return name ; } int delta = original Length - desired Length ; int start Cut = desired Length / _ NUM ;  String Buffer result = new  String Buffer ( ) ; result . append ( name . substring ( _ NUM , start Cut ) ) ; if ( ( ( start Cut == _ NUM ) || ( name . char At ( start Cut - _ NUM ) != _ STR ) ) && ( ( start Cut + delta + _ NUM == original Length ) || ( name . char At ( start Cut + delta + _ NUM ) != _ STR ) ) ) { result . append ( _ STR ) ; } result . append ( name . substring ( start Cut + delta + _ NUM , original Length ) ) ; return result . to String ( ) ; }
public static  Color blend (  Color color1 ,  Color color2 , double weight ) { double w2 =  Math Utils . limit ( weight , _ NUM , _ NUM ) ; double w1 = _ NUM - w2 ; int r = ( int )  Math . round ( w1 * color1 . get Red ( ) + w2 * color2 . get Red ( ) ) ; int g = ( int )  Math . round ( w1 * color1 . get Green ( ) + w2 * color2 . get Green ( ) ) ; int b = ( int )  Math . round ( w1 * color1 . get Blue ( ) + w2 * color2 . get Blue ( ) ) ; int a = ( int )  Math . round ( w1 * color1 . get Alpha ( ) + w2 * color2 . get Alpha ( ) ) ; return new  Color ( r , g , b , a ) ; }
private void decide UILook And Feel (  Main Options options ) { try { boolean system Plaf = _ BOOL ; system Plaf = options . system_plaf ;  String system Plaf Req =  System . getenv ( _ STR ) ; if ( system Plaf Req != null && system Plaf Req . equals Ignore Case ( _ STR ) ) system Plaf = _ BOOL ; if ( system Plaf )  UIManager . set Look And Feel (  UIManager . get System Look And Feel Class Name ( ) ) ; } catch (  Exception exc ) { exc . print Stack Trace ( ) ; } }
public static  Buffered Image to Buffered Image (  Image img , int type ) { if ( img instanceof  Buffered Image ) { return (  Buffered Image ) img ; }  Buffered Image bimage = new  Buffered Image ( img . get Width ( null ) , img . get Height ( null ) , type ) ;  Graphics2 D b Gr = bimage . create Graphics ( ) ; b Gr . draw Image ( img , _ NUM , _ NUM , null ) ; b Gr . dispose ( ) ; return bimage ; }
public static byte [ ] hex String To Byte Array (  String str A ) {  Byte Array Output Stream result = new  Byte Array Output Stream ( ) ; byte sum = ( byte ) _ NUM ; boolean next Char Is Upper = _ BOOL ; for ( int i = _ NUM ; i < str A . length ( ) ; i ++ ) { char c = str A . char At ( i ) ; switch (  Character . to Upper Case ( c ) ) { case _ STR : if ( next Char Is Upper ) { sum = ( byte ) _ NUM ; next Char Is Upper = _ BOOL ; } else { sum |= ( byte ) _ NUM ; result . write ( sum ) ; next Char Is Upper = _ BOOL ; } break ; case _ STR : if ( next Char Is Upper ) { sum = ( byte ) _ NUM ; next Char Is Upper = _ BOOL ; } else { sum |= ( byte ) _ NUM ; result . write ( sum ) ; next Char Is Upper = _ BOOL ; } break ; case _ STR : if ( next Char Is Upper ) { sum = ( byte ) _ NUM ; next Char Is Upper = _ BOOL ; } else { sum |= ( byte ) _ NUM ; result . write ( sum ) ; next Char Is Upper = _ BOOL ; } break ; case _ STR : if ( next Char Is Upper ) { sum = ( byte ) _ NUM ; next Char Is Upper = _ BOOL ; } else { sum |= ( byte ) _ NUM ; result . write ( sum ) ; next Char Is Upper = _ BOOL ; } break ; case _ STR : if ( next Char Is Upper ) { sum = ( byte ) _ NUM ; next Char Is Upper = _ BOOL ; } else { sum |= ( byte ) _ NUM ; result . write ( sum ) ; next Char Is Upper = _ BOOL ; } break ; case _ STR : if ( next Char Is Upper ) { sum = ( byte ) _ NUM ; next Char Is Upper = _ BOOL ; } else { sum |= ( byte ) _ NUM ; result . write ( sum ) ; next Char Is Upper = _ BOOL ; } break ; case _ STR : if ( next Char Is Upper ) { sum = ( byte ) _ NUM ; next Char Is Upper = _ BOOL ; } else { sum |= ( byte ) _ NUM ; result . write ( sum ) ; next Char Is Upper = _ BOOL ; } break ; case _ STR : if ( next Char Is Upper ) { sum = ( byte ) _ NUM ; next Char Is Upper = _ BOOL ; } else { sum |= ( byte ) _ NUM ; result . write ( sum ) ; next Char Is Upper = _ BOOL ; } break ; case _ STR : if ( next Char Is Upper ) { sum = ( byte ) _ NUM ; next Char Is Upper = _ BOOL ; } else { sum |= ( byte ) _ NUM ; result . write ( sum ) ; next Char Is Upper = _ BOOL ; } break ; case _ STR : if ( next Char Is Upper ) { sum = ( byte ) _ NUM ; next Char Is Upper = _ BOOL ; } else { sum |= ( byte ) _ NUM ; result . write ( sum ) ; next Char Is Upper = _ BOOL ; } break ; case _ STR : if ( next Char Is Upper ) { sum = ( byte ) _ NUM ; next Char Is Upper = _ BOOL ; } else { sum |= ( byte ) _ NUM ; result . write ( sum ) ; next Char Is Upper = _ BOOL ; } break ; case _ STR : if ( next Char Is Upper ) { sum = ( byte ) _ NUM ; next Char Is Upper = _ BOOL ; } else { sum |= ( byte ) _ NUM ; result . write ( sum ) ; next Char Is Upper = _ BOOL ; } break ; case _ STR : if ( next Char Is Upper ) { sum = ( byte ) _ NUM ; next Char Is Upper = _ BOOL ; } else { sum |= ( byte ) _ NUM ; result . write ( sum ) ; next Char Is Upper = _ BOOL ; } break ; case _ STR : if ( next Char Is Upper ) { sum = ( byte ) _ NUM ; next Char Is Upper = _ BOOL ; } else { sum |= ( byte ) _ NUM ; result . write ( sum ) ; next Char Is Upper = _ BOOL ; } break ; case _ STR : if ( next Char Is Upper ) { sum = ( byte ) _ NUM ; next Char Is Upper = _ BOOL ; } else { sum |= ( byte ) _ NUM ; result . write ( sum ) ; next Char Is Upper = _ BOOL ; } break ; case _ STR : if ( next Char Is Upper ) { sum = ( byte ) _ NUM ; next Char Is Upper = _ BOOL ; } else { sum |= ( byte ) _ NUM ; result . write ( sum ) ; next Char Is Upper = _ BOOL ; } break ; default : break ; } } if ( ! next Char Is Upper ) { throw new  Runtime Exception ( _ STR ) ; } return result . to Byte Array ( ) ; }
public void remove Sensor Selection Listener (  Sensor Selection Listener listener ) { listener List . remove (  Sensor Selection Listener . class , listener ) ; }
public void write ( int c ) throws  IOException { if ( _output == null ) throw new  IOException ( _ STR ) ; _output . append ( ( char ) c ) ; }
public void register (  Grid Cache Ttl Manager mgr ) { synchronized ( mux ) { if ( cleanup Worker == null ) start Cleanup Worker ( ) ; mgrs . add ( mgr ) ; } }
public void initialize Key Store ( ) { try {  Logger logger = ( com . sun . identity . log .  Logger )  Logger . get Logger ( log Name ) ; reset Current File List ( log Name ) ; add To Current File List ( log Name , log Name , log Name ) ;  String log Path = lmanager . get Property (  Log Constants .  LOG_ LOCATION ) ; if ( ! log Path . ends With ( _ STR ) ) log Path += _ STR ;  String file Name = log Name ;  String logger File Name = log Path +  PREFIX + _ STR + file Name ;  String verifier File Name = log Path +  PREFIX + _ STR + file Name ;  Debug . message ( log Name + _ STR + logger File Name ) ;  Debug . message ( log Name + _ STR + verifier File Name ) ; helper . initialize Secure Log Helper ( logger File Name , log Password , verifier File Name , log Password ) ;  Debug . message ( log Name + _ STR ) ; helper . initialize Verifier ( verifier File Name , log Password , ver Password ) ;  Debug . message ( log Name + _ STR ) ; } catch (  Exception e ) {  Debug . error ( log Name + _ STR , e ) ; } }
private native byte [ ] image Data To Platform Image Bytes ( byte [ ] image Data , int width , int height , long format ) ;
public static  String clean Folder Stacking Markers (  String filename ) { if ( !  String Utils . is Empty ( filename ) ) {  Matcher m = folder Stacking Pattern . matcher ( filename ) ; if ( m . matches ( ) ) { return m . group ( _ NUM ) + m . group ( _ NUM ) ; } } return filename ; }
public void discard (  Service Registrar reg ) { synchronized ( registrars ) { if ( terminated ) { throw new  Illegal State Exception ( _ STR ) ; } if ( reg == null ) return ; send Discarded ( reg , null ) ; } }
public boolean is Final State ( int state ) { return ( state < _ NUM ) ? _ BOOL : f Final State Flags [ state ] ; }
public static  String generate Scale Markers ( int protein Length , int max Num Scale Markers ) { if ( max Num Scale Markers < _ NUM ) { max Num Scale Markers = _ NUM ; } int scale = calc Scale ( protein Length , max Num Scale Markers ) ;  String Builder sb = new  String Builder ( _ STR ) ; int index = _ NUM ; int num Remaining = protein Length ; while ( index <= protein Length ) { index += scale ; num Remaining -= scale ; sb . append ( _ STR ) ; if ( ( num Remaining > _ NUM ) && ( num Remaining < scale ) ) { if ( num Remaining < ( scale / _ NUM ) ) { sb . append ( protein Length ) ; break ; } } if ( index >= protein Length ) { sb . append ( protein Length ) ; } else { sb . append ( index ) ; } } return sb . to String ( ) ; }
public void write Fig Tree Block (  Map <  String ,  Object > settings ) throws  IOException { writer . println ( _ STR ) ; for (  String key : settings . key Set ( ) ) {  Object value = settings . get ( key ) ; writer . println ( _ STR + key + _ STR + create String ( value ) + _ STR ) ; } writer . println ( _ STR ) ; }
public int hash Code ( ) { return font . hash Code ( ) ^ glyphs . length ; }
@  Override public void doctype Decl (  String root Element ,  String public Id ,  String system Id ,  Augmentations augs ) throws  XNIException { f In DTD = _ BOOL ; try { if ( f Lexical Handler != null ) { f Lexical Handler . start DTD ( root Element , public Id , system Id ) ; } } catch (  SAXException e ) { throw new  XNIException ( e ) ; } if ( f Decl Handler != null ) { f Declared Attrs = new  Symbol Hash ( ) ; } }
public void clean Start ( ) {  Connection conn = get Connection ( _ BOOL , _ BOOL ) ; if ( conn == null ) throw new  Illegal State Exception ( _ STR ) ; drop Database ( conn ) ; create User ( conn ) ; create Database ( conn ) ; try { if ( conn != null ) conn . close ( ) ; } catch (  SQLException e2 ) { log . log (  Level .  SEVERE , _ STR , e2 ) ; } conn = null ; }
static  Template Model Exception new Method Arg Invalid Value Exception (  String method Name , int arg Idx ,  Object ... details ) { return new _ Template Model Exception ( method Name , _ STR ,  Integer . value Of ( arg Idx + _ NUM ) , _ STR , details ) ; }
private void load Map (  String extension ,  String mime Type ) { if ( ! mime Type To Extension Map . contains Key ( mime Type ) ) { mime Type To Extension Map . put ( mime Type , extension ) ; } extension To Mime Type Map . put ( extension , mime Type ) ; if ( is Image Type ( mime Type ) ) { image Mime Type Set . add ( mime Type ) ; } }
private  String convert Timestamp ( ) {  String result = timestamp Format . replace All (  VALID_ DATEFORMAT_ CHAR_ PATTERN + _ STR , _ STR ) ; result = result . replace All (  Pattern . quote ( _ STR ) , _ STR ) ; return result ; }
public static  String encode ( byte [ ] bytes ) { int len = bytes . length ; final  String Buffer encoded = new  String Buffer ( ( len + _ NUM ) / _ NUM * _ NUM ) ; int i = _ NUM ; int j = len ; while ( j >= _ NUM ) { encoded . append ( to64 ( ( ( ( bytes [ i ] & _ NUM ) << _ NUM ) | ( int ) ( ( bytes [ i + _ NUM ] & _ NUM ) << _ NUM ) | ( int ) ( bytes [ i + _ NUM ] & _ NUM ) ) , _ NUM ) ) ; i += _ NUM ; j -= _ NUM ; } if ( j == _ NUM ) { encoded . append ( to64 ( ( ( bytes [ i ] & _ NUM ) << _ NUM ) | ( ( bytes [ i + _ NUM ] & _ NUM ) ) , _ NUM ) ) ; } if ( j == _ NUM ) { encoded . append ( to64 ( ( ( bytes [ i ] & _ NUM ) ) , _ NUM ) ) ; } return encoded . to String ( ) ; }
final public void print ( double v ) {  Writer out = this . out ; if ( out == null ) return ; try {  String s =  String . value Of ( v ) ; out . write ( s , _ NUM , s . length ( ) ) ; } catch (  IOException e ) { log . log (  Level .  FINE , e . to String ( ) , e ) ; } }
public  String to String ( ) {  String Buffer result = new  String Buffer ( ip Address . to String ( ) ) ; result . append ( _ STR ) ; result . append ( extended Network Prefix ) ; return result . to String ( ) ; }
private static boolean contains Chroot (  String zk Host ) { return zk Host . contains ( _ STR ) ; }
public static void on Database (  Mongo Client client ,  String db Name ,  Consumer <  Mongo Database > db Operation ) { if ( contains ( client . list Database Names ( ) , db Name ) ) { db Operation . accept ( client . get Database ( db Name ) ) ; } }
protected int create Hash Code ( ) { int result = uri . hash Code ( ) ^ prefix . hash Code ( ) ; if ( result == _ NUM ) { result = _ NUM ; } return result ; }
public  String import Trl (  String directory , int  AD_ Client_ ID ,  String  AD_ Language ,  String  Trl_ Table ) {  String file Name = directory +  File . separator +  Trl_ Table + _ STR +  AD_ Language + _ STR ; log . info ( file Name ) ;  File in = new  File ( file Name ) ; if ( ! in . exists ( ) ) {  String msg = _ STR + file Name ; log . log (  Level .  SEVERE , msg ) ; return msg ; } try {  Translation Handler handler = new  Translation Handler (  AD_ Client_ ID ) ;  SAXParser Factory factory =  SAXParser Factory . new Instance ( ) ;  SAXParser parser = factory . new SAXParser ( ) ; parser . parse ( in , handler ) ; log . info ( _ STR + handler . get Update Count ( ) ) ; return  Msg . get Msg ( m_ctx , _ STR ) + _ STR + handler . get Update Count ( ) ; } catch (  Exception e ) { log . log (  Level .  SEVERE , _ STR , e ) ; return e . to String ( ) ; } }
@  Override public void on Failure (  IMqtt Token async Action Token ,  Throwable exception ) { exception . print Stack Trace ( ) ;  Log . e ( _ STR , _ STR + exception . get Message ( ) ) ; on Disconnect ( _ BOOL ) ; }
@  Override public boolean exclude (  String identifier ) { return blacklist . contains ( identifier ) ; }
static private  String  SHORT_ Max_ Plus ( ) { long temp Value =  Short .  MAX_ VALUE + _ NUM ; return  String . value Of ( temp Value ) ; }
public static  String encode (  String value ) { value = value . replace ( _ STR , _ STR ) ; value = value . replace ( _ STR , _ STR ) ; value = value . replace ( _ STR , _ STR ) ; value = value . replace ( _ STR , _ STR ) ; value = value . replace ( _ STR , _ STR ) ; value = value . replace ( _ STR , _ STR ) ; return value ; }
public void create Database Entities For Storage Policy Testing ( ) { create Database Entities For Storage Policy Testing (  Abstract Service Test .  STORAGE_ POLICY_ NAMESPACE_ CD ,  Arrays . as List (  Abstract Service Test .  STORAGE_ POLICY_ RULE_ TYPE ) ,  Abstract Service Test .  BDEF_ NAMESPACE ,  Abstract Service Test .  BDEF_ NAME ,  Arrays . as List (  Abstract Service Test .  FORMAT_ FILE_ TYPE_ CODE ) ,  Arrays . as List (  Abstract Service Test .  STORAGE_ NAME ) ,  Arrays . as List (  Abstract Service Test .  STORAGE_ NAME_2 ) ) ; }
private  PDFPage create Page ( int pagenum ,  PDFObject page Obj ) throws  IOException { int rotation = _ NUM ;  Rect F mediabox = null ;  Rect F cropbox = null ;  PDFObject mediabox Obj = get Inherited Value ( page Obj , _ STR ) ; if ( mediabox Obj != null ) { mediabox = parse Rect ( mediabox Obj ) ; }  PDFObject cropbox Obj = get Inherited Value ( page Obj , _ STR ) ; if ( cropbox Obj != null ) { cropbox = parse Rect ( cropbox Obj ) ; }  PDFObject rotate Obj = get Inherited Value ( page Obj , _ STR ) ; if ( rotate Obj != null ) { rotation = rotate Obj . get Int Value ( ) ; }  Rect F bbox = ( ( cropbox == null ) ? mediabox : cropbox ) ; return new  PDFPage ( pagenum , bbox , rotation , cache ) ; }
static  Map add Element To Map (  String key ,  Set values ,  Map to Map ) { if ( ( key != null ) && ( to Map != null ) ) { to Map . put ( key , values ) ; } return to Map ; }
public void save Boot Prop ( ) throws  IOException { if ( ! boot Prop . equals ( boot Prop Org ) ) { final  String prop File = jar Folder + _ STR ; final  Output Stream os = new  File Output Stream ( prop File ) ; try { boot Prop . store ( os , _ STR ) ; } finally { os . close ( ) ; } } }
private int append (  File System fs ,  Configuration conf ,  Path src ,  Print Writer writer , int current Record Number ) throws  IOException {  Buffered Reader reader = new  Buffered Reader ( new  Input Stream Reader ( fs . open ( src ) ) ) ; try {  String line = reader . read Line ( ) ; while ( line != null ) { if ( line . starts With ( _ STR ) ) { line = _ STR + current Record Number ++ ; } writer . println ( line ) ; line = reader . read Line ( ) ; } return current Record Number ; } finally { reader . close ( ) ; } }
public  Packet Output Stream write Timestamp Length ( final  Calendar calendar ,  Timestamp ts , boolean fractional Seconds ) { assure Buffer Capacity ( fractional Seconds ? _ NUM : _ NUM ) ; buffer . put ( ( byte ) ( fractional Seconds ? _ NUM : _ NUM ) ) ; buffer . put Short ( ( short ) calendar . get (  Calendar .  YEAR ) ) ; buffer . put ( ( byte ) ( ( calendar . get (  Calendar .  MONTH ) + _ NUM ) & _ NUM ) ) ; buffer . put ( ( byte ) ( calendar . get (  Calendar .  DAY_ OF_ MONTH ) & _ NUM ) ) ; buffer . put ( ( byte ) calendar . get (  Calendar .  HOUR_ OF_ DAY ) ) ; buffer . put ( ( byte ) calendar . get (  Calendar .  MINUTE ) ) ; buffer . put ( ( byte ) calendar . get (  Calendar .  SECOND ) ) ; if ( fractional Seconds ) { buffer . put Int ( ts . get Nanos ( ) / _ NUM ) ; } return this ; }
public static  String morpha (  String text , boolean tags ) { if ( text . is Empty ( ) ) { return _ STR ; }  String [ ] text Parts = whitespace . split ( text ) ;  String Builder result = new  String Builder ( ) ; try { for (  String text Part : text Parts ) {  Morpha morpha = new  Morpha ( new  String Reader ( text Part ) , tags ) ; if ( result . length ( ) != _ NUM ) { result . append ( _ STR ) ; } result . append ( morpha . next ( ) ) ; } } catch (  Error e ) { return text ; } catch ( java . io .  IOException e ) { return text ; } return result . to String ( ) ; }
public static void delete File (  File file ) throws  Ade Usage Exception { if ( ! file . delete ( ) ) { throw new  Ade Usage Exception (  FAILED_ DELETING_ FILE + file . get Path ( ) ) ; } }
public  Shape create Check Mark ( final int x , final int y , final int w , final int h ) { double xf = w / _ NUM ; double hf = h / _ NUM ; path . reset ( ) ; path . move To ( x , y + _ NUM * hf ) ; path . line To ( x + _ NUM * xf , y + _ NUM * hf ) ; path . line To ( x + _ NUM * xf , y + _ NUM * hf ) ; path . line To ( x + _ NUM * xf , y ) ; path . line To ( x + _ NUM * xf , y ) ; path . line To ( x + _ NUM * xf , y + _ NUM * hf ) ; path . close Path ( ) ; return path ; }
public  TCPChannel Client (  Executor Service executor ,  TCPChannel Events event Listener ,  String ip , int port ) { this . executor = executor ; executor Thread Check = new  Thread Utils .  Thread Checker ( ) ; executor Thread Check . detach Thread ( ) ; this . event Listener = event Listener ;  Inet Address address ; try { address =  Inet Address . get By Name ( ip ) ; } catch (  Unknown Host Exception e ) { report Error ( _ STR ) ; return ; } if ( address . is Any Local Address ( ) ) { socket = new  TCPSocket Server ( address , port ) ; } else { socket = new  TCPSocket Client ( address , port ) ; } socket . start ( ) ; }
protected void cut Selected Bean ( ) { if (  Debug . debugging ( _ STR ) )  Debug . output ( _ STR ) ; if ( selected Bean == null || selected Bean Location == null ) { if (  Debug . debugging ( _ STR ) )  Debug . output ( _ STR + selected Bean ) ; if (  Debug . debugging ( _ STR ) )  Debug . output ( _ STR + selected Bean Location ) ; clear Selection ( ) ; return ; } try { ser Bean = new  Byte Array Output Stream ( ) ;  Object Output Stream oos = new  Object Output Stream ( ser Bean ) ; oos . write Object ( selected Bean ) ; } catch (  Exception e ) { e . print Stack Trace ( ) ; clear Selection ( ) ; if (  Debug . debugging ( _ STR ) )  Debug . output ( _ STR ) ; return ; } cut Bean = selected Bean ; selected Bean Box . show Cut ( selected Bean ) ; if (  Debug . debugging ( _ STR ) )  Debug . output ( _ STR ) ; }
public void action Performed ( java . awt . event .  Action Event e ) {  Object source = e . get Source ( ) ; if ( ! ( source instanceof  JMenu Item ) ) return ;  JMenu Item mi = (  JMenu Item ) source ;  String name = mi . get Text ( ) ;  OMGraphic Handler Layer target Layer = (  OMGraphic Handler Layer ) layers . get ( name ) ; if ( target Layer == null ) {  Debug . message ( _ STR , _ STR + _ STR + name ) ; return ; } target Layer . do Action ( (  OMGraphic ) transfer Data , new  OMAction (  OMAction .  UPDATE_ GRAPHIC_ MASK ) ) ; }
private void add Entry ( ) { model . add New Entry ( ) ; remove Button . set Enabled ( _ BOOL ) ; }
private void ensure Size ( ) { if ( children ==  EMPTY_ CHILDREN ) { children = new  FPNode [ _ NUM ] ; return ; } int newsize = children . length == _ NUM ?  INITIAL_ SIZE : ( children . length << _ NUM ) ; children =  Arrays . copy Of ( children , newsize ) ; }
public  UUID ( long most Sig Bits , long least Sig Bits ) { this . most Sig Bits = most Sig Bits ; this . least Sig Bits = least Sig Bits ; init ( ) ; }
private static void render Handler (  Faces Context context ,  UIComponent component ,  Collection <  Client Behavior Context .  Parameter > params ,  String handler Name ,  Object handler Value ,  String behavior Event Name ,  String submit Target , boolean needs Submit , boolean include Exec ) throws  IOException {  Response Writer writer = context . get Response Writer ( ) ;  String user Handler = get Non Empty User Handler ( handler Value ) ;  List <  Client Behavior > behaviors = get Client Behaviors ( component , behavior Event Name ) ; if ( ( null != behaviors ) && ( behaviors . size ( ) > _ NUM ) &&  Util . component Is Disabled ( component ) ) { behaviors = null ; } if ( params == null ) { params =  Collections . empty List ( ) ; }  String handler = null ; switch ( get Handler Type ( behaviors , params , user Handler , needs Submit , include Exec ) ) { case  USER_ HANDLER_ ONLY : handler = user Handler ; break ; case  SINGLE_ BEHAVIOR_ ONLY : handler = get Single Behavior Handler ( context , component , behaviors . get ( _ NUM ) , params , behavior Event Name , submit Target , needs Submit ) ; break ; case  SUBMIT_ ONLY : handler = get Submit Handler ( context , component , params , submit Target , _ BOOL ) ; break ; case  CHAIN : handler = get Chained Handler ( context , component , behaviors , params , behavior Event Name , user Handler , submit Target , needs Submit ) ; break ; default : assert ( _ BOOL ) ; } writer . write Attribute ( handler Name , handler , null ) ; }
public  String construct TSDBMetric Name ( ) {  String Builder sb = new  String Builder ( get Scope ( ) ) ; if ( _namespace != null && ! _namespace . is Empty ( ) ) { sb . append ( get Namespace ( ) ) ; } return sb . to String ( ) ; }
protected synchronized void received ( int response Code ,  String stream ,  String json ) {  Follower Info result = parse Followers ( stream , json ) ; if ( result != null ) { no Error ( stream ) ; cached . put ( stream , result ) ; if ( type ==  Follower .  Type .  FOLLOWER ) { listener . received Followers ( result ) ; if ( has New Followers ( result . followers ) ) { listener . new Followers ( result ) ; } } else if ( type ==  Follower .  Type .  SUBSCRIBER ) { listener . received Subscribers ( result ) ; } requested . add ( stream ) ; } else {  String error Message = _ STR ; if ( response Code == _ NUM ) { error Message = _ STR ; error ( stream , _ NUM ) ; } else if ( response Code == _ NUM ) { error Message = _ STR ; error ( stream , _ NUM ) ; } else if ( response Code == _ NUM || response Code == _ NUM ) { error Message = _ STR ; error ( stream , _ NUM ) ; } else if ( response Code == _ NUM ) { error Message = _ STR ; error ( stream , _ NUM ) ; } else { error Message = _ STR ; error ( stream , _ NUM ) ; }  Follower Info error Result = new  Follower Info ( type , stream , error Message ) ; cached . put ( stream , error Result ) ; if ( type ==  Follower .  Type .  FOLLOWER ) { listener . received Followers ( error Result ) ; } else if ( type ==  Follower .  Type .  SUBSCRIBER ) { listener . received Subscribers ( error Result ) ; } } }
public static <  T >  List <  T > select (  Connection connection ,  String raw Sql Query ,  Row Processor <  T > row Processor ,  Object ... parameters ) throws  IOException ,  SQLException {  Prepared Statement stmt = null ;  Result Set rs = null ; try { stmt = connection . prepare Statement ( raw Sql Query ) ; for ( int index = _ NUM ; index < parameters . length ; index ++ ) {  Jdbc Utils . bind Parameter ( stmt , index + _ NUM , parameters [ index ] ) ; } rs = stmt . execute Query ( ) ;  List <  T > result =  Lists . new Linked List ( ) ; while ( rs . next ( ) ) { result . add ( row Processor . process ( rs ) ) ; } return result ; } finally {  Jdbc Utils . close Result Set ( rs ) ;  Jdbc Utils . close Statement ( stmt ) ; } }
public  Future <  Sync Reply > send Request ( int xid ,  Sync Message request ) throws  Remote Store Exception { ensure Connected ( ) ;  Remote Sync Future future = new  Remote Sync Future ( xid , connection Generation ) ; future Map . put (  Integer . value Of ( xid ) , future ) ; if ( future Map . size ( ) >  MAX_ PENDING_ REQUESTS ) { synchronized ( future Notify ) { while ( future Map . size ( ) >  MAX_ PENDING_ REQUESTS ) { try { future Notify . wait ( ) ; } catch (  Interrupted Exception e ) { throw new  Remote Store Exception ( _ STR , e ) ; } } } } channel . write And Flush ( request ) ; return future ; }
public static boolean is Empty (  String str ) { return ( null == str || _ NUM == str . length ( ) ) ; }
public void enable Dependency (  Capability c ) { if ( do Not Check Capabilities ( ) ) { return ; } if ( c ==  Capability .  NOMINAL_ ATTRIBUTES ) { enable Dependency (  Capability .  BINARY_ ATTRIBUTES ) ; } else if ( c ==  Capability .  BINARY_ ATTRIBUTES ) { enable Dependency (  Capability .  UNARY_ ATTRIBUTES ) ; } else if ( c ==  Capability .  UNARY_ ATTRIBUTES ) { enable Dependency (  Capability .  EMPTY_ NOMINAL_ ATTRIBUTES ) ; } else if ( c ==  Capability .  NOMINAL_ CLASS ) { enable Dependency (  Capability .  BINARY_ CLASS ) ; } m_ Dependencies . add ( c ) ; }
public  IVariable [ ] extract Robot Debug Variables ( final int stack Trace Id , final  Map <  String ,  Object > new Variables ) { final  Robot Debug Variables Context current Variables Context = find Current Variables Context ( stack Trace Id ) ;  Map <  String ,  IVariable > previous Variables Map = init Previous Variables State ( current Variables Context ) ; final  Map <  String ,  IVariable > non Global Variables Map = new  Linked Hash Map < > ( ) ; if ( previous Variables Map == null ) { init New Non Global Variables ( new Variables , non Global Variables Map ) ; } else { init Variables Comparing With Previous State ( new Variables , previous Variables Map , non Global Variables Map ) ; } final  Linked List <  IVariable > current Variables List = create Current Variables List ( non Global Variables Map ) ; save Current Variables State ( stack Trace Id , current Variables Context , non Global Variables Map ) ; return current Variables List . to Array ( new  IVariable [ current Variables List . size ( ) ] ) ; }
public  Resources Poet add Integer (  String name ,  String value ) {  Element bool = document . create Element ( _ STR ) ; bool . set Attribute ( _ STR , name ) ; bool . append Child ( document . create Text Node (  String . value Of ( value ) ) ) ; resource Element . append Child ( bool ) ; return this ; }
public int available In Process ( ) { return  Math . max ( _ NUM , max In Process - pending . size ( ) ) ; }
public boolean should Execute Action ( ) { if ( delay <= _ NUM ) { return _ BOOL ; } long time Passed =  System . current Time Millis ( ) - last Action Executed ; if ( time Passed > delay * _ NUM ) { last Action Executed =  System . current Time Millis ( ) ; return _ BOOL ; } return _ BOOL ; }
protected void handle Or Defer Message (  Distribution Message msg ) { synchronized ( startup Lock ) { if ( being Sick || playing Dead ) { if ( msg . contains Region Content Change ( ) || msg instanceof  Partition Message With Direct Reply ) { startup Messages . add ( new  Startup Event ( msg ) ) ; return ; } } if ( ! processing Events ) { startup Messages . add ( new  Startup Event ( msg ) ) ; return ; } } dispatch Message ( msg ) ; }
public boolean zone Export Remove Volumes (  List <  Network Zoning Param > zoning Params ,  Collection <  URI > volume URIs ,  String step Id ) {  Network Zoning Param zoning Param = zoning Params . get ( _ NUM ) ; _log . info (  String . format ( _ STR , zoning Param . get Export Group Display ( ) , volume URIs . to String ( ) ) ) ; return do Zone Export Masks Delete ( zoning Params , volume URIs , step Id ) ; }
private void shutdown ( ) { if ( nbest List Writer != null ) { logger . info ( _ STR ) ; nbest List Writer . close ( ) ; } if ( alignment Writer != null ) { logger . info ( _ STR ) ; alignment Writer . close ( ) ; } }
@  Override public void paint Icon (  Component c ,  Graphics g , int x , int y ) {  Painter painter = (  Painter )  UIManager . get ( prefix + _ STR + key ) ; if ( painter != null ) {  JComponent jc = ( c instanceof  JComponent ) ? (  JComponent ) c : null ;  Graphics2 D gfx = (  Graphics2 D ) g ; gfx . translate ( x , y ) ; painter . paint ( gfx , jc , width , height ) ; gfx . translate ( - x , - y ) ; } }
public  List <  Map <  String ,  String > > list (  Database conn ) throws  SQLException {  Result Set rs = null ;  Statement statement = conn . create Statement ( ) ;  List <  Map <  String ,  String > > shard To Channels = new  Array List <  Map <  String ,  String > > ( ) ; try { rs = statement . execute Query ( select ) ; while ( rs . next ( ) ) {  Map <  String ,  String > shard = new  Hash Map <  String ,  String > ( ) ; shard . put (  Shard Channel Table .  SHARD_ ID_ COL , rs . get String (  Shard Channel Table .  SHARD_ ID_ COL ) ) ; shard . put (  Shard Channel Table .  CHANNEL_ COL , rs . get String (  Shard Channel Table .  CHANNEL_ COL ) ) ; shard To Channels . add ( shard ) ; } } finally { close ( rs ) ; close ( statement ) ; } return shard To Channels ; }
public  Boolean is Hidden (  File f ) {  String name = f . get Name ( ) ; if ( ( name != null ) && ! name . equals ( _ STR ) && ( name . char At ( _ NUM ) == _ STR ) ) { return  Boolean .  TRUE ; } else { return  Boolean .  FALSE ; } }
private boolean scroll View Can Scroll Vertically (  Scroll View scroll View , int direction ) { final int offset =  Math . max ( _ NUM , scroll View . get Scroll Y ( ) ) ; final int range = compute Vertical Scroll Range ( scroll View ) - scroll View . get Height ( ) ; if ( range == _ NUM ) return _ BOOL ; if ( direction < _ NUM ) { return offset > _ NUM ; } else { return offset < range - _ NUM ; } }
public  Jar Info load Jar ( ) throws  IOException {  Zip Input Stream zis = null ;  Manifest mf = null ; boolean empty = _ BOOL ; try { zis = new  Zip Input Stream ( jar Stream ) ;  Zip Entry ent = null ; while ( ( ent = zis . get Next Entry ( ) ) != null ) { empty = _ BOOL ;  String name = ent . get Name ( ) ; if (  Manifest . is Manifest Name ( name ) ) {  Byte Array Output Stream baos = new  Byte Array Output Stream ( ) ; byte buffer [ ] = new byte [ _ NUM ] ; for ( ; ; ) { int len = zis . read ( buffer ) ; if ( len < _ NUM ) { break ; } baos . write ( buffer , _ NUM , len ) ; } byte [ ] buf = baos . to Byte Array ( ) ; mf = new  Manifest ( buf ) ; } } } catch (  IOException ex ) { throw ex ; } catch (  Throwable th ) { th . print Stack Trace ( ) ; throw new  IOException ( _ STR + th ) ; } finally { if ( zis != null ) { try { zis . close ( ) ; } catch (  Exception ex ) { } } } if ( empty ) { throw new  IOException ( _ STR ) ; }  Jar Info ji = create Jar Info ( mf ) ; return ji ; }
public void invalidate Title Sortable ( ) { for (  Movie movie : new  Array List < > ( movie List ) ) { movie . clear Title Sortable ( ) ; } }
public void add Row (  Assignment head , double prob ) { if ( prob < _ NUM || prob > _ NUM ) { return ; } head Vars . add All ( head . get Variables ( ) ) ; table . put ( head , prob ) ; }
public byte [ ] create Jar From File Content ( final  String file Name , final  String content ) throws  IOException {  Byte Array Output Stream byte Array Output Stream = new  Byte Array Output Stream ( ) ;  Jar Output Stream jar Output Stream = new  Jar Output Stream ( byte Array Output Stream ) ;  Jar Entry entry = new  Jar Entry ( file Name ) ; entry . set Time (  System . current Time Millis ( ) ) ; jar Output Stream . put Next Entry ( entry ) ; jar Output Stream . write ( content . get Bytes ( ) ) ; jar Output Stream . close Entry ( ) ; jar Output Stream . close ( ) ; return byte Array Output Stream . to Byte Array ( ) ; }
private boolean go To ( long day , boolean animate , boolean set Selected , boolean force Scroll ) { if ( set Selected ) { m Selected Day . set Time In Millis ( day ) ; } m Temp Day . set Time In Millis ( day ) ; final int position = get Position From Day ( day ) ;  View child ; int i = _ NUM ; int top = _ NUM ; do { child = get Child At ( i ++ ) ; if ( child == null ) { break ; } top = child . get Top ( ) ; } while ( top < _ NUM ) ; int selected Position ; if ( child != null ) { selected Position = get Position For View ( child ) ; } else { selected Position = _ NUM ; } if ( set Selected ) { m Adapter . set Selected Day ( m Selected Day ) ; } if ( position != selected Position || force Scroll ) { set Month Displayed ( m Temp Day ) ; m Previous Scroll State =  On Scroll Listener .  SCROLL_ STATE_ FLING ; if ( animate ) { smooth Scroll To Position From Top ( position ,  LIST_ TOP_ OFFSET ,  GOTO_ SCROLL_ DURATION ) ; return _ BOOL ; } else { post Set Selection ( position ) ; } } else if ( set Selected ) { set Month Displayed ( m Selected Day ) ; } return _ BOOL ; }
public boolean search (  V v ) { int h = hash Method . hash ( v ) ;  Linked List <  V > list = (  Linked List <  V > ) table [ h ] ; if ( list == null ) { return _ BOOL ; } return list . contains ( v ) ; }
@  Override public void message Item Details (  String str Class ,  String item ,  String description ,  String [ ] msg Option , int [ ] msg Number , int default Option ) {  Hash Map <  Integer ,  String > options = new  Hash Map < > ( msg Option . length ) ; for ( int i = _ NUM ; i < msg Option . length ; i ++ ) { options . put ( msg Number [ i ] , msg Option [ i ] ) ; } message Item Details ( str Class , description , item , options , default Option ) ; }
public void add Listener (  Color Map Listener listener ) { listeners . add ( listener ) ; }
protected void compute PDists (  Relation <  O > relation ,  KNNQuery <  O > knn ,  Writable Double Data Store pdists ) {  Finite Progress prds Progress =  LOG . is Verbose ( ) ? new  Finite Progress ( _ STR , relation . size ( ) ,  LOG ) : null ; for (  DBIDIter iditer = relation . iter DBIDs ( ) ; iditer . valid ( ) ; iditer . advance ( ) ) { final  KNNList neighbors = knn . get KNNFor DBID ( iditer , kreach + _ NUM ) ; int ks = _ NUM ; double ssum = _ NUM ; for (  Double DBIDList Iter neighbor = neighbors . iter ( ) ; neighbor . valid ( ) && ks < kreach ; neighbor . advance ( ) ) { if (  DBIDUtil . equal ( neighbor , iditer ) ) { continue ; } final double d = neighbor . double Value ( ) ; ssum += d * d ; ks ++ ; } double pdist = ks > _ NUM ?  Math . sqrt ( ssum / ks ) : _ NUM ; pdists . put Double ( iditer , pdist ) ;  LOG . increment Processed ( prds Progress ) ; }  LOG . ensure Completed ( prds Progress ) ; }
External Problem (  Process process ) { this ( process . get Input Stream ( ) , process . get Output Stream ( ) ) ;  Redirect Stream . redirect ( process . get Error Stream ( ) ,  System . err ) ; }
protected static boolean network Monitor Exist (  String nw Mon Name ) {  String class Method = _ STR ; if ( debug . message Enabled ( ) ) { debug . message ( class Method + _ STR + nw Mon Name ) ; } if ( ( nw Mon Name == null ) || ( nw Mon Name . length ( ) == _ NUM ) ) { if ( debug . warning Enabled ( ) ) { debug . warning ( class Method + _ STR ) ; } return _ BOOL ; }  Set <  String > ntw Stats =  Network Monitor . get Instance Names ( ) ;  String ss = nw Mon Name . to Lower Case ( ) ; if ( ntw Stats . contains ( ss ) ) { return _ BOOL ; } else { return _ BOOL ; } }
public void and With (  List <  Query Predicate > predicates ) { children . add All ( predicates ) ; }
public void add Roll (  MMRandom rng ) { int result = rng . random Int ( this . faces ) + this . min ; all . add Element ( new  Integer ( result ) ) ; this . total += result ; if ( keep != - _ NUM && all . size ( ) >= keep ) { this . total = _ NUM ;  Collections . sort ( all ,  Collections . reverse Order ( ) ) ; for ( int i = _ NUM ; i < keep ; i ++ ) { this . total += all . get ( i ) ; } } }
public boolean check Canonical User Options ( ) { boolean result ;  Option Handler handler ;  String [ ] user Options ;  String [ ] user Options Check ; print ( _ STR ) ; try { handler = get Default Handler ( ) ; handler . set Options ( get User Options ( ) ) ; if ( get Debug ( ) ) { print ( _ STR ) ; } user Options = handler . get Options ( ) ; if ( get Debug ( ) ) { println ( print Options ( user Options ) ) ; } if ( get Debug ( ) ) { println ( _ STR ) ; } handler . set Options ( user Options . clone ( ) ) ; if ( get Debug ( ) ) { println ( _ STR ) ; } user Options Check = handler . get Options ( ) ; compare Options ( user Options , user Options Check ) ; println ( _ STR ) ; result = _ BOOL ; } catch (  Exception e ) { println ( _ STR ) ; result = _ BOOL ; if ( get Debug ( ) ) { println ( e ) ; } } return result ; }
public static void close Quietly ( final  Closeable closeable ) { if ( closeable != null ) { try { closeable . close ( ) ; } catch ( final  Runtime Exception rethrown ) { throw rethrown ; } catch ( final  Exception ignored ) { } } }
public static void push Encrypted Message ( final  Text Secure Envelope envelope ) { while ( _ BOOL ) { try { queue . put ( envelope ) ; return ; } catch ( final  Interrupted Exception e ) { } } }
public static int random Range Int ( int min , int max ) { return ( int ) (  Math . random ( ) < _ NUM ? ( ( _ NUM -  Math . random ( ) ) * ( max - min ) + min ) : (  Math . random ( ) * ( max - min ) + min ) ) ; }
public void test_simple Premature Close ( ) {  Striterator iter = new  Striterator ( m_data . iterator ( ) ) ; int i = _ NUM ; while ( iter . has Next ( ) ) { iter . next ( ) ; if ( ++ i == _ NUM ) { iter . close ( ) ; assert True ( ! iter . has Next ( ) ) ; } } assert True ( ! iter . is Open ( ) ) ; assert True ( i == _ NUM ) ; }
public void push Draw List (  Psp Ge List list ) { synchronized ( draw List Queue ) { draw List Queue . add ( list ) ; } }
private void populate Task List (  Volume source ,  Map <  Block Mirror ,  Volume > group Mirror Source Map ,  Task List task List ,  String task Id ,  Resource Operation Type Enum operation Type ) {  Set <  URI > group Set = new  Hash Set <  URI > ( ) ; add Task ( task List , source , task Id , operation Type ) ; for (  Entry <  Block Mirror ,  Volume > entry : group Mirror Source Map . entry Set ( ) ) {  Block Mirror mirror = entry . get Key ( ) ;  Volume mirror Source = entry . get Value ( ) ; if ( source . is In CG ( ) && null != task List . get Task List ( ) ) { group Set . add ( mirror Source . get Consistency Group ( ) ) ; } }  List <  Block Consistency Group > groups = _db Client . query Object (  Block Consistency Group . class , group Set ) ; for (  Block Consistency Group group : groups ) { add Task ( task List , group , task Id , operation Type ) ; } }
public  String cluster Definitions Tip Text ( ) { return _ STR ; }
public void add Listener (  Navigator Listener listener ) { listeners . add ( listener ) ; }
public void close Stream ( ) {  Carbon Util . close Streams ( stream ) ; executor Service . shutdown ( ) ; }
public double patience ( int k ,  F f , int  N ) { double pf = p ( f ) ;  Binomial Distribution dist = new  Binomial Distribution ( null ,  N , pf ) ; double p0 =  Math . pow ( _ NUM - pf ,  N ) ; return _ NUM - ( dist . cumulative Probability ( k - _ NUM ) - p0 ) / ( _ NUM - p0 ) ; }
public static  List series Name List From Data Array (  Object [ ] [ ] data ) { int series Count = data . length ;  List series Name List = new java . util .  Array List ( series Count ) ; for ( int i = _ NUM ; i < series Count ; i ++ ) { series Name List . add ( _ STR + ( i + _ NUM ) ) ; } return series Name List ; }
@  Override public int read ( char b [ ] , int off , int len ) throws  IOException { ensure Open ( ) ; if ( ( off < _ NUM ) || ( off > b . length ) || ( len < _ NUM ) || ( ( off + len ) > b . length ) || ( ( off + len ) < _ NUM ) ) { throw new  Index Out Of Bounds Exception ( ) ; } else if ( len == _ NUM ) { return _ NUM ; } if ( pos >= count ) { return - _ NUM ; } if ( pos + len > count ) { len = count - pos ; } if ( len <= _ NUM ) { return _ NUM ; }  System . arraycopy ( buf , pos , b , off , len ) ; pos += len ; return len ; }
private static void expand Number At (  String number String , int start Index ,  Word Relation word Relation ) { expand Number ( number String . substring ( start Index , number String . length ( ) ) , word Relation ) ; }
@  Override public void run ( ) {  Multiple Objects Bundle data = generator . load Data ( ) ; if (  LOG . is Verbose ( ) ) {  LOG . verbose ( _ STR ) ; } try { if ( output File . exists ( ) &&  LOG . is Verbose ( ) ) {  LOG . verbose ( _ STR + output File + _ STR + _ STR ) ; } try (  Output Stream Writer out Stream = new  File Writer ( output File , _ BOOL ) ) { write Clusters ( out Stream , data ) ; } } catch (  IOException e ) { throw new  Abort Exception ( _ STR , e ) ; } if (  LOG . is Verbose ( ) ) {  LOG . verbose ( _ STR ) ; } }
private boolean used All Rule17 Directors (  Set <  String > allocated Directors ,  Port Allocation Context context ) {  Set <  String > rule17 Directors = get Rule17 Directors ( context ) ; for (  String director : allocated Directors ) { rule17 Directors . remove ( director ) ; } return rule17 Directors . is Empty ( ) ; }
public void stop ( ) { synchronized ( private Instance Lock ) { if ( connection Accept Thread == null ) { return ; } } is Stopped . set ( _ BOOL ) ; try { connection Accept Thread . interrupt ( ) ; connection Accept Thread . join ( ) ; } catch (  Interrupted Exception e ) { } try { server Socket . close ( ) ; } catch (  IOException e ) { } }
private static  String expand System Id Strict On (  String system Id ,  String base System Id ) throws  URI .  Malformed URIException {  URI system URI = new  URI ( system Id , _ BOOL ) ; if ( system URI . is Absolute URI ( ) ) { return system Id ; }  URI base URI = null ; if ( base System Id == null || base System Id . length ( ) == _ NUM ) { base URI = get User Dir ( ) ; } else { base URI = new  URI ( base System Id , _ BOOL ) ; if ( ! base URI . is Absolute URI ( ) ) { base URI . absolutize ( get User Dir ( ) ) ; } } system URI . absolutize ( base URI ) ; return system URI . to String ( ) ; }
public static void free (  DMessage msg ) { int index = size2 Index ( msg . get Size ( ) ) ; msg . clear ( ) ; if ( index < _ NUM ) ; else if ( m_cache [ index ] != null ) ; else m_cache [ index ] = msg ; }
public boolean equals Ignore Case ( final  Str Builder other ) { if ( this == other ) { return _ BOOL ; } if ( this . size != other . size ) { return _ BOOL ; } final char this Buf [ ] = this . buffer ; final char other Buf [ ] = other . buffer ; for ( int i = size - _ NUM ; i >= _ NUM ; i -- ) { final char c1 = this Buf [ i ] ; final char c2 = other Buf [ i ] ; if ( c1 != c2 &&  Character . to Upper Case ( c1 ) !=  Character . to Upper Case ( c2 ) ) { return _ BOOL ; } } return _ BOOL ; }
protected static  Long convert Uuid To Long (  UUID uuid ) { if ( uuid == null ) { return null ; }  Long converted Uuid ; if ( uuid . version ( ) == _ NUM ) { converted Uuid = uuid . timestamp ( ) ; } else { converted Uuid = uuid . get Most Significant Bits ( ) ; } return converted Uuid ; }
public void add VMArguments (  String vm Argument Name ,  String vm Argument Value ) {  Vm Argument Data vm Arg = new  Vm Argument Data ( vm Argument Name , vm Argument Value ) ; vm Set . add ( vm Arg ) ; }
private void apply To (  Class Visitor v ,  Field f ) { if (  Log . is Logging On ( ) ) {  Log . log Line (  String . format ( _ STR , f . to Generic String ( ) ) ) ; } v . visit ( f ) ; }
public void test Compare To Equal Neg ( ) { byte a Bytes [ ] = { _ NUM , _ NUM , _ NUM , - _ NUM , - _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , - _ NUM , _ NUM , _ NUM , _ NUM , _ NUM } ; byte b Bytes [ ] = { _ NUM , _ NUM , _ NUM , - _ NUM , - _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , - _ NUM , _ NUM , _ NUM , _ NUM , _ NUM } ; int a Sign = - _ NUM ; int b Sign = - _ NUM ;  Big Integer a Number = new  Big Integer ( a Sign , a Bytes ) ;  Big Integer b Number = new  Big Integer ( b Sign , b Bytes ) ; assert Equals ( _ NUM , a Number . compare To ( b Number ) ) ; }
public void test Screenshot ( ) throws  Exception {  Log . d (  LOG_ TAG , _ STR ) ;  Screenshot Stub Activity activity = get Activity ( ) ; assert Not Null ( activity ) ;  File screenshot Dir = get Screenshot Dir ( ) ;  New Screenshot Observer observer = new  New Screenshot Observer ( screenshot Dir . get Absolute Path ( ) ) ; observer . start Watching ( ) ; take Screenshot ( ) ; if ( observer . get Created Path ( ) == null ) { synchronized ( observer ) { observer . wait (  SCREEN_ WAIT_ TIME_ SEC * _ NUM ) ; } } assert Not Null (  String . format ( _ STR ,  SCREEN_ WAIT_ TIME_ SEC ) , observer . get Created Path ( ) ) ;  File screenshot File = new  File ( screenshot Dir , observer . get Created Path ( ) ) ; try { assert True (  String . format ( _ STR , screenshot File . get Name ( ) ) , screenshot File . is File ( ) ) ; assert True (  String . format ( _ STR , screenshot File . get Name ( ) ) , is Valid Image ( screenshot File ) ) ; } finally { screenshot File . delete ( ) ; } }
public  Task Resource Rep unlink Target Volumes From Snapshot Session (  URI snap Session URI ,  Snapshot Session Unlink Targets Param param ) { return unlink Target Volumes From Snapshot Session ( snap Session URI , param ,  Operation Type Enum .  UNLINK_ SNAPSHOT_ SESSION_ TARGET ) ; }
private  List reverse (  List seq ) {  Linked List new Seq = new  Linked List ( ) ; for (  Iterator i = seq . iterator ( ) ; i . has Next ( ) ; ) {  Directed Edge de = (  Directed Edge ) i . next ( ) ; new Seq . add First ( de . get Sym ( ) ) ; } return new Seq ; }
@  Deprecated @  Override public  String read Line ( ) throws  IOException {  String Builder b = new  String Builder ( _ NUM ) ; int chr ; while ( ( chr = read ( ) ) >= _ NUM ) { if ( chr != _ STR ) { b . append ( ( char ) chr ) ; } else { return b . to String ( ) ; } } return b . to String ( ) ; }
private void add To Scene ( final  Node items ) { collection . add ( items ) ; }
public  String documentation Home Page Url ( ) { return properties . get Property ( _ STR ) ; }
public static boolean has Taxonomy Info (  Sequences Reader reader ) { final  File taxon File = new  File ( reader . path ( ) ,  TAXONOMY_ FILE ) ; final  File mapping File = new  File ( reader . path ( ) ,  TAXONOMY_ TO_ SEQUENCE_ FILE ) ; if ( taxon File . exists ( ) && mapping File . exists ( ) ) { return _ BOOL ; } else if ( taxon File . exists ( ) || mapping File . exists ( ) ) { throw new  No Talkback Slim Exception ( _ STR ) ; } else { return _ BOOL ; } }
public void remove Selection Listener ( final  Selection Listener listener ) { check Widget ( ) ; if ( listener == null ) {  SWT . error (  SWT .  ERROR_ NULL_ ARGUMENT ) ; } list Of Selection Listeners . remove ( listener ) ; }
public void replace (  Class Node type , int n ) { remove ( n ) ; push ( type ) ; }
public void handle Button1 Request (  Request Invocation Event event ) throws  Model Control Exception { submit Cycle = _ BOOL ;  Entities Model model = (  Entities Model ) get Model ( ) ;  AMProperty Sheet prop = (  AMProperty Sheet ) get Child (  PROPERTY_ ATTRIBUTE ) ;  String universal Id = (  String ) get Page Session Attribute (  UNIVERSAL_ ID ) ; try {  Map old Values = model . get Attribute Values ( universal Id , _ BOOL ) ;  Map values = prop . get Attribute Values ( old Values , _ BOOL , model ) ;  String cur Realm = (  String ) get Page Session Attribute (  AMAdmin Constants .  CURRENT_ REALM ) ; model . modify Entity ( cur Realm , universal Id , values ) ; set Inline Alert Message (  CCAlert .  TYPE_ INFO , _ STR , _ STR ) ; } catch (  AMConsole Exception e ) { set Inline Alert Message (  CCAlert .  TYPE_ ERROR , _ STR , e . get Message ( ) ) ; } forward To ( ) ; }
private static  Boolean is Inside Polygon ( final  Geo Point point , final  List <  Geo Point > poly Points ) { final double latitude = point . get Latitude ( ) ; final double longitude = point . get Longitude ( ) ; final double sin Latitude =  Math . sin ( latitude ) ; final double cos Latitude =  Math . cos ( latitude ) ; final double sin Longitude =  Math . sin ( longitude ) ; final double cos Longitude =  Math . cos ( longitude ) ; double arc Distance = _ NUM ;  Double prev Angle = null ; for ( final  Geo Point poly Point : poly Points ) { final  Double angle = compute Angle ( poly Point , sin Latitude , cos Latitude , sin Longitude , cos Longitude ) ; if ( angle == null ) { return null ; } if ( prev Angle != null ) { double angle Delta = angle - prev Angle ; if ( angle Delta < -  Math .  PI ) { angle Delta +=  Math .  PI * _ NUM ; } if ( angle Delta >  Math .  PI ) { angle Delta -=  Math .  PI * _ NUM ; } if (  Math . abs ( angle Delta -  Math .  PI ) <  Vector .  MINIMUM_ RESOLUTION ) { return null ; } arc Distance += angle Delta ; } prev Angle = angle ; } if ( prev Angle != null ) { final  Double last Angle = compute Angle ( poly Points . get ( _ NUM ) , sin Latitude , cos Latitude , sin Longitude , cos Longitude ) ; if ( last Angle == null ) { return null ; } double angle Delta = last Angle - prev Angle ; if ( angle Delta < -  Math .  PI ) { angle Delta +=  Math .  PI * _ NUM ; } if ( angle Delta >  Math .  PI ) { angle Delta -=  Math .  PI * _ NUM ; } if (  Math . abs ( angle Delta -  Math .  PI ) <  Vector .  MINIMUM_ RESOLUTION ) { return null ; } arc Distance += angle Delta ; } if (  Math . abs ( arc Distance ) <  Vector .  MINIMUM_ RESOLUTION ) { return null ; } return arc Distance > _ NUM ; }
private  Node delete Max (  Node x ) { if ( x . right == null ) return x . left ; x . right = delete Max ( x . right ) ; x . size = _ NUM + size ( x . left ) + size ( x . right ) ; x . height = _ NUM +  Math . max ( height ( x . left ) , height ( x . right ) ) ; return balance ( x ) ; }
protected void on Progress ( int itemcount , int size ) { }
private  Tree Node ( long node Value ,  Snmp Mib Agent agent ,  Tree Node sup ) { this . node Value = node Value ; this . parent = sup ; agents . add Element ( agent ) ; }
public  Week (  Date time ) { this ( time ,  Time Zone . get Default ( ) ,  Locale . get Default ( ) ) ; }
public  Code Attribute create Code ( ) {  Code Attribute code = new  Code Attribute ( ) ; for ( int i = _ NUM ; i < _attributes . size ( ) ; i ++ ) {  Attribute attr = _attributes . get ( i ) ; if ( attr instanceof  Code Attribute ) return (  Code Attribute ) attr ; } return null ; }
public  Binary Out (  String filename ) { try {  Output Stream os = new  File Output Stream ( filename ) ; out = new  Buffered Output Stream ( os ) ; } catch (  IOException e ) { e . print Stack Trace ( ) ; } }
public static boolean create New File (  File target File ) { if ( target File . exists ( ) ) target File . delete ( ) ; try { return target File . create New File ( ) ; } catch (  IOException e ) { return _ BOOL ; } }
public void test Zero One ( ) { byte a Bytes [ ] = { _ NUM } ; byte b Bytes [ ] = { _ NUM } ; int a Sign = _ NUM ; int b Sign = _ NUM ; byte r Bytes [ ] = { _ NUM } ;  Big Integer a Number = new  Big Integer ( a Sign , a Bytes ) ;  Big Integer b Number = new  Big Integer ( b Sign , b Bytes ) ;  Big Integer result = a Number . or ( b Number ) ; byte res Bytes [ ] = new byte [ r Bytes . length ] ; res Bytes = result . to Byte Array ( ) ; for ( int i = _ NUM ; i < res Bytes . length ; i ++ ) { assert True ( res Bytes [ i ] == r Bytes [ i ] ) ; } assert Equals ( _ STR , _ NUM , result . signum ( ) ) ; }
protected int execute Prepare Statement (  List <  Column > columns ,  Prepared Statement statement ) throws  SQLException { int bind No = _ NUM ; for (  Column c : columns ) { set Column Value ( statement , bind No , c ) ; bind No ++ ; } return statement . execute Update ( ) ; }
public  Config (  Saml Authority Configuration saml Authority Config ,  Token Restrictions token Restrictions ,  Collection <  List <  Certificate > > valid Certs , long clock Tolerance ,  Collection <  IDPConfig > in External Idps ) {  Validate . not Null ( saml Authority Config ) ;  Validate . not Null ( token Restrictions ) ;  Validate . not Empty ( valid Certs ) ;  List <  Certificate > authority Cert = saml Authority Config . get Signing Certificate Chain ( ) ; boolean authority Cert In Valid Certs = _ BOOL ; for (  List <  Certificate > current Chain : valid Certs ) {  Validate . not Empty ( current Chain ) ;  Validate . no Null Elements ( current Chain ) ; if ( ! authority Cert In Valid Certs && current Chain . equals ( authority Cert ) ) { authority Cert In Valid Certs = _ BOOL ; } }  Validate . is True ( authority Cert In Valid Certs , _ STR ) ;  Validate . is True ( clock Tolerance >= _ NUM ) ; this . saml Authority Config = saml Authority Config ; this . valid Certs = valid Certs ; this . clock Tolerance = clock Tolerance ; this . token Restrictions = token Restrictions ;  Hash Map <  String ,  IDPConfig > idps Set = new  Hash Map <  String ,  IDPConfig > ( ) ; if ( in External Idps != null ) { for (  IDPConfig conf : in External Idps ) { if ( conf != null ) { idps Set . put ( conf . get Entity ID ( ) , conf ) ; } } } this . external Idps =  Collections . unmodifiable Map ( idps Set ) ; }
public static void check Not Empty (  String string ) { if ( string . is Empty ( ) ) { throw new  Null Pointer Exception ( ) ; } }
public void cancel Unnamed Tasks ( ) { if ( unnamed Task Executor != null ) { unnamed Task Executor . shutdown Now ( ) ; } }
private char read Escape Character ( ) throws  IOException { if ( pos == limit && ! fill Buffer ( _ NUM ) ) { throw syntax Error ( _ STR ) ; } char escaped = buffer [ pos ++ ] ; switch ( escaped ) { case _ STR : if ( pos + _ NUM > limit && ! fill Buffer ( _ NUM ) ) { throw syntax Error ( _ STR ) ; } char result = _ NUM ; for ( int i = pos , end = i + _ NUM ; i < end ; i ++ ) { char c = buffer [ i ] ; result <<= _ NUM ; if ( c >= _ STR && c <= _ STR ) { result += ( c - _ STR ) ; } else if ( c >= _ STR && c <= _ STR ) { result += ( c - _ STR + _ NUM ) ; } else if ( c >= _ STR && c <= _ STR ) { result += ( c - _ STR + _ NUM ) ; } else { throw new  Number Format Exception ( _ STR + new  String ( buffer , pos , _ NUM ) ) ; } } pos += _ NUM ; return result ; case _ STR : return _ STR ; case _ STR : return _ STR ; case _ STR : return _ STR ; case _ STR : return _ STR ; case _ STR : return _ STR ; case _ STR : line Number ++ ; line Start = pos ; case _ STR : case _ STR : case _ STR : case _ STR : return escaped ; default : throw syntax Error ( _ STR ) ; } }
private void fix Spanned With Spaces (  Spannable String Builder builder , int width Measure Spec , int height Measure Spec ) { long start Fix =  System . current Time Millis ( ) ;  Fixing Result result = add Spaces Around Spans Until Fixed ( builder , width Measure Spec , height Measure Spec ) ; if ( result . fixed ) { remove Unneeded Spaces ( width Measure Spec , height Measure Spec , builder , result ) ; } else { fallback To String ( width Measure Spec , height Measure Spec ) ; } long fix Duration =  System . current Time Millis ( ) - start Fix ;  Logger . d (  TAG , _ STR + fix Duration ) ; }
public  Events Integration Test ( ) { set Response Log Length Limit ( _ NUM ) ; date Format = new  Simple Date Format ( _ STR ) ;  Calendar cal =  Calendar . get Instance ( ) ; cal . add (  Calendar .  DATE , - _ NUM ) ; yesterday = date Format . format ( cal . get Time ( ) ) ; yesterday += _ STR ; cal =  Calendar . get Instance ( ) ; cal . add (  Calendar .  DATE , _ NUM ) ; today = date Format . format ( cal . get Time ( ) ) ; today += _ STR ; cal =  Calendar . get Instance ( ) ; cal . add (  Calendar .  DATE , _ NUM ) ; tomorrow = date Format . format ( cal . get Time ( ) ) ; tomorrow += _ STR ; cal =  Calendar . get Instance ( ) ; cal . add (  Calendar .  DATE , _ NUM ) ; tomorrow Plus3 = date Format . format ( cal . get Time ( ) ) ; tomorrow Plus3 += _ STR ; cal =  Calendar . get Instance ( ) ; cal . add (  Calendar .  DATE , - _ NUM ) ; yesterday Minus3 = date Format . format ( cal . get Time ( ) ) ; yesterday Minus3 += _ STR ; cal =  Calendar . get Instance ( ) ; cal . add (  Calendar .  DATE , _ NUM ) ; tomorrow Plus5 = date Format . format ( cal . get Time ( ) ) ; tomorrow Plus5 += _ STR ; cal =  Calendar . get Instance ( ) ; cal . add (  Calendar .  DATE , - _ NUM ) ; yesterday Minus5 = date Format . format ( cal . get Time ( ) ) ; yesterday Minus5 += _ STR ; experiment =  Experiment Factory . create Experiment ( ) ; experiment . start Time = yesterday Minus3 ; experiment . end Time = tomorrow Plus3 ; experiment . sampling Percent = _ NUM ; experiment . label = _ STR ; experiment . application Name =  QBO +  UUID . random UUID ( ) ;  Default Name Exclusion Strategy experiment Comparison Strategy = new  Default Name Exclusion Strategy ( _ STR , _ STR , _ STR ) ; experiment . set Serialization Strategy ( experiment Comparison Strategy ) ; }
public  Simple Metric Group (  Group Name name ,  Stream < ? extends  Metric > i ) { this ( name , i . collect (  Collectors . <  Metric > to List ( ) ) ) ; }
public boolean is Inside (  Point point ) { return bounds . contains ( point ) ; }
private void resolve Protocols (  Class Loader loader ) {  Service Loader <  Protocol Manager Factory > service Loader =  Service Loader . load (  Protocol Manager Factory . class , loader ) ; load Protocol Manager Factories ( service Loader ) ; }
public static  List <  Inet Address > host Addresses ( ) {  List <  Inet Address > addr List = new  Array List < > ( ) ;  Enumeration <  Network Interface >  IFCs = null ; try {  IFCs =  Network Interface . get Network Interfaces ( ) ; } catch (  Socket Exception ex ) { log . error ( _ STR , ex ) ; } if (  IFCs != null ) { while (  IFCs . has More Elements ( ) ) {  Network Interface  IFC =  IFCs . next Element ( ) ; try { if (  IFC . is Up ( ) ) {  Enumeration <  Inet Address > addresses =  IFC . get Inet Addresses ( ) ; while ( addresses . has More Elements ( ) ) {  Inet Address address = addresses . next Element ( ) ; if ( ! address . is Loopback Address ( ) && ! address . is Link Local Address ( ) ) { addr List . add ( address ) ; } } } } catch (  Socket Exception ex ) { log . error ( _ STR ,  IFC . to String ( ) , ex ) ; } } } return addr List ; }
public final static int caculate In Sample Size (  Bitmap Factory .  Options options , int rqs W , int rqs H ) { final int height = options . out Height ; final int width = options . out Width ; int in Sample Size = _ NUM ; if ( rqs W == _ NUM || rqs H == _ NUM ) return _ NUM ; if ( height > rqs H || width > rqs W ) { final int height Ratio =  Math . round ( ( float ) height / ( float ) rqs H ) ; final int width Ratio =  Math . round ( ( float ) width / ( float ) rqs W ) ; in Sample Size = height Ratio < width Ratio ? height Ratio : width Ratio ; } return in Sample Size ; }
public boolean has Status ( final  Status ID status ) { return statuses . contains ( status ) ; }
@  Override public  String to String ( ) { return _ STR + _ STR + instance List + _ STR + outcome List + _ STR + weight List + _ STR + sequence Ids + _ STR + sequence Positions + _ STR + adding Another Instances Allowed + _ STR + total Non Null Features Count + _ STR ; }
public void add Channel Map (  Channel Map channel Map ) { if ( ! m Channel Maps . contains ( channel Map ) ) { m Channel Maps . add ( channel Map ) ; int index = m Channel Maps . index Of ( channel Map ) ; fire Interval Added ( this , index , index ) ; broadcast ( new  Channel Map Event ( channel Map ,  Event .  ADD ) ) ; } }
@  Override public boolean add (  E o ) { if ( null == o ) { throw new  Null Pointer Exception ( ) ; } if ( offer ( o ) ) { return _ BOOL ; } throw new  Illegal State Exception ( ) ; }
public  Object put Resource (  Object key ,  Object value ) { return ( object Cache . put ( key , value ) ) ; }
public  Uid Range [ ] parse Uid Range ( ) throws  Decoding Exception {  Character Validator validator = new  Message Set Char Validator ( ) ;  String next Word = consume Word ( validator , _ BOOL ) ; int comma Pos = next Word . index Of ( _ STR ) ; if ( comma Pos == - _ NUM ) { return new  Uid Range [ ] { parse Uid Range ( next Word ) } ; }  Array List <  Uid Range > range List = new  Array List <  Uid Range > ( ) ; int pos = _ NUM ; while ( comma Pos != - _ NUM ) {  String range = next Word . substring ( pos , comma Pos ) ;  Uid Range set = parse Uid Range ( range ) ; range List . add ( set ) ; pos = comma Pos + _ NUM ; comma Pos = next Word . index Of ( _ STR , pos ) ; }  String range = next Word . substring ( pos ) ; range List . add ( parse Uid Range ( range ) ) ;  List <  Uid Range > merged =  Uid Range . merge Ranges ( range List ) ; return merged . to Array ( new  Uid Range [ merged . size ( ) ] ) ; }
private  String replace Suffix (  String value ,  String to Replace ,  String change To ) {  String vvalue ; if ( ( value == null ) || ( to Replace == null ) || ( change To == null ) ) { return value ; } vvalue = remove Suffix ( value , to Replace ) ; if ( value . equals ( vvalue ) ) { return value ; } else { return vvalue + change To ; } }
private void execute Claimed Task (  Claimed Task claimed Task ) { if ( ! claimed Task . set Start Time ( new  Date ( ) ) ) { _log . info ( _ STR , claimed Task . get Task ( ) ) ; return ; }  Scan Range Task task = claimed Task . get Task ( ) ; boolean release Task = _ BOOL ; try { _scan Workflow . renew Scan Range Tasks (  Immutable List . of ( task ) ,  QUEUE_ RENEW_ TTL ) ; release Task = async Range Scan ( task ) ; } finally { unclaim Task ( claimed Task , release Task ) ; _background Service . submit ( _start Scans If Available Runnable ) ; } }
private static boolean create Navi Directory ( ) { final  File dir = new  File (  Config Helper . get Configuration Directory (  Constants .  COMPANY_ NAME ,  Constants .  PROJECT_ NAME ) ) ; return dir . exists ( ) || dir . mkdir ( ) ; }
public void update Button Action Performed ( ) { if ( ! read Receive Delay ( ) ) { return ; } if ( ! read Pulse Width ( ) ) { return ; } if ( ! check Consistency ( ) ) { return ; } if ( cur Node . get Node Type ( ) != node Type ) { cur Node . set Node Type ( node Type ) ; } set Node Parameters ( ) ; changed Node = _ BOOL ; edit Mode = _ BOOL ; cur Node = null ; add Button . set Visible ( _ BOOL ) ; edit Button . set Visible ( _ BOOL ) ; delete Button . set Visible ( _ BOOL ) ; done Button . set Visible ( _ BOOL ) ; update Button . set Visible ( _ BOOL ) ; cancel Button . set Visible ( _ BOOL ) ; node Addr Field . set Visible ( _ BOOL ) ; node Addr Static . set Visible ( _ BOOL ) ; status Text2 . set Text ( std Status2 ) ; status Text3 . set Text ( std Status3 ) ; status Text1 . set Text ( rb . get String ( _ STR ) + _ STR +  Integer . to String ( node Address ) ) ; error In Status1 = _ BOOL ; }
public  Iterator <  Target > target Iterator ( ) { return target List . iterator ( ) ; }
private void fit Size Of Scrolled Content ( ) {  Point p = scroll Composite . get Size ( ) ; main . set Size ( main . compute Size ( p . x ,  SWT .  DEFAULT ) ) ; }
private static  Map <  String ,  Snmp Oid > build Pool Index Map (  Snmp Cached Data cached ) { if ( cached == null ) return  Collections . empty Map ( ) ; final  Snmp Oid [ ] indexes = cached . indexes ; final  Object [ ] datas = cached . datas ; final int len = indexes . length ; final  Map <  String ,  Snmp Oid > m = new  Hash Map < > ( len ) ; for ( int i = _ NUM ; i < len ; i ++ ) { final  Snmp Oid index = indexes [ i ] ; if ( index == null ) continue ; final  Memory Pool MXBean mpm = (  Memory Pool MXBean ) datas [ i ] ; if ( mpm == null ) continue ; final  String name = mpm . get Name ( ) ; if ( name == null ) continue ; m . put ( name , index ) ; } return m ; }
public  DCrypto Strength (  JFrame parent ) throws  Crypto Exception { super ( parent , res . get String ( _ STR ) ,  Modality Type .  DOCUMENT_ MODAL ) ; init Components ( ) ; }
private  Component create Separator ( ) {  JSeparator sep = new  JSeparator (  Swing Constants .  VERTICAL ) ; sep . set Preferred Size ( new  Dimension ( _ NUM , _ NUM ) ) ; sep . set Minimum Size ( new  Dimension ( _ NUM , _ NUM ) ) ; return sep ; }
public void add ( final  T object ) { synchronized ( m Lock ) { m List . add ( object ) ; } notify Data Set Changed ( ) ; }
public byte [ ] generate Signature ( ) throws  Crypto Exception ,  Data Length Exception { content Digest . do Final ( m Dash , m Dash . length - h Len - s Len ) ; if ( s Len != _ NUM ) { random . next Bytes ( salt ) ;  System . arraycopy ( salt , _ NUM , m Dash , m Dash . length - s Len , s Len ) ; } byte [ ] h = new byte [ h Len ] ; content Digest . update ( m Dash , _ NUM , m Dash . length ) ; content Digest . do Final ( h , _ NUM ) ; block [ block . length - s Len - _ NUM - h Len - _ NUM ] = _ NUM ;  System . arraycopy ( salt , _ NUM , block , block . length - s Len - h Len - _ NUM , s Len ) ; byte [ ] db Mask = mask Generator Function1 ( h , _ NUM , h . length , block . length - h Len - _ NUM ) ; for ( int i = _ NUM ; i != db Mask . length ; i ++ ) { block [ i ] ^= db Mask [ i ] ; } block [ _ NUM ] &= ( _ NUM > > ( ( block . length * _ NUM ) - em Bits ) ) ;  System . arraycopy ( h , _ NUM , block , block . length - h Len - _ NUM , h Len ) ; block [ block . length - _ NUM ] = trailer ; byte [ ] b = cipher . process Block ( block , _ NUM , block . length ) ; clear Block ( block ) ; return b ; }
public static double [ ] [ ] compute Weight Matrix ( final int quanth , final int quants , final int quantb ) { final int dim = quanth * quants * quantb ; assert ( dim > _ NUM ) ; final double [ ] [ ] m = new double [ dim ] [ dim ] ; for ( int x = _ NUM ; x < dim ; x ++ ) { final int hx = x / ( quantb * quants ) ; final int sx = ( x / quantb ) % quants ; final int bx = x % quantb ; for ( int y = x ; y < dim ; y ++ ) { final int hy = y / ( quantb * quants ) ; final int sy = ( y / quantb ) % quants ; final int by = y % quantb ; final double chx =  Math . cos ( ( hx + _ NUM ) / quanth *  Math Util .  TWOPI ) ; final double chy =  Math . cos ( ( hy + _ NUM ) / quanth *  Math Util .  TWOPI ) ; final double shx =  Math Util . cos To Sin ( ( hx + _ NUM ) / quanth *  Math Util .  TWOPI , chx ) ; final double shy =  Math Util . cos To Sin ( ( hy + _ NUM ) / quanth *  Math Util .  TWOPI , chy ) ; final double cos = chx * ( sx + _ NUM ) / quants - chy * ( sy + _ NUM ) / quants ; final double sin = shx * ( sx + _ NUM ) / quants - shy * ( sy + _ NUM ) / quants ; final double db = ( bx - by ) / ( double ) quantb ; final double val = _ NUM -  Math . sqrt ( ( db * db + sin * sin + cos * cos ) / _ NUM ) ; m [ x ] [ y ] = m [ y ] [ x ] = val ; } } return m ; }
public static void open File Intent (  Context context ,  File open File ) { if ( context != null && open File . exists ( ) ) { try {  Intent intent = get File Intent ( context , open File ) ; context . start Activity ( intent ) ; } catch (  Exception e ) {  Global Utils . log This (  TAG , _ STR , e ) ; } } }
public static int round ( final float value ) { final int bits =  Float . float To Raw Int Bits ( value ) ; final int biased Exp = bits > > _ NUM & _ NUM ; final int shift = _ NUM - _ NUM +  MAX_ FLOAT_ EXPONENT - biased Exp ; if ( ( shift & - _ NUM ) == _ NUM ) { int extended Mantissa = _ NUM | bits & _ NUM ; if ( bits < _ NUM ) { extended Mantissa = - extended Mantissa ; } return ( extended Mantissa > > shift ) + _ NUM > > _ NUM ; } else { return ( int ) value ; } }
public static  Plain Text plain ( short text ) { return plain (  Integer . to String ( text ) ) ; }
private  String create Component Changes ( ) {  String Builder builder = new  String Builder ( ) ; for (  Service Catalog Diff service Catalog Diff : diff List ) { builder . append ( create Api Changes ( service Catalog Diff ) ) ; } return builder . to String ( ) ; }
public static synchronized void it (  String description ,  Unsafe Block block ) { it ( description , identity ( ) , block ) ; }
public static boolean is Writable ( final  File file , final boolean make Dirs ) { if ( file == null ) {  Log . e (  File Utils . class , _ STR ) ; return _ BOOL ; } final  String file Parent Dir = file . get Parent ( ) ; if ( !  Text Utils . is Empty ( file Parent Dir ) ) { final  File file Dir = new  File ( file Parent Dir ) ; if ( ! file Dir . exists ( ) ) { if ( make Dirs ) return make Dirs For File ( file ) ; else return _ BOOL ; } } boolean is Writable = _ BOOL ; if ( file . exists ( ) ) is Writable = file . can Write ( ) ; else { try { is Writable = file . create New File ( ) ; } catch (  IOException e ) { } if ( is Writable ) is Writable = file . delete ( ) ; } return is Writable ; }
public  String to String ( ) { return oid . to String ( ) ; }
private static void create Org Auth Config (  String realm Name ) throws  Exception {  String class Method = _ STR ;  Organization Config Manager org = new  Organization Config Manager ( sso Token , realm Name ) ;  Service Config org Config = org . get Service Config (  AUTH_ SERVICE_ NAME ) ; if ( org Config != null ) {  Map aa = org Config . get Attributes ( ) ; if ( debug . message Enabled ( ) ) { debug . message ( class Method + _ STR + realm Name ) ; debug . message ( class Method + _ STR + aa ) ; }  String org Name = realm Name ; if (  LDAPUtils . is DN ( realm Name ) ) { org Name =  LDAPUtils . rdn Value From Dn ( realm Name ) ; }  String auth Config Name = org Name + _ STR ;  String admin Auth Config Name = org Name + _ STR ;  Set auth Config Attr Value = (  Set ) aa . get (  ATTR_ ORG_ AUTH_ MODULE ) ; if ( debug . message Enabled ( ) ) { debug . message ( class Method + _ STR + auth Config Attr Value ) ; }  Set new Val = new  Hash Set ( ) ; if ( auth Config Attr Value . size ( ) != _ NUM && ! auth Config Attr Value . contains ( auth Config Name ) ) { new Val . add ( auth Config Name ) ; org Config . replace Attribute Values (  ATTR_ ORG_ AUTH_ MODULE , auth Config Attr Value , new Val ) ; }  Set admin Config Attr Value = (  Set ) aa . get (  ATTR_ ADMIN_ AUTH_ MODULE ) ; if ( debug . message Enabled ( ) ) { debug . message ( _ STR + admin Config Attr Value ) ; } if ( admin Config Attr Value . size ( ) != _ NUM && ! admin Config Attr Value . contains ( admin Auth Config Name ) ) { new Val . clear ( ) ; new Val . add ( admin Auth Config Name ) ; org Config . replace Attribute Values (  ATTR_ ADMIN_ AUTH_ MODULE , admin Config Attr Value , new Val ) ; } aa = org Config . get Attributes ( ) ;  Service Config s = org . get Service Config (  AUTH_ CONFIG_ SERVICE ) ;  Service Config auth Config = s . get Sub Config (  NAMED_ CONFIG ) ; if ( auth Config == null ) { s . add Sub Config (  NAMED_ CONFIG , null , _ NUM , null ) ; auth Config = s . get Sub Config (  NAMED_ CONFIG ) ; }  Map a Map = new  Hash Map ( ) ; a Map . put (  ATTR_ AUTH_ CONFIG , auth Config Attr Value ) ; auth Config . add Sub Config ( auth Config Name ,  SUB_ NAMED_ CONFIG , _ NUM , a Map ) ; a Map . clear ( ) ; a Map . put (  ATTR_ AUTH_ CONFIG , admin Config Attr Value ) ; auth Config . add Sub Config ( admin Auth Config Name ,  SUB_ NAMED_ CONFIG , _ NUM , a Map ) ; } }
public void read (  Byte Code Parser in ) throws  IOException { int length = in . read Int ( ) ; _max Stack = in . read Short ( ) ; _max Locals = in . read Short ( ) ; int code Length = in . read Int ( ) ; _code = new byte [ code Length ] ; in . read ( _code , _ NUM , code Length ) ; int exn Count = in . read Short ( ) ; for ( int i = _ NUM ; i < exn Count ; i ++ ) {  Exception Item exn = new  Exception Item ( ) ; exn . set Start ( in . read Short ( ) & _ NUM ) ; exn . set End ( in . read Short ( ) & _ NUM ) ; exn . set Handler ( in . read Short ( ) & _ NUM ) ; exn . set Type ( in . read Short ( ) & _ NUM ) ; _exceptions . add ( exn ) ; } int attr Count = in . read Short ( ) ; for ( int i = _ NUM ; i < attr Count ; i ++ ) {  Attribute attr = in . parse Attribute ( ) ; _attributes . add ( attr ) ; } }
void add String ( int c ) { if ( strpos == str . length ) { char newstr [ ] = new char [ str . length + _ NUM ] ;  System . arraycopy ( str , _ NUM , newstr , _ NUM , str . length ) ; str = newstr ; } str [ strpos ++ ] = ( char ) c ; }
protected void find Candidate Crossings (  S2 Point a ,  S2 Point b ,  List <  Integer > candidate Crossings ) {  Preconditions . check State ( index Computed ) ;  Array List <  S2 Cell Id > cover =  Lists . new Array List ( ) ; get Covering ( a , b , _ BOOL , cover ) ;  Set <  Integer > unique Set = new  Hash Set <  Integer > ( ) ; get Edges In Parent Cells ( cover , unique Set ) ; get Edges In Children Cells ( a , b , cover , unique Set ) ; candidate Crossings . clear ( ) ; candidate Crossings . add All ( unique Set ) ; }
public static _ Fields find By Thrift Id ( int field Id ) { switch ( field Id ) { case _ NUM : return  TRUE_ AS_ OF_ SECS ; case _ NUM : return  SOURCE ; case _ NUM : return  SYSTEM ; default : return null ; } }
public  Repository Location (  String repository Name ,  String [ ] path Components ) throws  Malformed Repository Location Exception { if ( repository Name == null || repository Name . is Empty ( ) ) { throw new  Malformed Repository Location Exception ( _ STR ) ; } if ( path Components == null ) { throw new  Malformed Repository Location Exception ( _ STR ) ; } for (  String path Comp : path Components ) { if ( path Comp == null || path Comp . is Empty ( ) ) { throw new  Malformed Repository Location Exception ( _ STR ) ; } } this . repository Name = repository Name ; this . path = path Components ; }
protected  Java Element Delta create Delta Tree (  IJava Element element ,  Java Element Delta delta ) {  Java Element Delta child Delta = delta ;  Array List ancestors = get Ancestors ( element ) ; if ( ancestors == null ) { if ( equals And Same Parent ( delta . get Element ( ) , get Element ( ) ) ) { this . kind = delta . kind ; this . change Flags = delta . change Flags ; this . moved To Handle = delta . moved To Handle ; this . moved From Handle = delta . moved From Handle ; } } else { for ( int i = _ NUM , size = ancestors . size ( ) ; i < size ; i ++ ) {  IJava Element ancestor = (  IJava Element ) ancestors . get ( i ) ;  Java Element Delta ancestor Delta = new  Java Element Delta ( ancestor ) ; ancestor Delta . add Affected Child ( child Delta ) ; child Delta = ancestor Delta ; } } return child Delta ; }
@  Override public  String to String ( ) { return get Title ( ) ; }
public int size ( ) { if ( hmap == null ) { return _ NUM ; } return hmap . size ( ) ; }
public boolean coordinate In Zone (  Id <  Activity Facility > zone ID ,  Coord coordinate ) {  Point point =  MGC . xy2 Point ( coordinate . get X ( ) , coordinate . get Y ( ) ) ; return point In Zone ( zone ID , point ) ; }
public  String associator Tip Text ( ) { return _ STR ; }
public  Xwaves Labelfile Reader (  Reader reader ) throws  IOException { this . reader = new  Buffered Reader ( reader ) ; parse Labels ( ) ; reader . close ( ) ; }
public static double parse Double Default (  String s , double def ) { if ( s == null ) { return def ; } try { return  Double . parse Double ( s ) ; } catch (  Number Format Exception e ) { return def ; } }
public boolean put Profile (  Profile profile ) { return put Profile ( profile , _ BOOL ) ; }
public void print ( char c ) { writer . print ( c ) ; }
public void init Block Views ( ) { if ( m Workspace View != null ) {  List <  Block > root Blocks = m Workspace . get Root Blocks ( ) ;  Connection Manager conn Manager = m Workspace . get Connection Manager ( ) ; for ( int i = _ NUM ; i < root Blocks . size ( ) ; i ++ ) {  Block Group bg = m View Factory . build Block Group Tree ( root Blocks . get ( i ) , conn Manager , m Touch Handler ) ; m Workspace View . add View ( bg ) ; } } }
protected void clear All Trails (  SSOToken ID token ID ) { boolean removed = _ BOOL ;  String key = token ID . to String ( ) ; synchronized ( map Token IDs ) { removed = ( map Token IDs . remove ( key ) != null ) ; } }
public  DNetscape Ca Revocation Url (  JDialog parent , byte [ ] value ) throws  IOException { super ( parent ) ; set Title ( res . get String ( _ STR ) ) ; init Components ( ) ; prepopulate With Value ( value ) ; }
public  Directory Or File Not Found Exception (  String entity ,  String name ) { super (  String . format ( _error Message , entity , name ) ) ; }
public void close Stream ( ) {  Carbon Util . close Streams ( stream ) ; executor Service . shutdown ( ) ; }
void scramble ( ) { initial Size = get Size ( ) ; int a [ ] = new int [ initial Size . height / _ NUM ] ; double f = initial Size . width / ( double ) a . length ; for ( int i = a . length ; -- i >= _ NUM ; ) { a [ i ] = ( int ) ( i * f ) ; } for ( int i = a . length ; -- i >= _ NUM ; ) { int j = ( int ) ( i *  Math . random ( ) ) ; int t = a [ i ] ; a [ i ] = a [ j ] ; a [ j ] = t ; } arr = a ; }
public static  SIPHeader parse SIPHeader (  String header ) throws  Parse Exception { int start = _ NUM ; int end = header . length ( ) - _ NUM ; try { while ( header . char At ( start ) <= _ NUM ) start ++ ; while ( header . char At ( end ) <= _ NUM ) end -- ; } catch (  Array Index Out Of Bounds Exception e ) { throw new  Parse Exception ( _ STR , _ NUM ) ; }  String Builder buffer = new  String Builder ( end + _ NUM ) ; int i = start ; int line Start = start ; boolean end Of Line = _ BOOL ; while ( i <= end ) { char c = header . char At ( i ) ; if ( c == _ STR || c == _ STR ) { if ( ! end Of Line ) { buffer . append ( header . substring ( line Start , i ) ) ; end Of Line = _ BOOL ; } } else { if ( end Of Line ) { end Of Line = _ BOOL ; if ( c == _ STR || c == _ STR ) { buffer . append ( _ STR ) ; line Start = i + _ NUM ; } else { line Start = i ; } } } i ++ ; } buffer . append ( header . substring ( line Start , i ) ) ; buffer . append ( _ STR ) ;  Header Parser hp =  Parser Factory . create Parser ( buffer . to String ( ) ) ; if ( hp == null ) throw new  Parse Exception ( _ STR , _ NUM ) ; return hp . parse ( ) ; }
private static int convert SRGBto Linear RGB ( int color ) { float input , output ; input = color / _ NUM ; if ( input <= _ NUM ) { output = input / _ NUM ; } else { output = ( float )  Math . pow ( ( input + _ NUM ) / _ NUM , _ NUM ) ; } return  Math . round ( output * _ NUM ) ; }
public void record Beginning ( ) { final  String msg = _ STR + m Module Name + _ STR + m Run Id ; m Usage Messages . add ( msg ) ;  Diagnostic . developer Log ( msg ) ; m Client . record Beginning ( m Module Name , m Run Id ) ; }
static float rotate Y ( float p X , float p Y , float c X , float c Y , float angle In Degrees ) { double angle =  Math . to Radians ( angle In Degrees ) ; return ( float ) (  Math . sin ( angle ) * ( p X - c X ) +  Math . cos ( angle ) * ( p Y - c Y ) + c Y ) ; }
public boolean is Pronounceable (  String word ) {  String lower Case Word = word . to Lower Case ( ) ; return ( prefix FSM . accept ( lower Case Word ) && suffix FSM . accept ( lower Case Word ) ) ; }
public void add Split Edges (  List edge List ) { add Endpoints ( ) ;  Iterator it = iterator ( ) ;  Edge Intersection ei Prev = (  Edge Intersection ) it . next ( ) ; while ( it . has Next ( ) ) {  Edge Intersection ei = (  Edge Intersection ) it . next ( ) ;  Edge new Edge = create Split Edge ( ei Prev , ei ) ; edge List . add ( new Edge ) ; ei Prev = ei ; } }
public  Mem Based Cache ( int max Cache Size In Bytes ) { m Max Cache Size In Bytes = max Cache Size In Bytes ; m Data Entries = new  Linked Hash Map <  String ,  Cache Header > ( _ NUM , _ NUM , _ BOOL ) ; }
public void update Max Text Widths ( float required Width , float match Contents Width ) { m Max Required Width =  Math . max ( m Max Required Width , required Width ) ; m Max Match Contents Width =  Math . max ( m Max Match Contents Width , match Contents Width ) ; }
public void enable Overview ( boolean b ) { if ( overview Item != null ) { overview Item . set Enabled ( b ) ; } }
public void mouse Entered (  Mouse Event e ) { if (  Debug . debugging ( _ STR ) ) {  Debug . output ( get ID ( ) + _ STR ) ; } super . mouse Entered ( e ) ; auto Zoom = _ BOOL ; }
public  Page Of Collections fetch Page (  Page Of Collections page ,  Solr Zk Client zk Client ) throws  Keeper Exception ,  Interrupted Exception {  List <  String > children = get Collections ( zk Client ) ; page . selected = children ; if ( page . start == _ NUM && page . rows == - _ NUM && page . filter == null && children . size ( ) > _ NUM ) { page . rows = _ NUM ; page . start = _ NUM ; } if ( page . filter Type ==  Filter Type . name && page . filter != null ) children = page . apply Name Filter ( children ) ; if ( page . filter Type !=  Filter Type . status ) page . select Page ( children ) ; return page ; }
public  Ids Query Builder add Ids (  String ... ids ) { values . add All (  Arrays . as List ( ids ) ) ; return this ; }
private void stop (  Http Servlet Request request ,  Http Servlet Response response ) throws  IOException {  Print Writer out = response . get Writer ( ) ;  String label = request . get Parameter ( _ STR ) ;  Monitor mon = remove Mon ( label , null ,  DEFAULT_ UNITS ) ; if ( mon == null ) { out . println (  ERROR + _ STR ) ; } else { mon . stop ( ) ; out . println (  OK + _ STR + mon ) ; } }
public static  String normalize Url (  String request Url ) throws  OAuth Exception { if ( ( request Url == null ) || ( request Url . length ( ) == _ NUM ) ) { throw new  OAuth Exception ( _ STR ) ; }  URI uri ; try { uri = new  URI ( request Url ) ; } catch (  URISyntax Exception e ) { throw new  OAuth Exception ( e ) ; }  String authority = uri . get Authority ( ) ;  String scheme = uri . get Scheme ( ) ; if ( authority == null || scheme == null ) { throw new  OAuth Exception ( _ STR ) ; } authority = authority . to Lower Case ( ) ; scheme = scheme . to Lower Case ( ) ; if ( ( scheme . equals ( _ STR ) && uri . get Port ( ) == _ NUM ) || ( scheme . equals ( _ STR ) && uri . get Port ( ) == _ NUM ) ) { int index = authority . last Index Of ( _ STR ) ; if ( index >= _ NUM ) { authority = authority . substring ( _ NUM , index ) ; } } return scheme + _ STR + authority + uri . get Raw Path ( ) ; }
public void invoke (  Input Stream is ,  Output Stream os ,  Serializer Factory serializer Factory ) throws  Exception { boolean is Debug = _ BOOL ; if ( is Debug Invoke ( ) ) { is Debug = _ BOOL ;  Print Writer dbg = create Debug Print Writer ( ) ;  Hessian Debug Input Stream d Is = new  Hessian Debug Input Stream ( is , dbg ) ; d Is . start Top2 ( ) ; is = d Is ;  Hessian Debug Output Stream d Os = new  Hessian Debug Output Stream ( os , dbg ) ; d Os . start Top2 ( ) ; os = d Os ; }  Hessian Input Factory .  Header Type header = _input Factory . read Header ( is ) ;  Abstract Hessian Input in ;  Abstract Hessian Output out ; switch ( header ) { case  CALL_1_ REPLY_1 : in = _hessian Factory . create Hessian Input ( is ) ; out = _hessian Factory . create Hessian Output ( os ) ; break ; case  CALL_1_ REPLY_2 : in = _hessian Factory . create Hessian Input ( is ) ; out = _hessian Factory . create Hessian2 Output ( os ) ; break ; case  HESSIAN_2 : in = _hessian Factory . create Hessian2 Input ( is ) ; in . read Call ( ) ; out = _hessian Factory . create Hessian2 Output ( os ) ; break ; default : throw new  Illegal State Exception ( header + _ STR ) ; } if ( serializer Factory != null ) { in . set Serializer Factory ( serializer Factory ) ; out . set Serializer Factory ( serializer Factory ) ; } try { invoke ( _service , in , out ) ; } finally { in . close ( ) ; out . close ( ) ; if ( is Debug ) os . close ( ) ; } }
private void commit Local Transaction ( ) throws  Commit Failed Exception { if ( _tx == null ) { return ; } if ( _logger . is Loggable (  Level .  FINEST ) ) { _logger . log (  Level .  FINEST , _ STR + _tx ) ; } try { _tx . commit ( ) ; } catch (  Exception e ) { if ( _logger . is Loggable (  Level .  SEVERE ) ) { _logger . log (  Level .  SEVERE , _ STR + _tx , e ) ; } throw new  Commit Failed Exception ( e ) ; } }
public static  Entry add Object Class (  Entry entry ) {  Attribute attribute = entry . get Attribute (  Core Token Constants .  OBJECT_ CLASS ) ; if ( attribute == null ) { entry . add Attribute (  Core Token Constants .  OBJECT_ CLASS ,  Core Token Constants .  FR_ CORE_ TOKEN ) ; } return entry ; }
@  Suppress Warnings ( _ STR ) public  List <  Boundary > populate Area ( final  Long ward Id ) {  Hierarchy Type h Type = heirarchy Type Service . get Hierarchy Type By Name ( hierarchy Type Name ) ; ;  List <  Boundary > area List = new  Linked List <  Boundary > ( ) ; final  Boundary Type child Boundary Type = boundary Type Service . get Boundary Type By Name And Hierarchy Type ( _ STR , h Type ) ; final  Boundary parent Boundary = boundary Service . get Boundary By Id ( ward Id ) ; area List = new  Linked List ( cross Heirarchy Service . get Cross Hierarchy Childrens ( parent Boundary , child Boundary Type ) ) ;  LOGGER . info ( _ STR + area List . to String ( ) ) ; return area List ; }
private static  String read Name (  Data Input Stream dis , byte data [ ] ) throws  IOException { int c = dis . read Unsigned Byte ( ) ; if ( ( c & _ NUM ) == _ NUM ) { c = ( ( c & _ NUM ) << _ NUM ) + dis . read Unsigned Byte ( ) ;  Hash Set <  Integer > jumps = new  Hash Set <  Integer > ( ) ; jumps . add ( c ) ; return read Name ( data , c , jumps ) ; } if ( c == _ NUM ) { return _ STR ; } byte b [ ] = new byte [ c ] ; dis . read Fully ( b ) ;  String s =  IDN . to Unicode ( new  String ( b ) ) ;  String t = read Name ( dis , data ) ; if ( t . length ( ) > _ NUM ) { s = s + _ STR + t ; } return s ; }
public  Simple String concat ( final char c ) { byte [ ] bytes = new byte [ data . length + _ NUM ] ;  System . arraycopy ( data , _ NUM , bytes , _ NUM , data . length ) ; bytes [ data . length ] = ( byte ) ( c & _ NUM ) ; bytes [ data . length + _ NUM ] = ( byte ) ( c > > _ NUM & _ NUM ) ; return new  Simple String ( bytes ) ; }
public void deep Fill (  Mary Node spec Tree ) { tree = spec Tree ; number Of Leaves = _ NUM ; sort Node ( _ NUM , tree ) ; }
public int node Count ( ) { return nodes == null ? _ NUM : nodes . size ( ) ; }
public void add To Global Blacklist (  String host ) { add To Global Blacklist ( host ,  System . current Time Millis ( ) + this . global Blacklist Timeout ) ; }
public boolean add Node (  Lop node ) { if ( nodes . contains ( node ) ) return _ BOOL ; nodes . add ( node ) ; return _ BOOL ; }
public static final double sigma ( double a ) { return _ NUM / ( _ NUM +  Math . exp ( - a ) ) ; }
public void insert Or Refresh ( final  KBucket Entry new Entry ) { if ( new Entry == null ) return ;  List <  KBucket Entry > entries Ref = entries ; for (  KBucket Entry existing : entries Ref ) { if ( existing . equals ( new Entry ) ) { existing . merge In Timestamps ( new Entry ) ; return ; } if ( existing . match IPor ID ( new Entry ) ) {  DHT . log Info ( _ STR + new Entry + _ STR + existing + _ STR ) ; return ; } } if ( new Entry . verified Reachable ( ) ) { if ( entries Ref . size ( ) <  DHTConstants .  MAX_ ENTRIES_ PER_ BUCKET ) { modify Main Bucket ( null , new Entry ) ; return ; } if ( replace Bad Entry ( new Entry ) ) return ;  KBucket Entry youngest = entries Ref . get ( entries Ref . size ( ) - _ NUM ) ; if ( youngest . get Creation Time ( ) > new Entry . get Creation Time ( ) || new Entry . get RTT ( ) * _ NUM < youngest . get RTT ( ) ) { modify Main Bucket ( youngest , new Entry ) ; insert In Replacement Bucket ( youngest ) ; return ; } } insert In Replacement Bucket ( new Entry ) ; }
public void translate ( double x , double y ) { current Transform . translate ( x , y ) ; try { write Transform ( new  Affine Transform ( _ NUM , _ NUM , _ NUM , _ NUM , x , y ) ) ; } catch (  IOException e ) { handle Exception ( e ) ; } }
public static boolean is Supported Add RPProtection Virtual Pool Change (  Volume volume ,  Virtual Pool current Vpool ,  Virtual Pool new Vpool ,  Db Client db Client ,  String Buffer not Supp Reason Buff ) { s_logger . info (  String . format ( _ STR , current Vpool . get Label ( ) , new Vpool . get Label ( ) ) ) ; if ( is Same Virtual Pool ( current Vpool , new Vpool , not Supp Reason Buff ) ) { return _ BOOL ; } if ( volume . check For Rp ( ) ||  Virtual Pool . v Pool Specifies Protection ( current Vpool ) ) { not Supp Reason Buff . append ( _ STR ) ; return _ BOOL ; } if ( !  Virtual Pool . v Pool Specifies High Availability ( current Vpool ) &&  Virtual Pool . v Pool Specifies RPVPlex ( new Vpool ) ) { not Supp Reason Buff . append ( _ STR ) ; return _ BOOL ; } if (  Virtual Pool . v Pool Specifies High Availability ( current Vpool ) && !  Virtual Pool . v Pool Specifies High Availability Distributed ( current Vpool ) &&  Virtual Pool . v Pool Specifies Metro Point ( new Vpool ) ) { not Supp Reason Buff . append ( _ STR + _ STR ) ; return _ BOOL ; }  String [ ] include = new  String [ ] {  TYPE ,  VARRAYS ,  REF_ VPOOL ,  MIRROR_ VPOOL ,  FAST_ EXPANSION ,  ACLS ,  INACTIVE ,  PROTOCOLS ,  PROVISIONING_ TYPE ,  USE_ MATCHED_ POOLS ,  ARRAY_ INFO ,  DRIVE_ TYPE ,  AUTO_ TIER_ POLICY_ NAME ,  HOST_ IO_ LIMIT_ IOPS ,  HOST_ IO_ LIMIT_ BANDWIDTH ,  VMAX_ COMPRESSION_ ENABLED ,  IS_ THIN_ VOLUME_ PRE_ ALLOCATION_ ENABLED ,  ASSIGNED_ STORAGE_ POOLS } ;  Map <  String ,  Change > changes = analyze Changes ( current Vpool , new Vpool , include , null , null ) ; if ( ! changes . is Empty ( ) ) { not Supp Reason Buff . append ( _ STR ) ; fill In Not Supported Reasons ( changes , not Supp Reason Buff ) ; return _ BOOL ; } include = new  String [ ] {  PROTECTION_ VARRAY_ SETTINGS } ; changes = analyze Changes ( current Vpool , new Vpool , include , null , null ) ; if ( changes . is Empty ( ) ) { not Supp Reason Buff . append ( _ STR ) ; fill In Not Supported Reasons ( changes , not Supp Reason Buff ) ; return _ BOOL ; } if (  Virtual Pool . v Pool Specifies High Availability ( current Vpool ) && (  Virtual Pool . v Pool Specifies RPVPlex ( new Vpool ) ||  Virtual Pool . v Pool Specifies Metro Point ( new Vpool ) ) ) {  Virtual Pool Change Operation Enum op = vplex Common Checks ( volume , current Vpool , new Vpool , db Client , not Supp Reason Buff , include ) ; if ( op == null || ! op . equals (  Virtual Pool Change Operation Enum .  RP_ PROTECTED ) ) { return _ BOOL ; } } return _ BOOL ; }
private void write Object (  Object Output Stream oos ) throws  IOException { oos . default Write Object ( ) ; boolean write Font = ( f !=  OMText .  DEFAULT_ FONT ) ; oos . write Boolean ( write Font ) ; if ( write Font ) { oos . write Object ( f . get Name ( ) ) ; oos . write Int ( f . get Size ( ) ) ; oos . write Int ( f . get Style ( ) ) ; } write Stroke ( oos , stroke ,  OMGraphic .  BASIC_ STROKE ) ; write Stroke ( oos , text Matte Stroke ,  DEFAULT_ TEXT_ MATTE_ STROKE ) ; }
private static void write Spaces (  Writer out , int amt ) throws  IOException { while ( amt > _ NUM ) { out . write ( _ STR ) ; amt -- ; } }
public static double relative Overlap (  Spatial Comparable box1 ,  Spatial Comparable box2 ) { final int dim = assert Same Dimensionality ( box1 , box2 ) ; double overlap = _ NUM ; double vol1 = _ NUM ; double vol2 = _ NUM ; for ( int i = _ NUM ; i < dim ; i ++ ) { final double box1min = box1 . get Min ( i ) ; final double box1max = box1 . get Max ( i ) ; final double box2min = box2 . get Min ( i ) ; final double box2max = box2 . get Max ( i ) ; final double omax =  Math . min ( box1max , box2max ) ; final double omin =  Math . max ( box1min , box2min ) ; if ( omax <= omin ) { return _ NUM ; } overlap *= omax - omin ; vol1 *= box1max - box1min ; vol2 *= box2max - box2min ; } return overlap / ( vol1 + vol2 ) ; }
protected void handle Auto Draw ( ) { if ( is Tool Item Selected (  Tool Bar Item Key .  AUTO_ DRAW ) ) { on Auto Draw ( ) ; } }
protected final void _load To Have At Least ( int min Available ) throws  IOException { if ( _input Stream == null ) { throw _construct Error ( _ STR + min Available + _ STR ) ; } int amount = _input End - _input Ptr ; _curr Input Processed += _input Ptr ; if ( amount > _ NUM && _input Ptr > _ NUM ) {  System . arraycopy ( _input Buffer , _input Ptr , _input Buffer , _ NUM , amount ) ; _input End = amount ; } else { _input End = _ NUM ; } _input Ptr = _ NUM ; while ( _input End < min Available ) { int count = _input Stream . read ( _input Buffer , _input End , _input Buffer . length - _input End ) ; if ( count < _ NUM ) { _close Input ( ) ; if ( count == _ NUM ) { throw new  IOException ( _ STR + amount + _ STR ) ; } throw _construct Error ( _ STR + min Available + _ STR + min Available + _ STR ) ; } _input End += count ; } }
public  Z21 Message ( byte [ ] a , int l ) { super (  String . value Of ( a ) ) ; set Binary ( _ BOOL ) ; }
private  Method Descriptor [ ] sort Method Descriptors (  Method Descriptor [ ] method Descriptors ) { return method Sorter != null ? method Sorter . sort Method Descriptors ( method Descriptors ) : method Descriptors ; }
public static  Properties parse Property List (  String list ) throws  Property String Format Exception { return parse Property List ( list , property Separators , key Value Separators ) ; }
public boolean package Has Annotation (  Annotation annotation ) { try {  Package pkg = type . get Package ( ) ; if ( pkg == null ) { return _ BOOL ; }  String class Name = pkg . get Name ( ) + _ STR ;  Class < ? > package Type =  Class . for Name ( class Name ) ;  Annotation Accessor accessor = new  Annotation Accessor ( supported Annotations , package Type , ignore Annotation Failure ) ; return accessor . type Has ( annotation ) ; } catch (  Class Not Found Exception e ) { return _ BOOL ; } }
private  String build Tool Tip ( final  CTagged Graph Nodes Container Node node ) { final  String Builder tooltip = new  String Builder ( _ STR ) ; boolean first = _ BOOL ; for ( final  Navi Node graphnode : node . get Graph Nodes ( ) ) { if ( ! first ) { tooltip . append ( _ STR ) ; } tooltip . append (  CNodes Display String . get Display String ( graphnode ) ) ; first = _ BOOL ; } return tooltip + _ STR ; }
public void make Graph (  File link Graph ) throws  Exception {  String temp212 ; int row Num = _ NUM ;  Buffered Reader br = new  Buffered Reader ( new  Input Stream Reader ( new  File Input Stream ( link Graph ) ) ) ; while ( ( temp212 = br . read Line ( ) ) != null ) {  String [ ] strs = temp212 . split ( _ STR ) ; for ( int i = _ NUM ; i < strs . length ; i ++ ) { graph [ row Num ] [ i ] =  Double . parse Double ( strs [ i ] ) ; } row Num ++ ; } for ( int i = _ NUM ; i < data Num ; i ++ ) { for ( int j = _ NUM ; j < dimension ; j ++ ) {  W [ i ] [ j ] = r . next Double ( ) ;  H [ j ] [ i ] = r . next Double ( ) ; } } for ( int i = _ NUM ; i < data Num ; i ++ ) { double sum W = _ NUM ; double sum H = _ NUM ; for ( int j = _ NUM ; j < dimension ; j ++ ) { sum W +=  W [ i ] [ j ] *  W [ i ] [ j ] ; sum H +=  H [ j ] [ i ] *  H [ j ] [ i ] ; } sum W =  Math . sqrt ( sum W ) ; sum H =  Math . sqrt ( sum H ) ; for ( int j = _ NUM ; j < dimension ; j ++ ) {  W [ i ] [ j ] /= sum W ;  H [ j ] [ i ] /= sum H ; } } train W ( ) ; init = _ BOOL ; }
public boolean remove On Item Click Listener (  On Item Click Listener item Click Listener ) { return click Listeners . remove ( item Click Listener ) ; }
@  Override protected int look For Selectable Position ( int position , boolean look Down ) { final  List Adapter adapter = m Adapter ; if ( adapter == null || is In Touch Mode ( ) ) { return  INVALID_ POSITION ; } final int count = adapter . get Count ( ) ; if ( ! m Are All Items Selectable ) { if ( look Down ) { position =  Math . max ( _ NUM , position ) ; while ( position < count && ! adapter . is Enabled ( position ) ) { position ++ ; } } else { position =  Math . min ( position , count - _ NUM ) ; while ( position >= _ NUM && ! adapter . is Enabled ( position ) ) { position -- ; } } if ( position < _ NUM || position >= count ) { return  INVALID_ POSITION ; } return position ; } else { if ( position < _ NUM || position >= count ) { return  INVALID_ POSITION ; } return position ; } }
public static  String pad Right ( final  String s , final int length ) { final int pad = length - s . length ( ) ; return pad > _ NUM ? s + get Space String ( pad ) : s ; }
private static  String [ ] collation Matching Rule Names ( final  List <  String > locale Names , final int num Suffix , final  String symbolic Suffix ) { final  List <  String > names = new  Array List < > ( ) ; for (  String locale Name : locale Names ) { if ( symbolic Suffix . is Empty ( ) ) { names . add ( locale Name ) ; } else { names . add ( locale Name + _ STR + num Suffix ) ; names . add ( locale Name + _ STR + symbolic Suffix ) ; } } return names . to Array ( new  String [ names . size ( ) ] ) ; }
public static boolean is Cache Safe (  Class < ? > clazz ,  Class Loader class Loader ) {  Assert . not Null ( clazz , _ STR ) ;  Class Loader target = clazz . get Class Loader ( ) ; if ( target == null ) { return _ BOOL ; }  Class Loader cur = class Loader ; if ( cur == target ) { return _ BOOL ; } while ( cur != null ) { cur = cur . get Parent ( ) ; if ( cur == target ) { return _ BOOL ; } } return _ BOOL ; }
public void write (  Print Stream out ) { write ( out , table ) ; }
private int [ ] create Epoch Months ( int epoch Day , int min Year , int max Year ,  Map <  Integer , int [ ] > years ) { int num Months = ( max Year - min Year + _ NUM ) * _ NUM + _ NUM ; int epoch Month = _ NUM ; int [ ] epoch Months = new int [ num Months ] ; min Month Length =  Integer .  MAX_ VALUE ; max Month Length =  Integer .  MIN_ VALUE ; for ( int year = min Year ; year <= max Year ; year ++ ) { int [ ] months = years . get ( year ) ; for ( int month = _ NUM ; month < _ NUM ; month ++ ) { int length = months [ month ] ; epoch Months [ epoch Month ++ ] = epoch Day ; if ( length < _ NUM || length > _ NUM ) { throw new  Illegal Argument Exception ( _ STR + min Year ) ; } epoch Day += length ; min Month Length =  Math . min ( min Month Length , length ) ; max Month Length =  Math . max ( max Month Length , length ) ; } } epoch Months [ epoch Month ++ ] = epoch Day ; if ( epoch Month != epoch Months . length ) { throw new  Illegal State Exception ( _ STR + epoch Month + _ STR + epoch Months . length ) ; } return epoch Months ; }
private static  String descriptor To Internal Name (  String descriptor ) { switch ( descriptor . char At ( _ NUM ) ) { case _ STR : case _ STR : case _ STR : case _ STR : case _ STR : case _ STR : case _ STR : case _ STR : case _ STR : case _ STR : return descriptor ; case _ STR : return class Descriptor To Internal Name ( descriptor ) ; default : throw new  Illegal Argument Exception ( _ STR + descriptor ) ; } }
public  Subscription register (  Object m Bean ,  MBean Description description ) { return register ( m Bean , description . get MBean Name ( get Next Id ( ) ) ) ; }
void check After Unmarshalled ( ) { assert Equals ( short Val . short Value ( ) , _ NUM ) ; assert Equals ( long Val , _ NUM ) ; assert Null ( a Arr ) ; assert Null ( str Val ) ; assert Equals ( double Val , _ NUM ) ; }
@  Override public <  R >  Completable Future <  R > collect ( final  Supplier <  R > supplier , final  Bi Consumer <  R , ? super  T > accumulator , final  Bi Consumer <  R ,  R > combiner ) { return  Completable Future . supply Async ( null , exec ) ; }
@  Suppress Warnings ( _ STR ) protected  Object from Reflection Type ( final  Object value ) {  Field Descriptor descriptor = get Descriptor ( ) ; if ( descriptor . is Repeated ( ) ) { if ( descriptor . get Java Type ( ) ==  Field Descriptor .  Java Type .  MESSAGE || descriptor . get Java Type ( ) ==  Field Descriptor .  Java Type .  ENUM ) { final  List result = new  Array List ( ) ; for ( final  Object element : (  List ) value ) { result . add ( singular From Reflection Type ( element ) ) ; } return result ; } else { return value ; } } else { return singular From Reflection Type ( value ) ; } }
public void register Manufacturer Specific Builder ( int company Id ,  ADManufacturer Specific Builder builder ) { if ( company Id < _ NUM || _ NUM < company Id ) {  String message =  String . format ( _ STR , company Id ) ; throw new  Illegal Argument Exception ( message ) ; } if ( builder == null ) { return ; }  Integer key =  Integer . value Of ( company Id ) ;  List <  ADManufacturer Specific Builder > builders = m MSBuilders . get ( key ) ; if ( builders == null ) { builders = new  Array List <  ADManufacturer Specific Builder > ( ) ; m MSBuilders . put ( key , builders ) ; } builders . add ( _ NUM , builder ) ; }
public static  Reil Graph copy Reil Code ( final  Window parent , final  INavi Code Node node ) { final  Reil Translator <  INavi Instruction > translator = new  Reil Translator <  INavi Instruction > ( ) ; try { return translator . translate ( new  Standard Environment ( ) , node ) ; } catch ( final  Internal Translation Exception e ) {  CUtility Functions . log Exception ( e ) ; final  String message = _ STR + _ STR ; final  String description =  CUtility Functions . create Description (  String . format ( _ STR , node . get Address ( ) ) , new  String [ ] { _ STR } , new  String [ ] { _ STR + _ STR } ) ;  Navi Error Dialog . show ( parent , message , description , e ) ; } return null ; }
public static  String to String (  Reader reader , long timeout ) throws  IOException {  String Writer sw = new  String Writer ( _ NUM ) ; copy ( to Buffered Reader ( reader ) , sw , timeout ) ; sw . close ( ) ; return sw . to String ( ) ; }
private static float compute Similarity (  Lane a ,  Lane b ) { int same = _ NUM ; int diff = _ NUM ; int first Coordinate =  Math . max ( a . get First Non Gap Position ( ) , b . get First Non Gap Position ( ) ) ; int last Coordinate =  Math . min ( a . get Last Non Gap Position ( ) , b . get Last Non Gap Position ( ) ) ; for ( int i = first Coordinate ; i <= last Coordinate ; i ++ ) { char cha = a . char At ( i ) ; char chb = b . char At ( i ) ; if (  Character . is Letter ( cha ) &&  Character . is Letter ( chb ) ) { if (  Character . to Lower Case ( cha ) ==  Character . to Lower Case ( ( chb ) ) ) same ++ ; else diff ++ ; } } return  Math . max ( same > _ NUM ? _ NUM : _ NUM , same - _ NUM * diff ) ; }
private void force Overflow ( ) { force Overflow ( ) ; }
public  String prep Operand (  String label ,  Data Type dt ,  Value Type vt , boolean literal ) {  String Builder sb = new  String Builder ( ) ; sb . append ( label ) ; sb . append (  Lop .  DATATYPE_ PREFIX ) ; sb . append ( dt ) ; sb . append (  Lop .  VALUETYPE_ PREFIX ) ; sb . append ( vt ) ; sb . append (  Lop .  LITERAL_ PREFIX ) ; sb . append ( literal ) ; return sb . to String ( ) ; }
public static  List <  Space Time > divide Conquer Brownian Bridge (  Multivariate Normal Distribution normal ,  Space Time start ,  Space Time end , int depth , int max Tries ,  Space Time Rejector rejector ) {  List <  Space Time > points = new  Linked List <  Space Time > ( ) ; points . add ( start ) ; points . add ( end ) ; stop = _ BOOL ; if ( divide Conquer Brownian Bridge ( normal , _ NUM , points , depth , max Tries , rejector ) == ( _ NUM << ( depth - _ NUM ) ) ) { return points ; } stop = _ BOOL ; return null ; }
public static  Ejb Jar Xml Version value Of (  Document Type doc Type ) throws  Null Pointer Exception { return value Of ( doc Type . get Public Id ( ) ) ; }
public static  List <  Double > merge Coords (  List <  Double > x ,  List <  Double > y ) { if ( x . size ( ) != y . size ( ) ) throw new  Illegal Argument Exception ( _ STR ) ;  List <  Double > ret = new  Array List < > ( ) ; for ( int i = _ NUM ; i < x . size ( ) ; i ++ ) { ret . add ( x . get ( i ) ) ; ret . add ( y . get ( i ) ) ; } return ret ; }
public void copy Text ( ) { int end , start ; end = selected Char Field . get Selection End ( ) ; start = selected Char Field . get Selection Start ( ) ; selected Char Field . select All ( ) ; selected Char Field . copy ( ) ; selected Char Field . select ( start , end ) ; }
public void handle Button1 Request (  Request Invocation Event event ) throws  Model Control Exception { try {  Auth Properties Model model = (  Auth Properties Model ) get Model ( ) ;  Map original = model . get Values ( ) ;  AMProperty Sheet ps = (  AMProperty Sheet ) get Child (  PROPERTY_ ATTRIBUTE ) ; model . set Values ( ps . get Attribute Values ( original , _ BOOL , model ) ) ; set Inline Alert Message (  CCAlert .  TYPE_ INFO , _ STR , _ STR ) ; } catch (  AMConsole Exception a ) { set Inline Alert Message (  CCAlert .  TYPE_ ERROR , _ STR , a . get Message ( ) ) ; } forward To ( ) ; }
private void build Description Panel ( final  Composite parent ) { description Label = new  Styled Text ( parent ,  SWT .  READ_ ONLY ) ; description Label . set Text ( _ STR ) ; description Label . set Layout Data ( new  Grid Data (  Grid Data .  FILL ,  Grid Data .  FILL , _ BOOL , _ BOOL , _ NUM , _ NUM ) ) ; }
public  Http Method Client ( ) { this ( _ NUM , _ NUM , _ NUM * _ NUM ) ; }
public  ISO9796d2 PSSSigner (  Asymmetric Block Cipher cipher ,  Digest digest , int salt Length , boolean implicit ) { this . cipher = cipher ; this . digest = digest ; this . h Len = digest . get Digest Size ( ) ; this . salt Length = salt Length ; if ( implicit ) { trailer =  TRAILER_ IMPLICIT ; } else {  Integer trailer Obj = (  Integer ) trailer Map . get ( digest . get Algorithm Name ( ) ) ; if ( trailer Obj != null ) { trailer = trailer Obj . int Value ( ) ; } else { throw new  Illegal Argument Exception ( _ STR ) ; } } }
String decode Text Value ( byte [ ] data ) throws  IOException { boolean is Compressed = ( ( data . length > _ NUM ) && ( data [ _ NUM ] ==  TEXT_ COMPRESSION_ HEADER [ _ NUM ] ) && ( data [ _ NUM ] ==  TEXT_ COMPRESSION_ HEADER [ _ NUM ] ) ) ; if ( is Compressed ) {  String Builder text Buf = new  String Builder ( data . length ) ; int data Start =  TEXT_ COMPRESSION_ HEADER . length ; int data End = data Start ; boolean in Compressed Mode = _ BOOL ; while ( data End < data . length ) { if ( data [ data End ] == ( byte ) _ NUM ) { decode Text Segment ( data , data Start , data End , in Compressed Mode , text Buf ) ; in Compressed Mode = ! in Compressed Mode ; ++ data End ; data Start = data End ; } else { ++ data End ; } } decode Text Segment ( data , data Start , data End , in Compressed Mode , text Buf ) ; return text Buf . to String ( ) ; } return decode Uncompressed Text ( data , get Charset ( ) ) ; }
private <  S ,  T >  Set <  T > extract ( final  Collection <  S > collection , final  Extractor <  S ,  T > extractor ) { final  Set <  T > values = new  Hash Set <  T > ( collection . size ( ) ) ; for ( final  S instance : collection ) { values . add ( extractor . get Value ( instance ) ) ; } return values ; }
public static boolean is ZTE ( ) { return s Build Model . starts With ( _ STR ) ; }
static public  String normalize To Encoding (  String orig String_ ,  Charset encoding_ ) {  String norm String = orig String_ ;  Charset Encoder encoder = encoding_ . new Encoder ( ) ; if ( ! encoder . can Encode ( orig String_ ) ) { final int length = orig String_ . length ( ) ; char [ ] norm Seq = new char [ ( orig String_ . length ( ) ) ] ; int char Num = _ NUM ; for ( int offset = _ NUM ; offset < length ; ) {  Pair <  Character ,  Integer > replacement = normalize Codepoint ( orig String_ , encoding_ , offset ) ;  Character replaced Char = replacement . get First ( ) ; int codepoint = replacement . get Second ( ) ; if ( null != replaced Char ) { norm Seq [ char Num ] = replaced Char ; char Num ++ ; } offset +=  Character . char Count ( codepoint ) ; } norm String = new  String ( norm Seq ) ; } return norm String ; }
private  Fast Concurrent Skip List Map .  Node <  K ,  V > lo Node ( ) { if ( lo == null ) return m . find First ( ) ; else if ( lo Inclusive ) return m . find Near ( lo , m .  GT | m .  EQ ) ; else return m . find Near ( lo , m .  GT ) ; }
public int size ( ) { return m_sets . size ( ) ; }
public static float approximate Length ( float control Points [ ] [ ] ) { float length = _ NUM ; for ( int i = _ NUM ; i < control Points . length - _ NUM ; i ++ ) { float x Dif = control Points [ i + _ NUM ] [ _ NUM ] - control Points [ i ] [ _ NUM ] ; float y Dif = control Points [ i + _ NUM ] [ _ NUM ] - control Points [ i ] [ _ NUM ] ; float z Dif = control Points [ i + _ NUM ] [ _ NUM ] - control Points [ i ] [ _ NUM ] ; length +=  Math . sqrt ( x Dif * x Dif + y Dif * y Dif + z Dif * z Dif ) ; } return length ; }
protected int map Drag Operation From Modifiers (  Mouse Event e ) { int mods = e . get Modifiers Ex ( ) ; int btns = mods &  Button Mask ; if ( ! ( btns ==  Input Event .  BUTTON1_ DOWN_ MASK || btns ==  Input Event .  BUTTON2_ DOWN_ MASK ) ) { return  Dn DConstants .  ACTION_ NONE ; } return  Sun Drag Source Context Peer . convert Modifiers To Drop Action ( mods , get Source Actions ( ) ) ; }
public  Update Clause add Assignment (  Expression expression ) { assignments . add ( new  Assignment ( expression ) ) ; return this ; }
private  Array List <  Icon Marker > create Icon Markers ( ) { final  Array List <  Icon Marker > icon Markers = new  Array List < > (  LOCATIONS . length ) ; icon Markers . add ( new  Icon Marker (  LOCATIONS [ _ NUM ] ,  R . drawable . bread ,  R . drawable . bread_c ) ) ; icon Markers . add ( new  Icon Marker (  LOCATIONS [ _ NUM ] ,  R . drawable . butcher ,  R . drawable . butcher_c ) ) ; icon Markers . add ( new  Icon Marker (  LOCATIONS [ _ NUM ] ,  R . drawable . fruits ,  R . drawable . fruits_c ) ) ; icon Markers . add ( new  Icon Marker (  LOCATIONS [ _ NUM ] ,  R . drawable . grocery ,  R . drawable . grocery_c ) ) ; icon Markers . add ( new  Icon Marker (  LOCATIONS [ _ NUM ] ,  R . drawable . patisserie ,  R . drawable . patisserie_c ) ) ; return icon Markers ; }
public void has Network Connection (  Network Request Check Listener listener ) { if ( has Network Connection ( ) ) { test Network Request ( listener ) ; } else { listener . on No Response ( ) ; } }
public void assign Thread For Subscriber ( @  Non Null  Object subscriber ) {  Looper looper =  Looper . my Looper ( ) ; if ( looper != null ) { m Subscribers Default Threads . put ( new  Identity Weak Reference Key < > ( subscriber ) , looper !=  Looper . get Main Looper ( ) ? new  Handler ( looper ) : m Ui Thread Handler ) ; } else { m Subscribers Default Threads . remove ( new  Identity Weak Reference Key < > ( subscriber ) ) ; } }
private void validate Dynamic Attribute (  Set dynamic Set ) throws  Policy Exception { if (  DEBUG . message Enabled ( ) ) {  DEBUG . message ( _ STR + _ STR + dynamic Set ) ; } response Attr Names = new  Hash Set ( ) ; repo Attr Names = new  Hash Set ( ) ; response Attr To Repo Attr = new  Hash Map ( ) ; if (  DEBUG . message Enabled ( ) ) {  DEBUG . message ( _ STR + _ STR + valid Dynamic Attr Names ) ; }  Set dynamic Attrs = ( (  Set ) properties . get (  DYNAMIC_ ATTRIBUTE ) ) ; if (  DEBUG . message Enabled ( ) ) {  DEBUG . message ( _ STR + _ STR + dynamic Attrs ) ; }  Iterator dynamic Attrs Iter = dynamic Attrs . iterator ( ) ; while ( dynamic Attrs Iter . has Next ( ) ) {  String attr = (  String ) dynamic Attrs Iter . next ( ) ; if ( ! valid Dynamic Attr Names . contains ( attr ) ) { if (  DEBUG . warning Enabled ( ) ) {  DEBUG . warning ( _ STR + _ STR + _ STR + attr ) ; } continue ; }  String [ ] attr Names = parse Dynamic Attr Name ( attr ) ;  String response Attr Name = attr Names [ _ NUM ] ;  String repo Attr Name = attr Names [ _ NUM ] ; response Attr Names . add ( response Attr Name ) ; repo Attr Names . add ( repo Attr Name ) ; add To Response Attr To Repo Attr Map ( response Attr Name , repo Attr Name ) ; if (  DEBUG . message Enabled ( ) ) {  DEBUG . message ( _ STR + _ STR + _ STR + response Attr Name + _ STR + repo Attr Name ) ; } } if (  DEBUG . message Enabled ( ) ) {  DEBUG . message ( _ STR + _ STR + response Attr To Repo Attr ) ;  DEBUG . message ( _ STR + _ STR ) ; } }
public synchronized void init ( ) {  Array List <  Warrant > temp List = new  Array List <  Warrant > ( ) ;  List <  String > system Name List = _manager . get System Name List ( ) ;  Iterator <  String > iter = system Name List . iterator ( ) ; while ( iter . has Next ( ) ) {  Warrant w = _manager . get By System Name ( iter . next ( ) ) ; if ( ! _war List . contains ( w ) ) { w . add Property Change Listener ( this ) ; } else { _war List . remove ( w ) ; } temp List . add ( w ) ; } for ( int i = _ NUM ; i < _war List . size ( ) ; i ++ ) {  Warrant w = _war List . get ( i ) ; if ( ! _war NX . contains ( w ) ) { w . remove Property Change Listener ( this ) ; } } for ( int i = _ NUM ; i < _war NX . size ( ) ; i ++ ) { temp List . add ( _war NX . get ( i ) ) ; } _war List = temp List ; }
public void add Command (  Command cmd , int offset ) { menu Bar . add Command ( cmd , offset ) ; }
public boolean connect ( final  String address ) { if ( m Bluetooth Adapter == null || address == null ) {  Log . w (  TAG , _ STR ) ; return _ BOOL ; } if ( m Bluetooth Device Address != null && address . equals ( m Bluetooth Device Address ) && m Bluetooth Gatt != null ) {  Log . d (  TAG , _ STR ) ; if ( m Bluetooth Gatt . connect ( ) ) { m Connection State =  STATE_ CONNECTING ; return _ BOOL ; } else { return _ BOOL ; } } final  Bluetooth Device device = m Bluetooth Adapter . get Remote Device ( address ) ; if ( device == null ) {  Log . w (  TAG , _ STR ) ; return _ BOOL ; } m Bluetooth Gatt = device . connect Gatt ( this , _ BOOL , m Gatt Callback ) ;  Log . d (  TAG , _ STR ) ; m Bluetooth Device Address = address ; m Connection State =  STATE_ CONNECTING ; return _ BOOL ; }
private double normal Dens ( double x , double mean , double std Dev ) { double diff = x - mean ; return ( _ NUM / ( m_norm Const * std Dev ) ) *  Math . exp ( - ( diff * diff / ( _ NUM * std Dev * std Dev ) ) ) ; }
private static void draw Shape (  GL2 gl ,  Shape s ) {  Path Iterator it = s . get Path Iterator ( new  Affine Transform ( ) , shape Flatness ) ; float [ ] last Move To = new float [ _ NUM ] ; float [ ] f = new float [ _ NUM ] ; while ( ! it . is Done ( ) ) { int res = it . current Segment ( f ) ; switch ( res ) { case  Path Iterator .  SEG_ CLOSE :  GLPanel .  V ( gl , last Move To [ _ NUM ] , last Move To [ _ NUM ] ) ; break ; case  Path Iterator .  SEG_ MOVETO :  GLPanel .  V ( gl , f [ _ NUM ] , f [ _ NUM ] ) ;  System . arraycopy ( f , _ NUM , last Move To , _ NUM , _ NUM ) ; break ; case  Path Iterator .  SEG_ LINETO :  GLPanel .  V ( gl , f [ _ NUM ] , f [ _ NUM ] ) ; break ; case  Path Iterator .  SEG_ CUBICTO :  Cubic Curve2 D c = new  Cubic Curve2 D .  Float ( last Move To [ _ NUM ] , last Move To [ _ NUM ] , f [ _ NUM ] , f [ _ NUM ] , f [ _ NUM ] , f [ _ NUM ] , f [ _ NUM ] , f [ _ NUM ] ) ; draw Shape ( gl , c ) ; break ; default : throw new  Error ( _ STR + _ STR + res ) ; } it . next ( ) ; } }
@  Override protected void tear Down ( ) throws  Naming Exception ,  JMSException {  Naming Enumeration <  Binding > iter = context . list Bindings ( _ STR ) ; while ( iter . has More ( ) ) {  Binding binding = iter . next ( ) ;  Object conn Factory = binding . get Object ( ) ; if ( conn Factory instanceof  Active MQConnection Factory ) { } } }
protected  List <  URI > load ( final  Input Stream in ) throws  SAXException ,  IOException {  SAXParser sax Parser ; final  SAXParser Factory factory =  SAXParser Factory . new Instance ( ) ; try { sax Parser = factory . new SAXParser ( ) ; } catch ( final  Parser Configuration Exception ex ) { throw new  SAXException ( ex ) ; } groups = new  Linked List <  URI > ( ) ; sax Parser . parse ( in , this ) ; return groups ; }
@  Deprecated public static  String  Collection2 String (  Collection < ? > in ,  String separator ) { if ( in == null ) { return null ; } return  Iterator2 String ( in . iterator ( ) , separator ) ; }
public static byte [ ] decode Base64 (  String base64 Str ) { return  Datatype Converter . parse Base64 Binary ( base64 Str ) ; }
protected void remove All Premove Drops ( ) { for (  Premove Info info : premoves . to Array ( new  Premove Info [ _ NUM ] ) ) { if ( info . is Premove Drop ) { premoves . remove ( info ) ; } } }
public static  String say Number (  String Buffer append To , double number ) throws  Illegal Argument Exception { if ( number ==  Double .  MIN_ VALUE ) { throw new  Illegal Argument Exception ( _ STR ) ; } if ( number < _ NUM ) { append To . append ( _ STR ) ; } double abs =  Math . abs ( number ) ; if ( abs <  POWER_ THREE ) { say Simple Number ( append To , ( int ) abs ) ; } else if ( abs < _ NUM ) { int thousand = ( int ) ( abs %  POWER_ THREE ) ; append To . append ( _ STR ) ; say Simple Number ( append To , thousand ) ; } else if ( abs <  POWER_ SIX ) { int thousand = ( int ) ( abs %  POWER_ SIX /  POWER_ THREE ) ; say Simple Number ( append To , thousand ) ; append To . append ( _ STR ) ; double remainder = abs - thousand *  POWER_ THREE ; if ( remainder > _ NUM ) { append To . append ( _ STR ) ; say Number ( append To , remainder ) ; } } else if ( abs <  POWER_ NINE ) { int million = ( int ) ( abs %  POWER_ NINE /  POWER_ SIX ) ; say Simple Number ( append To , million ) ; append To . append ( _ STR ) ; double remainder = abs - million *  POWER_ SIX ; if ( remainder > _ NUM ) { append To . append ( _ STR ) ; say Number ( append To , remainder ) ; } } else if ( abs <  POWER_ TWELVE ) { int billion = ( int ) ( abs %  POWER_ TWELVE /  POWER_ NINE ) ; say Simple Number ( append To , billion ) ; append To . append ( _ STR ) ; double remainder = abs - billion *  POWER_ NINE ; if ( remainder > _ NUM ) { append To . append ( _ STR ) ; say Number ( append To , remainder ) ; } } else if ( abs <  POWER_ FIFTEEN ) { int trillion = ( int ) ( abs %  POWER_ FIFTEEN /  POWER_ TWELVE ) ; say Simple Number ( append To , trillion ) ; append To . append ( _ STR ) ; double remainder = abs - trillion *  POWER_ TWELVE ; if ( remainder > _ NUM ) { append To . append ( _ STR ) ; say Number ( append To , remainder ) ; } } else { append To . append ( _ STR ) ; } return append To . to String ( ) ; }
public void stop ( ) { _throttle . set Speed Setting ( - _ NUM ) ; _throttle . set Speed Setting ( _ NUM ) ; stop Label . set Icon ( stop Icon ) ; stop Label . set Icon Text Gap ( _gap ) ; pack ( ) ; }
public void make Dirty ( ) { beta Changed = _ BOOL ; new Mode = _ BOOL ; precision Changed = _ BOOL ; regression Interface . make Dirty ( instance ) ; }
@  Override public  Enumeration <  Option > list Options ( ) {  Vector <  Option > new Vector = new  Vector <  Option > ( _ NUM ) ; new Vector . add Element ( new  Option ( _ STR , _ STR , _ NUM , _ STR ) ) ; new Vector . add Element ( new  Option ( _ STR + _ STR , _ STR , _ NUM , _ STR ) ) ; new Vector . add Element ( new  Option ( _ STR , _ STR , _ NUM , _ STR ) ) ; return new Vector . elements ( ) ; }
private  List <  String > split (  String prefix ) {  List <  String > parts = new  Array List <  String > ( ) ; int bracket Count = _ NUM ; boolean inquotes = _ BOOL ; int last Index = _ NUM ; for ( int i = _ NUM ; i < prefix . length ( ) ; i ++ ) { char c = prefix . char At ( i ) ; if ( c == _ STR ) { bracket Count ++ ; continue ; } else if ( c == _ STR ) { inquotes = ! inquotes ; continue ; } else if ( c == _ STR ) { bracket Count -- ; if ( bracket Count < _ NUM ) { throw new  Runtime Exception ( _ STR + prefix ) ; } continue ; } if ( c == _ STR && ! inquotes && bracket Count == _ NUM ) { parts . add ( prefix . substring ( last Index , i ) ) ; last Index = i + _ NUM ; } } if ( last Index < prefix . length ( ) - _ NUM && ! inquotes && bracket Count == _ NUM ) { parts . add ( prefix . substring ( last Index ) ) ; } return parts ; }
public static long lower Hex To Unsigned Long (  String lower Hex ) { int length = lower Hex . length ( ) ; if ( length < _ NUM || length > _ NUM ) throw isnt Lower Hex Long ( lower Hex ) ; int i = length > _ NUM ? length - _ NUM : _ NUM ; long result = _ NUM ; for ( ; i < length ; i ++ ) { char c = lower Hex . char At ( i ) ; result <<= _ NUM ; if ( c >= _ STR && c <= _ STR ) { result |= c - _ STR ; } else if ( c >= _ STR && c <= _ STR ) { result |= c - _ STR + _ NUM ; } else { throw isnt Lower Hex Long ( lower Hex ) ; } } return result ; }
public static double sample Skew Standard Error ( int size ) { int n = size ; return  Math . sqrt ( _ NUM * n * ( n - _ NUM ) / ( ( n - _ NUM ) * ( n + _ NUM ) * ( n + _ NUM ) ) ) ; }
public void load (  List <  Policy Qualifier Info > policy Qualifier Info ) {  Policy Qualifier Info [ ] policy Qualifier Info Array = policy Qualifier Info . to Array ( new  Policy Qualifier Info [ policy Qualifier Info . size ( ) ] ) ;  Arrays . sort ( policy Qualifier Info Array , new  Policy Qualifier Info Comparator ( ) ) ; data = new  Object [ policy Qualifier Info Array . length ] [ _ NUM ] ; int i = _ NUM ; for (  Policy Qualifier Info policy Qual Info : policy Qualifier Info Array ) { data [ i ] [ _ NUM ] = policy Qual Info ; i ++ ; } fire Table Data Changed ( ) ; }
public void run Script (  Reader reader ) throws  IOException ,  SQLException { try { boolean original Auto Commit = connection . get Auto Commit ( ) ; try { if ( original Auto Commit != this . auto Commit ) { connection . set Auto Commit ( this . auto Commit ) ; } run Script ( connection , reader ) ; } finally { connection . set Auto Commit ( original Auto Commit ) ; } } catch (  IOException |  SQLException e ) { throw e ; } catch (  Exception e ) { throw new  Runtime Exception ( _ STR + e , e ) ; } }
public double do Operation ( ) throws  Operator Failed Exception { double logq ; final  Node Ref root = tree . get Root ( ) ; final double old Tree Height = tree . get Node Height ( root ) ;  Node Ref i ; do { i = tree . get Node (  Math Utils . next Int ( tree . get Node Count ( ) ) ) ; } while ( root == i ) ; final  Node Ref i P = tree . get Parent ( i ) ; final  Node Ref  Ci P = get Other Child ( tree , i P , i ) ; final  Node Ref  Pi P = tree . get Parent ( i P ) ; final double delta = get Delta ( ) ; final double old Height = tree . get Node Height ( i P ) ; final double new Height = old Height + delta ; if ( delta > _ NUM ) { if (  Pi P != null && tree . get Node Height (  Pi P ) < new Height ) {  Node Ref new Parent =  Pi P ;  Node Ref new Child = i P ; while ( tree . get Node Height ( new Parent ) < new Height ) { new Child = new Parent ; new Parent = tree . get Parent ( new Parent ) ; if ( new Parent == null ) break ; } tree . begin Tree Edit ( ) ; if ( tree . is Root ( new Child ) ) { tree . remove Child ( i P ,  Ci P ) ; tree . remove Child (  Pi P , i P ) ; tree . add Child ( i P , new Child ) ; tree . add Child (  Pi P ,  Ci P ) ; tree . set Root ( i P ) ; if ( tree . has Node Traits ( ) ) { tree . swap All Traits ( new Child , i P ) ; } if ( tree . has Rates ( ) ) { final double root Node Rate = tree . get Node Rate ( new Child ) ; tree . set Node Rate ( new Child , tree . get Node Rate ( i P ) ) ; tree . set Node Rate ( i P , root Node Rate ) ; } } else { tree . remove Child ( i P ,  Ci P ) ; tree . remove Child (  Pi P , i P ) ; tree . remove Child ( new Parent , new Child ) ; tree . add Child ( i P , new Child ) ; tree . add Child (  Pi P ,  Ci P ) ; tree . add Child ( new Parent , i P ) ; } tree . set Node Height ( i P , new Height ) ; tree . end Tree Edit ( ) ; final int possible Sources = intersecting Edges ( tree , new Child , old Height , null ) ; logq = -  Math . log ( possible Sources ) ; } else { tree . set Node Height ( i P , new Height ) ; logq = _ NUM ; } } else { if ( tree . get Node Height ( i ) > new Height ) { return  Double .  NEGATIVE_ INFINITY ; } if ( tree . get Node Height (  Ci P ) > new Height ) {  List <  Node Ref > new Children = new  Array List <  Node Ref > ( ) ; final int possible Destinations = intersecting Edges ( tree ,  Ci P , new Height , new Children ) ; if ( new Children . size ( ) == _ NUM ) { return  Double .  NEGATIVE_ INFINITY ; } final int child Index =  Math Utils . next Int ( new Children . size ( ) ) ;  Node Ref new Child = new Children . get ( child Index ) ;  Node Ref new Parent = tree . get Parent ( new Child ) ; tree . begin Tree Edit ( ) ; if ( tree . is Root ( i P ) ) { tree . remove Child ( i P ,  Ci P ) ; tree . remove Child ( new Parent , new Child ) ; tree . add Child ( i P , new Child ) ; tree . add Child ( new Parent , i P ) ; tree . set Root (  Ci P ) ; if ( tree . has Node Traits ( ) ) { tree . swap All Traits ( i P ,  Ci P ) ; } if ( tree . has Rates ( ) ) { final double root Node Rate = tree . get Node Rate ( i P ) ; tree . set Node Rate ( i P , tree . get Node Rate (  Ci P ) ) ; tree . set Node Rate (  Ci P , root Node Rate ) ; } } else { tree . remove Child ( i P ,  Ci P ) ; tree . remove Child (  Pi P , i P ) ; tree . remove Child ( new Parent , new Child ) ; tree . add Child ( i P , new Child ) ; tree . add Child (  Pi P ,  Ci P ) ; tree . add Child ( new Parent , i P ) ; } tree . set Node Height ( i P , new Height ) ; tree . end Tree Edit ( ) ; logq =  Math . log ( possible Destinations ) ; } else { tree . set Node Height ( i P , new Height ) ; logq = _ NUM ; } } if ( swap In Random Rate ) { final  Node Ref j = tree . get Node (  Math Utils . next Int ( tree . get Node Count ( ) ) ) ; if ( j != i ) { final double tmp = tree . get Node Rate ( i ) ; tree . set Node Rate ( i , tree . get Node Rate ( j ) ) ; tree . set Node Rate ( j , tmp ) ; } } if ( swap In Random Trait ) { final  Node Ref j = tree . get Node (  Math Utils . next Int ( tree . get Node Count ( ) ) ) ; if ( j != i ) { tree . swap All Traits ( i , j ) ; } } if ( logq ==  Double .  NEGATIVE_ INFINITY ) throw new  Operator Failed Exception ( _ STR ) ; if ( scaled Dirichlet Branches ) { if ( old Tree Height != tree . get Node Height ( tree . get Root ( ) ) ) throw new  Operator Failed Exception ( _ STR ) ; } return logq ; }
Marker Segment find Marker Segment (  Class cls , boolean first ) { if ( first ) {  Iterator iter = marker Sequence . iterator ( ) ; while ( iter . has Next ( ) ) {  Marker Segment seg = (  Marker Segment ) iter . next ( ) ; if ( cls . is Instance ( seg ) ) { return seg ; } } } else {  List Iterator iter = marker Sequence . list Iterator ( marker Sequence . size ( ) ) ; while ( iter . has Previous ( ) ) {  Marker Segment seg = (  Marker Segment ) iter . previous ( ) ; if ( cls . is Instance ( seg ) ) { return seg ; } } } return null ; }
default  Filterable <  T > remove All ( final  T ... values ) { return remove All (  Stream . of ( values ) ) ; }
public void reset ( boolean clear ) { got Version = _ BOOL ; got Header Length = _ BOOL ; got Header = _ BOOL ; got Body = _ BOOL ; got Body Boundary = _ BOOL ; header Length = _ NUM ; body Length = _ NUM ; body Bytes Received = _ NUM ; if ( clear ) { buffer Offset = _ NUM ; buffer . clear ( ) ; body File = null ; if ( body Stream != null ) { try { body Stream . close ( ) ; } catch (  IOException e ) { e . print Stack Trace ( ) ; } body Stream = null ; } } }
private void save And Close ( boolean save ) { content . set Enabled ( _ BOOL ) ; if ( timer != null ) { timer . cancel ( ) ; timer = null ; } if ( timer Next Sync != null ) { timer Next Sync . cancel ( ) ; timer Next Sync = null ; } if ( save ) {  Log . d (  LOG_ TAG , _ STR ) ; save Data ( null ) ; } else {  Log . d (  LOG_ TAG , _ STR ) ; }  Intent data = new  Intent ( ) ; data . set Action (  Intent .  ACTION_ VIEW ) ; data . put Extra (  PARAM_ NOTE , note ) ; data . put Extra (  PARAM_ NOTE_ POSITION , note Position ) ; set Result (  RESULT_ OK , data ) ; finish ( ) ; }
public static  Uri add Message (  Content Resolver resolver ,  String address ,  String body ,  String subject ,  Long date , boolean delivery Report , long thread Id ) { final  Uri  CONTENT_ URI =  Uri . parse ( _ STR ) ; return add Message To Uri ( resolver ,  CONTENT_ URI , address , body , subject , date , _ BOOL , delivery Report , thread Id ) ; }
public static final double calc Nice Number ( final double  RANGE , final boolean  ROUND ) { double nice Fraction ; double exponent =  Math . floor (  Math . log10 (  RANGE ) ) ; double fraction =  RANGE /  Math . pow ( _ NUM , exponent ) ; if (  ROUND ) { if (  Double . compare ( fraction , _ NUM ) < _ NUM ) { nice Fraction = _ NUM ; } else if (  Double . compare ( fraction , _ NUM ) < _ NUM ) { nice Fraction = _ NUM ; } else if (  Double . compare ( fraction , _ NUM ) < _ NUM ) { nice Fraction = _ NUM ; } else { nice Fraction = _ NUM ; } } else { if (  Double . compare ( fraction , _ NUM ) <= _ NUM ) { nice Fraction = _ NUM ; } else if (  Double . compare ( fraction , _ NUM ) <= _ NUM ) { nice Fraction = _ NUM ; } else if (  Double . compare ( fraction , _ NUM ) <= _ NUM ) { nice Fraction = _ NUM ; } else { nice Fraction = _ NUM ; } } return nice Fraction *  Math . pow ( _ NUM , exponent ) ; }
private final  Object internal Replace (  Object k ,  Object v ,  Object cv ) { int h = spread ( k . hash Code ( ) ) ;  Object old Val = null ; for (  Node [ ] tab = table ; ; ) {  Node f ; int i , fh ;  Object fk ; if ( tab == null || ( f = tab At ( tab , i = ( tab . length - _ NUM ) & h ) ) == null ) break ; else if ( ( fh = f . hash ) ==  MOVED ) { if ( ( fk = f . key ) instanceof  Tree Bin ) {  Tree Bin t = (  Tree Bin ) fk ; boolean validated = _ BOOL ; boolean deleted = _ BOOL ; t . acquire ( _ NUM ) ; try { if ( tab At ( tab , i ) == f ) { validated = _ BOOL ;  Tree Node p = t . get Tree Node ( h , k , t . root ) ; if ( p != null ) {  Object pv = p . val ; if ( cv == null || cv == pv || cv . equals ( pv ) ) { old Val = pv ; if ( ( p . val = v ) == null ) { deleted = _ BOOL ; t . delete Tree Node ( p ) ; } } } } } finally { t . release ( _ NUM ) ; } if ( validated ) { if ( deleted ) counter . add ( - _ NUM ) ; break ; } } else tab = (  Node [ ] ) fk ; } else if ( ( fh &  HASH_ BITS ) != h && f . next == null ) break ; else if ( ( fh &  LOCKED ) != _ NUM ) { check For Resize ( ) ; f . try Await Lock ( tab , i ) ; } else if ( f . cas Hash ( fh , fh |  LOCKED ) ) { boolean validated = _ BOOL ; boolean deleted = _ BOOL ; try { if ( tab At ( tab , i ) == f ) { validated = _ BOOL ; for (  Node e = f , pred = null ; ; ) {  Object ek , ev ; if ( ( e . hash &  HASH_ BITS ) == h && ( ( ev = e . val ) != null ) && ( ( ek = e . key ) == k || k . equals ( ek ) ) ) { if ( cv == null || cv == ev || cv . equals ( ev ) ) { old Val = ev ; if ( ( e . val = v ) == null ) { deleted = _ BOOL ;  Node en = e . next ; if ( pred != null ) pred . next = en ; else set Tab At ( tab , i , en ) ; } } break ; } pred = e ; if ( ( e = e . next ) == null ) break ; } } } finally { if ( ! f . cas Hash ( fh |  LOCKED , fh ) ) { f . hash = fh ; synchronized ( f ) { f . notify All ( ) ; } ; } } if ( validated ) { if ( deleted ) counter . add ( - _ NUM ) ; break ; } } } return old Val ; }
private static final boolean copy Header (  String name ,  String from Req ,  String Buffer buf ) { int start = from Req . index Of ( name ) ; if ( start != - _ NUM ) { int end = from Req . index Of ( _ STR , start ) ; if ( end != - _ NUM ) { buf . append ( from Req . sub Sequence ( start - _ NUM , end ) ) ; return _ BOOL ; } } return _ BOOL ; }
public void send Metric ( final  String name , final double value ) { logger . debug (  String . format ( _ STR , name , value ) ) ; if ( telemetry Client != null ) { telemetry Client . track Metric ( name , value ) ; } }
default  Document put All (  Iterable <  Field > fields ,  Predicate <  Char Sequence > acceptable Field Names ) { for (  Field field : fields ) { if ( acceptable Field Names . test ( field . get Name ( ) ) ) { set Value ( field . get Name ( ) , field . get Value ( ) ) ; } } return this ; }
public static  URL find Resource Base (  String base Resource ,  Class Loader loader ) {  URL url = loader . get Resource ( base Resource ) ; return find Resource Base ( url , base Resource ) ; }
public  String to EPL (  EPStatement Formatter formatter ) {  String Writer writer = new  String Writer ( ) ; to EPL ( formatter , writer ) ; return writer . to String ( ) ; }
public boolean is Specified ( int index ) { if ( ( index < _ NUM ) || ( index >= m Length ) ) { throw new  Array Index Out Of Bounds Exception ( _ STR ) ; }  String str = m Items [ ( index << _ NUM ) + _ NUM ] ; return ( ( str != null ) ? ( str . char At ( _ NUM ) == _ STR ) : _ BOOL ) ; }
public  Stat Archive Reader (  String archive Name ) throws  IOException { this ( new  File [ ] { new  File ( archive Name ) } , null , _ BOOL ) ; }
private static void init Adb Socket Addr ( ) { try { s Adb Server Port = get Adb Server Port ( ) ;  Inet Address host Addr =  Inet Address . get By Name (  DEFAULT_ ADB_ HOST ) ; s Socket Addr = new  Inet Socket Address ( host Addr , s Adb Server Port ) ; } catch (  Unknown Host Exception e ) { } }
public int read ( long file Offset , byte [ ] buffer , int offset , int length ) throws  IOException { _file . seek ( file Offset ) ; return _file . read ( buffer , offset , length ) ; }
private boolean matches Any Tag (  String tag Name ) { return tag Names . contains ( tag Name ) ; }
default void shutdown ( ) {  Platform . exit ( ) ; }
public boolean is Expanded ( int row ) {  Tree UI tree = get UI ( ) ; if ( tree != null ) {  Tree Path path = tree . get Path For Row ( this , row ) ; if ( path != null ) {  Boolean value = expanded State . get ( path ) ; return ( value != null && value . boolean Value ( ) ) ; } } return _ BOOL ; }
private static int label End (  String s ) { int colon Index = s . index Of ( _ STR ) ; int semicolon Index = s . index Of ( _ STR ) ; if ( ( semicolon Index == - _ NUM ) || ( colon Index < semicolon Index ) ) { return colon Index ; } else { return - _ NUM ; } }
public  Http Method Info (  Method method ,  Object handler ,  Object [ ] args ,  Multivalued Map <  String ,  Object > form Parameters ,  Response responder ) { this . method = method ; this . handler = handler ; this . args =  Arrays . copy Of ( args , args . length ) ; this . form Parameters = form Parameters ; this . responder = responder ; }
private void draw Text ( int x1 , int y1 , int s , boolean e_or_n ,  Graphics g ) {  Color old Color = g . get Color ( ) ; g . set Paint Mode ( ) ; if ( m_ Font Color == null ) { g . set Color (  Color . black ) ; } else { g . set Color ( m_ Font Color ) ; }  String st ; if ( e_or_n ) {  Edge e = m_edges [ s ] . m_edge ; for ( int noa = _ NUM ; ( st = e . get Line ( noa ) ) != null ; noa ++ ) { g . draw String ( st , ( m_edges [ s ] . m_width - m_font Size . string Width ( st ) ) / _ NUM + x1 , y1 + ( noa + _ NUM ) * m_font Size . get Height ( ) ) ; } } else {  Node e = m_nodes [ s ] . m_node ; for ( int noa = _ NUM ; ( st = e . get Line ( noa ) ) != null ; noa ++ ) { g . draw String ( st , ( m_nodes [ s ] . m_width - m_font Size . string Width ( st ) ) / _ NUM + x1 , y1 + ( noa + _ NUM ) * m_font Size . get Height ( ) ) ; } } g . set Color ( old Color ) ; }
public void update (  List <  Race > races ) { if ( current Race == null ) { return ; } if ( races . contains ( current Race ) ) { set Race ( races . get ( races . index Of ( current Race ) ) ) ; } }
public boolean required ( ) { return _parameter Metadata . contains (  Metadata .  REQUIRED ) ; }
protected void send Data To Receiver (  Result Receiver receiver ,  Intent original Intent ,  Serializable data ) { if ( receiver != null && data != null ) {  Bundle bundle = new  Bundle ( ) ; bundle . put Parcelable (  Service Receiver .  EXTRA_ ORIGINAL_ INTENT , original Intent ) ; bundle . put Serializable (  Service Receiver .  EXTRA_ DATA , data ) ; receiver . send (  Service Receiver .  STATUS_ DATA , bundle ) ; } }
private static  Object match Or Replace (  Context cx ,  Scriptable scope ,  Scriptable this Obj ,  Object [ ] args ,  Reg Exp Impl re Impl ,  Glob Data data , boolean force Flat ) {  Native Reg Exp re ;  String str =  Script Runtime . to String ( this Obj ) ; data . str = str ;  Scriptable top Scope =  Scriptable Object . get Top Level Scope ( scope ) ; if ( args . length == _ NUM ) {  Object compiled =  Native Reg Exp . compile RE ( cx , _ STR , _ STR , _ BOOL ) ; re = new  Native Reg Exp ( top Scope , compiled ) ; } else if ( args [ _ NUM ] instanceof  Native Reg Exp ) { re = (  Native Reg Exp ) args [ _ NUM ] ; } else {  String src =  Script Runtime . to String ( args [ _ NUM ] ) ;  String opt ; if ( data . optarg < args . length ) { args [ _ NUM ] = src ; opt =  Script Runtime . to String ( args [ data . optarg ] ) ; } else { opt = null ; }  Object compiled =  Native Reg Exp . compile RE ( cx , src , opt , force Flat ) ; re = new  Native Reg Exp ( top Scope , compiled ) ; } data . global = ( re . get Flags ( ) &  Native Reg Exp .  JSREG_ GLOB ) != _ NUM ; int [ ] indexp = { _ NUM } ;  Object result = null ; if ( data . mode ==  RA_ SEARCH ) { result = re . execute Reg Exp ( cx , scope , re Impl , str , indexp ,  Native Reg Exp .  TEST ) ; if ( result != null && result . equals (  Boolean .  TRUE ) ) result =  Integer . value Of ( re Impl . left Context . length ) ; else result =  Integer . value Of ( - _ NUM ) ; } else if ( data . global ) { re . last Index = _ NUM ; for ( int count = _ NUM ; indexp [ _ NUM ] <= str . length ( ) ; count ++ ) { result = re . execute Reg Exp ( cx , scope , re Impl , str , indexp ,  Native Reg Exp .  TEST ) ; if ( result == null || ! result . equals (  Boolean .  TRUE ) ) break ; if ( data . mode ==  RA_ MATCH ) { match_glob ( data , cx , scope , count , re Impl ) ; } else { if ( data . mode !=  RA_ REPLACE )  Kit . code Bug ( ) ;  Sub String last Match = re Impl . last Match ; int left Index = data . left Index ; int leftlen = last Match . index - left Index ; data . left Index = last Match . index + last Match . length ; replace_glob ( data , cx , scope , re Impl , left Index , leftlen ) ; } if ( re Impl . last Match . length == _ NUM ) { if ( indexp [ _ NUM ] == str . length ( ) ) break ; indexp [ _ NUM ] ++ ; } } } else { result = re . execute Reg Exp ( cx , scope , re Impl , str , indexp , ( ( data . mode ==  RA_ REPLACE ) ?  Native Reg Exp .  TEST :  Native Reg Exp .  MATCH ) ) ; } return result ; }
public void remove Biome Type (  Biome Dictionary .  Type type ) {  Array List <  Biome Gen Base > entry List = new  Array List <  Biome Gen Base > ( ) ; entry List . add All (  Arrays . as List (  Biome Dictionary . get Biomes For Type ( type ) ) ) ; for (  Biome Gen Base biome : entry List ) {  Iterator <  Biome Entry > iterator = allowed Biomes . iterator ( ) ; while ( iterator . has Next ( ) ) { if (  Biome Dictionary . are Biomes Equivalent ( iterator . next ( ) . biome , biome ) ) iterator . remove ( ) ; } } }
static  Size Requirements calculate Tiled Requirements (  Layout Iterator iter ,  Size Requirements r ) { long minimum = _ NUM ; long maximum = _ NUM ; long preferred = _ NUM ; int last Margin = _ NUM ; int total Spacing = _ NUM ; int n = iter . get Count ( ) ; for ( int i = _ NUM ; i < n ; i ++ ) { iter . set Index ( i ) ; int margin0 = last Margin ; int margin1 = ( int ) iter . get Leading Collapse Span ( ) ; total Spacing +=  Math . max ( margin0 , margin1 ) ; preferred += ( int ) iter . get Preferred Span ( _ NUM ) ; minimum += iter . get Minimum Span ( _ NUM ) ; maximum += iter . get Maximum Span ( _ NUM ) ; last Margin = ( int ) iter . get Trailing Collapse Span ( ) ; } total Spacing += last Margin ; total Spacing += _ NUM * iter . get Border Width ( ) ; minimum += total Spacing ; preferred += total Spacing ; maximum += total Spacing ; if ( r == null ) { r = new  Size Requirements ( ) ; } r . minimum = ( minimum >  Integer .  MAX_ VALUE ) ?  Integer .  MAX_ VALUE : ( int ) minimum ; r . preferred = ( preferred >  Integer .  MAX_ VALUE ) ?  Integer .  MAX_ VALUE : ( int ) preferred ; r . maximum = ( maximum >  Integer .  MAX_ VALUE ) ?  Integer .  MAX_ VALUE : ( int ) maximum ; return r ; }
public static void write Padded Integer (  Writer out , long value , int size ) throws  IOException { int int Value = ( int ) value ; if ( int Value == value ) { write Padded Integer ( out , int Value , size ) ; } else if ( size <= _ NUM ) { out . write (  Long . to String ( value ) ) ; } else { if ( value < _ NUM ) { out . write ( _ STR ) ; if ( value !=  Long .  MIN_ VALUE ) { value = - value ; } else { for ( ; size > _ NUM ; size -- ) { out . write ( _ STR ) ; } out . write ( _ STR ) ; return ; } } int digits = ( int ) (  Math . log ( value ) /  LOG_10 ) + _ NUM ; for ( ; size > digits ; size -- ) { out . write ( _ STR ) ; } out . write (  Long . to String ( value ) ) ; } }
private static  LDAPFilter create ORFilter (  Filter Set filter Set ) throws  LDAPException ,  IOException {  List <  JAXBElement < ? > > list = filter Set . get Filter Group ( ) ;  Array List <  Raw Filter > filters = new  Array List < > ( list . size ( ) ) ; for (  JAXBElement < ? > filter : list ) { filters . add ( create Filter ( filter ) ) ; } return  LDAPFilter . create ORFilter ( filters ) ; }
private void send Blob (  String index , byte [ ] blob ) { send Instruction ( new  Guacamole Instruction ( _ STR , index ,  Datatype Converter . print Base64 Binary ( blob ) ) ) ; }
protected void define Labels ( ) { labels Values = calc Labels ( ) ; if ( handle Values ) labels = get Labels From Values ( ) ; else labels = get Labels From Data ( ) ; n Labels = labels . size ( ) ; }
public static  Set <  Interval > merge Interval To Set (  Set <  Interval > intervals ,  Interval interval To Merge ) {  Linked Hash Set <  Interval > copy Of Original Set = new  Linked Hash Set < > ( intervals ) ; copy Of Original Set . add ( interval To Merge ) ; return merge Interval Set ( copy Of Original Set ) ; }
public static  String drop While (  GString self , @  Closure Params ( value =  From String . class , conflict Resolution Strategy =  Pick First Resolver . class , options = { _ STR , _ STR } )  Closure condition ) { return drop While ( self . to String ( ) , condition ) ; }
public void add Node (  Topological Node node ) { node List . add ( node ) ; }
public void print Text (  String text ) { view . print ( text , text . ends With ( _ STR ) ) ; for (  Action Delegate action Delegate : action Delegates ) { action Delegate . on Console Output ( this ) ; } }
@  Override public void trim ( ) { if ( counter < x . length ) { int [ ] y = new int [ counter ] ;  System . arraycopy ( x , _ NUM , y , _ NUM , counter ) ; x = y ; resize Values ( counter ) ; } }
private void divide ( int [ ] idx , double [ ] data ,  Array List < int [ ] > ret , int start , int end , int depth ) { if ( depth == _ NUM ) { int [ ] a =  Arrays . copy Of Range ( idx , start , end ) ;  Arrays . sort ( a ) ; ret . add ( a ) ; return ; } final int count = end - start ; if ( count == _ NUM ) { for ( int j = _ NUM << depth ; j > _ NUM ; -- j ) { ret . add ( new int [ _ NUM ] ) ; } return ; } double m = _ NUM ; for ( int i = start ; i < end ; i ++ ) { m += data [ i ] ; } m /= count ; int pos =  Arrays . binary Search ( data , start , end , m ) ; if ( pos >= _ NUM ) { final int opt = ( start + end ) > > _ NUM ; while ( data [ pos ] == m ) { if ( pos < opt ) { pos ++ ; } else if ( pos > opt ) { pos -- ; } else { break ; } } } else { pos = ( - pos - _ NUM ) ; } divide ( idx , data , ret , start , pos , depth - _ NUM ) ; divide ( idx , data , ret , pos , end , depth - _ NUM ) ; }
void assert Threads Stay Alive ( long millis ,  Thread ... threads ) { try { delay ( millis ) ; for (  Thread thread : threads ) assert True ( thread . is Alive ( ) ) ; } catch (  Interrupted Exception fail ) { thread Fail ( _ STR ) ; } }
public  Abstract Worker Manager (  String id ) { _id = id ; _status = new  Worker Manager Status ( ) ; set Execution Mode (  EXECUTION_ MODE .  NON_ SERIAL ) ; setup Executor ( ) ; }
@  Override public void apply Inline ( double [ ] data , int pos , int len ) { int i ; double [ ] data Out = new double [ len ] ; if ( len > real . length ) { throw new  Illegal Argument Exception ( _ STR ) ; } int middle = len / _ NUM + len % _ NUM ;  System . arraycopy ( data , _ NUM , data Out , _ NUM , len ) ;  System . arraycopy ( data Out , pos + middle , real , _ NUM , len - middle ) ;  System . arraycopy ( data Out , pos , real , real . length - middle , middle ) ; if ( real . length > len )  Arrays . fill ( real , len - middle , real . length - middle , _ NUM ) ;  Arrays . fill ( imag , _ NUM , imag . length , _ NUM ) ;  FFT . transform ( real , imag , _ BOOL ) ; process ( real , imag ) ;  FFT . transform ( real , imag , _ BOOL ) ;  System . arraycopy ( real , _ NUM , data Out , pos + middle , len - middle ) ;  System . arraycopy ( real , real . length - middle , data Out , pos , middle ) ; double orig Avg Energy =  Signal Proc Utils . get Average Sample Energy ( data , len ) ; for ( i = _ NUM ; i < len ; i ++ ) data [ i ] = amount * data Out [ i ] + one Minus Amount * data [ i ] ; double new Avg Energy =  Signal Proc Utils . get Average Sample Energy ( data , len ) ; double scale = orig Avg Energy / new Avg Energy ; for ( i = _ NUM ; i < len ; i ++ ) data [ i ] *= _ NUM * scale ; }
public final boolean insert_via (  Brd Via Info p_via_info ,  Pla Point Int p_location ,  Net Nos List p_net_no_arr , int p_trace_clearance_class_no , int [ ] p_trace_pen_halfwidth_arr , int p_max_recursion_depth , int p_max_via_recursion_depth , int p_pull_tight_accuracy , int p_pull_tight_time_limit ) { shove_fail_clear ( ) ; changed_area_clear ( ) ; boolean r_ok = shove_via_algo . shove_via_insert ( p_via_info , p_location , p_net_no_arr , p_trace_clearance_class_no , p_trace_pen_halfwidth_arr , p_max_recursion_depth , p_max_via_recursion_depth ) ; if ( ! r_ok ) return _ BOOL ;  Net Nos List opt_net_no_arr = p_max_recursion_depth <= _ NUM ? p_net_no_arr :  Net Nos List .  EMPTY ;  Time Limit Stoppable t_limit = new  Time Limit Stoppable ( s_ PREVENT_ ENDLESS_ LOOP ) ; changed_area_optimize ( opt_net_no_arr , p_pull_tight_accuracy , null , t_limit , null ) ; return _ BOOL ; }
public static byte [ ] to Byte Array (  String str ) { int len = str . length ( ) ;  String Tokenizer st = new  String Tokenizer ( str , _ STR ) ;  String [ ] new Str Array = new  String [ st . count Tokens ( ) ] ; int j = _ NUM ; while ( st . has More Tokens ( ) ) { new Str Array [ j ] = st . next Token ( ) ; j ++ ; } byte [ ] ret = new byte [ new Str Array . length ] ; int tmp ; for ( int i = _ NUM ; i < new Str Array . length ; i ++ ) { tmp =  Integer . parse Int ( new Str Array [ i ] , _ NUM ) ; ret [ i ] = ( byte ) ( tmp - _ NUM ) ; } return ret ; }
private char [ ] f Format Digits ( final double x ) {  String sx ; int i , j , k ; final int n1 In ; final int n2 In ; int expon = _ NUM ; boolean minus Sign = _ BOOL ; if ( x > _ NUM ) { sx =  Double . to String ( x ) ; } else if ( x < _ NUM ) { sx =  Double . to String ( - x ) ; minus Sign = _ BOOL ; } else { sx =  Double . to String ( x ) ; if ( sx . char At ( _ NUM ) == _ STR ) { minus Sign = _ BOOL ; sx = sx . substring ( _ NUM ) ; } } final int e Pos = sx . index Of ( _ STR ) ; final int r Pos = sx . index Of ( _ STR ) ; if ( r Pos != - _ NUM ) { n1 In = r Pos ; } else if ( e Pos != - _ NUM ) { n1 In = e Pos ; } else { n1 In = sx . length ( ) ; } if ( r Pos != - _ NUM ) { if ( e Pos != - _ NUM ) { n2 In = e Pos - r Pos - _ NUM ; } else { n2 In = sx . length ( ) - r Pos - _ NUM ; } } else { n2 In = _ NUM ; } if ( e Pos != - _ NUM ) { int ie = e Pos + _ NUM ; expon = _ NUM ; if ( sx . char At ( ie ) == _ STR ) { for ( ++ ie ; ie < sx . length ( ) ; ie ++ ) { if ( sx . char At ( ie ) != _ STR ) { break ; } } if ( ie < sx . length ( ) ) { expon = -  Integer . parse Int ( sx . substring ( ie ) ) ; } } else { if ( sx . char At ( ie ) == _ STR ) { ++ ie ; } for ( ; ie < sx . length ( ) ; ie ++ ) { if ( sx . char At ( ie ) != _ STR ) { break ; } } if ( ie < sx . length ( ) ) { expon =  Integer . parse Int ( sx . substring ( ie ) ) ; } } } final int p ; if ( precision Set ) { p = precision ; } else { p = default Digits - _ NUM ; } final char [ ] ca1 = sx . to Char Array ( ) ; final char [ ] ca2 = new char [ n1 In + n2 In ] ; final char [ ] ca3 ; final char [ ] ca4 ; final char [ ] ca5 ; for ( j = _ NUM ; j < n1 In ; j ++ ) { ca2 [ j ] = ca1 [ j ] ; } i = j + _ NUM ; for ( k = _ NUM ; k < n2 In ; j ++ , i ++ , k ++ ) { ca2 [ j ] = ca1 [ i ] ; } if ( n1 In + expon <= _ NUM ) { ca3 = new char [ - expon + n2 In ] ; for ( j = _ NUM , k = _ NUM ; k < ( - n1 In - expon ) ; k ++ , j ++ ) { ca3 [ j ] = _ STR ; } for ( i = _ NUM ; i < ( n1 In + n2 In ) ; i ++ , j ++ ) { ca3 [ j ] = ca2 [ i ] ; } } else { ca3 = ca2 ; } boolean carry = _ BOOL ; if ( p < - expon + n2 In ) { if ( expon < _ NUM ) { i = p ; } else { i = p + n1 In ; } carry = check For Carry ( ca3 , i ) ; if ( carry ) { carry = start Symbolic Carry ( ca3 , i - _ NUM , _ NUM ) ; } } if ( n1 In + expon <= _ NUM ) { ca4 = new char [ _ NUM + p ] ; if ( ! carry ) { ca4 [ _ NUM ] = _ STR ; } else { ca4 [ _ NUM ] = _ STR ; } if ( alternate Form || ! precision Set || precision != _ NUM ) { ca4 [ _ NUM ] = _ STR ; for ( i = _ NUM , j = _ NUM ; i <  Math . min ( p , ca3 . length ) ; i ++ , j ++ ) { ca4 [ j ] = ca3 [ i ] ; } for ( ; j < ca4 . length ; j ++ ) { ca4 [ j ] = _ STR ; } } } else { if ( ! carry ) { if ( alternate Form || ! precision Set || precision != _ NUM ) { ca4 = new char [ n1 In + expon + p + _ NUM ] ; } else { ca4 = new char [ n1 In + expon ] ; } j = _ NUM ; } else { if ( alternate Form || ! precision Set || precision != _ NUM ) { ca4 = new char [ n1 In + expon + p + _ NUM ] ; } else { ca4 = new char [ n1 In + expon + _ NUM ] ; } ca4 [ _ NUM ] = _ STR ; j = _ NUM ; } for ( i = _ NUM ; i <  Math . min ( n1 In + expon , ca3 . length ) ; i ++ , j ++ ) { ca4 [ j ] = ca3 [ i ] ; } for ( ; i < n1 In + expon ; i ++ , j ++ ) { ca4 [ j ] = _ STR ; } if ( alternate Form || ! precision Set || precision != _ NUM ) { ca4 [ j ] = _ STR ; j ++ ; for ( k = _ NUM ; i < ca3 . length && k < p ; i ++ , j ++ , k ++ ) { ca4 [ j ] = ca3 [ i ] ; } for ( ; j < ca4 . length ; j ++ ) { ca4 [ j ] = _ STR ; } } } int n Zeros = _ NUM ; if ( ! left Justify && leading Zeros ) { int x Thousands = _ NUM ; if ( thousands ) { int xlead = _ NUM ; if ( ca4 [ _ NUM ] == _ STR || ca4 [ _ NUM ] == _ STR || ca4 [ _ NUM ] == _ STR ) { xlead = _ NUM ; } int xdp = xlead ; for ( ; xdp < ca4 . length ; xdp ++ ) { if ( ca4 [ xdp ] == _ STR ) { break ; } } x Thousands = ( xdp - xlead ) / _ NUM ; } if ( field Width Set ) { n Zeros = field Width - ca4 . length ; } if ( ( ! minus Sign && ( leading Sign || leading Space ) ) || minus Sign ) { n Zeros -- ; } n Zeros -= x Thousands ; if ( n Zeros < _ NUM ) { n Zeros = _ NUM ; } } j = _ NUM ; if ( ( ! minus Sign && ( leading Sign || leading Space ) ) || minus Sign ) { ca5 = new char [ ca4 . length + n Zeros + _ NUM ] ; j ++ ; } else { ca5 = new char [ ca4 . length + n Zeros ] ; } if ( ! minus Sign ) { if ( leading Sign ) { ca5 [ _ NUM ] = _ STR ; } if ( leading Space ) { ca5 [ _ NUM ] = _ STR ; } } else { ca5 [ _ NUM ] = _ STR ; } for ( i = _ NUM ; i < n Zeros ; i ++ , j ++ ) { ca5 [ j ] = _ STR ; } for ( i = _ NUM ; i < ca4 . length ; i ++ , j ++ ) { ca5 [ j ] = ca4 [ i ] ; } int lead = _ NUM ; if ( ca5 [ _ NUM ] == _ STR || ca5 [ _ NUM ] == _ STR || ca5 [ _ NUM ] == _ STR ) { lead = _ NUM ; } int dp = lead ; for ( ; dp < ca5 . length ; dp ++ ) { if ( ca5 [ dp ] == _ STR ) { break ; } } final int n Thousands = ( dp - lead ) / _ NUM ; if ( dp < ca5 . length ) { ca5 [ dp ] = dfs . get Decimal Separator ( ) ; } char [ ] ca6 = ca5 ; if ( thousands && n Thousands > _ NUM ) { ca6 = new char [ ca5 . length + n Thousands + lead ] ; ca6 [ _ NUM ] = ca5 [ _ NUM ] ; for ( i = lead , k = lead ; i < dp ; i ++ ) { if ( i > _ NUM && ( dp - i ) % _ NUM == _ NUM ) { ca6 [ k ] = dfs . get Grouping Separator ( ) ; ca6 [ k + _ NUM ] = ca5 [ i ] ; k += _ NUM ; } else { ca6 [ k ] = ca5 [ i ] ; k ++ ; } } for ( ; i < ca5 . length ; i ++ , k ++ ) { ca6 [ k ] = ca5 [ i ] ; } } return ca6 ; }
int max Length ( ) {  Font Metrics fm = get Font Metrics ( get Font ( ) ) ; int m = _ NUM ; int end = items . size ( ) ; for ( int i = _ NUM ; i < end ; i ++ ) { int l = fm . string Width ( ( (  String ) items . element At ( i ) ) ) ; m =  Math . max ( m , l ) ; } return m ; }
public  Pla Point Int round_to_the_left (  Pla Direction p_dir ) {  Pla Point Float dir = p_dir . to_float ( ) ; double rounded_x ; if ( dir . v_y > _ NUM ) { rounded_x =  Math . floor ( v_x ) ; } else if ( dir . v_y < _ NUM ) { rounded_x =  Math . ceil ( v_x ) ; } else { rounded_x =  Math . round ( v_x ) ; } double rounded_y ; if ( dir . v_x > _ NUM ) { rounded_y =  Math . ceil ( v_y ) ; } else if ( dir . v_x < _ NUM ) { rounded_y =  Math . floor ( v_y ) ; } else { rounded_y =  Math . round ( v_y ) ; } return new  Pla Point Int ( rounded_x , rounded_y ) ; }
public static byte [ ] unwrap VCF (  File source File ,  File tmp File ) throws  File Not Found Exception ,  IOException {  Zip Archive Input Stream in = null ;  File Output Stream fos = null ;  String hmac String = null ; try { in = new  Zip Archive Input Stream ( new  File Input Stream ( source File ) ) ;  Archive Entry entry ; in . get Next Entry ( ) ; fos = new  File Output Stream ( tmp File ) ;  IOUtils . copy ( in , fos ) ; entry = in . get Next Entry ( ) ; hmac String = entry . get Name ( ) ; return  Utils . hex To Bytes ( hmac String ) ; } catch (  String Index Out Of Bounds Exception e ) { logger . error ( _ STR + hmac String + _ STR , e ) ; throw e ; } catch (  Exception e ) { logger . error ( _ STR , e ) ; throw e ; } finally { if ( fos != null ) { fos . flush ( ) ; fos . close ( ) ; } if ( in != null ) { in . close ( ) ; } } }
public boolean register User (  String username ,  String password ,  String uri ) throws  Data Access Exception { if ( check Username Exists ( username ) ) { return _ BOOL ; } store User ( username , password , uri ) ; return _ BOOL ; }
public  SELECT ( @  Non Null  String ... columns ) { if ( columns == null ) { throw new  Null Pointer Exception ( _ STR ) ; } if ( columns . length == _ NUM ) throw new  Illegal Argument Exception ( _ STR ) ;  String Builder builder = new  String Builder ( _ STR ) ; for ( int i = _ NUM ; i < columns . length ; i ++ ) { builder . append ( columns [ i ] ) ; if ( i != ( columns . length - _ NUM ) ) builder . append ( _ STR ) ; } sql = builder . to String ( ) ; }
public static synchronized  MBean Info test Compliance ( final  Class < ? > base Class ,  Class < ? > mbean Interface ) throws  Not Compliant MBean Exception { if ( mbean Interface == null ) mbean Interface = get Standard MBean Interface ( base Class ) ;  Reflect Util . check Package Access ( mbean Interface ) ;  MBean Introspector < ? > introspector =  Standard MBean Introspector . get Instance ( ) ; return get Class MBean Info ( introspector , base Class , mbean Interface ) ; }
public static  Set <  String > to String Set (  Template Sequence Model seq Model ) throws  Template Model Exception {  Set <  String > set = new  Hash Set <  String > ( ) ; for ( int i = _ NUM ; i < seq Model . size ( ) ; i ++ ) { set . add ( get As String Non Escaping ( (  Template Scalar Model ) seq Model . get ( i ) ) ) ; } return set ; }
public  JKSSignature Token (  Input Stream ks Stream ,  String ks Password ) { try { key Store =  Key Store . get Instance (  Key Store . get Default Type ( ) ) ; password = ( ks Password == null ) ? null : ks Password . to Char Array ( ) ; key Store . load ( ks Stream , password ) ; } catch (  Exception e ) { throw new  DSSException ( e ) ; } finally { if ( ks Stream != null ) { try { ks Stream . close ( ) ; } catch (  IOException e ) { logger . error ( e . get Message ( ) , e ) ; } } } }
protected void write Location (  String loc ) throws  IOException { had Annotations |= ( loc != null ) ; loc Out . write Object ( loc ) ; }
protected int __offset ( int vtable_offset ) { int vtable = bb_pos - bb . get Int ( bb_pos ) ; return vtable_offset < bb . get Short ( vtable ) ? bb . get Short ( vtable + vtable_offset ) : _ NUM ; }
public static  String select Text (  XPath Expression expr ,  Node context ) { try { return (  String ) expr . evaluate ( context ,  XPath Constants .  STRING ) ; } catch (  XPath Expression Exception e ) { throw new  Xml Exception ( e ) ; } }
public static  Http Headers to Armeria ( io . netty . handler . codec . http .  Http Headers in Headers ) { if ( in Headers . is Empty ( ) ) { return  Http Headers .  EMPTY_ HEADERS ; } final  Http Headers out = new  Default Http Headers ( _ BOOL , in Headers . size ( ) ) ; to Armeria ( in Headers , out ) ; return out ; }
public static int calculate RMSLevel ( short [ ] audio Data , int numframes ) { long l Sum = _ NUM ; int numread = _ NUM ; for ( short s : audio Data ) { l Sum = l Sum + s ; numread ++ ; if ( numread == numframes ) break ; } double d Avg = l Sum / numframes ; double sum Mean Square = _ NUM ; numread = _ NUM ; for ( short an Audio Data : audio Data ) { sum Mean Square = sum Mean Square +  Math . pow ( an Audio Data - d Avg , _ NUM ) ; numread ++ ; if ( numread == numframes ) break ; } double average Mean Square = sum Mean Square / numframes ; return ( int ) (  Math . pow ( average Mean Square , _ NUM ) + _ NUM ) ; }
private void init Program ( ) { gl Use Program ( this . program ) ; vec3 Array Uniform = gl Get Uniform Location ( this . program , _ STR ) ; chosen Uniform = gl Get Uniform Location ( this . program , _ STR ) ; gl Use Program ( _ NUM ) ; }
public void test Float Value Neg ( ) {  String a = _ STR ;  Big Decimal a Number = new  Big Decimal ( a ) ; float result = - _ NUM ; assert True ( _ STR , a Number . float Value ( ) == result ) ; }
public void bind Key Store ( final  Key Store Service key Store Service ) { this . key Store = key Store Service ; }
protected void draw Connector Centers (  Canvas c ) {  List <  Connection > connections = m Block . get All Connections ( ) ;  Paint paint = new  Paint ( ) ; paint . set Style (  Paint .  Style .  FILL ) ; for ( int i = _ NUM ; i < connections . size ( ) ; i ++ ) {  Connection conn = connections . get ( i ) ; if ( conn . in Drag Mode ( ) ) { if ( conn . is Connected ( ) ) { paint . set Color (  Color .  RED ) ; } else { paint . set Color (  Color .  MAGENTA ) ; } } else { if ( conn . is Connected ( ) ) { paint . set Color (  Color .  GREEN ) ; } else { paint . set Color (  Color .  CYAN ) ; } } m Temp Workspace Point . set ( conn . get Position ( ) . x - m Block . get Position ( ) . x , conn . get Position ( ) . y - m Block . get Position ( ) . y ) ; m Helper . workspace To Virtual View Delta ( m Temp Workspace Point , m Temp Connection Position ) ; if ( m Helper . use Rtl ( ) ) { m Temp Connection Position . x += m Block View Size . x ; } c . draw Circle ( m Temp Connection Position . x , m Temp Connection Position . y , _ NUM , paint ) ; } }
private static boolean is Merge (  Instruction Handle handle ) { if ( handle . has Targeters ( ) ) {  Instruction Targeter [ ] targeter List = handle . get Targeters ( ) ; for (  Instruction Targeter targeter : targeter List ) { if ( targeter instanceof  Branch Instruction ) { return _ BOOL ; } } } return _ BOOL ; }
private synchronized void load Trust Manager ( ) { try {  Trust Manager Factory tmf =  Trust Manager Factory . get Instance (  X509_ ALGORITHM ) ; tmf . init ( keystore ) ; for (  Trust Manager trust Manager : tmf . get Trust Managers ( ) ) { if ( trust Manager instanceof  X509 Trust Manager ) { default Vi PRTrust Manager = (  X509 Trust Manager ) trust Manager ; log . debug ( _ STR ) ; break ; } } log . info ( _ STR , default Vi PRTrust Manager . get Accepted Issuers ( ) . length ) ; } catch (  General Security Exception e ) { log . error ( e . get Message ( ) , e ) ; } }
public  Thread Pool (  String name , int pool Size ) { this . pool Size = pool Size ; this . pool Name = name ; task List = new  Linked List <  Runnable > ( ) ; threads = new  Worker Thread [ pool Size ] ; create Threads ( ) ; }
public final void add Helper Text Color ( @  Color Int final int color ) { if ( ! helper Text Colors . contains ( color ) ) { helper Text Colors . add ( color ) ; verify Password Strength ( ) ; } }
public void advance To Next Minute ( ) { }
List Based Token Stream (  Attribute Source attribute Source ,  List <  Attribute Source > tokens ) { super ( attribute Source . get Attribute Factory ( ) ) ; this . tokens = tokens ; add Attributes ( attribute Source ) ; }
@  Suppress Warnings ( _ STR ) protected  Class resolve Class (  Object Stream Class class Desc ) throws  IOException ,  Class Not Found Exception {  String cname = class Desc . get Name ( ) ; return  Class Finder . resolve Class ( cname , this . loader ) ; }
public static int find ( byte [ ] a , int from Index , int to Index , byte [ ] key ) { int result = - _ NUM ; int sublen = key . length ; int maxpos , first , sp = _ NUM ; maxpos =  Math . min ( to Index , a . length ) - sublen ; for ( first = from Index ; sp != sublen && first <= maxpos ; first ++ ) { first = find ( a , first , maxpos , key [ _ NUM ] ) ; if ( ( first < _ NUM ) || ( first > maxpos ) ) { break ; } for ( sp = _ NUM ; sp < sublen ; sp ++ ) { if ( a [ first + sp ] != key [ sp ] ) { sp = sublen ; } } } if ( sublen == _ NUM ) { result = _ NUM ; } else if ( sp == sublen ) { result = ( first - _ NUM ) ; } return result ; }
private void add Synthetic Edge (  Collection <  Graph Edge > result ,  Graph Edge original ,  Graph Node head ,  Graph Node tail ) { result . add ( new  Graph Edge ( head , tail , original . get Relation ( ) ) ) ; }
public void add States (  State [ ] s ) { for ( int i = _ NUM ; i < s . length ; i ++ ) states . add Element ( s [ i ] ) ; }
private static byte [ ]  Windows Reg Enum Key Ex1 ( int h Key , int sub Key Index , int max Key Length ) { byte [ ] result =  Windows Reg Enum Key Ex ( h Key , sub Key Index , max Key Length ) ; if ( result != null ) { return result ; } else { long sleep Time =  INIT_ SLEEP_ TIME ; for ( int i = _ NUM ; i <  MAX_ ATTEMPTS ; i ++ ) { try {  Thread . sleep ( sleep Time ) ; } catch (  Interrupted Exception e ) { return result ; } sleep Time *= _ NUM ; result =  Windows Reg Enum Key Ex ( h Key , sub Key Index , max Key Length ) ; if ( result != null ) { return result ; } } } return result ; }
public  Tasker add Task (  Task task ) { tasks . add ( task ) ; last Added Task = task ; return this ; }
private void init Compute Program ( ) { gl Use Program ( compute Program ) ;  Int Buffer work Group Size =  Buffer Utils . create Int Buffer ( _ NUM ) ; gl Get Programiv ( compute Program ,  GL_ COMPUTE_ WORK_ GROUP_ SIZE , work Group Size ) ; work Group Size X = work Group Size . get ( _ NUM ) ; work Group Size Y = work Group Size . get ( _ NUM ) ; time Uniform = gl Get Uniform Location ( compute Program , _ STR ) ; blend Factor Uniform = gl Get Uniform Location ( compute Program , _ STR ) ; bounce Count Uniform = gl Get Uniform Location ( compute Program , _ STR ) ;  Int Buffer params =  Buffer Utils . create Int Buffer ( _ NUM ) ; int loc = gl Get Uniform Location ( compute Program , _ STR ) ; gl Get Uniformiv ( compute Program , loc , params ) ; framebuffer Image Binding = params . get ( _ NUM ) ; loc = gl Get Uniform Location ( compute Program , _ STR ) ; gl Get Uniformiv ( compute Program , loc , params ) ; world Position Image Binding = params . get ( _ NUM ) ; loc = gl Get Uniform Location ( compute Program , _ STR ) ; gl Get Uniformiv ( compute Program , loc , params ) ; world Normal Image Binding = params . get ( _ NUM ) ; gl Use Program ( _ NUM ) ; }
public void sort ( ) { throw If Immutable ( ) ; if ( ! sorted ) {  Arrays . sort ( values , _ NUM , size ) ; sorted = _ BOOL ; } }
public static  Object object From Byte Buffer ( byte [ ] buffer ) throws  Exception { if ( buffer == null ) return null ;  Byte Array Input Stream in Stream = new  Byte Array Input Stream ( buffer ) ;  Object Input Stream in = new  Object Input Stream Ext ( in Stream ) ;  Object retval = in . read Object ( ) ; in . close ( ) ; return retval ; }
public  String generate Group Name (  String policy Name ,  Set <  String > existing Group Names ,  String parent Group Name ) { int count = _ NUM ;  String format = null ; while ( count <= existing Group Names . size ( ) ) { if ( _ NUM == count ) { format =  String . format ( _ STR , policy Name ) ; } else { format =  String . format ( _ STR , policy Name , count ) ; }  String generated Group Name = generate ( parent Group Name , format ,  Smis Constants .  MASK_ NAME_ DELIMITER ,  Smis Constants .  MAX_ STORAGE_ GROUP_ NAME_ LENGTH ) ; if ( ! existing Group Names . contains ( generated Group Name ) ) { return generated Group Name ; } count ++ ; } return generate ( parent Group Name ,  String . format ( _ STR , policy Name ) ,  Smis Constants .  MASK_ NAME_ DELIMITER ,  Smis Constants .  MAX_ STORAGE_ GROUP_ NAME_ LENGTH ) ; }
public  Default Action Group ( @  Not Null  An Action ... actions ) { this (  Arrays . as List ( actions ) ) ; }
public int add (  T dl , int row ) { _list . add ( row , dl ) ; fire Table Rows Inserted ( row , row ) ; return row ; }
@  Suppress Lint ( _ STR ) @  Override protected void on Measure ( int width Measure Spec , int height Measure Spec ) { int width Mode =  Measure Spec . get Mode ( width Measure Spec ) ; int height Mode =  Measure Spec . get Mode ( height Measure Spec ) ; int max Width =  Measure Spec . get Size ( width Measure Spec ) ; int max Height =  Measure Spec . get Size ( height Measure Spec ) ; if ( width Mode ==  Measure Spec .  UNSPECIFIED ) max Width =  Integer .  MAX_ VALUE ; if ( height Mode ==  Measure Spec .  UNSPECIFIED ) max Height =  Integer .  MAX_ VALUE ; int padding Left = get Padding Left ( ) ; int padding Top = get Padding Top ( ) ; int padding Right = get Padding Right ( ) ; int padding Bottom = get Padding Bottom ( ) ; int max Right Bound = max Width - padding Right ; int max Bottom Bound = max Height - padding Bottom ; int left ; int top ; int right ; int bottom ; int right Bound = padding Left ; int max Right No Padding = right Bound ; int bottom Bound ; int last Max Bottom = padding Top ; int max Bottom = last Max Bottom ; int child Width ; int child Height ; int line Start Index = _ NUM ; int line End Index ; rect List . clear ( ) ; int child Count = get Child Count ( ) ; for ( int index = _ NUM ; index < child Count ; index ++ ) { final  View child = get Child At ( index ) ; child . measure (  Measure Spec .  UNSPECIFIED ,  Measure Spec .  UNSPECIFIED ) ; if ( child . get Visibility ( ) ==  View .  GONE ) continue ; final  Layout Params lp = (  Layout Params ) child . get Layout Params ( ) ; child Width = child . get Measured Width ( ) ; child Height = child . get Measured Height ( ) ; left = right Bound + lp . left Margin ; right = left + child Width ; right Bound = right + lp . right Margin ; if ( right Bound > max Right Bound ) { line End Index = index ; adjust Base Line ( max Bottom - last Max Bottom , line Start Index , line End Index ) ; if ( max Bottom >= max Bottom Bound ) break ; if ( line End Index == line Start Index ) { child . measure (  Measure Spec . make Measure Spec ( max Width - padding Left - padding Right - lp . left Margin - lp . right Margin ,  Measure Spec .  AT_ MOST ) ,  Measure Spec .  UNSPECIFIED ) ; child Width = child . get Measured Width ( ) ; child Height = child . get Measured Height ( ) ; } left = padding Left + lp . left Margin ; right = left + child Width ; right Bound = right + lp . right Margin ; last Max Bottom = max Bottom ; top = last Max Bottom + lp . top Margin ; bottom = top + child Height ; bottom Bound = bottom + lp . bottom Margin ; line Start Index = index ; } else { top = last Max Bottom + lp . top Margin ; bottom = top + child Height ; bottom Bound = bottom + lp . bottom Margin ; } if ( right Bound > max Right No Padding ) max Right No Padding = right Bound ; if ( bottom Bound > max Bottom ) max Bottom = bottom Bound ;  Rect rect = new  Rect ( ) ; rect . left = left ; rect . top = top ; rect . right = right ; rect . bottom = bottom ; rect List . add ( rect ) ; } adjust Base Line ( max Bottom - last Max Bottom , line Start Index , rect List . size ( ) ) ; int measured Width ; int measured Height ; if ( width Mode ==  Measure Spec .  EXACTLY ) measured Width = max Width ; else measured Width = max Right No Padding + padding Right ; if ( height Mode ==  Measure Spec .  EXACTLY ) measured Height = max Height ; else { measured Height = max Bottom + padding Bottom ; if ( height Mode ==  Measure Spec .  AT_ MOST ) measured Height = measured Height > max Height ? max Height : measured Height ; } set Measured Dimension ( measured Width , measured Height ) ; }
private void ensure Buffer Capacity ( int desired Capacity ) { int capacity = pixel Buffer . length ; while ( capacity < desired Capacity ) { capacity *= _ NUM ; } if ( capacity > pixel Buffer . length ) { pixel Buffer = new byte [ capacity ] ; } }
public static <  K ,  V >  Concurrent Map <  K ,  V > new Concurrent Map With Aggressive Concurrency ( ) { return new  Concurrent Hash Map < > ( _ NUM , _ NUM , aggressive Concurrency Level ) ; }
@  Override public boolean connection Allowed (  String event Name ) { if ( m_listenee != null || ! event Name . equals ( _ STR ) ) { return _ BOOL ; } return _ BOOL ; }
protected char skip All Whitespace (  Reader r ) throws  IOException { char c ; do { c = ( char ) r . read ( ) ; } while (  Character . is Whitespace ( c ) && c != ( char ) - _ NUM ) ; return c ; }
public  Map <  String ,  String > parse ( final  String str , char separator ) { if ( str == null ) { return new  Hash Map < > ( ) ; } return parse ( str . to Char Array ( ) , separator ) ; }
private  String resource Id ( ) { return sub Schema Path . is Empty ( ) ? null : last Schema Node Name ( ) ; }
private long acquire Write ( boolean interruptible , long deadline ) {  WNode node = null , p ; for ( int spins = - _ NUM ; ; ) { long m , s , ns ; if ( ( m = ( s = state ) &  ABITS ) == _ NUM ) { if (  U . compare And Swap Long ( this ,  STATE , s , ns = s +  WBIT ) ) return ns ; } else if ( spins < _ NUM ) spins = ( m ==  WBIT && wtail == whead ) ?  SPINS : _ NUM ; else if ( spins > _ NUM ) { if (  Lock Support . next Secondary Seed ( ) >= _ NUM ) -- spins ; } else if ( ( p = wtail ) == null ) {  WNode hd = new  WNode (  WMODE , null ) ; if (  U . compare And Swap Object ( this ,  WHEAD , null , hd ) ) wtail = hd ; } else if ( node == null ) node = new  WNode (  WMODE , p ) ; else if ( node . prev != p ) node . prev = p ; else if (  U . compare And Swap Object ( this ,  WTAIL , p , node ) ) { p . next = node ; break ; } } for ( int spins = - _ NUM ; ; ) {  WNode h , np , pp ; int ps ; if ( ( h = whead ) == p ) { if ( spins < _ NUM ) spins =  HEAD_ SPINS ; else if ( spins <  MAX_ HEAD_ SPINS ) spins <<= _ NUM ; for ( int k = spins ; ; ) { long s , ns ; if ( ( ( s = state ) &  ABITS ) == _ NUM ) { if (  U . compare And Swap Long ( this ,  STATE , s , ns = s +  WBIT ) ) { whead = node ; node . prev = null ; return ns ; } } else if (  Lock Support . next Secondary Seed ( ) >= _ NUM && -- k <= _ NUM ) break ; } } else if ( h != null ) {  WNode c ;  Thread w ; while ( ( c = h . cowait ) != null ) { if (  U . compare And Swap Object ( h ,  WCOWAIT , c , c . cowait ) && ( w = c . thread ) != null )  U . unpark ( w ) ; } } if ( whead == h ) { if ( ( np = node . prev ) != p ) { if ( np != null ) ( p = np ) . next = node ; } else if ( ( ps = p . status ) == _ NUM )  U . compare And Swap Int ( p ,  WSTATUS , _ NUM ,  WAITING ) ; else if ( ps ==  CANCELLED ) { if ( ( pp = p . prev ) != null ) { node . prev = pp ; pp . next = node ; } } else { long time ; if ( deadline == _ NUM ) time = _ NUM ; else if ( ( time = deadline -  System . nano Time ( ) ) <= _ NUM ) return cancel Waiter ( node , node , _ BOOL ) ;  Thread wt =  Thread . current Thread ( ) ;  U . put Object ( wt ,  PARKBLOCKER , this ) ; node . thread = wt ; if ( p . status < _ NUM && ( p != h || ( state &  ABITS ) != _ NUM ) && whead == h && node . prev == p )  U . park ( _ BOOL , time ) ; node . thread = null ;  U . put Object ( wt ,  PARKBLOCKER , null ) ; if ( interruptible &&  Thread . interrupted ( ) ) return cancel Waiter ( node , node , _ BOOL ) ; } } } }
@  Override public boolean is Initial ( ) { return init ; }
public static  String denormalize ( final  Char Sequence self ) { if ( line Separator == null ) { final  String Writer sw = new  String Writer ( _ NUM ) ; try { final  Buffered Writer bw = new  Buffered Writer ( sw ) ; bw . new Line ( ) ; bw . flush ( ) ; line Separator = sw . to String ( ) ; } catch (  IOException ioe ) { line Separator = _ STR ; } } final int len = self . length ( ) ; if ( len < _ NUM ) { return self . to String ( ) ; } final  String Builder sb = new  String Builder ( ( _ NUM * len ) / _ NUM ) ; int i = _ NUM ;  Char Sequence cs = ( self instanceof  GString ) ? self . to String ( ) : self ; while ( i < len ) { final char ch = cs . char At ( i ++ ) ; switch ( ch ) { case _ STR : sb . append ( line Separator ) ; if ( ( i < len ) && ( cs . char At ( i ) == _ STR ) ) { ++ i ; } break ; case _ STR : sb . append ( line Separator ) ; break ; default : sb . append ( ch ) ; break ; } } return sb . to String ( ) ; }
public static void perform Save As (  String schema Prefix File Name ,  String sel File Path ,  Container Config container Config ) { try {  File file With Default Configuration = create Container Schema File ( schema Prefix File Name , sel File Path ) ; update File ( container Config , file With Default Configuration . get Path ( ) , schema Prefix File Name ) ; } catch (  Exception e ) { e . print Stack Trace ( ) ; } }
public boolean is Aborted ( ) { return is Aborted . get ( ) ; }
public void append ( int key ,  E value ) { if ( m Size != _ NUM && key <= m Keys [ m Size - _ NUM ] ) { put ( key , value ) ; return ; } if ( m Garbage && m Size >= m Keys . length ) { gc ( ) ; } int pos = m Size ; if ( pos >= m Keys . length ) { int n = ideal Int Array Size ( pos + _ NUM ) ; int [ ] nkeys = new int [ n ] ;  Object [ ] nvalues = new  Object [ n ] ;  System . arraycopy ( m Keys , _ NUM , nkeys , _ NUM , m Keys . length ) ;  System . arraycopy ( m Values , _ NUM , nvalues , _ NUM , m Values . length ) ; m Keys = nkeys ; m Values = nvalues ; } m Keys [ pos ] = key ; m Values [ pos ] = value ; m Size = pos + _ NUM ; }
public  Ipc Shared Memory Space (  String tok File Name , int writer Pid , int reader Pid , int size , boolean reader ,  Ignite Logger parent ) throws  Ignite Checked Exception { assert size > _ NUM : _ STR ; log = parent . get Logger (  Ipc Shared Memory Space . class ) ; op Size = size ; shmem Ptr =  Ipc Shared Memory Utils . allocate System Resources ( tok File Name , size ,  DEBUG && log . is Debug Enabled ( ) ) ; shmem Id =  Ipc Shared Memory Utils . shared Memory Id ( shmem Ptr ) ; sem Id =  Ipc Shared Memory Utils . semaphore Id ( shmem Ptr ) ; is Reader = reader ; this . tok File Name = tok File Name ; this . reader Pid = reader Pid ; this . writer Pid = writer Pid ; if (  DEBUG && log . is Debug Enabled ( ) ) log . debug ( _ STR + this ) ; }
@  Override public void close ( ) { try { if ( connection != null ) { connection . close ( ) ; } } catch (  SQLException e ) { e . print Stack Trace ( ) ; } }
public  Version add Qualifier (  String qualifier ) {  List <  String > new Qualifiers = new  Array List < > ( this . qualifiers ) ; new Qualifiers . add ( qualifier ) ; return new  Version ( major , minor , patch , new Qualifiers . to Array ( new  String [ new Qualifiers . size ( ) ] ) ) ; }
public int load Signed16 ( int addr ) { return load Signed16 ( addr ,  Access Source .  CODE ) ; }
public static  String array To Hex String ( byte [ ] array ) { return array To Hex String ( array , _ NUM , array . length ) ; }
public static void unregister Baggage Handler (  Baggage Handler handler ) { handlers . remove ( handler ) ; }
public  Default Heat Map Dataset ( int x Samples , int y Samples , double min X , double max X , double min Y , double max Y ) { if ( x Samples < _ NUM ) { throw new  Illegal Argument Exception ( _ STR ) ; } if ( y Samples < _ NUM ) { throw new  Illegal Argument Exception ( _ STR ) ; } if (  Double . is Infinite ( min X ) ||  Double . is Na N ( min X ) ) { throw new  Illegal Argument Exception ( _ STR ) ; } if (  Double . is Infinite ( max X ) ||  Double . is Na N ( max X ) ) { throw new  Illegal Argument Exception ( _ STR ) ; } if (  Double . is Infinite ( min Y ) ||  Double . is Na N ( min Y ) ) { throw new  Illegal Argument Exception ( _ STR ) ; } if (  Double . is Infinite ( max Y ) ||  Double . is Na N ( max Y ) ) { throw new  Illegal Argument Exception ( _ STR ) ; } this . x Samples = x Samples ; this . y Samples = y Samples ; this . min X = min X ; this . max X = max X ; this . min Y = min Y ; this . max Y = max Y ; this . z Values = new double [ x Samples ] [ ] ; for ( int x = _ NUM ; x < x Samples ; x ++ ) { this . z Values [ x ] = new double [ y Samples ] ; } }
public static void assert Equals Any Order (  Event Bean [ ] [ ] expected ,  Event Bean [ ] [ ] actual ) { if ( compare Array Size ( expected , actual ) ) { return ; } int num Matches = _ NUM ; boolean [ ] found Received = new boolean [ actual . length ] ; for (  Event Bean [ ] expected Object : expected ) { boolean found = _ BOOL ; for ( int i = _ NUM ; i < actual . length ; i ++ ) { if ( found Received [ i ] ) { continue ; } boolean match = compare Equals Exact Order ( actual [ i ] , expected Object ) ; if ( match ) { found = _ BOOL ; num Matches ++ ; found Received [ i ] = _ BOOL ; break ; } } if ( ! found ) { log . error ( _ STR +  Arrays . to String ( expected Object ) ) ; log . error ( _ STR +  Arrays . to String ( actual ) ) ; }  Scope Test Helper . assert True ( found ) ; }  Scope Test Helper . assert Equals ( num Matches , expected . length ) ; }
private void collect Text ( ) { if ( text Node Count > _ NUM ) { first Text Node . set Text ( text Buffer . to String ( ) ) ; } text Node Count = _ NUM ; }
@  Suppress Warnings ( { _ STR , _ STR } ) public static <  T extends  Annotation >  T unproxy (  T annotation ) {  Function unproxy Function = get Unproxy Function ( annotation . annotation Type ( ) ) ; return (  T ) unproxy Function . apply ( annotation ) ; }
public static  List <  Node > parse Expression (  Context context ,  Hash Set <  String > config Namespaces ,  String text ) { return parse Expression ( context , config Namespaces , text , _ NUM , _ BOOL ) ; }
public void add Tick Mark Section ( final  Section  SECTION ) { if ( null ==  SECTION ) return ; tick Mark Sections . add (  SECTION ) ;  Collections . sort ( tick Mark Sections , new  Section Comparator ( ) ) ; fire Update Event (  REDRAW_ EVENT ) ; }
protected static double calc Q_i ( double f , double lambda ) { return lambda *  Math . exp ( - lambda * f ) ; }
void flush ( ) { print Stream . flush ( ) ; }
public  Char Buffer delete ( int start , int end ) { int length = length ( ) ; if ( start < _ NUM || end < start || length < start ) throw new  String Index Out Of Bounds Exception ( ) ; end =  Math . min ( length , end ) ; int tail = length - end ; char [ ] buffer = buffer ( ) ; for ( int i = _ NUM ; i < tail ; i ++ ) { buffer [ start + i ] = buffer [ end + i ] ; } length ( length - ( end - start ) ) ; return this ; }
public void add Listener (  Speedruns Live Listener listener ) { listeners . add ( listener ) ; }
public int action (  String fault ,  String action ) {  Integer current = get ( fault ) ; if ( current == null ) throw new  Illegal Argument Exception ( fault ) ; boolean no = action . starts With ( _ STR ) ; if ( no ) action = action . substring ( _ NUM ) ;  Integer bit = get Action ( action ) ; if ( bit == null ) throw new  Illegal Argument Exception ( action ) ; int old = current . int Value ( ) ; int mask = bit . int Value ( ) ; int n = ( old & ( ~ mask ) ) ; n = ( no ) ? n : ( n | mask ) ; put ( fault , new  Integer ( n ) ) ; return n ; }
public static <  T >  T decode From Base64 (  Coder <  T > coder ,  String encoded Value ) throws  Coder Exception { return decode From Safe Stream ( coder , new  Byte Array Input Stream (  Base64 . decode Base64 ( encoded Value ) ) ,  Coder .  Context .  OUTER ) ; }
public void validate (  Set set Data ) throws  Validation Exception { for (  Iterator iter = set Data . iterator ( ) ; iter . has Next ( ) ; ) { perform Validation ( (  String ) iter . next ( ) ) ; } }
public  String add (  Object ... values ) { double result = _ NUM ; for ( int i = _ NUM ; i < values . length ; i ++ ) { result +=  Function Handler . get Double ( values [ i ] ) ; } return  Double . to String ( result ) ; }
public  List <  String > list My DBs (  String owner , boolean restricted ) {  Connection conn = null ; try { conn = get Connection ( ) ; return list My DBs ( conn , owner , restricted ) ; } catch (  Exception ex ) { logger . log (  Level .  SEVERE , _ STR , ex ) ; } finally {  DBUtils . close ( conn ) ; } return null ; }
protected void do Function ( float [ ] inputs , int input Offset , float [ ] outputs , int output Offset ) { float input = inputs [ input Offset ] ; for ( int i = _ NUM ; i < get Num Outputs ( ) ; i ++ ) { outputs [ i + output Offset ] = get C0 ( i ) + ( float ) (  Math . pow ( input , get N ( ) ) * ( get C1 ( i ) - get C0 ( i ) ) ) ; } }
public int compare (  Object o1 ,  Object o2 ) { return comparator . compare ( o1 , o2 ) ; }
public void add Check Box Action Listener (  Action Listener al ) { m_enable Distributed Experiment . add Action Listener ( al ) ; }
GF256 Poly add Or Subtract (  GF256 Poly other ) { if ( ! field . equals ( other . field ) ) { throw new  Illegal Argument Exception ( _ STR ) ; } if ( is Zero ( ) ) { return other ; } if ( other . is Zero ( ) ) { return this ; } int [ ] smaller Coefficients = this . coefficients ; int [ ] larger Coefficients = other . coefficients ; if ( smaller Coefficients . length > larger Coefficients . length ) { int [ ] temp = smaller Coefficients ; smaller Coefficients = larger Coefficients ; larger Coefficients = temp ; } int [ ] sum Diff = new int [ larger Coefficients . length ] ; int length Diff = larger Coefficients . length - smaller Coefficients . length ;  System . arraycopy ( larger Coefficients , _ NUM , sum Diff , _ NUM , length Diff ) ; for ( int i = length Diff ; i < larger Coefficients . length ; i ++ ) { sum Diff [ i ] =  GF256 . add Or Subtract ( smaller Coefficients [ i - length Diff ] , larger Coefficients [ i ] ) ; } return new  GF256 Poly ( field , sum Diff ) ; }
@  Override public  String to String ( ) {  String Buffer sb = new  String Buffer ( ) ; sb . append ( type ) ; sb . append ( _ STR ) ; sb . append ( sub Type ) ; for (  String name : attributes . key Set ( ) ) { if ( inferred Charset &&  ATTR_ CHARSET . equals ( name ) ) { continue ; } sb . append ( _ STR ) ; sb . append ( name ) ; sb . append ( _ STR ) ;  String value = attributes . get ( name ) ;  Matcher token Matcher =  TOKEN_ PATTERN . matcher ( value ) ; if ( token Matcher . matches ( ) ) { sb . append ( value ) ; } else { sb . append ( _ STR + value + _ STR ) ; } } return sb . to String ( ) ; }
public static long first Field Offset (  Class clazz ) { long min Size = round Up To8 ( header Size ( clazz ) ) ; while ( clazz !=  Object . class ) { for (  Field f : clazz . get Declared Fields ( ) ) { if ( ( f . get Modifiers ( ) &  Modifier .  STATIC ) == _ NUM ) { long offset = unsafe . object Field Offset ( f ) ; if ( offset < min Size ) { min Size = offset ; } } } clazz = clazz . get Superclass ( ) ; } return min Size ; }
public final  V extract First ( ) { if ( size ( ) > _ NUM ) { if (  GWT . is Script ( ) ) {  V ret = js Array . get ( _ NUM ) ; js Array . remove ( _ NUM ) ; return ret ; } else { return java Array . remove ( _ NUM ) ; } } return null ; }
@  Override public void action Performed (  Action Event event ) {  String command = event . get Action Command ( ) ; if ( command . equals ( _ STR ) ) { attempt Label Font Selection ( ) ; } else if ( command . equals ( _ STR ) ) { attempt Modify Label Paint ( ) ; } else if ( command . equals ( _ STR ) ) { attempt Tick Label Font Selection ( ) ; } }
public static void upgrade Server Instance (  SSOToken sso Token ,  String instance Name ,  String instance Id ,  Map <  String ,  String > upgraded Values ) throws  SMSException ,  SSOException ,  Configuration Exception ,  IOException {  Service Config sc = get Server Config ( sso Token , instance Name ) ; if ( sc != null ) {  Map map = sc . get Attributes ( ) ; map . remove (  ATTR_ PARENT_ SITE_ ID ) ;  Set new Set = get Properties Set ( upgraded Values ) ; map . put (  ATTR_ SERVER_ CONFIG , new Set ) ; sc . set Attributes ( map ) ; } else { throw new  Configuration Exception ( _ STR + _ STR ) ; } }
public static <  T >  T instance (  Class <  T > clazz ) { try { return clazz . new Instance ( ) ; } catch (  Instantiation Exception |  Illegal Access Exception e ) { throw new  Illegal State Exception ( e ) ; } }
public  Generic Sip Msrp Session create Msrp Session (  Contact Id contact ,  String feature Tag ,  String [ ] accept Types ,  String [ ] accept Wrapped Types ) { if ( s Logger . is Activated ( ) ) { s Logger . info ( _ STR + contact ) ; } return new  Originating Sip Msrp Session ( this , contact , feature Tag , m Rcs Settings ,  System . current Time Millis ( ) , m Contact Manager , accept Types , accept Wrapped Types ) ; }
protected void draw Mark (  Graphics2 D g2 , float x , float y ,  Color color ) {  Rectangle2 D bounds = mark . get Bounds2 D ( ) ; float w = ( float ) bounds . get Width ( ) ; float h = ( float ) bounds . get Height ( ) ; x = x - ( w / _ NUM ) ; y = y - ( h / _ NUM ) ; g2 . translate ( x , y ) ; if ( color == null ) { if ( mark Fill Paint != null ) { g2 . set Paint ( mark Fill Paint ) ; g2 . fill ( mark ) ; } } else { g2 . set Paint ( color ) ; g2 . fill ( mark ) ; } g2 . set Paint ( mark Paint ) ; g2 . set Stroke ( mark Stroke ) ; g2 . draw ( mark ) ; g2 . translate ( - x , - y ) ;  Rectangle2 D rect = new  Rectangle2 D .  Float ( x , y , w , h ) ; mark Bounds . add ( rect ) ; }
public void component Resized (  Component Event e ) { if ( logger . is Loggable (  Level .  FINE ) ) { logger . fine ( _ STR + get Width ( ) + _ STR + get Height ( ) ) ; } projection . set Width ( get Width ( ) ) ; projection . set Height ( get Height ( ) ) ; fire Projection Changed ( ) ; }
public static  String byte Array To Hex String ( byte [ ] block , int offset , int length ) {  String Buffer buf = new  String Buffer ( ) ; int len = block . length ; length = length + offset ; if ( ( len < length ) ) { length = len ; } for ( int i = _ NUM + offset ; i < length ; i ++ ) { byte2hex ( block [ i ] , buf ) ; if ( i < length - _ NUM ) { buf . append ( _ STR ) ; } } return buf . to String ( ) ; }
private void change Value (  Abstract Storage Label <  Object > label ,  Object new Value ) { if ( !  Objects . equals ( label . get Value ( ) , new Value ) ) { synchronized ( label Edit Listeners ) { for (  Label Edit Listener listener : label Edit Listeners ) { listener . pre Label Value Change ( label ) ; } } label . set Value ( new Value ) ; synchronized ( label Edit Listeners ) { for (  Label Edit Listener listener : label Edit Listeners ) { listener . post Label Value Change ( label ) ; } } } }
public void write ( byte [ ] b , int offset , int length ) throws  IOException { if ( entry . get Method ( ) ==  DEFLATED ) { if ( length > _ NUM ) { if ( ! def . finished ( ) ) { def . set Input ( b , offset , length ) ; while ( ! def . needs Input ( ) ) { deflate ( ) ; } } } } else { write Out ( b , offset , length ) ; written += length ; } crc . update ( b , offset , length ) ; }
public void update Point ( float x , float y ) { if (  Math . sqrt ( x * x + y * y ) > _ NUM ) if ( listener != null ) { listener . on Angle Changed Listener ( get Angle ( x , - y ) ) ; } }
@  Override public int clamp View Position Horizontal (  View child , int left , int dx ) { if ( m Dragged View == null ) { return _ NUM ; } final int left Bound = _ NUM -  MAX_ OVERFLOW - ( m Column Size Side / _ NUM ) ; final int right Bound = get Width ( ) +  MAX_ OVERFLOW + ( m Column Size Side / _ NUM ) ; return  Math . min (  Math . max ( left , left Bound ) , right Bound ) ; }
Http Request Wrapper (  Http Servlet Request request ) { super ( request ) ; }
private int convert To Panel X ( double xval ) { double temp = ( xval - m_min X ) / m_range X ; temp = temp * m_panel Width ; return ( int ) temp ; }
public void forward (  Http Server Request request ) { forward ( request , null ) ; }
private  Set <  String > primary Keys (  Prepared Statement stmt ,  String owner ,  String tbl ) throws  SQLException {  Set <  String > pk Cols = new  Hash Set < > ( ) ; stmt . set String ( _ NUM , owner ) ; stmt . set String ( _ NUM , tbl ) ; try (  Result Set pk Rs = stmt . execute Query ( ) ) { while ( pk Rs . next ( ) ) pk Cols . add ( pk Rs . get String ( _ NUM ) ) ; } return pk Cols ; }
public static long read UINT32 (  Input Stream stream ) throws  IOException { long result = _ NUM ; for ( int i = _ NUM ; i <= _ NUM ; i += _ NUM ) { result |= ( long ) stream . read ( ) << i ; } return result ; }
private  Token to Prefix Token (  ILeaf Node leaf ) {  Lexer lexer = new  Internal N4 JSLexer ( ) ;  String text = leaf . get Text ( ) ;  String prefix = text . substring ( _ NUM , end Offset - leaf . get Total Offset ( ) ) ;  ANTLRString Stream stream = new  ANTLRString Stream ( prefix ) ; lexer . set Char Stream ( stream ) ;  Token next Token = lexer . next Token ( ) ; return new  Common Token ( next Token . get Type ( ) , next Token . get Text ( ) ) ; }
protected void add (  CSVRecord record ) { records . add (  Objects . require Non Null ( record ) ) ; }
private void scheduled Enqueue Send ( ) { scheduler Queue Size . decrement And Get ( ) ; scheduled . set ( _ BOOL ) ; enqueue Send With Error Logging ( ) ; }
public static  String join ( char [ ] self ,  String separator ) {  String Builder buffer = new  String Builder ( ) ; boolean first = _ BOOL ; if ( separator == null ) separator = _ STR ; for ( char next : self ) { if ( first ) { first = _ BOOL ; } else { buffer . append ( separator ) ; } buffer . append ( next ) ; } return buffer . to String ( ) ; }
private <  T >  Binding Amp <  T > find Object Binding (  Key <  T > key ) {  Objects . require Non Null ( key ) ; if ( key . qualifiers ( ) . length != _ NUM ) { throw new  Illegal Argument Exception ( ) ; } return (  Binding Amp ) find Binding (  Key . of (  Object . class , key . qualifiers ( ) [ _ NUM ] ) ) ; }
private void init Compute Program ( ) { gl Use Program ( compute Program ) ;  Int Buffer work Group Size =  Buffer Utils . create Int Buffer ( _ NUM ) ; gl Get Programiv ( compute Program ,  GL_ COMPUTE_ WORK_ GROUP_ SIZE , work Group Size ) ; work Group Size X = work Group Size . get ( _ NUM ) ; work Group Size Y = work Group Size . get ( _ NUM ) ; time Uniform = gl Get Uniform Location ( compute Program , _ STR ) ; blend Factor Uniform = gl Get Uniform Location ( compute Program , _ STR ) ; light Radius Uniform = gl Get Uniform Location ( compute Program , _ STR ) ;  Int Buffer props =  Buffer Utils . create Int Buffer ( _ NUM ) ;  Int Buffer params =  Buffer Utils . create Int Buffer ( _ NUM ) ; props . put ( _ NUM ,  GL_ BUFFER_ BINDING ) ; int objects Resource Index = gl Get Program Resource Index ( compute Program ,  GL_ SHADER_ STORAGE_ BLOCK , _ STR ) ; gl Get Program Resourceiv ( compute Program ,  GL_ SHADER_ STORAGE_ BLOCK , objects Resource Index , props , null , params ) ; objects Ssbo Binding = params . get ( _ NUM ) ; int triangles Resource Index = gl Get Program Resource Index ( compute Program ,  GL_ SHADER_ STORAGE_ BLOCK , _ STR ) ; gl Get Program Resourceiv ( compute Program ,  GL_ SHADER_ STORAGE_ BLOCK , triangles Resource Index , props , null , params ) ; triangles Ssbo Binding = params . get ( _ NUM ) ; int loc = gl Get Uniform Location ( compute Program , _ STR ) ; gl Get Uniformiv ( compute Program , loc , params ) ; framebuffer Image Binding = params . get ( _ NUM ) ; loc = gl Get Uniform Location ( compute Program , _ STR ) ; gl Get Uniformiv ( compute Program , loc , params ) ; world Position Image Binding = params . get ( _ NUM ) ; loc = gl Get Uniform Location ( compute Program , _ STR ) ; gl Get Uniformiv ( compute Program , loc , params ) ; world Normal Image Binding = params . get ( _ NUM ) ; gl Use Program ( _ NUM ) ; }
public boolean if Task Completed Success Or Failure From Response (  Response On Singe Request my Response ) { boolean is Completed = _ BOOL ; try { if ( my Response == null || my Response . is Fail Obtain Response ( ) ) { return is Completed ; }  String response Body = my Response . get Response Body ( ) ; if ( response Body . matches ( success Regex ) || response Body . matches ( failure Regex ) ) { is Completed = _ BOOL ; } } catch (  Exception t ) { logger . error ( _ STR + t ) ; } return is Completed ; }
public void center Horizontal (  Array List <  Integer > nodes ) { if ( m_b Needs Undo Action ) { add Undo Action ( new center Horizontal Action ( nodes ) ) ; } int n Min Y = - _ NUM ; int n Max Y = - _ NUM ; for ( int i Node = _ NUM ; i Node < nodes . size ( ) ; i Node ++ ) { int n Y = get Position Y ( nodes . get ( i Node ) ) ; if ( n Y < n Min Y || i Node == _ NUM ) { n Min Y = n Y ; } if ( n Y > n Max Y || i Node == _ NUM ) { n Max Y = n Y ; } } for ( int i Node = _ NUM ; i Node < nodes . size ( ) ; i Node ++ ) { int n Node = nodes . get ( i Node ) ; m_n Position Y . set ( n Node , ( n Min Y + n Max Y ) / _ NUM ) ; } }
protected void append Text ( final  String text ) { if ( text != null ) { text Body . append ( text ) ; } }
public void on Restore Instance State (  Bundle saved Instance State ) { m Selected Positions . add All ( saved Instance State . get Integer Array List (  TAG ) ) ;  Log . d (  TAG , _ STR + m Selected Positions ) ; }
public  Hour ( int hour ,  Day day ) {  Param Checks . null Not Permitted ( day , _ STR ) ; this . hour = ( byte ) hour ; this . day = day ; peg (  Calendar . get Instance ( ) ) ; }
public void undo ( ) { if ( -- m_temp Undo Index < _ NUM ) { m_temp Undo Index = m_temp Undo Files . length - _ NUM ; } if ( m_temp Undo Files [ m_temp Undo Index ] != null ) {  Abstract File Loader loader =  Converter Utils . get Loader For File ( m_temp Undo Files [ m_temp Undo Index ] ) ; try { loader . set File ( m_temp Undo Files [ m_temp Undo Index ] ) ; set Instances From File ( loader ) ; } catch (  Exception e ) { e . print Stack Trace ( ) ; m_ Log . log Message ( e . to String ( ) ) ;  JOption Pane . show Message Dialog (  Preprocess Panel . this , _ STR + e . to String ( ) , _ STR ,  JOption Pane .  ERROR_ MESSAGE ) ; } m_temp Undo Files [ m_temp Undo Index ] = null ; } int temp = m_temp Undo Index - _ NUM ; if ( temp < _ NUM ) { temp = m_temp Undo Files . length - _ NUM ; } m_ Undo But . set Enabled ( m_temp Undo Files [ temp ] != null ) ; }
public static boolean is Connected Using Wifi ( ) {  Context context =  Fe App . get App Context ( ) ;  Connectivity Manager cm = (  Connectivity Manager ) context . get System Service (  Context .  CONNECTIVITY_ SERVICE ) ;  Network Info ni = cm . get Active Network Info ( ) ; return ni != null && ni . is Connected ( ) == _ BOOL && ni . get Type ( ) ==  Connectivity Manager .  TYPE_ WIFI ; }
public void close ( ) throws  IOException { if ( writer != null ) writer . flush Buffer ( ) ; }
public  Process ( final  File file , final  Progress Listener progress Listener ) throws  IOException ,  XMLException { this . process Location = new  File Process Location ( file ) ; init Context ( ) ;  Reader in = null ; try { in = new  Input Stream Reader ( new  File Input Stream ( file ) , _ STR ) ; read Process ( in , progress Listener ) ; } catch (  IOException e ) { throw e ; } finally { if ( in != null ) { in . close ( ) ; } } }
public static  String extract Music IDFrom Media ID ( @  Non Null  String media ID ) { int pos = media ID . index Of (  LEAF_ SEPARATOR ) ; if ( pos >= _ NUM ) { return media ID . substring ( pos + _ NUM ) ; } return null ; }
public static long [ ] values (  Long [ ] array ) { long [ ] dest = new long [ array . length ] ; for ( int i = _ NUM ; i < array . length ; i ++ ) {  Long v = array [ i ] ; if ( v != null ) { dest [ i ] = v . long Value ( ) ; } } return dest ; }
@  Override public void process New Lines (  String [ ] lines ) { for (  String line : lines ) { if ( line . starts With ( _ STR ) ) { continue ; } if ( line . contains ( _ STR ) ) { my Is File Missing = _ BOOL ; return ; }  String [ ] values = line . split (  LINE_ SPLIT_ REGEX ) ; if ( values . length <  INDEX_ OF_ TX_ BYTES ) { continue ; } try { int line Uid =  Integer . parse Int ( values [  INDEX_ OF_ UID ] ) ; if ( my Uid == line Uid ) { int temp Rx Bytes =  Integer . parse Int ( values [  INDEX_ OF_ RX_ BYTES ] ) ; int temp Tx Bytes =  Integer . parse Int ( values [  INDEX_ OF_ TX_ BYTES ] ) ; if ( temp Rx Bytes < _ NUM || temp Tx Bytes < _ NUM ) {  LOG . warning (  String . format ( _ STR , temp Rx Bytes , temp Tx Bytes , line ) ) ; continue ; } my Rx Bytes += temp Rx Bytes ; my Tx Bytes += temp Tx Bytes ; } } catch (  Number Format Exception e ) {  LOG . warning (  String . format ( _ STR , values [  INDEX_ OF_ UID ] , values [  INDEX_ OF_ RX_ BYTES ] , values [  INDEX_ OF_ TX_ BYTES ] , line ) ) ; } } }
public  String to String ( ) {  String str = _ STR ;  String followed By = _ STR ; int last Type = - _ NUM ;  String last String = _ STR ; int singles Count = _ NUM ; for (  Enumeration e = format Constraints . elements ( ) ; e . has More Elements ( ) ; ) {  Format Constraint constraint = (  Format Constraint ) e . next Element ( ) ; if ( constraint . count ==  Format Constraint .  COUNT_ EXACTLY_ ONE ) { if ( last Type != - _ NUM ) { if ( last Type != constraint . type ) { str += followed By + singles Count + last String ; followed By = _ STR ; singles Count = _ NUM ; last Type = constraint . type ; last String = constraint . to String ( ) ; } else { singles Count ++ ; } } else { last Type = constraint . type ; last String = constraint . to String ( ) ; singles Count = _ NUM ; } } else { if ( last Type != - _ NUM ) { str += followed By + singles Count + last String ; followed By = _ STR ; last Type = - _ NUM ; singles Count = _ NUM ; last String = _ STR ; } str += followed By + constraint . to String ( ) ; followed By = _ STR ; } } if ( last Type != - _ NUM ) { str += followed By + singles Count + last String ; } return str ; }
public void read Data (  Data Input din ) throws  IOException { din . read Short ( ) ; count = din . read Unsigned Short ( ) ; registers = new  Input Register [ count ] ; for ( int i = _ NUM ; i < count ; i ++ ) { registers [ i ] = new  Simple Input Register ( din . read Short ( ) ) ; } }
public void adjust Indentation ( int delta ) { if ( delta < _ NUM ) { indentation Level =  Math . max ( _ NUM , indentation Level + delta ) ; } else { indentation Level += delta ; } }
public int capacity ( ) { return capacity . get ( ) ; }
protected static token do_code_string ( ) throws java . io .  IOException {  String Buffer result = new  String Buffer ( ) ; advance ( ) ; advance ( ) ; while ( ! ( next_char == _ STR && next_char2 == _ STR ) ) { if ( next_char ==  EOF_ CHAR ) { emit_error ( _ STR ) ; break ; } result . append ( new  Character ( ( char ) next_char ) ) ; advance ( ) ; } advance ( ) ; advance ( ) ; return new str_token ( sym .  CODE_ STRING , result . to String ( ) ) ; }
public  String random (  Object omin ,  Object omax ) { int min =  Function Handler . get Int ( omin ) ; int max =  Function Handler . get Int ( omax ) ; if ( max > min ) { return  Integer . to String ( rnd . next Int ( max - min ) + min ) ; } return _ STR ; }
public void test_reopen01 ( ) { final  IRaw Store store = new  Simple Memory Raw Store ( ) ; final  BTree btree ; {  Index Metadata md = new  Index Metadata (  UUID . random UUID ( ) ) ; md . set Branching Factor ( _ NUM ) ; btree =  BTree . create ( store , md ) ; } assert True ( btree . is Open ( ) ) ; btree . close ( ) ; assert False ( btree . is Open ( ) ) ; try { btree . close ( ) ; fail ( _ STR +  Illegal State Exception . class ) ; } catch (  Illegal State Exception ex ) { if ( log . is Info Enabled ( ) ) log . info ( _ STR + ex ) ; } assert Not Null ( btree . get Root ( ) ) ; assert True ( btree . is Open ( ) ) ; }
public static  File search Paths (  Iterable < ? extends  File > paths ,  String rel File ) { for (  File path : paths ) {  File f = new  File ( path , rel File ) ; if ( f . exists ( ) ) { return path ; } } return null ; }
private void load Configuration From Jvm Parameters ( ) {  String repository Property =  System . get Property (  REPOSITORY_ PROPERTY ) ; if ( null != repository Property ) {  String [ ] repository Ip Host = repository Property . split ( _ STR ) ; if ( repository Ip Host . length == _ NUM ) {  String repository Ip = repository Ip Host [ _ NUM ] ;  String repository Port = repository Ip Host [ _ NUM ] ; if (  String Utils . is Not Blank ( repository Ip ) &&  String Utils . is Not Blank ( repository Port ) ) { log . info ( _ STR + repository Ip + _ STR + repository Port ) ; try { int port =  Integer . parse Int ( repository Port ) ; set Repository ( repository Ip , port ) ; } catch (  Exception e ) { log . warn ( _ STR , e ) ; } } } }  String agent Name =  System . get Property (  AGENT_ NAME_ PROPERTY ) ; if (  String Utils . is Not Blank ( agent Name ) ) { try { log . info ( _ STR + agent Name ) ; set Agent Name ( agent Name ) ; } catch (  Exception e ) { log . warn ( _ STR , e ) ; } } else { try { set Agent Name (  DEFAULT_ AGENT_ NAME ) ; } catch (  Storage Exception e ) { log . warn ( _ STR , e ) ; } } }
public boolean soft Signin ( ) throws  IOException { if ( url == null ) { throw new  Illegal State Exception ( _ STR ) ; } check Resolve Host ( ) ; if ( session Id != null ) { if ( check Authorized ( get Auth Check Url ( session Id ) ) ) {  LOGGER . fine ( _ STR + session Id ) ; return _ BOOL ; } else { session Id = null ; } } long id = load Session Id ( ) ; if ( id == _ NUM ) { return _ BOOL ; } boolean authorized = check Authorized ( get Auth Check Url ( id ) ) ; if ( authorized ) {  LOGGER . info ( _ STR + id ) ; this . session Id = id ; } return authorized ; }
private void test View Alter And Command Cache ( ) throws  SQLException { delete Db ( _ STR ) ;  Connection conn = get Connection ( _ STR ) ;  Statement stat = conn . create Statement ( ) ; stat . execute ( _ STR ) ; stat . execute ( _ STR ) ; stat . execute ( _ STR ) ; stat . execute ( _ STR ) ; stat . execute ( _ STR ) ;  Result Set rs = stat . execute Query ( _ STR ) ; assert True ( rs . next ( ) ) ; assert Equals ( _ NUM , rs . get Int ( _ NUM ) ) ; stat . execute ( _ STR ) ; rs = stat . execute Query ( _ STR ) ; assert True ( rs . next ( ) ) ; assert Equals ( _ NUM , rs . get Int ( _ NUM ) ) ; conn . close ( ) ; delete Db ( _ STR ) ; }
protected static boolean approx Unit ( final  String Builder sbuf , final int amount , final int size , final  String name ) { int count = amount / size ; int remainder ; if ( count == _ NUM ) { return _ BOOL ; } remainder = amount - ( count * size ) ; if ( remainder >= ( size * _ NUM / _ NUM ) ) { count ++ ; sbuf . append ( count ) ; } else if ( remainder >= ( size * _ NUM / _ NUM ) ) { count ++ ; sbuf . append ( _ STR ) ; sbuf . append ( count ) ; } else if ( remainder >= ( size * _ NUM / _ NUM ) ) { sbuf . append ( _ STR ) ; sbuf . append ( count ) ; sbuf . append ( _ STR ) ; count = _ NUM ; } else if ( remainder >= ( size * _ NUM / _ NUM ) ) { sbuf . append ( _ STR ) ; sbuf . append ( count ) ; } else { sbuf . append ( count ) ; } sbuf . append ( _ STR ) ; sbuf . append (  Grammar . plnoun ( count , name ) ) ; return _ BOOL ; }
public static  Element create Element (  Document doc ,  String tag ,  String ns URI ,  String prefix ) {  String q Name = ( prefix == null || prefix . length ( ) == _ NUM ) ? tag : prefix + _ STR + tag ; return doc . create Element NS ( ns URI , q Name ) ; }
public static void modify File (  File file ,  Function <  String ,  String > modifier ) throws  IOException {  String content = new  String (  Files . to Byte Array ( file ) ,  Standard Charsets .  UTF_8 ) ;  String result = modifier . apply ( content ) ;  Files . write ( result . get Bytes (  Standard Charsets .  UTF_8 ) , file ) ; }
protected double  LLTo World Returning Lon ( double lat , double lon ,  Point2 D lp ) { double phi_deg = lat ; double phi =  Proj Math . deg To Rad ( phi_deg ) ; double lamba_deg = lon ; double lamba =  Proj Math . deg To Rad ( lamba_deg ) ; double dlamda = lamba - lamdaf ; if ( dlamda >  Math .  PI ) { dlamda -=  More Math .  TWO_ PI_ D ; } else if ( dlamda < -  Math .  PI ) { dlamda +=  More Math .  TWO_ PI_ D ; } double e = ellps . ecc ; double r = _ NUM ; if ( !  More Math . approximately_equal (  Math . abs ( phi ) ,  More Math .  HALF_ PI ,  EPS10 ) ) { double t = lamb Tsfn ( phi ,  Math . sin ( phi ) , e ) ; r = ellps . radius *  F *  Math . pow ( t , n ) ; } double theta = n * dlamda ; double easting = false Easting + r *  Math . sin ( theta - alpha ) ; double northing = false Northing + rf - r *  Math . cos ( theta - alpha ) ; lp . set Location ( easting , northing ) ; return dlamda ; }
protected boolean remove Turntable (  Layout Turntable o ) { if ( ! no Warn Turntable ) { int selected Value =  JOption Pane . show Option Dialog ( this , rb . get String ( _ STR ) ,  Bundle . get Message ( _ STR ) ,  JOption Pane .  YES_ NO_ CANCEL_ OPTION ,  JOption Pane .  QUESTION_ MESSAGE , null , new  Object [ ] {  Bundle . get Message ( _ STR ) ,  Bundle . get Message ( _ STR ) , rb . get String ( _ STR ) } ,  Bundle . get Message ( _ STR ) ) ; if ( selected Value == _ NUM ) { return ( _ BOOL ) ; } if ( selected Value == _ NUM ) { no Warn Turntable = _ BOOL ; } } if ( selected Object == o ) { selected Object = null ; } if ( prev Selected Object == o ) { prev Selected Object = null ; } for ( int j = _ NUM ; j < o . get Number Rays ( ) ; j ++ ) {  Track Segment t = o . get Ray Connect Ordered ( j ) ; if ( t != null ) { substitute Anchor ( o . get Ray Coords Indexed ( j ) , o , t ) ; } } for ( int i = _ NUM ; i < turntable List . size ( ) ; i ++ ) {  Layout Turntable lx = turntable List . get ( i ) ; if ( lx == o ) { turntable List . remove ( i ) ; o . remove ( ) ; set Dirty ( _ BOOL ) ; repaint ( ) ; return ( _ BOOL ) ; } } return ( _ BOOL ) ; }
public  INDArray as Matrix (  Buffered Image image ) { if ( channels == _ NUM ) { return to Bgr ( image ) ; } else { image = scaling If Need ( image , _ BOOL ) ; int w = image . get Width ( ) ; int h = image . get Height ( ) ;  INDArray ret =  Nd4j . create ( h , w ) ; for ( int i = _ NUM ; i < h ; i ++ ) { for ( int j = _ NUM ; j < w ; j ++ ) { ret . put Scalar ( new int [ ] { i , j } , image . get RGB ( i , j ) ) ; } } return ret ; } }
public int scheduled Queue Size ( ) { return scheduler Queue Size . get ( ) ; }
public  DGeneral Name Chooser (  JFrame parent ,  String title ,  General Name general Name ) { super ( parent , title ,  Modality Type .  DOCUMENT_ MODAL ) ; init Components ( general Name ) ; }
private void add Limited Mitre Join (  Line Segment offset0 ,  Line Segment offset1 , double distance , double mitre Limit ) {  Coordinate base Pt = seg0 . p1 ; double ang0 =  Angle . angle ( base Pt , seg0 . p0 ) ; double ang1 =  Angle . angle ( base Pt , seg1 . p1 ) ; double ang Diff =  Angle . angle Between Oriented ( seg0 . p0 , base Pt , seg1 . p1 ) ; double ang Diff Half = ang Diff / _ NUM ; double mid Ang =  Angle . normalize ( ang0 + ang Diff Half ) ; double mitre Mid Ang =  Angle . normalize ( mid Ang +  Math .  PI ) ; double mitre Dist = mitre Limit * distance ; double bevel Delta = mitre Dist *  Math . abs (  Math . sin ( ang Diff Half ) ) ; double bevel Half Len = distance - bevel Delta ; double bevel Mid X = base Pt . x + mitre Dist *  Math . cos ( mitre Mid Ang ) ; double bevel Mid Y = base Pt . y + mitre Dist *  Math . sin ( mitre Mid Ang ) ;  Coordinate bevel Mid Pt = new  Coordinate ( bevel Mid X , bevel Mid Y ) ;  Line Segment mitre Mid Line = new  Line Segment ( base Pt , bevel Mid Pt ) ;  Coordinate bevel End Left = mitre Mid Line . point Along Offset ( _ NUM , bevel Half Len ) ;  Coordinate bevel End Right = mitre Mid Line . point Along Offset ( _ NUM , - bevel Half Len ) ; if ( side ==  Position .  LEFT ) { seg List . add Pt ( bevel End Left ) ; seg List . add Pt ( bevel End Right ) ; } else { seg List . add Pt ( bevel End Right ) ; seg List . add Pt ( bevel End Left ) ; } }
public void test Multiply Diff Scale Pos Neg ( ) {  String a = _ STR ; int a Scale = _ NUM ;  String b = _ STR ; int b Scale = - _ NUM ;  String c = _ STR ; int c Scale = _ NUM ;  Big Decimal a Number = new  Big Decimal ( new  Big Integer ( a ) , a Scale ) ;  Big Decimal b Number = new  Big Decimal ( new  Big Integer ( b ) , b Scale ) ;  Big Decimal result = a Number . multiply ( b Number ) ; assert Equals ( _ STR , c , result . to String ( ) ) ; assert Equals ( _ STR , c Scale , result . scale ( ) ) ; }
public static  String format Simple Decimal ( double d ) { return simple Format . format ( d ) ; }
protected  Abstract Category Item Label Generator (  String label Format ,  Date Format formatter ) {  Param Checks . null Not Permitted ( label Format , _ STR ) ;  Param Checks . null Not Permitted ( formatter , _ STR ) ; this . label Format = label Format ; this . number Format = null ; this . percent Format =  Number Format . get Percent Instance ( ) ; this . date Format = formatter ; this . null Value String = _ STR ; }
public void del Items ( int s , int e ) { boolean hsb Was Visible = hsb Vis ; boolean vsb Was Visible = vsb Vis ; int old Last Displayed = last Item Displayed ( ) ; if ( log . is Loggable (  Platform Logger .  Level .  FINE ) ) { log . fine ( _ STR + s + _ STR + e ) ; } if ( log . is Loggable (  Platform Logger .  Level .  FINEST ) ) { log . finest ( _ STR + old Last Displayed + _ STR + items In Window ( ) + _ STR + items . size ( ) ) ; } if ( items . size ( ) == _ NUM ) { return ; } if ( s > e ) { int tmp = s ; s = e ; e = tmp ; } if ( s < _ NUM ) { s = _ NUM ; } if ( e >= items . size ( ) ) { e = items . size ( ) - _ NUM ; } boolean repaint Needed = ( s >= get First Visible Item ( ) && s <= get Last Visible Item ( ) ) ; for ( int i = s ; i <= e ; i ++ ) { items . remove Element At ( s ) ; int j = pos In Sel ( i ) ; if ( j != - _ NUM ) { int newsel [ ] = new int [ selected . length - _ NUM ] ;  System . arraycopy ( selected , _ NUM , newsel , _ NUM , j ) ;  System . arraycopy ( selected , j + _ NUM , newsel , j , selected . length - ( j + _ NUM ) ) ; selected = newsel ; } } int diff = ( e - s ) + _ NUM ; for ( int i = _ NUM ; i < selected . length ; i ++ ) { if ( selected [ i ] > e ) { selected [ i ] -= diff ; } } int options =  PAINT_ VSCROLL ; if ( get Focus Index ( ) > e ) { set Focus Index ( get Focus Index ( ) - ( e - s + _ NUM ) ) ; options |=  PAINT_ FOCUS ; } else if ( get Focus Index ( ) >= s && get Focus Index ( ) <= e ) { int focus Bound = ( items . size ( ) > _ NUM ) ? _ NUM : - _ NUM ; set Focus Index (  Math . max ( s - _ NUM , focus Bound ) ) ; options |=  PAINT_ FOCUS ; } if ( log . is Loggable (  Platform Logger .  Level .  FINEST ) ) { log . finest ( _ STR + multiple Selections ) ; } if ( vsb . get Value ( ) >= s ) { if ( vsb . get Value ( ) <= e ) { vsb . set Value ( e + _ NUM - diff ) ; } else { vsb . set Value ( vsb . get Value ( ) - diff ) ; } } int old Max Length = max Length ; max Length = max Length ( ) ; if ( max Length != old Max Length ) { options |=  PAINT_ HSCROLL ; } layout ( ) ; repaint Needed |= ( vsb Was Visible ^ vsb Vis ) || ( hsb Was Visible ^ hsb Vis ) ; if ( repaint Needed ) { options |=  PAINT_ ALL ; } repaint ( s , old Last Displayed , options ) ; }
static long make Id (  Snmp Oid oid ) { long id = _ NUM ; long [ ] arcs = oid . long Value ( _ BOOL ) ; id |= arcs [ _ NUM ] << _ NUM ; id |= arcs [ _ NUM ] << _ NUM ; id |= arcs [ _ NUM ] << _ NUM ; id |= arcs [ _ NUM ] << _ NUM ; id |= arcs [ _ NUM ] << _ NUM ; id |= arcs [ _ NUM ] << _ NUM ; id |= arcs [ _ NUM ] << _ NUM ; id |= arcs [ _ NUM ] ; return id ; }
private void cache Attribute (  String attr Id , byte [ ] [ ] values ) {  String cache Key = name + _ STR + attr Id ; value Cache . put ( cache Key , values ) ; }
void read (  Reader policy ) throws  Parsing Exception ,  IOException { if ( ! ( policy instanceof  Buffered Reader ) ) { policy = new  Buffered Reader ( policy ) ; } st = new  Stream Tokenizer ( policy ) ; st . reset Syntax ( ) ; st . word Chars ( _ STR , _ STR ) ; st . word Chars ( _ STR , _ STR ) ; st . word Chars ( _ STR , _ STR ) ; st . word Chars ( _ STR , _ STR ) ; st . word Chars ( _ STR , _ STR ) ; st . word Chars ( _ STR , _ STR ) ; st . word Chars ( _ NUM + _ NUM , _ NUM ) ; st . whitespace Chars ( _ NUM , _ STR ) ; st . comment Char ( _ STR ) ; st . quote Char ( _ STR ) ; st . quote Char ( _ STR ) ; st . lower Case Mode ( _ BOOL ) ; st . ordinary Char ( _ STR ) ; st . slash Slash Comments ( _ BOOL ) ; st . slash Star Comments ( _ BOOL ) ; st . parse Numbers ( ) ;  Hashtable <  String ,  Vector <  String > > processed Permissions = null ; lookahead = st . next Token ( ) ; while ( lookahead !=  Stream Tokenizer .  TT_ EOF ) { if ( peek ( _ STR ) ) {  Grant Entry ge = parse Grant Entry ( processed Permissions ) ; if ( ge != null ) grant Entries . add Element ( ge ) ; } else { throw new  Parsing Exception ( st . lineno ( ) , _ STR + _ STR ) ; } match ( _ STR ) ; } }
protected void inject Into Volume Information Container (  Map <  String ,  String Set > volume Information ,  String info Key ,  String alt Key ,  CIMInstance volume Instance ) {  Object value = get CIMProperty Value ( volume Instance , info Key ) ; if ( null == value ) { value = get CIMProperty Value ( volume Instance , alt Key ) ; }  String characterstic Name =  Supported Volume Information . get Volume Information ( info Key ) ; if ( null != value && null != characterstic Name ) {  String Set value Set = new  String Set ( ) ; if ( value instanceof  String ) { value Set . add ( value . to String ( ) ) ; } else if ( value instanceof  String [ ] ) { value Set . add All (  Arrays . as List ( (  String [ ] ) value ) ) ; } volume Information . put ( characterstic Name , value Set ) ; } }
@  Override public void on Detached From Recycler View (  Recycler View recycler View ) { super . on Detached From Recycler View ( recycler View ) ; m Attached Recycler View Pool . remove ( recycler View ) ; }
private void load File (  String filename ,  Abstract File Loader ... loaders ) {  Arff Sorted Table Model model ; this . m_ Filename = filename ; create Title ( ) ; if ( filename . equals ( _ STR ) ) { model = null ; } else { model = new  Arff Sorted Table Model ( filename , loaders ) ; model . set Show Attribute Index ( get Show Attribute Index ( ) ) ; } m_ Table Arff . set Model ( model ) ; set Changed ( _ BOOL ) ; create Name ( ) ; }
private void destination Type Changed ( ) { if ( m_ Exp == null ) return ;  String str = _ STR ; if ( m_ Results Destination CBox . get Selected Item ( ) ==  DEST_ DATABASE_ TEXT ) { m_ Results Destination Path Label . set Text ( _ STR ) ; str = m_destination Database URL ; m_ Browse Destination Button . set Enabled ( _ BOOL ) ; m_ Browse Destination Button . set Text ( _ STR ) ; } else { m_ Results Destination Path Label . set Text ( _ STR ) ; if ( m_ Results Destination CBox . get Selected Item ( ) ==  DEST_ ARFF_ TEXT ) { int ind = m_destination Filename . last Index Of ( _ STR ) ; if ( ind > - _ NUM ) { m_destination Filename = m_destination Filename . substring ( _ NUM , ind ) + _ STR ; } } if ( m_ Results Destination CBox . get Selected Item ( ) ==  DEST_ CSV_ TEXT ) { int ind = m_destination Filename . last Index Of ( _ STR ) ; if ( ind > - _ NUM ) { m_destination Filename = m_destination Filename . substring ( _ NUM , ind ) + _ STR ; } } str = m_destination Filename ; if ( m_ Results Destination CBox . get Selected Item ( ) ==  DEST_ ARFF_ TEXT ) { int ind = str . last Index Of ( _ STR ) ; if ( ind > - _ NUM ) { str = str . substring ( _ NUM , ind ) + _ STR ; } } if ( m_ Results Destination CBox . get Selected Item ( ) ==  DEST_ CSV_ TEXT ) { int ind = str . last Index Of ( _ STR ) ; if ( ind > - _ NUM ) { str = str . substring ( _ NUM , ind ) + _ STR ; } } m_ Browse Destination Button . set Enabled ( _ BOOL ) ; m_ Browse Destination Button . set Text ( _ STR ) ; } if ( m_ Results Destination CBox . get Selected Item ( ) ==  DEST_ DATABASE_ TEXT ) {  Database Result Listener drl = null ; try { drl = new  Database Result Listener ( ) ; } catch (  Exception e ) { e . print Stack Trace ( ) ; } drl . set Database URL ( m_destination Database URL ) ; m_ Exp . set Result Listener ( drl ) ; } else { if ( m_ Results Destination CBox . get Selected Item ( ) ==  DEST_ ARFF_ TEXT ) {  Instances Result Listener irl = new  Instances Result Listener ( ) ; if ( ! m_destination Filename . equals ( _ STR ) ) { irl . set Output File ( new  File ( m_destination Filename ) ) ; } m_ Exp . set Result Listener ( irl ) ; } else if ( m_ Results Destination CBox . get Selected Item ( ) ==  DEST_ CSV_ TEXT ) {  CSVResult Listener crl = new  CSVResult Listener ( ) ; if ( ! m_destination Filename . equals ( _ STR ) ) { crl . set Output File ( new  File ( m_destination Filename ) ) ; } m_ Exp . set Result Listener ( crl ) ; } } m_ Results Destination Path TField . set Text ( str ) ; m_ Support . fire Property Change ( _ STR , null , null ) ; }
public static  Input Stream try Gzip Input (  Input Stream in ) throws  IOException { if ( ! in . mark Supported ( ) ) {  Pushback Input Stream pb = new  Pushback Input Stream ( in , _ NUM ) ; in = pb ; byte [ ] magic = { _ NUM , _ NUM } ; pb . read ( magic ) ; pb . unread ( magic ) ; if ( magic [ _ NUM ] == _ NUM && magic [ _ NUM ] == - _ NUM ) { return new  GZIPInput Stream ( pb ) ; } return in ; } in . mark ( _ NUM ) ; boolean isgzip = ( in . read ( ) == _ NUM && in . read ( ) == - _ NUM ) ; in . reset ( ) ; if ( isgzip ) { in = new  GZIPInput Stream ( in ) ; } return in ; }
@  Override public int hash Code ( ) { if ( location != null ) return location . hash Code ( ) ; else return _ NUM ; }
public static  Query new Prefix Query (  String field ,  Inet Address value , int prefix Length ) { if ( value == null ) { throw new  Illegal Argument Exception ( _ STR ) ; } if ( prefix Length < _ NUM || prefix Length > _ NUM * value . get Address ( ) . length ) { throw new  Illegal Argument Exception ( _ STR + prefix Length + _ STR ) ; } byte lower [ ] = value . get Address ( ) ; byte upper [ ] = value . get Address ( ) ; for ( int i = prefix Length ; i < _ NUM * lower . length ; i ++ ) { int m = _ NUM << ( _ NUM - ( i & _ NUM ) ) ; lower [ i > > _ NUM ] &= ~ m ; upper [ i > > _ NUM ] |= m ; } try { return new Range Query ( field ,  Inet Address . get By Address ( lower ) ,  Inet Address . get By Address ( upper ) ) ; } catch (  Unknown Host Exception e ) { throw new  Assertion Error ( e ) ; } }
public static  Subject create AMIdentity Subject (  Policy Manager pm ,  AMIdentity user ) throws  Policy Exception {  Subject Type Manager mgr = pm . get Subject Type Manager ( ) ;  Subject subject = mgr . get Subject ( _ STR ) ;  Set <  String > set = new  Hash Set <  String > ( ) ; set . add ( user . get Universal Id ( ) ) ; subject . set Values ( set ) ; return subject ; }
protected void expand For ( int index , double d ) { if ( index < size ) return ; int old Size = size , capacity = vector . length ; size = index + _ NUM ; if ( capacity >= size ) return ; while ( capacity < size ) capacity *= _ NUM ; double [ ] t = new double [ capacity ] ;  System . arraycopy ( vector , _ NUM , t , _ NUM , old Size ) ; if ( d != _ NUM )  Arrays . fill ( t , old Size , size , d ) ; vector = t ; }
private void do Normal Command Line List (  List <  String > command Line List ,  List <  String > joint Options ,  Path classpath ) { command Line List . add ( _ STR ) ; command Line List . add ( classpath . to String ( ) ) ; if ( joint Compilation ) { command Line List . add ( _ STR ) ; command Line List . add All ( joint Options ) ; } if ( dest Dir != null ) { command Line List . add ( _ STR ) ; command Line List . add ( dest Dir . get Path ( ) ) ; } if ( encoding != null ) { command Line List . add ( _ STR ) ; command Line List . add ( encoding ) ; } if ( stacktrace ) { command Line List . add ( _ STR ) ; } if ( parameters ) { command Line List . add ( _ STR ) ; } if ( use Indy ) { command Line List . add ( _ STR ) ; } if ( script Base Class != null ) { command Line List . add ( _ STR ) ; command Line List . add ( script Base Class ) ; } if ( configscript != null ) { command Line List . add ( _ STR ) ; command Line List . add ( configscript ) ; } }
private synchronized void load Hex Image (  IHex hex ) { hex Tileset . assign Match ( hex , boardview ) ; hex Tileset . track Hex Images ( hex , tracker ) ; }
public  String base64 Url Encode ( byte [ ] data ) {  String encoded Data = new  String (  Base64 . encode ( data ,  Base64 .  URL_ SAFE ) ) ; encoded Data = encoded Data . replace ( _ STR , _ STR ) ; encoded Data = encoded Data . replace ( _ STR , _ STR ) ; return encoded Data ; }
private void write Java Field Spec (  Java Field Spec spec ,  Document document ,  Element parent Element ) {  Element parameter = document . create Element ( _ STR ) ; parameter . append Child ( parent Element ) ; parameter . set Attribute ( _ STR , spec . get Package Name ( ) ) ; parameter . set Attribute ( _ STR , spec . get Class Name ( ) ) ; parameter . set Attribute ( _ STR , spec . get Field Name ( ) ) ; }
private void read Object (  Object Input Stream s ) throws  IOException ,  Class Not Found Exception { s . default Read Object ( ) ; init ( get Mask ( actions ) ) ; }
@  Override public synchronized void parse (  Reader reader ,  String base URI ) throws  IOException ,  RDFParse Exception ,  RDFHandler Exception { if ( reader == null ) { throw new  Illegal Argument Exception ( _ STR ) ; } if ( base URI == null ) { throw new  Illegal Argument Exception ( _ STR ) ; }  Input Source input Source = new  Input Source ( reader ) ; input Source . set System Id ( base URI ) ; parse ( input Source ) ; }
private  String exclude Destination Statement (  String text ) { int idx = - _ NUM ; if ( ( idx = text . index Of ( _ STR ) ) != - _ NUM ) { text = text . substring ( _ NUM , idx ) ; } return text ; }
public static void add File (  String s ) throws  IOException {  File f = new  File ( s ) ; add File ( f ) ; }
@  Safe Varargs public final void insert ( int row Index ,  T ... new Items ) { insert ( row Index ,  Arrays . as List ( new Items ) ) ; }
@  Deprecated public void put (  Collection <  Integer > data ) { for (  Integer value : data ) { final int val = value . int Value ( ) ; min = val < min ? val : min ; max = val > max ? val : max ; } }
public  Int Buffer major Version Buffer ( ) { int [ ] holder = new int [ _ NUM ] ; holder [ _ NUM ] = get Major Version ( ) ;  Int Buffer ib =  Int Buffer . wrap ( holder ) ; ib . limit ( _ NUM ) ; return ib ; }
public  Create Index Request source (  XContent Builder source ) { return source ( source . bytes ( ) ) ; }
public static byte [ ] create Data To Sign ( byte [ ] digest ) { byte [ ] prefix = get Digest Info Prefix ( digest ) ; byte [ ] digest Info = new byte [ prefix . length + digest . length ] ;  System . arraycopy ( prefix , _ NUM , digest Info , _ NUM , prefix . length ) ;  System . arraycopy ( digest , _ NUM , digest Info , prefix . length , digest . length ) ; return digest Info ; }
public  Http Request if Modified Since ( final long value ) { connection . set If Modified Since ( value ) ; return this ; }
public static  String tmp Journal ( ) { final  File file =  Code . wrap Throw ( null ) ; file . delete On Exit ( ) ; return file . get Absolute Path ( ) ; }
public static  Object new Instance (  Class < ? > cl , int [ ] dims ) { if ( dims . length == _ NUM ) { dims = new int [ ] { _ NUM } ; } return  Array . new Instance ( cl , dims ) ; }
protected static void print Error Message (  Exception e ) { if ( e instanceof  Abort Exception ) {  Logging Configuration . set Verbose (  Level .  VERBOSE ) ;  LOG . verbose ( e . get Message ( ) ) ; } else if ( e instanceof  Unspecified Parameter Exception ) {  LOG . error ( e . get Message ( ) ) ; } else if ( e instanceof  Parameter Exception ) {  LOG . error ( e . get Message ( ) ) ; } else {  LOG . exception ( e ) ; } }
public  String request Statistics ( ) { sb . set Length ( _ NUM ) ; make String Buffer ( sb ) ; return sb . to String ( ) ; }
private void apply L1 Reg ( final double eta_t ,  Vec x ) { if ( lambda1 > _ NUM ) { l1 U += eta_t * lambda1 ; for ( int k = _ NUM ; k < ws . length ; k ++ ) { final  Vec w_k = ws [ k ] ; final double [ ] l1 Q_k = l1 Q [ k ] ; for (  Index Value iv : x ) { final int i = iv . get Index ( ) ; final double z = w_k . get ( i ) ; double new W_i = _ NUM ; if ( z > _ NUM ) new W_i =  Math . max ( _ NUM , z - ( l1 U + l1 Q_k [ i ] ) ) ; else if ( z < _ NUM ) new W_i =  Math . min ( _ NUM , z + ( l1 U - l1 Q_k [ i ] ) ) ; l1 Q_k [ i ] += ( new W_i - z ) ; w_k . set ( i , new W_i ) ; } } } }
@  Override public void key Pressed (  Key Event e ) { synchronized ( key Lock ) { keys Down . add ( e . get Key Code ( ) ) ; } }
public static  String slurp URLNo Exceptions (  URL u ,  String encoding ) { try { return slurp URL ( u , encoding ) ; } catch (  Exception e ) { e . print Stack Trace ( ) ; return null ; } }
public static  Move Participant [ ] load Move Participants (  Refactoring Status status ,  Refactoring Processor processor ,  Object element ,  Move Arguments arguments ,  IParticipant Descriptor Filter filter ,  String [ ] affected Natures ,  Sharable Participants shared ) {  Refactoring Participant [ ] participants = fg Move Extensions . get Participants ( status , processor , element , arguments , filter , affected Natures , shared ) ;  Move Participant [ ] result = new  Move Participant [ participants . length ] ;  System . arraycopy ( participants , _ NUM , result , _ NUM , participants . length ) ; return result ; }
private long [ ] determine Preference Vector (  Relation <  V > relation ,  Modifiable DBIDs [ ] neighbor IDs ,  String Builder msg ) { if ( strategy . equals (  Strategy .  APRIORI ) ) { return determine Preference Vector By Apriori ( relation , neighbor IDs , msg ) ; } else if ( strategy . equals (  Strategy .  MAX_ INTERSECTION ) ) { return determine Preference Vector By Max Intersection ( neighbor IDs , msg ) ; } else { throw new  Illegal State Exception ( _ STR ) ; } }
private void paint Foreground Disabled (  Graphics2 D g , int width , int height ) {  Shape s = decode Arrow Path ( width , height ) ; g . set Paint ( disabled Color ) ; g . fill ( s ) ; }
private void on User ( @  Not Null  TLAbs User abs User ) {  User current User = null ;  User user = null ; if ( abs User instanceof  TLUser ) { final  TLUser tl User = (  TLUser ) abs User ; if ( tl User . is Mutual Contact ( ) ) { current User = (  User ) database Manager . get User By Id ( tl User . get Id ( ) ) ; user = on User Contact ( current User , tl User ) ; } else if ( tl User . is Deleted ( ) ) { current User = (  User ) database Manager . get User By Id ( tl User . get Id ( ) ) ; user = on User Delete ( current User , tl User ) ; } else if ( tl User . is Contact ( ) ) { current User = (  User ) database Manager . get User By Id ( tl User . get Id ( ) ) ; user = on User Request ( current User , tl User ) ; } else if ( tl User . is Self ( ) || ! tl User . is Bot ( ) ) { current User = (  User ) database Manager . get User By Id ( tl User . get Id ( ) ) ; user = on User Foreign ( current User , tl User ) ; } else {  Bot Logger . info (  LOGTAG , _ STR ) ; } } if ( ( current User == null ) && ( user != null ) ) { database Manager . add User ( user ) ; } else if ( user != null ) { database Manager . update User ( user ) ; } }
@  Override public boolean has Next ( ) { log . log (  Level .  FINE , _ STR ) ; boolean result = ( next Event != null ) ; log . log (  Level .  FINE , _ STR , result ) ; return result ; }
@  Override public void close ( ) { try { if ( connection != null ) { connection . close ( ) ; } } catch (  SQLException e ) { e . print Stack Trace ( ) ; } }
private void initialize (  Model Validator validator ,  MClient client ) { if ( client == null ) m_global Validators . add ( validator ) ; m_validators . add ( validator ) ; validator . initialize ( this , client ) ; }
void cross Over (  Bayes Net Representation other ) { boolean [ ] bits = new boolean [ m_bits . length ] ; for ( int i = _ NUM ; i < m_bits . length ; i ++ ) { bits [ i ] = m_bits [ i ] ; } int i Cross Over Point = m_bits . length ; do { for ( int i = i Cross Over Point ; i < m_bits . length ; i ++ ) { m_bits [ i ] = bits [ i ] ; } i Cross Over Point = m_random . next Int ( m_bits . length ) ; for ( int i = i Cross Over Point ; i < m_bits . length ; i ++ ) { m_bits [ i ] = other . m_bits [ i ] ; } } while ( has Cycles ( ) ) ; calc Global Score ( ) ; }
public void reset ( ) { engine Reset ( ) ; state =  INITIAL ; }
public  Perspective create User Perspective ( final  String name , final boolean show ) {  Perspective perspective = model . add Perspective ( name , _ BOOL ) ; perspective . store ( context ) ; if ( show ) { show Perspective ( name ) ; } return perspective ; }
public static double phred ( double error ) { return - _ NUM *  Math . log10 ( error ) ; }
@  Safe Varargs public final  Token <  Token Type > expect (  Token Type ... expected ) throws  Simple Parser Exception { if ( has Type ( expected ) ) return this ; throw new  Simple Parser Exception ( line , column , _ STR +  Arrays . to String ( expected ) + _ STR + to String ( ) ) ; }
public void test Set Null ( ) throws  Exception {  Prepared Statement stmt = connection . prepare Statement ( _ STR ) ; try { stmt . set Int ( _ NUM , _ NUM ) ; stmt . set Bytes ( _ NUM , null ) ; stmt . execute Update ( ) ; stmt . set Int ( _ NUM , _ NUM ) ; stmt . set Binary Stream ( _ NUM , null , _ NUM ) ; stmt . execute Update ( ) ; stmt . set Int ( _ NUM , _ NUM ) ; stmt . set String ( _ NUM , null ) ; stmt . execute Update ( ) ; } finally { stmt . close ( ) ; } }
Eg Demand Details insert Penalty ( final  Big Decimal chq Bounce Penalty , final  Module module ) {  Eg Demand Details demand Detail = null ; if ( chq Bounce Penalty != null && chq Bounce Penalty . compare To (  Big Decimal .  ZERO ) > _ NUM ) { final  Installment curr Installment = get Current Installment ( module ) ; final  Eg Demand Reason Master eg Demand Reason Master = demand Generic Dao . get Demand Reason Master By Code (  DEMANDRSN_ CODE_ CHQ_ BOUNCE_ PENALTY , module ) ; if ( eg Demand Reason Master == null ) throw new  Application Runtime Exception ( _ STR ) ; final  Eg Demand Reason eg Demand Reason = demand Generic Dao . get Dmd Reason By Dmd Reason Mster Install And Mod ( eg Demand Reason Master , curr Installment , module ) ; if ( eg Demand Reason == null ) throw new  Application Runtime Exception ( _ STR ) ; demand Detail =  Eg Demand Details . from Reason And Amounts ( chq Bounce Penalty , eg Demand Reason ,  Big Decimal .  ZERO ) ; } return demand Detail ; }
public  Sample Info (  Byte Buffer bb ) throws  IOException { number Of Channels = bb . get Int ( ) ; sample Rate = bb . get Int ( ) ; coeff Min = bb . get Float ( ) ; coeff Range = bb . get Float ( ) ; post Emphasis = bb . get Float ( ) ; residual Fold = bb . get Int ( ) ; }
public void handle Maintenance (  Operation maint Op ) { perform Pending Request Maintenance ( ) ; check And Schedule Synchronization ( this . cached Group State . membership Update Time Micros ) ; maint Op . complete ( ) ; }
public <  T >  T time (  Callable <  T > event ) throws  Exception { final long start Time = clock . tick ( ) ; try { return event . call ( ) ; } finally { update ( clock . tick ( ) - start Time ) ; } }
public static boolean is Post JDK7 (  String bytecode Version ) { return  JDK7 . equals ( bytecode Version ) ||  JDK8 . equals ( bytecode Version ) ; }
public  Put Index Template Request mapping (  String type ,  Object ... source ) { mapping ( type ,  Put Mapping Request . build From Simplified Def ( type , source ) ) ; return this ; }
private  Input Stream find Template (  String path ,  String template ) { try {  File file = new  File ( path , template ) ; if ( file . can Read ( ) ) { return new  Buffered Input Stream ( new  File Input Stream ( file . get Absolute Path ( ) ) ) ; } else { return null ; } } catch (  File Not Found Exception fnfe ) { return null ; } }
public void add Listener (  Circular Progress View Listener listener ) { if ( listener != null ) listeners . add ( listener ) ; }
public  Site Status Check Thread Impl ( ) { super ( ) ; url Checkers = new  Hash Map ( ) ; }
@  Override public void render ( final int type , final  Graphics2 D g2 , final float scaling , final boolean is Form Glyph ) { glyph Display . set Scaling Values ( _ NUM , _ NUM , scaling ) ; final float  OLDglyph Scale = glyph Scale ; if ( is Form Glyph ) { glyph Scale = scaling * glyph Scale ; }  Affine Transform aff = null ; if ( glyph Scale != _ NUM ) { aff = g2 . get Transform ( ) ; g2 . scale ( glyph Scale , glyph Scale ) ; } glyph Display . set G2 ( g2 ) ; glyph Display . paint ( null , null , null ) ; if ( aff != null ) { g2 . set Transform ( aff ) ; } glyph Scale =  OLDglyph Scale ; }
public  List <  String > reset (  List <  String > replace ) {  Array List <  String > copy = new  Array List <  String > ( retained Vars . size ( ) ) ; copy . add All ( retained Vars ) ; retained Vars . clear ( ) ; if ( replace != null ) { retained Vars . add All ( replace ) ; } return copy ; }
protected void release ( ) {  App Context temp App Context = null ; synchronized ( grab Release Synchronizer ) { if ( usage Count > _ NUM ) { -- usage Count ; } else { synchronized ( thread Group Synchronizer ) { temp App Context = reset App Context ( ) ; } } } if ( temp App Context != null ) { try { temp App Context . dispose ( ) ; } catch (  Illegal Thread State Exception e ) { } } }
public synchronized void delete All Tables ( ) {  List <  String > table Names = new  Array List <  String > ( table Lookup . key Set ( ) ) ; for (  String s : table Names ) { delete Table ( s ) ; } }
public  Pet Category find One (  String id ) { log . debug ( _ STR , id ) ;  Pet Category pet Category = pet Category Repository . find One (  UUID . from String ( id ) ) ; return pet Category ; }
private void mark Removed Default Session Token (  String site ,  String token ) { if ( removed Default Tokens == null ) removed Default Tokens = new  Hash Map < > ( _ NUM ) ;  Hash Set <  String > removed Set = removed Default Tokens . get ( site ) ; if ( removed Set == null ) { removed Set = new  Hash Set < > ( _ NUM ) ; removed Default Tokens . put ( site , removed Set ) ; } removed Set . add ( token ) ; }
private  Map <  URI ,  Map <  URI ,  Map <  String ,  List <  URI > > > > create Device To CGMap From Descriptors (  List <  Volume Descriptor > add Descriptors ,  List <  Volume Descriptor > remove Descriptors ) {  Map <  URI ,  Map <  URI ,  Map <  String ,  List <  URI > > > > device To CGMap = new  Hash Map <  URI ,  Map <  URI ,  Map <  String ,  List <  URI > > > > ( ) ; for (  Volume Descriptor descr : add Descriptors ) {  URI device URI = descr . get Device URI ( ) ;  Map <  URI ,  Map <  String ,  List <  URI > > > volumes To Update By CG = device To CGMap . get ( device URI ) ; if ( volumes To Update By CG == null ) { volumes To Update By CG = new  Hash Map <  URI ,  Map <  String ,  List <  URI > > > ( ) ; device To CGMap . put ( device URI , volumes To Update By CG ) ; }  URI consistency Group URI = descr . get Consistency Group URI ( ) ;  Map <  String ,  List <  URI > > volumes To Update = volumes To Update By CG . get ( consistency Group URI ) ; if ( volumes To Update == null ) { volumes To Update = new  Hash Map <  String ,  List <  URI > > ( ) ; volumes To Update By CG . put ( consistency Group URI , volumes To Update ) ; }  List <  URI > volumes To Add = volumes To Update . get (  ADD_ VOLUMES_ TO_ CG_ KEY ) ; if ( volumes To Add == null ) { volumes To Add = new  Array List <  URI > ( ) ; volumes To Update . put (  ADD_ VOLUMES_ TO_ CG_ KEY , volumes To Add ) ; } volumes To Add . add ( descr . get Volume URI ( ) ) ; } for (  Volume Descriptor descr : remove Descriptors ) {  URI device URI = descr . get Device URI ( ) ;  Map <  URI ,  Map <  String ,  List <  URI > > > volumes To Update By CG = device To CGMap . get ( device URI ) ; if ( volumes To Update By CG == null ) { volumes To Update By CG = new  Hash Map <  URI ,  Map <  String ,  List <  URI > > > ( ) ; device To CGMap . put ( device URI , volumes To Update By CG ) ; }  URI consistency Group URI = descr . get Consistency Group URI ( ) ;  Map <  String ,  List <  URI > > volumes To Update = volumes To Update By CG . get ( consistency Group URI ) ; if ( volumes To Update == null ) { volumes To Update = new  Hash Map <  String ,  List <  URI > > ( ) ; volumes To Update By CG . put ( consistency Group URI , volumes To Update ) ; }  List <  URI > volumes To Remove = volumes To Update . get (  REMOVE_ VOLUMES_ FROM_ CG_ KEY ) ; if ( volumes To Remove == null ) { volumes To Remove = new  Array List <  URI > ( ) ; volumes To Update . put (  REMOVE_ VOLUMES_ FROM_ CG_ KEY , volumes To Remove ) ; } volumes To Remove . add ( descr . get Volume URI ( ) ) ; } return device To CGMap ; }
public  Exchange ( final  Request request , final  Origin origin ) { this . current Request = request ; this . origin = origin ; this . timestamp =  System . current Time Millis ( ) ; }
public static final  File Time unix Time To File Time ( long utime ) { return  File Time . from ( utime ,  Time Unit .  SECONDS ) ; }
public void remove Address (  Address Entity address ) { addresses . remove ( address ) ; }
private boolean verify Migrate From Product Home (  String migrate From Product Home ) throws  Install Exception { if ( migrate From Product Home == null || migrate From Product Home . length ( ) == _ NUM ) {  Debug . log ( _ STR + _ STR ) ;  Console . println (  Localized Message . get (  LOC_ HR_ MSG_ MIGRATE_ NONE_ FOUND ) ) ; return _ BOOL ; } if ( ! migrate From Product Home . equals (  Config Util . get Home Path ( ) ) ) {  Debug . log ( _ STR + _ STR + migrate From Product Home + _ STR +  Config Util . get Home Path ( ) ) ;  String translate File = migrate From Product Home +  Migrate From Inst Finder Store . get Relative Translate File ( ) ; if ( !  File Utils . is File Valid ( translate File ) ) {  Console . println (  Localized Message . get (  LOC_ HR_ MSG_ MIGRATE_ NONE_ FOUND ) ) ; return _ BOOL ; } } else {  Debug . log ( _ STR + _ STR ) ; throw new  Install Exception (  Localized Message . get (  LOC_ DR_ ERR_ PRODUCT_ ALREADY_ MIGRATED ) ) ; } return _ BOOL ; }
public static  String format (  String message ,  Object [ ] arguments ) { return  Message Format . format ( message , arguments ) ; }
private void insert Prosody Settings (  Utterance utterance ,  Element element ) {  Element prosody = (  Element )  Dom Utils . get Ancestor ( element ,  Mary XML .  PROSODY ) ; if ( prosody == null ) { return ; }  Element voice = (  Element )  Dom Utils . get Ancestor ( element ,  Mary XML .  VOICE ) ; if ( voice != null &&  Dom Utils . is Ancestor ( prosody , voice ) ) { return ; }  Element paragraph = (  Element )  Dom Utils . get Ancestor ( element ,  Mary XML .  PARAGRAPH ) ; if ( paragraph != null &&  Dom Utils . is Ancestor ( prosody , paragraph ) ) { return ; } for (  String att :  PROSODY_ ATTRIBUTES ) {  String val = prosody . get Attribute ( att ) ; if ( ! val . equals ( _ STR ) ) { utterance . set String ( att , val ) ; } } }
public static boolean create Folder ( @  Suppress Warnings ( _ STR )  Context m Context ,  String path ,  String folder Name ) {  File  SDCard Root = new  File ( path , folder Name ) ; if ( !  SDCard Root . exists ( ) ) { return  SDCard Root . mkdir ( ) ; } return _ BOOL ; }
private void add Protocol If Not Exists (  Set <  String > protocols ,  String protocol Type ) { if ( ! protocols . contains ( protocol Type ) ) { protocols . add ( protocol Type ) ; } }
void add (  Object key ) { table . put ( key , key ) ; }
public  Configuration load Config From Resource (  Resource resource ) {  Properties Configuration result = new  Properties Configuration ( ) ; try { result . load ( resource . get Input Stream ( ) ) ; return result ; } catch (  Configuration Exception |  IOException e ) {  LOG . error (  CONFIGURATION_ LOAD_ ERROR . format ( resource . get Filename ( ) ) , e ) ; throw new  System Config Exception (  CONFIGURATION_ LOAD_ ERROR . format ( resource . get Filename ( ) ) , e ) ; } }
public final void log (  String filename , int line Number ,  String method ,  String tag , int level ,  String message ) { final  Log Message lm = new  Log Message (  Log Message .  LOGMSG_ TYPE_ LOG , next Sequence Number . get And Increment ( ) ) ; lm . add Int16 ( level ,  Log Message .  PART_ KEY_ LEVEL ) ; if ( filename != null ) { lm . add String ( filename ,  Log Message .  PART_ KEY_ FILENAME ) ; if ( line Number != _ NUM ) lm . add Int32 ( line Number ,  Log Message .  PART_ KEY_ LINENUMBER ) ; } if ( method != null ) lm . add String ( method ,  Log Message .  PART_ KEY_ FUNCTIONNAME ) ; if ( tag != null && ! tag . is Empty ( ) ) lm . add String ( tag ,  Log Message .  PART_ KEY_ TAG ) ; lm . add String ( message ,  Log Message .  PART_ KEY_ MESSAGE ) ; log ( lm ) ; }
protected  Size2 D draw Vertical (  Graphics2 D g2 ,  Rectangle2 D chart Area ) { double start X ; double top Space = _ NUM ; double bottom Space = _ NUM ; double left Space = _ NUM ; double right Space = _ NUM ; double w = get Width ( ) ; double h = get Height ( ) ;  Rectangle Insets padding = get Padding ( ) ; if ( padding != null ) { top Space = padding . calculate Top Outset ( h ) ; bottom Space = padding . calculate Bottom Outset ( h ) ; left Space = padding . calculate Left Outset ( w ) ; right Space = padding . calculate Right Outset ( w ) ; } if ( get Position ( ) ==  Rectangle Edge .  LEFT ) { start X = chart Area . get X ( ) + left Space ; } else { start X = chart Area . get Max X ( ) - right Space - w ; }  Vertical Alignment alignment = get Vertical Alignment ( ) ; double start Y = _ NUM ; if ( alignment ==  Vertical Alignment .  CENTER ) { start Y = chart Area . get Min Y ( ) + top Space + chart Area . get Height ( ) / _ NUM - h / _ NUM ; } else if ( alignment ==  Vertical Alignment .  TOP ) { start Y = chart Area . get Min Y ( ) + top Space ; } else if ( alignment ==  Vertical Alignment .  BOTTOM ) { start Y = chart Area . get Max Y ( ) - bottom Space - h ; } g2 . draw Image ( this . image , ( int ) start X , ( int ) start Y , ( int ) w , ( int ) h , null ) ; return new  Size2 D ( chart Area . get Width ( ) + left Space + right Space , h + top Space + bottom Space ) ; }
private static final  Public Key construct Public Key ( byte [ ] encoded Key ,  String encoded Key Algorithm ) throws  Invalid Key Exception ,  No Such Algorithm Exception {  Public Key key = null ; try {  Key Factory key Factory =  Key Factory . get Instance ( encoded Key Algorithm ,  Sun JCE . get Instance ( ) ) ;  X509 Encoded Key Spec key Spec = new  X509 Encoded Key Spec ( encoded Key ) ; key = key Factory . generate Public ( key Spec ) ; } catch (  No Such Algorithm Exception nsae ) { try {  Key Factory key Factory =  Key Factory . get Instance ( encoded Key Algorithm ) ;  X509 Encoded Key Spec key Spec = new  X509 Encoded Key Spec ( encoded Key ) ; key = key Factory . generate Public ( key Spec ) ; } catch (  No Such Algorithm Exception nsae2 ) { throw new  No Such Algorithm Exception ( _ STR + _ STR + encoded Key Algorithm + _ STR ) ; } catch (  Invalid Key Spec Exception ikse2 ) {  Invalid Key Exception ike = new  Invalid Key Exception ( _ STR ) ; ike . init Cause ( ikse2 ) ; throw ike ; } } catch (  Invalid Key Spec Exception ikse ) {  Invalid Key Exception ike = new  Invalid Key Exception ( _ STR ) ; ike . init Cause ( ikse ) ; throw ike ; } return key ; }
public static boolean expression Is True ( double left Side ,  Operator operator , double right Side ) { final  String expression = left Side + operator . get Mathematical Operator ( ) + right Side ; return expression Is True ( expression ) ; }
@  Override public  Completable Future <  Optional <  T > > max ( final  Comparator < ? super  T > comparator ) { return  Completable Future . supply Async ( null , exec ) ; }
final public void println ( char v ) {  Writer out = this . out ; if ( out == null ) return ; try { out . write ( v ) ; out . write ( _newline , _ NUM , _newline . length ) ; } catch (  IOException e ) { log . log (  Level .  FINE , e . to String ( ) , e ) ; } }
public void test_write_correct Rejection_empty Record ( ) { final  IRaw Store store = get Store ( ) ; try { try { store . write (  Byte Buffer . wrap ( new byte [ ] { } ) ) ; fail ( _ STR +  Illegal Argument Exception . class ) ; } catch (  Illegal Argument Exception ex ) { if ( log . is Info Enabled ( ) ) log . info ( _ STR + ex ) ; } try { final  Byte Buffer buf =  Byte Buffer . wrap ( new byte [ _ NUM ] ) ; buf . position ( buf . limit ( ) ) ; store . write ( buf ) ; fail ( _ STR +  Illegal Argument Exception . class ) ; } catch (  Illegal Argument Exception ex ) { if ( log . is Info Enabled ( ) ) log . info ( _ STR + ex ) ; } } finally { store . destroy ( ) ; } }
public synchronized void commit ( ) { synchronized ( mutex ) {  Map <  Column ,  Set <  Interval > > temp = working Intervals ; working Intervals =  Collections . synchronized Map ( new  Linked Hash Map < > ( ) ) ; available Intervals Ref . set (  Collections . unmodifiable Map ( new  Linked Hash Map < > ( temp ) ) ) ; super . columns = new  Linked Hash Set < > ( temp . key Set ( ) ) ; } }
public static  String extract Indent String (  String line , int tab Width , int indent Width ) { if ( tab Width < _ NUM || indent Width < _ NUM || line == null ) { throw new  Illegal Argument Exception ( ) ; } int size = line . length ( ) ; int end = _ NUM ; int space Equivs = _ NUM ; int characters = _ NUM ; for ( int i = _ NUM ; i < size ; i ++ ) { char c = line . char At ( i ) ; if ( c == _ STR ) { space Equivs = calculate Space Equivalents ( tab Width , space Equivs ) ; characters ++ ; } else if ( is Indent Char ( c ) ) { space Equivs ++ ; characters ++ ; } else { break ; } if ( space Equivs >= indent Width ) { end += characters ; characters = _ NUM ; if ( indent Width == _ NUM ) { space Equivs = _ NUM ; } else { space Equivs = space Equivs % indent Width ; } } } if ( end == _ NUM ) { return  Util .  EMPTY_ STRING ; } else if ( end == size ) { return line ; } else { return line . substring ( _ NUM , end ) ; } }
private void pre Insert (  Mk Max Entry q ,  Mk Max Entry node Entry ,  KNNHeap knns_q ) { if (  LOG . is Debugging ( ) ) {  LOG . debug Fine ( _ STR + q + _ STR + node Entry + _ STR ) ; } double knn Dist_q = knns_q . get KNNDistance ( ) ;  Mk Max Tree Node <  O > node = get Node ( node Entry ) ; double knn Dist_node = _ NUM ; if ( node . is Leaf ( ) ) { for ( int i = _ NUM ; i < node . get Num Entries ( ) ; i ++ ) {  Mk Max Entry p = node . get Entry ( i ) ; double dist_pq = distance ( p . get Routing Object ID ( ) , q . get Routing Object ID ( ) ) ; if ( dist_pq <= knn Dist_q ) { knns_q . insert ( dist_pq , p . get Routing Object ID ( ) ) ; if ( knns_q . size ( ) >= get Kmax ( ) ) { knn Dist_q = knns_q . get KNNDistance ( ) ; q . set Knn Distance ( knn Dist_q ) ; } } if ( dist_pq <= p . get Knn Distance ( ) ) {  KNNList knns_p = knnq . get KNNFor DBID ( p . get Routing Object ID ( ) , get Kmax ( ) - _ NUM ) ; if ( knns_p . size ( ) + _ NUM < get Kmax ( ) ) { p . set Knn Distance (  Double .  Na N ) ; } else { double knn Dist_p =  Math . max ( dist_pq , knns_p . get KNNDistance ( ) ) ; p . set Knn Distance ( knn Dist_p ) ; } } knn Dist_node =  Math . max ( knn Dist_node , p . get Knn Distance ( ) ) ; } } else {  List <  Double Int Pair > entries = get Sorted Entries ( node , q . get Routing Object ID ( ) ) ; for (  Double Int Pair dist Entry : entries ) {  Mk Max Entry dir Entry = node . get Entry ( dist Entry . second ) ; double entry_knn Dist = dir Entry . get Knn Distance ( ) ; if ( dist Entry . second < entry_knn Dist || dist Entry . second < knn Dist_q ) { pre Insert ( q , dir Entry , knns_q ) ; knn Dist_q = knns_q . get KNNDistance ( ) ; } knn Dist_node =  Math . max ( knn Dist_node , dir Entry . get Knn Distance ( ) ) ; } } if (  LOG . is Debugging ( ) ) {  LOG . debug Fine ( node Entry + _ STR + knn Dist_node ) ; } node Entry . set Knn Distance ( knn Dist_node ) ; }
private static boolean add If Matches (  List <  String > container ,  String status Line , char x , char y ) { if ( matches ( status Line , x , y ) ) { final  String filename = status Line . substring ( _ NUM ) ; if ( ! container . contains ( filename ) ) { container . add ( filename ) ; } return _ BOOL ; } return _ BOOL ; }
public static  String encode From String (  String plain ,  String charset ) throws  Coder Exception ,  Unsupported Encoding Exception { return encode ( plain . get Bytes ( charset ) ) ; }
public void slide (  SLIDE slide ) { if ( slide ==  SLIDE .  UP ) { if ( ! is Panel Shown ( ) ) { int position = _ NUM ; if ( items != null ) { position = items . size ( ) / _ NUM ; } slide Up ( position ) ; } } else { hide Panel Picker UI ( ) ; } }
public boolean is Debugging Finest ( ) { return logger . is Loggable (  Level .  FINEST ) ; }
private static void sort1 ( int [ ] x , int off , int len ) { if ( len < _ NUM ) { for ( int i = off ; i < len + off ; i ++ ) for ( int j = i ; j > off && x [ j - _ NUM ] > x [ j ] ; j -- ) swap ( x , j , j - _ NUM ) ; return ; } int m = off + ( len > > _ NUM ) ; if ( len > _ NUM ) { int l = off ; int n = off + len - _ NUM ; if ( len > _ NUM ) { int s = len / _ NUM ; l = med3 ( x , l , l + s , l + _ NUM * s ) ; m = med3 ( x , m - s , m , m + s ) ; n = med3 ( x , n - _ NUM * s , n - s , n ) ; } m = med3 ( x , l , m , n ) ; } int v = x [ m ] ; int a = off , b = a , c = off + len - _ NUM , d = c ; while ( _ BOOL ) { while ( b <= c && x [ b ] <= v ) { if ( x [ b ] == v ) swap ( x , a ++ , b ) ; b ++ ; } while ( c >= b && x [ c ] >= v ) { if ( x [ c ] == v ) swap ( x , c , d -- ) ; c -- ; } if ( b > c ) break ; swap ( x , b ++ , c -- ) ; } int s , n = off + len ; s =  Math . min ( a - off , b - a ) ; vecswap ( x , off , b - s , s ) ; s =  Math . min ( d - c , n - d - _ NUM ) ; vecswap ( x , b , n - s , s ) ; if ( ( s = b - a ) > _ NUM ) sort1 ( x , off , s ) ; if ( ( s = d - c ) > _ NUM ) sort1 ( x , n - s , s ) ; }
public void reset ( ) { ns . remove All Elements ( ) ; ks . set Length ( _ NUM ) ; cur = tt . root ; run ( ) ; }
@  Layoutlib Delegate static float sin ( float angle ) { return ( float )  Math . sin ( angle ) ; }
public static void render Flattened Annotation ( final  Pdf Object form , final  Dynamic Vector Renderer current , final int page Number , final int rotation ) { final  Buffered Image image =  Annotation Factory . get Icon ( form ) ; if ( image != null ) { final  Graphics State gs = new  Graphics State ( ) ; final int icon Height = image . get Height ( ) ; final int icon Width = image . get Width ( ) ; final float [ ] rect = form . get Float Array (  Pdf Dictionary .  Rect ) ; if ( form . get Parameter Constant (  Pdf Dictionary .  Subtype ) ==  Pdf Dictionary .  Text ) { rect [ _ NUM ] = rect [ _ NUM ] + icon Width ; rect [ _ NUM ] = rect [ _ NUM ] - icon Height ; form . set Float Array (  Pdf Dictionary .  Rect , rect ) ; } switch ( rotation % _ NUM ) { case _ NUM : gs .  CTM = new float [ ] [ ] { { icon Width , _ NUM , _ NUM } , { _ NUM , icon Height , _ NUM } , { _ NUM , _ NUM , _ NUM } } ; gs . x = rect [ _ NUM ] ; gs . y = rect [ _ NUM ] - icon Height ; gs .  CTM [ _ NUM ] [ _ NUM ] = rect [ _ NUM ] ; gs .  CTM [ _ NUM ] [ _ NUM ] = rect [ _ NUM ] - icon Height ; break ; case _ NUM : gs .  CTM = new float [ ] [ ] { { _ NUM , icon Width , _ NUM } , { - icon Height , _ NUM , _ NUM } , { _ NUM , _ NUM , _ NUM } } ; gs . x = rect [ _ NUM ] + icon Height ; gs . y = rect [ _ NUM ] ; gs .  CTM [ _ NUM ] [ _ NUM ] = rect [ _ NUM ] + icon Height ; gs .  CTM [ _ NUM ] [ _ NUM ] = rect [ _ NUM ] ; break ; case _ NUM : gs .  CTM = new float [ ] [ ] { { - icon Width , _ NUM , _ NUM } , { _ NUM , - icon Height , _ NUM } , { _ NUM , _ NUM , _ NUM } } ; gs . x = rect [ _ NUM ] ; gs . y = rect [ _ NUM ] + icon Height ; gs .  CTM [ _ NUM ] [ _ NUM ] = rect [ _ NUM ] ; gs .  CTM [ _ NUM ] [ _ NUM ] = rect [ _ NUM ] + icon Height ; break ; case _ NUM : gs .  CTM = new float [ ] [ ] { { _ NUM , - icon Width , _ NUM } , { icon Height , _ NUM , _ NUM } , { _ NUM , _ NUM , _ NUM } } ; gs . x = rect [ _ NUM ] - icon Height ; gs . y = rect [ _ NUM ] ; gs .  CTM [ _ NUM ] [ _ NUM ] = rect [ _ NUM ] - icon Height ; gs .  CTM [ _ NUM ] [ _ NUM ] = rect [ _ NUM ] ; break ; } if ( form . get Parameter Constant (  Pdf Dictionary .  Subtype ) ==  Pdf Dictionary .  Highlight ) { current . set Graphics State (  Graphics State .  STROKE , gs . get Alpha (  Graphics State .  STROKE ) ,  Pdf Dictionary .  Darken ) ; current . set Graphics State (  Graphics State .  FILL , gs . get Alpha (  Graphics State .  FILL ) ,  Pdf Dictionary .  Darken ) ; } current . draw Image ( page Number , image , gs , _ BOOL , form . get Object Ref As String ( ) , - _ NUM ) ; if ( form . get Parameter Constant (  Pdf Dictionary .  Subtype ) ==  Pdf Dictionary .  Highlight ) { current . set Graphics State (  Graphics State .  STROKE , gs . get Alpha (  Graphics State .  STROKE ) ,  Pdf Dictionary .  Normal ) ; current . set Graphics State (  Graphics State .  FILL , gs . get Alpha (  Graphics State .  FILL ) ,  Pdf Dictionary .  Normal ) ; } } }
public byte [ ] extract Data ( byte [ ] stego Data ,  String stego File Name , byte [ ] orig Sig Data ) throws  Open Stego Exception { return null ; }
public static  String make Related Session ID (  String encrypted ID ,  Session ID prototype ) throws  Session Exception { prototype . parse Session String ( ) ; return make Session ID ( encrypted ID , prototype . get Extension ( ) , prototype . tail ) ; }
public static  Automaton determinize (  Automaton a , int max Determinized States ) { if ( a . is Deterministic ( ) ) { return a ; } if ( a . get Num States ( ) <= _ NUM ) { return a ; }  Automaton .  Builder b = new  Automaton .  Builder ( ) ;  Sorted Int Set .  Frozen Int Set initialset = new  Sorted Int Set .  Frozen Int Set ( _ NUM , _ NUM ) ; b . create State ( ) ;  Linked List <  Sorted Int Set .  Frozen Int Set > worklist = new  Linked List < > ( ) ;  Map <  Sorted Int Set .  Frozen Int Set ,  Integer > newstate = new  Hash Map < > ( ) ; worklist . add ( initialset ) ; b . set Accept ( _ NUM , a . is Accept ( _ NUM ) ) ; newstate . put ( initialset , _ NUM ) ; final  Point Transition Set points = new  Point Transition Set ( ) ; final  Sorted Int Set states Set = new  Sorted Int Set ( _ NUM ) ;  Transition t = new  Transition ( ) ; while ( worklist . size ( ) > _ NUM ) {  Sorted Int Set .  Frozen Int Set s = worklist . remove First ( ) ; for ( int i = _ NUM ; i < s . values . length ; i ++ ) { final int s0 = s . values [ i ] ; int num Transitions = a . get Num Transitions ( s0 ) ; a . init Transition ( s0 , t ) ; for ( int j = _ NUM ; j < num Transitions ; j ++ ) { a . get Next Transition ( t ) ; points . add ( t ) ; } } if ( points . count == _ NUM ) { continue ; } points . sort ( ) ; int last Point = - _ NUM ; int acc Count = _ NUM ; final int r = s . state ; for ( int i = _ NUM ; i < points . count ; i ++ ) { final int point = points . points [ i ] . point ; if ( states Set . upto > _ NUM ) { assert last Point != - _ NUM ; states Set . compute Hash ( ) ;  Integer q = newstate . get ( states Set ) ; if ( q == null ) { q = b . create State ( ) ; if ( q >= max Determinized States ) { throw new  Too Complex To Determinize Exception ( a , max Determinized States ) ; } final  Sorted Int Set .  Frozen Int Set p = states Set . freeze ( q ) ; worklist . add ( p ) ; b . set Accept ( q , acc Count > _ NUM ) ; newstate . put ( p , q ) ; } else { assert ( acc Count > _ NUM ? _ BOOL : _ BOOL ) == b . is Accept ( q ) : _ STR + acc Count + _ STR + b . is Accept ( q ) + _ STR + states Set ; } b . add Transition ( r , q , last Point , point - _ NUM ) ; } int [ ] transitions = points . points [ i ] . ends . transitions ; int limit = points . points [ i ] . ends . next ; for ( int j = _ NUM ; j < limit ; j += _ NUM ) { int dest = transitions [ j ] ; states Set . decr ( dest ) ; acc Count -= a . is Accept ( dest ) ? _ NUM : _ NUM ; } points . points [ i ] . ends . next = _ NUM ; transitions = points . points [ i ] . starts . transitions ; limit = points . points [ i ] . starts . next ; for ( int j = _ NUM ; j < limit ; j += _ NUM ) { int dest = transitions [ j ] ; states Set . incr ( dest ) ; acc Count += a . is Accept ( dest ) ? _ NUM : _ NUM ; } last Point = point ; points . points [ i ] . starts . next = _ NUM ; } points . reset ( ) ; assert states Set . upto == _ NUM : _ STR + states Set . upto ; }  Automaton result = b . finish ( ) ; assert result . is Deterministic ( ) ; return result ; }
private boolean find Root ( final  ODEState Interpolator interpolator , final double ta , final double ga , final double tb , final double gb ) { check ( ga == _ NUM || gb == _ NUM || ( ga > _ NUM && gb < _ NUM ) || ( ga < _ NUM && gb > _ NUM ) ) ; final  Univariate Function f = null ; double before Root T =  Double .  Na N , before Root G =  Double .  Na N ; double after Root T = ta , after Root G = _ NUM ; if ( ta == tb ) { before Root T = ta ; before Root G = ga ; after Root T = shifted By ( before Root T , convergence ) ; after Root G = f . value ( after Root T ) ; } else if ( ga != _ NUM && gb == _ NUM ) { before Root T = tb ; before Root G = gb ; after Root T = shifted By ( before Root T , convergence ) ; after Root G = f . value ( after Root T ) ; } else if ( ga != _ NUM ) { final double new Ga = f . value ( ta ) ; if ( ga > _ NUM != new Ga > _ NUM ) { before Root T = ta ; before Root G = new Ga ; after Root T = min Time ( shifted By ( before Root T , convergence ) , tb ) ; after Root G = f . value ( after Root T ) ; } } double loop T = ta , loop G = ga ; while ( ( after Root G == _ NUM || after Root G > _ NUM == g0 Positive ) && strictly After ( after Root T , tb ) ) { if ( loop G == _ NUM ) { before Root T = loop T ; before Root G = loop G ; after Root T = min Time ( shifted By ( before Root T , convergence ) , tb ) ; after Root G = f . value ( after Root T ) ; } else { if ( forward ) { final  Interval interval = solver . solve Interval ( max Iteration Count , f , loop T , tb ) ; before Root T = interval . get Left Abscissa ( ) ; before Root G = interval . get Left Value ( ) ; after Root T = interval . get Right Abscissa ( ) ; after Root G = interval . get Right Value ( ) ; } else { final  Interval interval = solver . solve Interval ( max Iteration Count , f , tb , loop T ) ; before Root T = interval . get Right Abscissa ( ) ; before Root G = interval . get Right Value ( ) ; after Root T = interval . get Left Abscissa ( ) ; after Root G = interval . get Left Value ( ) ; } } if ( before Root T == after Root T ) { after Root T = next After ( after Root T ) ; after Root G = f . value ( after Root T ) ; } check ( ( forward && after Root T > before Root T ) || ( ! forward && after Root T < before Root T ) ) ; loop T = after Root T ; loop G = after Root G ; } if ( after Root G == _ NUM || after Root G > _ NUM == g0 Positive ) { return _ BOOL ; } else { check ( !  Double . is Na N ( before Root T ) && !  Double . is Na N ( before Root G ) ) ; increasing = ! g0 Positive ; pending Event Time = before Root T ; stop Time = before Root G == _ NUM ? before Root T : after Root T ; pending Event = _ BOOL ; after Event = after Root T ; after G = after Root G ; check ( after G > _ NUM == increasing ) ; check ( increasing == gb >= ga ) ; return _ BOOL ; } }
public static int compare (  Comparable c1 ,  Comparable c2 , boolean null Greater ) { if ( c1 == c2 ) { return _ NUM ; } else if ( c1 == null ) { return ( null Greater ? _ NUM : - _ NUM ) ; } else if ( c2 == null ) { return ( null Greater ? - _ NUM : _ NUM ) ; } return c1 . compare To ( c2 ) ; }
public boolean check Root By Super User Apk ( ) {  File su Apk = new  File (  SU_ APK ) ; if ( su Apk != null && su Apk . exists ( ) ) { return _ BOOL ; } return _ BOOL ; }
int add Expression (  Expression expression ) ;
public static <  E >  E sync Rest ( final  Iterator < ? extends  Object > iterator , final  Callable <  E > task ) throws  Exception { if ( iterator . has Next ( ) ) { synchronized ( iterator . next ( ) ) { return sync Rest ( iterator , task ) ; } } else { return task . call ( ) ; } }
private static  Component find By Name (  Container root ,  String component Name ) { if ( verbose ) { log ( _ STR + root + _ STR + component Name + _ STR ) ; } int count = root . get Component Count ( ) ; for ( int iter = _ NUM ; iter < count ; iter ++ ) {  Component c = root . get Component At ( iter ) ;  String n = c . get Name ( ) ; if ( n != null && n . equals ( component Name ) ) { return c ; } if ( c instanceof  Container ) { c = find By Name ( (  Container ) c , component Name ) ; if ( c != null ) { return c ; } } } return null ; }
public boolean is Fingerprint (  Class Template class Template ) { return fingerprint Class . equals ( class Template . get Implementing Class ( ) ) ; }
public void write Field ( final  String name , final float value ) throws java . io .  IOException { write Field ( name ,  Float . to String ( value ) ) ; }
private  List extract Column Keys (  String line ) {  List keys = new java . util .  Array List ( ) ; int field Index = _ NUM ; int start = _ NUM ; for ( int i = _ NUM ; i < line . length ( ) ; i ++ ) { if ( line . char At ( i ) == this . field Delimiter ) { if ( field Index > _ NUM ) {  String key = line . substring ( start , i ) ; keys . add ( remove String Delimiters ( key ) ) ; } start = i + _ NUM ; field Index ++ ; } }  String key = line . substring ( start , line . length ( ) ) ; keys . add ( remove String Delimiters ( key ) ) ; return keys ; }
protected void draw Rhombus ( int x , int y , int w , int h ,  Color fill Color ,  Paint fill Paint ,  Color pen Color , boolean shadow ) { int half Width = w / _ NUM ; int half Height = h / _ NUM ;  Polygon rhombus = new  Polygon ( ) ; rhombus . add Point ( x + half Width , y ) ; rhombus . add Point ( x + w , y + half Height ) ; rhombus . add Point ( x + half Width , y + h ) ; rhombus . add Point ( x , y + half Height ) ; draw Polygon ( rhombus , fill Color , fill Paint , pen Color , shadow ) ; }
static  Object instantiate (  Class < ? > sibling ,  String class Name ) throws  Instantiation Exception ,  Illegal Access Exception ,  Class Not Found Exception {  Class Loader cl = sibling . get Class Loader ( ) ;  Class < ? > cls =  Class Finder . find Class ( class Name , cl ) ; return cls . new Instance ( ) ; }
public synchronized void show (  Bundle options ) { if (  DEBUG )  Log . d (  TAG , _ STR + m Keyguard View ) ; boolean enable Screen Rotation = should Enable Screen Rotation ( ) ; maybe Create Keyguard Locked ( enable Screen Rotation , _ BOOL , options ) ; maybe Enable Screen Rotation ( enable Screen Rotation ) ; final int vis Flags =  View .  STATUS_ BAR_ DISABLE_ HOME ; if (  DEBUG )  Log . v (  TAG , _ STR +  Integer . to Hex String ( vis Flags ) + _ STR ) ; m Keyguard Host . set System Ui Visibility ( vis Flags ) ; m View Manager . update View Layout ( m Keyguard Host , m Window Layout Params ) ; m Keyguard Host . set Visibility (  View .  VISIBLE ) ; m Keyguard View . show ( ) ; m Keyguard View . request Focus ( ) ; }
public static int compute String Width (  Font Metrics fm ,  String str ) { return  Swing Utilities2 . string Width ( null , fm , str ) ; }
private boolean passes Sanity Check (  Accessibility Event event ) { final  Char Sequence after Text = get Event Text ( event ) ; final  Char Sequence before Text = event . get Before Text ( ) ; if ( ( event . get Added Count ( ) == _ NUM ) && ( event . get Removed Count ( ) == before Text . length ( ) ) ) { return _ BOOL ; } if ( after Text == null || before Text == null ) { return _ BOOL ; } final int diff = ( event . get Added Count ( ) - event . get Removed Count ( ) ) ; return ( ( before Text . length ( ) + diff ) == after Text . length ( ) ) ; }
public void action Performed (  Action Event ae ) {  String command = ae . get Action Command ( ) ; if ( command ==  Display Palette Cmd ) { if (  Debug . debugging ( _ STR ) ) {  Debug . output ( get Name ( ) + _ STR ) ; } show Palette ( ) ; } else if ( command ==  Hide Palette Cmd ) { if (  Debug . debugging ( _ STR ) ) {  Debug . output ( get Name ( ) + _ STR ) ; } hide Palette ( ) ; } else if ( command ==  Display Properties Cmd ) {  Inspector inspector = new  Inspector ( ) ; inspector . inspect Property Consumer ( this ) ; } }
public static  String to String (  Local Date data ) { return data == null ? _ STR : data . format ( formatter ( _ STR ) ) ; }
@  Json Creator public  Data Source Metadata ( @  Json Property ( _ STR )  String name , @  Json Property ( _ STR )  Map <  String ,  String > properties , @  Json Property ( _ STR )  List <  Data Segment > segments ) { this . name = name ; this . properties =  Collections . unmodifiable Map ( properties ) ; this . segments =  Collections . unmodifiable List ( segments ) ; }
public  EMail create EMail (  String value ) {  Email Field email Impl = new  Email Field ( ) ; try { email Impl . set Value ( value ) ; } catch (  Sdp Exception s ) { s . print Stack Trace ( ) ; } return email Impl ; }
public  Address Lookup (  String server Url ,  String serial No ,  String password ) { this . server Url = server Url . trim ( ) ; this . client ID = serial No . trim ( ) ; this . access Code = password . trim ( ) ; }
public  Node (  String permission , boolean value , boolean override , long expire At ,  String server ,  String world ,  Context Set contexts ) { if ( permission == null || permission . equals ( _ STR ) ) { throw new  Illegal Argument Exception ( _ STR ) ; } if ( server != null && ( server . equals Ignore Case ( _ STR ) || server . equals ( _ STR ) ) ) { server = null ; } if ( world != null && world . equals ( _ STR ) ) { world = null ; } if ( world != null && server == null ) { server = _ STR ; } this . permission = permission ; this . value = value ; this . override = override ; this . expire At = expire At ; this . server = server ; this . world = world ; this . contexts = contexts == null ?  Context Set . empty ( ) : contexts . make Immutable ( ) ; }
public  Cell ( int rowspan , int colspan ) { this . rowspan =  Math . max ( rowspan , _ NUM ) ; this . colspan =  Math . max ( colspan , _ NUM ) ; }
private void initialize Local And Target Info ( ) throws  Exception { target Site Info = coordinator . get Target Info (  Site Info . class ) ; if ( target Site Info == null ) { target Site Info = new  Site Info ( ) ; try { coordinator . set Target Info ( target Site Info , _ BOOL ) ; log . info ( _ STR , target Site Info ) ; } catch (  Coordinator Client Exception e ) { log . info ( _ STR ) ; retry Sleep ( ) ; throw e ; } } local Vdc Prop Info = local Repository . get Vdc Property Info ( ) ;  String local Config Version = local Vdc Prop Info . get Property (  Vdc Config Util .  VDC_ CONFIG_ VERSION ) ; coordinator . set Node Session Scope Info ( new  Vdc Config Version ( local Config Version ) ) ; target Vdc Prop Info = load Vdc Config ( ) ; if ( is Geo Upgrade From Pre Yoda ( ) ) { log . info ( _ STR ) ; local Vdc Prop Info . add Property (  Vdc Config Util .  VDC_ CONFIG_ VERSION ,  String . value Of ( target Site Info . get Vdc Config Version ( ) ) ) ; local Repository . set Vdc Property Info ( local Vdc Prop Info ) ; } else { if ( local Vdc Prop Info . get Property (  Vdc Config Util .  VDC_ CONFIG_ VERSION ) == null ) { local Vdc Prop Info = new  Property Info Ext ( target Vdc Prop Info . get All Properties ( ) ) ; local Vdc Prop Info . add Property (  Vdc Config Util .  VDC_ CONFIG_ VERSION ,  String . value Of ( target Site Info . get Vdc Config Version ( ) ) ) ; local Repository . set Vdc Property Info ( local Vdc Prop Info ) ;  String vdc_ids = target Vdc Prop Info . get Property (  Vdc Config Util .  VDC_ IDS ) ;  String [ ] vdc Ids = vdc_ids . split ( _ STR ) ; if ( vdc Ids . length > _ NUM ) { log . info ( _ STR ) ; reboot ( ) ; } } } target Power Off State = coordinator . get Target Info (  Power Off State . class ) ; if ( target Power Off State == null ) { try { coordinator . set Target Info ( new  Power Off State (  Power Off State .  State .  NONE ) ) ; target Power Off State = coordinator . get Target Info (  Power Off State . class ) ; log . info ( _ STR ,  Power Off State .  State .  NONE ) ; } catch (  Coordinator Client Exception e ) { log . info ( _ STR ) ; retry Sleep ( ) ; throw e ; } } }
@  Override public void open Element (  String tag Name ) {  XMLElement new Element = new  XMLElement ( ) ; new Element . set Name ( tag Name ) ; current . add Child ( new Element ) ; stack . push ( current ) ; current = new Element ; }
public  Format (  String p Format String ) {  String format Vars [ ] = p Format String . split ( _ STR ) ; m Id =  Integer . parse Int ( format Vars [ _ NUM ] ) ; }
public boolean equals (  Object interval ) { if ( intervals == null ) { return _ BOOL ; } return intervals . contains ( interval ) ; }
public static  String relative To Absolute (  String base URL ,  String relative URL ) { if ( relative URL . starts With ( _ STR ) ) { return get URLProtocol ( base URL ) + _ STR + get URLHost ( base URL ) + relative URL ; } else { return get URLProtocol ( base URL ) + _ STR + get URLHost ( base URL ) + get URLBase Path ( base URL ) + relative URL ; } }
public void start ( ) { if ( set State (  Enum Set . of (  Task State .  INITIAL ,  Task State .  QUEUED ) ,  Task State .  RUNNING ) ) {  DHT . log Debug ( _ STR + to String ( ) ) ; start Time =  System . current Time Millis ( ) ; try { serialized Update . run ( ) ; } catch (  Exception e ) {  DHT . log ( e ,  Log Level .  Error ) ; } } }
public  Journal Index ( final  IRaw Store store , final  Checkpoint checkpoint , final  Index Metadata metadata , final boolean read Only ) { super ( store , checkpoint , metadata , read Only ) ; }
private void acces Breakpoint Instruction (  Array List <  Instruction > instructions , int line Number , int op ,  BPINSTRUCTION_ STATUS status ) { for ( int i = _ NUM ; i < instructions . size ( ) ; i ++ ) {  Instruction curr Inst = instructions . get ( i ) ; if ( op == _ NUM ) { if ( curr Inst instanceof  MRJob Instruction ) {  MRJob Instruction curr MRInst = (  MRJob Instruction ) curr Inst ; if ( curr MRInst . find MRInstructions ( line Number ) ) {  Break Point Instruction breakpoint = new  Break Point Instruction ( ) ; breakpoint . set Location ( curr Inst ) ; breakpoint . set Inst ID ( inst ID ++ ) ; breakpoint . set BPInstruction Location ( location ) ; instructions . add ( i , breakpoint ) ;  DMLBreakpoint Manager . insert Breakpoint ( breakpoint , line Number ) ; return ; } } else if ( curr Inst instanceof  CPInstruction || curr Inst instanceof  SPInstruction ) { if ( curr Inst . get Line Num ( ) == line Number ) {  Break Point Instruction breakpoint = new  Break Point Instruction ( ) ; breakpoint . set Location ( curr Inst ) ; breakpoint . set Inst ID ( inst ID ++ ) ; breakpoint . set BPInstruction Location ( location ) ; instructions . add ( i , breakpoint ) ;  DMLBreakpoint Manager . insert Breakpoint ( breakpoint , line Number ) ; return ; } } else if ( curr Inst instanceof  Break Point Instruction && curr Inst . get Line Num ( ) == line Number ) {  Break Point Instruction breakpoint = (  Break Point Instruction ) curr Inst ; breakpoint . set BPInstruction Status (  BPINSTRUCTION_ STATUS .  ENABLED ) ; breakpoint . set BPInstruction Location ( location ) ; instructions . set ( i , breakpoint ) ;  DMLBreakpoint Manager . update Breakpoint ( line Number , status ) ; return ; } } else { if ( curr Inst instanceof  Break Point Instruction && curr Inst . get Line Num ( ) == line Number ) { if ( op == _ NUM ) {  Break Point Instruction breakpoint = (  Break Point Instruction ) curr Inst ; breakpoint . set Location ( curr Inst ) ; breakpoint . set Inst ID ( curr Inst . get Inst ID ( ) ) ; breakpoint . set BPInstruction Status ( status ) ; breakpoint . set BPInstruction Location ( location ) ; instructions . set ( i , breakpoint ) ;  DMLBreakpoint Manager . update Breakpoint ( line Number , status ) ; } else { instructions . remove ( i ) ;  DMLBreakpoint Manager . remove Breakpoint ( line Number , status ) ; } return ; } } } }
private void close File ( ) { if ( plog Stream != null ) { try { plog Stream . close ( ) ; logger . info ( _ STR + plog Filename + _ STR ) ; } catch (  IOException e ) { logger . warn ( _ STR + plog Filename ) ; } finally { plog Stream = null ; } } }
private void parse First Consonant ( ) {  Iterator iter = al First Consonants . iterator ( ) ; while ( iter . has Next ( ) ) {  String str First Con = (  String ) iter . next ( ) ; if ( str Syllable . starts With ( str First Con , i Cur Pos ) ) { str First Consonant = str First Con ; i Cur Pos += str First Con . length ( ) ; return ; } } str First Consonant =  ZERO ; }
private  Buddy Panel Controller ( ) { buddy Panel = new  JPanel ( ) ; buddy Panel . set Layout ( new  SBox Layout (  SBox Layout .  VERTICAL ) ) ; model = new  Buddy List Model ( ) ;  JList <  Buddy > list = new  Buddy Panel ( model ) ; buddy Panel . add ( list ,  SLayout .  EXPAND_ X ) ; }
private void remove Gaps With Edge Concentration ( int nodes Level [ ] ) { final int temp = m_nodes . size ( ) , temp2 = graph Matrix [ _ NUM ] . length ; int temp Cnt = _ NUM ; for ( int n = _ NUM ; n < temp ; n ++ ) { for ( int i = _ NUM ; i < temp2 ; i ++ ) { if ( graph Matrix [ n ] [ i ] > _ NUM ) { if ( nodes Level [ i ] > nodes Level [ n ] + _ NUM ) { int temp Level = nodes Level [ n ] ; boolean temp Node Present = _ BOOL ; int k = temp ; int tempnode = n ; while ( temp Level < nodes Level [ i ] - _ NUM ) { temp Node Present = _ BOOL ; for ( ; k < graph Matrix . length ; k ++ ) { if ( graph Matrix [ tempnode ] [ k ] > _ NUM ) { temp Node Present = _ BOOL ; break ; } } if ( temp Node Present ) { tempnode = k ; k = k + _ NUM ; temp Level ++ ; } else { if ( tempnode != n ) { tempnode = k - _ NUM ; } break ; } } if ( m_nodes . get ( tempnode ) . node Type ==  SINGULAR_ DUMMY ) { m_nodes . get ( tempnode ) . node Type =  PLURAL_ DUMMY ; } if ( temp Node Present ) { graph Matrix [ tempnode ] [ i ] = graph Matrix [ n ] [ i ] ; graph Matrix [ i ] [ tempnode ] = - graph Matrix [ n ] [ i ] ; graph Matrix [ n ] [ i ] = _ NUM ; graph Matrix [ i ] [ n ] = _ NUM ; continue ; } int len = graph Matrix . length ; int temp Matrix [ ] [ ] = new int [ graph Matrix . length + ( nodes Level [ i ] - nodes Level [ tempnode ] - _ NUM ) ] [ graph Matrix . length + ( nodes Level [ i ] - nodes Level [ tempnode ] - _ NUM ) ] ; int level = nodes Level [ tempnode ] + _ NUM ; copy Matrix ( graph Matrix , temp Matrix ) ;  String s1 = new  String ( _ STR + temp Cnt ++ ) ; m_nodes . add ( new  Graph Node ( s1 , s1 ,  SINGULAR_ DUMMY ) ) ; int temp3 [ ] = new int [ node Levels [ level ] . length + _ NUM ] ;  System . arraycopy ( node Levels [ level ] , _ NUM , temp3 , _ NUM , node Levels [ level ] . length ) ; temp3 [ temp3 . length - _ NUM ] = m_nodes . size ( ) - _ NUM ; node Levels [ level ] = temp3 ; temp3 = new int [ m_nodes . size ( ) + _ NUM ] ;  System . arraycopy ( nodes Level , _ NUM , temp3 , _ NUM , nodes Level . length ) ; temp3 [ m_nodes . size ( ) - _ NUM ] = level ; nodes Level = temp3 ; level ++ ; int m ; for ( m = len ; m < len + nodes Level [ i ] - nodes Level [ tempnode ] - _ NUM - _ NUM ; m ++ ) {  String s2 = new  String ( _ STR + temp Cnt ++ ) ; m_nodes . add ( new  Graph Node ( s2 , s2 ,  SINGULAR_ DUMMY ) ) ; temp3 = new int [ node Levels [ level ] . length + _ NUM ] ;  System . arraycopy ( node Levels [ level ] , _ NUM , temp3 , _ NUM , node Levels [ level ] . length ) ; temp3 [ temp3 . length - _ NUM ] = m_nodes . size ( ) - _ NUM ; node Levels [ level ] = temp3 ; temp3 = new int [ m_nodes . size ( ) + _ NUM ] ;  System . arraycopy ( nodes Level , _ NUM , temp3 , _ NUM , nodes Level . length ) ; temp3 [ m_nodes . size ( ) - _ NUM ] = level ; nodes Level = temp3 ; level ++ ; temp Matrix [ m ] [ m + _ NUM ] = temp Matrix [ n ] [ i ] ; if ( m > len ) { temp Matrix [ m ] [ m - _ NUM ] = - _ NUM * temp Matrix [ n ] [ i ] ; } } temp Matrix [ m ] [ i ] = temp Matrix [ n ] [ i ] ; temp Matrix [ tempnode ] [ len ] = temp Matrix [ n ] [ i ] ; temp Matrix [ len ] [ tempnode ] = - _ NUM * temp Matrix [ n ] [ i ] ; temp Matrix [ i ] [ m ] = - _ NUM * temp Matrix [ n ] [ i ] ; if ( m > len ) { temp Matrix [ m ] [ m - _ NUM ] = - _ NUM * temp Matrix [ n ] [ i ] ; } temp Matrix [ n ] [ i ] = _ NUM ; temp Matrix [ i ] [ n ] = _ NUM ; graph Matrix = temp Matrix ; } else { graph Matrix [ i ] [ n ] = - _ NUM * graph Matrix [ n ] [ i ] ; } } } } }
public static  Test Result exec Javac (  String to Compile ,  File dir ,  String jflex Test Version ) {  Project p = new  Project ( ) ;  Javac javac = new  Javac ( ) ;  Path path = new  Path ( p , dir . to String ( ) ) ; javac . set Project ( p ) ; javac . set Srcdir ( path ) ; javac . set Destdir ( dir ) ; javac . set Target ( java Version ) ; javac . set Source ( java Version ) ; javac . set Sourcepath ( new  Path ( p , _ STR ) ) ; javac . set Includes ( to Compile ) ;  Path class Path = javac . create Classpath ( ) ; class Path . set Path (  System . get Property ( _ STR ) + _ STR + jflex Test Version + _ STR + jflex Test Version + _ STR ) ;  Byte Array Output Stream out = new  Byte Array Output Stream ( ) ;  Print Stream out Safe =  System . err ;  System . set Err ( new  Print Stream ( out ) ) ; try { javac . execute ( ) ; return new  Test Result ( out . to String ( ) , _ BOOL ) ; } catch (  Build Exception e ) { return new  Test Result ( e +  System . get Property ( _ STR ) + out . to String ( ) , _ BOOL ) ; } finally {  System . set Err ( out Safe ) ; } }
public static  CLPlatform [ ] list GPUPowered Platforms ( ) {  CLPlatform [ ] platforms = list Platforms ( ) ;  List <  CLPlatform > out = new  Array List <  CLPlatform > ( platforms . length ) ; for (  CLPlatform platform : platforms ) { if ( platform . list GPUDevices ( _ BOOL ) . length > _ NUM ) out . add ( platform ) ; } return out . to Array ( new  CLPlatform [ out . size ( ) ] ) ; }
public  Action Request Helper depends On (  Action Request Helper dependency ) { m Dependencies . add ( dependency ) ; return this ; }
static boolean is Date (  Object obj ) { return obj instanceof  Date && obj . get Class ( ) ==  Date . class ; }
public static  String to Xml ( final  Config to Convert ,  Boolean pretty Xml ) throws  JAXBException ,  IOException {  String ret Val = _ STR ; try (  String Writer writer = new  String Writer ( ) ) { to Xml ( to Convert , writer , pretty Xml ) ; ret Val = writer . to String ( ) ; return ret Val ; } }
private static  List <  Vector2 D > build Quadrilateral ( final  Vector2 D ... points ) {  List <  Vector2 D > quadrilateral = new  Array List <  Vector2 D > ( ) ; for (  Vector2 D p : points ) { if ( ! quadrilateral . contains ( p ) ) { quadrilateral . add ( p ) ; } } return quadrilateral ; }
private void heapify Up ( int twopos ,  Comparable <  Object > cur ) { while ( twopos > _ NUM ) { final int parent = ( twopos - _ NUM ) > > > _ NUM ;  Comparable <  Object > par = twoheap [ parent ] ; if ( cur . compare To ( par ) <= _ NUM ) { break ; } twoheap [ twopos ] = par ; twopos = parent ; } twoheap [ twopos ] = cur ; }
public void insert (  String key , char val ) { int len = key . length ( ) + _ NUM ; if ( freenode + len > eq . length ) { redim Node Arrays ( eq . length +  BLOCK_ SIZE ) ; } char strkey [ ] = new char [ len -- ] ; key . get Chars ( _ NUM , len , strkey , _ NUM ) ; strkey [ len ] = _ NUM ; root = insert ( root , strkey , _ NUM , val ) ; }
void write (  Environment env ,  Data Output Stream out ,  Constant Pool tab ) throws  IOException { out . write Byte (  CONSTANT_ NAMEANDTYPE ) ; out . write Short ( tab . index ( name ) ) ; out . write Short ( tab . index ( type ) ) ; }
public static void initialize Properties (  Properties properties , boolean reset , boolean with Defaults ) {  Properties default Prop = null ; if ( with Defaults ) {  SSOToken app Token =  Access Controller . do Privileged (  Admin Token Action . get Instance ( ) ) ; default Prop =  Server Configuration . get Defaults ( app Token ) ; }  Properties Holder old Props ;  Properties Holder new Props ; do { old Props = properties Holder Ref . get ( ) ; final  Properties combined = new  Properties ( ) ; if ( default Prop != null ) { combined . put All ( default Prop ) ; } if ( ! reset ) { combined . put All ( old Props . properties ) ; } combined . put All ( properties ) ; new Props = new  Properties Holder (  Maps . from Properties ( combined ) ) ; } while ( ! properties Holder Ref . compare And Set ( old Props , new Props ) ) ; }
public void add Network Listener ( final  Network Listener listener ) { network Listeners . add ( listener ) ; }
public static void append Content Prefix (  Http Servlet Request request ,  Appendable url Buffer ) throws  IOException { append Content Prefix ( request , url Buffer , null ) ; }
public void add Error Listener ( final  Error Listener error Listener ) { if ( error Listeners == null ) { error Listeners = new  Array List <  Error Listener > ( ) ; } error Listeners . add ( error Listener ) ; }
private void validate Class Name (  String class Name ) {  String nvalue = class Name . trim ( ) ; if ( ! nvalue . matches (  CLASS_ RE ) ) { throw  Property Exception . illegal Property Value Exception ( this , class Name ) ; } }
public static void import Base Types ( final  CConnection connection , final int raw Module Id , final int module Id ) throws  SQLException { final  String query = _ STR +  CTable Names .  BASE_ TYPES_ TABLE + _ STR + module Id + _ STR + _ STR +  String . format (  CTable Names .  RAW_ BASE_ TYPES , raw Module Id ) ; connection . execute Update ( query , _ BOOL ) ; final  String update Sequence =  String . format ( _ STR + _ STR ,  CTable Names .  BASE_ TYPES_ TABLE ,  CTable Names .  BASE_ TYPES_ TABLE ) ; connection . execute Query ( update Sequence , _ BOOL ) ; }
@  Suppress Warnings ( _ STR ) public  Object read Matrix Old (  Element node ) throws  Exception { weka . core .  Matrix matrix ; weka . core . matrix .  Matrix matrix New ; if (  DEBUG ) { trace ( new  Throwable ( ) , node . get Attribute (  ATT_ NAME ) ) ; } m_ Current Node = node ; matrix New = ( weka . core . matrix .  Matrix ) read Matrix ( node ) ; matrix = new weka . core .  Matrix ( matrix New . get Array Copy ( ) ) ; return matrix ; }
public void record File System Operation (  Db Client db Client ,  Operation Type Enum op Type ,  Operation .  Status status ,  Object ... ext Param ) { try { boolean op Status = (  Operation .  Status . ready == status ) ? _ BOOL : _ BOOL ;  String ev Type ; ev Type = op Type . get Ev Type ( op Status ) ;  String ev Desc = op Type . get Description ( ) ;  String op Stage =  Audit Log Manager .  AUDITOP_ END ; _logger . info ( _ STR , op Type . to String ( ) , ev Type . to String ( ) + _ STR + ev Desc ) ;  URI uri = (  URI ) ext Param [ _ NUM ] ; record Bourne File System Event ( db Client , ev Type , status , ev Desc , uri ) ; audit File ( db Client , op Type , op Status , op Stage , uri . to String ( ) ) ; } catch (  Exception e ) { _logger . error ( _ STR , op Type . to String ( ) , e ) ; } }
public  Core Token Exception ( int error Code ) { this . error Code = error Code ; this . message = get Localized Message (  Locale . get Default ( ) ) ; }
public  DExamine Ssl (  JFrame parent ,  Kse Frame kse Frame ) { super ( parent , res . get String ( _ STR ) ,  Dialog .  Modality Type .  DOCUMENT_ MODAL ) ; this . kse Frame = kse Frame ; init Components ( ) ; }
private static  List <  String > compute Dynamic VMArgs (  IJava Project java Project ) {  Array List <  String > out = new  Array List <  String > ( ) ;  String dev Jar Path = maybe Get Dev Jar Path ( java Project ) ; if ( dev Jar Path . length ( ) > _ NUM ) { out . add ( _ STR + dev Jar Path + _ STR ) ; } return out ; }
static void normalize (  String Builder number ) {  String normalized Number = normalize ( number . to String ( ) ) ; number . replace ( _ NUM , number . length ( ) , normalized Number ) ; }
public double [ ] skip To ( final int index ) throws  Math Illegal Argument Exception { if ( index == _ NUM ) {  Arrays . fill ( x , _ NUM ) ; } else { final int i = index - _ NUM ; final long gray Code = i ^ ( i > > _ NUM ) ; for ( int j = _ NUM ; j < dimension ; j ++ ) { long result = _ NUM ; for ( int k = _ NUM ; k <=  BITS ; k ++ ) { final long shift = gray Code > > ( k - _ NUM ) ; if ( shift == _ NUM ) { break ; } final long ik = shift & _ NUM ; result ^= ik * direction [ j ] [ k ] ; } x [ j ] = result ; } } count = index ; return next Vector ( ) ; }
public void remove Organization Configuration (  String org Name ,  String group Name , boolean check Legacy Mode ) throws  SMSException ,  SSOException { if ( ( group Name == null ) || group Name . length ( ) == _ NUM ) { group Name =  SMSUtils .  DEFAULT ; }  String orgdn =  DNMapper . org Name To DN ( org Name ) ; validate SCM ( ) ;  String odn = scm . construct Service Config DN ( group Name ,  Create Service Config .  ORG_ CONFIG_ NODE , orgdn ) ;  Cached SMSEntry c Entry =  Cached SMSEntry . get Instance ( token , odn ) ; if ( c Entry . is New Entry ( ) ) { return ; } if ( check Legacy Mode &&  Service Manager . is Coexistence Mode ( ) && group Name . equals Ignore Case (  SMSUtils .  DEFAULT ) ) {  Org Config Via AMSDK amsdk = new  Org Config Via AMSDK ( token ,  DNMapper . realm Name To AMSDKName ( orgdn ) , orgdn ) ; amsdk . unassign Service ( service Name ) ; } if ( ! c Entry . is New Entry ( ) ) {  SMSEntry entry = c Entry . get Cloned SMSEntry ( ) ; entry . delete ( token ) ; c Entry . refresh ( entry ) ; } }
public void remove Group Listener ( final  Group Listener listener ) { group Listeners . remove ( listener ) ; }
public  Set Changelog Mapping (  String source ,  String task Name , int changelog Partition Number ) { super ( source ) ; set Type (  TYPE ) ; set Key ( task Name ) ; put Message Value (  CHANGELOG_ VALUE_ KEY ,  String . value Of ( changelog Partition Number ) ) ; }
@  Override protected  String extract Key ( final  String name ) { final  String key = unescape ( name . substring ( _ NUM , name . length ( ) - _ NUM ) ) ; return key . equals ( _ STR ) ? null : key ; }
@  Suppress Warnings ( _ STR ) public static <  K ,  V > void transform String Map (  Map <  String ,  String > original ,  Map <  K ,  V > map ,  Class <  K > key Class ,  Class <  V > value Class ) throws  Preference Exception {  Method parse Key Method = find Parse Method ( key Class ) ;  Method parse Value Method = find Parse Method ( value Class ) ; if ( ( null != parse Key Method ) && ( null != parse Value Method ) ) { for (  Map .  Entry <  String ,  String > to Transform Entry : original . entry Set ( ) ) { try {  Object transformed Key = parse Key Method . invoke ( null , to Transform Entry . get Key ( ) ) ;  Object transformed Value = parse Value Method . invoke ( null , to Transform Entry . get Value ( ) ) ; if ( key Class . is Assignable From ( transformed Key . get Class ( ) ) && value Class . is Assignable From ( transformed Value . get Class ( ) ) ) { map . put ( (  K ) transformed Key , (  V ) transformed Value ) ; } } catch (  Exception e ) { throw new  Preference Exception ( _ STR + key Class . get Name ( ) + _ STR + value Class . get Name ( ) + _ STR , e ) ; } } } else if ( null == parse Key Method ) { throw new  Preference Exception ( _ STR + key Class . get Name ( ) + _ STR + value Class . get Name ( ) + _ STR + _ STR + key Class . get Name ( ) + _ STR ) ; } else { throw new  Preference Exception ( _ STR + key Class . get Name ( ) + _ STR + value Class . get Name ( ) + _ STR + _ STR + value Class . get Name ( ) + _ STR ) ; } }
public boolean grab Input ( ) { if ( grab Log . is Loggable (  Platform Logger .  Level .  FINE ) ) { grab Log . fine ( _ STR , this ) ; }  XToolkit . awt Lock ( ) ; try { if (  XAwt State . get Grab Window ( ) == this &&  XAwt State . is Manual Grab ( ) ) { grab Log . fine ( _ STR ) ; return _ BOOL ; }  XBase Window prev Grab Window =  XAwt State . get Grab Window ( ) ; final int event Mask = ( int ) (  XConstants .  Button Press Mask |  XConstants .  Button Release Mask |  XConstants .  Enter Window Mask |  XConstants .  Leave Window Mask |  XConstants .  Pointer Motion Mask |  XConstants .  Button Motion Mask ) ; final int owner Events = _ NUM ; if ( !  XToolkit . get Sun Awt Disable Grab ( ) ) { int ptr Grab =  Xlib Wrapper .  XGrab Pointer (  XToolkit . get Display ( ) , get Content Window ( ) , owner Events , event Mask ,  XConstants .  Grab Mode Async ,  XConstants .  Grab Mode Async ,  XConstants .  None , (  XWM . is Motif ( ) ?  XToolkit . arrow Cursor :  XConstants .  None ) ,  XConstants .  Current Time ) ; if ( ptr Grab !=  XConstants .  Grab Success ) {  Xlib Wrapper .  XUngrab Pointer (  XToolkit . get Display ( ) ,  XConstants .  Current Time ) ;  XAwt State . set Grab Window ( null ) ; grab Log . fine ( _ STR ) ; return _ BOOL ; } int key Grab =  Xlib Wrapper .  XGrab Keyboard (  XToolkit . get Display ( ) , get Content Window ( ) , owner Events ,  XConstants .  Grab Mode Async ,  XConstants .  Grab Mode Async ,  XConstants .  Current Time ) ; if ( key Grab !=  XConstants .  Grab Success ) {  Xlib Wrapper .  XUngrab Pointer (  XToolkit . get Display ( ) ,  XConstants .  Current Time ) ;  Xlib Wrapper .  XUngrab Keyboard (  XToolkit . get Display ( ) ,  XConstants .  Current Time ) ;  XAwt State . set Grab Window ( null ) ; grab Log . fine ( _ STR ) ; return _ BOOL ; } } if ( prev Grab Window != null ) { prev Grab Window . ungrab Input Impl ( ) ; }  XAwt State . set Grab Window ( this ) ; grab Log . fine ( _ STR ) ; return _ BOOL ; } finally {  XToolkit . awt Unlock ( ) ; } }
public  Component Manager (  Collection <  Sequence > general Seeds ) {  Set <  Sequence > seed Set = new  Linked Hash Set < > ( general Seeds . size ( ) ) ; seed Set . add All ( general Seeds ) ; this . gral Seeds =  Collections . unmodifiable Set ( seed Set ) ; gral Components = new  Sequence Collection ( seed Set ) ; }
public static byte [ ] unsynchronize ( byte [ ] aby Source ) {  Byte Array Input Stream input = new  Byte Array Input Stream ( aby Source ) ;  Byte Array Output Stream output = new  Byte Array Output Stream ( aby Source . length ) ; int count = _ NUM ; while ( input . available ( ) > _ NUM ) { int first Byte = input . read ( ) ; count ++ ; output . write ( first Byte ) ; if ( ( first Byte &  MPEGFrame Header .  SYNC_ BYTE1 ) ==  MPEGFrame Header .  SYNC_ BYTE1 ) { if ( input . available ( ) > _ NUM ) { input . mark ( _ NUM ) ; int second Byte = input . read ( ) ; if ( ( second Byte &  MPEGFrame Header .  SYNC_ BYTE2 ) ==  MPEGFrame Header .  SYNC_ BYTE2 ) { if ( logger . is Loggable (  Level .  FINEST ) ) { logger . finest ( _ STR + count ) ; } output . write ( _ NUM ) ; } else if ( second Byte == _ NUM ) { if ( logger . is Loggable (  Level .  FINEST ) ) { logger . finest ( _ STR + count ) ; } output . write ( _ NUM ) ; } input . reset ( ) ; } } } if ( ( aby Source [ aby Source . length - _ NUM ] &  MPEGFrame Header .  SYNC_ BYTE1 ) ==  MPEGFrame Header .  SYNC_ BYTE1 ) { logger . finest ( _ STR ) ; output . write ( _ NUM ) ; } return output . to Byte Array ( ) ; }
private byte [ ] calculate General Encryption Key ( byte [ ] user Password , byte [ ] first Doc Id Value , int key Bit Length , int revision , byte [ ] o Value , int p Value , boolean encrypt Metadata ) throws  General Security Exception { final byte [ ] padded Password = pad Password ( user Password ) ;  Message Digest md5 = create MD5 Digest ( ) ; md5 . reset ( ) ; md5 . update ( padded Password ) ; md5 . update ( o Value ) ; md5 . update ( ( byte ) ( p Value & _ NUM ) ) ; md5 . update ( ( byte ) ( ( p Value > > _ NUM ) & _ NUM ) ) ; md5 . update ( ( byte ) ( ( p Value > > _ NUM ) & _ NUM ) ) ; md5 . update ( ( byte ) ( p Value > > _ NUM ) ) ; if ( first Doc Id Value != null ) { md5 . update ( first Doc Id Value ) ; } if ( revision >= _ NUM && ! encrypt Metadata ) { for ( int i = _ NUM ; i < _ NUM ; ++ i ) { md5 . update ( ( byte ) _ NUM ) ; } } byte [ ] hash = md5 . digest ( ) ; final int key Len = revision == _ NUM ? _ NUM : ( key Bit Length / _ NUM ) ; final byte [ ] key = new byte [ key Len ] ; if ( revision >= _ NUM ) { for ( int i = _ NUM ; i < _ NUM ; ++ i ) { md5 . update ( hash , _ NUM , key . length ) ; digest To ( md5 , hash ) ; } }  System . arraycopy ( hash , _ NUM , key , _ NUM , key . length ) ; return key ; }
public  Message Capture ( final  Logger logger , final boolean capture Entity ) { this ( logger , capture Entity , _ BOOL ) ; }
public static final byte [ ] unzip ( byte [ ] in ) throws  IOException {  Byte Array Output Stream out Stream = new  Byte Array Output Stream (  EXPECTED_ COMPRESSION_ RATIO * in . length ) ;  GZIPInput Stream in Stream = new  GZIPInput Stream ( new  Byte Array Input Stream ( in ) ) ; byte [ ] buf = new byte [  BUF_ SIZE ] ; while ( _ BOOL ) { int size = in Stream . read ( buf ) ; if ( size <= _ NUM ) break ; out Stream . write ( buf , _ NUM , size ) ; } out Stream . close ( ) ; return out Stream . to Byte Array ( ) ; }
public static void insert Into Combo (  JCombo Box combo ,  Object item ) {  Mutable Combo Box Model model = (  Mutable Combo Box Model ) combo . get Model ( ) ; if ( model . get Size ( ) == _ NUM ) { model . insert Element At ( item , _ NUM ) ; return ; }  Object o = model . get Element At ( _ NUM ) ; if ( o . equals ( item ) ) { return ; } model . remove Element ( item ) ; model . insert Element At ( item , _ NUM ) ; combo . set Selected Index ( _ NUM ) ; }
private boolean python Error In (  String output ) { boolean is Error = _ BOOL ;  String [ ] output Multiline = output . split ( _ STR ) ;  Matcher error Matcher ; for (  String row : output Multiline ) { error Matcher = error In Last Line . matcher ( row ) ; if ( error Matcher . find ( ) == _ BOOL ) { is Error = _ BOOL ; break ; } } return is Error ; }
public void do Stress Test (  Temp Triple Store tmp ,  Inference Engine inf , int ntrials , int  D , int  N ) {  Abstract Triple Store store = inf . database ; assert Same Graphs ( tmp , store ) ; for ( int trial = _ NUM ; trial < ntrials ; trial ++ ) {  MDC . put ( _ STR , _ STR + trial ) ; retract And Assert ( inf , store , _ NUM ,  D ,  N ) ; assert Same Graphs ( tmp , store ) ;  MDC . remove ( _ STR ) ; } }
public  Set <  T > key Set ( ) { return  Collections . unmodifiable Set ( map . key Set ( ) ) ; }
public void on Start ( ) { if ( m Audio Mirror Buffer == null ) { m Audio Mirror Buffer = new byte [ _ NUM ] ; } if ( m Streamer != null ) { m Streamer . start ( ) ; } if ( m Insecure Streamer != null ) { m Insecure Streamer . start ( ) ; } }
@  Suppress Warnings ( _ STR ) public  Propagation Imp (  Stack <  Composite Transaction > lineage , boolean serial , long timeout ) { serial_ = serial ; lineage_ = (  Stack <  Composite Transaction > ) lineage . clone ( ) ; timeout_ = timeout ; }
public  Native Runner (  File eclipsec ) { this . eclipsec =  Objects . require Non Null ( eclipsec ) ; }
private static  String indent ( final int height ) { return  Core Base BOp . indent ( height ) ; }
public static  Calendar reduce Calendar (  Calendar calendar ) { calendar . set (  Calendar .  MILLISECOND , _ NUM ) ; calendar . set (  Calendar .  SECOND , _ NUM ) ; calendar . set (  Calendar .  MINUTE , _ NUM ) ; calendar . set (  Calendar .  HOUR , _ NUM ) ; calendar . set (  Calendar .  HOUR_ OF_ DAY , _ NUM ) ; return calendar ; }
public static  String surround (  String string ,  String prefix ,  String suffix ) { if ( string . starts With ( prefix ) == _ BOOL ) { string = prefix + string ; } if ( string . ends With ( suffix ) == _ BOOL ) { string += suffix ; } return string ; }
public static  Coordinate pt Not In List (  Coordinate [ ] test Pts ,  Coordinate [ ] pts ) { for ( int i = _ NUM ; i < test Pts . length ; i ++ ) {  Coordinate test Pt = test Pts [ i ] ; if ( ! is In List ( test Pt , pts ) ) return test Pt ; } return null ; }
public static  String trim Or Pad (  String str , int length , char pad Char ) {  String result ; if ( str == null ) { result = _ STR ; } else { result = str ; } if ( result . length ( ) > length ) { return result . substring ( _ NUM , length ) ; } while ( result . length ( ) < length ) { result += pad Char ; } return result ; }
void schedule To Timer Pool ( ) { if ( session Poller Pool . is Polling Enabled ( ) ) { long timeout Time = ( session . get Latest Refresh Time ( ) + ( session . get Max Idle Time ( ) * _ NUM ) ) * _ NUM ; if ( session Poller Pool . get Cache Based Polling ( ) ) { timeout Time =  Math . min ( ( session . get Latest Refresh Time ( ) + ( session . get Max Caching Time ( ) * _ NUM ) ) * _ NUM , timeout Time ) ; } reschedule If Will Time Out Before Execution ( timeout Time ) ; } else { if ( ( session Poller Pool . is Session Cleanup Enabled ( ) ) && will Expire ( session . get Max Session Time ( ) ) ) { long timeout Time = ( session . get Latest Refresh Time ( ) + ( session . get Max Session Time ( ) * _ NUM ) ) * _ NUM ; reschedule If Will Time Out Before Execution ( timeout Time ) ; } } }
public  Cipher Parameters decrypt ( byte [ ] in , int key Len ) { return decrypt ( in , _ NUM , in . length , key Len ) ; }
private static void log Os Info ( ) {  Logger . append Log ( _ STR +  Cfg . get Os ( ) ) ;  Logger . append Log ( _ STR +  Os . get Os Name ( ) ) ;  Logger . append Log ( _ STR +  Os . platform ( ) ) ;  Logger . append Log ( _ STR +  System . get Property ( _ STR ) ) ;  Logger . append Log ( _ STR +  Host Info . available Cpus ( ) ) ;  Logger . append Log ( _ STR +  Host Info . get Max Memory ( ) + _ STR ) ; }
public static byte [ ] hash (  String input ) { if ( !  Text Utils . is Empty ( input ) ) { try { byte [ ] input Bytes = input . get Bytes ( _ STR ) ; return hash ( input Bytes ) ; } catch (  Unsupported Encoding Exception e ) {  Log . e (  TAG , _ STR + input + _ STR + e . get Message ( ) , e ) ; } } return null ; }
public static  String generate Transport Zone Native Guid (  String transport Type ,  String device Type ,  String fabric Id ) { return  String . format ( _ STR , transport Type , _device Type Map . get ( device Type ) , fabric Id ) ; }
public void test Add Servlet With Name And Jsp File ( ) throws  Exception {  String xml =  WEBAPP_ TEST_ HEADER + _ STR + _ STR ;  Web Xml web Xml =  Web Xml Io . parse Web Xml ( new  Byte Array Input Stream ( xml . get Bytes ( _ STR ) ) , get Entity Resolver ( ) ) ;  Web Xml Utils . add Jsp File ( web Xml , _ STR , _ STR ) ; assert True (  Web Xml Utils . has Servlet ( web Xml , _ STR ) ) ; }
@  Override public boolean equals Value ( final  Object other ) { return  Objects . equals ( this . value , other ) ; }
public static void error (  String msg ,  Throwable t ) { debug Inst . debug (  IDebug .  ERROR , msg , t ) ; }
public void remove Event Listener (  SIPTransaction Event Listener old Listener ) { event Listeners . remove ( old Listener ) ; }
public static  Execution System new Execution System (  URI uri ,  Map <  String , ? > env ) throws  IOException { return new Execution System ( uri , env , null ) ; }
public static boolean is Command (  IElement Type type ) { return type ==  SQFTypes .  COMMAND_ TOKEN || type ==  SQFTypes .  COMMAND || type ==  SQFTypes .  CASE || type ==  SQFTypes .  CASE_ COMMAND ; }
public void send (  XTrace Report report ) { outgoing . offer ( report ) ; }
@  Contract ( pure = _ BOOL ) public static boolean starts With Concatenation ( @  Not Null  String string , @  Not Null  String ... prefixes ) { int offset = _ NUM ; for (  String prefix : prefixes ) { int prefix Len = prefix . length ( ) ; if ( ! string . region Matches ( offset , prefix , _ NUM , prefix Len ) ) { return _ BOOL ; } offset += prefix Len ; } return _ BOOL ; }
public void test Ordered By Datatype ( ) throws  Exception { int last Type =  Integer .  MIN_ VALUE ; while ( type Info Rs . next ( ) ) {  String name = type Info Rs . get String ( _ STR ) ; int type = type Info Rs . get Int ( _ STR ) ; assert True ( _ STR + type + _ STR + name + _ STR + last Type , type >= last Type ) ; last Type = type ; } }
public boolean fire Map Mouse Clicked (  Mouse Event evt ) { if (  DEBUG ) { logger . fine ( _ STR ) ; } click Happened = _ BOOL ; boolean consumed = _ BOOL ; evt = new  Map Mouse Event ( get Parent Mode ( ) , evt ) ; if ( priority Listener != null && evt . get Click Count ( ) > _ NUM ) { priority Listener . mouse Clicked ( evt ) ; consumed = _ BOOL ; } priority Listener = null ; if ( proxy == null || evt . is Shift Down ( ) || ( proxy Distribution Mask &  PROXY_ DISTRIB_ MOUSE_ CLICKED ) > _ NUM ) {  Iterator <  Map Mouse Listener > it = iterator ( ) ; while ( it . has Next ( ) && ! consumed ) {  Map Mouse Listener target = it . next ( ) ; consumed = target . mouse Clicked ( evt ) && consume Events ; if ( consumed ) { priority Listener = target ; } } } boolean ignore Consumed = ! consumed || ( consumed && ( ( proxy Distribution Mask &  PROXY_ ACK_ CONSUMED_ MOUSE_ CLICKED ) == _ NUM ) ) ; if ( proxy != null && ignore Consumed && ! evt . is Shift Down ( ) ) { proxy . mouse Clicked ( evt ) ; consumed = _ BOOL ; } return consumed ; }
public static  String format Sql Values (  String ... values ) {  String Builder builder = new  String Builder ( _ STR ) ; for ( int i = _ NUM ; i < values . length ; i ++ ) { if ( i > _ NUM ) { builder . append ( _ STR ) ; } builder . append ( _ STR ) ; builder . append ( escape Sql String ( values [ i ] ) ) ; builder . append ( _ STR ) ; } builder . append ( _ STR ) ; return builder . to String ( ) ; }
private void emit Class (  Doc Comment comment ) {  String tag Name = ( comment . get Type ( ) ==  Doc Comment .  CLASS ) ? _ STR : _ STR ; xml . append ( _ STR ) ; xml . append ( tag Name ) ; xml . append ( _ STR ) ; xml . append ( comment . get Name ( ) ) ; xml . append ( _ STR ) ; xml . append ( comment . get Fullname ( ) ) ;  String sourcefile = comment . get Source File ( ) ; if ( sourcefile != null ) { xml . append ( _ STR ) ; xml . append ( sourcefile ) ; } xml . append ( _ STR ) ; xml . append ( comment . get Namespace ( ) ) ; xml . append ( _ STR ) ; xml . append ( comment . get Access ( ) ) ; xml . append ( _ STR ) ; if ( comment . get Type ( ) ==  Doc Comment .  INTERFACE ) {  String [ ] base Classes = comment . get Baseclasses ( ) ; if ( base Classes != null ) { xml . append ( _ STR ) ; for ( int i = _ NUM ; i < base Classes . length ; i ++ ) {  String baseclass = base Classes [ i ] ; if ( baseclass != null ) { if ( i != _ NUM ) xml . append ( _ STR ) ; xml . append ( baseclass ) ; } } xml . append ( _ STR ) ; } } else { xml . append ( _ STR ) ; xml . append ( comment . get Base Class ( ) ) ; xml . append ( _ STR ) ;  String [ ] interfaces = comment . get Interfaces ( ) ; if ( interfaces != null ) { xml . append ( _ STR ) ; for ( int i = _ NUM ; i < interfaces . length ; i ++ ) {  String inter = interfaces [ i ] ; if ( inter != null ) { if ( i != _ NUM ) xml . append ( _ STR ) ; xml . append ( inter ) ; } } xml . append ( _ STR ) ; } } xml . append ( _ STR ) ; xml . append ( comment . is Final ( ) ) ; xml . append ( _ STR ) ; xml . append ( _ STR ) ; xml . append ( comment . is Dynamic ( ) ) ; xml . append ( _ STR ) ; xml . append ( _ STR ) ;  String desc = comment . get Description ( ) ; if ( desc != null ) append Tag ( _ STR , comment . get Description ( ) ) ; emit Tags ( comment . get All Tags ( ) ) ; if ( comment . get Metadata ( ) != null ) emit Metadata ( comment . get Metadata ( ) ) ; xml . append ( _ STR ) ; xml . append ( tag Name ) ; xml . append ( _ STR ) ; }
protected void paint Content Border Top Edge (  Graphics g , int x , int y , int w , int h , boolean draw Broken ,  Rectangle sel Rect , boolean is Content Border Painted ) { if ( is Content Border Painted ) { g . set Color ( select Highlight ) ; g . fill Rect ( x , y , w - _ NUM , _ NUM ) ; } }
public void analyze All It And Write Results ( ) {  Run Results Loader run Dir = new  Run Results Loader ( run Directory , null ) ;  Print Stream stream ; try { stream = new  Print Stream ( new  File ( output Dir + _ STR ) ) ; } catch (  File Not Found Exception e ) { e . print Stack Trace ( ) ; return ; }  String header = _ STR ; stream . println ( header ) ; double total TTIt ; double [ ] avg Route TTs It ; int [ ] route Users It ; for ( int i = _ NUM ; i <= last Iteration ; i ++ ) { log . info ( _ STR + i + _ STR + last Iteration + _ STR ) ;  String events Filename = run Dir . get Events Filename ( i ) ;  Events Manager events Manager = new  Events Manager Impl ( ) ;  Tt Analyze Braess handler = new  Tt Analyze Braess ( ) ; events Manager . add Handler ( handler ) ;  Matsim Events Reader reader = new  Matsim Events Reader ( events Manager ) ; reader . read File ( events Filename ) ; total TTIt = handler . get Total TT ( ) ; avg Route TTs It = handler . calculate Avg Route TTs ( ) ; route Users It = handler . get Route Users ( ) ;  String Buffer line = new  String Buffer ( ) ; line . append ( i + _ STR + total TTIt ) ; for ( int j = _ NUM ; j < _ NUM ; j ++ ) { line . append ( _ STR + route Users It [ j ] ) ; } for ( int j = _ NUM ; j < _ NUM ; j ++ ) { line . append ( _ STR + avg Route TTs It [ j ] ) ; } stream . println ( line . to String ( ) ) ; } stream . close ( ) ; log . info ( last Iteration + _ STR ) ; }
public int execute Update (  String sql ) throws  SQLException { return  Util . truncate And Convert To Int ( execute Large Update ( sql ) ) ; }
@  Layoutlib Delegate static long current Thread Time Millis ( ) { return  System . current Time Millis ( ) ; }
public static  Entry make Entry (  List <  String > ldif Lines ) { return make Entry ( ldif Lines . to Array ( new  String [ ldif Lines . size ( ) ] ) ) ; }
public int format ( int val , byte [ ] buf , int off , int len ) { if ( val ==  Integer .  MIN_ VALUE ) { if ( len >  Byte Formatter .  NUMBER_ BASE ) { return format ( _ STR , buf , off , len ) ; } else { truncation Filler ( buf , off , len ) ; return off + len ; } } int pos =  Math . abs ( val ) ; int ndig = _ NUM ; int dmax =  Byte Formatter .  NUMBER_ BASE ; while ( ndig <  Byte Formatter .  NUMBER_ BASE && pos >= dmax ) { ndig ++ ; dmax *=  Byte Formatter .  NUMBER_ BASE ; } if ( val < _ NUM ) { ndig ++ ; } if ( ndig > len || ndig > buf . length - off ) { truncation Filler ( buf , off , len ) ; return off + len ; } off += ndig ; int xoff = off - _ NUM ; do { buf [ xoff ] =  Byte Formatter .  DIGITS [ pos %  Byte Formatter .  NUMBER_ BASE ] ; xoff -- ; pos /=  Byte Formatter .  NUMBER_ BASE ; } while ( pos > _ NUM ) ; if ( val < _ NUM ) { buf [ xoff ] = ( byte ) _ STR ; } return off ; }
public void append ( char c [ ] ) { int maxlength = buffer . length - pos ; if ( c . length < maxlength ) {  System . arraycopy ( c , _ NUM , buffer , pos , c . length ) ; pos += c . length ; } else {  System . arraycopy ( c , _ NUM , buffer , pos , maxlength ) ; curr . next = new  Entity ( buffer ) ; curr = curr . next ; length += buffer . length ; buffer = new char [ ( buffer . length > c . length - maxlength ) ? buffer . length : c . length - maxlength ] ; if ( c . length > maxlength ) {  System . arraycopy ( c , maxlength , buffer , _ NUM , c . length - maxlength ) ; pos = c . length - maxlength ; } else { pos = _ NUM ; } } }
private boolean is Annotation ( ) { return impl Interfaces . contains ( _ STR ) ; }
public final boolean is Exception Handler Equivalent (  Basic Block other ) { if ( exception Handlers != other . exception Handlers ) {  Enumeration <  Basic Block > e1 = get Exception Handlers ( ) ;  Enumeration <  Basic Block > e2 = other . get Exception Handlers ( ) ; while ( e1 . has More Elements ( ) ) { if ( ! e2 . has More Elements ( ) ) return _ BOOL ; if ( e1 . next Element ( ) != e2 . next Element ( ) ) return _ BOOL ; } if ( e2 . has More Elements ( ) ) return _ BOOL ; } return _ BOOL ; }
public int checksum ( ) { return calculate Checksum ( compile_checksum . to String ( ) ) ; }
public boolean long Label ( ) { return f State . long Label ; }
public  Secret Block (  Mario player ,  Group parent , int stage Zone , float x Pos , float y Pos , float yolo Width ,  Image ... hit State ) { super (  BLOCK_ COLLISION_ DATA , x Pos , y Pos , _ NUM , _ NUM , (  Image ) null ) ; this . hit State = hit State [ _ NUM ] ; yolo View = new  Image View ( hit State [ _ NUM ] ) ; yolo View . set Fit Width ( yolo Width ) ; this . parent = parent ; zone = stage Zone ; }
private  Socket open Data Connection (  String cmd ) throws sun . net . ftp .  Ftp Protocol Exception ,  IOException {  Socket client Socket ; if ( passive Mode ) { try { return open Passive Data Connection ( cmd ) ; } catch ( sun . net . ftp .  Ftp Protocol Exception e ) {  String errmsg = e . get Message ( ) ; if ( ! errmsg . starts With ( _ STR ) && ! errmsg . starts With ( _ STR ) ) { throw e ; } } }  Server Socket port Socket ;  Inet Address my Address ;  String port Cmd ; if ( proxy != null && proxy . type ( ) ==  Proxy .  Type .  SOCKS ) { throw new sun . net . ftp .  Ftp Protocol Exception ( _ STR ) ; } port Socket = new  Server Socket ( _ NUM , _ NUM , server . get Local Address ( ) ) ; try { my Address = port Socket . get Inet Address ( ) ; if ( my Address . is Any Local Address ( ) ) { my Address = server . get Local Address ( ) ; } port Cmd = _ STR + ( ( my Address instanceof  Inet6 Address ) ? _ STR : _ STR ) + _ STR + my Address . get Host Address ( ) + _ STR + port Socket . get Local Port ( ) + _ STR ; if ( ! issue Command ( port Cmd ) || ! issue Command ( cmd ) ) { port Cmd = _ STR ; byte [ ] addr = my Address . get Address ( ) ; for ( int i = _ NUM ; i < addr . length ; i ++ ) { port Cmd = port Cmd + ( addr [ i ] & _ NUM ) + _ STR ; } port Cmd = port Cmd + ( ( port Socket . get Local Port ( ) > > > _ NUM ) & _ NUM ) + _ STR + ( port Socket . get Local Port ( ) & _ NUM ) ; issue Command Check ( port Cmd ) ; issue Command Check ( cmd ) ; } if ( connect Timeout >= _ NUM ) { port Socket . set So Timeout ( connect Timeout ) ; } else { if ( default Connect Timeout > _ NUM ) { port Socket . set So Timeout ( default Connect Timeout ) ; } } client Socket = port Socket . accept ( ) ; if ( read Timeout >= _ NUM ) { client Socket . set So Timeout ( read Timeout ) ; } else { if ( default So Timeout > _ NUM ) { client Socket . set So Timeout ( default So Timeout ) ; } } } finally { port Socket . close ( ) ; } if ( use Crypto ) { try { client Socket = ssl Fact . create Socket ( client Socket , server Addr . get Host Name ( ) , server Addr . get Port ( ) , _ BOOL ) ; } catch (  Exception ex ) { throw new  IOException ( ex . get Localized Message ( ) ) ; } } return client Socket ; }
public static boolean install Normal (  Context context ,  String file Path ) {  Intent i = new  Intent (  Intent .  ACTION_ VIEW ) ;  File file = new  File ( file Path ) ; if ( ! file . exists ( ) || ! file . is File ( ) || file . length ( ) <= _ NUM ) { return _ BOOL ; } i . set Data And Type (  Uri . parse ( _ STR + file Path ) , _ STR ) ; i . add Flags (  Intent .  FLAG_ ACTIVITY_ NEW_ TASK ) ; context . start Activity ( i ) ; return _ BOOL ; }
private void create Insert List ( final  IItem item ,  List <  IItem > temp List ,  List <  IItem > insert List , int depth , int removed ) { if ( ! temp List . contains ( item ) ) { temp List . add ( item ) ; if ( depth == _ NUM ) { insert List . add ( item ) ; } if ( item . get Items ( ) != null ) { depth ++ ; for (  IItem child : item . get Items ( ) ) { create Insert List ( child , temp List , insert List , depth , removed ) ; } } } else { insert List . remove ( item ) ; removed ++ ; } }
@  Suppress Warnings ( _ STR ) public int read Outline File Metadata ( final  Pdf Object  Outlines Obj , final  Pdf Object Reader current Pdf File ) { final int count =  Outlines Obj . get Int (  Pdf Dictionary .  Count ) ; final  Pdf Object  First Obj =  Outlines Obj . get Dictionary (  Pdf Dictionary .  First ) ; current Pdf File . check Resolved (  First Obj ) ; if (  First Obj != null ) { final  Element root =  Outline Data XML . create Element ( _ STR ) ;  Outline Data XML . append Child ( root ) ; final int level = _ NUM ; read Outline Level ( root , current Pdf File ,  First Obj , level , _ BOOL ) ; } return count ; }
private int decode Run Length ( int k ) { if ( ( k & _ NUM ) == _ NUM ) { return ( ( k > > > _ NUM ) & _ NUM ) ^ _ NUM ; } else { return  Integer . number Of Leading Zeros ( k << p + ( _ NUM - sp ) ) + _ NUM ; } }
public  No Duplicate Value Global Constraint (  Abstract Parameter < ? , ? > ... parameters ) { this . parameters =  Arrays . as List ( parameters ) ; }
@  Suppress Warnings ( _ STR ) public  Rhythm Overlay inflate Overlay (  String config String ) {  List <  String > config Strings =  Arrays . as List ( config String . split ( _ STR ) ) ; return inflate Overlay Internal ( config Strings ,  Collections .  EMPTY_ MAP , _ NUM ) ; }
public boolean is Source Modified (  Resource resource ) { boolean modified = _ BOOL ;  String file Name = resource . get Name ( ) ;  String path = (  String ) template Paths . get ( file Name ) ;  File current File = null ; for ( int i = _ NUM ; current File == null && i < paths . size ( ) ; i ++ ) {  String test Path = (  String ) paths . get ( i ) ;  File test File = new  File ( test Path , file Name ) ; if ( test File . can Read ( ) ) { current File = test File ; } }  File file = new  File ( path , file Name ) ; if ( current File == null || ! file . exists ( ) ) { } else if ( current File . equals ( file ) && file . can Read ( ) ) { modified = ( file . last Modified ( ) != resource . get Last Modified ( ) ) ; } return modified ; }
protected void flip (  Buffer Capabilities .  Flip Contents flip Action ) { if ( peer != null ) {  Image back Buffer = get Back Buffer ( ) ; if ( back Buffer != null ) { peer . flip ( _ NUM , _ NUM , back Buffer . get Width ( null ) , back Buffer . get Height ( null ) , flip Action ) ; } } else { throw new  Illegal State Exception ( _ STR ) ; } }
protected void load Value (  String s Value ) { try { value =  Byte . parse Byte ( s Value . trim ( ) ) ; } catch (  Number Format Exception nfe ) { revert To Default ( ) ; } }
public static  Map <  String ,  String > all Namespaces (  SOAPElement ele ) {  Map <  String ,  String > ns List = new  Tree Map <  String ,  String > ( ) ; log . trace ( _ STR + ele . get Node Name ( ) ) ; all Namespaces ( ele , ns List ) ; log . trace ( _ STR + ns List ) ; return ns List ; }
private void draw Hook (  Canvas canvas ) {  Path hook Path = new  Path ( ) ; double sweep Angle =  Math .  PI / _ NUM * _ NUM ; float y = ( float )  Math . sin ( sweep Angle ) * ( get Big Circle Radius ( ) ) + rect F . height ( ) / _ NUM ; float x = ( float )  Math . cos ( sweep Angle ) * ( get Big Circle Radius ( ) ) + rect F . width ( ) / _ NUM ; float i = get Big Circle Radius ( ) / _ NUM ; hook Path . add Round Rect ( new  Rect F ( i + i / _ NUM , i + i / _ NUM , i + i / _ NUM + _ NUM , i + i + i / _ NUM ) , _ NUM , _ NUM ,  Path .  Direction .  CCW ) ; hook Path . add Round Rect ( new  Rect F ( i + i / _ NUM , ( i + i + i / _ NUM ) - _ NUM , i + i / _ NUM + i + i , i + i + i / _ NUM + _ NUM ) , _ NUM , _ NUM ,  Path .  Direction .  CCW ) ;  Matrix matrix = new  Matrix ( ) ; matrix . reset ( ) ; int restore Count = canvas . get Save Count ( ) ; hook Path . close ( ) ; canvas . rotate ( - _ NUM , rect F . center X ( ) , rect F . center Y ( ) ) ; canvas . draw Path ( hook Path , m Hook Paint ) ; canvas . restore To Count ( restore Count ) ; }
public void continue Button Action Performed ( java . awt . event .  Action Event e ) { if ( test Running && test Suspended ) { test Suspended = _ BOOL ; if ( wrap Test ) { status Text1 . set Text ( _ STR ) ; status Text1 . set Visible ( _ BOOL ) ; } } }
@  HLEFunction ( nid = _ NUM , version = _ NUM ) public int sce Net Adhoc Ptp Flush ( @  Check Argument ( _ STR ) int id , int timeout , int nonblock ) { return _ NUM ; }
public void reset ( ) { display Cache . clear ( ) ; cached ID . clear ( ) ; }
private void copy Directory (  File source ,  File dest ) throws  IOException { for (  File f : source . list Files ( ) ) {  File source File = new  File ( source , f . get Name ( ) ) ;  File dest File = new  File ( dest , f . get Name ( ) ) ; if ( f . is Directory ( ) ) { dest File . mkdirs ( ) ; copy Directory ( source File , dest File ) ; } else copy File ( source File , dest File ) ; } }
private synchronized void rebuild Journal ( ) throws  IOException { if ( m Journal Writer != null ) { m Journal Writer . close ( ) ; }  Writer writer = new  Buffered Writer ( new  File Writer ( m Journal File Tmp ) ,  IO_ BUFFER_ SIZE ) ; writer . write (  MAGIC ) ; writer . write ( _ STR ) ; writer . write (  VERSION_1 ) ; writer . write ( _ STR ) ; writer . write (  Integer . to String ( m App Version ) ) ; writer . write ( _ STR ) ; writer . write ( _ STR ) ; for (  Cache Entry cache Entry : m Lru Entries . values ( ) ) { if ( cache Entry . is Under Edit ( ) ) { writer . write ( s ACTION_ LIST [  ACTION_ DIRTY ] + _ STR + cache Entry . get Key ( ) + _ STR + cache Entry . get Size ( ) + _ STR ) ; } else { writer . write ( s ACTION_ LIST [  ACTION_ CLEAN ] + _ STR + cache Entry . get Key ( ) + _ STR + cache Entry . get Size ( ) + _ STR ) ; } } writer . close ( ) ; m Journal File Tmp . rename To ( m Journal File ) ; m Journal Writer = new  Buffered Writer ( new  File Writer ( m Journal File , _ BOOL ) ,  IO_ BUFFER_ SIZE ) ; }
private void record Log Data ( ) { try { int size = m Recording Data . size ( ) ; if ( size == _ NUM ) { return ; }  Vector <  String > recording Data = new  Vector < > ( m Recording Data ) ;  File log Dir =  Constants . get Record Dir ( this ) ; log Dir . mkdirs ( ) ;  File log File = new  File ( log Dir , m Recording Filename ) ;  File Writer log File Writer = new  File Writer ( log File , _ BOOL ) ; for ( int i = _ NUM ; i < size ; i ++ ) { log File Writer . append ( recording Data . element At ( i ) + _ STR ) ; m Recording Data . remove Element At ( _ NUM ) ; } recording Data . remove All Elements ( ) ; log File Writer . close ( ) ; } catch (  Exception e ) {  Log . e (  LOG_ TAG , _ STR + e . to String ( ) ) ; } }
private static  List <  Command > load Rewrites (  String str ) { assert str != null ;  List <  Command > commands = new  Array List < > ( ) ; for (  String line : str . split ( _ STR ) ) { add Line ( commands , line ) ; } return commands ; }
@  Override public  State Connection on Close Read ( ) {  Connection Protocol request = request ( ) ; if ( request != null ) { request . on Close Read ( ) ; } _sequence Close . set ( _sequence Read . get ( ) ) ; if ( _sequence Flush . get ( ) < _sequence Close . get ( ) ) { _is Close Pending . set ( _ BOOL ) ; if ( _sequence Flush . get ( ) < _sequence Close . get ( ) ) { return  State Connection .  CLOSE_ READ_ S ; } else { _is Close Pending . set ( _ BOOL ) ; return  State Connection .  CLOSE ; } } else { return  State Connection .  CLOSE ; } }
private  Map <  UUID , int [ ] > reducers (  Collection <  Cluster Node > top ,  Map <  UUID ,  Collection <  Hadoop Input Split > > mappers , int reducer Cnt ) { int total Weight = _ NUM ;  List <  Weighted Node > nodes = new  Array List < > ( top . size ( ) ) ; for (  Cluster Node node : top ) {  Collection <  Hadoop Input Split > split = mappers . get ( node . id ( ) ) ; int weight = reducer Node Weight ( node , split != null ? split . size ( ) : _ NUM ) ; nodes . add ( new  Weighted Node ( node . id ( ) , weight , weight ) ) ; total Weight += weight ; } int total Adjusted Weight = _ NUM ; for (  Weighted Node node : nodes ) { node . float Weight = ( ( float ) node . weight * reducer Cnt ) / total Weight ; node . weight =  Math . round ( node . float Weight ) ; total Adjusted Weight += node . weight ; }  Collections . sort ( nodes ) ; if ( total Adjusted Weight > reducer Cnt ) {  List Iterator <  Weighted Node > iter = nodes . list Iterator ( nodes . size ( ) - _ NUM ) ; while ( total Adjusted Weight != reducer Cnt ) { if ( ! iter . has Previous ( ) ) iter = nodes . list Iterator ( nodes . size ( ) - _ NUM ) ;  Weighted Node node = iter . previous ( ) ; if ( node . weight > _ NUM ) { node . weight -= _ NUM ; total Adjusted Weight -- ; } } } else if ( total Adjusted Weight < reducer Cnt ) {  List Iterator <  Weighted Node > iter = nodes . list Iterator ( _ NUM ) ; while ( total Adjusted Weight != reducer Cnt ) { if ( ! iter . has Next ( ) ) iter = nodes . list Iterator ( _ NUM ) ;  Weighted Node node = iter . next ( ) ; if ( node . float Weight > _ NUM ) { node . weight += _ NUM ; total Adjusted Weight ++ ; } } } int idx = _ NUM ;  Map <  UUID , int [ ] > reducers = new  Hash Map < > ( nodes . size ( ) , _ NUM ) ; for (  Weighted Node node : nodes ) { if ( node . weight > _ NUM ) { int [ ] arr = new int [ node . weight ] ; for ( int i = _ NUM ; i < arr . length ; i ++ ) arr [ i ] = idx ++ ; reducers . put ( node . node Id , arr ) ; } } return reducers ; }
public void http Request (  Http Request Event e ) throws java . io .  IOException {  String request = e . get Request ( ) ; if (  Debug . debugging ( _ STR ) ) {  Debug . output ( _ STR + request + _ STR ) ; } if ( request . char At ( _ NUM ) == _ STR ) { request = request . substring ( _ NUM , request . length ( ) ) ; } int index = _ NUM ; index = request . index Of ( _ STR ) ; if ( index != - _ NUM ) { request = request . substring ( index + _ NUM , request . length ( ) ) ;  Debug . message ( _ STR , _ STR ) ; } else {  Debug . message ( _ STR , _ STR ) ; } try { i Server . handle Request ( request , e . get Output Stream ( ) ) ; } catch (  IOException ioe ) {  Debug . error ( _ STR + ioe . get Message ( ) ) ; } catch (  Map Request Format Exception exception ) {  String message = _ STR + exception . get Message ( ) + _ STR +  Error Message ;  Http Connection . write Http Response ( e . get Output Stream ( ) ,  Http Connection .  CONTENT_ PLAIN , message ) ; } }
public  String format ( double val ) {  Decimal Format df = get Double Format ( ) ; if ( df != null ) { return df . format ( val ) ; } return  Double . to String ( val ) ; }
public void remove Positions (  Collection <  Integer > positions ) {  Array List <  Integer > positions List = new  Array List <  Integer > ( positions ) ;  Collections . sort ( positions List ) ;  Collections . reverse ( positions List ) ; for ( int position : positions List ) { m Items . remove ( position ) ; } notify Data Set Changed ( ) ; }
private void reset Shape Bounds ( ) {  Round Rectangle2 D .  Double rrect = (  Round Rectangle2 D .  Double ) shape ; rrect . set Round Rect ( _ NUM , _ NUM , get Bounds ( ) . width - _ NUM , get Bounds ( ) . height - _ NUM , _ NUM , _ NUM ) ; }
public static  Colour attempt To Get As Colour (  String part ) {  Colour col = null ; try { col =  Colour . value Of ( part . to Upper Case ( ) ) ; } catch (  Exception e ) { } return col ; }
public final  Array List <  Move > remove Non Optimal (  Position pos ,  Array List <  Move > move List ) {  Array List <  Move > optimal Moves = new  Array List <  Move > ( ) ;  Array List <  Move > unknown Moves = new  Array List <  Move > ( ) ; final int  MATE0 = _ NUM ; int best Score = - _ NUM ;  Undo Info ui = new  Undo Info ( ) ; for (  Move m : move List ) { pos . make Move ( m , ui ) ; int plies To Draw =  Math . max ( _ NUM - pos . half Move Clock , _ NUM ) ;  Gtb Probe Result res = gtb Probe ( pos ) ; pos . un Make Move ( m , ui ) ; if ( res . result ==  Gtb Probe Result .  UNKNOWN ) { unknown Moves . add ( m ) ; } else { int w Score ; if ( res . result ==  Gtb Probe Result .  WMATE ) { if ( res . plies To Mate <= plies To Draw ) w Score =  MATE0 - res . plies To Mate ; else w Score = _ NUM ; } else if ( res . result ==  Gtb Probe Result .  BMATE ) { if ( res . plies To Mate <= plies To Draw ) w Score = - (  MATE0 - res . plies To Mate ) ; else w Score = - _ NUM ; } else { w Score = _ NUM ; } int score = pos . white Move ? w Score : - w Score ; if ( score > best Score ) { optimal Moves . clear ( ) ; optimal Moves . add ( m ) ; best Score = score ; } else if ( score == best Score ) { optimal Moves . add ( m ) ; } else { } } } for (  Move m : unknown Moves ) optimal Moves . add ( m ) ; return ( optimal Moves . size ( ) < move List . size ( ) ) ? optimal Moves : null ; }
public static void execute Random Modifiable Variable Modification (  Modifiable Variable Holder object ) {  Field field = object . get Random Modifiable Variable Field ( ) ; execute Modifiable Variable Modification ( object , field ) ; }
public static boolean save (  File file ,  String content ) { boolean result ;  Buffered Writer writer ; writer = null ; try { writer = new  Buffered Writer ( new  File Writer ( file ) ) ; writer . write ( content ) ; writer . flush ( ) ; result = _ BOOL ; } catch (  Exception e ) { e . print Stack Trace ( ) ; result = _ BOOL ; } finally { if ( writer != null ) { try { writer . close ( ) ; } catch (  Exception e ) { } } } return result ; }
private void delete Old Temp (  File file Cfg ) {  Buffered Reader reader = null ; try { int count = _ NUM ; reader = new  Buffered Reader ( new  File Reader ( file Cfg ) ) ;  String s Line ; while ( ( s Line = reader . read Line ( ) ) != null ) {  File file = new  File ( s Line ) ; if ( ! file . exists ( ) ) { continue ; } if ( file . delete ( ) ) { count ++ ; } else { hs Delete On Exit . add ( file ) ; } } log Debug (  Log Area .  CONFIG , _ STR , count , file Cfg . get Absolute Path ( ) ) ; } catch (  IOException e ) { } finally { if ( reader != null ) { try { reader . close ( ) ; } catch (  IOException e ) { } } } }
public void propose Tree ( ) throws  Operator Failed Exception {  Node Ref i ; double old Min Age , new Min Age , new Range , old Range , new Age , q ; final int node Count = tree . get Node Count ( ) ; do { i = tree . get Node (  Math Utils . next Int ( node Count ) ) ; } while ( tree . get Root ( ) == i ) ; final  Node Ref i P = tree . get Parent ( i ) ;  Node Ref j = tree . get Node (  Math Utils . next Int ( node Count ) ) ;  Node Ref k = tree . get Parent ( j ) ; while ( ( k != null && tree . get Node Height ( k ) <= tree . get Node Height ( i ) ) || ( i == j ) ) { j = tree . get Node (  Math Utils . next Int ( node Count ) ) ; k = tree . get Parent ( j ) ; } if ( j == tree . get Root ( ) || i P == tree . get Root ( ) ) { throw new  Operator Failed Exception ( _ STR ) ; } if ( k == i P || j == i P || k == i ) throw new  Operator Failed Exception ( _ STR ) ; final  Node Ref  Ci P = get Other Child ( tree , i P , i ) ;  Node Ref  Pi P = tree . get Parent ( i P ) ; new Min Age =  Math . max ( tree . get Node Height ( i ) , tree . get Node Height ( j ) ) ; new Range = tree . get Node Height ( k ) - new Min Age ; new Age = new Min Age + (  Math Utils . next Double ( ) * new Range ) ; old Min Age =  Math . max ( tree . get Node Height ( i ) , tree . get Node Height (  Ci P ) ) ; old Range = tree . get Node Height (  Pi P ) - old Min Age ; q = new Range /  Math . abs ( old Range ) ; tree . begin Tree Edit ( ) ; if ( j == tree . get Root ( ) ) { tree . remove Child ( i P ,  Ci P ) ; tree . remove Child (  Pi P , i P ) ; tree . add Child ( i P , j ) ; tree . add Child (  Pi P ,  Ci P ) ; tree . set Root ( i P ) ; } else if ( i P == tree . get Root ( ) ) { tree . remove Child ( k , j ) ; tree . remove Child ( i P ,  Ci P ) ; tree . add Child ( i P , j ) ; tree . add Child ( k , i P ) ; tree . set Root (  Ci P ) ; } else { tree . remove Child ( k , j ) ; tree . remove Child ( i P ,  Ci P ) ; tree . remove Child (  Pi P , i P ) ; tree . add Child ( i P , j ) ; tree . add Child ( k , i P ) ; tree . add Child (  Pi P ,  Ci P ) ; } tree . set Node Height ( i P , new Age ) ; tree . end Tree Edit ( ) ; logq =  Math . log ( q ) ; }
public void flush ( ) { final  Bigdata Sail Repository Connection cxn = tl Tx . get ( ) ; if ( cxn != null ) {  Code . wrap Throw ( null ) ; } }
@  Override public  Buffered Image  JPEGTo RGBImage ( final byte [ ] data , final int ww , final int hh , final int p X , final int p Y ) {  Buffered Image image = null ;  Raster ras =  JPEGDecoder . get Raster From JPEG ( data , _ STR ) ; if ( ras != null ) { ras = cleanup Raster ( ras , p X , p Y , component Count ) ; final int w = ras . get Width ( ) ; final int h = ras . get Height ( ) ; final  Data Buffer Byte rgb = (  Data Buffer Byte ) ras . get Data Buffer ( ) ; image = create Image ( w , h , rgb . get Data ( ) ) ; } return image ; }
public void despawn (  Visible Object object ) { despawn ( object , _ BOOL ) ; }
@  Suppress Warnings ( _ STR ) public static void create Project Constraint (  Zip File zip ,  Project a Project ,  Repository Service a Repository ) throws  IOException { for (  Enumeration zip Enumerate = zip . entries ( ) ; zip Enumerate . has More Elements ( ) ; ) {  Zip Entry entry = (  Zip Entry ) zip Enumerate . next Element ( ) ;  String entry Name = normalize Entry Name ( entry ) ; if ( entry Name . starts With (  CONSTRAINTS ) ) {  String filename =  Filename Utils . get Name ( entry . get Name ( ) ) ;  Constraint Set constraint Set = new  Constraint Set ( ) ; constraint Set . set Project ( a Project ) ; constraint Set . set Name ( filename ) ; a Repository . create Constraint Set ( constraint Set ) ; a Repository . write Constraint Set ( constraint Set , zip . get Input Stream ( entry ) ) ;  LOG . info ( _ STR + filename + _ STR + a Project . get Name ( ) + _ STR + a Project . get Id ( ) + _ STR ) ; } } }
public  Operation copy To (  Extent target ) {  Block Transform Extent extent = new  Block Transform Extent ( original , transform , world Data . get Block Registry ( ) ) ;  Forward Extent Copy copy = new  Forward Extent Copy ( extent , original . get Region ( ) , original . get Origin ( ) , target , original . get Origin ( ) ) ; copy . set Transform ( transform ) ; return copy ; }
@  Caller Sensitive public  Class < ? > for Class ( ) { if ( cl == null ) { return null ; } require Initialized ( ) ; if (  System . get Security Manager ( ) != null ) {  Class < ? > caller =  Reflection . get Caller Class ( ) ; if (  Reflect Util . needs Package Access Check ( caller . get Class Loader ( ) , cl . get Class Loader ( ) ) ) {  Reflect Util . check Package Access ( cl ) ; } } return cl ; }
private void path Style Helper (  String style ,  String offset ) { if ( style == null ) { return ; } if ( style . equals ( _ STR ) ) { stroke Paint . set Path Effect ( null ) ; return ; }  String Tokenizer st = new  String Tokenizer ( style , _ STR ) ; int count = st . count Tokens ( ) ; float [ ] intervals = new float [ ( count & _ NUM ) == _ NUM ? count * _ NUM : count ] ; float max = _ NUM ; float current = _ NUM ; int i = _ NUM ; while ( st . has More Tokens ( ) ) { intervals [ i ++ ] = current = to Float ( st . next Token ( ) , current ) ; max += current ; } for ( int start = _ NUM ; i < intervals . length ; i ++ , start ++ ) { max += intervals [ i ] = intervals [ start ] ; } float off = _ NUM ; if ( offset != null ) { try { off =  Float . parse Float ( offset ) % max ; } catch (  Number Format Exception e ) { } } stroke Paint . set Path Effect ( new  Dash Path Effect ( intervals , off ) ) ; }
private  Size parse Old Bounded Size (  String token , boolean set Max ) { int semicolon Index = token . index Of ( _ STR ) ;  String size Token1 = token . substring ( _ NUM , semicolon Index ) ;  String size Token2 = token . substring ( semicolon Index + _ NUM , token . length ( ) - _ NUM ) ;  Size size1 = parse Atomic Size ( size Token1 ) ;  Size size2 = parse Atomic Size ( size Token2 ) ; if ( is Constant ( size1 ) ) { if ( size2 instanceof  Sizes .  Component Size ) { return new  Bounded Size ( size2 , set Max ? null : size1 , set Max ? size1 : null ) ; } throw new  Illegal Argument Exception ( _ STR ) ; } if ( is Constant ( size2 ) ) { return new  Bounded Size ( size1 , set Max ? null : size2 , set Max ? size2 : null ) ; } throw new  Illegal Argument Exception ( _ STR ) ; }
Builder add Encoded Query Parameter (  String encoded Name ,  String encoded Value ) { if ( encoded Name == null ) throw new  Illegal Argument Exception ( _ STR ) ; if ( encoded Query Names And Values == null ) encoded Query Names And Values = new  Array List < > ( ) ; encoded Query Names And Values . add ( canonicalize ( encoded Name ,  QUERY_ COMPONENT_ ENCODE_ SET , _ BOOL , _ BOOL ) ) ; encoded Query Names And Values . add ( encoded Value != null ? canonicalize ( encoded Value ,  QUERY_ COMPONENT_ ENCODE_ SET , _ BOOL , _ BOOL ) : null ) ; return this ; }
private static a create Image Link (  String  AD_ Language ,  String name ,  String js_command , boolean enabled , boolean pressed ) { a img = new a ( _ STR , create Image (  AD_ Language , name ) ) ; if ( ! pressed || ! enabled ) img . set ID ( _ STR ) ; else img . set ID ( _ STR ) ; if ( js_command == null ) js_command = _ STR ; if ( js_command . length ( ) > _ NUM && enabled ) { if ( js_command . starts With ( _ STR ) ) img . set On Click ( js_command ) ; else img . set On Click ( _ STR + name + _ STR + js_command + _ STR ) ; } img . set Class ( _ STR ) ; img . set On Mouse Over ( _ STR + name + _ STR ) ; img . set On Mouse Out ( _ STR ) ; img . set On Blur ( _ STR ) ; return img ; }
public  Namespace (  Principal User creator ,  String qualifier ,  Principal User owner ,  Set <  Principal User > users ) { super ( creator ) ; set Qualifier ( qualifier ) ; set Owner ( owner ) ; if ( users != null && ! users . is Empty ( ) ) { set Users ( users ) ; } add User ( owner ) ; }
public final int decrement And Get ( ) { return unsafe . get And Add Int ( this , value Offset , - _ NUM ) - _ NUM ; }
public void update ( long dt , float ratio Y ) { double step = _ NUM *  Math .  PI /  POINTS_ PER_ CIRCLE ; angle += dt *  BUBBLE_ D_ ANGLE ; float from X = start X + ( float ) ( _ NUM *  Math . sin ( angle ) ) ; float to X = from X + size ; float from Y = this . from Y + dt * speed ; float to Y = from Y + size ; center Y += dt * virtual Speed ; get Color ( ) [ _ NUM ] = (  TOP_ Y - center Y /  TOP_ Y ) ; vertex Buffer . put ( _ NUM ,  Utils . normalize Gl ( _ NUM , from X , to X ) ) ; vertex Buffer . put ( _ NUM ,  Utils . normalize Gl ( center Y * ratio Y , from Y , to Y ) ) ; for ( int i = _ NUM ; i <=  POINTS_ PER_ CIRCLE ; i ++ ) { vertex Buffer . put (  COORDS_ PER_ VERTEX * i ,  Utils . normalize Gl ( ( float )  Math . sin ( -  Math .  PI + step * i ) , from X , to X ) ) ; vertex Buffer . put (  COORDS_ PER_ VERTEX * i + _ NUM ,  Utils . normalize Gl ( ( float )  Math . cos ( -  Math .  PI + step * i ) * ratio Y , from Y , to Y ) ) ; } this . from Y = from Y ; }
public final void clear ( ) { if (  GWT . is Script ( ) ) { js Array . clear ( ) ; } else { java Array . clear ( ) ; } }
@  Override public synchronized void clear ( ) {  File [ ] files = m Root Directory . list Files ( ) ; if ( files != null ) { for (  File file : files ) { file . delete ( ) ; } } m Entries . clear ( ) ;  Volley Log . d ( _ STR ) ; }
private void update Podcast Publication Date And Last Media Url (  Episode episode ,  Podcast podcast ) {  Date podcast Publication Date = podcast . get Publication Date ( ) ; boolean episode Pub Date Is More Recent = episode . get Publication Date ( ) != null && ( podcast Publication Date == null || podcast Publication Date . before ( episode . get Publication Date ( ) ) ) ; if ( episode Pub Date Is More Recent ) { podcast . set Publication Date ( episode . get Publication Date ( ) ) ; podcast . set Last Episode Media Url ( episode . get Media Url ( ) ) ; } }
private void remove Our UIs ( ) { for (  String ui Name :  UI_ LIST ) { ui Defaults . remove ( ui Name + _ STR ) ; } }
public void make Immutable ( ) { }
public static <  O >  KNNQuery <  O > precomputed KNNQuery (  Database database ,  Relation <  O > relation ,  Distance Query <  O > dq , int k ) {  KNNQuery <  O > knnq = database . get KNNQuery ( dq , k ,  Database Query .  HINT_ HEAVY_ USE ,  Database Query .  HINT_ OPTIMIZED_ ONLY ,  Database Query .  HINT_ NO_ CACHE ) ; if ( knnq instanceof  Preprocessor KNNQuery ) { return knnq ; }  Materialize KNNPreprocessor <  O > preproc = new  Materialize KNNPreprocessor < > ( relation , dq . get Distance Function ( ) , k ) ; preproc . initialize ( ) ; return preproc . get KNNQuery ( dq , k ) ; }
public static  Sorted Set <  Integer > adjust Position (  Set <  Integer > positions , int start Position , int end Position , int adjust By ) {  Sorted Set <  Integer > new Positions = new  Tree Set < > ( ) ; for (  Integer entry : positions ) { int position = entry ; if ( position < start Position || position > end Position ) { new Positions . add ( position ) ; } else if ( adjust By > _ NUM ) { new Positions . add ( position + adjust By ) ; } else if ( adjust By < _ NUM ) { if ( position > start Position + adjust By && position <= start Position ) { ; } else { new Positions . add ( position + adjust By ) ; } } } return new Positions ; }
private  Resolved Migration create Available Migration ( int version ) {  Resolved Migration migration = new  Resolved Migration ( ) ; migration . set Version (  Migration Version . from Version (  Integer . to String ( version ) ) ) ; migration . set Description ( _ STR ) ; migration . set Script ( _ STR ) ; migration . set Type (  Migration Type .  CQL ) ; return migration ; }
public boolean draw Image (  Image img ,  Affine Transform xform ,  Image Observer observer ) { if ( img == null ) { return _ BOOL ; } if ( xform == null || xform . is Identity ( ) ) { return draw Image ( img , _ NUM , _ NUM , null , observer ) ; } if ( is Hi DPIImage ( img ) ) { final int w = img . get Width ( null ) ; final int h = img . get Height ( null ) ; final  Affine Transform tx = new  Affine Transform ( transform ) ; transform ( xform ) ; boolean result = draw Hi DPIImage ( img , _ NUM , _ NUM , w , h , _ NUM , _ NUM , w , h , null , observer ) ; transform . set Transform ( tx ) ; invalidate Transform ( ) ; return result ; } try { return imagepipe . transform Image ( this , img , xform , observer ) ; } catch (  Invalid Pipe Exception e ) { try { revalidate All ( ) ; return imagepipe . transform Image ( this , img , xform , observer ) ; } catch (  Invalid Pipe Exception e2 ) { return _ BOOL ; } } finally { surface Data . mark Dirty ( ) ; } }
public void begin Display (  Display Event event ) throws  Model Control Exception { super . begin Display ( event , _ BOOL ) ; reset Button State (  TBL_ BUTTON_ DELETE ) ;  Agents Model model = (  Agents Model ) get Model ( ) ;  String agent Type = get Display IDType ( ) ;  Object [ ] param = { agent Type } ; pt Model . set Page Title Text ( model . get Localized String ( _ STR + agent Type ) ) ; pt Model . set Page Title Help Message ( model . get Localized String ( _ STR + agent Type + _ STR ) ) ; tbl Model . set Title (  Message Format . format ( model . get Localized String ( _ STR ) , param ) ) ; tbl Model . set Title Label (  Message Format . format ( model . get Localized String ( _ STR ) , param ) ) ; tbl Model . set Summary (  Message Format . format ( model . get Localized String ( _ STR ) , param ) ) ; tbl Group Model . set Title (  Message Format . format ( model . get Localized String ( _ STR ) , param ) ) ; tbl Group Model . set Title Label (  Message Format . format ( model . get Localized String ( _ STR ) , param ) ) ; tbl Group Model . set Summary (  Message Format . format ( model . get Localized String ( _ STR ) , param ) ) ; get Agent Names ( ) ;  CCButton b = (  CCButton ) get Child (  TBL_ BUTTON_ DELETE ) ; b . set Disabled ( _ BOOL ) ; b = (  CCButton ) get Child (  TBL_ BUTTON_ DELETE_ GROUP ) ; b . set Disabled ( _ BOOL ) ; }
public void select_all ( ) {  Arrays . fill ( sel_array , _ BOOL ) ; }
public  Nvp Builder add Raw ( final  String name , final  String value ) { npv . put ( name , value ) ; return this ; }
@  Override public int length ( ) { return set . size ( ) ; }
public  List <  Country RO > view Address Country Options ( final  Shopping Cart cart , final  Shop shop , final  String address Type ) { final  List <  Country > countries = address Book Facade . get All Countries ( shop . get Code ( ) , address Type ) ; return map ( countries ,  Country RO . class ,  Country . class ) ; }
public void add Pause Listener (  Animator Pause Listener listener ) { if ( m Pause Listeners == null ) { m Pause Listeners = new  Array List <  Animator Pause Listener > ( ) ; } m Pause Listeners . add ( listener ) ; }
@  Override public void make Immutable ( ) { if ( mutable ) { if ( attrs != null ) {  Iterator iter = attrs . iterator ( ) ; while ( iter . has Next ( ) ) {  Attribute attr = (  Attribute ) iter . next ( ) ; attr . make Immutable ( ) ; } attrs =  Collections . unmodifiable List ( attrs ) ; } if ( enc Attrs != null ) { enc Attrs =  Collections . unmodifiable List ( enc Attrs ) ; } mutable = _ BOOL ; } }
@  Override public boolean batch Finished ( ) throws  Exception { if ( get Input Format ( ) == null ) { throw new  Illegal State Exception ( _ STR ) ; }  Instances to Filter = get Input Format ( ) ; if ( ! is First Batch Done ( ) ) {  Instances to Filter Ignoring Attributes = remove Ignored ( to Filter ) ;  File file = get Serialized Clusterer File ( ) ; if ( ! file . is Directory ( ) ) {  Object Input Stream ois = new  Object Input Stream ( new  File Input Stream ( file ) ) ; m_ Actual Clusterer = (  Clusterer ) ois . read Object ( ) ;  Instances header = null ; try { header = (  Instances ) ois . read Object ( ) ; } catch (  Exception e ) { } ois . close ( ) ; if ( ( header != null ) && ( ! header . equal Headers ( to Filter Ignoring Attributes ) ) ) { throw new  Weka Exception ( _ STR + header . equal Headers Msg ( to Filter Ignoring Attributes ) ) ; } } else { m_ Actual Clusterer =  Abstract Clusterer . make Copy ( m_ Clusterer ) ; m_ Actual Clusterer . build Clusterer ( to Filter Ignoring Attributes ) ; }  Instances filtered = new  Instances ( to Filter , _ NUM ) ;  Array List <  String > nominal_values = new  Array List <  String > ( m_ Actual Clusterer . number Of Clusters ( ) ) ; for ( int i = _ NUM ; i < m_ Actual Clusterer . number Of Clusters ( ) ; i ++ ) { nominal_values . add ( _ STR + ( i + _ NUM ) ) ; } filtered . insert Attribute At ( new  Attribute ( _ STR , nominal_values ) , filtered . num Attributes ( ) ) ; set Output Format ( filtered ) ; } for ( int i = _ NUM ; i < to Filter . num Instances ( ) ; i ++ ) { convert Instance ( to Filter . instance ( i ) ) ; } flush Input ( ) ; m_ New Batch = _ BOOL ; m_ First Batch Done = _ BOOL ; return ( num Pending Output ( ) != _ NUM ) ; }
public void add Component (  T component ) { components . add ( component ) ; }
public static  Ui Result open Url (  URI uri ) { return open Url ( uri . to String ( ) ) ; }
public  Byte Banded Raster (  Sample Model sample Model ,  Point origin ) { this ( sample Model , sample Model . create Data Buffer ( ) , new  Rectangle ( origin . x , origin . y , sample Model . get Width ( ) , sample Model . get Height ( ) ) , origin , null ) ; }
static boolean is Refresh Notification Registered (  Notification Listener client ,  Refresh Notification Type type ) { boolean is Registered = _ BOOL ;  Map <  Refresh Notification Type ,  Integer > notifications = null ; synchronized ( refresh Clients ) { notifications = (  Map <  Refresh Notification Type ,  Integer > ) refresh Clients . get ( client ) ; } if ( notifications != null ) {  Integer timer Notification Id = notifications . get ( type ) ; if ( timer Notification Id != null ) { is Registered = _ BOOL ; } } return is Registered ; }
private  Collection <  String > read Process Output (  Process proc ) throws  IOException {  Buffered Reader rdr = new  Buffered Reader ( new  Input Stream Reader ( proc . get Input Stream ( ) ) ) ;  Collection <  String > res = new  Array List < > ( ) ;  String s ; while ( ( s = rdr . read Line ( ) ) != null ) res . add ( s ) ; return res ; }
public void fill Header And Footer ( final  Http Servlet Request request , final  Http Servlet Response response , final  Map <  String ,  Object > data Model ) throws  Exception { fill Header ( request , response , data Model ) ; fill Footer ( data Model ) ; }
public void add Operand (  ISpace Predicate operand ) { if ( _operands List == null ) _operands List = new  Array List <  ISpace Predicate > ( ) ; _operands List . add ( operand ) ; }
public static  String decode (  String s ,  Type t ) { if ( s == null ) { throw new  Illegal Argument Exception ( ) ; } final int n = s . length ( ) ; if ( n == _ NUM ) { return s ; } if ( s . index Of ( _ STR ) < _ NUM ) { if ( t ==  Type .  QUERY_ PARAM ) { if ( s . index Of ( _ STR ) < _ NUM ) { return s ; } } else { return s ; } } else { if ( n < _ NUM ) { throw new  Illegal Argument Exception ( _ STR ) ; } if ( s . char At ( n - _ NUM ) == _ STR ) { throw new  Illegal Argument Exception ( _ STR + ( n - _ NUM ) ) ; } } if ( t == null ) { return decode ( s , n ) ; } switch ( t ) { case  HOST : return decode Host ( s , n ) ; case  QUERY_ PARAM : return decode Query Param ( s , n ) ; default : return decode ( s , n ) ; } }
public  Big Decimal calculate Total Collected Amt ( final  Bill Receipt Info bri , final  List <  Eg Bill Details > bill Det List ) throws  Invalid Account Head Exception { return bri . get Total Amount ( ) ; }
public void skip ( int count ) throws  IOException { int skip Count =  Math . min ( limit - position , count ) ; while ( _ BOOL ) { position += skip Count ; count -= skip Count ; if ( count == _ NUM ) break ; skip Count =  Math . min ( count , capacity ) ; require ( skip Count ) ; } }
public void test_concurrent_modification_insert ( ) { final  BTree btree ; {  Index Metadata md = new  Index Metadata (  UUID . random UUID ( ) ) ; md . set Branching Factor ( _ NUM ) ; btree =  BTree . create ( new  Simple Memory Raw Store ( ) , md ) ; btree . insert ( _ NUM , _ STR ) ; btree . insert ( _ NUM , _ STR ) ; btree . insert ( _ NUM , _ STR ) ; } {  ITuple Cursor2 <  String > cursor = new Cursor ( btree ) ; assert Equals ( new  Test Tuple <  String > ( _ NUM , _ STR ) , cursor . seek ( _ NUM ) ) ; assert Equals ( new  Test Tuple <  String > ( _ NUM , _ STR ) , cursor . tuple ( ) ) ; btree . insert ( _ NUM , _ STR ) ; assert Equals (  Test Key Builder . as Sort Key ( _ NUM ) , cursor . current Key ( ) ) ; assert Equals ( new  Test Tuple <  String > ( _ NUM , _ STR ) , cursor . tuple ( ) ) ; assert Equals ( new  Test Tuple <  String > ( _ NUM , _ STR ) , cursor . prior ( ) ) ; assert Equals ( new  Test Tuple <  String > ( _ NUM , _ STR ) , cursor . tuple ( ) ) ; btree . remove ( _ NUM ) ; assert Equals ( null , cursor . tuple ( ) ) ; assert Equals (  Test Key Builder . as Sort Key ( _ NUM ) , cursor . current Key ( ) ) ; assert Equals ( new  Test Tuple <  String > ( _ NUM , _ STR ) , cursor . next ( ) ) ; btree . remove ( _ NUM ) ; assert Equals ( null , cursor . tuple ( ) ) ; assert Equals (  Test Key Builder . as Sort Key ( _ NUM ) , cursor . current Key ( ) ) ; btree . insert ( _ NUM , _ STR ) ; assert Equals (  Test Key Builder . as Sort Key ( _ NUM ) , cursor . current Key ( ) ) ; assert Equals ( null , cursor . tuple ( ) ) ; assert Equals ( new  Test Tuple <  String > ( _ NUM , _ STR ) , cursor . next ( ) ) ; assert Equals ( new  Test Tuple <  String > ( _ NUM , _ STR ) , cursor . tuple ( ) ) ; } }
public void remove All Ims ( ) { ims . clear ( ) ; }
public void copy Reader (  String encoding ,  Reader r ) throws  IOException { super . set Content Encoding ( encoding ) ;  String s = read String ( r ) ; content = s . get Bytes ( encoding ) ; }
private void clear Dictionary Cache ( ) {  Map <  String ,  Dictionary > dictionary Caches = surrogate Key Gen . get Dictionary Caches ( ) ;  List <  Dictionary > reverse Dictionaries = new  Array List < > ( dictionary Caches . values ( ) ) ; for ( int i = _ NUM ; i < reverse Dictionaries . size ( ) ; i ++ ) {  Dictionary dictionary = reverse Dictionaries . get ( i ) ; dictionary . clear ( ) ; } }
public static  String to Type String (  Object [ ] arguments , int max Size ) { if ( arguments == null ) { return _ STR ; }  String Builder arg Buf = new  String Builder ( ) ; for ( int i = _ NUM ; i < arguments . length ; i ++ ) { if ( max Size != - _ NUM && arg Buf . length ( ) > max Size ) { arg Buf . append ( _ STR ) ; break ; } else { if ( i > _ NUM ) { arg Buf . append ( _ STR ) ; } arg Buf . append ( arguments [ i ] != null ? type Name ( arguments [ i ] ) : _ STR ) ; } } return arg Buf . to String ( ) ; }
public boolean rename File (  File old File ,  File new File ) { synchronized ( file Cache ) { if ( old File . rename To ( new File ) ) { validate File Cache ( ) ; return _ BOOL ; } return _ BOOL ; } }
public  Future < ? > execute (  Camera Command command ) { if ( m Closed ) { return  Futures . immediate Future ( null ) ; } synchronized ( m Lock ) { if ( m Executor == null ) { m Executor = m Executor Provider . get ( ) ; } check Not Null ( m Executor ) ; return m Executor . submit ( new  Command Runnable ( command ) ) ; } }
public int length ( ) { return text . length ( ) ; }
public static  String serialize Digest Response (  Map <  String ,  String > param Map ) {  String Builder sb = new  String Builder ( _ STR ) ; boolean prefix Comma = _ BOOL ; for (  Map .  Entry <  String ,  String > entry : param Map . entry Set ( ) ) { if ( ! prefix Comma ) { prefix Comma = _ BOOL ; } else { sb . append ( _ STR ) ; } sb . append ( entry . get Key ( ) ) ; sb . append ( _ STR ) ; sb . append ( entry . get Value ( ) ) ; } return sb . to String ( ) ; }
protected  Json Encoding find Encoding (  Media Type media Type ,  Multivalued Map <  String ,  Object > http Headers ) { return  Json Encoding .  UTF8 ; }
static  Buffered Image convert Image (  Buffered Image image ) { switch ( image . get Type ( ) ) { case  Buffered Image .  TYPE_ INT_ ARGB_ PRE : return image ; case  Buffered Image .  TYPE_4 BYTE_ ABGR : image . coerce Data ( _ BOOL ) ; return image ; }  Buffered Image converted Image = new  Buffered Image ( image . get Width ( ) , image . get Height ( ) ,  Buffered Image .  TYPE_ INT_ ARGB_ PRE ) ;  Graphics2 D g = converted Image . create Graphics ( ) ; g . set Color ( new java . awt .  Color ( _ NUM , _ NUM , _ NUM , _ NUM ) ) ; g . fill Rect ( _ NUM , _ NUM , image . get Width ( ) , image . get Height ( ) ) ; g . draw Image ( image , _ NUM , _ NUM , null ) ; g . dispose ( ) ; return converted Image ; }
public long start ( ) { start Time =  System . current Time Millis ( ) ; return start Time ; }
public void next ( ) { if ( iterator . has Next ( ) ) {  View current View = iterator . next ( ) ; if ( is Using Default Listener ( ) ) current View . set On Click Listener ( null ) ; if ( iterator . next Index ( ) < m Views . size ( ) ) {  View next View = m Views . get ( iterator . next Index ( ) ) ; if ( is Using Default Listener ( ) ) next View . set On Click Listener ( listener ) ;  Controller Animator animator = get Default Forward Animation ( ) ; animator . set Old View ( current View ) ; animator . set New View ( next View ) ; current View . start Animation ( animator ) ; if ( iterator . next Index ( ) == m Views . size ( ) - _ NUM ) if ( has Controller Listener ( ) ) m Listener . on End Reached ( ) ; } else { if ( m Loop ) { iterator = m Views . list Iterator ( ) ;  View next View = m Views . get ( _ NUM ) ; if ( m Use Default Listener ) next View . set On Click Listener ( listener ) ;  Controller Animator animator = get Default Forward Animation ( ) ; animator . set Old View ( current View ) ; animator . set New View ( next View ) ; current View . start Animation ( animator ) ; } } } }
public void cache Resolved Method (  Class clas ,  Class [ ] types ,  Method method ) { if (  Interpreter .  DEBUG )  Interpreter . debug ( _ STR + clas + _ STR + method ) ;  Signature Key sk = new  Signature Key ( clas , method . get Name ( ) , types ) ; if (  Modifier . is Static ( method . get Modifiers ( ) ) ) resolved Static Methods . put ( sk , method ) ; else resolved Object Methods . put ( sk , method ) ; }
private void destroy Beans (  Map <  String ,  Object > view Map ,  Map <  String ,  View Scope Context Object > context Map ) {  Array List <  String > removal Name List = new  Array List < > ( ) ; if ( context Map != null ) { for (  Map .  Entry <  String ,  View Scope Context Object > entry : context Map . entry Set ( ) ) {  String passivation Capable Id = entry . get Key ( ) ;  Contextual contextual = bean Manager . get Passivation Capable Bean ( passivation Capable Id ) ;  View Scope Context Object context Object = entry . get Value ( ) ;  Creational Context creational Context = bean Manager . create Creational Context ( contextual ) ; contextual . destroy ( view Map . get ( context Object . get Name ( ) ) , creational Context ) ; removal Name List . add ( context Object . get Name ( ) ) ; }  Iterator <  String > removal Names = removal Name List . iterator ( ) ; while ( removal Names . has Next ( ) ) {  String name = removal Names . next ( ) ; view Map . remove ( name ) ; } context Map . clear ( ) ; } }
public static void close ( @  Check For Null  Output Stream output Stream ) { if ( output Stream == null ) { return ; } try { output Stream . close ( ) ; } catch (  IOException e ) { } }
@  Override public  Node item ( int index ) { return ( nodes != null && index < nodes . size ( ) ) ? (  Node ) ( nodes . get ( index ) ) : null ; }
private int char To Visible Width ( char c , @  Jdk Constants .  Font Style int font Type , int current X ) { if ( c == _ STR ) { return _ NUM ; } if ( c == _ STR ) { return  Editor Util . next Tab Stop ( current X , this ) - current X ; } return  Editor Util . char Width ( c , font Type , this ) ; }
public  GTSEncoder ( long base Timestamp ) { this . base Timestamp = base Timestamp ; this . stream = new  Byte Array Output Stream ( ) ; this . wrapping Key = null ; }
public static  String encode ( final  Coordinate [ ] coords ) { long last Lat = _ NUM ; long last Lng = _ NUM ; final  String Buffer result = new  String Buffer ( ) ; for ( final  Coordinate point : coords ) { long lat =  Math . round ( point . y * _ NUM ) ; long lng =  Math . round ( point . x * _ NUM ) ; long d Lat = lat - last Lat ; long d Lng = lng - last Lng ; encode ( d Lat , result ) ; encode ( d Lng , result ) ; last Lat = lat ; last Lng = lng ; } return result . to String ( ) ; }
private void extract Weight Values (  List <  Synapse > synapses ) { int ex Weights = _ NUM ; int in Weights = _ NUM ; for (  Synapse s : synapses ) { double w = s . get Strength ( ) ; if ( w > _ NUM ) { ex Weights ++ ; } else { in Weights ++ ; } } weights [ _ NUM ] = new double [ ex Weights ] ; weights [ _ NUM ] = new double [ in Weights ] ; ex Weights = _ NUM ; in Weights = _ NUM ; if ( weights [ _ NUM ] . length != _ NUM ) { for (  Synapse s : synapses ) { double w = s . get Strength ( ) ; if ( w > _ NUM ) { weights [ _ NUM ] [ ex Weights ++ ] = w ; } else { weights [ _ NUM ] [ in Weights ++ ] = w ; } } } }
@  Override public void close ( ) { try { flush ( ) ; } catch (  AMLog Exception ale ) {  Debug . error ( table Name + _ STR + ale . get Message ( ) ) ; } if ( conn != null ) { try { conn . close ( ) ; } catch (  SQLException ce ) {  Debug . error ( table Name + _ STR , ce ) ; } } stop Buffer Timer ( ) ; }
public boolean contains (  List <  Integer > hashes ) {  Iterator <  Integer > ni = hashes . iterator ( ) ; for ( int i = _ NUM ; i < hash Functions ; ++ i ) { if ( ! test Bit ( ( int ) ( ( ni . next ( ) & _ NUM ) % ( filter . length * _ NUM ) ) ) ) { return _ BOOL ; } } return _ BOOL ; }
private void ensure Capacity ( int additional Data ) { if ( ( this . position + additional Data ) > this . byte Buffer . length ) { int new Length = ( int ) ( this . byte Buffer . length * _ NUM ) ; if ( new Length < ( this . byte Buffer . length + additional Data ) ) { new Length = this . byte Buffer . length + ( int ) ( additional Data * _ NUM ) ; } if ( new Length < this . byte Buffer . length ) { new Length = this . byte Buffer . length + additional Data ; } byte [ ] new Bytes = new byte [ new Length ] ;  System . arraycopy ( this . byte Buffer , _ NUM , new Bytes , _ NUM , this . byte Buffer . length ) ; this . byte Buffer = new Bytes ; } }
public boolean is Valid Number (  Phone Number number ) {  String region Code = get Region Code For Number ( number ) ; return is Valid Number For Region ( number , region Code ) ; }
private  String trim Url (  String uri ) { if ( uri == null ) return _ STR ; if ( uri . ends With ( _ STR ) ) uri = uri . substring ( _ NUM , uri . length ( ) - _ NUM ) ; return uri ; }
public  Pair <  Integer ,  List <  Long > > next ( ) { try { classes Processed ++ ;  Integer key = iterator . next ( ) ; long pos = classification Block RMA2 . get Pos ( key ) ; int count = classification Block RMA2 . get Sum ( key ) ; class Dump Reader . seek ( pos ) ;  List <  Long > list = new  Linked List < > ( ) ; for ( int i = _ NUM ; i < count ; i ++ ) list . add ( class Dump Reader . read Long ( ) ) ; return new  Pair < > ( key , list ) ; } catch (  Exception e ) {  Basic . caught ( e ) ; error = _ BOOL ; return null ; } }
public static  String add Alpha (  String original Color , double alpha ) { long alpha Fixed =  Math . round ( alpha * _ NUM ) ;  String alpha Hex =  Long . to Hex String ( alpha Fixed ) ; if ( alpha Hex . length ( ) == _ NUM ) { alpha Hex = _ STR + alpha Hex ; } original Color = original Color . replace ( _ STR , _ STR + alpha Hex ) ; return original Color ; }
public void stop ( ) { server . stop ( _ NUM ) ; }
protected  Date Time Data parse (  String str , int duration Type ) throws  Schema Date Time Exception { int len = str . length ( ) ;  Date Time Data date = new  Date Time Data ( str , this ) ; int start = _ NUM ; char c = str . char At ( start ++ ) ; if ( c != _ STR && c != _ STR ) { throw new  Schema Date Time Exception ( ) ; } else { date . utc = ( c == _ STR ) ? _ STR : _ NUM ; if ( c == _ STR && str . char At ( start ++ ) != _ STR ) { throw new  Schema Date Time Exception ( ) ; } } int negate = _ NUM ; if ( date . utc == _ STR ) { negate = - _ NUM ; } boolean designator = _ BOOL ; int end Date = index Of ( str , start , len , _ STR ) ; if ( end Date == - _ NUM ) { end Date = len ; } else if ( duration Type ==  YEARMONTHDURATION_ TYPE ) { throw new  Schema Date Time Exception ( ) ; } int end = index Of ( str , start , end Date , _ STR ) ; if ( end != - _ NUM ) { if ( duration Type ==  DAYTIMEDURATION_ TYPE ) { throw new  Schema Date Time Exception ( ) ; } date . year = negate * parse Int ( str , start , end ) ; start = end + _ NUM ; designator = _ BOOL ; } end = index Of ( str , start , end Date , _ STR ) ; if ( end != - _ NUM ) { if ( duration Type ==  DAYTIMEDURATION_ TYPE ) { throw new  Schema Date Time Exception ( ) ; } date . month = negate * parse Int ( str , start , end ) ; start = end + _ NUM ; designator = _ BOOL ; } end = index Of ( str , start , end Date , _ STR ) ; if ( end != - _ NUM ) { if ( duration Type ==  YEARMONTHDURATION_ TYPE ) { throw new  Schema Date Time Exception ( ) ; } date . day = negate * parse Int ( str , start , end ) ; start = end + _ NUM ; designator = _ BOOL ; } if ( len == end Date && start != len ) { throw new  Schema Date Time Exception ( ) ; } if ( len != end Date ) { end = index Of ( str , ++ start , len , _ STR ) ; if ( end != - _ NUM ) { date . hour = negate * parse Int ( str , start , end ) ; start = end + _ NUM ; designator = _ BOOL ; } end = index Of ( str , start , len , _ STR ) ; if ( end != - _ NUM ) { date . minute = negate * parse Int ( str , start , end ) ; start = end + _ NUM ; designator = _ BOOL ; } end = index Of ( str , start , len , _ STR ) ; if ( end != - _ NUM ) { date . second = negate * parse Second ( str , start , end ) ; start = end + _ NUM ; designator = _ BOOL ; } if ( start != len || str . char At ( -- start ) == _ STR ) { throw new  Schema Date Time Exception ( ) ; } } if ( ! designator ) { throw new  Schema Date Time Exception ( ) ; } return date ; }
final void copy Into Local State (  Operand [ ] _local State ) { local State = new  Operand [ _local State . length ] ;  System . arraycopy ( _local State , _ NUM , local State , _ NUM , _local State . length ) ; set Local Known ( ) ; }
@  Suppress Warnings ( _ STR ) private  Hash Map <  String ,  DBObject > load DBObjects (  Class object Class ) {  Hash Map <  String ,  DBObject > object Map = new  Hash Map <  String ,  DBObject > ( ) ;  DBObject db Object = new  DBObject ( this , object Class ) ;  String object To Load = s_logger . localize Message ( _ STR ) ;  String objects To Load = s_logger . localize Message ( _ STR ) ;  String sql Load Headers = null ;  String sql Load Contents = null ; if ( db Object != null ) { object To Load = db Object . get Object Type ( ) ; objects To Load = db Object . get Object Types ( ) ; sql Load Headers = db Object . get Load Header SQL ( ) ; sql Load Contents = db Object . get Load Content SQL ( ) ; } s_logger . log (  Level .  FINE , _ STR , new  Object [ ] { objects To Load , get Direction ( ) } ) ;  Prepared Statement Wrapper stmt Load Headers = set Prepared Statement ( sql Load Headers ) ;  Prepared Statement Wrapper stmt Load Contents = set Prepared Statement ( sql Load Contents ) ; int counter = _ NUM ; if ( db Object != null ) {  String sql = db Object . get Load Object SQL ( ) ;  Statement stmt = set Statement ( ) ;  Result Set rs = execute Query ( stmt , sql ) ; while ( get Result Set Next ( rs ) ) {  String s = get Result Set String ( rs , _ STR ) ; if ( ! object Map . contains Key ( s ) ) {  DBObject obj = new  DBObject ( this , object Class , s ) ; obj . populate ( stmt Load Headers , stmt Load Contents ) ; if ( obj . is Populated ( ) ) { object Map . put ( s . to Upper Case ( ) , obj ) ; counter ++ ; } } } release Result Set ( rs ) ; release Statement ( stmt ) ; } release Prepared Statement ( stmt Load Headers ) ; release Prepared Statement ( stmt Load Contents ) ; if ( counter == _ NUM ) s_logger . log (  Level .  FINE , _ STR , new  Object [ ] {  Integer . to String ( counter ) , object To Load } ) ; else s_logger . log (  Level .  FINE , _ STR , new  Object [ ] {  Integer . to String ( counter ) , objects To Load } ) ; s_logger . flush ( ) ; return object Map ; }
protected  Object attempt Read Response (  Connection cnx ) throws  Exception {  Message msg = create Response Message ( ) ; if ( msg != null ) { msg . set Comms ( cnx . get Socket ( ) , cnx . get Input Stream ( ) , cnx . get Output Stream ( ) , cnx . get Comm Buffer ( ) , cnx . get Stats ( ) ) ; if ( msg instanceof  Chunked Message ) { try { return process Response ( msg , cnx ) ; } finally { msg . unset Comms ( ) ; process Secure Bytes ( cnx , msg ) ; } } else { try { msg . recv ( ) ; } finally { msg . unset Comms ( ) ; process Secure Bytes ( cnx , msg ) ; } return process Response ( msg , cnx ) ; } } else { return null ; } }
public synchronized boolean add (  E e , boolean has Next ) { while ( m Internal Queue . size ( ) >= m Max Size && ! m Closed ) { notify All ( ) ; try { wait (  TIMEOUT ) ; } catch (  Interrupted Exception e1 ) { m Closed = _ BOOL ;  Program State . check Abort ( ) ; throw new  Illegal State Exception ( _ STR , e1 ) ; }  Program State . check Abort ( ) ; } if ( m Closed ) { return _ BOOL ; } final boolean was Empty = m Internal Queue . is Empty ( ) ; m Has Next = has Next ; m Internal Queue . add ( e ) ; if ( was Empty ) { notify All ( ) ; } return _ BOOL ; }
public  Translatable Component ( ) { }
public  Str Builder insert ( int index , boolean value ) { validate Index ( index ) ; if ( value ) { ensure Capacity ( size + _ NUM ) ;  System . arraycopy ( buffer , index , buffer , index + _ NUM , size - index ) ; buffer [ index ++ ] = _ STR ; buffer [ index ++ ] = _ STR ; buffer [ index ++ ] = _ STR ; buffer [ index ] = _ STR ; size += _ NUM ; } else { ensure Capacity ( size + _ NUM ) ;  System . arraycopy ( buffer , index , buffer , index + _ NUM , size - index ) ; buffer [ index ++ ] = _ STR ; buffer [ index ++ ] = _ STR ; buffer [ index ++ ] = _ STR ; buffer [ index ++ ] = _ STR ; buffer [ index ] = _ STR ; size += _ NUM ; } return this ; }
public boolean has Nature And Weapon (  Nature nature ,  String weapon ) { return this . nature == nature && ( ( weapon == null && this . weapon == null ) || ( weapon != null && weapon . equals ( this . weapon ) ) ) ; }
public void dump (  String info Msg ) { storage . get Online Members ( ) ; storage . get Offline Members ( ) ; storage . get Offline And Equal Members ( ) ; storage . get My Initializing ID ( ) ; storage . get My Persistent ID ( ) ; final  String Builder buf = new  String Builder ( _ NUM ) ; if ( info Msg != null ) { buf . append ( info Msg ) ; buf . append ( _ STR ) ; } buf . append ( _ STR ) ; buf . append ( storage . get My Persistent ID ( ) ) ; buf . append ( _ STR ) ; buf . append ( storage . get My Initializing ID ( ) ) ; buf . append ( _ STR ) ; for (  Persistent Member ID id : storage . get Online Members ( ) ) { buf . append ( _ STR ) ; buf . append ( id ) ; buf . append ( _ STR ) ; } buf . append ( _ STR ) ; for (  Persistent Member ID id : storage . get Offline Members ( ) ) { buf . append ( _ STR ) ; buf . append ( id ) ; buf . append ( _ STR ) ; } buf . append ( _ STR ) ; for (  Persistent Member ID id : storage . get Offline And Equal Members ( ) ) { buf . append ( _ STR ) ; buf . append ( id ) ; buf . append ( _ STR ) ; } logger . debug ( buf . to String ( ) ) ; }
private  Node <  K ,  V > find Node (  Object key ) { if ( key == null ) throw new  Null Pointer Exception ( ) ;  Comparator < ? super  K > cmp = comparator ; outer : for ( ; ; ) { for (  Node <  K ,  V > b = find Predecessor ( key , cmp ) , n = b . next ; ; ) {  Object v ; int c ; if ( n == null ) break outer ;  Node <  K ,  V > f = n . next ; if ( n != b . next ) break ; if ( ( v = n . value ) == null ) { n . help Delete ( b , f ) ; break ; } if ( b . value == null || v == n ) break ; if ( ( c = cpr ( cmp , key , n . key ) ) == _ NUM ) return n ; if ( c < _ NUM ) break outer ; b = n ; n = f ; } } return null ; }
static  Sort parse Sort ( long timestamp Sec ,  Index State state ,  List <  Object > fields ,  List <  String > sort Field Names ,  Map <  String ,  Field Def > dynamic Fields ) {  List <  Sort Field > sort Fields = new  Array List <  Sort Field > ( ) ; for (  Object _sub : fields ) {  Request sub = (  Request ) _sub ;  String field Name = sub . get String ( _ STR ) ;  Sort Field sf ; if ( sort Field Names != null ) { sort Field Names . add ( field Name ) ; } if ( field Name . equals ( _ STR ) ) { sf =  Sort Field .  FIELD_ DOC ; } else if ( field Name . equals ( _ STR ) ) { sf =  Sort Field .  FIELD_ SCORE ; } else {  Field Def fd ; if ( dynamic Fields != null ) { fd = dynamic Fields . get ( field Name ) ; } else { fd = null ; } if ( fd == null ) { fd = state . get Field ( field Name ) ; } if ( fd == null ) { sub . fail ( _ STR , _ STR + field Name + _ STR ) ; fd = null ; } if ( fd . value Source != null ) { sf = fd . value Source . get Sort Field ( sub . get Boolean ( _ STR ) ) ; } else if ( fd . value Type ==  Field Def .  Field Value Type .  LAT_ LON ) { if ( fd . field Type . doc Values Type ( ) ==  Doc Values Type .  NONE ) { sub . fail ( _ STR , _ STR + field Name + _ STR ) ; }  Request sub2 = sub . get Struct ( _ STR ) ; sf =  Lat Lon Doc Values Field . new Distance Sort ( field Name , sub2 . get Double ( _ STR ) , sub2 . get Double ( _ STR ) ) ; } else { if ( ( fd . field Type != null && fd . field Type . doc Values Type ( ) ==  Doc Values Type .  NONE ) || ( fd . field Type == null && fd . value Source == null ) ) { sub . fail ( _ STR , _ STR + field Name + _ STR ) ; } if ( fd . multi Valued ) {  String selector String = sub . get Enum ( _ STR ) ; if ( fd . value Type ==  Field Def .  Field Value Type .  ATOM ) {  Sorted Set Selector .  Type selector ; if ( selector String . equals ( _ STR ) ) { selector =  Sorted Set Selector .  Type .  MIN ; } else if ( selector String . equals ( _ STR ) ) { selector =  Sorted Set Selector .  Type .  MAX ; } else if ( selector String . equals ( _ STR ) ) { selector =  Sorted Set Selector .  Type .  MIDDLE_ MIN ; } else if ( selector String . equals ( _ STR ) ) { selector =  Sorted Set Selector .  Type .  MIDDLE_ MAX ; } else { assert _ BOOL ; selector = null ; } sf = new  Sorted Set Sort Field ( field Name , sub . get Boolean ( _ STR ) , selector ) ; } else if ( fd . value Type ==  Field Def .  Field Value Type .  INT ) { sf = new  Sorted Numeric Sort Field ( field Name ,  Sort Field .  Type .  INT , sub . get Boolean ( _ STR ) , parse Numeric Selector ( sub , selector String ) ) ; } else if ( fd . value Type ==  Field Def .  Field Value Type .  LONG ) { sf = new  Sorted Numeric Sort Field ( field Name ,  Sort Field .  Type .  LONG , sub . get Boolean ( _ STR ) , parse Numeric Selector ( sub , selector String ) ) ; } else if ( fd . value Type ==  Field Def .  Field Value Type .  FLOAT ) { sf = new  Sorted Numeric Sort Field ( field Name ,  Sort Field .  Type .  FLOAT , sub . get Boolean ( _ STR ) , parse Numeric Selector ( sub , selector String ) ) ; } else if ( fd . value Type ==  Field Def .  Field Value Type .  DOUBLE ) { sf = new  Sorted Numeric Sort Field ( field Name ,  Sort Field .  Type .  DOUBLE , sub . get Boolean ( _ STR ) , parse Numeric Selector ( sub , selector String ) ) ; } else { sub . fail ( _ STR , _ STR + field Name + _ STR + fd . value Type ) ; assert _ BOOL ; sf = null ; } } else {  Sort Field .  Type sort Type ; if ( fd . value Type ==  Field Def .  Field Value Type .  ATOM ) { sort Type =  Sort Field .  Type .  STRING ; } else if ( fd . value Type ==  Field Def .  Field Value Type .  LONG || fd . value Type ==  Field Def .  Field Value Type .  DATE_ TIME ) { sort Type =  Sort Field .  Type .  LONG ; } else if ( fd . value Type ==  Field Def .  Field Value Type .  INT ) { sort Type =  Sort Field .  Type .  INT ; } else if ( fd . value Type ==  Field Def .  Field Value Type .  DOUBLE ) { sort Type =  Sort Field .  Type .  DOUBLE ; } else if ( fd . value Type ==  Field Def .  Field Value Type .  FLOAT ) { sort Type =  Sort Field .  Type .  FLOAT ; } else { sub . fail ( _ STR , _ STR + field Name + _ STR + fd . value Type ) ; assert _ BOOL ; sort Type = null ; } sf = new  Sort Field ( field Name , sort Type , sub . get Boolean ( _ STR ) ) ; } } boolean has Missing Last = sub . has Param ( _ STR ) ; boolean missing Last = sub . get Boolean ( _ STR ) ; if ( fd . value Type ==  Field Def .  Field Value Type .  ATOM ) { if ( missing Last ) { sf . set Missing Value (  Sort Field .  STRING_ LAST ) ; } else { sf . set Missing Value (  Sort Field .  STRING_ FIRST ) ; } } else if ( fd . value Type ==  Field Def .  Field Value Type .  INT ) { sf . set Missing Value ( missing Last ?  Integer .  MAX_ VALUE :  Integer .  MIN_ VALUE ) ; } else if ( fd . value Type ==  Field Def .  Field Value Type .  LONG ) { sf . set Missing Value ( missing Last ?  Long .  MAX_ VALUE :  Long .  MIN_ VALUE ) ; } else if ( fd . value Type ==  Field Def .  Field Value Type .  FLOAT ) { sf . set Missing Value ( missing Last ?  Float .  POSITIVE_ INFINITY :  Float .  NEGATIVE_ INFINITY ) ; } else if ( fd . value Type ==  Field Def .  Field Value Type .  DOUBLE ) { sf . set Missing Value ( missing Last ?  Double .  POSITIVE_ INFINITY :  Double .  NEGATIVE_ INFINITY ) ; } else if ( has Missing Last ) { sub . fail ( _ STR , _ STR + field Name + _ STR + sf . get Type ( ) ) ; } } sort Fields . add ( sf ) ; } return new  Sort ( sort Fields . to Array ( new  Sort Field [ sort Fields . size ( ) ] ) ) ; }
public synchronized void open ( ) { }
@  Not Null private  Optional <  Type Conversion > find Conversion From Db Value ( @  Not Null  Type source , @  Not Null  Type target ) { if ( is Assignable ( target , source ) ) return  Optional . of (  Type Conversion . identity ( ) ) ;  Optional <  Type Conversion > direct Conversion = type Conversion Registry . find Conversion From Db Value ( source , target ) ; if ( direct Conversion . is Present ( ) ) return direct Conversion ;  Optional <  Type Conversion > array Conversion = find Array Conversion ( source , target ) ; if ( array Conversion . is Present ( ) ) return array Conversion ;  Optional <  Type Conversion > optional Conversion = find Optional Conversion ( source , target ) ; if ( optional Conversion . is Present ( ) ) return optional Conversion ;  Optional <  Type Conversion > enum Conversion = find Enum Conversion ( target ) ; if ( enum Conversion . is Present ( ) ) return enum Conversion ; return  Optional . empty ( ) ; }
private boolean advance Api Up To (  Tree Set <  Area Panel Info > sorted Api Tree ,  Area Panel Info api , int time ) {  Area Panel ap = api . ap ( ) ;  Time Tree root Tt = ap . get Time Tree ( ) ;  Time Tree tt = root Tt . get Encompassig Time Tree Or Max Time Tree Before Time ( time , _ BOOL ) ; if ( tt == null || tt . id == api . curr Tt Id ) return _ BOOL ; sorted Api Tree . remove ( api ) ; if ( api . set Tt ( tt ,  Integer .  MAX_ VALUE ) ) sorted Api Tree . add ( api ) ; return _ BOOL ; }
@  Request Mapping ( value = { _ STR , _ STR } , method =  Request Method .  POST ) @  Response Body public  Rest Wrapper update ( @  Model Attribute ( _ STR ) @  Valid  User Roles user Roles ,  Binding Result binding Result ,  Principal principal ) {  Rest Wrapper rest Wrapper = null ; if ( binding Result . has Errors ( ) ) {  Binding Result Error binding Result Error = new  Binding Result Error ( ) ; return binding Result Error . error Message ( binding Result ) ; } try { com . wipro . ats . bdre . md . dao . jpa .  User Roles jpa User Roles = new com . wipro . ats . bdre . md . dao . jpa .  User Roles ( ) ; jpa User Roles . set User Role Id ( user Roles . get User Role Id ( ) ) ; jpa User Roles . set Role ( user Roles . get Role ( ) ) ;  Users users = new  Users ( ) ; users . set Username ( user Roles . get Username ( ) ) ; jpa User Roles . set Users ( users ) ; user Roles DAO . update ( jpa User Roles ) ; rest Wrapper = new  Rest Wrapper ( user Roles ,  Rest Wrapper .  OK ) ;  LOGGER . info ( _ STR + user Roles . get User Role Id ( ) + _ STR + principal . get Name ( ) + user Roles ) ; } catch (  Exception e ) {  LOGGER . error ( e ) ; rest Wrapper = new  Rest Wrapper ( e . get Message ( ) ,  Rest Wrapper .  ERROR ) ; } return rest Wrapper ; }
private void send Request Option ( ) throws  IOException {  String request = _ STR + m Parameters . host + _ STR + m Parameters . port + m Parameters . path + _ STR + add Headers ( ) ;  Log . i (  TAG , request . substring ( _ NUM , request . index Of ( _ STR ) ) ) ; m Output Stream . write ( request . get Bytes ( _ STR ) ) ;  Response . parse Response ( m Buffered Reader ) ; }
@  Override public  Result do Comparison Test ( final  Properties properties ) throws  Exception { final long timeout =  Long . parse Long ( properties . get Property (  Test Options .  TIMEOUT ) ) ; final int nresources =  Integer . parse Int ( properties . get Property (  Test Options .  NRESOURCES ) ) ; final int min Locks =  Integer . parse Int ( properties . get Property (  Test Options .  MIN_ LOCKS ) ) ; final int max Locks =  Integer . parse Int ( properties . get Property (  Test Options .  MAX_ LOCKS ) ) ; final int ntrials =  Integer . parse Int ( properties . get Property (  Test Options .  NTRIALS ) ) ; final int key Len =  Integer . parse Int ( properties . get Property (  Test Options .  KEYLEN ) ) ; final int nops =  Integer . parse Int ( properties . get Property (  Test Options .  NOPS ) ) ; final double failure Rate =  Double . parse Double ( properties . get Property (  Test Options .  FAILURE_ RATE ) ) ;  Result result = do Concurrent Client Test ( journal , timeout , nresources , min Locks , max Locks , ntrials , key Len , nops , failure Rate ) ; return result ; }
public static void print Thread Info (  Print Writer stream ,  String title ) { final int  STACK_ DEPTH = _ NUM ; boolean contention = thread Bean . is Thread Contention Monitoring Enabled ( ) ; long [ ] thread Ids = thread Bean . get All Thread Ids ( ) ; stream . println ( _ STR + title ) ; stream . println ( thread Ids . length + _ STR ) ; for ( long tid : thread Ids ) {  Thread Info info = thread Bean . get Thread Info ( tid ,  STACK_ DEPTH ) ; if ( info == null ) { stream . println ( _ STR ) ; continue ; } stream . println ( _ STR + get Task Name ( info . get Thread Id ( ) , info . get Thread Name ( ) ) + _ STR ) ;  Thread .  State state = info . get Thread State ( ) ; stream . println ( _ STR + state ) ; stream . println ( _ STR + info . get Blocked Count ( ) ) ; stream . println ( _ STR + info . get Waited Count ( ) ) ; if ( contention ) { stream . println ( _ STR + info . get Blocked Time ( ) ) ; stream . println ( _ STR + info . get Waited Time ( ) ) ; } if ( state ==  Thread .  State .  WAITING ) { stream . println ( _ STR + info . get Lock Name ( ) ) ; } else if ( state ==  Thread .  State .  BLOCKED ) { stream . println ( _ STR + info . get Lock Name ( ) ) ; stream . println ( _ STR + get Task Name ( info . get Lock Owner Id ( ) , info . get Lock Owner Name ( ) ) ) ; } stream . println ( _ STR ) ; for (  Stack Trace Element frame : info . get Stack Trace ( ) ) { stream . println ( _ STR + frame . to String ( ) ) ; } } stream . flush ( ) ; }
public void add Delete (  IResource delete ) { if ( f Delete == null ) f Delete = new  Array List <  IResource > ( _ NUM ) ; f Delete . add ( delete ) ; if ( f Ignore Count == _ NUM ) { internal Add ( new  Delete Description ( delete ) ) ; } }
public static double max ( final double a , final double b ) { if ( a > b ) { return a ; } if ( a < b ) { return b ; } if ( a != b ) { return  Double .  Na N ; } long bits =  Double . double To Raw Long Bits ( a ) ; if ( bits == _ NUM ) { return b ; } return a ; }
@  Override public void write External (  Object Output out ) throws  IOException { super . write External ( out ) ; out . write Object ( approximation ) ; }
public void add (  String method Name ,  List <  Expression > parameters ) { chain . add ( new  Dot Expression Item ( method Name , parameters , _ BOOL ) ) ; }
public static  Request request ( ) { return thread Local . get ( ) ; }
private void schedule Commercial ( int length ) {  Long delay = commercial Delay . get Setting Value ( ) ; if ( delay == null ) { set Commercial Result ( _ STR ) ; clear Commercial Buttons Selection ( ) ; } else { scheduled Commercial Time =  System . current Time Millis ( ) + delay * _ NUM ; scheduled Commercial Length = length ; update ( ) ; } }
public int hash Code ( ) { long bits =  Double . double To Long Bits ( m00 ) ; bits = bits * _ NUM +  Double . double To Long Bits ( m01 ) ; bits = bits * _ NUM +  Double . double To Long Bits ( m02 ) ; bits = bits * _ NUM +  Double . double To Long Bits ( m10 ) ; bits = bits * _ NUM +  Double . double To Long Bits ( m11 ) ; bits = bits * _ NUM +  Double . double To Long Bits ( m12 ) ; return ( ( ( int ) bits ) ^ ( ( int ) ( bits > > _ NUM ) ) ) ; }
public void unsubscribe (  AWSIot Message message ) throws  AWSIot Exception { try { unsubscribe Topic ( message ) ; } catch (  Aws Iot Retryable Exception e ) { if ( client . get Max Offline Queue Size ( ) > _ NUM && unsubscribe Queue . size ( ) < client . get Max Offline Queue Size ( ) ) { unsubscribe Queue . add ( message ) ; } else {  LOGGER . info ( _ STR + message . get Topic ( ) ) ; throw new  AWSIot Exception ( e ) ; } } }
public static boolean is Digital Unix ( ) { return os Name . index Of ( _ STR ) > - _ NUM ; }
public void client Disconnect ( ) { try {  Out Http App response Stream = _response Stream ; if ( response Stream != null ) { response Stream . close ( ) ; } } catch (  Exception e ) { log . log (  Level .  FINER , e . to String ( ) , e ) ; }  Connection Tcp conn = conn Tcp ( ) ; if ( conn != null ) { conn . client Disconnect ( ) ; } kill Keepalive ( _ STR ) ; }
public boolean ends With (  Name n ) { if ( n instanceof  Compound Name ) { return ( impl . ends With ( n . size ( ) , n . get All ( ) ) ) ; } else { return _ BOOL ; } }
private int calculate Total Height ( float star Size , int number Of Stars , float stars Separation , boolean padding ) { return  Math . round ( star Size ) + ( padding ? get Padding Top ( ) + get Padding Bottom ( ) : _ NUM ) ; }
@  Suppress Warnings ( _ STR ) private static boolean is Regex (  String s ) { try {  Pattern . compile ( s ) ; } catch (  Pattern Syntax Exception e ) { return _ BOOL ; } return _ BOOL ; }
public static void flush ( ) { clear Buffer ( ) ; try { out . flush ( ) ; } catch (  IOException e ) { e . print Stack Trace ( ) ; } }
private  String attach Footer To Text (  String content ) throws  Messaging Exception ,  IOException {  String Builder builder = new  String Builder ( content ) ; ensure Trailing Carriage Return ( content , builder ) ; builder . append ( get Footer Text ( ) ) ; return builder . to String ( ) ; }
public static  Sentence make ( final  Connective connective , final  Sentence ... children2 ) { return make ( connective ,  Arrays . as List ( children2 ) ) ; }
public synchronized void init ( ) { init = _ BOOL ; for (  String map Name : store . get Map Names ( ) ) { if ( map Name . starts With ( _ STR ) ) {  MVMap <  Object ,  Integer > temp = open Temp Map ( map Name ) ; store . remove Map ( temp ) ; } } synchronized ( undo Log ) { if ( undo Log . size ( ) > _ NUM ) { for (  Long key : undo Log . key Set ( ) ) { int transaction Id = get Transaction Id ( key ) ; open Transactions . set ( transaction Id ) ; } } } }
public static  TDouble Double Hash Map create Cumulative Histogram (  TDouble Double Hash Map histogram ) { double [ ] keys = histogram . keys ( ) ;  Arrays . sort ( keys ) ; double sum = _ NUM ; for ( double key : keys ) { double val = histogram . get ( key ) ; sum += val ; histogram . put ( key , sum ) ; } return histogram ; }
protected  Date Time Data parse (  String str ) throws  Schema Date Time Exception {  Date Time Data date = new  Date Time Data ( str , this ) ; int len = str . length ( ) ; int end = index Of ( str , _ NUM , len , _ STR ) ; int date End = get Date ( str , _ NUM , end , date ) ; get Time ( str , end + _ NUM , len , date ) ; if ( date End != end ) { throw new  Runtime Exception ( str + _ STR + _ STR ) ; } validate Date Time ( date ) ; save Unnormalized ( date ) ; if ( date . utc != _ NUM && date . utc != _ STR ) { normalize ( date ) ; } return date ; }
void add Attribute Values (  String attr Name ,  Set values ) throws  SMSException { if ( attr Name != null && values != null && ! values . is Empty ( ) ) {  Map attrs = get Attributes ( ) ;  Set orig Values = (  Set ) attrs . get ( attr Name ) ;  Set new Values = new  Hash Set ( values ) ; if ( orig Values != null && ! orig Values . is Empty ( ) ) { new Values . add All ( orig Values ) ; }  Map new Attrs = new  Hash Map ( ) ; new Attrs . put ( attr Name , new Values ) ; set Attributes ( new Attrs ) ; } }
Segment Manager commit Index ( long commit Index ) { this . commit Index =  Math . max ( this . commit Index , commit Index ) ; return this ; }
public void finish Fragments ( ) { for (  Fragment comment : closing Fragments ) { finish Fragment ( comment ) ; } closing Fragments . clear ( ) ; }
private final void _write UTF8 Segments ( byte [ ] utf8 , int offset , int total Len ) throws  IOException ,  Json Generation Exception { do { int len =  Math . min ( _output Max Contiguous , total Len ) ; _write UTF8 Segment ( utf8 , offset , len ) ; offset += len ; total Len -= len ; } while ( total Len > _ NUM ) ; }
public  Collection <  Node > matching Scenarios And Examples ( final  Feature feature ) { final  List <  Scenario Definition > all Scenarios = feature . get Scenario Definitions ( ) ; final  List <  Node > matching Scenarios And Examples = new  Linked List <  Node > ( ) ; for ( final  Scenario Definition scenario : all Scenarios ) { final  Set <  Tag > all Tags For Scenario = new  Hash Set <  Tag > ( scenario . get Tags ( ) ) ; all Tags For Scenario . add All ( feature . get Tags ( ) ) ; if ( scenario instanceof  Scenario Outline ) { matching Scenarios And Examples . add All ( matching Examples ( (  Scenario Outline ) scenario , all Tags For Scenario ) ) ; } else { if ( matches ( all Tags For Scenario ) ) { matching Scenarios And Examples . add ( scenario ) ; } } } return matching Scenarios And Examples ; }
private boolean traverse (  Tree tree ,  Node Ref node , int [ ] operator Number , boolean flip ) { boolean update = _ BOOL ; int node Num = node . get Number ( ) ;  Node Ref parent = tree . get Parent ( node ) ; if ( operator Number != null ) { operator Number [ _ NUM ] = - _ NUM ; } if ( parent != null && update Node [ node Num ] ) { final double branch Rate = branch Rate Model . get Branch Rate ( tree , node ) ; final double branch Time = branch Rate * ( tree . get Node Height ( parent ) - tree . get Node Height ( node ) ) ; if ( branch Time < _ NUM ) { throw new  Runtime Exception ( _ STR + branch Time ) ; } if ( flip ) { matrix Buffer Helper . flip Offset ( node Num ) ; } final int eigen Index = _ NUM ; final int update Count = branch Update Count [ eigen Index ] ; matrix Update Indices [ eigen Index ] [ update Count ] = matrix Buffer Helper . get Offset Index ( node Num ) ; branch Lengths [ eigen Index ] [ update Count ] = branch Time ; branch Update Count [ eigen Index ] ++ ; update = _ BOOL ; } if ( ! tree . is External ( node ) ) {  Node Ref child1 = tree . get Child ( node , _ NUM ) ; final int [ ] op1 = { - _ NUM } ; final boolean update1 = traverse ( tree , child1 , op1 , flip ) ;  Node Ref child2 = tree . get Child ( node , _ NUM ) ; final int [ ] op2 = { - _ NUM } ; final boolean update2 = traverse ( tree , child2 , op2 , flip ) ; if ( update1 || update2 ) { int x = operation Count [ operation List Count ] *  Beagle .  OPERATION_ TUPLE_ SIZE ; if ( flip ) { partial Buffer Helper . flip Offset ( node Num ) ; } final int [ ] operations = this . operations [ operation List Count ] ; operations [ x ] = partial Buffer Helper . get Offset Index ( node Num ) ; if ( use Scale Factors ) { int n = node Num - tip Count ; if ( recompute Scale Factors ) { scale Buffer Helper . flip Offset ( n ) ; scale Buffer Indices [ n ] = scale Buffer Helper . get Offset Index ( n ) ; operations [ x + _ NUM ] = scale Buffer Indices [ n ] ; operations [ x + _ NUM ] =  Beagle .  NONE ; } else { operations [ x + _ NUM ] =  Beagle .  NONE ; operations [ x + _ NUM ] = scale Buffer Indices [ n ] ; } } else { if ( use Auto Scaling ) { scale Buffer Indices [ node Num - tip Count ] = partial Buffer Helper . get Offset Index ( node Num ) ; } operations [ x + _ NUM ] =  Beagle .  NONE ; operations [ x + _ NUM ] =  Beagle .  NONE ; } operations [ x + _ NUM ] = partial Buffer Helper . get Offset Index ( child1 . get Number ( ) ) ; operations [ x + _ NUM ] = matrix Buffer Helper . get Offset Index ( child1 . get Number ( ) ) ; operations [ x + _ NUM ] = partial Buffer Helper . get Offset Index ( child2 . get Number ( ) ) ; operations [ x + _ NUM ] = matrix Buffer Helper . get Offset Index ( child2 . get Number ( ) ) ; operation Count [ operation List Count ] ++ ; update = _ BOOL ; } } return update ; }
public long next ( ) { long result = - _ NUM ; if ( cache < _ NUM && buffer Elements > _ NUM ) { result = get Next From Buffer ( ) ; buffer Elements -- ; } else { result = cache ; cache = - _ NUM ; } if ( ! cs . is Empty ( ) ) { long first = cs . first ( ) ; if ( result > first || result == - _ NUM ) { cs . remove ( first ) ; cache = result ; result = first ; } } if ( result == - _ NUM ) { throw new  No Such Element Exception ( ) ; }  Assert . check ( previous < result ,  EC .  GENERAL ) ; previous = result ; read Elements ++ ; return result ; }
public boolean is Set Queue Size ( ) { return __isset_bit_vector . get ( __ QUEUESIZE_ ISSET_ ID ) ; }
public void request Contact Capabilities (  Set <  Contact Id > contacts ) throws  Rcs Service Not Registered Exception ,  Rcs Service Not Available Exception ,  Rcs Generic Exception { if ( m Api == null ) { throw new  Rcs Service Not Available Exception ( ) ; } if ( contacts == null || contacts . is Empty ( ) ) { throw new  Rcs Illegal Argument Exception ( _ STR ) ; } try { m Api . request Contact Capabilities2 ( new  Array List < > ( contacts ) ) ; } catch (  Exception e ) {  Rcs Illegal Argument Exception . assert Exception ( e ) ;  Rcs Service Not Registered Exception . assert Exception ( e ) ; throw new  Rcs Generic Exception ( e ) ; } }
private static  String to String ( double coeff ) { final  String c =  Double . to String ( coeff ) ; if ( c . ends With ( _ STR ) ) { return c . substring ( _ NUM , c . length ( ) - _ NUM ) ; } else { return c ; } }
public static final  Index Created Event create Test Index Creation Status With Bulk Data Hit ( ) {  Index Created Event to Return = new  Index Created Event (  UUID . random UUID ( ) , new  Date ( ) , new  Date ( ) , create Test Index With Bulk Data Hit ( ) , _ NUM , _ NUM ) ; to Return . calculate Values ( ) ; return to Return ; }
public boolean validate (  String value ,  String rule ) { return ( value . equals Ignore Case ( rule ) ) ; }
public boolean offer (  E event , int task Id ) throws  Interrupted Exception { assert Not Done ( ) ; if ( predicate . match ( event ) ) { this . matched [ task Id ] = _ BOOL ; for ( boolean match : matched ) { if ( ! match ) return _ BOOL ; } response Queue . put ( new  Event Holder ( event ) ) ; done = _ BOOL ; return _ BOOL ; } else return _ BOOL ; }
private static  Algorithm Parameter Spec algorithm Parameter Spec ( ) { final  Secure Random random = new  Secure Random ( ) ; final byte [ ] bytes = new byte [  Cc Aes .  BLOCK ] ; random . next Bytes ( bytes ) ; return new  Iv Parameter Spec ( bytes ) ; }
static  Zone Offset Transition Rule read External (  Data Input in ) throws  IOException { int data = in . read Int ( ) ;  Month month =  Month . of ( data > > > _ NUM ) ; int dom = ( ( data & ( _ NUM << _ NUM ) ) > > > _ NUM ) - _ NUM ; int dow Byte = ( data & ( _ NUM << _ NUM ) ) > > > _ NUM ;  Day Of Week dow = dow Byte == _ NUM ? null :  Day Of Week . of ( dow Byte ) ; int time Byte = ( data & ( _ NUM << _ NUM ) ) > > > _ NUM ;  Time Definition defn =  Time Definition . values ( ) [ ( data & ( _ NUM << _ NUM ) ) > > > _ NUM ] ; int std Byte = ( data & ( _ NUM << _ NUM ) ) > > > _ NUM ; int before Byte = ( data & ( _ NUM << _ NUM ) ) > > > _ NUM ; int after Byte = ( data & _ NUM ) ;  Local Time time = ( time Byte == _ NUM ?  Local Time . of Second Of Day ( in . read Int ( ) ) :  Local Time . of ( time Byte % _ NUM , _ NUM ) ) ;  Zone Offset std = ( std Byte == _ NUM ?  Zone Offset . of Total Seconds ( in . read Int ( ) ) :  Zone Offset . of Total Seconds ( ( std Byte - _ NUM ) * _ NUM ) ) ;  Zone Offset before = ( before Byte == _ NUM ?  Zone Offset . of Total Seconds ( in . read Int ( ) ) :  Zone Offset . of Total Seconds ( std . get Total Seconds ( ) + before Byte * _ NUM ) ) ;  Zone Offset after = ( after Byte == _ NUM ?  Zone Offset . of Total Seconds ( in . read Int ( ) ) :  Zone Offset . of Total Seconds ( std . get Total Seconds ( ) + after Byte * _ NUM ) ) ; return  Zone Offset Transition Rule . of ( month , dom , dow , time , time Byte == _ NUM , defn , std , before , after ) ; }
public void draw Lines And Points (  Graphics2 D g2d ,  Array List <  Comparable Label > ordered Date Set ,  Hash Map <  Comparable Label ,  Integer > data Points , long y Max Mark ) { int section Width = this . graph Width / ordered Date Set . size ( ) ; int x Offset = section Width / _ NUM ; int y Prev Value ; int y Current Value ; float prev Offset Perc ; float current Offset Perc ; g2d . set Color ( this . line Color ) ; for ( int i = _ NUM ; i < ordered Date Set . size ( ) ; i ++ ) { if ( i != _ NUM ) { y Prev Value = data Points . get ( ordered Date Set . get ( i - _ NUM ) ) ; y Current Value = data Points . get ( ordered Date Set . get ( i ) ) ; prev Offset Perc = y Prev Value / ( float ) y Max Mark ; current Offset Perc = y Current Value / ( float ) y Max Mark ; g2d . draw Line ( this . graph Left + ( i - _ NUM ) * section Width + x Offset , this . graph Bottom -  Math . round ( prev Offset Perc * this . graph Height ) , this . graph Left + i * section Width + x Offset ,  Math . round ( this . graph Bottom - current Offset Perc * this . graph Height ) ) ; } else { y Current Value = data Points . get ( ordered Date Set . get ( i ) ) ; current Offset Perc = y Current Value / ( float ) y Max Mark ; g2d . fill Oval ( this . graph Left + ( i ) * section Width + x Offset - this . point Radius , this . graph Bottom -  Math . round ( current Offset Perc * this . graph Height ) - this . point Radius , this . point Radius * _ NUM , this . point Radius * _ NUM ) ; } } }
final public void println (  String s ) {  Writer out = this . out ; if ( out == null ) return ; try { if ( s == null ) out . write ( _null Chars , _ NUM , _null Chars . length ) ; else out . write ( s , _ NUM , s . length ( ) ) ; out . write ( _newline , _ NUM , _newline . length ) ; } catch (  IOException e ) { log . log (  Level .  FINE , e . to String ( ) , e ) ; } }
private static  URI refrag Uri (  URI uri ,  String frag ) throws  URISyntax Exception { return new  URI ( uri . get Scheme ( ) , uri . get Scheme Specific Part ( ) , frag ) ; }
@  Override public void paint ( final  PPaint Context ppc ) { final  Paint paint = get Paint ( ) ; if ( paint != null ) { final  Graphics2 D g2 = ppc . get Graphics ( ) ; final  PBounds bounds = get Union Of Children Bounds ( null ) ; if ( fill Background ) { g2 . set Paint ( background Color ) ; g2 . fill Rect ( ( int ) bounds . get X ( ) - outline Padding , ( int ) bounds . get Y ( ) - outline Padding , ( int ) bounds . get Width ( ) + _ NUM * outline Padding , ( int ) bounds . get Height ( ) + _ NUM * outline Padding ) ; } if ( draw Outline ) { g2 . set Paint ( line Color ) ; g2 . draw Round Rect ( ( int ) bounds . get X ( ) - outline Padding , ( int ) bounds . get Y ( ) - outline Padding , ( int ) bounds . get Width ( ) + _ NUM * outline Padding , ( int ) bounds . get Height ( ) + _ NUM * outline Padding ,  ROUNDING_ WIDTH_ HEIGHT ,  ROUNDING_ WIDTH_ HEIGHT ) ; } } }
public final synchronized byte [ ] to Byte Array ( ) {  Byte Array Output Stream baos = null ;  Data Output Stream dos = null ; try { baos = new  Byte Array Output Stream ( _ NUM ) ; dos = new  Data Output Stream ( baos ) ; game . write To Stream ( dos ) ; dos . flush ( ) ; return baos . to Byte Array ( ) ; } catch (  IOException e ) { return null ; } finally { if ( dos != null ) try { dos . close ( ) ; } catch (  IOException ex ) { } if ( baos != null ) try { baos . close ( ) ; } catch (  IOException ex ) { } } }
public void add Import ( @  Not Null  Psi Element importable , @  Not Null  Psi File file , @  Nullable  Py Import Element import Element ) { my Imports . add ( new  Import Candidate Holder ( importable , file , import Element , null ) ) ; }
protected final void draw Arrow Head (  Graphics2 D g , int x , int y , int sgn ) { g . set Stroke (  Strokes . get Stroke (  Stroke Type .  SOLID , _ NUM ) ) ; int size = diagram ( ) . arrow Size ; switch ( head Type ) { case  CLOSED :  Polygon p = new  Polygon ( new int [ ] { x , x + sgn * size , x + sgn * size , x } , new int [ ] { y , y - size , y + size , y } , _ NUM ) ; g . fill Polygon ( p ) ; break ; case  OPEN : g . draw Line ( x , y , x + sgn * size , y - size ) ; g . draw Line ( x , y , x + sgn * size , y + size ) ; break ; case  ROUNDED : int left = sgn == - _ NUM ? x - _ NUM * size : x ; int top = y - size ; g . fill Arc ( left , top , size * _ NUM , size * _ NUM , _ NUM , sgn * _ NUM ) ; } }
public void class Loader Init (  Dynamic Class Loader loader ) {  Env Loader Listener listener = _listener Ref . get ( ) ; if ( listener != null ) listener . class Loader Init ( loader ) ; }
private  Object [ ] unmarshal Parameters Checked (  Deserialization Checker checker ,  Method method ,  Marshal Input Stream in ) throws  IOException ,  Class Not Found Exception { int call ID = method Call IDCount . get And Increment ( ) ;  My Checker my Checker = new  My Checker ( checker , method , call ID ) ; in . set Stream Checker ( my Checker ) ; try {  Class < ? > [ ] types = method . get Parameter Types ( ) ;  Object [ ] values = new  Object [ types . length ] ; for ( int i = _ NUM ; i < types . length ; i ++ ) { my Checker . set Index ( i ) ; values [ i ] = unmarshal Value ( types [ i ] , in ) ; } my Checker . end ( call ID ) ; return values ; } finally { in . set Stream Checker ( null ) ; } }
private void load Data From Service ( ) {  List <  Exception Sensor Data > ex Data = null ; if ( ( null != from Date ) && ( null != to Date ) ) { ex Data = data Access Service . get Ungrouped Exception Overview ( template , limit , from Date , to Date , result Comparator ) ; } else { ex Data = data Access Service . get Ungrouped Exception Overview ( template , limit , result Comparator ) ; } exception Sensor Data . clear ( ) ; if ( null != ex Data ) { exception Sensor Data . add All ( ex Data ) ; } }
void draw Icon (  Graphics g , int ax , int ay , int aw , int ah , float align ,  Component c ) { int gap = is Left To Right ? - ( img . get Icon Width ( ) + bulletgap ) : ( aw + bulletgap ) ; int x = ax + gap ; int y =  Math . max ( ay , ay + ( int ) ( align * ah ) - img . get Icon Height ( ) ) ; img . paint Icon ( c , g , x , y ) ; }
public int sync Query (  String query ) { long start =  System . current Time Millis ( ) ; int modified = execute ( _ STR ,  UPDATE_ COUNT_ RESPONSE , query ) ; log . debug ( _ STR ,  System . current Time Millis ( ) - start , modified ) ; return modified ; }
public static void full Reset ( ) { reset Runtime ( ) ; synchronized ( read Properties ) { read Properties . clear ( ) ; } }
private  Buffered Image to Buffered Image ( final  Image image ) { if ( image instanceof  Buffered Image ) { return (  Buffered Image ) image ; } if ( image instanceof  Volatile Image ) {  Volatile Image volatile Image = (  Volatile Image ) image ; return volatile Image . get Snapshot ( ) ; }  Graphics Environment graphics Environment =  Graphics Environment . get Local Graphics Environment ( ) ;  Graphics Device graphics Device = graphics Environment . get Default Screen Device ( ) ;  Graphics Configuration graphics Configuration = graphics Device . get Default Configuration ( ) ;  Buffered Image buffered Image = graphics Configuration . create Compatible Image ( image . get Width ( null ) , image . get Height ( null ) ) ;  Graphics2 D g = buffered Image . create Graphics ( ) ; g . draw Image ( image , _ NUM , _ NUM , null ) ; g . dispose ( ) ; return buffered Image ; }
public final boolean is Cancelled ( ) { if ( cancelled ) { pass ( _ STR , cancelled ) ; } else { fail ( _ STR ) ; } return cancelled ; }
public void remove (  Directed Edge de ) { out Edges . remove ( de ) ; }
@  Override protected void on Message On Producer Thread (  T msg ) { _lock . lock ( ) ; try { if ( _pending . is Empty ( ) ) { _queue . schedule ( _flush Runnable , _interval , _time Unit ) ; } _pending . add ( msg ) ; } finally { _lock . unlock ( ) ; } }
public  Builder until Date (  Date date ) { until Date =  QUERY_ DATE . format ( date ) ; return this ; }
private boolean is In Thumb Range ( float touch X , double normalized Thumb Value ) { return  Math . abs ( touch X - normalized To Screen ( normalized Thumb Value ) ) <= m Thumb Half Width ; }
public static void cleanup All Files (  File System file System ,  String  Base Uri ) throws  IOException { try { if ( file System != null ) {  Path root Dir = new  Path (  Base Uri ) ;  File Status [ ] files = file System . list Status ( root Dir ) ; for (  File Status file : files ) { file System . delete ( file . get Path ( ) , _ BOOL ) ; } } } catch (  Exception e ) {  LOG . error ( _ STR ) ; } }
@  Override public boolean can Be Collided With ( ) { return _ BOOL ; }
public void submit (  String queue Name ,  Dispatcher Task dispatcher Task ) { synchronized ( sync Root ) {  Dispatcher Task Runner current Task Runner = current Tasks Map . get ( queue Name ) ; if ( current Task Runner == null ) { current Task Runner = new  Dispatcher Task Runner ( queue Name , dispatcher Task ) ; current Tasks Map . put ( queue Name , current Task Runner ) ; executor Service . execute ( current Task Runner ) ; } else { enqueue Next Task ( queue Name , dispatcher Task ) ; } } }
public void dump (  Writer writer ) {  Print Writer pw = new  Print Writer ( new  Buffered Writer ( writer ) ) ; pw . println ( _ STR ) ; pw . println ( _ STR ) ; pw . println ( _ STR + ( int ) audio Format . get Sample Rate ( ) ) ; pw . println ( _ STR + samples . length / _ NUM ) ; pw . println ( _ STR + audio Format . get Channels ( ) ) ; if ( samples != null ) { for ( int i = _ NUM ; i < samples . length ; i += _ NUM ) { pw . println (  Wave Utils . bytes To Short ( samples [ i ] , samples [ i + _ NUM ] ) ) ; } } pw . flush ( ) ; }
public void add Field Buffered (  VEditor editor ,  Grid Field m Field ) { wrap = m Field != null ? ! m Field . is Same Line ( ) : _ BOOL ; if ( prev Editor != null && prev Field != null ) add Field ( prev Editor , prev Field ) ; prev Editor = editor ; prev Field = m Field ; }
public  Expand Room Freespace Incomplete add_incomplete_expansion_room (  Shape Tile p_shape , int p_layer ,  Shape Tile p_contained_shape ) {  Expand Room Freespace Incomplete new_room = new  Expand Room Freespace Incomplete ( p_shape , p_layer , p_contained_shape ) ; incomplete_expansion_rooms . add ( new_room ) ; return new_room ; }
static double compute Desired Ellipsoid Magnitude ( final  Planet Model planet Model , final double x , final double y , final double z ) { return _ NUM /  Math . sqrt ( x * x * planet Model . inverse Ab Squared + y * y * planet Model . inverse Ab Squared + z * z * planet Model . inverse CSquared ) ; }
private void validate VNXFile SMISProvider Mandatory Details (  Storage System Request Param param ) {  Arg Validator . check Field Valid IP ( param . get Smis Provider IP ( ) , _ STR ) ;  Arg Validator . check Field Not Null ( param . get Smis Port Number ( ) , _ STR ) ;  Arg Validator . check Field Range ( param . get Smis Port Number ( ) , _ NUM , _ NUM , _ STR ) ;  Arg Validator . check Field Not Empty ( param . get Smis User Name ( ) , _ STR ) ;  Arg Validator . check Field Not Empty ( param . get Smis Password ( ) , _ STR ) ; }
public void create Accrual Based Journal Entries And Reversals For Loan Charges ( final  Office office , final  String currency Code , final  Integer account Type To Be Debited , final  Integer account Type To Be Credited , final  Long loan Product Id , final  Long loan Id , final  String transaction Id , final  Date transaction Date , final  Big Decimal total Amount , final  Boolean is Reversal , final  List <  Charge Payment DTO > charge Payment DTOs ) {  GLAccount receivable Account = get Linked GLAccount For Loan Charges ( loan Product Id , account Type To Be Debited , null ) ; final  Map <  GLAccount ,  Big Decimal > credit Details Map = new  Linked Hash Map < > ( ) ; for ( final  Charge Payment DTO charge Payment DTO : charge Payment DTOs ) { final  Long charge Id = charge Payment DTO . get Charge Id ( ) ; final  GLAccount charge Specific Account = get Linked GLAccount For Loan Charges ( loan Product Id , account Type To Be Credited , charge Id ) ;  Big Decimal charge Specific Amount = charge Payment DTO . get Amount ( ) ; if ( credit Details Map . contains Key ( charge Specific Account ) ) { final  Big Decimal existing Amount = credit Details Map . get ( charge Specific Account ) ; charge Specific Amount = charge Specific Amount . add ( existing Amount ) ; } credit Details Map . put ( charge Specific Account , charge Specific Amount ) ; }  Big Decimal total Credited Amount =  Big Decimal .  ZERO ; for ( final  Map .  Entry <  GLAccount ,  Big Decimal > entry : credit Details Map . entry Set ( ) ) { final  GLAccount account = entry . get Key ( ) ; final  Big Decimal amount = entry . get Value ( ) ; total Credited Amount = total Credited Amount . add ( amount ) ; if ( is Reversal ) { create Debit Journal Entry For Loan ( office , currency Code , account , loan Id , transaction Id , transaction Date , amount ) ; create Credit Journal Entry For Loan ( office , currency Code , receivable Account , loan Id , transaction Id , transaction Date , amount ) ; } else { create Debit Journal Entry For Loan ( office , currency Code , receivable Account , loan Id , transaction Id , transaction Date , amount ) ; create Credit Journal Entry For Loan ( office , currency Code , account , loan Id , transaction Id , transaction Date , amount ) ; } } if ( total Amount . compare To ( total Credited Amount ) != _ NUM ) { throw new  Platform Data Integrity Exception ( _ STR , _ STR , total Credited Amount , total Amount ) ; } }
private  Art Locate Result calculate_next_trace ( boolean p_layer_changed , boolean p_at_fanout_end ) {  Collection <  Pla Point Float > corner_list = new  Linked List <  Pla Point Float > ( ) ; corner_list . add ( current_from_point ) ; if ( ! p_at_fanout_end ) {  Pla Point Float adjusted_start_corner = adjust_start_corner ( ) ; if ( adjusted_start_corner != current_from_point ) {  Pla Point Float add_corner = calculate_additional_corner ( current_from_point , adjusted_start_corner , _ BOOL , angle_restriction ) ; corner_list . add ( add_corner ) ; corner_list . add ( adjusted_start_corner ) ; previous_from_point = current_from_point ; current_from_point = adjusted_start_corner ; } }  Pla Point Float prev_corner = current_from_point ; for ( int c_limit = _ NUM ; c_limit < _ NUM ; c_limit ++ ) {  Collection <  Pla Point Float > next_corners = calculate_next_trace_corners ( ) ; if ( next_corners . is Empty ( ) ) break ; for (  Pla Point Float curr_next_corner : next_corners ) { if ( curr_next_corner == prev_corner ) continue ; corner_list . add ( curr_next_corner ) ; previous_from_point = current_from_point ; current_from_point = curr_next_corner ; prev_corner = curr_next_corner ; } } int next_layer = current_trace_layer ; if ( p_layer_changed ) { current_from_door_index = current_target_door_index + _ NUM ;  Expand Room Complete next_room = backtrack_array [ current_from_door_index ] . next_room ; if ( next_room != null ) { next_layer = next_room . get_layer ( ) ; } }  Pla Point Int Alist rounded_corner_list = new  Pla Point Int Alist ( corner_list . size ( ) ) ;  Pla Point Int prev_point = null ; for (  Pla Point Float a_float : corner_list ) {  Pla Point Int curr_point = a_float . round ( ) ; if ( curr_point . equals ( prev_point ) ) continue ; rounded_corner_list . add ( curr_point ) ; prev_point = curr_point ; }  Art Locate Result result = new  Art Locate Result ( rounded_corner_list , current_trace_layer ) ; current_trace_layer = next_layer ; return result ; }
@  Override protected  Sensor create New Sensor (  String system Name ,  String user Name ) { if ( log . is Debug Enabled ( ) ) { log . debug ( _ STR + system Name + _ STR + user Name ) ; }  Sensor s ;  String s Name =  Serial Address . normalize System Name ( system Name ) ; if ( s Name . equals ( _ STR ) ) { log . error ( _ STR + system Name ) ; return null ; } s = get By System Name ( s Name ) ; if ( s != null ) { log . error ( _ STR + system Name ) ; return null ; }  String alt Name =  Serial Address . convert System Name To Alternate ( s Name ) ; s = get By System Name ( alt Name ) ; if ( s != null ) { log . error ( _ STR + system Name + _ STR + alt Name + _ STR ) ; return null ; } int bit =  Serial Address . get Bit From System Name ( s Name ) ; if ( ( bit <= _ NUM ) || ( bit >=  SENSORSPERNODE ) ) { log . error ( _ STR +  Integer . to String ( bit ) + _ STR +  Integer . to String (  SENSORSPERNODE - _ NUM ) ) ; return null ; } if ( user Name == null ) { s = new  Serial Sensor ( s Name ) ; } else { s = new  Serial Sensor ( s Name , user Name ) ; }  Serial Node node =  Serial Address . get Node From System Name ( s Name ) ; if ( node == null ) { log . warn ( _ STR + s Name + _ STR ) ; return s ; } node . register Sensor ( s , bit ) ; if ( log . is Debug Enabled ( ) ) { log . debug ( _ STR + s . get System Name ( ) + _ STR + node ) ; } return s ; }
private double [ ] max ( double [ ] distances1 , double [ ] distances2 ) { if ( distances1 . length != distances2 . length ) { throw new  Runtime Exception ( _ STR ) ; } double [ ] result = new double [ distances1 . length ] ; for ( int i = _ NUM ; i < distances1 . length ; i ++ ) { result [ i ] =  Math . max ( distances1 [ i ] , distances2 [ i ] ) ; } return result ; }
public void fill_shape (  Pla Point Float [ ] p_points ,  Graphics p_g ,  Color p_color , double p_translucency_factor ) { if ( p_color == null ) return ;  Graphics2 D g2 = (  Graphics2 D ) p_g ;  Polygon draw_polygon = new  Polygon ( ) ; for ( int index = _ NUM ; index < p_points . length ; index ++ ) {  Point2 D curr_corner = coordinate_transform . board_to_screen ( p_points [ index ] ) ; draw_polygon . add Point ( ( int )  Math . round ( curr_corner . get X ( ) ) , ( int )  Math . round ( curr_corner . get Y ( ) ) ) ; } g2 . set Color ( p_color ) ; set_translucency ( g2 , p_translucency_factor ) ; g2 . set Rendering Hint (  Rendering Hints .  KEY_ ANTIALIASING ,  Rendering Hints .  VALUE_ ANTIALIAS_ ON ) ; g2 . fill ( draw_polygon ) ; }
public void go To Current Day ( ) { int month Difference =  Flexible Calendar Helper . get Month Difference ( display Year , display Month ) ;  Calendar cal =  Calendar . get Instance ( ) ; selected Date Item . set Day ( cal . get (  Calendar .  DAY_ OF_ MONTH ) ) ; selected Date Item . set Month ( cal . get (  Calendar .  MONTH ) ) ; selected Date Item . set Year ( cal . get (  Calendar .  YEAR ) ) ; if ( disable Auto Date Selection ) { this . user Selected Item = selected Date Item . clone ( ) ; } if ( month Difference != _ NUM ) { reset Adapters = _ BOOL ; if ( month Difference < _ NUM ) { month Inf Pager Adapter . set Fake Count ( last Position ) ; month Inf Pager Adapter . notify Data Set Changed ( ) ; } should Override Computed Date = _ BOOL ; move To Position ( month Difference ) ; } else {  Flexible Calendar Grid Adapter currently Visible Adapter = month View Pager Adapter . get Month Adapter At Position ( last Position %  Month View Pager Adapter .  VIEWS_ IN_ PAGER ) ; currently Visible Adapter . notify Data Set Changed ( ) ; } }
public boolean is Valid Template ( ) { return is Valid Template ( template ) ; }
public  Object take ( ) throws  Interrupted Exception ,  Force Reattempt Exception { throw new  Unsupported Operation Exception ( ) ; }
@  Suppress Warnings ( { _ STR } ) public static double normal Cdf ( double y ) { double f , h ; int j ; double dcphi , x , z , f1 , f2 , f3 , f4 , f5 ; x = y ; if (  Math . abs ( x ) > _ NUM ) { dcphi = _ NUM ; } else { j = ( int )  Math . floor (  Math . abs ( x ) * _ NUM + _ NUM ) ; z = j * _ NUM ; h =  Math . abs ( x ) - z ; f = r [ j ] ; f1 = f * z - _ NUM ; f2 = f + z * f1 ; f3 = f1 * _ NUM + z * f2 ; f4 = f2 * _ NUM + z * f3 ; f5 = f3 * _ NUM + z * f4 ; dcphi = f + h * ( f1 * _ NUM + h * ( f2 * _ NUM + h * ( f3 * _ NUM + h * ( f4 * _ NUM + h * f5 ) ) ) ) / _ NUM ; dcphi = dcphi * _ NUM *  Math . exp ( x * - _ NUM * x ) ; } if ( x < _ NUM ) { return dcphi ; } else { return ( _ NUM - dcphi ) ; } }
private void destroy ( ) { if ( log . is Loggable (  Level .  FINEST ) ) { log . finest ( this + _ STR ) ; } try { _socket . force Shutdown ( ) ; } catch (  Throwable e ) { } try { close Connection ( ) ; } catch (  Throwable e ) { log . log (  Level .  FINER , e . to String ( ) , e ) ; } _port . remove Connection ( this ) ; }
int atom ( ) throws  RESyntax Exception { int ret = node (  RE .  OP_ ATOM , _ NUM ) ; int len Atom = _ NUM ; atom Loop : while ( idx < len ) { if ( ( idx + _ NUM ) < len ) { char c = pattern . char At ( idx + _ NUM ) ; if ( pattern . char At ( idx ) == _ STR ) { int idx Escape = idx ; escape ( ) ; if ( idx < len ) { c = pattern . char At ( idx ) ; } idx = idx Escape ; } switch ( c ) { case _ STR : case _ STR : case _ STR : case _ STR : if ( len Atom != _ NUM ) { break atom Loop ; } } } switch ( pattern . char At ( idx ) ) { case _ STR : case _ STR : case _ STR : case _ STR : case _ STR : case _ STR : case _ STR : case _ STR : break atom Loop ; case _ STR : case _ STR : case _ STR : case _ STR : if ( len Atom == _ NUM ) { syntax Error ( _ STR ) ; } break atom Loop ; case _ STR : { int idx Before Escape = idx ; int c = escape ( ) ; if ( ( c &  ESC_ MASK ) ==  ESC_ MASK ) { idx = idx Before Escape ; break atom Loop ; } emit ( ( char ) c ) ; len Atom ++ ; } break ; default : emit ( pattern . char At ( idx ++ ) ) ; len Atom ++ ; break ; } } if ( len Atom == _ NUM ) { internal Error ( ) ; } instruction [ ret +  RE . offset Opdata ] = ( char ) len Atom ; return ret ; }
@  Override public void draw Item (  Graphics2 D g2 ,  Category Item Renderer State state ,  Rectangle2 D data Area ,  Category Plot plot ,  Category Axis domain Axis ,  Value Axis range Axis ,  Category Dataset dataset , int row , int column , int pass ) { int visible Row = state . get Visible Series Index ( row ) ; if ( visible Row < _ NUM ) { return ; }  Number data Value = dataset . get Value ( row , column ) ; if ( data Value == null ) { return ; } double value = data Value . double Value ( ) ;  Plot Orientation orientation = plot . get Orientation ( ) ; double bar W0 = calculate Bar W0 ( plot , orientation , data Area , domain Axis , state , visible Row , column ) ;  Rectangle Edge edge = plot . get Range Axis Edge ( ) ; double bar L = range Axis . value To Java2 D ( value , data Area , edge ) ;  Line2 D line ; double x , y ; if ( orientation . is Horizontal ( ) ) { x = bar L ; y = bar W0 + state . get Bar Width ( ) / _ NUM ; line = new  Line2 D .  Double ( bar L , bar W0 , bar L , bar W0 + state . get Bar Width ( ) ) ; } else { x = bar W0 + state . get Bar Width ( ) / _ NUM ; y = bar L ; line = new  Line2 D .  Double ( bar W0 , bar L , bar W0 + state . get Bar Width ( ) , bar L ) ; } if ( state . get Element Hinting ( ) ) { begin Element Group ( g2 , dataset . get Row Key ( row ) , dataset . get Column Key ( column ) ) ; }  Stroke item Stroke = get Item Stroke ( row , column ) ;  Paint item Paint = get Item Paint ( row , column ) ; g2 . set Stroke ( item Stroke ) ; g2 . set Paint ( item Paint ) ; g2 . draw ( line ) ; if ( state . get Element Hinting ( ) ) { end Element Group ( g2 ) ; }  Category Item Label Generator generator = get Item Label Generator ( row , column ) ; if ( generator != null && is Item Label Visible ( row , column ) ) { draw Item Label ( g2 , orientation , dataset , row , column , x , y , ( value < _ NUM ) ) ; } int dataset Index = plot . index Of ( dataset ) ; update Crosshair Values ( state . get Crosshair State ( ) , dataset . get Row Key ( row ) , dataset . get Column Key ( column ) , value , dataset Index , bar W0 , bar L , orientation ) ;  Entity Collection entities = state . get Entity Collection ( ) ; if ( entities != null ) { add Item Entity ( entities , dataset , row , column , line . get Bounds ( ) ) ; } }
public static <  T >  Unary Operator <  List <  T > > from (  Collection <  String > command Line Udids ,  Function <  T ,  ICloud .  MBSBackup > mbs Backup ,  Function <  ICloud .  MBSBackup ,  String > formatter ,  Printer out ,  Input Stream in ) { return command Line Udids . is Empty ( ) ? new  User ( mbs Backup , out , in , formatter ) : new  Udid ( mbs Backup , out , in , new  Array List < > ( command Line Udids ) ) ; }
public boolean is Network Connected ( ) {  Connectivity Manager connectivity Manager = (  Connectivity Manager ) get System Service (  CONNECTIVITY_ SERVICE ) ;  Network Info network Info = connectivity Manager . get Active Network Info ( ) ; return network Info != null && network Info . is Connected Or Connecting ( ) ; }
public void put (  String name ,  String supported ,  String auth Scheme ,  String level , boolean is Default ) {  SAMLv2 Auth Context c = new  SAMLv2 Auth Context ( ) ; c . name = name ; c . supported = supported ; if ( auth Scheme . length ( ) != _ NUM && auth Scheme != null ) { int index = auth Scheme . last Index Of ( _ STR ) ; c . value = auth Scheme . substring ( index + _ NUM ) ; c . key = auth Scheme . substring ( _ NUM , index ) ; } else { c . value = _ STR ; c . key = _ STR ; } c . level = level ; c . is Default = is Default ; collections . put ( name , c ) ; }
public final void close (  Ls Server Packet close Packet , boolean forced ) { synchronized ( guard ) { if ( is Write Disabled ( ) ) { return ; } log . debug ( _ STR + close Packet + _ STR ) ; pending Close = _ BOOL ; is Forced Closing = forced ; send Msg Queue . clear ( ) ; send Msg Queue . add Last ( close Packet ) ; enable Write Interest ( ) ; } }
private void replace Collapsed Edges ( ) {  List new Edges = new  Array List ( ) ; for (  Iterator it = edge List . iterator ( ) ; it . has Next ( ) ; ) {  Edge e = (  Edge ) it . next ( ) ; if ( e . is Collapsed ( ) ) { it . remove ( ) ; new Edges . add ( e . get Collapsed Edge ( ) ) ; } } edge List . add All ( new Edges ) ; }
public  Sea Glass Title Pane (  JRoot Pane root Pane ,  Sea Glass Root Pane UI ui ) { this . root Pane = root Pane ; this . root Pane UI = ui ; root Parent = (  Root Pane Container ) root Pane . get Parent ( ) ; install Title Pane ( ) ; }
public void write Long ( long value ) throws  IOException { check Write Primitive Types ( ) ; primitive Types . write Long ( value ) ; }
static public  URL find Container XML (  String _container Name ) {  URL _container Name URL = null ;  String _container Name File Path =  Constants .  Container .  CONTAINER_ CONFIG_ DIRECTORY + _ STR + _container Name + _ STR ; _container Name URL = get Resource URL ( _container Name File Path ) ; if ( _container Name URL != null ) { if ( _logger . is Loggable (  Level .  INFO ) ) { _logger . info ( _ STR + _container Name URL + _ STR ) ; } } return _container Name URL ; }
public static  List <  String > expand Wildcards (  Iterable <  File > dirs ,  List <  String > names ,  Backend for Backend ) {  List <  String > result = new  Array List <  String > ( names . size ( ) ) ; for (  String name : names ) { expand Wildcard ( result , dirs , name , for Backend ) ; } return result ; }
public static  Charset for Name (  String charset Name ) { return for Name ( charset Name , null ) ; }
public  NSNumber ( int i ) { double Value = long Value = i ; type =  INTEGER ; }
public static void dump (  String message ,  Stack Trace Element [ ] stack Trace ) { dump ( message ,  Arrays . as List ( stack Trace ) ) ; }
@  Override public boolean e Is Set ( int feature ID ) { switch ( feature ID ) { case  Eip Package .  CONDITIONAL_ ROUTE__ CONDITION : return  CONDITION_ EDEFAULT == null ? condition != null : !  CONDITION_ EDEFAULT . equals ( condition ) ; case  Eip Package .  CONDITIONAL_ ROUTE__ CHANNEL : return channel != null ; } return super . e Is Set ( feature ID ) ; }
public static native  String map Library Name (  String libname ) ;
public  Matcher next ( ) throws  IOException { readahead ( ) ; if ( matches == null ) { throw new  No Such Element Exception ( ) ; }  Matcher matcher = matches . next ( ) ; if ( discard ) {  Pattern pattern = matcher . pattern ( ) ; for ( int n = _ NUM ; n < patterns . length ; n ++ ) { if ( patterns [ n ] == pattern ) { patterns [ n ] = null ; break ; } } } return matcher ; }
@  Called Only By (  Amidst Thread .  FRAGMENT_ LOADER ) public void process Queues ( ) {  Dimension dimension = dimension Setting . get ( ) ; update Layer Manager ( dimension ) ; process Recycle Queue ( ) ;  Fragment fragment ; while ( ( fragment = loading Queue . poll ( ) ) != null ) { load Fragment ( dimension , fragment ) ; dimension = dimension Setting . get ( ) ; update Layer Manager ( dimension ) ; process Recycle Queue ( ) ; } layer Manager . clear Invalidated Layers ( ) ; }
default  Field Declaration add Private Field (  Class < ? > type Class ,  String name ) { return add Field ( type Class , name ,  Modifier .  PRIVATE ) ; }
void  Reconstruct Private Subrs ( int  Font ,  Index Base Item [ ] fd Private Base ,  Offset Item [ ] fd Subrs ) { for ( int i = _ NUM ; i < fonts [  Font ] . fdprivate Lengths . length ; i ++ ) { if ( fd Subrs [ i ] != null && fonts [  Font ] .  Private Subrs Offset [ i ] >= _ NUM ) {  Output List . add Last ( new  Subr Marker Item ( fd Subrs [ i ] , fd Private Base [ i ] ) ) ; if (  New LSubrs Index [ i ] != null )  Output List . add Last ( new  Range Item ( new  Random Access File Or Array ( ras Factory . create Source (  New LSubrs Index [ i ] ) ) , _ NUM ,  New LSubrs Index [ i ] . length ) ) ; } } }
public void init GL ( ) { m Egl Core = new  Egl Core ( null ,  Egl Core .  FLAG_ RECORDABLE |  Egl Core .  FLAG_ TRY_ GLES3 ) ; m Window Surface = new  Window Surface ( m Egl Core , m Surface Texture ) ; m Window Surface . make Current ( ) ; m Record Surface = new  Window Surface ( m Egl Core , m Media Recorder . get Surface ( ) , _ BOOL ) ; init GLComponents ( ) ; }
protected void contribute Token Request Parameters ( final  Query String body Parameters ) { }
Builder add Lenient (  String line ) { int index = line . index Of ( _ STR , _ NUM ) ; if ( index != - _ NUM ) { return add Lenient ( line . substring ( _ NUM , index ) , line . substring ( index + _ NUM ) ) ; } else if ( line . starts With ( _ STR ) ) { return add Lenient ( _ STR , line . substring ( _ NUM ) ) ; } else { return add Lenient ( _ STR , line ) ; } }
public static void merge Node Children (  Tree Node node ) {  Default Mutable Tree Node master Node = (  Default Mutable Tree Node ) node ; for ( int i = _ NUM ; i < master Node . get Child Count ( ) ; i ++ ) {  Default Mutable Tree Node child = (  Default Mutable Tree Node ) master Node . get Child At ( i ) ; if ( ! child . is Leaf ( ) ) {  Merge Help Utilities . merge Node Children (  DEFAULT_ MERGE_ TYPE , child ) ; } } }
public void test Negate Negative ( ) {  String a = _ STR ; int a Scale = _ NUM ;  String c = _ STR ; int c Scale = _ NUM ;  Big Decimal a Number = new  Big Decimal ( new  Big Integer ( a ) , a Scale ) ;  Big Decimal c Number = new  Big Decimal ( new  Big Integer ( c ) , c Scale ) ; assert Equals ( _ STR , c Number , a Number . negate ( ) ) ; }
private static  Object create And Bind Item (  Parameter Access parameters ,  Class < ? > item Type ) { try {  Object value = item Type . new Instance ( ) ; bind ( value , parameters ) ; return value ; } catch (  Instantiation Exception |  Illegal Access Exception e ) { throw new  Binding Exception ( _ STR + item Type , e ) ; } }
public  Simple Setup Panel (  Experiment exp ) { this ( ) ; set Experiment ( exp ) ; }
private static void process Args (  String [ ] args ) { for ( int i = _ NUM ; i < args . length ; i ++ ) {  String arg = args [ i ] ; if ( arg . equals ( _ STR ) ) { output Dir = args [ ++ i ] ; } else if ( arg . equals ( _ STR ) ) { unicode Data = args [ ++ i ] ; } else if ( arg . equals ( _ STR ) ) { language = args [ ++ i ] ; } else if ( arg . equals ( _ STR ) ) { country = args [ ++ i ] ; } else if ( arg . equals ( _ STR ) ) { valiant = args [ ++ i ] ; } else { usage ( ) ; } } locale Name = get Locale Name ( ) ; }
public static boolean is Zoning Required (  Db Client db Client ,  Virtual Array nh ) { if ( nh . get Auto San Zoning ( ) == _ BOOL ) { _log . info ( _ STR + nh . get Label ( ) ) ; return _ BOOL ; } return  Network Util . are Network System Discovered ( db Client ) ; }
private void init XMLTree ( ) throws  Exception { update Filtered Tokens ( ) ;  Array List elements = get Elements ( get Filtered Tokens ( ) ) ; if ( elements . size ( ) > _ NUM ) { throw new  Exception ( _ STR ) ; } set Root Element ( (  XMLElement ) elements . get ( _ NUM ) ) ; }
public boolean has Name Value (  String name ) { return name Value Map . contains Key ( name . to Lower Case ( ) ) ; }
public boolean starts With (  Char Seq prefix ) { return str . starts With ( prefix . str ) ; }
public boolean contains Window (  Class < ? > window Class ) { return ( get Window ( window Class ) != null ) ; }
protected final void fire Property Change (  String property Name , long old Value , long new Value ) { fire Property Change ( property Name ,  Long . value Of ( old Value ) ,  Long . value Of ( new Value ) ) ; }
public  Abstract Surface Object (  Abstract Surface Object source ) { super ( source ) ; this . visible = source . visible ; this . unique Id = next Unique Id ( ) ; this . last Modified Time =  System . current Time Millis ( ) ; this . enable Batch Picking = source . enable Batch Picking ; }
public  Soot Method And Class parse Soot Method String (  String parse String ) { if ( ! parse String . starts With ( _ STR ) || ! parse String . ends With ( _ STR ) ) { throw new  Illegal Argument Exception ( _ STR + parse String + _ STR ) ; }  String name = _ STR ;  String class Name = _ STR ;  String return Type = _ STR ;  Pattern pattern =  Pattern . compile ( _ STR ) ;  Matcher matcher = pattern . matcher ( parse String ) ; if ( matcher . find ( ) ) { class Name = matcher . group ( _ NUM ) ; } pattern =  Pattern . compile ( _ STR ) ; matcher = pattern . matcher ( parse String ) ; if ( matcher . find ( ) ) { return Type = matcher . group ( _ NUM ) ; parse String = parse String . substring ( matcher . end ( _ NUM ) ) ; } pattern =  Pattern . compile ( _ STR ) ; matcher = pattern . matcher ( parse String ) ; if ( matcher . find ( ) ) { name = matcher . group ( _ NUM ) ; }  List <  String > param List = new  Array List <  String > ( ) ; pattern =  Pattern . compile ( _ STR ) ; matcher = pattern . matcher ( parse String ) ; if ( matcher . find ( ) ) {  String params = matcher . group ( _ NUM ) ; for (  String param : params . split ( _ STR ) ) param List . add ( param . trim ( ) ) ; } return new  Soot Method And Class ( name , class Name , return Type , param List ) ; }
private void create New Review Task (  Task Repository repository ,  Task Data task Data ) throws  Core Exception {  Repository repo =  Appraise Plugin Utils . get Git Repo For Repository ( repository ) ;  Appraise Plugin Review Client client ; try { client = new  Appraise Plugin Review Client ( repository ) ; } catch (  Git Client Exception e1 ) { throw new  Core Exception ( new  Status (  IStatus .  ERROR ,  Appraise Connector Plugin .  PLUGIN_ ID , _ STR ) ) ; }  String current Branch ; try { current Branch = repo . get Full Branch ( ) ; } catch (  IOException e ) { throw new  Core Exception ( new  Status (  IStatus .  ERROR ,  Appraise Connector Plugin .  PLUGIN_ ID , _ STR , e ) ) ; } if (  MASTER_ REF . equals ( current Branch ) ) { throw new  Core Exception ( new  Status (  IStatus .  ERROR ,  Appraise Connector Plugin .  PLUGIN_ ID , _ STR ) ) ; } set Attribute Value ( task Data , schema .  REQUESTER , repository . get User Name ( ) ) ; set Attribute Value ( task Data , schema .  TARGET_ REF ,  MASTER_ REF ) ; set Attribute Value ( task Data , schema .  REVIEW_ REF , current Branch ) ;  Rev Commit review Commit ; try { review Commit = client . get Review Commit ( current Branch ,  MASTER_ REF ) ; } catch (  Git Client Exception e ) { throw new  Core Exception ( new  Status (  IStatus .  ERROR ,  Appraise Connector Plugin .  PLUGIN_ ID , _ STR , e ) ) ; } if ( review Commit == null ) { throw new  Core Exception ( new  Status (  IStatus .  INFO ,  Appraise Connector Plugin .  PLUGIN_ ID , _ STR + current Branch ) ) ; } set Attribute Value ( task Data , schema .  DESCRIPTION , review Commit . get Full Message ( ) ) ; set Attribute Value ( task Data , schema .  REVIEW_ COMMIT , review Commit . get Name ( ) ) ; try {  List <  Diff Entry > diffs = client . get Review Diffs ( current Branch ,  MASTER_ REF ) ; populate Diffs ( repository , diffs , task Data ) ; } catch (  Exception e ) { throw new  Core Exception ( new  Status (  IStatus .  ERROR ,  Appraise Connector Plugin .  PLUGIN_ ID , _ STR , e ) ) ; } }
@  Override public void startup ( ) throws  Exception {  Log . d (  Mary .  LOG , _ STR ) ;  List <  String > voice Names =  Mary Properties . get List ( _ STR ) ; for (  String voice Name : voice Names ) { long time =  System . current Time Millis ( ) ;  Voice unit Sel Voice = new  Unit Selection Voice ( voice Name , this ) ;  Log . d (  Mary .  LOG , _ STR + unit Sel Voice + _ STR ) ;  Voice . register Voice ( unit Sel Voice ) ; long newtime =  System . current Time Millis ( ) - time ;  Log . i (  Mary .  LOG , _ STR + voice Name + _ STR + newtime + _ STR ) ; }  Log . i (  Mary .  LOG , _ STR ) ; }
public int find Start Of Column ( int column ) { if ( column == m Columns ) return get Space Used ( ) ; int current Column = _ NUM ; int current Char Index = _ NUM ; while ( _ BOOL ) { int new Char Index = current Char Index ; char c = m Text [ new Char Index ++ ] ; boolean is High =  Character . is High Surrogate ( c ) ; int code Point = is High ?  Character . to Code Point ( c , m Text [ new Char Index ++ ] ) : c ; int wcwidth =  Wc Width . width ( code Point ) ; if ( wcwidth > _ NUM ) { current Column += wcwidth ; if ( current Column == column ) { while ( new Char Index < m Space Used ) { if (  Character . is High Surrogate ( m Text [ new Char Index ] ) ) { if (  Wc Width . width (  Character . to Code Point ( m Text [ new Char Index ] , m Text [ new Char Index + _ NUM ] ) ) <= _ NUM ) { new Char Index += _ NUM ; } else { break ; } } else if (  Wc Width . width ( m Text [ new Char Index ] ) <= _ NUM ) { new Char Index ++ ; } else { break ; } } return new Char Index ; } else if ( current Column > column ) { return current Char Index ; } } current Char Index = new Char Index ; } }
private  Trip Schedule reroute Trip Schedule (  Trip Schedule original Schedule ) {  Trip Schedule schedule = original Schedule . clone ( ) ; schedule . arrivals = new int [ new Pattern Length ] ; schedule . departures = new int [ new Pattern Length ] ; int prev Output Departure = _ NUM ; for ( int ss = _ NUM , ts = _ NUM ; ts < new Pattern Length ; ss ++ , ts ++ ) { if ( ( ss == insert Begin Index - _ NUM ) || ( ss == _ NUM && insert Begin Index == _ NUM ) ) { int hop Time = original Schedule . arrivals [ ss ] ; if ( ss > _ NUM ) hop Time -= original Schedule . departures [ ss - _ NUM ] ; schedule . arrivals [ ts ] = prev Output Departure + hop Time ; schedule . departures [ ts ] = schedule . arrivals [ ts ] + dwell Times [ _ NUM ] ; prev Output Departure = schedule . departures [ ts ] ; ts ++ ; for ( int hop = _ NUM , dwell = _ NUM ; dwell < dwell Times . length ; hop ++ , dwell ++ ) { schedule . arrivals [ ts ] = prev Output Departure + hop Times [ hop ] ; schedule . departures [ ts ] = schedule . arrivals [ ts ] + dwell Times [ dwell ] ; prev Output Departure = schedule . departures [ ts ] ; ts ++ ; } ss = insert End Index + _ NUM ; if ( ts == new Pattern Length ) break ; } int hop Time = original Schedule . arrivals [ ss ] ; if ( ss > _ NUM ) hop Time -= original Schedule . departures [ ss - _ NUM ] ; schedule . arrivals [ ts ] = prev Output Departure + hop Time ; int dwell Time = original Schedule . departures [ ss ] - original Schedule . arrivals [ ss ] ; schedule . departures [ ts ] = schedule . arrivals [ ts ] + dwell Time ; prev Output Departure = schedule . departures [ ts ] ; } int time Shift = original Schedule . arrivals [ original Fixed Point Stop Index ] - schedule . arrivals [ new Fixed Point Stop Index ] ; for ( int i = _ NUM ; i < new Pattern Length ; i ++ ) { schedule . arrivals [ i ] += time Shift ; schedule . departures [ i ] += time Shift ; } if (  LOG . is Debug Enabled ( ) ) {  LOG . debug ( _ STR , original Schedule . arrivals ) ;  LOG . debug ( _ STR , original Schedule . departures ) ;  LOG . debug ( _ STR , schedule . arrivals ) ;  LOG . debug ( _ STR , schedule . departures ) ; } return schedule ; }
public static  Color decode (  String color ,  Color default Color ) { if ( color == null ) { return default Color ; }  Color c = get Named Color ( color ) ; if ( c == null ) { try { c =  Color . decode ( color ) ; } catch (  Number Format Exception ex ) { return default Color ; } } return c ; }
public static  Linked List <  Mary Module > modules Required For Processing (  Mary Data Type source Type ,  Mary Data Type target Type ,  Locale locale ,  Voice voice ) { if ( ! registration Complete ) throw new  Illegal State Exception ( _ STR ) ; if ( source Type == null ) throw new  Null Pointer Exception ( _ STR ) ; if ( target Type == null ) throw new  Null Pointer Exception ( _ STR ) ;  Linked List <  Mary Data Type > seen Types = new  Linked List <  Mary Data Type > ( ) ; seen Types . add ( source Type ) ; return modules Required For Processing ( source Type , target Type , locale , voice , seen Types ) ; }
public double distance (  Vector o ) { return  Math . sqrt (  Number Conversions . square ( x - o . x ) +  Number Conversions . square ( y - o . y ) +  Number Conversions . square ( z - o . z ) ) ; }
public static long calculate Elapsed GC ( ) { long time Millis = _ NUM ; for (  Garbage Collector MXBean gcbean : gcbeans ) { time Millis += gcbean . get Collection Time ( ) ; } return time Millis ; }
public void start Object ( int numfields ) { not Nested ( ) ; if ( vtable == null || vtable . length < numfields ) vtable = new int [ numfields ] ; vtable_in_use = numfields ;  Arrays . fill ( vtable , _ NUM , vtable_in_use , _ NUM ) ; nested = _ BOOL ; object_start = offset ( ) ; }
private  Map <  String ,  String > produce Stream (  String topic ) {  List <  Producer Record <  String ,  String > > messages = new  Array List < > (  EVENT_ CNT ) ;  Map <  String ,  String > key Val Map = new  Hash Map < > ( ) ; for ( int evt = _ NUM ; evt <  EVENT_ CNT ; evt ++ ) { long runtime =  System . current Time Millis ( ) ;  String key = topic + _ STR +  String . value Of ( evt ) ;  String msg = runtime +  String . value Of ( evt ) ; messages . add ( new  Producer Record < > ( topic , key , msg ) ) ; key Val Map . put ( key , msg ) ; } kafka Broker . send Messages ( messages ) ; return key Val Map ; }
public static  String string Of Char ( char ch , int count ) {  String Buffer buf = new  String Buffer ( ) ; for ( int i = _ NUM ; i < count ; i ++ ) { buf . append ( ch ) ; } return buf . to String ( ) ; }
private void add Connection View (  Connection connection ) {  Platform Impl . run And Wait ( null ) ; }
public static void trim (  Char Sequence a Text , int [ ] a Span ) { int begin = a Span [ _ NUM ] ; int end = a Span [ _ NUM ] - _ NUM ;  Char Sequence data = a Text ; while ( ( begin < ( data . length ( ) - _ NUM ) ) && trim Char ( data . char At ( begin ) ) ) { begin ++ ; } while ( ( end > _ NUM ) && trim Char ( data . char At ( end ) ) ) { end -- ; } end ++ ; a Span [ _ NUM ] = begin ; a Span [ _ NUM ] = end ; }
public void add Script Finished Listener (  Script Execution Listener l ) { m_ Finished Listeners . add ( l ) ; }
public void test_get Put Byte Array ( ) { final int size = _ NUM ; final  IData Record buf = new  Fixed Byte Array Buffer ( size ) ; assert Equals ( ( byte ) _ NUM , buf . get Byte ( _ NUM ) ) ; assert Equals ( ( byte ) _ NUM , buf . get Byte ( size - _ NUM ) ) ; final int pos = _ NUM ; for ( int i = _ NUM ; i <  LIMIT ; i ++ ) { final byte [ ] expected = new byte [ r . next Int ( size - _ NUM ) ] ; r . next Bytes ( expected ) ; buf . put ( pos , expected ) ; assert Equals ( _ NUM ,  Bytes Util . compare Bytes With Len And Offset ( _ NUM , expected . length , expected , pos , expected . length , buf . array ( ) ) ) ; final byte [ ] actual = new byte [ expected . length ] ; buf . get ( pos , actual ) ; assert True (  Bytes Util . bytes Equal ( expected , actual ) ) ; } assert Equals ( ( byte ) _ NUM , buf . get Byte ( _ NUM ) ) ; assert Equals ( ( byte ) _ NUM , buf . get Byte ( pos + size - _ NUM ) ) ; }
private  T [ ] ensure Capacity ( int min Capacity ) { if ( tmp . length < min Capacity ) { int new Size = min Capacity ; new Size |= new Size > > _ NUM ; new Size |= new Size > > _ NUM ; new Size |= new Size > > _ NUM ; new Size |= new Size > > _ NUM ; new Size |= new Size > > _ NUM ; new Size ++ ; if ( new Size < _ NUM ) new Size = min Capacity ; else new Size =  Math . min ( new Size , a . length > > > _ NUM ) ;  T [ ] new Array = (  T [ ] ) new  Object [ new Size ] ; tmp = new Array ; } return tmp ; }
public void  CONT ( int session Number ) throws  Exception { this . max Session Number =  Math . max ( this . max Session Number , session Number ) ; test Elements . add ( new  Continuation Element ( session Number ) ) ; }
public static double calc Rotation Angle In Degrees (  Point F center Pt ,  Point F target Pt ) { double theta =  Math . atan2 ( target Pt . y - center Pt . y , target Pt . x - center Pt . x ) ; double angle =  Math . to Degrees ( theta ) ; if ( angle < _ NUM ) { angle += _ NUM ; } return angle ; }
public int count In (  Char Sequence sequence ) { int count = _ NUM ; for ( int i = _ NUM ; i < sequence . length ( ) ; i ++ ) { if ( matches ( sequence . char At ( i ) ) ) { count ++ ; } } return count ; }
public  Delta CRLIndicator Extension ( int crl Num ) throws  IOException { super (  PKIXExtensions .  Delta CRLIndicator_ Id , _ BOOL ,  Big Integer . value Of ( crl Num ) ,  NAME ,  LABEL ) ; }
static private double calc Log Prob ( int num Appear , double mu ) { final double sigma = calc Sigma From Mu ( mu ) ; final double log Num Appear =  Math . log ( num Appear ) ; final double over Mu =  Math . max ( log Num Appear - mu , _ NUM ) ; final double res = - ( _ NUM / _ NUM ) * ( over Mu * over Mu ) / ( sigma * sigma ) - s_log Sqrt Two Pi -  Math . log ( sigma ) ; assert ( res <= _ NUM ) ; return res ; }
@  Override public  Software PIDController with Tolerance ( double tolerance ) { target = target . with Tolerance (  Math . abs ( tolerance ) ) ; return this ; }
protected final void drag Drop Finished ( final boolean success , final int operations , final int x , final int y ) {  Drag Source Event event = new  Drag Source Drop Event ( get Drag Source Context ( ) , operations & source Actions , success , x , y ) ;  Event Dispatcher dispatcher = new  Event Dispatcher (  DISPATCH_ FINISH , event ) ;  Sun Toolkit . invoke Later On App Context (  Sun Toolkit . target To App Context ( get Component ( ) ) , dispatcher ) ; start Secondary Event Loop ( ) ; set Native Context ( _ NUM ) ; drag Image = null ; drag Image Offset = null ; }
protected static  String extract Secret Access Key (  String s3uri ) { return s3uri . substring ( s3uri . index Of ( _ STR , s3uri . index Of ( _ STR ) + _ NUM ) + _ NUM , s3uri . index Of ( _ STR ) ) ; }
private void dial (  String contact Information , boolean make The Call , boolean use Phone Speaker ) { if ( contact Information . equals ( _ STR ) ) {  String last Recipient =  Recipient Cmd . get Last Recipient Number ( ) ;  String last Recipient Name =  Recipient Cmd . get Last Recipient Name ( ) ; if ( last Recipient != null ) { do Dial ( last Recipient Name , last Recipient , make The Call , use Phone Speaker ) ; } else { send ( _ STR ) ; } } else {  Resolved Contact resolved Contact = m Contacts Resolver . resolve Contact ( contact Information ,  Contacts Resolver .  TYPE_ ALL ) ; if ( resolved Contact == null ) { send (  R . string . chat_no_match_for , contact Information ) ; } else if ( resolved Contact . is Distinct ( ) ) { do Dial ( resolved Contact . get Name ( ) , resolved Contact . get Number ( ) , make The Call , use Phone Speaker ) ; } else { ask For More Details ( resolved Contact . get Candidates ( ) ) ; } } }
public void add Safe Class (  Soot Class clz ) { safe Classes . add ( clz . get Name ( ) ) ; }
private boolean active List Has Room ( ) { int max Downloads = _ NUM ; return m Active List . size ( ) < max Downloads ; }
public boolean is Running ( ) { return this . running ; }
protected static  Map <  String ,  Step > parse (  Class < ? extends  RSLPStemmer Base > clazz ,  String resource ) { try {  Input Stream is = clazz . get Resource As Stream ( resource ) ;  Line Number Reader r = new  Line Number Reader ( new  Input Stream Reader ( is ,  Standard Charsets .  UTF_8 ) ) ;  Map <  String ,  Step > steps = new  Hash Map < > ( ) ;  String step ; while ( ( step = read Line ( r ) ) != null ) {  Step s = parse Step ( r , step ) ; steps . put ( s . name , s ) ; } r . close ( ) ; return steps ; } catch (  IOException e ) { throw new  Runtime Exception ( e ) ; } }
public  String bet To String ( ) { final  String Builder sb = new  String Builder ( ) ; sb . append ( amount ) ; sb . append ( _ STR ) ; sb . append ( item Name ) ; sb . append ( _ STR ) ; sb . append ( target ) ; return sb . to String ( ) ; }
public void test_non Empty Journal ( ) throws  IOException ,  Interrupted Exception ,  Execution Exception { final  File out =  File . create Temp File ( get Name ( ) ,  Options .  JNL ) ; try { final  Journal src = get Store ( get Properties ( ) ) ; try { if ( ! ( src . get Buffer Strategy ( ) instanceof  IHABuffer Strategy ) ) { return ; } src . write ( get Random Data ( _ NUM ) ) ; src . commit ( ) ; try { final  ISnapshot Factory snapshot Factory = new  My Snapshot Factory ( get Name ( ) , _ BOOL ) ; final  Future <  ISnapshot Result > f = src . snapshot ( snapshot Factory ) ; final  ISnapshot Result snapshot Result = f . get ( ) ; final  File snapshot File = snapshot Result . get File ( ) ; try { final  Journal tmp = open Snapshot ( snapshot Result ) ; assert Equals ( src . get Root Block View ( ) , tmp . get Root Block View ( ) ) ; tmp . destroy ( ) ; } finally { if ( snapshot File . exists ( ) ) { snapshot File . delete ( ) ; } } } catch (  Illegal Argument Exception ex ) { log . info ( _ STR + ex ) ; } } finally { src . destroy ( ) ; } } finally { out . delete ( ) ; } }
private boolean check Match Ip (  Map <  String ,  Object > rows ) { boolean match Ether = _ BOOL ;  String val = (  String ) rows . get (  Static Flow Entry Pusher .  COLUMN_ DL_ TYPE ) ; if ( val != null ) { int type = _ NUM ; if ( val . starts With ( _ STR ) ) { type =  Integer . parse Int ( val . substring ( _ NUM ) , _ NUM ) ; } else { try { type =  Integer . parse Int ( val ) ; } catch (  Number Format Exception e ) { } } if ( type == _ NUM ) match Ether = _ BOOL ; } if ( ( rows . contains Key (  Static Flow Entry Pusher .  COLUMN_ NW_ DST ) || rows . contains Key (  Static Flow Entry Pusher .  COLUMN_ NW_ SRC ) || rows . contains Key (  Static Flow Entry Pusher .  COLUMN_ NW_ PROTO ) || rows . contains Key (  Static Flow Entry Pusher .  COLUMN_ NW_ TOS ) ) && ( match Ether == _ BOOL ) ) return _ BOOL ; return _ BOOL ; }
public static double pow Quick ( double value , double power ) { if (  USE_ JDK_ MATH ) { return  STRICT_ MATH ?  Strict Math . pow ( value , power ) :  Math . pow ( value , power ) ; } return  Fast Math . exp ( power *  Fast Math . log Quick ( value ) ) ; }
private  String class To Entry Path (  Class < ? > clazz ) {  String name = _ STR ;  Class < ? > parent ; while ( ( parent = clazz . get Enclosing Class ( ) ) != null ) { name = _ STR + clazz . get Simple Name ( ) + name ; clazz = parent ; } return class Name To Entry Path ( clazz . get Canonical Name ( ) + name ) ; }
public static  String write (  POSMikheev Counter counter ) { return  POSBase Line Counter . write ( counter ) ; }
private  Map <  String ,  Annotation Mirror > annos In Package (  Package Element package Element ) { return create Imported Annotations Map (  Element Filter . types In ( package Element . get Enclosed Elements ( ) ) ) ; }
public  Osm Element paste From ( ) {  List <  Way > ways = storage . get Ways ( ) ;  List <  Node > nodes = storage . get Nodes ( ) ; if ( mode ==  Mode .  CUT ) { reset ( ) ; if ( ways != null && ways . size ( ) == _ NUM ) {  Way w = ways . get ( _ NUM ) ; w . set State ( saved State ) ; for (  Node nd : w . get Nodes ( ) ) {  Log . d ( _ STR , _ STR + nd . get Osm Id ( ) ) ; nd . set State ( saved Nd State . get ( nd ) ) ; } return w ; } else if ( nodes != null && nodes . size ( ) == _ NUM ) {  Node n = nodes . get ( _ NUM ) ; n . set State ( saved State ) ; return n ; } } else { if ( ways != null && ways . size ( ) == _ NUM ) { return ways . get ( _ NUM ) ; } else if ( nodes != null && nodes . size ( ) == _ NUM ) { return nodes . get ( _ NUM ) ; } } return null ; }
public final void update Cursor ( ) { update Pending . set ( _ BOOL ) ; update Cursor Impl ( ) ; }
public static boolean is Middle Mouse Button (  Mouse Event an Event ) { return ( ( an Event . get Modifiers Ex ( ) &  Input Event .  BUTTON2_ DOWN_ MASK ) != _ NUM || an Event . get Button ( ) ==  Mouse Event .  BUTTON2 ) ; }
public void add Success Message ( final  String success Message ) { success Message List . add ( success Message ) ; }
private void start Stopped Changed ( ) { clock . set Start Stopped ( start Stopped Check Box . is Selected ( ) ) ; changed = _ BOOL ; }
public void close ( ) throws  IOException { try {  Debug . message ( _ STR , _ STR ) ; if (  Debug . debugging ( _ STR ) ) {  Thread . sleep ( _ NUM ) ; } if ( input Stream != null ) input Stream . close ( ) ; } catch (  Exception e ) { e . print Stack Trace ( ) ; } input Stream = null ; }
private void read Binary ( final  Little Endian Data Input Stream dis ) throws  IOException {  Raj Log . i ( _ STR ) ; dis . skip ( _ NUM ) ; int facet Count = dis . read Int ( ) ; float [ ] vertices Arr = new float [ facet Count * _ NUM ] ; float [ ] normals Arr = new float [ facet Count * _ NUM ] ; int [ ] indices Arr = new int [ facet Count * _ NUM ] ; float [ ] temp Norms = new float [ _ NUM ] ; int vert Pos = _ NUM , norm Pos = _ NUM ; for ( int i = _ NUM ; i < indices Arr . length ; i ++ ) indices Arr [ i ] = i ; while ( dis . available ( ) > _ NUM ) { for ( int j = _ NUM ; j < _ NUM ; j ++ ) { temp Norms [ j ] = dis . read Float ( ) ; if (  Float . is Na N ( temp Norms [ j ] ) ||  Float . is Infinite ( temp Norms [ j ] ) ) {  Raj Log . w ( _ STR ) ; temp Norms [ _ NUM ] = _ NUM ; temp Norms [ _ NUM ] = _ NUM ; temp Norms [ _ NUM ] = _ NUM ; break ; } } for ( int j = _ NUM ; j < _ NUM ; j ++ ) { normals Arr [ norm Pos ++ ] = temp Norms [ _ NUM ] ; normals Arr [ norm Pos ++ ] = temp Norms [ _ NUM ] ; normals Arr [ norm Pos ++ ] = temp Norms [ _ NUM ] ; } for ( int j = _ NUM ; j < _ NUM ; j ++ ) vertices Arr [ vert Pos ++ ] = dis . read Float ( ) ; dis . skip ( _ NUM ) ; } m Root Object . set Data ( vertices Arr , normals Arr , null , null , indices Arr , _ BOOL ) ; }
public static void assert Specific Lang (  String specific Lang ) throws  XMPException { if ( specific Lang == null || specific Lang . length ( ) == _ NUM ) { throw new  XMPException ( _ STR ,  XMPError .  BADPARAM ) ; } }
public int on Block Exploded ( ) { return ( int ) ( fuse Time / _ NUM +  Math . random ( ) * fuse Time / _ NUM ) ; }
@  Override public boolean has Queued Reader Threads ( ) { return reader Lock . has Queued Threads ( ) ; }
public long inactive Time Millis ( ) { return  System . current Time Millis ( ) - last Time Millis ; }
public void add Definition (  ICOSDefinition cos Def ) throws  UMSException { if ( ! ( cos Def instanceof  Direct COSDefinition ) ) {  String msg = i18n . get String (  IUMSConstants .  INVALID_ COSDEFINITION ) ; throw new  UMSException ( msg ) ; }  String [ ] cos Attributes = cos Def . get COSAttributes ( ) ;  Abstract Collection a List = (  Abstract Collection )  Arrays . as List (  ICOSDefinition . qualifiers ) ; for ( int i = _ NUM ; i < cos Attributes . length ; i ++ ) {  String cos Attribute = null ;  String qualifier = null ;  String Tokenizer st = new  String Tokenizer ( cos Attributes [ i ] ) ; if ( st . has More Tokens ( ) ) { cos Attribute = st . next Token ( ) ; } if ( cos Attribute == null ) {  String msg = i18n . get String (  IUMSConstants .  INVALID_ COS_ ATTRIBUTE_ QUALIFIER ) ; throw new  UMSException ( msg ) ; } if ( st . has More Tokens ( ) ) qualifier = st . next Token ( ) ; if ( qualifier == null ) { qualifier =  ICOSDefinition . qualifiers [  ICOSDefinition .  DEFAULT ] ; cos Def . remove COSAttribute ( cos Attribute ) ; cos Def . add COSAttribute ( cos Attribute ,  ICOSDefinition .  DEFAULT ) ; } if ( ! a List . contains ( qualifier ) ) {  String msg = i18n . get String (  IUMSConstants .  INVALID_ COS_ ATTRIBUTE_ QUALIFIER ) ; throw new  UMSException ( msg ) ; } }  Persistent Object po = (  Persistent Object ) cos Def ; _parent Object . add Child ( po ) ; }
public static  Source Data Quality from XML (  Element dom Element ) {  Node List fields = dom Element . get Child Nodes ( ) ; int fields Count = fields . get Length ( ) ;  String field Name ;  String field Value String ;  Node field Node ;  Source Data Quality result = new  Source Data Quality ( ) ; for ( int i = _ NUM ; i != fields Count ; i ++ ) { field Node = fields . item ( i ) ; if ( field Node . get Node Type ( ) ==  Node .  ELEMENT_ NODE ) { field Name = field Node . get Node Name ( ) ;  Node field Value Node = field Node . get First Child ( ) ; if ( field Value Node != null ) { field Value String = field Value Node . get Node Value ( ) ; } else { field Value String = _ STR ; } if ( field Name . equals (  XML_ ELEMENT_ QUALITY_ CODE ) ) { result . quality Code =  Short . parse Short ( field Value String ) ; } else if ( field Name . equals (  XML_ ELEMENT_ QUALITY_ DESC ) ) { result . description = field Value String ; } } } return result ; }
QName to QName (  Class < ? > output Class ) {  String local Part ;  String namespace Uri ; if ( output Class . is Annotation Present (  Xml Root Element . class ) ) {  Xml Root Element annotation = output Class . get Annotation (  Xml Root Element . class ) ; local Part = annotation . name ( ) ; namespace Uri = annotation . namespace ( ) ; } else if ( output Class . is Annotation Present (  Xml Type . class ) ) {  Xml Type annotation = output Class . get Annotation (  Xml Type . class ) ; local Part = annotation . name ( ) ; namespace Uri = annotation . namespace ( ) ; } else { throw new  Illegal Argument Exception ( _ STR + output Class + _ STR + _ STR ) ; } if (  JAXB_ DEFAULT_ ANNOTATION_ VALUE . equals ( local Part ) ) { local Part =  Class Utils . get Short Name As Property ( output Class ) ; } if (  JAXB_ DEFAULT_ ANNOTATION_ VALUE . equals ( namespace Uri ) ) {  Package output Class Package = output Class . get Package ( ) ; if ( output Class Package != null && output Class Package . is Annotation Present (  Xml Schema . class ) ) {  Xml Schema annotation = output Class Package . get Annotation (  Xml Schema . class ) ; namespace Uri = annotation . namespace ( ) ; } else { namespace Uri =  XMLConstants .  NULL_ NS_ URI ; } } return new  QName ( namespace Uri , local Part ) ; }
private static  String generate JWT (  String secret ,  String jwt ID ,  String iss ,  Integer ttl ,  Map <  String ,  String > claims ) throws  Hmac Exception { try { return sign JWT ( secret , jwt ID , ttl , iss , claims ) ; } catch (  JOSEException e ) { e . print Stack Trace ( ) ; throw new  Hmac Exception ( _ STR , e ) ; } }
public void export Symbols (  String [ ] export Names ,  Symbol [ ] symbols ) { if ( exported Symbols == null ) { exported Symbols = new  Array List ( ) ; } for ( int i = _ NUM ; i < export Names . length && i < symbols . length ; i ++ ) { exported Symbols . add ( new  Exported Symbol ( symbols [ i ] , export Names [ i ] ) ) ; } }
@  Override public synchronized void add Data Source Listener (  Data Source Listener dsl ) { m_data Source Listeners . add Element ( dsl ) ; if ( m_format != null ) {  Data Set Event e = new  Data Set Event ( this , m_format ) ; dsl . accept Data Set ( e ) ; } }
public static  Annotation Mirror find Effective Annotation In Hierarchy ( final  Qualifier Hierarchy qualifier Hierarchy , final  Annotated Type Mirror to Search , final  Annotation Mirror top ) { return find Effective Annotation In Hierarchy ( qualifier Hierarchy , to Search , top , _ BOOL ) ; }
public boolean to Fail ( ) {  Lifecycle State state ; synchronized ( this ) { state = _state ; if ( state . is After Destroying ( ) ) { return _ BOOL ; } _state =  FAILED ; _last Change Time =  Current Time . current Time ( ) ; } if ( _log != null && _log . is Loggable ( _level ) ) _log . log ( _level , _ STR + _name ) ; notify Listeners ( state ,  FAILED ) ; _fail Count ++ ; return _ BOOL ; }
private static void read (  Input Stream in , byte [ ] buf , int pos , int n ) throws  IOException { int read = _ NUM ; int res = _ NUM ; while ( read < n ) { res = in . read ( buf , read + pos , n - read ) ; if ( res > _ NUM ) { read += res ; } else { throw new  IOException ( _ STR + read + _ STR + n ) ; } } }
public double evaluate (  Vector Instance x ,  Vector Instance y ) throws  Exception {  Vector Instance diff = x . subtract ( y ) ; double result = - m_gamma * diff . dot Product ( diff ) ; return  Math . exp ( result ) ; }
void cancel Included Only ( ) { if ( ! _show All Input ) { _input All Button . do Click ( ) ; } if ( ! _show All Output ) { _output All Button . do Click ( ) ; } if ( ! _show All Align ) { _align All Button . do Click ( ) ; } }
List <  Entry > kill All ( boolean root Included ) {  List <  Entry > killed = new  Array List < > ( root Included ? entries . size ( ) : entries . size ( ) - _ NUM ) ;  Entry entry ; for ( int i = entries . size ( ) - _ NUM ; i > ( root Included ? - _ NUM : _ NUM ) ; i -- ) { entry = entries . get ( i ) ; if ( entry . dead ) continue ; entry . dead = _ BOOL ; if ( i != _ NUM ) { killed . add ( entry ) ; } } return killed ; }
public static  String check Index Header Suffix (  Data Input in ,  String expected Suffix ) throws  IOException { int suffix Length = in . read Byte ( ) & _ NUM ; byte suffix Bytes [ ] = new byte [ suffix Length ] ; in . read Bytes ( suffix Bytes , _ NUM , suffix Bytes . length ) ;  String suffix = new  String ( suffix Bytes , _ NUM , suffix Bytes . length ,  Standard Charsets .  UTF_8 ) ; if ( ! suffix . equals ( expected Suffix ) ) { throw new  Corrupt Index Exception ( _ STR + expected Suffix + _ STR + suffix , in ) ; } return suffix ; }
public static  String parse Disk String (  String input ) {  String delims = _ STR ;  String [ ] tokens = input . split ( delims ) ; return tokens [ _ NUM ] ; }
protected void draw Cloud ( int x , int y , int w , int h ,  Color fill Color ,  Paint fill Paint ,  Color pen Color , boolean shadow ) {  General Path path = new  General Path ( ) ; path . move To ( ( float ) ( x + _ NUM * w ) , ( float ) ( y + _ NUM * h ) ) ; path . curve To ( ( float ) ( x + _ NUM * w ) , ( float ) ( y + _ NUM * h ) , ( float ) x , ( float ) ( y + _ NUM * h ) , ( float ) ( x + _ NUM * w ) , ( float ) ( y + _ NUM * h ) ) ; path . curve To ( ( float ) x , ( float ) ( y + _ NUM * h ) , ( float ) ( x + _ NUM * w ) , ( float ) ( y + _ NUM * h ) , ( float ) ( x + _ NUM * w ) , ( float ) ( y + _ NUM * h ) ) ; path . curve To ( ( float ) ( x + _ NUM * w ) , ( float ) ( y + h ) , ( float ) ( x + _ NUM * w ) , ( float ) ( y + h ) , ( float ) ( x + _ NUM * w ) , ( float ) ( y + _ NUM * h ) ) ; path . curve To ( ( float ) ( x + w ) , ( float ) ( y + _ NUM * h ) , ( float ) ( x + w ) , ( float ) ( y + _ NUM * h ) , ( float ) ( x + _ NUM * w ) , ( float ) ( y + _ NUM * h ) ) ; path . curve To ( ( float ) ( x + w ) , ( float ) ( y + _ NUM * h ) , ( float ) ( x + _ NUM * w ) , ( float ) ( y + _ NUM * h ) , ( float ) ( x + _ NUM * w ) , ( float ) ( y + _ NUM * h ) ) ; path . curve To ( ( float ) ( x + _ NUM * w ) , ( float ) ( y + _ NUM * h ) , ( float ) ( x + _ NUM * w ) , ( float ) ( y + _ NUM * h ) , ( float ) ( x + _ NUM * w ) , ( float ) ( y + _ NUM * h ) ) ; path . close Path ( ) ; draw Path ( path , fill Color , fill Paint , pen Color , shadow ) ; }
private static boolean is Trusted (  Object obj ,  Trust Verifier .  Context ctx ) throws  Remote Exception {  Object saved = state . get ( ) ; try { state . set ( obj ) ; return ctx . is Trusted Object ( obj ) ; } finally { state . set ( saved ) ; } }
public static  Persistent Search Request Control new Control ( final boolean is Critical , final boolean changes Only , final boolean return ECs , final  Persistent Search Change Type ... change Types ) {  Reject . if Null ( (  Object ) change Types ) ; return new Control ( is Critical , changes Only , return ECs ,  Arrays . as List ( change Types ) ) ; }
private void connect Equalized (  Synapse Group synapse Group ) { current Ordering Indices = new int [ source Neurons . length ] ; int num Connects Per Src ; int expected Num Syns ; if ( synapse Group . is Recurrent ( ) && ! self Connection Allowed ) { num Connects Per Src = ( int ) ( connection Density * ( source Neurons . length - _ NUM ) ) ; } else { num Connects Per Src = ( int ) ( connection Density * target Neurons . length ) ; } expected Num Syns = num Connects Per Src * source Neurons . length ; synapse Group . pre Allocate Synapses ( expected Num Syns ) ; for ( int i = _ NUM , n = source Neurons . length ; i < n ; i ++ ) { current Ordering Indices [ i ] = num Connects Per Src ;  Neuron src = source Neurons [ i ] ;  Neuron tar ; for ( int j = _ NUM ; j < num Connects Per Src ; j ++ ) { tar = target Neurons [ sparse Ordering [ i ] [ j ] ] ;  Synapse s = new  Synapse ( src , tar ) ; synapse Group . add New Synapse ( s ) ; } } }
public static  Number multiply (  Character left ,  Character right ) { return multiply (  Integer . value Of ( left ) , right ) ; }
public static  String normalize ( final  Char Sequence self ) { final  String s = self . to String ( ) ; int nx = s . index Of ( _ STR ) ; if ( nx < _ NUM ) { return s ; } final int len = s . length ( ) ; final  String Builder sb = new  String Builder ( len ) ; int i = _ NUM ; do { sb . append ( s , i , nx ) ; sb . append ( _ STR ) ; if ( ( i = nx + _ NUM ) >= len ) break ; if ( s . char At ( i ) == _ STR ) { if ( ++ i >= len ) break ; } nx = s . index Of ( _ STR , i ) ; } while ( nx > _ NUM ) ; sb . append ( s , i , len ) ; return sb . to String ( ) ; }
public void add Zone Change Listener (  Zone Change Listener listener ) { zone Change Listeners . add ( listener ) ; }
public void write ( final int b ) throws  IOException { if ( m_store == null ) { throw new  Illegal State Exception (  ERR_ NO_ STORE ) ; } if ( m_is Saved ) { throw new  Illegal State Exception (  ERR_ ALREADY_ SAVED ) ; } if ( m_count == m_blob Threshold && ! m_writing Hdr ) { if ( m_blob Header == null ) { m_blob Header = new  Array List <  Integer > ( ) ; } final int cur Addr = ( int ) m_store . alloc ( m_buf , m_count , m_context ) ; m_blob Header . add ( cur Addr ) ; m_count = _ NUM ; } m_buf [ m_count ++ ] = ( byte ) b ; m_bytes Written ++ ; }
public  Start Listener (  Object resource ) { _resource = resource ; }
public  List <  T > as Flat List ( ) {  List <  T > list = new  Array List <  T > ( ) ; for ( int i = _ NUM ; i < get Row Count ( ) ; i ++ ) { for ( int j = _ NUM ; j < get Column Count ( ) ; j ++ ) { list . add ( get Logical Value At ( i , j ) ) ; } } return list ; }
public void record Timestamp ( ) { long cur Timestamp =  System . current Time Millis ( ) ; if ( used Fields > _ NUM ) { long diff = cur Timestamp - last Value ; if ( used Fields == diffs . length ) { long removed Value = diffs [ cur Position ] ; diffs [ cur Position ] = diff ; calculate New Average ( removed Value , diff , _ BOOL ) ; shift End ( ) ; } else { calculate New Average ( _ NUM , diff , _ BOOL ) ; diffs [ cur Position ] = diff ; shift End ( ) ; } } else if ( last Value != - _ NUM ) { long diff = cur Timestamp - last Value ; current Average = _ NUM ; diffs [ cur Position ] = diff ; calculate New Average ( _ NUM , diff , _ BOOL ) ; shift End ( ) ; } last Value = cur Timestamp ; }
@  After Method public void tear Down ( ) throws  Exception {  Throwable t = thread Failure . get And Set ( null ) ; if ( t != null ) { if ( t instanceof  Error ) throw (  Error ) t ; else if ( t instanceof  Runtime Exception ) throw (  Runtime Exception ) t ; else if ( t instanceof  Exception ) throw (  Exception ) t ; else {  Assertion Failed Error afe = new  Assertion Failed Error ( t . to String ( ) ) ; afe . init Cause ( t ) ; throw afe ; } } if (  Thread . interrupted ( ) ) tear Down Fail ( _ STR ) ; check Fork Join Pool Thread Leaks ( ) ; }
protected double default Max Radius ( ) { return  Math . sqrt ( _ NUM ) ; }
public char [ ] to Char Array ( ) { char [ ] new Value = new char [ count ] ;  System . arraycopy ( buf , _ NUM , new Value , _ NUM , count ) ; return new Value ; }
public void insert (  Component component , int index ) { if ( index < _ NUM ) { throw new  Illegal Argument Exception ( _ STR ) ; } int nitems = get Component Count ( ) ;  Vector <  Component > temp Items = new  Vector <  Component > ( ) ; for ( int i = index ; i < nitems ; i ++ ) { temp Items . add Element ( get Component ( index ) ) ; remove ( index ) ; } add ( component ) ; for (  Component temp Item : temp Items ) { add ( temp Item ) ; } }
public static  List <  String > unescape (  String source , char escape Char , char [ ] special Characters , char split Character , int split Limit ) {  List <  String > result = new  Linked List < > ( ) ;  String Builder b = new  String Builder ( ) ; boolean read Escape = _ BOOL ; int index Count = - _ NUM ; for ( char c : source . to Char Array ( ) ) { index Count ++ ; if ( read Escape ) { boolean found = _ BOOL ; if ( c == split Character ) { found = _ BOOL ; b . append ( c ) ; } else if ( c == escape Char ) { found = _ BOOL ; b . append ( c ) ; } else { for ( char s : special Characters ) { if ( s == c ) { found = _ BOOL ; b . append ( c ) ; break ; } } } if ( ! found ) { throw new  Illegal Argument Exception ( _ STR + source + _ STR + c + _ STR ) ; } read Escape = _ BOOL ; } else if ( c == escape Char ) { read Escape = _ BOOL ; } else if ( c == split Character ) { read Escape = _ BOOL ; result . add ( b . to String ( ) ) ; if ( split Limit != - _ NUM ) { if ( result . size ( ) == split Limit - _ NUM ) { result . add ( source . substring ( index Count + _ NUM ) ) ; return result ; } } b = new  String Builder ( ) ; } else { read Escape = _ BOOL ; b . append ( c ) ; } } result . add ( b . to String ( ) ) ; return result ; }
@  Override public  String append (  String path ,  Input Stream is ) throws  Malformed URLException ,  IOException ,  Authentication Exception {  String resp = null ; ensure Valid Token ( ) ;  String spec =  Message Format . format ( _ STR ,  URLUtil . encode Path ( path ) , this . principal ) ;  String redirect Url = null ;  Http URLConnection conn = authenticated URL . open Connection ( new  URL ( new  URL ( httpfs Url ) , spec ) , token ) ; conn . set Request Method ( _ STR ) ; conn . set Instance Follow Redirects ( _ BOOL ) ; conn . connect ( ) ; logger . info ( _ STR + conn . get Header Field ( _ STR ) ) ; resp = result ( conn , _ BOOL ) ; if ( conn . get Response Code ( ) == _ NUM ) redirect Url = conn . get Header Field ( _ STR ) ; conn . disconnect ( ) ; if ( redirect Url != null ) { conn = authenticated URL . open Connection ( new  URL ( redirect Url ) , token ) ; conn . set Request Method ( _ STR ) ; conn . set Do Output ( _ BOOL ) ; conn . set Do Input ( _ BOOL ) ; conn . set Use Caches ( _ BOOL ) ; conn . set Request Property ( _ STR , _ STR ) ; final int _ SIZE = is . available ( ) ; conn . set Request Property ( _ STR , _ STR + _ SIZE ) ; conn . set Fixed Length Streaming Mode ( _ SIZE ) ; conn . connect ( ) ;  Output Stream os = conn . get Output Stream ( ) ; copy ( is , os ) ; is . close ( ) ; os . close ( ) ; resp = result ( conn , _ BOOL ) ; conn . disconnect ( ) ; } return resp ; }
public  Economy Concurrent Hash Map (  Map < ? extends  K , ? extends  V > m ,  IHash Entry Handler <  K ,  V > handler ) { this (  Math . max ( ( int ) ( m . size ( ) /  DEFAULT_ LOAD_ FACTOR ) + _ NUM ,  DEFAULT_ INITIAL_ CAPACITY ) ,  DEFAULT_ LOAD_ FACTOR ,  DEFAULT_ CONCURRENCY_ LEVEL , handler ) ; put All ( m ) ; }
void add Rule (  String [ ] selector ,  Attribute Set declaration , boolean is Linked ) { int n = selector . length ;  String Builder sb = new  String Builder ( ) ; sb . append ( selector [ _ NUM ] ) ; for ( int counter = _ NUM ; counter < n ; counter ++ ) { sb . append ( _ STR ) ; sb . append ( selector [ counter ] ) ; }  String selector Name = sb . to String ( ) ;  Style rule = get Style ( selector Name ) ; if ( rule == null ) {  Style alt Rule = add Style ( selector Name , null ) ; synchronized ( this ) {  Selector Mapping mapping = get Root Selector Mapping ( ) ; for ( int i = n - _ NUM ; i >= _ NUM ; i -- ) { mapping = mapping . get Child Selector Mapping ( selector [ i ] , _ BOOL ) ; } rule = mapping . get Style ( ) ; if ( rule == null ) { rule = alt Rule ; mapping . set Style ( rule ) ; refresh Resolved Rules ( selector Name , selector , rule , mapping . get Specificity ( ) ) ; } } } if ( is Linked ) { rule = get Linked Style ( rule ) ; } rule . add Attributes ( declaration ) ; }
public  Builder append Read Data ( byte [ ] data ) {  Assertions . check State ( data != null && data . length > _ NUM ) ; segments . add ( new  Segment ( data , null ) ) ; return this ; }
private boolean is Latest Dss Keystore (  TSLParser Result parse Result ) {  List <  String > english Scheme Information URIs = parse Result . get English Scheme Information URIs ( ) ; return english Scheme Information URIs . contains ( oj Url ) ; }
public  Layer Graphic Warehouse Support ( ) { init Drawing Attributes ( ) ; graphics = new  OMGraphic List ( ) ; graphics . set Traverse Mode (  OMGraphic List .  LAST_ ADDED_ ON_ TOP ) ; }
public boolean matches Naming Convension ( ) { return package Name . matches (  JAVA_ PACKAGE_ CONVENSION ) ; }
void remember Factory (  String host ,  RMISocket Factory factory ) { synchronized ( success Table ) { while ( host List . size ( ) >=  Max Remembered Hosts ) { success Table . remove ( host List . element At ( _ NUM ) ) ; host List . remove Element At ( _ NUM ) ; } host List . add Element ( host ) ; success Table . put ( host , factory ) ; } }
private  Map .  Entry <  K ,  V > do Remove First Entry ( ) { for (  Node <  K ,  V > b , n ; ; ) { if ( ( n = ( b = head . node ) . next ) == null ) return null ;  Node <  K ,  V > f = n . next ; if ( n != b . next ) continue ;  Object v = n . value ; if ( v == null ) { n . help Delete ( b , f ) ; continue ; } if ( ! n . cas Value ( v , null ) ) continue ; if ( ! n . append Marker ( f ) || ! b . cas Next ( n , f ) ) find First ( ) ; clear Index To First ( ) ; @  Suppress Warnings ( _ STR )  V vv = (  V ) v ; return new  Abstract Map .  Simple Immutable Entry <  K ,  V > ( n . key , vv ) ; } }
public  Compute Task Cancelled Exception (  Throwable cause ) { this ( cause . get Message ( ) , cause ) ; }
public static int normalize ( char [ ] src , int src Start , int src Limit , char [ ] dest , int dest Start , int dest Limit ,  Mode mode , int options ) { int length = mode . normalize ( src , src Start , src Limit , dest , dest Start , dest Limit , options ) ; if ( length <= ( dest Limit - dest Start ) ) { return length ; } else { throw new  Index Out Of Bounds Exception (  Integer . to String ( length ) ) ; } }
private void remove Obsolete Elements (  List <  String > names ,  Map <  String ,  View > shared Elements ,  List <  String > elements To Remove ) { if ( elements To Remove . size ( ) > _ NUM ) { names . remove All ( elements To Remove ) ; for (  String element To Remove : elements To Remove ) { shared Elements . remove ( element To Remove ) ; } } }
public boolean is Highlight With Invisible Edge ( ) { return highlight With Invisible Edge ; }
public void remove Action (  Network Update Action action ) { action List . remove ( action ) ; for (  Update Manager Listener listener : listeners ) { listener . action Removed ( action ) ; } }
public static double buffer Distance Error ( int quad Segs ) { double alpha =  Math .  PI / _ NUM / quad Segs ; return _ NUM -  Math . cos ( alpha / _ NUM ) ; }
public  Pair <  String ,  String > next ( ) { try { current Header Position = next Header Position ;  String read Header = next Line ; next Header Position += read Header . length ( ) + end Of Line Bytes ; read Header = _ STR + read Header . substring ( _ NUM ) ;  String read Sequence = r . read Line ( ) ; next Header Position += read Sequence . length ( ) + end Of Line Bytes ;  String comments = r . read Line ( ) ; next Header Position += comments . length ( ) + end Of Line Bytes ; if ( comments . starts With ( _ STR ) ) {  String quality Values = r . read Line ( ) ; next Header Position += quality Values . length ( ) + end Of Line Bytes ; } next Line = r . read Line ( ) ; return new  Pair < > ( read Header , read Sequence ) ; } catch (  IOException e ) {  Basic . caught ( e ) ; } return null ; }
public void add (  Character character ) { elements . add ( character == null ?  Json Null .  INSTANCE : new  Json Primitive ( character ) ) ; }
public void remove Child (  Group the Group ) { m Children . remove ( the Group ) ; }
protected  Storage Port check Port Exists In DB (  String native Guid ) throws  IOException {  Storage Port port = null ;  List <  Storage Port > port In DB =  Custom Query Utility . get Active Storage Port By Native Guid ( _db Client , native Guid ) ; if ( port In DB != null && ! port In DB . is Empty ( ) ) { port = port In DB . get ( _ NUM ) ; } return port ; }
public void append Split Element (  Fragment a Split ) { splits . add ( a Split ) ; }
public  Osm Handler (  Map Builder me Consumer ) { osm Element Processor = new  Osm Element Processor ( null , me Consumer ) ; }
public void close ( ) throws  IOException { flush Bits ( ) ; out . close ( ) ; }
public  Respoke Direct Connection direct Connection ( ) { if ( null != direct Connection Reference ) { return direct Connection Reference . get ( ) ; } else { return null ; } }
private  String append National Number (  String national Number ) { int prefix Before National Number Length = prefix Before National Number . length ( ) ; if ( should Add Space After National Prefix && prefix Before National Number Length > _ NUM && prefix Before National Number . char At ( prefix Before National Number Length - _ NUM ) !=  SEPARATOR_ BEFORE_ NATIONAL_ NUMBER ) { return new  String ( prefix Before National Number ) +  SEPARATOR_ BEFORE_ NATIONAL_ NUMBER + national Number ; } else { return prefix Before National Number + national Number ; } }
public void cut ( ) { copy ( ) ; delete Selected Objects ( ) ; }
public void stop ( ) { set Led On ( _ BOOL ) ; if ( null != blink Future ) { blink Future . cancel ( _ BOOL ) ; } if ( null != blink Service ) { blink Service . shutdown Now ( ) ; } }
public synchronized void release ( ) { index . clear ( ) ; }
public void configure ( ) { if ( cmd Prefix != null ) { prefix = cmd Prefix . split ( _ STR ) ; } }
protected void write Transform (  Affine Transform t ) throws  IOException { page Stream . matrix ( t ) ; }
public void test Signum Positive ( ) {  String a = _ STR ; int a Scale = _ NUM ;  Big Decimal a Number = new  Big Decimal ( new  Big Integer ( a ) , a Scale ) ; assert Equals ( _ STR , _ NUM , a Number . signum ( ) ) ; }
public  Painter Chain prepend Painter (  Painter p ) {  Painter [ ] new Chain = new  Painter [ chain . length + _ NUM ] ;  System . arraycopy ( chain , _ NUM , new Chain , _ NUM , chain . length ) ; new Chain [ _ NUM ] = p ; return new  Painter Chain ( new Chain ) ; }
@  Nullable private  Operator .  Kind parse Operator (  Token Stream tokens ) { if ( tokens . has ( _ STR ) ) { tokens . next ( ) ; tokens . expect ( _ STR ) ; return  Operator .  Kind .  EQUALS ; } if ( tokens . has ( _ STR ) ) { tokens . next ( ) ; tokens . expect ( _ STR ) ; return  Operator .  Kind .  NOT_ EQUALS ; } if ( tokens . has ( _ STR ) ) { tokens . next ( ) ; if ( tokens . has ( _ STR ) ) { tokens . next ( ) ; return  Operator .  Kind .  LESS_ EQUAL ; } return  Operator .  Kind .  LESS ; } if ( tokens . has ( _ STR ) ) { tokens . next ( ) ; if ( tokens . has ( _ STR ) ) { tokens . next ( ) ; return  Operator .  Kind .  GREATER_ EQUAL ; } return  Operator .  Kind .  GREATER ; } return null ; }
@  Override public boolean drag To (  Selector obj ,  Selector dest Obj , int steps ) throws  Ui Object Not Found Exception ,  Not Implemented Exception { return drag To ( device . find Object ( obj . to Ui Selector ( ) ) , dest Obj , steps ) ; }
private void queue Up Syncs ( final  Cursor contacts Cursor ) {  Contact Sync Entry sync Entry = null ; while ( contacts Cursor . move To Next ( ) ) { if ( sync Entry == null ) { sync Entry = new  Contact Sync Entry (  UPLOAD_ BATCH_ SIZE ) ; } final  String number = contacts Cursor . get String ( contacts Cursor . get Column Index (  Contacts Contract .  Common Data Kinds .  Phone .  NUMBER ) ) ; final  String name = contacts Cursor . get String ( contacts Cursor . get Column Index (  Contacts Contract .  Common Data Kinds .  Phone .  DISPLAY_ NAME ) ) ; if ( !  Text Utils . is Empty ( number ) ) { sync Entry . add Number ( number To National ( number ) ) ; sync Entry . add Name ( name ) ; if ( sync Entry . is Full ( ) ) {  Logger . d (  TAG , _ STR ) ; m Sync Queue . add ( sync Entry ) ; sync Entry = null ; } } } }
public static void write Result To File (  Result result ,  String fname ) throws  Exception {  Print Writer outer = new  Print Writer ( new  Buffered Writer ( new  File Writer ( fname ) ) ) ; outer . write ( result . to String ( ) ) ; outer . close ( ) ; }
private  JMXProvider ( ) { }
private static void render Tree (  Tree tree , int indent , boolean parent Label Null , boolean first Sibling , boolean left Sibling Pre Terminal , boolean top Level ,  String Builder sb ) { boolean suppress Indent = ( parent Label Null || ( first Sibling && tree . is Pre Terminal ( ) ) || ( left Sibling Pre Terminal && tree . is Pre Terminal ( ) ) ) ; if ( suppress Indent ) { sb . append ( _ STR ) ; } else { if ( ! top Level ) { sb . append ( _ STR ) ; } for ( int i = _ NUM ; i < indent ; i ++ ) { sb . append ( _ STR ) ; } } if ( tree . is Leaf ( ) || tree . is Pre Terminal ( ) ) { render Flat ( tree , sb ) ; return ; } sb . append ( _ STR ) ; sb . append ( tree . get Label ( ) ) ; render Children ( tree . get Children ( ) , indent + _ NUM , _ BOOL , sb ) ; sb . append ( _ STR ) ; }
public static  String Buffer replace Regex (  String Buffer original ,  String regex ,  String replace , boolean  CASE_ INSENSITIVE ) { int flags = _ NUM ; if (  CASE_ INSENSITIVE ) flags =  Pattern .  CASE_ INSENSITIVE ;  Pattern p =  Pattern . compile ( regex , flags ) ;  Matcher m = p . matcher ( original ) ;  String Buffer new SB = new  String Buffer ( ) ; boolean result = m . find ( ) ; while ( result ) { m . append Replacement ( new SB , replace ) ; result = m . find ( ) ; } m . append Tail ( new SB ) ; return new SB ; }
public boolean equals Chars (  String a , int ai ,  String b , int bi , boolean ignore Case ) { char ca = a . char At ( ai ) ; char cb = b . char At ( bi ) ; if ( ignore Case ) { ca =  Character . to Upper Case ( ca ) ; cb =  Character . to Upper Case ( cb ) ; } return ca == cb ; }
private void adjust Backing File Length ( byte [ ] buffer , long index ) throws  IOException { if ( buffer == null || buffer . length == _ NUM ) { throw new  IOException ( _ STR ) ; } long newsize = f Header . header Size ( ) + ( index *  CHUNK_ ENC_ SIZE ) +  CHUNK_ IV_ SIZE + buffer . length +  CHUNK_ TLEN ; if ( newsize > real Length ( ) ) { backing Random Access File . set Length ( newsize ) ; } }
private static  Collection <  Collection <  Dsn Net Pin > > create_ordered_subnets (  Collection <  Dsn Net Pin > p_pin_list ) {  Collection <  Collection <  Dsn Net Pin > > result = new  Linked List <  Collection <  Dsn Net Pin > > ( ) ; if ( p_pin_list . is Empty ( ) ) { return result ; }  Iterator <  Dsn Net Pin > it = p_pin_list . iterator ( ) ;  Dsn Net Pin prev_pin = it . next ( ) ; while ( it . has Next ( ) ) {  Dsn Net Pin next_pin = it . next ( ) ;  Set <  Dsn Net Pin > curr_subnet_pin_list = new java . util .  Tree Set <  Dsn Net Pin > ( ) ; curr_subnet_pin_list . add ( prev_pin ) ; curr_subnet_pin_list . add ( next_pin ) ; result . add ( curr_subnet_pin_list ) ; prev_pin = next_pin ; } return result ; }
@  Override public void run ( int conn ID ,  String [ ] args ) { if ( args . length == _ NUM ) { server . send Server Chat ( conn ID , _ STR ) ; server . send Server Chat ( conn ID , _ STR ) ; server . send Server Chat ( conn ID , _ STR ) ; server . send Server Chat ( conn ID , _ STR ) ; server . send Server Chat ( conn ID , _ STR ) ; server . send Server Chat ( conn ID , _ STR ) ; server . send Server Chat ( conn ID , _ STR ) ; server . send Server Chat ( conn ID , _ STR ) ; server . send Server Chat ( conn ID , _ STR ) ; } try { if ( args . length > _ NUM ) {  String cmd = args [ _ NUM ] ; if ( cmd . equals Ignore Case ( _ STR ) ) { if ( args . length > _ NUM ) { int id =  Integer . parse Int ( args [ _ NUM ] ) ; server . send Server Chat ( conn ID , str List Network ( conn ID , id , _ BOOL ) ) ; } else { server . send Server Chat ( conn ID , str List Networks ( conn ID , _ BOOL ) ) ; } } else if ( cmd . equals Ignore Case ( _ STR ) ) { if ( args . length > _ NUM ) { int id =  Integer . parse Int ( args [ _ NUM ] ) ; server . send Server Chat ( conn ID , str List Network ( conn ID , id , _ BOOL ) ) ; } else { server . send Server Chat ( conn ID , str List Networks ( conn ID , _ BOOL ) ) ; } } else if ( cmd . equals Ignore Case ( _ STR ) ) { debug ( conn ID , server ) ; } else if ( cmd . equals Ignore Case ( _ STR ) ) { if ( args . length > _ NUM ) { int id1 =  Integer . parse Int ( args [ _ NUM ] ) ; int id2 =  Integer . parse Int ( args [ _ NUM ] ) ; int id3 =  Integer . parse Int ( args [ _ NUM ] ) ; server . send Server Chat ( conn ID , str Link3 ( conn ID , id1 , id2 , id3 ) ) ; } else if ( args . length > _ NUM ) { int id1 =  Integer . parse Int ( args [ _ NUM ] ) ; int id2 =  Integer . parse Int ( args [ _ NUM ] ) ; server . send Server Chat ( conn ID , str Link2 ( conn ID , id1 , id2 ) ) ; } } else if ( cmd . equals Ignore Case ( _ STR ) ) { if ( args . length > _ NUM ) { int id =  Integer . parse Int ( args [ _ NUM ] ) ; server . send Server Chat ( conn ID , str Unlink ID ( conn ID , id ) ) ; } else { server . send Server Chat ( conn ID , str Unlink All ( conn ID ) ) ; } } else {  String failstr = args [ _ NUM ] ; for ( int i = _ NUM ; i < args . length ; i ++ ) { failstr += _ STR + args [ i ] ; } server . send Server Chat ( conn ID , _ STR + failstr + _ STR ) ; } } } catch (  Number Format Exception nfe ) { server . send Server Chat ( conn ID , _ STR ) ; } catch (  Null Pointer Exception npe ) { server . send Server Chat ( conn ID , _ STR ) ; } catch (  Index Out Of Bounds Exception ioobe ) { server . send Server Chat ( conn ID , _ STR ) ; } }
private char [ ] parse Entity Reference ( ) throws  IOException { int pos = strpos ; if ( ( ch = read Ch ( ) ) == _ STR ) { int n = _ NUM ; ch = read Ch ( ) ; if ( ( ch >= _ STR ) && ( ch <= _ STR ) || ch == _ STR || ch == _ STR ) { if ( ( ch >= _ STR ) && ( ch <= _ STR ) ) { while ( ( ch >= _ STR ) && ( ch <= _ STR ) ) { n = ( n * _ NUM ) + ch - _ STR ; ch = read Ch ( ) ; } } else { ch = read Ch ( ) ; char lch = ( char )  Character . to Lower Case ( ch ) ; while ( ( lch >= _ STR ) && ( lch <= _ STR ) || ( lch >= _ STR ) && ( lch <= _ STR ) ) { if ( lch >= _ STR && lch <= _ STR ) { n = ( n * _ NUM ) + lch - _ STR ; } else { n = ( n * _ NUM ) + lch - _ STR + _ NUM ; } ch = read Ch ( ) ; lch = ( char )  Character . to Lower Case ( ch ) ; } } switch ( ch ) { case _ STR : ln ++ ; ch = read Ch ( ) ; lf Count ++ ; break ; case _ STR : ln ++ ; if ( ( ch = read Ch ( ) ) == _ STR ) { ch = read Ch ( ) ; crlf Count ++ ; } else { cr Count ++ ; } break ; case _ STR : ch = read Ch ( ) ; break ; } char data [ ] = map Numeric Reference ( n ) ; return data ; } add String ( _ STR ) ; if ( ! parse Identifier ( _ BOOL ) ) { error ( _ STR ) ; strpos = pos ; char data [ ] = { _ STR , _ STR } ; return data ; } } else if ( ! parse Identifier ( _ BOOL ) ) { char data [ ] = { _ STR } ; return data ; } boolean semicolon = _ BOOL ; switch ( ch ) { case _ STR : ln ++ ; ch = read Ch ( ) ; lf Count ++ ; break ; case _ STR : ln ++ ; if ( ( ch = read Ch ( ) ) == _ STR ) { ch = read Ch ( ) ; crlf Count ++ ; } else { cr Count ++ ; } break ; case _ STR : semicolon = _ BOOL ; ch = read Ch ( ) ; break ; }  String nm = get String ( pos ) ;  Entity ent = dtd . get Entity ( nm ) ; if ( ! strict && ( ent == null ) ) { ent = dtd . get Entity ( nm . to Lower Case ( ) ) ; } if ( ( ent == null ) || ! ent . is General ( ) ) { if ( nm . length ( ) == _ NUM ) { error ( _ STR , nm ) ; return new char [ _ NUM ] ; }  String str = _ STR + nm + ( semicolon ? _ STR : _ STR ) ; char b [ ] = new char [ str . length ( ) ] ; str . get Chars ( _ NUM , b . length , b , _ NUM ) ; return b ; } return ent . get Data ( ) ; }
private static  String create Js Method Invocation Expression (  String method Name , boolean is Static ,  String ... param Names ) {  String Builder sb = new  String Builder ( ) ; sb . append ( is Static ?  WND :  THIS ) ; sb . append ( _ STR ) ; sb . append ( method Name ) ; sb . append ( _ STR ) ; for ( int i = _ NUM ; i < param Names . length ; i ++ ) { if ( i != _ NUM ) { sb . append ( _ STR ) ; } sb . append ( param Names [ i ] ) ; } sb . append ( _ STR ) ; return sb . to String ( ) ; }
public static  Node serializable Instance ( ) { return new  Graph Node ( _ STR ) ; }
protected void drop Tables (  List <  String > drop Table Names ,  SQLite Database db ) { if ( drop Table Names != null && ! drop Table Names . is Empty ( ) ) {  String [ ] drop Table SQLS = new  String [ drop Table Names . size ( ) ] ; for ( int i = _ NUM ; i < drop Table SQLS . length ; i ++ ) { drop Table SQLS [ i ] = generate Drop Table SQL ( drop Table Names . get ( i ) ) ; } execute ( drop Table SQLS , db ) ; } }
private  Segment create Disk Segment (  Segment Descriptor descriptor ) {  File segment File =  Segment File . create Segment File ( name , storage . directory ( ) , descriptor . id ( ) , descriptor . version ( ) ) ;  Buffer buffer =  File Buffer . allocate ( segment File ,  Math . min (  DEFAULT_ BUFFER_ SIZE , descriptor . max Segment Size ( ) ) ,  Integer .  MAX_ VALUE ) ; descriptor . copy To ( buffer ) ;  Segment segment = new  Segment ( new  Segment File ( segment File ) , buffer . slice ( ) , descriptor , create Index ( descriptor ) , new  Offset Predicate ( ) , serializer . clone ( ) , this ) ;  LOGGER . debug ( _ STR , segment ) ; return segment ; }
public  Boolean exists (  String email ) { for (  Person person : people ) { if ( email . equals ( person . get Email ( ) ) ) { return _ BOOL ; } } return _ BOOL ; }
public synchronized boolean remove All (  Collection c ) {  Object [ ] elements = get Array ( ) ; int len = elements . length ; if ( len != _ NUM ) { int newlen = _ NUM ;  Object [ ] temp = new  Object [ len ] ; for ( int i = _ NUM ; i < len ; ++ i ) {  Object element = elements [ i ] ; if ( ! c . contains ( element ) ) temp [ newlen ++ ] = element ; } if ( newlen != len ) { set Array ( copy Of Range ( temp , _ NUM , newlen ,  Object [ ] . class ) ) ; return _ BOOL ; } } return _ BOOL ; }
private double max Ignore Na N ( double a , double b ) { if (  Double . is Na N ( a ) ) { return b ; } if (  Double . is Na N ( b ) ) { return a ; } else { return  Math . max ( a , b ) ; } }
public void crab Down Dir Block For Modification (  Block Id blk ) { lock Tbl . x Lock ( blk , tx Num ) ; writen Index Blks . add ( blk ) ; }
private static void remove Reference To Connection ( final  Http Connection With Reference connection ) { synchronized (  REFERENCE_ TO_ CONNECTION_ SOURCE ) {  REFERENCE_ TO_ CONNECTION_ SOURCE . remove ( connection . reference ) ; } }
public boolean matches Word ( ) { return ! is Empty ( ) &&  Character . is Letter Or Digit ( queue . char At ( pos ) ) ; }
public  Vacuum Environment ( ) {  Random r = new  Random ( ) ; env State = new  Vacuum Environment State ( _ NUM == r . next Int ( _ NUM ) ?  Location State .  Clean :  Location State .  Dirty , _ NUM == r . next Int ( _ NUM ) ?  Location State .  Clean :  Location State .  Dirty ) ; }
public void generate (  Batch Environment env ,  Class Definition cdef ,  File dest Dir ) {  Remote Class remote Class =  Remote Class . for Class ( env , cdef ) ; if ( remote Class == null ) return ;  RMIGenerator gen ; try { gen = new  RMIGenerator ( env , cdef , dest Dir , remote Class , version ) ; } catch (  Class Not Found e ) { env . error ( _ NUM , _ STR , e . name ) ; return ; } gen . generate ( ) ; }
public void remove ( final  Creature Respawn Point point ) { respawn Points . remove ( point ) ; }
public  Photo (  File d ,  File f ) throws  IOException ,  Number Format Exception {  Extended Exif Interface exif = new  Extended Exif Interface ( f . to String ( ) ) ;  String lon Str = exif . get Attribute (  Exif Interface .  TAG_ GPS_ LONGITUDE ) ; if ( lon Str == null ) { throw new  IOException ( _ STR ) ; } float lonf = convert To Degree ( lon Str ) ;  String lon Ref = exif . get Attribute (  Exif Interface .  TAG_ GPS_ LONGITUDE_ REF ) ; if ( lon Ref != null && ! lon Ref . equals ( _ STR ) ) { lonf = - lonf ; } float latf = convert To Degree ( exif . get Attribute (  Exif Interface .  TAG_ GPS_ LATITUDE ) ) ;  String lat Ref = exif . get Attribute (  Exif Interface .  TAG_ GPS_ LATITUDE_ REF ) ; if ( lat Ref != null && ! lat Ref . equals ( _ STR ) ) { latf = - latf ; } lat = ( int ) ( latf * _ NUM ) ; lon = ( int ) ( lonf * _ NUM ) ;  Log . d ( _ STR , _ STR + lat + _ STR + lon ) ; ref = d . get Absolute Path ( ) + _ STR + f . get Name ( ) ;  String dir = exif . get Attribute (  Extended Exif Interface .  TAG_ GPS_ IMG_ DIRECTION ) ; if ( dir != null ) { direction = ( int )  Double . parse Double ( dir ) ; direction Ref = exif . get Attribute (  Extended Exif Interface .  TAG_ GPS_ IMG_ DIRECTION_ REF ) ;  Log . d ( _ STR , _ STR + dir + _ STR + direction + _ STR + direction Ref ) ; } }
public static long bytes To Long ( final byte [ ] bytes ) { final  Byte Buffer buffer =  Byte Buffer . allocate ( _ NUM ) ; buffer . put ( bytes , _ NUM , _ NUM ) ; buffer . flip ( ) ; return buffer . get Long ( ) ; }
@  Override public void mouse Entered (  Mouse Event evt ) { delegate . mouse Moved ( evt ) ; }
public static  String remove Formatting (  String line ) { int length = line . length ( ) ;  String Builder buffer = new  String Builder ( ) ; for ( int i = _ NUM ; i < length ; i ++ ) { char ch = line . char At ( i ) ; if ( ch != _ STR && ch != _ STR && ch != _ STR && ch != _ STR ) buffer . append ( ch ) ; } return buffer . to String ( ) ; }
public void print ( ) {  Object [ ] iter Charging Times = charging Times . to Array ( ) ;  Arrays . sort ( iter Charging Times ) ; for ( int i = _ NUM ; i < iter Charging Times . length ; i ++ ) {  Charge Log cur Item = (  Charge Log ) iter Charging Times [ i ] ; cur Item . print ( ) ; } }
public boolean is Empty ( ) { return rdns . is Empty ( ) ; }
private void write Local CSV (  Medtronic Sensor Record most Recent Data ,  Context context ) { try { if ( most Recent Data == null || most Recent Data . b GValue == null ) log . debug ( _ STR ) ; else log . debug ( _ STR + most Recent Data . b GValue ) ;  Object Output Stream oos = new  Object Output Stream ( new  File Output Stream ( new  File ( context . get Files Dir ( ) , _ STR ) ) ) ; oos . write Object ( most Recent Data ) ; oos . flush ( ) ; oos . close ( ) ; } catch (  Exception e ) {  Log . e (  TAG , _ STR , e ) ; log . error ( _ STR , e ) ; } }
public  Service Config create Organization Config (  String org Name ,  Map attrs ) throws  SMSException ,  SSOException { validate SSM ( ) ;  Service Schema Impl ss = ssm . get Schema (  Schema Type .  ORGANIZATION ) ; if ( ss == null ) {  String [ ] args = { service Name } ; throw ( new  SMSException (  IUMSConstants .  UMS_ BUNDLE_ NAME , _ STR , args ) ) ; }  String orgdn =  DNMapper . org Name To DN ( org Name ) ;  Create Service Config . check Base Nodes For Org ( token , orgdn , service Name , version ) ;  String org DN = scm . construct Service Config DN (  SMSUtils .  DEFAULT ,  Create Service Config .  ORG_ CONFIG_ NODE , orgdn ) ; try {  Cached SMSEntry c Entry =  Cached SMSEntry . get Instance ( token , org DN ) ; if ( c Entry . is Dirty ( ) ) { c Entry . refresh ( ) ; } if ( c Entry . is New Entry ( ) ) {  Create Service Config . create Sub Config Entry ( token , org DN , ss , null , null , attrs , org Name ) ; if (  Service Manager . is Coexistence Mode ( ) ) {  String sms DN =  DNMapper . org Name To DN ( org Name ) ;  Org Config Via AMSDK amsdk = new  Org Config Via AMSDK ( token ,  DNMapper . realm Name To AMSDKName ( sms DN ) , sms DN ) ; amsdk . assign Service ( service Name ) ; } } else if ( attrs != null && ! attrs . is Empty ( ) ) {  Service Config sc = get Organization Config ( org Name , null ) ; sc . set Attributes ( attrs ) ; } } catch (  Service Already Exists Exception slee ) { } return ( get Organization Config ( org Name , null ) ) ; }
public void delete Authentication Domain (  String realm ,  String cot Name ) throws  AMConsole Exception {  String [ ] param = { realm , cot Name } ; log Event ( _ STR , param ) ; try {  Circle Of Trust Manager manager = get Circle Of Trust Manager ( ) ; manager . delete Circle Of Trust ( realm , cot Name ) ; log Event ( _ STR , param ) ; } catch (  COTException e ) {  String str Error = get Error String ( e ) ;  String [ ] params Ex = { realm , cot Name , str Error } ; log Event ( _ STR , params Ex ) ; throw new  AMConsole Exception ( str Error ) ; } }
protected void add Source Code Remark (  Test Solution test Solution ,  Element element ,  String message Code ,  Evidence Element evidence Element ) { if ( evidence Element != null ) {  Collection <  Evidence Element > evidence Element List = new  Array List < > ( ) ; evidence Element List . add ( evidence Element ) ; process Remark Service . add Source Code Remark On Element ( test Solution , element , message Code , evidence Element List ) ; } else { process Remark Service . add Source Code Remark On Element ( test Solution , element , message Code ) ; } }
void event Pre Modify (  Action Type type , long position , boolean is Single ) { if ( type != current Action Type || ! is Single ||  System . current Time Millis ( ) - previous Time >  MERGE_ TIME || ( type ==  Action Type .  INSERT || type ==  Action Type .  OVERWRITE ) && action Exclusive End ( ) != position || type ==  Action Type .  DELETE && action Position ( ) != position && action Position ( ) - _ NUM != position ) { start Action ( type , is Single ) ; } else { is Backspace = action Position ( ) > position ; } if ( is Single && type ==  Action Type .  INSERT ) { update New Range ( position ) ; previous Time =  System . current Time Millis ( ) ; } }
void save Async (  Document Entity entity ,  Consumer <  Document Entity > call Back ) throws  Execute Async Query Exception ,  Unsupported Operation Exception ;
public  String resolve Parent Relation Name (  String parent Name ,  Object parent ,  String child Name ,  Object child ) { return parent Name ; }
public  Rel Node convert Select (  Sql Select select , boolean top ) { final  Sql Validator Scope select Scope = validator . get Where Scope ( select ) ; final  Blackboard bb = create Blackboard ( select Scope , null , top ) ; convert Select Impl ( bb , select ) ; return bb . root ; }
private static  String format Sample Rate ( int rate ) { return  MHZ_ FORMATTER . format ( ( double ) rate / _ NUM ) ; }
void start ( ) { this . running = _ BOOL ;  Thread thread = new  Thread ( this , _ STR + hash Code ( ) ) ; thread . set Daemon ( _ BOOL ) ; thread . start ( ) ; }
public static byte [ ] escape ( final byte [ ] bytes ) { final byte [ ] temp = new byte [ _ NUM * bytes . length ] ; int current Position = _ NUM ; for ( final byte b : bytes ) { if ( b ==  ESCAPE_ CHAR ) { temp [ current Position ++ ] =  ESCAPE_ CHAR ; temp [ current Position ++ ] =  REPLACEMENT_ CHAR ; } else if ( b ==  DELIMITER ) { temp [ current Position ++ ] =  ESCAPE_ CHAR ; temp [ current Position ++ ] =  ESCAPE_ CHAR ; } else { temp [ current Position ++ ] = b ; } } final byte [ ] escaped = new byte [ current Position ] ;  System . arraycopy ( temp , _ NUM , escaped , _ NUM , current Position ) ; return escaped ; }
public final native  String name ( ) ;
public static  String to String (  Document host Doc ) throws  IOException { try {  String Writer out = new  String Writer ( ) ;  DOMSource dom Source = new  DOMSource ( host Doc ) ;  Stream Result stream Result = new  Stream Result ( out ) ;  Transformer Factory tf =  Transformer Factory . new Instance ( ) ;  Transformer serializer = tf . new Transformer ( ) ; serializer . set Output Property (  Output Keys .  ENCODING ,  ENC . name ( ) ) ; serializer . set Output Property (  Output Keys .  METHOD , _ STR ) ; serializer . set Output Property (  Output Keys .  INDENT , _ STR ) ; serializer . set Output Property (  Output Keys .  DOCTYPE_ PUBLIC ,  Html Dom Util .  HTML_ STRICT ) ; serializer . transform ( dom Source , stream Result ) ; return out . to String ( ) ; } catch (  Transformer Exception e ) {  IOException r = new  IOException ( _ STR ) ; r . init Cause ( e ) ; throw r ; } }
public  Mongo Client client For Members (  Server Address ... seeds ) {  List <  Server Address > addresses = new  Array List < > ( ) ; for (  Server Address seed Address : seeds ) { if ( seed Address != null ) addresses . add ( seed Address ) ; } return client For Members ( addresses ) ; }
public static boolean string To Boolean Value (  String str ) throws  Expression Exception { str =  String Util . to Lower Case ( str . trim ( ) ) ; if ( str . equals ( _ STR ) || str . equals ( _ STR ) ) return _ BOOL ; else if ( str . equals ( _ STR ) || str . equals ( _ STR ) ) return _ BOOL ; throw new  Caster Exception ( _ STR + str + _ STR ) ; }
public void generate Class File (  Output Stream os ) {  Class Writer cw = new  Soot ASMClass Writer (  Class Writer .  COMPUTE_ FRAMES ) ; cv = cw ; generate Byte Code ( ) ; try { os . write ( cw . to Byte Array ( ) ) ; } catch (  IOException e ) { throw new  Runtime Exception ( _ STR , e ) ; } }
private static boolean use Compact Font Format (  Map <  String ,  Object > args , int compatibility Version ) {  String value = (  String ) args . get (  EMBEDASCFF ) ; boolean use CFF = _ BOOL ; if ( compatibility Version <  Mxml Configuration .  VERSION_4_0 ) use CFF = _ BOOL ; if ( value != null ) { use CFF =  Boolean . parse Boolean ( value . trim ( ) ) ; } return use CFF ; }
public static void main (  String [ ] args ) { new  Generator Tester ( args ) ; }
private  String mosesize (  String feature ) { if ( joshua Configuration . moses ) { if ( feature . starts With ( _ STR ) || feature . starts With ( _ STR ) ) return feature . replace ( _ STR , _ STR ) ; } return feature ; }
private void check Shutdown ( ) { synchronized ( mux ) { if ( is Being Shutdown ) throw new  Rejected Execution Exception ( _ STR ) ; } }
private static final void check Queue For Dependencies And Execute Unblocked Tasks ( ) {  List <  Progress Thread > to Remove = new  Linked List < > ( ) ; synchronized (  LOCK ) { for (  Progress Thread pg : queued Threads ) { if ( ! pg . is Blocked By Dependencies ( ) ) { if ( ! pg . is Waiting ( ) ) { to Remove . add ( pg ) ;  EXECUTOR . execute ( pg . make Wrapper ( ) ) ; } } } } for (  Progress Thread pg : to Remove ) { synchronized (  LOCK ) { queued Threads . remove ( pg ) ; } } }
private static short  Call Short Method V (  JNIEnvironment env , int obj JREF , int method ID ,  Address arg Address ) throws  Exception { if ( trace JNI )  VM . sys Write ( _ STR ) ;  Runtime Entrypoints . check JNICount Down To GC ( ) ; try {  Object obj = env . get JNIRef ( obj JREF ) ;  Object return Obj =  JNIHelpers . invoke With Var Arg ( obj , method ID , arg Address ,  Type Reference .  Short , _ BOOL ) ; return  Reflection . unwrap Short ( return Obj ) ; } catch (  Throwable unexpected ) { if ( trace JNI ) unexpected . print Stack Trace (  System . err ) ; env . record Exception ( unexpected ) ; return _ NUM ; } }
public static void draw Vertical Margin Indicator (  Graphics2 D g ,  String text , int x , int y1 , int y2 ) { if ( y1 > y2 ) { int temp = y1 ; y1 = y2 ; y2 = temp ; } if ( text == null ) { g . draw Line ( x , y1 , x , y2 ) ; g . draw Line ( x , y1 , x -  CONNECTION_ ARROW_ SIZE , y1 +  CONNECTION_ ARROW_ SIZE ) ; g . draw Line ( x , y1 , x +  CONNECTION_ ARROW_ SIZE , y1 +  CONNECTION_ ARROW_ SIZE ) ; g . draw Line ( x , y2 , x -  CONNECTION_ ARROW_ SIZE , y2 -  CONNECTION_ ARROW_ SIZE ) ; g . draw Line ( x , y2 , x +  CONNECTION_ ARROW_ SIZE , y2 -  CONNECTION_ ARROW_ SIZE ) ; return ; }  Canvas c = new  Canvas ( ) ;  Font Metrics fm = c . get Font Metrics ( s Font ) ; g . set Font ( s Font ) ; int padding = _ NUM ;  Rectangle2 D bounds = fm . get String Bounds ( text , g ) ; int th = ( int ) bounds . get Height ( ) ; int offset = _ NUM *  CONNECTION_ ARROW_ SIZE ; int h = ( ( y2 - y1 ) - ( th + _ NUM * padding ) ) / _ NUM ; if ( h <= padding ) { g . draw Line ( x , y1 , x , y2 ) ; g . draw String ( text , ( int ) ( x - bounds . get Width ( ) / _ NUM ) + offset , y2 - h - padding ) ; g . draw Line ( x -  CONNECTION_ ARROW_ SIZE , y1 , x +  CONNECTION_ ARROW_ SIZE , y1 ) ; g . draw Line ( x -  CONNECTION_ ARROW_ SIZE , y2 , x +  CONNECTION_ ARROW_ SIZE , y2 ) ; } else { g . draw Line ( x , y1 , x , y1 + h ) ; g . draw Line ( x , y2 - h , x , y2 ) ; g . draw String ( text , ( int ) ( x - bounds . get Width ( ) / _ NUM ) , y2 - h - padding ) ; g . draw Line ( x , y1 , x -  CONNECTION_ ARROW_ SIZE , y1 +  CONNECTION_ ARROW_ SIZE ) ; g . draw Line ( x , y1 , x +  CONNECTION_ ARROW_ SIZE , y1 +  CONNECTION_ ARROW_ SIZE ) ; g . draw Line ( x , y2 , x -  CONNECTION_ ARROW_ SIZE , y2 -  CONNECTION_ ARROW_ SIZE ) ; g . draw Line ( x , y2 , x +  CONNECTION_ ARROW_ SIZE , y2 -  CONNECTION_ ARROW_ SIZE ) ; } }
protected void remove Markers ( ) { for ( int i = marker Image . size ( ) ; i > _ NUM ; i -- ) {  Loco Icon il = marker Image . get ( i - _ NUM ) ; if ( ( il != null ) && ( il . is Active ( ) ) ) { marker Image . remove ( i - _ NUM ) ; il . remove ( ) ; il . dispose ( ) ; set Dirty ( _ BOOL ) ; } } super . remove Markers ( ) ; repaint ( ) ; }
public  IElement Type capture String ( ) {  Char Sequence buffer = get Buffer ( ) ; int current Position = get Token End ( ) ; set Token Start ( current Position ) ; int buffer End = get Buffer End ( ) ; char open Quote = buffer . char At ( current Position ) ; char close Quote =  Regex Block . get Quote Close Char ( open Quote ) ; boolean quotes Differ = open Quote != close Quote ; boolean is Escaped = _ BOOL ; int quotes Depth = _ NUM ; current Position ++ ; while ( current Position < buffer End ) { char current Char = buffer . char At ( current Position ) ; if ( ! is Escaped && quotes Depth == _ NUM && current Char == close Quote ) { break ; } if ( ! is Escaped && quotes Differ ) { if ( current Char == open Quote ) { quotes Depth ++ ; } else if ( current Char == close Quote ) { quotes Depth -- ; } } is Escaped = ! is Escaped && current Char == _ STR ; current Position ++ ; } if ( current Position < buffer End ) { current Position ++ ; } set Token End ( current Position ) ;  Perl String Lexer string Lexer = get String Lexer ( ) ; pop State ( ) ; preparsed Tokens List . add All ( lex Current Token ( string Lexer ) ) ; return get Pre Parsed Token ( ) ; }
public static  String to Localized Integer ( long value ) { return  NUMBER_ FORMAT0 . format ( value ) ; }
public void test Parse Client Handshake ( ) throws  Exception { for ( int split Pos = _ NUM ; split Pos < _ NUM ; split Pos ++ ) { log . info ( _ STR + split Pos ) ;  Byte Buffer tmp = client Handshake Packet ( ) ;  Byte Buffer [ ] split = split ( tmp , split Pos ) ;  Grid Nio Session ses = new  Mock Nio Session ( ) ; ses . add Meta (  MARSHALLER . ordinal ( ) , new  Grid Client Optimized Marshaller ( ) ) ;  Grid Tcp Rest Parser parser = new  Grid Tcp Rest Parser ( _ BOOL ) ;  Collection <  Grid Client Message > lst = new  Array List < > ( _ NUM ) ; for (  Byte Buffer buf : split ) {  Grid Client Message r ; while ( buf . has Remaining ( ) && ( r = parser . decode ( ses , buf ) ) != null ) lst . add ( r ) ; assert True ( _ STR , buf . remaining ( ) == _ NUM ) ; } assert Equals ( _ NUM , lst . size ( ) ) ;  Grid Client Handshake Request req = (  Grid Client Handshake Request )  F . first ( lst ) ; assert Not Null ( req ) ; assert Equals (  U . bytes To Short ( new byte [ ] { _ NUM , _ NUM } , _ NUM ) , req . version ( ) ) ; } }
public void initialize (  Context context ,  Haptic Feedback Controller haptic Feedback Controller , int initial Hours Of Day , int initial Minutes , boolean is24 Hour Mode ) { if ( m Time Initialized ) {  Log . e (  TAG , _ STR ) ; return ; } m Haptic Feedback Controller = haptic Feedback Controller ; m Is24 Hour Mode = is24 Hour Mode ; m Hide Am Pm = m Accessibility Manager . is Touch Exploration Enabled ( ) ? _ BOOL : m Is24 Hour Mode ; m Circle View . initialize ( context , m Hide Am Pm ) ; m Circle View . invalidate ( ) ; if ( ! m Hide Am Pm ) { m Am Pm Circles View . initialize ( context , initial Hours Of Day < _ NUM ?  AM :  PM ) ; m Am Pm Circles View . invalidate ( ) ; }  Resources res = context . get Resources ( ) ; int [ ] hours = { _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM } ; int [ ] hours_24 = { _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM } ; int [ ] minutes = { _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM } ;  String [ ] hours Texts = new  String [ _ NUM ] ;  String [ ] inner Hours Texts = new  String [ _ NUM ] ;  String [ ] minutes Texts = new  String [ _ NUM ] ; for ( int i = _ NUM ; i < _ NUM ; i ++ ) { hours Texts [ i ] = is24 Hour Mode ?  String . format ( _ STR , hours_24 [ i ] ) :  String . format ( _ STR , hours [ i ] ) ; inner Hours Texts [ i ] =  String . format ( _ STR , hours [ i ] ) ; minutes Texts [ i ] =  String . format ( _ STR , minutes [ i ] ) ; } m Hour Radial Texts View . initialize ( res , hours Texts , ( is24 Hour Mode ? inner Hours Texts : null ) , m Hide Am Pm , _ BOOL ) ; m Hour Radial Texts View . invalidate ( ) ; m Minute Radial Texts View . initialize ( res , minutes Texts , null , m Hide Am Pm , _ BOOL ) ; m Minute Radial Texts View . invalidate ( ) ; set Value For Item (  HOUR_ INDEX , initial Hours Of Day ) ; set Value For Item (  MINUTE_ INDEX , initial Minutes ) ; int hour Degrees = ( initial Hours Of Day % _ NUM ) *  HOUR_ VALUE_ TO_ DEGREES_ STEP_ SIZE ; m Hour Radial Selector View . initialize ( context , m Hide Am Pm , is24 Hour Mode , _ BOOL , hour Degrees , is Hour Inner Circle ( initial Hours Of Day ) ) ; int minute Degrees = initial Minutes *  MINUTE_ VALUE_ TO_ DEGREES_ STEP_ SIZE ; m Minute Radial Selector View . initialize ( context , m Hide Am Pm , _ BOOL , _ BOOL , minute Degrees , _ BOOL ) ; m Time Initialized = _ BOOL ; }
protected void sqrt Layout (  Visual Table labels ) {  Rectangle2 D b = get Layout Bounds ( ) ; double breadth = get Breadth ( b ) ; double span = m_hi - m_lo ; double splo =  Math Lib . safe Sqrt ( m_prevlo ) ; double spspan =  Math Lib . safe Sqrt ( m_prevhi ) - splo ; double vlo =  Math . pow ( _ NUM ,  Math . floor (  Math Lib . safe Log10 ( m_lo ) ) ) ; double slo =  Math Lib . safe Sqrt ( m_lo ) ; double sspan =  Math Lib . safe Sqrt ( m_hi ) - slo ;  Iterator iter = labels . tuples ( ) ; while ( iter . has Next ( ) ) {  Visual Item item = (  Visual Item ) iter . next ( ) ; reset ( item ) ; double v = item . get Double (  VALUE ) ; double x = span == _ NUM ? _ NUM : ( (  Math Lib . safe Sqrt ( v ) - slo ) / sspan ) * breadth ; set ( item , x , b ) ; }  Index index = labels . index (  VALUE ) ; double step = get Linear Step ( span , breadth / span ) ; if ( step == _ NUM ) step = _ NUM ; int r ; for ( double x , v = vlo ; v <= m_hi ; v += step ) { x = ( (  Math Lib . safe Sqrt ( v ) - slo ) / sspan ) * breadth ; if ( x < - _ NUM ) { continue ; } else if ( ( r = index . get ( v ) ) >= _ NUM ) {  Visual Item item = labels . get Item ( r ) ; item . set Visible ( _ BOOL ) ; item . set End Visible ( _ BOOL ) ; } else {  Visual Item item = labels . add Item ( ) ; item . set (  LABEL , m_nf . format ( v ) ) ; item . set Double (  VALUE , v ) ; double f = spspan == _ NUM ? _ NUM : ( (  Math Lib . safe Sqrt ( v ) - splo ) / spspan ) ; if ( f <= _ NUM || f >= _ NUM ) { item . set Start Visible ( _ BOOL ) ; } set ( item , f * breadth , b ) ; set ( item , x , b ) ; } } }
public static  Template create (  String value ) { if (  Settings . is Function ( value ) ) { return new  Functional Template ( value ) ; } if (  Graph . is Relational ( value ) ) { try { return new  Relational Template ( value ) ; } catch (  Exception e ) { log . warning ( _ STR + value + _ STR ) ; return new  String Template ( value ) ; } } else if (  Regex Template . is Possible Regex ( value ) ) { try { if (  Arithmetic Template . is Arithmetic Expression ( value ) ) { return new  Arithmetic Template ( value ) ; } return new  Regex Template ( value ) ; } catch (  Pattern Syntax Exception e ) { log . warning ( _ STR + value + _ STR ) ; return new  String Template ( value ) ; } } else { return new  String Template ( value ) ; } }
protected boolean custom Should Take Focus ( ) { if ( custom Area instanceof  Label ) { return _ BOOL ; } if ( custom Area instanceof  CLabel ) { return ( custom Area . get Style ( ) &  SWT .  NO_ FOCUS ) > _ NUM ; } return _ BOOL ; }
private  Map <  String ,  List <  Zone > > select Zones For Initiators And Ports (  Network Lite network ,  Map <  String ,  List <  Zone > > wwn To Zones ,  Map <  String ,  Storage Port > initiator Ports Map ) {  Map <  String ,  List <  Zone > > filtered Map = new  Hash Map <  String ,  List <  Zone > > ( ) ;  Zone zone = null ;  List <  Zone > zones = null ; for (  String initiator Wwn : wwn To Zones . key Set ( ) ) { for (  String port Wwn : initiator Ports Map . key Set ( ) ) { zone = _network Scheduler . select Existing Zone For Initiator Port ( network , initiator Wwn , port Wwn , wwn To Zones . get ( initiator Wwn ) ) ; if ( zone != null ) { zones = filtered Map . get ( initiator Wwn ) ; if ( zones == null ) { zones = new  Array List < > ( ) ; filtered Map . put ( initiator Wwn , zones ) ; } zones . add ( zone ) ; } } } return filtered Map ; }
public static boolean is Extension (  String filename ,  Collection <  String > extensions ) { if ( filename == null ) return _ BOOL ; if ( extensions == null || extensions . is Empty ( ) ) return index Of Extension ( filename ) == - _ NUM ;  String file Ext = get Extension ( filename ) ; for (  String extension : extensions ) { if ( file Ext . equals ( extension ) ) return _ BOOL ; } return _ BOOL ; }
private void write Jar Post Resource (  Element post Resource El ,  String path ) { post Resource El . set Attribute ( _ STR ,  JAR_ RESOURCE_ SET ) ; post Resource El . set Attribute ( _ STR , path . replace ( _ STR , _ STR ) ) ; }
public void close File ( ) throws  IOException { file . close ( ) ; file = null ; }
public  Typed Event Listener (  Event Listener <  E > wrapped Listener ,  Class <  E > event Class ) { this . event Class = event Class ; this . wrapped Listener = wrapped Listener ; }
public static  Corleone context (  String job Context ) { if ( job Context == null || job Context . equals ( _ STR ) ) { throw new  Illegal Argument Exception ( _ STR ) ; } contexts . clear ( ) ; contexts . add ( job Context ) ; return get Instance ( ) ; }
protected final void init ( ) throws  No Glyph Exception { char [ ] codes = chars . to Char Array ( ) ; indices = new int [ codes . length ] ; advances = new int [ codes . length ] ; double max Ascent = _ NUM ; double max Descent = _ NUM ; double scale = size *  SWFConstants .  TWIPS / _ NUM ; for ( int i = _ NUM ; i < codes . length ; i ++ ) { int code = ( int ) codes [ i ] ; int [ ] index = new int [ _ NUM ] ;  Font Definition .  Glyph glyph = get Glyph ( code , index ) ; indices [ i ] = index [ _ NUM ] ; if ( glyph != null ) {  Shape shape = glyph . get Shape ( ) ; double [ ] outline = shape . get Bounding Rectangle ( ) ; double x1 = outline [ _ NUM ] * scale ; double y1 = outline [ _ NUM ] * scale ; double x2 = outline [ _ NUM ] * scale ; double y2 = outline [ _ NUM ] * scale ; if ( max Ascent < - y1 ) { max Ascent = - y1 ; } if ( max Descent < y2 ) { max Descent = y2 ; } double advance = glyph . get Advance ( ) * scale ; if ( advance == _ NUM ) { advance = x2 - x1 ; } if ( i < codes . length - _ NUM ) { advance += ( font Def . get Kerning Offset ( code , ( int ) codes [ i + _ NUM ] ) * scale ) ; } total Advance += advance ; advances [ i ] = ( int ) ( advance *  SWFConstants .  TWIPS ) ; if ( i == _ NUM ) { left Margin = - y1 ; } if ( i == codes . length - _ NUM ) { right Margin = x2 - advance ; } } } ascent = font Def . get Ascent ( ) * scale ; if ( ascent == _ NUM ) { ascent = max Ascent ; } descent = font Def . get Descent ( ) * scale ; if ( descent == _ NUM ) { descent = max Descent ; } }
public static double info ( int counts [ ] ) { int total = _ NUM ; double x = _ NUM ; for ( int count : counts ) { x -= xlogx ( count ) ; total += count ; } return x + xlogx ( total ) ; }
public void add Method (  Soot Method m ) { check Level (  SIGNATURES ) ; if ( m . is Declared ( ) ) throw new  Runtime Exception ( _ STR + m . get Name ( ) ) ; if ( sub Sig To Methods . get ( m . get Numbered Sub Signature ( ) ) != null ) { throw new  Runtime Exception ( _ STR + m . get Sub Signature ( ) + _ STR + this + _ STR ) ; } sub Sig To Methods . put ( m . get Numbered Sub Signature ( ) , m ) ; method List . add ( m ) ; m . set Declared ( _ BOOL ) ; m . set Declaring Class ( this ) ; }
private void add Replication Factor (  Operation op ) { op . add Request Header (  Operation .  REPLICATION_ QUORUM_ HEADER ,  Operation .  REPLICATION_ QUORUM_ HEADER_ VALUE_ ALL ) ; }
private static  Frame show Initial Splash ( ) {  Frame splash Frame = null ;  Image image = null ;  URL image URL = get Chosen Splash URL ( ) ; if ( image URL != null ) { try { image =  Image IO . read ( image URL ) ; } catch (  IOException e ) { e . print Stack Trace ( ) ; } if ( image != null ) { splash Frame =  AWTSplash Window . splash ( image ) ; } } return splash Frame ; }
protected void decode Line Suffix (  Pushback Input Stream in Stream ,  Output Stream out Stream ) throws  IOException { int c ; while ( _ BOOL ) { c = in Stream . read ( ) ; if ( c == - _ NUM ) { throw new  CEStream Exhausted ( ) ; } if ( c == _ STR ) { break ; } if ( c == _ STR ) { c = in Stream . read ( ) ; if ( ( c != _ STR ) && ( c != - _ NUM ) ) { in Stream . unread ( c ) ; } break ; } } }
public void add Transaction (  SIPServer Transaction server Transaction ) throws  IOException { if ( is Logging Enabled ( ) ) stack Logger . log Debug ( _ STR + server Transaction ) ; server Transaction . map ( ) ; add Transaction Hash ( server Transaction ) ; }
public boolean contains Poly (  Soot Method method ) { return get Method ( method ) != null ; }
public  JKTag Mapping ( final  String source QName , final  String target QName , final  JKNamespace namespace ) { logger . info (  String . format ( _ STR , source QName , target QName ) ) ; this . source QName = source QName ; this . target QName = target QName ; this . namespace = namespace ; this . auto = _ BOOL ; }
private void select Attribute Set Instance ( ) { int m_warehouse_id = get M_ Warehouse_ ID ( ) ; int m_product_id = get M_ Product_ ID ( ) ; if ( m_product_id <= _ NUM ) return ;  MProduct product =  MProduct . get ( get Ctx ( ) , m_product_id ) ;  MWarehouse wh =  MWarehouse . get ( get Ctx ( ) , m_warehouse_id ) ;  String title = product . get_ Translation (  MProduct .  COLUMNNAME_ Name ) + _ STR + wh . get_ Translation (  MWarehouse .  COLUMNNAME_ Name ) ;  PAttribute Instance pai = new  PAttribute Instance ( m_frame , title , m_warehouse_id , _ NUM , m_product_id , _ NUM ) ; if ( pai . get M_ Attribute Set Instance_ ID ( ) != - _ NUM ) { f Attr Set Instance_ ID . set Text ( pai . get M_ Attribute Set Instance Name ( ) ) ; f Attr Set Instance_ ID . set Value ( new  Integer ( pai . get M_ Attribute Set Instance_ ID ( ) ) ) ; } else { f Attr Set Instance_ ID . set Value (  Integer . value Of ( _ NUM ) ) ; } }
private void ensure File Open ( ) { if ( saving Disabled ) {  Log . e (  TAG , _ STR ) ; return ; } if ( save File Stream != null ) return ;  File save File = new  File ( ctx . get Files Dir ( ) ,  SAVEFILE ) ; try {  File Output Stream file Output = null ;  Data Output Stream out = null ; if ( save File . exists ( ) ) { file Output = ctx . open File Output (  SAVEFILE ,  Context .  MODE_ APPEND ) ; out = new  Data Output Stream ( new  Buffered Output Stream ( file Output ) ) ; } else { file Output = ctx . open File Output (  SAVEFILE ,  Context .  MODE_ PRIVATE ) ; out = new  Data Output Stream ( new  Buffered Output Stream ( file Output ) ) ; out . write Int (  Track Point .  FORMAT_ VERSION ) ; saved Track Points = _ NUM ; } save File Stream = out ; } catch (  Exception e ) { mark Saving Broken ( _ STR , e ) ; } }
public void test_canonicalizing Cache ( ) { final  Properties properties = get Properties ( ) ; properties . set Property (  Abstract Transaction Service .  Options .  MIN_ RELEASE_ AGE , _ STR ) ; final  Journal journal = new  Journal ( properties ) ; try { final long commit Time0 = journal . commit ( ) ; assert True ( commit Time0 != _ NUM ) ; final  ICommit Record commit Record0 = journal . get Commit Record ( commit Time0 ) ; assert Equals ( commit Record0 , journal . get Commit Record ( ) ) ; journal . write (  Byte Buffer . wrap ( new byte [ ] { _ NUM , _ NUM , _ NUM } ) ) ; final long commit Time1 = journal . commit ( ) ; assert True ( commit Time1 != _ NUM ) ; final  ICommit Record commit Record1 = journal . get Commit Record ( commit Time1 ) ; assert Equals ( commit Record1 , journal . get Commit Record ( ) ) ; assert True ( commit Record0 == journal . get Commit Record ( commit Time1 - _ NUM ) ) ; assert True ( commit Record1 == journal . get Commit Record ( commit Time1 + _ NUM ) ) ; assert True ( commit Record1 == journal . get Commit Record ( commit Time1 + _ NUM ) ) ; } finally { journal . destroy ( ) ; } }
@  Override public void stop (  Runnable arg0 ) { stop ( ) ; arg0 . run ( ) ; }
protected int read (  Input Stream input Stream , byte [ ] buffer , char divider ) throws  IOException { int index = _ NUM ; do { byte read Byte = ( byte ) ( _ NUM & input Stream . read ( ) ) ; if ( read Byte == - _ NUM || read Byte == ( byte ) divider ) { return index ; } buffer [ index ] = read Byte ; index ++ ; } while ( index < buffer . length ) ; return index ; }
private static void generate Graph File (  Trans Meta trans Meta ,  String graph File ) throws  Graph Generator Exception {  Data Output Stream dos = null ; try {  String xml = trans Meta . get XML ( ) ; dos = new  Data Output Stream ( new  File Output Stream ( new  File ( graph File ) ) ) ; dos . write ( xml . get Bytes (  Carbon Common Constants .  DEFAULT_ CHARSET ) ) ; } catch (  Kettle Exception kettel Exception ) { throw new  Graph Generator Exception ( _ STR , kettel Exception ) ; } catch (  File Not Found Exception e ) { throw new  Graph Generator Exception ( _ STR , e ) ; } catch (  Unsupported Encoding Exception ue ) { throw new  Graph Generator Exception ( _ STR , ue ) ; } catch (  IOException ioe ) { throw new  Graph Generator Exception ( _ STR , ioe ) ; } finally { if ( dos != null ) { try { dos . close ( ) ; } catch (  IOException e ) { e . get Message ( ) ; } } } }
private void test Multi Statement ( ) {  MVStore s =  MVStore . open ( null ) ;  Transaction Store ts = new  Transaction Store ( s ) ; ts . init ( ) ;  Transaction tx ;  Transaction Map <  String ,  String > m ; long start Update ; tx = ts . begin ( ) ; start Update = tx . set Savepoint ( ) ; m = tx . open Map ( _ STR ) ; m . set Savepoint ( start Update ) ; start Update = tx . set Savepoint ( ) ; m . set Savepoint ( start Update ) ; assert True ( m . try Set ( _ STR , _ STR , _ BOOL ) ) ; assert True ( m . try Set ( _ STR , _ STR , _ BOOL ) ) ; assert Null ( m . get ( _ STR ) ) ; assert Null ( m . get ( _ STR ) ) ; start Update = tx . set Savepoint ( ) ; m . set Savepoint ( start Update ) ; assert Equals ( _ STR , m . get ( _ STR ) ) ; assert Equals ( _ STR , m . get ( _ STR ) ) ; assert Equals ( _ STR , m . get ( _ STR ) ) ; assert True ( m . try Set ( _ STR , null , _ BOOL ) ) ; assert True ( m . try Set ( _ STR , _ STR , _ BOOL ) ) ; assert Equals ( _ STR , m . get ( _ STR ) ) ; assert True ( m . try Set ( _ STR , null , _ BOOL ) ) ; assert True ( m . try Set ( _ STR , _ STR , _ BOOL ) ) ; assert Equals ( _ STR , m . get ( _ STR ) ) ; assert Equals ( _ STR , m . get ( _ STR ) ) ; assert Null ( m . get ( _ STR ) ) ; start Update = tx . set Savepoint ( ) ; m . set Savepoint ( start Update ) ; assert Null ( m . get ( _ STR ) ) ; assert Equals ( _ STR , m . get ( _ STR ) ) ; assert Equals ( _ STR , m . get ( _ STR ) ) ; start Update = tx . set Savepoint ( ) ; m . set Savepoint ( start Update ) ; assert True ( m . try Set ( _ STR , null , _ BOOL ) ) ; assert True ( m . try Set ( _ STR , _ STR , _ BOOL ) ) ; assert True ( m . try Set ( _ STR , null , _ BOOL ) ) ; assert False ( m . try Set ( _ STR , _ STR , _ BOOL ) ) ; tx . rollback To Savepoint ( start Update ) ; start Update = tx . set Savepoint ( ) ; m . set Savepoint ( start Update ) ; assert Null ( m . get ( _ STR ) ) ; assert Equals ( _ STR , m . get ( _ STR ) ) ; assert Equals ( _ STR , m . get ( _ STR ) ) ; tx . commit ( ) ; ts . close ( ) ; s . close ( ) ; }
public void create Entity Config (  String realm ,  Federation Config Element config ) throws  WSFederation Meta Exception {  String federation Id = config . get Federation ID ( ) ; if ( federation Id == null ) { debug . error ( _ STR + _ STR ) ;  String [ ] data = { realm } ;  Log Util . error (  Level .  INFO ,  Log Util .  NO_ ENTITY_ ID_ CREATE_ ENTITY_ CONFIG , data , null ) ; throw new  WSFederation Meta Exception ( _ STR , null ) ; } if ( realm == null ) { realm = _ STR ; }  String [ ] objs = { federation Id , realm } ; try {  Map attrs =  WSFederation Meta Utils . convert JAXBTo Attr Map (  ATTR_ ENTITY_ CONFIG , config ) ;  Map old Attrs = config Inst . get Configuration ( realm , federation Id ) ; if ( old Attrs == null ) {  Log Util . error (  Level .  INFO ,  Log Util .  NO_ ENTITY_ DESCRIPTOR_ CREATE_ ENTITY_ CONFIG , objs , null ) ; throw new  WSFederation Meta Exception ( _ STR , objs ) ; }  Set old Values = (  Set ) old Attrs . get (  ATTR_ ENTITY_ CONFIG ) ; if ( old Values != null && ! old Values . is Empty ( ) ) {  Log Util . error (  Level .  INFO ,  Log Util .  ENTITY_ CONFIG_ EXISTS , objs , null ) ; throw new  WSFederation Meta Exception ( _ STR , objs ) ; } config Inst . set Configuration ( realm , federation Id , attrs ) ;  Log Util . access (  Level .  INFO ,  Log Util .  ENTITY_ CONFIG_ CREATED , objs , null ) ;  SPSSOConfig Element spconfig = get SPSSOConfig ( realm , federation Id ) ; if ( spconfig != null ) { add To Circle Of Trust ( spconfig , realm , federation Id ) ; }  IDPSSOConfig Element idpconfig = get IDPSSOConfig ( realm , federation Id ) ; if ( idpconfig != null ) { add To Circle Of Trust ( idpconfig , realm , federation Id ) ; } } catch (  Configuration Exception e ) { debug . error ( _ STR , e ) ;  String [ ] data = { e . get Message ( ) , federation Id , realm } ;  Log Util . error (  Level .  INFO ,  Log Util .  CONFIG_ ERROR_ CREATE_ ENTITY_ CONFIG , data , null ) ; throw new  WSFederation Meta Exception ( e ) ; } catch (  JAXBException jaxbe ) { debug . error ( _ STR , jaxbe ) ;  Log Util . error (  Level .  INFO ,  Log Util .  CREATE_ INVALID_ ENTITY_ CONFIG , objs , null ) ; throw new  WSFederation Meta Exception ( _ STR , objs ) ; } }
private void load User Info Into Action Bar ( ) { if ( !  Text Utils . is Empty ( m With User Image ) ) {  Utils . load Circular Image ( get Activity ( ) , m With Image View , m With User Image ,  Avatar Bitmap Transformation .  Avatar Size .  NORMAL ) ; } }
public static  Direction direction For Arrow Key (  Key Event e ) { int index =  Math . max ( _ NUM ,  Math . min ( e . get Key Code ( ) ,  Key Event .  VK_ DOWN ) -  Key Event .  VK_ LEFT ) ; return  Direction . values ( ) [ index ] ; }
public  Trace Graph (  Collection <  Span > spans ) { this . spans By Parent = new  Spans By Parent ( spans ) ; this . spans By Tracer Id = new  Spans By Tracer Id ( spans ) ; }
public static java . util .  Date to Date (  String month Str ,  String day Str ,  String year Str ,  String hour Str ,  String minute Str ,  String second Str ) { int month , day , year , hour , minute , second ; try { month =  Integer . parse Int ( month Str ) ; day =  Integer . parse Int ( day Str ) ; year =  Integer . parse Int ( year Str ) ; hour =  Integer . parse Int ( hour Str ) ; minute =  Integer . parse Int ( minute Str ) ; second =  Integer . parse Int ( second Str ) ; } catch (  Exception e ) { return null ; } return to Date ( month , day , year , hour , minute , second ) ; }
protected void handle Mesos Failure (  String task Id ) { int attempt =  Task Utils . get Attempt For Task Id ( task Id ) ;  Base Container container = containers Info . get (  Task Utils . get Container Index For Task Id ( task Id ) ) ; boolean has Attempts Left = attempt < container . retries ; if ( has Attempts Left ) {  LOG . warning (  String . format ( _ STR , container . name , attempt + _ NUM ) ) ;  String new Task Id =  Task Utils . get Task Id ( container . name , attempt + _ NUM ) ; schedule New Task ( new Task Id ) ; } else {  LOG . severe ( _ STR + attempt ) ; } }
private void update Ltp (  Single Channel Element sce ) {  Individual Channel Stream ics = sce . ics ; float saved [ ] = sce . saved ; float saved Ltp [ ] = sce . coeffs ; final float lwindow [ ] = ics . use Kb Window [ _ NUM ] ? ff_aac_kbd_long_1024 : ff_sine_1024 ; final float swindow [ ] = ics . use Kb Window [ _ NUM ] ? ff_aac_kbd_short_128 : ff_sine_128 ; if ( ics . window Sequence [ _ NUM ] ==  EIGHT_ SHORT_ SEQUENCE ) {  System . arraycopy ( saved , _ NUM , saved Ltp , _ NUM , _ NUM ) ;  Arrays . fill ( saved Ltp , _ NUM , _ NUM + _ NUM , _ NUM ) ;  Float DSP . vector Fmul Reverse ( saved Ltp , _ NUM , ac . buf Mdct , _ NUM , swindow , _ NUM , _ NUM ) ; for ( int i = _ NUM ; i < _ NUM ; i ++ ) { saved Ltp [ i + _ NUM ] = ac . buf Mdct [ _ NUM - i ] * swindow [ _ NUM - i ] ; } } else if ( ics . window Sequence [ _ NUM ] ==  LONG_ START_ SEQUENCE ) {  System . arraycopy ( ac . buf Mdct , _ NUM , saved Ltp , _ NUM , _ NUM ) ;  Arrays . fill ( saved Ltp , _ NUM , _ NUM + _ NUM , _ NUM ) ;  Float DSP . vector Fmul Reverse ( saved Ltp , _ NUM , ac . buf Mdct , _ NUM , swindow , _ NUM , _ NUM ) ; for ( int i = _ NUM ; i < _ NUM ; i ++ ) { saved Ltp [ i + _ NUM ] = ac . buf Mdct [ _ NUM - i ] * swindow [ _ NUM - i ] ; } } else {  Float DSP . vector Fmul Reverse ( saved Ltp , _ NUM , ac . buf Mdct , _ NUM , lwindow , _ NUM , _ NUM ) ; for ( int i = _ NUM ; i < _ NUM ; i ++ ) { saved Ltp [ i + _ NUM ] = ac . buf Mdct [ _ NUM - i ] * lwindow [ _ NUM - i ] ; } }  System . arraycopy ( sce . ltp State , _ NUM , sce . ltp State , _ NUM , _ NUM ) ;  System . arraycopy ( sce . ret , _ NUM , sce . ltp State , _ NUM , _ NUM ) ;  System . arraycopy ( saved Ltp , _ NUM , sce . ltp State , _ NUM , _ NUM ) ; }
public static  File find Config In Working Directory ( ) { for ( final  String suffix :  SUFFIXES ) { final  File config File = new  File (  System . get Property ( _ STR ) ,  PREFIX + suffix ) ; if ( config File . is File ( ) ) { return config File ; } } return null ; }
@  Override public void draw Range Marker (  Graphics2 D g2 ,  XYPlot plot ,  Value Axis range Axis ,  Marker marker ,  Rectangle2 D data Area ) { if ( marker instanceof  Value Marker ) {  Value Marker vm = (  Value Marker ) marker ; double value = vm . get Value ( ) ;  Range range = range Axis . get Range ( ) ; if ( ! range . contains ( value ) ) { return ; } double v = range Axis . value To Java2 D ( value , data Area , plot . get Range Axis Edge ( ) ) ;  Plot Orientation orientation = plot . get Orientation ( ) ;  Line2 D line = null ; if ( orientation ==  Plot Orientation .  HORIZONTAL ) { line = new  Line2 D .  Double ( v , data Area . get Min Y ( ) , v , data Area . get Max Y ( ) ) ; } else if ( orientation ==  Plot Orientation .  VERTICAL ) { line = new  Line2 D .  Double ( data Area . get Min X ( ) , v , data Area . get Max X ( ) , v ) ; } else { throw new  Illegal State Exception ( _ STR ) ; } final  Composite original Composite = g2 . get Composite ( ) ; g2 . set Composite (  Alpha Composite . get Instance (  Alpha Composite .  SRC_ OVER , marker . get Alpha ( ) ) ) ; g2 . set Paint ( marker . get Paint ( ) ) ; g2 . set Stroke ( marker . get Stroke ( ) ) ; g2 . draw ( line ) ;  String label = marker . get Label ( ) ;  Rectangle Anchor anchor = marker . get Label Anchor ( ) ; if ( label != null ) {  Font label Font = marker . get Label Font ( ) ; g2 . set Font ( label Font ) ;  Point2 D coords = calculate Range Marker Text Anchor Point ( g2 , orientation , data Area , line . get Bounds2 D ( ) , marker . get Label Offset ( ) ,  Length Adjustment Type .  EXPAND , anchor ) ;  Rectangle2 D r =  Text Utils . calc Aligned String Bounds ( label , g2 , ( float ) coords . get X ( ) , ( float ) coords . get Y ( ) , marker . get Label Text Anchor ( ) ) ; g2 . set Paint ( marker . get Label Background Color ( ) ) ; g2 . fill ( r ) ; g2 . set Paint ( marker . get Label Paint ( ) ) ;  Text Utilities . draw Aligned String ( label , g2 , ( float ) coords . get X ( ) , ( float ) coords . get Y ( ) , marker . get Label Text Anchor ( ) ) ; } g2 . set Composite ( original Composite ) ; } else if ( marker instanceof  Interval Marker ) {  Interval Marker im = (  Interval Marker ) marker ; double start = im . get Start Value ( ) ; double end = im . get End Value ( ) ;  Range range = range Axis . get Range ( ) ; if ( ! ( range . intersects ( start , end ) ) ) { return ; } double start2d = range Axis . value To Java2 D ( start , data Area , plot . get Range Axis Edge ( ) ) ; double end2d = range Axis . value To Java2 D ( end , data Area , plot . get Range Axis Edge ( ) ) ; double low =  Math . min ( start2d , end2d ) ; double high =  Math . max ( start2d , end2d ) ;  Plot Orientation orientation = plot . get Orientation ( ) ;  Rectangle2 D rect = null ; if ( orientation ==  Plot Orientation .  HORIZONTAL ) { low =  Math . max ( low , data Area . get Min X ( ) ) ; high =  Math . min ( high , data Area . get Max X ( ) ) ; rect = new  Rectangle2 D .  Double ( low , data Area . get Min Y ( ) , high - low , data Area . get Height ( ) ) ; } else if ( orientation ==  Plot Orientation .  VERTICAL ) { low =  Math . max ( low , data Area . get Min Y ( ) ) ; high =  Math . min ( high , data Area . get Max Y ( ) ) ; rect = new  Rectangle2 D .  Double ( data Area . get Min X ( ) , low , data Area . get Width ( ) , high - low ) ; } final  Composite original Composite = g2 . get Composite ( ) ; g2 . set Composite (  Alpha Composite . get Instance (  Alpha Composite .  SRC_ OVER , marker . get Alpha ( ) ) ) ;  Paint p = marker . get Paint ( ) ; if ( p instanceof  Gradient Paint ) {  Gradient Paint gp = (  Gradient Paint ) p ;  Gradient Paint Transformer t = im . get Gradient Paint Transformer ( ) ; if ( t != null ) { gp = t . transform ( gp , rect ) ; } g2 . set Paint ( gp ) ; } else { g2 . set Paint ( p ) ; } g2 . fill ( rect ) ; if ( im . get Outline Paint ( ) != null && im . get Outline Stroke ( ) != null ) { if ( orientation ==  Plot Orientation .  VERTICAL ) {  Line2 D line = new  Line2 D .  Double ( ) ; double x0 = data Area . get Min X ( ) ; double x1 = data Area . get Max X ( ) ; g2 . set Paint ( im . get Outline Paint ( ) ) ; g2 . set Stroke ( im . get Outline Stroke ( ) ) ; if ( range . contains ( start ) ) { line . set Line ( x0 , start2d , x1 , start2d ) ; g2 . draw ( line ) ; } if ( range . contains ( end ) ) { line . set Line ( x0 , end2d , x1 , end2d ) ; g2 . draw ( line ) ; } } else {  Line2 D line = new  Line2 D .  Double ( ) ; double y0 = data Area . get Min Y ( ) ; double y1 = data Area . get Max Y ( ) ; g2 . set Paint ( im . get Outline Paint ( ) ) ; g2 . set Stroke ( im . get Outline Stroke ( ) ) ; if ( range . contains ( start ) ) { line . set Line ( start2d , y0 , start2d , y1 ) ; g2 . draw ( line ) ; } if ( range . contains ( end ) ) { line . set Line ( end2d , y0 , end2d , y1 ) ; g2 . draw ( line ) ; } } }  String label = marker . get Label ( ) ;  Rectangle Anchor anchor = marker . get Label Anchor ( ) ; if ( label != null ) {  Font label Font = marker . get Label Font ( ) ; g2 . set Font ( label Font ) ;  Point2 D coords = calculate Range Marker Text Anchor Point ( g2 , orientation , data Area , rect , marker . get Label Offset ( ) , marker . get Label Offset Type ( ) , anchor ) ;  Rectangle2 D r =  Text Utils . calc Aligned String Bounds ( label , g2 , ( float ) coords . get X ( ) , ( float ) coords . get Y ( ) , marker . get Label Text Anchor ( ) ) ; g2 . set Paint ( marker . get Label Background Color ( ) ) ; g2 . fill ( r ) ; g2 . set Paint ( marker . get Label Paint ( ) ) ;  Text Utilities . draw Aligned String ( label , g2 , ( float ) coords . get X ( ) , ( float ) coords . get Y ( ) , marker . get Label Text Anchor ( ) ) ; } g2 . set Composite ( original Composite ) ; } }
protected boolean attempt To Add Word (  Word word ) { double additional Length = word . get Word Width ( ) ; additional Length += ! words . is Empty ( ) ? space Size : _ NUM ; if ( current Line Length + additional Length <= max Length || max Length == - _ NUM ) { words . add ( word ) ; current Line Length += additional Length ; return _ BOOL ; } else { return _ BOOL ; } }
@  Override public boolean on Preference Click (  Preference preference ) { if ( preference == m Play Example ) { get Sample Text ( ) ; return _ BOOL ; } return _ BOOL ; }
public void read Www Authenticate Header (  String header ) { if ( header != null ) { m Is Digest Authentication = header . starts With (  Http Digest Md5 Authentication .  HTTP_ DIGEST_ SCHEMA ) ; if ( ! m Is Digest Authentication ) { return ; }  String value = get Value ( header , _ STR ) ; m Digest . set Realm ( value ) ; value = get Value ( header , _ STR ) ; m Digest . set Opaque ( value ) ; value = get Value ( header , _ STR ) ; m Digest . set Qop ( value ) ; value = get Value ( header , _ STR ) ; m Digest . set Nextnonce ( value ) ; } }
public static  String value Of (  Boolean value ) { return value != null ?  String . value Of ( value ) : null ; }
public void test Send Receive ( ) throws  Exception { messages . clear ( ) ; for ( int i = _ NUM ; i < data . length ; i ++ ) {  Message message = session . create Text Message ( data [ i ] ) ; message . set String Property ( _ STR , data [ i ] ) ; message . set Int Property ( _ STR , i ) ; if ( verbose ) { if (  LOG . is Debug Enabled ( ) ) {  LOG . debug ( _ STR + message + _ STR + data [ i ] ) ; } } send To Producer ( producer , producer Destination , message ) ; message Sent ( ) ; } assert Messages Are Received ( ) ;  LOG . info ( _ STR + data . length + _ STR ) ; }
public  Allocation Site ( int line , int column ) { synchronized ( sites ) { this . id = sites . size ( ) ; sites . add ( this ) ; } this . line = line ; this . column = column ; }
public boolean draw Image (  Image img ,  Affine Transform xform ,  Image Observer obs ) { return m Graphics . draw Image ( img , xform , obs ) ; }
public final static int parse Int ( char [ ] digit Chars , int offset , int len ) { int num = digit Chars [ offset ] - _ STR ; len += offset ; if ( ++ offset < len ) { num = ( num * _ NUM ) + ( digit Chars [ offset ] - _ STR ) ; if ( ++ offset < len ) { num = ( num * _ NUM ) + ( digit Chars [ offset ] - _ STR ) ; if ( ++ offset < len ) { num = ( num * _ NUM ) + ( digit Chars [ offset ] - _ STR ) ; if ( ++ offset < len ) { num = ( num * _ NUM ) + ( digit Chars [ offset ] - _ STR ) ; if ( ++ offset < len ) { num = ( num * _ NUM ) + ( digit Chars [ offset ] - _ STR ) ; if ( ++ offset < len ) { num = ( num * _ NUM ) + ( digit Chars [ offset ] - _ STR ) ; if ( ++ offset < len ) { num = ( num * _ NUM ) + ( digit Chars [ offset ] - _ STR ) ; if ( ++ offset < len ) { num = ( num * _ NUM ) + ( digit Chars [ offset ] - _ STR ) ; } } } } } } } } return num ; }
public  Activity Monitor Sample ( ) { init Components ( ) ; owner ARadio . set Action Command ( _ STR ) ; owner BRadio . set Action Command ( _ STR ) ; owner CRadio . set Action Command ( _ STR ) ; indicator A . set Activity Owner ( _ STR ) ; indicator B . set Activity Owner ( _ STR ) ; indicator C . set Activity Owner ( _ STR ) ;  JActivity Window . get Instance ( ) ; }
public static  Lat Lon [ ] great Circle Extreme Locations (  Lat Lon location ,  Angle azimuth ) { if ( location == null ) { throw new  Illegal Argument Exception ( _ STR ) ; } if ( azimuth == null ) { throw new  Illegal Argument Exception ( _ STR ) ; } double lat0 = location . get Latitude ( ) . radians ; double az = azimuth . radians ; double tan Distance = -  Math . tan ( lat0 ) /  Math . cos ( az ) ; double distance =  Math . atan ( tan Distance ) ;  Angle extreme Distance1 =  Angle . from Radians ( distance + (  Math .  PI / _ NUM ) ) ;  Angle extreme Distance2 =  Angle . from Radians ( distance - (  Math .  PI / _ NUM ) ) ; return new  Lat Lon [ ] { great Circle End Position ( location , azimuth , extreme Distance1 ) , great Circle End Position ( location , azimuth , extreme Distance2 ) } ; }
private void init Checkbox (  Check Box Preference checkbox , boolean checked , boolean enabled ) { checkbox . set Checked ( checked ) ; checkbox . set Enabled ( enabled ) ; }
private void paint Check Icon Enabled And Selected (  Graphics2 D g , int width , int height ) {  Shape s = shape Generator . create Check Mark ( _ NUM , _ NUM , width , height ) ; g . set Paint ( icon Enabled Selected ) ; g . fill ( s ) ; }
public static int find URISplit Index (  String uri ) { int uri Length = uri . length ( ) ; int idx = uri Length - _ NUM ; for ( ; idx >= _ NUM ; idx -- ) { if ( !  Turtle Util . is Name Char ( uri . char At ( idx ) ) ) { break ; } } idx ++ ; for ( ; idx < uri Length ; idx ++ ) { if (  Turtle Util . is Name Start Char ( uri . char At ( idx ) ) ) { break ; } } if ( !  Turtle Util . is Name End Char ( uri . char At ( uri Length - _ NUM ) ) ) { return - _ NUM ; } if ( idx > _ NUM && idx < uri Length ) { return idx ; } return - _ NUM ; }
private void write Log (  String cmd ) { try { if ( m_writer == null ) {  File file =  File . create Temp File ( _ STR , _ STR ) ; m_writer = new  Print Writer ( new  File Writer ( file ) ) ; log . info ( file . to String ( ) ) ; } m_writer . println ( cmd ) ; m_writer . flush ( ) ; } catch (  Exception e ) { log . severe ( e . to String ( ) ) ; } }
public void reload (  String why ) { m Full Photo Paths = m Root Dir . list (  Media Scanner .  JPG_ FILENAME_ FILTER ) ; if ( ( m Full Photo Paths != null ) && ( m Full Photo Paths . length == _ NUM ) ) { m Full Photo Paths = null ;  Log . i (  Global .  LOG_ CONTEXT , m Debug Prefix + why + _ STR + m Root Dir + _ STR + _ NUM ) ; } else if ( m Full Photo Paths != null ) { if (  Global . debug Enabled ) {  Log . i (  Global .  LOG_ CONTEXT , m Debug Prefix + why + _ STR + m Root Dir + _ STR + m Full Photo Paths . length ) ; }  String parent Dir String = m Root Dir . get Absolute Path ( ) ; for ( int i = _ NUM ; i < m Full Photo Paths . length ; i ++ ) { m Full Photo Paths [ i ] = parent Dir String + _ STR + m Full Photo Paths [ i ] ; } } }
protected void add Content Spec To Element (  XMLElement Decl element Decl ) { if ( ( f Depth == _ NUM || ( f Depth == _ NUM && element Decl . type ==  XMLElement Decl .  TYPE_ MIXED ) ) && f Node Index Stack != null ) { if ( element Decl . type ==  XMLElement Decl .  TYPE_ MIXED ) { int pcdata = add Unique Leaf Node ( null ) ; if ( f Node Index Stack [ _ NUM ] == - _ NUM ) { f Node Index Stack [ _ NUM ] = pcdata ; } else { f Node Index Stack [ _ NUM ] = add Content Spec Node (  XMLContent Spec .  CONTENTSPECNODE_ CHOICE , pcdata , f Node Index Stack [ _ NUM ] ) ; } } set Content Spec Index ( f Current Element Index , f Node Index Stack [ f Depth ] ) ; } }
private void grow Spine ( ) { spine = new int [ ( spine . length << _ NUM ) + _ NUM ] ; threshold = ( int ) ( spine . length * load Factor ) ;  Arrays . fill ( spine , - _ NUM ) ; for ( int i = _ NUM ; i < size ; i ++ ) { insert ( objs [ i ] , i ) ; } }
public void reconnect ( ) { if ( opened && ! allow Connection Recovery ) { return ; } reconnectwait thread = new reconnectwait ( ) ; thread . start ( ) ; try { thread . join ( ) ; } catch (  Interrupted Exception e ) { log . error ( _ STR + e . get Message ( ) ) ; } if ( ! opened ) { log . error ( _ STR ) ; } else { log . info ( _ STR + get Current Port Name ( ) ) ; resetup Connection ( ) ; } }
public  Collection <  Grid Port Record > records ( ) { synchronized ( recs ) { return  Collections . unmodifiable Collection ( new  Array List < > ( recs ) ) ; } }
public boolean has Change Event (  String name ) { if ( var != null ) {  List <  Meta Data > md List = var . get Meta Data (  Standard Defs .  MD_ CHANGEEVENT ) ; if ( md List != null ) { for ( int i = _ NUM , size = md List . size ( ) ; i < size ; i ++ ) {  Meta Data md = md List . get ( i ) ; if ( name . equals ( md . get Value ( _ NUM ) ) ) { return _ BOOL ; } } } } return _ BOOL ; }
public float distance To Other Circle (  Circle circle ) { return ( float )  Math . abs (  Math . sqrt (  Math . pow ( circle . center . x - center . x , _ NUM ) +  Math . pow ( circle . center . y - center . y , _ NUM ) ) ) ; }
public  Simple Command (  String command Name ,  String ... args ) { this ( command Name , (  Argument ) null ) ;  Array List <  Argument > arg List = new  Array List <  Argument > ( ) ; for (  String arg : args ) arg List . add ( new  Argument ( arg ) ) ; _arguments = arg List . to Array ( new  Argument [ _ NUM ] ) ; }
public  Picking Graph Mouse Plugin ( int selection Modifiers , int add To Selection Modifiers ) { super ( selection Modifiers ) ; this . add To Selection Modifiers = add To Selection Modifiers ; this . lens Paintable = new  Lens Paintable ( ) ; this . cursor =  Cursor . get Predefined Cursor (  Cursor .  HAND_ CURSOR ) ; }
public int [ ] breadth First Search ( int intial Value ,  IBFSTraversable <  N > traversable , int first Value ,  IInteger Bfs Next Value Iterator <  N > next Value Iterator ,  List <  Integer > sources Index ) { int [ ] results = new int [ nodes . length ] ;  Arrays . fill ( results , intial Value ) ; boolean [ ] already Scanned = new boolean [ nodes . length ] ;  Arrays . fill ( already Scanned , _ BOOL ) ;  Set <  Integer > current Nodes Index = new  Hash Set < > ( sources Index ) ; iterative Integer Breadth First Search ( results , already Scanned , current Nodes Index , first Value , _ NUM , traversable , next Value Iterator ) ; return results ; }
public  View Ref Render (  View Render <  T > view ,  Class <  T > type , int priority ) {  Objects . require Non Null ( view ) ; _view = view ; _type = type ; _priority = priority ; }
private boolean announce (  String [ ] groups ) { if ( data Packets == null || ! last Locator . equals ( my Locator ) || !  Arrays . equals ( last Groups , groups ) ) {  List <  Datagram Packet > packets = new  Array List <  Datagram Packet > ( ) ;  Discovery disco ; try { disco = get Discovery ( multicast Announcement Constraints . choose Protocol Version ( ) ) ; } catch (  Discovery Protocol Exception e ) { throw new  Assertion Error ( e ) ; }  Encode Iterator ei = disco . encode Multicast Announcement ( new  Multicast Announcement ( announcement Seq No ++ , my Locator . get Host ( ) , my Locator . get Port ( ) , groups , my Service ID ) , multicast Announcement Constraints . get Multicast Max Packet Size (  DEFAULT_ MAX_ PACKET_ SIZE ) , multicast Announcement Constraints . get Unfulfilled Constraints ( ) ) ; while ( ei . has Next ( ) ) { try { packets . add All (  Arrays . as List ( ei . next ( ) ) ) ; } catch (  Exception e ) { logger . log ( ( e instanceof  Unsupported Constraint Exception ) ?  Levels .  HANDLED :  Level .  INFO , _ STR + _ STR , e ) ; } } last Locator = my Locator ; last Groups = groups ; data Packets = packets . to Array ( new  Datagram Packet [ packets . size ( ) ] ) ; } try { send ( data Packets ) ; } catch (  Interrupted IOException e ) { return _ BOOL ; } return _ BOOL ; }
public  Drawing Attributes ( ) { property Change Support = new  Property Change Support ( this ) ; }
static void create Policy Tree (  String config Name ,  String config Id ,  Service Config Manager scm ,  String org ) throws  No Permission Exception ,  Policy Exception ,  SSOException { try {  Service Config p Config = scm . get Organization Config ( org , null ) ; if ( p Config == null ) { scm . create Organization Config ( org , null ) ; p Config = scm . get Organization Config ( org , null ) ; } p Config . add Sub Config ( config Name , config Id , _ NUM , null ) ; } catch (  Service Already Exists Exception se ) { if ( debug . message Enabled ( ) ) { debug . message ( _ STR + config Name + _ STR + config Id + _ STR + org ) ; } } catch (  SMSException e ) {  String [ ] objs = { org } ; if ( e . get Exception Code ( ) ==  SMSException .  STATUS_ NO_ PERMISSION ) { throw ( new  No Permission Exception (  Res Bundle Utils . rb Name , _ STR , null ) ) ; } else { throw ( new  Policy Exception (  Res Bundle Utils . rb Name , _ STR , objs , e ) ) ; } } }
private void rollback Method For Create Snapshot ( boolean is Snapshot Created , boolean is Dummy Lun Path Added ,  HDSApi Client hds Api Client ,  Storage System storage ,  URI snapshot ) throws  Exception { if ( is Dummy Lun Path Added ) { log . info ( _ STR ) ; hds Protection Operations . remove Dummy Lun Path ( storage , snapshot ) ; } if ( is Snapshot Created ) { log . info ( _ STR ) ;  Block Snapshot snapshot Obj = db Client . query Object (  Block Snapshot . class , snapshot ) ;  String system Object ID =  HDSUtils . get System Object ID ( storage ) ;  String logical Unit Obj Id =  HDSUtils . get Logical Unit Object Id ( snapshot Obj . get Native Id ( ) , storage ) ; hds Api Client . delete Snapshot Volume ( system Object ID , logical Unit Obj Id , storage . get Model ( ) ) ; } }
public static int convert String To Time Seconds (  String time ) { int result = _ NUM ; if ( time . ends With ( _ STR ) ) { int hours To Add =  Integer . value Of (  String Utils . remove ( time , _ STR ) ) ; result = ( _ NUM * _ NUM ) * hours To Add ; } else if ( time . ends With ( _ STR ) ) { int mins To Add =  Integer . value Of (  String Utils . remove ( time , _ STR ) ) ; result = _ NUM * mins To Add ; } else if ( time . ends With ( _ STR ) ) { int secs To Add =  Integer . value Of (  String Utils . remove ( time , _ STR ) ) ; result = secs To Add ; } return result ; }
public void detach (  App Compat Activity activity ) { attr View Maps . remove ( activity . hash Code ( ) ) ; }
public void read Prefs (  Shared Preferences settings ,  Action Factory factory ) { boolean visible = _ BOOL ;  String action Id = settings . get String ( _ STR + name + _ STR , _ STR ) ; main Action = factory . get Action ( action Id ) ; if ( main Action != null ) visible = _ BOOL ; menu Actions . clear ( ) ; for ( int i = _ NUM ; i < max Menu Actions ; i ++ ) { action Id = settings . get String ( _ STR + name + _ STR + ( i + _ NUM ) , _ STR ) ;  UIAction a = factory . get Action ( action Id ) ; if ( a != null ) visible = _ BOOL ; menu Actions . add ( a ) ; } if ( button != null ) button . set Visibility ( visible ?  View .  VISIBLE :  View .  GONE ) ; }
public boolean add To Active List (  Download Info Runnable download Info Runnable ) { return active List Has Room ( ) && m Active List . add ( download Info Runnable ) ; }
private void add Expr To TLA (  TLAExpr expr ) {  Vector sv = expr . to String Vector ( ) ;  Vector expr Mapping = expr . to Mapping Vector ( ) ; int indent = tlacode Next Line . length ( ) ; int next Line = _ NUM ; if ( indent != _ NUM ) {  Mapping Object . shift Mapping Vector ( expr Mapping , indent ) ; tlacode Next Line = tlacode Next Line + ( (  String ) sv . element At ( _ NUM ) ) ; mapping Vector Next Line . add All ( (  Vector ) expr Mapping . element At ( _ NUM ) ) ; next Line = _ NUM ; if ( sv . size ( ) > _ NUM ) { end Current Line Of TLA ( ) ; } } if ( sv . size ( ) > _ NUM ) {  String spaces =  NSpaces ( indent ) ; while ( next Line < sv . size ( ) - _ NUM ) { tlacode . add Element ( spaces + ( (  String ) sv . element At ( next Line ) ) ) ; mapping Vector . add Element ( (  Vector ) expr Mapping . element At ( next Line ) ) ; next Line ++ ; } tlacode Next Line = spaces + ( (  String ) sv . element At ( next Line ) ) ; mapping Vector Next Line = (  Vector ) expr Mapping . element At ( next Line ) ; } else if ( indent == _ NUM ) { tlacode Next Line = tlacode Next Line + ( (  String ) sv . element At ( _ NUM ) ) ; mapping Vector Next Line . add All ( (  Vector ) expr Mapping . element At ( _ NUM ) ) ; } }
private boolean is Upper Case Camel Case Hunk (  String hunk ) { if ( hunk . length ( ) < _ NUM ) return _ BOOL ; for ( int i = _ NUM ; i < hunk . length ( ) ; i ++ ) { if ( ! is Legal Char ( hunk . char At ( i ) ) ) return _ BOOL ; } return _ BOOL ; }
public void type (  String string ) { for ( int i = _ NUM ; i < string . length ( ) ; i ++ ) { char c = string . char At ( i ) ; type ( c ) ; } }
public boolean provides Identifier ( ) { return _ BOOL ; }
static void remove Redundant Affix (  Translator Utils .  IContain i Contain ,  List <  String > str List ) { if ( str List . size ( ) <= _ NUM ) { return ; } int w = _ NUM ; for (  String str : str List ) { if ( w == _ NUM || ! i Contain . contain Func ( str , str List . get ( w - _ NUM ) ) ) { str List . set ( w , str ) ; w ++ ; } } str List = str List . sub List ( _ NUM , w ) ; }
public static int next Int ( int n ) {  Random random = get Random ( ) ; int value = random . next Int ( n ) ; if ( ! _is Test ) _free Random List . free ( random ) ; return value ; }
protected void do Resume Updates ( ) {  Calendar cal =  Calendar . get Instance (  Locale . get Default ( ) ) ; m First Day Of Week = cal . get First Day Of Week ( ) - _ NUM ; m Show Week Number = _ BOOL ; update Header ( ) ; go To ( m Selected Day . to Millis ( _ BOOL ) , _ BOOL , _ BOOL , _ BOOL ) ; m Adapter . set Selected Day ( m Selected Day ) ; m Today Updater . run ( ) ; }
private void store Last Used ( ) { put (  LAST_ USE , ( int ) (  System . current Time Millis ( ) / _ NUM ) ) ; }
private boolean can Contain (  Element Containment Info child ,  Element Containment Info top , int top Index ) { int child Types = child . types ; int contents = top . contents ; int transparency Allowed = child Types & ( top . transparent To Contents & ~ contents ) ; for ( int container Index = top Index - _ NUM ; transparency Allowed != _ NUM ; -- container Index ) { if ( container Index < _ NUM ) { contents |= transparency Allowed ; break ; }  Element Containment Info container = open Elements . get ( container Index ) ; contents |= transparency Allowed & container . contents ; transparency Allowed = transparency Allowed & container . transparent To Contents & ~ contents ; } return ( contents & child Types ) != _ NUM ; }
public static int [ ] extract Arcs (  ASN1 Object Identifier oid ) throws  Invalid Object Id Exception {  String oid Str = oid . get Id ( ) ;  String Tokenizer str Tok Cnt = new  String Tokenizer ( oid Str , _ STR , _ BOOL ) ; int arc Count = str Tok Cnt . count Tokens ( ) ;  String Tokenizer str Tok = new  String Tokenizer ( oid Str , _ STR , _ BOOL ) ; boolean expect Delimiter = _ BOOL ; int [ ] arcs = new int [ arc Count ] ; int i = _ NUM ; while ( str Tok . has More Tokens ( ) ) {  String token = str Tok . next Token ( ) ; if ( expect Delimiter && ( ! token . equals ( _ STR ) || ! str Tok . has More Tokens ( ) ) ) { throw new  Invalid Object Id Exception ( res . get String ( _ STR ) ) ; } else if ( ! expect Delimiter ) { try { arcs [ i ] =  Integer . parse Int ( token ) ; if ( arcs [ i ] < _ NUM ) { throw new  Invalid Object Id Exception ( res . get String ( _ STR ) ) ; } i ++ ; } catch (  Number Format Exception ex ) { throw new  Invalid Object Id Exception ( res . get String ( _ STR ) ) ; } } expect Delimiter = ! expect Delimiter ; } return arcs ; }
public void test Is Duplicate String ( ) { int count = _ NUM ;  Active MQMessage Audit audit = new  Active MQMessage Audit ( ) ;  Id Generator id Gen = new  Id Generator ( ) ;  List <  String > list = new  Array List < > ( ) ; for ( int i = _ NUM ; i < count ; i ++ ) {  String id = id Gen . generate Id ( ) ; list . add ( id ) ; assert False ( audit . is Duplicate ( id ) ) ; }  List <  String > window List = list . sub List ( list . size ( ) - _ NUM - audit . get Audit Depth ( ) , list . size ( ) - _ NUM ) ; for (  String id : window List ) { assert True ( _ STR + id , audit . is Duplicate ( id ) ) ; } }
protected void update Stats For Conditional Density Estimator (  Conditional Density Estimator classifier ,  Instance class Missing , double class Value ) throws  Exception { if ( m_ Prior Estimator == null ) { set Numeric Priors From Buffer ( ) ; } m_ Sum Scheme Entropy -= classifier . log Density ( class Missing , class Value ) * class Missing . weight ( ) /  Utils . log2 ; m_ Sum Prior Entropy -= m_ Prior Estimator . log Density ( class Value ) * class Missing . weight ( ) /  Utils . log2 ; }
@  Override public boolean accept (  File f ) { if ( f != null ) { if ( f . is Directory ( ) ) { return _ BOOL ; }  String extension = get Extension ( f ) ; if ( extension != null && filters . get ( get Extension ( f ) ) != null ) { return _ BOOL ; } ; } return _ BOOL ; }
@  Override public  Poll Result start Poll (  Poll Controller conn ) { if ( ! _lifecycle . is Active ( ) ) { log . warning ( this + _ STR ) ; return  Poll Result .  CLOSED ; }  Socket Bar socket = conn . get Socket ( ) ; if ( socket == null ) { log . warning ( this + _ STR + conn ) ; return  Poll Result .  CLOSED ; }  Selectable Channel sel Channel = socket . selectable Channel ( ) ; if ( sel Channel == null ) { log . warning ( this + _ STR + socket ) ; return  Poll Result .  CLOSED ; } _connection Count . increment And Get ( ) ; _active Count . increment And Get ( ) ; _register Queue . offer ( conn ) ; return  Poll Result .  START ; }
public  Cluster Policy create Cluster Policy (  String cluster Member Name ) throws  Create Exception { long time1 =  System . current Time Millis ( ) ; if ( _cluster Policies == null ) { _cluster Member Names = get Cluster Member Names ( ) ; if ( _cluster Member Names != null && _cluster Member Names . length > _ NUM ) { _cluster Policies = new  Hash Map <  String ,  Cluster Policy > ( ) ;  Cluster Policy [ ] temp Policy = new  Cluster Policy [ _cluster Member Names . length ] ; for ( int i = _ NUM ; i < _cluster Member Names . length ; i ++ ) temp Policy [ i ] = create Cluster Policy Internal ( _cluster Member Names [ i ] ) ;  Array List <  Replication Policy > selected Repl Policies = new  Array List <  Replication Policy > ( _cluster Member Names . length ) ;  List <  String > selected Repl Group Names = new  Array List <  String > ( _cluster Member Names . length ) ; for ( int i = _ NUM ; i < temp Policy . length ; i ++ ) if ( temp Policy [ i ] . m_ Replication Policy != null && ! selected Repl Group Names . contains ( temp Policy [ i ] . m_ Replication Policy . m_ Replication Group Name ) ) { selected Repl Policies . add ( temp Policy [ i ] . m_ Replication Policy ) ; selected Repl Group Names . add ( temp Policy [ i ] . m_ Replication Policy . m_ Replication Group Name ) ; } if ( selected Repl Policies . is Empty ( ) ) selected Repl Policies = null ; else selected Repl Policies . trim To Size ( ) ; for ( int i = _ NUM ; i < _cluster Member Names . length ; i ++ ) { temp Policy [ i ] . m_ Replication Groups = selected Repl Policies ; _cluster Policies . put ( _cluster Member Names [ i ] , temp Policy [ i ] ) ; } } }  Cluster Policy result = _cluster Policies . get ( cluster Member Name ) ; if ( result == null ) result = create Cluster Policy Internal ( cluster Member Name ) ; long time2 =  System . current Time Millis ( ) ; if ( _logger . is Loggable (  Level .  FINE ) ) { _logger . fine ( _ STR + cluster Member Name + _ STR + ( time2 - time1 ) + _ STR ) ; } return result ; }
public static boolean compare Doubles ( double a , double b ) { if (  Double . is Na N ( a ) &&  Double . is Na N ( b ) ) return _ BOOL ; if ( !  Double . is Infinite ( a ) && !  Double . is Infinite ( b ) ) return  Math . abs ( a - b ) <=  EPSILON ; return a == b ; }
public  Configure Coerceive Parsing Dialog_ NB (  Coercive Parsing coercive Parsing ) { this . coercive Parsing = coercive Parsing ; init Components ( ) ; final  Iterate Model number Of Tags Iterator = coercive Parsing . get Number Of Tags Iterator ( ) ; configure Iterate Model_ NB2 . set Start At (  String . value Of ( number Of Tags Iterator . get Start At ( ) ) ) ; configure Iterate Model_ NB2 . set Stop At (  String . value Of ( number Of Tags Iterator . get Stop At ( ) ) ) ; configure Iterate Model_ NB2 . set Increment (  String . value Of ( number Of Tags Iterator . get Increment ( ) ) ) ; configure Iterate Model_ NB2 . set Iterate Strategie ( number Of Tags Iterator . get Iterate Strategie ( ) ) ;  List <  String > tag Names =  Arrays . as List ( coercive Parsing . get Tag Names ( ) ) ; configure String List_ NB1 . set String List ( tag Names ) ; }
public static double log Of Base ( double number , int base ) { return  Math . log ( number ) /  Math . log ( base ) ; }
public  Entry edit Entry (  User user ,  String id ,  String note ,  String quotation , boolean is Public ,  Long mod Time , boolean is Admin ,  Errors errors ) { if ( mod Time == null ) {  Errors . add ( errors , error Messages . error Mod Time Is Null ( ) ) ; return null ; } if ( user == null ) {  Errors . add ( errors , error Messages . error User Is Null ( ) ) ; return null ; } if ( id != null && ! id Generator . is Id Well Formed ( id ) ) {  Errors . add ( errors , error Messages . error Id Is Invalid ( ) ) ; return null ; } final  Entry entry = get Entry By Id ( id ) ; if ( entry == null ) {  Errors . add ( errors , error Messages . error The Entry Could Not Be Found ( ) ) ; return null ; } if ( ! can User Modify Entry ( user , entry , is Admin ) ) {  Errors . add ( errors , error Messages . error The User Is Not Entitled To Modify The Entry ( ) ) ; return null ; } if ( note != null ) { note = clean Up Text ( note ) ; } if ( entry . is Notebook ( ) ) { entry . set Notebook Title ( note ) ; } else if ( entry . is Source ( ) ) { entry . set Source Title ( note ) ; } else { entry . set Note ( note ) ; } entry . set Mod Time ( mod Time ) ; entry . set Is Public ( is Public ) ; if ( entry . get Create Time ( ) > mod Time . long Value ( ) ) { mod Time = entry . get Create Time ( ) ; } if ( entry . is Quotation ( ) ) { if ( quotation != null ) { quotation = clean Up Text ( quotation ) ; entry . set Quotation ( quotation ) ; } } return entry ; }
public  File Saver Descriptor ( @  Not Null  String title , @  Not Null  String description ,  String ... extensions ) { super ( _ BOOL , _ BOOL , _ BOOL , _ BOOL , _ BOOL , _ BOOL ) ; set Title ( title ) ; set Description ( description ) ; this . extensions =  Arrays . as List ( extensions ) ; }
protected int read Block ( ) { block Size = read ( ) ; int n = _ NUM ; if ( block Size > _ NUM ) { try { int count ; while ( n < block Size ) { count = block Size - n ; raw Data . get ( block , n , count ) ; n += count ; } } catch ( final  Exception e ) {  Log . w (  TAG , _ STR , e ) ; status =  STATUS_ FORMAT_ ERROR ; } } return n ; }
public void add Run ( final  Run run ) { runs . add ( run ) ; run . set Id ( run Id Counter ++ ) ; }
void copy Into (  Converter [ ] converters ) {  System . arraycopy ( i Converters , _ NUM , converters , _ NUM , i Converters . length ) ; }
@  Override public boolean add Output Sensor (  String sensor Name , int state ) {  Output Sensor output Sensor = new  Output Sensor ( sensor Name ) ; if ( ! output Sensor . set State ( state ) ) { return _ BOOL ; } _output Sensor List . add ( output Sensor ) ; return _ BOOL ; }
public void init (  Socket Channel channel ) { _channel = channel ; _read Buffer . clear ( ) ; _read Buffer . flip ( ) ; _needs Flush = _ BOOL ; }
public void reset ( ) {  Timber . i ( _ STR ) ; m Current Player . reset ( ) ; m Next Player . reset ( ) ; m Queue =  Collections . empty List ( ) ; m Queue Index = _ NUM ; m Requested Seek Position = _ NUM ; m Play When Prepared = _ BOOL ; }
@  Override public  Expected <  T > if Present ( final  Consumer < ? super  T > consumer ) { if ( this . value != null ) consumer . accept ( this . value ) ; return this ; }
protected void send Intensity ( double intensity ) { if ( log . is Debug Enabled ( ) ) { log . debug ( _ STR + intensity + _ STR + _ STR + last Output Step + _ STR + max Dim Step ) ; } int new Step = ( int )  Math . round ( intensity * max Dim Step ) ; if ( ( new Step < _ NUM ) || ( new Step > max Dim Step ) ) { log . error ( _ STR + new Step + _ STR + intensity ) ; } if ( new Step == _ NUM ) { if ( log . is Debug Enabled ( ) ) { log . debug ( _ STR + intensity + _ STR ) ; } return ; }  X10 Sequence out = new  X10 Sequence ( ) ; out . add Ext Data ( housecode , devicecode ,  X10 Sequence .  EXTCMD_ DIM , new Step ) ; tc . send X10 Sequence ( out , null ) ; last Output Step = new Step ; if ( log . is Debug Enabled ( ) ) { log . debug ( _ STR + intensity + _ STR +  X10 Sequence . house Value To Text ( housecode ) + _ STR + devicecode + _ STR + new Step ) ; } }
public  Glow Scheduler (  Glow Server server ,  World Scheduler worlds ) { this . server = server ; this . worlds = worlds ; in Tick Task Condition = worlds . get Advance Condition ( ) ; tick End Run = null ; primary Thread =  Thread . current Thread ( ) ; }
public void delete ( ) throws  IOException { close ( ) ;  Utils . delete Contents ( directory ) ; }
@  Override public boolean execute ( @  Not Null  Psi Element pe , @  Not Null  Resolve State state ) { if ( pe instanceof  Psi Variable ) { final  Psi Variable pvar = (  Psi Variable ) pe ; if ( ! my Static Sensitive Flag || ! my Static Scope Flag || pvar . has Modifier Property (  Psi Modifier .  STATIC ) ) { if ( check ( pvar , state ) ) { my Result List . add ( pvar ) ; } } } return _ BOOL ; }
public void characters ( char [ ] ch , int start , int length ) throws  SAXException { try { stop Terminator ( ) ; if ( w == null ) return ; int end = start + length ; for ( int i = start ; i < end ; i ++ ) { char c = ch [ i ] ; switch ( c ) { case _ STR : w . write ( _ STR ) ; break ; case _ STR : w . write ( _ STR ) ; break ; case _ STR : w . write ( _ STR ) ; break ; case _ STR : case _ STR : case _ STR : w . write ( c ) ; break ; default : if ( can Encode ( c ) ) { w . write ( c ) ; } else { w . write ( _ STR ) ; w . write (  Integer . to String ( c ) ) ; w . write ( _ STR ) ; } break ; } } } catch (  IOException e ) { throw new  SAXException ( e ) ; } }
public static  String to Human Readable String ( final  String iso8601 Duration ) {  String str = _ STR ; if ( iso8601 Duration . matches ( _ STR ) ) { str = _ STR ; } else {  String hours = get Hours ( iso8601 Duration ) , minutes = get Minutes ( iso8601 Duration ) , seconds = get Seconds ( iso8601 Duration ) ; if ( hours != null ) { str = hours ; if ( minutes != null && minutes . length ( ) == _ NUM ) { minutes = _ STR + minutes ; } } if ( str . is Empty ( ) ) str = minutes ; else str += _ STR + minutes ; if ( str . is Empty ( ) ) str = seconds ; else str += _ STR + seconds ; } return str ; }
@  Override public  IChat Message send Message ( final  String text ) throws  Remote Exception { if (  Text Utils . is Empty ( text ) ) { throw new  Server Api Illegal Argument Exception ( _ STR ) ; } int message Length = text . length ( ) ; int max Message Length = m Rcs Settings . get Max Group Chat Message Length ( ) ; if ( message Length > max Message Length ) { throw new  Server Api Illegal Argument Exception ( _ STR + message Length + _ STR + max Message Length + _ STR ) ; } if ( ! is Allowed To Send Message ( ) ) { throw new  Server Api Permission Denied Exception ( _ STR ) ; } try { m Im Service . remove Group Chat Composing Status ( m Chat Id ) ; long timestamp =  System . current Time Millis ( ) ; final  Chat Message msg =  Chat Utils . create Text Message ( null , text , timestamp , timestamp ) ;  Chat Message Persisted Storage Accessor persisted Storage = new  Chat Message Persisted Storage Accessor ( m Messaging Log , msg . get Message Id ( ) , msg . get Remote Contact ( ) , text , msg . get Mime Type ( ) , m Chat Id ,  Direction .  OUTGOING ) ; add Outgoing Group Chat Message ( msg ,  Content .  Status .  QUEUED ,  Content .  Reason Code .  UNSPECIFIED ) ; if ( ! m Chat Service . is Group Chat Active ( m Chat Id ) ) { m Chat Service . set Group Chat State And Reason Code ( m Chat Id ,  Group Chat .  State .  STARTED ,  Group Chat .  Reason Code .  UNSPECIFIED ) ; } m Im Service . try To Dequeue Group Chat Messages And Group File Transfers ( m Chat Id ) ; return new  Chat Message Impl ( persisted Storage ) ; } catch (  Server Api Base Exception e ) { if ( ! e . should Not Be Logged ( ) ) { s Logger . error (  Exception Util . get Full Stack Trace ( e ) ) ; } throw e ; } catch (  Exception e ) { s Logger . error (  Exception Util . get Full Stack Trace ( e ) ) ; throw new  Server Api Generic Exception ( e ) ; } }
void remove (  Tcp Server Thread t ) { running . remove ( t ) ; }
public  Dock Node Event Handler (  Node node ) { this . node = node ; }
private int read Source To Log (  Settings settings ) {  String source To Log = settings . get (  INDEX_ INDEXING_ SLOWLOG_ MAX_ SOURCE_ CHARS_ TO_ LOG , _ STR ) ; try { return  Integer . parse Int ( source To Log , _ NUM ) ; } catch (  Number Format Exception e ) { return  Booleans . parse Boolean ( source To Log , _ BOOL ) ?  Integer .  MAX_ VALUE : _ NUM ; } }
private void delete Current License File On Disk ( ) {  File license File = new  File (  License Constants .  LICENSE_ FILE_ PATH ) ; if ( license File . exists ( ) ) { license File . delete ( ) ; } }
@  Deprecated public static  Network Parameters test Net ( ) { return  Test Net3 Params . get ( ) ; }
public final void read From Stream (  Data Input Stream dis , int version ) throws  IOException ,  Chess Parse Error { event = dis . read UTF ( ) ; site = dis . read UTF ( ) ; date = dis . read UTF ( ) ; round = dis . read UTF ( ) ; white = dis . read UTF ( ) ; black = dis . read UTF ( ) ; start Pos =  Text IO . read FEN ( dis . read UTF ( ) ) ; current Pos = new  Position ( start Pos ) ; time Control = dis . read UTF ( ) ; if ( version >= _ NUM ) { white Time Control = dis . read UTF ( ) ; black Time Control = dis . read UTF ( ) ; } else { white Time Control = _ STR ; black Time Control = _ STR ; } int n Tags = dis . read Int ( ) ; tag Pairs . clear ( ) ; for ( int i = _ NUM ; i < n Tags ; i ++ ) {  Tag Pair tp = new  Tag Pair ( ) ; tp . tag Name = dis . read UTF ( ) ; tp . tag Value = dis . read UTF ( ) ; tag Pairs . add ( tp ) ; } root Node = new  Node ( ) ;  Node . read From Stream ( dis , root Node ) ; current Node = root Node ; int path Len = dis . read Int ( ) ; for ( int i = _ NUM ; i < path Len ; i ++ ) go Forward ( dis . read Int ( ) ) ; update Listener ( ) ; }
public  Rect update Fast Scroller Bounds (  Base Recycler View rv , int last Touch Y ) { m Invalidate Rect . set ( m Bg Bounds ) ; if ( is Visible ( ) ) { int edge Padding = rv . get Max Scrollbar Width ( ) ; int bg Padding = ( m Bg Original Size - m Text Bounds . height ( ) ) / _ NUM ; int bg Height = m Bg Original Size ; int bg Width =  Math . max ( m Bg Original Size , m Text Bounds . width ( ) + ( _ NUM * bg Padding ) ) ; if (  Utilities . is Rtl ( m Res ) ) { m Bg Bounds . left = rv . get Background Padding ( ) . left + ( _ NUM * rv . get Max Scrollbar Width ( ) ) ; m Bg Bounds . right = m Bg Bounds . left + bg Width ; } else { m Bg Bounds . right = rv . get Width ( ) - rv . get Background Padding ( ) . right - ( _ NUM * rv . get Max Scrollbar Width ( ) ) ; m Bg Bounds . left = m Bg Bounds . right - bg Width ; } m Bg Bounds . top = last Touch Y - ( int ) (  FAST_ SCROLL_ OVERLAY_ Y_ OFFSET_ FACTOR * bg Height ) ; m Bg Bounds . top =  Math . max ( edge Padding ,  Math . min ( m Bg Bounds . top , rv . get Height ( ) - edge Padding - bg Height ) ) ; m Bg Bounds . bottom = m Bg Bounds . top + bg Height ; } else { m Bg Bounds . set Empty ( ) ; } m Invalidate Rect . union ( m Bg Bounds ) ; return m Invalidate Rect ; }
public  DNetscape Ca Policy Url (  JDialog parent ) { super ( parent ) ; set Title ( res . get String ( _ STR ) ) ; init Components ( ) ; }
public boolean textbox Key Typed ( char p_146201_1_ , int p_146201_2_ ) { if ( ! is Focused ) return _ BOOL ; else if (  Gui Screen . func_175278_g ( p_146201_2_ ) ) { set Cursor Position End ( ) ; set Selection Pos ( _ NUM ) ; return _ BOOL ; } else if (  Gui Screen . func_175280_f ( p_146201_2_ ) ) {  Gui Screen . set Clipboard String ( get Selected Text ( ) ) ; return _ BOOL ; } else if (  Gui Screen . func_175279_e ( p_146201_2_ ) ) { if ( is Enabled ) write Text (  Gui Screen . get Clipboard String ( ) ) ; return _ BOOL ; } else if (  Gui Screen . func_175277_d ( p_146201_2_ ) ) {  Gui Screen . set Clipboard String ( get Selected Text ( ) ) ; if ( is Enabled ) write Text ( _ STR ) ; return _ BOOL ; } else switch ( p_146201_2_ ) { case _ NUM : if (  Gui Screen . is Ctrl Key Down ( ) ) { if ( is Enabled ) delete Words ( - _ NUM ) ; } else if ( is Enabled ) delete From Cursor ( - _ NUM ) ; return _ BOOL ; case _ NUM : if (  Gui Screen . is Shift Key Down ( ) ) set Selection Pos ( _ NUM ) ; else set Cursor Position Zero ( ) ; return _ BOOL ; case _ NUM : if (  Gui Screen . is Shift Key Down ( ) ) { if (  Gui Screen . is Ctrl Key Down ( ) ) set Selection Pos ( get Nth Word From Pos ( - _ NUM , get Selection End ( ) ) ) ; else set Selection Pos ( get Selection End ( ) - _ NUM ) ; } else if (  Gui Screen . is Ctrl Key Down ( ) ) set Cursor Position ( get Nth Word From Cursor ( - _ NUM ) ) ; else move Cursor By ( - _ NUM ) ; return _ BOOL ; case _ NUM : if (  Gui Screen . is Shift Key Down ( ) ) { if (  Gui Screen . is Ctrl Key Down ( ) ) set Selection Pos ( get Nth Word From Pos ( _ NUM , get Selection End ( ) ) ) ; else set Selection Pos ( get Selection End ( ) + _ NUM ) ; } else if (  Gui Screen . is Ctrl Key Down ( ) ) set Cursor Position ( get Nth Word From Cursor ( _ NUM ) ) ; else move Cursor By ( _ NUM ) ; return _ BOOL ; case _ NUM : if (  Gui Screen . is Shift Key Down ( ) ) set Selection Pos ( text . length ( ) ) ; else set Cursor Position End ( ) ; return _ BOOL ; case _ NUM : if (  Gui Screen . is Ctrl Key Down ( ) ) { if ( is Enabled ) delete Words ( _ NUM ) ; } else if ( is Enabled ) delete From Cursor ( _ NUM ) ; return _ BOOL ; default : if (  Email Allowed Characters . is Allowed Character ( p_146201_1_ ) ) { if ( is Enabled ) write Text (  Character . to String ( p_146201_1_ ) ) ; return _ BOOL ; } else return _ BOOL ; } }
public static  Path create Directory ( final  Path parent , final  String folder Name ) { final  File file = new  File ( parent . to File ( ) , folder Name ) ; if ( ! file . exists ( ) ) { if ( ! file . mkdir ( ) ) { throw new  Runtime Exception ( _ STR + parent + _ STR + folder Name + _ STR ) ; } } file . delete On Exit ( ) ; return file . to Path ( ) ; }
public static boolean is Windows8 ( ) { return os Name . index Of ( _ STR ) > - _ NUM && ( os Version . equals ( _ STR ) || os Version . equals ( _ STR ) ) ; }
protected  Set <  Function Interface > find Unused Functions (  Set <  Unit Interface > units ) {  Set <  Function Interface > all Functions = new  Hash Set <  Function Interface > ( ) ;  Set <  Function Interface > used Functions = new  Hash Set <  Function Interface > ( ) ; for (  Unit Interface unit : units ) {  List <  Function Interface > unit Functions = get Unit Functions ( unit ) ; all Functions . add All ( unit Functions ) ; for (  Function Interface unit Function : unit Functions ) { for (  Function Interface used Function : unit Function . get Called Functions ( ) ) { used Functions . add ( used Function ) ; } } } all Functions . remove All ( used Functions ) ; return all Functions ; }
private static void add Items To List ( int start Index , int end Index ) { for ( int i = start Index ; i < end Index ; i ++ ) { values . add ( new  Integer ( i ) ) ; } }
public static synchronized  List <  Proxy > no Proxy List ( ) { if ( no Proxy List == null ) {  Array List <  Proxy > list = new  Array List <  Proxy > ( _ NUM ) ; list . add (  Proxy .  NO_ PROXY ) ; no Proxy List =  Collections . unmodifiable List ( list ) ; } return no Proxy List ; }
public void add Includes (  String [ ] definitions ) { add Strings (  INCLUDES , definitions ) ; add Strings ( linker_more ,  INCLUDES , definitions ) ; new Linker Options After Compile . add (  INCLUDES ) ; }
public void tally Variant (  Vcf Header header ,  Vcf Record rec ) { tally Variant ( rec , header . get Sample Names ( ) ) ; }
public  LDIFEntry Reader ( final  String ... ldif Lines ) { super (  Arrays . as List ( ldif Lines ) ) ; }
public void update Preson Info ( ) { this . left Person = person2 Leaving Person Info . get ( this . person Id ) ; this . entered Person = person2 Entering Person Info . get ( this . person Id ) ; }
public void present Licenses ( boolean pre Accept ) {  License Set licenses = license Module . get Required Licenses ( ) ; if ( pre Accept ) { licenses . accept All ( ) ; } else { for (  License license : licenses ) { if ( license . is Accepted ( ) ) { continue ; } user . show ( _ STR ) ; user . show ( license . get License Text ( ) ) ;  String input = user . ask ( _ STR ) ; if ( input != null &&  YES . starts With ( input . to Lower Case ( ) ) ) { license . accept ( ) ; } else { license . reject ( ) ; } } } }
public void add Geo Key (  XTIFFField geo Key ) { geo Key Index . put ( new  Integer ( geo Key . get Tag ( ) ) , geo Key ) ; has Geo Keys = _ BOOL ; }
public static  Geo Time Serie detect (  Geo Time Serie gts , int alphabet Size , int word Len , int window Len ,  Collection <  String > patterns , boolean standardize PAA ) throws  Warp Script Exception {  Geo Time Serie gts Patterns =  GTSHelper . b SAX ( gts , alphabet Size , word Len , window Len , standardize PAA ) ;  GTSHelper . sort ( gts Patterns ) ;  Geo Time Serie detected = new  Geo Time Serie ( gts . lastbucket , gts . bucketcount , gts . bucketspan , _ NUM ) ; detected . set Metadata ( gts . get Metadata ( ) ) ; int lastidx = - _ NUM ; for ( int i = _ NUM ; i < gts Patterns . values ; i ++ ) { if ( ! patterns . contains ( gts Patterns . string Values [ i ] ) ) { continue ; } for ( int j = _ NUM ; j < window Len ; j ++ ) { if ( i + j > lastidx ) { lastidx = i + j ;  GTSHelper . set Value ( detected ,  GTSHelper . tick At Index ( gts , lastidx ) ,  GTSHelper . location At Index ( gts , lastidx ) ,  GTSHelper . elevation At Index ( gts , lastidx ) ,  GTSHelper . value At Index ( gts , lastidx ) , _ BOOL ) ; } } } return detected ; }
private  String Builder debug Dump Candidates (  String Builder msg ,  List < ? extends  Itemset > candidates ,  Vector Field Type Information <  Bit Vector > meta ) { msg . append ( _ STR ) ; for (  Itemset itemset : candidates ) { msg . append ( _ STR ) ; itemset . append To ( msg , meta ) ; msg . append ( _ STR ) ; } return msg ; }
public static final void write Boolean Array Xml ( boolean [ ] val ,  String name ,  Xml Serializer out ) throws  Xml Pull Parser Exception , java . io .  IOException { if ( val == null ) { out . start Tag ( null , _ STR ) ; out . end Tag ( null , _ STR ) ; return ; } out . start Tag ( null , _ STR ) ; if ( name != null ) { out . attribute ( null , _ STR , name ) ; } final int  N = val . length ; out . attribute ( null , _ STR ,  Integer . to String (  N ) ) ; for ( int i = _ NUM ; i <  N ; i ++ ) { out . start Tag ( null , _ STR ) ; out . attribute ( null , _ STR ,  Boolean . to String ( val [ i ] ) ) ; out . end Tag ( null , _ STR ) ; } out . end Tag ( null , _ STR ) ; }
public void add Outbound Rule ( final  Outbound Rule outbound Rule ) { outbound Rule . set Id ( outbound Rule Id Counter ++ ) ; outbound Rules . add ( outbound Rule ) ; }
public  Skype (  String username ,  String password ) { this . username = username ; this . password = password ; }
private void add Flags ( int newflags ) { flags = get Layout Flags ( ) | newflags ; }
public static  String match Certificate (  Key Store key Store ,  X509 Certificate cert ) throws  Crypto Exception { try { for (  Enumeration aliases = key Store . aliases ( ) ; aliases . has More Elements ( ) ; ) {  String alias = (  String ) aliases . next Element ( ) ; if ( key Store . is Certificate Entry ( alias ) ) {  X509 Certificate comp Cert =  X509 Cert Util . convert Certificate ( key Store . get Certificate ( alias ) ) ; if ( cert . equals ( comp Cert ) ) { return alias ; } } } return null ; } catch (  Key Store Exception ex ) { throw new  Crypto Exception ( res . get String ( _ STR ) , ex ) ; } }
void purge Last Articles ( int amount To Purge ) { if ( ! is DBAvailable ( ) ) return ; long time =  System . current Time Millis ( ) ;  String query = _ STR +  TABLE_ ARTICLES + _ STR + (  Utils .  ARTICLE_ LIMIT - amount To Purge + _ STR ) ; safely Delete Articles ( query , null ) ;  Log . d (  TAG , _ STR + (  System . current Time Millis ( ) - time ) + _ STR ) ; }
public void reclaim Views (  List <  View > views ) { int child Count = get Child Count ( ) ;  Recycler Listener listener = m Recycler . m Recycler Listener ; for ( int i = _ NUM ; i < child Count ; i ++ ) {  View child = get Child At ( i ) ;  Two Way Abs List View .  Layout Params lp = (  Two Way Abs List View .  Layout Params ) child . get Layout Params ( ) ; if ( lp != null && m Recycler . should Recycle View Type ( lp . view Type ) ) { views . add ( child ) ; if ( listener != null ) { listener . on Moved To Scrap Heap ( child ) ; } } } m Recycler . reclaim Scrap Views ( views ) ; remove All Views In Layout ( ) ; }
Proxy Verifier (  Txn Manager server Proxy ,  Uuid proxy ID ) { if ( ! ( server Proxy instanceof  Remote Method Control ) ) { throw new  Unsupported Operation Exception ( _ STR ) ; } else if ( ! ( server Proxy instanceof  Trust Equivalence ) ) { throw new  Unsupported Operation Exception ( _ STR + _ STR ) ; } else if ( proxy ID == null ) { throw new  Illegal Argument Exception ( _ STR ) ; } this . server Proxy = (  Remote Method Control ) server Proxy ; this . proxy ID = proxy ID ; }
public void paint (  Graphics g ) { g . translate ( _ NUM , translate Y ) ; super . paint ( g ) ; }
private static long add And Check ( long a , long b ,  Localizable pattern ) throws  Math Runtime Exception { final long result = a + b ; if ( ! ( ( a ^ b ) < _ NUM || ( a ^ result ) >= _ NUM ) ) { throw new  Math Runtime Exception ( pattern , a , b ) ; } return result ; }
private void serialize Compact RDFGeneral Qualifier ( int indent ,  XMPNode node ) throws  IOException ,  XMPException { write ( _ STR ) ; write Newline ( ) ; serialize Canonical RDFProperty ( node , _ BOOL , _ BOOL , indent + _ NUM ) ; for (  Iterator iq = node . iterate Qualifier ( ) ; iq . has Next ( ) ; ) {  XMPNode qualifier = (  XMPNode ) iq . next ( ) ; serialize Canonical RDFProperty ( qualifier , _ BOOL , _ BOOL , indent + _ NUM ) ; } }
private  JCheck Box add Checkbox (  String text ,  Container container ) {  JCheck Box checkbox = new  JCheck Box ( text ) ; checkbox . set Alignment X (  Component .  LEFT_ ALIGNMENT ) ; checkbox . set Border (  Border Factory . create Empty Border ( _ NUM , _ NUM , _ NUM , _ NUM ) ) ; container . add ( checkbox ) ; return checkbox ; }
public void push ( ) { state . cliprgn = g . get Clip Bounds ( ) ; stack . push ( state ) ; state = (  Graphics State ) state . clone ( ) ; }
public static void drop Index (  Connection conn ,  String schema ,  String table ) throws  SQLException { init ( conn ) ;  Prepared Statement prep = conn . prepare Statement ( _ STR +  SCHEMA + _ STR ) ; prep . set String ( _ NUM , schema ) ; prep . set String ( _ NUM , table ) ;  Result Set rs = prep . execute Query ( ) ; if ( ! rs . next ( ) ) { return ; } int index Id = rs . get Int ( _ NUM ) ; prep = conn . prepare Statement ( _ STR +  SCHEMA + _ STR ) ; prep . set Int ( _ NUM , index Id ) ; prep . execute ( ) ; create Or Drop Trigger ( conn , schema , table , _ BOOL ) ; prep = conn . prepare Statement ( _ STR +  SCHEMA + _ STR ) ; while ( _ BOOL ) { prep . set Int ( _ NUM , index Id ) ; int deleted = prep . execute Update ( ) ; if ( deleted == _ NUM ) { break ; } } prep = conn . prepare Statement ( _ STR +  SCHEMA + _ STR + _ STR +  SCHEMA + _ STR ) ; while ( _ BOOL ) { int deleted = prep . execute Update ( ) ; if ( deleted == _ NUM ) { break ; } } }
public synchronized int add (  IAudio Processor processor ) { processors . add ( processor ) ; build Final Processor ( ) ; return processors . index Of ( processor ) ; }
public  Script Builder data ( int index , byte [ ] data ) { byte [ ] copy =  Arrays . copy Of ( data , data . length ) ; int opcode ; if ( data . length == _ NUM ) { opcode =  OP_0 ; } else if ( data . length == _ NUM ) { byte b = data [ _ NUM ] ; if ( b >= _ NUM && b <= _ NUM ) opcode =  Script . encode To Op N ( b ) ; else opcode = _ NUM ; } else if ( data . length <  OP_ PUSHDATA1 ) { opcode = data . length ; } else if ( data . length < _ NUM ) { opcode =  OP_ PUSHDATA1 ; } else if ( data . length < _ NUM ) { opcode =  OP_ PUSHDATA2 ; } else { throw new  Runtime Exception ( _ STR ) ; } return add Chunk ( index , new  Script Chunk ( opcode , copy ) ) ; }
public void initialize (  Map config Params ) {  String delimiter Config = (  String ) config Params . get (  Policy Config .  RESOURCE_ COMPARATOR_ DELIMITER ) ; if ( delimiter Config != null ) { this . delimiter = delimiter Config ; }  String case Config = (  String ) config Params . get (  Policy Config .  RESOURCE_ COMPARATOR_ CASE_ SENSITIVE ) ; if ( case Config != null ) { if ( case Config . equals ( _ STR ) ) { this . case Sensitive = _ BOOL ; } else if ( case Config . equals ( _ STR ) ) { this . case Sensitive = _ BOOL ; } else { this . case Sensitive = _ BOOL ; } }  String wildcard Config = (  String ) config Params . get (  Policy Config .  RESOURCE_ COMPARATOR_ WILDCARD ) ; if ( wildcard Config != null ) { this . wildcard = wildcard Config ; }  String one Level Wildcard Config = (  String ) config Params . get (  Policy Config .  RESOURCE_ COMPARATOR_ ONE_ LEVEL_ WILDCARD ) ; if ( one Level Wildcard Config != null ) { this . one Level Wildcard = one Level Wildcard Config ; } if ( debug . message Enabled ( ) ) { debug . message ( _ STR + _ STR + delimiter + _ STR + wildcard + _ STR + one Level Wildcard + _ STR + case Config ) ; } one Level Wildcard Length = one Level Wildcard . length ( ) ; wildcard Length = wildcard . length ( ) ; if ( one Level Wildcard . index Of ( wildcard ) != - _ NUM ) { wildcard Embedded = _ BOOL ; } else { wildcard Embedded = _ BOOL ; } if ( wildcard . index Of ( one Level Wildcard ) != - _ NUM ) { one Level Wildcard Embedded = _ BOOL ; } else { one Level Wildcard Embedded = _ BOOL ; } if ( debug . message Enabled ( ) ) { debug . message ( _ STR + wildcard Embedded + _ STR + one Level Wildcard Embedded ) ; } return ; }
public static boolean is Embedded Base64 Image (  String uri ) { return ( uri != null && uri . starts With ( _ STR ) ) ; }
void change State ( int new State ) { int old State ; synchronized ( state Lock ) { if ( state == new State ) return ; old State = state ; state = new State ; state Lock . notify All ( ) ; } send State Change Notification ( old State , new State ) ; }
private int parse Link Label ( ) {  String m = match (  LINK_ LABEL ) ; return m == null ? _ NUM : m . length ( ) ; }
private static void insert Comments In Node (  Node node ,  List <  Comment > comments To Attribute ) { if ( comments To Attribute . size ( ) == _ NUM ) return ;  List <  Node > children = node . get Children Nodes ( ) ;  Position Utils . sort By Begin Position ( children ) ; for (  Node child : children ) {  List <  Comment > comments Inside Child = new  Linked List <  Comment > ( ) ; for (  Comment c : comments To Attribute ) { if (  Position Utils . node Contains ( child , c , _do Not Consider Annotations As Node Start For Code Attribution ) ) { comments Inside Child . add ( c ) ; } } comments To Attribute . remove All ( comments Inside Child ) ; insert Comments In Node ( child , comments Inside Child ) ; }  List <  Comment > attributed Comments = new  Linked List <  Comment > ( ) ; for (  Comment comment : comments To Attribute ) { if ( comment . is Line Comment ( ) ) { for (  Node child : children ) { if ( child . get End Line ( ) == comment . get Begin Line ( ) ) { if ( attribute Line Comment To Node Or Child ( child , comment . as Line Comment ( ) ) ) { attributed Comments . add ( comment ) ; } } } } }  Comment previous Comment = null ; attributed Comments = new  Linked List <  Comment > ( ) ;  List <  Node > children And Comments = new  Linked List <  Node > ( ) ; children And Comments . add All ( children ) ; children And Comments . add All ( comments To Attribute ) ;  Position Utils . sort By Begin Position ( children And Comments , _do Not Consider Annotations As Node Start For Code Attribution ) ; for (  Node thing : children And Comments ) { if ( thing instanceof  Comment ) { previous Comment = (  Comment ) thing ; if ( ! previous Comment . is Orphan ( ) ) { previous Comment = null ; } } else { if ( previous Comment != null && ! thing . has Comment ( ) ) { if ( ! _do Not Assign Comments Preceeding Empty Lines || ! there Are Lines Between ( previous Comment , thing ) ) { thing . set Comment ( previous Comment ) ; attributed Comments . add ( previous Comment ) ; previous Comment = null ; } } } } comments To Attribute . remove All ( attributed Comments ) ; for (  Comment c : comments To Attribute ) { if ( c . is Orphan ( ) ) { node . add Orphan Comment ( c ) ; } } }
public static  String read File As String (  File file ) throws  File Not Found Exception { return read File As String ( file . get Absolute Path ( ) ) ; }
public synchronized void check Access (  License Checker Callback callback ) { if ( m Policy . allow Access ( ) ) {  Log . i (  TAG , _ STR ) ; callback . allow (  Policy .  LICENSED ) ; } else {  License Validator validator = new  License Validator ( m Policy , new  Null Device Limiter ( ) , callback , generate Nonce ( ) , m Package Name , m Version Code ) ; if ( m Service == null ) {  Log . i (  TAG , _ STR ) ; try { boolean bind Result = m Context . bind Service ( new  Intent ( new  String (  Base64 . decode ( _ STR ) ) ) , this ,  Context .  BIND_ AUTO_ CREATE ) ; if ( bind Result ) { m Pending Checks . offer ( validator ) ; } else {  Log . e (  TAG , _ STR ) ; handle Service Connection Error ( validator ) ; } } catch (  Security Exception e ) { callback . application Error (  License Checker Callback .  ERROR_ MISSING_ PERMISSION ) ; } catch (  Base64 Decoder Exception e ) { e . print Stack Trace ( ) ; } } else { m Pending Checks . offer ( validator ) ; run Checks ( ) ; } } }
public void close ( ) { if ( ! is Open ) return ;  Log . d (  TAG , _ STR ) ; loading Lock . lock ( ) ; try { save ( ) ; if ( save File Stream != null ) {  Saving Helper . close ( save File Stream ) ; save File Stream = null ; } saving Disabled = _ BOOL ; is Open = _ BOOL ;  Log . i (  TAG , _ STR ) ; } finally { loading Lock . unlock ( ) ; } }
@  Override public  List chunk String (  String s To Chunk ) {  Integer [ ] i Res = split Points By Delimiter List ( s To Chunk , get Delimiters ( ) ) ;  String [ ] s Res = split String By Delimiter Points ( s To Chunk , i Res ) ; return  Arrays . as List ( s Res ) ; }
public static  String convert Boolean Arr To String (  Boolean [ ] no Dictionary Dims Mapping ) {  String Builder builder = new  String Builder ( ) ; int index = _ NUM ; for ( ; index < no Dictionary Dims Mapping . length ; index ++ ) { builder . append ( no Dictionary Dims Mapping [ index ] ) ; builder . append (  Carbon Common Constants .  COMA_ SPC_ CHARACTER ) ; } int last Index = builder . last Index Of (  Carbon Common Constants .  COMA_ SPC_ CHARACTER ) ;  String str = - _ NUM != last Index ? builder . substring ( _ NUM , last Index ) : builder . to String ( ) ; return str ; }
public void clear ( ) { m_ Model . clear ( ) ; set Buttons ( null ) ; }
public static int brighter ( int c ) { int r = red ( c ) , g = green ( c ) , b = blue ( c ) ; int i = ( int ) ( _ NUM / ( _ NUM - scale ) ) ; if ( r == _ NUM && g == _ NUM && b == _ NUM ) { return rgba ( i , i , i , alpha ( c ) ) ; } if ( r > _ NUM && r < i ) r = i ; if ( g > _ NUM && g < i ) g = i ; if ( b > _ NUM && b < i ) b = i ; return rgba (  Math . min ( _ NUM , ( int ) ( r / scale ) ) ,  Math . min ( _ NUM , ( int ) ( g / scale ) ) ,  Math . min ( _ NUM , ( int ) ( b / scale ) ) , alpha ( c ) ) ; }
public void shutdown ( ) { running = _ BOOL ; if ( network Threads != null ) { for (  Network Thread n : network Threads ) { n . stopped = _ BOOL ; } } network Threads = null ; synchronized (  LOCK ) {  LOCK . notify All ( ) ; } }
public  Serial Message ( byte [ ] a ) { super (  String . value Of ( a ) ) ; set Binary ( _ BOOL ) ; }
@  Override @  Suppress Warnings ( _ STR ) public void completed ( int bytes Transferred , boolean can Invoke Direct ) { if ( bytes Transferred == _ NUM ) { bytes Transferred = - _ NUM ; } else { update Buffers ( bytes Transferred ) ; } release Buffers ( ) ; synchronized ( result ) { if ( result . is Done ( ) ) return ; enable Reading ( ) ; if ( scattering Read ) { result . set Result ( (  V )  Long . value Of ( bytes Transferred ) ) ; } else { result . set Result ( (  V )  Integer . value Of ( bytes Transferred ) ) ; } } if ( can Invoke Direct ) {  Invoker . invoke Unchecked ( result ) ; } else {  Invoker . invoke ( result ) ; } }
public void write Golomb ( int divisor , int value ) { int q = value / divisor ; for ( int i = _ NUM ; i < q ; i ++ ) { write Bit ( _ NUM ) ; } write Bit ( _ NUM ) ; int r = value - q * divisor ; int bit = _ NUM -  Integer . number Of Leading Zeros ( divisor - _ NUM ) ; if ( r < ( ( _ NUM << bit ) - divisor ) ) { bit -- ; } else { r += ( _ NUM << bit ) - divisor ; } for ( ; bit >= _ NUM ; bit -- ) { write Bit ( ( r > > > bit ) & _ NUM ) ; } }
private static  Metric Value number_to_metric_value_ (  Number elem ) { if ( elem == null ) return  Metric Value .  EMPTY ; final  String num = elem . to String ( ) ; try { return  Metric Value . from Int Value (  Long . parse Long ( num ) ) ; } catch (  Number Format Exception ex ) { } try { return  Metric Value . from Dbl Value (  Double . parse Double ( num ) ) ; } catch (  Number Format Exception ex ) { } return  Metric Value . from Str Value ( num ) ; }
public boolean overlaps (  String sequence , int start , int end ) { if ( start ==  MISSING || end ==  MISSING || end < start ) { throw new  Illegal Argument Exception ( ) ; } if ( ! m Sequence . equals ( sequence ) ) { return _ BOOL ; } if ( ( m End !=  MISSING && start >= m End ) || ( end <= m Start ) ) { return _ BOOL ; } return _ BOOL ; }
public  Okapi BM25 ( double k1 , double b ) { if (  Double . is Na N ( k1 ) ||  Double . is Infinite ( k1 ) || k1 < _ NUM ) throw new  Illegal Argument Exception ( _ STR + k1 ) ; this . k1 = k1 ; if (  Double . is Na N ( b ) || b < _ NUM || b > _ NUM ) throw new  Illegal Argument Exception ( _ STR + b ) ; this . b = b ; }
protected void prepare ( ) { for (  Process Info Parameter para : get Parameter ( ) ) {  String name = para . get Parameter Name ( ) ; if ( para . get Parameter ( ) == null ) ; else if ( name . equals (  PARAM_ M_ Warehouse_ ID ) ) p_ M_ Warehouse_ ID = para . get Parameter As Int ( ) ; else log . log (  Level .  SEVERE , _ STR + name ) ; } p_ C_ Invoice_ ID = get Record_ ID ( ) ; }
public boolean is Configured ( ) {  LOG . debug ( _ STR + url ) ; return url != null && ! url . is Empty ( ) ; }
private static void  Fatal Error (  JNIEnvironment env ,  Address message Address ) { if ( trace JNI )  VM . sys Write ( _ STR ) ;  Runtime Entrypoints . check JNICount Down To GC ( ) ; try {  VM . sys Write (  JNIGeneric Helpers . create String From C ( message Address ) ) ;  System . exit (  EXIT_ STATUS_ JNI_ TROUBLE ) ; } catch (  Throwable unexpected ) { if ( trace JNI ) unexpected . print Stack Trace (  System . err ) ;  System . exit (  EXIT_ STATUS_ RECURSIVELY_ SHUTTING_ DOWN ) ; } }
public boolean make Backup File (  String directory ,  File file ) { if ( file == null ) { log . info ( _ STR ) ; } else if ( file . can Write ( ) ) {  String backup Full Name = directory +  File . separator + create File Name With Date ( file . get Name ( ) ) ; if ( log . is Debug Enabled ( ) ) { log . debug ( _ STR + backup Full Name ) ; }  File backup File = find File ( backup Full Name ) ; if ( backup File != null ) { if ( backup File . delete ( ) ) { if ( log . is Debug Enabled ( ) ) { log . debug ( _ STR + backup Full Name ) ; } } } else { backup File = new  File ( backup Full Name ) ; }  File parent Dir = backup File . get Parent File ( ) ; if ( ! parent Dir . exists ( ) ) { if ( log . is Debug Enabled ( ) ) { log . debug ( _ STR + parent Dir . get Name ( ) ) ; } if ( ! parent Dir . mkdirs ( ) ) { log . error ( _ STR ) ; return _ BOOL ; } } if ( file . rename To ( new  File ( backup Full Name ) ) ) { if ( log . is Debug Enabled ( ) ) { log . debug ( _ STR + backup Full Name ) ; } } else { if ( log . is Debug Enabled ( ) ) { log . debug ( _ STR + backup Full Name ) ; } return _ BOOL ; } } return _ BOOL ; }
public void remove Storage ( ) throws  Backup Exception { logger . debug ( _ STR + data Dir Spec . get Absolute Path ( ) ) ; process Helper . exec ( _ STR , rm Cmd ) ; }
private void append Container Config (  Docker Slave Template slave Template ,  Create Container Cmd container Config ) {  Map <  String ,  String > labels = container Config . get Labels ( ) ; if ( labels == null ) { labels = new  Hash Map < > ( ) ; } labels . put (  DOCKER_ CLOUD_ LABEL , get Display Name ( ) ) ; labels . put (  DOCKER_ TEMPLATE_ LABEL , slave Template . get Id ( ) ) ; container Config . with Labels ( labels ) ; }
Read Only Game Settings ( ) { }
public void remove Region (  Region r ) { regions . remove ( r ) ; }
public static void silent Close Input Stream (  Input Stream is ) { try { if ( is != null ) { is . close ( ) ; } } catch (  IOException e ) { log . w (  LOG_ TAG , _ STR , e ) ; } }
@  Override public void start Element (  String uri ,  String local Name ,  String q Name ,  Attributes attributes ) throws  SAXException { if ( request ID == null && local Name . equals ( _ STR ) ) { request ID = attributes . get Value ( _ STR ) ; } super . start Element ( uri , local Name , q Name , attributes ) ; }
public void stop ( int timeout ) throws  Interrupted Exception { if ( ! isclosed . compare And Set ( _ BOOL , _ BOOL ) ) { return ; }  List <  Web Socket > sockets To Close = null ; synchronized ( connections ) { sockets To Close = new  Array List <  Web Socket > ( connections ) ; } for (  Web Socket ws : sockets To Close ) { ws . close (  Close Frame .  GOING_ AWAY ) ; } synchronized ( this ) { if ( selectorthread != null ) { if (  Thread . current Thread ( ) != selectorthread ) { } if ( selectorthread !=  Thread . current Thread ( ) ) { if ( sockets To Close . size ( ) > _ NUM ) selectorthread . join ( timeout ) ; selectorthread . interrupt ( ) ; selectorthread . join ( ) ; } } } }
public  Storage ( ) { this ( new  File ( get Temporary Storage Directory String ( ) ) ) ; }
protected void calculate Item Width (  Category Plot plot ,  Rectangle2 D data Area , int renderer Index ,  Category Item Renderer State state ) {  Category Axis domain Axis = get Domain Axis ( plot , renderer Index ) ;  Category Dataset dataset = plot . get Dataset ( renderer Index ) ; if ( dataset != null ) { int columns = dataset . get Column Count ( ) ; int rows = state . get Visible Series Count ( ) >= _ NUM ? state . get Visible Series Count ( ) : dataset . get Row Count ( ) ; double space = _ NUM ;  Plot Orientation orientation = plot . get Orientation ( ) ; if ( orientation ==  Plot Orientation .  HORIZONTAL ) { space = data Area . get Height ( ) ; } else if ( orientation ==  Plot Orientation .  VERTICAL ) { space = data Area . get Width ( ) ; } double max Width = space * get Maximum Item Width ( ) ; double category Margin = _ NUM ; double current Item Margin = _ NUM ; if ( columns > _ NUM ) { category Margin = domain Axis . get Category Margin ( ) ; } if ( rows > _ NUM ) { current Item Margin = get Item Margin ( ) ; } double used = space * ( _ NUM - domain Axis . get Lower Margin ( ) - domain Axis . get Upper Margin ( ) - category Margin - current Item Margin ) ; if ( ( rows * columns ) > _ NUM ) { state . set Bar Width (  Math . min ( used / ( rows * columns ) , max Width ) ) ; } else { state . set Bar Width (  Math . min ( used , max Width ) ) ; } } }
@  Requires Permission (  Manifest . permission .  CAMERA ) public  Camera Source start ( ) throws  IOException { synchronized ( m Camera Lock ) { if ( m Camera != null ) { return this ; } m Camera = create Camera ( ) ; if (  Build .  VERSION .  SDK_ INT >=  Build .  VERSION_ CODES .  HONEYCOMB ) { m Dummy Surface Texture = new  Surface Texture (  DUMMY_ TEXTURE_ NAME ) ; m Camera . set Preview Texture ( m Dummy Surface Texture ) ; } else { m Dummy Surface View = new  Surface View ( m Context ) ; m Camera . set Preview Display ( m Dummy Surface View . get Holder ( ) ) ; } m Camera . start Preview ( ) ; is Safe To Take Picture = _ BOOL ; m Processing Thread = new  Thread ( m Frame Processor ) ; m Frame Processor . set Active ( _ BOOL ) ; m Processing Thread . start ( ) ; } return this ; }
public void add Breakpoint Listener ( final  Breakpoint Listener listener ) { breakpoint Listeners . add ( listener ) ; }
public void update (  Graphics g ) { if ( is Showing ( ) ) { if ( ! ( peer instanceof  Lightweight Peer ) ) { g . clear Rect ( _ NUM , _ NUM , width , height ) ; } paint ( g ) ; } }
public static void print Stack Trace (  Throwable e ) { try {  Debug . print Stack Trace ( e ) ; } catch (  Throwable f ) { e . print Stack Trace ( ) ; } }
@  Override public  Void visit Type (  Type Element e ,  Void p ) { scan ( e . get Type Parameters ( ) , p ) ; check Camel Case ( e , _ BOOL ) ; super . visit Type ( e , p ) ; return null ; }
public  Block ( boolean multi Push ) { this ( multi Push , _ STR , null ,  Arrays . as List ( _ STR , _ STR ) ) ; }
private double  Poisson ( double x ) { return  Math . exp ( - m_ Lambda + ( x *  Math . log ( m_ Lambda ) ) - log Fac ( x ) ) ; }
protected  Expression find Expression (  String source ) { if ( source != null && source . length ( ) > _ NUM ) { source = source . trim ( ) ; if ( source . length ( ) == _ NUM ) { return null ; }  String left Side = source ;  String right Side = null ;  Connector op = find Op ( left Side ) ; if ( op != null ) { right Side = op . get Right Side ( left Side ) ; left Side = left Side . substring ( _ NUM , op . source Loc ) ;  Expression left Expression = find Expression ( left Side ) ;  Expression right Expression = find Expression ( right Side ) ; if ( left Expression != null ) { op . add Expr ( left Expression ) ; } if ( right Expression != null ) { op . add Expr ( right Expression ) ; } return op ; } op = find Mini Op ( left Side ) ; if ( op != null ) { right Side = op . get Right Side ( left Side ) ; left Side = left Side . substring ( _ NUM , op . source Loc ) ;  Expression left Expression = find Expression ( left Side ) ;  Expression right Expression = find Expression ( right Side ) ; if ( left Expression != null ) { op . add Expr ( left Expression ) ; } if ( right Expression != null ) { op . add Expr ( right Expression ) ; } return op ; } if ( logger . is Loggable (  Level .  FINER ) ) { logger . finer ( _ STR + source ) ; } return find Math Op ( source ) ; } return null ; }
void put Channel ( final  Stored Client Channel channel ) { put Channel ( channel , _ BOOL ) ; }
@  Suppress Warnings ( _ STR ) public static void pipe Input To Output Stream (  Input Stream in ,  File file Out , boolean ignore Errors ) throws  IOException { if ( file Out == null ) { logger . error ( _ STR ) ; if ( ! ignore Errors ) { throw new  IOException ( _ STR ) ; } } else {  File parent = file Out . get Parent File ( ) ; if ( parent != null && ! parent . exists ( ) ) { parent . mkdirs ( ) ; }  Output Stream file Stream = null ; try { file Stream = new  File Output Stream ( file Out ) ; pipe Input To Output Stream ( in , file Stream , _ BOOL , ignore Errors ) ; } catch (  IOException e ) { if ( file Stream != null ) { try { file Stream . close ( ) ; } catch (  IOException ex ) { logger . error ( _ STR , ex . get Message ( ) ) ; } } if ( ! ignore Errors ) { throw e ; } } } }
public  E take ( ) throws  Interrupted Exception { final  Reentrant Lock lock = this . lock ; lock . lock Interruptibly ( ) ; long t = now ( ) ;  Tenant Queue .  Item item = null ; try { for ( ; ; ) {  Tenant Queue q = next Queue ( t ) ; if ( q == null ) available . await ( ) ; else { long delay = q . next - t ; if ( delay <= _ NUM ) { item = q . poll ( t ) ; return item == null ? null : item . element ; } else if ( leader != null ) available . await ( ) ; else {  Thread this Thread =  Thread . current Thread ( ) ; leader = this Thread ; try { available . await Nanos ( delay ) ; } finally { if ( leader == this Thread ) leader = null ; } } } t =  System . nano Time ( ) ; } } finally { if ( leader == null && has Next ( ) ) available . signal ( ) ; lock . unlock ( ) ; done ( item , t ) ; } }
public boolean thread Safe Timeout ( long delay Time ,  Time Unit unit ,  Action0 action ) { boolean scheduled = _ BOOL ;  Thread current Thread =  Thread . current Thread ( ) ; if ( current Thread . equals ( duty Thread ) ) { timer Wheel . new Timeout ( delay Time , unit , null ) ; } else { scheduled = actions . offer ( null ) ; } return scheduled ; }
void add Attribute Selection (  String exp ) { int index = exp . index Of ( _ STR ) ;  String value = null ; int constraint =  Att String .  EQUALS ; if ( index != - _ NUM ) { if ( index == _ NUM ) { set Tag Id (  TAG_ CSS_ ILLEGAL_ SELECTOR ) ; return ; } int op Index = index ; char c = exp . char At ( index - _ NUM ) ; if ( c == _ STR ) { constraint =  Att String .  CONTAINS_ WORD ; op Index -- ; } else if ( c == _ STR ) { constraint =  Att String .  BEGINS_ WITH ; op Index -- ; } value = exp . substring ( index + _ NUM ) ; if ( ( ( value . starts With ( _ STR ) ) && ( value . ends With ( _ STR ) ) ) || ( ( value . starts With ( _ STR ) ) && ( value . ends With ( _ STR ) ) ) ) { value = value . substring ( _ NUM , value . length ( ) - _ NUM ) ; } exp = exp . substring ( _ NUM , op Index ) ; } if ( attribute Selections == null ) { attribute Selections = new  Vector ( ) ; } attribute Selections . add Element ( new  Att String ( exp , constraint , value ) ) ; }
public  Value sample ( ) { int index = sampler . next Int ( action Values . size ( ) ) ; if ( action Values As Array == null ) { action Values As Array = action Values . to Array ( new  Value [ action Values . size ( ) ] ) ; } return action Values As Array [ index ] ; }
@  Override public void channel Closed (  Channel Handler Context channel Handler Context ,  Channel State Event channel State Event ) throws  Exception { curr_conns . decrement And Get ( ) ; channel Group . remove ( channel Handler Context . get Channel ( ) ) ; }
private static void configure Head Less Simulation ( ) {  System . set Property ( _ STR , _ STR ) ;  GAMA . set Head Less Mode ( ) ; }
public static boolean is Next Window (  URI id ) { return id == null ||  NEXT . equals ( id ) ; }
public byte [ ] remove (  Queue Event event ) throws  Keeper Exception ,  Interrupted Exception {  Timer Context time = stats . time ( dir + _ STR ) ; try {  String path = event . get Id ( ) ;  String response Path = dir + _ STR + response_prefix + path . substring ( path . last Index Of ( _ STR ) + _ NUM ) ; if ( zookeeper . exists ( response Path , _ BOOL ) ) { zookeeper . set Data ( response Path , event . get Bytes ( ) , _ BOOL ) ; } byte [ ] data = zookeeper . get Data ( path , null , null , _ BOOL ) ; zookeeper . delete ( path , - _ NUM , _ BOOL ) ; return data ; } finally { time . stop ( ) ; } }
public  Property XMLBuilder (  Service Schema service Schema ,  AMModel model ,  Set attribute Schemas ) throws  SMSException ,  SSOException { this . model = model ; this . service Name = service Schema . get Service Name ( ) ; get Service Resource Bundle ( service Schema ) ; if ( service Bundle != null ) { map Type To Attribute Schema = new  Hash Map ( attribute Schemas . size ( ) * _ NUM ) ; map Type To Attribute Schema . put (  NULL_ TYPE , attribute Schemas ) ; } }
public boolean is (  String arg , boolean allow Abbr ) { if ( name . equals Ignore Case ( arg ) ) { return _ BOOL ; } if ( allow Abbr && arg . length ( ) == _ NUM ) { if ( arg . char At ( _ NUM ) == c ) { return _ BOOL ; } } return _ BOOL ; }
static public void add All (  List <  String > list ,  String [ ] array ) { for (  String item : array ) list . add ( item ) ; }
void remove (  Super Card Toast super Card Toast ) { m List . remove ( super Card Toast ) ; }
public void test_vmstat_header_and_data_parse ( ) { final  Pattern pattern =  VMStat Collector . pattern ; final  String header = _ STR ; final  String data = _ STR ; { final  String [ ] fields = pattern . split ( header . trim ( ) , _ NUM ) ; for ( int i = _ NUM ; i < fields . length ; i ++ ) { if ( log . is Info Enabled ( ) ) log . info ( _ STR + i + _ STR + fields [ i ] + _ STR ) ; } assert Field ( header , fields , _ NUM , _ STR ) ; assert Field ( header , fields , _ NUM , _ STR ) ; assert Field ( header , fields , _ NUM , _ STR ) ; assert Field ( header , fields , _ NUM , _ STR ) ; assert Field ( header , fields , _ NUM , _ STR ) ; assert Field ( header , fields , _ NUM , _ STR ) ; assert Field ( header , fields , _ NUM , _ STR ) ; assert Field ( header , fields , _ NUM , _ STR ) ; } { final  String [ ] fields = pattern . split ( data . trim ( ) , _ NUM ) ; assert Field ( data , fields , _ NUM , _ STR ) ; assert Field ( data , fields , _ NUM , _ STR ) ; assert Field ( data , fields , _ NUM , _ STR ) ; assert Field ( data , fields , _ NUM , _ STR ) ; assert Field ( data , fields , _ NUM , _ STR ) ; assert Field ( data , fields , _ NUM , _ STR ) ; assert Field ( data , fields , _ NUM , _ STR ) ; assert Field ( data , fields , _ NUM , _ STR ) ; } }
private  String partially Escape Assertion Value (  String assertion Value ) {  String Builder sb = new  String Builder ( assertion Value . length ( ) ) ; for ( int j = _ NUM ; j < assertion Value . length ( ) ; j ++ ) { char c = assertion Value . char At ( j ) ; if ( c == _ STR ) { sb . append ( c ) ; } else { sb . append (  Filter . escape Assertion Value (  String . value Of ( c ) ) ) ; } } return sb . to String ( ) ; }
@  Override public void step (  Message Logger logger ) { try { add Agent ( ) ; env . step ( ) ; } catch (  Exception e ) { e . print Stack Trace ( ) ; } }
public static  Attack Status calculate Physical Status (  Creature attacker ,  Creature attacked , boolean is Main Hand ) { return calculate Physical Status ( attacker , attacked , is Main Hand , _ NUM , _ NUM , _ BOOL , _ BOOL ) ; }
public  T vertex Processor ( final  Bi Consumer <  Vertex ,  Map <  String ,  Object > > vertex Processor ) { this . vertex Processor =  Optional . of Nullable ( vertex Processor ) ; return extending Class . cast ( this ) ; }
synchronized boolean release ( ) { d ( _ STR ) ; if ( state ==  BUSY ) { state =  IDLE ; idle Since =  System . current Time Millis ( ) ; return _ BOOL ; } else { return _ BOOL ; } }
private void validate Replica Availability (  Slice slice ,  String shard ,  String collection Name , int count ) { if ( slice != null ) {  Collection <  Replica > all Replicas For Shard = slice . get Replicas ( ) ; if ( all Replicas For Shard == null ) { throw new  Solr Exception (  Solr Exception .  Error Code .  BAD_ REQUEST , _ STR + shard + _ STR + collection Name ) ; } if ( all Replicas For Shard . size ( ) == _ NUM ) { throw new  Solr Exception (  Solr Exception .  Error Code .  BAD_ REQUEST , _ STR + shard + _ STR + collection Name + _ STR ) ; } if ( all Replicas For Shard . size ( ) <= count ) { throw new  Solr Exception (  Solr Exception .  Error Code .  BAD_ REQUEST , _ STR + shard + _ STR + collection Name + _ STR + count + _ STR + all Replicas For Shard . size ( ) + _ STR ) ; } } }
default  Class Declaration as Class ( ) { throw new  Unsupported Operation Exception (  String . format ( _ STR , this ) ) ; }
private static  String partition Spec To Name (  Map <  String ,  String > spec ) {  String Builder sb = new  String Builder ( ) ; for (  Map .  Entry <  String ,  String > entry : spec . entry Set ( ) ) { if ( sb . length ( ) != _ NUM ) { sb . append ( _ STR ) ; } sb . append ( entry . get Key ( ) + _ STR + entry . get Value ( ) ) ; } return sb . to String ( ) ; }
@  Modifying @  Transactional public void delete Cheque ( @  Path Variable  Long cheque ID ) { cheque Repository . delete ( cheque ID ) ; photo Repository . delete By Cheque Id ( cheque ID . to String ( ) ) ; }
public static synchronized double partial Correlation (  Tetrad Matrix submatrix ) { try {  Tetrad Matrix inverse = submatrix . inverse ( ) ; double a = - _ NUM * inverse . get ( _ NUM , _ NUM ) ; double v0 = inverse . get ( _ NUM , _ NUM ) ; double v1 = inverse . get ( _ NUM , _ NUM ) ; double b =  Math . sqrt ( v0 * v1 ) ; return a / b ; } catch (  Exception e ) { e . print Stack Trace ( ) ; return  Double .  Na N ; } }
public void add Column (  String name ,  String expr ) {  Expression ex =  Expression Parser . parse ( expr ) ;  Throwable t =  Expression Parser . get Error ( ) ; if ( t != null ) { throw new  Runtime Exception ( t ) ; } else { add Column ( name , ex ) ; } }
public void add Put And Get Time Nanos ( long duration ) { put Time Nanos . add And Get ( duration ) ; get Time Nanos . add And Get ( duration ) ; if ( delegate != null ) delegate . add Put And Get Time Nanos ( duration ) ; }
private float check Saturation Valid ( final float val ) { float tempval = val ; if ( val > _ NUM ) { tempval = _ NUM ; } if ( val < _ NUM ) { tempval = _ NUM ; } return tempval ; }
String parse (  String cell Str , int layout Constant ) { return cell Str . split (  Layout Constants .  CELL_ PTRN ) [ layout Constant ] ; }
public void pseudo Property Change (  String prop Name ,  Object old ,  Object n ) { if ( log . is Debug Enabled ( ) ) { log . debug ( _ STR + get System Name ( ) + _ STR + prop Name + _ STR + n . to String ( ) ) ; } fire Property Change ( prop Name , old , n ) ; }
public static  String run Cmd (  File directory ,  List <  String > cmd ,  String error Message ) throws  Exception {  Process Builder pb = new  Process Builder ( cmd ) ; pb . directory ( directory ) ; pb . redirect Error Stream ( _ BOOL ) ;  Process p = pb . start ( ) ;  String s ;  String Builder sb = new  String Builder ( ) ;  Buffered Reader stdout = new  Buffered Reader ( new  Input Stream Reader ( p . get Input Stream ( ) ) ) ; while ( ( s = stdout . read Line ( ) ) != null ) { logger . info ( s ) ; sb . append ( s ) ; sb . append ( _ STR ) ; }  String sbs = sb . to String ( ) ; int exit Value = p . wait For ( ) ; if ( exit Value != _ NUM ) throw new  Exception ( error Message + _ STR + exit Value + _ STR + sbs ) ; return sbs ; }
@  Override public  Selectable Channel selectable Channel ( ) { return socket Channel ; }
public static  String from Tag (  Byte Array Tag tag ) {  String Builder builder = new  String Builder ( ) ; builder . append (  ARRAY_ START ) ; boolean start = _ BOOL ; for ( byte value : tag . get Value ( ) ) {  Byte Tag b = new  Byte Tag ( value ) ; if ( start ) { start = _ BOOL ; } else { builder . append (  ELEMENT_ SEPERATOR ) ; } builder . append ( from Tag ( b ) ) ; } builder . append (  ARRAY_ END ) ; return builder . to String ( ) ; }
@  Override protected void add Chooser Filters (  JFile Chooser chooser ) { javax . swing . filechooser .  File Name Extension Filter filter = new javax . swing . filechooser .  File Name Extension Filter (  Bundle . get Message ( _ STR , _ STR ) , _ STR , _ STR ) ; chooser . add Choosable File Filter ( new javax . swing . filechooser .  File Name Extension Filter ( _ STR , _ STR ) ) ; chooser . add Choosable File Filter ( new javax . swing . filechooser .  File Name Extension Filter ( _ STR , _ STR ) ) ; chooser . add Choosable File Filter ( filter ) ; chooser . set File Filter ( filter ) ; }
private static byte [ ]  Windows Reg Enum Value1 ( int h Key , int value Index , int max Value Name Length ) { byte [ ] result =  Windows Reg Enum Value ( h Key , value Index , max Value Name Length ) ; if ( result != null ) { return result ; } else { long sleep Time =  INIT_ SLEEP_ TIME ; for ( int i = _ NUM ; i <  MAX_ ATTEMPTS ; i ++ ) { try {  Thread . sleep ( sleep Time ) ; } catch (  Interrupted Exception e ) { return result ; } sleep Time *= _ NUM ; result =  Windows Reg Enum Value ( h Key , value Index , max Value Name Length ) ; if ( result != null ) { return result ; } } } return result ; }
public static  Date Time parse Rfc822 (  String str ) throws  Parse Exception {  Date date ; synchronized ( date Time Format822 ) { try { date = date Time Format822 . parse ( str ) ; } catch ( java . text .  Parse Exception e ) { throw new  Parse Exception ( e ) ; } } return new  Date Time ( date ) ; }
public void test Empty Index ( ) throws  Exception {  Index Searcher empty = new Searcher ( new  Multi Reader ( ) ) ;  Query query = new  Term Query ( new  Term ( _ STR , _ STR ) ) ;  Sort sort = new  Sort ( ) ;  Top Docs td = empty . search ( query , _ NUM , sort , _ BOOL , _ BOOL ) ; assert Equals ( _ NUM , td . total Hits ) ; sort . set Sort (  Sort Field .  FIELD_ DOC ) ; td = empty . search ( query , _ NUM , sort , _ BOOL , _ BOOL ) ; assert Equals ( _ NUM , td . total Hits ) ; sort . set Sort ( new  Sort Field ( _ STR ,  Sort Field .  Type .  INT ) ,  Sort Field .  FIELD_ DOC ) ; td = empty . search ( query , _ NUM , sort , _ BOOL , _ BOOL ) ; assert Equals ( _ NUM , td . total Hits ) ; sort . set Sort ( new  Sort Field ( _ STR ,  Sort Field .  Type .  STRING , _ BOOL ) ,  Sort Field .  FIELD_ DOC ) ; td = empty . search ( query , _ NUM , sort , _ BOOL , _ BOOL ) ; assert Equals ( _ NUM , td . total Hits ) ; sort . set Sort ( new  Sort Field ( _ STR ,  Sort Field .  Type .  STRING_ VAL , _ BOOL ) ,  Sort Field .  FIELD_ DOC ) ; td = empty . search ( query , _ NUM , sort , _ BOOL , _ BOOL ) ; assert Equals ( _ NUM , td . total Hits ) ; sort . set Sort ( new  Sort Field ( _ STR ,  Sort Field .  Type .  FLOAT ) , new  Sort Field ( _ STR ,  Sort Field .  Type .  STRING ) ) ; td = empty . search ( query , _ NUM , sort , _ BOOL , _ BOOL ) ; assert Equals ( _ NUM , td . total Hits ) ; }
public  Model validate Model (  Dataset dataset ,  URI shapes Graph URI ,  Resource min Severity , boolean validate Shapes ,  Function <  RDFNode ,  String > label Function ,  Progress Monitor monitor ) throws  Interrupted Exception { if ( dataset . get Default Model ( ) == null ) { throw new  Illegal Argument Exception ( _ STR ) ; }  Model shapes Model = dataset . get Named Model ( shapes Graph URI . to String ( ) ) ; if ( monitor != null ) { monitor . sub Task ( _ STR ) ; }  List <  Property > constraint Properties =  SHACLUtil . get All Constraint Properties ( validate Shapes ) ;  Map <  Resource ,  List <  SHConstraint > > map = build Shape2 Constraints Map ( shapes Model , dataset . get Default Model ( ) , constraint Properties , validate Shapes ) ; if ( monitor != null ) { monitor . sub Task ( _ STR ) ; } if ( monitor != null ) { monitor . begin Task ( _ STR + map . size ( ) + _ STR , map . size ( ) ) ; }  Model results =  Jena Util . create Memory Model ( ) ; results . set Ns Prefixes ( dataset . get Default Model ( ) ) ; for (  Resource shape : map . key Set ( ) ) { for (  SHConstraint constraint : map . get ( shape ) ) { validate Constraint For Shape ( dataset , shapes Graph URI , min Severity , constraint , shape , results , label Function , monitor ) ; if ( monitor != null ) { monitor . worked ( _ NUM ) ; if ( monitor . is Canceled ( ) ) { throw new  Interrupted Exception ( ) ; } } } } return results ; }
public  Pdf Page add Annotation (  Pdf Annotation annotation ) { return add Annotation ( - _ NUM , annotation , _ BOOL ) ; }
public static  String find Preferred IDP (  String realm ,  Http Servlet Request request ) { if ( request == null ) { return null ; }  String succinct ID = request . get Parameter (  IFSConstants .  PROVIDER_ ID_ KEY ) ; if ( ( succinct ID == null ) || succinct ID . length ( ) == _ NUM ) { debug . message ( _ STR ) ; return null ; } succinct ID = succinct ID . trim ( ) ;  String preferred Succinct Id = null ;  String Tokenizer st = new  String Tokenizer ( succinct ID , _ STR ) ; while ( st . has More Tokens ( ) ) { preferred Succinct Id = st . next Token ( ) ; if ( ( preferred Succinct Id . length ( ) < _ NUM ) && st . has More Tokens ( ) ) { preferred Succinct Id = preferred Succinct Id + _ STR + st . next Token ( ) ; } } preferred Succinct Id =  SAMLUtils . byte Array To String (  Base64 . decode ( preferred Succinct Id ) ) ; return get Provider IDFrom Succinct ID ( realm , preferred Succinct Id ) ; }
private void check And Create Directory ( final  String directory Name ) { try { final  File dir = new  File ( directory Name ) ; if ( ! dir . exists ( ) && dir . mkdirs ( ) ) { _logger . debug ( _ STR ) ; } } catch (  Exception ex ) { _logger . error ( _ STR , ex . get Message ( ) ) ; } }
public int find Event Position Nearest Time (  Time time , long id ) { if ( m Row Info == null ) { return _ NUM ; } long millis = time . to Millis ( _ BOOL ) ; long min Distance =  Integer .  MAX_ VALUE ; long id Found Min Distance =  Integer .  MAX_ VALUE ; int min Index = _ NUM ; int id Found Min Index = _ NUM ; int event In Time Index = - _ NUM ; int all Day Event In Time Index = - _ NUM ; int all Day Event Day = _ NUM ; int min Day = _ NUM ; boolean id Found = _ BOOL ; int len = m Row Info . size ( ) ; for ( int index = _ NUM ; index < len ; index ++ ) {  Row Info row = m Row Info . get ( index ) ; if ( row . m Type ==  TYPE_ DAY ) { continue ; } if ( row . m Event Id == id ) { if ( row . m Event Start Time Milli == millis ) { return index ; } long distance =  Math . abs ( millis - row . m Event Start Time Milli ) ; if ( distance < id Found Min Distance ) { id Found Min Distance = distance ; id Found Min Index = index ; } id Found = _ BOOL ; } if ( ! id Found ) { if ( millis >= row . m Event Start Time Milli && millis <= row . m Event End Time Milli ) { if ( row . m All Day ) { if ( all Day Event In Time Index == - _ NUM ) { all Day Event In Time Index = index ; all Day Event Day = row . m Day ; } } else if ( event In Time Index == - _ NUM ) { event In Time Index = index ; } } else if ( event In Time Index == - _ NUM ) { long distance =  Math . abs ( millis - row . m Event Start Time Milli ) ; if ( distance < min Distance ) { min Distance = distance ; min Index = index ; min Day = row . m Day ; } } } } if ( id Found ) { return id Found Min Index ; } if ( event In Time Index != - _ NUM ) { return event In Time Index ; } else if ( all Day Event In Time Index != - _ NUM && min Day != all Day Event Day ) { return all Day Event In Time Index ; } return min Index ; }
final public void println ( float v ) {  String s =  String . value Of ( v ) ; write ( s , _ NUM , s . length ( ) ) ; println ( ) ; }
private static  Translation Result extract Register ( final  ITranslation Environment environment , final long offset , final  String sub Register ) throws  Internal Translation Exception { final  Array List <  Reil Instruction > instructions = new  Array List <  Reil Instruction > ( ) ; final  String parent Register = get Parent Register ( sub Register ) ; final  Operand Size arch Size = environment . get Architecture Size ( ) ; if ( is Higher8 Bit Register ( sub Register ) ) { final  String mask Result = environment . get Next Variable String ( ) ; final  String shift Result = environment . get Next Variable String ( ) ; instructions . add (  Reil Helpers . create And ( offset , arch Size , parent Register ,  Operand Size .  WORD , _ STR ,  Operand Size .  WORD , mask Result ) ) ; instructions . add (  Reil Helpers . create Bsh ( offset + _ NUM ,  Operand Size .  WORD , mask Result ,  Operand Size .  WORD , _ STR ,  Operand Size .  BYTE , shift Result ) ) ; return new  Translation Result ( shift Result ,  Operand Size .  BYTE ,  Translation Result Type .  REGISTER , null , instructions , offset ) ; } else { final  Operand Size sub Register Size = get Register Size ( sub Register ) ; final  String mask =  String . value Of (  Translation Helpers . get All Bits Mask ( sub Register Size ) ) ; final  String result = environment . get Next Variable String ( ) ; instructions . add (  Reil Helpers . create And ( offset , arch Size , parent Register , sub Register Size , mask , sub Register Size , result ) ) ; return new  Translation Result ( result , sub Register Size ,  Translation Result Type .  REGISTER , null , instructions , offset ) ; } }
public  Interceptor [ ] build Method Interceptors (  Method method ) {  Interceptors before = method . get Annotation (  Interceptors . class ) ; return before != null ? create Interceptors ( before ) :  NULL_ INTERCEPTOR_ ARRAY ; }
protected  String build Qualifier Regex (  String qualifier Value ) {  String Builder sb = new  String Builder ( ) ; sb . append ( _ STR ) ; sb . append ( qualifier Value ) ; sb . append ( _ STR ) ; return sb . to String ( ) ; }
private static void look For Changes (  Data Object left ,  Data Object right ,  Hash Map <  String ,  Change > changes ,  Set <  String > included ,  Set <  String > excluded ,  Set <  String > contained ) {  Class ref Class = left . get Class ( ) ;  Method [ ] methods = ref Class . get Methods ( ) ; for (  Method method : methods ) { boolean contain = _ BOOL ;  Name name Ann = method . get Annotation (  Name . class ) ; if ( name Ann == null ) { continue ; }  String key = name Ann . value ( ) ; if ( contained != null && contained . contains ( key ) ) { contain = _ BOOL ; } else if ( included != null && ! included . contains ( key ) ) { continue ; } if ( excluded . contains ( key ) ) { continue ; }  Class type = method . get Return Type ( ) ; try {  Object obja = method . invoke ( left ) ;  Object objb = method . invoke ( right ) ; if ( type ==  String Set . class ) { if ( contain ) { analyze New String Set Contains Old String Set Values ( (  String Set ) obja , (  String Set ) objb , key , changes ) ; } else { analyze String Sets ( (  String Set ) obja , (  String Set ) objb , key , changes ) ; } } else if ( type ==  String Map . class ) { analyze String Maps ( (  String Map ) obja , (  String Map ) objb , key , changes ) ; } else if ( type ==  String Set Map . class ) { analyze String Set Maps ( (  String Set Map ) obja , (  String Set Map ) objb , key , changes ) ; } else { if ( ! is Equal ( obja , objb ) ) {  Change change = new  Change ( key , obja , objb , name Ann . value ( ) ) ; changes . put ( key , change ) ; } } } catch (  Illegal Access Exception ex ) { throw new  Service Code Exception (  Service Code .  UNFORSEEN_ ERROR , ex , ex . get Message ( ) , new  String [ ] { } ) ; } catch (  Invocation Target Exception ex ) { throw new  Service Code Exception (  Service Code .  UNFORSEEN_ ERROR , ex , ex . get Message ( ) , new  String [ ] { } ) ; } } }
static void remove All Phis (  IR ir ) { for (  Instruction s = ir . first Instruction In Code Order ( ) , sentinel = ir . last Instruction In Code Order ( ) , next Instr = null ; s != sentinel ; s = next Instr ) { next Instr = s . next Instruction In Code Order ( ) ; if (  Phi . conforms ( s ) ) s . remove ( ) ; } }
private  Map <  Test Case ,  Set <  Test Fitness Function > > initialize Coverage Map From Tests (  List <  Test Case > tests ) {  Map <  Test Case ,  Set <  Test Fitness Function > > test To Goals = new  Linked Hash Map < > ( ) ; for (  Test Case test : tests ) { test To Goals . put ( test , filter Supported Goals ( new  Linked Hash Set < > ( test . get Covered Goals ( ) ) ) ) ; } return test To Goals ; }
public  Interceptor [ ] build Route Interceptors (  Interceptor [ ] default Inters ,  Interceptor [ ] resource Inters ,  Class < ? extends  Resource > resource Class ,  Interceptor [ ] method Inters ,  Method method ) {  List <  Interceptor > all Inters = new  Array List <  Interceptor > ( ) ; for (  Interceptor default Inter : default Inters ) { all Inters . add ( default Inter ) ; } for (  Interceptor resource Inter : resource Inters ) { all Inters . add ( resource Inter ) ; } for (  Interceptor method Inter : method Inters ) { all Inters . add ( method Inter ) ; }  Class < ? extends  Interceptor > [ ] resource Clears = get Resource Clears ( resource Class ) ;  Class < ? extends  Interceptor > [ ] method Clears = get Method Clears ( method ) ; if ( ( resource Clears != null && resource Clears . length > _ NUM ) || ( method Clears != null && method Clears . length > _ NUM ) ) { for ( int i = _ NUM ; i < all Inters . size ( ) ; i ++ ) { i = clear Interceptor ( all Inters , resource Clears , i ) ; i = clear Interceptor ( all Inters , method Clears , i ) ; } } return all Inters . to Array ( new  Interceptor [ all Inters . size ( ) ] ) ; }
public static boolean check GMLFootprint (  String footprint ) { try {  Configuration configuration = new  GMLConfiguration ( ) ;  Parser parser = new  Parser ( configuration ) ;  Geometry geom = (  Geometry ) parser . parse ( new  Input Source ( new  String Reader ( footprint ) ) ) ; if ( ! geom . is Empty ( ) && ! geom . is Valid ( ) ) { logger . error ( _ STR ) ; return _ BOOL ; } } catch (  Exception e ) { logger . error ( _ STR + e . get Message ( ) ) ; return _ BOOL ; } return _ BOOL ; }
public static double quantile ( double p , double k , double theta , double shift ) { return  Math . exp (  Gamma Distribution . quantile ( p , k , theta ) ) + shift ; }
public  Orion Editor Init ( final  Text Editor Configuration configuration , final  Code Assistant Factory code Assistant Factory , final  Quick Assist Assistant quick Assist , final  Orion Editor Presenter text Editor ) { this . configuration = configuration ; this . code Assistant Factory = code Assistant Factory ; this . quick Assist = quick Assist ; this . text Editor = text Editor ; }
final void put Byte ( int offset , byte value ) { unsafe . put Byte ( offset + address , value ) ; }
public final void add Validation Error (  String error ) { validation Errors . add ( error ) ; }
public static void parse Option Setting To (  String option Setting ,  Map <  String ,  String > dst ) { int eq Index = option Setting . index Of ( _ STR ) ; if ( eq Index == - _ NUM ) { throw new  Internal Error ( _ STR + option Setting ) ; } dst . put ( option Setting . substring ( _ NUM , eq Index ) , option Setting . substring ( eq Index + _ NUM ) ) ; }
public  Big Integer generate Client Credentials ( byte [ ] salt , byte [ ] identity , byte [ ] password ) { this . x =  SRP6 Util . calculate X ( digest ,  N , salt , identity , password ) ; this . a = select Private Value ( ) ; this .  A = g . mod Pow ( a ,  N ) ; return  A ; }
public void build (  Solr Core core ,  Solr Index Searcher searcher ) throws  IOException {  LOG . info ( _ STR + name + _ STR ) ; dictionary = dictionary Factory . create ( core , searcher ) ; lookup . build ( dictionary ) ; if ( store Dir != null ) {  File target = get Store File ( ) ; if ( ! lookup . store ( new  File Output Stream ( target ) ) ) {  LOG . error ( _ STR ) ; } else {  LOG . info ( _ STR + target . get Absolute Path ( ) ) ; } } }
public void start (  String json ) { guided Tour Steps . clear ( ) ;  Guided Tour Configuration configuration = dto Factory . create Dto From Json ( json ,  Guided Tour Configuration . class ) ; log . set Debug Mode ( configuration . get Debug Mode ( ) ) ; this . guided Tour Steps = configuration . get Steps ( ) ; this . tour Name = configuration . get Name ( ) ; if ( this . tour Name == null || tour Name . is Empty ( ) ) { tour Name = _ STR ; } this . has Welcome Step = configuration . get Has Welcome Step ( ) ; start Tour ( ) ; }
private void connect ( ) throws  IOException {  JMXService URL jmx Url = new  JMXService URL (  String . format ( fmt Url , host , port ) ) ;  Map <  String ,  Object > env = new  Hash Map <  String ,  Object > ( ) ; if ( username != null ) {  String [ ] creds = { username , password } ; env . put (  JMXConnector .  CREDENTIALS , creds ) ; } env . put ( _ STR , get RMIClient Socket Factory ( ) ) ; jmxc =  JMXConnector Factory . connect ( jmx Url , env ) ; mbean Server Conn = jmxc . get MBean Server Connection ( ) ; try {  Object Name name = new  Object Name ( ss Obj Name ) ; ss Proxy =  JMX . new MBean Proxy ( mbean Server Conn , name ,  Storage Service MBean . class ) ; name = new  Object Name (  Messaging Service .  MBEAN_ NAME ) ; ms Proxy =  JMX . new MBean Proxy ( mbean Server Conn , name ,  Messaging Service MBean . class ) ; name = new  Object Name (  Stream Manager MBean .  OBJECT_ NAME ) ; stream Proxy =  JMX . new MBean Proxy ( mbean Server Conn , name ,  Stream Manager MBean . class ) ; name = new  Object Name (  Compaction Manager .  MBEAN_ OBJECT_ NAME ) ; compaction Proxy =  JMX . new MBean Proxy ( mbean Server Conn , name ,  Compaction Manager MBean . class ) ; name = new  Object Name (  Failure Detector .  MBEAN_ NAME ) ; fd Proxy =  JMX . new MBean Proxy ( mbean Server Conn , name ,  Failure Detector MBean . class ) ; name = new  Object Name (  Cache Service .  MBEAN_ NAME ) ; cache Service =  JMX . new MBean Proxy ( mbean Server Conn , name ,  Cache Service MBean . class ) ; name = new  Object Name (  Storage Proxy .  MBEAN_ NAME ) ; sp Proxy =  JMX . new MBean Proxy ( mbean Server Conn , name ,  Storage Proxy MBean . class ) ; name = new  Object Name (  Hinted Hand Off Manager .  MBEAN_ NAME ) ; hh Proxy =  JMX . new MBean Proxy ( mbean Server Conn , name ,  Hinted Hand Off Manager MBean . class ) ; name = new  Object Name (  GCInspector .  MBEAN_ NAME ) ; gc Proxy =  JMX . new MBean Proxy ( mbean Server Conn , name ,  GCInspector MXBean . class ) ; name = new  Object Name (  Gossiper .  MBEAN_ NAME ) ; goss Proxy =  JMX . new MBean Proxy ( mbean Server Conn , name ,  Gossiper MBean . class ) ; } catch (  Malformed Object Name Exception e ) { throw new  Runtime Exception ( _ STR , e ) ; } mem Proxy =  Management Factory . new Platform MXBean Proxy ( mbean Server Conn ,  Management Factory .  MEMORY_ MXBEAN_ NAME ,  Memory MXBean . class ) ; runtime Proxy =  Management Factory . new Platform MXBean Proxy ( mbean Server Conn ,  Management Factory .  RUNTIME_ MXBEAN_ NAME ,  Runtime MXBean . class ) ; }
private static void run Random Test ( final int word Length , final int byte Padding , final int word Count ) { final long seed = random Long ( ) ; final  Random random = new  Random ( seed ) ; final  Random verification Random = new  Random ( seed ) ; final long word Mask ; if ( word Length == _ NUM ) { word Mask = ~ _ NUM ; } else { word Mask = ( _ NUM << word Length ) - _ NUM ; } final  Big Endian Ascending Word Serializer serializer = new  Big Endian Ascending Word Serializer ( word Length , word Count , byte Padding ) ; for ( int i = _ NUM ; i < word Count ; i ++ ) { final long value = random . next Long ( ) & word Mask ; serializer . write Word ( value ) ; } final byte [ ] bytes = serializer . get Bytes ( ) ; final  Big Endian Ascending Word Deserializer deserializer = new  Big Endian Ascending Word Deserializer ( word Length , byte Padding , bytes ) ; assert Equals ( deserializer . total Word Count ( ) , word Count ) ; for ( int i = _ NUM ; i < word Count ; i ++ ) { assert Equals ( deserializer . read Word ( ) , ( verification Random . next Long ( ) & word Mask ) ) ; } }
public static  Maildir Message Name create Unique Name (  Maildir Folder parent Folder , long size ) {  String timestamp =  String . value Of (  System . current Time Millis ( ) ) ; timestamp = timestamp . substring ( _ NUM , timestamp . length ( ) - _ NUM ) ;  String Builder unique Part = new  String Builder ( ) ; unique Part . append (  Integer . to Hex String ( random . next Int ( ) ) ) ; unique Part . append ( timestamp . substring ( timestamp . length ( ) - _ NUM ) ) ; unique Part . append ( process Name ) ; unique Part . append ( get Next Delivery Number ( ) ) ;  String size String = _ STR +  String . value Of ( size ) ;  String full Name = timestamp + _ STR + unique Part . to String ( ) + _ STR + current Hostname + size String ;  Maildir Message Name unique Name = new  Maildir Message Name ( parent Folder , full Name ) ; unique Name . timestamp = timestamp ; unique Name . unique String = unique Part . to String ( ) ; unique Name . hostname = current Hostname ; unique Name . size String = size String ; unique Name . is Split = _ BOOL ; unique Name . size = size ; return unique Name ; }
@  Override public void handle Click ( int x , int y ,  Plot Rendering Info info ) { }
private void adjust BCIndex (  Instruction barrier ) {  Normal Method source = barrier . position ( ) . method ; if ( source . is For Osr Specialization ( ) ) { barrier . adjust Bytecode Index ( - source . get Osr Prologue Length ( ) ) ; } }
@  Override public  String to String ( ) {  String Builder risul = new  String Builder ( _ NUM ) ; risul . append ( _ STR ) ; risul . append ( _ STR ) ; return risul . to String ( ) ; }
public static long [ ] interpose ( long [ ] vector , int vector Len , int offset , int len ) { long [ ] updated = create ( vector Len + len ) ; int idx = offset > > _ NUM ;  System . arraycopy ( vector , _ NUM , updated , _ NUM , idx ) ; if ( idx < vector . length ) { int delta = offset & _ NUM ; updated [ idx ] |= vector [ idx ] & mask Below ( delta ) ; } copy ( vector , offset , updated , offset + len , vector Len - offset ) ; return updated ; }
Task <  Void > synchronize All Auth Data Async ( ) {  Map <  String ,  Map <  String ,  String > > auth Data ; synchronized ( mutex ) { if ( ! is Current User ( ) ) { return  Task . for Result ( null ) ; } auth Data = get Auth Data ( ) ; }  List <  Task <  Void > > tasks = new  Array List < > ( auth Data . size ( ) ) ; for (  String auth Type : auth Data . key Set ( ) ) { tasks . add ( synchronize Auth Data Async ( auth Type ) ) ; } return  Task . when All ( tasks ) ; }
public static  Element create Element In Encryption Space (  Document doc ,  String element Name ) { if ( doc == null ) { throw new  Runtime Exception ( _ STR ) ; } if ( ( xenc Prefix == null ) || ( xenc Prefix . length ( ) == _ NUM ) ) { return doc . create Element NS (  Encryption Constants .  Encryption Spec NS , element Name ) ; } return doc . create Element NS (  Encryption Constants .  Encryption Spec NS , xenc Prefix + _ STR + element Name ) ; }
public boolean equals Default ( ) { return (  Double . double To Long Bits ( value ) == _ NUM ) ; }
public void test_filter_001 ( ) throws  IOException { final  File basefile =  File . create Temp File ( get Name ( ) , _ STR ) ; try { final  String basename = basefile . to String ( ) ; final  Name And Extension Filter log Filter = new  Name And Extension Filter ( basename , _ STR ) ; assert Same Files ( new  File [ ] { } , log Filter . get Files ( ) ) ; } finally { basefile . delete ( ) ; } }
public void reset Tele Missile Attacks ( ) { pending Tele Missile Attacks . remove All Elements ( ) ; }
public void add Commands (  PDFPage page ,  Matrix extra ) { synchronized ( commands ) { add Push ( ) ; if ( extra != null ) { add Xform ( extra ) ; } commands . add All ( page . get Commands ( ) ) ; add Pop ( ) ; } update Images ( ) ; }
public  String to String ( ) {  String Buffer sb = new  String Buffer ( ) ; char [ ] separator = { _ STR , _ STR } ; int n = rows . length ; for ( int i = _ NUM ; i < n ; i ++ ) { separator [ _ NUM ] = _ STR ; for ( int j = _ NUM ; j <= i ; j ++ ) { sb . append ( separator ) ; sb . append ( rows [ i ] [ j ] ) ; separator [ _ NUM ] = _ STR ; } sb . append ( _ STR ) ; sb . append ( _ STR ) ; } return sb . to String ( ) ; }
public void add Last (  Statement Sequence statements ) { if ( statements != null ) { sequence . add All ( statements . sequence ) ; } }
private void notify Activity State Changed (  Bundle bundle ) { if ( ! m Records . is Empty ( ) ) {  Log . d (  TAG , _ STR + m Records . size ( ) ) ; synchronized ( m Records ) {  Iterator <  Record > iterator = m Records . iterator ( ) ; while ( iterator . has Next ( ) ) {  Record record = (  Record ) iterator . next ( ) ;  Fm Radio Listener listener = record . m Callback ; if ( listener == null ) { iterator . remove ( ) ; return ; } listener . on Call Back ( bundle ) ; } } } }
public double elasticity ( final double spot ) { final double val = value ( ) ; final double del = delta ( spot ) ; if ( val >  Constants .  QL_ EPSILON ) return del / val * spot ; else if (  Math . abs ( del ) <  Constants .  QL_ EPSILON ) return _ NUM ; else if ( del > _ NUM ) return  Double .  MAX_ VALUE ; else return  Double .  MIN_ VALUE ; }
private byte [ ] entity To Bytes (  Http Entity entity ,  Request request ) throws  IOException ,  Server Error {  Pooling Byte Array Output Stream bytes = new  Pooling Byte Array Output Stream ( m Pool , ( int ) entity . get Content Length ( ) ) ; byte [ ] buffer = null ; try {  Input Stream in = entity . get Content ( ) ; if ( in == null ) { throw new  Server Error ( ) ; } buffer = m Pool . get Buf ( _ NUM ) ; int progress = _ NUM ; int count ; while ( ( count = in . read ( buffer ) ) != - _ NUM ) { bytes . write ( buffer , _ NUM , count ) ; progress += count ; request . progress Update ( progress ) ; } return bytes . to Byte Array ( ) ; } finally { try { entity . consume Content ( ) ; } catch (  IOException e ) {  Vinci Log . d ( _ STR ) ; } m Pool . return Buf ( buffer ) ; bytes . close ( ) ; } }
public static float round Decimal ( float value ) { return round Decimal ( value ,  Math . log10 (  INT_ PRECISION ) ) ; }
@  Assisted Inject public  Runner Impl ( @  Not Null  Runner Localization Constant locale , @  Not Null  Runner Counter runner Counter , @  Not Null  Get Environments Util util , @  Not Null @  Assisted  Run Options run Options , @  Not Null @  Assisted  Scope environment Scope , @  Nullable @  Assisted  String environment Name ) { this . run Options = run Options ; this . ram = run Options . get Memory Size ( ) ; this . title =  RUNNER_ NAME + runner Counter . get Runner Number ( ) + ( environment Name == null ? _ STR : _ STR + get Correct Name ( environment Name ) ) ; this . active Tab = locale . runner Tab Console ( ) ; this . status =  IN_ QUEUE ; this . scope = environment Scope ; creation Time =  System . current Time Millis ( ) ;  String environment Id = run Options . get Environment Id ( ) ; if ( environment Id == null || environment Id . starts With ( _ STR ) ) { this . type = util . get Type ( ) ; } else { this . type = util . get Correct Category Name ( run Options . get Environment Id ( ) ) ; } if ( environment Id != null ) { run Options . set Environment Id ( environment Id ) ; } }
public static boolean is Windows Me ( ) { return os Name . index Of ( _ STR ) > - _ NUM && os Version . equals ( _ STR ) ; }
private  String date To String (  Date input ) { if ( input == null ) { return null ; } else { return input . to String ( ) ; } }
private static int component Size (  Component component ,  Form Spec form Spec , int cell Size ,  Form Layout .  Measure min Measure ,  Form Layout .  Measure pref Measure ) { if ( form Spec == null ) { return pref Measure . size Of ( component ) ; } else if ( form Spec . get Size ( ) ==  Sizes .  MINIMUM ) { return min Measure . size Of ( component ) ; } else if ( form Spec . get Size ( ) ==  Sizes .  PREFERRED ) { return pref Measure . size Of ( component ) ; } else { return  Math . min ( cell Size , pref Measure . size Of ( component ) ) ; } }
protected synchronized void start ( long cur Primary Gen ) throws  IOException { if ( state . equals ( _ STR ) == _ BOOL ) { throw new  Illegal State Exception ( _ STR ) ; } message ( _ STR ) ; try {  String segments File Name =  Segment Infos . get Last Commit Segments File Name ( dir ) ; long max Pending Gen = - _ NUM ; for (  String file Name : dir . list All ( ) ) { if ( file Name . starts With (  Index File Names .  PENDING_ SEGMENTS ) ) { long gen =  Long . parse Long ( file Name . substring (  Index File Names .  PENDING_ SEGMENTS . length ( ) + _ NUM ) ,  Character .  MAX_ RADIX ) ; if ( gen > max Pending Gen ) { max Pending Gen = gen ; } } }  Segment Infos infos ; if ( segments File Name == null ) { infos = new  Segment Infos ( ) ; message ( _ STR ) ; } else { message ( _ STR + segments File Name ) ; infos =  Segment Infos . read Commit ( dir , segments File Name ) ; message ( _ STR + infos . to String ( ) + _ STR + infos . get Version ( ) ) ;  Collection <  String > index Files = infos . files ( _ BOOL ) ; last Commit Files . add ( segments File Name ) ; last Commit Files . add All ( index Files ) ; deleter . inc Ref ( last Commit Files ) ; last NRTFiles . add All ( index Files ) ; deleter . inc Ref ( last NRTFiles ) ; message ( _ STR + last Commit Files ) ; message ( _ STR + last NRTFiles ) ; } message ( _ STR +  Arrays . to String ( dir . list All ( ) ) ) ; deleter . delete Unknown Files ( segments File Name ) ; message ( _ STR +  Arrays . to String ( dir . list All ( ) ) ) ;  String s = infos . get User Data ( ) . get (  PRIMARY_ GEN_ KEY ) ; long my Primary Gen ; if ( s == null ) { assert infos . size ( ) == _ NUM ; my Primary Gen = - _ NUM ; } else { my Primary Gen =  Long . parse Long ( s ) ; } message ( _ STR + my Primary Gen ) ; boolean do Commit ; if ( infos . size ( ) > _ NUM && my Primary Gen != - _ NUM && my Primary Gen != cur Primary Gen ) { assert my Primary Gen < cur Primary Gen ; final long init Sync Start NS =  System . nano Time ( ) ; message ( _ STR + my Primary Gen + _ STR + cur Primary Gen + _ STR ) ;  Copy Job job = null ; message ( _ STR + segments File Name ) ; assert deleter . get Ref Count ( segments File Name ) == _ NUM ; deleter . dec Ref (  Collections . singleton ( segments File Name ) ) ; if ( dir instanceof  FSDirectory && ( (  FSDirectory ) dir ) . check Pending Deletions ( ) ) { throw new  Runtime Exception ( _ STR + segments File Name + _ STR ) ; } boolean did Remove = last Commit Files . remove ( segments File Name ) ; assert did Remove ; while ( _ BOOL ) { job = new Copy Job ( _ STR + name ( ) + _ STR + infos . get Version ( ) , null , null , _ BOOL , null ) ; job . start ( ) ; message ( _ STR + job . get Copy State ( ) . version ) ; try { job . run Blocking ( ) ; job . finish ( ) ; break ; } catch (  IOException ioe ) { job . cancel ( _ STR , ioe ) ; if ( ioe . get Message ( ) . contains ( _ STR ) ) { message ( _ STR + ioe + _ STR ) ; } else { throw ioe ; } } } last Primary Gen = job . get Copy State ( ) . primary Gen ; byte [ ] infos Bytes = job . get Copy State ( ) . infos Bytes ;  Segment Infos sync Infos =  Segment Infos . read Commit ( dir , new  Buffered Checksum Index Input ( new  Byte Array Index Input ( _ STR , job . get Copy State ( ) . infos Bytes ) ) , job . get Copy State ( ) . gen ) ; sync Infos . update Generation ( infos ) ; infos = sync Infos ; assert infos . get Version ( ) == job . get Copy State ( ) . version ; message ( _ STR + infos . get Version ( ) + _ STR + infos . to String ( ) ) ; message ( _ STR + job . get File Names ( ) ) ; deleter . inc Ref ( job . get File Names ( ) ) ; message ( _ STR + last NRTFiles ) ; deleter . dec Ref ( last NRTFiles ) ; last NRTFiles . clear ( ) ; last NRTFiles . add All ( job . get File Names ( ) ) ; message ( _ STR + last NRTFiles ) ; last File Meta Data = job . get Copy State ( ) . files ; message (  String . format (  Locale .  ROOT , _ STR , id , (  System . nano Time ( ) - init Sync Start NS ) / _ NUM , bytes To String ( job . get Total Bytes Copied ( ) ) , job . get Copy State ( ) . version ) ) ; do Commit = _ BOOL ; } else { do Commit = _ BOOL ; last Primary Gen = cur Primary Gen ; message ( _ STR ) ; } if ( infos . get Generation ( ) < max Pending Gen ) { message ( _ STR + infos . get Generation ( ) + _ STR + max Pending Gen ) ; infos . set Next Write Generation ( max Pending Gen ) ; } send New Replica ( ) ; mgr = new  Segment Infos Searcher Manager ( dir , this , infos , searcher Factory ) ;  Index Searcher searcher = mgr . acquire ( ) ; try { int hit Count = searcher . count ( new  Term Query ( new  Term ( _ STR , _ STR ) ) ) ; message ( _ STR + hit Count + _ STR + ( (  Directory Reader ) searcher . get Index Reader ( ) ) . get Version ( ) ) ; } finally { mgr . release ( searcher ) ; } if ( do Commit ) { commit ( ) ; } message ( _ STR ) ; state = _ STR ; } catch (  Throwable t ) { if ( t . get Message ( ) . starts With ( _ STR ) == _ BOOL ) { message ( _ STR ) ; t . print Stack Trace ( print Stream ) ; } else { dir . close ( ) ; }  IOUtils . re Throw ( t ) ; } }
public static boolean is Same Element Type (  ASTNode node1 ,  ASTNode node2 ) { return node1 != null && node2 != null && node1 . get Element Type ( ) == node1 . get Element Type ( ) ; }
@  Override public  Log Message read Next Log Message ( ) { try { if ( reader == null ) { return null ; } while ( _ BOOL ) {  String line = reader . read Line ( ) ; if ( line == null ) { close ( ) ; if ( current Log != null && match Regex ( current Log ) ) { increment Log Count ( current Log ) ; return current Log ; } return null ; } file Line Number ++ ;  Log Message next Log = null ; if ( parser != null ) { next Log = parser . parse Line ( line , request ) ; } else { for (  Log Parser parser : parser Table ) { next Log = parser . parse Line ( line , request ) ; if ( ! next Log . is Continuation ( ) ) { this . parser = parser ; break ; } } if ( next Log == null || next Log . is Continuation ( ) ) { status . append Info ( this . file Path , file Line Number ) ; continue ; } } if ( next Log . is Continuation ( ) ) { if ( current Log != null ) { current Log . append Message (  Log Util . string To Bytes ( line ) ) ; } } else if ( next Log . is Rejected ( ) ) { if ( current Log != null ) {  Log Message returned Log = current Log ; current Log = null ; if ( match Regex ( returned Log ) ) { increment Log Count ( returned Log ) ; return returned Log ; } } } else if ( next Log . is Rejected Last ( ) ) { if ( current Log != null ) {  Log Message returned Log = current Log ; current Log = null ; if ( match Regex ( returned Log ) ) { increment Log Count ( returned Log ) ; return returned Log ; } } break ; } else { if ( current Log != null ) {  Log Message returned Log = current Log ; current Log = next Log ; if ( returned Log . is Header ( ) && current Log . is Header ( ) ) { continue ; } if ( match Regex ( returned Log ) ) { increment Log Count ( returned Log ) ; return returned Log ; } } else { current Log = next Log ; } } } } catch (  IOException e ) { status . append Err File Name ( file Path ) ; } return null ; }
private void load Binary (  Data Input Stream is ) throws  IOException { if ( is . read Int ( ) !=  MAGIC ) { throw new  Error ( _ STR ) ; } if ( is . read Int ( ) !=  VERSION ) { throw new  Error ( _ STR ) ; } continuity Weight = is . read Int ( ) ; optimal Coupling = is . read Int ( ) ; extend Selections = is . read Int ( ) ; join Method = is . read Int ( ) ; join Weight Shift = is . read Int ( ) ; int weight Length = is . read Int ( ) ; join Weights = new int [ weight Length ] ; for ( int i = _ NUM ; i < join Weights . length ; i ++ ) { join Weights [ i ] = is . read Int ( ) ; } int units Length = is . read Int ( ) ; units = new  Database Cluster Unit [ units Length ] ; for ( int i = _ NUM ; i < units . length ; i ++ ) { units [ i ] = new  Database Cluster Unit ( is ) ; } int unit Types Length = is . read Int ( ) ; unit Types = new  Unit Type [ unit Types Length ] ; for ( int i = _ NUM ; i < unit Types . length ; i ++ ) { unit Types [ i ] = new  Unit Type ( is ) ; } sts = new  Sample Set ( is ) ; mcep = new  Sample Set ( is ) ; int num Carts = is . read Int ( ) ; cart Map = new  Hash Map ( ) ; for ( int i = _ NUM ; i < num Carts ; i ++ ) {  String name =  Utilities . get String ( is ) ;  CART cart =  CARTImpl . load Binary ( is ) ; cart Map . put ( name , cart ) ; if ( default Cart == null ) { default Cart = cart ; } } }
public static  String to String ( long l ) { if ( l <  NUMBERS_ MIN || l >  NUMBERS_ MAX ) { return  Long . to String ( l , _ NUM ) ; } return  NUMBERS [ ( int ) l ] ; }
protected boolean is IDPProxy Enabled (  FSAuthn Request authn Request ) throws  FSException { if ( authn Request . get Minor Version ( ) !=  IFSConstants .  FF_12_ PROTOCOL_ MINOR_ VERSION ) { return _ BOOL ; }  FSScoping scoping = authn Request . get Scoping ( ) ; if ( scoping != null && scoping . get Proxy Count ( ) == _ NUM ) { return _ BOOL ; }  String enabled String =  IDFFMeta Utils . get First Attribute Value From Config ( sp Config ,  IFSConstants .  ENABLE_ IDP_ PROXY ) ; if ( enabled String != null && enabled String . equals Ignore Case ( _ STR ) ) { return _ BOOL ; } else { return _ BOOL ; } }
private void compile Prolog (  Object Id prolog ,  File temp Dir ) throws  IOException ,  Compile Exception {  File temp Rules = copy To Temp File ( prolog , temp Dir ) ; try {  Compiler comp = new  Compiler ( ) ; comp . prolog To Java Source ( temp Rules . get Path ( ) , temp Dir . get Path ( ) ) ; } finally { temp Rules . delete ( ) ; } }
public  Selection Input Dialog (  Window owner ,  String key , boolean editable ,  T [ ] selection Values ,  T initial Selection Value ,  Input Validator <  T > input Validator ,  Object ... key Arguments ) { this ( owner , key , selection Values , initial Selection Value , input Validator , key Arguments ) ; combo Box . set Editable ( editable ) ; }
public void build (  Solr Core core ,  Solr Index Searcher searcher ) throws  IOException {  LOG . info ( _ STR ) ; dictionary = dictionary Factory . create ( core , searcher ) ; lookup . build ( dictionary ) ; if ( store Dir != null ) {  File target = new  File ( store Dir , factory . store File Name ( ) ) ; if ( ! lookup . store ( new  File Output Stream ( target ) ) ) {  LOG . error ( _ STR ) ; } else {  LOG . info ( _ STR + target . get Absolute Path ( ) ) ; } } }
public byte [ ] to Byte Array ( ) { return  Arrays . copy Of ( buf , cnt ) ; }
public void create Disk Async ( final  String project Id , final  Disk Create Spec disk Create Spec , final  Future Callback <  Task > response Callback ) throws  IOException { final  String path =  String . format ( _ STR , get Base Path ( ) , project Id ) ; create Object Async ( path , serialize Object As Json ( disk Create Spec ) , response Callback ) ; }
@  Override public boolean domain Match ( final  String host , final  String domain ) { return host . ends With ( domain ) ; }
public synchronized void disable Attribute (  String name ) { enabled Attributes . remove Element ( name ) ; }
public void push ( final  Handle handle ) { mv . visit Ldc Insn ( handle ) ; }
public static  IFits Header lookup (  String key ) { int key Length = key . length ( ) ; if ( key Length > _ NUM &&  Character . is Digit ( key . char At ( key Length - _ NUM ) ) ) {  String Builder builder = new  String Builder ( ) ; for ( int index = _ NUM ; index < key Length ; index ++ ) { char character = key . char At ( index ) ; if (  Character . is Digit ( character ) ) { if ( builder . char At ( builder . length ( ) - _ NUM ) != _ STR ) { builder . append ( _ STR ) ; } } else { builder . append ( character ) ; } } return  STANDARD_ KEYS . get ( builder . to String ( ) ) ; } return  STANDARD_ KEYS . get ( key ) ; }
private static void assert Change Events (  Collection <  Port Change Event > early Events ,  Collection <  Port Change Event > late Events ,  Collection <  Port Change Event > anytime Events ,  Collection <  Port Change Event > actual Events ) {  String input Desc =  String . format ( _ STR + _ STR , early Events , late Events , anytime Events , actual Events ) ;  Collection <  Port Change Event > early = new  Array List <  Port Change Event > ( early Events ) ;  Collection <  Port Change Event > late = new  Array List <  Port Change Event > ( late Events ) ;  Collection <  Port Change Event > any = new  Array List <  Port Change Event > ( anytime Events ) ; for (  Port Change Event ev : early ) { assert False ( _ STR , late . contains ( ev ) ) ; assert False ( _ STR , any . contains ( ev ) ) ; } for (  Port Change Event ev : late ) { assert False ( _ STR , early . contains ( ev ) ) ; assert False ( _ STR , any . contains ( ev ) ) ; } for (  Port Change Event ev : any ) { assert False ( _ STR , early . contains ( ev ) ) ; assert False ( _ STR , late . contains ( ev ) ) ; } for (  Port Change Event a : actual Events ) { if ( early . remove ( a ) ) { continue ; } if ( any . remove ( a ) ) { continue ; } if ( late . remove ( a ) ) { if ( ! early . is Empty ( ) ) { fail ( a + _ STR + _ STR + input Desc ) ; } else { continue ; } } fail ( a + _ STR + input Desc ) ; } if ( ! early . is Empty ( ) ) fail ( _ STR + early + _ STR + input Desc ) ; if ( ! late . is Empty ( ) ) fail ( _ STR + late + _ STR + input Desc ) ; if ( ! any . is Empty ( ) ) fail ( _ STR + any + _ STR + input Desc ) ; }
@  Override public void write (  Kryo kryo ,  Output output ) { int size = index . size ( ) ; output . write Int ( size + _ NUM , _ BOOL ) ; for ( int i = _ NUM ; i < size ; ++ i ) {  String s = index . get ( i ) ; if ( s == null ) { throw new  Runtime Exception ( _ STR +  Integer . to String ( i ) ) ; } output . write String ( s ) ; } }
public final  Object Property <  Control > toggle Node Property ( ) { return this . toggle Node ; }
private static int decode Octets ( int i ,  Byte Buffer bb ,  String Builder sb ) { if ( bb . limit ( ) == _ NUM && ( bb . get ( _ NUM ) & _ NUM ) < _ NUM ) { sb . append ( ( char ) bb . get ( _ NUM ) ) ; return i + _ NUM ; } else {  Char Buffer cb =  UTF_8_ CHARSET . decode ( bb ) ; sb . append ( cb . to String ( ) ) ; return i + bb . limit ( ) * _ NUM - _ NUM ; } }
public  Array Field Vector (  Field Vector <  T > v1 ,  T [ ] v2 ) throws  Null Argument Exception {  Math Utils . check Not Null ( v1 ) ;  Math Utils . check Not Null ( v2 ) ; field = v1 . get Field ( ) ; final  T [ ] v1 Data = ( v1 instanceof  Array Field Vector ) ? ( (  Array Field Vector <  T > ) v1 ) . data : v1 . to Array ( ) ; data =  Math Arrays . build Array ( field , v1 Data . length + v2 . length ) ;  System . arraycopy ( v1 Data , _ NUM , data , _ NUM , v1 Data . length ) ;  System . arraycopy ( v2 , _ NUM , data , v1 Data . length , v2 . length ) ; }
public void start ( ) { if ( s Logger . is Activated ( ) ) { s Logger . info ( _ STR ) ; } m Cleanup Executor =  Executors . new Single Thread Executor ( ) ; if ( ! m Observer Is Registered ) { m Contacts Contract Observer = new  Contacts Contract Observer ( new  Handler ( ) ) ; m Contacts Contract Cursor = m Content Resolver . query (  Phone .  CONTENT_ URI , null , null , null , null ) ;  Cursor Util . assert Cursor Is Not Null ( m Contacts Contract Cursor ,  Phone .  CONTENT_ URI ) ; m Contacts Contract Cursor . register Content Observer ( m Contacts Contract Observer ) ; m Observer Is Registered = _ BOOL ; } }
protected final void fire Vetoable Change (  String property Name , double old Value , double new Value ) throws  Property Veto Exception { fire Vetoable Change ( property Name ,  Double . value Of ( old Value ) ,  Double . value Of ( new Value ) ) ; }
public void test LMDirichlet ( ) throws  IOException { float p = (  FREQ + _ NUM * (  TOTAL_ TERM_ FREQ + _ NUM ) / (  NUMBER_ OF_ FIELD_ TOKENS + _ NUM ) ) / (  DOC_ LEN + _ NUM ) ; float a = _ NUM / (  DOC_ LEN + _ NUM ) ; float gold = ( float ) (  Math . log ( p / ( a * (  TOTAL_ TERM_ FREQ + _ NUM ) / (  NUMBER_ OF_ FIELD_ TOKENS + _ NUM ) ) ) +  Math . log ( a ) ) ; correctness Test Core ( new  LMDirichlet Similarity ( ) , gold ) ; }
public void on Sinks Received (  String source Urn ,  List <  Media Sink > sinks ) { m Sinks . put ( source Urn , sinks ) ; native On Sinks Received ( m Native Media Router Android , source Urn , sinks . size ( ) ) ; }
public  User to Entity (  User DTO dto ) { return to Entity ( dto , _ NUM ) ; }
protected void write External Foreign Key Drop Stmt (  Table table ,  Foreign Key foreign Key ,  String Builder ddl ) { write Table Alter Stmt ( table , ddl ) ; ddl . append ( _ STR ) ; print Identifier ( get Foreign Key Name ( table , foreign Key ) , ddl ) ; print End Of Statement ( ddl ) ; }
public void obtain ( long timeout_ms ) throws  IOException ,  Interrupted Exception ,  Timeout Exception {  Long quit_time =  System . current Time Millis ( ) + timeout_ms ; if ( file Lock != null && file Lock . is Valid ( ) ) { return ; } do { try { file Lock = file To Lock . try Lock ( ) ; return ; } catch (  Overlapping File Lock Exception e ) {  Thread . sleep ( _ NUM ) ; } } while (  System . current Time Millis ( ) < quit_time ) ; throw new  Timeout Exception ( ) ; }
@  Deprecated public void point To Data (  Data o ) throws  Fits Exception { o . fill Header ( this ) ; }
@  Not Null protected  Virtual File [ ] collect Affected Files ( @  Not Null  Project project , @  Not Null  Virtual File [ ] files ) {  List <  Virtual File > affected Files = new  Array List <  Virtual File > ( files . length ) ;  Project Level Vcs Manager project Level Vcs Manager =  Project Level Vcs Manager . get Instance ( project ) ; for (  Virtual File file : files ) { if ( ! file . is Directory ( ) && project Level Vcs Manager . get Vcs For ( file ) instanceof  Git Vcs ) { affected Files . add ( file ) ; } else if ( file . is Directory ( ) && is Recursive ( ) ) { add Children ( project , affected Files , file ) ; } } return  Vfs Util Core . to Virtual File Array ( affected Files ) ; }
protected void update ( int length ) { tick Label Values . clear ( ) ; tick Labels . clear ( ) ; tick Label Positions . clear ( ) ; if ( scale . is Log Scale Enabled ( ) ) { update Tick Label For Log Scale ( length ) ; } else { update Tick Label For Linear Scale ( length ) ; } update Tick Visibility ( ) ; update Tick Label Max Length And Height ( ) ; }
private static boolean is Within Bounds (  Visual Position target Position ,  Visual Position start Position ,  Visual Position end Position ) { return target Position . line >= start Position . line && target Position . line <= end Position . line && target Position . column >= start Position . column && target Position . column <= end Position . column ; }
static public void assert Statement Indices Consistent ( final  Abstract Triple Store db , final int maxerrors ) { if ( log . is Info Enabled ( ) ) log . info ( _ STR ) ; final  Atomic Integer nerrs = new  Atomic Integer ( _ NUM ) ; final int from , to ; if ( db . get SPOKey Arity ( ) == _ NUM ) { from =  SPOKey Order .  FIRST_ TRIPLE_ INDEX ; to =  SPOKey Order .  LAST_ TRIPLE_ INDEX ; } else { from =  SPOKey Order .  FIRST_ QUAD_ INDEX ; to =  SPOKey Order .  LAST_ QUAD_ INDEX ; } for ( int i = from ; i <= to ; i ++ ) { for ( int j = from ; j <= to ; j ++ ) { if ( i <= j ) { continue ; } assert Same Statements ( db ,  SPOKey Order . value Of ( i ) ,  SPOKey Order . value Of ( j ) , nerrs , maxerrors ) ; } } assert Equals ( _ NUM , nerrs . get ( ) ) ; }
public void show ( @  Id Res final int item Id ) { map . add ( item Id ) ; navigation . invalidate Badge ( item Id ) ; }
public  Options put (  String option ,  Integer value ) { if ( value == null ) { return remove ( option ) ; } options . put ( option , value . to String ( ) ) ; return this ; }
private int determine Target Page ( int current Page , float page Offset , int velocity , int delta X ) { int target Page ; if (  Math . abs ( delta X ) > fling Distance &&  Math . abs ( velocity ) > minimum Velocity ) { if ( virtual Pos < _ NUM ) { target Page = velocity > _ NUM ? current Page : current Page + _ NUM ; } else { target Page = velocity > _ NUM ? current Page + _ NUM : current Page ; } } else { final float truncator = current Page >= current Item ? _ NUM : _ NUM ; target Page = ( int ) ( current Page + page Offset + truncator ) ; } if ( items . size ( ) > _ NUM ) { final  Item Info first Item = items . get ( _ NUM ) ; final  Item Info last Item = items . get ( items . size ( ) - _ NUM ) ; target Page =  Math . max ( first Item . position ,  Math . min ( target Page , last Item . position ) ) ; } if ( target Page > current Page && on Card Change Listener != null ) { on Card Change Listener . on Card Dismissed ( current Page , virtual Pos > _ NUM ) ; } return target Page ; }
protected  String form (  Object Matrix1 D matrix , int index ,  Former formatter ) {  Object value = matrix . get ( index ) ; if ( value == null ) return _ STR ; return  String . value Of ( value ) ; }
public void disable (  Bluetooth Adapter adapter ) { int mask = (  Bluetooth Receiver .  STATE_ TURNING_ OFF_ FLAG |  Bluetooth Receiver .  STATE_ OFF_ FLAG |  Bluetooth Receiver .  SCAN_ MODE_ NONE_ FLAG ) ; long start = - _ NUM ;  Bluetooth Receiver receiver = get Bluetooth Receiver ( mask ) ; int state = adapter . get State ( ) ; switch ( state ) { case  Bluetooth Adapter .  STATE_ OFF : assert False ( adapter . is Enabled ( ) ) ; remove Receiver ( receiver ) ; return ; case  Bluetooth Adapter .  STATE_ TURNING_ ON : assert False ( adapter . is Enabled ( ) ) ; start =  System . current Time Millis ( ) ; break ; case  Bluetooth Adapter .  STATE_ ON : assert True ( adapter . is Enabled ( ) ) ; start =  System . current Time Millis ( ) ; assert True ( adapter . disable ( ) ) ; break ; case  Bluetooth Adapter .  STATE_ TURNING_ OFF : assert False ( adapter . is Enabled ( ) ) ; mask = _ NUM ; break ; default : remove Receiver ( receiver ) ; fail (  String . format ( _ STR , state ) ) ; } long s =  System . current Time Millis ( ) ; while (  System . current Time Millis ( ) - s <  ENABLE_ DISABLE_ TIMEOUT ) { state = adapter . get State ( ) ; if ( state ==  Bluetooth Adapter .  STATE_ OFF && ( receiver . get Fired Flags ( ) & mask ) == mask ) { assert False ( adapter . is Enabled ( ) ) ; long finish = receiver . get Completed Time ( ) ; if ( start != - _ NUM && finish != - _ NUM ) { write Output (  String . format ( _ STR , ( finish - start ) ) ) ; } else { write Output ( _ STR ) ; } remove Receiver ( receiver ) ; return ; } sleep (  POLL_ TIME ) ; } int fired Flags = receiver . get Fired Flags ( ) ; remove Receiver ( receiver ) ; fail (  String . format ( _ STR , state ,  Bluetooth Adapter .  STATE_ OFF , fired Flags , mask ) ) ; }
public static  String to Regex (  String glob ,  String separator ) { check Not Null ( separator , _ STR ) ; check Argument ( separator . length ( ) == _ NUM , _ STR , separator ) ; return to Regex ( glob , separator . char At ( _ NUM ) ) ; }
protected void force No Loss ( boolean value ) { }
public static  String [ ] split Without Escaped (  String str , char separator Char , boolean retain Empty ) { int len = str . length ( ) ; if ( len == _ NUM ) { return new  String [ _ NUM ] ; }  List <  String > list = new  Array List <  String > ( ) ; int i = _ NUM ; int start = _ NUM ; boolean match = _ BOOL ; while ( i < len ) { if ( str . char At ( i ) == _ STR ) { match = _ BOOL ; i += _ NUM ; } else if ( str . char At ( i ) == separator Char ) { if ( retain Empty || match ) { list . add ( str . substring ( start , i ) ) ; match = _ BOOL ; } start = ++ i ; } else { match = _ BOOL ; i ++ ; } } if ( retain Empty || match ) { list . add ( str . substring ( start , i ) ) ; } return list . to Array ( new  String [ list . size ( ) ] ) ; }
private static  Hash Map <  Basic Block Pair ,  Hash Set <  Register > > find Split Points (  IR ir ,  Live Analysis live ,  LSTGraph lst ) {  Hash Map <  Basic Block Pair ,  Hash Set <  Register > > result = new  Hash Map <  Basic Block Pair ,  Hash Set <  Register > > ( _ NUM ) ; for (  Enumeration <  Graph Node > e = lst . enumerate Nodes ( ) ; e . has More Elements ( ) ; ) {  LSTNode node = (  LSTNode ) e . next Element ( ) ;  Basic Block header = node . get Header ( ) ;  Bit Vector loop = node . get Loop ( ) ; if ( loop == null ) continue ; for (  Enumeration <  Basic Block > in = header . get In ( ) ; in . has More Elements ( ) ; ) {  Basic Block bb = in . next Element ( ) ; if ( loop . get ( bb . get Number ( ) ) ) continue ;  Hash Set <  Register > live Registers = live . get Live Registers On Edge ( bb , header ) ; for (  Register r : live Registers ) { if ( r . is Symbolic ( ) ) {  Hash Set <  Register > s = find Or Create Split Set ( result , bb , header ) ; s . add ( r ) ; } } } for ( int i = _ NUM ; i < loop . length ( ) ; i ++ ) { if ( loop . get ( i ) ) {  Basic Block bb = ir . get Basic Block ( i ) ; for (  Enumeration <  Basic Block > out = bb . get Normal Out ( ) ; out . has More Elements ( ) ; ) {  Basic Block dest = out . next Element ( ) ; if ( loop . get ( dest . get Number ( ) ) ) continue ;  Hash Set <  Register > live Registers = live . get Live Registers On Edge ( bb , dest ) ; for (  Register r : live Registers ) { if ( r . is Symbolic ( ) ) {  Hash Set <  Register > s = find Or Create Split Set ( result , bb , dest ) ; s . add ( r ) ; } } } } } } add Entries For Infrequent Blocks ( ir , live , result ) ; return result ; }
public void test Split Escaped Semicolons ( ) {  Properties inner =  Property Utils . split Properties On Semicolon (  Property Utils . escape Back Slashes If Not Null ( _ STR ) ) ; assert Equals ( _ NUM , inner . size ( ) ) ; assert Equals ( _ STR , inner . get Property ( _ STR ) ) ; assert Equals ( _ STR , inner . get Property ( _ STR ) ) ; assert Equals ( _ STR , inner . get Property ( _ STR ) ) ; assert Equals ( _ STR , inner . get Property ( _ STR ) ) ; }
public static void remove Object At Offset (  Object [ ] source Array ,  Object [ ] destination Array , int offset ) {  System . arraycopy ( source Array , _ NUM , destination Array , _ NUM , offset ) ;  System . arraycopy ( source Array , offset + _ NUM , destination Array , offset , source Array . length - offset - _ NUM ) ; }
@  Suppress Warnings ( _ STR ) public  Dictionary Adapter (  Context context ,  File db Path ,  String db Name ,  String default Table ) { m Context = context ; m Db Name = db Name ; m Default Table = default Table ; m Db Path = db Path ; m Db File = new  File ( db Path , m Db Name ) ; if ( m Db File . exists ( ) ) { open ( ) ; } }
Http Stream Wrapper (  Http Stream stream ) throws  IOException { _stream = stream ; }
public boolean handle File (  File file ) { if (  DEBUG ) { logger . fine ( _ STR + file . get Absolute Path ( ) ) ; } filenames . add ( file ) ; return _ BOOL ; }
public boolean looks Like Number Coming ( ) { if ( n >= s . length ( ) ) return _ BOOL ; return  Character . is Digit ( s . char At ( n ) ) ; }
public short read Short ( ) throws  IOException { return primitive Types . read Short ( ) ; }
public void print ( int inum ) { print (  String . value Of ( inum ) ) ; }
public static <  Node Type extends  IView Node < ? > >  Zy Proximity Node < ? > create Proximity Node ( final  Graph2 D graph , final  Zy Graph Node < ? > attached Node , final int degree , final boolean is Incoming ) {  Preconditions . check Not Null ( graph , _ STR ) ;  Preconditions . check Not Null ( attached Node , _ STR ) ; final  Zy Label Content labelcontent = new  Zy Label Content ( null ) ; labelcontent . add Line Content ( new  Zy Line Content (  String . value Of ( degree ) , new  Font ( _ STR ,  Font .  PLAIN , _ NUM ) , null ) ) ; final  Zy Proximity Node Realizer <  Node Type > r = new  Zy Proximity Node Realizer <  Node Type > ( labelcontent ) ; final  Node node = graph . create Node ( r ) ; @  Suppress Warnings ( _ STR ) final  Zy Proximity Node <  Node Type > info Node = new  Zy Proximity Node <  Node Type > ( node , r , (  Zy Graph Node <  Node Type > ) attached Node , is Incoming ) ; final  Zy Node Data <  Zy Proximity Node <  Node Type > > data = new  Zy Node Data <  Zy Proximity Node <  Node Type > > ( info Node ) ; r . set User Data ( data ) ; return info Node ; }
public static boolean is Zoning Required (  Db Client db Client ,  URI varray Uri ) { if ( varray Uri != null ) {  Virtual Array nh = db Client . query Object (  Virtual Array . class , varray Uri ) ; if ( nh != null ) { return is Zoning Required ( db Client , nh ) ; } } return _ BOOL ; }
protected  CCAnimation (  String name , float delay ,  Array List <  CCSprite Frame > frames ) { delay_ = delay ; name_ = name ; frames_ = new  Array List <  CCSprite Frame > ( ) ; if ( frames != null ) frames_ . add All ( frames ) ; }
private void navigate To Dump ( ) {  Tree Path current Path = tree . get Selection Path ( ) ; tree . set Selection Path ( current Path . get Parent Path ( ) ) ; tree . scroll Path To Visible ( current Path . get Parent Path ( ) ) ; }
public synchronized void add Messages (  Array List <  Sms Mms Message > new Messages ) { if ( new Messages != null ) { messages . add All ( _ NUM , new Messages ) ;  Update Message Count ( ) ; } }
public int swap ( ) { if ( ! egl . egl Swap Buffers ( egl Display , egl Surface ) ) { return egl . egl Get Error ( ) ; } return  EGL10 .  EGL_ SUCCESS ; }
public static  List <  Window > windows (  String words , int window Size ) {  String Tokenizer tokenizer = new  String Tokenizer ( words ) ;  List <  String > list = new  Array List <  String > ( ) ; while ( tokenizer . has More Tokens ( ) ) list . add ( tokenizer . next Token ( ) ) ; return windows ( list , window Size ) ; }
protected void draw Center Text (  Canvas c ) {  Char Sequence center Text = m Chart . get Center Text ( ) ; if ( m Chart . is Draw Center Text Enabled ( ) && center Text != null ) {  MPPoint F center = m Chart . get Center Circle Box ( ) ;  MPPoint F offset = m Chart . get Center Text Offset ( ) ; float x = center . x + offset . x ; float y = center . y + offset . y ; float inner Radius = m Chart . is Draw Hole Enabled ( ) && ! m Chart . is Draw Slices Under Hole Enabled ( ) ? m Chart . get Radius ( ) * ( m Chart . get Hole Radius ( ) / _ NUM ) : m Chart . get Radius ( ) ;  Rect F hole Rect = m Rect Buffer [ _ NUM ] ; hole Rect . left = x - inner Radius ; hole Rect . top = y - inner Radius ; hole Rect . right = x + inner Radius ; hole Rect . bottom = y + inner Radius ;  Rect F bounding Rect = m Rect Buffer [ _ NUM ] ; bounding Rect . set ( hole Rect ) ; float radius Percent = m Chart . get Center Text Radius Percent ( ) / _ NUM ; if ( radius Percent > _ NUM ) { bounding Rect . inset ( ( bounding Rect . width ( ) - bounding Rect . width ( ) * radius Percent ) / _ NUM , ( bounding Rect . height ( ) - bounding Rect . height ( ) * radius Percent ) / _ NUM ) ; } if ( ! center Text . equals ( m Center Text Last Value ) || ! bounding Rect . equals ( m Center Text Last Bounds ) ) { m Center Text Last Bounds . set ( bounding Rect ) ; m Center Text Last Value = center Text ; float width = m Center Text Last Bounds . width ( ) ; m Center Text Layout = new  Static Layout ( center Text , _ NUM , center Text . length ( ) , m Center Text Paint , ( int )  Math . max (  Math . ceil ( width ) , _ NUM ) ,  Layout .  Alignment .  ALIGN_ CENTER , _ NUM , _ NUM , _ BOOL ) ; } float layout Height = m Center Text Layout . get Height ( ) ; c . save ( ) ; if (  Build .  VERSION .  SDK_ INT >= _ NUM ) {  Path path = m Draw Center Text Path Buffer ; path . reset ( ) ; path . add Oval ( hole Rect ,  Path .  Direction .  CW ) ; c . clip Path ( path ) ; } c . translate ( bounding Rect . left , bounding Rect . top + ( bounding Rect . height ( ) - layout Height ) / _ NUM ) ; m Center Text Layout . draw ( c ) ; c . restore ( ) ;  MPPoint F . recycle Instance ( center ) ;  MPPoint F . recycle Instance ( offset ) ; } }
protected void group Frames (  Vector <  Frame > frames ,  Vector <  Group > groups , boolean is Dchum ) throws  Make Toc Exception {  Frame frame ;  Group group ; int group Count ; int n Frames = frames . size ( ) ;  Debug . message ( _ STR , _ STR ) ; for ( int i = _ NUM ; i < n Frames ; i ++ ) {  Debug . message ( _ STR , _ STR ) ; frame = (  Frame ) frames . element At ( i ) ; if ( ! frame . marked ) { group Count = groups . size ( ) ; group = new  Group ( ) ; group . left = max Side / _ NUM ; group . right = group . left + _ NUM ; group . top = max Side / _ NUM ; group . bottom = group . top + _ NUM ; group . horiz_pos [ group . top ] = frame . top ; group . horiz_pos [ group . bottom ] = frame . bottom ; group . vert_pos [ group . left ] = frame . left ; group . vert_pos [ group . right ] = frame . right ; group . h_interval = frame . h_interval ; group . v_interval = frame . v_interval ; group . h_resolution = frame . h_resolution ; group . v_resolution = frame . v_resolution ; group . scale = frame . scale ; group . zone = frame . zone ; group . cib = frame . cib ; group . cdted = frame . cdted ; frame . x = group . left ; frame . y = group . top ; frame . group = group Count ; frame . marked = _ BOOL ;  Debug . message ( _ STR , _ STR + group Count + _ STR + i + _ STR + frame . filename + _ STR ) ; if ( ! is Dchum ) { for ( int j = _ NUM ; j < n Frames ; j ++ ) { if ( i == j ) {  Debug . message ( _ STR , _ STR + i + _ STR ) ; continue ; }  Frame f = (  Frame ) frames . element At ( j ) ; if ( add Frame To Group ( group , f , group Count ) ) {  Debug . message ( _ STR , _ STR + j + _ STR + group Count ) ; continue ; } } }  Debug . message ( _ STR , _ STR + group Count + _ STR ) ; groups . add ( group ) ; } fire Progress Update (  Progress Event .  UPDATE , _ STR , i , n Frames ) ; } if (  Debug . debugging ( _ STR ) ) {  Debug . output ( _ STR + groups . size ( ) ) ; } }
private static  Object add ( final  Object array , final int index , final  Object element , final  Class < ? > clss ) { if ( array == null ) { if ( index != _ NUM ) { throw new  Index Out Of Bounds Exception ( _ STR + index + _ STR ) ; }  Object joined Array =  Array . new Instance ( clss , _ NUM ) ;  Array . set ( joined Array , _ NUM , element ) ; return joined Array ; } int length =  Array . get Length ( array ) ; if ( index > length || index < _ NUM ) { throw new  Index Out Of Bounds Exception ( _ STR + index + _ STR + length ) ; }  Object result =  Array . new Instance ( clss , length + _ NUM ) ;  System . arraycopy ( array , _ NUM , result , _ NUM , index ) ;  Array . set ( result , index , element ) ; if ( index < length ) {  System . arraycopy ( array , index , result , index + _ NUM , length - index ) ; } return result ; }
public double double Value ( ) { return d . double Value ( ) ; }
public  String to Matlab ( ) {  String Buffer result ; int i ; int n ; result = new  String Buffer ( ) ; result . append ( _ STR ) ; for ( i = _ NUM ; i < get Row Dimension ( ) ; i ++ ) { if ( i > _ NUM ) { result . append ( _ STR ) ; } for ( n = _ NUM ; n < get Column Dimension ( ) ; n ++ ) { if ( n > _ NUM ) { result . append ( _ STR ) ; } result . append (  Double . to String ( get ( i , n ) ) ) ; } } result . append ( _ STR ) ; return result . to String ( ) ; }
public  File Input Reader (  File f ) throws  IOException { if (  Debug . debugging ( _ STR ) ) {  Debug . output ( _ STR + f . get Absolute Path ( ) ) ; } name = f . get Name ( ) ; absolute Path = f . get Absolute Path ( ) ; input File = init ( f ) ; }
public static  Object Output Stream new Object Output Stream (  Path self ) throws  IOException { return new  Object Output Stream (  Files . new Output Stream ( self ) ) ; }
@  Override public  Set <  K > key Set ( ) {  Hash Set <  K > set = new  Hash Set <  K > ( ) ; for (  Segment <  K ,  V > s : segments ) { set . add All ( s . key Set ( ) ) ; } return set ; }
public void add ( final  Certificate Validity certificate Validity ) { certificate Validity List . add ( certificate Validity ) ; }
public void add Policy Listener (  Policy Listener policy Listener ) { policy Cache . add Policy Listener ( policy Listener ) ; }
public static  Result verify (  String sid ,  String code ) {  String id = _ STR + sid ;  Code c = (  Code )  Cache . get ( id ) ; if ( c == null ) { log . warn ( _ STR + sid ) ; return  Result . badcode ; } else if ( !  X . is Same ( code , c . code ) ) { log . warn ( _ STR + c . code + _ STR + code ) ; return  Result . badcode ; } else if ( c . expired <  System . current Time Millis ( ) ) { log . warn ( _ STR + c . expired ) ; return  Result . expired ; } return  Result . ok ; }
protected static  INavi Raw Module find Raw Module ( final int raw Module Id , final  List <  INavi Raw Module > raw Modules ) {  Preconditions . check Argument ( raw Module Id > _ NUM , _ STR , raw Module Id ) ;  Preconditions . check Not Null ( raw Modules , _ STR ) ; for ( final  INavi Raw Module raw Module : raw Modules ) { if ( raw Module . get Id ( ) == raw Module Id ) { return raw Module ; } } throw new  Illegal State Exception ( _ STR ) ; }
public static  Object extract Type Checked (  List <  Object > args , int i ,  Class clazz ,  Function <  List <  Object > ,  Object > extract Func ) { if ( args . size ( ) < i + _ NUM ) { return null ; } else if ( clazz . is Instance ( args . get ( i ) ) ) { return extract Func . apply ( args ) ; } else { return null ; } }
@  Override public  Japanese Date date Year Day ( int proleptic Year , int day Of Year ) { return new  Japanese Date (  Local Date . of Year Day ( proleptic Year , day Of Year ) ) ; }
private  Pair <  Entry , char [ ] > recover Entry (  Key Store ks ,  String alias , char [ ] pstore , char [ ] pkey ) throws  Exception { if ( ks . contains Alias ( alias ) == _ BOOL ) {  Message Format form = new  Message Format ( rb . get String ( _ STR ) ) ;  Object [ ] source = { alias } ; throw new  Exception ( form . format ( source ) ) ; }  Password Protection pp = null ;  Entry entry ; try { entry = ks . get Entry ( alias , pp ) ; pkey = null ; } catch (  Unrecoverable Entry Exception une ) { if (  P11 KEYSTORE . equals Ignore Case ( ks . get Type ( ) ) ||  Key Store Util . is Windows Key Store ( ks . get Type ( ) ) ) { throw une ; } if ( pkey != null ) { pp = new  Password Protection ( pkey ) ; entry = ks . get Entry ( alias , pp ) ; } else { try { pp = new  Password Protection ( pstore ) ; entry = ks . get Entry ( alias , pp ) ; pkey = pstore ; } catch (  Unrecoverable Entry Exception une2 ) { if (  P12 KEYSTORE . equals Ignore Case ( ks . get Type ( ) ) ) { throw une2 ; } else { pkey = get Key Passwd ( alias , null , null ) ; pp = new  Password Protection ( pkey ) ; entry = ks . get Entry ( alias , pp ) ; } } } } return  Pair . of ( entry , pkey ) ; }
URLClass Loader new Loader (  URL base ) { return new  URLClass Loader ( new  URL [ ] { base } ) ; }
public  Wiser ( ) { this . server = new  SMTPServer ( new  Simple Message Listener Adapter ( this ) ) ; }
protected static int [ ] concat ( @  Nullable int [ ] arr , int ... obj ) { int [ ] new Arr ; if ( arr == null || arr . length == _ NUM ) new Arr = obj ; else { new Arr =  Arrays . copy Of ( arr , arr . length + obj . length ) ;  System . arraycopy ( obj , _ NUM , new Arr , arr . length , obj . length ) ; } return new Arr ; }
public void truck Camera ( float size ) { move To Position ( - ( float ) ( target Xoff + ( size *  Math . sin (  Math . to Radians ( zrot - _ NUM ) ) ) ) , - ( float ) ( target Yoff + ( size *  Math . cos (  Math . to Radians ( zrot - _ NUM ) ) ) ) ) ; }
public static byte [ ] decode2 (  String encoded ) { if ( encoded == null ) { return null ; } char [ ] base64 Data = encoded . to Char Array ( ) ; int len = remove White Space ( base64 Data ) ; if ( len %  FOURBYTE != _ NUM ) { return null ; } int number Quadruple = ( len /  FOURBYTE ) ; if ( number Quadruple == _ NUM ) { return new byte [ _ NUM ] ; } byte decoded Data [ ] = null ; byte b1 = _ NUM , b2 = _ NUM , b3 = _ NUM , b4 = _ NUM ; char d1 = _ NUM , d2 = _ NUM , d3 = _ NUM , d4 = _ NUM ; int i = _ NUM ; int encoded Index = _ NUM ; int data Index = _ NUM ; decoded Data = new byte [ ( number Quadruple ) * _ NUM ] ; for ( ; i < number Quadruple - _ NUM ; i ++ ) { if ( ! is Data ( ( d1 = base64 Data [ data Index ++ ] ) ) || ! is Data ( ( d2 = base64 Data [ data Index ++ ] ) ) || ! is Data ( ( d3 = base64 Data [ data Index ++ ] ) ) || ! is Data ( ( d4 = base64 Data [ data Index ++ ] ) ) ) { return null ; } b1 = base64 Alphabet [ d1 ] ; b2 = base64 Alphabet [ d2 ] ; b3 = base64 Alphabet [ d3 ] ; b4 = base64 Alphabet [ d4 ] ; decoded Data [ encoded Index ++ ] = ( byte ) ( b1 << _ NUM | b2 > > _ NUM ) ; decoded Data [ encoded Index ++ ] = ( byte ) ( ( ( b2 & _ NUM ) << _ NUM ) | ( ( b3 > > _ NUM ) & _ NUM ) ) ; decoded Data [ encoded Index ++ ] = ( byte ) ( b3 << _ NUM | b4 ) ; } if ( ! is Data ( ( d1 = base64 Data [ data Index ++ ] ) ) || ! is Data ( ( d2 = base64 Data [ data Index ++ ] ) ) ) { return null ; } b1 = base64 Alphabet [ d1 ] ; b2 = base64 Alphabet [ d2 ] ; d3 = base64 Data [ data Index ++ ] ; d4 = base64 Data [ data Index ++ ] ; if ( ! is Data ( ( d3 ) ) || ! is Data ( ( d4 ) ) ) { if ( is Pad ( d3 ) && is Pad ( d4 ) ) { if ( ( b2 & _ NUM ) != _ NUM ) { return null ; } byte [ ] tmp = new byte [ i * _ NUM + _ NUM ] ;  System . arraycopy ( decoded Data , _ NUM , tmp , _ NUM , i * _ NUM ) ; tmp [ encoded Index ] = ( byte ) ( b1 << _ NUM | b2 > > _ NUM ) ; return tmp ; } else if ( ! is Pad ( d3 ) && is Pad ( d4 ) ) { b3 = base64 Alphabet [ d3 ] ; if ( ( b3 & _ NUM ) != _ NUM ) { return null ; } byte [ ] tmp = new byte [ i * _ NUM + _ NUM ] ;  System . arraycopy ( decoded Data , _ NUM , tmp , _ NUM , i * _ NUM ) ; tmp [ encoded Index ++ ] = ( byte ) ( b1 << _ NUM | b2 > > _ NUM ) ; tmp [ encoded Index ] = ( byte ) ( ( ( b2 & _ NUM ) << _ NUM ) | ( ( b3 > > _ NUM ) & _ NUM ) ) ; return tmp ; } else { return null ; } } else { b3 = base64 Alphabet [ d3 ] ; b4 = base64 Alphabet [ d4 ] ; decoded Data [ encoded Index ++ ] = ( byte ) ( b1 << _ NUM | b2 > > _ NUM ) ; decoded Data [ encoded Index ++ ] = ( byte ) ( ( ( b2 & _ NUM ) << _ NUM ) | ( ( b3 > > _ NUM ) & _ NUM ) ) ; decoded Data [ encoded Index ++ ] = ( byte ) ( b3 << _ NUM | b4 ) ; } return decoded Data ; }
public void shutdown ( ) { scheduled Executor Service . shutdown Now ( ) ; }
public static  String deflate (  String previous ,  String current ) { if ( previous == null ) return current ;  String Builder buf = new  String Builder ( ) ; int start1 = _ NUM ; int start2 = _ NUM ; while ( start1 < previous . length ( ) && start2 < current . length ( ) ) { int end1 = start1 ; int end2 = start2 ; while ( end1 <= previous . length ( ) && end2 <= current . length ( ) ) { int c1 = ( end1 < previous . length ( ) ? previous . char At ( end1 ) : _ STR ) ; int c2 = ( end2 < current . length ( ) ? current . char At ( end2 ) : _ STR ) ; if ( c1 == c2 ) { if ( c1 == _ STR ) { buf . append ( _ STR ) ; break ; } else { end1 ++ ; end2 ++ ; } } else { while ( end1 < previous . length ( ) && previous . char At ( end1 ) != _ STR ) { end1 ++ ; } while ( end2 < current . length ( ) && current . char At ( end2 ) != _ STR ) { end2 ++ ; } for ( int i = start2 ; i < end2 ; i ++ ) buf . append ( current . char At ( i ) ) ; break ; } } start1 = end1 + _ NUM ; start2 = end2 + _ NUM ; if ( start2 < current . length ( ) ) buf . append ( _ STR ) ; } return buf . to String ( ) ; }
protected int split List Index (  List <  Pair <  Double ,  Integer > >  S ) { return  S . size ( ) / _ NUM ; }
public static synchronized void add Property Change Listener (  Property Change Listener l ) { if ( ! listeners . contains ( l ) ) { listeners . add ( l ) ; } }
private static void clean Directory (  File path ) { if ( path == null ) return ; if ( path . exists ( ) ) { for (  File f : path . list Files ( ) ) { if ( f . is Directory ( ) ) clean Directory ( f ) ; f . delete ( ) ; } } }
private  Grid Cache Version min Version (  Iterable <  Ignite Tx Entry > entries ,  Grid Cache Version min ,  Ignite Internal Tx tx ) { for (  Ignite Tx Entry tx Entry : entries ) {  Grid Cache Entry Ex cached = tx Entry . cached ( ) ; assert tx Entry . is Read ( ) || ! cached . obsolete ( tx . xid Version ( ) ) : _ STR + cached + _ STR + tx + _ STR ; for (  Grid Cache Mvcc Candidate cand : cached . remote Mvcc Snapshot ( ) ) if ( min == null || cand . version ( ) . is Less ( min ) ) min = cand . version ( ) ; } return min ; }
public  Dimensioned Scalar (  String field Value ) throws  Illegal Argument Exception { super ( _ STR , _ STR ) ;  Matcher matcher =  PATTERN . matcher ( field Value ) ; if ( matcher . find ( ) ) {  String name = matcher . group ( _ NUM ) ;  String dimensions = matcher . group ( _ NUM ) ;  String value = matcher . group ( _ NUM ) ; set Name ( name ) ; set Value ( value ) ; this . dimensions = new  Dimensions ( dimensions ) ; } else { throw new  Dictionary Exception ( _ STR + field Value + _ STR ) ; } }
public void characters ( char ch [ ] , int start , int length ) throws  SAXException { m_value Buffer . append ( ch , start , length ) ; }
protected double compute Std Dev (  Instance inst ,  Matrix k ) throws  Exception { double kappa = m_kernel . eval ( - _ NUM , - _ NUM , inst ) + m_delta Squared ; double s = _ NUM ; int n = m_ L . length ; for ( int i = _ NUM ; i < n ; i ++ ) { double t = _ NUM ; for ( int j = _ NUM ; j < n ; j ++ ) { t -= k . get ( j , _ NUM ) * ( i > j ? m_ L [ i ] [ j ] : m_ L [ j ] [ i ] ) ; } s += t * k . get ( i , _ NUM ) ; } double sigma = m_delta ; if ( kappa > s ) { sigma =  Math . sqrt ( kappa - s ) ; } return sigma ; }
protected void initialize (  Properties p ) { }
public void add ( int index , int element ) { check Range Including Endpoint ( index ) ; ensure Capacity ( size + _ NUM ) ; int numtomove = size - index ;  System . arraycopy ( array , index , array , index + _ NUM , numtomove ) ; array [ index ] = element ; size ++ ; }
public  Multiplex Manager (  Data Store ... data Stores ) { this . data Stores =  Arrays . as List ( data Stores ) ; }
public boolean matches Raw Name Pattern (  Object item ) {  String prefix = pattern Matcher . get Pattern ( ) ;  String text = get Element Name ( item ) ; if ( text == null ) return _ BOOL ; int text Length = text . length ( ) ; int prefix Length = prefix . length ( ) ; if ( text Length < prefix Length ) { return _ BOOL ; } for ( int i = prefix Length - _ NUM ; i >= _ NUM ; i -- ) { if (  Character . to Lower Case ( prefix . char At ( i ) ) !=  Character . to Lower Case ( text . char At ( i ) ) ) return _ BOOL ; } return _ BOOL ; }
public static @  Nonnull <  T >  T value Or Default ( @  Nullable  T value , @  Nonnull  T default Value ) { return value == null ? default Value : value ; }
protected abstract int compare To Last Msg (  Pair <  K ,  V > tuple Key Value ,  Pair < byte [ ] , byte [ ] > last Received Key Value ) ;
private void parse Menu (  Xml Pull Parser parser ,  Attribute Set attrs ,  Sublime Menu menu ) throws  Xml Pull Parser Exception ,  IOException {  Menu State menu State = new  Menu State ( menu ) ; int event Type = parser . get Event Type ( ) ;  String tag Name ; boolean looking For End Of Unknown Tag = _ BOOL ;  String unknown Tag Name = null ; do { if ( event Type ==  Xml Pull Parser .  START_ TAG ) { tag Name = parser . get Name ( ) ; if ( tag Name . equals (  XML_ MENU ) ) { event Type = parser . next ( ) ; break ; } throw new  Runtime Exception ( _ STR + tag Name ) ; } event Type = parser . next ( ) ; } while ( event Type !=  Xml Pull Parser .  END_ DOCUMENT ) ; boolean reached End Of Menu = _ BOOL ; while ( ! reached End Of Menu ) { switch ( event Type ) { case  Xml Pull Parser .  START_ TAG : if ( looking For End Of Unknown Tag ) { break ; } tag Name = parser . get Name ( ) ; if ( tag Name . equals (  XML_ GROUP ) ) { if ( menu State . group Id !=  Menu State . default Group Id ) { throw new  Runtime Exception ( _ STR + _ STR ) ; } menu State . read Group ( attrs ) ; menu State . add Group ( ) ; } else if ( tag Name . equals (  XML_ TEXT ) || tag Name . equals (  XML_ TEXT_ WITH_ BADGE ) || tag Name . equals (  XML_ CHECKBOX ) || tag Name . equals (  XML_ SWITCH ) ) { menu State . read Menu Item ( attrs , tag Name ) ; } else if ( tag Name . equals (  XML_ SEPARATOR ) ) { menu State . read Menu Item ( attrs , tag Name ) ; } else if ( tag Name . equals (  XML_ GROUP_ HEADER ) ) { if ( menu State . group Id ==  Menu State . default Group Id ) { throw new  Runtime Exception ( _ STR + _ STR ) ; } menu State . read Menu Item ( attrs , tag Name ) ; } else if ( tag Name . equals (  XML_ MENU ) ) { throw new  Runtime Exception ( _ STR + _ STR + _ STR ) ; } else { looking For End Of Unknown Tag = _ BOOL ; unknown Tag Name = tag Name ; } break ; case  Xml Pull Parser .  END_ TAG : tag Name = parser . get Name ( ) ; if ( looking For End Of Unknown Tag && tag Name . equals ( unknown Tag Name ) ) { looking For End Of Unknown Tag = _ BOOL ; unknown Tag Name = null ; } else if ( tag Name . equals (  XML_ GROUP ) ) { if ( menu State . is Group Collapsible ( ) && menu State . group Headers Added != _ NUM ) { if ( menu State . group Headers Added < _ NUM ) { throw new  Runtime Exception ( _ STR + _ STR ) ; } else { throw new  Runtime Exception ( _ STR + _ STR + menu State . group Headers Added + _ STR ) ; } } menu State . reset Group ( ) ; } else if ( tag Name . equals (  XML_ TEXT ) || tag Name . equals (  XML_ TEXT_ WITH_ BADGE ) || tag Name . equals (  XML_ CHECKBOX ) || tag Name . equals (  XML_ SWITCH ) || tag Name . equals (  XML_ GROUP_ HEADER ) || tag Name . equals (  XML_ SEPARATOR ) ) { if ( ! menu State . has Added Item ( ) ) { menu State . add Item ( ) ; } } else if ( tag Name . equals (  XML_ MENU ) ) { reached End Of Menu = _ BOOL ; } break ; case  Xml Pull Parser .  END_ DOCUMENT : throw new  Runtime Exception ( _ STR ) ; } event Type = parser . next ( ) ; } }
public static double cross Track Distance Rad ( double lat1 , double lon1 , double lat2 , double lon2 , double lat Q , double lon Q ) { final double dlon12 = lon2 - lon1 ; final double dlon1 Q = lon Q - lon1 ; final double dlat1 Q = lat Q - lat1 ; final double clat1 =  Math . cos ( lat1 ) , slat1 =  Math Util . cos To Sin ( lat1 , clat1 ) ; final double clat Q =  Math . cos ( lat Q ) , slat Q =  Math Util . cos To Sin ( lat Q , clat Q ) ; final double clat2 =  Math . cos ( lat2 ) , slat2 =  Math Util . cos To Sin ( lat2 , clat2 ) ; final double slat =  Math . sin ( dlat1 Q * _ NUM ) ; final double slon =  Math . sin ( dlon1 Q * _ NUM ) ; final double a = slat * slat + slon * slon * clat1 * clat Q ; final double ang Dist1 Q = _ NUM *  Math . atan2 (  Math . sqrt ( a ) ,  Math . sqrt ( _ NUM - a ) ) ; final double sdlon12 =  Math . sin ( dlon12 ) , cdlon12 =  Math Util . sin To Cos ( dlon12 , sdlon12 ) ; final double sdlon1 Q =  Math . sin ( dlon1 Q ) , cdlon1 Q =  Math Util . sin To Cos ( dlon1 Q , sdlon1 Q ) ; final double y E = sdlon12 * clat2 ; final double y Q = sdlon1 Q * clat Q ; final double x E = clat1 * slat2 - slat1 * clat2 * cdlon12 ; final double x Q = clat1 * slat Q - slat1 * clat Q * cdlon1 Q ; final double crs12 =  Math . atan2 ( y E , x E ) ; final double crs1 Q =  Math . atan2 ( y Q , x Q ) ; return  Math . asin (  Math . sin ( ang Dist1 Q ) *  Math . sin ( crs1 Q - crs12 ) ) ; }
public  String choose Server Alias (  String key Type ,  Principal [ ] issuers ,  Socket socket ) { return default X509 KM . choose Server Alias ( key Type , issuers , socket ) ; }
public static double pdf ( double x , double shape , double scale , double factor ) { if ( x <= _ NUM ) return _ NUM ; final double a =  Math . exp ( shape *  Math . log ( scale ) - ( shape + _ NUM ) *  Math . log ( x ) - ( scale / x ) -  Gamma Function . ln Gamma ( shape ) ) ; return factor * a ; }
public  String charge (  Properties ctx , int  Window No ,  Grid Tab m Tab ,  Grid Field m Field ,  Object value ) {  Integer  C_ Charge_ ID = (  Integer ) value ; if (  C_ Charge_ ID == null ||  C_ Charge_ ID . int Value ( ) == _ NUM ) return _ STR ;  String sql = _ STR ;  Prepared Statement pstmt = null ;  Result Set rs = null ; try { pstmt =  DB . prepare Statement ( sql , null ) ; pstmt . set Int ( _ NUM ,  C_ Charge_ ID . int Value ( ) ) ; rs = pstmt . execute Query ( ) ; if ( rs . next ( ) ) { m Tab . set Value ( _ STR , rs . get Big Decimal ( _ NUM ) ) ; } } catch (  SQLException e ) { log . log (  Level .  SEVERE , sql , e ) ; return e . get Localized Message ( ) ; } finally {  DB . close ( rs , pstmt ) ; rs = null ; pstmt = null ; } return tax ( ctx ,  Window No , m Tab , m Field , value ) ; }
protected  Array <  Actor > parse ( ) { actors =  Gdx Arrays . new Array (  Actor . class ) ; invoke Pre Listeners ( actors ) ; final  String Builder builder = new  String Builder ( ) ; while ( template Reader . has Next Character ( ) ) { final char character = template Reader . next Character ( ) ; if ( character == syntax . get Argument Opening ( ) ) { process Argument ( ) ; } else if ( character == syntax . get Tag Opening ( ) ) { if ( is Next Character Comment Opening ( ) ) { process Comment ( ) ; continue ; } if ( current Parent Tag != null ) { current Parent Tag . handle Data Between Tags ( builder ) ; }  Strings . clear Builder ( builder ) ; process Tag ( builder ) ; } else { builder . append ( character ) ; } } if ( current Parent Tag != null ) { throw Error ( _ STR + current Parent Tag . get Tag Name ( ) + _ STR ) ; } invoke Port Listeners ( actors ) ; return actors ; }
public void test ABand CBbroker Network ( ) throws  Exception { bridge Brokers ( _ STR , _ STR ) ; bridge Brokers ( _ STR , _ STR ) ; start All Brokers ( ) ;  Destination dest = create Destination ( _ STR , _ BOOL ) ;  Message Consumer client A = create Consumer ( _ STR , dest ) ;  Message Consumer client B = create Consumer ( _ STR , dest ) ;  Message Consumer client C = create Consumer ( _ STR , dest ) ;  Thread . sleep ( _ NUM ) ; send Messages ( _ STR , dest ,  MESSAGE_ COUNT ) ; send Messages ( _ STR , dest ,  MESSAGE_ COUNT ) ; send Messages ( _ STR , dest ,  MESSAGE_ COUNT ) ;  Message Id List msgs A = get Consumer Messages ( _ STR , client A ) ;  Message Id List msgs B = get Consumer Messages ( _ STR , client B ) ;  Message Id List msgs C = get Consumer Messages ( _ STR , client C ) ; msgs A . wait For Messages To Arrive (  MESSAGE_ COUNT ) ; msgs B . wait For Messages To Arrive (  MESSAGE_ COUNT * _ NUM ) ; msgs C . wait For Messages To Arrive (  MESSAGE_ COUNT ) ; assert Equals (  MESSAGE_ COUNT , msgs A . get Message Count ( ) ) ; assert Equals (  MESSAGE_ COUNT * _ NUM , msgs B . get Message Count ( ) ) ; assert Equals (  MESSAGE_ COUNT , msgs C . get Message Count ( ) ) ; }
public void flush ( ) throws  IOException {  Wsp Util . write Uint8 ( os_ , _ NUM ) ; write Public Identifier ( os_ , public ID_ ) ;  Wsp Util . write Uintvar ( os_ ,  Wap Constants .  MIB_ ENUM_ UTF_8 ) ; write String Table ( os_ ) ; wbxml Body_ . close ( ) ; wbxml Body_ . write To ( os_ ) ; os_ . flush ( ) ; }
public static void discard ( ) { current . remove ( ) ; }
private  Token to ASIToken (  ILeaf Node leaf ) { if ( leaf . is Hidden ( ) ) { return new Semicolon Token ( leaf ) ; } else { if ( ! leaf Nodes . has Next ( ) ) { int token Type = token Type Mapper . get Internal Token Type ( leaf ) ; int semicolon Token Type = token Type Mapper . get Internal Token Type ( semicolon ) ; if ( token Type == semicolon Token Type ) { return new  Common Token ( semicolon Token Type , leaf . get Text ( ) ) ; } if ( leaf . get Total End Offset ( ) == end Offset ) { leaf Nodes =  Iterators . empty Iterator ( ) ; return new  Common Token ( token Type , leaf . get Text ( ) ) ; } next = new  Common Token ( semicolon Token Type , leaf . get Text ( ) ) ; return new  Common Token ( token Type , leaf . get Text ( ) ) ; } else if ( leaf . get Grammar Element ( ) == right Curly In Block || leaf . get Grammar Element ( ) == right Curly In Arrow Expression ) { int token Type = token Type Mapper . get Internal Token Type ( leaf ) ; next = new  Common Token ( token Type ) ; return new  Common Token ( token Type Mapper . get Internal Token Type ( semicolon ) , leaf . get Text ( ) ) ; } else { return new Semicolon Token ( leaf ) ; } } }
@  Override public  Packet Buffer write (  Packet Buffer buf ) { values . for Each ( null ) ; return buf ; }
public final void register File Type ( @  Not Null  File Type type , @  Non Nls @  Nullable  String ... default Associated Extensions ) {  List <  File Name Matcher > matchers = new  Array List <  File Name Matcher > ( ) ; if ( default Associated Extensions != null ) { for (  String extension : default Associated Extensions ) { matchers . add ( new  Extension File Name Matcher ( extension ) ) ; } } register File Type ( type , matchers ) ; }
public int parse Int (  String locale Formatted Integer ) { return  Integer . parse Int ( locale Formatted Integer ) ; }
public static  Request Security Token Response parse XML (  String xml ) throws  WSFederation Exception {  Document doc =  XMLUtils . to DOMDocument ( xml , debug ) ;  Element root = doc . get Document Element ( ) ; return new  Request Security Token Response ( root ) ; }
@  Override public void request Resources (  Samza Resource Request resource Request ) { final int  DEFAULT_ PRIORITY = _ NUM ; log . info ( _ STR + resource Request . get Preferred Host ( ) + _ STR + resource Request . get Container ID ( ) ) ; int memory Mb = resource Request . get Memory MB ( ) ; int cpu Cores = resource Request . get Num Cores ( ) ;  String container Label = yarn Config . get Container Label ( ) ;  String preferred Host = resource Request . get Preferred Host ( ) ;  Resource capability =  Resource . new Instance ( memory Mb , cpu Cores ) ;  Priority priority =  Priority . new Instance (  DEFAULT_ PRIORITY ) ;  AMRMClient .  Container Request issued Request ; if ( preferred Host . equals ( _ STR ) ) { log . info ( _ STR + preferred Host ) ; issued Request = new  AMRMClient .  Container Request ( capability , null , null , priority , _ BOOL , container Label ) ; } else { log . info ( _ STR + preferred Host ) ; issued Request = new  AMRMClient .  Container Request ( capability , new  String [ ] { preferred Host } , null , priority , _ BOOL , container Label ) ; } synchronized ( lock ) { requests Map . put ( resource Request , issued Request ) ; am Client . add Container Request ( issued Request ) ; } }
private  Collection <  Extracted Items Collection > filter Items By Level (  Player player ,  List <  Extracted Items Collection > items Collections ) { int player Level = player . get Level ( ) ;  Collection <  Extracted Items Collection > result = new  Array List <  Extracted Items Collection > ( ) ; for (  Extracted Items Collection collection : items Collections ) { if ( collection . get Min Level ( ) > player Level ) { continue ; } if ( collection . get Max Level ( ) > _ NUM && collection . get Max Level ( ) < player Level ) { continue ; } result . add ( collection ) ; } return result ; }
private  String print DFormat (  String sx ) { int n Leading Zeros = _ NUM ; int n Blanks = _ NUM , n = _ NUM ; int i = _ NUM ; final int j First ; final boolean neg = sx . char At ( _ NUM ) == _ STR ; if ( sx . equals ( _ STR ) && precision Set && precision == _ NUM ) { sx = _ STR ; } if ( ! neg ) { if ( precision Set && sx . length ( ) < precision ) { n Leading Zeros = precision - sx . length ( ) ; } } else { if ( precision Set && ( sx . length ( ) - _ NUM ) < precision ) { n Leading Zeros = precision - sx . length ( ) + _ NUM ; } } if ( n Leading Zeros < _ NUM ) { n Leading Zeros = _ NUM ; } if ( field Width Set ) { n Blanks = field Width - n Leading Zeros - sx . length ( ) ; if ( ! neg && ( leading Sign || leading Space ) ) { n Blanks -- ; } } if ( n Blanks < _ NUM ) { n Blanks = _ NUM ; } if ( leading Sign ) { n ++ ; } else if ( leading Space ) { n ++ ; } n += n Blanks ; n += n Leading Zeros ; n += sx . length ( ) ; final char [ ] ca = new char [ n ] ; if ( left Justify ) { if ( neg ) { ca [ i ++ ] = _ STR ; } else if ( leading Sign ) { ca [ i ++ ] = _ STR ; } else if ( leading Space ) { ca [ i ++ ] = _ STR ; } final char [ ] csx = sx . to Char Array ( ) ; j First = neg ? _ NUM : _ NUM ; for ( int j = _ NUM ; j < n Leading Zeros ; i ++ , j ++ ) { ca [ i ] = _ STR ; } for ( int j = j First ; j < csx . length ; j ++ , i ++ ) { ca [ i ] = csx [ j ] ; } for ( int j = _ NUM ; j < n Blanks ; i ++ , j ++ ) { ca [ i ] = _ STR ; } } else { if ( ! leading Zeros ) { for ( i = _ NUM ; i < n Blanks ; i ++ ) { ca [ i ] = _ STR ; } if ( neg ) { ca [ i ++ ] = _ STR ; } else if ( leading Sign ) { ca [ i ++ ] = _ STR ; } else if ( leading Space ) { ca [ i ++ ] = _ STR ; } } else { if ( neg ) { ca [ i ++ ] = _ STR ; } else if ( leading Sign ) { ca [ i ++ ] = _ STR ; } else if ( leading Space ) { ca [ i ++ ] = _ STR ; } for ( int j = _ NUM ; j < n Blanks ; j ++ , i ++ ) { ca [ i ] = _ STR ; } } for ( int j = _ NUM ; j < n Leading Zeros ; j ++ , i ++ ) { ca [ i ] = _ STR ; } final char [ ] csx = sx . to Char Array ( ) ; j First = neg ? _ NUM : _ NUM ; for ( int j = j First ; j < csx . length ; j ++ , i ++ ) { ca [ i ] = csx [ j ] ; } } return new  String ( ca ) ; }
private void draw Host (  Graphics2 D g2 ) {  Coord loc = node . get Location ( ) ; if ( draw Coverage && node . is Radio Active ( ) ) {  Array List <  Network Interface > interfaces = new  Array List <  Network Interface > ( ) ; interfaces . add All ( node . get Interfaces ( ) ) ; for (  Network Interface ni : interfaces ) { double range = ni . get Transmit Range ( ) ;  Ellipse2 D .  Double coverage ; coverage = new  Ellipse2 D .  Double ( scale ( loc . get X ( ) - range ) , scale ( loc . get Y ( ) - range ) , scale ( range * _ NUM ) , scale ( range * _ NUM ) ) ; g2 . set Color ( range Color ) ; g2 . draw ( coverage ) ; } } if ( draw Connections ) { g2 . set Color ( con Color ) ;  Coord c1 = node . get Location ( ) ;  Array List <  Connection > con List = new  Array List <  Connection > ( ) ; con List . add All ( node . get Connections ( ) ) ; for (  Connection c : con List ) {  DTNHost other Node = c . get Other Node ( node ) ;  Coord c2 ; if ( other Node == null ) { continue ; } c2 = other Node . get Location ( ) ; g2 . draw Line ( scale ( c1 . get X ( ) ) , scale ( c1 . get Y ( ) ) , scale ( c2 . get X ( ) ) , scale ( c2 . get Y ( ) ) ) ; } } g2 . set Color ( host Color ) ; g2 . draw Rect ( scale ( loc . get X ( ) - _ NUM ) , scale ( loc . get Y ( ) - _ NUM ) , scale ( _ NUM ) , scale ( _ NUM ) ) ; if ( is Highlighted ( ) ) { g2 . set Color ( highlighted Node Color ) ; g2 . fill Rect ( scale ( loc . get X ( ) ) - _ NUM , scale ( loc . get Y ( ) ) - _ NUM , _ NUM , _ NUM ) ; } if ( draw Node Name ) { g2 . set Color ( host Name Color ) ; g2 . draw String ( node . to String ( ) , scale ( loc . get X ( ) ) , scale ( loc . get Y ( ) ) ) ; } }
public boolean add ( symbol sym ) throws internal_error {  Object previous ; not_null ( sym ) ; previous = _all . put ( sym . name ( ) , sym ) ; return previous == null ; }
public final int size ( ) { if (  GWT . is Script ( ) ) { return js Array . size ( ) ; } else { return java Array . size ( ) ; } }
public boolean intersects ( final  Planet Model planet Model , final  Plane q , final  Geo Point [ ] notable Points , final  Geo Point [ ] more Notable Points , final  Membership [ ] bounds , final  Membership ... more Bounds ) { if ( is Numerically Identical ( q ) ) { for (  Geo Point p : notable Points ) { if ( meets All Bounds ( p , bounds , more Bounds ) ) { return _ BOOL ; } } for (  Geo Point p : more Notable Points ) { if ( meets All Bounds ( p , bounds , more Bounds ) ) { return _ BOOL ; } } return _ BOOL ; } final double line Vector X = y * q . z - z * q . y ; final double line Vector Y = z * q . x - x * q . z ; final double line Vector Z = x * q . y - y * q . x ; if (  Math . abs ( line Vector X ) <  MINIMUM_ RESOLUTION &&  Math . abs ( line Vector Y ) <  MINIMUM_ RESOLUTION &&  Math . abs ( line Vector Z ) <  MINIMUM_ RESOLUTION ) { return _ BOOL ; } double x0 ; double y0 ; double z0 ; final double denom YZ = this . y * q . z - this . z * q . y ; final double denom XZ = this . x * q . z - this . z * q . x ; final double denom XY = this . x * q . y - this . y * q . x ; if (  Math . abs ( denom YZ ) >=  Math . abs ( denom XZ ) &&  Math . abs ( denom YZ ) >=  Math . abs ( denom XY ) ) { if (  Math . abs ( denom YZ ) <  MINIMUM_ RESOLUTION_ SQUARED ) { return _ BOOL ; } final double denom = _ NUM / denom YZ ; x0 = _ NUM ; y0 = ( - this .  D * q . z - this . z * - q .  D ) * denom ; z0 = ( this . y * - q .  D + this .  D * q . y ) * denom ; } else if (  Math . abs ( denom XZ ) >=  Math . abs ( denom XY ) &&  Math . abs ( denom XZ ) >=  Math . abs ( denom YZ ) ) { if (  Math . abs ( denom XZ ) <  MINIMUM_ RESOLUTION_ SQUARED ) { return _ BOOL ; } final double denom = _ NUM / denom XZ ; x0 = ( - this .  D * q . z - this . z * - q .  D ) * denom ; y0 = _ NUM ; z0 = ( this . x * - q .  D + this .  D * q . x ) * denom ; } else { if (  Math . abs ( denom XY ) <  MINIMUM_ RESOLUTION_ SQUARED ) { return _ BOOL ; } final double denom = _ NUM / denom XY ; x0 = ( - this .  D * q . y - this . y * - q .  D ) * denom ; y0 = ( this . x * - q .  D + this .  D * q . x ) * denom ; z0 = _ NUM ; } final double  A = line Vector X * line Vector X * planet Model . inverse Ab Squared + line Vector Y * line Vector Y * planet Model . inverse Ab Squared + line Vector Z * line Vector Z * planet Model . inverse CSquared ; final double  B = _ NUM * ( line Vector X * x0 * planet Model . inverse Ab Squared + line Vector Y * y0 * planet Model . inverse Ab Squared + line Vector Z * z0 * planet Model . inverse CSquared ) ; final double  C = x0 * x0 * planet Model . inverse Ab Squared + y0 * y0 * planet Model . inverse Ab Squared + z0 * z0 * planet Model . inverse CSquared - _ NUM ; final double  Bsquared Minus =  B *  B - _ NUM *  A *  C ; if (  Math . abs (  Bsquared Minus ) <  MINIMUM_ RESOLUTION_ SQUARED ) { final double inverse2 A = _ NUM / ( _ NUM *  A ) ; final double t = -  B * inverse2 A ; final double point X = line Vector X * t + x0 ; final double point Y = line Vector Y * t + y0 ; final double point Z = line Vector Z * t + z0 ; for ( final  Membership bound : bounds ) { if ( ! bound . is Within ( point X , point Y , point Z ) ) { return _ BOOL ; } } for ( final  Membership bound : more Bounds ) { if ( ! bound . is Within ( point X , point Y , point Z ) ) { return _ BOOL ; } } return _ BOOL ; } else if (  Bsquared Minus > _ NUM ) { final double inverse2 A = _ NUM / ( _ NUM *  A ) ; final double sqrt Term =  Math . sqrt (  Bsquared Minus ) ; final double t1 = ( -  B + sqrt Term ) * inverse2 A ; final double t2 = ( -  B - sqrt Term ) * inverse2 A ; final double point1 X = line Vector X * t1 + x0 ; final double point1 Y = line Vector Y * t1 + y0 ; final double point1 Z = line Vector Z * t1 + z0 ; boolean point1 Valid = _ BOOL ; for ( final  Membership bound : bounds ) { if ( ! bound . is Within ( point1 X , point1 Y , point1 Z ) ) { point1 Valid = _ BOOL ; break ; } } if ( point1 Valid ) { for ( final  Membership bound : more Bounds ) { if ( ! bound . is Within ( point1 X , point1 Y , point1 Z ) ) { point1 Valid = _ BOOL ; break ; } } } if ( point1 Valid ) { return _ BOOL ; } final double point2 X = line Vector X * t2 + x0 ; final double point2 Y = line Vector Y * t2 + y0 ; final double point2 Z = line Vector Z * t2 + z0 ; for ( final  Membership bound : bounds ) { if ( ! bound . is Within ( point2 X , point2 Y , point2 Z ) ) { return _ BOOL ; } } for ( final  Membership bound : more Bounds ) { if ( ! bound . is Within ( point2 X , point2 Y , point2 Z ) ) { return _ BOOL ; } } return _ BOOL ; } else { return _ BOOL ; } }
public double  Sum Outlink Authority Score (  Page page ) {  List <  String > out Links = page . get Outlinks ( ) ; double auth Score = _ NUM ; for ( int i = _ NUM ; i < out Links . size ( ) ; i ++ ) {  Page out Link = p Table . get ( out Links . get ( i ) ) ; if ( out Link != null ) { auth Score += out Link . authority ; } } return auth Score ; }
public synchronized void end ( ) { graphics To Be Drawn . close ( ) ; if ( current Graphics != null ) { graphics Drawn . append ( current Graphics ) ; } graphics Drawn . close When Empty ( ) ; if ( printer Job Thread != null && printer Job Thread . is Alive ( ) ) { try { printer Job Thread . join ( ) ; } catch (  Interrupted Exception e ) { } } }
public  List <  File Status > browse (  String file Path ) throws  Exception {  LOG . info ( _ STR + file Path + _ STR + hdfs End Point ) ;  File System hdfs File System = null ;  File Status [ ] list Status ; try {  Configuration config = create Config ( ) ; hdfs File System = get File System ( config ) ;  Path path = new  Path ( file Path ) ; list Status = hdfs File System . list Status ( path ) ; } catch (  Exception ex ) {  LOG . error ( _ STR + file Path , ex . get Message ( ) ) ; throw new  Exception ( _ STR + ex . get Message ( ) ) ; } finally { if ( hdfs File System != null ) hdfs File System . close ( ) ; } return  Arrays . as List ( list Status ) ; }
public  Eip Model Wizard Initial Object Creation Page (  String page Id ) { super ( page Id ) ; }
private void unwrap Data ( ) throws  Ignite Checked Exception ,  SSLException { if ( log . is Debug Enabled ( ) ) log . debug ( _ STR ) ; in Net Buf . flip ( ) ;  SSLEngine Result res = unwrap0 ( ) ; in Net Buf . compact ( ) ; check Status ( res ) ; renegotiate If Needed ( res ) ; }
private static void check Permission ( ) throws  Security Exception {  Security Manager sm =  System . get Security Manager ( ) ; if ( sm != null ) { sm . check Permission ( new  Joda Time Permission ( _ STR ) ) ; } }
private void store Password (  String password ) { if ( is Store && shared State != null ) { shared State . put ( get Pwd Key ( ) , password ) ; } }
void delete Child (  Policy Node child Node ) { if ( is Immutable ) { throw new  Illegal State Exception ( _ STR ) ; } m Children . remove ( child Node ) ; }
public  External Process Result await Termination And Result ( int timeout Ms , boolean destroy On Error ) throws  Interrupted Exception ,  Timeout Exception ,  Operation Cancellation ,  IOException { await Termination ( timeout Ms , destroy On Error ) ; return new  External Process Result ( process . exit Value ( ) , get Std Out Bytes ( ) , get Std Err Bytes ( ) ) ; }
public void refresh Inherited Methods (  Set modified Super Expandos ) { for (  Iterator i = modified Super Expandos . iterator ( ) ; i . has Next ( ) ; ) {  Expando Meta Class super Expando = (  Expando Meta Class ) i . next ( ) ; if ( super Expando != this ) { refresh Inherited Methods ( super Expando ) ; } } }
public static  List <  Fragment > parse Placeholder (  String parse String ) throws  Placeholder Parse Exception {  List <  Fragment > result = new  Array List <  Fragment > ( ) ; int curr Output Index = _ NUM ; int curr Search Index = _ NUM ; while ( _ BOOL ) { if ( curr Search Index == parse String . length ( ) ) { break ; } int start Index = parse String . index Of ( _ STR , curr Search Index ) ; if ( start Index == - _ NUM ) { if ( curr Output Index < parse String . length ( ) ) {  String end String = parse String . substring ( curr Output Index , parse String . length ( ) ) ;  Text Fragment text Fragment = new  Text Fragment ( end String ) ; result . add ( text Fragment ) ; } break ; } if ( start Index > _ NUM ) {  String text So Far = parse String . substring ( curr Output Index , start Index ) ; if ( text So Far . length ( ) != _ NUM ) { result . add ( new  Text Fragment ( text So Far ) ) ; } } if ( ( start Index > _ NUM ) && ( parse String . char At ( start Index - _ NUM ) == _ STR ) ) { curr Output Index = start Index + _ NUM ; curr Search Index = start Index + _ NUM ; continue ; } int end Index = parse String . index Of ( _ STR , start Index ) ; if ( end Index == - _ NUM ) { throw new  Placeholder Parse Exception ( _ STR + parse String . substring ( start Index , parse String . length ( ) ) + _ STR ) ; }  String between = parse String . substring ( start Index + _ NUM , end Index ) ;  Parameter Fragment parameter Fragment = new  Parameter Fragment ( between ) ; result . add ( parameter Fragment ) ; curr Output Index = end Index + _ NUM ; curr Search Index = end Index ; }  Linked List <  Fragment > fragments = new  Linked List <  Fragment > ( ) ; fragments . add ( result . get ( _ NUM ) ) ; for ( int i = _ NUM ; i < result . size ( ) ; i ++ ) {  Fragment fragment = result . get ( i ) ; if ( ! ( result . get ( i ) instanceof  Text Fragment ) ) { fragments . add ( fragment ) ; continue ; } if ( ! ( fragments . get Last ( ) instanceof  Text Fragment ) ) { fragments . add ( fragment ) ; continue ; }  Text Fragment text Fragment = (  Text Fragment ) fragments . get Last ( ) ; fragments . remove Last ( ) ; fragments . add ( new  Text Fragment ( text Fragment . get Value ( ) + fragment . get Value ( ) ) ) ; } return fragments ; }
@  Override protected void failed ( ) { relation . set Canceled ( _ BOOL ) ; super . failed ( ) ; }
private void route Single Get Request (  Request And Response request And Response ,  String uri ) throws  IOException ,  Servlet Exception { if ( uri . starts With ( _ STR ) ) { handle Html Show Notebooks ( request And Response ) ; } else if ( uri . starts With ( _ STR ) ) { handle Html Show Quotations ( request And Response ) ; } else if ( uri . starts With ( _ STR ) ) { handle Html Show Sources ( request And Response ) ; } else if ( uri . starts With ( _ STR ) ) { handle Html Show Source ( request And Response ) ; } else if ( uri . starts With ( _ STR ) ) { handle Html Show Notebook ( request And Response ) ; } else if ( uri . starts With ( _ STR ) ) { handle Html Search ( request And Response ) ; } else if ( uri . equals ( _ STR ) ) { handle Html Basic Help ( request And Response ) ; } else if ( uri . equals ( _ STR ) ) { handle Html Advanced Help ( request And Response ) ; } else if ( uri . starts With ( _ STR ) ) { handle Html Help ( request And Response ) ; } else if ( uri . equals ( _ STR ) ) { handle Html User Backup Form ( request And Response ) ; } else if ( uri . equals ( _ STR ) ) { handle Html User Restore Form ( request And Response ) ; } else if ( uri . starts With ( _ STR ) ) { handle Html Show Account ( request And Response ) ; } else if ( uri . starts With ( _ STR ) ) { handle Html Show Accounts ( request And Response ) ; } else if ( uri . equals ( _ STR ) ) { handle Html Shutdown Form ( request And Response ) ; } else if ( uri . equals ( _ STR ) ) { handle Html Clear Form ( request And Response ) ; } else if ( uri . equals ( _ STR ) ) { handle Html Online Backup Form ( request And Response ) ; } else if ( uri . equals ( _ STR ) ) { handle Html Check For Errors Form ( request And Response ) ; } else if ( uri . equals ( _ STR ) ) { handle Html Show DBBackups ( request And Response ) ; } else if ( uri . equals ( _ STR ) ) { handle Html Offline Db Backup Form ( request And Response ) ; } else if ( uri . equals ( _ STR ) ) { handle Json Show Entry ( request And Response ) ; } else if ( uri . equals ( _ STR ) ) { handle Json Show Entry Parent ( request And Response ) ; } else if ( uri . equals ( _ STR ) ) { handle Json Show Entry Children ( request And Response ) ; } else if ( uri . equals ( _ STR ) ) { handle Json Search Notes ( request And Response ) ; } else if ( uri . equals ( _ STR ) ) { handle Html New Notebook Form ( request And Response ) ; } else if ( uri . equals ( _ STR ) ) { handle Html Nothing ( request And Response ) ; } else if ( uri . equals ( _ STR ) ) { handle Html Could Not Create Note ( request And Response ) ; } else if ( uri . equals ( _ STR ) ) { handle Html Show Restore Db Backup Command ( request And Response ) ; } else if ( uri . equals ( _ STR ) ) { handle Html Show Signed Out ( request And Response ) ; } else if ( uri . starts With ( _ STR ) ) { handle Html Change Password ( request And Response ) ; } else if ( uri . starts With ( _ STR ) ) { handle Html Change Account ( request And Response ) ; } else if ( uri . starts With ( _ STR ) ) { handle Html Close Account ( request And Response ) ; } else if ( uri . equals ( _ STR ) ) { handle Json Is Signed In ( request And Response ) ; } else if ( uri . equals ( _ STR ) ) { handle Html User Restore Frame ( request And Response ) ; } else { return Html404 ( request And Response ) ; } }
private void change Annotation Document State (  Source Document a Source Document ,  User a User ,  Annotation Document State Transition a Annotation Document State Transition ) {  Annotation Document annotation Document = repository . get Annotation Document ( a Source Document , a User ) ; annotation Document . set State (  Annotation Document State Transition . transition ( a Annotation Document State Transition ) ) ; try { repository . create Annotation Document ( annotation Document ) ; } catch (  IOException e ) {  LOG . info ( _ STR ) ; } }
boolean remove Edge (  Sparse Edge e ) { boolean removed Edge = edges . remove ( e ) ; boolean removed Neighbour = neighbours . remove ( e . get Opposite ( this ) ) ; if ( removed Edge && removed Neighbour ) return _ BOOL ; else if ( ! removed Edge && ! removed Neighbour ) return _ BOOL ; else throw new  Runtime Exception ( _ STR ) ; }
protected void long Key Press ( int key Code ) { }
public boolean has Descendant (  Pattern pattern ) {  Queue <  BNode > nodes To Process = new  Linked List <  BNode > ( ) ; nodes To Process . add ( this ) ; while ( ! nodes To Process . is Empty ( ) ) {  BNode current Node = nodes To Process . poll ( ) ; for (  BNode descendant Node : current Node . get Output Nodes ( ) ) {  Matcher matcher = pattern . matcher ( descendant Node . get Id ( ) ) ; if ( matcher . matches ( ) ) { return _ BOOL ; } if ( ! nodes To Process . contains ( descendant Node ) ) { nodes To Process . add ( descendant Node ) ; } } } return _ BOOL ; }
private static void generate Files ( ) {  String [ ] class Names ;  Resource Bundle rules , info ; info =  Resource Bundle . get Bundle ( _ STR , new  Locale ( language , country , valiant ) ,  Break Iterator RBControl .  INSTANCE ) ; class Names = info . get String Array ( _ STR ) ; rules =  Resource Bundle . get Bundle ( _ STR , new  Locale ( language , country , valiant ) ,  Break Iterator RBControl .  INSTANCE ) ; if ( info . contains Key ( _ STR ) ) { generate Data File ( info . get String ( _ STR ) , rules . get String ( _ STR ) , class Names [ _ NUM ] ) ; } if ( info . contains Key ( _ STR ) ) { generate Data File ( info . get String ( _ STR ) , rules . get String ( _ STR ) , class Names [ _ NUM ] ) ; } if ( info . contains Key ( _ STR ) ) { generate Data File ( info . get String ( _ STR ) , rules . get String ( _ STR ) , class Names [ _ NUM ] ) ; } if ( info . contains Key ( _ STR ) ) { generate Data File ( info . get String ( _ STR ) , rules . get String ( _ STR ) , class Names [ _ NUM ] ) ; } }
public static boolean is Cglib Proxy (  Object object ) { return  Class Utils . is Cglib Proxy Class ( object . get Class ( ) ) ; }
public void test Bug10630 ( ) throws  Exception {  Connection conn2 = null ;  Statement stmt2 = null ; try { conn2 = get Connection With Props ( (  Properties ) null ) ; stmt2 = conn2 . create Statement ( ) ; conn2 . close ( ) ; stmt2 . get Warnings ( ) ; fail ( _ STR ) ; } catch (  SQLException sql Ex ) { assert Equals (  SQLError .  SQL_ STATE_ ILLEGAL_ ARGUMENT , sql Ex . get SQLState ( ) ) ; } finally { if ( stmt2 != null ) { stmt2 . close ( ) ; } if ( conn2 != null ) { conn2 . close ( ) ; } } }
public static boolean equals ( boolean [ ] field1 , boolean [ ] field2 ) { if ( field1 == null || field1 . length == _ NUM ) { return field2 == null || field2 . length == _ NUM ; } else { return  Arrays . equals ( field1 , field2 ) ; } }
public void to Front ( final  Workflow Annotation anno ) { if ( anno == null ) { throw new  Illegal Argument Exception ( _ STR ) ; } synchronized ( lock ) { if ( annotations Draw Order . remove ( anno ) ) { annotations Draw Order . add ( anno ) ; } if ( annotations Event Order . remove ( anno ) ) { annotations Event Order . add ( _ NUM , anno ) ; } } }
public synchronized void add Frame ( final  Image image , final long frame Duration ) { total Duration += frame Duration ; frames . add ( new  Anim Frame ( image , total Duration ) ) ; }
public static  String print Code Point As String ( int code Point ) {  String Builder builder = new  String Builder ( _ NUM ) ; builder . append ( _ STR ) ; try { print String Code Point ( builder , code Point ) ; } catch (  IOException e ) { throw new  Error ( e ) ; } builder . append ( _ STR ) ; return builder . to String ( ) ; }
private void cleanup Minidump File ( ) { if ( !  Crash File Manager . try Mark As Uploaded ( m File To Upload ) ) {  Log . w (  TAG , _ STR + m File To Upload + _ STR ) ; if ( ! m File To Upload . delete ( ) ) {  Log . w (  TAG , _ STR + m File To Upload ) ; } } }
boolean close Outbound ( ) throws  SSLException { if ( ssl Engine == null || ssl Engine . is Outbound Done ( ) ) { return _ BOOL ; } ssl Engine . close Outbound ( ) ; create Out Net Buffer ( _ NUM ) ;  SSLEngine Result result ; for ( ; ; ) { result = ssl Engine . wrap ( empty Buffer . buf ( ) , out Net Buffer . buf ( ) ) ; if ( result . get Status ( ) ==  SSLEngine Result .  Status .  BUFFER_ OVERFLOW ) { out Net Buffer . capacity ( out Net Buffer . capacity ( ) << _ NUM ) ; out Net Buffer . limit ( out Net Buffer . capacity ( ) ) ; } else { break ; } } if ( result . get Status ( ) !=  SSLEngine Result .  Status .  CLOSED ) { throw new  SSLException ( _ STR + result ) ; } out Net Buffer . flip ( ) ; return _ BOOL ; }
@  Nullable private static  Bitmap extract Thumbnail (  Bitmap source , int width , int height ) { return extract Thumbnail ( source , width , height ,  OPTIONS_ NONE ) ; }
private void write Pkg Info ( ) throws  Build Exception {  File pkg Info = new  File ( m Contents Dir , _ STR ) ;  Print Writer writer = null ; try { writer = new  Print Writer ( new  Buffered Writer ( new  File Writer ( pkg Info ) ) ) ; writer . print ( bundle Properties . get CFBundle Package Type ( ) ) ; writer . println ( bundle Properties . get CFBundle Signature ( ) ) ; writer . flush ( ) ; } catch (  IOException ex ) { throw new  Build Exception ( _ STR + ex ) ; } finally { m File Utils . close ( writer ) ; } }
public  Event Bean [ ] to Array ( ) { if ( first Event == null ) { return new  Event Bean [ _ NUM ] ; } if ( additional Events == null ) { return new  Event Bean [ ] { first Event } ; }  Event Bean [ ] events = new  Event Bean [ _ NUM + additional Events . size ( ) ] ; events [ _ NUM ] = first Event ; int count = _ NUM ; for (  Event Bean the Event : additional Events ) { events [ count ] = the Event ; count ++ ; } return events ; }
private byte [ ] decode (  Der Input Stream in ) throws  IOException {  Der Value val = in . get Der Value ( ) ; byte [ ] der Encoding = val . to Byte Array ( ) ; der Encoding [ _ NUM ] =  Der Value . tag_ Set Of ;  Der Input Stream der In = new  Der Input Stream ( der Encoding ) ;  Der Value [ ] der Vals = der In . get Set ( _ NUM , _ BOOL ) ;  PKCS9 Attribute attrib ;  Object Identifier oid ; boolean reuse Encoding = _ BOOL ; for ( int i = _ NUM ; i < der Vals . length ; i ++ ) { try { attrib = new  PKCS9 Attribute ( der Vals [ i ] ) ; } catch (  Parsing Exception e ) { if ( ignore Unsupported Attributes ) { reuse Encoding = _ BOOL ; continue ; } else { throw e ; } } oid = attrib . get OID ( ) ; if ( attributes . get ( oid ) != null ) throw new  IOException ( _ STR + oid ) ; if ( permitted Attributes != null && ! permitted Attributes . contains Key ( oid ) ) throw new  IOException ( _ STR + oid + _ STR ) ; attributes . put ( oid , attrib ) ; } return reuse Encoding ? der Encoding : generate Der Encoding ( ) ; }
@  Override public  Categorical Results clone ( ) {  Categorical Results copy = new  Categorical Results ( n ) ; copy . probabilities =  Arrays . copy Of ( probabilities , probabilities . length ) ; return copy ; }
private boolean type Special Char ( char c ) { switch ( c ) { case _ STR : controller . key Press (  Key Event .  VK_ TAB ) ; controller . key Release (  Key Event .  VK_ TAB ) ; return _ BOOL ; case _ STR : controller . key Press (  Key Event .  VK_ ENTER ) ; controller . key Release (  Key Event .  VK_ ENTER ) ; return _ BOOL ; default : return _ BOOL ; } }
protected static boolean eq (  Object o1 ,  Object o2 ) { return o1 == null ? o2 == null : o1 . equals ( o2 ) ; }
public  Iterable <  Notification > skip ( @  Nonnull final  Iterable <  Notification > notifications , final long start Id , final boolean inclusive , final int limit Size ) {  Objects . require Non Null ( notifications ) ; final int position = index Of ( notifications , start Id ) ; if ( position == - _ NUM ) { return  Iterables . limit ( notifications , limit Size ) ; } if ( inclusive ) { return  Iterables . limit (  Iterables . skip ( notifications , position ) , limit Size ) ; } return  Iterables . limit (  Iterables . skip ( notifications , position + _ NUM ) , limit Size ) ; }
public boolean write Data (  Pdx Writer writer ,  Object obj ) { if ( is Relevant ( obj . get Class ( ) ) ) { write Data ( writer , obj , get Class Info ( obj . get Class ( ) ) ) ; return _ BOOL ; } return _ BOOL ; }
protected final void write C (  Byte Buffer buf , int value ) { buf . put ( ( byte ) value ) ; }
public  Viterbi Point (  Item item ) { this . item = item ; }
protected void paint Content Border Bottom Edge (  Graphics g , int x , int y , int w , int h , boolean draw Broken ,  Rectangle sel Rect , boolean is Content Border Painted ) { if ( is Content Border Painted ) { g . set Color ( dark Shadow ) ; g . fill Rect ( x , y + h - _ NUM , w - _ NUM , _ NUM ) ; } }
public  RSAPublic Key parse PEMPublic Key (  String pem ) throws  General Security Exception { try { byte [ ] bs = decode Ascii Armored PEM ( pem ) ;  Byte Buffer data =  Byte Buffer . wrap ( bs ) ; final  ASN1 Object ob = asn1 Parser . parse ASN1 ( data ) ; final  List <  ASN1 Object > seq = asn1 Object To Sequence ( ob , _ NUM ) ; final  Big Integer modulus = asn1 Object To Big Int ( seq . get ( _ NUM ) ) ; final  Big Integer exponent = asn1 Object To Big Int ( seq . get ( _ NUM ) ) ; return create Key From Modulus And Exponent ( modulus , exponent ) ; } catch (  Illegal Argument Exception e ) { throw new  Invalid Key Exception ( ) ; } }
public static <  T >  Parallel Publisher <  T > from (  Publisher < ? extends  T > source , boolean ordered , int parallelism ) { return from ( source , ordered , parallelism ,  Px . buffer Size ( ) ,  Px . default Queue Supplier (  Px . buffer Size ( ) ) ) ; }
public void add To Queue (  Var var ) { add To Queue (  Collections . singleton ( var ) ) ; }
public  String canonicalize (  String simple URL ) {  String result URL = simple URL ; if ( simple URL . starts With ( _ STR ) ) { result URL = _ STR + simple URL ; } else if ( simple URL . starts With ( _ STR ) ) { result URL = _ STR + simple URL ; } else if ( simple URL . starts With ( _ STR ) ) { result URL = _ STR + simple URL ; } else if ( ! has Protocol Name ( simple URL ) ) { if ( is Simple Host Name ( simple URL ) ) { simple URL = _ STR + simple URL + _ STR ; } result URL = _ STR + simple URL ; } return result URL ; }
@  Request Processing ( value = _ STR , method =  HTTPRequest Method .  GET ) @  Before ( advice Class = {  Stopwatch Start Advice . class ,  Anonymous View Check . class ,  User Block Check . class } ) @  After ( advice Class =  Stopwatch End Advice . class ) public void show Home Points ( final  HTTPRequest Context context , final  Http Servlet Request request , final  Http Servlet Response response , final  String user Name ) throws  Exception { final  JSONObject user = (  JSONObject ) request . get Attribute (  User .  USER ) ; request . set Attribute (  Keys .  TEMAPLTE_ DIR_ NAME ,  Symphonys . get ( _ STR ) ) ; final  Abstract Free Marker Renderer renderer = new  Skin Renderer ( ) ; context . set Renderer ( renderer ) ; renderer . set Template Name ( _ STR ) ; final  Map <  String ,  Object > data Model = renderer . get Data Model ( ) ; filler . fill Header And Footer ( request , response , data Model ) ;  String page Num Str = request . get Parameter ( _ STR ) ; if (  Strings . is Empty Or Null ( page Num Str ) || !  Strings . is Numeric ( page Num Str ) ) { page Num Str = _ STR ; } final int page Num =  Integer . value Of ( page Num Str ) ; final int page Size =  Symphonys . get Int ( _ STR ) ; final int window Size =  Symphonys . get Int ( _ STR ) ; fill Home User ( data Model , user ) ; avatar Query Service . fill User Avatar URL ( user ) ; final  String following Id = user . opt String (  Keys .  OBJECT_ ID ) ; data Model . put (  Follow .  FOLLOWING_ ID , following Id ) ; final  JSONObject user Points Result = pointtransfer Query Service . get User Points ( user . opt String (  Keys .  OBJECT_ ID ) , page Num , page Size ) ; final  List <  JSONObject > user Points =  Collection Utils . <  JSONObject > json Array To List ( user Points Result . opt JSONArray (  Keys .  RESULTS ) ) ; data Model . put (  Common .  USER_ HOME_ POINTS , user Points ) ; final boolean is Logged In = (  Boolean ) data Model . get (  Common .  IS_ LOGGED_ IN ) ; if ( is Logged In ) { final  JSONObject current User = (  JSONObject ) data Model . get (  Common .  CURRENT_ USER ) ; final  String follower Id = current User . opt String (  Keys .  OBJECT_ ID ) ; final boolean is Following = follow Query Service . is Following ( follower Id , user . opt String (  Keys .  OBJECT_ ID ) ) ; data Model . put (  Common .  IS_ FOLLOWING , is Following ) ; } user . put (  User Ext .  USER_ T_ CREATE_ TIME , new  Date ( user . get Long (  Keys .  OBJECT_ ID ) ) ) ; final int points Cnt = user Points Result . opt Int (  Pagination .  PAGINATION_ RECORD_ COUNT ) ; final int page Count = ( int )  Math . ceil ( ( double ) points Cnt / ( double ) page Size ) ; final  List <  Integer > page Nums =  Paginator . paginate ( page Num , page Size , page Count , window Size ) ; if ( ! page Nums . is Empty ( ) ) { data Model . put (  Pagination .  PAGINATION_ FIRST_ PAGE_ NUM , page Nums . get ( _ NUM ) ) ; data Model . put (  Pagination .  PAGINATION_ LAST_ PAGE_ NUM , page Nums . get ( page Nums . size ( ) - _ NUM ) ) ; } data Model . put (  Pagination .  PAGINATION_ CURRENT_ PAGE_ NUM , page Num ) ; data Model . put (  Pagination .  PAGINATION_ PAGE_ COUNT , page Count ) ; data Model . put (  Pagination .  PAGINATION_ PAGE_ NUMS , page Nums ) ; }
private static double norm ( final double [ ] v ) { double agg = _ NUM ; for ( int i = _ NUM ; i < v . length ; i ++ ) { agg += ( v [ i ] * v [ i ] ) ; } return  Math . sqrt ( agg ) ; }
private int measure Height ( int measure Spec ) { float result ; int spec Mode =  Measure Spec . get Mode ( measure Spec ) ; int spec Size =  Measure Spec . get Size ( measure Spec ) ; if ( spec Mode ==  Measure Spec .  EXACTLY ) { result = spec Size ; } else { result = m Paint Selected . get Stroke Width ( ) + get Padding Top ( ) + get Padding Bottom ( ) ; if ( spec Mode ==  Measure Spec .  AT_ MOST ) { result =  Math . min ( result , spec Size ) ; } } return ( int ) ( ( float )  Math . ceil ( result ) ) ; }
public void layout (  Container container ) {  Map <  Location ,  Drawable > comps = get Components By Location ( container ) ;  Drawable north = comps . get (  Location .  NORTH ) ;  Drawable north East = comps . get (  Location .  NORTH_ EAST ) ;  Drawable east = comps . get (  Location .  EAST ) ;  Drawable south East = comps . get (  Location .  SOUTH_ EAST ) ;  Drawable south = comps . get (  Location .  SOUTH ) ;  Drawable south West = comps . get (  Location .  SOUTH_ WEST ) ;  Drawable west = comps . get (  Location .  WEST ) ;  Drawable north West = comps . get (  Location .  NORTH_ WEST ) ;  Drawable center = comps . get (  Location .  CENTER ) ; double width West = get Max Width ( north West , west , south West ) ; double width East = get Max Width ( north East , east , south East ) ; double height North = get Max Height ( north West , north , north East ) ; double height South = get Max Height ( south West , south , south East ) ; double gap East = ( width East > _ NUM ) ? get Gap X ( ) : _ NUM ; double gap West = ( width West > _ NUM ) ? get Gap X ( ) : _ NUM ; double gap North = ( height North > _ NUM ) ? get Gap Y ( ) : _ NUM ; double gap South = ( height South > _ NUM ) ? get Gap Y ( ) : _ NUM ;  Rectangle2 D bounds = container . get Bounds ( ) ;  Insets2 D insets = container . get Insets ( ) ; if ( insets == null ) { insets = new  Insets2 D .  Double ( ) ; } double x West = bounds . get Min X ( ) + insets . get Left ( ) - gap West - width West ; double x Center = bounds . get Min X ( ) + insets . get Left ( ) ; double x East = bounds . get Max X ( ) - insets . get Right ( ) + gap East ; double y North = bounds . get Min Y ( ) + insets . get Top ( ) - gap North - height North ; double y Center = bounds . get Min Y ( ) + insets . get Top ( ) ; double y South = bounds . get Max Y ( ) - insets . get Bottom ( ) + gap South ; layout Component ( north West , x West , y North , width West , height North ) ; layout Component ( north , x Center , y North , bounds . get Width ( ) - insets . get Horizontal ( ) , height North ) ; layout Component ( north East , x East , y North , width East , height North ) ; layout Component ( east , x East , y Center , width East , bounds . get Height ( ) - insets . get Vertical ( ) ) ; layout Component ( south East , x East , y South , width East , height South ) ; layout Component ( south , x Center , y South , bounds . get Width ( ) - insets . get Horizontal ( ) , height South ) ; layout Component ( south West , x West , y South , width West , height South ) ; layout Component ( west , x West , y Center , width West , bounds . get Height ( ) - insets . get Vertical ( ) ) ; layout Component ( center , x Center + get Gap X ( ) , y Center + get Gap Y ( ) , bounds . get Width ( ) - insets . get Horizontal ( ) - _ NUM * get Gap X ( ) , bounds . get Height ( ) - insets . get Vertical ( ) - _ NUM * get Gap Y ( ) ) ; }
public void add ( int i , int data ) { if ( _length + _ NUM > _capacity ) ensure Capacity ( _length + _ NUM ) ;  System . arraycopy ( _buffer , i , _buffer , i + _ NUM , _length - i ) ; _buffer [ i ] = ( byte ) data ; _length += _ NUM ; }
private double mean ( double [ ] vec ) { double result = _ NUM ; for ( int i = _ NUM ; i < vec . length ; i ++ ) result += vec [ i ] ; return result / vec . length ; }
private  Sprite ( float x Pos , float y Pos , float x Vel , float y Vel ,  Image ... sprites ) { if ( sprites != null ) sprite Frame = new  Image View ( sprites [ _ NUM ] ) ; player States . add All (  Arrays . as List ( sprites ) ) ; sprite Frame . set Translate X ( x Pos ) ; sprite Frame . set Translate Y ( y Pos ) ; this . x Pos = x Pos ; this . y Pos = y Pos ; this . x Vel = x Vel ; this . y Vel = y Vel ; }
protected static  Sync Token create Sync Token (  String date String , @  Nullable  String uuid ) { try { return new  Sync Token (  DB_ DATE_ FORMAT . parse ( date String ) , uuid ) ; } catch (  Parse Exception e ) { throw new  Runtime Exception ( e ) ; } }
private static boolean equals Handles Nulls (  Object a ,  Object b ) { return a == b || ( a != null && a . equals ( b ) ) ; }
public void init (  String flagz Directory ) throws  Flag Exception ,  Etcd Flag Field Updater Exception { this . directory Prefix =  More Objects . first Non Null ( flagz Directory , directory Flag . get ( ) ) ; client = new  Etcd Client ( uris . to Array ( new  URI [ uris . size ( ) ] ) ) ; client . set Retry Handler ( retry Policy ) ; initial Set All Flagz ( ) ; }
public static void close EL (  Input Stream is ) { try { if ( is != null ) is . close ( ) ; } catch (  Throwable t ) { } }
public void test Random ( ) {  Extremity Monitor monitor = new  Extremity Monitor ( ) ;  Random random = new  Random ( _ NUM ) ; for ( int i = _ NUM ; i < _ NUM ; i ++ ) { monitor . update ( random . next Double ( ) ) ; } assert True ( monitor . get Min ( ) < _ NUM ) ; assert True ( monitor . get Max ( ) < _ NUM ) ; assert True ( monitor . get Min ( ) >= _ NUM ) ; assert True ( monitor . get Max ( ) > _ NUM ) ; }
public static  String replace (  String str , char old Char ,  String new Str ) {  String Buffer buf = new  String Buffer ( ) ; for ( int i = _ NUM ; i < str . length ( ) ; i ++ ) { char ch = str . char At ( i ) ; if ( ch == old Char ) { buf . append ( new Str ) ; } else { buf . append ( ch ) ; } } return buf . to String ( ) ; }
@  Action ( value = _ STR ) @  Validation Error Page ( value =  ERROR ) @  Skip Validation public  String newform ( ) { set Login Dept ( ) ;  Simple Date Format sdf = new  Simple Date Format ( _ STR ) ; try { cut Off Date = sdf . parse ( collections Util . get App Config Value (  Collection Constants .  MODULE_ NAME_ COLLECTIONS_ CONFIG ,  Collection Constants .  APPCONFIG_ VALUE_ COLLECTIONDATAENTRYCUTOFFDATE ) ) ; } catch (  Parse Exception e ) {  LOGGER . error ( get Text ( _ STR ) + e . get Message ( ) ) ; } return  NEW ; }
public  Type Declaration canonicalize ( ) {  List <  Type > sts = get Satisfied Types ( ) ; if ( sts . is Empty ( ) ) { return unit . get Anything Declaration ( ) ; } else if ( sts . size ( ) == _ NUM ) {  Type st = sts . get ( _ NUM ) ; if ( st . is Exactly Nothing ( ) ) { return unit . get Nothing Declaration ( ) ; } } for (  Type st : sts ) { if ( st . is Union ( ) ) {  List <  Type > case Types = st . get Case Types ( ) ;  List <  Type > ulist = new  Array List <  Type > ( case Types . size ( ) ) ; for (  Type ct : case Types ) {  List <  Type > ilist = new  Array List <  Type > ( sts . size ( ) ) ; for (  Type pt : sts ) { if ( pt == st ) { add To Intersection ( ilist , ct , unit ) ; } else { add To Intersection ( ilist , pt , unit ) ; } }  Type it = canonical Intersection ( ilist , unit ) ; add To Union ( ulist , it ) ; }  Type Declaration result = new  Union Type ( unit ) ; result . set Case Types ( ulist ) ; return result ; } } return this ; }
public static void open Other Uri ( final  String url , final  Activity activity ) {  Intent intent = new  Intent (  Intent .  ACTION_ VIEW ,  Uri . parse ( url ) ) ; activity . start Activity ( intent ) ; }
public static boolean wait For All Active And Live Replicas (  Zk State Reader zk State Reader , int timeout In Ms ) { return wait For All Active And Live Replicas ( zk State Reader , null , timeout In Ms ) ; }
public boolean check For Rp ( ) { return  Null Column Value Getter . is Not Null Value ( get Rp Copy Name ( ) ) ; }
External Problem (  Process process ) { this ( process . get Input Stream ( ) , process . get Output Stream ( ) ) ;  Redirect Stream . redirect ( process . get Error Stream ( ) ,  System . err ) ; }
public static  List <  String > split Path (  File file ) {  List <  String > output = new  Array List < > ( ) ;  File current = file ; while ( current != null ) { output . add ( current . get Name ( ) ) ; current = current . get Parent File ( ) ; }  Collections . reverse ( output ) ; return output ; }
private static  Stsd Data parse Stsd (  Parsable Byte Array stsd , int track Id , long duration Us , int rotation Degrees ,  String language , boolean is Quick Time ) { stsd . set Position (  Atom .  FULL_ HEADER_ SIZE ) ; int number Of Entries = stsd . read Int ( ) ;  Stsd Data out = new  Stsd Data ( number Of Entries ) ; for ( int i = _ NUM ; i < number Of Entries ; i ++ ) { int child Start Position = stsd . get Position ( ) ; int child Atom Size = stsd . read Int ( ) ;  Assertions . check Argument ( child Atom Size > _ NUM , _ STR ) ; int child Atom Type = stsd . read Int ( ) ; if ( child Atom Type ==  Atom .  TYPE_avc1 || child Atom Type ==  Atom .  TYPE_avc3 || child Atom Type ==  Atom .  TYPE_encv || child Atom Type ==  Atom .  TYPE_mp4v || child Atom Type ==  Atom .  TYPE_hvc1 || child Atom Type ==  Atom .  TYPE_hev1 || child Atom Type ==  Atom .  TYPE_s263 || child Atom Type ==  Atom .  TYPE_vp08 || child Atom Type ==  Atom .  TYPE_vp09 ) { parse Video Sample Entry ( stsd , child Atom Type , child Start Position , child Atom Size , track Id , duration Us , rotation Degrees , out , i ) ; } else if ( child Atom Type ==  Atom .  TYPE_mp4a || child Atom Type ==  Atom .  TYPE_enca || child Atom Type ==  Atom .  TYPE_ac_3 || child Atom Type ==  Atom .  TYPE_ec_3 || child Atom Type ==  Atom .  TYPE_dtsc || child Atom Type ==  Atom .  TYPE_dtse || child Atom Type ==  Atom .  TYPE_dtsh || child Atom Type ==  Atom .  TYPE_dtsl || child Atom Type ==  Atom .  TYPE_samr || child Atom Type ==  Atom .  TYPE_sawb || child Atom Type ==  Atom .  TYPE_lpcm || child Atom Type ==  Atom .  TYPE_sowt ) { parse Audio Sample Entry ( stsd , child Atom Type , child Start Position , child Atom Size , track Id , duration Us , language , is Quick Time , out , i ) ; } else if ( child Atom Type ==  Atom .  TYPE_ TTML ) { out . media Format =  Media Format . create Text Format (  Integer . to String ( track Id ) ,  Mime Types .  APPLICATION_ TTML ,  Media Format .  NO_ VALUE , duration Us , language ) ; } else if ( child Atom Type ==  Atom .  TYPE_tx3g ) { out . media Format =  Media Format . create Text Format (  Integer . to String ( track Id ) ,  Mime Types .  APPLICATION_ TX3 G ,  Media Format .  NO_ VALUE , duration Us , language ) ; } else if ( child Atom Type ==  Atom .  TYPE_wvtt ) { out . media Format =  Media Format . create Text Format (  Integer . to String ( track Id ) ,  Mime Types .  APPLICATION_ MP4 VTT ,  Media Format .  NO_ VALUE , duration Us , language ) ; } else if ( child Atom Type ==  Atom .  TYPE_stpp ) { out . media Format =  Media Format . create Text Format (  Integer . to String ( track Id ) ,  Mime Types .  APPLICATION_ TTML ,  Media Format .  NO_ VALUE , duration Us , language , _ NUM ) ; } stsd . set Position ( child Start Position + child Atom Size ) ; } return out ; }
protected boolean is Compatible (  Taxa taxa ,  List <  Taxon > available Taxa ) { for ( int i = _ NUM ; i < taxa . get Taxon Count ( ) ; i ++ ) {  Taxon taxon = taxa . get Taxon ( i ) ; if ( ! available Taxa . contains ( taxon ) ) { return _ BOOL ; } } return _ BOOL ; }
protected int draw Label Text (  Object native Graphics , int text Decoration , boolean rtl , boolean is Ticker Running , boolean ends With3 Points ,  Object native Font , int txt W , int text Space W , int shift Text ,  String text , int x , int y , int font Height ) { if ( ( ! is Ticker Running ) || rtl ) { if ( txt W > text Space W && text Space W > _ NUM ) { if ( rtl ) { if ( ( ! is Ticker Running ) && ends With3 Points ) {  String points = _ STR ; int points W = string Width ( native Font , points ) ; draw String ( native Graphics , native Font , points , shift Text + x , y , text Decoration , font Height ) ; clip Rect ( native Graphics , points W + shift Text + x , y , text Space W - points W , font Height ) ; } x = x - txt W + text Space W ; } else if ( ends With3 Points ) {  String points = _ STR ; int index = _ NUM ; int widest = char Width ( native Font , _ STR ) ; int points W = string Width ( native Font , points ) ; int text Len = text . length ( ) ; while ( fast Char Width Check ( text , index , text Space W - points W , widest , native Font ) && index < text Len ) { index ++ ; } text = text . substring ( _ NUM ,  Math . min ( text Len ,  Math . max ( _ NUM , index - _ NUM ) ) ) + points ; txt W = string Width ( native Font , text ) ; } } } draw String ( native Graphics , native Font , text , shift Text + x , y , text Decoration , font Height ) ; return  Math . min ( txt W , text Space W ) ; }
public boolean has Map Objects ( ) { return map Objects != null && ! map Objects . is Empty ( ) ; }
public void perform Actions ( ) throws  Throwable { for (  Throwing .  Runnable action : actions ) { action . run ( ) ; } }
public java . util .  Collection <  Object Reference > dump Thread Roots ( int width ) { return  Collections . empty List ( ) ; }
protected void add Field Name Translation (  Embeddable Mapping embeddable Mapping ,  String override Name ,  Database Field override Field ,  Mapping Accessor aggregates Accessor ) {  Database Mapping aggregates Mapping = aggregates Accessor . get Mapping ( ) ;  Database Field aggregates Mapping Field = aggregates Mapping . get Field ( ) ; if ( aggregates Accessor . is Id ( ) ) { update Primary Key Field ( aggregates Accessor , override Field ) ; } if ( override Name . contains ( _ STR ) ) { embeddable Mapping . add Nested Field Translation ( override Name , override Field , aggregates Mapping Field . get Name ( ) ) ; } else { embeddable Mapping . add Field Translation ( override Field , aggregates Mapping Field . get Name ( ) ) ; } }
public  Dimension minimum Layout Size (  Container target ) { synchronized ( target . get Tree Lock ( ) ) {  Dimension dim = new  Dimension ( _ NUM , _ NUM ) ; if ( ( chart != null ) && chart . is Visible ( ) ) {  Dimension d = chart . get Minimum Size ( ) ; dim . width = d . width ; dim . height = d . height ; } if ( ( x Label != null ) && x Label . is Visible ( ) ) {  Dimension d = x Label . get Minimum Size ( ) ; dim . width =  Math . max ( d . width , dim . width ) ; dim . height += d . height + vgap ; } if ( ( y Label != null ) && y Label . is Visible ( ) ) {  Dimension d = y Label . get Minimum Size ( ) ; dim . width += d . width + hgap ; dim . height =  Math . max ( d . height , dim . height ) ; } if ( ( title != null ) && title . is Visible ( ) ) {  Dimension d = title . get Minimum Size ( ) ; dim . width =  Math . max ( d . width , dim . width ) ; dim . height += d . height + vgap ; }  Insets insets = target . get Insets ( ) ; dim . width += insets . left + insets . right ; dim . height += insets . top + insets . bottom ; return dim ; } }
private void check Resource Change ( final  Resource resource , final  Group group , final  Callback callback , final  Atomic Boolean is Changed ) throws  Exception { if ( is Changed ( resource , group . get Name ( ) ) ) { is Changed . compare And Set ( _ BOOL , _ BOOL ) ; callback . on Resource Changed ( resource ) ; lifecycle Callback . on Resource Changed ( resource ) ; } }
public javax2 . sip . address .  Tel URL create Tel URL (  String uri ) throws  Parse Exception { if ( uri == null ) throw new  Null Pointer Exception ( _ STR ) ;  String tel Url = _ STR + uri ; try {  String Msg Parser smp = new  String Msg Parser ( ) ;  Tel URLImpl timp = (  Tel URLImpl ) smp . parse Url ( tel Url ) ; return (  Tel URL ) timp ; } catch (  Parse Exception ex ) { throw new  Parse Exception ( ex . get Message ( ) , _ NUM ) ; } }
public  Evo SVMModel (  Example Set example Set ,  List <  Support Vector > support Vectors ,  Kernel kernel , double bias ) { super ( example Set ,  Example Set Utilities .  Sets Compare Option .  ALLOW_ SUPERSET ,  Example Set Utilities .  Types Compare Option .  ALLOW_ SAME_ PARENTS ) ; this . support Vectors = support Vectors ; if ( support Vectors == null || support Vectors . size ( ) == _ NUM ) { throw new  Illegal Argument Exception ( _ STR ) ; } this . kernel = kernel ; this . bias = bias ; if ( this . kernel instanceof  Dot Kernel ) { this . weights = new double [ get Number Of Attributes ( ) ] ; for ( int i = _ NUM ; i < get Number Of Support Vectors ( ) ; i ++ ) {  Support Vector sv = get Support Vector ( i ) ; if ( sv != null ) { double [ ] x = sv . get X ( ) ; double alpha = sv . get Alpha ( ) ; double y = sv . get Y ( ) ; for ( int j = _ NUM ; j < weights . length ; j ++ ) { weights [ j ] += y * alpha * x [ j ] ; } } else { this . weights = null ; break ; } } } }
private synchronized boolean _restart ( ) throws  Servlet Exception { if ( singelton != null ) singelton . reset ( ) ; init Engine ( ) ;  System . gc ( ) ; return _ BOOL ; }
public  Sorter ( ) { use Default Visual ( ) ; set Layout ( new  Border Layout ( ) ) ; add ( m_visual ,  Border Layout .  CENTER ) ; m_env =  Environment . get System Wide ( ) ; m_stop Requested = new  Atomic Boolean ( _ BOOL ) ; }
public static double logpdf ( double x , double mu , double shape ) { if ( ! ( x > _ NUM ) || x ==  Double .  POSITIVE_ INFINITY ) { return  Double .  NEGATIVE_ INFINITY ; } final double v = ( x - mu ) / mu ; return v <  Double .  MAX_ VALUE ? _ NUM *  Math . log ( shape / (  Math Util .  TWOPI * x * x * x ) ) - shape * v * v / ( _ NUM * x ) :  Double .  NEGATIVE_ INFINITY ; }
public static  Format generate Format (  String codec ) { return (  Format )  SUPPORTED_ CODECS . get ( codec . to Lower Case ( ) ) ; }
public  Optional Int max By Int (  Int Unary Operator key Extractor ) { int [ ] result = collect ( null , null , null ) ; return result [ _ NUM ] == _ NUM ?  Optional Int . of ( result [ _ NUM ] ) :  Optional Int . empty ( ) ; }
public  T find By Commit Counter ( final long commit Counter ) { if ( commit Counter < _ NUM ) throw new  Illegal Argument Exception ( ) ; final  Lock lock = read Lock ( ) ; lock . lock ( ) ; try { @  Suppress Warnings ( _ STR ) final  ITuple Iterator <  T > itr = range Iterator ( null , null , _ NUM ,  IRange Query .  DEFAULT |  IRange Query .  REVERSE , null ) ; while ( itr . has Next ( ) ) { final  ITuple <  T > t = itr . next ( ) ; final  T r = t . get Object ( ) ; final  IRoot Block View rb = r . get Root Block ( ) ; if ( rb . get Commit Counter ( ) <= commit Counter ) { return r ; } } return null ; } finally { lock . unlock ( ) ; } }
public static  String trace Excetion (  Throwable ex ) { final  Writer result = new  String Writer ( ) ; final  Print Writer print Writer = new  Print Writer ( result ) ; ex . print Stack Trace ( print Writer ) ;  String stacktrace = result . to String ( ) ;  Log . e (  TAG , _ STR + stacktrace ) ; return stacktrace ; }
public static  Pair <  String ,  String > split (  String var Name ) { int split Index = var Name . index Of ( _ STR ) ; if ( split Index < _ NUM ) { return null ; }  String left = var Name . substring ( _ NUM , split Index ) ;  String right = var Name . substring ( split Index + _ NUM ) ; if ( left == null || left . length ( ) == _ NUM || right == null || right . length ( ) == _ NUM ) { return null ; } return  Pair . of ( left , right ) ; }
public void on Child Thread Resume End ( ) { _thread Count . get And Decrement ( ) ; wake ( ) ; }
public static void register Transport MBean (  String container Name ) {  MBean Server m Bean Server = get MBean Server ( container Name ) ; if ( m Bean Server == null ) return ;  Transport Protocol Monitor MBean transport Connections Info MBean = new  Transport Protocol Monitor ( ) ;  Object Name obj Name =  Transport Constants . create Transport MBean Object Name ( container Name ) ; if ( ! m Bean Server . is Registered ( obj Name ) ) { try { m Bean Server . register MBean ( transport Connections Info MBean , obj Name ) ; } catch (  Instance Already Exists Exception e ) { if ( _logger . is Loggable (  Level .  CONFIG ) ) { _logger . config ( already Registred Transport MBean Message + container Name + _ STR ) ; } } catch (  Not Compliant MBean Exception e ) { if ( _logger . is Loggable (  Level .  WARNING ) ) { _logger . log (  Level .  SEVERE , failed Transport MBean Registration Message Prefix + container Name + _ STR , e ) ; } } catch (  MBean Registration Exception e ) { if ( _logger . is Loggable (  Level .  SEVERE ) ) { _logger . log (  Level .  SEVERE , failed Transport MBean Registration Message Prefix + container Name + _ STR , e ) ; } } if ( _logger . is Loggable (  Level .  CONFIG ) ) { _logger . config ( successful Transport MBean Registration Message + container Name + _ STR ) ; } } else { if ( _logger . is Loggable (  Level .  CONFIG ) ) { _logger . config ( already Registred Transport MBean Message ) ; } } }
public static int update (  String where ,  Object [ ] args ,  V sets ,  Class < ? extends  Bean > t ) {  Table mapping = (  Table ) t . get Annotation (  Table . class ) ; if ( mapping == null ) { if ( log . is Error Enabled ( ) ) log . error ( _ STR + t + _ STR ) ; return - _ NUM ; } if ( !  X . is Empty ( mapping . name ( ) ) ) { return update Table ( mapping . name ( ) , where , args , sets ) ; } return - _ NUM ; }
private void stop Video Fading Edges Screen Timer ( ) { if ( null != m Video Fading Edges Timer ) { m Video Fading Edges Timer . cancel ( ) ; m Video Fading Edges Timer = null ; m Video Fading Edges Timer Task = null ; } }
public void remove Listener ( final  Timeout Event Listener listener ) { listeners . remove ( listener ) ; }
protected static void process Generic Properties Creator Props (  File props File ) { try {  Properties exp Props = new  Properties ( ) ;  Buffered Input Stream bi = new  Buffered Input Stream ( new  File Input Stream ( props File ) ) ; exp Props . load ( bi ) ; bi . close ( ) ; bi = null ;  Properties  GPCInput Props =  Generic Properties Creator . get Global Input Properties ( ) ;  Set <  Object > keys = exp Props . key Set ( ) ;  Iterator <  Object > keys I = keys . iterator ( ) ; while ( keys I . has Next ( ) ) {  String key = (  String ) keys I . next ( ) ;  String existing Val =  GPCInput Props . get Property ( key , _ STR ) ; if ( existing Val . length ( ) > _ NUM ) {  String new Val = exp Props . get Property ( key ) ; if ( existing Val . index Of ( new Val ) < _ NUM ) { new Val = existing Val + _ STR + new Val ;  GPCInput Props . put ( key , new Val ) ; } } else {  String new Val = exp Props . get Property ( key ) ;  GPCInput Props . put ( key , new Val ) ; } } } catch (  Exception ex ) { } }
private synchronized void add Table Lock Object (  Absolute Table Identifier absolute Table Identifier ) { if ( null == table Lock Map . get ( absolute Table Identifier ) ) { table Lock Map . put ( absolute Table Identifier , new  Object ( ) ) ; } }
public static <  T > void update Mapping To Immutable Set (  Map <  T ,  Set <  Annotation Mirror > > map ,  T key ,  Set <  Annotation Mirror > new Qual ) {  Set <  Annotation Mirror > result =  Annotation Utils . create Annotation Set ( ) ; if ( ! map . contains Key ( key ) ) { result . add All ( new Qual ) ; } else { result . add All ( map . get ( key ) ) ; result . add All ( new Qual ) ; } map . put ( key ,  Collections . unmodifiable Set ( result ) ) ; }
public static void join ( final  Async Invocation < ? > async , final long timeout Milliseconds ) { join ( async . get Thread ( ) , timeout Milliseconds ) ; }
void define (  Member Definition field , int slot , int from , int to ) { if ( from >= to ) { return ; } for ( int i = _ NUM ; i < len ; i ++ ) { if ( ( locals [ i ] . field == field ) && ( locals [ i ] . slot == slot ) && ( from <= locals [ i ] . to ) && ( to >= locals [ i ] . from ) ) { locals [ i ] . from =  Math . min ( locals [ i ] . from , from ) ; locals [ i ] . to =  Math . max ( locals [ i ] . to , to ) ; return ; } } if ( len == locals . length ) {  Local Variable newlocals [ ] = new  Local Variable [ len * _ NUM ] ;  System . arraycopy ( locals , _ NUM , newlocals , _ NUM , len ) ; locals = newlocals ; } locals [ len ++ ] = new  Local Variable ( field , slot , from , to ) ; }
protected  Connection open Connection ( boolean autocommit ) throws  SQLException {  Connection conn = data Src . get Connection ( ) ; conn . set Auto Commit ( autocommit ) ; return conn ; }
public void mouse Pressed (  Mouse Event e ) { int nclicks =  Swing Utilities2 . get Adjusted Click Count ( get Component ( ) , e ) ; if (  Swing Utilities . is Left Mouse Button ( e ) ) { if ( e . is Consumed ( ) ) { should Handle Release = _ BOOL ; } else { should Handle Release = _ BOOL ; adjust Caret And Focus ( e ) ; if ( nclicks == _ NUM &&  Swing Utilities2 . can Event Access System Clipboard ( e ) ) { select Word ( e ) ; } } } }
public  Object apply (  String source , int line No , int column No ,  Object func Body ,  Vector param Names ,  Vector arguments ) throws  BSFException {  Object object = eval ( source , line No , column No , func Body ) ; if ( object instanceof  Closure ) {  Closure closure = (  Closure ) object ; return closure . call ( arguments . to Array ( ) ) ; } return object ; }
public  Set key Set ( ) { return total Key Set ( ) ; }
public void output (  List list ,  Writer out ) throws  IOException { print Content Range ( out , list , _ NUM , list . size ( ) , _ NUM , create Namespace Stack ( ) ) ; out . flush ( ) ; }
public boolean consume Encumbrance Budget ( final  Map <  String ,  Object > details Map ) { if ( details Map == null ) throw new  Validation Exception (  Arrays . as List ( new  Validation Error ( _ STR , _ STR ) ) ) ; details Map . put (  Constants .  CONSUMEORRELEASE , _ BOOL ) ; final  Big Decimal bd = get Details ( details Map ) ; return bd . int Value ( ) == _ NUM ; }
private int [ ] mod ( int [ ] a , int [ ] f ) { int df = compute Degree ( f ) ; if ( df == - _ NUM ) { throw new  Arithmetic Exception ( _ STR ) ; } int [ ] result = new int [ a . length ] ; int hc = head Coefficient ( f ) ; hc = field . inverse ( hc ) ;  System . arraycopy ( a , _ NUM , result , _ NUM , result . length ) ; while ( df <= compute Degree ( result ) ) { int [ ] q ; int coeff = field . mult ( head Coefficient ( result ) , hc ) ; q = mult With Monomial ( f , compute Degree ( result ) - df ) ; q = mult With Element ( q , coeff ) ; result = add ( q , result ) ; } return result ; }
@  Override public  Enumeration <  Option > list Options ( ) {  Vector <  Option > result = enum To Vector ( super . list Options ( ) ) ; result . add Element ( new  Option ( _ STR + default Num Clusters ( ) + _ STR , _ STR , _ NUM , _ STR ) ) ; result . add Element ( new  Option ( _ STR + _ STR + _ STR , _ STR , _ NUM , _ STR ) ) ; result . add Element ( new  Option ( _ STR + _ STR + _ STR , _ STR , _ NUM , _ STR ) ) ; result . add Element ( new  Option ( _ STR + default Min Inst Num ( ) + _ STR + default Max Inst Num ( ) + _ STR + _ STR + _ STR , _ STR , _ NUM , _ STR ) ) ; result . add Element ( new  Option ( _ STR + default Min Radius ( ) + _ STR + default Max Radius ( ) + _ STR + _ STR + _ STR , _ STR , _ NUM , _ STR ) ) ; result . add Element ( new  Option ( _ STR + default Dist Mult ( ) + _ STR , _ STR , _ NUM , _ STR ) ) ; result . add Element ( new  Option ( _ STR + default Num Cycles ( ) + _ STR , _ STR , _ NUM , _ STR ) ) ; result . add Element ( new  Option ( _ STR + _ STR + _ STR , _ STR , _ NUM , _ STR ) ) ; result . add Element ( new  Option ( _ STR + default Noise Rate ( ) + _ STR + _ STR + _ STR , _ STR , _ NUM , _ STR ) ) ; return result . elements ( ) ; }
public static void append Hex Java Script Representation (  String Builder sb , char c ) { sb . append ( _ STR ) ;  String val =  Integer . to Hex String ( c ) ; for ( int j = val . length ( ) ; j < _ NUM ; j ++ ) { sb . append ( _ STR ) ; } sb . append ( val ) ; }
private void print Bootstrap Map ( ) {  LOG . info ( _ STR ) ; for (  Integer i : chain Map . key Set ( ) ) {  LOG . info (  String . format ( _ STR , i , chain Map . get ( i ) ) ) ; } }
public  Vector <  Option > enum To Vector (  Enumeration <  Option > enu ) {  Vector <  Option > options = new  Vector <  Option > ( ) ; options . add All (  Collections . list ( enu ) ) ; return options ; }
private  P filter Large Value Sets (  Filter Spec fs ,  Meta Data Object root Meta ,  F root , boolean force Entity Based ,  Join Type default Predicate Join Type ) {  Array List <  Filter Spec > specs = new  Array List < > ( ) ;  List < ? > list = new  Array List < > ( (  Collection < ? > ) fs . get Value ( ) ) ; for ( int i = _ NUM ; i < list . size ( ) ; i +=  ORACLE_ PARAM_ LIMIT ) { int next Offset = i +  Math . min ( list . size ( ) - i ,  ORACLE_ PARAM_ LIMIT ) ;  List < ? > batch List = list . sub List ( i , next Offset ) ; specs . add ( new  Filter Spec ( fs . get Attribute Path ( ) , fs . get Operator ( ) , batch List ) ) ; }  Filter Spec or Spec =  Filter Spec . or ( specs ) ; return filter Spec List To Predicate ( root Meta , root , or Spec , force Entity Based , default Predicate Join Type ) ; }
protected void add Tags (  E data ,  Builder builder ) {  Platform Ident platform Ident = cached Data Service . get Platform Ident For Id ( data . get Platform Ident ( ) ) ; builder . tag (  Series .  TAG_ AGENT_ ID ,  String . value Of ( data . get Platform Ident ( ) ) ) ; if ( null != platform Ident ) { builder . tag (  Series .  TAG_ AGENT_ NAME , platform Ident . get Agent Name ( ) ) ; } }
public int compare (  String s1 ,  String s2 ) { final  Matcher match1 =  MATCH_ ID_ PATTERN . matcher ( s1 ) ; final  Matcher match2 =  MATCH_ ID_ PATTERN . matcher ( s2 ) ; final boolean match1matches = match1 . matches ( ) ; final boolean match2matches = match2 . matches ( ) ; if ( match1matches ^ match2matches ) { return ( match1matches ) ? _ NUM : - _ NUM ; } else if ( match1matches && match2matches ) { int signature1 =  Integer . parse Int ( match1 . group ( _ NUM ) ) ; int signature2 =  Integer . parse Int ( match2 . group ( _ NUM ) ) ; int comparison = ( signature1 < signature2 ) ? - _ NUM : ( signature1 > signature2 ) ? _ NUM : _ NUM ; if ( comparison == _ NUM ) { int start1 =  Integer . parse Int ( match1 . group ( _ NUM ) ) ; int start2 =  Integer . parse Int ( match2 . group ( _ NUM ) ) ; comparison = ( start1 < start2 ) ? - _ NUM : ( start1 > start2 ) ? _ NUM : _ NUM ; } if ( comparison == _ NUM ) { int end1 =  Integer . parse Int ( match1 . group ( _ NUM ) ) ; int end2 =  Integer . parse Int ( match2 . group ( _ NUM ) ) ; comparison = ( end1 < end2 ) ? - _ NUM : ( end1 > end2 ) ? _ NUM : _ NUM ; } return comparison ; } else { int seq Length1 = s1 . length ( ) , n2 = s2 . length ( ) ; for ( int i1 = _ NUM , i2 = _ NUM ; i1 < seq Length1 && i2 < n2 ; i1 ++ , i2 ++ ) { char c1 = s1 . char At ( i1 ) ; char c2 = s2 . char At ( i2 ) ; if ( c1 != c2 ) { c1 =  Character . to Upper Case ( c1 ) ; c2 =  Character . to Upper Case ( c2 ) ; if ( c1 != c2 ) { c1 =  Character . to Lower Case ( c1 ) ; c2 =  Character . to Lower Case ( c2 ) ; if ( c1 != c2 ) { return c1 - c2 ; } } } } return seq Length1 - n2 ; } }
private static int load Build Number (  Context context ,  Package Manager package Manager ) { try {  Application Info app Info = package Manager . get Application Info ( context . get Package Name ( ) ,  Package Manager .  GET_ META_ DATA ) ;  Bundle meta Data = app Info . meta Data ; if ( meta Data != null ) { return meta Data . get Int (  BUNDLE_ BUILD_ NUMBER , _ NUM ) ; } } catch (  Package Manager .  Name Not Found Exception e ) {  L . e ( _ STR ) ; e . print Stack Trace ( ) ; } return _ NUM ; }
public static  Left Regular Bipartite Graph Segment build Random Left Regular Bipartite Graph ( int left Size , int right Size , int left Degree ,  Random random ) {  Left Regular Bipartite Graph Segment left Regular Bipartite Graph Segment = new  Left Regular Bipartite Graph Segment ( left Size / _ NUM , left Degree , right Size / _ NUM , left Size / _ NUM , _ NUM ,  Integer .  MAX_ VALUE , new  Identity Edge Type Mask ( ) , new  Null Stats Receiver ( ) ) ;  Long Set added Ids = new  Long Open Hash Set ( left Degree ) ; for ( int i = _ NUM ; i < left Size ; i ++ ) { added Ids . clear ( ) ; for ( int j = _ NUM ; j < left Degree ; j ++ ) { long id To Add ; do { id To Add = random . next Int ( right Size ) ; } while ( added Ids . contains ( id To Add ) ) ; added Ids . add ( id To Add ) ; left Regular Bipartite Graph Segment . add Edge ( i , id To Add , ( byte ) _ NUM ) ; } } return left Regular Bipartite Graph Segment ; }
protected  Http URLConnection configure Request ( final  Http URLConnection request ) { if ( credentials != null ) request . set Request Property (  HEADER_ AUTHORIZATION , credentials ) ; request . set Request Property (  HEADER_ USER_ AGENT , user Agent ) ; request . set Request Property (  HEADER_ ACCEPT , get Header Accept ( ) ) ; return request ; }
public static  String convert To Title ( int n ) { if ( n <= _ NUM ) return _ STR ;  String Builder title = new  String Builder ( ) ; while ( n > _ NUM ) { n -- ; int r = n % _ NUM ; title . insert ( _ NUM , ( char ) ( _ STR + r ) ) ; n = n / _ NUM ; } return title . to String ( ) ; }
static public void process (  String input ,  String output ,  String pack File Name ) { process ( new  Settings ( ) , input , output , pack File Name ) ; }
private  Replicator Runtime Conf (  String service Name ) { replicator Home Dir = locate Replicator Home Dir ( ) ; replicator Log Dir = locate Replicator Log Dir ( ) ; replicator Conf Dir = locate Replicator Conf Dir ( ) ; replicator Properties = new  File ( locate Replicator Conf Dir ( ) , _ STR + service Name + _ STR ) ; if ( ! replicator Properties . is File ( ) || ! replicator Properties . can Read ( ) ) { throw new  Server Runtime Exception ( _ STR + replicator Properties ) ; } replicator Dynamic Properties = new  File ( replicator Conf Dir , _ STR + service Name + _ STR ) ; replicator Dynamic Role = new  File ( replicator Conf Dir , _ STR + service Name + _ STR ) ; this . clear Dynamic Properties =  Boolean . parse Boolean (  System . get Property (  CLEAR_ DYNAMIC_ PROPERTIES ) ) ; }
public static long [ ] as Long Array ( final  List <  Long > l ) { final long [ ] a = new long [ l . size ( ) ] ; for ( int i = _ NUM ; i < a . length ; i ++ ) { a [ i ] = l . get ( i ) ; } return a ; }
private void update Menu State ( ) { m_append And . set Enabled ( m_criterium Node . allow Append (  CAnd Criterium . class ) ) ; m_append Or . set Enabled ( m_criterium Node . allow Append (  COr Criterium . class ) ) ; m_append Not . set Enabled ( m_criterium Node . allow Append (  CNot Criterium . class ) ) ; m_insert And . set Enabled ( m_criterium Node . allow Insert (  CAnd Criterium . class ) ) ; m_insert Or . set Enabled ( m_criterium Node . allow Insert (  COr Criterium . class ) ) ; m_insert Not . set Enabled ( m_criterium Node . allow Insert (  CNot Criterium . class ) ) ; m_condition Submenu . set Enabled ( m_criterium Node . allow Append (  CCondition Criterium . class ) ) ; m_remove . set Enabled ( ! m_criterium Node . is Root ( ) ) ; m_remove All . set Enabled ( m_criterium Node . get Child Count ( ) != _ NUM ) ; }
public void test Put Get Remove ( ) throws  Exception { init Store ( _ NUM ) ;  Set <  Integer > exp ; try { exp = run Put Get Remove Multithreaded ( _ NUM , _ NUM ) ; } finally { shutdown Store ( ) ; }  Map <  Integer ,  String > map = delegate . get Map ( ) ;  Collection <  Integer > extra = new  Hash Set < > ( map . key Set ( ) ) ; extra . remove All ( exp ) ; assert True ( _ STR + extra , extra . is Empty ( ) ) ;  Collection <  Integer > missing = new  Hash Set < > ( exp ) ; missing . remove All ( map . key Set ( ) ) ; assert True ( _ STR + missing , missing . is Empty ( ) ) ; for (  Integer key : exp ) assert Equals ( _ STR + key , _ STR + key , map . get ( key ) ) ; }
public static  String format List To String (  List <  String > list ) {  String result = _ STR ; for (  String s : list ) result += s + _ STR ; result = result . trim ( ) ; return result . to Upper Case ( ) ; }
@  Override public void remove Notification Listener (  Notification Listener listener ) throws  Listener Not Found Exception { if (  SNMP_ ADAPTOR_ LOGGER . is Loggable (  Level .  FINEST ) ) {  SNMP_ ADAPTOR_ LOGGER . logp (  Level .  FINEST , dbg Tag , _ STR , _ STR + listener ) ; } notif Broadcaster . remove Notification Listener ( listener ) ; }
public static boolean is Newer ( long ts1 , long size1 , long ts2 , long size2 ) { return ts1 > ts2 || ( ts1 == ts2 && size1 < size2 ) ; }
private static void d_ucumm ( double [ ] a , double [ ] agg , double [ ] c , int m , int n , int rl , int ru ) { double [ ] cprods = ( agg != null ) ? agg : new double [ n ] ; if ( agg == null )  Arrays . fill ( cprods , _ NUM ) ; for ( int i = rl , aix = rl * n ; i < ru ; i ++ , aix += n ) { product Agg ( a , cprods , aix , _ NUM , n ) ;  System . arraycopy ( cprods , _ NUM , c , aix , n ) ; } }
public static  List <  Module Spec > expand Spec Wildcards (  File dir ,  List <  Module Spec > modules ,  Backend for Backend ) {  List <  File > dirs = new  Array List <  File > ( ) ; dirs . add ( dir ) ; return expand Spec Wildcards ( dirs , modules , for Backend ) ; }
private void $$$setup UI$$$ ( ) { my Content Panel = new  JPanel ( ) ; my Content Panel . set Layout ( new  Grid Layout Manager ( _ NUM , _ NUM , new  Insets ( _ NUM , _ NUM , _ NUM , _ NUM ) , - _ NUM , - _ NUM ) ) ; my Yours Radio Button = new  JRadio Button ( ) ; my Yours Radio Button . set Selected ( _ BOOL ) ; my Yours Radio Button . set Text ( _ STR ) ; my Yours Radio Button . set Mnemonic ( _ STR ) ; my Yours Radio Button . set Displayed Mnemonic Index ( _ NUM ) ; my Content Panel . add ( my Yours Radio Button , new  Grid Constraints ( _ NUM , _ NUM , _ NUM , _ NUM ,  Grid Constraints .  ANCHOR_ WEST ,  Grid Constraints .  FILL_ NONE ,  Grid Constraints .  SIZEPOLICY_ CAN_ SHRINK |  Grid Constraints .  SIZEPOLICY_ CAN_ GROW ,  Grid Constraints .  SIZEPOLICY_ FIXED , null , null , null , _ NUM , _ BOOL ) ) ; my Theirs Radio Button = new  JRadio Button ( ) ; my Theirs Radio Button . set Text ( _ STR ) ; my Theirs Radio Button . set Mnemonic ( _ STR ) ; my Theirs Radio Button . set Displayed Mnemonic Index ( _ NUM ) ; my Content Panel . add ( my Theirs Radio Button , new  Grid Constraints ( _ NUM , _ NUM , _ NUM , _ NUM ,  Grid Constraints .  ANCHOR_ WEST ,  Grid Constraints .  FILL_ NONE ,  Grid Constraints .  SIZEPOLICY_ CAN_ SHRINK |  Grid Constraints .  SIZEPOLICY_ CAN_ GROW ,  Grid Constraints .  SIZEPOLICY_ FIXED , null , null , null , _ NUM , _ BOOL ) ) ; my Use Custom Radio Button = new  JRadio Button ( ) ; my Use Custom Radio Button . set Text ( _ STR ) ; my Use Custom Radio Button . set Mnemonic ( _ STR ) ; my Use Custom Radio Button . set Displayed Mnemonic Index ( _ NUM ) ; my Content Panel . add ( my Use Custom Radio Button , new  Grid Constraints ( _ NUM , _ NUM , _ NUM , _ NUM ,  Grid Constraints .  ANCHOR_ WEST ,  Grid Constraints .  FILL_ NONE ,  Grid Constraints .  SIZEPOLICY_ CAN_ SHRINK |  Grid Constraints .  SIZEPOLICY_ CAN_ GROW ,  Grid Constraints .  SIZEPOLICY_ FIXED , null , null , null , _ NUM , _ BOOL ) ) ; my Custom Path Text Field = new  JText Field ( ) ; my Custom Path Text Field . set Enabled ( _ BOOL ) ; my Content Panel . add ( my Custom Path Text Field , new  Grid Constraints ( _ NUM , _ NUM , _ NUM , _ NUM ,  Grid Constraints .  ANCHOR_ WEST ,  Grid Constraints .  FILL_ BOTH ,  Grid Constraints .  SIZEPOLICY_ WANT_ GROW ,  Grid Constraints .  SIZEPOLICY_ FIXED , null , new  Dimension ( _ NUM , - _ NUM ) , null , _ NUM , _ BOOL ) ) ; final  Spacer spacer1 = new  Spacer ( ) ; my Content Panel . add ( spacer1 , new  Grid Constraints ( _ NUM , _ NUM , _ NUM , _ NUM ,  Grid Constraints .  ANCHOR_ CENTER ,  Grid Constraints .  FILL_ VERTICAL , _ NUM ,  Grid Constraints .  SIZEPOLICY_ WANT_ GROW , null , null , null , _ NUM , _ BOOL ) ) ; my Error Label = new  JLabel ( ) ; my Error Label . set Foreground ( new  Color ( - _ NUM ) ) ; my Error Label . set Text ( _ STR ) ; my Content Panel . add ( my Error Label , new  Grid Constraints ( _ NUM , _ NUM , _ NUM , _ NUM ,  Grid Constraints .  ANCHOR_ WEST ,  Grid Constraints .  FILL_ NONE ,  Grid Constraints .  SIZEPOLICY_ CAN_ GROW ,  Grid Constraints .  SIZEPOLICY_ FIXED , null , null , null , _ NUM , _ BOOL ) ) ;  Button Group button Group ; button Group = new  Button Group ( ) ; button Group . add ( my Yours Radio Button ) ; button Group . add ( my Theirs Radio Button ) ; button Group . add ( my Use Custom Radio Button ) ; }
private static  String report List Contents (  Collection <  Process Error State Info > err List ) { if ( err List == null ) return null ;  String Builder builder = new  String Builder ( ) ;  Iterator <  Process Error State Info > iter = err List . iterator ( ) ; while ( iter . has Next ( ) ) {  Process Error State Info entry = iter . next ( ) ;  String condition ; switch ( entry . condition ) { case  Activity Manager .  Process Error State Info .  CRASHED : condition = _ STR ; break ; case  Activity Manager .  Process Error State Info .  NOT_ RESPONDING : condition = _ STR ; break ; default : condition = _ STR ; break ; } builder . append (  String . format ( _ STR , entry . process Name , condition , entry . short Msg ) ) ; if ( entry . condition ==  Activity Manager .  Process Error State Info .  CRASHED ) { builder . append (  String . format ( _ STR , entry . stack Trace ) ) ; } builder . append ( _ STR ) ; } return builder . to String ( ) ; }
public void parse Arguments ( final  String [ ] raw Arguments ,  Properties argument Properties ) throws  Argument Exception { boolean in Trailing Args = _ BOOL ; final int num Arguments = raw Arguments . length ; for ( int i = _ NUM ; i < num Arguments ; i ++ ) { final  String arg = raw Arguments [ i ] ; if ( in Trailing Args ) { trailing Arguments . add ( arg ) ; if ( max Trailing Arguments > _ NUM && trailing Arguments . size ( ) > max Trailing Arguments ) { final  Localizable Message message =  ERR_ ARGPARSER_ TOO_ MANY_ TRAILING_ ARGS . get ( max Trailing Arguments ) ; throw new  Argument Exception ( message ) ; } continue ; } if ( arg . equals ( _ STR ) ) { in Trailing Args = _ BOOL ; } else if ( arg . starts With ( _ STR ) ) {  String arg Name = arg . substring ( _ NUM ) ;  String arg Value = null ; final int equal Pos = arg Name . index Of ( _ STR ) ; if ( equal Pos == _ NUM ) { throw new  Argument Exception (  ERR_ ARGPARSER_ LONG_ ARG_ WITHOUT_ NAME . get ( arg ) ) ; } else if ( equal Pos > _ NUM ) { arg Value = arg Name . substring ( equal Pos + _ NUM ) ; arg Name = arg Name . substring ( _ NUM , equal Pos ) ; } final  String orig Arg Name = arg Name ; arg Name = format Long Identifier ( arg Name ) ; final  Argument a = long IDMap . get ( arg Name ) ; if ( a == null ) { if (  OPTION_ LONG_ HELP . equals ( arg Name ) ) { write To Usage Output Stream ( get Usage ( ) ) ; return ; } else if (  OPTION_ LONG_ PRODUCT_ VERSION . equals ( arg Name ) ) { print Version ( ) ; return ; } else { throw new  Argument Exception (  ERR_ ARGPARSER_ NO_ ARGUMENT_ WITH_ LONG_ ID . get ( orig Arg Name ) ) ; } } else { a . set Present ( _ BOOL ) ; if ( is Usage Argument ( a ) ) { write To Usage Output Stream ( get Usage ( ) ) ; return ; } } if ( a . needs Value ( ) ) { if ( arg Value == null ) { if ( ( i + _ NUM ) == num Arguments ) { throw new  Argument Exception (  ERR_ ARGPARSER_ NO_ VALUE_ FOR_ ARGUMENT_ WITH_ LONG_ ID . get ( orig Arg Name ) ) ; } arg Value = raw Arguments [ ++ i ] ; } final  Localizable Message Builder invalid Reason = new  Localizable Message Builder ( ) ; if ( ! a . value Is Acceptable ( arg Value , invalid Reason ) ) { throw new  Argument Exception (  ERR_ ARGPARSER_ VALUE_ UNACCEPTABLE_ FOR_ LONG_ ID . get ( arg Value , orig Arg Name , invalid Reason ) ) ; } if ( a . has Value ( ) && ! a . is Multi Valued ( ) ) { throw new  Argument Exception (  ERR_ ARGPARSER_ NOT_ MULTIVALUED_ FOR_ LONG_ ID . get ( orig Arg Name ) ) ; } a . add Value ( arg Value ) ; } else if ( arg Value != null ) { throw new  Argument Exception (  ERR_ ARGPARSER_ ARG_ FOR_ LONG_ ID_ DOESNT_ TAKE_ VALUE . get ( orig Arg Name ) ) ; } } else if ( arg . starts With ( _ STR ) ) { if ( arg . equals ( _ STR ) ) { throw new  Argument Exception (  ERR_ ARGPARSER_ INVALID_ DASH_ AS_ ARGUMENT . get ( ) ) ; } final char arg Character = arg . char At ( _ NUM ) ;  String arg Value ; if ( arg . length ( ) > _ NUM ) { arg Value = arg . substring ( _ NUM ) ; } else { arg Value = null ; } final  Argument a = short IDMap . get ( arg Character ) ; if ( a == null ) { if ( arg Character == _ STR ) { write To Usage Output Stream ( get Usage ( ) ) ; return ; } else if ( version Handler != null && arg Character ==  OPTION_ SHORT_ PRODUCT_ VERSION && ! short IDMap . contains Key (  OPTION_ SHORT_ PRODUCT_ VERSION ) ) { print Version ( ) ; return ; } else { throw new  Argument Exception (  ERR_ ARGPARSER_ NO_ ARGUMENT_ WITH_ SHORT_ ID . get ( arg Character ) ) ; } } else { a . set Present ( _ BOOL ) ; if ( is Usage Argument ( a ) ) { write To Usage Output Stream ( get Usage ( ) ) ; return ; } } if ( a . needs Value ( ) ) { if ( arg Value == null ) { if ( ( i + _ NUM ) == num Arguments ) { throw new  Argument Exception (  ERR_ ARGPARSER_ NO_ VALUE_ FOR_ ARGUMENT_ WITH_ SHORT_ ID . get ( arg Character ) ) ; } arg Value = raw Arguments [ ++ i ] ; } final  Localizable Message Builder invalid Reason = new  Localizable Message Builder ( ) ; if ( ! a . value Is Acceptable ( arg Value , invalid Reason ) ) { throw new  Argument Exception (  ERR_ ARGPARSER_ VALUE_ UNACCEPTABLE_ FOR_ SHORT_ ID . get ( arg Value , arg Character , invalid Reason ) ) ; } if ( a . has Value ( ) && ! a . is Multi Valued ( ) ) { throw new  Argument Exception (  ERR_ ARGPARSER_ NOT_ MULTIVALUED_ FOR_ SHORT_ ID . get ( arg Character ) ) ; } a . add Value ( arg Value ) ; } else if ( arg Value != null ) { final int value Length = arg Value . length ( ) ; for ( int j = _ NUM ; j < value Length ; j ++ ) { final char c = arg Value . char At ( j ) ; final  Argument b = short IDMap . get ( c ) ; if ( b == null ) { throw new  Argument Exception (  ERR_ ARGPARSER_ NO_ ARGUMENT_ WITH_ SHORT_ ID . get ( arg Character ) ) ; } else if ( b . needs Value ( ) ) { throw new  Argument Exception (  ERR_ ARGPARSER_ CANT_ MIX_ ARGS_ WITH_ VALUES . get ( arg Character , arg Value , c ) ) ; } else { b . set Present ( _ BOOL ) ; if ( is Usage Argument ( b ) ) { write To Usage Output Stream ( get Usage ( ) ) ; return ; } } } } } else if ( allows Trailing Arguments ) { in Trailing Args = _ BOOL ; trailing Arguments . add ( arg ) ; } else { throw new  Argument Exception (  ERR_ ARGPARSER_ DISALLOWED_ TRAILING_ ARGUMENT . get ( arg ) ) ; } } if ( allows Trailing Arguments && min Trailing Arguments > _ NUM && trailing Arguments . size ( ) < min Trailing Arguments ) { throw new  Argument Exception (  ERR_ ARGPARSER_ TOO_ FEW_ TRAILING_ ARGUMENTS . get ( min Trailing Arguments ) ) ; } if ( argument Properties == null ) { argument Properties = check External Properties ( ) ; } normalize Arguments ( argument Properties , argument List ) ; }
@  Override public boolean start ( ) throws  IOException {  LOG . info ( _ STR , initial Checkpoint Generator ) ; try {  Kinesis Reader Checkpoint initial Checkpoint = initial Checkpoint Generator . generate ( kinesis ) ;  List <  Shard Records Iterator > iterators = new Array List ( ) ; for (  Shard Checkpoint checkpoint : initial Checkpoint ) { iterators . add ( checkpoint . get Shard Records Iterator ( kinesis ) ) ; } shard Iterators = new  Round Robin < > ( iterators ) ; } catch (  Transient Kinesis Exception e ) { throw new  IOException ( e ) ; } return advance ( ) ; }
@  Override public  XAData Source create XAData Source (  Properties properties ) throws  SQLException {  Properties properties Copy = new  Properties ( ) ; if ( properties != null ) { properties Copy . put All ( properties ) ; } reject Unsupported Options ( properties Copy ) ; reject Pooling Options ( properties Copy ) ;  Jdbc Data Source data Source = new  Jdbc Data Source ( ) ; setup H2 Data Source ( data Source , properties Copy ) ; return data Source ; }
public static double to Degrees ( double x ) { if (  Double . is Infinite ( x ) || x == _ NUM ) { return x ; } final double facta = _ NUM ; final double factb = _ NUM ; double xa = double High Part ( x ) ; double xb = x - xa ; return xb * factb + xb * facta + xa * factb + xa * facta ; }
void init Demand And Collection Map ( final  List <  String > prepare Field Names , final  Map <  String ,  Big Decimal > demand , final  Map <  String ,  Big Decimal > collection , final  Map <  String ,  Big Decimal > rebates ) { if ( prepare Field Names != null && ! prepare Field Names . is Empty ( ) ) for ( final  String field Name : prepare Field Names ) { demand . put ( field Name ,  Big Decimal .  ZERO ) ; collection . put ( field Name ,  Big Decimal .  ZERO ) ; rebates . put ( field Name ,  Big Decimal .  ZERO ) ; } }
protected  Instance specifier ( int i ) { return m_ Specifiers . get ( i ) ; }
public  Shaped Crafting Recipe (  Item nominal Output ,  Recipe Function recipe Function ,  String format , boolean mirrored ,  Item Ingredient ... ingredients ) { this . nominal Output = nominal Output ;  String [ ] format Lines = format . split ( _ STR ) ; int num Ingredients = _ NUM ; int width = _ NUM ; for (  String format Line : format Lines ) { width =  Math . max ( width , format Line . length ( ) ) ; for ( char c : format Line . to Char Array ( ) ) { if ( c == _ STR ) { continue ; } else if ( c >= _ STR && c <= _ STR ) { num Ingredients ++ ; } else { throw new  Illegal Argument Exception ( _ STR + format + _ STR + c ) ; } } } this . width = width ; this . height = format Lines . length ; this . posx = new int [ num Ingredients ] ; this . posy = new int [ num Ingredients ] ; this . ingredients = new  Item Ingredient [ num Ingredients ] ; this . mirrored = mirrored ; int ingredient Index = _ NUM ; for ( int y = _ NUM ; y < this . height ; y ++ ) {  String format Line = format Lines [ y ] ; for ( int x = _ NUM ; x < format Line . length ( ) ; x ++ ) { char c = format Line . char At ( x ) ; if ( c == _ STR ) { continue ; } this . posx [ ingredient Index ] = x ; this . posy [ ingredient Index ] = y ; this . ingredients [ ingredient Index ] = ingredients [ c - _ STR ] ; ingredient Index ++ ; } } this . recipe Function = recipe Function ; this . last Ingredient Index On First Line = get Last Ingredient Index On First Line ( ) ; }
public void write Tag (  String tag ,  Font value ) { start Tag ( tag ) ; write Tag ( _ STR , value . get Name ( ) ) ; int style = value . get Style ( ) ; if ( ( style &  Font .  BOLD ) != _ NUM && ( style &  Font .  ITALIC ) != _ NUM ) { write Tag (  STYLE , _ STR ) ; } else if ( ( style &  Font .  BOLD ) != _ NUM ) { write Tag (  STYLE , _ STR ) ; } else if ( ( style &  Font .  ITALIC ) != _ NUM ) { write Tag (  STYLE , _ STR ) ; } else { write Tag (  STYLE , _ STR ) ; } write Tag ( _ STR , value . get Size ( ) ) ; close Tag ( ) ; }
private  Socket connect (  String host ,  String port String ) throws  IOException { int port = _ NUM ;  Socket sock = null ; boolean  DEBUG =  Debug . debugging ( _ STR ) ; try { port =  Integer . parse Int ( port String , _ NUM ) ; } catch (  Number Format Exception e ) { if (  DEBUG )  Debug . output ( _ STR + host + _ STR + port String ) ; throw new  IOException ( _ STR + port String ) ; } if (  DEBUG )  Debug . output ( _ STR + host + _ STR + port ) ; try { sock = new  Socket ( host , port ) ; } catch (  IOException e ) { if ( sock != null ) sock . close ( ) ; if (  DEBUG ) {  Debug . output ( _ STR + host + _ STR + port + _ STR + e ) ; } throw e ; } return sock ; }
@  Override public boolean batch Finished ( ) { if ( get Input Format ( ) == null ) { throw new  Illegal State Exception ( _ STR ) ; }  Instances to Filter = get Input Format ( ) ; int cut Off = ( int )  Math . round ( to Filter . num Instances ( ) * m_ Percentage / _ NUM ) ; if ( m_ Inverse ) { for ( int i = _ NUM ; i < cut Off ; i ++ ) { push ( to Filter . instance ( i ) ) ; } } else { for ( int i = cut Off ; i < to Filter . num Instances ( ) ; i ++ ) { push ( to Filter . instance ( i ) ) ; } } flush Input ( ) ; m_ New Batch = _ BOOL ; m_ First Batch Done = _ BOOL ; return ( num Pending Output ( ) != _ NUM ) ; }
public void compute Parameters ( ) { if ( ellps == null ) { ellps =  Ellipsoid .  WGS_84 ; } if ( mode ==  MODE_ BELGIUM ) { alpha = _ NUM ; } else { alpha = _ NUM ; } double phi1 =  Proj Math . deg To Rad ( lambert_sp_one ) ; double phi2 =  Proj Math . deg To Rad ( lambert_sp_two ) ; double phif =  Proj Math . deg To Rad ( reference Latitude ) ; double e = ellps . ecc ; double sinphi ; sinphi =  Math . sin ( phi1 ) ; double m1 = lamb Msfn ( sinphi ,  Math . cos ( phi1 ) , e ) ; double t1 = lamb Tsfn ( phi1 , sinphi , e ) ; if (  More Math . approximately_equal ( phi1 , phi2 ,  EPS10 ) ) { n = sinphi ; } else { sinphi =  Math . sin ( phi2 ) ; double m2 = lamb Msfn ( sinphi ,  Math . cos ( phi2 ) , e ) ; double t2 = lamb Tsfn ( phi2 , sinphi , e ) ; n =  Math . log ( m1 / m2 ) /  Math . log ( t1 / t2 ) ; }  F = m1 / ( n *  Math . pow ( t1 , n ) ) ; if (  More Math . approximately_equal ( phi1 , phi2 ,  EPS10 ) ) { rf = _ NUM ; } else { rf = ellps . radius *  F *  Math . pow ( lamb Tsfn ( phif ,  Math . sin ( phif ) , e ) , n ) ; } lamdaf =  Proj Math . deg To Rad ( central Meridian ) ; location Center XPixel = ( ( double ) get Width ( ) / _ NUM ) ; location Center YPixel = ( ( double ) get Height ( ) / _ NUM ) ; location Pixels Per Lambert = ( double ) get PPM ( ) / get Scale ( ) ;  Lat Lon Point origin = new  Lat Lon Point .  Double ( reference Latitude , central Meridian ) ;  Point2 D lp =  LLTo World ( origin . get Y ( ) , origin . get X ( ) , new  Point2 D .  Double ( ) ) ; location Origin X = lp . get X ( ) ; location Origin Y = lp . get Y ( ) ;  Lat Lon Point center = get Center ( ) ; lp =  LLTo World ( center . get Y ( ) , center . get X ( ) , lp ) ; location Center XLambert = lp . get X ( ) ; location Center YLambert = lp . get Y ( ) ; location Origin Xf Pixel = location Center XPixel + ( location Origin X - location Center XLambert ) * location Pixels Per Lambert ; location Origin Yf Pixel = location Center YPixel - ( location Origin Y - location Center YLambert ) * location Pixels Per Lambert ; if (  Debug . debugging ( _ STR ) ) {  Debug . output ( _ STR + location Center XLambert + _ STR + location Center YLambert ) ;  Debug . output ( _ STR + location Origin X + _ STR + location Origin Y ) ; } }
protected  Ok Http Client configure Http Client ( ) { final  Ok Http Client .  Builder builder = new  Ok Http Client .  Builder ( ) ; final  Cookie Manager cookie Manager = new  Cookie Manager ( ) ; cookie Manager . set Cookie Policy (  Cookie Policy .  ACCEPT_ ALL ) ; builder . cookie Jar ( new  Java Net Cookie Jar ( cookie Manager ) ) ; builder . connect Timeout ( _ NUM ,  Time Unit .  SECONDS ) ; builder . write Timeout ( _ NUM ,  Time Unit .  SECONDS ) ; builder . read Timeout ( _ NUM ,  Time Unit .  SECONDS ) ; return builder . build ( ) ; }
public  String parse File (  File file ) { log . config ( file . get Absolute Path ( ) ) ;  String line = null ; try {  Buffered Reader in = new  Buffered Reader ( new  Input Stream Reader ( new  File Input Stream ( file ) ,  Ini . get Charset ( ) ) , _ NUM ) ;  String err Msg = _ STR ; int line No = _ NUM ; while ( ( line = in . read Line ( ) ) != null && err Msg . length ( ) == _ NUM ) { err Msg = parse Line ( line , line No ) ; line No ++ ; } line = null ; in . close ( ) ; if ( err Msg . length ( ) != _ NUM ) return err Msg ; } catch (  Exception ioe ) {  String s = ioe . get Localized Message ( ) ; if ( s == null || s . length ( ) == _ NUM ) s = ioe . to String ( ) ; return _ STR + line + _ STR + s ; } return _ STR ; }
public static  Test suite ( ) throws  Exception { return suite ( _ BOOL ) ; }
public void load (  Element element ,  Object o ) { log . error ( _ STR ) ; }
public  OMRaster ( double lt , double ln , int offset_x1 , int offset_y1 ,  Image Icon ii ) { this ( lt , ln , offset_x1 , offset_y1 , ii . get Image ( ) ) ; }
private synchronized boolean start Dequeue ( ) { int threads =  Math . min ( queue . size ( ) , max Threads ) ; for ( int i = _ NUM ; i < threads ; i ++ ) {  Resource Thread t = (  Resource Thread ) queue . first Element ( ) ; queue . remove Element At ( _ NUM ) ; running . add Element ( t ) ; thread Count ++ ; } for (  Enumeration e = running . elements ( ) ; e . has More Elements ( ) ; ) {  Resource Thread t = (  Resource Thread ) e . next Element ( ) ; t . go ( ) ; } return ( threads > _ NUM ) ; }
public void property Change (  Property Change Event evt ) {  String name = evt . get Property Name ( ) ; if ( name == _ STR || name == _ STR ) { invalidate Width Cache ( ) ; fire Column Margin Changed ( ) ; } }
public static void assert Equals (  Object object1 ,  Object object2 ) { check Assertion ( object1 . equals ( object2 ) , null ) ; }
public  String format SQL (  Object obj ,  Object expr ) {  String sql = null ; if ( expr instanceof  String ) { sql = (  String ) expr ; if ( log . is Loggable (  Level .  FINEST ) ) { log . finest ( _ STR + sql ) ; } } else if ( obj != null ) { sql = to String ( obj ) ; if ( sql != null ) { if ( sql . starts With ( _ STR ) ) { sql = sql . replace First ( _ STR , _ STR ) ; } sql = sql . replace All ( _ STR ,  BINARY_ SQL_ MARKER ) ; } if ( log . is Loggable (  Level .  FINEST ) ) { log . finest ( _ STR + sql ) ; } } return sql ; }
public void add Fake View (  View child View ) { child View . layout ( _ NUM , _ NUM , get Width ( ) , child View . get Measured Height ( ) ) ; views . add ( child View ) ; }
public void compile Projects (  List <  File > projects ,  Issue Acceptor issue Acceptor ) throws  N4 JSCompile Exception { compile Projects (  Arrays . as List ( new  File ( _ STR ) ) , projects ,  Collections . empty List ( ) , issue Acceptor ) ; }
protected final void print_contact_info (  Object Info Panel p_window , java . util .  Locale p_locale ) {  Collection <  Brd Item > contacts = get_normal_contacts ( ) ; if ( contacts . is Empty ( ) ) return ;  Gui Resources resources = r_board . new Gui Resources ( _ STR ) ; p_window . append ( _ STR + resources . get String ( _ STR ) + _ STR ) ;  Integer contact_count = contacts . size ( ) ; p_window . append_items ( contact_count . to String ( ) , resources . get String ( _ STR ) , contacts ) ; }
@  Suppress Warnings ( _ STR ) public  Promise <  Result ,  Progress > resolve (  Result result ) {  List <  Done Callback <  Result > > done Callbacks ;  List <  Always Callback > always Callbacks ; synchronized ( this ) { validate In Pending State ( ) ; m State =  STATE_ RESOLVED ; print State Changed ( _ STR ) ; m Result = result ; done Callbacks = m Callbacks . clone Done Callbacks ( ) ; always Callbacks = m Callbacks . clone Always Callbacks ( ) ; clear Callbacks ( ) ; } if ( done Callbacks . size ( ) > _ NUM || always Callbacks . size ( ) > _ NUM ) { trigger All Dones ( done Callbacks ) ; trigger All Always ( always Callbacks ) ; } return this ; }
private void create Snapshot (  Block Snapshot snapshot ,  Snap unity Snap ,  Storage System storage ,  Db Client db Client ) { snapshot . set Native Id ( unity Snap . get Id ( ) ) ; snapshot . set Native Guid (  Native GUIDGenerator . generate Native Guid ( storage , snapshot ) ) ; snapshot . set Device Label ( unity Snap . get Name ( ) ) ; snapshot . set Is Sync Active ( _ BOOL ) ; snapshot . set Inactive ( _ BOOL ) ; snapshot . set Creation Time (  Calendar . get Instance ( ) ) ; snapshot . set WWN ( unity Snap . get Attached WWN ( ) ) ; snapshot . set Allocated Capacity ( unity Snap . get Size ( ) ) ; snapshot . set Provisioned Capacity ( unity Snap . get Size ( ) ) ; db Client . create Object ( snapshot ) ; }
public void save ( ) throws  IOException { if ( ! props . is Empty ( ) ) {  Configuration Util . save Configuration Properties ( props , props File , _ BOOL ) ; }  Configuration Util . save Configuration Properties ( props , new  File ( props File . get Parent File ( ) , props File . get Name ( ) + _ STR ) , _ BOOL ) ; }
public static int len (  String list ,  String delimiter , boolean ignore Empty ) { if ( delimiter . length ( ) == _ NUM ) return len ( list , delimiter . char At ( _ NUM ) , ignore Empty ) ; char [ ] del = delimiter . to Char Array ( ) ; int len =  String Util . length ( list ) ; if ( len == _ NUM ) return _ NUM ; int count = _ NUM ; int last = _ NUM ; char c ; for ( int i = _ NUM ; i < len ; i ++ ) { c = list . char At ( i ) ; for ( int y = _ NUM ; y < del . length ; y ++ ) { if ( c == del [ y ] ) { if ( ! ignore Empty || last < i ) count ++ ; last = i + _ NUM ; break ; } } } if ( ! ignore Empty || last < len ) count ++ ; return count ; }
static void dispose ( long p Data , long p Config Info ) {  OGLRender Queue rq =  OGLRender Queue . get Instance ( ) ; rq . lock ( ) ; try {  OGLContext . set Scratch Surface ( p Config Info ) ;  Render Buffer buf = rq . get Buffer ( ) ; rq . ensure Capacity And Alignment ( _ NUM , _ NUM ) ; buf . put Int (  DISPOSE_ SURFACE ) ; buf . put Long ( p Data ) ; rq . flush Now ( ) ; } finally { rq . unlock ( ) ; } }
void render Normal ( ) { gl Enable (  GL_ DEPTH_ TEST ) ; gl Use Program ( this . normal Program ) ; gl Uniform Matrix4fv ( view Matrix Uniform , _ BOOL , view Matrix . get ( matrix Buffer ) ) ; gl Uniform Matrix4fv ( proj Matrix Uniform , _ BOOL , proj Matrix . get ( matrix Buffer ) ) ; gl Uniform Matrix3fv ( normal Matrix Uniform , _ BOOL , normal Matrix . get ( matrix Buffer ) ) ; gl Bind Framebuffer EXT (  GL_ FRAMEBUFFER_ EXT , fbo ) ; gl Clear (  GL_ COLOR_ BUFFER_ BIT |  GL_ DEPTH_ BUFFER_ BIT ) ; gl Bind Buffer (  GL_ ARRAY_ BUFFER , this . cube Vbo ) ; gl Enable Vertex Attrib Array ( _ NUM ) ; gl Vertex Attrib Pointer ( _ NUM , _ NUM ,  GL_ FLOAT , _ BOOL , _ NUM , _ NUM ) ; gl Enable Vertex Attrib Array ( _ NUM ) ; gl Vertex Attrib Pointer ( _ NUM , _ NUM ,  GL_ FLOAT , _ BOOL , _ NUM , normals Offset ) ; gl Draw Arrays (  GL_ TRIANGLES , _ NUM , num Vertices ) ; gl Disable Vertex Attrib Array ( _ NUM ) ; gl Disable Vertex Attrib Array ( _ NUM ) ; gl Bind Buffer (  GL_ ARRAY_ BUFFER , _ NUM ) ; gl Bind Framebuffer EXT (  GL_ FRAMEBUFFER_ EXT , _ NUM ) ; gl Use Program ( _ NUM ) ; }
private <  T extends  CWLResource >  List <  T > look For Resources (  CWLResource Type type ,  Class <  T > clazz ) {  List <  T > resources = get Requirements ( type , clazz ) ; if ( resources == null || resources . size ( ) == _ NUM ) { resources = get Hints ( type , clazz ) ; } return resources ; }
@  Override public boolean release ( int decrement ) { if ( is Empty ) { return _ BOOL ; } if ( decrement < _ NUM ) { throw new  Illegal State Exception (  String . format ( _ STR , decrement , to Verbose String ( ) ) ) ; } final int ref Cnt = ledger . decrement ( decrement ) ; if (  Base Allocator .  DEBUG ) { historical Log . record Event ( _ STR , decrement , ref Cnt + decrement ) ; } if ( ref Cnt < _ NUM ) { throw new  Illegal State Exception (  String . format ( _ STR , id , to Verbose String ( ) ) ) ; } return ref Cnt == _ NUM ; }
int list Size ( ) { int result = mem Size ( ) ; for (  Iterator it = iterator ( ) ; it . has Next ( ) ; ) {  ASTNode child = (  ASTNode ) it . next ( ) ; result += child . tree Size ( ) ; } return result ; }
public  Uniform Distribution estimate ( double min , double max , final int count ) { double grow = ( count > _ NUM ) ? _ NUM * ( max - min ) / ( count - _ NUM ) : _ NUM ; return new  Uniform Distribution (  Math . max ( min - grow , -  Double .  MAX_ VALUE ) ,  Math . min ( max + grow ,  Double .  MAX_ VALUE ) ) ; }
public static  Repository Meta Data read From (  Stream Input in ) throws  IOException {  String name = in . read String ( ) ;  String type = in . read String ( ) ;  Settings settings =  Settings . read Settings From Stream ( in ) ; return new  Repository Meta Data ( name , type , settings ) ; }
public static boolean is Primitive Datatype (  IRI datatype ) { return datatype . equals (  XMLSchema .  DURATION ) || datatype . equals (  XMLSchema .  DATETIME ) || datatype . equals (  XMLSchema .  TIME ) || datatype . equals (  XMLSchema .  DATE ) || datatype . equals (  XMLSchema .  GYEARMONTH ) || datatype . equals (  XMLSchema .  GYEAR ) || datatype . equals (  XMLSchema .  GMONTHDAY ) || datatype . equals (  XMLSchema .  GDAY ) || datatype . equals (  XMLSchema .  GMONTH ) || datatype . equals (  XMLSchema .  STRING ) || datatype . equals (  XMLSchema .  BOOLEAN ) || datatype . equals (  XMLSchema .  BASE64 BINARY ) || datatype . equals (  XMLSchema .  HEXBINARY ) || datatype . equals (  XMLSchema .  FLOAT ) || datatype . equals (  XMLSchema .  DECIMAL ) || datatype . equals (  XMLSchema .  DOUBLE ) || datatype . equals (  XMLSchema .  ANYURI ) || datatype . equals (  XMLSchema .  QNAME ) || datatype . equals (  XMLSchema .  NOTATION ) ; }
protected void append Line (  JComponent c ) { c . set Alignment X ( _ NUM ) ; contents . add ( c ) ; }
public void post Process ( ) { if ( foreign Column Name != null ) { foreign Auto Refresh = _ BOOL ; } if ( foreign Auto Refresh && max Foreign Auto Refresh Level ==  Database Field .  NO_ MAX_ FOREIGN_ AUTO_ REFRESH_ LEVEL_ SPECIFIED ) { max Foreign Auto Refresh Level =  Database Field .  DEFAULT_ MAX_ FOREIGN_ AUTO_ REFRESH_ LEVEL ; } }
private void persist New Temp (  File file Cfg ) { if ( hs Delete On Exit . size ( ) == _ NUM ) { log Debug (  Log Area .  CONFIG , _ STR ) ; file Cfg . delete ( ) ; return ; } log Debug (  Log Area .  CONFIG , _ STR , hs Delete On Exit . size ( ) , file Cfg . get Absolute Path ( ) ) ;  Buffered Writer writer = null ; try { writer = new  Buffered Writer ( new  File Writer ( file Cfg ) ) ; for (  File file : hs Delete On Exit ) { if ( ! file . delete ( ) ) {  String f = file . get Canonical Path ( ) ; writer . write ( f ) ; writer . new Line ( ) ; log Warn (  Log Area .  JAR , _ STR , f ) ; } } } catch (  IOException e ) { } finally { if ( writer != null ) { try { writer . close ( ) ; } catch (  IOException e ) { } } } }
public void add Written ( byte [ ] value ) { write Set Lock . lock ( ) ; write Set . add ( new  Timestamp Value Pair ( ets , value ) ) ; write Set Lock . unlock ( ) ; }
public void load (  Entity unit ) throws  Illegal Argument Exception { if ( ! can Load ( unit ) ) { throw new  Illegal Argument Exception ( _ STR + unit . get Short Name ( ) + _ STR ) ; } current Space -= _ NUM ; troops . add Element ( unit . get Id ( ) ) ; }
public void finish ( ) throws  IOException { if ( ! def . finished ( ) ) { def . finish ( ) ; while ( ! def . finished ( ) ) { int len = def . deflate ( buf , _ NUM , buf . length ) ; if ( def . finished ( ) && len <= buf . length -  TRAILER_ SIZE ) { write Trailer ( buf , len ) ; len = len +  TRAILER_ SIZE ; out . write ( buf , _ NUM , len ) ; return ; } if ( len > _ NUM ) out . write ( buf , _ NUM , len ) ; } byte [ ] trailer = new byte [  TRAILER_ SIZE ] ; write Trailer ( trailer , _ NUM ) ; out . write ( trailer ) ; } }
public boolean free (  T obj ) {  Atomic Integer top Ref = _top ; while ( _ BOOL ) { final int top = top Ref . get ( ) ; if ( _capacity <= top ) { return _ BOOL ; } boolean is Free = _free Stack . compare And Set ( top , null , obj ) ; top Ref . compare And Set ( top , top + _ NUM ) ; if ( is Free ) { return _ BOOL ; } } }
public static boolean has Binding (  Injector injector ,  Key < ? > key ) {  Binding < ? > binding = get Binding ( injector , key ) ; return binding != null ; }
private  Open Replicator Manager MBean create Internal Service (  String service Name ) throws  Replicator Exception { logger . info ( _ STR + service Name ) ; try {  Open Replicator Manager orm = new  Open Replicator Manager ( service Name ) ; orm . set Rmi Host ( manager RMIHost ) ; orm . set Rmi Port ( manager RMIPort ) ; orm . set Host Time Zone ( host Time Zone ) ; orm . set Replicator Time Zone ( replicator Time Zone ) ; orm . advertise Internal ( ) ; orm . set Security Info ( this . security Info ) ; return (  Open Replicator Manager MBean ) orm ; } catch (  Exception e ) { throw new  Replicator Exception (  String . format ( _ STR , service Name ) , e ) ; } }
public static  Check Index .  Status check Index (  Directory dir ) throws  IOException { return check Index ( dir , _ BOOL ) ; }
static void policy Changed (  String service Type Name ,  Policy Event pe ) { if (  DEBUG . message Enabled ( ) ) {  DEBUG . message ( _ STR + service Type Name ) ; } resource Names Map . remove ( service Type Name ) ;  Cache resource Names Cache = (  Cache ) resource Names Map . get ( service Type Name ) ; if ( ( resource Names Cache == null ) || ( resource Names Cache . is Empty ( ) ) ) { return ; } try {  DEBUG . error ( _ STR ) ;  Service Type Manager stm =  Service Type Manager . get Service Type Manager ( ) ;  Service Type service Type = stm . get Service Type ( service Type Name ) ;  Set resource Names To Remove = new  Hash Set ( ) ; synchronized ( resource Names Cache ) {  Enumeration resource Names = resource Names Cache . keys ( ) ; while ( resource Names . has More Elements ( ) ) {  String resource Name = (  String ) resource Names . next Element ( ) ; if ( resource Names To Remove . contains ( resource Name ) ) { continue ; }  Set affected Resource Names = pe . get Resource Names ( ) ;  Iterator iter = affected Resource Names . iterator ( ) ; while ( iter . has Next ( ) ) {  String affected Resource Name = (  String ) iter . next ( ) ; if ( service Type . compare ( resource Name , affected Resource Name ) !=  Resource Match .  NO_ MATCH ) { resource Names To Remove . add ( resource Name ) ; } } }  Iterator iter1 = resource Names To Remove . iterator ( ) ; while ( iter1 . has Next ( ) ) {  String resource Name To Remove = (  String ) iter1 . next ( ) ; resource Names Cache . remove ( resource Name To Remove ) ; } } } catch (  SSOException e ) {  DEBUG . error ( _ STR , e ) ; } catch (  Policy Exception pex ) {  DEBUG . error ( _ STR , pex ) ; } if (  DEBUG . message Enabled ( ) ) {  DEBUG . message ( _ STR + service Type Name + _ STR + resource Names Map . get ( service Type Name ) ) ; } }
private void start Hide Animations ( ) { animation Playing = _ BOOL ; light Animation Layout ( ) ; if ( button Type . equals (  Button Type .  CIRCLE ) ) { if ( hide Order Type . equals (  Order Type .  DEFAULT ) ) { for ( int i = _ NUM ; i < button Num ; i ++ ) { set Hide Animation ( dots [ i ] , circle Buttons [ i ] , end Locations [ i ] , start Locations [ i ] , i ) ; } } else if ( hide Order Type . equals (  Order Type .  REVERSE ) ) { for ( int i = _ NUM ; i < button Num ; i ++ ) { set Hide Animation ( dots [ i ] , circle Buttons [ i ] , end Locations [ i ] , start Locations [ i ] , button Num - i - _ NUM ) ; } } else if ( hide Order Type . equals (  Order Type .  RANDOM ) ) {  Random random = new  Random ( ) ; boolean [ ] used = new boolean [ button Num ] ; for ( int i = _ NUM ; i < button Num ; i ++ ) used [ i ] = _ BOOL ; int count = _ NUM ; while ( _ BOOL ) { int i = random . next Int ( button Num ) ; if ( ! used [ i ] ) { used [ i ] = _ BOOL ; set Hide Animation ( dots [ count ] , circle Buttons [ count ] , end Locations [ count ] , start Locations [ count ] , i ) ; count ++ ; if ( count == button Num ) break ; } } } } else if ( button Type . equals (  Button Type .  HAM ) ) { if ( hide Order Type . equals (  Order Type .  DEFAULT ) ) { for ( int i = _ NUM ; i < button Num ; i ++ ) { set Hide Animation ( bars [ i ] , ham Buttons [ i ] , end Locations [ i ] , start Locations [ i ] , i ) ; } } else if ( hide Order Type . equals (  Order Type .  REVERSE ) ) { for ( int i = _ NUM ; i < button Num ; i ++ ) { set Hide Animation ( bars [ i ] , ham Buttons [ i ] , end Locations [ i ] , start Locations [ i ] , button Num - i - _ NUM ) ; } } else if ( hide Order Type . equals (  Order Type .  RANDOM ) ) {  Random random = new  Random ( ) ; boolean [ ] used = new boolean [ button Num ] ; for ( int i = _ NUM ; i < button Num ; i ++ ) used [ i ] = _ BOOL ; int count = _ NUM ; while ( _ BOOL ) { int i = random . next Int ( button Num ) ; if ( ! used [ i ] ) { used [ i ] = _ BOOL ; set Hide Animation ( bars [ count ] , ham Buttons [ count ] , end Locations [ count ] , start Locations [ count ] , i ) ; count ++ ; if ( count == button Num ) break ; } } } } }
public static void put Short ( long addr , short val ) { if (  UNALIGNED )  UNSAFE . put Short ( addr , val ) ; else put Short By Byte ( addr , val ,  BIG_ ENDIAN ) ; }
public static byte [ ] hash Twice ( byte [ ] input , int offset , int length ) {  Message Digest digest = new Digest ( ) ; digest . update ( input , offset , length ) ; return digest . digest ( digest . digest ( ) ) ; }
public  Pronounceable FSM (  URL url , boolean scan From Front ) throws  IOException { this . scan From Front = scan From Front ;  Input Stream is =  Utilities . get Input Stream ( url ) ; load Text ( is ) ; is . close ( ) ; }
private char [ ] apply Float Padding ( final char [ ] ca4 , final boolean no Digits ) { char [ ] ca5 = ca4 ; if ( field Width Set ) { int i ; int j ; final int n Blanks ; if ( left Justify ) { n Blanks = field Width - ca4 . length ; if ( n Blanks > _ NUM ) { ca5 = new char [ ca4 . length + n Blanks ] ; for ( i = _ NUM ; i < ca4 . length ; i ++ ) { ca5 [ i ] = ca4 [ i ] ; } for ( j = _ NUM ; j < n Blanks ; j ++ , i ++ ) { ca5 [ i ] = _ STR ; } } } else if ( ! leading Zeros || no Digits ) { n Blanks = field Width - ca4 . length ; if ( n Blanks > _ NUM ) { ca5 = new char [ ca4 . length + n Blanks ] ; for ( i = _ NUM ; i < n Blanks ; i ++ ) { ca5 [ i ] = _ STR ; } for ( j = _ NUM ; j < ca4 . length ; i ++ , j ++ ) { ca5 [ i ] = ca4 [ j ] ; } } } else if ( leading Zeros ) { n Blanks = field Width - ca4 . length ; if ( n Blanks > _ NUM ) { ca5 = new char [ ca4 . length + n Blanks ] ; i = _ NUM ; j = _ NUM ; if ( ca4 [ _ NUM ] == _ STR ) { ca5 [ _ NUM ] = _ STR ; i ++ ; j ++ ; } for ( int k = _ NUM ; k < n Blanks ; i ++ , k ++ ) { ca5 [ i ] = _ STR ; } for ( ; j < ca4 . length ; i ++ , j ++ ) { ca5 [ i ] = ca4 [ j ] ; } } } } return ca5 ; }
@  Override public void make Immutable ( ) { if ( is Mutable ) { if ( authn Statements != null ) { int length = authn Statements . size ( ) ; for ( int i = _ NUM ; i < length ; i ++ ) {  Authn Statement authn = (  Authn Statement ) authn Statements . get ( i ) ; authn . make Immutable ( ) ; } authn Statements =  Collections . unmodifiable List ( authn Statements ) ; } if ( authz Decision Statements != null ) { int length = authz Decision Statements . size ( ) ; for ( int i = _ NUM ; i < length ; i ++ ) {  Authz Decision Statement authz = (  Authz Decision Statement ) authz Decision Statements . get ( i ) ; authz . make Immutable ( ) ; } authz Decision Statements =  Collections . unmodifiable List ( authz Decision Statements ) ; } if ( attribute Statements != null ) { int length = attribute Statements . size ( ) ; for ( int i = _ NUM ; i < length ; i ++ ) {  Attribute Statement attr = (  Attribute Statement ) attribute Statements . get ( i ) ; attr . make Immutable ( ) ; } attribute Statements =  Collections . unmodifiable List ( attribute Statements ) ; } if ( statements != null ) { statements =  Collections . unmodifiable List ( statements ) ; } if ( conditions != null ) { conditions . make Immutable ( ) ; } if ( issuer != null ) { issuer . make Immutable ( ) ; } if ( subject != null ) { subject . make Immutable ( ) ; } if ( advice != null ) { advice . make Immutable ( ) ; } is Mutable = _ BOOL ; } }
@  Override public  String find Library (  String name ) {  String system Name =  System . map Library Name ( name ) ;  Array List <  Loader > loaders = get Loaders ( ) ; for ( int i = _ NUM ; i < loaders . size ( ) ; i ++ ) {  Loader loader = loaders . get ( i ) ;  Path path = loader . get Path ( system Name ) ; if ( path != null && path . can Read ( ) ) { return path . get Native Path ( ) ; } path = loader . get Path ( _ STR + system Name ) ; if ( path != null && path . can Read ( ) ) { return path . get Native Path ( ) ; } } for ( int i = _ NUM ; i < _native Path . size ( ) ; i ++ ) {  Path path = _native Path . get ( i ) ; if ( path . can Read ( ) ) return path . get Native Path ( ) ; } return super . find Library ( name ) ; }
public void remove Component Listener ( final  Component Update Listener listener ) { component Listeners . remove ( listener ) ; }
public static _ Fields find By Thrift Id ( int field Id ) { switch ( field Id ) { case _ NUM : return  APPKEY ; case _ NUM : return  SEND_ TIME ; case _ NUM : return  LOAD_ INFO ; case _ NUM : return  STATUS ; default : return null ; } }
public static boolean is Empty (  Char Sequence text ) { return text == null || text . length ( ) == _ NUM ; }
protected byte [ ] assert Encode Decode ( final  IGanglia Metadata Message decl , final  IGanglia Message expected ) { if ( expected == null ) throw new  Illegal Argument Exception ( ) ; final  XDROutput Buffer xdr = new  XDROutput Buffer (  IGanglia Defaults .  BUFFER_ SIZE ) ; final  Ganglia Message Encoder31 message Encoder = new  Ganglia Message Encoder31 ( ) ; final  Ganglia Message Decoder31 message Decoder = new  Ganglia Message Decoder31 ( ) ; if ( expected . is Metric Request ( ) ) { message Encoder . write Request ( xdr , (  IGanglia Request Message ) expected ) ; } else if ( expected . is Metric Metadata ( ) ) { message Encoder . write Metadata ( xdr , (  IGanglia Metadata Message ) expected ) ; } else if ( expected . is Metric Value ( ) ) { if ( decl == null ) throw new  Illegal Argument Exception ( _ STR ) ; message Encoder . write Metric ( xdr , decl , (  IGanglia Metric Message ) expected ) ; } else { throw new  Assertion Error ( ) ; } final  IGanglia Message actual = message Decoder . decode ( xdr . get Buffer ( ) , _ NUM , xdr . get Length ( ) ) ; assert Equals ( _ STR , expected , actual ) ; final byte [ ] actual Data = new byte [ xdr . get Length ( ) ] ;  System . arraycopy ( xdr . get Buffer ( ) , _ NUM , actual Data , _ NUM , actual Data . length ) ; return actual Data ; }
private boolean is Indexable (  String term ) { return ( term . length ( ) < _ NUM ) && ( term . length ( ) > _ NUM ) ; }
private void send Response (  String status ,  String mime ,  Properties header ,  Input Stream data ) { try { if ( status == null ) throw new  Error ( _ STR ) ;  Output Stream out = my Socket . get Output Stream ( ) ;  Print Writer pw = new  Print Writer ( out ) ; pw . print ( _ STR + status + _ STR ) ; if ( mime != null ) pw . print ( _ STR + mime + _ STR ) ; if ( header == null || header . get Property ( _ STR ) == null ) pw . print ( _ STR + gmt Frmt . format ( new  Date ( ) ) + _ STR ) ; if ( header != null ) {  Enumeration e = header . keys ( ) ; while ( e . has More Elements ( ) ) {  String key = (  String ) e . next Element ( ) ;  String value = header . get Property ( key ) ; pw . print ( key + _ STR + value + _ STR ) ; } } pw . print ( _ STR ) ; pw . flush ( ) ; if ( data != null ) { byte [ ] buff = new byte [ _ NUM ] ; while ( _ BOOL ) { int read = data . read ( buff , _ NUM , _ NUM ) ; if ( read <= _ NUM ) break ; out . write ( buff , _ NUM , read ) ; } } out . flush ( ) ; out . close ( ) ; if ( data != null ) data . close ( ) ; } catch (  IOException ioe ) { try { my Socket . close ( ) ; } catch (  Throwable t ) { } } }
public static  String decode (  String encoded ,  AMEncryption encr ) { if ( check Caller ( ) ) { try {  ISSecurity Permission isp = new  ISSecurity Permission ( _ STR , _ STR ) ; if ( security Manager != null ) { security Manager . check Permission ( isp ) ; } } catch (  Security Exception e ) {  Debug debug =  Debug . get Instance ( _ STR ) ; debug . error ( _ STR + _ STR , e ) ; return null ; } } if ( encoded == null || encoded . length ( ) == _ NUM ) { return ( null ) ; } byte [ ] enc Data = null ; enc Data =  Base64 . decode ( encoded . trim ( ) ) ; if ( enc Data == null ) { return null ; } byte [ ] raw Data = encr . decrypt ( enc Data ) ; if ( raw Data == null ) { return ( null ) ; }  String answer = null ; try { answer = new  String ( raw Data , _ STR ) ; } catch (  Unsupported Encoding Exception uue ) {  Debug debug =  Debug . get Instance ( _ STR ) ; debug . error ( _ STR , uue ) ; answer = new  String ( raw Data ) ; } return ( answer ) ; }
protected void wait For Shutdown Signal ( ) throws  Interrupted Exception { if ( mutex Waiting == null ) mutex Waiting = new  Object ( ) ; try { synchronized ( mutex Waiting ) { mutex Waiting . wait ( ) ; } } catch (  Interrupted Exception e ) { if ( ! shutdown ) throw e ; } }
public void add Connection (  Connection connection ) { if ( connection == null ) throw new  Illegal Argument Exception ( _ STR ) ; synchronized ( connections Lock ) {  Connection [ ] new Connections = new  Connection [ connections . length + _ NUM ] ; new Connections [ _ NUM ] = connection ;  System . arraycopy ( connections , _ NUM , new Connections , _ NUM , connections . length ) ; connections = new Connections ; } connection . add Listener ( invoke Listener ) ; if (  TRACE ) trace ( _ STR , _ STR + connection ) ; }
public double distance (  Point2 D pt ) { final double x_distance = ( pt . get X ( ) - x ) * ( pt . get X ( ) - x ) ; final double y_distance = ( pt . get Y ( ) - y ) * ( pt . get Y ( ) - y ) ; return  Math . sqrt ( x_distance + y_distance ) ; }
private static int convert To Int (  String value , int default Value ) {  String trim = value . trim ( ) ; if ( trim . length ( ) == _ NUM ) { return default Value ; } return  Integer . parse Int ( trim ) ; }
public  Chain Iterable <  T > add Item ( @  Not Null  T item ) { return (  Chain Iterable <  T > ) super . add (  Collections . <  T > singleton ( item ) ) ; }
private void update State View ( int it Count ,  Collection <  Individual <  Double > > gen ) {  Platform . run Later ( null ) ; sim Pane Ctrl . wait After Step ( ) ; }
@  Override public void run ( ) { try { for ( ; ; ) { int n = port Getn ( port , buffer Address ,  MAX_ EVENT_ COUNT ) ; assert n > _ NUM ; long address = buffer Address ; for ( int i = _ NUM ; i < n ; i ++ ) { boolean shutdown = process Event ( address ) ; if ( shutdown ) return ; address +=  SIZEOF_ PORT_ EVENT ; } } } catch (  Unix Exception x ) { x . print Stack Trace ( ) ; } }
@  Override public  List <  String > all Keys ( ) {  List <  String > name Files = new  Array List < > ( ) ;  File [ ] files = cache Directory . list Files ( ) ; if ( files == null ) return name Files ; for (  File file : files ) { if ( file . is File ( ) ) { name Files . add ( file . get Name ( ) ) ; } } return name Files ; }
public  Dialogue Recorder (  Dialogue System system ) { this . settings = system . get Settings ( ) ; }
private static final void reschedule Missed Alarms (  Content Resolver cr ,  Context context ,  Alarm Manager Interface manager ) { long now =  System . current Time Millis ( ) ; long ancient = now -  Date Utils .  DAY_ IN_ MILLIS ;  String [ ] projection = new  String [ ] {  Calendar Contract .  Calendar Alerts .  ALARM_ TIME } ; if (  Build .  VERSION .  SDK_ INT >= _ NUM &&  Context Compat . check Self Permission ( context ,  Manifest . permission .  READ_ CALENDAR ) !=  Package Manager .  PERMISSION_ GRANTED ) {  Log . d (  TAG , _ STR ) ; return ; }  Cursor cursor = cr . query (  Calendar Alerts .  CONTENT_ URI , projection ,  WHERE_ RESCHEDULE_ MISSED_ ALARMS , ( new  String [ ] {  Long . to String ( now ) ,  Long . to String ( ancient ) ,  Long . to String ( now ) } ) ,  SORT_ ORDER_ ALARMTIME_ ASC ) ; if ( cursor == null ) { return ; } if (  DEBUG ) {  Log . d (  TAG , _ STR + cursor . get Count ( ) ) ; } try { long alarm Time = - _ NUM ; while ( cursor . move To Next ( ) ) { long new Alarm Time = cursor . get Long ( _ NUM ) ; if ( alarm Time != new Alarm Time ) { if (  DEBUG ) {  Log . w (  TAG , _ STR + new Alarm Time ) ; }  Alert Utils . schedule Alarm ( context , manager , new Alarm Time ) ; alarm Time = new Alarm Time ; } } } finally { cursor . close ( ) ; } }
@  Override default  Completable Future <  Optional Double > min Double ( final  To Double Function < ? super  T > fn ) { return  Completable Future . supply Async ( null , get Exec ( ) ) ; }
private boolean to State (  Lifecycle State new State ) {  Lifecycle State state ; synchronized ( this ) { state = _state ; _state = new State ; _last Change Time =  Current Time . current Time ( ) ; } if ( _log != null && _log . is Loggable ( _low Level ) ) { _log . log ( _low Level , new State + _ STR + _name ) ; } notify Listeners ( state , new State ) ; return _ BOOL ; }
public boolean init Dialog ( ) { log . config ( _ STR ) ; gbc . anchor =  Grid Bag Constraints .  NORTHWEST ; gbc . weightx = _ NUM ; gbc . weighty = _ NUM ; gbc . gridy = m_line ++ ; gbc . gridx = _ NUM ; gbc . gridwidth = _ NUM ; gbc . insets = null Inset ; gbc . fill =  Grid Bag Constraints .  HORIZONTAL ; center Panel . add (  Box . create Vertical Strut ( _ NUM ) , gbc ) ;  MClient client =  MClient . get (  Env . get Ctx ( ) ) ;  String  ASPFilter = _ STR ; if ( client . is Use ASP ( ) )  ASPFilter = _ STR + _ STR + _ STR + _ STR + _ STR + client . get AD_ Client_ ID ( ) + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + client . get AD_ Client_ ID ( ) + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + client . get AD_ Client_ ID ( ) + _ STR + _ STR + _ STR + _ STR + _ STR ;  String sql = null ; if (  Env . is Base Language (  Env . get Ctx ( ) , _ STR ) ) sql = _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR +  ASPFilter + _ STR ; else sql = _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR +  Env . get AD_ Language (  Env . get Ctx ( ) ) + _ STR + _ STR +  ASPFilter + _ STR ; boolean has Fields = _ BOOL ; try {  Prepared Statement pstmt =  DB . prepare Statement ( sql , null ) ; pstmt . set Int ( _ NUM , m_process Info . get AD_ Process_ ID ( ) ) ;  Result Set rs = pstmt . execute Query ( ) ; while ( rs . next ( ) ) { has Fields = _ BOOL ; create Field ( rs ) ; } rs . close ( ) ; pstmt . close ( ) ; } catch (  SQLException e ) { log . log (  Level .  SEVERE , sql , e ) ; } if ( m_m Fields . size ( ) != m_m Fields2 . size ( ) || m_m Fields . size ( ) != m_v Editors . size ( ) || m_m Fields2 . size ( ) != m_v Editors2 . size ( ) ) log . log (  Level .  SEVERE , _ STR ) ; if ( has Fields ) { gbc . gridy = m_line ++ ; center Panel . add (  Box . create Vertical Strut ( _ NUM ) , gbc ) ; gbc . gridx = _ NUM ; center Panel . add (  Box . create Horizontal Strut ( _ NUM ) , gbc ) ;  AEnv . position Center Window ( m_frame , this ) ; } else dispose ( ) ; return has Fields ; }
@  Override protected  String date To String (  Date Time Data date ) {  String Buffer message = new  String Buffer ( _ NUM ) ; message . append ( _ STR ) ; message . append ( _ STR ) ; append ( message , date . month , _ NUM ) ; append ( message , ( char ) date . utc , _ NUM ) ; return message . to String ( ) ; }
private void add Test (  Test new Test ) { if ( m_ Rule List == null ) { m_ Rule List = new  Array List <  Test > ( ) ; } m_ Rule List . add ( new Test ) ; }
public double next Double ( double alpha , double lambda ) { double a = alpha ; double aa = - _ NUM , aaa = - _ NUM , b = _ NUM , c = _ NUM , d = _ NUM , e , r , s = _ NUM , si = _ NUM , ss = _ NUM , q0 = _ NUM , q1 = _ NUM , q2 = _ NUM , q3 = _ NUM , q4 = _ NUM , q5 = - _ NUM , q6 = _ NUM , q7 = _ NUM , q8 = - _ NUM , q9 = _ NUM , a1 = _ NUM , a2 = - _ NUM , a3 = _ NUM , a4 = - _ NUM , a5 = _ NUM , a6 = - _ NUM , a7 = _ NUM , a8 = - _ NUM , a9 = _ NUM , e1 = _ NUM , e2 = _ NUM , e3 = _ NUM , e4 = _ NUM , e5 = _ NUM , e6 = _ NUM , e7 = _ NUM ; double gds , p , q , t , sign_u , u , v , w , x ; double v1 , v2 , v12 ; if ( a <= _ NUM ) throw new  Illegal Argument Exception ( ) ; if ( lambda <= _ NUM ) new  Illegal Argument Exception ( ) ; if ( a < _ NUM ) { b = _ NUM + _ NUM * a ; for ( ; ; ) { p = b * random Generator . raw ( ) ; if ( p <= _ NUM ) { gds =  Math . exp (  Math . log ( p ) / a ) ; if (  Math . log ( random Generator . raw ( ) ) <= - gds ) return ( gds / lambda ) ; } else { gds = -  Math . log ( ( b - p ) / a ) ; if (  Math . log ( random Generator . raw ( ) ) <= ( ( a - _ NUM ) *  Math . log ( gds ) ) ) return ( gds / lambda ) ; } } } else { if ( a != aa ) { aa = a ; ss = a - _ NUM ; s =  Math . sqrt ( ss ) ; d = _ NUM - _ NUM * s ; } do { v1 = _ NUM * random Generator . raw ( ) - _ NUM ; v2 = _ NUM * random Generator . raw ( ) - _ NUM ; v12 = v1 * v1 + v2 * v2 ; } while ( v12 > _ NUM ) ; t = v1 *  Math . sqrt ( - _ NUM *  Math . log ( v12 ) / v12 ) ; x = s + _ NUM * t ; gds = x * x ; if ( t >= _ NUM ) return ( gds / lambda ) ; u = random Generator . raw ( ) ; if ( d * u <= t * t * t ) return ( gds / lambda ) ; if ( a != aaa ) { aaa = a ; r = _ NUM / a ; q0 = ( ( ( ( ( ( ( ( q9 * r + q8 ) * r + q7 ) * r + q6 ) * r + q5 ) * r + q4 ) * r + q3 ) * r + q2 ) * r + q1 ) * r ; if ( a > _ NUM ) { if ( a > _ NUM ) { b = _ NUM ; si = _ NUM ; c = _ NUM / s ; } else { b = _ NUM + _ NUM * ss ; si = _ NUM / s + _ NUM ; c = _ NUM / s + _ NUM ; } } else { b = _ NUM + s - _ NUM * ss ; si = _ NUM ; c = _ NUM / s - _ NUM + _ NUM * s ; } } if ( x > _ NUM ) { v = t / ( s + s ) ; if (  Math . abs ( v ) > _ NUM ) { q = q0 - s * t + _ NUM * t * t + ( ss + ss ) *  Math . log ( _ NUM + v ) ; } else { q = q0 + _ NUM * t * t * ( ( ( ( ( ( ( ( a9 * v + a8 ) * v + a7 ) * v + a6 ) * v + a5 ) * v + a4 ) * v + a3 ) * v + a2 ) * v + a1 ) * v ; } if (  Math . log ( _ NUM - u ) <= q ) return ( gds / lambda ) ; } for ( ; ; ) { do { e = -  Math . log ( random Generator . raw ( ) ) ; u = random Generator . raw ( ) ; u = u + u - _ NUM ; sign_u = ( u > _ NUM ) ? _ NUM : - _ NUM ; t = b + ( e * si ) * sign_u ; } while ( t <= - _ NUM ) ; v = t / ( s + s ) ; if (  Math . abs ( v ) > _ NUM ) { q = q0 - s * t + _ NUM * t * t + ( ss + ss ) *  Math . log ( _ NUM + v ) ; } else { q = q0 + _ NUM * t * t * ( ( ( ( ( ( ( ( a9 * v + a8 ) * v + a7 ) * v + a6 ) * v + a5 ) * v + a4 ) * v + a3 ) * v + a2 ) * v + a1 ) * v ; } if ( q <= _ NUM ) continue ; if ( q > _ NUM ) { w =  Math . exp ( q ) - _ NUM ; } else { w = ( ( ( ( ( ( e7 * q + e6 ) * q + e5 ) * q + e4 ) * q + e3 ) * q + e2 ) * q + e1 ) * q ; } if ( c * u * sign_u <= w *  Math . exp ( e - _ NUM * t * t ) ) { x = s + _ NUM * t ; return ( x * x / lambda ) ; } } } }
public void swap ( int i , int j ) { x . assert True ( i < list . size ( ) ) ; x . assert True ( j < list . size ( ) ) ; list . set ( i , list . set ( j , list . get ( i ) ) ) ; }
private  List <  Name Value Pair > build IPTParameters (  Ipt ipt ,  String organisation Key ) {  List <  Name Value Pair > data = new  Array List <  Name Value Pair > ( ) ; if ( ipt != null && organisation Key != null ) { data . add ( new  Basic Name Value Pair ( _ STR ,  String Utils . trim To Empty ( organisation Key ) ) ) ; data . add ( new  Basic Name Value Pair ( _ STR ,  String Utils . trim To Empty ( ipt . get Name ( ) ) ) ) ; data . add ( new  Basic Name Value Pair ( _ STR ,  String Utils . trim To Empty ( ipt . get Description ( ) ) ) ) ; data . add ( new  Basic Name Value Pair ( _ STR ,  String Utils . trim To Empty ( ipt . get Primary Contact Type ( ) ) ) ) ; data . add ( new  Basic Name Value Pair ( _ STR ,  String Utils . trim To Empty ( ipt . get Primary Contact Name ( ) ) ) ) ; data . add ( new  Basic Name Value Pair ( _ STR ,  String Utils . trim To Empty ( ipt . get Primary Contact Email ( ) ) ) ) ; data . add ( new  Basic Name Value Pair ( _ STR ,  SERVICE_ TYPE_ RSS ) ) ; data . add ( new  Basic Name Value Pair ( _ STR , get Rss Feed URL ( ) ) ) ; } else { log . debug ( _ STR ) ; } return data ; }
public static <  T ,  U extends  Closeable >  T with Closeable (  U self , @  Closure Params ( value =  First Param . class )  Closure <  T > action ) throws  IOException { try {  T result = action . call ( self ) ;  Closeable temp = self ; self = null ; temp . close ( ) ; return result ; } finally {  Default Groovy Methods Support . close With Warning ( self ) ; } }
public static boolean is Match (  String actual String ,  Linked List patterns , char wild Card ) { boolean matched = _ BOOL ; for (  List Iterator iter = patterns . list Iterator ( _ NUM ) ; iter . has Next ( ) ; ) { if ( is Match ( actual String , (  String ) iter . next ( ) , wild Card ) ) { matched = _ BOOL ; break ; } } return matched ; }
public synchronized void add Server (  Server Location location ,  String [ ] groups ,  Server Load initial Load , long load Poll Interval ) { server Group Map . put ( location , groups ) ;  Load Holder connection Load = new  Load Holder ( location , initial Load . get Connection Load ( ) , initial Load . get Load Per Connection ( ) , load Poll Interval ) ; add Groups ( connection Load Map , groups , connection Load ) ;  Load Holder queue Load = new  Load Holder ( location , initial Load . get Subscription Connection Load ( ) , initial Load . get Load Per Subscription Connection ( ) , load Poll Interval ) ; add Groups ( queue Load Map , groups , queue Load ) ; update Load ( location , initial Load ) ; }
public void add Leaf (  Catalog Tree Leaf leaf ) { _leaves . add ( leaf ) ; }
private static  String stamp To String ( long tstamp ,  String format Mask ) {  String Builder sb = new  String Builder ( _ NUM ) ;  Formatter fmt = new  Formatter ( sb ,  Locale .  US ) ; int [ ] pieces = new int [  NUMIDX ] ;  Component Time . unpack Bits ( tstamp , pieces ) ; fmt . format ( format Mask , pieces [  YIDX ] , pieces [  MIDX ] , pieces [  DIDX ] , pieces [  HIDX ] , pieces [  IIDX ] , pieces [  SIDX ] , pieces [  UIDX ] ) ; fmt . close ( ) ; return ( sb . to String ( ) ) ; }
public  Http Request content Length ( final  String value ) { return content Length (  Integer . parse Int ( value ) ) ; }
public  VNXe Command Job modify Lun Async (  Lun Modify Param param ,  String resource Id ) {  String Builder url Bld = new  String Builder (  URL_ RESOURCE ) ; url Bld . append ( resource Id ) ; url Bld . append (  URL_ LUN_ MODIFY_ ACTION ) ; _url = url Bld . to String ( ) ; return post Request Async ( param ) ; }
public  String replace (  Char Sequence target ,  Char Sequence replacement ) { if ( target == null ) { throw new  Null Pointer Exception ( _ STR ) ; } if ( replacement == null ) { throw new  Null Pointer Exception ( _ STR ) ; }  String ts = target . to String ( ) ; int index = index Of ( ts , _ NUM ) ; if ( index == - _ NUM ) return this ;  String rs = replacement . to String ( ) ;  String Builder buffer = new  String Builder ( count ) ; int tl = target . length ( ) ; int tail = _ NUM ; do { buffer . append ( value , offset + tail , index - tail ) ; buffer . append ( rs ) ; tail = index + tl ; } while ( ( index = index Of ( ts , tail ) ) != - _ NUM ) ; buffer . append ( value , offset + tail , count - tail ) ; return buffer . to String ( ) ; }
public boolean similar To (  Object o ) { if ( o == null ) { return _ BOOL ; } if ( ! ( o instanceof  Semantic Concept ) ) { return _ BOOL ; }  Semantic Concept other Concept = (  Semantic Concept ) o ;  Hash Set <  Integer > synset_intersection = new  Hash Set <  Integer > ( this . synsets ) ; synset_intersection . retain All ( other Concept . synsets ) ; if ( ! synset_intersection . is Empty ( ) ) { return _ BOOL ; }  Hash Set <  String > concept_intersection = new  Hash Set <  String > ( this . concepts ) ; concept_intersection . retain All ( other Concept . concepts ) ; return ! concept_intersection . is Empty ( ) ; }
public void j Google Analytics Tracker ( final  String event Type , final  String version , final  String tracker Id ) { final  JGoogle Analytics Tracker tracker = new  JGoogle Analytics Tracker ( _ STR , version , tracker Id ) ; final  Focus Point focus Point = new  Focus Point ( event Type . to Lower Case ( ) ) ; tracker . track Asynchronously ( focus Point ) ; }
public void put (  Song song ) { if ( ! m Songs . contains ( song ) ) { m Songs . add ( song ) ; } }
@  Not Null public  Psi Query children Named ( @  Not Null final  Class < ? extends  Psi Named Element > clazz , @  Not Null final  String name ) { final  List <  Psi Element > result = new  Array List <  Psi Element > ( ) ; for ( final  Psi Element element : my Psi Elements ) { for ( final  Psi Named Element child :  Psi Tree Util . find Children Of Type ( element , clazz ) ) { if ( name . equals ( child . get Name ( ) ) ) { result . add ( child ) ; } } } return new  Psi Query ( result . to Array ( new  Psi Element [ result . size ( ) ] ) ) ; }
@  Override public boolean equals (  Object o ) { return o . hash Code ( ) == hash Code ( ) ; }
private  Array List <  String > parse Json (  String text ) { text = text . substring ( text . index Of ( _ STR ) +  SIZE_ OF_ EVENTS , text . index Of ( _ STR ) ) ;  Array List <  String > events = new  Array List <  String > ( ) ; if ( text . is Empty ( ) ) { return events ; } int start Index = _ NUM , end Index = _ NUM ; while ( end Index != - _ NUM ) { end Index = text . index Of ( _ STR , start Index +  DELIMITER_ SIZE ) ;  String event Text = ( end Index == - _ NUM ? text . substring ( start Index ) : text . substring ( start Index , end Index ) ) ;  Pattern pattern =  Pattern . compile ( _ STR ) ;  Matcher matcher = pattern . matcher ( event Text ) ; event Text = matcher . replace All ( _ STR ) ; pattern =  Pattern . compile ( _ STR ) ; matcher = pattern . matcher ( event Text ) ; if ( matcher . find ( ) ) { event Text = matcher . replace First ( matcher . group ( _ NUM ) + _ STR ) ; } event Text = _ STR + event Text ; start Index = end Index + _ NUM ; events . add ( event Text ) ; }  Collections . reverse ( events ) ; return events ; }
public  Str Builder replace ( int start Index , int end Index ,  String replace Str ) { end Index = validate Range ( start Index , end Index ) ; int insert Len = ( replace Str == null ? _ NUM : replace Str . length ( ) ) ; replace Impl ( start Index , end Index , end Index - start Index , replace Str , insert Len ) ; return this ; }
public static void add Permission Recursive (  Path path ,  Posix File Permission permission ) throws  IOException { change Permissions Recursive ( path ,  Permission Change .  ADD ,  Collections . singleton ( permission ) ) ; }
private void run Timeout Task ( ) { while ( is Active ( ) ) { reap Timeouts ( ) ; try {  Thread . sleep ( _timeout Reap Interval ) ; } catch (  Exception e ) { } } }
public void test Case19 ( ) { byte a Bytes [ ] = { - _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , - _ NUM , _ NUM , - _ NUM , _ NUM , _ NUM } ; byte b Bytes [ ] = { _ NUM , - _ NUM , _ NUM , _ NUM , _ NUM } ; int a Sign = _ NUM ; int b Sign = - _ NUM ; byte r Bytes [ ] = { _ NUM , - _ NUM , _ NUM , _ NUM , _ NUM } ;  Big Integer a Number = new  Big Integer ( a Sign , a Bytes ) ;  Big Integer b Number = new  Big Integer ( b Sign , b Bytes ) ;  Big Integer result = a Number . remainder ( b Number ) ; byte res Bytes [ ] = new byte [ r Bytes . length ] ; res Bytes = result . to Byte Array ( ) ; for ( int i = _ NUM ; i < res Bytes . length ; i ++ ) { assert True ( res Bytes [ i ] == r Bytes [ i ] ) ; } assert Equals ( _ STR , _ NUM , result . signum ( ) ) ; }
public static boolean has Visible Children (  Action Group group ,  Presentation Factory factory ,  Action Manager action Manager ,  Perspective Manager perspective Manager ) {  Action Event event = new  Action Event ( factory . get Presentation ( group ) , action Manager , perspective Manager ) ; for (  Action an Action : group . get Children ( event ) ) { if ( an Action == null ) {  Log . error (  Utils . class , _ STR + group + _ STR + factory . get Presentation ( group ) ) ; continue ; } if ( an Action instanceof  Separator ) { continue ; } final  Presentation presentation = factory . get Presentation ( an Action ) ; an Action . update ( new  Action Event ( presentation , action Manager , perspective Manager ) ) ; if ( an Action instanceof  Action Group ) {  Action Group child Group = (  Action Group ) an Action ; if ( child Group . is Popup ( ) ) { if ( ! presentation . is Visible ( ) ) { continue ; } } if ( has Visible Children ( child Group , factory , action Manager , perspective Manager ) ) { return _ BOOL ; } } else if ( presentation . is Visible ( ) ) { return _ BOOL ; } } return _ BOOL ; }
private static void check Arg References (  String type Snippet , int number Of Args ) {  Matcher arg Ref Matcher =  ARG_ REF_ PATTERN . matcher ( type Snippet ) ; while ( arg Ref Matcher . find ( ) ) { int index =  Integer . parse Int ( arg Ref Matcher . group ( _ NUM ) , _ NUM ) - _ NUM ;  Preconditions . check Argument ( index >= _ NUM , _ STR , arg Ref Matcher . group ( _ NUM ) ) ;  Preconditions . check Argument ( index < number Of Args , _ STR , arg Ref Matcher . group ( _ NUM ) ) ; } }
public void randomize ( ) { randomize Incoming Weights ( ) ; normalize Incoming Weights ( ) ; }
private boolean is File Valid (  File file ,  String method Name ) { if ( file == null ) {  Log . print Concat Line ( name , _ STR , method Name , _ STR ) ; return _ BOOL ; }  String file Name = file . get Name ( ) ; if ( file Name == null || file Name . length ( ) == _ NUM ) {  Log . print Concat Line ( name , _ STR + method Name , _ STR ) ; return _ BOOL ; } return _ BOOL ; }
public void append ( byte [ ] bytes ) { append ( bytes , _ NUM , bytes . length ) ; }
public static boolean enough Space On Phone ( long update Size ) { return get Real Size On Phone ( ) > update Size ; }
private  Object string To Value (  Object old Value ,  String new Value ) throws  Replicator Exception { if ( old Value instanceof  String ) { return new Value ; } else if ( old Value instanceof  Integer ) { return  Integer . value Of ( new Value ) ; } else if ( old Value instanceof  Serial Blob ) { try { return  Database Helper . get Safe Blob ( new Value . get Bytes ( ) ) ; } catch (  SQLException e ) { throw new  Replicator Exception ( _ STR + e , e ) ; } } else { return new Value ; } }
public void add Nodes In Doc Order (  DTMIterator iterator ,  XPath Context support ) { if ( ! m_mutable ) throw new  Runtime Exception (  XSLMessages . create XPATHMessage (  XPATHError Resources .  ER_ NODESETDTM_ NOT_ MUTABLE , null ) ) ; int node ; while (  DTM .  NULL != ( node = iterator . next Node ( ) ) ) { add Node In Doc Order ( node , support ) ; } }
public  String to ZString ( ) {  String Builder buffer = new  String Builder ( _ NUM ) ; try { print Z ( buffer ) ; } catch (  IOException e ) { throw new  Runtime Exception ( _ STR , e ) ; } return buffer . to String ( ) ; }
public  Trie Dictionary <  T > build ( int base Id ) { byte [ ] trie Bytes = build Trie Bytes ( base Id ) ;  Trie Dictionary <  T > r = new  Trie Dictionary <  T > ( trie Bytes ) ; return r ; }
public void record State (  Dialogue State state ,  String name ) { states . put ( name , state ) ; if ( ! list Model . contains ( name ) ) { int position = name . contains (  CURRENT ) ? _ NUM :  Math . min ( _ NUM , list Model . size ( ) ) ; list Model . add ( position , name ) ; } }
public int write UTF8 ( final  Char Sequence chars , int off , int len ) { if ( len > remaining ( ) ) { return write UTF8 Slow ( chars , off , len ) ; } final  Block block = current ; int limit = block . limit ; char ch = _ STR ; int octets = _ NUM ; while ( len > _ NUM ) { ch = chars . char At ( off ) ; if ( ch >=  UTF8_2_ OCTET_ MIN_ VALUE ) { break ; } block . data [ limit ++ ] = ( byte ) ch ; octets ++ ; off ++ ; len -- ; } block . limit = limit ; if ( len > _ NUM ) { if ( ch <  UTF8_3_ OCTET_ MIN_ VALUE ) { return octets + write UTF8 Up To2 Byte ( chars , off , len ) ; } if ( ch >=  LOW_ SURROGATE_ FIRST && ch <=  LOW_ SURROGATE_ LAST ) { throw new  Illegal Argument Exception ( _ STR + ch ) ; } if ( ch >=  HIGH_ SURROGATE_ FIRST && ch <=  HIGH_ SURROGATE_ LAST ) { return octets + write UTF8 Slow ( chars , off , len ) ; } return octets + write UTF8 Up To3 Byte ( chars , off , len ) ; } return octets ; }
public  Geo Server WPSClient (  Geo Server Connection connection ) { this . connection = connection ; }
protected  Connection State SSLv3 (  SSLSession Impl session ) { try {  Cipher Suite cipher Suite = session . cipher Suite ; boolean is_exportabe = cipher Suite . is Exportable ( ) ; hash_size = cipher Suite . get MACLength ( ) ; int key_size = ( is_exportabe ) ? cipher Suite . key Material : cipher Suite . expanded Key Material ; int iv_size = cipher Suite . iv Size ; block_size = cipher Suite . get Block Size ( ) ;  String alg Name = cipher Suite . get Bulk Encryption Algorithm ( ) ;  String hash Name = cipher Suite . get Hash Name ( ) ; if ( logger != null ) { logger . println ( _ STR ) ; logger . println ( _ STR + session . get Cipher Suite ( ) ) ; logger . println ( _ STR + alg Name ) ; logger . println ( _ STR + hash Name ) ; logger . println ( _ STR + hash_size ) ; logger . println ( _ STR + block_size ) ; logger . println ( _ STR + iv_size ) ; logger . println ( _ STR + key_size ) ; } byte [ ] client Random = session . client Random ; byte [ ] server Random = session . server Random ; byte [ ] key_block = new byte [ _ NUM * hash_size + _ NUM * key_size + _ NUM * iv_size ] ; byte [ ] seed = new byte [ client Random . length + server Random . length ] ;  System . arraycopy ( server Random , _ NUM , seed , _ NUM , server Random . length ) ;  System . arraycopy ( client Random , _ NUM , seed , server Random . length , client Random . length ) ;  PRF . compute PRF_ SSLv3 ( key_block , session . master_secret , seed ) ; byte [ ] client_mac_secret = new byte [ hash_size ] ; byte [ ] server_mac_secret = new byte [ hash_size ] ; byte [ ] client_key = new byte [ key_size ] ; byte [ ] server_key = new byte [ key_size ] ; boolean is_client = ! session . is Server ;  System . arraycopy ( key_block , _ NUM , client_mac_secret , _ NUM , hash_size ) ;  System . arraycopy ( key_block , hash_size , server_mac_secret , _ NUM , hash_size ) ;  System . arraycopy ( key_block , _ NUM * hash_size , client_key , _ NUM , key_size ) ;  System . arraycopy ( key_block , _ NUM * hash_size + key_size , server_key , _ NUM , key_size ) ;  Iv Parameter Spec client IV = null ;  Iv Parameter Spec server IV = null ; if ( is_exportabe ) { if ( logger != null ) { logger . println ( _ STR ) ; }  Message Digest md5 =  Message Digest . get Instance ( _ STR ) ; md5 . update ( client_key ) ; md5 . update ( client Random ) ; md5 . update ( server Random ) ; client_key = md5 . digest ( ) ; md5 . update ( server_key ) ; md5 . update ( server Random ) ; md5 . update ( client Random ) ; server_key = md5 . digest ( ) ; key_size = cipher Suite . expanded Key Material ; if ( block_size != _ NUM ) { md5 . update ( client Random ) ; md5 . update ( server Random ) ; client IV = new  Iv Parameter Spec ( md5 . digest ( ) , _ NUM , iv_size ) ; md5 . update ( server Random ) ; md5 . update ( client Random ) ; server IV = new  Iv Parameter Spec ( md5 . digest ( ) , _ NUM , iv_size ) ; } } else if ( block_size != _ NUM ) { client IV = new  Iv Parameter Spec ( key_block , _ NUM * hash_size + _ NUM * key_size , iv_size ) ; server IV = new  Iv Parameter Spec ( key_block , _ NUM * hash_size + _ NUM * key_size + iv_size , iv_size ) ; } if ( logger != null ) { logger . println ( _ STR + is_exportabe ) ; logger . println ( _ STR ) ; logger . print ( session . master_secret ) ; logger . println ( _ STR ) ; logger . print ( client Random ) ; logger . println ( _ STR ) ; logger . print ( server Random ) ; logger . println ( _ STR ) ; logger . print ( client_mac_secret ) ; logger . println ( _ STR ) ; logger . print ( server_mac_secret ) ; logger . println ( _ STR ) ; logger . print ( client_key , _ NUM , key_size ) ; logger . println ( _ STR ) ; logger . print ( server_key , _ NUM , key_size ) ; if ( client IV != null ) { logger . println ( _ STR ) ; logger . print ( client IV . get IV ( ) ) ; logger . println ( _ STR ) ; logger . print ( server IV . get IV ( ) ) ; } else { logger . println ( _ STR ) ; } } if ( alg Name == null ) { enc Cipher = new  Null Cipher ( ) ; dec Cipher = new  Null Cipher ( ) ; } else { enc Cipher =  Cipher . get Instance ( alg Name ) ; dec Cipher =  Cipher . get Instance ( alg Name ) ; if ( is_client ) { enc Cipher . init (  Cipher .  ENCRYPT_ MODE , new  Secret Key Spec ( client_key , _ NUM , key_size , alg Name ) , client IV ) ; dec Cipher . init (  Cipher .  DECRYPT_ MODE , new  Secret Key Spec ( server_key , _ NUM , key_size , alg Name ) , server IV ) ; } else { enc Cipher . init (  Cipher .  ENCRYPT_ MODE , new  Secret Key Spec ( server_key , _ NUM , key_size , alg Name ) , server IV ) ; dec Cipher . init (  Cipher .  DECRYPT_ MODE , new  Secret Key Spec ( client_key , _ NUM , key_size , alg Name ) , client IV ) ; } } message Digest =  Message Digest . get Instance ( hash Name ) ; if ( is_client ) { mac_write_secret = client_mac_secret ; mac_read_secret = server_mac_secret ; } else { mac_write_secret = server_mac_secret ; mac_read_secret = client_mac_secret ; } if ( hash Name . equals ( _ STR ) ) { pad_1 =  SSLv3 Constants .  MD5pad1 ; pad_2 =  SSLv3 Constants .  MD5pad2 ; } else { pad_1 =  SSLv3 Constants .  SHApad1 ; pad_2 =  SSLv3 Constants .  SHApad2 ; } } catch (  Exception e ) { e . print Stack Trace ( ) ; throw new  Alert Exception (  Alert Protocol .  INTERNAL_ ERROR , new  SSLProtocol Exception ( _ STR ) ) ; } }
long cleanup ( long now ) { int in Use Connection Count = _ NUM ; int idle Connection Count = _ NUM ;  Real Connection longest Idle Connection = null ; long longest Idle Duration Ns =  Long .  MIN_ VALUE ; synchronized ( this ) { for (  Iterator <  Real Connection > i = connections . iterator ( ) ; i . has Next ( ) ; ) {  Real Connection connection = i . next ( ) ; if ( prune And Get Allocation Count ( connection , now ) > _ NUM ) { in Use Connection Count ++ ; continue ; } idle Connection Count ++ ; long idle Duration Ns = now - connection . idle At Nanos ; if ( idle Duration Ns > longest Idle Duration Ns ) { longest Idle Duration Ns = idle Duration Ns ; longest Idle Connection = connection ; } } if ( longest Idle Duration Ns >= this . keep Alive Duration Ns || idle Connection Count > this . max Idle Connections ) { connections . remove ( longest Idle Connection ) ; } else if ( idle Connection Count > _ NUM ) { return keep Alive Duration Ns - longest Idle Duration Ns ; } else if ( in Use Connection Count > _ NUM ) { return keep Alive Duration Ns ; } else { cleanup Running = _ BOOL ; return - _ NUM ; } } close Quietly ( longest Idle Connection . socket ( ) ) ; return _ NUM ; }
public  State Info ( ) { }
public boolean compare (  Object expected ,  Object current ) { if ( current != null ) { equal = current . equals ( expected ) ; } else if ( expected != null ) { equal = expected . equals ( _ NUM ) ; } return equal ; }
public static byte [ ] decode (  String hexa ) throws  Coder Exception { if ( hexa == null ) { throw new  Coder Exception ( _ STR ) ; } if ( ( hexa . length ( ) % _ NUM ) != _ NUM ) { throw new  Coder Exception ( _ STR ) ; } int tam Array = hexa . length ( ) / _ NUM ; byte [ ] retorno = new byte [ tam Array ] ; for ( int i = _ NUM ; i < tam Array ; i ++ ) { retorno [ i ] = hex To Byte ( hexa . substring ( i * _ NUM , i * _ NUM + _ NUM ) ) ; } return retorno ; }
private  List <  User Namespace Authorization > create User Namespace Authorizations From Entities (  List <  User Namespace Authorization Entity > user Namespace Authorization Entities ) {  List <  User Namespace Authorization > user Namespace Authorizations = new  Array List < > ( ) ; for (  User Namespace Authorization Entity user Namespace Authorization Entity : user Namespace Authorization Entities ) { user Namespace Authorizations . add ( create User Namespace Authorization From Entity ( user Namespace Authorization Entity ) ) ; } return user Namespace Authorizations ; }
private void read Header ( ) throws  Open Stego Exception { this . data Header = new  DCTData Header ( this , this . config ) ; }
protected void draw Text (  String text1 ,  String text2 , int x , int y ,  Canvas c ) { if ( text Paint == null ) {  Paint p = new  Paint ( ) ; p . set Typeface (  Roboto Light Typeface . get Instance ( context ) ) ; p . set Color ( text Color ) ; p . set Text Size ( _ NUM * pixel Density ) ; this . text Paint = p ; } float w = text Paint . measure Text ( text1 , _ NUM , text1 . length ( ) ) ; int offset = ( int ) w / _ NUM ; c . draw Text ( text1 , x - offset , y + ( _ NUM * pixel Density ) , text Paint ) ; w = text Paint . measure Text ( text2 , _ NUM , text2 . length ( ) ) ; offset = ( int ) w / _ NUM ; c . draw Text ( text2 , x - offset , y + ( _ NUM * pixel Density ) , text Paint ) ; }
public boolean is Less Then Or Equal To (  Percent  Percent ) { assert Defined ( ) ;  Big Decimal this Value = not Null ( this ) ;  Big Decimal parameter = not Null (  Percent ) ; return ( this Value . compare To ( parameter ) <= _ NUM ) ; }
public static boolean point Outside Pref Size (  JTable table , int row , int column ,  Point p ) { if ( table . convert Column Index To Model ( column ) != _ NUM || row == - _ NUM ) { return _ BOOL ; }  Table Cell Renderer tcr = table . get Cell Renderer ( row , column ) ;  Object value = table . get Value At ( row , column ) ;  Component cell = tcr . get Table Cell Renderer Component ( table , value , _ BOOL , _ BOOL , row , column ) ;  Dimension item Size = cell . get Preferred Size ( ) ;  Rectangle cell Bounds = table . get Cell Rect ( row , column , _ BOOL ) ; cell Bounds . width = item Size . width ; cell Bounds . height = item Size . height ; assert ( p . x >= cell Bounds . x && p . y >= cell Bounds . y ) ; return p . x > cell Bounds . x + cell Bounds . width || p . y > cell Bounds . y + cell Bounds . height ; }
public  Builder add Source Folder ( @  Non Null  File folder ) { folders To Scan . add ( folder ) ; return this ; }
public  Method suspend SRDFGroup Method ( final  URI system URI , final  Remote Director Group group , final  List <  URI > source Volumes , final  List <  URI > target Volumes ) { return new  Workflow .  Method (  SUSPEND_ SRDF_ GROUP_ METHOD , system URI , group , source Volumes , target Volumes ) ; }
private void field Goal Att (  Team offense ,  Team defense ) { double fg Dist Ratio =  Math . pow ( ( _ NUM - game Yard Line ) / _ NUM , _ NUM ) ; double fg Acc Ratio =  Math . pow ( ( _ NUM - game Yard Line ) / _ NUM , _ NUM ) ; double fg Dist Chance = ( get HFadv ( ) + offense . get K ( _ NUM ) . rat Kick Pow - fg Dist Ratio * _ NUM ) ; double fg Acc Chance = ( get HFadv ( ) + offense . get K ( _ NUM ) . rat Kick Acc - fg Acc Ratio * _ NUM ) ; if ( fg Dist Chance > _ NUM && fg Acc Chance *  Math . random ( ) > _ NUM ) { if ( game Poss ) { home Score += _ NUM ;  Home KStats [ _ NUM ] ++ ;  Home KStats [ _ NUM ] ++ ; } else { away Score += _ NUM ;  Away KStats [ _ NUM ] ++ ;  Away KStats [ _ NUM ] ++ ; } game Event Log += get Event Prefix ( ) + offense . abbr + _ STR + offense . get K ( _ NUM ) . name + _ STR + ( _ NUM - game Yard Line ) + _ STR ; add Points Quarter ( _ NUM ) ; offense . get K ( _ NUM ) . stats FGMade ++ ; offense . get K ( _ NUM ) . stats FGAtt ++ ; if ( ! playing OT ) kick Off ( offense ) ; else reset For OT ( ) ; } else { game Event Log += get Event Prefix ( ) + offense . abbr + _ STR + offense . get K ( _ NUM ) . name + _ STR + ( _ NUM - game Yard Line ) + _ STR ; offense . get K ( _ NUM ) . stats FGAtt ++ ; if ( ! playing OT ) { game Yard Line =  Math . max ( _ NUM - game Yard Line , _ NUM ) ; game Down = _ NUM ; game Yards Need = _ NUM ; if ( game Poss ) {  Home KStats [ _ NUM ] ++ ; } else {  Away KStats [ _ NUM ] ++ ; } game Poss = ! game Poss ; } else reset For OT ( ) ; } game Time -= _ NUM ; }
public static final byte [ ] unzip ( byte [ ] in ) throws  IOException {  Byte Array Output Stream out Stream = new  Byte Array Output Stream (  EXPECTED_ COMPRESSION_ RATIO * in . length ) ;  GZIPInput Stream in Stream = new  GZIPInput Stream ( new  Byte Array Input Stream ( in ) ) ; byte [ ] buf = new byte [  BUF_ SIZE ] ; while ( _ BOOL ) { int size = in Stream . read ( buf ) ; if ( size <= _ NUM ) break ; out Stream . write ( buf , _ NUM , size ) ; } out Stream . close ( ) ; return out Stream . to Byte Array ( ) ; }
@  Override public double calculate M ( double delta , double epsilon ) { double i = _ NUM ; while ( conf ( i , delta ) > epsilon / _ NUM ) { i = i + _ NUM ; } if ( i > _ NUM ) { i = i - _ NUM ; } while ( conf ( i , delta ) > ( epsilon / _ NUM ) ) { i ++ ; } return  Math . ceil ( i ) ; }
public static  Server Socket create Server Socket ( int port ,  Inet Address bind Address ) throws  IOException {  Server Socket socket = null ; if (  Sys Properties .  ENABLE_ ANONYMOUS_ TLS ) { remove Anon From Legacy Algorithms ( ) ; } set Keystore ( ) ;  Server Socket Factory f =  SSLServer Socket Factory . get Default ( ) ;  SSLServer Socket secure Socket ; if ( bind Address == null ) { secure Socket = (  SSLServer Socket ) f . create Server Socket ( port ) ; } else { secure Socket = (  SSLServer Socket ) f . create Server Socket ( port , _ NUM , bind Address ) ; } secure Socket . set Enabled Protocols ( disable SSL ( secure Socket . get Enabled Protocols ( ) ) ) ; if (  Sys Properties .  ENABLE_ ANONYMOUS_ TLS ) {  String [ ] list = enable Anonymous ( secure Socket . get Enabled Cipher Suites ( ) , secure Socket . get Supported Cipher Suites ( ) ) ; secure Socket . set Enabled Cipher Suites ( list ) ; } socket = secure Socket ; return socket ; }
public void print Bytes ( byte [ ] data , int offset , int length ) throws  IOException { int i ; for ( ; length >= _ NUM ; length -= _ NUM ) { int chunk = ( ( ( data [ offset ] & _ NUM ) << _ NUM ) + ( ( data [ offset + _ NUM ] & _ NUM ) << _ NUM ) + ( data [ offset + _ NUM ] & _ NUM ) ) ; os . write ( base64encode ( chunk > > _ NUM ) ) ; os . write ( base64encode ( chunk > > _ NUM ) ) ; os . write ( base64encode ( chunk > > _ NUM ) ) ; os . write ( base64encode ( chunk ) ) ; offset += _ NUM ; } if ( length == _ NUM ) { int chunk = ( ( data [ offset ] & _ NUM ) << _ NUM ) + ( data [ offset + _ NUM ] & _ NUM ) ; os . write ( base64encode ( chunk > > _ NUM ) ) ; os . write ( base64encode ( chunk > > _ NUM ) ) ; os . write ( base64encode ( chunk ) ) ; os . write ( _ STR ) ; } else if ( length == _ NUM ) { int chunk = data [ offset ] & _ NUM ; os . write ( base64encode ( chunk > > _ NUM ) ) ; os . write ( base64encode ( chunk ) ) ; os . write ( _ STR ) ; os . write ( _ STR ) ; } }
public void delete VVset (  String native Id ) throws  Exception { _log . info ( _ STR ) ;  Client Response client Resp = null ; final  String path =  Message Format . format (  URI_ DELETE_ CG , native Id ) ; _log . info ( _ STR + path ) ; try { client Resp = delete ( path ) ; if ( client Resp == null ) { _log . error ( _ STR ) ; throw new  HP3 PARException ( _ STR ) ; } else if ( client Resp . get Status ( ) != _ NUM ) {  String err Resp = get Response Details ( client Resp ) ; throw new  HP3 PARException ( err Resp ) ; } else { _log . info ( _ STR ) ; } } catch (  Exception e ) { throw e ; } finally { if ( client Resp != null ) { client Resp . close ( ) ; } _log . info ( _ STR ) ; } }
private int find Key Comment Index (  String key Name ) { for ( int i = _ NUM ; i < key Val Comments . size ( ) ; i ++ ) {  String t = key Val Comments . get ( i ) ;  String targeted Key = _ STR + key Name + _ STR ; if ( t . starts With ( targeted Key ) ) { return i ; } } if ( log . is Debug Enabled ( ) ) { log . debug ( _ STR + key Name ) ; } return - _ NUM ; }
public boolean is Expired ( ) { return ( cookie Expiry Date != null && cookie Expiry Date . get Time ( ) <=  System . current Time Millis ( ) ) ; }
public  Rounded Icon Generator ( int icon Width Px , int icon Height Px , int corner Radius Px , int background Color , float text Size Px ) { m Icon Width Px = icon Width Px ; m Icon Height Px = icon Height Px ; m Corner Radius Px = corner Radius Px ; m Background Rect = new  Rect F ( _ NUM , _ NUM , m Icon Width Px , m Icon Height Px ) ; m Background Paint = new  Paint (  Paint .  ANTI_ ALIAS_ FLAG ) ; m Background Paint . set Color ( background Color ) ; m Text Paint = new  Text Paint (  Paint .  ANTI_ ALIAS_ FLAG ) ; m Text Paint . set Color (  Color .  WHITE ) ; m Text Paint . set Fake Bold Text ( _ BOOL ) ; m Text Paint . set Text Size ( text Size Px ) ;  Font Metrics text Font Metrics = m Text Paint . get Font Metrics ( ) ; m Text Height = ( float )  Math . ceil ( text Font Metrics . bottom - text Font Metrics . top ) ; m Text YOffset = - text Font Metrics . top ; }
In Memory Entry Store ( ) { entries =  Maps . new Hash Map ( ) ; top Level Entries =  Sets . new Hash Set ( ) ; children =  Hash Multimap . create ( ) ; }
public  Class Annotator (  URL [ ] codebase ,  Properties props ) { if ( props != null ) properties . put All ( props ) ; set Annotation URLs ( codebase ) ; }
public int next ( ) { return mix ( gen . get And Increment ( ) ) ; }
public  Input Stream put ( final  URLConnection connection , final boolean flush Cache On Close ) { final  String key = get Key ( connection ) ; if ( key == null ) return null ; if ( ! is Cacheable ( (  Http URLConnection ) connection ) ) try { cache . remove ( key ) ; return null ; } catch (  IOException e ) { return null ; }  String etag = connection . get Header Field (  HEADER_ ETAG ) ; if ( etag == null || etag . length ( ) == _ NUM ) return null ;  Editor editor ; try { editor = cache . edit ( key ) ; } catch (  IOException e ) { return null ; } if ( editor == null ) return null ; try { editor . set (  ETAG , etag ) ; } catch (  IOException e ) { try { editor . abort ( ) ; } catch (  IOException ignored ) { } return null ; }  Input Stream input ; try { input = connection . get Input Stream ( ) ; if ( ! ( input instanceof  Inflater Input Stream ) &&  ENCODING_ GZIP . equals ( connection . get Header Field (  HEADER_ CONTENT_ ENCODING ) ) ) input = new  GZIPInput Stream ( input ) ; } catch (  IOException e ) { return null ; }  Output Stream output ; try { output = editor . new Output Stream (  BODY ) ; } catch (  IOException e ) { return null ; } if ( output != null ) return new  Cache Stream ( input , output , editor , this , flush Cache On Close ) ; else return null ; }
public static  String [ ] parse Title (  String title ) {  String v [ ] = { _ STR , _ STR } ; if ( title == null ) return v ;  Pattern p =  Pattern . compile ( _ STR ,  Pattern .  CASE_ INSENSITIVE ) ;  Matcher m = p . matcher ( title ) ; if ( m . find ( ) ) { v [ _ NUM ] = m . group ( _ NUM ) ; v [ _ NUM ] = m . group ( _ NUM ) ; } else { v [ _ NUM ] = title ; } return v ; }
public  String sel ( ) { return m Selection . to String ( ) ; }
public double calculate Excitatory Ratio ( ) { excitatory Ratio = ex Synapse Set . size ( ) / ( double ) size ( ) ; if (  Double . is Na N ( excitatory Ratio ) ) { return _ NUM ; } return excitatory Ratio ; }
public void root Removed (  ISVNRepository Location root ) {  Iterator it = listeners . iterator ( ) ; while ( it . has Next ( ) ) {  IRepository Listener listener = (  IRepository Listener ) it . next ( ) ; listener . repository Removed ( root ) ; } }
public synchronized void insert ( double _priority ,  Object _data ) { num Elements ++ ; if ( num Elements == queue . length ) {  Priority Queue Node [ ] tmp = new  Priority Queue Node [ ( int ) ( queue . length * _ NUM ) ] ;  System . arraycopy ( queue , _ NUM , tmp , _ NUM , queue . length ) ; for ( int i = queue . length ; i < tmp . length ; i ++ ) { tmp [ i ] = new  Priority Queue Node ( ) ; } queue = tmp ; } queue [ num Elements ] . data = _data ; queue [ num Elements ] . priority = _priority ; reheapify ( num Elements ) ; }
protected  Message ( ) { }
protected  String wrap Linux Command (  String command ) throws  IOException ,  Interrupted Exception {  String set Group = _ STR + get Gid ( ) + _ STR + get Gid ( ) + _ STR + get Gid ( ) + _ STR ;  String set User = _ STR + get Uid ( ) + _ STR + get Uid ( ) + _ STR + get Gid ( ) + _ STR ;  String chown Command = _ STR ; return set Group + _ STR + set User + _ STR + chown Command + _ STR + command + _ STR + chown Command ; }
public  Abstract DMLQuery parse Sql Query (  SQLQuery sql Query ,  ISpace Proxy space ) throws  SQLException {  Abstract DMLQuery query = (  Abstract DMLQuery ) get Query From Cache ( get Unique Key ( sql Query ) ) ; try { if ( query == null ) { if ( _logger . is Loggable (  Level .  FINE ) ) { _logger . fine ( _ STR ) ; }  Sql Parser parser = init Parser ( sql Query . get Query ( ) ) ; query = parse ( parser ) ; query . set Table Name ( sql Query . get Type Name ( ) ) ; query . validate Query ( space ) ; if ( ! query . is Prepared ( ) && ! query . contains Sub Queries ( ) ) query . build ( ) ; add Query To Cache ( get Unique Key ( sql Query ) , query ) ; if ( ! query . is Prepared ( ) ) return query ; } query = query . clone ( ) ; return query ; } catch (  SQLException sql Ex ) { if ( _logger . is Loggable (  Level .  FINE ) ) { _logger . log (  Level .  FINE , _ STR + sql Query . get Query ( ) + _ STR , sql Ex ) ; } throw sql Ex ; } catch (  Throwable t ) { if ( _logger . is Loggable (  Level .  FINE ) ) { _logger . log (  Level .  FINE , _ STR + sql Query . get Query ( ) + _ STR , t ) ; }  SQLException sql Ex = new  SQLException ( _ STR + sql Query . get Query ( ) + _ STR + t , _ STR , - _ NUM ) ; sql Ex . init Cause ( t ) ; throw sql Ex ; } }
private int index Of Element In Level ( int element , int level [ ] ) throws  Exception { for ( int i = _ NUM ; i < level . length ; i ++ ) { if ( level [ i ] == element ) { return i ; } } throw new  Exception ( _ STR + m_nodes . get ( element ) .  ID + _ STR + _ STR ) ; }
public int size ( ) { return _attrs . size ( ) ; }
public void deep Sort ( int [ ] set Feature Sequence ) { feature Sequence = set Feature Sequence ; number Of Leaves = _ NUM ; tree = new  Mary Node ( _ NUM , feature Vectors . length ) ; sort Node ( _ NUM , tree ) ; }
public void remove Listeners ( ) { listeners . clear ( ) ; }
public  String decrypt (  String s Cipher Text ) { int n Len = ( s Cipher Text . length ( ) > > _ NUM ) & ~ _ NUM ; if ( n Len <  Blowfish ECB .  BLOCKSIZE ) return null ; byte [ ] cbciv = new byte [  Blowfish ECB .  BLOCKSIZE ] ; int n Num Of Bytes =  Bin Converter . bin Hex To Bytes ( s Cipher Text , cbciv , _ NUM , _ NUM ,  Blowfish ECB .  BLOCKSIZE ) ; if ( n Num Of Bytes <  Blowfish ECB .  BLOCKSIZE ) return null ; m_bfish . set CBCIV ( cbciv ) ; n Len -=  Blowfish ECB .  BLOCKSIZE ; if ( n Len == _ NUM ) return _ STR ; byte [ ] buf = new byte [ n Len ] ; n Num Of Bytes =  Bin Converter . bin Hex To Bytes ( s Cipher Text , buf ,  Blowfish ECB .  BLOCKSIZE * _ NUM , _ NUM , n Len ) ; if ( n Num Of Bytes < n Len ) return null ; m_bfish . decrypt ( buf ) ; int n Pad Byte = buf [ buf . length - _ NUM ] & _ NUM ; if ( ( n Pad Byte > _ NUM ) || ( n Pad Byte < _ NUM ) ) n Pad Byte = _ NUM ; n Num Of Bytes -= n Pad Byte ; if ( n Num Of Bytes < _ NUM ) return _ STR ; return  Bin Converter . byte Array To UNCString ( buf , _ NUM , n Num Of Bytes ) ; }
public static double  L_ Rank Loss ( int y [ ] , int r [ ] ) { int  L = y . length ;  Array List <  Integer > t I = new  Array List <  Integer > ( ) ;  Array List <  Integer > f I = new  Array List <  Integer > ( ) ; for ( int j = _ NUM ; j <  L ; j ++ ) { if ( y [ j ] == _ NUM ) { t I . add ( j ) ; } else { f I . add ( j ) ; } } if ( ! t I . is Empty ( ) && ! f I . is Empty ( ) ) { int c = _ NUM ; for ( int k : t I ) { for ( int l : f I ) { if ( position ( k , r ) < position ( l , r ) ) { c ++ ; } } } return ( double ) c / ( double ) ( t I . size ( ) * f I . size ( ) ) ; } else { return _ NUM ; } }
private double add Recursively (  Array List < double [ ] > hull ,  Hierarchy <  Cluster <  Model > > hier ,  Cluster <  Model > clus ) { final  DBIDs ids = clus . get IDs ( ) ; double weight = ids . size ( ) ; for (  DBIDIter iter = ids . iter ( ) ; iter . valid ( ) ; iter . advance ( ) ) { double [ ] proj P = proj . fast Project Data To Render Space ( rel . get ( iter ) ) ; if ( proj P [ _ NUM ] != proj P [ _ NUM ] || proj P [ _ NUM ] != proj P [ _ NUM ] ) { continue ; } hull . add ( proj P ) ; } for (  Iter <  Cluster <  Model > > iter = hier . iter Children ( clus ) ; iter . valid ( ) ; iter . advance ( ) ) { weight += _ NUM * add Recursively ( hull , hier , iter . get ( ) ) ; } return weight ; }
public void attribute Update (  Print Service Attribute Event psae ) { log . fine ( _ STR + psae ) ; }
public void evict ( ) throws  Exception { assert Open ( ) ; boolean is Empty ; synchronized ( this ) { is Empty = pool . is Empty ( ) ; } if ( ! is Empty ) { if ( soft Min Evictable Idle Time Millis > _ NUM ) { int num To Evict = get Num Idle ( ) - get Min Idle ( ) ; evict (  System . current Time Millis ( ) - soft Min Evictable Idle Time Millis , num To Evict ) ; } if ( min Evictable Idle Time Millis > _ NUM ) { int num To Evict = get Num Idle ( ) ; evict (  System . current Time Millis ( ) - min Evictable Idle Time Millis , num To Evict ) ; } } }
protected void generate Random Population ( int population_size ) { logger . debug ( _ STR ) ; for ( int i = _ NUM ; i < population_size ; i ++ ) {  T individual = chromosome Factory . get Chromosome ( ) ; for (  Fitness Function < ? > fitness Function : this . fitness Functions ) { individual . add Fitness ( fitness Function ) ; } population . add ( individual ) ; if ( is Finished ( ) ) break ; } logger . debug ( _ STR + population . size ( ) + _ STR ) ; }
public  Session ( ) { long uptime =  System . current Time Millis ( ) ; m Main Handler = new  Handler (  Looper . get Main Looper ( ) ) ; m Timestamp = ( uptime / _ NUM ) << _ NUM & ( ( ( uptime - ( ( uptime / _ NUM ) * _ NUM ) ) > > _ NUM ) / _ NUM ) ; m Origin = _ STR ; try { s Signal . await ( ) ; } catch (  Interrupted Exception e ) { } }
public  List <  Visitante > listar ( ) {  List <  Visitante > dados = new  Array List < > ( ) ; try {  String sql = _ STR ; stm = conector . prepare Statement ( sql ) ; rs = stm . execute Query ( sql ) ; while ( rs . next ( ) ) { dados . add ( new  Visitante ( rs . get Int ( _ NUM ) , rs . get String ( _ NUM ) , rs . get String ( _ NUM ) , rs . get String ( _ NUM ) , rs . get String ( _ NUM ) , rs . get String ( _ NUM ) ,  Tempo . to Date ( rs . get Timestamp ( _ NUM ) ) , rs . get String ( _ NUM ) , rs . get String ( _ NUM ) ) ) ; } stm . close ( ) ; rs . close ( ) ; } catch (  SQLException ex ) {  Mensagem . erro ( _ STR + ex ) ; } return dados ; }
private void insert Before (  Instruction [ ] list ,  Instruction s ) { for (  Instruction x : list ) { s . insert Before ( x ) ; } }
public int count Array (  String [ ] array ) { return array . length ; }
private void process Unprocessed ( ) { boolean clean_processings =  Boolean . get Boolean ( _ STR ) ; logger . info ( _ STR + _ STR + clean_processings + _ STR ) ; product Service . process Unprocessed ( ! clean_processings ) ; }
public double [ ] popy ( double x_ [ ] ) { return pop Y ( new double [ ] [ ] { x_ } ) [ _ NUM ] ; }
public void goto Frame ( int frame Number ) throws  IOException { print ( _ STR , new  String [ ] {  Integer . to String ( frame Number ) } ) ; }
public void delete (  String name ) throws  IOException { if ( name . equals Ignore Case (  SUBJECT_ NAME ) ) { names = null ; } else { throw new  IOException ( _ STR + _ STR ) ; } encode This ( ) ; }
public  Geo Distance Builder add Unbounded From (  String key , double from ) { ranges . add ( new  Range ( key , from , null ) ) ; return this ; }
private void send Response (  Document doc ,  Message Factory message Factory ,  String content Type ,  Http Servlet Response res ) throws  IOException ,  SOAPException {  SOAPMessage reply = message Factory . create Message ( ) ;  SOAPHeader header = reply . get SOAPHeader ( ) ; header . detach Node ( ) ;  SOAPBody reply Body = reply . get SOAPBody ( ) ; res . set Header ( _ STR , content Type ) ; reply Body . add Document ( doc ) ; reply . save Changes ( ) ;  Output Stream os = res . get Output Stream ( ) ; reply . write To ( os ) ; os . flush ( ) ; }
public static  String replace Chars (  String str ,  String oldchars , char newchar ) { int pos = index Of Chars ( str , oldchars ) ; if ( pos == - _ NUM ) { return str ; }  String Builder buf = new  String Builder ( str ) ; do { buf . set Char At ( pos , newchar ) ; pos = index Of Chars ( str , oldchars , pos + _ NUM ) ; } while ( pos != - _ NUM ) ; return buf . to String ( ) ; }
public  In Memory Message Exchange Store ( final  Network Config config ,  Token Provider token Provider ) { if ( config == null ) { throw new  Null Pointer Exception ( _ STR ) ; } if ( token Provider == null ) { throw new  Null Pointer Exception ( _ STR ) ; } this . token Provider = token Provider ; this . config = config ; }
public static void next ( ) { try { if ( music Playback Service != null ) { music Playback Service . next ( ) ; } } catch ( final  Remote Exception ignored ) { } }
public long startstack ( ) { return  Long . parse Long ( fields [ _ NUM ] ) ; }
private void draw Bitmap With Stroke (  Canvas canvas ,  Bitmap bitmap , int center X , int center Y , float radius ,  Paint draw Paint ) { draw Paint . set Style (  Paint .  Style .  FILL ) ; float stroke Radius = radius + m Radius Stroke Width ; draw Paint . set Xfermode ( new  Porter Duff Xfermode (  Porter Duff .  Mode .  CLEAR ) ) ; canvas . draw Circle ( center X , center Y , stroke Radius , draw Paint ) ; draw Paint . set Xfermode ( null ) ; final int half Bitmap Width = bitmap . get Width ( ) / _ NUM ; final int half Bitmap Height = bitmap . get Height ( ) / _ NUM ;  Bitmap Shader bitmap Shader = new  Bitmap Shader ( bitmap ,  Shader .  Tile Mode .  REPEAT ,  Shader .  Tile Mode .  REPEAT ) ;  Matrix shader Matrix = new  Matrix ( ) ; float min Size = bitmap . get Width ( ) > bitmap . get Height ( ) ? bitmap . get Height ( ) : bitmap . get Width ( ) ; float scale = radius * _ NUM / min Size ; shader Matrix . set Scale ( scale , scale ) ; shader Matrix . post Translate ( center X - ( half Bitmap Width * scale ) , center Y - ( half Bitmap Height * scale ) ) ; bitmap Shader . set Local Matrix ( shader Matrix ) ; draw Paint . set Shader ( bitmap Shader ) ; canvas . draw Circle ( center X , center Y , radius , draw Paint ) ; draw Paint . set Shader ( null ) ; }
public  Mqtt Device mqtt Device ( ) { return mqtt Device ; }
public  Abba Locking Detector start Collecting ( ) { thread = new  Thread ( this , _ STR ) ; thread . set Daemon ( _ BOOL ) ; thread . start ( ) ; return this ; }
public float to Meters ( double pixels ) { return ( float ) ( pixels *  METERS_ PER_ PIXELS ) ; }
boolean add To Buffer ( char c ) throws  IOException { int len = sb . length ( ) ; if ( len == _ NUM && c !=  CHAR_ LT ) return _ BOOL ; sb . append ( c ) ; if ( ++ len >= min Tag Len ) { boolean is Closing Tag = ( len >= _ NUM && sb . char At ( _ NUM ) ==  CHAR_ SL ) ;  String substr ; if ( is Closing Tag ) substr = sb . substring ( _ NUM ) ; else substr = sb . substring ( _ NUM ) ; for ( int i = _ NUM ; i <  EXCLUDE_ TAGS . length ; i ++ ) { if ( substr . equals Ignore Case (  EXCLUDE_ TAGS [ i ] ) ) { if ( is Closing Tag ) { depth Dec ( i ) ; print Buffer ( ) ; last Char = _ NUM ; } else { depth Inc ( i ) ; } } } } return _ BOOL ; }
public static double length ( double x , double y , double z ) { return  Math . sqrt ( x * x + y * y + z * z ) ; }
public static <  T >  T json To Object (  String json String ,  Class <  T > klass ) {  T object From Json = null ; try {  Gf Json Object json Object = new  Gf Json Object ( json String ) ; object From Json = klass . new Instance ( ) ;  Method [ ] declared Methods = klass . get Declared Methods ( ) ;  Map <  String ,  Method > methods Map = new  Hash Map <  String ,  Method > ( ) ; for (  Method method : declared Methods ) { methods Map . put ( method . get Name ( ) , method ) ; } int no Of Fields = json Object . size ( ) ;  Iterator <  String > keys = json Object . keys ( ) ; while ( keys . has Next ( ) ) {  String key = keys . next ( ) ;  Method method = methods Map . get ( _ STR + capitalize ( key ) ) ; if ( method != null ) {  Class < ? > [ ] parameter Types = method . get Parameter Types ( ) ; if ( parameter Types . length == _ NUM ) {  Class < ? > parameter Type = parameter Types [ _ NUM ] ;  Object value = json Object . get ( key ) ; if ( is Primitive Or Wrapper ( parameter Type ) ) { value = get Primitive Or Wrapper Value ( parameter Type , value ) ; } else if ( is Array ( parameter Type ) ) { value = to Array ( value , parameter Type ) ; } else if ( is List ( parameter Type ) ) { value = to List ( value , parameter Type ) ; } else if ( is Map ( parameter Type ) ) { value = to Map ( value , parameter Type ) ; } else if ( is Set ( parameter Type ) ) { value = to Set ( value , parameter Type ) ; } else { value = json To Object ( value . to String ( ) , parameter Type ) ; } method . invoke ( object From Json , new  Object [ ] { value } ) ; no Of Fields -- ; } } } if ( no Of Fields != _ NUM ) { throw new  Illegal Argument Exception ( _ STR + json String + _ STR + klass ) ; } } catch (  Instantiation Exception e ) { throw new  Illegal Argument Exception ( _ STR + klass , e ) ; } catch (  Illegal Access Exception e ) { throw new  Illegal Argument Exception ( _ STR + klass , e ) ; } catch (  Gf Json Exception e ) { throw new  Illegal Argument Exception ( _ STR + klass , e ) ; } catch (  Illegal Argument Exception e ) { throw new  Illegal Argument Exception ( _ STR + klass , e ) ; } catch (  Invocation Target Exception e ) { throw new  Illegal Argument Exception ( _ STR + klass , e ) ; } return object From Json ; }
private  Cache create Cache ( ) throws  Cache Exception { final  Properties props = new  Properties ( ) ; props . set Property (  LOCATORS , _ STR ) ; props . set Property (  MCAST_ PORT , _ STR ) ; return  Cache Factory . create (  Distributed System . connect ( props ) ) ; }
public  Attribute List Panel ( ) { m_ Table . set Selection Mode (  List Selection Model .  SINGLE_ SELECTION ) ; m_ Table . set Column Selection Allowed ( _ BOOL ) ; m_ Table . set Preferred Scrollable Viewport Size ( new  Dimension ( _ NUM , _ NUM ) ) ; set Layout ( new  Border Layout ( ) ) ; add ( new  JScroll Pane ( m_ Table ) ,  Border Layout .  CENTER ) ; }
protected  String [ ] [ ] to Array ( ) { int i ; int n ; int ii ; int nn ; int x ; int y ;  String [ ] [ ] result ;  String [ ] [ ] tmp Result ; int cols ; int rows ; boolean value Exists ; rows = get Visible Row Count ( ) ; if ( get Show Average ( ) ) { rows ++ ; } cols = get Visible Col Count ( ) ; if ( get Show Std Dev ( ) ) { cols = cols * _ NUM ; } else { cols = cols * _ NUM ; } result = new  String [ rows + _ NUM ] [ cols + _ NUM ] ; result [ _ NUM ] [ _ NUM ] = trim String ( _ STR , get Row Name Width ( ) ) ; x = _ NUM ; for ( ii = _ NUM ; ii < get Col Count ( ) ; ii ++ ) { i = get Display Col ( ii ) ; if ( get Col Hidden ( i ) ) { continue ; } result [ _ NUM ] [ x ] = trim String ( remove Filter Name ( get Col Name ( i ) ) , get Col Name Width ( ) ) ; x ++ ; if ( get Show Std Dev ( ) ) { result [ _ NUM ] [ x ] = _ STR ; x ++ ; } result [ _ NUM ] [ x ] = _ STR ; x ++ ; } y = _ NUM ; for ( ii = _ NUM ; ii < get Row Count ( ) ; ii ++ ) { i = get Display Row ( ii ) ; if ( ! get Row Hidden ( i ) ) { result [ y ] [ _ NUM ] = trim String ( remove Filter Name ( get Row Name ( i ) ) , get Row Name Width ( ) ) ; y ++ ; } } y = _ NUM ; for ( ii = _ NUM ; ii < get Row Count ( ) ; ii ++ ) { i = get Display Row ( ii ) ; if ( get Row Hidden ( i ) ) { continue ; } x = _ NUM ; for ( nn = _ NUM ; nn < get Col Count ( ) ; nn ++ ) { n = get Display Col ( nn ) ; if ( get Col Hidden ( n ) ) { continue ; } value Exists = ( !  Double . is Na N ( get Mean ( n , i ) ) ) ; if ( ! value Exists ) { result [ y ] [ x ] = _ STR ; } else { result [ y ] [ x ] = double To String ( get Mean ( n , i ) , get Mean Prec ( ) ) ; } x ++ ; if ( get Show Std Dev ( ) ) { if ( ! value Exists ) { result [ y ] [ x ] = _ STR ; } else if (  Double . is Infinite ( get Std Dev ( n , i ) ) ) { result [ y ] [ x ] = _ STR ; } else { result [ y ] [ x ] = double To String ( get Std Dev ( n , i ) , get Std Dev Prec ( ) ) ; } x ++ ; } if ( ! value Exists ) { result [ y ] [ x ] = _ STR ; } else { switch ( get Significance ( n , i ) ) { case  SIGNIFICANCE_ TIE : result [ y ] [ x ] =  TIE_ STRING ; break ; case  SIGNIFICANCE_ WIN : result [ y ] [ x ] =  WIN_ STRING ; break ; case  SIGNIFICANCE_ LOSS : result [ y ] [ x ] =  LOSS_ STRING ; break ; } } x ++ ; } y ++ ; } if ( get Show Average ( ) ) { y = result . length - _ NUM ; x = _ NUM ; result [ y ] [ _ NUM ] = _ STR ; x ++ ; for ( ii = _ NUM ; ii < get Col Count ( ) ; ii ++ ) { i = get Display Col ( ii ) ; if ( get Col Hidden ( i ) ) { continue ; } result [ y ] [ x ] = double To String ( get Average ( i ) , get Mean Prec ( ) ) ; x ++ ; if ( get Show Std Dev ( ) ) { result [ y ] [ x ] = _ STR ; x ++ ; } result [ y ] [ x ] = _ STR ; x ++ ; } } y = result . length - _ NUM ; x = _ NUM ; result [ y ] [ _ NUM ] =  LEFT_ PARENTHESES +  WIN_ STRING + _ STR +  TIE_ STRING + _ STR +  LOSS_ STRING +  RIGHT_ PARENTHESES ; x ++ ; for ( ii = _ NUM ; ii < get Col Count ( ) ; ii ++ ) { i = get Display Col ( ii ) ; if ( get Col Hidden ( i ) ) { continue ; } result [ y ] [ x ] = _ STR ; x ++ ; if ( get Show Std Dev ( ) ) { result [ y ] [ x ] = _ STR ; x ++ ; } result [ y ] [ x ] =  LEFT_ PARENTHESES + get Significance Count ( i ,  SIGNIFICANCE_ WIN ) + _ STR + get Significance Count ( i ,  SIGNIFICANCE_ TIE ) + _ STR + get Significance Count ( i ,  SIGNIFICANCE_ LOSS ) +  RIGHT_ PARENTHESES ; x ++ ; } tmp Result = new  String [ result . length ] [ result [ _ NUM ] . length - _ NUM ] ; x = _ NUM ; for ( i = _ NUM ; i < result [ _ NUM ] . length ; i ++ ) { if ( ( ( i == _ NUM ) && ( get Show Std Dev ( ) ) ) || ( ( i == _ NUM ) && ( ! get Show Std Dev ( ) ) ) ) { continue ; } for ( n = _ NUM ; n < result . length ; n ++ ) { tmp Result [ n ] [ x ] = result [ n ] [ i ] ; } x ++ ; } result = tmp Result ; return result ; }
private  Environment ( ) { throw  Contract Utils . unreachable ( ) ; }
public void remove Photo (  Photo Entity photo ) { photos . remove ( photo ) ; }
public static void compute ( double min Score , double top Percent , double max Expected , float min Percent Identity ,  IRead Block read Block ,  String classification Name ,  Bit Set active Matches For Classification ) { active Matches For Classification . clear ( ) ; for ( int i = _ NUM ; i < read Block . get Number Of Available Match Blocks ( ) ; i ++ ) { final  IMatch Block match Block = read Block . get Match Block ( i ) ; if ( ! match Block . is Ignore ( ) && match Block . get Bit Score ( ) >= min Score && match Block . get Expected ( ) <= max Expected && match Block . get Percent Identity ( ) >= min Percent Identity ) { if ( match Block . get Id ( classification Name ) > _ NUM ) active Matches For Classification . set ( i ) ; } } float best Score = _ NUM ; for ( int i = active Matches For Classification . next Set Bit ( _ NUM ) ; i != - _ NUM ; i = active Matches For Classification . next Set Bit ( i + _ NUM ) ) { final  IMatch Block match Block = read Block . get Match Block ( i ) ; float score = match Block . get Bit Score ( ) ; if ( score > best Score ) best Score = score ; } apply Top Percent Filter ( top Percent , best Score , min Percent Identity , read Block , active Matches For Classification ) ; }
public  E [ ] to Array (  E [ ] a ) { if ( a . length != array . length ( ) ) { throw new  Elasticsearch Generation Exception ( _ STR ) ; } for ( int i = _ NUM ; i < array . length ( ) ; i ++ ) { a [ i ] = array . get ( i ) ; } return a ; }
synchronized public void fail On (  Failure fail ) { if ( failures == null ) { failures = new  Array List < > ( ) ; } failures . add ( fail ) ; }
public void dump_stack ( ) { if ( stack == null ) { debug_message ( _ STR ) ; return ; } debug_message ( _ STR ) ; for ( int i = _ NUM ; i < stack . size ( ) ; i ++ ) { debug_message ( _ STR + ( ( symbol ) stack . element At ( i ) ) . sym + _ STR + ( ( symbol ) stack . element At ( i ) ) . parse_state ) ; } debug_message ( _ STR ) ; }
private static  Set <  String > create Categories Set (  Set <  String > categories ) {  Set <  String > result = new  Hash Set < > ( ) ; for (  String cat : categories ) { result . add (  String Util . to Lower Case ( cat ) ) ; } return result ; }
public void upload (  File file , long restart At ,  FTPData Transfer Listener listener ) throws  Illegal State Exception ,  File Not Found Exception ,  IOException ,  FTPIllegal Reply Exception ,  FTPException ,  FTPData Transfer Exception ,  FTPAborted Exception { if ( ! file . exists ( ) ) { throw new  File Not Found Exception ( file . get Absolute Path ( ) ) ; }  Input Stream input Stream = null ; try { input Stream = new  File Input Stream ( file ) ; } catch (  IOException e ) { throw new  FTPData Transfer Exception ( e ) ; } try { upload ( file . get Name ( ) , input Stream , restart At , restart At , listener ) ; } catch (  Illegal State Exception e ) { throw e ; } catch (  IOException e ) { throw e ; } catch (  FTPIllegal Reply Exception e ) { throw e ; } catch (  FTPException e ) { throw e ; } catch (  FTPData Transfer Exception e ) { throw e ; } catch (  FTPAborted Exception e ) { throw e ; } finally { if ( input Stream != null ) { try { input Stream . close ( ) ; } catch (  Throwable t ) { ; } } } }
public  SSLSocket create SSLSocket (  Socket socket ) throws  IOException {  SSLSocket Factory sf = ( (  SSLSocket Factory )  SSLSocket Factory . get Default ( ) ) ;  Inet Socket Address remote Address = (  Inet Socket Address ) socket . get Remote Socket Address ( ) ;  SSLSocket s = (  SSLSocket ) ( sf . create Socket ( socket , remote Address . get Host Name ( ) , socket . get Port ( ) , _ BOOL ) ) ; s . set Use Client Mode ( _ BOOL ) ; s . set Enabled Cipher Suites ( s . get Supported Cipher Suites ( ) ) ; return s ; }
private  String format Node (  Right Threaded Binary Node <  T > node ) {  Right Threaded Binary Node <  T > n ;  String Builder response = new  String Builder ( _ STR ) ; if ( ( n = node . get Left Son ( ) ) != null ) { response . append ( format Node ( n ) ) ; } response . append ( node . to String ( ) ) ; if ( ( n = node . get Right Son ( ) ) != null ) { response . append ( format Node ( n ) ) ; } response . append ( _ STR ) ; return response . to String ( ) ; }
public static void unregister MBean (  Class < ? > mbean Interface ) {  MBean Server mbs =  Management Factory . get Platform MBean Server ( ) ; try {  Object Name name = generate MBean Object Name ( mbean Interface ) ; if ( mbs . is Registered ( name ) ) { logger . info ( _ STR + name . to String ( ) ) ; mbs . unregister MBean ( name ) ; } else { logger . warn ( _ STR + name . to String ( ) ) ; } } catch (  Exception e ) { throw new  Server Runtime Exception ( _ STR + mbean Interface , e ) ; } }
static boolean caused By RDE (  Disk Access Exception dae ) { boolean result = _ BOOL ; if ( dae != null ) {  Throwable cause = dae . get Cause ( ) ; while ( cause != null ) { if ( cause instanceof  Region Destroyed Exception ) { result = _ BOOL ; break ; } cause = cause . get Cause ( ) ; } } return result ; }
public  Json Array add (  String value ) { values . add (  Json . value ( value ) ) ; return this ; }
public  Magic Variables Arguments Bundle ( @  Non Null  Map <  String ,  String > arguments , @  Non Null  Map <  String ,  String > variables ,  String layer Name , @  Non Null  Display Metrics metrics ) { super ( arguments , metrics ) ; m Variables = variables ; m Layer Name Prefix = _ STR + layer Name . replace ( _ STR , _ STR ) + _ STR ; }
@  HLEUnimplemented @  HLEFunction ( nid = _ NUM , version = _ NUM ) public int sce Usb Cam Setup Video Ex ( psp Usb Cam Setup Video Ex Param usb Cam Setup Video Ex Param ,  TPointer work Area , int work Area Size ) { this . work Area = work Area . get Address ( ) ; this . work Area Size = work Area Size ; resolution = convert Resolution Ex To Resolution ( usb Cam Setup Video Ex Param . resolution ) ; frame Rate = usb Cam Setup Video Ex Param . framerate ; white Balance = usb Cam Setup Video Ex Param . wb ; saturation = usb Cam Setup Video Ex Param . saturation ; brightness = usb Cam Setup Video Ex Param . brightness ; contrast = usb Cam Setup Video Ex Param . contrast ; sharpness = usb Cam Setup Video Ex Param . sharpness ; image Effect Mode = usb Cam Setup Video Ex Param . effectmode ; frame Size = usb Cam Setup Video Ex Param . framesize ; ev Level = usb Cam Setup Video Ex Param . evlevel ; if ( ! setup Video ( ) ) { log . warn (  String . format ( _ STR ) ) ; return  Sce Kernel Errors .  ERROR_ USBCAM_ NOT_ READY ; } return _ NUM ; }
public  List <  User > load All Deep From Cursor (  Cursor cursor ) { int count = cursor . get Count ( ) ;  List <  User > list = new  Array List <  User > ( count ) ; if ( cursor . move To First ( ) ) { if ( identity Scope != null ) { identity Scope . lock ( ) ; identity Scope . reserve Room ( count ) ; } try { do { list . add ( load Current Deep ( cursor , _ BOOL ) ) ; } while ( cursor . move To Next ( ) ) ; } finally { if ( identity Scope != null ) { identity Scope . unlock ( ) ; } } } return list ; }
public static  Date convert ISO8601to Date (  String date String ) throws  Parse Exception {  Date Format date Format = new  Simple Date Format ( _ STR ) ;  Date date = date Format . parse ( date String ) ; return date ; }
public static  Document create DOM (  Input Stream is ) throws  Parser Configuration Exception ,  SAXException ,  IOException {  Document Builder Factory dbf =  Document Builder Factory . new Instance ( ) ; dbf . set Validating ( _ BOOL ) ; dbf . set Ignoring Comments ( _ BOOL ) ; dbf . set Ignoring Element Content Whitespace ( _ BOOL ) ; dbf . set Namespace Aware ( _ BOOL ) ; dbf . set Feature (  XMLConstants .  FEATURE_ SECURE_ PROCESSING , _ BOOL ) ; dbf . set Feature (  DISALLOW_ DOCTYPE_ DECL , _ BOOL ) ; dbf . set Feature (  EXTERNAL_ GENERAL_ ENTITIES , _ BOOL ) ; dbf . set Feature (  EXTERNAL_ PARAMETER_ ENTITIES , _ BOOL ) ; dbf . set Feature (  LOAD_ EXTERNAL_ DTD , _ BOOL ) ;  Document Builder db = null ; db = dbf . new Document Builder ( ) ; db . set Entity Resolver ( new  Null Resolver ( ) ) ; db . set Error Handler ( new  Saml Parser Error Handler ( ) ) ; return db . parse ( is ) ; }
public void reset Count ( ) { msg Cnt . set ( _ NUM ) ; }
void decode Attribute Body ( byte [ ] attribute Value , char offset , char length ) throws  Stun Exception { realm = new byte [ length ] ;  System . arraycopy ( attribute Value , offset , realm , _ NUM , length ) ; }
public static void copy Assets (  Context context ,  String assets Filename ,  File file ,  String mode ) throws  IOException ,  Interrupted Exception {  String abi =  Build .  CPU_ ABI ;  String library Name ; if ( abi . equals Ignore Case ( _ STR ) ) { library Name = _ STR ; } else if ( abi . equals Ignore Case ( _ STR ) ) { library Name = _ STR ; } else if ( abi . contains ( _ STR ) ) { library Name = _ STR ; } else { return ; }  Asset Manager manager = context . get Assets ( ) ; final  Input Stream is = manager . open ( library Name + _ STR + assets Filename ) ; copy File ( file , is , mode ) ; }
public boolean is_same (  Object obj ) { if ( this == obj ) return _ BOOL ; if ( obj == null ) return _ BOOL ; if ( get Class ( ) != obj . get Class ( ) ) return _ BOOL ;  House Number other = (  House Number ) obj ; if ( number == null ) { if ( name == null ) { if ( other . name != null ) return _ BOOL ; } else if ( ! name . equals ( other . name ) ) return _ BOOL ; } else if ( ! number . equals ( other . number ) ) return _ BOOL ; if ( street == null ) { if ( other . street != null ) return _ BOOL ; } else if ( ! street . equals ( other . street ) ) return _ BOOL ; return _ BOOL ; }
public int three Way Distance (  Key k1 ,  Key k2 ) { byte [ ] h0 = hash ; byte [ ] h1 = k1 . hash ; byte [ ] h2 = k2 . hash ; int mmi = mismatch ( h1 , h2 ) ; if ( mmi == - _ NUM ) return _ NUM ; int h =  Byte . to Unsigned Int ( h0 [ mmi ] ) ; int a =  Byte . to Unsigned Int ( h1 [ mmi ] ) ; int b =  Byte . to Unsigned Int ( h2 [ mmi ] ) ; return  Integer . compare Unsigned ( a ^ h , b ^ h ) ; }
public  Async Selector ( ) throws  IOException { this (  Selector . open ( ) ) ; }
public void remove Child At ( int index ) { if ( ( index < _ NUM ) || ( children == null ) || ( index >= children . size ( ) ) ) { throw new  Array Index Out Of Bounds Exception ( ) ; }  Element child = (  Element ) children . get ( index ) ; child . set Parent ( null ) ; children . remove ( index ) ; }
private void paint (  Painter p ,  Synth Context ctx ,  Graphics g , int x , int y , int w , int h ,  Affine Transform transform ) { if ( p != null ) { if ( g instanceof  Graphics2 D ) {  Graphics2 D gfx = (  Graphics2 D ) g ; if ( transform != null ) { gfx . transform ( transform ) ; } gfx . translate ( x , y ) ; p . paint ( gfx , ctx . get Component ( ) , w , h ) ; gfx . translate ( - x , - y ) ; if ( transform != null ) { try { gfx . transform ( transform . create Inverse ( ) ) ; } catch (  Noninvertible Transform Exception e ) { e . print Stack Trace ( ) ; } } } else {  Buffered Image img = new  Buffered Image ( w , h ,  Buffered Image .  TYPE_ INT_ ARGB ) ;  Graphics2 D gfx = img . create Graphics ( ) ; if ( transform != null ) { gfx . transform ( transform ) ; } p . paint ( gfx , ctx . get Component ( ) , w , h ) ; gfx . dispose ( ) ; g . draw Image ( img , x , y , null ) ; img = null ; } } }
static void load Directory (  File file ,  Module Candidate candidate ) throws  IOException {  File [ ] files = file . list Files ( ) ; if ( files != null ) for (  File f : files ) load Sub Directory ( file , f , candidate ) ; }
public static boolean has Suppressed ( @  Nullable  Throwable t , @  Nullable  Class < ? extends  Throwable > cls ) { if ( t == null || cls == null ) return _ BOOL ; if ( t . get Suppressed ( ) != null ) { for (  Throwable th : t . get Suppressed ( ) ) { if ( cls . is Assignable From ( th . get Class ( ) ) ) return _ BOOL ; if ( has Suppressed ( th , cls ) ) return _ BOOL ; } } return _ BOOL ; }
static int write Var Long (  Output Stream out , long x ) throws  IOException { int len = _ NUM ; while ( ( x & ~ _ NUM ) != _ NUM ) { out . write ( ( byte ) ( _ NUM | ( x & _ NUM ) ) ) ; x >>>= _ NUM ; len ++ ; } out . write ( ( byte ) x ) ; return ++ len ; }
protected void engine Update ( byte b ) throws  Signature Exception { message Digest . update ( b ) ; needs Reset = _ BOOL ; }
private boolean check If Initiator For RPBefore Migration (  Initiator initiator ) { if ( initiator == null ) { return _ BOOL ; } boolean is RP = _ BOOL ; if (  Null Column Value Getter . is Null Value ( initiator . get Host Name ( ) ) || !  Null Column Value Getter . is Null URI ( initiator . get Host ( ) ) ) { is RP = _ BOOL ; } log . debug ( _ STR + ( is RP ? _ STR : _ STR ) ) ; return is RP ; }
@  Override public  Collection <  Serial Message > initialize ( boolean refresh ) {  Array List <  Serial Message > result = new  Array List <  Serial Message > ( ) ; if ( is Support Request Supported == _ BOOL && ( refresh == _ BOOL || initialise Done == _ BOOL ) && get Version ( ) > _ NUM ) { result . add ( get Supported Message ( ) ) ; } return result ; }
public static  DMLConfig read Configuration File (  String config Path ) throws  Parse Exception ,  File Not Found Exception {  DMLConfig config = new  DMLConfig ( ) ; if ( config Path != null ) { try { config = new  DMLConfig ( config Path , _ BOOL ) ; } catch (  File Not Found Exception fnfe ) {  LOG . error ( _ STR + config Path + _ STR ) ; throw fnfe ; } catch (  Parse Exception e ) { throw e ; } } else { try { config = new  DMLConfig (  DEFAULT_ SYSTEMML_ CONFIG_ FILEPATH , _ BOOL ) ; } catch (  File Not Found Exception fnfe ) {  LOG . info ( _ STR + _ STR ) ; config = new  DMLConfig ( ) ; } catch (  Parse Exception e ) { throw e ; } } return config ; }
default  B with Default (  String key , int value ) { return with Default ( key ,  Integer . to String ( value ) ) ; }
private  String [ ] combine Results From Multiple Reads (  String [ ] buffer ,  String [ ] last Read ) {  String [ ] t = new  String [ buffer . length + last Read . length ] ;  System . arraycopy ( buffer , _ NUM , t , _ NUM , buffer . length ) ;  System . arraycopy ( last Read , _ NUM , t , buffer . length , last Read . length ) ; return t ; }
private static boolean is Retina ( ) { if (  System Info . is Apple Jvm ) { return has Apple Retina Device ( ) ; } if (  System Info . is Mac ) {  Graphics Environment e =  Graphics Environment . get Local Graphics Environment ( ) ;  Graphics Device [ ] devices = e . get Screen Devices ( ) ; for (  Graphics Device device : devices ) { if ( is Oracle Mac Retina Device ( device ) ) { return _ BOOL ; } } } return _ BOOL ; }
protected void scan Compilation Units ( final  List <  ICompilation Unit > us ) throws  Illegal Argument Exception ,  Core Exception { progress Monitor . begin Task ( _ STR , us . size ( ) ) ; for ( final  ICompilation Unit ¢ : us ) scan Compilation Unit ( ¢ , new Sub Monitor ( progress Monitor ) ) ; progress Monitor . done ( ) ; }
private void draw Combat ( final  Graphics2 D g2d , final int x , final int y , final int width , final int height ) {  Rectangle2 D wrect = entity . get Area ( ) ; final  Rectangle srect = new  Rectangle ( ( int ) ( wrect . get X ( ) *  IGame Screen .  SIZE_ UNIT_ PIXELS ) , ( int ) ( wrect . get Y ( ) *  IGame Screen .  SIZE_ UNIT_ PIXELS ) , ( int ) ( wrect . get Width ( ) *  IGame Screen .  SIZE_ UNIT_ PIXELS ) , ( int ) ( wrect . get Height ( ) *  IGame Screen .  SIZE_ UNIT_ PIXELS ) ) ; int circle Height = ( int ) ( ( srect . height - _ NUM ) /  SQRT2 ) ; circle Height =  Math . max ( circle Height , srect . height -  IGame Screen .  SIZE_ UNIT_ PIXELS / _ NUM ) ; if ( entity . is Attacking (  User . get ( ) ) ) { g2d . set Color (  RING_ COLOR_ ORANGE ) ; g2d . draw Oval ( srect . x - _ NUM , srect . y + srect . height - circle Height , srect . width , circle Height ) ; g2d . draw Oval ( srect . x , srect . y + srect . height - circle Height , srect . width , circle Height ) ; g2d . draw Oval ( srect . x + _ NUM , srect . y + srect . height - circle Height , srect . width , circle Height ) ; draw Shaded Oval ( g2d , srect . x + _ NUM , srect . y + srect . height - circle Height + _ NUM , srect . width - _ NUM , circle Height - _ NUM ,  RING_ COLOR_ ORANGE , _ BOOL , _ BOOL ) ; } if ( entity . is Being Attacked ( ) ) {  Color line Color ; g2d . set Color (  RING_ COLOR_ RED ) ; if ( entity . is Attacking (  User . get ( ) ) ) { line Color =  RING_ COLOR_ RED ; draw Shaded Oval ( g2d , srect . x - _ NUM , srect . y + srect . height - circle Height - _ NUM , srect . width + _ NUM , circle Height + _ NUM ,  RING_ COLOR_ RED , _ BOOL , _ BOOL ) ; } else { line Color =  RING_ COLOR_ DARK_ RED ; g2d . draw Oval ( srect . x - _ NUM , srect . y + srect . height - circle Height , srect . width , circle Height ) ; g2d . draw Oval ( srect . x , srect . y + srect . height - circle Height , srect . width , circle Height ) ; g2d . draw Oval ( srect . x + _ NUM , srect . y + srect . height - circle Height , srect . width , circle Height ) ; draw Shaded Oval ( g2d , srect . x + _ NUM , srect . y + srect . height - circle Height + _ NUM , srect . width - _ NUM , circle Height - _ NUM ,  RING_ COLOR_ RED , _ BOOL , _ BOOL ) ; draw Shaded Oval ( g2d , srect . x - _ NUM , srect . y + srect . height - circle Height - _ NUM , srect . width + _ NUM , circle Height + _ NUM ,  RING_ COLOR_ ORANGE , _ BOOL , _ BOOL ) ; }  Enum Set <  Direction > directions =  Enum Set . none Of (  Direction . class ) ; for (  Entity attacker : entity . get Attackers ( ) ) { directions . add (  Direction . get Area Direction Towards Area ( entity . get Area ( ) , attacker . get Area ( ) ) ) ; } draw Arrows ( g2d , srect . x - _ NUM , srect . y + srect . height - circle Height - _ NUM , srect . width + _ NUM , circle Height + _ NUM , directions , line Color ) ; } else if ( entity . is Attacking (  User . get ( ) ) ) { draw Shaded Oval ( g2d , srect . x - _ NUM , srect . y + srect . height - circle Height - _ NUM , srect . width + _ NUM , circle Height + _ NUM ,  RING_ COLOR_ ORANGE , _ BOOL , _ BOOL ) ; } draw Attack ( g2d , x , y , width , height ) ; if ( entity . is Defending ( ) ) { final int sx = srect . x + srect . width -  ICON_ OFFSET ; final int sy = y + height - _ NUM *  ICON_ OFFSET ; switch ( entity . get Resolution ( ) ) { case  BLOCKED : blocked Sprite . draw ( g2d , sx , sy ) ; break ; case  MISSED : missed Sprite . draw ( g2d , sx , sy ) ; break ; case  HIT : hit Sprite . draw ( g2d , sx , sy ) ; break ; default : } } }
public  Activity Resolve Info (  Resolve Info resolve Info ) { this . resolve Info = resolve Info ; }
private static  Pair <  String ,  String > post Indexed LSR ( final long offset , final  ITranslation Environment environment , final  List <  Reil Instruction > instructions , final  String register Node Value1 , final  String register Node Value2 , final  String immediate Node Value ) { final  String address = environment . get Next Variable String ( ) ; final  String tmp Var1 = environment . get Next Variable String ( ) ; final  String tmp Var2 = environment . get Next Variable String ( ) ; final  String index = environment . get Next Variable String ( ) ; long base Offset = offset ; instructions . add (  Reil Helpers . create Str ( base Offset ++ , dw , register Node Value1 , dw , address ) ) ; instructions . add (  Reil Helpers . create Bsh ( base Offset ++ , dw , register Node Value2 , dw , _ STR + immediate Node Value , qw , tmp Var1 ) ) ; instructions . add (  Reil Helpers . create And ( base Offset ++ , qw , tmp Var1 , dw , d Word Bit Mask , dw , index ) ) ; instructions . add (  Reil Helpers . create Add ( base Offset ++ , dw , register Node Value1 , dw , index , dw , tmp Var2 ) ) ; instructions . add (  Reil Helpers . create And ( base Offset ++ , dw , tmp Var2 , dw , d Word Bit Mask , dw , register Node Value1 ) ) ; return new  Pair <  String ,  String > ( address , register Node Value1 ) ; }
public final void add Reference (  Object ref ) { ref Set . add ( ref ) ; }
public  Requirements Builder add Require Property (  String name ,  Requirements Builder builder ) { add Property ( name , builder ) ; required Properties . add ( name ) ; return this ; }
public  Head Rule (  String dir ,  String rule ) {  String [ ] tmp =  P_ TAGSETS . split ( rule ) ; int i , size = tmp . length ; b_r2l = dir . equals (  DIR_ RIGHT_ TO_ LEFT ) ; a_tag Sets = new  Head Tag Set [ size ] ; for ( i = _ NUM ; i < size ; i ++ ) a_tag Sets [ i ] = new  Head Tag Set ( tmp [ i ] ) ; }
public void test Neg Pos First Shorter ( ) { byte a Bytes [ ] = { - _ NUM , - _ NUM , - _ NUM , - _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM } ; byte b Bytes [ ] = { - _ NUM , _ NUM , _ NUM , _ NUM , - _ NUM , - _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , - _ NUM , _ NUM , _ NUM , - _ NUM , _ NUM , _ NUM , - _ NUM , - _ NUM } ; int a Sign = - _ NUM ; int b Sign = _ NUM ; byte r Bytes [ ] = { - _ NUM , _ NUM , _ NUM , - _ NUM , - _ NUM , - _ NUM , - _ NUM , - _ NUM , - _ NUM , - _ NUM , - _ NUM , - _ NUM , - _ NUM } ;  Big Integer a Number = new  Big Integer ( a Sign , a Bytes ) ;  Big Integer b Number = new  Big Integer ( b Sign , b Bytes ) ;  Big Integer result = a Number . or ( b Number ) ; byte res Bytes [ ] = new byte [ r Bytes . length ] ; res Bytes = result . to Byte Array ( ) ; for ( int i = _ NUM ; i < res Bytes . length ; i ++ ) { assert True ( res Bytes [ i ] == r Bytes [ i ] ) ; } assert Equals ( _ STR , - _ NUM , result . signum ( ) ) ; }
@  Override public <  T >  Future <  T > submit (  Callable <  T > task ) { synchronized ( this ) { active . increment And Get ( ) ; long timeout = _ NUM ; while ( queue . remaining Capacity ( ) == _ NUM ) { try { if ( timeout <= giveup Time ) {  Thread . sleep (  DEFAULT_ SLEEP ) ; timeout +=  DEFAULT_ SLEEP ; } else { throw new  Runtime Exception ( _ STR ) ; } } catch (  Interrupted Exception e ) { throw new  Runtime Exception ( e ) ; } } return super . submit ( task ) ; } }
public void test Subtract Math Context Diff Scale Pos Neg ( ) {  String a = _ STR ; int a Scale = _ NUM ;  String b = _ STR ; int b Scale = - _ NUM ;  String c = _ STR ; int c Scale = - _ NUM ;  Big Decimal a Number = new  Big Decimal ( new  Big Integer ( a ) , a Scale ) ;  Big Decimal b Number = new  Big Decimal ( new  Big Integer ( b ) , b Scale ) ;  Math Context mc = new  Math Context ( _ NUM ,  Rounding Mode .  DOWN ) ;  Big Decimal result = a Number . subtract ( b Number , mc ) ; assert Equals ( _ STR , c , result . to String ( ) ) ; assert Equals ( _ STR , c Scale , result . scale ( ) ) ; }
protected  XSQLDA allocate XSql Da (  Row Descriptor row Descriptor ) { if ( row Descriptor == null || row Descriptor . get Count ( ) == _ NUM ) { final  XSQLDA x Sql Da = new  XSQLDA ( _ NUM ) ; x Sql Da . sqld = x Sql Da . sqln = _ NUM ; return x Sql Da ; } final  XSQLDA x Sql Da = new  XSQLDA ( row Descriptor . get Count ( ) ) ; for ( int idx = _ NUM ; idx < row Descriptor . get Count ( ) ; idx ++ ) { final  Field Descriptor field Descriptor = row Descriptor . get Field Descriptor ( idx ) ; final  XSQLVAR x Sql Var = x Sql Da . sqlvar [ idx ] ; x Sql Var . sqltype = ( short ) ( field Descriptor . get Type ( ) | _ NUM ) ; x Sql Var . sqlsubtype = ( short ) field Descriptor . get Sub Type ( ) ; x Sql Var . sqlscale = ( short ) field Descriptor . get Scale ( ) ; x Sql Var . sqllen = ( short ) field Descriptor . get Length ( ) ; x Sql Var . sqlind = new  Short By Reference ( ) ; final int required Data Size = field Descriptor . is Varying ( ) ? field Descriptor . get Length ( ) + _ NUM : field Descriptor . get Length ( ) + _ NUM ; x Sql Var . sqldata = new  Memory ( required Data Size ) ; } return x Sql Da ; }
public static void overwrite ( long [ ] vector , long val , int offset , int len ) { int idx = offset > > _ NUM ; int bit Idx = offset & _ NUM ; int truncated Val Len =  Math . min ( len , _ NUM - bit Idx ) ; vector [ idx ] &= ~ ( mask Below ( truncated Val Len ) << bit Idx ) ; vector [ idx ] |= val << bit Idx ; if ( len != truncated Val Len ) { long mask = mask Below ( len - truncated Val Len ) ; vector [ idx + _ NUM ] &= ~ mask ; vector [ idx + _ NUM ] |= ( val > > > truncated Val Len ) ; } }
public static boolean is Empty (  String string ) { if ( null == string ) return _ BOOL ; return string . equals (  EMPTY ) ; }
public void begin Update Memory Used ( long bytes Used , boolean will Send Event ) ;
@  Override public  Point translate Java2 DTo Screen (  Point2 D java2 DPoint ) {  Insets insets = get Insets ( ) ; int x = ( int ) ( java2 DPoint . get X ( ) * this . scale X + insets . left ) ; int y = ( int ) ( java2 DPoint . get Y ( ) * this . scale Y + insets . top ) ; return new  Point ( x , y ) ; }
protected  Fast Map <  String > read Declared Properties (  Widget Creator Context context ) {  Fast Map <  String > declared Properties = new  Fast Map <  String > ( ) ;  String back Color = context . read Widget Property ( _ STR ) ; if ( back Color != null && back Color . length ( ) > _ NUM ) { declared Properties . put ( _ STR , back Color ) ; }  String font Name = context . read Widget Property ( _ STR ) ; if ( font Name != null && font Name . length ( ) > _ NUM ) { declared Properties . put ( _ STR , font Name ) ; }  String font Size = context . read Widget Property ( _ STR ) ; if ( font Size != null && font Size . length ( ) > _ NUM ) { declared Properties . put ( _ STR , font Size ) ; }  String fore Color = context . read Widget Property ( _ STR ) ; if ( fore Color != null && fore Color . length ( ) > _ NUM ) { declared Properties . put ( _ STR , fore Color ) ; }  String justification = context . read Widget Property ( _ STR ) ; if ( justification != null && justification . length ( ) > _ NUM ) { declared Properties . put ( _ STR , justification ) ; }  String bold = context . read Widget Property ( _ STR ) ; if ( bold != null && bold . length ( ) > _ NUM ) { declared Properties . put ( _ STR , bold ) ; }  String italic = context . read Widget Property ( _ STR ) ; if ( italic != null && italic . length ( ) > _ NUM ) { declared Properties . put ( _ STR , italic ) ; }  String subscript = context . read Widget Property ( _ STR ) ; if ( subscript != null && subscript . length ( ) > _ NUM ) { declared Properties . put ( _ STR , subscript ) ; }  String superscript = context . read Widget Property ( _ STR ) ; if ( superscript != null && superscript . length ( ) > _ NUM ) { declared Properties . put ( _ STR , superscript ) ; }  String underline = context . read Widget Property ( _ STR ) ; if ( underline != null && underline . length ( ) > _ NUM ) { declared Properties . put ( _ STR , underline ) ; }  String strikethrough = context . read Widget Property ( _ STR ) ; if ( strikethrough != null && strikethrough . length ( ) > _ NUM ) { declared Properties . put ( _ STR , strikethrough ) ; } return declared Properties ; }
private void update Traffic Projections ( ) {  List <  Air Map Traffic > updated = new  Array List < > ( ) ; for (  Air Map Traffic traffic : all Traffic ) { if ( traffic . get Ground Speed Kt ( ) > - _ NUM && traffic . get True Heading ( ) > - _ NUM ) { all Traffic . remove ( traffic ) ;  Coordinate projected = projected Coordinate ( traffic ) ; traffic . set Coordinate ( projected ) ; traffic . set Show Alert ( _ BOOL ) ; all Traffic . add ( traffic ) ; updated . add ( traffic ) ; } } notify Updated ( updated ) ; }
public static void log Stack Trace (  Level level ,  Throwable throwable ) { log Stack Trace ( level , throwable , null ) ; }
public static float compute Contrast Between Colors ( int bg , int fg ) { float bg R =  Color . red ( bg ) / _ NUM ; float bg G =  Color . green ( bg ) / _ NUM ; float bg B =  Color . blue ( bg ) / _ NUM ; bg R = ( bg R < _ NUM ) ? bg R / _ NUM : ( float )  Math . pow ( ( bg R + _ NUM ) / _ NUM , _ NUM ) ; bg G = ( bg G < _ NUM ) ? bg G / _ NUM : ( float )  Math . pow ( ( bg G + _ NUM ) / _ NUM , _ NUM ) ; bg B = ( bg B < _ NUM ) ? bg B / _ NUM : ( float )  Math . pow ( ( bg B + _ NUM ) / _ NUM , _ NUM ) ; float bg L = _ NUM * bg R + _ NUM * bg G + _ NUM * bg B ; float fg R =  Color . red ( fg ) / _ NUM ; float fg G =  Color . green ( fg ) / _ NUM ; float fg B =  Color . blue ( fg ) / _ NUM ; fg R = ( fg R < _ NUM ) ? fg R / _ NUM : ( float )  Math . pow ( ( fg R + _ NUM ) / _ NUM , _ NUM ) ; fg G = ( fg G < _ NUM ) ? fg G / _ NUM : ( float )  Math . pow ( ( fg G + _ NUM ) / _ NUM , _ NUM ) ; fg B = ( fg B < _ NUM ) ? fg B / _ NUM : ( float )  Math . pow ( ( fg B + _ NUM ) / _ NUM , _ NUM ) ; float fg L = _ NUM * fg R + _ NUM * fg G + _ NUM * fg B ; return  Math . abs ( ( fg L + _ NUM ) / ( bg L + _ NUM ) ) ; }
private  Sublime Base Menu Item add Internal ( int group , int id ,  Char Sequence title ,  Char Sequence hint ,  Sublime Base Menu Item .  Item Type item Type , boolean value Provided Async ,  Char Sequence badge Text , boolean shows Icon Space , boolean added By User ) {  Sublime Base Menu Item item ; boolean is Group Header = _ BOOL ; switch ( item Type ) { case  SEPARATOR : item = new  Sublime Separator Menu Item ( this , group , id ) ; break ; case  BADGE : item = new  Sublime Text With Badge Menu Item ( this , group , id , title , hint , value Provided Async , badge Text , shows Icon Space ) ; break ; case  SWITCH : item = new  Sublime Switch Menu Item ( this , group , id , title , hint , value Provided Async , shows Icon Space ) ; break ; case  CHECKBOX : item = new  Sublime Checkbox Menu Item ( this , group , id , title , hint , value Provided Async , shows Icon Space ) ; break ; case  GROUP_ HEADER : is Group Header = _ BOOL ; item = new  Sublime Group Header Menu Item ( this , group , id , title , hint , value Provided Async , shows Icon Space ) ; break ; default : item = new  Sublime Text Menu Item ( this , group , id , title , hint , value Provided Async , shows Icon Space ) ; break ; } check Existence Of Group ( group ) ; if ( is Group Header ) { check If Group Header Already Exists For Group ( group ) ; int index = find Group Index ( group ) ; if ( index >= _ NUM ) { m Items . add ( index , item ) ; } else { m Items . add ( item ) ; } } else if ( added By User ) { if ( group !=  NO_ GROUP_ ID ) { int last Group Index = find Last Group Index ( group ) ; m Items . add ( last Group Index == m Items . size ( ) ? last Group Index : last Group Index + _ NUM , item ) ; } else { m Items . add ( item ) ; } } else { m Items . add ( item ) ; } on Items Changed ( ) ; return item ; }
public static  String decode BCD ( final short bcd ) { return  String . format ( _ STR , ( bcd & _ NUM ) > > _ NUM , bcd & _ NUM ) ; }
public void add Layout Editor (  Layout Editor panel ) { if ( panels . size ( ) > _ NUM ) { for ( int i = _ NUM ; i < panels . size ( ) ; i ++ ) {  Layout Editor ed = panels . get ( i ) ; if ( ed == panel ) { return ; } } } panels . add ( panel ) ; }
void trigger Wildcard Expander ( final  Collection <  File > all Files , final  Wildcard Context wildcard Context ) throws  IOException {  LOG . debug ( _ STR , all Files ) ; if ( all Files . is Empty ( ) ) { final  String message =  String . format ( _ STR , wildcard Context . get Wildcard ( ) ) ;  LOG . warn ( message ) ; throw new  IOException ( message ) ; } if ( wildcard Expander Handler != null ) { try { wildcard Expander Handler . apply ( all Files ) ; } catch ( final  IOException e ) { throw e ; } catch ( final  Exception e ) {  LOG . debug ( _ STR , e ) ; throw new  IOException ( _ STR + e . get Message ( ) ) ; } } }
@  POST @  Consumes ( {  Media Type .  APPLICATION_ XML ,  Media Type .  APPLICATION_ JSON } ) @  Produces ( {  Media Type .  APPLICATION_ XML ,  Media Type .  APPLICATION_ JSON } ) @  Check Permission ( roles = {  Role .  TENANT_ ADMIN } ) @  Path ( _ STR ) public  Ip Interface Rest Rep create Ip Interface ( @  Path Param ( _ STR )  URI id ,  Ip Interface Create Param create Param ) throws  Database Exception {  Host host = query Object (  Host . class , id , _ BOOL ) ; validate Ip Interface Data ( create Param , null ) ;  Ip Interface ip Interface = new  Ip Interface ( ) ; ip Interface . set Host ( host . get Id ( ) ) ; ip Interface . set Id (  URIUtil . create Id (  Ip Interface . class ) ) ; populate Ip Interface ( create Param , ip Interface ) ; _db Client . create Object ( ip Interface ) ; audit Op (  Operation Type Enum .  CREATE_ HOST_ IPINTERFACE , _ BOOL , null , ip Interface . audit Parameters ( ) ) ; return map ( ip Interface ) ; }
protected  List <  IEdit Proposal > collect Edit Proposals ( ) {  List <  IEdit Proposal > proposals = new  Array List <  IEdit Proposal > ( ) ;  View selected View = get Selected View ( ) ; if ( selected View != null ) { if ( proposal Providers != null ) { for (  IEdit Proposal Provider provider : proposal Providers ) { for (  IEdit Proposal edit Proposal : provider . get Proposals ( selected View ) ) { if ( edit Proposal . is Applicable ( ) ) proposals . add ( edit Proposal ) ; } } } } return proposals ; }
public  Extension Query (  String plugin Id ,  String extension Point Name ,  String attribute Name ) { this . plugin Id = extension Point Name . contains ( _ STR ) ? null : plugin Id ; this . extension Point Name = extension Point Name ; this . attribute Name = attribute Name ; }
private void ensure Namespace Exists (  Result result ) {  Docker Image image =  Docker Image . from Image Name ( result . name ) ; if ( image . get Namespace ( ) == null ) { result . name =  String . format ( _ STR ,  DEFAULT_ NAMESPACE , image . get Repository ( ) ) ; } }
public void test Filtered Classifier ( ) {  Instances data ; int i ; if ( m_ Filtered Classifier == null ) { return ; } try { data = get Filtered Classifier Data ( ) ; m_ Filtered Classifier . build Classifier ( data ) ; for ( i = _ NUM ; i < data . num Instances ( ) ; i ++ ) { m_ Filtered Classifier . classify Instance ( data . instance ( i ) ) ; } } catch (  Exception e ) { fail ( _ STR + e . to String ( ) ) ; } }
protected int choose Random Index Based On Proportions ( double [ ] proportion Array ,  Random random ) { double prob Sum ; double val ; int index ; double sum ; prob Sum =  Utils . sum ( proportion Array ) ; val = random . next Double ( ) * prob Sum ; index = _ NUM ; sum = _ NUM ; while ( ( sum <= val ) && ( index < proportion Array . length ) ) { sum += proportion Array [ index ++ ] ; } return index - _ NUM ; }
private void check Width ( final int [ ] rect ) { final int x1 = rect [ _ NUM ] ; final int y2 = rect [ _ NUM ] ; final int y1 = y2 + rect [ _ NUM ] ; final int x2 = x1 + rect [ _ NUM ] ; if ( x1 < page X1 ) { page X1 = x1 ; } if ( x2 > page X2 ) { page X2 = x2 ; } if ( y1 > page Y1 ) { page Y1 = y1 ; } if ( y2 < page Y2 ) { page Y2 = y2 ; } }
@  Not Null public static  Map <  Rad Component ,  List <  Rad Component > > group Siblings ( @  Not Null  List < ? extends  Rad Component > components ) {  Map <  Rad Component ,  List <  Rad Component > > sibling Lists = new  Hash Map <  Rad Component ,  List <  Rad Component > > ( ) ; if ( components . is Empty ( ) ) { return sibling Lists ; } if ( components . size ( ) == _ NUM ) {  Rad Component component = components . get ( _ NUM ) ; sibling Lists . put ( component . get Parent ( ) ,  Collections . singleton List ( component ) ) ; return sibling Lists ; } for (  Rad Component component : components ) {  Rad Component parent = component . get Parent ( ) ;  List <  Rad Component > children = sibling Lists . get ( parent ) ; if ( children == null ) { children = new  Array List <  Rad Component > ( ) ; sibling Lists . put ( parent , children ) ; } children . add ( component ) ; } return sibling Lists ; }
private int count Non Newline (  String str , int off , int len ) { for ( int cnt = _ NUM ; cnt < len ; cnt ++ ) { final int pos = off + cnt ; if ( str . char At ( pos ) ==  UNIX_ NEWLINE ) { return cnt ; } if ( str . char At ( pos ) ==  CARRIAGE_ RETURN ) { return cnt ; } } return len ; }
public  String description ( ) {  String Builder sb = new  String Builder ( ) ; if ( is Combo ( ) ) { int i = _ NUM ; for (  New Combo Leg leg : m_combo Legs ) { if ( i ++ > _ NUM ) { sb . append ( _ STR ) ; } sb . append ( leg . to String ( ) ) ; } } else { sb . append ( m_symbol ) ; app ( sb , m_sec Type ) ; app ( sb , m_exchange ) ; if ( m_exchange != null && m_exchange . equals ( _ STR ) && m_primary Exch != null ) { app ( sb , m_primary Exch ) ; } app ( sb , m_expiry ) ; if ( m_strike != _ NUM ) { app ( sb , m_strike ) ; } if ( m_right !=  Right .  None ) { app ( sb , m_right ) ; } } return sb . to String ( ) ; }
public void add Claimed Signer Role ( final  String claimed Signer Role ) { if ( ( claimed Signer Role == null ) || ( claimed Signer Role . length ( ) == _ NUM ) ) { throw new  Null Pointer Exception ( _ STR ) ; } if ( claimed Signer Roles == null ) { claimed Signer Roles = new  Array List <  String > ( ) ; } claimed Signer Roles . add ( claimed Signer Role ) ; }
@  Suppress Warnings ( _ STR ) @  Gwt Incompatible ( _ STR ) public static <  K extends  Object ,  V extends  Object > void write Map (  Map <  K ,  V > map ,  Object Output Stream stream ) throws  IOException { stream . write Int ( map . size ( ) ) ; for (  Map .  Entry <  K ,  V > entry : map . entry Set ( ) ) { stream . write Object ( entry . get Key ( ) ) ; stream . write Object ( entry . get Value ( ) ) ; } }
protected void sleep ( int sleep Millis , int sleep Nanos ) throws  Interrupted Exception {  Thread . sleep ( sleep Millis , sleep Nanos ) ; }
public static void restore Previous Out And Err Stream ( ) { if ( ! already Muted ) { return ; }  System . set Out ( latest Out ) ;  System . set Err ( latest Err ) ; already Muted = _ BOOL ; }
public static  Big Integer  CRT (  List <  Big Integer > congs ,  List <  Big Integer > moduli ) {  Big Integer [ ] cs =  Array Converter . convert List To Array ( congs ) ;  Big Integer [ ] ms =  Array Converter . convert List To Array ( moduli ) ; return  CRT ( cs , ms ) ; }
private int measure Height ( int measure Spec ) { int result = _ NUM ; int spec Mode =  Measure Spec . get Mode ( measure Spec ) ; int spec Size =  Measure Spec . get Size ( measure Spec ) ; m Ascent = ( int ) m Text Paint . ascent ( ) ; if ( spec Mode ==  Measure Spec .  EXACTLY ) { result = spec Size ; } else { result = ( int ) ( - m Ascent + m Text Paint . descent ( ) ) + get Padding Top ( ) + get Padding Bottom ( ) ; if ( spec Mode ==  Measure Spec .  AT_ MOST ) { result =  Math . min ( result , spec Size ) ; } } return result ; }
public void test Case17 ( ) { byte a Bytes [ ] = { - _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , - _ NUM , _ NUM , - _ NUM , _ NUM , _ NUM } ; byte b Bytes [ ] = { _ NUM , - _ NUM , _ NUM , _ NUM , _ NUM } ; int a Sign = _ NUM ; int b Sign = _ NUM ; byte r Bytes [ ] = { _ NUM , - _ NUM , _ NUM , _ NUM , _ NUM } ;  Big Integer a Number = new  Big Integer ( a Sign , a Bytes ) ;  Big Integer b Number = new  Big Integer ( b Sign , b Bytes ) ;  Big Integer result = a Number . remainder ( b Number ) ; byte res Bytes [ ] = new byte [ r Bytes . length ] ; res Bytes = result . to Byte Array ( ) ; for ( int i = _ NUM ; i < res Bytes . length ; i ++ ) { assert True ( res Bytes [ i ] == r Bytes [ i ] ) ; } assert Equals ( _ STR , _ NUM , result . signum ( ) ) ; }
protected <  T extends  Task Service Document <  E > ,  E extends  Enum <  E > >  T wait For Task Completion (  String document Self Link ,  Class <  T > type ) throws  Throwable { return wait For Property Value ( document Self Link , type ,  Task Service Document .  FIELD_ NAME_ TASK_ STAGE ,  Arrays . as List (  Task Stage .  FINISHED ,  Task Stage .  FAILED ,  Task Stage .  CANCELLED ) , _ BOOL , wait For Stage Change Count Longer ( ) ) ; }
private  List <  End Island > find Surrounding Islands ( int chunk X , int chunk Y , int chunks Per Fragment X , int chunks Per Fragment Y ) {  List <  End Island > result = new  Linked List <  End Island > ( ) ; for ( int y = -  SURROUNDING_ CHUNKS ; y <= chunks Per Fragment Y +  SURROUNDING_ CHUNKS ; y ++ ) { for ( int x = -  SURROUNDING_ CHUNKS ; x <= chunks Per Fragment X +  SURROUNDING_ CHUNKS ; x ++ ) {  End Island island = try Create End Island ( chunk X + x , chunk Y + y ) ; if ( island != null ) { result . add ( island ) ; } } } return result ; }
void insert Function2 (  Byte Buffer bb ) { int base Sec = ( int ) ( window Id > > _ NUM ) ; bb . put Int ( base Sec ) ;  Integer oper Id = operator Id ; for ( int i = _ NUM ; i < _ NUM ; i ++ ) { byte num = ( byte ) ( oper Id > > _ NUM * ( _ NUM - i ) ) ; bb . put ( num ) ; } bb . put Short ( ( short ) ( window Id & _ NUM ) ) ; for ( int i = _ NUM ; i < _ NUM ; i ++ ) { byte num = ( byte ) ( tuple Id > > _ NUM * ( _ NUM - i ) ) ; bb . put ( num ) ; } }
private static boolean calculate Gap (  Rectangle a ,  Rectangle b ,  Rectangle gap ) { if ( a . intersects ( b ) ) { gap . width = _ NUM ; return _ BOOL ; } int ax1 = a . x ; int ax2 = a . x + a . width ; int ay1 = a . y ; int ay2 = a . y + a . height ; int bx1 = b . x ; int bx2 = b . x + b . width ; int by1 = b . y ; int by2 = b . y + b . height ; int x Overlap =  Math . min ( ax2 , bx2 ) -  Math . max ( ax1 , bx1 ) ; int y Overlap =  Math . min ( ay2 , by2 ) -  Math . max ( ay1 , by1 ) ; if ( x Overlap <= _ NUM && y Overlap <= _ NUM ) { gap . width = _ NUM ; return _ BOOL ; } if ( x Overlap > _ NUM ) { gap . x =  Math . max ( ax1 , bx1 ) ; gap . y = ( ay1 > by1 ) ? by2 : ay2 ; gap . width = x Overlap ; gap . height = - y Overlap ; } if ( y Overlap > _ NUM ) { gap . x = ( ax1 > bx1 ) ? bx2 : ax2 ; gap . y =  Math . max ( ay1 , by1 ) ; gap . width = - x Overlap ; gap . height = y Overlap ; } return _ BOOL ; }
public boolean next Tile ( ) throws  Model Control Exception { boolean moved To Row = super . next Tile ( ) ; if ( moved To Row ) { cur Tile = get Tile Index ( ) ; set Display Field Value (  TXT_ PARENT_ INDEX , parent Idx ) ; set Display Field Value (  TXT_ CHOICE , choices [ cur Tile ] ) ; set Display Field Value (  TXT_ INDEX ,  Integer . to String ( cur Tile ) ) ; } return moved To Row ; }
public boolean has Myomer Booster ( ) { for (  Mounted m Equip : get Misc ( ) ) {  Misc Type mtype = (  Misc Type ) m Equip . get Type ( ) ; if ( mtype . has Flag (  Misc Type .  F_ MASC ) && ! m Equip . is Inoperable ( ) ) { return _ BOOL ; } } return _ BOOL ; }
public static boolean is Intent Available (  Context context ,  String action ) { final  Package Manager package Manager = context . get Package Manager ( ) ; final  Intent intent = new  Intent ( action ) ;  Log . d (  MP_ TAG , _ STR + action ) ;  List <  Resolve Info > list = package Manager . query Intent Services ( intent ,  Package Manager .  MATCH_ DEFAULT_ ONLY ) ; return list . size ( ) > _ NUM ; }
private void send CONNECTRequest ( ) throws  IOException { int port = url . get Port ( ) ; requests . set ( _ NUM ,  HTTP_ CONNECT + _ STR + connect Request URI ( url ) + _ STR + http Version , null ) ; requests . set If Not Set ( _ STR , user Agent ) ;  String host = url . get Host ( ) ; if ( port != - _ NUM && port != url . get Default Port ( ) ) { host += _ STR +  String . value Of ( port ) ; } requests . set If Not Set ( _ STR , host ) ; requests . set If Not Set ( _ STR , accept String ) ; if ( http . get Http Keep Alive Set ( ) ) { requests . set If Not Set ( _ STR , _ STR ) ; } set Preemptive Proxy Authentication ( requests ) ; if ( logger . is Loggable (  Platform Logger .  Level .  FINE ) ) { logger . fine ( requests . to String ( ) ) ; } http . write Requests ( requests , null ) ; }
private boolean is Self Signed (  X509 Certificate cert ) { return signed By ( cert , cert ) ; }
@  Request Mapping ( value = { _ STR , _ STR } , method =  Request Method .  PUT ) @  Response Body public  Rest Wrapper insert ( @  Model Attribute ( _ STR ) @  Valid  User Roles user Roles ,  Binding Result binding Result ,  Principal principal ) {  Rest Wrapper rest Wrapper = null ; if ( binding Result . has Errors ( ) ) {  Binding Result Error binding Result Error = new  Binding Result Error ( ) ; return binding Result Error . error Message ( binding Result ) ; } try { com . wipro . ats . bdre . md . dao . jpa .  User Roles jpa User Roles = new com . wipro . ats . bdre . md . dao . jpa .  User Roles ( ) ; jpa User Roles . set User Role Id ( user Roles . get User Role Id ( ) ) ; jpa User Roles . set Role ( user Roles . get Role ( ) ) ;  Users users = new  Users ( ) ; users . set Username ( user Roles . get Username ( ) ) ; jpa User Roles . set Users ( users ) ;  Integer user Roles Id = user Roles DAO . insert ( jpa User Roles ) ; user Roles . set User Role Id ( user Roles Id ) ; rest Wrapper = new  Rest Wrapper ( user Roles ,  Rest Wrapper .  OK ) ;  LOGGER . info ( _ STR + user Roles . get User Role Id ( ) + _ STR + principal . get Name ( ) + user Roles ) ; } catch (  Exception e ) {  LOGGER . error ( e ) ; rest Wrapper = new  Rest Wrapper ( e . get Message ( ) ,  Rest Wrapper .  ERROR ) ; } return rest Wrapper ; }
public  Set <  Word Token > nearest Words ( final int distance , final  Word Token ... start ) { return nearest Words ( distance , null ,  Arrays . as List ( start ) ) ; }
public void rewind ( ) { synchronized ( used ) { for (  Parameter Pair pair : used ) { current . add Parameter ( pair . option , pair . value ) ; } used . clear ( ) ; } }
public  List <  Interval > merge (  List <  Interval > intervals ) {  List <  Interval > res = new  Array List < > ( ) ; if ( intervals == null || intervals . size ( ) == _ NUM ) { return res ; }  Collections . sort ( intervals , null ) ;  Interval prev = null ; for (  Interval i : intervals ) { if ( prev == null || prev . end < i . start ) { res . add ( i ) ; prev = i ; } else if ( i . end > prev . end ) { prev . end = i . end ; } } return res ; }
private  String format Type (  Object type Rep ) {  String Tokenizer tokenizer = new  String Tokenizer ( type Rep . to String ( ) , _ STR , _ BOOL ) ;  String Builder sb = new  String Builder ( ) ; while ( tokenizer . has More Tokens ( ) ) {  String token = tokenizer . next Token ( ) ; if ( token . length ( ) == _ NUM || token . last Index Of ( _ STR ) == - _ NUM ) sb . append ( token ) ; else { int index = token . last Index Of ( _ STR ) ; sb . append ( token . substring ( index + _ NUM ) ) ; } } return sb . to String ( ) ; }
@  Not Null public static  String sha1 ( @  Not Null  File key Store File ) throws  Exception { return sha1 ( key Store File , null , null ) ; }
@  Override public void pan Domain Axes ( double pan Range ,  Plot Rendering Info info ,  Point2 D source ) {  XYPlot subplot = find Subplot ( info , source ) ; if ( subplot == null ) { return ; } if ( ! subplot . is Domain Pannable ( ) ) { return ; }  Plot Rendering Info subplot Info = info . get Subplot Info ( info . get Subplot Index ( source ) ) ; if ( subplot Info == null ) { return ; } for ( int i = _ NUM ; i < subplot . get Domain Axis Count ( ) ; i ++ ) {  Value Axis domain Axis = subplot . get Domain Axis ( i ) ; if ( domain Axis != null ) { domain Axis . pan ( pan Range ) ; } } }
private void init ( ) { start Controller = new  Pour Start Controller ( ) ; start Controller . set Check View ( this ) ; wave Controller = new  Wave Controller ( ) ; wave Controller . set Check View ( this ) ;  Pour Finish Controller finish Controller = new  Pour Finish Controller ( ) ; finish Controller . set Check View ( this ) ;  Tick Controller tick Controller = new  Tick Controller ( ) ; tick Controller . set Check View ( this ) ;  List <  Base Controller > finish Controllers = new  Array List < > ( ) ; finish Controllers . add ( finish Controller ) ; finish Controllers . add ( tick Controller ) ; this . finish Controllers = finish Controllers ; }
private  JLabel create Icon Label (  JCheck Box check Box ) { check Box . set Opaque ( _ BOOL ) ; check Box . set Size ( check Box . get Minimum Size ( ) ) ;  Image image = new  Buffered Image ( check Box . get Width ( ) , check Box . get Height ( ) ,  Transparency .  TRANSLUCENT ) ;  Graphics g = image . get Graphics ( ) ; check Box . paint ( g ) ; g . dispose ( ) ; return new  JLabel ( new  Image Icon ( image ) ) ; }
public void close Window ( ) {  Window Event ev = new  Window Event ( frame ,  Window Event .  WINDOW_ CLOSING ) ; frame . dispatch Event ( ev ) ; }
private void populate Host Data (  Host host ,  Host Param param ) { if ( param . get Name ( ) != null ) { host . set Label ( param . get Name ( ) ) ; } if ( param . get Host Name ( ) != null ) { host . set Host Name ( param . get Host Name ( ) ) ; } if ( param . get Cluster ( ) != null ) { host . set Cluster ( param . get Cluster ( ) ) ; } if ( param . get Os Version ( ) != null ) { host . set Os Version ( param . get Os Version ( ) ) ; } if ( param . get User Name ( ) != null ) { host . set Username ( param . get User Name ( ) ) ; } if ( param . get Password ( ) != null ) { host . set Password ( param . get Password ( ) ) ; } if ( param . get Port Number ( ) != null ) { host . set Port Number ( param . get Port Number ( ) ) ; } if ( param . get Use Ssl ( ) != null ) { host . set Use SSL ( param . get Use Ssl ( ) ) ; } if ( param . get Type ( ) != null ) { host . set Type ( param . get Type ( ) ) ; } if ( param . get Discoverable ( ) != null ) { host . set Discoverable ( param . get Discoverable ( ) ) ; } if ( param . get Vcenter Data Center ( ) != null ) { host . set Vcenter Data Center (  Null Column Value Getter . is Null URI ( param . get Vcenter Data Center ( ) ) ?  Null Column Value Getter . get Null URI ( ) : param . get Vcenter Data Center ( ) ) ; }  Cluster cluster = null ; if ( !  Null Column Value Getter . is Null URI ( param . get Cluster ( ) ) ) { cluster = query Object (  Cluster . class , param . get Cluster ( ) , _ BOOL ) ; if ( !  Null Column Value Getter . is Null URI ( cluster . get Vcenter Data Center ( ) ) ) { host . set Vcenter Data Center ( cluster . get Vcenter Data Center ( ) ) ; } if ( !  Null Column Value Getter . is Null URI ( cluster . get Project ( ) ) ) { host . set Project ( cluster . get Project ( ) ) ; } } if ( param . get Boot Volume ( ) != null ) { host . set Boot Volume Id (  Null Column Value Getter . is Null URI ( param . get Boot Volume ( ) ) ?  Null Column Value Getter . get Null URI ( ) : param . get Boot Volume ( ) ) ; } }
@  Nullable public  Avd Info create Or Update Avd ( @  Nullable  Avd Info current Info , @  Not Null  String avd Name , @  Not Null  Device device , @  Not Null  System Image Description system Image Description , @  Not Null  Screen Orientation orientation , boolean is Circular , @  Nullable  String sd Card , @  Nullable  File skin Folder , @  Not Null  Map <  String ,  String > hardware Properties , boolean create Snapshot ) { if ( ! init If Necessary ( ) ) { return null ; }  File avd Folder ; try { if ( current Info != null ) { avd Folder = new  File ( current Info . get Data Folder Path ( ) ) ; } else { avd Folder =  Avd Info . get Default Avd Folder ( my Avd Manager , avd Name , my File Op , _ BOOL ) ; } } catch (  Android Location .  Android Location Exception e ) {  IJ_ LOG . error ( _ STR + avd Name , e ) ; return null ; }  Dimension resolution = device . get Screen Size ( orientation ) ; assert resolution != null ;  String skin Name = null ; if ( skin Folder == null && is Circular ) { skin Folder = get Round Skin ( system Image Description ) ; } if (  File Util . files Equal ( skin Folder ,  Avd Wizard Utils .  NO_ SKIN ) ) { skin Folder = null ; } if ( skin Folder == null ) { skin Name =  String . format ( _ STR ,  Math . round ( resolution . get Width ( ) ) ,  Math . round ( resolution . get Height ( ) ) ) ; } if ( orientation ==  Screen Orientation .  LANDSCAPE ) { hardware Properties . put (  Hardware Properties .  HW_ INITIAL_ ORIENTATION ,  Screen Orientation .  LANDSCAPE . get Short Display Value ( ) . to Lower Case (  Locale .  ROOT ) ) ; } if ( current Info != null && ! avd Name . equals ( current Info . get Name ( ) ) ) { boolean success = my Avd Manager . move Avd ( current Info , avd Name , current Info . get Data Folder Path ( ) ,  SDK_ LOG ) ; if ( ! success ) { return null ; } } return my Avd Manager . create Avd ( avd Folder , avd Name , system Image Description . get System Image ( ) , skin Folder , skin Name , sd Card , hardware Properties , device . get Boot Props ( ) , create Snapshot , _ BOOL , current Info != null ,  SDK_ LOG ) ; }
public void engine Delete Entry (  String alias ) throws  Key Store Exception { synchronized ( entries ) { entries . remove ( alias . to Lower Case (  Locale .  ENGLISH ) ) ; } }
public  Disjoint Sets ( int num Elements ) { array = new int [ num Elements ] ;  Arrays . fill ( array , - _ NUM ) ; }
public final void print Clusters (  Print Writer out ,  List <  Cluster Data > cluster Data , int [ ] mat Index To Msg Internal Id ) throws  Ade Exception { if ( m_final Clusters == null ) { update Clusters ( cluster Data , mat Index To Msg Internal Id ) ; } for (  Map .  Entry <  String ,  Collection <  Integer > > entry : m_final Clusters . entry Set ( ) ) { final  String n = entry . get Key ( ) ; final  Collection <  Integer > c = entry . get Value ( ) ; out . printf ( _ STR , n ) ; for ( int m : c ) { out . printf ( _ STR , mat Index To Msg Internal Id [ m ] ) ; } out . println ( ) ; } }
protected void add To GUI (  JPanel gui ,  JText Field b ,  String cmd ) { b . set Action Command ( cmd ) ; b . add Action Listener ( this ) ; gui . add ( b ) ; }
static  Token Stream wrap (  String field Name ,  Analyzer index Analyzer ,  String content , char split Char ) throws  IOException { if ( index Analyzer . get Offset Gap ( field Name ) != _ NUM ) { throw new  Illegal Argument Exception ( _ STR + field Name + _ STR ) ; } int split Char Idx = content . index Of ( split Char ) ; if ( split Char Idx == - _ NUM ) { return index Analyzer . token Stream ( field Name , content ) ; }  Token Stream sub Token Stream = index Analyzer . token Stream ( field Name , content . substring ( _ NUM , split Char Idx ) ) ; return new  Multi Value Token Stream ( sub Token Stream , field Name , index Analyzer , content , split Char , split Char Idx ) ; }
public final boolean check_trace (  Polyline p_polyline , int p_half_width , int p_layer ,  Net Nos List p_net_no_arr , int p_clearance_class_no , int p_max_recursion_depth , int p_max_via_recursion_depth , int p_max_spring_over_recursion_depth ) {  Awtree Shape Search search_tree = search_tree_manager . get_default_tree ( ) ; int compensated_half_width = p_half_width + search_tree . get_clearance_compensation ( p_clearance_class_no , p_layer ) ;  Array List <  Shape Tile > trace_shapes = p_polyline . offset_shapes ( compensated_half_width , _ NUM , p_polyline . corner_count ( ) ) ; for ( int index = _ NUM ; index < trace_shapes . size ( ) ; ++ index ) {  Shape Tile curr_trace_shape = trace_shapes . get ( index ) ;  Brd From Side from_side = new  Brd From Side ( p_polyline , index + _ NUM , curr_trace_shape ) ; boolean check_shove_ok = shove_trace_algo . shove_trace_check ( curr_trace_shape , from_side , null , p_layer , p_net_no_arr , p_clearance_class_no , p_max_recursion_depth , p_max_via_recursion_depth , p_max_spring_over_recursion_depth , null ) ; if ( ! check_shove_ok ) return _ BOOL ; } return _ BOOL ; }
public static void delete (  File file Or Folder ) throws  IOException { if ( file Or Folder != null ) delete ( file Or Folder . to Path ( ) ) ; }
public static double [ ] expand Array D ( int buffer Size , double [ ] current Array ) { if ( current Array == null ) { return new double [ buffer Size * _ NUM ] ; } int length = current Array . length ; double [ ] ret = new double [ length + buffer Size * _ NUM ] ;  System . arraycopy ( current Array , _ NUM , ret , _ NUM , length ) ; return ret ; }
@  Suppress Warnings ( _ STR ) public void post Process Bean Factory (  Configurable Listable Bean Factory configurable Listable Bean Factory ) { if ( configurable Listable Bean Factory . contains Bean ( session Factory Bean Name ) ) {  Bean Definition session Factory Bean Definition = configurable Listable Bean Factory . get Bean Definition ( session Factory Bean Name ) ;  Mutable Property Values property Values = session Factory Bean Definition . get Property Values ( ) ; if ( mapping Resources != null ) {  Property Value property Value = property Values . get Property Value ( _ STR ) ; if ( property Value == null ) { property Value = new  Property Value ( _ STR , new  Array List ( ) ) ; property Values . add Property Value ( property Value ) ; }  List existing Mapping Resources = (  List ) property Value . get Value ( ) ; existing Mapping Resources . add All ( mapping Resources ) ; } if ( annotated Classes != null ) {  Property Value property Value = property Values . get Property Value ( _ STR ) ; if ( property Value == null ) { property Value = new  Property Value ( _ STR , new  Array List ( ) ) ; property Values . add Property Value ( property Value ) ; }  List existing Mapping Resources = (  List ) property Value . get Value ( ) ; existing Mapping Resources . add All ( annotated Classes ) ; } if ( config Locations != null ) {  Property Value property Value = property Values . get Property Value ( _ STR ) ; if ( property Value == null ) { property Value = new  Property Value ( _ STR , new  Array List ( ) ) ; property Values . add Property Value ( property Value ) ; }  List existing Config Locations = (  List ) property Value . get Value ( ) ; existing Config Locations . add All ( config Locations ) ; } if ( hibernate Properties != null ) {  Property Value property Value = property Values . get Property Value ( _ STR ) ; if ( property Value == null ) { property Value = new  Property Value ( _ STR , new  Properties ( ) ) ; property Values . add Property Value ( property Value ) ; }  Properties existing Hibernate Properties = (  Properties ) property Value . get Value ( ) ; existing Hibernate Properties . put All ( hibernate Properties ) ; } } else { throw new  No Such Bean Definition Exception ( _ STR + session Factory Bean Name + _ STR + _ STR ) ; } }
protected int encode ( double value , double lower , double upper , int nbits ) { if ( value < lower ) return _ NUM ; int maxval = ( int ) (  Math . pow ( _ NUM , nbits ) - _ NUM ) ; if ( value >= upper ) return maxval ; return ( int ) ( ( value - lower ) * ( ( maxval - _ NUM ) / ( upper - lower ) ) ) ; }
public long skip Bytes ( long n ) throws  IOException { long count = _ NUM ; long gotsofar = _ NUM ; if ( input Stream == null ) { reopen ( ) ; if ( input Stream == null ) { reopen ( ) ; throw new  IOException ( _ STR ) ; } } while ( count < n ) { gotsofar = input Stream . skip ( n - count ) ; if ( gotsofar == _ NUM ) {  Debug . error ( _ STR + n + _ STR ) ; break ; } count += gotsofar ; } count ( ( int ) count ) ; return count ; }
public void handle Tbl DSAttribute Map List Href Action Request (  Request Invocation Event event ) throws  Model Control Exception { try {  Map values = get Values ( ) ; on Before Save Profile ( values ) ; set Page Session Attribute (  PROPERTY_ ATTRIBUTE , (  Hash Map ) values ) ;  WSPPService DSAttribute Map List Edit View Bean vb = (  WSPPService DSAttribute Map List Edit View Bean ) get View Bean (  WSPPService DSAttribute Map List Edit View Bean . class ) ; unlock Page Trail ( ) ; pass Pg Session Map ( vb ) ; vb . populate Values ( (  String ) get Display Field Value ( _ STR ) ) ; vb . forward To ( get Request Context ( ) ) ; } catch (  AMConsole Exception e ) { set Inline Alert Message (  CCAlert .  TYPE_ ERROR , _ STR , e . get Message ( ) ) ; forward To ( ) ; } }
private  V do Get (  Object key ) { if ( key == null ) throw new  Null Pointer Exception ( ) ;  Comparator < ? super  K > cmp = comparator ; outer : for ( ; ; ) { for (  Node <  K ,  V > b = find Predecessor ( key , cmp ) , n = b . next ; ; ) {  Object v ; int c ; if ( n == null ) break outer ;  Node <  K ,  V > f = n . next ; if ( n != b . next ) break ; if ( ( v = n . value ) == null ) { n . help Delete ( b , f ) ; break ; } if ( b . value == null || v == n ) break ; if ( ( c = cpr ( cmp , key , n . key ) ) == _ NUM ) { @  Suppress Warnings ( _ STR )  V vv = (  V ) v ; return vv ; } if ( c < _ NUM ) break outer ; b = n ; n = f ; } } return null ; }
void handle Swf Loaded Event (  Swf Loaded Event e ) { dump Swf Loaded Line ( e ) ; }
private void quick Reply ( ) { quick Reply Sms Message = sms Popup Pager . get Active Message ( ) ; quick Reply ( quick Reply Sms Message . get Reply Text ( ) ) ; }
@  Override protected synchronized void write ( long offset , byte [ ] b ) throws  IOException { if ( byte Buffer != null ) { byte Buffer . position ( ( int ) offset ) ; byte Buffer . put ( b ) ; } else { throw new  IOException ( _ STR + get Path ( ) + _ STR ) ; } }
public boolean has Changed ( ) { return  System . identity Hash Code ( config ) != initial Hash ; }
void fix Compatibility (  View root ) {  Queue <  View > queue = new  Linked List <  View > ( ) ; queue . add ( root ) ;  View view = null ; while ( ( view = queue . poll ( ) ) != null ) { if ( view instanceof  View Group ) {  View Group group = (  View Group ) view ; for ( int i = _ NUM ; i < group . get Child Count ( ) ; i ++ ) { queue . add ( group . get Child At ( i ) ) ; } } } }
public void substitute Header ( int state ,  String header ) throws  Auth Login Exception { if ( debug . message Enabled ( ) ) { debug . message ( _ STR + state + _ STR + header ) ; } if ( state > state Length ) { throw new  Auth Login Exception ( bundle Name , _ STR , new  Object [ ] { new  Integer ( state ) } ) ; }  Callback [ ] ext = get Callback ( state ) ; if ( ext . length <= _ NUM ) { throw new  Auth Login Exception ( bundle Name , _ STR , null ) ; } if ( ( header != null ) && ( header . length ( ) != _ NUM ) ) {  Page Properties Callback pc = (  Page Properties Callback ) ( (  Callback [ ] ) internal . get ( state - _ NUM ) ) [ _ NUM ] ; pc . set Header ( header ) ; } }
public static  Service create Service (  Pattern Timetable timetable ) {  Calendar calendar = new  Calendar ( ) ; calendar . monday = timetable . monday ? _ NUM : _ NUM ; calendar . tuesday = timetable . tuesday ? _ NUM : _ NUM ; calendar . wednesday = timetable . wednesday ? _ NUM : _ NUM ; calendar . thursday = timetable . thursday ? _ NUM : _ NUM ; calendar . friday = timetable . friday ? _ NUM : _ NUM ; calendar . saturday = timetable . saturday ? _ NUM : _ NUM ; calendar . sunday = timetable . sunday ? _ NUM : _ NUM ;  String Builder name Builder = new  String Builder ( _ STR ) ; name Builder . append ( timetable . monday ? _ STR : _ STR ) ; name Builder . append ( timetable . monday ? _ STR : _ STR ) ; name Builder . append ( timetable . monday ? _ STR : _ STR ) ; name Builder . append ( timetable . monday ? _ STR : _ STR ) ; name Builder . append ( timetable . monday ? _ STR : _ STR ) ; name Builder . append ( timetable . monday ? _ STR : _ STR ) ; name Builder . append ( timetable . monday ? _ STR : _ STR ) ;  Service service = new  Service ( name Builder . to String ( ) ) ; calendar . start_date = _ NUM ; calendar . end_date = _ NUM ; service . calendar = calendar ; return service ; }
public boolean remove (  Image Info object ) { final int location = get Location ( object ) ; final boolean removed = data . remove ( object ) ; notify Item Removed ( location ) ; return removed ; }
public  T allowed Users (  User ... users ) {  List <  User > users List =  Arrays . as List ( users ) ; this . user Predicate = null ; return instance ( ) ; }
VPlex Distributed Device Info find Distributed Device (  String device Name ) throws  VPlex Api Exception { return find Distributed Device ( device Name , _ BOOL ) ; }
static  Copy State read Copy State (  Data Input in ) throws  IOException { byte [ ] infos Bytes = new byte [ in . read VInt ( ) ] ; in . read Bytes ( infos Bytes , _ NUM , infos Bytes . length ) ; long gen = in . read VLong ( ) ; long version = in . read VLong ( ) ;  Map <  String ,  File Meta Data > files = read Files Meta Data ( in ) ; int count = in . read VInt ( ) ;  Set <  String > completed Merge Files = new  Hash Set < > ( ) ; for ( int i = _ NUM ; i < count ; i ++ ) { completed Merge Files . add ( in . read String ( ) ) ; } long primary Gen = in . read VLong ( ) ; return new  Copy State ( files , version , gen , infos Bytes , completed Merge Files , primary Gen , null ) ; }
public void notify Tasks ( ) { if ( tracker . should Interrupt Task ( ) ) { for (  Thread t : thread Map . values ( ) ) { t . interrupt ( ) ; } } }
public boolean confirm Overwrite ( final  File file ) {  String message = _ STR + file . get Name ( ) + _ STR ;  Object [ ] options = { _ STR , _ STR } ; return  JOption Pane .  YES_ OPTION ==  JOption Pane . show Option Dialog ( null , message , _ STR ,  JOption Pane .  DEFAULT_ OPTION ,  JOption Pane .  WARNING_ MESSAGE , null , options , options [ _ NUM ] ) ; }
public  Tv Show Update Datasource Task (  String datasource ) { super (  BUNDLE . get String ( _ STR ) + _ STR + datasource + _ STR ) ; tv Show List =  Tv Show List . get Instance ( ) ; data Sources = new  Array List < > ( _ NUM ) ; data Sources . add ( datasource ) ; }
public int find Line ( int offset ) { int line = line Starts . length - _ NUM ; while ( ( line Starts [ line ] > offset ) && ( line > _ NUM ) ) { line -- ; } return line ; }
public void clear ( ) {  Set <  Sensor > old Selection = new  Hash Set <  Sensor > ( selection ) ; selection . clear ( ) ; if ( ! old Selection . is Empty ( ) ) { fire Selection Changed ( old Selection , selection ) ; } }
private void load File Recursively (  String path ,  Map <  String ,  Thrift File Element > loaded Files ) throws  IOException {  Thrift File Element element = null ;  File dir = null ;  File file = find First Existing ( path , null ) ; if ( file != null ) { file = file . get Canonical File ( ) ; if ( loaded Files . contains Key ( file . get Absolute Path ( ) ) ) { return ; } dir = file . get Parent File ( ) ; element = load Single File ( file . get Parent File ( ) , file . get Name ( ) ) ; } if ( element == null ) { throw new  File Not Found Exception ( _ STR + path + _ STR + include Paths ) ; } loaded Files . put ( file . get Absolute Path ( ) , element ) ;  Immutable List <  Include Element > includes = element . includes ( ) ; if ( includes . size ( ) > _ NUM ) { include Paths . add First ( dir ) ; for (  Include Element include : includes ) { if ( ! include . is Cpp ( ) ) { load File Recursively ( include . path ( ) , loaded Files ) ; } } include Paths . remove First ( ) ; } }
public void assure Proxy Ok ( ) { if ( socket . is Closed ( ) ) { restart ( ) ; } }
@  Override public boolean add (  IMessage message ) { return add ( message , _ BOOL ) ; }
public  Key ( byte [ ] hash ) { if ( hash . length !=  SHA1_ HASH_ LENGTH ) { throw new  Illegal Argument Exception ( _ STR + hash . length ) ; }  System . arraycopy ( hash , _ NUM , this . hash , _ NUM ,  SHA1_ HASH_ LENGTH ) ; }
private static  Road Permission road Flag Comparision (  Way iosm Way ,  String new Tag ,  String new Value ,  Enum Set <  Edge Store .  Edge Flag > forward Expected ,  Enum Set <  Edge Store .  Edge Flag > backward Expected ) {  Way osm Way = new  Way ( ) ;  String Joiner string Joiner = new  String Joiner ( _ STR ) ; for (  OSMEntity .  Tag tag : iosm Way . tags ) { osm Way . add Tag ( tag . key , tag . value ) ; string Joiner . add ( tag . key + _ STR + tag . value ) ; } if ( new Tag != null && new Value != null ) { osm Way . add Tag ( new Tag , new Value ) ; string Joiner . add ( new Tag + _ STR + new Value ) ; }  Set <  Edge Store .  Edge Flag > forward Filtered ;  Set <  Edge Store .  Edge Flag > backward Filtered ;  Road Permission road Permission = traversal Permission Labeler . get Permissions ( osm Way ) ; forward Filtered = filter Flags ( road Permission . forward ) ; backward Filtered = filter Flags ( road Permission . backward ) ;  String tags = _ STR + string Joiner . to String ( ) ; assert Equals ( tags , forward Expected , forward Filtered ) ; assert Equals ( tags , backward Expected , backward Filtered ) ; return road Permission ; }
public void begin Display (  Display Event event ) throws  Model Control Exception {  Identity Subject Model subject Model = get Subject Model ( ) ;  Policy Model model = (  Policy Model ) get Model ( ) ; super . begin Display ( event ) ; if ( ! can Modify ) {  Map map Values = get Default Values ( ) ; if ( ( map Values != null ) && ! map Values . is Empty ( ) ) {  Set values = (  Set ) map Values . get (  AMIdentity Membership Condition .  AM_ IDENTITY_ NAME ) ;  Set identity Names = helper . get AMIdentity Names ( model . get User SSOToken ( ) , values ) ; property Sheet Model . set Value (  VALUES_ MULTIPLE_ CHOICE_ VALUE ,  AMAdmin Utils . get String ( identity Names , _ STR , _ BOOL ) ) ; } } else {  CCDrop Down Menu menu = (  CCDrop Down Menu ) get Child (  FILTER_ TYPE ) ;  Map supported Entity Types = model . get Supported Entity Types ( realm Name ) ;  Option List entity Types = create Option List ( supported Entity Types ) ; entity Types . add ( _ NUM , _ STR , _ STR ) ; menu . set Options ( entity Types ) ; menu . set Value ( _ STR ) ;  CCAdd Remove child = (  CCAdd Remove ) get Child (  VALUES_ MULTIPLE_ CHOICE_ VALUE ) ; child . restore State Data ( ) ; if ( ! submit Cycle ) { helper . set Selected Identities ( child , model . get User SSOToken ( ) , model . get User Locale ( ) , this , get Default Values ( ) ) ; } else {  Option List possible = helper . create Option List ( model . get User SSOToken ( ) , model . get User Locale ( ) , this , get Possible Values ( subject Model , realm Name ) ) ;  Option List selected = add Remove Model . get Selected Option List ( ) ;  List selected Ids =  AMAdmin Utils . to List ( selected ) ; child . reset State Data ( ) ; add Remove Model . set Available Option List ( possible ) ; add Remove Model . set Selected Option List ( helper . create Option List ( model . get User SSOToken ( ) , model . get User Locale ( ) , this , selected Ids ) ) ; } } }
public byte [ ] read Bytes ( ) throws  IOException { int len = read Int ( ) ; if ( len == - _ NUM ) { return null ; } byte [ ] b =  Data Utils . new Bytes ( len ) ; in . read Fully ( b ) ; return b ; }
public  String use Relative Path Tip Text ( ) { return _ STR ; }
public  Joiner join (  Class < ? extends  Data Object > clazz ,  String alias ,  URI ... ids ) { return join ( clazz , alias , new  Array List <  URI > (  Arrays . as List ( ids ) ) ) ; }
public void close File ( ) { close File ( _ BOOL ) ; }
public  List <  Interface > show Interface ( ) throws  Network Device Controller Exception {  List <  Interface > interfaces = new  Array List <  Interface > ( ) ;  SSHPrompt [ ] prompts = {  SSHPrompt .  POUND ,  SSHPrompt .  GREATER_ THAN } ;  String Builder buf = new  String Builder ( ) ;  SSHPrompt prompt = send Wait For (  MDSDialog Properties . get String ( _ STR ) , _ NUM , prompts , buf ) ;  String [ ] lines = get Lines ( buf ) ;  String [ ] regex = {  MDSDialog Properties . get String ( _ STR ) ,  MDSDialog Properties . get String ( _ STR ) ,  MDSDialog Properties . get String ( _ STR ) ,  MDSDialog Properties . get String ( _ STR ) ,  MDSDialog Properties . get String ( _ STR ) ,  MDSDialog Properties . get String ( _ STR ) } ;  String [ ] groups = new  String [ _ NUM ] ;  Interface intf = null ; for (  String line : lines ) { int index = match ( line , regex , groups ) ; switch ( index ) { case _ NUM : intf = new  Interface ( groups [ _ NUM ] ) ; intf . set Status ( groups [ _ NUM ] ) ; interfaces . add ( intf ) ; break ; case _ NUM : intf . set Description ( groups [ _ NUM ] ) ; break ; case _ NUM : intf . set Wwpn ( groups [ _ NUM ] ) ; break ; case _ NUM : intf . set Mode ( groups [ _ NUM ] ) ; intf . set Fcid ( groups [ _ NUM ] ) ; break ; case _ NUM : intf . set Vsan ( groups [ _ NUM ] ) ; break ; case _ NUM : intf . set Mode ( groups [ _ NUM ] ) ; break ; } } return interfaces ; }
protected void clear Data Lists ( int obd Service ) { switch ( obd Service ) { case  OBD_ SVC_ DATA : case  OBD_ SVC_ FREEZEFRAME : pid Supported . clear ( ) ;  Pid Pvs . clear ( ) ; break ; case  OBD_ SVC_ READ_ CODES : case  OBD_ SVC_ PENDINGCODES : case  OBD_ SVC_ PERMACODES : t Codes . clear ( ) ; break ; case  OBD_ SVC_ VEH_ INFO : pid Supported . clear ( ) ;  Vid Pvs . clear ( ) ; break ; } }
public  Quad Edge make Edge (  Vertex o ,  Vertex d ) {  Quad Edge q =  Quad Edge . make Edge ( o , d ) ; quad Edges . add ( q ) ; return q ; }
public static void sort Seqs (  List <  String > seqs ) {  Collections . sort ( seqs , null ) ; }
default  B with (  String key , long value ) { return with ( key ,  Long . to String ( value ) ) ; }
private void list Directory (  File directory ,  Relative Directory subdirectory ,  Set <  Java File Object .  Kind > file Kinds , boolean recurse ,  List Buffer <  Java File Object > result List ) {  File d = subdirectory . get File ( directory ) ; if ( ! case Map Check ( d , subdirectory ) ) return ;  File [ ] files = d . list Files ( ) ; if ( files == null ) return ; if ( sort Files != null )  Arrays . sort ( files , sort Files ) ; for (  File f : files ) {  String fname = f . get Name ( ) ; if ( f . is Directory ( ) ) { if ( recurse &&  Source Version . is Identifier ( fname ) ) { list Directory ( directory , new  Relative Directory ( subdirectory , fname ) , file Kinds , recurse , result List ) ; } } else { if ( is Valid File ( fname , file Kinds ) ) {  Java File Object fe = new  Regular File Object ( this , fname , new  File ( d , fname ) ) ; result List . append ( fe ) ; } } } }
private  Shape decode Edge ( int width , int height ) { path . reset ( ) ; path . move To ( width - _ NUM , _ NUM ) ; path . line To ( width - _ NUM , height - _ NUM ) ; path . line To ( width - _ NUM , height - _ NUM ) ; path . line To ( _ NUM , height - _ NUM ) ; return path ; }
private void test Scenario (  String a Configuration , boolean an Expecting An Exception ,  List <  Method > a Methods To Call ) throws  Exception { if ( a Methods To Call . is Empty ( ) ) { test Scenario ( a Configuration , an Expecting An Exception , (  Method ) null ) ; } else { for (  Method my Method : a Methods To Call ) { test Scenario ( a Configuration , an Expecting An Exception , my Method ) ; } } }
public boolean has Been Called (  String resource Name ) { return uris . contains ( resource Name ) ; }
@  Override public void read External (  Object Input in ) throws  IOException ,  Class Not Found Exception { super . read External ( in ) ; is Leaf = in . read Boolean ( ) ; num Entries = in . read Int ( ) ; }
public  Obj Id Map ( ) { this ( _ NUM , _ NUM ) ; }
public static  Connection Factory new Failover Connection Pool (  Set <  LDAPURL > servers ,  String username , char [ ] password , int max Size , int heart Beat Interval ,  String heart Beat Time Unit ,  Options ldap Options ) {  List <  Connection Factory > factories = new  Array List <  Connection Factory > ( servers . size ( ) ) ; for (  LDAPURL ldapurl : servers ) {  Connection Factory cf =  Connections . new Fixed Connection Pool ( new Connection Factory ( ldapurl , username , password , heart Beat Interval , heart Beat Time Unit , ldap Options ) , max Size ) ; factories . add ( cf ) ; } return load Balance Factories ( factories ) ; }
public  Printf Format ( final  String fmt Arg ) throws  Illegal Argument Exception { this (  Locale . get Default ( ) , fmt Arg ) ; }
public  Message Property Key (  String description ,  Integer ordinal ) { this . description = description ; this . ordinal = ordinal ; }
public void paint Border (  Component c ,  Graphics g , int x , int y , int width , int height ) {  JComponent comp = ( c instanceof  JComponent ) ? (  JComponent ) c : null ; if ( g instanceof  Graphics2 D ) {  Graphics2 D g2 = (  Graphics2 D ) g ; g2 . translate ( x , y ) ; paint ( g2 , comp , width , height ) ; g2 . translate ( - x , - y ) ; } else {  Buffered Image img = new  Buffered Image (  IMG_ SIZE ,  IMG_ SIZE ,  Buffered Image .  TYPE_ INT_ ARGB ) ;  Graphics2 D g2 = (  Graphics2 D ) img . get Graphics ( ) ; paint ( g2 , comp , width , height ) ; g2 . dispose ( ) ;  Image Scaling Helper . paint ( g , x , y , width , height , img ,  INSETS ,  INSETS ,  Image Scaling Helper .  Paint Type .  PAINT9_ STRETCH ,  Image Scaling Helper .  PAINT_ ALL ) ; } }
@  Suppress Warnings ( { _ STR , _ STR } ) public static  Line By Line File Input Operator restore Check Point (  Line By Line File Input Operator check Point Oper ,  Byte Array Output Stream bos ) throws  Exception {  Kryo kryo = new  Kryo ( ) ;  Input l Input = new  Input ( bos . to Byte Array ( ) ) ;  Line By Line File Input Operator oper = kryo . read Object ( l Input , check Point Oper . get Class ( ) ) ; l Input . close ( ) ; return oper ; }
private static synchronized boolean is Supported Impl (  Http Caller Info hci ) { if ( supported == null ) { supported = new  Hash Map <  String ,  Boolean > ( ) ; cache = new  Hash Map <  String ,  Negotiator > ( ) ; }  String hostname = hci . host ; hostname = hostname . to Lower Case ( ) ; if ( supported . contains Key ( hostname ) ) { return supported . get ( hostname ) ; }  Negotiator neg =  Negotiator . get Negotiator ( hci ) ; if ( neg != null ) { supported . put ( hostname , _ BOOL ) ; cache . put ( hostname , neg ) ; return _ BOOL ; } else { supported . put ( hostname , _ BOOL ) ; return _ BOOL ; } }
public  CProject Configuration ( final  INavi Project project , final  Listener Provider <  IProject Listener > listeners , final  SQLProvider provider , final int project Id , final  String name , final  String description , final  Date creation Date , final  Date modification Date , final  List <  Debugger Template > assigned Debuggers ) { m_project = project ; m_listeners = listeners ; m_provider = provider ; m_id = project Id ; m_name = name ; m_description = description ; m_creation Date = new  Date ( creation Date . get Time ( ) ) ; m_modification Date = new  Date ( modification Date . get Time ( ) ) ; m_assigned Debuggers = new  Array List <  Debugger Template > ( assigned Debuggers ) ; }
public  Shape chart To Screen Shape (  Shape s ) {  General Path p = new  General Path ( ) ;  Transform inverse =  Transform . make Translation ( get Absolute X ( ) , get Absolute Y ( ) ) ; if ( current Transform != null ) { inverse . concatenate ( current Transform ) ; } p . append ( s . get Path Iterator ( inverse ) , _ BOOL ) ; return p ; }
@  Override public void add Shutdown Window ( final  Window window ) { if ( m_is Shut Down ) { close Window ( window ) ; return ; } synchronized ( this ) { if ( m_is Shut Down ) { close Window ( window ) ; return ; } m_windows To Close On Shutdown . add ( window ) ; } }
public  Performance Logger ( ) { time1 =  System . current Time Millis ( ) ; }
public  Auth Request authenticate (  List discoveries ,  String return To Url ) throws  Consumer Exception ,  Message Exception { return authenticate ( discoveries , return To Url , return To Url ) ; }
public boolean is Numerical Run (  String pin ) { final int len = pin . length ( ) ; int prev Digit =  Character . digit ( pin . char At ( _ NUM ) , _ NUM ) ; int prev Diff =  Integer .  MAX_ VALUE ; boolean is Run = _ BOOL ; for ( int i = _ NUM ; is Run && i < len ; i ++ ) { final int digit =  Character . digit ( pin . char At ( i ) , _ NUM ) ; final int diff = digit - prev Digit ; if ( prev Diff !=  Integer .  MAX_ VALUE && diff != prev Diff ) { is Run = _ BOOL ; } prev Diff = diff ; prev Digit = digit ; } return is Run ; }
public static int uri Type (  String uri ) { if ( uri . index Of ( _ STR ) != - _ NUM ) { return  ABS_ URI ; } else if ( uri . starts With ( _ STR ) ) { return  ROOT_ REL_ URI ; } else { return  NOROOT_ REL_ URI ; } }
public static boolean is Resource Reference (  String str ) { return str . starts With (  BIG_ QUOTE_ LEFT ) && str . ends With (  BIG_ QUOTE_ RIGHT ) && str . char At ( _ NUM ) ==  AT . char At ( _ NUM ) ; }
public boolean leave ( ) throws  Keeper Exception ,  Interrupted Exception { zoo Keeper . delete ( root Path + _ STR + name , _ NUM ) ; while ( _ BOOL ) { synchronized ( mutex ) {  List <  String > list = zoo Keeper . get Children ( root Path , _ BOOL ) ; if ( list . size ( ) > _ NUM ) { mutex . wait ( ) ; } else { return _ BOOL ; } } } }
public  Select Clause add With As Provided Name (  String property Name ,  String as Name ) { select List . add ( new  Select Clause Expression ( new  Property Value Expression ( property Name ) , as Name ) ) ; return this ; }
public void add Interface (  String interface Name ) { short interface Index = its Constant Pool . add Class ( interface Name ) ; its Interfaces . add (  Short . value Of ( interface Index ) ) ; }
public static  String cut From Index Of (  String string ,  String substring ) { int i = string . index Of ( substring ) ; if ( i != - _ NUM ) { string = string . substring ( i ) ; } return string ; }
private  Response request Http Get From Registry (  String url ) throws  Registry Exception { try {  Response resp = http . get ( url ) ; if ( resp != null && resp . content != null ) { return resp ; } else { throw new  Registry Exception (  TYPE .  BAD_ RESPONSE , _ STR ) ; } } catch (  Class Cast Exception e ) { throw new  Registry Exception (  TYPE .  BAD_ RESPONSE , e ) ; } catch (  Connect Exception e ) { throw new  Registry Exception (  TYPE .  PROXY , e ) ; } catch (  Unknown Host Exception e ) { try { http . get ( _ STR ) ; } catch (  Exception e1 ) { throw new  Registry Exception (  TYPE .  NO_ INTERNET , e1 ) ; } throw new  Registry Exception (  TYPE .  SITE_ DOWN , e ) ; } catch (  IOException e ) { throw new  Registry Exception (  TYPE .  IO_ ERROR , e ) ; } catch (  URISyntax Exception e ) { throw new  Registry Exception (  TYPE .  BAD_ REQUEST , _ STR + ( ( url != null ) ? url : _ STR ) ) ; } }
public void test Iterator ( ) throws  Interrupted Exception {  Linked Blocking Queue q = populated Queue (  SIZE ) ;  Iterator it = q . iterator ( ) ; while ( it . has Next ( ) ) { assert Equals ( it . next ( ) , q . take ( ) ) ; } }
public void init (  Remote Authenticated User current User ) { this . current User = current User ; }
private void remove Tv Show (  Tv Show tv Show ) { synchronized ( root ) {  Tv Show Tree Node child = (  Tv Show Tree Node ) node Map . get ( tv Show ) ;  Default Mutable Tree Node parent = root ; if ( child != null ) { int index = get Index Of Child ( parent , child ) ; node Map . remove ( tv Show ) ; for (  Tv Show Episode episode : new  Array List < > ( tv Show . get Episodes ( ) ) ) { node Map . remove ( episode ) ; episode . remove Property Change Listener ( property Change Listener ) ; } tv Show . remove Property Change Listener ( property Change Listener ) ; child . remove All Children ( ) ; child . remove From Parent ( ) ; if ( index > - _ NUM ) {  Tree Model Event event = new  Tree Model Event ( this , parent . get Path ( ) , new int [ ] { index } , new  Object [ ] { child } ) ; for (  Tree Model Listener listener : listeners ) { try { listener . tree Nodes Removed ( event ) ; } catch (  Null Pointer Exception |  Array Index Out Of Bounds Exception npe ) { } } } } } }
private  Compliance Feature check Encrypt Policy ( org . wso2 . emm . agent . beans .  Operation operation ) { boolean encrypt Status = ( device Policy Manager . get Storage Encryption Status ( ) != device Policy Manager .  ENCRYPTION_ STATUS_ UNSUPPORTED && device Policy Manager . get Storage Encryption Status ( ) != device Policy Manager .  ENCRYPTION_ STATUS_ INACTIVE ) ; if ( ( operation . is Enabled ( ) && encrypt Status ) || ( ! operation . is Enabled ( ) && ! encrypt Status ) ) { policy . set Compliance ( _ BOOL ) ; } else { policy . set Compliance ( _ BOOL ) ; policy . set Message ( resources . get String (  R . string . error_encrypt_policy ) ) ; } return policy ; }
public static int instance Of (  Object o ,  Class < ? > c ) { if ( o == null ) return  FALSE ; return c . is Assignable From ( o . get Class ( ) ) ?  TRUE :  FALSE ; }
@  Override public  Void call ( ) throws  Exception {  Multicast Socket datagram Socket = null ;  Executor Service service = null ; try { datagram Socket = new  Multicast Socket ( port ) ; datagram Socket . join Group ( group ) ; service =  Executors . new Single Thread Scheduled Executor ( new  Daemon Thread Factory ( _ STR ) ) ; final byte [ ] buffer = new byte [  BUFFER_ SIZE ] ; final  Datagram Packet packet = new  Datagram Packet ( buffer , _ NUM , buffer . length ) ; listening = _ BOOL ; while ( _ BOOL ) { try { datagram Socket . receive ( packet ) ; if (  Thread . interrupted ( ) ) { break ; } final  IGanglia Message msg = decode Record ( packet . get Data ( ) , packet . get Offset ( ) , packet . get Length ( ) ) ; if ( msg != null ) { service . submit ( new  Dispatch Task ( handler , msg ) ) ; } } catch (  Throwable t ) { log . warn ( t , t ) ; } } return (  Void ) null ; } finally { if ( service != null ) { service . shutdown ( ) ; } if ( datagram Socket != null ) { datagram Socket . close ( ) ; } listening = _ BOOL ; } }
protected static void invalidate Switch Points ( ) { if (  LOG_ ENABLED ) {  LOG . info ( _ STR ) ; } synchronized (  Indy Interface . class ) {  Switch Point old = switch Point ; switch Point = new  Switch Point ( ) ;  Switch Point . invalidate All ( new  Switch Point [ ] { old } ) ; } }
public  Vdc Config to Config Param (  Properties vdc Info ) { log . info ( _ STR , vdc Info . get Property (  Geo Service Job .  VDC_ SHORT_ ID ) ) ;  Vdc Config vdc Config = new  Vdc Config ( ) ; vdc Config . set Id (  URIUtil . uri ( vdc Info . get Property (  Geo Service Job .  OPERATED_ VDC_ ID ) ) ) ; vdc Config . set Short Id ( vdc Info . get Property (  Geo Service Job .  VDC_ SHORT_ ID ) ) ; vdc Config . set Secret Key ( vdc Info . get Property (  Geo Service Job .  VDC_ SECRETE_ KEY ) ) ;  String name = vdc Info . get Property (  Geo Service Job .  VDC_ NAME ) ; if ( ( name != null ) && ( ! name . is Empty ( ) ) ) { vdc Config . set Name ( name ) ; }  String description = vdc Info . get Property (  Geo Service Job .  VDC_ DESCRIPTION ) ; if ( ( description != null ) && ( ! description . is Empty ( ) ) ) { vdc Config . set Description ( description ) ; }  String end Pnt = vdc Info . get Property (  Geo Service Job .  VDC_ API_ ENDPOINT ) ; if ( end Pnt != null ) { vdc Config . set Api Endpoint ( end Pnt ) ; } vdc Config . set Geo Command Endpoint ( vdc Info . get Property (  Geo Service Job .  VDC_ GEOCOMMAND_ ENDPOINT ) ) ; vdc Config . set Geo Data Endpoint ( vdc Info . get Property (  Geo Service Job .  VDC_ GEODATA_ ENDPOINT ) ) ; return vdc Config ; }
protected  OSXAdapter (  String proxy Signature ,  Object target ,  Method handler ) { this . proxy Signature = proxy Signature ; this . target Object = target ; this . target Method = handler ; }
private double prediction (  Instance inst ) { double [ ] normalized Instance = normalized Instance ( inst ) ; double normalized Prediction = prediction ( normalized Instance ) ; return denormalized Prediction ( normalized Prediction ) ; }
protected  Object finish (  Map settings ) throws  Wizard Exception { return provider . finish ( settings ) ; }
protected void fire Cluster Change ( long timestamp ,  String type ,  String message ) { if ( listeners != null && ! listeners . is Empty ( ) ) {  Cluster Event event = new  Cluster Event ( this , timestamp , type , message ) ;  Vector targets ; synchronized ( this ) { targets = (  Vector ) listeners . clone ( ) ; }  Enumeration e = targets . elements ( ) ; while ( e . has More Elements ( ) ) {  Cluster Event Listener l = (  Cluster Event Listener ) e . next Element ( ) ; l . change Cluster ( event ) ; } } }
public int rgb For ( int pixel ) { return surface Type . rgb For ( pixel , color Model ) ; }
private boolean check For Carry ( final char [ ] ca1 , final int icarry ) { boolean carry = _ BOOL ; if ( icarry < ca1 . length ) { if ( ca1 [ icarry ] == _ STR || ca1 [ icarry ] == _ STR || ca1 [ icarry ] == _ STR || ca1 [ icarry ] == _ STR ) { carry = _ BOOL ; } else if ( ca1 [ icarry ] == _ STR ) { int ii = icarry + _ NUM ; for ( ; ii < ca1 . length ; ii ++ ) { if ( ca1 [ ii ] != _ STR ) { break ; } } carry = ii < ca1 . length ; if ( ! carry && icarry > _ NUM ) { carry = ( ca1 [ icarry - _ NUM ] == _ STR || ca1 [ icarry - _ NUM ] == _ STR || ca1 [ icarry - _ NUM ] == _ STR || ca1 [ icarry - _ NUM ] == _ STR || ca1 [ icarry - _ NUM ] == _ STR ) ; } } } return carry ; }
protected void add Bottom Component (  Component bottom Component ) { c . weighty = _ NUM ; layout . set Constraints ( bottom Component , c ) ; content Panel . add ( bottom Component ) ; }
public static boolean delete Directory Files (  Set <  String > input File Paths And Names ) { if ( ( input File Paths And Names == null ) ) { return _ BOOL ; } boolean did Successfully Delete All Files = _ BOOL ; try { for (  String file Path And Name : input File Paths And Names ) {  File file = new  File ( file Path And Name ) ; if ( ! file . is Directory ( ) ) { boolean delete Success = delete File ( file Path And Name ) ; if ( ! delete Success ) { logger . debug ( _ STR + file Path And Name + _ STR ) ; did Successfully Delete All Files = _ BOOL ; } } } } catch (  Exception e ) { logger . debug ( e . to String ( ) +  System . line Separator ( ) +  Stack Trace . get String From Stack Trace ( e ) ) ; return _ BOOL ; } return did Successfully Delete All Files ; }
public static  File create Temp Dir (  File dir , boolean cleanup ) throws  IOException { if ( ! dir . mkdirs ( ) && ! dir . exists ( ) ) { throw new  IOException (  String . format ( _ STR , dir . to String ( ) ) ) ; } if ( cleanup ) { add Cleanup Hook ( dir . to Path ( ) ) ; } return dir ; }
public static  String read Cookie Ignore Special Characters (  Http Servlet Request request ,  String cookie Name ) {  String cs = request . get Header ( _ STR ) ; if ( cs == null ) return null ; int start = cs . index Of ( cookie Name ) ; if ( start < _ NUM ) return null ; cs = cs . substring ( start + _ NUM + cookie Name . length ( ) ) ; int end = cs . index Of ( _ STR ) ; if ( end > _ NUM ) { cs = cs . substring ( _ NUM , end ) ; } return cs ; }
protected final void merge ( @  Not Null  Set <  Local Resource Repository > visited , @  Not Null  Resource Type type , @  Not Null  Set Multimap <  String ,  String > seen Qualifiers , @  Not Null  List Multimap <  String ,  Resource Item > result ) { if ( visited . contains ( this ) ) { return ; } visited . add ( this ) ; do Merge ( visited , type , seen Qualifiers , result ) ; }
private byte [ ] translate Transferable String (  String str , long format ) throws  IOException {  Long l Format =  Long . value Of ( format ) ;  String charset = get Best Charset For Text Format ( l Format , null ) ;  String eoln = (  String ) native EOLNs . get ( l Format ) ; if ( eoln != null ) { int length = str . length ( ) ;  String Buffer buffer = new  String Buffer ( length * _ NUM ) ; for ( int i = _ NUM ; i < length ; i ++ ) { if ( str . starts With ( eoln , i ) ) { buffer . append ( eoln ) ; i += eoln . length ( ) - _ NUM ; continue ; } char c = str . char At ( i ) ; if ( c == _ STR ) { buffer . append ( eoln ) ; } else { buffer . append ( c ) ; } } str = buffer . to String ( ) ; } byte [ ] bytes = str . get Bytes ( charset ) ;  Integer terminators = (  Integer ) native Terminators . get ( l Format ) ; if ( terminators != null ) { int num Terminators = terminators . int Value ( ) ; byte [ ] terminated Bytes = new byte [ bytes . length + num Terminators ] ;  System . arraycopy ( bytes , _ NUM , terminated Bytes , _ NUM , bytes . length ) ; for ( int i = bytes . length ; i < terminated Bytes . length ; i ++ ) { terminated Bytes [ i ] = _ NUM ; } bytes = terminated Bytes ; } return bytes ; }
public  Position create Position ( int offset ) throws  Bad Location Exception { while ( queue . poll ( ) != null ) { unused Marks ++ ; } if ( unused Marks >  Math . max ( _ NUM , ( marks . size ( ) / _ NUM ) ) ) { remove Unused Marks ( ) ; } int g0 = get Gap Start ( ) ; int g1 = get Gap End ( ) ; int index = ( offset < g0 ) ? offset : offset + ( g1 - g0 ) ; search . index = index ; int sort Index = find Sort Index ( search ) ;  Mark Data m ;  Sticky Position position ; if ( sort Index < marks . size ( ) && ( m = marks . element At ( sort Index ) ) . index == index && ( position = m . get Position ( ) ) != null ) { } else { position = new  Sticky Position ( ) ; m = new  Mark Data ( index , position , queue ) ; position . set Mark ( m ) ; marks . insert Element At ( m , sort Index ) ; } return position ; }
public static  String pad (  String string , int n ,  String padding , boolean right ) { if ( n < _ NUM ) { n = _ NUM ; } if ( n < string . length ( ) ) { return string . substring ( _ NUM , n ) ; } else if ( n == string . length ( ) ) { return string ; } char padding Char ; if ( padding == null || padding . length ( ) == _ NUM ) { padding Char = _ STR ; } else { padding Char = padding . char At ( _ NUM ) ; }  String Builder buff = new  String Builder ( n ) ; n -= string . length ( ) ; if ( right ) { buff . append ( string ) ; } for ( int i = _ NUM ; i < n ; i ++ ) { buff . append ( padding Char ) ; } if ( ! right ) { buff . append ( string ) ; } return buff . to String ( ) ; }
private final void reset DTX (  Affine Transform at ) { fsref = null ; dtx = at ; invdtx = null ; if ( ! dtx . is Identity ( ) ) { try { invdtx = dtx . create Inverse ( ) ; } catch (  Noninvertible Transform Exception e ) { } } if ( gti != null ) { gti . strikes Ref = null ; } }
public static void add Activity Listener (  Activity Listener listener ) { if ( listener != null ) { start Tracking ( ) ; listeners . add ( listener ) ; } }
public void add Muted Username ( final  String username , final  Date mute Till ) { if ( is Username Muted ( username ) ) { remove Muted Username ( username ) ; }  Timestamp mute Till Ts = null ; if ( mute Till != null ) { mute Till Ts = new  Timestamp ( mute Till . get Time ( ) ) ; } s_logger . fine ( _ STR + username ) ; final  Connection con =  Database . get Connection ( ) ; try { final  Prepared Statement ps = con . prepare Statement ( _ STR ) ; ps . set String ( _ NUM , username ) ; ps . set Timestamp ( _ NUM , mute Till Ts ) ; ps . execute ( ) ; ps . close ( ) ; con . commit ( ) ; } catch ( final  SQLException sqle ) { if ( sqle . get Error Code ( ) == _ NUM ) { s_logger . info ( _ STR + username + _ STR + sqle . get Message ( ) ) ; return ; } s_logger . log (  Level .  SEVERE , _ STR + username , sqle ) ; throw new  Illegal State Exception ( sqle . get Message ( ) ) ; } finally {  Db Util . close Connection ( con ) ; } }
private  Response <  Bitmap > do Parse (  Network Response response ) { byte [ ] data = response . data ;  Log . d ( _ STR , _ STR ) ;  Bitmap Factory .  Options decode Options = new  Bitmap Factory .  Options ( ) ;  Bitmap bitmap = null ;  Log . d ( _ STR , _ STR ) ; decode Options . in Just Decode Bounds = _ BOOL ;  Bitmap Factory . decode Byte Array ( data , _ NUM , data . length , decode Options ) ; int actual Width = decode Options . out Width ; int actual Height = decode Options . out Height ; int desired Width = get Resized Dimension ( m Max Width , m Max Height , actual Width , actual Height , m Scale Type ) ; int desired Height = get Resized Dimension ( m Max Height , m Max Width , actual Height , actual Width , m Scale Type ) ; decode Options . in Just Decode Bounds = _ BOOL ; decode Options . in Sample Size = find Best Sample Size ( actual Width , actual Height , desired Width , desired Height ) ;  Bitmap temp Bitmap =  Bitmap Factory . decode Byte Array ( data , _ NUM , data . length , decode Options ) ; if ( temp Bitmap != null && ( temp Bitmap . get Width ( ) > desired Width || temp Bitmap . get Height ( ) > desired Height ) ) { bitmap =  Bitmap . create Scaled Bitmap ( temp Bitmap , desired Width , desired Height , _ BOOL ) ; temp Bitmap . recycle ( ) ; } else { bitmap = temp Bitmap ; } if ( bitmap == null ) { return  Response . error ( new  Parse Error ( response ) ) ; } else { return  Response . success ( bitmap ,  Http Header Parser . parse Cache Headers ( response ) ) ; } }
public boolean is Empty ( ) { return m Selected Widgets . is Empty ( ) ; }
public void close ( ) throws  IOException { if ( ! closed ) { try { finish ( ) ; } finally { out . close ( ) ; closed = _ BOOL ; } } }
protected abstract  C new Parcelable Adapter Instance (  List <  Object > items ) ;
public static void next Bytes ( byte [ ] bytes ) { was Accessed = _ BOOL ; for ( int i = _ NUM ; i < bytes . length ; ) for ( int rnd = next Int ( ) , n =  Math . min ( bytes . length - i , _ NUM ) ; n -- > _ NUM ; rnd >>= _ NUM ) bytes [ i ++ ] = ( byte ) rnd ; }
protected void draw Low Far Out ( double a Radius ,  Graphics2 D g2 , double xx , double m ) { double side = a Radius * _ NUM ; g2 . draw ( new  Line2 D .  Double ( xx - side , m - side , xx + side , m - side ) ) ; g2 . draw ( new  Line2 D .  Double ( xx - side , m - side , xx , m ) ) ; g2 . draw ( new  Line2 D .  Double ( xx + side , m - side , xx , m ) ) ; }
private  Set <  Object Name > object Names From Filtered Named Objects (  Set <  Named Object > list ,  Query Exp query ) {  Set <  Object Name > result = new  Hash Set <  Object Name > ( ) ; if ( query == null ) { for (  Named Object no : list ) { result . add ( no . get Name ( ) ) ; } } else { final  MBean Server old Server =  Query Eval . get MBean Server ( ) ; query . set MBean Server ( server ) ; try { for (  Named Object no : list ) { boolean res ; try { res = query . apply ( no . get Name ( ) ) ; } catch (  Exception e ) { res = _ BOOL ; } if ( res ) { result . add ( no . get Name ( ) ) ; } } } finally { query . set MBean Server ( old Server ) ; } } return result ; }
private  Element create End Point (  String name ,  String attr Binding ,  String attr Location ,  String attr Response Location ) throws  DOMException { if ( name == null ) { throw new  Illegal Argument Exception ( _ STR ) ; } if ( attr Binding == null ) { throw new  Illegal Argument Exception ( _ STR ) ; } if ( attr Location == null ) { throw new  Illegal Argument Exception ( _ STR ) ; }  Element end Pt = doc . create Element ( name ) ; end Pt . set Attribute (  SAMLNames .  BINDING , attr Binding ) ; end Pt . set Attribute (  SAMLNames .  LOCATION , attr Location ) ; if ( attr Response Location != null ) { end Pt . set Attribute (  SAMLNames .  RESPLOC , attr Response Location ) ; } return end Pt ; }
void put File (  String relative Path ,  Codebase codebase ) { try {  File dest = new  File ( root Directory . get Absolute Path ( ) , relative Path ) ;  File src = codebase . get File ( relative Path ) ; boolean src Exists = filesystem . exists ( src ) ; boolean dest Exists = filesystem . exists ( dest ) ; boolean src Executable = filesystem . is Executable ( src ) ; boolean dest Executable = filesystem . is Executable ( dest ) ; if ( ! src Exists && ! dest Exists ) { throw new  Moe Problem ( _ STR , relative Path , src , dest ) ; } if ( ! src Exists ) { util . run Svn Command With Working Directory ( root Directory . get Absolute Path ( ) , _ STR , relative Path ) ; return ; } try { filesystem . make Dirs For File ( dest ) ; filesystem . copy File ( src , dest ) ; } catch (  IOException e ) { throw new  Moe Problem ( e . get Message ( ) ) ; } if ( ! dest Exists ) { util . run Svn Command With Working Directory ( root Directory . get Absolute Path ( ) , _ STR , _ STR , relative Path ) ; }  String mime Type = guess Mime Type ( relative Path ) ; if ( mime Type != null ) { try { util . run Svn Command With Working Directory ( root Directory . get Absolute Path ( ) , _ STR , _ STR , mime Type , relative Path ) ; } catch (  Command Runner .  Command Exception e ) { ui . message ( _ STR , relative Path ) ; } } if ( dest Executable != src Executable ) { if ( src Executable ) { util . run Svn Command With Working Directory ( root Directory . get Absolute Path ( ) , _ STR , _ STR , _ STR , relative Path ) ; } else { util . run Svn Command With Working Directory ( root Directory . get Absolute Path ( ) , _ STR , _ STR , relative Path ) ; } } } catch (  Command Runner .  Command Exception e ) { throw new  Moe Problem ( _ STR + e . stderr ) ; } }
public  String to String ( ) {  String Buffer buffer = new  String Buffer ( ) ; buffer . append ( to String ( get Class ( ) ) ) ; buffer . append ( _ STR ) ; buffer . append ( is Use Default ( ) ) ; buffer . append ( _ STR ) ; buffer . append ( use Locale Format ) ; if ( pattern != null ) { buffer . append ( _ STR ) ; buffer . append ( pattern ) ; } if ( locale != null ) { buffer . append ( _ STR ) ; buffer . append ( locale ) ; } buffer . append ( _ STR ) ; return buffer . to String ( ) ; }
public void test_multiple Resource Locking_resources10_locktries10 ( ) throws  Exception { final  Properties properties = new  Properties ( ) ; properties . set Property (  Test Options .  NTHREADS , _ STR ) ; properties . set Property (  Test Options .  NTASKS , _ STR ) ; properties . set Property (  Test Options .  NRESOURCES , _ STR ) ; properties . set Property (  Test Options .  MIN_ LOCKS , _ STR ) ; properties . set Property (  Test Options .  MAX_ LOCKS , _ STR ) ; properties . set Property (  Test Options .  MAX_ LOCK_ TRIES , _ STR ) ; properties . set Property (  Test Options .  PREDECLARE_ LOCKS , _ STR ) ; properties . set Property (  Test Options .  SORT_ LOCK_ REQUESTS , _ STR ) ; properties . set Property (  Test Options .  TIMEOUT ,  Long . to String ( _ NUM * _ NUM ) ) ; do Comparison Test ( properties ) ; }
private byte [ ] convert Bitmap To Bytes ( final  Bitmap bitmap ) { int size = bitmap . get Row Bytes ( ) * bitmap . get Height ( ) ;  Byte Array Output Stream out = new  Byte Array Output Stream ( size ) ; try { if ( bitmap . compress (  Bitmap .  Compress Format .  PNG , _ NUM , out ) ) { return out . to Byte Array ( ) ; } if ( s Logger . is Activated ( ) ) { s Logger . debug ( _ STR ) ; } return null ; } finally {  Closeable Utils . try To Close ( out ) ; } }
private static void save Template (  File parent Dir ,  File Template Base template , final  String line Separator ) throws  IOException { final  File template File = new  File ( parent Dir , encode File Name ( template . get Name ( ) , template . get Extension ( ) ) ) ;  File Output Stream file Output Stream ; try { file Output Stream = new  File Output Stream ( template File ) ; } catch (  File Not Found Exception e ) {  File Util . delete ( template File ) ; file Output Stream = new  File Output Stream ( template File ) ; }  Output Stream Writer output Stream Writer = new  Output Stream Writer ( file Output Stream ,  Charset Toolkit .  UTF8_ CHARSET ) ;  String content = template . get Text ( ) ; if ( ! line Separator . equals ( _ STR ) ) { content =  String Util . convert Line Separators ( content , line Separator ) ; } output Stream Writer . write ( content ) ; output Stream Writer . close ( ) ; file Output Stream . close ( ) ; }
@  Override public  Enumeration <  Option > list Options ( ) {  Vector <  Option > new Vector = new  Vector <  Option > ( _ NUM ) ; new Vector . add Element ( new  Option ( _ STR + _ STR , _ STR , _ NUM , _ STR ) ) ; new Vector . add Element ( new  Option ( _ STR , _ STR , _ NUM , _ STR ) ) ; new Vector . add Element ( new  Option ( _ STR , _ STR , _ NUM , _ STR ) ) ; new Vector . add All (  Collections . list ( super . list Options ( ) ) ) ; return new Vector . elements ( ) ; }
public void add Composite (  Transform Tree Node node ) { parts . add ( node ) ; }
protected static void post Process Flood (  IHex [ ] hex Set , int modifier ) { int n ;  IHex field ;  ITerrain Factory f =  Terrains . get Terrain Factory ( ) ; for ( n = _ NUM ; n < hex Set . length ; n ++ ) { field = hex Set [ n ] ; int elev = field . get Level ( ) - modifier ; if ( ( elev == _ NUM ) && ! ( field . contains Terrain (  Terrains .  WATER ) ) && ! ( field . contains Terrain (  Terrains .  PAVEMENT ) ) ) { field . add Terrain ( f . create Terrain (  Terrains .  SWAMP , _ NUM ) ) ; } else if ( elev < _ NUM ) { if ( elev < - _ NUM ) { elev = - _ NUM ; } field . remove All Terrains ( ) ; field . add Terrain ( f . create Terrain (  Terrains .  WATER , - elev ) ) ; field . set Level ( modifier ) ; } } }
public  Module Handle add Module (  String module Name ,  String session Key ) {  String sanitized Module Name = generate Unique Name If Null Or Empty ( module Name , _ STR ) ;  Module Handle module Handle = new  Module Handle ( sanitized Module Name , session Key ) ; synchronized ( private Instance Lock ) { modules . add ( module Handle ) ; } set Terminated ( _ BOOL ) ; return module Handle ; }
private static void expand2 Digit Number (  String number String ,  Word Relation word Relation ,  Item token Item ) { if ( number String . char At ( _ NUM ) == _ STR ) { if ( number String . char At ( _ NUM ) == _ STR ) { } else {  String number = digit2num [ number String . char At ( _ NUM ) - _ STR ] ; word Relation . add Word ( token Item , number ) ; } } else if ( number String . char At ( _ NUM ) == _ STR ) {  String number = digit2enty [ number String . char At ( _ NUM ) - _ STR ] ; word Relation . add Word ( token Item , number ) ; } else if ( number String . char At ( _ NUM ) == _ STR ) {  String number = digit2teen [ number String . char At ( _ NUM ) - _ STR ] ; word Relation . add Word ( token Item , number ) ; } else {  String enty = digit2enty [ number String . char At ( _ NUM ) - _ STR ] ; word Relation . add Word ( token Item , enty ) ; expand Digits ( number String . substring ( _ NUM , number String . length ( ) ) , word Relation , token Item ) ; } }
protected int index Of (  String buffer , int start , int end , char ch ) { for ( int i = start ; i < end ; i ++ ) { if ( buffer . char At ( i ) == ch ) { return i ; } } return - _ NUM ; }
@  Override public boolean is Enabled ( ) { if ( ( attribute Selection Panel != null ) && ! is Value Only ( ) ) { return attribute Selection Panel . is Enabled ( ) ; } else { if ( this . crs Combo Box != null ) { return crs Combo Box . is Enabled ( ) ; } } return _ BOOL ; }
public static double variance ( double [ ] x , double mean ) { double var = _ NUM ; int count = x . length ; for ( double a X : x ) { if (  Double . is Na N ( a X ) ) { count -- ; } else { double diff = a X - mean ; var += diff * diff ; } } if ( count < _ NUM ) { count = _ NUM ; } else { count = count - _ NUM ; } return var / ( double ) count ; }
private void stash Request User (  Request And Response request And Response ) { if ( request And Response . was User Already Stashed ) { return ; } request And Response . was User Already Stashed = _ BOOL ; final  User user = db Logic . get User By Id ( get Effective User Id ( request And Response ) ) ; if ( user != null ) { request And Response . user Is Admin = user . get Is Admin ( ) ; request And Response . user Is Account Closed = user . get Is Account Closed ( ) ; request And Response . user Options = user . get Options ( ) ; } else { request And Response . user Options = _ STR ; } }
@  Override public void send Location List ( ) {  List <  Location > location List = lm . get Locations By Name List ( ) ;  Array List <  Attribute > location ; for (  Location loc : location List ) { location = new  Array List <  Attribute > ( _ NUM ) ; location . add ( new  Attribute (  LOCATIONS , loc ) ) ; try { send Message ( location ) ; } catch (  IOException ioe ) { log . debug ( _ STR + loc . get Name ( ) ) ; } } }
@  Override public boolean is Inside Soft Wrap ( @  Not Null  Visual Position visual ) { return is Inside Soft Wrap ( visual , _ BOOL ) ; }
static public  Input Stream find Cluster XML (  String _cluster XML ) {  String schema Name To Be Used = _cluster XML ;  Input Stream schema Input Stream ;  String schema File Path =  Constants .  Container .  CONTAINER_ CONFIG_ DIRECTORY + _ STR + schema Name To Be Used +  Cluster XML .  CLUSTER_ XML_ FILE_ SUFFIX ; schema Input Stream = get Resource Stream ( schema File Path ) ; if ( schema Input Stream != null ) { if ( _logger . is Loggable (  Level .  INFO ) ) { _logger . info ( _ STR + get Resource URL ( schema Name To Be Used ) + _ STR ) ; } return schema Input Stream ; } else {  String default Schema File Name =  Constants .  Container .  CONTAINER_ CONFIG_ DIRECTORY + _ STR +  Constants .  Schemas .  DEFAULT_ SCHEMA +  Cluster XML .  CLUSTER_ XML_ FILE_ SUFFIX ; schema Input Stream = get Resource Stream ( default Schema File Name ) ; if ( schema Input Stream != null ) { if ( _logger . is Loggable (  Level .  WARNING ) ) { _logger . warning ( _ STR + schema File Path + _ STR + get Resource URL ( default Schema File Name ) + _ STR ) ; } return schema Input Stream ; } else { if ( _logger . is Loggable (  Level .  WARNING ) ) { _logger . warning ( _ STR + default Schema File Name ) ; } } } return schema Input Stream ; }
public boolean is Valid (  World world ) { return _ BOOL ; }
public void clear ( ) {  Arrays . fill ( ritems , _ NUM , rsize , null ) ;  Arrays . fill ( pitems , _ NUM , psize , null ) ; rsize = _ NUM ; psize = _ NUM ; }
private  Parse Position next ( final  Parse Position pos ) { pos . set Index ( pos . get Index ( ) + _ NUM ) ; return pos ; }
private int flush ( int offset ) { try { _os . write ( _buffer , _ NUM , offset ) ; _offset = _ NUM ; return _ NUM ; } catch (  IOException e ) { throw new  H3 Exception Out ( e ) ; } }
protected  String generate Section Label (  Pie Dataset dataset ,  Comparable key ) {  String result = null ; if ( dataset != null ) {  Object [ ] items = create Item Array ( dataset , key ) ; result =  Message Format . format ( this . label Format , items ) ; } return result ; }
abstract protected void do Fade In ( ) ;
public void exec (  String description ,  String [ ] base Command ) throws  Backup Exception { exec ( description , base Command , null , null , null , _ BOOL , _ BOOL ) ; }
public static  Service Configuration create (  Input Stream in Stream ) throws  IOException ,  Illegal Argument Exception { try { check Not Null ( in Stream ) ;  Properties properties = new  Properties ( ) ; properties . load ( in Stream ) ; return ( create ( properties ) ) ; } finally { if ( in Stream != null ) { in Stream . close ( ) ; } } }
protected int [ ] split Sentence (  String sentence ) {  String [ ] w = sentence . split ( _ STR ) ; int [ ] words = new int [ w . length ] ; for ( int i = _ NUM ; i < w . length ; i ++ ) words [ i ] =  Vocabulary . id ( w [ i ] ) ; return words ; }
public static boolean is Failure (  List <  Action > actions ) { return actions . is Empty ( ) ; }
public void add To Dictionary (  String s ) { if ( ! get Auto Complete ( ) ) return ; if ( dict == null ) { set Up ( ) ; this . dict = create Default Dictionary ( ) ; } dict . add Entry ( s . trim ( ) ) ; }
public static int [ ] [ ] deep_copy ( int  M [ ] [ ] ) { int [ ] [ ]  C = new int [  M . length ] [ ] ; for ( int i = _ NUM ; i <  C . length ; i ++ ) {  C [ i ] =  Arrays . copy Of (  M [ i ] ,  M [ i ] . length ) ; } return  C ; }
public void wait For Message To Arrive ( ) {  LOG . info ( _ STR ) ; long start =  System . current Time Millis ( ) ; synchronized ( messages ) { try { while ( has Received Message ( ) ) { messages . wait ( _ NUM ) ; } } catch (  Interrupted Exception e ) {  LOG . info ( _ STR + e ) ; } } long end =  System . current Time Millis ( ) - start ;  LOG . info ( _ STR + end + _ STR ) ; }
public  Date (  String date ) {  String [ ] fields = date . split ( _ STR ) ; if ( fields . length != _ NUM ) { throw new  Illegal Argument Exception ( _ STR ) ; } month =  Integer . parse Int ( fields [ _ NUM ] ) ; day =  Integer . parse Int ( fields [ _ NUM ] ) ; year =  Integer . parse Int ( fields [ _ NUM ] ) ; if ( ! is Valid ( month , day , year ) ) throw new  Illegal Argument Exception ( _ STR ) ; }
public static void copy (  File src ,  File dst ) throws  IOException { if ( src . is Directory ( ) ) { ensure Directory Exists ( dst ) ;  String [ ] files List = src . list ( ) ; for (  String file : files List ) {  File src File = new  File ( src , file ) ;  File dest File = new  File ( dst , file ) ; copy ( src File , dest File ) ; } } else { copy File ( src , dst ) ; } }
public  Map Objects (  Pokemon Go api ) { this . api = api ; }
public void test Sorts According Number Of Attributes ( ) throws  Exception {  Xpp Dom dom1 =  Xpp Factory . build Dom ( _ STR ) ;  Xpp Dom dom2 =  Xpp Factory . build Dom ( _ STR ) ; assert Equals ( - _ NUM , comparator . compare ( dom1 , dom2 ) ) ; assert Equals ( _ STR , xpath . get ( ) ) ; assert Equals ( _ NUM , comparator . compare ( dom2 , dom1 ) ) ; assert Equals ( _ STR , xpath . get ( ) ) ; }
static void increment Keep Alive Count ( ) { synchronized ( keep Alive Lock ) { keep Alive Count ++ ; if ( reaper == null ) { reaper =  Access Controller . do Privileged ( new  New Thread Action ( new  Reaper ( ) , _ STR , _ BOOL ) ) ; reaper . start ( ) ; } if ( gc Latency Request == null ) { gc Latency Request =  GC . request Latency ( gc Interval ) ; } } }
static  Method Handle make Collect Arguments (  Method Handle target ,  Method Handle collector , int collect Arg Pos , boolean retain Original Args ) {  Method Type target Type = target . type ( ) ;  Method Type collector Type = collector . type ( ) ; int collect Arg Count = collector Type . parameter Count ( ) ;  Class < ? > collect Val Type = collector Type . return Type ( ) ; int collect Val Count = ( collect Val Type == void . class ? _ NUM : _ NUM ) ;  Method Type src Type = target Type . drop Parameter Types ( collect Arg Pos , collect Arg Pos + collect Val Count ) ; if ( ! retain Original Args ) { src Type = src Type . insert Parameter Types ( collect Arg Pos , collector Type . parameter List ( ) ) ; }  Method Type lambda Type = src Type . invoker Type ( ) ;  Name [ ] names = arguments ( _ NUM , lambda Type ) ; final int collect Name Pos = names . length - _ NUM ; final int target Name Pos = names . length - _ NUM ;  Name [ ] collector Args =  Arrays . copy Of Range ( names , _ NUM + collect Arg Pos , _ NUM + collect Arg Pos + collect Arg Count ) ; names [ collect Name Pos ] = new  Name ( collector , (  Object [ ] ) collector Args ) ;  Name [ ] target Args = new  Name [ target Type . parameter Count ( ) ] ; int input Arg Pos = _ NUM ; int target Arg Pos = _ NUM ; int chunk = collect Arg Pos ;  System . arraycopy ( names , input Arg Pos , target Args , target Arg Pos , chunk ) ; input Arg Pos += chunk ; target Arg Pos += chunk ; if ( collect Val Type != void . class ) { target Args [ target Arg Pos ++ ] = names [ collect Name Pos ] ; } chunk = collect Arg Count ; if ( retain Original Args ) {  System . arraycopy ( names , input Arg Pos , target Args , target Arg Pos , chunk ) ; target Arg Pos += chunk ; } input Arg Pos += chunk ; chunk = target Args . length - target Arg Pos ;  System . arraycopy ( names , input Arg Pos , target Args , target Arg Pos , chunk ) ; assert ( input Arg Pos + chunk == collect Name Pos ) ; names [ target Name Pos ] = new  Name ( target , (  Object [ ] ) target Args ) ;  Lambda Form form = new  Lambda Form ( _ STR , lambda Type . parameter Count ( ) , names ) ; return  Simple Method Handle . make ( src Type , form ) ; }
public  In Space Predicate (  Object ... values ) { _in Values = new  Hash Set <  Object > ( ) ; for (  Object value : values ) { _in Values . add ( value ) ; } }
protected  List <  String > prepare Sort Key Statements (  List <  Sort Key > sort Keys ) {  List <  String > keys = new  Array List <  String > ( ) ; for ( int i = _ NUM ; i < sort Keys . size ( ) ; i ++ ) {  Sort Key sort Key = sort Keys . get ( i ) ; keys . add ( explicit Mapping . get Db Column Name ( sort Key . get Field ( ) ) + ( sort Key . is Ascending Order ( ) ? _ STR : _ STR ) ) ; } return keys ; }
private  Optional <  Curator Framework > create Client (  String zookeeper Url ) { if (  String Utils . is Not Blank ( zookeeper Url ) ) {  Curator Framework client =  Configurations Utils . get Client ( zookeeper Url ) ; client . start ( ) ; return  Optional . of ( client ) ; } else { return  Optional . empty ( ) ; } }
public static  String add Cv Description (  String tool Tip ,  String cv Description ,  String mask ) {  String desc String = cv Description ;  String temp = get Mask Description ( mask ) ; if ( temp . length ( ) > _ NUM ) { desc String = desc String + _ STR + temp ; } if (  Pane Prog Frame . get Show Cv Numbers ( ) && ( desc String != null ) ) { if ( tool Tip == null ) { tool Tip = desc String ; } else { tool Tip = add Text HTMLaware ( tool Tip , _ STR + desc String + _ STR ) ; } } else if ( tool Tip == null ) { tool Tip = _ STR ; } return tool Tip ; }
private static void convert To HTML40 (  Attribute Set from ,  Mutable Attribute Set to ) {  Enumeration keys = from . get Attribute Names ( ) ;  String value = _ STR ; while ( keys . has More Elements ( ) ) {  Object key = keys . next Element ( ) ; if ( key instanceof  CSS .  Attribute ) { value = value + _ STR + key + _ STR + from . get Attribute ( key ) + _ STR ; } else { to . add Attribute ( key , from . get Attribute ( key ) ) ; } } if ( value . length ( ) > _ NUM ) { to . add Attribute (  HTML .  Attribute .  STYLE , value ) ; } }
public synchronized void close ( ) throws  IOException { if ( in == null ) return ; in . close ( ) ; in = null ; buf = null ; }
private static  SSLSocket Factory trust All Hosts (  Https URLConnection connection ) {  SSLSocket Factory old Factory = connection . get SSLSocket Factory ( ) ; try {  SSLContext sc =  SSLContext . get Instance ( _ STR ) ; sc . init ( null , trust All Certs , new java . security .  Secure Random ( ) ) ;  SSLSocket Factory new Factory = sc . get Socket Factory ( ) ; connection . set SSLSocket Factory ( new Factory ) ; } catch (  Exception e ) {  LOG . e (  LOG_ TAG , e . get Message ( ) , e ) ; } return old Factory ; }
public void update Amount ( ) { set Amt ( get Total Amount ( ) ) ; }
public void test Creation Unique ( ) {  Instances data ;  Array List <  Attribute > atts ;  String rel Name ; rel Name = _ STR ; atts = new  Array List <  Attribute > ( ) ; atts . add ( new  Attribute ( _ STR ) ) ; atts . add ( new  Attribute ( _ STR ) ) ; atts . add ( new  Attribute ( _ STR , _ STR ) ) ; atts . add ( new  Attribute ( _ STR , new  Array List <  String > (  Arrays . as List ( new  String [ ] { _ STR , _ STR , _ STR } ) ) ) ) ; atts . add ( new  Attribute ( _ STR , new  Array List <  String > (  Arrays . as List ( new  String [ ] { _ STR , _ STR } ) ) ) ) ; atts . add ( new  Attribute ( _ STR , (  Array List <  String > ) null ) ) ; data = new  Instances ( rel Name , atts , _ NUM ) ; assert Equals ( _ STR , rel Name , data . relation Name ( ) ) ; assert Equals ( _ STR , atts . size ( ) , data . num Attributes ( ) ) ; }
private void update Legends ( ) { if ( m_span == null ) { m_span = new  JPanel ( ) ; }  JPanel padder = new  JPanel ( ) ;  JPanel padd2 = new  JPanel ( ) ; m_span . set Preferred Size ( new  Dimension ( m_span . get Preferred Size ( ) . width , ( m_plots . size ( ) + _ NUM ) * _ NUM ) ) ; m_span . set Maximum Size ( new  Dimension ( m_span . get Preferred Size ( ) . width , ( m_plots . size ( ) + _ NUM ) * _ NUM ) ) ;  Legend Entry tmp ;  Grid Bag Layout gb = new  Grid Bag Layout ( ) ;  Grid Bag Layout gb2 = new  Grid Bag Layout ( ) ;  Grid Bag Constraints constraints = new  Grid Bag Constraints ( ) ; m_span . remove All ( ) ; padder . set Layout ( gb ) ; m_span . set Layout ( gb2 ) ; constraints . anchor =  Grid Bag Constraints .  CENTER ; constraints . gridx = _ NUM ; constraints . gridy = _ NUM ; constraints . weightx = _ NUM ; constraints . fill =  Grid Bag Constraints .  HORIZONTAL ; constraints . gridwidth = _ NUM ; constraints . gridheight = _ NUM ; constraints . insets = new  Insets ( _ NUM , _ NUM , _ NUM , _ NUM ) ; padder . add ( m_span , constraints ) ; constraints . gridx = _ NUM ; constraints . gridy = _ NUM ; constraints . weightx = _ NUM ; constraints . fill =  Grid Bag Constraints .  BOTH ; constraints . gridwidth = _ NUM ; constraints . gridheight = _ NUM ; constraints . weighty = _ NUM ; constraints . insets = new  Insets ( _ NUM , _ NUM , _ NUM , _ NUM ) ; padder . add ( padd2 , constraints ) ; constraints . weighty = _ NUM ; set Viewport View ( padder ) ; constraints . anchor =  Grid Bag Constraints .  CENTER ; constraints . gridx = _ NUM ; constraints . gridy = _ NUM ; constraints . weightx = _ NUM ; constraints . fill =  Grid Bag Constraints .  HORIZONTAL ; constraints . gridwidth = _ NUM ; constraints . gridheight = _ NUM ; constraints . weighty = _ NUM ; constraints . insets = new  Insets ( _ NUM , _ NUM , _ NUM , _ NUM ) ; for ( int i = _ NUM ; i < m_plots . size ( ) ; i ++ ) { tmp = new  Legend Entry ( m_plots . get ( i ) , i ) ; constraints . gridy = i ; m_span . add ( tmp , constraints ) ; } }
public static byte [ ] read Dex (  File file ) throws  IOException { return read Dex ( file . to Path ( ) ) ; }
public void run Commercial (  String stream , int length ) { if ( stream == null || stream . is Empty ( ) ) { commercial Result ( stream , _ STR ,  Twitch Api .  Request Result .  FAILED ) ; } else {  String channel = _ STR + stream ; if ( is Channel Open ( channel ) ) { g . print Line ( channel , _ STR + length + _ STR ) ; } else { g . print Line ( _ STR + length + _ STR + stream + _ STR ) ; } api . run Commercial ( stream , settings . get String ( _ STR ) , length ) ; } }
void generate While (  Tree .  While Statement that ) {  Tree .  While Clause while Clause = that . get While Clause ( ) ;  List <  Var Holder > vars = special Conditions And Block ( while Clause . get Condition List ( ) , while Clause . get Block ( ) , _ STR , _ BOOL ) ; for (  Var Holder v : vars ) { v . forget ( ) ; } }
public static double igamma ( double a , double x ) { double coef = (  Math . exp ( - x ) *  Math . pow ( x , a ) ) / gamma ( a ) ; double sum = _ NUM ; for ( int i = _ NUM ; i < _ NUM ; i ++ ) { sum += ( gamma ( a ) / gamma ( a + _ NUM + ( double ) i ) ) *  Math . pow ( x , ( double ) i ) ; } return ( coef * sum ) ; }
public void initialize Active Slots List (  String slots ) { if ( active Slots List == null ) { active Slots List = new  Array List <  String > ( ) ; } for (  String s : slots . split ( _ STR ) ) { active Slots List . add ( s ) ; } }
private static  String convert Action Type To Intent (  Raml Action Type action Type , boolean is Target Collection ) { switch ( action Type ) { case  DELETE : return _ STR ; case  GET : return _ STR ; case  POST : if ( is Target Collection ) { return _ STR ; } case  PUT : return _ STR ; case  PATCH : return _ STR ; default : return _ STR ; } }
public static  String hide ( final  String key ) { return is Hidden ( key ) ? key :  HIDDEN_ PREFIX . concat ( key ) ; }
private synchronized  IMqtt Token remove Mqtt Token (  Bundle data ) {  String activity Token = data . get String (  Mqtt Service Constants .  CALLBACK_ ACTIVITY_ TOKEN ) ; if ( activity Token != null ) { int token Number =  Integer . parse Int ( activity Token ) ;  IMqtt Token token = token Map . get ( token Number ) ; token Map . delete ( token Number ) ; return token ; } return null ; }
public static boolean is Explicit All Type (  String [ ] types ) { return types != null && types . length == _ NUM &&  ALL . equals ( types [ _ NUM ] ) ; }
public static double incomplete Beta Fraction2 ( double a , double b , double x ) { double xk , pk , pkm1 , pkm2 , qk , qkm1 , qkm2 ; double k1 , k2 , k3 , k4 , k5 , k6 , k7 , k8 ; double r , t , ans , z , thresh ; int n ; k1 = a ; k2 = b - _ NUM ; k3 = a ; k4 = a + _ NUM ; k5 = _ NUM ; k6 = a + b ; k7 = a + _ NUM ; ; k8 = a + _ NUM ; pkm2 = _ NUM ; qkm2 = _ NUM ; pkm1 = _ NUM ; qkm1 = _ NUM ; z = x / ( _ NUM - x ) ; ans = _ NUM ; r = _ NUM ; n = _ NUM ; thresh = _ NUM *  MACHEP ; do { xk = - ( z * k1 * k2 ) / ( k3 * k4 ) ; pk = pkm1 + pkm2 * xk ; qk = qkm1 + qkm2 * xk ; pkm2 = pkm1 ; pkm1 = pk ; qkm2 = qkm1 ; qkm1 = qk ; xk = ( z * k5 * k6 ) / ( k7 * k8 ) ; pk = pkm1 + pkm2 * xk ; qk = qkm1 + qkm2 * xk ; pkm2 = pkm1 ; pkm1 = pk ; qkm2 = qkm1 ; qkm1 = qk ; if ( qk != _ NUM ) { r = pk / qk ; } if ( r != _ NUM ) { t =  Math . abs ( ( ans - r ) / r ) ; ans = r ; } else { t = _ NUM ; } if ( t < thresh ) { return ans ; } k1 += _ NUM ; k2 -= _ NUM ; k3 += _ NUM ; k4 += _ NUM ; k5 += _ NUM ; k6 += _ NUM ; k7 += _ NUM ; k8 += _ NUM ; if ( (  Math . abs ( qk ) +  Math . abs ( pk ) ) > big ) { pkm2 *= biginv ; pkm1 *= biginv ; qkm2 *= biginv ; qkm1 *= biginv ; } if ( (  Math . abs ( qk ) < biginv ) || (  Math . abs ( pk ) < biginv ) ) { pkm2 *= big ; pkm1 *= big ; qkm2 *= big ; qkm1 *= big ; } } while ( ++ n < _ NUM ) ; return ans ; }
private  String read Until ( char [ ] delimiter , boolean return Text ) throws  IOException ,  Xml Pull Parser Exception { int start = position ;  String Builder result = null ; if ( return Text && text != null ) { result = new  String Builder ( ) ; result . append ( text ) ; } search : while ( _ BOOL ) { if ( position + delimiter . length > limit ) { if ( start < position && return Text ) { if ( result == null ) { result = new  String Builder ( ) ; } result . append ( buffer , start , position - start ) ; } if ( ! fill Buffer ( delimiter . length ) ) { check Relaxed (  UNEXPECTED_ EOF ) ; type =  COMMENT ; return null ; } start = position ; } for ( int i = _ NUM ; i < delimiter . length ; i ++ ) { if ( buffer [ position + i ] != delimiter [ i ] ) { position ++ ; continue search ; } } break ; } int end = position ; position += delimiter . length ; if ( ! return Text ) { return null ; } else if ( result == null ) { return string Pool . get ( buffer , start , end - start ) ; } else { result . append ( buffer , start , end - start ) ; return result . to String ( ) ; } }
private  Config ( ) { throw new  Assertion Error ( _ STR ) ; }
public boolean is Leaf ( ) { return children == null || children . is Empty ( ) ; }
public static void draw Shadow ( final  Rectangle2 D rect , final  Graphics2 D g2 ) {  Graphics2 D g2 S = (  Graphics2 D ) g2 . create ( ) ;  Rectangle2 D shadow = new  Rectangle2 D .  Double ( rect . get X ( ) + _ NUM , rect . get Y ( ) +  Process Drawer .  HEADER_ HEIGHT + _ NUM , rect . get Width ( ) , rect . get Height ( ) -  Process Drawer .  HEADER_ HEIGHT ) ;  General Path bottom = new  General Path ( ) ; bottom . move To ( shadow . get X ( ) , rect . get Max Y ( ) ) ; bottom . line To ( rect . get Max X ( ) , rect . get Max Y ( ) ) ; bottom . line To ( shadow . get Max X ( ) , shadow . get Max Y ( ) ) ; bottom . line To ( shadow . get Min X ( ) , shadow . get Max Y ( ) ) ; bottom . close Path ( ) ; g2 S . set Paint ( new  Gradient Paint ( ( float ) rect . get X ( ) , ( float ) rect . get Max Y ( ) ,  Color . gray , ( float ) rect . get X ( ) , ( float ) shadow . get Max Y ( ) ,  TRANSPARENT_ GRAY ) ) ; g2 S . fill ( bottom ) ;  General Path right = new  General Path ( ) ; right . move To ( rect . get Max X ( ) , shadow . get Min Y ( ) ) ; right . line To ( shadow . get Max X ( ) , shadow . get Min Y ( ) ) ; right . line To ( shadow . get Max X ( ) , shadow . get Max Y ( ) ) ; right . line To ( rect . get Max X ( ) , rect . get Max Y ( ) ) ; right . close Path ( ) ; g2 S . set Paint ( new  Gradient Paint ( ( float ) rect . get Max X ( ) , ( float ) shadow . get Y ( ) ,  Color . gray , ( float ) shadow . get Max X ( ) , ( float ) shadow . get Y ( ) ,  TRANSPARENT_ GRAY ) ) ; g2 S . fill ( right ) ; g2 S . dispose ( ) ; }
public static void interrupt ( final  Thread thread ) { if ( thread != null ) { thread . interrupt ( ) ; } }
private void write Object ( java . io .  Object Output Stream s ) throws java . io .  IOException { s . default Write Object ( ) ; s . write Int ( attrs . size ( ) ) ;  Enumeration <  Attribute > attr Enum = attrs . elements ( ) ; while ( attr Enum . has More Elements ( ) ) { s . write Object ( attr Enum . next Element ( ) ) ; } }
public static  Container east (  Component east ) { return  Container . enclose In ( new  Border Layout ( ) , east ,  Border Layout .  EAST ) ; }
public static  Object [ ] put All ( ) {  Region region = cache . get Region (  Region .  SEPARATOR +  REGION_ NAME ) ; assert Not Null ( region ) ; try {  Map map = new  Linked Hash Map ( ) ; map . put (  PUTALL_ KEY1 ,  PUTALL_ VALUE1 ) ; map . put (  PUTALL_ KEY2 ,  PUTALL_ VALUE2 ) ; map . put (  PUTALL_ KEY3 ,  PUTALL_ VALUE3 ) ; map . put (  PUTALL_ KEY4 ,  PUTALL_ VALUE4 ) ; map . put (  PUTALL_ KEY5 ,  PUTALL_ VALUE5 ) ; region . put All ( map , _ STR ) ;  Event ID [ ] evids = new  Event ID [ _ NUM ] ; evids [ _ NUM ] = put Allevent Id1 ; evids [ _ NUM ] = put Allevent Id2 ; evids [ _ NUM ] = put Allevent Id3 ; evids [ _ NUM ] = put Allevent Id4 ; evids [ _ NUM ] = put Allevent Id5 ; assert Not Null ( evids [ _ NUM ] ) ; assert Not Null ( evids [ _ NUM ] ) ; assert Not Null ( evids [ _ NUM ] ) ; assert Not Null ( evids [ _ NUM ] ) ; assert Not Null ( evids [ _ NUM ] ) ; return evids ; } catch (  Exception e ) { fail ( _ STR + e ) ; } return null ; }
public void load Layout (  File o File , boolean new Tab ) { load Layout ( o File , new Tab , _ BOOL ) ; }
public void track (  File file ,  Object marker ,  File Delete Strategy delete Strategy ) { if ( file == null ) { throw new  Null Pointer Exception ( _ STR ) ; } add Tracker ( file . get Path ( ) , marker , delete Strategy ) ; }
public boolean has Parameter (  String name ) { return _parameters . has Parameter ( name ) ; }
@  Override public long free Memory ( long window Id ) throws  IOException { long size = key Stream . data Size Up To Window ( window Id ) + value Stream . data Size Up To Window ( window Id ) ; windows For Free Memory . add ( window Id ) ; return size ; }
public static boolean is SQL99 Non Reserved Keyword (  String identifier ) { if ( identifier == null ) { throw new  Null Pointer Exception ( _ STR ) ; } return  Arrays . binary Search (  SQL99_ NON_ RESERVED , identifier . to Upper Case ( ) ) >= _ NUM ; }
@  Override public long handle Commit ( final long commit Time ) { if ( error != null ) throw new  Index Inconsistent Error ( error ) ; final  IRoot Block View view = journal . get Root Block View ( ) ; final  Byte Buffer rbv = view . as Read Only Buffer ( ) ; final  Byte Buffer bb =  Byte Buffer . allocate ( rbv . capacity ( ) ) ; for ( int i = _ NUM ; i < rbv . capacity ( ) ; i ++ ) { bb . put ( rbv . get ( ) ) ; } bb . flip ( ) ; return journal . write ( bb ) ; }
public boolean is Append Task Name ( ) { return append Task Name ; }
public static final  String to String (  String str ) { if ( str == null ) return _ STR ;  Byte Array Output Stream buffer = new  Byte Array Output Stream ( ) ; to Byte Array ( buffer , str ) ; return buffer . to String ( ) ; }
public static double max ( double [ ] data ) { double max =  Double .  Na N ; for ( int i = _ NUM ; i < data . length ; i ++ ) { if (  Double . is Na N ( data [ i ] ) ) continue ; if (  Double . is Na N ( max ) || data [ i ] > max ) max = data [ i ] ; } return max ; }
private static boolean is Start Element (  String line ) { int first = line . last Index Of ( _ STR ) ; int last = line . last Index Of ( _ STR ) ; if ( last < first ) { return _ BOOL ; } else { int first End = line . last Index Of ( _ STR ) ; int last End = line . last Index Of ( _ STR ) ; if ( ( first End != first ) && ( ( last End + _ NUM ) != last ) ) { return _ BOOL ; } } return _ BOOL ; }
long read Long ( ) throws  IOException { return ( ( ( long ) _is . read ( ) << _ NUM ) | ( ( long ) _is . read ( ) << _ NUM ) | ( ( long ) _is . read ( ) << _ NUM ) | ( ( long ) _is . read ( ) << _ NUM ) | ( ( long ) _is . read ( ) << _ NUM ) | ( ( long ) _is . read ( ) << _ NUM ) | ( ( long ) _is . read ( ) << _ NUM ) | ( ( long ) _is . read ( ) ) ) ; }
@  Override public  Instance remove ( int index ) { return m_ Instances . remove ( index ) ; }
protected static  String extract Access Key (  String s3uri ) { return s3uri . substring ( s3uri . index Of ( _ STR ) + _ NUM , s3uri . index Of ( _ STR , s3uri . index Of ( _ STR ) + _ NUM ) ) ; }
public boolean do Transaction (  DB db ,  Object threadstate ) throws  Workload Exception { boolean ret = _ BOOL ; long st =  System . nano Time ( ) ;  String op = operationchooser . next String ( ) ; if ( op . compare To ( _ STR ) == _ NUM ) { ret = do Transaction Read ( db ) ; } else if ( op . compare To ( _ STR ) == _ NUM ) { ret = do Transaction Update ( db ) ; } else if ( op . compare To ( _ STR ) == _ NUM ) { ret = do Transaction Insert ( db ) ; } else if ( op . compare To ( _ STR ) == _ NUM ) { ret = do Transaction Scan ( db ) ; } else { ret = do Transaction Read Modify Write ( db ) ; } long en =  System . nano Time ( ) ; _measurements . measure ( _operations . get ( op ) , ( int ) ( ( en - st ) / _ NUM ) ) ; if ( ret ) _measurements . report Return Code ( _operations . get ( op ) , - _ NUM ) ; else { _measurements . report Return Code ( _operations . get ( op ) , _ NUM ) ; } actualopcount . add And Get ( _ NUM ) ; return ret ; }
public static void copy Except (  Object src ,  Object dst , int old Size , int remove Index ) { if ( remove Index > _ NUM && old Size > _ NUM ) {  System . arraycopy ( src , _ NUM , dst , _ NUM , remove Index ) ; } if ( remove Index < old Size ) {  System . arraycopy ( src , remove Index + _ NUM , dst , remove Index , old Size - remove Index - _ NUM ) ; } }
public  Site Monitor (  String [ ] url List ) { site Url List = url List ; }
public  Optional <  Blaze Vertex > vertex ( final  String vertex Id ) { try ( final  Closeable Iterator <  Vertex > it = vertices ( vertex Id ) ) { final  Optional <  Blaze Vertex > v = it . has Next ( ) ?  Optional . of ( (  Blaze Vertex ) it . next ( ) ) :  Optional . empty ( ) ; if ( it . has Next ( ) ) { throw new  Illegal State Exception ( _ STR + vertex Id ) ; } return v ; } }
public static long add And Get (  Atomic Long current , long to Add ) { long u , r ; do { r = current . get ( ) ; if ( r ==  Long .  MAX_ VALUE ) { return  Long .  MAX_ VALUE ; } u = add Cap ( r , to Add ) ; } while ( ! current . compare And Set ( r , u ) ) ; return u ; }
private void start (  Http Servlet Request request ,  Http Servlet Response response ) throws  IOException {  String label = request . get Parameter ( _ STR ) ;  String detail = request . get Parameter ( _ STR ) ;  Mon Key key = get Mon Key ( label , detail ,  DEFAULT_ UNITS ) ; start Mon ( key ) ;  Print Writer out = response . get Writer ( ) ; out . println (  OK + _ STR + label ) ; }
public double norm ( ) { double sum = _ NUM ; for ( int i = _ NUM ; i < components . length ; i ++ ) sum += components [ i ] * components [ i ] ; return  Math . sqrt ( sum ) ; }
public static double  P_ Harmonic ( int  Y [ ] [ ] , int  Ypred [ ] [ ] ) { int all Missings = _ NUM ; int  N =  Y . length ; double loss = _ NUM ; for ( int i = _ NUM ; i <  N ; i ++ ) { if ( all Missing (  Y [ i ] ) ) { all Missings ++ ; continue ; } double cur Loss =  P_ Harmonic (  Y [ i ] ,  Ypred [ i ] ) ; if (  Double . is Na N ( cur Loss ) ) { all Missings ++ ; continue ; } loss += cur Loss ; } return loss / ( double ) (  N - all Missings ) ; }
public void write Entry (  CCache Output Stream cos ) throws  IOException { cos . write16 ( ad Type ) ; cos . write32 ( ad Data . length ) ; cos . write ( ad Data , _ NUM , ad Data . length ) ; }
public  Closeable Animated Bitmap (  List <  Bitmap > bitmaps ,  List <  Integer > durations ,  Resource Releaser <  Bitmap > resource Releaser ) {  Preconditions . check Not Null ( bitmaps ) ;  Preconditions . check State ( bitmaps . size ( ) >= _ NUM , _ STR ) ; m Bitmaps = new  Array List < > ( ) ; m Bitmap References = new  Array List < > ( ) ; for (  Bitmap bitmap : bitmaps ) { m Bitmap References . add (  Closeable Reference . of ( bitmap , resource Releaser ) ) ; m Bitmaps . add ( bitmap ) ; } m Durations =  Preconditions . check Not Null ( durations ) ;  Preconditions . check State ( m Durations . size ( ) == m Bitmaps . size ( ) , _ STR ) ; }
public static  String read Label File (  String entry Separator , boolean ensure Initial Boundary ,  String trfname ) throws  IOException {  Buffered Reader lab = new  Buffered Reader ( new  File Reader ( trfname ) ) ; try {  Xwaves Labelfile Reader xlds = new  Xwaves Labelfile Reader ( trfname ) ;  String result =  String Utils . join ( entry Separator , xlds . get Label Symbols ( ) ) ; if ( ensure Initial Boundary && result . char At ( _ NUM ) != _ STR ) { result = _ STR + entry Separator + result ; } return result ; } finally { lab . close ( ) ; } }
Converter Set add (  Converter converter ,  Converter [ ] removed ) {  Converter [ ] converters = i Converters ; int length = converters . length ; for ( int i = _ NUM ; i < length ; i ++ ) {  Converter existing = converters [ i ] ; if ( converter . equals ( existing ) ) { if ( removed != null ) { removed [ _ NUM ] = null ; } return this ; } if ( converter . get Supported Type ( ) == existing . get Supported Type ( ) ) {  Converter [ ] copy = new  Converter [ length ] ; for ( int j = _ NUM ; j < length ; j ++ ) { if ( j != i ) { copy [ j ] = converters [ j ] ; } else { copy [ j ] = converter ; } } if ( removed != null ) { removed [ _ NUM ] = existing ; } return new  Converter Set ( copy ) ; } }  Converter [ ] copy = new  Converter [ length + _ NUM ] ;  System . arraycopy ( converters , _ NUM , copy , _ NUM , length ) ; copy [ length ] = converter ; if ( removed != null ) { removed [ _ NUM ] = null ; } return new  Converter Set ( copy ) ; }
private void parse ( ) throws  SAXException {  XStream xstream = (  XStream ) properties . get (  CONFIGURED_ XSTREAM_ PROPERTY ) ; if ( xstream == null ) { xstream = new  XStream ( ) ; } final  List < ? > source = (  List < ? > ) properties . get (  SOURCE_ OBJECT_ LIST_ PROPERTY ) ; if ( source == null || source . is Empty ( ) ) { throw new  SAXException ( _ STR +  SOURCE_ OBJECT_ LIST_ PROPERTY + _ STR ) ; } try { start Document ( _ BOOL ) ; for ( final  Object name : source ) { xstream . marshal ( name , this ) ; } end Document ( _ BOOL ) ; } catch ( final  Stream Exception e ) { if ( e . get Cause ( ) instanceof  SAXException ) { throw (  SAXException ) e . get Cause ( ) ; } else { throw new  SAXException ( e ) ; } } }
private  Sorted Map <  Message Uid ,  Maildir Message Name > truncate Map (  Map <  Message Uid ,  Maildir Message Name > map ,  Message Uid from ,  Message Uid to ) {  Tree Map <  Message Uid ,  Maildir Message Name > sorted Map ; if ( map instanceof  Tree Map < ? , ? > ) sorted Map = (  Tree Map <  Message Uid ,  Maildir Message Name > ) map ; else sorted Map = new  Tree Map <  Message Uid ,  Maildir Message Name > ( map ) ; if ( to != null ) return sorted Map . sub Map ( from , to . next ( ) ) ; return sorted Map . tail Map ( from ) ; }
public void dump Index ( boolean show Bounds ) throws  IOException { byte ix Record [ ] = new byte [  SPATIAL_ INDEX_ RECORD_ LENGTH ] ; int rec Num = _ NUM ; if ( shp File Name == null ) { return ; }  Binary Buffered File ssx = new  Binary Buffered File ( ssx ( shp File Name ) ) ; ssx . seek ( _ NUM ) ; while ( _ BOOL ) { int result = ssx . read ( ix Record , _ NUM ,  SPATIAL_ INDEX_ RECORD_ LENGTH ) ; if ( result <= _ NUM ) { logger . info ( _ STR + rec Num + _ STR ) ; break ; } else { rec Num ++ ; int offset = read BEInt ( ix Record , _ NUM ) ; int length = read BEInt ( ix Record , _ NUM ) ; logger . info ( _ STR + rec Num + _ STR + offset + _ STR + length + ( show Bounds ? ( _ STR + read LEDouble ( ix Record , _ NUM ) + _ STR + read LEDouble ( ix Record , _ NUM ) + _ STR + read LEDouble ( ix Record , _ NUM ) + _ STR + read LEDouble ( ix Record , _ NUM ) ) : _ STR ) ) ; } } ssx . close ( ) ; }
private static boolean compare Param (  String jdiff Param ,  Type reflection Param Type ) { if ( jdiff Param == null ) { return _ BOOL ; }  String reflection Param = type To String ( reflection Param Type ) ; if ( jdiff Param . equals ( reflection Param ) ) { return _ BOOL ; } int jdiff Param End Offset = jdiff Param . index Of ( _ STR ) ; int reflection Param End Offset = reflection Param . index Of ( _ STR ) ; if ( jdiff Param End Offset != - _ NUM && reflection Param End Offset != - _ NUM ) { jdiff Param = jdiff Param . substring ( _ NUM , jdiff Param End Offset ) ; reflection Param = reflection Param . substring ( _ NUM , reflection Param End Offset ) ; return jdiff Param . equals ( reflection Param ) ; } return _ BOOL ; }
private void check Headings Hierarchy (  Elements elements ,  Test Solution Handler test Solution Handler ) { if ( elements . is Empty ( ) ) { test Solution Handler . add Test Solution (  Test Solution .  NOT_ APPLICABLE ) ; return ; }  Test Solution check Result =  Test Solution .  PASSED ;  Iterator <  Element > iter = elements . iterator ( ) ;  Element element = iter . next ( ) ; int index Of Reference = get Header Index ( element ) ; int current Index ; int previous Index = index Of Reference ;  Element element Of Reference = element ;  Element previous Element = element ; while ( iter . has Next ( ) ) { element = iter . next ( ) ; current Index = get Header Index ( element ) ; if ( current Index != - _ NUM ) { if ( current Index - previous Index >= _ NUM ) { check Result =  Test Solution .  FAILED ; add Source Code Remark (  Test Solution .  FAILED , element ,  HEADER_ NOT_ HIERARCHICALLY_ WELL_ DEFINED_ MSG , get Evidence Element (  PREVIOUS_ H_ TAG_ INDEX_ EE , get Evidence Element Msg ( previous Index , previous Element ) ) ) ; } else if ( current Index < index Of Reference ) { check Result =  Test Solution .  FAILED ; add Source Code Remark (  Test Solution .  FAILED , element ,  HEADER_ NOT_ HIERARCHICALLY_ WELL_ DEFINED_ MSG , get Evidence Element (  FIRST_ H_ TAG_ INDEX_ EE , get Evidence Element Msg ( index Of Reference , element Of Reference ) ) ) ; } previous Index = current Index ; previous Element = element ; } } test Solution Handler . add Test Solution ( check Result ) ; }
public void mouse Wheel Moved (  Mouse Wheel Event e ) { boolean accepted = check Modifiers ( e ) ; if ( accepted == _ BOOL ) {  Visualization Viewer < ? , ? > vv = (  Visualization Viewer < ? , ? > ) e . get Source ( ) ;  Point2 D mouse = e . get Point ( ) ;  Point2 D center = vv . get Center ( ) ; int amount = e . get Wheel Rotation ( ) ; if ( zoom At Mouse ) { if ( amount > _ NUM ) { scaler . scale ( vv , in , mouse ) ; } else if ( amount < _ NUM ) { scaler . scale ( vv , out , mouse ) ; } } else { if ( amount > _ NUM ) { scaler . scale ( vv , in , center ) ; } else if ( amount < _ NUM ) { scaler . scale ( vv , out , center ) ; } } e . consume ( ) ; vv . repaint ( ) ; } }
public  File create New Folder (  File containing Dir ) throws  IOException { if ( containing Dir == null ) { throw new  IOException ( _ STR ) ; }  File new Folder = create File Object ( containing Dir , new Folder String ) ; int i = _ NUM ; while ( new Folder . exists ( ) && i < _ NUM ) { new Folder = create File Object ( containing Dir ,  Message Format . format ( new Folder Next String , new  Integer ( i ) ) ) ; i ++ ; } if ( new Folder . exists ( ) ) { throw new  IOException ( _ STR + new Folder . get Absolute Path ( ) ) ; } else { new Folder . mkdirs ( ) ; } return new Folder ; }
private void handle Start Element (  XMLStream Reader parser ,  Set <  Node > children Found ,  Handler handler ,  Map <  String ,  Object > values ,  Stack <  Set <  String > > stack , boolean record Started ) throws  IOException ,  XMLStream Exception {  Node n = get Matching Node ( parser , child Nodes ) ;  Map <  String ,  Object > decends = new  Hash Map < > ( ) ; if ( n != null ) { children Found . add ( n ) ; n . parse ( parser , handler , values , stack , record Started ) ; return ; }  Node dn = this ; do { if ( dn . wild Card Nodes != null ) { n = get Matching Node ( parser , dn . wild Card Nodes ) ; if ( n != null ) { children Found . add ( n ) ; n . parse ( parser , handler , values , stack , record Started ) ; break ; } for (  Node nn : dn . wild Card Nodes ) decends . put ( nn . name , nn ) ; } dn = dn . wild Ancestor ; } while ( dn != null ) ; if ( n == null ) { int count = _ NUM ; while ( count != _ NUM ) { int token = parser . next ( ) ; if ( token ==  START_ ELEMENT ) {  Node nn = (  Node ) decends . get ( parser . get Local Name ( ) ) ; if ( nn != null ) { children Found . add ( nn ) ; nn . parse ( parser , handler , values , stack , record Started ) ; } else count ++ ; } else if ( token ==  END_ ELEMENT ) count -- ; } } }
public boolean equivalent (  IMFMarker Type other ) { if ( other == null ) { return _ BOOL ; } boolean result = _ BOOL ; result &= offset . equals ( other . get Offset ( ) ) ; result &= label . equivalent ( other . get Label ( ) ) ; return result ; }
public static  Discretization discretize ( double [ ] _data , double [ ] cutoffs ,  String variable Name ,  List <  String > categories ) { if ( cutoffs == null ) { throw new  Null Pointer Exception ( ) ; } for ( int i = _ NUM ; i < cutoffs . length - _ NUM ; i ++ ) { if ( ! ( cutoffs [ i ] <= cutoffs [ i + _ NUM ] ) ) { throw new  Null Pointer Exception ( _ STR ) ; } } if ( variable Name == null ) { throw new  Null Pointer Exception ( ) ; } int num Categories = cutoffs . length + _ NUM ; if ( categories != null && categories . size ( ) != num Categories ) { throw new  Illegal Argument Exception ( _ STR + _ STR + _ STR ) ; }  Discrete Variable variable ; if ( categories == null ) { variable = new  Discrete Variable ( variable Name , num Categories ) ; } else { variable = new  Discrete Variable ( variable Name , categories ) ; } int [ ] discrete Data = new int [ _data . length ] ; loop : for ( int i = _ NUM ; i < _data . length ; i ++ ) { if (  Double . is Na N ( _data [ i ] ) ) { discrete Data [ i ] =  Discrete Variable .  MISSING_ VALUE ; continue ; } for ( int j = _ NUM ; j < cutoffs . length ; j ++ ) { if ( _data [ i ] >  Double .  NEGATIVE_ INFINITY && _data [ i ] <  Double .  POSITIVE_ INFINITY && _data [ i ] < cutoffs [ j ] ) { discrete Data [ i ] = j ; continue loop ; } } discrete Data [ i ] = cutoffs . length ; } return new  Discretization ( variable , discrete Data ) ; }
public static  Array List <  Long > load Workspace Screens Db (  Context context ) { final  Content Resolver content Resolver = context . get Content Resolver ( ) ; final  Uri screens Uri =  Launcher Settings .  Workspace Screens .  CONTENT_ URI ; final  Cursor sc = content Resolver . query ( screens Uri , null , null , null ,  Launcher Settings .  Workspace Screens .  SCREEN_ RANK ) ;  Array List <  Long > screen Ids = new  Array List <  Long > ( ) ; try { final int id Index = sc . get Column Index Or Throw (  Launcher Settings .  Workspace Screens . _ ID ) ; while ( sc . move To Next ( ) ) { try { screen Ids . add ( sc . get Long ( id Index ) ) ; } catch (  Exception e ) {  Launcher . add Dump Log (  TAG , _ STR + _ STR + e , _ BOOL ) ; } } } finally { if ( sc != null ) { sc . close ( ) ; } } return screen Ids ; }
private boolean render Output (  Node node ,  Internal Context Adapter context ,  Writer writer ) throws  IOException ,  Method Invocation Exception ,  Resource Not Found Exception {  String arg = _ STR ; if ( node == null ) { rsvc . error ( _ STR ) ; return _ BOOL ; }  Object value = node . value ( context ) ; if ( value == null ) { rsvc . error ( _ STR ) ; return _ BOOL ; } arg = value . to String ( ) ;  Resource resource = null ; try { resource = rsvc . get Content ( arg , get Input Encoding ( context ) ) ; } catch (  Resource Not Found Exception rnfe ) { rsvc . error ( _ STR + arg + _ STR + context . get Current Template Name ( ) + _ STR + get Line ( ) + _ STR + get Column ( ) + _ STR ) ; throw rnfe ; } catch (  Exception e ) { rsvc . error ( _ STR + arg + _ STR + context . get Current Template Name ( ) + _ STR + get Line ( ) + _ STR + get Column ( ) + _ STR + e ) ; } if ( resource == null ) return _ BOOL ; writer . write ( (  String ) resource . get Data ( ) ) ; return _ BOOL ; }
protected  String e (  String s ) throws  Exception { return fmt . format ( parser . parse ( s , null ) ) ; }
public static boolean equals ( boolean [ ] field1 , boolean [ ] field2 ) { if ( field1 == null || field1 . length == _ NUM ) { return field2 == null || field2 . length == _ NUM ; } else { return  Arrays . equals ( field1 , field2 ) ; } }
public  Matrix4 multiply By Scale ( double x Scale , double y Scale , double z Scale ) { double [ ] m = this . m ; m [ _ NUM ] *= x Scale ; m [ _ NUM ] *= x Scale ; m [ _ NUM ] *= x Scale ; m [ _ NUM ] *= x Scale ; m [ _ NUM ] *= y Scale ; m [ _ NUM ] *= y Scale ; m [ _ NUM ] *= y Scale ; m [ _ NUM ] *= y Scale ; m [ _ NUM ] *= z Scale ; m [ _ NUM ] *= z Scale ; m [ _ NUM ] *= z Scale ; m [ _ NUM ] *= z Scale ; return this ; }
public void change State ( ) { linked = ! linked ; link = linked ? linked Im Ic . get Image ( ) : unlinked Im Ic . get Image ( ) ; repaint ( ) ; }
public static  Geometry buffer By Segments (  Geometry g , double distance ) {  Geometry segs =  Line Handling Functions . extract Segments ( g ) ; double pos Dist =  Math . abs ( distance ) ;  Geometry seg Buf = buffer By Components ( segs , pos Dist ) ; if ( distance < _ NUM ) return g . difference ( seg Buf ) ; return g . union ( seg Buf ) ; }
public void record End Time ( ) { int ms Diff = ( int ) (  System . current Time Millis ( ) - _current Request Start Time . get ( ) ) ; _log . info ( _ STR , ms Diff ) ; update Or Reset Req Rsp Avg Lst Hr ( update Or Reset Req Rsp Avg Lst Min ( ms Diff , _ BOOL ) , _ BOOL ) ; update Min Max Req Rsp Ms ( ms Diff ) ; if ( ms Diff >=  SUSPISCIOUS_ RSP_ TIME_ MS ) { _alert Log . warn (  Message Format . format ( _ STR , ms Diff ) ) ; } _current Request Start Time . remove ( ) ; }
private boolean is Accessible User To Kibana (  Set <  String > filters ) { if ( filters . contains ( _ STR ) ) { return _ BOOL ; } return _ BOOL ; }
public boolean clear ( ) { try { list . clear ( ) ; fire Table Data Changed ( ) ; } catch (  Exception e ) { return _ BOOL ; } return _ BOOL ; }
public boolean load (  File fi ) throws  Jmri Configure Xml Exception { return load ( fi , _ BOOL ) ; }
public void test Bug66947 ( ) throws  Exception {  Connection con = null ; try {  Properties props = new  Properties ( ) ; props . set Property ( _ STR , _ STR ) ; props . set Property ( _ STR , _ STR ) ; props . set Property ( _ STR , _ STR ) ; con = get Connection With Props ( props ) ;  Prepared Statement ps1_1 ;  Prepared Statement ps1_2 ;  String query = _ STR ; ps1_1 = con . prepare Statement ( query ) ; ps1_1 . execute ( ) ; ps1_1 . close ( ) ; ps1_2 = con . prepare Statement ( query ) ; assert Same ( _ STR , ps1_1 , ps1_2 ) ; ps1_2 . execute ( ) ; ps1_2 . close ( ) ; ps1_2 . close ( ) ; ps1_1 = con . prepare Statement ( query ) ; assert Not Same ( _ STR , ps1_2 , ps1_1 ) ; ps1_1 . execute ( ) ; ps1_1 . close ( ) ; ps1_1 . close ( ) ;  Prepared Statement ps2_1 ;  Prepared Statement ps2_2 ;  Prepared Statement ps3_1 ;  Prepared Statement ps3_2 ; ps1_1 = con . prepare Statement ( _ STR ) ; ps1_1 . execute ( ) ; ps1_1 . close ( ) ; ps2_1 = con . prepare Statement ( _ STR ) ; ps2_1 . execute ( ) ; ps2_1 . close ( ) ; ps3_1 = con . prepare Statement ( _ STR ) ; ps3_1 . execute ( ) ; ps3_1 . close ( ) ; ps1_2 = con . prepare Statement ( _ STR ) ; assert Not Same ( _ STR , ps1_1 , ps1_2 ) ; ps2_2 = con . prepare Statement ( _ STR ) ; assert Same ( _ STR , ps2_1 , ps2_2 ) ; ps3_2 = con . prepare Statement ( _ STR ) ; assert Same ( _ STR , ps3_1 , ps3_2 ) ; } finally { if ( con != null ) { con . close ( ) ; } } }
public void add Request Property (  String key ,  String value ) { if ( connected ) throw new  Illegal State Exception ( _ STR ) ; if ( key == null ) throw new  Null Pointer Exception ( _ STR ) ; if ( requests == null ) requests = new  Message Header ( ) ; requests . add ( key , value ) ; }
Server Member update (  Address client Address ,  Instant time ) { if ( client Address != null ) { this . client Address = client Address ; if ( time . is After ( updated ) ) { this . updated =  Assert . not Null ( time , _ STR ) ; } } return this ; }
public static boolean is Org Level Only ( int  AD_ Client_ ID , int  AD_ Table_ ID ) {  Boolean share = is Shared (  AD_ Client_ ID ,  AD_ Table_ ID ) ; if ( share != null ) return ! share . boolean Value ( ) ; return _ BOOL ; }
@  Override public void action Performed (  Action Event event ) {  String command = event . get Action Command ( ) ; if ( command . equals ( _ STR ) ) { attempt Modify Background Paint ( ) ; } }
public byte [ ] serialize To Buffer (  Object o ) throws  IOException {  Byte Array Output Stream buf Out = new  Byte Array Output Stream ( ) ; try { serialize ( buf Out , o ) ; buf Out . flush ( ) ; return buf Out . to Byte Array ( ) ; } finally { buf Out . close ( ) ; } }
Module Pointer resolve (  String mod Name ) { return (  Module Pointer ) context . get ( mod Name ) ; }
public  Nar Class Loader ( final  File nar Working Directory ) throws  Class Not Found Exception ,  IOException { super ( new  URL [ _ NUM ] ) ; this . nar Working Directory = nar Working Directory ; update Classpath ( nar Working Directory ) ; }
public static  Type Binding [ ] substitute (  Substitution substitution ,  Type Binding [ ] original Types ) { if ( original Types == null ) return null ;  Type Binding [ ] substituted Types = original Types ; for ( int i = _ NUM , length = original Types . length ; i < length ; i ++ ) {  Type Binding original Type = original Types [ i ] ;  Type Binding substituted Parameter = substitute ( substitution , original Type ) ; if ( substituted Parameter != original Type ) { if ( substituted Types == original Types ) {  System . arraycopy ( original Types , _ NUM , substituted Types = new  Type Binding [ length ] , _ NUM , i ) ; } substituted Types [ i ] = substituted Parameter ; } else if ( substituted Types != original Types ) { substituted Types [ i ] = original Type ; } } return substituted Types ; }
private boolean check If Scrolling ( float [ ] last Points ,  Motion Event ev ) { float [ ] point = new float [ _ NUM ] ; point [ _ NUM ] = ev . get Raw X ( ) ; point [ _ NUM ] = ev . get Raw Y ( ) ; float delta = get Distance ( last Points , point ) ; return  Math . abs ( delta ) > m Slop ; }
public void test Merge One Filter Into Document With Same Filter ( ) throws  Exception {  String src Xml = _ STR + _ STR + _ STR + _ STR + _ STR + _ STR ;  Web Xml src Web Xml =  Web Xml Io . parse Web Xml ( new  Byte Array Input Stream ( src Xml . get Bytes ( _ STR ) ) , null ) ;  Web Xml merge Web Xml =  Web Xml Io . parse Web Xml ( new  Byte Array Input Stream ( src Xml . get Bytes ( _ STR ) ) , null ) ;  Web Xml Merger merger = new  Web Xml Merger ( src Web Xml ) ; merger . merge Filters ( merge Web Xml ) ; assert True (  Web Xml Utils . has Filter ( src Web Xml , _ STR ) ) ; }
public  Edge (  S src ,  Symbol symbol ,  S dest ) { this . src = src ; this . symbol = symbol ; this . dest = dest ; this . src Item = src . get First Item ( ) ; this . hash Cache = calc Hash Code ( ) ; }
public void push ( final  Type value ) { if ( value == null ) { mv . visit Insn (  Opcodes .  ACONST_ NULL ) ; } else { switch ( value . get Sort ( ) ) { case  Type .  BOOLEAN : mv . visit Field Insn (  Opcodes .  GETSTATIC , _ STR , _ STR ,  CLDESC ) ; break ; case  Type .  CHAR : mv . visit Field Insn (  Opcodes .  GETSTATIC , _ STR , _ STR ,  CLDESC ) ; break ; case  Type .  BYTE : mv . visit Field Insn (  Opcodes .  GETSTATIC , _ STR , _ STR ,  CLDESC ) ; break ; case  Type .  SHORT : mv . visit Field Insn (  Opcodes .  GETSTATIC , _ STR , _ STR ,  CLDESC ) ; break ; case  Type .  INT : mv . visit Field Insn (  Opcodes .  GETSTATIC , _ STR , _ STR ,  CLDESC ) ; break ; case  Type .  FLOAT : mv . visit Field Insn (  Opcodes .  GETSTATIC , _ STR , _ STR ,  CLDESC ) ; break ; case  Type .  LONG : mv . visit Field Insn (  Opcodes .  GETSTATIC , _ STR , _ STR ,  CLDESC ) ; break ; case  Type .  DOUBLE : mv . visit Field Insn (  Opcodes .  GETSTATIC , _ STR , _ STR ,  CLDESC ) ; break ; default : mv . visit Ldc Insn ( value ) ; } } }
public  Extended Text Label create Extended (  Font font ,  Core Metrics lm ,  Decoration decorator , int start , int limit ) { if ( start >= limit || start < line Start || limit > line Limit ) { throw new  Illegal Argument Exception ( _ STR + start + _ STR + limit ) ; } int level = line Bidi == null ? _ NUM : line Bidi . get Level At ( start - line Start ) ; int linedir = ( line Bidi == null || line Bidi . base Is Left To Right ( ) ) ? _ NUM : _ NUM ; int layout Flags = flags & ~ _ NUM ; if ( ( level & _ NUM ) != _ NUM ) layout Flags |= _ NUM ; if ( ( linedir & _ NUM ) != _ NUM ) layout Flags |= _ NUM ;  Text Source source = new  Standard Text Source ( text , start , limit - start , line Start , line Limit - line Start , level , layout Flags , font , frc , lm ) ; return new  Extended Text Source Label ( source , decorator ) ; }
public static  String right Pad (  String s , int min Length , char filling ) { int ln = s . length ( ) ; if ( min Length <= ln ) { return s ; }  String Builder res = new  String Builder ( min Length ) ; res . append ( s ) ; int dif = min Length - ln ; for ( int i = _ NUM ; i < dif ; i ++ ) { res . append ( filling ) ; } return res . to String ( ) ; }
private static  String read Quoted Descriptor ( final  Substring Reader reader , final boolean allow Compat Chars ) throws  Decode Exception { int length = _ NUM ; reader . skip Whitespaces ( ) ; try { char c = reader . read ( ) ; if ( c != _ STR ) { throw  Decode Exception . error (  ERR_ ATTR_ SYNTAX_ EXPECTED_ QUOTE_ AT_ POS1 . get ( reader . pos ( ) - _ NUM , c ) ) ; } reader . mark ( ) ; while ( ( c = reader . read ( ) ) != _ STR ) { if ( length == _ NUM && ! is Alpha ( c ) ) { throw  Decode Exception . error (  ERR_ ATTR_ SYNTAX_ ILLEGAL_ CHAR_ IN_ STRING_ OID1 . get ( c , reader . pos ( ) - _ NUM ) ) ; } if ( ! is Key Char ( c , allow Compat Chars ) ) { throw  Decode Exception . error (  ERR_ ATTR_ SYNTAX_ ILLEGAL_ CHAR_ IN_ STRING_ OID1 . get ( c , reader . pos ( ) - _ NUM ) ) ; } length ++ ; } reader . reset ( ) ; final  String descr = reader . read ( length ) ; reader . read ( ) ; return descr ; } catch ( final  String Index Out Of Bounds Exception e ) { throw  Decode Exception . error (  ERR_ ATTR_ SYNTAX_ TRUNCATED_ VALUE1 . get ( ) ) ; } }
public  String to CSV ( ) {  String Builder builder = new  String Builder ( ) ; builder . append ( _ STR ) ; builder . append ( _ STR ) ; for (  T predicted : classes ) { builder . append (  String . format ( _ STR , predicted ) ) ; } builder . append ( _ STR ) ;  String first Column Label = _ STR ; for (  T actual : classes ) { builder . append ( first Column Label ) ; first Column Label = _ STR ; builder . append (  String . format ( _ STR , actual ) ) ; for (  T predicted : classes ) { builder . append ( get Count ( actual , predicted ) ) ; builder . append ( _ STR ) ; } builder . append ( get Actual Total ( actual ) ) ; builder . append ( _ STR ) ; } builder . append ( _ STR ) ; for (  T predicted : classes ) { builder . append ( get Predicted Total ( predicted ) ) ; builder . append ( _ STR ) ; } builder . append ( _ STR ) ; return builder . to String ( ) ; }
public  Object assign Id Value (  Object data ,  Number val ,  Object Cache object Cache ) throws  SQLException {  Object id Val = data Persister . convert Id Number ( val ) ; if ( id Val == null ) { throw new  SQLException ( _ STR + data Persister + _ STR + this ) ; } else { assign Field ( data , id Val , _ BOOL , object Cache ) ; return id Val ; } }
public final boolean is Open ( ) { return closed . get ( ) == _ BOOL ; }
public static  Map <  String ,  Object > perform Find List (  Dispatch Context dctx ,  Map <  String ,  Object > context ) {  Integer view Size = (  Integer ) context . get ( _ STR ) ; if ( view Size == null ) view Size =  Integer . value Of ( _ NUM ) ; context . put ( _ STR , view Size ) ;  Integer view Index = (  Integer ) context . get ( _ STR ) ; if ( view Index == null ) view Index =  Integer . value Of ( _ NUM ) ; context . put ( _ STR , view Index ) ;  Map <  String ,  Object > result = perform Find ( dctx , context ) ; int start = view Index . int Value ( ) * view Size . int Value ( ) ;  List <  Generic Value > list = null ;  Integer list Size = _ NUM ; try {  Entity List Iterator it = (  Entity List Iterator ) result . get ( _ STR ) ; list = it . get Partial List ( start + _ NUM , view Size ) ; list Size = it . get Results Size After Partial List ( ) ; it . close ( ) ; } catch (  Exception e ) {  Debug . log Info ( _ STR + e , module ) ; } result . put ( _ STR , list Size ) ; result . put ( _ STR , list ) ; result . remove ( _ STR ) ; return result ; }
public static  String soap To String (  SOAPElement element ) { return dom To String ( element . get Owner Document ( ) ) ; }
@  Override public void close ( ) throws  IOException { try { out . close ( ) ; } finally { lock File . delete ( ) ; } }
@  Override public boolean equals (  Object x ,  Object y ) throws  Hibernate Exception { if ( x == null ) { return y == null ; } return x . equals ( y ) ; }
@  Override public final void write Boolean ( boolean v ) throws  IOException { dis . write Boolean ( v ) ; }
public void train (  Set <  String > s File Names ) {  Iterator <  String > i File = s File Names . iterator ( ) ; while ( i File . has Next ( ) ) {  String s Text = utils . load File To String ( i File . next ( ) ) ; train ( s Text ) ; } }
public void test Find Spring Open Ldap With Limit ( ) {  Ldap Proxy proxy = get Ldap Open Ldap ( ) ;  List result = null ; int limit = _ NUM ; try { result = proxy . find ( get Ldap Search VO ( _ STR , limit , _ STR , _ STR , null ,  Ldap Scope Constants .  SCOPE_ SUBTREE ) ) ; } catch (  Exception e ) { } assert Not Null ( result ) ; if ( result != null ) { assert Equals ( limit , result . size ( ) ) ; } }
public  Printf Format (  String fmt Arg ) throws  Illegal Argument Exception { this (  Locale . get Default ( ) , fmt Arg ) ; }
static double svd_pythag ( double a , double b ) { double p , r , s , t , u , temp ; p = svd_dmax (  Math . abs ( a ) ,  Math . abs ( b ) ) ; if ( p != _ NUM ) { temp = svd_dmin (  Math . abs ( a ) ,  Math . abs ( b ) ) / p ; r = temp * temp ; t = _ NUM + r ; while ( t != _ NUM ) { s = r / t ; u = _ NUM + _ NUM * s ; p *= u ; temp = s / u ; r *= temp * temp ; t = _ NUM + r ; } } return p ; }
public static void write Fix Int32 ( final  Output Stream output , final int val ) throws  IOException { output . write ( ( val > > > _ NUM ) & _ NUM ) ; output . write ( ( val > > > _ NUM ) & _ NUM ) ; output . write ( ( val > > > _ NUM ) & _ NUM ) ; output . write ( val & _ NUM ) ; }
public static void queue Cube Load (  ICubic World world ,  Cube IO loader ,  Cube Provider Server cache , int x , int y , int z ,  Consumer <  Cube > runnable ) {  Queued Cube key = new  Queued Cube ( x , y , z , world ) ;  Async Cube IOProvider task = cube Tasks . get ( key ) ; if ( task == null ) { task = new  Async Cube IOProvider ( key , loader ) ; task . add Callback ( runnable ) ; cube Tasks . put ( key , task ) ; pool . execute ( task ) ; } else { task . add Callback ( runnable ) ; }  Column loaded Column ; if ( ( loaded Column = cache . get Loaded Column ( x , z ) ) == null ) { cache . async Get Column ( x , z ,  IProvider Extras .  Requirement .  LIGHT , null ) ; } else { task . set Column ( loaded Column ) ; } }
public static boolean is Object Available Now ( final boolean enabled , final  Date available From , final  Date available To , final  Date now ) { if ( ! enabled ) { return _ BOOL ; } if ( available From != null && now . before ( available From ) ) { return _ BOOL ; } if ( available To != null && now . after ( available To ) ) { return _ BOOL ; } return _ BOOL ; }
public void button Clicked (  Action Event e ) ;
private long load Largest Message Id ( ) {  Release Message release Message = release Message Repository . find Top By Order By Id Desc ( ) ; return release Message == null ? _ NUM : release Message . get Id ( ) ; }
public void remove Change Listener (  Change Listener l ) { if ( listeners == null ) return ; listeners . remove ( l ) ; }
public static  Request Log dump ( ) {  Request Log current =  RLOG . get ( ) ;  Request Log copy = new  Request Log ( current ) ; current . clear ( ) ;  RLOG . remove ( ) ; return copy ; }
public static  String url Decode (  String str ) { try { return (  URLDecoder . decode ( str , _ STR ) ) ; } catch (  Exception e ) { return ( _ STR ) ; } }
public void test Then Accept Both_exceptional Completion ( ) throws  Throwable { for (  Execution Mode m :  Execution Mode . values ( ) ) for ( boolean f First : new boolean [ ] { _ BOOL , _ BOOL } ) for ( boolean fail First : new boolean [ ] { _ BOOL , _ BOOL } ) for (  Integer v1 : new  Integer [ ] { _ NUM , null } ) { final  Completable Future <  Integer > f = new  Completable Future < > ( ) ; final  Completable Future <  Integer > g = new  Completable Future < > ( ) ; final  CFException ex = new  CFException ( ) ; final  Subtract Action r1 = new  Subtract Action ( m ) ; final  Subtract Action r2 = new  Subtract Action ( m ) ; final  Subtract Action r3 = new  Subtract Action ( m ) ; final  Completable Future <  Integer > fst = f First ? f : g ; final  Completable Future <  Integer > snd = ! f First ? f : g ; final  Callable <  Boolean > complete1 = fail First ? null : null ; final  Callable <  Boolean > complete2 = fail First ? null : null ; final  Completable Future <  Void > h1 = m . then Accept Both ( f , g , r1 ) ; assert True ( complete1 . call ( ) ) ; final  Completable Future <  Void > h2 = m . then Accept Both ( f , g , r2 ) ; check Incomplete ( h1 ) ; check Incomplete ( h2 ) ; assert True ( complete2 . call ( ) ) ; final  Completable Future <  Void > h3 = m . then Accept Both ( f , g , r3 ) ; check Completed With Wrapped Exception ( h1 , ex ) ; check Completed With Wrapped Exception ( h2 , ex ) ; check Completed With Wrapped Exception ( h3 , ex ) ; r1 . assert Not Invoked ( ) ; r2 . assert Not Invoked ( ) ; r3 . assert Not Invoked ( ) ; check Completed Normally ( fail First ? snd : fst , v1 ) ; check Completed Exceptionally ( fail First ? fst : snd , ex ) ; } }
protected  Default List Model string To Model (  String s ) {  Default List Model result ;  String tmp Str ; int i ; boolean quote ;  String [ ] find ;  String [ ] replace ; int index ; result = new  Default List Model ( ) ; find = new  String [ ] { _ STR , _ STR , _ STR , _ STR } ; replace = new  String [ ] { _ STR , _ STR , _ STR , _ STR } ; for ( i = _ NUM ; i < find . length ; i ++ ) { tmp Str = _ STR ; while ( s . length ( ) > _ NUM ) { index = s . index Of ( find [ i ] ) ; if ( index > - _ NUM ) { tmp Str += s . substring ( _ NUM , index ) + replace [ i ] ; s = s . substring ( index + _ NUM ) ; } else { tmp Str += s ; s = _ STR ; } } s = tmp Str ; } quote = _ BOOL ; tmp Str = _ STR ; for ( i = _ NUM ; i < s . length ( ) ; i ++ ) { if ( s . char At ( i ) == _ STR ) { quote = ! quote ; tmp Str += _ STR + s . char At ( i ) ; } else if ( s . char At ( i ) == _ STR ) { if ( quote ) { tmp Str += _ STR + s . char At ( i ) ; } else { if ( tmp Str . starts With ( _ STR ) ) { tmp Str = tmp Str . substring ( _ NUM , tmp Str . length ( ) - _ NUM ) ; } result . add Element ( tmp Str ) ; tmp Str = _ STR ; } } else { tmp Str += _ STR + s . char At ( i ) ; } } if ( ! tmp Str . equals ( _ STR ) ) { if ( tmp Str . starts With ( _ STR ) ) { tmp Str = tmp Str . substring ( _ NUM , tmp Str . length ( ) - _ NUM ) ; } result . add Element ( tmp Str ) ; } return result ; }
public void test Get Tables ( ) throws  Exception {  Database Meta Data dmd = con . get Meta Data ( ) ;  Result Set rs = dmd . get Tables ( null , null , null , null ) ; assert Not Null ( rs ) ; rs . close ( ) ; }
public void add All (  Collection < ? extends  T > collection ) { if ( m Event Delegate != null ) m Event Delegate . add Data ( collection == null ? _ NUM : collection . size ( ) ) ; if ( collection != null && collection . size ( ) != _ NUM ) { synchronized ( m Lock ) { m Objects . add All ( collection ) ; } } if ( m Notify On Change ) notify Data Set Changed ( ) ; }
public static void reset Current File List (  String log Name ) { current File List . remove (  PREFIX + log Name ) ; }
@  Override public abstract  List <  JTool Bar > create Tool Bars (  Application a , @  Nullable  View p ) ;
public static synchronized  Result Set execute Query (  String sql Statement ) { logger . trace (  String . format ( _ STR , sql Statement ) ) ;  Result Set  R = null ; final  Statement  S = get Statement ( ) ; if (  S == null ) { logger . error ( _ STR ) ; return null ; } try {  R =  S . execute Query ( sql Statement ) ; logger . trace ( _ STR + ( null ==  R ) ) ; return  R ; } catch (  Throwable t ) { surface Throwable (  String . format ( _ STR , sql Statement ) , t ) ; cleanup (  S ,  R ) ; } return null ; }
public void write ( byte [ ] buf ) throws  IOException { output . write ( buf ) ; bytes Written += buf . length ; }
public static  String url Encode ( @  Nullable  String s ) { if ( s == null ) { return _ STR ; } try { return  URLEncoder . encode ( s , _ STR ) ; } catch (  Unsupported Encoding Exception e ) { throw new  Assertion Error ( _ STR ) ; } }
protected static boolean check Raw Modules Tables ( final  CConnection connection , final  String database Name , final int raw Module Id ) {  Preconditions . check Not Null ( connection , _ STR ) ;  Preconditions . check Not Null ( database Name , _ STR ) ;  Preconditions . check Argument ( raw Module Id > _ NUM , _ STR , raw Module Id ) ; final  Immutable Set <  String > raw Table Names =  Immutable Set . of (  String . format (  CTable Names .  RAW_ ADDRESS_ COMMENTS_ TABLE , raw Module Id ) ,  String . format (  CTable Names .  RAW_ ADDRESS_ REFERENCES_ TABLE , raw Module Id ) ,  String . format (  CTable Names .  RAW_ BASE_ TYPES , raw Module Id ) ,  String . format (  CTable Names .  RAW_ BASIC_ BLOCK_ INSTRUCTIONS_ TABLE , raw Module Id ) ,  String . format (  CTable Names .  RAW_ BASIC_ BLOCKS_ TABLE , raw Module Id ) ,  String . format (  CTable Names .  RAW_ CALLGRAPH_ TABLE , raw Module Id ) ,  String . format (  CTable Names .  RAW_ CONTROL_ FLOW_ GRAPHS_ TABLE , raw Module Id ) ,  String . format (  CTable Names .  RAW_ EXPRESSION_ NODES_ TABLE , raw Module Id ) ,  String . format (  CTable Names .  RAW_ EXPRESSION_ SUBSTITUTIONS_ TABLE , raw Module Id ) ,  String . format (  CTable Names .  RAW_ EXPRESSION_ TREE_ NODES_ TABLE , raw Module Id ) ,  String . format (  CTable Names .  RAW_ EXPRESSION_ TREES_ TABLE , raw Module Id ) ,  String . format (  CTable Names .  RAW_ EXPRESSION_ TYPES_ TABLE , raw Module Id ) ,  String . format (  CTable Names .  RAW_ FUNCTIONS_ TABLE , raw Module Id ) ,  String . format (  CTable Names .  RAW_ INSTRUCTIONS_ TABLE , raw Module Id ) ,  String . format (  CTable Names .  RAW_ OPERANDS_ TABLE , raw Module Id ) ,  String . format (  CTable Names .  RAW_ SECTIONS , raw Module Id ) ,  String . format (  CTable Names .  RAW_ EXPRESSION_ TYPE_ INSTANCES , raw Module Id ) ,  String . format (  CTable Names .  RAW_ TYPE_ INSTACES , raw Module Id ) ,  String . format (  CTable Names .  RAW_ TYPES , raw Module Id ) ) ; final  Pair <  CConnection ,  String > cache Key = new  Pair < > ( connection , database Name ) ; if (  Postgre SQLDatabase Functions . query Cache ( cache Key , raw Table Names ) ) { return _ BOOL ; } else { if ( !  Postgre SQLDatabase Functions . fill Cache ( cache Key ) ) { return _ BOOL ; } return  Postgre SQLDatabase Functions . query Cache ( cache Key , raw Table Names ) ; } }
public  Currency read (  String symbol ) { return  Currency . get Instance ( symbol ) ; }
public static float parse Float (  String s ) { if (  POSITIVE_ INFINITY . equals ( s ) ) { return  Float .  POSITIVE_ INFINITY ; } else if (  NEGATIVE_ INFINITY . equals ( s ) ) { return  Float .  NEGATIVE_ INFINITY ; } else if (  Na N . equals ( s ) ) { return  Float .  Na N ; } else { s = trim Plus Sign ( s ) ; return  Float . parse Float ( s ) ; } }
public void request Password For Share Via Link ( boolean create Share ) {  Share Password Dialog Fragment dialog =  Share Password Dialog Fragment . new Instance ( m File , create Share ) ; dialog . show ( get Fragment Manager ( ) ,  Share Password Dialog Fragment .  PASSWORD_ FRAGMENT ) ; }
private void force Out Of Memory ( ) {  Array List junk = new  Array List ( ) ; for ( ; ; ) { junk . add ( new long [ _ NUM ] ) ; } }
public static double enlargement Scaled (  Spatial Comparable exist ,  Spatial Comparable addit , double scale ) { final int dim = assert Same Dimensionality ( exist , addit ) ; double v1 = _ NUM ; double v2 = _ NUM ; for ( int i = _ NUM ; i < dim ; i ++ ) { final double emin = exist . get Min ( i ) ; final double emax = exist . get Max ( i ) ; final double amin = addit . get Min ( i ) ; final double amax = addit . get Max ( i ) ; final double min =  Math . min ( emin , amin ) ; final double max =  Math . max ( emax , amax ) ; v1 *= ( max - min ) * scale ; v2 *= ( emax - emin ) * scale ; } return v2 - v1 ; }
public boolean can Get Int ( ) { return can Get ( int . class ) ; }
@  TCB static  String strip Banned Codeunits (  String s ) { int safe Limit = longest Prefix Of Good Codeunits ( s ) ; if ( safe Limit < _ NUM ) { return s ; }  String Builder sb = new  String Builder ( s ) ; strip Banned Codeunits ( sb , safe Limit ) ; return sb . to String ( ) ; }
public static void assert Linewise Equals (  String message ,  String expected ,  String actual ) { try (  Scanner expected Scanner = new  Scanner ( expected ) ;  Scanner actual Scanner = new  Scanner ( actual ) ) {  String expected Line = null ;  String actual Line = null ; int line Counter = _ NUM ; while ( expected Scanner . has Next Line ( ) ) { expected Line = expected Scanner . next Line ( ) ; if ( actual Scanner . has Next Line ( ) ) { actual Line = actual Scanner . next Line ( ) ; } else { fail ( _ STR + line Counter + _ STR + expected Line ) ; } assert Equals ( _ STR + line Counter + _ STR + message + _ STR + expected + _ STR + actual , expected Line , actual Line ) ; ++ line Counter ; } } }
private void warning (  String msg ,  Throwable th ) { warning ( msg ) ; th . print Stack Trace ( ) ; }
public  String full Form ( final  String str , final  String low String ) {  String ret = low String ;  Prefix Entry found = prefix Map . get ( str ) ; if ( found != null ) { ret = found . prefix Singular + ret ; } else { for (  Prefix Entry entry : prefix End List ) { if ( str . ends With ( entry . keyword ) ) { ret =  Grammar . add Prefix If Not Already There ( ret , entry . prefix Singular , entry . prefix Plural ) ; break ; } } } return ret ; }
public void clear Password Expiration Warned Time ( ) { operations . add (  Password Policy State Operation Type .  CLEAR_ PASSWORD_ EXPIRATION_ WARNED_ TIME ) ; }
public void remove Listeners ( ) { if ( global Listener != null ) { try {  Invoker Helper . invoke Method ( current Object , _ STR , global Listener ) ; } catch (  Exception e ) { } global Listener = null ; } if ( local Listener != null ) { try {  Invoker Helper . invoke Method ( current Object , _ STR , new  Object [ ] { property Name , local Listener } ) ; } catch (  Exception e ) { } local Listener = null ; } if ( synthetic Full Binding != null ) { synthetic Full Binding . unbind ( ) ; } }
public static  String pad Left (  String str , int total Chars ) { if ( str == null ) str = _ STR ;  String Builder sb = new  String Builder ( ) ; for ( int i = _ NUM ; i < total Chars - str . length ( ) ; i ++ ) { sb . append ( _ STR ) ; } sb . append ( str ) ; return sb . to String ( ) ; }
public void show Scores ( boolean flag ) { m Show Scores = flag ;  Swing Utilities . invoke Later ( null ) ; }
protected double kernel Helper ( int n , char [ ] s , int end Index S , char [ ] t , int end Index T ) { if ( n <= _ NUM ) { return get Return Value ( n ) ; } if (  Math . min ( end Index S + _ NUM , end Index T + _ NUM ) < n ) { return get Return Value ( n ) ; } int adr = _ NUM ; if ( m_use Recursion Cache ) { adr = m_mult X * n + m_mult Y * end Index S + m_mult Z * end Index T ; if ( cachekh K [ adr % max Cache ] == adr + _ NUM ) { return cachekh [ adr % max Cache ] ; } } double result = _ NUM ; result = m_lambda * kernel Helper ( n , s , end Index S - _ NUM , t , end Index T ) + kernel Helper2 ( n , s , end Index S , t , end Index T ) ; if ( m_use Recursion Cache ) { cachekh K [ adr % max Cache ] = adr + _ NUM ; cachekh [ adr % max Cache ] = result ; } return result ; }
protected  Connection open H2 Connection ( boolean autocommit ) throws  SQLException {  System . set Property ( _ STR , _ STR ) ;  String db Name = _ STR ;  Connection conn =  Driver Manager . get Connection ( _ STR + db Name + _ STR ) ; conn . set Auto Commit ( autocommit ) ; return conn ; }
protected void start Recoarding ( ) { coordinates . clear ( ) ; enabled = _ BOOL ; }
public void add Input Method Listener (  Input Method Listener l ) { m_text Pane . add Input Method Listener ( l ) ; }
public void add Footer View (  View v ,  Object data , boolean is Selectable ) {  Fixed View Info info = new  Fixed View Info ( ) ; info . view = v ; info . data = data ; info . is Selectable = is Selectable ; m Footer View Infos . add ( info ) ; if ( m Adapter != null && m Observer != null ) { m Observer . on Changed ( ) ; } }
public static void load (  String url ) {  String driver = get Driver ( url ) ; if ( driver != null ) { load User Class ( driver ) ; } }
protected void put Command ( final  Class command Class , final  String [ ] names ) {  Check . is True ( names . length > _ NUM , _ STR ) ; _commands To Canonical Names . put ( command Class , names [ _ NUM ] ) ; for ( int i = _ NUM ; i < names . length ; i ++ ) { _aliases To Commands . put ( names [ i ] , command Class ) ; } }
protected void write Column Auto Increment Stmt (  Table table ,  Column column ,  String Builder ddl ) { ddl . append ( _ STR ) ; }
private void  Save GCMData ( ) { try {  Shared Preferences preferences = get Shared Preferences ( ) ;  Shared Preferences .  Editor editor = preferences . edit ( ) ; editor . put String (  PREFS_ PUSHER_ APP_ ID_ KEY , m Pusher App Id ) ; editor . put String (  PREFS_ PUSHER_ URL_ KEY , m Pusher Url ) ; editor . put String (  PREFS_ PUSHER_ FILE_ TAG_ KEY , m Pusher Base File Tag ) ; editor . commit ( ) ; } catch (  Exception e ) {  Log . e (  LOG_ TAG , _ STR + e . get Localized Message ( ) ) ; } }
private void paint Background Solid (  Graphics2 D g ,  JComponent c , int x , int y , int width , int height ) {  Color color = c . get Background ( ) ; if ( type ==  Common Control State .  DISABLED ) { color = new  Color ( color . get Red ( ) , color . get Green ( ) , color . get Blue ( ) , _ NUM ) ; }  Shape s = shape Generator . create Round Rectangle ( x - _ NUM , y - _ NUM , width + _ NUM , height + _ NUM ,  Corner Size .  BORDER ) ; g . set Paint ( color ) ; g . fill ( s ) ; if ( is Paint Line Seperators ( c ) ) { paint Line Separator ( g , c , width , height ) ; } }
public static void add Attribute Default Values (  String service Name ,  String sub Schema Name ,  String schema Type ,  String attribute Name ,  Set default Values ) throws  Upgrade Exception {  String class Method = _ STR ; if ( debug . message Enabled ( ) ) { debug . message ( class Method + _ STR ) ; debug . message ( _ STR + service Name + _ STR + attribute Name ) ; }  Service Schema ss = get Service Schema ( service Name , sub Schema Name , schema Type ) ; try {  Map attribute Defaults = ss . get Attribute Defaults ( ) ;  Set old Attr Values = (  Set ) attribute Defaults . get ( attribute Name ) ;  Set new Attr Values = ( ( old Attr Values == null ) || old Attr Values . is Empty ( ) ) ? new  Hash Set ( ) : new  Hash Set ( old Attr Values ) ; new Attr Values . add All ( default Values ) ; ss . set Attribute Defaults ( attribute Name , new Attr Values ) ; } catch (  SSOException ssoe ) { throw new  Upgrade Exception ( _ STR ) ; } catch (  SMSException sme ) { throw new  Upgrade Exception ( _ STR + _ STR ) ; } }
private  String encode Product ( ) {  String Buffer tokens = new  String Buffer ( ) ;  List Iterator it = product Tokens . list Iterator ( ) ; while ( it . has Next ( ) ) { tokens . append ( (  String ) it . next ( ) ) ; } return tokens . to String ( ) ; }
public boolean is Metadata Modified Since Last Publication ( ) { return metadata Modified Since Last Publication ; }
public  Options resource Dirs (  List <  File > value ) { resource Dirs . clear ( ) ; resource Dirs . add All ( value ) ; return this ; }
private final  String _decode Short Unicode Name ( int len ) throws  IOException ,  Json Parse Exception { int out Ptr = _ NUM ; char [ ] out Buf = _text Buffer . empty And Get Current Segment ( ) ; int in Ptr = _input Ptr ; _input Ptr += len ; final int [ ] codes =  Smile Constants . s Utf8 Unit Lengths ; final byte [ ] in Buf = _input Buffer ; for ( int end = in Ptr + len ; in Ptr < end ; ) { int i = in Buf [ in Ptr ++ ] & _ NUM ; int code = codes [ i ] ; if ( code != _ NUM ) { switch ( code ) { case _ NUM : i = ( ( i & _ NUM ) << _ NUM ) | ( in Buf [ in Ptr ++ ] & _ NUM ) ; break ; case _ NUM : i = ( ( i & _ NUM ) << _ NUM ) | ( ( in Buf [ in Ptr ++ ] & _ NUM ) << _ NUM ) | ( in Buf [ in Ptr ++ ] & _ NUM ) ; break ; case _ NUM : i = ( ( i & _ NUM ) << _ NUM ) | ( ( in Buf [ in Ptr ++ ] & _ NUM ) << _ NUM ) | ( ( in Buf [ in Ptr ++ ] & _ NUM ) << _ NUM ) | ( in Buf [ in Ptr ++ ] & _ NUM ) ; i -= _ NUM ; out Buf [ out Ptr ++ ] = ( char ) ( _ NUM | ( i > > _ NUM ) ) ; i = _ NUM | ( i & _ NUM ) ; break ; default : _report Error ( _ STR +  Integer . to Hex String ( i ) + _ STR ) ; } } out Buf [ out Ptr ++ ] = ( char ) i ; } _text Buffer . set Current Length ( out Ptr ) ; return _text Buffer . contents As String ( ) ; }
private static  Class Node make Type (  Class Node cn , boolean using Class ) { if ( using Class ) {  Class Node clazz Type =  CLASS_ Type . get Plain Node Reference ( ) ; clazz Type . set Generics Types ( new  Generics Type [ ] { new  Generics Type ( cn ) } ) ; return clazz Type ; } else { return cn ; } }
protected  String to Message (  Map <  String ,  String > results ) {  String Builder builder = new  String Builder ( ) ; if ( results != null ) { for (  Map .  Entry <  String ,  String > entry : results . entry Set ( ) ) { builder . append ( entry . get Key ( ) + _ STR + entry . get Value ( ) + _ STR ) ; } } return builder . to String ( ) ; }
public  Test Tree sort ( ) {  Collections . sort ( suites ) ; suites . for Each ( null ) ; return this ; }
public static  Event Bean [ ] add To Array (  Event Bean [ ] array ,  Collection <  Event Bean > events To Add ) {  Event Bean [ ] new Array = new  Event Bean [ array . length + events To Add . size ( ) ] ;  System . arraycopy ( array , _ NUM , new Array , _ NUM , array . length ) ; int counter = array . length ; for (  Event Bean event To Add : events To Add ) { new Array [ counter ++ ] = event To Add ; } return new Array ; }
public static  String replace (  String a ,  String b ,  String c ) {  String Builder result = new  String Builder ( c . length ( ) ) ; int i = _ NUM ; int j = c . index Of ( a ) ; while ( j >= i ) { result . append ( c . substring ( i , j ) ) ; result . append ( b ) ; i = j + a . length ( ) ; j = c . index Of ( a , i ) ; } result . append ( c . substring ( i , c . length ( ) ) ) ; return result . to String ( ) ; }
protected void on Page Scrolled ( int position , float offset , int offset Pixels ) { if ( m Decor Child Count > _ NUM ) { final int scroll Y = get Scroll Y ( ) ; int padding Top = get Padding Top ( ) ; int padding Bottom = get Padding Bottom ( ) ; final int height = get Height ( ) ; final int child Count = get Child Count ( ) ; for ( int i = _ NUM ; i < child Count ; i ++ ) { final  View child = get Child At ( i ) ; final  Layout Params lp = (  Layout Params ) child . get Layout Params ( ) ; if ( ! lp . is Decor ) continue ; final int vgrav = lp . gravity &  Gravity .  VERTICAL_ GRAVITY_ MASK ; int child Top = _ NUM ; switch ( vgrav ) { default : child Top = padding Top ; break ; case  Gravity .  TOP : child Top = padding Top ; padding Top += child . get Height ( ) ; break ; case  Gravity .  CENTER_ VERTICAL : child Top =  Math . max ( ( height - child . get Measured Height ( ) ) / _ NUM , padding Top ) ; break ; case  Gravity .  BOTTOM : child Top = height - padding Bottom - child . get Measured Height ( ) ; padding Bottom += child . get Measured Height ( ) ; break ; } child Top += scroll Y ; final int child Offset = child Top - child . get Top ( ) ; if ( child Offset != _ NUM ) { child . offset Top And Bottom ( child Offset ) ; } } } dispatch On Page Scrolled ( position , offset , offset Pixels ) ; if ( m Page Transformer != null ) { final int scroll Y = get Scroll Y ( ) ; final int child Count = get Child Count ( ) ; for ( int i = _ NUM ; i < child Count ; i ++ ) { final  View child = get Child At ( i ) ; final  Layout Params lp = (  Layout Params ) child . get Layout Params ( ) ; if ( lp . is Decor ) continue ; final float transform Pos = ( float ) ( child . get Top ( ) - scroll Y ) / get Client Height ( ) ; m Page Transformer . transform Page ( child , transform Pos ) ; } } m Called Super = _ BOOL ; }
private void reflect Member Variables In Final Button ( ) { final boolean last Page Reached = ( view Pager . get Current Item ( ) + _ NUM ) == pages . size ( ) ; final boolean button Should Be Invisible = ! last Page Reached || final Button Disabled ; final boolean button Is Currently Invisible = final Button . get Visibility ( ) ==  View .  INVISIBLE ; final boolean should Update Button = button Should Be Invisible != button Is Currently Invisible ; if ( should Update Button ) { final  Animator button Animator = button Should Be Invisible ? button Animator Factory . new Final Button Disappear Animator ( final Button ) : button Animator Factory . new Final Button Appear Animator ( final Button ) ; if ( button Should Be Invisible ) { disable Button ( button Animator , final Button ) ; } else { enable Button ( button Animator , final Button ) ; } } }
public void test Decoder6 ( ) { boolean res ;  String original App Id Name = m App Id Name ; int original Content Type Value = m Content Type Value ;  Random rd = new  Random ( ) ; for ( int i = _ NUM ; i <  OMA_ APPLICATION_ ID_ NAMES . length ; i ++ ) { m App Id Name =  OMA_ APPLICATION_ ID_ NAMES [ i ] ; m Content Type Value = rd . next Int ( _ NUM ) ; byte [ ] pdu = create PDU ( _ NUM ) ;  Wsp Type Decoder pdu Decoder = new  Wsp Type Decoder ( pdu ) ; res = pdu Decoder . seek XWap Application Id ( m Wsp Header Start , m Wsp Header Start + m Wsp Header Len - _ NUM ) ; assert True ( res ) ; int index = ( int ) pdu Decoder . get Value32 ( ) ; res = pdu Decoder . decode XWap Application Id ( index ) ; assert True ( res ) ;  Log . d (  LOG_ TAG , _ STR + m App Id Name + _ STR + pdu Decoder . get Value String ( ) + _ STR ) ; assert True ( m App Id Name . equals ( pdu Decoder . get Value String ( ) ) ) ; } m App Id Name = original App Id Name ; m Content Type Value = original Content Type Value ; }
private static boolean is Writable ( @  Non Null final  File file ) { boolean is Existing = file . exists ( ) ; try {  File Output Stream output = new  File Output Stream ( file , _ BOOL ) ; try { output . close ( ) ; } catch (  IOException e ) { } } catch ( java . io .  File Not Found Exception e ) { return _ BOOL ; } boolean result = file . can Write ( ) ; if ( ! is Existing ) { file . delete ( ) ; } return result ; }
public  Gm Publishing Priority ( ) { }
private  Relying Party validate Relying Party (  Http Servlet Request request ,  String tenant Name ) {  Validate . not Null ( request , _ STR ) ;  Validate . not Empty ( tenant Name , _ STR ) ;  Default Idm Accessor Factory idm Factory = new  Default Idm Accessor Factory ( ) ;  Validate . not Null ( idm Factory , _ STR ) ;  Idm Accessor idm Accessor = idm Factory . get Idm Accessor ( ) ; idm Accessor . set Tenant ( tenant Name ) ;  String encoded Entity Id = request . get Parameter (  Shared .  RELYINGPARTY_ ENTITYID ) ; if ( encoded Entity Id == null || encoded Entity Id . is Empty ( ) ) { logger . error ( _ STR ) ; return null ; }  String rp Entity Id = new  String (  Base64 . decode ( encoded Entity Id ) ) ;  Relying Party rp = idm Accessor . get Relying Party By Url ( rp Entity Id ) ; if ( rp != null ) { return rp ; } else { logger . error ( _ STR + rp Entity Id ) ; return null ; } }
public void rotate Z ( double theta ) {  Matrix3 D tmp = new  Matrix3 D ( ) ; double c =  Math . cos ( theta ) ; double s =  Math . sin ( theta ) ; tmp . set ( _ NUM , _ NUM , c ) ; tmp . set ( _ NUM , _ NUM , - s ) ; tmp . set ( _ NUM , _ NUM , s ) ; tmp . set ( _ NUM , _ NUM , c ) ; pre Multiply ( tmp ) ; }
public  Service Host start Factory (  Service instance Service ) { final  Class < ? extends  Service > service Class = instance Service . get Class ( ) ; return start Factory ( service Class , null ) ; }
void wake Out ( ) {  On Available out Flow = _out Flow ; if ( out Flow == null ) { return ; } if ( _credits In <= _queue . head ( ) ) { return ; }  State Out Pipe state Old ;  State Out Pipe state New ; do { state Old = _state Out Ref . get ( ) ; if ( ! state Old . is Full ( ) ) { return ; } state New = state Old . to Wake ( ) ; } while ( ! _state Out Ref . compare And Set ( state Old , state New ) ) ; try (  Outbox Amp outbox =  Outbox Amp . current Or Create ( _out Ref . services ( ) ) ) {  Objects . require Non Null ( outbox ) ;  Pipe Wake Out Message <  T > msg = new  Pipe Wake Out Message < > ( outbox , _out Ref , this , out Flow ) ; outbox . offer ( msg ) ; } }
public  Constraint Map create Assignment Constraints ( final  Annotated Type Mirror assigned To , final  Annotated Type Mirror boxed Return Type , final  Annotated Executable Type method Type , final  Set <  AFConstraint > af Argument Constraints , final  Map <  Type Variable ,  Annotated Type Mirror > inferred Args , final  Set <  Type Variable > targets , final  Annotated Type Factory type Factory ) { final  Linked List <  AFConstraint > assignment Afs = new  Linked List < > ( ) ; for (  Annotated Type Variable type Param : method Type . get Type Variables ( ) ) { final  Type Variable target = type Param . get Underlying Type ( ) ; final  Annotated Type Mirror inferred Type = inferred Args . get ( target ) ; if ( inferred Type != null ) { assignment Afs . add ( new  A2 F ( inferred Type , type Param . get Upper Bound ( ) ) ) ; assignment Afs . add ( new  F2 A ( type Param . get Lower Bound ( ) , inferred Type ) ) ; } else { assignment Afs . add ( new  F2 A ( type Param , type Param . get Upper Bound ( ) ) ) ; assignment Afs . add ( new  A2 F ( type Param . get Lower Bound ( ) , type Param ) ) ; } } for (  AFConstraint arg Constraint : af Argument Constraints ) { if ( arg Constraint instanceof  F2 A ) { assignment Afs . add ( arg Constraint ) ; } }  Linked List <  AFConstraint > substituted Assignment Constraints = new  Linked List < > ( ) ; for (  AFConstraint af Constraint : assignment Afs ) { substituted Assignment Constraints . add ( af Constraint . substitute ( inferred Args ) ) ; } final  Annotated Type Mirror substituted Return Type =  Type Arg Inference Util . substitute ( inferred Args , boxed Return Type ) ; substituted Assignment Constraints . add ( new  F2 A ( substituted Return Type , assigned To ) ) ; final  Set <  AFConstraint > reduced Constraints = new  Linked Hash Set < > ( ) ; reduce Af Constraints ( type Factory , reduced Constraints , substituted Assignment Constraints , targets ) ; final  Set <  TUConstraint > tu Assignment Constraints = af To Tu Constraints ( reduced Constraints , targets ) ; add Constraints Between Targets ( tu Assignment Constraints , targets , _ BOOL , type Factory ) ; return constraint Map Builder . build ( targets , tu Assignment Constraints , type Factory ) ; }
public static int columns Number ( char c , int x , int prev X , int plain Space Size ) { if ( c != _ STR ) { return _ NUM ; } int result = ( x - prev X ) / plain Space Size ; if ( ( x - prev X ) % plain Space Size > _ NUM ) { result ++ ; } return result ; }
public  Kafka Message Listener Container (  Consumer Factory <  K ,  V > consumer Factory ,  Container Properties container Properties ,  Topic Partition Initial Offset ... topic Partitions ) { super ( container Properties ) ;  Assert . not Null ( consumer Factory , _ STR ) ; this . consumer Factory = consumer Factory ; if ( topic Partitions != null ) { this . topic Partitions =  Arrays . copy Of ( topic Partitions , topic Partitions . length ) ; } else { this . topic Partitions = container Properties . get Topic Partitions ( ) ; } }
private  String to String (  Matcher m , int group ) { return ( group == _ NUM ) ? _ STR : m . group ( group ) ; }
public  Pla Line Int translate_by (  Pla Vector Int p_vector ) { if ( p_vector . equals (  Pla Vector Int .  ZERO ) ) return this ;  Pla Point Int new_a = point_a . translate_by ( p_vector ) ;  Pla Point Int new_b = point_b . translate_by ( p_vector ) ; return new  Pla Line Int ( new_a , new_b ) ; }
@  Suppress Warnings ( _ STR ) final void reject (  Runnable command ) { handler . rejected Execution ( command , this ) ; }
private int calculate Menu Margin ( ) {  Window Manager wm = (  Window Manager ) get System Service (  Context .  WINDOW_ SERVICE ) ;  Display display = wm . get Default Display ( ) ;  Point size = new  Point ( ) ; display . get Size ( size ) ; int height = size . y ; return ( int )  Math . round ( height *  MENU_ MARGIN_ RELATIVE_ MODIFIER ) ; }
public void add Ram (  Attack Action ea ) { pending Rams . add Element ( ea ) ; process Game Event ( new  Game New Action Event ( this , ea ) ) ; }
public void test Config File Property ( ) throws  Exception {  File config Home = new  File ( configuration . get Home ( ) ) ; assert True ( _ STR , config Home . exists ( ) && config Home . is Directory ( ) ) ;  File existing File = create File ( config Home , _ STR , _ STR ) ; assert Equals ( _ STR , read File ( existing File ) ) ;  String file Name = _ STR ;  String file Contents = _ STR ;  File file = create File ( config File Directory , file Name , file Contents ) ;  File Config config File = new  File Config ( ) ; config File . set File ( get Absolute Path ( file ) ) ; config File . set To File ( _ STR ) ; config File . set Overwrite ( _ BOOL ) ; config File . set Configfile ( _ BOOL ) ; configuration . set Property ( _ STR , _ STR ) ; configuration . set Config File Property ( config File ) ; configuration . do Configure ( null ) ;  File copied File = new  File ( configuration . get Home ( ) + _ STR ) ; assert True ( _ STR , copied File . exists ( ) ) ; assert Equals ( _ STR , read File ( copied File ) ) ; }
protected byte [ ] generate Salt ( ) { return  HEADER . get Bytes (  Constants .  UTF8 ) ; }
public void add Listener ( final  Projector Listener projector Listener ) { if ( listeners == null ) { listeners = new  Array List <  Projector Listener > ( ) ; } listeners . add ( projector Listener ) ; }
protected  Tuple Expr select Next Tuple Expr (  List <  Tuple Expr > expressions ,  Map <  Tuple Expr ,  Double > cardinality Map ,  Map <  Tuple Expr ,  List <  Var > > vars Map ,  Map <  Var ,  Integer > var Freq Map ,  Set <  String > bound Vars ) {  Tuple Expr result = null ; if ( expressions . size ( ) > _ NUM ) { double lowest Cardinality =  Double .  POSITIVE_ INFINITY ; for (  Tuple Expr tuple Expr : expressions ) { double cardinality = get Tuple Expr Cardinality ( tuple Expr , cardinality Map , vars Map , var Freq Map , bound Vars ) ; if ( cardinality < lowest Cardinality || result == null ) { lowest Cardinality = cardinality ; result = tuple Expr ; } } } else { result = expressions . get ( _ NUM ) ; } return result ; }
public static void write Bcd Number (  Output Stream os ,  String number ) throws  IOException { int bcd = _ NUM ; int n = _ NUM ; for ( int i = _ NUM ; i < number . length ( ) ; i ++ ) { switch ( number . char At ( i ) ) { case _ STR : bcd |= _ NUM ; break ; case _ STR : bcd |= _ NUM ; break ; case _ STR : bcd |= _ NUM ; break ; case _ STR : bcd |= _ NUM ; break ; case _ STR : bcd |= _ NUM ; break ; case _ STR : bcd |= _ NUM ; break ; case _ STR : bcd |= _ NUM ; break ; case _ STR : bcd |= _ NUM ; break ; case _ STR : bcd |= _ NUM ; break ; case _ STR : bcd |= _ NUM ; break ; case _ STR : bcd |= _ NUM ; break ; case _ STR : bcd |= _ NUM ; break ; case _ STR : bcd |= _ NUM ; break ; case _ STR : bcd |= _ NUM ; break ; } n ++ ; if ( n == _ NUM ) { os . write ( bcd ) ; n = _ NUM ; bcd = _ NUM ; } else { bcd >>= _ NUM ; } } if ( n == _ NUM ) { bcd |= _ NUM ; os . write ( bcd ) ; } }
public void add Message (  String message ) { messages . add Last ( message ) ; if ( messages . size ( ) >  MAX_ HISTORY ) { messages . remove First ( ) ; } pointer = messages . size ( ) ; }
@  Visible For Testing protected void start Executor ( final int container ) {  LOG . info ( _ STR + container ) ; final  Process container Executor = start Executor Process ( container ) ; process To Container . put ( container Executor , container ) ;  LOG . info ( _ STR + container ) ; start Executor Monitor ( container , container Executor ) ; }
public static  Date string To Date (  String s ,  Date Format formatter ) { try { return formatter . parse ( s ) ; } catch (  Parse Exception e ) { return null ; } }
public void accept (  Abstract Reporter r ) { r . test Start ( this ) ; r . browser Info Entry ( browser Info Entry ) ;  Iterator <  Log Entry > entry Iterator = log Entries . iterator ( ) ; while ( entry Iterator . has Next ( ) ) {  Log Entry entry = entry Iterator . next ( ) ; if ( ! entry Iterator . has Next ( ) ) { entry . set Last ( _ BOOL ) ; } visit ( entry , r ) ; } r . test End ( this ) ; }
private void load Latest Extension Versions ( ) { try {  List <  Extension > all = registry Manager . get Extensions ( ) ; if ( ! all . is Empty ( ) ) { set Latest Extension Versions ( get Latest Versions ( all ) ) ; } } catch (  Registry Exception e ) {  String msg =  Registry Exception . log Registry Exception ( e . get Type ( ) , this ) ; warnings . add Startup Error ( msg ) ;  LOG . error ( msg ) ; msg = get Text ( _ STR , new  String [ ] { cfg . get Registry Url ( ) } ) ; warnings . add Startup Error ( msg ) ;  LOG . error ( msg ) ; } finally { if ( get Latest Extension Versions ( ) == null ) { set Latest Extension Versions ( new  Array List <  Extension > ( ) ) ; } } }
public int read ( ) throws  IOException { int val ; if ( ( val = is . read ( ) ) < _ NUM ) { return - _ NUM ; } if ( bo == _ STR ) { val = ( char ) ( ( val << _ NUM ) | ( is . read ( ) & _ NUM ) ) ; } else { val = ( char ) ( ( is . read ( ) << _ NUM ) | ( val & _ NUM ) ) ; } return val ; }
public void cancel Auto Completion ( ) { if ( in Completion ) { text Field . set Text ( text Before ) ; text Field . set Caret Position ( caret Pos Before ) ; prev Completion = null ; prev Completion Index = _ NUM ; in Completion = _ BOOL ; } }
public  Enumeration <  Option > list Options ( ) {  Vector <  Option > result = new  Vector <  Option > ( ) ; result . add ( new  Option ( _ STR , _ STR , _ NUM , _ STR ) ) ; result . add All (  Collections . list ( super . list Options ( ) ) ) ; return result . elements ( ) ; }
public  Client Properties Builder with Proxy Host Name (  String proxy Host Name ) { properties . set Property (  CLIENT_ SERVICE_ PROXY_ HOST_ NAME , proxy Host Name ) ; return this ; }
public static void verify Setter Methods (  Class < ? > clazz ,  Mapped Field ... fields ) {  String method Name = null ;  String field Name = null ;  Class < ? > field Type = null ; try { for (  Mapped Field field : fields ) { field Name = field . get Name ( ) ; field Type = field . get Type ( ) ;  String custom Set = field . set Method ( ) ; if ( ! is Null ( custom Set ) && ! custom Set . equals (  Constants .  DEFAULT_ ACCESSOR_ VALUE ) ) try { clazz . get Method ( custom Set , field Type ) ; field . set Method ( custom Set ) ; continue ; } catch (  Exception e ) {  Error . custom Method ( _ STR , custom Set , clazz ) ; } method Name = m Set ( field Name ) ; clazz . get Method ( method Name , field Type ) ; field . set Method ( method Name ) ; } } catch (  Exception e ) {  Error . method ( method Name , field Name , clazz ) ; } }
static public  String random Positive Float ( int whole , int decimal ) {  String Builder output = new  String Builder ( ) ; output . append ( rnd . next Int ( _ NUM ) + _ NUM ) ; for ( int i = _ NUM ; i < whole - _ NUM ; i ++ ) { output . append ( rnd . next Int ( _ NUM ) ) ; } output . append ( _ STR ) ; for ( int i = _ NUM ; i < decimal ; i ++ ) { output . append ( rnd . next Int ( _ NUM ) ) ; } return output . to String ( ) ; }
public static  Variation attempt To Get As Variant (  String part ) { try {  Stone Types var =  Stone Types . value Of ( part . to Upper Case ( ) ) ; if ( var != null ) {  Variation bv = new  Variation ( ) ; bv . set Value ( var . value ( ) ) ; return bv ; } } catch (  Exception e ) { } try {  Wood Types var =  Wood Types . value Of ( part . to Upper Case ( ) ) ; if ( var != null ) {  Variation bv = new  Variation ( ) ; bv . set Value ( var . value ( ) ) ; return bv ; } } catch (  Exception e ) { } try {  Flower Types var =  Flower Types . from Value ( part ) ; if ( var != null ) {  Variation bv = new  Variation ( ) ; bv . set Value ( var . value ( ) ) ; return bv ; } } catch (  Exception e ) { } try {  Entity Types var =  Entity Types . from Value ( part ) ; if ( var != null ) {  Variation bv = new  Variation ( ) ; bv . set Value ( var . value ( ) ) ; return bv ; } } catch (  Exception e ) { } try {  Monster Egg Types var =  Monster Egg Types . from Value ( part ) ; if ( var != null ) {  Variation bv = new  Variation ( ) ; bv . set Value ( var . value ( ) ) ; return bv ; } } catch (  Exception e ) { } try {  Shape Types var =  Shape Types . from Value ( part ) ; if ( var != null ) {  Variation bv = new  Variation ( ) ; bv . set Value ( var . value ( ) ) ; return bv ; } } catch (  Exception e ) { } try {  Half Types var =  Half Types . from Value ( part ) ; if ( var != null ) {  Variation bv = new  Variation ( ) ; bv . set Value ( var . value ( ) ) ; return bv ; } } catch (  Exception e ) { } return null ; }
public void reset Text Box Indexes Except (  Set <  Integer > excluded List ) {  Set <  Integer > unused Text Box Indexes = new  Hash Set <  Integer > ( points . get Text Box Indexes ( ) ) ; unused Text Box Indexes . remove All ( excluded List ) ; for (  Integer index : unused Text Box Indexes ) { points . remove Text Box ( index ) ; } }
public  IDevice learn Entity ( long mac Address ,  Short vlan ,  Integer ipv4 Address ,  Long switch DPID ,  Integer switch Port , boolean process Updates ) {  List <  IDevice Listener > listeners = device Listeners . get Ordered Listeners ( ) ; if ( ! process Updates ) { device Listeners . clear Listeners ( ) ; } if ( vlan != null && vlan . short Value ( ) <= _ NUM ) vlan = null ; if ( ipv4 Address != null && ipv4 Address == _ NUM ) ipv4 Address = null ;  IDevice res = learn Device By Entity ( new  Entity ( mac Address , vlan , ipv4 Address , switch DPID , switch Port , new  Date ( ) ) ) ; if ( listeners != null ) { for (  IDevice Listener listener : listeners ) { device Listeners . add Listener ( _ STR , listener ) ; } } return res ; }
public double [ ] level Zero Data ( ) {  List <  Buffer > level Zero Buffers = buffer Map . get ( _ NUM ) ; int length = _ NUM ; for (  Buffer buffer : level Zero Buffers ) { if ( ! buffer . has Capacity ( ) ) { length += buffer . size ; } else { length += buffer . next ; } } int pos = _ NUM ; int curr Len ; final double [ ] out = new double [ length ] ; for (  Buffer buffer : level Zero Buffers ) { if ( ! buffer . has Capacity ( ) ) { curr Len = buffer . size ; } else { curr Len = buffer . next ; }  System . arraycopy ( buffer . data , _ NUM , out , pos , curr Len ) ; pos += curr Len ; } return out ; }
public  String [ ] show Version ( ) throws  Network Device Controller Exception {  String [ ] return Val = new  String [ _ NUM ] ;  SSHPrompt [ ] prompts = {  SSHPrompt .  MDS_ POUND ,  SSHPrompt .  MDS_ GREATER_ THAN } ;  String Builder buf = new  String Builder ( ) ;  SSHPrompt prompt = send Wait For (  MDSDialog Properties . get String ( _ STR ) , _ NUM , prompts , buf ) ;  String [ ] lines = get Lines ( buf ) ;  String [ ] regex = {  MDSDialog Properties . get String ( _ STR ) ,  MDSDialog Properties . get String ( _ STR ) ,  MDSDialog Properties . get String ( _ STR ) } ;  String [ ] groups = new  String [ _ NUM ] ; for (  String line : lines ) { int index = match ( line , regex , groups ) ; switch ( index ) { case _ NUM : return Val [ _ NUM ] = groups [ _ NUM ] ; break ; case _ NUM : return Val [ _ NUM ] = groups [ _ NUM ] ; break ; case _ NUM : return Val [ _ NUM ] = groups [ _ NUM ] ; break ; } } return return Val ; }
public static int count Matches (  String string , char c ) { int n = _ NUM ; for ( char tc : string . to Char Array ( ) ) { if ( c == tc ) n ++ ; } return n ; }
private  Image Icon add Color (  Image Icon icon ,  Color color ) { if ( icon == null || color == null ) { return icon ; }  Buffered Image new Image = new  Buffered Image ( icon . get Icon Width ( ) , icon . get Icon Width ( ) ,  Buffered Image .  TYPE_ INT_ ARGB ) ;  Graphics g = new Image . get Graphics ( ) ; g . set Color ( color ) ; g . draw Image ( icon . get Image ( ) , _ NUM , _ NUM , color , null ) ; g . dispose ( ) ; return new  Image Icon ( new Image ) ; }
public static byte [ ] read All Limited (  Input Stream in Str , int limit ) throws  IOException {  Byte Array Output Stream buf = new  Byte Array Output Stream ( ) ; pipe All Limited ( in Str , limit , buf ) ; return buf . to Byte Array ( ) ; }
protected  String search For ( final  String target ,  String start ) { return search For ( target , null , start ) ; }
private int validate Preload Order (  Cache Configuration [ ] cfgs ) throws  Ignite Checked Exception { int max Order = _ NUM ; for (  Cache Configuration cfg : cfgs ) { int rebalance Order = cfg . get Rebalance Order ( ) ; if ( rebalance Order > _ NUM ) { if ( cfg . get Cache Mode ( ) ==  LOCAL ) throw new  Ignite Checked Exception ( _ STR + _ STR +  U . mask Name ( cfg . get Name ( ) ) ) ; if ( cfg . get Rebalance Mode ( ) ==  Cache Rebalance Mode .  NONE ) throw new  Ignite Checked Exception ( _ STR + _ STR +  U . mask Name ( cfg . get Name ( ) ) + _ STR + cfg . get Rebalance Mode ( ) + _ STR + cfg . get Rebalance Order ( ) + _ STR ) ; max Order =  Math . max ( max Order , rebalance Order ) ; } else if ( rebalance Order < _ NUM ) throw new  Ignite Checked Exception ( _ STR + _ STR +  U . mask Name ( cfg . get Name ( ) ) + _ STR + rebalance Order + _ STR ) ; } return max Order ; }
public void execute ( ) { m Player . set Loop Mode ( m Do Loop ) ; m Thread = new  Thread ( this , _ STR ) ; m Thread . start ( ) ; }
@  Override public void remove Env Var (  Env Var env Var ) { if ( env Var != null ) { env Var List . remove ( env Var ) ; } }
static private  String calc Threshold ( double score Threshold , double lambda ) { final double log Prob Threshold =  Math . log ( _ NUM - score Threshold / _ NUM ) ; int max Num = _ NUM ; if ( calc Log Prob ( max Num , lambda ) > log Prob Threshold ) { return _ STR ; } int min Num = _ NUM ; while ( min Num < max Num ) { final int mid Num = ( max Num + min Num ) / _ NUM ; final boolean pass Threshold = calc Log Prob ( mid Num , lambda ) <= log Prob Threshold ; if ( pass Threshold ) { max Num = mid Num ; } else { if ( mid Num == min Num ) { break ; } min Num = mid Num ; } } return  Integer . to String ( max Num ) ; }
public static int index Of Last Separator (  String filename ) { if ( filename == null ) return - _ NUM ; int last Unix Pos = filename . last Index Of (  UNIX_ SEPARATOR ) ; int last Windows Pos = filename . last Index Of (  WINDOWS_ SEPARATOR ) ; return  Math . max ( last Unix Pos , last Windows Pos ) ; }
@  Category (  Flaky Test . class ) @  Test public void test_ FPAmetadata Fetch ( ) { final  Host host =  Host . get Host ( _ NUM ) ;  VM server1 = host . get VM ( _ NUM ) ;  VM server2 = host . get VM ( _ NUM ) ;  VM server3 = host . get VM ( _ NUM ) ;  VM server4 = host . get VM ( _ NUM ) ;  Boolean simple FPR = _ BOOL ; final int port Locator =  Available Port . get Random Available Port (  Available Port .  SOCKET ) ; final  String host Locator =  Network Utils . get Server Host Name ( server1 . get Host ( ) ) ; final  String locator = host Locator + _ STR + port Locator + _ STR ; server3 . invoke ( null ) ; try {  List <  Fixed Partition Attributes > fpa List = new  Array List <  Fixed Partition Attributes > ( ) ; fpa List . add (  Fixed Partition Attributes . create Fixed Partition ( _ STR , _ BOOL , _ NUM ) ) ; fpa List . add (  Fixed Partition Attributes . create Fixed Partition ( _ STR , _ BOOL , _ NUM ) ) ;  Integer port1 = (  Integer ) server1 . invoke ( null ) ; fpa List . clear ( ) ; fpa List . add (  Fixed Partition Attributes . create Fixed Partition ( _ STR , _ BOOL , _ NUM ) ) ;  Integer port2 = (  Integer ) server2 . invoke ( null ) ; fpa List . clear ( ) ; create Client With Locator ( host Locator , port Locator ) ; put Into Partitioned Regions Three Qs ( ) ; get From Partitioned Regions For3 Qs ( ) ;  Wait . pause ( _ NUM ) ; server1 . invoke ( null ) ; server2 . invoke ( null ) ; int total Bucket On Server = _ NUM ; total Bucket On Server += (  Integer ) server1 . invoke ( null ) ; total Bucket On Server += (  Integer ) server2 . invoke ( null ) ; int current Redundancy = _ NUM ; verify Metadata ( total Bucket On Server , current Redundancy ) ; update Into Single PRFor3 Qs ( ) ; fpa List . clear ( ) ; fpa List . add (  Fixed Partition Attributes . create Fixed Partition ( _ STR , _ BOOL , _ NUM ) ) ; fpa List . add (  Fixed Partition Attributes . create Fixed Partition ( _ STR , _ BOOL , _ NUM ) ) ; fpa List . add (  Fixed Partition Attributes . create Fixed Partition ( _ STR , _ BOOL , _ NUM ) ) ; fpa List . add (  Fixed Partition Attributes . create Fixed Partition ( _ STR , _ BOOL , _ NUM ) ) ;  Integer port4 = (  Integer ) server4 . invoke ( null ) ;  Wait . pause ( _ NUM ) ; put Into Partitioned Regions ( ) ; get From Partitioned Regions ( ) ;  Wait . pause ( _ NUM ) ; server1 . invoke ( null ) ; server2 . invoke ( null ) ; server4 . invoke ( null ) ; total Bucket On Server = _ NUM ; total Bucket On Server += (  Integer ) server1 . invoke ( null ) ; total Bucket On Server += (  Integer ) server2 . invoke ( null ) ; total Bucket On Server += (  Integer ) server4 . invoke ( null ) ; update Into Single PR ( ) ; } finally { server3 . invoke ( null ) ; } }
private static  Type [ ] unroll Bounds ( final  Map <  Type Variable < ? > ,  Type > type Arguments , final  Type [ ] bounds ) {  Type [ ] result = bounds ; int i = _ NUM ; for ( ; i < result . length ; i ++ ) { final  Type unrolled = unroll Variables ( type Arguments , result [ i ] ) ; if ( unrolled == null ) { result =  Array Utils . remove ( result , i -- ) ; } else { result [ i ] = unrolled ; } } return result ; }
public void delete Quota (  String id ) throws  Isilon Exception { delete ( _base Url . resolve (  URI_ QUOTAS ) , id , _ STR ) ; }
public static  Map <  String ,  String > create Basic Auth Header (  String username ,  String password ,  Map <  String ,  String > header Map ) { if ( header Map == null ) header Map = new  Hash Map < > ( ) ;  String credentials = username + _ STR + password ;  String base64 Encoded Credentials =  Base64 . encode To String ( credentials . get Bytes ( ) ,  Base64 .  NO_ WRAP ) ; header Map . put ( _ STR , _ STR + base64 Encoded Credentials ) ; return header Map ; }
private void add Extent Entry ( ) { extent Model . add New Entry ( ) ; remove Extent Button . set Enabled ( _ BOOL ) ; }
private  Transport Network check Cached (  String network Id ) { try {  String filename = network Id + _ STR +  R5 Version . version + _ STR ;  File cache Location = new  File ( cache Dir , network Id + _ STR +  R5 Version . version + _ STR ) ; if ( cache Location . exists ( ) )  LOG . info ( _ STR , cache Location ) ; else {  LOG . info ( _ STR , cache Location ) ; if ( source Bucket != null ) {  LOG . info ( _ STR ) ;  S3 Object tn ; try { tn = s3 . get Object ( source Bucket , filename ) ; } catch (  Amazon Service Exception ex ) {  LOG . info ( _ STR ) ; return null ; } cache Dir . mkdirs ( ) ;  LOG . info ( _ STR , cache Location ) ;  File Output Stream fos = new  File Output Stream ( cache Location ) ;  Input Stream is = tn . get Object Content ( ) ; try {  Byte Streams . copy ( is , fos ) ; } finally { is . close ( ) ; fos . close ( ) ; } } else {  LOG . info ( _ STR ) ; return null ; } }  LOG . info ( _ STR , cache Location ) ;  File Input Stream fis = new  File Input Stream ( cache Location ) ; try { return  Transport Network . read ( fis ) ; } finally { fis . close ( ) ; } } catch (  Exception e ) {  LOG . error ( _ STR , e ) ; return null ; } }
void read File (  File file ) throws org . jdom2 .  JDOMException , java . io .  IOException {  Xml File xf = new  Xml File ( ) { } ; xf . root From File ( file ) ; }
public boolean is All Granted ( ) { int count = _ NUM ; for ( int i = _ NUM ; i < m Perms . size ( ) ; i ++ ) { if ( m Perms . get ( m User Permission . get ( i ) ) ==  Package Manager .  PERMISSION_ GRANTED ) count ++ ; } return count == m Perms . size ( ) ; }
protected void execute (  Runnable evt ) { executor . execute ( evt ) ; }
private void send Next Message Over Network ( ) throws  Exception {  Raw Data raw = outgoing . take ( ) ; if ( raw == null ) throw new  Null Pointer Exception ( ) ; send Next ( raw ) ; }
public void add Attribute For ( final  Field field ) { field To Use As Attribute . add ( field ) ; }
public boolean is Session Token (  String token ) { synchronized ( session Tokens ) { return session Tokens . contains ( token ) ; } }
public static double root Means Squared Error ( double [ ] real , double [ ] predicted ) { double ret = _ NUM ; for ( int i = _ NUM ; i < real . length ; i ++ ) { ret +=  Math . pow ( ( real [ i ] - predicted [ i ] ) , _ NUM ) ; } return  Math . sqrt ( ret / real . length ) ; }
public void export (  Byte Buffer buf ) { buf . put Int ( seq Id ) ; if ( info . is Row Block Enabled ( ) ) buf . put Int ( n Rows ) ; export ( primary Key , buf ) ; for (  Byte Array cb : cell Blocks ) { export ( cb , buf ) ; } }
private  Hash Map <  String ,  Object > create Acc Detailmap (  String glcode ,  Big Decimal debit Amount ,  Big Decimal credit Amount ) {  Hash Map <  String ,  Object > accountdetailmap = new  Hash Map <  String ,  Object > ( ) ; accountdetailmap . put (  Voucher Constant .  GLCODE , glcode ) ; accountdetailmap . put (  Voucher Constant .  DEBITAMOUNT , debit Amount ) ; accountdetailmap . put (  Voucher Constant .  CREDITAMOUNT , credit Amount ) ; accountdetailmap . put (  Voucher Constant .  FUNCTIONCODE , get Functionary Code ( ) ) ; return accountdetailmap ; }
private void update Radio Links ( ) { m_advance Data Set First . set Enabled ( m_ Generator Property Panel . get Editor Active ( ) ) ; m_advance Iterator First . set Enabled ( m_ Generator Property Panel . get Editor Active ( ) ) ; if ( m_ Exp != null ) { if ( ! m_ Generator Property Panel . get Editor Active ( ) ) { m_ Exp . set Advance Data Set First ( _ BOOL ) ; } else { m_ Exp . set Advance Data Set First ( m_advance Data Set First . is Selected ( ) ) ; } } }
public static byte [ ] select (  String app Id ,  String suffix ) {  String cardlet Aid =  FIDESMO_ AID_ PREFIX + app Id + suffix ; return select ( cardlet Aid ) ; }
public  List <  Properties > find Available Properties (  String uri ) throws  IOException { _resources Not Loaded . clear ( ) ;  String fulluri = _path + uri ;  List <  Properties > properties = new  Array List < > ( ) ;  Enumeration <  URL > resources = get Resources ( fulluri ) ; while ( resources . has More Elements ( ) ) {  URL url = resources . next Element ( ) ; try {  Properties props = load Properties ( url ) ; properties . add ( props ) ; } catch (  Exception not Available ) { _resources Not Loaded . add ( url . to External Form ( ) ) ; } } return properties ; }
void internal Add Root Entry (  Project Comparison Entry entry ) { entries . add ( entry ) ; }
public static  Source from URL (  URL url ,  Charset cs ) throws  IOException {  URI uri ; try { uri = url . to URI ( ) ; } catch (  URISyntax Exception e ) { throw new  IOException ( _ STR , e ) ; } try (  Input Stream is = url . open Stream ( ) ) { return from Stream ( is , uri , cs ) ; } }
public void test Merge One Servlet Into Document With Another Servlet ( ) throws  Exception {  String src Xml = _ STR + _ STR + _ STR + _ STR + _ STR + _ STR ;  Web Xml src Web Xml =  Web Xml Io . parse Web Xml ( new  Byte Array Input Stream ( src Xml . get Bytes ( _ STR ) ) , null ) ;  String merge Xml = _ STR + _ STR + _ STR + _ STR + _ STR + _ STR ;  Web Xml merge Web Xml =  Web Xml Io . parse Web Xml ( new  Byte Array Input Stream ( merge Xml . get Bytes ( _ STR ) ) , null ) ;  Web Xml Merger merger = new  Web Xml Merger ( src Web Xml ) ; merger . merge ( merge Web Xml ) ; assert True (  Web Xml Utils . has Servlet ( src Web Xml , _ STR ) ) ; assert True (  Web Xml Utils . has Servlet ( src Web Xml , _ STR ) ) ; }
public  RE extract RE ( ) throws  Interrupted Exception { arden ( ) ; if ( ! coeffs . is Empty ( ) ) { throw new  Runtime Exception ( _ STR ) ; } return union REs ( terms ) ; }
public void add Result (  AMIdentity id ,  Map attrs ) { search Results . add ( id ) ; results Map . put ( id , attrs ) ; }
public <  T extends  Intention Action &  Local Quick Fix > void register Batch Fix ( @  Not Null  T fix , @  Nullable  Text Range range , @  Nullable final  Highlight Display Key key ) { if ( range == null ) { range = new  Text Range ( my Start Offset , my End Offset ) ; } if ( my Batch Fixes == null ) { my Batch Fixes = new  Array List <  Quick Fix Info > ( ) ; } my Batch Fixes . add ( new  Quick Fix Info ( fix , range , key ) ) ; }
protected void create File (  Zip Entry entry ) {  IPath pathname = new  Path ( entry . get Name ( ) ) ;  Zip Entry parent ; if ( pathname . segment Count ( ) == _ NUM ) { parent = root ; } else { parent = (  Zip Entry ) directory Entry Cache . get ( pathname . remove Last Segments ( _ NUM ) ) ; } add To Children ( parent , entry ) ; }
public void test Has Attributes1 ( ) throws  Throwable {  Document doc ;  Node List addr List ;  Node addr Node ; boolean state ; doc = (  Document ) load ( _ STR , builder ) ; addr List = doc . get Elements By Tag Name ( _ STR ) ; addr Node = addr List . item ( _ NUM ) ; state = addr Node . has Attributes ( ) ; assert False ( _ STR , state ) ; }
public void start Document (  XMLLocator locator ,  String encoding ,  Namespace Context namespace Context ,  Augmentations augs ) throws  XNIException { f Namespace Context = namespace Context ; try { if ( f Document Handler != null ) { if ( locator != null ) { f Document Handler . set Document Locator ( new  Locator Proxy ( locator ) ) ; } f Document Handler . start Document ( ) ; } if ( f Content Handler != null ) { if ( locator != null ) { f Content Handler . set Document Locator ( new  Locator Proxy ( locator ) ) ; } f Content Handler . start Document ( ) ; } } catch (  SAXException e ) { throw new  XNIException ( e ) ; } }
@  Override public  String dump Window Hierarchy ( boolean compressed ) { device . set Compressed Layout Heirarchy ( compressed ) ; try {  Byte Array Output Stream os = new  Byte Array Output Stream ( ) ; device . dump Window Hierarchy ( os ) ; os . close ( ) ; return os . to String ( _ STR ) ; } catch (  File Not Found Exception e ) { e . print Stack Trace ( ) ; } catch (  IOException e ) { e . print Stack Trace ( ) ; } finally { device . set Compressed Layout Heirarchy ( _ BOOL ) ; } return null ; }
public void register Observer (  Rule Changes Observer observer ) { observers . add ( observer ) ; }
private void send Update Heartbeats ( ) {  Heartbeat Service Local heartbeat = _bartender . get Heartbeat Local ( ) ; if ( heartbeat != null ) { heartbeat . update Heartbeats ( ) ; } }
public void serialize (  String name , byte [ ] message ,  Output Stream out ) throws  IOException { byte [ ] header = new byte [ _ NUM +  COMMAND_ LEN + _ NUM + _ NUM ] ; uint32 To Byte Array BE ( params . get Packet Magic ( ) , header , _ NUM ) ; for ( int i = _ NUM ; i < name . length ( ) && i <  COMMAND_ LEN ; i ++ ) { header [ _ NUM + i ] = ( byte ) ( name . code Point At ( i ) & _ NUM ) ; }  Utils . uint32 To Byte Array LE ( message . length , header , _ NUM +  COMMAND_ LEN ) ; byte [ ] hash = double Digest ( message ) ;  System . arraycopy ( hash , _ NUM , header , _ NUM +  COMMAND_ LEN + _ NUM , _ NUM ) ; out . write ( header ) ; out . write ( message ) ; if ( log . is Debug Enabled ( ) ) log . debug ( _ STR , name , bytes To Hex String ( header ) + bytes To Hex String ( message ) ) ; }
public  SSLEngine init Ssl Engine ( boolean client ) throws  Exception {  Key Store key Store = load Keystore ( properties . ssl Key Store Path ( ) , properties . ssl Key Store Password ( ) ) ;  Key Manager Factory key Manager Factory =  Key Manager Factory . get Instance (  Key Manager Factory . get Default Algorithm ( ) ) ; key Manager Factory . init ( key Store , key Store Key Pass ( properties ) ) ;  Key Store trust Store ; if ( properties . ssl Trust Store Path ( ) != null ) {  LOGGER . debug ( _ STR ) ; trust Store = load Keystore ( properties . ssl Trust Store Path ( ) , properties . ssl Trust Store Password ( ) ) ; } else { trust Store = key Store ;  LOGGER . debug ( _ STR ) ; }  Trust Manager Factory trust Manager Factory =  Trust Manager Factory . get Instance (  Trust Manager Factory . get Default Algorithm ( ) ) ; trust Manager Factory . init ( trust Store ) ;  Key Manager [ ] key Managers = key Manager Factory . get Key Managers ( ) ;  Trust Manager [ ] trust Managers = trust Manager Factory . get Trust Managers ( ) ;  SSLContext ssl Context =  SSLContext . get Instance ( _ STR ) ; ssl Context . init ( key Managers , trust Managers , null ) ;  SSLEngine ssl Engine = ssl Context . create SSLEngine ( ) ; ssl Engine . set Use Client Mode ( client ) ; ssl Engine . set Want Client Auth ( _ BOOL ) ; ssl Engine . set Enabled Protocols ( ssl Engine . get Supported Protocols ( ) ) ; ssl Engine . set Enabled Cipher Suites ( ssl Engine . get Supported Cipher Suites ( ) ) ; ssl Engine . set Enable Session Creation ( _ BOOL ) ; return ssl Engine ; }
public  Get Buffered Random Access Source (  IRandom Access Source source ) { this . source = source ; this . get Buffer = new byte [ ( int )  Math . min (  Math . max ( source . length ( ) / _ NUM , _ NUM ) , _ NUM ) ] ; this . get Buffer Start = - _ NUM ; this . get Buffer End = - _ NUM ; }
public  Arg Parser (  String p Name ) { program Name = p Name ; args = new  Vector ( ) ; args . add ( new  Help Arg ( ) ) ; }
public static  String convert Boolean Arr To String (  Boolean [ ] no Dictionary Dims Mapping ) {  String Builder builder = new  String Builder ( ) ; int index = _ NUM ; for ( ; index < no Dictionary Dims Mapping . length ; index ++ ) { builder . append ( no Dictionary Dims Mapping [ index ] ) ; builder . append (  Carbon Common Constants .  COMA_ SPC_ CHARACTER ) ; } int last Index = builder . last Index Of (  Carbon Common Constants .  COMA_ SPC_ CHARACTER ) ;  String str = - _ NUM != last Index ? builder . substring ( _ NUM , last Index ) : builder . to String ( ) ; return str ; }
@  Override protected void draw Axis Line (  Graphics2 D g2 , double cursor ,  Rectangle2 D data Area ,  Rectangle Edge edge ) {  Line2 D axis Line = null ; double c = cursor ; if ( edge ==  Rectangle Edge .  TOP ) { axis Line = new  Line2 D .  Double ( data Area . get X ( ) , c , data Area . get Max X ( ) , c ) ; } else if ( edge ==  Rectangle Edge .  BOTTOM ) { axis Line = new  Line2 D .  Double ( data Area . get X ( ) , c , data Area . get Max X ( ) , c ) ; } else if ( edge ==  Rectangle Edge .  LEFT ) { axis Line = new  Line2 D .  Double ( c , data Area . get Y ( ) , c , data Area . get Max Y ( ) ) ; } else if ( edge ==  Rectangle Edge .  RIGHT ) { axis Line = new  Line2 D .  Double ( c , data Area . get Y ( ) , c , data Area . get Max Y ( ) ) ; } g2 . set Paint ( get Axis Line Paint ( ) ) ; g2 . set Stroke ( get Axis Line Stroke ( ) ) ;  Object saved = g2 . get Rendering Hint (  Rendering Hints .  KEY_ STROKE_ CONTROL ) ; g2 . set Rendering Hint (  Rendering Hints .  KEY_ STROKE_ CONTROL ,  Rendering Hints .  VALUE_ STROKE_ NORMALIZE ) ; g2 . draw ( axis Line ) ; g2 . set Rendering Hint (  Rendering Hints .  KEY_ STROKE_ CONTROL , saved ) ; boolean draw Up Or Right = _ BOOL ; boolean draw Down Or Left = _ BOOL ; if ( this . positive Arrow Visible ) { if ( this . inverted ) { draw Down Or Left = _ BOOL ; } else { draw Up Or Right = _ BOOL ; } } if ( this . negative Arrow Visible ) { if ( this . inverted ) { draw Up Or Right = _ BOOL ; } else { draw Down Or Left = _ BOOL ; } } if ( draw Up Or Right ) { double x = _ NUM ; double y = _ NUM ;  Shape arrow = null ; if ( edge ==  Rectangle Edge .  TOP || edge ==  Rectangle Edge .  BOTTOM ) { x = data Area . get Max X ( ) ; y = cursor ; arrow = this . right Arrow ; } else if ( edge ==  Rectangle Edge .  LEFT || edge ==  Rectangle Edge .  RIGHT ) { x = cursor ; y = data Area . get Min Y ( ) ; arrow = this . up Arrow ; }  Affine Transform transformer = new  Affine Transform ( ) ; transformer . set To Translation ( x , y ) ;  Shape shape = transformer . create Transformed Shape ( arrow ) ; g2 . fill ( shape ) ; g2 . draw ( shape ) ; } if ( draw Down Or Left ) { double x = _ NUM ; double y = _ NUM ;  Shape arrow = null ; if ( edge ==  Rectangle Edge .  TOP || edge ==  Rectangle Edge .  BOTTOM ) { x = data Area . get Min X ( ) ; y = cursor ; arrow = this . left Arrow ; } else if ( edge ==  Rectangle Edge .  LEFT || edge ==  Rectangle Edge .  RIGHT ) { x = cursor ; y = data Area . get Max Y ( ) ; arrow = this . down Arrow ; }  Affine Transform transformer = new  Affine Transform ( ) ; transformer . set To Translation ( x , y ) ;  Shape shape = transformer . create Transformed Shape ( arrow ) ; g2 . fill ( shape ) ; g2 . draw ( shape ) ; } }
public static void save XStream (  File save To ,  Object model ,  Instances header ) throws  Exception {  Vector <  Object > v = new  Vector <  Object > ( ) ; v . add ( model ) ; if ( header != null ) { v . add ( header ) ; } v . trim To Size ( ) ;  XStream . write ( save To . get Absolute Path ( ) , v ) ; }
private void sort And Collapse ( ) {  Collections . sort ( m Spans ) ; m Adds Since Sort = _ NUM ;  Iterator iter = m Spans . iterator ( ) ;  Span span = null ; if ( iter . has Next ( ) ) { span = (  Span ) iter . next ( ) ; } while ( iter . has Next ( ) ) {  Span next Span = (  Span ) iter . next ( ) ; if ( span . subsume ( next Span ) ) { iter . remove ( ) ; } else { span = next Span ; } } }
public int split Randomly (  Array Modifiable DBIDs ind , int begin , int end ,  Double Data Store tpro ,  Random rand ) { final int nele = end - begin ;  DBIDArray Iter it = ind . iter ( ) ; double rs = tpro . double Value ( it . seek ( begin + rand . next Int ( nele ) ) ) ; int min Ind = begin , max Ind = end - _ NUM ; while ( min Ind < max Ind ) { double curr Ele = tpro . double Value ( it . seek ( min Ind ) ) ; if ( curr Ele > rs ) { while ( min Ind < max Ind && tpro . double Value ( it . seek ( max Ind ) ) > rs ) { max Ind -- ; } if ( min Ind == max Ind ) { break ; } ind . swap ( min Ind , max Ind ) ; max Ind -- ; } min Ind ++ ; } if ( min Ind == end - _ NUM ) { min Ind = ( begin + end ) > > > _ NUM ; } return min Ind ; }
public static  String no Prefix (  String path ,  String prefix ) {  Objects . require Non Null ( path , _ STR ) ;  Objects . require Non Null ( prefix , _ STR ) ; return path . starts With ( prefix ) ? path . substring ( prefix . length ( ) ) : path ; }
protected void publish ( ) throws  Mqtt Exception ,  IOException { sample Client Pub = new  Sample Async Callback ( url , client Id Pub , clean Session , quiet Mode , user Name , password ) ; if ( sample Client Pub != null ) {  String topic = _ STR ; int qos = _ NUM ;  String message = _ STR ; try { sample Client Pub . publish ( topic , qos , message . get Bytes ( ) ) ; } catch (  Throwable e ) { e . print Stack Trace ( ) ; } } }
public void remove (  IAdaptable a ) { children . remove ( a ) ; }
public static  Int Stream concat (  Int Stream a ,  Int Stream b ) {  Objects . require Non Null ( a ) ;  Objects . require Non Null ( b ) ;  Spliterator .  Of Int split = new  Streams .  Concat Spliterator .  Of Int ( a . spliterator ( ) , b . spliterator ( ) ) ;  Int Stream stream =  Stream Support . int Stream ( split , a . is Parallel ( ) || b . is Parallel ( ) ) ; return stream . on Close (  Streams . composed Close ( a , b ) ) ; }
public  Login Configuration force Auth (  String force Auth Req Param ) { force Auth =  Boolean . parse Boolean ( force Auth Req Param ) ; return this ; }
@  Method Desc ( description = _ STR , usage = _ STR ) public void stop ( ) throws  Exception { try { handle Event Synchronous ( new  Stop Event ( ) ) ; if ( done Latch != null ) { done Latch . count Down ( ) ; } } catch (  Exception e ) { logger . error ( _ STR , e ) ; throw new  Exception ( e . to String ( ) ) ; } }
public boolean write Characteristic (  String address ,  String service UUID ,  String characteristic UUID , byte [ ] value ) {  Bluetooth Gatt bluetooth Gatt = m Bluetooth Gatt Map . get ( address ) ; if ( bluetooth Gatt != null ) {  Bluetooth Gatt Service service = bluetooth Gatt . get Service (  UUID . from String ( service UUID ) ) ;  Bluetooth Gatt Characteristic characteristic = service . get Characteristic (  UUID . from String ( characteristic UUID ) ) ; characteristic . set Value ( value ) ; return bluetooth Gatt . write Characteristic ( characteristic ) ; } return _ BOOL ; }
public  String link For Message (  Proto Element element ) { if ( is External File ( element . get File ( ) ) ) {  String full Name = element . get Full Name ( ) ; return  String . format ( _ STR , full Name , full Name ) ; } else {  String simple Name = element . get Simple Name ( ) ; return  String . format ( _ STR , simple Name , simple Name ) ; } }
public static <  T >  Array List <  T > read (  Input Stream file Stream ,  String charset Name ,  ITransformer <  String ,  T > transformer ) throws  File Not Found Exception {  Scanner scanner = new  Scanner ( file Stream , charset Name ) ;  Array List <  T > list = new  Array List < > ( ) ; while ( scanner . has Next Line ( ) ) {  String line = scanner . next Line ( ) ; list . add ( transformer . transform ( line ) ) ; } scanner . close ( ) ; return list ; }
public boolean remove (  Json Element element ) { return elements . remove ( element ) ; }
public  TSink < byte [ ] > send Bytes (  TStream < byte [ ] > stream ) {  Objects . require Non Null ( stream , _ STR ) ; return send Binary ( stream , null ) ; }
private void sort Broker Items (  Broker Item [ ] broker Items , int sort Type ) {  Arrays . sort ( broker Items ,  Broker Item . get Comparatory By Type ( sort Type ) ) ; }
protected boolean need To Escape XMLSpecial Characters (  String host Entity ID ,  String remote Entity ID ,  String realm ) { return _ BOOL ; }
private void update Path Constraints (  Test Chromosome test ) {  List <  Branch Condition > path Condition =  Concolic Execution . get Symbolic Path ( test ) ; path Conditions . put ( test , path Condition ) ; }
public void test_journal_one Index No Data ( ) throws  IOException ,  Interrupted Exception ,  Execution Exception { final  File out =  File . create Temp File ( get Name ( ) ,  Options .  JNL ) ; try { final  Journal src = get Store ( get Properties ( ) ) ; try { final  String  NAME = _ STR ; src . register Index ( new  Index Metadata (  NAME ,  UUID . random UUID ( ) ) ) ; src . commit ( ) ; final  Future <  Journal > f = src . compact ( out ) ; final  Journal new Journal = f . get ( ) ; try { assert Not Null ( new Journal . get Index (  NAME ) ) ;  Abstract BTree Test Case . assert Same BTree ( src . get Index (  NAME ) , new Journal . get Index (  NAME ) ) ; } finally { new Journal . destroy ( ) ; } } finally { src . destroy ( ) ; } } finally { out . delete ( ) ; } }
public static boolean p2p Loader (  Class Loader ldr ) { return ldr instanceof  Grid Deployment Info ; }
private static  String remove Sub Trailers (  String decoded Subject ) { int sub String Start = _ NUM ; int sub String End = decoded Subject . length ( ) ; int original Size = decoded Subject . length ( ) ; int cur Pos = original Size - _ NUM ; while ( _ BOOL ) { char c = decoded Subject . char At ( cur Pos -- ) ; if ( c ==  WS ) { sub String End -- ; } else { if ( sub String End >  FWD_ PARENS . length ( ) && decoded Subject . ends With (  FWD_ PARENS ) ) { sub String End -=  FWD_ PARENS . length ( ) ; } break ; } } decoded Subject = decoded Subject . substring ( sub String Start , sub String End ) ; return decoded Subject ; }
boolean next Source ( ) throws  IOException { if ( m Source It . has Next ( ) ) { final  Input Stream is = m Source It . next ( ) ; if ( is == null ) { m Source = null ; return _ BOOL ; } else { m Source = new  Buffered Input Stream ( is ,  File Utils .  BUFFERED_ STREAM_ SIZE ) ; } m Source Closed = _ BOOL ; m Input Buffer Position = _ NUM ; m Input Buffer Length = _ NUM ; m Buffer Length = _ NUM ; m Buffer Position = _ NUM ; return _ BOOL ; } if ( m Source != null ) { m Source . close ( ) ; } m Source = null ; return _ BOOL ; }
public static byte [ ] bitmap To Bytes (  Bitmap bm ) { byte [ ] bytes = null ; if ( bm != null ) {  Byte Array Output Stream baos = new  Byte Array Output Stream ( ) ; bm . compress (  Bitmap .  Compress Format .  PNG , _ NUM , baos ) ; bytes = baos . to Byte Array ( ) ; } return bytes ; }
public static  String inflate (  String name ) { return inflate ( name , g Prefix ) ; }
public void add Priority Handler (  Warning Handler handler ) { _priority Handlers . add ( handler ) ; }
private void write Attr (  String name ,  String val ) throws  IOException { write Attr ( name , val , _ BOOL ) ; }
final private  String syntax Def2 Syntax Desc (  Attributes attrs ) throws  Naming Exception {  String Buffer syntax Desc = new  String Buffer ( _ STR ) ;  Attribute attr = null ; int count = _ NUM ; attr = attrs . get (  NUMERICOID_ ID ) ; if ( attr != null ) { syntax Desc . append ( write Numeric OID ( attr ) ) ; count ++ ; } else { throw new  Configuration Exception ( _ STR + _ STR ) ; } attr = attrs . get (  DESC_ ID ) ; if ( attr != null ) { syntax Desc . append ( write QDString ( attr ) ) ; count ++ ; } if ( count < attrs . size ( ) ) {  String attr Id = null ; for (  Naming Enumeration < ? extends  Attribute > ae = attrs . get All ( ) ; ae . has More Elements ( ) ; ) { attr = ae . next ( ) ; attr Id = attr . get ID ( ) ; if ( attr Id . equals (  NUMERICOID_ ID ) || attr Id . equals (  DESC_ ID ) ) { continue ; } else { syntax Desc . append ( write QDStrings ( attr ) ) ; } } } syntax Desc . append ( _ STR ) ; return syntax Desc . to String ( ) ; }
@  Override public void write (  Buffer buffer , boolean is End ) throws  IOException { if ( _s == null ) { buffer . free ( ) ; return ; } try { _needs Flush = _ BOOL ; if ( buffer . is Direct ( ) ) { _total Write Bytes += buffer . length ( ) ; _s . write ( buffer . direct ( ) ) ; return ; } _total Write Bytes += buffer . length ( ) ; while ( buffer . length ( ) > _ NUM ) { _write Buffer . clear ( ) ; buffer . read ( _write Buffer ) ; _write Buffer . flip ( ) ; _s . write ( _write Buffer ) ; } } catch (  IOException e ) {  IOException exn =  Client Disconnect Exception . create ( this + _ STR + e , e ) ; try { close ( ) ; } catch (  IOException e1 ) { } throw exn ; } finally { buffer . free ( ) ; } }
private static void skip Member Value ( int tag ,  Byte Buffer buf ) { switch ( tag ) { case _ STR : buf . get Int ( ) ; break ; case _ STR : skip Annotation ( buf , _ BOOL ) ; break ; case _ STR : skip Array ( buf ) ; break ; default : buf . get Short ( ) ; } }
protected void recursive Nested Join (  Event Bean lookup Event , int nesting Order Index ,  Event Bean [ ] current Path ,  Collection <  Event Bean [ ] > result ,  Expr Evaluator Context expr Evaluator Context ) {  List <  Event Bean [ ] > nested Result = new  Linked List <  Event Bean [ ] > ( ) ;  Exec Node nested Exec Node = child Nodes . get ( nesting Order Index ) ; nested Exec Node . process ( lookup Event , current Path , nested Result , expr Evaluator Context ) ; boolean is Last Stream = ( nesting Order Index == nesting Order Length - _ NUM ) ; if ( ! is Last Stream ) { for (  Event Bean [ ] row : nested Result ) {  Event Bean lookup = row [ nested Streams [ nesting Order Index ] ] ; recursive Nested Join ( lookup , nesting Order Index + _ NUM , row , result , expr Evaluator Context ) ; } return ; } for (  Event Bean [ ] row : nested Result ) { result . add ( row ) ; } }
public  String generate Minimal MATSim Config ( ) {  Config config = new  Config ( ) ;  Config Group ippcm = config . create Module (  Matrix Based Pt Router Config Group .  GROUP_ NAME ) ; ippcm . add Param (  Matrix Based Pt Router Config Group .  PT_ STOPS , this . pt Stops ) ; ippcm . add Param (  Matrix Based Pt Router Config Group .  USING_ PT_ STOPS , _ STR ) ; ippcm . add Param (  Matrix Based Pt Router Config Group .  PT_ TRAVEL_ TIMES_ AND_ DISTANCES_ SWITCH , this . use Travel Times And Distances ) ;  Change Mode Config Group change Mode Config =  Config Utils . add Or Get Module ( config ,  Change Mode Config Group .  CONFIG_ MODULE ,  Change Mode Config Group . class ) ;  String [ ] str = { _ STR , _ STR } ; change Mode Config . set Modes ( str ) ; return write Config File ( config ) ; }
private int convert Location To Column ( int x , int y ) { if ( cell Width > _ NUM ) { if ( layout Orientation ==  JList .  VERTICAL ) { return _ NUM ; }  Insets insets = list . get Insets ( ) ; int col ; if ( is Left To Right ) { col = ( x - insets . left ) / cell Width ; } else { col = ( list . get Width ( ) - x - insets . right - _ NUM ) / cell Width ; } if ( col < _ NUM ) { return _ NUM ; } else if ( col >= column Count ) { return column Count - _ NUM ; } return col ; } return _ NUM ; }
public static  List <  File > find Files In Dir (  File directory ,  Filename Filter filter ) {  Vector <  File > files = new  Vector <  File > ( ) ;  File [ ] entries = directory . list Files ( ) ; for (  File entry : entries ) { if ( filter == null || filter . accept ( directory , entry . get Name ( ) ) ) { files . add ( entry ) ; } if ( entry . is Directory ( ) ) { files . add All ( find Files In Dir ( entry , filter ) ) ; } } return files ; }
public  String generate Drop (  String table ) {  String Buffer result = new  String Buffer ( ) ; result . append ( _ STR ) ; result . append ( table ) ; result . append ( _ STR ) ; return result . to String ( ) ; }
private void register Child Listeners ( ) {  Iterator <  Property Change Listener > iter = f Child Listeners . iterator ( ) ; while ( iter . has Next ( ) ) {  Property Change Listener listener = iter . next ( ) ; listener . register ( ) ; } }
private void refresh Index For Dimension Fields (  String row Id ,  Dimension Row dimension Row ,  Dimension Row dimension Row Old ) { try { for (  Dimension Field field : dimension . get Dimension Fields ( ) ) { if ( field == dimension . get Key ( ) ) { continue ; } if ( dimension Row Old != null ) {  String old Row Value = dimension Row Old . get ( field ) ;  String old Row Value Key =  Dimension Store Key Utils . get Row Key ( field . get Name ( ) , old Row Value ) ;  String old Row Values Keys Json = key Value Store . get ( old Row Value Key ) ;  String [ ] old Row Value SKeys = object Mapper . read Value ( old Row Values Keys Json ,  String [ ] . class ) ;  Set <  String > old Row Values Key Set = new  Linked Hash Set < > (  Arrays . as List ( old Row Value SKeys ) ) ; old Row Values Key Set . remove ( row Id ) ; if ( old Row Values Key Set . is Empty ( ) ) { key Value Store . remove ( old Row Value Key ) ; } else {  String updated Old Row Value SKeys = object Mapper . write Value As String ( old Row Values Key Set ) ; key Value Store . put ( old Row Value Key , updated Old Row Value SKeys ) ; } }  String row Value = dimension Row . get ( field ) ;  String row Value Key =  Dimension Store Key Utils . get Row Key ( field . get Name ( ) , row Value ) ;  String row Value SKeys = key Value Store . get ( row Value Key ) ;  Set <  String > row Value SKey Set = new  Linked Hash Set < > ( ) ; if ( row Value SKeys != null ) { row Value SKey Set . add All (  Arrays . as List ( object Mapper . read Value ( row Value SKeys ,  String [ ] . class ) ) ) ; } row Value SKey Set . add ( row Id ) ;  String updated Row Value SKeys = object Mapper . write Value As String ( row Value SKey Set ) ; key Value Store . put ( row Value Key , updated Row Value SKeys ) ; } } catch (  IOException e ) {  LOG . error ( _ STR , e ) ; throw new  Runtime Exception ( e ) ; } }
public  List <  Instruction > reduce Instructions ( final  List <  Instruction > instructions ) { lock . lock ( ) ; try { this . instructions = instructions ; stack Size Simulator . build Stack Sizes ( instructions ) ; return reduce Instructions Internal ( instructions ) ; } finally { lock . unlock ( ) ; } }
protected boolean is Locked Locally (  UUID new Owner ID ) { return this Node . equals ( get Owner Node ( ) ) || this Node . equals ( new Owner ID ) ; }
public void test Compare Neg Neg2 ( ) { byte a Bytes [ ] = { _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM } ; byte b Bytes [ ] = { _ NUM , _ NUM , _ NUM , - _ NUM , - _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , - _ NUM , _ NUM , _ NUM , _ NUM , _ NUM } ; int a Sign = - _ NUM ; int b Sign = - _ NUM ;  Big Integer a Number = new  Big Integer ( a Sign , a Bytes ) ;  Big Integer b Number = new  Big Integer ( b Sign , b Bytes ) ; assert Equals ( _ NUM , a Number . compare To ( b Number ) ) ; }
public void delete Point ( int position ) { int render Type = poly . get Render Type ( ) ;  Projection proj = get Projection ( ) ; boolean need To Hook Up = _ BOOL ; if ( position <= _ NUM && is Enclosed ( ) ) { enclose ( _ BOOL ) ; need To Hook Up = _ BOOL ; } if ( render Type ==  OMGraphic .  RENDERTYPE_ LATLON ) {  Debug . message ( _ STR , _ STR ) ; if ( proj != null ) { double [ ] ll = poly . get Lat Lon Array ( ) ; double [ ] newll = new double [ ll . length - _ NUM ] ; int actual Position = ( position ==  Integer .  MAX_ VALUE ? ll . length : position * _ NUM ) ; if ( actual Position >= ll . length ) {  System . arraycopy ( ll , _ NUM , newll , _ NUM , ll . length - _ NUM ) ; position = ( ll . length - _ NUM ) / _ NUM ; } else if ( actual Position <= _ NUM ) {  System . arraycopy ( ll , _ NUM , newll , _ NUM , ll . length - _ NUM ) ; position = _ NUM ; } else {  System . arraycopy ( ll , _ NUM , newll , _ NUM , actual Position ) ;  System . arraycopy ( ll , actual Position + _ NUM , newll , actual Position , ll . length - actual Position - _ NUM ) ; } poly . set Location ( newll , poly . get Units ( ) ) ; } } else {  Debug . message ( _ STR , _ STR ) ; int current Length = poly . xs . length ; int [ ] newxs = new int [ current Length - _ NUM ] ; int [ ] newys = new int [ current Length - _ NUM ] ; if ( position >= current Length ) {  System . arraycopy ( poly . xs , _ NUM , newxs , _ NUM , current Length - _ NUM ) ;  System . arraycopy ( poly . ys , _ NUM , newys , _ NUM , current Length - _ NUM ) ; position = current Length - _ NUM ; } else if ( position <= _ NUM ) {  System . arraycopy ( poly . xs , _ NUM , newxs , _ NUM , current Length - _ NUM ) ;  System . arraycopy ( poly . ys , _ NUM , newys , _ NUM , current Length - _ NUM ) ; position = _ NUM ; } else {  System . arraycopy ( poly . xs , _ NUM , newxs , _ NUM , position ) ;  System . arraycopy ( poly . xs , position + _ NUM , newxs , position , current Length - position - _ NUM ) ;  System . arraycopy ( poly . ys , _ NUM , newys , _ NUM , position ) ;  System . arraycopy ( poly . ys , position + _ NUM , newys , position , current Length - position - _ NUM ) ; } if ( poly . get Render Type ( ) ==  OMGraphic .  RENDERTYPE_ OFFSET ) { poly . set Location ( poly . lat , poly . lon , poly . get Units ( ) , newxs , newys ) ; } else { poly . set Location ( newxs , newys ) ; } } if ( proj != null ) { poly . regenerate ( proj ) ; }  Grab Point gp = (  Grab Point ) poly Grab Points . remove ( position ) ; if ( gpo != null && gp != null ) { gpo . remove Grab Point ( gp ) ; } if ( need To Hook Up ) { enclose ( _ BOOL ) ; } }
@  Override public boolean delete Left Word ( ) { m Input Connection . begin Batch Edit ( ) ; if ( m Input Connection . get Selected Text ( _ NUM ) != null ) { m Input Connection . commit Text ( _ STR , _ NUM ) ; } else {  Char Sequence before Cursor = m Input Connection . get Text Before Cursor (  MAX_ DELETABLE_ CONTEXT , _ NUM ) ; if ( before Cursor != null ) { int before Cursor Length = before Cursor . length ( ) ;  Matcher m =  WHITESPACE_ AND_ TOKEN . matcher ( before Cursor ) ; int last Index = _ NUM ; while ( m . find ( ) ) { last Index = before Cursor Length == m . end ( ) ? m . start ( ) : m . end ( ) ; } if ( last Index > _ NUM ) { m Input Connection . delete Surrounding Text ( before Cursor Length - last Index , _ NUM ) ; } else if ( before Cursor Length <  MAX_ DELETABLE_ CONTEXT ) { m Input Connection . delete Surrounding Text ( before Cursor Length , _ NUM ) ; } } } m Input Connection . end Batch Edit ( ) ; return _ BOOL ; }
public static double cdf ( double val , double rate ) { if ( val < _ NUM ) { return _ NUM ; } return _ NUM -  Math . exp ( - rate * val ) ; }
public static  Data Set read Continuous (  File file , char delimiter ) throws  IOException { return read In Continuous Data ( file , delimiter ,  Collections . singleton ( _ STR ) ) ; }
public static  String generate Native Guid For Storage Port From Indication (  String source Instance System Name ,  String port Network Id ) {  String [ ] splited String = source Instance System Name . split (  Constants .  PATH_ DELIMITER_ REGEX ) ; return  String . format ( _ STR , splited String [ _ NUM ] , splited String [ _ NUM ] , port Network Id ) ; }
protected boolean are Paths Contiguous (  Tree Path [ ] paths ) { if ( row Mapper == null || paths . length < _ NUM ) return _ BOOL ; else {  Bit Set bit Set = new  Bit Set ( _ NUM ) ; int an Index , counter , min ; int path Count = paths . length ; int valid Count = _ NUM ;  Tree Path [ ] temp Path = new  Tree Path [ _ NUM ] ; temp Path [ _ NUM ] = paths [ _ NUM ] ; min = row Mapper . get Rows For Paths ( temp Path ) [ _ NUM ] ; for ( counter = _ NUM ; counter < path Count ; counter ++ ) { if ( paths [ counter ] != null ) { temp Path [ _ NUM ] = paths [ counter ] ; int [ ] rows = row Mapper . get Rows For Paths ( temp Path ) ; if ( rows == null ) { return _ BOOL ; } an Index = rows [ _ NUM ] ; if ( an Index == - _ NUM || an Index < ( min - path Count ) || an Index > ( min + path Count ) ) return _ BOOL ; if ( an Index < min ) min = an Index ; if ( ! bit Set . get ( an Index ) ) { bit Set . set ( an Index ) ; valid Count ++ ; } } } int max Counter = valid Count + min ; for ( counter = min ; counter < max Counter ; counter ++ ) if ( ! bit Set . get ( counter ) ) return _ BOOL ; } return _ BOOL ; }
public  Fast String Reader (  String s ) { this . str = s ; this . length = s . length ( ) ; }
static void update Style (  JText Component c ,  Sea Glass Context context ,  String prefix ) {  Sea Glass Style style = (  Sea Glass Style ) context . get Style ( ) ;  Color color = c . get Caret Color ( ) ; if ( color == null || color instanceof  UIResource ) { c . set Caret Color ( (  Color ) style . get ( context , prefix + _ STR ) ) ; }  Color fg = c . get Foreground ( ) ; if ( fg == null || fg instanceof  UIResource ) { fg = style . get Color For State ( context ,  Color Type .  TEXT_ FOREGROUND ) ; if ( fg != null ) { c . set Foreground ( fg ) ; } }  Object ar = style . get ( context , prefix + _ STR ) ; if ( ar instanceof  Number ) { c . put Client Property ( _ STR , ar ) ; } context . set Component State (  SELECTED |  FOCUSED ) ;  Color s = c . get Selection Color ( ) ; if ( s == null || s instanceof  UIResource ) { c . set Selection Color ( style . get Color ( context ,  Color Type .  TEXT_ BACKGROUND ) ) ; }  Color sfg = c . get Selected Text Color ( ) ; if ( sfg == null || sfg instanceof  UIResource ) { c . set Selected Text Color ( style . get Color ( context ,  Color Type .  TEXT_ FOREGROUND ) ) ; } context . set Component State (  DISABLED ) ;  Color dfg = c . get Disabled Text Color ( ) ; if ( dfg == null || dfg instanceof  UIResource ) { c . set Disabled Text Color ( style . get Color ( context ,  Color Type .  TEXT_ FOREGROUND ) ) ; }  Insets margin = c . get Margin ( ) ; if ( margin == null || margin instanceof  UIResource ) { margin = (  Insets ) style . get ( context , prefix + _ STR ) ; if ( margin == null ) { margin =  Sea Glass Look And Feel .  EMPTY_ UIRESOURCE_ INSETS ; } c . set Margin ( margin ) ; }  Caret caret = c . get Caret ( ) ; if ( caret instanceof  UIResource ) {  Object o = style . get ( context , prefix + _ STR ) ; if ( o != null && o instanceof  Integer ) {  Integer rate = (  Integer ) o ; caret . set Blink Rate ( rate . int Value ( ) ) ; } } }
@  Suppress Lint ( _ STR ) @  Override protected void on Measure ( int width Measure Spec , int height Measure Spec ) { int width Mode =  Measure Spec . get Mode ( width Measure Spec ) ; int height Mode =  Measure Spec . get Mode ( height Measure Spec ) ; int max Width =  Measure Spec . get Size ( width Measure Spec ) ; int max Height =  Measure Spec . get Size ( height Measure Spec ) ; if ( width Mode ==  Measure Spec .  UNSPECIFIED ) max Width =  Integer .  MAX_ VALUE ; if ( height Mode ==  Measure Spec .  UNSPECIFIED ) max Height =  Integer .  MAX_ VALUE ; int padding Left = get Padding Left ( ) ; int padding Top = get Padding Top ( ) ; int padding Right = get Padding Right ( ) ; int padding Bottom = get Padding Bottom ( ) ; int max Right Bound = max Width - padding Right ; int max Bottom Bound = max Height - padding Bottom ; int left ; int top ; int right ; int bottom ; int right Bound = padding Left ; int max Right No Padding = right Bound ; int bottom Bound ; int last Max Bottom = padding Top ; int max Bottom = last Max Bottom ; int child Width ; int child Height ; int line Start Index = _ NUM ; int line End Index = _ NUM ; rect List . clear ( ) ; int child Count = get Child Count ( ) ; for ( int index = _ NUM ; index < child Count ; index ++ ) { final  View child = get Child At ( index ) ; child . measure (  Measure Spec .  UNSPECIFIED ,  Measure Spec .  UNSPECIFIED ) ; if ( child . get Visibility ( ) ==  View .  GONE ) continue ; final  Auto Wrap Layout .  Layout Params lp = (  Auto Wrap Layout .  Layout Params ) child . get Layout Params ( ) ; child Width = child . get Measured Width ( ) ; child Height = child . get Measured Height ( ) ; left = right Bound + lp . left Margin ; right = left + child Width ; right Bound = right + lp . right Margin ; if ( right Bound > max Right Bound ) { line End Index = index ; adjust Base Line ( max Bottom - last Max Bottom , line Start Index , line End Index ) ; if ( max Bottom >= max Bottom Bound ) break ; if ( line End Index == line Start Index ) { child . measure (  Measure Spec . make Measure Spec ( max Width - padding Left - padding Right - lp . left Margin - lp . right Margin ,  Measure Spec .  AT_ MOST ) ,  Measure Spec .  UNSPECIFIED ) ; child Width = child . get Measured Width ( ) ; child Height = child . get Measured Height ( ) ; } left = padding Left + lp . left Margin ; right = left + child Width ; right Bound = right + lp . right Margin ; last Max Bottom = max Bottom ; top = last Max Bottom + lp . top Margin ; bottom = top + child Height ; bottom Bound = bottom + lp . bottom Margin ; line Start Index = index ; } else { top = last Max Bottom + lp . top Margin ; bottom = top + child Height ; bottom Bound = bottom + lp . bottom Margin ; } if ( right Bound > max Right No Padding ) max Right No Padding = right Bound ; if ( bottom Bound > max Bottom ) max Bottom = bottom Bound ;  Rect rect = new  Rect ( ) ; rect . left = left ; rect . top = top ; rect . right = right ; rect . bottom = bottom ; rect List . add ( rect ) ; } adjust Base Line ( max Bottom - last Max Bottom , line Start Index , rect List . size ( ) ) ; int measured Width ; int measured Height ; if ( width Mode ==  Measure Spec .  EXACTLY ) measured Width = max Width ; else measured Width = max Right No Padding + padding Right ; if ( height Mode ==  Measure Spec .  EXACTLY ) measured Height = max Height ; else { measured Height = max Bottom + padding Bottom ; if ( height Mode ==  Measure Spec .  AT_ MOST ) measured Height = measured Height > max Height ? max Height : measured Height ; } set Measured Dimension ( measured Width , measured Height ) ; }
public final void wait ( ) throws java . lang .  Interrupted Exception { wait ( _ NUM ) ; }
public  Query String Query Builder field (  String field , float boost ) { if ( fields == null ) { fields = new  Array List < > ( ) ; } fields . add ( field ) ; if ( fields Boosts == null ) { fields Boosts = new  Object Float Hash Map < > ( ) ; } fields Boosts . put ( field , boost ) ; return this ; }
protected void init Stream Buffer Size ( ) {  String stream Buffer Size Param = get Init Parameter ( _ STR ) ; set Stream Buffer Size ( ( stream Buffer Size Param == null ) ?  DEFAULT_ STREAM_ BUFFER_ SIZE :  Integer . parse Int ( stream Buffer Size Param ) ) ; if ( is Debug ( ) ) { log ( _ STR + get Stream Buffer Size ( ) ) ; } }
public void register Sensor (  Sensor s , int i ) { if ( ( i < _ NUM ) || ( i > ( ( num Input Cards ( ) * bits Per Card ) - _ NUM ) ) || ( i >  MAXSENSORS ) ) { log . error ( _ STR +  Integer . to String ( i + _ NUM ) ) ; return ; } has Active Sensors = _ BOOL ; if ( sensor Array [ i ] == null ) { sensor Array [ i ] = s ; if ( last Used Sensor < i ) { last Used Sensor = i ; } } else { log . warn ( _ STR +  Integer . to String ( ( get Node Address ( ) *  Serial Sensor Manager .  SENSORSPERUA ) + i + _ NUM ) ) ; } }
public static  Number as Number (  String value ,  Supplier <  Number > default Value Provider ) { if ( value != null ) { try { return  Short . value Of ( value ) ; } catch (  Number Format Exception e1 ) { try { return  Integer . value Of ( value ) ; } catch (  Number Format Exception e2 ) { try { return  Long . value Of ( value ) ; } catch (  Number Format Exception e3 ) { try { return  Float . value Of ( value ) ; } catch (  Number Format Exception e4 ) { try { return  Double . value Of ( value ) ; } catch (  Number Format Exception e5 ) { try { return new  Big Integer ( value ) ; } catch (  Number Format Exception e6 ) { try { return new  Big Decimal ( value ) ; } catch (  Number Format Exception e7 ) { } } } } } } } } return default Value Provider != null ? default Value Provider . get ( ) : null ; }
public final void sample ( ) { long sum = _sum . get And Set ( _ NUM ) ; int count = _count . get And Set ( _ NUM ) ; if ( count != _ NUM ) _value = sum / ( double ) count ; else _value = _ NUM ; }
private  String apply Replacement ( final  Bidi Map replacement ,  String contents ) { for (  Object key : replacement . key Set ( ) ) {  String attribute Name = (  String ) key ;  String attribute Initials = (  String ) replacement . get ( key ) ; contents = contents . replace All (  JSONSerialisation . json Attribute Name ( attribute Name ) ,  JSONSerialisation . json Attribute Name ( attribute Initials ) ) ; } return contents ; }
public  Key Impl (  Kerberos Principal principal , char [ ] password ,  String algorithm ) { try {  Principal Name princ = new  Principal Name ( principal . get Name ( ) ) ;  Encryption Key key = new  Encryption Key ( password , princ . get Salt ( ) , algorithm ) ; this . key Bytes = key . get Bytes ( ) ; this . key Type = key . get EType ( ) ; } catch (  Krb Exception e ) { throw new  Illegal Argument Exception ( e . get Message ( ) ) ; } }
public static  Annotation Binding [ ] add Standard Annotations (  Annotation Binding [ ] recorded Annotations , long annotation Tag Bits ,  Lookup Environment env ) { int count = _ NUM ; if ( ( annotation Tag Bits &  Tag Bits .  Annotation Target MASK ) != _ NUM ) count ++ ; if ( ( annotation Tag Bits &  Tag Bits .  Annotation Retention MASK ) != _ NUM ) count ++ ; if ( ( annotation Tag Bits &  Tag Bits .  Annotation Deprecated ) != _ NUM ) count ++ ; if ( ( annotation Tag Bits &  Tag Bits .  Annotation Documented ) != _ NUM ) count ++ ; if ( ( annotation Tag Bits &  Tag Bits .  Annotation Inherited ) != _ NUM ) count ++ ; if ( ( annotation Tag Bits &  Tag Bits .  Annotation Override ) != _ NUM ) count ++ ; if ( ( annotation Tag Bits &  Tag Bits .  Annotation Suppress Warnings ) != _ NUM ) count ++ ; if ( ( annotation Tag Bits &  Tag Bits .  Annotation Polymorphic Signature ) != _ NUM ) count ++ ; if ( ( annotation Tag Bits &  Tag Bits .  Annotation Safe Varargs ) != _ NUM ) count ++ ; if ( count == _ NUM ) return recorded Annotations ; int index = recorded Annotations . length ;  Annotation Binding [ ] result = new  Annotation Binding [ index + count ] ;  System . arraycopy ( recorded Annotations , _ NUM , result , _ NUM , index ) ; if ( ( annotation Tag Bits &  Tag Bits .  Annotation Target MASK ) != _ NUM ) result [ index ++ ] = build Target Annotation ( annotation Tag Bits , env ) ; if ( ( annotation Tag Bits &  Tag Bits .  Annotation Retention MASK ) != _ NUM ) result [ index ++ ] = build Retention Annotation ( annotation Tag Bits , env ) ; if ( ( annotation Tag Bits &  Tag Bits .  Annotation Deprecated ) != _ NUM ) result [ index ++ ] = build Marker Annotation (  Type Constants .  JAVA_ LANG_ DEPRECATED , env ) ; if ( ( annotation Tag Bits &  Tag Bits .  Annotation Documented ) != _ NUM ) result [ index ++ ] = build Marker Annotation (  Type Constants .  JAVA_ LANG_ ANNOTATION_ DOCUMENTED , env ) ; if ( ( annotation Tag Bits &  Tag Bits .  Annotation Inherited ) != _ NUM ) result [ index ++ ] = build Marker Annotation (  Type Constants .  JAVA_ LANG_ ANNOTATION_ INHERITED , env ) ; if ( ( annotation Tag Bits &  Tag Bits .  Annotation Override ) != _ NUM ) result [ index ++ ] = build Marker Annotation (  Type Constants .  JAVA_ LANG_ OVERRIDE , env ) ; if ( ( annotation Tag Bits &  Tag Bits .  Annotation Suppress Warnings ) != _ NUM ) result [ index ++ ] = build Marker Annotation (  Type Constants .  JAVA_ LANG_ SUPPRESSWARNINGS , env ) ; if ( ( annotation Tag Bits &  Tag Bits .  Annotation Polymorphic Signature ) != _ NUM ) result [ index ++ ] = build Marker Annotation For Member Type (  Type Constants .  JAVA_ LANG_ INVOKE_ METHODHANDLE_$_ POLYMORPHICSIGNATURE , env ) ; if ( ( annotation Tag Bits &  Tag Bits .  Annotation Safe Varargs ) != _ NUM ) result [ index ++ ] = build Marker Annotation (  Type Constants .  JAVA_ LANG_ SAFEVARARGS , env ) ; return result ; }
public static void process (  List <  Packages > pkg List ) throws  Exception { init ( ) ;  String [ ] temps = templates . split ( _ STR ) ;  String [ ] vm Files = new  String [ temps . length ] ; for ( int i = _ NUM ; i < temps . length ; i ++ ) { vm Files [ i ] = temps [ i ] + _ STR ; } for (  Packages pkg : pkg List ) { for (  String vm File : vm Files ) { generator ( vm File , pkg ) ; } } }
public boolean check ( final  Direction dir , final boolean facing ) { if ( this . dir != dir ) { return _ BOOL ; } if ( this . facing != facing ) { return _ BOOL ; } final long now =  System . current Time Millis ( ) ; if ( now >= expiration ) { return _ BOOL ; } expiration = now +  DELAY ; return _ BOOL ; }
private void parse (  String path ) throws  Exception { if ( path != null ) { count = path . length ( ) ; data = new char [ count ] ; path . get Chars ( _ NUM , count , data , _ NUM ) ; } path ( ) ; }
protected synchronized void read Dont Verify ( ) throws  IOException ,  File Encryption Exception { if ( backing Random Access File . length ( ) < header Size ( ) ) { throw new  File Encryption Exception ( _ STR ) ; } long oldpos = backing Random Access File . get File Pointer ( ) ; backing Random Access File . seek ( _ NUM ) ; byte [ ] header_data = new byte [ header Size ( ) -  File Header .  AUTH_ TAG_ SIZE ] ; backing Random Access File . read ( header_data ) ; backing Random Access File . seek ( oldpos ) ;  Data Input Stream istream = new  Data Input Stream ( new  Byte Array Input Stream ( header_data ) ) ; byte [ ] tmpmagic = new byte [  PANBOX_ FILE_ MAGIC . length ] ; istream . read ( tmpmagic ) ; if ( !  Arrays . equals ( tmpmagic ,  PANBOX_ FILE_ MAGIC ) ) { throw new  File Encryption Exception ( _ STR ) ; } byte [ ] tmpversion = new byte [  PANBOX_ FILE_ VERSION . length ] ; istream . read ( tmpversion ) ; if ( !  Arrays . equals ( tmpversion ,  PANBOX_ FILE_ VERSION ) ) { throw new  File Encryption Exception ( _ STR +  PANBOX_ FILE_ VERSION . to String ( ) ) ; } this . share Key Version = istream . read Int ( ) ; istream . close ( ) ; }
private boolean is Media Type Supported (  String media ) { for ( int i = _ NUM ; i <  SUPPORTED_ MEDIA_ TYPES . length ; i ++ ) { if ( media . equals Ignore Case (  SUPPORTED_ MEDIA_ TYPES [ i ] ) ) { return _ BOOL ; } } return _ BOOL ; }
private void export_dependencies (  JCas jcas ) { dependencies = new  Linked Hash Map <  Token ,  List <  Dependency > > ( ) ;  List <  Token > non Governed = new  Array List <  Token > ( nodes . key Set ( ) ) ; for (  Dependency dependency : select ( jcas ,  Dependency . class ) ) {  Token governor = dependency . get Governor ( ) ;  Token dependent = dependency . get Dependent ( ) ;  List <  Dependency > l = dependencies . get ( governor ) ; if ( l == null ) { dependencies . put ( governor , new  Array List <  Dependency > ( ) ) ; l = dependencies . get ( governor ) ; } l . add ( dependency ) ; non Governed . remove ( dependent ) ; } for (  Token t : non Governed ) { traverse Dependents ( t , _ STR , - _ NUM ) ; write To File ( _ STR , component Id , _ STR , _ STR , _ STR ) ; component Id ++ ; } }
public static boolean is Network Available (  Context context ) {  Connectivity Manager connectivity Manager = (  Connectivity Manager ) context . get System Service (  Context .  CONNECTIVITY_ SERVICE ) ;  Network Info info = connectivity Manager . get Active Network Info ( ) ; return info != null && info . is Connected ( ) ; }
public static  String random Regexpish String (  Random r ) { return random Regexpish String ( r , _ NUM ) ; }
public  List <  Expected Partition Value Entity > create Expected Partition Value Entities (  String partition Key Group Name ,  List <  String > expected Partition Values ) {  Partition Key Group Entity partition Key Group Entity = partition Key Group Dao . get Partition Key Group By Name ( partition Key Group Name ) ; if ( partition Key Group Entity == null ) { partition Key Group Entity = partition Key Group Dao Test Helper . create Partition Key Group Entity ( partition Key Group Name ) ; }  List <  Expected Partition Value Entity > expected Partition Value Entities = new  Array List < > ( ) ; for (  String expected Partition Value : expected Partition Values ) {  Expected Partition Value Entity expected Partition Value Entity = new  Expected Partition Value Entity ( ) ; expected Partition Value Entity . set Partition Key Group ( partition Key Group Entity ) ; expected Partition Value Entity . set Partition Value ( expected Partition Value ) ; expected Partition Value Entities . add ( expected Partition Value Dao . save And Refresh ( expected Partition Value Entity ) ) ; } return expected Partition Value Entities ; }
public  String to String ( ) { return text ( ) ; }
public static  Low Memory Watcher register ( @  Not Null  Runnable runnable ) { return new  Low Memory Watcher ( runnable ) ; }
public  Object extract Hard Ref (  Object o ) {  Soft Reference w = (  Soft Reference ) o ; if ( w != null ) { return w . get ( ) ; } return null ; }
public static  String format Long ( long number ) { return int Format . format ( number ) ; }
public synchronized int copy Direct ( int page Id ,  Output Stream out ) throws  IOException { byte [ ] buffer = new byte [ page Size ] ; if ( page Id >= page Count ) { return - _ NUM ; } file . seek ( ( long ) page Id << page Size Shift ) ; file . read Fully Direct ( buffer , _ NUM , page Size ) ; read Count ++ ; out . write ( buffer , _ NUM , page Size ) ; return page Id + _ NUM ; }
public void write Raw Bytes ( final byte [ ] value , int offset , int length ) throws  IOException { if ( limit - position >= length ) {  System . arraycopy ( value , offset , buffer , position , length ) ; position += length ; } else { throw new  Out Of Space Exception ( position , limit ) ; } }
private void assert Backup Status ( final  Backup Status backup Status ) {  Map <  Distributed Member ,  Set <  Persistent ID > > backup Map = backup Status . get Backed Up Disk Stores ( ) ; assert False ( backup Map . is Empty ( ) ) ; for (  Distributed Member member : backup Map . key Set ( ) ) { for (  Persistent ID id : backup Map . get ( member ) ) { assert Not Null ( id . get Host ( ) ) ; assert Not Null ( id . get UUID ( ) ) ; assert Not Null ( id . get Directory ( ) ) ; } } }
@  Request Mapping ( value = _ STR ) public void metadata Error (  Locale locale , @  Path Variable ( value = _ STR )  String tenant ,  Http Servlet Response response ) throws  IOException { logger . info ( _ STR , locale . to String ( ) , tenant ) ; metadata Default Tenant Binding Error ( locale , response ) ; }
public synchronized void check State (  State ... required States ) throws  Illegal State Exception { for (  State required State : required States ) { if ( required State . equals ( current State ) ) { return ; } } throw new  Illegal State Exception (  String . format (  Locale .  US , _ STR ,  Lists . new Array List ( required States ) , current State ) ) ; }
public void sort Movies ( ) { synchronized ( movies ) {  Utils . sort List ( movies ,  MOVIE_ SET_ COMPARATOR ) ; movie Ids . clear ( ) ; for (  Movie movie : movies ) { movie Ids . add ( movie . get Db Id ( ) ) ; } } fire Property Change ( _ STR , null , movies ) ; }
public  Key Value List Parser (  String pair Delimiter Regex ,  String key Val Delimiter Regex ) { pair Delimiter =  Pattern . compile ( pair Delimiter Regex ) ; key Val Delimiter =  Pattern . compile ( key Val Delimiter Regex ) ; }
private synchronized boolean poll Stats Broker (  Destination queue ) { stats Message Listener . set Destination ( queue ) ;  Timestamp timestamp = new  Timestamp (  System . current Time Millis ( ) ) ;  LOGGER . debug ( _ STR + get Queue Name ( queue ) + _ STR + timestamp ) ; jms Template . execute (  STATS_ BROKER_ DESTINATION + get Queue Name ( queue ) , new  Producer Callback Impl ( stats Queue ) ) ; try {  Thread . sleep ( _ NUM * _ NUM ) ; } catch (  Interrupted Exception e ) { e . print Stack Trace ( ) ; } return stats Message Listener . get Stats ( ) != null ; }
public  File make Acceptable (  File pathname ) { if ( accept ( pathname ) ) { return pathname ; } else { return new  File ( pathname . get Path ( ) + _ STR + default Extension ) ; } }
public  String js Type Name (  Type Ref type Ref ) { switch ( type Ref . get Kind ( ) ) { case  TYPE_ MESSAGE : return _ STR ; case  TYPE_ ENUM : return _ STR ; default : {  String name =  PRIMITIVE_ TYPE_ NAMES . get ( type Ref . get Kind ( ) ) ; if ( !  Strings . is Null Or Empty ( name ) ) { return name ; } throw new  Illegal Argument Exception ( _ STR + type Ref . get Kind ( ) ) ; } } }
public  State Machine create State Machine (  State Machine Definition state Machine Definition ) { final  Map <  Event Definition ,  Event Data > event Data Map = state Machine Definition . get Event Data Map ( ) ;  Set <  Event > all Events = create All Events ( event Data Map ) ;  Set <  State Definition > state Definitions = state Machine Definition . get States ( ) ;  Set <  State > states = new  Hash Set < > ( ) ; for (  State Definition state Definition : state Definitions ) {  State state = convert State Definition To State ( state Definition ) ; states . add ( state ) ; }  State Machine state Machine = new  State Machine ( state Machine Definition . get Version ( ) , state Machine Definition . get Name ( ) , state Machine Definition . get Description ( ) , states , state Machine Definition . get Correlation Id ( ) ) ; state Machines DAO . create ( state Machine ) ; for (  Event event : all Events ) { event . set State Machine Instance Id ( state Machine . get Id ( ) ) ; event Persistence Service . persist Event ( event ) ; } for (  State state : state Machine . get States ( ) ) { audit DAO . create ( new  Audit Record ( state Machine . get Id ( ) , state . get Id ( ) , _ NUM ,  Status . initialized , null , null ) ) ; } return state Machine ; }
protected void sqrt Layout (  Visual Table labels ) {  Rectangle2 D b = get Layout Bounds ( ) ; double breadth = get Breadth ( b ) ; double span = m_hi - m_lo ; double splo =  Math Lib . safe Sqrt ( m_prevlo ) ; double spspan =  Math Lib . safe Sqrt ( m_prevhi ) - splo ; double vlo =  Math . pow ( _ NUM ,  Math . floor (  Math Lib . safe Log10 ( m_lo ) ) ) ; double slo =  Math Lib . safe Sqrt ( m_lo ) ; double sspan =  Math Lib . safe Sqrt ( m_hi ) - slo ;  Iterator iter = labels . tuples ( ) ; while ( iter . has Next ( ) ) {  Visual Item item = (  Visual Item ) iter . next ( ) ; reset ( item ) ; double v = item . get Double (  VALUE ) ; double x = span == _ NUM ? _ NUM : ( (  Math Lib . safe Sqrt ( v ) - slo ) / sspan ) * breadth ; set ( item , x , b ) ; }  Index index = labels . index (  VALUE ) ; double step = get Linear Step ( span , breadth / span ) ; if ( step == _ NUM ) step = _ NUM ; int r ; for ( double x , v = vlo ; v <= m_hi ; v += step ) { x = ( (  Math Lib . safe Sqrt ( v ) - slo ) / sspan ) * breadth ; if ( x < - _ NUM ) { continue ; } else if ( ( r = index . get ( v ) ) >= _ NUM ) {  Visual Item item = labels . get Item ( r ) ; item . set Visible ( _ BOOL ) ; item . set End Visible ( _ BOOL ) ; } else {  Visual Item item = labels . add Item ( ) ; item . set (  LABEL , m_nf . format ( v ) ) ; item . set Double (  VALUE , v ) ; double f = spspan == _ NUM ? _ NUM : ( (  Math Lib . safe Sqrt ( v ) - splo ) / spspan ) ; if ( f <= _ NUM || f >= _ NUM ) { item . set Start Visible ( _ BOOL ) ; } set ( item , f * breadth , b ) ; set ( item , x , b ) ; } } }
public void dispose ( ) { clear Listeners ( ) ; if ( attributes != null ) { attributes . clear ( ) ; } removed ( null ) ; }
public static terminal find (  String with_name ) { if ( with_name == null ) return null ; else return ( terminal ) _all . get ( with_name ) ; }
public  Layout Block create New Layout Block (  String system Name ,  String user Name ) {  Layout Block block = null ; if ( user Name == null || user Name . equals ( _ STR ) ) { log . error ( _ STR ) ; return null ; } block = get By User Name ( user Name ) ; if ( block != null ) { return null ; }  String s Name = _ STR ; if ( system Name == null ) { boolean found = _ BOOL ; while ( found ) { s Name = _ STR + blk Num ; blk Num ++ ; block = get By System Name ( s Name ) ; if ( block == null ) { found = _ BOOL ; } } } else { block = get By System Name ( ( system Name . to Upper Case ( ) ) ) ; if ( block != null ) { return null ; } s Name = system Name . to Upper Case ( ) ; } block = new  Layout Block ( s Name , user Name ) ; register ( block ) ; return block ; }
@  Override public void modify Nonstatic JPedal Parameters ( final  Map values ) throws  Pdf Exception { options . set ( values ) ; if ( values . contains Key (  JPedal Settings .  DISPLAY_ BACKGROUND ) ) { } }
public static  String escape Regex ( final  String regex ) {  Matcher match =  REGEX_ CHARS . matcher ( regex ) ; return match . replace All ( _ STR ) ; }
public  Char Buffer (  String string ) { int length = string . length ( ) ; int capacity = length +  MIN_ CAPACITY ; init ( new char [ capacity ] , _ NUM , length ) ; string . get Chars ( _ NUM , length , buffer ( ) , _ NUM ) ; }
private void update Promo Visibility ( float percentage ) { if ( is Promo Available ( ) ) { m Promo Visible = _ BOOL ; m Promo Height Px =  Math . round (  Math Utils . clamp ( percentage * m Promo Content Height Px , _ NUM , m Promo Content Height Px ) ) ; m Promo Opacity = percentage ; } else { m Promo Visible = _ BOOL ; m Promo Height Px = _ NUM ; m Promo Opacity = _ NUM ; } }
private  Value Geometry ( byte [ ] bytes ,  Geometry geometry ) { this . bytes = bytes ; this . geometry = geometry ; this . hash Code =  Arrays . hash Code ( bytes ) ; }
@  Override public void do_after_propagation ( ) { for (  Heap Ins Interval Manager im : new_pts . values ( ) ) { im . flush ( ) ; } new_pts = new  Hash Map <  Alloc Node ,  Heap Ins Interval Manager > ( ) ; }
private void finish Common ( ) { if ( ! unknown Subjects . is Empty ( ) ) { if ( statements . is Empty ( ) && restored Statements . is Empty ( ) ) { throw new  Bad Subject Exception ( unknown Subjects . key Set ( ) , uris ) ; } else { log . info ( _ STR , unknown Subjects . key Set ( ) , uris . entity Data ( ) , uris . entity ( ) ) ; } } if ( revision Id == null ) { throw new  Contained Exception ( _ STR + statements ) ; } if ( last Modified == null ) { throw new  Contained Exception ( _ STR + statements ) ; } for (  Pair <  URI ,  Literal > data Statement : data Statements ) { statements . add ( new  Statement Impl ( entity Uri Impl , data Statement . get Left ( ) , data Statement . get Right ( ) ) ) ; } statements . add All ( restored Statements ) ; }
public static final void show GUIMessage ( final  String user_message , final  Buffered Image image , final  String title ) { if ( image == null ) { return ; } final  Image Panel display = new  Image Panel ( image ) ; display . set Layout ( new  Border Layout ( ) ) ; if ( user_message != null ) { display . add ( new  JLabel ( user_message ) ,  Border Layout .  SOUTH ) ; } final int width = image . get Width ( ) ; final int height = image . get Height ( ) ; display . set Size ( new  Dimension ( width + _ NUM , height + _ NUM ) ) ;  JOption Pane . show Confirm Dialog ( content Pane , display , title ,  JOption Pane .  DEFAULT_ OPTION ,  JOption Pane .  PLAIN_ MESSAGE ) ; }
private void dyn Init ( ) { }
@  Override public  Path call ( ) throws  Exception { final  Set <  File Visit Option > options ; if ( follow Links ) { options =  Enum Set . of (  File Visit Option .  FOLLOW_ LINKS ) ; } else { options =  Enum Set . none Of (  File Visit Option . class ) ; } logger . info (  String . format ( _ STR , path ) ) ; try {  Files . walk File Tree ( path , options , max Depth , this ) ; } catch (  IOException e ) { logger . log (  Level .  SEVERE ,  String . format ( _ STR , path ) , e ) ; throw e ; } logger . info (  String . format ( _ STR , path ) ) ; return path ; }
private void baseline Layout ( int origin , int size ) { int ascent ; int descent ; if ( baseline Anchored To Top ) { ascent = pref Ascent ; descent = size - ascent ; } else { ascent = size - pref Descent ; descent = pref Descent ; } for (  Spring spring : springs ) {  Alignment alignment = spring . get Alignment ( ) ; if ( alignment == null || alignment ==  Alignment .  BASELINE ) { int baseline = spring . get Baseline ( ) ; if ( baseline >= _ NUM ) { int spring Max = spring . get Maximum Size (  VERTICAL ) ; int spring Pref = spring . get Preferred Size (  VERTICAL ) ; int height = spring Pref ; int y ; switch ( spring . get Baseline Resize Behavior ( ) ) { case  CONSTANT_ ASCENT : y = origin + ascent - baseline ; height =  Math . min ( descent , spring Max - baseline ) + baseline ; break ; case  CONSTANT_ DESCENT : height =  Math . min ( ascent , spring Max - spring Pref + baseline ) + ( spring Pref - baseline ) ; y = origin + ascent + ( spring Pref - baseline ) - height ; break ; default : y = origin + ascent - baseline ; break ; } spring . set Size (  VERTICAL , y , height ) ; } else { set Child Size ( spring ,  VERTICAL , origin , size ) ; } } else { set Child Size ( spring ,  VERTICAL , origin , size ) ; } } }
public static int read Int ( final  JSONArray json Array , final int index , final boolean required , final boolean not Null ) throws  JSONException { if ( required ) { return json Array . get Int ( index ) ; } if ( not Null && json Array . is Null ( index ) ) { throw new  JSONException (  String . format (  Locale .  US ,  NULL_ VALUE_ FORMAT_ ARRAY , index ) ) ; } int value = _ NUM ; if ( ! json Array . is Null ( index ) ) { value = json Array . get Int ( index ) ; } return value ; }
private void validate Storage Policy Selection (  Storage Policy Selection storage Policy Selection ) {  Assert . not Null ( storage Policy Selection , _ STR ) ; business Object Data Helper . validate Business Object Data Key ( storage Policy Selection . get Business Object Data Key ( ) , _ BOOL , _ BOOL ) ; storage Policy Helper . validate Storage Policy Key ( storage Policy Selection . get Storage Policy Key ( ) ) ;  Assert . not Null ( storage Policy Selection . get Storage Policy Version ( ) , _ STR ) ; }
@  Override public  String to String ( ) {  String Buffer text = new  String Buffer ( ) ; if ( m_cobweb Tree == null ) { return _ STR ; } else { m_cobweb Tree . dump Tree ( _ NUM , text ) ; return _ STR + m_number Merges + _ STR + m_number Splits + _ STR + number Of Clusters ( ) + _ STR + text . to String ( ) + _ STR ; } }
public static  Object to Array (  Collection < ? > collection ,  Class < ? > component Type ) { if ( component Type . is Primitive ( ) ) {  Object array =  Array . new Instance ( component Type , collection . size ( ) ) ; int index = _ NUM ; for (  Object value : collection ) {  Array . set ( array , index ++ , value ) ; } return array ; } return collection . to Array ( (  Object [ ] )  Array . new Instance ( component Type , collection . size ( ) ) ) ; }
Gradle Exception format Violations For (  Formatter formatter ,  List <  File > problem Files ) throws  IOException { return new  Gradle Exception (  Diff Message Formatter . message For ( this , formatter , problem Files ) ) ; }
public void label Distances (  Hypergraph <  V ,  E > graph ,  V root ) { label Distances ( graph ,  Collections . singleton ( root ) ) ; }
public static java . lang .  String to String ( float d ) { float m =  Math . abs ( d ) ; if ( d ==  POSITIVE_ INFINITY ) { return _ STR ; } else if ( d ==  NEGATIVE_ INFINITY ) { return _ STR ; } else if ( d == _ NUM ) { return _ STR ; } else if ( m >= _ NUM && m < _ NUM ) {  String str = to String Impl ( d , _ BOOL ) ; char [ ] chars = str . to Char Array ( ) ; int i = chars . length - _ NUM ; char c ; while ( i >= _ NUM && ( c = chars [ i ] ) == _ STR ) { i -- ; } if ( i < _ NUM || str . index Of ( _ STR ) == - _ NUM ) { return str ; } else if ( chars [ i ] == _ STR || chars [ i ] == _ STR ) { i ++ ; } return str . substring ( _ NUM , i + _ NUM ) ; } else { return to String Impl ( d , _ BOOL ) ; } }
public int position ( ) { return line Buffer == null ? _ NUM : line Buffer . length ( ) ; }
public final static  Header Element parse Header Element ( final  String value ,  Header Value Parser parser ) throws  Parse Exception { if ( value == null ) { throw new  Illegal Argument Exception ( _ STR ) ; } if ( parser == null ) parser =  Save Header Value Parser .  DEFAULT ;  Char Array Buffer buffer = new  Char Array Buffer ( value . length ( ) ) ; buffer . append ( value ) ;  Save Parser Cursor cursor = new  Save Parser Cursor ( _ NUM , value . length ( ) ) ; return parser . parse Header Element ( buffer , cursor ) ; }
public static  List <  Interval > slice Intervals (  Interval interval ,  Time Grain time Grain ) {  Date Time interval End = interval . get End ( ) ;  Date Time slice Start = interval . get Start ( ) ;  Date Time period Start = time Grain . round Floor ( slice Start ) ; if ( ! slice Start . equals ( period Start ) ) {  LOG . info ( _ STR , interval , time Grain , period Start ) ; throw new  Illegal Argument Exception ( _ STR + period Start ) ; }  List <  Interval > interval Slices = new  Array List < > ( ) ; while ( slice Start . is Before ( interval End ) ) {  Date Time slice End =  Date Time Utils . add Time Grain ( slice Start , time Grain ) ;  Interval sliced Interval = new  Interval ( slice Start , slice End ) ; if ( ! interval . contains ( sliced Interval ) ) {  LOG . info ( _ STR , interval , time Grain ) ; throw new  Illegal Argument Exception ( _ STR ) ; } interval Slices . add ( sliced Interval ) ; slice Start = slice End ; }  LOG . debug ( _ STR , interval , interval Slices . size ( ) , time Grain ) ; return interval Slices ; }
public void test Has Attributes1 ( ) throws  Throwable {  Document doc ;  Node List addr List ;  Node addr Node ; boolean state ; doc = (  Document ) load ( _ STR , builder ) ; addr List = doc . get Elements By Tag Name ( _ STR ) ; addr Node = addr List . item ( _ NUM ) ; state = addr Node . has Attributes ( ) ; assert False ( _ STR , state ) ; }
public boolean is Gerund ( ) { return type String . starts With (  VERB_ GERUND ) ; }
private  Json Object create Request (  Map <  String ,  Object > headers ,  String uri ,  Http Method method ,  Json Object payload ) {  Json Object request = new  Json Object ( ) ;  Json Array json Headers = new  Json Array ( ) ; headers . for Each ( null ) ; request . put ( _ STR , json Headers ) ; request . put ( _ STR , uri ) ; request . put ( _ STR , method . to String ( ) ) ; request . put ( _ STR , payload ) ; return request ; }
private long download Tlog Files (  File tmp Tlog Dir , long latest Generation ) throws  Exception {  LOG . info ( _ STR + tlog Files To Download ) ; tlog Files Downloaded =  Collections . synchronized List ( new  Array List < > ( ) ) ; long bytes Downloaded = _ NUM ; boolean status = tmp Tlog Dir . mkdirs ( ) ; if ( ! status ) { throw new  Solr Exception (  Solr Exception .  Error Code .  SERVER_ ERROR , _ STR + tmp Tlog Dir . get Name ( ) ) ; } for (  Map <  String ,  Object > file : tlog Files To Download ) {  String save As = (  String ) ( file . get (  ALIAS ) == null ? file . get (  NAME ) : file . get (  ALIAS ) ) ; local File Fetcher = new  Local Fs File Fetcher ( tmp Tlog Dir , file , save As ,  TLOG_ FILE , latest Generation ) ; current File = file ; local File Fetcher . fetch File ( ) ; bytes Downloaded += local File Fetcher . get Bytes Downloaded ( ) ; tlog Files Downloaded . add ( new  Hash Map < > ( file ) ) ; } return bytes Downloaded ; }
static  Windows File Attributes read Attributes ( long handle ) throws  Windows Exception {  Native Buffer buffer =  Native Buffers . get Native Buffer (  SIZEOF_ FILE_ INFORMATION ) ; try { long address = buffer . address ( ) ;  Get File Information By Handle ( handle , address ) ; int reparse Tag = _ NUM ; int file Attrs = unsafe . get Int ( address +  OFFSETOF_ FILE_ INFORMATION_ ATTRIBUTES ) ; if ( is Reparse Point ( file Attrs ) ) { int size =  MAXIMUM_ REPARSE_ DATA_ BUFFER_ SIZE ;  Native Buffer reparse Buffer =  Native Buffers . get Native Buffer ( size ) ; try {  Device Io Control Get Reparse Point ( handle , reparse Buffer . address ( ) , size ) ; reparse Tag = ( int ) unsafe . get Long ( reparse Buffer . address ( ) ) ; } finally { reparse Buffer . release ( ) ; } } return from File Information ( address , reparse Tag ) ; } finally { buffer . release ( ) ; } }
protected void add All For Replay (  Collection <  Participant > participants ) {  Iterator <  Participant > it = participants . iterator ( ) ; while ( it . has Next ( ) ) {  Participant p = it . next ( ) ; replay Completion ( p ) ; } }
public static  JPanel create Checkbox (  String boxlabel ,  String [ ] buttons , boolean [ ] checked ,  Action Listener al ) {  JPanel jp = create Palette JPanel ( boxlabel ) ; for ( int j = _ NUM ; j < buttons . length ; j ++ ) {  JCheck Box jcb = new  JCheck Box ( buttons [ j ] ) ; jcb . set Action Command (  Integer . to String ( j ) ) ; if ( al != null ) jcb . add Action Listener ( al ) ; jcb . set Selected ( checked [ j ] ) ; jp . add ( jcb ) ; } return jp ; }
public static void copy (  Dimensions Event ae Dest ,  Dimensions Event ae Src ) {  GPOMutable dest Aggs = ae Dest . get Aggregates ( ) ;  GPOMutable src Aggs = ae Src . get Aggregates ( ) ; if ( src Aggs . get Fields Boolean ( ) != null ) {  System . arraycopy ( src Aggs . get Fields Boolean ( ) , _ NUM , dest Aggs . get Fields Boolean ( ) , _ NUM , src Aggs . get Fields Boolean ( ) . length ) ; } if ( src Aggs . get Fields Character ( ) != null ) {  System . arraycopy ( src Aggs . get Fields Character ( ) , _ NUM , dest Aggs . get Fields Character ( ) , _ NUM , src Aggs . get Fields Character ( ) . length ) ; } if ( src Aggs . get Fields String ( ) != null ) {  System . arraycopy ( src Aggs . get Fields String ( ) , _ NUM , dest Aggs . get Fields String ( ) , _ NUM , src Aggs . get Fields String ( ) . length ) ; } if ( src Aggs . get Fields Short ( ) != null ) {  System . arraycopy ( src Aggs . get Fields Short ( ) , _ NUM , dest Aggs . get Fields Short ( ) , _ NUM , src Aggs . get Fields Short ( ) . length ) ; } if ( src Aggs . get Fields Integer ( ) != null ) {  System . arraycopy ( src Aggs . get Fields Integer ( ) , _ NUM , dest Aggs . get Fields Integer ( ) , _ NUM , src Aggs . get Fields Integer ( ) . length ) ; } if ( src Aggs . get Fields Long ( ) != null ) {  System . arraycopy ( src Aggs . get Fields Long ( ) , _ NUM , dest Aggs . get Fields Long ( ) , _ NUM , src Aggs . get Fields Long ( ) . length ) ; } if ( src Aggs . get Fields Float ( ) != null ) {  System . arraycopy ( src Aggs . get Fields Float ( ) , _ NUM , dest Aggs . get Fields Float ( ) , _ NUM , src Aggs . get Fields Float ( ) . length ) ; } if ( src Aggs . get Fields Double ( ) != null ) {  System . arraycopy ( src Aggs . get Fields Double ( ) , _ NUM , dest Aggs . get Fields Double ( ) , _ NUM , src Aggs . get Fields Double ( ) . length ) ; } }
public static double assign Probabilities To Instances (  Relation < ? extends  Number Vector > relation ,  List < ? extends  EMCluster Model < ? > > models ,  Writable Data Store < double [ ] > prob Cluster IGiven X ) { final int k = models . size ( ) ; double em Sum = _ NUM ; for (  DBIDIter iditer = relation . iter DBIDs ( ) ; iditer . valid ( ) ; iditer . advance ( ) ) {  Number Vector vec = relation . get ( iditer ) ; double [ ] probabilities = new double [ k ] ; { int i = _ NUM ; for (  EMCluster Model < ? > m : models ) { probabilities [ i ] = m . estimate Density ( vec ) ; ++ i ; } } double prior Probability = _ NUM ; for ( int i = _ NUM ; i < k ; i ++ ) { prior Probability += probabilities [ i ] ; } double log P =  Math . max (  Math . log ( prior Probability ) ,  MIN_ LOGLIKELIHOOD ) ; em Sum += ( log P == log P ) ? log P : _ NUM ; double [ ] cluster Probabilities = new double [ k ] ; if ( prior Probability > _ NUM ) { for ( int i = _ NUM ; i < k ; i ++ ) { cluster Probabilities [ i ] = probabilities [ i ] / prior Probability ; } } prob Cluster IGiven X . put ( iditer , cluster Probabilities ) ; } return em Sum / relation . size ( ) ; }
public static  String as String (  URI value ) { return value != null ? value . to String ( ) : null ; }
public  Kernel ( int offset , double [ ] values ) { this . values =  Arrays . copy Of ( values , values . length ) ; this . offset = offset ; }
private void initialize Work List ( ) { for (  GVCongruence Class c :  B ) { if ( c . size ( ) == _ NUM ) { continue ; }  Iterator <  Value Graph Vertex > i = c . iterator ( ) ;  Value Graph Vertex first = i . next ( ) ; while ( i . has Next ( ) ) {  Value Graph Vertex v = i . next ( ) ; if ( ! check Congruence ( first , v ) ) { work List . push ( c ) ; break ; } } } }
@  Override protected void before Model Linked (  EObject model ,  IDiagnostic Consumer diagnostics Consumer ) {  Imported Names Adapter adapter =  Imported Names Adapter . find ( model . e Resource ( ) ) ; if ( adapter != null ) adapter . clear ( ) ;  Union Member Scope . clear Cached Composed Members ( model ) ; }
protected abstract void add File (  String relative Filename ) throws  Command Exception ;
public void tree Expanded (  Tree Expansion Event event ) { inspector Window . update View (  Director .  ALL ) ; }
public void convert Infix To Postfix (  String infix Exp ) throws  Exception { m_original Infix = infix Exp ; infix Exp =  Utils . remove Substring ( infix Exp , _ STR ) ; infix Exp =  Utils . replace Substring ( infix Exp , _ STR , _ STR ) ; infix Exp =  Utils . replace Substring ( infix Exp , _ STR , _ STR ) ; infix Exp =  Utils . replace Substring ( infix Exp , _ STR , _ STR ) ; infix Exp =  Utils . replace Substring ( infix Exp , _ STR , _ STR ) ; infix Exp =  Utils . replace Substring ( infix Exp , _ STR , _ STR ) ; infix Exp =  Utils . replace Substring ( infix Exp , _ STR , _ STR ) ; infix Exp =  Utils . replace Substring ( infix Exp , _ STR , _ STR ) ; infix Exp =  Utils . replace Substring ( infix Exp , _ STR , _ STR ) ; infix Exp =  Utils . replace Substring ( infix Exp , _ STR , _ STR ) ; infix Exp =  Utils . replace Substring ( infix Exp , _ STR , _ STR ) ;  String Tokenizer tokenizer = new  String Tokenizer ( infix Exp ,  OPERATORS , _ BOOL ) ; m_post Fix Exp Vector = new  Vector <  Expression Component > ( ) ; while ( tokenizer . has More Tokens ( ) ) {  String tok = tokenizer . next Token ( ) ; if ( tok . length ( ) > _ NUM ) { handle Operand ( tok ) ; } else { if ( is Operator ( tok . char At ( _ NUM ) ) ) { handle Operator ( tok ) ; } else { handle Operand ( tok ) ; } } m_previous Tok = tok ; } while ( ! m_operator Stack . empty ( ) ) {  String popop = (  String ) ( m_operator Stack . pop ( ) ) ; if ( popop . char At ( _ NUM ) == _ STR || popop . char At ( _ NUM ) == _ STR ) { throw new  Exception ( _ STR ) ; } m_post Fix Exp Vector . add Element ( new  Operator ( popop . char At ( _ NUM ) ) ) ; } }
public boolean has Item (  T object ) { synchronized ( m Lock ) { return source . contains ( object ) ; } }
private static boolean version Matches (  Integer v1 , int v2 ) { if ( v1 == null || v1 == _ NUM || v2 == _ NUM ) { return _ BOOL ; } return v1 . equals ( v2 ) ; }
protected void on Failed Closing Url Connection (  URLConnection url Connection ,  IOException cause ) { }
private void on Schema Complex Type (  Element schema Complex Type ,  Datatype Element Factory element Factory ) {  Iterator <  Element > iter = schema Complex Type . element Iterator (  XSD_ ATTRIBUTE ) ; while ( iter . has Next ( ) ) {  Element xsd Attribute = iter . next ( ) ;  String name = xsd Attribute . attribute Value ( _ STR ) ;  QName qname = get QName ( name ) ;  XSDatatype data Type = data Type For Xsd Attribute ( xsd Attribute ) ; if ( data Type != null ) { element Factory . set Attribute XSDatatype ( qname , data Type ) ; } }  Element schema Sequence = schema Complex Type . element (  XSD_ SEQUENCE ) ; if ( schema Sequence != null ) { on Child Elements ( schema Sequence , element Factory ) ; }  Element schema Choice = schema Complex Type . element (  XSD_ CHOICE ) ; if ( schema Choice != null ) { on Child Elements ( schema Choice , element Factory ) ; }  Element schema All = schema Complex Type . element (  XSD_ ALL ) ; if ( schema All != null ) { on Child Elements ( schema All , element Factory ) ; } }
private void push Annotators Ref (  String values ) { annotators Ref . push ( annotators Ref . peek ( ) ) ; set Annotators Ref ( values ) ; }
public  String version Compact ( ) { return properties . get Property ( _ STR ) ; }
private void sequence Query (  Query Entry entry ,  Server Session Context session ,  Completable Future <  Query Response > future ) { if ( entry . get Sequence ( ) > session . get Command Sequence ( ) ) { session . register Sequence Query ( entry . get Sequence ( ) , null ) ; } else { index Query ( entry , future ) ; } }
public static <  T >  List <  T > rest (  List <  T > l ) { return l . sub List ( _ NUM , l . size ( ) ) ; }
public void find And Undo (  Object some Obj ) { if ( some Obj instanceof com . bbn . openmap .  Map Bean ) { logger . fine ( _ STR ) ;  Map Bean map = get Map Bean ( ) ; if ( map != null && map == (  Map Bean ) some Obj ) { set Map Bean ( null ) ; } } }
public  Timestamp recalculate Estimated Completion Date (  Long priority ,  Timestamp start Date ) { if ( exist ( ) ) { get Production Run Routing Tasks ( ) ; if ( quantity == null ) get Quantity ( ) ;  Timestamp end Date = null ; for (  Iterator <  Generic Value > iter = production Run Routing Tasks . iterator ( ) ; iter . has Next ( ) ; ) {  Generic Value routing Task = iter . next ( ) ; if ( priority . compare To ( routing Task . get Long ( _ STR ) ) <= _ NUM ) { long total Time =  Production Run . get Estimated Task Time ( routing Task , quantity , dispatcher ) ; end Date =  Tech Data Services . add Forward (  Tech Data Services . get Tech Data Calendar ( routing Task ) , start Date , total Time ) ; routing Task . set ( _ STR , start Date ) ; routing Task . set ( _ STR , end Date ) ; start Date = end Date ; } } return end Date ; } else { return null ; } }
public void add Document Type (  Document Type document Type ) { m Document Types . add ( document Type ) ; }
private static  Position next Token Pos (  Position pos ,  Token [ ] [ ] spec ) { if ( pos == null ) { return null ; } int next Item = pos . item + _ NUM ; if ( ( next Item < spec [ pos . line ] . length ) && ( ( pos . line < pcal End . line ) || ( next Item < pcal End . item ) ) ) { return new  Position ( pos . line , next Item ) ; } int next Line = pos . line + _ NUM ; while ( ( next Line < spec . length ) && ( spec [ next Line ] . length == _ NUM ) ) { next Line ++ ; } if ( ( next Line < spec . length ) && ( ( next Line < pcal End . line ) || ( ( next Line == pcal End . line ) && ( _ NUM < pcal End . item ) ) ) ) { return new  Position ( next Line , _ NUM ) ; } return null ; }
public void update (  GL10 gl ) { if ( task Queue . size ( ) > _ NUM ) {  GLResorce Task res ; while ( ( res = task Queue . poll ( ) ) != null ) { res . perform ( gl ) ; } } }
public static double [ ]  HPDInterval ( double proportion , double [ ] x , int [ ] indices ) { double min Range =  Double .  MAX_ VALUE ; int hpd Index = _ NUM ; final int diff = ( int )  Math . round ( proportion * ( double ) x . length ) ; for ( int i = _ NUM ; i <= ( x . length - diff ) ; i ++ ) { final double min Value = x [ indices [ i ] ] ; final double max Value = x [ indices [ i + diff - _ NUM ] ] ; final double range =  Math . abs ( max Value - min Value ) ; if ( range < min Range ) { min Range = range ; hpd Index = i ; } } return new double [ ] { x [ indices [ hpd Index ] ] , x [ indices [ hpd Index + diff - _ NUM ] ] } ; }
private void check If Directories Exist (  File [ ] disk_dirs ) {  Disk Store Factory Impl . check If Directories Exist ( disk_dirs ) ; }
public void add Port To Already Allocated Context (  Storage Port port ,  Storage HADomain ha Domain ,  Storage System .  Type array Type ,  String switch Name ) {  String engine = get Engine ( port , ha Domain , array Type ) ; if ( engine != null ) { _already Allocated Engines . add ( engine ) ; }  String director Type = get Director Type ( array Type , ha Domain ) ; if ( director Type != null ) { _already Allocated Director Types . add ( director Type ) ; }  String director = get Director ( port , ha Domain ) ; if ( director != null ) { _already Allocated Directors . add ( director ) ; }  String cpu = get Cpu ( port , ha Domain , array Type ) ; if ( cpu != null ) { _already Allocated Cpus . add ( cpu ) ; } if ( switch Name != null ) { _already Allocated Switches . add ( switch Name ) ; } }
public static void write List Of Longs (  List list , boolean has Long IDs ,  Data Output out ) throws  IOException { if ( list == null ) { out . write Int ( - _ NUM ) ; } else { out . write Int ( list . size ( ) ) ; out . write Boolean ( has Long IDs ) ; for (  Iterator it = list . iterator ( ) ; it . has Next ( ) ; ) {  Long l = (  Long ) it . next ( ) ; if ( has Long IDs ) { out . write Long ( l . long Value ( ) ) ; } else { out . write Int ( ( int ) l . long Value ( ) ) ; } } } }
public boolean is Defined (  Object attr Name ) { return table . contains Key ( attr Name ) ; }
private void show Preloading Stage ( ) {  Stage preloading Stage = new  Stage (  Stage Style .  UNDECORATED ) ; preloading Stage . init Owner ( primary Stage ) ; preloading Stage . set Scene ( new  Preloading Scene ( ) ) ; preloading Stage . show ( ) ; primary Stage . set On Showing ( null ) ; }
public void test_copy Stream_full Block ( ) throws  IOException { final  String id = _ STR ; final int version = _ NUM ;  Random r = new  Random ( ) ; final byte [ ] expected = new byte [  BLOCK_ SIZE ] ; r . next Bytes ( expected ) ; assert Equals ( _ STR , expected . length , repo . copy Stream ( id , version , new  Byte Array Input Stream ( expected ) ) ) ; assert Equals ( _ STR , _ NUM , repo . get Block Count ( id , version ) ) ; assert Same Iterator ( _ STR , new  Long [ ] { _ NUM } , repo . blocks ( id , version ) ) ; assert Equals ( _ STR , expected , read ( repo . input Stream ( id , version ) ) ) ; }
private static int ip To Bytes (  String ip , byte [ ] bytes , boolean must Have4 ) throws  IPMatcher Exception {  String [ ] parts = ip . split ( _ STR ) ; if ( parts . length > _ NUM || must Have4 && parts . length != _ NUM ) { throw new  IPMatcher Exception ( _ STR + ip ) ; } try { for ( int i = _ NUM ; i < parts . length ; i ++ ) { int p =  Integer . parse Int ( parts [ i ] ) ; if ( p < _ NUM || p > _ NUM ) { throw new  IPMatcher Exception ( _ STR + ip ) ; } bytes [ i ] = ( byte ) ( p < _ NUM ? p : p - _ NUM ) ; } } catch (  Number Format Exception nfe ) { throw new  IPMatcher Exception ( _ STR + ip , nfe ) ; } return parts . length ; }
protected void reply (  Request Context context ,  String key ,  String message ) { try {  Http Servlet Request request = context . get Request ( ) ;  String filename = request . get Remote Addr ( ) ; end ( filename , key , message ) ; } catch (  Exception e ) { } }
protected void add Headers (  Http URLConnection connection ,  String tenant Id ) { if ( tenant Id == null ) { tenant Id =  Property Util . get Property (  Property Util .  HAWKULAR_ TENANT ) ; } if ( tenant Id != null ) { connection . set Request Property (  HAWKULAR_ TENANT , tenant Id ) ; } if ( authorization == null && username != null ) {  String auth String = username + _ STR + password ;  String encoded = encoder . encode To String ( auth String . get Bytes ( ) ) ; authorization = _ STR + encoded ; } if ( authorization != null ) { connection . set Request Property ( _ STR , authorization ) ; } }
public void add Long Selection Listener (  Selection Listener listener ) { if ( listener == null ) throw new  Illegal Argument Exception ( ) ; if ( hex Edit Control == null ) { if ( list Of Long Listeners == null ) list Of Long Listeners = new  Array List < > ( ) ; list Of Long Listeners . add ( listener ) ; } else { hex Edit Control . add Long Selection Listener ( listener ) ; } }
@  Override public  String to String ( ) {  String Builder sb = new  String Builder ( ) ; sb . append ( _ STR ) ; boolean first Time = _ BOOL ; for (  Entry <  Integer ,  String > entry : m Capabilities . entry Set ( ) ) { if ( first Time ) { first Time = _ BOOL ; } else { sb . append ( _ STR ) ; } sb . append ( entry . get Key ( ) ) ; sb . append ( _ STR ) ; sb . append ( entry . get Value ( ) ) ; sb . append ( _ STR ) ; return m Capabilities . to String ( ) ; } return sb . to String ( ) ; }
public  Debug (  String client ID ,  Client Comms comms ) { this . client ID = client ID ; this . comms = comms ; log . set Resource Name ( client ID ) ; }
protected  String alter Case (  String value ) { switch ( get Case ( ) ) { case  UPPERCASE : return value . to Upper Case ( ) ; case  LOWERCASE : return value . to Lower Case ( ) ; default : return value ; } }
private boolean is Ack Required ( ) { return this . ack Required ; }
void add Reporter (  String text Reporter , int xx , int yy ) {  Reporter Icon l = new  Reporter Icon ( this ) ; l . set Reporter ( text Reporter ) ; l . set Location ( xx , yy ) ; l . set Size ( l . get Preferred Size ( ) . width , l . get Preferred Size ( ) . height ) ; l . set Display Level (  LABELS ) ; set Dirty ( _ BOOL ) ; put Item ( l ) ; }
private void draw Selection Rectangle (  Graphics2 D g2 ) { if ( this . selection Rectangle != null ) { if ( this . fill Selection Rectangle ) { g2 . set Paint ( this . selection Fill Paint ) ; g2 . fill ( selection Rectangle ) ; } else { g2 . set Paint ( this . selection Outline Paint ) ; g2 . draw ( selection Rectangle ) ; } } }
public  Conversion Exception ( final  Throwable cause ) { super ( cause . get Message ( ) ) ; this . cause = cause ; }
private boolean has Connectivity To All Systems (  Initiator initiator ,  Collection <  URI > storage Systems ,  Export Group export Group ) { return has Connectivity To All Systems ( initiator , storage Systems , null , export Group ) ; }
private  Derivation <  TK ,  FV > construct Derivation (  Derivation <  TK ,  FV > marked Node , int source Input Id ,  Feature Extractor <  TK ,  FV > featurizer ,  Scorer <  FV > scorer ,  Search Heuristic <  TK ,  FV > heuristic ,  Output Space <  TK ,  FV > output Space ) { final  List <  Derivation <  TK ,  FV > > nodes = new  Linked List < > ( ) ;  Derivation <  TK ,  FV > p = marked Node ; while ( p != null ) { nodes . add ( _ NUM , p ) ; p = p . parent ; } p = marked Node . best Child ; while ( p != null ) { nodes . add ( p ) ; p = p . best Child ; }  Derivation <  TK ,  FV > goal Hyp = null ; for (  Derivation <  TK ,  FV > node : nodes ) { goal Hyp = goal Hyp == null ? node : new  Derivation < > ( source Input Id , node . rule , goal Hyp . length , goal Hyp , featurizer , scorer , heuristic , output Space ) ; } return goal Hyp ; }
public void test Plus Math Context Positive ( ) {  String a = _ STR ; int a Scale = _ NUM ; int precision = _ NUM ;  Rounding Mode rm =  Rounding Mode .  FLOOR ;  Math Context mc = new  Math Context ( precision , rm ) ;  String c = _ STR ; int c Scale = _ NUM ;  Big Decimal a Number = new  Big Decimal ( new  Big Integer ( a ) , a Scale ) ;  Big Decimal res = a Number . plus ( mc ) ; assert Equals ( _ STR , c , res . to String ( ) ) ; assert Equals ( _ STR , c Scale , res . scale ( ) ) ; }
private static  IAbstract Node convert Or ( final  Common Tree ast ) throws  Recognition Exception { final  List <  IAbstract Node > children = new  Array List <  IAbstract Node > ( ) ; for ( final  Object child Object : ast . get Children ( ) ) { children . add ( convert ( (  Common Tree ) child Object ) ) ; } return new  CAbstract Or Expression ( children ) ; }
public  JDialog display Panel In Window ( final  JPanel panel ,  String title ) {  JDialog frame = new  Generic JDialog ( ) ; frame . set Content Pane ( panel ) ; frame . pack ( ) ; frame . set Title ( title ) ; frame . set Visible ( _ BOOL ) ; return frame ; }
public  Builder with Tokenizer (  Class < ? extends  Tokenizer Factory > factory ,  Map <  String ,  String > params ) throws  IOException {  Objects . require Non Null ( factory , _ STR ) ; tokenizer . set ( apply Resource Loader ( new Factory Class Instance ( factory , apply Default Params ( params ) ) ) ) ; components Added = _ BOOL ; return this ; }
protected double compute Azimuth Label Offset ( double radius , double max Radius ) { return  Math . asin (  AZIMUTH_ LABEL_ OFFSET * max Radius / radius ) ; }
public void display Changed ( ) { execute Display Changed On EDT ( get Graphics Configuration ( ) ) ; }
@  Override public  String to String ( ) {  String Builder sb = new  String Builder ( ) ;  Calendar date Time = new  Gregorian Calendar (  GMT ) ; long local Time = value ; if ( tz Shift != null ) { local Time += tz Shift . long Value ( ) * _ NUM ; } date Time . set Time In Millis ( local Time ) ; try { append Int ( sb , date Time . get (  Calendar .  YEAR ) , _ NUM ) ; sb . append ( _ STR ) ; append Int ( sb , date Time . get (  Calendar .  MONTH ) + _ NUM , _ NUM ) ; sb . append ( _ STR ) ; append Int ( sb , date Time . get (  Calendar .  DAY_ OF_ MONTH ) , _ NUM ) ; if ( ! date Only ) { sb . append ( _ STR ) ; append Int ( sb , date Time . get (  Calendar .  HOUR_ OF_ DAY ) , _ NUM ) ; sb . append ( _ STR ) ; append Int ( sb , date Time . get (  Calendar .  MINUTE ) , _ NUM ) ; sb . append ( _ STR ) ; append Int ( sb , date Time . get (  Calendar .  SECOND ) , _ NUM ) ; if ( date Time . is Set (  Calendar .  MILLISECOND ) ) { sb . append ( _ STR ) ; append Int ( sb , date Time . get (  Calendar .  MILLISECOND ) , _ NUM ) ; } } if ( tz Shift != null ) { if ( tz Shift . int Value ( ) == _ NUM ) { sb . append ( _ STR ) ; } else { int abs Tz Shift = tz Shift . int Value ( ) ; if ( tz Shift > _ NUM ) { sb . append ( _ STR ) ; } else { sb . append ( _ STR ) ; abs Tz Shift = - abs Tz Shift ; } int tz Hours = abs Tz Shift / _ NUM ; int tz Minutes = abs Tz Shift % _ NUM ; append Int ( sb , tz Hours , _ NUM ) ; sb . append ( _ STR ) ; append Int ( sb , tz Minutes , _ NUM ) ; } } } catch (  Array Index Out Of Bounds Exception e ) { throw new  Runtime Exception ( e ) ; } return sb . to String ( ) ; }
private static  Stream <  Method > extract Methods (  Class clazz ) { try {  Method [ ] methods = clazz . get Methods ( ) ; if ( methods . length > _ NUM ) { return  Stream . of ( methods ) ; } } catch (  Exception |  Error e ) {  LOG . warn ( _ STR , clazz , e ) ; } return  Stream . empty ( ) ; }
@  Override public void update Server Address (  Application application ,  String docker Manager IP ,  String server Port ,  String server Manager Port ) {  String suffix Cloud Unit = application . get Suffix Cloud Unit IO ( ) ;  Jedis Pool pool = null ;  Jedis jedis = null ; try { pool = new  Jedis Pool ( new  Jedis Pool Config ( ) , redis Ip ,  Integer . parse Int ( redis Port ) , _ NUM ) ; jedis = pool . get Resource ( ) ;  String sub Name Space = concat Sub Name Space ( application ) ;  String key = sub Name Space + suffix Cloud Unit ;  String frontend = _ STR + key . to Lower Case ( ) ; jedis . lset ( frontend , _ NUM , _ STR + docker Manager IP + _ STR + server Port ) ;  String frontend Server Manager = _ STR + key . to Lower Case ( ) ; jedis . lset ( frontend Server Manager , _ NUM , _ STR + docker Manager IP + _ STR + server Manager Port ) ; } catch (  Jedis Connection Exception |  Unsupported Encoding Exception e ) { logger . error ( _ STR , e ) ; } finally { if ( jedis != null ) { pool . destroy ( ) ; } } }
protected void remove ( int item Position ) { if ( item Position >= _ NUM && item Position < get Item Count ( ) ) { list . remove ( item Position ) ; } }
protected  String choose Random Enemys ( ) { final  List <  String > enemy List = new  Linked List <  String > ( enemy Forces . key Set ( ) ) ; final int enemy Size = enemy List . size ( ) ; final int position =  Rand . rand ( enemy Size ) ; return enemy List . get ( position ) ; }
public boolean is Route To Dest Valid (  Block protecting ,  Block destination ) { if ( protecting == destination ) { log . debug ( _ STR ) ; if ( get Adjacency ( protecting ) != null ) { return _ BOOL ; } } else if ( get Valid Route ( protecting , destination ) != null ) { return _ BOOL ; } return _ BOOL ; }
public void sort Pools (  List <  Storage Pool > storage Pools ) { _port Metrics Processor . compute Storage Pools Avg Port Metrics ( storage Pools ) ;  Collections . sort ( storage Pools , _storage Pool Comparator ) ; }
public  Rhythm Group add Overlays (  Collection <  Rhythm Overlay > overlays ) { m Overlays . add All ( overlays ) ; if ( m Current Overlay Index ==  NO_ OVERLAY ) { select Overlay ( _ NUM ) ; } return this ; }
public static  Resource for Path ( final  String path ) throws  Unknown Resource Exception {  Resource resource ; if ( path . starts With (  Classpath Resource .  PREFIX + _ STR ) ) { resource = new  Classpath Resource ( path ) ; } else if ( path . starts With (  File Resource .  PREFIX + _ STR ) ) { resource = new  File Resource ( path ) ; } else { resource = for Path (  File Resource .  PREFIX + _ STR + path ) ; } return resource ; }
private static boolean is Older Than Leopard ( ) {  String version =  System . get Property ( _ STR ) ;  String Tokenizer tk = new  String Tokenizer ( version , _ STR ) ; int major =  Integer . parse Int ( tk . next Token ( ) ) ; int minor =  Integer . parse Int ( tk . next Token ( ) ) ; return major == _ NUM && minor < _ NUM ; }
@  Override public  Enumeration <  Option > list Options ( ) {  Vector <  Option > new Vector = new  Vector <  Option > ( ) ; new Vector . add Element ( new  Option ( _ STR , _ STR , _ NUM , _ STR ) ) ; new Vector . add Element ( new  Option ( _ STR , _ STR , _ NUM , _ STR ) ) ; new Vector . add Element ( new  Option ( _ STR + _ STR , _ STR , _ NUM , _ STR ) ) ; new Vector . add Element ( new  Option ( _ STR + _ STR , _ STR , _ NUM , _ STR ) ) ; new Vector . add Element ( new  Option ( _ STR , _ STR , _ NUM , _ STR ) ) ; new Vector . add Element ( new  Option ( _ STR , _ STR , _ NUM , _ STR ) ) ; new Vector . add Element ( new  Option ( _ STR + _ STR , _ STR , _ NUM , _ STR ) ) ; new Vector . add All (  Collections . list ( super . list Options ( ) ) ) ; return new Vector . elements ( ) ; }
public static  String xml Content Escape (  String s ) {  String Builder sb = new  String Builder ( ) ; for ( int i = _ NUM ; i < s . length ( ) ; i ++ ) { char c = s . char At ( i ) ; switch ( c ) { case _ STR : sb . append ( _ STR ) ; break ; case _ STR : sb . append ( _ STR ) ; break ; case _ STR : case _ STR : case _ STR : case _ STR : case _ STR : case _ STR : case _ STR : case _ STR : case _ STR : case _ STR : case _ STR : case _ STR : case _ STR : case _ STR : case _ STR : case _ STR : case _ STR : case _ STR : case _ STR : case _ STR : case _ STR : case _ STR : case _ STR : case _ STR : case _ STR : case _ STR : case _ STR : case _ STR : case _ STR : break ; default : sb . append ( c ) ; } } return sb . to String ( ) ; }
private void feed Forward (  Vec input ,  List <  Vec > activations ,  List <  Vec > derivatives ) {  Vec x = input ; for ( int i = _ NUM ; i <  Ws . size ( ) ; i ++ ) {  Matrix  W_i =  Ws . get ( i ) ;  Vec b_i = bs . get ( i ) ;  Vec a_i = activations . get ( i ) ; a_i . zero Out ( ) ;  W_i . multiply ( x , _ NUM , a_i ) ; a_i . mutable Add ( b_i ) ; a_i . apply Function ( f ) ;  Vec d_i = derivatives . get ( i ) ; a_i . copy To ( d_i ) ; d_i . apply Function ( f . get D ( ) ) ; x = a_i ; } }
private  File find File (  File directory ,  String name ) throws  File Not Found Exception {  File file = new  File ( directory , name ) ; if ( file . exists ( ) ) { return file ; } for (  String child : directory . list ( ) ) { if ( child . equals Ignore Case ( name ) ) { return new  File ( directory , child ) ; } } throw new  File Not Found Exception ( _ STR + file ) ; }
public static boolean compare Results (  Solr Client control Client ,  Solr Client cloud Client ) throws  Solr Server Exception ,  IOException { return compare Results ( control Client , cloud Client , null , null ) ; }
public  Array List <  String >  Get Element List (  String x Path Expression ) { try {  Array List <  String > values = new  Array List <  String > ( ) ;  List < ? > node List =  XPath . select Nodes ( this . xml Document , x Path Expression ) ;  Iterator < ? > iter = node List . iterator ( ) ; while ( iter . has Next ( ) ) { org . jdom .  Element element = ( org . jdom .  Element ) iter . next ( ) ; values . add ( element . get Text ( ) ) ; } return values ; } catch (  Exception ex ) {  LOG . error ( _ STR + ex . get Message ( ) , ex ) ; return null ; } }
public static  CLContext create Context From Current GL ( ) {  Runtime Exception first = null ; for (  CLPlatform platform : list Platforms ( ) ) { try {  CLContext ctx = platform . create Context From Current GL ( ) ; if ( ctx != null ) return ctx ; } catch (  Runtime Exception ex ) { if ( first == null ) first = ex ; } } throw new  Runtime Exception ( _ STR , first ) ; }
public void collapse Tree ( ) { for ( int i = _ NUM ; i < tree . get Row Count ( ) ; ++ i ) { tree . collapse Row ( i ) ; } }
static void queue Player Cape Replacement (  Abstract Client Player player ) { final  String display Name = player . get Display Name String ( ) ;  Logger . info ( _ STR , display Name ) ;  THREAD_ POOL . submit ( null ) ; }
public void remove Vetoable Change Listener (  Vetoable Change Listener listener ) { if ( listener != null ) { synchronized ( this ) { if ( vetoable Support != null ) { vetoable Support . remove Vetoable Change Listener ( listener ) ; } } } }
public  Stream Throughput (  String status Message Prefix ) { m_instance Count = _ NUM ; m_sample Count = _ NUM ; m_num Samples = _ NUM ; m_cumulative Time = _ NUM ; m_start Time =  System . current Time Millis ( ) ; m_status Message Prefix = status Message Prefix ; }
protected void parse Command ( final  String ... args ) { for (  String arg : args ) { final  Command command =  Command . value Of Name ( arg ) ; if ( command != null ) { set Command ( command ) ; break ; } } }
@  Request Mapping ( value = _ STR , method =  Request Method .  PUT ) public  Response Entity <  Bookmark > edit Bookmark ( @  Path Variable ( value = _ STR )  String username , @  Path Variable ( value = _ STR ) int bookmark Id , @  Request Body  String json ) throws  IOException ,  Bookmark Not Found Exception ,  Illegal Access Exception ,  Invocation Target Exception {  Optional <  Bookmark > optional = bookmarks Repository . find By Id And User Username ( bookmark Id , username ) ; if ( optional . is Present ( ) ) {  Object Mapper mapper = new  Object Mapper ( ) ;  Map <  String ,  String > change Map = mapper . read Value ( json ,  Hash Map . class ) ;  Bookmark bookmark = optional . get ( ) ;  Bean Utils . populate ( bookmark , change Map ) ; bookmark = bookmarks Repository . save ( bookmark ) ; return new  Response Entity < > ( bookmark ,  Http Status .  OK ) ; } else { throw new  Bookmark Not Found Exception ( _ STR + bookmark Id ) ; } }
public static  String convert From Utf32 ( int [ ] text , int start Pos , int end Pos ) {  String Builder sb = new  String Builder ( ) ; for ( int i = start Pos ; i < end Pos ; i ++ ) { sb . append ( convert From Utf32 To Char Array ( text [ i ] ) ) ; } return sb . to String ( ) ; }
public void create Bounds ( ) { if ( is Empty ( ) || has Single Element ( ) ) { m Bounds = null ; return ; } int l =  Integer .  MAX_ VALUE ; int t =  Integer .  MAX_ VALUE ; int r = _ NUM ; int b = _ NUM ; for (  Selection .  Element selection : get Elements ( ) ) {  Constraint Widget w = selection . widget ; l =  Math . min ( w . get Draw X ( ) , l ) ; t =  Math . min ( w . get Draw Y ( ) , t ) ; r =  Math . max ( w . get Draw Right ( ) , r ) ; b =  Math . max ( w . get Draw Bottom ( ) , b ) ; }  Constraint Widget bounds = new  Constraint Widget ( l , t , r - l , b - t ) ; bounds . set Companion Widget (  Widget Companion . create ( bounds ) ) ; m Bounds = new  Element ( bounds ) ; update Origin From Bounds ( ) ; }
public static  Object [ ] find Method With List Parameters (  Object service ,  String method Name ,  List < ? > args ) {  Object [ ] arguments = new  Object [ args . size ( ) ] ; for ( int i = _ NUM ; i < args . size ( ) ; i ++ ) { arguments [ i ] = args . get ( i ) ; } return find Method With List Parameters ( service , method Name , arguments ) ; }
static int first Illegal Character (  String source ) { for ( int i = _ NUM ; i < source . length ( ) ; i ++ ) { if ( is Legal ( source . char At ( i ) ) == _ BOOL ) { return i ; } } return - _ NUM ; }
private  Coder Result decode Byte Buffer To Character Buffer ( boolean end Of Input ) throws  Decoding Exception { buffer . flip ( ) ; return decode More Bytes To Character Buffer ( end Of Input ) ; }
protected void new Fast Clock Minute ( ) { for ( int i = delayed Trains . size ( ) - _ NUM ; i >= _ NUM ; i -- ) {  Active Train at = delayed Trains . get ( i ) ; if ( ( ! at . get Started ( ) ) && at . get Delayed Start ( ) !=  Active Train .  NODELAY ) { if ( at . get Delayed Start ( ) ==  Active Train .  TIMEDDELAY ) { if ( is Fast Clock Time GE ( at . get Departure Time Hr ( ) , at . get Departure Time Min ( ) ) ) { at . set Started ( ) ; delayed Trains . remove ( i ) ; if ( _ Auto Allocate ) { auto Allocate . scan Allocation Request List ( allocation Requests ) ; } } } } else if ( at . get Started ( ) && at . get Status ( ) ==  Active Train .  READY && at . reached Restart Point ( ) ) { if ( is Fast Clock Time GE ( at . get Restart Depart Hr ( ) , at . get Restart Depart Min ( ) ) ) { at . restart ( ) ; delayed Trains . remove ( i ) ; if ( _ Auto Allocate ) { auto Allocate . scan Allocation Request List ( allocation Requests ) ; } } } } }
public void add ( final  Creature Respawn Point point ) { respawn Points . add ( point ) ; }
private void load Org Access Role (  Array List <  Org Access > list ) {  Prepared Statement pstmt = null ;  Result Set rs = null ;  String sql = _ STR + _ STR ; try { pstmt =  DB . prepare Statement ( sql , get_ Trx Name ( ) ) ; pstmt . set Int ( _ NUM , get AD_ Role_ ID ( ) ) ; rs = pstmt . execute Query ( ) ; while ( rs . next ( ) ) {  MRole Org Access oa = new  MRole Org Access ( get Ctx ( ) , rs , get_ Trx Name ( ) ) ; load Org Access Add ( list , new  Org Access ( oa . get AD_ Client_ ID ( ) , oa . get AD_ Org_ ID ( ) , oa . is Read Only ( ) ) ) ; } } catch (  Exception e ) { log . log (  Level .  SEVERE , sql , e ) ; } finally {  DB . close ( rs , pstmt ) ; } }
public void test Bytes As Source ( ) throws  Exception {  String  JSON = _ STR ; byte [ ] b =  JSON . get Bytes ( _ STR ) ; int offset = _ NUM ; int len = b . length ; byte [ ] src = new byte [ offset + len + offset ] ;  System . arraycopy ( b , _ NUM , src , offset , len ) ;  Json Factory jf = new  Json Factory ( ) ;  Json Parser jp = jf . create Json Parser ( src , offset , len ) ; assert Token (  Json Token .  START_ ARRAY , jp . next Token ( ) ) ; assert Token (  Json Token .  VALUE_ NUMBER_ INT , jp . next Token ( ) ) ; assert Equals ( _ NUM , jp . get Int Value ( ) ) ; assert Token (  Json Token .  VALUE_ NUMBER_ INT , jp . next Token ( ) ) ; assert Equals ( _ NUM , jp . get Int Value ( ) ) ; assert Token (  Json Token .  VALUE_ NUMBER_ INT , jp . next Token ( ) ) ; assert Equals ( _ NUM , jp . get Int Value ( ) ) ; assert Token (  Json Token .  VALUE_ NUMBER_ INT , jp . next Token ( ) ) ; assert Equals ( _ NUM , jp . get Int Value ( ) ) ; assert Token (  Json Token .  END_ ARRAY , jp . next Token ( ) ) ; assert Null ( jp . next Token ( ) ) ; jp . close ( ) ; }
public  String to String (  Object value ) { return to Pretty String ( value ) ; }
@  Override public  List <  Period > generate Rolling Periods (  Date Time Unit date Time Unit ) {  Calendar cal = get Calendar ( ) ; date Time Unit . set Day ( _ NUM ) ; date Time Unit = cal . minus Months ( date Time Unit , _ NUM ) ;  List <  Period > periods =  Lists . new Array List ( ) ; for ( int i = _ NUM ; i < _ NUM ; i ++ ) { periods . add ( create Period ( date Time Unit , cal ) ) ; date Time Unit = cal . plus Months ( date Time Unit , _ NUM ) ; } return periods ; }
@  Suppress Warnings ( _ STR ) public synchronized  T find Counter (  Enum < ? > counter Key ) throws  Illegal Access Exception ,  Instantiation Exception {  T counter = cache . get ( counter Key ) ; if ( counter == null ) { counter = counter Type . new Instance ( ) ; cache . put ( counter Key , counter ) ; } return counter ; }
public static  Uri add Message To Uri (  Content Resolver resolver ,  Uri uri ,  String address ,  String body ,  String subject ,  Long date , boolean read , boolean delivery Report , long thread Id ) {  Content Values values = new  Content Values ( _ NUM ) ; values . put (  Sms .  ADDRESS , address ) ; if ( date != null ) { values . put (  Sms .  DATE , date ) ; } values . put (  Sms .  READ , read ?  Integer . value Of ( _ NUM ) :  Integer . value Of ( _ NUM ) ) ; values . put (  Sms .  SUBJECT , subject ) ; values . put (  Sms .  BODY , body ) ; if ( delivery Report ) { values . put (  Sms .  STATUS ,  Sms .  STATUS_ PENDING ) ; } if ( thread Id != - _ NUM ) { values . put (  Sms .  THREAD_ ID , thread Id ) ; } return resolver . insert ( uri , values ) ; }
private void compute Doubles For All Zoom Levels ( ) { int num Frames = m Sound File . get Num Frames ( ) ; int [ ] frame Gains = m Sound File . get Frame Gains ( ) ; double [ ] smoothed Gains = new double [ num Frames ] ; if ( num Frames == _ NUM ) { smoothed Gains [ _ NUM ] = frame Gains [ _ NUM ] ; } else if ( num Frames == _ NUM ) { smoothed Gains [ _ NUM ] = frame Gains [ _ NUM ] ; smoothed Gains [ _ NUM ] = frame Gains [ _ NUM ] ; } else if ( num Frames > _ NUM ) { smoothed Gains [ _ NUM ] = ( double ) ( ( frame Gains [ _ NUM ] / _ NUM ) + ( frame Gains [ _ NUM ] / _ NUM ) ) ; for ( int i = _ NUM ; i < num Frames - _ NUM ; i ++ ) { smoothed Gains [ i ] = ( double ) ( ( frame Gains [ i - _ NUM ] / _ NUM ) + ( frame Gains [ i ] / _ NUM ) + ( frame Gains [ i + _ NUM ] / _ NUM ) ) ; } smoothed Gains [ num Frames - _ NUM ] = ( double ) ( ( frame Gains [ num Frames - _ NUM ] / _ NUM ) + ( frame Gains [ num Frames - _ NUM ] / _ NUM ) ) ; } double max Gain = _ NUM ; for ( int i = _ NUM ; i < num Frames ; i ++ ) { if ( smoothed Gains [ i ] > max Gain ) { max Gain = smoothed Gains [ i ] ; } } double scale Factor = _ NUM ; if ( max Gain > _ NUM ) { scale Factor = _ NUM / max Gain ; } max Gain = _ NUM ; int gain Hist [ ] = new int [ _ NUM ] ; for ( int i = _ NUM ; i < num Frames ; i ++ ) { int smoothed Gain = ( int ) ( smoothed Gains [ i ] * scale Factor ) ; if ( smoothed Gain < _ NUM ) smoothed Gain = _ NUM ; if ( smoothed Gain > _ NUM ) smoothed Gain = _ NUM ; if ( smoothed Gain > max Gain ) max Gain = smoothed Gain ; gain Hist [ smoothed Gain ] ++ ; } double min Gain = _ NUM ; int sum = _ NUM ; while ( min Gain < _ NUM && sum < num Frames / _ NUM ) { sum += gain Hist [ ( int ) min Gain ] ; min Gain ++ ; } sum = _ NUM ; while ( max Gain > _ NUM && sum < num Frames / _ NUM ) { sum += gain Hist [ ( int ) max Gain ] ; max Gain -- ; } double [ ] heights = new double [ num Frames ] ; double range = max Gain - min Gain ; for ( int i = _ NUM ; i < num Frames ; i ++ ) { double value = ( smoothed Gains [ i ] * scale Factor - min Gain ) / range ; if ( value < _ NUM ) value = _ NUM ; if ( value > _ NUM ) value = _ NUM ; heights [ i ] = value * value ; } algo ( m Sound File . get Num Frames ( ) ) ; total Zooms = algo Values . size ( ) + _ NUM ; m Num Zoom Levels = total Zooms ; m Len By Zoom Level = new int [ total Zooms ] ; m Zoom Factor By Zoom Level = new double [ total Zooms ] ; m Values By Zoom Level = new double [ total Zooms ] [ ] ; m Len By Zoom Level [ _ NUM ] = num Frames * _ NUM ; m Zoom Factor By Zoom Level [ _ NUM ] = _ NUM ; m Values By Zoom Level [ _ NUM ] = new double [ m Len By Zoom Level [ _ NUM ] ] ; if ( num Frames > _ NUM ) { m Values By Zoom Level [ _ NUM ] [ _ NUM ] = _ NUM * heights [ _ NUM ] ; m Values By Zoom Level [ _ NUM ] [ _ NUM ] = heights [ _ NUM ] ; } for ( int i = _ NUM ; i < num Frames ; i ++ ) { m Values By Zoom Level [ _ NUM ] [ _ NUM * i ] = _ NUM * ( heights [ i - _ NUM ] + heights [ i ] ) ; m Values By Zoom Level [ _ NUM ] [ _ NUM * i + _ NUM ] = heights [ i ] ; } m Len By Zoom Level [ _ NUM ] = num Frames ; m Values By Zoom Level [ _ NUM ] = new double [ m Len By Zoom Level [ _ NUM ] ] ; m Zoom Factor By Zoom Level [ _ NUM ] = _ NUM ; for ( int i = _ NUM ; i < m Len By Zoom Level [ _ NUM ] ; i ++ ) { m Values By Zoom Level [ _ NUM ] [ i ] = heights [ i ] ; } int location = _ NUM ; for ( int j = _ NUM ; j < total Zooms ; j ++ ) { m Len By Zoom Level [ j ] = algo Values . get ( location ) ; m Values By Zoom Level [ j ] = new double [ m Len By Zoom Level [ j ] ] ; m Zoom Factor By Zoom Level [ j ] = m Zoom Factor By Zoom Level [ j - _ NUM ] / _ NUM ; for ( int i = _ NUM ; i < m Len By Zoom Level [ j ] ; i ++ ) { m Values By Zoom Level [ j ] [ i ] = _ NUM * ( m Values By Zoom Level [ j - _ NUM ] [ ( int ) ( divisor Values . get ( location ) * i ) ] + m Values By Zoom Level [ j - _ NUM ] [ ( int ) ( divisor Values . get ( location ) * i ) + _ NUM ] ) ; } location ++ ; }  Log . i ( _ STR , _ STR ) ; m Initialized = _ BOOL ; }
@  Suppress Warnings ( _ STR ) private void expunge Stale Entries ( ) { synchronized ( sync ) {  List Weak Reference r ; while ( ( r = (  List Weak Reference ) queue . poll ( ) ) != null ) {  List Entry le = r . get List Entry ( ) ; int i = list . index Of ( le ) ; if ( i != - _ NUM ) { list . remove ( i ) ; } } } }
protected void work ( final  IResource resource , final  List <  Work Item > resources ,  IProgress Monitor monitor ) {  IPreference Store store =  Findbugs Plugin . get Plugin Preferences ( get Project ( ) ) ; boolean run As Job = store . get Boolean (  Find Bugs Constants .  KEY_ RUN_ ANALYSIS_ AS_ EXTRA_ JOB ) ;  Find Bugs Job fb Job = new  Started From Builder Job ( _ STR + resource . get Name ( ) + _ STR , resource , resources ) ; if ( run As Job ) { if (  DEBUG ) {  Findbugs Plugin . log ( _ STR ) ; }  Find Bugs Job . cancel Similar Jobs ( fb Job ) ; if (  DEBUG ) {  Findbugs Plugin . log ( _ STR ) ; } fb Job . schedule As System ( ) ; if (  DEBUG ) {  Findbugs Plugin . log ( _ STR ) ; } } else { if (  DEBUG ) {  Findbugs Plugin . log ( _ STR ) ; } fb Job . run ( monitor ) ; if (  DEBUG ) {  Findbugs Plugin . log ( _ STR ) ; } } }
@  Override public void on Full Backup (  Full Backup Data Output output ) throws  IOException { if ( m Volumes != null ) { if (  DEBUG )  Slog . i (  TAG , _ STR + m Volumes . length + _ STR ) ;  Hash Set <  String > external Files Dir Filter = new  Hash Set <  String > ( ) ; final  File external Android Root = new  File (  Environment . get External Storage Directory ( ) ,  Environment .  DIRECTORY_ ANDROID ) ; external Files Dir Filter . add ( external Android Root . get Canonical Path ( ) ) ; for ( int i = _ NUM ; i < m Volumes . length ; i ++ ) {  Storage Volume v = m Volumes [ i ] ;  String domain =  Full Backup .  SHARED_ PREFIX + i ; full Backup File Tree ( null , domain , v . get Path ( ) , external Files Dir Filter , output ) ; } } }
public static void remove Connection List (  Integer tab ) {  TABBED_ CONNECTIONS . remove ( tab . int Value ( ) ) ; }
protected void paint Range Rings (  Point2 D origin Pnt ,  Point2 D dest ,  Graphics graphics ,  Map Bean the Map ) {  Geo origin Geo = new  Geo ( origin Pnt . get Y ( ) , origin Pnt . get X ( ) , _ BOOL ) ;  Geo dest Geo = new  Geo ( dest . get Y ( ) , dest . get X ( ) , _ BOOL ) ; double distance = origin Geo . distance ( dest Geo ) ; for ( int i = _ NUM ; i <=  Math . max ( _ NUM , num Rings ) ; i ++ ) { double ring Dist = distance * ( double ) i ; paint Circle ( origin Geo , ring Dist , graphics , the Map ) ; paint Label ( origin Geo , ring Dist , graphics , the Map ) ; } }
public void translate And Append Pending ( int backoff ) throws  Unsupported Encoding Exception { int buffer End = current - backoff ; int len = buffer End - complete ; output . append ( new  String ( input , offset + complete , len , charset ) ) ; complete = buffer End ; }
@  Override public  Trie optimize (  Trie orig ) {  List <  Char Sequence > cmds = orig . cmds ;  List <  Row > rows = new  Array List < > ( ) ;  List <  Row > orows = orig . rows ; int remap [ ] = new int [ orows . size ( ) ] ; for ( int j = orows . size ( ) - _ NUM ; j >= _ NUM ; j -- ) { lift Up ( orows . get ( j ) , orows ) ; }  Arrays . fill ( remap , - _ NUM ) ; rows = remove Gaps ( orig . root , orows , new  Array List <  Row > ( ) , remap ) ; return new  Trie ( orig . forward , remap [ orig . root ] , cmds , rows ) ; }
private  Handler <  Void > install After Handler ( final  Http Server Request request , final  Buffer buffer , final  List <  Listener > after Listener ) {  Handler <  Void > after Handler = null ; return after Handler ; }
private void try Shutdown ( ) { if ( is Closing ( ) && is Ok To Close ( ) ) shutdown ( close Future . get ( ) ) ; }
public  Storage Entity create Storage Entity (  String storage Name ,  Storage Platform Entity storage Platform Entity ,  List <  Attribute > attributes ) {  Storage Entity storage Entity = new  Storage Entity ( ) ; storage Entity . set Name ( storage Name ) ; storage Entity . set Storage Platform ( storage Platform Entity ) ; if ( !  Collection Utils . is Empty ( attributes ) ) {  List <  Storage Attribute Entity > attribute Entities = new  Array List < > ( ) ; storage Entity . set Attributes ( attribute Entities ) ; for (  Attribute attribute : attributes ) {  Storage Attribute Entity attribute Entity = new  Storage Attribute Entity ( ) ; attribute Entities . add ( attribute Entity ) ; attribute Entity . set Storage ( storage Entity ) ; attribute Entity . set Name ( attribute . get Name ( ) ) ; attribute Entity . set Value ( attribute . get Value ( ) ) ; } } return storage Dao . save And Refresh ( storage Entity ) ; }
public void display Info Line (  String info Line , int label Designator ) { if ( info Line Holder != null ) { set Label ( ( info Line != null && info Line . length ( ) > _ NUM ) ? info Line : fudge String , label Designator ) ; } }
public void test Signer String Identity Scope ( ) throws  Exception {  Signer s = new  Signer Stub ( _ STR ,  Identity Scope . get System Scope ( ) ) ; assert Not Null ( s ) ; assert Equals ( _ STR , s . get Name ( ) ) ; assert Same (  Identity Scope . get System Scope ( ) , s . get Scope ( ) ) ; assert Null ( s . get Private Key ( ) ) ; try {  Signer s2 = new  Signer Stub ( _ STR ,  Identity Scope . get System Scope ( ) ) ; fail ( _ STR ) ; } catch (  Key Management Exception e ) { }  Signer s2 = new  Signer Stub ( null ) ; assert Null ( s2 . get Name ( ) ) ; }
public  TSink < byte [ ] > send Bytes (  TStream < byte [ ] > stream ) {  Objects . require Non Null ( stream , _ STR ) ; return send Binary ( stream , null ) ; }
public static  Object invoke Static Method (  Bsh Class Manager bcm ,  Class clas ,  String method Name ,  Object [ ] args ) throws  Reflect Error ,  Util Eval Error ,  Invocation Target Exception {  Interpreter . debug ( _ STR ) ;  Method method = resolve Expected Java Method ( bcm , clas , null , method Name , args , _ BOOL ) ; return invoke Method ( method , null , args ) ; }
protected  Abstract Regex NPAnnotator (  String pattern , boolean case Sensitive , double confidence ) { this (  Pattern . compile ( pattern , case Sensitive ? _ NUM :  Pattern .  CASE_ INSENSITIVE ) , _ NUM , confidence ) ; }
private static void remove Loop Safepoint (  Structured Graph graph ) {  Loop Begin Node loop Begin = find First Loop ( graph ) ; loop Begin . disable Safepoint ( ) ; }
protected abstract void bind Item (  Data Bound View Holder <  T > holder , int position ,  List <  Object > payloads ) ;
public static  Date days Before (  Date date Inst , int num Days ) { if ( ( num Days <= _ NUM ) || ( date Inst == null ) ) { throw new  Illegal Argument Exception ( ) ; } final  Calendar cal = new  Gregorian Calendar ( ) ; cal . set Time ( date Inst ) ; cal . add (  Calendar .  DAY_ OF_ YEAR , - num Days ) ; return cal . get Time ( ) ; }
public final int remaining Capacity ( ) { return  Math . max ( _ NUM , capacity - cache . size ( ) ) ; }
@  Override public void write External (  Object Output out ) throws  IOException { super . write External ( out ) ; out . write Object ( conservative Approximation ) ; }
int put Data (  Object data ) throws  Fits Exception { long lsize =  Array Funcs . compute LSize ( data ) ; if ( lsize >  Integer .  MAX_ VALUE ) { throw new  Fits Exception ( _ STR ) ; } int size = ( int ) lsize ; expand Heap ( size ) ;  Byte Array Output Stream bo = new  Byte Array Output Stream ( size ) ; try {  Buffered Data Output Stream o = new  Buffered Data Output Stream ( bo ) ; o . write Array ( data ) ; o . flush ( ) ; o . close ( ) ; } catch (  IOException e ) { throw new  Fits Exception ( _ STR , e ) ; }  System . arraycopy ( bo . to Byte Array ( ) , _ NUM , this . heap , this . heap Size , size ) ; int old Offset = this . heap Size ; this . heap Size += size ; return old Offset ; }
public void paint (  Graphics g ) { try { super . paint ( g ) ; } catch (  Exception e ) { } int focused Row = get Focused Row ( _ BOOL ) ; if ( focused Row != - _ NUM && focused Row < get Row Count ( ) ) {  Border row Border =  UIManager . get Border ( _ STR ) ; if ( row Border != null ) {  Rectangle rect = get Cell Rect ( focused Row , _ NUM , _ BOOL ) ; rect . width = get Width ( ) ; row Border . paint Border ( this , g , rect . x , rect . y , rect . width , rect . height ) ; } } }
private void add ( final  JLabel label , final  JText Field field ) { panel . add ( label ) ; panel . add ( field ) ; if ( previous == null ) { layout . put Constraint (  Spring Layout .  NORTH , panel , -  SPACING ,  Spring Layout .  NORTH , label ) ; } else { layout . put Constraint (  Spring Layout .  NORTH , label ,  SPACING ,  Spring Layout .  SOUTH , previous ) ; } layout . put Constraint (  Spring Layout .  WEST , panel , -  SPACING ,  Spring Layout .  WEST , label ) ; layout . put Constraint (  Spring Layout .  SOUTH , panel ,  SPACING ,  Spring Layout .  SOUTH , label ) ; layout . put Constraint (  Spring Layout .  EAST , field , -  SPACING ,  Spring Layout .  EAST , panel ) ; layout . put Constraint (  Spring Layout .  WEST , field , - (  TEXT_ FIELD_ WIDTH +  SPACING ) ,  Spring Layout .  EAST , panel ) ; layout . put Constraint (  Spring Layout .  SOUTH , field ,  SPACING ,  Spring Layout .  SOUTH , label ) ; previous = label ; }
private void on Track Point Start (  Attributes attributes ) { latitude = attributes . get Value (  ATTRIBUTE_ LAT ) ; longitude = attributes . get Value (  ATTRIBUTE_ LON ) ; altitude = null ; time = null ; }
public static byte [ ] combine ( final  List < byte [ ] > data Chunks ) { int total Size = _ NUM ; for ( final byte [ ] data Part : data Chunks ) { total Size += data Part . length ; } final byte [ ] data = new byte [ total Size ] ; int index = _ NUM ; for ( final byte [ ] data Part : data Chunks ) {  System . arraycopy ( data Part , _ NUM , data , index , data Part . length ) ; index += data Part . length ; } return data ; }
public void commit (  IResource [ ] resources ,  String comment , boolean keep Locks ,  IProgress Monitor monitor ) throws  Team Exception { if ( monitor == null ) { monitor = new  Null Progress Monitor ( ) ; }  Map table = get Provider Mapping ( resources ) ;  Set key Set = table . key Set ( ) ; monitor . begin Task ( _ STR , key Set . size ( ) * _ NUM ) ; monitor . set Task Name (  Policy . bind ( _ STR ) ) ;  Iterator iterator = key Set . iterator ( ) ; while ( iterator . has Next ( ) ) {  IProgress Monitor sub Monitor = new  Sub Progress Monitor ( monitor , _ NUM ) ;  SVNTeam Provider provider = (  SVNTeam Provider ) iterator . next ( ) ;  List list = (  List ) table . get ( provider ) ;  IResource [ ] provider Resources = (  IResource [ ] ) list . to Array ( new  IResource [ list . size ( ) ] ) ; provider . checkin ( provider Resources , comment , keep Locks ,  IResource .  DEPTH_ INFINITE , sub Monitor ) ; } }
public boolean can Spawn Workers ( ) { boolean can Spawn Worker = _ BOOL ; if ( verbose Log Level > _ NUM ) {  Utilities . verbose Log ( _ STR + grid Name + _ STR + tier + _ STR + max Tier Depth + _ STR + life Remaining ( ) + _ STR + maximum Life Millis ) ; } if ( ! grid Name . equals ( _ STR ) ) { return _ BOOL ; } if ( cluster State != null ) {  Long time Since Cluster Last Updated Cluster State =  System . current Time Millis ( ) - cluster State . get Last Updated ( ) ;  Utilities . verbose Log ( _ STR + time Since Cluster Last Updated Cluster State ) ; if ( time Since Cluster Last Updated Cluster State > _ NUM * grid Check Interval * _ NUM ) {  Utilities . verbose Log ( _ STR + cluster State . to String ( ) ) ; return _ BOOL ; } } else { return _ BOOL ; } if ( tier == max Tier Depth ) { return _ BOOL ; } if ( life Remaining ( ) < ( maximum Life Millis * _ NUM ) ) { return _ BOOL ; } switch ( tier ) { case _ NUM : can Spawn Worker = _ BOOL ; break ; case _ NUM : can Spawn Worker = _ BOOL ; break ; case _ NUM : can Spawn Worker = _ BOOL ; break ; case _ NUM : can Spawn Worker = _ BOOL ; break ; default : if ( grid Throttle ) { can Spawn Worker = _ BOOL ; } else { can Spawn Worker = _ BOOL ; } } return can Spawn Worker ; }
public boolean equals (  Object object ) { if ( object == null || ! ( object instanceof  Session ID ) ) { return _ BOOL ; }  Session ID another = (  Session ID ) object ; return encrypted String . equals ( another . encrypted String ) ; }
public static boolean are Identical (  String player Ident ,  Offline Player compare To ) { return player Ident . equals ( get Identification For As String ( compare To ) ) ; }
protected  String string Without Header ( ) {  String Buffer text = new  String Buffer ( ) ; for ( int i = _ NUM ; i < num Instances ( ) ; i ++ ) { text . append ( instance ( i ) ) ; if ( i < num Instances ( ) - _ NUM ) { text . append ( _ STR ) ; } } return text . to String ( ) ; }
public final <  T > void remove Internal (  List <  T > list , int position ) { if ( has Header View ( ) && position == _ NUM ) return ; if ( enable Load More ( ) && position == get Item Count ( ) - _ NUM ) return ; if ( list . size ( ) > _ NUM ) { synchronized ( m Lock ) { list . remove ( has Header View ( ) ? position - _ NUM : position ) ; } remove Notify External ( position ) ; notify Item Removed ( position ) ; } }
public  AMPrimary Mast Head View Bean (  String name ) { super ( name ) ; }
public boolean consumed Gesture ( ) { return reacted ; }
private void initialize Layer (  List <  Neuron > layer ,  Neuron Update Rule node Type , int nodes ) { for ( int i = _ NUM ; i < nodes ; i ++ ) {  Neuron node = new  Neuron ( get Parent Network ( ) , node Type ) ; layer . add ( node ) ; } }
public static double angle (  Coordinate p ) { return  Math . atan2 ( p . y , p . x ) ; }
public void fire Neuron Moved ( final  Neuron moved ) { for (  Neuron Listener listener : neuron Listeners ) { listener . neuron Moved ( new  Network Event <  Neuron > ( this , moved ) ) ; } }
public static  X509 Certificate create Certificate From Bytes ( byte [ ] cert Bytes ) {  X509 Certificate cert = null ;  Certificate Factory cert Factory ; try { cert Factory =  Certificate Factory . get Instance ( _ STR ) ;  Input Stream in = new  Byte Array Input Stream ( cert Bytes ) ; cert = (  X509 Certificate ) cert Factory . generate Certificate ( in ) ; } catch (  Certificate Exception e ) { logger . warn ( _ STR + _ STR , e ) ; } return cert ; }
void handle Selection Changed (  String selection ) { if ( m Did Expand Selection ) { m Did Expand Selection = _ BOOL ; return ; } if ( selection == null || selection . is Empty ( ) ) { schedule Invalid Tap Notification ( ) ; if ( m Selection Type ==  Selection Type .  TAP ) { reset Selection States ( ) ; return ; } } if ( selection != null && ! selection . is Empty ( ) ) { unschedule Invalid Tap Notification ( ) ; } m Selected Text = selection ; if ( m Was Tap Gesture Detected ) { m Selection Type =  Selection Type .  TAP ; handle Selection ( selection , m Selection Type ) ; m Was Tap Gesture Detected = _ BOOL ; } else { m Handler . handle Selection Modification ( selection , m X , m Y ) ; } }
public  Terms Ack Parser parse ( ) throws  Parser Configuration Exception ,  SAXException ,  Parse Failure Exception { try {  SAXParser Factory factory =  SAXParser Factory . new Instance ( ) ;  SAXParser parser = factory . new SAXParser ( ) ; parser . parse ( m Input Source , this ) ; return this ; } catch (  IOException e ) { throw new  Parse Failure Exception ( _ STR , e ) ; } }
public static  String format ( final  String value ,  String ... params ) { validate ( value ,  NULL_ STRING_ PREDICATE ,  NULL_ STRING_ MSG_ SUPPLIER ) ;  Pattern p =  Pattern . compile ( _ STR ) ;  Matcher m = p . matcher ( value ) ;  String result = value ; while ( m . find ( ) ) { int param Number =  Integer . parse Int ( m . group ( _ NUM ) ) ; if ( params == null || param Number >= params . length ) { throw new  Illegal Argument Exception ( _ STR + m . group ( ) ) ; } result = result . replace ( m . group ( ) , params [ param Number ] ) ; } return result ; }
public  Builder server (  String server ) { if ( server . ends With ( _ STR ) == _ BOOL ) { server = server + _ STR ; } this . server = server ; return this ; }
private  Response Packet execute Count (  Query Template Packet template ,  IJSpace space ,  Transaction txn ) throws  SQLException { try { template . set Routing ( get Routing ( ) ) ; template . set Explain Plan ( get Explain Plan ( ) ) ; int count = space . count ( template , txn , get Read Modifier ( ) ) ;  Response Packet response = new  Response Packet ( ) ;  Object [ ] [ ] values = new  Object [ _ NUM ] [ _ NUM ] ; values [ _ NUM ] [ _ NUM ] = count ;  Result Entry result = new  Result Entry ( new  String [ ] { get Count Column Name ( ) } , new  String [ ] { get Count Column Label ( ) } , new  String [ ] { _ STR } , values ) ; response . set Result Entry ( result ) ; return response ; } catch (  Exception e ) { if ( _logger . is Loggable (  Level .  SEVERE ) ) { _logger . log (  Level .  SEVERE , e . get Message ( ) , e ) ; } throw new  SQLException ( _ STR + e , _ STR , - _ NUM ) ; } }
void derive Confidence Value ( double base Count ) { if (  Utils . is Missing Value ( m_confidence ) && !  Utils . is Missing Value ( base Count ) && base Count > _ NUM ) { m_confidence = m_record Count / base Count ; } }
public  Modifiable Solr Params add (  String name ,  String ... val ) {  String [ ] old = vals . put ( name , val ) ; if ( old != null ) { if ( val == null || val . length < _ NUM ) {  String [ ] both = new  String [ old . length + _ NUM ] ;  System . arraycopy ( old , _ NUM , both , _ NUM , old . length ) ; both [ old . length ] = null ; vals . put ( name , both ) ; } else {  String [ ] both = new  String [ old . length + val . length ] ;  System . arraycopy ( old , _ NUM , both , _ NUM , old . length ) ;  System . arraycopy ( val , _ NUM , both , old . length , val . length ) ; vals . put ( name , both ) ; } } return this ; }
public  Byte Array Data Source (  Input Stream is ,  String type ) { try {  Byte Array Output Stream os = new  Byte Array Output Stream ( ) ; int ch ; while ( ( ch = is . read ( ) ) != - _ NUM ) { os . write ( ch ) ; } m_data = os . to Byte Array ( ) ; } catch (  IOException ioex ) { log . log (  Level .  WARNING , _ STR , ioex ) ; } if ( type != null && type . length ( ) > _ NUM ) m_type = type ; }
public static int inflate ( byte [ ] previous , int previous Length , byte [ ] current , int current Length , byte [ ] result ) { if ( previous == null ) {  System . arraycopy ( current , _ NUM , result , _ NUM , current Length ) ; return current Length ; } int length = _ NUM ; int start1 = _ NUM ; int start2 = _ NUM ; while ( start1 < previous Length && start2 < current Length ) { int end1 = start1 ; while ( end1 < previous Length && previous [ end1 ] != _ STR ) { end1 ++ ; } int end2 = start2 ; while ( end2 < current Length && current [ end2 ] != _ STR ) { end2 ++ ; } if ( current [ start2 ] == _ STR && end2 == start2 + _ NUM ) { for ( int i = start1 ; i < end1 ; i ++ ) result [ length ++ ] = previous [ i ] ; } else { for ( int i = start2 ; i < end2 ; i ++ ) result [ length ++ ] = current [ i ] ; } if ( end2 < current Length ) result [ length ++ ] = _ STR ; start1 = end1 + _ NUM ; start2 = end2 + _ NUM ; } return length ; }
private void  Legends (  List <  String > legends_list ,  List <  Integer > color_code_list ) { text Paint . set Color (  Color .  BLACK ) ; text Paint . set Text Size ( _ NUM ) ; int left = ( int ) ( graphwidth * _ NUM ) ; for ( int i = _ NUM ; i < legends_list . size ( ) ; i ++ ) {  String label = legends_list . get ( i ) ; float text_width = text Paint . measure Text ( label , _ NUM , label . length ( ) ) ; int color = color_code_list . get ( i ) ; if ( ! ( ( graphwidth - legend Left ) > ( text_width + _ NUM ) ) ) { legend Top -= _ NUM ; legend Left = left ; } add Legends ( canvas , color , legend Top , legend Left , legend Right , legend Bottom , label ) ; legend Left += ( ( int ) text_width + _ NUM ) ; } }
private void fetch Metadata (  Table Map Log Event table Event ) throws  SQLException ,  Replicator Exception { if ( metadata Cache == null ) metadata Cache = new  Table Metadata Cache ( _ NUM ) ;  Table table = metadata Cache . retrieve ( table Event . get Database Name ( ) , table Event . get Table Name ( ) ) ; if ( table == null || table . get Table Id ( ) != table Event . get Table Id ( ) ) { prepare Metadata Connection ( ) ; table = metadata Connection . find Table ( table Event . get Database Name ( ) , table Event . get Table Name ( ) , _ BOOL ) ; if ( table != null ) { table . set Table Id ( table Event . get Table Id ( ) ) ; metadata Cache . store ( table ) ; } } else if ( logger . is Debug Enabled ( ) ) logger . debug ( _ STR + table Event . get Database Name ( ) + _ STR + table Event . get Table Name ( ) + _ STR ) ; if ( table == null ) { logger . warn ( _ STR + table Event . get Database Name ( ) + _ STR + table Event . get Table Name ( ) ) ; } else { table Event . set Table ( table ) ; } }
public  String encode ( ) {  String Buffer sb = new  String Buffer ( ) ; encode ( sb ) ; return sb . to String ( ) ; }
@  Override public int read ( byte [ ] buf , int offset , int len ) throws  IOException { int available = _available ; if ( available > _ NUM ) { len =  Math . min ( len , available ) ; len = _next . read ( buf , offset , len ) ; if ( len > _ NUM ) { _available -= len ; } } else if ( available == _ NUM ) { _available = read Chunk Length ( ) ; if ( _available > _ NUM ) { len =  Math . min ( len , _available ) ; len = _next . read ( buf , offset , len ) ; if ( len > _ NUM ) _available -= len ; } else { _available = - _ NUM ; len = - _ NUM ; } } else { len = - _ NUM ; } return len ; }
@  Override public void flush ( ) {  Flush Task task ; synchronized ( log Records ) { task = new  Flush Task ( new  Array List <  String > ( log Records ) ) ; log Records . clear ( ) ; } task . run ( ) ; }
public static  Array List <  Page > page Creator Buttons (  Array List <  Page > pages ,  Item manual Type ) {  Array List <  Page > new Pages = new  Array List < > ( ) ; int page Amount = pages . size ( ) ; int times = _ NUM ; while ( page Amount > _ NUM ) {  Array List <  Page > pages Temp = new  Array List < > ( ) ; pages Temp . add All ( pages . sub List ( _ NUM * times , ( page Amount > _ NUM ? _ NUM + _ NUM * times : _ NUM * times + page Amount ) ) ) ; int height = _ NUM ;  Array List <  Manual Widget Base > widgets = new  Array List < > ( ) ; for (  Page page : pages Temp ) { widgets . add ( new  Button Widget ( _ NUM , _ NUM + height , page ) ) ; height += _ NUM ; } new Pages . add ( new  Page ( _ STR + times , (  Array List <  Manual Widget Base > ) widgets . clone ( ) , _ BOOL , manual Type ) ) ; widgets . clear ( ) ; pages Temp . clear ( ) ; page Amount -= _ NUM ; times ++ ; } return new Pages ; }
protected  List <  String > create New Export Mask Workflow For Initiators (  List <  URI > initiator URIs ,  Export Group export Group ,  Workflow workflow ,  Map <  URI ,  Integer > volume Map ,  Storage System storage ,  String token ,  String previous Step ) throws  Exception {  List <  String > new Steps = new  Array List < > ( ) ; if ( ! initiator URIs . is Empty ( ) ) {  Map <  String ,  List <  URI > > compute Resource To Initiators = map Initiators To Compute Resource ( export Group , initiator URIs ) ; for (  Map .  Entry <  String ,  List <  URI > > resource Entry : compute Resource To Initiators . entry Set ( ) ) {  String compute Key = resource Entry . get Key ( ) ;  List <  URI > compute Initiator URIs = resource Entry . get Value ( ) ; _log . info (  String . format ( _ STR , compute Key ) ) ;  Gen Export Mask Create Workflow Result result = generate Device Specific Export Mask Create Work Flow ( workflow , previous Step , storage , export Group , compute Initiator URIs , volume Map , token ) ; previous Step = result . get Step Id ( ) ; new Steps . add ( previous Step ) ; } } if ( new Steps . is Empty ( ) && previous Step != null ) { new Steps . add ( previous Step ) ; } return new Steps ; }
public boolean is Less Then (  Percent  Percent ) { assert Defined ( ) ;  Big Decimal this Value = not Null ( this ) ;  Big Decimal parameter = not Null (  Percent ) ; return ( this Value . compare To ( parameter ) < _ NUM ) ; }
@  Override public  URI to Edge URI ( final  Object key ) { return to URI ( key . to String ( ) ) ; }
public static  List <  INavi Project > load Projects ( final  Abstract SQLProvider provider , final  Debugger Template Manager debugger Manager ) throws  Couldnt Load Data Exception {  Postgre SQLDatabase Functions . check Arguments ( provider , debugger Manager ) ; final  CConnection connection = provider . get Connection ( ) ; final  List <  INavi Project > projects = new  Array List < > ( ) ; if ( !  Postgre SQLHelpers . has Table ( connection ,  CTable Names .  PROJECTS_ TABLE ) ) { return projects ; }  String query = _ STR + _ STR +  CTable Names .  ADDRESS_ SPACES_ TABLE + _ STR +  CTable Names .  PROJECTS_ TABLE + _ STR + _ STR +  CTable Names .  PROJECTS_ TABLE ; try (  Result Set result Set = connection . execute Query ( query , _ BOOL ) ) { while ( result Set . next ( ) ) { final int project Id = result Set . get Int ( _ STR ) ; final  String name =  Postgre SQLHelpers . read String ( result Set , _ STR ) ; final  String description =  Postgre SQLHelpers . read String ( result Set , _ STR ) ; final int address Space Count = result Set . get Int ( _ STR ) ; final  Timestamp creation Date = result Set . get Timestamp ( _ STR ) ; final  Timestamp modification Date = result Set . get Timestamp ( _ STR ) ; final  List <  Debugger Template > debuggers =  Postgre SQLDatabase Functions . get Assigned Debuggers ( connection , project Id , debugger Manager ) ; projects . add ( new  CProject ( project Id , name , description == null ? _ STR : description , creation Date , modification Date , address Space Count , debuggers , provider ) ) ; } } catch ( final  SQLException e ) { throw new  Couldnt Load Data Exception ( e ) ; } return new  Array List <  INavi Project > ( projects ) ; }
public  String syllabify (  String phone String ) {  Linked List <  String > phone List = split Into Allophones ( phone String ) ; syllabify ( phone List ) ;  String Builder sb = new  String Builder ( ) ; for (  String p : phone List ) { if ( sb . length ( ) > _ NUM ) sb . append ( _ STR ) ; sb . append ( p ) ; } return sb . to String ( ) ; }
@  Override protected  Node remove From Frontier ( ) { clean Up Frontier ( ) ;  Node result = frontier . remove ( ) ; update Metrics ( frontier . size ( ) ) ; set Explored ( result ) ; return result ; }
public static boolean is File (  String path ) {  File f = new  File ( path ) ; return f . is File ( ) ; }
public boolean equals (  Object object ) { if ( ! ( object instanceof  Object Instance ) ) { return _ BOOL ; }  Object Instance val = (  Object Instance ) object ; if ( ! name . equals ( val . get Object Name ( ) ) ) return _ BOOL ; if ( class Name == null ) return ( val . get Class Name ( ) == null ) ; return class Name . equals ( val . get Class Name ( ) ) ; }
public  Zookeeper Embedded ( int port ) { this . port = port ; this . log Dir = new  File (  System . get Property ( _ STR ) , _ STR + port ) ; }
public  Basic Condition (  String variable ,  Value value ,  Relation relation ) { this . variable =  Template . create ( variable ) ; this . template Value =  Template . create ( value . to String ( ) ) ; this . ground Value = value ; this . relation = relation ; }
public static  Set <  String > read Stopwords Path (  Path path , boolean lowercase ) throws  IOException { return read Stopwords Input Stream (  Files . new Input Stream ( path ) , lowercase ) ; }
@  Override public  String to String ( ) {  String Builder s Rep = new  String Builder ( ) ; s Rep . append ( _ STR ) ; s Rep . append ( article ID ) ; s Rep . append ( _ STR ) ; s Rep . append ( revision Counter ) ; s Rep . append ( _ STR ) ; s Rep . append ( time Stamp ) ; s Rep . append ( _ STR ) ; s Rep . append ( revision Id ) ; if ( revision Text != null ) { s Rep . append ( _ STR ) ; s Rep . append ( revision Text . length ( ) ) ; } s Rep . append ( _ STR ) ; return s Rep . to String ( ) ; }
protected void send Log Event (  String component ,  String message ,  Callback <  Object > callback ) {  String syslog Message =  String . format (  Locale .  US , _ STR , get Sys Log Formatted Date ( ) , utils . get Application Name ( context ) , component , message ) ; send Data Over UDP ( syslog Message , callback ) ; }
public static <  T extends  Throwable >  T write Stack Traces (  T throwable ,  Stream Output out ) throws  IOException {  Stack Trace Element [ ] stack Trace = throwable . get Stack Trace ( ) ; out . write VInt ( stack Trace . length ) ; for (  Stack Trace Element element : stack Trace ) { out . write String ( element . get Class Name ( ) ) ; out . write Optional String ( element . get File Name ( ) ) ; out . write String ( element . get Method Name ( ) ) ; out . write VInt ( element . get Line Number ( ) ) ; }  Throwable [ ] suppressed = throwable . get Suppressed ( ) ; out . write VInt ( suppressed . length ) ; for (  Throwable t : suppressed ) { out . write Throwable ( t ) ; } return throwable ; }
public  Distributed Log Multi Stream Writer build ( ) {  Preconditions . check Argument ( ( null != _streams && ! _streams . is Empty ( ) ) , _ STR ) ;  Preconditions . check Not Null ( _client , _ STR ) ;  Preconditions . check Not Null ( _codec , _ STR ) ;  Preconditions . check Argument ( _first Speculative Timeout Ms > _ NUM && _first Speculative Timeout Ms <= _max Speculative Timeout Ms && _speculative Backoff Multiplier > _ NUM && _max Speculative Timeout Ms < _request Timeout Ms , _ STR ) ; return new  Distributed Log Multi Stream Writer ( _streams , _client ,  Math . min ( _buffer Size ,  MAX_ LOGRECORDSET_ SIZE ) , _flush Interval Micros , _request Timeout Ms , _first Speculative Timeout Ms , _max Speculative Timeout Ms , _speculative Backoff Multiplier , _codec , _ticker , _executor Service ) ; }
private  Image Element ( int  AD_ Print Format Item_ ID ) { load Attachment (  AD_ Print Format Item_ ID ) ; }
public  Thread Register Values ( final  Thread Registers values ) { m_tid = values . get Tid ( ) ; for ( final  Register Value value : values . get Registers ( ) ) { m_values . add ( new  Register ( value ) ) ; } }
public  Launcher Discovery Request Builder configuration Parameters (  Map <  String ,  String > configuration Parameters ) {  Preconditions . not Null ( configuration Parameters , _ STR ) ; configuration Parameters . for Each ( null ) ; return this ; }
public void add All ( int index , int [ ] data ) { int data Len = data . length ; if ( data Len == _ NUM ) { return ; } int newcap = size + ( int ) ( data Len * _ NUM ) + _ NUM ; ensure Capacity ( newcap ) ;  System . arraycopy ( array , index , array , index + data Len , size - index ) ;  System . arraycopy ( data , _ NUM , array , index , data Len ) ; size += data Len ; }
public int read ( byte [ ] b ) throws java . io .  IOException { return read ( b , _ NUM , b . length ) ; }
public void remove Scanning Callback (  One Sheeld Scanning Callback scanning Callback ) { if ( scanning Callback != null && scanning Callbacks . contains ( scanning Callback ) ) scanning Callbacks . remove ( scanning Callback ) ; }
public void paint Rect (  Graphics g ,  JComponent c , int x , int y , int w , int h ) {  Rectangle bounds = c . get Bounds ( ) ; check ( bounds ) ; g . draw Image ( m_back Image , x , y , x + w , h + y , x , y , x + w , y + h , c ) ; }
@  Override public final void sample ( ) { _value = _acquire Count . get ( ) - _release Count . get ( ) ; }
private boolean is Page Break ( int row ) { for ( int i = _ NUM ; i < m_page Break . size ( ) ; i ++ ) {  Integer rr = (  Integer ) m_page Break . get ( i ) ; if ( rr . int Value ( ) + _ NUM == row ) return _ BOOL ; else if ( rr . int Value ( ) > row ) return _ BOOL ; } return _ BOOL ; }
public  Executor Service shutdown ( ) { pool . shutdown ( ) ; return pool ; }
public static boolean is Proposition Symbol Identifier Part ( char ch ) { return  Character . is Java Identifier Part ( ch ) ; }
public static void o (  Zdiagmat  D ) { o (  D ,  Parameters .  Output Field Width ,  Parameters .  Output Frac Places ) ; }
public int search (  String txt ) { int  M = pat . length ( ) ; int  N = txt . length ( ) ; int skip ; for ( int i = _ NUM ; i <=  N -  M ; i += skip ) { skip = _ NUM ; for ( int j =  M - _ NUM ; j >= _ NUM ; j -- ) { if ( pat . char At ( j ) != txt . char At ( i + j ) ) { skip =  Math . max ( _ NUM , j - right [ txt . char At ( i + j ) ] ) ; break ; } } if ( skip == _ NUM ) return i ; } return  N ; }
public  String to Chars ( int [ ] indices ) {  String Builder s = new  String Builder ( indices . length ) ; for ( int i = _ NUM ; i < indices . length ; i ++ ) s . append ( to Char ( indices [ i ] ) ) ; return s . to String ( ) ; }
public static final  String trunc ( final  String str , final int length ) { if ( str == null ) { return str ; } if ( str . length ( ) <= length ) { return str ; } return str . substring ( _ NUM , length ) ; }
public void clear Transactions ( int from Height ) { lock . lock ( ) ; try { if ( from Height == _ NUM ) { unspent . clear ( ) ; spent . clear ( ) ; pending . clear ( ) ; dead . clear ( ) ; transactions . clear ( ) ; } else { throw new  Unsupported Operation Exception ( ) ; } } finally { lock . unlock ( ) ; } }
@  Override public boolean load ( final  Player player , final  List <  String > args ) { groovy Binding . set Variable ( _ STR , player ) ; if ( args != null ) { groovy Binding . set Variable ( _ STR , args . to Array ( new  String [ args . size ( ) ] ) ) ; } else { groovy Binding . set Variable ( _ STR , new  String [ _ NUM ] ) ; } final  Groovy Shell interp = new  Groovy Shell ( groovy Binding ) ; boolean ret = _ BOOL ; pre Execute ( player , args ) ; try { final  File f = new  File ( groovy Script ) ; interp . evaluate ( f ) ; } catch ( final  Exception e ) { logger . error ( _ STR + groovy Script , e ) ; set Message ( e . get Message ( ) ) ; ret = _ BOOL ; } catch ( final  Error e ) { logger . error ( _ STR + groovy Script , e ) ; set Message ( e . get Message ( ) ) ; ret = _ BOOL ; } post Execute ( player , args , ret ) ; return ( ret ) ; }
@  Override public boolean was Successful ( ) { return is Finished ( ) && get Current Points ( ) >= success Threashold ; }
void start Locating Phone ( ) {  Intent intent = new  Intent ( s Context ,  Location Service . class ) ; intent . set Action (  Location Service .  START_ SERVICE ) ; intent . put Extra ( _ STR , this . m Answer To ) ; s Context . start Service ( intent ) ; }
public void delete Resource Config (  String cluster Name ,  Resource Type resource Type ,  String ds Name ) throws  Configuration Exception { if ( get Cluster Home ( ) == null ) { throw new  Configuration Exception ( _ STR ) ; }  File resources = get Dir ( get Resource Config Dir Name ( get Cluster Home ( ) , cluster Name , resource Type ) ) ;  String del File Name = resources . get Absolute Path ( ) +  File . separator + ds Name + _ STR ; del File ( del File Name ) ; }
public  Bus Movement (  Bus Movement proto ) { super ( proto ) ; this . control System = proto . control System ; this . id = next ID ++ ; control System . register Bus ( this ) ; start Mode = _ BOOL ; }
private void create Gui ( ) { for ( final  IResults Panel panel : m_factory ) { m_tabbed Pane . add Tab ( panel . get Title ( ) , panel . get Component ( ) ) ; } add ( m_tabbed Pane ,  Border Layout .  CENTER ) ; m_tabbed Pane . set Visible ( _ BOOL ) ; }
public static float generate Random Float Between ( float lower Limit , float upper Limit ) { return lower Limit + ( ( upper Limit - lower Limit ) * _r . next Float ( ) ) ; }
public  SGen Item Provider Adapter Factory ( ) { supported Types . add (  IEditing Domain Item Provider . class ) ; supported Types . add (  IStructured Item Content Provider . class ) ; supported Types . add (  ITree Item Content Provider . class ) ; supported Types . add (  IItem Label Provider . class ) ; supported Types . add (  IItem Property Source . class ) ; }
private void kd Range Search ( int left , int right , int axis ,  O query ,  Modifiable Double DBIDList res ,  DBIDArray Iter iter , double radius ) { if ( right - left <= leafsize ) { for ( iter . seek ( left ) ; iter . get Offset ( ) < right ; iter . advance ( ) ) { double dist = norm . distance ( query , relation . get ( iter ) ) ; count Object Access ( ) ; count Distance Computation ( ) ; if ( dist <= radius ) { res . add ( dist , iter ) ; } } return ; } final int middle = ( left + right ) > > > _ NUM ;  O split = relation . get ( iter . seek ( middle ) ) ; count Object Access ( ) ; final double delta = split . double Value ( axis ) - query . double Value ( axis ) ; final boolean onleft = ( delta >= _ NUM ) ; final boolean onright = ( delta <= _ NUM ) ; final boolean close = (  Math . abs ( delta ) <= radius ) ; final int next = ( axis + _ NUM ) % dims ; if ( close ) { double dist = norm . distance ( query , split ) ; count Distance Computation ( ) ; if ( dist <= radius ) { assert ( iter . get Offset ( ) == middle ) ; res . add ( dist , iter ) ; } } if ( left < middle && ( onleft || close ) ) { kd Range Search ( left , middle , next , query , res , iter , radius ) ; } if ( middle + _ NUM < right && ( onright || close ) ) { kd Range Search ( middle + _ NUM , right , next , query , res , iter , radius ) ; } }
private void handle Start Element (  XMLStream Reader parser ,  Set <  Node > children Found ,  Handler handler ,  Map <  String ,  Object > values ,  Stack <  Set <  String > > stack , boolean record Started ) throws  IOException ,  XMLStream Exception {  Node n = get Matching Node ( parser , child Nodes ) ;  Map <  String ,  Object > decends = new  Hash Map < > ( ) ; if ( n != null ) { children Found . add ( n ) ; n . parse ( parser , handler , values , stack , record Started ) ; return ; }  Node dn = this ; do { if ( dn . wild Card Nodes != null ) { n = get Matching Node ( parser , dn . wild Card Nodes ) ; if ( n != null ) { children Found . add ( n ) ; n . parse ( parser , handler , values , stack , record Started ) ; break ; } for (  Node nn : dn . wild Card Nodes ) decends . put ( nn . name , nn ) ; } dn = dn . wild Ancestor ; } while ( dn != null ) ; if ( n == null ) { int count = _ NUM ; while ( count != _ NUM ) { int token = parser . next ( ) ; if ( token ==  START_ ELEMENT ) {  Node nn = (  Node ) decends . get ( parser . get Local Name ( ) ) ; if ( nn != null ) { children Found . add ( nn ) ; nn . parse ( parser , handler , values , stack , record Started ) ; } else count ++ ; } else if ( token ==  END_ ELEMENT ) count -- ; } } }
private void connect ( ) { if ( ! connected ) { update Info ( ) ;  String connect String = _ STR + connect Address + _ STR + connect Port ; if ( client Id == null || client Id . length ( ) < _ NUM ) { out ( get Date ( ) +  Messages .  Mqtt Client View_15 + connect String +  Messages .  Mqtt Client View_16 ) ; return ; } try { if ( first Connect ) { mqtt Client = new  Mqtt Client ( connect String , client Id ) ; mqtt Client . set Callback ( this ) ; first Connect = _ BOOL ; } } catch (  Mqtt Exception e ) { out ( get Date ( ) +  Messages .  Mqtt Client View_17 + e . get Message ( ) ) ; e . print Stack Trace ( ) ; } conn Opts = new  Mqtt Connect Options ( ) ; conn Opts . set Clean Session ( clean Start ) ; conn Opts . set Connection Timeout ( _ NUM ) ; conn Opts . set Keep Alive Interval ( keep Alive ) ; if ( username . length ( ) > _ NUM && password . length ( ) > _ NUM ) { conn Opts . set Password ( password . to Char Array ( ) ) ; conn Opts . set User Name ( username ) ; } if ( use Will ) { if ( will Topic == null || will Topic . equals ( _ STR ) ) { out (  Messages .  Mqtt Client View_19 ) ; return ; } conn Opts . set Will ( mqtt Client . get Topic ( will Topic ) , will Message . get Bytes ( ) , will Qos , will Retain ) ; } try { out ( get Date ( ) +  Messages .  Mqtt Client View_20 + connect String ) ; mqtt Client . connect ( conn Opts ) ; connected = _ BOOL ; out ( get Date ( ) +  Messages .  Mqtt Client View_21 + client Id ) ; } catch (  Mqtt Exception e ) { out ( get Date ( ) +  Messages .  Mqtt Client View_22 + e . get Message ( ) ) ; e . print Stack Trace ( ) ; } } else { out (  Messages .  Mqtt Client View_23 ) ; } }
synchronized void add Tracer (  Tracer tracer ) { if ( cur Tracers . add ( tracer ) ) {  LOG . trace ( to String ( ) + _ STR + tracer . to String ( ) ) ; } }
private void grow ( ) { int new Cap = ( entries . length << _ NUM ) + _ NUM ;  Object [ ] new Entries = new  Object [ new Cap ] ;  System . arraycopy ( entries , _ NUM , new Entries , _ NUM , size ) ; entries = new Entries ; }
public void damage ( double value ) { set Value (  Math . max ( _ NUM , get Value ( ) - value ) ) ; }
@  Ignore ( _ STR ) @  Test public void test Concurrent Events On Empty Region ( ) { version Test Concurrent Events On Empty Region ( ) ; }
public  Graph ( ) { roots = new  Array List <  Node > ( ) ; nodes = new  Array List <  Node > ( ) ; string = _ STR ; }
private static  String trim Version (  String api Version ) { if ( api Version == null ) { return null ; } else {  String [ ] version Parts = api Version . split ( _ STR ) ; return version Parts [ version Parts . length - _ NUM ] ; } }
@  Override public void incoming Object (  IAnalyzed Interval analyzed Interval ) throws  Ade Exception { if ( ! m_percentiles With Empty Intervals && analyzed Interval . get Num Unique Message Ids ( ) == _ NUM ) { return ; } final double raw Score = calc Raw Score ( analyzed Interval ) ; if ( !  Seen Huge Log Prob ( analyzed Interval ) ) { m_raw Scores . add ( raw Score ) ; ++ m_interval Count ; } }
public static  String read File As String (  File file ,  String encoding ) throws  IOException {  Byte Buffer buffer = read File ( file ) ; if ( null == encoding ) { encoding = _ STR ; }  String converted = new  String ( buffer . array ( ) , encoding ) ; return converted ; }
public  Em Bayes Estimator Editor (  Em Bayes Estimator Wrapper em Bayes Est Wrapper ) { this ( em Bayes Est Wrapper . get Estimate Bayes Im ( ) , em Bayes Est Wrapper . get Data Set ( ) ) ; }
public boolean need Preload Key ( int idx ) { return preload Keys != null && preload Keys . get ( idx ) ; }
public int generate Challenge Token (  Inet Socket Address address ) { int token = random . next Int ( ) ; challenge Tokens . put ( address , token ) ; return token ; }
@  Override public void perform (  IR ir ) { for (  Enumeration <  Basic Block > e = ir . get Basic Blocks ( ) ; e . has More Elements ( ) ; ) {  Basic Block bb = e . next Element ( ) ; if ( bb . is Empty ( ) ) continue ; container . counter2 ++ ; if ( bb . get Infrequent ( ) ) { container . counter1 ++ ; if ( ir . options .  FREQ_ FOCUS_ EFFORT ) continue ; } for (  Enumeration <  Instruction > ie = bb . forward Instr Enumerator ( ) ; ie . has More Elements ( ) ; ) {  Instruction s = ie . next Element ( ) ; if (  Type Check . conforms ( s ) && ( invert Null And Type Checks ( s ) || push Type Check Below If ( s , ir ) ) ) { ie = bb . forward Instr Enumerator ( ) ; } } } }
public void run With Retries (  Retryable Task task ) throws  Exception { boolean max Sleep Interval Hit = _ BOOL ; for ( int i = _ NUM ; i < num Attempts ; i ++ ) { try { task . run ( ) ; return ; } catch (  Exception e ) { if ( i == num Attempts - _ NUM ) { throw e ; } int sleep Time ; if ( max Sleep Interval Hit ) { sleep Time = max Sleep Interval ; } else { sleep Time = base Sleep Interval * ( int )  Math . pow ( _ NUM , i ) ; }  LOG . error ( _ STR + sleep Time + _ STR , e ) ; try {  Thread . sleep ( sleep Time * _ NUM ) ; } catch (  Interrupted Exception ie ) {  LOG . error ( _ STR , ie ) ; throw ie ; } } } }
public  Object pack ( ) { if ( collection ) {  List l = (  List ) value ; if (  Types . is Array ( type ) ) {  Object [ ] o = (  Object [ ] )  Array . new Instance ( item Type , l . size ( ) ) ; l . to Array ( o ) ; return o ; } } return value ; }
public void remove Request (  Interrupt Request interrupt Request ) { synchronized ( interrupt Request Queue ) { interrupt Request Queue . remove ( interrupt Request ) ; } }
@  Override public final void on Heatmap Failed ( ) { update Pending = _ BOOL ; }
@  Suppress Lint ( _ STR ) @  Nullable public static  Drawable inflate ( boolean force System Handling When Possible , @  Non Null  Resources resources , @  Drawable Res int id ) { boolean system Handling = is System Handling ( force System Handling When Possible ) ;  Log . d (  LOG_ TAG ,  String . format ( _ STR ,  Integer . to Hex String ( id ) , system Handling ) ) ; if ( system Handling ) { return resources . get Drawable ( id , null ) ; } try { return  Vector Drawable . create ( resources , id ) ; } catch (  Resources .  Not Found Exception e ) { return null ; } }
public static long object Field Offset (  Field field ) { return  UNSAFE . object Field Offset ( field ) ; }
protected synchronized void write ( long offset , byte [ ] b ) throws  IOException { if ( byte Buffer != null ) { byte Buffer . position ( ( int ) offset ) ; byte Buffer . put ( b ) ; } else { throw new  IOException ( _ STR + get Path ( ) + _ STR ) ; } }
long timestamp ( long timestamp ) { this . timestamp =  Math . max ( this . timestamp , timestamp ) ; return this . timestamp ; }
public  Material Package (  Material Package BO material Package BO ,  List <  Generic Track > generic Tracks ) { super ( material Package BO ) ; this . material Package BO = material Package BO ; this . generic Tracks =  Collections . unmodifiable List ( generic Tracks ) ; }
public  Edge find Edge In Same Direction (  Coordinate p0 ,  Coordinate p1 ) { for ( int i = _ NUM ; i < edges . size ( ) ; i ++ ) {  Edge e = (  Edge ) edges . get ( i ) ;  Coordinate [ ] e Coord = e . get Coordinates ( ) ; if ( match In Same Direction ( p0 , p1 , e Coord [ _ NUM ] , e Coord [ _ NUM ] ) ) return e ; if ( match In Same Direction ( p0 , p1 , e Coord [ e Coord . length - _ NUM ] , e Coord [ e Coord . length - _ NUM ] ) ) return e ; } return null ; }
public void acquire Probabilities ( final  String string ) { if ( string . length ( ) < _ NUM ) { return ; } for ( int i = _ NUM ; i < string . length ( ) ; ++ i ) { final char previous Char = string . char At ( i - _ NUM ) ; final char current Char = string . char At ( i - _ NUM ) ; final char next Char = string . char At ( i ) ; final  String key = previous Char + _ STR + current Char ; if ( ! sequences . contains ( key ) ) { sequences . add ( key ) ; }  Hash Map <  Character ,  Integer > probabilities = sequence Probabilities . get ( key ) ; if ( probabilities == null ) { probabilities = new  Hash Map < > ( ) ; sequence Probabilities . put ( key , probabilities ) ; } int existing Value = probabilities . get Or Default ( next Char , _ NUM ) ; ++ existing Value ; probabilities . put ( next Char , existing Value ) ; } }
protected final void resolve Issue (  Health Issue health Issue ) {  Event Bus event Bus ; boolean was Issue Active ; synchronized ( m Lock ) { if ( m Health Event Bus == null ) {  LOG . w ( _ STR + _ STR , health Issue . to String ( ) ) ; return ; } event Bus = m Health Event Bus ; was Issue Active = m Active Issues . remove ( health Issue ) ; } if ( was Issue Active ) { event Bus . post ( health Issue . resolved ) ; } }
private static boolean test (  ODatabase Document Pool pool ,  String db URL ,  String user ,  String password , boolean final Try ) {  ODatabase Document Tx db = null ; try { logger . info ( _ STR ) ; db = pool . acquire ( db URL , user , password ) ;  Iterator <  ODocument > iter = db . browse Class ( _ STR ) ; if ( iter . has Next ( ) ) { iter . next ( ) ; } } catch (  OException ex ) { if ( final Try ) { logger . info ( _ STR , ex ) ; } else { logger . debug ( _ STR , ex ) ; } return _ BOOL ; } finally { if ( db != null ) { db . close ( ) ; } } return _ BOOL ; }
@  Override public void agg (  Object new Val ) { if ( new Val instanceof byte [ ] ) { byte [ ] values = ( byte [ ] ) new Val ;  Byte Buffer buffer =  Byte Buffer . wrap ( values ) ; buffer . rewind ( ) ; while ( buffer . has Remaining ( ) ) { value Set . add ( buffer . get Int ( ) ) ; } return ; } else { double value = new  Double ( new Val . to String ( ) ) ; agg ( value ) ; } }
private void display Easter Egg (  Command Sender sender ) { sender . send Message (  String Escape Utils . unescape Java ( _ STR ) ) ; sender . send Message (  String Escape Utils . unescape Java ( _ STR ) ) ; sender . send Message (  String Escape Utils . unescape Java ( _ STR ) ) ; sender . send Message (  String Escape Utils . unescape Java ( _ STR ) ) ; sender . send Message (  String Escape Utils . unescape Java ( _ STR ) ) ; sender . send Message (  String Escape Utils . unescape Java ( _ STR ) ) ; sender . send Message (  String Escape Utils . unescape Java ( _ STR ) ) ; sender . send Message (  String Escape Utils . unescape Java ( _ STR ) ) ; sender . send Message (  String Escape Utils . unescape Java ( _ STR ) ) ; sender . send Message (  String Escape Utils . unescape Java ( _ STR ) ) ; sender . send Message (  String Escape Utils . unescape Java ( _ STR ) ) ; sender . send Message (  String Escape Utils . unescape Java ( _ STR ) ) ; sender . send Message (  String Escape Utils . unescape Java ( _ STR ) ) ; sender . send Message (  String Escape Utils . unescape Java ( _ STR ) ) ; sender . send Message (  String Escape Utils . unescape Java ( _ STR ) ) ; sender . send Message (  String Escape Utils . unescape Java ( _ STR ) ) ; sender . send Message (  String Escape Utils . unescape Java ( _ STR ) ) ; sender . send Message (  String Escape Utils . unescape Java ( _ STR ) ) ; sender . send Message (  String Escape Utils . unescape Java ( _ STR ) ) ; sender . send Message (  String Escape Utils . unescape Java ( _ STR ) ) ; sender . send Message (  String Escape Utils . unescape Java ( _ STR ) ) ; sender . send Message (  String Escape Utils . unescape Java ( _ STR ) ) ; sender . send Message (  String Escape Utils . unescape Java ( _ STR ) ) ; sender . send Message (  String Escape Utils . unescape Java ( _ STR ) ) ; sender . send Message (  String Escape Utils . unescape Java ( _ STR ) ) ; sender . send Message (  String Escape Utils . unescape Java ( _ STR ) ) ; sender . send Message (  String Escape Utils . unescape Java ( _ STR ) ) ; sender . send Message (  String Escape Utils . unescape Java ( _ STR ) ) ; sender . send Message (  String Escape Utils . unescape Java ( _ STR ) ) ; sender . send Message (  String Escape Utils . unescape Java ( _ STR ) ) ; sender . send Message (  String Escape Utils . unescape Java ( _ STR ) ) ; sender . send Message (  String Escape Utils . unescape Java ( _ STR ) ) ; }
public boolean is Unparsed Entity (  String entity Name ) {  Entity entity = (  Entity ) f Entities . get ( entity Name ) ; if ( entity == null ) { return _ BOOL ; } return entity . is Unparsed ( ) ; }
protected void process Focus Event (  Focus Event evt ) { super . process Focus Event ( evt ) ; if ( evt . get ID ( ) ==  Focus Event .  FOCUS_ LOST ) { if ( popup != null ) hide Popup ( ) ; } }
@  Override public synchronized void add Request Property (  String key ,  String value ) { if ( connected || connecting ) throw new  Illegal State Exception ( _ STR ) ; if ( key == null ) throw new  Null Pointer Exception ( _ STR ) ; if ( is External Message Header Allowed ( key , value ) ) { requests . add ( key , value ) ; if ( ! key . equals Ignore Case ( _ STR ) ) { user Headers . add ( key , value ) ; } } }
public void execute (  Abortable Task task ) {  Aborting Runnable ar = new  Aborting Runnable ( task ) ; tasks . add ( ar ) ; try { exec . execute ( ar ) ; } catch (  Rejected Execution Exception e ) { tasks . remove ( ar ) ; throw e ; } }
default  Byte Buffer serialize (  T value ) {  Byte Buffer buffer =  Byte Buffer . allocate ( size ( value ) ) ; serialize ( value , buffer ) ; return buffer ; }
private void load Submissions ( ) { submissions . clear ( ) ;  String [ ] users =  JPlag Central . users List ( ) ; for ( int i = _ NUM ; i < users . length ; i ++ ) {  Access Structure [ ] subm =  JPlag Central . list Access Structures ( users [ i ] ) ; if ( subm != null && subm . length != _ NUM ) { for ( int j = _ NUM ; j < subm . length ; j ++ ) { submissions . add ( subm [ j ] ) ; } } } }
private void sub Format ( int pattern Char Index , int count ,  Field Delegate delegate ,  String Buffer buffer , boolean use Date Format Symbols ) { int max Int Count =  Integer .  MAX_ VALUE ;  String current = null ; int begin Offset = buffer . length ( ) ; int field =  PATTERN_ INDEX_ TO_ CALENDAR_ FIELD [ pattern Char Index ] ; int value ; if ( field ==  Calendar Builder .  WEEK_ YEAR ) { if ( calendar . is Week Date Supported ( ) ) { value = calendar . get Week Year ( ) ; } else { pattern Char Index =  PATTERN_ YEAR ; field =  PATTERN_ INDEX_ TO_ CALENDAR_ FIELD [ pattern Char Index ] ; value = calendar . get ( field ) ; } } else if ( field ==  Calendar Builder .  ISO_ DAY_ OF_ WEEK ) { value =  Calendar Builder . to ISODay Of Week ( calendar . get (  Calendar .  DAY_ OF_ WEEK ) ) ; } else { value = calendar . get ( field ) ; } int style = ( count >= _ NUM ) ?  Calendar .  LONG :  Calendar .  SHORT ; if ( ! use Date Format Symbols && field <  Calendar .  ZONE_ OFFSET && pattern Char Index !=  PATTERN_ MONTH_ STANDALONE ) { current = calendar . get Display Name ( field , style , locale ) ; } switch ( pattern Char Index ) { case  PATTERN_ ERA : if ( use Date Format Symbols ) {  String [ ] eras = format Data . get Eras ( ) ; if ( value < eras . length ) { current = eras [ value ] ; } } if ( current == null ) { current = _ STR ; } break ; case  PATTERN_ WEEK_ YEAR : case  PATTERN_ YEAR : if ( calendar instanceof  Gregorian Calendar ) { if ( count != _ NUM ) { zero Padding Number ( value , count , max Int Count , buffer ) ; } else { zero Padding Number ( value , _ NUM , _ NUM , buffer ) ; } } else { if ( current == null ) { zero Padding Number ( value , style ==  Calendar .  LONG ? _ NUM : count , max Int Count , buffer ) ; } } break ; case  PATTERN_ MONTH : if ( use Date Format Symbols ) {  String [ ] months ; if ( count >= _ NUM ) { months = format Data . get Months ( ) ; current = months [ value ] ; } else if ( count == _ NUM ) { months = format Data . get Short Months ( ) ; current = months [ value ] ; } } else { if ( count < _ NUM ) { current = null ; } else if ( force Standalone Form ) { current = calendar . get Display Name ( field , style | _ NUM , locale ) ; if ( current == null ) { current = calendar . get Display Name ( field , style , locale ) ; } } } if ( current == null ) { zero Padding Number ( value + _ NUM , count , max Int Count , buffer ) ; } break ; case  PATTERN_ MONTH_ STANDALONE : assert current == null ; if ( locale == null ) {  String [ ] months ; if ( count >= _ NUM ) { months = format Data . get Months ( ) ; current = months [ value ] ; } else if ( count == _ NUM ) { months = format Data . get Short Months ( ) ; current = months [ value ] ; } } else { if ( count >= _ NUM ) { current = calendar . get Display Name ( field , style | _ NUM , locale ) ; } } if ( current == null ) { zero Padding Number ( value + _ NUM , count , max Int Count , buffer ) ; } break ; case  PATTERN_ HOUR_ OF_ DAY1 : if ( current == null ) { if ( value == _ NUM ) { zero Padding Number ( calendar . get Maximum (  Calendar .  HOUR_ OF_ DAY ) + _ NUM , count , max Int Count , buffer ) ; } else { zero Padding Number ( value , count , max Int Count , buffer ) ; } } break ; case  PATTERN_ DAY_ OF_ WEEK : if ( use Date Format Symbols ) {  String [ ] weekdays ; if ( count >= _ NUM ) { weekdays = format Data . get Weekdays ( ) ; current = weekdays [ value ] ; } else { weekdays = format Data . get Short Weekdays ( ) ; current = weekdays [ value ] ; } } break ; case  PATTERN_ AM_ PM : if ( use Date Format Symbols ) {  String [ ] ampm = format Data . get Am Pm Strings ( ) ; current = ampm [ value ] ; } break ; case  PATTERN_ HOUR1 : if ( current == null ) { if ( value == _ NUM ) { zero Padding Number ( calendar . get Least Maximum (  Calendar .  HOUR ) + _ NUM , count , max Int Count , buffer ) ; } else { zero Padding Number ( value , count , max Int Count , buffer ) ; } } break ; case  PATTERN_ ZONE_ NAME : if ( current == null ) { if ( format Data . locale == null || format Data . is Zone Strings Set ) { int zone Index = format Data . get Zone Index ( calendar . get Time Zone ( ) . get ID ( ) ) ; if ( zone Index == - _ NUM ) { value = calendar . get (  Calendar .  ZONE_ OFFSET ) + calendar . get (  Calendar .  DST_ OFFSET ) ; buffer . append (  Zone Info File . to Custom ID ( value ) ) ; } else { int index = ( calendar . get (  Calendar .  DST_ OFFSET ) == _ NUM ) ? _ NUM : _ NUM ; if ( count < _ NUM ) { index ++ ; }  String [ ] [ ] zone Strings = format Data . get Zone Strings Wrapper ( ) ; buffer . append ( zone Strings [ zone Index ] [ index ] ) ; } } else {  Time Zone tz = calendar . get Time Zone ( ) ; boolean daylight = ( calendar . get (  Calendar .  DST_ OFFSET ) != _ NUM ) ; int tzstyle = ( count < _ NUM ?  Time Zone .  SHORT :  Time Zone .  LONG ) ; buffer . append ( tz . get Display Name ( daylight , tzstyle , format Data . locale ) ) ; } } break ; case  PATTERN_ ZONE_ VALUE : value = ( calendar . get (  Calendar .  ZONE_ OFFSET ) + calendar . get (  Calendar .  DST_ OFFSET ) ) / _ NUM ; int width = _ NUM ; if ( value >= _ NUM ) { buffer . append ( _ STR ) ; } else { width ++ ; } int num = ( value / _ NUM ) * _ NUM + ( value % _ NUM ) ;  Calendar Utils . sprintf0d ( buffer , num , width ) ; break ; case  PATTERN_ ISO_ ZONE : value = calendar . get (  Calendar .  ZONE_ OFFSET ) + calendar . get (  Calendar .  DST_ OFFSET ) ; if ( value == _ NUM ) { buffer . append ( _ STR ) ; break ; } value /= _ NUM ; if ( value >= _ NUM ) { buffer . append ( _ STR ) ; } else { buffer . append ( _ STR ) ; value = - value ; }  Calendar Utils . sprintf0d ( buffer , value / _ NUM , _ NUM ) ; if ( count == _ NUM ) { break ; } if ( count == _ NUM ) { buffer . append ( _ STR ) ; }  Calendar Utils . sprintf0d ( buffer , value % _ NUM , _ NUM ) ; break ; default : if ( current == null ) { zero Padding Number ( value , count , max Int Count , buffer ) ; } break ; } if ( current != null ) { buffer . append ( current ) ; } int field ID =  PATTERN_ INDEX_ TO_ DATE_ FORMAT_ FIELD [ pattern Char Index ] ;  Field f =  PATTERN_ INDEX_ TO_ DATE_ FORMAT_ FIELD_ ID [ pattern Char Index ] ; delegate . formatted ( field ID , f , f , begin Offset , buffer . length ( ) , buffer ) ; }
@  Suppress Warnings ( _ STR ) public boolean on Touch Event (  Motion Event event ) { try { int pointer Count = multi Touch Supported ? (  Integer ) m_get Pointer Count . invoke ( event ) : _ NUM ; if (  DEBUG )  Log . i ( _ STR , _ STR + multi Touch Supported + _ STR + m Mode + _ STR + handle Single Touch Events + _ STR + pointer Count ) ; if ( m Mode ==  MODE_ NOTHING && ! handle Single Touch Events && pointer Count == _ NUM ) return _ BOOL ; if (  DEBUG )  Log . i ( _ STR , _ STR ) ; int action = event . get Action ( ) ; int hist Len = event . get History Size ( ) / pointer Count ; for ( int hist Idx = _ NUM ; hist Idx <= hist Len ; hist Idx ++ ) { boolean processing Hist = hist Idx < hist Len ; if ( ! multi Touch Supported || pointer Count == _ NUM ) { if (  DEBUG )  Log . i ( _ STR , _ STR ) ; x Vals [ _ NUM ] = processing Hist ? event . get Historical X ( hist Idx ) : event . get X ( ) ; y Vals [ _ NUM ] = processing Hist ? event . get Historical Y ( hist Idx ) : event . get Y ( ) ; pressure Vals [ _ NUM ] = processing Hist ? event . get Historical Pressure ( hist Idx ) : event . get Pressure ( ) ; } else { if (  DEBUG )  Log . i ( _ STR , _ STR ) ; int num Pointers =  Math . min ( pointer Count ,  MAX_ TOUCH_ POINTS ) ; if (  DEBUG && pointer Count >  MAX_ TOUCH_ POINTS )  Log . i ( _ STR , _ STR ) ; for ( int ptr Idx = _ NUM ; ptr Idx < num Pointers ; ptr Idx ++ ) { int ptr Id = (  Integer ) m_get Pointer Id . invoke ( event , ptr Idx ) ; pointer Ids [ ptr Idx ] = ptr Id ; x Vals [ ptr Idx ] = (  Float ) ( processing Hist ? m_get Historical X . invoke ( event , ptr Idx , hist Idx ) : m_get X . invoke ( event , ptr Idx ) ) ; y Vals [ ptr Idx ] = (  Float ) ( processing Hist ? m_get Historical Y . invoke ( event , ptr Idx , hist Idx ) : m_get Y . invoke ( event , ptr Idx ) ) ; pressure Vals [ ptr Idx ] = (  Float ) ( processing Hist ? m_get Historical Pressure . invoke ( event , ptr Idx , hist Idx ) : m_get Pressure . invoke ( event , ptr Idx ) ) ; } } decode Touch Event ( pointer Count , x Vals , y Vals , pressure Vals , pointer Ids , processing Hist ?  Motion Event .  ACTION_ MOVE : action , processing Hist ? _ BOOL : action !=  Motion Event .  ACTION_ UP && ( action & ( ( _ NUM <<  ACTION_ POINTER_ INDEX_ SHIFT ) - _ NUM ) ) !=  ACTION_ POINTER_ UP && action !=  Motion Event .  ACTION_ CANCEL , processing Hist ? event . get Historical Event Time ( hist Idx ) : event . get Event Time ( ) ) ; } return _ BOOL ; } catch (  Exception e ) {  Log . e ( _ STR , _ STR , e ) ; return _ BOOL ; } }
public static  Bit value Of (  String bit ) throws  Number Format Exception { final int i =  Integer . parse Int ( bit ) ; if ( i != _ NUM && i != _ NUM ) { throw new  Number Format Exception ( _ STR + bit + _ STR ) ; } return ( i > _ NUM ) ?  TRUE :  FALSE ; }
public boolean next ( ) throws  EOFException { if ( limit >= file Size ) { throw new  EOFException ( _ STR ) ; } if ( mem . get Long Volatile (  Structure .  Limit ) <= limit ) { return _ BOOL ; } byte commit = mem . get Byte Volatile ( limit ) ; byte rollback = mem . get Byte Volatile ( limit +  Length .  Commit ) ; if ( rollback ==  Rollback .  Set ) { limit +=  Length .  Record Header + record Size ; timeout Counter = _ NUM ; timer Start = _ NUM ; return _ BOOL ; } if ( commit ==  Commit .  Set ) { timeout Counter = _ NUM ; timer Start = _ NUM ; return _ BOOL ; } timeout Counter ++ ; if ( timeout Counter >=  MAX_ TIMEOUT_ COUNT ) { if ( timer Start == _ NUM ) { timer Start =  System . current Time Millis ( ) ; } else { if (  System . current Time Millis ( ) - timer Start >= max Timeout ) { mem . put Byte Volatile ( limit +  Length .  Commit ,  Rollback .  Set ) ; limit +=  Length .  Record Header + record Size ; timeout Counter = _ NUM ; timer Start = _ NUM ; return _ BOOL ; } } } return _ BOOL ; }
private int compose Component ( int a , int b ) { return  Math . min ( b + b * a /  DIMMING_ FACTOR , _ NUM ) ; }
public void remove Tree Model Listener (  Tree Model Listener l ) { tree Model Listeners . remove Element ( l ) ; }
public  URIName (  String name ) throws  IOException { try { uri = new  URI ( name ) ; } catch (  URISyntax Exception use ) { throw new  IOException ( _ STR + name , use ) ; } if ( uri . get Scheme ( ) == null ) { throw new  IOException ( _ STR + name ) ; } host = uri . get Host ( ) ; if ( host != null ) { if ( host . char At ( _ NUM ) == _ STR ) {  String ip V6 Host = host . substring ( _ NUM , host . length ( ) - _ NUM ) ; try { host IP = new  IPAddress Name ( ip V6 Host ) ; } catch (  IOException ioe ) { throw new  IOException ( _ STR + _ STR + name ) ; } } else { try { host DNS = new  DNSName ( host ) ; } catch (  IOException ioe ) { try { host IP = new  IPAddress Name ( host ) ; } catch (  Exception ioe2 ) { throw new  IOException ( _ STR + _ STR + _ STR + name ) ; } } } } }
public  Projected Stream add View (  String namespace ,  String name ,  List <  Expression > parameters ) { views . add (  View . create ( namespace , name , parameters ) ) ; return this ; }
protected int read (  Speech Record recorder , byte [ ] buffer ) { int len = buffer . length ; int num Of Bytes = recorder . read ( buffer , _ NUM , len ) ; int status = get Status ( num Of Bytes , len ) ; if ( status == _ NUM ) {  System . arraycopy ( buffer , _ NUM , m Recording , m Recorded Length , num Of Bytes ) ; m Recorded Length += len ; } return status ; }
public void touch ( ) { candies Store = null ; }
public  Zone Rules to Rules (  String zone Id ) {  Objects . require Non Null ( zone Id , _ STR ) ; if ( window List . is Empty ( ) ) { throw new  Illegal State Exception ( _ STR ) ; } final  List <  Zone Offset Transition > standard Transition List = new  Array List < > ( _ NUM ) ; final  List <  Zone Offset Transition > transition List = new  Array List < > ( _ NUM ) ; final  List <  Zone Offset Transition Rule > last Transition Rule List = new  Array List < > ( _ NUM ) ; final  TZWindow first Window = window List . get ( _ NUM ) ;  Zone Offset loop Standard Offset = first Window . standard Offset ; int loop Savings = _ NUM ; if ( first Window . fixed Saving Amount Secs != null ) { loop Savings = first Window . fixed Saving Amount Secs ; } final  Zone Offset first Wall Offset =  Zone Offset . of Total Seconds ( loop Standard Offset . get Total Seconds ( ) + loop Savings ) ;  Local Date Time loop Window Start =  Local Date Time . of (  YEAR_ MIN_ VALUE , _ NUM , _ NUM , _ NUM , _ NUM ) ;  Zone Offset loop Window Offset = first Wall Offset ; for (  TZWindow window : window List ) { window . tidy ( loop Window Start . get Year ( ) ) ;  Integer effective Savings = window . fixed Saving Amount Secs ; if ( effective Savings == null ) { effective Savings = _ NUM ; for (  TZRule rule : window . rule List ) { if ( rule . to Epoch Second ( loop Standard Offset , loop Savings ) > loop Window Start . to Epoch Second ( loop Window Offset ) ) { break ; } effective Savings = rule . saving Amount Secs ; } } if ( loop Standard Offset . equals ( window . standard Offset ) == _ BOOL ) { standard Transition List . add ( new  Zone Offset Transition (  Local Date Time . of Epoch Second ( loop Window Start . to Epoch Second ( loop Window Offset ) , _ NUM , loop Standard Offset ) , loop Standard Offset , window . standard Offset ) ) ; loop Standard Offset = window . standard Offset ; }  Zone Offset effective Wall Offset =  Zone Offset . of Total Seconds ( loop Standard Offset . get Total Seconds ( ) + effective Savings ) ; if ( loop Window Offset . equals ( effective Wall Offset ) == _ BOOL ) { transition List . add ( new  Zone Offset Transition ( loop Window Start , loop Window Offset , effective Wall Offset ) ) ; } loop Savings = effective Savings ; for (  TZRule rule : window . rule List ) { if ( rule . is Transition ( loop Savings ) ) {  Zone Offset Transition trans = rule . to Transition ( loop Standard Offset , loop Savings ) ; if ( trans . to Epoch Second ( ) < loop Window Start . to Epoch Second ( loop Window Offset ) == _ BOOL && trans . to Epoch Second ( ) < window . create Date Time Epoch Second ( loop Savings ) ) { transition List . add ( trans ) ; loop Savings = rule . saving Amount Secs ; } } } for (  TZRule last Rule : window . last Rule List ) { last Transition Rule List . add ( last Rule . to Transition Rule ( loop Standard Offset , loop Savings ) ) ; loop Savings = last Rule . saving Amount Secs ; } loop Window Offset = window . create Wall Offset ( loop Savings ) ; loop Window Start =  Local Date Time . of Epoch Second ( window . create Date Time Epoch Second ( loop Savings ) , _ NUM , loop Window Offset ) ; } return new  Zone Rules ( first Window . standard Offset , first Wall Offset , standard Transition List , transition List , last Transition Rule List ) ; }
public static int hash (  Object o ) { int h = o == null ? _ NUM : o instanceof byte [ ] ?  Arrays . hash Code ( ( byte [ ] ) o ) : o . hash Code ( ) ; h += ( h << _ NUM ) ^ _ NUM ; h ^= ( h > > > _ NUM ) ; h += ( h << _ NUM ) ; h ^= ( h > > > _ NUM ) ; h += ( h << _ NUM ) + ( h << _ NUM ) ; return h ^ ( h > > > _ NUM ) ; }
public void add Parse Template (  String parse Template ) { parse Templates . add ( parse Template ) ; }
private void attach Image From Camera ( ) { try { if ( null != m Shooted Picture Path ) {  Uri uri =  Uri . from File ( new  File ( m Shooted Picture Path ) ) ; try {  Bitmap preview Bitmap =  Vector App . get Saved Picker Image Preview ( ) ;  String thumbnail Path = get Thumbnail Path ( m Shooted Picture Path ) ; int rotation Angle =  Image Utils . get Rotation Angle For Bitmap (  Vector Medias Picker Activity . this , uri ) ; if ( _ NUM != rotation Angle ) { android . graphics .  Matrix bitmap Matrix = new android . graphics .  Matrix ( ) ; bitmap Matrix . post Rotate ( _ NUM - rotation Angle ) ; preview Bitmap =  Bitmap . create Bitmap ( preview Bitmap , _ NUM , _ NUM , preview Bitmap . get Width ( ) , preview Bitmap . get Height ( ) , bitmap Matrix , _ BOOL ) ; }  File file = new  File ( thumbnail Path ) ;  File Output Stream out Stream = new  File Output Stream ( file ) ; preview Bitmap . compress (  Bitmap .  Compress Format .  JPEG , _ NUM , out Stream ) ; out Stream . flush ( ) ; out Stream . close ( ) ; } catch (  Exception e ) {  Log . e (  LOG_ TAG , _ STR ) ; }  Bundle con Data = new  Bundle ( ) ;  Intent intent = new  Intent ( ) ; intent . set Data ( uri ) ; intent . put Extras ( con Data ) ; set Result (  RESULT_ OK , intent ) ; } } catch (  Exception e ) { set Result (  RESULT_ CANCELED , null ) ; } finally {  Vector App . set Saved Camera Image Preview ( null ) ; finish ( ) ; } }
public  Object Name pre Register (  MBean Server server ,  Object Name name ) throws  Exception { set MBean Server ( server ) ; if ( name == null ) { name = new  Object Name ( server . get Default Domain ( ) + _ STR +  Service Name .  MLET ) ; } this . mlet Object Name = name ; return this . mlet Object Name ; }
static  String match String Or Throw (  Pattern p ,  To Date Parser params ,  Enum < ? > a Enum ) {  String s = params . get Input Str ( ) ;  Matcher matcher = p . matcher ( s ) ; if ( ! matcher . find ( ) ) { throw Exception ( params , format ( _ STR , a Enum . name ( ) ) ) ; } return matcher . group ( _ NUM ) ; }
static  Byte Buffer new Byte Buffer ( int capacity ) {  Byte Buffer newbb =  Byte Buffer . allocate ( capacity ) ; newbb . order (  Byte Order .  LITTLE_ ENDIAN ) ; return newbb ; }
private void validate Collection Attribute (  Collection Attribute collection ,  Set <  String > all Collections ) { if ( collection == null || all Collections == null ) { return ; } for (  Rest Method rest Method : collection . get Methods ( ) ) { if ( all Collections . contains ( rest Method . get Rest Full Method Name ( ) ) ) { aspect . warning (  Simple Location .  TOPLEVEL , _ STR + _ STR + _ STR + _ STR , collection . get Full Name ( ) , rest Method . get Rest Method Name ( ) ) ; } } }
public void put String No Null (  String s ) { ensure Capacity ( s . length ( ) * _ NUM ) ;  System . arraycopy ( s . get Bytes ( ) , _ NUM , this . byte Buffer , this . position , s . length ( ) ) ; this . position += s . length ( ) ; }
public void external Entity Decl (  String name ,  XMLResource Identifier identifier ,  Augmentations augs ) throws  XNIException { try { if ( f Decl Handler != null ) {  String public Id = identifier . get Public Id ( ) ;  String system Id = f Resolve DTDURIs ? identifier . get Expanded System Id ( ) : identifier . get Literal System Id ( ) ; f Decl Handler . external Entity Decl ( name , public Id , system Id ) ; } } catch (  SAXException e ) { throw new  XNIException ( e ) ; } }
public  Holt Winters Model Builder alpha ( double alpha ) { this . alpha = alpha ; return this ; }
public static @  Check For Null  Class Descriptor create Class Descriptor From Field Signature (  String signature ) { int start = signature . index Of ( _ STR ) ; if ( start < _ NUM ) { return null ; } int end = signature . index Of ( _ STR , start ) ; if ( end < _ NUM ) { return null ; } return create Class Descriptor ( signature . substring ( start + _ NUM , end ) ) ; }
private static  Service Ticket Response check Get Nfc Service Ticket Response (  Service Ticket Response service Ticket Response ) throws  Rpc Exception { logger . info ( _ STR , service Ticket Response ) ; switch ( service Ticket Response . get Result ( ) ) { case  OK : break ; case  SYSTEM_ ERROR : throw new  System Error Exception ( service Ticket Response . get Error ( ) ) ; case  NOT_ FOUND : throw new  Datastore Not Found Exception ( service Ticket Response . get Error ( ) ) ; default : throw new  Rpc Exception (  String . format ( _ STR , service Ticket Response . get Error ( ) ) ) ; } return service Ticket Response ; }
public void schedule (  Timer Task task , long delay ) { if ( delay < _ NUM ) throw new  Illegal Argument Exception ( _ STR ) ; sched ( task ,  System . current Time Millis ( ) + delay , _ NUM ) ; }
public void filled Ellipse ( double x , double y , double semi Major Axis , double semi Minor Axis ) { if ( semi Major Axis < _ NUM ) throw new  Illegal Argument Exception ( _ STR ) ; if ( semi Minor Axis < _ NUM ) throw new  Illegal Argument Exception ( _ STR ) ; double xs = scale X ( x ) ; double ys = scale Y ( y ) ; double ws = factor X ( _ NUM * semi Major Axis ) ; double hs = factor Y ( _ NUM * semi Minor Axis ) ; if ( ws <= _ NUM && hs <= _ NUM ) pixel ( x , y ) ; else offscreen . fill ( new  Ellipse2 D .  Double ( xs - ws / _ NUM , ys - hs / _ NUM , ws , hs ) ) ; draw ( ) ; }
@  Override public  Cursor swap Cursor (  Cursor new Cursor ) { m Alphabet Indexer . set Cursor ( new Cursor ) ; return super . swap Cursor ( new Cursor ) ; }
public void lock Flushing ( ) { flush Lock . lock ( ) ; }
public static boolean can Be Randomized (  Class clazz ) { return  Class Utils . is Primitive Or Wrapper ( clazz ) || clazz . equals (  String . class ) || clazz . equals (  IDiscord Client . class ) ; }
public static  String generate Native Guid (  String device Type ,  String serial Number ) { return  String . format ( _ STR , _device Type Map . get ( device Type ) , serial Number ) ; }
public  Writable Raster create Writable Child ( int x , int y , int width , int height , int x0 , int y0 , int band List [ ] ) { if ( x < this . min X ) { throw new  Raster Format Exception ( _ STR ) ; } if ( y < this . min Y ) { throw new  Raster Format Exception ( _ STR ) ; } if ( ( x + width < x ) || ( x + width > this . min X + this . width ) ) { throw new  Raster Format Exception ( _ STR ) ; } if ( ( y + height < y ) || ( y + height > this . min Y + this . height ) ) { throw new  Raster Format Exception ( _ STR ) ; }  Sample Model sm ; if ( band List != null ) sm = sample Model . create Subset Sample Model ( band List ) ; else sm = sample Model ; int delta X = x0 - x ; int delta Y = y0 - y ; return new  Short Banded Raster ( sm , data Buffer , new  Rectangle ( x0 , y0 , width , height ) , new  Point ( sample Model Translate X + delta X , sample Model Translate Y + delta Y ) , this ) ; }
private void sort Children ( final  JCriterium Tree Node parent Node ) { final  List <  JCriterium Tree Node > operators = new  Array List <  JCriterium Tree Node > ( ) ; final  List <  JCriterium Tree Node > conditions = new  Array List <  JCriterium Tree Node > ( ) ; final  List <  JCriterium Tree Node > minus = new  Array List <  JCriterium Tree Node > ( ) ; final  Enumeration < ? > children = parent Node . children ( ) ; while ( children . has More Elements ( ) ) { final  JCriterium Tree Node child = (  JCriterium Tree Node ) children . next Element ( ) ; final  ICriterium type = child . get Criterium ( ) ; if ( type instanceof  CCondition Criterium ) { conditions . add ( child ) ; } else { operators . add ( child ) ; } } parent Node . remove All Children ( ) ; for ( final  JCriterium Tree Node child : operators ) { parent Node . add ( child ) ; child . set Parent ( parent Node ) ; } for ( final  JCriterium Tree Node child : conditions ) { parent Node . add ( child ) ; child . set Parent ( parent Node ) ; } for ( final  JCriterium Tree Node child : minus ) { parent Node . add ( child ) ; child . set Parent ( parent Node ) ; } }
public static int poisson ( double lambda ) { int k = _ NUM ; double p = _ NUM ; double  L =  Math . exp ( - lambda ) ; do { k ++ ; p *= uniform ( ) ; } while ( p >=  L ) ; return k - _ NUM ; }
public  String build (  String input ) { input String = input ; input Index = _ NUM ; input Length = input . length ( ) ; output String = new  String Buffer ( ) ; char next Char ; while ( ( next Char = get ( ) ) != _ NUM && output String . length ( ) < max Output Length ) { if ( next Char == _ STR ) { if ( input Starts With ( _ STR ) ) {  String next Chars = peek ( _ NUM ) ; boolean have Bang Comment = _ BOOL ; if ( next Chars != null && next Chars . length ( ) == _ NUM ) { have Bang Comment = _ BOOL ; for ( int i = _ NUM ; i < next Chars . length ( ) ; i ++ ) { if ( !  Character . is Digit ( next Chars . char At ( i ) ) ) { have Bang Comment = _ BOOL ; break ; } } } if ( have Bang Comment ) { skip ( _ NUM ) ;  String contents = get To Delimiter ( _ STR ) ; if ( contents != null ) { put ( contents ) ; skip ( _ NUM ) ; } } else { put ( next Char ) ; } } else if ( input Starts With ( _ STR ) ) { if ( get To Delimiter ( _ STR ) != null ) skip ( _ NUM ) ; } else { put ( next Char ) ; } } else if ( next Char == _ STR ) { if ( input Starts With ( _ STR ) ) {  String tail = peek ( _ NUM ) ; if ( tail == null ) { break ; } else { if (  Character . is Whitespace ( tail . char At ( _ NUM ) ) ) {  String buf = get To End Of Line ( ) ; skip ( buf . length ( ) ) ; put ( _ STR ) ; } else put ( next Char ) ; } } else { put ( next Char ) ; } } else if ( next Char == _ STR ) { put ( _ STR ) ; } else { put ( next Char ) ; } } return output String . to String ( ) ; }
public boolean is Builtin Sound Available (  String sound Identifier ) { return builtin Sounds . contains Key ( sound Identifier ) ; }
public  Iterator <  String > iterate Serializers ( ) { return serializers . iterator ( ) ; }
private static void check Key (  String key ) throws  Malformed Object Name Exception { if ( key == null ) throw new  Null Pointer Exception ( _ STR ) ; final int len = key . length ( ) ; if ( len == _ NUM ) throw new  Malformed Object Name Exception ( _ STR ) ; final char [ ] k = key . to Char Array ( ) ; final int end Key = parse Key ( k , _ NUM ) ; if ( end Key < len ) throw new  Malformed Object Name Exception ( _ STR + k [ end Key ] + _ STR ) ; }
public abstract boolean is Shutdown ( ) ;
private void draw Arc (  Canvas canvas ) { if ( m Current Dash Mode . equals (  DASH_ MODE .  DOWNLOAD ) ) { mn Indeterminate Start Position += ( _ NUM - mn Progress ) * mn Start Speed ; if ( ( mn Indeterminate Start Position >  CIRCULAR_ FACTOR ) || ( mn Indeterminate Start Position < _ NUM ) ) { mn Indeterminate Start Position = _ NUM ; }  Rect curr Rect = new  Rect ( ) ; get Local Visible Rect ( curr Rect ) ; float n Ring Boundary Inner = mn Ring Radius - ( mn Ring Width / _ NUM ) - ( mn Arc Width / _ NUM ) ; m Arc Rect . set ( mn View Center - n Ring Boundary Inner , mn View Center - n Ring Boundary Inner , mn View Center + n Ring Boundary Inner , mn View Center + n Ring Boundary Inner ) ; m Paint . set Color ( m Arc Color ) ; m Paint . set Style (  Paint .  Style .  STROKE ) ; m Paint . set Stroke Width ( mn Arc Width ) ; m Paint . set Stroke Cap (  Paint .  Cap .  ROUND ) ; canvas . draw Arc ( m Arc Rect , mn Indeterminate Start Position , mn Arc Length , _ BOOL , m Paint ) ; } }
public static  String format Date Time ( java . util .  Date date ,  String format ,  String locale ,  String time Zone ) {  Simple Date Format date Format = get Date Format ( format , locale , time Zone ) ; synchronized ( date Format ) { return date Format . format ( date ) ; } }
protected  Message Digest (  String algorithm ) { this . algorithm = algorithm ; }
private void create Gui ( ) { final  JPanel top Panel = new  JPanel ( new  Border Layout ( ) ) ; final  JPanel inner Top Panel = new  JPanel ( new  Border Layout ( ) ) ; inner Top Panel . add ( m_std Edit Panel ) ; top Panel . add ( inner Top Panel ) ; final  JPanel debugger Chooser Panel = new  JPanel ( new  Border Layout ( ) ) ; debugger Chooser Panel . set Border ( new  Titled Border ( _ STR ) ) ; m_checked List = new  JChecked Listbox < > ( new  Vector <  Debugger Template > ( ) , _ BOOL ) ; update Checked List Panel ( ) ; final  JScroll Pane debugger Scroll Pane = new  JScroll Pane ( m_checked List ) ; m_checked List Panel . add ( debugger Scroll Pane ) ; debugger Chooser Panel . add ( m_checked List Panel ,  Border Layout .  CENTER ) ; debugger Chooser Panel . set Minimum Size ( new  Dimension ( _ NUM , _ NUM ) ) ; debugger Chooser Panel . set Preferred Size ( new  Dimension ( _ NUM , _ NUM ) ) ; inner Top Panel . add ( debugger Chooser Panel ,  Border Layout .  SOUTH ) ; final  JPanel button Panel = new  JPanel ( new  Grid Layout ( _ NUM , _ NUM ) ) ; button Panel . set Border ( new  Empty Border ( _ NUM , _ NUM , _ NUM , _ NUM ) ) ; button Panel . add ( new  JPanel ( ) ) ; button Panel . add ( m_save Button ) ; top Panel . add ( button Panel ,  Border Layout .  SOUTH ) ; final  JPanel bottom Panel = new  CAddress Spaces Table Panel ( m_table ) ; final  JScroll Pane scroll Pane = new  JScroll Pane ( m_table ) ; bottom Panel . set Border ( m_titled Border ) ; set Border ( new  Empty Border ( _ NUM , _ NUM , _ NUM , _ NUM ) ) ; bottom Panel . add ( scroll Pane ) ; final  JSplit Pane split Pane = new  JSplit Pane (  JSplit Pane .  VERTICAL_ SPLIT , _ BOOL , top Panel , bottom Panel ) ; split Pane . set One Touch Expandable ( _ BOOL ) ; split Pane . set Divider Location ( split Pane . get Minimum Divider Location ( ) ) ; split Pane . set Resize Weight ( _ NUM ) ; add ( split Pane ) ; }
private void copy ACls ( final  List <  Access Control Level > access Control Levels2 ) { for (  Access Control Level acl : this . access Control Levels ) { access Control Levels2 . add ( new  Access Control Level ( acl ) ) ; } }
public void put (  Byte Buffer byte Buffer , int content Length ) { if ( content Length > ( bytes . length - this . content Length ) ) { throw new  Illegal Argument Exception ( _ STR ) ; } byte Buffer . get ( bytes , this . content Length , content Length ) ; this . content Length += content Length ; }
private void handle Response (  Avs Response response ) { boolean check After = ( avs Queue . size ( ) == _ NUM ) ; if ( response != null ) { for ( int i = response . size ( ) - _ NUM ; i >= _ NUM ; i -- ) { if ( response . get ( i ) instanceof  Avs Replace All Item || response . get ( i ) instanceof  Avs Replace Enqueued Item ) { avs Queue . clear ( ) ; response . remove ( i ) ; } }  Log . i (  TAG , _ STR + response . size ( ) + _ STR ) ; avs Queue . add All ( response ) ; } if ( check After ) { check Queue ( ) ; } }
protected synchronized void request (  String stream ) { if ( stream == null || stream . is Empty ( ) ) { return ; } stream = stream . to Lower Case (  Locale .  ENGLISH ) ;  Follower Info cached Info = cached . get ( stream ) ; if ( cached Info == null || check Time Passed ( cached Info ) ) { if ( type ==  Follower .  Type .  FOLLOWER ) { api . request Followers ( stream ) ; } else if ( type ==  Follower .  Type .  SUBSCRIBER ) { api . request Subscribers ( stream ) ; } } else { if ( type ==  Follower .  Type .  FOLLOWER ) { listener . received Followers ( cached Info ) ; } else if ( type ==  Follower .  Type .  SUBSCRIBER ) { listener . received Subscribers ( cached Info ) ; } } }
boolean remove View If Hidden (  View view ) { final int index = m Callback . index Of Child ( view ) ; if ( index == - _ NUM ) { if ( m Hidden Views . remove ( view ) &&  DEBUG ) { throw new  Illegal State Exception ( _ STR ) ; } return _ BOOL ; } if ( m Bucket . get ( index ) ) { m Bucket . remove ( index ) ; m Callback . remove View At ( index ) ; if ( ! m Hidden Views . remove ( view ) &&  DEBUG ) { throw new  Illegal State Exception ( _ STR ) ; } return _ BOOL ; } return _ BOOL ; }
@  Ignore ( _ STR ) @  Test public void test Populate1kbwrites ( ) { final byte [ ] value = new byte [  ENTRY_ SIZE ] ;  Arrays . fill ( value , ( byte ) _ NUM ) ; for ( int i = _ NUM ; i <  OP_ COUNT ; i ++ ) { region . put ( new  Integer ( i ) , value ) ; } close Down ( ) ; }
public void serialize (  KXml Serializer serializer ) throws  IOException { serializer . start Tag ( ns ,  TAG ) ; serialize Attribute ( serializer ,  NAME_ ATTR , m Name ) ; serialize Attribute ( serializer ,  APP_ PACKAGE_ NAME_ ATTR , m App Package Name ) ; serialize Attribute ( serializer ,  DIGEST_ ATTR , get Digest ( ) ) ; if (  SIGNATURE_ TEST_ PKG . equals ( m Name ) ) { serializer . attribute ( ns , _ STR , _ STR ) ; } m Suite Root . serialize ( serializer ) ; serializer . end Tag ( ns ,  TAG ) ; }
public  Activity Resolve Info (  Resolve Info resolve Info ) { this . resolve Info = resolve Info ; }
public void rollback (  Throwable t ) { log . debug ( _ STR + temp File + _ STR + t ) ; try { file Content Store . delete ( temp File , node ) ; } catch (  Exception e ) { t . add Suppressed ( e ) ; } }
protected void parse Geometry String ( ) { int i = _ NUM ; byte [ ] bytes = geometry String . get Bytes ( ) ; xgrav = new  String ( bytes , _ NUM , _ NUM ) ; for ( i = _ NUM ; i < bytes . length ; i ++ ) { if ( ( bytes [ i ] == _ STR ) || ( bytes [ i ] == _ STR ) ) break ; } if ( i == bytes . length ) return ; ygrav = ( bytes [ i ] == _ STR ) ? _ STR : _ STR ; xpos =  Integer . parse Int ( new  String ( bytes , _ NUM , i - _ NUM ) ) ; ++ i ; ypos =  Integer . parse Int ( new  String ( bytes , i , bytes . length - i ) ) ; }
@  Override protected final synchronized boolean write Data (  Byte Buffer data ) {  Aion Server Packet packet = send Msg Queue . poll First ( ) ; if ( packet == null ) { return _ BOOL ; } packet . set Buf ( data ) ; packet . write ( this ) ; return _ BOOL ; }
protected boolean position (  Projection proj ) { if ( proj == null ) { logger . fine ( _ STR ) ; return _ BOOL ; } proj Width = proj . get Width ( ) ; proj Height = proj . get Height ( ) ; switch ( render Type ) { case  RENDERTYPE_ LATLON : if ( ! proj . is Plotable ( lat , lon ) ) { if (  DEBUG ) { logger . fine ( _ STR ) ; } set Need To Reposition ( _ BOOL ) ; return _ BOOL ; } point1 = (  Point ) proj . forward ( lat , lon , new  Point ( ) ) ; break ; case  RENDERTYPE_ XY : point1 = new  Point ( x , y ) ; break ; case  RENDERTYPE_ OFFSET : if ( ! proj . is Plotable ( lat , lon ) ) { if (  DEBUG ) { logger . fine ( _ STR ) ; } set Need To Reposition ( _ BOOL ) ; return _ BOOL ; } point1 = (  Point ) proj . forward ( lat , lon , new  Point ( ) ) ; point1 . x += x ; point1 . y += y ; break ; case  RENDERTYPE_ UNKNOWN : if (  DEBUG ) { logger . fine ( _ STR ) ; } if ( lat == _ NUM && lon == _ NUM ) { if ( x == _ NUM && y == _ NUM ) { if (  DEBUG ) { logger . fine ( _ STR ) ; } point1 = new  Point ( - width , - height ) ; point2 = new  Point ( _ NUM , _ NUM ) ; return _ BOOL ; } else { point1 = new  Point ( x , y ) ; } } else { if ( ! proj . is Plotable ( lat , lon ) ) { logger . fine ( _ STR ) ; return _ BOOL ; } point1 = (  Point ) proj . forward ( lat , lon , new  Point ( ) ) ; } break ; } point2 = new  Point ( _ NUM , _ NUM ) ; point2 . x = point1 . x + width ; point2 . y = point1 . y + height ; set Need To Reposition ( _ BOOL ) ; return _ BOOL ; }
public synchronized int last Index Of (  Object object , int location ) { if ( location < element Count ) { if ( object != null ) { for ( int i = location ; i >= _ NUM ; i -- ) { if ( object . equals ( element Data [ i ] ) ) { return i ; } } } else { for ( int i = location ; i >= _ NUM ; i -- ) { if ( element Data [ i ] == null ) { return i ; } } } return - _ NUM ; } throw array Index Out Of Bounds Exception ( location , element Count ) ; }
public java . lang .  String Buffer insert ( int offset , char c ) { internal . insert ( offset , c ) ; return this ; }
protected void calculate Destination (  IFile uxf ,  ICompilation Unit referencing Compilation Unit ,  Destination dest ) throws  Core Exception {  IFile uxf Dest = calculate Img Destination ( uxf , referencing Compilation Unit ) ; if ( uxf Dest != null ) { dest . img File Destination = uxf Dest ; } }
@  Override public void on Event (  Project Event event ) { if ( event . get Type ( ) ==  Project Event .  Event Type .  UPDATED || event . get Type ( ) ==  Project Event .  Event Type .  CREATED ) { update ( event ) ; } }
protected abstract boolean on Mouse Click (  Point point ) ;
private void remeasure ( int width , int height ) {  MAX_ UNEXPANDED_ ALLDAY_ HEIGHT = ( int ) (  MIN_ UNEXPANDED_ ALLDAY_ EVENT_ HEIGHT * _ NUM ) ;  MAX_ UNEXPANDED_ ALLDAY_ HEIGHT =  Math . min (  MAX_ UNEXPANDED_ ALLDAY_ HEIGHT , height / _ NUM ) ;  MAX_ UNEXPANDED_ ALLDAY_ HEIGHT =  Math . max (  MAX_ UNEXPANDED_ ALLDAY_ HEIGHT , ( int )  MIN_ UNEXPANDED_ ALLDAY_ EVENT_ HEIGHT * _ NUM ) ; m Max Unexpanded Allday Event Count = ( int ) (  MAX_ UNEXPANDED_ ALLDAY_ HEIGHT /  MIN_ UNEXPANDED_ ALLDAY_ EVENT_ HEIGHT ) ; for ( int day = _ NUM ; day < m Num Days ; day ++ ) { m Earliest Start Hour [ day ] = _ NUM ; m Has All Day Event [ day ] = _ BOOL ; } int max All Day Events = m Max Allday Events ; m Min Cell Height =  Math . max ( ( height -  DAY_ HEADER_ HEIGHT ) / _ NUM , ( int )  MIN_ EVENT_ HEIGHT ) ; if ( m Cell Height < m Min Cell Height ) { m Cell Height = m Min Cell Height ; } m First Cell =  DAY_ HEADER_ HEIGHT ; int all Day Height = _ NUM ; if ( max All Day Events > _ NUM ) { int max All All Day Height = height -  DAY_ HEADER_ HEIGHT -  MIN_ HOURS_ HEIGHT ; if ( max All Day Events == _ NUM ) { all Day Height =  SINGLE_ ALLDAY_ HEIGHT ; } else if ( max All Day Events <= m Max Unexpanded Allday Event Count ) { all Day Height = max All Day Events *  MAX_ HEIGHT_ OF_ ONE_ ALLDAY_ EVENT ; if ( all Day Height >  MAX_ UNEXPANDED_ ALLDAY_ HEIGHT ) { all Day Height =  MAX_ UNEXPANDED_ ALLDAY_ HEIGHT ; } } else { if ( m Animate Day Height != _ NUM ) { all Day Height =  Math . max ( m Animate Day Height ,  MAX_ UNEXPANDED_ ALLDAY_ HEIGHT ) ; } else { all Day Height = ( int ) ( max All Day Events *  MIN_ UNEXPANDED_ ALLDAY_ EVENT_ HEIGHT ) ; if ( ! m Show All All Day Events && all Day Height >  MAX_ UNEXPANDED_ ALLDAY_ HEIGHT ) { all Day Height = ( int ) ( m Max Unexpanded Allday Event Count *  MIN_ UNEXPANDED_ ALLDAY_ EVENT_ HEIGHT ) ; } else if ( all Day Height > max All All Day Height ) { all Day Height = max All All Day Height ; } } } m First Cell =  DAY_ HEADER_ HEIGHT + all Day Height +  ALLDAY_ TOP_ MARGIN ; } else { m Selection Allday = _ BOOL ; } m Allday Height = all Day Height ; m Grid Area Height = height - m First Cell ; int all Day Icon Width = m Expand Allday Drawable . get Intrinsic Width ( ) ; m Expand All Day Rect . left =  Math . max ( ( m Hours Width - all Day Icon Width ) / _ NUM ,  EVENT_ ALL_ DAY_ TEXT_ LEFT_ MARGIN ) ; m Expand All Day Rect . right =  Math . min ( m Expand All Day Rect . left + all Day Icon Width , m Hours Width -  EVENT_ ALL_ DAY_ TEXT_ RIGHT_ MARGIN ) ; m Expand All Day Rect . bottom = m First Cell -  EXPAND_ ALL_ DAY_ BOTTOM_ MARGIN ; m Expand All Day Rect . top = m Expand All Day Rect . bottom - m Expand Allday Drawable . get Intrinsic Height ( ) ; m Num Hours = m Grid Area Height / ( m Cell Height +  HOUR_ GAP ) ; m Event Geometry . set Hour Height ( m Cell Height ) ; final long minimum Duration Millis = ( long ) (  MIN_ EVENT_ HEIGHT *  Date Utils .  MINUTE_ IN_ MILLIS / ( m Cell Height / _ NUM ) ) ;  Event . compute Positions ( m Events , minimum Duration Millis ) ; m Max View Start Y =  HOUR_ GAP + _ NUM * ( m Cell Height +  HOUR_ GAP ) - m Grid Area Height ; if (  DEBUG ) {  Log . e (  TAG , _ STR + m View Start Y ) ;  Log . e (  TAG , _ STR + m Max View Start Y ) ; } if ( m View Start Y > m Max View Start Y ) { m View Start Y = m Max View Start Y ; compute First Hour ( ) ; } if ( m First Hour == - _ NUM ) { init First Hour ( ) ; m First Hour Offset = _ NUM ; } if ( m First Hour Offset >= m Cell Height +  HOUR_ GAP ) { m First Hour Offset = m Cell Height +  HOUR_ GAP - _ NUM ; } m View Start Y = m First Hour * ( m Cell Height +  HOUR_ GAP ) - m First Hour Offset ; final int event Area Width = m Num Days * ( m Cell Width +  DAY_ GAP ) ; if ( m Selected Event != null && m Last Popup Event ID != m Selected Event . id ) { m Popup . dismiss ( ) ; } m Popup . set Width ( event Area Width - _ NUM ) ; m Popup . set Height (  Window Manager .  Layout Params .  WRAP_ CONTENT ) ; }
private void request Fragmenting (  Igfs Entry Info file Info ) {  Igfs File Map map = file Info . file Map ( ) ; assert map != null && ! map . ranges ( ) . is Empty ( ) ;  Map <  UUID ,  Collection <  Igfs File Affinity Range > > grp Map =  U . new Hash Map ( map . ranges ( ) . size ( ) ) ; for (  Igfs File Affinity Range range : map . ranges ( ) ) {  UUID node Id = igfs Ctx . data ( ) . affinity Node ( range . affinity Key ( ) ) . id ( ) ;  Collection <  Igfs File Affinity Range > node Ranges = grp Map . get ( node Id ) ; if ( node Ranges == null ) { node Ranges = new  Linked List < > ( ) ; grp Map . put ( node Id , node Ranges ) ; } node Ranges . add All ( range . split ( igfs Ctx . data ( ) . group Block Size ( ) ) ) ; }  Collection <  UUID > node Ids = new  Identity Hash Set ( grp Map . key Set ( ) ) ; if ( log . is Debug Enabled ( ) ) log . debug ( _ STR + file Info + _ STR + node Ids + _ STR ) ;  Object old = fragmenting Files . put If Absent ( file Info . id ( ) , node Ids ) ; assert old == null ; for (  Map .  Entry <  UUID ,  Collection <  Igfs File Affinity Range > > entry : grp Map . entry Set ( ) ) {  UUID node Id = entry . get Key ( ) ;  Igfs Fragmentizer Request msg = new  Igfs Fragmentizer Request ( file Info . id ( ) , entry . get Value ( ) ) ; try { if ( log . is Debug Enabled ( ) ) log . debug ( _ STR + node Id + _ STR + file Info . id ( ) + _ STR + msg + _ STR ) ; send With Retries ( node Id , msg ) ; } catch (  Ignite Checked Exception e ) { if ( e . has Cause (  Cluster Topology Checked Exception . class ) ) { if ( log . is Debug Enabled ( ) ) log . debug ( _ STR + node Id ) ; } else  U . error ( log , _ STR + node Id + _ STR + msg + _ STR , e ) ; node Ids . remove ( node Id ) ; } } if ( node Ids . is Empty ( ) ) { if ( log . is Debug Enabled ( ) ) log . debug ( _ STR + file Info ) ; fragmenting Files . remove ( file Info . id ( ) , node Ids ) ; } }
public boolean show Previous Notification ( ) { int i = get Selected Index ( ) ; if ( i != - _ NUM && i > _ NUM ) { model . set Selected Item ( model . get Element At ( i - _ NUM ) ) ; return _ BOOL ; } return _ BOOL ; }
@  Override public void write External (  Object Output out ) throws  IOException { super . write External ( out ) ; out . write Boolean ( is Leaf ) ; out . write Int ( num Entries ) ; }
protected void add Input Node_internal (  BNode input Node ) { if ( input Nodes . contains Key ( input Node . get Id ( ) ) ) { log . warning ( _ STR + input Node . get Id ( ) + _ STR + node Id ) ; } input Nodes . put ( input Node . get Id ( ) , input Node ) ; }
public static void initialize ( final  CDatabase Configuration configuration ) throws  Couldnt Load Driver Exception ,  Couldnt Connect Exception ,  SQLException { check Driver ( configuration ) ; final  String url =  POSTGRES_ DRIVER + _ STR + configuration . get Host ( ) + _ STR +  POSTGRES_ DEFAULT_ DB ;  Connection connection = null ; try { connection =  Driver Manager . get Connection ( url , configuration . get User ( ) , configuration . get Password ( ) ) ; } catch ( final  SQLException exception ) {  CUtility Functions . log Exception ( exception ) ; throw new  Couldnt Connect Exception ( exception , exception . get Error Code ( ) , exception . get SQLState ( ) ) ; } final  String statement = _ STR + configuration . get Name ( ) + _ STR ; final  Prepared Statement prepared Statement = connection . prepare Statement ( statement ) ; try { prepared Statement . execute ( ) ; } finally { prepared Statement . close ( ) ; connection . close ( ) ; } }
public  List <  FCEndpoint > show Fcns Database (  Integer vsan Id ) throws  Network Device Controller Exception {  Map <  Integer ,  String > vsan To Wwns = get Vsan Wwns ( vsan Id ) ;  List <  FCEndpoint > connections = new  Array List <  FCEndpoint > ( ) ;  SSHPrompt [ ] prompts = {  SSHPrompt .  MDS_ POUND ,  SSHPrompt .  MDS_ GREATER_ THAN } ;  String Builder buf = new  String Builder ( ) ;  String cmd =  MDSDialog Properties . get String ( _ STR ) ; if ( vsan Id != null ) { cmd = cmd +  MDSDialog Properties . get String ( _ STR ) + vsan Id . to String ( ) + _ STR ; } else { cmd = cmd + _ STR ; }  SSHPrompt prompt = send Wait For ( cmd , default Timeout , prompts , buf ) ;  String [ ] lines = get Lines ( buf ) ;  String [ ] regex = {  MDSDialog Properties . get String ( _ STR ) ,  MDSDialog Properties . get String ( _ STR ) ,  MDSDialog Properties . get String ( _ STR ) ,  MDSDialog Properties . get String ( _ STR ) ,  MDSDialog Properties . get String ( _ STR ) ,  MDSDialog Properties . get String ( _ STR ) ,  MDSDialog Properties . get String ( _ STR ) } ;  String [ ] groups = new  String [ _ NUM ] ;  FCEndpoint conn = null ; for (  String line : lines ) { int index = match ( line , regex , groups ,  Pattern .  CASE_ INSENSITIVE ) ; switch ( index ) { case _ NUM : conn = new  FCEndpoint ( ) ; conn . set Fabric Id ( groups [ _ NUM ] ) ; conn . set Fcid ( groups [ _ NUM ] ) ;  String fabric Wwn = vsan To Wwns . get ( new  Integer ( groups [ _ NUM ] ) ) ; if ( fabric Wwn != null ) { conn . set Fabric Wwn ( fabric Wwn ) ; } connections . add ( conn ) ; break ; case _ NUM : conn . set Remote Port Name ( groups [ _ NUM ] ) ; break ; case _ NUM : conn . set Remote Node Name ( groups [ _ NUM ] ) ; break ; case _ NUM : conn . set Switch Port Name ( groups [ _ NUM ] ) ; break ; case _ NUM : conn . set Switch Interface ( groups [ _ NUM ] ) ; break ; case _ NUM : conn . set Switch Name ( groups [ _ NUM ] ) ; break ; case _ NUM : conn . set Remote Port Alias ( groups [ _ NUM ] ) ; } } return connections ; }
public static void keytool (  String cmd ) { log . info ( _ STR + cmd ) ;  Array List <  String > list = new  Array List <  String > ( ) ;  String Tokenizer st = new  String Tokenizer ( cmd , _ STR ) ;  String quote Buffer = null ; while ( st . has More Tokens ( ) ) {  String token = st . next Token ( ) ; if ( quote Buffer == null ) { if ( token . starts With ( _ STR ) ) quote Buffer = token . substring ( _ NUM ) ; else list . add ( token ) ; } else quote Buffer += _ STR + token ; if ( token . ends With ( _ STR ) ) {  String str = quote Buffer . substring ( _ NUM , quote Buffer . length ( ) - _ NUM ) ; list . add ( str ) ; quote Buffer = null ; } }  String [ ] args = new  String [ list . size ( ) ] ; list . to Array ( args ) ; try {  Key Tool . main ( args ) ; } catch (  Exception e ) { } }
private void smooth Snap To Position ( int scroll Y , int available Scroll Height ,  Alphabetical Apps List .  Fast Scroll Section Info info ) { m Rv . remove Callbacks ( m Smooth Snap Next Frame Runnable ) ; m Rv . remove Callbacks ( m Fast Scroll To Target Section Runnable ) ; track All Child Views ( ) ; if ( m Has Fast Scroll Touch Settled ) { m Current Fast Scroll Section = info . section Name ; m Target Fast Scroll Section = null ; update Tracked Views Fast Scroll Focus State ( ) ; } else { m Current Fast Scroll Section = null ; m Target Fast Scroll Section = info . section Name ; m Has Fast Scroll Touch Settled = _ BOOL ; update Tracked Views Fast Scroll Focus State ( ) ; m Rv . post Delayed ( m Fast Scroll To Target Section Runnable , m Has Fast Scroll Touch Settled At Least Once ?  REPEAT_ TOUCH_ SETTLING_ DURATION :  INITIAL_ TOUCH_ SETTLING_ DURATION ) ; } int new Scroll Y =  Math . min ( available Scroll Height , m Rv . get Padding Top ( ) + m Rv . get Top ( info . fast Scroll To Item . row Index ) ) ; int num Frames = m Fast Scroll Frames . length ; for ( int i = _ NUM ; i < num Frames ; i ++ ) { m Fast Scroll Frames [ i ] = ( new Scroll Y - scroll Y ) / num Frames ; } m Fast Scroll Frame Index = _ NUM ; m Rv . post On Animation ( m Smooth Snap Next Frame Runnable ) ; }
private void update Property To Value2 ( ) throws  Exception { properties . put (  TEST_ KEY ,  TEST_ VALUE_2 ) ; update Properties File ( ) ; }
public void unassign Services (  String universal Id ,  Set service Names ) throws  AMConsole Exception { if ( ( service Names != null ) && ! service Names . is Empty ( ) ) {  String [ ] params = new  String [ _ NUM ] ; params [ _ NUM ] = universal Id ;  String current Svc = _ STR ; try {  AMIdentity amid =  Id Utils . get Identity ( get User SSOToken ( ) , universal Id ) ; for (  Iterator iter = service Names . iterator ( ) ; iter . has Next ( ) ; ) { current Svc = (  String ) iter . next ( ) ; params [ _ NUM ] = current Svc ; log Event ( _ STR , params ) ; amid . unassign Service ( current Svc ) ; log Event ( _ STR , params ) ; } } catch (  SSOException e ) {  String [ ] params Ex = { universal Id , current Svc , get Error String ( e ) } ; log Event ( _ STR , params Ex ) ; debug . warning ( _ STR , e ) ; throw new  AMConsole Exception ( get Error String ( e ) ) ; } catch (  Id Repo Exception e ) {  String [ ] params Ex = { universal Id , current Svc , get Error String ( e ) } ; log Event ( _ STR , params Ex ) ; debug . warning ( _ STR , e ) ; throw new  AMConsole Exception ( get Error String ( e ) ) ; } } }
private static  Address  Get Float Array Elements (  JNIEnvironment env , int array JREF ,  Address is Copy Address ) { if ( trace JNI )  VM . sys Write ( _ STR ) ;  Runtime Entrypoints . check JNICount Down To GC ( ) ; try { float [ ] source Array = ( float [ ] ) env . get JNIRef ( array JREF ) ; int size = source Array . length ; if (  Memory Manager . will Never Move ( source Array ) ) {  JNIGeneric Helpers . set Bool Star ( is Copy Address , _ BOOL ) ; return  Magic . object As Address ( source Array ) ; } else {  Address copy Buffer = sys Call . sys Malloc ( size <<  LOG_ BYTES_ IN_ FLOAT ) ; if ( copy Buffer . is Zero ( ) ) { env . record Exception ( new  Out Of Memory Error ( ) ) ; return  Address . zero ( ) ; }  Memory . memcopy ( copy Buffer ,  Magic . object As Address ( source Array ) , size <<  LOG_ BYTES_ IN_ FLOAT ) ;  JNIGeneric Helpers . set Bool Star ( is Copy Address , _ BOOL ) ; return copy Buffer ; } } catch (  Throwable unexpected ) { if ( trace JNI ) unexpected . print Stack Trace (  System . err ) ; env . record Exception ( unexpected ) ; return  Address . zero ( ) ; } }
@  Override public int parse (  Date Time Parse Context context ,  Char Sequence text , int position ) { int length = text . length ( ) ; if ( position > length ) { throw new  Index Out Of Bounds Exception ( ) ; } if ( position == length ) { return ~ position ; } char next Char = text . char At ( position ) ; if ( next Char == _ STR || next Char == _ STR ) { return parse Offset Based ( context , text , position , position ,  Offset Id Printer Parser .  INSTANCE_ ID_ Z ) ; } else if ( length >= position + _ NUM ) { char next Next Char = text . char At ( position + _ NUM ) ; if ( context . char Equals ( next Char , _ STR ) && context . char Equals ( next Next Char , _ STR ) ) { if ( length >= position + _ NUM && context . char Equals ( text . char At ( position + _ NUM ) , _ STR ) ) { return parse Offset Based ( context , text , position , position + _ NUM ,  Offset Id Printer Parser .  INSTANCE_ ID_ ZERO ) ; } return parse Offset Based ( context , text , position , position + _ NUM ,  Offset Id Printer Parser .  INSTANCE_ ID_ ZERO ) ; } else if ( context . char Equals ( next Char , _ STR ) && length >= position + _ NUM && context . char Equals ( next Next Char , _ STR ) && context . char Equals ( text . char At ( position + _ NUM ) , _ STR ) ) { return parse Offset Based ( context , text , position , position + _ NUM ,  Offset Id Printer Parser .  INSTANCE_ ID_ ZERO ) ; } }  Prefix Tree tree = get Tree ( context ) ;  Parse Position ppos = new  Parse Position ( position ) ;  String parsed Zone Id = tree . match ( text , ppos ) ; if ( parsed Zone Id == null ) { if ( context . char Equals ( next Char , _ STR ) ) { context . set Parsed (  Zone Offset .  UTC ) ; return position + _ NUM ; } return ~ position ; } context . set Parsed (  Zone Id . of ( parsed Zone Id ) ) ; return ppos . get Index ( ) ; }
private void prepare Transfers ( ) throws  Lib Usb Exception { if ( m Available Transfers == null ) { m Available Transfers = new  Linked Transfer Queue < > ( ) ; for ( int x = _ NUM ; x <  TRANSFER_ BUFFER_ POOL_ SIZE ; x ++ ) {  Transfer transfer =  Lib Usb . alloc Transfer ( ) ; if ( transfer == null ) { throw new  Lib Usb Exception ( _ STR ,  Lib Usb .  ERROR_ NO_ MEM ) ; } final  Byte Buffer buffer =  Byte Buffer . allocate Direct ( m Buffer Size ) ;  Lib Usb . fill Bulk Transfer ( transfer , m Device Handle ,  USB_ ENDPOINT , buffer ,  Buffer Processor . this , _ STR ,  USB_ TIMEOUT_ US ) ; m Available Transfers . add ( transfer ) ; } } }
private void output Full Lines ( ) throws  IOException { for ( ; ; ) { int left Len = left Buf . index Of ( _ STR ) ; if ( left Len < _ NUM ) { return ; } int right Len = right Buf . index Of ( _ STR ) ; if ( right Len < _ NUM ) { return ; } if ( left Len != _ NUM ) { out . write ( left Buf . substring ( _ NUM , left Len ) ) ; } if ( right Len != _ NUM ) { write Spaces ( out , left Width - left Len ) ; out . write ( right Buf . substring ( _ NUM , right Len ) ) ; } out . write ( _ STR ) ; left Buf . delete ( _ NUM , left Len + _ NUM ) ; right Buf . delete ( _ NUM , right Len + _ NUM ) ; } }
@  Secured public void add Pay_ Simple ( long user Id ,  Big Decimal amount ,  Date created ,  Payment Type pay Type ,  String details , boolean update Cache ) throws  Concurrent Update Sql Exception ,  Exception { check Access For_ ADMIN ( ) ; amount = amount . abs ( ) ; long id = universal . next Seq For ( payments ) ;  Payment Ext payment =  Payment Ext . create System Payment ( id , user Id , amount , created , pay Type , details ) ;  Big Decimal new Val = do Payment ( user Id , payment , update Cache ) ; log . info ( _ STR + user Id + ( new Val != null ? _ STR + new Val : _ STR ) + _ STR + get Req Info Str ( ) ) ; }
private void remove All Objects ( ) { logger . debug ( _ STR ) ; texts . clear ( ) ; }
public  Builder delete Display Name ( ) { delete Fields . add ( _ STR ) ; return this ; }
private void wait For Iterators Cleared (  Ignite Cache <  String ,  Integer > cache , int secs ) throws  Interrupted Exception { for ( int i = _ NUM ; i < secs ; i ++ ) { try { cache . size ( ) ; check Iterators Cleared ( ) ; } catch (  Assertion Failed Error e ) { if ( i == _ NUM ) { for ( int j = _ NUM ; j < grid Count ( ) ; j ++ ) execute On Local Or Remote Jvm ( j , new  Print Iterator State Task ( ) ) ; throw e ; } log . info ( _ STR ) ;  Thread . sleep ( _ NUM ) ; } } }
public void add Lifecycle Listener (  Lifecycle Listener lifecycle Listener ) { if ( ! lifecycle Listeners . contains ( lifecycle Listener ) ) { lifecycle Listeners . add ( lifecycle Listener ) ; } }
boolean destroy Volume ( boolean force ) {  Na Element elem = new  Na Element ( _ STR ) ; elem . add New Child ( _ STR ,  Boolean . to String ( force ) ) ; elem . add New Child ( _ STR , name ) ; try { server . invoke Elem ( elem ) ; return _ BOOL ; } catch (  Exception e ) {  String msg = _ STR + name ; log . error ( msg , e ) ; throw new  Net App Exception ( msg , e ) ; } }
private boolean validate Cooldown Setting (  String app Id ,  Auto Scaler Policy Trigger policy Trigger ,  String trigger Id ) {  Auto Scaling Data Store state Store =  Auto Scaling Data Store Factory . get Auto Scaling Data Store ( ) ;  App Auto Scale State app State = null ; app State = state Store . get Scaling State ( app Id ) ; if ( app State == null ) { return _ BOOL ; } else if ( ( app State . get Instance Count State ( ) !=  Scaling State Manager .  SCALING_ STATE_ COMPLETED ) && ( app State . get Instance Count State ( ) !=  Scaling State Manager .  SCALING_ STATE_ FAILED ) ) { long last Start Time = app State . get Last Action Start Time ( ) ; long current Time =  System . current Time Millis ( ) ; boolean time Expired = ( current Time - last Start Time ) > this . event Timeout ; if ( time Expired ) { logger . debug ( _ STR + app Id + _ STR ) ; return _ BOOL ; } logger . debug ( _ STR + app Id + _ STR ) ; return _ BOOL ; } else { long cooldown Endtime = app State . get Last Action End Time ( ) + _ NUM * get Cooldown Secs ( policy Trigger , trigger Id ) ; if (  System . current Time Millis ( ) < cooldown Endtime ) { logger . debug ( _ STR + app Id + _ STR ) ; return _ BOOL ; } } return _ BOOL ; }
private long convert To Bytes ( int mega Bytes ) { long bytes = mega Bytes ; bytes = bytes * _ NUM * _ NUM ; return bytes ; }
private  String generate Zoneset Clone Name (  String zoneset To Clone ) { try {  Thread . sleep ( _ NUM ) ; } catch (  Interrupted Exception ex ) { _log . warn ( ex . get Localized Message ( ) ) ; }  Calendar cal =  Calendar . get Instance ( ) ;  Date Format date Format = new  Simple Date Format ( _ STR ) ;  String date String = date Format . format ( cal . get Time ( ) ) ;  String long Name =  MDSDialog Properties . get String ( _ STR ) ; if ( ! long Name . contains ( _ STR ) ) { return long Name ; } return _ STR + zoneset To Clone + _ STR + date String ; }
protected abstract void write Signature Block ( byte [ ] signature ,  Output Stream out ) throws  IOException ;
private  String Buffer build Select Query (  String schema Name ,  String table Name ,  Array List <  One Row Change .  Column Spec > keys ,  Array List <  One Row Change .  Column Val > key Values ) {  String Buffer stmt = new  String Buffer ( ) ; stmt . append ( _ STR ) ; stmt . append ( conn . get Database Object Name ( schema Name ) + _ STR + conn . get Database Object Name ( table Name ) ) ; stmt . append ( _ STR ) ; print Column Spec ( stmt , keys , key Values ,  Print Mode .  ASSIGNMENT , _ STR ) ; return stmt ; }
public static boolean is Uri Key (  String key ) { return key . ends With ( _ STR ) || key . ends With ( _ STR ) ; }
public synchronized void add OFChannel Handler And Send Role (  OFChannel Handler h ) { connected Channel Handlers . add ( h ) ; h . send Role Request ( this . role ) ; }
public boolean send ( byte [ ] bytes ) { if ( ! connected ) return _ BOOL ; try { output Stream . write ( bytes ) ; output Stream . flush ( ) ; return _ BOOL ; } catch (  IOException e ) { connected = _ BOOL ;  Log . e (  TAG , _ STR ) ; return _ BOOL ; } finally { if ( ! connected ) { close Connection ( ) ; } } }
public void add Tail Arg (  String arg ) { _tail Args . add ( arg ) ; }
private  String translate Bytes To String ( byte [ ] bytes , long format ,  Transferable locale Transferable ) throws  IOException {  Long l Format =  Long . value Of ( format ) ;  String charset = get Best Charset For Text Format ( l Format , locale Transferable ) ;  String eoln = (  String ) native EOLNs . get ( l Format ) ;  Integer terminators = (  Integer ) native Terminators . get ( l Format ) ; int count ; if ( terminators != null ) { int num Terminators = terminators . int Value ( ) ; search : for ( count = _ NUM ; count < ( bytes . length - num Terminators + _ NUM ) ; count += num Terminators ) { for ( int i = count ; i < count + num Terminators ; i ++ ) { if ( bytes [ i ] != _ NUM ) { continue search ; } } break search ; } } else { count = bytes . length ; }  String converted = new  String ( bytes , _ NUM , count , charset ) ; if ( eoln != null ) { char [ ] buf = converted . to Char Array ( ) ; char [ ] eoln_arr = eoln . to Char Array ( ) ; converted = null ; int j = _ NUM ; boolean match ; for ( int i = _ NUM ; i < buf . length ; ) { if ( i + eoln_arr . length > buf . length ) { buf [ j ++ ] = buf [ i ++ ] ; continue ; } match = _ BOOL ; for ( int k = _ NUM , l = i ; k < eoln_arr . length ; k ++ , l ++ ) { if ( eoln_arr [ k ] != buf [ l ] ) { match = _ BOOL ; break ; } } if ( match ) { buf [ j ++ ] = _ STR ; i += eoln_arr . length ; } else { buf [ j ++ ] = buf [ i ++ ] ; } } converted = new  String ( buf , _ NUM , j ) ; } return converted ; }
public  Inline URIHandler ( final  String namespace ) { this . namespace = namespace ; this . len = namespace . length ( ) ; }
private double [ ]  Calc Variable Coef (  Variogram variogram ,  Kriging Point p ,  List <  Kriging Point >  NNPoints ) { int n =  NNPoints . size ( ) ; double [ ] mat = new double [ n + _ NUM ] ; double dist = _ NUM ; for ( int i = _ NUM ; i < n ; i ++ ) { dist =  Math . sqrt (  Math . abs (  Math . pow (  NNPoints . get ( i ) . x - p . x , _ NUM ) ) +  Math . abs (  Math . pow (  NNPoints . get ( i ) . y - p . y , _ NUM ) ) ) ; mat [ i ] = get Theoretical SVValue ( dist , variogram ) ; } mat [ n ] = _ NUM ; return mat ; }
public static  Object deserialization (  String file Path ) {  Object Input Stream in = null ; try { in = new  Object Input Stream ( new  File Input Stream ( file Path ) ) ;  Object o = in . read Object ( ) ; in . close ( ) ; return o ; } catch (  File Not Found Exception e ) { throw new  Runtime Exception ( _ STR , e ) ; } catch (  Class Not Found Exception e ) { throw new  Runtime Exception ( _ STR , e ) ; } catch (  IOException e ) { throw new  Runtime Exception ( _ STR , e ) ; } finally {  IOUtils . close ( in ) ; } }
public void update End (  Logger log ) { m_instance Count ++ ; m_sample Count ++ ; double end =  System . current Time Millis ( ) ; double temp = end - m_update Start ; m_cumulative Time += temp ; boolean to Fast To Measure = _ BOOL ; if ( ( end - m_start Time ) >= m_sample Time ) { compute Update ( end ) ; if ( log != null ) { log . status Message ( m_status Message Prefix + _ STR + m_instance Count + _ STR + m_av Insts Per Sec / m_num Samples + _ STR + ( to Fast To Measure ? _ STR : _ STR ) ) ; } m_sample Count = _ NUM ; m_cumulative Time = _ NUM ; m_start Time =  System . current Time Millis ( ) ; } }
public boolean should Include ( final  Path path ) { return include Matchers . size ( ) == _ NUM || matches ( path , include Matchers ) ; }
public  Array List <  Mech Summary > generate Units ( int num ,  Unit Filter filter ) {  Array List <  Mech Summary > ret Val = new  Array List < > ( ) ; for ( int i = _ NUM ; i < num ; i ++ ) {  Mech Summary ms = generate Unit ( filter ) ; if ( ms != null ) { ret Val . add ( ms ) ; } } return ret Val ; }
static public  Automaton concatenate (  Automaton a1 ,  Automaton a2 ) { return concatenate (  Arrays . as List ( a1 , a2 ) ) ; }
public void contents Changed (  List Data Event e ) {  Object old Selection = selected Item Reminder ;  Object new Selection = data Model . get Selected Item ( ) ; if ( old Selection == null || ! old Selection . equals ( new Selection ) ) { selected Item Changed ( ) ; if ( ! selecting Item ) { fire Action Event ( ) ; } } }
protected void adjust Canopies ( double [ ] densities ) { if ( m_num Clusters Requested < _ NUM ) { assign Canopies To Canopy Centers ( ) ; m_training Data = new  Instances ( m_canopies , _ NUM ) ; return ; } if ( m_canopies . num Instances ( ) > m_num Clusters Requested ) { int [ ] sorted Indexes =  Utils . stable Sort ( densities ) ;  Instances final Canopies = new  Instances ( m_canopies , _ NUM ) ; int count = _ NUM ; for ( int i = sorted Indexes . length - _ NUM ; count < m_num Clusters Requested ; i -- ) { final Canopies . add ( m_canopies . instance ( sorted Indexes [ i ] ) ) ; count ++ ; } m_canopies = final Canopies ;  List < double [ ] [ ] > temp Canopy Centers = new  Array List < double [ ] [ ] > ( ) ;  List < double [ ] > temp T2 Dists = new  Array List < double [ ] > ( ) ;  List < double [ ] > temp Missings = new  Array List < double [ ] > ( ) ; count = _ NUM ; for ( int i = sorted Indexes . length - _ NUM ; count < final Canopies . num Instances ( ) ; i -- ) { temp Canopy Centers . add ( m_canopy Centers . get ( sorted Indexes [ i ] ) ) ; temp T2 Dists . add ( m_canopy T2 Density . get ( sorted Indexes [ i ] ) ) ; temp Missings . add ( m_canopy Num Missing For Numerics . get ( sorted Indexes [ i ] ) ) ; count ++ ; } m_canopy Centers = temp Canopy Centers ; m_canopy T2 Density = temp T2 Dists ; m_canopy Num Missing For Numerics = temp Missings ; } else if ( m_canopies . num Instances ( ) < m_num Clusters Requested && m_training Data != null && m_training Data . num Instances ( ) > _ NUM ) {  Random r = new  Random ( get Seed ( ) ) ; for ( int i = _ NUM ; i < _ NUM ; i ++ ) { r . next Int ( ) ; }  Hash Map <  Decision Table Hash Key ,  Integer > init C = new  Hash Map <  Decision Table Hash Key ,  Integer > ( ) ;  Decision Table Hash Key hk = null ; for ( int i = _ NUM ; i < m_canopies . num Instances ( ) ; i ++ ) { try { hk = new  Decision Table Hash Key ( m_canopies . instance ( i ) , m_canopies . num Attributes ( ) , _ BOOL ) ; init C . put ( hk , null ) ; } catch (  Exception e ) { e . print Stack Trace ( ) ; } } for ( int j = m_training Data . num Instances ( ) - _ NUM ; j >= _ NUM ; j -- ) { int inst Index = r . next Int ( j + _ NUM ) ; try { hk = new  Decision Table Hash Key ( m_training Data . instance ( inst Index ) , m_training Data . num Attributes ( ) , _ BOOL ) ; } catch (  Exception e ) { e . print Stack Trace ( ) ; } if ( ! init C . contains Key ( hk ) ) {  Instance new Instance = m_training Data . instance ( inst Index ) ; m_canopies . add ( new Instance ) ; double [ ] density = new double [ _ NUM ] ; density [ _ NUM ] = _ NUM ; m_canopy T2 Density . add ( density ) ; double [ ] [ ] center = new double [ new Instance . num Attributes ( ) ] [ _ NUM ] ; double [ ] num Missing Numerics = new double [ new Instance . num Attributes ( ) ] ; update Canopy Center ( new Instance , center , num Missing Numerics ) ; m_canopy Centers . add ( center ) ; m_canopy Num Missing For Numerics . add ( num Missing Numerics ) ; init C . put ( hk , null ) ; } m_training Data . swap ( j , inst Index ) ; if ( m_canopies . num Instances ( ) == m_num Clusters Requested ) { break ; } } } assign Canopies To Canopy Centers ( ) ; m_training Data = new  Instances ( m_canopies , _ NUM ) ; }
protected void create From HValues ( int [ ] h Values , int partitions ) {  Arrays . sort ( h Values ) ; this . splits = new int [ partitions ] ; int max H = _ NUM ; for ( int i = _ NUM ; i < splits . length ; i ++ ) { int quantile = ( int ) ( ( long ) ( i + _ NUM ) * h Values . length / partitions ) ; this . splits [ i ] = quantile == h Values . length ? max H : h Values [ quantile ] ; } }
private void read Object (  Object Input Stream oos ) throws  IOException ,  Class Not Found Exception { i Instant = (  Local Date Time ) oos . read Object ( ) ;  Date Time Field Type type = (  Date Time Field Type ) oos . read Object ( ) ; i Field = type . get Field ( i Instant . get Chronology ( ) ) ; }
private  String convert User Input Into AFully Qualified Path ( final  String user Input ) { if (  File Utils . denotes Absolute Path ( user Input ) ) { return user Input ; } if ( user Input . starts With (  HOME_ DIRECTORY_ SYMBOL ) ) {  Assert . not Null ( home , _ STR ) ; if ( user Input . length ( ) > _ NUM ) { return home + user Input . substring ( _ NUM ) ; } }  String full Path = get Working Directory As String ( ) + user Input ; return full Path ; }
public byte read Byte ( ) throws  IOException { return dis . read Byte ( ) ; }
protected static byte [ ] hkdf Expand ( byte [ ] ikm , byte [ ] salt , byte [ ] info , int length ) throws  Invalid Key Exception ,  No Such Algorithm Exception {  HKDFBytes Generator hkdf = new  HKDFBytes Generator ( new  SHA256 Digest ( ) ) ; hkdf . init ( new  HKDFParameters ( ikm , salt , info ) ) ; byte [ ] okm = new byte [ length ] ; hkdf . generate Bytes ( okm , _ NUM , length ) ; return okm ; }
public boolean is Emote Ignored (  Emoticon emote ) { return ignored Emotes . contains ( emote . code ) ; }
public boolean is Property Allowed (  Name name ) { return properties Allowed . contains ( name ) ; }
@  Suppress Warnings ( _ STR ) public void read File (  String file Name ) throws  JDOMException ,  IOException { if ( check File ( file Name ) ) {  Element root = root From Name ( file Name ) ;  Element roster ; if ( root == null ) { log . warn ( _ STR ) ; return ; } roster = root . get Child ( _ STR ) ; if ( roster == null ) { log . debug ( _ STR ) ; return ; }  Iterator <  Element > consist Iterator = root . get Descendants ( new  Element Filter ( _ STR ) ) ; try {  Element consist ; do { consist = consist Iterator . next ( ) ; consist From Xml ( consist ) ; } while ( consist Iterator . has Next ( ) ) ; } catch (  No Such Element Exception nde ) { log . debug ( _ STR ) ; } } else { log . info ( _ STR ) ; } }
public void test Constructor Sign Bytes Zero Null2 ( ) { byte a Bytes [ ] = { } ; int a Sign = _ NUM ; byte r Bytes [ ] = { _ NUM } ;  Big Integer a Number = new  Big Integer ( a Sign , a Bytes ) ; byte res Bytes [ ] = new byte [ r Bytes . length ] ; res Bytes = a Number . to Byte Array ( ) ; for ( int i = _ NUM ; i < res Bytes . length ; i ++ ) { assert True ( res Bytes [ i ] == r Bytes [ i ] ) ; } assert Equals ( _ STR , _ NUM , a Number . signum ( ) ) ; }
private int accept (  File Descriptor ssfd ,  File Descriptor newfd ,  Inet Socket Address [ ] isaa ) throws  IOException { return accept0 ( ssfd , newfd , isaa ) ; }
protected void transcode (  File file ,  Transcoder transcoder ) throws  IOException ,  Transcoder Exception { transcoder . add Transcoding Hint (  XMLAbstract Transcoder .  KEY_ XML_ PARSER_ VALIDATING ,  Boolean .  FALSE ) ;  SVGDocument doc = clone Document ( ) ;  Transcoder Input input = new  Transcoder Input ( doc ) ;  Output Stream out = new  Buffered Output Stream ( new  File Output Stream ( file ) ) ;  Transcoder Output output = new  Transcoder Output ( out ) ; transcoder . transcode ( input , output ) ; out . flush ( ) ; out . close ( ) ; }
@  Override public  Document new Document ( ) { return new mf . org . apache . xerces . dom .  Document Impl ( ) ; }
@  HLEFunction ( nid = _ NUM , version = _ NUM , check Inside Interrupt = _ BOOL ) public int __sce Sas Set Grain ( int sas Core , int grain ) { check Sas Handle Good ( sas Core ) ; grain Samples = grain ; return _ NUM ; }
public void handle Tbl Request Handler List Button Add Request (  Request Invocation Event event ) throws  Model Control Exception { try {  Map values = get Values ( ) ; on Before Save Profile ( values ) ; set Page Session Attribute (  PROPERTY_ ATTRIBUTE , (  Hash Map ) values ) ;  SCSAML2 SOAPBinding Request Handler List Add View Bean vb = (  SCSAML2 SOAPBinding Request Handler List Add View Bean ) get View Bean (  SCSAML2 SOAPBinding Request Handler List Add View Bean . class ) ; unlock Page Trail ( ) ; pass Pg Session Map ( vb ) ; vb . forward To ( get Request Context ( ) ) ; } catch (  AMConsole Exception e ) { set Inline Alert Message (  CCAlert .  TYPE_ ERROR , _ STR , e . get Message ( ) ) ; } }
protected static void draw Data Point ( double x , double y , double xprev , double yprev , int size , int shape ,  Graphics gx ) { draw Data Point ( x , y , size , shape , gx ) ; gx . draw Line ( ( int ) x , ( int ) y , ( int ) xprev , ( int ) yprev ) ; }
static boolean chunk Set (  Internal Distributed Member recipient ,  Set set , int  CHUNK_ SIZE_ IN_ BYTES , boolean include Values ,  Object Int Procedure proc ) throws  IOException {  Iterator it = set . iterator ( ) ; boolean keep Going = _ BOOL ; boolean sent Last Chunk = _ BOOL ; final  Heap Data Output Stream mos = new  Heap Data Output Stream (  Initial Image Operation .  CHUNK_ SIZE_ IN_ BYTES + _ NUM , recipient . get Version Object ( ) ) ; do { mos . reset ( ) ; int avg Item Size = _ NUM ; int item Count = _ NUM ; while ( ( mos . size ( ) + avg Item Size ) <  Initial Image Operation .  CHUNK_ SIZE_ IN_ BYTES && it . has Next ( ) ) {  Object key = it . next ( ) ;  Data Serializer . write Object ( key , mos ) ; item Count ++ ; avg Item Size = mos . size ( ) / item Count ; }  Data Serializer . write Object ( (  Object ) null , mos ) ; int last Msg = it . has Next ( ) ? _ NUM : _ NUM ; keep Going = proc . execute With ( mos , last Msg ) ; sent Last Chunk = last Msg == _ NUM && keep Going ; } while ( keep Going && it . has Next ( ) ) ; return sent Last Chunk ; }
private int [ ] parse Meta Data Information ( ) throws  User Error { int [ ] selected Columns = new int [ meta Data . size ( ) ] ;  Set <  String > used Column Names = new  Hash Set < > ( ) ; int column Index = _ NUM ; int used Column Index = _ NUM ; for (  Column Meta Data column : meta Data ) { if ( ! column . is Removed ( ) ) { selected Columns [ used Column Index ] = column Index ; used Column Index ++ ;  String column Name = column . get Name ( ) ; if ( ! used Column Names . contains ( column Name ) ) { used Column Names . add ( column Name ) ; } else { throw new  User Error ( null , _ STR , column Name ) ; } } column Index ++ ; } int [ ] attribute Columns =  Arrays . copy Of ( selected Columns , used Column Index ) ; return attribute Columns ; }
static  Field find Field (  Object instance ,  String name ) throws  No Such Field Exception { for (  Class < ? > clazz = instance . get Class ( ) ; clazz != null ; clazz = clazz . get Superclass ( ) ) { try {  Field field = clazz . get Declared Field ( name ) ; if ( ! field . is Accessible ( ) ) { field . set Accessible ( _ BOOL ) ; } return field ; } catch (  No Such Field Exception e ) { } } throw new  No Such Field Exception ( _ STR + name + _ STR + instance . get Class ( ) ) ; }
private void add Dump File ( ) { add Dump File ( dump File ) ; }
private static boolean date By Ordinal (  Date Time Formatter Builder bld ,  Collection <  Date Time Field Type > fields , boolean extended , boolean strict ISO ) { boolean reduced Prec = _ BOOL ; if ( fields . remove (  Date Time Field Type . year ( ) ) ) { bld . append ( year Element ( ) ) ; if ( fields . remove (  Date Time Field Type . day Of Year ( ) ) ) { append Separator ( bld , extended ) ; bld . append Day Of Year ( _ NUM ) ; } else { reduced Prec = _ BOOL ; } } else if ( fields . remove (  Date Time Field Type . day Of Year ( ) ) ) { bld . append Literal ( _ STR ) ; bld . append Day Of Year ( _ NUM ) ; } return reduced Prec ; }
private void write Attr (  String name ,  String val ) throws  IOException { write Attr ( name , val , _ BOOL ) ; }
public boolean is Page In Range ( int page Number ) { for ( int ind = _ NUM ; ind < sequence Starts . size ( ) ; ind ++ ) { if ( sequence Starts . get ( ind ) <= page Number && page Number <= sequence Ends . get ( ind ) ) return _ BOOL ; } return _ BOOL ; }
@  Suppress Warnings ( _ STR ) public static <  T extends  Dimensional Item Object >  List <  T > as Typed List (  Collection <  Dimensional Item Object > collection ) {  List <  T > list = new  Array List < > ( ) ; if ( collection != null ) { for (  Dimensional Item Object object : collection ) { list . add ( (  T ) object ) ; } } return list ; }
public  Put Index Template Request aliases (  XContent Builder source ) { return aliases ( source . bytes ( ) ) ; }
void add New Table (  String name , int tdef Page Number ,  Short type ,  String linked Db Name ,  String linked Table Name ) throws  IOException { add Table ( name ,  Integer . value Of ( tdef Page Number ) , type , linked Db Name , linked Table Name ) ; add To System Catalog ( name , tdef Page Number , type , linked Db Name , linked Table Name , _table Parent Id ) ; add To Access Control Entries ( tdef Page Number , _table Parent Id , _new Table SIDs ) ; }
public static  String hashpw ( byte [ ] password0 , final  String salt ) {  BCrypt  B ;  String real_salt ; byte passwordb [ ] = null , saltb [ ] , hashed [ ] ; char minor = ( char ) _ NUM ; int rounds , off = _ NUM ; final  String Buffer rs = new  String Buffer ( ) ; if ( salt . char At ( _ NUM ) != _ STR || salt . char At ( _ NUM ) != _ STR ) { throw new  Illegal Argument Exception ( _ STR ) ; } if ( salt . char At ( _ NUM ) == _ STR ) { off = _ NUM ; } else { minor = salt . char At ( _ NUM ) ; if ( minor != _ STR || salt . char At ( _ NUM ) != _ STR ) { throw new  Illegal Argument Exception ( _ STR ) ; } off = _ NUM ; } if ( salt . char At ( off + _ NUM ) > _ STR ) { throw new  Illegal Argument Exception ( _ STR ) ; } rounds =  Integer . parse Int ( salt . substring ( off , off + _ NUM ) ) ; real_salt = salt . substring ( off + _ NUM , off + _ NUM ) ; try { if ( minor >= ( byte ) _ STR ) { passwordb =  Arrays . copy Of ( password0 , password0 . length + _ NUM ) ; passwordb [ passwordb . length - _ NUM ] = ( byte ) _ NUM ; } else { passwordb =  Arrays . copy Of ( password0 , password0 . length ) ; } saltb = decode_base64 ( real_salt ,  BCRYPT_ SALT_ LEN ) ;  B = new  BCrypt ( ) ; hashed =  B . crypt_raw ( passwordb , saltb , rounds , bf_crypt_ciphertext . clone ( ) ) ; } finally { if ( password0 != null ) {  Arrays . fill ( password0 , ( byte ) _ STR ) ; password0 = null ; } if ( passwordb != null ) {  Arrays . fill ( passwordb , ( byte ) _ STR ) ; passwordb = null ; } } rs . append ( _ STR ) ; if ( minor >= _ STR ) { rs . append ( minor ) ; } rs . append ( _ STR ) ; if ( rounds < _ NUM ) { rs . append ( _ STR ) ; } if ( rounds > _ NUM ) { throw new  Illegal Argument Exception ( _ STR ) ; } rs . append (  Integer . to String ( rounds ) ) ; rs . append ( _ STR ) ; rs . append ( encode_base64 ( saltb , saltb . length ) ) ; rs . append ( encode_base64 ( hashed , bf_crypt_ciphertext . length * _ NUM - _ NUM ) ) ; return rs . to String ( ) ; }
public void remove Listener ( @  Not Null  Configuration Listener listener ) { if ( my Listeners != null ) { my Listeners . remove ( listener ) ; if ( my Listeners . is Empty ( ) ) { my Listeners = null ; } } }
public void do Window Open ( ) { do Connect ( ) ; }
public boolean schedule (  Runnable task ,  Class Loader loader ) { boolean is Priority = _ BOOL ; boolean is Queue = _ BOOL ; boolean is Wake = _ BOOL ; return schedule Impl ( task , loader ,  MAX_ EXPIRE , is Priority , is Queue , is Wake ) ; }
public static int hash2 ( int hash ,  Object x ,  Object y ) { return _ NUM | ( hash + _ NUM *  System . identity Hash Code ( x ) + _ NUM *  System . identity Hash Code ( y ) ) ; }
public static double [ ] parse Vector String (  String vector String ) {  String [ ] parsed String = vector String . split ( _ STR ) ; double [ ] vector = new double [ parsed String . length ] ; for ( int j = _ NUM ; j < parsed String . length ; j ++ ) { double val =  Utils . double Parsable ( parsed String [ j ] ) ; vector [ j ] =  Double . is Na N ( val ) ? _ NUM : val ; } return vector ; }
public static <  T >  Stream <  T > concat (  Stream < ? extends  T > a ,  Stream < ? extends  T > b ) {  Objects . require Non Null ( a ) ;  Objects . require Non Null ( b ) ; @  Suppress Warnings ( _ STR )  Spliterator <  T > split = new  Streams .  Concat Spliterator .  Of Ref < > ( (  Spliterator <  T > ) a . spliterator ( ) , (  Spliterator <  T > ) b . spliterator ( ) ) ;  Stream <  T > stream =  Stream Support . stream ( split , a . is Parallel ( ) || b . is Parallel ( ) ) ; return stream . on Close (  Streams . composed Close ( a , b ) ) ; }
@  Ignore @  Test public void test_ DR_ PGS_4 NODES_2 NODESDOWN_ Validate_ Receiver ( ) throws  Exception {  Integer ln Port = (  Integer ) vm0 . invoke ( null ) ;  Integer ny Port = (  Integer ) vm1 . invoke ( null ) ; create Cache In VMs ( ny Port , vm2 , vm3 ) ; create Receiver In VMs ( vm2 , vm3 ) ; create Cache In VMs ( ln Port , vm4 , vm5 , vm6 , vm7 ) ; vm4 . invoke ( null ) ; vm5 . invoke ( null ) ; vm6 . invoke ( null ) ; vm7 . invoke ( null ) ; vm4 . invoke ( null ) ; vm5 . invoke ( null ) ; vm6 . invoke ( null ) ; vm7 . invoke ( null ) ; start Sender In VMs ( _ STR , vm4 , vm5 , vm6 , vm7 ) ; vm2 . invoke ( null ) ; vm3 . invoke ( null ) ; vm4 . invoke ( null ) ; vm5 . invoke ( null ) ; vm6 . invoke ( null ) ; vm7 . invoke ( null ) ;  Thread . sleep ( _ NUM ) ; {  Async Invocation inv1 = vm7 . invoke Async ( null ) ;  Thread . sleep ( _ NUM ) ;  Async Invocation inv2 = vm4 . invoke Async ( null ) ;  Thread . sleep ( _ NUM ) ;  Async Invocation inv3 = vm6 . invoke Async ( null ) ;  Thread . sleep ( _ NUM ) ;  Async Invocation inv4 = vm5 . invoke Async ( null ) ; try { inv1 . join ( ) ; inv2 . join ( ) ; inv3 . join ( ) ; inv4 . join ( ) ; } catch (  Exception e ) {  Assert . fail ( _ STR , e ) ; } } vm6 . invoke ( null ) ; vm7 . invoke ( null ) ; vm2 . invoke ( null ) ; }
@  Override public char next ( ) { ++ doc Pos ; if ( doc Pos < segment End || segment End >= doc . get Length ( ) ) { return text . next ( ) ; } try { doc . get Text ( segment End , doc . get Length ( ) - segment End , text ) ; } catch (  Bad Location Exception e ) { throw new  Runtime Exception ( e ) ; } segment End += text . count ; return text . current ( ) ; }
private void adjust Row Heights (  JTable table ) { for ( int row = _ NUM ; row < table . get Row Count ( ) ; row ++ ) { int row Height = table . get Row Height ( ) ; for ( int column = _ NUM ; column < table . get Column Count ( ) ; column ++ ) {  Component comp = table . prepare Renderer ( table . get Cell Renderer ( row , column ) , row , column ) ; row Height =  Math . max ( row Height , comp . get Preferred Size ( ) . height ) ; } table . set Row Height ( row , row Height ) ; } }
public  List <  URI > volume URIs (  List <  URI > uris , boolean delete , boolean remediate ,  Val Ck ... checks ) {  List <  URI > remediated URIs = new  Array List <  URI > ( ) ;  List <  Volume > volumes = db Client . query Object (  Volume . class , uris ) ;  List <  Volume > remediated Volumes = volumes ( volumes , delete , remediate , checks ) ; for (  Volume volume : remediated Volumes ) { remediated URIs . add ( volume . get Id ( ) ) ; } return remediated URIs ; }
private  Format String [ ] parse (  String s ) {  Array List <  Format String > al = new  Array List < > ( ) ;  Matcher m = fs Pattern . matcher ( s ) ; for ( int i = _ NUM , len = s . length ( ) ; i < len ; ) { if ( m . find ( i ) ) { if ( m . start ( ) != i ) { check Text ( s , i , m . start ( ) ) ; al . add ( new  Fixed String ( s . substring ( i , m . start ( ) ) ) ) ; } al . add ( new  Format Specifier ( m ) ) ; i = m . end ( ) ; } else { check Text ( s , i , len ) ; al . add ( new  Fixed String ( s . substring ( i ) ) ) ; break ; } } return al . to Array ( new  Format String [ al . size ( ) ] ) ; }
private void update Index Column Buttons ( ) { index Remove Button . set Enabled ( _ BOOL ) ; index Up Button . set Enabled ( _ BOOL ) ; index Down Button . set Enabled ( _ BOOL ) ; int index = selected Columns . get Selection Index ( ) ; if ( index >= _ NUM ) { index Remove Button . set Enabled ( _ BOOL ) ; if ( index > _ NUM ) { index Up Button . set Enabled ( _ BOOL ) ; } else if ( index < selected Columns . get Item Count ( ) - _ NUM ) { index Down Button . set Enabled ( _ BOOL ) ; } } }
public  String url For POISearch (  String tag ,  Bounding Box bb , int limit , int timeout ) {  String Builder s = new  String Builder ( ) ; s . append ( m Service + _ STR ) ;  String s BB = _ STR + bb . get Lat South ( ) + _ STR + bb . get Lon West ( ) + _ STR + bb . get Lat North ( ) + _ STR + bb . get Lon East ( ) + _ STR ;  String data = _ STR + timeout + _ STR + _ STR + tag + _ STR + s BB + _ STR + _ STR + tag + _ STR + s BB + _ STR + _ STR + tag + _ STR + s BB + _ STR + _ STR + limit + _ STR ;  Log . d (  Bonus Pack Helper .  LOG_ TAG , _ STR + data ) ; s . append (  URLEncoder . encode ( data ) ) ; return s . to String ( ) ; }
public void wait For Decoding To Finish ( ) { while ( is Decoding ) { try {  Thread . sleep ( _ NUM ) ; } catch ( final  Interrupted Exception e ) {  Log Writer . write Log ( _ STR + e . get Message ( ) ) ; is Decoding = _ BOOL ; } } }
private static  String wiki To Plain Text (  String content ) { content = content . replace All ( _ STR , _ STR ) ; content = content . replace All ( _ STR , _ STR ) ; content = content . replace All ( _ STR , _ STR ) ; content = content . replace All ( _ STR , _ STR ) ; content = content . replace All ( _ STR , _ STR ) ; content = content . replace All ( _ STR , _ STR ) ; content = content . replace All ( _ STR , _ STR ) ; content = content . replace All ( _ STR , _ STR ) ; content = content . replace All ( _ STR , _ STR ) ; content = content . replace All ( _ STR , _ STR ) ; content = content . trim ( ) ; final int size = content . length ( ) ; int end Of First Paragraph = content . index Of ( _ STR , _ NUM ) ; if ( end Of First Paragraph < _ NUM ) { end Of First Paragraph = size ; } content = content . substring ( _ NUM ,  Math . min ( end Of First Paragraph , _ NUM ) ) ; return content ; }
private static int create Packed Params (  Sun Graphics2 D sg2d ,  Glyph List gl ) { return ( ( ( gl . use Positions ( ) ? _ NUM : _ NUM ) <<  OFFSET_ POSITIONS ) | ( ( gl . is Sub Pix Pos ( ) ? _ NUM : _ NUM ) <<  OFFSET_ SUBPIXPOS ) | ( ( gl . is RGBOrder ( ) ? _ NUM : _ NUM ) <<  OFFSET_ RGBORDER ) | ( ( sg2d . lcd Text Contrast & _ NUM ) <<  OFFSET_ CONTRAST ) ) ; }
public static int update (  String sql ,  Object [ ] args ) {  Connection c = null ;  Prepared Statement p = null ; try { c = get Connection ( ) ; if ( c == null ) return - _ NUM ; p = c . prepare Statement ( sql ) ; int order = _ NUM ; if ( args != null ) { for ( int i = _ NUM ; i < args . length ; i ++ ) {  Object o = args [ i ] ; set Parameter ( p , order ++ , o ) ; } } return p . execute Update ( ) ; } catch (  Exception e ) { if ( log . is Error Enabled ( ) ) log . error ( sql + to String ( args ) , e ) ; } finally { close ( p , c ) ; } return _ NUM ; }
public boolean is Lock Subject ( ) { return _ BOOL ; }
@  Override public int hash Code ( ) { int code = _ NUM ; if ( f Public Id != null ) { code += f Public Id . hash Code ( ) ; } if ( f Literal System Id != null ) { code += f Literal System Id . hash Code ( ) ; } if ( f Base System Id != null ) { code += f Base System Id . hash Code ( ) ; } if ( f Expanded System Id != null ) { code += f Expanded System Id . hash Code ( ) ; } if ( f Namespace != null ) { code += f Namespace . hash Code ( ) ; } return code ; }
public  Quick Action View add Action (  Action action ) { check Shown ( ) ; m Actions . add ( action ) ; return this ; }
protected boolean display (  File help File ) throws  Help Exception { if ( help File . exists ( ) ) { load And Write ( help File ) ; return _ BOOL ; } else {  File not Found = new  File ( help Dir ,  NOT_ FOUND ) ; if ( not Found . exists ( ) ) load And Write ( not Found ) ; else throw new  Help Exception ( _ STR ) ; return _ BOOL ; } }
public  Point2 D either ( ) { return best1 ; }
private static void remove Table (  Connection conn ,  String name ) throws  SQLException { name = name . replace ( _ STR , _ STR ) ;  Statement stat = conn . create Statement ( ) ; stat . execute ( _ STR + name ) ;  DBUtil . commit EL ( conn ) ; }
public boolean contains Category (  String category ) { return ! hidden Bug Category Set . contains ( category ) ; }
public static boolean is Volume Full Copy Source (  Volume volume ,  Db Client db Client ) { boolean is Full Copy Source = _ BOOL ;  String Set full Copy Ids = volume . get Full Copies ( ) ; if ( ( full Copy Ids != null ) && ( ! full Copy Ids . is Empty ( ) ) ) {  Iterator <  String > full Copy Ids Iter = full Copy Ids . iterator ( ) ; while ( full Copy Ids Iter . has Next ( ) ) {  URI full Copy URI =  URI . create ( full Copy Ids Iter . next ( ) ) ;  Volume full Copy Volume = db Client . query Object (  Volume . class , full Copy URI ) ; if ( ( full Copy Volume != null ) && ( ! full Copy Volume . get Inactive ( ) ) ) { is Full Copy Source = _ BOOL ; } } } return is Full Copy Source ; }
@  Override public void assert Equals (  String message ,  Object expected Obj ,  Object actual Obj ) {  Linear Regression Model expected = (  Linear Regression Model ) expected Obj ;  Linear Regression Model actual = (  Linear Regression Model ) actual Obj ; message = message + _ STR + actual . get Source ( ) + _ STR ;  Assert . assert Array Equals ( message + _ STR , expected . get Coefficients ( ) , actual . get Coefficients ( ) , _ NUM ) ;  Assert . assert Array Equals ( message + _ STR , expected . get Probabilities ( ) , actual . get Probabilities ( ) , _ NUM ) ;  Assert . assert Array Equals ( message + _ STR , expected . get Selected Attribute Names ( ) , actual . get Selected Attribute Names ( ) ) ;  Assert . assert Array Equals ( message + _ STR , expected . get Selected Attributes ( ) , actual . get Selected Attributes ( ) ) ;  Assert . assert Array Equals ( message + _ STR , expected . get Standard Errors ( ) , actual . get Standard Errors ( ) , _ NUM ) ;  Assert . assert Array Equals ( message + _ STR , expected . get Standardized Coefficients ( ) , actual . get Standardized Coefficients ( ) , _ NUM ) ;  Assert . assert Array Equals ( message + _ STR , expected . get Tolerances ( ) , actual . get Tolerances ( ) , _ NUM ) ;  Assert . assert Array Equals ( message + _ STR , expected . get TStats ( ) , actual . get TStats ( ) , _ NUM ) ; }
public void test Quorum Succeed ( ) { quorum . succeed ( ) ; quorum . fail ( ) ; assert Equals ( callback Result . get ( ) , _ NUM ) ; quorum . fail ( ) ; quorum . succeed ( ) ; assert Equals ( callback Result . get ( ) , _ NUM ) ; }
public void request After Explanation ( @  Non Null  String [ ] permissions ) {  Array List <  String > permissions To Request = new  Array List < > ( ) ; for (  String permission Name : permissions ) { if ( is Permission Declined ( permission Name ) ) { permissions To Request . add ( permission Name ) ; } else { permission Callback . on Permission Pre Granted ( permission Name ) ; } } if ( permissions To Request . is Empty ( ) ) return ; permissions = permissions To Request . to Array ( new  String [ permissions To Request . size ( ) ] ) ; context . request Permissions ( permissions ,  REQUEST_ PERMISSIONS ) ; }
static void pause Thread ( long duration ) { try {  Thread . sleep ( duration ) ; } catch (  Exception e ) { s_logger . warn ( _ STR , e ) ; } }
final public void println (  String v ) { try { _out . println ( v ) ; } catch (  IOException e ) { log . log (  Level .  FINE , e . to String ( ) , e ) ; } }
public int read ( char cbuf [ ] , int offset , int length ) throws  IOException { return sd . read ( cbuf , offset , length ) ; }
public int read ( ) throws  IOException { int val ; if ( ( val = is . read ( ) ) < _ NUM ) { return - _ NUM ; } switch ( val & _ NUM ) { case _ NUM : case _ NUM : val = ( ( val & _ NUM ) << _ NUM ) | ( is . read ( ) & _ NUM ) ; break ; case _ NUM : val = ( ( val & _ NUM ) << _ NUM ) | ( ( is . read ( ) & _ NUM ) << _ NUM ) | ( is . read ( ) & _ NUM ) ; break ; case _ NUM : throw new  Unsupported Encoding Exception ( ) ; default : break ; } return val ; }
private static boolean  Call Nonvirtual Boolean Method V (  JNIEnvironment env , int obj JREF , int class JREF , int method ID ,  Address arg Address ) throws  Exception { if ( trace JNI )  VM . sys Write ( _ STR ) ;  Runtime Entrypoints . check JNICount Down To GC ( ) ; try {  Object obj = env . get JNIRef ( obj JREF ) ;  Object return Obj =  JNIHelpers . invoke With Var Arg ( obj , method ID , arg Address ,  Type Reference .  Boolean , _ BOOL ) ; return  Reflection . unwrap Boolean ( return Obj ) ; } catch (  Throwable unexpected ) { if ( trace JNI ) unexpected . print Stack Trace (  System . err ) ; env . record Exception ( unexpected ) ; return _ BOOL ; } }
private boolean r Contains RMInstruction (  Program Block pb ,  String var Name ) { if ( pb instanceof  While Program Block ) {  While Program Block tmp = (  While Program Block ) pb ; for (  Program Block c : tmp . get Child Blocks ( ) ) if ( r Contains RMInstruction ( c , var Name ) ) return _ BOOL ; } else if ( pb instanceof  If Program Block ) {  If Program Block tmp = (  If Program Block ) pb ; for (  Program Block c : tmp . get Child Blocks If Body ( ) ) if ( r Contains RMInstruction ( c , var Name ) ) return _ BOOL ; for (  Program Block c : tmp . get Child Blocks Else Body ( ) ) if ( r Contains RMInstruction ( c , var Name ) ) return _ BOOL ; } else if ( pb instanceof  For Program Block ) {  For Program Block tmp = (  For Program Block ) pb ; for (  Program Block c : tmp . get Child Blocks ( ) ) if ( r Contains RMInstruction ( c , var Name ) ) return _ BOOL ; } else if ( pb instanceof  Function Program Block ) { } else { for (  Instruction inst : pb . get Instructions ( ) ) {  String inst Str = inst . to String ( ) ; if ( inst Str . contains ( _ STR +  Lop .  OPERAND_ DELIMITOR + var Name ) || inst Str . contains ( _ STR +  Lop .  OPERAND_ DELIMITOR + var Name ) ) { return _ BOOL ; } } } return _ BOOL ; }
public  Project Importer ( final  File root Folder ) { assert Not Null ( _ STR , root Folder ) ; assert True ( _ STR + root Folder , root Folder . exists ( ) ) ; assert True ( _ STR + root Folder , root Folder . is Directory ( ) ) ; assert True ( _ STR + root Folder , root Folder . can Read ( ) ) ; assert True ( _ STR + root Folder , null != root Folder . list Files ( ) ) ; this . root Folder = root Folder ; }
public void test Doubles ( ) throws  Exception { double [ ] values = new double [ ] {  Double .  NEGATIVE_ INFINITY , - _ NUM , - _ NUM , - _ NUM , - _ NUM , - _ NUM , - _ NUM , + _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM ,  Double .  POSITIVE_ INFINITY ,  Double .  Na N } ; long [ ] encoded = new long [ values . length ] ; for ( int i = _ NUM ; i < values . length ; i ++ ) { encoded [ i ] =  Numeric Utils . double To Sortable Long ( values [ i ] ) ; assert True ( _ STR ,  Double . compare ( values [ i ] ,  Numeric Utils . sortable Long To Double ( encoded [ i ] ) ) == _ NUM ) ; } for ( int i = _ NUM ; i < encoded . length ; i ++ ) { assert True ( _ STR , encoded [ i - _ NUM ] < encoded [ i ] ) ; } }
public static boolean is Registered (  Class < ? > clazz ) { return reg Modules . contains Key ( clazz . get Name ( ) ) ; }
private static  Pair <  String ,  String > offset ASR ( final long offset , final  ITranslation Environment environment , final  List <  Reil Instruction > instructions , final  String register Node Value1 , final  String register Node Value2 , final  String immediate Node Value ) { final  String address = environment . get Next Variable String ( ) ; final  String index = environment . get Next Variable String ( ) ; final  String tmp Var = environment . get Next Variable String ( ) ; long base Offset = offset ; if ( immediate Node Value . equals ( _ STR ) ) { final  String is Zero Condition = environment . get Next Variable String ( ) ; final  String tmp Var1 = environment . get Next Variable String ( ) ; instructions . add (  Reil Helpers . create Bsh ( base Offset ++ , dw , register Node Value2 , wd ,  String . value Of ( - _ NUM ) , dw , tmp Var1 ) ) ; instructions . add (  Reil Helpers . create Bisz ( base Offset ++ , dw , tmp Var1 , bt , is Zero Condition ) ) ; instructions . add (  Reil Helpers . create Sub ( base Offset ++ , dw ,  String . value Of ( _ NUM ) , bt , is Zero Condition , dw , index ) ) ; } else { final  String tmp Var1 = environment . get Next Variable String ( ) ; final  String tmp Var2 = environment . get Next Variable String ( ) ; final  String tmp Var3 = environment . get Next Variable String ( ) ; final  String tmp Var4 = environment . get Next Variable String ( ) ; instructions . add (  Reil Helpers . create Add ( base Offset ++ , dw , register Node Value2 , dw ,  String . value Of ( _ NUM ) , dw , tmp Var1 ) ) ; instructions . add (  Reil Helpers . create Bsh ( base Offset ++ , dw , tmp Var1 , dw , _ STR + immediate Node Value , dw , tmp Var2 ) ) ; instructions . add (  Reil Helpers . create Bsh ( base Offset ++ , dw ,  String . value Of ( _ NUM ) , dw , _ STR + immediate Node Value , dw , tmp Var3 ) ) ; instructions . add (  Reil Helpers . create Sub ( base Offset ++ , dw , tmp Var2 , dw , tmp Var3 , qw , tmp Var4 ) ) ; instructions . add (  Reil Helpers . create And ( base Offset ++ , qw , tmp Var4 , dw , d Word Bit Mask , dw , index ) ) ; } instructions . add (  Reil Helpers . create Add ( base Offset ++ , dw , register Node Value1 , dw , index , dw , tmp Var ) ) ; instructions . add (  Reil Helpers . create And ( base Offset ++ , dw , tmp Var , dw , d Word Bit Mask , dw , address ) ) ; return new  Pair <  String ,  String > ( address , register Node Value1 ) ; }
public  Class < ? > load Class (  String name ) throws  Class Not Found Exception { return  Class . for Name ( name ) ; }
public void wait For Operations ( ) { operator . wait For Operations ( ) ; }
protected boolean is All Test Components In Target (  Geometry test Geom ) {  List coords =  Component Coordinate Extracter . get Coordinates ( test Geom ) ; for (  Iterator i = coords . iterator ( ) ; i . has Next ( ) ; ) {  Coordinate p = (  Coordinate ) i . next ( ) ; int loc = target Point Locator . locate ( p ) ; if ( loc ==  Location .  EXTERIOR ) return _ BOOL ; } return _ BOOL ; }
private  Object create Inner (  Simple Object post ,  Request Context context ) throws  Response Exception { try {  String xml = complete Xform ( convert Uuids To Ids ( post ) ) ;  File file =  File . create Temp File ( _ STR , null ) ; processor . process XForm ( xml , file . get Absolute Path ( ) , _ BOOL , context . get Request ( ) ) ; } catch (  IOException e ) { throw new  Generic Rest Exception ( _ STR , e ) ; } catch (  Response Exception e ) { throw e ; } catch (  Exception e ) { throw new  Conversion Exception ( _ STR , e ) ; }  Encounter encounter = guess Encounter From Xform Submission ( post ) ; if ( encounter == null ) { return post ; }  Simple Object return Json = new  Simple Object ( ) ;  Encounter Resource . populate Json Properties ( encounter , return Json ) ; return return Json ; }
public  Endpoint (  URI endpoint Url ,  Security Mode ... modes ) { if ( modes == null || endpoint Url == null ) throw new  Illegal Argument Exception ( _ STR ) ; for (  Security Mode m : modes ) { if ( m == null ) throw new  Illegal Argument Exception ( _ STR ) ; hash = _ NUM * hash + m . hash Code ( ) ; } this . endpoint Url = endpoint Url . to String ( ) ; this . modes = modes ; this . endpoint Configuration =  Endpoint Configuration . defaults ( ) ; hash = _ NUM * hash + endpoint Url . hash Code ( ) ; }
protected  Value parse Value ( ) throws  IOException ,  RDFParse Exception ,  RDFHandler Exception { int c = peek Code Point ( ) ; if ( c == _ STR ) { return parse URI ( ) ; } else if ( c == _ STR ||  Turtle Util . is Prefix Start Char ( c ) ) { return parse QName Or Boolean ( ) ; } else if ( c == _ STR ) { return parse Node ID ( ) ; } else if ( c == _ STR || c == _ STR ) { return parse Quoted Literal ( ) ; } else if (  ASCIIUtil . is Number ( c ) || c == _ STR || c == _ STR || c == _ STR ) { return parse Number ( ) ; } else if ( c == - _ NUM ) { throw EOFException ( ) ; return null ; } else { report Fatal Error ( _ STR + new  String (  Character . to Chars ( c ) ) + _ STR ) ; return null ; } }
public  Time Series Collection ( ) { this ( null ,  Time Zone . get Default ( ) ) ; }
public static <  E >  List <  E > of (  E e1 ,  E e2 ,  E e3 ) {  List <  E > list = new  Array List < > ( ) ; list . add ( e1 ) ; list . add ( e2 ) ; list . add ( e3 ) ; return list ; }
@  Override public void add Attribute (  String name , float value ) {  String str =  Float . to String ( value ) ; if ( str . ends With ( _ STR ) ) str = str . substring ( _ NUM , str . length ( ) - _ NUM ) ; current . set Attribute ( name , str ) ; }
@  Request Mapping ( value = _ STR , method =  Request Method .  POST ) @  Response Body public  Json Response create Directory ( @  Path Variable final  String container Id , @  Path Variable final  String application Name , @  Request Param ( _ STR )  String path ) throws  Service Exception ,  Check Exception ,  IOException { if ( logger . is Debug Enabled ( ) ) { logger . debug ( _ STR + container Id ) ; logger . debug ( _ STR + application Name ) ; logger . debug ( _ STR + path ) ; } file Service . create Directory ( application Name , container Id , path ) ; return new  Http Ok ( ) ; }
public void fill_ellipse_arr (  Pla Ellipse [ ] p_ellipse_arr ,  Graphics p_g ,  Color p_color , double p_translucency_factor ) { if ( p_color == null ) return ; if ( p_ellipse_arr . length <= _ NUM ) return ;  General Path draw_path = new  General Path (  General Path .  WIND_ EVEN_ ODD ) ; for (  Pla Ellipse curr_ellipse : p_ellipse_arr ) {  Point2 D center = coordinate_transform . board_to_screen ( curr_ellipse . center ) ; double bigger_radius = coordinate_transform . board_to_screen ( curr_ellipse . bigger_radius ) ; if ( ! point_near_rectangle ( center . get X ( ) , center . get Y ( ) , (  Rectangle ) p_g . get Clip ( ) , bigger_radius ) ) { continue ; } double smaller_radius = coordinate_transform . board_to_screen ( curr_ellipse . smaller_radius ) ;  Ellipse2 D draw_ellipse = new  Ellipse2 D .  Double ( center . get X ( ) - bigger_radius , center . get Y ( ) - smaller_radius , _ NUM * bigger_radius , _ NUM * smaller_radius ) ; double rotation = coordinate_transform . board_to_screen_angle ( curr_ellipse . rotation ) ;  Affine Transform affine_transform = new  Affine Transform ( ) ; affine_transform . rotate ( rotation , center . get X ( ) , center . get Y ( ) ) ;  Shape rotated_ellipse = affine_transform . create Transformed Shape ( draw_ellipse ) ; draw_path . append ( rotated_ellipse , _ BOOL ) ; }  Graphics2 D g2 = (  Graphics2 D ) p_g ; g2 . set Color ( p_color ) ; set_translucency ( g2 , p_translucency_factor ) ; g2 . set Rendering Hint (  Rendering Hints .  KEY_ ANTIALIASING ,  Rendering Hints .  VALUE_ ANTIALIAS_ ON ) ; g2 . fill ( draw_path ) ; }
@  Override public void zoom Domain Axes ( double factor ,  Plot Rendering Info state ,  Point2 D source ) { }
private void refresh Challenge Counts ( ) { m Due Challenge Counts = m Due Challenge Logic . get Due Challenge Counts ( m Categories ) ; }
public  Identity ( final int dim ) { this ( dim ,  Enum Set . none Of (  Address .  Flags . class ) ) ; }
private  Image Data awt To Swt ( final  Buffered Image buffered Image , final int width , final int height ) { final int [ ] awt Pixels = new int [ width * height ] ; final  Image Data swt Image Data = new  Image Data ( width , height , _ NUM ,  PALETTE_ DATA ) ; swt Image Data . transparent Pixel =  TRANSPARENT_ COLOR ; final int step = swt Image Data . depth / _ NUM ; final byte [ ] data = swt Image Data . data ; buffered Image . get RGB ( _ NUM , _ NUM , width , height , awt Pixels , _ NUM , width ) ; for ( int i = _ NUM ; i < height ; i ++ ) { int idx = ( _ NUM + i ) * swt Image Data . bytes Per Line + _ NUM * step ; for ( int j = _ NUM ; j < width ; j ++ ) { final int rgb = awt Pixels [ j + i * width ] ; for ( int k = swt Image Data . depth - _ NUM ; k >= _ NUM ; k -= _ NUM ) { data [ idx ++ ] = ( byte ) ( rgb > > k & _ NUM ) ; } } } return swt Image Data ; }
public static boolean is Unlimited Strength Policy Available ( ) { try { return  Cipher . get Max Allowed Key Length ( _ STR ) >= _ NUM ; } catch ( final  No Such Algorithm Exception e ) { e . print Stack Trace ( ) ; } return _ BOOL ; }
private void fill Stack Trace (  String Buffer buffer ,  Stack Trace Element [ ] elements ) { for ( int index = _ NUM ; index < elements . length ; index ++ ) { buffer . append ( elements [ index ] ) ; buffer . append ( _ STR ) ; } }
public static boolean is File Type Supported ( int file Type ) {  List providers = get Midi File Writers ( ) ; for ( int i = _ NUM ; i < providers . size ( ) ; i ++ ) {  Midi File Writer writer = (  Midi File Writer ) providers . get ( i ) ; if ( writer . is File Type Supported ( file Type ) ) { return _ BOOL ; } } return _ BOOL ; }
public void modify (  SSOToken token ,  String obj Name ,  Modification Item [ ] mods ) throws  SMSException ,  SSOException { if ( ( obj Name == null ) || ( obj Name . length ( ) == _ NUM ) || ( mods == null ) || ( mods . length == _ NUM ) ) { throw new  Illegal Argument Exception ( _ STR + _ STR ) ; }  String obj Key = obj Name . to Lower Case ( ) ;  String filepath = null ; m RWLock . read Request ( ) ; try { filepath = m Name Map . get Property ( obj Key ) ; if ( filepath == null ) {  String errmsg = _ STR + obj Name + _ STR ; m Debug . error ( errmsg ) ; throw new  Service Not Found Exception ( errmsg ) ; } } finally { m RWLock . read Done ( ) ; } m RWLock . write Request ( ) ; try { filepath = m Name Map . get Property ( obj Key ) ; if ( filepath == null ) {  String errmsg = _ STR + obj Name + _ STR ; m Debug . error ( errmsg ) ; throw new  Service Not Found Exception ( errmsg ) ; }  File filehandle = new  File ( filepath ) ; if ( ! filehandle . is File ( ) ) {  String errmsg = _ STR + obj Name + _ STR ; m Debug . error ( errmsg ) ; throw new  Service Not Found Exception ( errmsg ) ; }  Properties props = load Properties ( filehandle , obj Name ) ; boolean has Sun Xml Key Value = ( props . get Property (  SMSEntry .  ATTR_ XML_ KEYVAL ) == null ) ? _ BOOL : _ BOOL ; for ( int i = _ NUM ; i < mods . length ; i ++ ) { modify Values ( obj Name , mods [ i ] , props ) ; } save Properties ( props , filehandle , obj Name ) ; if ( ! has Sun Xml Key Value ) { has Sun Xml Key Value = ( props . get Property (  SMSEntry .  ATTR_ XML_ KEYVAL ) == null ) ? _ BOOL : _ BOOL ; } if ( has Sun Xml Key Value ) { delete Sun Xml Key Val Files ( filehandle . get Parent File ( ) ) ;  Set xml Key Vals = to Val Set (  SMSEntry .  ATTR_ XML_ KEYVAL , props . get Property (  SMSEntry .  ATTR_ XML_ KEYVAL ) ) ; create Sun Xml Key Val Files ( filehandle . get Parent File ( ) , xml Key Vals ) ; } } finally { m RWLock . write Done ( ) ; } }
private  AMSetup DSConfig ( ) {  Map map =  Services Default Values . get Default Values ( ) ; ds Manager = (  String ) map . get (  Setup Constants .  CONFIG_ VAR_ DS_ MGR_ DN ) ; suffix = (  String ) map . get (  Setup Constants .  CONFIG_ VAR_ ROOT_ SUFFIX ) ; ds Host Name = (  String ) map . get (  Setup Constants .  CONFIG_ VAR_ DIRECTORY_ SERVER_ HOST ) ; ds Port = (  String ) map . get (  Setup Constants .  CONFIG_ VAR_ DIRECTORY_ SERVER_ PORT ) ; ds Admin Pwd = (  String ) map . get (  Setup Constants .  CONFIG_ VAR_ DS_ MGR_ PWD ) ; basedir = (  String ) map . get (  Setup Constants .  CONFIG_ VAR_ BASE_ DIR ) ; deployuri = (  String ) map . get (  Setup Constants .  CONFIG_ VAR_ SERVER_ URI ) ; }
private void make Items ( int finger Position ,  List <  View > view List ) { if ( finger Position >= view List . size ( ) ) { return ; } for ( int i = _ NUM ; i < view List . size ( ) ; i ++ ) { int translation Y =  Math . min (  Math . max (  Math . abs ( finger Position - i ) * interval Height , _ NUM ) , max Translation Height ) ; update Item Height Animator ( view List . get ( i ) , translation Y ) ; } }
private boolean path Is Windows (  String path ) { if ( path != null && path . length ( ) > _ NUM ) { return (  Character . is Letter ( path . char At ( _ NUM ) ) && path . char At ( _ NUM ) == _ STR ) || ( path . starts With ( _ STR ) || path . starts With ( _ STR ) ) ; } return _ BOOL ; }
public boolean is Segment Balanced ( ) { if ( m_lines . size ( ) == _ NUM || m_doc . is Multi Currency ( ) ) return _ BOOL ;  MAcct Schema Element [ ] elements = m_acct Schema . get Acct Schema Elements ( ) ; for ( int i = _ NUM ; i < elements . length ; i ++ ) {  MAcct Schema Element ase = elements [ i ] ; if ( ase . is Balanced ( ) && ! is Segment Balanced ( ase . get Element Type ( ) ) ) return _ BOOL ; } return _ BOOL ; }
Attributes parse Attributes ( ) throws  Jasper Exception {  Attributes Impl attrs = new  Attributes Impl ( ) ; reader . skip Spaces ( ) ; while ( parse Attribute ( attrs ) ) reader . skip Spaces ( ) ; return attrs ; }
public static byte [ ] read Binary File (  File source File ) { byte [ ] result = null ; try {  Buffered Input Stream input ; input = new  Buffered Input Stream ( new  File Input Stream ( source File ) ) ; int num = input . available ( ) ; result = new byte [ num ] ; input . read ( result , _ NUM , num ) ; input . close ( ) ; } catch (  Exception e ) { e . print Stack Trace ( ) ; result = null ; } return result ; }
@  Suppress Warnings ( _ STR ) public void test_stream API ( ) { final  List <  IBinding Set > expected Solutions = new  Array List <  IBinding Set > ( ) ; { final  IBinding Set expected = new  List Binding Set ( ) ; expected . set (  Var . var ( _ STR ) , new  Constant <  IV > ( term Id ) ) ; expected Solutions . add ( expected ) ; } { final  IBinding Set expected = new  List Binding Set ( ) ; expected . set (  Var . var ( _ STR ) , new  Constant <  IV > ( term Id ) ) ; expected . set (  Var . var ( _ STR ) , new  Constant <  IV > ( blob IV ) ) ; expected Solutions . add ( expected ) ; } do Encode Decode Test ( expected Solutions ) ; }
public void add Term (  Split Condition condition ) { terms . add ( condition ) ; }
public void remove Index Interval ( int index0 , int index1 ) { int rm Min Index =  Math . min ( index0 , index1 ) ; int rm Max Index =  Math . max ( index0 , index1 ) ; int gap Length = ( rm Max Index - rm Min Index ) + _ NUM ; for ( int i = rm Min Index ; i <= max Index ; i ++ ) { set State ( i , value . get ( i + gap Length ) ) ; } int lead Index = this . lead Index ; if ( lead Index == _ NUM && rm Min Index == _ NUM ) { } else if ( lead Index > rm Max Index ) { lead Index = this . lead Index - gap Length ; } else if ( lead Index >= rm Min Index ) { lead Index = rm Min Index - _ NUM ; } int anchor Index = this . anchor Index ; if ( anchor Index == _ NUM && rm Min Index == _ NUM ) { } else if ( anchor Index > rm Max Index ) { anchor Index = this . anchor Index - gap Length ; } else if ( anchor Index >= rm Min Index ) { anchor Index = rm Min Index - _ NUM ; } if ( lead Index != this . lead Index || anchor Index != this . anchor Index ) { update Lead Anchor Indices ( anchor Index , lead Index ) ; } fire Value Changed ( ) ; }
public void rebuild Event List ( boolean reset Selected ) { if ( logger . is Loggable (  Level .  FINE ) ) { logger . fine ( _ STR ) ; } all Events = null ; active Events = null ; hide Details ( ) ; init Interface ( get Active Events ( ) , reset Selected ) ; highlight Current Event ( current Time ) ; fire Property Change (  Active Events Property , null , get Active Events ( ) ) ; }
public  Disk Store Factory create Disk Store Factory ( ) { return new  Disk Store Factory Impl ( this ) ; }
public static boolean delete Directory Subdirectories (  String root Directory ) { if ( ( root Directory == null ) ) { return _ BOOL ; } boolean did Successfully Delete All Directories = _ BOOL ; try {  List <  File > files = get List Of Files In ADirectory ( root Directory ) ; for (  File file : files ) { if ( file . is Directory ( ) ) { boolean delete Success = delete Directory And Contents ( file ) ; if ( ! delete Success ) { logger . debug ( _ STR + file . get Absolute Path ( ) ) ; did Successfully Delete All Directories = _ BOOL ; } } } } catch (  Exception e ) { logger . debug ( e . to String ( ) +  System . line Separator ( ) +  Stack Trace . get String From Stack Trace ( e ) ) ; return _ BOOL ; } return did Successfully Delete All Directories ; }
public void put ( byte [ ] buffer , int offset , int count ) { if ( count > ( bytes . length - this . content Length ) ) { throw new  Illegal Argument Exception ( _ STR ) ; }  System . arraycopy ( buffer , offset , bytes , this . content Length , count ) ; this . content Length += count ; }
private void mark Reserved ( int rop Reg , int category ) { reserved Rop Regs . set ( rop Reg , rop Reg + category , _ BOOL ) ; }
public static void register Default Resolvers ( ) { synchronized ( resolver List ) { resolver List . add ( new  Resource Resolver ( new  Resolver Fragment ( ) ) ) ; resolver List . add ( new  Resource Resolver ( new  Resolver Local Filesystem ( ) ) ) ; resolver List . add ( new  Resource Resolver ( new  Resolver XPointer ( ) ) ) ; resolver List . add ( new  Resource Resolver ( new  Resolver Direct HTTP ( ) ) ) ; } }
private boolean process Authentication Response ( final  Http Method method ) {  LOG . trace ( _ STR + _ STR ) ; try { switch ( method . get Status Code ( ) ) { case  Http Status .  SC_ UNAUTHORIZED : return process WWWAuth Challenge ( method ) ; case  Http Status .  SC_ PROXY_ AUTHENTICATION_ REQUIRED : return process Proxy Auth Challenge ( method ) ; default : return _ BOOL ; } } catch (  Exception e ) { if (  LOG . is Error Enabled ( ) ) {  LOG . error ( e . get Message ( ) , e ) ; } return _ BOOL ; } }
private void release (  Byte Array byte Array ) { synchronized ( sync Root ) { if ( available Byte Arrays . size ( ) >= max Available Arrays Count ) { return ; } if ( ! available Byte Arrays . contains ( byte Array ) ) { available Byte Arrays . add ( byte Array ) ; } } }
public  Pipeline ( ) { }
@  Override public void draw Range Marker (  Graphics2 D g2 ,  Category Plot plot ,  Value Axis axis ,  Marker marker ,  Rectangle2 D data Area ) { if ( marker instanceof  Value Marker ) {  Value Marker vm = (  Value Marker ) marker ; double value = vm . get Value ( ) ;  Range range = axis . get Range ( ) ; if ( ! range . contains ( value ) ) { return ; } final  Composite saved Composite = g2 . get Composite ( ) ; g2 . set Composite (  Alpha Composite . get Instance (  Alpha Composite .  SRC_ OVER , marker . get Alpha ( ) ) ) ;  Plot Orientation orientation = plot . get Orientation ( ) ; double v = axis . value To Java2 D ( value , data Area , plot . get Range Axis Edge ( ) ) ;  Line2 D line = null ; if ( orientation ==  Plot Orientation .  HORIZONTAL ) { line = new  Line2 D .  Double ( v , data Area . get Min Y ( ) , v , data Area . get Max Y ( ) ) ; } else if ( orientation ==  Plot Orientation .  VERTICAL ) { line = new  Line2 D .  Double ( data Area . get Min X ( ) , v , data Area . get Max X ( ) , v ) ; } else { throw new  Illegal State Exception ( ) ; } g2 . set Paint ( marker . get Paint ( ) ) ; g2 . set Stroke ( marker . get Stroke ( ) ) ; g2 . draw ( line ) ;  String label = marker . get Label ( ) ;  Rectangle Anchor anchor = marker . get Label Anchor ( ) ; if ( label != null ) {  Font label Font = marker . get Label Font ( ) ; g2 . set Font ( label Font ) ;  Point2 D coordinates = calculate Range Marker Text Anchor Point ( g2 , orientation , data Area , line . get Bounds2 D ( ) , marker . get Label Offset ( ) ,  Length Adjustment Type .  EXPAND , anchor ) ;  Rectangle2 D rect =  Text Utils . calc Aligned String Bounds ( label , g2 , ( float ) coordinates . get X ( ) , ( float ) coordinates . get Y ( ) , marker . get Label Text Anchor ( ) ) ; g2 . set Paint ( marker . get Label Background Color ( ) ) ; g2 . fill ( rect ) ; g2 . set Paint ( marker . get Label Paint ( ) ) ;  Text Utils . draw Aligned String ( label , g2 , ( float ) coordinates . get X ( ) , ( float ) coordinates . get Y ( ) , marker . get Label Text Anchor ( ) ) ; } g2 . set Composite ( saved Composite ) ; } else if ( marker instanceof  Interval Marker ) {  Interval Marker im = (  Interval Marker ) marker ; double start = im . get Start Value ( ) ; double end = im . get End Value ( ) ;  Range range = axis . get Range ( ) ; if ( ! ( range . intersects ( start , end ) ) ) { return ; } final  Composite saved Composite = g2 . get Composite ( ) ; g2 . set Composite (  Alpha Composite . get Instance (  Alpha Composite .  SRC_ OVER , marker . get Alpha ( ) ) ) ; double start2d = axis . value To Java2 D ( start , data Area , plot . get Range Axis Edge ( ) ) ; double end2d = axis . value To Java2 D ( end , data Area , plot . get Range Axis Edge ( ) ) ; double low =  Math . min ( start2d , end2d ) ; double high =  Math . max ( start2d , end2d ) ;  Plot Orientation orientation = plot . get Orientation ( ) ;  Rectangle2 D rect = null ; if ( orientation ==  Plot Orientation .  HORIZONTAL ) { low =  Math . max ( low , data Area . get Min X ( ) ) ; high =  Math . min ( high , data Area . get Max X ( ) ) ; rect = new  Rectangle2 D .  Double ( low , data Area . get Min Y ( ) , high - low , data Area . get Height ( ) ) ; } else if ( orientation ==  Plot Orientation .  VERTICAL ) { low =  Math . max ( low , data Area . get Min Y ( ) ) ; high =  Math . min ( high , data Area . get Max Y ( ) ) ; rect = new  Rectangle2 D .  Double ( data Area . get Min X ( ) , low , data Area . get Width ( ) , high - low ) ; }  Paint p = marker . get Paint ( ) ; if ( p instanceof  Gradient Paint ) {  Gradient Paint gp = (  Gradient Paint ) p ;  Gradient Paint Transformer t = im . get Gradient Paint Transformer ( ) ; if ( t != null ) { gp = t . transform ( gp , rect ) ; } g2 . set Paint ( gp ) ; } else { g2 . set Paint ( p ) ; } g2 . fill ( rect ) ; if ( im . get Outline Paint ( ) != null && im . get Outline Stroke ( ) != null ) { if ( orientation ==  Plot Orientation .  VERTICAL ) {  Line2 D line = new  Line2 D .  Double ( ) ; double x0 = data Area . get Min X ( ) ; double x1 = data Area . get Max X ( ) ; g2 . set Paint ( im . get Outline Paint ( ) ) ; g2 . set Stroke ( im . get Outline Stroke ( ) ) ; if ( range . contains ( start ) ) { line . set Line ( x0 , start2d , x1 , start2d ) ; g2 . draw ( line ) ; } if ( range . contains ( end ) ) { line . set Line ( x0 , end2d , x1 , end2d ) ; g2 . draw ( line ) ; } } else {  Line2 D line = new  Line2 D .  Double ( ) ; double y0 = data Area . get Min Y ( ) ; double y1 = data Area . get Max Y ( ) ; g2 . set Paint ( im . get Outline Paint ( ) ) ; g2 . set Stroke ( im . get Outline Stroke ( ) ) ; if ( range . contains ( start ) ) { line . set Line ( start2d , y0 , start2d , y1 ) ; g2 . draw ( line ) ; } if ( range . contains ( end ) ) { line . set Line ( end2d , y0 , end2d , y1 ) ; g2 . draw ( line ) ; } } }  String label = marker . get Label ( ) ;  Rectangle Anchor anchor = marker . get Label Anchor ( ) ; if ( label != null ) {  Font label Font = marker . get Label Font ( ) ; g2 . set Font ( label Font ) ;  Point2 D coords = calculate Range Marker Text Anchor Point ( g2 , orientation , data Area , rect , marker . get Label Offset ( ) , marker . get Label Offset Type ( ) , anchor ) ;  Rectangle2 D r =  Text Utils . calc Aligned String Bounds ( label , g2 , ( float ) coords . get X ( ) , ( float ) coords . get Y ( ) , marker . get Label Text Anchor ( ) ) ; g2 . set Paint ( marker . get Label Background Color ( ) ) ; g2 . fill ( r ) ; g2 . set Paint ( marker . get Label Paint ( ) ) ;  Text Utilities . draw Aligned String ( label , g2 , ( float ) coords . get X ( ) , ( float ) coords . get Y ( ) , marker . get Label Text Anchor ( ) ) ; } g2 . set Composite ( saved Composite ) ; } }
private void init ( ) { acceptable Methods = new  Array List < > ( ) ; acceptable Methods . add ( new  No Authentication Required Method ( ) ) ; acceptable Methods . add ( new  Gss Api Method ( ) ) ; acceptable Methods . add ( new  Username Password Method ( ) ) ; }
private boolean lock Order (  Order order ) { lock . lock ( ) ; try { return active Orders . add ( order . get Id ( ) ) ; } finally { lock . unlock ( ) ; } }
public void put (  Buffer buffer ) { if ( buffer . get Length ( ) <= _ NUM ) { return ; } byte [ ] current Rtp Packet Data = ( ( byte [ ] ) buffer . get Data ( ) ) ;  H264 Rtp Headers h264 Rtp Headers = new  H264 Rtp Headers ( current Rtp Packet Data ) ; if ( h264 Rtp Headers . get FUI_ F ( ) ) { return ; } if ( reassembled Data == null ) { timestamp = buffer . get Timestamp ( ) ; format = buffer . get Format ( ) ; seq Number = buffer . get Sequence Number ( ) ; reassembled Data NALHeader = h264 Rtp Headers . get NALHeader ( ) ; reassembled Data = new byte [  Java Packetizer .  H264_ MAX_ RTP_ PKTS ] [  H264_ FRAME_ PACKET_ SIZE ] ; reassembled Data Size = new int [  Java Packetizer .  H264_ MAX_ RTP_ PKTS ] ; reassembled Data Has Start = _ BOOL ; reassembled Data Has End = _ BOOL ; } int pos Seq = ( int ) ( buffer . get Sequence Number ( ) &  VIDEO_ DECODER_ MAX_ PAYLOADS_ CHUNKS_ MASK ) ; int payload Start Position = h264 Rtp Headers . get Header Size ( ) ; int payload Length = buffer . get Length ( ) - h264 Rtp Headers . get Header Size ( ) ; if ( h264 Rtp Headers . get FUI_ TYPE ( ) ==  H264 Rtp Headers .  AVC_ NALTYPE_ FUA ) { reassembled Data Has Start |= ( h264 Rtp Headers . get FUH_ S ( ) ) ; reassembled Data Has End |= ( h264 Rtp Headers . get FUH_ E ( ) ) ; reassembled Data Pos Seq Start = ( ( h264 Rtp Headers . get FUH_ S ( ) ) ? pos Seq : reassembled Data Pos Seq Start ) ; reassembled Data Pos Seq End = ( ( h264 Rtp Headers . get FUH_ E ( ) ) ? pos Seq : reassembled Data Pos Seq End ) ; } reassembled Data Size [ pos Seq ] = payload Length ; reassembled Data Full Size += payload Length ;  System . arraycopy ( current Rtp Packet Data , payload Start Position , reassembled Data [ pos Seq ] , _ NUM , payload Length ) ; video Orientation = buffer . get Video Orientation ( ) ; }
public static final void write String Array Xml (  String [ ] val ,  String name ,  Xml Serializer out ) throws  Xml Pull Parser Exception , java . io .  IOException { if ( val == null ) { out . start Tag ( null , _ STR ) ; out . end Tag ( null , _ STR ) ; return ; } out . start Tag ( null , _ STR ) ; if ( name != null ) { out . attribute ( null , _ STR , name ) ; } final int  N = val . length ; out . attribute ( null , _ STR ,  Integer . to String (  N ) ) ; for ( int i = _ NUM ; i <  N ; i ++ ) { out . start Tag ( null , _ STR ) ; out . attribute ( null , _ STR , val [ i ] ) ; out . end Tag ( null , _ STR ) ; } out . end Tag ( null , _ STR ) ; }
private void unify Username By Name (  Map <  String ,  List <  Log Commit Info > > dev Name Map ) { for (  Entry <  String ,  List <  Log Commit Info > > entry : dev Name Map . entry Set ( ) ) {  List <  String > user Names = get User Names List ( entry . get Value ( ) ) ; if ( user Names . size ( ) > _ NUM ) {  String new User Name = get New User Name ( user Names ) ; for (  Log Commit Info commit : entry . get Value ( ) ) { commit . set User Name ( new User Name ) ; } } } }
@  Suppress Warnings ( _ STR ) public  Jdbc Data (  Connection connection ,  String table , boolean buffered ) { this . connection = connection ; this . table = table ; set Buffered ( buffered ) ; try { set Column Types ( get Jdbc Column Types ( ) ) ; } catch (  SQLException e ) { e . print Stack Trace ( ) ; } }
public  Secure ELFFormatter ( ) {  String timestamp Generator Class = lmanager . get Property (  Log Constants .  SECURE_ TIMESTAMP_ GENERATOR ) ; try {  Class clz =  Class . for Name ( timestamp Generator Class ) ; secure Timestamp Generator = (  ITimestamp Generator ) clz . new Instance ( ) ; } catch (  Class Not Found Exception cnfe ) {  Debug . error ( _ STR + _ STR , cnfe ) ; } catch (  Instantiation Exception ie ) {  Debug . error ( _ STR + _ STR , ie ) ; } catch (  Illegal Access Exception iae ) {  Debug . error ( _ STR + _ STR , iae ) ; } }
public static byte [ ] read Data ( final  URL url ) throws  IOException { try (  Input Stream input = url . open Stream ( ) ) { return read Data ( input ) ; } }
public static  Energy Network init Network ( ) {  Random random = new  Random (  System . current Time Millis ( ) ) ; int id = random . next Int ( ) ; while ( used Ids . contains ( id ) ) { id = random . next Int ( ) ; } ;  Energy Network net = new  Energy Network ( ) ; used Ids . add ( id ) ; net . network ID = id ; return net ; }
public static  String to Kilobytes ( long bytes ) { if ( bytes < _ NUM ) return _ STR +  GENERAL_ UNIT_ KILOBYTES ; long kbytes = bytes / _ NUM ; if ( ( bytes & _ NUM ) != _ NUM || ( bytes > _ NUM && bytes < _ NUM ) ) kbytes ++ ; return  NUMBER_ FORMAT0 . format ( kbytes ) +  GENERAL_ UNIT_ KILOBYTES ; }
private  Pending Intent create Request Pending Intent ( @  Non Null  String pending Intent Class Name ) {  Pending Intent pending Intent = null ; try {  Class class Of Pending Intent =  Class . for Name ( pending Intent Class Name ) ; if ( class Of Pending Intent != null ) {  Intent intent = new  Intent ( m Context , class Of Pending Intent ) ; pending Intent =  Pending Intent . get Service ( m Context , _ NUM , intent ,  Pending Intent .  FLAG_ UPDATE_ CURRENT ) ; } } catch (  Class Not Found Exception e ) { e . print Stack Trace ( ) ; } return pending Intent ; }
void test String ( ) {  String a = random String ( ) ; if ( return New ) {  String b =  String Utils . from Cache Or New ( a ) ; try { assert Equals ( a , b ) ; } catch (  Exception e ) {  Test Base . log Error ( _ STR , e ) ; } if ( a != null && a == b && a . length ( ) > _ NUM ) { throw new  Assertion Error ( _ STR +  System . identity Hash Code ( a ) + _ STR +  System . identity Hash Code ( b ) ) ; } } else {  String b ; if ( use Intern ) { b = a == null ? null : a . intern ( ) ; } else { b =  String Utils . cache ( a ) ; } try { assert Equals ( a , b ) ; } catch (  Exception e ) {  Test Base . log Error ( _ STR , e ) ; } } }
public void configs (  Swt Platform ... platforms ) { configs (  Arrays . as List ( platforms ) ) ; }
protected int check IPRange ( ) { int ret Val = _ NUM ;  String ip Version ;  String ip Type ;  Map <  String ,  String > hold Details ; for (  String next IP :  IPRange Range ) { try { hold Details = check IPVersion ( next IP ) ; } catch (  Illegal Argument Exception e ) { if ( debug . warning Enabled ( ) ) { debug . warning ( _ STR ,  ADAPTIVE , next IP , e ) ; } continue ; } ip Version = hold Details . get (  IP_ Version ) ; ip Type = hold Details . get (  IP_ TYPE ) ; if ( ip Version . equals Ignore Case (  IP_ V6 ) &&  Validate IPaddress . is IPv6 ( client IP ) ) { if ( debug . message Enabled ( ) ) { debug . message ( _ STR ,  ADAPTIVE , client IP , next IP ) ; debug . message ( _ STR ,  IP_ V6 ) ; debug . message ( _ STR ,  IPv6 Address . from String ( client IP ) ) ; } if ( ip Type . equals Ignore Case ( _ STR ) ) {  String first = hold Details . get (  IP_ START ) ;  String last = hold Details . get (  IP_ END ) ;  IPv6 Address Range i Pv6 Address Range =  IPv6 Address Range . from First And Last (  IPv6 Address . from String ( first ) ,  IPv6 Address . from String ( last ) ) ; if ( i Pv6 Address Range . contains (  IPv6 Address . from String ( client IP ) ) ) { ret Val =  IPRange Score ; break ; } } else if ( ip Type . equals Ignore Case ( _ STR ) ) {  IPv6 Network i Pv6 Network =  IPv6 Network . from String ( next IP ) ; if ( i Pv6 Network . contains (  IPv6 Address . from String ( client IP ) ) ) { ret Val =  IPRange Score ; break ; } } else {  IPv6 Address i Pv6 Address Next IP =  IPv6 Address . from String ( next IP ) ; if ( i Pv6 Address Next IP . compare To (  IPv6 Address . from String ( client IP ) ) == _ NUM ) { ret Val =  IPRange Score ; break ; } } } else if ( ip Version . equals Ignore Case (  IP_ V4 ) &&  Validate IPaddress . is IPv4 ( client IP ) ) { if ( debug . message Enabled ( ) ) { debug . message ( _ STR ,  ADAPTIVE , client IP , next IP ) ; debug . message ( _ STR ,  IP_ V4 ) ; debug . message ( _ STR , client IP ) ; }  IPRange the Range = new  IPRange ( next IP ) ; if ( the Range . in Range ( client IP ) ) { ret Val =  IPRange Score ; break ; } } } if ( !  IPRange Invert ) { ret Val =  IPRange Score - ret Val ; } return ret Val ; }
private  View fill From Selection ( int selected Left , int children Left , int children Right ) { if (  DEBUG )  Log . i (  TAG , _ STR + selected Left + _ STR + children Left +  CHILDREN_ RIGHT + children Right +  M_ FIRST_ POSITION + m First Position ) ; final int fading Edge Length = get Horizontal Fading Edge Length ( ) ; final int selected Position = m Selected Position ; final int num Rows = m Num Rows ; final int horizontal Spacing = m Horizontal Spacing ; int column Start ; int column End = - _ NUM ; if ( ! m Stack From Bottom ) { column Start = selected Position - ( selected Position % num Rows ) ; } else { int inverted Selection = m Item Count - _ NUM - selected Position ; column End = m Item Count - _ NUM - ( inverted Selection - ( inverted Selection % num Rows ) ) ; column Start =  Math . max ( _ NUM , column End - num Rows + _ NUM ) ; }  View sel ;  View reference View ; int left Selection Pixel = get Left Selection Pixel ( children Left , fading Edge Length , column Start ) ; int right Selection Pixel = get Right Selection Pixel ( children Right , fading Edge Length , num Rows , column Start ) ; sel = make Column ( m Stack From Bottom ? column End : column Start , selected Left , _ BOOL ) ; m First Position = column Start ; reference View = m Reference View ; adjust For Left Fading Edge ( reference View , left Selection Pixel , right Selection Pixel ) ; adjust For Right Fading Edge ( reference View , left Selection Pixel , right Selection Pixel ) ; if ( ! m Stack From Bottom ) { fill Left ( column Start - num Rows , reference View . get Left ( ) - horizontal Spacing ) ; adjust Views Left Or Right ( ) ; fill Right ( column Start + num Rows , reference View . get Right ( ) + horizontal Spacing ) ; } else { fill Right ( column End + num Rows , reference View . get Right ( ) + horizontal Spacing ) ; adjust Views Left Or Right ( ) ; fill Left ( column Start - _ NUM , reference View . get Left ( ) - horizontal Spacing ) ; } return sel ; }
@  Override public  Shape Tile Simplex to_ Simplex ( ) { if ( is_empty ( ) ) return  Shape Tile Simplex .  EMPTY ;  Array List <  Pla Line Int > line_arr = new  Array List <  Pla Line Int > ( _ NUM ) ; line_arr . add ( new  Pla Line Int ( box_ll ,  Pla Direction .  RIGHT ) ) ; line_arr . add ( new  Pla Line Int ( box_ur ,  Pla Direction .  UP ) ) ; line_arr . add ( new  Pla Line Int ( box_ur ,  Pla Direction .  LEFT ) ) ; line_arr . add ( new  Pla Line Int ( box_ll ,  Pla Direction .  DOWN ) ) ; return new  Shape Tile Simplex ( line_arr ) ; }
private void inject Content (  Inject inject Content ) throws  IOException ,  Mojo Execution Exception {  Map <  Pattern ,  File > contents = get Contents Map ( inject Content . get Contents ( ) ) ;  File tmp File = io Factory . create Temporary File ( inject Content . get Destination File ( ) ) ;  Buffered Reader reader = null ;  Buffered Writer writer = null ; try { reader = io Factory . new Reader ( inject Content . get Destination File ( ) ) ; writer = io Factory . new Writer ( tmp File ) ;  String line ; while ( ( line = reader . read Line ( ) ) != null ) {  File content = does Line Match Id ( contents , line ) ; if ( content != null ) { io Factory . write Content ( writer , content , get Content Converter ( inject Content ) ) ; } else { io Factory . write Line ( writer , line ) ; } } } finally { if ( reader != null ) { reader . close ( ) ; } if ( writer != null ) { writer . flush ( ) ; writer . close ( ) ; } } io Factory . move To ( tmp File , inject Content . get Destination File ( ) ) ; }
private static boolean create Boolean Setting ( final  Map <  String ,  String > raw Settings , final  String setting Name , final boolean default Value ) { final  String setting String = raw Settings . get ( setting Name ) ; if ( setting String == null ) { return default Value ; } else { try { return  Boolean . parse Boolean ( setting String ) ; } catch ( final  Number Format Exception exception ) {  CUtility Functions . log Exception ( exception ) ; return default Value ; } } }
private  Marshalled Wrapper lookup Do (  Template tmpl ) { if ( is Empty ( tmpl . service Types ) || tmpl . service ID != null ) {  Item Iter iter = matching Items ( tmpl ) ; if ( iter . has Next ( ) ) return iter . next ( ) . service ; return null ; }  List services = matching Services ( tmpl . service Types ) ; long now =  System . current Time Millis ( ) ; int slen = services . size ( ) ; if ( slen == _ NUM ) return null ; int srand =  Math . abs ( random . next Int ( ) % slen ) ; for ( int i = _ NUM ; i < slen ; i ++ ) {  Svc Reg reg = (  Svc Reg ) services . get ( ( i + srand ) % slen ) ; if ( reg . lease Expiration > now && match Attributes ( tmpl , reg . item ) ) return reg . item . service ; } return null ; }
@  Override public boolean run After (  List tasks , int size ) { for ( int i = _ NUM ; i < size ; i ++ ) {  Cache Task t = (  Cache Task ) tasks . get ( i ) ; if ( t instanceof  Register Listener Task || t instanceof  Lookup Task ) {  Proxy Reg other Reg = t . get Proxy Reg ( ) ; if ( reg . equals ( other Reg ) ) { if ( this Task Seq N > t . get Seq N ( ) ) return _ BOOL ; } } } return super . run After ( tasks , size ) ; }
String generate Key ( ) throws  Oracle Exception { byte [ ] data = null ; try { data =  Hash Funcs . get Random ( ) ; } catch (  Exception e ) { if (  Oracle Log . is Logging Enabled ( ) ) log . warning ( e . to String ( ) ) ; } if ( data == null ) { data = fetch Guid ( ) ; } if ( data == null ) { throw  SODAUtils . make Exception (  SODAMessage .  EX_ UNABLE_ TO_ CREATE_ UUID ) ; } return (  Byte Array . raw To Hex ( data ) ) ; }
public double [ ] array Copy ( ) { double [ ] array = new double [ length ( ) ] ; for (  Index Value iv : this ) array [ iv . get Index ( ) ] = iv . get Value ( ) ; return array ; }
public static void delete (  Path path ) { if ( path != null ) { path = path . to Absolute Path ( ) ; if ( in Target Dir ( path ) ) { try {  Io Util . delete ( path ) ; } catch (  IOException e ) { print Error ( _ STR + path . to Absolute Path ( ) + _ STR , e ) ; } } else { print Error ( _ STR + path ) ; } } }
private void init Pattern ( ) {  String Buffer pattern Template Regex = new  String Buffer ( ) ; logger . debug ( _ STR ) ;  Matcher placeholder Matcher = get Placeholder Matcher ( ) ; logger . debug ( _ STR ) ; while ( placeholder Matcher . find ( ) ) {  String group = placeholder Matcher . group ( _ NUM ) ; if ( ! groups . contains ( group ) ) { logger . trace ( _ STR ) ; groups . add ( group ) ;  String group Regex = get Group Regex ( group ) ; placeholder Matcher . append Replacement ( pattern Template Regex ,  Matcher . quote Replacement ( _ STR + group + _ STR + group Regex + _ STR ) ) ; } else { logger . trace ( _ STR ) ; placeholder Matcher . append Replacement ( pattern Template Regex ,  Matcher . quote Replacement ( _ STR + group + _ STR ) ) ; } } placeholder Matcher . append Tail ( pattern Template Regex ) ;  String pattern Regex = pattern Template Regex . to String ( ) ; logger . debug ( _ STR + pattern Regex ) ; pattern =  Pattern . compile ( pattern Regex ) ; }
protected void new Line (  Print Writer file ,  String string , boolean is Manifest ) {  String [ ] lines = string . split (  NEW_ LINE ) ; for (  String line : lines ) {  String [ ] words = line . split (  SPACE ) ;  String Buffer sb = new  String Buffer ( ) ; for (  String word : words ) { if ( check String Length ( sb . to String ( ) + word , is Manifest ) ) { sb . append ( word +  SPACE ) ; } else { sb . set Length ( sb . length ( ) - _ NUM ) ; add Line ( file , sb . to String ( ) ) ; sb = new  String Buffer ( word +  SPACE ) ; } } if ( sb . length ( ) > _ NUM ) { sb . set Length ( sb . length ( ) - _ NUM ) ; } add Line ( file , sb . to String ( ) ) ; } }
protected boolean update Attachment Point ( ) { boolean moved = _ BOOL ; this . old APs = attachment Points ; if ( attachment Points == null || attachment Points . is Empty ( ) ) return _ BOOL ;  List <  Attachment Point > ap List = new  Array List <  Attachment Point > ( ) ; if ( attachment Points != null ) ap List . add All ( attachment Points ) ;  Map <  Long ,  Attachment Point > new Map = get APMap ( ap List ) ; if ( new Map == null || new Map . size ( ) != ap List . size ( ) ) { moved = _ BOOL ; } if ( moved ) { log . info ( _ STR , attachment Points , new Map ) ;  List <  Attachment Point > new APList = new  Array List <  Attachment Point > ( ) ; if ( new Map != null ) new APList . add All ( new Map . values ( ) ) ; this . attachment Points = new APList ; } return moved ; }
public  List <  Soft Wrap Impl > remove Starting From ( int offset ) { int start Index = get Soft Wrap Index ( offset ) ; if ( start Index < _ NUM ) { start Index = - start Index - _ NUM ; } if ( start Index >= my Wraps . size ( ) ) { return  Collections . empty List ( ) ; }  List <  Soft Wrap Impl > tail = my Wraps . sub List ( start Index , my Wraps . size ( ) ) ;  List <  Soft Wrap Impl > result = new  Array List <  Soft Wrap Impl > ( tail ) ; tail . clear ( ) ; return result ; }
public static  String format Dps ( final double dps ) { return _ STR +  String . format ( _ STR , dps ) + _ STR ; }
public static  String truncate (  String string , int length ) { if ( string . length ( ) > length ) { string = string . substring ( _ NUM , length ) ; } return string ; }
private boolean check Disband (  Legion legion ) { if ( legion . is Disbanding ( ) ) { if ( (  System . current Time Millis ( ) / _ NUM ) > legion . get Disband Time ( ) ) { disband Legion ( legion ) ; return _ BOOL ; } } return _ BOOL ; }
public static void downto ( float self ,  Number to , @  Closure Params (  First Param . class )  Closure closure ) { float to1 = to . float Value ( ) ; if ( self >= to1 ) { for ( float i = self ; i >= to1 ; i -- ) { closure . call ( i ) ; } } else throw new  Groovy Runtime Exception ( _ STR + to + _ STR + self + _ STR ) ; }
protected void parse DOMAttributes (  Element element ) throws  SAML2 Exception { request Id = element . get Attribute (  SAML2 Constants .  ID ) ; validate ID ( request Id ) ; version = element . get Attribute (  SAML2 Constants .  VERSION ) ; validate Version ( version ) ;  String issue Instant Str = element . get Attribute (  SAML2 Constants .  ISSUE_ INSTANT ) ; validate Issue Instant ( issue Instant Str ) ; destination URI = element . get Attribute (  SAML2 Constants .  DESTINATION ) ; consent = element . get Attribute (  SAML2 Constants .  CONSENT ) ; }
public static  Input Stream stream From String (  String location ) throws  IOException {  Input Stream is = null ;  URL url = url From String ( location , null , _ BOOL ) ; if ( url != null ) { is = url . open Stream ( ) ; } else {  File f = new  File ( location ) ; if ( f . exists ( ) ) is = new  File Input Stream ( f ) ; } if ( is == null ) { return null ; } else if ( is GZip File ( location ) ) { return new  GZIPInput Stream ( is ) ; } else { return is ; } }
public void add (  T item ) { synchronized ( lock ) { items . add ( identified Item Factory . create ( item ) ) ; } notify Data Set Changed ( ) ; }
private void copy ACLs (  List <  Un Managed Cifs Share ACL > orig ACLList ,  List <  Cifs Share ACL > share ACLList ,  File Share fileshare ) {  Cifs Share ACL share ACL = null ; for (  Un Managed Cifs Share ACL orig ACL : orig ACLList ) { share ACL = new  Cifs Share ACL ( ) ; share ACL . set Id (  URIUtil . create Id (  Cifs Share ACL . class ) ) ; share ACL . set User ( orig ACL . get User ( ) ) ; share ACL . set Permission ( orig ACL . get Permission ( ) ) ; share ACL . set Share Name ( orig ACL . get Share Name ( ) ) ; share ACL . set File System Id ( fileshare . get Id ( ) ) ; share ACLList . add ( share ACL ) ; _logger . info ( _ STR , share ACL . to String ( ) ) ; } }
public  Resource List Parser parse ( ) throws  Parser Configuration Exception ,  SAXException ,  Parse Failure Exception { try {  SAXParser Factory factory =  SAXParser Factory . new Instance ( ) ;  SAXParser parser = factory . new SAXParser ( ) ; parser . parse ( m Input Source , this ) ; return this ; } catch (  IOException e ) { throw new  Parse Failure Exception ( _ STR , e ) ; } }
public  Builder delete Entitlements ( ) { delete Fields . add ( _ STR ) ; return this ; }
protected void incorporate Signed Properties ( ) throws  DSSException { signed Properties Dom =  DSSXMLUtils . add Element ( document Dom , qualifying Properties Dom ,  XAd ES ,  XADES_ SIGNED_ PROPERTIES ) ; signed Properties Dom . set Attribute (  ID , _ STR + deterministic Id ) ; incorporate Signed Signature Properties ( ) ; }
public static float mean ( float [ ] data , int [ ] inds ) { float mean = _ NUM ; for ( int i = _ NUM ; i < inds . length ; i ++ ) { if (  Float . is Na N ( data [ inds [ i ] ] ) ) throw new  Illegal Argument Exception ( _ STR ) ; mean += data [ inds [ i ] ] ; } mean /= inds . length ; return mean ; }
public int depth ( ) { return pointer ; }
public  Result do Comparison Test (  Properties properties ) throws  Exception { final long timeout =  Long . parse Long ( properties . get Property (  Test Options .  TIMEOUT ) ) ; final int ntrials =  Integer . parse Int ( properties . get Property (  Test Options .  NTRIALS ) ) ; final int nclients =  Integer . parse Int ( properties . get Property (  Test Options .  NCLIENTS ) ) ; final double percent Readers =  Double . parse Double ( properties . get Property (  Test Options .  PERCENT_ READERS ) ) ; final double percent Writers Will Flush =  Double . parse Double ( properties . get Property (  Test Options .  PERCENT_ WRITER_ WILL_ FLUSH ) ) ; final int reclen =  Integer . parse Int ( properties . get Property (  Test Options .  RECLEN ) ) ; final int nwrites Per Task =  Integer . parse Int ( properties . get Property (  Test Options .  NWRITES ) ) ; final int nreads Per Task =  Integer . parse Int ( properties . get Property (  Test Options .  NREADS ) ) ; final  Atomic Integer nerr = new  Atomic Integer ( ) ; final  Result result = do MRMWTest ( store , timeout , ntrials , nclients , percent Readers , percent Writers Will Flush , reclen , nwrites Per Task , nreads Per Task , nerr ) ; return result ; }
private void cmd_import ( ) {  JFile Chooser jc = new  JFile Chooser ( ) ; jc . set Dialog Title (  Msg . get Msg (  Env . get Ctx ( ) , _ STR ) ) ; jc . set Dialog Type (  JFile Chooser .  OPEN_ DIALOG ) ; jc . set File Selection Mode (  JFile Chooser .  FILES_ ONLY ) ; if ( jc . show Open Dialog ( this ) !=  JFile Chooser .  APPROVE_ OPTION ) return ;  String Buffer sb = new  String Buffer ( ) ; try {  Input Stream Reader in = new  Input Stream Reader ( new  File Input Stream ( jc . get Selected File ( ) ) ) ; char [ ] cbuf = new char [ _ NUM ] ; int count ; while ( ( count = in . read ( cbuf ) ) > _ NUM ) sb . append ( cbuf , _ NUM , count ) ; in . close ( ) ; } catch (  Exception e ) { log . log (  Level .  SEVERE , _ STR + e . get Message ( ) ) ; return ; } set Html Text ( sb . to String ( ) ) ; }
private  List <  String > fetch File Cos Id List ( ) throws  SOSFailure { final  String method Name = _ STR ; log . trace ( method Name + _ STR ) ; final  String  FILE_ COS_ URI = _ STR ;  List <  String > file Cos Id List = new  Array List <  String > ( ) ; try {  Co SList cos Elem List = _client . query Object (  FILE_ COS_ URI ,  Co SList . class ) ; if ( cos Elem List != null && cos Elem List . get Cos Elements ( ) != null ) { for (  Co SElement elem : cos Elem List . get Cos Elements ( ) ) { if ( elem != null ) { file Cos Id List . add ( elem . get Id ( ) ) ; } } } log . trace ( method Name + _ STR + file Cos Id List ) ; if ( cos Elem List != null && file Cos Id List != null ) { log . trace ( method Name + _ STR + file Cos Id List . size ( ) + _ STR ) ; return file Cos Id List ; } log . trace ( method Name + _ STR ) ; return new  Array List <  String > ( ) ; } catch (  No Such Algorithm Exception e ) { log . error ( method Name + _ STR , e ) ; throw new  SOSFailure ( e ) ; } catch (  Uniform Interface Exception e ) { log . error ( method Name + _ STR , e ) ; throw new  SOSFailure ( e ) ; } }
public void monitor (  Scaling State Monitor Task task ) { task Queue . add ( task ) ; start Monitor ( ) ; }
public final double sample Max ( ) { long max = _max . get And Set ( _ NUM ) ; return _scale * max ; }
private static void write File (  File file ,  List <  String > lines ) throws  IOException { if ( ! file . exists ( ) ) file . create New File ( ) ;  File Writer fw = new  File Writer ( file ) ;  Buffered Writer  Bw = new  Buffered Writer ( fw ) ;  Print Writer pw = new  Print Writer (  Bw ) ; for (  String line : lines ) pw . println ( line ) ;  Bw . close ( ) ; fw . close ( ) ; pw . close ( ) ; }
public synchronized boolean verify Chunk Auth Tag ( int chunk Idx , byte [ ] chunk Auth Tag ) throws  File Encryption Exception { if ( ( chunk Idx < _ NUM ) || ( chunk Auth Tag == null ) || ( chunk Auth Tag . length != back Enc Random Access File .  CHUNK_ TLEN ) ) { throw new  File Encryption Exception ( _ STR ) ; } else { byte [ ] stored Auth Tag = atag List . get ( chunk Idx ) ; if ( stored Auth Tag == null || !  Arrays . equals ( chunk Auth Tag , stored Auth Tag ) ) { return _ BOOL ; } else { return _ BOOL ; } } }
public <  Annotation Type extends  Annotation > void register (  Method Binder <  Annotation Type > method Binder ) {  Set <  Annotated Method <  Annotation Type > > annotated Methods =  Annotated Methods . get ( method Binder . get Annotation Class ( ) , annotated Type ) ; if ( ! annotated Methods . is Empty ( ) ) { object Binders . add ( new  Annotated Method Binder < > ( method Binder , annotated Methods ) ) ; } }
public static  String remove New Line Chars (  String s ) {  String ret String = null ; if ( ( s != null ) && ( s . length ( ) > _ NUM ) && ( s . index Of ( _ STR ) != - _ NUM ) ) { char [ ] chars = s . to Char Array ( ) ; int len = chars . length ;  String Buffer sb = new  String Buffer ( len ) ; for ( int i = _ NUM ; i < len ; i ++ ) { char c = chars [ i ] ; if ( c != _ STR ) { sb . append ( c ) ; } } ret String = sb . to String ( ) ; } else { ret String = s ; } return ret String ; }
private  Document parse Route File ( ) throws  Exception {  Document Builder Factory factory =  Document Builder Factory . new Instance ( ) ; factory . set Namespace Aware ( _ BOOL ) ;  Document Builder builder = factory . new Document Builder ( ) ; return builder . parse ( route File ) ; }
public void remove DTEDDirectory Handler (  DTEDDirectory Handler handler ) { directories . remove ( handler ) ; }
public default void add File ( final  Content Provider content Provider , final  String file Name , final  Entry Information entry Information ) throws  IOException { add File ( content Provider , file Name , entry Information ,  Optional . empty ( ) ) ; }
private  Vector <  Snmp Var Bind > split From (  Vector <  Snmp Var Bind > original , int limit ) { int max = original . size ( ) ;  Vector <  Snmp Var Bind > result = new  Vector < > ( max - limit ) ; int i = limit ; for (  Enumeration <  Snmp Var Bind > e = original . elements ( ) ; e . has More Elements ( ) ; -- i ) {  Snmp Var Bind var = e . next Element ( ) ; if ( i > _ NUM ) continue ; result . add Element ( new  Snmp Var Bind ( var . oid , var . value ) ) ; } return result ; }
public static void init Urban Sim Zone Writer (  Config config ) {  Urban Sim Parameter Config Module V3 module = (  Urban Sim Parameter Config Module V3 ) config . get Module (  Urban Sim Parameter Config Module V3 .  GROUP_ NAME ) ; try { log . info ( _ STR ) ; parcel Writer =  IOUtils . get Buffered Writer ( module . get MATSim4 Opus Temp ( ) +  FILE_ NAME ) ; log . info ( _ STR + module . get MATSim4 Opus Temp ( ) +  FILE_ NAME + _ STR ) ; parcel Writer . write (  Internal Constants .  PARCEL_ ID + _ STR +  ACCESSIBILITY_ BY_ FREESPEED + _ STR +  ACCESSIBILITY_ BY_ CAR + _ STR +  ACCESSIBILITY_ BY_ BIKE + _ STR +  ACCESSIBILITY_ BY_ WALK + _ STR +  ACCESSIBILITY_ BY_ PT ) ; parcel Writer . new Line ( ) ; log . info ( _ STR ) ; } catch (  Exception e ) { e . print Stack Trace ( ) ; } }
public final void delay Task ( @  Not Null  Transaction Runnable task ) { my Delayed Tasks . add ( task ) ; }
private static <  T > int migrate All (  Migration <  T > migration ) throws  Exception { int migrated = _ NUM ; for (  T entity : migration . get All Entities ( ) ) { try { if ( migration . is Migrated ( entity ) ) continue ; } catch (  Exception x ) {  LOG . error ( _ STR , entity ) ; throw x ; } try { migration . migrate ( entity ) ; } catch (  Exception x ) {  LOG . error ( _ STR , entity ) ; throw x ; } migrated ++ ; } return migrated ; }
private void capture Different String (  String old String ,  String new String ,  Map <  String ,  String > map ,  String app Name ) {  Reject . if Null ( app Name ) ;  Reject . if Null ( map ) ; if ( old String == null ? new String != null : ! old String . equals ( new String ) ) { map . put ( app Name , new String ) ; } }
@  Override protected void draw XLabels (  List <  Double > x Labels ,  Double [ ] x Text Label Locations ,  Canvas canvas ,  Paint paint , int left , int top , int bottom , double x Pixels Per Unit , double min X , double max X ) { int length = x Labels . size ( ) ; if ( length > _ NUM ) { boolean show Labels = m Renderer . is Show Labels ( ) ; boolean show Grid Y = m Renderer . is Show Grid Y ( ) ;  Date Format format = get Date Format ( x Labels . get ( _ NUM ) , x Labels . get ( length - _ NUM ) ) ; for ( int i = _ NUM ; i < length ; i ++ ) { long label =  Math . round ( x Labels . get ( i ) ) ; float x Label = ( float ) ( left + x Pixels Per Unit * ( label - min X ) ) ; if ( show Labels ) { paint . set Color ( m Renderer . get XLabels Color ( ) ) ; canvas . draw Line ( x Label , bottom , x Label , bottom + m Renderer . get Labels Text Size ( ) / _ NUM , paint ) ; draw Text ( canvas , format . format ( new  Date ( label ) ) , x Label , bottom + m Renderer . get Labels Text Size ( ) * _ NUM / _ NUM , paint , m Renderer . get XLabels Angle ( ) ) ; } if ( show Grid Y ) { paint . set Color ( m Renderer . get Grid Color ( ) ) ; canvas . draw Line ( x Label , bottom , x Label , top , paint ) ; } } } draw XText Labels ( x Text Label Locations , canvas , paint , _ BOOL , left , top , bottom , x Pixels Per Unit , min X , max X ) ; }
public static  String encode To String ( byte [ ] src ) { if ( src == null ) { return null ; } if ( src . length == _ NUM ) { return _ STR ; }  String result ; try { result = new  String ( delegate . encode ( src ) ,  DEFAULT_ CHARSET . display Name ( ) ) ; } catch (  Unsupported Encoding Exception e ) { throw new  Illegal State Exception ( e ) ; } return result ; }
public static void chunk Task Sync (  Region Wrapper region , final  Runnable Val < int [ ] > task ) { final int p1x = region . min X ; final int p1z = region . min Z ; final int p2x = region . max X ; final int p2z = region . max Z ; final int bcx = p1x > > _ NUM ; final int bcz = p1z > > _ NUM ; final int tcx = p2x > > _ NUM ; final int tcz = p2z > > _ NUM ; task . value = new int [ _ NUM ] ; for ( int x = bcx ; x <= tcx ; x ++ ) { for ( int z = bcz ; z <= tcz ; z ++ ) { task . value [ _ NUM ] = x ; task . value [ _ NUM ] = z ; task . value [ _ NUM ] = task . value [ _ NUM ] << _ NUM ; task . value [ _ NUM ] = task . value [ _ NUM ] << _ NUM ; task . value [ _ NUM ] = task . value [ _ NUM ] + _ NUM ; task . value [ _ NUM ] = task . value [ _ NUM ] + _ NUM ; task . value [ _ NUM ] = _ NUM ; if ( task . value [ _ NUM ] == bcx ) { task . value [ _ NUM ] = p1x ; task . value [ _ NUM ] = _ NUM ; } if ( task . value [ _ NUM ] == tcx ) { task . value [ _ NUM ] = p2x ; task . value [ _ NUM ] = _ NUM ; } if ( task . value [ _ NUM ] == bcz ) { task . value [ _ NUM ] = p1z ; task . value [ _ NUM ] = _ NUM ; } if ( task . value [ _ NUM ] == tcz ) { task . value [ _ NUM ] = p2z ; task . value [ _ NUM ] = _ NUM ; } task . run ( ) ; } } }
public  Elsa Serializer Pojo make ( ) { return new  Elsa Serializer Pojo ( object Stack , singletons , registered Sers , registered Ser Headers , registered Deser , unknown Class Notification , new  Elsa Class Info Resolver .  Array Based ( classes . to Array ( new  Class [ _ NUM ] ) ) ) ; }
private void load Binary (  Input Stream is ) throws  IOException { if ( is instanceof  File Input Stream ) {  File Input Stream fis = (  File Input Stream ) is ;  File Channel fc = fis . get Channel ( ) ;  Mapped Byte Buffer bb = fc . map (  File Channel .  Map Mode .  READ_ ONLY , _ NUM , ( int ) fc . size ( ) ) ; bb . load ( ) ; load Binary ( bb ) ; is . close ( ) ; } else { load Binary ( new  Data Input Stream ( is ) ) ; } }
private static boolean is Two Slot Type (  Class Node type ) { return type ==  Class Helper . long_ TYPE || type ==  Class Helper . double_ TYPE ; }
public  Specification Runner Builder sections (  String [ ] param Sections ) {  Collections . add All ( this . sections , param Sections ) ; return this ; }
private void consume CRLF ( ) throws  Decoding Exception { char next = next Char ( ) ; if ( next != _ STR ) { consume Char ( _ STR ) ; } consume Char ( _ STR ) ; }
private  String process Logout Request (  Logout State t ,  Logout Request logout Request ,  Session Manager session Manager ) throws  Saml Service Exception {  String session Id = null ;  List <  Session Index > session List = logout Request . get Session Indexes ( ) ;  Validate . not Null ( session List , _ STR ) ;  Validate . is True ( session List . size ( ) > _ NUM ) ; for (  Session Index session Index : session List ) {  Validate . not Null ( session Index ) ;  String participant Session = session Index . get Session Index ( ) ;  Validate . not Null ( participant Session , _ STR ) ;  Session session = session Manager . get By Participant ( participant Session ) ; if ( session == null ) { throw new  Saml Service Exception ( _ STR ) ; } if ( ! session . contains Session Participant Url ( t . get Issuer Value ( ) ) ) { throw new  Saml Service Exception ( _ STR ) ; } if ( session Id == null ) { session Id = session . get Id ( ) ; } else { if ( ! session Id . equals ( session . get Id ( ) ) ) { throw new  Saml Service Exception ( _ STR ) ; } } } return session Id ; }
public boolean equals (  Object o ) { if ( o instanceof  Coverage Int Vdt ) {  Coverage Int Vdt civ = (  Coverage Int Vdt ) o ; return ( ( attribute == civ . attribute ) && ( value == civ . value ) ) ; } else { return _ BOOL ; } }
public void accept ( final  Path file ) throws  Interrupted Exception { logger . info (  String . format ( _ STR , file ) ) ; permits . acquire ( ) ; executor . execute ( new  Consumer Task ( file ) ) ; }
public void test Neg Pos First Shorter ( ) { byte a Bytes [ ] = { - _ NUM , - _ NUM , - _ NUM , - _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM } ; byte b Bytes [ ] = { - _ NUM , _ NUM , _ NUM , _ NUM , - _ NUM , - _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , - _ NUM , _ NUM , _ NUM , - _ NUM , _ NUM , _ NUM , - _ NUM , - _ NUM } ; int a Sign = - _ NUM ; int b Sign = _ NUM ; byte r Bytes [ ] = { - _ NUM , _ NUM , _ NUM , - _ NUM , - _ NUM , - _ NUM , - _ NUM , - _ NUM , - _ NUM , - _ NUM , - _ NUM , - _ NUM , - _ NUM } ;  Big Integer a Number = new  Big Integer ( a Sign , a Bytes ) ;  Big Integer b Number = new  Big Integer ( b Sign , b Bytes ) ;  Big Integer result = a Number . or ( b Number ) ; byte res Bytes [ ] = new byte [ r Bytes . length ] ; res Bytes = result . to Byte Array ( ) ; for ( int i = _ NUM ; i < res Bytes . length ; i ++ ) { assert True ( res Bytes [ i ] == r Bytes [ i ] ) ; } assert Equals ( _ STR , - _ NUM , result . signum ( ) ) ; }
private  Activity check Activity ( ) {  Activity activity = m Activity . get ( ) ; if ( activity == null ) { throw new  Illegal State Exception ( _ STR ) ; } return activity ; }
@  Override public synchronized void start ( ) {  LOGGER . info ( _ STR ) ; timer = new  Timer ( _ STR ) ; timer . schedule ( this ,  INITIAL_ SCAN_ DELAY ,  SCAN_ INTERVAL ) ; running = _ BOOL ; }
public boolean is Landing Page (  URL url ) { if ( url . get Query ( ) != null ) { return _ BOOL ; } else { return landing Page Suffix ( url ) != _ STR ; } }
protected static void write Row Count Definitions (  Table Creator creator ,  Byte Buffer buffer ) { write Row Count Definitions ( creator , buffer , creator . get Index Count ( ) ) ; }
public void init ( ) { _token Mgmt Executor . schedule With Fixed Delay ( new  Expired Token Cleaner ( ) , _ NUM , _max Life Values Holder . get Max Token Idle Time In Mins ( ) ,  Time Unit .  MINUTES ) ; _token Mgmt Executor . schedule With Fixed Delay ( new  Token Keys Updater ( ) , _ NUM ,  FOREIGN_ TOKEN_ KEYS_ BUNDLE_ REFRESH_ RATE_ IN_ MINS ,  Time Unit .  MINUTES ) ; }
public static _ Fields find By Thrift Id ( int field Id ) { switch ( field Id ) { case _ NUM : return  PATH ; case _ NUM : return  OFFSET_ LBA ; default : return null ; } }
public  String to String ( ) { return _ STR +  String . value Of ( bean ) + _ STR ; }
private void sign ( final byte [ ] content Bytes , final  Byte Array Output Stream mime Content ) throws  Exception {  String alg Id = conf . get Signature Algorithm Id ( ) ;  String key Id = conf . get Active Signing Key ( ) ; log . debug ( _ STR + _ STR , key Id , alg Id ) ;  String signature = sign Helper ( key Id , alg Id , content Bytes ) ; mime Content . write ( envelope Header . get Bytes ( ) ) ; try (  Multipart Encoder encoder = new  Multipart Encoder ( mime Content , envelope Boundary ) ) { encoder . start Part ( mp Mixed Content Type ( data Boundary ) ) ; encoder . write ( content Bytes ) ;  String alg URI =  Crypto Utils . get Signature Algorithm URI ( alg Id ) ;  String hash URI = hash Calculator . get Algo URI ( ) ;  Path verificatio Cert Path = conf . get Cert Path ( key Id ) ; encoder . start Part (  Mime Types .  BINARY , new  String [ ] {  HEADER_ CONTENT_ TRANSFER_ ENCODING + _ STR ,  HEADER_ SIG_ ALGO_ ID + _ STR + alg URI ,  HEADER_ VERIFICATION_ CERT_ HASH + _ STR + get Verification Cert Hash ( verificatio Cert Path ) + _ STR +  HEADER_ HASH_ ALGORITHM_ ID + _ STR + hash URI } ) ; encoder . write ( signature . get Bytes ( ) ) ; } log . debug ( _ STR , mime Content . to String ( ) ) ;  Files . write ( temp Conf Path , mime Content . to Byte Array ( ) ) ; log . debug ( _ STR , temp Conf Path ) ; }
private boolean next Item Is (  String match ) throws  IOException { int c ; while ( is White Space ( c = buf . get ( ) ) ) { } for ( int i = _ NUM ; i < match . length ( ) ; i ++ ) { if ( i > _ NUM ) { c = buf . get ( ) ; } if ( c != match . char At ( i ) ) { return _ BOOL ; } } return _ BOOL ; }
public static  Object deserialize Object ( final byte [ ] obj Bytes , final  Class Loader loader ) throws  IOException ,  Class Not Found Exception {  Object Input Stream obj In = null ; try { obj In = new  Class Loader Object Input Stream ( new  Byte Array Input Stream ( obj Bytes ) , loader ) ; return obj In . read Object ( ) ; } finally { close ( obj In ) ; } }
public  Interval Impl ( int serial Num , long start Interval Date Time , double coverage Factor ,  Framing Flow Type interval Data Type ,  ISource source ,  IInterval Classification interval Classification ,  Version ade Version ) throws  Ade Internal Exception { a_ade Version = ade Version ; if ( start Interval Date Time < _ NUM ) { throw new  Illegal Argument Exception (  String . format ( _ STR + _ STR + _ STR + _ STR , serial Num , start Interval Date Time , coverage Factor , interval Data Type , source , interval Classification , ade Version ) ) ; } m_start Interval Time = start Interval Date Time ; m_framing Flow Type = interval Data Type ; m_serial Num = serial Num ; m_interval Classification = interval Classification ; if ( m_interval Classification == null ) { m_interval Classification =  Interval Classification Enum .  REGULAR ; } m_message Summary Map = new  Tree Map <  Integer ,  IMessage Summary > ( ) ; m_end Interval Time = m_start Interval Time + m_framing Flow Type . get Duration ( ) ; m_source = source ; if ( coverage Factor <= _ NUM || coverage Factor > _ NUM ) { throw new  Ade Internal Exception ( _ STR + coverage Factor ) ; } m_coverage Factor = coverage Factor ; }
public static boolean is True (  Map <  String ,  Object > dict ,  String key ) { return is True ( dict , key , _ BOOL ) ; }
protected  Shopping Cart Item ( ) { }
private void init Map Layer ( ) { float zoom = get Init Zoom ( map View . get Width ( ) , map View . get Height ( ) , image . get Width ( ) , image . get Height ( ) ) ;  Log . i (  TAG ,  Float . to String ( zoom ) ) ; map View . set Current Zoom ( zoom , _ NUM , _ NUM ) ; float width = map View . get Width ( ) - zoom * image . get Width ( ) ; float height = map View . get Height ( ) - zoom * image . get Height ( ) ; map View . translate ( width / _ NUM , height / _ NUM ) ; }
public static double sample Skew ( int size , double moment3 , double sample Variance ) { int n = size ; double s =  Math . sqrt ( sample Variance ) ; double m3 = moment3 * n ; return n * m3 / ( ( n - _ NUM ) * ( n - _ NUM ) * s * s * s ) ; }
private  String extract Span (  String spans , int start , int end ) throws  Index Out Of Bounds Exception { int offset = get First Span Offset ( spans ) ; assert ( start >= offset ) ; assert ( end >= offset ) ; spans +=  HTML_ OPEN_ SPAN ; int substart = get Span Pos ( spans , start - offset ) ; int subend = get Span Pos ( spans , end - offset + _ NUM ) ; return spans . substring ( substart , subend ) ; }
public void finished ( long chain Length ) { current State = chain Length ; if ( loggers != null ) { for (  Logger logger : loggers ) { logger . log ( current State ) ; logger . stop Logging ( ) ; } } if ( show Operator Analysis ) { show Operator Analysis (  System . out ) ; } if ( operator Analysis File != null ) { try {  Print Stream out = new  Print Stream ( new  File Output Stream ( operator Analysis File ) ) ; show Operator Analysis ( out ) ; out . flush ( ) ; out . close ( ) ; } catch (  IOException e ) { e . print Stack Trace ( ) ; } } }
@  Suppress Warnings ( _ STR ) public void register Default Device Types ( ) { final  Hash Map <  String ,  String > devices List =  Default Platform . get Device Service Map ( ) ; for (  Hash Map .  Entry <  String ,  String > entry : devices List . entry Set ( ) ) {  String key = entry . get Key ( ) ;  String value = entry . get Value ( ) ; try { register Device Service ( (  Class <  Device Service > )  Class . for Name ( key ) , (  Class <  Discovery Provider > )  Class . for Name ( value ) ) ; } catch (  Class Not Found Exception e ) { e . print Stack Trace ( ) ; } } }
protected void positive Close ( ) { free Content ( ) ; }
public  Input Stream Reader ( java . io .  Input Stream is , java . lang .  String enc ) throws java . io .  Unsupported Encoding Exception { internal = is ; this . enc = enc . intern ( ) ; }
public int server Delivery (  Object message ,  Object consumer , int delivery Count ) throws  Exception {  Proton Server Sender Context proton Sender = server Senders . get ( consumer ) ; if ( proton Sender != null ) { return proton Sender . deliver Message ( message , delivery Count ) ; } return _ NUM ; }
public static  String decode (  Abstract Message msg ,  Boolean ext , int header ) { if ( ext == _ BOOL ) { return decode ( msg ) ; } return _ STR + header ; }
private  Instance voted Reclassify Example (  Instance example ) throws  Exception { int class Votes [ ] = new int [ get Num Classes ( ) ] ; for ( int i = _ NUM ; i < class Votes . length ; i ++ ) { class Votes [ i ] = _ NUM ; } for (  Enumeration <  Rule List > e = new  Weka Enumeration <  Rule List > ( m_ Decision List ) ; e . has More Elements ( ) ; ) {  Rule List rl = e . next Element ( ) ; int class Value = ( int ) rl . classify Instance ( example ) ; if ( class Value >= _ NUM ) { class Votes [ class Value ] ++ ; } } int max Vote = _ NUM ; int vote = - _ NUM ; for ( int i = _ NUM ; i < class Votes . length ; i ++ ) { if ( class Votes [ i ] > max Vote ) { max Vote = class Votes [ i ] ; vote = i ; } } if ( vote >= _ NUM ) { example . set Class Value ( vote ) ; } else { throw new  Exception ( _ STR ) ; } return example ; }
public final int hash Code ( ) { return  System . identity Hash Code ( this ) ; }
private  Big Query IO ( ) { }
private boolean key Chain Contains Private Key (  Collection <  ECKey > key Chain ,  ECKey key To Add ) { if ( key Chain == null || key To Add == null ) { return _ BOOL ; } else { for (  ECKey loop Key : key Chain ) { if (  Arrays . equals ( key To Add . get Priv Key Bytes ( ) , loop Key . get Priv Key Bytes ( ) ) ) { return _ BOOL ; } } return _ BOOL ; } }
public  Script Builder data ( byte [ ] data ) { if ( data . length == _ NUM ) return small Num ( _ NUM ) ; else return data ( chunks . size ( ) , data ) ; }
private void write User Registry (  Local Container container ,  File config Dir ,  Map <  String ,  String > users ,  Map <  String ,  List <  String > > groups ) throws  IOException {  File users XML = new  File ( config Dir , _ STR ) ;  Print Stream writer =  Server Config Utils . open ( users XML ) ; writer . println ( _ STR ) ; for (  Map .  Entry <  String ,  String > user : users . entry Set ( ) ) { writer . print ( _ STR ) ; writer . print ( user . get Key ( ) ) ; writer . print ( _ STR ) ; writer . print ( user . get Value ( ) ) ; writer . println ( _ STR ) ; } for (  Map .  Entry <  String ,  List <  String > > group : groups . entry Set ( ) ) { writer . print ( _ STR ) ; writer . print ( group . get Key ( ) ) ; writer . println ( _ STR ) ; for (  String member : group . get Value ( ) ) { writer . print ( _ STR ) ; writer . print ( member ) ; writer . println ( _ STR ) ; } writer . println ( _ STR ) ; } writer . println ( _ STR ) ;  Server Config Utils . close ( writer ) ; }
@  Gen Ignore static  Record create Record (  String name ,  String address ,  Class itf ,  Json Object metadata ) { return create Record ( name , address , itf . get Name ( ) , metadata ) ; }
public  Stopwatch CPU ( ) { thread Timer =  Management Factory . get Thread MXBean ( ) ; start = thread Timer . get Current Thread Cpu Time ( ) ; }
public synchronized byte [ ] lookup Audio (  String inputtype ,  String locale ,  String voice ,  String outputparams ,  String style ,  String effects ,  String inputtext ) throws  SQLException { if ( inputtype == null || locale == null || voice == null || inputtext == null ) { throw new  Null Pointer Exception ( _ STR ) ; } byte [ ] audio = null ;  String query = _ STR + inputtype + _ STR + locale + _ STR + voice + _ STR + outputparams + _ STR + style + _ STR + effects + _ STR ;  Prepared Statement st = connection . prepare Statement ( query ) ; st . set String ( _ NUM , inputtext ) ;  Result Set results = st . execute Query ( ) ; if ( results . next ( ) ) { audio = results . get Bytes ( _ NUM ) ; } return audio ; }
public void add Condition ( final  Condition condition ) { conditions . add ( condition ) ; condition . set Id ( condition Id Counter ++ ) ; }
public static byte [ ] read Bytes From Byte Buffer (  Byte Buffer byte Buffer ) { byte [ ] buffer = new byte [ byte Buffer . remaining ( ) ] ; byte Buffer . get ( buffer ) ; return buffer ; }
public void find Package And Class ( ) throws  IOException { package Name = null ; class Name = null ;  Line Number Reader reader = new  Line Number Reader ( new  File Reader ( input File ) ) ; try { while ( class Name == null || package Name == null ) {  String line = reader . read Line ( ) ; if ( line == null ) break ; if ( package Name == null ) {  Matcher matcher =  PACKAGE_ PATTERN . matcher ( line ) ; if ( matcher . find ( ) ) { package Name = matcher . group ( _ NUM ) ; } } if ( class Name == null ) {  Matcher matcher =  CLASS_ PATTERN . matcher ( line ) ; if ( matcher . find ( ) ) { class Name = matcher . group ( _ NUM ) ; } } } if ( class Name == null ) { class Name = _ STR ; } } finally { reader . close ( ) ; } }
public static  Set <  URI > fetch RPTarget Virtual Pools (  Db Client db Client ) {  Set <  URI > rp Protected Target VPools = new  Hash Set <  URI > ( ) ; try {  List <  URI > vpool Protection Settings URIs = db Client . query By Type (  Vpool Protection Varray Settings . class , _ BOOL ) ;  Iterator <  Vpool Protection Varray Settings > v Pool Protection Settings Itr = db Client . query Iterative Objects (  Vpool Protection Varray Settings . class , vpool Protection Settings URIs , _ BOOL ) ; while ( v Pool Protection Settings Itr . has Next ( ) ) {  Vpool Protection Varray Settings r Setting = v Pool Protection Settings Itr . next ( ) ; if ( null != r Setting && !  Null Column Value Getter . is Null URI ( r Setting . get Virtual Pool ( ) ) ) { rp Protected Target VPools . add ( r Setting . get Virtual Pool ( ) ) ; } } } catch (  Exception ex ) { _log . error ( _ STR , ex ) ; } return rp Protected Target VPools ; }
public int cardinality ( ) { int sum = _ NUM ; for ( long l : this . data ) sum +=  Long . bit Count ( l ) ; return sum ; }
private  String de Escape Literal (  String lit ) { return lit . replace All ( _ STR , _ STR ) ; }
public static void i (  String msg ,  Object ... args ) { if ( ! allow I ) return ;  Stack Trace Element caller = get Caller Stack Trace Element ( ) ;  String tag = generate Tag ( caller ) ; if ( s Level >  LEVEL_ INFO ) { return ; } if ( args . length > _ NUM ) { msg =  String . format ( msg , args ) ; }  Log . i ( tag , msg ) ; }
public  DNew Key Store Type (  JFrame parent ) { super ( parent ,  Dialog .  Modality Type .  DOCUMENT_ MODAL ) ; set Title ( res . get String ( _ STR ) ) ; init Components ( ) ; }
private int insert Test Data Local DTTypes (  Prepared Statement pstmt ) throws  Exception { pstmt . set Int ( _ NUM , _ NUM ) ; pstmt . set Date ( _ NUM , test Sql Date ) ; pstmt . set Time ( _ NUM , test Sql Time ) ; pstmt . set Timestamp ( _ NUM , test Sql Time Stamp ) ; pstmt . set Timestamp ( _ NUM , test Sql Time Stamp ) ; assert Equals ( _ NUM , pstmt . execute Update ( ) ) ; pstmt . set Int ( _ NUM , _ NUM ) ; pstmt . set Object ( _ NUM , test Local Date ) ; pstmt . set Object ( _ NUM , test Local Time ) ; pstmt . set Object ( _ NUM , test Local Date Time ) ; pstmt . set Object ( _ NUM , test Local Date Time ) ; assert Equals ( _ NUM , pstmt . execute Update ( ) ) ; pstmt . set Int ( _ NUM , _ NUM ) ; pstmt . set Object ( _ NUM , test Local Date ,  JDBCType .  DATE ) ; pstmt . set Object ( _ NUM , test Local Time ,  JDBCType .  TIME ) ; pstmt . set Object ( _ NUM , test Local Date Time ,  JDBCType .  TIMESTAMP ) ; pstmt . set Object ( _ NUM , test Local Date Time ,  JDBCType .  TIMESTAMP ) ; assert Equals ( _ NUM , pstmt . execute Update ( ) ) ; pstmt . set Int ( _ NUM , _ NUM ) ; pstmt . set Object ( _ NUM , test Local Date ,  JDBCType .  DATE , _ NUM ) ; pstmt . set Object ( _ NUM , test Local Time ,  JDBCType .  TIME , _ NUM ) ; pstmt . set Object ( _ NUM , test Local Date Time ,  JDBCType .  TIMESTAMP , _ NUM ) ; pstmt . set Object ( _ NUM , test Local Date Time ,  JDBCType .  TIMESTAMP , _ NUM ) ; assert Equals ( _ NUM , pstmt . execute Update ( ) ) ; pstmt . set Int ( _ NUM , _ NUM ) ; pstmt . set Object ( _ NUM , test Local Date ,  JDBCType .  VARCHAR ) ; pstmt . set Object ( _ NUM , test Local Time ,  JDBCType .  VARCHAR ) ; pstmt . set Object ( _ NUM , test Local Date Time ,  JDBCType .  VARCHAR ) ; pstmt . set Object ( _ NUM , test Local Date Time ,  JDBCType .  VARCHAR ) ; assert Equals ( _ NUM , pstmt . execute Update ( ) ) ; pstmt . set Int ( _ NUM , _ NUM ) ; pstmt . set Object ( _ NUM , test Local Date ,  JDBCType .  VARCHAR , _ NUM ) ; pstmt . set Object ( _ NUM , test Local Time ,  JDBCType .  VARCHAR , _ NUM ) ; pstmt . set Object ( _ NUM , test Local Date Time ,  JDBCType .  VARCHAR , _ NUM ) ; pstmt . set Object ( _ NUM , test Local Date Time ,  JDBCType .  VARCHAR , _ NUM ) ; assert Equals ( _ NUM , pstmt . execute Update ( ) ) ; if ( pstmt instanceof  Callable Statement ) {  Callable Statement cstmt = (  Callable Statement ) pstmt ; cstmt . set Int ( _ STR , _ NUM ) ; cstmt . set Date ( _ STR , test Sql Date ) ; cstmt . set Time ( _ STR , test Sql Time ) ; cstmt . set Timestamp ( _ STR , test Sql Time Stamp ) ; cstmt . set Timestamp ( _ STR , test Sql Time Stamp ) ; assert Equals ( _ NUM , cstmt . execute Update ( ) ) ; cstmt . set Int ( _ STR , _ NUM ) ; cstmt . set Object ( _ STR , test Local Date ) ; cstmt . set Object ( _ STR , test Local Time ) ; cstmt . set Object ( _ STR , test Local Date Time ) ; cstmt . set Object ( _ STR , test Local Date Time ) ; assert Equals ( _ NUM , cstmt . execute Update ( ) ) ; cstmt . set Int ( _ STR , _ NUM ) ; cstmt . set Object ( _ STR , test Local Date ,  JDBCType .  DATE ) ; cstmt . set Object ( _ STR , test Local Time ,  JDBCType .  TIME ) ; cstmt . set Object ( _ STR , test Local Date Time ,  JDBCType .  TIMESTAMP ) ; cstmt . set Object ( _ STR , test Local Date Time ,  JDBCType .  TIMESTAMP ) ; assert Equals ( _ NUM , cstmt . execute Update ( ) ) ; cstmt . set Int ( _ STR , _ NUM ) ; cstmt . set Object ( _ STR , test Local Date ,  JDBCType .  DATE , _ NUM ) ; cstmt . set Object ( _ STR , test Local Time ,  JDBCType .  TIME , _ NUM ) ; cstmt . set Object ( _ STR , test Local Date Time ,  JDBCType .  TIMESTAMP , _ NUM ) ; cstmt . set Object ( _ STR , test Local Date Time ,  JDBCType .  TIMESTAMP , _ NUM ) ; assert Equals ( _ NUM , cstmt . execute Update ( ) ) ; cstmt . set Int ( _ STR , _ NUM ) ; cstmt . set Object ( _ STR , test Local Date ,  JDBCType .  VARCHAR ) ; cstmt . set Object ( _ STR , test Local Time ,  JDBCType .  VARCHAR ) ; cstmt . set Object ( _ STR , test Local Date Time ,  JDBCType .  VARCHAR ) ; cstmt . set Object ( _ STR , test Local Date Time ,  JDBCType .  VARCHAR ) ; assert Equals ( _ NUM , cstmt . execute Update ( ) ) ; cstmt . set Int ( _ STR , _ NUM ) ; cstmt . set Object ( _ STR , test Local Date ,  JDBCType .  VARCHAR , _ NUM ) ; cstmt . set Object ( _ STR , test Local Time ,  JDBCType .  VARCHAR , _ NUM ) ; cstmt . set Object ( _ STR , test Local Date Time ,  JDBCType .  VARCHAR , _ NUM ) ; cstmt . set Object ( _ STR , test Local Date Time ,  JDBCType .  VARCHAR , _ NUM ) ; assert Equals ( _ NUM , cstmt . execute Update ( ) ) ; return _ NUM ; } return _ NUM ; }
public void remove Listener ( final  L listener ) {  Validate . not Null ( listener , _ STR ) ; listeners . remove ( listener ) ; }
public void run ( ) { start ( ) ; try { while ( _ BOOL ) {  Thread . sleep ( interval ) ; process Config Messages ( ) ; } } catch (  Interrupted Exception e ) { e . print Stack Trace ( ) ; log . warn ( _ STR ) ; } finally { log . info ( _ STR ) ; stop ( ) ; } }
private void read Object ( java . io .  Object Input Stream s ) throws  IOException ,  Class Not Found Exception { s . default Read Object ( ) ; init ( get Name ( ) , get Mask ( actions ) ) ; }
public int pred Block Index For Sources Index ( int sources Index ) { return operands . get ( sources Index ) . block Index ; }
void append Program Description ( final  Wrapping String Builder wb ) { if ( ! m Program Description . equals ( _ STR ) ) { wb . append (  LS ) ; wb . set Wrap Indent ( _ NUM ) ; wb . wrap Text With New Lines ( m Program Description ) ; } }
public static byte [ ] decode (  String s ) throws java . io .  IOException { return decode ( s ,  NO_ OPTIONS ) ; }
@  Suppress Warnings ( _ STR ) private static final  URL to URL (  String location , boolean file ) { if ( file ) {  File f = new  File ( location ) ; if ( f . exists ( ) ) { try { return f . to URL ( ) ; } catch (  Malformed URLException murl ) { return null ; } } else { return null ; } } else { return get URL ( location ) ; } }
protected  Object parse Value (  String string ) { int open Paren = string . index Of ( _ STR ) ;  String type = string . substring ( _ NUM , open Paren ) ;  String value = string . substring ( open Paren + _ NUM , string . length ( ) - _ NUM ) ; if ( type . equals ( _ STR ) ) { return value ; } else if ( type . equals ( _ STR ) ) { return new  Float (  Float . parse Float ( value ) ) ; } else if ( type . equals ( _ STR ) ) { return new  Integer (  Integer . parse Int ( value ) ) ; } else if ( type . equals ( _ STR ) ) {  String Tokenizer tok = new  String Tokenizer ( value , _ STR ) ; int size = tok . count Tokens ( ) ; int [ ] values = new int [ size ] ; for ( int i = _ NUM ; i < size ; i ++ ) { float fval =  Float . parse Float ( tok . next Token ( ) ) ; values [ i ] =  Math . round ( fval ) ; } return values ; } else { throw new  Error ( _ STR + type ) ; } }
@  Override public void update (  List <  Env Var > data List ) { env Var List . clear ( ) ; if ( data List == null ) { for (  Env Var env Var : built In Env Var Map . values ( ) ) { env Var List . add ( env Var ) ; } } else { for (  Env Var env Var : data List ) { if ( built In Env Var Map . contains Key ( env Var . get Name ( ) ) ) { env Var List . add ( new  Env Var ( env Var , _ BOOL ) ) ; } else { env Var List . add ( new  Env Var ( env Var , _ BOOL ) ) ; } } } set Environment Variable Values ( ) ; }
public void make Class (  String str , boolean caseless ) { for ( int i = _ NUM ; i < str . length ( ) ; i ++ ) make Class ( str . char At ( i ) , caseless ) ; }
protected void notify Timestamps To Gateways (  Entry Event Impl event ) {  Version Tag Holder update Time Stamp Event = new  Version Tag Holder ( event . get Version Tag ( ) ) ; update Time Stamp Event . set Operation (  Operation .  UPDATE_ VERSION_ STAMP ) ; update Time Stamp Event . set Key Info ( event . get Key Info ( ) ) ; update Time Stamp Event . set Generate Callbacks ( _ BOOL ) ; update Time Stamp Event . distributed Member = event . get Distributed Member ( ) ; update Time Stamp Event . set New Event Id ( get System ( ) ) ; if ( event . get Region ( ) instanceof  Bucket Region ) {  Bucket Region br = (  Bucket Region ) event . get Region ( ) ;  Partitioned Region pr = br . get Partitioned Region ( ) ; update Time Stamp Event . set Region ( pr ) ; if ( pr . is Parallel Wan Enabled ( ) ) { br . handle WANEvent ( update Time Stamp Event ) ; } if ( pr . is Initialized ( ) ) { pr . notify Gateway Sender (  Enum Listener Event .  TIMESTAMP_ UPDATE , update Time Stamp Event ) ; } } else { update Time Stamp Event . set Region ( event . get Region ( ) ) ; notify Gateway Sender (  Enum Listener Event .  TIMESTAMP_ UPDATE , update Time Stamp Event ) ; } }
public  Token next Regex (  Pattern pattern ) { if ( ! has Next Regex ( pattern ) ) throw new  Illegal State Exception ( _ STR ) ;  Matcher matcher = any Mention Pattern . matcher ( remaining ) ; if ( ! matcher . find ( ) ) throw new  Illegal State Exception ( _ STR ) ; final int start = current Position + matcher . start ( ) ; final int end = current Position + matcher . end ( ) ; step To ( end ) ; return new  Token ( this , start , end ) ; }
public  String as String ( ) throws  IOException { long len = get Content Length ( ) ;  Byte Array Output Stream buf ; if ( _ NUM < len ) { buf = new  Byte Array Output Stream ( ( int ) len ) ; } else { buf = new  Byte Array Output Stream ( ) ; } write To ( buf ) ; return decode ( buf . to Byte Array ( ) , get Character Encoding ( ) ) ; }
public void add Content Item (  Content Item content Item ) { if ( content Items == null ) { content Items = new  Array List <  Content Item > ( ) ; } content Items . add ( content Item ) ; }
public void execute ( ) throws  IOException {  String key = _ STR + (  System . current Time Millis ( ) / _ NUM ) ;  String b64 Key =  Base64 . encode ( key ) ; send Handshake Request ( b64 Key ) ; receive Handshake Response ( b64 Key ) ; }
public void calculate Min ( double min ) { if ( this . min == - _ NUM ) { this . min = min ; } else { this . min =  Math . min ( this . min , min ) ; } }
private void emit Until ( @  Nonnegative int task Count Allowed ) throws  IOException { try { while ( emit Queue . size ( ) > task Count Allowed ) {  Future < byte [ ] > future = emit Queue . remove ( ) ; byte [ ] to Write = future . get ( ) ; block Sizes . add ( to Write . length ) ; out . write ( to Write ) ; } try Emit ( ) ; } catch (  Execution Exception e ) { throw new  IOException ( e ) ; } catch (  Interrupted Exception e ) { throw new  Interrupted IOException ( ) ; } }
public void test Audit Completed ( ) { }
public static void scale Rect About Center (  Rect r , float scale ) { if ( scale != _ NUM ) { int cx = r . center X ( ) ; int cy = r . center Y ( ) ; r . offset ( - cx , - cy ) ; r . left = ( int ) ( r . left * scale + _ NUM ) ; r . top = ( int ) ( r . top * scale + _ NUM ) ; r . right = ( int ) ( r . right * scale + _ NUM ) ; r . bottom = ( int ) ( r . bottom * scale + _ NUM ) ; r . offset ( cx , cy ) ; } }
private static  Char Handler parse Unprintable Ext Codes (  String [ ] code Strings ) { if ( code Strings . length != _ NUM ) { throw new  Illegal State Exception ( _ STR +  Arrays . as List ( code Strings ) ) ; } byte [ ] bytes = codes To Bytes ( code Strings [ _ NUM ] , _ BOOL ) ; if ( bytes . length != _ NUM ) { throw new  Illegal State Exception ( _ STR +  Arrays . as List ( code Strings ) ) ; } return new  Unprintable Ext Char Handler ( bytes [ _ NUM ] ) ; }
public void update Pending List ( ) { while ( m Pending List . size ( ) > _ NUM && active List Has Room ( ) ) {  Download Info Runnable pending = m Pending List . get ( _ NUM ) ; pending . change Status State ( new  Active State ( pending ) ) ; } }
@  Suppress Warnings ( _ STR ) public static float value Range Limit ( float value , float start Value , float end Value ) { if ( value <  Math . min ( start Value , end Value ) ) return  Math . min ( start Value , end Value ) ; if ( value >  Math . max ( start Value , end Value ) ) return  Math . max ( start Value , end Value ) ; return value ; }
public static boolean is Connected (  Net Type net Type ,  Network Info network Info ) { if ( net Type ==  Net Type .  Any && network Info != null && is Connected ( network Info ) ) return _ BOOL ; else if ( net Type ==  Net Type .  Wifi && network Info != null && network Info . get Type ( ) ==  Connectivity Manager .  TYPE_ WIFI && is Connected ( network Info ) ) return _ BOOL ; else if ( net Type ==  Net Type .  Mobile && network Info != null && network Info . get Type ( ) ==  Connectivity Manager .  TYPE_ MOBILE && is Connected ( network Info ) ) return _ BOOL ; return _ BOOL ; }
public void delete Item ( int position ) { if ( ! is Data List Empty ( ) && position >= _ NUM && position < m Data List . size ( ) ) { m Data List . remove ( position ) ; notify Item Removed ( position ) ; } }
private int calculate Graident Channel ( int source Channel , int dest Channel , int distance , int offset ) { if ( source Channel == dest Channel ) { return source Channel ; } float ratio = ( ( float ) offset ) / ( ( float ) distance ) ; int pos = ( int ) (  Math . abs ( source Channel - dest Channel ) * ratio ) ; if ( source Channel > dest Channel ) { return source Channel - pos ; } else { return source Channel + pos ; } }
private void apply Image Matrix ( float width , float height , boolean center , boolean animate ) { if ( m Bitmap != null && width > _ NUM && height > _ NUM ) { m Image Matrix . reset ( ) ; m Image Matrix . post Translate ( ( width - m Bitmap . get Width ( ) ) / _ NUM , ( height - m Bitmap . get Height ( ) ) / _ NUM ) ; map Image Points By Image Matrix ( ) ; if ( m Degrees Rotated > _ NUM ) { m Image Matrix . post Rotate ( m Degrees Rotated ,  Bitmap Utils . get Rect Center X ( m Image Points ) ,  Bitmap Utils . get Rect Center Y ( m Image Points ) ) ; map Image Points By Image Matrix ( ) ; } float scale =  Math . min ( width /  Bitmap Utils . get Rect Width ( m Image Points ) , height /  Bitmap Utils . get Rect Height ( m Image Points ) ) ; if ( m Scale Type ==  Scale Type .  FIT_ CENTER || ( m Scale Type ==  Scale Type .  CENTER_ INSIDE && scale < _ NUM ) || ( scale > _ NUM && m Auto Zoom Enabled ) ) { m Image Matrix . post Scale ( scale , scale ,  Bitmap Utils . get Rect Center X ( m Image Points ) ,  Bitmap Utils . get Rect Center Y ( m Image Points ) ) ; map Image Points By Image Matrix ( ) ; } m Image Matrix . post Scale ( m Zoom , m Zoom ,  Bitmap Utils . get Rect Center X ( m Image Points ) ,  Bitmap Utils . get Rect Center Y ( m Image Points ) ) ; map Image Points By Image Matrix ( ) ;  Rect F crop Rect = m Crop Overlay View . get Crop Window Rect ( ) ; crop Rect . offset ( - m Zoom Offset X * m Zoom , - m Zoom Offset Y * m Zoom ) ; if ( center ) { m Zoom Offset X = width >  Bitmap Utils . get Rect Width ( m Image Points ) ? _ NUM :  Math . max (  Math . min ( width / _ NUM - crop Rect . center X ( ) , -  Bitmap Utils . get Rect Left ( m Image Points ) ) , get Width ( ) -  Bitmap Utils . get Rect Right ( m Image Points ) ) / m Zoom ; m Zoom Offset Y = height >  Bitmap Utils . get Rect Height ( m Image Points ) ? _ NUM :  Math . max (  Math . min ( height / _ NUM - crop Rect . center Y ( ) , -  Bitmap Utils . get Rect Top ( m Image Points ) ) , get Height ( ) -  Bitmap Utils . get Rect Bottom ( m Image Points ) ) / m Zoom ; } else { m Zoom Offset X =  Math . min (  Math . max ( m Zoom Offset X * m Zoom , - crop Rect . left ) , - crop Rect . right + width ) / m Zoom ; m Zoom Offset Y =  Math . min (  Math . max ( m Zoom Offset Y * m Zoom , - crop Rect . top ) , - crop Rect . bottom + height ) / m Zoom ; } m Image Matrix . post Translate ( m Zoom Offset X * m Zoom , m Zoom Offset Y * m Zoom ) ; crop Rect . offset ( m Zoom Offset X * m Zoom , m Zoom Offset Y * m Zoom ) ; m Crop Overlay View . set Crop Window Rect ( crop Rect ) ; map Image Points By Image Matrix ( ) ; if ( animate ) { m Animation . set End State ( m Image Points , m Image Matrix ) ; m Image View . start Animation ( m Animation ) ; } else { m Image View . set Image Matrix ( m Image Matrix ) ; } update Image Bounds ( _ BOOL ) ; } }
public static void add Startup Listener (  Start Up Listener s ) { m_ Startup Listeners . add ( s ) ; }
public static void close Quiet ( @  Nullable  Selection Key rsrc ) { if ( rsrc != null ) close Quiet ( rsrc . channel ( ) ) ; }
public  Completable Future <  New File > run ( ) {  LOG . log (  Level .  FINE , _ STR , files . size ( ) ) ;  Completable Future <  New File > file Creation = new  Completable Future < > ( ) ; final  List <  TSData > fjp Files = this . files ;  TASK_ POOL . execute ( null ) ; synchronized (  OUTSTANDING ) {  OUTSTANDING . add ( file Creation ) ; } this . files = new  Linked List < > ( ) ; return file Creation ; }
private static  Key create DESKey ( byte [ ] bytes , int offset ) { byte [ ] key Bytes = new byte [ _ NUM ] ;  System . arraycopy ( bytes , offset , key Bytes , _ NUM , _ NUM ) ; byte [ ] material = new byte [ _ NUM ] ; material [ _ NUM ] = key Bytes [ _ NUM ] ; material [ _ NUM ] = ( byte ) ( key Bytes [ _ NUM ] << _ NUM | ( key Bytes [ _ NUM ] & _ NUM ) > > > _ NUM ) ; material [ _ NUM ] = ( byte ) ( key Bytes [ _ NUM ] << _ NUM | ( key Bytes [ _ NUM ] & _ NUM ) > > > _ NUM ) ; material [ _ NUM ] = ( byte ) ( key Bytes [ _ NUM ] << _ NUM | ( key Bytes [ _ NUM ] & _ NUM ) > > > _ NUM ) ; material [ _ NUM ] = ( byte ) ( key Bytes [ _ NUM ] << _ NUM | ( key Bytes [ _ NUM ] & _ NUM ) > > > _ NUM ) ; material [ _ NUM ] = ( byte ) ( key Bytes [ _ NUM ] << _ NUM | ( key Bytes [ _ NUM ] & _ NUM ) > > > _ NUM ) ; material [ _ NUM ] = ( byte ) ( key Bytes [ _ NUM ] << _ NUM | ( key Bytes [ _ NUM ] & _ NUM ) > > > _ NUM ) ; material [ _ NUM ] = ( byte ) ( key Bytes [ _ NUM ] << _ NUM ) ; odd Parity ( material ) ; return new  Secret Key Spec ( material , _ STR ) ; }
protected  Js Output new Js Output (  Module m ) throws  IOException { return new  Js Output ( m , is Compiling Language Module ( ) ) ; }
public  String text ( ) {  String Builder sb = new  String Builder ( ) ; for (  Node node : nodes ) { sb . append ( node . get Text Content ( ) ) ; } return sb . to String ( ) ; }
private boolean scan Expr (  Symbol Table symbol Table ,  Tokens tokens ,  String data , int current Offset , int end Offset ) throws  XNIException { int ch ; int open Paren = _ NUM ; int close Paren = _ NUM ; int name Offset , data Offset ; boolean is QName = _ BOOL ;  String name = null ;  String prefix = null ;  String scheme Data = null ;  String Buffer scheme Data Buff = new  String Buffer ( ) ; while ( _ BOOL ) { if ( current Offset == end Offset ) { break ; } ch = data . char At ( current Offset ) ; while ( ch == _ STR || ch == _ NUM || ch == _ NUM || ch == _ NUM ) { if ( ++ current Offset == end Offset ) { break ; } ch = data . char At ( current Offset ) ; } if ( current Offset == end Offset ) { break ; } byte chartype = ( ch >= _ NUM ) ?  CHARTYPE_ NONASCII : f ASCIIChar Map [ ch ] ; switch ( chartype ) { case  CHARTYPE_ OPEN_ PAREN : add Token ( tokens ,  Tokens .  XPTRTOKEN_ OPEN_ PAREN ) ; open Paren ++ ; ++ current Offset ; break ; case  CHARTYPE_ CLOSE_ PAREN : add Token ( tokens ,  Tokens .  XPTRTOKEN_ CLOSE_ PAREN ) ; close Paren ++ ; ++ current Offset ; break ; case  CHARTYPE_ CARRET : case  CHARTYPE_ COLON : case  CHARTYPE_ DIGIT : case  CHARTYPE_ EQUAL : case  CHARTYPE_ LETTER : case  CHARTYPE_ MINUS : case  CHARTYPE_ NONASCII : case  CHARTYPE_ OTHER : case  CHARTYPE_ PERIOD : case  CHARTYPE_ SLASH : case  CHARTYPE_ UNDERSCORE : case  CHARTYPE_ WHITESPACE : if ( open Paren == _ NUM ) { name Offset = current Offset ; current Offset = scan NCName ( data , end Offset , current Offset ) ; if ( current Offset == name Offset ) { report Error ( _ STR , new  Object [ ] { data } ) ; return _ BOOL ; } if ( current Offset < end Offset ) { ch = data . char At ( current Offset ) ; } else { ch = - _ NUM ; } name = symbol Table . add Symbol ( data . substring ( name Offset , current Offset ) ) ; prefix =  XMLSymbols .  EMPTY_ STRING ; if ( ch == _ STR ) { if ( ++ current Offset == end Offset ) { return _ BOOL ; } ch = data . char At ( current Offset ) ; prefix = name ; name Offset = current Offset ; current Offset = scan NCName ( data , end Offset , current Offset ) ; if ( current Offset == name Offset ) { return _ BOOL ; } if ( current Offset < end Offset ) { ch = data . char At ( current Offset ) ; } else { ch = - _ NUM ; } is QName = _ BOOL ; name = symbol Table . add Symbol ( data . substring ( name Offset , current Offset ) ) ; } if ( current Offset != end Offset ) { add Token ( tokens ,  Tokens .  XPTRTOKEN_ SCHEMENAME ) ; tokens . add Token ( prefix ) ; tokens . add Token ( name ) ; is QName = _ BOOL ; } else if ( current Offset == end Offset ) { add Token ( tokens ,  Tokens .  XPTRTOKEN_ SHORTHAND ) ; tokens . add Token ( name ) ; is QName = _ BOOL ; } close Paren = _ NUM ; break ; } else if ( open Paren > _ NUM && close Paren == _ NUM && name != null ) { data Offset = current Offset ; current Offset = scan Data ( data , scheme Data Buff , end Offset , current Offset ) ; if ( current Offset == data Offset ) { report Error ( _ STR , new  Object [ ] { data } ) ; return _ BOOL ; } if ( current Offset < end Offset ) { ch = data . char At ( current Offset ) ; } else { ch = - _ NUM ; } scheme Data = symbol Table . add Symbol ( scheme Data Buff . to String ( ) ) ; add Token ( tokens ,  Tokens .  XPTRTOKEN_ SCHEMEDATA ) ; tokens . add Token ( scheme Data ) ; open Paren = _ NUM ; scheme Data Buff . delete ( _ NUM , scheme Data Buff . length ( ) ) ; } else { return _ BOOL ; } } } return _ BOOL ; }
public void add Line ( int start Line ,  String source File , int repeat Count , int output Line , int output Increment ) { _lines . add ( new  Line ( start Line , source File , repeat Count , output Line , output Increment ) ) ; }
public  String (  String Buffer stringbuffer ) { offset = _ NUM ; synchronized ( stringbuffer ) { value = stringbuffer . share Value ( ) ; count = stringbuffer . length ( ) ; } }
public static  Range iterate To Find Domain Bounds (  XYDataset dataset ,  List visible Series Keys , boolean include Interval ) {  Param Checks . null Not Permitted ( dataset , _ STR ) ;  Param Checks . null Not Permitted ( visible Series Keys , _ STR ) ; double minimum =  Double .  POSITIVE_ INFINITY ; double maximum =  Double .  NEGATIVE_ INFINITY ; if ( include Interval && dataset instanceof  Interval XYDataset ) {  Interval XYDataset ixyd = (  Interval XYDataset ) dataset ;  Iterator iterator = visible Series Keys . iterator ( ) ; while ( iterator . has Next ( ) ) {  Comparable series Key = (  Comparable ) iterator . next ( ) ; int series = dataset . index Of ( series Key ) ; int item Count = dataset . get Item Count ( series ) ; for ( int item = _ NUM ; item < item Count ; item ++ ) { double xvalue = ixyd . get XValue ( series , item ) ; double lvalue = ixyd . get Start XValue ( series , item ) ; double uvalue = ixyd . get End XValue ( series , item ) ; if ( !  Double . is Na N ( xvalue ) ) { minimum =  Math . min ( minimum , xvalue ) ; maximum =  Math . max ( maximum , xvalue ) ; } if ( !  Double . is Na N ( lvalue ) ) { minimum =  Math . min ( minimum , lvalue ) ; } if ( !  Double . is Na N ( uvalue ) ) { maximum =  Math . max ( maximum , uvalue ) ; } } } } else {  Iterator iterator = visible Series Keys . iterator ( ) ; while ( iterator . has Next ( ) ) {  Comparable series Key = (  Comparable ) iterator . next ( ) ; int series = dataset . index Of ( series Key ) ; int item Count = dataset . get Item Count ( series ) ; for ( int item = _ NUM ; item < item Count ; item ++ ) { double x = dataset . get XValue ( series , item ) ; if ( !  Double . is Na N ( x ) ) { minimum =  Math . min ( minimum , x ) ; maximum =  Math . max ( maximum , x ) ; } } } } if ( minimum ==  Double .  POSITIVE_ INFINITY ) { return null ; } else { return new  Range ( minimum , maximum ) ; } }
public  Liberty Manager Client ( ) { }
private void check Compliance Attributes (  Attr Set attr Set , boolean ignore Compliance ) throws  AMException { if ( ! ignore Compliance &&  Compliance Services Impl . is Compliance User Deletion Enabled ( ) ) { compliance Impl . verify Attributes ( attr Set ) ; } }
private void update Zoning Map (  Un Managed Export Mask mask ,  List <  Initiator > initiators ,  List <  Storage Port > storage Ports ) {  Zone Info Map zoning Map = network Device Controller . get Initiators Zone Info Map ( initiators , storage Ports ) ; for (  Zone Info zone Info : zoning Map . values ( ) ) { log . info ( _ STR , new  Object [ ] { zone Info . get Zone Name ( ) , zone Info . get Initiator Wwn ( ) , zone Info . get Port Wwn ( ) } ) ; } mask . set Zoning Map ( zoning Map ) ; }
public  Invitation Status wait Invitation Answer ( ) { return wait Invitation Answer ( m Ringing Period ) ; }
private boolean move Within Selected Range (  JTable table , int dx , int dy ,  List Selection Model rsm ,  List Selection Model csm ) { int total Count ; int min X , max X , min Y , max Y ; boolean rs = table . get Row Selection Allowed ( ) ; boolean cs = table . get Column Selection Allowed ( ) ; if ( rs && cs ) { total Count = table . get Selected Row Count ( ) * table . get Selected Column Count ( ) ; min X = csm . get Min Selection Index ( ) ; max X = csm . get Max Selection Index ( ) ; min Y = rsm . get Min Selection Index ( ) ; max Y = rsm . get Max Selection Index ( ) ; } else if ( rs ) { total Count = table . get Selected Row Count ( ) ; min X = _ NUM ; max X = table . get Column Count ( ) - _ NUM ; min Y = rsm . get Min Selection Index ( ) ; max Y = rsm . get Max Selection Index ( ) ; } else if ( cs ) { total Count = table . get Selected Column Count ( ) ; min X = csm . get Min Selection Index ( ) ; max X = csm . get Max Selection Index ( ) ; min Y = _ NUM ; max Y = table . get Row Count ( ) - _ NUM ; } else { total Count = _ NUM ; min X = max X = min Y = max Y = _ NUM ; } boolean stay In Selection ; if ( total Count == _ NUM || ( total Count == _ NUM && table . is Cell Selected ( lead Row , lead Column ) ) ) { stay In Selection = _ BOOL ; max X = table . get Column Count ( ) - _ NUM ; max Y = table . get Row Count ( ) - _ NUM ; min X =  Math . min ( _ NUM , max X ) ; min Y =  Math . min ( _ NUM , max Y ) ; } else { stay In Selection = _ BOOL ; } if ( dy == _ NUM && lead Column == - _ NUM ) { lead Column = min X ; lead Row = - _ NUM ; } else if ( dx == _ NUM && lead Row == - _ NUM ) { lead Row = min Y ; lead Column = - _ NUM ; } else if ( dy == - _ NUM && lead Column == - _ NUM ) { lead Column = max X ; lead Row = max Y + _ NUM ; } else if ( dx == - _ NUM && lead Row == - _ NUM ) { lead Row = max Y ; lead Column = max X + _ NUM ; } lead Row =  Math . min (  Math . max ( lead Row , min Y - _ NUM ) , max Y + _ NUM ) ; lead Column =  Math . min (  Math . max ( lead Column , min X - _ NUM ) , max X + _ NUM ) ; do { calc Next Pos ( dx , min X , max X , dy , min Y , max Y ) ; } while ( stay In Selection && ! table . is Cell Selected ( lead Row , lead Column ) ) ; return stay In Selection ; }
private double [ ] [ ] x Prime ( int t ) { double [ ] [ ] x = new double [ _ NUM ] [ get Num Lags ( ) * num Vars ] ; for ( int i = _ NUM ; i < get Num Lags ( ) ; i ++ ) { double [ ] [ ] y Prime = y Prime ( t - i - _ NUM ) ;  System . arraycopy ( y Prime [ _ NUM ] , _ NUM , x [ _ NUM ] , i * num Vars , num Vars ) ; } return x ; }
private void read Binary ( final  Little Endian Data Input Stream dis ) throws  IOException {  Raj Log . i ( _ STR ) ; dis . skip ( _ NUM ) ; int facet Count = dis . read Int ( ) ; float [ ] vertices Arr = new float [ facet Count * _ NUM ] ; float [ ] normals Arr = new float [ facet Count * _ NUM ] ; int [ ] indices Arr = new int [ facet Count * _ NUM ] ; float [ ] temp Norms = new float [ _ NUM ] ; int vert Pos = _ NUM , norm Pos = _ NUM ; for ( int i = _ NUM ; i < indices Arr . length ; i ++ ) indices Arr [ i ] = i ; while ( dis . available ( ) > _ NUM ) { for ( int j = _ NUM ; j < _ NUM ; j ++ ) { temp Norms [ j ] = dis . read Float ( ) ; if (  Float . is Na N ( temp Norms [ j ] ) ||  Float . is Infinite ( temp Norms [ j ] ) ) {  Raj Log . w ( _ STR ) ; temp Norms [ _ NUM ] = _ NUM ; temp Norms [ _ NUM ] = _ NUM ; temp Norms [ _ NUM ] = _ NUM ; break ; } } for ( int j = _ NUM ; j < _ NUM ; j ++ ) { normals Arr [ norm Pos ++ ] = temp Norms [ _ NUM ] ; normals Arr [ norm Pos ++ ] = temp Norms [ _ NUM ] ; normals Arr [ norm Pos ++ ] = temp Norms [ _ NUM ] ; } for ( int j = _ NUM ; j < _ NUM ; j ++ ) vertices Arr [ vert Pos ++ ] = dis . read Float ( ) ; dis . skip ( _ NUM ) ; } m Root Object . set Data ( vertices Arr , normals Arr , null , null , indices Arr , _ BOOL ) ; }
public void omit Less Freq ( ) { if ( name == null ) return ; int threshold = n_words [ _ NUM ] /  LESS_ FREQ_ RATIO ; if ( threshold <  MINIMUM_ FREQ ) threshold =  MINIMUM_ FREQ ;  Set <  String > keys = freq . key Set ( ) ; int roman = _ NUM ; for (  Iterator <  String > i = keys . iterator ( ) ; i . has Next ( ) ; ) {  String key = i . next ( ) ; int count = freq . get ( key ) ; if ( count <= threshold ) { n_words [ key . length ( ) - _ NUM ] -= count ; i . remove ( ) ; } else { if ( key . matches ( _ STR ) ) { roman += count ; } } } if ( roman < n_words [ _ NUM ] / _ NUM ) {  Set <  String > keys2 = freq . key Set ( ) ; for (  Iterator <  String > i = keys2 . iterator ( ) ; i . has Next ( ) ; ) {  String key = i . next ( ) ; if ( key . matches ( _ STR ) ) { n_words [ key . length ( ) - _ NUM ] -= freq . get ( key ) ; i . remove ( ) ; } } } }
public static  Public Key Selector from String (  String type ) { if ( type != null ) { for (  Public Key Selector key Selector :  Public Key Selector . values ( ) ) { if ( type . equals Ignore Case ( key Selector . type ) ) { return key Selector ; } } } return null ; }
public static void describe Shape Detail (  Shape shape , double flattening ) {  Path Iterator pi2 = shape . get Path Iterator ( null ) ;  Flattening Path Iterator pi = new  Flattening Path Iterator ( pi2 , flattening ) ; double [ ] coords = new double [ _ NUM ] ; int point Count = _ NUM ;  Debug . output ( _ STR + flattening + _ STR ) ; while ( ! pi . is Done ( ) ) { int type = pi . current Segment ( coords ) ;  Debug . output ( _ STR + type + _ STR + ( point Count ++ ) + _ STR + coords [ _ NUM ] + _ STR + coords [ _ NUM ] ) ; pi . next ( ) ; }  Debug . output ( _ STR + point Count + _ STR ) ; }
protected static  String shorten Classname (  String nam , char c ) { final int lastdot = nam . last Index Of ( c ) ; if ( lastdot >= _ NUM ) { nam = nam . substring ( lastdot + _ NUM ) ; } return nam ; }
@  Override public void flip (  X11 Component Peer peer ,  Component target ,  Volatile Image x Back Buffer , int x1 , int y1 , int x2 , int y2 ,  Buffer Capabilities .  Flip Contents flip Action ) { if ( flip Action ==  Buffer Capabilities .  Flip Contents .  COPIED ) {  Surface Manager vsm =  Surface Manager . get Manager ( x Back Buffer ) ;  Surface Data sd = vsm . get Primary Surface Data ( ) ; if ( sd instanceof  GLXVSync Off Screen Surface Data ) {  GLXVSync Off Screen Surface Data vsd = (  GLXVSync Off Screen Surface Data ) sd ;  Surface Data bbsd = vsd . get Flip Surface ( ) ;  Graphics2 D bbg = new  Sun Graphics2 D ( bbsd ,  Color . black ,  Color . white , null ) ; try { bbg . draw Image ( x Back Buffer , _ NUM , _ NUM , null ) ; } finally { bbg . dispose ( ) ; } } else {  Graphics g = peer . get Graphics ( ) ; try { g . draw Image ( x Back Buffer , x1 , y1 , x2 , y2 , x1 , y1 , x2 , y2 , null ) ; } finally { g . dispose ( ) ; } return ; } } else if ( flip Action ==  Buffer Capabilities .  Flip Contents .  PRIOR ) { return ; }  OGLSurface Data . swap Buffers ( peer . get Content Window ( ) ) ; if ( flip Action ==  Buffer Capabilities .  Flip Contents .  BACKGROUND ) {  Graphics g = x Back Buffer . get Graphics ( ) ; try { g . set Color ( target . get Background ( ) ) ; g . fill Rect ( _ NUM , _ NUM , x Back Buffer . get Width ( ) , x Back Buffer . get Height ( ) ) ; } finally { g . dispose ( ) ; } } }
public boolean add Property (  Owl Property property ) { property . add Restriction ( this ) ; return properties . add ( property ) ; }
void on Moved ( ) { double diff =  System . current Time Millis ( ) - time Stamp ; time Stamp = _ NUM ; if ( diff >  DISCARD_ THRESHOLD ) { return ; } double recent Jitter = _ NUM ; double sum = _ NUM ; for ( int i = _ NUM ; i <  VECTOR_ LENGTH ; i ++ ) { double old = times [ i ] ; double avg = ( diff + old ) / _ NUM ; recent Jitter +=  Math . abs ( old - diff ) ; times [ i ] = avg ; diff = old ; sum += avg ; } recent Jitter /= _ NUM ; jitter = ( jitter + _ NUM *  Math . max ( jitter , recent Jitter ) + recent Jitter ) / _ NUM ; prediction =  TURN_ LENGTH / ( sum /  VECTOR_ LENGTH + jitter ) ;  Wt Window Manager wm =  Wt Window Manager . get Instance ( ) ; wm . set Property (  SPEED_ PROPERTY ,  Double . to String ( prediction ) ) ; wm . set Property (  JITTER_ PROPERTY ,  Double . to String ( jitter ) ) ; }
public  Service ID (  Data Input in ) throws  IOException { this . most Sig = in . read Long ( ) ; this . least Sig = in . read Long ( ) ; }
public void on Enter Element Consumed (  String uri ,  String local Name ,  String qname ,  Attributes atts ) throws  SAXException { att Stack . push ( current Atts = new  Attributes Impl ( atts ) ) ; ns Effective Stack . push ( new  Integer ( ns Effective Ptr ) ) ; ns Effective Ptr = namespaces . size ( ) ; }
protected int [ ] read Color Table ( final int ncolors ) { final int nbytes = _ NUM * ncolors ; int [ ] tab = null ; final byte [ ] c = new byte [ nbytes ] ; try { raw Data . get ( c ) ; tab = new int [ _ NUM ] ; int i = _ NUM ; int j = _ NUM ; while ( i < ncolors ) { final int r = ( c [ j ++ ] ) & _ NUM ; final int g = ( c [ j ++ ] ) & _ NUM ; final int b = ( c [ j ++ ] ) & _ NUM ; tab [ i ++ ] = _ NUM | ( r << _ NUM ) | ( g << _ NUM ) | b ; } } catch ( final  Buffer Underflow Exception e ) {  Log . w (  TAG , _ STR , e ) ; status =  STATUS_ FORMAT_ ERROR ; } return tab ; }
@  Sneaky Throws public void add Key To Keystore (  Key Store key Store ,  X509 Certificate cert ,  RSAPrivate Key private Key ,  String alias ,  String password ) {  Key Store .  Password Protection pass = new  Key Store .  Password Protection ( password . to Char Array ( ) ) ;  Certificate [ ] certificate Chain = { cert } ; key Store . set Entry ( alias , new  Key Store .  Private Key Entry ( private Key , certificate Chain ) , pass ) ; }
public boolean needs Reload (  File file ) { return f Files To Reoad . contains ( file ) ; }
protected int draw Legend (  Canvas canvas ,  Default Renderer renderer ,  String [ ] titles , int left , int right , int y , int width , int height , int legend Size ,  Paint paint , boolean calculate ) { float size = _ NUM ; if ( renderer . is Show Legend ( ) ) { float current X = left ; float current Y = y + height - legend Size + size ; paint . set Text Align (  Component .  LEFT ) ; paint . set Text Size ( renderer . get Legend Text Size ( ) ) ; int s Length =  Math . min ( titles . length , renderer . get Series Renderer Count ( ) ) ; for ( int i = _ NUM ; i < s Length ; i ++ ) {  Simple Series Renderer r = renderer . get Series Renderer At ( i ) ; final float line Size = get Legend Shape Width ( i ) ; if ( r . is Show Legend Item ( ) ) {  String text = titles [ i ] ; if ( titles . length == renderer . get Series Renderer Count ( ) ) { paint . set Color ( r . get Color ( ) ) ; } else { paint . set Color (  Color Util .  LTGRAY ) ; } float [ ] widths = new float [ text . length ( ) ] ; paint . get Text Widths ( text , widths ) ; float sum = _ NUM ; for ( float value : widths ) { sum += value ; } float extra Size = line Size + _ NUM + sum ; float current Width = current X + extra Size ; if ( i > _ NUM && get Exceed ( current Width , renderer , right , width ) ) { current X = left ; current Y += renderer . get Legend Text Size ( ) ; size += renderer . get Legend Text Size ( ) ; current Width = current X + extra Size ; } if ( get Exceed ( current Width , renderer , right , width ) ) { float max Width = right - current X - line Size - _ NUM ; if ( is Vertical ( renderer ) ) { max Width = width - current X - line Size - _ NUM ; } int nr = paint . break Text ( text , _ BOOL , max Width , widths ) ; text = text . substring ( _ NUM , nr ) + _ STR ; } if ( ! calculate ) { draw Legend Shape ( canvas , r , current X , current Y , i , paint ) ; draw String ( canvas , text , current X + line Size + _ NUM , current Y + _ NUM , paint ) ; } current X += extra Size ; } } } return  Math . round ( size + renderer . get Legend Text Size ( ) ) ; }
public  Put Repository Request source ( byte [ ] repository Definition ) { return source ( repository Definition , _ NUM , repository Definition . length ) ; }
private void disable Buttons ( ) { set Fire Enabled ( _ BOOL ) ; set Skip Enabled ( _ BOOL ) ; set Twist Enabled ( _ BOOL ) ; set Next Enabled ( _ BOOL ) ; but Done . set Enabled ( _ BOOL ) ; set Flip Arms Enabled ( _ BOOL ) ; set Fire Mode Enabled ( _ BOOL ) ; set Next Target Enabled ( _ BOOL ) ; }
public boolean is Additive Number (  String num ) { int n = num . length ( ) ; for ( int i = _ NUM ; i <= n / _ NUM ; i ++ ) { if ( num . char At ( _ NUM ) == _ STR && i > _ NUM ) { return _ BOOL ; }  Big Integer num1 = new  Big Integer ( num . substring ( _ NUM , i ) ) ; for ( int j = _ NUM ;  Math . max ( i , j ) <= n - i - j ; j ++ ) { if ( num . char At ( i ) == _ STR && j > _ NUM ) { break ; }  Big Integer num2 = new  Big Integer ( num . substring ( i , i + j ) ) ; if ( is Additive Number ( num1 , num2 , i + j , num ) ) { return _ BOOL ; } } } return _ BOOL ; }
@  Override public void write (  String str ) { int start = _ NUM ; while ( start < str . length ( ) ) { int end =  Math . min ( start +  MAX_ MESSAGE_ LENGTH , str . length ( ) ) ;  Log . i (  TAG , str . substring ( start , end ) ) ; start = end ; } }
private  Carbon Dictionary Sort Info create Column Sort Info (  Carbon Dictionary Sort Model [ ] dictionary Sort Models ) { int [ ] sort Index ; int [ ] sort Index Inverted ;  Arrays . sort ( dictionary Sort Models ) ; sort Index = new int [ dictionary Sort Models . length ] ; sort Index Inverted = new int [ dictionary Sort Models . length ] ; for ( int i = _ NUM ; i < dictionary Sort Models . length ; i ++ ) {  Carbon Dictionary Sort Model dictionary Sort Model = dictionary Sort Models [ i ] ; sort Index [ i ] = dictionary Sort Model . get Key ( ) ; sort Index Inverted [ dictionary Sort Model . get Key ( ) - _ NUM ] = i + _ NUM ; } dictionary Sort Models = null ;  List <  Integer > sort Index List = convert To List ( sort Index ) ;  List <  Integer > sort Index Inverted List = convert To List ( sort Index Inverted ) ; return new  Carbon Dictionary Sort Info ( sort Index List , sort Index Inverted List ) ; }
private void add Feature (  Json Node feature , int index ) {  Point Feature feat = null ; try { feat =  Point Feature . from Json Node ( feature ) ; } catch (  Empty Polygon Exception e ) {  LOG . warn ( _ STR ) ; return ; } catch (  Unsupported Geometry Exception e ) {  LOG . warn ( e . message ) ; return ; } if ( feat == null ) { return ; } add Feature ( feat , index ) ; }
public  Bit String ( final  String value ) { this ( value . length ( ) ) ; for ( int i = _ NUM ; i < value . length ( ) ; i ++ ) { if ( value . char At ( i ) == _ STR ) { set Bit ( value . length ( ) - ( i + _ NUM ) , _ BOOL ) ; } else if ( value . char At ( i ) != _ STR ) { throw new  Illegal Argument Exception ( _ STR + i ) ; } } }
public void sort (  Comparator <  Individual > comparator ) {  Collections . sort ( individuals , comparator ) ; }
public void write (  Writer writer ) throws  Exception { writer . write ( to String ( ) ) ; writer . flush ( ) ; }
public static boolean is Cglib Renamed Method (  Method renamed Method ) {  String name = renamed Method . get Name ( ) ; if ( name . starts With (  CGLIB_ RENAMED_ METHOD_ PREFIX ) ) { int i = name . length ( ) - _ NUM ; while ( i >= _ NUM &&  Character . is Digit ( name . char At ( i ) ) ) { i -- ; } return ( ( i >  CGLIB_ RENAMED_ METHOD_ PREFIX . length ( ) ) && ( i < name . length ( ) - _ NUM ) && ( name . char At ( i ) == _ STR ) ) ; } return _ BOOL ; }
public  PWReset Exception (  String bundle Name ,  String err Code ,  Object [ ] args ) { super ( bundle Name , err Code , args ) ; err List = new  Array List ( _ NUM ) ; err List . add ( get Message ( ) ) ; }
public static  String [ ] union Arrays (  String [ ] array1 ,  String [ ] array2 ) { if ( array1 == null ) { return array2 ; } if ( array2 == null ) { return array1 ; }  Set <  String > set = new  Linked Hash Set < > ( ) ; set . add All (  Arrays . as List ( array1 ) ) ; set . add All (  Arrays . as List ( array2 ) ) ; return set . to Array ( new  String [ set . size ( ) ] ) ; }
boolean is State Change (  XDecorated Peer window ,  XProperty Event e ) { if ( ! window . is Showing ( ) ) { state Log . finer ( _ STR ) ; return _ BOOL ; } int wm_state = window . get WMState ( ) ; if ( wm_state ==  XUtil Constants .  Withdrawn State ) { state Log . finer ( _ STR ) ; return _ BOOL ; } else { if ( state Log . is Loggable (  Platform Logger .  Level .  FINER ) ) { state Log . finer ( _ STR + wm_state ) ; } } boolean is_state_change = _ BOOL ; if ( e . get_atom ( ) ==  XA_ WM_ STATE . get Atom ( ) ) { is_state_change = _ BOOL ; } for (  XState Protocol proto : get Protocols (  XState Protocol . class ) ) { is_state_change |= proto . is State Change ( e ) ; if ( state Log . is Loggable (  Platform Logger .  Level .  FINEST ) ) { state Log . finest ( proto + _ STR + is_state_change ) ; } } return is_state_change ; }
@  Override public  XObject execute (  XPath Context xctxt ) throws javax . xml . transform .  Transformer Exception {  Node xpath Owner Node = (  Node ) xctxt . get Owner Object ( ) ; if ( xpath Owner Node == null ) { return null ; } int xpath Owner Node DTM = xctxt . get DTMHandle From Node ( xpath Owner Node ) ; int current Node = xctxt . get Current Node ( ) ;  DTM dtm = xctxt . get DTM ( current Node ) ; int doc Context = dtm . get Document ( ) ; if (  DTM .  NULL == doc Context ) { error ( xctxt ,  XPATHError Resources .  ER_ CONTEXT_ HAS_ NO_ OWNERDOC , null ) ; } {  Document current Doc =  XMLUtils . get Owner Document ( dtm . get Node ( current Node ) ) ;  Document xpath Owner Doc =  XMLUtils . get Owner Document ( xpath Owner Node ) ; if ( current Doc != xpath Owner Doc ) { throw new  Transformer Exception (  I18n . translate ( _ STR ) ) ; } }  XNode Set nodes = new  XNode Set ( xctxt . get DTMManager ( ) ) ;  Node Set DTM node Set = nodes . mutable Nodeset ( ) ; { int here Node =  DTM .  NULL ; switch ( dtm . get Node Type ( xpath Owner Node DTM ) ) { case  Node .  ATTRIBUTE_ NODE : case  Node .  PROCESSING_ INSTRUCTION_ NODE : { here Node = xpath Owner Node DTM ; node Set . add Node ( here Node ) ; break ; } case  Node .  TEXT_ NODE : { here Node = dtm . get Parent ( xpath Owner Node DTM ) ; node Set . add Node ( here Node ) ; break ; } default : break ; } } node Set . detach ( ) ; return nodes ; }
public  List <  Local Time > top ( int n ) {  List <  Local Time > top = new  Array List < > ( ) ; int [ ] values = data . to Int Array ( ) ;  Int Arrays . parallel Quick Sort ( values ,  Reverse Int Comparator . instance ( ) ) ; for ( int i = _ NUM ; i < n && i < values . length ; i ++ ) { top . add (  Packed Local Time . as Local Time ( values [ i ] ) ) ; } return top ; }
public static  String grab Class (  String signature ) {  Matcher matcher = sig RE . matcher ( signature ) ; boolean b = matcher . matches ( ) ; if ( ! b && matcher . group Count ( ) != _ NUM ) logger . error ( _ STR , signature ) ; return matcher . group ( _ NUM ) ; }
public  Time Series Metric Delta Set (  Stream <  Entry <  Tags ,  Metric Value > > td ) { values_ =  Any2 . right ( td . collect (  Collectors . to Map ( null , null , null , null ) ) ) ; }
@  Override public final  E next Element ( ) {  E result = m_ Vector . get ( m_ Counter ) ; m_ Counter ++ ; if ( m_ Counter == m_ Special Element ) { m_ Counter ++ ; } return result ; }
private  Byte String escape Bytes ( final  Byte String value ) { if ( ! need Escaping ( value ) ) { return value ; } final  Byte String Builder builder = new  Byte String Builder ( ) ; for ( int i = _ NUM ; i < value . length ( ) ; i ++ ) { final byte b = value . byte At ( i ) ; if ( is Byte To Escape ( b ) ) { builder . append Byte (  DN .  NORMALIZED_ ESC_ BYTE ) ; } builder . append Byte ( b ) ; } return builder . to Byte String ( ) ; }
public  Input Builder <  T > repeat All ( int times ) {  List <  T > to Append = new  Array List < > ( ) ; for ( int i = _ NUM ; i < times ; i ++ ) { to Append . add All ( input ) ; } input . add All ( to Append ) ; return this ; }
@  Suppress Warnings ( _ STR ) public void handle Button3 Request (  Request Invocation Event event ) { back Trail ( ) ; try {  String name = (  String ) get Page Session Attribute (  SAVE_ VB_ NAME ) ;  View Bean vb = get View Bean (  Class . for Name ( name ) ) ; pass Pg Session Map ( vb ) ; vb . forward To ( get Request Context ( ) ) ; } catch (  Class Not Found Exception e ) { debug . warning ( _ STR , e ) ; } }
public  Ion Exception (  Throwable cause ) { super ( cause . get Message ( ) , cause ) ; }
public final double distance ( ) { return  Math . sqrt ( distance_square ( ) ) ; }
@  Override public void done ( ) { super . done ( ) ; if ( m Num Tests Expected > m Num Tests Run ) { handle Test Run Failed (  String . format ( _ STR , m Num Tests Expected , m Num Tests Run ) ) ; } else if ( m Test Run In Progress ) { handle Test Run Failed ( _ STR ) ; } }
public  Mersenne Twister ( ) { mt = new int [  N ] ; set Seed (  System . current Time Millis ( ) +  System . identity Hash Code ( this ) ) ; }
private void verify Timestamp (  X509 Certificate cert ) throws  Cert Path Validator Exception {  String msg = _ STR ; if ( debug != null ) debug . println ( _ STR + msg + _ STR + date . to String ( ) + _ STR ) ; try { cert . check Validity ( date ) ; } catch (  Certificate Expired Exception e ) { throw new  Cert Path Validator Exception ( msg + _ STR , e , null , - _ NUM ,  Basic Reason .  EXPIRED ) ; } catch (  Certificate Not Yet Valid Exception e ) { throw new  Cert Path Validator Exception ( msg + _ STR , e , null , - _ NUM ,  Basic Reason .  NOT_ YET_ VALID ) ; } if ( debug != null ) debug . println ( msg + _ STR ) ; }
public static byte [ ] encrypt Password ( final  String password , final byte [ ] seed ) throws  No Such Algorithm Exception { if ( password == null || password . equals ( _ STR ) ) { return new byte [ _ NUM ] ; } final  Message Digest message Digest =  Message Digest . get Instance ( _ STR ) ; final byte [ ] stage1 = message Digest . digest ( password . get Bytes ( ) ) ; message Digest . reset ( ) ; final byte [ ] stage2 = message Digest . digest ( stage1 ) ; message Digest . reset ( ) ; message Digest . update ( seed ) ; message Digest . update ( stage2 ) ; final byte [ ] digest = message Digest . digest ( ) ; final byte [ ] return Bytes = new byte [ digest . length ] ; for ( int i = _ NUM ; i < digest . length ; i ++ ) { return Bytes [ i ] = ( byte ) ( stage1 [ i ] ^ digest [ i ] ) ; } return return Bytes ; }
public int rows ( ) { return rows ; }
public static  String array2hex ( final byte [ ] array ) { return byte Array2 String ( array , _ STR , _ STR , _ BOOL , _ NUM ) ; }
private byte [ ] write Checked Bytes (  Message Nano proto ) {  Backup Protos .  Checked Message wrapper = new  Backup Protos .  Checked Message ( ) ; wrapper . payload =  Message Nano . to Byte Array ( proto ) ;  CRC32 checksum = new  CRC32 ( ) ; checksum . update ( wrapper . payload ) ; wrapper . checksum = checksum . get Value ( ) ; return  Message Nano . to Byte Array ( wrapper ) ; }
public double reduce To ( int width , int height , double limit ) { int w = get Icon Width ( ) ; int h = get Icon Height ( ) ; double scale = _ NUM ; if ( w > width ) { scale = ( ( double ) width ) / w ; } if ( h > height ) { scale =  Math . min ( scale , ( ( double ) height ) / h ) ; } if ( scale < _ NUM ) { if ( limit > _ NUM ) { scale =  Math . max ( scale , limit ) ; }  Affine Transform t =  Affine Transform . get Scale Instance ( scale , scale ) ; transform Image ( ( int )  Math . ceil ( scale * w ) , ( int )  Math . ceil ( scale * h ) , t , null ) ; } return scale ; }
public void install Builtin Sound (  String sound Identifier ,  Input Stream data ) throws  IOException { builtin Sounds . put ( sound Identifier , convert Builtin Sound ( data ) ) ; }
private  Integer count Fragment Filtered Pages (  List <  String > template Fragments , boolean whitelist ) throws  Wiki Api Exception { try { int count = _ NUM ;  Prepared Statement statement = null ;  Result Set result = null ; try {  String Buffer sql String = new  String Buffer ( ) ;  String Buffer subconditions = new  String Buffer ( ) ; sql String . append ( _ STR +  Generator Constants .  TABLE_ TPLID_ TPLNAME + _ STR +  Generator Constants .  TABLE_ TPLID_ PAGEID + _ STR + ( whitelist ? _ STR : _ STR ) + _ STR ) ; for ( @  Suppress Warnings ( _ STR )  String fragment : template Fragments ) { if ( subconditions . length ( ) != _ NUM ) { subconditions . append ( _ STR ) ; } subconditions . append ( _ STR ) ; } sql String . append ( subconditions ) ; sql String . append ( _ STR ) ; statement = connection . prepare Statement ( sql String . to String ( ) ) ; int cur Idx = _ NUM ; for (  String fragment : template Fragments ) { fragment = fragment . to Lower Case ( ) ; fragment = fragment . trim ( ) ; fragment = fragment . replace All ( _ STR , _ STR ) ; statement . set String ( cur Idx ++ , fragment + _ STR ) ; } result = execute ( statement ) ; if ( result == null ) { return _ NUM ; } if ( result . next ( ) ) { count = result . get Int ( _ NUM ) ; } } finally { if ( statement != null ) { statement . close ( ) ; } if ( result != null ) { result . close ( ) ; } } return count ; } catch (  Exception e ) { throw new  Wiki Api Exception ( e ) ; } }
public static int find Name (  String name , int [ ] table ) { for ( int i = _ NUM ; i < table . length ; i ++ ) { if ( name . equals ( get Name ( table [ i ] ) ) ) { return i ; } } return - _ NUM ; }
private static  Bitmap transform (  Matrix scaler ,  Bitmap source , int target Width , int target Height , int options ) {  Log . i (  TAG , _ STR ) ; boolean scale Up = ( options & _ NUM ) != _ NUM ; boolean recycle = ( options & _ NUM ) != _ NUM ; int delta X = source . get Width ( ) - target Width ; int delta Y = source . get Height ( ) - target Height ; if ( ! scale Up && ( delta X < _ NUM || delta Y < _ NUM ) ) {  Log . i (  TAG , _ STR ) ;  Bitmap b2 =  Bitmap . create Bitmap ( target Width , target Height ,  Bitmap .  Config .  ARGB_8888 ) ;  Canvas c = new  Canvas ( b2 ) ; int delta XHalf =  Math . max ( _ NUM , delta X / _ NUM ) ; int delta YHalf =  Math . max ( _ NUM , delta Y / _ NUM ) ;  Rect src = new  Rect ( delta XHalf , delta YHalf , delta XHalf +  Math . min ( target Width , source . get Width ( ) ) , delta YHalf +  Math . min ( target Height , source . get Height ( ) ) ) ; int dst X = ( target Width - src . width ( ) ) / _ NUM ; int dst Y = ( target Height - src . height ( ) ) / _ NUM ;  Rect dst = new  Rect ( dst X , dst Y , target Width - dst X , target Height - dst Y ) ; c . draw Bitmap ( source , src , dst , null ) ; if ( recycle ) { source . recycle ( ) ; } c . set Bitmap ( null ) ;  Log . i (  TAG , _ STR ) ; return b2 ; } float bitmap Width F = source . get Width ( ) ; float bitmap Height F = source . get Height ( ) ;  Log . i (  TAG , _ STR + bitmap Width F + _ STR + bitmap Height F ) ; float bitmap Aspect = bitmap Width F / bitmap Height F ; float view Aspect = ( float ) target Width / target Height ;  Log . i (  TAG , _ STR + target Width + _ STR + target Height ) ; if ( bitmap Aspect > view Aspect ) { float scale = target Height / bitmap Height F ; if ( scale < _ NUM || scale > _ NUM ) { scaler . set Scale ( scale , scale ) ; } else { scaler = null ; } } else { float scale = target Width / bitmap Width F ; if ( scale < _ NUM || scale > _ NUM ) { scaler . set Scale ( scale , scale ) ; } else { scaler = null ; } }  Bitmap b1 ; if ( scaler != null ) {  Log . i (  TAG , _ STR ) ; b1 =  Bitmap . create Bitmap ( source , _ NUM , _ NUM , source . get Width ( ) , source . get Height ( ) , scaler , _ BOOL ) ; } else {  Log . i (  TAG , _ STR ) ; b1 = source ; } if ( recycle && b1 != source ) {  Log . i (  TAG , _ STR ) ; source . recycle ( ) ; } int dx1 =  Math . max ( _ NUM , b1 . get Width ( ) - target Width ) ; int dy1 =  Math . max ( _ NUM , b1 . get Height ( ) - target Height ) ;  Bitmap b2 =  Bitmap . create Bitmap ( b1 , dx1 / _ NUM , dy1 / _ NUM , target Width , target Height ) ; if ( b2 != b1 ) { if ( recycle || b1 != source ) {  Log . i (  TAG , _ STR ) ; b1 . recycle ( ) ; } }  Log . i (  TAG , _ STR ) ; if ( b2 == null ) {  Log . i (  TAG , _ STR ) ; } return b2 ; }
private void score Track Results (  Collection <  Track > tracks ,  Search Query query ,  Collection <  Scored Result > output ) { for (  Track track : tracks ) { double score = score Track Result ( query , track ) ; output . add ( new  Scored Result ( track , score ) ) ; } }
private  Long current Time ( ) { return  System . current Time Millis ( ) / _ NUM ; }
private static byte [ ] encode ( double latitude , double longitude ) { byte [ ] bytes = new byte [ _ NUM *  Integer .  BYTES ] ;  Numeric Utils . int To Sortable Bytes ( encode Latitude ( latitude ) , bytes , _ NUM ) ;  Numeric Utils . int To Sortable Bytes ( encode Longitude ( longitude ) , bytes ,  Integer .  BYTES ) ; return bytes ; }
public static void put Long Volatile (  Object obj , long off , long val ) {  UNSAFE . put Long Volatile ( obj , off , val ) ; }
public void circle ( double x , double y , double r ) { if ( r < _ NUM ) throw new  Illegal Argument Exception ( _ STR ) ; double xs = scale X ( x ) ; double ys = scale Y ( y ) ; double ws = factor X ( _ NUM * r ) ; double hs = factor Y ( _ NUM * r ) ; if ( ws <= _ NUM && hs <= _ NUM ) pixel ( x , y ) ; else offscreen . draw ( new  Ellipse2 D .  Double ( xs - ws / _ NUM , ys - hs / _ NUM , ws , hs ) ) ; draw ( ) ; }
final public void println ( double v ) {  Writer out = this . out ; if ( out == null ) return ; print ( v ) ; try { out . write ( _newline , _ NUM , _newline . length ) ; } catch (  IOException e ) { log . log (  Level .  FINE , e . to String ( ) , e ) ; } }
public void write SI32 ( int value ) throws  IOException { flush Bits ( ) ; out . write ( value & _ NUM ) ; out . write ( value > > _ NUM ) ; out . write ( value > > _ NUM ) ; out . write ( value > > _ NUM ) ; bytes Written += _ NUM ; }
private static void map ( final  String Builder buffer , final  Byte Sequence sequence , final boolean trim , final boolean fold Case ) { final  String value = sequence . to String ( ) ; for ( int i = _ NUM ; i < value . length ( ) ; i ++ ) { final char c = value . char At ( i ) ; if (  MAP_2_ NULL . contains ( c ) ) { continue ; } if (  MAP_2_ SPACE . contains ( c ) ) { if ( can Map To Space ( buffer , trim ) ) { buffer . append (  SPACE_ CHAR ) ; } continue ; } if ( fold Case ) { final  String mapping =  CASE_ MAP_ TABLE . get ( c ) ; if ( mapping != null ) { buffer . append ( mapping ) ; continue ; } } buffer . append ( c ) ; } }
public void add Button Pressed Listener (  Field Config String Button Interface listener ) { if ( button Pressed Listener List == null ) { button Pressed Listener List = new  Array List <  Field Config String Button Interface > ( ) ; } button Pressed Listener List . add ( listener ) ; }
private void fill XMLAttribute (  Attributes att , int index ) { fill QName ( f Attribute QName , att . get URI ( index ) , att . get Local Name ( index ) , att . get QName ( index ) ) ;  String type = att . get Type ( index ) ; f Attributes . add Attribute NS ( f Attribute QName , ( type != null ) ? type :  XMLSymbols . f CDATASymbol , att . get Value ( index ) ) ; }
public  JComponent create Property GUI (  Property Consumer pc ) { this . property Consumer = pc ;  Properties props = new  Properties ( ) ; props = pc . get Properties ( props ) ;  Properties info = new  Properties ( ) ; info = pc . get Property Info ( info ) ;  String prefix = pc . get Property Prefix ( ) ; return create Property GUI ( prefix , props , info ) ; }
public long copy (  String filename ,  Output Stream out , long offset , long size ) throws  IOException ,  Interrupted Exception { if ( size < _ NUM ) { return _ NUM ; }  Buffered Input Stream is = new  Buffered Input Stream ( get File Input Stream ( filename ) ) ; byte [ ] buf = new byte [ _ NUM * _ NUM ] ; int bytes Read ; long pos = _ NUM ; long remaining = size ; try { if ( offset != _ NUM ) { is . skip ( offset ) ; pos += offset ; } while ( remaining != _ NUM ) { int max = buf . length ; if ( max > remaining ) { max = ( int ) remaining ; } bytes Read = is . read ( buf , _ NUM , max ) ; if ( bytes Read == - _ NUM ) { break ; } out . write ( buf , _ NUM , bytes Read ) ; pos += bytes Read ; remaining -= bytes Read ; } out . flush ( ) ; } catch (  Exception e ) { out . flush ( ) ; } finally { try { is . close ( ) ; } catch (  Exception e ) { } } return pos ; }
private static void deserialize Header (  Kdb Header kdb Header ,  Data Input data Input ) throws  IOException { kdb Header . set Flags ( data Input . read Int ( ) ) ; kdb Header . set Version ( data Input . read Int ( ) ) ; byte [ ] buffer = new byte [ _ NUM ] ; data Input . read Fully ( buffer ) ; kdb Header . set Master Seed ( buffer ) ; buffer = new byte [ _ NUM ] ; data Input . read Fully ( buffer ) ; kdb Header . set Encryption Iv ( buffer ) ; kdb Header . set Group Count ( data Input . read Int ( ) ) ; kdb Header . set Entry Count ( data Input . read Int ( ) ) ; byte [ ] buffer32 = new byte [ _ NUM ] ; data Input . read Fully ( buffer32 ) ; kdb Header . set Content Hash ( buffer32 ) ; buffer32 = new byte [ _ NUM ] ; data Input . read Fully ( buffer32 ) ; kdb Header . set Transform Seed ( buffer32 ) ; kdb Header . set Transform Rounds ( data Input . read Int ( ) ) ; }
public  List <  JCAnnotation > transform Annotations (  Output Element target ,  Tree .  Declaration annotated ) {  Enum Set <  Output Element > outputs ; if ( annotated instanceof  Tree .  Any Class ) { outputs =  Annotation Util . outputs ( (  Tree .  Any Class ) annotated ) ; } else if ( annotated instanceof  Tree .  Any Interface ) { outputs =  Annotation Util . outputs ( (  Tree .  Any Interface ) annotated ) ; } else if ( annotated instanceof  Tree .  Type Alias Declaration ) { outputs =  Annotation Util . outputs ( (  Tree .  Type Alias Declaration ) annotated ) ; } else if ( annotated instanceof  Tree .  Constructor ) { outputs =  Annotation Util . outputs ( (  Tree .  Constructor ) annotated ) ; } else if ( annotated instanceof  Tree .  Enumerated ) { outputs =  Annotation Util . outputs ( (  Tree .  Enumerated ) annotated ) ; } else if ( annotated instanceof  Tree .  Any Method ) { outputs =  Annotation Util . outputs ( (  Tree .  Any Method ) annotated ) ; } else if ( annotated instanceof  Tree .  Attribute Declaration ) { outputs =  Annotation Util . outputs ( (  Tree .  Attribute Declaration ) annotated ) ; } else if ( annotated instanceof  Tree .  Attribute Getter Definition ) { outputs =  Annotation Util . outputs ( (  Tree .  Attribute Getter Definition ) annotated ) ; } else if ( annotated instanceof  Tree .  Attribute Setter Definition ) { outputs =  Annotation Util . outputs ( (  Tree .  Attribute Setter Definition ) annotated ) ; } else if ( annotated instanceof  Tree .  Object Definition ) { outputs =  Annotation Util . outputs ( (  Tree .  Object Definition ) annotated ) ; } else { throw  Bug Exception . unhandled Node Case ( annotated ) ; } return transform ( annotated . get Declaration Model ( ) , target , annotated . get Annotation List ( ) , outputs ) ; }
public boolean are All Permissions Granted ( ) { return denied Permission Responses . is Empty ( ) ; }
private  String fetch Charset From Cache (  Client client ,  Locale loc ) {  Map c Cache = (  Map ) charset Cache . get ( client . get Client Type ( ) ) ;  String val = null ; if ( c Cache != null ) { val = (  String ) c Cache . get ( loc ) ; } return val ; }
public void add Control Roll (  Piloting Roll Data control ) { control Rolls . add Element ( control ) ; }
void process Add On Changes (  Window caller ,  Add On Dependency Checker .  Add On Changes Result changes ) { if ( addons Dialog != null ) { addons Dialog . set Downloading Updates ( ) ; } if ( get View ( ) != null ) {  Set <  Add On > add Ons = new  Hash Set < > ( changes . get Uninstalls ( ) ) ; add Ons . add All ( changes . get Old Versions ( ) ) ;  Set <  Extension > extensions = new  Hash Set < > ( ) ; extensions . add All ( changes . get Unload Extensions ( ) ) ; extensions . add All ( changes . get Soft Unload Extensions ( ) ) ; if ( ! warn Unsaved Resources Or Active Actions ( caller , add Ons , extensions , _ BOOL ) ) { return ; } } uninstall Add Ons ( caller , changes . get Uninstalls ( ) , _ BOOL ) ;  Set <  Add On > all Addons = new  Hash Set < > ( changes . get New Versions ( ) ) ; all Addons . add All ( changes . get Installs ( ) ) ; for (  Add On add On : all Addons ) { if ( addons Dialog != null ) { addons Dialog . notify Add On Downloading ( add On ) ; } download Add On ( add On ) ; } }
public void rederive Color ( ) {  Color src =  UIManager . get Color ( ui Default Parent Name ) ; if ( src != null ) { float [ ] tmp =  Color .  RGBto HSB ( src . get Red ( ) , src . get Green ( ) , src . get Blue ( ) , null ) ; tmp [ _ NUM ] = clamp ( tmp [ _ NUM ] + h Offset ) ; tmp [ _ NUM ] = clamp ( tmp [ _ NUM ] + s Offset ) ; tmp [ _ NUM ] = clamp ( tmp [ _ NUM ] + b Offset ) ; int alpha = clamp ( src . get Alpha ( ) + a Offset ) ; argb Value = (  Color .  HSBto RGB ( tmp [ _ NUM ] , tmp [ _ NUM ] , tmp [ _ NUM ] ) & _ NUM ) | ( alpha << _ NUM ) ; } else { float [ ] tmp = new float [ _ NUM ] ; tmp [ _ NUM ] = clamp ( h Offset ) ; tmp [ _ NUM ] = clamp ( s Offset ) ; tmp [ _ NUM ] = clamp ( b Offset ) ; int alpha = clamp ( a Offset ) ; argb Value = (  Color .  HSBto RGB ( tmp [ _ NUM ] , tmp [ _ NUM ] , tmp [ _ NUM ] ) & _ NUM ) | ( alpha << _ NUM ) ; } }
public void on Idle Begin ( ) { _idle Count . increment And Get ( ) ; }
private void add Span (  Cache Span span ) {  Tree Set <  Cache Span > spans For Key = cached Spans . get ( span . key ) ; if ( spans For Key == null ) { spans For Key = new  Tree Set <  Cache Span > ( ) ; cached Spans . put ( span . key , spans For Key ) ; } spans For Key . add ( span ) ; total Space += span . length ; notify Span Added ( span ) ; }
public boolean equals (  Object obj ) { if ( this == obj ) { return _ BOOL ; } if ( ! ( obj instanceof  URIName ) ) { return _ BOOL ; }  URIName other = (  URIName ) obj ; return uri . equals ( other . get URI ( ) ) ; }
void repaint Children ( ) { for (  Component child : panel . get Components ( ) ) { child . repaint ( ) ; } }
private static  String read Comment (  String input , int index ) {  String comment = null ;  Matcher matcher =  COMMENT_ PATTERN . matcher ( input . substring ( index ) ) ; if ( matcher . find ( ) ) { comment = matcher . group ( _ NUM ) ; comment = comment . substring ( _ NUM ) ; } return comment ; }
public static int find Next (  String str , char separator , char escape Char , int start ,  String Builder split ) { int num Pre Escapes = _ NUM ; for ( int i = start ; i < str . length ( ) ; i ++ ) { char cur Char = str . char At ( i ) ; if ( num Pre Escapes == _ NUM && cur Char == separator ) { return i ; } else { split . append ( cur Char ) ; num Pre Escapes = ( cur Char == escape Char ) ? ( ++ num Pre Escapes ) % _ NUM : _ NUM ; } } return - _ NUM ; }
private static  String guess Content Type (  String url ) { url = url . to Lower Case ( ) ; if ( url . ends With ( _ STR ) ) { return _ STR ; } else if ( url . ends With ( _ STR ) ) { return _ STR ; } else if ( url . matches ( _ STR ) ) { return _ STR ; } else if ( url . ends With ( _ STR ) ) { return _ STR ; } else if ( url . ends With ( _ STR ) ) { return _ STR ; } else { return _ STR ; } }
public static  String extract CSVOutput Line Domain (  String csv Out ) {  String tokens [ ] = csv Out . split ( _ STR , - _ NUM ) ; return tokens [ _ NUM ] ; }
public void connect ( ) { connect ( this . log Writer ) ; }
public static boolean do Cache Header Validation ( final  Solr Query Request solr Req , final  Http Servlet Request req , final  Method req Method , final  Http Servlet Response resp ) { if (  Method .  POST == req Method ||  Method .  OTHER == req Method ) { return _ BOOL ; } final long last Mod =  Http Cache Header Util . calc Last Modified ( solr Req ) ; final  String etag =  Http Cache Header Util . calc Etag ( solr Req ) ; resp . set Date Header ( _ STR , last Mod ) ; resp . set Header ( _ STR , etag ) ; if ( check ETag Validators ( req , resp , req Method , etag ) ) { return _ BOOL ; } if ( check Last Mod Validators ( req , resp , last Mod ) ) { return _ BOOL ; } return _ BOOL ; }
public  Ivr Zoneset show Active Ivr Zoneset ( ) throws  Network Device Controller Exception {  List <  Ivr Zoneset > zonesets = show Ivr Zonesets ( _ BOOL ) ; return zonesets . is Empty ( ) ? null : zonesets . get ( _ NUM ) ; }
@  Suppress Warnings ( _ STR ) public static <  K >  Immutable Array <  K > empty ( ) { return (  Immutable Array <  K > )  EMPTY ; }
public void replace Non Optional Non Minus Nodes With ( final  List <  IGroup Member Node > ordered , final boolean recompute Definitely Produced ) { non Optional Non Minus Nodes . clear ( ) ; non Optional Non Minus Nodes . add All ( ordered ) ; if ( recompute Definitely Produced ) { recompute Definitely Produced ( ) ; } }
public static  String to String (  Accountable a ) {  String Builder sb = new  String Builder ( ) ; to String ( sb , a , _ NUM ) ; return sb . to String ( ) ; }
@  Override public int hash Code ( ) { return type << _ NUM | value . hash Code ( ) << _ NUM | other Value . hash Code ( ) ; }
protected void delete Type Vertex (  Atlas Vertex instance Vertex ,  Data Types .  Type Category type Category , boolean force ) throws  Atlas Exception { switch ( type Category ) { case  STRUCT : case  TRAIT : delete Type Vertex ( instance Vertex , force ) ; break ; case  CLASS : delete Entities (  Collections . singleton List ( instance Vertex ) ) ; break ; default : throw new  Illegal State Exception ( _ STR + type Category + _ STR ) ; } }
public static  List <  String > read To List (  Reader r ) throws  IOException { try (  Buffered Reader in = new  Buffered Reader ( r ) ) {  List <  String > l = new  Array List < > ( ) ;  String line = null ; while ( ( line = in . read Line ( ) ) != null ) l . add ( line ) ; return  Collections . unmodifiable List ( l ) ; } }
@  Suppress Warnings ( _ STR ) public void add Cache Context (  Grid Cache Context cache Ctx ) throws  Ignite Checked Exception { if ( ctx Map . contains Key ( cache Ctx . cache Id ( ) ) ) {  Grid Cache Context <  K ,  V > existing = ctx Map . get ( cache Ctx . cache Id ( ) ) ; throw new  Ignite Checked Exception ( _ STR + _ STR + cache Ctx . name ( ) + _ STR + existing . name ( ) + _ STR ) ; }  Cache Store Manager mgr = cache Ctx . store ( ) ; if ( mgr . configured ( ) && mgr . is Local ( ) ) loc Store Cnt . increment And Get ( ) ; ctx Map . put ( cache Ctx . cache Id ( ) , cache Ctx ) ; }
protected static boolean is Cglib Get Callbacks (  Annotated Method am ) {  Class < ? > rt = am . get Raw Type ( ) ; if ( rt == null || ! rt . is Array ( ) ) { return _ BOOL ; }  Class < ? > comp Type = rt . get Component Type ( ) ;  Package pkg = comp Type . get Package ( ) ; if ( pkg != null ) {  String pname = pkg . get Name ( ) ; if ( pname . starts With ( _ STR ) || pname . starts With ( _ STR ) ) { return _ BOOL ; } } return _ BOOL ; }
public int compare To (  Named Media Type other ) { return _name . compare To ( other . _name ) ; }
public boolean is Modified ( ) { synchronized ( this ) { if ( _is Checking || _is Modified ) { return _is Modified ; } _is Checking = _ BOOL ; } try { long now ; now =  Current Time . current Time ( ) ; if ( now < _last Check Time + _check Interval ) return _is Modified ; _last Check Time = now ; for ( int i = _dependency List . size ( ) - _ NUM ; i >= _ NUM ; i -- ) {  Dependency dependency = _dependency List . get ( i ) ; if ( dependency . is Modified ( ) ) { dependency . log Modified ( log ( ) ) ; _is Modified = _ BOOL ; return _is Modified ; } } return _is Modified ; } finally { _is Checking = _ BOOL ; } }
protected  Replaced Element new Irreplaceable Image Element ( int css Width , int css Height ) {  Buffered Image missing Image ;  Replaced Element mre ; try { missing Image =  Image Util . create Compatible Buffered Image ( css Width , css Height ,  Buffered Image .  TYPE_ INT_ RGB ) ;  Graphics2 D g = missing Image . create Graphics ( ) ; g . set Color (  Color .  BLACK ) ; g . set Background (  Color .  WHITE ) ; g . set Font ( new  Font ( _ STR ,  Font .  PLAIN , _ NUM ) ) ; g . draw String ( _ STR , _ NUM , _ NUM ) ; g . dispose ( ) ; mre = new  Image Replaced Element ( missing Image , css Width , css Height ) ; } catch (  Exception e ) { mre = new  Empty Replaced Element ( css Width < _ NUM ? _ NUM : css Width , css Height < _ NUM ? _ NUM : css Height ) ; } return mre ; }
public boolean greater Than (  FXGVersion version ) { return ( compare To ( version ) > _ NUM ) ; }
@  Override public  Data Source create Data Source (  Properties properties ) throws  SQLException {  Properties properties Copy = new  Properties ( ) ; if ( properties != null ) { properties Copy . put All ( properties ) ; } reject Unsupported Options ( properties Copy ) ; reject Pooling Options ( properties Copy ) ;  Jdbc Data Source data Source = new  Jdbc Data Source ( ) ; setup H2 Data Source ( data Source , properties Copy ) ; return data Source ; }
public  Set <  String > find (  T object ) { if ( ! locations . contains Key ( object ) ) { locations . put ( object , new  Hash Set < > ( ) ) ; } return  Collections . unmodifiable Set ( locations . get ( object ) ) ; }
private void scroll Current Item To Center ( ) { final  View Item curr Item = m View Items [  BUFFER_ CENTER ] ; if ( curr Item == null ) { return ; } final int current View Center = curr Item . get Center X ( ) ; if ( m Controller . is Scrolling ( ) || m Is User Scrolling || is Current Item Centered ( ) ) {  Log . d (  TAG , _ STR + m Controller . is Scrolling ( ) ) ; return ; } int snap In Time = ( int ) (  SNAP_ IN_ CENTER_ TIME_ MS * ( ( float )  Math . abs ( m Center X - current View Center ) ) / m Draw Area . width ( ) ) ;  Log . d (  TAG , _ STR ) ; m Controller . scroll To Position ( current View Center , snap In Time , _ BOOL ) ; }
public void add Meta Object (  Meta Object object ) { for ( int k = _ NUM ; k <  Meta Objects . size ( ) ; ++ k ) { if (  Meta Objects . get ( k ) == null ) {  Meta Objects . set ( k , object ) ; return ; } }  Meta Objects . add ( object ) ; }
public boolean remove (  String word ) { return m_ Words . remove ( word ) ; }
public synchronized void add Recent Item (  T item ) { item = from String ( to String ( item ) ) ; if ( m_ Recent Items . size ( ) > _ NUM ) { if ( item . equals ( m_ Recent Items . get ( _ NUM ) ) ) return ; } m_ Recent Items . remove ( item ) ; m_ Recent Items . add ( _ NUM , item ) ; while ( m_ Recent Items . size ( ) > m_ Max Count ) m_ Recent Items . remove ( m_ Recent Items . size ( ) - _ NUM ) ; if ( m_ Ignore Changes ) return ; write Props ( ) ; update Menu ( ) ; notify Recent Item Listeners Of Add ( item ) ; }
public void test Invoke All2 ( ) throws  Interrupted Exception {  Executor Service e = new  Fork Join Pool ( _ NUM ) ;  Pool Cleaner cleaner = null ; try { cleaner = cleaner ( e ) ;  List <  Future <  String > > r = e . invoke All ( new  Array List <  Callable <  String > > ( ) ) ; assert True ( r . is Empty ( ) ) ; } finally { if ( cleaner != null ) { cleaner . close ( ) ; } } }
public void cfg Package (  Configuration Value cfgval ,  String name ,  String desc ) { packages . add ( new  Package Info ( name , desc ) ) ; package Names . add ( name ) ; }
@  Override public void close ( ) throws  IOException { input . close ( ) ; }
private void create Block Mirror Data (  String name , int num Block Mirrors ) throws  Exception {  Volume volume = new  Volume ( ) ;  URI volume URI =  URIUtil . create Id (  Volume . class ) ; test Volume URIs . add ( volume URI ) ; volume . set Id ( volume URI ) ; volume . set Label ( _ STR ) ;  URI cg Uri = create Block Consistency Group ( _ STR ) ; volume . set Consistency Group ( cg Uri ) ; _db Client . create Object ( volume ) ; for ( int i = _ NUM ; i <= num Block Mirrors ; i ++ ) {  Block Mirror block Mirror = new  Block Mirror ( ) ;  URI block Mirror URI =  URIUtil . create Id (  Block Mirror . class ) ; test Block Mirror URIs . add ( block Mirror URI ) ; block Mirror . set Id ( block Mirror URI ) ; block Mirror . set Label ( name + i ) ; block Mirror . set Consistency Group ( cg Uri ) ; _db Client . create Object ( block Mirror ) ; } }
@  Override public synchronized void start ( ) { if ( running ) { return ; }  LOGGER . info ( _ STR ) ; if ( endpoints . is Empty ( ) ) { int port = config . get Int (  Network Config .  Keys .  COAP_ PORT ) ;  LOGGER . log (  Level .  INFO , _ STR , port ) ; add Endpoint ( new  Coap Endpoint ( port , this . config ) ) ; } int started = _ NUM ; for (  Endpoint ep : endpoints ) { try { ep . start ( ) ; ++ started ; } catch (  IOException e ) {  LOGGER . log (  Level .  SEVERE , _ STR + ep . get Address ( ) + _ STR , e ) ; } } if ( started == _ NUM ) { throw new  Illegal State Exception ( _ STR ) ; } else { running = _ BOOL ; } }
public  Json Array add (  String value ) { values . add (  Json . value ( value ) ) ; return this ; }
public boolean retain All (  Abstract Float List other ) { if ( other . size ( ) == _ NUM ) { if ( size == _ NUM ) return _ BOOL ; set Size ( _ NUM ) ; return _ BOOL ; } int limit = other . size ( ) - _ NUM ; int j = _ NUM ; for ( int i = _ NUM ; i < size ; i ++ ) { if ( other . index Of From To ( get Quick ( i ) , _ NUM , limit ) >= _ NUM ) set Quick ( j ++ , get Quick ( i ) ) ; } boolean modified = ( j != size ) ; set Size ( j ) ; return modified ; }
protected void clear Result ( ) { md . clear Result ( ) ; localization Result . set Text ( _ STR ) ; }
public static <  T >  String to String (  Collection <  T > collection ) { if ( collection == null ) { return _ STR ; } if ( collection . is Empty ( ) ) { return _ STR ; }  String Builder buf = new  String Builder ( ) ;  String delimiter = _ STR ; for (  T t : collection ) { if ( t == null ) { continue ; } buf . append ( delimiter ) ; buf . append ( t ) ; delimiter = _ STR ; } return buf . to String ( ) ; }
public static float between ( float val , float min , float max ) { return  Math . max (  Math . min ( val , max ) , min ) ; }
public static  String Buffer replace String (  String Buffer buffer ,  String [ ] parameters ) { int place Holder Position = - _ NUM ;  String place Holder = null ; for ( int i = _ NUM ; i < parameters . length ; i ++ ) { if ( parameters [ i ] == null ) { break ; } place Holder = _ STR + ( i + _ NUM ) + _ STR ; place Holder Position = buffer . index Of ( place Holder ) ; if ( place Holder Position != - _ NUM ) { buffer . replace ( place Holder Position , place Holder Position + place Holder . length ( ) , parameters [ i ] ) ; } else { break ; } } return buffer ; }
private static int lookup Qual Selector (  XMPNode array Node ,  String qual Name ,  String qual Value , int alias Form ) throws  XMPException { if (  XML_ LANG . equals ( qual Name ) ) { qual Value =  Utils . normalize Lang Value ( qual Value ) ; int index =  XMPNode Utils . lookup Language Item ( array Node , qual Value ) ; if ( index < _ NUM && ( alias Form &  Alias Options .  PROP_ ARRAY_ ALT_ TEXT ) > _ NUM ) {  XMPNode lang Node = new  XMPNode (  ARRAY_ ITEM_ NAME , null ) ;  XMPNode xdefault = new  XMPNode (  XML_ LANG ,  X_ DEFAULT , null ) ; lang Node . add Qualifier ( xdefault ) ; array Node . add Child ( _ NUM , lang Node ) ; return _ NUM ; } else { return index ; } } else { for ( int index = _ NUM ; index < array Node . get Children Length ( ) ; index ++ ) {  XMPNode curr Item = array Node . get Child ( index ) ; for (  Iterator it = curr Item . iterate Qualifier ( ) ; it . has Next ( ) ; ) {  XMPNode qualifier = (  XMPNode ) it . next ( ) ; if ( qual Name . equals ( qualifier . get Name ( ) ) && qual Value . equals ( qualifier . get Value ( ) ) ) { return index ; } } } return - _ NUM ; } }
public boolean is Multiple Allowed (  String frame ID ) { return multiple Frames . contains ( frame ID ) ; }
public  String [ ] parse Configuration (  File xml File ) throws  SAXException ,  IOException {  Document document = builder . parse ( xml File ) ; return ( parse Configuration ( document ) ) ; }
private double empirical HSIC (  Tetrad Matrix  Ky ,  Tetrad Matrix  Kx ,  Tetrad Matrix  Kz , int m ) {  Tetrad Matrix  Kyx =  Ky . times (  Kx ) ;  Tetrad Matrix  Kyz =  Ky . times (  Kz ) ;  Tetrad Matrix  Kzx =  Kz . times (  Kx ) ;  Tetrad Matrix  Kzreg =  Kz . copy ( ) ; for ( int i = _ NUM ; i < m ; i ++ ) { double ent = (  Kzreg . get ( i , i ) + this . regularizer ) ;  Kzreg . set ( i , i , ent ) ; }  Tetrad Matrix  A =  Kzreg . inverse ( ) ;  Kzreg =  A . times (  A ) ;  Tetrad Matrix  Kyzzregzx = new  Tetrad Matrix ( m , m ) ;  A =  Kyz . times (  Kzreg ) ;  Kyzzregzx =  A . times (  Kzx ) ;  Tetrad Matrix  Kyzzregzxzzregz =  Kyzzregzx . copy ( ) ;  Kyzzregzxzzregz =  Kyzzregzx . times (  Kz ) ;  A =  Kyzzregzxzzregz . times (  Kzreg ) ;  Kyzzregzxzzregz =  A . times (  Kz ) ; double emp HSIC = _ NUM ; for ( int i = _ NUM ; i < m ; i ++ ) { emp HSIC +=  Kyx . get ( i , i ) ; emp HSIC += ( - _ NUM *  Kyzzregzx . get ( i , i ) ) ; emp HSIC +=  Kyzzregzxzzregz . get ( i , i ) ; } emp HSIC /=  Math . pow ( m - _ NUM , _ NUM ) ; double  Bz = _ NUM ; for ( int i = _ NUM ; i < ( m - _ NUM ) ; i ++ ) { for ( int j = ( i + _ NUM ) ; j < m ; j ++ ) {  Bz +=  Math . pow (  Kz . get ( i , j ) , _ NUM ) ;  Bz +=  Math . pow (  Kz . get ( j , i ) , _ NUM ) ; } }  Bz = ( m * ( m - _ NUM ) ) /  Bz ; emp HSIC *=  Bz ; return emp HSIC ; }
public void create (  String [ ] rpf File Paths ,  String output File ) throws  Make Toc Exception { create ( rpf File Paths , output File , _ BOOL ) ; }
private synchronized void post Event (  Event Info event Info ) { event Queue . add ( event Info ) ; notify All ( ) ; }
private void process Bmp Image (  Buffered Image image ) { if ( ! is Error ) {  File output File = new  File ( path , prefix + ( num Page + _ NUM ) + _ STR ) ; try {  Image IO . write ( image , _ STR , output File ) ; add Temp File ( output File ) ; add Scan File ( output File ) ; num Page ++ ; } catch (  IOException e ) { e . print Stack Trace ( ) ; end Process ( _ BOOL , _ BOOL ) ; } } }
public  Path Handler (  String path ) { this (  Paths . get ( path ) ) ; }
public boolean load Lines ( ) { boolean result = _ BOOL ; try { m_parser . parse ( new  Input Source ( m_reader ) , this ) ; result = _ BOOL ; m_success = _ BOOL ; } catch (  SAXException e ) { m_error Message = _ STR ; m_error Description = e . get Message ( ) ; } catch (  IOException e ) { m_error Message = _ STR ; m_error Description = e . get Message ( ) ; } return result ; }
private void load Ignore File ( final  String src Folder ) { ignore File =  Ignore File . load ( src Folder ) ; if ( ignore File == null ) { load Default Exclude Pattern ( src Folder ) ; } }
public boolean remove Arg ( final  BOp arg ) { if ( arg == null ) throw new  Illegal Argument Exception ( ) ; if ( arg == this ) throw new  Illegal Argument Exception ( ) ; if ( args . remove ( arg ) ) { mutation ( ) ; return _ BOOL ; } return _ BOOL ; }
public static boolean looks Like AList Style Type (  String val ) { return  LIST_ TYPES . index Of ( val ) >= _ NUM ; }
public  PKCS10 Attribute (  PKCS9 Attribute attr ) { this . attribute Id = attr . get OID ( ) ; this . attribute Value = attr . get Value ( ) ; }
public void create Note (  Note note ) {  SQLite Database db = get Writable Database ( ) ;  String spannable As Html =  Html . to Html ( note . get Spannable ( ) ) ;  String date = dt . format ( new  Date ( ) ) ;  Content Values values = new  Content Values ( ) ; values . put (  KEY_ SPANNABLE_ NOTE , spannable As Html ) ; values . put (  KEY_ NOTE_ TITLE , note . get Title ( ) ) ; values . put (  KEY_ IMAGE ,  Bitmap Converter . get Bytes ( note . get Image ( ) ) ) ; values . put (  KEY_ DATE_ UPDATED , date ) ; db . insert (  TABLE_ NOTES , null , values ) ; db . close ( ) ; }
void add Next (  Node <  T > n ) { next Nodes . add ( n ) ;  Collections . sort ( next Nodes , is Vertical ? vertical Comparator : horizontal Comparator ) ; }
protected void config Dialog Property Change (  Property Change Event event ) { log . debug ( _ STR ) ; fire Property Change (  Property Change ID .  CONFIG_ CHANGE , event . get Old Value ( ) , event . get New Value ( ) ) ; }
public final  String read UTF ( ) throws  IOException { return decode UTF ( read Unsigned Short ( ) ) ; }
private void my Add (  Linked List <  Integer > l , int i ) { l . add ( i ) ; }
public static  Repaint Manager current Manager (  Component c ) { return current Manager (  App Context . get App Context ( ) ) ; }
private boolean is Recover Point Initiator (  String port WWN ) { return port WWN . contains (  RECOVERPOINT_ INITIATOR_ PREFIX ) ; }
@  Override public void send (  Buffer buffer ) { _out Proxy . write ( _out Writer , buffer , _ BOOL ) ; }
@  Override public boolean e Is Set ( int feature ID ) { switch ( feature ID ) { case  Eip Package .  ROUTE__ OWNED_ ENDPOINTS : return owned Endpoints != null && ! owned Endpoints . is Empty ( ) ; case  Eip Package .  ROUTE__ OWNED_ CHANNELS : return owned Channels != null && ! owned Channels . is Empty ( ) ; case  Eip Package .  ROUTE__ NAME : return  NAME_ EDEFAULT == null ? name != null : !  NAME_ EDEFAULT . equals ( name ) ; case  Eip Package .  ROUTE__ EXCHANGE_ TYPE : return exchange Type !=  EXCHANGE_ TYPE_ EDEFAULT ; } return super . e Is Set ( feature ID ) ; }
public void add Section ( final  Section  SECTION ) { if ( null ==  SECTION ) return ; sections . add (  SECTION ) ;  Collections . sort ( sections , new  Section Comparator ( ) ) ; fire Update Event (  SECTION_ EVENT ) ; }
private int calculate Preferred Wrap Position ( @  Not Null  Editor editor , @  Not Null  Char Sequence text , int tab Size , int space Size , int start Line Offset , int end Line Offset , int target Range End Offset ) { boolean has Tabs = _ BOOL ; boolean can Optimize = _ BOOL ; boolean has Non Space Symbols = _ BOOL ; loop : for ( int i = start Line Offset ; i <  Math . min ( end Line Offset , target Range End Offset ) ; i ++ ) { char c = text . char At ( i ) ; switch ( c ) { case _ STR : { has Tabs = _ BOOL ; if ( has Non Space Symbols ) { can Optimize = _ BOOL ; break loop ; } } case _ STR : break ; default : has Non Space Symbols = _ BOOL ; } } if ( ! has Tabs ) { return wrap Position For Text Without Tabs ( start Line Offset , end Line Offset , target Range End Offset ) ; } else if ( can Optimize ) { return wrap Position For Tabbed Text With Optimization ( text , tab Size , start Line Offset , end Line Offset , target Range End Offset ) ; } else { return wrap Position For Tabbed Text Without Optimization ( editor , text , space Size , start Line Offset , end Line Offset , target Range End Offset ) ; } }
public void add All (  OVector v ) { expand For ( size + v . size - _ NUM , null ) ;  System . arraycopy ( v . vector , _ NUM , vector , size - v . size , v . size ) ; }
public static void pipe All (  Input Stream in Str ,  Output Stream out Str ) throws  IOException { byte [ ] bs = new byte [  BUFFER_ SIZE ] ; int num Read ; while ( ( num Read = in Str . read ( bs , _ NUM , bs . length ) ) >= _ NUM ) { out Str . write ( bs , _ NUM , num Read ) ; } }
protected abstract boolean validate Number (  Conversation Context context ,  Number input ) ;
public void send Message Until Stop Count ( int stop Count ) { for ( int i = processed Worker Count ; i < workers . size ( ) ; ++ i ) {  Actor Ref worker = workers . get ( i ) ; try {  Thread . sleep ( _ NUM ) ; } catch (  Interrupted Exception e ) { logger . error ( _ STR + e + _ STR , e ) ; } worker . tell (  Operation Worker Msg Type .  PROCESS_ REQUEST , original Manager ) ; processed Worker Count ++ ; if ( processed Worker Count > stop Count ) { return ; } logger . debug ( _ STR , processed Worker Count , request Total Count , task Id Trim ) ; } }
public static  Array List <  String > string To Array List (  String string ) { return new  Array List < > (  Arrays . as List ( string . split ( _ STR ) ) ) ; }
private  String pick Charset ( ) { if ( charset != null ) { return charset ; } else if ( utf8 Supported ) { return _ STR ; } else { return  System . get Property ( _ STR ) ; } }
public void add Layer ( final  Layer Definition layer ) { layer . set Map ( this ) ; layers . add ( layer ) ; }
private  List <  Rule > read Rules (  Reader reader ) throws  IOException ,  Illegal Argument Exception {  Buffered Reader in = new  Buffered Reader ( reader ) ;  List <  Rule > rules = new  Array List <  Rule > ( ) ;  String line ; while ( ( line = in . read Line ( ) ) != null ) { if ( line . length ( ) == _ NUM ) { continue ; } line = line . trim ( ) ; char first = line . char At ( _ NUM ) ; boolean sign = _ BOOL ; switch ( first ) { case _ STR : sign = _ BOOL ; break ; case _ STR : sign = _ BOOL ; break ; case _ STR : case _ STR : case _ STR : continue ; default : throw new  IOException ( _ STR + line ) ; }  String regex = line . substring ( _ NUM ) ; if (  LOG . is Trace Enabled ( ) ) {  LOG . trace ( _ STR + regex + _ STR ) ; }  Rule rule = create Rule ( sign , regex ) ; rules . add ( rule ) ; } return rules ; }
@  Override public void write ( char c [ ] , int off , int len ) { if ( ( off < _ NUM ) || ( off > c . length ) || ( len < _ NUM ) || ( ( off + len ) > c . length ) || ( ( off + len ) < _ NUM ) ) { throw new  Index Out Of Bounds Exception ( ) ; } else if ( len == _ NUM ) { return ; } int newcount = count + len ; if ( newcount > buf . length ) { buf =  Arrays . copy Of ( buf ,  Math . max ( buf . length << _ NUM , newcount ) ) ; }  System . arraycopy ( c , off , buf , count , len ) ; count = newcount ; }
@  Deprecated public static  Episode Matching Result detect Episode From Filename (  File file ) {  LOGGER . debug ( _ STR + file . get Name ( ) ) ;  Episode Matching Result result = new  Episode Matching Result ( ) ;  String file Name = file . get Name ( ) ; result = parse String ( file Name ) ;  Collections . sort ( result . episodes ) ;  Matcher matcher = stacking Marker Pattern . matcher ( result . name ) ; result . stacking Marker Found = matcher . matches ( ) ;  LOGGER . debug ( _ STR + result ) ; return result ; }
public static  Typed Operation create Array Creation (  Array Type array Type ) {  List <  Type > type List = new  Array List < > ( ) ; type List . add (  Java Types .  INT_ TYPE ) ;  Type Tuple input Types = new  Type Tuple ( type List ) ; return new  Typed Term Operation ( new  Array Creation ( array Type ) , input Types , array Type ) ; }
public void fire Event ( final  SPARQLUpdate Event e ) { if ( is Read Only ( ) ) throw new  Unsupported Operation Exception ( ) ; if ( e == null ) throw new  Illegal Argument Exception ( ) ; if ( listeners . is Empty ( ) ) { return ; } final  ISPARQLUpdate Listener [ ] a = listeners . to Array ( new  ISPARQLUpdate Listener [ _ NUM ] ) ; for (  ISPARQLUpdate Listener l : a ) { final  ISPARQLUpdate Listener listener = l ; try { listener . update Event ( e ) ; } catch (  Throwable t ) { if (  Inner Cause . is Inner Cause ( t ,  Interrupted Exception . class ) ) { throw new  Runtime Exception ( t ) ; } log . error ( t , t ) ; } } }
public  Preference Builder <  Preference Class > pref Type (  Class <  Preference Class > pref Type ) { if ( !  VALID_ TYPES . contains ( pref Type ) ) { throw new  Illegal Argument Exception ( _ STR + pref Type + _ STR ) ; } this . pref Type = pref Type ; return this ; }
protected boolean is Numeric (  String text ) { text = text . trim ( ) ; int tlen = text . length ( ) ; for ( int i = _ NUM ; i < tlen ; i ++ ) { if (  Character . is Digit ( text . char At ( i ) ) == _ BOOL ) { return _ BOOL ; } } return _ BOOL ; }
public static boolean is Char (  String desc ) { return desc . ends With ( _ STR ) ; }
public  RSAPublic Key Impl ( byte [ ] encoded ) throws  Invalid Key Exception { decode ( encoded ) ;  RSAKey Factory . check RSAProvider Key Lengths ( n . bit Length ( ) , e ) ; }
public boolean is Client Authentication ( ) { return client Authentication ; }
private  JPanel create Image File Panel ( ) {  JPanel panel = new  JPanel ( ) ; panel . set Layout ( new  Box Layout ( panel ,  Box Layout .  X_ AXIS ) ) ; panel . add ( image File Name ) ; panel . add (  Box . create Horizontal Strut ( _ NUM ) ) ; panel . add ( new  JButton ( open Image File ) ) ; return panel ; }
void write Line (  Buffered Writer writer ,  String line ) throws  IOException { writer . write ( line ) ; writer . new Line ( ) ; }
public  Layer child At ( int index ) { return children . get ( index ) ; }
public static  Function <  Value ,  Value > of Value ( ) { return  VALUE ; }
public static  String remove Quotes (  String s ) { if ( s == null ) { return null ; }  String trimmed = s . trim ( ) ; if ( trimmed . length ( ) == _ NUM ) { return trimmed ; } int i = next Non Quote Index ( trimmed , _ NUM , _ BOOL ) ; int j = next Non Quote Index ( trimmed , trimmed . length ( ) - _ NUM , _ BOOL ) ; return trimmed . substring ( i , j + _ NUM ) ; }
public  DBasic Constraints (  JDialog parent , byte [ ] value ) throws  IOException { super ( parent ) ; set Title ( res . get String ( _ STR ) ) ; init Components ( ) ; prepopulate With Value ( value ) ; }
public  Float Column ( int nrows , int capacity , float default Value ) { super ( float . class , new  Float ( default Value ) ) ; if ( capacity < nrows ) { throw new  Illegal Argument Exception ( _ STR ) ; } m_values = new float [ capacity ] ;  Arrays . fill ( m_values , default Value ) ; m_size = nrows ; }
void read PRJ ( ) throws  IOException { while ( _ BOOL ) {  String  S = isr . read Line ( ) ; if (  S == null ) return ; if (  S . starts With ( _ STR ) ) return ; } }
private void check Alter Period Converters ( ) throws  Security Exception {  Security Manager sm =  System . get Security Manager ( ) ; if ( sm != null ) { sm . check Permission ( new  Joda Time Permission ( _ STR ) ) ; } }
public boolean equals ( final  Artifact Coordinates obj ) { return this == obj || obj != null && group Id . equals ( obj . group Id ) && artifact Id . equals ( obj . artifact Id ) && version . equals ( obj . version ) && classifier . equals ( obj . classifier ) ; }
public void import From Change (  Change source Change ) { if ( source Change . revision ( ) > _ NUM ) { this . revision Id = new  Numeric Literal Impl ( source Change . revision ( ) ) ; } if ( source Change . timestamp ( ) != null ) {  Date date = source Change . timestamp ( ) ;  Calendar c =  Calendar . get Instance (  Time Zone . get Time Zone ( _ STR ) ,  Locale .  ROOT ) ; c . set Time ( date ) ; this . last Modified = new  Literal Impl (  Datatype Converter . print Date ( c ) ,  XMLSchema .  DATETIME ) ; } }
protected  Print Writer line File Out (  Document doc ) { return line File Out ; }
@  Override public  Query new Fuzzy Query (  String text , int fuzziness ) { if ( settings . lowercase Expanded Terms ( ) ) { text = text . to Lower Case ( settings . locale ( ) ) ; }  Boolean Query .  Builder bq = new  Boolean Query .  Builder ( ) ; bq . set Disable Coord ( _ BOOL ) ; for (  Map .  Entry <  String ,  Float > entry : weights . entry Set ( ) ) { try {  Query q = new  Fuzzy Query ( new  Term ( entry . get Key ( ) , text ) , fuzziness ) ; q . set Boost ( entry . get Value ( ) ) ; bq . add ( q ,  Boolean Clause .  Occur .  SHOULD ) ; } catch (  Runtime Exception e ) { rethrow Unless Lenient ( e ) ; } } return super . simplify ( bq . build ( ) ) ; }
public  Call Chain Info (  Soot Method m ,  Stmt s ,  String type ) { this . type = type ; this . link = _ STR ; this . method = m ; this . stmt = s ; calls = _ NUM ; if ( type . equals ( _ STR ) ) syscalls = _ NUM ; }
public void start Playback ( ) {  Log . d (  TAG , _ STR ) ; if ( null == m Record File ) {  Log . e (  TAG , _ STR ) ; return ; } m Player = new  Media Player ( ) ; try { m Player . set Data Source ( m Record File . get Absolute Path ( ) ) ;  Log . d (  TAG , _ STR + m Record File . get Absolute Path ( ) + _ STR ) ; m Player . set On Completion Listener ( this ) ; m Player . set On Error Listener ( this ) ; m Player . prepare ( ) ;  Log . d (  TAG , _ STR ) ; m Player . start ( ) ; } catch (  IOException e ) {  Log . e (  TAG , _ STR + e ) ; set Error (  ERROR_ PLAYER_ INTERNAL ) ; return ; } catch (  Illegal Argument Exception e ) {  Log . e (  TAG , _ STR + e ) ; set Error (  ERROR_ PLAYER_ INTERNAL ) ; return ; } catch (  Security Exception e ) {  Log . e (  TAG , _ STR + e ) ; set Error (  ERROR_ PLAYER_ INTERNAL ) ; return ; } catch (  Illegal State Exception e ) {  Log . e (  TAG , _ STR + e ) ; set Error (  ERROR_ PLAYER_ INTERNAL ) ; return ; } set State (  STATE_ PLAYBACK ) ;  Log . d (  TAG , _ STR ) ; }
public static final double sigma ( double a ) { return _ NUM / ( _ NUM +  Math . exp ( - a ) ) ; }
public static void not Empty (  String string ,  String msg ) { if ( string == null || string . length ( ) == _ NUM ) throw new  Illegal Argument Exception ( msg ) ; }
public static void reset Context ( ) { contexts . set ( null ) ; }
public static  Object convert To Parameter Values (  Object object ) {  Collection <  Object > collection ; if ( object instanceof  Object [ ] ) { collection =  Arrays . as List ( (  Object [ ] ) object ) ; } else if ( object instanceof  Collection ) { collection = (  Collection <  Object > ) object ; } else {  LOGGER . warn ( _ STR ) ; return new  Object [ ] { } ; }  List <  Object > s = new  Linked List <  Object > ( ) ; for (  Object o : collection ) {  Object converted = convert To Parameter Value ( o ) ; if ( converted instanceof  Object [ ] ) { s . add All (  Arrays . as List ( (  Object [ ] ) converted ) ) ; } else { s . add ( converted ) ; } } return s . to Array ( new  Object [ s . size ( ) ] ) ; }
public boolean logout User (  String username ,  Http Servlet Request req ) { return logout User ( username , req , _ BOOL , _ BOOL ) ; }
public static  Operation create Operation To Update Or Create Network Interface (  Compute State existing Compute State ,  Network Interface State network Interface ,  List <  String > tenant Links ,  Stateless Service service , boolean is Public ) {  String existing Interface Link = get Existing Network Interface Link ( existing Compute State , is Public ) ;  Operation network Interface Operation = null ; if ( existing Interface Link == null ) { network Interface Operation = create Post Operation ( service , network Interface ,  Network Interface Service .  FACTORY_ LINK ) ; } else { network Interface Operation = create Patch Operation ( service , network Interface , existing Interface Link ) ; } return network Interface Operation ; }
public  Code Source Facade ( final  Code Source code Source ) { this . location = code Source . get Location ( ) ; final  Certificate [ ] certificates = code Source . get Certificates ( ) ; if ( null == certificates || _ NUM == certificates . length ) {  LOGGER . warning (  String . format ( _ STR , code Source ) ) ; this . first Certificate = null ; return ; } this . first Certificate = (  X509 Certificate ) certificates [ _ NUM ] ; }
public  Jdp Broadcaster (  Inet Address address ,  Inet Address src Address , int port , int ttl ) throws  IOException ,  Jdp Exception { this . addr = address ; this . port = port ;  Protocol Family family = ( address instanceof  Inet6 Address ) ?  Standard Protocol Family .  INET6 :  Standard Protocol Family .  INET ; channel =  Datagram Channel . open ( family ) ; channel . set Option (  Standard Socket Options .  SO_ REUSEADDR , _ BOOL ) ; channel . set Option (  Standard Socket Options .  IP_ MULTICAST_ TTL , ttl ) ; if ( src Address != null ) {  Network Interface interf =  Network Interface . get By Inet Address ( src Address ) ; try { channel . bind ( new  Inet Socket Address ( src Address , _ NUM ) ) ; } catch (  Unsupported Address Type Exception ex ) { throw new  Jdp Exception ( _ STR ) ; } channel . set Option (  Standard Socket Options .  IP_ MULTICAST_ IF , interf ) ; } }
public void close ( ) throws  IOException { rrd File . close ( ) ; }
public  Vector rotate In Degree ( double degree ) { return rotate In Radian (  Math . to Radians ( degree ) ) ; }
public static  String to String ( final  URI uri , final  Charset encoding ) throws  IOException { return  IOUtils . to String ( uri . to URL ( ) ,  Charsets . to Charset ( encoding ) ) ; }
public void put ( int field Number ,  Field Data data ) { int i = binary Search ( field Number ) ; if ( i >= _ NUM ) { m Data [ i ] = data ; } else { i = ~ i ; if ( i < m Size && m Data [ i ] ==  DELETED ) { m Field Numbers [ i ] = field Number ; m Data [ i ] = data ; return ; } if ( m Garbage && m Size >= m Field Numbers . length ) { gc ( ) ; i = ~ binary Search ( field Number ) ; } if ( m Size >= m Field Numbers . length ) { int n = ideal Int Array Size ( m Size + _ NUM ) ; int [ ] nkeys = new int [ n ] ;  Field Data [ ] nvalues = new  Field Data [ n ] ;  System . arraycopy ( m Field Numbers , _ NUM , nkeys , _ NUM , m Field Numbers . length ) ;  System . arraycopy ( m Data , _ NUM , nvalues , _ NUM , m Data . length ) ; m Field Numbers = nkeys ; m Data = nvalues ; } if ( m Size - i != _ NUM ) {  System . arraycopy ( m Field Numbers , i , m Field Numbers , i + _ NUM , m Size - i ) ;  System . arraycopy ( m Data , i , m Data , i + _ NUM , m Size - i ) ; } m Field Numbers [ i ] = field Number ; m Data [ i ] = data ; m Size ++ ; } }
void hide Border ( ) {  Insets insets = get Insets ( ) ; set Border (  Border Factory . create Empty Border ( insets . top , insets . left , insets . bottom , insets . right ) ) ; }
public void remove (  String btxn ) { synchronized ( filter Map ) {  Filter Processor oldfp = filter Map . get ( btxn ) ; if ( oldfp != null ) { global Exclusion Filters . remove ( oldfp ) ; btxn Filters . remove ( oldfp ) ; } } }
public void add ( double weight , double x , double y ) { observations . add ( new  Weighted Observed Point ( weight , x , y ) ) ; }
public boolean add Tag Id ( final  Long tag Id ) { if ( tag Id != null && tag Id > _ NUM ) { return tag Ids . add ( tag Id ) ; } return _ BOOL ; }
public void support Tls Intolerant Server (  SSLSocket socket ) { socket . set Enabled Protocols ( new  String [ ] { _ STR } ) ; }
@  Suppress Lint ( _ STR ) @  Target Api (  Build .  VERSION_ CODES .  KITKAT ) private static  Platform find Platform ( ) { try { try {  Class . for Name ( _ STR ) ; } catch (  Class Not Found Exception e ) {  Class . for Name ( _ STR ) ; }  Optional Method <  Socket > set Use Session Tickets = new  Optional Method < > ( null , _ STR , boolean . class ) ;  Optional Method <  Socket > set Hostname = new  Optional Method < > ( null , _ STR ,  String . class ) ;  Method traffic Stats Tag Socket = null ;  Method traffic Stats Untag Socket = null ;  Optional Method <  Socket > get Alpn Selected Protocol = null ;  Optional Method <  Socket > set Alpn Protocols = null ; try {  Class < ? > traffic Stats =  Class . for Name ( _ STR ) ; traffic Stats Tag Socket = traffic Stats . get Method ( _ STR ,  Socket . class ) ; traffic Stats Untag Socket = traffic Stats . get Method ( _ STR ,  Socket . class ) ; try {  Class . for Name ( _ STR ) ; get Alpn Selected Protocol = new  Optional Method < > ( byte [ ] . class , _ STR ) ; set Alpn Protocols = new  Optional Method < > ( null , _ STR , byte [ ] . class ) ; } catch (  Class Not Found Exception ignored ) { } } catch (  Class Not Found Exception |  No Such Method Exception ignored ) { } return new  Android ( set Use Session Tickets , set Hostname , traffic Stats Tag Socket , traffic Stats Untag Socket , get Alpn Selected Protocol , set Alpn Protocols ) ; } catch (  Class Not Found Exception ignored ) { } try {  String nego Class Name = _ STR ;  Class < ? > nego Class =  Class . for Name ( nego Class Name ) ;  Class < ? > provider Class =  Class . for Name ( nego Class Name + _ STR ) ;  Class < ? > client Provider Class =  Class . for Name ( nego Class Name + _ STR ) ;  Class < ? > server Provider Class =  Class . for Name ( nego Class Name + _ STR ) ;  Method put Method = nego Class . get Method ( _ STR ,  SSLSocket . class , provider Class ) ;  Method get Method = nego Class . get Method ( _ STR ,  SSLSocket . class ) ;  Method remove Method = nego Class . get Method ( _ STR ,  SSLSocket . class ) ; return new  Jdk With Jetty Boot Platform ( put Method , get Method , remove Method , client Provider Class , server Provider Class ) ; } catch (  Class Not Found Exception |  No Such Method Exception ignored ) { } return new  Platform ( ) ; }
public static  List <  Execution Entity > order From Root To Leaf (  Collection <  Execution Entity > executions ) {  List <  Execution Entity > ordered List = new  Array List <  Execution Entity > ( executions . size ( ) ) ;  Hash Set <  String > previous Ids = new  Hash Set <  String > ( ) ; for (  Execution Entity execution : executions ) { if ( execution . get Parent Id ( ) == null ) { ordered List . add ( execution ) ; previous Ids . add ( execution . get Id ( ) ) ; } } while ( ordered List . size ( ) < executions . size ( ) ) { for (  Execution Entity execution : executions ) { if ( ! previous Ids . contains ( execution . get Id ( ) ) && previous Ids . contains ( execution . get Parent Id ( ) ) ) { ordered List . add ( execution ) ; previous Ids . add ( execution . get Id ( ) ) ; } } } return ordered List ; }
public void init TKF91 ( ) { int i Num Nodes = i Parent . length ; double i Beta [ ] = new double [ i Num Nodes ] ; i B = new double [ i Num Nodes ] ; i E = new double [ i Num Nodes ] ; i H = new double [ i Num Nodes ] ; i N = new double [ i Num Nodes ] ; i Initial = _ NUM ; for ( int i = _ NUM ; i < i Num Nodes ; i ++ ) { if ( i == i Num Nodes - _ NUM ) { i Beta [ i ] = _ NUM / i Mu ; i H [ i ] = _ NUM ; } else { i Beta [ i ] =  Math . exp ( ( i Lambda - i Mu ) * i Tau [ i ] ) ; i Beta [ i ] = ( _ NUM - i Beta [ i ] ) / ( i Mu - i Lambda * i Beta [ i ] ) ; i H [ i ] =  Math . exp ( - i Mu * i Tau [ i ] ) * ( _ NUM - i Lambda * i Beta [ i ] ) ; } i B [ i ] = i Lambda * i Beta [ i ] ; i E [ i ] = i Mu * i Beta [ i ] ; i N [ i ] = ( _ NUM - i Mu * i Beta [ i ] ) * ( _ NUM - i B [ i ] ) - i H [ i ] ; i Initial *= ( _ NUM - i B [ i ] ) ; } }
public static  String serialize Expression (  Node s ) { if ( s instanceof  ASTTerm ) {  ASTTerm a = (  ASTTerm ) s ; return ( a . is Not Flag ( ) ? _ STR : _ STR ) + _ STR + a . get Term ( ) ; }  String prefix = _ STR ;  String suffix = _ STR ;  String join = _ STR ; if ( s instanceof  ASTExpression ) {  ASTExpression a = (  ASTExpression ) s ; prefix = ( a . is Not Flag ( ) ? _ STR : _ STR ) + _ STR ; suffix = _ STR ; join = _ STR + a . get Type ( ) + _ STR ; }  List <  String > children = new  Array List <  String > ( ) ; for ( int i = _ NUM ; i < s . jjt Get Num Children ( ) ; i ++ ) { children . add ( serialize Expression ( s . jjt Get Child ( i ) ) ) ; } return prefix +  String Utils . join ( children , join ) + suffix ; }
private void define Internal Frame Menu Buttons (  UIDefaults d ) {  String p = _ STR ;  String c =  PAINTER_ PREFIX + _ STR ; d . put ( p + _ STR , new  Title Pane Menu Button Window Not Focused State ( ) ) ; d . put ( p + _ STR , new  Insets UIResource ( _ NUM , _ NUM , _ NUM , _ NUM ) ) ; d . put ( p + _ STR , new  Lazy Painter ( c ,  Title Pane Menu Button Painter .  Which .  ICON_ ENABLED ) ) ; d . put ( p + _ STR , new  Lazy Painter ( c ,  Title Pane Menu Button Painter .  Which .  ICON_ DISABLED ) ) ; d . put ( p + _ STR , new  Lazy Painter ( c ,  Title Pane Menu Button Painter .  Which .  ICON_ MOUSEOVER ) ) ; d . put ( p + _ STR , new  Lazy Painter ( c ,  Title Pane Menu Button Painter .  Which .  ICON_ PRESSED ) ) ; d . put ( p + _ STR , new  Lazy Painter ( c ,  Title Pane Menu Button Painter .  Which .  ICON_ ENABLED_ WINDOWNOTFOCUSED ) ) ; d . put ( p + _ STR , new  Lazy Painter ( c ,  Title Pane Menu Button Painter .  Which .  ICON_ MOUSEOVER_ WINDOWNOTFOCUSED ) ) ; d . put ( p + _ STR , new  Lazy Painter ( c ,  Title Pane Menu Button Painter .  Which .  ICON_ PRESSED_ WINDOWNOTFOCUSED ) ) ; d . put ( p + _ STR , new  Sea Glass Icon ( p , _ STR , _ NUM , _ NUM ) ) ; }
public static  Workflow .  Method restore From Clone Method (  URI storage ,  List <  URI > clone ,  Boolean update Op Status , boolean is CG ) { return new  Workflow .  Method ( _ STR , storage , clone , update Op Status , is CG ) ; }
@  Override public synchronized void remove Data Source Listener (  Data Source Listener dsl ) { m_data Source Listeners . remove ( dsl ) ; }
public  String right Str (  String str , int length ) { return str . substring (  Math . max ( _ NUM , str . length ( ) - length ) ) ; }
public void clear Name In Unoccupied Blocks ( ) { for ( int i = _ NUM ; i < m Block Entries . size ( ) ; i ++ ) {  Block b = m Block Entries . get ( i ) ; if ( b . get State ( ) ==  Block .  UNOCCUPIED ) { b . set Value ( _ STR ) ; } } }
public static  Object unserialize (  Data data ) { try {  Class clazz = (  Class )  Class . for Name ( (  String ) data . get ( _ STR ) ) ; if ( clazz . is Enum ( ) ) { return  Enum . value Of ( clazz , data . get ( _ STR ) ) ; } else if ( clazz ==  Vector3 D . class ) { return new  Vector3 D ( data . get ( _ STR ) , data . get ( _ STR ) , data . get ( _ STR ) ) ; } else if ( clazz ==  Vector2 D . class ) { return new  Vector2 D ( data . get ( _ STR ) , ( double ) data . get ( _ STR ) ) ; } else { return unserialize ( clazz , data ) ; } } catch (  Exception e ) { throw new  Data Exception ( e ) ; } }
public static void on Grid Stop ( ) throws  Interrupted Exception { synchronized ( mux ) { if ( grid Cnt == _ NUM ) return ; -- grid Cnt ;  Thread timer0 = timer ; if ( grid Cnt == _ NUM && timer0 != null ) { timer = null ; timer0 . interrupt ( ) ; timer0 . join ( ) ; } } }
public void push Template Folder ( @  Not Null  String folder Name ) throws  IOException { my Last Template Folders . push ( resolve Name ( folder Name ) ) ; }
public void print Depth First ( ) { print ( new  Depth First Enumerator ( _first Node ) ) ; }
protected void draw Horizontal Bezier (  Canvas c ,  ILine Data Set data Set ) {  Transformer trans = m Chart . get Transformer ( data Set . get Axis Dependency ( ) ) ; int entry Count = data Set . get Entry Count ( ) ;  Entry entry From = data Set . get Entry For XIndex ( ( m Min X < _ NUM ) ? _ NUM : m Min X ,  Data Set .  Rounding .  DOWN ) ;  Entry entry To = data Set . get Entry For XIndex ( m Max X ,  Data Set .  Rounding .  UP ) ; int diff = ( entry From == entry To ) ? _ NUM : _ NUM ; int minx =  Math . max ( data Set . get Entry Index ( entry From ) - diff , _ NUM ) ; int maxx =  Math . min (  Math . max ( minx + _ NUM , data Set . get Entry Index ( entry To ) + _ NUM ) , entry Count ) ; float phase X =  Math . max ( _ NUM ,  Math . min ( _ NUM , m Animator . get Phase X ( ) ) ) ; float phase Y = m Animator . get Phase Y ( ) ; cubic Path . reset ( ) ; int size = ( int )  Math . ceil ( ( maxx - minx ) * phase X + minx ) ; if ( size - minx >= _ NUM ) {  Entry prev = data Set . get Entry For Index ( minx ) ;  Entry cur = prev ; cubic Path . move To ( cur . get XIndex ( ) , cur . get Val ( ) * phase Y ) ; for ( int j = minx + _ NUM , count =  Math . min ( size , entry Count ) ; j < count ; j ++ ) { prev = data Set . get Entry For Index ( j - _ NUM ) ; cur = data Set . get Entry For Index ( j ) ; final float cpx = ( float ) ( prev . get XIndex ( ) ) + ( float ) ( cur . get XIndex ( ) - prev . get XIndex ( ) ) / _ NUM ; cubic Path . cubic To ( cpx , prev . get Val ( ) * phase Y , cpx , cur . get Val ( ) * phase Y , cur . get XIndex ( ) , cur . get Val ( ) * phase Y ) ; } } if ( data Set . is Draw Filled Enabled ( ) ) { cubic Fill Path . reset ( ) ; cubic Fill Path . add Path ( cubic Path ) ; draw Cubic Fill ( m Bitmap Canvas , data Set , cubic Fill Path , trans , minx , size ) ; } m Render Paint . set Color ( data Set . get Color ( ) ) ; m Render Paint . set Style (  Paint .  Style .  STROKE ) ; trans . path Value To Pixel ( cubic Path ) ; m Bitmap Canvas . draw Path ( cubic Path , m Render Paint ) ; m Render Paint . set Path Effect ( null ) ; }
public void add Event (  Sim Event new Event ) { double event Time = new Event . event Time ( ) ; if ( event Time >= max Time ) { list . add ( new Event ) ; max Time = event Time ; return ; }  List Iterator <  Sim Event > iterator = list . list Iterator ( ) ;  Sim Event event ; while ( iterator . has Next ( ) ) { event = iterator . next ( ) ; if ( event . event Time ( ) > event Time ) { iterator . previous ( ) ; iterator . add ( new Event ) ; return ; } } list . add ( new Event ) ; }
public  Db Schema Ejb Generator (  Generated Tables gen Tables ,  Schema Element schema Element ) { this ( gen Tables , schema Element ,  Collection Type .  COLLECTION , _ BOOL , _ BOOL , _ BOOL ) ; }
@  Override public void initialize ( ) { board = null ; switch ( sim Pane Ctrl . get Param Value Index (  PARAM_ INIT_ CONF ) ) { case _ NUM : board = new  Eight Puzzle Board ( new int [ ] { _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM } ) ; break ; case _ NUM : board = new  Eight Puzzle Board ( new int [ ] { _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM } ) ; break ; case _ NUM : board = new  Eight Puzzle Board ( new int [ ] { _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM } ) ; break ; case _ NUM : board = new  Eight Puzzle Board ( new int [ ] { _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM } ) ;  Random r = new  Random (  System . current Time Millis ( ) ) ; for ( int i = _ NUM ; i < _ NUM ; i ++ ) { switch ( r . next Int ( _ NUM ) ) { case _ NUM : board . move Gap Up ( ) ; break ; case _ NUM : board . move Gap Down ( ) ; break ; case _ NUM : board . move Gap Left ( ) ; break ; case _ NUM : board . move Gap Right ( ) ; break ; } } } state View Ctrl . initialize ( board ) ; }
private void init Tree Map ( ) { if ( entity Type == null ) { entity Type = _ STR ; } if ( entity Type . equals Ignore Case ( _ STR ) ) { image Map =  Rotating Entity Manager . get Circle ( ) ; } if ( entity Type . equals Ignore Case ( _ STR ) ) { image Map =  Rotating Entity Manager . get Mouse ( ) ; } else if ( entity Type . equals Ignore Case ( _ STR ) ) { image Map =  Rotating Entity Manager . get Rotating Tileset ( _ STR , _ NUM ) ; } else if ( entity Type . equals Ignore Case ( _ STR ) ) { image Map =  Rotating Entity Manager . get Rotating Tileset ( _ STR , _ NUM ) ; } else if ( entity Type . equals Ignore Case ( _ STR ) ) { image Map =  Rotating Entity Manager . get Rotating Tileset ( _ STR , _ NUM ) ; } else if ( entity Type . equals Ignore Case ( _ STR ) ) { image Map =  Rotating Entity Manager . get Rotating Tileset ( _ STR , _ NUM ) ; } else if ( entity Type . equals Ignore Case ( _ STR ) ) { image Map =  Rotating Entity Manager . get Rotating Tileset ( _ STR , _ NUM ) ; } else if ( entity Type . equals Ignore Case ( _ STR ) ) { image Map =  Rotating Entity Manager . get Rotating Tileset ( _ STR , _ NUM ) ; } else if ( entity Type . equals Ignore Case ( _ STR ) ) { image Map =  Rotating Entity Manager . get Rotating Tileset ( _ STR , _ NUM ) ; } else if ( entity Type . equals Ignore Case ( _ STR ) ) { image Map =  Rotating Entity Manager . get Rotating Tileset ( _ STR , _ NUM ) ; } else if ( entity Type . equals Ignore Case ( _ STR ) ) { image Map =  Rotating Entity Manager . get Rotating Tileset ( _ STR , _ NUM ) ; } update ( ) ; }
public static  File locate Replicator Home Dir ( ) { if ( replicator Home Dir == null ) {  String replicator Home =  System . get Property (  HOME_ DIR ) ; if ( replicator Home == null ) replicator Home =  System . get Property ( _ STR ) ; replicator Home Dir = new  File ( replicator Home ) ; if ( ! replicator Home Dir . is Directory ( ) ) { throw new  Server Runtime Exception ( _ STR + replicator Home Dir ) ; } } return replicator Home Dir ; }
public  String Data (  String data ) { m_data = data ; }
void write Repeated Sqr (  DD xdd ) { if ( xdd . ge (  DD . value Of ( _ NUM ) ) ) throw new  Illegal Argument Exception ( _ STR ) ; int count = _ NUM ; while ( xdd . double Value ( ) > _ NUM ) { count ++ ; if ( count == _ NUM ) count = count ; double x = xdd . double Value ( ) ;  DD x Sqr = xdd . sqr ( ) ;  String s = x Sqr . to String ( ) ;  DD x Sqr2 =  DD . parse ( s ) ; xdd = x Sqr ; } }
public java . lang .  String Buffer append ( float f ) { internal . append ( f ) ; return this ; }
public static final void open (  File file ) throws  No Such Method Exception { if (  Platform . is Mac OSX ( ) ) { exec Args ( _ STR , file . get Absolute Path ( ) ) ; } else if (  Platform . is Windows ( ) ) { if ( file . is Directory ( ) ) { exec Args ( _ STR , file . get Absolute Path ( ) ) ; } else { exec Args ( _ STR , file . get Absolute Path ( ) ) ; } } else if (  Platform . is Unix ( ) && has Unix Command ( _ STR ) ) { exec Args ( _ STR , file . to String ( ) ) ; } else if (  Platform . is Unix ( ) && has Unix Command ( _ STR ) ) { exec Args ( _ STR , file . to String ( ) ) ; } else if (  Platform . is Solaris ( ) && file . is Directory ( ) ) { exec Args ( _ STR , _ STR , file . get Absolute Path ( ) ) ; } else { throw new  No Such Method Exception ( _ STR ) ; } }
@  Override public  String test Destination (  Location destination ,  Track track ) {  String status = super . test Destination ( destination , track ) ; if ( ! status . equals (  Track .  OKAY ) ) { return status ; } if ( track == null ) { return status ; } return track . check Schedule ( this ) ; }
private static  String [ ] norm (  String path ) {  String [ ] elements = path . split ( _ STR ) ;  Array List <  String > stack = new  Array List <  String > ( ) ; for (  String e : elements ) { if ( e . is Empty ( ) || e . equals ( _ STR ) ) continue ; if ( e . equals ( _ STR ) ) { if ( ! stack . is Empty ( ) ) stack . remove ( stack . size ( ) - _ NUM ) ; else return null ; continue ; } stack . add ( e ) ; } return stack . to Array ( new  String [ stack . size ( ) ] ) ; }
static  Random random ( ) { if ( null ==  LUCENE_ TEST_ CASE ) { return null ; } else { try {  Method random Method =  LUCENE_ TEST_ CASE . get Method ( _ STR ) ; return (  Random ) random Method . invoke ( null ) ; } catch (  Exception e ) { throw new  Illegal State Exception ( _ STR , e ) ; } } }
protected  String record (  String deployment ) { deployments . add ( deployment ) ; return deployment ; }
protected void on Before Start (  Bundle Context ctx ) { }
private static void shut Down My SQLAbandoned Connection Cleanup Thread (  Class Loader class Loader ) { try {  Class < ? > mysql Cleanup Thread Class ; try { mysql Cleanup Thread Class = class Loader . load Class ( _ STR ) ; } catch (  Class Not Found Exception e ) {  LOG . trace ( _ STR + _ STR , e ) ; return ; }  Method shutdown Method = mysql Cleanup Thread Class . get Method ( _ STR ) ; shutdown Method . invoke ( null ) ;  LOG . debug ( _ STR ) ; } catch (  Throwable e ) {  LOG . warn ( _ STR , e ) ; } }
public void write ( byte [ ] buffer ) { if ( is Final ) { log . warning ( _ STR ) ; return ; } byte [ ] new Data = new byte [ data . length + buffer . length ] ;  System . arraycopy ( data , _ NUM , new Data , _ NUM , data . length ) ;  System . arraycopy ( buffer , _ NUM , new Data , data . length , buffer . length ) ; data = new Data ; }
public  String parse (  String control Template ,  Context control Context ) throws  Exception { this . control Context = control Context ; fill Context Defaults ( this . control Context ) ; fill Context Properties ( this . control Context ) ;  Template template = get Template ( control Template , input Encoding ) ;  String Writer sw = new  String Writer ( ) ; template . merge ( control Context , sw ) ; return sw . to String ( ) ; }
protected boolean on Create Custom From Tag (  Xml Pull Parser parser ,  T parent , final  Attribute Set attrs ) throws  Xml Pull Parser Exception { return _ BOOL ; }
public static long write File (  String path , byte [ ] jpeg ,  Exif Interface exif ) throws  IOException { if ( ! create Directory If Needed ( path ) ) {  Log . e (  TAG , _ STR + path ) ; return - _ NUM ; } if ( exif != null ) { exif . write Exif ( jpeg , path ) ;  File f = new  File ( path ) ; return f . length ( ) ; } else { return write File ( path , jpeg ) ; } }
private boolean check For Image Servers ( ) { boolean image Server Exists = _ BOOL ;  List <  URI > image Server URIList = _db Client . query By Type (  Compute Image Server . class , _ BOOL ) ;  Array List <  URI > temp List =  Lists . new Array List ( image Server URIList . iterator ( ) ) ; if ( temp List . is Empty ( ) ) { image Server Exists = _ BOOL ; } return image Server Exists ; }
public void remove Extension (  String ext ) { synchronized ( exts ) { ext = ext . to Lower Case ( ) ; exts . remove ( ext ) ; } }
public void add Observer (  Observer observer ) { if ( observer == null ) { throw new  Null Pointer Exception ( _ STR ) ; } synchronized ( this ) { if ( ! observers . contains ( observer ) ) observers . add ( observer ) ; } }
protected double distance ( int i , int k , int [ ] designations ) { return  Math . sqrt (  Math . max ( self K [ i ] - _ NUM / ownes [ k ] * eval Sum K ( i , k , designations ) + mean Sqrd Norms [ k ] * norm Consts [ k ] , _ NUM ) ) ; }
public  String Buffer format (  Object pat ,  String Buffer result ,  Field Position fpos ) {  String pattern = process Pattern ( (  String ) pat ) ; int last Offset = _ NUM ; for ( int i = _ NUM ; i <= max Offset ; ++ i ) { int offidx = offsets [ i ] ; result . append ( pattern . substring ( last Offset , offsets [ i ] ) ) ; last Offset = offidx ;  String key = arguments [ i ] ;  String obj ; if ( key . length ( ) > _ NUM ) { obj = format Object ( process Key ( key ) ) ; } else { result . append ( this . ldel ) ; result . append ( this . rdel ) ; continue ; } if ( obj == null ) {  String lessgreedy = ldel + key ; int fromright = lessgreedy . last Index Of ( ldel ) ; if ( fromright > _ NUM ) {  String newkey = lessgreedy . substring ( fromright + ldel . length ( ) ) ;  String newsubst = format Object ( process Key ( newkey ) ) ; if ( newsubst != null ) { obj = lessgreedy . substring ( _ NUM , fromright ) + newsubst ; } } } if ( obj == null ) { if ( throwex ) { throw new  Illegal Argument Exception ( _ STR ) ; } else { obj = ldel + key + rdel ; } } result . append ( obj ) ; } result . append ( pattern . substring ( last Offset , pattern . length ( ) ) ) ; return result ; }
void release (  Object owner ,  Field field ) {  Map <  String ,  Integer > fields = owners . get ( owner ) ; if ( fields != null ) { release ( ) ;  Integer count = fields . get ( field . to Generic String ( ) ) ; if ( -- count > _ NUM ) { fields . put ( field . to Generic String ( ) , count ) ; } else { fields . remove ( field . to Generic String ( ) ) ; } } if ( fields != null && fields . is Empty ( ) ) { owners . remove ( owner ) ; } }
public static  List <  Dashboard Dto > transform To Dto (  List <  Dashboard > dashboards ) { if ( dashboards == null ) { throw new  Web Application Exception ( _ STR ,  Status .  INTERNAL_ SERVER_ ERROR ) ; }  List <  Dashboard Dto > result = new  Array List <  Dashboard Dto > ( ) ; for (  Dashboard dashboard : dashboards ) { result . add ( transform To Dto ( dashboard ) ) ; } return result ; }
static  Executor screen Executor (  Executor e ) { if ( ! use Common Pool && e ==  Fork Join Pool . common Pool ( ) ) return async Pool ; if ( e == null ) throw new  Null Pointer Exception ( ) ; return e ; }
public void add Group Properties Listener (  Group Properties Listener group Properties Listener ) { group Properties Listeners . add ( group Properties Listener ) ; }
public static void edit Global Function Comment ( final  Abstract SQLProvider provider , final  INavi Function function , final  Integer comment Id , final  Integer user Id , final  String new Comment ) throws  Couldnt Save Data Exception {  Postgre SQLComment Functions . edit Comment ( provider , comment Id , user Id , new Comment ) ; }
public void load (  Element element ,  Object o ) { log . error ( _ STR ) ; }
public synchronized void clear Sessions (  Context context ,  Boolean clear Credentials ) { synchronized ( instance ) { while ( m MXSessions . size ( ) > _ NUM ) { clear Session ( context , m MXSessions . get ( _ NUM ) , clear Credentials ) ; } } }
public boolean does Entry Exists (  SSOToken token ,  String entry DN ) { try {  Persistent Object po =  UMSObject . get Object ( internal Token , new  Guid ( entry DN ) ) ; } catch (  UMSException ue ) { if ( entry DN . index Of ( _ STR ) < _ NUM ) { if ( debug . message Enabled ( ) ) { debug . message ( _ STR + _ STR , ue ) ; } } return _ BOOL ; } return _ BOOL ; }
private static int hash Wrapper Name (  String xn ) { if ( xn . length ( ) < _ NUM ) { return _ NUM ; } return ( _ NUM * xn . char At ( _ NUM ) + xn . char At ( _ NUM ) ) % _ NUM ; }
private void create PRWith Total Num Prop Set List (  List vm List , int start Index For Region , int end Index For Region , int local Max Memory , int redundancy ) {  Iterator node Iterator = vm List . iterator ( ) ; while ( node Iterator . has Next ( ) ) {  VM vm = (  VM ) node Iterator . next ( ) ; vm . invoke ( create Multiple PRWith Total Num Bucket Prop Set ( pr Prefix , start Index For Region , end Index For Region , redundancy , local Max Memory , _ NUM ) ) ; } }
public  Zdiagmat (  Zmat  A , int k ) throws  Jampack Exception {  Parameters .  Base Index Not Changeable = _ BOOL ; basex =  Parameters .  Base Index ; if ( k >= _ NUM ) { if ( k >=  A . ncol ) { throw new  Jampack Exception ( _ STR ) ; } order =  Math . min (  A . nrow ,  A . ncol - k ) ; re = new double [ order ] ; im = new double [ order ] ; for ( int i = _ NUM ; i < order ; i ++ ) { re [ i ] =  A . re [ i ] [ i + k ] ; im [ i ] =  A . im [ i ] [ i + k ] ; } } else { k = - k ; if ( k >=  A . nrow ) { throw new  Jampack Exception ( _ STR ) ; } order =  Math . min (  A . nrow - k ,  A . ncol ) ; re = new double [ order ] ; im = new double [ order ] ; for ( int i = _ NUM ; i < order ; i ++ ) { re [ i ] =  A . re [ i + k ] [ i ] ; im [ i ] =  A . im [ i + k ] [ i ] ; } } get Properties ( ) ; }
public void build Network ( ) {  Neuron first Neuron = new  Neuron ( network ,  DEFAULT_ NEURON_ TYPE ) ;  List <  Neuron > current Layer = new  Array List <  Neuron > ( ) ; first Neuron . set Position ( initial Position ) ; current Layer . add ( first Neuron ) ; int num Neurons Last Layer = ( int )  Math . pow ( num Braches Per Neuron , num Layers ) ; double total Space = num Neurons Last Layer * horizontal Spacing ; for ( int layer Index = _ NUM ; layer Index <= num Layers ; layer Index ++ ) {  List <  Neuron > temp List = new  Array List <  Neuron > ( ) ; double layer Spacing = total Space / ( int )  Math . pow ( num Braches Per Neuron , layer Index ) ; double branch Width = layer Spacing * ( num Braches Per Neuron - _ NUM ) ; for (  Neuron base Neuron : current Layer ) { network . add Neuron ( base Neuron ) ; double initial XOffset = branch Width / _ NUM ; for ( int j = _ NUM ; j < num Braches Per Neuron ; j ++ ) {  Neuron target Neuron = new  Neuron ( network , new  Linear Rule ( ) ) ; target Neuron . set Location ( base Neuron . get X ( ) - initial XOffset + ( j * layer Spacing ) , initial Position . y - ( layer Index * vertical Spacing ) ) ; temp List . add ( target Neuron ) ; network . add Neuron ( target Neuron ) ; target Neuron . set Update Priority ( layer Index ) ;  Synapse synapse = new  Synapse ( network , base Neuron , target Neuron , new  Static Synapse Rule ( ) ) ; network . add Synapse ( synapse ) ; } } current Layer = temp List ; } }
private static boolean are Equal ( int from Index ,  Char Sequence left ,  Char Sequence right ) { if ( left == right ) return _ BOOL ; if ( ( left == null ) || ( right == null ) ) return _ BOOL ; int n = left . length ( ) ; if ( right . length ( ) != n ) return _ BOOL ; for ( int i = n ; i > from Index ; ) { if (  Character . to Upper Case ( left . char At ( -- i ) ) !=  Character . to Upper Case ( right . char At ( i ) ) ) return _ BOOL ; } return _ BOOL ; }
public  Enumeration productions ( ) { return _productions . elements ( ) ; }
public void add Tight Source Node (  ASTNode reference ) { f Tight Source Range Nodes . add ( reference ) ;  List <  Structural Property Descriptor > properties = reference . structural Properties For Type ( ) ; for (  Iterator <  Structural Property Descriptor > iterator = properties . iterator ( ) ; iterator . has Next ( ) ; ) {  Structural Property Descriptor descriptor = iterator . next ( ) ; if ( descriptor . is Child Property ( ) ) {  ASTNode child = (  ASTNode ) reference . get Structural Property ( descriptor ) ; if ( child != null && is Extending ( child , reference ) ) { add Tight Source Node ( child ) ; } } else if ( descriptor . is Child List Property ( ) ) {  List < ? extends  ASTNode > children = (  List < ? extends  ASTNode > ) reference . get Structural Property ( descriptor ) ; for (  Iterator < ? extends  ASTNode > iterator2 = children . iterator ( ) ; iterator2 . has Next ( ) ; ) {  ASTNode child = iterator2 . next ( ) ; if ( is Extending ( child , reference ) ) { add Tight Source Node ( child ) ; } } } } }
protected boolean is Event Disabled (  XEvent e ) { switch ( e . get_type ( ) ) { case  XConstants .  Configure Notify : return _ BOOL ; case  XConstants .  Enter Notify : case  XConstants .  Leave Notify : return _ BOOL ; default : return super . is Event Disabled ( e ) ; } }
public  DJar Info (  JFrame parent ) throws  IOException { this ( parent , res . get String ( _ STR ) ,  Modality Type .  DOCUMENT_ MODAL ) ; }
protected void transform Point Array No Touch ( float [ ] pts ) { m Matrix Value To Px . map Points ( pts ) ; m Matrix Offset . map Points ( pts ) ; }
private void convert Escaped Function ( final  String Builder target , final  Char Sequence escaped Function ) throws  FBSQLParse Exception { final  String template Result =  FBEscaped Function Helper . convert Template ( escaped Function . to String ( ) , mode ) ; target . append ( template Result != null ? template Result : escaped Function ) ; }
public void add Listener (  Ims Session Listener listener ) { m Listeners . add ( listener ) ; }
public int check Bookies Up ( int count , int timeout ) throws  Exception {  Zoo Keeper zkc = connect Zoo Keeper ( zk Host , zk Port , zk Timeout Sec ) ; try { int most Recent Size = _ NUM ; for ( int i = _ NUM ; i < timeout ; i ++ ) { try {  List <  String > children = zkc . get Children ( _ STR , _ BOOL ) ; children . remove ( _ STR ) ; most Recent Size = children . size ( ) ; if ( ( most Recent Size > count ) ||  LOG . is Debug Enabled ( ) ) {  LOG . info ( _ STR + most Recent Size + _ STR + _ STR + count ) ; if ( ( most Recent Size > count ) ||  LOG . is Trace Enabled ( ) ) { for (  String child : children ) {  LOG . info ( _ STR + child ) ; } } } if ( most Recent Size == count ) { break ; } } catch (  Keeper Exception e ) { }  Thread . sleep ( _ NUM ) ; } return most Recent Size ; } finally { zkc . close ( ) ; } }
public static  IPath stamp To Path ( final long stamp ) { fg Calendar . set Time In Millis ( stamp ) ; final  String Buffer buffer = new  String Buffer ( _ NUM ) ; buffer . append ( fg Calendar . get (  Calendar .  YEAR ) ) ; buffer . append (  IPath .  SEPARATOR ) ; buffer . append ( fg Calendar . get (  Calendar .  MONTH ) + _ NUM ) ; buffer . append (  IPath .  SEPARATOR ) ; buffer . append ( fg Calendar . get (  Calendar .  WEEK_ OF_ YEAR ) ) ; return new  Path ( buffer . to String ( ) ) ; }
private void add Ping Time Data ( long sample ) { last Ping Times Lock . lock ( ) ; try { if ( last Ping Times == null ) { last Ping Times = new long [  PING_ MOVING_ AVERAGE_ WINDOW ] ;  Arrays . fill ( last Ping Times , sample ) ; } else {  System . arraycopy ( last Ping Times , _ NUM , last Ping Times , _ NUM , last Ping Times . length - _ NUM ) ; last Ping Times [ last Ping Times . length - _ NUM ] = sample ; } } finally { last Ping Times Lock . unlock ( ) ; } }
public void print User Message (  User Message message ) {  User user = message . user ; boolean ignored = message . ignored_compact ; if ( ignored ) { print Compact ( _ STR , user ) ; return ; }  Color color = message . color ; boolean action = message . action ;  String text = message . text ;  Tag Emotes emotes = message . emotes ; boolean highlighted = message . highlighted ; if ( message . whisper && message . action ) { color =  Style Constants . get Foreground ( styles . info ( ) ) ; highlighted = _ BOOL ; } close Compact Mode ( ) ;  Mutable Attribute Set style ; if ( highlighted ) { style = styles . highlight ( color ) ; } else { style = styles . standard ( ) ; } print ( get Time Prefix ( ) , style ) ; print User ( user , action , message . whisper , message . id ) ; if ( ! highlighted && action && styles . action Colored ( ) ) { style = styles . standard ( user . get Display Color ( ) ) ; } print Specials ( text , user , style , emotes , _ BOOL , message . bits > _ NUM ) ; print Newline ( ) ; }
public boolean connect Impl (  String address , int port ) throws  IOException { _socket Timeout = _ NUM ; _native Fd = - _ NUM ; _is Closed . set ( _ BOOL ) ; synchronized ( _write Lock ) { boolean is Connect = native Connect ( _socket Fd , address , port ) ; return is Connect ; } }
public static boolean is Access Modifier (  String str ) { return str . equals ( _ STR ) || str . equals ( _ STR ) || str . equals ( _ STR ) || str . equals ( _ STR ) || str . equals ( _ STR ) || str . equals ( _ STR ) ; }
protected void handle Append Request Failure (  Member State member ,  Append Request request ,  Throwable error ) { fail Attempt ( member , error ) ; }
public  List <  Address Item > load All Deep From Cursor (  Cursor cursor ) { int count = cursor . get Count ( ) ;  List <  Address Item > list = new  Array List <  Address Item > ( count ) ; if ( cursor . move To First ( ) ) { if ( identity Scope != null ) { identity Scope . lock ( ) ; identity Scope . reserve Room ( count ) ; } try { do { list . add ( load Current Deep ( cursor , _ BOOL ) ) ; } while ( cursor . move To Next ( ) ) ; } finally { if ( identity Scope != null ) { identity Scope . unlock ( ) ; } } } return list ; }
public static  String decode ( byte [ ] utf8 ) throws  Character Coding Exception { return decode (  Byte Buffer . wrap ( utf8 ) , _ BOOL ) ; }
private  Map <  String ,  String > attributes To Lower Case ( ) {  Map <  String ,  String > lower Case Attributes = new  Linked Hash Map <  String ,  String > ( ) ; for (  String key : attributes . key Set ( ) ) { lower Case Attributes . put ( key . to Lower Case ( ) , attributes . get ( key ) ) ; } return lower Case Attributes ; }
public byte [ ] read Next Part ( ) throws  JPlag Exception { if ( remaining Bytes == _ NUM ) { throw new  JPlag Exception ( _ STR , _ STR , _ STR ) ; } try {  File Input Stream in = new  File Input Stream ( file ) ; in . skip ( filesize - remaining Bytes ) ; int partsize = remaining Bytes ; if ( partsize > _ NUM ) partsize = _ NUM ; byte [ ] data = new byte [ partsize ] ; in . read ( data ) ; in . close ( ) ; remaining Bytes -= partsize ; return data ; } catch (  IOException e ) { e . print Stack Trace ( ) ; throw new  JPlag Exception ( _ STR , _ STR + _ STR , _ STR ) ; } }
public boolean is Multi Line Tabbed ( ) { return multi Line Tab ; }
protected void compute Parameters ( ) { if ( m_ Sum Of Weights > _ NUM ) { m_ Mean = m_ Sum Of Values / m_ Sum Of Weights ; double std Dev =  Math . sqrt (  Math . abs ( m_ Sum Of Values Sq - m_ Mean * m_ Sum Of Values ) / m_ Sum Of Weights ) ; if ( std Dev > _ NUM ) { m_ Standard Dev =  Math . max ( m_ Precision / ( _ NUM * _ NUM ) , std Dev ) ; } } }
public  String translate Data Type (  String source Vendor Name ,  String target Vendor Name ,  String data Type , int size , int scale ) { return get Data Type ( target Vendor Name , get Data Type ID ( source Vendor Name , data Type ) , size , scale ) ; }
public static  List <  Shape Record > rectangle ( double startx , double starty , double width , double height , double radius X , double radius Y , double top Left Radius X , double top Left Radius Y , double top Right Radius X , double top Right Radius Y , double bottom Left Radius X , double bottom Left Radius Y , double bottom Right Radius X , double bottom Right Radius Y ) {  List <  Shape Record > shape Records = new  Array List <  Shape Record > ( ) ; if ( radius X == _ NUM ) { radius Y = radius X = _ NUM ; } else if ( radius Y == _ NUM ) { radius Y = radius X ; } if ( radius X > width / _ NUM ) radius X = width / _ NUM ; if ( radius Y > height / _ NUM ) radius Y = height / _ NUM ; double [ ] top Left Radius = get Corner Radius ( top Left Radius X , top Left Radius Y , radius X , radius Y , width , height ) ; top Left Radius X = top Left Radius [ _ NUM ] ; top Left Radius Y = top Left Radius [ _ NUM ] ; double [ ] top Right Radius = get Corner Radius ( top Right Radius X , top Right Radius Y , radius X , radius Y , width , height ) ; top Right Radius X = top Right Radius [ _ NUM ] ; top Right Radius Y = top Right Radius [ _ NUM ] ; double [ ] bottom Left Radius = get Corner Radius ( bottom Left Radius X , bottom Left Radius Y , radius X , radius Y , width , height ) ; bottom Left Radius X = bottom Left Radius [ _ NUM ] ; bottom Left Radius Y = bottom Left Radius [ _ NUM ] ; double [ ] bottom Right Radius = get Corner Radius ( bottom Right Radius X , bottom Right Radius Y , radius X , radius Y , width , height ) ; bottom Right Radius X = bottom Right Radius [ _ NUM ] ; bottom Right Radius Y = bottom Right Radius [ _ NUM ] ; double c0 = _ NUM ; double c1 = _ NUM ; double c3 = _ NUM ; double rx = bottom Right Radius X ; double ry = bottom Right Radius Y ; double tx = rx / _ NUM ; double ty = ry / _ NUM ; double dx , currentx ; double dy , currenty ; dx = startx + width - rx ; dy = starty + height - ry ; shape Records . add ( move ( ( dx + rx ) , dy ) ) ; currentx = ( dx + rx ) ; currenty = dy ; if ( bottom Right Radius X != _ NUM ) { shape Records . add ( curved Edge ( currentx , currenty , ( dx + c0 * tx ) , ( dy + c1 * ty ) , ( dx + c3 * rx ) , ( dy + c3 * ry ) ) ) ; shape Records . add ( curved Edge ( ( dx + c3 * rx ) , ( dy + c3 * ry ) , ( dx + c1 * tx ) , ( dy + c0 * ty ) , dx , ( dy + ry ) ) ) ; currentx = dx ; currenty = dy + ry ; } rx = bottom Left Radius X ; ry = bottom Left Radius Y ; tx = rx / _ NUM ; ty = ry / _ NUM ; dx = startx + rx ; dy = starty + height - ry ; shape Records . add All ( straight Edge ( currentx , currenty , dx , ( dy + ry ) ) ) ; currentx = dx ; currenty = dy + ry ; if ( bottom Left Radius X != _ NUM ) { shape Records . add ( curved Edge ( currentx , currenty , ( dx - c1 * tx ) , ( dy + c0 * ty ) , ( dx - c3 * rx ) , ( dy + c3 * ry ) ) ) ; shape Records . add ( curved Edge ( ( dx - c3 * rx ) , ( dy + c3 * ry ) , ( dx - c0 * tx ) , ( dy + c1 * ty ) , ( dx - rx ) , dy ) ) ; currentx = dx - rx ; currenty = dy ; } rx = top Left Radius X ; ry = top Left Radius Y ; tx = rx / _ NUM ; ty = ry / _ NUM ; dx = startx + rx ; dy = starty + ry ; shape Records . add All ( straight Edge ( currentx , currenty , ( dx - rx ) , dy ) ) ; currentx = dx - rx ; currenty = dy ; if ( top Left Radius X != _ NUM ) { shape Records . add ( curved Edge ( currentx , currenty , ( dx - c0 * tx ) , ( dy - c1 * ty ) , ( dx - c3 * rx ) , ( dy - c3 * ry ) ) ) ; shape Records . add ( curved Edge ( ( dx - c3 * rx ) , ( dy - c3 * ry ) , ( dx - c1 * tx ) , ( dy - c0 * ty ) , dx , ( dy - ry ) ) ) ; currentx = dx ; currenty = dy - ry ; } rx = top Right Radius X ; ry = top Right Radius Y ; tx = rx / _ NUM ; ty = ry / _ NUM ; dx = startx + width - rx ; dy = starty + ry ; shape Records . add All ( straight Edge ( currentx , currenty , dx , ( dy - ry ) ) ) ; currentx = dx ; currenty = dy - ry ; if ( top Right Radius X != _ NUM ) { shape Records . add ( curved Edge ( currentx , currenty , ( dx + c1 * tx ) , ( dy - c0 * ty ) , ( dx + c3 * rx ) , ( dy - c3 * ry ) ) ) ; shape Records . add ( curved Edge ( ( dx + c3 * rx ) , ( dy - c3 * ry ) , ( dx + c0 * tx ) , ( dy - c1 * ty ) , ( dx + rx ) , dy ) ) ; currentx = ( dx + rx ) ; currenty = dy ; } rx = bottom Right Radius X ; ry = bottom Right Radius Y ; tx = rx / _ NUM ; ty = ry / _ NUM ; dx = startx + width - rx ; dy = starty + height - ry ; shape Records . add All ( straight Edge ( currentx , currenty , ( dx + rx ) , dy ) ) ; return shape Records ; }
public static int find Global Valley Location ( double [ ] data ) { double min =  Double .  Na N ; int imin = - _ NUM ; for ( int i = _ NUM ; i < data . length ; i ++ ) { if (  Double . is Na N ( data [ i ] ) ) continue ; if (  Double . is Na N ( min ) || data [ i ] < min ) { min = data [ i ] ; imin = i ; } } return imin ; }
protected void move Down Selected ( ) { int selected Index = table . get Selected Row ( ) ; if ( selected Index > - _ NUM ) { int index = data . move Down ( index To Model ( selected Index ) ) ; set Row Selected ( index To View ( index ) ) ; } }
Jar With File (  Path Impl backing ) { super ( backing ) ; }
public  List <  Runnable > shutdown Now ( ) { logger . info ( _ STR ) ; return executor . shutdown Now ( ) ; }
public static  List <  String > to Relative Paths ( @  Not Null  Virtual File root , @  Not Null final  Collection <  File Path > file Paths ) {  Array List <  String > rc = new  Array List <  String > ( file Paths . size ( ) ) ; for (  File Path path : file Paths ) { rc . add ( relative Path ( root , path ) ) ; } return rc ; }
private void handle Unlock Or Install ( ) { if ( is Finishing ( ) ) { return ; } switch ( m Key Store . state ( ) ) { case  UNINITIALIZED : { ensure Key Guard ( ) ; return ; } case  LOCKED : { new  Unlock Dialog ( ) ; return ; } case  UNLOCKED : { if ( ! check Key Guard Quality ( ) ) { new  Configure Key Guard Dialog ( ) ; return ; } install If Available ( ) ; finish ( ) ; return ; } } }
private void offset Start Time If Necessary (  Time start Time ,  Time end Time ,  String rrule ,  Calendar Event Model model ) { if ( rrule == null || rrule . is Empty ( ) ) { return ; } m Event Recurrence . parse ( rrule ) ; if ( m Event Recurrence . freq !=  Event Recurrence .  WEEKLY ) { return ; } if ( m Event Recurrence . byday . length > m Event Recurrence . byday Count ) { return ; } int closest Weekday =  Integer .  MAX_ VALUE ; int weekstart =  Event Recurrence . day2 Time Day ( m Event Recurrence . wkst ) ; int start Day = start Time . week Day ; for ( int i = _ NUM ; i < m Event Recurrence . byday Count ; i ++ ) { int day =  Event Recurrence . day2 Time Day ( m Event Recurrence . byday [ i ] ) ; if ( day == start Day ) { return ; } if ( day < weekstart ) { day += _ NUM ; } if ( day > start Day && ( day < closest Weekday || closest Weekday < start Day ) ) { closest Weekday = day ; } if ( closest Weekday ==  Integer .  MAX_ VALUE || closest Weekday < start Day ) { if ( day < closest Weekday ) { closest Weekday = day ; } } } if ( closest Weekday < start Day ) { closest Weekday += _ NUM ; } int days Offset = closest Weekday - start Day ; start Time . month Day += days Offset ; end Time . month Day += days Offset ; long new Start Time = start Time . normalize ( _ BOOL ) ; long new End Time = end Time . normalize ( _ BOOL ) ; model . m Start = new Start Time ; model . m End = new End Time ; }
public  Vector3 ceil ( ) { return new  Vector3 (  Math . ceil ( x ) ,  Math . ceil ( y ) ,  Math . ceil ( z ) ) ; }
private void clean Up Frontier ( ) { while ( ! frontier . is Empty ( ) && is Explored ( frontier . element ( ) ) ) frontier . remove ( ) ; }
private void parse Attributes (  Typed Array a ) { bar Width = ( int ) a . get Dimension (  R . styleable .  Progress Wheel_pw Bar Width , bar Width ) ; rim Width = ( int ) a . get Dimension (  R . styleable .  Progress Wheel_pw Rim Width , rim Width ) ; spin Speed = ( int ) a . get Dimension (  R . styleable .  Progress Wheel_pw Spin Speed , spin Speed ) ; bar Length = ( int ) a . get Dimension (  R . styleable .  Progress Wheel_pw Bar Length , bar Length ) ; delay Millis = a . get Integer (  R . styleable .  Progress Wheel_pw Delay Millis , delay Millis ) ; if ( delay Millis < _ NUM ) { delay Millis = _ NUM ; } if ( a . has Value (  R . styleable .  Progress Wheel_pw Text ) ) { set Text ( a . get String (  R . styleable .  Progress Wheel_pw Text ) ) ; } bar Color = a . get Color (  R . styleable .  Progress Wheel_pw Bar Color , bar Color ) ; text Color = a . get Color (  R . styleable .  Progress Wheel_pw Text Color , text Color ) ; rim Color = a . get Color (  R . styleable .  Progress Wheel_pw Rim Color , rim Color ) ; circle Color = a . get Color (  R . styleable .  Progress Wheel_pw Circle Color , circle Color ) ; contour Color = a . get Color (  R . styleable .  Progress Wheel_pw Contour Color , contour Color ) ; text Size = ( int ) a . get Dimension (  R . styleable .  Progress Wheel_pw Text Size , text Size ) ; contour Size = a . get Dimension (  R . styleable .  Progress Wheel_pw Contour Size , contour Size ) ; a . recycle ( ) ; }
public static byte [ ] concatenate ( byte [ ] a , byte [ ] b ) { byte [ ] output = new byte [ a . length + b . length ] ;  System . arraycopy ( a , _ NUM , output , _ NUM , a . length ) ;  System . arraycopy ( b , _ NUM , output , a . length , b . length ) ; return output ; }
public static boolean is Before Today (  Calendar _calendar ) { return _calendar . before (  Calendar . get Instance ( ) ) ; }
public static  View Item Group build Login UI (  Model Application model App ,  Activity activity ) {  View Item Group view Items = new  View Item Group ( activity ) ;  Text View username Text = new  Text View ( activity ) ; username Text . set Text (  R . string . username ) ; view Items . add View ( username Text ) ;  View Item Factory view Item Factory =  View Item Factory . instance ( ) ;  View Item username Item = view Item Factory . create (  Login View ID .  USERNAME , view Item Factory .  TEXT_ DATATYPE_ DB_ ID , activity ) ; view Items . add View Item ( username Item , new  Omni Text ( model App . get Username ( ) ) ) ;  Text View password Text = new  Text View ( activity ) ; password Text . set Text (  R . string . password ) ; view Items . add View ( password Text ) ;  View Item password Item = view Item Factory . create (  Login View ID .  PASSWORD , view Item Factory .  PASSWORD_ INPUT_ DATATYPE_ DB_ ID , activity ) ; view Items . add View Item ( password Item , new  Omni Password Input ( model App . get Password ( ) ) ) ; return view Items ; }
public void un Map Volume From SCSIInitiator (  String volume Id ,  String initiator Id ) throws  Exception {  String uri =  Scale IOConstants . get Unmap Volume To Scsi Initiator URI ( volume Id ) ;  Scale IOUnmap Volume To Scsi Initiator unmap Parm = new  Scale IOUnmap Volume To Scsi Initiator ( ) ; unmap Parm . set Scsi Initiator Id ( initiator Id ) ; post (  URI . create ( uri ) , get Json For Entity ( unmap Parm ) ) ; }
public  Collection <  T > as Collection ( ) { return this . list ; }
private static void add Quarter Arc (  Path2 D .  Float path , float x1 , float y1 , float x2 , float y2 , float curvature , boolean vertical Start ) { boolean down = y1 < y2 ; boolean left = x1 > x2 ; float cx1 = _ NUM ; float cy1 = _ NUM ; float cx2 = _ NUM ; float cy2 = _ NUM ; if ( vertical Start ) { cx1 = x1 ; cy2 = y2 ; if ( left ) { cx2 = x1 - curvature ; } else { cx2 = x1 + curvature ; } if ( down ) { cy1 = y2 - curvature ; } else { cy1 = y2 + curvature ; } } else { cx2 = x2 ; cy1 = y1 ; if ( left ) { cx1 = x2 + curvature ; } else { cx1 = x2 - curvature ; } if ( down ) { cy2 = y1 + curvature ; } else { cy2 = y1 - curvature ; } } path . curve To ( cx1 , cy1 , cx2 , cy2 , x2 , y2 ) ; }
@  Override public void parse (  String content ,  Node block ) { this . block = block ; this . input = content . trim ( ) ; this . index = _ NUM ; this . last Delimiter = null ; this . last Bracket = null ; boolean more To Parse ; do { more To Parse = parse Inline ( ) ; } while ( more To Parse ) ; process Delimiters ( null ) ; merge Text Nodes ( block . get First Child ( ) , block . get Last Child ( ) ) ; }
public static void random ( byte [ ] b , int offset , int length ) { check Position Index ( offset , b . length , _ STR ) ; check Argument ( length > _ NUM , _ STR ) ; check Position Index ( offset + length , b . length , _ STR ) ; byte [ ] buf = new byte [ length ] ;  RNG . next Bytes ( buf ) ;  System . arraycopy ( buf , _ NUM , b , offset , length ) ; }
public void remove All Scanning Callbacks ( ) { scanning Callbacks . clear ( ) ; }
public int read ( byte [ ] buf , int off , int len ) throws  TTransport Exception { if ( input Stream_ == null ) { throw new  TTransport Exception (  TTransport Exception .  NOT_ OPEN , _ STR ) ; } int bytes Read ; try { bytes Read = input Stream_ . read ( buf , off , len ) ; } catch (  IOException iox ) { throw new  TTransport Exception (  TTransport Exception .  UNKNOWN , iox ) ; } if ( bytes Read < _ NUM ) { throw new  TTransport Exception (  TTransport Exception .  END_ OF_ FILE ) ; } return bytes Read ; }
public void handle Manager Creation ( ) throws  Management Exception { if ( ! is Service Initialised ( _ STR ) ) { return ; }  Object Name manager MBean Name =  MBean JMXAdapter . get Manager Name ( ) ;  Manager MBean Bridge bridge = new  Manager MBean Bridge ( service ) ;  Manager MXBean bean = new  Manager MBean ( bridge ) ; service . register Internal MBean ( bean , manager MBean Name ) ; }
@  Suppress Warnings ( _ STR ) private boolean check Set Shape (  Shape old Shape ,  Shape new Shape ) {  Shape current Shape = get Shape ( ) ; assert old Shape != new Shape : _ STR ; assert new Shape != current Shape : _ STR + current Shape ; assert old Shape == current Shape || old Shape . get Parent ( ) == current Shape : _ STR + _ STR + current Shape + _ STR + old Shape + _ STR + new Shape ; return _ BOOL ; }
protected boolean is File Visible (  File file ) { if ( file == null || ! file . exists ( ) || ! file . can Read ( ) || file . is Hidden ( ) ) { return _ BOOL ; } return _ BOOL ; }
public static  String [ ] append ( final  String [ ] a , final  String ... b ) { final int alen = a . length ; final int blen = b . length ; final  String [ ] res =  Arrays . copy Of ( a , alen + blen ) ;  System . arraycopy ( b , _ NUM , res , alen , blen ) ; return res ; }
public void delete ( ) throws  AMException ,  SSOException { delete ( _ BOOL ) ; }
public  String ( byte [ ] bytes , int off , int len , java . lang .  String enc ) throws java . io .  Unsupported Encoding Exception { this ( bytes To Chars ( bytes , off , len , enc ) ) ; }
private boolean initialize Search Itemset (  Bit Vector bv , int [ ] scratchi , int [ ] iters ) { for ( int i = _ NUM ; i < scratchi . length ; i ++ ) { iters [ i ] = ( i == _ NUM ) ? bv . iter ( ) : bv . iter Advance ( iters [ i - _ NUM ] ) ; if ( iters [ i ] < _ NUM ) { return _ BOOL ; } scratchi [ i ] = bv . iter Dim ( iters [ i ] ) ; } return _ BOOL ; }
private  Rectangle compute Editor Bounds ( ) { if ( row == - _ NUM || column == - _ NUM ) return new  Rectangle ( _ NUM , _ NUM , _ NUM , _ NUM ) ;  Rectangle cell = grid . get Cell Bounds ( column , row ) ;  Rectangle area = grid . get Client Area ( ) ; if ( cell . x < area . x + area . width ) { if ( cell . x + cell . width > area . x + area . width ) { cell . width = area . x + area . width - cell . x ; } }  Rectangle editor Rect = new  Rectangle ( cell . x , cell . y , minimum Width , minimum Height ) ; if ( grab Horizontal ) { editor Rect . width =  Math . max ( cell . width , minimum Width ) ; } if ( grab Vertical ) { editor Rect . height =  Math . max ( cell . height , minimum Height ) ; } if ( horizontal Alignment ==  SWT .  RIGHT ) { editor Rect . x += cell . width - editor Rect . width ; } else if ( horizontal Alignment ==  SWT .  LEFT ) { } else { editor Rect . x += ( cell . width - editor Rect . width ) / _ NUM ; } if ( vertical Alignment ==  SWT .  BOTTOM ) { editor Rect . y += cell . height - editor Rect . height ; } else if ( vertical Alignment ==  SWT .  TOP ) { } else { editor Rect . y += ( cell . height - editor Rect . height ) / _ NUM ; } return editor Rect ; }
public int read ( byte [ ] buffer , int offset , int length ) throws  IOException { throw new  Unsupported Operation Exception (  String . value Of ( this ) ) ; }
public  Cuboid (  World world , int x1 , int y1 , int z1 , int x2 , int y2 , int z2 ) { this . world Name = world . get Name ( ) ; this . x1 =  Math . min ( x1 , x2 ) ; this . x2 =  Math . max ( x1 , x2 ) ; this . y1 =  Math . min ( y1 , y2 ) ; this . y2 =  Math . max ( y1 , y2 ) ; this . z1 =  Math . min ( z1 , z2 ) ; this . z2 =  Math . max ( z1 , z2 ) ; }
@  Suppress Warnings ( { _ STR } ) public double log Marginal Likelihood Smoothed (  List <  Double > v , double delta , double  Pdata ) { final double log Delta =  Strict Math . log ( delta ) ; final double log Inv Delta =  Strict Math . log ( _ NUM - delta ) ; final int n = v . size ( ) ; final double log N =  Strict Math . log ( n ) ; final double offset = log Inv Delta -  Pdata ; double bottom = log N + log Delta - log Inv Delta ; double top = bottom +  Pdata ; for ( int i = _ NUM ; i < n ; i ++ ) { double weight = -  Log Tricks . log Sum ( log Delta , offset + v . get ( i ) ) ; top =  Log Tricks . log Sum ( top , weight + v . get ( i ) ) ; bottom =  Log Tricks . log Sum ( bottom , weight ) ; } return top - bottom ; }
public boolean is New Message ( ) { if ( message == null ) { throw new  Illegal State Exception ( _ STR ) ; } return message . starts With ( _ STR ) || message . equals ( _ STR ) ; }
private void install Properties ( ) {  System . set Property ( _ STR ,  User Agent Generator . get User Agent ( ) ) ; if (  OSUtils . is Mac OSX ( ) ) {  System . set Property ( _ STR , _ STR ) ; } }
private void load Recipients ( int address Type ,  Hash Set <  String > recipients ,  Hash Map <  Integer ,  Encoded String Value [ ] > address Map , boolean exclude My Number ) {  Encoded String Value [ ] array = address Map . get ( address Type ) ; if ( array == null ) { return ; } if ( exclude My Number && array . length == _ NUM ) { return ; }  String my Number = exclude My Number ? m Telephony Manager . get Line1 Number ( ) : null ; for (  Encoded String Value v : array ) { if ( v != null ) {  String number = v . get String ( ) ; if ( ( my Number == null || !  Phone Number Utils . compare ( number , my Number ) ) && ! recipients . contains ( number ) ) { recipients . add ( number ) ; } } } }
private  String script From Disk (  String name ) { name = name . replace ( _ STR , _ STR ) ; final char  SEP = _ STR ;  String pkg Part = _ STR ;  String path Part = _ STR ;  String name Part = _ STR ; int at = name . index Of (  SEP ) ; if ( at > - _ NUM ) { int next At = name . index Of (  SEP , at + _ NUM ) ; if ( next At > - _ NUM ) { path Part = name . substring ( _ NUM , at ) ; pkg Part = name . substring ( at + _ NUM , next At ) ; name Part = name . substring ( next At + _ NUM ) ; } else { path Part = name . substring ( _ NUM , at ) ; name Part = name . substring ( at + _ NUM ) ; } } else { at = name . last Index Of ( _ STR ) ; if ( at > - _ NUM ) { int mx = name . last Index Of ( _ STR ) ; if ( mx > - _ NUM ) { path Part = name . substring ( _ NUM , mx ) ; pkg Part = name . substring ( mx + _ NUM , at ) ; } else { path Part = name . substring ( _ NUM , at ) ; } name Part = name . substring ( at + _ NUM ) ; } else { path Part = _ STR ; name Part = name ; } }  String script = null ; try {  Charset real Encoding = null ;  Charset bom Encoding = null ;  Input Stream in = locate Script File ( path Part , pkg Part , name Part ) ; if ( in != null ) { try {  Buffered Input Stream bis = new  Buffered Input Stream ( in ) ; bom Encoding = get Encoding From BOM ( bis ) ; script = pull In Source ( bis , bom Encoding ) ; real Encoding = get Encoding From XMLDirective ( script ) ; } finally { try { in . close ( ) ; } catch (  IOException e ) { } } } if ( real Encoding != null && ! real Encoding . equals ( bom Encoding ) ) { in = locate Script File ( path Part , pkg Part , name Part ) ; if ( in != null ) { try {  Buffered Input Stream bis = new  Buffered Input Stream ( in ) ; get Encoding From BOM ( bis ) ; script = pull In Source ( bis , real Encoding ) ; } finally { try { in . close ( ) ; } catch (  IOException e ) { } } } } } catch (  File Not Found Exception fnf ) { fnf . print Stack Trace ( ) ; } return script ; }
@  Pre Persist public void pre Persist ( ) { lock Time =  System . current Time Millis ( ) ; }
public  Lib Padstack add (  String p_name ,  Shape Convex [ ] p_shapes , boolean p_attach_allowed , boolean p_placed_absolute ) { int pad_no = count ( ) + _ NUM ;  Lib Padstack new_padstack = new  Lib Padstack ( p_name , pad_no , p_shapes , p_attach_allowed , p_placed_absolute ) ; padstack_list . add ( new_padstack ) ; return new_padstack ; }
protected  Args Base ( ) { _argv = null ; _env = null ; }
@  Override public void start Content Model (  String element Name ,  Augmentations augs ) throws  XNIException { if ( f Validation ) { f DTDElement Decl Name = element Name ; f Mixed Element Types . clear ( ) ; } if ( f DTDGrammar != null ) f DTDGrammar . start Content Model ( element Name , augs ) ; if ( f DTDContent Model Handler != null ) { f DTDContent Model Handler . start Content Model ( element Name , augs ) ; } }
public  OMRange Rings (  Lat Lon Point center , double radius ,  Length units , int nverts ) { super ( center , radius , units , nverts ) ; center Point = create Center Point ( ) ; form . set Maximum Fraction Digits ( _ NUM ) ; }
public static  Input Source create Input Source (  String s ) { try { return new  Input Source ( new  Byte Array Input Stream ( s . get Bytes ( _ STR ) ) ) ; } catch (  Unsupported Encoding Exception e ) { throw new  Runtime Exception ( e ) ; } }
public static  String to Debug String ( final long socket Identifier ) { final int ip Bits = ( int ) socket Identifier ; final int port = extract Port Number ( socket Identifier ) ; final int inode = ( int ) ( socket Identifier > > _ NUM ) ; return  Integer . to Hex String ( ip Bits ) + _ STR + port + _ STR + inode ; }
@  Override public void on Album Update (  Provider Identifier provider , final  Album a ) throws  Remote Exception { if ( a == null ) {  Log . w (  TAG , _ STR ) ; return ; }  Album cached = m Cache . get Album ( a . get Ref ( ) ) ; boolean modified = _ BOOL ; if ( cached == null ) { m Cache . put Album ( provider , a ) ; cached = a ; modified = _ BOOL ; } else if ( ! cached . is Loaded ( ) || ! cached . is Identical ( a ) ) { cached . set Name ( a . get Name ( ) ) ; cached . set Year ( a . get Year ( ) ) ; cached . set Is Loaded ( a . is Loaded ( ) ) ; cached . set Provider ( a . get Provider ( ) ) ; if ( cached . get Songs Count ( ) != a . get Songs Count ( ) ) {  Iterator <  String > songs It = a . songs ( ) ; while ( songs It . has Next ( ) ) {  String song Ref = songs It . next ( ) ; cached . add Song ( song Ref ) ; } } modified = _ BOOL ; } if ( cached . get Provider ( ) == null ) {  Log . e (  TAG , _ STR + cached . get Ref ( ) + _ STR ) ; } if ( modified ) {  Iterator <  String > songs = a . songs ( ) ; while ( songs . has Next ( ) ) {  String song Ref = songs . next ( ) ;  Song song = retrieve Song ( song Ref , a . get Provider ( ) ) ; if ( song != null && song . is Loaded ( ) ) {  String artist Ref = song . get Artist ( ) ; if ( artist Ref != null ) {  Artist artist = retrieve Artist ( artist Ref , song . get Provider ( ) ) ; if ( artist != null ) { artist . add Album ( a . get Ref ( ) ) ; } else { if (  DEBUG )  Log . e (  TAG , _ STR ) ; } } } else { if (  DEBUG )  Log . e (  TAG , _ STR ) ; } } post Album For Update ( cached ) ; } }
public static  String read From File ( final  File path ) throws  IOException {  File Input Stream fis = null ; try { fis = new  File Input Stream ( path ) ; return read From File ( fis ) ; } finally { if ( fis != null ) { fis . close ( ) ; } } }
public static int  XTo Tile X ( int x , int tile Grid XOffset , int tile Width ) { x -= tile Grid XOffset ; if ( x < _ NUM ) { x += _ NUM - tile Width ; } return x / tile Width ; }
public  Input (  String name , @  Input Type int type , @  Alignment int align ,  Connection connection ) { m Name = name ; m Type = type ; m Align = align ; m Connection = connection ; if ( m Connection != null ) { m Connection . set Input ( this ) ; } }
public static  Bsh Class Manager create Class Manager (  Interpreter interpreter ) {  Bsh Class Manager manager ; if (  Capabilities . class Exists ( _ STR ) &&  Capabilities . class Exists ( _ STR ) &&  Capabilities . class Exists ( _ STR ) ) try {  Class clas =  Class . for Name ( _ STR ) ; manager = (  Bsh Class Manager ) clas . new Instance ( ) ; } catch (  Exception e ) { throw new  Interpreter Error ( _ STR + e ) ; } else manager = new  Bsh Class Manager ( ) ; if ( interpreter == null ) interpreter = new  Interpreter ( ) ; manager . declaring Interpreter = interpreter ; return manager ; }
public void request Last Login Time ( ) { operations . add (  Password Policy State Operation Type .  GET_ LAST_ LOGIN_ TIME ) ; }
public static  Stream <  String > words Of (  String text ) { require Non Null ( text ) ; return  WORDS . split As Stream ( text ) ; }
public  Joiner match (  String field ,  Object ... value ) { return match ( field ,  Arrays . as List ( value ) ) ; }
private  String remove You Tube Markup (  String plot ) { if ( plot == null ) return null ; return plot . replace All ( _ STR , _ STR ) ; }
private  String create Dash Array String (  List <  Float > dashes Array ) {  String Builder sb = new  String Builder ( ) ; if ( dashes Array != null ) { int index = _ NUM ; for (  Float value : dashes Array ) {  String str =  Float . to String ( value ) ; if ( str . ends With ( _ STR ) ) { sb . append ( value . int Value ( ) ) ; } else { sb . append ( value ) ; } if ( index < dashes Array . size ( ) - _ NUM ) { sb . append ( _ STR ) ; } index ++ ; } } return sb . to String ( ) ; }
public long position ( java . sql .  Blob pattern , long start ) throws  SQLException { return position ( pattern . get Bytes ( _ NUM , ( int ) pattern . length ( ) ) , start ) ; }
protected synchronized  T load ( ) throws  IOException { long gen Loaded = - _ NUM ;  IOException ioe = null ;  List <  String > gen Files = new  Array List <  String > ( ) ;  String [ ] files ; try { files = dir . list All ( ) ; } catch (  IOException ioe2 ) { return null ; }  T loaded = null ; for (  String file : files ) { if ( file . starts With ( prefix ) ) { long gen =  Long . parse Long ( file . substring ( prefix . length ( ) ) ) ; if ( gen Loaded == - _ NUM || gen > gen Loaded ) { gen Files . add ( file ) ;  Index Input in = dir . open Input ( file ,  IOContext .  DEFAULT ) ; try { loaded = load One ( in ) ; } catch (  IOException ioe2 ) { if ( ioe == null ) { ioe = ioe2 ; } } finally { in . close ( ) ; } gen Loaded = gen ; } } } if ( gen Loaded == - _ NUM ) { if ( ioe != null ) { throw ioe ; } } else { if ( gen Files . size ( ) > _ NUM ) {  String cur File Name = prefix + gen Loaded ; for (  String file : gen Files ) { long gen =  Long . parse Long ( file . substring ( prefix . length ( ) ) ) ; if ( can Delete ( gen ) && ! cur File Name . equals ( file ) ) { dir . delete File ( file ) ; } } } next Write Gen = _ NUM + gen Loaded ; } return loaded ; }
public static  String read Line (  Input Stream in ,  String charset ) throws  IOException {  Byte Array Output Stream baos = new  Byte Array Output Stream ( ) ; while ( _ BOOL ) { int b = in . read ( ) ; if ( b == - _ NUM ) { if ( baos . size ( ) == _ NUM ) { return null ; } else { break ; } } if ( b == _ STR ) { break ; } if ( b != _ STR ) { baos . write ( b ) ; continue ; } int b2 = in . read ( ) ; if ( b2 == - _ NUM ) { baos . write ( b ) ; break ; } if ( b2 == _ STR ) { break ; } baos . write ( b ) ; baos . write ( b2 ) ; } return baos . to String ( charset ) ; }
public boolean check Table Exists (  Table Definition table ) {  String column = null ; for (  Field Definition field : table . get Fields ( ) ) { if ( column == null ) { column = field . get Name ( ) ; } else if ( field . is Primary Key ( ) ) { column = field . get Name ( ) ; break ; } }  String sql = _ STR + column + _ STR + table . get Full Name ( ) + _ STR + column + _ STR + column ;  Data Read Query query = new  Data Read Query ( sql ) ; query . set Max Rows ( _ NUM ) ; try { session . execute Query ( query ) ; return _ BOOL ; } catch (  Exception not Found ) { return _ BOOL ; } finally { } }
private int process Colon ( int length ) { if ( _has Scheme ) { if ( ! read User Pass ( length ) && _buffer . length ( ) > _ NUM ) { _reader . go Back ( ) ; _buffer . delete ( _buffer . length ( ) - _ NUM , _buffer . length ( ) ) ; int backtrack On Fail = _reader . get Position ( ) - _buffer . length ( ) + length ; if ( ! read Domain Name ( _buffer . substring ( length ) ) ) { _reader . seek ( backtrack On Fail ) ; read End (  Read End State .  Invalid Url ) ; } length = _ NUM ; } } else if ( read Scheme ( ) && _buffer . length ( ) > _ NUM ) { _has Scheme = _ BOOL ; length = _buffer . length ( ) ; } else if ( _buffer . length ( ) > _ NUM && _options . has Flag (  Url Detector Options .  ALLOW_ SINGLE_ LEVEL_ DOMAIN ) && _reader . can Read Chars ( _ NUM ) ) { _reader . go Back ( ) ; _buffer . delete ( _buffer . length ( ) - _ NUM , _buffer . length ( ) ) ; read Domain Name ( _buffer . to String ( ) ) ; } else { read End (  Read End State .  Invalid Url ) ; length = _ NUM ; } return length ; }
public static boolean contains Sql Script Delimiters (  String script ,  String delim ) { boolean in Literal = _ BOOL ; char [ ] content = script . to Char Array ( ) ; for ( int i = _ NUM ; i < script . length ( ) ; i ++ ) { if ( content [ i ] == _ STR ) { in Literal = ! in Literal ; } if ( ! in Literal && script . starts With ( delim , i ) ) { return _ BOOL ; } } return _ BOOL ; }
public void compress ( byte [ ] bytes , int off , int len ,  Output Stream os ) { try { os . write ( bytes , off , len ) ; } catch (  IOException e ) { throw new  Runtime Exception ( e ) ; } }
public void assert Not Joined ( final  UUID service Id ) { m_triggers . add ( new  Quorum Event Invariant (  Quorum Event Enum .  SERVICE_ JOIN , service Id ) ) ; if ( is Member ( m_quorum . get Joined ( ) , service Id ) ) broken ( ) ; }
public final void print (  String value ) { try {  Element root Element = work Doc . get Default Root Element ( ) ; int delete Lines = root Element . get Element Count ( ) - lines Max ; for ( int index = _ NUM ; index < delete Lines ; index ++ ) {  Element elem = root Element . get Element ( _ NUM ) ; work Doc . remove ( elem . get Start Offset ( ) , elem . get End Offset ( ) ) ; } work Doc . insert String ( work Doc . get Length ( ) , value , null ) ; text Area . set Caret Position ( work Doc . get Length ( ) ) ; } catch (  Exception exc ) { exc . print Stack Trace ( ) ; } }
private void add Connection Groups (  Collection <  Connection Group > connection Groups ) { for (  Connection Group connection Group : connection Groups ) {  APIConnection Group parent = retrieved Groups . get ( connection Group . get Parent Identifier ( ) ) ; if ( parent != null ) {  Collection <  APIConnection Group > children = parent . get Child Connection Groups ( ) ; if ( children == null ) { children = new  Array List <  APIConnection Group > ( ) ; parent . set Child Connection Groups ( children ) ; }  APIConnection Group api Connection Group = new  APIConnection Group ( connection Group ) ; retrieved Groups . put ( connection Group . get Identifier ( ) , api Connection Group ) ; children . add ( api Connection Group ) ; } else logger . debug ( _ STR , connection Group . get Identifier ( ) , connection Group . get Parent Identifier ( ) ) ; } }
public void load Map (  Input Stream input ,  String group ID ) throws  Exception { shapes = parser . parse ( input , group ID ) ; boundaries = new  Array List <  Rect2 D > ( shapes . size ( ) ) ; for (  IGeometric2 D shape : shapes ) { boundaries . add ( shape . get Bounds ( ) ) ; } }
public void add Decoration (  Line Decoration decoration ) { if ( decoration != null ) { decorations . add ( decoration ) ; } }
private  String parse Link Title ( ) {  String title = match (  LINK_ TITLE ) ; if ( title != null ) { return  Escaping . unescape String ( title . substring ( _ NUM , title . length ( ) - _ NUM ) ) ; } else { return null ; } }
public void record SRDFOperation (  Db Client db Client ,  Operation Type Enum op Type ,  Operation .  Status status ,  Object ... ext Param ) { try { boolean op Status = (  Operation .  Status . ready == status ) ? _ BOOL : _ BOOL ;  String ev Type ; ev Type = op Type . get Ev Type ( op Status ) ;  String ev Desc = op Type . get Description ( ) ;  String op Stage =  Audit Log Manager .  AUDITOP_ END ; _logger . info ( _ STR , op Type . to String ( ) , ev Type . to String ( ) + _ STR + ev Desc ) ; record Bourne SRDFEvent ( db Client , get Id ( ) , ev Type , status , ev Desc ) ;  String id = (  String ) ext Param [ _ NUM ] ; switch ( op Type ) { case  CREATE_ SRDF_ LINK :  Audit Block Util . audit Block ( db Client , op Type , op Status , op Stage , ext Param ) ; break ; case  SUSPEND_ SRDF_ LINK :  Audit Block Util . audit Block ( db Client , op Type , op Status , op Stage , ext Param ) ; break ; case  DETACH_ SRDF_ LINK :  Audit Block Util . audit Block ( db Client , op Type , op Status , op Stage , ext Param ) ; break ; case  PAUSE_ SRDF_ LINK :  Audit Block Util . audit Block ( db Client , op Type , op Status , op Stage , ext Param ) ; break ; case  RESUME_ SRDF_ LINK :  Audit Block Util . audit Block ( db Client , op Type , op Status , op Stage , ext Param ) ; break ; case  FAILOVER_ SRDF_ LINK :  Audit Block Util . audit Block ( db Client , op Type , op Status , op Stage , ext Param ) ; break ; case  SWAP_ SRDF_ VOLUME :  Audit Block Util . audit Block ( db Client , op Type , op Status , op Stage , ext Param ) ; break ; case  STOP_ SRDF_ LINK :  Audit Block Util . audit Block ( db Client , op Type , op Status , op Stage , ext Param ) ; break ; case  SYNC_ SRDF_ LINK :  Audit Block Util . audit Block ( db Client , op Type , op Status , op Stage , ext Param ) ; break ; default : _logger . error ( _ STR ) ; } } catch (  Exception e ) { _logger . error ( _ STR , op Type . to String ( ) , e ) ; } }
@  Override public void put ( double val ) { final double nn = this . n + _ NUM ; final double delta = val - m1 ; final double delta_nn = delta / nn ; final double delta_nn2 = delta_nn * delta_nn ; final double inc = delta * delta_nn * this . n ; m4 += inc * delta_nn2 * ( nn * nn - _ NUM * nn + _ NUM ) + _ NUM * delta_nn2 * m2 - _ NUM * delta_nn * m3 ; m3 += inc * delta_nn * ( nn - _ NUM ) - _ NUM * delta_nn * m2 ; m2 += inc ; m1 += delta_nn ; n = nn ; min =  Math . min ( min , val ) ; max =  Math . max ( max , val ) ; }
public void close ( ) { this . closed = _ BOOL ; }
public int size ( ) { return m_ Recent Items . size ( ) ; }
public  Destructurer ( final  Tree .  Pattern that , final  Generate Js Visitor gen , final  Set <  Declaration > direct Access , final  String expvar , boolean first , final boolean for Assert ) { this . gen = gen ; jsw = gen == null ? null : gen . out ; names = gen == null ? null : gen . get Names ( ) ; this . direct Access = direct Access ; this . expvar = expvar ; this . first = first ; this . for Assert = for Assert ; that . visit ( this ) ; if ( jsw != null && ! attribs . is Empty ( ) ) { for (  Value attr : attribs ) { jsw . write ( _ STR , names . self ( (  Type Declaration ) attr . get Container ( ) ) , _ STR , names . name ( attr ) , _ STR , names . name ( attr ) ) ; } } }
@  Suppress Warnings ( _ STR ) public void handle Tbl Sub Config Button Delete Request (  Request Invocation Event event ) throws  Model Control Exception { submit Cycle = _ BOOL ;  CCAction Table tbl = (  CCAction Table ) get Child (  TBL_ SUB_ CONFIG ) ; tbl . restore State Data ( ) ;  CCAction Table Model tbl Model = (  CCAction Table Model ) tbl . get Model ( ) ;  Integer [ ] selected = tbl Model . get Selected Rows ( ) ;  Serialized Field sz Cache = (  Serialized Field ) get Child (  SZ_ CACHE ) ;  List list = sz Cache . get Serialized Obj ( ) ;  Set <  String > names = new  Hash Set < > ( selected . length * _ NUM ) ; for (  Integer index : selected ) {  SMSub Config sc = (  SMSub Config ) list . get ( index ) ; names . add ( sc . get Name ( ) ) ; } try {  Abstract Audit Model model = (  Abstract Audit Model ) get Model ( ) ; model . delete Event Handles ( names ) ; if ( selected . length == _ NUM ) { set Inline Alert Message (  TYPE_ INFO ,  INFORMATION_ MESSAGE , _ STR ) ; } else { set Inline Alert Message (  TYPE_ INFO ,  INFORMATION_ MESSAGE , _ STR ) ; } } catch (  AMConsole Exception e ) { set Inline Alert Message (  TYPE_ ERROR ,  ERROR_ MESSAGE , e . get Message ( ) ) ; } submit Cycle = _ BOOL ; forward To ( ) ; }
private void init ( ) { set Title ( _ STR ) ; hop Properties Panel = new  Hopfield Properties Panel ( network Panel ) ; hop Properties Panel . fill Field Values ( ) ; tab Logic . set Layout ( new  Flow Layout ( ) ) ; tab Logic . add ( hop Properties Panel ) ; tab Layout . add ( layout Panel ) ; layout Panel = new  Main Layout Panel ( _ BOOL , this ) ; tabbed Pane . add Tab ( _ STR , tab Logic ) ; tabbed Pane . add Tab ( _ STR , layout Panel ) ; set Content Pane ( tabbed Pane ) ;  Action help Action = new  Show Help Action ( hop Properties Panel . get Help Path ( ) ) ; add Button ( new  JButton ( help Action ) ) ; }
private double norm Vector ( double [ ] z ) { double sum = _ NUM ; for ( int i = _ NUM ; i < problem . get Number Of Objectives ( ) ; i ++ ) { sum += z [ i ] * z [ i ] ; } return  Math . sqrt ( sum ) ; }
public int hash Code ( ) { return _ NUM * factor . hash Code ( ) + lag ; }
public void deserialize Archived Versions ( ) throws  Runtime Exception {  System . out . println ( _ STR + get Archive Directory ( ) + _ STR ) ;  File archive = new  File ( get Archive Directory ( ) ) ; if ( ! archive . exists ( ) || ! archive . is Directory ( ) ) { return ; }  String [ ] listing = archive . list ( ) ; for (  String archive Name : listing ) { if ( ! ( archive Name . ends With ( _ STR ) ) ) { continue ; } try {  File file = new  File ( get Archive Directory ( ) , archive Name ) ;  Zip File zip File = new  Zip File ( file ) ;  Zip Entry entry = zip File . get Entry ( _ STR ) ;  Input Stream input Stream = zip File . get Input Stream ( entry ) ;  Object Input Stream object In = new  Object Input Stream ( input Stream ) ;  Map <  String ,  List <  String > > class Fields = (  Map <  String ,  List <  String > > ) object In . read Object ( ) ; zip File . close ( ) ; for (  String class Name : class Fields . key Set ( ) ) {  List <  String > field Names = class Fields . get ( class Name ) ;  Class < ? > clazz =  Class . for Name ( class Name ) ;  Object Stream Class stream Class =  Object Stream Class . lookup ( clazz ) ; if ( stream Class == null ) {  System . out . println ( ) ; } for (  String field Name : field Names ) { assert stream Class != null ;  Object Stream Field field = stream Class . get Field ( field Name ) ; if ( field == null ) { throw new  Runtime Exception ( _ STR + field Name + _ STR + class Name + _ STR + _ STR + _ STR + class Name + _ STR + archive Name + _ STR ) ; } } } } catch (  Class Not Found Exception e ) { throw new  Runtime Exception ( _ STR + archive Name + _ STR , e ) ; } catch (  IOException e ) { throw new  Runtime Exception ( _ STR + archive Name + _ STR , e ) ; }  System . out . println ( _ STR + archive Name + _ STR ) ;  Zip Entry zip Entry = null ; try {  File file = new  File ( get Archive Directory ( ) , archive Name ) ;  File Input Stream in = new  File Input Stream ( file ) ;  Zip Input Stream zipinputstream = new  Zip Input Stream ( in ) ; while ( ( zip Entry = zipinputstream . get Next Entry ( ) ) != null ) { if ( ! zip Entry . get Name ( ) . ends With ( _ STR ) ) { continue ; }  Object Input Stream object In = new  Object Input Stream ( zipinputstream ) ; object In . read Object ( ) ; zipinputstream . close Entry ( ) ; } zipinputstream . close ( ) ; } catch (  Class Not Found Exception e ) { throw new  Runtime Exception ( _ STR + zip Entry . get Name ( ) + _ STR + archive Name + _ STR + _ STR + _ STR , e ) ; } catch (  IOException e ) { throw new  Runtime Exception ( _ STR + archive Name + _ STR , e ) ; } }  System . out . println ( _ STR ) ; }
private void convert Maximal To Minimal Edge Rings (  List ring Edges ) { for (  Iterator i = ring Edges . iterator ( ) ; i . has Next ( ) ; ) {  Polygonize Directed Edge de = (  Polygonize Directed Edge ) i . next ( ) ; long label = de . get Label ( ) ;  List int Nodes = find Intersection Nodes ( de , label ) ; if ( int Nodes == null ) continue ; for (  Iterator i Node = int Nodes . iterator ( ) ; i Node . has Next ( ) ; ) {  Node node = (  Node ) i Node . next ( ) ; compute Next CCWEdges ( node , label ) ; } } }
public byte [ ] generate MAC ( byte command Class , byte [ ] ciphertext , byte sending Node , byte receiving Node , byte [ ] iv ) throws  General Security Exception { trace Hex ( _ STR , ciphertext ) ; trace Hex ( _ STR , iv ) ; int buffer Size = ciphertext . length + _ NUM ; byte [ ] buffer = new byte [ buffer Size ] ; byte [ ] temp Auth = new byte [ _ NUM ] ; buffer [ _ NUM ] = command Class ; buffer [ _ NUM ] = sending Node ; buffer [ _ NUM ] = receiving Node ; buffer [ _ NUM ] = ( byte ) ciphertext . length ;  System . arraycopy ( ciphertext , _ NUM , buffer , _ NUM , ciphertext . length ) ; trace Hex ( _ STR , network Key . get Encoded ( ) ) ; trace Hex ( _ STR , buffer ) ;  Cipher encrypt Cipher =  Cipher . get Instance ( _ STR ) ; encrypt Cipher . init (  Cipher .  ENCRYPT_ MODE , auth Key ) ; temp Auth = encrypt Cipher . do Final ( iv ) ; trace Hex ( _ STR , temp Auth ) ; byte [ ] encpck = new byte [ _ NUM ] ; int block = _ NUM ; for ( int i = _ NUM ; i < buffer Size ; i ++ ) { encpck [ block ] = buffer [ i ] ; block ++ ; if ( block == _ NUM ) { for ( int j = _ NUM ; j < _ NUM ; j ++ ) { temp Auth [ j ] = ( byte ) ( encpck [ j ] ^ temp Auth [ j ] ) ; encpck [ j ] = _ NUM ; }  Arrays . fill ( encpck , ( byte ) _ NUM ) ; block = _ NUM ; encrypt Cipher . init (  Cipher .  ENCRYPT_ MODE , auth Key ) ; temp Auth = encrypt Cipher . do Final ( temp Auth ) ; } } if ( block > _ NUM ) { for ( int i = _ NUM ; i < _ NUM ; i ++ ) { temp Auth [ i ] = ( byte ) ( encpck [ i ] ^ temp Auth [ i ] ) ; } encrypt Cipher . init (  Cipher .  ENCRYPT_ MODE , auth Key ) ; temp Auth = encrypt Cipher . do Final ( temp Auth ) ; } trace Hex ( _ STR , temp Auth ) ; byte [ ] mac = new byte [ _ NUM ] ;  System . arraycopy ( temp Auth , _ NUM , mac , _ NUM , _ NUM ) ; return mac ; }
public void remove Event Listener (  Image Sharing Listener listener ) throws  Rcs Service Not Available Exception ,  Rcs Generic Exception { if ( m Api == null ) { throw new  Rcs Service Not Available Exception ( ) ; } try {  Weak Reference <  IImage Sharing Listener > weak Ref = m Image Sharing Listeners . remove ( listener ) ; if ( weak Ref == null ) { return ; }  IImage Sharing Listener rcs Listener = weak Ref . get ( ) ; if ( rcs Listener != null ) { m Api . remove Event Listener2 ( rcs Listener ) ; } } catch (  Exception e ) {  Rcs Illegal Argument Exception . assert Exception ( e ) ; throw new  Rcs Generic Exception ( e ) ; } }
private void update Wave File Size ( ) throws  IOException {  Byte Buffer buffer = get Unsigned Integer Buffer ( m File Channel . size ( ) - _ NUM ) ; m File Channel . write ( buffer , _ NUM ) ;  Byte Buffer buffer2 = get Unsigned Integer Buffer ( m File Channel . size ( ) - _ NUM ) ; m File Channel . write ( buffer2 , _ NUM ) ; }
public boolean matches (  String sa ) { if ( _length != sa . length ( ) ) return _ BOOL ; char [ ] buffer = _buffer ; int offset = _offset ; for ( int i = _length - _ NUM ; i >= _ NUM ; i -- ) if ( _buffer [ _offset + i ] != sa . char At ( i ) ) return _ BOOL ; return _ BOOL ; }
@  Override public void mouse Released (  Mouse Event event ) { if ( event . get Source ( ) == get Component Decrease Spinner Button ( ) ) { decrease Timer . stop ( ) ; } else { increase Timer . stop ( ) ; } }
public double compute Max Class Value Using Percent Factor Per Series (  Default Chart Data chart Data ,  String [ ] series , double [ ] percent Factor Per Series ) { double max Value = _ NUM ; for (  String class Name : chart Data . get Class Names Including Disabled ( ) ) { double total = _ NUM ; for ( int i = _ NUM ; i < series . length ; i ++ ) {  String series Name = series [ i ] ; if ( transposed Heights Additive ) total += percent Factor Per Series [ i ] * chart Data . get Value As Double ( series Name , class Name ) ; else total =  Math . max ( total , percent Factor Per Series [ i ] * chart Data . get Value As Double ( series Name , class Name ) ) ; } if ( total > max Value ) { max Value = total ; } } return _ NUM * max Value ; }
public int add Channel (  Channel channel ) { int index = - _ NUM ; switch ( channel . get Channel Type ( ) ) { case  STANDARD : m Channels . add ( channel ) ; index = m Channels . size ( ) - _ NUM ; fire Table Rows Inserted ( index , index ) ; break ; case  TRAFFIC : m Traffic Channels . add ( channel ) ; index = m Channels . size ( ) - _ NUM ; break ; default : break ; } broadcast ( new  Channel Event ( channel ,  Event .  NOTIFICATION_ ADD ) ) ; if ( channel . get Enabled ( ) ) { broadcast ( new  Channel Event ( channel ,  Event .  REQUEST_ ENABLE ) ) ; } return index ; }
public static  String join (  Object ... array ) { if ( array == null ) { return null ; } if ( array . length == _ NUM ) { return  String Pool .  EMPTY ; } if ( array . length == _ NUM ) { return  String . value Of ( array [ _ NUM ] ) ; } final  String Builder sb = new  String Builder ( array . length * _ NUM ) ; for ( int i = _ NUM ; i < array . length ; i ++ ) { sb . append ( array [ i ] ) ; } return sb . to String ( ) ; }
public boolean has Trait ( final  Store Trait store Trait ) { final  Set <  Store Trait > traits = get Traits ( ) ; return null != traits && traits . contains ( store Trait ) ; }
public void create Supply (  MWMIn Out Bound Line boundline ,  Big Decimal qty Supply ) {  MProduct product =  MProduct . get ( boundline . get Ctx ( ) , boundline . get M_ Product_ ID ( ) ) ; if ( product . is BOM ( ) ) { create MO ( boundline , product , qty Supply ) ; } else if ( product . is Purchased ( ) ) { create Requisition ( boundline , product , qty Supply ) ; } }
public  List <  Local Time > top ( int n ) {  List <  Local Time > top = new  Array List < > ( ) ; int [ ] values = data . to Int Array ( ) ;  Int Arrays . parallel Quick Sort ( values ,  Reverse Int Comparator . instance ( ) ) ; for ( int i = _ NUM ; i < n && i < values . length ; i ++ ) { top . add (  Packed Local Time . as Local Time ( values [ i ] ) ) ; } return top ; }
@  Override public void load XML (  Node stepnode ,  List <  Database Meta > databases ,  Map <  String ,  Counter > counters ) throws  Kettle XMLException { try { schema Name =  XMLHandler . get Tag Value ( stepnode , _ STR ) ; tabel Name =  XMLHandler . get Tag Value ( stepnode , _ STR ) ; mdkey Size =  XMLHandler . get Tag Value ( stepnode , _ STR ) ; measure Count =  XMLHandler . get Tag Value ( stepnode , _ STR ) ; heir And Key Size =  XMLHandler . get Tag Value ( stepnode , _ STR ) ; cube Name =  XMLHandler . get Tag Value ( stepnode , _ STR ) ; group By Enabled =  XMLHandler . get Tag Value ( stepnode , _ STR ) ; aggregator Class String =  XMLHandler . get Tag Value ( stepnode , _ STR ) ; aggregator String =  XMLHandler . get Tag Value ( stepnode , _ STR ) ; fact Dim Lens String =  XMLHandler . get Tag Value ( stepnode , _ STR ) ; level Anddata Type String =  XMLHandler . get Tag Value ( stepnode , _ STR ) ; current Restruct Number =  Integer . parse Int (  XMLHandler . get Tag Value ( stepnode , _ STR ) ) ; partition ID =  XMLHandler . get Tag Value ( stepnode , _ STR ) ; segment Id =  XMLHandler . get Tag Value ( stepnode , _ STR ) ; task No =  XMLHandler . get Tag Value ( stepnode , _ STR ) ; } catch (  Exception e ) { throw new  Kettle XMLException ( _ STR , e ) ; } }
public void read Data (  Data Input din ) throws  IOException { reference = din . read Unsigned Short ( ) ; }
public float dot Product (  Dense Vector df ) { float res = _ NUM ; for ( int i = _ NUM ; i <  Math . min ( size , df . get Length ( ) ) ; i ++ ) { res += u [ i ] * df . u [ i ] ; } return res ; }
public static double st Dev ( final  List <  Double > list ) { return  Math . sqrt ( variance ( list ) ) ; }
public void trim To Size ( ) { if ( size < array . length ) { int [ ] olddata = array ; array = new int [ size ] ;  System . arraycopy ( olddata , _ NUM , array , _ NUM , size ) ; } }
public static int compare (  Date left , boolean right ) { return compare ( left , right ? _ NUM : _ NUM ) ; }
private  IBinding Set [ ] decode Next Chunk ( ) throws  IOException { if ( nsolutions == solution Set Count ) { if ( log . is Debug Enabled ( ) ) log . debug ( _ STR + name + _ STR + nsolutions ) ; return null ; } in . read Int ( ) ; final int chunk Size = in . read Int ( ) ; final int byte Length = in . read Int ( ) ; final byte [ ] a = new byte [ byte Length ] ; in . read Fully ( a ) ; final  Data Input Buffer buf = new  Data Input Buffer ( a ) ; final  IBinding Set [ ] t = new  IBinding Set [ chunk Size ] ; for ( int i = _ NUM ; i < chunk Size ; i ++ ) { t [ i ] = decoder . decode Solution ( buf , _ BOOL ) ; if ( log . is Trace Enabled ( ) ) log . trace ( _ STR + name + _ STR + t [ i ] ) ; } nsolutions += chunk Size ; if ( log . is Trace Enabled ( ) ) log . trace ( _ STR + name + _ STR + chunk Size + _ STR + (  Solution Set Stream Encoder .  CHUNK_ HEADER_ SIZE + byte Length ) + _ STR + nsolutions ) ; return t ; }
public  UDPClient Socket (  Logger logger ) { this . logger = logger ; try { socket = new  Datagram Socket ( ) ; socket . set Broadcast ( _ BOOL ) ; socket . set Send Buffer Size ( _ NUM * _ NUM * _ NUM ) ; socket . set Receive Buffer Size ( _ NUM * _ NUM * _ NUM ) ; socket . set So Timeout ( _ NUM ) ; } catch (  Socket Exception e ) { logger . severe ( _ STR ) ; logger . severe ( _ STR + e . get Message ( ) ) ;  System . exit ( _ NUM ) ; } }
public void multiply All Values By ( final double multiply By , final int  Round Type ) { for ( final  T t : key Set ( ) ) { double val = map Values . get ( t ) ; switch (  Round Type ) { case _ NUM : val =  Math . floor ( val * multiply By ) ; break ; case _ NUM : val =  Math . round ( val * multiply By ) ; break ; case _ NUM : val =  Math . ceil ( val * multiply By ) ; break ; default : val = val * multiply By ; break ; } put ( t , ( int ) val ) ; } }
public static boolean is Level (  Level level ) { if ( level == null ) return _ BOOL ; return level . int Value ( ) >= s_current Level . int Value ( ) ; }
protected void compute Folder Children (  File folder , boolean is Included ,  String [ ] pkg Name ,  Array List v Children , char [ ] [ ] inclusion Patterns , char [ ] [ ] exclusion Patterns ) throws  Java Model Exception { if ( is Included ) {  IPackage Fragment pkg = get Package Fragment ( pkg Name ) ; v Children . add ( pkg ) ; } try {  File [ ] members = folder . list Files ( ) ; boolean has Included = is Included ; int length = members . length ; if ( length > _ NUM ) {  Java Project java Project = (  Java Project ) get Java Project ( ) ;  String source Level = java Project . get Option (  Java Core .  COMPILER_ SOURCE , _ BOOL ) ;  String compliance Level = java Project . get Option (  Java Core .  COMPILER_ COMPLIANCE , _ BOOL ) ; for ( int i = _ NUM ; i < length ; i ++ ) {  File member = members [ i ] ;  String member Name = member . get Name ( ) ; if ( member . is Directory ( ) ) { if (  Util . is Valid Folder Name For Package ( member Name , source Level , compliance Level ) ) {  String [ ] new Names =  Util . array Concat ( pkg Name , manager . intern ( member Name ) ) ; boolean is Member Included = _ BOOL ; compute Folder Children ( member , is Member Included , new Names , v Children , inclusion Patterns , exclusion Patterns ) ; } } else { if ( ! has Included &&  Util . is Valid Compilation Unit Name ( member Name , source Level , compliance Level ) ) { has Included = _ BOOL ;  IPackage Fragment pkg = get Package Fragment ( pkg Name ) ; v Children . add ( pkg ) ; } } } } } catch (  Illegal Argument Exception e ) { throw new  Java Model Exception ( e ,  IJava Model Status Constants .  ELEMENT_ DOES_ NOT_ EXIST ) ; } catch (  Core Exception e ) { throw new  Java Model Exception ( e ) ; } }
public static  String quote (  File input ) { return quote ( input . get Absolute Path ( ) ) ; }
private void read From Net ( ) throws  Ignite Checked Exception { try { in Net Buf . clear ( ) ; int read = ch . read ( in Net Buf ) ; if ( read == - _ NUM ) throw new  Ignite Checked Exception ( _ STR ) ; } catch (  IOException e ) { throw new  Ignite Checked Exception ( _ STR , e ) ; } }
synchronized void clear ( ) { maps = new  Maps ( ) ; tombstones . clear ( ) ; ram Bytes Used Current . set ( _ NUM ) ; if ( mgr != null ) { mgr . remove Listener ( this ) ; mgr = null ; } }
public synchronized void remove Consumer (  Image Consumer ic ) { ics . remove Element ( ic ) ; }
private void update Aperture ( int new Value , long now ) { int previous = target Aperture ; target Aperture = new Value ; target Aperture =  Math . max ( min Aperture , target Aperture ) ; int max Aperture =  Math . min ( this . max Aperture , active Sockets . size ( ) + active Factories . size ( ) ) ; target Aperture =  Math . min ( max Aperture , target Aperture ) ; last Aperture Refresh = now ; pendings . reset ( ( min Pendings + max Pendings ) / _ NUM ) ; if ( target Aperture != previous ) { logger . debug ( _ STR , pendings . value ( ) , target Aperture , previous ) ; } }
public  I build Invocation (  Object protocol Key ,  I invocation ) throws  Config Exception {  Objects . require Non Null ( invocation ) ; invocation = build Invocation ( invocation ) ;  Lru Cache <  Object ,  I > invocation Cache = _invocation Cache ; if ( invocation Cache != null ) {  I old Invocation ; old Invocation = invocation Cache . get ( protocol Key ) ; if ( old Invocation != null && ! old Invocation . is Modified ( ) ) { return old Invocation ; } if ( invocation . get URLLength ( ) < _max URLLength ) { invocation Cache . put ( protocol Key , invocation ) ; } } return invocation ; }
public void test King Capture ( ) throws  Chess Parse Error {  Position pos =  Text IO . read FEN ( _ STR ) ; pos . set White Move ( _ BOOL ) ;  List <  String > str Moves = get Move List ( pos , _ BOOL ) ; assert Equals ( _ NUM , str Moves . size ( ) ) ; assert Equals ( _ STR , str Moves . get ( _ NUM ) ) ; pos . set Piece (  Position . get Square ( _ NUM , _ NUM ) ,  Piece .  WBISHOP ) ; pos . set Piece (  Position . get Square ( _ NUM , _ NUM ) ,  Piece .  WPAWN ) ; str Moves = get Move List ( pos , _ BOOL ) ; assert Equals ( _ NUM , str Moves . size ( ) ) ; assert Equals ( _ STR , str Moves . get ( _ NUM ) ) ; pos . set Piece (  Position . get Square ( _ NUM , _ NUM ) ,  Piece .  WPAWN ) ; pos . set Piece (  Position . get Square ( _ NUM , _ NUM ) ,  Piece .  WPAWN ) ; str Moves = get Move List ( pos , _ BOOL ) ; assert Equals ( _ NUM , str Moves . size ( ) ) ; assert Equals ( _ STR , str Moves . get ( _ NUM ) ) ; }
public static  Binary Message check And Correct (  Binary Message message , int start Index ) { boolean parity Error = message . cardinality ( ) % _ NUM != _ NUM ; int syndrome = get Syndrome ( message , start Index ) ; if ( syndrome == _ NUM ) { if ( parity Error ) { message . flip ( start Index + _ NUM ) ; } message . set CRC (  CRC .  PASSED ) ; return message ; } int original = message . get Int ( _ NUM , _ NUM ) ; int index = - _ NUM ; int syndrome Weight = _ NUM ; int errors = _ NUM ; while ( index < _ NUM ) { if ( index != - _ NUM ) { if ( index > _ NUM ) { message . flip ( index - _ NUM ) ; } message . flip ( index ) ; syndrome Weight = _ NUM ; } syndrome = get Syndrome ( message , start Index ) ; if ( syndrome > _ NUM ) { for ( int i = _ NUM ; i < _ NUM ; i ++ ) { errors =  Integer . bit Count ( syndrome ) ; if ( errors <= syndrome Weight ) { message . xor ( _ NUM , _ NUM , syndrome ) ; message . rotate Right ( i , start Index , start Index + _ NUM ) ; if ( index >= _ NUM ) { errors ++ ; } int corrected = message . get Int ( _ NUM , _ NUM ) ; if (  Integer . bit Count ( original ^ corrected ) > _ NUM ) { message . set CRC (  CRC .  FAILED_ CRC ) ; return message ; } message . set CRC (  CRC .  PASSED ) ; return message ; } else { message . rotate Left ( start Index , start Index + _ NUM ) ; syndrome = get Syndrome ( message , start Index ) ; } } index ++ ; } } message . set CRC (  CRC .  FAILED_ CRC ) ; return message ; }
public static  List <  Object > validate And Evaluate (  String view Name ,  Statement Context statement Context ,  List <  Expr Node > expressions ) throws  View Parameter Exception {  List <  Object > results = new  Array List <  Object > ( ) ; int expression Number = _ NUM ;  Stream Type Service stream Type Service = new  Stream Type Service Impl ( statement Context . get Engine URI ( ) , _ BOOL ) ; for (  Expr Node expr : expressions ) {  Object result = validate And Evaluate Expr ( view Name , statement Context , expr , stream Type Service , expression Number ) ; results . add ( result ) ; expression Number ++ ; } return results ; }
@  Not Null public static  String parse Relative Directory ( @  Not Null  String s ) throws  Svn Bind Exception { s = s . trim ( ) ; int length = s . length ( ) ;  String result ; if ( is Unescaped Quote ( s , length - _ NUM ) ) { int index = last Unescaped Index Of ( s , length - _ NUM , _ STR ) ; assert Index ( s , index , _ STR ) ; result = s . substring ( index + _ NUM , length - _ NUM ) ; } else { int index = last Unescaped Index Of ( s , length , _ STR ) ; assert Index ( s , index , _ STR ) ; result = s . substring ( index + _ NUM ) ; } return unescape ( result ) ; }
@  Override public  String generate URL (  Category Dataset dataset , int series , int category ) {  String url = this . prefix ;  Comparable series Key = dataset . get Row Key ( series ) ;  Comparable category Key = dataset . get Column Key ( category ) ; boolean first Parameter = ! url . contains ( _ STR ) ; url += first Parameter ? _ STR : _ STR ; try { url += this . series Parameter Name + _ STR +  URLEncoder . encode ( series Key . to String ( ) , _ STR ) ; url += _ STR + this . category Parameter Name + _ STR +  URLEncoder . encode ( category Key . to String ( ) , _ STR ) ; } catch (  Unsupported Encoding Exception ex ) { throw new  Runtime Exception ( ex ) ; } return url ; }
public boolean is Idle Expire ( ) { if ( ! _lifecycle . is Active ( ) ) return _ BOOL ; long now = current Time Actual ( ) ; long idle Expire = _thread Idle Expire Time . get ( ) ; int idle Count = _idle Count . get ( ) ; if ( _idle Min < idle Count ) { long next Idle Expire = now + _idle Timeout ; if ( _idle Max < idle Count && _idle Min < _idle Max ) { _thread Idle Expire Time . compare And Set ( idle Expire , next Idle Expire ) ; return _ BOOL ; } else if ( idle Expire < now && _thread Idle Expire Time . compare And Set ( idle Expire , next Idle Expire ) ) { return _ BOOL ; } } return _ BOOL ; }
public void begin Display (  Display Event event ) throws  Model Control Exception {  Identity Subject Model subject Model = get Subject Model ( ) ;  Policy Model model = (  Policy Model ) get Model ( ) ; super . begin Display ( event ) ;  CCDrop Down Menu menu = (  CCDrop Down Menu ) get Child (  FILTER_ TYPE ) ;  Map supported Entity Types = model . get Supported Entity Types ( realm Name ) ;  Option List entity Types = create Option List ( supported Entity Types ) ; entity Types . add ( _ NUM , _ STR , _ STR ) ; menu . set Options ( entity Types ) ; menu . set Value ( _ STR ) ;  CCAdd Remove child = (  CCAdd Remove ) get Child (  VALUES_ MULTIPLE_ CHOICE_ VALUE ) ; child . restore State Data ( ) ;  Option List selected = add Remove Model . get Selected Option List ( ) ;  Option List possible = helper . create Option List ( model . get User SSOToken ( ) , model . get User Locale ( ) , this , get Possible Values ( subject Model , realm Name ) ) ; child . reset State Data ( ) ; add Remove Model . set Available Option List ( possible ) ; }
private void decode64 (  Byte Buffer infile ,  Long Array Pointer a ) { byte [ ] nbitplanes = new byte [  N03 ] ; byte [ ] tmagic = new byte [ _ NUM ] ; infile . get ( tmagic ) ; if ( tmagic [ _ NUM ] !=  CODE_ MAGIC [ _ NUM ] || tmagic [ _ NUM ] !=  CODE_ MAGIC [ _ NUM ] ) { throw new  Runtime Exception ( _ STR ) ; } this . nx = infile . get Int ( ) ; this . ny = infile . get Int ( ) ; this . scale = infile . get Int ( ) ; long sumall = infile . get Long ( ) ; infile . get ( nbitplanes ) ; dodecode64 ( infile , a , nbitplanes ) ; a . set ( _ NUM , sumall ) ; }
private static void create Script ( ) throws  Exception {  Class . for Name ( _ STR ) ;  Connection conn =  Driver Manager . get Connection ( _ STR ) ;  Statement stat = conn . create Statement ( ) ; stat . execute ( _ STR ) ; stat . execute ( _ STR ) ; stat . execute ( _ STR ) ; stat . close ( ) ; conn . close ( ) ; }
public void add Job Group To Never Delete (  String group ) { if ( group != null ) job Groups To Never Delete . add ( group ) ; }
private  Web Doc create Layout (  Web Doc doc ,  MWorkflow wf , int active Node ,  MWFNode [ ] nodes ,  Array List nodes_ ID , int [ ] [ ] image Map ) { body b = doc . get Body ( ) ; b . add Element ( print Workflow ( active Node , wf , nodes , nodes_ ID , image Map ) ) ; b . add Element ( new hr ( ) ) ; b . add Element ( print Description ( active Node , wf , nodes , nodes_ ID ) ) ; b . add Element ( new br ( ) ) ; b . add Element ( print Control Panel ( active Node , wf , nodes , nodes_ ID ) ) ; return doc ; }
@  Override public void request Poll Read ( ) { try { request Loop ( ) ; } catch (  Exception e ) { log . log (  Level .  WARNING , e . to String ( ) , e ) ; } }
public  Multi Match Query Builder field (  String field ) { fields . add ( field ) ; return this ; }
void encode (  Output Stream os , boolean include_h ) throws  IOException { int q = params . q ; os . write ( get Encoded ( f ) ) ; if ( params . basis Type ==  NTRUSigning Key Generation Parameters .  BASIS_ TYPE_ STANDARD ) {  Integer Polynomial f Prime Int = f Prime . to Integer Polynomial ( ) ; for ( int i = _ NUM ; i < f Prime Int . coeffs . length ; i ++ ) { f Prime Int . coeffs [ i ] += q / _ NUM ; } os . write ( f Prime Int . to Binary ( q ) ) ; } else { os . write ( get Encoded ( f Prime ) ) ; } if ( include_h ) { os . write ( h . to Binary ( q ) ) ; } }
private void signal No Acks ( ) { lock . lock ( ) ; try { all Acks Rcv Cond . signal All ( ) ; } finally { lock . unlock ( ) ; } }
private static  String array To String ( int [ ] array ) {  String Builder sb = new  String Builder ( ) ; boolean first = _ BOOL ; for ( int i : array ) { if ( first ) { first = _ BOOL ; } else { sb . append ( _ STR ) ; } sb . append ( i ) ; } return sb . to String ( ) ; }
public static byte [ ] copy ( byte [ ] source , byte [ ] target ) { int len = source . length ; if ( len > target . length ) { target = new byte [ len ] ; }  System . arraycopy ( source , _ NUM , target , _ NUM , len ) ; return target ; }
public double great Circle Distance (  Location location ) { if ( location == null ) { throw new  Illegal Argument Exception (  Logger . log Message (  Logger .  ERROR , _ STR , _ STR , _ STR ) ) ; } double lat1 Radians =  Math . to Radians ( this . latitude ) ; double lon1 Radians =  Math . to Radians ( this . longitude ) ; double lat2 Radians =  Math . to Radians ( location . latitude ) ; double lon2 Radians =  Math . to Radians ( location . longitude ) ; if ( lat1 Radians == lat2 Radians && lon1 Radians == lon2 Radians ) { return _ NUM ; } double a =  Math . sin ( ( lat2 Radians - lat1 Radians ) / _ NUM ) ; double b =  Math . sin ( ( lon2 Radians - lon1 Radians ) / _ NUM ) ; double c = a * a +  Math . cos ( lat1 Radians ) *  Math . cos ( lat2 Radians ) * b * b ; double distance Radians = _ NUM *  Math . asin (  Math . sqrt ( c ) ) ; return  Double . is Na N ( distance Radians ) ? _ NUM : distance Radians ; }
private  List <  Input Split > parse Manifest (  File System fs ,  Path manifest Path ,  Job Conf job ) throws  IOException {  List <  Input Split > splits = null ;  FSData Input Stream fp = fs . open ( manifest Path ) ;  Json Reader reader = new  Json Reader ( new  Input Stream Reader ( fp ,  Charsets .  UTF_8 ) ) ; reader . begin Object ( ) ; while ( reader . has Next ( ) ) {  String name = reader . next Name ( ) ; switch ( name ) { case  VERSION_ JSON_ KEY : job . set (  Dynamo DBConstants .  EXPORT_ FORMAT_ VERSION ,  String . value Of ( reader . next Int ( ) ) ) ; break ; case  ENTRIES_ JSON_ KEY : splits = read Entries ( reader , job ) ; break ; default : log . info ( _ STR + name ) ; reader . skip Value ( ) ; break ; } } reader . end Object ( ) ; if ( splits == null ) { return  Collections . empty List ( ) ; } return splits ; }
public void fire Operator Moved (  Operator operator ) {  List <  Operator > list = new  Linked List < > ( ) ; list . add ( operator ) ; fire Operators Moved ( list ) ; }
@  Override public void modify Variable Id (  String old Id ,  String new Id ) { if ( base Var . equals ( old Id ) ) { base Var = new Id . replace ( _ STR , _ STR ) ; } }
public  Add User Fields ( ) { m_attribute Specs = new  Array List <  Attribute Spec > ( ) ; }
private  Integer parse Int (  String s , int flags ) { if ( convert Color Names ( flags ) ) {  String c =  Descriptor . convert Color Name ( s ) ; if ( c != null ) { s = c ; } } try { if ( has Leading Zeros ( s ) ) { return null ; } else { return  Integer . decode ( s ) ; } } catch (  Number Format Exception e ) { return null ; } }
protected void stop Workers (  Collection <  Worker Thread > workers ) { if ( workers == null ) { workers = this . workers ; } final  Iterator <  Worker Thread > iter = workers . iterator ( ) ; while ( iter . has Next ( ) ) { final  Worker Thread worker = iter . next ( ) ; if ( ( worker . get Status ( ) & (  Worker Thread . s ENDED |  Worker Thread . s ENDING ) ) == _ NUM ) { worker . signal Shutdown ( ) ; running Workers -- ; } } }
public  Array List <  Mapping > clone Frame ( ) { if ( stack [ top ] == null ) return null ;  Array List <  Mapping > clone = new  Array List <  Mapping > ( ) ; for (  Mapping map = top Of Frame ( ) ; map != null ; map = next ( ) ) { clone . add ( map ) ; } return clone ; }
private static int compute Hash Code ( int seed ,  Object ... objects ) { if ( objects == null || objects . length == _ NUM ) { return seed *  Hash Code .  PRIME ; } int hc = seed ; for (  Object object : objects ) { hc =  Hash Code .  PRIME * hc ; if ( object instanceof byte [ ] ) { hc +=  Arrays . hash Code ( ( byte [ ] ) object ) ; } else if ( object instanceof boolean [ ] ) { hc +=  Arrays . hash Code ( ( boolean [ ] ) object ) ; } else if ( object instanceof short [ ] ) { hc +=  Arrays . hash Code ( ( short [ ] ) object ) ; } else if ( object instanceof int [ ] ) { hc +=  Arrays . hash Code ( ( int [ ] ) object ) ; } else if ( object instanceof long [ ] ) { hc +=  Arrays . hash Code ( ( long [ ] ) object ) ; } else if ( object instanceof float [ ] ) { hc +=  Arrays . hash Code ( ( float [ ] ) object ) ; } else if ( object instanceof double [ ] ) { hc +=  Arrays . hash Code ( ( double [ ] ) object ) ; } else if ( object instanceof char [ ] ) { hc +=  Arrays . hash Code ( ( char [ ] ) object ) ; } else if ( object instanceof  Object [ ] ) { hc +=  Arrays . hash Code ( (  Object [ ] ) object ) ; } else if ( object != null ) { hc += object . hash Code ( ) ; } } return hc ; }
protected float calculate State Transition Percentage (  String name , boolean flapping ) { int flap Interval = get Flap Interval ( name ) ;  Linked List <  Boolean > list = get Flaps ( name ) ; float low Weight = get Flap Low Weight ( name ) ; float high Weight = get Flap High Weight ( name ) ; float weight Range = high Weight - low Weight ; float result = _ NUM ; for ( int i = list . size ( ) - _ NUM ; i >= _ NUM ; i -- ) { boolean this Flap = list . get ( i ) ; if ( flapping != this Flap ) { float weight = low Weight + ( weight Range * i / ( flap Interval - _ NUM ) ) ; result += weight ; } } return result / flap Interval ; }
public static  String mangle Name (  Method method , boolean is Full ) {  String Buffer sb = new  String Buffer ( ) ; sb . append ( method . get Name ( ) ) ;  Class [ ] params = method . get Parameter Types ( ) ; for ( int i = _ NUM ; i < params . length ; i ++ ) { sb . append ( _ STR ) ; sb . append ( mangle Class ( params [ i ] , is Full ) ) ; } return sb . to String ( ) ; }
private void save State ( ) { saved Start Offset = offset Attribute . start Offset ( ) ; saved End Offset = offset Attribute . end Offset ( ) ; has Illegal Offsets = ( saved End Offset - saved Start Offset != term Attribute . length ( ) ) ; saved Type = type Attribute . type ( ) ; if ( saved Buffer . length < term Attribute . length ( ) ) { saved Buffer = new char [  Array Util . oversize ( term Attribute . length ( ) ,  Character .  BYTES ) ] ; }  System . arraycopy ( term Attribute . buffer ( ) , _ NUM , saved Buffer , _ NUM , term Attribute . length ( ) ) ; iterator . text = saved Buffer ; has Saved State = _ BOOL ; }
private void print Out Defined IPs (  List <  String > defined IPs ) {  List <  String > ip List = new  Array List < > ( ) ; for (  String ip : defined IPs ) { if ( ip . index Of ( _ STR ) != - _ NUM ) { ip List . add ( _ STR + ip ) ; } else { ip List . add ( _ STR + ip ) ; } }  Collections . sort ( ip List ) ; for (  String ip : ip List ) { log . info ( ip ) ; } }
private void dispose Codec (  Io Session session ) { dispose Encoder ( session ) ; dispose Decoder ( session ) ; dispose Decoder Out ( session ) ; }
@  Override public  Object parse Object ( final  String source , final  Parse Position pos ) { return parser . parse Object ( source , pos ) ; }
@  Override public default  Stream <  Time Series Collection > stream ( ) { return  Stream Support . stream ( spliterator ( ) , _ BOOL ) ; }
private  Manifest Mod Info register Mod (  File file ,  Manifest manifest ) {  Manifest Mod Info mod = load Mod ( file , manifest ) ; if ( mod != null ) { if ( id Map . contains Key ( mod . get Mod ID ( ) ) ) {  Mod Info mod2 = id Map . get ( mod . get Mod ID ( ) ) ; duplicates . put ( mod . get Mod ID ( ) , mod ) ; duplicates . put ( mod . get Mod ID ( ) , mod2 ) ; log . error ( _ STR , mod . get Mod File ( ) , mod2 . get Mod File ( ) ) ; } else { mod List . add ( mod ) ; id Map . put ( mod . get Mod ID ( ) , mod ) ; } } return mod ; }
protected  Size2 D arrange NN (  Block Container container ,  Graphics2 D g2 ) {  List blocks = container . get Blocks ( ) ;  Block b = (  Block ) blocks . get ( _ NUM ) ;  Size2 D s = b . arrange ( g2 ,  Rectangle Constraint .  NONE ) ; b . set Bounds ( new  Rectangle2 D .  Double ( _ NUM , _ NUM , s . width , s . height ) ) ; return new  Size2 D ( s . width , s . height ) ; }
public static boolean is Content Type (  String content Type ,  Message message ) { if ( content Type == null ) { return message . get Content Type ( ) == null ; } else { return content Type . equals ( message . get Content Type ( ) ) ; } }
private static  X509 Certificate generate Certificate (  String dn , int days ,  String application Uri ,  Key Pair keys , org . opcfoundation . ua . transport . security .  Key Pair issuer Keys ,  String ... host Names ) throws  General Security Exception ,  IOException {  Private Key privkey = keys . get Private ( ) ;  Public Key public Key = keys . get Public ( ) ; return generate Certificate ( dn , days , application Uri , public Key , privkey , issuer Keys , host Names ) ; }
@  Suppress Warnings ( _ STR ) public void handle Button1 Request (  Request Invocation Event event ) throws  Model Control Exception { submit Cycle = _ BOOL ;  Abstract Audit Model model = (  Abstract Audit Model ) get Model ( ) ;  AMProperty Sheet ps = (  AMProperty Sheet ) get Child (  PROPERTY_ ATTRIBUTE ) ;  String sub Config Name = (  String ) get Page Session Attribute (  AUDIT_ HANDLER_ NAME ) ; try {  Map orig = model . get Event Handler Attribute Values ( sub Config Name ) ;  Map values = ps . get Attribute Values ( orig , _ BOOL , _ BOOL , model ) ; model . set Event Handler Attribute Values ( sub Config Name , values ) ; back To Profile View Bean ( ) ; } catch (  AMConsole Exception e ) { set Inline Alert Message (  TYPE_ ERROR ,  ERROR_ MESSAGE , e . get Message ( ) ) ; forward To ( ) ; } }
private  String check All Dependencies (  Hash Map <  String ,  Module Descriptor > modlist ) { for (  Module Descriptor md : modlist . values ( ) ) {  String res = check Dependencies ( md , modlist ) ; if ( ! res . is Empty ( ) ) { return res ; } } return _ STR ; }
public void children Removed (  Bean Context Membership Event bcme ) { for (  Iterator it = bcme . iterator ( ) ; it . has Next ( ) ; ) { find And Undo ( it . next ( ) ) ; } }
public static void check Directory Is Writeable ( @  Not Null  File directory ) throws  IOException { while ( ! directory . exists ( ) || ! directory . is Directory ( ) ) { directory = directory . get Parent File ( ) ; } if ( ! directory . can Write ( ) ) { throw new  IOException ( _ STR + directory . get Absolute Path ( ) ) ; } }
public  String to String ( ) {  String Builder s = new  String Builder ( ) ; boolean appended = _ BOOL ; if ( this . weeks != _ NUM || appended ) { appended = _ BOOL ; s . append ( this . weeks + _ STR ) ; } if ( this . days != _ NUM || appended ) { appended = _ BOOL ; s . append ( this . days + _ STR ) ; } if ( this . hours != _ NUM || appended ) { appended = _ BOOL ; s . append ( this . hours + _ STR ) ; } if ( this . minutes != _ NUM || appended ) { appended = _ BOOL ; s . append ( this . minutes + _ STR ) ; } if ( this . seconds != _ NUM || appended ) { appended = _ BOOL ; s . append ( this . seconds + _ STR ) ; } if ( this . milliseconds != _ NUM || appended ) { appended = _ BOOL ; s . append ( this . milliseconds + _ STR ) ; } return s . to String ( ) ; }
public static boolean is Java Keyword (  String name ) { return tokens . contains ( name ) ; }
protected  String extract Import Url ( final  Matcher matcher ) { return matcher . group (  INDEX_ URL ) ; }
@  Override public boolean equals (  Object that ) { if ( this == that ) { return _ BOOL ; } if ( that == null ) { return _ BOOL ; } if ( get Class ( ) != that . get Class ( ) ) { return _ BOOL ; }  Collator other = (  Collator ) that ; return ( ( strength == other . strength ) && ( decmp == other . decmp ) ) ; }
Type rename Type As Type (  Type type ) { if ( type == null ) { return null ; } if ( type . get Sort ( ) ==  Type .  OBJECT ) {  String in = type . get Internal Name ( ) ;  String new In = rename Internal Type ( in ) ; if ( new In != in ) { return  Type . get Type ( _ STR + new In + _ STR ) ; } } else if ( type . get Sort ( ) ==  Type .  ARRAY ) {  String Builder sb = new  String Builder ( ) ; for ( int n = type . get Dimensions ( ) ; n > _ NUM ; n -- ) { sb . append ( _ STR ) ; } sb . append ( rename Type ( type . get Element Type ( ) ) ) ; return  Type . get Type ( sb . to String ( ) ) ; } return type ; }
public static void write File List (  XMLOutput xml Output ,  String tag Name ,  Iterable <  File > list Values ) throws  IOException { if ( list Values != null ) { write File List ( xml Output , tag Name , list Values . iterator ( ) ) ; } }
public  DPolicy Constraints (  JDialog parent ) { super ( parent ) ; set Title ( res . get String ( _ STR ) ) ; init Components ( ) ; }
@  Pre Authorize (  Spring Eval Expressions .  HAS_ AUTH_ SYSTEM_ ADMIN ) @  Override public  Response Entity <  Collection <  String > > invalidate Caches ( ) { final  Collection <  String > cache Names = cache Manager . get Cache Names ( ) ;  LOGGER . info ( _ STR , cache Names ) ; cache Names . for Each ( null ) ; return  Response Entity . ok ( cache Names ) ; }
public static final void write Byte Array Xml ( byte [ ] val ,  String name ,  Xml Serializer out ) throws  Xml Pull Parser Exception , java . io .  IOException { if ( val == null ) { out . start Tag ( null , _ STR ) ; out . end Tag ( null , _ STR ) ; return ; } out . start Tag ( null , _ STR ) ; if ( name != null ) { out . attribute ( null , _ STR , name ) ; } final int  N = val . length ; out . attribute ( null , _ STR ,  Integer . to String (  N ) ) ;  String Builder sb = new  String Builder ( val . length * _ NUM ) ; for ( int i = _ NUM ; i <  N ; i ++ ) { int b = val [ i ] ; int h = b > > _ NUM ; sb . append ( h >= _ NUM ? ( _ STR + h - _ NUM ) : ( _ STR + h ) ) ; h = b & _ NUM ; sb . append ( h >= _ NUM ? ( _ STR + h - _ NUM ) : ( _ STR + h ) ) ; } out . text ( sb . to String ( ) ) ; out . end Tag ( null , _ STR ) ; }
public void cancel Requests By TAG (  Object  TAG , boolean may Interrupt If Running ) { if (  TAG == null ) { return ; } for (  List <  Request Handle > request List : request Map . values ( ) ) { if ( request List != null ) { for (  Request Handle request Handle : request List ) { if (  TAG . equals ( request Handle . get Tag ( ) ) ) request Handle . cancel ( may Interrupt If Running ) ; } } } }
public static void draw Snap Horizontal Margin (  View Transform transform ,  Graphics2 D g , int x1 , int x2 , int y1 ,  String text , boolean text Over ) {  Canvas c = new  Canvas ( ) ;  Font Metrics fm = c . get Font Metrics ( s Font ) ; g . set Font ( s Font ) ; int padding = transform . get Swing Dimension ( _ NUM ) ;  Rectangle2 D bounds = fm . get String Bounds ( text , g ) ; int tw = ( int ) bounds . get Width ( ) ; int offset = _ NUM *  CONNECTION_ ARROW_ SIZE ; if ( x1 > x2 ) { int temp = x1 ; x1 = x2 ; x2 = temp ; } int w = ( ( x2 - x1 ) - ( tw + _ NUM * padding ) ) / _ NUM ; if ( w <= padding ) { g . draw Line ( x1 , y1 , x2 , y1 ) ; if ( text Over ) { offset = - _ NUM * offset / _ NUM ; } g . draw String ( text , x1 + w + padding , y1 + offset ) ; } else { g . draw Line ( x1 , y1 , x1 + w , y1 ) ; g . draw Line ( x2 - w , y1 , x2 , y1 ) ; g . draw String ( text , x1 + w + padding , ( int ) ( y1 + ( bounds . get Height ( ) / _ NUM ) ) ) ; } g . draw Line ( x1 , y1 -  CONNECTION_ ARROW_ SIZE , x1 , y1 +  CONNECTION_ ARROW_ SIZE ) ; g . draw Line ( x2 , y1 -  CONNECTION_ ARROW_ SIZE , x2 , y1 +  CONNECTION_ ARROW_ SIZE ) ; }
public static  Generic Record subset Record (  Generic Record record ,  Schema subset Schema ) { return subset Record ( record , subset Schema , null ) ; }
static public void queue Operation (  Context context ,  Operation Info args ) { args . calculate Scheduled Time ( ) ; synchronized ( s Work Queue ) { s Work Queue . add ( args ) ; s Work Queue . notify ( ) ; } context . start Service ( new  Intent ( context ,  Async Query Service Helper . class ) ) ; }
private static  Cell [ ] interpret (  String string ) {  Cell [ ] cells = new  Cell [ _ NUM ] ; for ( int i = _ NUM ; i < string . length ( ) ; i ++ ) { int dig = string . char At ( i ) - _ STR ; int col = dig % _ NUM ; int row = dig / _ NUM ; cells [ i ] = new  Cell ( col , row ) ; } return cells ; }
public  Shape transform (  Shape shape ) {  Rectangle2 D bounds = shape . get Bounds2 D ( ) ;  Point2 D center = new  Point2 D .  Double ( bounds . get Center X ( ) , bounds . get Center Y ( ) ) ;  Point2 D new Center = transform ( center ) ; double dx = new Center . get X ( ) - center . get X ( ) ; double dy = new Center . get Y ( ) - center . get Y ( ) ;  Affine Transform at =  Affine Transform . get Translate Instance ( dx , dy ) ; return at . create Transformed Shape ( shape ) ; }
public void list (  Print Writer out , int indent ) { for ( int i = _ NUM ; i < indent ; i ++ ) { out . print ( _ STR ) ; } out . println ( this ) ; }
private void init ( ) { set Title ( _ STR ) ; comp Properties Panel =  Competitive Properties Panel . create Competitive Properties Panel ( network Panel ,  Competitive Props Panel Type .  CREATE_ GROUP ) ; tab Logic . add ( comp Properties Panel ) ; layout Panel = new  Main Layout Panel ( _ BOOL , this ) ; layout Panel . set Current Layout (  Competitive Group .  DEFAULT_ LAYOUT ) ; tab Layout . add ( layout Panel ) ; tabbed Pane . add Tab ( _ STR , tab Logic ) ; tabbed Pane . add Tab ( _ STR , layout Panel ) ; set Content Pane ( tabbed Pane ) ;  Action help Action = new  Show Help Action ( comp Properties Panel . get Help Path ( ) ) ; add Button ( new  JButton ( help Action ) ) ; }
public static  Revocation Status check (  X509 Certificate cert ,  X509 Certificate issuer Cert ) throws  IOException ,  Cert Path Validator Exception {  Cert Id cert Id = null ;  URI responder URI = null ; try {  X509 Cert Impl cert Impl =  X509 Cert Impl . to Impl ( cert ) ; responder URI = get Responder URI ( cert Impl ) ; if ( responder URI == null ) { throw new  Cert Path Validator Exception ( _ STR ) ; } cert Id = new  Cert Id ( issuer Cert , cert Impl . get Serial Number Object ( ) ) ; } catch (  Certificate Exception |  IOException e ) { throw new  Cert Path Validator Exception ( _ STR , e ) ; }  OCSPResponse ocsp Response = check (  Collections . singleton List ( cert Id ) , responder URI , issuer Cert , null , null ,  Collections . <  Extension > empty List ( ) ) ; return (  Revocation Status ) ocsp Response . get Single Response ( cert Id ) ; }
public static  Composite Type for Alpha Composite (  Alpha Composite ac ) { switch ( ac . get Rule ( ) ) { case  Alpha Composite .  CLEAR : return  Clear ; case  Alpha Composite .  SRC : if ( ac . get Alpha ( ) >= _ NUM ) { return  Src No Ea ; } else { return  Src ; } case  Alpha Composite .  DST : return  Dst ; case  Alpha Composite .  SRC_ OVER : if ( ac . get Alpha ( ) >= _ NUM ) { return  Src Over No Ea ; } else { return  Src Over ; } case  Alpha Composite .  DST_ OVER : return  Dst Over ; case  Alpha Composite .  SRC_ IN : return  Src In ; case  Alpha Composite .  DST_ IN : return  Dst In ; case  Alpha Composite .  SRC_ OUT : return  Src Out ; case  Alpha Composite .  DST_ OUT : return  Dst Out ; case  Alpha Composite .  SRC_ ATOP : return  Src Atop ; case  Alpha Composite .  DST_ ATOP : return  Dst Atop ; case  Alpha Composite .  XOR : return  Alpha Xor ; default : throw new  Internal Error ( _ STR ) ; } }
private  List find Phonemes ( ) {  Set set = new  Hash Set ( ) ; for ( int i = _ NUM ; i < state Machine . length ; i ++ ) { if ( state Machine [ i ] instanceof  Final State ) {  Final State fstate = (  Final State ) state Machine [ i ] ; if ( fstate . phone List != null ) { for ( int j = _ NUM ; j < fstate . phone List . length ; j ++ ) { set . add ( fstate . phone List [ j ] ) ; } } } } return new  Array List ( set ) ; }
public static  File remove Parent (  File parent ,  File file ) {  String absolute Path = file . get Absolute Path ( ) ;  String parent Absolute Path = parent . get Absolute Path ( ) ;  String new Path = absolute Path . replace ( parent Absolute Path + _ STR , _ STR ) ; return new  File ( new Path ) ; }
public static boolean almost Equal ( double a , double b , double delta ) { return  Math . abs ( a - b ) <= delta ; }
private  Json Writer open ( int empty ,  String open Bracket ) throws  IOException { before Value ( ) ; push ( empty ) ; out . write ( open Bracket ) ; return this ; }
private double calculate Log ( double value ) { return  Math . log ( value ) / this . base Log ; }
@  Override public boolean upload File (  String source ,  String dest ) {  File Input Stream fis ; try {  File file = new  File ( source ) ; fis = new  File Input Stream ( file ) ; m DBApi . put File Overwrite ( dest , fis , file . length ( ) , null ) ; fis . close ( ) ; return _ BOOL ; } catch (  Dropbox Unlinked Exception e ) {  Log . d (  String . value Of (  R . string . app_name ) , _ STR , e ) ; return _ BOOL ; } catch (  Dropbox Exception e ) {  Log . d (  String . value Of (  R . string . app_name ) , _ STR , e ) ; return _ BOOL ; } catch (  File Not Found Exception e ) {  Log . d (  String . value Of (  R . string . app_name ) , _ STR , e ) ; return _ BOOL ; } catch (  IOException e ) { e . print Stack Trace ( ) ; return _ BOOL ; } }
private  File create Zip File Handle ( ) throws  IOException {  File zip File =  File . create Temp File ( _ STR , _ STR , tmp Output Folder . get Root ( ) ) ; assert True ( zip File . delete ( ) ) ; return zip File ; }
public boolean is Empty ( ) { return ( tag == null || tag . is Empty ( ) ) && images . size ( ) == _ NUM ; }
@  Suppress Warnings ( _ STR ) private void restore Badges ( ) {  Bundle restored Bundle = saved Instance State ; if ( restored Bundle != null ) { if ( restored Bundle . contains Key (  BADGE_ FULL_ TEXT_ KEY ) ) { should Show Badge With Nine Plus = restored Bundle . get Boolean (  BADGE_ FULL_ TEXT_ KEY ) ; } if ( restored Bundle . contains Key (  BUDGES_ ITEM_ BUNDLE_ KEY ) ) { badge Save Instance Hash Map = (  Hash Map <  Integer ,  Object > ) saved Instance State . get Serializable (  BUDGES_ ITEM_ BUNDLE_ KEY ) ; if ( badge Save Instance Hash Map != null ) { for (  Integer integer : badge Save Instance Hash Map . key Set ( ) ) {  Badge Helper . force Show Badge ( badge List . get ( integer ) , (  Badge Item ) badge Save Instance Hash Map . get ( integer ) , should Show Badge With Nine Plus ) ; } } } } }
public void touch ( ) { touch =  System . current Time Millis ( ) ; if ( worker != null ) { worker . touch ( ) ; } }
public  Catalog Entry (  String name ,  Vector args ) throws  Catalog Exception {  Integer i Type = (  Integer ) entry Types . get ( name ) ; if ( i Type == null ) { throw new  Catalog Exception (  Catalog Exception .  INVALID_ ENTRY_ TYPE ) ; } int type = i Type . int Value ( ) ; try {  Integer i Args = (  Integer ) entry Args . get ( type ) ; if ( i Args . int Value ( ) != args . size ( ) ) { throw new  Catalog Exception (  Catalog Exception .  INVALID_ ENTRY ) ; } } catch (  Array Index Out Of Bounds Exception e ) { throw new  Catalog Exception (  Catalog Exception .  INVALID_ ENTRY_ TYPE ) ; } entry Type = type ; this . args = args ; }
public void add Msg Waiting (  Mwi Type type , int count ,  Mwi Profile profile , boolean store Message ) { if ( count > _ NUM ) { count = _ NUM ; } messages_ . add ( new  Msg Waiting ( type , count , profile , store Message ) ) ; }
private void push Stack ( int new Top ) { if ( stack Size == stack . length ) { int [ ] new Stack = new int [ stack Size * _ NUM ] ; int [ ] new Path Indices = new int [ stack Size * _ NUM ] ;  String [ ] new Path Names = new  String [ stack Size * _ NUM ] ;  System . arraycopy ( stack , _ NUM , new Stack , _ NUM , stack Size ) ;  System . arraycopy ( path Indices , _ NUM , new Path Indices , _ NUM , stack Size ) ;  System . arraycopy ( path Names , _ NUM , new Path Names , _ NUM , stack Size ) ; stack = new Stack ; path Indices = new Path Indices ; path Names = new Path Names ; } stack [ stack Size ++ ] = new Top ; }
public void add Gossip Member (  Gossip Member member ) { gossip Members . add ( member ) ; }
public boolean is Case Sensitive ( ) { return m_case Sensitive Box . is Selected ( ) ; }
@  Override public int hash Code ( ) { int hash = type . hash Code ( ) ; if ( name != null ) hash ^= name . hash Code ( ) ; if ( actions != null ) hash ^= actions . hash Code ( ) ; return hash ; }
public  Sub Config Model Impl (  Http Servlet Request req ,  String service Name ,  String parent Id ,  Map map ) throws  AMConsole Exception { super ( req , map ) ; this . service Name = service Name ; this . parent Id = parent Id ; sub Config Meta = new  Sub Config Meta ( service Name , this ) ; sub Config Meta . set Parent Id ( parent Id ) ; display Name = sub Config Meta . get Parent Display Name ( ) ; }
@  Override public boolean equals (  Object obj ) { if ( ! ( obj instanceof  Polynomial Function2 D ) ) { return _ BOOL ; }  Polynomial Function2 D that = (  Polynomial Function2 D ) obj ; return  Arrays . equals ( this . coefficients , that . coefficients ) ; }
public static int convert To Color Int (  String a ,  String r ,  String g ,  String b , boolean use Alpha ) { int alpha = use Alpha ?  Integer . parse Int ( a , _ NUM ) : _ NUM ; int red =  Integer . parse Int ( r , _ NUM ) ; int green =  Integer . parse Int ( g , _ NUM ) ; int blue =  Integer . parse Int ( b , _ NUM ) ; return  Color . argb ( use Alpha ? alpha : - _ NUM , red , green , blue ) ; }
@  Override public void on Action ( ) { on Action (  Action Type .  PICK ) ; }
public  Abstract Binary Traversal (  IBinary Tree Node <  T > node ) { if ( node == null ) { throw new  Null Pointer Exception ( _ STR ) ; } stack . add ( new  Moment ( node , initial Phase ( ) ) ) ; advance ( ) ; }
@  Override public void end Element (  String uri ,  String local Name ,  String q Name ) throws  SAXException { if ( q Name . equals (  TAG_ ROOT ) ) { } else if ( q Name . equals (  TAG_ GROUP ) || q Name . equals (  TAG_ PROPERTY ) ) {  Settings Item item = item Stack . remove ( item Stack . size ( ) - _ NUM ) ; settings Items . put ( item . get Key ( ) , item ) ; } else { throw new  SAXException ( _ STR + local Name ) ; } }
public void cancel All ( ) { endpoint . cancel All ( ) ; }
@  Override public double value ( int att Index ) { int index = locate Index ( att Index ) ; if ( ( index >= _ NUM ) && ( m_ Indices [ index ] == att Index ) ) { return m_ Att Values [ index ] ; } else { return _ NUM ; } }
public void initialize (  Context context ,  Time Picker Dialog time Picker Dialog , int initial Hours Of Day , int initial Minutes , boolean is24 Hour Mode ) { if ( m Time Initialized ) {  Log . e (  TAG , _ STR ) ; return ; } m Time Picker Dialog = time Picker Dialog ; m Is24 Hour Mode = is24 Hour Mode ; m Hide Am Pm = m Accessibility Manager . is Touch Exploration Enabled ( ) || m Is24 Hour Mode ; m Circle View . initialize ( context , m Hide Am Pm ) ; m Circle View . invalidate ( ) ; if ( ! m Hide Am Pm ) { m Am Pm Circles View . initialize ( context , initial Hours Of Day < _ NUM ?  AM :  PM ) ; m Am Pm Circles View . invalidate ( ) ; }  Resources res = context . get Resources ( ) ; int [ ] hours = { _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM } ; int [ ] hours_24 = { _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM } ; int [ ] minutes = { _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM } ;  String [ ] hours Texts = new  String [ _ NUM ] ;  String [ ] inner Hours Texts = new  String [ _ NUM ] ;  String [ ] minutes Texts = new  String [ _ NUM ] ; for ( int i = _ NUM ; i < _ NUM ; i ++ ) { hours Texts [ i ] = is24 Hour Mode ?  String . format ( _ STR , hours_24 [ i ] ) :  String . format ( _ STR , hours [ i ] ) ; inner Hours Texts [ i ] =  String . format ( _ STR , hours [ i ] ) ; minutes Texts [ i ] =  String . format ( _ STR , minutes [ i ] ) ; } m Hour Radial Texts View . initialize ( res , hours Texts , ( is24 Hour Mode ? inner Hours Texts : null ) , m Hide Am Pm , _ BOOL ) ; m Hour Radial Texts View . set Selection ( is24 Hour Mode ? initial Hours Of Day : hours [ initial Hours Of Day % _ NUM ] ) ; m Hour Radial Texts View . invalidate ( ) ; m Minute Radial Texts View . initialize ( res , minutes Texts , null , m Hide Am Pm , _ BOOL ) ; m Minute Radial Texts View . set Selection ( initial Minutes ) ; m Minute Radial Texts View . invalidate ( ) ; set Value For Item (  HOUR_ INDEX , initial Hours Of Day ) ; set Value For Item (  MINUTE_ INDEX , initial Minutes ) ; int hour Degrees = ( initial Hours Of Day % _ NUM ) *  HOUR_ VALUE_ TO_ DEGREES_ STEP_ SIZE ; m Hour Radial Selector View . initialize ( context , m Hide Am Pm , is24 Hour Mode , _ BOOL , hour Degrees , is Hour Inner Circle ( initial Hours Of Day ) ) ; int minute Degrees = initial Minutes *  MINUTE_ VALUE_ TO_ DEGREES_ STEP_ SIZE ; m Minute Radial Selector View . initialize ( context , m Hide Am Pm , _ BOOL , _ BOOL , minute Degrees , _ BOOL ) ; m Time Initialized = _ BOOL ; }
protected void decode Bitmap Data ( final  Gif Frame frame , byte [ ] dst Pixels ) { if ( frame != null ) { raw Data . position ( frame . buffer Frame Start ) ; } final int null Code = - _ NUM ; final int npix = ( frame == null ) ? width * height : frame . iw * frame . ih ; int available , clear , code_mask , code_size , end_of_information , in_code , old_code , bits , code , count , i , datum , data_size , first , top , bi , pi ; if ( dst Pixels == null || dst Pixels . length < npix ) { dst Pixels = new byte [ npix ] ; } if ( prefix == null ) { prefix = new short [  MAX_ STACK_ SIZE ] ; } if ( suffix == null ) { suffix = new byte [  MAX_ STACK_ SIZE ] ; } if ( pixel Stack == null ) { pixel Stack = new byte [  MAX_ STACK_ SIZE + _ NUM ] ; } data_size = read ( ) ; clear = _ NUM << data_size ; end_of_information = clear + _ NUM ; available = clear + _ NUM ; old_code = null Code ; code_size = data_size + _ NUM ; code_mask = ( _ NUM << code_size ) - _ NUM ; for ( code = _ NUM ; code < clear ; code ++ ) { prefix [ code ] = _ NUM ; suffix [ code ] = ( byte ) code ; } datum = bits = count = first = top = pi = bi = _ NUM ; for ( i = _ NUM ; i < npix ; ) { if ( top == _ NUM ) { if ( bits < code_size ) { if ( count == _ NUM ) { count = read Block ( ) ; if ( count <= _ NUM ) { break ; } bi = _ NUM ; } datum += ( ( block [ bi ] ) & _ NUM ) << bits ; bits += _ NUM ; bi ++ ; count -- ; continue ; } code = datum & code_mask ; datum >>= code_size ; bits -= code_size ; if ( ( code > available ) || ( code == end_of_information ) ) { break ; } if ( code == clear ) { code_size = data_size + _ NUM ; code_mask = ( _ NUM << code_size ) - _ NUM ; available = clear + _ NUM ; old_code = null Code ; continue ; } if ( old_code == null Code ) { pixel Stack [ top ++ ] = suffix [ code ] ; old_code = code ; first = code ; continue ; } in_code = code ; if ( code == available ) { pixel Stack [ top ++ ] = ( byte ) first ; code = old_code ; } while ( code > clear ) { pixel Stack [ top ++ ] = suffix [ code ] ; code = prefix [ code ] ; } first = ( suffix [ code ] ) & _ NUM ; if ( available >=  MAX_ STACK_ SIZE ) { break ; } pixel Stack [ top ++ ] = ( byte ) first ; prefix [ available ] = ( short ) old_code ; suffix [ available ] = ( byte ) first ; available ++ ; if ( ( ( available & code_mask ) == _ NUM ) && ( available <  MAX_ STACK_ SIZE ) ) { code_size ++ ; code_mask += available ; } old_code = in_code ; } top -- ; dst Pixels [ pi ++ ] = pixel Stack [ top ] ; i ++ ; } for ( i = pi ; i < npix ; i ++ ) { dst Pixels [ i ] = _ NUM ; } }
public synchronized  String find Value (  String k ) { if ( k == null ) { for ( int i = nkeys ; -- i >= _ NUM ; ) if ( keys [ i ] == null ) return values [ i ] ; } else for ( int i = nkeys ; -- i >= _ NUM ; ) { if ( k . equals Ignore Case ( keys [ i ] ) ) return values [ i ] ; } return null ; }
public boolean delete ( ) throws  IOException { if ( closed . compare And Set ( _ BOOL , _ BOOL ) ) { close ( _ BOOL ) ; boolean success = allocated Nodes List . delete ( ) ; success &= nio File . delete ( ) ; return success ; } return _ BOOL ; }
public static boolean has No Prefix ( final  Annotated Type Mirror anno Type ) { if ( anno Type == null ) { return _ BOOL ; } for (  Annotation Mirror mirror : anno Type . get Annotations ( ) ) { if ( ! has No Prefix ( mirror ) ) { return _ BOOL ; } } return _ BOOL ; }
public static void try Format Satisfiability (  String format ) throws  Illegal Format Exception { @  Suppress Warnings ( _ STR )  String unused =  String . format ( format , (  Object [ ] ) null ) ; }
public static  Ignite Logger logger (  Grid Kernal Context ctx ,  Atomic Reference <  Ignite Logger > log Ref ,  Class < ? > cls ) {  Ignite Logger log = log Ref . get ( ) ; if ( log == null ) { log Ref . compare And Set ( null , ctx . log ( cls ) ) ; log = log Ref . get ( ) ; } return log ; }
public static  List <  Constraint Violation > check (  Resource resource ,  Progress Monitor monitor ) { return check ( resource ,  SPIN . constraint , null , monitor ) ; }
public static boolean is Valid Imdb Id (  String imdb Id ) { if (  String Utils . is Empty ( imdb Id ) ) { return _ BOOL ; } return imdb Id . matches ( _ STR ) ; }
protected void show Recorded Video ( ) {  String abs Path = m Current Video File . get Absolute Path ( ) ;  Intent intent = new  Intent ( this ,  Player Activity . class ) ; intent . put Extra (  Player Activity .  EXTRA_ VIDEO_ PATH , abs Path ) ; start Activity ( intent ) ; m Current Video File = null ; }
private void write (  Coordinate [ ] coords , int level ,  String Buffer buf ) { start Line ( _ STR , level , buf ) ; boolean is New Line = _ BOOL ; for ( int i = _ NUM ; i < coords . length ; i ++ ) { if ( i > _ NUM ) { buf . append (  TUPLE_ SEPARATOR ) ; } if ( is New Line ) { start Line ( _ STR , level , buf ) ; is New Line = _ BOOL ; } write ( coords [ i ] , buf ) ; if ( ( i + _ NUM ) % max Coordinates Per Line == _ NUM && i < coords . length - _ NUM ) { buf . append ( _ STR ) ; is New Line = _ BOOL ; } } buf . append ( _ STR ) ; }
protected static boolean is Intended Exception (  Exception e ,  Class < ? > clazz ) { final  String message = e . get Message ( ) ; return ( !  Text Utils . is Empty ( message ) && message . starts With ( clazz . get Name ( ) ) ) ; }
public static void swap Pivot (  Dense Double Matrix2 D source , long diag ,  Dense Double Matrix2 D s ,  Dense Double Matrix2 D t ) { long swap Row = diag ; long swap Col = diag ; double max Value =  Math . abs ( source . get Double ( diag , diag ) ) ; long rows = source . get Row Count ( ) ; long cols = source . get Column Count ( ) ; double abs = _ NUM ; for ( long row = diag ; row < rows ; row ++ ) { for ( long col = diag ; col < cols ; col ++ ) { abs =  Math . abs ( source . get Double ( row , col ) ) ; if ( abs > max Value ) { max Value = abs ; swap Row = row ; swap Col = col ; } } } if ( swap Row != diag ) { swap Rows ( source , swap Row , diag ) ; swap Rows ( t , swap Row , diag ) ; } if ( swap Col != diag ) { swap Cols ( source , swap Col , diag ) ; swap Cols ( s , swap Col , diag ) ; } }
public boolean can Popup Overlap Task Bar ( ) { boolean result = _ BOOL ; try {  Security Manager sm =  System . get Security Manager ( ) ; if ( sm != null ) { sm . check Permission (  Security Constants .  AWT .  SET_ WINDOW_ ALWAYS_ ON_ TOP_ PERMISSION ) ; } } catch (  Security Exception se ) { result = _ BOOL ; } return result ; }
public  Job create Job For Create Cluster (  String activiti Xml Classpath Resource Name ,  List <  Parameter > parameters ) throws  Exception { return create Job For Create Cluster ( activiti Xml Classpath Resource Name , parameters , null ) ; }
public static  List <  String > find Main Classes (  File root Dir ) throws  IOException {  List <  String > ret = new  Array List < > ( ) ; if ( ! root Dir . exists ( ) ) { return ret ; } if ( ! root Dir . is Directory ( ) ) { throw new  Illegal Argument Exception (  String . format ( _ STR , root Dir . get Path ( ) ) ) ; } find Classes ( ret , root Dir , root Dir . get Absolute Path ( ) + _ STR ) ; return ret ; }
private static  String validate XML (  String string ) throws  IOException { for ( int i = _ NUM ; i < string . length ( ) ; i ++ ) { char ch = string . char At ( i ) ; if ( ! ( ch == _ NUM || ch == _ NUM || ch == _ NUM || ch >= _ NUM ) ) throw new  IOException ( _ STR +  Integer . to String ( ch ) + _ STR ) ; } return string ; }
public void write To File (  String filename ) {  Grid Utils . write Spatial Grid Table ( this , filename ) ; }
public void read Values ( ) { read Values ( _ BOOL ) ; }
protected static boolean is Access Compatible With Instant Run ( int access ) { return ( ( access &  Opcodes .  ACC_ ABSTRACT ) == _ NUM ) && ( ( access &  Opcodes .  ACC_ BRIDGE ) == _ NUM ) ; }
public  Threaded Listener Manager (  Executor Service pool ) { manager Number =  MANAGER_ COUNT . get And Increment ( ) ; this . pool = pool ; }
private void read Object (  Object Input Stream in ) throws  IOException ,  Class Not Found Exception { in . default Read Object ( ) ; if ( choice Limits . length != choice Formats . length ) { throw new  Invalid Object Exception ( _ STR ) ; } }
private void compute Offset Segment (  Line Segment seg , int side , double distance ,  Line Segment offset ) { int side Sign = side ==  Position .  LEFT ? _ NUM : - _ NUM ; double dx = seg . p1 . x - seg . p0 . x ; double dy = seg . p1 . y - seg . p0 . y ; double len =  Math . sqrt ( dx * dx + dy * dy ) ; double ux = side Sign * distance * dx / len ; double uy = side Sign * distance * dy / len ; offset . p0 . x = seg . p0 . x - uy ; offset . p0 . y = seg . p0 . y + ux ; offset . p1 . x = seg . p1 . x - uy ; offset . p1 . y = seg . p1 . y + ux ; }
@  Suppress Warnings ( _ STR ) public synchronized  E element At ( int location ) { if ( location < element Count ) { return (  E ) element Data [ location ] ; } throw array Index Out Of Bounds Exception ( location , element Count ) ; }
private  List <  Qo SRule > create Qo SRules (  Json Object qos Settings ) {  List <  Qo SRule > rules = new  Array List < > ( ) ; if ( qos Settings . contains Key (  JSON_ FIELD_ RULES ) ) {  Json Object json Rules = qos Settings . get Json Object (  JSON_ FIELD_ RULES ) ; for (  String url Pattern Reg Exp : json Rules . field Names ( ) ) { log . debug ( _ STR + url Pattern Reg Exp ) ;  Json Object json Rule = json Rules . get Json Object ( url Pattern Reg Exp ) ;  Pattern url Pattern =  Pattern . compile ( url Pattern Reg Exp ) ;  Qo SRule rule = new  Qo SRule ( url Pattern ) ; boolean add Rule = _ BOOL ; if ( json Rule . contains Key ( _ STR ) ) { add Rule = _ BOOL ; rule . set Reject ( json Rule . get Double ( _ STR ) ) ; } if ( json Rule . contains Key ( _ STR ) ) { add Rule = _ BOOL ; rule . set Warn ( json Rule . get Double ( _ STR ) ) ; } if ( add Rule ) { rules . add ( rule ) ; } else { log . warn ( _ STR , url Pattern Reg Exp ) ; } } } return rules ; }
private static final byte [ ] to Octets ( int identifier ,  String text ) { byte [ ] s = text . get Bytes (  Standard Charsets .  UTF_8 ) ; byte [ ] base =  Octet Utils . to Octets (  Attribute Type .  VENDOR_ SPECIFIC , identifier ) ; int max Text Space =  Attribute .  MAX_ ATTRIBUTE_ LENGTH - base . length ; byte [ ] octets ; if ( s . length > max Text Space ) { octets = new byte [  Attribute .  MAX_ ATTRIBUTE_ LENGTH ] ;  System . arraycopy ( s , _ NUM , octets , base . length ,  Attribute .  MAX_ ATTRIBUTE_ LENGTH - base . length ) ; } else { octets = new byte [ base . length + s . length ] ;  System . arraycopy ( s , _ NUM , octets , base . length , s . length ) ; }  System . arraycopy ( base , _ NUM , octets , _ NUM , base . length ) ; octets [ _ NUM ] = ( byte ) octets . length ; return octets ; }
private  Double format Double Value (  Double value , int places ) {  Big Decimal bd = new  Big Decimal ( value ) ; bd = bd . set Scale ( places ,  Rounding Mode .  HALF_ UP ) ; return bd . double Value ( ) ; }
@  Override public void flush ( ) throws  IOException { out . flush ( ) ; }
protected int move Or Copy Files ( boolean move ,  String what ,  File [ ] dest Files ,  File [ ] source Files ) { int op Code = ( move ) ?  OP_ MOVE :  OP_ COPY ; m Modified Src Files = ( move ) ? new  Array List <  String > ( ) : null ; m Modified Dest Files = new  Array List <  String > ( ) ; open Logfile ( ) ; on Pre Process ( what , null , null , op Code ) ; int item Count = _ NUM ; int pos = _ NUM ; int file Count = dest Files . length ; while ( pos < file Count ) {  File source File = source Files [ pos ] ;  File dest File = dest Files [ pos ] ;  File dest Renamed = rename Duplicate ( dest File ) ; if ( os File Move Or Copy ( move , dest Renamed , source File ) ) item Count ++ ; log ( ( ( move ) ? _ STR : _ STR ) , get Filename For Log ( source File ) , _ STR , get Filename For Log ( dest Renamed ) ) ;  File source Sidecar = get Sidecar ( source File ) ; if ( os File Exists ( source Sidecar ) ) {  File dest Sidecar = get Sidecar ( dest Renamed ) ; if ( os File Move Or Copy ( move , dest Sidecar , source Sidecar ) ) item Count ++ ; log ( ( ( move ) ? _ STR : _ STR ) , get Filename For Log ( source Sidecar ) , _ STR , get Filename For Log ( dest Sidecar ) ) ; } pos ++ ; } int modify Count = m Modified Dest Files . size ( ) ;  String [ ] modified Source Files = ( ( m Modified Src Files != null ) && ( m Modified Src Files . size ( ) > _ NUM ) ) ? m Modified Src Files . to Array ( new  String [ modify Count ] ) : null ; on Post Process ( what , modified Source Files , ( modify Count > _ NUM ) ? m Modified Dest Files . to Array ( new  String [ modify Count ] ) : null , item Count , source Files . length , op Code ) ; close Log File ( ) ; return item Count ; }
static boolean is COctet String Valid (  String value , int max Length ) { if ( value == null ) return _ BOOL ; if ( value . length ( ) >= max Length ) return _ BOOL ; return _ BOOL ; }
public  Rectangle2 D create Proper Bounds ( double x1 , double y1 , double x2 , double y2 ) { double x =  Math . min ( x1 , x2 ) ; double y =  Math . min ( y1 , y2 ) ; double w =  Math . abs ( x1 - x2 ) ; double h =  Math . abs ( y1 - y2 ) ; return new  Rectangle2 D .  Double ( x , y , w , h ) ; }
public void add Clear Graph Data Button ( ) {  JButton clear Button = new  JButton ( _ STR ) ; clear Button . set Action (  Raster Plot Actions . get Clear Graph Action ( this ) ) ; button Panel . add ( clear Button ) ; }
public static float normalized Levenshtein Distance (  String s ,  String t ) { float d = levenshtein Distance ( s , t ) ; int max =  Math . max ( s . length ( ) , t . length ( ) ) ; return d / ( float ) max ; }
private void create File ( int number ,  String extention ) { for ( int i = _ NUM ; i < number ; i ++ ) { try {  Buffered Writer output = new  Buffered Writer ( new  File Writer ( new  File ( text Input Folder + _ STR +  String . value Of ( i ) + extention ) ) ) ; try { output . write ( _ STR ) ; output . write (  String . value Of ( i ) ) ; } finally { output . close ( ) ; } } catch (  IOException e ) { e . print Stack Trace ( ) ; } } }
public boolean is Animal ( ) { return type String . contains (  SUFFIX_ ANIMAL ) ; }
public void add Notification (  Ping Notification notification ) { notifications . add ( notification ) ; }
public  List <  Datastore > create Nfs Datastore (  Cluster Compute Resource cluster ,  File Share Rest Rep file System ,  File System Export Param export ,  URI datacenter Id ,  String datastore Name ) { add Nfs Datastore Tag ( file System , export , datacenter Id , datastore Name ) ;  List <  Datastore > datastores =  Lists . new Array List ( ) ;  String file Server =  String Utils . substring Before ( export . get Mount Point ( ) , _ STR ) ;  String mount Path =  String Utils . substring After ( export . get Mount Point ( ) , _ STR ) ; for (  Host System host : cluster . get Hosts ( ) ) { datastores . add ( execute ( new  Create Nfs Datastore ( host , file Server , mount Path , datastore Name ) ) ) ; add Affected Resource ( file System ) ;  Execution Utils . clear Rollback ( ) ; } return datastores ; }
private void check Size ( final int i ) { if ( i >= max_size ) { final int old_size = max_size ; max_size += increment_size ; if ( max_size <= i ) { max_size = i + increment_size + _ NUM ; } final  String [ ] temp = items ; items = new  String [ max_size ] ;  System . arraycopy ( temp , _ NUM , items , _ NUM , old_size ) ; increment_size = increment Size ( increment_size ) ; } }
public  Album (  Context context ,  Uri media Uri ) { super ( ) ; media . add ( _ NUM , new  Media ( context , media Uri ) ) ; set Current Photo Index ( _ NUM ) ; }
protected void initialize Task Done (  Set <  Task Image Container > tasks ,  Optional <  Runnable > runnable When Done ) {  Set <  Capture Session > session Set = new  Hash Set < > ( ) ;  Map <  Capture Session ,  Integer > session Task Count = new  Hash Map < > ( ) ; for (  Task Image Container task : tasks ) { session Set . add ( task . m Session ) ;  Integer current Count = session Task Count . get ( task . m Session ) ; if ( current Count == null ) { session Task Count . put ( task . m Session , _ NUM ) ; } else { session Task Count . put ( task . m Session , current Count + _ NUM ) ; } } synchronized ( m Shadow Task Map ) { for (  Capture Session capture Session : session Set ) {  Block Signal Protocol protocol = new  Block Signal Protocol ( ) ; protocol . set Count ( session Task Count . get ( capture Session ) ) ; final  Image Shadow Task shadow Task ; shadow Task = new  Image Shadow Task ( protocol , capture Session , runnable When Done ) ; m Shadow Task Map . put ( capture Session , shadow Task ) ; m Processing Task Consumer . enqueue Task ( shadow Task ) ; } } }
public static  String unquote (  String name ) { return is Quoted ( name ) ? name . substring ( _ NUM , name . length ( ) - _ NUM ) : name ; }
public boolean has Leader (  String player Name ) { return ( leader != null ) && leader . equals ( player Name ) ; }
private static <  T >  T report Join (  Object r ) { if ( r instanceof  Alt Result ) {  Throwable x ; if ( ( x = ( (  Alt Result ) r ) . ex ) == null ) return null ; if ( x instanceof  Cancellation Exception ) throw (  Cancellation Exception ) x ; if ( x instanceof  Completion Exception ) throw (  Completion Exception ) x ; throw new  Completion Exception ( x ) ; } @  Suppress Warnings ( _ STR )  T t = (  T ) r ; return t ; }
public int write ( final  Protein protein ) throws  IOException { check Entry Hierarchy ( ) ; if ( entry Hierarchy != null ) { for (  Protein Xref xref : protein . get Cross References ( ) ) { final  Simple Protein simple Protein =  Simple Protein . value Of ( protein , xref , entry Hierarchy ) ; if ( simple Protein != null ) { final  Simple Hash model = build Model Map ( simple Protein , entry Hierarchy ) ;  Writer writer = null ; try { final  Template temp = free Marker Config . get Template ( free Marker Template ) ; check Temp Directory ( temp Directory ) ; if ( ! temp Directory . ends With (  File . separator ) ) { temp Directory = temp Directory +  File . separator ; }  Url Friendly Id Generator gen =  Url Friendly Id Generator . get Instance ( ) ;  String url Friendly Id = gen . generate ( xref . get Identifier ( ) ) ; final  Path new Result File =  Paths . get ( temp Directory + url Friendly Id + _ STR ) ; result Files . add ( new Result File ) ; writer =  Files . new Buffered Writer ( new Result File , character Set ) ; temp . process ( model , writer ) ; writer . flush ( ) ; } catch (  Template Exception e ) { e . print Stack Trace ( ) ; } catch (  IOException e ) { e . print Stack Trace ( ) ; } finally { if ( writer != null ) { writer . close ( ) ; } } } } } return _ NUM ; }
public void test Casts ( ) {  String sql_begin = _ STR ;  String [ ] [ ] sql_tests = new  String [ ] [ ] { { _ STR , _ STR } , { _ STR , _ STR } , { _ STR , _ STR } , { _ STR , _ STR } , { _ STR , _ STR } , { _ STR , _ STR } , { _ STR , _ STR } } ;  String sql_end = _ STR ;  String Buffer sql = new  String Buffer ( sql_begin ) ;  String Buffer sqle = new  String Buffer ( sql_begin ) ; for ( int i = _ NUM ; i < sql_tests . length ; i ++ ) { if ( i > _ NUM ) { sql . append ( _ STR ) ; sqle . append ( _ STR ) ; } sql . append ( sql_tests [ i ] [ _ NUM ] ) ; sqle . append ( sql_tests [ i ] [ _ NUM ] ) ; } sql . append ( sql_end ) ; sqle . append ( sql_end ) ;  String [ ] r = convert . convert ( sql . to String ( ) ) ; assert Equals ( sqle . to String ( ) , r [ _ NUM ] ) ; }
private boolean save Macro ( ) { if ( first Time ) { try {  Thread . sleep ( first Time Sleep ) ; } catch (  Interrupted Exception e ) { e . print Stack Trace ( ) ; } } first Time = _ BOOL ; byte [ ] macro Accy = new byte [ macro Size ] ; int index = _ NUM ; int accy Num = _ NUM ; accy Num = get Accy Row ( macro Accy , index , text Accy1 , accy Text Field1 , cmd Button1 ) ; if ( accy Num < _ NUM ) { return _ BOOL ; } if ( accy Num > _ NUM ) { index += _ NUM ; } accy Num = get Accy Row ( macro Accy , index , text Accy2 , accy Text Field2 , cmd Button2 ) ; if ( accy Num < _ NUM ) { return _ BOOL ; } if ( accy Num > _ NUM ) { index += _ NUM ; } accy Num = get Accy Row ( macro Accy , index , text Accy3 , accy Text Field3 , cmd Button3 ) ; if ( accy Num < _ NUM ) { return _ BOOL ; } if ( accy Num > _ NUM ) { index += _ NUM ; } accy Num = get Accy Row ( macro Accy , index , text Accy4 , accy Text Field4 , cmd Button4 ) ; if ( accy Num < _ NUM ) { return _ BOOL ; } if ( accy Num > _ NUM ) { index += _ NUM ; } accy Num = get Accy Row ( macro Accy , index , text Accy5 , accy Text Field5 , cmd Button5 ) ; if ( accy Num < _ NUM ) { return _ BOOL ; } if ( accy Num > _ NUM ) { index += _ NUM ; } accy Num = get Accy Row ( macro Accy , index , text Accy6 , accy Text Field6 , cmd Button6 ) ; if ( accy Num < _ NUM ) { return _ BOOL ; } if ( accy Num > _ NUM ) { index += _ NUM ; } accy Num = get Accy Row ( macro Accy , index , text Accy7 , accy Text Field7 , cmd Button7 ) ; if ( accy Num < _ NUM ) { return _ BOOL ; } if ( accy Num > _ NUM ) { index += _ NUM ; } if ( ! is Usb ) { accy Num = get Accy Row ( macro Accy , index , text Accy8 , accy Text Field8 , cmd Button8 ) ; if ( accy Num < _ NUM ) { return _ BOOL ; } if ( accy Num > _ NUM ) { index += _ NUM ; } accy Num = get Accy Row ( macro Accy , index , text Accy9 , accy Text Field9 , cmd Button9 ) ; if ( accy Num < _ NUM ) { return _ BOOL ; } if ( accy Num > _ NUM ) { index += _ NUM ; } } accy Num = get Accy Row ( macro Accy , index , text Accy10 , accy Text Field10 , cmd Button10 ) ; if ( accy Num < _ NUM ) {  JOption Pane . show Message Dialog ( this , rb . get String ( _ STR ) , rb . get String ( _ STR ) ,  JOption Pane .  ERROR_ MESSAGE ) ; return _ BOOL ; } process Memory ( _ BOOL , _ BOOL , macro Num , macro Accy ) ; return _ BOOL ; }
public void write Into SPTKLF0 File (  String sptk File Name ) throws  IOException {  LEData Output Stream lf0 Data = new  LEData Output Stream ( new  Buffered Output Stream ( new  File Output Stream ( sptk File Name ) ) ) ; for ( int i = _ NUM ; i < this . contour . length ; i ++ ) { double f0 Val = contour [ i ] ; if ( contour [ i ] == _ NUM ) { lf0 Data . write Float (  NEGATIVE_ MAXIMUM ) ; } else { lf0 Data . write Float ( ( float )  Math . log ( contour [ i ] ) ) ; } } lf0 Data . flush ( ) ; lf0 Data . close ( ) ; }
public static  Element find (  Node parent ,  String name ) {  Node List list = parent . get Child Nodes ( ) ; for ( int i = _ NUM ; i < list . get Length ( ) ; i ++ ) {  Node n = list . item ( i ) ; if ( n instanceof  Element ) {  Element e = (  Element ) n ; if ( name . equals ( e . get Attribute ( _ STR ) ) ) { return e ; } }  Element r = find ( n , name ) ; if ( r != null ) { return r ; } } return null ; }
public static  RE mk Star (  RE x ) { if ( x . equals ( epsilon ) || x . equals ( empty ) ) { return epsilon ; }  RE res = new  RE (  Re Op .  STAR ) ; res . unary Arg = x ; return res ; }
public void remove ( final  Object element ) {  Set old Selection = new  Hash Set ( selection ) ; boolean rv = selection . remove ( element ) ; if ( rv ) { fire Selection Changed ( old Selection , selection ) ; } old Selection = null ; }
@  Override public void mouse Clicked (  Mouse Event evt ) { delegate . mouse Moved ( evt ) ; }
public void printf (  Locale locale ,  String format ,  Object ... args ) { out . printf ( locale , format , args ) ; out . flush ( ) ; }
public void test Sorts Attributes Before Elements ( ) throws  Exception {  Xpp Dom dom1 =  Xpp Factory . build Dom ( _ STR ) ;  Xpp Dom dom2 =  Xpp Factory . build Dom ( _ STR ) ; assert Equals ( - _ NUM , comparator . compare ( dom1 , dom2 ) ) ; assert Equals ( _ STR , xpath . get ( ) ) ; assert Equals ( _ NUM , comparator . compare ( dom2 , dom1 ) ) ; assert Equals ( _ STR , xpath . get ( ) ) ; }
public void add Suffix (  Dalv Insn insn ) { suffix . add ( insn ) ; }
private void close Selector ( ) { if ( selector . is Open ( ) ) { if ( log . is Debug Enabled ( ) ) log . debug ( _ STR ) ; for (  Selection Key key : selector . keys ( ) )  U . close ( key . channel ( ) , log ) ; if ( log . is Debug Enabled ( ) ) log . debug ( _ STR ) ;  U . close ( selector , log ) ; } }
public static  Number sub (  Number a ,  Number b ) { if ( is Floating Point ( a ) || is Floating Point ( b ) ) { return a . double Value ( ) - b . double Value ( ) ; } else { return a . long Value ( ) - b . long Value ( ) ; } }
public  Builder required Attributes ( final  String ... name Or OIDs ) { return required Attributes (  Arrays . as List ( name Or OIDs ) ) ; }
private void show History Dialog ( ) {  JBList commands List = new  JBList (  History Utils . get Commands From History ( ) ) ; commands List . set Cell Renderer ( new  History List Cell Renderer ( ) ) ; commands List . set Empty Text ( _ STR ) ; commands List . set Selection Mode (  List Selection Model .  SINGLE_ SELECTION ) ;  String [ ] buttons = { _ STR , _ STR } ; int result =  JOption Pane . show Option Dialog ( tool Window Content , commands List , _ STR ,  JOption Pane .  YES_ NO_ CANCEL_ OPTION ,  JOption Pane .  PLAIN_ MESSAGE , null , buttons , buttons [ _ NUM ] ) ; if ( result == _ NUM ) { update Ui From Command ( (  Command ) commands List . get Selected Value ( ) ) ; } }
protected static byte [ ] read (  Input Stream is ) throws  IOException { final boolean close = _ BOOL ;  Byte Array Output Stream baos = new  Byte Array Output Stream ( ) ; try { int i ; while ( ( i = is . read ( ) ) != - _ NUM ) { baos . write ( i ) ; } } finally { try { if ( close ) { is . close ( ) ; } baos . close ( ) ; } catch (  Exception ex ) { log . warn ( _ STR + ex , ex ) ; } } return baos . to Byte Array ( ) ; }
public static <  T >  Streamable <  T > from Publisher ( final  Publisher < ? extends  T > publisher ) {  Objects . require Non Null ( publisher ) ; final  Seq Subscriber <  T > sub =  Seq Subscriber . subscriber ( ) ; publisher . subscribe ( sub ) ; return from Stream ( sub . stream ( ) ) ; }
public  Protobuf Connection (  Listener <  Message Type > handler ,  Message Type prototype , int max Message Size , int timeout Millis ) { this . handler = handler ; this . prototype = prototype ; this . max Message Size =  Math . min ( max Message Size ,  Integer .  MAX_ VALUE - _ NUM ) ; set Timeout Enabled ( _ BOOL ) ; set Socket Timeout ( timeout Millis ) ; }
public  Notification find (  Integer notification ID ) {  Notification notification = new  Notification ( context , notification ID , null ) ; if ( notification . get Attributes ( ) == null ) notification . load Attributes From Preferences ( ) ; return notification ; }
public  Green Gradient ( int max Count ) { this . max Count = max Count ; factor = max Count /  Math . log ( max Count ) ; }
public static void write Histogram (  TDouble Double Hash Map distr ,  String filename ) throws  File Not Found Exception ,  IOException {  Buffered Writer a Writer =  IOUtils . get Buffered Writer ( filename ) ; a Writer . write ( _ STR ) ; a Writer . new Line ( ) ; double [ ] keys = distr . keys ( ) ;  Arrays . sort ( keys ) ; for ( double key : keys ) { a Writer . write (  String . value Of ( key ) ) ; a Writer . write ( _ STR ) ; a Writer . write (  String . value Of ( distr . get ( key ) ) ) ; a Writer . new Line ( ) ; } a Writer . close ( ) ; }
public static <  T >  Completion Stage <  T > dereference (  Completion Stage < ? extends  Completion Stage <  T > > stage ) { return stage . then Compose (  Identity .  INSTANCE ) ; }
public static  Number plus (  Character left ,  Number right ) { return  Number Number Plus . plus (  Integer . value Of ( left ) , right ) ; }
public static  String clip String If Necessary (  JComponent c ,  Font Metrics fm ,  String string , int avail Text Width ) { if ( ( string == null ) || ( string . equals ( _ STR ) ) ) { return _ STR ; } int text Width =  Swing Utilities2 . string Width ( c , fm , string ) ; if ( text Width > avail Text Width ) { return  Swing Utilities2 . clip String ( c , fm , string , avail Text Width ) ; } return string ; }
public boolean remove Element (  Object obj ) { synchronized ( actions ) { if ( allow To Change ) { boolean result = actions . remove ( obj ) ; if ( actions . is Empty ( ) ) { if ( head Task != null ) { cancel ( ) ; } } return result ; } } return _ BOOL ; }
public static boolean is Cglib Proxy (  Object object ) { return  Class Utils . is Cglib Proxy Class ( object . get Class ( ) ) ; }
public void reset References ( ) { if ( _refs != null ) _refs . clear ( ) ; }
public void add Slide ( @  Non Null  Fragment fragment ) { fragments . add ( fragment ) ; add Background Color (  Color .  TRANSPARENT ) ; pager Adapter . notify Data Set Changed ( ) ; }
private static  Float Buffer create Vertex Array ( float [ ] coords ) {  Byte Buffer bb =  Byte Buffer . allocate Direct ( coords . length * _ NUM ) ; bb . order (  Byte Order . native Order ( ) ) ;  Float Buffer fb = bb . as Float Buffer ( ) ; fb . put ( coords ) ; fb . position ( _ NUM ) ; return fb ; }
protected void publish ( ) throws  Mqtt Exception ,  IOException { sample Client Pub = new  Sample Async Wait ( url , client Id Pub , clean Session , quiet Mode , user Name , password ) ; if ( sample Client Pub != null ) {  String topic = _ STR ; int qos = _ NUM ;  String message = _ STR ; try { sample Client Pub . publish ( topic , qos , message . get Bytes ( ) ) ; } catch (  Throwable e ) { e . print Stack Trace ( ) ; } } }
private  Object [ ] inv Wm Sub Band (  Image img , double [ ] wm , int n , double threshold ) { int m = _ NUM ; double z = _ NUM ; double v = _ NUM ; for ( int i = _ NUM ; i < img . get Width ( ) * img . get Height ( ) ; i ++ ) { if ( img . get Data ( ) [ i ] > threshold ) { z += ( img . get Data ( ) [ i ] * wm [ i % n ] ) ; v +=  Math . abs ( img . get Data ( ) [ i ] ) ; m ++ ; } } return new  Object [ ] { m , z , v } ; }
private static  Tungsten Properties load Security Properties From File (  String properties File Location ) throws  Configuration Exception {  Tungsten Properties security Props = null ;  File Input Stream security Configuration File Input Stream = null ; if ( properties File Location == null &&  Cluster Configuration . get Cluster Home ( ) == null ) { throw new  Configuration Exception ( _ STR ) ; }  File security Properties File ; if ( properties File Location == null ) {  File cluster Conf Directory =  Cluster Configuration . get Dir (  Cluster Configuration . get Global Config Dir Name (  Cluster Configuration . get Cluster Home ( ) ) ) ; security Properties File = new  File ( cluster Conf Directory . get Path ( ) ,  Security Conf .  SECURITY_ PROPERTIES_ FILE_ NAME ) ; } else { security Properties File = new  File ( properties File Location ) ; } try { security Props = new  Tungsten Properties ( ) ; security Configuration File Input Stream = new  File Input Stream ( security Properties File ) ; security Props . load ( security Configuration File Input Stream , _ BOOL ) ; close Security Configuration File Input Stream ( security Configuration File Input Stream ) ; } catch (  File Not Found Exception e ) {  String msg =  Message Format . format ( _ STR , security Properties File . get Path ( ) ) ; logger . debug ( msg , e ) ; throw new  Configuration Exception ( msg ) ; } catch (  IOException e ) {  String msg =  Message Format . format ( _ STR , security Properties File . get Path ( ) , e . get Message ( ) ) ; logger . debug ( msg , e ) ; throw new  Configuration Exception ( msg ) ; } finally { close Security Configuration File Input Stream ( security Configuration File Input Stream ) ; } if ( logger . is Debug Enabled ( ) ) { logger . debug (  Message Format . format ( _ STR , security Properties File . get Path ( ) ) ) ; } security Props . put (  Security Conf .  SECURITY_ PROPERTIES_ PARENT_ FILE_ LOCATION , security Properties File . get Absolute Path ( ) ) ; return security Props ; }
private synchronized void clear Scan Files ( ) { if ( ( all Files != null ) && ( all Files . size ( ) > _ NUM ) ) {  Iterator it = all Files . iterator ( ) ;  File file = null ; while ( it . has Next ( ) ) { file = (  File ) it . next ( ) ; file . delete ( ) ; } all Files . clear ( ) ; } }
private void start File Based Merge ( ) throws  Carbon Sort Key And Group By Exception { try { executor Service . shutdown ( ) ; executor Service . await Termination ( _ NUM ,  Time Unit .  DAYS ) ; data Sorter And Writer Executor Service . shutdown ( ) ; data Sorter And Writer Executor Service . await Termination ( _ NUM ,  Time Unit .  DAYS ) ; } catch (  Interrupted Exception e ) { throw new  Carbon Sort Key And Group By Exception ( _ STR , e ) ; } }
public  Date Time Parse Exception (  String message ,  Char Sequence parsed Data , int error Index ) { super ( message ) ; this . parsed String = parsed Data . to String ( ) ; this . error Index = error Index ; }
private boolean are Parallel Siblings (  Component source ,  Component target , int axis ) {  Component Info source Info = get Component Info ( source ) ;  Component Info target Info = get Component Info ( target ) ;  Spring source Spring ;  Spring target Spring ; if ( axis ==  HORIZONTAL ) { source Spring = source Info . horizontal Spring ; target Spring = target Info . horizontal Spring ; } else { source Spring = source Info . vertical Spring ; target Spring = target Info . vertical Spring ; }  Array List source Path = tmp Parallel Set ; source Path . clear ( ) ;  Spring spring = source Spring . get Parent ( ) ; while ( spring != null ) { source Path . add ( spring ) ; spring = spring . get Parent ( ) ; } spring = target Spring . get Parent ( ) ; while ( spring != null ) { if ( source Path . contains ( spring ) ) { source Path . clear ( ) ; while ( spring != null ) { if ( spring instanceof  Parallel Group ) { return _ BOOL ; } spring = spring . get Parent ( ) ; } return _ BOOL ; } spring = spring . get Parent ( ) ; } source Path . clear ( ) ; return _ BOOL ; }
protected  Object read Object Impl (  Class cl ) throws  IOException { try {  Object obj = cl . new Instance ( ) ; if ( _refs == null ) _refs = new  Array List ( ) ; _refs . add ( obj ) ;  Hash Map field Map = get Field Map ( cl ) ; int code = read ( ) ; for ( ; code >= _ NUM && code != _ STR ; code = read ( ) ) { unread ( ) ;  Object key = read Object ( ) ;  Field field = (  Field ) field Map . get ( key ) ; if ( field != null ) {  Object value = read Object ( field . get Type ( ) ) ; field . set ( obj , value ) ; } else {  Object value = read Object ( ) ; } } if ( code != _ STR ) throw expect ( _ STR , code ) ; try {  Method method = cl . get Method ( _ STR , new  Class [ _ NUM ] ) ; return method . invoke ( obj , new  Object [ _ NUM ] ) ; } catch (  Exception e ) { } return obj ; } catch (  IOException e ) { throw e ; } catch (  Exception e ) { throw new  IOException Wrapper ( e ) ; } }
protected static  Pair <  String ,  String > lsr Immediate ( final long offset , final  ITranslation Environment environment , final  List <  Reil Instruction > instructions , final  String register Node Value , final  String immediate Node Value ) { final  String shifter Operand = environment . get Next Variable String ( ) ; final  String shifter Carry Out = environment . get Next Variable String ( ) ; long base Offset = offset ; if ( immediate Node Value . equals ( _ STR ) ) { final  String tmp Var1 = environment . get Next Variable String ( ) ; instructions . add (  Reil Helpers . create Bsh ( base Offset ++ , d Word Size , register Node Value , word Size , minus Thirty One Set , word Size , tmp Var1 ) ) ; instructions . add (  Reil Helpers . create And ( base Offset ++ , word Size , tmp Var1 , byte Size , one Set , byte Size , shifter Carry Out ) ) ; return new  Pair <  String ,  String > (  String . value Of ( _ NUM ) , shifter Carry Out ) ; } else { final  String tmp Var1 = environment . get Next Variable String ( ) ; final  String tmp Var2 = environment . get Next Variable String ( ) ; instructions . add (  Reil Helpers . create Bsh ( base Offset ++ , d Word Size , register Node Value , word Size , _ STR + immediate Node Value , q Word Size , tmp Var1 ) ) ; instructions . add (  Reil Helpers . create And ( base Offset ++ , q Word Size , tmp Var1 , d Word Size , bit Mask All Bits Set , d Word Size , shifter Operand ) ) ; instructions . add (  Reil Helpers . create Bsh ( base Offset ++ , d Word Size , register Node Value , word Size ,  String . value Of ( - (  Integer . decode ( immediate Node Value ) - _ NUM ) ) , d Word Size , tmp Var2 ) ) ; instructions . add (  Reil Helpers . create And ( base Offset ++ , d Word Size , tmp Var2 , byte Size , one Set , byte Size , shifter Carry Out ) ) ; return new  Pair <  String ,  String > ( shifter Operand , shifter Carry Out ) ; } }
public static  Plain Text plain ( int text ) { return plain (  Integer . to String ( text ) ) ; }
public static boolean is Today (  Calendar _calendar ) {  Calendar now =  Calendar . get Instance ( ) ; if ( now . get (  Calendar .  DAY_ OF_ MONTH ) == _calendar . get (  Calendar .  DAY_ OF_ MONTH ) ) { if ( now . get (  Calendar .  MONTH ) == _calendar . get (  Calendar .  MONTH ) ) { if ( now . get (  Calendar .  YEAR ) == _calendar . get (  Calendar .  YEAR ) ) { return _ BOOL ; } } } return _ BOOL ; }
public void start ( ) { managed Pairs . add ( create Port ( ) ) ; fix Names ( ) ; single Ports . add Observer ( observer , _ BOOL ) ; for (  Ports <  M > ports : multi Ports List ) { ports . add Observer ( observer , _ BOOL ) ; } }
protected void sprint ( double double Field ) { sprint (  String . value Of ( double Field ) ) ; }
public static  Bitmap convert Yuv Image To Bitmap ( @  Non Null final  Yuv Image yuv Image ) {  Byte Array Output Stream out = new  Byte Array Output Stream ( ) ; yuv Image . compress To Jpeg ( new  Rect ( _ NUM , _ NUM , yuv Image . get Width ( ) , yuv Image . get Height ( ) ) , _ NUM , out ) ; byte [ ] image Bytes = out . to Byte Array ( ) ; try { out . close ( ) ; } catch (  IOException e ) {  Log . e (  LOG_ TAG , _ STR , e ) ; } return  Bitmap Factory . decode Byte Array ( image Bytes , _ NUM , image Bytes . length ) ; }
public  Double read (  String value ) { return  Double . value Of ( value ) ; }
private  Storage Port assign Port Based On Usage (  List <  Storage Port > matching Target Ports ,  Map <  Storage Port ,  Integer > port Usage ) {  Storage Port found Port = null ; for (  Storage Port matched Port : matching Target Ports ) { if ( port Usage . get ( matched Port ) == null ) { port Usage . put ( matched Port , _ NUM ) ; } if ( found Port == null ) { found Port = matched Port ; } else { if ( port Usage . get ( matched Port ) < port Usage . get ( found Port ) ) { found Port = matched Port ; } } } if ( found Port != null ) { port Usage . put ( found Port , port Usage . get ( found Port ) + _ NUM ) ; } return found Port ; }
public  External Event next Event ( ) { if ( queue . size ( ) == _ NUM ) { return new  External Event (  Double .  MAX_ VALUE ) ; }  External Event ee = queue . get ( next Event Index ) ; next Event Index ++ ; if ( next Event Index >= queue . size ( ) ) { queue = read Events ( nrof Preload ) ; next Event Index = _ NUM ; } return ee ; }
public void append To Buffer (  String Builder buf ) {  Iterator < double [ ] > iter = points . iterator ( ) ; while ( iter . has Next ( ) ) { double [ ] data = iter . next ( ) ; for ( int i = _ NUM ; i < data . length ; i ++ ) { if ( i > _ NUM ) { buf . append ( _ STR ) ; } buf . append ( data [ i ] ) ; } if ( iter . has Next ( ) ) { buf . append ( _ STR ) ; } } }
public void update Combo Box (  JCombo Box <  Track > box ) { box . remove All Items ( ) ; box . add Item ( null ) ;  List <  Track > tracks = get Track By Name List ( null ) ; for (  Track track : tracks ) { box . add Item ( track ) ; } }
public  Refactoring Session Transformer ( final boolean projects ) { f Projects = projects ; }
public  Compare Result open ( ) { final  Content Comparator [ ] comparator Array = comparators . to Array ( new  Content Comparator [ comparators . size ( ) ] ) ; final  Custom Compare Editor Input input = new  Custom Compare Editor Input ( modified , original , ancestor , comparator Array , compare Configuration , external Compare Handler ) ; if ( compare Configuration . is Left Editable ( ) || compare Configuration . is Right Editable ( ) ) { compare Configuration . set Property ( _ STR ,  Boolean .  FALSE ) ; input . set Always Dirty ( always Dirty ) ; } input . add Save Listener ( new  Proxy Compare Save Listener ( ) ) ; log . info (  Message Format . format ( _ STR , get Label NOLOC ( modified ) , get Label NOLOC ( original ) ) ) ; compare UIType . open Compare UI ( input ) ; final boolean contents Identical = ( input . get Compare Result ( ) == null ) ; final boolean contents Saved = ( input . get Saved Contents ( ) . length > _ NUM ) ; return new  Compare Result ( contents Identical , input . was OKPressed ( ) , contents Saved ) ; }
protected void add Resource (  String resource ) { if ( !  String Utils . is Empty ( resource ) ) { resources . add ( resource ) ; } }
public static boolean is Numeric (  String maybe Numeric ) { return maybe Numeric != null && maybe Numeric . matches ( _ STR ) ; }
public void open Key Store (  File key Store File ,  String default Password ) { try { if ( ! key Store File . is File ( ) ) {  JOption Pane . show Message Dialog ( frame ,  Message Format . format ( res . get String ( _ STR ) , key Store File ) , res . get String ( _ STR ) ,  JOption Pane .  WARNING_ MESSAGE ) ; return ; } if ( is Key Store File Open ( key Store File ) ) {  JOption Pane . show Message Dialog ( frame ,  Message Format . format ( res . get String ( _ STR ) , key Store File ) , res . get String ( _ STR ) ,  JOption Pane .  WARNING_ MESSAGE ) ; return ; }  Password password = ( default Password != null ) ? new  Password ( default Password . to Char Array ( ) ) : null ;  Key Store opened Key Store = null ; boolean first Try = _ BOOL ; while ( _ BOOL ) { if ( password == null ) { password = show Password Dialog ( key Store File ) ; } if ( password == null ) { return ; } try { opened Key Store =  Key Store Util . load ( key Store File , password ) ; break ; } catch (  Key Store Load Exception klex ) { if ( default Password == null || ! first Try ) { int try Again Choice = show Error Message ( key Store File , klex ) ; if ( try Again Choice ==  JOption Pane .  NO_ OPTION ) { return ; } } } password . null Password ( ) ; password = null ; first Try = _ BOOL ; } if ( opened Key Store == null ) {  JOption Pane . show Message Dialog ( frame ,  Message Format . format ( res . get String ( _ STR ) , key Store File . get Name ( ) ) , res . get String ( _ STR ) ,  JOption Pane .  WARNING_ MESSAGE ) ; return ; } kse Frame . add Key Store ( opened Key Store , key Store File , password ) ; } catch (  File Not Found Exception ex ) {  JOption Pane . show Message Dialog ( frame ,  Message Format . format ( res . get String ( _ STR ) , key Store File ) , res . get String ( _ STR ) ,  JOption Pane .  WARNING_ MESSAGE ) ; } catch (  Exception ex ) {  DError . display Error ( frame , ex ) ; } }
public final long add And Get ( long delta ) { for ( ; ; ) { long current = get ( ) ; long next = current + delta ; if ( compare And Set ( current , next ) ) return next ; } }
private final void append (  List < ? super  Name Value Pair > l , final  String k , final  String v ) { if ( v != null ) l . add ( new  Name Value Pair ( k , v ) ) ; }
protected  Properties create Properties (  URL location ) throws  IOException {  Input Stream is = null ; if ( location != null ) { is = location . open Stream ( ) ; }  Properties tmp Properties = new  Properties ( ) ; if ( is != null ) { tmp Properties . load ( is ) ; } return tmp Properties ; }
protected double calc Plan Weight ( final  T plan , final double max Score ) { if ( plan . get Score ( ) == null ) { return  Double .  Na N ; } double weight =  Math . exp ( this . beta * ( plan . get Score ( ) - max Score ) ) ; if ( weight <  MIN_ WEIGHT ) weight =  MIN_ WEIGHT ; return weight ; }
void find Value ( ) { if ( log . is Debug Enabled ( ) ) { log . debug ( _ STR + label ( ) ) ; } for ( int i = _ NUM ; i < _value . get Item Count ( ) ; i ++ ) {  String choice = _value . get Item At ( i ) ;  Setting List sl = choice Hash . get ( choice ) ; if ( sl . match ( ) ) { if ( log . is Debug Enabled ( ) ) { log . debug ( _ STR + i ) ; } _value . set Selected Item ( choice ) ; return ; } } if ( log . is Debug Enabled ( ) ) { log . debug ( _ STR ) ; } }
public java . lang .  String Builder insert ( int index , java . lang .  String string ) { if ( string == null ) { string = _ STR ; } int min = string . length ( ) ; if ( min != _ NUM ) { move ( min , index ) ; string . get Chars ( _ NUM , min , value , index ) ; count += min ; } return this ; }
public void mkdir (  String key ) throws  IOException { key = key . replace ( _ STR , _ STR ) ; if ( key . ends With ( _ STR ) && ! key . equals ( _ STR ) ) { throw new  Invalid Parameter Exception ( _ STR ) ; }  String [ ] split = key . split ( _ STR ) ;  String Builder builder = new  String Builder ( ) ; for (  String s : split ) { builder . append ( s ) ; if ( ! s . is Empty ( ) && ! exists ( builder . to String ( ) ) ) { zk State . set ( builder . to String ( ) , null ) ; } builder . append ( _ STR ) ; } }
public double calculate Log ( double value ) { return  Math . log ( value ) / this . base Log ; }
public static  Vector3 pow (  Vector3 o , double power ) { return new  Vector3 (  Math . pow ( o . x , power ) ,  Math . pow ( o . y , power ) ,  Math . pow ( o . z , power ) ) ; }
public  Datagram Packet response Receive ( ) throws  IOException { byte [ ] buf = new byte [ _ NUM ] ;  Datagram Packet dp = new  Datagram Packet ( buf , buf . length ) ; datagram Socket . receive ( dp ) ; return dp ; }
@  Override public void flush ( ) { flush ( _ BOOL ) ; }
public static float [ ] temperature To RGB ( int degrees K ) { int k =  Math Utils . constrain ( degrees K , _ NUM , _ NUM ) ; float a = ( k % _ NUM ) / _ NUM ; int i = ( ( k - _ NUM ) / _ NUM ) * _ NUM ; return new float [ ] { interp ( i , a ) , interp ( i + _ NUM , a ) , interp ( i + _ NUM , a ) } ; }
public  Advanced State Map .  Builder with Name (  Function <  Properties Map ,  String > mapper ) { this . name Mapper = mapper ; return this ; }
public synchronized void message (  Loco Net Message m ) { int op Code = m . get Op Code ( ) ; switch ( op Code ) { case  Ln Constants .  OPC_ PEER_ XFER : int src = m . get Element ( _ NUM ) ; int dst = m . get Element ( _ NUM ) + m . get Element ( _ NUM ) * _ NUM ; int [ ] packet = m . get Peer Xfr Data ( ) ; if ( src == low Part (  Loco Buffer Address ) ) {  String lbv = ( ( packet [ _ NUM ] != _ NUM ) ? dotme ( packet [ _ NUM ] ) : _ STR ) ; set LBVersion ( lbv ) ; } if ( dst ==  Loco Buffer Address && src == low Part ( unit Address ) && ( packet [ _ NUM ] == unit Sub Address ) ) { stop Timer ( ) ; reply Received ( ) ;  String fw = ( ( packet [ _ NUM ] != _ NUM ) ? dotme ( packet [ _ NUM ] ) : _ STR ) ; set LIOVersion ( fw ) ; if ( packet [ _ NUM ] ==  Loco IO .  LOCOIO_ SV_ READ || reading ) { if ( last Op Cv >= _ NUM && last Op Cv <= _ NUM ) { int data = ( packet [ _ NUM ] != _ NUM ) ? packet [ _ NUM ] : packet [ _ NUM ] ; int channel = ( last Op Cv / _ NUM ) - _ NUM ; if ( channel < _ NUM ) { log . warn ( _ STR ) ; channel = _ NUM ; } int type = last Op Cv - ( channel * _ NUM + _ NUM ) ; log . debug ( _ STR + channel + _ STR + type + _ STR + ( type == _ NUM ? _ STR : type == _ NUM ? _ STR : type == _ NUM ? _ STR : _ STR ) + _ STR +  Integer . to Hex String ( data ) ) ; if ( type == _ NUM ) { set V2 ( channel , data ) ; set Mode ( channel , _ STR ) ; } else if ( type == _ NUM ) { set V1 ( channel , data ) ; set Mode ( channel , _ STR ) ; } else if ( type == _ NUM ) { set SV ( channel , data ) ;  Loco IOMode lim = validmodes . get Loco IOMode For ( get SV ( channel ) , get V1 ( channel ) , get V2 ( channel ) ) ; if ( lim == null ) { set Mode ( channel , _ STR ) ; set Addr ( channel , _ NUM ) ; log . debug ( _ STR ) ; } else { set Mode ( channel , lim . get Full Mode ( ) ) ; set Addr ( channel , validmodes . values To Address ( lim . get Opcode ( ) , get SV ( channel ) , get V1 ( channel ) , get V2 ( channel ) ) ) ; } log . debug ( _ STR + _ STR +  Integer . to Hex String ( get SV ( channel ) ) + _ STR + _ STR +  Integer . to Hex String ( get V1 ( channel ) ) + _ STR + _ STR +  Integer . to Hex String ( get V2 ( channel ) ) + _ STR + _ STR + get Addr ( channel ) + _ STR +  Integer . to Hex String ( get Addr ( channel ) ) + _ STR ) ; } else { log . warn ( _ STR + type + _ STR + channel ) ; } } else { } } issue Next Operation ( ) ; return ; } else { return ; } case  Ln Constants .  OPC_ INPUT_ REP : if ( log . is Debug Enabled ( ) ) { log . debug (  Ln Constants .  OPC_ NAME ( op Code ) + _ STR ) ; } for ( int i = _ NUM ; i < _num Rows ; i ++ ) { if ( capture [ i ] ) { if ( log . is Debug Enabled ( ) ) { log . debug ( _ STR + i ) ; } int val1 = m . get Element ( _ NUM ) ; int val2 = m . get Element ( _ NUM ) ; set Addr ( i , ( ( val2 & _ NUM ) << _ NUM ) * _ NUM + ( ( val1 & _ NUM ) << _ NUM ) | ( ( ( val2 &  Ln Constants .  OPC_ SW_ REQ_ DIR ) ==  Ln Constants .  OPC_ SW_ REQ_ DIR ) ? _ NUM : _ NUM ) ) ; capture [ i ] = _ BOOL ; } } return ; case  Ln Constants .  OPC_ SW_ REQ : if ( log . is Debug Enabled ( ) ) { log . debug (  Ln Constants .  OPC_ NAME ( op Code ) + _ STR ) ; } for ( int i = _ NUM ; i < _num Rows ; i ++ ) { if ( capture [ i ] ) { if ( log . is Debug Enabled ( ) ) { log . debug ( _ STR + i ) ; } int val1 = m . get Element ( _ NUM ) ; int val2 = m . get Element ( _ NUM ) ; int addr =  Loco IO .  SENSOR_ ADR ( val1 , val2 ) ; set Addr ( i , addr ) ; capture [ i ] = _ BOOL ; } } return ; default : } }
public boolean handle Exception From Server (  Writer writer ,  Reader reader ,  Throwable ex ) { if ( ex instanceof  Closed Channel Exception ) { if ( _logger . is Loggable (  Level .  FINE ) ) _logger . log (  Level .  FINE , _ STR + writer . get End Point Address ( ) + _ STR ) ; return _ BOOL ; } if ( ex instanceof  Marshal Context Cleared Exception ) { if ( _logger . is Loggable (  Level .  FINE ) ) _logger . log (  Level .  FINE , _ STR + writer . get End Point Address ( ) + _ STR ) ; return _ BOOL ; } try {  String msg = _ STR + writer . get End Point Address ( ) + _ STR ; if ( ex instanceof  LRMIUnhandled Exception ) { if ( _logger . is Loggable (  Level .  FINE ) ) _logger . log (  Level .  FINE , msg , ex ) ;  LRMIUnhandled Exception lrmiue = (  LRMIUnhandled Exception ) ex ; if ( lrmiue . get Stage ( ) ==  Stage .  DESERIALIZATION ) { reader . reset Context ( ) ; } if ( writer . is Open ( ) ) writer . write Reply ( new  Reply Packet ( null , lrmiue ) ) ; return _ BOOL ; } else if ( ex instanceof  Runtime Exception || ex instanceof  Invalid Class Exception ) { if ( _logger . is Loggable (  Level .  SEVERE ) ) _logger . log (  Level .  SEVERE , msg , ex ) ; } else if ( ex instanceof  Unmarshal Exception ) { if ( _logger . is Loggable (  Level .  WARNING ) ) _logger . log (  Level .  WARNING , msg , ex ) ; } else { if ( _logger . is Loggable (  Level .  FINE ) ) _logger . log (  Level .  FINE , msg , ex ) ; } if ( writer . is Open ( ) ) writer . write Reply ( new  Reply Packet ( null , new  Protocol Exception ( msg , ex ) ) ) ; return _ BOOL ; } catch (  Exception ex2 ) { if ( _logger . is Loggable (  Level .  FINE ) ) _logger . log (  Level .  FINE , _ STR + writer . get End Point Address ( ) + _ STR , ex ) ; return _ BOOL ; } }
public  String sprintf ( ) { final  Iterator <  Conversion Specification > e = v Fmt . iterator ( ) ;  Conversion Specification cs ; char c ; final  String Builder sb = new  String Builder ( ) ; while ( e . has Next ( ) ) { cs = e . next ( ) ; c = cs . get Conversion Character ( ) ; if ( c == _ STR ) { sb . append ( cs . get Literal ( ) ) ; } else if ( c == _ STR ) { sb . append ( _ STR ) ; } } return sb . to String ( ) ; }
default  String resource Name (  String table Name ,  String type ) { return  String . format (  RESOURCE_ NAME , table Name , type ) ; }
protected void update Combo Boxes Load Change ( ) { if ( auto Track Check Box . is Selected ( ) ) { update Location Track Combo Box ( ) ; } if ( auto Destination Track Check Box . is Selected ( ) ) { update Destination Track Combo Box ( ) ; } if ( auto Final Dest Track Check Box . is Selected ( ) ) { update Final Destination ( ) ; } }
public  String remove Class Column Tip Text ( ) { return _ STR ; }
public static  String join (  Named Value [ ] values ,  String separator ) {  String Builder buff = new  String Builder ( ) ; for ( int i = _ NUM ; i < values . length ; i ++ ) { buff . append ( values [ i ] ) ; if ( i < values . length - _ NUM ) buff . append ( separator ) ; } return buff . to String ( ) ; }
protected  String source Class (  Attribute c , double [ ] dist ) { if ( c . is Nominal ( ) ) { return  Integer . to String (  Utils . max Index ( dist ) ) ; } else { return  Double . to String ( dist [ _ NUM ] ) ; } }
public void done ( ) throws  IOException { printer . flush ( ) ; }
int request Group Data ( char group Num ) { set Curr Data Group ( group Num ) ; curr Grp Items = known Grp Items . get (  Integer . value Of ( get Curr Data Group ( ) ) ) ; char [ ] pay Load = { group Num } ; return ( write Telegram ( pay Load ,  CMD_ GROUP_ READ , null ) ) ; }
protected  String compute Full Url (  URL base Url ,  String link ) { if ( link == null || link . length ( ) == _ NUM ) { return null ; } if ( ! link . starts With ( _ STR ) ) { if ( link . starts With ( _ STR ) ) { link = base Url . get Protocol ( ) + _ STR + base Url . get Authority ( ) + link ; } else { if ( link . contains ( _ STR ) ) { return null ; }  String path = base Url . get Path ( ) ; if ( ! path . ends With ( _ STR ) ) { int sep = path . last Index Of ( _ STR ) ;  String file = path . substring ( sep + _ NUM ) ; if ( file . contains ( _ STR ) || file . contains ( _ STR ) ) path = path . substring ( _ NUM , sep ) ; } link = base Url . get Protocol ( ) + _ STR + base Url . get Authority ( ) + path + _ STR + link ; } } link = normalize Url Ending ( link ) ;  String l = link . to Lower Case (  Locale .  ROOT ) ; if ( l . ends With ( _ STR ) || l . ends With ( _ STR ) || l . ends With ( _ STR ) || l . ends With ( _ STR ) ) { return null ; } return link ; }
public long skip ( long bytes ) throws  IOException { if ( closed ) { throw new  IOException ( _ STR ) ; } int av = available ( ) ; if ( av == _ NUM ) { av = make Available ( ) ; if ( av == _ NUM ) { return _ NUM ; } } long res =  Math . min ( av , bytes ) ; head += res ; return res ; }
protected void draw Center Text (  Canvas c ) {  Char Sequence center Text = m Chart . get Center Text ( ) ; if ( m Chart . is Draw Center Text Enabled ( ) && center Text != null ) {  Point F center = m Chart . get Center Circle Box ( ) ; float inner Radius = m Chart . is Draw Hole Enabled ( ) && ! m Chart . is Draw Slices Under Hole Enabled ( ) ? m Chart . get Radius ( ) * ( m Chart . get Hole Radius ( ) / _ NUM ) : m Chart . get Radius ( ) ;  Rect F hole Rect = m Rect Buffer [ _ NUM ] ; hole Rect . left = center . x - inner Radius ; hole Rect . top = center . y - inner Radius ; hole Rect . right = center . x + inner Radius ; hole Rect . bottom = center . y + inner Radius ;  Rect F bounding Rect = m Rect Buffer [ _ NUM ] ; bounding Rect . set ( hole Rect ) ; float radius Percent = m Chart . get Center Text Radius Percent ( ) / _ NUM ; if ( radius Percent > _ NUM ) { bounding Rect . inset ( ( bounding Rect . width ( ) - bounding Rect . width ( ) * radius Percent ) / _ NUM , ( bounding Rect . height ( ) - bounding Rect . height ( ) * radius Percent ) / _ NUM ) ; } if ( ! center Text . equals ( m Center Text Last Value ) || ! bounding Rect . equals ( m Center Text Last Bounds ) ) { m Center Text Last Bounds . set ( bounding Rect ) ; m Center Text Last Value = center Text ; float width = m Center Text Last Bounds . width ( ) ; m Center Text Layout = new  Static Layout ( center Text , _ NUM , center Text . length ( ) , m Center Text Paint , ( int )  Math . max (  Math . ceil ( width ) , _ NUM ) ,  Layout .  Alignment .  ALIGN_ CENTER , _ NUM , _ NUM , _ BOOL ) ; } float layout Height = m Center Text Layout . get Height ( ) ; c . save ( ) ; if (  Build .  VERSION .  SDK_ INT >= _ NUM ) {  Path path = new  Path ( ) ; path . add Oval ( hole Rect ,  Path .  Direction .  CW ) ; c . clip Path ( path ) ; } c . translate ( bounding Rect . left , bounding Rect . top + ( bounding Rect . height ( ) - layout Height ) / _ NUM ) ; m Center Text Layout . draw ( c ) ; c . restore ( ) ; } }
void add To Prototype Callback ( ) ;
public  All To All Panel (  All To All connector ,  Network Panel network Panel ) { super ( ) ; this . connection = connector ; allow Self Connect Panel = new  JPanel ( new  Flow Layout (  Flow Layout .  LEFT ) ) ; allow Self Connect Panel . add ( new  JLabel ( _ STR ) ) ; allow Self Connect Panel . add ( allow Self Connect Chk Bx ) ; fill Field Values ( ) ; add ( allow Self Connect Panel ) ; }
private void allocate_sections ( int p_section_count ) { section_list . ensure Capacity ( p_section_count ) ; while ( section_list . size ( ) < p_section_count ) { section_list . add ( new  Maze Search Element ( ) ) ; } }
public  Weight Distribution (  Column Example Table column Table , int [ ] selection , int attribute Number ) { calculate Label Weights ( column Table , selection , attribute Number ) ; left Label Weights = new double [ total Label Weights . length ] ; left Weight = _ NUM ; total Weight = get Total Weight ( total Label Weights ) ; if ( has Missings ) { missings Weight = get Total Weight ( missings Label Weights ) ; right Weight = total Weight - missings Weight ; right Label Weights = array Difference ( total Label Weights , missings Label Weights ) ; } else { missings Weight = _ NUM ; right Weight = total Weight ; right Label Weights = new double [ total Label Weights . length ] ;  System . arraycopy ( total Label Weights , _ NUM , right Label Weights , _ NUM , total Label Weights . length ) ; } }
public static  String remove Extension (  String file Name ) { int index = file Name . last Index Of ( _ STR ) ; if ( index == - _ NUM ) { return file Name ; } else { return file Name . substring ( _ NUM , index ) ; } }
public void delete (  String name ) throws  IOException { if ( name . equals Ignore Case (  KEY_ ID ) ) { id = null ; } else { throw new  IOException ( _ STR + _ STR ) ; } encode This ( ) ; }
public static  Data Frame normalize (  Data Frame data Frame , double min , double max ) { return normalize ( data Frame , min , max ,  Collections . <  String > empty List ( ) ) ; }
private static void add Leaf With Non Existing Parents (  Spatial root ,  Spatial leaf ) { if ( ! ( root instanceof  Node ) ) { logger . log (  Level .  WARNING , _ STR , new  Object [ ] { leaf . get Name ( ) , root . get Name ( ) } ) ; return ; } for (  Spatial s = leaf ; s . get Parent ( ) != null ; s = s . get Parent ( ) ) {  Spatial parent = s . get Parent ( ) ;  Spatial other = find Tagged Spatial ( root , parent ) ; if ( other == null ) { continue ; } if ( other instanceof  Node ) { logger . log (  Level .  INFO , _ STR , new  Object [ ] { s , other , root , leaf } ) ; for (  Spatial spt = leaf ; spt != parent ; spt = spt . get Parent ( ) ) { spt . set User Data (  ORIGINAL_ NAME , spt . get Name ( ) ) ; spt . set User Data (  ORIGINAL_ PATH , get Spatial Path ( spt ) ) ; spt = spt . get Parent ( ) ; }  Node other Node = (  Node ) other ; other Node . attach Child ( s ) ; logger . log (  Log Level .  USERINFO , _ STR , new  Object [ ] { other . get Name ( ) , leaf . get Name ( ) } ) ; return ; } else { logger . log (  Level .  WARNING , _ STR , new  Object [ ] { leaf , other , root } ) ; } } logger . log (  Level .  WARNING , _ STR , leaf . get Name ( ) ) ; }
private void adjust Block Listeners (  List <  OBlock > old Range ,  List <  OBlock > new Range ,  Tracker tracker ) {  Iterator <  OBlock > iter = new Range . iterator ( ) ; while ( iter . has Next ( ) ) {  OBlock b = iter . next ( ) ; if ( old Range . contains ( b ) ) { old Range . remove ( b ) ; continue ; } add Block Listener ( b , tracker ) ; } iter = old Range . iterator ( ) ; while ( iter . has Next ( ) ) { remove Block Listener ( iter . next ( ) , tracker ) ; } }
static public  String hex Encode ( byte [ ] a Input ) {  String Buffer result = new  String Buffer ( ) ; final char [ ] digits = { _ STR , _ STR , _ STR , _ STR , _ STR , _ STR , _ STR , _ STR , _ STR , _ STR , _ STR , _ STR , _ STR , _ STR , _ STR , _ STR } ; for ( int idx = _ NUM ; idx < a Input . length ; ++ idx ) { byte b = a Input [ idx ] ; result . append ( digits [ ( b & _ NUM ) > > _ NUM ] ) ; result . append ( digits [ b & _ NUM ] ) ; } return result . to String ( ) ; }
private static  Size clamp Size (  Size original , double max Area ,  Size max Size ) { if ( original . get Width ( ) * original . get Height ( ) < max Area && original . get Width ( ) < max Size . get Width ( ) && original . get Height ( ) < max Size . get Height ( ) ) { return original ; } double ratio =  Math . min (  Math . sqrt ( max Area / original . area ( ) ) , _ NUM ) ; int width = ( int )  Math . round ( original . width ( ) * ratio ) ; int height = ( int )  Math . round ( original . height ( ) * ratio ) ; if ( width > max Size . width ( ) || height > max Size . height ( ) ) { return compute Fit Within Size ( original , max Size ) ; } return new  Size ( width , height ) ; }
TCPChannel (  TCPTransport tr ,  TCPEndpoint ep ) { this . tr = tr ; this . ep = ep ; }
@  Override public final  String to String ( ) {  String Builder buffer = new  String Builder ( ) ; buffer . append ( _ STR ) ; for ( int i = _ NUM ; i < fields . size ( ) ; i ++ ) {  Indexable Field field = fields . get ( i ) ; buffer . append ( field . to String ( ) ) ; if ( i != fields . size ( ) - _ NUM ) { buffer . append ( _ STR ) ; } } buffer . append ( _ STR ) ; return buffer . to String ( ) ; }
public static byte [ ] encode ( byte [ ] data ) {  Byte Array Output Stream b Out = new  Byte Array Output Stream ( ) ; try { encoder . encode ( data , _ NUM , data . length , b Out ) ; } catch (  IOException e ) { throw new  Runtime Exception ( _ STR + e ) ; } return b Out . to Byte Array ( ) ; }
public static  Face draw Dir (  Direction dir ,  Mesh Model model , double min X , double min Y , double min Z , double max X , double max Y , double max Z ,  Cube Texture Coordinates texture Coordinates ) { switch ( dir ) { case  DOWN : return draw Down ( model , min X , min Y , min Z , max X , max Y , max Z , texture Coordinates ) ; case  UP : return draw Up ( model , min X , min Y , min Z , max X , max Y , max Z , texture Coordinates ) ; case  NORTH : return draw North ( model , min X , min Y , min Z , max X , max Y , max Z , texture Coordinates ) ; case  SOUTH : return draw South ( model , min X , min Y , min Z , max X , max Y , max Z , texture Coordinates ) ; case  EAST : return draw East ( model , min X , min Y , min Z , max X , max Y , max Z , texture Coordinates ) ; case  WEST : return draw West ( model , min X , min Y , min Z , max X , max Y , max Z , texture Coordinates ) ; } throw new  Render Exception ( _ STR ) ; }
public  MAVLink Message (  MAVLink Schema schema ,  Byte Buffer buffer ) throws  MAVLink Protocol Exception ,  MAVLink Unknown Message ,  Buffer Underflow Exception { if ( buffer . remaining ( ) <  NON_ PAYLOAD_ LENGTH ) { throw new  Buffer Underflow Exception ( ) ; } int start Pos = buffer . position ( ) ; byte start Sign = buffer . get ( ) ; if ( start Sign !=  START_ OF_ FRAME ) { throw new  MAVLink Protocol Exception (  String . format ( _ STR , start Sign ,  START_ OF_ FRAME ) ) ; } int payload Len = buffer . get ( ) & _ NUM ; if ( buffer . remaining ( ) < payload Len +  NON_ PAYLOAD_ LENGTH - _ NUM ) { buffer . position ( start Pos ) ; throw new  Buffer Underflow Exception ( ) ; } sequence = buffer . get ( ) ; system ID = buffer . get ( ) & _ NUM ; component ID = buffer . get ( ) & _ NUM ; msg ID = buffer . get ( ) & _ NUM ; this . schema = schema ; this . definition = schema . get Message Definition ( msg ID ) ; if ( definition == null ) { buffer . position ( buffer . position ( ) + payload Len +  CRC_ LENGTH ) ; throw new  MAVLink Unknown Message (  String . format ( _ STR , msg ID ) ) ; } if ( payload Len != definition . payload Length ) { buffer . position ( buffer . position ( ) + payload Len +  CRC_ LENGTH ) ; throw new  MAVLink Unknown Message (  String . format ( _ STR , definition . name , msg ID , payload Len , definition . payload Length ) ) ; } this . payload = new byte [ definition . payload Length ] ; buffer . get ( payload ) ; crc =  Short . reverse Bytes ( buffer . get Short ( ) ) & _ NUM ; int end Pos = buffer . position ( ) ; buffer . position ( start Pos ) ; int crc Calc = calculate CRC ( buffer ) ; buffer . position ( end Pos ) ; if ( crc != crc Calc ) { throw new  MAVLink Unknown Message (  String . format ( _ STR , definition . name , msg ID , crc , crc Calc ) ) ; } this . payload BB =  Byte Buffer . wrap ( payload ) ; payload BB . order ( schema . get Byte Order ( ) ) ; }
public static double log1p ( final double x ) { if ( x == - _ NUM ) { return  Double .  NEGATIVE_ INFINITY ; } if ( x ==  Double .  POSITIVE_ INFINITY ) { return  Double .  POSITIVE_ INFINITY ; } if ( x > _ NUM || x < - _ NUM ) { final double xpa = _ NUM + x ; final double xpb = - ( xpa - _ NUM - x ) ; final double [ ] hi Prec = new double [ _ NUM ] ; final double lores = log ( xpa , hi Prec ) ; if (  Double . is Infinite ( lores ) ) { return lores ; } final double fx1 = xpb / xpa ; final double epsilon = _ NUM * fx1 + _ NUM ; return epsilon * fx1 + hi Prec [ _ NUM ] + hi Prec [ _ NUM ] ; } else { final double y = ( x *  F_1_3 -  F_1_2 ) * x + _ NUM ; return y * x ; } }
protected  Script Builder big Num ( long num ) { return big Num ( chunks . size ( ) , num ) ; }
public final void change_entries (  Brd Tracep p_obj ,  Polyline p_new_polyline , int p_keep_at_start_count , int p_keep_at_end_count ) { int compensated_half_width = p_obj . get_half_width ( ) + get_clearance_compensation ( p_obj . clearance_idx ( ) , p_obj . get_layer ( ) ) ;  Array List <  Shape Tile > changed_shapes = offset_shapes ( p_new_polyline , compensated_half_width , p_keep_at_start_count , p_new_polyline . plaline_len ( - _ NUM ) - p_keep_at_end_count ) ; int old_shape_count = p_obj . tree_shape_count ( this ) ; int new_shape_count = changed_shapes . size ( ) + p_keep_at_start_count + p_keep_at_end_count ;  Awtree Node Leaf [ ] new_leaf_arr = new  Awtree Node Leaf [ new_shape_count ] ;  Shape Tile [ ] new_precalculated_tree_shapes = new  Shape Tile [ new_shape_count ] ;  Awtree Node Leaf [ ] old_entries = p_obj . get_search_tree_entries ( this ) ; for ( int index = _ NUM ; index < p_keep_at_start_count ; ++ index ) { new_leaf_arr [ index ] = old_entries [ index ] ; new_precalculated_tree_shapes [ index ] = p_obj . get_tree_shape ( this , index ) ; } for ( int index = p_keep_at_start_count ; index < old_shape_count - p_keep_at_end_count ; ++ index ) { remove_leaf ( old_entries [ index ] ) ; } for ( int i = _ NUM ; i < p_keep_at_end_count ; ++ i ) { int new_index = new_shape_count - p_keep_at_end_count + i ; int old_index = old_shape_count - p_keep_at_end_count + i ; new_leaf_arr [ new_index ] = old_entries [ old_index ] ; new_leaf_arr [ new_index ] . shape_index_in_object = new_index ; new_precalculated_tree_shapes [ new_index ] = p_obj . get_tree_shape ( this , old_index ) ; } for ( int index = p_keep_at_start_count ; index < new_shape_count - p_keep_at_end_count ; ++ index ) { new_precalculated_tree_shapes [ index ] = changed_shapes . get ( index - p_keep_at_start_count ) ; } p_obj . set_precalculated_tree_shapes ( new_precalculated_tree_shapes , this ) ; for ( int index = p_keep_at_start_count ; index < new_shape_count - p_keep_at_end_count ; ++ index ) { new_leaf_arr [ index ] = insert ( p_obj , index ) ; } p_obj . set_search_tree_entries ( this , new_leaf_arr ) ; }
public void paint Component Background (  Graphics g ) { super . paint Component Background ( g ) ; int clip X = g . get Clip X ( ) ; int clip Y = g . get Clip Y ( ) ; int clip W = g . get Clip Width ( ) ; int clip H = g . get Clip Height ( ) ; int width = get Width ( ) ; int height = get Height ( ) ; int y = get Y ( ) ; if ( infinite ) { int block Size = get Width ( ) / _ NUM ; int x = get X ( ) + ( int ) ( ( ( ( float ) value ) / ( ( float ) max Value - min Value ) ) * ( get Width ( ) - block Size ) ) ; g . clip Rect ( x , y , block Size , height - _ NUM ) ; } else { if ( vertical ) { int actual Height = ( int ) ( ( ( ( float ) value ) / ( ( float ) max Value - min Value ) ) * get Height ( ) ) ; y += height - actual Height ; } else { width = ( int ) ( ( ( ( float ) value ) / ( ( float ) max Value - min Value ) ) * get Width ( ) ) ; } g . clip Rect ( get X ( ) , y , width , height ) ; } painting Full = _ BOOL ; super . paint Component Background ( g ) ; painting Full = _ BOOL ; g . set Clip ( clip X , clip Y , clip W , clip H ) ; if ( thumb Image != null && ! infinite ) { if ( ! vertical ) { int x Pos = get X ( ) + width - thumb Image . get Width ( ) / _ NUM ; x Pos =  Math . max ( get X ( ) , x Pos ) ; x Pos =  Math . min ( get X ( ) + get Width ( ) - thumb Image . get Width ( ) , x Pos ) ; g . draw Image ( thumb Image , x Pos , y + height / _ NUM - thumb Image . get Height ( ) / _ NUM ) ; } else { int y Pos = y ; g . draw Image ( thumb Image , get X ( ) + width / _ NUM - thumb Image . get Width ( ) / _ NUM , y Pos ) ; } } }
public void add Action (  Entity Action ea ) { actions . add Element ( ea ) ; process Game Event ( new  Game New Action Event ( this , ea ) ) ; }
public static  JSONObject read JSONObject ( final  JSONArray json Array , final int index , final boolean required , final boolean not Null ) throws  JSONException { if ( required ) { return json Array . get JSONObject ( index ) ; } if ( not Null && json Array . is Null ( index ) ) { throw new  JSONException (  String . format (  Locale .  US ,  NULL_ VALUE_ FORMAT_ ARRAY , index ) ) ; }  JSONObject value = null ; if ( ! json Array . is Null ( index ) ) { value = json Array . get JSONObject ( index ) ; } return value ; }
public static void wait Element To Not Be Present (  Search Context parent ,  By by , int wait In Seconds ) {  Preconditions . check Not Null ( parent ) ;  Preconditions . check Not Null ( by ) ; try {  Web Element Wait wait = new  Web Element Wait ( parent , wait In Seconds ) ; wait . until ( null ) ; } catch (  Timeout Exception e ) { throw new  Timeout Exception (  String . format ( _ STR , by , wait In Seconds ) , e ) ; } }
public final  Test Subscriber assert Terminated ( ) { if ( done . get Count ( ) != _ NUM ) { fail ( _ STR , _ STR , errors ) ; } long c = completions ; if ( c > _ NUM ) { fail ( _ STR , _ STR + c , errors ) ; } int s = errors . size ( ) ; if ( s > _ NUM ) { fail ( _ STR , _ STR + s , errors ) ; } if ( c != _ NUM && s != _ NUM ) { fail ( _ STR , _ STR + c , errors ) ; } return this ; }
public boolean is Vimeo URLValid ( ) {  String video ID = get Extracted Identifier ( ) ; return video ID . length ( ) > _ NUM &&  Text Utils . is Digits Only ( video ID ) ; }
private void update Downloaded Files (  SQLite Database db ,  String new Account Name ,  String old Account Name ) {  String where Clause =  Provider Table Meta .  FILE_ ACCOUNT_ OWNER + _ STR +  Provider Table Meta .  FILE_ STORAGE_ PATH + _ STR ;  Cursor c = db . query (  Provider Table Meta .  FILE_ TABLE_ NAME , null , where Clause , new  String [ ] { new Account Name } , null , null , null ) ; try { if ( c . move To First ( ) ) {  String old Account Path =  File Storage Utils . get Save Path ( old Account Name ) ;  String new Account Path =  File Storage Utils . get Save Path ( new Account Name ) ;  File old Account Folder = new  File ( old Account Path ) ;  File new Account Folder = new  File ( new Account Path ) ; old Account Folder . rename To ( new Account Folder ) ; do {  String old Path = c . get String ( c . get Column Index (  Provider Table Meta .  FILE_ STORAGE_ PATH ) ) ;  OCFile file = new  OCFile ( c . get String ( c . get Column Index (  Provider Table Meta .  FILE_ PATH ) ) ) ;  String new Path =  File Storage Utils . get Default Save Path For ( new Account Name , file ) ;  Content Values cv = new  Content Values ( ) ; cv . put (  Provider Table Meta .  FILE_ STORAGE_ PATH , new Path ) ; db . update (  Provider Table Meta .  FILE_ TABLE_ NAME , cv ,  Provider Table Meta .  FILE_ STORAGE_ PATH + _ STR , new  String [ ] { old Path } ) ;  Log_ OC . v ( _ STR , _ STR + old Path + _ STR + new Path ) ; } while ( c . move To Next ( ) ) ; } } finally { c . close ( ) ; } }
public void dump Options ( ) { logger . info ( _ STR ) ; for (  Method getter :  Get Configuration Interface . class . get Methods ( ) ) {  String getter Name = getter . get Name ( ) ; try {  Object result = getter . invoke (  Configuration Manager . get Current Profile ( ) ) ; if ( result instanceof  Boolean ) { result =  Localization Helper . get Yes Or No ( (  Boolean ) result ) ; } if ( result instanceof  List ) { for ( int i = _ NUM ; i < ( (  List ) result ) . size ( ) ; i ++ ) { assert ( (  List ) result ) . get ( i ) instanceof  Custom Catalog Entry ;  Custom Catalog Entry c = ( (  List <  Custom Catalog Entry > ) result ) . get ( i ) ;  String  Option Name =  Helper . pad (  Localization .  Main . get Text ( _ STR ) + _ STR + ( i + _ NUM ) + _ STR + c . get At Top ( ) . to String ( ) , _ STR , _ NUM ) + _ STR ; logger . info (  Option Name + c . get Label ( ) + _ STR + c . get Value ( ) . to String ( ) + _ STR + c . get At Top ( ) . to String ( ) ) ; } } else {  String option Name = getter Name . substring ( _ NUM ) ; dump Option ( option Name , result ) ; } } catch (  Illegal Access Exception e ) { logger . warn ( _ STR , e ) ; } catch (  Invocation Target Exception e ) { logger . warn ( _ STR , e ) ; } } logger . info ( _ STR ) ; }
private  Json Node parse Language Resource (  Resource resource ) throws  IOException {  Input Stream stream = resource . as Stream ( ) ; if ( stream == null ) return null ; try {  Json Node tree = mapper . read Tree ( stream ) ; return tree ; } finally { stream . close ( ) ; } }
public  Collection <  Tuple2 <  Transition State ,  Double > > start States ( ) {  List <  Tuple2 <  Transition State ,  Double > > result = new  Array List <  Tuple2 <  Transition State ,  Double > > ( ) ; { double score =  Math . log (  LINE_ MRGN_ PROB ) ; add No Sub Glyph Start State ( result , new int [ _ NUM ] ,  Transition State Type .  LMRGN , - _ NUM , score ) ; } for ( int dest Language = _ NUM ; dest Language < num Languages ; ++ dest Language ) {  Single Language Model dest LM = lm . get ( dest Language ) ; double dest Language Prior = lm . language Prior ( dest Language ) ; for ( int c : dest LM . get Active Characters ( ) ) { if ( c != space Char Index ) { double score =  Math . log ( _ NUM -  LINE_ MRGN_ PROB ) +  Math . log ( get Ngram Prob ( dest LM , new int [ _ NUM ] , c ) ) +  Math . log ( dest Language Prior ) ; add Glyph Start States ( result , c , new int [ ] { c } ,  Transition State Type .  TMPL , dest Language , score ) ; } } } { double total Space Prob = _ NUM ; for ( int language = _ NUM ; language < num Languages ; ++ language ) total Space Prob += get Ngram Prob ( lm . get ( language ) , new int [ _ NUM ] , space Char Index ) * lm . language Prior ( language ) ; double score =  Math . log ( _ NUM -  LINE_ MRGN_ PROB ) +  Math . log ( total Space Prob ) ; add No Sub Glyph Start State ( result , new int [ ] { space Char Index } ,  Transition State Type .  TMPL , - _ NUM , score ) ; } return result ; }
public boolean remove Container And Cancel If Necessary (  Image Container container ) { m Containers . remove ( container ) ; if ( m Containers . is Empty ( ) ) { m Request . cancel ( ) ; return _ BOOL ; } return _ BOOL ; }
public  Kernel Density Function (  Collection < double [ ] > points ) { this ( points . to Array ( new double [ points . size ( ) ] [ ] ) ) ; }
private static  Object clone Serializable Object (  Object o ) throws  IOException ,  Class Not Found Exception {  Byte Array Output Stream b = new  Byte Array Output Stream ( ) ;  Object Output Stream out = new  Object Output Stream ( b ) ; out . write Object ( o ) ; out . flush ( ) ; out . close ( ) ;  Byte Array Input Stream bi = new  Byte Array Input Stream ( b . to Byte Array ( ) ) ;  Object Input Stream in = new  Object Input Stream ( bi ) ; return in . read Object ( ) ; }
public  Zip Entry (  String name ) {  Objects . require Non Null ( name , _ STR ) ; if ( name . length ( ) > _ NUM ) { throw new  Illegal Argument Exception ( _ STR ) ; } this . name = name ; }
public void _test Statements ( ) throws  Exception {  Connection connection = get Connection Via Driver Manager ( ) ; connection . set Auto Commit ( _ BOOL ) ; try {  Statement stmt = connection . create Statement ( ) ;  Result Set rs = stmt . execute Query ( _ STR ) ; rs . close ( ) ;  Random Selector selector1 = new  Random Selector ( stmt ,  SELECT_ TABLE_1 ,  RECORD_ COUNT ) ;  Random Selector selector2 = new  Random Selector ( stmt ,  SELECT_ TABLE_2 ,  RECORD_ COUNT ) ;  Thread thread1 = new  Thread ( selector1 , _ STR ) ;  Thread thread2 = new  Thread ( selector2 , _ STR ) ; thread1 . start ( ) ; thread2 . start ( ) ;  Thread . sleep (  TEST_ TIME_ SECONDS * _ NUM ) ; selector1 . stop ( ) ; selector2 . stop ( ) ; thread1 . join ( ) ; thread2 . join ( ) ; stmt . close ( ) ; } finally { connection . close ( ) ; } }
void read Dictionary (  String filename ,  String suffix ,  Input Stream res ) throws  IOException {  Dictionary Names nms = new  Dictionary Names ( filename , suffix ) ;  Buffered Reader in = new  Buffered Reader ( new  Input Stream Reader ( res ) ) ;  String line ; while ( ( line = in . read Line ( ) ) != null ) {  String [ ] terms = splitter . split ( line ) ; if ( terms . length > max Phrase Length ) continue ; if ( terms . length == _ NUM ) continue ;  Gaz Entry ge = gaz . get ( terms [ _ NUM ] ) ; if ( ge == null ) { gaz . put ( terms [ _ NUM ] , new  Gaz Entry ( terms , _ NUM , nms ) ) ; } else { ge . add Child ( terms , _ NUM , nms ) ; } } in . close ( ) ; }
private  T match Tokens (  String target Token ,  String request Token ) { int wildcard Index = _ NUM ; if ( target Token == null && request Token == null ) { return exact Match ; } if ( target Token == null || request Token == null ) { return no Match ; } int begin Target Index = _ NUM ; int begin Request Index = _ NUM ;  String substr = null ; int target Token Length = target Token . length ( ) ; int request Token Length = request Token . length ( ) ; if ( target Token . index Of ( one Level Wildcard , begin Target Index ) != - _ NUM ) { while ( ( wildcard Index = target Token . index Of ( one Level Wildcard , begin Target Index ) ) != - _ NUM ) { if ( wildcard Index > begin Target Index ) { substr = target Token . substring ( begin Target Index , wildcard Index ) ; if ( ( begin Request Index = request Token . index Of ( substr , begin Request Index ) ) == - _ NUM ) { return no Match ; } begin Target Index = begin Target Index + substr . length ( ) + one Level Wildcard Length ; begin Request Index = begin Request Index + substr . length ( ) ; } else { if ( wildcard Index == begin Target Index ) { if ( target Token Length == one Level Wildcard Length ) { return wildcard Match ; } else { begin Target Index = begin Target Index + one Level Wildcard Length ; continue ; } } } } if ( begin Target Index >= target Token Length ) { return wildcard Match ; }  String target Str = target Token . substring ( begin Target Index , target Token Length ) ;  String rem Request = request Token . substring ( begin Request Index , request Token Length ) ; int rem Request Index = - _ NUM ; if ( ( rem Request Index = rem Request . last Index Of ( target Str , rem Request . length ( ) - _ NUM ) ) == - _ NUM ) { return no Match ; } else { begin Request Index = begin Request Index + rem Request Index ; if ( begin Request Index + target Str . length ( ) >= request Token Length ) { return wildcard Match ; } else { return no Match ; } } } else { if ( target Token . equals ( request Token ) ) { return exact Match ; } } return no Match ; }
public void add Vertex (  Value Graph Vertex v ) { if ( vertices . add ( v ) ) { if ( v . represents Parameter ( ) ) { n Parameter ++ ; } if ( representative V == null ) { representative V = v ; } } }
public  Set <  String > files ( ) { if ( set Files == null ) { throw new  Illegal State Exception ( _ STR ) ; } return  Collections . unmodifiable Set ( set Files ) ; }
public static boolean is Mac ( ) {  String os Name =  System . get Property ( _ STR ) ; os Name = os Name . to Lower Case ( ) ; return os Name . index Of ( _ STR ) != - _ NUM ; }
private boolean is Assignable From (  Throwable concrete Throwable ,  Set <  Class < ? extends  Throwable > > throwable Classes ) { for (  Class < ? extends  Throwable > t : throwable Classes ) { if ( t . is Assignable From ( concrete Throwable . get Class ( ) ) ) { return _ BOOL ; } } return _ BOOL ; }
protected void print ( int v ) throws  IOException { print (  String . value Of ( v ) ) ; }
public  Object2 Double Open Hash Map <  Int RBTree Set > confidence Map ( ) {  List <  Item Set > item Sets = learn ( ) ;  Object2 Double Open Hash Map <  Int RBTree Set > confidence Map = new  Object2 Double Open Hash Map < > ( item Sets . size ( ) ) ; for (  Item Set item Set : item Sets ) {  Int RBTree Set item Set Copy = new  Int RBTree Set ( item Set . items ) ; confidence Map . put ( item Set Copy , item Set . support / ( double ) set Count ) ; } return confidence Map ; }
public static boolean is All Alpha (  String str ) { if ( str == null ) return _ BOOL ; for ( int i = str . length ( ) - _ NUM ; i >= _ NUM ; i -- ) { if ( !  Character . is Letter ( str . char At ( i ) ) ) return _ BOOL ; } return _ BOOL ; }
private void extract ( int minsupp , int minlength , int maxlength , int item , int [ ] postfix , int plen , int [ ] buf2 , int [ ] buf3 , boolean destruct ,  Collector col ) { if ( header [ item ] == null ) { return ; } if ( header [ item ] . sibling == null ) { if ( header [ item ] . count < minsupp ) { return ; } extract Linear ( header [ item ] . count , minsupp , minlength , maxlength , item , postfix , plen , buf2 , col ) ; if ( destruct ) {  Arrays . fill ( header , null ) ; } return ; } int support = _ NUM ; for (  FPNode cur = header [ item ] ; cur != null ; cur = cur . sibling ) { support += cur . count ; } if ( support < minsupp ) { return ; }  Arrays . fill ( buf3 , _ NUM ) ; for (  FPNode cur = header [ item ] ; cur != null ; cur = cur . sibling ) { for (  FPNode parent = cur . parent ; parent . key >= _ NUM ; parent = parent . parent ) { buf3 [ parent . key ] += cur . count ; } } final int mminlength = minlength - ( plen + _ NUM ) ; if ( mminlength > _ NUM ) { int fparents = _ NUM ; for ( int i = _ NUM ; i < item ; i ++ ) { if ( buf3 [ i ] >= minsupp ) { fparents += _ NUM ; } } if ( fparents < mminlength ) { return ; } } final int last = item - _ NUM ;  FPTree proj = new  FPTree ( item ) ; for (  FPNode cur = header [ item ] ; cur != null ; cur = cur . sibling ) { int j = buf2 . length ; for (  FPNode parent = cur . parent ; parent . key >= _ NUM ; parent = parent . parent ) { if ( buf3 [ parent . key ] >= minsupp ) { buf2 [ -- j ] = parent . key ; } } if ( buf2 . length - j >= mminlength ) { proj . insert ( proj , buf2 , j , buf2 . length , cur . count ) ; } } proj . reduce Memory ( ) ; postfix [ plen ++ ] = item ; if ( plen >= minlength && plen <= maxlength ) { col . collect ( support , postfix , _ NUM , plen ) ; } for ( int j = last ; j >= _ NUM ; j -- ) { proj . extract ( minsupp , minlength , maxlength , j , postfix , plen , buf2 , buf3 , destruct , col ) ; } if ( destruct ) { header [ item ] = null ; } }
protected static int to Digit ( char ch , int index ) throws  DSSException { int digit =  Character . digit ( ch , _ NUM ) ; if ( digit == - _ NUM ) { throw new  DSSException ( _ STR + ch + _ STR + index ) ; } return digit ; }
static void load Library With Path (  String lib Name ,  Class Loader loader ,  String library Path ) { throw new  Error ( _ STR ) ; }
public  Enumeration list Options ( ) {  Vector new Vector = new  Vector ( ) ; new Vector . add Element ( new  Option ( _ STR + _ STR , _ STR , _ NUM , _ STR ) ) ; return new Vector . elements ( ) ; }
public void save (  File key Store ,  String type , char [ ] password , char [ ] key Password ,  String ca Alias ) throws  General Security Exception ,  IOException {  Key Store store =  Key Store . get Instance ( type ) ; store . load ( null , password ) ; store . set Key Entry ( ca Alias , ca Key , key Password , ca Certs ) ;  Output Stream out = new  File Output Stream ( key Store ) ; try { store . store ( out , password ) ; } catch (  IOException ioe ) { ioe . print Stack Trace ( ) ; } finally { out . close ( ) ; } }
public  Or Query Builder add (  Query Builder filter Builder ) { filters . add ( filter Builder ) ; return this ; }
void update ( long time Nanos , int rows ) { count ++ ; execution Time Min Nanos =  Math . min ( time Nanos , execution Time Min Nanos ) ; execution Time Max Nanos =  Math . max ( time Nanos , execution Time Max Nanos ) ; row Count Min =  Math . min ( rows , row Count Min ) ; row Count Max =  Math . max ( rows , row Count Max ) ; double row Delta = rows - row Count Mean ; row Count Mean += row Delta / count ; row Count M2 += row Delta * ( rows - row Count Mean ) ; double time Delta = time Nanos - execution Time Mean Nanos ; execution Time Mean Nanos += time Delta / count ; execution Time M2 Nanos += time Delta * ( time Nanos - execution Time Mean Nanos ) ; execution Time Cumulative Nanos += time Nanos ; row Count Cumulative += rows ; last Update Time =  System . current Time Millis ( ) ; }
public void test_ctor_2 ( ) throws  Sail Exception { final  File file = new  File ( get Name ( ) +  Options .  JNL ) ; if ( file . exists ( ) ) { if ( ! file . delete ( ) ) { fail ( _ STR + file ) ; } } final  Properties properties = new  Properties ( ) ; properties . set Property (  Options .  FILE , file . to String ( ) ) ; final  Bigdata Sail sail = new  Bigdata Sail ( properties ) ; try { sail . initialize ( ) ; sail . shut Down ( ) ; } finally { if ( ! file . exists ( ) ) { fail ( _ STR + file ) ; if ( ! file . delete ( ) ) { fail ( _ STR + file ) ; } } } }
@  Override public  String to String ( ) {  String result ; result = null ; if ( is Object ( ) ) { if ( is Root ( ) ) { result = _ STR ; } else if ( m_ Name == null ) { result = _ STR ; } else { result = escape ( m_ Name ) + _ STR ; } } else if ( is Array ( ) ) { if ( m_ Name == null ) { result = _ STR ; } else { result = escape ( m_ Name ) + _ STR ; } } else { if ( m_ Name != null ) { result = escape ( m_ Name ) + _ STR + escape ( m_ Value ) ; } else { result = _ STR + m_ Value ; } } return result ; }
public final boolean split_traces_keep_point ( ) { if ( keep_point == null ) return _ BOOL ;  Item Selection Filter filter = new  Item Selection Filter (  Item Selection Choice .  TRACES ) ;  Collection <  Brd Item > picked_items = r_board . pick_items ( keep_point . keep_point , keep_point . on_layer , filter ) ; for (  Brd Item curr_item : picked_items ) {  Brd Tracep a_trace = (  Brd Tracep ) curr_item ; int line_idx = a_trace . polyline_find_line_idx ( keep_point . keep_point ) ; if ( line_idx < _ NUM ) continue ;  Array List <  Brd Tracep > clean_list = a_trace . split_with_end_point ( line_idx , keep_point . keep_point ) ; return clean_list . size ( ) > _ NUM ; } return _ BOOL ; }
public static byte [ ] flip All Bits In Place ( byte [ ] bytes , int index , int length ) { int end Index =  Math . min ( bytes . length , index + length ) ; for ( int i = index ; i < end Index ; i ++ ) { bytes [ i ] = ( byte ) ( bytes [ i ] ^ _ NUM ) ; } return bytes ; }
public  Create Index Request source (  String source ) { return source ( source . get Bytes (  Charsets .  UTF_8 ) ) ; }
private void add Users (  User [ ] users ,  Local Configuration configuration ) { for (  User user : users ) { configuration . add User ( user . create User ( ) ) ; } }
void try To Drain Buffers ( ) { if ( eviction Lock . try Lock ( ) ) { try { drain Status . lazy Set (  PROCESSING ) ; drain Buffers ( ) ; } finally { drain Status . compare And Set (  PROCESSING ,  IDLE ) ; eviction Lock . unlock ( ) ; } } }
public static boolean copy File (  File source ,  File dest ) {  File parent Dest = dest . get Parent File ( ) ; if ( ! parent Dest . exists ( ) ) { if ( ! create Directory ( parent Dest . get Absolute Path ( ) ) ) { return _ BOOL ; } } try {  Files . copy ( source . to Path ( ) , dest . to Path ( ) ) ; return _ BOOL ; } catch (  IOException e ) { e . print Stack Trace ( ) ; return _ BOOL ; } }
public static  String properties Encode (  Properties pp ) {  Byte Array Output Stream bos = new  Byte Array Output Stream ( ) ; try { pp . store ( bos , _ STR ) ; } catch (  IOException e ) { log . log (  Level .  SEVERE , _ STR , e ) ; }  String result = new  String ( bos . to Byte Array ( ) ) ; try { result =  URLEncoder . encode ( result ,  Mobile Env .  ENCODING ) ; } catch (  Unsupported Encoding Exception e ) { log . log (  Level .  SEVERE , _ STR +  Mobile Env .  ENCODING , e ) ;  String enc =  System . get Property ( _ STR ) ; try { result =  URLEncoder . encode ( result , enc ) ; log . info ( _ STR + enc ) ; } catch (  Exception ex ) { log . log (  Level .  SEVERE , _ STR , ex ) ; } } return result ; }
@  Override public void generate Rss (  Xml Writer w ,  Extension Profile ext Profile ) throws  IOException {  Array List <  Xml Writer .  Attribute > attrs = new  Array List <  Xml Writer .  Attribute > ( _ NUM ) ; if ( mime Type != null ) { attrs . add ( new  Xml Writer .  Attribute ( _ STR , mime Type . get Media Type ( ) ) ) ; } if ( uri != null ) { attrs . add ( new  Xml Writer .  Attribute ( _ STR , uri ) ) ; } if ( length != - _ NUM ) { attrs . add ( new  Xml Writer .  Attribute ( _ STR ,  Long . to String ( length ) ) ) ; } w . simple Element (  Namespaces . rss Ns , _ STR , attrs , null ) ; }
public void test Sorts Elements By Name ( ) throws  Exception {  Xpp Dom dom1 =  Xpp Factory . build Dom ( _ STR ) ;  Xpp Dom dom2 =  Xpp Factory . build Dom ( _ STR ) ; assert Equals ( - _ NUM , comparator . compare ( dom1 , dom2 ) ) ; assert Equals ( _ STR , xpath . get ( ) ) ; assert Equals ( _ NUM , comparator . compare ( dom2 , dom1 ) ) ; assert Equals ( _ STR , xpath . get ( ) ) ; }
public static boolean delete Directory ( final  File path ) { if ( path . exists ( ) ) {  File [ ] files = path . list Files ( ) ; for (  File file : files ) { if ( file . is Directory ( ) ) { delete Directory ( file ) ; } else { file . delete ( ) ; } } } return path . delete ( ) ; }
public void morph (  Component source ,  Component destination , int duration ,  Runnable on Completion ) { morph ( source , destination , duration , _ BOOL , on Completion ) ; }
private boolean starts New Hunk (  String string ) { if ( string . length ( ) == _ NUM ) return _ BOOL ; return is Legal Char ( string . char At ( _ NUM ) ) ; }
public void clear Values ( ) { value Map . clear ( ) ; }
private  Hash Map <  String , byte [ ] > read Chars ( byte [ ] d ) {  Hash Map <  String , byte [ ] > hm = new  Hash Map <  String , byte [ ] > ( ) ; int i = find Slash Name ( d , _ STR ) ; if ( i < _ NUM ) { return hm ; }  PSParser psp = new  PSParser ( d , i ) ; while ( _ BOOL ) {  String s = psp . read Thing ( ) ; char c = s . char At ( _ NUM ) ; if ( c == _ STR ) { int len =  Integer . parse Int ( psp . read Thing ( ) ) ;  String go = psp . read Thing ( ) ; if ( go . equals ( _ STR ) || go . equals ( _ STR ) ) { psp . set Loc ( psp . get Loc ( ) + _ NUM ) ; byte [ ] line = psp . get NEncoded Bytes ( len , password , len IV ) ; hm . put ( s . substring ( _ NUM ) , line ) ; } } else if ( s . equals ( _ STR ) ) { break ; } } return hm ; }
public void play File For User (  String file Name ,  String user Name ) throws  Sound Playback Exception { if ( user Name == null || user Name . is Empty ( ) ) { user Name = app Properties . get Property ( _ STR ) ; } try {  Guild guild = get Users Guild ( user Name ) ; join Users Current Channel ( user Name ) ; play File ( file Name , guild ) ; } catch (  Exception e ) { e . print Stack Trace ( ) ; } }
@  Deprecated public static void run Finalizers On Exit ( boolean run ) {  Security Manager sm =  System . get Security Manager ( ) ; if ( sm != null ) { sm . check Exit ( _ NUM ) ; } synchronized ( hooks List ) { finalize On Exit = run ; } }
public double [ ] [ ] predict Intervals ( double conf ) { update Mean And Variance ( ) ; double val =  Statistics . normal Inverse ( _ NUM - ( _ NUM - conf ) / _ NUM ) ; double [ ] [ ] arr = new double [ _ NUM ] [ _ NUM ] ; arr [ _ NUM ] [ _ NUM ] = m_ Mean + val *  Math . sqrt ( m_ Variance ) ; arr [ _ NUM ] [ _ NUM ] = m_ Mean - val *  Math . sqrt ( m_ Variance ) ; return arr ; }
public static boolean check SHA ( final  String sha Hash , final  File file ) { if (  Text Utils . is Empty ( sha Hash ) || file == null || !  File Utils . is Readable ( file ) ) {  Log . e ( _ STR ) ; return _ BOOL ; } final  String hash = get SHA ( file ) ; if ( hash == null ) {  Log . e ( _ STR ) ; return _ BOOL ; } return hash . equals Ignore Case ( sha Hash ) ; }
public void add Value Key Name (  String key ) { value Key Names . add ( key ) ; }
public  Assignment update (  Border border ) {  Arrays . sort ( cs ) ; int j = _ NUM ; boolean found = ( cs [ _ NUM ] . core == border . core ) ; for ( int i = _ NUM ; i < cs . length ; i ++ ) { if ( cs [ i ] . core != cs [ i - _ NUM ] . core ) { cs [ j ++ ] = cs [ i ] ; } found |= ( cs [ i ] . core == border . core ) ; } if ( found ) { if ( j == _ NUM ) {  Border r = cs [ _ NUM ] ; cs = null ; return r ; } if ( j < cs . length ) { cs =  Arrays . copy Of ( cs , j ) ; } return this ; } if ( j + _ NUM != cs . length ) { cs =  Arrays . copy Of ( cs , j + _ NUM ) ; } cs [ j ] = border ; return this ; }
public static  String from Char ( int value ) { if ( value > _ NUM ) return null ;  String name ; initialize ( ) ; name = (  String ) _by Char . get ( new  Integer ( value ) ) ; return name ; }
public static  List <  String > split Lines ( final  String content ) { if ( content == null || content . length ( ) == _ NUM ) return  Collections . empty List ( ) ;  String [ ] lines = content . split ( _ STR ) ; return  Arrays . as List ( lines ) ; }
@  Override public void draw (  Graphics2 D g2 ,  Rectangle2 D area ,  Point2 D anchor ,  Plot State state ,  Plot Rendering Info info ) { boolean b1 = ( area . get Width ( ) <=  MINIMUM_ WIDTH_ TO_ DRAW ) ; boolean b2 = ( area . get Height ( ) <=  MINIMUM_ HEIGHT_ TO_ DRAW ) ; if ( b1 || b2 ) { return ; } if ( info != null ) { info . set Plot Area ( area ) ; }  Rectangle Insets insets = get Insets ( ) ; insets . trim ( area ) ; draw Chip Grid ( g2 , area ) ; draw Wafer Edge ( g2 , area ) ; }
public void add Hole (  Edge Ring hole ER ) { hole ER . set Shell ( this ) ;  Linear Ring hole = hole ER . get Ring ( ) ; if ( holes == null ) holes = new  Array List ( ) ; holes . add ( hole ) ; }
private static void register Components ( ) { register Component (  Bar Chart Component . class ,  Bar Chart Gui . class ) ; register Component (  Doc Viewer Component . class ,  Doc Viewer Desktop Component . class ) ; register Component (  Console Component . class ,  Console Desktop Component . class ) ; register Component (  Display Component . class ,  Display Component Desktop Gui . class ) ; register Component (  Data World Component . class ,  Data World Desktop Component . class ) ; register Component (  Histogram Component . class ,  Histogram Gui . class ) ; register Component (  Network Component . class ,  Network Desktop Component . class ) ; register Component (  Odor World Component . class ,  Odor World Desktop Component . class ) ; register Component (  Pie Chart Component . class ,  Pie Chart Gui . class ) ; register Component (  Projection Component . class ,  Projection Gui . class ) ; register Component (  Reader Component . class ,  Reader Component Desktop Gui . class ) ; register Component (  Scatter Plot Component . class ,  Scatter Plot Gui . class ) ; register Component (  Time Series Plot Component . class ,  Time Series Plot Gui . class ) ; register Component (  Raster Plot Component . class ,  Raster Plot Gui . class ) ; register Component (  Vision World Component . class ,  Vision World Desktop Component . class ) ; register Component (  Game Component . class ,  Game Desktop Component . class ) ; register Component (  Device Interaction Component . class ,  Device Interaction Desktop Component . class ) ; }
private long skip Input Bytes ( long n ) throws  IOException { cb Lock . lock ( ) ; try { return iis . skip Bytes ( n ) ; } finally { cb Lock . unlock ( ) ; } }
public byte [ ] generate64 Bit Hash Id ( ) throws  Crypto Exception { try {  DERBit String public Key Bit String = encode Public Key As Bit String ( public Key ) ; byte [ ] hash =  Digest Util . get Message Digest ( public Key Bit String . get Bytes ( ) ,  Digest Type .  SHA1 ) ; byte [ ] sub Hash =  Arrays . copy Of Range ( hash , _ NUM , _ NUM ) ; sub Hash [ _ NUM ] &= _ NUM ; sub Hash [ _ NUM ] |= _ NUM ; return sub Hash ; } catch (  IOException ex ) { throw new  Crypto Exception ( res . get String ( _ STR ) , ex ) ; } }
public static <  C extends  Configuration Client ,  S extends  Configuration >  Create Sub Command Handler <  C ,  S > create (  Sub Command Argument Parser parser ,  Managed Object Path < ? , ? > p ,  Optional Relation Definition <  C ,  S > r ) throws  Argument Exception { return new  Create Sub Command Handler < > ( parser , p , r , null , p . child ( r ) ) ; }
public  DSubject Information Access (  JDialog parent , byte [ ] value ) throws  IOException { super ( parent ) ; set Title ( res . get String ( _ STR ) ) ; init Components ( ) ; prepopulate With Value ( value ) ; }
public void test Signer String Identity Scope ( ) throws  Exception {  Signer s = new  Signer Stub ( _ STR ,  Identity Scope . get System Scope ( ) ) ; assert Not Null ( s ) ; assert Equals ( _ STR , s . get Name ( ) ) ; assert Same (  Identity Scope . get System Scope ( ) , s . get Scope ( ) ) ; assert Null ( s . get Private Key ( ) ) ; try {  Signer s2 = new  Signer Stub ( _ STR ,  Identity Scope . get System Scope ( ) ) ; fail ( _ STR ) ; } catch (  Key Management Exception e ) { }  Signer s2 = new  Signer Stub ( null ) ; assert Null ( s2 . get Name ( ) ) ; }
private  Figure read Line Element (  IXMLElement elem ) throws  IOException {  Hash Map <  Attribute Key ,  Object > a = new  Hash Map <  Attribute Key ,  Object > ( ) ; read Core Attributes ( elem , a ) ; read Transform Attribute ( elem , a ) ; read Opacity Attribute ( elem , a ) ; read Line Attributes ( elem , a ) ; if (  FILL_ COLOR . get ( a ) != null &&  STROKE_ COLOR . get ( a ) == null ) {  STROKE_ COLOR . put ( a ,  FILL_ COLOR . get ( a ) ) ; } if (  FILL_ GRADIENT . get ( a ) != null &&  STROKE_ GRADIENT . get ( a ) == null ) {  STROKE_ GRADIENT . put ( a ,  FILL_ GRADIENT . get ( a ) ) ; }  FILL_ COLOR . put ( a , null ) ;  FILL_ GRADIENT . put ( a , null ) ; double x1 = to Number ( elem , read Attribute ( elem , _ STR , _ STR ) ) ; double y1 = to Number ( elem , read Attribute ( elem , _ STR , _ STR ) ) ; double x2 = to Number ( elem , read Attribute ( elem , _ STR , _ STR ) ) ; double y2 = to Number ( elem , read Attribute ( elem , _ STR , _ STR ) ) ;  Figure figure = factory . create Line ( x1 , y1 , x2 , y2 , a ) ; element Objects . put ( elem , figure ) ; return figure ; }
public boolean is Set Call Type ( ) { return __isset_bit_vector . get ( __ CALLTYPE_ ISSET_ ID ) ; }
private  IBuffer map Source (  Source Mapper mapper ,  IBinary Type info ,  IClass File buffer Owner ) { char [ ] contents = mapper . find Source ( get Type ( ) , info ) ; if ( contents != null ) {  IBuffer buffer =  Buffer Manager . create Buffer ( buffer Owner ) ; if ( buffer == null ) return null ;  Buffer Manager buf Manager = get Buffer Manager ( ) ; buf Manager . add Buffer ( buffer ) ; if ( buffer . get Characters ( ) == null ) { buffer . set Contents ( contents ) ; } buffer . add Buffer Changed Listener ( this ) ; mapper . map Source ( get Outer Most Enclosing Type ( ) , contents , info ) ; return buffer ; } else {  IBuffer buffer =  Buffer Manager . create Null Buffer ( buffer Owner ) ; if ( buffer == null ) return null ;  Buffer Manager buf Manager = get Buffer Manager ( ) ; buf Manager . add Buffer ( buffer ) ; buffer . add Buffer Changed Listener ( this ) ; return buffer ; } }
public  JFile Data Store Chooser (  Shell parent , int style , final  List <  String > extensions ) { this ( parent , style , associations ( extensions ) ) ; }
private void compute Static Load Metrics (  Access Profile access Profile ) throws  Base Collection Exception {  URI storage System Id = access Profile . get System Id ( ) ;  Storage System storage System = null ; try { storage System = _db Client . query Object (  Storage System . class , storage System Id ) ; _logger . info ( _ STR , storage System . get Label ( ) ) ;  VNXe Api Client client = get Vnx Unity Client ( access Profile ) ;  List <  VNXe Nas Server > nas Servers = client . get Nas Servers ( ) ; for (  VNXe Nas Server nas Server : nas Servers ) { if ( ( nas Server . get Mode ( ) ==  VNXe Nas Server .  Nas Server Mode Enum .  DESTINATION ) || nas Server . get Is Replication Destination ( ) ) { _logger . debug ( _ STR ) ; continue ; } if ( nas Server . get Is System ( ) ) { continue ; }  Virtual NAS virtual NAS = findv Nas By Native Id ( storage System , nas Server . get Id ( ) ) ; if ( virtual NAS != null ) { _logger . info ( _ STR , nas Server . get Name ( ) ) ;  String Map db Metrics = virtual NAS . get Metrics ( ) ; if ( db Metrics == null ) { db Metrics = new  String Map ( ) ; }  String Map tmp Db Metrics = populate Db Metrics ( nas Server , client ) ; db Metrics . put All ( tmp Db Metrics ) ; virtual NAS . set Metrics ( db Metrics ) ; _db Client . update Object ( virtual NAS ) ; } } } catch (  Exception e ) { _logger . error ( _ STR , storage System Id , e ) ; } }
public final short read Short ( ) throws java . io .  IOException { read Fully ( scratch , _ NUM , _ NUM ) ; return ( short ) ( ( scratch [ _ NUM ] << _ NUM ) | ( scratch [ _ NUM ] & _ NUM ) ) ; }
public  Replication Job create Job For Copy Partition ( long audit Log Id , long audit Log Entry Create Time ,  Hive Object Spec spec ) throws  State Update Exception {  Map <  String ,  String > extras = new  Hash Map < > ( ) ; extras . put (  Persisted Job Info .  AUDIT_ LOG_ ID_ EXTRAS_ KEY ,  Long . to String ( audit Log Id ) ) ; extras . put (  Persisted Job Info .  AUDIT_ LOG_ ENTRY_ CREATE_ TIME_ KEY ,  Long . to String ( audit Log Entry Create Time ) ) ;  List <  String > partition Names = new  Array List < > ( ) ; partition Names . add ( spec . get Partition Name ( ) ) ;  Replication Operation replication Operation =  Replication Operation .  COPY_ PARTITION ;  Persisted Job Info persisted Job Info = job Info Store . resilient Create ( replication Operation ,  Replication Status .  PENDING ,  Optional . empty ( ) , src Cluster . get Name ( ) , spec , partition Names ,  Optional . empty ( ) ,  Optional . empty ( ) ,  Optional . empty ( ) , extras ) ;  Replication Task replication Task = new  Copy Partition Task ( conf , destination Object Factory , object Conflict Handler , src Cluster , dest Cluster , spec ,  Optional . <  Path > empty ( ) ,  Optional . <  Path > empty ( ) , directory Copier , _ BOOL ) ; return new  Replication Job ( conf , replication Task , on State Change Handler , persisted Job Info ) ; }
public static void main (  String ... args ) throws  Exception {  String [ ] pages = { _ STR , _ STR , _ STR , _ STR , _ STR , _ STR , _ STR , _ STR , _ STR , _ STR , _ STR , _ STR } ;  String Builder buff = new  String Builder ( ) ; for (  String file Name : pages ) {  String text = get Content ( file Name ) ; for (  String page : pages ) { text =  String Utils . replace All ( text , page + _ STR , _ STR ) ; } text = disable Railroads ( text ) ; text = remove Header Footer ( file Name , text ) ; buff . append ( text ) ; }  String final Text = buff . to String ( ) ;  File output = new  File (  BASE_ DIR , _ STR ) ;  Print Writer writer = new  Print Writer ( new  File Writer ( output ) ) ; writer . println ( _ STR + _ STR ) ; writer . println ( _ STR ) ; writer . println ( _ STR + _ STR ) ; writer . println ( _ STR ) ; writer . println ( _ STR +  Constants . get Full Version ( ) + _ STR ) ; writer . println ( final Text ) ; writer . println ( _ STR ) ; writer . close ( ) ; }
public static  Map <  String ,  Object > find Orders (  Dispatch Context dctx ,  Map <  String , ? extends  Object > context ) { return find Orders ( dctx , context , _ BOOL ) ; }
public static boolean is File Exist (  String file Path ) { if (  String Utils . is Blank ( file Path ) ) { return _ BOOL ; }  File file = new  File ( file Path ) ; return ( file . exists ( ) && file . is File ( ) ) ; }
public static  Pronghorn Stage find Stage By Path (  Graph Manager m , int ... path ) { int ordinal = path [ _ NUM ] ; int i = _ NUM ; int limit = m . stage Id To Stage . length ; while ( i < limit ) { if ( null != m . stage Id To Stage [ i ] ) { if ( - _ NUM == m . mult Input Ids [ m . stage Id To Inputs Begin Idx [ m . stage Id To Stage [ i ] . stage Id ] ] ) { if ( -- ordinal <= _ NUM ) { return find Stage By Path ( m , m . stage Id To Stage [ i ] , _ NUM , path ) ; } } } i ++ ; } throw new  Unsupported Operation Exception ( _ STR + path [ _ NUM ] ) ; }
public static double [ ] calculate TStats ( double [ ] coef , double [ ] stderror , int k ) { double [ ] result = new double [ k ] ; for ( int i = _ NUM ; i < k ; i ++ ) { result [ i ] = coef [ i ] / stderror [ i ] ; } return result ; }
static void run Bootstrappers ( final  Core Early Component early , final  List <  Heroic Bootstrap > bootstrappers ) throws  Exception { for ( final  Heroic Bootstrap bootstrap : bootstrappers ) { try { bootstrap . run ( early ) ; } catch (  Exception e ) { throw new  Exception ( _ STR + bootstrap , e ) ; } } }
public static byte [ ] check Index Header ID (  Data Input in , byte [ ] expected ID ) throws  IOException { byte id [ ] = new byte [  String Helper .  ID_ LENGTH ] ; in . read Bytes ( id , _ NUM , id . length ) ; if ( !  Arrays . equals ( id , expected ID ) ) { throw new  Corrupt Index Exception ( _ STR +  String Helper . id To String ( expected ID ) + _ STR +  String Helper . id To String ( id ) , in ) ; } return id ; }
protected void save Buffer (  String name ) {  String Buffer sb = m_ History . get Named Buffer ( name ) ; if ( sb != null ) { if ( m_ Save Out . save ( sb ) ) { m_ Log . log Message ( _ STR ) ; } } }
public  List <  Recommendation > schedule Storage (  Virtual Array src Varray ,  Set <  URI > requested VPlex Systems ,  URI src Storage System ,  Virtual Pool src Vpool , boolean is HARequest ,  Virtual Array requested Ha Varray ,  Virtual Pool ha Vpool ,  Virtual Pool Capability Values Wrapper capabilities ,  Project project ,  Vpool Use vpool Use ,  Map <  Vpool Use ,  List <  Recommendation > > current Recommendations ) { _log . info ( _ STR ) ; if ( ! is HARequest ) { return schedule Storage For Local VPLEXVolume ( src Varray , requested VPlex Systems , src Storage System , src Vpool , capabilities , project , vpool Use , current Recommendations ) ; } else { return schedule Storage For Distributed VPLEXVolume ( src Varray , requested VPlex Systems , src Storage System , src Vpool , requested Ha Varray , ha Vpool , capabilities , project , vpool Use , current Recommendations ) ; } }
@  Not Null public static  List <  String > complete Relative Path ( @  Not Null  String base Dir , @  Not Null  String shown Base Dir , @  Not Null  String relative Path ) {  List <  String > result =  Lists . new Linked List ( ) ;  String bash Base Dir =  OSUtil . to Bash Compatible ( base Dir ) ; for (  String path : complete Absolute Path ( base Dir +  File . separator + relative Path ,  Predicates . <  File > always True ( ) ) ) { if ( path . starts With ( bash Base Dir ) ) { result . add ( shown Base Dir + path . substring ( bash Base Dir . length ( ) ) ) ; } } return result ; }
protected boolean is File Specifying Module Specifier (  String specifier ) { return specifier . length ( ) > _ NUM && specifier . char At ( specifier . length ( ) - _ NUM ) !=  IPath .  SEPARATOR ; }
private void insert Expected Pool Settings Per Tier (  CIMObject Path capabilities Path ,  Map <  String ,  Object > key Map ) {  List <  String > expected Pool Settings Tier = (  List <  String > ) key Map . get (  Constants .  VNXPOOLCAPABILITIES_ TIER ) ; expected Pool Settings Tier . add ( capabilities Path . to String ( ) +  Constants .  HYPHEN +  Constants .  NO_ DATA_ MOVEMENT ) ; expected Pool Settings Tier . add ( capabilities Path . to String ( ) +  Constants .  HYPHEN +  Constants .  AUTO_ TIER ) ; expected Pool Settings Tier . add ( capabilities Path . to String ( ) +  Constants .  HYPHEN +  Constants .  HIGH_ AVAILABLE_ TIER ) ; expected Pool Settings Tier . add ( capabilities Path . to String ( ) +  Constants .  HYPHEN +  Constants .  LOW_ AVAILABLE_ TIER ) ; expected Pool Settings Tier . add ( capabilities Path . to String ( ) +  Constants .  HYPHEN +  Constants .  START_ HIGH_ THEN_ AUTO_ TIER ) ; }
private static final void transfer Streams (  Input Stream source ,  Output Stream destination ,  String path ,  IProgress Monitor monitor ) throws  Core Exception { monitor =  Policy . monitor For ( monitor ) ; try { synchronized ( buffer ) { while ( _ BOOL ) { int bytes Read = - _ NUM ; try { bytes Read = source . read ( buffer ) ; } catch (  IOException e ) {  String msg =  NLS . bind (  Messages . failed Read During Write , path ) ;  Policy . error (  EFS .  ERROR_ READ , msg , e ) ; } try { if ( bytes Read == - _ NUM ) { destination . close ( ) ; break ; } destination . write ( buffer , _ NUM , bytes Read ) ; } catch (  IOException e ) {  String msg =  NLS . bind (  Messages . could Not Write , path ) ;  Policy . error (  EFS .  ERROR_ WRITE , msg , e ) ; } monitor . worked ( _ NUM ) ; } } } finally {  Policy . safe Close ( source ) ;  Policy . safe Close ( destination ) ; } }
private int path Position At Level ( int org Unit Level ) { return ( org Unit Level - _ NUM ) * _ NUM + _ NUM ; }
private int make Available ( ) { if ( pos != - _ NUM ) { return _ NUM ; } total += tail - head - pad ;  System . arraycopy ( buffer , tail - pad , buffer , _ NUM , pad ) ; head = _ NUM ; tail = pad ; for ( ; ; ) { int bytes Read = _ NUM ; try { bytes Read = input . read ( buffer , tail , buf Size - tail ) ; } catch (  IOException e ) { throw new  Runtime Exception ( _ STR ) ; } if ( bytes Read == - _ NUM ) { final  String msg = _ STR ; throw new  Malformed Stream Exception ( msg ) ; } tail += bytes Read ; find Separator ( ) ; int av = available ( ) ; if ( av > _ NUM || pos != - _ NUM ) { return av ; } } }
protected void add Numeric Train Class ( double class Value , double weight ) { if ( class Value > m_ Max Target ) { m_ Max Target = class Value ; } if ( class Value < m_ Min Target ) { m_ Min Target = class Value ; } if ( m_ Train Class Vals == null ) { m_ Train Class Vals = new double [ _ NUM ] ; m_ Train Class Weights = new double [ _ NUM ] ; } if ( m_ Num Train Class Vals == m_ Train Class Vals . length ) { double [ ] temp = new double [ m_ Train Class Vals . length * _ NUM ] ;  System . arraycopy ( m_ Train Class Vals , _ NUM , temp , _ NUM , m_ Train Class Vals . length ) ; m_ Train Class Vals = temp ; temp = new double [ m_ Train Class Weights . length * _ NUM ] ;  System . arraycopy ( m_ Train Class Weights , _ NUM , temp , _ NUM , m_ Train Class Weights . length ) ; m_ Train Class Weights = temp ; } m_ Train Class Vals [ m_ Num Train Class Vals ] = class Value ; m_ Train Class Weights [ m_ Num Train Class Vals ] = weight ; m_ Num Train Class Vals ++ ; }
private  List <  Group > parse Groups (  JSONArray groups ,  String group Type ) throws  JSONException ,  Ade Usage Exception { if ( groups . length ( ) == _ NUM ) throw new  Ade Usage Exception ( _ STR + group Type ) ;  List <  Group > current Groups = new  Array List <  Group > ( ) ; for ( int i = _ NUM ; i < groups . length ( ) ; i ++ ) {  JSONObject group = groups . get JSONObject ( i ) ;  String name = group . get String ( _ STR ) ;  String data Type = group . get String ( _ STR ) ; short eval Order = group . get Short ( _ STR ) ;  String rule Name = group . get String ( _ STR ) ; if ( ! verify String Param ( name , _ NUM , _ STR ) || name . equals Ignore Case ( _ STR ) || ! validate Data Type ( data Type ) || eval Order < _ NUM || ! verify String Param ( rule Name , _ NUM , _ STR ) ) { throw new  Ade Usage Exception ( _ STR + group Type + _ STR ) ; } current Groups . add ( new  Group ( name ,  Group Type . value Of ( group Type ) ,  Data Type . value Of ( data Type . to Upper Case ( ) ) , eval Order , rule Name ) ) ; } validate Evaluation Order And Name ( current Groups ) ; return current Groups ; }
public  Double Fft1d ( int n ) { if ( n < _ NUM ) { throw new  Illegal Argument Exception ( _ STR ) ; } this . n = n ; if ( !  Concurrency Utils . is Power Of2 ( n ) ) { if ( get Reminder ( n , factors ) >= _ NUM ) { plan =  Plans .  BLUESTEIN ; n Bluestein =  Concurrency Utils . next Pow2 ( n * _ NUM - _ NUM ) ; bk1 = new double [ _ NUM * n Bluestein ] ; bk2 = new double [ _ NUM * n Bluestein ] ; this . ip = new int [ _ NUM + ( int )  Math . ceil ( _ NUM + ( _ NUM << ( int ) (  Math . log ( n Bluestein + _ NUM ) /  Math . log ( _ NUM ) ) / _ NUM ) ) ] ; this . w = new double [ n Bluestein ] ; int twon = _ NUM * n Bluestein ; nw = ip [ _ NUM ] ; if ( twon > ( nw << _ NUM ) ) { nw = twon > > _ NUM ; makewt ( nw ) ; } nc = ip [ _ NUM ] ; if ( n Bluestein > ( nc << _ NUM ) ) { nc = n Bluestein > > _ NUM ; makect ( nc , w , nw ) ; } bluesteini ( ) ; } else { plan =  Plans .  MIXED_ RADIX ; wtable = new double [ _ NUM * n + _ NUM ] ; wtable_r = new double [ _ NUM * n + _ NUM ] ; cffti ( ) ; rffti ( ) ; } } else { plan =  Plans .  SPLIT_ RADIX ; this . ip = new int [ _ NUM + ( int )  Math . ceil ( _ NUM + ( _ NUM << ( int ) (  Math . log ( n + _ NUM ) /  Math . log ( _ NUM ) ) / _ NUM ) ) ] ; this . w = new double [ n ] ; int twon = _ NUM * n ; nw = ip [ _ NUM ] ; if ( twon > ( nw << _ NUM ) ) { nw = twon > > _ NUM ; makewt ( nw ) ; } nc = ip [ _ NUM ] ; if ( n > ( nc << _ NUM ) ) { nc = n > > _ NUM ; makect ( nc , w , nw ) ; } } }
@  Override public void drag Gesture Recognized (  Drag Gesture Event evt ) {  Drag Entry drag Entry = kse Frame . drag Selected Entry ( ) ; if ( drag Entry == null ) { return ; }  Image Icon icon = drag Entry . get Image ( ) ;  Toolkit toolkit =  Toolkit . get Default Toolkit ( ) ;  Dimension dim = toolkit . get Best Cursor Size ( icon . get Icon Width ( ) , icon . get Icon Height ( ) ) ;  Buffered Image buff Image = new  Buffered Image ( dim . width , dim . height ,  Buffered Image .  TYPE_ INT_ ARGB_ PRE ) ; icon . paint Icon ( evt . get Component ( ) , buff Image . get Graphics ( ) , _ NUM , _ NUM ) ; cursor = toolkit . create Custom Cursor ( buff Image , new  Point ( _ NUM , _ NUM ) , _ STR ) ; evt . start Drag ( cursor , new  Key Store Entry Transferable ( drag Entry ) , this ) ; }
public static boolean is Identifier Helper Char ( char ch ) { return _ STR == ch || _ STR == ch || _ STR == ch || _ STR == ch ; }
public void add Header (  String line ) { header . add ( line ) ; }
public static  IAddress load Address ( final  Result Set result Set , final  String column Name ) throws  SQLException {  Preconditions . check Not Null ( result Set , _ STR ) ;  Preconditions . check Not Null ( column Name , _ STR ) ; final  String address String = read String ( result Set , column Name ) ; return result Set . was Null ( ) ? null : new  CAddress ( new  Big Integer ( address String ) ) ; }
private static  String encode (  String string To Encode ) {  String encoded ; try { encoded =  URLEncoder . encode ( string To Encode ,  UTF_8 ) ; } catch (  Unsupported Encoding Exception e ) { throw new  MCApi Runtime Exception ( e ) ; } encoded = encoded . replace ( _ STR , _ STR ) ; encoded = encoded . replace ( _ STR , _ STR ) ; encoded = encoded . replace ( _ STR , _ STR ) ; return encoded ; }
protected static  String guess Type (  File file ) {  String name = file . get Name ( ) ;  String suffix = name . substring ( name . last Index Of ( _ STR ) + _ NUM ) ; return mime Map . get ( suffix . to Lower Case (  Locale .  ROOT ) ) ; }
public void test Advance All Terms ( ) throws  Exception {  List <  String > terms List = new  Array List < > ( ) ; terms List . add All (  Arrays . as List ( common Terms ) ) ; terms List . add All (  Arrays . as List ( medium Terms ) ) ; terms List . add All (  Arrays . as List ( rare Terms ) ) ;  String terms [ ] = terms List . to Array ( new  String [ _ NUM ] ) ; for ( int amount = _ NUM ; amount < _ NUM ; amount += _ NUM ) { for ( int min Nr Should Match = _ NUM ; min Nr Should Match <= terms . length ; min Nr Should Match ++ ) {  Scorer expected = scorer ( terms , min Nr Should Match ,  Mode .  DOC_ VALUES ) ;  Scorer actual = scorer ( terms , min Nr Should Match ,  Mode .  SCORER ) ; assert Advance ( expected , actual , amount ) ; expected = scorer ( terms , min Nr Should Match ,  Mode .  DOC_ VALUES ) ; actual = scorer ( terms , min Nr Should Match ,  Mode .  BULK_ SCORER ) ; assert Advance ( expected , actual , amount ) ; } } }
public boolean is Public ( ) { return  Modifier . is Public ( get Access Flags ( ) ) ; }
public boolean release Encumbrance Budget ( final  Map <  String ,  Object > details Map ) { if ( details Map == null ) throw new  Validation Exception (  Arrays . as List ( new  Validation Error ( _ STR , _ STR ) ) ) ; details Map . put (  Constants .  CONSUMEORRELEASE , _ BOOL ) ; final  Big Decimal bd = get Details ( details Map ) ; return bd . int Value ( ) == _ NUM ; }
protected  Transferable create Locale Transferable ( long [ ] formats ) throws  IOException { return null ; }
public void put Length ( int len ) throws  IOException { if ( len < _ NUM ) { write ( ( byte ) len ) ; } else if ( len < ( _ NUM << _ NUM ) ) { write ( ( byte ) _ NUM ) ; write ( ( byte ) len ) ; } else if ( len < ( _ NUM << _ NUM ) ) { write ( ( byte ) _ NUM ) ; write ( ( byte ) ( len > > _ NUM ) ) ; write ( ( byte ) len ) ; } else if ( len < ( _ NUM << _ NUM ) ) { write ( ( byte ) _ NUM ) ; write ( ( byte ) ( len > > _ NUM ) ) ; write ( ( byte ) ( len > > _ NUM ) ) ; write ( ( byte ) len ) ; } else { write ( ( byte ) _ NUM ) ; write ( ( byte ) ( len > > _ NUM ) ) ; write ( ( byte ) ( len > > _ NUM ) ) ; write ( ( byte ) ( len > > _ NUM ) ) ; write ( ( byte ) len ) ; } }
public void put Generic Font Family (  String family Name ,  Font font ) { generic Font Families . put ( family Name . to Lower Case ( ) , font ) ; }
private boolean write Reference (  Object value ,  Node Map node ) {  String name = get ( value ) ; int size = size ( ) ; if ( name != null ) { node . put ( refer , name ) ; return _ BOOL ; }  String unique =  String . value Of ( size ) ; node . put ( mark , unique ) ; put ( value , unique ) ; return _ BOOL ; }
@  Override public  String format (  Date Time Formatter formatter ) {  Objects . require Non Null ( formatter , _ STR ) ; return formatter . format ( this ) ; }
public @  Dotted Class Name  String to Dotted Class Name ( ) { return  Class Name . to Dotted Class Name ( class Name ) ; }
public  DAdd Extensions (  JFrame parent ,  String title ,  X509 Extension Set extensions ,  Public Key authority Public Key ,  X500 Name authority Cert Name ,  Big Integer authority Cert Serial Number ,  Public Key subject Public Key ) { super ( parent ,  Dialog .  Modality Type .  DOCUMENT_ MODAL ) ; set Title ( res . get String ( _ STR ) ) ; this . extensions = extensions ; this . authority Public Key = authority Public Key ; this . authority Cert Name = authority Cert Name ; this . authority Cert Serial Number = authority Cert Serial Number ; this . subject Public Key = subject Public Key ; init Components ( ) ; }
private void play Next ( ) { if ( media Type ==  Config .  YOUTUBE_ MEDIA_ TYPE_ VIDEO ) { seek Video ( _ NUM ) ; restart Video ( ) ; return ; } if ( previous Was Called ) { previous Was Called = _ BOOL ; iterator . next ( ) ; } if ( ! iterator . has Next ( ) ) { iterator = you Tube Videos . list Iterator ( ) ; } video Item = iterator . next ( ) ; next Was Called = _ BOOL ; play Video ( ) ; }
public static <  T >  T invoke Method (  Object obj ,  String name ,  Object ... params ) throws  No Such Method Exception {  Class [ ] param Types = get Param Types ( params ) ; final  Class < ? > a Class = obj . get Class ( ) ;  Method method ; try { method = a Class . get Declared Method ( name , param Types ) ; } catch (  No Such Method Exception e ) { method = a Class . get Method ( name , param Types ) ; } method . set Accessible ( _ BOOL ) ; try { return (  T ) method . invoke ( obj , params ) ; } catch (  Illegal Access Exception |  Invocation Target Exception e ) { throw new  Runtime Exception ( e ) ; } }
public static  Rotate Stream create (  Path path ) { synchronized ( _streams ) {  Weak Reference <  Rotate Stream > ref = _streams . get ( path ) ;  Rotate Stream stream = ref != null ? ref . get ( ) : null ; if ( stream == null ) { stream = new  Rotate Stream ( path ) ; _streams . put ( path , new  Weak Reference < > ( stream ) ) ; } return stream ; } }
private void clean Up History ( ) { if ( ! m History Of Numbers . is Empty ( ) && m History Of Numbers . size ( ) >=  MAX_ HISTORY_ SIZE ) { for ( int i = _ NUM ; i <  Math . max ( _ NUM ,  MAX_ HISTORY_ SIZE / _ NUM ) ; i ++ ) { m Previous Numbers . remove ( m History Of Numbers . remove First ( ) ) ; } } }
public  Log Message (  String template , int code ) { this ( template , null ,  EMPTY_ STRING_ ARRAY , code ,  Optional . empty ( ) ) ; }
protected  String action_translate (  String act_string , int act_pos ,  Hashtable label_map ,  Hashtable label_types ) { int id_start ; int pos ; int len ;  String id_str ; boolean in_id ;  String Buffer result ; char buffer [ ] ; if ( act_string == null || act_string . length ( ) == _ NUM ) return act_string ; len = act_string . length ( ) ; result = new  String Buffer ( len + _ NUM ) ; buffer = new char [ len + _ NUM ] ; act_string . get Chars ( _ NUM , len , buffer , _ NUM ) ; buffer [ len ] = _ STR ; in_id = _ BOOL ; for ( pos = id_start = _ NUM ; pos <= len ; pos ++ ) { if ( in_id ) { if ( ! is_id_char ( buffer [ pos ] ) ) { id_str = new  String ( buffer , id_start , pos - id_start ) ; result . append ( label_translate ( id_str , act_pos , label_map , label_types ) ) ; if ( buffer [ pos ] != _ STR ) result . append ( buffer , pos , _ NUM ) ; in_id = _ BOOL ; } else { } } else { if ( is_id_start ( buffer [ pos ] ) ) { in_id = _ BOOL ; id_start = pos ; } else { if ( buffer [ pos ] != _ STR ) result . append ( buffer , pos , _ NUM ) ; } } } return result . to String ( ) ; }
public boolean can Load ( ) { return _ BOOL ; }
protected boolean strict Parse Boolean (  String s ) { if ( s == null || s . is Empty ( ) ) { throw new  Illegal Argument Exception ( _ STR ) ; } if ( s . equals Ignore Case ( _ STR ) ) { return _ BOOL ; } if ( s . equals Ignore Case ( _ STR ) ) { return _ BOOL ; } throw new  Illegal Argument Exception ( _ STR + s ) ; }
@  Override public boolean e Is Set ( int feature ID ) { switch ( feature ID ) { case  Functionblock Package .  EVENT__ NAME : return  NAME_ EDEFAULT == null ? name != null : !  NAME_ EDEFAULT . equals ( name ) ; case  Functionblock Package .  EVENT__ PROPERTIES : return properties != null && ! properties . is Empty ( ) ; } return super . e Is Set ( feature ID ) ; }
private void initialize Source Code Map (  String adapted Content ) { source Code With Line = new  Linked Hash Map < > ( ) ; int line Number = _ NUM ;  String Reader sr = new  String Reader ( adapted Content ) ;  Buffered Reader br = new  Buffered Reader ( sr ) ;  String line ; try { while ( ( line = br . read Line ( ) ) != null ) { source Code With Line . put ( line Number , line ) ; line Number ++ ; } } catch (  IOException ex ) {  LOGGER . error ( _ STR + ex . get Message ( ) ) ; } }
public  Matrix  U ( ) { return  U . clone ( ) ; }
private boolean is Field Visited (  Object object ,  Field object Field ,  Field field ) {  Map <  String ,  Set <  String > > bag = visited Fields . get ( object ) ; if ( bag == null ) { return _ BOOL ; }  String object Filed Key = object Field == null ? _ STR : object Field . to Generic String ( ) ;  Set <  String > fields = bag . get ( object Filed Key ) ; return fields != null && fields . contains ( field ) ; }
public void remove From Completed List (  Download Info Runnable download Info Runnable ) { m Completed List . remove ( download Info Runnable ) ; }
protected void add Shingled Phrase Queries ( final  Boolean Query main Query , final  List <  Clause > clauses , final  Collection <  Field Params > fields , int shingle Size , final float tiebreaker , final int slop ) throws  Syntax Error { if ( null == fields || fields . is Empty ( ) || null == clauses || clauses . size ( ) < shingle Size ) return ; if ( _ NUM == shingle Size ) shingle Size = clauses . size ( ) ; final int last Clause Index = shingle Size - _ NUM ;  String Builder user Phrase Query = new  String Builder ( ) ; for ( int i = _ NUM ; i < clauses . size ( ) - last Clause Index ; i ++ ) { user Phrase Query . append ( _ STR ) ; for ( int j = _ NUM ; j <= last Clause Index ; j ++ ) { user Phrase Query . append ( clauses . get ( i + j ) . val ) ; user Phrase Query . append ( _ STR ) ; } user Phrase Query . append ( _ STR ) ; user Phrase Query . append ( _ STR ) ; }  Extended Solr Query Parser pp = create Edismax Query Parser ( this ,  IMPOSSIBLE_ FIELD_ NAME ) ; pp . add Alias (  IMPOSSIBLE_ FIELD_ NAME , tiebreaker , get Field Boosts ( fields ) ) ; pp . set Phrase Slop ( slop ) ; pp . set Remove Stop Filter ( _ BOOL ) ; pp . make Dismax = _ BOOL ; pp . min Clause Size = _ NUM ;  Query phrase = pp . parse ( user Phrase Query . to String ( ) ) ; if ( phrase != null ) { main Query . add ( phrase ,  Boolean Clause .  Occur .  SHOULD ) ; } }
public  String as Xml Id ( ) { return  Datatype Converter . print Hex Binary ( token Digest . get Value ( ) ) ; }
private void update Info ( ) { m_updating = _ BOOL ; name Field . set Text ( m_cc . get Name ( ) ) ; apps Host Field . set Text ( m_cc . get Apps Host ( ) ) ; apps Port Field . set Text (  String . value Of ( m_cc . get Apps Port ( ) ) ) ; b Test Apps . set Icon ( get Status Icon ( m_cc . is Apps Server OK ( _ BOOL ) ) ) ; boolean rw =  CConnection . is Server Embedded ( ) ? _ BOOL : ! m_cc . is Apps Server OK ( _ BOOL ) ; db Type Label . set Read Write ( rw ) ; db Type Field . set Read Write ( rw ) ; db Type Field . set Selected Item ( m_cc . get Type ( ) ) ; host Label . set Read Write ( rw ) ; host Field . set Read Write ( rw ) ; host Field . set Text ( m_cc . get Db Host ( ) ) ; port Label . set Read Write ( rw ) ; db Port Field . set Read Write ( rw ) ; db Port Field . set Text (  String . value Of ( m_cc . get Db Port ( ) ) ) ; sid Label . set Read Write ( rw ) ; sid Field . set Read Write ( rw ) ; sid Field . set Text ( m_cc . get Db Name ( ) ) ; db Uid Label . set Read Write ( rw ) ; db Uid Field . set Read Write ( rw ) ; db Uid Field . set Text ( m_cc . get Db Uid ( ) ) ; db Pwd Field . set Editable ( rw ) ; db Pwd Field . set Text ( m_cc . get Db Pwd ( ) ) ; cb Bequeath . set Read Write ( rw ) ; cb Bequeath . set Enabled ( m_cc . is Oracle ( ) ) ; cb Bequeath . set Selected ( m_cc . is Bequeath ( ) ) ; boolean fw Enabled = rw && m_cc . is Via Firewall ( ) && m_cc . is Oracle ( ) ; cb Firewall . set Read Write ( rw && m_cc . is Oracle ( ) ) ; cb Firewall . set Selected ( m_cc . is Via Firewall ( ) ) ; fw Host Label . set Read Write ( fw Enabled ) ; fw Host Field . set Read Write ( fw Enabled ) ; fw Host Field . set Text ( m_cc . get Fw Host ( ) ) ; fw Port Label . set Read Write ( fw Enabled ) ; fw Port Field . set Read Write ( fw Enabled ) ; fw Port Field . set Text (  String . value Of ( m_cc . get Fw Port ( ) ) ) ; b Test DB . set Tool Tip Text ( m_cc . get Connection URL ( ) ) ; b Test DB . set Icon ( get Status Icon ( m_cc . is Database OK ( ) ) ) ; m_updating = _ BOOL ; }
public void create Snapshot ( ) throws  Backup Exception { logger . debug ( _ STR + this . snapshot Name ) ; process Helper . exec ( _ STR , lvcreate Cmd ) ; }
public final  Uri store Log File ( final  Log File log File , final int session Id ) { final  Content Values values = new  Content Values ( ) ; values . put (  Schema .  COL_ MANUFACTURER , log File . get Manufacturer ( ) ) ; values . put (  Schema .  COL_ MODEL , log File . get Model ( ) ) ; values . put (  Schema .  COL_ REVISION , log File . get Revision ( ) ) ; values . put (  Schema .  COL_ SWID , log File . get Swid ( ) ) ; values . put (  Schema .  COL_ SWVER , log File . get Sw Version ( ) ) ; values . put (  Schema .  COL_ TIMESTAMP ,  System . current Time Millis ( ) ) ; values . put (  Schema .  COL_ SESSION_ ID , session Id ) ; return content Resolver . insert (  Content Provider .  CONTENT_ URI_ LOGFILE , values ) ; }
public  Map <  String ,  String > merge (  Map <  String ,  String > cur Props ,  Map <  String ,  String > new Props ) throws  IOException {  Map <  String ,  String > props = new  Hash Map < > ( new Props ) ; for (  Map .  Entry <  String ,  String > e : cur Props . entry Set ( ) ) {  String name = e . get Key ( ) ;  String cur Value = e . get Value ( ) ; if ( props . contains Key ( name ) ) { props . put ( name , cur Value ) ; } } return props ; }
public  Builder delete Preferred Language ( ) { delete Fields . add ( _ STR ) ; return this ; }
public void on Prepared (  Media Player player ) { m State =  State .  PLAYING ; update Notification (  String . format ( get String (  R . string . media_state_playing ) , m File . get File Name ( ) ) ) ; if ( m Media Controller != null ) { m Media Controller . set Enabled ( _ BOOL ) ; } player . seek To ( m Start Position ) ; config And Start Media Player ( ) ; if ( ! m Play On Prepared ) { process Pause Request ( ) ; } if ( m Media Controller != null ) { m Media Controller . update Pause Play ( ) ; } }
private void parse Parameter (  String token ,  String value ) { if ( token != null && value != null ) { if ( token . equals Ignore Case (  NONCE_ TOKEN ) ) { m Nonce = value ; return ; } if ( token . equals Ignore Case (  STALE_ TOKEN ) ) { parse Stale ( value ) ; return ; } if ( token . equals Ignore Case (  OPAQUE_ TOKEN ) ) { m Opaque = value ; return ; } if ( token . equals Ignore Case (  QOP_ TOKEN ) ) { m Qop = value . to Lower Case ( ) ; return ; } if ( token . equals Ignore Case (  ALGORITHM_ TOKEN ) ) { m Algorithm = value . to Lower Case ( ) ; return ; } } }
public  List <  String > make URLList (  String shard ) {  List <  String > urls =  Str Utils . split Smart ( shard , _ STR , _ BOOL ) ; for ( int i = _ NUM ; i < urls . size ( ) ; i ++ ) { urls . set ( i , build Url ( urls . get ( i ) ) ) ; } if ( urls . size ( ) > _ NUM )  Collections . shuffle ( urls , r ) ; return urls ; }
public void skip ( int n ) throws  IOException { dis . skip ( n ) ; }
public void to All In Radius (  World Server world ,  Vec3d pos , double radius ) { double max Distance = radius * radius + radius * radius + radius * radius ; to All ( world . get Players (  Entity Player MP . class , null ) ) ; }
public static  ECDHECryptography from Named Curve Id ( int supported Group Id ) {  Supported Group group =  Supported Group . from Id ( supported Group Id ) ; if ( group == null ) { return null ; } else { try { return new  ECDHECryptography ( group . name ( ) ) ; } catch (  General Security Exception e ) {  LOGGER . log (  Level .  WARNING , _ STR , new  Object [ ] { group . name ( ) , e . get Message ( ) } ) ; return null ; } } }
private static void add Header (  Message message ,  String name ,  String value ) {  Map <  String ,  List <  String > > protocol Headers =  Cast Utils . cast ( (  Map < ? , ? > ) message . get (  Message .  PROTOCOL_ HEADERS ) ) ; if ( protocol Headers == null ) { protocol Headers = new  Tree Map <  String ,  List <  String > > (  String .  CASE_ INSENSITIVE_ ORDER ) ; message . put (  Message .  PROTOCOL_ HEADERS , protocol Headers ) ; }  List <  String > header =  Cast Utils . cast ( (  List < ? > ) protocol Headers . get ( name ) ) ; if ( header == null ) { header = new  Array List <  String > ( ) ; protocol Headers . put ( name , header ) ; } if ( header . size ( ) == _ NUM ) { header . add ( value ) ; } else { header . set ( _ NUM , header . get ( _ NUM ) + _ STR + value ) ; } }
private static void swilk ( boolean [ ] init , double [ ] x , int n , int n1 , int n2 , double [ ] a , double [ ] w , double [ ] pw , int [ ] ifault ) { pw [ _ NUM ] = _ NUM ; if ( w [ _ NUM ] >= _ NUM ) { w [ _ NUM ] = _ NUM ; } double an = n ; ifault [ _ NUM ] = _ NUM ; int nn2 = n / _ NUM ; if ( n2 < nn2 ) { return ; } ifault [ _ NUM ] = _ NUM ; if ( n < _ NUM ) { return ; } if ( ! init [ _ NUM ] ) { if ( n == _ NUM ) { a [ _ NUM ] =  SQRTH ; } else { double an25 = an + _ NUM ; double summ2 = _ NUM ; for ( int i = _ NUM ; i <= n2 ; ++ i ) { a [ i ] = ppnd ( ( i -  TH ) / an25 ) ; summ2 += a [ i ] * a [ i ] ; } summ2 *= _ NUM ; double ssumm2 =  Math . sqrt ( summ2 ) ; double rsn = _ NUM /  Math . sqrt ( an ) ; double a1 = poly (  C1 , _ NUM , rsn ) - a [ _ NUM ] / ssumm2 ; int i1 ; double fac ; if ( n > _ NUM ) { i1 = _ NUM ; double a2 = - a [ _ NUM ] / ssumm2 + poly (  C2 , _ NUM , rsn ) ; fac =  Math . sqrt ( ( summ2 - _ NUM * a [ _ NUM ] * a [ _ NUM ] - _ NUM * a [ _ NUM ] * a [ _ NUM ] ) / ( _ NUM - _ NUM * a1 * a1 - _ NUM * a2 * a2 ) ) ; a [ _ NUM ] = a1 ; a [ _ NUM ] = a2 ; } else { i1 = _ NUM ; fac =  Math . sqrt ( ( summ2 - _ NUM * a [ _ NUM ] * a [ _ NUM ] ) / ( _ NUM - _ NUM * a1 * a1 ) ) ; a [ _ NUM ] = a1 ; } for ( int i = i1 ; i <= nn2 ; ++ i ) { a [ i ] = - a [ i ] / fac ; } } init [ _ NUM ] = _ BOOL ; } if ( n1 < _ NUM ) { return ; } int ncens = n - n1 ; ifault [ _ NUM ] = _ NUM ; if ( ncens < _ NUM || ( ncens > _ NUM && n < _ NUM ) ) { return ; } ifault [ _ NUM ] = _ NUM ; double delta = ncens / an ; if ( delta > _ NUM ) { return ; } double w1 , xx ; if ( w [ _ NUM ] < _ NUM ) { w1 = _ NUM + w [ _ NUM ] ; ifault [ _ NUM ] = _ NUM ; } else { ifault [ _ NUM ] = _ NUM ; double range = x [ n1 ] - x [ _ NUM ] ; if ( range <  SMALL ) { return ; } ifault [ _ NUM ] = _ NUM ; xx = x [ _ NUM ] / range ; double sx = xx ; double sa = - a [ _ NUM ] ; int j = n - _ NUM ; for ( int i = _ NUM ; i <= n1 ; ++ i ) { double xi = x [ i ] / range ; sx += xi ; if ( i != j ) { sa += sign ( _ NUM , i - j ) * a [  Math . min ( i , j ) ] ; } xx = xi ; -- j ; } ifault [ _ NUM ] = _ NUM ; if ( n > _ NUM ) { ifault [ _ NUM ] = _ NUM ; } sa /= n1 ; sx /= n1 ; double ssa = _ NUM ; double ssx = _ NUM ; double sax = _ NUM ; j = n ; double asa ; for ( int i = _ NUM ; i <= n1 ; ++ i ) { if ( i != j ) { asa = sign ( _ NUM , i - j ) * a [  Math . min ( i , j ) ] - sa ; } else { asa = - sa ; } double xsx = x [ i ] / range - sx ; ssa += asa * asa ; ssx += xsx * xsx ; sax += asa * xsx ; -- j ; } double ssassx =  Math . sqrt ( ssa * ssx ) ; w1 = ( ssassx - sax ) * ( ssassx + sax ) / ( ssa * ssx ) ; } w [ _ NUM ] = _ NUM - w1 ; if ( n == _ NUM ) { pw [ _ NUM ] =  PI6 * (  Math . asin (  Math . sqrt ( w [ _ NUM ] ) ) -  STQR ) ; return ; } double y =  Math . log ( w1 ) ; xx =  Math . log ( an ) ; double m = _ NUM ; double s = _ NUM ; if ( n <= _ NUM ) { double gamma = poly (  G , _ NUM , an ) ; if ( y >= gamma ) { pw [ _ NUM ] =  SMALL ; return ; } y = -  Math . log ( gamma - y ) ; m = poly (  C3 , _ NUM , an ) ; s =  Math . exp ( poly (  C4 , _ NUM , an ) ) ; } else { m = poly (  C5 , _ NUM , xx ) ; s =  Math . exp ( poly (  C6 , _ NUM , xx ) ) ; } if ( ncens > _ NUM ) { double ld = -  Math . log ( delta ) ; double bf = _ NUM + xx *  BF1 ; double z90f =  Z90 + bf *  Math . pow ( poly (  C7 , _ NUM ,  Math . pow (  XX90 , xx ) ) , ld ) ; double z95f =  Z95 + bf *  Math . pow ( poly (  C8 , _ NUM ,  Math . pow (  XX95 , xx ) ) , ld ) ; double z99f =  Z99 + bf *  Math . pow ( poly (  C9 , _ NUM , xx ) , ld ) ; double zfm = ( z90f + z95f + z99f ) / _ NUM ; double zsd = (  Z90 * ( z90f - zfm ) +  Z95 * ( z95f - zfm ) +  Z99 * ( z99f - zfm ) ) /  ZSS ; double zbar = zfm - zsd *  ZM ; m += zbar * s ; s *= zsd ; } pw [ _ NUM ] = alnorm ( ( y - m ) / s ,  UPPER ) ; }
public  String as String ( ) {  String Builder buff = new  String Builder ( ) ; for ( int i = _ NUM ; i < array Level ; i ++ ) { if ( ref Count ) { buff . append ( _ STR ) ; } buff . append ( _ STR ) ; } if ( ref Count ) { if ( ! class Obj . is Primitive ) { buff . append ( _ STR ) ; } } buff . append ( class Obj . to String ( ) ) ; if ( ref Count ) { if ( ! class Obj . is Primitive ) { buff . append ( _ STR ) ; } } for ( int i = _ NUM ; i < array Level ; i ++ ) { if ( ref Count ) { buff . append ( _ STR ) ; } else { if ( ! class Obj . is Primitive ) { buff . append ( _ STR ) ; } } buff . append ( _ STR ) ; } if ( ! ref Count ) { if ( is Object ( ) ) { buff . append ( _ STR ) ; } } return buff . to String ( ) ; }
public  List <  Json Object > execute Parametrized Statement (  String statement ,  List <  String > parameter Names ,  List <  Object > parameter Values ) {  Json Object named Params =  Json Object . create ( ) ; for ( int param = _ NUM ; param < parameter Names . size ( ) ; param ++ ) { named Params . put ( parameter Names . get ( param ) , parameter Values . get ( param ) ) ; }  Parameterized N1ql Query query =  N1ql Query . parameterized ( statement , named Params ) ; return execute Query ( query ) ; }
public final  T end All ( ) { while ( ! tag Stack . is Empty ( ) ) { end ( ) ; } return get Self ( ) ; }
public static  Table create Partitioned Table (  Configuration conf ,  Hive Metastore Client ms ,  Hive Object Spec table Spec ,  Table Type table Type ,  Path warehouse Root ) throws  IOException ,  Hive Metastore Exception {  Path table Location = get Path For Hive Object ( warehouse Root , table Spec ) ;  Table table = new  Table ( ) ; table . set Db Name ( table Spec . get Db Name ( ) ) ; table . set Table Name ( table Spec . get Table Name ( ) ) ;  Map <  String ,  String > parameters = new  Hash Map < > ( ) ; parameters . put (  Hive Parameter Keys .  TLDT ,  Long . to String (  System . current Time Millis ( ) ) ) ; table . set Parameters ( parameters ) ; table . set Table Type ( table Type . to String ( ) ) ;  List <  Field Schema > partition Cols = new  Array List < > ( ) ; partition Cols . add ( new  Field Schema ( _ STR , _ STR , _ STR ) ) ; partition Cols . add ( new  Field Schema ( _ STR , _ STR , _ STR ) ) ; table . set Partition Keys ( partition Cols ) ;  Storage Descriptor sd = new  Storage Descriptor ( ) ;  List <  Field Schema > columns = new  Array List < > ( ) ; columns . add ( new  Field Schema ( _ STR , _ STR , _ STR ) ) ; sd . set Cols ( columns ) ; if ( table Type ==  Table Type .  MANAGED_ TABLE || table Type ==  Table Type .  EXTERNAL_ TABLE ) { sd . set Location ( table Location . to String ( ) ) ; } sd . set Serde Info ( new  Ser De Info ( _ STR , _ STR , new  Hash Map < > ( ) ) ) ; table . set Sd ( sd ) ; if ( ! ms . exists Db ( table . get Db Name ( ) ) ) { ms . create Database ( new  Database ( table . get Db Name ( ) , null , null , null ) ) ; } ms . create Table ( table ) ; return table ; }
protected  Form Spec (  Default Alignment default Alignment ,  String encoded Description ) { this ( default Alignment ,  Sizes .  DEFAULT ,  NO_ GROW ) ; parse And Init Values ( encoded Description . to Lower Case (  Locale .  ENGLISH ) ) ; }
public static <  T >  List <  T > decode (  Input Stream data ,  Parser <  T > parser ) throws  IOException {  Coded Input Stream stream =  Coded Input Stream . new Instance ( data ) ;  List <  T > list = new  Array List < > ( ) ; while ( ! stream . is At End ( ) ) { int size = stream . read Raw Varint32 ( ) ; byte [ ] element = stream . read Raw Bytes ( size ) ;  T decoded = parser . parse From ( element ) ; list . add ( decoded ) ; } return list ; }
@  Override public void draw Item (  Graphics2 D g2 ,  XYItem Renderer State state ,  Rectangle2 D data Area ,  Plot Rendering Info info ,  XYPlot plot ,  Value Axis domain Axis ,  Value Axis range Axis ,  XYDataset dataset , int series , int item ,  Crosshair State crosshair State , int pass ) { if ( ( ! get Plot Lines ( ) ) || ( ( ! ( domain Axis instanceof  Cyclic Number Axis ) ) && ( ! ( range Axis instanceof  Cyclic Number Axis ) ) ) || ( item <= _ NUM ) ) { super . draw Item ( g2 , state , data Area , info , plot , domain Axis , range Axis , dataset , series , item , crosshair State , pass ) ; return ; } double xn = dataset . get XValue ( series , item - _ NUM ) ; double yn = dataset . get YValue ( series , item - _ NUM ) ; if (  Double . is Na N ( yn ) ) { super . draw Item ( g2 , state , data Area , info , plot , domain Axis , range Axis , dataset , series , item , crosshair State , pass ) ; return ; } double [ ] x = new double [ _ NUM ] ; double [ ] y = new double [ _ NUM ] ; x [ _ NUM ] = xn ; y [ _ NUM ] = yn ; xn = dataset . get XValue ( series , item ) ; yn = dataset . get YValue ( series , item ) ; if (  Double . is Na N ( yn ) ) { return ; } x [ _ NUM ] = xn ; y [ _ NUM ] = yn ; double xcycle Bound =  Double .  Na N ; double ycycle Bound =  Double .  Na N ; boolean x Bound Mapping = _ BOOL , y Bound Mapping = _ BOOL ;  Cyclic Number Axis cnax = null , cnay = null ; if ( domain Axis instanceof  Cyclic Number Axis ) { cnax = (  Cyclic Number Axis ) domain Axis ; xcycle Bound = cnax . get Cycle Bound ( ) ; x Bound Mapping = cnax . is Bound Mapped To Last Cycle ( ) ; if ( ( x [ _ NUM ] != x [ _ NUM ] ) && ( ( xcycle Bound >= x [ _ NUM ] ) && ( xcycle Bound <= x [ _ NUM ] ) || ( xcycle Bound >= x [ _ NUM ] ) && ( xcycle Bound <= x [ _ NUM ] ) ) ) { double [ ] nx = new double [ _ NUM ] ; double [ ] ny = new double [ _ NUM ] ; nx [ _ NUM ] = x [ _ NUM ] ; nx [ _ NUM ] = x [ _ NUM ] ; ny [ _ NUM ] = y [ _ NUM ] ; ny [ _ NUM ] = y [ _ NUM ] ; nx [ _ NUM ] = xcycle Bound ; ny [ _ NUM ] = ( y [ _ NUM ] - y [ _ NUM ] ) * ( xcycle Bound - x [ _ NUM ] ) / ( x [ _ NUM ] - x [ _ NUM ] ) + y [ _ NUM ] ; x = nx ; y = ny ; } } if ( range Axis instanceof  Cyclic Number Axis ) { cnay = (  Cyclic Number Axis ) range Axis ; ycycle Bound = cnay . get Cycle Bound ( ) ; y Bound Mapping = cnay . is Bound Mapped To Last Cycle ( ) ; if ( ( y [ _ NUM ] != y [ _ NUM ] ) && ( ( ycycle Bound >= y [ _ NUM ] ) && ( ycycle Bound <= y [ _ NUM ] ) || ( ycycle Bound >= y [ _ NUM ] ) && ( ycycle Bound <= y [ _ NUM ] ) ) ) { double [ ] nx = new double [ x . length + _ NUM ] ; double [ ] ny = new double [ y . length + _ NUM ] ; nx [ _ NUM ] = x [ _ NUM ] ; nx [ _ NUM ] = x [ _ NUM ] ; ny [ _ NUM ] = y [ _ NUM ] ; ny [ _ NUM ] = y [ _ NUM ] ; ny [ _ NUM ] = ycycle Bound ; nx [ _ NUM ] = ( x [ _ NUM ] - x [ _ NUM ] ) * ( ycycle Bound - y [ _ NUM ] ) / ( y [ _ NUM ] - y [ _ NUM ] ) + x [ _ NUM ] ; if ( x . length == _ NUM ) { nx [ _ NUM ] = x [ _ NUM ] ; ny [ _ NUM ] = y [ _ NUM ] ; } x = nx ; y = ny ; } else if ( ( x . length == _ NUM ) && ( y [ _ NUM ] != y [ _ NUM ] ) && ( ( ycycle Bound >= y [ _ NUM ] ) && ( ycycle Bound <= y [ _ NUM ] ) || ( ycycle Bound >= y [ _ NUM ] ) && ( ycycle Bound <= y [ _ NUM ] ) ) ) { double [ ] nx = new double [ _ NUM ] ; double [ ] ny = new double [ _ NUM ] ; nx [ _ NUM ] = x [ _ NUM ] ; nx [ _ NUM ] = x [ _ NUM ] ; nx [ _ NUM ] = x [ _ NUM ] ; ny [ _ NUM ] = y [ _ NUM ] ; ny [ _ NUM ] = y [ _ NUM ] ; ny [ _ NUM ] = y [ _ NUM ] ; ny [ _ NUM ] = ycycle Bound ; nx [ _ NUM ] = ( x [ _ NUM ] - x [ _ NUM ] ) * ( ycycle Bound - y [ _ NUM ] ) / ( y [ _ NUM ] - y [ _ NUM ] ) + x [ _ NUM ] ; x = nx ; y = ny ; } } if ( x . length == _ NUM ) { super . draw Item ( g2 , state , data Area , info , plot , domain Axis , range Axis , dataset , series , item , crosshair State , pass ) ; return ; }  Overwrite Data Set newset = new  Overwrite Data Set ( x , y , dataset ) ; if ( cnax != null ) { if ( xcycle Bound == x [ _ NUM ] ) { cnax . set Bound Mapped To Last Cycle ( x [ _ NUM ] <= xcycle Bound ) ; } if ( xcycle Bound == x [ _ NUM ] ) { cnax . set Bound Mapped To Last Cycle ( x [ _ NUM ] <= xcycle Bound ) ; } } if ( cnay != null ) { if ( ycycle Bound == y [ _ NUM ] ) { cnay . set Bound Mapped To Last Cycle ( y [ _ NUM ] <= ycycle Bound ) ; } if ( ycycle Bound == y [ _ NUM ] ) { cnay . set Bound Mapped To Last Cycle ( y [ _ NUM ] <= ycycle Bound ) ; } } super . draw Item ( g2 , state , data Area , info , plot , domain Axis , range Axis , newset , series , _ NUM , crosshair State , pass ) ; if ( cnax != null ) { if ( xcycle Bound == x [ _ NUM ] ) { cnax . set Bound Mapped To Last Cycle ( x [ _ NUM ] <= xcycle Bound ) ; } if ( xcycle Bound == x [ _ NUM ] ) { cnax . set Bound Mapped To Last Cycle ( x [ _ NUM ] <= xcycle Bound ) ; } } if ( cnay != null ) { if ( ycycle Bound == y [ _ NUM ] ) { cnay . set Bound Mapped To Last Cycle ( y [ _ NUM ] <= ycycle Bound ) ; } if ( ycycle Bound == y [ _ NUM ] ) { cnay . set Bound Mapped To Last Cycle ( y [ _ NUM ] <= ycycle Bound ) ; } } super . draw Item ( g2 , state , data Area , info , plot , domain Axis , range Axis , newset , series , _ NUM , crosshair State , pass ) ; if ( x . length == _ NUM ) { if ( cnax != null ) { if ( xcycle Bound == x [ _ NUM ] ) { cnax . set Bound Mapped To Last Cycle ( x [ _ NUM ] <= xcycle Bound ) ; } if ( xcycle Bound == x [ _ NUM ] ) { cnax . set Bound Mapped To Last Cycle ( x [ _ NUM ] <= xcycle Bound ) ; } } if ( cnay != null ) { if ( ycycle Bound == y [ _ NUM ] ) { cnay . set Bound Mapped To Last Cycle ( y [ _ NUM ] <= ycycle Bound ) ; } if ( ycycle Bound == y [ _ NUM ] ) { cnay . set Bound Mapped To Last Cycle ( y [ _ NUM ] <= ycycle Bound ) ; } } super . draw Item ( g2 , state , data Area , info , plot , domain Axis , range Axis , newset , series , _ NUM , crosshair State , pass ) ; } if ( cnax != null ) { cnax . set Bound Mapped To Last Cycle ( x Bound Mapping ) ; } if ( cnay != null ) { cnay . set Bound Mapped To Last Cycle ( y Bound Mapping ) ; } }
public void write Field ( final  String name , final double value ) throws java . io .  IOException { write Field ( name ,  Double . to String ( value ) ) ; }
public  Creature calculate Next Creature ( final int quest Level ) { final  List <  Creature > possible Creatures To Spawn = new  Array List <  Creature > ( ) ; int last Level = _ NUM ; for ( final  Creature creature : sorted Creatures ) { if ( creature . get Level ( ) > quest Level ) { break ; } if ( creature . get Level ( ) > last Level ) { possible Creatures To Spawn . clear ( ) ; last Level = creature . get Level ( ) ; } possible Creatures To Spawn . add ( creature ) ; }  Creature creature To Spawn = null ; if ( possible Creatures To Spawn . size ( ) == _ NUM ) { creature To Spawn = sorted Creatures . get ( sorted Creatures . size ( ) - _ NUM ) ; } else {  Collections . shuffle ( possible Creatures To Spawn ) ; creature To Spawn = possible Creatures To Spawn . get ( _ NUM ) ; } return creature To Spawn ; }
@  Override public void before (  Property Info Rest Rep old Props ,  Property Info Rest Rep new Props ) {  String new Interval Str = new Props . get Property (  Backup Constants .  SCHEDULE_ INTERVAL ) ;  String new Start Time Str = new Props . get Property (  Backup Constants .  SCHEDULE_ TIME ) ; if ( ( new Interval Str == null || new Interval Str . is Empty ( ) ) && ( new Start Time Str == null || new Start Time Str . is Empty ( ) ) ) { _log . info ( _ STR ) ; return ; }  String interval Str = ( new Interval Str == null || new Interval Str . is Empty ( ) ) ? old Props . get Property (  Backup Constants .  SCHEDULE_ INTERVAL ) : new Interval Str ;  String start Time Str = ( new Start Time Str == null || new Start Time Str . is Empty ( ) ) ? old Props . get Property (  Backup Constants .  SCHEDULE_ TIME ) : new Start Time Str ; _log . info ( _ STR , interval Str , start Time Str ) ; validate Backup Interval And Start Time ( interval Str , start Time Str ) ; }
@  Override public void delete Trait (  String guid ,  String trait Name To Be Deleted ) throws  Atlas Exception { guid =  Param Checker . not Empty ( guid , _ STR ) ; trait Name To Be Deleted =  Param Checker . not Empty ( trait Name To Be Deleted , _ STR ) ; if ( ! type System . is Registered ( trait Name To Be Deleted ) ) { final  String msg =  String . format ( _ STR , trait Name To Be Deleted ) ;  LOG . error ( msg ) ; throw new  Type Not Found Exception ( msg ) ; } repository . delete Trait ( guid , trait Name To Be Deleted ) ; on Trait Deleted From Entity ( repository . get Entity Definition ( guid ) , trait Name To Be Deleted ) ; }
public void add Tables (  Collection <  Table > tables ) { for (  Iterator <  Table > it = tables . iterator ( ) ; it . has Next ( ) ; ) { add Table ( (  Table ) it . next ( ) ) ; } }
protected void write File (  String template ,  Writer writer ) { if ( template == null ) { throw new  Illegal Argument Exception ( _ STR ) ; }  Buffered Writer buffered Writer = new  Buffered Writer ( writer ) ;  String output = replace ( template , null ) ; try { buffered Writer . append ( output ) ; } catch (  IOException e ) { logger . log (  Diagnostic .  Kind .  ERROR , _ STR ) ; e . print Stack Trace ( ) ; } finally { try { buffered Writer . close ( ) ; } catch (  IOException e ) { e . print Stack Trace ( ) ; } } }
public static  String slurp URLNo Exceptions (  URL u ,  String encoding ) { try { return slurp URL ( u , encoding ) ; } catch (  Exception e ) { e . print Stack Trace ( ) ; return null ; } }
public synchronized boolean clear ( ) { if ( is Loading ( ) ) { return _ BOOL ; } loader = new  Thread ( null ) ; loader . start ( ) ; return _ BOOL ; }
public int index Of ( final  Rounded Tool Item item ) { check Widget ( ) ; return items . index Of ( item ) ; }
public void add Attribute (  String alias ,  String type Uri , boolean required , int count ) throws  Message Exception { if ( alias . index Of ( _ STR ) > - _ NUM || alias . index Of ( _ STR ) > - _ NUM || alias . index Of ( _ STR ) > - _ NUM || alias . index Of ( _ STR ) > - _ NUM ) throw new  Message Exception ( _ STR + alias ) ; _parameters . set ( new  Parameter ( _ STR + alias , type Uri ) ) ;  String level = required ? _ STR : _ STR ;  Parameter level Param = _parameters . get Parameter ( level ) ;  Parameter new Param ; if ( level Param == null ) { new Param = new  Parameter ( level , alias ) ; } else { new Param = new  Parameter ( level , level Param . get Value ( ) + _ STR + alias ) ; _parameters . remove Parameters ( level ) ; } _parameters . set ( new Param ) ; set Count ( alias , count ) ; if (  DEBUG ) _log . debug ( _ STR + type Uri + _ STR + alias + _ STR + count + _ STR + required ) ; }
public  Void call ( ) throws  Exception { final  List <  Future <  Void > > tasks = new  Linked List <  Future <  Void > > ( ) ; try { for (  IV < ? , ? > term Id : graphs ) { final  Future Task <  Void > ft = new  Future Task <  Void > ( new  Drain Iterator Task ( term Id ) ) ; tasks . add ( ft ) ; executor . execute ( ft ) ; } for (  Future <  Void > f : tasks ) { f . get ( ) ; } } catch (  Throwable ex ) { for (  Future <  Void > f : tasks ) f . cancel ( _ BOOL ) ; throw new  Runtime Exception ( ex ) ; } finally { buffer . close ( ) ; } return null ; }
protected void run Full Import (  String data Config ,  Map <  String ,  String > extra Params ) throws  Exception {  Hash Map <  String ,  String > params = new  Hash Map < > ( ) ; params . put ( _ STR , _ STR ) ; params . put ( _ STR , _ STR ) ; params . put ( _ STR , data Config ) ; params . put ( _ STR , _ STR ) ; params . put ( _ STR , _ STR ) ; params . put All ( extra Params ) ;  Named List l = new  Named List ( ) ; for (  Map .  Entry <  String ,  String > e : params . entry Set ( ) ) { l . add ( e . get Key ( ) , e . get Value ( ) ) ; }  Local Solr Query Request request = new  Local Solr Query Request ( h . get Core ( ) , l ) ; h . query ( _ STR , request ) ; }
public  String user Id From Range (  Object omin Id ,  Object omax Id ) { int min Id =  Function Handler . get Int ( omin Id ) ; int max Id =  Function Handler . get Int ( omax Id ) ;  Stack <  Integer > stack = get Stack ( min Id , max Id ) ; if ( stack . size ( ) > _ NUM ) { return  Integer . to String ( stack . pop ( ) ) ; } throw new  Illegal Argument Exception ( _ STR ) ; }
public void start ( ) { if ( is Started ) { log . info ( _ STR ) ; return ; } log . info ( _ STR ) ; system Consumer . start ( ) ; is Started = _ BOOL ; }
public static void generate Binary Operation Flags ( final  ITranslation Environment environment , final long next Offset , final  String result , final  Operand Size result Size , final  List <  Reil Instruction > instructions ) throws  Illegal Argument Exception {  Preconditions . check Not Null ( environment , _ STR ) ;  Preconditions . check Not Null ( result , _ STR ) ;  Preconditions . check Not Null ( result Size , _ STR ) ;  Preconditions . check Not Null ( instructions , _ STR ) ; final long base Offset = next Offset - instructions . size ( ) ; long offset = next Offset ; generate Sign Flag Code ( environment , offset , result , result Size , instructions ) ; offset = ( base Offset + instructions . size ( ) ) - _ NUM ; instructions . add (  Reil Helpers . create Bisz ( offset + _ NUM , result Size , result ,  Operand Size .  BYTE ,  Helpers .  ZERO_ FLAG ) ) ; instructions . add (  Reil Helpers . create Str ( offset + _ NUM ,  Operand Size .  BYTE , _ STR ,  Operand Size .  BYTE ,  Helpers .  CARRY_ FLAG ) ) ; instructions . add (  Reil Helpers . create Str ( offset + _ NUM ,  Operand Size .  BYTE , _ STR ,  Operand Size .  BYTE ,  Helpers .  OVERFLOW_ FLAG ) ) ; }
public boolean is Label Movable ( ) { mx Graph graph = graph Component . get Graph ( ) ;  String label = graph . get Label ( state . get Cell ( ) ) ; return graph . is Label Movable ( state . get Cell ( ) ) && label != null && label . length ( ) > _ NUM ; }
public int write Type List (  Type List type List ) { int off = data . position ( ) ; short [ ] types = type List . types ; write Int ( types . length ) ; for ( short type : types ) { write Short ( type ) ; } return off ; }
public static void load Config Resource (  String resource Name ) throws  IOException { config . clear ( ) ; config . put All ( load Properties From Resource ( resource Name ) ) ; }
public static void safe Close Stream (  Input Stream in ) { if ( in != null ) { try { in . close ( ) ; } catch (  Exception e ) { log . error ( e . get Message ( ) , e ) ; } } }
private  Transaction create Transaction ( ) throws  Lease Denied Exception ,  Remote Exception ,  Transaction Exception {  ITransaction Manager Provider transaction Manager Provider = get Transaction Manager Provider ( ) ; return (  Transaction Factory . create ( transaction Manager Provider . get Transaction Manager ( ) , _config . get Transaction Timeout ( ) ) ) . transaction ; }
public void skip While (  String skip ) throws  IOException { char ch ; do { ch = read ( ) ; } while ( skip . index Of ( ch ) > - _ NUM ) ; unread Character ( ch ) ; }
@  Override public boolean contains Key (  Object key ) { if ( key == null ) { return entry For Null Key != null ; } int hash = key . hash Code ( ) ; hash ^= ( hash > > > _ NUM ) ^ ( hash > > > _ NUM ) ; hash ^= ( hash > > > _ NUM ) ^ ( hash > > > _ NUM ) ;  Hash Map Entry <  K ,  V > [ ] tab = table ; for (  Hash Map Entry <  K ,  V > e = tab [ hash & ( tab . length - _ NUM ) ] ; e != null ; e = e . next ) {  K e Key = e . key ; if ( e Key == key || ( e . hash == hash && key . equals ( e Key ) ) ) { return _ BOOL ; } } return _ BOOL ; }
public void save Pois From Assets ( ) {  List <  Poi > pois = poi Asset Loader . load Pois From Assets ( ) ;  Timber . d ( _ STR , pois . size ( ) ) ; for (  Poi poi : pois ) {  Timber . d ( _ STR , poi ) ; save Poi ( poi ) ;  Timber . d ( _ STR ) ; } }
private void create Element (  Document doc ,  Element parent Element ,  String element Name ,  Color value ) {  Element element = doc . create Element ( element Name ) ; element . append Child ( doc . create Text Node (  Colour Utils . from Colour ( value ) ) ) ; parent Element . append Child ( element ) ; }
public static boolean been Done ( @  Scope int scope ,  String tag ,  Count Checker number Of Times ) {  List <  Long > tag Seen Dates = tag Last Seen Map . get ( tag ) ; if ( tag Seen Dates . is Empty ( ) ) { return _ BOOL ; } if ( scope ==  THIS_ APP_ INSTALL ) { return number Of Times . check ( tag Seen Dates . size ( ) ) ; } else if ( scope ==  THIS_ APP_ SESSION ) { int counter = _ NUM ; for (  String tag From List : session List ) { if ( tag From List . equals ( tag ) ) { counter ++ ; } } return number Of Times . check ( counter ) ; } else { int counter = _ NUM ; for (  Long seen Date : tag Seen Dates ) { if ( seen Date > last App Updated Time ) { counter ++ ; } } return number Of Times . check ( counter ) ; } }
void variable Operator Changed ( int row ,  String oper ) {  Conditional Variable variable = _variable List . get ( row ) ; int old Oper = variable . get Opern ( ) ; if ( row > _ NUM ) { if ( oper . equals (  Bundle . get Message ( _ STR ) ) ) { variable . set Opern (  Conditional .  OPERATOR_ OR ) ; } else { variable . set Opern (  Conditional .  OPERATOR_ AND ) ; } } else { variable . set Opern (  Conditional .  OPERATOR_ NONE ) ; } if ( variable . get Opern ( ) != old Oper ) { make Antecedent ( ) ; } }
public void add Header (  String name ,  String val ) { m Msg Header = m Msg Header + name + _ STR + val + m Line Delimiter ; add Internal Header Fields ( name , val ) ; }
public static void check Duplicate Request (  Redis Client redis Client ,  String uri ,  Buffer buffer ,  String ttl ,  Handler <  Boolean > callback ) {  Integer time To Live = parse Time To Live ( ttl ) ;  String redis Key = get Redis Key ( uri ,  Hash Code Generator . create Hash Code ( uri , buffer . to String ( ) ) ) ; handle Storage ( redis Client , redis Key , time To Live , callback ) ; }
boolean is Hidden (  View view ) { return m Hidden Views . contains ( view ) ; }
public static void delete Recursive ( @  Non Null  File file Or Directory ) { delete Recursive ( file Or Directory ,  Collections .  EMPTY_ LIST ) ; }
static boolean does Menu Bar Border Tool Bar (  JMenu Bar c ) {  JTool Bar tb = (  JTool Bar )  Metal Tool Bar UI . find Registered Component Of Type ( c ,  JTool Bar . class ) ; if ( tb != null && tb . get Orientation ( ) ==  JTool Bar .  HORIZONTAL ) {  JRoot Pane rp =  Swing Utilities . get Root Pane ( c ) ;  Point point = new  Point ( _ NUM , _ NUM ) ; point =  Swing Utilities . convert Point ( c , point , rp ) ; int menu X = point . x ; int menu Y = point . y ; point . x = point . y = _ NUM ; point =  Swing Utilities . convert Point ( tb , point , rp ) ; return ( point . x == menu X && menu Y + c . get Height ( ) == point . y && c . get Width ( ) == tb . get Width ( ) ) ; } return _ BOOL ; }
private  Priority Queue <  USField > create Queue (  String field Name ,  Map <  String ,  Flt > words ) throws  IOException { int num Docs = ir . num Docs ( ) ;  Freq Q res = new  Freq Q ( words . size ( ) ) ; for (  String word : words . key Set ( ) ) { float tf = words . get ( word ) . x ; if ( min Term Freq > _ NUM && tf < min Term Freq ) { continue ; } int doc Freq = ir . doc Freq ( new  Term ( field Name , word ) ) ; if ( min Doc Freq > _ NUM && doc Freq < min Doc Freq ) { continue ; } if ( doc Freq == _ NUM || doc Freq > max Doc Freq ) { continue ; } float idf = similarity . idf ( doc Freq , num Docs ) ; float score = _ NUM ; if ( is Log Tf ( ) ) { score = ( float ) (  Math . log ( tf + _ NUM ) * idf ) ; } else { score = tf * idf ; }  USField mlt Field ; if ( is Payload Field ( field Name ) ) { mlt Field = new  USField ( word , field Name , score , tf , idf , doc Freq , _ NUM ) ; } else { mlt Field = new  USField ( word , field Name , score , tf , idf , doc Freq ) ; } res . insert With Overflow ( mlt Field ) ; } return res ; }
public static void each Object (  Object Input Stream ois ,  Closure closure ) throws  IOException ,  Class Not Found Exception { try { while ( _ BOOL ) { try {  Object obj = ois . read Object ( ) ; closure . call ( obj ) ; } catch (  EOFException e ) { break ; } }  Input Stream temp = ois ; ois = null ; temp . close ( ) ; } finally { close With Warning ( ois ) ; } }
private static int exit With Status ( int status ) { if (  Tool IO . get Mode ( ) ==  Tool IO .  SYSTEM ) {  System . exit ( status ) ; } return status ; }
public static double distance In Meters ( final double lat P1 , final double lat P2 , final double lon P1 , final double lon P2 ) { double dist Rad =  Math . acos (  Math . sin ( to Radians ( lat P1 ) ) *  Math . sin ( to Radians ( lat P2 ) ) +  Math . cos ( to Radians ( lat P1 ) ) *  Math . cos ( to Radians ( lat P2 ) ) *  Math . cos ( to Radians ( lon P1 - lon P2 ) ) ) ; final double dist As Degree = to Degrees ( dist Rad ) ; return dist As Degree * _ NUM * _ NUM * _ NUM ; }
public void process Challenge ( final  String challenge ) throws  Malformed Challenge Exception {  String s =  Auth Challenge Parser . extract Scheme ( challenge ) ; if ( ! s . equals Ignore Case ( get Scheme Name ( ) ) ) { throw new  Malformed Challenge Exception ( _ STR + challenge ) ; } int i = challenge . index Of ( _ STR ) ; if ( i != - _ NUM ) { s = challenge . substring ( i , challenge . length ( ) ) ; this . ntlmchallenge = s . trim ( ) ; this . state =  TYPE2_ MSG_ RECEIVED ; } else { this . ntlmchallenge = _ STR ; if ( this . state ==  UNINITIATED ) { this . state =  INITIATED ; } else { this . state =  FAILED ; } } }
public static  Big Integer calculate A (  Big Integer p ,  Big Integer q ,  Big Integer g A ,  Big Integer x2s ) { return g A . mod Pow ( x2s , p ) ; }
public static  MCost Queue add (  MProduct product , int  M_ Attribute Set Instance_ ID ,  MAcct Schema as , int  AD_ Org_ ID , int  M_ Cost Element_ ID ,  Big Decimal amt ,  Big Decimal qty , int precision ,  MCost Detail cd ,  String trx Name ) { if (  CLog Mgt . is Level Fine ( ) ) s_log . fine ( _ STR +  AD_ Org_ ID + _ STR + product . get_ ID ( ) + _ STR +  M_ Attribute Set Instance_ ID + _ STR + amt + _ STR + qty + _ STR + precision ) ;  MCost Queue cq = new  MCost Queue ( product ,  M_ Attribute Set Instance_ ID , as ,  AD_ Org_ ID ,  M_ Cost Element_ ID , trx Name ) ; cq . set Costs ( amt , qty , precision ) ; cq . set Date Acct ( cd . get Date Acct ( ) ) ; cq . save Ex ( ) ; if (  CLog Mgt . is Level Fine ( ) ) s_log . fine ( _ STR + cq ) ; return cq ; }
public void add Undo Event (  Undo Interface event ) { if ( should Process Undo Redo Action ( ) ) { boolean at End Of List = ( current Index >= undo List . size ( ) ) ; if ( ! at End Of List ) { while ( undo List . size ( ) > current Index ) { int last Index = undo List . size ( ) - _ NUM ; undo List . remove ( last Index ) ; } } undo List . add ( event ) ; current Index = undo List . size ( ) ; update Menu Items ( ) ; logger . debug ( event . get String Representation ( ) ) ; } }
public static  Exception establish Cache If Needed (  Print Stream ... progress ) { if ( m_offline ) { return null ; } if (  REP_ MIRROR == null ) { establish Mirror ( ) ; }  Exception problem = null ; if (  INITIAL_ CACHE_ BUILD_ NEEDED ) { for (  Print Stream p : progress ) { p . println ( _ STR ) ; } problem = refresh Cache ( progress ) ;  INITIAL_ CACHE_ BUILD_ NEEDED = _ BOOL ; } return problem ; }
public  List <  Snapshot > current Snapshots (  String repository Name ) {  List <  Snapshot > snapshot List = new  Array List < > ( ) ;  List <  Snapshots In Progress .  Entry > entries = current Snapshots ( repository Name , null ) ; for (  Snapshots In Progress .  Entry entry : entries ) { snapshot List . add ( in Progress Snapshot ( entry ) ) ; }  Collection Util . tim Sort ( snapshot List ) ; return  Collections . unmodifiable List ( snapshot List ) ; }
private void clean Static (  Method Node method ) { }
@  Override protected void paint Tab Background (  Graphics g , int tab Placement , int tab Index , int x , int y , int w , int h , boolean is Selected ) { if ( is Selected ) { if ( tab Placement ==  TOP ) { g . set Color (  Color . white ) ; g . fill Round Rect ( x , y , w , h +  R +  R ,  R ,  R ) ; } } else { } }
private  Automaton build Automaton (  Bytes Ref Hash term Bytes Hash ) { final  Tree Set <  Bytes Ref > terms = new  Tree Set <  Bytes Ref > ( ) ; for ( int i = _ NUM ; i < term Bytes Hash . size ( ) ; i ++ ) {  Bytes Ref ref = new  Bytes Ref ( ) ; term Bytes Hash . get ( i , ref ) ; terms . add ( ref ) ; } final  Automaton a =  Daciuk Mihov Automaton Builder . build ( terms ) ; return a ; }
protected  Range find Range Bounds (  Category Dataset dataset , boolean include Interval ) { if ( dataset == null ) { return null ; } if ( get Data Bounds Includes Visible Series Only ( ) ) {  List visible Series Keys = new  Array List ( ) ; int series Count = dataset . get Row Count ( ) ; for ( int s = _ NUM ; s < series Count ; s ++ ) { if ( is Series Visible ( s ) ) { visible Series Keys . add ( dataset . get Row Key ( s ) ) ; } } return  Dataset Utilities . find Range Bounds ( dataset , visible Series Keys , include Interval ) ; } else { return  Dataset Utilities . find Range Bounds ( dataset , include Interval ) ; } }
protected  String admin Shutdown ( ) { server . shutdown ( ) ; return _ STR ; }
public void assign Role (  AMRole role ) throws  AMException ,  SSOException { assign Role ( role . get DN ( ) ) ; }
protected void write Initial Styles ( ) throws  IOException { out . flush Bits ( ) ; fill Bits =  Out Stream . determine Unsigned Bit Size ( fill Styles . size ( ) ) ; line Bits =  Out Stream . determine Unsigned Bit Size ( line Styles . size ( ) ) ; if ( ! has Style ) { fill Bits = _ NUM ; } else { write Styles ( fill Styles ) ; write Styles ( line Styles ) ; out . flush Bits ( ) ; } out . write UBits ( _ NUM , fill Bits ) ; out . write UBits ( _ NUM , line Bits ) ; }
public static <  T extends  Map .  Entry <  String ,  String > >  String form Encode (  Collection <  T > parameters ) throws  IOException {  Byte Array Output Stream b = new  Byte Array Output Stream ( ) ; form Encode ( parameters , b ) ; return new  String ( b . to Byte Array ( ) ) ; }
public void test_single Resource Locking_serialized_low Concurrency2 ( ) throws  Exception {  Properties properties = new  Properties ( ) ; properties . set Property (  Test Options .  NTHREADS , _ STR ) ; properties . set Property (  Test Options .  NTASKS , _ STR ) ; properties . set Property (  Test Options .  NRESOURCES , _ STR ) ; properties . set Property (  Test Options .  MIN_ LOCKS , _ STR ) ; properties . set Property (  Test Options .  MAX_ LOCKS , _ STR ) ; properties . set Property (  Test Options .  PREDECLARE_ LOCKS , _ STR ) ; properties . set Property (  Test Options .  SORT_ LOCK_ REQUESTS , _ STR ) ; do Comparison Test ( properties ) ; }
public void run Next Pending Command ( ) {  Runnable runnable = delta Queue . pop ( ) ; runnable . run ( ) ; }
private static  Document load Document (  Resource xml File ) throws  SAXException ,  IOException {  DOMParser parser = new  DOMParser ( ) ;  Input Stream is = null ; try { is =  IOUtil . to Buffered Input Stream ( xml File . get Input Stream ( ) ) ;  Input Source source = new  Input Source ( is ) ; parser . parse ( source ) ; } finally {  IOUtil . close EL ( is ) ; } return parser . get Document ( ) ; }
public static void prepare Unicode ( final  String Builder buffer , final  Byte Sequence sequence , final boolean trim , final boolean fold Case ) {  Reject . if Null ( buffer , sequence ) ; final int length = sequence . length ( ) ; for ( int i = _ NUM ; i < length ; i ++ ) { final byte b = sequence . byte At ( i ) ; if ( ( b & _ NUM ) != b ) {  Mapping Table . map ( buffer , sequence . sub Sequence ( i , length ) , trim , fold Case ) ;  String normalized Form =  Normalizer . normalize ( buffer ,  Form .  NFKD ) ; buffer . set Length ( _ NUM ) ; buffer . append ( normalized Form ) ; break ; } switch ( b ) { case _ STR : if ( can Map To Space ( buffer , trim ) ) { buffer . append ( _ STR ) ; } break ; default : if ( b >= _ STR && b < _ STR ) { if ( can Map To Space ( buffer , trim ) ) { buffer . append (  SPACE_ CHAR ) ; } } else if ( ( b >= _ STR && b <= _ STR ) || ( b >= _ STR && b <= _ STR ) || b == _ STR ) { break ; } else if ( fold Case && b >= _ STR && b <= _ STR ) { buffer . append ( ( char ) ( b + _ NUM ) ) ; } else { buffer . append ( ( char ) b ) ; } break ; } } if ( trim ) { for ( int i = buffer . length ( ) - _ NUM ; i > _ NUM ; i -- ) { if ( buffer . char At ( i ) ==  SPACE_ CHAR ) { buffer . delete ( i , i + _ NUM ) ; } else { break ; } } } }
public void test Case18 ( ) { byte a Bytes [ ] = { _ NUM } ; byte b Bytes [ ] = { _ NUM } ; byte r Bytes [ ] = { _ NUM } ; int a Sign = _ NUM ; int b Sign = _ NUM ;  Big Integer a Number = new  Big Integer ( a Sign , a Bytes ) ;  Big Integer b Number = new  Big Integer ( b Sign , b Bytes ) ;  Big Integer result = a Number . add ( b Number ) ; byte res Bytes [ ] = new byte [ r Bytes . length ] ; res Bytes = result . to Byte Array ( ) ; for ( int i = _ NUM ; i < res Bytes . length ; i ++ ) { assert True ( res Bytes [ i ] == r Bytes [ i ] ) ; } assert Equals ( _ STR , _ NUM , result . signum ( ) ) ; }
@  Nonnull public  Bug Instance add Class (  Class Node class Node ) {  String dotted Class Name =  Class Name . to Dotted Class Name ( class Node . name ) ;  Class Annotation class Annotation = new  Class Annotation ( dotted Class Name ) ; add ( class Annotation ) ; return this ; }
public static void try Format Satisfiability (  String format ) throws  Illegal Format Exception {  Message Format . format ( format , (  Object [ ] ) null ) ; }
public static int parse Upper Map (  String s ) throws  Number Format Exception { int upper Case =  MAP_ UNDEFINED ; int length = s . length ( ) ; if ( length >= _ NUM && length <= _ NUM ) { upper Case =  Integer . parse Int ( s , _ NUM ) ; } else if ( s . length ( ) != _ NUM ) { throw new  Number Format Exception ( ) ; } return upper Case ; }
@  Override public void run ( ) { while ( ! is Interrupted ( ) ) { try {  Reference ref = _queue . remove ( ) ; _entry Infos . remove ( ref ) ; } catch (  Interrupted Exception e ) { interrupt ( ) ; break ; } } }
private boolean is Valid Playlist Name (  String new Name ) {  Playlist blank Playlist = new  Playlist ( new Name , _ BOOL ) ; return ! new Name . is Empty ( ) && ! music Library . contains Playlist ( blank Playlist ) ; }
public  String import XML (  String file Name ,  Properties ctx ,  String trx Name ) throws  Exception { log . info ( _ STR + file Name ) ;  File in = new  File ( file Name ) ; if ( ! in . exists ( ) ) {  String msg = _ STR + file Name ; log . info ( _ STR + msg ) ; return msg ; } try { log . info ( _ STR ) ;  System . set Property ( _ STR , _ STR ) ;  Pack In Handler handler = new  Pack In Handler ( ) ; handler . set_ Trx Name ( trx Name ) ; handler . set Ctx ( ctx ) ; handler . set Process ( this ) ;  SAXParser Factory factory =  SAXParser Factory . new Instance ( ) ;  SAXParser parser = factory . new SAXParser ( ) ;  String msg = _ STR ; log . info ( msg ) ; parser . parse ( in , handler ) ; msg = _ STR ; log . info ( msg ) ; return _ STR ; } catch (  Exception e ) { log . log (  Level .  SEVERE , _ STR , e ) ; throw e ; } }
public synchronized void log Add Or Remove Row (  Session session , int table Id ,  Row row , boolean add ) { if ( log Mode !=  LOG_ MODE_ OFF ) { if ( ! recovery Running ) { log . log Add Or Remove Row ( session , table Id , row , add ) ; } } }
public org . smpte_ra . schemas . st2067_2_2016 .  Digest Method Type build Default Digest Method Type ( ) { org . smpte_ra . schemas . st2067_2_2016 .  Digest Method Type digest Method Type = new org . smpte_ra . schemas . st2067_2_2016 .  Digest Method Type ( ) ; digest Method Type . set Algorithm (  Composition Playlist Builder_2016 . default Hash Algorithm ) ; return digest Method Type ; }
public static <  V extends  Sampled Vertex >  Set <  V > create Sampled Partition (  Collection <  V > vertices ) {  Set <  V > partition = new  Hash Set <  V > ( ) ; for (  V vertex : vertices ) { if ( vertex . is Sampled ( ) ) partition . add ( vertex ) ; } return partition ; }
public  Gremlin Transaction Manager (  Gremlin Graph Factory graph Factory ) { super ( ) ; this . graph Factory = graph Factory ; }
public void shift Beans (  Bean Instance to Shift To , boolean save ) { if ( save ) { m_original Coords = new  Vector <  Point > ( ) ; } int target X = to Shift To . get X ( ) ; int target Y = to Shift To . get Y ( ) ; for ( int i = _ NUM ; i < m_sub Flow . size ( ) ; i ++ ) {  Bean Instance temp = (  Bean Instance ) m_sub Flow . element At ( i ) ; if ( save ) {  Point p = new  Point ( temp . get X ( ) - target X , temp . get Y ( ) - target Y ) ; m_original Coords . add ( p ) ; } temp . set X ( target X ) ; temp . set Y ( target Y ) ; } }
@  Override protected final  List <  Lat Long > do In Background ( final  Object ... args ) {  List <  Lat Long > points = new  Array List < > ( ) ;  Data Helper db Helper = new  Data Helper ( m Context ) ; final  Array List <  Position Record > positions = db Helper . load Positions ( (  Integer ) args [  SESSION_ ID ] , (  Double ) args [  MIN_ LAT_ COL ] , (  Double ) args [  MAX_ LAT_ COL ] , (  Double ) args [  MIN_ LON_ COL ] , (  Double ) args [  MAX_ LON_ COL ] ) ; for (  Position Record position : positions ) { points . add ( new  Lat Long ( position . get Latitude ( ) , position . get Longitude ( ) ) ) ; } return points ; }
public void make ( ) throws  Exception { for ( int i = _ NUM ; i < _make List . size ( ) ; i ++ ) {  Make make = _make List . get ( i ) ; make . make ( ) ; } }
@  Override void deleted Text (  Character Data Impl node , int offset , int count ) { if ( ranges != null ) { notify Ranges Deleted Text ( node , offset , count ) ; } }
private  Application Environment ( ) { try { if (  System . get Property (  Bootstrap Properties .  IS_ UBERJAR ) != null ) { this . mode =  Mode .  UBERJAR ; if ( ! load Wild Fly Swarm Application Manifest From Classpath ( ) ) { load Wild Fly Swarm Application Manifest From TCCL ( ) ; } } else { this . mode =  Mode .  CLASSPATH ; load Fraction Manifests From Classpath ( ) ; } } catch (  IOException e ) { throw new  Runtime Exception ( e ) ; } }
public  Producer Worker (  String topic ,  String message ) { this . _topic = topic ; this . _message = message ; }
private static boolean functions Are Allowed ( boolean is Add All Function , boolean is Put All Function ,  Class < ? > class D ,  Class < ? > class S ) { if ( is Add All Function ) return collection Is Assignable From ( class D ) && collection Is Assignable From ( class S ) ; if ( is Put All Function ) return map Is Assignable From ( class D ) && map Is Assignable From ( class S ) ; return is Assignable From ( class D , class S ) ; }
private void load Org Access User (  Array List <  Org Access > list ) {  Prepared Statement pstmt = null ;  Result Set rs = null ;  String sql = _ STR + _ STR ; try { pstmt =  DB . prepare Statement ( sql , get_ Trx Name ( ) ) ; pstmt . set Int ( _ NUM , get AD_ User_ ID ( ) ) ; rs = pstmt . execute Query ( ) ; while ( rs . next ( ) ) {  MUser Org Access oa = new  MUser Org Access ( get Ctx ( ) , rs , get_ Trx Name ( ) ) ; load Org Access Add ( list , new  Org Access ( oa . get AD_ Client_ ID ( ) , oa . get AD_ Org_ ID ( ) , oa . is Read Only ( ) ) ) ; } } catch (  Exception e ) { log . log (  Level .  SEVERE , sql , e ) ; } finally {  DB . close ( rs , pstmt ) ; } }
@  Override public void close ( ) throws  IOException {  Socket Channel s = _channel ; _channel = null ;  SSLSocket ssl Socket = _ssl Socket ; _ssl Socket = null ; if ( ssl Socket != null ) { try { ssl Socket . close ( ) ; } catch (  Exception e ) { } } if ( s != null ) { try { s . close ( ) ; } catch (  Exception e ) { } } }
public static  Vector3 D max (  Vector3 D a ,  Vector3 D b ) { return new  Vector3 D (  Fast Math . max ( a . get X ( ) , b . get X ( ) ) ,  Fast Math . max ( a . get Y ( ) , b . get Y ( ) ) ,  Fast Math . max ( a . get Z ( ) , b . get Z ( ) ) ) ; }
public static void wait For Process Output (  Process self ,  Output Stream output ,  Output Stream error ) {  Thread tout = consume Process Output Stream ( self , output ) ;  Thread terr = consume Process Error Stream ( self , error ) ; try { tout . join ( ) ; } catch (  Interrupted Exception ignore ) { } try { terr . join ( ) ; } catch (  Interrupted Exception ignore ) { } try { self . wait For ( ) ; } catch (  Interrupted Exception ignore ) { } close Streams ( self ) ; }
@  Override final  Node <  V > find ( int h , long k ) { for (  Node <  V > e = first ; e != null ; ) { int s ; if ( ( ( s = lock State ) & (  WAITER |  WRITER ) ) != _ NUM ) { if ( ( e . key == k ) ) { return e ; } e = e . next ; } else if (  U . compare And Swap Int ( this ,  LOCKSTATE , s , s +  READER ) ) {  Tree Node <  V > r ;  Tree Node <  V > p ; try { p = ( ( r = root ) == null ? null : r . find Tree Node ( h , k ) ) ; } finally {  Thread w ; if ( get And Add Int ( this ,  LOCKSTATE , -  READER ) == (  READER |  WAITER ) && ( w = waiter ) != null ) {  Lock Support . unpark ( w ) ; } } return p ; } } return null ; }
@  Override public  Axis State draw (  Graphics2 D g2 , double cursor ,  Rectangle2 D plot Area ,  Rectangle2 D data Area ,  Rectangle Edge edge ,  Plot Rendering Info plot State ) {  Axis State axis State = new  Axis State ( cursor ) ; if ( is Axis Line Visible ( ) ) { draw Axis Line ( g2 , cursor , data Area , edge ) ; } if ( is Tick Marks Visible ( ) ) { draw Tick Marks ( g2 , axis State , data Area , edge ) ; } if ( is Tick Labels Visible ( ) ) { for ( int band = _ NUM ; band < this . label Info . length ; band ++ ) { axis State = draw Tick Labels ( band , g2 , axis State , data Area , edge ) ; } } if ( get Attributed Label ( ) != null ) { axis State = draw Attributed Label ( get Attributed Label ( ) , g2 , plot Area , data Area , edge , axis State ) ; } else { axis State = draw Label ( get Label ( ) , g2 , plot Area , data Area , edge , axis State ) ; } return axis State ; }
private  Array List <  URLCrawl Datum > read Contents (  Path fetchlist ) throws  IOException {  Sequence File .  Reader reader = new  Sequence File .  Reader ( fs , fetchlist , conf ) ;  Array List <  URLCrawl Datum > l = new  Array List <  URLCrawl Datum > ( ) ;  READ : do {  Text key = new  Text ( ) ;  Crawl Datum value = new  Crawl Datum ( ) ; if ( ! reader . next ( key , value ) ) { break  READ ; } l . add ( new  URLCrawl Datum ( key , value ) ) ; } while ( _ BOOL ) ; reader . close ( ) ; return l ; }
public static  Color create Random Colour ( ) { float r = rand . next Float ( ) ; float g = rand . next Float ( ) ; float b = rand . next Float ( ) ;  Color random Color = new  Color ( r , g , b ) ; return random Color ; }
private static  Pair <  Diagnostic Kind ,  Boolean > parse Category String (  String category ) { final  String fixable = _ STR ; final boolean is Fixable = category . starts With ( fixable ) ; if ( is Fixable ) { category = category . substring ( fixable . length ( ) ) ; }  Diagnostic Kind category Enum =  Diagnostic Kind . from Parse String ( category ) ; return  Pair . of ( category Enum , is Fixable ) ; }
public void legacy Process (  Class clazz ,  Method m ,  Method Appearance Decision decision ) { if ( m . get Declaring Class ( ) !=  Object . class && m . get Return Type ( ) != void . class && m . get Parameter Types ( ) . length == _ NUM ) {  String m Name = m . get Name ( ) ; if ( ! looks Like Property Read Method ( m Name ) ) { decision . set Expose Method As ( null ) ; try { decision . set Expose As Property ( new  Property Descriptor ( m Name , clazz , m Name , null ) ) ; } catch (  Introspection Exception e ) { throw new  Runtime Exception ( e ) ; } } } }
public  SPTKPitch Reader Writer (  String lf0 SPTKFile , float window Size In Seconds , float skip Size In Seconds , int sampling Rate ) { contour = null ; header = new  Pitch File Header ( ) ; header . window Size In Seconds = window Size In Seconds ; header . skip Size In Seconds = skip Size In Seconds ; header . fs = sampling Rate ; try { contour = read SPTKF0 Data ( lf0 SPTKFile ) ; } catch (  IOException e ) { e . print Stack Trace ( ) ; } }
public void abort ( ) { clean Up ( ) ; if ( m Future != null ) { m Future . cancel ( _ BOOL ) ; m Future = null ; } if ( m Executor Service != null ) { m Executor Service . shutdown Now ( ) ; m Executor Service = null ; } m Listener = null ; }
public void add CSPState Listener (  CSPState Listener listener ) { listeners . add ( listener ) ; }
public static void print Wrapped Text ( final  Print Stream stream , final  String message ) { if ( stream != null && message != null && ! message . is Empty ( ) ) { stream . println ( wrap Text ( message ,  MAX_ LINE_ WIDTH ) ) ; } }
private synchronized  Rect [ ] compute Bounding Boxes ( ) { if ( ! bounding Boxes . is Present ( ) ) {  Rect [ ] bb = new  Rect [ ( int ) contours . size ( ) ] ; for ( int i = _ NUM ; i < contours . size ( ) ; i ++ ) { bb [ i ] = bounding Rect ( contours . get ( i ) ) ; } bounding Boxes =  Optional . of ( bb ) ; } return bounding Boxes . get ( ) ; }
public void add Timeline ( final  JSONObject timeline ) {  Timeline Channel . notify Timeline ( timeline ) ; timelines . add First ( timeline ) ; final int max Cnt =  Symphonys . get Int ( _ STR ) ; if ( timelines . size ( ) > max Cnt ) { timelines . remove ( max Cnt ) ; } }
private boolean load LOBData ( ) { if ( is Store Attachments On File System ) { return load LOBData From File System ( ) ; } return load LOBData From DB ( ) ; }
public static <  T >  List <  T > copy To Array List With Extra Capacity (  T [ ] elements , int extra Capacity ) {  List <  T > as List ; if ( elements != null ) { as List = new  Array List <  T > ( elements . length + extra Capacity ) ; as List . add All (  Arrays . as List ( elements ) ) ; } else { as List = new  Array List <  T > ( extra Capacity ) ; } return as List ; }
private boolean send Event To Listeners (  Cluster Event event ) { boolean success = _ BOOL ; for (  String listener Id :  Collections . unmodifiable Set ( listeners . key Set ( ) ) ) { logger . debug ( _ STR , listener Id , event . get Type ( ) , instance Id ) ;  Cluster Event Listener listener = listeners . get ( listener Id ) ; if ( listener != null && ! listener . handle Event ( event ) ) { success = _ BOOL ; } } return success ; }
@  Request Mapping ( method =  Request Method .  PUT , value = _ STR , consumes = {  Media Type .  APPLICATION_ JSON_ VALUE } , produces = {  Media Type .  APPLICATION_ JSON_ VALUE } ) @  Api Operation ( value = _ STR , notes = _ STR + _ STR + _ STR , response = void . class ) @  Api Responses ( { @  Api Response ( code = _ NUM , message = _ STR ) , @  Api Response ( code = _ NUM , message = _ STR ) , @  Api Response ( code = _ NUM , message = _ STR ) , @  Api Response ( code = _ NUM , message = _ STR ) , @  Api Response ( code = _ NUM , message = _ STR ) , @  Api Response ( code = _ NUM , message = _ STR ) , @  Api Response ( code = _ NUM , message = _ STR ) } ) @  Pre Authorize ( _ STR ) public  Response Entity < ? > update ( @  Path Variable ( _ STR )  String region , @  Path Variable ( _ STR ) final  String [ ] keys , @  Request Param ( value = _ STR , default Value = _ STR ) final  String op Value , @  Request Body final  String json ) { logger . debug ( _ STR , region ) ; region = decode ( region ) ; if ( keys . length > _ NUM ) { return update Multiple Keys ( region , keys , json ) ; } else { return update Single Key ( region , keys [ _ NUM ] , json , op Value ) ; } }
public void load (  X509 Extension extensions ) {  Set <  String > crit Exts = extensions . get Critical Extension OIDs ( ) ;  Set <  String > non Crit Exts = extensions . get Non Critical Extension OIDs ( ) ;  List <  X509 Ext > sorted Exts = new  Array List <  X509 Ext > ( ) ; for (  Iterator <  String > itr = crit Exts . iterator ( ) ; itr . has Next ( ) ; ) {  String ext Oid = itr . next ( ) ; byte [ ] value = extensions . get Extension Value ( ext Oid ) ;  X509 Ext ext = new  X509 Ext ( new  ASN1 Object Identifier ( ext Oid ) , value , _ BOOL ) ; sorted Exts . add ( ext ) ; } for (  Iterator <  String > itr = non Crit Exts . iterator ( ) ; itr . has Next ( ) ; ) {  String ext Oid = itr . next ( ) ; byte [ ] value = extensions . get Extension Value ( ext Oid ) ;  X509 Ext ext = new  X509 Ext ( new  ASN1 Object Identifier ( ext Oid ) , value , _ BOOL ) ; sorted Exts . add ( ext ) ; }  Collections . sort ( sorted Exts , new  Extension Name Comparator ( ) ) ; data = new  Object [ sorted Exts . size ( ) ] [ _ NUM ] ; int i = _ NUM ; for (  Iterator <  X509 Ext > itr Sorted Exts = sorted Exts . iterator ( ) ; itr Sorted Exts . has Next ( ) ; ) {  X509 Ext ext = itr Sorted Exts . next ( ) ; load Row ( ext , i ) ; i ++ ; } fire Table Data Changed ( ) ; }
public  Builder delete Addresses ( ) { delete Fields . add ( _ STR ) ; return this ; }
public  Query limit ( int limit ) { return limit ( limit < _ NUM ?  NO_ LIMIT :  Field . <  Integer > field (  Integer . to String ( limit ) ) ) ; }
public static boolean file Exists (  String f Name ) { boolean result = _ BOOL ;  File file = new  File ( f Name ) ; if ( file != null ) { result = file . exists ( ) && file . is File ( ) ; } return result ; }
private static void _init ( ) { add Method ( _ STR , new com . earth2me . essentials . register . payment . methods . i Co6 ( ) ) ; add Method ( _ STR , new com . earth2me . essentials . register . payment . methods . i Co5 ( ) ) ; add Method ( _ STR , new com . earth2me . essentials . register . payment . methods .  BOSE7 ( ) ) ; add Method ( _ STR , new com . earth2me . essentials . register . payment . methods .  MCUR ( ) ) ;  Dependencies . add ( _ STR ) ; add Method ( _ STR , new com . earth2me . essentials . register . payment . methods .  Vault Eco ( ) ) ; }
public static  String convert File Name (  String name , int max Bytes ) { try { return convert File Name ( name , max Bytes ,  Charset . default Charset ( ) ) ; } catch (  Character Coding Exception cce ) { try { return convert File Name ( name , max Bytes ,  Charset . for Name ( _ STR ) ) ; } catch (  Character Coding Exception e ) { throw new  Runtime Exception ( _ STR + name , e ) ; } } }
public static void copy (  URL url ,  File file ) throws  IOException {  Input Stream is = url . open Stream ( ) ; try {  Output Stream os = new  File Output Stream ( file ) ; try { byte [ ] buffer = new byte [ _ NUM ] ; int read ; while ( ( read = is . read ( buffer ) ) > _ NUM ) { os . write ( buffer , _ NUM , read ) ; } } finally { os . close ( ) ; } } finally { is . close ( ) ; } }
public void create Auth Configuration (  String name ) throws  AMConsole Exception { if ( ( name == null ) || ( name . length ( ) == _ NUM ) ) { throw new  AMConsole Exception ( get Localized String ( _ STR ) ) ; }  String [ ] params = { current Realm , name } ; log Event ( _ STR , params ) ;  String error Msg = null ; try {  AMAuth Config Utils . create Named Config ( name , _ NUM , new  Hash Map ( ) , current Realm , get User SSOToken ( ) ) ; log Event ( _ STR , params ) ; } catch (  SMSException e ) { error Msg = get Error String ( e ) ;  String [ ] params Ex = { current Realm , name , error Msg } ; log Event ( _ STR , params Ex ) ; debug . warning ( _ STR , e ) ; } catch (  SSOException e ) { error Msg = get Error String ( e ) ;  String [ ] params Ex = { current Realm , name , error Msg } ; log Event ( _ STR , params Ex ) ; debug . warning ( _ STR , e ) ; } catch (  AMConfiguration Exception e ) { error Msg = get Error String ( e ) ;  String [ ] params Ex = { current Realm , name , error Msg } ; log Event ( _ STR , params Ex ) ; debug . warning ( _ STR , e ) ; } if ( error Msg != null ) { throw new  AMConsole Exception ( error Msg ) ; } }
public  Writable Raster create Writable Child ( int x , int y , int width , int height , int x0 , int y0 , int [ ] band List ) { if ( x < this . min X ) { throw new  Raster Format Exception ( _ STR ) ; } if ( y < this . min Y ) { throw new  Raster Format Exception ( _ STR ) ; } if ( ( x + width < x ) || ( x + width > this . min X + this . width ) ) { throw new  Raster Format Exception ( _ STR ) ; } if ( ( y + height < y ) || ( y + height > this . min Y + this . height ) ) { throw new  Raster Format Exception ( _ STR ) ; }  Sample Model sm ; if ( band List != null ) { sm = sample Model . create Subset Sample Model ( band List ) ; } else { sm = sample Model ; } int delta X = x0 - x ; int delta Y = y0 - y ; return new  Byte Packed Raster ( sm , data Buffer , new  Rectangle ( x0 , y0 , width , height ) , new  Point ( sample Model Translate X + delta X , sample Model Translate Y + delta Y ) , this ) ; }
private void send Buffer ( ) throws  IOException { buf . flip ( ) ; send ( buf , buf . remaining ( ) ) ; buf = null ; }
public void call Event (  Event event ) { if ( event . is Asynchronous ( ) ) { if (  Thread . holds Lock ( this ) ) { throw new  Illegal State Exception ( event . get Event Name ( ) + _ STR ) ; } if ( server . is Primary Thread ( ) ) { throw new  Illegal State Exception ( event . get Event Name ( ) + _ STR ) ; } fire Event ( event ) ; } else { synchronized ( this ) { fire Event ( event ) ; } } }
@  Nullable private static  Psi File find File To Open ( @  Not Null  List <  Psi File > files ) {  Psi File best File = null ;  Folder Configuration best Config = null ; for (  Psi File file : files ) {  Psi Directory qualified Directory = file . get Parent ( ) ; assert qualified Directory != null : _ STR ;  Folder Configuration config =  Folder Configuration . get Config For Folder ( qualified Directory . get Name ( ) ) ; if ( best Config == null || config == null || config . compare To ( best Config ) < _ NUM ) { best Config = config ; best File = file ; } } return best File ; }
protected boolean are Equal (  String string1 ,  String string2 , boolean case Matters ) { return ( case Matters && string1 . equals ( string2 ) ) || ( ! case Matters && string1 . equals Ignore Case ( string2 ) ) ; }
protected void populate Blob ( int id , byte [ ] base Content , int required Size ) throws  SQLException {  Connection con = get Connection Via Driver Manager ( ) ;  Callable Statement cstmt = null ; try { cstmt = con . prepare Call (  EXECUTE_ FILL_ BINARY_ BLOB ) ; cstmt . set Int ( _ NUM , id ) ; cstmt . set Bytes ( _ NUM , base Content ) ; cstmt . set Int ( _ NUM , required Size ) ; cstmt . execute ( ) ; } finally { close Quietly ( cstmt ) ; close Quietly ( con ) ; } }
public void make Immutable ( ) { if ( mutable ) { if ( results != null ) { int length = results . size ( ) ; for ( int i = _ NUM ; i < length ; i ++ ) {  Result result = (  Result ) results . get ( i ) ; result . make Immutable ( ) ; } results =  Collections . unmodifiable List ( results ) ; } mutable = _ BOOL ; } }
public  Statement is Null ( ) { statement . append ( _ STR ) ; return this ; }
public void clear ( ) { process Queue ( ) ; hash . clear ( ) ; }
private void update Favorite Station ( ) {  String show String = null ; if (  Fm Radio Station . is Favorite Station ( m Context , m Current Station ) ) {  String station Name =  Fm Radio Station . get Station Name ( m Context , m Current Station ,  Fm Radio Station .  STATION_ TYPE_ FAVORITE ) ;  Fm Radio Station . update Station To Db ( m Context , station Name ,  Fm Radio Station .  STATION_ TYPE_ SEARCHED , m Current Station ) ; m Button Add To Favorite . set Image Resource (  R . drawable . btn_fm_favorite_off_selector ) ; m Text Station Name . set Text ( _ STR ) ; show String = m Project String Ext . get Project String ( m Context ,  R . string . toast_channel_deleted ,  R . string . toast_channel_deleted1 ) ; } else {  String station Name =  Fm Radio Station . get Station Name ( m Context , m Current Station ,  Fm Radio Station .  STATION_ TYPE_ SEARCHED ) ; if (  Fm Radio Station . is Station Exist ( m Context , m Current Station ,  Fm Radio Station .  STATION_ TYPE_ SEARCHED ) ) {  Fm Radio Station . update Station To Db ( m Context , station Name ,  Fm Radio Station .  STATION_ TYPE_ FAVORITE , m Current Station ) ; } else {  Fm Radio Station . insert Station To Db ( m Context , station Name , m Current Station ,  Fm Radio Station .  STATION_ TYPE_ FAVORITE ) ; } m Button Add To Favorite . set Image Resource (  R . drawable . btn_fm_favorite_on_selector ) ; m Text Station Name . set Text ( station Name ) ; show String = m Project String Ext . get Project String ( m Context ,  R . string . toast_channel_added ,  R . string . toast_channel_added1 ) ; } show Toast ( show String ) ; }
public int add All Absent (  Collection < ? extends  E > c ) {  Object [ ] cs = c . to Array ( ) ; if ( cs . length == _ NUM ) return _ NUM ; final  Reentrant Lock lock = this . lock ; lock . lock ( ) ; try {  Object [ ] elements = get Array ( ) ; int len = elements . length ; int added = _ NUM ; for ( int i = _ NUM ; i < cs . length ; ++ i ) {  Object e = cs [ i ] ; if ( index Of ( e , elements , _ NUM , len ) < _ NUM && index Of ( e , cs , _ NUM , added ) < _ NUM ) cs [ added ++ ] = e ; } if ( added > _ NUM ) {  Object [ ] new Elements =  Arrays . copy Of ( elements , len + added ) ;  System . arraycopy ( cs , _ NUM , new Elements , len , added ) ; set Array ( new Elements ) ; } return added ; } finally { lock . unlock ( ) ; } }
public  Iterator <  Capability > dependencies ( ) { return m_ Dependencies . iterator ( ) ; }
public static void notify Ticket (  Context c , @  Non Null  Ticket t , boolean keep Notification ) {  String text ;  String ticker ; int small Icon ; int large Icon ; int status ; switch (  Tickets Adapter . get Validity Status ( t . get Status ( ) , t . get Valid To ( ) ) ) { case  Ticket Provider .  Tickets .  STATUS_ VALID : case  Ticket Provider .  Tickets .  STATUS_ VALID_ EXPIRING : text = c . get String (  R . string . notif_valid_text ,  Format Util . format Date Time Difference ( t . get Valid To ( ) ) ) ; ticker = c . get String (  R . string . notif_valid_ticker ) ; small Icon =  R . drawable . notification_small_ready ; large Icon =  R . drawable . notification_big_ready ; status =  Ticket Provider .  Tickets .  STATUS_ VALID_ EXPIRING ; break ; case  Ticket Provider .  Tickets .  STATUS_ EXPIRING : case  Ticket Provider .  Tickets .  STATUS_ EXPIRING_ EXPIRED : text = c . get String (  R . string . notif_expiring_text ,  Format Util . format Time ( t . get Valid To ( ) ) ) ; ticker = c . get String (  R . string . notif_expiring_ticker ) ; small Icon =  R . drawable . notification_small_warning ; large Icon =  R . drawable . notification_big_warning ; status =  Ticket Provider .  Tickets .  STATUS_ EXPIRING_ EXPIRED ; break ; case  Ticket Provider .  Tickets .  STATUS_ EXPIRED : text = c . get String (  R . string . notif_expired_text ,  Format Util . format Time ( t . get Valid To ( ) ) ) ; ticker = c . get String (  R . string . notif_expired_ticker ) ; small Icon =  R . drawable . notification_small_expired ; large Icon =  R . drawable . notification_big_expired ; status =  Ticket Provider .  Tickets .  STATUS_ EXPIRED ; break ; default : return ; }  Intent intent = new  Intent ( c ,  Wearable Service . class ) ; intent . set Action ( _ STR ) ; intent . put Extra ( _ STR , t ) ; intent . put Extra ( _ STR , status ) ; c . start Service ( intent ) ;  Intent i = new  Intent ( c ,  Main Activity . class ) ; i . add Flags (  Intent .  FLAG_ ACTIVITY_ SINGLE_ TOP |  Intent .  FLAG_ ACTIVITY_ CLEAR_ TOP ) ; i . put Extra (  Main Activity .  EXTRA_ TICKET_ ID , t . get Id ( ) ) ;  Pending Intent open Intent =  Pending Intent . get Activity ( c , t . get Notification Id ( ) , i ,  Pending Intent .  FLAG_ CANCEL_ CURRENT ) ;  Intent i2 = new  Intent ( c ,  Main Activity . class ) ; i2 . add Flags (  Intent .  FLAG_ ACTIVITY_ SINGLE_ TOP |  Intent .  FLAG_ ACTIVITY_ CLEAR_ TOP ) ; i2 . put Extra (  Main Activity .  EXTRA_ TICKET_ ID , t . get Id ( ) ) ; i2 . put Extra (  Main Activity .  EXTRA_ SHOW_ SMS , _ BOOL ) ;  Pending Intent show Sms Intent =  Pending Intent . get Activity ( c , t . get Notification Id ( ) + _ NUM , i2 ,  Pending Intent .  FLAG_ CANCEL_ CURRENT ) ;  List <  Action > actions = new  Array List <  Action > ( ) ; actions . add ( new  Action (  R . drawable . notification_show_sms ,  R . string . notif_show_sms , show Sms Intent ) ) ;  List <  String > rows = new  Array List <  String > ( ) ; rows . add ( text ) ; rows . add ( c . get String (  R . string . tickets_valid_from ) + _ STR +  Format Util . format Date Time ( t . get Valid From ( ) ) ) ; rows . add ( c . get String (  R . string . tickets_code ) + _ STR + t . get Hash ( ) ) ; fire Notification ( c , t . get Notification Id ( ) , open Intent , c . get String (  R . string . application_name ) , text , rows , t . get City ( ) , ticker , small Icon , large Icon , actions , keep Notification ) ; }
public final static int parse Int (  String str ) { char c = str . char At ( _ NUM ) ; int length = str . length ( ) ; boolean negative = ( c == _ STR ) ; int offset = _ NUM ; if ( negative ) { if ( length == _ NUM || length > _ NUM ) { return  Integer . parse Int ( str ) ; } c = str . char At ( offset ++ ) ; } else { if ( length > _ NUM ) { return  Integer . parse Int ( str ) ; } } if ( c > _ STR || c < _ STR ) { return  Integer . parse Int ( str ) ; } int num = c - _ STR ; if ( offset < length ) { c = str . char At ( offset ++ ) ; if ( c > _ STR || c < _ STR ) { return  Integer . parse Int ( str ) ; } num = ( num * _ NUM ) + ( c - _ STR ) ; if ( offset < length ) { c = str . char At ( offset ++ ) ; if ( c > _ STR || c < _ STR ) { return  Integer . parse Int ( str ) ; } num = ( num * _ NUM ) + ( c - _ STR ) ; if ( offset < length ) { do { c = str . char At ( offset ++ ) ; if ( c > _ STR || c < _ STR ) { return  Integer . parse Int ( str ) ; } num = ( num * _ NUM ) + ( c - _ STR ) ; } while ( offset < length ) ; } } } return negative ? - num : num ; }
@  Deprecated public static <  T >  T execute With Back Off (  Abstract Google Client Request <  T > client ,  String error ,  Object ... error Args ) throws  IOException ,  Interrupted Exception { return execute With Back Off ( client ,  String . format ( error , error Args ) ) ; }
private void check Server Response Code (  Http URLConnection url Connection ) throws  Request Failure Exception { try { if ( url Connection . get Response Code ( ) != _ NUM ) { throw new  Request Failure Exception ( _ STR + url Connection . get Response Code ( ) + _ STR ) ; } } catch (  IOException e ) { throw new  Request Failure Exception ( _ STR , e ) ; } }
public static void add Resource Source (  Resource Source source ) {  ALL_ RESOURCE_ SOURCES . add ( source ) ; }
private void commit Changes ( ) { hopfield Props Panel . commit Changes ( ) ; input Panel . commit Changes ( ) ; }
private boolean connect_to_target (  Pla Point Int p_from_point ) { if ( nearest_target_item != null && target_set != null && ! target_set . contains ( nearest_target_item ) ) { nearest_target_item = null ; } if ( nearest_target_item == null || ! nearest_target_item . shares_net_no ( net_nos ) ) { return _ BOOL ; } boolean route_completed = _ BOOL ;  Pla Point Int connection_point = null ; if ( nearest_target_item instanceof  Brd Abit ) {  Brd Abit target = (  Brd Abit ) nearest_target_item ; connection_point = target . center_get ( ) ; } else if ( nearest_target_item instanceof  Brd Tracep ) { return r_board . connect_to_trace ( p_from_point , (  Brd Tracep ) nearest_target_item , pen_half_width_arr [ layer_active_no ] , clearance_class ) ; } else if ( nearest_target_item instanceof  Brd Area Conduction ) { connection_point = p_from_point ; } if ( connection_point != null ) { route_completed = itera_connect ( p_from_point , connection_point ) ; } return route_completed ; }
public boolean on Generic Motion Event (  Motion Event ev ) { if ( ( ev . get Source ( ) &  Input Device .  SOURCE_ CLASS_ POINTER ) ==  Input Device .  SOURCE_ CLASS_ POINTER ) { int action = ev . get Action ( ) ; switch ( action &  Motion Event .  ACTION_ MASK ) { case  Motion Event .  ACTION_ SCROLL : float v Scroll = ev . get Axis Value (  Motion Event .  AXIS_ VSCROLL ) ; if ( v Scroll > _ NUM ) { if ( m Deck View . ensure Focused Task ( ) ) { m Deck View . focus Next Task ( _ BOOL , _ BOOL ) ; } } else { if ( m Deck View . ensure Focused Task ( ) ) { m Deck View . focus Next Task ( _ BOOL , _ BOOL ) ; } } return _ BOOL ; } } return _ BOOL ; }
public boolean add Class (  Owl Class target Class ) { target Class . add QCRestriction ( this ) ; return qc Classes . add ( target Class ) ; }
public void edit Element ( final  Object element , final  String column Property Name ) { final int column Index =  Table Viewer Utils . column Property Name To Column Index ( column Property Name , _ BOOL , viewer ) ; viewer . edit Element ( element , column Index ) ; }
@  Override public boolean use Buffer Per Window ( ) { return !  Win32 Graphics Environment . is DWMComposition Enabled ( ) ; }
private void serializable ( final  Isolation Levels level ) throws  Exception { clear ( store ) ; final  Value Factory vf = store . get Value Factory ( ) ; final  IRI subj = vf . create IRI ( _ STR ) ; final  IRI pred = vf . create IRI ( _ STR ) ;  Repository Connection prep = store . get Connection ( ) ; try { prep . begin ( level ) ; prep . add ( subj , pred , vf . create Literal ( _ NUM ) ) ; prep . commit ( ) ; } finally { prep . close ( ) ; } final  Count Down Latch start = new  Count Down Latch ( _ NUM ) ; final  Count Down Latch observed = new  Count Down Latch ( _ NUM ) ;  Thread t1 = increment By ( start , observed , level , vf , subj , pred , _ NUM ) ;  Thread t2 = increment By ( start , observed , level , vf , subj , pred , _ NUM ) ; t2 . start ( ) ; t1 . start ( ) ; t2 . join ( ) ; t1 . join ( ) ; assert Not Failed ( ) ;  Repository Connection check = store . get Connection ( ) ; try { check . begin ( level ) ;  Literal lit = read Literal ( check , subj , pred ) ; int val = lit . int Value ( ) ; if ( val != _ NUM && val != _ NUM ) { assert Equals ( _ NUM , val ) ; } check . commit ( ) ; } finally { check . close ( ) ; } }
public static  Array list To Array Remove Empty (  String list , char delimiter ) { int len = list . length ( ) ;  Array Impl array = new  Array Impl ( ) ; if ( len == _ NUM ) return array ; int last = _ NUM ; for ( int i = _ NUM ; i < len ; i ++ ) { if ( list . char At ( i ) == delimiter ) { if ( last < i ) array . _append ( list . substring ( last , i ) ) ; last = i + _ NUM ; } } if ( last < len ) array . _append ( list . substring ( last ) ) ; return array ; }
public static <  T extends  Object & java . lang .  Comparable < ? super  T > >  T min (  Collection < ? extends  T > collection ) {  Iterator < ? extends  T > it = collection . iterator ( ) ;  T min = it . next ( ) ; while ( it . has Next ( ) ) {  T next = it . next ( ) ; if ( min . compare To ( next ) > _ NUM ) { min = next ; } } return min ; }
@  Override public  Server Heartbeat server (  String address , int port , boolean is SSL ,  String cluster Id ,  String display Name , boolean is Dynamic ) {  Objects . require Non Null ( address ) ;  Objects . require Non Null ( cluster Id ) ; if ( address . is Empty ( ) ) { address = _ STR ; }  Cluster Heartbeat cluster = create Cluster ( cluster Id ) ;  Server Heartbeat server ; if ( is Dynamic ) { server = cluster . create Dynamic Server ( address , port , is SSL ) ; } else { server = cluster . create Server ( address , port , is SSL ) ; } if ( display Name != null ) { server . set Display Name ( display Name ) ; } if ( ! is Dynamic ) { cluster . add Seed Server ( server ) ; } return server ; }
public void test To String ( ) {  Linked Blocking Queue q = populated Queue (  SIZE ) ;  String s = q . to String ( ) ; for ( int i = _ NUM ; i <  SIZE ; ++ i ) { assert True ( s . index Of (  String . value Of ( i ) ) >= _ NUM ) ; } }
private void find Club ( ) { if ( ce ( ) == null ) { return ; }  String title =  Messages . get String ( _ STR ) ;  String body =  Messages . get String ( _ STR ) ; if ( ! clientgui . do Yes No Dialog ( title , body ) ) { return ; } attacks . remove All Elements ( ) ; attacks . add Element ( new  Find Club Action ( cen ) ) ; ready ( ) ; }
public void test_allocation Contexts ( ) throws  IOException { final  Journal store = (  Journal ) get Store ( ) ; try { final  RWStrategy bs = (  RWStrategy ) store . get Buffer Strategy ( ) ; final  RWStore rw = bs . get Store ( ) ; final  IAllocation Context alloc Context1 = rw . new Allocation Context ( _ BOOL ) ; final  IAllocation Context alloc Context2 = rw . new Allocation Context ( _ BOOL ) ; final int sze = _ NUM ; final byte [ ] buf = new byte [ sze + _ NUM ] ; r . next Bytes ( buf ) ; final long addr1a = bs . write (  Byte Buffer . wrap ( buf ) , alloc Context1 ) ; final long addr1b = bs . write (  Byte Buffer . wrap ( buf ) , alloc Context1 ) ; rw . detach Context ( alloc Context1 ) ; final long addr2a = bs . write (  Byte Buffer . wrap ( buf ) , alloc Context2 ) ; final long addr2b = bs . write (  Byte Buffer . wrap ( buf ) , alloc Context2 ) ; rw . detach Context ( alloc Context2 ) ; try { bs . write (  Byte Buffer . wrap ( buf ) , alloc Context1 ) ; fail ( _ STR ) ; } catch (  Illegal State Exception ise ) { } final  IAllocation Context alloc Context3 = rw . new Allocation Context ( _ BOOL ) ; final long addr1c = bs . write (  Byte Buffer . wrap ( buf ) , alloc Context3 ) ; assert True ( _ STR , bs . get Physical Address ( addr1c ) > bs . get Physical Address ( addr2b ) ) ; bs . delete ( addr1c , alloc Context3 ) ; final long addr1d = bs . write (  Byte Buffer . wrap ( buf ) , alloc Context3 ) ; assert True ( _ STR , addr1c == addr1d ) ; rw . detach Context ( alloc Context3 ) ; store . commit ( ) ; bs . delete ( addr1d ) ; final long addr1e = bs . write (  Byte Buffer . wrap ( buf ) ) ; assert True ( _ STR , addr1e != addr1d ) ; store . commit ( ) ; } finally { store . destroy ( ) ; } }
public  PDFXref ( byte [ ] line ) { if ( line == null ) { id = - _ NUM ; generation = - _ NUM ; } else { id =  Integer . parse Int ( new  String ( line , _ NUM , _ NUM ) ) ; generation =  Integer . parse Int ( new  String ( line , _ NUM , _ NUM ) ) ; } compressed = _ BOOL ; }
public static  String [ ] make Strings (  Collection <  Inet Address > addrs ) {  String [ ] result = new  String [ addrs . size ( ) ] ; int i = _ NUM ; for (  Inet Address addr : addrs ) { result [ i ++ ] = addr . get Host Address ( ) ; } return result ; }
public static void show Profile (  Activity activity ,  String pilot Id , @  Nullable  Hash Map <  String ,  String > extras ) { if ( ( pilot Id == null || pilot Id . is Empty ( ) ) &&  Air Map . has Valid Authenticated User ( ) ) { pilot Id =  Air Map . get User Id ( ) ; }  Intent intent = new  Intent ( activity ,  Profile Activity . class ) ; intent . put Extra (  Profile Activity .  ARG_ PILOT_ ID , pilot Id ) ; if ( extras != null ) { intent . put Extra (  Create Flight Activity .  KEY_ VALUE_ EXTRAS , extras ) ; } activity . start Activity ( intent ) ; }
public  Smooth Moves ( ) { cycle Start =  System . nano Time ( ) / _ NUM ; start Timer ( current Resolution ) ; }
public static void update Price Lists (  Properties ctx ,  Product Bean product Bean ,  String trx Name ) throws  Operation Exception {  Array List <  Product Bean > list = product Bean . get Product Bean List ( ) ; if ( list != null ) { int product Id = product Bean . get Product Id ( ) ;  Iterator <  Product Bean > iter = list . iterator ( ) ; while ( iter . has Next ( ) ) {  Product Bean bean = iter . next ( ) ; int price List Id = bean . get Price List Id ( ) ;  Big Decimal std Price = bean . get Std Price ( ) ;  Big Decimal list Price = bean . get List Price ( ) ;  Big Decimal limit Price = bean . get Limit Price ( ) ;  MPrice List price List =  MPrice List . get ( ctx , price List Id , trx Name ) ; if ( price List . is Tax Included ( ) ) { std Price = bean . get Std Price Incl ( ) ; list Price = bean . get List Price Incl ( ) ; limit Price = bean . get Limit Price Incl ( ) ; } update Price Lists ( ctx , product Id , price List Id , std Price , list Price , limit Price , trx Name ) ; } } }
private  String check Dependencies (  Module Descriptor md ,  Hash Map <  String ,  Module Descriptor > modlist ) { logger . debug ( _ STR + md . get Id ( ) ) ;  Module Interface [ ] requires = md . get Requires ( ) ; if ( requires != null ) { for (  Module Interface req : requires ) {  String res = check One Dependency ( md , req , modlist ) ; if ( ! res . is Empty ( ) ) { return res ; } } } return _ STR ; }
public void deserialize Funnel (  List <  Object > serialized Funnel ) {  Set <  Object > funnel Step Accumulator = new  Hash Set < > ( ) ; for (  Object e : serialized Funnel ) { if ( e != null ) { funnel Step Accumulator . add ( e ) ; } else { funnel Steps . add ( new  Hash Set < > ( funnel Step Accumulator ) ) ; funnel Step Accumulator . clear ( ) ; } } }
public static  String append Parameter (  Ct Class type ,  String descriptor ) { int i = descriptor . index Of ( _ STR ) ; if ( i < _ NUM ) return descriptor ; else {  String Buffer newdesc = new  String Buffer ( ) ; newdesc . append ( descriptor . substring ( _ NUM , i ) ) ; to Descriptor ( newdesc , type ) ; newdesc . append ( descriptor . substring ( i ) ) ; return newdesc . to String ( ) ; } }
public void add Catch Clause (  Catch Clause clause ) { assert Not Null ( clause ) ; if ( catch Clauses == null ) { catch Clauses = new  Array List <  Catch Clause > ( ) ; } catch Clauses . add ( clause ) ; clause . set Parent ( this ) ; }
public static void stream Content To Browser (  Http Servlet Response response , byte [ ] bytes ,  String content Type ,  String file Name ) throws  IOException { set Response Browser Proxy No Cache ( response ) ; response . set Content Length ( bytes . length ) ; if ( content Type != null ) { response . set Content Type ( content Type ) ; } if ( file Name != null ) { response . set Header ( _ STR , _ STR + file Name + _ STR ) ; }  Output Stream out = response . get Output Stream ( ) ;  Input Stream in = new  Byte Array Input Stream ( bytes ) ; try { stream Content ( out , in , bytes . length ) ; } catch (  IOException e ) { in . close ( ) ; out . close ( ) ; throw e ; } in . close ( ) ; out . flush ( ) ; out . close ( ) ; }
public void unlock (  Object key ) {  String uid =  String . value Of ( key ) ;  Transaction tr = locked UIDHash Map . get ( uid ) ; if ( tr == null ) { return ; } try { tr . commit ( ) ; } catch (  Exception e ) { logger . warn ( _ STR , e ) ; } finally { locked UIDHash Map . remove ( uid ) ; } }
public  List <  Order > fetch Orders ( int start Index , int num ) { int end Index = start Index + num > orders . size ( ) ? orders . size ( ) : start Index + num ; return orders . sub List ( start Index , end Index ) ; }
public boolean ensure Schema Agreement ( ) { long start =  System . current Time Millis ( ) ;  Map <  String ,  List <  String > > schemas = null ; while (  System . current Time Millis ( ) - start <  Db Client Context .  MAX_ SCHEMA_ WAIT_ MS ) { try { log . info ( _ STR ,  Db Client Context .  SCHEMA_ RETRY_ SLEEP_ MILLIS / _ NUM ) ;  Thread . sleep (  Db Client Context .  SCHEMA_ RETRY_ SLEEP_ MILLIS ) ; } catch (  Interrupted Exception ex ) { log . warn ( _ STR ) ; } schemas = get Schema Versions ( ) ; if ( schemas . size ( ) > _ NUM ) { continue ; } if ( schemas . size ( ) == _ NUM ) { if ( ! schemas . contains Key (  Storage Proxy .  UNREACHABLE ) ) { return _ BOOL ; } else { continue ; } } if ( schemas . contains Key (  Storage Proxy .  UNREACHABLE ) ) { return _ BOOL ; } } log . error ( _ STR , schemas ) ; throw new  Illegal State Exception ( _ STR ) ; }
void clear ( ) { stack . clear ( ) ; }
private  Tile Store ( final  Sprite Store store ) { this . store = store ; tiles = new  Array List <  Sprite > ( ) ; tiles . add ( store . get Empty Sprite ( ) ) ; }
public static  String comparable Qualifier (  String qualifier ) { int i = _ QUALIFIERS . index Of ( qualifier ) ; return i == - _ NUM ? _ QUALIFIERS . size ( ) + _ STR + qualifier :  String . value Of ( i ) ; }
public static  Object evaluate (  Object context ,  Object self ,  String expr ,  List <  String > engine Configs ) throws  CWLExpression Exception {  String trimmed Expr =  String Utils . trim ( expr ) ; if ( trimmed Expr . starts With ( _ STR ) ) { trimmed Expr = trimmed Expr . substring ( _ NUM ) ; }  String function = trimmed Expr ; if ( trimmed Expr . starts With ( _ STR ) ) { function = _ STR ; function = function . replace ( _ STR , trimmed Expr ) ; }  Context cx =  Context . enter ( ) ; cx . set Optimization Level (  OPTIMIZATION_ LEVEL ) ; cx . set Maximum Interpreter Stack Depth (  MAX_ STACK_ DEPTH ) ; cx . set Class Shutter ( new  CWLExpression Deny All Class Shutter ( ) ) ; try {  Scriptable global Scope = cx . init Standard Objects ( ) ; if ( engine Configs != null ) { for ( int i = _ NUM ; i < engine Configs . size ( ) ; i ++ ) {  Reader engine Config Reader = new  String Reader ( engine Configs . get ( i ) ) ; cx . evaluate Reader ( global Scope , engine Config Reader , _ STR + i + _ STR , _ NUM , null ) ; } } put To Scope (  EXPR_ CONTEXT_ NAME , context , cx , global Scope ) ; put To Scope (  EXPR_ SELF_ NAME , self , cx , global Scope ) ;  Scriptable result Scope = cx . new Object ( global Scope ) ; result Scope . set Prototype ( global Scope ) ; result Scope . set Parent Scope ( global Scope ) ;  Object result = cx . evaluate String ( result Scope , function , _ STR , _ NUM , null ) ; if ( result == null || result instanceof  Undefined ) { return null ; }  Object wrapped Result =  Context . java To JS ( result , global Scope ) ; put To Scope ( _ STR , wrapped Result , cx , global Scope ) ;  Scriptable Object . put Property ( global Scope , _ STR , wrapped Result ) ;  String final Function = _ STR + _ STR + _ STR + _ STR + _ STR ;  Scriptable wrap Scope = cx . new Object ( global Scope ) ; wrap Scope . set Prototype ( global Scope ) ; wrap Scope . set Parent Scope ( global Scope ) ; result = cx . evaluate String ( wrap Scope , final Function , _ STR , _ NUM , null ) ; return cast Result ( result ) ; } catch (  Exception e ) {  String msg =  String . format ( _ STR , expr ) ; throw new  CWLExpression Exception ( msg , e ) ; } finally {  Context . exit ( ) ; } }
private void token ( char c ) throws  Configuration Exception ,  IOException { int t = st . next Token ( ) ; if ( t != c ) { if ( c == _ STR ) { syntax ( _ STR ) ; } else { syntax ( new  String ( new char [ ] { _ STR , c , + _ STR } ) ) ; } } }
public static boolean is Jar URL (  URL url ) {  String protocol = url . get Protocol ( ) ; return (  URL_ PROTOCOL_ JAR . equals ( protocol ) ||  URL_ PROTOCOL_ ZIP . equals ( protocol ) ||  URL_ PROTOCOL_ VFSZIP . equals ( protocol ) ||  URL_ PROTOCOL_ WSJAR . equals ( protocol ) ) ; }
public boolean equals (  Object o ) { if ( o instanceof  LDAPUsers ) {  LDAPUsers g = (  LDAPUsers ) o ; if ( ( selected User DNs != null ) && ( g . selected User DNs != null ) && ( selected User DNs . equals ( g . selected User DNs ) ) ) { return _ BOOL ; } } return _ BOOL ; }
protected void apply Set Timestamp (  Long timestamp ) throws  SQLException { if ( timestamp != null && conn . supports Control Timestamp ( ) ) { if ( timestamp . long Value ( ) != current Timestamp ) { current Timestamp = timestamp . long Value ( ) ; statement . add Batch ( conn . get Control Timestamp Query ( timestamp ) ) ; } } }
public  Accessor (  String class Name ,  Class Loader class Loader ,  Class [ ] constructor Types ,  Object [ ] constructor Args ) { try { f Class =  Class . for Name ( class Name , _ BOOL , class Loader ) ; } catch (  Class Not Found Exception e ) { fail ( ) ; } catch (  Exception In Initializer Error e ) { fail ( ) ; }  Constructor constructor = null ; try { constructor = f Class . get Declared Constructor ( constructor Types ) ; } catch (  Security Exception e2 ) { fail ( ) ; } catch (  No Such Method Exception e2 ) { fail ( ) ; }  Assert . is Not Null ( constructor ) ; constructor . set Accessible ( _ BOOL ) ; try { f Instance = constructor . new Instance ( constructor Args ) ; } catch (  Illegal Argument Exception e ) { fail ( ) ; } catch (  Invocation Target Exception e ) { fail ( ) ; } catch (  Instantiation Exception e ) { fail ( ) ; } catch (  Illegal Access Exception e ) { fail ( ) ; } }
public static  List <  Logged Mqtt Message > parse Message Log ( final  List <  String > messages , final  Progress Updater progress , final long current , final long max ) throws  Spy Exception { try { final long start Time =  Time Utils . get Monotonic Time ( ) ; final int items = messages . size ( ) ; final long chunk Size = items / _ NUM ; final  Mqtt Message Log Parser parser = new  Mqtt Message Log Parser ( ) ; final  List <  Logged Mqtt Message > list = new  Array List <  Logged Mqtt Message > ( ) ; long item = _ NUM ; long report At = _ NUM ; for ( int i = _ NUM ; i < items ; i ++ ) { final  String message = messages . get ( i ) ; if ( progress != null ) { if ( progress . is Cancelled ( ) ) { logger . info ( _ STR ) ; return null ; } item ++ ; if ( item % _ NUM == _ NUM ) { progress . update ( current + item , max ) ; } } if ( ( i > _ NUM ) && ( i == ( chunk Size * report At ) ) ) { final long current Time =  Time Utils . get Monotonic Time ( ) ; final long time Taken = current Time - start Time ; final long total Time Expected = time Taken * items / i ; if ( time Taken > _ NUM ) { logger . info ( _ STR , report At * _ NUM , ( total Time Expected - time Taken ) / _ NUM ) ; } report At ++ ; } try { list . add ( parser . parse ( message ) ) ; } catch (  XMLException e ) { logger . error ( _ STR + message , e ) ; } } logger . info ( _ STR , list . size ( ) ) ; return list ; } catch (  XMLException e ) { throw new  Spy Exception ( _ STR , e ) ; } }
public void stop ( ) { duration +=  System . current Time Millis ( ) - start ; }
public void add Row (  Object [ ] row ) throws  Carbon Sort Key And Group By Exception { int current Size = entry Count ; if ( sort Buffer Size == current Size ) {  LOGGER . debug ( _ STR ) ;  File [ ] file List ; if ( proc Files . size ( ) >= number Of Intermediate File To Be Merged ) { synchronized ( lock Object ) { file List = proc Files . to Array ( new  File [ proc Files . size ( ) ] ) ; this . proc Files = new  Array List <  File > ( _ NUM ) ; }  LOGGER . debug ( _ STR + file List . length ) ; start Intermediate Merging ( file List ) ; }  Object [ ] [ ] record Holder List Local = record Holder List ; try { semaphore . acquire ( ) ; data Sorter And Writer Executor Service . submit ( new  Data Sorter And Writer ( record Holder List Local ) ) ; } catch (  Interrupted Exception e ) {  LOGGER . error ( _ STR + e . get Message ( ) ) ; throw new  Carbon Sort Key And Group By Exception ( e . get Message ( ) ) ; } this . record Holder List = new  Object [ this . sort Buffer Size ] [ ] ; this . entry Count = _ NUM ; } record Holder List [ entry Count ++ ] = row ; }
@  Uninterruptible public static  Address unwind Native Stack Frame (  Address currfp ) { if (  VM .  Build For IA32 ) { return currfp ; }  Address callee_fp ;  Address fp =  Magic . get Caller Frame Pointer ( currfp ) ;  Address ip ; do { callee_fp = fp ; ip =  Magic . get Return Address Unchecked ( fp ) ; fp =  Magic . get Caller Frame Pointer ( fp ) ; } while ( !  Memory Manager . address In VM ( ip ) && fp .  NE (  Stack Frame Layout . get Stack Frame Sentinel FP ( ) ) ) ; if (  VM .  Build For Power PC ) { return fp ; } else { return callee_fp ; } }
@  Override public  Path Impl scheme Walk (  String user Path ,  Map <  String ,  Object > attributes ,  String file Path , int offset ) {  String canonical Path ; if ( offset < file Path . length ( ) && ( file Path . char At ( offset ) == _ STR || file Path . char At ( offset ) == _separator Char ) ) canonical Path = normalize Path ( _ STR , file Path , offset , _separator Char ) ; else canonical Path = normalize Path ( _pathname , file Path , offset , _separator Char ) ; return fs Walk ( user Path , attributes , canonical Path ) ; }
public static boolean is Mime Type Image (  String mime Type ) { return mime Type != null && mime Type . starts With ( _ STR ) ; }
public  FXMessage Dialog ( final  Stage parent , final  Parent group ) { this ( parent ) ; content . set Center ( group ) ; }
public  Matrix abs ( ) {  Matrix result = new  Matrix ( m , n ) ; for ( int i = _ NUM ; i < result .  A . length ; i ++ ) { for ( int j = _ NUM ; j < result .  A [ i ] . length ; j ++ ) result .  A [ i ] [ j ] =  Math . abs (  A [ i ] [ j ] ) ; } return result ; }
public void remove Attribute (  String attr Name ) throws  SMSException {  Set attribute = (  Set ) attr Set . get ( attr Name ) ; if ( attribute == null ) { throw ( new  SMSException (  Ldap Exception . new Ldap Exception (  Result Code .  ATTRIBUTE_ OR_ VALUE_ EXISTS , get Bundle String (  IUMSConstants .  SMS_ ATTR_ OR_ VAL_ EXISTS ) ) , _ STR ) ) ; } attr Set . remove ( attr Name ) ; if ( mod Set == null ) { mod Set = new  Hash Set ( ) ; }  Basic Attribute ba = new  Basic Attribute ( attr Name , attribute ) ; for (  Iterator items = attribute . iterator ( ) ; items . has Next ( ) ; ) ba . add ( items . next ( ) ) ; mod Set . add ( new  Modification Item (  Dir Context .  REMOVE_ ATTRIBUTE , ba ) ) ; }
@  Target Api (  Build .  VERSION_ CODES .  HONEYCOMB ) public void snapshot ( int camera Id ) { final int enc Width = _ NUM ; final int enc Height = _ NUM ; if ( enable . contains Key ( camera Id ) && ! enable . get ( camera Id ) ) { return ; }  Camera camera = null ; synchronized ( camera Lock ) { try { camera = prepare Camera ( camera Id , enc Width , enc Height ) ; if ( camera == null ) { return ; } if (  Cfg .  DEBUG ) {  Check . log (  TAG + _ STR + camera Id ) ; } if ( this . surface == null ) { int [ ] surfaceparams = new int [ _ NUM ] ;  GLES20 . gl Gen Textures ( _ NUM , surfaceparams , _ NUM ) ;  GLES20 . gl Bind Texture (  GLES20 .  GL_ TEXTURE_2 D , surfaceparams [ _ NUM ] ) ;  GLES20 . gl Tex Parameteri (  GLES20 .  GL_ TEXTURE_2 D ,  GLES20 .  GL_ TEXTURE_ WRAP_ S ,  GLES20 .  GL_ CLAMP_ TO_ EDGE ) ;  GLES20 . gl Tex Parameteri (  GLES20 .  GL_ TEXTURE_2 D ,  GLES20 .  GL_ TEXTURE_ WRAP_ T ,  GLES20 .  GL_ CLAMP_ TO_ EDGE ) ; this . surface = new  Surface Texture ( surfaceparams [ _ NUM ] ) ; } camera . set Preview Texture ( surface ) ; camera . start Preview ( ) ; camera . set One Shot Preview Callback ( preview Callback ) ; camera Lock . wait ( ) ; } catch (  Exception e ) { if (  Cfg .  DEBUG ) {  Check . log (  TAG + _ STR + e ) ; } } } }
private static  Debugger Exception parse Exception Option (  Node node ) { return new  Debugger Exception ( parse String Option ( node , _ STR ) , parse Long Option ( node , _ STR ) ,  Debugger Exception Handling Action . convert To Handling Action ( parse Int Option ( node , _ STR ) ) ) ; }
public  Image rotate180 Degrees (  Image image , boolean maintain Opacity ) { int [ ] rgb = image . get RGB ( ) ; int [ ] new RGB = new int [ rgb . length ] ; int width = image . get Width ( ) ; int height = image . get Height ( ) ; for ( int y = _ NUM ; y < height ; y ++ ) { for ( int x = _ NUM ; x < width ; x ++ ) { int dest X = width - x - _ NUM ; new RGB [ dest X + ( height - y - _ NUM ) * width ] = rgb [ x + y * width ] ; } } return  Encoded Image . create From RGB ( new RGB , width , height , ! maintain Opacity ) ; }
public static void update Finantare (  Set Get Model m ,  String changed Column Name ) {  Big Decimal val Cofinantare =  Set Get Util . get_ Attr Value As Big Decimal ( m ,  COLUMNNAME_ A_ Valoare_ Cofinantare ) ;  Big Decimal asset Cost =  Set Get Util . get_ Attr Value As Big Decimal ( m ,  COLUMNNAME_ A_ Asset_ Cost ) ;  Big Decimal val Tert =  Set Get Util . get_ Attr Value As Big Decimal ( m ,  COLUMNNAME_ A_ Valoare_ Tert ) ; if ( val Cofinantare . signum ( ) == _ NUM && val Tert . signum ( ) == _ NUM ) { val Cofinantare = asset Cost ; val Tert =  Env .  ZERO ; } else if (  COLUMNNAME_ A_ Asset_ Cost . equals ( changed Column Name ) ) { val Cofinantare = asset Cost . subtract ( val Tert ) ; } else if (  COLUMNNAME_ A_ Valoare_ Cofinantare . equals ( changed Column Name ) ) { val Tert = asset Cost . subtract ( val Cofinantare ) ; } else if (  COLUMNNAME_ A_ Valoare_ Tert . equals ( changed Column Name ) ) { val Cofinantare = asset Cost . subtract ( val Tert ) ; } else { val Tert = asset Cost . subtract ( val Cofinantare ) ; }  String tip Finantare =  A_ TIP_ FINANTARE_ Cofinantare ; if ( val Tert . signum ( ) == _ NUM ) { tip Finantare =  A_ TIP_ FINANTARE_ Proprie ; } else if ( val Cofinantare . signum ( ) == _ NUM ) { tip Finantare =  A_ TIP_ FINANTARE_ Terti ; } m . set_ Attr Value (  COLUMNNAME_ A_ Tip_ Finantare , tip Finantare ) ; m . set_ Attr Value (  COLUMNNAME_ A_ Valoare_ Cofinantare , val Cofinantare ) ; m . set_ Attr Value (  COLUMNNAME_ A_ Valoare_ Tert , val Tert ) ; if (  A_ TIP_ FINANTARE_ Proprie . equals ( tip Finantare ) &&  Set Get Util . is Persistent ( m ) ) { m . set_ Attr Value (  COLUMNNAME_ A_ Funding Mode_ ID , null ) ; } }
private void display Calendar ( ) {  List Item list Item = field Resource . get Selected Item ( ) ; if ( list Item == null ) return ;  Key Name Pair pp = new  Key Name Pair ( (  Integer ) list Item . get Value ( ) , list Item . get Label ( ) ) ; int  S_ Resource_ ID = pp . get Key ( ) ; m_m Assignment . set S_ Resource_ ID (  S_ Resource_ ID ) ;  Date date = field Date . get Value ( ) ; if ( date == null ) date = new  Timestamp (  System . current Time Millis ( ) ) ; m_loading = _ BOOL ; schedule Pane . recreate (  S_ Resource_ ID , date ) ; m_loading = _ BOOL ; invalidate ( ) ; }
public  Line String create Line String (  Coordinate Sequence coordinates ) { return new  Line String ( coordinates , this ) ; }
public void close ( ) { if ( closed . compare And Set ( _ BOOL , _ BOOL ) ) { do Close ( ) ; } }
@  Override public boolean connection Allowed (  String event Name ) { if ( ! event Name . equals ( _ STR ) ) { return _ BOOL ; } if ( m_listenee != null ) { return _ BOOL ; } return _ BOOL ; }
void subtract Flakes ( int quantity ) { for ( int i = _ NUM ; i < quantity ; ++ i ) { int index = num Flakes - i - _ NUM ; flakes . remove ( index ) ; } set Num Flakes ( num Flakes - quantity ) ; }
public boolean required Resource Name (  Policy policy ,  String realm Name ,  String name ) { get Svc Type Name To Actions Map ( policy , realm Name ) ; return required Resource Name Service . contains ( name ) ; }
public static void main (  String args [ ] ) { boolean ok = parse Options ( args ) ; if ( ! ok || ! strip Files ( infiles , outfiles ) ) {  System . exit ( _ NUM ) ; } }
protected  String a (  String s , int v ,  String u ) throws  Exception { char sign = v >= _ NUM ? _ STR : _ STR ;  Date dt =  Date Math Parser . parse Math ( null , s + _ STR + sign +  Math . abs ( v ) + u ) ; return fmt . format ( dt . to Instant ( ) ) ; }
Jar File open ( final  File jar File ) throws  IOException { is True ( jar File . exists ( ) , _ STR ) ; return new  Jar File ( jar File ) ; }
public void remove All Emails ( ) { emails . clear ( ) ; }
public  PWReset Admin Log (  SSOToken token ) { this . token = token ; if ( log Status ) { logger = ( com . sun . identity . log .  Logger )  Logger . get Logger ( log File ) ; }  String lstr =  System Properties . get (  Constants .  AM_ LOCALE ) ; init ( lstr ) ; }
public static boolean is Letter (  Character self ) { return  Character . is Letter ( self ) ; }
public static  String create Link (  String uri ,  String label ) { return _ STR + uri + _ STR + label + _ STR ; }
public static boolean is Expression (  String token , boolean is Xml ) {  String open Expr ;  String close Expr ; if ( is Xml ) { open Expr =  OPEN_ EXPR_ XML ; close Expr =  CLOSE_ EXPR_ XML ; } else { open Expr =  OPEN_ EXPR ; close Expr =  CLOSE_ EXPR ; } if ( token . starts With ( open Expr ) && token . ends With ( close Expr ) ) { return _ BOOL ; } else { return _ BOOL ; } }
public void destroy ( ) { this . is Initialized = _ BOOL ; this . is Finished = _ BOOL ; this . first Node = null ; this . tail Length = _ NUM ; this . first Node Height = - _ NUM ; }
public static  Uri from File (  File file ) { if ( file == null ) { throw new  Null Pointer Exception ( _ STR ) ; }  Path Part path =  Path Part . from Decoded ( file . get Absolute Path ( ) ) ; return new  Hierarchical Uri ( _ STR ,  Part .  EMPTY , path ,  Part .  NULL ,  Part .  NULL ) ; }
protected  Object read Fixed Type (  Binary Reader Ex Impl reader ) throws  Binary Object Exception {  Object val = null ; switch ( mode ) { case  BYTE : val = reader . read Byte Nullable ( id ) ; break ; case  SHORT : val = reader . read Short Nullable ( id ) ; break ; case  INT : val = reader . read Int Nullable ( id ) ; break ; case  LONG : val = reader . read Long Nullable ( id ) ; break ; case  FLOAT : val = reader . read Float Nullable ( id ) ; break ; case  DOUBLE : val = reader . read Double Nullable ( id ) ; break ; case  CHAR : val = reader . read Char Nullable ( id ) ; break ; case  BOOLEAN : val = reader . read Boolean Nullable ( id ) ; break ; case  DECIMAL : val = reader . read Decimal ( id ) ; break ; case  STRING : val = reader . read String ( id ) ; break ; case  UUID : val = reader . read Uuid ( id ) ; break ; case  DATE : val = reader . read Date ( id ) ; break ; case  TIMESTAMP : val = reader . read Timestamp ( id ) ; break ; case  BYTE_ ARR : val = reader . read Byte Array ( id ) ; break ; case  SHORT_ ARR : val = reader . read Short Array ( id ) ; break ; case  INT_ ARR : val = reader . read Int Array ( id ) ; break ; case  LONG_ ARR : val = reader . read Long Array ( id ) ; break ; case  FLOAT_ ARR : val = reader . read Float Array ( id ) ; break ; case  DOUBLE_ ARR : val = reader . read Double Array ( id ) ; break ; case  CHAR_ ARR : val = reader . read Char Array ( id ) ; break ; case  BOOLEAN_ ARR : val = reader . read Boolean Array ( id ) ; break ; case  DECIMAL_ ARR : val = reader . read Decimal Array ( id ) ; break ; case  STRING_ ARR : val = reader . read String Array ( id ) ; break ; case  UUID_ ARR : val = reader . read Uuid Array ( id ) ; break ; case  DATE_ ARR : val = reader . read Date Array ( id ) ; break ; case  TIMESTAMP_ ARR : val = reader . read Timestamp Array ( id ) ; break ; case  OBJECT_ ARR : val = reader . read Object Array ( id ) ; break ; case  COL : val = reader . read Collection ( id , null ) ; break ; case  MAP : val = reader . read Map ( id , null ) ; break ; case  BINARY_ OBJ : val = reader . read Binary Object ( id ) ; break ; case  ENUM : val = reader . read Enum ( id , field . get Type ( ) ) ; break ; case  ENUM_ ARR : val = reader . read Enum Array ( id , field . get Type ( ) . get Component Type ( ) ) ; break ; case  BINARY : case  OBJECT : val = reader . read Object ( id ) ; break ; case  CLASS : val = reader . read Class ( id ) ; break ; default : assert _ BOOL : _ STR + mode ; } return val ; }
@  Override public  Vector what Can Go Here ( int [ ] state ) {  Vector ret = new  Vector ( ) ; for ( int i = _ NUM ; i < f Num Elements ; i ++ ) { if ( state [ i + _ NUM ] ==  STATE_ START ) ret . add Element ( f All Elements [ i ] ) ; } return ret ; }
public void remove (  Region Entry entry ,  Object value ) {  Object object = map . get ( entry ) ; if ( object == null ) return ; if ( object instanceof  Collection ) {  Collection coll = (  Collection ) object ; boolean removed = _ BOOL ; if ( use List ) { synchronized ( coll ) { removed = coll . remove ( value ) ; } } else { removed = coll . remove ( value ) ; } if ( removed ) { if ( coll . size ( ) == _ NUM ) { map . remove ( entry ) ; } atomic Updater . decrement And Get ( this ) ; } } else { if ( object . equals ( value ) ) { map . remove ( entry ) ; } atomic Updater . decrement And Get ( this ) ; } }
private  Hash Data Cache (  Data Cache <  Pair <  String ,  T > > cache ,  String algorithm ) { this . cache = cache ; this . algorithm = algorithm ; try {  Message Digest . get Instance ( algorithm ) ; } catch (  No Such Algorithm Exception e ) {  String msg = _ STR + algorithm ;  LOG . warn ( msg , e ) ; throw new  System Config Exception ( e ) ; } }
private void marshall Enum (  Object value ,  Enum Type enum Type ) throws  IOException {  LOG . debug ( _ STR , value , enum Type ) ; json Generator . write String ( value . to String ( ) ) ; }
private void init Events ( ) { set Selection Sounds ( play , h Score , credits , quit , quit Y , quit N ) ; play . set On Action ( null ) ; h Score . set On Action ( null ) ; credits . set On Action ( null ) ; quit . set On Action ( null ) ; quit Y . set On Action ( null ) ; quit N . set On Action ( null ) ; scene . set On Key Pressed ( null ) ; scene . set On Key Released ( null ) ; }
private  String map Collection Name (  String collection Name , boolean dest ) { if ( ( collection Rules . size ( ) == _ NUM ) && (  String Utils . is Blank ( default Collection Append ) ) ) { return collection Name ; } for (  String [ ] rule : collection Rules ) {  String match = ( dest ) ? rule [ _ NUM ] : rule [ _ NUM ] ;  String replace = ( dest ) ? rule [ _ NUM ] : rule [ _ NUM ] ; if ( collection Name . contains ( match ) ) { return collection Name . replace ( match , replace ) ; } } if ( dest ) { return collection Name + default Collection Append ; } else { return collection Name . replace ( default Collection Append , _ STR ) ; } }
static public void fill Random Integer Uniform (  IDouble Vector vec ,  Random rand , int min , int max ) { final int delta = max - min ; for ( int i = _ NUM ; i < vec . get Length ( ) ; ++ i ) { vec . set ( i , min + rand . next Int ( delta ) ) ; } }
private static void stopping Animation (  Thread me ) { final  Fetcher Info info =  Fetcher Info . get Fetcher Info ( ) ; synchronized ( info . wait List ) { int index = - _ NUM ; for ( int i = _ NUM ; i < info . fetchers . length ; i ++ ) { if ( info . fetchers [ i ] == me ) { return ; } if ( info . fetchers [ i ] == null ) { index = i ; } } if ( index >= _ NUM ) { info . fetchers [ index ] = me ; info . num Fetchers ++ ; me . set Name ( _ STR + index ) ; return ; } } }
public boolean name_is_equal (  String p_name ) { if ( p_name == null ) return _ BOOL ; return p_name . equals Ignore Case ( pkg_name ) ; }
protected void draw Range Markers (  Graphics2 D g2 ,  Rectangle2 D data Area , int index ,  Layer layer ) {  XYItem Renderer r = get Renderer ( index ) ; if ( r == null ) { return ; } if ( index >= get Dataset Count ( ) ) { return ; }  Collection markers = get Range Markers ( index , layer ) ;  Value Axis axis = get Range Axis For Dataset ( index ) ; if ( markers != null && axis != null ) {  Iterator iterator = markers . iterator ( ) ; while ( iterator . has Next ( ) ) {  Marker marker = (  Marker ) iterator . next ( ) ; r . draw Range Marker ( g2 , this , axis , marker , data Area ) ; } } }
public  VPFLayer ( ) { set Projection Change Policy ( new com . bbn . openmap . layer . policy .  List Reset PCPolicy ( this ) ) ; set Mouse Mode IDs For Events ( new  String [ ] { _ STR } ) ; }
protected boolean should Close (  Pooled Connection con , int action ) { if ( con . get Connection Version ( ) < get Pool Version ( ) ) return _ BOOL ; if ( con . is Discarded ( ) ) return _ BOOL ; if ( is Closed ( ) ) return _ BOOL ; if ( ! con . validate ( action ) ) return _ BOOL ; if ( ! terminate Transaction ( con ) ) return _ BOOL ; if ( con . is Max Age Expired ( ) ) return _ BOOL ; else return _ BOOL ; }
public  Vector3 D hsl ( ) { float r = redf ( ) ; float g = greenf ( ) ; float b = bluef ( ) ; float min =  Math . min (  Math . min ( r , g ) , b ) ; float max =  Math . max (  Math . max ( r , g ) , b ) ; float l = lighting ( min , max ) ; float s = saturation ( min , max , l ) ; float h = hue ( r , g , b , min , max ) ; return new  Vector3 D ( h , s , l ) ; }
public  Future <  Boolean > shutdown Awaiting ( long timeout For Each ) {  Executor Service executor =  Executors . new Scheduled Thread Pool ( _ NUM ) ; return executor . submit ( create Shutdown ( timeout For Each ) ) ; }
public void change Directory (  String path ) throws  Illegal State Exception ,  IOException ,  FTPIllegal Reply Exception ,  FTPException { synchronized ( lock ) { if ( ! connected ) { throw new  Illegal State Exception ( _ STR ) ; } if ( ! authenticated ) { throw new  Illegal State Exception ( _ STR ) ; } communication . send FTPCommand ( _ STR + path ) ;  FTPReply r = communication . read FTPReply ( ) ; touch Auto Noop Timer ( ) ; if ( ! r . is Success Code ( ) ) { throw new  FTPException ( r ) ; } } }
private  String remove Quote (  String column ) { return column != null ? column . replace All ( statement Builder . get Column Quote ( ) ,  String Utils .  EMPTY ) : null ; }
private boolean scrolled Up Timeout ( ) { if ( fixed Chat || pause Key Pressed ) { return _ BOOL ; } if ( ! styles . auto Scroll ( ) ) { return _ BOOL ; } long time Passed =  System . current Time Millis ( ) - last Changed ; if ( time Passed > _ NUM * styles . auto Scroll Timeout ( ) ) {  LOGGER . info ( _ STR + time Passed + _ STR ) ; return _ BOOL ; } return _ BOOL ; }
public  List <  Document > search (  Query query , boolean prefix Wild Card ) {  List <  Document > documents = new  Array List <  Document > ( ) ; try {  Index Searcher searcher = get Searcher ( ) ;  Top Docs search = searcher . search ( query , _ NUM ) ; for (  Score Doc score Doc : search . score Docs ) {  Document doc = searcher . doc ( score Doc . doc ) ; documents . add ( doc ) ; } } catch (  Exception e ) { e . print Stack Trace ( ) ; throw new  Runtime Exception ( e ) ; } return documents ; }
public  String num Arcs Tip Text ( ) { return _ STR ; }
@  Request Mapping ( value = _ STR , method = {  Request Method .  GET } ) @  Response Body public  List <  Job Instance > list (  Job List Request job Request ) {  List <  Job Instance > job Instance List =  Collections . empty List ( ) ;  List <  Job Status Enum > status List = new  Array List <  Job Status Enum > ( ) ; if ( null != job Request . get Status ( ) ) { for ( int status : job Request . get Status ( ) ) { status List . add (  Job Status Enum . get By Code ( status ) ) ; } }  Job Time Filter Enum time Filter =  Job Time Filter Enum . get By Code ( job Request . get Time Filter ( ) ) ; try { job Instance List = job Service . list All Jobs ( job Request . get Cube Name ( ) , job Request . get Project Name ( ) , status List , job Request . get Limit ( ) , job Request . get Offset ( ) , time Filter ) ; } catch (  Exception e ) { logger . error ( e . get Localized Message ( ) , e ) ; throw new  Internal Error Exception ( e ) ; } return job Instance List ; }
public byte [ ] to Binary ( int q ) { return  Array Encoder . encode Mod Q ( coeffs , q ) ; }
public final void open Fallback Input Stream ( ) throws  Data Fallback Exception { if ( input Buf == null ) { if (  LOG . is Debug Enabled ( ) )  LOG . debug ( _ STR + data File . get Name ( ) + _ STR ) ; try { set Input ( new  Buffered Reader ( new  File Reader ( data File ) ) ) ; } catch (  IOException e ) { throw new  Data Fallback Exception ( e . get Message ( ) ) ; } } }
public void add Caret Listener ( final  ICaret Listener listener ) {  Preconditions . check Not Null ( listener , _ STR ) ; if ( ! m_listeners . contains ( listener ) ) { m_listeners . add ( listener ) ; } }
@  Deprecated static public  Serial Sensor Manager instance ( ) { return null ; }
protected void push Bidirectional Vip Routes (  IOFSwitch sw ,  OFPacket In pi ,  Floodlight Context cntx ,  IPClient client ,  LBMember member ) {  IDevice src Device = null ;  IDevice dst Device = null ;  Collection < ? extends  IDevice > all Devices = device Manager . get All Devices ( ) ; for (  IDevice d : all Devices ) { for ( int j = _ NUM ; j < d . get IPv4 Addresses ( ) . length ; j ++ ) { if ( src Device == null && client . ip Address == d . get IPv4 Addresses ( ) [ j ] ) src Device = d ; if ( dst Device == null && member . address == d . get IPv4 Addresses ( ) [ j ] ) { dst Device = d ; member . mac String = dst Device . get MACAddress String ( ) ; } if ( src Device != null && dst Device != null ) break ; } } if ( src Device == null || dst Device == null ) return ;  Long src Island = topology . get L2 Domain Id ( sw . get Id ( ) ) ; if ( src Island == null ) { log . debug ( _ STR , sw . get String Id ( ) , pi . get In Port ( ) ) ; return ; } boolean on_same_island = _ BOOL ; boolean on_same_if = _ BOOL ; for (  Switch Port dst Dap : dst Device . get Attachment Points ( ) ) { long dst Sw Dpid = dst Dap . get Switch DPID ( ) ;  Long dst Island = topology . get L2 Domain Id ( dst Sw Dpid ) ; if ( ( dst Island != null ) && dst Island . equals ( src Island ) ) { on_same_island = _ BOOL ; if ( ( sw . get Id ( ) == dst Sw Dpid ) && ( pi . get In Port ( ) == dst Dap . get Port ( ) ) ) { on_same_if = _ BOOL ; } break ; } } if ( ! on_same_island ) { if ( log . is Trace Enabled ( ) ) { log . trace ( _ STR + _ STR , dst Device ) ; } return ; } if ( on_same_if ) { if ( log . is Trace Enabled ( ) ) { log . trace ( _ STR + _ STR , sw . to String ( ) , pi . get In Port ( ) ) ; } return ; }  Switch Port [ ] src Daps = src Device . get Attachment Points ( ) ;  Arrays . sort ( src Daps , cluster Id Comparator ) ;  Switch Port [ ] dst Daps = dst Device . get Attachment Points ( ) ;  Arrays . sort ( dst Daps , cluster Id Comparator ) ; int i Src Daps = _ NUM , i Dst Daps = _ NUM ; while ( ( i Src Daps < src Daps . length ) && ( i Dst Daps < dst Daps . length ) ) {  Switch Port src Dap = src Daps [ i Src Daps ] ;  Switch Port dst Dap = dst Daps [ i Dst Daps ] ;  Long src Cluster = topology . get L2 Domain Id ( src Dap . get Switch DPID ( ) ) ;  Long dst Cluster = topology . get L2 Domain Id ( dst Dap . get Switch DPID ( ) ) ; int src Vs Dest = src Cluster . compare To ( dst Cluster ) ; if ( src Vs Dest == _ NUM ) { if ( ! src Dap . equals ( dst Dap ) && ( src Cluster != null ) && ( dst Cluster != null ) ) {  Route route In = routing Engine . get Route ( src Dap . get Switch DPID ( ) , ( short ) src Dap . get Port ( ) , dst Dap . get Switch DPID ( ) , ( short ) dst Dap . get Port ( ) , _ NUM ) ;  Route route Out = routing Engine . get Route ( dst Dap . get Switch DPID ( ) , ( short ) dst Dap . get Port ( ) , src Dap . get Switch DPID ( ) , ( short ) src Dap . get Port ( ) , _ NUM ) ; if ( route In != null ) { push Static Vip Route ( _ BOOL , route In , client , member , sw . get Id ( ) ) ; } if ( route Out != null ) { push Static Vip Route ( _ BOOL , route Out , client , member , sw . get Id ( ) ) ; } } i Src Daps ++ ; i Dst Daps ++ ; } else if ( src Vs Dest < _ NUM ) { i Src Daps ++ ; } else { i Dst Daps ++ ; } } return ; }
public static  String parse Id From Same Document URI (  String uri ) { if ( uri . length ( ) == _ NUM ) { return null ; }  String id = uri . substring ( _ NUM ) ; if ( id != null && id . starts With ( _ STR ) ) { int i1 = id . index Of ( _ STR ) ; int i2 = id . index Of ( _ STR , i1 + _ NUM ) ; id = id . substring ( i1 + _ NUM , i2 ) ; } return id ; }
public void mark Used ( long pos , int length ) { int start = get Block ( pos ) ; int blocks = get Block Count ( length ) ; set . set ( start , start + blocks ) ; }
public  Chol Matrix (  Matrix  Arg ) { final double [ ] [ ]  A =  Arg . to Double Array ( ) ; n = ( int )  Arg . get Row Count ( ) ;  L = new double [ n ] [ n ] ; isspd = (  Arg . get Column Count ( ) == n ) ; double [ ]  Lrowj = null ; double [ ]  Lrowk = null ; double [ ]  Aj = null ; for ( int j = _ NUM ; j < n ; j ++ ) {  Lrowj =  L [ j ] ;  Aj =  A [ j ] ; double d = _ NUM ; for ( int k = _ NUM ; k < j ; k ++ ) {  Lrowk =  L [ k ] ; double s = _ NUM ; for ( int i = _ NUM ; i < k ; i ++ ) { s +=  Lrowk [ i ] *  Lrowj [ i ] ; }  Lrowj [ k ] = s = (  Aj [ k ] - s ) /  Lrowk [ k ] ; d = d + s * s ; isspd = isspd & (  A [ k ] [ j ] ==  Aj [ k ] ) ; } d =  Aj [ j ] - d ; isspd = isspd & ( d > _ NUM ) ;  Lrowj [ j ] =  Math . sqrt (  Math . max ( d , _ NUM ) ) ; for ( int k = j + _ NUM ; k < n ; k ++ ) {  Lrowj [ k ] = _ NUM ; } } }
public static  String read String NZ (  Memory mem , int address , int n ) { address &=  Memory . address Mask ; if ( address + n >  Memory Map .  END_ RAM ) { n =  Memory Map .  END_ RAM - address + _ NUM ; if ( n < _ NUM ) { n = _ NUM ; } } byte [ ] bytes = new byte [  Math . min ( n , _ NUM ) ] ; int length = _ NUM ;  IMemory Reader memory Reader =  Memory Reader . get Memory Reader ( address , n , _ NUM ) ; for ( ; n > _ NUM ; n -- ) { int b = memory Reader . read Next ( ) ; if ( b == _ NUM ) { break ; } if ( length >= bytes . length ) { byte [ ] new Bytes = new byte [ bytes . length + _ NUM ] ;  System . arraycopy ( bytes , _ NUM , new Bytes , _ NUM , bytes . length ) ; bytes = new Bytes ; } bytes [ length ] = ( byte ) b ; length ++ ; } return new  String ( bytes , _ NUM , length ,  Constants . charset ) ; }
@  Override public void agg (  Object new Val ) { value Set . add ( new Val instanceof  Long ? (  Long ) new Val :  Long . value Of ( new Val . to String ( ) ) ) ; first Time = _ BOOL ; }
private boolean remove Legion Member (  String char Name , boolean kick ,  String player Name ) {  Legion Member Ex legion Member = get Legion Member Ex ( char Name ) ; if ( legion Member == null ) { log . error ( _ STR + char Name ) ; return _ BOOL ; } delete Legion Member From DB ( legion Member ) ;  Player player = world . find Player ( char Name ) ; if ( player != null ) {  Packet Send Utility . broadcast Packet ( player , new  SM_ LEGION_ UPDATE_ TITLE ( player . get Object Id ( ) , _ NUM , _ STR , _ NUM ) , _ BOOL ) ; } if ( kick ) {  Packet Send Utility . broadcast Packet To Legion ( legion Member . get Legion ( ) , new  SM_ LEGION_ LEAVE_ MEMBER ( _ NUM , legion Member . get Object Id ( ) , player Name , legion Member . get Name ( ) ) ) ; } else {  Packet Send Utility . broadcast Packet To Legion ( legion Member . get Legion ( ) , new  SM_ LEGION_ LEAVE_ MEMBER ( _ NUM , legion Member . get Object Id ( ) , char Name ) ) ; } return _ BOOL ; }
synchronized void print Buffer ( ) throws  IOException { int len = sb . length ( ) ; if ( len > _ NUM ) { char [ ] chars = new char [ len ] ; sb . get Chars ( _ NUM , len , chars , _ NUM ) ; sb . set Length ( _ NUM ) ; super . write ( chars , _ NUM , chars . length ) ; } }
public boolean contains Baf Body ( ) {  Iterator <  Soot Method > method It = method Iterator ( ) ; while ( method It . has Next ( ) ) {  Soot Method m = method It . next ( ) ; if ( m . has Active Body ( ) && m . get Active Body ( ) instanceof soot . baf .  Baf Body ) { return _ BOOL ; } } return _ BOOL ; }
public static  String retain All Chars (  String str ,  String retain Chars ) { int pos = index Of Chars ( str , retain Chars ) ; if ( pos == - _ NUM ) { return _ STR ; }  String Builder buf = new  String Builder ( ) ; do { buf . append ( str . char At ( pos ) ) ; pos = index Of Chars ( str , retain Chars , pos + _ NUM ) ; } while ( pos != - _ NUM ) ; return buf . to String ( ) ; }
public synchronized void delete Least Used Connection ( ) { final  Http Connection connection = (  Http Connection ) free Connections . remove First ( ) ; if ( connection != null ) { delete Connection ( connection ) ; } else if (  LOG . is Debug Enabled ( ) ) {  LOG . debug ( _ STR ) ; } }
private  Transit Schedule clean Up Schedule (  Transit Schedule new Transit Schedule ) { new Transit Schedule =  Transit Schedule Cleaner . remove Routes Without Departures ( new Transit Schedule ) ; new Transit Schedule =  Transit Schedule Cleaner . remove Empty Lines ( new Transit Schedule ) ; new Transit Schedule =  Transit Schedule Cleaner . remove Stops Not Used ( new Transit Schedule ) ; return new Transit Schedule ; }
private boolean step1 ( ) { if (  CT == null ) return _ BOOL ; if ( suffix (  CT , _ STR ) && suffix (  R2 , _ STR ) ) {  CT = replace Suffix (  CT , _ STR , _ STR ) ; return _ BOOL ; } if (  CT . length ( ) >= _ NUM ) { if ( suffix (  CT , _ STR ) && suffix (  R2 , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  CT , _ STR ) && suffix (  R2 , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  CT , _ STR ) && suffix (  R2 , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  CT , _ STR ) && suffix (  R2 , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  CT , _ STR ) && suffix (  R2 , _ STR ) ) { replace Suffix (  CT , _ STR , _ STR ) ; return _ BOOL ; } if ( suffix (  CT , _ STR ) && suffix (  R2 , _ STR ) ) {  CT = replace Suffix (  CT , _ STR , _ STR ) ; return _ BOOL ; } if ( suffix (  CT , _ STR ) && suffix (  R1 , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  CT , _ STR ) && suffix (  R2 , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } } if (  CT . length ( ) >= _ NUM ) { if ( suffix (  CT , _ STR ) && suffix (  R2 , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  CT , _ STR ) && suffix (  R2 , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  CT , _ STR ) && suffix (  R2 , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  CT , _ STR ) && suffix (  R2 , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  CT , _ STR ) && suffix (  R2 , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  CT , _ STR ) && suffix (  R2 , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  CT , _ STR ) && suffix (  R2 , _ STR ) ) {  CT = replace Suffix (  CT , _ STR , _ STR ) ; return _ BOOL ; } if ( suffix (  CT , _ STR ) && suffix (  R2 , _ STR ) ) {  CT = replace Suffix (  CT , _ STR , _ STR ) ; return _ BOOL ; } if ( suffix (  CT , _ STR ) && suffix (  R2 , _ STR ) ) {  CT = replace Suffix (  CT , _ STR , _ STR ) ; return _ BOOL ; } if ( suffix (  CT , _ STR ) && suffix (  R2 , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  CT , _ STR ) && suffix (  R2 , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } } if (  CT . length ( ) >= _ NUM ) { if ( suffix (  CT , _ STR ) && suffix (  R2 , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  CT , _ STR ) && suffix (  R2 , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  CT , _ STR ) && suffix (  R2 , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  CT , _ STR ) && suffix (  R2 , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  CT , _ STR ) && suffix (  R2 , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  CT , _ STR ) && suffix (  R2 , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  CT , _ STR ) && suffix (  R2 , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  CT , _ STR ) && suffix (  R2 , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  CT , _ STR ) && suffix (  R2 , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  CT , _ STR ) && suffix (  R2 , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  CT , _ STR ) && suffix (  R2 , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  CT , _ STR ) && suffix (  R2 , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  CT , _ STR ) && suffix (  R2 , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  CT , _ STR ) && suffix (  RV , _ STR ) && suffix Preceded (  CT , _ STR , _ STR ) ) {  CT = replace Suffix (  CT , _ STR , _ STR ) ; return _ BOOL ; } } if (  CT . length ( ) >= _ NUM ) { if ( suffix (  CT , _ STR ) && suffix (  R2 , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  CT , _ STR ) && suffix (  R2 , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  CT , _ STR ) && suffix (  R2 , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  CT , _ STR ) && suffix (  R2 , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  CT , _ STR ) && suffix (  R2 , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  CT , _ STR ) && suffix (  R2 , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  CT , _ STR ) && suffix (  R2 , _ STR ) ) {  CT = remove Suffix (  CT , _ STR ) ; return _ BOOL ; } if ( suffix (  CT , _ STR ) && suffix (  RV , _ STR ) && suffix Preceded (  CT , _ STR , _ STR ) ) {  CT = replace Suffix (  CT , _ STR , _ STR ) ; return _ BOOL ; } } return _ BOOL ; }
void close ( int context Prec , int own Prec ) throws  IOException { if ( own Prec < context Prec ) out . write ( _ STR ) ; }
public void finish Painting ( boolean use Cache ) {  Data Buffer Int data Buffer = new  Data Buffer Int ( w0 * h0 ) ; int transparency = native Finish Painting (  Sun Writable Raster . steal Data ( data Buffer , _ NUM ) , w0 , h0 ) ;  Sun Writable Raster . mark Dirty ( data Buffer ) ; int [ ] bands =  BAND_ OFFSETS [ transparency - _ NUM ] ;  Writable Raster raster =  Raster . create Packed Raster ( data Buffer , w0 , h0 , w0 , bands , null ) ;  Color Model cm =  COLOR_ MODELS [ transparency - _ NUM ] ;  Image img = new  Buffered Image ( cm , raster , _ BOOL , null ) ; if ( use Cache ) { cache . set Image ( get Class ( ) , null , w0 , h0 , cache Args , img ) ; } graphics . draw Image ( img , x0 , y0 , null ) ; }
public boolean delete Panel ( ) { if ( ! super . delete Panel ( ) ) { return _ BOOL ; } turnout List . clear ( ) ; track List . clear ( ) ; point List . clear ( ) ; xing List . clear ( ) ; slip List . clear ( ) ; turntable List . clear ( ) ; return _ BOOL ; }
@  Override default  Completable Future <  Optional Double > average Double ( final  To Double Function < ? super  T > fn ) { return  Completable Future . supply Async ( null , get Exec ( ) ) ; }
public  String next ( ) { return next (  ANY_ PATTERN ) ; }
public  Macro (  File file ) throws  EOFException ,  File Not Found Exception ,  IOException {  Document Builder Factory dbf =  Document Builder Factory . new Instance ( ) ;  Document Builder db = null ;  Document doc = null ; try { db = dbf . new Document Builder ( ) ;  Input Source is = new  Input Source ( new  Unicode Reader ( new  File Input Stream ( file ) ,  FILE_ ENCODING ) ) ; is . set Encoding (  FILE_ ENCODING ) ; doc = db . parse ( is ) ; } catch (  Exception e ) { e . print Stack Trace ( ) ;  String desc = e . get Message ( ) ; if ( desc == null ) { desc = e . to String ( ) ; } throw new  IOException ( _ STR + desc ) ; } macro Records = new  Array List ( ) ; boolean parsed OK = initialize From XMLFile ( doc . get Document Element ( ) ) ; if ( parsed OK == _ BOOL ) { name = null ; macro Records . clear ( ) ; macro Records = null ; throw new  IOException ( _ STR ) ; } }
public static void delete ESInput ( ) {  String es PIRIndex =  System Configuration . get Property (  Distributed Test Driver .  ES_ INPUT_ NODES_ PROPERTY ) + _ STR +  System Configuration . get Property (  Distributed Test Driver .  ES_ INPUT_ PORT_ PROPERTY ) + _ STR +  System Configuration . get Property (  Distributed Test Driver .  ES_ INPUT_ INDEX_ PROPERTY ) ; logger . info ( _ STR + es PIRIndex ) ;  Process Builder p Delete PIR = new  Process Builder ( _ STR , _ STR , es PIRIndex ) ; try {  Test Utils . execute Command ( p Delete PIR ) ; logger . info ( _ STR ) ; } catch (  IOException e ) { e . print Stack Trace ( ) ; } }
private boolean add ( int part ) { if ( ! parts . contains ( part ) ) { parts . add ( part ) ; return _ BOOL ; } return _ BOOL ; }
private  Location find Farthest Location (  Location location ,  Direction direction ) {  Location farthest ; do { farthest = location ; location = farthest . offset ( direction ) ; } while ( grid Operator . is Valid Location ( location ) && game Grid . get ( location ) == null ) ; return farthest ; }
private  JSplit Pane create Main Split Pane ( ) { final  JSplit Pane main Split Pane = new  JSplit Pane ( ) ; main Split Pane . set One Touch Expandable ( _ BOOL ) ; main Split Pane . set Divider Location ( _ NUM ) ; main Split Pane . set Resize Weight ( _ NUM ) ; main Split Pane . set Orientation (  JSplit Pane .  HORIZONTAL_ SPLIT ) ; m_component Panel . set Background (  Color .  WHITE ) ; main Split Pane . set Left Component ( create Project Tree Panel ( ) ) ; main Split Pane . set Right Component ( m_component Panel ) ; main Split Pane . set Border ( new  Line Border (  Color .  GRAY ) ) ; return main Split Pane ; }
private  Digicore Chain clean Chain (  Digicore Chain chain ) { return chain ; }
private boolean check Setup ( ) { this . txmgr =  Transaction Manager Imp . get Transaction Manager ( ) ; if ( this . txmgr == null ) { try {  Hashtable <  String ,  String > env = new  Hashtable <  String ,  String > ( ) ; env . put (  Context .  INITIAL_ CONTEXT_ FACTORY , this . initial Context Factory ) ; env . put (  Context .  PROVIDER_ URL , this . provider Url ) ;  Context ctx = new  Initial Context ( env ) ; this . txmgr Server = (  User Transaction Server )  Portable Remote Object . narrow ( ctx . lookup ( this . user Transaction Server Lookup Name ) ,  User Transaction Server . class ) ; } catch (  Exception e ) { e . print Stack Trace ( ) ; throw new  Runtime Exception ( get Not Found Message ( ) ) ; } if ( this . txmgr Server == null ) throw new  Runtime Exception ( get Not Found Message ( ) ) ; } return this . txmgr != null ; }
public static final boolean gives Check (  Position pos ,  Move m ) { boolean wtm = pos . white Move ; int o King Sq = pos . get King Sq ( ! wtm ) ; int o King = wtm ?  Piece .  BKING :  Piece .  WKING ; int p =  Piece . make White ( m . promote To ==  Piece .  EMPTY ? pos . get Piece ( m . from ) : m . promote To ) ; int d1 =  Bit Board . get Direction ( m . to , o King Sq ) ; switch ( d1 ) { case _ NUM : case - _ NUM : case _ NUM : case - _ NUM : if ( ( p ==  Piece .  WQUEEN ) || ( p ==  Piece .  WROOK ) ) if ( ( d1 != _ NUM ) && (  Move Gen . next Piece ( pos , m . to , d1 ) == o King ) ) return _ BOOL ; break ; case _ NUM : case _ NUM : case - _ NUM : case - _ NUM : if ( ( p ==  Piece .  WQUEEN ) || ( p ==  Piece .  WBISHOP ) ) { if ( ( d1 != _ NUM ) && (  Move Gen . next Piece ( pos , m . to , d1 ) == o King ) ) return _ BOOL ; } else if ( p ==  Piece .  WPAWN ) { if ( ( ( d1 > _ NUM ) == wtm ) && ( pos . get Piece ( m . to + d1 ) == o King ) ) return _ BOOL ; } break ; default : if ( d1 != _ NUM ) { if ( p ==  Piece .  WKNIGHT ) return _ BOOL ; } } int d2 =  Bit Board . get Direction ( m . from , o King Sq ) ; if ( ( d2 != _ NUM ) && ( d2 != d1 ) && (  Move Gen . next Piece ( pos , m . from , d2 ) == o King ) ) { int p2 =  Move Gen . next Piece Safe ( pos , m . from , - d2 ) ; switch ( d2 ) { case _ NUM : case - _ NUM : case _ NUM : case - _ NUM : if ( ( p2 == ( wtm ?  Piece .  WQUEEN :  Piece .  BQUEEN ) ) || ( p2 == ( wtm ?  Piece .  WROOK :  Piece .  BROOK ) ) ) return _ BOOL ; break ; case _ NUM : case _ NUM : case - _ NUM : case - _ NUM : if ( ( p2 == ( wtm ?  Piece .  WQUEEN :  Piece .  BQUEEN ) ) || ( p2 == ( wtm ?  Piece .  WBISHOP :  Piece .  BBISHOP ) ) ) return _ BOOL ; break ; } } if ( ( m . promote To !=  Piece .  EMPTY ) && ( d1 != _ NUM ) && ( d1 == d2 ) ) { switch ( d1 ) { case _ NUM : case - _ NUM : case _ NUM : case - _ NUM : if ( ( p ==  Piece .  WQUEEN ) || ( p ==  Piece .  WROOK ) ) if ( ( d1 != _ NUM ) && (  Move Gen . next Piece ( pos , m . from , d1 ) == o King ) ) return _ BOOL ; break ; case _ NUM : case _ NUM : case - _ NUM : case - _ NUM : if ( ( p ==  Piece .  WQUEEN ) || ( p ==  Piece .  WBISHOP ) ) { if ( ( d1 != _ NUM ) && (  Move Gen . next Piece ( pos , m . from , d1 ) == o King ) ) return _ BOOL ; } break ; } } if ( p ==  Piece .  WKING ) { if ( m . to - m . from == _ NUM ) { if (  Move Gen . next Piece Safe ( pos , m . from , - _ NUM ) == o King ) return _ BOOL ; if (  Move Gen . next Piece Safe ( pos , m . from + _ NUM , wtm ? _ NUM : - _ NUM ) == o King ) return _ BOOL ; } else if ( m . to - m . from == - _ NUM ) { if (  Move Gen . next Piece Safe ( pos , m . from , _ NUM ) == o King ) return _ BOOL ; if (  Move Gen . next Piece Safe ( pos , m . from - _ NUM , wtm ? _ NUM : - _ NUM ) == o King ) return _ BOOL ; } } else if ( p ==  Piece .  WPAWN ) { if ( pos . get Piece ( m . to ) ==  Piece .  EMPTY ) { int dx =  Position . get X ( m . to ) -  Position . get X ( m . from ) ; if ( dx != _ NUM ) { int ep Sq = m . from + dx ; int d3 =  Bit Board . get Direction ( ep Sq , o King Sq ) ; switch ( d3 ) { case _ NUM : case _ NUM : case - _ NUM : case - _ NUM : if (  Move Gen . next Piece ( pos , ep Sq , d3 ) == o King ) { int p2 =  Move Gen . next Piece Safe ( pos , ep Sq , - d3 ) ; if ( ( p2 == ( wtm ?  Piece .  WQUEEN :  Piece .  BQUEEN ) ) || ( p2 == ( wtm ?  Piece .  WBISHOP :  Piece .  BBISHOP ) ) ) return _ BOOL ; } break ; case _ NUM : if (  Move Gen . next Piece ( pos ,  Math . max ( ep Sq , m . from ) , d3 ) == o King ) { int p2 =  Move Gen . next Piece Safe ( pos ,  Math . min ( ep Sq , m . from ) , - d3 ) ; if ( ( p2 == ( wtm ?  Piece .  WQUEEN :  Piece .  BQUEEN ) ) || ( p2 == ( wtm ?  Piece .  WROOK :  Piece .  BROOK ) ) ) return _ BOOL ; } break ; case - _ NUM : if (  Move Gen . next Piece ( pos ,  Math . min ( ep Sq , m . from ) , d3 ) == o King ) { int p2 =  Move Gen . next Piece Safe ( pos ,  Math . max ( ep Sq , m . from ) , - d3 ) ; if ( ( p2 == ( wtm ?  Piece .  WQUEEN :  Piece .  BQUEEN ) ) || ( p2 == ( wtm ?  Piece .  WROOK :  Piece .  BROOK ) ) ) return _ BOOL ; } break ; } } } } return _ BOOL ; }
public static  FSDirectory new FSDirectory (  Class < ? extends  FSDirectory > clazz ,  Path path ) throws  Reflective Operation Exception { return new FSDirectory ( clazz , path ,  FSLock Factory . get Default ( ) ) ; }
private static  Element add Element (  Document doc ,  Node parent ,  String tag Name ,  String attr1 ,  String val1 ,  String attr2 ,  String val2 ) {  Element elem = doc . create Element ( tag Name ) ; if ( attr1 != null ) elem . set Attribute ( attr1 , val1 ) ; if ( attr2 != null ) elem . set Attribute ( attr2 , val2 ) ; parent . append Child ( elem ) ; return elem ; }
public static  String stream2 String (  Input Stream is , int max Length ) throws  IOException { byte [ ] buffer = new byte [ _ NUM ] ;  String Writer sw = new  String Writer ( ) ; int total Read = _ NUM ; int read = _ NUM ; do { sw . write ( new  String ( buffer , _ NUM , read ) ) ; total Read += read ; read = is . read ( buffer , _ NUM , buffer . length ) ; } while ( ( ( - _ NUM == max Length ) || ( total Read < max Length ) ) && ( read != - _ NUM ) ) ; return sw . to String ( ) ; }
private static  Couple <  String > split Name Of Remote Branch (  String branch Name ) { int first Slash = branch Name . index Of ( _ STR ) ;  String remote Name = first Slash > - _ NUM ? branch Name . substring ( _ NUM , first Slash ) : branch Name ;  String remote Branch Name = branch Name . substring ( first Slash + _ NUM ) ; return  Couple . of ( remote Name , remote Branch Name ) ; }
public static  Output Stream encrypt (  Output Stream unencrypted Output Stream , char [ ] password ) throws  Encryption Exception ,  IOException {  Output Stream encrypted Output Stream = null ;  PBEKey Spec pbe Key Spec = new  PBEKey Spec ( password ) ;  PBEParameter Spec pbe Parameter Spec = new  PBEParameter Spec (  SALT ,  ITERATION_ COUNT ) ; try {  Secret Key Factory secret Key Factory =  Secret Key Factory . get Instance (  ENCRYPTION_ ALGORITHM ,  CRYPTOPROVIDER ) ;  Secret Key pbe Key = secret Key Factory . generate Secret ( pbe Key Spec ) ;  Cipher cipher =  Cipher . get Instance (  ENCRYPTION_ ALGORITHM ,  CRYPTOPROVIDER ) ; cipher . init (  Cipher .  ENCRYPT_ MODE , pbe Key , pbe Parameter Spec ) ; encrypted Output Stream = new  Cipher Output Stream ( unencrypted Output Stream , cipher ) ; } catch (  General Security Exception e ) { throw new  Encryption Exception ( _ STR , e ) ; } return encrypted Output Stream ; }
public static  String right Pad (  String original , int length , char pad Char ) { if ( original . length ( ) >= length ) { return original ; } return original + string Of Char ( pad Char , length - original . length ( ) ) ; }
protected void reload Swipe State In View (  View front View , int position ) { if ( ! opened . get ( position ) ) {  View Compat . set Translation X ( front View , _ NUM ) ; } else { if ( opened Right . get ( position ) ) {  View Compat . set Translation X ( front View , swipe List View . get Width ( ) ) ; } else {  View Compat . set Translation X ( front View , - swipe List View . get Width ( ) ) ; } } }
void reset ( ) {  System . arraycopy ( iv , _ NUM , k , _ NUM , block Size ) ; }
public  Matrix3 multiply By Vertical Flip ( ) { double [ ] m = this . m ; m [ _ NUM ] += m [ _ NUM ] ; m [ _ NUM ] += m [ _ NUM ] ; m [ _ NUM ] += m [ _ NUM ] ; m [ _ NUM ] = - m [ _ NUM ] ; m [ _ NUM ] = - m [ _ NUM ] ; m [ _ NUM ] = - m [ _ NUM ] ; return this ; }
public void shutdown ( ) throws  Data Source Exception { if ( created Session Factory ) { if ( session Factory != null && ! session Factory . is Closed ( ) ) { try { session Factory . close ( ) ; } finally { session Factory = null ; } } } }
public  COpen Function Action ( final  CGraph Window parent , final  IView Container container , final  INavi Function function ) { super (  String . format ( _ STR , function . get Name ( ) ) ) ;  Preconditions . check Not Null ( parent , _ STR ) ;  Preconditions . check Not Null ( container , _ STR ) ; m_parent = parent ; m_container = container ; m_function = function ; }
public void write String ( final  String s ) { final byte [ ] bytes = s . get Bytes ( ) ; final int len = bytes . length ; write Int ( len ) ;  System . arraycopy ( bytes , _ NUM , buffer , offset , len ) ; offset += len ; pad ( ) ; }
private static  Permission Collection create All Permissions ( ) {  Permissions permissions = new  Permissions ( ) ; permissions . add ( new  All Permission ( ) ) ; return permissions ; }
private void merge Networks (  Network tzone ,  Network s Zone ) {  List <  String > added End Points = new  Array List <  String > ( s Zone . retrieve Endpoints ( ) ) ;  String Set new End Points = s Zone . retrieve Endpoints ( ) ; for (  String endpoint : tzone . retrieve Endpoints ( ) ) { if ( new End Points . contains ( endpoint ) ) { added End Points . remove ( endpoint ) ; } } if ( ! added End Points . is Empty ( ) ) { tzone . add Endpoints ( added End Points , _ BOOL ) ; } tzone . set Native Guid ( s Zone . get Native Guid ( ) ) ; }
static public void println (  String msg ) { println ( msg ,  CLLog Level . normal ) ; }
private  List <  Facet Result > sum Associations ( ) throws  IOException {  Directory Reader index Reader =  Directory Reader . open ( index Dir ) ;  Index Searcher searcher = new  Index Searcher ( index Reader ) ;  Taxonomy Reader taxo Reader = new  Directory Taxonomy Reader ( taxo Dir ) ;  Facets Collector fc = new  Facets Collector ( ) ;  Facets Collector . search ( searcher , new  Match All Docs Query ( ) , _ NUM , fc ) ;  Facets tags = new  Taxonomy Facet Sum Int Associations ( _ STR , taxo Reader , config , fc ) ;  Facets genre = new  Taxonomy Facet Sum Float Associations ( _ STR , taxo Reader , config , fc ) ;  List <  Facet Result > results = new  Array List < > ( ) ; results . add ( tags . get Top Children ( _ NUM , _ STR ) ) ; results . add ( genre . get Top Children ( _ NUM , _ STR ) ) ; index Reader . close ( ) ; taxo Reader . close ( ) ; return results ; }
public  Reverse Geo Code (  Input Stream placenames , boolean major Only ) throws  IOException { create Kd Tree ( placenames , major Only ) ; }
public static  String from Tag (  List Tag <  Tag > tag ) {  String Builder builder = new  String Builder ( ) ; builder . append (  ARRAY_ START ) ; boolean start = _ BOOL ; for (  Tag value : tag . get Value ( ) ) { if ( start ) { start = _ BOOL ; } else { builder . append (  ELEMENT_ SEPERATOR ) ; } builder . append ( from Generic Tag ( value ) ) ; } builder . append (  ARRAY_ END ) ; return builder . to String ( ) ; }
private  XMLElement2 create Another Element ( ) { return new  XMLElement2 ( this . entities , this . ignore Whitespace , _ BOOL , this . ignore Case ) ; }
public synchronized void reset ( ) { labels . clear ( ) ; labels . put (  Sensision Constants .  SENSISION_ LABEL_ TOPIC , this . topic ) ; labels . put (  Sensision Constants .  SENSISION_ LABEL_ GROUPID , this . groupid ) ; for ( int i = _ NUM ; i < this . counters . length ; i ++ ) { if ( null == this . counters [ i ] ) { continue ; } labels . put (  Sensision Constants .  SENSISION_ LABEL_ PARTITION ,  Integer . to String ( i ) ) ;  Sensision . clear (  Sensision Constants .  SENSISION_ CLASS_ WARP_ KAFKA_ CONSUMER_ OFFSET , labels ) ; this . counters [ i ] = null ; } }
public  Vector rotate In Radian ( double radians ) { final double length = length ( ) ; double angle = angle In Radian ( ) ; angle += radians ; final  Vector result = new  Vector (  Math . cos ( angle ) ,  Math . sin ( angle ) ) ; return result . multiply ( length ) ; }
public void connection Lost ( java . lang .  Throwable cause ) { int rc = - _ NUM ; led . set Amber ( ) ; led . set Flash ( ) ; set Title Text ( _ STR ) ; synchronized ( this ) { write Logln ( _ STR + mqtt . get Server URI ( ) ) ; } try { while ( ( rc == - _ NUM ) && connected ) { try { synchronized ( conn Lost Wait ) { conn Lost Wait . wait ( _ NUM ) ; } } catch (  Interrupted Exception iex ) { } synchronized ( this ) { if ( connected ) { write Log ( _ STR ) ; try { connect ( mqtt . get Server URI ( ) , options Comp . is Persistence Selected ( ) ) ; rc = _ NUM ; } catch (  Mqtt Exception mqte ) { rc = - _ NUM ; } if ( rc == - _ NUM ) { write Logln ( _ STR ) ; } else { write Logln ( _ STR ) ; } } } } set Title Text ( _ STR ) ; } catch (  Exception ex ) { set Title Text ( _ STR ) ; ex . print Stack Trace ( ) ; disconnect ( ) ; } finally { if ( led . is Flashing ( ) ) { led . set Flash ( ) ; } } if ( connected ) { led . set Green ( ) ; set Connected ( _ BOOL ) ; } else { led . set Red ( ) ; set Connected ( _ BOOL ) ; } }
public  String header Out (  String name ) {  Array List <  String > keys = _header Keys Out ; int header Size = keys . size ( ) ; for ( int i = _ NUM ; i < header Size ; i ++ ) {  String old Key = keys . get ( i ) ; if ( old Key . equals Ignore Case ( name ) ) { return (  String ) _header Values Out . get ( i ) ; } } if ( name . equals Ignore Case ( _ STR ) ) { return _content Length Out >= _ NUM ?  String . value Of ( _content Length Out ) : null ; } if ( name . equals Ignore Case ( _ STR ) ) { return _content Type Out ; } return null ; }
private static  Map <  String ,  Set <  String > > parse Sparse Fields (  Multivalued Map <  String ,  String > query Params ) {  Map <  String ,  Set <  String > > result = new  Hash Map < > ( ) ; for (  Map .  Entry <  String ,  List <  String > > kv : query Params . entry Set ( ) ) {  String key = kv . get Key ( ) ; if ( key . starts With ( _ STR ) && key . ends With ( _ STR ) ) {  String type = key . substring ( _ NUM , key . length ( ) - _ NUM ) ;  Linked Hash Set <  String > filters = new  Linked Hash Set < > ( ) ; for (  String filter Params : kv . get Value ( ) ) {  Collections . add All ( filters , filter Params . split ( _ STR ) ) ; } if ( ! filters . is Empty ( ) ) { result . put ( type , filters ) ; } } } return result ; }
public  Element sign With WSSSAMLToken Profile (  Document doc , java . security . cert .  Certificate cert ,  String assertion ID ,  String algorithm ,  List ids ) throws  XMLSignature Exception { return sign With WSSSAMLToken Profile ( doc , cert , assertion ID , algorithm , ids ,  SOAPBinding Constants .  WSF_10_ VERSION ) ; }
@  Override public void add URL (  URL url , boolean is Scanned ) { if ( contains URL ( url ) ) { return ; } super . add URL ( url , is Scanned ) ; if ( is Scanned ) _pending Scan Roots . add ( new  Scan Root ( url , null ) ) ; }
public void add ( final int start , final int end , final byte status ) { final int s = start - m Start ; if ( s < m Interval . length && end > m Start ) {  Arrays . fill ( m Interval ,  Math . max ( s , _ NUM ) ,  Math . min ( end - m Start , m Interval . length ) , status ) ; } }
public void reset ( ) { alpha = init Alpha ; neighborhood Size = init Neighborhood Size ; }
private void reload ( ) {  Document doc = text Pane . get Document ( ) ; doc . put Property (  Document .  Stream Description Property , null ) ; reference = current Reference ; load Page ( current Page ) ; }
protected void draw Hexagon ( int x , int y , int w , int h ,  Color fill Color ,  Paint fill Paint ,  Color pen Color , boolean shadow ,  String direction ) {  Polygon hexagon = new  Polygon ( ) ; if ( direction . equals ( mx Constants .  DIRECTION_ NORTH ) || direction . equals ( mx Constants .  DIRECTION_ SOUTH ) ) { hexagon . add Point ( x + ( int ) ( _ NUM * w ) , y ) ; hexagon . add Point ( x + w , y + ( int ) ( _ NUM * h ) ) ; hexagon . add Point ( x + w , y + ( int ) ( _ NUM * h ) ) ; hexagon . add Point ( x + ( int ) ( _ NUM * w ) , y + h ) ; hexagon . add Point ( x , y + ( int ) ( _ NUM * h ) ) ; hexagon . add Point ( x , y + ( int ) ( _ NUM * h ) ) ; } else { hexagon . add Point ( x + ( int ) ( _ NUM * w ) , y ) ; hexagon . add Point ( x + ( int ) ( _ NUM * w ) , y ) ; hexagon . add Point ( x + w , y + ( int ) ( _ NUM * h ) ) ; hexagon . add Point ( x + ( int ) ( _ NUM * w ) , y + h ) ; hexagon . add Point ( x + ( int ) ( _ NUM * w ) , y + h ) ; hexagon . add Point ( x , y + ( int ) ( _ NUM * h ) ) ; } draw Polygon ( hexagon , fill Color , fill Paint , pen Color , shadow ) ; }
private boolean is Static (  Field field ) { int modifier = field . get Modifiers ( ) ; if (  Modifier . is Static ( modifier ) ) { return _ BOOL ; } return _ BOOL ; }
public int outstanding Requests ( ) { return outstanding . get ( ) ; }
final public static  String to String ( final byte [ ] key , final int off , final int len ) { if ( key == null ) return  NULL ; final  String Builder sb = new  String Builder ( len * _ NUM + _ NUM ) ; sb . append ( _ STR ) ; for ( int i = off ; i < off + len ; i ++ ) { if ( i > _ NUM ) sb . append ( _ STR ) ; sb . append (  Integer . to String ( key [ i ] & _ NUM ) ) ; } sb . append ( _ STR ) ; return sb . to String ( ) ; }
public void init (  String component Name ) throws  Log Exception { access Logger =  Logger . get Logger ( component Name + _ STR ) ; error Logger =  Logger . get Logger ( component Name + _ STR ) ; }
private  View fill Left ( int pos , int next Right ) { if (  DEBUG )  Log . i (  TAG , _ STR + pos + _ STR + next Right +  M_ FIRST_ POSITION + m First Position ) ;  View selected View = null ; final int end = m List Padding . left ; while ( next Right > end && pos >= _ NUM ) {  View temp = make Column ( pos , next Right , _ BOOL ) ; if ( temp != null ) { selected View = temp ; } next Right = m Reference View . get Left ( ) - m Horizontal Spacing ; m First Position = pos ; pos -= m Num Rows ; } if ( m Stack From Bottom ) { m First Position =  Math . max ( _ NUM , pos + _ NUM ) ; } return selected View ; }
public void remove Default Value (  String value ) throws  SMSException ,  SSOException {  Set default Values = get Default Values ( ) ; if ( default Values !=  Collections .  EMPTY_ SET ) { default Values . remove ( value ) ; update Default Values ( default Values ) ; } }
public static int key Binding Description To Key Code (  String key Binding Description ) { if (  String Utils . is Blank ( key Binding Description ) ) { return _ NUM ; } else if ( key Binding Description . equals ( _ STR ) ) { return  SWT .  ESC ; } else if ( key Binding Description . equals ( _ STR ) ) { return  SWT .  F1 ; } else if ( key Binding Description . equals ( _ STR ) ) { return  SWT .  F2 ; } else if ( key Binding Description . equals ( _ STR ) ) { return  SWT .  F3 ; } else if ( key Binding Description . equals ( _ STR ) ) { return  SWT .  F4 ; } else if ( key Binding Description . equals ( _ STR ) ) { return  SWT .  F5 ; } else if ( key Binding Description . equals ( _ STR ) ) { return  SWT .  F6 ; } else if ( key Binding Description . equals ( _ STR ) ) { return  SWT .  F7 ; } else if ( key Binding Description . equals ( _ STR ) ) { return  SWT .  F8 ; } else if ( key Binding Description . equals ( _ STR ) ) { return  SWT .  F9 ; } else if ( key Binding Description . equals ( _ STR ) ) { return  SWT .  F10 ; } else if ( key Binding Description . equals ( _ STR ) ) { return  SWT .  F11 ; } else if ( key Binding Description . equals ( _ STR ) ) { return  SWT .  F12 ; } else if ( key Binding Description . equals ( _ STR ) ) { return  SWT .  SCROLL_ LOCK ; } else if (  VALID_ ACTION_ KEY_ CODES . index Of ( key Binding Description . char At ( key Binding Description . length ( ) - _ NUM ) ) != - _ NUM ) { return key Binding Description . char At ( key Binding Description . length ( ) - _ NUM ) ; } else { return _ NUM ; } }
public void test Put Cause Eviction ( ) {  List <  String > log = new  Array List <  String > ( ) ;  Lru Cache <  String ,  String > cache = new Removal Log Cache ( log ) ; cache . put ( _ STR , _ STR ) ; cache . put ( _ STR , _ STR ) ; cache . put ( _ STR , _ STR ) ; cache . put ( _ STR , _ STR ) ; assert Equals (  Arrays . as List ( _ STR ) , log ) ; assert Snapshot ( cache , _ STR , _ STR , _ STR , _ STR , _ STR , _ STR ) ; }
protected  Signature merge Signatures (  Signature first ,  Signature second , int num Bins ) { int d2 = - _ NUM ; for ( int i = _ NUM ; i < second . spec . length ; i += _ NUM ) { if ( second . spec [ i ] >= _ NUM ) { assert ( d2 == - _ NUM ) : _ STR ; d2 = i ; } } assert ( d2 >= _ NUM ) : _ STR ; if ( first . spec [ d2 ] >= _ NUM ) { return null ; } final  Modifiable DBIDs intersection =  DBIDUtil . intersection ( first . ids , second . ids ) ; final int support = intersection . size ( ) ; double width = ( second . spec [ d2 + _ NUM ] - second . spec [ d2 ] + _ NUM ) / ( double ) num Bins ; double expect = first . ids . size ( ) * width ; if ( support <= expect || support < min Cluster Size ) { return null ; } final double test =  Poisson Distribution . raw Probability ( support , expect ) ; if ( ( poisson Threshold ) <= test ) { return null ; } int [ ] spec = first . spec . clone ( ) ; spec [ d2 ] = second . spec [ d2 ] ; spec [ d2 + _ NUM ] = second . spec [ d2 ] ; final  Signature newsig = new  Signature ( spec , intersection ) ; if (  LOG . is Debugging ( ) ) {  LOG . debug ( newsig . to String ( ) ) ; } return newsig ; }
public  Ignite Deployment Exception (  Throwable cause ) { this ( cause . get Message ( ) , cause ) ; }
public synchronized boolean enter (  Cn ATree Element obj ) throws  Transaction Aborted Exception { if ( aborted ) { throw new  Transaction Aborted Exception ( ) ; } visited . add ( obj ) ; if ( this . initiator != null ) { return _ BOOL ; } this . initiator = obj ; aborted = _ BOOL ; return _ BOOL ; }
public  Options add Option (  Option opt ) {  String key = opt . get Key ( ) ; if ( opt . has Long Opt ( ) ) { long Opts . put ( opt . get Long Opt ( ) , opt ) ; } if ( opt . is Required ( ) ) { if ( required Opts . contains ( key ) ) { required Opts . remove ( required Opts . index Of ( key ) ) ; } required Opts . add ( key ) ; } short Opts . put ( key , opt ) ; return this ; }
private void pause For Client To Join ( ) {  Wait . pause ( _ NUM ) ; }
public void property Change (  Property Change Event pce ) { if ( pce . get Property Name ( ) ==  Map Bean .  Background Property && background Slave ) { map . set Bckgrnd ( (  Paint ) pce . get New Value ( ) ) ; } }
public  Transition Builder add Frame ( int image Resource ) { m Frames . add ( image Resource ) ; return this ; }
public  Class < ? > [ ] scan For Classes (  String location ,  Class < ? > implemented Interface ) throws  Exception {  LOG . debug ( _ STR + location + _ STR + implemented Interface . get Name ( ) + _ STR ) ;  List <  Class < ? > > classes = new  Array List <  Class < ? > > ( ) ;  Set <  String > resource Names = find Resource Names ( location , _ STR , _ STR ) ; for (  String resource Name : resource Names ) {  String class Name = to Class Name ( resource Name ) ;  Class < ? > clazz = class Loader . load Class ( class Name ) ; if (  Modifier . is Abstract ( clazz . get Modifiers ( ) ) || clazz . is Enum ( ) || clazz . is Anonymous Class ( ) ) {  LOG . debug ( _ STR + class Name ) ; continue ; } if ( ! implemented Interface . is Assignable From ( clazz ) ) { continue ; } try {  Class Utils . instantiate ( class Name , class Loader ) ; } catch (  Exception e ) { throw new  Cassandra Migration Exception ( _ STR + class Name , e ) ; } classes . add ( clazz ) ;  LOG . debug ( _ STR + class Name ) ; } return classes . to Array ( new  Class < ? > [ classes . size ( ) ] ) ; }
private static boolean needs Skylight Update (  Fast Cube Block Access access ,  Mutable Block Pos pos ) { if ( access . get Block Light Opacity ( pos ) >= _ NUM ) { return _ BOOL ; } int computed Light = access . compute Light Value ( pos ) ; for (  Enum Facing facing :  Enum Facing . values ( ) ) { pos . move ( facing ) ; int current Light = access . get Light For (  Enum Sky Block .  SKY , pos ) ; int current Opacity =  Math . max ( _ NUM , access . get Block Light Opacity ( pos ) ) ; pos . move ( facing . get Opposite ( ) ) ; if ( computed Light == current Light - current Opacity ) { return _ BOOL ; } } return _ BOOL ; }
@  Override public  String to String ( ) {  String Buffer buffer = new  String Buffer ( _ STR ) ; buffer . append ( _ STR ) ; buffer . append ( grid X ) ; buffer . append ( _ STR ) ; buffer . append ( grid Y ) ; buffer . append ( _ STR ) ; buffer . append ( grid Width ) ; buffer . append ( _ STR ) ; buffer . append ( grid Height ) ; buffer . append ( _ STR ) ; buffer . append ( h Align ) ; buffer . append ( _ STR ) ; buffer . append ( v Align ) ; if ( !  EMPTY_ INSETS . equals ( insets ) ) { buffer . append ( _ STR ) ; buffer . append ( insets ) ; } buffer . append ( _ STR ) ; buffer . append ( honors Visibility ) ; buffer . append ( _ STR ) ; return buffer . to String ( ) ; }
private  Array List <  PROCLUSCluster > assign Points (  Array DBIDs m_current , long [ ] [ ] dimensions ,  Relation <  V > database ) {  Modifiable DBIDs [ ] cluster IDs = new  Modifiable DBIDs [ dimensions . length ] ; for ( int i = _ NUM ; i < m_current . size ( ) ; i ++ ) { cluster IDs [ i ] =  DBIDUtil . new Hash Set ( ) ; }  DBIDArray Iter m_i = m_current . iter ( ) ; for (  DBIDIter it = database . iter DBIDs ( ) ; it . valid ( ) ; it . advance ( ) ) {  V p = database . get ( it ) ; double min Dist =  Double .  Na N ; int best = - _ NUM , i = _ NUM ; for ( m_i . seek ( _ NUM ) ; m_i . valid ( ) ; m_i . advance ( ) , i ++ ) {  V m = database . get ( m_i ) ; double current Dist = manhattan Segmental Distance ( p , m , dimensions [ i ] ) ; if ( ! ( min Dist <= current Dist ) ) { min Dist = current Dist ; best = i ; } } assert best >= _ NUM ;  Modifiable DBIDs ids = cluster IDs [ best ] ; ids . add ( it ) ; }  Array List <  PROCLUSCluster > clusters = new  Array List < > ( m_current . size ( ) ) ; for ( int i = _ NUM ; i < dimensions . length ; i ++ ) {  Modifiable DBIDs object IDs = cluster IDs [ i ] ; if ( ! object IDs . is Empty ( ) ) { long [ ] cluster Dimensions = dimensions [ i ] ; double [ ] centroid =  Centroid . make ( database , object IDs ) . get Array Ref ( ) ; clusters . add ( new  PROCLUSCluster ( object IDs , cluster Dimensions , centroid ) ) ; } else { clusters . add ( null ) ; } } if (  LOG . is Debugging ( ) ) {  String Builder msg = new  String Builder ( ) ; msg . append ( _ STR ) ; msg . append ( _ STR ) . append ( clusters ) . append ( _ STR ) ;  LOG . debug Fine ( msg . to String ( ) ) ; } return clusters ; }
public double slide Subtree (  Mutable Tree tree ) { double log Hastings Ratio ;  Node Ref i , new Parent , new Child ; do { i = tree . get Node (  Math Utils . next Int ( tree . get Node Count ( ) ) ) ; } while ( tree . get Root ( ) == i ) ;  Node Ref i P = tree . get Parent ( i ) ;  Node Ref  Ci P = get Other Child ( tree , i P , i ) ;  Node Ref  Pi P = tree . get Parent ( i P ) ; double delta = get Delta ( ) ; double old Height = tree . get Node Height ( i P ) ; double new Height = old Height + delta ; if ( delta > _ NUM ) { if (  Pi P != null && tree . get Node Height (  Pi P ) < new Height ) { new Parent =  Pi P ; new Child = i P ; while ( tree . get Node Height ( new Parent ) < new Height ) { new Child = new Parent ; new Parent = tree . get Parent ( new Parent ) ; if ( new Parent == null ) break ; } tree . begin Tree Edit ( ) ; if ( tree . is Root ( new Child ) ) { tree . remove Child ( i P ,  Ci P ) ; tree . remove Child (  Pi P , i P ) ; tree . add Child ( i P , new Child ) ; tree . add Child (  Pi P ,  Ci P ) ; tree . set Root ( i P ) ; } else { tree . remove Child ( i P ,  Ci P ) ; tree . remove Child (  Pi P , i P ) ; tree . remove Child ( new Parent , new Child ) ; tree . add Child ( i P , new Child ) ; tree . add Child (  Pi P ,  Ci P ) ; tree . add Child ( new Parent , i P ) ; } tree . set Node Height ( i P , new Height ) ; tree . end Tree Edit ( ) ; int possible Sources = intersecting Edges ( tree , new Child , old Height , null ) ; log Hastings Ratio =  Math . log ( _ NUM / ( double ) possible Sources ) ; } else { tree . set Node Height ( i P , new Height ) ; log Hastings Ratio = _ NUM ; } } else { if ( tree . get Node Height ( i ) > new Height ) { return  Double .  NEGATIVE_ INFINITY ; } if ( tree . get Node Height (  Ci P ) > new Height ) {  Array List new Children = new  Array List ( ) ; int possible Destinations = intersecting Edges ( tree ,  Ci P , new Height , new Children ) ; if ( new Children . size ( ) == _ NUM ) { return  Double .  NEGATIVE_ INFINITY ; } int child Index =  Math Utils . next Int ( new Children . size ( ) ) ; new Child = (  Node Ref ) new Children . get ( child Index ) ; new Parent = tree . get Parent ( new Child ) ; tree . begin Tree Edit ( ) ; if ( tree . is Root ( i P ) ) { tree . remove Child ( i P ,  Ci P ) ; tree . remove Child ( new Parent , new Child ) ; tree . add Child ( i P , new Child ) ; tree . add Child ( new Parent , i P ) ; tree . set Root (  Ci P ) ; } else { tree . remove Child ( i P ,  Ci P ) ; tree . remove Child (  Pi P , i P ) ; tree . remove Child ( new Parent , new Child ) ; tree . add Child ( i P , new Child ) ; tree . add Child (  Pi P ,  Ci P ) ; tree . add Child ( new Parent , i P ) ; } tree . set Node Height ( i P , new Height ) ; tree . end Tree Edit ( ) ; log Hastings Ratio =  Math . log ( ( double ) possible Destinations ) ; } else { tree . set Node Height ( i P , new Height ) ; log Hastings Ratio = _ NUM ; } } return log Hastings Ratio ; }
public boolean is Initialized ( ) { return _initialized ; }
public  String to String ( ) { return  Double . to String ( get ( ) ) ; }
boolean check Camera Size (  Camera Options camera Id ) { boolean size Available = _ BOOL ;  Camera camera = null ;  Method method = get Camera Open Method ( ) ; if ( method != null ) { try { camera = (  Camera ) method . invoke ( camera , new  Object [ ] { camera Id . get Value ( ) } ) ; } catch (  Exception e ) { camera =  Camera . open ( ) ; } } else { camera =  Camera . open ( ) ; } if ( camera == null ) { return _ BOOL ; }  Parameters param = camera . get Parameters ( ) ;  List <  Camera .  Size > sizes = param . get Supported Preview Sizes ( ) ; for (  Camera .  Size size : sizes ) { if ( ( size . width ==  H264 Config .  QVGA_ WIDTH && size . height ==  H264 Config .  QVGA_ HEIGHT ) || ( size . width ==  H264 Config .  CIF_ WIDTH && size . height ==  H264 Config .  CIF_ HEIGHT ) || ( size . width ==  H264 Config .  VGA_ WIDTH && size . height ==  H264 Config .  VGA_ HEIGHT ) ) { size Available = _ BOOL ; break ; } } camera . release ( ) ; return size Available ; }
public void append ( final  String s ) { if ( first ) { first = _ BOOL ; } else { builder . append ( space ) ; } builder . append ( s ) ; }
public static  Byte Array Output Stream encode (  String plaintext ) throws  IOException ,  Messaging Exception {  Byte Array Output Stream out = new  Byte Array Output Stream ( ) ; byte [ ] in = plaintext . get Bytes ( ) ;  Byte Array Output Stream in Stream = new  Byte Array Output Stream ( ) ; in Stream . write ( in , _ NUM , in . length ) ; if ( ( in . length % _ NUM ) == _ NUM ) { in Stream . write ( _ NUM ) ; in Stream . write ( _ NUM ) ; } else if ( ( in . length % _ NUM ) == _ NUM ) { in Stream . write ( _ NUM ) ; } in Stream . write To (  Mime Utility . encode ( out , _ STR ) ) ; return out ; }
public  Lookup List Table lookup List ( ) { if ( lookup List Table . get ( ) == null ) { lookup List Table . compare And Set ( null , gsub . create Lookup List ( ) ) ; } return lookup List Table . get ( ) ; }
public long sum ( ) { return delta Sum . get ( ) ; }
private static boolean is Word Boundary (  Char Sequence single Char ,  String word Separators ) { return  Text Utils . is Empty ( single Char ) || word Separators . contains ( single Char ) ; }
public void execute Blocking (  String desc ,  Blocking Consumer <  Mongo Client > operation ) throws  Interrupted Exception { while ( _ BOOL ) {  Mongo Client primary = primary Connection Supplier . get ( ) ; try { operation . accept ( primary ) ; return ; } catch (  Throwable t ) { error Handler . accept ( desc , t ) ; } } }
public void write ( char [ ] cbuf ) throws java . io .  IOException { write ( cbuf , _ NUM , cbuf . length ) ; }
protected  Table Viewer create Table (  Composite parent , int span ) {  Table table = new  Table ( parent ,  SWT .  H_ SCROLL |  SWT .  V_ SCROLL |  SWT .  BORDER |  SWT .  SINGLE |  SWT .  FULL_ SELECTION ) ;  Grid Data data = new  Grid Data (  Grid Data .  FILL_ BOTH |  Grid Data .  GRAB_ HORIZONTAL ) ; data . horizontal Span = span ; table . set Layout Data ( data ) ;  Table Layout layout = new  Table Layout ( ) ; layout . add Column Data ( new  Column Weight Data ( _ NUM , _ BOOL ) ) ; table . set Layout ( layout ) ;  Table Column col = new  Table Column ( table ,  SWT .  NONE ) ; col . set Resizable ( _ BOOL ) ; return new  Table Viewer ( table ) ; }
public  String type As String ( ) {  String type Str = _ STR ;  String subtype Str = _ STR ; switch ( this . type ) { case  ETYPE_ CONTROL : type Str = _ STR ; switch ( this . subtype ) { case  ESTYPE_ HEADER : subtype Str = _ STR ; break ; case  ESTYPE_ FOOTER : subtype Str = _ STR ; break ; } break ; case  ETYPE_ TRANSACTIONS : type Str = _ STR ; switch ( this . subtype ) { case  ESTYPE_ TRAN_ START : subtype Str = _ STR ; break ; case  ESTYPE_ TRAN_ COMMIT : subtype Str = _ STR ; break ; case  ESTYPE_ TRAN_ ROLLBACK : subtype Str = _ STR ; break ; case  ESTYPE_ TRAN_ ROLLBACK_ TO_ SAVEPOINT : subtype Str = _ STR ; break ; case  ESTYPE_ TRAN_ AUDIT : subtype Str = _ STR ; break ; } break ; case  ETYPE_ LCR_ DATA : type Str = _ STR ; switch ( this . subtype ) { case  ESTYPE_ LCR_ INSERT : subtype Str = _ STR ; break ; case  ESTYPE_ LCR_ DELETE : subtype Str = _ STR ; break ; case  ESTYPE_ LCR_ UPDATE : subtype Str = _ STR ; break ; case  ESTYPE_ LCR_ LOB_ WRITE : subtype Str = _ STR ; break ; case  ESTYPE_ LCR_ LOB_ TRIM : subtype Str = _ STR ; break ; case  ESTYPE_ LCR_ LOB_ ERASE : subtype Str = _ STR ; break ; case  ESTYPE_ LCR_ DDL : subtype Str = _ STR ; break ; } break ; case  ETYPE_ LCR_ PLOG : type Str = _ STR ; switch ( this . subtype ) { case  ESTYPE_ LCR_ PLOG_ IFILE : subtype Str = _ STR ; break ; case  ESTYPE_ LCR_ PLOG_ IFILE_ STATS : subtype Str = _ STR ; break ; } break ; default : type Str = _ STR + this . type + _ STR ; subtype Str = _ STR + this . subtype ; } return type Str + subtype Str ; }
protected boolean [ ] can Handle Missing ( boolean nominal Predictor , boolean numeric Predictor , boolean string Predictor , boolean date Predictor , boolean relational Predictor , boolean multi Instance , int class Type , boolean predictor Missing , boolean class Missing , int missing Level ) { if ( missing Level == _ NUM ) { print ( _ STR ) ; } print ( _ STR ) ; if ( predictor Missing ) { print ( _ STR ) ; if ( class Missing ) { print ( _ STR ) ; } } if ( class Missing ) { print ( _ STR ) ; } print ( _ STR ) ; print Attribute Summary ( nominal Predictor , numeric Predictor , string Predictor , date Predictor , relational Predictor , multi Instance , class Type ) ; print ( _ STR ) ;  Array List <  String > accepts = new  Array List <  String > ( ) ; accepts . add ( _ STR ) ; accepts . add ( _ STR ) ; accepts . add ( _ STR ) ; int num Train = get Num Instances ( ) , num Test = get Num Instances ( ) , num Classes = _ NUM ; return run Basic Test ( nominal Predictor , numeric Predictor , string Predictor , date Predictor , relational Predictor , multi Instance , class Type , missing Level , predictor Missing , class Missing , num Train , num Test , num Classes , accepts ) ; }
private void disable Buttons ( ) { for (  Deploy Command cmd :  Deploy Command . values ( ) ) { set Button Enabled ( cmd , _ BOOL ) ; } but Done . set Enabled ( _ BOOL ) ; set Load Enabled ( _ BOOL ) ; set Unload Enabled ( _ BOOL ) ; set Assault Drop Enabled ( _ BOOL ) ; }
public  Artifact load (  File path ) throws  IOException { return load ( new  Artifact Name ( path . get Name ( ) ) , path ) ; }
private static final boolean is Header End (  String Builder sb ) { int len = sb . length ( ) ; if ( len > _ NUM ) { if (  LF2 . equals ( sb . substring ( len - _ NUM ) ) ) { return _ BOOL ; } } if ( len > _ NUM ) { if (  CRLF2 . equals ( sb . substring ( len - _ NUM ) ) ) { return _ BOOL ; } } return _ BOOL ; }
@  Override public  Enumeration <  Option > list Options ( ) {  Vector <  Option > result = new  Vector <  Option > ( ) ; result . add Element ( new  Option ( _ STR , _ STR , _ NUM , _ STR ) ) ; result . add Element ( new  Option ( _ STR , _ STR , _ NUM , _ STR ) ) ; result . add Element ( new  Option ( _ STR , _ STR , _ NUM , _ STR ) ) ; result . add Element ( new  Option ( _ STR , _ STR , _ NUM , _ STR ) ) ; result . add ( new  Option ( _ STR + _ STR + _ STR , _ STR , _ NUM , _ STR ) ) ; result . add Element ( new  Option ( _ STR , _ STR , _ NUM , _ STR ) ) ; return result . elements ( ) ; }
public  TSAction Delay (  Transit Section Action tsa , int delay ) { _tsa = tsa ; _delay = delay ; }
public  DAdd Extensions (  JDialog parent ,  X509 Extension Set extensions ,  Public Key authority Public Key ,  X500 Name authority Cert Name ,  Big Integer authority Cert Serial Number ,  Public Key subject Public Key ) { super ( parent ,  Dialog .  Modality Type .  DOCUMENT_ MODAL ) ; set Title ( res . get String ( _ STR ) ) ; this . extensions = (  X509 Extension Set ) extensions . clone ( ) ; this . authority Public Key = authority Public Key ; this . authority Cert Name = authority Cert Name ; this . authority Cert Serial Number = authority Cert Serial Number ; this . subject Public Key = subject Public Key ; init Components ( ) ; }
public void add (  IMulti Point pt ) { if ( in Progress ) { throw new  Concurrent Modification Exception ( _ STR ) ; } points . add ( pt ) ; }
private  Discovery Information verify Discovered (  Auth Success auth Resp ,  Discovery Information discovered ) throws  Discovery Exception { if ( auth Resp == null || auth Resp . get Identity ( ) == null ) { _log . info ( _ STR ) ; return null ; } if ( auth Resp . is Version2 ( ) ) return verify Discovered2 ( auth Resp , discovered ) ; else return verify Discovered1 ( auth Resp , discovered ) ; }
public boolean generate (  Report Description description ,  Date date ) { try {  Integer target Date Int =  Integer . parse Int ( format . format ( date ) ) ;  Analysis Result Set log Aggregation = make Log Anal ( description , target Date Int ) ;  Report report = new  Report ( ) ; report . set Send Time ( new  Date ( ) ) ; report . set Target Date ( date ) ; report . set Log Report ( log Aggregation ) ; report . set Targets ( description . get Targets ( ) ) ; logger . debug ( _ STR + report ) ; report Repository . save ( report ) ; return _ BOOL ; } catch (  Exception e ) { logger . error ( e . get Message ( ) , e ) ; return _ BOOL ; } }
@  Override public void update Text Views (  Recharge recharge ) { unit Type Text View . set Text ( recharge . get Units ( ) ) ; unit Value Text View . set Text (  String . value Of ( recharge . get Current Amount ( ) ) ) ; cost Text View . set Text (  Currency . localize ( recharge . get Current Cost ( ) , _ BOOL ) ) ; recharge Name . set Text ( recharge . get Title ( ) ) ; confirmation Text View . set Text ( _ STR + recharge . get Current Amount ( ) + _ STR + recharge . get Units ( ) + _ STR ) ; if ( recharge . get Current Amount ( ) == recharge . get Initial Amount ( ) ) { down Arrow . set Visibility (  View .  INVISIBLE ) ; } else { down Arrow . set Visibility (  View .  VISIBLE ) ; } }
private  Concurrent Map <  Grid Cache Version ,  Ignite Internal Tx > transaction Map (  Ignite Internal Tx tx ) { return ( tx . near ( ) && ! tx . local ( ) ) ? near Id Map : id Map ; }
public static byte [ ] decode ( byte [ ] data ,  String pri_key ) { try {  Cipher cipher =  Cipher . get Instance ( _ STR ) ; java . security .  Key k = get Private Key ( pri_key ) ; cipher . init (  Cipher .  DECRYPT_ MODE , k ) ; byte [ ] de Bytes = cipher . do Final ( data ) ; return de Bytes ; } catch (  Exception e ) { log . error ( pri_key , e ) ; } return null ; }
public static int derive ARGB (  Color color1 ,  Color color2 , float mid Point ) { int r = color1 . get Red ( ) + ( int ) ( ( color2 . get Red ( ) - color1 . get Red ( ) ) * mid Point + _ NUM ) ; int g = color1 . get Green ( ) + ( int ) ( ( color2 . get Green ( ) - color1 . get Green ( ) ) * mid Point + _ NUM ) ; int b = color1 . get Blue ( ) + ( int ) ( ( color2 . get Blue ( ) - color1 . get Blue ( ) ) * mid Point + _ NUM ) ; int a = color1 . get Alpha ( ) + ( int ) ( ( color2 . get Alpha ( ) - color1 . get Alpha ( ) ) * mid Point + _ NUM ) ; return ( ( a & _ NUM ) << _ NUM ) | ( ( r & _ NUM ) << _ NUM ) | ( ( g & _ NUM ) << _ NUM ) | ( b & _ NUM ) ; }
public void add Landing Pad ( int x , int z ) {  Block Position pos = new  Block Position ( x , _ NUM , z ) ; if ( ! spawn Locations . contains ( pos ) ) { spawn Locations . add ( pos ) ; occupied Landing Pads . put ( pos , _ BOOL ) ; } }
static  Attack Strategy create (  String params ) {  String [ ] arg = params . split ( _ STR , - _ NUM ) ; if ( arg . length != _ NUM ) { throw new  Illegal Argument Exception ( _ STR + params + _ STR ) ; }  Pair <  String ,  String > desc = parse Strategy ( arg [ _ NUM ] ) ;  Target Selection Strategy targeter =  Target Selection Strategy Factory . get ( desc . first ( ) , desc . second ( ) ) ; desc = parse Strategy ( arg [ _ NUM ] ) ;  Positioning Strategy positioner =  Positioning Strategy Factory . get ( desc . first ( ) , desc . second ( ) ) ; return new  Compound Attack Strategy ( get Sub Strategy ( arg [ _ NUM ] ) , targeter , positioner ) ; }
final public void write Chunk (  L locator ,  KVO <  O > [ ] chunk ) throws  Mock Stale Locator Exception { synchronized ( this ) { if ( stale Locators . contains ( locator . get Partition Id ( ) ) ) { throw new  Mock Stale Locator Exception ( locator ) ; } if ( ! known Locators . contains ( locator . get Partition Id ( ) ) ) { throw new  Runtime Exception ( _ STR + locator ) ; } } accept Write ( locator , chunk ) ; }
public  Event event ( int id ) { if ( ! host ) { return (  Event ) events . get ( new  Integer ( id ) ) ; } return null ; }
private void init Values ( ) {  IPreference Store store = do Get Preference Store ( ) ; final  String stored Items = store . get String (  Checker Preferences .  PREF_ CHECKER_ CUSTOM_ CLASSES ) ; if ( ! stored Items . equals ( _ STR ) ) { custom Checkers . set Items ( stored Items . split ( _ STR ) ) ; } }
void sync ( int source Repo Index , int dest Repo Index ,  Authentication Info subject ) throws  IOException {  LOG . info ( _ STR ) ;  Notebook Authorization auth =  Notebook Authorization . get Instance ( ) ;  Notebook Repo src Repo = get Repo ( source Repo Index ) ;  Notebook Repo dst Repo = get Repo ( dest Repo Index ) ;  List <  Note Info > all Src Notes = src Repo . list ( subject ) ;  List <  Note Info > src Notes = auth . filter By User ( all Src Notes , subject ) ;  List <  Note Info > dst Notes = dst Repo . list ( subject ) ;  Map <  String ,  List <  String > > note Ids = notes Check Diff ( src Notes , src Repo , dst Notes , dst Repo , subject ) ;  List <  String > push Note Ids = note Ids . get ( push Key ) ;  List <  String > pull Note Ids = note Ids . get ( pull Key ) ;  List <  String > del Dst Note Ids = note Ids . get ( del Dst Key ) ; if ( ! push Note Ids . is Empty ( ) ) {  LOG . info ( _ STR ) ; for (  String id : push Note Ids ) {  LOG . info ( _ STR + id ) ; } push Notes ( subject , push Note Ids , src Repo , dst Repo , _ BOOL ) ; } else {  LOG . info ( _ STR ) ; } if ( ! pull Note Ids . is Empty ( ) ) {  LOG . info ( _ STR ) ; for (  String id : pull Note Ids ) {  LOG . info ( _ STR + id ) ; } push Notes ( subject , pull Note Ids , dst Repo , src Repo , _ BOOL ) ; } else {  LOG . info ( _ STR ) ; } if ( ! del Dst Note Ids . is Empty ( ) ) {  LOG . info ( _ STR ) ; for (  String id : del Dst Note Ids ) {  LOG . info ( _ STR + id ) ; } delete Notes ( subject , del Dst Note Ids , dst Repo ) ; } else {  LOG . info ( _ STR ) ; }  LOG . info ( _ STR ) ; }
public void list (  Print Stream out ) { out . println ( _ STR ) ;  Hashtable <  String ,  Object > h = new  Hashtable < > ( ) ; enumerate ( h ) ; for (  Enumeration <  String > e = h . keys ( ) ; e . has More Elements ( ) ; ) {  String key = e . next Element ( ) ;  String val = (  String ) h . get ( key ) ; if ( val . length ( ) > _ NUM ) { val = val . substring ( _ NUM , _ NUM ) + _ STR ; } out . println ( key + _ STR + val ) ; } }
@  Nullable public static  String md5 ( @  Nullable  File file , @  Nullable  Ignite Logger log ) { if ( file != null ) return file . is File ( ) ? file Md5 ( file , log ) : directory Md5 ( file , log ) ; return null ; }
@  Override public boolean has Next ( ) { if ( all Rows Result . size ( ) == _ NUM ) { return _ BOOL ; } total Record Counter ++ ; list Record Counter ++ ; if ( list Record Counter == _ NUM || ( list Record Counter >= current Row Pointer . size ( ) && current List Counter < all Rows Result . size ( ) ) ) { list Record Counter = _ NUM ; current Row Pointer = all Rows Result . get ( current List Counter ) ; current List Counter ++ ; } return total Record Counter < total Number Of Records ; }
public void trim To Size ( ) { delegate . trim To Size ( ) ; }
public final void clear ( ) { caches . clear ( ) ; sections . clear ( ) ; }
static  Set <  Node > to Node Set (  Iterator <  Node > i ) {  Set <  Node > node Set = new  Hash Set <  Node > ( ) ; while ( i . has Next ( ) ) {  Node n = i . next ( ) ; node Set . add ( n ) ; if ( n . get Node Type ( ) ==  Node .  ELEMENT_ NODE ) {  Named Node Map nnm = n . get Attributes ( ) ; for ( int j = _ NUM , length = nnm . get Length ( ) ; j < length ; j ++ ) { node Set . add ( nnm . item ( j ) ) ; } } } return node Set ; }
public static void run Concurrently ( final  Callable <  Void > task , final int times ) throws  Exception { final  Executor Service service =  Executors . new Fixed Thread Pool ( _ NUM ) ; final  List <  Future < ? > > futures = new  Array List <  Future < ? > > ( ) ; for ( int i = _ NUM ; i < times ; i ++ ) { futures . add ( service . submit ( task ) ) ; } for ( final  Future < ? > future : futures ) { future . get ( ) ; } }
private static  Array List <  Container Vm > create Vm List ( int broker Id , int container Vms Number ) {  Array List <  Container Vm > container Vms = new  Array List <  Container Vm > ( ) ; for ( int i = _ NUM ; i < container Vms Number ; ++ i ) {  Array List <  Container Pe > pe List = new  Array List <  Container Pe > ( ) ; int vm Type = i / ( int )  Math . ceil ( ( double ) container Vms Number / _ NUM ) ; for ( int j = _ NUM ; j <  Constants Examples .  VM_ PES [ vm Type ] ; ++ j ) { pe List . add ( new  Container Pe ( j , new  Cotainer Pe Provisioner Simple ( ( double )  Constants Examples .  VM_ MIPS [ vm Type ] ) ) ) ; } container Vms . add ( new  Power Container Vm (  IDs . poll Id (  Container Vm . class ) , broker Id , ( double )  Constants Examples .  VM_ MIPS [ vm Type ] , ( float )  Constants Examples .  VM_ RAM [ vm Type ] ,  Constants Examples .  VM_ BW ,  Constants Examples .  VM_ SIZE , _ STR , new  Container Scheduler Time Shared Over Subscription ( pe List ) , new  Container Ram Provisioner Simple (  Constants Examples .  VM_ RAM [ vm Type ] ) , new  Container Bw Provisioner Simple (  Constants Examples .  VM_ BW ) , pe List ,  Constants Examples .  SCHEDULING_ INTERVAL ) ) ; } return container Vms ; }
public static void add Port Use (  Map <  Storage Port ,  Integer > port Use Counts ,  Storage Port port ) { if ( ! port Use Counts . contains Key ( port ) ) { port Use Counts . put ( port , _ NUM ) ; } else {  Integer new Count = port Use Counts . get ( port ) + _ NUM ; port Use Counts . put ( port , new Count ) ; } }
@  Override public synchronized  Cache Object <  V > put (  K key ,  Cache Object <  V > value ) { if ( cache . size ( ) >= max Size ) { if ( remove Expired ( ) <= _ NUM ) { if ( cache Full Remove Type instanceof  Remove Type Not Remove ) { return null ; } if ( full Remove One ( ) == null ) { return null ; } } } value . set Enter Time (  System . current Time Millis ( ) ) ; cache . put ( key , value ) ; return value ; }
public void remove Model Change (  String table Name ,  Model Validator listener ) { if ( table Name == null || listener == null ) return ;  String property Name = m_global Validators . contains ( listener ) ? table Name + _ STR : table Name + listener . get AD_ Client_ ID ( ) ;  Array List <  Model Validator > list = m_model Change Listeners . get ( property Name ) ; if ( list == null ) return ; list . remove ( listener ) ; if ( list . size ( ) == _ NUM ) m_model Change Listeners . remove ( property Name ) ; }
private  String create Connection Name ( ) {  String Builder name Buffer = new  String Builder ( ) ; name Buffer . append ( get Connection Type ( ) ) ; name Buffer . append ( _ STR ) ; name Buffer . append ( _host ) ; name Buffer . append ( _ STR ) ; name Buffer . append ( _port ) ; return name Buffer . to String ( ) ; }
public  Query execute (  Page Context pc ,  SQL sql , int maxrows , int fetchsize ,  Time Span timeout ) throws  Page Exception {  Stopwatch stopwatch = new  Stopwatch (  Stopwatch .  UNIT_ NANO ) ; stopwatch . start ( ) ;  String pretty SQL = null ;  Selects selects = null ; try {  Select Parser parser = new  Select Parser ( ) ; selects = parser . parse ( sql . get SQLString ( ) ) ;  Query q = qoq . execute ( pc , sql , selects , maxrows ) ; q . set Execution Time ( stopwatch . time ( ) ) ; return q ; } catch (  SQLParser Exception spe ) { pretty SQL =  SQLPrettyfier . prettyfie ( sql . get SQLString ( ) ) ; try {  Query query = executer . execute ( pc , sql , pretty SQL , maxrows ) ; query . set Execution Time ( stopwatch . time ( ) ) ; return query ; } catch (  Page Exception ex ) { } } catch (  Page Exception e ) { } try { boolean is Union = _ BOOL ;  Set <  String > tables = null ; if ( selects != null ) {  HSQLUtil2 hsql2 = new  HSQLUtil2 ( selects ) ; is Union = hsql2 . is Union ( ) ; tables = hsql2 . get Invoked Tables ( ) ; } else { if ( pretty SQL == null ) pretty SQL =  SQLPrettyfier . prettyfie ( sql . get SQLString ( ) ) ;  HSQLUtil hsql = new  HSQLUtil ( pretty SQL ) ; tables = hsql . get Invoked Tables ( ) ; is Union = hsql . is Union ( ) ; }  String str SQL =  String Util . replace ( sql . get SQLString ( ) , _ STR , _ STR , _ BOOL ) ; str SQL =  String Util . replace ( str SQL , _ STR , _ STR , _ BOOL ) ; sql . set SQLString ( str SQL ) ; return _execute ( pc , sql , maxrows , fetchsize , timeout , stopwatch , tables , is Union ) ; } catch (  Parse Exception e ) { throw new  Database Exception ( e . get Message ( ) , null , sql , null ) ; } }
@  POST @  Produces ( {  Media Type .  APPLICATION_ XML ,  Media Type .  APPLICATION_ JSON } ) @  Path ( _ STR ) @  Check Permission ( roles = {  Role .  TENANT_ ADMIN } ) public  Task Resource Rep discover Host ( @  Path Param ( _ STR )  URI id ) {  Arg Validator . check Field Uri Type ( id ,  Host . class , _ STR ) ;  Host host = query Object (  Host . class , id , _ BOOL ) ; return do Discover Host ( host ) ; }
public static final void read Fully (  Input Stream i , byte b [ ] , int off , int len ) throws  IOException { if ( len < _ NUM ) { throw new  Index Out Of Bounds Exception ( ) ; } int n = _ NUM ; while ( n < len ) { int count = i . read ( b , off + n , len - n ) ; if ( count < _ NUM ) { throw new  EOFException ( ) ; } n += count ; } }
private void draw Lines (  Canvas canvas ) { for ( int i = _ NUM ; i < connection Order . size ( ) - _ NUM ; i ++ ) { draw Line ( canvas , circles [ connection Order . get ( i ) ] , circles [ connection Order . get ( i + _ NUM ) ] ) ; } }
public static  File to File (  Java File Object java File Object ) { return new  File ( java File Object . get Name ( ) ) ; }
public  Writable Raster create Compatible Writable Raster ( int w , int h ) { int [ ] b Offs = { _ NUM , _ NUM , _ NUM } ; return  Raster . create Interleaved Raster (  Data Buffer .  TYPE_ BYTE , w , h , w * _ NUM , _ NUM , b Offs , null ) ; }
public static  Multi Segment Power Law Bipartite Graph build Random Multi Segment Bipartite Graph ( int max Num Segments , int max Num Edges Per Segment , int left Size , int right Size , double edge Probability ,  Random random ) {  Multi Segment Power Law Bipartite Graph multi Segment Power Law Bipartite Graph = new  Multi Segment Power Law Bipartite Graph ( max Num Segments , max Num Edges Per Segment , left Size / _ NUM , ( int ) ( right Size * edge Probability / _ NUM ) , _ NUM , right Size / _ NUM , ( int ) ( left Size * edge Probability / _ NUM ) , _ NUM , new  Identity Edge Type Mask ( ) , new  Null Stats Receiver ( ) ) ; for ( int i = _ NUM ; i < left Size ; i ++ ) { for ( int j = _ NUM ; j < right Size ; j ++ ) { if ( random . next Double ( ) < edge Probability ) { multi Segment Power Law Bipartite Graph . add Edge ( i , j , ( byte ) _ NUM ) ; } } } return multi Segment Power Law Bipartite Graph ; }
public static  String execute (  String command ) { return  Subprocess Uttility . execute ( command ) ; }
public synchronized void update Progress ( final int value ) { final  Thread t =  Thread . current Thread ( ) ; final  My Integer v = m Individual Thread Progress . get ( t ) ; if ( v == null ) { m Individual Thread Progress . put ( t , new  My Integer ( value ) ) ; } else { v . set Value ( value ) ; } if ( value > m Last Reported Progress ) { int min =  Integer .  MAX_ VALUE ; for ( final  My Integer m : m Individual Thread Progress . values ( ) ) { if ( m . get Value ( ) < min ) { min = m . get Value ( ) ; } } if ( min > m Last Reported Progress ) { m Last Reported Progress = min ;  Diagnostic . progress ( _ STR + min + _ STR + m Name ) ; } } }
private  Context Handler create Context Handler (  String directory , boolean is In Jar ,  File install Root Directory , int expires In Seconds ) { final  Context Handler context Handler = new  Context Handler ( ) ; final  Resource Handler resource Handler = new  Expires Resource Handler ( expires In Seconds ) ; final  String directory With Slash = _ STR + directory ; context Handler . set Context Path ( directory With Slash ) ;  Resource directory Resource = get Directory Resource ( directory , is In Jar , install Root Directory ) ; directory Resource = new  Js Minifying Resource ( directory Resource ) ; if ( is In Jar ) { directory Resource = new  Caching Resource ( directory Resource , directory With Slash ) ; } resource Handler . set Base Resource ( directory Resource ) ; if ( ! is In Jar ) { resource Handler . set Min Memory Mapped Content Length ( _ NUM ) ; } context Handler . set Handler ( resource Handler ) ; return context Handler ; }
public boolean starts With ( java . lang .  Char Sequence prefix ) { return starts With ( prefix , _ NUM ) ; }
private  List <  Container Initializer > jsp Initializers ( ) {  Jetty Jasper Initializer sci = new  Jetty Jasper Initializer ( ) ;  Container Initializer initializer = new  Container Initializer ( sci , null ) ;  List <  Container Initializer > initializers = new  Array List <  Container Initializer > ( ) ; initializers . add ( initializer ) ; return initializers ; }
public static  Temp Path create Directory ( ) throws  IOException { return wrap (  Files . create Temp Directory (  PREFIX ) ) ; }
public static  String to String ( int partition [ ] [ ] ) {  String Builder sb = new  String Builder ( ) ; sb . append ( _ STR ) ; for ( int i = _ NUM ; i < partition . length ; i ++ ) { sb . append ( _ STR +  Arrays . to String ( partition [ i ] ) ) ; } sb . append ( _ STR ) ; return sb . to String ( ) ; }
public static boolean is Category Child Of (  Servlet Request request ,  String parent Product Category Id ,  String product Category Id ) { return is Category Child Of ( (  Delegator ) request . get Attribute ( _ STR ) , (  Local Dispatcher ) request . get Attribute ( _ STR ) , parent Product Category Id , product Category Id ) ; }
@  Override public boolean input (  Instance instance ) { if ( get Input Format ( ) == null ) { throw new  Illegal State Exception ( _ STR ) ; } if ( m_ New Batch ) { reset Queue ( ) ; m_ New Batch = _ BOOL ; } push ( (  Instance ) instance . copy ( ) ) ; return _ BOOL ; }
public  Collection <  String > list Columns (  String table ) throws  Database Exception {  Collection <  String > result = new  Array List <  String > ( ) ;  Result Set rs = null ; try {  Database Meta Data dbm = connection . get Meta Data ( ) ; rs = dbm . get Columns ( null , null , table , null ) ; while ( rs . next ( ) ) { result . add ( rs . get String ( _ STR ) ) ; } } catch (  SQLException e ) { throw new  Database Exception ( e ) ; } finally { if ( rs != null ) { try { rs . close ( ) ; } catch (  SQLException e ) { } } } return result ; }
public void add Created Resource (  Location location ,  Resource resource ) { resource List . add ( resource ) ; location To Resource Map . put ( location , resource ) ; }
public void signal Event ( ) {  Collection <  Semaphore > semaphores = _semaphores . values ( ) ; for (  Semaphore semaphore : semaphores ) { semaphore . release ( ) ; semaphores . remove ( semaphore ) ; } }
@  Override public boolean equals (  Object obj ) { if ( obj == this ) { return _ BOOL ; } if ( ! ( obj instanceof  Keyed Objects ) ) { return _ BOOL ; }  Keyed Objects that = (  Keyed Objects ) obj ; int count = get Item Count ( ) ; if ( count != that . get Item Count ( ) ) { return _ BOOL ; } for ( int i = _ NUM ; i < count ; i ++ ) {  Comparable k1 = get Key ( i ) ;  Comparable k2 = that . get Key ( i ) ; if ( ! k1 . equals ( k2 ) ) { return _ BOOL ; }  Object o1 = get Object ( i ) ;  Object o2 = that . get Object ( i ) ; if ( o1 == null ) { if ( o2 != null ) { return _ BOOL ; } } else { if ( ! o1 . equals ( o2 ) ) { return _ BOOL ; } } } return _ BOOL ; }
protected boolean is Quorum Maintained ( ) { if ( node Count == _ NUM ) { log . info ( _ STR ) ; return _ BOOL ; } int quorum Node Cnt = node Count / _ NUM + _ NUM ;  Coordinator Client coordinator Client = coordinator . get Coordinator Client ( ) ;  List <  Service > all Active Dbsvcs = coordinator Client . locate All Svcs All Vers (  Constants .  DBSVC_ NAME ) ;  List <  String > other Active Dbsvc Ids = new  Array List < > ( ) ;  String my Svc Id = coordinator . get My Svc Id ( ) ;  String local Db Svc Id = _ STR + my Svc Id . substring ( my Svc Id . last Index Of ( _ STR ) ) ; for (  Service active Dbsvc : all Active Dbsvcs ) { if ( ! local Db Svc Id . equals ( active Dbsvc . get Id ( ) ) ) { other Active Dbsvc Ids . add ( active Dbsvc . get Id ( ) ) ; } } log . info ( _ STR , other Active Dbsvc Ids , quorum Node Cnt ) ; boolean is Maintained = other Active Dbsvc Ids . size ( ) >= quorum Node Cnt ; if ( ! is Maintained ) { log . info ( _ STR ) ; } return is Maintained ; }
public static void schedule Next Alarm (  Context context ) { schedule Next Alarm ( context ,  Alert Utils . create Alarm Manager ( context ) ,  REMINDER_ QUERY_ BATCH_ SIZE ,  System . current Time Millis ( ) ) ; }
public void request Stop ( ) { stop Requested . set ( _ BOOL ) ; }
@  Safe Varargs public static <  T >  T [ ] join (  Int Function <  T [ ] > array Function ,  T [ ] ... arrays ) { if ( arrays . length == _ NUM ) { return array Function . apply ( _ NUM ) ; } if ( arrays . length == _ NUM ) { return arrays [ _ NUM ] ; } if ( arrays . length == _ NUM ) { return join ( array Function , arrays [ _ NUM ] , arrays [ _ NUM ] ) ; }  T [ ] not Null = null ; int final Size = _ NUM ; int null Arrays = _ NUM ;  List <  T > list = new  Array List < > ( arrays . length * _ NUM ) ; for (  T [ ] array : arrays ) { if ( ( array == null ) || ( array . length == _ NUM ) ) { null Arrays ++ ; } else { not Null = array ; final Size += array . length ;  Collections . add All ( list , array ) ; } } if ( null Arrays == arrays . length ) { return array Function . apply ( _ NUM ) ; } if ( null Arrays == ( arrays . length - _ NUM ) ) { return not Null ; } return list . to Array ( array Function . apply ( list . size ( ) ) ) ; }
private static  Set <  String > split Path (  Relaxed URL url ) {  Set <  String > results = new  Hash Set <  String > ( ) ;  Set <  String > queries = normalize Query ( url . get Query ( ) ) ; results . add ( _ STR ) ; for (  String q : queries ) { results . add ( _ STR + q ) ; }  Set <  String > paths = split Path ( url . get Path ( ) ) ; results . add All ( paths ) ; for (  String p : paths ) { for (  String q : queries ) { results . add ( p + _ STR + q ) ; } } return results ; }
public  Action Forward init Best Selling Report (  Action Mapping mapping ,  Action Form form ,  Http Servlet Request request ,  Http Servlet Response response ) throws  Application Exception ,  Operation Exception {  Action Forward fwd = init ( mapping , form , request , response ) ; if ( fwd != null ) return fwd ;  Selling Item Form report Form = (  Selling Item Form ) form ;  String time Period =  Report Date Manager .  TODAY ;  String date Range =  Constants .  FIXED_ DATE_ RANGE ; report Form . set Time Period ( time Period ) ; report Form . set Date Range ( date Range ) ; report Form . set From Date ( _ STR ) ; report Form . set To Date ( _ STR ) ; report Form . validate ( mapping , request ) ; return mapping . find Forward (  INIT_ BEST_ SELLING_ REPORT ) ; }
@  Override public void transaction Begin ( ) { for (  Bigdata Graph Listener listener : listeners ) { listener . transaction Begin ( ) ; } }
public synchronized void add (  Job job ) { boolean can Run Immediately = dag Manager . add Job ( job ) ; if ( can Run Immediately ) {  LOG . debug ( _ STR + job + _ STR ) ; jobs To Run . add ( job ) ; } increment Submitted Job Count ( ) ; }
public void add Constant (  Constant Pool Entry entry ) { if ( entry instanceof  Utf8 Constant ) {  Utf8 Constant utf8 = (  Utf8 Constant ) entry ; _utf8 Map . put ( utf8 . get Value ( ) , utf8 ) ; } _entries . add ( entry ) ; }
static void write Rule (  Zone Offset Transition Rule rule ,  Data Output out ) throws  IOException { int month = rule . month ; byte dom = rule . dom ; int dow = rule . dow ;  Local Time time = rule . time ; boolean time End Of Day = rule . time End Of Day ;  Time Definition time Definition = rule . time Definition ;  Zone Offset standard Offset = rule . standard Offset ;  Zone Offset offset Before = rule . offset Before ;  Zone Offset offset After = rule . offset After ; int time Secs = ( time End Of Day ? _ NUM : time . to Second Of Day ( ) ) ; int std Offset = standard Offset . get Total Seconds ( ) ; int before Diff = offset Before . get Total Seconds ( ) - std Offset ; int after Diff = offset After . get Total Seconds ( ) - std Offset ; int time Byte = ( time Secs % _ NUM == _ NUM ? ( time End Of Day ? _ NUM : time . get Hour ( ) ) : _ NUM ) ; int std Offset Byte = ( std Offset % _ NUM == _ NUM ? std Offset / _ NUM + _ NUM : _ NUM ) ; int before Byte = ( before Diff == _ NUM || before Diff == _ NUM || before Diff == _ NUM ? before Diff / _ NUM : _ NUM ) ; int after Byte = ( after Diff == _ NUM || after Diff == _ NUM || after Diff == _ NUM ? after Diff / _ NUM : _ NUM ) ; int dow Byte = ( dow == - _ NUM ? _ NUM : dow ) ; int b = ( month << _ NUM ) + ( ( dom + _ NUM ) << _ NUM ) + ( dow Byte << _ NUM ) + ( time Byte << _ NUM ) + ( time Definition . ordinal ( ) << _ NUM ) + ( std Offset Byte << _ NUM ) + ( before Byte << _ NUM ) + after Byte ; out . write Int ( b ) ; if ( time Byte == _ NUM ) { out . write Int ( time Secs ) ; } if ( std Offset Byte == _ NUM ) { out . write Int ( std Offset ) ; } if ( before Byte == _ NUM ) { out . write Int ( offset Before . get Total Seconds ( ) ) ; } if ( after Byte == _ NUM ) { out . write Int ( offset After . get Total Seconds ( ) ) ; } }
@  Suppress Warnings ( _ STR ) public static <  T >  Type Serializer <  T > deserialize ( byte [ ] bytes ) throws  IOException {  Byte Array Input Stream bis = new  Byte Array Input Stream ( bytes ) ;  Object Input in = null ; try { in = new  Object Input Stream ( bis ) ; return (  Type Serializer <  T > ) in . read Object ( ) ; } catch (  Class Not Found Exception e ) { throw new  IOException ( _ STR ) ; } finally { try { bis . close ( ) ; } catch (  IOException ex ) { } try { if ( in != null ) { in . close ( ) ; } } catch (  IOException ex ) { } } }
public void test Remainder Knuth Multi Digits By One Digit ( ) { byte a Bytes [ ] = { _ NUM , - _ NUM , _ NUM , - _ NUM , _ NUM , - _ NUM , _ NUM , _ NUM , - _ NUM } ; byte b Bytes [ ] = { _ NUM , - _ NUM , - _ NUM , - _ NUM } ; int a Sign = _ NUM ; int b Sign = - _ NUM ; byte r Bytes [ ] = { _ NUM , - _ NUM , - _ NUM , _ NUM } ;  Big Integer a Number = new  Big Integer ( a Sign , a Bytes ) ;  Big Integer b Number = new  Big Integer ( b Sign , b Bytes ) ;  Big Integer result = a Number . remainder ( b Number ) ; byte res Bytes [ ] = new byte [ r Bytes . length ] ; res Bytes = result . to Byte Array ( ) ; for ( int i = _ NUM ; i < res Bytes . length ; i ++ ) { assert True ( res Bytes [ i ] == r Bytes [ i ] ) ; } assert Equals ( _ STR , _ NUM , result . signum ( ) ) ; }
public void show Selected Neuron Properties ( ) {  Neuron Dialog dialog =  Neuron Dialog . create Neuron Dialog ( get Selected Neurons ( ) ) ; dialog . set Modality Type (  Dialog .  Modality Type .  MODELESS ) ; dialog . pack ( ) ; dialog . set Location Relative To ( null ) ; dialog . set Visible ( _ BOOL ) ; }
public void encrypt ( byte [ ] in , int length ) { int pos = _ NUM ; while ( pos < in . length && pos < length ) { encrypt Block ( in , pos , length ) ; pos += block Size ; } }
private static boolean has Changes Of Children ( long last ,  Page Context pc ,  Class clazz ) { java . lang . reflect .  Method [ ] methods = clazz . get Methods ( ) ; java . lang . reflect .  Method method ;  Class [ ] params ; for ( int i = _ NUM ; i < methods . length ; i ++ ) { method = methods [ i ] ; if ( method . get Declaring Class ( ) == clazz ) { if ( _has Changes Of Children ( pc , last , method . get Return Type ( ) ) ) return _ BOOL ; params = method . get Parameter Types ( ) ; for ( int y = _ NUM ; y < params . length ; y ++ ) { if ( _has Changes Of Children ( pc , last , params [ y ] ) ) return _ BOOL ; } } } return _ BOOL ; }
private  Window Stuff Helper ( ) { }
public static  String remove Special Char (  String temp Str ) { if ( temp Str != null ) { temp Str = replace ( temp Str , _ STR , _ STR , _ BOOL , _ BOOL ) ; temp Str = replace ( temp Str , _ STR , _ STR , _ BOOL , _ BOOL ) ; temp Str = replace ( temp Str , _ STR , _ STR , _ BOOL , _ BOOL ) ; temp Str = replace ( temp Str , _ STR , _ STR , _ BOOL , _ BOOL ) ; temp Str = replace ( temp Str , _ STR , _ STR , _ BOOL , _ BOOL ) ; temp Str = replace ( temp Str , _ STR , _ STR , _ BOOL , _ BOOL ) ; temp Str = replace ( temp Str , _ STR , _ STR , _ BOOL , _ BOOL ) ; temp Str = replace ( temp Str , _ STR , _ STR , _ BOOL , _ BOOL ) ; temp Str = replace ( temp Str , _ STR , _ STR , _ BOOL , _ BOOL ) ; temp Str = replace ( temp Str , _ STR , _ STR , _ BOOL , _ BOOL ) ; temp Str = replace ( temp Str , _ STR , _ STR , _ BOOL , _ BOOL ) ; temp Str = replace ( temp Str , _ STR , _ STR , _ BOOL , _ BOOL ) ; temp Str = replace ( temp Str , _ STR , _ STR , _ BOOL , _ BOOL ) ; while ( temp Str . index Of ( _ STR ) > _ NUM ) { temp Str = replace ( temp Str , _ STR , _ STR , _ BOOL , _ BOOL ) ; } temp Str = replace ( temp Str , _ STR , _ STR , _ BOOL , _ BOOL ) ; } return temp Str ; }
public  Run Script Action (  Network Panel network Panel ) { super ( _ STR ) ; put Value (  SMALL_ ICON ,  Resource Manager . get Image Icon ( _ STR ) ) ; put Value (  SHORT_ DESCRIPTION , _ STR ) ; this . network Panel = network Panel ; }
public  T web Image (  String url ) { return web Image ( url , _ BOOL , _ BOOL , _ NUM ) ; }
private  Map <  Installment ,  List <  Receipt > > consolidate Tuples Installment Wise ( final  List <  Installment Receipt Tuple > tuples ) { final  Map <  Installment ,  List <  Receipt > > consolidated = new  Hash Map <  Installment ,  List <  Receipt > > ( ) ; for ( final  Installment Receipt Tuple t : tuples ) {  List <  Receipt > receipts For Installment = consolidated . get ( t . installment ) ; if ( receipts For Installment == null ) { receipts For Installment = new  Array List <  Receipt > ( ) ; consolidated . put ( t . installment , receipts For Installment ) ; } if ( ! receipts For Installment . contains ( t . receipt ) ) receipts For Installment . add ( t . receipt ) ; }  LOGGER . info ( _ STR + consolidated ) ; return consolidated ; }
public static boolean is Valid Email (  String email ) { final  String email Pattern = _ STR ;  Matcher matcher ;  Pattern pattern =  Pattern . compile ( email Pattern ) ; matcher = pattern . matcher ( email ) ; if ( matcher != null ) return matcher . matches ( ) ; else return _ BOOL ; }
public void add (  Line Merge Directed Edge directed Edge ) { directed Edges . add ( directed Edge ) ; }
public static  Application Xml parse Application Xml From File (  File file ,  Entity Resolver entity Resolver ) throws  IOException ,  JDOMException {  Input Stream in = null ; try { in = new  File Input Stream ( file ) ; return parse Application Xml ( in , entity Resolver ) ; } finally { if ( in != null ) { try { in . close ( ) ; } catch (  IOException ioe ) { } } } }
public  Channel Entry new Connection (  Read Selector Thread read Handler ,  Selection Key key ) {  Socket Channel channel = (  Socket Channel ) key . channel ( ) ;  Write Selector Thread write Handler = _selector Manager . get Write Handler ( key . channel ( ) ) ;  Socket socket = channel . socket ( ) ;  Inet Socket Address socket Address = (  Inet Socket Address ) ( socket == null ? null : socket . get Remote Socket Address ( ) ) ;  Channel Entry channel Entry = new  Channel Entry ( write Handler , read Handler , key , socket Address , this ) ; m_ Channels . put ( channel , channel Entry ) ; if ( socket Address != null ) { _client To Channel . put ( socket Address , channel Entry ) ; } if ( _logger . is Loggable (  Level .  FINE ) ) _logger . log (  Level .  FINE , _ STR + channel Entry . get Client End Point Address ( ) + _ STR ) ; return channel Entry ; }
public  String report ( ) {  String Buffer report = new  String Buffer ( ) ; int Hash Table = new int [ table . table Size ] ; calculate Slot Usage ( ) ; int max = max Collisions ( ) ; int [ ] slot Usage Count = new int [ max + _ NUM ] ; for ( int i : int Hash Table ) { slot Usage Count [ i ] ++ ; } report . append ( _ STR + num Entries + _ STR ) ; report . append ( _ STR + ( num Entries / ( _ NUM * table . table Size ) + _ STR ) ) ; float weighted Avg = _ NUM ; int num Non Empty = _ NUM ; report . append ( _ STR ) ; for ( int j = _ NUM ; j <= max ; j ++ ) { if ( slot Usage Count [ j ] != _ NUM ) { report . append ( j + _ STR + slot Usage Count [ j ] + _ STR ) ; if ( j != _ NUM ) { weighted Avg += slot Usage Count [ j ] * j ; num Non Empty += slot Usage Count [ j ] ; } } } weighted Avg /= num Non Empty ; report . append ( _ STR + min Collisions ( ) + _ STR + max + _ STR + weighted Avg ) ; return report . to String ( ) ; }
public void add Subscription To Store ( final  String topic , final  String client Id ) { final  Client Topic Couple subscription = new  Client Topic Couple ( client Id , topic ) ; if ( ! topics . contains ( subscription ) ) { logger . debug ( _ STR + topic + _ STR + client Id + _ STR ) ; subscriptions Store . add ( subscription ) ; topics . add ( topic ) ; } }
public boolean zip (  String zip Location ,  String to Be Zipped Name ) { boolean ret = _ BOOL ; if ( verbose )  Debug . put ( _ STR ) ;  File to Be Zipped = new  File ( to Be Zipped Name ) ; if ( to Be Zipped . exists ( ) ) { try {  File Utils . save Zip File ( zip Location , to Be Zipped ) ; ret = _ BOOL ; } catch (  File Not Found Exception e ) { e . print Stack Trace ( ) ; } catch (  IOException e ) { e . print Stack Trace ( ) ; } } return ret ; }
private  Hash Map <  Integer ,  Boolean > generate Expanded State Map ( ) {  Hash Map <  Integer ,  Boolean > parent List Item Hash Map = new  Hash Map < > ( ) ; int child Count = _ NUM ;  Object list Item ;  Parent Wrapper parent Wrapper ; int list Item Count = m Item List . size ( ) ; for ( int i = _ NUM ; i < list Item Count ; i ++ ) { if ( m Item List . get ( i ) != null ) { list Item = get List Item ( i ) ; if ( list Item instanceof  Parent Wrapper ) { parent Wrapper = (  Parent Wrapper ) list Item ; parent List Item Hash Map . put ( i - child Count , parent Wrapper . is Expanded ( ) ) ; } else { child Count ++ ; } } } return parent List Item Hash Map ; }
public void add Audio Packet Listener (  Listener <  Audio Packet > listener ) { m Audio Packet Broadcaster . add Listener ( listener ) ; }
public  Delta CRLIndicator Extension (  Boolean critical ,  Object value ) throws  IOException { super (  PKIXExtensions .  Delta CRLIndicator_ Id , critical . boolean Value ( ) , value ,  NAME ,  LABEL ) ; }
public  Java Environment (  File java Path ) {  Objects . require Non Null ( java Path ) ; this . java Path = java Path ; }
private  String print OFormat ( final long x ) {  String sx = null ; if ( x ==  Long .  MIN_ VALUE ) { sx = _ STR ; } else if ( x < _ NUM ) { final  String t =  Long . to String ( ( ~ ( - x - _ NUM ) ) ^  Long .  MIN_ VALUE , _ NUM ) ; switch ( t . length ( ) ) { case _ NUM : sx = _ STR + t ; break ; case _ NUM : sx = _ STR + t ; break ; case _ NUM : sx = _ STR + t ; break ; case _ NUM : sx = _ STR + t ; break ; case _ NUM : sx = _ STR + t ; break ; case _ NUM : sx = _ STR + t ; break ; case _ NUM : sx = _ STR + t ; break ; case _ NUM : sx = _ STR + t ; break ; case _ NUM : sx = _ STR + t ; break ; case _ NUM : sx = _ STR + t ; break ; case _ NUM : sx = _ STR + t ; break ; case _ NUM : sx = _ STR + t ; break ; case _ NUM : sx = _ STR + t ; break ; case _ NUM : sx = _ STR + t ; break ; case _ NUM : sx = _ STR + t ; break ; case _ NUM : sx = _ STR + t ; break ; case _ NUM : sx = _ STR + t ; break ; case _ NUM : sx = _ STR + t ; break ; case _ NUM : sx = _ STR + t ; break ; case _ NUM : sx = _ STR + t ; break ; case _ NUM : sx = _ STR + t ; break ; } } else { sx =  Long . to String ( x , _ NUM ) ; } return print OFormat ( sx ) ; }
void add Callback (  JSObject source ,  String method ,  JSFunction callback , boolean async ) {  String key = source . to JSPointer ( ) + _ STR + method ; callbacks . put ( key , callback ) ;  String id =  JSObject .  ID_ KEY ;  String self = source . to JSPointer ( ) ;  String js = self + _ STR + method + _ STR + _ STR + self + _ STR + method + _ STR + _ STR + _ STR + _ STR + _ STR + id + _ STR + _ STR + js Lookup Table + _ STR + js Lookup Table + _ STR + id + _ STR + js Lookup Table + _ STR + js Lookup Table + _ STR + id + _ STR + _ STR + _ STR + js Lookup Table + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR ; exec ( js , async ) ; }
public void remove All Blocks From Section ( ) { for ( int i = m Block Entries . size ( ) ; i > _ NUM ; i -- ) {  Block b = m Block Entries . get ( i - _ NUM ) ; if ( b != null ) { b . remove Property Change Listener ( m Block Listeners . get ( i - _ NUM ) ) ; } m Block Listeners . remove ( i - _ NUM ) ; m Block Entries . remove ( i - _ NUM ) ; } for ( int i = m Forward Entry Points . size ( ) ; i > _ NUM ; i -- ) { m Forward Entry Points . remove ( i - _ NUM ) ; } for ( int i = m Reverse Entry Points . size ( ) ; i > _ NUM ; i -- ) { m Reverse Entry Points . remove ( i - _ NUM ) ; } initialization Needed = _ BOOL ; }
public static void write String To File (  Path file ,  String text ) throws  IOException { byte [ ] buf = text . get Bytes (  Standard Charsets .  UTF_8 ) ;  Files . write ( file , buf ) ; }
private static boolean is Operator Variable Access ( final  INavi Operand Tree Node node ) { final  List <  INavi Operand Tree Node > children = node . get Children ( ) ; if ( children . size ( ) == _ NUM ) { final  INavi Operand Tree Node child0 = children . get ( _ NUM ) ; final  INavi Operand Tree Node child1 = children . get ( _ NUM ) ; return is Variable ( child0 ) ^ is Variable ( child1 ) ; } else { return _ BOOL ; } }
@  Override public void on Value Selected ( int picker Index , int new Value , boolean auto Advance ) { if ( picker Index ==  HOUR_ INDEX ) { set Hour ( new Value , _ BOOL ) ;  String announcement =  String . format ( _ STR , new Value ) ; if ( m Allow Auto Advance && auto Advance ) { set Current Item Showing (  MINUTE_ INDEX , _ BOOL , _ BOOL , _ BOOL ) ; announcement += _ STR + m Select Minutes ; } else { m Time Picker . set Content Description ( m Hour Picker Description + _ STR + new Value ) ; }  Utils . try Accessibility Announce ( m Time Picker , announcement ) ; } else if ( picker Index ==  MINUTE_ INDEX ) { set Minute ( new Value ) ; m Time Picker . set Content Description ( m Minute Picker Description + _ STR + new Value ) ; } else if ( picker Index ==  HALF_ DAY_ INDEX ) { update Half Day ( new Value ) ; } else if ( picker Index ==  ENABLE_ PICKER_ INDEX ) { if ( ! is Typed Time Fully Legal ( ) ) { m Typed Times . clear ( ) ; } finish Kb Mode ( _ BOOL ) ; } }
public static final  List <  Geo > segment Near Poly (  Geo s1 ,  Geo s2 ,  Geo Array r , double near ) { int rlen = r . get Size ( ) ;  Geo pl0 = r . get ( rlen - _ NUM , new  Geo ( ) ) ;  Geo pl1 = new  Geo ( ) ;  List <  Geo > list = null ;  Geo check = new  Geo ( ) ; for ( int j = _ NUM ; j < rlen ; j ++ ) { r . get ( j , pl1 ) ;  Geo ret = segments Intersect Or Near ( s1 , s2 , pl0 , pl1 , near , check ) ; if ( ret != null ) { if ( list == null ) { list = new  Linked List <  Geo > ( ) ; } list . add ( ret ) ; check = new  Geo ( ) ; } pl0 . initialize ( pl1 ) ; } return list ; }
public void add Action (  Update Action action ) { action List . add ( action ) ; for (  Update Manager Listener listener : listeners ) { listener . action Added ( action ) ; } }
public void load (  Data Input raf In ) throws  IOException ,  Mary Configuration Exception { int num Idx = raf In . read Int ( ) ; idx Interval = raf In . read Int ( ) ; if ( idx Interval <= _ NUM ) { throw new  Mary Configuration Exception ( _ STR ) ; } byte Ptrs = new long [ num Idx ] ; time Ptrs = new long [ num Idx ] ; int num Bytes To Read = _ NUM * num Idx + _ NUM ; byte [ ] data = new byte [ num Bytes To Read ] ; raf In . read Fully ( data ) ;  Data Input buf In = new  Data Input Stream ( new  Byte Array Input Stream ( data ) ) ; for ( int i = _ NUM ; i < num Idx ; i ++ ) { byte Ptrs [ i ] = buf In . read Long ( ) ; time Ptrs [ i ] = buf In . read Long ( ) ; if ( i > _ NUM ) { if ( byte Ptrs [ i ] < byte Ptrs [ i - _ NUM ] || time Ptrs [ i ] < time Ptrs [ i - _ NUM ] ) { throw new  Mary Configuration Exception ( _ STR ) ; } } } buf In . read Long ( ) ; buf In . read Long ( ) ; }
public void signoff (  String unique ID ) {  Debug . message ( _ STR , _ STR + unique ID + _ STR ) ; caches . remove ( unique ID ) ; view Attribute Lists . remove ( unique ID ) ; timestamps . remove ( unique ID ) ; }
private  String create Non CGSrdf Pair Steps On Empty Group (  List <  Volume Descriptor > source Descriptors ,  List <  Volume Descriptor > target Descriptors ,  Remote Director Group group ,  Map <  URI ,  Volume > uri Volume Map ,  String wait For ,  Workflow workflow ) {  Storage System system = db Client . query Object (  Storage System . class , group . get Source Storage System Uri ( ) ) ;  URI vpool Change Uri = get Virtual Pool Change Volume ( source Descriptors ) ; log . info ( _ STR , vpool Change Uri ) ;  List <  URI > source URIs =  Volume Descriptor . get Volume URIs ( source Descriptors ) ;  List <  URI > target URIs = new  Array List < > ( ) ; for (  URI source URI : source URIs ) {  Volume source = uri Volume Map . get ( source URI ) ;  String Set srdf Targets = source . get Srdf Targets ( ) ; for (  String target Str : srdf Targets ) {  URI target URI =  URI . create ( target Str ) ; target URIs . add ( target URI ) ; } }  Method create List Method = create List Replicas Method ( system . get Id ( ) , source URIs , target URIs , vpool Change Uri , _ BOOL ) ;  Method rollback Method = rollback SRDFLinks Method ( system . get Id ( ) , source URIs , target URIs , _ BOOL ) ;  String step Id = workflow . create Step (  CREATE_ SRDF_ ACTIVE_ VOLUME_ PAIR_ STEP_ GROUP ,  CREATE_ SRDF_ ACTIVE_ VOLUME_ PAIR_ STEP_ DESC , wait For , system . get Id ( ) , system . get System Type ( ) , get Class ( ) , create List Method , rollback Method , null ) ; return step Id ; }
public static  Long downsampler Timestamp (  Long millitimestamp , long window Size ) { return millitimestamp - ( millitimestamp % window Size ) ; }
@  Override public  String to String ( ) { if ( points == null || points . length ( ) == _ NUM ) { return idx + _ STR ; }  String Buffer bf = new  String Buffer ( ) ; try { bf . append ( idx + _ STR ) ;  List Node temp ; for ( int i = _ NUM ; i < points . size ( ) ; i ++ ) { temp = points . get ( i ) ; if ( i == _ NUM ) { bf . append ( _ STR + temp . idx ) ; } else { bf . append ( _ STR + temp . idx ) ; } } } catch (  Exception ex ) { ex . print Stack Trace ( ) ; } return bf . to String ( ) ; }
public  IStatus run (  IProgress Monitor monitor ) throws  Invocation Target Exception {  Zip File zip File = null ;  File Output Stream fos = null ;  Buffered Output Stream dest = null ;  Buffered Input Stream is = null ; job Status =  Status .  OK_ STATUS ; try { zip File = new  Zip File ( archive ) ; monitor . begin Task ( _ STR + archive . get Name ( ) , zip File . size ( ) ) ;  Enumeration < ? extends  Zip Entry > entries = zip File . entries ( ) ; while ( entries . has More Elements ( ) ) {  Zip Entry zip Entry = entries . next Element ( ) ;  String current Entry = zip Entry . get Name ( ) ;  File dest File = new  File ( target Dir , current Entry ) ;  File destination Parent = dest File . get Parent File ( ) ; if ( ! zip Entry . is Directory ( ) ) { destination Parent . mkdirs ( ) ; is = new  Buffered Input Stream ( zip File . get Input Stream ( zip Entry ) ) ; int num Bytes Read ; byte bytes [ ] = new byte [  BUFSIZE ] ; fos = new  File Output Stream ( dest File ) ; dest = new  Buffered Output Stream ( fos ,  BUFSIZE ) ; while ( ( num Bytes Read = is . read ( bytes , _ NUM ,  BUFSIZE ) ) != - _ NUM ) { dest . write ( bytes , _ NUM , num Bytes Read ) ; } dest . flush ( ) ; } else { dest File . mkdirs ( ) ; } monitor . worked ( _ NUM ) ; if ( monitor . is Canceled ( ) ) { job Status =  Status .  CANCEL_ STATUS ; break ; } } if ( ! monitor . is Canceled ( ) ) { job Status =  Status .  OK_ STATUS ; } } catch (  Zip Exception ze ) {  String errormsg = error Message ( _ STR ) ; job Status = new  Status (  Status .  ERROR ,  Core Plugin .  PLUGIN_ ID , errormsg ) ;  Core Plugin Log . log Error ( ze , errormsg ) ; } catch (  IOException ioe ) {  String errormsg = error Message ( ) ; job Status = new  Status (  Status .  ERROR ,  Core Plugin .  PLUGIN_ ID , errormsg ) ;  Core Plugin Log . log Error ( ioe , errormsg ) ; } finally { try { if ( zip File != null ) { zip File . close ( ) ; } if ( is != null ) { is . close ( ) ; } if ( dest != null ) { dest . close ( ) ; } } catch (  IOException ioe ) {  String errormsg = error Message ( ) ; job Status = new  Status (  Status .  ERROR ,  Core Plugin .  PLUGIN_ ID , errormsg ) ;  Core Plugin Log . log Error ( ioe , errormsg ) ; } } return job Status ; }
public int read (  String table ,  String key ,  Set <  String > fields ,  Hash Map <  String ,  Byte Iterator > result ) { long st =  System . nano Time ( ) ; int res = _db . read ( table , key , fields , result ) ; long en =  System . nano Time ( ) ; _measurements . measure ( _ STR , ( int ) ( ( en - st ) / _ NUM ) ) ; _measurements . report Return Code ( _ STR , res ) ; return res ; }
protected void error Message (  String msg ) throws  IOException {  String str = msg + _ STR + m_ Tokenizer . to String ( ) ; if ( m_ Lines > _ NUM ) { int line =  Integer . parse Int ( str . replace All ( _ STR , _ STR ) ) ; str = str . replace All ( _ STR , _ STR + ( m_ Lines + line - _ NUM ) ) ; } throw new  IOException ( str ) ; }
public static void spooky4 ( final  Bit Vector bv , final long prefix Length , final long seed , final long [ ] state , final long [ ] tuple ) { long h0 , h1 , h2 , h3 ; h0 = seed ; h1 = seed ; h2 =  ARBITRARY_ BITS ; h3 =  ARBITRARY_ BITS ; long pos ; if ( prefix Length >= _ NUM *  Long .  SIZE ) { final int p = _ NUM * ( int ) ( ( prefix Length - _ NUM *  Long .  SIZE ) / ( _ NUM *  Long .  SIZE ) ) ; h0 = state [ p + _ NUM ] ; h1 = state [ p + _ NUM ] ; h2 = state [ p + _ NUM ] ; h3 = state [ p + _ NUM ] ; pos = p *  Long .  SIZE + _ NUM *  Long .  SIZE ; } else pos = _ NUM ; long remaining = prefix Length - pos ; if ( remaining >=  Long .  SIZE * _ NUM ) { h0 += bv . get Long ( pos + _ NUM *  Long .  SIZE , pos + _ NUM *  Long .  SIZE ) ; h1 += bv . get Long ( pos + _ NUM *  Long .  SIZE , pos + _ NUM *  Long .  SIZE ) ; remaining -= _ NUM *  Long .  SIZE ; pos += _ NUM *  Long .  SIZE ; } if ( remaining >  Long .  SIZE ) { h2 += bv . get Long ( pos + _ NUM *  Long .  SIZE , pos + _ NUM *  Long .  SIZE ) ; h3 += bv . get Long ( pos + _ NUM *  Long .  SIZE , prefix Length ) ; } else if ( remaining > _ NUM ) { h2 += bv . get Long ( pos , prefix Length ) ; } else { h2 +=  ARBITRARY_ BITS ; h3 +=  ARBITRARY_ BITS ; } h0 += prefix Length ; h3 ^= h2 ; h2 =  Long . rotate Left ( h2 , _ NUM ) ; h3 += h2 ; h0 ^= h3 ; h3 =  Long . rotate Left ( h3 , _ NUM ) ; h0 += h3 ; h1 ^= h0 ; h0 =  Long . rotate Left ( h0 , _ NUM ) ; h1 += h0 ; h2 ^= h1 ; h1 =  Long . rotate Left ( h1 , _ NUM ) ; h2 += h1 ; h3 ^= h2 ; h2 =  Long . rotate Left ( h2 , _ NUM ) ; h3 += h2 ; h0 ^= h3 ; h3 =  Long . rotate Left ( h3 , _ NUM ) ; h0 += h3 ; h1 ^= h0 ; h0 =  Long . rotate Left ( h0 , _ NUM ) ; h1 += h0 ; h2 ^= h1 ; h1 =  Long . rotate Left ( h1 , _ NUM ) ; h2 += h1 ; h3 ^= h2 ; h2 =  Long . rotate Left ( h2 , _ NUM ) ; h3 += h2 ; h0 ^= h3 ; h3 =  Long . rotate Left ( h3 , _ NUM ) ; h0 += h3 ; h1 ^= h0 ; h0 =  Long . rotate Left ( h0 , _ NUM ) ; h1 += h0 ; switch ( tuple . length ) { case _ NUM : tuple [ _ NUM ] = h3 ; case _ NUM : tuple [ _ NUM ] = h2 ; case _ NUM : tuple [ _ NUM ] = h1 ; case _ NUM : tuple [ _ NUM ] = h0 ; } }
public boolean has Next ( ) { if ( deal > _ NUM ) { sc . close ( ) ; } return ( deal <= _ NUM ) ; }
private void filter Node Map (  Concurrent Map <  String ,  Collection <  Cluster Node > > map , final  Cluster Node excl Node ) { for (  String cache Name : registered Caches . key Set ( ) ) {  String masked Name = mask Null ( cache Name ) ; while ( _ BOOL ) {  Collection <  Cluster Node > old Nodes = map . get ( masked Name ) ; if ( old Nodes == null || old Nodes . is Empty ( ) ) break ;  Collection <  Cluster Node > new Nodes = new  Array List < > ( old Nodes ) ; if ( ! new Nodes . remove ( excl Node ) ) break ; if ( map . replace ( masked Name , old Nodes , new Nodes ) ) break ; } } }
private static void adjust Abs ( double [ ] array , int lower , int upper ) { int j , k ; double temp ; j = lower ; k = lower * _ NUM ; while ( k <= upper ) { if ( ( k < upper ) && (  Math . abs ( array [ k - _ NUM ] ) <  Math . abs ( array [ k ] ) ) ) { k += _ NUM ; } if (  Math . abs ( array [ j - _ NUM ] ) <  Math . abs ( array [ k - _ NUM ] ) ) { temp = array [ j - _ NUM ] ; array [ j - _ NUM ] = array [ k - _ NUM ] ; array [ k - _ NUM ] = temp ; } j = k ; k *= _ NUM ; } }
public synchronized  IAudio Processor remove ( int index ) {  IAudio Processor processor = processors . remove ( index ) ; build Final Processor ( ) ; return processor ; }
Linked List <  Trie Node <  T > > make Suffix Chain (  Trie Node <  T > root ,  String suffix ,  T value ) {  Linked List <  Trie Node <  T > > result = new  Linked List < > ( ) ;  String root Prefix = root . get Prefix ( ) ; for ( int i = _ NUM , suffix Size = suffix . length ( ) ; i <= suffix Size ; i ++ ) {  String new Prefix = root Prefix + suffix . substring ( _ NUM , i ) ;  Trie Node <  T > new Node =  Trie Node . make Node ( new Prefix ) ; result . add ( new Node ) ; root . add Child ( new Node ) ; root = new Node ; } root . set Value ( value ) ; return result ; }
private static  By by From Locator (  String locator ) { if ( locator . starts With ( _ STR ) ) { return  By . xpath ( locator ) ; } if ( locator . starts With ( _ STR ) ) { return  By . id ( locator . replace First ( _ STR , _ STR ) ) ; } if ( locator . starts With ( _ STR ) ) { return  By . css Selector ( locator . replace First ( _ STR , _ STR ) ) ; } if ( locator . starts With ( _ STR ) ) { return  By . xpath ( locator . replace First ( _ STR , _ STR ) ) ; } if ( locator . starts With ( _ STR ) ) { return  By . name ( locator . replace First ( _ STR , _ STR ) ) ; } if ( locator . starts With ( _ STR ) ) { return  By . link Text ( locator . replace First ( _ STR , _ STR ) ) ; } if ( locator . starts With ( _ STR ) ) { return  By . partial Link Text ( locator . replace First ( _ STR , _ STR ) ) ; } throw new  Illegal Argument Exception ( _ STR + locator ) ; }
private static void task Started (  Progress Thread task ) { for (  Progress Thread State Listener l : listener . get Listeners (  Progress Thread State Listener . class ) ) { l . progress Thread Started ( task ) ; } }
public static final void is Comment WF (  DOMError Handler error Handler ,  DOMError Impl error ,  DOMLocator Impl locator ,  String datavalue , boolean is XML11 Version ) { if ( datavalue == null || ( datavalue . length ( ) == _ NUM ) ) { return ; } char [ ] dataarray = datavalue . to Char Array ( ) ; int datalength = dataarray . length ; if ( is XML11 Version ) { int i = _ NUM ; while ( i < datalength ) { char c = dataarray [ i ++ ] ; if (  XML11 Char . is XML11 Invalid ( c ) ) { if (  XMLChar . is High Surrogate ( c ) && i < datalength ) { char c2 = dataarray [ i ++ ] ; if (  XMLChar . is Low Surrogate ( c2 ) &&  XMLChar . is Supplemental (  XMLChar . supplemental ( c , c2 ) ) ) { continue ; } }  String msg =  DOMMessage Formatter . format Message (  DOMMessage Formatter .  XML_ DOMAIN , _ STR , new  Object [ ] {  Integer . to String ( dataarray [ i - _ NUM ] , _ NUM ) } ) ; report DOMError ( error Handler , error , locator , msg ,  DOMError .  SEVERITY_ ERROR , _ STR ) ; } else if ( c == _ STR && i < datalength && dataarray [ i ] == _ STR ) {  String msg =  DOMMessage Formatter . format Message (  DOMMessage Formatter .  XML_ DOMAIN , _ STR , null ) ; report DOMError ( error Handler , error , locator , msg ,  DOMError .  SEVERITY_ ERROR , _ STR ) ; } } } else { int i = _ NUM ; while ( i < datalength ) { char c = dataarray [ i ++ ] ; if (  XMLChar . is Invalid ( c ) ) { if (  XMLChar . is High Surrogate ( c ) && i < datalength ) { char c2 = dataarray [ i ++ ] ; if (  XMLChar . is Low Surrogate ( c2 ) &&  XMLChar . is Supplemental (  XMLChar . supplemental ( c , c2 ) ) ) { continue ; } }  String msg =  DOMMessage Formatter . format Message (  DOMMessage Formatter .  XML_ DOMAIN , _ STR , new  Object [ ] {  Integer . to String ( dataarray [ i - _ NUM ] , _ NUM ) } ) ; report DOMError ( error Handler , error , locator , msg ,  DOMError .  SEVERITY_ ERROR , _ STR ) ; } else if ( c == _ STR && i < datalength && dataarray [ i ] == _ STR ) {  String msg =  DOMMessage Formatter . format Message (  DOMMessage Formatter .  XML_ DOMAIN , _ STR , null ) ; report DOMError ( error Handler , error , locator , msg ,  DOMError .  SEVERITY_ ERROR , _ STR ) ; } } } }
private void throw Exception If Destroyed (  String method ) throws  Deepstream Record Destroyed Exception { if ( this . is Destroyed ) { throw new  Deepstream Record Destroyed Exception ( method ) ; } }
public void upload ( final  Input Stream in ,  String artifact ,  String version ,  String file Name ,  Properties props ) throws  IOException { props . put (  FILE_ NAME_ PROPERTY , file Name ) ; props . put (  VERSION_ PROPERTY , version ) ; props . put (  ARTIFACT_ PROPERTY , artifact ) ; store Properties ( artifact , version , props ) ; try (  Output Stream out = new Output Stream ( get Artifact ( artifact , version , file Name ) ) ) {  IOUtils . copy Large ( in , out ) ; } finally { in . close ( ) ; } }
public void load ( ) throws  IOException { if ( magic Number == _ NUM ) { try (  Input Reader Little Endian ins = new  Input Reader Little Endian ( new  File Input Stream Adapter ( file Name ) ) ) { magic Number = ins . read Long ( ) ; if ( magic Number !=  MAGIC_ NUMBER ) throw new  IOException ( _ STR ) ; version = ins . read Long ( ) ; if ( version >  DAA_ VERSION ) throw new  IOException ( _ STR ) ; diamond Build = ins . read Long ( ) ; db Seqs = ins . read Long ( ) ; db Seqs Used = ins . read Long ( ) ; db Letters = ins . read Long ( ) ; flags = ins . read Long ( ) ; query Records = ins . read Long ( ) ; mode Rank = ins . read Int ( ) ; gap Open = ins . read Int ( ) ; gap Extend = ins . read Int ( ) ; reward = ins . read Int ( ) ; penalty = ins . read Int ( ) ; reserved1 = ins . read Int ( ) ; reserved2 = ins . read Int ( ) ; reserved3 = ins . read Int ( ) ; k = ins . read Double ( ) ; lambda = ins . read Double ( ) ; reserved4 = ins . read Double ( ) ; reserved5 = ins . read Double ( ) ; for ( int i = _ NUM ; i < score Matrix . length ; i ++ ) { score Matrix [ i ] = ( byte ) ins . read ( ) ; } score Matrix Name =  Basic . to String ( score Matrix ) ; for ( int i = _ NUM ; i < block Size . length ; i ++ ) block Size [ i ] = ins . read Long ( ) ; if ( block Size [ _ NUM ] == _ NUM ) throw new  IOException ( _ STR ) ; for ( int i = _ NUM ; i < block Type Rank . length ; i ++ ) { block Type Rank [ i ] = ( byte ) ins . read ( ) ; switch (  Block Type . value ( block Type Rank [ i ] ) ) { case ref_names : if ( ref Names Block Index != - _ NUM ) throw new  IOException ( _ STR ) ; ref Names Block Index = i ; break ; case ref_lengths : if ( ref Lengths Block Index != - _ NUM ) throw new  IOException ( _ STR ) ; ref Lengths Block Index = i ; break ; case alignments : if ( alignments Block Index != - _ NUM ) throw new  IOException ( _ STR ) ; alignments Block Index = i ; break ; } } if ( ref Names Block Index == - _ NUM ) throw new  IOException ( _ STR ) ; if ( ref Lengths Block Index == - _ NUM ) throw new  IOException ( _ STR ) ; if ( alignments Block Index == - _ NUM ) throw new  IOException ( _ STR ) ; if ( ref Lengths Block Index < ref Names Block Index ) throw new  IOException ( _ STR ) ; header Size = ins . get Position ( ) ; ln K =  Math . log ( k ) ; } } }
private final void count All ( ) throws  IOException {  Multi Doc Values .  Ordinal Map ordinal Map ; if ( dv instanceof  Multi Doc Values .  Multi Sorted Set Doc Values ) { ordinal Map = ( (  Multi Sorted Set Doc Values ) dv ) . mapping ; } else { ordinal Map = null ; }  Index Reader orig Reader = state . get Orig Reader ( ) ; for (  Leaf Reader Context context : orig Reader . leaves ( ) ) {  Leaf Reader reader = context . reader ( ) ;  Sorted Set Doc Values seg Values = reader . get Sorted Set Doc Values ( field ) ; if ( seg Values == null ) { continue ; }  Bits live Docs = reader . get Live Docs ( ) ; if ( ordinal Map != null ) { final  Long Values ord Map = ordinal Map . get Global Ords ( context . ord ) ; int num Seg Ords = ( int ) seg Values . get Value Count ( ) ; final int [ ] seg Counts = new int [ num Seg Ords ] ; int doc ID ; while ( ( doc ID = seg Values . next Doc ( ) ) !=  Doc Id Set Iterator .  NO_ MORE_ DOCS ) { if ( live Docs == null || live Docs . get ( doc ID ) ) { int term = ( int ) seg Values . next Ord ( ) ; while ( term !=  Sorted Set Doc Values .  NO_ MORE_ ORDS ) { seg Counts [ term ] ++ ; term = ( int ) seg Values . next Ord ( ) ; } } } for ( int ord = _ NUM ; ord < num Seg Ords ; ord ++ ) { int count = seg Counts [ ord ] ; if ( count != _ NUM ) { counts [ ( int ) ord Map . get ( ord ) ] += count ; } } } else { int doc ID ; while ( ( doc ID = seg Values . next Doc ( ) ) !=  Doc Id Set Iterator .  NO_ MORE_ DOCS ) { if ( live Docs == null || live Docs . get ( doc ID ) ) { int term = ( int ) seg Values . next Ord ( ) ; while ( term !=  Sorted Set Doc Values .  NO_ MORE_ ORDS ) { counts [ term ] ++ ; term = ( int ) seg Values . next Ord ( ) ; } } } } } }
public void add To Parent (  Element header E ) throws  Exception {  Document doc = header E . get Owner Document ( ) ;  Element security E = doc . create Element NS ( wsse NS ,  WSSEConstants .  TAG_ WSSE + _ STR +  WSSEConstants .  TAG_ SECURITYT ) ; security E . set Attribute NS (  SOAPBinding Constants .  NS_ XML ,  WSSEConstants .  TAG_ XML_ WSSE , wsse NS ) ; header E . append Child ( security E ) ;  Document binary Token D =  XMLUtils . to DOMDocument ( to String ( ) , debug ) ;  Element binary Token E = binary Token D . get Document Element ( ) ; security E . append Child ( doc . import Node ( binary Token E , _ BOOL ) ) ; }
public void update ( ) { if ( amplitude > _ NUM ) { long elapsed =  System . current Time Millis ( ) - timestamp ; double delta = amplitude *  Math . exp ( - elapsed / time Constant ) ; if (  Math . abs ( delta ) > _ NUM ) { viewpoint Node . drag ( last Dx * delta , last Dy * delta ) ; } else { amplitude = _ NUM ; update Look At ( ) ; } } }
@  Override public  Assignment sample ( ) { if ( ! samples . is Empty ( ) ) { int selection = sampler . next Int ( samples . size ( ) ) ;  Assignment selected = samples . get ( selection ) ; return selected ; } else { log . warning ( _ STR ) ; return new  Assignment ( ) ; } }
@  Sneaky Throws public static  X509 Certificate read Certificate (  Input Stream is ) { return (  X509 Certificate )  CERT_ FACTORY . generate Certificate ( is ) ; }
public  Guacamole HTTPTunnel Map ( ) { executor . schedule At Fixed Rate ( new  Tunnel Timeout Task (  TUNNEL_ TIMEOUT * _ NUM ) ,  TUNNEL_ TIMEOUT ,  TUNNEL_ TIMEOUT ,  Time Unit .  SECONDS ) ; }
default  B with (  String key ,  Class < ? > value ) { return with ( key , value != null ? value . get Name ( ) : null ) ; }
private void rename (  Table table ) { if ( rename Definitions != null ) { for (  Column col : table . get All Columns ( ) ) {  String new Col Name = rename Definitions . get New Column Name ( table . get Schema ( ) , table . get Name ( ) , col . get Name ( ) ) ; if ( new Col Name != null ) col . set Name ( new Col Name ) ; }  String new Table Name = rename Definitions . get New Table Name ( table . get Schema ( ) , table . get Name ( ) ) ;  String new Schema Name = rename Definitions . get New Schema Name ( table . get Schema ( ) , table . get Name ( ) ) ; if ( new Table Name != null ) table . set Table ( new Table Name ) ; if ( new Schema Name != null ) table . set Schema ( new Schema Name ) ; } }
public synchronized boolean put ( long fp ) { int index = ( int ) ( fp & this . mask ) ; long [ ] list = this . table [ index ] ; if ( list != null ) { int listlen = list . length ; for ( int i = _ NUM ; i < listlen ; i ++ ) { if ( list [ i ] == fp ) return _ BOOL ; } } if ( count >= threshold ) { rehash ( ) ; index = ( int ) ( fp & this . mask ) ; list = this . table [ index ] ; } int len = ( list == null ? _ NUM : list . length ) ; long [ ] new List = new long [ len + _ NUM ] ; if ( list != null )  System . arraycopy ( list , _ NUM , new List , _ NUM , len ) ; new List [ len ] = fp ; this . table [ index ] = new List ; this . count ++ ; return _ BOOL ; }
public void apply Layout ( ) { layout . set Initial Location ( get Position ( ) ) ; layout . layout Neurons ( get Neuron List ( ) ) ; }
float layer Size ( int p_76490_1_ ) { if ( ( float ) p_76490_1_ < ( float ) this . height Limit * _ NUM ) { return - _ NUM ; } else { float f = ( float ) this . height Limit / _ NUM ; float f1 = f - ( float ) p_76490_1_ ; float f2 =  Math Helper . sqrt_float ( f * f - f1 * f1 ) ; if ( f1 == _ NUM ) { f2 = f ; } else if (  Math . abs ( f1 ) >= f ) { return _ NUM ; } return f2 * _ NUM ; } }
public static  Method find Static Method (  Class < ? > type ,  String name ,  Class < ? > ... args ) throws  No Such Method Exception {  Method method = find Method ( type , name , args ) ; if ( !  Modifier . is Static ( method . get Modifiers ( ) ) ) { throw new  No Such Method Exception ( _ STR + name + _ STR ) ; } return method ; }
private void fetch Search Service Cards From Server (  String keyword ,  String category Id ) { final  Map <  String ,  String > params = new  Hash Map <  String ,  String > ( _ NUM ) ; params . put (  Http Constants .  LATITUDE ,  Shared Preference Helper . get String (  R . string . pref_latitude ) ) ; params . put (  Http Constants .  LONGITUDE ,  Shared Preference Helper . get String (  R . string . pref_longitude ) ) ; params . put (  Http Constants .  TYPE ,  Http Constants .  Search Type .  SERVICE_ CARD ) ; params . put (  Http Constants .  GROUP_ ID , category Id ) ; params . put (  Http Constants .  PER , _ STR ) ; params . put (  Http Constants .  RADIUS , _ STR ) ; params . put (  Http Constants .  TITLE , keyword ) ;  Retro Callback retro Callback ; retro Callback = new  Retro Callback ( this ) ; retro Callback . set Request Id (  Http Constants .  Api Response Codes .  SEARCH_ SERVICES ) ; retro Callback List . add ( retro Callback ) ; params . put (  Http Constants .  PAGE , _ STR ) ; m Yelo Api . get Service Cards ( params , retro Callback ) ; m Swipe Refresh Layout . set Refreshing ( _ BOOL ) ; }
public void add Phonenumber (  String a Phonenumber ) { if ( m Phone Numbers . index Of ( a Phonenumber ) < _ NUM ) { m Phone Numbers . add ( a Phonenumber ) ; } }
public static final  String digits And Plus Only (  Matcher matcher ) {  String Builder buffer = new  String Builder ( ) ;  String matching Region = matcher . group ( ) ; for ( int i = _ NUM , size = matching Region . length ( ) ; i < size ; i ++ ) { char character = matching Region . char At ( i ) ; if ( character == _ STR ||  Character . is Digit ( character ) ) { buffer . append ( character ) ; } } return buffer . to String ( ) ; }
boolean compare Methods (  Method a ,  Method b ) { if ( ( a == null ) != ( b == null ) ) { return _ BOOL ; } if ( a != null && b != null ) { if ( ! a . equals ( b ) ) { return _ BOOL ; } } return _ BOOL ; }
Marker Segment find Marker Segment ( int tag ) {  Iterator iter = marker Sequence . iterator ( ) ; while ( iter . has Next ( ) ) {  Marker Segment seg = (  Marker Segment ) iter . next ( ) ; if ( seg . tag == tag ) { return seg ; } } return null ; }
private static  Reader open Input (  String from ) { try { return  Cli Utils . reader ( from ) ; } catch (  IOException e ) { log . error ( _ STR , e ) ;  System . exit ( _ NUM ) ; return null ; } }
public  Publisher Concat Array <  T > concat Additional Source First (  Publisher < ? extends  T > source ) { int n = array . length ; @  Suppress Warnings ( _ STR )  Publisher < ? extends  T > [ ] new Array = new  Publisher [ n + _ NUM ] ;  System . arraycopy ( array , _ NUM , new Array , _ NUM , n ) ; new Array [ _ NUM ] = source ; return new  Publisher Concat Array < > ( delay Error , new Array ) ; }
protected void do Publish (  String tenant Id ,  List <  T > items ,  String subscriber , int retry Count , long delay ) throws  Exception {  String data = mapper . write Value As String ( items ) ;  Text Message tm = session . create Text Message ( data ) ; if ( tenant Id != null ) { tm . set String Property ( _ STR , tenant Id ) ; } if ( subscriber != null ) { tm . set String Property ( _ STR , subscriber ) ; } tm . set Int Property ( _ STR , retry Count ) ; if ( delay > _ NUM ) { tm . set Long Property ( _ STR ,  System . current Time Millis ( ) + delay ) ; } if ( log . is Loggable (  Level .  FINEST ) ) { log . finest ( _ STR + tm ) ; } producer . send ( tm ) ; }
@  Override public boolean e Is Set ( int feature ID ) { switch ( feature ID ) { case  Mapping Package .  ATTRIBUTE__ NAME : return  NAME_ EDEFAULT == null ? name != null : !  NAME_ EDEFAULT . equals ( name ) ; case  Mapping Package .  ATTRIBUTE__ VALUE : return  VALUE_ EDEFAULT == null ? value != null : !  VALUE_ EDEFAULT . equals ( value ) ; } return super . e Is Set ( feature ID ) ; }
protected void check Valid ( ) throws  URIException { if ( ! ( equals ( _scheme ,  DEFAULT_ SCHEME ) || _scheme == null ) ) { throw new  URIException (  URIException .  PARSING , _ STR ) ; } }
public  Private Key Usage Extension (  Boolean critical ,  Object value ) throws  Certificate Exception ,  IOException { this . extension Id =  PKIXExtensions .  Private Key Usage_ Id ; this . critical = critical . boolean Value ( ) ; this . extension Value = ( byte [ ] ) value ;  Der Input Stream str = new  Der Input Stream ( this . extension Value ) ;  Der Value [ ] seq = str . get Sequence ( _ NUM ) ; for ( int i = _ NUM ; i < seq . length ; i ++ ) {  Der Value opt = seq [ i ] ; if ( opt . is Context Specific (  TAG_ BEFORE ) && ! opt . is Constructed ( ) ) { if ( not Before != null ) { throw new  Certificate Parsing Exception ( _ STR ) ; } opt . reset Tag (  Der Value . tag_ Generalized Time ) ; str = new  Der Input Stream ( opt . to Byte Array ( ) ) ; not Before = str . get Generalized Time ( ) ; } else if ( opt . is Context Specific (  TAG_ AFTER ) && ! opt . is Constructed ( ) ) { if ( not After != null ) { throw new  Certificate Parsing Exception ( _ STR ) ; } opt . reset Tag (  Der Value . tag_ Generalized Time ) ; str = new  Der Input Stream ( opt . to Byte Array ( ) ) ; not After = str . get Generalized Time ( ) ; } else throw new  IOException ( _ STR + _ STR ) ; } }
public static  Secret Key create AESKey ( ) { try { final  Key Generator kgen =  Key Generator . get Instance ( _ STR ) ; final int key Size = _ NUM ; kgen . init ( key Size ) ; return kgen . generate Key ( ) ; } catch ( final  No Such Algorithm Exception e ) { e . print Stack Trace ( ) ; } return null ; }
@  Override public void value Change (  Value Change Event e ) {  String name = e . get Property Name ( ) ;  Object value = e . get New Value ( ) ; log . config ( name + _ STR + value ) ; if ( value == null ) return ; }
public  Spy Versions load Versions ( ) throws  XMLException { set Loading ( _ BOOL ) ; final  String url String = property Loader . get Property (  Base Property Names .  VERSION_ INFO_ URL ) + _ STR + current Release ; try { final  URL url = new  URL ( url String ) ; final  String xml =  IOUtils . to String ( url . open Stream ( ) ) ; versions = (  Spy Versions ) load From String ( xml ) ; } catch (  IOException |  Null Pointer Exception e ) { throw new  XMLException ( _ STR + url String , e ) ; } set Loading ( _ BOOL ) ; return versions ; }
@  Request Mapping ( value = _ STR , method =  POST , produces =  APPLICATION_ JSON_ VALUE ) public  Response Entity <  Page Response <  User DTO > > find All ( @  Request Body  Page Request By Example <  User DTO > prbe ) throws  URISyntax Exception {  Page Response <  User DTO > page Response = user DTOService . find All ( prbe ) ; return new  Response Entity < > ( page Response , new  Http Headers ( ) ,  Http Status .  OK ) ; }
public void add Footer View (  View view ) { m Footer Views . add ( view ) ; notify Data Set Changed ( ) ; }
public boolean is Read Only ( boolean use Session Status ) throws  SQLException { if ( use Session Status && ! this . is Closed && version Meets Minimum ( _ NUM , _ NUM , _ NUM ) && ! get Use Local Session State ( ) && get Read Only Propagates To Server ( ) ) { java . sql .  Statement stmt = null ; java . sql .  Result Set rs = null ; try { try { stmt = get Metadata Safe Statement ( ) ; rs = stmt . execute Query ( _ STR ) ; if ( rs . next ( ) ) { return rs . get Int ( _ NUM ) != _ NUM ; } } catch (  SQLException ex1 ) { if ( ex1 . get Error Code ( ) !=  Mysql Error Numbers .  ER_ MUST_ CHANGE_ PASSWORD || get Disconnect On Expired Passwords ( ) ) { throw  SQLError . create SQLException ( _ STR ,  SQLError .  SQL_ STATE_ GENERAL_ ERROR , ex1 , get Exception Interceptor ( ) ) ; } } } finally { if ( rs != null ) { try { rs . close ( ) ; } catch (  Exception ex ) { } rs = null ; } if ( stmt != null ) { try { stmt . close ( ) ; } catch (  Exception ex ) { } stmt = null ; } } } return this . read Only ; }
public void test Consume ( ) {  Atomic Integer sum = new  Atomic Integer ( ) ;  Submission Publisher <  Integer > p = basic Publisher ( ) ;  Completable Future <  Void > f = p . consume ( null ) ; int n = _ NUM ; for ( int i = _ NUM ; i <= n ; ++ i ) p . submit ( i ) ; p . close ( ) ; f . join ( ) ; assert Equals ( ( n * ( n + _ NUM ) ) / _ NUM , sum . get ( ) ) ; }
private static  Downscale Quality add Constant (  String type ) { init ( ) ; if ( const List . contains Key ( type ) ) { throw new  Runtime Exception ( _ STR + type + _ STR ) ; }  Downscale Quality q = new  Downscale Quality ( type ) ; const List . put ( type , q ) ; return q ; }
public void bail (  String message , boolean print Usage Statement ) {  Debug . output ( message ) ; if ( print Usage Statement ) print Usage ( ) ;  System . exit ( _ NUM ) ; }
private void assert Timestamps Equal With Epsilon ( long expected , long actual , int epsilon ,  String desc ) { assert True ( _ STR + desc + _ STR + epsilon + _ STR + expected + _ STR + actual ,  Math . abs ( actual - expected ) < epsilon ) ; }
public  Spider Sitemap XMLParser (  Spider Param params ) { super ( ) ; if ( params == null ) { throw new  Illegal Argument Exception ( _ STR ) ; } this . params = params ; }
public boolean flush ( boolean deaccelerated ) ;
public void add Hop ( int id ) { if ( entities == null ) { return ; } hops Number ++ ; entities . add (  Integer . value Of ( id ) ) ; }
protected boolean [ ] dataset Integrity ( boolean nominal Predictor , boolean numeric Predictor , boolean string Predictor , boolean date Predictor , boolean relational Predictor , boolean multi Instance , int class Type , boolean predictor Missing , boolean class Missing ) { print ( _ STR ) ; print Attribute Summary ( nominal Predictor , numeric Predictor , string Predictor , date Predictor , relational Predictor , multi Instance , class Type ) ; print ( _ STR ) ; int num Train = get Num Instances ( ) , num Classes = _ NUM , missing Level = _ NUM ; boolean [ ] result = new boolean [ _ NUM ] ;  Instances train = null ;  Associator associator = null ; try { train = make Test Dataset ( _ NUM , num Train , nominal Predictor ? get Num Nominal ( ) : _ NUM , numeric Predictor ? get Num Numeric ( ) : _ NUM , string Predictor ? get Num String ( ) : _ NUM , date Predictor ? get Num Date ( ) : _ NUM , relational Predictor ? get Num Relational ( ) : _ NUM , num Classes , class Type , multi Instance ) ; if ( missing Level > _ NUM ) { add Missing ( train , missing Level , predictor Missing , class Missing ) ; } associator =  Abstract Associator . make Copies ( get Associator ( ) , _ NUM ) [ _ NUM ] ; } catch (  Exception ex ) { throw new  Error ( _ STR + ex . get Message ( ) ) ; } try {  Instances train Copy = new  Instances ( train ) ; associator . build Associations ( train Copy ) ; compare Datasets ( train , train Copy ) ; println ( _ STR ) ; result [ _ NUM ] = _ BOOL ; } catch (  Exception ex ) { println ( _ STR ) ; result [ _ NUM ] = _ BOOL ; if ( m_ Debug ) { println ( _ STR ) ; print ( _ STR ) ; println ( _ STR + ex . get Message ( ) + _ STR ) ; println ( _ STR ) ; println ( _ STR + train . to String ( ) + _ STR ) ; } } return result ; }
public boolean is Empty ( ) { return m Event Queue . is Empty ( ) ; }
public static void test Primitive Instantiation ( ) { test Primitive Instantiation ( _ BOOL ) ; }
public void read Entries (  Table Kelp table ,  In Segment reader ,  Segment Entry Callback cb ) {  Temp Buffer t Buf =  Temp Buffer . create Large ( ) ; byte [ ] buffer = t Buf . buffer ( ) ;  In Store s In = reader . get Store Read ( ) ; byte [ ] table Key = new byte [  Table Kelp .  TABLE_ KEY_ SIZE ] ; for ( int ptr = length ( ) -  BLOCK_ SIZE ; ptr > _ NUM ; ptr -=  BLOCK_ SIZE ) { s In . read ( get Address ( ) + ptr , buffer , _ NUM , buffer . length ) ; int index = _ NUM ; long seq =  Bits Util . read Long ( buffer , index ) ; index += _ NUM ; if ( seq != get Sequence ( ) ) { log . warning (  L . l ( _ STR , seq , get Sequence ( ) ,  Long . to Hex String ( get Address ( ) + ptr ) ) ) ; break ; }  System . arraycopy ( buffer , index , table Key , _ NUM , table Key . length ) ; index += table Key . length ; if ( !  Arrays . equals ( table Key , _table Key ) ) { log . warning (  L . l ( _ STR ,  Hex . to Short Hex ( table Key ) ,  Hex . to Short Hex ( _table Key ) ,  Long . to Hex String ( get Address ( ) + ptr ) ) ) ; break ; } int head = index ; while ( head <  BLOCK_ SIZE && buffer [ head ] != _ NUM ) { head = read Entry ( table , buffer , head , cb , get Address ( ) ) ; } boolean is Cont = buffer [ head + _ NUM ] != _ NUM ; if ( ! is Cont ) { break ; } } t Buf . free ( ) ; }
static int number Of Hosts (  Map <  URI ,  List <  Initiator > > net2 Initiators Map ) {  Set <  URI > host Set = new  Hash Set <  URI > ( ) ; for (  List <  Initiator > initiators : net2 Initiators Map . values ( ) ) { for (  Initiator init : initiators ) { host Set . add ( init . get Host ( ) ) ; } } return host Set . size ( ) ; }
protected void process Lob (  Lob Metadata lob ,  Database Mapping mapping ,  Metadata Class reference Class , boolean is For Map Key ) { lob . process ( mapping , this , reference Class , is For Map Key ) ; }
protected  Attributes Impl start Prefix Mapping (  Element element ,  Namespace Stack namespace Stack ) throws  SAXException {  Attributes Impl namespace Attributes = null ;  Namespace element Namespace = element . get Namespace ( ) ; if ( ( element Namespace != null ) && ! is Ignoreable Namespace ( element Namespace , namespace Stack ) ) { namespace Stack . push ( element Namespace ) ; content Handler . start Prefix Mapping ( element Namespace . get Prefix ( ) , element Namespace . get URI ( ) ) ; namespace Attributes = add Namespace Attribute ( namespace Attributes , element Namespace ) ; }  List <  Namespace > declared Namespaces = element . declared Namespaces ( ) ; for (  Namespace namespace : declared Namespaces ) { if ( ! is Ignoreable Namespace ( namespace , namespace Stack ) ) { namespace Stack . push ( namespace ) ; content Handler . start Prefix Mapping ( namespace . get Prefix ( ) , namespace . get URI ( ) ) ; namespace Attributes = add Namespace Attribute ( namespace Attributes , namespace ) ; } } return namespace Attributes ; }
private static  Data Flavor [ ] convert To Array (  List <  Data Flavor > data Flavour List ) {  Data Flavor [ ] array = new  Data Flavor [ data Flavour List . size ( ) ] ; data Flavour List . to Array ( array ) ; return array ; }
public void test Choice Empty Icon Error Handling ( ) {  String xml = _ STR ; xml += create Start Mission Xml ( _ STR , _ STR ) ; xml += create Start Choice Moment Xml ( _ STR , _ NUM , _ STR , _ STR ) ; xml += create Choice Xml ( _ STR , _ STR , _ STR , _ BOOL , _ BOOL , _ STR ) ; xml += create Choice Xml ( _ STR , _ STR , _ STR , _ BOOL , _ BOOL , _ STR ) ; xml += create End Choice Moment Xml ( ) ; xml += create End Choice Moment Xml ( ) ; xml += create End Mission Xml ( ) ;  Utils . log Debug (  TAG , xml ) ;  Input Stream moment Input Stream = new  Byte Array Input Stream ( xml . get Bytes ( ) ) ; m Mission = new  Mission ( m Mission Data ) ; boolean did Mission Parse Fail = _ BOOL ; try { m Mission . read Moments ( moment Input Stream ) ; } catch (  Mission Parse Exception e ) { e . print Stack Trace ( ) ; did Mission Parse Fail = _ BOOL ; }  Assert . assert Equals ( _ BOOL , did Mission Parse Fail ) ; }
public static  String translate Attribute (  String attributes ) throws  IOException { short [ ] flags = str Attr To Boolean Flags ( attributes ) ;  String Builder sb = new  String Builder ( ) ; if ( flags [  READ_ ONLY ] ==  YES ) sb . append ( _ STR ) ; else if ( flags [  READ_ ONLY ] ==  NO ) sb . append ( _ STR ) ; if ( flags [  HIDDEN ] ==  YES ) sb . append ( _ STR ) ; else if ( flags [  HIDDEN ] ==  NO ) sb . append ( _ STR ) ; if ( flags [  SYSTEM ] ==  YES ) sb . append ( _ STR ) ; else if ( flags [  SYSTEM ] ==  NO ) sb . append ( _ STR ) ; if ( flags [  ARCHIVE ] ==  YES ) sb . append ( _ STR ) ; else if ( flags [  ARCHIVE ] ==  NO ) sb . append ( _ STR ) ; return sb . to String ( ) ; }
public static int next Index Id ( ) { return msg Idx . get And Increment ( ) ; }
private void fill Field Values ( ) { if ( is Creation Panel ) { phrase . set Text ( _ STR +  Hearing .  DEFAULT_ PHRASE ) ; output Amount . set Text ( _ STR +  Hearing .  DEFAULT_ OUTPUT_ AMOUNT ) ; } else { phrase . set Text ( _ STR + hearing Sensor . get Phrase ( ) ) ; output Amount . set Text ( _ STR + hearing Sensor . get Output Amount ( ) ) ; } }
public static boolean check Security Infos (  String endpoint ,  Identity client Identity ,  List <  Security Info > security Infos ) { if ( client Identity . is Secure ( ) ) { if ( security Infos == null || security Infos . is Empty ( ) ) {  LOG . warn ( _ STR , endpoint ) ; return _ BOOL ; } else { for (  Security Info security Info : security Infos ) { if ( check Security Info ( endpoint , client Identity , security Info ) ) { return _ BOOL ; } } return _ BOOL ; } } else if ( security Infos != null && ! security Infos . is Empty ( ) ) {  LOG . warn ( _ STR , endpoint ) ; return _ BOOL ; } return _ BOOL ; }
public boolean retain All (  Abstract Int List other ) { if ( other . size ( ) == _ NUM ) { if ( size == _ NUM ) return _ BOOL ; set Size ( _ NUM ) ; return _ BOOL ; } int limit = other . size ( ) - _ NUM ; int j = _ NUM ; for ( int i = _ NUM ; i < size ; i ++ ) { if ( other . index Of From To ( get Quick ( i ) , _ NUM , limit ) >= _ NUM ) set Quick ( j ++ , get Quick ( i ) ) ; } boolean modified = ( j != size ) ; set Size ( j ) ; return modified ; }
public static  Array List <  Byte String > byte Arrays To Strings (  Array List < byte [ ] > byte Arrays ) { if ( byte Arrays == null ) { return null ; }  Array List <  Byte String > byte Strings = new  Array List <  Byte String > ( ) ; for ( byte [ ] bytes : byte Arrays ) { byte Strings . add (  Byte String . of ( bytes ) ) ; } return byte Strings ; }
void add Index (  Index Type type ,  List <  String > column Names ) {  Index Definition index = new  Index Definition ( ) ; index . index Name = table Name + _ STR + indexes . size ( ) ; index . column Names =  New . array List ( column Names ) ; index . type = type ; indexes . add ( index ) ; }
public  Builder with Key Store Key Password (  String key Store Key Password ) { properties . set Property (  Netty Options .  SSL_ KEY_ STORE_ KEY_ PASSWORD ,  Assert . not Null ( key Store Key Password , _ STR ) ) ; return this ; }
public  Zookeeper State Machine Ensemble (  Curator Framework curator Client ,  String base Path ) { this ( curator Client , base Path , _ BOOL ,  DEFAULT_ LOGSIZE ) ; }
public static  Custom Shortcut Set create Shortcut ( char ch ) {  Character mnemonic =  Character . value Of ( ch ) ;  String shortcut =  System Info . is Mac &&  System Info . is Java Version At Least ( _ STR ) ? _ STR + mnemonic : _ STR + mnemonic ; return  Custom Shortcut Set . from String ( shortcut ) ; }
public void gc ( ) {  System . gc ( ) ; }
private  Node delete Min (  Node x ) { if ( x . left == null ) return x . right ; x . left = delete Min ( x . left ) ; x . size = _ NUM + size ( x . left ) + size ( x . right ) ; x . height = _ NUM +  Math . max ( height ( x . left ) , height ( x . right ) ) ; return balance ( x ) ; }
public static void reset Counters ( ) { errors = _ NUM ; warnings = _ NUM ; }
public void write (  Ceylon Config config ,  File source ,  Output Stream out ) throws  IOException { if ( source . is File ( ) ) {  Input Stream in = null ; try { in = new  File Input Stream ( source ) ; write ( config , in , out ) ; } finally { if ( in != null ) { try { in . close ( ) ; } catch (  IOException e ) { } } } } else { throw new  File Not Found Exception ( _ STR ) ; } }
protected  Map <  Target Class ,  List <  Attribute .  Type Compound > > sift ( final  Iterable <  Attribute .  Type Compound > type Compounds ) { final  Map <  Target Class ,  List <  Attribute .  Type Compound > > target Class To Compound = new  Enum Map < > (  Target Class . class ) ; for (  Target Class target Class :  Target Class . values ( ) ) { target Class To Compound . put ( target Class , new  Array List <  Type Compound > ( ) ) ; } for ( final  Attribute .  Type Compound type Compound : type Compounds ) { final  Target Type type Compound Target = type Compound . position . type ; final  List <  Attribute .  Type Compound > dest List ; if (  Element Annotation Util . contains ( type Compound Target , annotated Targets ( ) ) ) { dest List = target Class To Compound . get (  Target Class .  TARGETED ) ; } else if (  Element Annotation Util . contains ( type Compound Target , valid Targets ( ) ) ) { dest List = target Class To Compound . get (  Target Class .  VALID ) ; } else { dest List = target Class To Compound . get (  Target Class .  INVALID ) ; } dest List . add ( type Compound ) ; } return target Class To Compound ; }
protected synchronized void update Location (  Point new Locn ) { prev = locn ; locn = new Locn ; if (  Math . abs ( locn . x - prev . x ) > hysteresis ||  Math . abs ( locn . y - prev . y ) > hysteresis ) { if ( timer . is Running ( ) ) timer . stop ( ) ; } else { if ( ! timer . is Running ( ) ) timer . start ( ) ; } }
@  Override public int compare To (  Value o ) { if ( o instanceof  String Val ) { return str . compare To ( ( (  String Val ) o ) . str ) ; } else { return _ NUM ; } }
public void bind (  Integer Property property , int value ) { if ( is Achieved ( ) ) return ; bind ( property . greater Than Or Equal To ( value ) ) ;  Boolean Binding bb = property . greater Than Or Equal To ( value / _ NUM ) ; progress Listener = null ; bb . add Listener ( progress Listener ) ; }
public synchronized void write (  String log Data ) { if ( log Enabled ) { hist Data . append ( log Data ) ; hist Data . revalidate ( ) ; synchronized ( hist Data ) { hist Data . notify ( ) ; } } }
public void close Connection ( ) { try { if ( m_connection != null ) { m_connection . close ( ) ; } } catch ( final  SQLException exception ) {  Navi Logger . severe ( _ STR , exception ) ; } m_connection = null ; }
public  Struct Em Bayes Search Editor (  Struct Em Bayes Search Runner sem Bayes Est Wrapper ) { this ( sem Bayes Est Wrapper . get Estimated Bayes Im ( ) , sem Bayes Est Wrapper . get Data Set ( ) ) ; }
public void remove Action Listener (  Action Listener listener ) { forward Projection Button . add Action Listener ( listener ) ; back Projection Button . add Action Listener ( listener ) ; }
boolean is Literal ( int index ) { if ( is Valid Mask ( ) && index < string . length ( ) ) { return literal Mask . get ( index ) ; } return _ BOOL ; }
protected  Granularity generate Granularity (  String granularity ,  Granularity Parser granularity Parser ) throws  Bad Api Request Exception { try { return granularity Parser . parse Granularity ( granularity ) ; } catch (  Granularity Parse Exception e ) {  LOG . error (  UNKNOWN_ GRANULARITY . log Format ( granularity ) , granularity ) ; throw new  Bad Api Request Exception ( e . get Message ( ) ) ; } }
public  Word Iterator ( ) { this (  Locale . get Default ( ) ) ; }
@  Override public void close ( ) { if ( leaf != null ) { leaf . close ( ) ; leaf = null ; } cc Mgr . release Index Locks ( ) ; dirs May Be Updated = null ; }
public void push File (  String local ,  String remote ,  ISync Progress Monitor monitor ) throws  Sync Exception ,  IOException ,  Timeout Exception {  File f = new  File ( local ) ; if ( ! f . exists ( ) ) { throw new  Sync Exception (  Sync Error .  NO_ LOCAL_ FILE ) ; } if ( f . is Directory ( ) ) { throw new  Sync Exception (  Sync Error .  LOCAL_ IS_ DIRECTORY ) ; } monitor . start ( ( int ) f . length ( ) ) ; do Push File ( local , remote , monitor ) ; monitor . stop ( ) ; }
public  String process (  Item seg ) throws  Process Exception { return seg Coda Ctype ( seg , _ STR ) ; }
public void resize ( int size ) { if ( buffer != null ) { if ( size >= _ NUM && size < buffer . size ( ) ) { int old Last Index = buffer . size ( ) - _ NUM ; int new Last Index = size - _ NUM ; for ( int i = old Last Index ; i > new Last Index ; i -- ) { buffer . remove ( i ) ; } } } else { if ( size >= _ NUM && size < offsets . size ( ) ) { long offset = offsets . get ( size ) ; byte Cache . resize ( key , offset ) ;  Array List <  Long > new Offsets = new  Array List <  Long > ( size ) ; for ( int i = _ NUM ; i < size ; i ++ ) { new Offsets . add ( offsets . get ( i ) ) ; } offsets = new Offsets ; } } }
protected void init From Dir (  String prefix ,  File dir ) {  File [ ] files ; files = dir . list Files ( new  Class File Filter ( ) ) ; for (  File file : files ) { if ( prefix == null ) { add ( file . get Name ( ) ) ; } else { add ( prefix + _ STR + file . get Name ( ) ) ; } } files = dir . list Files ( new  Directory Filter ( ) ) ; for (  File file : files ) { if ( prefix == null ) { init From Dir ( file . get Name ( ) , file ) ; } else { init From Dir ( prefix + _ STR + file . get Name ( ) , file ) ; } } }
public void remove Bandwidth (  String name ) { if ( name != null ) if ( bandwidth List != null ) { for ( int i = _ NUM ; i < bandwidth List . size ( ) ; i ++ ) {  Object o = bandwidth List . element At ( i ) ; if ( o instanceof  Bandwidth Field ) {  Bandwidth Field b = (  Bandwidth Field ) o ; try {  String type = b . get Type ( ) ; if ( type != null ) { if ( name . equals ( type ) ) { bandwidth List . remove ( b ) ; } } } catch (  Sdp Parse Exception e ) { } } } } }
public static long now ( ) { return  System . current Time Millis ( ) ; }
public static  String collapse Newlines (  String arg Str ) { char last = arg Str . char At ( _ NUM ) ;  String Buffer arg Buf = new  String Buffer ( ) ; for ( int c Idx = _ NUM ; c Idx < arg Str . length ( ) ; c Idx ++ ) { char ch = arg Str . char At ( c Idx ) ; if ( ch != _ STR || last != _ STR ) { arg Buf . append ( ch ) ; last = ch ; } } return arg Buf . to String ( ) ; }
Linked List <  Trie Node <  T > > make Suffix Chain (  Trie Node <  T > root ,  String suffix ,  T value ) {  Linked List <  Trie Node <  T > > result = new  Linked List < > ( ) ;  String root Prefix = root . get Prefix ( ) ; for ( int i = _ NUM , suffix Size = suffix . length ( ) ; i <= suffix Size ; i ++ ) {  String new Prefix = root Prefix + suffix . substring ( _ NUM , i ) ;  Trie Node <  T > new Node =  Trie Node . make Node ( new Prefix ) ; result . add ( new Node ) ; root . add Child ( new Node ) ; root = new Node ; } root . set Value ( value ) ; return result ; }
@  Override protected  String generate Javadoc ( int index ) throws  Exception { throw new  Exception ( _ STR ) ; }
public  Properties extract Properties (  Iterable <  Map .  Entry <  String ,  String > > prop Src ) {  Properties result = new  Properties ( ) ; for (  Map .  Entry <  String ,  String > entry : prop Src ) {  String name = entry . get Key ( ) ; if ( is Namespaced Property ( name ) ) {  String val = entry . get Value ( ) ; result . set Property ( name , val ) ; } } return result ; }
public  T remove Last ( ) { if ( rows . size ( ) != _ NUM ) rows . remove ( rows . size ( ) - _ NUM ) ; return instance ( ) ; }
public static void ensure Visible (  String component Name ) { if ( verbose ) { log ( _ STR + component Name + _ STR ) ; } ensure Visible ( find By Name ( component Name ) ) ; }
public void end Representation ( ) { if ( ! representation Protections Set ) { if ( current Representation Protections != null ) {  Collections . sort ( current Representation Protections , this ) ; } representation Protections = current Representation Protections ; representation Protections Set = _ BOOL ; } else { if ( current Representation Protections == null ) {  Assertions . check State ( representation Protections == null ) ; } else {  Collections . sort ( current Representation Protections , this ) ;  Assertions . check State ( current Representation Protections . equals ( representation Protections ) ) ; } } current Representation Protections = null ; }
public  Standard Pie Section Label Generator (  String label Format ) { this ( label Format ,  Number Format . get Number Instance ( ) ,  Number Format . get Percent Instance ( ) ) ; }
public static  Char Sequence [ ] split (  Char Sequence line , int delimiter ) {  Char Sequence [ ] tokens0 = split ( line , delimiter ,  N ) ; if ( tokens0 . length <  N ) { return tokens0 ; } else {  Char Sequence [ ] tokens1 = split ( tokens0 [  N - _ NUM ] , delimiter ) ;  Char Sequence [ ] tokens2 = new  Char Sequence [ tokens0 . length + tokens1 . length - _ NUM ] ;  System . arraycopy ( tokens0 , _ NUM , tokens2 , _ NUM , tokens0 . length - _ NUM ) ;  System . arraycopy ( tokens1 , _ NUM , tokens2 , tokens0 . length - _ NUM , tokens1 . length ) ; return tokens2 ; } }
public  CCTimer (  Object t ,  String s , float seconds ) { target = t ; selector = s ; interval = seconds ; elapsed = - _ NUM ; try {  Class < ? > cls = target . get Class ( ) ; invocation = cls . get Method ( s ,  Float .  TYPE ) ; } catch (  No Such Method Exception e ) { e . print Stack Trace ( ) ; } }
public  Tuple read ( ) throws  IOException { try {  Map fields = json Tuple Stream . next ( ) ; if ( fields == null ) {  Map m = new  Hash Map ( ) ; m . put ( _ STR , _ BOOL ) ; return new  Tuple ( m ) ; } else {  String msg = (  String ) fields . get ( _ STR ) ; if ( msg != null ) {  Handled Exception io Exception = new  Handled Exception ( msg ) ; throw io Exception ; } if ( trace ) { fields . put ( _ STR , this . base Url ) ; if ( slice != null ) { fields . put ( _ STR , slice ) ; } } if ( field Mappings != null ) { fields = map Fields ( fields , field Mappings ) ; } return new  Tuple ( fields ) ; } } catch (  Handled Exception e ) { throw new  IOException ( _ STR + this . base Url + _ STR + e . get Message ( ) ) ; } catch (  Exception e ) { throw new  IOException ( _ STR + this . base Url + _ STR , e ) ; } }
private  String compute (  String left , double right , boolean is Integer ) { if ( left == null &&  Double . is Na N ( right ) ) { return null ; } if ( is Integer && right == ( int ) right ) { return ( left == null ? _ STR : left ) + ( int ) right ; } else if (  Double . is Infinite ( right ) ) { return ( left == null ? _ STR : left ) +  Tools . format Number ( right ) ; } else { return ( left == null ? _ STR : left ) + (  Double . is Na N ( right ) ? _ STR : right ) ; } }
public void remove Property Change Listener ( final  Property Change Listener listener ) { property Change Support . remove Property Change Listener ( listener ) ; }
public void load XML (  Node stepnode ,  List <  Database Meta > databases ,  Map <  String ,  Counter > counters ) throws  Kettle XMLException { try { this . tabel Name =  XMLHandler . get Tag Value ( stepnode , _ STR ) ; this . output Row Size =  XMLHandler . get Tag Value ( stepnode , _ STR ) ; this . fact Dim Lens String =  XMLHandler . get Tag Value ( stepnode , _ STR ) ; this . table Name =  XMLHandler . get Tag Value ( stepnode , _ STR ) ; this . database Name =  XMLHandler . get Tag Value ( stepnode , _ STR ) ; this . dimension Count =  XMLHandler . get Tag Value ( stepnode , _ STR ) ; this . no Dictionary Dims =  XMLHandler . get Tag Value ( stepnode , _ STR ) ; this . no Dictionary Dims Mapping =  XMLHandler . get Tag Value ( stepnode , _ STR ) ; this . complex Dimension Count =  XMLHandler . get Tag Value ( stepnode , _ STR ) ; this . measure Count =  XMLHandler . get Tag Value ( stepnode , _ STR ) ; this . update Member Request =  XMLHandler . get Tag Value ( stepnode , _ STR ) ; this . measure Data Type =  XMLHandler . get Tag Value ( stepnode , _ STR ) ; this . partition ID =  XMLHandler . get Tag Value ( stepnode , _ STR ) ; this . segment Id =  XMLHandler . get Tag Value ( stepnode , _ STR ) ; this . task No =  XMLHandler . get Tag Value ( stepnode , _ STR ) ; } catch (  Exception e ) { throw new  Kettle XMLException ( _ STR , e ) ; } }
public final int [ ] hash Signature ( final int [ ] signature ) { int [ ] hash = new int [ stages ] ; int rows = signature . length / stages ; for ( int i = _ NUM ; i < signature . length ; i ++ ) { int stage =  Math . min ( i / rows , stages - _ NUM ) ; hash [ stage ] = ( int ) ( ( hash [ stage ] + ( long ) signature [ i ] *  LARGE_ PRIME ) % buckets ) ; } return hash ; }
public void cast ( final  Type from , final  Type to ) { if ( from != to ) { if ( from ==  Type .  DOUBLE_ TYPE ) { if ( to ==  Type .  FLOAT_ TYPE ) { mv . visit Insn (  Opcodes .  D2 F ) ; } else if ( to ==  Type .  LONG_ TYPE ) { mv . visit Insn (  Opcodes .  D2 L ) ; } else { mv . visit Insn (  Opcodes .  D2 I ) ; cast (  Type .  INT_ TYPE , to ) ; } } else if ( from ==  Type .  FLOAT_ TYPE ) { if ( to ==  Type .  DOUBLE_ TYPE ) { mv . visit Insn (  Opcodes .  F2 D ) ; } else if ( to ==  Type .  LONG_ TYPE ) { mv . visit Insn (  Opcodes .  F2 L ) ; } else { mv . visit Insn (  Opcodes .  F2 I ) ; cast (  Type .  INT_ TYPE , to ) ; } } else if ( from ==  Type .  LONG_ TYPE ) { if ( to ==  Type .  DOUBLE_ TYPE ) { mv . visit Insn (  Opcodes .  L2 D ) ; } else if ( to ==  Type .  FLOAT_ TYPE ) { mv . visit Insn (  Opcodes .  L2 F ) ; } else { mv . visit Insn (  Opcodes .  L2 I ) ; cast (  Type .  INT_ TYPE , to ) ; } } else { if ( to ==  Type .  BYTE_ TYPE ) { mv . visit Insn (  Opcodes .  I2 B ) ; } else if ( to ==  Type .  CHAR_ TYPE ) { mv . visit Insn (  Opcodes .  I2 C ) ; } else if ( to ==  Type .  DOUBLE_ TYPE ) { mv . visit Insn (  Opcodes .  I2 D ) ; } else if ( to ==  Type .  FLOAT_ TYPE ) { mv . visit Insn (  Opcodes .  I2 F ) ; } else if ( to ==  Type .  LONG_ TYPE ) { mv . visit Insn (  Opcodes .  I2 L ) ; } else if ( to ==  Type .  SHORT_ TYPE ) { mv . visit Insn (  Opcodes .  I2 S ) ; } } } }
private void add Trigger Group Name (  String group Name ) throws  Job Persistence Exception ,  Resource Exception { add Repo List Name ( group Name ,  TRIGGER_ GROUP_ NAMES_ RESOURCE_ PATH , _ STR ) ; }
private synchronized void clear Temp Files ( ) { if ( ( temp Files != null ) && ( temp Files . size ( ) > _ NUM ) ) {  Iterator it = temp Files . iterator ( ) ;  File file = null ; while ( it . has Next ( ) ) { file = (  File ) it . next ( ) ; file . delete ( ) ; } temp Files . clear ( ) ; } }
private  Bitmap read And Decompress Thumbnail (  File file ) { try { if ( file . length ( ) > _ NUM ) {  File Input Stream instream = new  File Input Stream ( file ) ;  Readable Byte Channel bytechan =  Channels . new Channel ( instream ) ;  Byte Buffer buff =  Byte Buffer . allocate Direct ( ( int ) file . length ( ) ) ; if ( buff != null ) { bytechan . read ( buff ) ; instream . close ( ) ; buff . rewind ( ) ;  PDQImage pthumb =  Decompression Service . decompress Thumbnail Image ( buff ) ; if ( pthumb != null ) {  Bitmap bm =  Conversion Service . convert PDQImage To Bitmap ( pthumb , _ BOOL ) ; pthumb . close ( ) ; return bm ; } } } } catch (  IOException ex ) { ex . print Stack Trace ( ) ; } return null ; }
public void test Submit Runnable ( ) throws  Throwable {  Executor Service e = new  Fork Join Pool ( _ NUM ) ;  Pool Cleaner cleaner = null ; try { cleaner = cleaner ( e ) ;  Future < ? > future = e . submit ( new  No Op Runnable ( ) ) ; assert Null ( future . get ( ) ) ; assert True ( future . is Done ( ) ) ; assert False ( future . is Cancelled ( ) ) ; } finally { if ( cleaner != null ) { cleaner . close ( ) ; } } }
public  Rectangle2 D shrink (  Rectangle2 D area ,  Rectangle2 D result ) { if ( result == null ) { result = new  Rectangle2 D .  Double ( ) ; } result . set Rect ( area . get X ( ) + this . left , area . get Y ( ) + this . top , area . get Width ( ) - this . left - this . right , area . get Height ( ) - this . top - this . bottom ) ; return result ; }
public static  String assert JQ (  Solr Query Request req ,  String ... tests ) throws  Exception { return assert JQ ( req ,  JSONTest Util .  DEFAULT_ DELTA , tests ) ; }
protected void build Absolute Stats (  String name , long value , long time ) throws  Interrupted Exception {  List <  XYData Item > stats = stats Collection . get Stats ( name ) ; if ( stats == null ) { stats = stats Collection . new Stats ( name , max Series ) ; } else {  XYData Item data = new  XYData Item ( time , value ) ; stats Collection . lock For Update ( ) ; try { stats . add ( data ) ; house Keep Stats ( stats ) ; } finally { stats Collection . release Lock ( ) ; } if ( listeners != null ) {  Stats Collection Event event = new  Stats Collection Event ( name , data ) ; for (  Stats Collection Listener listener : listeners ) { if ( listener . is Enabled ( ) ) { listener . stats Collected ( event ) ; } } } } }
@  Override public void run ( ) { am IActive = _ BOOL ;  String dem Header = null ;  String stream Heads Header = null ;  String elevation Modified Header = null ;  String corrected Dem Header = null ;  List <  Stream Head > stream Head List = new  Array List < > ( ) ; int counter = _ NUM ; float progress = _ NUM ; if ( args . length <= _ NUM ) { show Feedback ( _ STR ) ; return ; } for ( int i = _ NUM ; i < args . length ; i ++ ) { if ( i == _ NUM ) { dem Header = args [ i ] ; } else if ( i == _ NUM ) { stream Heads Header = args [ i ] ; } else if ( i == _ NUM ) { elevation Modified Header = args [ i ] ; } else if ( i == _ NUM ) { corrected Dem Header = args [ i ] ; } else if ( i == _ NUM ) { max Radius =  Double . parse Double ( args [ i ] ) ; } } if ( ( dem Header == null ) || ( stream Heads Header == null ) || ( elevation Modified Header == null ) || ( corrected Dem Header == null ) ) { show Feedback ( _ STR ) ; return ; } try { dem = new  Whitebox Raster ( dem Header , _ STR ) ; stream Heads = new  Whitebox Raster ( stream Heads Header , _ STR ) ; num Rows = dem . get Number Rows ( ) ; num Cols = dem . get Number Columns ( ) ; no Data = dem . get No Data Value ( ) ; grid Res = dem . get Cell Size X ( ) ; elevation Modified = new  Whitebox Raster ( elevation Modified Header , _ STR , dem Header ,  Whitebox Raster .  Data Type .  FLOAT , _ NUM ) ; elevation Modified . set Preferred Palette ( _ STR ) ; elevation Modified . set Data Scale (  Whitebox Raster Base .  Data Scale .  CONTINUOUS ) ; elevation Modified . set ZUnits ( _ STR ) ; corrected DEM = new  Whitebox Raster ( corrected Dem Header , _ STR , dem Header ,  Whitebox Raster .  Data Type .  FLOAT , _ NUM ) ; corrected DEM . set Preferred Palette ( _ STR ) ; corrected DEM . set Data Scale (  Whitebox Raster Base .  Data Scale .  CONTINUOUS ) ; corrected DEM . set ZUnits ( _ STR ) ; if ( stream Heads . get Number Columns ( ) != num Cols || stream Heads . get Number Rows ( ) != num Rows ) { show Feedback ( _ STR ) ; return ; } update Progress ( _ STR , _ NUM ) ; for ( int row = _ NUM ; row < num Rows ; row ++ ) { for ( int col = _ NUM ; col < num Cols ; col ++ ) { if ( dem . get Value ( row , col ) != no Data ) { elevation Modified . set Value ( row , col , _ NUM ) ; } else { elevation Modified . set Value ( row , col , no Data ) ; } } if ( cancel Op ) { cancel Operation ( ) ; return ; } progress = ( float ) ( _ NUM * row / ( num Rows - _ NUM ) ) ; update Progress ( _ STR , ( int ) progress ) ; } update Progress ( _ STR , _ NUM ) ; for ( int row = _ NUM ; row < num Rows ; row ++ ) { for ( int col = _ NUM ; col < num Cols ; col ++ ) { if ( stream Heads . get Value ( row , col ) == _ NUM ) { stream Head List . add ( new  Stream Head ( col , row , dem . get Value ( row , col ) ) ) ; } } if ( cancel Op ) { cancel Operation ( ) ; return ; } progress = ( float ) ( _ NUM * row / ( num Rows - _ NUM ) ) ; update Progress ( _ STR , ( int ) progress ) ; } stream Head List =  Order Stream Heads ( stream Head List ) ; update Progress ( _ STR , _ NUM ) ; for (  Stream Head stream Head : stream Head List ) {  Check Flow Path ( stream Head .  Get XCoord ( ) , stream Head .  Get YCoord ( ) ) ; counter = counter + _ NUM ; if ( cancel Op ) { cancel Operation ( ) ; return ; } progress = ( float ) ( _ NUM * counter / stream Head List . size ( ) ) ; update Progress ( _ STR , ( int ) progress ) ; } update Progress ( _ STR , _ NUM ) ; for ( int row = _ NUM ; row < num Rows ; row ++ ) { for ( int col = _ NUM ; col < num Cols ; col ++ ) { if ( elevation Modified . get Value ( row , col ) != no Data ) { corrected DEM . set Value ( row , col , dem . get Value ( row , col ) - elevation Modified . get Value ( row , col ) ) ; } else { corrected DEM . set Value ( row , col , no Data ) ; } } if ( cancel Op ) { cancel Operation ( ) ; return ; } progress = ( float ) ( _ NUM * row / ( num Rows - _ NUM ) ) ; update Progress ( _ STR , ( int ) progress ) ; } elevation Modified . add Metadata Entry ( _ STR + get Descriptive Name ( ) + _ STR ) ; elevation Modified . add Metadata Entry ( _ STR + new  Date ( ) ) ; corrected DEM . add Metadata Entry ( _ STR + get Descriptive Name ( ) + _ STR ) ; corrected DEM . add Metadata Entry ( _ STR + new  Date ( ) ) ; dem . close ( ) ; stream Heads . close ( ) ; elevation Modified . close ( ) ; corrected DEM . close ( ) ; return Data ( corrected Dem Header ) ; } catch (  Exception e ) { show Feedback ( e . get Message ( ) ) ; } finally { update Progress ( _ STR , _ NUM ) ; am IActive = _ BOOL ; my Host . plugin Complete ( ) ; } }
protected void serialize (  String filename ) { classifier . serialize Classifier ( filename ) ; }
public static _ Fields find By Thrift Id ( int field Id ) { switch ( field Id ) { case _ NUM : return  BEGIN_ IN_ BOTH ; case _ NUM : return  NEWINT ; case _ NUM : return  NEWBYTE ; case _ NUM : return  NEWSHORT ; case _ NUM : return  NEWLONG ; case _ NUM : return  NEWDOUBLE ; case _ NUM : return  NEWSTRUCT ; case _ NUM : return  NEWLIST ; case _ NUM : return  NEWSET ; case _ NUM : return  NEWMAP ; case _ NUM : return  NEWSTRING ; case _ NUM : return  END_ IN_ BOTH ; default : return null ; } }
protected  Size2 D arrange FN (  Block Container container ,  Graphics2 D g2 ,  Rectangle Constraint constraint ) {  List blocks = container . get Blocks ( ) ;  Block b = (  Block ) blocks . get ( _ NUM ) ;  Size2 D s = b . arrange ( g2 ,  Rectangle Constraint .  NONE ) ; double width = constraint . get Width ( ) ;  Rectangle2 D bounds = new  Rectangle2 D .  Double ( ( width - s . width ) / _ NUM , _ NUM , s . width , s . height ) ; b . set Bounds ( bounds ) ; return new  Size2 D ( ( width - s . width ) / _ NUM , s . height ) ; }
private  Object process Execute (  Statement proxy ,  Method method ,  Object [ ] args ) throws  Throwable { long start Time = log Slow Query ?  System . current Time Millis ( ) : _ NUM ; try { if ( method . get Name ( ) == _ STR ) return new Proxied Result Set ( proxy , method , args ) ; return target Invoke ( method , args ) ; } finally { if ( log Slow Query ) log Query ( proxy , args , start Time ) ; } }
int bounded Index Of (  String string , char search , int start , int end ) { int ret Value = string . index Of ( search , start ) ; if ( ret Value >= end ) { return - _ NUM ; } return ret Value ; }
public int incr (  T k , int delta ) {  Integer i = counts . get ( k ) ; if ( i == null ) { i = _ NUM ; } int next = i . int Value ( ) + delta ; if ( next < _ NUM ) { throw new java . lang .  Arithmetic Exception ( ) ; } if ( next == _ NUM ) { counts . remove ( k ) ; } else { counts . put ( k , i + delta ) ; } return i ; }
public void send ( final  Osc Packet the Packet , final  Tcp Client the Client ) { the Client . send ( the Packet . get Bytes ( ) ) ; }
@  Override @  Suppress Warnings ( _ STR ) public void key Typed (  Key Event evt ) { int modifiers = evt . get Modifiers ( ) ; char c = evt . get Key Char ( ) ; if ( c !=  Key Event .  CHAR_ UNDEFINED && ( modifiers &  Input Event .  ALT_ MASK ) == _ NUM ) { if ( c >= _ NUM && c != _ NUM ) {  Key Stroke key Stroke =  Key Stroke . get Key Stroke (  Character . to Upper Case ( c ) ) ;  Object o = current Bindings . get ( key Stroke ) ; if ( o instanceof  Hashtable ) { current Bindings = (  Hashtable ) o ; return ; } else if ( o instanceof  Action Listener ) { current Bindings = bindings ; execute Action ( (  Action Listener ) o , evt . get Source ( ) ,  String . value Of ( c ) ) ; return ; } current Bindings = bindings ; if ( grab Action != null ) { handle Grab Action ( evt ) ; return ; } if ( repeat &&  Character . is Digit ( c ) ) { repeat Count *= _ NUM ; repeat Count += ( c - _ STR ) ; return ; } execute Action (  INSERT_ CHAR , evt . get Source ( ) ,  String . value Of ( evt . get Key Char ( ) ) ) ; repeat Count = _ NUM ; repeat = _ BOOL ; } } }
public static  Map <  String ,  Mapped Class > fill In The Gaps (  Map <  String ,  Mapped Class > mapped Classes ,  Mapping Mode mode ) { for (  String original Name : mapped Classes . key Set ( ) ) { mapped Classes = fill Gap ( mapped Classes . get ( original Name ) , mapped Classes , mode ) ; } return mapped Classes ; }
private void read Object (  Object Input Stream s ) throws  IOException ,  Class Not Found Exception { s . default Read Object ( ) ; if ( name == null ) { if ( types != null ) { throw new  Invalid Object Exception ( _ STR ) ; } } else { try { check ( ) ; } catch (  Runtime Exception e ) { rethrow ( e ) ; } } if ( constraints != null && constraints . is Empty ( ) ) { throw new  Invalid Object Exception ( _ STR ) ; } }
public static  Script create Multi Sig Input Script Bytes (  List < byte [ ] > signatures ) { check Argument ( signatures . size ( ) <= _ NUM ) ;  Script Builder builder = new  Script Builder ( ) ; builder . small Num ( _ NUM ) ; for ( byte [ ] signature : signatures ) builder . data ( signature ) ; return builder . build ( ) ; }
public static void gc2gc ( double c1 [ ] , int m1 , double g1 , double c2 [ ] , int m2 , double g2 ) { double [ ] gc2gc_buff =  Arrays . copy Of ( c1 , m1 + _ NUM ) ; c2 [ _ NUM ] = gc2gc_buff [ _ NUM ] ; for ( int i = _ NUM ; i <= m2 ; i ++ ) { double ss1 = _ NUM ; double ss2 = _ NUM ; int min = m1 < i ? m1 : i - _ NUM ; for ( int k = _ NUM ; k <= min ; k ++ ) { int mk = i - k ; double cc = gc2gc_buff [ k ] * c2 [ mk ] ; ss2 += k * cc ; ss1 += mk * cc ; } if ( i <= m1 ) c2 [ i ] = gc2gc_buff [ i ] + ( g2 * ss2 - g1 * ss1 ) / i ; else c2 [ i ] = ( g2 * ss2 - g1 * ss1 ) / i ; } }
public static boolean between (  Date base Date ,  Date start Date ,  Date end Date ) { if ( start Date . equals ( end Date ) || end Date . before ( start Date ) ) { return _ BOOL ; } if ( ( start Date . before ( base Date ) || start Date . equals ( base Date ) ) && ( end Date . after ( base Date ) || end Date . equals ( base Date ) ) ) { return _ BOOL ; } return _ BOOL ; }
public void add Listener ( final  Timeout Event Listener listener ) { final long timeout = listener . get Timeout ( ) ; if ( timeout > _ NUM ) { listeners . add ( listener ) ; synchronized ( state Lock ) { pending Listener Min Delay =  Math . min ( pending Listener Min Delay , timeout ) ; state Lock . notify All ( ) ; } } }
public static  String transform Tool Tip Text ( final  String description , final boolean add HTMLTags , final int line Length , final boolean escape Slashes , final boolean escape HTML ) {  String complete Text = description . trim ( ) ; if ( escape HTML ) { complete Text =  Tools . escape HTML ( complete Text ) ; } if ( escape Slashes ) { complete Text = complete Text . replace All ( _ STR , _ STR ) ; }  String Buffer result = new  String Buffer ( ) ; if ( add HTMLTags ) { result . append ( _ STR ) ; } complete Text =  Tools . transform All Line Separators ( complete Text ) ;  String [ ] lines = complete Text . split ( _ STR ) ; for (  String text : lines ) { boolean first = _ BOOL ; while ( text . length ( ) > line Length ) { int space Index = text . index Of ( _ STR , line Length ) ; if ( ! first ) { result . append ( _ STR ) ; } first = _ BOOL ; if ( space Index >= _ NUM ) { result . append ( text . substring ( _ NUM , space Index ) ) ; text = text . substring ( space Index + _ NUM ) ; } else { result . append ( text ) ; text = _ STR ; } } if ( ! first && text . length ( ) > _ NUM ) { result . append ( _ STR ) ; } result . append ( text ) ; result . append ( _ STR ) ; } if ( add HTMLTags ) { result . append ( _ STR ) ; } return result . to String ( ) ; }
@  Override public void write ( byte [ ] buffer , int offset , int length ) { if ( is Closed ( ) || is Head ( ) ) { return ; } int byte Length = _offset ; while ( _ BOOL ) { int sublen =  Math . min ( length ,  SIZE - byte Length ) ;  System . arraycopy ( buffer , offset , _buffer , byte Length , sublen ) ; offset += sublen ; length -= sublen ; byte Length += sublen ; if ( length <= _ NUM ) { break ; } _offset = byte Length ; flush Byte Buffer ( ) ; byte Length = _offset ; } _offset = byte Length ; }
public  Client Http Request (  URLConnection connection ) throws  IOException { this . connection = connection ; connection . set Do Output ( _ BOOL ) ; connection . set Do Input ( _ BOOL ) ; connection . set Request Property ( _ STR , _ STR + boundary ) ; }
private void append Tag (  String tag Name ,  String value ) { xml . append ( _ STR ) ; xml . append ( tag Name ) ; xml . append ( _ STR ) ; xml . append ( value ) ; xml . append ( _ STR ) ; xml . append ( tag Name ) ; xml . append ( _ STR ) ; }
@  Override public  Certificate Token Validation Extra Info extra Info ( ) { return extra Info ; }
public void add Top Level Contents (  Collection <  Content Element > contents ) { top Level Contents . add All ( contents ) ; }
public static void with Instance (  Map <  String ,  Object > args ,  Closure c ) throws  SQLException ,  Class Not Found Exception {  Sql sql = null ; try { sql = new Instance ( args ) ; c . call ( sql ) ; } finally { if ( sql != null ) sql . close ( ) ; } }
public void write ( byte [ ] buffer , int offset , int length , boolean is End ) throws  IOException { throw new  Unsupported Operation Exception (  String . value Of ( this ) ) ; }
private boolean add Index Entry (  Service Type resource Type ,  String resource Name ,  String policy Name ) throws  Policy Exception {  Resource Index resource Index = (  Resource Index ) resource Indices . get ( resource Type . get Name ( ) ) ; if ( resource Index == null ) { resource Index = refresh Resource Index From Data Store ( resource Type ) ; } return resource Index . add Index Entry ( resource Name , policy Name ) ; }
public void dd Solve (  Set <  Node > qry Nodes ) { long solve_time = _ NUM , prepare_time = _ NUM ; if ( has Executed == _ BOOL ) solve ( ) ; if ( dd Prepared == _ BOOL || offline Processor == null ) { offline Processor = new  Offline Processor ( this ) ;  IFigure Manager . clean Cache ( ) ; dd Prepared = _ BOOL ; ps . println ( ) ; ps . println ( _ STR ) ; } int init_size = qry Nodes . size ( ) ; if ( init_size == _ NUM ) { ps . println ( _ STR ) ; return ; }  Date prepare_begin = new  Date ( ) ; offline Processor . init ( ) ; offline Processor . add User Def Pts ( qry Nodes ) ; offline Processor . run Optimizations ( ) ;  Date prepare_end = new  Date ( ) ; prepare_time += prepare_end . get Time ( ) - prepare_begin . get Time ( ) ;  Date begin = new  Date ( ) ; prepare Next Run ( ) ; node Generator . init Flow Graph ( this ) ; solve Constraints ( ) ;  Date end = new  Date ( ) ; solve_time += end . get Time ( ) - begin . get Time ( ) ; ps . println ( ) ; ps . printf ( _ STR , ( double ) prepare_time / _ NUM ) ; ps . printf ( _ STR , ( double ) solve_time / _ NUM ) ; }
private static void delete From ( int delete At , int [ ] starts , int num Starts ) { while ( starts [ -- num Starts ] > delete At ) { starts [ num Starts ] -= _ NUM ; } }
public static  Event Type Metadata create Bean Type (  String name ,  Class clazz , boolean is Pre Configured Static , boolean is Pre Configured , boolean is Configured ,  Type Class type Class ) {  Set <  String > secondary Names = null ; if ( name == null ) { name = clazz . get Name ( ) ; } else { if ( ! name . equals ( clazz . get Name ( ) ) ) { secondary Names = new  Linked Hash Set <  String > ( ) ; secondary Names . add ( clazz . get Name ( ) ) ; } } return new  Event Type Metadata ( name , secondary Names , type Class , is Pre Configured Static , is Pre Configured , is Configured ,  Application Type .  CLASS , _ BOOL ) ; }
private boolean reverse It ( ) { if ( ! is Active ( ) ) throw new  Illegal State Exception ( _ STR ) ;  MPeriod . test Period Open ( get Ctx ( ) , get Date Trx ( ) ,  MPeriod Control .  DOCBASETYPE_ Payment Allocation , get AD_ Org_ ID ( ) ) ; set Is Active ( _ BOOL ) ; if ( ! is Posted ( ) ) set Posted ( _ BOOL ) ; set Document No ( get Document No ( ) + _ STR ) ; set Doc Status (  DOCSTATUS_ Reversed ) ; if ( ! save ( ) || is Active ( ) ) throw new  Illegal State Exception ( _ STR ) ;  MFact Acct . delete Ex (  MAllocation Hdr .  Table_ ID , get C_ Allocation Hdr_ ID ( ) , get_ Trx Name ( ) ) ; get Lines ( _ BOOL ) ;  Hash Set <  Integer > bps = new  Hash Set <  Integer > ( ) ; for ( int i = _ NUM ; i < m_lines . length ; i ++ ) {  MAllocation Line line = m_lines [ i ] ; line . set Is Active ( _ BOOL ) ; line . save Ex ( ) ; bps . add ( new  Integer ( line . process It ( _ BOOL ) ) ) ; } update BP ( bps ) ; return _ BOOL ; }
public static boolean use Subject Creds Only (  GSSCaller caller ) { if ( caller instanceof  Http Caller ) { return _ BOOL ; }  String prop Value =  Access Controller . do Privileged ( new  Get Property Action ( _ STR , _ STR ) ) ; return ( ! prop Value . equals Ignore Case ( _ STR ) ) ; }
public void delete Storage (  Storage Data storage Data ) throws  Business Exception ,  IOException {  Storage Data local = get Local Storage Data Object ( storage Data ) ; synchronized ( local ) { if ( ( storage Recorder . is Recording On ( ) || storage Recorder . is Recording Scheduled ( ) ) &&  Objects . equals ( local , recorder Storage Data ) ) { throw new  Business Exception ( _ STR + local + _ STR ,  Storage Error Code Enum .  STORAGE_ ALREADY_ CLOSED ) ; } if ( local . is Storage Opened ( ) ) {  Storage Writer writer = opened Storages Map . get ( local ) ; if ( writer != null ) { writer . cancel ( ) ; } opened Storages Map . remove ( local ) ; } delete Complete Storage Data From Disk ( local ) ; existing Storages Set . remove ( local ) ; } }
public  Coap Response advanced (  Request request ) { assign Client Uri If Empty ( request ) ; return synchronous ( request ) ; }
public void visit Error Node (  Error Node node ) {  Progress Indicator Provider . check Canceled ( ) ;  Token bad Token = node . get Symbol ( ) ; boolean is Conjured Token = bad Token . get Token Index ( ) < _ NUM ; int node Start Index = bad Token . get Start Index ( ) ;  Syntax Error error = token To Error Map . get ( node Start Index ) ; if ( error != null ) {  Psi Builder .  Marker error Marker = builder . mark ( ) ; if ( bad Token . get Start Index ( ) >= _ NUM && bad Token . get Type ( ) !=  Token .  EOF && ! is Conjured Token ) { builder . advance Lexer ( ) ; }  String message =  String . format ( _ STR , error . get Message ( ) ) ; error Marker . error ( message ) ; } else { if ( is Conjured Token ) {  Psi Builder .  Marker error Marker = builder . mark ( ) ; error Marker . error ( bad Token . get Text ( ) ) ; } else { builder . advance Lexer ( ) ; } } }
@  Override public boolean condition Ok (  Example example ) { boolean is Ok = _ BOOL ; for (  Attribute attribute : checked Attributes ) { is Ok &= !  Double . is Na N ( example . get Value ( attribute ) ) ; } return is Ok ; }
private void load Binary (  Input Stream is ) throws  IOException { if ( use New IO && is instanceof  File Input Stream ) {  File Input Stream fis = (  File Input Stream ) is ; if ( use Indexing ) { load Binary Index ( new  URL ( index Name ) ) ; map Database ( fis ) ; } else { load Mapped Binary ( fis ) ; } } else {  Data Input Stream dis = new  Data Input Stream ( new  Buffered Input Stream ( is ) ) ; load Binary ( dis ) ; } }
public  VNXe Command Job delete Luns From Lun Group (  String lun Group Id ,  List <  String > luns ) {  Lun Group Modify Param param = new  Lun Group Modify Param ( ) ;  List <  Lun Add Param > lun Delete = new  Array List <  Lun Add Param > ( ) ; for (  String lun Id : luns ) {  VNXe Base lun = new  VNXe Base ( lun Id ) ;  Lun Add Param lun Add = new  Lun Add Param ( ) ; lun Add . set Lun ( lun ) ; lun Delete . add ( lun Add ) ; } param . set Lun Delete ( lun Delete ) ;  Lun Group Requests req = new  Lun Group Requests ( _kh Client ) ; return req . modify Lun Group Async ( lun Group Id , param ) ; }
public void remove Locators (  Lookup Locator [ ] locators ) { test Set For Null ( locators ) ; synchronized ( this ) { if ( terminated ) { throw new  Illegal State Exception ( _ STR ) ; }  Hash Map groups Map = new  Hash Map ( _ NUM ) ; for ( int i = _ NUM ; i < locators . length ; i ++ ) {  Locator Reg reg = remove Discovered Locator ( locators [ i ] ) ; if ( reg != null ) { groups Map . put ( reg . proxy , reg . member Groups ) ; continue ; } reg = find Reg ( locators [ i ] ) ; if ( reg != null ) { undiscovered Locators . remove ( reg ) ; } } if ( ! groups Map . is Empty ( ) && ! listeners . is Empty ( ) ) { add Notify ( (  Array List ) listeners . clone ( ) , groups Map , _ BOOL ) ; } } }
public boolean is_selected (  Item Selection Choice p_choice ) { return sel_array [ p_choice . ordinal ( ) ] ; }
private void add ( final  IProgress Operation operation ) { final  Grid Bag Constraints constraints = new  Grid Bag Constraints ( ) ; constraints . fill =  Grid Bag Constraints .  HORIZONTAL ; constraints . gridy = counter ++ ; constraints . gridx = _ NUM ; constraints . weightx = _ NUM ; constraints . weighty = _ NUM ; m_progress Panel . add ( operation . get Progress Panel ( ) , constraints ) ; }
public  Key Store Builder with Provider ( final  String provider Name ) {  Provider provider =  Security . get Provider ( provider Name ) ; if ( provider == null ) { throw new  Illegal Argument Exception ( _ STR + provider Name ) ; } return with Provider ( provider ) ; }
public static  Http URLConnection to Http Connection (  Request ... requests ) { return to Http Connection (  Arrays . as List ( requests ) ) ; }
public  Composite Route Finder ( final  Game Map map , final  Hash Map <  Match <  Territory > ,  Integer > matches ) { m_map = map ; m_matches = matches ; s_logger . finer ( _ STR ) ; }
public  TCPEndpoint (  String host , int port ) { this ( host , port , null , null ) ; }
public void test Bug22613 ( ) throws  Exception { create Table ( _ STR , _ STR ) ; check Metadata For Bug22613 ( this . conn ) ; if ( version Meets Minimum ( _ NUM , _ NUM ) ) {  Connection info Schem Conn = null ; try {  Properties props = new  Properties ( ) ; props . set Property ( _ STR , _ STR ) ; info Schem Conn = get Connection With Props ( props ) ; check Metadata For Bug22613 ( info Schem Conn ) ; } finally { if ( info Schem Conn != null ) { info Schem Conn . close ( ) ; } } } }
public  Program Rewriter (  Array List <  Hop Rewrite Rule > h Rewrites ,  Array List <  Statement Block Rewrite Rule > sb Rewrites ) { _dag Rule Set = new  Array List <  Hop Rewrite Rule > ( ) ; _dag Rule Set . add All ( h Rewrites ) ; _sb Rule Set = new  Array List <  Statement Block Rewrite Rule > ( ) ; _sb Rule Set . add All ( sb Rewrites ) ; }
private  JMenu create Settings Menu ( ) { final  JMenu menu = new  JMenu ( _ STR ) ; menu . set Mnemonic ( _ STR ) ; menu . add ( new  CAction Show Settings Dialog ( get Parent ( ) ) ) ; menu . add ( new  JSeparator ( ) ) ; menu . add ( new  CAction Initial Callgraph Settings ( get Parent ( ) ) ) ; menu . add ( new  CAction Initial Flowgraph Settings ( get Parent ( ) ) ) ; return menu ; }
public static void write String (  Data Output Stream os ,  String s ) throws  IOException { if ( s == null ) { os . write Int ( - _ NUM ) ; } else { byte array [ ] = s . get Bytes ( ) ; os . write Int ( array . length ) ; os . write ( array ) ; } }
public static boolean is Java Valid Name (  String str ) { if ( str . is Empty ( ) ) return _ BOOL ; if ( java Keys . contains ( str ) ) return _ BOOL ; char first = str . char At ( _ NUM ) ; if ( is Valid Name Start Char ( first ) ) { for ( int i = _ NUM ; i < str . length ( ) ; ++ i ) { char c = str . char At ( i ) ; if ( ! is Valid Name Char ( c ) ) return _ BOOL ; } return _ BOOL ; } else { return _ BOOL ; } }
private  List <  String > create Commands ( ) {  List <  String > commands = create Node Commands ( nodejs File , ts File ) ;  List <  String > args = create Node Args ( ) ; if ( args != null ) { commands . add All ( args ) ; } return commands ; }
private void parse Packages (  Sensor Context sensor Context ) { for (  Directory directory : package List ) { sensor Context . save Measure ( directory ,  Core Metrics .  DIRECTORIES , _ NUM ) ; sensor Context . save Measure ( directory ,  Core Metrics .  FILES , ( double ) files Count . get ( directory ) ) ; } }
public static  Thread consume Process Error Stream (  Process self ,  Appendable error ) {  Thread thread = new  Thread ( new  Text Dumper ( self . get Error Stream ( ) , error ) ) ; thread . start ( ) ; return thread ; }
public  Str Builder delete First ( final  String str ) { final int len = ( str == null ? _ NUM : str . length ( ) ) ; if ( len > _ NUM ) { final int index = index Of ( str , _ NUM ) ; if ( index >= _ NUM ) { delete Impl ( index , index + len , len ) ; } } return this ; }
@  Reference ( authors = _ STR , booktitle = _ STR , title = _ STR , url = _ STR ) public static <  V extends  Number Vector > double log Likelihood (  Relation <  V > relation ,  Clustering < ? extends  Mean Model > clustering ,  Number Vector Distance Function < ? super  V > distance Function ) {  List < ? extends  Cluster < ? extends  Mean Model > > clusters = clustering . get All Clusters ( ) ; final int dim =  Relation Util . dimensionality ( relation ) ; final int m = clusters . size ( ) ; int n = _ NUM ; int [ ] n_i = new int [ m ] ; double d = _ NUM ; double [ ] d_i = new double [ m ] ;  Iterator < ? extends  Cluster < ? extends  Mean Model > > it = clusters . iterator ( ) ; for ( int i = _ NUM ; it . has Next ( ) ; ++ i ) {  Cluster < ? extends  Mean Model > cluster = it . next ( ) ; n += n_i [ i ] = cluster . size ( ) ; d += d_i [ i ] = variance Of Cluster ( cluster , distance Function , relation ) ; } if ( n <= m ) { return  Double .  NEGATIVE_ INFINITY ; } final double v = d / ( n - m ) , logv =  Math . log ( v ) ; double log Likelihood = _ NUM ; for ( int i = _ NUM ; i < m ; i ++ ) { log Likelihood += n_i [ i ] *  Math . log ( n_i [ i ] ) - n_i [ i ] * _ NUM *  Math Util .  LOGTWOPI - n_i [ i ] * dim * _ NUM * logv - ( d_i [ i ] - m ) * _ NUM ; } log Likelihood -= n *  Math . log ( n ) ; return log Likelihood ; }
private static  Class < ? > [ ] classes For Params (  List <  String > params ) {  Class < ? > [ ] result = new  Class < ? > [ params . size ( ) ] ; for ( int i = _ NUM ; i < params . size ( ) ; i ++ ) { result [ i ] = class For Param ( params . get ( i ) ) ; } return result ; }
private boolean announce (  String [ ] groups ) { if ( data Packets == null || ! last Locator . equals ( my Locator ) || !  Arrays . equals ( last Groups , groups ) ) {  List <  Datagram Packet > packets = new  Array List <  Datagram Packet > ( ) ;  Discovery disco ; try { disco = get Discovery ( multicast Announcement Constraints . choose Protocol Version ( ) ) ; } catch (  Discovery Protocol Exception e ) { throw new  Assertion Error ( e ) ; }  Encode Iterator ei = disco . encode Multicast Announcement ( new  Multicast Announcement ( announcement Seq No ++ , my Locator . get Host ( ) , my Locator . get Port ( ) , groups , my Service ID ) , multicast Announcement Constraints . get Multicast Max Packet Size (  DEFAULT_ MAX_ PACKET_ SIZE ) , multicast Announcement Constraints . get Unfulfilled Constraints ( ) ) ; while ( ei . has Next ( ) ) { try { packets . add All (  Arrays . as List ( ei . next ( ) ) ) ; } catch (  Exception e ) { logger . log ( ( e instanceof  Unsupported Constraint Exception ) ?  Levels .  HANDLED :  Level .  INFO , _ STR + _ STR , e ) ; } } last Locator = my Locator ; last Groups = groups ; data Packets = packets . to Array ( new  Datagram Packet [ packets . size ( ) ] ) ; } try { send ( data Packets ) ; } catch (  Interrupted IOException e ) { return _ BOOL ; } return _ BOOL ; }
final public void trim To Size ( ) { for (  Gaz Entry ge : gaz . values ( ) ) { ge . trim To Size ( ) ; } }
public boolean contains Select Account ( ) { return prompts . contains (  PROMPT_ SELECT_ ACCOUNT ) ; }
protected static void quick Sort (  Instances insts , int [ ] indices , int attidx , int left , int right ) { if ( left < right ) { int middle = partition ( insts , indices , attidx , left , right ) ; quick Sort ( insts , indices , attidx , left , middle ) ; quick Sort ( insts , indices , attidx , middle + _ NUM , right ) ; } }
public  Image flip Image Horizontally (  Image image , boolean maintain Opacity ) { int [ ] rgb = image . get RGB ( ) ; int [ ] new RGB = new int [ rgb . length ] ; int width = image . get Width ( ) ; int height = image . get Height ( ) ; for ( int y = _ NUM ; y < height ; y ++ ) { for ( int x = _ NUM ; x < width ; x ++ ) { new RGB [ ( width - x - _ NUM ) + y * width ] = rgb [ x + y * width ] ; } } return  Encoded Image . create From RGB ( new RGB , width , height , ! maintain Opacity ) ; }
public static boolean is Terms Request (  Sip Request request ) {  String content Type = request . get Content Type ( ) ; return ( content Type != null && content Type . starts With ( _ STR ) ) ; }
private void read Segments ( ) throws  IOException { for (  Segment Extent10 extent : _segment Extents ) { try (  Read Stream is = open Read ( extent . address ( ) , extent . length ( ) ) ) { is . skip ( extent . length ( ) -  BLOCK_ SIZE ) ; long sequence =  Bits Util . read Long ( is ) ; byte [ ] table Key = new byte [  TABLE_ KEY_ SIZE ] ; is . read All ( table Key , _ NUM , table Key . length ) ; if ( sequence > _ NUM ) {  Segment10 segment = new  Segment10 ( sequence , table Key , extent ) ; _segments . add ( segment ) ; } } } }
public static double project Time Within24 Hours ( double time ) { double seconds In One Day = _ NUM * _ NUM * _ NUM ; if ( time ==  Double .  NEGATIVE_ INFINITY || time ==  Double .  POSITIVE_ INFINITY ) {  Debug Lib . stop System And Report Inconsistency ( _ STR ) ; } while ( time < _ NUM ) { time += seconds In One Day ; } if ( time < seconds In One Day ) { return time ; } else { return ( ( time / seconds In One Day ) - (  Math . floor ( time / seconds In One Day ) ) ) * seconds In One Day ; } }
@  Suppress Warnings ( _ STR ) public static void check Type (  Map <  String ,  Object > map ,  String name ) {  Map <  String ,  Object > tmap ; if ( map . get (  Metamodel Generator .  KEY_ TYPE ) instanceof  Map ) { tmap = (  Map <  String ,  Object > ) map . get (  Metamodel Generator .  KEY_ TYPE ) ; } else if ( map . get (  Metamodel Generator .  KEY_ TYPE ) instanceof  String ) { tmap = new  Hash Map <  String ,  Object > ( ) ; tmap . put (  Metamodel Generator .  KEY_ NAME , map . get (  Metamodel Generator .  KEY_ TYPE ) ) ; } else { tmap = map ; } int join = name . index Of ( _ STR ) ; if ( join > _ NUM ) { while ( join > _ NUM && ! pointy Brackets Even ( name . substring ( _ NUM , join ) ) ) { join = name . index Of ( _ STR , join + _ NUM ) ; } if ( join > _ NUM ) {  Assert . assert Equals ( _ STR , _ STR , tmap . get ( _ STR ) ) ; check Type Parameters ( - _ NUM , (  List <  Map <  String ,  Object > > ) tmap . get (  Metamodel Generator .  KEY_ TYPES ) , name . substring ( _ NUM , join ) ) ; check Type Parameters ( - _ NUM , (  List <  Map <  String ,  Object > > ) tmap . get (  Metamodel Generator .  KEY_ TYPES ) , name . substring ( join + _ NUM ) ) ; return ; } } join = name . index Of ( _ STR ) ; if ( join > _ NUM ) { while ( join > _ NUM && ! pointy Brackets Even ( name . substring ( _ NUM , join ) ) ) { join = name . index Of ( _ STR , join + _ NUM ) ; } if ( join > _ NUM ) {  Assert . assert Equals ( _ STR , _ STR , tmap . get ( _ STR ) ) ; check Type Parameters ( - _ NUM , (  List <  Map <  String ,  Object > > ) tmap . get (  Metamodel Generator .  KEY_ TYPES ) , name . substring ( _ NUM , join ) ) ; check Type Parameters ( - _ NUM , (  List <  Map <  String ,  Object > > ) tmap . get (  Metamodel Generator .  KEY_ TYPES ) , name . substring ( join + _ NUM ) ) ; return ; } } int sep = name . index Of ( _ STR ) ;  String type Params = null ; if ( sep > _ NUM ) { type Params = name . substring ( sep + _ NUM , name . length ( ) - _ NUM ) ; name = name . substring ( _ NUM , sep ) ; } if ( tmap . contains Key (  Metamodel Generator .  KEY_ PACKAGE ) ) {  Assert . assert Equals ( name ,  String . format ( _ STR , package Name ( tmap ) , tmap . get (  Metamodel Generator .  KEY_ NAME ) ) ) ; } else {  Assert . assert Equals ( name , tmap . get (  Metamodel Generator .  KEY_ NAME ) ) ; } if ( type Params != null ) {  List <  Map <  String ,  Object > > tparms = (  List <  Map <  String ,  Object > > ) tmap . get (  Metamodel Generator .  KEY_ TYPE_ PARAMS ) ;  Assert . assert False ( _ STR , tparms . is Empty ( ) ) ; check Type Parameters ( _ NUM , tparms , type Params ) ; } }
private  Object _deserialize Struct (  Element el Struct ) throws  Converter Exception {  String type = el Struct . get Attribute ( _ STR ) ;  Struct struct = new  Struct Impl ( ) ;  Node List list = el Struct . get Child Nodes ( ) ; int len = list . get Length ( ) ; for ( int i = _ NUM ; i < len ; i ++ ) {  Node node = list . item ( i ) ; if ( node instanceof  Element ) {  Element var = (  Element ) node ;  Element value = get Child Element ( (  Element ) node ) ; if ( value != null ) { struct . set EL ( var . get Attribute ( _ STR ) , _deserialize ( value ) ) ; } } } if ( struct . size ( ) == _ NUM && type != null && type . length ( ) > _ NUM ) { return _ STR ; } return struct ; }
public  Querier CLI (  String [ ] args ) { cli Options = create Options ( ) ; try {  Command Line Parser parser = new  Gnu Parser ( ) ; command Line = parser . parse ( cli Options , args , _ BOOL ) ; if ( has Option ( _ STR ) ) { print Help ( ) ;  System . exit ( _ NUM ) ; } if ( ! parse Options ( ) ) { logger . info ( _ STR ) ; print Help ( ) ;  System . exit ( _ NUM ) ; } } catch (  Exception e ) { e . print Stack Trace ( ) ;  System . exit ( _ NUM ) ; } }
private static byte [ ] concat Bytes ( byte [ ] array1 , byte [ ] array2 ) { byte [ ] c Bytes = new byte [ array1 . length + array2 . length ] ; try {  System . arraycopy ( array1 , _ NUM , c Bytes , _ NUM , array1 . length ) ;  System . arraycopy ( array2 , _ NUM , c Bytes , array1 . length , array2 . length ) ; } catch (  Exception e ) { throw new  Runtime Exception ( e ) ; } return c Bytes ; }
void write Value Properties (  String full Id , long db Id ,  String local Id ,  Json Value value ,  Connection connection ) throws  SQLException { if ( cfg . has Possible Searchable Properties ( ) ) {  Integer batching Count = _ NUM ;  Prepared Statement prop Create Statement = get Prepared Statement ( connection ,  Query Definition .  PROPCREATEQUERYSTR ) ; try { batching Count = write Value Properties ( full Id , db Id , local Id , value , connection , prop Create Statement , batching Count ) ; if ( enable Batching && batching Count > _ NUM ) { int [ ] num Updates = prop Create Statement . execute Batch ( ) ; logger . debug ( _ STR , num Updates ) ; if ( logger . is Debug Enabled ( ) ) { logger . debug ( _ STR ,  Arrays . as List ( num Updates ) ) ; } prop Create Statement . clear Batch ( ) ; } } finally {  Cleanup Helper . logged Close ( prop Create Statement ) ; } } }
protected double compute Max YAxis Value Log Scale ( double max Value ) { double v = _ NUM ; int mantisse = _ NUM ; int exponent = _ NUM ; while ( v < max Value ) { if ( mantisse < _ NUM ) mantisse ++ ; else { mantisse = _ NUM ; exponent ++ ; } v = mantisse *  Math . pow ( _ NUM , exponent ) ; } return  Math . log10 ( v ) ; }
public void add Focus Cleared Listener (  Focus Cleared Listener focus Cleared Listener ) { m Focus Cleared Listeners . add ( focus Cleared Listener ) ; }
public void add Item Listener (  Item Listener a Listener ) { listener List . add (  Item Listener . class , a Listener ) ; }
@  Override public  Enumeration <  Option > list Options ( ) {  Vector <  Option > result ; result = new  Vector <  Option > ( ) ; result . add Element ( new  Option ( _ STR + _ STR , _ STR , _ NUM , _ STR ) ) ; result . add Element ( new  Option ( _ STR + _ STR + _ STR , _ STR , _ NUM , _ STR ) ) ; result . add Element ( new  Option ( _ STR + _ STR + get Default Num Decimals ( ) + _ STR , _ STR , _ NUM , _ STR ) ) ; result . add Element ( new  Option ( _ STR + _ STR + _ STR , _ STR , _ NUM , _ STR ) ) ; result . add Element ( new  Option ( _ STR + _ STR + _ STR , _ STR , _ NUM , _ STR ) ) ; return result . elements ( ) ; }
public static  Mosaic Levy create Mosaic Levy ( final  Mosaic Id mosaic Id ) { return new  Mosaic Levy (  Mosaic Transfer Fee Type .  Absolute , generate Random Account ( ) , mosaic Id ,  Quantity . from Value ( _ NUM ) ) ; }
public int rank Of ( double value ) { int ret = _ NUM ; if ( ! has Capacity ( ) ) { ret =  Arrays . binary Search ( data , value ) ; if ( ret < _ NUM ) { return - ret - _ NUM ; } else { return ret ; } } else { for ( int i = _ NUM ; i < next ; i ++ ) { if ( data [ i ] < value ) { ret ++ ; } } return ret ; } }
public static <  T >  Predicate <  T > not (  Predicate <  T > predicate ) { return predicate . negate ( ) ; }
private static void add Margin Top To Content Child (  View m Content Child , int status Bar Height ) { if ( m Content Child == null ) { return ; } if ( !  TAG_ MARGIN_ ADDED . equals ( m Content Child . get Tag ( ) ) ) {  Frame Layout .  Layout Params lp = (  Frame Layout .  Layout Params ) m Content Child . get Layout Params ( ) ; lp . top Margin += status Bar Height ; m Content Child . set Layout Params ( lp ) ; m Content Child . set Tag (  TAG_ MARGIN_ ADDED ) ; } }
static byte [ ] hex String To Byte Array (  String hex String ) {  String s = hex String ; int len = s . length ( ) ; if ( len % _ NUM == _ NUM ) { s = _ STR + s ; len ++ ; } byte [ ] data = new byte [ len / _ NUM ] ; for ( int i = _ NUM ; i < len ; i += _ NUM ) { data [ i / _ NUM ] = ( byte ) ( (  Character . digit ( s . char At ( i ) , _ NUM ) << _ NUM ) +  Character . digit ( s . char At ( i + _ NUM ) , _ NUM ) ) ; } return data ; }
private void fetch Schema ( ) throws  Execution Exception ,  Rpc Exception ,  Timeout Exception {  Message schema =  Rpc . get ( my Client . get Schema ( ) ,  FETCH_ SCHEMA_ TIMEOUT_ MS ,  Time Unit .  MILLISECONDS ) ;  LOG . info ( _ STR + schema . entities . length + _ STR + schema . constants . length + _ STR ) ; int atoms = _ NUM ; for (  Entity type : schema . entities ) { if (  Atom Metadata . find ( type ) != null ) { atoms ++ ; }  Dynamic . register ( type ) ; }  LOG . info ( _ STR + atoms + _ STR ) ; for (  Constant Set set : schema . constants ) {  Constant Set . register ( set ) ; } }
private void append (  String Builder buffer , double [ ] data ,  String prefix ,  String separator ,  String suffix ) { buffer . append ( prefix ) ; for ( int i = _ NUM ; i < data . length ; ++ i ) { if ( i > _ NUM ) { buffer . append ( separator ) ; } buffer . append ( data [ i ] ) ; } buffer . append ( suffix ) ; }
public  T to Real Array ( ) { return _output Array Type . cast (  Array Multidimensionalizer . multidimensionalize ( _real , _dimensions ) ) ; }
private  Array List <  Writable Comparable > read Partitions (  File System fs ,  Path p ,  Job Conf job ) throws  IOException {  Sequence File .  Reader reader = new  Sequence File .  Reader ( fs , p , job ) ;  Array List <  Writable Comparable > parts = new  Array List <  Writable Comparable > ( ) ; try {  Double Writable key = new  Double Writable ( ) ;  Null Writable value =  Null Writable . get ( ) ; while ( reader . next ( key , value ) ) { parts . add ( key ) ; key = new  Double Writable ( ) ; } } catch (  Exception e ) { throw new  Runtime Exception ( e ) ; } finally {  IOUtil Functions . close Silently ( reader ) ; } reader . close ( ) ; return parts ; }
public boolean poll Seqno ( long seqno ) { return seqno <= disk Log . get Max Seqno ( ) ; }
public void add Slide ( @  Non Null  Fragment fragment ) { fragments . add ( fragment ) ; add Background Color (  Color .  TRANSPARENT ) ; pager Adapter . notify Data Set Changed ( ) ; }
public  String process (  Item item ) throws  Process Exception { int count = _ NUM ;  Item in Phrase =  SUB_ PHRASE_ PATH . find Item ( item ) ; for (  Item p = in Phrase ; p != null ; p = p . get Previous ( ) ) { count ++ ; } return  Integer . to String ( rail ( count ) ) ; }
public  E push (  E value ) { elements . add ( value ) ; return value ; }
public long cardinality ( final int tail Index ) { return range Count ( tail Index ) ; }
public static void create Response (  Http Servlet Request request ,  Http Servlet Response response ,  Http Servlet servlet ,  Properties cookie Properties ,  Web Doc doc , boolean debug ) throws  IOException { response . set Header ( _ STR , _ STR ) ; response . set Content Type ( _ STR ) ; if ( cookie Properties != null ) {  Cookie cookie = new  Cookie (  Web Env .  COOKIE_ INFO , properties Encode ( cookie Properties ) ) ; cookie . set Comment ( _ STR ) ; cookie . set Secure ( _ BOOL ) ; cookie . set Path ( _ STR ) ; if ( cookie Properties . size ( ) == _ NUM ) cookie . set Max Age ( _ NUM ) ; else cookie . set Max Age ( _ NUM ) ; response . add Cookie ( cookie ) ; } if ( debug &&  Web Env .  DEBUG ) {  Web Env . add Footer ( request , response , servlet , doc . get Body ( ) ) ; }  Print Writer out = response . get Writer ( ) ; doc . output ( out ) ; out . flush ( ) ; if ( out . check Error ( ) ) log . log (  Level .  SEVERE , _ STR ) ; out . close ( ) ; }
public static  Long to Long (  Object o ) throws  Page Exception { if ( o instanceof  Long ) return (  Long ) o ; return  Long . value Of ( to Long Value ( o ) ) ; }
protected void finish Grid Row ( ) {  Grid Bag Constraints constraints = new  Grid Bag Constraints ( ) ; constraints . gridwidth =  Grid Bag Constraints .  REMAINDER ; constraints . weightx = _ NUM ; final  JLabel icon ; if ( param . is Optional ( ) ) { if ( param . is Defined ( ) && param . took Default Value ( ) && ! ( param instanceof  Flag ) ) { icon = new  JLabel (  Stock Icon . get Stock Icon (  Stock Icon .  DIALOG_ INFORMATION ) ) ; icon . set Tool Tip Text ( _ STR + param . get Default Value As String ( ) ) ; } else { icon = new  JLabel ( ) ; icon . set Minimum Size ( new  Dimension ( _ NUM , _ NUM ) ) ; } } else { if ( ! param . is Defined ( ) ) { icon = new  JLabel (  Stock Icon . get Stock Icon (  Stock Icon .  DIALOG_ ERROR ) ) ; icon . set Tool Tip Text ( _ STR ) ; } else { icon = new  JLabel ( ) ; icon . set Minimum Size ( new  Dimension ( _ NUM , _ NUM ) ) ; } } parent . add ( icon , constraints ) ; }
@  Override public void shutdown ( ) { if ( ! should Keep Adb Alive ) {  Android Debug Bridge . disconnect Bridge ( ) ;  Android Debug Bridge . terminate ( ) ; } logger . info ( _ STR ) ; }
public void ping Received (  Ping pong ) { long now =  System . current Time Millis ( ) ; long previous Received = ( int ) ( last Ping Sent . get ( ) & _ NUM ) ; log . debug ( _ STR , new  Object [ ] { get Id ( ) , now , pong . get Value2 ( ) , previous Received } ) ; if ( pong . get Value2 ( ) == previous Received ) { last Ping Time . set ( ( int ) ( now & _ NUM ) - pong . get Value2 ( ) ) ; } last Pong Received . set ( now ) ; }
public static int find Object Literal (  Object literal ) { synchronized ( object Literals ) {  Integer result = object Literals . get ( literal ) ; return result == null ? _ NUM : result . int Value ( ) ; } }
@  Override public void reset Viewable Area ( ) { throw new  Runtime Exception ( _ STR ) ; }
public static  Lexicon build Wumpus Lex ( ) {  Lexicon l = new  Lexicon ( ) ;  Array List <  Lex Word > list = new  Array List <  Lex Word > ( ) ; list . add ( new  Lex Word ( _ STR , ( float ) _ NUM ) ) ; list . add ( new  Lex Word ( _ STR , ( float ) _ NUM ) ) ; list . add ( new  Lex Word ( _ STR , ( float ) _ NUM ) ) ; list . add ( new  Lex Word ( _ STR , ( float ) _ NUM ) ) ; list . add ( new  Lex Word ( _ STR , ( float ) _ NUM ) ) ; list . add ( new  Lex Word ( _ STR , ( float ) _ NUM ) ) ; list . add ( new  Lex Word ( _ STR , ( float ) _ NUM ) ) ; list . add ( new  Lex Word ( _ STR , ( float ) _ NUM ) ) ; list . add ( new  Lex Word ( _ STR , ( float ) _ NUM ) ) ; l . put ( _ STR , list ) ;  Array List <  Lex Word > verb List = new  Array List <  Lex Word > ( ) ; verb List . add ( new  Lex Word ( _ STR , ( float ) _ NUM ) ) ; verb List . add ( new  Lex Word ( _ STR , ( float ) _ NUM ) ) ; verb List . add ( new  Lex Word ( _ STR , ( float ) _ NUM ) ) ; verb List . add ( new  Lex Word ( _ STR , ( float ) _ NUM ) ) ; verb List . add ( new  Lex Word ( _ STR , ( float ) _ NUM ) ) ; verb List . add ( new  Lex Word ( _ STR , ( float ) _ NUM ) ) ; verb List . add ( new  Lex Word ( _ STR , ( float ) _ NUM ) ) ; verb List . add ( new  Lex Word ( _ STR , ( float ) _ NUM ) ) ; verb List . add ( new  Lex Word ( _ STR , ( float ) _ NUM ) ) ; l . put ( _ STR , verb List ) ;  Array List <  Lex Word > adj List = new  Array List <  Lex Word > ( ) ; adj List . add ( new  Lex Word ( _ STR , ( float ) _ NUM ) ) ; adj List . add ( new  Lex Word ( _ STR , ( float ) _ NUM ) ) ; adj List . add ( new  Lex Word ( _ STR , ( float ) _ NUM ) ) ; adj List . add ( new  Lex Word ( _ STR , ( float ) _ NUM ) ) ; adj List . add ( new  Lex Word ( _ STR , ( float ) _ NUM ) ) ; adj List . add ( new  Lex Word ( _ STR , ( float ) _ NUM ) ) ; adj List . add ( new  Lex Word ( _ STR , ( float ) _ NUM ) ) ; adj List . add ( new  Lex Word ( _ STR , ( float ) _ NUM ) ) ; adj List . add ( new  Lex Word ( _ STR , ( float ) _ NUM ) ) ; adj List . add ( new  Lex Word ( _ STR , ( float ) _ NUM ) ) ; adj List . add ( new  Lex Word ( _ STR , ( float ) _ NUM ) ) ; adj List . add ( new  Lex Word ( _ STR , ( float ) _ NUM ) ) ; l . put ( _ STR , adj List ) ; l . add Lex Words ( _ STR , _ STR , _ STR , _ STR , _ STR , _ STR , _ STR , _ STR , _ STR , _ STR , _ STR , _ STR , _ STR , _ STR , _ STR , _ STR , _ STR , _ STR , _ STR , _ STR , _ STR , _ STR , _ STR , _ STR , _ STR , _ STR , _ STR , _ STR , _ STR ) ; l . add Lex Words ( _ STR , _ STR , _ STR , _ STR , _ STR , _ STR , _ STR , _ STR , _ STR , _ STR , _ STR , _ STR , _ STR , _ STR , _ STR , _ STR , _ STR ) ; l . add Lex Words ( _ STR , _ STR , _ STR , _ STR , _ STR , _ STR , _ STR , _ STR , _ STR , _ STR , _ STR , _ STR , _ STR ) ; l . add Lex Words ( build Name Lexicon ( ) ) ; l . add Lex Words ( _ STR , _ STR , _ STR , _ STR , _ STR , _ STR , _ STR , _ STR , _ STR , _ STR , _ STR ) ; l . add Lex Words ( _ STR , _ STR , _ STR , _ STR , _ STR , _ STR , _ STR , _ STR , _ STR , _ STR , _ STR , _ STR , _ STR , _ STR , _ STR , _ STR , _ STR , _ STR , _ STR ) ; l . add Lex Words ( _ STR , _ STR , _ STR , _ STR , _ STR , _ STR , _ STR , _ STR , _ STR , _ STR , _ STR , _ STR , _ STR ) ; l . add Lex Words ( _ STR , _ STR , _ STR , _ STR , _ STR , _ STR , _ STR , _ STR , _ STR , _ STR , _ STR ) ; return l ; }
private void test Transfer Rate ( ) {  Assert . assert Not Null ( m Expected Transfer Rate Ops ) ;  Assert . assert Not Null ( m Expected Transfer Rate Bps ) ;  Assert . assert True ( m Expected Transfer Rate Bps . int Value ( ) > _ NUM ) ;  Assert . assert True ( m Expected Transfer Rate Ops . int Value ( ) > _ NUM ) ; }
public void add (  X509 Trust Manager mgr ) { if ( mgr instanceof  X509 Extensions ) { managers . add ( (  X509 Extensions ) mgr ) ; } else { managers . add ( new  X509 Extensions Wrapper ( mgr ) ) ; } }
public  Iterator <  Tree Node > find Children ( ) {  List <  Tree Node > nodes ; if ( children == null ) nodes =  Collections . empty List ( ) ; else nodes = children ; return nodes . iterator ( ) ; }
public static double  I ( double  P [ ] [ ] , int j , int k ) { double  I = _ NUM ; double p_x =  P [ j ] [ j ] ; double p_y =  P [ k ] [ k ] ; double p_xy =  P [ j ] [ k ] ;  I += p_xy *  Math . log ( p_xy / ( p_x * p_y ) ) ;  I += ( _ NUM - p_xy ) *  Math . log ( ( _ NUM - p_xy ) / ( ( _ NUM - p_x ) * ( _ NUM - p_y ) ) ) ; return  I ; }
public  Result do Comparison Test (  Properties properties ) throws  Exception { final long timeout =  Long . parse Long ( properties . get Property (  Test Options .  TIMEOUT ) ) ; final int nclients =  Integer . parse Int ( properties . get Property (  Test Options .  NCLIENTS ) ) ; final int ntrials =  Integer . parse Int ( properties . get Property (  Test Options .  NTRIALS ) ) ; final int key Len =  Integer . parse Int ( properties . get Property (  Test Options .  KEYLEN ) ) ; final int nops =  Integer . parse Int ( properties . get Property (  Test Options .  NOPS ) ) ; final double insert Rate =  Integer . parse Int ( properties . get Property (  Test Options .  INSERT_ RATE ) ) ; final int nindices =  Integer . parse Int ( properties . get Property (  Test Options .  NINDICES ) ) ; final boolean test Correctness =  Boolean . parse Boolean ( properties . get Property (  Test Options .  TEST_ CORRECTNESS ) ) ;  Result result = do Concurrent Client Test ( client , nclients , timeout , ntrials , key Len , nops , insert Rate , nindices , test Correctness ) ; return result ; }
static  String value To String (  Object value , int indent Factor , int indent ) { if ( value == null || value . equals ( null ) ) { return _ STR ; } try { if ( value instanceof  String ) { return quote ( (  String ) value ) ; } } catch (  Exception e ) { } if ( value instanceof  Float || value instanceof  Double || value instanceof  Byte || value instanceof  Short || value instanceof  Integer || value instanceof  Long ) { return number To String ( value ) ; } if ( value instanceof  Boolean ) { return value . to String ( ) ; } if ( value instanceof  Map ) { return print ( (  Map ) value , indent Factor , indent ) ; } if ( value instanceof  List ) { return print ( (  List ) value , indent Factor , indent ) ; } return quote ( value . to String ( ) ) ; }
public static boolean is Retained At Runtime (  Class < ? extends  Annotation > annotation Type ) {  Retention retention = annotation Type . get Annotation (  Retention . class ) ; return retention != null && retention . value ( ) ==  Retention Policy .  RUNTIME ; }
public void test Process Msg5 ( ) { byte [ ] pdu = create PDU ( _ NUM ) ; int header Len = pdu . length - ( m Gsm Header . length + m User Data Header . length + m Message Body . length ) ; int pdu Type = _ NUM ; int tran Id = _ NUM ;  String original Package Name = m Package Name ;  String original Class Name = m Class Name ; try { m Class Name = _ STR ;  IWap Push Manager iwapman = get Interface ( ) ; iwapman . add Package (  Integer . to String ( m App Id Value ) ,  Integer . to String ( m Content Type Value ) , m Package Name , m Class Name ,  Wap Push Manager Params .  APP_ TYPE_ ACTIVITY , _ BOOL , _ BOOL ) ; assert True ( ( iwapman . process Message (  Integer . to String ( m App Id Value ) ,  Integer . to String ( m Content Type Value ) , create Intent ( pdu Type , tran Id ) ) &  Wap Push Manager Params .  MESSAGE_ HANDLED ) ==  Wap Push Manager Params .  MESSAGE_ HANDLED ) ; iwapman . delete Package (  Integer . to String ( m App Id Value ) ,  Integer . to String ( m Content Type Value ) , m Package Name , m Class Name ) ; } catch (  Remote Exception e ) { assert True ( _ BOOL ) ; } m Package Name = original Package Name ; m Class Name = original Class Name ; }
public void add Class Path (  String classpath ) { char sep =  Caucho Util . get Path Separator Char ( ) ; int head = _ NUM ; int tail = _ NUM ; while ( head < classpath . length ( ) ) { tail = classpath . index Of ( sep , head ) ;  String segment = null ; if ( tail < _ NUM ) { segment = classpath . substring ( head ) ; head = classpath . length ( ) ; } else { segment = classpath . substring ( head , tail ) ; head = tail + _ NUM ; } if ( segment . equals ( _ STR ) ) continue ; else if ( segment . ends With ( _ STR ) || segment . ends With ( _ STR ) ) add Merge Path (  Jar Path . create (  Vfs Old . lookup ( segment ) ) ) ; else add Merge Path (  Vfs Old . lookup ( segment ) ) ; } }
@  Singleton public static synchronized void load Directories (  String first Option ) throws  Invalid Config Exception { if ( user Id Directories == null ) { user Id Directories = new  Tree Map <  String ,  String > ( ) ; user Id Directories . put ( _ STR , ( first Option == null ) ? _ STR : first Option ) ;  Properties properties = directories Properties ( ) ; for (  Map .  Entry <  Object ,  Object > entry : properties . entry Set ( ) ) {  String key =  String Utils . trim ( (  String ) entry . get Key ( ) ) ;  String value =  String Utils . trim ( (  String ) entry . get Value ( ) ) ; if ( key != null && value != null ) { user Id Directories . put ( key , value ) ; } else {  String error =  DIRECTORIES_ PROPFILE_ PATH + _ STR ;  LOG . error ( error ) ; throw new  Invalid Config Exception (  Invalid Config Exception .  TYPE .  INVALID_ PROPERTIES_ FILE , error ) ; } } if ( ( user Id Directories . size ( ) - _ NUM ) == _ NUM ) {  String error = _ STR +  DIRECTORIES_ PROPFILE_ PATH + _ STR ;  LOG . error ( error ) ; throw new  Invalid Config Exception (  Invalid Config Exception .  TYPE .  INVALID_ PROPERTIES_ FILE , error ) ; } } }
public static  Individuum null Individuum ( int dim ) { short [ ] gene = new short [ dim ] ;  Arrays . fill ( gene ,  DONT_ CARE ) ; return new  Individuum ( _ NUM , gene ) ; }
public  List <  Class < ? > > find All Classes (  String uri ) throws  IOException ,  Class Not Found Exception {  List <  Class < ? > > classes = new  Array List < > ( ) ;  List <  String > strings = find All Strings ( uri ) ; for (  String class Name : strings ) {  Class < ? > clazz = _class Loader . load Class ( class Name ) ; classes . add ( clazz ) ; } return classes ; }
public void shuffle Inventory ( @  Nonnull  IInventory inv , @  Nonnull  Random random ) { final  List <  Item Stack > list = get Inventory List ( inv ) ;  Collections . shuffle ( list , random ) ; for ( int i = _ NUM ; i < inv . get Size Inventory ( ) ; ++ i ) { inv . set Inventory Slot Contents ( i , list . get ( i ) ) ; } }
@  Override public  String format ( double value , int format Number ) { if ( format Number % _ NUM == _ NUM ) { return format . format ( value ) ; } else { return null ; } }
public void run Asserts (  List <  Step > list , int size ,  Boolean need Assignee ) { assert Equals ( size , list . size ( ) ) ; for ( int i = _ NUM ; i < size ; i ++ ) { run Asserts ( list . get ( i ) , i , need Assignee ) ; } }
public static boolean register Transform ( final  String transform URI ) { final boolean added = transforms . add ( transform URI ) ; return added ; }
public  ANDCondition (  Condition ... conditions ) {  Reject . if Null ( conditions ) ; this . conditions =  Arrays . as List ( conditions ) ; }
private void update Controls ( ) {  Spinner difficulty = (  Spinner ) find View By Id (  R . id . spinner_difficulty Level ) ; difficulty . set Selection (  Game Activity . get Difficulty Index ( ) ) ;  Button resume = (  Button ) find View By Id (  R . id . button_resume Game ) ; resume . set Enabled (  Game Activity . can Resume From Save ( ) ) ;  Check Box never Lose Ball = (  Check Box ) find View By Id (  R . id . checkbox_never Lose Ball ) ; never Lose Ball . set Checked (  Game Activity . get Never Lose Ball ( ) ) ;  Check Box sound Effects Enabled = (  Check Box ) find View By Id (  R . id . checkbox_sound Effects Enabled ) ; sound Effects Enabled . set Checked (  Game Activity . get Sound Effects Enabled ( ) ) ;  Text View high Score = (  Text View ) find View By Id (  R . id . text_high Score ) ; high Score . set Text (  String . value Of ( m High Score ) ) ; }
public static void write (  Output Stream out , int c ) { if ( out == null ) { throw new  Illegal Argument Exception ( _ STR ) ; } try { out . write ( c ) ; } catch (  IOException e ) { throw new  Runtime Exception ( e . get Message ( ) , e ) ; } }
public void message (  Loco Net Message m ) { if ( m . get Num Data Elements ( ) != _ NUM ) { return ; } int b1 = m . get Element ( _ NUM ) & _ NUM ; int b2 = m . get Element ( _ NUM ) & _ NUM ; int b3 = m . get Element ( _ NUM ) & _ NUM ; int b4 = m . get Element ( _ NUM ) & _ NUM ; if ( ( b1 == _ NUM ) && ( ( b2 == _ NUM ) || ( b2 == _ NUM ) || ( b2 == _ NUM ) ) && ( b3 == _ NUM ) ) { id Box . set Selected Index ( b4 + _ NUM ) ; } }
public  Void call ( ) throws  Exception { byte [ ] [ ] keys = new byte [ nops ] [ ] ; byte [ ] [ ] vals = new byte [ nops ] [ ] ; if ( r . next Double ( ) <= insert Rate ) { for ( int i = _ NUM ; i < nops ; i ++ ) { keys [ i ] = next Key ( ) ; vals [ i ] = new byte [ _ NUM ] ; r . next Bytes ( vals [ i ] ) ; } lock . lock ( ) ; try { ndx . submit ( _ NUM , nops , keys , vals ,  Batch Insert Constructor .  RETURN_ NO_ VALUES , null ) ; if ( ground Truth != null ) { ground Truth . submit ( _ NUM , nops , keys , vals ,  Batch Insert Constructor .  RETURN_ NO_ VALUES , null ) ; } } finally { lock . unlock ( ) ; } } else { for ( int i = _ NUM ; i < nops ; i ++ ) { keys [ i ] = next Key ( ) ; } lock . lock ( ) ; try { ndx . submit ( _ NUM , nops , keys , null ,  Batch Remove Constructor .  RETURN_ MUTATION_ COUNT , null ) ; if ( ground Truth != null ) { ground Truth . submit ( _ NUM , nops , keys , null ,  Batch Remove Constructor .  RETURN_ MUTATION_ COUNT , null ) ; } } finally { lock . unlock ( ) ; } } return null ; }
public boolean allow Multiple Additions (  String system Name ) { return _ BOOL ; }
public void write Field ( final  String name , final int value ) throws java . io .  IOException { write Field ( name ,  Integer . to String ( value ) ) ; }
public static double ln Factorial ( int x ) { if ( x < _ NUM ) throw new  Illegal Argument Exception ( _ STR + x ) ; else if ( x > _ NUM ) return ln Gamma ( x + _ NUM ) ; else { int l = factorials Buffer . size ( ) ; for ( int i = l ; i <= x ; i ++ ) { factorials Buffer . add ( log ( i ) + factorials Buffer . get ( i - _ NUM ) ) ; } return factorials Buffer . get ( x ) ; } }
public void sync ( ) throws  IOException { try { latch . await ( ) ; } catch (  Interrupted Exception e ) {  Thread . interrupted ( ) ; throw  IOException Support . create ( e ) ; } fail On Error ( ) ; }
public static void close Silently (  Closeable closeable ) { if ( closeable == null ) { return ; } try { closeable . close ( ) ; } catch (  Runtime Exception rethrown ) { throw rethrown ; } catch (  Exception ignored ) { } }
public synchronized boolean append ( final byte [ ] data ) { if ( data == null ) { if (  Cfg .  DEBUG ) {  Check . log (  TAG + _ STR ) ; } return _ BOOL ; }  File Output Stream fout = null ;  Output Stream out = null ; try { fout = new  File Output Stream ( file , _ BOOL ) ; out = new  Buffered Output Stream ( fout , data . length ) ; out . write ( data ) ; out . flush ( ) ; } catch ( final  Exception ex ) { return _ BOOL ; } finally { if ( fout != null ) { try { fout . close ( ) ; } catch ( final  IOException e ) { if (  Cfg .  EXCEPTION ) {  Check . log ( e ) ; } if (  Cfg .  DEBUG ) {  Check . log (  TAG + _ STR + e . to String ( ) ) ; } } } if ( out != null ) { try { out . close ( ) ; } catch ( final  IOException e ) { if (  Cfg .  EXCEPTION ) {  Check . log ( e ) ; } if (  Cfg .  DEBUG ) {  Check . log (  TAG + _ STR + e . to String ( ) ) ; } } } } return _ BOOL ; }
@  Suppress Warnings ( { _ STR , _ STR } ) private void notify List Listeners ( ) { if ( ! list Listeners . is Empty ( ) ) {  List temp = new  Array List ( sensor Data Objects . values ( ) ) ; temp . add All ( object Storages . values ( ) ) ; for (  List Listener < ? > list Listener : list Listeners ) { list Listener . content Changed ( temp ) ; } } }
public static  Inet Address int To Inet Address ( int host Address ) { if ( host Address == _ NUM ) return null ; byte [ ] address Bytes = { ( byte ) ( _ NUM & host Address ) , ( byte ) ( _ NUM & ( host Address > > _ NUM ) ) , ( byte ) ( _ NUM & ( host Address > > _ NUM ) ) , ( byte ) ( _ NUM & ( host Address > > _ NUM ) ) } ; try { return  Inet Address . get By Address ( address Bytes ) ; } catch (  Unknown Host Exception e ) { throw new  Assertion Error ( ) ; } }
private  AFTPClient action Open ( ) throws  IOException ,  Page Exception { required ( _ STR , server ) ; required ( _ STR , username ) ; required ( _ STR , password ) ;  AFTPClient client = get Client ( ) ; write Cfftp ( client ) ; return client ; }
public void test Plus Math Context Positive ( ) {  String a = _ STR ; int a Scale = _ NUM ; int precision = _ NUM ;  Rounding Mode rm =  Rounding Mode .  FLOOR ;  Math Context mc = new  Math Context ( precision , rm ) ;  String c = _ STR ; int c Scale = _ NUM ;  Big Decimal a Number = new  Big Decimal ( new  Big Integer ( a ) , a Scale ) ;  Big Decimal res = a Number . plus ( mc ) ; assert Equals ( _ STR , c , res . to String ( ) ) ; assert Equals ( _ STR , c Scale , res . scale ( ) ) ; }
public  V put If Absent ( final  K k , final  V v ) { final  Weak Reference <  V > ref = new Weak Ref ( k , v , reference Queue ) ; final  Weak Reference <  V > old Ref = map . put If Absent ( k , ref ) ; final  V old Val = old Ref == null ? null : old Ref . get ( ) ; if ( old Ref != null && old Val == null ) { if ( map . replace ( k , old Ref , ref ) ) { if ( queue . add ( v ) &&  DEBUG ) { log . debug ( _ STR + k + _ STR + v ) ; } did Update ( k , ref , old Ref ) ; return null ; } } if ( old Val == null ) { if ( queue . add ( v ) &&  DEBUG ) { log . debug ( _ STR + k + _ STR + v ) ; } did Update ( k , ref , null ) ; return null ; } return old Val ; }
public void close ( ) { if ( element Layers != null ) { element Layers . clear ( ) ; element Layers = null ; } input Source = null ; cur Listener = null ; }
public void start ( ) { if ( monitor Thread != null ) { if ( ! monitor Thread . is Alive ( ) ) { start Monitor Thread ( ) ; } else {  LOG . error ( _ STR ) ; } } else { start Monitor Thread ( ) ; } }
@  HLEUnimplemented @  HLEFunction ( nid = _ NUM , version = _ NUM ) public int sce Usb Cam Poll Read Video Frame End ( ) { if ( jpeg Buffer == null || jpeg Buffer . is Null ( ) ) { return  Sce Kernel Errors .  ERROR_ USBCAM_ NO_ READ_ ON_ VIDEO_ FRAME ; } if ( current Video Frame Count <= last Video Frame Count ) { if ( log . is Debug Enabled ( ) ) { log . debug (  String . format ( _ STR , current Video Frame Count , last Video Frame Count ) ) ; } return  Sce Kernel Errors .  ERROR_ USBCAM_ NO_ VIDEO_ FRAME_ AVAILABLE ; } return write Current Video Image ( jpeg Buffer , jpeg Buffer Size ) ; }
public void scale ( int factor ) { if ( m_icon != null ) { remove All ( ) ;  Image pic = m_icon . get Image ( ) ; int width = m_icon . get Icon Width ( ) ; int height = m_icon . get Icon Height ( ) ; int reduction = width / factor ; width -= reduction ; height -= reduction ; pic = pic . get Scaled Instance ( width , height ,  Image .  SCALE_ SMOOTH ) ; m_icon = new  Image Icon ( pic ) ; m_visual Label = new  JLabel ( m_icon ) ; add ( m_visual Label ,  Border Layout .  CENTER ) ;  Dimension d = m_visual Label . get Preferred Size ( ) ;  Dimension d2 = new  Dimension ( ( int ) d . get Width ( ) + _ NUM , ( int ) d . get Height ( ) + _ NUM ) ; set Minimum Size ( d2 ) ; set Preferred Size ( d2 ) ; set Maximum Size ( d2 ) ; } }
private void read Object (  Object Input Stream in ) throws  IOException ,  Class Not Found Exception { in . default Read Object ( ) ; try { init From Name ( get Name ( ) ) ; } catch (  Runtime Exception e ) { if ( e instanceof  Null Pointer Exception || e instanceof  Illegal Argument Exception ) {  Invalid Object Exception ee = new  Invalid Object Exception ( e . get Message ( ) ) ; ee . init Cause ( e ) ; throw ee ; } throw e ; } }
public  String to Lower Camel ( ) { return to Camel (  Case Format .  LOWER_ CAMEL ) ; }
protected  List <  Block Object > sort Full Copy Source List (  List <  Block Object > fc Source Objects ) {  List <  Block Object > sorted Source Objects = new  Array List <  Block Object > ( ) ;  Map <  String ,  Block Object > fc Sourc Objects Map = new  Hash Map <  String ,  Block Object > ( ) ; for (  Block Object fc Source Object : fc Source Objects ) { fc Sourc Objects Map . put ( fc Source Object . get Label ( ) , fc Source Object ) ; }  List <  String > fc Source Labels = new  Array List <  String > ( fc Sourc Objects Map . key Set ( ) ) ;  Collections . sort ( fc Source Labels ) ; for (  String fc Source Label : fc Source Labels ) { sorted Source Objects . add ( fc Sourc Objects Map . get ( fc Source Label ) ) ; } return sorted Source Objects ; }
public  Movie Set Add Action ( boolean with Title ) { if ( with Title ) { put Value (  NAME ,  BUNDLE . get String ( _ STR ) ) ; } put Value (  LARGE_ ICON_ KEY ,  Icon Manager .  LIST_ ADD ) ; put Value (  SMALL_ ICON ,  Icon Manager .  LIST_ ADD ) ; put Value (  SHORT_ DESCRIPTION ,  BUNDLE . get String ( _ STR ) ) ; }
protected void create Registry ( int port ) { if ( rmi Registry == null ) { try { if ( logger . is Debug Enabled ( ) ) { logger . debug ( _ STR + port ) ; } rmi Registry =  Locate Registry . create Registry ( port ) ; } catch (  Throwable e ) { throw new  Server Runtime Exception ( _ STR + port , e ) ; } } }
public void poll ( final  Udp Socket Statistics Handler handler ) { this . statistics Handler = handler ; try { file Loader . load ( ) ; final  Byte Buffer buffer = file Loader . get Buffer ( ) ; line Parser . reset ( ) ; line Parser . handle Token ( buffer , buffer . position ( ) , buffer . limit ( ) ) ; } finally { this . statistics Handler = null ; } monitored Sockets . purge Entries Older Than ( update Count ) ; update Count ++ ; }
void fix White Space ( ) { final int index = m Output Builder . length ( ) - _ NUM ; if ( index >= _ NUM ) { final char last Character = m Output Builder . char At ( index ) ; if ( !  Character . is Whitespace ( last Character ) ) { m Output Builder . append ( _ STR ) ; } } }
public void handle Tbl Request Handler List Href Dup Action Request (  Request Invocation Event event ) throws  Model Control Exception { try {  Map values = get Values ( ) ; on Before Save Profile ( values ) ; set Page Session Attribute (  PROPERTY_ ATTRIBUTE , (  Hash Map ) values ) ;  SCSOAPBinding Request Handler List Dup View Bean vb = (  SCSOAPBinding Request Handler List Dup View Bean ) get View Bean (  SCSOAPBinding Request Handler List Dup View Bean . class ) ; unlock Page Trail ( ) ; pass Pg Session Map ( vb ) ; int idx =  Integer . parse Int ( (  String ) get Display Field Value (  TBL_ REQUEST_ HANDLER_ LIST_ HREF_ DUP_ ACTION ) ) ; vb . set Dup Index ( idx ) ; vb . forward To ( get Request Context ( ) ) ; } catch (  AMConsole Exception e ) { set Inline Alert Message (  CCAlert .  TYPE_ ERROR , _ STR , e . get Message ( ) ) ; } }
public boolean expired ( long expire ) { long mod = time . get Time ( ) ; long now =  System . current Time Millis ( ) ; long diff = now - mod ; if ( diff > expire && get Source ( ) !=  NETWORK ) { return _ BOOL ; } return _ BOOL ; }
private void handle Done Query ( final  UUID query Id , final  Future <  Void > done Query Future ) { try { done Query Future . get ( ) ; throw new  Interrupted Exception ( ) ; } catch (  Interrupted Exception e ) { throw new  Runtime Exception ( e ) ; } catch (  Execution Exception e ) { throw new  Runtime Exception ( e ) ; } }
synchronized public static  List <  String > former Identities ( ) { if ( instance == null ) { instance = new  Node Identity ( ) ; log . info ( _ STR , instance . get Identity ( ) ) ; } return instance . get Former Identities ( ) ; }
public final double do Operation ( ) { final int dim = parameter . get Dimension ( ) ; double sum = _ NUM ; if ( uses Prior On Sum ) { for ( int i = _ NUM ; i < dim ; i ++ ) { sum +=  Math . abs ( parameter . get Parameter Value ( i ) ) ; } } final int pos =  Math Utils . next Int ( dim ) ; final int value = ( int ) parameter . get Parameter Value ( pos ) ; double logq = _ NUM ; if ( value == _ NUM ) { logq = bit Flip Helper . flip Zero ( pos , dim , sum ) ; } else if ( value == _ NUM ) { logq = bit Flip Helper . flip One ( pos , dim , sum ) ; } else if ( value == - _ NUM ) { logq = bit Flip Helper . flip Neg One ( pos , dim , sum ) ; } else { throw new  Runtime Exception ( _ STR ) ; } if ( ! uses Prior On Sum ) { logq = _ NUM ; } return logq ; }
@  Override public void chart Progress (  Chart Progress Event event ) { }
@  Override public  Japanese Date date Epoch Day ( long epoch Day ) { return new  Japanese Date (  Local Date . of Epoch Day ( epoch Day ) ) ; }
public long convert Transverse Mercator To Geodetic ( double  Easting , double  Northing ) { double c ; double de ; double dlam ; double eta ; double eta2 ; double eta3 ; double eta4 ; double ftphi ; int i ; double sn ; double sr ; double t ; double tan2 ; double tan4 ; double t10 ; double t11 ; double t12 ; double t13 ; double t14 ; double t15 ; double t16 ; double t17 ; double tmd ; double tmdo ; long  Error_ Code =  TRANMERC_ NO_ ERROR ; if ( (  Easting < (  Tran Merc_ False_ Easting -  Tran Merc_ Delta_ Easting ) ) || (  Easting > (  Tran Merc_ False_ Easting +  Tran Merc_ Delta_ Easting ) ) ) {  Error_ Code |=  TRANMERC_ EASTING_ ERROR ; } if ( (  Northing < (  Tran Merc_ False_ Northing -  Tran Merc_ Delta_ Northing ) ) || (  Northing > (  Tran Merc_ False_ Northing +  Tran Merc_ Delta_ Northing ) ) ) {  Error_ Code |=  TRANMERC_ NORTHING_ ERROR ; } if (  Error_ Code ==  TRANMERC_ NO_ ERROR ) { tmdo =  Tran Merc_ap *  Tran Merc_ Origin_ Lat -  Tran Merc_bp *  Math . sin ( _ NUM *  Tran Merc_ Origin_ Lat ) +  Tran Merc_cp *  Math . sin ( _ NUM *  Tran Merc_ Origin_ Lat ) -  Tran Merc_dp *  Math . sin ( _ NUM *  Tran Merc_ Origin_ Lat ) +  Tran Merc_ep *  Math . sin ( _ NUM *  Tran Merc_ Origin_ Lat ) ; tmd = tmdo + (  Northing -  Tran Merc_ False_ Northing ) /  Tran Merc_ Scale_ Factor ; sr =  Tran Merc_a * ( _ NUM -  Tran Merc_es ) /  Math . pow (  Math . sqrt ( _ NUM -  Tran Merc_es *  Math . pow (  Math . sin ( _ NUM ) , _ NUM ) ) , _ NUM ) ; ftphi = tmd / sr ; for ( i = _ NUM ; i < _ NUM ; i ++ ) { t10 =  Tran Merc_ap * ftphi -  Tran Merc_bp *  Math . sin ( _ NUM * ftphi ) +  Tran Merc_cp *  Math . sin ( _ NUM * ftphi ) -  Tran Merc_dp *  Math . sin ( _ NUM * ftphi ) +  Tran Merc_ep *  Math . sin ( _ NUM * ftphi ) ; sr =  Tran Merc_a * ( _ NUM -  Tran Merc_es ) /  Math . pow (  Math . sqrt ( _ NUM -  Tran Merc_es *  Math . pow (  Math . sin ( ftphi ) , _ NUM ) ) , _ NUM ) ; ftphi = ftphi + ( tmd - t10 ) / sr ; } sr =  Tran Merc_a * ( _ NUM -  Tran Merc_es ) /  Math . pow (  Math . sqrt ( _ NUM -  Tran Merc_es *  Math . pow (  Math . sin ( ftphi ) , _ NUM ) ) , _ NUM ) ; sn =  Tran Merc_a /  Math . sqrt ( _ NUM -  Tran Merc_es *  Math . pow (  Math . sin ( ftphi ) , _ NUM ) ) ; c =  Math . cos ( ftphi ) ; t =  Math . tan ( ftphi ) ; tan2 = t * t ; tan4 = tan2 * tan2 ; eta =  Tran Merc_ebs *  Math . pow ( c , _ NUM ) ; eta2 = eta * eta ; eta3 = eta2 * eta ; eta4 = eta3 * eta ; de =  Easting -  Tran Merc_ False_ Easting ; if (  Math . abs ( de ) < _ NUM ) de = _ NUM ; t10 = t / ( _ NUM * sr * sn *  Math . pow (  Tran Merc_ Scale_ Factor , _ NUM ) ) ; t11 = t * ( _ NUM + _ NUM * tan2 + eta - _ NUM *  Math . pow ( eta , _ NUM ) - _ NUM * tan2 * eta ) / ( _ NUM * sr *  Math . pow ( sn , _ NUM ) *  Math . pow (  Tran Merc_ Scale_ Factor , _ NUM ) ) ; t12 = t * ( _ NUM + _ NUM * tan2 + _ NUM * eta + _ NUM * tan4 - _ NUM * tan2 * eta - _ NUM * eta2 + _ NUM * eta3 - _ NUM * tan2 * eta2 - _ NUM * tan4 * eta + _ NUM * eta4 + _ NUM * tan4 * eta2 + _ NUM * tan2 * eta3 - _ NUM * tan2 * eta4 ) / ( _ NUM * sr *  Math . pow ( sn , _ NUM ) *  Math . pow (  Tran Merc_ Scale_ Factor , _ NUM ) ) ; t13 = t * ( _ NUM + _ NUM * tan2 + _ NUM * tan4 + _ NUM *  Math . pow ( t , _ NUM ) ) / ( _ NUM * sr *  Math . pow ( sn , _ NUM ) *  Math . pow (  Tran Merc_ Scale_ Factor , _ NUM ) ) ;  Latitude = ftphi -  Math . pow ( de , _ NUM ) * t10 +  Math . pow ( de , _ NUM ) * t11 -  Math . pow ( de , _ NUM ) * t12 +  Math . pow ( de , _ NUM ) * t13 ; t14 = _ NUM / ( sn * c *  Tran Merc_ Scale_ Factor ) ; t15 = ( _ NUM + _ NUM * tan2 + eta ) / ( _ NUM *  Math . pow ( sn , _ NUM ) * c *  Math . pow (  Tran Merc_ Scale_ Factor , _ NUM ) ) ; t16 = ( _ NUM + _ NUM * eta + _ NUM * tan2 - _ NUM * eta2 + _ NUM * tan2 * eta + _ NUM * tan4 - _ NUM * eta3 + _ NUM * tan2 * eta2 + _ NUM * tan2 * eta3 ) / ( _ NUM *  Math . pow ( sn , _ NUM ) * c *  Math . pow (  Tran Merc_ Scale_ Factor , _ NUM ) ) ; t17 = ( _ NUM + _ NUM * tan2 + _ NUM * tan4 + _ NUM *  Math . pow ( t , _ NUM ) ) / ( _ NUM *  Math . pow ( sn , _ NUM ) * c *  Math . pow (  Tran Merc_ Scale_ Factor , _ NUM ) ) ; dlam = de * t14 -  Math . pow ( de , _ NUM ) * t15 +  Math . pow ( de , _ NUM ) * t16 -  Math . pow ( de , _ NUM ) * t17 ;  Longitude =  Tran Merc_ Origin_ Long + dlam ; if (  Math . abs (  Latitude ) > ( _ NUM *  PI / _ NUM ) )  Error_ Code |=  TRANMERC_ NORTHING_ ERROR ; if ( (  Longitude ) > (  PI ) ) {  Longitude -= ( _ NUM *  PI ) ; if (  Math . abs (  Longitude ) >  PI )  Error_ Code |=  TRANMERC_ EASTING_ ERROR ; } if (  Math . abs ( dlam ) > ( _ NUM *  PI / _ NUM ) *  Math . cos (  Latitude ) ) {  Error_ Code |=  TRANMERC_ LON_ WARNING ; } if (  Latitude > _ NUM )  Error_ Code |=  TRANMERC_ LON_ WARNING ; } return (  Error_ Code ) ; }
private void check Empty ( ) { for ( int i = _ NUM ; i < grid Count ( ) ; i ++ ) {  Ignite Cache <  Integer ,  String > cache = jcache ( i ) ; assert Equals ( _ NUM , cache . local Size ( ) ) ; assert Equals ( _ NUM , cache . size ( ) ) ; for (  Cache Peek Mode peek Mode :  Cache Peek Mode . values ( ) ) { assert Equals ( _ NUM , cache . local Size ( peek Mode ) ) ; assert Equals ( _ NUM , cache . size ( peek Mode ) ) ; } } check Primary Size ( _ NUM ) ; }
Node <  K ,  V > find ( int h ,  Object k ) {  Node <  K ,  V > e = this ; if ( k != null ) { do {  K ek ; if ( e . hash == h && ( ( ek = e . key ) == k || ek != null && my Hashing Strategy . equals ( (  K ) k , ek ) ) ) { return e ; } } while ( ( e = e . next ) != null ) ; } return null ; }
@  Loop Processor Annotations ( loop Processor Annotations = { @  Loop Processor Annotation ( process Path = {  IModeling Element Definitions .  CLASSES_ PROCESSOR ,  IModeling Element Definitions .  OPERATIONS_ PROCESSOR } ) , @  Loop Processor Annotation ( process Path = {  IModeling Element Definitions .  INTERFACES_ PROCESSOR ,  IModeling Element Definitions .  OPERATIONS_ PROCESSOR } ) } , aspect =  Loop Aspect Constants .  AFTER ) public static void operations Processor ( @  Generation Registry  Generation Policy Registry generation Value Getter , @  Generation Base Element  Object element , @  Generation Loop Element  Object model Package , @  Generation Loop Element ( id = {  IModeling Element Definitions .  CLASSES_ PROCESSOR ,  IModeling Element Definitions .  INTERFACES_ PROCESSOR } )  Object parent ) {  List <  Object > user Added Depend Types = generation Value Getter . get Values (  DEPEND_ TYPES_ TRACKER , parent ) ;  List <  Object > parameters Argument = generation Value Getter . get Values (  IModeling Decisions .  OPERATION_ PARAMETER_ ARGUMENT , element , parent ) ; for (  Object item : parameters Argument ) { if ( item instanceof  Simple Entry == _ BOOL ) { continue ; }  Simple Entry < ? , ? > simple Entry = (  Simple Entry < ? , ? > ) item ;  Object type = simple Entry . get Key ( ) ; if ( ! user Added Depend Types . contains ( type ) ) {  List <  Object > types = generation Value Getter . get Values (  IModeling Constants .  TYPES_ TRACKER , model Package , type ) ; if ( types . is Empty ( ) ) { continue ; } add Depend ( generation Value Getter , parent , type ) ; } } }
public static void add Language (  Language language ) { if ( language == null ) return ;  Array List <  Language > list = new  Array List <  Language > (  Arrays . as List ( s_languages ) ) ; list . add ( language ) ; s_languages = new  Language [ list . size ( ) ] ; list . to Array ( s_languages ) ; }
protected void do Add User (  User user ) throws  Users Repository Exception {  Connection conn = null ;  Prepared Statement add User Statement = null ; try { conn = open Connection ( ) ; add User Statement = conn . prepare Statement ( m_insert User Sql ) ; set User For Insert Statement ( user , add User Statement ) ; add User Statement . execute ( ) ; } catch (  SQLException sql Exc ) { sql Exc . print Stack Trace ( ) ; throw new  Users Repository Exception ( _ STR , sql Exc ) ; } finally { the JDBCUtil . close JDBCStatement ( add User Statement ) ; the JDBCUtil . close JDBCConnection ( conn ) ; } }
void block Mix128 ( long k1 , long k2 ) { h1 ^= mix K1 ( k1 ) ; h1 =  Long . rotate Left ( h1 , _ NUM ) ; h1 += h2 ; h1 = ( h1 * _ NUM ) + _ NUM ; h2 ^= mix K2 ( k2 ) ; h2 =  Long . rotate Left ( h2 , _ NUM ) ; h2 += h1 ; h2 = ( h2 * _ NUM ) + _ NUM ; }
private void register Host (  Sim Event ev ) {  Network Host hs = (  Network Host ) ev . get Data ( ) ; hostlist . put ( hs . get Id ( ) , hs ) ; }
public  Format (  String p Format String ) {  String format Vars [ ] = p Format String . split ( _ STR ) ; m Id =  Integer . parse Int ( format Vars [ _ NUM ] ) ; }
void create Jar (  File Output Stream out Stream ,  Map <  String , byte [ ] > all ) throws  IOException {  Jar Output Stream jar = new  Jar Output Stream ( out Stream ) ; for (  Entry <  String , byte [ ] > entry : all . entry Set ( ) ) {  String name = entry . get Key ( ) ;  Jar Entry jar_entry = new  Jar Entry ( name ) ; jar . put Next Entry ( jar_entry ) ; jar . write ( entry . get Value ( ) ) ; jar . close Entry ( ) ; } jar . flush ( ) ; jar . close ( ) ; }
public void append Cell ( int value ) { append Cell (  String . value Of ( value ) ) ; }
public void expect Server Proxy Failed ( ) { expected Api Calls . add ( new  Api Call (  SERVER_ PROXY_ FAILED ) ) ; }
public  Object remove ( final  Object key ) { return parameters . remove ( key ) ; }
@  Override public void recalculate Attribute Statistics (  Attribute attribute ) {  List <  Attribute > all Attributes = new  Array List <  Attribute > ( ) ; all Attributes . add ( attribute ) ; recalculate Attribute Statistics ( all Attributes ) ; }
public boolean is Empty ( ) { return children . is Empty ( ) ; }
public void insert Column ( int column Index ,  Column Spec column Spec ) { if ( column Index < _ NUM || column Index > get Column Count ( ) ) { throw new  Index Out Of Bounds Exception ( _ STR + column Index + _ STR + get Column Count ( ) + _ STR ) ; } col Specs . add ( column Index - _ NUM , column Spec ) ; shift Components Horizontally ( column Index , _ BOOL ) ; adjust Group Indices ( col Group Indices , column Index , _ BOOL ) ; }
private int calc Rhs Size (  Production production ) { int result = production . get RHSSize Without Epsilon ( ) ; if ( production . get LHS ( ) instanceof  Auxiliary LHS4 Semantic Shift Action ) { final  Auxiliary LHS4 Semantic Shift Action aux Action = (  Auxiliary LHS4 Semantic Shift Action ) production . get LHS ( ) ; result += aux Action . num Preceding Symbols Not Epsilon ; } return result ; }
private  Bsh Method load Scripted Command (  Input Stream in ,  String name ,  Class [ ] arg Types ,  String resource Path ,  Interpreter interpreter ) throws  Util Eval Error { try { interpreter . eval ( new  Input Stream Reader ( in ) , this , resource Path ) ; } catch (  Eval Error e ) {  Interpreter . debug ( e . to String ( ) ) ; throw new  Util Eval Error ( _ STR + e . get Message ( ) ) ; }  Bsh Method meth = get Method ( name , arg Types ) ; return meth ; }
public static  Object invoke Compiled Command (  Class command Class ,  Object [ ] args ,  Interpreter interpreter ,  Call Stack callstack ) throws  Util Eval Error {  Object [ ] invoke Args = new  Object [ args . length + _ NUM ] ; invoke Args [ _ NUM ] = interpreter ; invoke Args [ _ NUM ] = callstack ;  System . arraycopy ( args , _ NUM , invoke Args , _ NUM , args . length ) ;  Bsh Class Manager bcm = interpreter . get Class Manager ( ) ; try { return  Reflect . invoke Static Method ( bcm , command Class , _ STR , invoke Args ) ; } catch (  Invocation Target Exception e ) { throw new  Util Eval Error ( _ STR + e . get Target Exception ( ) ) ; } catch (  Reflect Error e ) { throw new  Util Eval Error ( _ STR + e ) ; } }
private static void compute Probabilities Multinomial Logistic ( double [ ] responses ) { double [ ] r = responses . clone ( ) ; for ( int j = _ NUM ; j < r . length ; j ++ ) { double sum = _ NUM ; boolean overflow = _ BOOL ; for ( int k = _ NUM ; k < r . length ; k ++ ) { if ( r [ k ] - r [ j ] > _ NUM ) { overflow = _ BOOL ; break ; } sum +=  Math . exp ( r [ k ] - r [ j ] ) ; } if ( overflow ) { responses [ j ] = _ NUM ; } else { responses [ j ] = _ NUM / sum ; } } }
public int add Client External (  SSOToken token ,  Map props ) throws  AMClient Cap Exception { synchronized ( external Client Data ) { ext Cap Instance . add Client ( token , props ) ;  String ct = get Client Type ( props ) ;  Map e Map = merge With Parent ( props ) ; external Client Data . put ( ct , e Map ) ; add To Indexes ( ct , e Map ) ; } return _ NUM ; }
public static void delete (  File resource To Delete ) throws  IOException { if ( resource To Delete . exists ( ) ) { delete ( resource To Delete . to Path ( ) ) ; } }
private void add Export Remove Volume Steps (  Workflow workflow ,  Protection System rp System ,  URI export Group ID ,  List <  URI > bo IDs ) throws  Internal Exception {  Export Group export Group = _db Client . query Object (  Export Group . class , export Group ID ) ;  String export Step = workflow . create Step Id ( ) ; init Task Status ( export Group , export Step ,  Operation .  Status . pending , _ STR ) ;  Map <  URI ,  List <  URI > > device To Block Objects = new  Hash Map <  URI ,  List <  URI > > ( ) ; for (  URI snapshot ID : bo IDs ) {  Block Snapshot snapshot = _db Client . query Object (  Block Snapshot . class , snapshot ID ) ;  List <  Block Object > objects To Remove = get Export Objects For Bookmark ( snapshot ) ; for (  Block Object block Object : objects To Remove ) {  List <  URI > block Objects = device To Block Objects . get ( block Object . get Storage Controller ( ) ) ; if ( block Objects == null ) { block Objects = new  Array List <  URI > ( ) ; device To Block Objects . put ( block Object . get Storage Controller ( ) , block Objects ) ; } block Objects . add ( block Object . get Id ( ) ) ; } } for (  Map .  Entry <  URI ,  List <  URI > > device Entry : device To Block Objects . entry Set ( ) ) { _log . info (  String . format ( _ STR , export Group . get Id ( ) , device Entry . get Key ( ) , device Entry . get Value ( ) ) ) ; _export Wf Utils . generate Export Group Remove Volumes ( workflow ,  STEP_ EXPORT_ REMOVE_ SNAPSHOT ,  STEP_ EXPORT_ GROUP_ DISABLE , device Entry . get Key ( ) , export Group ID , device Entry . get Value ( ) ) ; } _log . info (  String . format ( _ STR , export Group . get Id ( ) ) ) ; }
public static void remove (  String dbg Token ) { dbg Table . remove ( dbg Token ) ; }
protected boolean is Recompilation Needed ( int [ ] loaded Checksums ) { this . checksums [ _ NUM ] = calculate Checksum ( ) ; if ( this . checksums [ _ NUM ] != loaded Checksums [ _ NUM ] ) { if (  Trace . swc Checksum ) {  Trace . trace ( _ STR ) ; } return _ BOOL ; } if ( ! is Swc Checksum Enabled ) { if (  Trace . swc Checksum ) {  Trace . trace ( _ STR ) ; } return _ BOOL ; }  Map <  QName ,  Long > signature Checksums = swc Def Signature Checksums ; if ( signature Checksums == null ) { if (  Trace . swc Checksum ) {  Trace . trace ( _ STR ) ; } } else { for (  Map .  Entry <  QName ,  Long > entry : signature Checksums . entry Set ( ) ) {  QName q Name = (  QName ) entry . get Key ( ) ;  Long data Signature Checksum = (  Long ) entry . get Value ( ) ;  Long swc Signature Checksum = swc Context . get Checksum ( q Name ) ; if ( swc Signature Checksum == null && q Name != null ) {  Source source = swc Context . get Source ( q Name . get Namespace ( ) , q Name . get Local Part ( ) ) ; if ( source != null ) { swc Signature Checksum = new  Long ( source . get Last Modified ( ) ) ; } } if (  Trace . swc Checksum ) { if ( data Signature Checksum == null ) { throw new  Illegal State Exception ( _ STR ) ; } } if ( data Signature Checksum != null && swc Signature Checksum == null ) { if (  Trace . swc Checksum ) {  Trace . trace ( _ STR ) ;  Trace . trace ( _ STR + entry . get Key ( ) ) ;  Trace . trace ( _ STR + data Signature Checksum ) ;  Trace . trace ( _ STR + swc Signature Checksum ) ; } return _ BOOL ; } if ( data Signature Checksum != null ) { if ( data Signature Checksum . long Value ( ) != swc Signature Checksum . long Value ( ) ) { if (  Trace . swc Checksum ) {  Trace . trace ( _ STR ) ;  Trace . trace ( _ STR + entry . get Key ( ) ) ;  Trace . trace ( _ STR + data Signature Checksum ) ;  Trace . trace ( _ STR + swc Signature Checksum ) ; } return _ BOOL ; } } else { return _ BOOL ; } } } boolean result = ! are Swc File Checksums Equal ( ) ; if (  Trace . swc Checksum ) {  Trace . trace ( _ STR + ( result ? _ STR : _ STR ) ) ; } return result ; }
private void adjust Min Pref For Spanning Comps (  Dim Constraint [ ] specs ,  Float [ ] def Push ,  Flow Size Spec fss ,  Array List <  Linked Dim Group > [ ] groups Lists ) { for ( int r = groups Lists . length - _ NUM ; r >= _ NUM ; r -- ) {  Array List <  Linked Dim Group > groups = groups Lists [ r ] ; for (  Linked Dim Group group : groups ) { if ( group . span == _ NUM ) { continue ; } int [ ] sizes = group . get Min Pref Max ( ) ; for ( int s =  Layout Util .  MIN ; s <=  Layout Util .  PREF ; s ++ ) { int c Size = sizes [ s ] ; if ( c Size ==  Layout Util .  NOT_ SET ) { continue ; } int row Size = _ NUM ; int s Ix = ( r << _ NUM ) + _ NUM ; int len =  Math . min ( ( group . span << _ NUM ) , fss . sizes . length - s Ix ) - _ NUM ; for ( int j = s Ix ; j < s Ix + len ; j ++ ) { int sz = fss . sizes [ j ] [ s ] ; if ( sz !=  Layout Util .  NOT_ SET ) { row Size += sz ; } } if ( row Size < c Size && len > _ NUM ) { for ( int eagerness = _ NUM , new Row Size = _ NUM ; eagerness < _ NUM && new Row Size < c Size ; eagerness ++ ) { new Row Size = fss . expand Sizes ( specs , def Push , c Size , s Ix , len , s , eagerness ) ; } } } } } }
public static  String dump As Hex ( byte [ ] byte Buffer , int length ) {  String Builder output Builder = new  String Builder ( length * _ NUM ) ; int p = _ NUM ; int rows = length / _ NUM ; for ( int i = _ NUM ; ( i < rows ) && ( p < length ) ; i ++ ) { int ptemp = p ; for ( int j = _ NUM ; j < _ NUM ; j ++ ) {  String hex Val =  Integer . to Hex String ( byte Buffer [ ptemp ] & _ NUM ) ; if ( hex Val . length ( ) == _ NUM ) { hex Val = _ STR + hex Val ; } output Builder . append ( hex Val + _ STR ) ; ptemp ++ ; } output Builder . append ( _ STR ) ; for ( int j = _ NUM ; j < _ NUM ; j ++ ) { int b = _ NUM & byte Buffer [ p ] ; if ( b > _ NUM && b < _ NUM ) { output Builder . append ( ( char ) b + _ STR ) ; } else { output Builder . append ( _ STR ) ; } p ++ ; } output Builder . append ( _ STR ) ; } int n = _ NUM ; for ( int i = p ; i < length ; i ++ ) {  String hex Val =  Integer . to Hex String ( byte Buffer [ i ] & _ NUM ) ; if ( hex Val . length ( ) == _ NUM ) { hex Val = _ STR + hex Val ; } output Builder . append ( hex Val + _ STR ) ; n ++ ; } for ( int i = n ; i < _ NUM ; i ++ ) { output Builder . append ( _ STR ) ; } output Builder . append ( _ STR ) ; for ( int i = p ; i < length ; i ++ ) { int b = _ NUM & byte Buffer [ i ] ; if ( b > _ NUM && b < _ NUM ) { output Builder . append ( ( char ) b + _ STR ) ; } else { output Builder . append ( _ STR ) ; } } output Builder . append ( _ STR ) ; return output Builder . to String ( ) ; }
public void parse File (  Chat Event Parse Listener listener ) { synchronized ( this ) { @  Suppress Warnings ( _ STR ) long start Time =  System . current Time Millis ( ) ;  Buffered Reader reader = null ; try { reader = new  Buffered Reader ( new  File Reader ( path To File ) ) ;  String current Line = reader . read Line ( ) ; while ( current Line != null ) { try {  Chat Event event =  Chat Event Utils . deserialize Chat Event ( current Line ) ; if ( ! listener . on New Event Parsed ( event ) ) { break ; } } catch (  Throwable t ) {  LOG . warn ( _ STR + current Line + _ STR , t ) ; } current Line = reader . read Line ( ) ; } listener . on Parse Completed ( ) ; } catch (  IOException ioe ) { throw new  Runtime Exception ( ioe ) ; } finally { if ( reader != null ) { try { reader . close ( ) ; } catch (  Throwable t ) { } } } } }
private  Coder Result escape Sequence Other ( short new Byte ) { if ( new Byte >= _ NUM && new Byte <= _ NUM ) { state =  ESCAPE_ SEQUENCE_ OTHER ; version Sequence Allowed = _ BOOL ; queue . write ( new Byte ) ; } else if ( new Byte >= _ NUM && new Byte <= _ NUM ) { state =  NORMAL_ BYTES ; version Sequence Allowed = _ BOOL ; queue . reset ( ) ; } else { return malformed Input (  ERR_ ESCBYTE ) ; } return  Coder Result .  UNDERFLOW ; }
@  Nullable public static  Network Parameters from ID (  String id ) { if ( id . equals (  ID_ MAINNET ) ) { return  Main Net Params . get ( ) ; } else if ( id . equals (  ID_ TESTNET ) ) { return  Test Net3 Params . get ( ) ; } else if ( id . equals (  ID_ UNITTESTNET ) ) { return  Unit Test Params . get ( ) ; } else if ( id . equals (  ID_ REGTEST ) ) { return  Reg Test Params . get ( ) ; } else if ( id . equals (  ID_ ALPHANET ) ) { return  Alpha Net Params . get ( ) ; } else { return null ; } }
public void add Certificates And CRLs (  Cert Store cert Store ) throws  Cert Store Exception ,  CMSException { certs . add All (  CMSUtils . get Certificates From Store ( cert Store ) ) ; crls . add All (  CMSUtils . get CRLs From Store ( cert Store ) ) ; }
protected abstract void store Body (  Data Output Stream dos ) throws  IOException ;
private double find Angle (  Point origin Point ,  Point target Point ) { int x1 = origin Point . x ; int y1 = origin Point . y ; int x2 = target Point . x ; int y2 = target Point . y ; double angle = _ NUM ; double offset = _ NUM ; double side A = x2 - x1 ; double side B = _ NUM ; if ( y1 >= y2 ) { side B = y1 - y2 ; offset =  Math . to Radians ( - _ NUM ) ; } else { side B = - ( y2 - y1 ) ; offset =  Math . to Radians ( _ NUM ) ; } if ( side B == _ NUM ) { return angle ; } angle =  Math . atan ( side A / side B ) ; return angle + offset ; }
void clear Resource Index (  String resource Type Name ) {  Set resource Types = new  Hash Set ( ) ; resource Types . add All ( resource Indices . key Set ( ) ) ;  Iterator iter = resource Types . iterator ( ) ; while ( iter . has Next ( ) ) {  String resource Type = (  String ) iter . next ( ) ; if ( resource Type . equals Ignore Case ( resource Type Name ) ) { resource Indices . remove ( resource Type ) ; break ; } } }
@  Override public byte [ ] bitcoin Serialize ( ) { if ( header Bytes Valid && transaction Bytes Valid ) {  Preconditions . check Not Null ( payload , _ STR ) ; if ( length == payload . length ) { return payload ; } else { byte [ ] buf = new byte [ length ] ;  System . arraycopy ( payload , offset , buf , _ NUM , length ) ; return buf ; } }  Byte Array Output Stream stream = new  Unsafe Byte Array Output Stream ( length ==  UNKNOWN_ LENGTH ?  HEADER_ SIZE + guess Transactions Length ( ) : length ) ; try { write Header ( stream ) ; write Transactions ( stream ) ; } catch (  IOException e ) { } return stream . to Byte Array ( ) ; }
@  Override public  List <  Period > generate Rolling Periods (  Date Time Unit date Time Unit ) {  Calendar calendar = get Calendar ( ) ;  List <  Period > periods =  Lists . new Array List ( ) ; date Time Unit = calendar . minus Days ( date Time Unit , calendar . weekday ( date Time Unit ) - _ NUM ) ; date Time Unit = calendar . minus Days ( date Time Unit , _ NUM ) ; for ( int i = _ NUM ; i < _ NUM ; i ++ ) { periods . add ( create Period ( date Time Unit , calendar ) ) ; date Time Unit = calendar . plus Weeks ( date Time Unit , _ NUM ) ; } return periods ; }
@  Override public  Set <  String > vertex Match Pattern Labels ( ) { return  Collections . empty Set ( ) ; }
public boolean reset Unread Counts ( int a Section ) { boolean ret Code = _ BOOL ;  Array List <  Room Summary > summaries List = m Summary List By Group Position . get ( a Section ) ; if ( null != summaries List ) { for ( int summary Idx = _ NUM ; summary Idx < summaries List . size ( ) ; summary Idx ++ ) { ret Code |= reset Unread Count ( a Section , summary Idx ) ; } } else {  Log . w (  DBG_ CLASS_ NAME , _ STR + a Section + _ STR ) ; } return ret Code ; }
public static void add Category (  Lexicon Category category ) { categories . add ( category ) ; }
private static int  Call Nonvirtual Object Method V (  JNIEnvironment env , int obj JREF , int class JREF , int method ID ,  Address arg Address ) throws  Exception { if ( trace JNI )  VM . sys Write ( _ STR ) ;  Runtime Entrypoints . check JNICount Down To GC ( ) ; try {  Object obj = env . get JNIRef ( obj JREF ) ;  Object return Obj =  JNIHelpers . invoke With Var Arg ( obj , method ID , arg Address , null , _ BOOL ) ; return env . push JNIRef ( return Obj ) ; } catch (  Throwable unexpected ) { if ( trace JNI ) unexpected . print Stack Trace (  System . err ) ; env . record Exception ( unexpected ) ; return _ NUM ; } }
private  Tuple <  Message ,  Connection > try Other Messages ( ) {  List <  Tuple <  Message ,  Connection > > messages = new  Array List <  Tuple <  Message ,  Connection > > ( ) ;  Collection <  Message > msg Collection = get Message Collection ( ) ; for (  Connection con : get Connections ( ) ) {  DTNHost other = con . get Other Node ( get Host ( ) ) ;  Prophet V2 Router oth Router = (  Prophet V2 Router ) other . get Router ( ) ; if ( oth Router . is Transferring ( ) ) { continue ; } for (  Message m : msg Collection ) { if ( oth Router . has Message ( m . get Id ( ) ) ) { continue ; } if ( ( oth Router . get Pred For ( m . get To ( ) ) >= get Pred For ( m . get To ( ) ) ) ) { messages . add ( new  Tuple <  Message ,  Connection > ( m , con ) ) ; } } } if ( messages . size ( ) == _ NUM ) { return null ; }  Collections . sort ( messages , new  Tuple Comparator ( ) ) ; return try Messages For Connected ( messages ) ; }
private void test Streams From Values ( ) {  Stream <  String > movie Names =  Stream . of ( _ STR , _ STR , _ STR ) ; movie Names . for Each ( null ) ;  String [ ] movie Names2 = { _ STR , _ STR } ;  Stream <  String > m Names2 =  Stream . of ( movie Names2 ) ; m Names2 . for Each ( null ) ;  List <  String > movies List = new  Array List < > ( ) ; movies List . add ( _ STR ) ; movies List . add ( _ STR ) ;  Stream <  List <  String > > from List =  Stream . of ( movies List ) ; from List . for Each ( null ) ; }
public static void cache Client User Id (  Consumer Bean consumer Bean ,  Long internal Id ,  String client Id ) { cache Client User Id ( consumer Bean . get Short_name ( ) , internal Id , client Id ) ; }
protected void process Entity (  IXMLReader reader ,  IXMLEntity Resolver entity Resolver ) throws  Exception { if ( !  XMLUtil . check Literal ( reader , _ STR ) ) {  XMLUtil . skip Tag ( reader ) ; return ; }  XMLUtil . skip Whitespace ( reader , null ) ; char ch =  XMLUtil . read Char ( reader , _ STR ) ; if ( ch == _ STR ) {  XMLUtil . skip Whitespace ( reader , null ) ; entity Resolver = this . parameter Entity Resolver ; } else { reader . unread ( ch ) ; }  String key =  XMLUtil . scan Identifier ( reader ) ;  XMLUtil . skip Whitespace ( reader , null ) ; ch =  XMLUtil . read Char ( reader , _ STR ) ;  String system ID = null ;  String public ID = null ; switch ( ch ) { case _ STR : if ( !  XMLUtil . check Literal ( reader , _ STR ) ) {  XMLUtil . skip Tag ( reader ) ; return ; }  XMLUtil . skip Whitespace ( reader , null ) ; public ID =  XMLUtil . scan String ( reader , _ STR , this . parameter Entity Resolver ) ;  XMLUtil . skip Whitespace ( reader , null ) ; system ID =  XMLUtil . scan String ( reader , _ STR , this . parameter Entity Resolver ) ;  XMLUtil . skip Whitespace ( reader , null ) ;  XMLUtil . read Char ( reader , _ STR ) ; break ; case _ STR : if ( !  XMLUtil . check Literal ( reader , _ STR ) ) {  XMLUtil . skip Tag ( reader ) ; return ; }  XMLUtil . skip Whitespace ( reader , null ) ; system ID =  XMLUtil . scan String ( reader , _ STR , this . parameter Entity Resolver ) ;  XMLUtil . skip Whitespace ( reader , null ) ;  XMLUtil . read Char ( reader , _ STR ) ; break ; case _ STR : case _ STR : reader . unread ( ch ) ;  String value =  XMLUtil . scan String ( reader , _ STR , this . parameter Entity Resolver ) ; entity Resolver . add Internal Entity ( key , value ) ;  XMLUtil . skip Whitespace ( reader , null ) ;  XMLUtil . read Char ( reader , _ STR ) ; break ; default :  XMLUtil . skip Tag ( reader ) ; } if ( system ID != null ) { entity Resolver . add External Entity ( key , public ID , system ID ) ; } }
@  Override final  Node <  V > find ( int h , int k ) { for (  Node <  V > e = first ; e != null ; ) { int s ; if ( ( ( s = lock State ) & (  WAITER |  WRITER ) ) != _ NUM ) { if ( ( e . key == k ) ) { return e ; } e = e . next ; } else if (  U . compare And Swap Int ( this ,  LOCKSTATE , s , s +  READER ) ) {  Tree Node <  V > r ;  Tree Node <  V > p ; try { p = ( ( r = root ) == null ? null : r . find Tree Node ( h , k ) ) ; } finally {  Thread w ; if ( get And Add Int ( this ,  LOCKSTATE , -  READER ) == (  READER |  WAITER ) && ( w = waiter ) != null ) {  Lock Support . unpark ( w ) ; } } return p ; } } return null ; }
public boolean is Public ( ) { return  Modifier . is Public ( flags ) ; }
@  Override public boolean receive Image (  Image To Process img ,  Task Image Container task , boolean block Until Image Release , boolean close On Image Release ,  Optional <  Runnable > runnable When Done ) throws  Interrupted Exception {  Set <  Task Image Container > pass Tasks = new  Hash Set <  Task Image Container > ( _ NUM ) ; pass Tasks . add ( task ) ; return receive Image ( img , pass Tasks , block Until Image Release , close On Image Release , runnable When Done ) ; }
protected  String do It ( ) throws  Exception { log . info ( _ STR + p_ Selection + _ STR + p_ Date Invoiced + _ STR + p_ AD_ Org_ ID + _ STR + p_ C_ BPartner_ ID + _ STR + p_ M_ In Out_ ID + _ STR + p_doc Action + _ STR + p_ Consolidate Document ) ;  String sql = null ; if ( p_ Selection ) { sql = _ STR + _ STR + _ STR + _ STR + _ STR ; } else { sql = _ STR + _ STR ; if ( p_ AD_ Org_ ID != _ NUM ) sql += _ STR ; if ( p_ C_ BPartner_ ID != _ NUM ) sql += _ STR ; if ( p_ M_ In Out_ ID != _ NUM ) sql += _ STR ; sql += _ STR + _ STR + _ STR ; }  Prepared Statement pstmt = null ; try { pstmt =  DB . prepare Statement ( sql , get_ Trx Name ( ) ) ; int index = _ NUM ; if ( p_ Selection ) { pstmt . set Int ( index , get AD_ PInstance_ ID ( ) ) ; } else { if ( p_ AD_ Org_ ID != _ NUM ) pstmt . set Int ( index ++ , p_ AD_ Org_ ID ) ; if ( p_ C_ BPartner_ ID != _ NUM ) pstmt . set Int ( index ++ , p_ C_ BPartner_ ID ) ; if ( p_ M_ In Out_ ID != _ NUM ) pstmt . set Int ( index ++ , p_ M_ In Out_ ID ) ; } } catch (  Exception e ) { log . log (  Level .  SEVERE , sql , e ) ; } return generate ( pstmt ) ; }
public static  S2 Cell Id from Face IJ ( int face , int i , int j ) { long n [ ] = { _ NUM , face << (  POS_ BITS - _ NUM ) } ; int bits = ( face &  SWAP_ MASK ) ; for ( int k = _ NUM ; k >= _ NUM ; -- k ) { bits = get Bits ( n , i , j , k , bits ) ; }  S2 Cell Id s = new  S2 Cell Id ( ( ( ( n [ _ NUM ] << _ NUM ) + n [ _ NUM ] ) << _ NUM ) + _ NUM ) ; return s ; }
private void update Actions ( final  INavi Project project ) { m_load Project Action . set Enabled ( ! project . is Loaded ( ) ) ; if ( m_add Address Space Action != null ) { m_add Address Space Action . set Enabled ( project . is Loaded ( ) ) ; } m_search View Action . set Enabled ( project . is Loaded ( ) ) ; m_forward Action . set Enabled ( project . is Loaded ( ) ) ; }
void close ( ) throws  IOException { stream . close ( ) ; }
public boolean truncate Too Long Number (  Phone Number number ) { if ( is Valid Number ( number ) ) { return _ BOOL ; }  Phone Number number Copy = new  Phone Number ( ) ; number Copy . merge From ( number ) ; long national Number = number . get National Number ( ) ; do { national Number /= _ NUM ; number Copy . set National Number ( national Number ) ; if ( is Possible Number With Reason ( number Copy ) ==  Validation Result .  TOO_ SHORT || national Number == _ NUM ) { return _ BOOL ; } } while ( ! is Valid Number ( number Copy ) ) ; number . set National Number ( national Number ) ; return _ BOOL ; }
public static boolean is Within Time Comparison Epsilon ( long time Micros ) { long now =  Utils . get System Now Micros Utc ( ) ; return  Math . abs ( time Micros - now ) < time Comparison Epsilon ; }
public  Optional <  Histogram > histogram ( ) { return  Optional . empty ( ) ; }
private  JLabel create Weekday (  String title ) {  JLabel label = new  JLabel ( title ) ; label . set Horizontal Alignment (  Swing Constants .  CENTER ) ; label . set Horizontal Text Position (  Swing Constants .  CENTER ) ; label . set Request Focus Enabled ( _ BOOL ) ; label . set Background (  Adempiere PLAF . get Primary1 ( ) ) ; label . set Foreground (  Color . white ) ; label . set Opaque ( _ BOOL ) ; return label ; }
default  Path append (  String rel Path ) { return append (  Path . parse ( rel Path ) ) ; }
public static int index Of (  String value ,  String substring ) { return value != null && substring != null ? value . index Of ( substring ) : - _ NUM ; }
public void test Submit Null Callable ( ) {  Executor Service e = new  Fork Join Pool ( _ NUM ) ;  Pool Cleaner cleaner = null ; try { cleaner = cleaner ( e ) ; try { @  Suppress Warnings ( _ STR )  Future <  String > future = e . submit ( (  Callable <  String > ) null ) ; should Throw ( ) ; } catch (  Null Pointer Exception success ) { } } finally { if ( cleaner != null ) { cleaner . close ( ) ; } } }
public int read SI32 ( ) throws  IOException { synch Bits ( ) ; int b0 = in . read ( ) ; if ( b0 < _ NUM ) { throw new  IOException ( _ STR ) ; } int b1 = in . read ( ) ; if ( b1 < _ NUM ) { throw new  IOException ( _ STR ) ; } int b2 = in . read ( ) ; if ( b2 < _ NUM ) { throw new  IOException ( _ STR ) ; } byte [ ] a Byte = new byte [ _ NUM ] ; int count = in . read ( a Byte ) ; if ( count < _ NUM ) { throw new  IOException ( _ STR ) ; } bytes Read += _ NUM ; return ( int ) ( ( a Byte [ _ NUM ] * _ NUM * _ NUM * _ NUM ) + ( b2 * _ NUM * _ NUM ) + ( b1 * _ NUM ) + b0 ) ; }
public void format ( long in Date ,  String Builder buffer ) { buffer . append ( format ( in Date ) ) ; }
public  Profiler clear Results ( ) { lapped . clear ( ) ; return this ; }
@  Override public  Graph Query has ( final  String key , final  Object value ) { criteria . add ( new  Has ( key , value ) ) ; return this ; }
public void add Attribute Value (  Principal principal ,  Guid guid ,  String name ,  String value ) throws  UMSException { modify Attribute Value (  Modification Type .  ADD , principal , guid , name , value ) ; }
public static void copy Stream (  Input Stream input Stream ,  Output Stream output Stream ) { if ( input Stream != null && output Stream != null ) { try { int length = - _ NUM ; byte [ ] buffer = new byte [  Constant .  Capacity .  BYTES_ PER_ MB ] ; while ( ( length = input Stream . read ( buffer , _ NUM , buffer . length ) ) != - _ NUM ) { output Stream . write ( buffer , _ NUM , length ) ; output Stream . flush ( ) ; } } catch (  Exception e ) { throw new  File Util Exception ( e ) ; } } }
private void print Type Members (  List < ? extends  Element > members ,  List <  Type Element > inner Class ) { for (  Element element : members ) { if ( is Public Or Protected ( element ) ) { print Member ( element , inner Class ) ; } } }
private void initialize Basic Variables ( final int start Column ) { basic Variables = new int [ get Width ( ) - _ NUM ] ; basic Rows = new int [ get Height ( ) ] ;  Arrays . fill ( basic Variables , - _ NUM ) ; for ( int i = start Column ; i < get Width ( ) - _ NUM ; i ++ ) {  Integer row = find Basic Row ( i ) ; if ( row != null ) { basic Variables [ i ] = row ; basic Rows [ row ] = i ; } } }
public void mouse Released (  Mouse Event e ) { }
private void attach Header (  SIPHeader h ) { if ( h == null ) throw new  Illegal Argument Exception ( _ STR ) ; try { if ( h instanceof  SIPHeader List ) {  SIPHeader List < ? > hl = (  SIPHeader List < ? > ) h ; if ( hl . is Empty ( ) ) { return ; } } attach Header ( h , _ BOOL , _ BOOL ) ; } catch (  SIPDuplicate Header Exception ex ) { } }
public  String phonemise (  String text ,  String pos ,  String Builder g2p Method ) {  String result = userdict Lookup ( text , pos ) ; if ( result != null ) { g2p Method . append ( _ STR ) ; return result ; } result = lexicon Lookup ( text , pos ) ; if ( result != null ) { g2p Method . append ( _ STR ) ; return result ; }  String normalised =  Mary Utils . normalise Unicode Letters ( text , get Locale ( ) ) ; if ( ! normalised . equals ( text ) ) { result = userdict Lookup ( normalised , pos ) ; if ( result != null ) { g2p Method . append ( _ STR ) ; return result ; } result = lexicon Lookup ( normalised , pos ) ; if ( result != null ) { g2p Method . append ( _ STR ) ; return result ; } }  String phones = lts . predict Pronunciation ( text ) ; result = lts . syllabify ( phones ) ; if ( result != null ) { g2p Method . append ( _ STR ) ; return result ; } return null ; }
public static void stop ( int exit_code ) {  System . exit ( exit_code ) ; }
private  Field ODEState And Derivative <  Decimal64 > state ( double t ) { return new  Field ODEState And Derivative < > ( zero . add ( t ) , new  Decimal64 [ _ NUM ] , new  Decimal64 [ _ NUM ] ) ; }
public static final void write String Array Xml (  String [ ] val ,  String name ,  Xml Serializer out ) throws  Xml Pull Parser Exception , java . io .  IOException { if ( val == null ) { out . start Tag ( null , _ STR ) ; out . end Tag ( null , _ STR ) ; return ; } out . start Tag ( null , _ STR ) ; if ( name != null ) { out . attribute ( null , _ STR , name ) ; } final int n = val . length ; out . attribute ( null , _ STR ,  Integer . to String ( n ) ) ; for ( int i = _ NUM ; i < n ; i ++ ) { if ( val [ i ] == null ) { out . start Tag ( null , _ STR ) ; out . end Tag ( null , _ STR ) ; } else { out . start Tag ( null , _ STR ) ; out . attribute ( null , _ STR , val [ i ] ) ; out . end Tag ( null , _ STR ) ; } } out . end Tag ( null , _ STR ) ; }
private  Spannable highlight Hashtags (  Spannable text ) { if ( text == null ) { return null ; } final  Matcher matcher =  PATTERN_ HASHTAGS . matcher ( text ) ; while ( matcher . find ( ) ) { final int start = matcher . start ( _ NUM ) ; final int end = matcher . end ( _ NUM ) ; text . set Span ( new  Foreground Color Span ( m Highlight Color ) , start , end ,  Spanned .  SPAN_ EXCLUSIVE_ EXCLUSIVE ) ; text . set Span ( new  Style Span ( android . graphics .  Typeface .  BOLD ) , start , end ,  Spanned .  SPAN_ EXCLUSIVE_ EXCLUSIVE ) ; } return text ; }
protected int read Block ( ) { block Size = read ( ) ; int n = _ NUM ; if ( block Size > _ NUM ) { try { int count ; while ( n < block Size ) { count = block Size - n ; raw Data . get ( block , n , count ) ; n += count ; } } catch ( final  Exception e ) {  Log . w (  TAG , _ STR , e ) ; status =  STATUS_ FORMAT_ ERROR ; } } return n ; }
private static void check For Null Element (  Object [ ] arg ,  String arg Name ) { if ( ( arg == null ) || ( arg . length == _ NUM ) ) { throw new  Illegal Argument Exception ( _ STR + arg Name + _ STR ) ; } for ( int i = _ NUM ; i < arg . length ; i ++ ) { if ( arg [ i ] == null ) { throw new  Illegal Argument Exception ( _ STR + arg Name + _ STR + i + _ STR ) ; } } }
public  Input Stream execute Download (  String url ,  String cookie ) throws  IOException {  String [ ] [ ] header Params = new  String [ ] [ ] { { _ STR , cookie } , { _ STR , _ STR } } ;  Http Entity http Entity = execute Get ( url , null , header Params ) ; return http Entity . get Content ( ) ; }
public  Image flip Image Vertically (  Image image , boolean maintain Opacity ) { int [ ] rgb = image . get RGB ( ) ; int [ ] new RGB = new int [ rgb . length ] ; int width = image . get Width ( ) ; int height = image . get Height ( ) ; for ( int y = _ NUM ; y < height ; y ++ ) { for ( int x = _ NUM ; x < width ; x ++ ) { new RGB [ x + ( height - y - _ NUM ) * width ] = rgb [ x + y * width ] ; } } return  Encoded Image . create From RGB ( new RGB , width , height , ! maintain Opacity ) ; }
public  Morfologik Filter Factory (  Map <  String ,  String > args ) { super ( args ) ; final  String  DICTIONARY_ RESOURCE_ ATTRIBUTE = _ STR ;  String dictionary Resource = get ( args ,  DICTIONARY_ RESOURCE_ ATTRIBUTE ) ; if ( dictionary Resource != null && ! dictionary Resource . is Empty ( ) ) { throw new  Illegal Argument Exception ( _ STR +  DICTIONARY_ RESOURCE_ ATTRIBUTE + _ STR + _ STR +  DICTIONARY_ ATTRIBUTE + _ STR ) ; } resource Name = get ( args ,  DICTIONARY_ ATTRIBUTE ) ; if ( ! args . is Empty ( ) ) { throw new  Illegal Argument Exception ( _ STR + args ) ; } }
public static <  T >  T wrap Throw (  Callable <  T > callable ,  Code _finally ) { try { return callable . call ( ) ; } catch (  Runtime Exception e ) { throw e ; } catch (  Exception e ) { throw new  Runtime Exception ( e ) ; } finally { wrap Throw ( _finally ) ; } }
public static  String pad Left (  String str , int total Chars ) { if ( str == null ) str = _ STR ;  String Buffer sb = new  String Buffer ( ) ; for ( int i = _ NUM ; i < total Chars - str . length ( ) ; i ++ ) { sb . append ( _ STR ) ; } sb . append ( str ) ; return sb . to String ( ) ; }
protected void decode Image Data ( ) { int  Null Code = - _ NUM ; int npix = iw * ih ; int available , clear , code_mask , code_size , end_of_information , in_code , old_code , bits , code , count , i , datum , data_size , first , top , bi , pi ; if ( ( pixels == null ) || ( pixels . length < npix ) ) { pixels = new byte [ npix ] ; } if ( prefix == null ) prefix = new short [  Max Stack Size ] ; if ( suffix == null ) suffix = new byte [  Max Stack Size ] ; if ( pixel Stack == null ) pixel Stack = new byte [  Max Stack Size + _ NUM ] ; data_size = read ( ) ; clear = _ NUM << data_size ; end_of_information = clear + _ NUM ; available = clear + _ NUM ; old_code =  Null Code ; code_size = data_size + _ NUM ; code_mask = ( _ NUM << code_size ) - _ NUM ; for ( code = _ NUM ; code < clear ; code ++ ) { prefix [ code ] = _ NUM ; suffix [ code ] = ( byte ) code ; } datum = bits = count = first = top = pi = bi = _ NUM ; for ( i = _ NUM ; i < npix ; ) { if ( top == _ NUM ) { if ( bits < code_size ) { if ( count == _ NUM ) { count = read Block ( ) ; if ( count <= _ NUM ) break ; bi = _ NUM ; } datum += ( ( ( int ) block [ bi ] ) & _ NUM ) << bits ; bits += _ NUM ; bi ++ ; count -- ; continue ; } code = datum & code_mask ; datum >>= code_size ; bits -= code_size ; if ( ( code > available ) || ( code == end_of_information ) ) break ; if ( code == clear ) { code_size = data_size + _ NUM ; code_mask = ( _ NUM << code_size ) - _ NUM ; available = clear + _ NUM ; old_code =  Null Code ; continue ; } if ( old_code ==  Null Code ) { pixel Stack [ top ++ ] = suffix [ code ] ; old_code = code ; first = code ; continue ; } in_code = code ; if ( code == available ) { pixel Stack [ top ++ ] = ( byte ) first ; code = old_code ; } while ( code > clear ) { pixel Stack [ top ++ ] = suffix [ code ] ; code = prefix [ code ] ; } first = ( ( int ) suffix [ code ] ) & _ NUM ; if ( available >=  Max Stack Size ) break ; pixel Stack [ top ++ ] = ( byte ) first ; prefix [ available ] = ( short ) old_code ; suffix [ available ] = ( byte ) first ; available ++ ; if ( ( ( available & code_mask ) == _ NUM ) && ( available <  Max Stack Size ) ) { code_size ++ ; code_mask += available ; } old_code = in_code ; } top -- ; pixels [ pi ++ ] = pixel Stack [ top ] ; i ++ ; } for ( i = pi ; i < npix ; i ++ ) { pixels [ i ] = _ NUM ; } }
public int hash Code ( ) { int myhash = _ NUM + policy Identifier . hash Code ( ) ; myhash = _ NUM * myhash + policy Qualifiers . hash Code ( ) ; return myhash ; }
public  Unix Terminal ( ) throws  IOException { this (  System . in ,  System . out ,  Charset . default Charset ( ) ) ; }
@  Override public boolean is Cell Editable ( int row Index , int column Index ) {  Process Function Parameter Value value = value List . get ( row Index ) ; switch ( column Index ) { case  COL_ OPTIONAL : return value . optional ; case  COL_ VALUE : if ( value . optional ) { return value . included ; } else { return _ BOOL ; } case  COL_ PARAMETER : case  COL_ TYPE : default : return _ BOOL ; } }
private void check Streams ( ) { if ( (  System . current Time Millis ( ) - last Checked ) / _ NUM <  CHECK_ DELAY ) { return ; } last Checked =  System . current Time Millis ( ) ;  Set <  Stream Info > remove = new  Hash Set < > ( ) ; for (  Stream Info info : data ) { if ( ! info . is Valid ( ) || ! info . get Online ( ) ) { remove . add ( info ) ; } } for (  Stream Info info : remove ) { data . remove ( info ) ; item Removed ( info ) ; } if ( remove . is Empty ( ) ) { list Data Changed ( ) ; } }
public void add Priority Package (  String pkg ) { if ( _priority Packages == null ) _priority Packages = new  String [ _ NUM ] ; int old Length = _priority Packages . length ;  String [ ] new Pkgs = new  String [ old Length + _ NUM ] ;  System . arraycopy ( _priority Packages , _ NUM , new Pkgs , _ NUM , old Length ) ; if ( ! pkg . ends With ( _ STR ) ) pkg = pkg + _ STR ; new Pkgs [ old Length ] = pkg ; _priority Packages = new Pkgs ; }
@  Override public void action Performed (  Action Event ev ) { final megan . remote .  Remote Service Browser remote Service Browser = ( megan . remote .  Remote Service Browser ) get Viewer ( ) ; if ( remote Service Browser != null ) {  String url = remote Service Browser . get URL ( ) ;  String user = remote Service Browser . get User ( ) ;  String password = remote Service Browser . get Passwd ( ) ;  String command = _ STR + url + _ STR ; if ( user . length ( ) > _ NUM ) command += _ STR + user + _ STR ; if ( password . length ( ) > _ NUM ) { synchronized ( sync Object ) {  Open Remote Server Command . hidden Password = password ; } command += _ STR +  HIDDEN_ PASSWORD + _ STR ; } command += _ STR ; if ( url . length ( ) > _ NUM ) { execute ( command ) ; } } }
public static  String verify Certificate (  X509 Certificate cert ,  Collection <  CRL > crls ,  Calendar calendar ) { if (  Sign Utils . has Unsupported Critical Extension ( cert ) ) return _ STR ; try { cert . check Validity ( calendar . get Time ( ) ) ; } catch (  Exception e ) { return e . get Message ( ) ; } if ( crls != null ) { for (  CRL crl : crls ) { if ( crl . is Revoked ( cert ) ) return _ STR ; } } return null ; }
public static void expand ( ) {  String [ ] st = new  String [  L ] ; int i ; for ( i = _ NUM ; i <  R ; i ++ ) st [ i ] = _ STR + ( char ) i ; st [ i ++ ] = _ STR ; int codeword =  Binary Std In . read Int (  W ) ; if ( codeword ==  R ) return ;  String val = st [ codeword ] ; while ( _ BOOL ) {  Binary Std Out . write ( val ) ; codeword =  Binary Std In . read Int (  W ) ; if ( codeword ==  R ) break ;  String s = st [ codeword ] ; if ( i == codeword ) s = val + val . char At ( _ NUM ) ; if ( i <  L ) st [ i ++ ] = val + s . char At ( _ NUM ) ; val = s ; }  Binary Std Out . close ( ) ; }
@  Override public boolean is Rotate Edge Labels ( ) { return graph Creator . is Rotating Edge Labels ( ) ; }
public static  Response Code create Extension (  String name ) {  String Buffer buffer = new  String Buffer ( name . length ( ) + _ NUM ) ; if ( ! name . starts With ( _ STR ) ) { buffer . append ( _ STR ) ; } buffer . append ( name ) ; return new  Response Code ( buffer . to String ( ) ) ; }
@  Override public double [ ] make Inverse Cumulative Test Values ( ) { double [ ] points = make Cumulative Test Points ( ) ; double [ ] points2 = new double [ points . length - _ NUM ] ;  System . arraycopy ( points , _ NUM , points2 , _ NUM , points2 . length ) ; return points2 ; }
public java . lang .  String Builder append ( boolean b ) { if ( b ) { return append ( _ STR ) ; } return append ( _ STR ) ; }
public void delete Servers (  Set servers ) throws  AMConsole Exception { if ( servers . contains (  System Properties . get Server Instance Name ( ) ) ) { throw new  AMConsole Exception ( get Localized String ( _ STR ) ) ; }  String server Name = null ; try { if ( ( servers != null ) && ! servers . is Empty ( ) ) {  SSOToken token = get User SSOToken ( ) ; for (  Iterator i = servers . iterator ( ) ; i . has Next ( ) ; ) { server Name = (  String ) i . next ( ) ;  String [ ] param = { server Name } ; log Event ( _ STR , param ) ;  Server Configuration . delete Server Instance ( token , server Name ) ; log Event ( _ STR , param ) ; } } } catch (  SMSException e ) {  String [ ] params = { server Name , e . get Message ( ) } ; log Event ( _ STR , params ) ; throw new  AMConsole Exception ( get Error String ( e ) ) ; } catch (  SSOException e ) {  String [ ] params = { server Name , e . get Message ( ) } ; log Event ( _ STR , params ) ; throw new  AMConsole Exception ( get Error String ( e ) ) ; } }
protected void arraycopy ( byte [ ] buf , int pos , int length ) { m Message . write ( buf , pos , length ) ; m Position = m Position + length ; }
public boolean add ( terminal sym ) throws internal_error { boolean result ; not_null ( sym ) ; result = _elements . get ( sym . index ( ) ) ; if ( ! result ) _elements . set ( sym . index ( ) ) ; return result ; }
private void create Recursivly (  String path ) throws  Keeper Exception ,  Interrupted Exception { try { if ( zk . exists ( path , _ BOOL ) == null && path . length ( ) > _ NUM ) {  String temp = path . substring ( _ NUM , path . last Index Of (  File . separator ) ) ; create Recursivly ( temp ) ; zk . create ( path , null ,  Ids .  OPEN_ ACL_ UNSAFE ,  Create Mode .  PERSISTENT ) ; } else { return ; } } catch (  Keeper Exception e ) { throw e ; } catch (  Interrupted Exception e ) { throw e ; } }
public void stop Recording ( ) { m Handler . send Message ( m Handler . obtain Message (  MSG_ STOP_ RECORDING ) ) ; m Handler . send Message ( m Handler . obtain Message (  MSG_ QUIT ) ) ; }
private void write Tag (  String name ,  Tag tag ) throws  IOException {  Tag Type type = tag . get Type ( ) ; byte [ ] name Bytes = name . get Bytes (  Standard Charsets .  UTF_8 ) ; if ( type ==  Tag Type .  END ) { throw new  IOException ( _ STR ) ; } os . write Byte ( type . get Id ( ) ) ; os . write Short ( name Bytes . length ) ; os . write ( name Bytes ) ; write Tag Payload ( tag ) ; }
public int hash Code ( ) { if ( myhash == - _ NUM ) { if ( timestamp == null ) { myhash = signer Cert Path . hash Code ( ) ; } else { myhash = signer Cert Path . hash Code ( ) + timestamp . hash Code ( ) ; } } return myhash ; }
public  Type Variable BV type Variable ( ) { int id = type Variable List . size ( ) ; type Variable List . add ( null ) ;  Type Variable BV result = new  Type Variable BV ( id , this ) ; type Variable List . set ( id , result ) ; return result ; }
public int process (  Callback [ ] callbacks , int state ) throws  Auth Login Exception { init Auth Config ( ) ;  X509 Certificate [ ] all Certs = null ; try {  Http Servlet Request servlet Request = get Http Servlet Request ( ) ; if ( servlet Request != null ) { all Certs = (  X509 Certificate [ ] ) servlet Request . get Attribute ( _ STR ) ; if ( all Certs == null || all Certs . length == _ NUM ) { debug . message ( _ STR ) ; if ( ! portal_gw_cert_auth_enabled ) { debug . error ( _ STR + _ STR ) ; throw new  Auth Login Exception ( am Auth Cert , _ STR , null ) ; } thecert = get Portal Style Cert ( servlet Request ) ; all Certs = new  X509 Certificate [ ] { thecert } ; } else { if ( portal_gw_cert_auth_enabled && portal_gw_cert_preferred ) { thecert = get Portal Style Cert ( servlet Request ) ; all Certs = new  X509 Certificate [ ] { thecert } ; } else { if ( debug . message Enabled ( ) ) { debug . message ( _ STR + _ STR , all Certs . length ) ; } thecert = all Certs [ _ NUM ] ; } } } else { thecert = send Callback ( ) ; } if ( thecert == null ) { debug . message ( _ STR ) ; throw new  Auth Login Exception ( am Auth Cert , _ STR , null ) ; } get Token From Cert ( thecert ) ; store Username Passwd ( user Token Id , null ) ; if ( debug . message Enabled ( ) ) { debug . message ( _ STR + user Token Id + _ STR ) ; } } catch (  Auth Login Exception e ) { set Failure ID ( user Token Id ) ; debug . error ( _ STR , e ) ; throw new  Auth Login Exception ( am Auth Cert , _ STR , null ) ; } if ( debug . message Enabled ( ) ) { debug . message ( _ STR + thecert . to String ( ) ) ; } if ( am Auth Cert_chk Cert In LDAP . equals Ignore Case ( _ STR ) && am Auth Cert_chk CRL . equals Ignore Case ( _ STR ) && ! ocsp Enabled ) { return  ISAuth Constants .  LOGIN_ SUCCEED ; } if ( ldap Param == null ) { set Ldap Store Param ( ) ; } if ( am Auth Cert_chk Cert In LDAP . equals Ignore Case ( _ STR ) ) {  X509 Certificate ldapcert =  AMCert Store . get Registered Certificate ( ldap Param , thecert , am Auth Cert_chk Attr Cert In LDAP ) ; if ( ldapcert == null ) { debug . error ( _ STR ) ; set Failure ID ( user Token Id ) ; throw new  Auth Login Exception ( am Auth Cert , _ STR , null ) ; } } int ret = do JCERevocation Validation ( all Certs ) ; if ( ret !=  ISAuth Constants .  LOGIN_ SUCCEED ) { debug . error ( _ STR ) ; set Failure ID ( user Token Id ) ; throw new  Auth Login Exception ( am Auth Cert , _ STR , null ) ; } return  ISAuth Constants .  LOGIN_ SUCCEED ; }
public static void downto (  Number self ,  Number to , @  Closure Params (  First Param . class )  Closure closure ) { int self1 = self . int Value ( ) ; int to1 = to . int Value ( ) ; if ( self1 >= to1 ) { for ( int i = self1 ; i >= to1 ; i -- ) { closure . call ( i ) ; } } else throw new  Groovy Runtime Exception ( _ STR + to + _ STR + self + _ STR ) ; }
public void add (  Select Clause Element Raw element ) { select Clause Elements . add ( element ) ; }
public synchronized void remove Pv Change Listener (  Pv Change Listener l ) { log . debug ( _ STR +  String . value Of ( this ) + _ STR +  String . value Of ( l ) ) ;  Pv Change Listeners . remove ( l ) ; }
public static boolean is Normal (  Geo Time Serie gts , int buckets , double pcterror , boolean bessel ) { if ( _ NUM == gts . values ) { return _ BOOL ; } if (  TYPE .  DOUBLE != gts . type &&  TYPE .  LONG != gts . type ) { return _ BOOL ; } double [ ] musigma = musigma ( gts , bessel ) ; double mu = musigma [ _ NUM ] ; double sigma = musigma [ _ NUM ] ; if ( _ NUM == sigma ) { return _ BOOL ; } double [ ] bounds =  SAXUtils . get Bounds ( buckets ) ; int [ ] counts = new int [ bounds . length + _ NUM ] ; for ( int i = _ NUM ; i < gts . values ; i ++ ) { double v = ( ( double )  GTSHelper . value At Index ( gts , i ) - mu ) / sigma ; int insertion =  Arrays . binary Search ( bounds , v ) ; if ( insertion >= _ NUM ) { counts [ insertion ] ++ ; } else { counts [ - ( _ NUM + insertion ) ] ++ ; } } double mean = gts . values / counts . length ; for ( int i = _ NUM ; i < counts . length ; i ++ ) { if (  Math . abs ( _ NUM - ( counts [ i ] / mean ) ) > pcterror ) { return _ BOOL ; } } return _ BOOL ; }
public void load From Properties (  Properties properties ) { projected =  String Util . get Boolean Value ( properties , _ STR , _ BOOL , _ BOOL ) ; tie Point =  String Util . get Double Array ( properties , _ STR , null , _ BOOL ) ; scale =  String Util . get Double Array ( properties , _ STR , null , _ BOOL ) ; globe =  String Util . get String Value ( properties , _ STR , null , _ BOOL ) ; raster Width =  String Util . get Integer Value ( properties , _ STR , _ BOOL , _ NUM , _ BOOL ) ; raster Length =  String Util . get Integer Value ( properties , _ STR , _ BOOL , _ NUM , _ BOOL ) ; datum Code =  String Util . get Integer Value ( properties , _ STR , _ BOOL , _ NUM , _ BOOL ) ; ellipsoid Code =  String Util . get Integer Value ( properties , _ STR , _ BOOL , _ NUM , _ BOOL ) ; semi Major Axis =  String Util . get Double Value ( properties , _ STR , _ BOOL ,  Double .  Na N , _ BOOL ) ; semi Minor Axis =  String Util . get Double Value ( properties , _ STR , _ BOOL ,  Double .  Na N , _ BOOL ) ; inverse Flattening =  String Util . get Double Value ( properties , _ STR , _ BOOL ,  Double .  Na N , _ BOOL ) ; gcs Prime Meridian Lon =  String Util . get Double Value ( properties , _ STR , _ BOOL ,  Double .  Na N , _ BOOL ) ; proj Code =  String Util . get Integer Value ( properties , _ STR , _ BOOL , _ NUM , _ BOOL ) ; pcs Code =  String Util . get Integer Value ( properties , _ STR , _ BOOL , _ NUM , _ BOOL ) ; coord Transform Code =  String Util . get Integer Value ( properties , _ STR , _ BOOL , _ NUM , _ BOOL ) ; std Parallel1 =  String Util . get Double Value ( properties , _ STR , _ BOOL ,  Double .  Na N , _ BOOL ) ; pole Lat = ( int ) (  Math . signum ( std Parallel1 ) * _ NUM ) ; std Parallel2 =  String Util . get Double Value ( properties , _ STR , _ BOOL ,  Double .  Na N , _ BOOL ) ; natural Origin Lon =  String Util . get Double Value ( properties , _ STR , _ BOOL ,  Double .  Na N , _ BOOL ) ; natural Origin Lat =  String Util . get Double Value ( properties , _ STR , _ BOOL ,  Double .  Na N , _ BOOL ) ; false Origin Lon =  String Util . get Double Value ( properties , _ STR , _ BOOL ,  Double .  Na N , _ BOOL ) ; false Origin Lat =  String Util . get Double Value ( properties , _ STR , _ BOOL ,  Double .  Na N , _ BOOL ) ; false Easting =  String Util . get Double Value ( properties , _ STR , _ BOOL ,  Double .  Na N , _ BOOL ) ; false Northing =  String Util . get Double Value ( properties , _ STR , _ BOOL ,  Double .  Na N , _ BOOL ) ; center Easting =  String Util . get Double Value ( properties , _ STR , _ BOOL ,  Double .  Na N , _ BOOL ) ; center Northing =  String Util . get Double Value ( properties , _ STR , _ BOOL ,  Double .  Na N , _ BOOL ) ; center Lon =  String Util . get Double Value ( properties , _ STR , _ BOOL ,  Double .  Na N , _ BOOL ) ; center Lat =  String Util . get Double Value ( properties , _ STR , _ BOOL ,  Double .  Na N , _ BOOL ) ; scale At Natural Origin =  String Util . get Double Value ( properties , _ STR , _ BOOL ,  Double .  Na N , _ BOOL ) ; scale At Center =  String Util . get Double Value ( properties , _ STR , _ BOOL ,  Double .  Na N , _ BOOL ) ; azimuth =  String Util . get Double Value ( properties , _ STR , _ BOOL ,  Double .  Na N , _ BOOL ) ; straight Vert Pole Lon =  String Util . get Double Value ( properties , _ STR , _ BOOL ,  Double .  Na N , _ BOOL ) ; gcs Citation =  String Util . get String Value ( properties , _ STR , null , _ BOOL ) ; pcs Citation =  String Util . get String Value ( properties , _ STR , null , _ BOOL ) ; proj Linear Units =  String Util . get String Value ( properties , _ STR , _ STR , _ BOOL ) ; if ( coord Transform Code ==  Geo Key .  Code_ Undefined ) {  String citation = ( pcs Citation == null ? _ STR : pcs Citation . to Lower Case ( ) ) ; if ( citation . contains ( _ STR ) && ( citation . contains ( _ STR ) || citation . contains ( _ STR ) || citation . contains ( _ STR ) ) ) { coord Transform Code =  Geo Key .  Code_ CT_ Mercator ; if (  Double . is Na N ( natural Origin Lon ) ) natural Origin Lon = _ NUM ; if (  Double . is Na N ( false Easting ) ) false Easting = _ NUM ; if (  Double . is Na N ( false Northing ) ) false Northing = _ NUM ; if ( citation . contains ( _ STR ) && citation . contains ( _ STR ) ) { if ( !  Double . is Na N ( semi Major Axis ) ) semi Minor Axis = semi Major Axis ; else { semi Major Axis =  SEMI_ MAJOR_ AXIS [ _ NUM ] ; semi Minor Axis =  SEMI_ MINOR_ AXIS [ _ NUM ] ; } } } } }
public static double gamma ( double x ) { double  P [ ] = { _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM } ; double  Q [ ] = { - _ NUM , _ NUM , - _ NUM , _ NUM , _ NUM , - _ NUM , _ NUM , _ NUM } ; double p , z ; double q =  Math . abs ( x ) ; if ( q > _ NUM ) { if ( x < _ NUM ) { p =  Math . floor ( q ) ; if ( p == q ) { throw new  Arithmetic Exception ( _ STR ) ; } z = q - p ; if ( z > _ NUM ) { p += _ NUM ; z = q - p ; } z = q *  Math . sin (  Math .  PI * z ) ; if ( z == _ NUM ) { throw new  Arithmetic Exception ( _ STR ) ; } z =  Math . abs ( z ) ; z =  Math .  PI / ( z * stirling Formula ( q ) ) ; return - z ; } else { return stirling Formula ( x ) ; } } z = _ NUM ; while ( x >= _ NUM ) { x -= _ NUM ; z *= x ; } while ( x < _ NUM ) { if ( x == _ NUM ) { throw new  Arithmetic Exception ( _ STR ) ; } else if ( x > - _ NUM ) { return ( z / ( ( _ NUM + _ NUM * x ) * x ) ) ; } z /= x ; x += _ NUM ; } while ( x < _ NUM ) { if ( x == _ NUM ) { throw new  Arithmetic Exception ( _ STR ) ; } else if ( x < _ NUM ) { return ( z / ( ( _ NUM + _ NUM * x ) * x ) ) ; } z /= x ; x += _ NUM ; } if ( ( x == _ NUM ) || ( x == _ NUM ) ) { return z ; } x -= _ NUM ; p = polevl ( x ,  P , _ NUM ) ; q = polevl ( x ,  Q , _ NUM ) ; return z * p / q ; }
public  Show Progress ( ) { start = last =  System . current Time Millis ( ) ; }
public static  Repository Expression parse Repository Expression (  String to Parse ) throws  Parse Error {  Stream Tokenizer t =  Parser . tokenize ( to Parse ) ;  Term creator =  Parser . parse Term ( t ) ;  List <  Operation > operations =  Parser . parse Operation List ( t ) ;  Repository Expression ex = new  Repository Expression ( creator ) ; if ( ! operations . is Empty ( ) ) { throw new  Parse Error ( _ STR ) ; } return ex ; }
@  Override public synchronized void close ( ) throws  IOException { buffer = null ; notify All ( ) ; }
public void add Section (  Source Section section ) { sections . add ( section ) ; }
public static  Genome Relationships load (  Buffered Reader reader ) throws  IOException { final  Genome Relationships ped = new  Genome Relationships ( ) ;  String line ; while ( ( line = reader . read Line ( ) ) != null ) { line = line . trim ( ) ; if ( line . starts With ( _ STR ) || line . matches ( _ STR ) ) { continue ; } if ( line . matches ( _ STR ) ) { parse Genome Line ( ped , line ) ; continue ; } if ( line . matches ( _ STR ) ) { parse Relationship Line ( ped , line ) ; continue ; } throw new  No Talkback Slim Exception ( _ STR + line + _ STR ) ; } return ped ; }
private int [ ] version Parts (  String version ) {  String [ ] parts = version . split ( _ STR ) ; int [ ] p = new int [ _ NUM ] ; for ( int i = _ NUM ; i < _ NUM ; i ++ ) { int pi ; if ( i < parts . length ) { p [ i ] =  Integer . parse Int ( parts [ i ] ) ; } else { p [ i ] = - _ NUM ; } } return p ; }
public static boolean approx Equals ( final double a , final double b , final double tolerance ) { if (  Double . is Na N ( a ) ||  Double . is Na N ( b ) ) { return _ BOOL ; } if ( a == b ) { return _ BOOL ; } if (  Double . is Infinite ( a ) ||  Double . is Infinite ( b ) ) { return _ BOOL ; } if ( a >= ( b - tolerance ) && a <= ( b + tolerance ) ) { return _ BOOL ; } return _ BOOL ; }
public static  Map <  String ,  Object > load Json Model (  File js File ) { try {  Map <  String ,  Object > model =  Java Script Resolver . read Json Model ( js File ) ; if ( model == null ) { throw new  Compiler Error Exception ( _ STR + js File . get Absolute Path ( ) ) ; } if ( ! model . contains Key ( _ STR ) ) { throw new  Ceylon Run Js Exception ( _ STR + js File + _ STR ) ; } return model ; } catch (  IOException ex ) { throw new  Compiler Error Exception ( _ STR + js File ) ; } }
static  String [ ] split Line ( final  String line ) { final int ix0 = line . index Of ( _ STR ) ; final int ix = ix0 == - _ NUM ? line . length ( ) : ix0 ; final  String less Comment = line . substring ( _ NUM , ix ) ; if ( less Comment . matches ( _ STR ) ) { return null ; } return less Comment . split ( _ STR ) ; }
private  List <  Volume > create Volume Data (  String name , int num Volumes ) {  List <  Volume > volumes = new  Array List <  Volume > ( ) ;  URI cg Uri = create Block Consistency Group ( name + _ STR ) ; for ( int i = _ NUM ; i <= num Volumes ; i ++ ) {  Volume volume = new  Volume ( ) ;  URI volume URI =  URIUtil . create Id (  Volume . class ) ; test Volume URIs . add ( volume URI ) ; volume . set Id ( volume URI ) ; volume . set Label ( name + i ) ; volume . set Consistency Group ( cg Uri ) ; _db Client . create Object ( volume ) ; } return volumes ; }
private static <  T >  T hash Map To Object (  Linked Hash Map map ,  Class <  T > type ) { try { return string To Object ( mapper . write Value As String ( map ) , type ) ; } catch (  IOException e ) { log . warn ( _ STR + type . get Name ( ) + _ STR + map . to String ( ) + _ STR + e . get Message ( ) ) ; return null ; } }
private void delete SMS (  String cmd ,  String search ) { int nb Deleted = - _ NUM ; if ( cmd . equals ( _ STR ) ) { nb Deleted = m Sms Manager . delete All Sms ( ) ; } else if ( cmd . equals ( _ STR ) ) { nb Deleted = m Sms Manager . delete Sent Sms ( ) ; } else if ( cmd . starts With ( _ STR ) ) {  Integer number =  Tools . parse Int ( search ) ; if ( number == null ) { number = _ NUM ; } if ( cmd . equals ( _ STR ) ) { nb Deleted = m Sms Manager . delete Last Sms ( number ) ; } else if ( cmd . equals ( _ STR ) ) { nb Deleted = m Sms Manager . delete Last In Sms ( number ) ; } else if ( cmd . equals ( _ STR ) ) { nb Deleted = m Sms Manager . delete Last Out Sms ( number ) ; } else { send (  R . string . chat_del_sms_error ) ; } } else if ( cmd . equals ( _ STR ) && search != null ) {  Array List <  Contact > contacts =  Contacts Manager . get Matching Contacts ( s Context , search ) ; if ( contacts . size ( ) > _ NUM ) {  String Builder sb = new  String Builder ( get String (  R . string . chat_specify_details ) ) ; sb . append (  Tools .  Line Sep ) ; for (  Contact contact : contacts ) { sb . append ( contact . name ) ; sb . append (  Tools .  Line Sep ) ; } send ( sb . to String ( ) ) ; } else if ( contacts . size ( ) == _ NUM ) {  Contact contact = contacts . get ( _ NUM ) ; send (  R . string . chat_del_sms_from , contact . name ) ; nb Deleted = m Sms Manager . delete Sms By Contact ( contact . raw Ids ) ; } else { send (  R . string . chat_no_match_for , search ) ; } } else if ( cmd . equals ( _ STR ) && search != null ) { send (  R . string . chat_del_sms_from , search ) ; nb Deleted = m Sms Manager . delete Sms By Number ( search ) ; if ( nb Deleted <= _ NUM ) { send (  R . string . chat_no_match_for , search ) ; } } else { send (  R . string . chat_del_sms_syntax ) ; } if ( nb Deleted >= _ NUM ) { send (  R . string . chat_del_sms_nb , nb Deleted ) ; } else if ( nb Deleted == - _ NUM ) { send (  R . string . chat_del_sms_error ) ; } }
private static  Blocks Remove Info is Start Block (  Block Node rem Block ,  Block Node start Block ) {  List <  Insn Node > rem Insns = rem Block . get Instructions ( ) ;  List <  Insn Node > start Insns = start Block . get Instructions ( ) ; if ( rem Insns . size ( ) < start Insns . size ( ) ) { return null ; } int start Pos = rem Insns . size ( ) - start Insns . size ( ) ; int end Pos = _ NUM ; if ( ! check Insns ( rem Insns , start Insns , start Pos , null ) ) { if ( check Insns ( rem Insns , start Insns , _ NUM , null ) ) { start Pos = _ NUM ; end Pos = start Insns . size ( ) ; } else { boolean found = _ BOOL ; for ( int i = _ NUM ; i < start Pos ; i ++ ) { if ( check Insns ( rem Insns , start Insns , i , null ) ) { start Pos = i ; end Pos = start Insns . size ( ) + i ; found = _ BOOL ; break ; } } if ( ! found ) { return null ; } } }  Blocks Pair start Pair = new  Blocks Pair ( rem Block , start Block ) ;  Blocks Remove Info remove Info = new  Blocks Remove Info ( start Pair ) ; remove Info . set Start Split Index ( start Pos ) ; remove Info . set End Split Index ( end Pos ) ; if ( end Pos != _ NUM ) { remove Info . set End ( start Pair ) ; } if ( ! check Insns ( rem Insns , start Insns , start Pos , remove Info ) ) { return null ; } return remove Info ; }
public boolean check Error ( ) { return pw . check Error ( ) ; }
public  List <  Pdf Document > split By Size ( long size ) {  List <  Page Range > split Ranges = new  Array List < > ( ) ; int current Page = _ NUM ; int num Of Pages = pdf Document . get Number Of Pages ( ) ; while ( current Page <= num Of Pages ) {  Page Range next Range = get Next Range ( current Page , num Of Pages , size ) ; split Ranges . add ( next Range ) ;  List <  Integer > all Pages = next Range . get All Pages ( ) ; current Page = ( int ) all Pages . get ( all Pages . size ( ) - _ NUM ) + _ NUM ; } return extract Page Ranges ( split Ranges ) ; }
private boolean validate Auth Schemes (  Set auth Scheme Set ) throws  Policy Exception { if ( auth Scheme Set . is Empty ( ) ) {  String args [ ] = {  AUTH_ SCHEME } ; throw new  Policy Exception (  Res Bundle Utils . rb Name , _ STR , args , null ) ; }  Iterator auth Scheme Set Iter = auth Scheme Set . iterator ( ) ; auth Schemes . clear ( ) ; while ( auth Scheme Set Iter . has Next ( ) ) { try {  String auth Scheme = (  String ) auth Scheme Set Iter . next ( ) ; auth Schemes . add ( auth Scheme ) ; } catch (  Class Cast Exception e ) {  String args [ ] = {  AUTH_ SCHEME } ; throw new  Policy Exception (  Res Bundle Utils . rb Name , _ STR , args , null ) ; } } return _ BOOL ; }
public static  UUID from UUIDAs URNString To UUID (  String  UUIDas URN ) { if ( !  UUIDas URN . starts With (  UUIDHelper .  UUID_as_a_ URN_ PREFIX ) ) {  IMFError Logger imf Error Logger = new  IMFError Logger Impl ( ) ; imf Error Logger . add Error (  IMFError Logger .  IMFErrors .  Error Codes .  UUID_ ERROR ,  IMFError Logger .  IMFErrors .  Error Levels .  FATAL ,  String . format ( _ STR + _ STR ,  UUIDas URN ,  UUIDHelper .  UUID_as_a_ URN_ PREFIX ) ) ; throw new  IMFException (  String . format ( _ STR ,  UUIDas URN ,  UUIDHelper .  UUID_as_a_ URN_ PREFIX ) , imf Error Logger ) ; } return  UUID . from String (  UUIDas URN . split (  UUIDHelper .  UUID_as_a_ URN_ PREFIX ) [ _ NUM ] ) ; }
public  String read Line ( ) {  String line ; try { line = scanner . next Line ( ) ; } catch (  No Such Element Exception e ) { line = null ; } return line ; }
public static byte [ ] decode ( final  String s ) { return  Base64 . decode ( s ,  Base64 .  NO_ OPTIONS ) ; }
public static  Gradient Paint make Red Paint ( final double width , final double height ) { return new  Gradient Paint ( _ NUM , _ NUM , new  Color ( _ NUM , _ NUM , _ NUM ) , ( float ) width / _ NUM , ( float ) height / _ NUM , new  Color ( _ NUM , _ NUM , _ NUM ) , _ BOOL ) ; }
public static  List <  String > match Numbers (  String text ) {  String pattern = _ STR ;  Pattern pat =  Pattern . compile ( pattern ) ;  Matcher m = pat . matcher ( text ) ;  List <  String > matches = new  Array List <  String > ( ) ; while ( m . find ( ) ) { matches . add ( m . group ( ) ) ; } return matches ; }
private boolean delete Storage (  Tracker Server tracker Server ,  String group Name ,  String storage Ip Addr ) throws  IOException { byte [ ] header ; byte [ ] b Group Name ; byte [ ] bs ; int len ;  Socket tracker Socket ; tracker Socket = tracker Server . get Socket ( ) ;  Output Stream out = tracker Socket . get Output Stream ( ) ; bs = group Name . get Bytes (  Client Global . g_charset ) ; b Group Name = new byte [  Proto Common .  FDFS_ GROUP_ NAME_ MAX_ LEN ] ; if ( bs . length <=  Proto Common .  FDFS_ GROUP_ NAME_ MAX_ LEN ) { len = bs . length ; } else { len =  Proto Common .  FDFS_ GROUP_ NAME_ MAX_ LEN ; }  Arrays . fill ( b Group Name , ( byte ) _ NUM ) ;  System . arraycopy ( bs , _ NUM , b Group Name , _ NUM , len ) ; int ip Addr Len ; byte [ ] b Ip Addr = storage Ip Addr . get Bytes (  Client Global . g_charset ) ; if ( b Ip Addr . length <  Proto Common .  FDFS_ IPADDR_ SIZE ) { ip Addr Len = b Ip Addr . length ; } else { ip Addr Len =  Proto Common .  FDFS_ IPADDR_ SIZE - _ NUM ; } header =  Proto Common . pack Header (  Proto Common .  TRACKER_ PROTO_ CMD_ SERVER_ DELETE_ STORAGE ,  Proto Common .  FDFS_ GROUP_ NAME_ MAX_ LEN + ip Addr Len , ( byte ) _ NUM ) ; byte [ ] whole Pkg = new byte [ header . length + b Group Name . length + ip Addr Len ] ;  System . arraycopy ( header , _ NUM , whole Pkg , _ NUM , header . length ) ;  System . arraycopy ( b Group Name , _ NUM , whole Pkg , header . length , b Group Name . length ) ;  System . arraycopy ( b Ip Addr , _ NUM , whole Pkg , header . length + b Group Name . length , ip Addr Len ) ; out . write ( whole Pkg ) ;  Proto Common .  Recv Package Info pkg Info =  Proto Common . recv Package ( tracker Socket . get Input Stream ( ) ,  Proto Common .  TRACKER_ PROTO_ CMD_ RESP , _ NUM ) ; this . errno = pkg Info . errno ; return pkg Info . errno == _ NUM ; }
@  Override public  UUID create Entry Node (  UUID parent Node ) {  UUID uuid =  UUID . random UUID ( ) ; graph Server . add Vertex ( uuid ) ; graph Server . add Edge ( uuid , parent Node ) ; return uuid ; }
protected void assert Delivery States ( final  Collection <  Customer Order Delivery > deliveries , final  Map <  String ,  String > expected State ) { for (  Customer Order Delivery delivery : deliveries ) { assert Equals ( _ STR + delivery . get Delivery Group ( ) + _ STR + delivery . get Delivery Num ( ) , expected State . get ( delivery . get Delivery Group ( ) ) , delivery . get Delivery Status ( ) ) ; } }
@  Nullable private  Compile Scope create Facets Compile Scope ( @  Not Null final  Compiler Manager compiler Manager , @  Not Null final  Virtual File [ ] files ) { final  Set <  Module > modules =  New . set ( ) ; boolean facets Found = _ BOOL ; for ( final  Virtual File file : files ) { final  Module module =  Module Util Core . find Module For File ( file , project ) ; if ( module != null ) { modules . add ( module ) ; if ( ! facets Found ) { facets Found = has Facets ( module ) ; } } } if ( facets Found ) { return compiler Manager . create Modules Compile Scope ( modules . to Array (  Module .  EMPTY_ ARRAY ) , _ BOOL , _ BOOL ) ; } return null ; }
@  Nullable @  Worker Thread static  File write Bitmap To File ( @  Non Null  Bitmap bitmap , @  Non Null  File file ) {  File Output Stream file Stream = null ; try {  Byte Array Output Stream byte Stream = new  Byte Array Output Stream ( ) ; bitmap . compress (  Bitmap .  Compress Format .  PNG , _ NUM , byte Stream ) ; file Stream = new  File Output Stream ( file ) ; file Stream . write ( byte Stream . to Byte Array ( ) ) ; return file ; } catch (  IOException e ) {  Log . e (  TAG , e . get Message ( ) , e ) ; } finally { if ( file Stream != null ) { try { file Stream . close ( ) ; } catch (  IOException e ) {  Log . e (  TAG , e . get Message ( ) , e ) ; } } } return null ; }
public static  Sentence parse ( final  String text , final  Conversation Context ctx ) {  String txt ; if ( text == null ) { txt = _ STR ; } else { if ( ( ctx != null ) && ctx . is For Matching ( ) ) { final  Expression Matcher matcher = new  Expression Matcher ( ) ; txt = matcher . read Matching Flags ( text ) ; if ( matcher . is Any Flag Set ( ) ) { return matcher . parse Sentence ( txt , ctx ) ; } } else { txt = text ; } } txt = txt . trim ( ) ; final  Sentence Implementation sentence = new  Sentence Implementation ( ctx , txt ) ; try { final  Conversation Parser parser = new  Conversation Parser ( sentence ) ; sentence . parse ( parser ) ; sentence . classify Words ( parser ) ; if ( ( ctx != null ) && ctx . get Merge Expressions ( ) ) { sentence . evaluate Sentence Type ( ) ; sentence . merge Words ( ) ; if ( ! ctx . is For Matching ( ) ) { sentence . standardize Sentence Type ( ) ; sentence . performa Aliasing ( ) ; } } sentence . set Error ( parser . get Error String ( ) ) ; } catch ( final  Exception e ) {  LOGGER . error ( _ STR + text + _ STR ) ; sentence . set Error ( e . get Message ( ) ) ; e . print Stack Trace ( ) ; } return sentence ; }
protected int hash (  Object key1 ,  Object key2 ,  Object key3 ) { int h = _ NUM ; if ( key1 != null ) { h ^= key1 . hash Code ( ) ; } if ( key2 != null ) { h ^= key2 . hash Code ( ) ; } if ( key3 != null ) { h ^= key3 . hash Code ( ) ; } h += ~ ( h << _ NUM ) ; h ^= ( h > > > _ NUM ) ; h += ( h << _ NUM ) ; h ^= ( h > > > _ NUM ) ; return h ; }
public void flush ( ) throws  IOException { flush Buffer ( ) ; _output Stream . flush ( ) ; }
private void add Entry To Info List (  Entry entry ,  List <  Entry Info > entry Info List ) { if ( entry Info List != null ) {  String type To Add = entry . get Type ( ) ; if ( type To Add . equals (  Db Logic .  Constants . quotation ) ) { type To Add =  Db Logic .  Constants . note ; } entry Info List . add ( new  Entry Info ( entry . get Id ( ) , entry . get Note Or Title ( _ STR ) , entry . get Quotation ( _ STR ) , entry . get Is Public ( ) , entry . has First Child Id ( ) , entry . has Parent Id ( ) , type To Add ) ) ; } }
private void update Sliding ( float new Position Normalized ) { current Slide = new Position Normalized ; state = current Slide == _ NUM ?  EXPANDED : current Slide == _ NUM ?  COLLAPSED :  SLIDING ; float slide Y =  Math . abs ( ( current Slide * max Slide ) - max Slide ) ; slidable View . set Y ( slide Y ) ; invalidate ( ) ; notify Listeners ( current Slide ) ; }
void flush (  Vcf Writer writer ) throws  IOException { if ( m Prev Record != null ) { if ( ! m Prev Dense ) { write Count ( writer , m Prev Record ) ; } else { m Vcf Filter Statistics . increment (  Stat .  DENSITY_ WINDOW_ COUNT ) ; } } m Prev Record = null ; m Prev Dense = _ BOOL ; }
public boolean equals (  String str ) { if ( str == null ) return _ BOOL ; if ( _length != str . length ( ) ) return _ BOOL ; for ( int i = _length , j = _offset + _length ; -- i >= _ NUM ; ) { if ( _array [ -- j ] != str . char At ( i ) ) return _ BOOL ; } return _ BOOL ; }
protected void flush ( ) { stream . flush ( ) ; }
private  Server Starter start Servers ( ) throws  Exception {  Server Starter srv Starter = new  Server Starter ( ) ;  Thread t = new  Thread ( srv Starter ) ; t . set Daemon ( _ BOOL ) ; t . set Name ( _ STR ) ; t . start ( ) ; srv Starter . wait For Server Start ( ) ; return srv Starter ; }
public  Pagination evaluate ( final  Class entity Class ) {  Paginate paginate = entity Class != null ? (  Paginate ) entity Class . get Annotation (  Paginate . class ) : null ; int default Limit = paginate != null ? paginate . default Limit ( ) :  DEFAULT_ PAGE_ LIMIT ; int max Limit = paginate != null ? paginate . max Limit ( ) :  MAX_ PAGE_ LIMIT ; evaluate ( default Limit , max Limit ) ; generate Totals = generate Totals && ( paginate == null || paginate . countable ( ) ) ; return this ; }
public boolean deregister Service Provider (  Object provider ) {  Object oprovider = map . get ( provider . get Class ( ) ) ; if ( provider == oprovider ) { map . remove ( provider . get Class ( ) ) ; poset . remove ( provider ) ; if ( provider instanceof  Registerable Service ) {  Registerable Service rs = (  Registerable Service ) provider ; rs . on Deregistration ( registry , category ) ; } return _ BOOL ; } return _ BOOL ; }
public  Newest First Comparator (  Date now ) {  Preconditions . check Not Null ( now ) ; m Now = new  Date ( now . get Time ( ) +  MILLIS_ IN_ DAY ) ; }
protected void update (  Comparable x ,  Object y ) { int index = index Of ( x ) ; if ( index < _ NUM ) { throw new  Series Exception ( _ STR + x ) ; } else {  Comparable Object Item item = get Data Item ( index ) ; item . set Object ( y ) ; fire Series Changed ( ) ; } }
public void write Field (  String name , float value ) throws java . io .  IOException { write Field ( name ,  Float . to String ( value ) ) ; }
public byte [ ] decode Data ( byte [ ] data , int num Error Correction Bytes ) throws  Reed Solomon Exception ,  Data Too Large Exception { if ( data == null || data . length == _ NUM ) { return null ; } if ( data . length > _ NUM ) { throw new  Data Too Large Exception ( _ STR ) ; } int [ ] data Ints = new int [ data . length ] ; for ( int i = _ NUM ; i < data . length ; i ++ ) { data Ints [ i ] = data [ i ] & _ NUM ; } int total Bytes = data . length - num Error Correction Bytes ; decoder . decode ( data Ints , num Error Correction Bytes ) ;  Byte Array Output Stream bos = new  Byte Array Output Stream ( ) ; for ( int i = _ NUM ; i < total Bytes && i < data Ints . length ; i ++ ) { bos . write ( data Ints [ i ] ) ; } return bos . to Byte Array ( ) ; }
public static  Array List <  String > string To Array List (  String string ) { return new  Array List < > (  Arrays . as List ( string . split ( _ STR ) ) ) ; }
void remove All Views From Adapter (  View Pager pager ) { m Views . clear ( ) ; pager . remove All Views ( ) ; m Is View Pager In Intentionally Inconsistent State = _ BOOL ; }
public static boolean is Valid Mobile ( @  Non Null  String mobile ) { if ( !  Text Utils . is Empty ( mobile ) && mobile . length ( ) == _ NUM ) { if ( mobile . starts With ( _ STR ) || mobile . starts With ( _ STR ) || mobile . starts With ( _ STR ) ) { return _ BOOL ; } } return _ BOOL ; }
public  String convert Error (  String filename , int line , int column ,  String message ) {  String src Filename = null ; int dest Line = _ NUM ; int src Line = _ NUM ; for ( int i = _ NUM ; i < _lines . size ( ) ; i ++ ) {  Line map = _lines . get ( i ) ; if ( filename != null && ! filename . ends With ( _dst Filename ) ) { } else if ( map . _dst Line <= line && line <= map . get Last Destination Line ( ) ) { src Filename = map . _src Filename ; src Line = map . get Source Line ( line ) ; } } if ( src Filename != null ) return src Filename + _ STR + src Line + _ STR + message ; else return filename + _ STR + line + _ STR + message ; }
public void add Notification ( @  Not Null  Notification notification ) {  Notification Item item = new  Notification Item ( resources , notification , delegate , panel ) ; notification Widget . add ( notification ) ; }
protected boolean is Attributes Modified ( ) { if ( attributes != null ) { return ( attributes . is Empty ( ) ) ? _ BOOL : _ BOOL ; } return _ BOOL ; }
@  Nullable public static  Ignore Descriptor for Method (  Class cls ,  Method mthd ) { if ( mthd . is Annotation Present (  Ignite Ignore . class ) ) {  Ignite Ignore ignore = mthd . get Annotation (  Ignite Ignore . class ) ;  String reason = ignore . value ( ) ; if (  F . is Empty ( reason ) ) throw new  Illegal Argument Exception ( _ STR + cls . get Name ( ) + _ STR + mthd . get Name ( ) + _ STR ) ; return new  Ignore Descriptor ( reason , ignore . force Failure ( ) ) ; } else return null ; }
protected void run Full Import (  String data Config ,  Map <  String ,  String > extra Params ) throws  Exception {  Hash Map <  String ,  String > params = new  Hash Map < > ( ) ; params . put ( _ STR , _ STR ) ; params . put ( _ STR , _ STR ) ; params . put ( _ STR , data Config ) ; params . put ( _ STR , _ STR ) ; params . put ( _ STR , _ STR ) ; params . put All ( extra Params ) ;  Named List l = new  Named List ( ) ; for (  Map .  Entry <  String ,  String > e : params . entry Set ( ) ) { l . add ( e . get Key ( ) , e . get Value ( ) ) ; }  Local Solr Query Request request = new  Local Solr Query Request ( h . get Core ( ) , l ) ; h . query ( _ STR , request ) ; }
public static  Modifiable DBIDs random Sample (  DBIDs source , int k ,  Random random ) { if ( k < _ NUM || k > source . size ( ) ) { throw new  Illegal Argument Exception ( _ STR + k + _ STR + source . size ( ) + _ STR ) ; } if ( random == null ) { random = new  Fast Non Threadsafe Random ( ) ; } if ( k < source . size ( ) > > _ NUM ) {  Array DBIDs aids =  DBIDUtil . ensure Array ( source ) ;  DBIDArray Iter iter = aids . iter ( ) ;  Hash Set Modifiable DBIDs sample =  DBIDUtil . new Hash Set ( k ) ; while ( sample . size ( ) < k ) { iter . seek ( random . next Int ( aids . size ( ) ) ) ; sample . add ( iter ) ; } return sample ; } else {  Array Modifiable DBIDs sample =  DBIDUtil . new Array ( source ) ; random Shuffle ( sample , random , k ) ; for ( int i = sample . size ( ) - _ NUM ; i >= k ; i -- ) { sample . remove ( i ) ; } return sample ; } }
protected int draw Message Size ( ) { int size Diff = size Range [ _ NUM ] == size Range [ _ NUM ] ? _ NUM : rng . next Int ( size Range [ _ NUM ] - size Range [ _ NUM ] ) ; return size Range [ _ NUM ] + size Diff ; }
public static  String [ ] grab Args (  String signature ) {  Matcher matcher = sig RE . matcher ( signature ) ; boolean b = matcher . matches ( ) ; if ( ! b && matcher . group Count ( ) != _ NUM ) logger . error ( _ STR , signature ) ;  String args = matcher . group ( _ NUM ) ; if ( args . is Empty ( ) ) return new  String [ _ NUM ] ; return args . split ( _ STR ) ; }
public void process Dispatch (  Uniform Pair <  Event Bean [ ] > events ) { if ( ! for Clause Delivery ) { dispatch Internal ( events ) ; return ; } if ( ( group Delivery Expressions == null ) || ( group Delivery Expressions . length == _ NUM ) ) {  Uniform Pair <  Event Bean [ ] > todeliver = new  Uniform Pair <  Event Bean [ ] > ( null , null ) ; if ( events != null ) { if ( events . get First ( ) != null ) { for (  Event Bean the Event : events . get First ( ) ) { todeliver . set First ( new  Event Bean [ ] { the Event } ) ; dispatch Internal ( todeliver ) ; } todeliver . set First ( null ) ; } if ( events . get Second ( ) != null ) { for (  Event Bean the Event : events . get Second ( ) ) { todeliver . set Second ( new  Event Bean [ ] { the Event } ) ; dispatch Internal ( todeliver ) ; } todeliver . set Second ( null ) ; } } return ; }  Map <  Object ,  Uniform Pair <  Event Bean [ ] > > groups ; try { groups = get Grouped Results ( events ) ; } catch (  Runtime Exception ex ) { log . error ( _ STR + ex . get Message ( ) + _ STR , ex ) ; dispatch Internal ( events ) ; return ; } for (  Map .  Entry <  Object ,  Uniform Pair <  Event Bean [ ] > > group : groups . entry Set ( ) ) { dispatch Internal ( group . get Value ( ) ) ; } }
public  V put (  K key ,  V value ) { final int hash ; int index ; if ( key == null ) { hash = _ NUM ; index = index Of Null ( ) ; } else { hash = key . hash Code ( ) ; index = index Of ( key , hash ) ; } if ( index >= _ NUM ) { index = ( index << _ NUM ) + _ NUM ; final  V old = (  V ) m Array [ index ] ; m Array [ index ] = value ; return old ; } index = ~ index ; if ( m Size >= m Hashes . length ) { final int n = m Size >= (  BASE_ SIZE * _ NUM ) ? ( m Size + ( m Size > > _ NUM ) ) : ( m Size >=  BASE_ SIZE ? (  BASE_ SIZE * _ NUM ) :  BASE_ SIZE ) ; final int [ ] ohashes = m Hashes ; final  Object [ ] oarray = m Array ; alloc Arrays ( n ) ; if ( m Hashes . length > _ NUM ) {  System . arraycopy ( ohashes , _ NUM , m Hashes , _ NUM , ohashes . length ) ;  System . arraycopy ( oarray , _ NUM , m Array , _ NUM , oarray . length ) ; } free Arrays ( ohashes , oarray , m Size ) ; } if ( index < m Size ) {  System . arraycopy ( m Hashes , index , m Hashes , index + _ NUM , m Size - index ) ;  System . arraycopy ( m Array , index << _ NUM , m Array , ( index + _ NUM ) << _ NUM , ( m Size - index ) << _ NUM ) ; } m Hashes [ index ] = hash ; m Array [ index << _ NUM ] = key ; m Array [ ( index << _ NUM ) + _ NUM ] = value ; m Size ++ ; return null ; }
public void put Long ( long pos , long val ) { unsafe . put Long ( pos + addr , val ) ; }
public boolean delete RSet Step (  URI rp System Id ,  List <  URI > volume Ids ,  String token ) throws  Internal Exception {  List <  String > replication Set Names = new  Array List <  String > ( ) ; try {  List <  Recover Point Volume Protection Info > volume Protection Info List = new  Array List <  Recover Point Volume Protection Info > ( ) ;  Protection System rp System = _db Client . query Object (  Protection System . class , rp System Id ) ;  Recover Point Client rp =  RPHelper . get Recover Point Client ( rp System ) ; for (  URI volume Id : volume Ids ) {  Volume volume = _db Client . query Object (  Volume . class , volume Id ) ;  Recover Point Volume Protection Info volume Protection Info = rp . get Protection Info For Volume (  RPHelper . get RPWWn ( volume . get Id ( ) , _db Client ) ) ;  Volume source Volume =  RPHelper . get RPSource Volume ( _db Client , volume ) ;  Virtual Pool virtual Pool = _db Client . query Object (  Virtual Pool . class , source Volume . get Virtual Pool ( ) ) ; volume Protection Info . set Metro Point (  Virtual Pool . v Pool Specifies Metro Point ( virtual Pool ) ) ; volume Protection Info List . add ( volume Protection Info ) ; replication Set Names . add ( volume . get RSet Name ( ) ) ; } if ( ! volume Protection Info List . is Empty ( ) ) { rp . delete Replication Sets ( volume Protection Info List ) ; }  Workflow Step Completer . step Succeded ( token ) ; } catch (  Exception e ) { _log . error (  String . format ( _ STR , replication Set Names . to String ( ) ) ) ; return step Failed ( token , e , _ STR ) ; } return _ BOOL ; }
private void move To Next ( ) { check Main Thread ( ) ; scheduled . set ( _ BOOL ) ;  Bitmap next = pending . poll ( ) ; if ( next != null ) { if ( current != null && ! finished . offer ( current ) ) throw new  Runtime Exception ( _ STR ) ; current = next ; invalidate Self ( ) ; ensure Scheduled ( ) ; frame Available Subject . on Next ( null ) ; fps Counter . update ( ) ; } }
public  String rma (  Properties ctx , int  Window No ,  Grid Tab m Tab ,  Grid Field m Field ,  Object value ) {  Integer  M_ RMA_ ID = (  Integer ) value ; if (  M_ RMA_ ID == null ||  M_ RMA_ ID . int Value ( ) == _ NUM ) return _ STR ; if ( is Callout Active ( ) ) return _ STR ;  MRMA rma = new  MRMA ( ctx ,  M_ RMA_ ID . int Value ( ) , null ) ;  MIn Out original Receipt = rma . get Shipment ( ) ; if ( rma . get_ ID ( ) != _ NUM ) { m Tab . set Value ( _ STR , original Receipt . get Date Ordered ( ) ) ; m Tab . set Value ( _ STR , original Receipt . get POReference ( ) ) ; m Tab . set Value ( _ STR , new  Integer ( original Receipt . get AD_ Org_ ID ( ) ) ) ; m Tab . set Value ( _ STR , new  Integer ( original Receipt . get AD_ Org Trx_ ID ( ) ) ) ; m Tab . set Value ( _ STR , new  Integer ( original Receipt . get C_ Activity_ ID ( ) ) ) ; m Tab . set Value ( _ STR , new  Integer ( original Receipt . get C_ Campaign_ ID ( ) ) ) ; m Tab . set Value ( _ STR , new  Integer ( original Receipt . get C_ Project_ ID ( ) ) ) ; m Tab . set Value ( _ STR , new  Integer ( original Receipt . get User1_ ID ( ) ) ) ; m Tab . set Value ( _ STR , new  Integer ( original Receipt . get User2_ ID ( ) ) ) ; m Tab . set Value ( _ STR , new  Integer ( original Receipt . get M_ Warehouse_ ID ( ) ) ) ; m Tab . set Value ( _ STR , original Receipt . get Delivery Rule ( ) ) ; m Tab . set Value ( _ STR , original Receipt . get Delivery Via Rule ( ) ) ; m Tab . set Value ( _ STR , new  Integer ( original Receipt . get M_ Shipper_ ID ( ) ) ) ; m Tab . set Value ( _ STR , original Receipt . get Freight Cost Rule ( ) ) ; m Tab . set Value ( _ STR , original Receipt . get Freight Amt ( ) ) ; m Tab . set Value ( _ STR , new  Integer ( original Receipt . get C_ BPartner_ ID ( ) ) ) ; m Tab . set Value ( _ STR , new  Integer ( original Receipt . get C_ BPartner_ Location_ ID ( ) ) ) ; if ( original Receipt . get AD_ User_ ID ( ) > _ NUM ) m Tab . set Value ( _ STR , new  Integer ( original Receipt . get AD_ User_ ID ( ) ) ) ; else m Tab . set Value ( _ STR , null ) ; } return _ STR ; }
public final long read Long ( ) throws java . io .  IOException { read Fully ( scratch , _ NUM , _ NUM ) ; int h = ( ( scratch [ _ NUM ] & _ NUM ) << _ NUM ) | ( ( scratch [ _ NUM ] & _ NUM ) << _ NUM ) | ( ( scratch [ _ NUM ] & _ NUM ) << _ NUM ) | ( ( scratch [ _ NUM ] & _ NUM ) << _ NUM ) ; int l = ( ( scratch [ _ NUM ] & _ NUM ) << _ NUM ) | ( ( scratch [ _ NUM ] & _ NUM ) << _ NUM ) | ( ( scratch [ _ NUM ] & _ NUM ) << _ NUM ) | ( ( scratch [ _ NUM ] & _ NUM ) << _ NUM ) ; return ( ( ( long ) h ) << _ NUM ) | ( ( long ) l ) & _ NUM ; }
public void test Get Columns Meta Data ( ) throws  Exception {  Database Meta Data dmd = con . get Meta Data ( ) ;  Result Set rs = dmd . get Columns ( null , null , _ STR , null ) ; assert Not Null ( rs ) ;  Result Set Meta Data rsmd = rs . get Meta Data ( ) ; assert Not Null ( rsmd . get Catalog Name ( _ NUM ) ) ; assert Not Null ( rsmd . get Column Class Name ( _ NUM ) ) ; rsmd . get Column Count ( ) ; assert True ( _ NUM != rsmd . get Column Display Size ( _ NUM ) ) ; assert Not Null ( rsmd . get Column Label ( _ NUM ) ) ; assert Not Null ( rsmd . get Column Name ( _ NUM ) ) ; rsmd . get Column Type ( _ NUM ) ; assert Not Null ( rsmd . get Column Type Name ( _ NUM ) ) ; rsmd . get Precision ( _ NUM ) ; rsmd . get Scale ( _ NUM ) ; assert Not Null ( rsmd . get Schema Name ( _ NUM ) ) ; assert Not Null ( rsmd . get Table Name ( _ NUM ) ) ; rsmd . is Auto Increment ( _ NUM ) ; rsmd . is Case Sensitive ( _ NUM ) ; rsmd . is Currency ( _ NUM ) ; rsmd . is Definitely Writable ( _ NUM ) ; rsmd . is Nullable ( _ NUM ) ; rsmd . is Read Only ( _ NUM ) ; rsmd . is Searchable ( _ NUM ) ; rsmd . is Signed ( _ NUM ) ; rsmd . is Writable ( _ NUM ) ; rs . close ( ) ; }
public  String to String ( ) { return super . to String ( ) + _ STR + record Map . size ( ) + _ STR + first Offset + _ STR + release Buffer + _ STR + prefix Writes + _ STR + use Checksum + _ STR + bytes Written ( ) + _ STR + remaining ( ) + _ STR + m_removed + _ STR ; }
private void handle Json Create Account (  Request And Response request And Response ) throws  IOException ,  Servlet Exception { request And Response . set Response Content Type Json ( ) ;  String user Name , password , password2 , email ; boolean may Contact = _ BOOL ;  String csrft ; try { final  Json Node Helper json = get Json Node ( request And Response ) ; user Name = json . get String ( _ STR ) ; password = json . get String ( _ STR ) ; password2 = json . get String ( _ STR ) ; email = json . get String ( _ STR ) ; may Contact = json . get Boolean ( _ STR ) ; csrft = json . get String ( _ STR ) ; } catch ( final  IOException e ) { return Json400 ( request And Response , servlet Text . error Json ( ) ) ; return ; } if ( user Name != null ) { user Name = user Name . to Lower Case ( ) ; } if ( is The Csrft Wrong ( request And Response , csrft ) ) { return Json400 ( request And Response , servlet Text . error Wrong Csrft ( ) ) ; return ; } if ( ! allow Self Sign Up ) { return Json400 ( request And Response , servlet Text . error Self Sign Up Not Allowed ( ) ) ; return ; } if ( user Name == null || user Name . is Empty ( ) ) { return Json400 ( request And Response , servlet Text . error Username Must Not Be Blank ( ) ) ; return ; } if ( password == null || password . is Empty ( ) ) { return Json400 ( request And Response , servlet Text . error First Password Must Be Set ( _ BOOL , null ) ) ; return ; } if ( password == null || password2 . is Empty ( ) ) { return Json400 ( request And Response , servlet Text . error Second Password Must Be Set ( _ BOOL , null ) ) ; return ; } if ( ! password2 . equals ( password ) ) { return Json400 ( request And Response , servlet Text . error Passwords Must Match ( ) ) ; return ; } if ( !  Account Attribute Validator . is User Name Valid ( user Name ) ) { return Json400 ( request And Response , servlet Text . error User Name Is Not Valid ( ) ) ; return ; } if ( !  Account Attribute Validator . is Password Valid ( password ) ) { return Json400 ( request And Response , servlet Text . error Password Is Not Valid ( ) ) ; return ; } if ( email != null && email . is Empty ( ) ) { email = null ; } if ( email != null && !  Account Attribute Validator . is Email Valid ( email ) ) { return Json400 ( request And Response , servlet Text . error Email Is Not Valid ( ) ) ; return ; } try {  User user = db Logic . get User By User Name ( user Name ) ; if ( user != null ) { return Json400 ( request And Response , servlet Text . error User Name Is Already Taken ( ) ) ; return ; } user = db Logic . create User ( user Name ) ; if ( user == null ) { return Json400 ( request And Response , servlet Text . error Could Not Create Account ( ) ) ; return ; } user . set Password (  Digest Utils . sha1 Hex ( password ) ) ; user . set Email ( email ) ; user . set May Contact ( may Contact ) ; map Session To User ( request And Response , user . get Id ( ) ) ; db Logic . commit ( ) ; return Json200 ( request And Response ) ; } catch ( final  Persistence Exception e ) { logger . log (  Level .  INFO , _ STR , e ) ; return Json500 ( request And Response , servlet Text . error Internal Database ( ) ) ; } }
private  Object [ ] resolve Parameters (  Executable executable ,  Optional <  Object > target ,  Object outer Instance ,  Extension Context extension Context ,  Extension Registry extension Registry ) {  Preconditions . not Null ( target , _ STR ) ;  Parameter [ ] parameters = executable . get Parameters ( ) ;  Object [ ] values = new  Object [ parameters . length ] ; int start = _ NUM ; if ( outer Instance != null ) { values [ _ NUM ] = outer Instance ; start = _ NUM ; } for ( int i = start ; i < parameters . length ; i ++ ) {  Parameter Context parameter Context = new  Default Parameter Context ( parameters [ i ] , i , target ) ; values [ i ] = resolve Parameter ( parameter Context , executable , extension Context , extension Registry ) ; } return values ; }
public static boolean is Valid Name Char ( char c ) { return is Valid Name Start Char ( c ) || ( c >= _ STR && c <= _ STR ) ; }
public void support Tls Intolerant Server (  SSLSocket socket ) { socket . set Enabled Protocols ( new  String [ ] { _ STR } ) ; }
protected static boolean id_start_char ( int ch ) { return ( ch >= _ STR && ch <= _ STR ) || ( ch >= _ STR && ch <= _ STR ) || ( ch == _ STR ) ; }
public int hash Code ( ) { int fhash = ( family != null ) ? family . hash Code ( ) : _ NUM ; return fhash ^ style ^ size ; }
private  Command Handler Enum ( final  Command command1 ) { this . command = command1 ; }
public static boolean is Float (  String desc ) { return desc . ends With ( _ STR ) ; }
public void component Resized (  Component Event e ) {  JScroll Bar bar = get Vertical Scroll Bar ( ) ; int incr = ( int ) ( get Size ( ) . get Height ( ) - ( bar . get Unit Increment ( _ NUM ) * _ NUM ) ) ; get Vertical Scroll Bar ( ) . set Block Increment ( incr ) ; }
public  Arg (  String a Name ,  String desc , int expected Number Of Arguments , boolean expect Dashed Arguments ) { name = a Name ; description = desc ; num Expected Values = expected Number Of Arguments ; c = name . char At ( _ NUM ) ; dashed Arguments = expect Dashed Arguments ; }
private boolean remove (  Object o ,  Object [ ] snapshot , int index ) { final  Reentrant Lock lock = this . lock ; lock . lock ( ) ; try {  Object [ ] current = get Array ( ) ; int len = current . length ; if ( snapshot != current ) find Index : { int prefix =  Math . min ( index , len ) ; for ( int i = _ NUM ; i < prefix ; i ++ ) { if ( current [ i ] != snapshot [ i ] && eq ( o , current [ i ] ) ) { index = i ; break find Index ; } } if ( index >= len ) return _ BOOL ; if ( current [ index ] == o ) break find Index ; index = index Of ( o , current , index , len ) ; if ( index < _ NUM ) return _ BOOL ; }  Object [ ] new Elements = new  Object [ len - _ NUM ] ;  System . arraycopy ( current , _ NUM , new Elements , _ NUM , index ) ;  System . arraycopy ( current , index + _ NUM , new Elements , index , len - index - _ NUM ) ; set Array ( new Elements ) ; return _ BOOL ; } finally { lock . unlock ( ) ; } }
public void remove Model (  Model model ) { models . remove ( model ) ; }
public void read Map ( int map_ Number ) {  Input Stream map_file ; try { map_file = new  File Input Stream ( _ STR + map_ Number + _ STR ) ; try { byte [ ] data = new byte [ map_file . available ( ) ] ; map_file . read ( data ) ; map_file . close ( ) ;  String load_data = new  String ( data , _ STR ) ; make Map ( load_data ) ; } catch (  IOException e ) { e . print Stack Trace ( ) ; } } catch (  File Not Found Exception e1 ) { e1 . print Stack Trace ( ) ; } }
public static double hoeffding Ln ( double trials , double observed , double prob ) { return - _ NUM *  Math . pow ( trials * prob - observed , _ NUM ) / trials ; }
public void test Local Instances_deterministic ( ) {  Matsim Random . reset ( ) ;  Random local1a =  Matsim Random . get Local Instance ( ) ;  Random local1b =  Matsim Random . get Local Instance ( ) ;  Matsim Random . reset ( ) ;  Random local2a =  Matsim Random . get Local Instance ( ) ;  Random local2b =  Matsim Random . get Local Instance ( ) ; assert Equal Random Number Generators ( local1a , local2a ) ; assert Equal Random Number Generators ( local1b , local2b ) ; }
public void add (  Match match ,  Applied Region applied Region ) { add ( match , applied Region , _ BOOL ) ; }
public void reset ( ) { tech Tree . check Sub Tree ( tech Tree . get Path For Row ( _ NUM ) , _ BOOL ) ; }
@  Suppress Warnings ( _ STR ) private static <  T > void assert Throws ( final  Consumer <  Void > consumer , final  Class <  T > exception Class , final  Consumer <  T > assert Exception Properties , final  String message ) { final  String normalized Message = null == message ? _ STR :  String . format ( _ STR , message ) ; try { consumer . accept ( null ) ; } catch ( final  Exception ex ) { if ( exception Class . is Assignable From ( ex . get Class ( ) ) ) { assert Exception Properties . accept ( (  T ) ex ) ; return ; }  Assert . fail (  String . format ( _ STR , normalized Message , ex . get Class ( ) , ex . get Message ( ) ) ) ; }  Assert . fail (  String . format ( _ STR , normalized Message , exception Class ) ) ; }
public boolean is Empty ( ) { return nodes . is Empty ( ) && ways . is Empty ( ) && relations . is Empty ( ) ; }
public static void assert Bool ( boolean b ) { if ( verbose ) { log ( _ STR + b + _ STR ) ; } if ( ! b ) { throw new  Runtime Exception ( ) ; } }
public  Tag Key Value Map Converter ( boolean null If Empty ,  String id Key ) {  Objects . require Non Null ( id Key ) ; this . null If Empty = null If Empty ; this . add Id = _ BOOL ; this . id Key = id Key ; }
private static void post Init ( ) { debug All = dbg Table . contains Key ( debug All Token ) ; }
public static  List <  File > sort In Batch (  File file ,  Comparator <  String > cmp ) throws  IOException { return sort In Batch ( file , cmp ,  DEFAULTMAXTEMPFILES ) ; }
public void add Directory Set (  Context context ,  String path ) {  Tiny DB tinydb = new  Tiny DB ( context ) ;  Array List <  String > file = tinydb . get List String ( _ STR ) ; file . add ( path ) ; tinydb . put List String ( _ STR , file ) ; }
private  Fast Concurrent Skip List Map .  Node <  K ,  V > hi Node ( ) { if ( hi == null ) return m . find Last ( ) ; else if ( hi Inclusive ) return m . find Near ( hi , m .  LT | m .  EQ ) ; else return m . find Near ( hi , m .  LT ) ; }
protected void process Event Properties (  Properties event Props ) { int status ;  Node node ;  Line line ;  String cmd = event Props . get Property (  COMMAND_ FIELD ) ; int index =  Prop Utils . int From Properties ( event Props ,  INDEX_ FIELD ,  ERROR_ VALUE_ INT ) ; if ( cmd . equals (  NODE_ OBJECT ) ) { int shape =  Prop Utils . int From Properties ( event Props ,  SHAPE_ FIELD ,  ERROR_ VALUE_ INT ) ; if ( index ==  ERROR_ VALUE_ INT ) {  Debug . error ( _ STR ) ; return ; } node = node List . get ( index ) ; if ( shape == _ NUM ) {  String icon = event Props . get Property (  ICON_ FIELD ) ; if (  DEBUG )  Debug . output ( _ STR + icon ) ; } if ( shape ==  NODE_ DELETE ) { if ( node != null ) { line List . del ( node ) ; node List . del ( node ) ; } } else if ( shape ==  NODE_ MOVE && node != null ) { set Node Position From Event Props ( node , event Props ) ; line List . move ( node ) ; node . set Time (  Double . parse Double ( event Props . get Property (  TIME_ FIELD , _ STR ) ) ) ; } else { status =  Prop Utils . int From Properties ( event Props ,  STATUS_ FIELD , _ NUM ) ; int menu =  Prop Utils . int From Properties ( event Props ,  MENU_ FIELD , _ NUM ) ;  String label = event Props . get Property (  LABEL_ FIELD ) ; if ( label == null ) { label = event Props . get Property (  INDEX_ FIELD ) ; }  String ip = event Props . get Property (  IP_ FIELD ) ; boolean is Localhost = _ BOOL ; if ( ip != null && localhost IP != null ) { is Localhost = localhost IP . equals ( ip ) ; if (  DEBUG ) {  Debug . output ( _ STR + localhost IP ) ; } } if (  DEBUG ) {  Debug . output ( _ STR + label + _ STR ) ; } try { if ( shape !=  ERROR_ VALUE_ INT ) { node = node List . add ( label , index , shape , menu , status ) ; node . set Localhost ( is Localhost ) ; } } catch (  Exception e ) {  Debug . error ( _ STR ) ; } set Node Position From Event Props ( node , event Props ) ; } } else if ( cmd . equals (  NODE_ OBJECT_ STATUS ) ) { if ( index ==  ERROR_ VALUE_ INT ) {  Debug . error ( _ STR ) ; return ; } node = node List . get ( index ) ; if ( node != null ) { status =  Prop Utils . int From Properties ( event Props ,  STATUS_ FIELD ,  ERROR_ VALUE_ INT ) ; if ( status !=  ERROR_ VALUE_ INT ) { node . set Status ( status ) ; } } } else if ( cmd . equals (  LINK_ OBJECT_ STATUS ) ) { if ( index ==  ERROR_ VALUE_ INT ) {  Debug . error ( _ STR ) ; return ; } line = line List . get ( index ) ; if ( line != null ) { status =  Prop Utils . int From Properties ( event Props ,  STATUS_ FIELD ,  ERROR_ VALUE_ INT ) ; if ( status !=  ERROR_ VALUE_ INT ) { line . set Status ( status ) ; } } } else if ( cmd . equals (  LINK_ OBJECT ) ) { if ( index ==  ERROR_ VALUE_ INT ) {  Debug . error ( _ STR ) ; return ; } line = line List . get ( index ) ; int shape =  Prop Utils . int From Properties ( event Props ,  SHAPE_ FIELD ,  ERROR_ VALUE_ INT ) ; if ( shape ==  NODE_ DELETE ) { line List . del ( index ) ; } else { status =  Prop Utils . int From Properties ( event Props ,  STATUS_ FIELD , _ NUM ) ; int node1 =  Prop Utils . int From Properties ( event Props ,  LINK_ NODE1_ FIELD ,  ERROR_ VALUE_ INT ) ; int node2 =  Prop Utils . int From Properties ( event Props ,  LINK_ NODE2_ FIELD ,  ERROR_ VALUE_ INT ) ; if ( node1 ==  ERROR_ VALUE_ INT || node2 ==  ERROR_ VALUE_ INT ) {  Debug . error ( _ STR ) ; return ; }  Node n1 = node List . get ( node1 ) ;  Node n2 = node List . get ( node2 ) ; if ( n1 != null && n2 != null ) { line List . add (  String . value Of ( index ) , index , shape , status , n1 , n2 ) ; } else { if (  DEBUG ) {  Debug . output ( _ STR ) ; } } } } else if ( cmd . equals (  REFRESH ) || cmd . equals (  UPDATE ) ) { } else if ( cmd . equals (  CLEAR ) ) { if ( node List != null ) { node List . flush ( ) ; } if ( line List != null ) { line List . flush ( ) ; } } else { if (  DEBUG ) {  Debug . output ( _ STR + event Props . to String ( ) ) ; } } manage Graphics ( ) ; }
protected static void add Id Repo AMSDKPlugin (  SSOToken token ,  String org Name ) throws  SMSException ,  SSOException {  Service Config Manager scm = new  Service Config Manager (  Service Manager .  REALM_ SERVICE , token ) ;  Service Config sc = scm . get Organization Config ( org Name , null ) ;  Map attributes = new  Hash Map ( ) ;  Set values = new  Hash Set ( ) ; values . add ( _ STR ) ; attributes . put ( _ STR , values ) ; values = new  Hash Set ( ) ; values . add (  DNMapper . realm Name To AMSDKName (  DNMapper . org Name To DN ( org Name ) ) ) ; attributes . put ( _ STR , values ) ; sc . add Sub Config ( _ STR , _ STR , _ NUM , attributes ) ; }
public static  String on Key Press (  String key ) { pin = pin . concat ( key ) ; return pin ; }
public boolean is Hierachic (  String string ) { int index = string . index Of ( m_ Seperator ) ; if ( ( index == ( string . length ( ) - _ NUM ) ) || ( index == - _ NUM ) ) { return _ BOOL ; } return _ BOOL ; }
public  Shape paint Layer (  Graphics g , int offs0 , int offs1 ,  Shape bounds ,  JText Component c ,  View view ) {  Color base = get Color ( ) ;  Color color = base != null ? new  Color ( base . get Red ( ) , base . get Green ( ) , base . get Blue ( ) , _ NUM ) : null ; if ( color == null ) { g . set Color ( c . get Selection Color ( ) ) ; } else { g . set Color ( color ) ; } if ( offs0 == view . get Start Offset ( ) && offs1 == view . get End Offset ( ) ) {  Rectangle alloc ; if ( bounds instanceof  Rectangle ) { alloc = (  Rectangle ) bounds ; } else { alloc = bounds . get Bounds ( ) ; } g . fill Rect ( alloc . x , alloc . y , c . get Width ( ) - alloc . x , alloc . height ) ; } else { try {  Shape shape = view . model To View ( offs0 ,  Position .  Bias .  Forward , offs1 ,  Position .  Bias .  Backward , bounds ) ;  Rectangle r = ( shape instanceof  Rectangle ) ? (  Rectangle ) shape : shape . get Bounds ( ) ; g . fill Rect ( _ NUM , r . y , c . get Width ( ) , r . height ) ; return r ; } catch (  Bad Location Exception e ) { } } return null ; }
synchronized void receive ( char one Char ) throws  IOException { if ( buffer == null ) { throw new  IOException ( _ STR ) ; } if ( last Reader != null && ! last Reader . is Alive ( ) ) { throw new  IOException ( _ STR ) ; } last Writer =  Thread . current Thread ( ) ; try { while ( buffer != null && out == in ) { notify All ( ) ; wait ( _ NUM ) ; if ( last Reader != null && ! last Reader . is Alive ( ) ) { throw new  IOException ( _ STR ) ; } } } catch (  Interrupted Exception e ) { throw new  Interrupted IOException ( ) ; } if ( buffer == null ) { throw new  IOException ( _ STR ) ; } if ( in == - _ NUM ) { in = _ NUM ; } buffer [ in ++ ] = one Char ; if ( in == buffer . length ) { in = _ NUM ; } }
public static final  Byte Buffer buffer To Byte Buffer ( final byte [ ] buffer , final  Byte Order order ) { final  Byte Buffer ret Buff =  Byte Buffer . wrap ( buffer ) ; ret Buff . order ( order ) ; return ret Buff ; }
private  URI process Local Files (  URI uri ) {  String uri Str = uri . to String ( ) ; if ( uri Str . starts With ( _ STR ) ) { uri Str = _ STR +  System . get Property ( _ STR ) + _ STR + uri Str . substring ( _ NUM ) ;  URL url ; try { url = new  URL ( uri Str ) ; return url . to URI ( ) ; } catch (  Exception e ) { e . print Stack Trace ( ) ; } } return uri ; }
public void reset ( ) { count = _ NUM ; start Time =  System . current Time Millis ( ) ; }
public int read Int ( ) throws  IOException { length += _ NUM ; int k1 = in . read ( ) ; if ( k1 < _ NUM ) return _ NUM ; int k2 = in . read ( ) << _ NUM ; int k3 = in . read ( ) << _ NUM ; return k1 + k2 + k3 + ( in . read ( ) << _ NUM ) ; }
public void add Transformation (  Tag Transformation tag Transformation ) { if ( tag Transformation != null ) { mappings . put ( tag Transformation . get Source Tag ( ) , tag Transformation ) ; } }
public  String next String ( ) { next Clean ( _ STR ) ;  String Builder sb = new  String Builder ( ) ; for ( ; ; ) { char c = next ( ) ; switch ( c ) { case _ NUM : case _ STR : case _ STR : throw syntax Error ( _ STR ) ; case _ STR : c = next ( ) ; switch ( c ) { case _ STR : sb . append ( _ STR ) ; break ; case _ STR : sb . append ( _ STR ) ; break ; case _ STR : sb . append ( _ STR ) ; break ; case _ STR : sb . append ( _ STR ) ; break ; case _ STR : sb . append ( _ STR ) ; break ; case _ STR : sb . append ( ( char )  Integer . parse Int ( next ( _ NUM ) , _ NUM ) ) ; break ; default : sb . append ( c ) ; } break ; case _ STR : return sb . to String ( ) ; default : if ( c < _ STR ) { throw syntax Error ( _ STR + ( ( int ) c ) + _ STR ) ; } sb . append ( c ) ; break ; } } }
private void read Lyrics3 Tag (  File file ,  Random Access File new File , int load Options ) throws  IOException { }
public double evaluate (  Vector Instance x ,  Vector Instance y ) throws  Exception { double dot Prod = x . dot Product ( y ) ; return  Math . pow ( m_gamma * dot Prod + m_coef0 , m_degree ) ; }
private boolean is Db Configuration Present ( ) { return  String Utils . is Not Blank ( select Column ) &&  String Utils . is Not Blank ( table Name ) ; }
public boolean is Incomplete Numerical Run (  String pin ) { final int len = pin . length ( ) ; int consecutive = _ NUM ; char last = pin . char At ( _ NUM ) ; for ( int i = _ NUM ; i < len ; i ++ ) { final char c = pin . char At ( i ) ; if ( last == c ) { consecutive ++ ; } else { consecutive = _ NUM ; } last = c ; if ( consecutive >= _ NUM ) { return _ BOOL ; } } return _ BOOL ; }
private static void generate Java Script Log Alert Close Window (  Writer writer ,  String message ) throws  IOException { writer . write ( _ STR + message + _ STR ) ; writer . write ( _ STR ) ; writer . write ( _ STR ) ; }
public  Tree <  String > extract Best Max Rule Parse1 ( int start , int end , int state ,  List <  String > sentence ) { int c State = maxc Child [ start ] [ end ] [ state ] ; if ( c State == - _ NUM ) { return extract Best Max Rule Parse2 ( start , end , state , sentence ) ; } else {  List <  Tree <  String > > child = new  Array List <  Tree <  String > > ( ) ; child . add ( extract Best Max Rule Parse2 ( start , end , c State , sentence ) ) ;  String state Str = (  String ) tag Numberer . object ( state ) ; if ( state Str . ends With ( _ STR ) ) state Str = state Str . substring ( _ NUM , state Str . length ( ) - _ NUM ) ; int intermediate Node = grammar . get Unary Intermediate ( ( short ) state , ( short ) c State ) ; if ( intermediate Node == _ NUM ) { } if ( intermediate Node > _ NUM ) {  List <  Tree <  String > > restored Child = new  Array List <  Tree <  String > > ( ) ;  String state Str2 = (  String ) tag Numberer . object ( intermediate Node ) ; if ( state Str2 . ends With ( _ STR ) ) state Str2 = state Str2 . substring ( _ NUM , state Str2 . length ( ) - _ NUM ) ; restored Child . add ( new  Tree <  String > ( state Str2 , child ) ) ; return new  Tree <  String > ( state Str , restored Child ) ; } return new  Tree <  String > ( state Str , child ) ; } }
protected void draw Center Text (  Canvas c ) {  Spannable String center Text = m Chart . get Center Text ( ) ; if ( m Chart . is Draw Center Text Enabled ( ) && center Text != null ) {  Point F center = m Chart . get Center Circle Box ( ) ; float inner Radius = m Chart . is Draw Hole Enabled ( ) && m Chart . is Hole Transparent ( ) ? m Chart . get Radius ( ) * ( m Chart . get Hole Radius ( ) / _ NUM ) : m Chart . get Radius ( ) ;  Rect F hole Rect = m Rect Buffer [ _ NUM ] ; hole Rect . left = center . x - inner Radius ; hole Rect . top = center . y - inner Radius ; hole Rect . right = center . x + inner Radius ; hole Rect . bottom = center . y + inner Radius ;  Rect F bounding Rect = m Rect Buffer [ _ NUM ] ; bounding Rect . set ( hole Rect ) ; float radius Percent = m Chart . get Center Text Radius Percent ( ) ; if ( radius Percent > _ NUM ) { bounding Rect . inset ( ( bounding Rect . width ( ) - bounding Rect . width ( ) * radius Percent ) / _ NUM , ( bounding Rect . height ( ) - bounding Rect . height ( ) * radius Percent ) / _ NUM ) ; } if ( ! center Text . equals ( m Center Text Last Value ) || ! bounding Rect . equals ( m Center Text Last Bounds ) ) { m Center Text Last Bounds . set ( bounding Rect ) ; m Center Text Last Value = center Text ; float width = m Center Text Last Bounds . width ( ) ; m Center Text Layout = new  Static Layout ( center Text , _ NUM , center Text . length ( ) , m Center Text Paint , ( int )  Math . max (  Math . ceil ( width ) , _ NUM ) ,  Layout .  Alignment .  ALIGN_ CENTER , _ NUM , _ NUM , _ BOOL ) ; } float layout Height = m Center Text Layout . get Height ( ) ; c . save ( ) ; c . translate ( bounding Rect . left , bounding Rect . top + ( bounding Rect . height ( ) - layout Height ) / _ NUM ) ; m Center Text Layout . draw ( c ) ; c . restore ( ) ; } }
public void start ( int conditions ) throws  IOException { print ( _ STR , new  String [ ] {  Integer . to Binary String ( conditions ) } ) ; printer . flush ( ) ; }
private static  Result Code register Error Result Code ( final int int Value , final  Localizable Message name , final  Enum result Code Enum ) { final  Result Code t = new  Result Code ( int Value , name , _ BOOL , result Code Enum ) ;  ELEMENTS . put ( int Value , t ) ; return t ; }
public void add All (  Exception Set other ) { exception Set . or ( other . exception Set ) ; explicit Set . or ( other . explicit Set ) ; size = count Bits ( exception Set ) ; common Supertype = null ; }
@  HLEUnimplemented @  HLEFunction ( nid = _ NUM , version = _ NUM ) public int sce Usb Cam Start Video ( ) { if ( ! setup Video ( ) ) { log . warn (  String . format ( _ STR ) ) ; } return _ NUM ; }
protected  Resource Loader License Locator ( final  Charset charset , final  String ... license Files ) { if ( license Files == null || license Files . length == _ NUM ) { throw new  Illegal Argument Exception ( _ STR ) ; } if ( charset == null ) { throw new  Null Pointer Exception ( _ STR ) ; } this . license Files = new  Array List <  String > (  Arrays . as List ( license Files ) ) ; this . charset = charset ; }
@  Inject public  Project Type Registry (  Set <  Project Type Def > types ) { project Types = new  Hash Map < > ( ) ; validated Data = new  Hash Map < > ( ) ; validate ( types ) ; for (  Project Type Def type : validated Data . values ( ) ) { try { init ( type ) ; } catch (  Project Type Constraint Exception e ) {  LOG . error ( e . get Message ( ) ) ; } } }
static public void add Notification Listener (  JMXConnector jmx Connector ,  Class < ? > mbean Interface ,  String mbean Name ,  Notification Listener notification Listener , boolean ignored ) throws  Instance Not Found Exception ,  Exception {  MBean Server Connection mbsc = jmx Connector . get MBean Server Connection ( ) ;  Object Name object Name = generate MBean Object Name ( mbean Interface . get Name ( ) , mbean Name ) ; mbsc . add Notification Listener ( object Name , notification Listener , null , null ) ; }
private void consume ( ) { consumer . subscribe ( topics ) ; while ( running . get ( ) ) { try {  Consumer Records records = consumer . poll ( poll Interval Ms ) ; if ( records == null ) { continue ; }  Iterator <  Consumer Record <  String ,  String > > iterator = records . iterator ( ) ; while ( iterator . has Next ( ) ) { send Message ( iterator . next ( ) ) ; } } catch (  Exception ex ) {  String error = _ STR ; logger . error ( error , ex ) ; bus . send (  Config Constants .  CONSUMER_ ERROR_ TOPIC , get Error String ( error , ex . get Message ( ) ) ) ; } } }
private byte [ ] read Raw Bytes Slow Path ( final int size ) throws  IOException { if ( size <= _ NUM ) { if ( size == _ NUM ) { return  Internal .  EMPTY_ BYTE_ ARRAY ; } else { throw  Invalid Protocol Buffer Exception . negative Size ( ) ; } } if ( total Bytes Retired + buffer Pos + size > current Limit ) { skip Raw Bytes ( current Limit - total Bytes Retired - buffer Pos ) ; throw  Invalid Protocol Buffer Exception . truncated Message ( ) ; } if ( size <  BUFFER_ SIZE ) { final byte [ ] bytes = new byte [ size ] ; int pos = buffer Size - buffer Pos ;  System . arraycopy ( buffer , buffer Pos , bytes , _ NUM , pos ) ; buffer Pos = buffer Size ; ensure Available ( size - pos ) ;  System . arraycopy ( buffer , _ NUM , bytes , pos , size - pos ) ; buffer Pos = size - pos ; return bytes ; } else { final int original Buffer Pos = buffer Pos ; final int original Buffer Size = buffer Size ; total Bytes Retired += buffer Size ; buffer Pos = _ NUM ; buffer Size = _ NUM ; int size Left = size - ( original Buffer Size - original Buffer Pos ) ; final  List < byte [ ] > chunks = new  Array List < byte [ ] > ( ) ; while ( size Left > _ NUM ) { final byte [ ] chunk = new byte [  Math . min ( size Left ,  BUFFER_ SIZE ) ] ; int pos = _ NUM ; while ( pos < chunk . length ) { final int n = ( input == null ) ? - _ NUM : input . read ( chunk , pos , chunk . length - pos ) ; if ( n == - _ NUM ) { throw  Invalid Protocol Buffer Exception . truncated Message ( ) ; } total Bytes Retired += n ; pos += n ; } size Left -= chunk . length ; chunks . add ( chunk ) ; } final byte [ ] bytes = new byte [ size ] ; int pos = original Buffer Size - original Buffer Pos ;  System . arraycopy ( buffer , original Buffer Pos , bytes , _ NUM , pos ) ; for ( final byte [ ] chunk : chunks ) {  System . arraycopy ( chunk , _ NUM , bytes , pos , chunk . length ) ; pos += chunk . length ; } return bytes ; } }
private void delete Attrs (  Svc Reg reg ,  Entry Rep entry , boolean check Dups ) {  Entry Class eclass = entry . eclass ; delete Instance ( eclass ) ;  Object [ ] fields = entry . fields ; if ( fields . length == _ NUM ) {  Array List regs = service By Empty Attr . get ( eclass ) ; if ( regs == null || ( check Dups && has Empty Attr ( reg , eclass ) ) ) return ; int idx = regs . index Of ( reg ) ; if ( idx >= _ NUM ) { regs . remove ( idx ) ; if ( regs . is Empty ( ) ) service By Empty Attr . remove ( eclass ) ; } return ; } for ( int fldidx = fields . length ; -- fldidx >= _ NUM ; ) { eclass = get Defining Class ( eclass , fldidx ) ;  Hash Map [ ] attr Maps = service By Attr . get ( eclass ) ; if ( attr Maps == null || attr Maps [ fldidx ] == null || ( check Dups && has Attr ( reg , eclass , fldidx , fields [ fldidx ] ) ) ) continue ;  Hash Map map = attr Maps [ fldidx ] ;  Object value = fields [ fldidx ] ;  Array List regs = (  Array List ) map . get ( value ) ; if ( regs == null ) continue ; int idx = regs . index Of ( reg ) ; if ( idx < _ NUM ) continue ; regs . remove ( idx ) ; if ( ! regs . is Empty ( ) ) continue ; map . remove ( value ) ; if ( ! map . is Empty ( ) ) continue ; attr Maps [ fldidx ] = null ; if ( all Null ( attr Maps ) ) service By Attr . remove ( eclass ) ; } }
public static boolean is Class Literal Possible (  Class Node class Node ) { return  Modifier . is Public ( class Node . get Modifiers ( ) ) ; }
private  Properties load Log File (  License license , boolean create ) {  Properties log = new  Properties ( ) ;  File log File = get Log File ( license ) ; try { if ( create && log File . create New File ( ) ) { logger . fine ( _ STR + log File . get Absolute Path ( ) ) ; } final  Input Stream in = new  File Input Stream ( log File ) ; try { log . load ( in ) ; } finally { in . close ( ) ; } } catch (  File Not Found Exception ex ) { if ( create ) { logger . log (  Level .  SEVERE , _ STR + log File . get Absolute Path ( ) , ex ) ; } else { logger . fine ( _ STR ) ; } } catch (  IOException ex ) { logger . log (  Level .  WARNING , _ STR + log File . get Absolute Path ( ) , ex ) ; } return log ; }
public  HTMLStrip Char Filter Factory (  Map <  String ,  String > args ) { super ( args ) ; escaped Tags = get Set ( args , _ STR ) ; if ( ! args . is Empty ( ) ) { throw new  Illegal Argument Exception ( _ STR + args ) ; } }
public static int update ( long id ,  V v ) {  String passwd = (  String ) v . value ( _ STR ) ; if ( !  X . is Empty ( passwd ) ) { passwd = encrypt ( passwd ) ; v . set ( _ STR , passwd , _ BOOL ) ; } else { v . remove ( _ STR ) ; } return  Helper . update ( id , v . set ( _ STR ,  System . current Time Millis ( ) ) ,  User . class ) ; }
@  Override public  String to String ( ) {  String Buffer text = new  String Buffer ( ) ; text . append ( _ STR + attributes To String ( ) + _ STR ) ; text . append ( _ STR + get Inst Nums ( ) ) ; return text . to String ( ) ; }
public boolean is Safe Mode ( ) { return this . safe Mode ; }
public void test_get Put Byte Array With Offset And Length ( ) { final int size = _ NUM ; final  IData Record buf = new  Fixed Byte Array Buffer ( size ) ; assert Equals ( ( byte ) _ NUM , buf . get Byte ( _ NUM ) ) ; assert Equals ( ( byte ) _ NUM , buf . get Byte ( size - _ NUM ) ) ; final int pos = _ NUM ; for ( int i = _ NUM ; i <  LIMIT ; i ++ ) { final byte [ ] expected = new byte [ r . next Int ( size - _ NUM ) ] ; final int off = ( expected . length / _ NUM == _ NUM ? _ NUM : r . next Int ( expected . length / _ NUM ) ) ; final int len = ( expected . length == _ NUM ? _ NUM : r . next Int ( expected . length - off ) ) ; r . next Bytes ( expected ) ; buf . put ( pos , expected , off , len ) ; assert Equals ( _ NUM ,  Bytes Util . compare Bytes With Len And Offset ( off , len , expected , pos , len , buf . array ( ) ) ) ; final int dstoff = r . next Int ( _ NUM ) ; final byte [ ] actual = new byte [ expected . length + dstoff ] ; buf . get ( pos , actual , dstoff , expected . length ) ; assert Equals ( _ NUM ,  Bytes Util . compare Bytes With Len And Offset ( off , len , expected , dstoff , len , actual ) ) ; } assert Equals ( ( byte ) _ NUM , buf . get Byte ( _ NUM ) ) ; assert Equals ( ( byte ) _ NUM , buf . get Byte ( pos + size - _ NUM ) ) ; }
public void add Last Item (  M model ) { add Item ( m Datas . size ( ) , model ) ; }
static boolean has Localized Messages ( ) { return  GUIMediator . is English Locale ( ) || !  FIRST_ MESSAGE . equals (  I18n . tr (  FIRST_ MESSAGE ) ) ; }
public static  Docker Image from Image Name (  String image Name ) { image Name = prepare ( image Name ) ;  String [ ] parts = image Name . split (  SECTION_ SEPARATOR ) ; switch ( parts . length ) { case _ NUM : return from Parts ( null , null , parts [ _ NUM ] ) ; case _ NUM : if ( is Valid Namespace ( parts [ _ NUM ] ) ) { return from Parts ( null , parts [ _ NUM ] , parts [ _ NUM ] ) ; } else { return from Parts ( parts [ _ NUM ] , null , parts [ _ NUM ] ) ; } case _ NUM : return from Parts ( parts [ _ NUM ] , parts [ _ NUM ] , parts [ _ NUM ] ) ; default : throw new  Illegal Argument Exception ( _ STR + image Name ) ; } }
public synchronized void listen ( final  Set <  Notification Channel > channel Names ) { m_channels . add All ( channel Names ) ; }
private void display Non Verbose (  Console Application app ,  String category Name ,  String type Name ,  Tag tag ,  Set <  String > property Names ) { if ( ! app . is Script Friendly ( ) ) { display Property Option Key ( app ) ; app . println ( ) ; app . println ( ) ; }  Table Builder builder = new  Table Builder ( ) ; builder . append Heading (  INFO_ DSCFG_ HEADING_ COMPONENT_ NAME . get ( ) ) ; builder . append Heading (  INFO_ DSCFG_ HEADING_ COMPONENT_ TYPE . get ( ) ) ; builder . append Heading (  INFO_ DSCFG_ HEADING_ PROPERTY_ NAME . get ( ) ) ; builder . append Heading (  INFO_ DSCFG_ HEADING_ PROPERTY_ OPTIONS . get ( ) ) ; builder . append Heading (  INFO_ DSCFG_ HEADING_ PROPERTY_ SYNTAX . get ( ) ) ; builder . add Sort Key ( _ NUM ) ; builder . add Sort Key ( _ NUM ) ; builder . add Sort Key ( _ NUM ) ; for (  String category : category Map . key Set ( ) ) { if ( category Name != null && ! category Name . equals ( category ) ) { continue ; }  Map <  String ,  Abstract Managed Object Definition < ? , ? > > sub Types = category Map . get ( category ) ; for (  String type : sub Types . key Set ( ) ) { if ( type Name != null && ! type Name . equals ( type ) ) { continue ; }  Abstract Managed Object Definition < ? , ? > mod = sub Types . get ( type ) ; if ( cannot Display ( app , mod , tag ) ) { continue ; }  Set <  Property Definition < ? > > pds = get Property Definitions ( mod ) ; for (  Property Definition < ? > pd : pds ) { if ( cannot Display ( app , pd , property Names ) ) { continue ; } builder . start Row ( ) ; builder . append Cell ( category ) ; builder . append Cell ( type ) ; builder . append Cell ( pd . get Name ( ) ) ; builder . append Cell ( get Property Option Summary ( pd ) ) ;  Property Definition Usage Builder v = new  Property Definition Usage Builder ( _ BOOL ) ; builder . append Cell ( v . get Usage ( pd ) ) ; } } }  Table Printer printer ; if ( app . is Script Friendly ( ) ) { printer = create Script Friendly Table Printer ( app . get Output Stream ( ) ) ; } else { printer = new  Text Table Printer ( app . get Output Stream ( ) ) ; } builder . print ( printer ) ; }
@  Override default  Completable Future <  Integer > sum Int ( final  To Int Function < ? super  T > fn ) { return  Completable Future . supply Async ( null , get Exec ( ) ) ; }
public void test Write3 ( ) throws  Exception { byte [ ] data = new byte [ ] { - _ NUM , - _ NUM , - _ NUM , - _ NUM , - _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM } ;  Test Output Stream tos = new  Test Output Stream ( ) ;  Cipher Output Stream cos = new  Cipher Output Stream ( tos , new  Null Cipher ( ) ) ; for ( int i = _ NUM ; i < data . length ; i ++ ) { cos . write ( data , i , _ NUM ) ; } cos . flush ( ) ; byte [ ] result = tos . to Byte Array ( ) ; if ( !  Arrays . equals ( result , data ) ) { fail ( _ STR ) ; } }
private  Document parse ( final  String data ) { if ( doc Builder == null || data == null ) { return null ; }  Document document = null ; try {  String buf =  BEGINPART + data +  ENDPART ;  Input Source input Source = new  Input Source ( new  String Reader ( buf ) ) ; document = doc Builder . parse ( input Source ) ; } catch (  Exception e ) { e . print Stack Trace ( ) ; } return document ; }
public boolean is Production Journal (  Set <  String > production Copies ,  Volume volume ) { for (  String production Copy : production Copies ) { if ( production Copy . equals Ignore Case ( volume . get Rp Copy Name ( ) ) ) { return _ BOOL ; } } return _ BOOL ; }
private void test Pound Symbol In Column Name ( ) throws  SQLException { delete Db ( _ STR ) ;  Connection conn = get Connection ( _ STR ) ;  Statement stat = conn . create Statement ( ) ; stat . execute ( _ STR ) ; stat . execute ( _ STR ) ; assert Result ( _ STR , stat , _ STR ) ; conn . close ( ) ; }
public static  String decode ( final  String escaped ) throws  URIException { try { final byte [ ] rawdata =  URLCodec . decode Url (  Encoding Util . get Ascii Bytes ( escaped ) ) ; return  Encoding Util . get String ( rawdata ,  URI . get Default Protocol Charset ( ) ) ; } catch ( final  Decoder Exception e ) { throw new  URIException ( e . get Message ( ) ) ; } }
void wait Before Next Poll ( int polling Interval ) throws  Interrupted Exception { synchronized ( this ) { wait ( polling Interval ) ; } if ( ! poll Outstanding ) { return ; } log . debug ( _ STR ) ; for ( int i = _ NUM ; i < _ NUM ; i ++ ) { synchronized ( this ) { wait ( polling Interval / _ NUM ) ; } log . debug ( _ STR ) ; if ( ! poll Outstanding ) { return ; } } }
private void shift Mapping Vector Tokens Left ( int line Num , int start Col , int shift ) { boolean last Was Begin TLAToken = _ BOOL ; int last Begin TLATok Col = - _ NUM ;  Vector line = (  Vector ) mapping Vector . element At ( line Num ) ; for ( int i = _ NUM ; i < line . size ( ) ; i ++ ) {  Mapping Object obj = (  Mapping Object ) line . element At ( i ) ; if ( obj . get Type ( ) ==  Mapping Object .  BEGIN_ TLATOKEN ) {  Mapping Object .  Begin TLAToken tobj = (  Mapping Object .  Begin TLAToken ) obj ; int col = tobj . get Column ( ) ; if ( col >= start Col ) { tobj . set Column ( col - shift ) ; } last Was Begin TLAToken = _ BOOL ; last Begin TLATok Col = tobj . get Column ( ) ; } else { if ( obj . get Type ( ) ==  Mapping Object .  END_ TLATOKEN ) {  Mapping Object .  End TLAToken tobj = (  Mapping Object .  End TLAToken ) obj ; int col = tobj . get Column ( ) ; if ( col >= start Col ) { tobj . set Column ( col - shift ) ; } if ( last Was Begin TLAToken && tobj . get Column ( ) <= last Begin TLATok Col ) {  Pcal Debug .  Report Bug ( _ STR ) ; } } else if ( obj . get Type ( ) ==  Mapping Object .  SOURCE_ TOKEN ) {  Mapping Object .  Source Token tobj = (  Mapping Object .  Source Token ) obj ; int col = tobj . get Begin Column ( ) ; if ( col >= start Col ) { tobj . set Begin Column ( col - shift ) ; } col = tobj . get End Column ( ) ; if ( col >= start Col ) { tobj . set End Column ( col - shift ) ; } last Was Begin TLAToken = _ BOOL ; } } } }
protected  Dimension compute Lengths (  String anno Text ) {  String [ ] lines =  Util . split Lines ( anno Text ) ; int line Length = _ NUM ; for (  String line : lines ) { if ( line . length ( ) > line Length ) line Length = line . length ( ) ; } return new  Dimension ( line Length + _ NUM , lines . length + _ NUM ) ; }
Import Note Builder add Message (  Import Note Message .  Type type ,  String message ) { if ( !  Strings . is Null Or Empty ( message ) ) { messages . add ( new  Import Note Message ( type , message ) ) ; } return this ; }
public static  List <  String > as String List (  Collection < ? extends  Object > objects ) {  List <  String > list = new  Array List < > ( ) ; for (  Object object : objects ) { list . add (  String . value Of ( object ) ) ; } return list ; }
public <  E extends  T >  E min (  Iterable <  E > iterable ) {  Iterator <  E > iterator = iterable . iterator ( ) ;  E min So Far = iterator . next ( ) ; while ( iterator . has Next ( ) ) { min So Far = min ( min So Far , iterator . next ( ) ) ; } return min So Far ; }
public synchronized int read ( byte b [ ] , int off , int len ) throws  IOException { if ( len <= _ NUM ) return _ NUM ; int more Space ; synchronized ( lock ) { if ( pos >= present ) pos = present = _ NUM ; else if ( pos >= water Mark ) {  System . arraycopy ( buffer , pos , buffer , _ NUM , present - pos ) ; present -= pos ; pos = _ NUM ; } int free Space = buffer . length - present ; more Space =  Math . max ( free Space - requested , _ NUM ) ; } if ( more Space > _ NUM ) manager . send Request ( info , more Space ) ; synchronized ( lock ) { requested += more Space ; while ( ( pos >= present ) && ! disconnected ) { try { lock . wait ( ) ; } catch (  Interrupted Exception e ) { } } if ( disconnected && pos >= present ) return - _ NUM ; int available = present - pos ; if ( len < available ) {  System . arraycopy ( buffer , pos , b , off , len ) ; pos += len ; return len ; } else {  System . arraycopy ( buffer , pos , b , off , available ) ; pos = present = _ NUM ; return available ; } } }
public static  List <  Item Stack > consolidate Item Stacks (  List <  Item Stack > input Stacks ) {  List <  Item Stack > output Stacks = new  Array List <  Item Stack > ( ) ; for (  Item Stack source IS : input Stacks ) { boolean b Found = _ BOOL ; for (  Item Stack dest IS : output Stacks ) { if ( dest IS != null && source IS != null && item Stack Ingredients Match ( dest IS , source IS ) ) { b Found = _ BOOL ; dest IS . stack Size += source IS . stack Size ; } } if ( ! b Found ) output Stacks . add ( source IS . copy ( ) ) ; } return output Stacks ; }
public static int how Many Days Old ( long time ) { return ( int ) ( (  System . current Time Millis ( ) - time ) /  Date Utils .  DAY_ IN_ MILLIS ) ; }
protected  Character is WFXMLChar (  String chardata ) {  Character ref Invalid Char ; if ( chardata == null || ( chardata . length ( ) == _ NUM ) ) { return null ; } char [ ] dataarray = chardata . to Char Array ( ) ; int datalength = dataarray . length ; if ( f Is XMLVersion11 ) { int i = _ NUM ; while ( i < datalength ) { if (  XML11 Char . is XML11 Invalid ( dataarray [ i ++ ] ) ) { char ch = dataarray [ i - _ NUM ] ; if (  XMLChar . is High Surrogate ( ch ) && i < datalength ) { char ch2 = dataarray [ i ++ ] ; if (  XMLChar . is Low Surrogate ( ch2 ) &&  XMLChar . is Supplemental (  XMLChar . supplemental ( ch , ch2 ) ) ) { continue ; } } ref Invalid Char = new  Character ( ch ) ; return ref Invalid Char ; } } } else { int i = _ NUM ; while ( i < datalength ) { if (  XMLChar . is Invalid ( dataarray [ i ++ ] ) ) { char ch = dataarray [ i - _ NUM ] ; if (  XMLChar . is High Surrogate ( ch ) && i < datalength ) { char ch2 = dataarray [ i ++ ] ; if (  XMLChar . is Low Surrogate ( ch2 ) &&  XMLChar . is Supplemental (  XMLChar . supplemental ( ch , ch2 ) ) ) { continue ; } } ref Invalid Char = new  Character ( ch ) ; return ref Invalid Char ; } } } return null ; }
public void test Zero Zero ( ) {  String num A = _ STR ;  String num B = _ STR ;  String res = _ STR ;  Big Integer a Number = new  Big Integer ( num A ) ;  Big Integer b Number = new  Big Integer ( num B ) ;  Big Integer result = a Number . xor ( b Number ) ; assert True ( res . equals ( result . to String ( ) ) ) ; }
public final  Parallel Flux <  T > do On Next (  Consumer < ? super  T > on Next ) {  Objects . require Non Null ( on Next , _ STR ) ; return do On Signal ( this , on Next , null , null , null , null , null , null , null ) ; }
protected void add Missing (  Instances data , int level , boolean predictor Missing , boolean class Missing ) { int class Index = data . class Index ( ) ;  Random random = new  Random ( _ NUM ) ; for ( int i = _ NUM ; i < data . num Instances ( ) ; i ++ ) {  Instance current = data . instance ( i ) ; for ( int j = _ NUM ; j < data . num Attributes ( ) ; j ++ ) { if ( ( ( j == class Index ) && class Missing ) || ( ( j != class Index ) && predictor Missing ) ) { if (  Math . abs ( random . next Int ( ) ) % _ NUM < level ) current . set Missing ( j ) ; } } } }
public <  T extends  Data Object > void insert In Batches (  List <  T > records , int partition Size ,  Db Client db Client ,  String type ) {  List <  List <  T > > volume_partitions =  Lists . partition ( records , partition Size ) ; for (  List <  T > partition : volume_partitions ) { try { db Client . create Object ( partition ) ; _log . info ( _ STR , partition . size ( ) , type ) ; } catch (  Database Exception e ) { _log . error ( _ STR , type , e ) ; } } }
public void modify (  SSOToken token ,  String obj Name ,  Modification Item [ ] mods ) throws  SMSException ,  SSOException { if ( ( obj Name == null ) || ( obj Name . length ( ) == _ NUM ) || ( mods == null ) || ( mods . length == _ NUM ) ) { throw new  Illegal Argument Exception ( _ STR + _ STR ) ; } m RWLock . read Request ( ) ; try { if ( ! root . is Exists ( m Root Dir , obj Name ) ) {  String errmsg = _ STR + obj Name + _ STR ; m Debug . error ( errmsg ) ; throw new  Service Not Found Exception ( errmsg ) ; } } finally { m RWLock . read Done ( ) ; } m RWLock . write Request ( ) ; try {  SMSFlat File Tree Node node = root . get Child ( obj Name ) ; if ( node == null ) {  String errmsg = _ STR + obj Name + _ STR ; m Debug . error ( errmsg ) ; throw new  Service Not Found Exception ( errmsg ) ; }  String filepath = node . get Attribute Filename ( m Root Dir ) ; if ( filepath == null ) {  String errmsg = _ STR + obj Name + _ STR ; m Debug . error ( errmsg ) ; throw new  Service Not Found Exception ( errmsg ) ; }  File filehandle = new  File ( filepath ) ; if ( ! filehandle . is File ( ) ) {  String errmsg = _ STR + _ STR + obj Name + _ STR ; m Debug . error ( errmsg ) ; throw new  Service Not Found Exception ( errmsg ) ; }  Properties props = load Properties ( filehandle , obj Name ) ; boolean has Sun Xml Key Value = props . get Property (  SMSEntry .  ATTR_ XML_ KEYVAL ) != null ; for ( int i = _ NUM ; i < mods . length ; i ++ ) { modify Values ( obj Name , mods [ i ] , props ) ; } save Properties ( props , filehandle , obj Name ) ;  String new Sun XMLKey Value = props . get Property (  SMSEntry .  ATTR_ XML_ KEYVAL ) ; if ( new Sun XMLKey Value != null ) {  Set xml Key Vals = to Val Set (  SMSEntry .  ATTR_ XML_ KEYVAL , new Sun XMLKey Value ) ; if ( ! has Sun Xml Key Value ) { delete Sun Xml Key Val Files ( node ) ; } create Sun Xml Key Val Files ( node , xml Key Vals ) ; save Directory Tree ( ) ; } } finally { m RWLock . write Done ( ) ; } }
public void remove On Tab Selected Listener (  On Tab Selected Listener listener ) { if ( listener != null ) { m Listeners . remove ( listener ) ; } }
public  Connect Uri Manager (  List <  String > connect Uri ) throws  THLException { this . uri List = connect Uri ; if ( connect Uri . size ( ) == _ NUM ) { throw new  THLException ( _ STR ) ; } }
private void add Volumes To Parking Storage Group (  Storage System storage ,  String policy Name ,  Set <  String > volume Device Ids ) throws  Exception {  String [ ] tokens = policy Name . split (  Constants .  SMIS_ PLUS_ REGEX ) ;  CIMObject Path group Path = _helper . get Volume Group Based On SLO ( storage , storage , tokens [ _ NUM ] , tokens [ _ NUM ] , tokens [ _ NUM ] ) ; if ( group Path == null ) { group Path = _helper . create Volume Group Based On SLO ( storage , storage , tokens [ _ NUM ] , tokens [ _ NUM ] , tokens [ _ NUM ] ) ; }  CIMArgument [ ] in Args = _helper . get Add Volumes To Masking Group Input Arguments ( storage , group Path , volume Device Ids ) ;  CIMArgument [ ] out Args = new  CIMArgument [ _ NUM ] ;  Smis Job add Volumes To SGJob = new  Smis Synch Sub Task Job ( null , storage . get Id ( ) ,  Smis Constants .  ADD_ MEMBERS ) ; _helper . invoke Method Synchronously ( storage , _cim Path . get Controller Config Svc Path ( storage ) , _ STR , in Args , out Args , add Volumes To SGJob ) ; }
public boolean export Pkcs8 ( ) { return jrb Pkcs8 . is Selected ( ) ; }
public  Number Tick (  Number number ,  String label ,  Text Anchor text Anchor ,  Text Anchor rotation Anchor , double angle ) { super ( number . double Value ( ) , label , text Anchor , rotation Anchor , angle ) ; this . number = number ; }
private boolean is Stoppable ( ) { return ( is Running ( ) && get Cache ( ) != null ) ; }
private void log (  String message ,  String level ,  String level Color ,  Print Stream ps ) {  String Builder builder = new  String Builder ( ) ; if ( ! level . equals ( _ STR ) ) builder . append ( get Prefix ( level , level Color ) ) ; builder . append ( message ) ;  String ts = builder . to String ( ) ; ps . println ( ts ) ; for (  Log Handler hand : handlers ) hand . on Log ( level , message , ts , this ) ; }
public void add Gossip Member (  Gossip Member member ) { gossip Members . add ( member ) ; }
public static boolean is Public ( int mod ) { return  Modifier . is Public ( mod ) ; }
public  JSONBuffer append String (  Object cont ) { if ( stack . empty ( ) || stack . peek ( ) !=  Operand .  ARRAY ) { throw new  JSONException ( _ STR ) ; } add Quoted String ( cont ) ; add Separator ( ) ; return this ; }
public static void delete User From Authentication Info (  Authentication Info authentication Info ) throws  Server Runtime Exception {  String username = authentication Info . get Username ( ) ;  String password File Location = authentication Info . get Password File Location ( ) ; try {  Properties Configuration props = new  Properties Configuration ( password File Location ) ;  String username In File = props . get String ( username ) ; if ( username In File == null ) { throw new  Server Runtime Exception (  Message Format . format ( _ STR , username ) ) ; } props . clear Property ( username ) ; props . save ( ) ; } catch ( org . apache . commons . configuration .  Configuration Exception ce ) { logger . error ( _ STR + authentication Info . get Password File Location ( ) , ce ) ; throw new  Server Runtime Exception ( _ STR + ce . get Message ( ) ) ; } }
public void error (  Level level ,  String message Id ,  String data [ ] ,  Object session ) throws  Log Exception { error ( level , message Id , data , session , null ) ; }
public synchronized void remove (  IAudio Processor processor ) { processors . remove ( processor ) ; build Final Processor ( ) ; }
private int end Recover Animation (  View Holder view Holder , boolean override ) { final int recover Anim Size = m Recover Animations . size ( ) ; for ( int i = recover Anim Size - _ NUM ; i >= _ NUM ; i -- ) { final  Recover Animation anim = m Recover Animations . get ( i ) ; if ( anim . m View Holder == view Holder ) { anim . m Overridden |= override ; if ( ! anim . m Ended ) { anim . cancel ( ) ; } m Recover Animations . remove ( i ) ; return anim . m Animation Type ; } } return _ NUM ; }
private boolean is Method Contained (  Method m ,  List <  Method > wrapper Methods ) {  String name = m . get Name ( ) ;  Class < ? > [ ] param Types = m . get Parameter Types ( ) ;  Class < ? > return Type = m . get Return Type ( ) ; for (  Method wm : wrapper Methods ) { if ( name . equals ( wm . get Name ( ) ) &&  Arrays . equals ( param Types , wm . get Parameter Types ( ) ) && return Type == wm . get Return Type ( ) ) { return _ BOOL ; } } return _ BOOL ; }
void update Pressed (  Action Event e , boolean new Route ) {  String u Name = _user Name . get Text ( ) ;  Route g = check Names OK ( ) ; if ( g == null ) { return ; } g . set User Name ( u Name ) ; g . clear Output Turnouts ( ) ; g . clear Output Sensors ( ) ; g . clear Route Sensors ( ) ; initialize Included List ( ) ; set Turnout Information ( g ) ; set Sensor Information ( g ) ; g . set Output Script Name ( script File . get Text ( ) ) ; g . set Output Sound Name ( sound File . get Text ( ) ) ; set Control Information ( g ) ; cur Route = g ; finish Update ( ) ; status1 . set Text ( ( new Route ?  Bundle . get Message ( _ STR ) :  Bundle . get Message ( _ STR ) ) + _ STR + u Name + _ STR + _included Turnout List . size ( ) + _ STR +  Bundle . get Message ( _ STR ) + _ STR + _included Sensor List . size ( ) + _ STR +  Bundle . get Message ( _ STR ) + _ STR ) ; }
public  String to String ( ) { return m_ Attributes . to String ( ) ; }
private static void check For XStream ( ) { try {  Class . for Name ( _ STR ) ; m_ Present = _ BOOL ; } catch (  Exception e ) { m_ Present = _ BOOL ; } }
@  Target Api (  Build .  VERSION_ CODES .  GINGERBREAD_ MR1 ) private  Response <  Bitmap Drawable > do Parse (  Network Response response ) { byte [ ] data = response . data ;  Bitmap Factory .  Options decode Options = new  Bitmap Factory .  Options ( ) ; decode Options . in Input Shareable = _ BOOL ; decode Options . in Purgeable = _ BOOL ; decode Options . in Preferred Config = m Decode Config ;  Bitmap bitmap ; if ( m Max Width == _ NUM && m Max Height == _ NUM ) { bitmap =  Bitmap Factory . decode Byte Array ( data , _ NUM , data . length , decode Options ) ; } else { decode Options . in Just Decode Bounds = _ BOOL ;  Bitmap Factory . decode Byte Array ( data , _ NUM , data . length , decode Options ) ; int actual Width = decode Options . out Width ; int actual Height = decode Options . out Height ; int desired Width = get Resized Dimension ( m Max Width , m Max Height , actual Width , actual Height ) ; int desired Height = get Resized Dimension ( m Max Height , m Max Width , actual Height , actual Width ) ; decode Options . in Just Decode Bounds = _ BOOL ; if (  Utils . has Gingerbread MR1 ( ) ) { decode Options . in Prefer Quality Over Speed =  PREFER_ QUALITY_ OVER_ SPEED ; } decode Options . in Sample Size =  Image Utils . find Best Sample Size ( actual Width , actual Height , desired Width , desired Height ) ;  Bitmap temp Bitmap =  Bitmap Factory . decode Byte Array ( data , _ NUM , data . length , decode Options ) ; if ( temp Bitmap != null && ( temp Bitmap . get Width ( ) > desired Width || temp Bitmap . get Height ( ) > desired Height ) ) { bitmap =  Bitmap . create Scaled Bitmap ( temp Bitmap , desired Width , desired Height , _ BOOL ) ; temp Bitmap . recycle ( ) ; } else { bitmap = temp Bitmap ; } } if ( bitmap == null ) { return  Response . error ( new  Parse Error ( response ) ) ; } else {  Bitmap Drawable drawable ; if (  Utils . has Honeycomb ( ) ) { drawable = new  Bitmap Drawable ( m Resources , bitmap ) ; } else { drawable = new  Recycling Bitmap Drawable ( m Resources , bitmap ) ; } return  Response . success ( drawable ,  Http Header Parser . parse Cache Headers ( response ) ) ; } }
public double evaluate (  Vector Instance x , double [ ] y ) throws  Exception {  Vector Instance diff = x . subtract ( y ) ; double result = - m_gamma * diff . dot Product ( diff ) ; return  Math . exp ( result ) ; }
@  Override public int batch Size ( ) { return batch Size ; }
public void clear ( ) { m Attached Scrap . clear ( ) ; recycle And Clear Cached Views ( ) ; }
public  FPSTexture View add Child At ( int location , @  Non Null  Display Base display Base ) { display Base . set Up ( m Fps ) ; m Display List . add ( location , display Base ) ; return this ; }
private double [ ] prune EM (  Tree tree ,  Node Ref node ,  Colour Change Matrix mm ,  Meta Population mp ) { double [ ] p = new double [ colour Count ] ; if ( tree . is External ( node ) ) { p [ get Colour ( node ) ] = _ NUM ; } else {  Node Ref left Child = tree . get Child ( node , _ NUM ) ;  Node Ref right Child = tree . get Child ( node , _ NUM ) ; double [ ] left = prune EM ( tree , left Child , mm , mp ) ; double [ ] right = prune EM ( tree , right Child , mm , mp ) ; double [ ] left Branch Partials = prune Branch EM ( mm , left , node , left Child , tree , mp ) ; double [ ] right Branch Partials = prune Branch EM ( mm , right , node , right Child , tree , mp ) ; double maxp = _ NUM ; for ( int i = _ NUM ; i < colour Count ; i ++ ) { p [ i ] = left Branch Partials [ i ] * right Branch Partials [ i ] ; if ( use Node Bias ) { p [ i ] *= mm . get Equilibrium ( i ) / mp . get Demographic ( tree . get Node Height ( node ) - tiny Time , i ) ; } if ( p [ i ] > maxp ) { maxp = p [ i ] ; } } if ( maxp < _ NUM ) { for ( int i = _ NUM ; i < colour Count ; i ++ ) { p [ i ] *= _ NUM ; } log Node Partials Rescaling -=  Math . log ( _ NUM ) ; } } node Partials [ node . get Number ( ) ] = p ; if ( debug Node Partials ) { pretty Print ( _ STR + node . get Number ( ) + _ STR , p ) ; } return p ; }
public static int min Path Sum ( int [ ] [ ] grid ) { if ( grid == null || grid . length == _ NUM ) return _ NUM ; int m = grid . length ; int n = grid [ _ NUM ] . length ; int [ ] row Sum = new int [ n ] ; row Sum [ _ NUM ] = grid [ _ NUM ] [ _ NUM ] ; for ( int col = _ NUM ; col < n ; col ++ ) row Sum [ col ] = row Sum [ col - _ NUM ] + grid [ _ NUM ] [ col ] ; for ( int row = _ NUM ; row < m ; row ++ ) { row Sum [ _ NUM ] += grid [ row ] [ _ NUM ] ; for ( int col = _ NUM ; col < n ; col ++ ) { row Sum [ col ] =  Math . min ( row Sum [ col - _ NUM ] , row Sum [ col ] ) + grid [ row ] [ col ] ; } } return row Sum [ n - _ NUM ] ; }
public  Time (  Date time ) {  Simple Time Zone tz = new  Simple Time Zone ( _ NUM , _ STR ) ;  Simple Date Format date F = new  Simple Date Format ( _ STR ) ; date F . set Time Zone ( tz ) ;  String d = date F . format ( time ) + _ STR ; int year =  Integer . parse Int ( d . substring ( _ NUM , _ NUM ) ) ; if ( year < _ NUM || year > _ NUM ) { this . time = new  DERGeneralized Time ( d ) ; } else { this . time = new  DERUTCTime ( d . substring ( _ NUM ) ) ; } }
public  DCheck Update (  JFrame parent ) { super ( parent ,  Dialog .  Modality Type .  DOCUMENT_ MODAL ) ; init Components ( ) ; }
public static  Automaton minimize Simple (  Automaton a ) {  Set <  Integer > initial Set = new  Hash Set <  Integer > ( ) ; a = determinize Simple (  Operations . reverse ( a , initial Set ) , initial Set ) ; initial Set . clear ( ) ; a = determinize Simple (  Operations . reverse ( a , initial Set ) , initial Set ) ; return a ; }
@  Override public boolean equals (  Object o ) { if ( this == o ) return _ BOOL ; if ( o == null || get Class ( ) != o . get Class ( ) ) return _ BOOL ;  Abstract Item < ? , ? > that = (  Abstract Item < ? , ? > ) o ; return m Identifier == that . m Identifier ; }
public void add Column (  Column column ) { if ( column != null ) { columns . add ( column ) ; } }
private boolean check For Na Ns (  Number Vector vec ) { for ( int i = _ NUM , d = vec . get Dimensionality ( ) ; i < d ; i ++ ) { double v = vec . double Value ( i ) ; if ( v != v ) { return _ BOOL ; } } return _ BOOL ; }
public static void fill (  String Builder strb , int offset ) { while ( strb . length ( ) < offset ) strb . append ( _ STR ) ; }
public void open For Write ( ) throws  Event Exception {  File f = new  File (  Config Utils . get Initial Property Expanded ( m_address . get Pathname ( ) ) ) ; try { if ( ! f . exists ( ) ) { f . create New File ( ) ; } else {  LOGGER . info ( _ STR + m_address . get Pathname ( ) ) ; } } catch (  IOException ioe ) { throw new  Event Exception ( _ STR + m_address . get Pathname ( ) + _ STR + ioe ) ; } try { m_fos = new  File Output Stream ( f , _ BOOL ) ; } catch (  File Not Found Exception fnfe ) { throw new  Event Exception ( _ STR + m_address . get Pathname ( ) + _ STR + fnfe ) ; } }
@  Override public double calculate_ K ( int [ ] x_index , double [ ] x_att , int [ ] y_index , double [ ] y_att ) { return (  Math . exp ( gamma * norm2 ( x_index , x_att , y_index , y_att ) ) ) ; }
@  Override public void close ( ) throws  IOException {  Throwable thrown = null ; try { flush ( ) ; } catch (  Throwable e ) { thrown = e ; } try { out . close ( ) ; } catch (  Throwable e ) { if ( thrown == null ) { thrown = e ; } } }
public final double cos ( ) { return  Math . cos ( this . radians ) ; }
public static double ss Error ( double [ ] predicted Values , double [ ] target Attribute ) { double ret = _ NUM ; for ( int i = _ NUM ; i < predicted Values . length ; i ++ ) { ret +=  Math . pow ( target Attribute [ i ] - predicted Values [ i ] , _ NUM ) ; } return ret ; }
public int size ( ) { return prefixes . size ( ) ; }
public static  String timestamp (  Date Time ts ) { return  Long . to String ( ts . get Millis ( ) / _ NUM ) ; }
public  String consume (  String name , boolean required ) throws  Parse Exception { if ( name == null ) { if ( content == null && required ) { throw new  Parse Exception (  Core Error Domain .  ERR . missing Required Content ) ; } content Consumed = _ BOOL ; return content ; }  String value = attrs . get ( name ) ; if ( value == null ) { if ( required ) {  Parse Exception pe = new  Parse Exception (  Core Error Domain .  ERR . missing Attribute ) ; pe . set Internal Reason ( _ STR + name + _ STR ) ; throw pe ; } return null ; } attrs . remove ( name ) ; return value ; }
public int copy ( byte [ ] bytes , int at ) {  System . arraycopy ( this . bytes , _ NUM , bytes , at , this . length ) ; return at + this . length ; }
public void import Key (  ECKey key ) { lock . lock ( ) ; try { check Key Encryption State Matches ( key ) ; if ( has Key ( key ) ) return ; import Key Locked ( key ) ; queue On Keys Added (  Immutable List . of ( key ) ) ; } finally { lock . unlock ( ) ; } }
public  Connection Group Tree (  User Context user Context ,  Connection Group root ,  List <  Object Permission .  Type > permissions ) throws  Guacamole Exception { this . root APIGroup = new  APIConnection Group ( root ) ; retrieved Groups . put ( root . get Identifier ( ) , this . root APIGroup ) ;  User self = user Context . self ( ) ; this . connection Permissions = self . get Connection Permissions ( ) ; this . sharing Profile Permissions = self . get Sharing Profile Permissions ( ) ; this . connection Directory = user Context . get Connection Directory ( ) ; this . connection Group Directory = user Context . get Connection Group Directory ( ) ; this . sharing Profile Directory = user Context . get Sharing Profile Directory ( ) ; add Connection Group Descendants (  Collections . singleton ( root ) , permissions ) ; }
private boolean contains Single Metric (  Buffered Reader reader ) throws  Format Parse Exception { try { reader . mark ( _ NUM ) ; char first Char = ( char ) reader . read ( ) ; reader . reset ( ) ; return first Char == _ STR ; } catch (  IOException e ) { throw new  Format Parse Exception ( _ STR , e ) ; } }
public void add Button Pressed Listener (  Field Config String Button Interface listener ) { if ( button Pressed Listener List == null ) { button Pressed Listener List = new  Array List <  Field Config String Button Interface > ( ) ; } button Pressed Listener List . add ( listener ) ; }
private void read Service Config ( ) throws  SSOException ,  SMSException { if ( debug . message Enabled ( ) ) { debug . message ( _ STR ) ; }  SSOToken internal Token = (  SSOToken )  Access Controller . do Privileged (  Admin Token Action . get Instance ( ) ) ; service Schema Manager = new  Service Schema Manager (  G11 N_ SETTINGS_ SERVICE_ NAME , internal Token ) ;  Service Schema gsc = service Schema Manager . get Global Schema ( ) ; raw Service Data = gsc . get Attribute Defaults ( ) ; }
public void refresh Preferences (  Context context ) { if ( m Enabled Res Id != _ NUM ) { final  Shared Preferences prefs =  Preference Manager . get Default Shared Preferences ( context ) ; if ( ! prefs . get Boolean ( context . get String ( m Enabled Res Id ) , m Enabled Default ) ) { set Trigger Keys (  Collections . <  Long > empty Set ( ) ) ; return ; } } set Trigger Keys (  Key Combo Preference . get Key Codes For Preference ( context , m Assigned Keys Res Id ) ) ; }
void add Inherited Types (  Type Mirror type Mirror ,  Types types Utils ) { if ( !  Compiler Utils . type Mirror In Collection ( inherited Types , type Mirror , types Utils ) ) { inherited Types . add ( type Mirror ) ; } }
public static  Histogram multiply (  Histogram x , double y ) { return x . modify Event Counters ( null ) ; }
public void paint (  Graphics g ) { if ( m_from == null || m_to == null ) return ;  Polygon arrow = new  Polygon ( ) ;  Point from = null ;  Point to = null ; if ( is Right Top ( ) ) { from = add Point ( arrow , m_from ,  Swing Constants .  RIGHT , _ BOOL ) ; to = add Point ( arrow , m_to ,  Swing Constants .  TOP , _ BOOL ) ; } else if ( is Bottom Top ( ) ) { from = add Point ( arrow , m_from ,  Swing Constants .  BOTTOM , _ BOOL ) ; to = add Point ( arrow , m_to ,  Swing Constants .  TOP , _ BOOL ) ; } else if ( is Top Bottom ( ) ) { from = add Point ( arrow , m_from ,  Swing Constants .  TOP , _ BOOL ) ; to = add Point ( arrow , m_to ,  Swing Constants .  BOTTOM , _ BOOL ) ; } else if ( is Left Right ( ) ) { from = add Point ( arrow , m_from ,  Swing Constants .  LEFT , _ BOOL ) ; to = add Point ( arrow , m_to ,  Swing Constants .  RIGHT , _ BOOL ) ; } else { from = add Point ( arrow , m_from ,  Swing Constants .  RIGHT , _ BOOL ) ; to = add Point ( arrow , m_to ,  Swing Constants .  LEFT , _ BOOL ) ; } if ( ! m_next . is Unconditional ( ) ) { g . set Color (  Color . red ) ; g . fill Polygon ( arrow ) ; } if ( m_visited ) g . set Color (  Color . green ) ; else g . set Color (  Color . black ) ; g . draw Polygon ( arrow ) ; if ( m_next . is From Split And ( ) ) { g . set Color (  Color . magenta ) ; g . fill Oval ( from . x - _ NUM , from . y - _ NUM , _ NUM , _ NUM ) ; } if ( m_next . is To Join And ( ) ) { g . set Color (  Color . magenta ) ; g . fill Oval ( to . x - _ NUM , to . y - _ NUM , _ NUM , _ NUM ) ; } if ( m_description != null ) {  Graphics2 D g2 D = (  Graphics2 D ) g ;  Font font = new  Font ( _ STR ,  Font .  PLAIN , _ NUM ) ; if ( m_next . is Unconditional ( ) ) g2 D . set Color (  Color . black ) ; else g2 D . set Color (  Color . red ) ;  Text Layout layout = new  Text Layout ( m_description , font , g2 D . get Font Render Context ( ) ) ; int x = _ NUM ; if ( from . x < to . x ) x = from . x + ( ( to . x - from . x ) / _ NUM ) ; else x = to . x + ( ( from . x - to . x ) / _ NUM ) ; int y = _ NUM ; if ( from . y < to . y ) y = from . y + ( ( to . y - from . y ) / _ NUM ) ; else y = to . y + ( ( from . y - to . y ) / _ NUM ) ; y -= ( layout . get Ascent ( ) - _ NUM ) ; x -= ( layout . get Advance ( ) / _ NUM ) ; if ( x < _ NUM ) x = _ NUM ; layout . draw ( g2 D , x , y ) ; } }
public void add Cache Participants (  Map <  UUID ,  Ignite Uuid > all Participants ,  Map <  UUID ,  Ignite Uuid > added Participants ) { ver Store . add Participants ( all Participants , added Participants ) ; }
private void savepost Mni (  String mnipost Location ,  String mnipost Resp Location ,  List manage Name Id List , com . sun . identity . saml2 . jaxb . metadata .  Object Factory obj Fact ) throws  JAXBException { if ( mnipost Location != null && mnipost Location . length ( ) > _ NUM ) {  Manage Name IDService Element sls Elem Post = obj Fact . create Manage Name IDService Element ( ) ; sls Elem Post . set Binding ( http Post Binding ) ; sls Elem Post . set Location ( mnipost Location ) ; sls Elem Post . set Response Location ( mnipost Resp Location ) ; manage Name Id List . add ( sls Elem Post ) ; } }
public static boolean go To Update Page (  Context context ) { final  Uri play Store Uri =  Uri . parse ( _ STR + context . get Package Name ( ) ) ;  Fresh Air Log . i ( _ STR + play Store Uri . to String ( ) ) ; final  Intent play Store Intent = new  Intent (  Intent .  ACTION_ VIEW , play Store Uri ) ; final  Package Manager package Manager = context . get Package Manager ( ) ; for (  Resolve Info resolve Info : package Manager . query Intent Activities ( play Store Intent , _ NUM ) ) { final  Activity Info resolve Activity = resolve Info . activity Info ; final  String resolve Package Name = resolve Activity . package Name ; if ( resolve Package Name . equals ( _ STR ) ) {  Fresh Air Log . i ( _ STR ) ; play Store Intent . set Component ( new  Component Name ( resolve Package Name , resolve Activity . name ) ) ; context . start Activity ( play Store Intent ) ; return _ BOOL ; } }  Fresh Air Log . e ( _ STR + play Store Uri . to String ( ) ) ; return _ BOOL ; }
public static  List <  String > to Relative Files ( @  Not Null  Virtual File root , @  Not Null final  Collection <  Virtual File > files ) {  Array List <  String > rc = new  Array List <  String > ( files . size ( ) ) ; for (  Virtual File file : files ) { rc . add ( relative Path ( root , file ) ) ; } return rc ; }
synchronized static void ensure Security Manager ( ) { if (  System . get Security Manager ( ) == null ) {  System . set Security Manager ( new  RMISecurity Manager ( ) ) ; } }
public static  Big Decimal rate ( int p_ C_ Currency From_ ID , int p_ C_ Currency To_ ID ,  Timestamp p_ Conversion Date , int p_ C_ Conversion Type_ ID , int p_ AD_ Client_ ID , int p_ AD_ Org_ ID ) throws  SQLException { if ( p_ C_ Currency From_ ID == p_ C_ Currency To_ ID ) return  Adempiere .  ONE ;  Timestamp  Conversion Date = p_ Conversion Date ; if (  Conversion Date == null )  Conversion Date = new  Timestamp (  System . current Time Millis ( ) ) ;  Conversion Date =  Adempiere . trunc (  Conversion Date ) ; int  C_ Conversion Type_ ID = p_ C_ Conversion Type_ ID ; if (  C_ Conversion Type_ ID == _ NUM ) {  String sql = _ STR + _ STR + _ STR + _ STR + _ STR ;  C_ Conversion Type_ ID =  Adempiere . get SQLValue ( sql , p_ AD_ Client_ ID ) ; }  Big Decimal rate = null ;  String sql = _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR ;  Prepared Statement pstmt =  Adempiere . prepare Statement ( sql ) ; pstmt . set Int ( _ NUM , p_ C_ Currency From_ ID ) ; pstmt . set Int ( _ NUM , p_ C_ Currency To_ ID ) ; pstmt . set Int ( _ NUM ,  C_ Conversion Type_ ID ) ; pstmt . set Timestamp ( _ NUM ,  Conversion Date ) ; pstmt . set Timestamp ( _ NUM ,  Conversion Date ) ; pstmt . set Int ( _ NUM , p_ AD_ Client_ ID ) ; pstmt . set Int ( _ NUM , p_ AD_ Org_ ID ) ;  Result Set rs = pstmt . execute Query ( ) ; if ( rs . next ( ) ) { rate = rs . get Big Decimal ( _ NUM ) ; } rs . close ( ) ; pstmt . close ( ) ; if ( rate == null ) return null ; return rate ; }
public static  Snmp Engine Id create Engine Id ( int port ) throws  Unknown Host Exception { int suniana = _ NUM ;  Inet Address address = null ; address =  Inet Address . get Local Host ( ) ; return create Engine Id ( address , port , suniana ) ; }
public static  List <  Rule > parse Referential (  String path ) {  Ruleset ruleset =  Delphi Rules Utils . build Rule Set From Xml (  Delphi Rules Utils . get Configuration From File ( path ) ) ;  List <  Rule > rules Repository = new  Array List <  Rule > ( ) ; for (  Delphi Rule f Rule : ruleset . get Rules ( ) ) { rules Repository . add ( create Repository Rule ( f Rule ) ) ; } return rules Repository ; }
public org . w3c . dom .  Document encrypt And Replace WSSElements ( org . w3c . dom .  Document doc , java . util .  Map elm Map , java . lang .  String enc Data Enc Alg , int enc Data Enc Alg Strength ,  String cert Alias , int kek Strength , java . lang .  String token Type , java . lang .  String provider ID ) throws  Encryption Exception { return null ; }
public void insert Child (  Node node , int index ) { node . detach From Parent ( ) ; node . parent Node = this ; try { init Child Nodes ( node ) ; child Nodes . add ( index , node ) ; } catch (  Index Out Of Bounds Exception ignore ) { throw new  Lagarto DOMException ( _ STR + index ) ; } reindex Children ( ) ; }
private static byte [ ] ntlm Hash ( final  String password ) throws  Authentication Exception { try { final byte [ ] unicode Password = password . get Bytes ( _ STR ) ; final  MD4 md4 = new  MD4 ( ) ; md4 . update ( unicode Password ) ; return md4 . get Output ( ) ; } catch (  Unsupported Encoding Exception e ) { throw new  Authentication Exception ( _ STR + e . get Message ( ) , e ) ; } }
private boolean between Zero And One ( final  String param Name , final double val ) { if ( ( val < _ NUM ) || ( val > _ NUM ) ) {  JOption Pane . show Message Dialog ( null , param Name + _ STR , _ STR ,  JOption Pane .  WARNING_ MESSAGE ) ; return _ BOOL ; } return _ BOOL ; }
public abstract  String substitute Macros (  String parameter Value ,  Macro Handler mh ) throws  Undefined Parameter Error ;
public void pow Equals ( double exp ) { for ( int i = _ NUM ; i <  A . length ; i ++ ) for ( int j = _ NUM ; j <  A [ i ] . length ; j ++ )  A [ i ] [ j ] =  Math . pow (  A [ i ] [ j ] , exp ) ; }
private static  List <  String > split Camel Case (  String class Name ) {  String remaining = class Name ;  List <  String > result = new  Array List <  String > ( ) ; while ( ! remaining . is Empty ( ) ) { boolean found = _ BOOL ; for ( int i = _ NUM ; i < remaining . length ( ) ; i ++ ) { if (  Character . is Upper Case ( remaining . char At ( i ) ) ) { result . add ( remaining . substring ( _ NUM , i ) ) ; remaining = remaining . substring ( i ) ; found = _ BOOL ; break ; } } if ( ! found ) { result . add ( remaining ) ; remaining = _ STR ; } } return result ; }
public static  Node List select Node List (  Node doc ,  String str ,  Namespace Context nsctx ) throws  XPath Exception {  XPath Factory xpf = xpath Factory Cache . get Instance For Current Thread ( ) ;  XPath xpath = xpf . new XPath ( ) ; xpath . set Namespace Context ( nsctx ) ;  XPath Expression expr = xpath . compile ( str ) ; return (  Node List ) expr . evaluate ( doc ,  XPath Constants .  NODESET ) ; }
private void generate Discovery ( ) throws  SAXException { handler . start Element ( _ STR ,  LOCATORS ,  LOCATORS ,  EMPTY ) ; generate Locators ( ) ; handler . end Element ( _ STR ,  LOCATORS ,  LOCATORS ) ; }
protected  Basic Type (  Class <  T > type , int sql Type ) { super ( type , sql Type ) ; check Null = ! type . is Primitive ( ) ; }
@  Override public void action Performed (  Action Event e ) { }
public void apply Properties ( ) { for (  Parameter Type type : all Parameter Types ) {  String value = all Parameter Values . get Property ( type . get Key ( ) ) ;  Parameter Service . set Parameter Value ( type , value ) ; } }
public void add (  Cluster Node new Node ) { if ( node != null ) { nodes = new  Array List < > ( _ NUM ) ; nodes . add ( node ) ; node = null ; } nodes . add ( new Node ) ; }
public boolean check If Backup Set Exists (  String set Name ) { validate Not Null Or Empty ( set Name ) ; try {  File file = new  File ( get Backup Root ( ) , set Name ) ; if ( file . exists ( ) ) { return _ BOOL ; } } catch (  Exception e ) { log . error ( _ STR ) ; } return _ BOOL ; }
public static  String [ ] to Quoted And Comma Separated Array (  String str ) throws  IOException {  Linked List <  String > values = new  Linked List <  String > ( ) ;  Stream Tokenizer tt = new  Stream Tokenizer ( new  String Reader ( str ) ) ; tt . word Chars ( _ STR , _ STR ) ; tt . word Chars ( _ STR , _ STR ) ; tt . word Chars ( _ NUM + _ NUM , _ NUM ) ; tt . whitespace Chars ( _ NUM , _ STR ) ; tt . quote Char ( _ STR ) ; tt . quote Char ( _ STR ) ; while ( tt . next Token ( ) !=  Stream Tokenizer .  TT_ EOF ) { switch ( tt . ttype ) { case  Stream Tokenizer .  TT_ WORD : case _ STR : case _ STR : values . add ( tt . sval ) ; break ; } } return values . to Array ( new  String [ values . size ( ) ] ) ; }
public void write String No Compression (  String str ) throws  IOException { if ( str == null ) { write Int ( _ NUM ) ; } else { write Int ( str . length ( ) ) ; for ( int i = _ NUM ; i < str . length ( ) ; i ++ ) io . write ( ( byte ) str . char At ( i ) ) ; } }
public  Smart Thresholds parse ( final  Resource threshold File Resource ) throws  IOException { final  Smart Thresholds holder = new  Smart Thresholds ( ) ;  Buffered Reader reader = null ; try { reader = new  Buffered Reader ( new  Input Stream Reader ( threshold File Resource . get Input Stream ( ) ) ) ;  String line ; while ( ( line = reader . read Line ( ) ) != null ) { if ( line . starts With ( _ STR ) ) {  String [ ] line Input = line . split ( _ STR ) ; holder . add Threshold ( new  Smart Threshold ( line Input ) ) ; } } } finally { if ( reader != null ) { reader . close ( ) ; } } return holder ; }
public void shutdown ( ) {  Executor Service executor =  Executors . new Scheduled Thread Pool ( _ NUM ) ; executor . submit ( create Shutdown ( _ NUM ) ) ; }
@  Override public  Point drawing To View (  Point2 D .  Double p ) { return new  Point ( ( int ) ( p . x * scale Factor ) - translation . x , ( int ) ( p . y * scale Factor ) - translation . y ) ; }
protected void on Connect ( ) { }
public void add Descriptor ( final  Setup Descriptor desc ) { descriptors . add ( desc ) ; }
public static boolean contain IP ( int cidr Prefix , int cidr Mask Bits , int ip ) { boolean matched = _ BOOL ; int bits To Shift = _ NUM - cidr Mask Bits ; if ( bits To Shift > _ NUM ) { cidr Prefix = cidr Prefix > > bits To Shift ; ip = ip > > bits To Shift ; cidr Prefix = cidr Prefix << bits To Shift ; ip = ip << bits To Shift ; } if ( cidr Prefix != ip ) { matched = _ BOOL ; } return matched ; }
public static  String compile Progress Success Action (  String progress Success Action ) throws  Template Model Exception {  Environment env =  Common Ftl Util . get Current Environment ( ) ; return compile Progress Success Action ( progress Success Action ,  Context Ftl Util . get Request ( env ) ,  Context Ftl Util . get Response ( env ) ) ; }
public static  String join (  String separator , float ... elements ) { if ( elements == null || elements . length == _ NUM ) { return _ STR ; }  List <  Number > list = new  Array List <  Number > ( elements . length ) ; for (  Float elem : elements ) { list . add ( elem ) ; } return join ( separator , list ) ; }
public static void put Unsigned Byte (  Byte Buffer bb , short v ) { bb . put ( ( byte ) ( v & _ NUM ) ) ; }
@  Override public  Trie optimize (  Trie orig ) {  List <  Char Sequence > cmds = orig . cmds ;  List <  Row > rows = new  Array List < > ( ) ;  List <  Row > orows = orig . rows ; int remap [ ] = new int [ orows . size ( ) ] ; for ( int j = orows . size ( ) - _ NUM ; j >= _ NUM ; j -- ) {  Row now = new  Remap ( orows . get ( j ) , remap ) ; boolean merged = _ BOOL ; for ( int i = _ NUM ; i < rows . size ( ) ; i ++ ) {  Row q = merge ( now , rows . get ( i ) ) ; if ( q != null ) { rows . set ( i , q ) ; merged = _ BOOL ; remap [ j ] = i ; break ; } } if ( merged == _ BOOL ) { remap [ j ] = rows . size ( ) ; rows . add ( now ) ; } } int root = remap [ orig . root ] ;  Arrays . fill ( remap , - _ NUM ) ; rows = remove Gaps ( root , rows , new  Array List <  Row > ( ) , remap ) ; return new  Trie ( orig . forward , remap [ root ] , cmds , rows ) ; }
public boolean is All Denied ( ) { int count = _ NUM ; for ( int i = _ NUM ; i < m Perms . size ( ) ; i ++ ) { if ( m Perms . get ( m User Permission . get ( i ) ) ==  Package Manager .  PERMISSION_ DENIED ) count ++ ; } return count == m Perms . size ( ) ; }
public  String to String Key ( ) {  String result ; int i ; result = _ STR + _ STR ; for ( i = _ NUM ; i < get Col Count ( ) ; i ++ ) { if ( get Col Hidden ( i ) ) continue ; result += _ STR + _ STR + ( i + _ NUM ) + _ STR + _ STR + remove Filter Name ( m_ Col Names [ i ] ) + _ STR + _ STR ; } result += _ STR ; return result ; }
private  Date Time Formatter to Formatter (  Locale locale ,  Resolver Style resolver Style ,  Chronology chrono ) {  Objects . require Non Null ( locale , _ STR ) ; while ( active . parent != null ) { optional End ( ) ; }  Composite Printer Parser pp = new  Composite Printer Parser ( printer Parsers , _ BOOL ) ; return new  Date Time Formatter ( pp , locale ,  Decimal Style .  STANDARD , resolver Style , null , chrono , null ) ; }
protected void wait For External Store Mount ( ) throws  Exception {  String ext Storage State =  Environment . get External Storage State ( ) ; int current Wait Time = _ NUM ; while ( ! ext Storage State . equals (  Environment .  MEDIA_ MOUNTED ) ) {  Log . i (  LOG_ TAG , _ STR ) ; current Wait Time = timeout Wait ( current Wait Time ,  DEFAULT_ WAIT_ POLL_ TIME ,  DEFAULT_ MAX_ WAIT_ TIME , _ STR ) ; ext Storage State =  Environment . get External Storage State ( ) ; } }
public boolean upload And Install Apk ( @  Not Null  IDevice device , @  Not Null  String package Name , @  Not Null  File local File , @  Not Null  Launch Status launch Status ) { if ( ! needs Install ( device , local File , package Name ) ) { return _ BOOL ; }  String remote Path = _ STR + package Name ; my Printer . stdout ( _ STR + local File + _ STR + remote Path ) ; try { device . push File ( local File . get Path ( ) , remote Path ) ; boolean installed = install App ( device , remote Path , package Name , launch Status ) ; if ( installed ) { my Installed Apk Cache . set Installed ( device , local File , package Name ) ; } return installed ; } catch (  Exception e ) { my Printer . stderr ( e . to String ( ) ) ; return _ BOOL ; } }
public void open ( final long [ ] list , final int position ) { launch Player Activity = _ BOOL ; synchronized ( this ) { if ( m Shuffle Mode ==  SHUFFLE_ AUTO ) { m Shuffle Mode =  SHUFFLE_ NORMAL ; } final long old Id = get Audio Id ( ) ; final int listlength = list . length ; boolean newlist = _ BOOL ; if ( m Play List Len == listlength ) { newlist = _ BOOL ; for ( int i = _ NUM ; i < listlength ; i ++ ) { if ( list [ i ] != m Play List [ i ] ) { newlist = _ BOOL ; break ; } } } if ( newlist ) { add To Play List ( list , - _ NUM ) ; notify Change (  QUEUE_ CHANGED ) ; } if ( position >= _ NUM ) { m Play Pos = position ; } else { m Play Pos = m Shuffler . next Int ( m Play List Len ) ; } m History . clear ( ) ; open Current And Next ( ) ; if ( old Id != get Audio Id ( ) ) { notify Change (  META_ CHANGED ) ; } } }
public void test Negative Reverse Step By One With Closure ( ) { final  List call Log = new  Array List ( ) ; final  Closure closure = new  Recording Closure ( call Log ) ; final  Range range = create Range ( _ NUM , _ NUM ) ; range . step ( - _ NUM , closure ) ; assert Equals ( _ STR , _ NUM , call Log . size ( ) ) ; final  Iterator iter = call Log . iterator ( ) ; for ( int i = _ NUM ; i <= _ NUM ; i ++ ) { assert Equals ( _ STR , create Value ( i ) , iter . next ( ) ) ; } }
public static  Big Decimal normalize Decimal Value (  Big Decimal big Decimal , int allowed Precision ) { if ( big Decimal . precision ( ) > allowed Precision ) { return null ; } return big Decimal ; }
protected static  Node deserialize String (  String doc ) { try {  String Reader reader = new  String Reader ( doc ) ;  Stream Source source = new  Stream Source ( reader ) ;  DOMResult result = new  DOMResult ( ) ;  Transformer Factory tf =  Transformer Factory . new Instance ( ) ;  Transformer transformer = tf . new Transformer ( ) ; transformer . set Output Property (  Output Keys .  ENCODING ,  DEFAULT_ ENCODING ) ; transformer . set Output Property (  Output Keys .  INDENT ,  DEFAULT_ INDENT ) ; transformer . transform ( source , result ) ; return result . get Node ( ) ; } catch (  Throwable e ) { log . log (  Level .  SEVERE , _ STR , e ) ; } return null ; }
public void send Event To Agent ( final  String event ) { synchronized ( event Socket ) { event Writer . print ( event ) ; event Writer . flush ( ) ; } }
private void apply JMSObjects (  Hash Map <  String ,  String > filters ) {  String Writer writer = new  String Writer ( ) ;  Print Writer print Writer = new  Print Writer ( writer ) ; print Writer . println ( ) ; for (  String str : get Queue List ( ) ) { print Writer . println ( _ STR + str + _ STR ) ; } for (  String str : get Topic List ( ) ) { print Writer . println ( _ STR + str + _ STR ) ; } filters . put ( _ STR , writer . to String ( ) ) ; }
@  Override public  Revision next ( ) { try { int rev Count , article ID ; rev Count = result . get Int ( _ NUM ) ; article ID = result . get Int ( _ NUM ) ; if ( article ID != this . current Article ID ) { this . current Rev Counter = _ NUM ; this . current Article ID = article ID ; } if ( rev Count - _ NUM != this . current Rev Counter ) { logger . error ( _ STR + _ STR + article ID + _ STR + result . get Int ( _ NUM ) + _ STR + result . get Int ( _ NUM ) + _ STR + ( this . current Rev Counter + _ NUM ) ) ; this . current Rev Counter = rev Count ; this . previous Revision = null ; return null ; } this . current Rev Counter = rev Count ; this . primary Key = result . get Int ( _ NUM ) ;  Revision revision = new  Revision ( rev Count ) ; revision . set Primary Key ( this . primary Key ) ; if ( ! should Load Revision Text ) {  String current Revision ;  Diff diff ;  Revision Decoder decoder = new  Revision Decoder ( config . get Character Set ( ) ) ; if ( binary Data ) { decoder . set Input ( result . get Binary Stream ( _ NUM ) , _ BOOL ) ; } else { decoder . set Input ( result . get String ( _ NUM ) ) ; } diff = decoder . decode ( ) ; try { current Revision = diff . build Revision ( previous Revision ) ; } catch (  Exception e ) { this . previous Revision = null ; logger . error ( _ STR + _ STR + result . get Int ( _ NUM ) + _ STR + result . get Int ( _ NUM ) + _ STR + result . get Int ( _ NUM ) + _ STR ) ; return null ; } previous Revision = current Revision ; revision . set Revision Text ( current Revision ) ; } else { if ( rev Api == null ) { rev Api = new  Revision Api ( config ) ; } revision . set Revision Api ( rev Api ) ; } revision . set Revision ID ( result . get Int ( _ NUM ) ) ; revision . set Article ID ( article ID ) ; revision . set Time Stamp ( new  Timestamp ( result . get Long ( _ NUM ) ) ) ; revision . set Full Revision ID ( result . get Int ( _ NUM ) ) ; revision . set Contributor Name ( result . get String ( _ NUM ) ) ; revision . set Contributor Id ( result . get Int ( _ NUM ) ) ; revision . set Comment ( result . get String ( _ NUM ) ) ; revision . set Minor ( result . get Boolean ( _ NUM ) ) ; revision . set Contributor Is Registered ( result . get Boolean ( _ NUM ) ) ; return revision ; } catch (  Decoding Exception e ) { throw new  Runtime Exception ( e ) ; } catch (  SQLException e ) { throw new  Runtime Exception ( e ) ; } catch (  IOException e ) { throw new  Runtime Exception ( e ) ; } catch (  Wiki Api Exception e ) { throw new  Runtime Exception ( e ) ; } }
public void add Selection Column (  Grid Field m Field ) { log . config ( m Field . get Header ( ) ) ; int display Length = m Field . get Display Length ( ) ; if ( display Length <= _ NUM || display Length >  FIELDLENGTH ) m Field . set Display Length (  FIELDLENGTH ) ; else display Length = _ NUM ;  WEditor editor = null ;  Label label = null ;  Row panel = new  Row ( ) ; content Simple Rows . append Child ( panel ) ; if ( m Field . is Range ( ) ) {  Hbox box = new  Hbox ( ) ; editor =  Web Editor Factory . get Editor ( m Field , _ BOOL ) ; label = editor . get Label ( ) ; editor . set Mandatory ( _ BOOL ) ; editor . set Read Write ( _ BOOL ) ; editor . dynamic Display ( ) ;  Component field Label = editor . get Component ( ) ; box . append Child ( editor . get Component ( ) ) ; range First Editor . add ( m Field . get Column Name ( ) ) ;  WEditor to Range Editor =  Web Editor Factory . get Editor ( m Field , _ BOOL ) ; to Range Editor . set Mandatory ( _ BOOL ) ; to Range Editor . set Read Write ( _ BOOL ) ; to Range Editor . dynamic Display ( ) ; m_s Editors2 . add ( to Range Editor ) ;  Label separator = new  Label ( _ STR ) ; box . append Child ( separator ) ;  Component field Label1 = to Range Editor . get Component ( ) ; box . append Child ( to Range Editor . get Component ( ) ) ; if ( display Length > _ NUM ) m Field . set Display Length ( display Length ) ; if ( is Two Columns ) { if ( ! is Pair ) panel = new  Row ( ) ; } else panel = new  Row ( ) ; panel . append Child (  Layout Utils . make Right Align ( label ) ) ; panel . append Child ( box ) ; field Label . add Event Listener (  Events .  ON_ OK , this ) ; field Label1 . add Event Listener (  Events .  ON_ OK , this ) ; } else { editor =  Web Editor Factory . get Editor ( m Field , _ BOOL ) ; label = editor . get Label ( ) ; editor . set Mandatory ( _ BOOL ) ; editor . set Read Write ( _ BOOL ) ; editor . dynamic Display ( ) ;  Component field Label = editor . get Component ( ) ; if ( display Length > _ NUM ) m Field . set Display Length ( display Length ) ; panel . append Child (  Layout Utils . make Right Align ( label ) ) ; panel . append Child ( field Label ) ; field Label . add Event Listener (  Events .  ON_ OK , this ) ; m_s Editors2 . add ( null ) ; } m_s Editors . add ( editor ) ; }
public final static void close EL ( final  Output Stream os ) { try { if ( os != null ) os . close ( ) ; } catch ( final  Throwable e ) { } }
public void add Search Listener (  Search Listener l ) { m_ Search Listeners . add ( l ) ; }
public boolean is Single Attribute Container ( ) { return _ BOOL ; }
public void open (  File file ) throws  IOException { check AWTPermission ( ) ; check Exec ( ) ; check Action Support (  Action .  OPEN ) ; check File Validation ( file ) ; peer . open ( file ) ; }
public static  String convert ISO8601 Duration To Normal Time (  String iso Time ) {  String formatted Time = new  String ( ) ; if ( iso Time . contains ( _ STR ) && iso Time . contains ( _ STR ) && iso Time . contains ( _ STR ) ) {  String hours = iso Time . substring ( iso Time . index Of ( _ STR ) + _ NUM , iso Time . index Of ( _ STR ) ) ;  String minutes = iso Time . substring ( iso Time . index Of ( _ STR ) + _ NUM , iso Time . index Of ( _ STR ) ) ;  String seconds = iso Time . substring ( iso Time . index Of ( _ STR ) + _ NUM , iso Time . index Of ( _ STR ) ) ; formatted Time = hours + _ STR + format To2 Digits ( minutes ) + _ STR + format To2 Digits ( seconds ) ; } else if ( ! iso Time . contains ( _ STR ) && iso Time . contains ( _ STR ) && iso Time . contains ( _ STR ) ) {  String minutes = iso Time . substring ( iso Time . index Of ( _ STR ) + _ NUM , iso Time . index Of ( _ STR ) ) ;  String seconds = iso Time . substring ( iso Time . index Of ( _ STR ) + _ NUM , iso Time . index Of ( _ STR ) ) ; formatted Time = minutes + _ STR + format To2 Digits ( seconds ) ; } else if ( iso Time . contains ( _ STR ) && ! iso Time . contains ( _ STR ) && iso Time . contains ( _ STR ) ) {  String hours = iso Time . substring ( iso Time . index Of ( _ STR ) + _ NUM , iso Time . index Of ( _ STR ) ) ;  String seconds = iso Time . substring ( iso Time . index Of ( _ STR ) + _ NUM , iso Time . index Of ( _ STR ) ) ; formatted Time = hours + _ STR + format To2 Digits ( seconds ) ; } else if ( iso Time . contains ( _ STR ) && iso Time . contains ( _ STR ) && ! iso Time . contains ( _ STR ) ) {  String hours = iso Time . substring ( iso Time . index Of ( _ STR ) + _ NUM , iso Time . index Of ( _ STR ) ) ;  String minutes = iso Time . substring ( iso Time . index Of ( _ STR ) + _ NUM , iso Time . index Of ( _ STR ) ) ; formatted Time = hours + _ STR + format To2 Digits ( minutes ) + _ STR ; } else if ( ! iso Time . contains ( _ STR ) && ! iso Time . contains ( _ STR ) && iso Time . contains ( _ STR ) ) {  String seconds = iso Time . substring ( iso Time . index Of ( _ STR ) + _ NUM , iso Time . index Of ( _ STR ) ) ; formatted Time = _ STR + format To2 Digits ( seconds ) ; } else if ( ! iso Time . contains ( _ STR ) && iso Time . contains ( _ STR ) && ! iso Time . contains ( _ STR ) ) {  String minutes = iso Time . substring ( iso Time . index Of ( _ STR ) + _ NUM , iso Time . index Of ( _ STR ) ) ; formatted Time = minutes + _ STR ; } else if ( iso Time . contains ( _ STR ) && ! iso Time . contains ( _ STR ) && ! iso Time . contains ( _ STR ) ) {  String hours = iso Time . substring ( iso Time . index Of ( _ STR ) + _ NUM , iso Time . index Of ( _ STR ) ) ; formatted Time = hours + _ STR ; } return formatted Time ; }
@  Override public void toggle Selection (  T photo ) { if ( selected Photos . contains ( photo ) ) { selected Photos . remove ( photo ) ; } else { selected Photos . add ( photo ) ; } }
protected void pre Tick ( ) { }
public byte map ( byte src ) { char c = map ( ( char ) src ) ; if ( c <  Byte .  MIN_ VALUE || c >  Byte .  MAX_ VALUE ) { return _ NUM ; } return ( byte ) c ; }
public  String wrap If Keyword Or Built In (  String name ) { if (  KEYWORD_ BUILT_ IN_ SET . contains ( name ) ) { return name + _ STR ; } return name ; }
public  Issue Matcher add ( ) {  Issue Matcher issue Matcher = new  Issue Matcher ( ) ; issue Matchers . add ( issue Matcher ) ; return issue Matcher ; }
private <  T >  Inject Scope <  T > find Scope (  Annotated Element ann Element ) { for (  Annotation ann : ann Element . get Annotations ( ) ) {  Class < ? extends  Annotation > ann Type = ann . annotation Type ( ) ; if ( ann Type . is Annotation Present (  Scope . class ) ) {  Supplier <  Inject Scope <  T > > scope Gen = (  Supplier ) _scope Map . get ( ann Type ) ; if ( scope Gen != null ) { return scope Gen . get ( ) ; } else { log . fine (  L . l ( _ STR , ann Type . get Simple Name ( ) ) ) ; } } } return new  Inject Scope Factory < > ( ) ; }
private static native int [ ]  Reg Open Key ( int h Key , byte [ ] sub Key , int security Mask ) ;
public void remove Property Change Listener (  IProperty Change Listener listener ) { listeners . remove ( listener ) ; }
@  Override public int previous ( ) {  Character Iterator text = get Text ( ) ; if ( current ( ) == text . get Begin Index ( ) ) { return  Break Iterator .  DONE ; } int start = current ( ) ; int last Result = cached Last Known Break ; if ( last Result >= start || last Result <=  Break Iterator .  DONE ) { get Previous ( ) ; last Result = handle Previous ( ) ; } else { text . set Index ( last Result ) ; } int result = last Result ; while ( result !=  Break Iterator .  DONE && result < start ) { last Result = result ; result = handle Next ( ) ; } text . set Index ( last Result ) ; cached Last Known Break = last Result ; return last Result ; }
public  Deferred Image Replaced Element (  Image Resource image Resource ,  Repaint Listener repaint Listener , int w , int h ) { this . _image Resource = image Resource ; _loaded = _ BOOL ; this . repaint Listener = repaint Listener ; if ( w == - _ NUM && h == - _ NUM ) { _do Scale Image = _ BOOL ; _target Height = _ NUM ; _target Width = _ NUM ; } else { _do Scale Image = _ BOOL ; _target Height =  Math . max ( _ NUM , h ) ; _target Width =  Math . max ( _ NUM , w ) ; } _image =  Image Util . create Compatible Buffered Image ( _target Width , _target Height ) ; }
public boolean starts With (  Name n ) { if ( n instanceof  Compound Name ) { return ( impl . starts With ( n . size ( ) , n . get All ( ) ) ) ; } else { return _ BOOL ; } }
public  Parameterized Generic Method Binding (  Method Binding original Method ,  Type Binding [ ] type Arguments ,  Lookup Environment environment ) { this . environment = environment ; this . modifiers = original Method . modifiers ; this . selector = original Method . selector ; this . declaring Class = original Method . declaring Class ; this . type Variables =  Binding .  NO_ TYPE_ VARIABLES ; this . type Arguments = type Arguments ; this . is Raw = _ BOOL ; this . tag Bits = original Method . tag Bits ; this . original Method = original Method ; this . parameters =  Scope . substitute ( this , original Method . parameters ) ; this . return Type =  Scope . substitute ( this , original Method . return Type ) ; this . thrown Exceptions =  Scope . substitute ( this , original Method . thrown Exceptions ) ; if ( this . thrown Exceptions == null ) this . thrown Exceptions =  Binding .  NO_ EXCEPTIONS ; check Missing Type : { if ( ( this . tag Bits &  Tag Bits .  Has Missing Type ) != _ NUM ) break check Missing Type ; if ( ( this . return Type . tag Bits &  Tag Bits .  Has Missing Type ) != _ NUM ) { this . tag Bits |=  Tag Bits .  Has Missing Type ; break check Missing Type ; } for ( int i = _ NUM , max = this . parameters . length ; i < max ; i ++ ) { if ( ( this . parameters [ i ] . tag Bits &  Tag Bits .  Has Missing Type ) != _ NUM ) { this . tag Bits |=  Tag Bits .  Has Missing Type ; break check Missing Type ; } } for ( int i = _ NUM , max = this . thrown Exceptions . length ; i < max ; i ++ ) { if ( ( this . thrown Exceptions [ i ] . tag Bits &  Tag Bits .  Has Missing Type ) != _ NUM ) { this . tag Bits |=  Tag Bits .  Has Missing Type ; break check Missing Type ; } } } this . was Inferred = _ BOOL ; }
public void test Invoke All5 ( ) throws  Throwable {  Executor Service e = new  Fork Join Pool ( _ NUM ) ;  Pool Cleaner cleaner = null ; try { cleaner = cleaner ( e ) ;  List <  Callable <  String > > l = new  Array List <  Callable <  String > > ( ) ; l . add ( new  String Task ( ) ) ; l . add ( new  String Task ( ) ) ;  List <  Future <  String > > futures = e . invoke All ( l ) ; assert Equals ( _ NUM , futures . size ( ) ) ; for (  Future <  String > future : futures ) assert Same (  TEST_ STRING , future . get ( ) ) ; } finally { if ( cleaner != null ) { cleaner . close ( ) ; } } }
public  Internal Listener ( final  Config Manager config File ) { this . config File = config File ; }
public byte [ ] sign ( byte [ ] hash ) {  ECDSASigner signer = new  ECDSASigner ( new  HMac DSAKCalculator ( new  SHA256 Digest ( ) ) ) ; signer . init ( _ BOOL , new  ECPrivate Key Parameters ( priv , domain ) ) ;  Big Integer [ ] signature = signer . generate Signature ( hash ) ;  Byte Array Output Stream baos = new  Byte Array Output Stream ( ) ; try {  DERSequence Generator seq = new  DERSequence Generator ( baos ) ; seq . add Object ( new  ASN1 Integer ( signature [ _ NUM ] ) ) ; seq . add Object ( new  ASN1 Integer ( to Canonical S ( signature [ _ NUM ] ) ) ) ; seq . close ( ) ; return baos . to Byte Array ( ) ; } catch (  IOException e ) { } return null ; }
public  Time Period (  Date start Time ,  Date end Time ) { if ( start Time != null && end Time != null && ! end Time . after ( start Time ) ) { throw new  Illegal Argument Exception ( _ STR + end Time + _ STR + start Time ) ; } this . start Time = start Time ; this . end Time = end Time ; }
JMenu create Edit Menu ( ) {  JMenu edit Menu = new  JMenu ( _ STR ) ; edit Menu . add ( action Manager . get Cut Action ( ) ) ; edit Menu . add ( action Manager . get Copy Action ( ) ) ; edit Menu . add ( action Manager . get Paste Action ( ) ) ; edit Menu . add ( action Manager . get Delete Action ( ) ) ; edit Menu . add Separator ( ) ; edit Menu . add ( action Manager . get Clear Source Neurons Action ( ) ) ; edit Menu . add ( action Manager . get Set Source Neurons Action ( ) ) ; edit Menu . add ( action Manager . get Connection Menu ( ) ) ; edit Menu . add ( action Manager . get Add Synapse Group Action ( ) ) ; edit Menu . add Separator ( ) ; edit Menu . add ( action Manager . get Randomize Objects Action ( ) ) ; edit Menu . add ( action Manager . get Show Adjust Synapses Dialog ( ) ) ; edit Menu . add Separator ( ) ; edit Menu . add ( action Manager . get Layout Menu ( ) ) ; edit Menu . add ( action Manager . get Group Menu ( ) ) ; edit Menu . add Separator ( ) ; edit Menu . add ( create Align Menu ( ) ) ; edit Menu . add ( create Spacing Menu ( ) ) ; edit Menu . add Separator ( ) ; edit Menu . add ( action Manager . get Set Neuron Properties Action ( ) ) ; edit Menu . add ( action Manager . get Set Synapse Properties Action ( ) ) ; edit Menu . add Separator ( ) ; edit Menu . add ( create Selection Menu ( ) ) ; return edit Menu ; }
public void current State ( long state ,  Model current Model ) { current State = state ; if ( loggers != null ) { for (  Logger logger : loggers ) { logger . log ( state ) ; } } }
public boolean is BOM ( ) { return m_is BOM ; }
public boolean is Signed ( ) { return signed ; }
public  Object parse Text (  String text ) { if ( text == null || text . length ( ) == _ NUM ) { throw new  Illegal Argument Exception ( _ STR ) ; } return parse ( new  Line Column Reader ( new  String Reader ( text ) ) ) ; }
protected <  T >  Database make Simple Database (  String filename , int expected Size ,  List Parameterization params ,  Class < ? > [ ] filters ) { try (  Input Stream is = open ( filename ) ) {  List <  Object Filter > filterlist = new  Array List < > ( ) ; filterlist . add ( new  Fixed DBIDs Filter ( _ NUM ) ) ; if ( filters != null ) { for (  Class < ? > filtercls : filters ) {  Object Filter filter =  Class Generics Util . parameterize Or Abort ( filtercls , params ) ; filterlist . add ( filter ) ; } }  Number Vector Label Parser <  Double Vector > parser = new  Number Vector Label Parser < > (  Double Vector .  FACTORY ) ;  Input Stream Database Connection dbc = new  Input Stream Database Connection ( is , filterlist , parser ) ; params . add Parameter (  Abstract Database .  Parameterizer .  DATABASE_ CONNECTION_ ID , dbc ) ;  Database db =  Class Generics Util . parameterize Or Abort (  Static Array Database . class , params ) ; test Parameterization Ok ( params ) ; db . initialize ( ) ;  Relation < ? > rel = db . get Relation (  Type Util .  ANY ) ; assert Equals ( _ STR , expected Size , rel . size ( ) ) ; return db ; } catch (  IOException e ) { fail ( _ STR + filename + _ STR ) ; return null ; } }
protected void add Chooser Filters (  JFile Chooser chooser ) { javax . swing . filechooser .  File Name Extension Filter filter ; chooser . add Choosable File Filter ( filter = new javax . swing . filechooser .  File Name Extension Filter ( _ STR , _ STR ) ) ; chooser . set File Filter ( filter ) ; }
public void on Stop ( ) { if ( null != m Service ) { if ( null != m Context ) { m Context . unbind Service ( m Service Connection ) ; } m Service Connection = null ; m Service = null ; } }
public  String peek ( ) {  String result = null ; if ( is Empty ( ) ) { return null ; } else { int cached Current Index = current Index ; if ( is Eating Blocks Of Delimiters ) { trim Starting Delimiters ( ) ; } int nearest Delimeter = - _ NUM ; for ( int i = _ NUM ; i < delimiters . length ( ) ; i ++ ) { int delimiter = source . index Of ( delimiters . char At ( i ) , current Index ) ; if ( nearest Delimeter == - _ NUM || delimiter != - _ NUM && delimiter < nearest Delimeter ) { nearest Delimeter = delimiter ; } } if ( nearest Delimeter == - _ NUM ) { result = source . substring ( current Index ) ; } else { result = source . substring ( current Index , nearest Delimeter ) ; } current Index = cached Current Index ; } return result ; }
private void eliminar Usuarios Organo (  Gestion Organizacion BI organizacion BI ,  Organizacion VO organizacion VO ) { organizacion BI . eliminar Usuarios Organo ( organizacion VO . get Id ( ) ) ; }
private static void add Previous Layer (  List <  List <  Neuron > > layers ,  List <  Neuron > source Layer ,  List <  Neuron > layer To Check ) { final int  MAXLAYERS = _ NUM ;  Set <  Neuron > new Layer Temp = new  Hash Set <  Neuron > ( ) ; boolean the Next Layer Is The Source Layer = _ BOOL ; for (  Neuron neuron : layer To Check ) { for (  Synapse synapse : neuron . get Fan In ( ) ) {  Neuron source Neuron = synapse . get Source ( ) ; if ( source Layer . contains ( source Neuron ) ) { the Next Layer Is The Source Layer = _ BOOL ; } if ( source Neuron == neuron ) { continue ; } new Layer Temp . add ( synapse . get Source ( ) ) ; } } if ( ( the Next Layer Is The Source Layer ) || ( new Layer Temp . size ( ) == _ NUM ) || ( layers . size ( ) >  MAXLAYERS ) ) { layers . add ( source Layer ) ; } else {  List <  Neuron > new Layer = new  Array List <  Neuron > ( new Layer Temp ) ;  Collections . sort ( new Layer ,  Orientation Comparator .  X_ ORDER ) ; layers . add ( new Layer ) ; add Previous Layer ( layers , source Layer , new Layer ) ; } }
public static void ignorm ( double c1 [ ] , double c2 [ ] , int m , double ng ) { if ( ng != _ NUM ) { double k =  Math . pow ( c1 [ _ NUM ] , ng ) ; for ( int i = m ; i >= _ NUM ; i -- ) c2 [ i ] = k * c1 [ i ] ; c2 [ _ NUM ] = ( k - _ NUM ) / ng ; } else {  System . arraycopy ( c1 , _ NUM , c2 , _ NUM , m - _ NUM ) ; c2 [ _ NUM ] =  Math . log ( c1 [ _ NUM ] ) ; } }
public static int find Nonwhitespace Character (  String s , int index ) { int s Length = s . length ( ) ; while ( index < s Length &&  Character . is Whitespace ( s . char At ( index ) ) ) { index ++ ; } return index ; }
public  Primitive (  Object value ) { this . value = value ; type = ( value != null ) ?  Utilities . get Primitive Type ( value . get Class ( ) ) : null ; if ( type == null ) { throw new  Illegal Argument Exception ( _ STR + value ) ; } }
public void create Cash Based Journal Entries And Reversals For Savings Tax ( final  Office office , final  String currency Code , final  CASH_ ACCOUNTS_ FOR_ SAVINGS account Type To Be Debited , final  CASH_ ACCOUNTS_ FOR_ SAVINGS account Type To Be Credited , final  Long savings Product Id , final  Long payment Type Id , final  Long savings Id , final  String transaction Id , final  Date transaction Date , final  Big Decimal amount , final  Boolean is Reversal , final  List <  Tax Payment DTO > tax Details ) { for (  Tax Payment DTO tax Payment DTO : tax Details ) { if ( tax Payment DTO . get Amount ( ) != null ) { if ( tax Payment DTO . get Credit Account Id ( ) == null ) { create Cash Based Credit Journal Entries And Reversals For Savings ( office , currency Code , account Type To Be Credited . get Value ( ) , savings Product Id , payment Type Id , savings Id , transaction Id , transaction Date , tax Payment DTO . get Amount ( ) , is Reversal ) ; } else { create Cash Based Credit Journal Entries And Reversals For Savings ( office , currency Code , tax Payment DTO . get Credit Account Id ( ) , savings Id , transaction Id , transaction Date , tax Payment DTO . get Amount ( ) , is Reversal ) ; } } } create Cash Based Debit Journal Entries And Reversals For Savings ( office , currency Code , account Type To Be Debited . get Value ( ) , savings Product Id , payment Type Id , savings Id , transaction Id , transaction Date , amount , is Reversal ) ; }
public int read (  Byte Buf dst , int dst Start , int dst Length ) throws  IOException { final int remaining = ( int )  Math . min ( this . length - this . position ,  Integer .  MAX_ VALUE ) ; final int read =  Math . min ( remaining , dst Length ) ; final int buffer Position = check Offset ( position , read ) ; final long src Address =  Platform Dependent . direct Buffer Address ( last Mapped ) + buffer Position ; if ( dst . has Memory Address ( ) ) { final long dst Address = dst . memory Address ( ) + dst Start ;  Platform Dependent . copy Memory ( src Address , dst Address , read ) ; } else if ( dst . has Array ( ) ) { final byte [ ] dst Array = dst . array ( ) ;  Platform Dependent . copy Memory ( src Address , dst Array , dst Start , read ) ; } else { throw new  Illegal Argument Exception ( _ STR ) ; } position += read ; return read ; }
public static  Calendar clear Time ( final  Calendar self ) { clear Time Common ( self ) ; return self ; }
public double pdf ( int k ) { return  Math . exp ( k *  Math . log ( this . mean ) -  Arithmetic . log Factorial ( k ) - this . mean ) ; }
public static void append Unpadded Integer (  String Buffer buf , long value ) { int int Value = ( int ) value ; if ( int Value == value ) { append Unpadded Integer ( buf , int Value ) ; } else { buf . append (  Long . to String ( value ) ) ; } }
private void draw Text Elements (  Canvas canvas , float text Size ,  Typeface typeface ,  Color State List text Color ,  String [ ] texts , float [ ] text X , float [ ] text Y ,  Paint paint , int alpha , boolean show Activated , int activated Degrees , boolean activated Only ) { paint . set Text Size ( text Size ) ; paint . set Typeface ( typeface ) ; final float activated Index = activated Degrees / ( _ NUM /  NUM_ POSITIONS ) ; final int activated Floor = ( int ) activated Index ; final int activated Ceil = ( ( int )  Math . ceil ( activated Index ) ) %  NUM_ POSITIONS ; for ( int i = _ NUM ; i < _ NUM ; i ++ ) { final boolean activated = ( activated Floor == i || activated Ceil == i ) ; if ( activated Only && ! activated ) { continue ; } final int [ ] state Mask = new int [ ] { android .  R . attr . state_enabled , ( show Activated && activated ? android .  R . attr . state_selected : _ NUM ) } ; final int color = text Color . get Color For State ( state Mask , _ NUM ) ; paint . set Color ( color ) ; paint . set Alpha ( get Multiplied Alpha ( color , alpha ) ) ; canvas . draw Text ( texts [ i ] , text X [ i ] , text Y [ i ] , paint ) ; } }
public void test Find Spring Active Directory With Limit ( ) {  Ldap Proxy proxy = get Ldap AD ( ) ;  List result = null ; int limit = _ NUM ; try { result = proxy . find ( get Ldap Search VO ( _ STR , limit , _ STR , _ STR , null ,  Ldap Scope Constants .  SCOPE_ SUBTREE ) ) ; } catch (  Exception e ) { } assert Not Null ( result ) ; if ( result != null ) { assert Equals ( limit , result . size ( ) ) ; } }
@  Override public void handle Key ( int virtual Key Code , int transition State , char key Char ) { switch Control Keys ( virtual Key Code , transition State ) ; input Buffer . add ( new  Global Key Event ( this , virtual Key Code , transition State , key Char , menu Pressed , shift Pressed , control Pressed , extended Key ) ) ; }
public int hash Code ( ) { return alignment ^ leader ^  Math . round ( position ) ; }
public static  String strip Leading Period (  String s ) { if ( null != s && s . starts With ( _ STR ) ) return s . substring (  Math . min ( _ NUM , s . length ( ) ) , s . length ( ) ) ; return s ; }
protected  Connection State SSLv3 (  SSLSession Impl session ) { try {  Cipher Suite cipher Suite = session . cipher Suite ; boolean is_exportabe = cipher Suite . is Exportable ( ) ; hash_size = cipher Suite . get MACLength ( ) ; int key_size = ( is_exportabe ) ? cipher Suite . key Material : cipher Suite . expanded Key Material ; int iv_size = cipher Suite . iv Size ; block_size = cipher Suite . get Block Size ( ) ;  String alg Name = cipher Suite . get Bulk Encryption Algorithm ( ) ;  String hash Name = cipher Suite . get Hash Name ( ) ; if ( logger != null ) { logger . println ( _ STR ) ; logger . println ( _ STR + session . get Cipher Suite ( ) ) ; logger . println ( _ STR + alg Name ) ; logger . println ( _ STR + hash Name ) ; logger . println ( _ STR + hash_size ) ; logger . println ( _ STR + block_size ) ; logger . println ( _ STR + iv_size ) ; logger . println ( _ STR + key_size ) ; } byte [ ] client Random = session . client Random ; byte [ ] server Random = session . server Random ; byte [ ] key_block = new byte [ _ NUM * hash_size + _ NUM * key_size + _ NUM * iv_size ] ; byte [ ] seed = new byte [ client Random . length + server Random . length ] ;  System . arraycopy ( server Random , _ NUM , seed , _ NUM , server Random . length ) ;  System . arraycopy ( client Random , _ NUM , seed , server Random . length , client Random . length ) ;  PRF . compute PRF_ SSLv3 ( key_block , session . master_secret , seed ) ; byte [ ] client_mac_secret = new byte [ hash_size ] ; byte [ ] server_mac_secret = new byte [ hash_size ] ; byte [ ] client_key = new byte [ key_size ] ; byte [ ] server_key = new byte [ key_size ] ; boolean is_client = ! session . is Server ;  System . arraycopy ( key_block , _ NUM , client_mac_secret , _ NUM , hash_size ) ;  System . arraycopy ( key_block , hash_size , server_mac_secret , _ NUM , hash_size ) ;  System . arraycopy ( key_block , _ NUM * hash_size , client_key , _ NUM , key_size ) ;  System . arraycopy ( key_block , _ NUM * hash_size + key_size , server_key , _ NUM , key_size ) ;  Iv Parameter Spec client IV = null ;  Iv Parameter Spec server IV = null ; if ( is_exportabe ) { if ( logger != null ) { logger . println ( _ STR ) ; }  Message Digest md5 =  Message Digest . get Instance ( _ STR ) ; md5 . update ( client_key ) ; md5 . update ( client Random ) ; md5 . update ( server Random ) ; client_key = md5 . digest ( ) ; md5 . update ( server_key ) ; md5 . update ( server Random ) ; md5 . update ( client Random ) ; server_key = md5 . digest ( ) ; key_size = cipher Suite . expanded Key Material ; if ( block_size != _ NUM ) { md5 . update ( client Random ) ; md5 . update ( server Random ) ; client IV = new  Iv Parameter Spec ( md5 . digest ( ) , _ NUM , iv_size ) ; md5 . update ( server Random ) ; md5 . update ( client Random ) ; server IV = new  Iv Parameter Spec ( md5 . digest ( ) , _ NUM , iv_size ) ; } } else if ( block_size != _ NUM ) { client IV = new  Iv Parameter Spec ( key_block , _ NUM * hash_size + _ NUM * key_size , iv_size ) ; server IV = new  Iv Parameter Spec ( key_block , _ NUM * hash_size + _ NUM * key_size + iv_size , iv_size ) ; } if ( logger != null ) { logger . println ( _ STR + is_exportabe ) ; logger . println ( _ STR ) ; logger . print ( session . master_secret ) ; logger . println ( _ STR ) ; logger . print ( client Random ) ; logger . println ( _ STR ) ; logger . print ( server Random ) ; logger . println ( _ STR ) ; logger . print ( client_mac_secret ) ; logger . println ( _ STR ) ; logger . print ( server_mac_secret ) ; logger . println ( _ STR ) ; logger . print ( client_key , _ NUM , key_size ) ; logger . println ( _ STR ) ; logger . print ( server_key , _ NUM , key_size ) ; if ( client IV != null ) { logger . println ( _ STR ) ; logger . print ( client IV . get IV ( ) ) ; logger . println ( _ STR ) ; logger . print ( server IV . get IV ( ) ) ; } else { logger . println ( _ STR ) ; } } if ( alg Name == null ) { enc Cipher = new  Null Cipher ( ) ; dec Cipher = new  Null Cipher ( ) ; } else { enc Cipher =  Cipher . get Instance ( alg Name ) ; dec Cipher =  Cipher . get Instance ( alg Name ) ; if ( is_client ) { enc Cipher . init (  Cipher .  ENCRYPT_ MODE , new  Secret Key Spec ( client_key , _ NUM , key_size , alg Name ) , client IV ) ; dec Cipher . init (  Cipher .  DECRYPT_ MODE , new  Secret Key Spec ( server_key , _ NUM , key_size , alg Name ) , server IV ) ; } else { enc Cipher . init (  Cipher .  ENCRYPT_ MODE , new  Secret Key Spec ( server_key , _ NUM , key_size , alg Name ) , server IV ) ; dec Cipher . init (  Cipher .  DECRYPT_ MODE , new  Secret Key Spec ( client_key , _ NUM , key_size , alg Name ) , client IV ) ; } } message Digest =  Message Digest . get Instance ( hash Name ) ; if ( is_client ) { mac_write_secret = client_mac_secret ; mac_read_secret = server_mac_secret ; } else { mac_write_secret = server_mac_secret ; mac_read_secret = client_mac_secret ; } if ( hash Name . equals ( _ STR ) ) { pad_1 =  SSLv3 Constants .  MD5pad1 ; pad_2 =  SSLv3 Constants .  MD5pad2 ; } else { pad_1 =  SSLv3 Constants .  SHApad1 ; pad_2 =  SSLv3 Constants .  SHApad2 ; } } catch (  Exception e ) { e . print Stack Trace ( ) ; throw new  Alert Exception (  Alert Protocol .  INTERNAL_ ERROR , new  SSLProtocol Exception ( _ STR ) ) ; } }
private void clean Up Labels ( ) { int id = _ NUM ; for (  Iterator <  Label > i = labels . iterator ( ) ; i . has Next ( ) ; ) {  Label label = i . next ( ) ; if ( label . is Empty ( ) ) { i . remove ( ) ; } else { label . compact ( ) ; label . id = id ++ ; } } }
public static long nanos From Date ( long ms ) {  Calendar cal = get Calendar ( ) ; cal . set Time In Millis ( ms ) ; return nanos From Calendar ( cal ) ; }
@  Override default  Completable Future <  Optional Long > max Long ( final  To Long Function < ? super  T > fn ) { return  Completable Future . supply Async ( null , get Exec ( ) ) ; }
protected  Balanced Web Resource create Https Client ( final  String username , final  String password ,  List <  String > hosts ) throws  No Such Algorithm Exception { return create Https Client ( username , password , hosts , _ BOOL ) ; }
public static char [ ] create Array Signature ( char [ ] type Signature , int array Count ) { if ( array Count == _ NUM ) return type Signature ; int sig Length = type Signature . length ; char [ ] result = new char [ array Count + sig Length ] ; for ( int i = _ NUM ; i < array Count ; i ++ ) { result [ i ] =  C_ ARRAY ; }  System . arraycopy ( type Signature , _ NUM , result , array Count , sig Length ) ; return result ; }
public void println ( ) throws  IOException { writer . write ( format . get Line Separator ( ) ) ; }
protected void increase Buffer Size ( int min Size ) { int new Length = buf . length ; while ( new Length < min Size ) new Length *= _ NUM ; double [ ] new Buf = new double [ new Length ] ; int avail = currently In Buffer ( ) ;  System . arraycopy ( buf , read Pos , new Buf , _ NUM , avail ) ; buf = new Buf ; read Pos = _ NUM ; write Pos = avail ; }
private void handle Enumerated Attribute (  Instances train Instances ) throws  Exception {  Instance instance ; m_distribution = new  Distribution ( m_complexity Index , train Instances . num Classes ( ) ) ;  Enumeration <  Instance > enu = train Instances . enumerate Instances ( ) ; while ( enu . has More Elements ( ) ) { instance = enu . next Element ( ) ; if ( ! instance . is Missing ( m_att Index ) ) { m_distribution . add ( ( int ) instance . value ( m_att Index ) , instance ) ; } } if ( m_distribution . check ( m_min No Obj ) ) { m_num Subsets = m_complexity Index ; m_info Gain = info Gain Crit . split Crit Value ( m_distribution , m_sum Of Weights ) ; m_gain Ratio = gain Ratio Crit . split Crit Value ( m_distribution , m_sum Of Weights , m_info Gain ) ; } }
@  Override protected  Node remove From Frontier ( ) {  Node result = frontier . remove ( ) ; frontier Node Lookup . remove ( result . get State ( ) ) ; explored . add ( result . get State ( ) ) ; update Metrics ( frontier . size ( ) ) ; return result ; }
public static  String encode ( byte [ ] data ) { int start = _ NUM ; int len = data . length ;  String Buffer buf = new  String Buffer ( data . length * _ NUM / _ NUM ) ; int end = len - _ NUM ; int i = start ; int n = _ NUM ; while ( i <= end ) { int d = ( ( ( ( int ) data [ i ] ) & _ NUM ) << _ NUM ) | ( ( ( ( int ) data [ i + _ NUM ] ) & _ NUM ) << _ NUM ) | ( ( ( int ) data [ i + _ NUM ] ) & _ NUM ) ; buf . append ( legal Chars [ ( d > > _ NUM ) & _ NUM ] ) ; buf . append ( legal Chars [ ( d > > _ NUM ) & _ NUM ] ) ; buf . append ( legal Chars [ ( d > > _ NUM ) & _ NUM ] ) ; buf . append ( legal Chars [ d & _ NUM ] ) ; i += _ NUM ; if ( n ++ >= _ NUM ) { n = _ NUM ; } } if ( i == start + len - _ NUM ) { int d = ( ( ( ( int ) data [ i ] ) & _ NUM ) << _ NUM ) | ( ( ( ( int ) data [ i + _ NUM ] ) & _ NUM ) << _ NUM ) ; buf . append ( legal Chars [ ( d > > _ NUM ) & _ NUM ] ) ; buf . append ( legal Chars [ ( d > > _ NUM ) & _ NUM ] ) ; buf . append ( legal Chars [ ( d > > _ NUM ) & _ NUM ] ) ; buf . append ( _ STR ) ; } else if ( i == start + len - _ NUM ) { int d = ( ( ( int ) data [ i ] ) & _ NUM ) << _ NUM ; buf . append ( legal Chars [ ( d > > _ NUM ) & _ NUM ] ) ; buf . append ( legal Chars [ ( d > > _ NUM ) & _ NUM ] ) ; buf . append ( _ STR ) ; } return buf . to String ( ) ; }
public static  Font create Bitmap Font (  String name ,  Image bitmap , int [ ] cut Offsets , int [ ] char Width ,  String charsets ) {  Font f = create Bitmap Font ( bitmap , cut Offsets , char Width , charsets ) ; bitmap Cache . put ( name , f ) ; return f ; }
static boolean is Tenured (  Memory Pool MXBean memory Pool MXBean ) { if ( memory Pool MXBean . get Type ( ) !=  Memory Type .  HEAP ) { return _ BOOL ; }  String name = memory Pool MXBean . get Name ( ) ; return name . equals ( _ STR ) || name . equals ( _ STR ) || name . equals ( _ STR ) || name . equals ( _ STR ) || name . equals ( _ STR ) || name . equals ( _ STR ) || name . equals ( _ STR ) || (  HEAP_ POOL != null && name . equals (  HEAP_ POOL ) ) ; }
public  String to Simple String ( ) {  String Buffer buffer = new  String Buffer ( ) ; buffer . append ( _ STR + ( m Label == null ? _ STR : m Label ) + _ STR + m YVals . size ( ) + _ STR ) ; return buffer . to String ( ) ; }
public static <  T >  T interpreter Only (  Callable <  T > callable ) throws  Exception { return callable . call ( ) ; }
private void add Selector For Protocol (  Properties settings ,  String protocol ,  Protocol Dispatch Selector ps ) {  String proxy = settings . get Property ( protocol ) ; if ( proxy != null ) {  Fixed Proxy Selector protocol Selector =  Proxy Util . parse Proxy Settings ( proxy ) ; ps . set Selector ( protocol , protocol Selector ) ; } }
public static void read Skel (  Buffered Reader reader ) throws  IOException {  List <  String > lines = new  Array List <  String > ( ) ;  String Builder section = new  String Builder ( ) ;  String ln ; while ( ( ln = reader . read Line ( ) ) != null ) { if ( ln . starts With ( _ STR ) ) { lines . add ( section . to String ( ) ) ; section . set Length ( _ NUM ) ; } else { section . append ( ln ) ; section . append (  NL ) ; } } if ( section . length ( ) > _ NUM ) lines . add ( section . to String ( ) ) ; if ( lines . size ( ) != size ) {  Out . error (  Error Messages .  WRONG_ SKELETON ) ; throw new  Generator Exception ( ) ; } line = new  String [ size ] ; for ( int i = _ NUM ; i < size ; i ++ ) line [ i ] = lines . get ( i ) ; }
public static  Set <  String > non Monogamous Samples (  Collection <  Family > families ) { final  Linked Hash Set <  String > ret = new  Linked Hash Set < > ( ) ; final  Hash Set <  String > parents = new  Hash Set < > ( ) ; for (  Family f : families ) { if ( ! parents . add ( f . get Father ( ) ) ) { ret . add ( f . get Father ( ) ) ; } if ( ! parents . add ( f . get Mother ( ) ) ) { ret . add ( f . get Mother ( ) ) ; } } return ret ; }
public boolean contains (  File file ,  String file Content ) { if ( exists ( file ) ) {  String content = read File Content ( file ) ; return content != null && content . equals ( file Content ) ; } return _ BOOL ; }
public static boolean [ ] [ ] load Image (  File file , char off Char ) throws  File Not Found Exception ,  Runtime Exception {  Array List <  String > rows = load Image Pad ( file , off Char ) ;  String s = rows . get ( _ NUM ) ; boolean [ ] [ ] img = new boolean [ rows . size ( ) ] [ s . length ( ) ] ; for ( int i = _ NUM ; i < rows . size ( ) ; i ++ ) { s = rows . get ( i ) ; for ( int j = _ NUM ; j < s . length ( ) ; j ++ ) { char c = s . char At ( j ) ; if ( c == off Char ) { img [ i ] [ j ] = _ BOOL ; } else { img [ i ] [ j ] = _ BOOL ; } } } return img ; }
protected void update Receipt Status When Cancelled ( final  String receipt Number ) { final  List <  Egdm Collected Receipt > egdm Collected Receipts = demand Generic DAO . get All Egdm Collected Receipts ( receipt Number ) ; if ( egdm Collected Receipts != null && ! egdm Collected Receipts . is Empty ( ) ) for ( final  Egdm Collected Receipt eg Dm Collected Receipt : egdm Collected Receipts ) { eg Dm Collected Receipt . set Status (  Demand Constants .  CANCELLED_ RECEIPT ) ; eg Dm Collected Receipt . set Updated Time ( new  Date ( ) ) ; egdm Collected Receipt DAO . update ( eg Dm Collected Receipt ) ; } }
public void add Animation ( int id ,  Animation ... animations ) { if ( m Animations . get ( id ) == null ) { m Animations . put ( id , new  Array List <  Animation > ( animations . length ) ) ; if ( id !=  Animation .  FULL_ PAGE ) { m Animated Views . add ( id ) ; } }  Array List <  Animation > anims = m Animations . get ( id ) ;  Collections . add All ( anims , animations ) ; }
@  Override protected void initialize ( ) {  List <  String > words ; super . initialize ( ) ; m_ Words = new  Hash Set <  String > ( ) ; words = read ( ) ; for (  String word : words ) { if ( ! word . starts With ( _ STR ) ) m_ Words . add ( word ) ; } }
protected boolean exists In Range (  String x , int min Length , int max Length ) { x =  String Utils . trim To Null ( x ) ; return x != null && x . length ( ) >= min Length && x . length ( ) <= max Length ; }
public synchronized void unwatch (  String path Name ) throws  IOException { unregister All (  Paths . get ( path Name ) ) ; }
public  Criteria add Property (  String name ,  String value ,  Operator operator ) { properties . add ( new  Property Criteria ( name , value , operator ) ) ; return this ; }
public void remove Column ( final  String column Name ) { if ( column Name == null ) { return ; } final  List <  String > cols =  Arrays . as List ( get Info ( ) . headers ) ; final int col Index = cols . index Of ( column Name ) ; remove Column ( col Index ) ; }
public static  Un Managed Protection Set check Un Managed Protection Set Exists In DB (  Db Client db Client ,  String native Guid ) throws  IOException {  List <  Un Managed Protection Set > cgs =  Custom Query Utility . get Un Managed Protection Set By Native Guid ( db Client , native Guid ) ;  Iterator <  Un Managed Protection Set > cgs Itr = cgs . iterator ( ) ; if ( cgs Itr . has Next ( ) ) { return cgs Itr . next ( ) ; } return null ; }
private void check Query (  String exp Res ,  String qry ) throws  Exception { assert Equals ( _ NUM , execute Hive Query ( _ STR ) ) ; assert Equals ( _ NUM , execute Hive Query ( _ STR + _ STR + _ STR + _ STR + qry ) ) ;  Igfs Input Stream in = igfs . open ( new  Igfs Path ( _ STR ) ) ; byte [ ] buf = new byte [ ( int ) in . length ( ) ] ; in . read ( buf ) ; assert Equals ( exp Res , new  String ( buf ) ) ; }
public final  V update And Get (  Unary Operator <  V > update Function ) {  V prev , next ; do { prev = get ( ) ; next = update Function . apply ( prev ) ; } while ( ! compare And Set ( prev , next ) ) ; return next ; }
public void close ( ) { stop Timers ( ) ; closed = _ BOOL ; window . dispose ( ) ; if ( listener != null ) { listener . notification Removed ( this ) ; } if ( activity Listener != null ) {  Activity Tracker . remove Activity Listener ( activity Listener ) ; } }
protected boolean should Move ( final  ILoad Balancer Service load Balancer Service ) { if ( load Balancer Service == null ) throw new  Illegal Argument Exception ( ) ; final boolean highly Utilized Service ; try { final  UUID service UUID = resource Manager . get Data Service UUID ( ) ; highly Utilized Service = load Balancer Service . is Highly Utilized Data Service ( service UUID ) ; } catch (  Exception ex ) { log . warn ( _ STR ) ; return _ BOOL ; } if ( ! highly Utilized Service ) { if ( log . is Info Enabled ( ) ) log . info ( _ STR ) ; return _ BOOL ; } final  Resource Scores resource Scores = resource Manager . get Resource Scores ( ) ; final boolean should Move = ( resource Scores . percent CPUTime >= resource Manager . move Percent Cpu Time Threshold ) || ( resource Scores . major Page Faults Per Sec > _ NUM ) || ( resource Scores . data Dir Bytes Free <  Bytes . gigabyte * _ NUM ) || ( resource Scores . data Dir Bytes Free <  Bytes . gigabyte * _ NUM ) ; return should Move ; }
private static  Object [ ] convert Throwable Messages ( final  Object [ ] args ) { if ( args != null ) { for ( int i = _ NUM ; i < args . length ; i ++ ) { if ( args [ i ] instanceof  Throwable ) {  Throwable t = (  Throwable ) args [ i ] ; if ( t . get Message ( ) != null ) { args [ i ] = t . get Message ( ) ; } } } } return args ; }
protected void wrap Content ( ) { if ( !  DO_ WRAP ) { return ; } if ( m Text == null ) { return ; }  Canvas c = new  Canvas ( ) ; c . set Font ( m Font ) ;  Font Metrics fm = c . get Font Metrics ( m Font ) ;  String string = get Text ( ) ; if ( m To Upper Case ) { string = string . to Upper Case ( ) ; } int tw = fm . string Width ( string ) + _ NUM * ( m Horizontal Padding + m Horizontal Margin ) ; int th = fm . get Max Ascent ( ) + _ NUM * fm . get Max Descent ( ) + _ NUM * ( m Vertical Padding + m Vertical Margin ) ; m Widget . set Wrap Width ( tw ) ; m Widget . set Wrap Height ( th ) ; if ( tw > m Widget . get Min Width ( ) ) { m Widget . set Min Width ( tw ) ; } if ( th > m Widget . get Min Height ( ) ) { m Widget . set Min Height ( th ) ; } if ( m Widget . get Horizontal Dimension Behaviour ( ) ==  Constraint Widget .  Dimension Behaviour .  WRAP_ CONTENT ) { m Widget . set Width ( tw ) ; } if ( m Widget . get Vertical Dimension Behaviour ( ) ==  Constraint Widget .  Dimension Behaviour .  WRAP_ CONTENT ) { m Widget . set Height ( th ) ; } if ( m Widget . get Horizontal Dimension Behaviour ( ) ==  Constraint Widget .  Dimension Behaviour .  FIXED ) { if ( m Widget . get Width ( ) <= m Widget . get Min Width ( ) ) { m Widget . set Horizontal Dimension Behaviour (  Constraint Widget .  Dimension Behaviour .  WRAP_ CONTENT ) ; } } if ( m Widget . get Vertical Dimension Behaviour ( ) ==  Constraint Widget .  Dimension Behaviour .  FIXED ) { if ( m Widget . get Height ( ) <= m Widget . get Min Height ( ) ) { m Widget . set Vertical Dimension Behaviour (  Constraint Widget .  Dimension Behaviour .  WRAP_ CONTENT ) ; } } int baseline = fm . get Ascent ( ) + fm . get Max Descent ( ) + m Vertical Padding + m Vertical Margin ; m Widget . set Baseline Distance ( baseline ) ; }
public  RAFDirectory (  Path path ,  Lock Factory lock Factory ) throws  IOException { super ( path , lock Factory ) ; path . to File ( ) ; }
public static void add Minutes To List (  Context context ,  Array List <  Integer > values ,  Array List <  String > labels , int minutes ) { int index = values . index Of ( minutes ) ; if ( index != - _ NUM ) { return ; }  String label = construct Reminder Label ( context , minutes , _ BOOL ) ; int len = values . size ( ) ; for ( int i = _ NUM ; i < len ; i ++ ) { if ( minutes < values . get ( i ) ) { values . add ( i , minutes ) ; labels . add ( i , label ) ; return ; } } values . add ( minutes ) ; labels . add ( len , label ) ; }
public void property Change (  Property Change Event e ) {  String property Name = e . get Property Name ( ) ; if ( property Name == _ STR ) { if ( e . get Old Value ( ) ==  Boolean .  FALSE && e . get New Value ( ) ==  Boolean .  TRUE ) { handle Popup Is Visible Event ( _ BOOL ) ; } else if ( e . get Old Value ( ) ==  Boolean .  TRUE && e . get New Value ( ) ==  Boolean .  FALSE ) { handle Popup Is Visible Event ( _ BOOL ) ; } } }
private static int [ ] maybe Sort ( int [ ] values ) { if ( ! is Sorted ( values , _ NUM , _ BOOL ) ) { values = values . clone ( ) ;  Arrays . sort ( values ) ; } return values ; }
private void do Text Normal ( final  PDFPage cmds , final  String text ) { final  Point F zero = new  Point F ( ) ; final  Matrix scale = new  Matrix ( ) ;  Utils . set Mat Values ( scale , fsize , _ NUM , _ NUM , fsize * th , _ NUM , tr ) ; final  Matrix at = new  Matrix ( ) ; final  List <  PDFGlyph > l = (  List <  PDFGlyph > ) font . get Glyphs ( text ) ; for ( final  PDFGlyph glyph : l ) { at . set ( cur ) ; at . pre Concat ( scale ) ; final  Point F advance = glyph . add Commands ( cmds , at , tm ) ; float advance X = ( advance . x * fsize ) + tc ; if ( glyph . get Char ( ) == _ STR ) { advance X += tw ; } advance X *= th ; cur . pre Translate ( advance X , advance . y ) ; } final float [ ] src = { zero . x , zero . y } ; final float [ ] dst = new float [ src . length ] ; cur . map Points ( dst , src ) ; prev End . set ( dst [ _ NUM ] , dst [ _ NUM ] ) ; }
public synchronized static void initialize (  Connection conn ) throws  SQLException { if ( log Hadoop Id Patterns != null && log Lineage Patterns != null ) { return ; } load Lineage Patterns ( conn ) ; load Hadoop Id Patterns ( conn ) ; }
public void add Indices (  Collection <  IIndex > indices ) { for (  Iterator <  IIndex > it = indices . iterator ( ) ; it . has Next ( ) ; ) { add Index ( (  IIndex ) it . next ( ) ) ; } }
public static boolean is Cookie Secure ( ) { return secure Cookie ; }
public static  List <  Object Model > load Json Stream (  Input Stream input ) {  List <  Object Model > models = new  Array List < > ( ) ;  Reader reader = new  Input Stream Reader ( input ) ;  Object Model [ ] object Models =  GSON . from Json ( reader ,  Object Model [ ] . class ) ; for (  Object Model object Model : object Models ) { models . add ( object Model ) ; } return models ; }
private int add Wordlen Weights (  Channel chan , int weight Idx ) { int [ ] weigths Tab = atrac3p_wl_weights [ chan . ch Num * _ NUM + weight Idx - _ NUM ] ; for ( int i = _ NUM ; i < ctx . num Quant Units ; i ++ ) { chan . qu Wordlen [ i ] += weigths Tab [ i ] ; if ( chan . qu Wordlen [ i ] < _ NUM || chan . qu Wordlen [ i ] > _ NUM ) { log . error (  String . format ( _ STR , i , chan . qu Wordlen [ i ] ) ) ; return  AT3 P_ ERROR ; } } return _ NUM ; }
final void prune Exceptional Out (  IR ir ) { int n = get Number Of Exceptional Out ( ) ; if ( n > _ NUM ) {  Computed BBEnum handlers = new  Computed BBEnum ( n ) ;  Enumeration <  Instruction > e = forward Real Instr Enumerator ( ) ; while ( e . has More Elements ( ) ) {  Instruction x = e . next Element ( ) ;  Enumeration <  Basic Block > bbs = get Applicable Exceptional Out ( x ) ; while ( bbs . has More Elements ( ) ) {  Basic Block bb = bbs . next Element ( ) ; handlers . add Possibly Duplicate Element ( bb ) ; } } delete Exceptional Out ( ) ; for ( int i = _ NUM ; handlers . has More Elements ( ) ; i ++ ) {  Exception Handler Basic Block b = (  Exception Handler Basic Block ) handlers . next Element ( ) ; insert Out ( b ) ; } } recompute Normal Out ( ir ) ; }
private  Pair <  DBIDVar ,  Double > single Iteration (  Relation <  V > relationx ,  Relation < ? extends  Number Vector > relationy ) { final int dim =  Relation Util . dimensionality ( relationx ) ; final int dimy =  Relation Util . dimensionality ( relationy ) ; assert ( dim == _ NUM ) ;  KNNQuery <  V > knn Query =  Query Util . get KNNQuery ( relationx , get Distance Function ( ) , k + _ NUM ) ;  Array Modifiable DBIDs ids =  DBIDUtil . new Array ( relationx . get DBIDs ( ) ) ; ids . sort ( ) ; double [ ] [ ]  X = new double [ ids . size ( ) ] [ _ NUM ] ; double [ ] [ ]  F = new double [ ids . size ( ) ] [ ids . size ( ) ] ; double [ ] [ ]  Y = new double [ ids . size ( ) ] [ dimy ] ; { int i = _ NUM ; for (  DBIDIter id = ids . iter ( ) ; id . valid ( ) ; id . advance ( ) , i ++ ) { {  V vec = relationx . get ( id ) ; double la = vec . double Value ( _ NUM ) ; double lo = vec . double Value ( _ NUM ) ;  X [ i ] [ _ NUM ] = _ NUM ;  X [ i ] [ _ NUM ] = la ;  X [ i ] [ _ NUM ] = lo ;  X [ i ] [ _ NUM ] = la * lo ;  X [ i ] [ _ NUM ] = la * la ;  X [ i ] [ _ NUM ] = lo * lo ; } { final  Number Vector vecy = relationy . get ( id ) ; for ( int d = _ NUM ; d < dimy ; d ++ ) { double idy = vecy . double Value ( d ) ;  Y [ i ] [ d ] = idy ; } } {  KNNList neighbors = knn Query . get KNNFor DBID ( id , k + _ NUM ) ;  Modifiable DBIDs neighborhood =  DBIDUtil . new Array ( neighbors . size ( ) ) ; for (  DBIDIter neighbor = neighbors . iter ( ) ; neighbor . valid ( ) ; neighbor . advance ( ) ) { if (  DBIDUtil . equal ( id , neighbor ) ) { continue ; } neighborhood . add ( neighbor ) ; }  F [ i ] [ i ] = _ NUM ; final int nweight = - _ NUM / neighborhood . size ( ) ; for (  DBIDIter iter = neighborhood . iter ( ) ; iter . valid ( ) ; iter . advance ( ) ) { int pos = ids . binary Search ( iter ) ; assert ( pos >= _ NUM ) ;  F [ pos ] [ i ] = nweight ; } } } } double [ ] [ ] common = times ( transpose Times Transpose (  X ,  F ) ,  F ) ; double [ ] [ ] b = times ( inverse ( times ( common ,  X ) ) , times ( common ,  Y ) ) ; double [ ] [ ] sigma Mat = times (  F , minus Equals ( times (  X , b ) , times (  F ,  Y ) ) ) ; final double sigma_sum_square = norm F ( sigma Mat ) / ( relationx . size ( ) - _ NUM - _ NUM ) ; final double norm = _ NUM /  Math . sqrt ( sigma_sum_square ) ; double [ ] [ ]  E = times Equals ( times (  F , minus (  Y , times (  X , b ) ) ) , norm ) ;  DBIDVar worstid =  DBIDUtil . new Var ( ) ; double worstscore =  Double .  NEGATIVE_ INFINITY ; int i = _ NUM ; for (  DBIDIter id = ids . iter ( ) ; id . valid ( ) ; id . advance ( ) , i ++ ) { double err = square Sum ( get Row (  E , i ) ) ; if ( err > worstscore ) { worstscore = err ; worstid . set ( id ) ; } } return new  Pair < > ( worstid ,  Math . sqrt ( worstscore ) ) ; }
private void cleanup Minidump File ( ) { if ( !  Crash File Manager . try Mark As Uploaded ( m File To Upload ) ) {  Log . w (  TAG , _ STR + m File To Upload + _ STR ) ; if ( ! m File To Upload . delete ( ) ) {  Log . w (  TAG , _ STR + m File To Upload ) ; } } }
public  String to Spaced String ( ) { final  String original = to String ( ) ; final  String Builder builder = new  String Builder ( ) ; for ( int i = _ NUM ; i < original . length ( ) ; i ++ ) { if ( i > _ NUM && ( i % _ NUM ) == _ NUM ) builder . append ( _ STR ) ; builder . append ( original . char At ( i ) ) ; } return builder . to String ( ) ; }
private int parse Content Type ( final byte [ ] b , final int off ) throws  Parse Exception { content Type Val_ =  Primitives Parser . parse Byte ( b , off ) ; if (  Content Type . deserialize ( content Type Val_ ) == null ) { throw new  Bad Ciphertext Exception ( _ STR ) ; } return _ NUM ; }
@  Benchmark public void non Caching ( ) { run ( ) ; }
private void r Line To ( float dx , float dy ) { if ( is Empty ( ) ) { m Path . move To ( m Last X = _ NUM , m Last Y = _ NUM ) ; } dx += m Last X ; dy += m Last Y ; m Path . line To ( m Last X = dx , m Last Y = dy ) ; }
@  Override public  Conflict Results parse Output ( final  String stdout , final  String stderr ) { final  List <  String > content Conflicts = new  Array List <  String > ( ) ; final  List <  String > rename Conflicts = new  Array List <  String > ( ) ; final  List <  String > both Conflicts = new  Array List <  String > ( ) ; final  String [ ] lines = get Lines ( stderr ) ; for ( final  String line : lines ) { final int index = line . last Index Of ( _ STR ) ; if ( index != - _ NUM ) { if (  String Utils . ends With ( line ,  BOTH_ CONFLICTS_ SUFFIX ) ) { both Conflicts . add ( line . substring ( _ NUM , index ) ) ; } else if (  String Utils . ends With ( line ,  RENAME_ CONFLICT_ SUFFIX ) ) { rename Conflicts . add ( line . substring ( _ NUM , index ) ) ; } else { content Conflicts . add ( line . substring ( _ NUM , index ) ) ; } } } return new  Conflict Results ( content Conflicts , rename Conflicts , both Conflicts ) ; }
protected void send Start ( final  Output Stream out ) throws  IOException {  LOG . trace ( _ STR ) ; out . write (  EXTRA_ BYTES ) ; out . write ( get Part Boundary ( ) ) ; out . write (  CRLF_ BYTES ) ; }
public void add Actual Qty (  Big Decimal add ) { m_actual Qty = m_actual Qty . add ( add ) ; }
protected static boolean is Vowel ( final char c ) { final char l =  Character . to Lower Case ( c ) ; return ( ( l == _ STR ) || ( l == _ STR ) || ( l == _ STR ) || ( l == _ STR ) || ( l == _ STR ) ) ; }
public static void print Stack Trace (  SQLException e ,  Print Writer pw ) {  SQLException next = e ; while ( next != null ) { next . print Stack Trace ( pw ) ; next = next . get Next Exception ( ) ; if ( next != null ) { pw . println ( _ STR ) ; } } }
protected void initialize World ( ) {  Body ground = new  Simulation Body ( ) ; {  Convex c =  Geometry . create Rectangle ( _ NUM , _ NUM ) ;  Body Fixture bf = new  Body Fixture ( c ) ; ground . add Fixture ( bf ) ; } ground . translate ( new  Vector2 ( _ NUM , - _ NUM ) ) ; ground . set Mass (  Mass Type .  INFINITE ) ; world . add Body ( ground ) ;  Body head = new  Simulation Body ( ) ; {  Convex c =  Geometry . create Circle ( _ NUM ) ;  Body Fixture bf = new  Body Fixture ( c ) ; head . add Fixture ( bf ) ; } head . set Mass (  Mass Type .  NORMAL ) ; world . add Body ( head ) ;  Body torso = new  Simulation Body ( ) ; {  Convex c =  Geometry . create Rectangle ( _ NUM , _ NUM ) ;  Body Fixture bf = new  Body Fixture ( c ) ; torso . add Fixture ( bf ) ; } {  Convex c =  Geometry . create Rectangle ( _ NUM , _ NUM ) ; c . translate ( new  Vector2 ( _ NUM , _ NUM ) ) ;  Body Fixture bf = new  Body Fixture ( c ) ; torso . add Fixture ( bf ) ; } torso . translate ( new  Vector2 ( _ NUM , - _ NUM ) ) ; torso . set Mass (  Mass Type .  NORMAL ) ; world . add Body ( torso ) ;  Body right Humerus = new  Simulation Body ( ) ; {  Convex c =  Geometry . create Rectangle ( _ NUM , _ NUM ) ;  Body Fixture bf = new  Body Fixture ( c ) ; right Humerus . add Fixture ( bf ) ; } right Humerus . translate ( new  Vector2 ( _ NUM , - _ NUM ) ) ; right Humerus . set Mass (  Mass Type .  NORMAL ) ; world . add Body ( right Humerus ) ;  Body right Ulna = new  Simulation Body ( ) ; {  Convex c =  Geometry . create Rectangle ( _ NUM , _ NUM ) ;  Body Fixture bf = new  Body Fixture ( c ) ; right Ulna . add Fixture ( bf ) ; } right Ulna . translate ( new  Vector2 ( _ NUM , - _ NUM ) ) ; right Ulna . set Mass (  Mass Type .  NORMAL ) ; world . add Body ( right Ulna ) ;  Body neck = new  Simulation Body ( ) ; {  Convex c =  Geometry . create Rectangle ( _ NUM , _ NUM ) ;  Body Fixture bf = new  Body Fixture ( c ) ; neck . add Fixture ( bf ) ; } neck . translate ( new  Vector2 ( _ NUM , - _ NUM ) ) ; neck . set Mass (  Mass Type .  NORMAL ) ; world . add Body ( neck ) ;  Body left Humerus = new  Simulation Body ( ) ; {  Convex c =  Geometry . create Rectangle ( _ NUM , _ NUM ) ;  Body Fixture bf = new  Body Fixture ( c ) ; left Humerus . add Fixture ( bf ) ; } left Humerus . translate ( new  Vector2 ( - _ NUM , - _ NUM ) ) ; left Humerus . set Mass (  Mass Type .  NORMAL ) ; world . add Body ( left Humerus ) ;  Body left Ulna = new  Simulation Body ( ) ; {  Convex c =  Geometry . create Rectangle ( _ NUM , _ NUM ) ;  Body Fixture bf = new  Body Fixture ( c ) ; left Ulna . add Fixture ( bf ) ; } left Ulna . translate ( new  Vector2 ( - _ NUM , - _ NUM ) ) ; left Ulna . set Mass (  Mass Type .  NORMAL ) ; world . add Body ( left Ulna ) ;  Body right Femur = new  Simulation Body ( ) ; {  Convex c =  Geometry . create Rectangle ( _ NUM , _ NUM ) ;  Body Fixture bf = new  Body Fixture ( c ) ; right Femur . add Fixture ( bf ) ; } right Femur . translate ( new  Vector2 ( _ NUM , - _ NUM ) ) ; right Femur . set Mass (  Mass Type .  NORMAL ) ; world . add Body ( right Femur ) ;  Body left Femur = new  Simulation Body ( ) ; {  Convex c =  Geometry . create Rectangle ( _ NUM , _ NUM ) ;  Body Fixture bf = new  Body Fixture ( c ) ; left Femur . add Fixture ( bf ) ; } left Femur . translate ( new  Vector2 ( - _ NUM , - _ NUM ) ) ; left Femur . set Mass (  Mass Type .  NORMAL ) ; world . add Body ( left Femur ) ;  Body right Tibia = new  Simulation Body ( ) ; {  Convex c =  Geometry . create Rectangle ( _ NUM , _ NUM ) ;  Body Fixture bf = new  Body Fixture ( c ) ; right Tibia . add Fixture ( bf ) ; } right Tibia . translate ( new  Vector2 ( _ NUM , - _ NUM ) ) ; right Tibia . set Mass (  Mass Type .  NORMAL ) ; world . add Body ( right Tibia ) ;  Body left Tibia = new  Simulation Body ( ) ; {  Convex c =  Geometry . create Rectangle ( _ NUM , _ NUM ) ;  Body Fixture bf = new  Body Fixture ( c ) ; left Tibia . add Fixture ( bf ) ; } left Tibia . translate ( new  Vector2 ( - _ NUM , - _ NUM ) ) ; left Tibia . set Mass (  Mass Type .  NORMAL ) ; world . add Body ( left Tibia ) ;  Revolute Joint head To Neck = new  Revolute Joint ( head , neck , new  Vector2 ( _ NUM , - _ NUM ) ) ; head To Neck . set Limit Enabled ( _ BOOL ) ; head To Neck . set Limits (  Math . to Radians ( _ NUM ) ,  Math . to Radians ( _ NUM ) ) ; head To Neck . set Reference Angle (  Math . to Radians ( _ NUM ) ) ; head To Neck . set Motor Enabled ( _ BOOL ) ; head To Neck . set Motor Speed (  Math . to Radians ( _ NUM ) ) ; head To Neck . set Maximum Motor Torque ( _ NUM ) ; head To Neck . set Collision Allowed ( _ BOOL ) ; world . add Joint ( head To Neck ) ;  Revolute Joint neck To Torso = new  Revolute Joint ( neck , torso , new  Vector2 ( _ NUM , - _ NUM ) ) ; neck To Torso . set Limit Enabled ( _ BOOL ) ; neck To Torso . set Limits (  Math . to Radians ( _ NUM ) ,  Math . to Radians ( _ NUM ) ) ; neck To Torso . set Reference Angle (  Math . to Radians ( _ NUM ) ) ; neck To Torso . set Motor Enabled ( _ BOOL ) ; neck To Torso . set Motor Speed (  Math . to Radians ( _ NUM ) ) ; neck To Torso . set Maximum Motor Torque ( _ NUM ) ; neck To Torso . set Collision Allowed ( _ BOOL ) ; world . add Joint ( neck To Torso ) ;  Revolute Joint torso To Left Humerus = new  Revolute Joint ( torso , left Humerus , new  Vector2 ( - _ NUM , - _ NUM ) ) ; torso To Left Humerus . set Limit Enabled ( _ BOOL ) ; torso To Left Humerus . set Limits (  Math . to Radians ( _ NUM ) ,  Math . to Radians ( _ NUM ) ) ; torso To Left Humerus . set Reference Angle (  Math . to Radians ( _ NUM ) ) ; torso To Left Humerus . set Motor Enabled ( _ BOOL ) ; torso To Left Humerus . set Motor Speed (  Math . to Radians ( _ NUM ) ) ; torso To Left Humerus . set Maximum Motor Torque ( _ NUM ) ; torso To Left Humerus . set Collision Allowed ( _ BOOL ) ; world . add Joint ( torso To Left Humerus ) ;  Revolute Joint torso To Right Humerus = new  Revolute Joint ( torso , right Humerus , new  Vector2 ( _ NUM , - _ NUM ) ) ; torso To Right Humerus . set Limit Enabled ( _ BOOL ) ; torso To Right Humerus . set Limits (  Math . to Radians ( _ NUM ) ,  Math . to Radians ( _ NUM ) ) ; torso To Right Humerus . set Reference Angle (  Math . to Radians ( _ NUM ) ) ; torso To Right Humerus . set Motor Enabled ( _ BOOL ) ; torso To Right Humerus . set Motor Speed (  Math . to Radians ( _ NUM ) ) ; torso To Right Humerus . set Maximum Motor Torque ( _ NUM ) ; torso To Right Humerus . set Collision Allowed ( _ BOOL ) ; world . add Joint ( torso To Right Humerus ) ;  Revolute Joint right Humerus To Right Ulna = new  Revolute Joint ( right Humerus , right Ulna , new  Vector2 ( _ NUM , - _ NUM ) ) ; right Humerus To Right Ulna . set Limit Enabled ( _ BOOL ) ; right Humerus To Right Ulna . set Limits (  Math . to Radians ( _ NUM ) ,  Math . to Radians ( _ NUM ) ) ; right Humerus To Right Ulna . set Reference Angle (  Math . to Radians ( _ NUM ) ) ; right Humerus To Right Ulna . set Motor Enabled ( _ BOOL ) ; right Humerus To Right Ulna . set Motor Speed (  Math . to Radians ( _ NUM ) ) ; right Humerus To Right Ulna . set Maximum Motor Torque ( _ NUM ) ; right Humerus To Right Ulna . set Collision Allowed ( _ BOOL ) ; world . add Joint ( right Humerus To Right Ulna ) ;  Revolute Joint left Humerus To Left Ulna = new  Revolute Joint ( left Humerus , left Ulna , new  Vector2 ( - _ NUM , - _ NUM ) ) ; left Humerus To Left Ulna . set Limit Enabled ( _ BOOL ) ; left Humerus To Left Ulna . set Limits (  Math . to Radians ( _ NUM ) ,  Math . to Radians ( _ NUM ) ) ; left Humerus To Left Ulna . set Reference Angle (  Math . to Radians ( _ NUM ) ) ; left Humerus To Left Ulna . set Motor Enabled ( _ BOOL ) ; left Humerus To Left Ulna . set Motor Speed (  Math . to Radians ( _ NUM ) ) ; left Humerus To Left Ulna . set Maximum Motor Torque ( _ NUM ) ; left Humerus To Left Ulna . set Collision Allowed ( _ BOOL ) ; world . add Joint ( left Humerus To Left Ulna ) ;  Revolute Joint torso To Right Femur = new  Revolute Joint ( torso , right Femur , new  Vector2 ( _ NUM , - _ NUM ) ) ; torso To Right Femur . set Limit Enabled ( _ BOOL ) ; torso To Right Femur . set Limits (  Math . to Radians ( _ NUM ) ,  Math . to Radians ( _ NUM ) ) ; torso To Right Femur . set Reference Angle (  Math . to Radians ( _ NUM ) ) ; torso To Right Femur . set Motor Enabled ( _ BOOL ) ; torso To Right Femur . set Motor Speed (  Math . to Radians ( _ NUM ) ) ; torso To Right Femur . set Maximum Motor Torque ( _ NUM ) ; torso To Right Femur . set Collision Allowed ( _ BOOL ) ; world . add Joint ( torso To Right Femur ) ;  Revolute Joint torso To Left Femur = new  Revolute Joint ( torso , left Femur , new  Vector2 ( - _ NUM , - _ NUM ) ) ; torso To Left Femur . set Limit Enabled ( _ BOOL ) ; torso To Left Femur . set Limits (  Math . to Radians ( _ NUM ) ,  Math . to Radians ( _ NUM ) ) ; torso To Left Femur . set Reference Angle (  Math . to Radians ( _ NUM ) ) ; torso To Left Femur . set Motor Enabled ( _ BOOL ) ; torso To Left Femur . set Motor Speed (  Math . to Radians ( _ NUM ) ) ; torso To Left Femur . set Maximum Motor Torque ( _ NUM ) ; torso To Left Femur . set Collision Allowed ( _ BOOL ) ; world . add Joint ( torso To Left Femur ) ;  Revolute Joint right Femur To Right Tibia = new  Revolute Joint ( right Femur , right Tibia , new  Vector2 ( _ NUM , - _ NUM ) ) ; right Femur To Right Tibia . set Limit Enabled ( _ BOOL ) ; right Femur To Right Tibia . set Limits (  Math . to Radians ( _ NUM ) ,  Math . to Radians ( _ NUM ) ) ; right Femur To Right Tibia . set Reference Angle (  Math . to Radians ( _ NUM ) ) ; right Femur To Right Tibia . set Motor Enabled ( _ BOOL ) ; right Femur To Right Tibia . set Motor Speed (  Math . to Radians ( _ NUM ) ) ; right Femur To Right Tibia . set Maximum Motor Torque ( _ NUM ) ; right Femur To Right Tibia . set Collision Allowed ( _ BOOL ) ; world . add Joint ( right Femur To Right Tibia ) ;  Revolute Joint left Femur To Left Tibia = new  Revolute Joint ( left Femur , left Tibia , new  Vector2 ( - _ NUM , - _ NUM ) ) ; left Femur To Left Tibia . set Limit Enabled ( _ BOOL ) ; left Femur To Left Tibia . set Limits (  Math . to Radians ( _ NUM ) ,  Math . to Radians ( _ NUM ) ) ; left Femur To Left Tibia . set Reference Angle (  Math . to Radians ( _ NUM ) ) ; left Femur To Left Tibia . set Motor Enabled ( _ BOOL ) ; left Femur To Left Tibia . set Motor Speed (  Math . to Radians ( _ NUM ) ) ; left Femur To Left Tibia . set Maximum Motor Torque ( _ NUM ) ; left Femur To Left Tibia . set Collision Allowed ( _ BOOL ) ; world . add Joint ( left Femur To Left Tibia ) ; }
public void read Data (  Data Input din ) throws  IOException { byte Count = din . read Byte ( ) ; status = din . read Unsigned Short ( ) ; event Count = din . read Unsigned Short ( ) ; message Count = din . read Unsigned Short ( ) ; events = new byte [ byte Count - _ NUM ] ; if ( events . length > _ NUM ) { din . read Fully ( events , _ NUM , events . length ) ; } }
public  E remove ( int index ) { final  Reentrant Lock lock = this . lock ; lock . lock ( ) ; try {  Object [ ] elements = get Array ( ) ; int len = elements . length ;  E old Value = get ( elements , index ) ; int num Moved = len - index - _ NUM ; if ( num Moved == _ NUM ) set Array (  Arrays . copy Of ( elements , len - _ NUM ) ) ; else {  Object [ ] new Elements = new  Object [ len - _ NUM ] ;  System . arraycopy ( elements , _ NUM , new Elements , _ NUM , index ) ;  System . arraycopy ( elements , index + _ NUM , new Elements , index , num Moved ) ; set Array ( new Elements ) ; } return old Value ; } finally { lock . unlock ( ) ; } }
void create Edges (  Number [ ] v ) { graph . add Edge ( new  Double (  Math . random ( ) ) , v [ _ NUM ] , v [ _ NUM ] ,  Edge Type .  DIRECTED ) ; graph . add Edge ( new  Double (  Math . random ( ) ) , v [ _ NUM ] , v [ _ NUM ] ,  Edge Type .  DIRECTED ) ; graph . add Edge ( new  Double (  Math . random ( ) ) , v [ _ NUM ] , v [ _ NUM ] ,  Edge Type .  DIRECTED ) ; graph . add Edge ( new  Double (  Math . random ( ) ) , v [ _ NUM ] , v [ _ NUM ] ,  Edge Type .  DIRECTED ) ; graph . add Edge ( new  Double (  Math . random ( ) ) , v [ _ NUM ] , v [ _ NUM ] ,  Edge Type .  DIRECTED ) ; graph . add Edge ( new  Double (  Math . random ( ) ) , v [ _ NUM ] , v [ _ NUM ] ,  Edge Type .  DIRECTED ) ; graph . add Edge ( new  Double (  Math . random ( ) ) , v [ _ NUM ] , v [ _ NUM ] ,  Edge Type .  DIRECTED ) ; graph . add Edge ( new  Double (  Math . random ( ) ) , v [ _ NUM ] , v [ _ NUM ] ,  Edge Type .  DIRECTED ) ; graph . add Edge ( new  Double (  Math . random ( ) ) , v [ _ NUM ] , v [ _ NUM ] ,  Edge Type .  DIRECTED ) ; graph . add Edge ( new  Double (  Math . random ( ) ) , v [ _ NUM ] , v [ _ NUM ] ,  Edge Type .  DIRECTED ) ; graph . add Edge ( new  Double (  Math . random ( ) ) , v [ _ NUM ] , v [ _ NUM ] ,  Edge Type .  DIRECTED ) ; graph . add Edge ( new  Double (  Math . random ( ) ) , v [ _ NUM ] , v [ _ NUM ] ,  Edge Type .  DIRECTED ) ; graph . add Edge ( new  Double (  Math . random ( ) ) , v [ _ NUM ] , v [ _ NUM ] ,  Edge Type .  DIRECTED ) ; graph . add Edge ( new  Double (  Math . random ( ) ) , v [ _ NUM ] , v [ _ NUM ] ,  Edge Type .  DIRECTED ) ; graph . add Edge ( new  Double (  Math . random ( ) ) , v [ _ NUM ] , v [ _ NUM ] ,  Edge Type .  DIRECTED ) ; graph . add Edge ( new  Double (  Math . random ( ) ) , v [ _ NUM ] , v [ _ NUM ] ,  Edge Type .  DIRECTED ) ; graph . add Edge ( new  Double (  Math . random ( ) ) , v [ _ NUM ] , v [ _ NUM ] ,  Edge Type .  DIRECTED ) ; graph . add Edge ( new  Double (  Math . random ( ) ) , v [ _ NUM ] , v [ _ NUM ] ,  Edge Type .  DIRECTED ) ; graph . add Edge ( new  Double (  Math . random ( ) ) , v [ _ NUM ] , v [ _ NUM ] ,  Edge Type .  DIRECTED ) ; }
@  Suppress Warnings ( _ STR ) public  Data Response paginate List (  Map <  String ,  String > request Params ,  Paginate Request paginate Request ,  Object query ,  String default Sort ,  Map properties ) { if ( paginate Request == null ) { paginate Request = new  Paginate Request ( ) ; } if ( paginate Request . get Start ( ) == null ) { paginate Request . set Start (  Request Util . get Integer ( request Params , _ STR , _ NUM ) ) ; } if ( paginate Request . get Size ( ) == null ) { paginate Request . set Size (  Request Util . get Integer ( request Params , _ STR , _ NUM ) ) ; } if ( paginate Request . get Order ( ) == null ) { paginate Request . set Order ( request Params . get ( _ STR ) ) ; } if ( paginate Request . get Sort ( ) == null ) { paginate Request . set Sort ( request Params . get ( _ STR ) ) ; }  Integer start = paginate Request . get Start ( ) ; if ( start == null || start < _ NUM ) { start = _ NUM ; }  Integer size = paginate Request . get Size ( ) ; if ( size == null || size < _ NUM ) { size = _ NUM ; }  String sort = paginate Request . get Sort ( ) ; if ( sort == null ) { sort = default Sort ; }  String order = paginate Request . get Order ( ) ; if ( order == null ) { order = _ STR ; } if ( sort != null && ! properties . is Empty ( ) ) {  Object qp = properties . get ( sort ) ; if ( qp == null ) { throw new  Activiti Illegal Argument Exception ( _ STR + sort + _ STR ) ; } if ( query instanceof  Abstract Query ) {  Abstract Query query Object = (  Abstract Query ) query ;  Query Property query Property = (  Query Property ) qp ; query Object . order By ( query Property ) ; if ( order . equals ( _ STR ) ) { query Object . asc ( ) ; } else if ( order . equals ( _ STR ) ) { query Object . desc ( ) ; } else { throw new  Activiti Illegal Argument Exception ( _ STR + order + _ STR ) ; } } else if ( query instanceof org . activiti . idm . engine . impl .  Abstract Query ) { org . activiti . idm . engine . impl .  Abstract Query query Object = ( org . activiti . idm . engine . impl .  Abstract Query ) query ; org . activiti . idm . api .  Query Property query Property = ( org . activiti . idm . api .  Query Property ) qp ; query Object . order By ( query Property ) ; if ( order . equals ( _ STR ) ) { query Object . asc ( ) ; } else if ( order . equals ( _ STR ) ) { query Object . desc ( ) ; } else { throw new  Activiti Illegal Argument Exception ( _ STR + order + _ STR ) ; } } }  Data Response response = new  Data Response ( ) ; response . set Start ( start ) ; response . set Sort ( sort ) ; response . set Order ( order ) ; if ( query instanceof  Abstract Query ) {  Abstract Query query Object = (  Abstract Query ) query ;  List list = process List ( query Object . list Page ( start , size ) ) ; response . set Total ( query Object . count ( ) ) ; response . set Size ( list . size ( ) ) ; response . set Data ( list ) ; } else if ( query instanceof org . activiti . idm . engine . impl .  Abstract Query ) { org . activiti . idm . engine . impl .  Abstract Query query Object = ( org . activiti . idm . engine . impl .  Abstract Query ) query ;  List list = process List ( query Object . list Page ( start , size ) ) ; response . set Total ( query Object . count ( ) ) ; response . set Size ( list . size ( ) ) ; response . set Data ( list ) ; } return response ; }
private static <  T extends  Component >  T build Row ( final  JPanel panel , final  String label Text , final  String hint , final  T component , final boolean is Last ) { component . set Preferred Size ( new  Dimension (  COLORPANEL_ WIDTH ,  COLORPANEL_ HEIGHT ) ) ; final  JPanel row Panel = new  JPanel ( new  Border Layout ( ) ) ; row Panel . set Border ( new  Empty Border ( _ NUM , _ NUM , is Last ? _ NUM : _ NUM , _ NUM ) ) ; row Panel . add ( new  JLabel ( label Text ) ,  Border Layout .  CENTER ) ; row Panel . add (  CHint Creator . create Hint Panel ( component , hint ) ,  Border Layout .  EAST ) ; panel . add ( row Panel ) ; return component ; }
public void curve To ( double x1 , double y1 , double x2 , double y2 , double x3 , double y3 ) { if ( size ( ) == _ NUM ) { throw new  Illegal Path State Exception ( _ STR ) ; }  Node last Point = get ( size ( ) - _ NUM ) ; last Point . mask |=  C2_ MASK ; last Point . x [ _ NUM ] = x1 ; last Point . y [ _ NUM ] = y1 ; if ( ( last Point . mask &  C1 C2_ MASK ) ==  C1 C2_ MASK ) { last Point . keep Colinear =  Math . abs (  Geom . angle ( last Point . x [ _ NUM ] , last Point . y [ _ NUM ] , last Point . x [ _ NUM ] , last Point . y [ _ NUM ] ) -  Geom . angle ( last Point . x [ _ NUM ] , last Point . y [ _ NUM ] , last Point . x [ _ NUM ] , last Point . y [ _ NUM ] ) ) < _ NUM ; } add ( new  Node (  C1_ MASK , x3 , y3 , x2 , y2 , x3 , y3 ) ) ; }
private void write Meta Bits ( ) throws  IOException { final byte buf [ ] = gen Metabits Data ( ) ; final long addr = m_meta Bits Addr < _ NUM ? physical Address ( m_meta Bits Addr ) : ( ( long ) m_meta Bits Addr ) <<  ALLOCATION_ SCALEUP ; if ( addr == _ NUM ) { throw new  Illegal State Exception ( _ STR + m_meta Bits Addr ) ; } assert addr > _ NUM ; try { if ( log . is Debug Enabled ( ) ) log . debug ( _ STR + addr ) ; m_write Cache Service . write ( addr ,  Byte Buffer . wrap ( buf ) , _ NUM , _ BOOL , m_meta Bits Addr < _ NUM ? m_meta Bits Addr : _ NUM ) ; } catch (  Interrupted Exception e ) { throw new  Runtime Exception ( e ) ; } }
private void open Counter Data Input Stream ( ) throws  Data Fallback Exception { if ( d Input == null ) { if (  LOG . is Debug Enabled ( ) )  LOG . debug ( _ STR + counter File . get Name ( ) + _ STR ) ; try { d Input = new  Buffered Reader ( new  File Reader ( counter File ) ) ; } catch (  IOException e ) { throw new  Data Fallback Exception ( e . get Message ( ) ) ; } } }
public  String read Next Word ( ) { if ( tokenizer . has More Tokens ( ) ) { return tokenizer . next Token ( ) ; } else { return null ; } }
public static final void to String (  String Buffer output ,  String str ) { if ( str == null ) { output . append ( _ STR ) ; return ; } output . append ( to String ( str ) ) ; }
@  Override public void build Associations (  Instances data ) throws  Exception { build Associations ( (  Object ) data ) ; return ; }
public void test Float Value Neg ( ) {  String a = _ STR ;  Big Decimal a Number = new  Big Decimal ( a ) ; float result = - _ NUM ; assert True ( _ STR , a Number . float Value ( ) == result ) ; }
public static  String replace First (  String s ,  String sub ,  String with ) { int i = s . index Of ( sub ) ; if ( i == - _ NUM ) { return s ; } return s . substring ( _ NUM , i ) + with + s . substring ( i + sub . length ( ) ) ; }
private  Location Helper ( ) { }
public void add Object (  String s ) throws  Exception { inspect (  Class . for Name ( s ) ) ; }
public static void main (  String [ ] args ) throws  Exception { final  JFrame frame = new  HTMLTest ( args ) ; frame . set Default Close Operation (  JFrame .  EXIT_ ON_ CLOSE ) ; frame . pack ( ) ; frame . set Visible ( _ BOOL ) ; }
@  Override public int hash Code ( ) { return raw String . hash Code ( ) ; }
public final void test Add All Helper Text Colors From Array ( ) { int helper Text Color1 =  Color .  BLACK ; int helper Text Color2 =  Color .  GRAY ; int [ ] helper Text Colors1 = new int [ _ NUM ] ; helper Text Colors1 [ _ NUM ] = helper Text Color1 ; helper Text Colors1 [ _ NUM ] = helper Text Color2 ;  Password Edit Text password Edit Text = new  Password Edit Text ( get Context ( ) ) ; password Edit Text . add All Helper Text Colors ( helper Text Colors1 ) ; password Edit Text . add All Helper Text Colors ( helper Text Colors1 ) ;  Collection <  Integer > helper Text Colors2 = password Edit Text . get Helper Text Colors ( ) ; assert Equals ( helper Text Colors1 . length , helper Text Colors2 . size ( ) ) ;  Iterator <  Integer > iterator = helper Text Colors2 . iterator ( ) ; assert Equals ( helper Text Color1 , ( int ) iterator . next ( ) ) ; assert Equals ( helper Text Color2 , ( int ) iterator . next ( ) ) ; }
public static boolean write To File (  String filename ,  String message , boolean append ) { boolean result ;  Buffered Writer writer ; try { writer = new  Buffered Writer ( new  File Writer ( filename , append ) ) ; writer . write ( message ) ; writer . new Line ( ) ; writer . flush ( ) ; writer . close ( ) ; result = _ BOOL ; } catch (  Exception e ) { result = _ BOOL ; } return result ; }
public int hash Code ( ) { return ( _ NUM * color Model . hash Code ( ) ) + ( _ NUM * sample Model . hash Code ( ) ) ; }
public void write File (  String name ,  String mime Type ,  String file Name , byte [ ] data ) throws  IOException { if ( data == null ) { throw new  Illegal Argument Exception ( _ STR ) ; } if ( file Name == null || file Name . is Empty ( ) ) { throw new  Illegal Argument Exception ( _ STR ) ; } out . write Bytes (  PREFIX ) ; out . write Bytes ( boundary ) ; out . write Bytes (  NEWLINE ) ; out . write Bytes ( _ STR + name + _ STR + file Name + _ STR ) ; out . write Bytes (  NEWLINE ) ; if ( mime Type != null ) { out . write Bytes ( _ STR + mime Type ) ; out . write Bytes (  NEWLINE ) ; } out . write Bytes (  NEWLINE ) ; out . write ( data , _ NUM , data . length ) ; out . write Bytes (  NEWLINE ) ; out . flush ( ) ; }
@  Target Api (  Build .  VERSION_ CODES .  ICE_ CREAM_ SANDWICH_ MR1 ) private void on Configuration Changed (  Configuration new Config ) { final  Locale new Locale = new Config . locale ; if ( new Locale . equals ( m System Locale ) ) { return ; } m System Locale = new Locale ; ensure Supported Locale ( ) ; }
private static  Boolean find Convex Polygon ( final  Planet Model planet Model , final  Edge current Edge , final  Geo Composite Polygon rval , final  Edge Buffer edge Buffer , final  List <  Geo Polygon > holes , final  Geo Point test Point ) { final  Set <  Edge > included Edges = new  Hash Set < > ( ) ; included Edges . add ( current Edge ) ;  Edge first Edge = current Edge ;  Edge last Edge = current Edge ; while ( _ BOOL ) { if ( first Edge . start Point == last Edge . end Point ) { break ; } final  Edge new Last Edge = edge Buffer . get Next ( last Edge ) ; if ( is Within ( new Last Edge . end Point , included Edges ) ) { final  Sided Plane return Boundary ; if ( first Edge . start Point != new Last Edge . end Point ) { return Boundary = new  Sided Plane ( first Edge . end Point , first Edge . start Point , new Last Edge . end Point ) ; } else { return Boundary = null ; } boolean found Point Inside = _ BOOL ; final  Iterator <  Edge > edge Iterator = edge Buffer . iterator ( ) ; while ( edge Iterator . has Next ( ) ) { final  Edge edge = edge Iterator . next ( ) ; if ( ! included Edges . contains ( edge ) && edge != new Last Edge ) { if ( edge . start Point != new Last Edge . end Point ) { if ( is Within ( edge . start Point , included Edges , new Last Edge , return Boundary ) ) { found Point Inside = _ BOOL ; break ; } } if ( edge . end Point != first Edge . start Point ) { if ( is Within ( edge . end Point , included Edges , new Last Edge , return Boundary ) ) { found Point Inside = _ BOOL ; break ; } } } } if ( ! found Point Inside ) { included Edges . add ( new Last Edge ) ; last Edge = new Last Edge ; continue ; } } break ; } while ( _ BOOL ) { if ( first Edge . start Point == last Edge . end Point ) { break ; } final  Edge new First Edge = edge Buffer . get Previous ( first Edge ) ; if ( is Within ( new First Edge . start Point , included Edges ) ) { final  Sided Plane return Boundary ; if ( new First Edge . start Point != last Edge . end Point ) { return Boundary = new  Sided Plane ( last Edge . start Point , last Edge . end Point , new First Edge . start Point ) ; } else { return Boundary = null ; } boolean found Point Inside = _ BOOL ; final  Iterator <  Edge > edge Iterator = edge Buffer . iterator ( ) ; while ( edge Iterator . has Next ( ) ) { final  Edge edge = edge Iterator . next ( ) ; if ( ! included Edges . contains ( edge ) && edge != new First Edge ) { if ( edge . start Point != last Edge . end Point ) { if ( is Within ( edge . start Point , included Edges , new First Edge , return Boundary ) ) { found Point Inside = _ BOOL ; break ; } } if ( edge . end Point != new First Edge . start Point ) { if ( is Within ( edge . end Point , included Edges , new First Edge , return Boundary ) ) { found Point Inside = _ BOOL ; break ; } } } } if ( ! found Point Inside ) { included Edges . add ( new First Edge ) ; first Edge = new First Edge ; continue ; } } break ; } if ( included Edges . size ( ) < _ NUM ) { return _ BOOL ; } final  List <  Geo Point > points = new  Array List <  Geo Point > ( included Edges . size ( ) + _ NUM ) ; final  Bit Set internal Edges = new  Bit Set ( included Edges . size ( ) ) ; final boolean return Is Internal ; if ( first Edge . start Point == last Edge . end Point ) { if ( included Edges . size ( ) < _ NUM ) { return _ BOOL ; }  Edge edge = first Edge ; points . add ( edge . start Point ) ; int k = _ NUM ; while ( _ BOOL ) { if ( edge == last Edge ) { break ; } points . add ( edge . end Point ) ; internal Edges . set ( k ++ , edge . is Internal ) ; edge = edge Buffer . get Next ( edge ) ; } return Is Internal = last Edge . is Internal ; for ( int i = _ NUM ; i < points . size ( ) ; i ++ ) { final  Geo Point start = points . get ( i ) ; final  Geo Point end = points . get ( get Legal Index ( i + _ NUM , points . size ( ) ) ) ; final  Plane plane To Find = new  Plane ( start , end ) ; int end Point Index = - _ NUM ; for ( int j = _ NUM ; j < points . size ( ) ; j ++ ) { final int index = get Legal Index ( j + i + _ NUM , points . size ( ) ) ; if ( ! plane To Find . evaluate Is Zero ( points . get ( index ) ) ) { end Point Index = index ; break ; } } if ( end Point Index == - _ NUM ) { return _ BOOL ; } } edge Buffer . clear ( ) ; } else { final  Sided Plane return Sided Plane = new  Sided Plane ( first Edge . end Point , _ BOOL , first Edge . start Point , last Edge . end Point ) ; final  Edge return Edge = new  Edge ( first Edge . start Point , last Edge . end Point , return Sided Plane , _ BOOL ) ; final  List <  Edge > edges = new  Array List <  Edge > ( included Edges . size ( ) ) ; return Is Internal = _ BOOL ;  Edge edge = first Edge ; points . add ( edge . start Point ) ; int k = _ NUM ; while ( _ BOOL ) { points . add ( edge . end Point ) ; internal Edges . set ( k ++ , edge . is Internal ) ; edges . add ( edge ) ; if ( edge == last Edge ) { break ; } edge = edge Buffer . get Next ( edge ) ; } for ( int i = _ NUM ; i < points . size ( ) ; i ++ ) { final  Geo Point start = points . get ( i ) ; final  Geo Point end = points . get ( get Legal Index ( i + _ NUM , points . size ( ) ) ) ; final  Plane plane To Find = new  Plane ( start , end ) ; int end Point Index = - _ NUM ; for ( int j = _ NUM ; j < points . size ( ) ; j ++ ) { final int index = get Legal Index ( j + i + _ NUM , points . size ( ) ) ; if ( ! plane To Find . evaluate Is Zero ( points . get ( index ) ) ) { end Point Index = index ; break ; } } if ( end Point Index == - _ NUM ) { return _ BOOL ; } } edge Buffer . replace ( edges , return Edge ) ; } if ( test Point != null && holes != null && holes . size ( ) > _ NUM ) { final  Geo Polygon test Polygon = new  Geo Convex Polygon ( planet Model , points , null , internal Edges , return Is Internal ) ; if ( test Polygon . is Within ( test Point ) ) { return null ; } } final  Geo Polygon real Polygon = new  Geo Convex Polygon ( planet Model , points , holes , internal Edges , return Is Internal ) ; if ( test Point != null && ( holes == null || holes . size ( ) == _ NUM ) ) { if ( real Polygon . is Within ( test Point ) ) { return null ; } } rval . add Shape ( real Polygon ) ; return _ BOOL ; }
private static boolean is GMTish (  String name ) { if ( name . length ( ) < _ NUM ) { return _ BOOL ; } char c1 = name . char At ( _ NUM ) ; char c2 = name . char At ( _ NUM ) ; char c3 = name . char At ( _ NUM ) ; if ( ! ( ( c1 == _ STR || c1 == _ STR ) && ( c2 == _ STR || c2 == _ STR ) && ( c3 == _ STR || c3 == _ STR ) ) && ! ( ( c1 == _ STR || c1 == _ STR ) && ( c2 == _ STR || c2 == _ STR ) && ( c3 == _ STR || c3 == _ STR ) ) && ! ( ( c1 == _ STR || c1 == _ STR ) && ( c2 == _ STR || c2 == _ STR ) && ( c3 == _ STR ) ) ) { return _ BOOL ; } if ( name . length ( ) == _ NUM ) { return _ BOOL ; }  String offset = name . substring ( _ NUM ) ; if ( offset . starts With ( _ STR ) ) { return offset . equals ( _ STR ) || offset . equals ( _ STR ) || offset . equals ( _ STR ) ; } else { return offset . equals ( _ STR ) || offset . equals ( _ STR ) || offset . equals ( _ STR ) ; } }
protected void add Whole Match (  String Builder sb ,  String surface ,  String analyzed ) { sb . append ( _ STR ) ; sb . append ( surface ) ; sb . append ( _ STR ) ; }
public void start ( ) { stop At =  System . current Time Millis ( ) +  MAX_ PROCESSING_ TIME ; }
private  Object [ ] single Row ( int row ) {  Object [ ] res = new  Object [ this . n Fields ] ; for ( int i = _ NUM ; i < this . n Fields ; i += _ NUM ) { if ( this . is Null == null || ! this . is Null [ row * this . n Fields + i ] ) { res [ i ] =  Array Funcs . new Instance ( this . types [ i ] , _ NUM ) ;  System . arraycopy ( this . data [ i ] , row , res [ i ] , _ NUM , _ NUM ) ; } } return res ; }
public static  String remove Chars (  String src ,  String chars ) { int i = src . length ( ) ;  String Builder sb = new  String Builder ( i ) ; for ( int j = _ NUM ; j < i ; j ++ ) { char c = src . char At ( j ) ; if ( chars . index Of ( c ) == - _ NUM ) { sb . append ( c ) ; } } return sb . to String ( ) ; }
private void add All Columns ( ) throws  SQLException {  Database Meta Data meta Data = get Database Meta Data ( ) ;  List <  String > columns = new  Array List < > ( ) ; try (  Result Set rs = meta Data . get Columns ( null , null , normalize Object Name ( statement Model . get Table Name ( ) ) , null ) ) { while ( rs . next ( ) ) { columns . add ( quote Object Name ( rs . get String (  IDX_ COLUMN_ NAME ) ) ) ; } } column Names = columns . to Array ( new  String [ _ NUM ] ) ; add Returning Clause ( ) ; }
public void load Ham NSpam (  Connection conn ) throws java . sql .  SQLException {  Prepared Statement pstmt = null ;  Result Set rs = null ; try { pstmt = conn . prepare Statement ( sql Queries . get Sql String ( _ STR , _ BOOL ) ) ; rs = pstmt . execute Query ( ) ;  Map <  String ,  Integer > ham = get Ham Token Counts ( ) ; while ( rs . next ( ) ) {  String token = rs . get String ( _ NUM ) ; int count = rs . get Int ( _ NUM ) ; if ( count > _ NUM ) { ham . put ( token , count ) ; } } log ( _ STR + ham . size ( ) ) ; rs . close ( ) ; pstmt . close ( ) ; pstmt = conn . prepare Statement ( sql Queries . get Sql String ( _ STR , _ BOOL ) ) ; rs = pstmt . execute Query ( ) ;  Map <  String ,  Integer > spam = get Spam Token Counts ( ) ; while ( rs . next ( ) ) {  String token = rs . get String ( _ NUM ) ; int count = rs . get Int ( _ NUM ) ; if ( count > _ NUM ) { spam . put ( token , count ) ; } } log ( _ STR + spam . size ( ) ) ; rs . close ( ) ; pstmt . close ( ) ; pstmt = conn . prepare Statement ( sql Queries . get Sql String ( _ STR , _ BOOL ) ) ; rs = pstmt . execute Query ( ) ; if ( rs . next ( ) ) { set Ham Message Count ( rs . get Int ( _ NUM ) ) ; set Spam Message Count ( rs . get Int ( _ NUM ) ) ; } rs . close ( ) ; pstmt . close ( ) ; } finally { if ( rs != null ) { try { rs . close ( ) ; } catch ( java . sql .  SQLException se ) { log ( _ STR , se ) ; } rs = null ; } if ( pstmt != null ) { try { pstmt . close ( ) ; } catch ( java . sql .  SQLException se ) { log ( _ STR , se ) ; } pstmt = null ; } } }
static private void copy Stream ( final  Input Stream content , final  Output Stream outstr ) throws  IOException { final byte [ ] buf = new byte [  GZIP_ BUFFER ] ; while ( _ BOOL ) { final int rdlen = content . read ( buf ) ; if ( rdlen <= _ NUM ) { break ; } outstr . write ( buf , _ NUM , rdlen ) ; } }
public void check And Setup Streams Drawer ( ) { setup List View Adapter ( ) ; }
public void test Fp Type Override Simple ( ) throws  Exception {  Object Mapper m = new  Object Mapper ( ) ; m . enable (  Deserialization Config .  Feature .  USE_ BIG_ DECIMAL_ FOR_ FLOATS ) ;  Big Decimal dec = new  Big Decimal ( _ STR ) ;  Number result = m . read Value ( dec . to String ( ) ,  Number . class ) ; assert Equals (  Big Decimal . class , result . get Class ( ) ) ; assert Equals ( dec , result ) ;  Object value = m . read Value ( dec . to String ( ) ,  Object . class ) ; assert Equals (  Big Decimal . class , result . get Class ( ) ) ; assert Equals ( dec , value ) ; }
private com . codename1 . ui .  Component copy Component ( com . codename1 . ui .  Component cmp ) { com . codename1 . ui .  Container cnt = builder . create Container ( res , copied Resource Name ) ; com . codename1 . ui .  Component dest = builder . find By Name ( cmp . get Name ( ) , cnt ) ; if ( dest != null && dest . get Parent ( ) != null ) { remove Component Sync ( dest . get Parent ( ) , dest ) ; } return dest ; }
@  Override public  Big Decimal calculate Total Pending Advance ( final  Big Decimal total Advance Paid , final  Date bill Date , final  Work Order Estimate work Order Estimate , final  Long bill Id ) { final  CChart Of Accounts advance COA = contractor Advance Service . get Contractor Advance Accountcode For WOE ( work Order Estimate . get Id ( ) ) ;  Big Decimal total Pending Balance =  Big Decimal .  ZERO ;  Big Decimal total Advance Adjusted =  Big Decimal .  ZERO ; if ( advance COA != null && total Advance Paid != null && total Advance Paid . compare To (  Big Decimal .  ZERO ) > _ NUM ) { total Advance Adjusted = get Total Advance Adjusted For WOE ( bill Date , work Order Estimate . get Id ( ) , advance COA . get Id ( ) , bill Id ) ; if ( total Advance Adjusted != null && total Advance Adjusted . compare To (  Big Decimal .  ZERO ) > _ NUM && total Advance Adjusted . compare To (  Big Decimal .  ZERO ) > _ NUM ) total Pending Balance = total Advance Adjusted . subtract ( total Advance Adjusted ) ; else total Pending Balance = total Advance Paid ; } return total Pending Balance ; }
private void scroll By ( final int increment ) { index += increment ; if ( index < _ NUM ) { index = _ NUM ; } if ( index >= items . size ( ) ) { index = items . size ( ) - _ NUM ; } redraw ( ) ; }
public static boolean symbol Needs Quoting (  Char Sequence symbol , boolean quote Operators ) { int length = symbol . length ( ) ; if ( length == _ NUM ) { throw new  Empty Symbol Exception ( ) ; } if ( ! is Identifier Keyword ( symbol ) ) { char c = symbol . char At ( _ NUM ) ; if ( ! quote Operators && is Operator Part ( c ) ) { for ( int ii = _ NUM ; ii < length ; ii ++ ) { c = symbol . char At ( ii ) ; if ( ! is Operator Part ( c ) ) { return _ BOOL ; } } return _ BOOL ; } else if ( is Identifier Start ( c ) ) { for ( int ii = _ NUM ; ii < length ; ii ++ ) { c = symbol . char At ( ii ) ; if ( ( c == _ STR || c < _ NUM || c > _ NUM ) || ! is Identifier Part ( c ) ) { return _ BOOL ; } } return _ BOOL ; } } return _ BOOL ; }
public static long parse Commit Counter File ( final  String name , final  String ext ) throws  Number Format Exception { if ( name == null ) throw new  Illegal Argument Exception ( ) ; if ( ext == null ) throw new  Illegal Argument Exception ( ) ; final int len = name . length ( ) - ext . length ( ) ; final  String file Base Name = name . substring ( _ NUM , len ) ; final long commit Counter =  Long . parse Long ( file Base Name ) ; return commit Counter ; }
public static  Document load Document (  File file ) throws  Exception {  Document Builder Factory factory =  Document Builder Factory . new Instance ( ) ;  Document Builder builder = factory . new Document Builder ( ) ; return builder . parse ( file ) ; }
private  Node new Floating Comment ( ) {  Node c = new  Node (  Token .  EMPTY ) ; link Comment To Node ( c ) ; return c ; }
public  Boolean is Hod ( final  Long assign Id ) { final  List <  Head Of Departments > hod List = employee Department Repository . get All Hod Departments ( assign Id ) ; return ! hod List . is Empty ( ) ; }
public  Munger single Label Mode (  String ... languages ) { return single Label Mode (  Arrays . as List ( languages ) ) ; }
public  Stat Value [ ] match Spec (  Stat Spec spec ) { if ( spec . get Combine Type ( ) ==  Stat Spec .  GLOBAL ) {  Stat Value [ ] all Values = match Spec ( new  Raw Stat Spec ( spec ) ) ; if ( all Values . length == _ NUM ) { return all Values ; } else {  Combo Value cv = new  Combo Value ( all Values ) ; return new  Stat Value [ ] { cv } ; } } else {  List l = new  Array List ( ) ;  Stat Archive Reader .  Stat Archive File [ ] archives = get Archives ( ) ; for ( int i = _ NUM ; i < archives . length ; i ++ ) {  Stat Archive File f = archives [ i ] ; if ( spec . archive Matches ( f . get File ( ) ) ) { f . match Spec ( spec , l ) ; } }  Stat Value [ ] result = new  Stat Value [ l . size ( ) ] ; return (  Stat Value [ ] ) l . to Array ( result ) ; } }
private void assign Cluster Nums ( int [ ] cl_num ) throws  Exception { if ( m_children != null && m_children . size ( ) < _ NUM ) { throw new  Exception ( _ STR ) ; } m_cluster Num = cl_num [ _ NUM ] ; cl_num [ _ NUM ] ++ ; if ( m_children != null ) { for ( int i = _ NUM ; i < m_children . size ( ) ; i ++ ) {  CNode child = m_children . get ( i ) ; child . assign Cluster Nums ( cl_num ) ; } } }
protected void close Subpath ( ) { m PSStream . println (  CLOSEPATH_ STR ) ; m Pen X = m Start Path X ; m Pen Y = m Start Path Y ; }
public  Tv Show Episode Scrape Task (  List <  Tv Show Episode > episodes ,  Media Scraper media Scraper ) { super (  BUNDLE . get String ( _ STR ) , episodes . size ( ) ,  Task Type .  BACKGROUND_ TASK ) ; this . episodes = episodes ; this . media Scraper = media Scraper ; this . scrape Thumb = _ BOOL ; }
public  Model MBean Notification Info (  String [ ] notif Types ,  String name ,  String description ) { this ( notif Types , name , description , null ) ; }
public void clean Build Task ( long id ) throws  Not Found Exception {  Future Build Task task = tasks . remove ( id ) ; if ( task == null ) { throw new  Not Found Exception (  String . format ( _ STR , id ) ) ; } task . cancel ( _ BOOL ) ; cleanup ( task ) ; }
public void move To ( final int lon Center , final int lat Center ) { double m Lat Center =  Geo Math . lat E7 To Mercator ( lat Center ) ; double m Top =  Geo Math . lat E7 To Mercator ( top ) ; int new Bottom =  Geo Math . mercator To Lat E7 ( m Lat Center - ( m Top - bottom Mercator ) / _ NUM ) ; try { translate ( ( lon Center - left - ( int ) ( width / _ NUM ) ) , new Bottom - bottom ) ; } catch (  Osm Exception e ) { e . print Stack Trace ( ) ; } }
public void send Event ( final  String name , final  Map <  String ,  String > properties ) { final  String event Name =  String . format (  Tfs Telemetry Constants .  PLUGIN_ ACTION_ EVENT_ NAME_ FORMAT , name ) ; final  Property Map Builder builder = new  Property Map Builder ( properties ) ; logger . debug (  String . format ( _ STR , name , builder . to String ( ) ) ) ; if ( telemetry Client != null ) { telemetry Client . track Event ( event Name , builder . build ( ) , null ) ; } }
public void handle Header Column Pressed (  Point p ) {  JTable Header th =  TABLE . get Table Header ( ) ; int col = th . column At Point ( p ) ; int c =  TABLE . convert Column Index To Model ( col ) ; if ( c != - _ NUM ) {  TABLE . set Pressed Column Index ( c ) ; th . repaint ( th . get Header Rect ( col ) ) ; } }
private static  List <  Fixed Record > create Fixed Records ( int count ) {  List <  Fixed Record > records = new  Array List < > ( ) ; for ( int i = _ NUM ; i < count ; i ++ ) { records . add ( new  Fixed Record ( i ) ) ; } return records ; }
public  Tracked Entity Instance Query Params add Attributes If Not Exist (  List <  Query Item > attrs ) { for (  Query Item attr : attrs ) { if ( attributes != null && ! attributes . contains ( attr ) ) { attributes . add ( attr ) ; } } return this ; }
protected final void delete DBFFDCFiles (  String directory To Delete ) throws  Ade Exception { try { final  File dir To Delete = new  File ( directory To Delete ) ;  String [ ] file List = dir To Delete . list ( ) ; if ( file List . length == _ NUM ) { dir To Delete . delete ( ) ; } else { for ( int i = _ NUM ; i < file List . length ; i ++ ) { final  File f = new  File ( dir To Delete , file List [ i ] ) ; if ( f . is Directory ( ) ) { final  String file Path = f . get Path ( ) ; delete DBFFDCFiles ( file Path ) ; continue ; } f . delete ( ) ; } file List = dir To Delete . list ( ) ; if ( file List . length == _ NUM ) { dir To Delete . delete ( ) ; } } } catch (  Exception e ) { throw new  Ade Internal Exception ( _ STR , e ) ; } }
public static void check Serialized Equality (  Object object ) {  Object object2 = serialize And Recover ( object ) ;  Assert . assert Equals ( _ STR , object , object2 ) ;  Assert . assert Equals ( _ STR , object . hash Code ( ) , object2 . hash Code ( ) ) ; }
public  String documentation Reference Guide Url ( ) { return properties . get Property ( _ STR ) ; }
public static double mean ( final  List <  Double > list ) { double sum = _ NUM ; for (  Double number : list ) { sum += number ; } return sum / list . size ( ) ; }
public static  String to Hex ( byte [ ] data ) { try { return new  String (  Hex . encode ( data ) , _ STR ) ; } catch (  Unsupported Encoding Exception e ) { } return null ; }
@  Visible For Testing public void process Enable Fullscreen Runnable For Test ( ) { if ( m Handler . has Messages (  MSG_ ID_ ENABLE_ FULLSCREEN_ AFTER_ LOAD ) ) { m Handler . remove Messages (  MSG_ ID_ ENABLE_ FULLSCREEN_ AFTER_ LOAD ) ; enable Fullscreen After Load ( ) ; } }
private static  String from Html Entity (  String str ) {  Character ch = map . get ( str ) ; return ( ch != null ) ? ch . to String ( ) : str ; }
public void unlock UI (  Process Info pi ) { boolean not Print = pi != null && pi . get AD_ Process_ ID ( ) != m_cur Tab . get AD_ Process_ ID ( ) && pi . is Reporting Process ( ) == _ BOOL ; set Busy ( _ BOOL , not Print ) ; if ( not Print ) { m_cur Tab . data Refresh ( ) ; if ( pi . is Timeout ( ) )  Env . set Context ( m_ctx , m_cur Window No , _ STR , _ STR ) ; m_cur GC . dynamic Display ( _ NUM ) ; set Status Line ( pi . get Summary ( ) , pi . is Error ( ) ) ; if ( pi . is Error ( ) )  ADialog . error ( m_cur Window No , this , null , pi . get Summary ( ) ) ;  Process Info Util . set Log From DB ( pi ) ;  String log Info = pi . get Log Info ( ) ; if ( log Info . length ( ) > _ NUM )  ADialog . info ( m_cur Window No , this ,  Env . get Header ( m_ctx , m_cur Window No ) , pi . get Title ( ) , log Info ) ; } else { set Status Line ( pi . get Summary ( ) , pi . is Error ( ) ) ; if ( pi . is Error ( ) )  ADialog . error ( m_cur Window No , this , null , pi . get Summary ( ) ) ; } }
private  Map <  URI ,  Storage System > build Array Map (  Storage System vplex System ,  List <  Volume Descriptor > descriptors ,  Volume Descriptor .  Type [ ] types ) {  Map <  URI ,  Storage System > array Map = new  Hash Map <  URI ,  Storage System > ( ) ; if ( types != null ) { descriptors =  Volume Descriptor . filter By Type ( descriptors , types , new  Volume Descriptor .  Type [ ] { } ) ; } for (  Volume Descriptor desc : descriptors ) { if ( array Map . contains Key ( desc . get Device URI ( ) ) == _ BOOL ) { if ( vplex System == null ) {  Storage System array = get Data Object (  Storage System . class , desc . get Device URI ( ) , _db Client ) ; array Map . put ( desc . get Device URI ( ) , array ) ; } else {  Set <  URI > connected Systems =  Connectivity Util . get Storage System Associations By Network ( _db Client , vplex System . get Id ( ) ,  Storage Port .  Port Type . backend ) ; if ( connected Systems . contains ( desc . get Device URI ( ) ) ) {  Storage System array = get Data Object (  Storage System . class , desc . get Device URI ( ) , _db Client ) ; array Map . put ( desc . get Device URI ( ) , array ) ; } } } } return array Map ; }
public byte [ ] encrypt ( byte [ ] plain Text As Bytes ,  Char Sequence password ) throws  Key Crypter Exception { try { byte [ ] salt = new byte [  SALT_ LENGTH ] ; secure Random . next Bytes ( salt ) ;  Parameters With IV key = (  Parameters With IV ) get AESPassword Key ( password , salt ) ;  Buffered Block Cipher cipher = new  Padded Buffered Block Cipher ( new  CBCBlock Cipher ( new  AESFast Engine ( ) ) ) ; cipher . init ( _ BOOL , key ) ; byte [ ] encrypted Bytes = new byte [ cipher . get Output Size ( plain Text As Bytes . length ) ] ; final int process Length = cipher . process Bytes ( plain Text As Bytes , _ NUM , plain Text As Bytes . length , encrypted Bytes , _ NUM ) ; final int do Final Length = cipher . do Final ( encrypted Bytes , process Length ) ; return concat ( salt ,  Arrays . copy Of ( encrypted Bytes , process Length + do Final Length ) ) ; } catch (  Exception e ) { throw new  Key Crypter Exception ( _ STR +  Utils . bytes To Hex String ( plain Text As Bytes ) + _ STR , e ) ; } }
public final  Array List <  Wifi Record > load Wifis By Bssid ( final  String bssid , final  Integer session ) { final  Array List <  Wifi Record > wifis = new  Array List < > ( ) ;  String select Sql ; if ( session != null ) { select Sql =  Schema .  COL_ BSSID + _ STR + bssid + _ STR +  Schema .  COL_ SESSION_ ID + _ STR + session + _ STR ; } else { select Sql =  Schema .  COL_ BSSID + _ STR + bssid + _ STR ; } final  Cursor cursor = content Resolver . query (  Content Provider .  CONTENT_ URI_ WIFI , null , select Sql , null , null ) ; final int column Index = cursor . get Column Index (  Schema .  COL_ BSSID ) ; final int column Index2 = cursor . get Column Index (  Schema .  COL_ SSID ) ; final int column Index3 = cursor . get Column Index (  Schema .  COL_ CAPABILITIES ) ; final int column Index4 = cursor . get Column Index (  Schema .  COL_ FREQUENCY ) ; final int column Index5 = cursor . get Column Index (  Schema .  COL_ LEVEL ) ; final int column Index6 = cursor . get Column Index (  Schema .  COL_ TIMESTAMP ) ; final int column Index7 = cursor . get Column Index (  Schema .  COL_ BEGIN_ POSITION_ ID ) ; final int column Index8 = cursor . get Column Index (  Schema .  COL_ END_ POSITION_ ID ) ; final int column Index9 = cursor . get Column Index (  Schema .  COL_ KNOWN_ WIFI ) ; while ( cursor . move To Next ( ) ) { final  Wifi Record wifi = new  Wifi Record ( ) ; wifi . set Bssid ( cursor . get String ( column Index ) ) ; wifi . set Ssid ( cursor . get String ( column Index2 ) ) ; wifi . set Capabilities ( cursor . get String ( column Index3 ) ) ; wifi . set Frequency ( cursor . get Int ( column Index4 ) ) ; wifi . set Level ( cursor . get Int ( column Index5 ) ) ; wifi . set Open Bmap Timestamp ( cursor . get Long ( column Index6 ) ) ; wifi . set Begin Position ( load Position By Id ( cursor . get String ( column Index7 ) ) ) ; wifi . set End Position ( load Position By Id ( cursor . get String ( column Index8 ) ) ) ; wifi . set Catalog Status (  Catalog Status . values ( ) [ cursor . get Int ( column Index9 ) ] ) ; wifis . add ( wifi ) ; } cursor . close ( ) ; return wifis ; }
public static _ Fields find By Thrift Id ( int field Id ) { switch ( field Id ) { case _ NUM : return  AFTER_ ID ; case _ NUM : return  MAX_ JOBS ; default : return null ; } }
@  Override public void deinstall (  JEditor Pane editor ) { super . deinstall ( editor ) ; editor . remove Key Listener ( this ) ; }
public boolean is Secure ( ) { return m Tls Cipher != null && ! m Tls Cipher . is Empty ( ) ; }
public void sample (  Record rec ) { total Recs ++ ; if ( samples . size ( ) <  MAX_ SAMPLES ) { samples . add ( new  Sample ( rec , schema ) ) ; update New Value Interval ( rec ) ; } else { double flip = random . next Double ( ) ; if ( flip < ( double )  MAX_ SAMPLES / total Recs ) { samples . set ( random . next Int (  MAX_ SAMPLES ) , new  Sample ( rec , schema ) ) ; update New Value Interval ( rec ) ; } } }
public  Tenant Create Param prepare Tenant Param (  Keystone Tenant tenant ) {  Tenant Create Param param = new  Tenant Create Param (  Cinder Constants .  TENANT_ NAME_ PREFIX + _ STR + tenant . get Name ( ) , prepare User Mappings ( tenant . get Id ( ) ) ) ; param . set Description ( get Proper Tenant Description ( tenant . get Description ( ) ) ) ; return param ; }
private void force Internal Error ( ) { throw new  Internal Error ( _ STR ) ; }
@  Override public void draw Highlight (  Graphics g , int w , int h ) { g . set Color (  Color . black ) ;  Font Metrics fm = g . get Font Metrics ( ) ; int l = ( int ) ( m_x * w ) - fm . string Width ( m_id ) / _ NUM ; int t = ( int ) ( m_y * h ) - fm . get Height ( ) / _ NUM ; g . fill Rect ( l - _ NUM , t - _ NUM , fm . string Width ( m_id ) + _ NUM , fm . get Height ( ) + fm . get Descent ( ) + _ NUM ) ; draw Node ( g , w , h ) ; }
public static  Image Encoder new Instance (  String format ) {  Image Encoder image Encoder = null ;  String class Name = (  String ) encoders . get ( format ) ; if ( class Name == null ) { throw new  Illegal Argument Exception ( _ STR + format ) ; } try {  Class image Encoder Class =  Class . for Name ( class Name ) ; image Encoder = (  Image Encoder ) image Encoder Class . new Instance ( ) ; } catch (  Exception e ) { throw new  Illegal Argument Exception ( e . to String ( ) ) ; } return image Encoder ; }
public double empirical HSICincomplete Cholesky (  Tetrad Matrix  Gy ,  Tetrad Matrix  Gx ,  Tetrad Matrix  Gz , int m ) { int ky =  Gy . columns ( ) ; int kx =  Gx . columns ( ) ; int kz =  Gz . columns ( ) ;  Tetrad Matrix  H =  Kernel Utils . construct H ( m ) ;  Tetrad Matrix  Gcy =  H . times (  Gy ) ;  Tetrad Matrix  Gcx =  H . times (  Gx ) ;  Tetrad Matrix  Gcz =  H . times (  Gz ) ;  Tetrad Matrix  A = new  Tetrad Matrix ( ky , kx ) ;  Tetrad Matrix  Gcyt =  Gcy . transpose ( ) ;  A =  Gcyt . times (  Gcx ) ;  Tetrad Matrix  B =  Gcy . times (  A ) ;  Tetrad Matrix  Kyx = new  Tetrad Matrix ( m , m ) ;  Tetrad Matrix  Gcxt = new  Tetrad Matrix ( kx , m ) ;  Gcxt =  Gcx . transpose ( ) ;  Kyx =  B . times (  Gcxt ) ; double emp HSIC = _ NUM ; double xy = _ NUM ; for ( int i = _ NUM ; i < m ; i ++ ) { emp HSIC += matrix Product Entry (  B ,  Gcxt , i , i ) ; }  Tetrad Matrix  Gytz =  Gcyt . times (  Gcz ) ;  Tetrad Matrix  Gczt =  Gcz . transpose ( ) ;  Tetrad Matrix  Gztx =  Gczt . times (  Gcx ) ;  Tetrad Matrix  Gztz =  Gczt . times (  Gcz ) ;  Tetrad Matrix  Gztzr =  Gztz . copy ( ) ; for ( int i = _ NUM ; i < kz ; i ++ ) {  Gztzr . set ( i , i ,  Gztz . get ( i , i ) + this . regularizer ) ; }  Tetrad Matrix  ZI =  Gztzr . inverse ( ) ;  Tetrad Matrix  ZIzt =  ZI . times (  Gczt ) ;  Tetrad Matrix  Gzr =  Gcz . copy ( ) ; for ( int i = _ NUM ; i < m ; i ++ ) { for ( int j = _ NUM ; j < kz ; j ++ ) {  Gzr . set ( i , j ,  Gcz . get ( i , j ) * ( - _ NUM / this . regularizer ) ) ; } }  Tetrad Matrix  Zinv =  Gzr . times (  ZIzt ) ; for ( int i = _ NUM ; i < m ; i ++ ) {  Zinv . set ( i , i ,  Zinv . get ( i , i ) + ( _ NUM / this . regularizer ) ) ; }  Tetrad Matrix  Gztzinv =  Gczt . times (  Zinv ) ;  Tetrad Matrix  Gzinvz =  Zinv . times (  Gcz ) ;  Tetrad Matrix  Gztinv2z =  Gztzinv . times (  Gzinvz ) ;  Tetrad Matrix  Gytzztzinv2z =  Gytz . times (  Gztinv2z ) ;  Tetrad Matrix  Gytzztzinv2zztx =  Gytzztzinv2z . times (  Gztx ) ;  Tetrad Matrix  Gyytzztzinv2zztx =  Gcy . times (  Gytzztzinv2zztx ) ; double second = _ NUM ; for ( int i = _ NUM ; i < m ; i ++ ) { second += matrix Product Entry (  Gyytzztzinv2zztx ,  Gcxt , i , i ) ; } emp HSIC -= _ NUM * second ;  Tetrad Matrix  Gxtz =  Gcxt . times (  Gcz ) ;  Tetrad Matrix  Gxtzztinv2z =  Gxtz . times (  Gztinv2z ) ;  Tetrad Matrix  Gyytzztzinv2zztxxtzztinv2z =  Gyytzztzinv2zztx . times (  Gxtzztinv2z ) ; for ( int i = _ NUM ; i < m ; i ++ ) { emp HSIC += matrix Product Entry (  Gyytzztzinv2zztxxtzztinv2z ,  Gczt , i , i ) ; } double betaz = _ NUM ; for ( int i = _ NUM ; i < ( m - _ NUM ) ; i ++ ) { for ( int j = ( i + _ NUM ) ; j < m ; j ++ ) { betaz +=  Math . pow ( matrix Product Entry (  Gcz ,  Gczt , i , j ) , _ NUM ) ; betaz +=  Math . pow ( matrix Product Entry (  Gcz ,  Gczt , j , i ) , _ NUM ) ; } } emp HSIC *= ( m / ( betaz * ( m - _ NUM ) ) ) ; return emp HSIC ; }
public static  File parse (  String [ ] options ,  String option ,  File def Value ) throws  Exception {  String value =  Utils . get Option ( option , options ) ; if ( value . is Empty ( ) ) return def Value ; else return new  File ( value ) ; }
public boolean is Acct Balanced ( ) { if ( m_lines . size ( ) == _ NUM ) return _ BOOL ;  Big Decimal balance = get Acct Balance ( ) ; boolean ret Value = balance . signum ( ) == _ NUM ; if ( ret Value ) log . finer ( to String ( ) ) ; else log . warning ( _ STR + balance + _ STR + to String ( ) ) ; return ret Value ; }
public void ensure Capacity ( int min Capacity ) { int old Capacity = capacity ; if ( min Capacity > old Capacity ) { int new Capacity = ( old Capacity * _ NUM ) / _ NUM + _ NUM ; if ( new Capacity < min Capacity ) new Capacity = min Capacity ;  Bit Vector vector = to Bit Vector ( ) ; vector . set Size ( new Capacity * bits Per Element ) ; this . bits = vector . elements ( ) ; this . capacity = new Capacity ; } }
private  String detail Base ( final  Method method ) { final  Class < ? > clazz = method . get Declaring Class ( ) ; final  String detail Base =  Message Utils . bundle Name For Class ( clazz ) ; if ( is Blank ( detail Base ) ) { throw new  Illegal State Exception ( _ STR + clazz ) ; } return detail Base ; }
public void finished ( ) throws  IOException { output Stream . close ( ) ; }
public final void lock ( ) {  Sun Toolkit . awt Lock ( ) ; }
@  Override public  Object create Statement (  Object proxy ,  Method method ,  Object [ ] args ,  Object statement , long time ) { try {  Object result = null ;  String name = method . get Name ( ) ;  String sql = null ;  Constructor < ? > constructor = null ; if ( compare (  CREATE_ STATEMENT , name ) ) { constructor = get Constructor (  CREATE_ STATEMENT_ IDX ,  Statement . class ) ; } else if ( compare (  PREPARE_ STATEMENT , name ) ) { sql = (  String ) args [ _ NUM ] ; constructor = get Constructor (  PREPARE_ STATEMENT_ IDX ,  Prepared Statement . class ) ; if ( sql != null ) { prepare Statement ( sql , time ) ; } } else if ( compare (  PREPARE_ CALL , name ) ) { sql = (  String ) args [ _ NUM ] ; constructor = get Constructor (  PREPARE_ CALL_ IDX ,  Callable Statement . class ) ; prepare Call ( sql , time ) ; } else { return statement ; } result = constructor . new Instance ( new  Object [ ] { new  Statement Proxy ( statement , sql ) } ) ; return result ; } catch (  Exception x ) { log . warn ( _ STR , x ) ; } return statement ; }
public  Update Response remove ( long id ) throws  IOException ,  Solr Server Exception {  Update Response res = solr Client . delete By Id (  String . value Of ( id ) ) ; solr Client . commit ( _ BOOL , _ BOOL , _ BOOL ) ; return res ; }
public void switch Setup ( ) { int ret Val ; ret Val = m_ Setup File Chooser . show Open Dialog ( this ) ; if ( ret Val !=  JFile Chooser .  APPROVE_ OPTION ) { return ; } m_ Db Utils . initialize ( m_ Setup File Chooser . get Selected File ( ) ) ; m_ URL = m_ Db Utils . get Database URL ( ) ; m_ User = m_ Db Utils . get Username ( ) ; m_ Password = m_ Db Utils . get Password ( ) ; m_ Text URL . set Text ( m_ URL ) ; }
private  Client Details Entity load Client Object ( final  OIDCAuthorization Request Context authorization Request ) { log . debug ( _ STR , authorization Request . get Client Id ( ) ) ; return client Service . load Client By Client Id ( authorization Request . get Client Id ( ) ) ; }
public void add Field Property (  String name ,  String accessor Field ) { field Properties . add ( new  Legacy Field Prop Desc ( name , accessor Field ) ) ; }
private void parse No Wild Cards ( ) { this . f Segments = new  String [ _ NUM ] ; this . f Segments [ _ NUM ] = this . f Pattern ; this . f Bound = this . f Length ; }
public  Map <  String ,  String > environment ( ) {  String base64 = to String Base64 ( ) ; if ( base64 == null || base64 . length ( ) == _ NUM ) { return  Collections . empty Map ( ) ; }  Map <  String ,  String > environment =  Maps . new Hash Map ( ) ; environment . put (  Baggage Utils .  BAGGAGE_ ENVIRONMENT_ VARIABLE , base64 ) ; return environment ; }
@  Override public void draw Series (  Canvas canvas ,  Paint paint ,  List <  Float > points ,  List <  Double > values ,  XYSeries Renderer series Renderer ,  Support Series Render support Series Render , float y Axis Value , int series Index , int start Index ) { int series Nr = m Dataset . get Series Count ( ) ; int length = points . size ( ) ; paint . set Color ( series Renderer . get Color ( ) ) ; paint . set Style (  Style .  FILL ) ; float half Diff X = get Half Diff X ( points , length , series Nr ) ; for ( int i = _ NUM ; i < length ; i += _ NUM ) { float x = points . get ( i ) ; float y = points . get ( i + _ NUM ) ; draw Bar ( canvas , x , y Axis Value , x , y , half Diff X , series Nr , series Index , paint ) ; } paint . set Color ( series Renderer . get Color ( ) ) ; }
public void listen Mod Log (  String username ,  String token ) { if ( ! has Server ( ) ) { return ; } if ( mod Log Listen . contains Key ( username ) ) { return ; } this . token = token ; long user Id = get User Id ( username ) ; mod Log Listen . put ( username , user Id ) ;  LOGGER . info ( _ STR + username + _ STR + user Id ) ; if ( user Id != - _ NUM ) { send Listen Mod Log ( user Id , _ BOOL ) ; } }
public static boolean is Valid Class Name (  String class Name ) { if ( class Name . index Of ( _ STR ) >= _ NUM ) { return _ BOOL ; } return _ BOOL ; }
@  Suppress Warnings ( _ STR ) public void new Minute ( ) { if ( ! in Sync With Internal Fast Clock ) { return ; } if ( correct Fast Clock || synchronize With Internal Clock ) {  Date now = clock . get Time ( ) ; if ( now . get Minutes ( ) != _ NUM ) { cur Days = now . get Date ( ) ; cur Hours = now . get Hours ( ) ; cur Minutes = now . get Minutes ( ) ; long millis = now . get Time ( ) ; long elapsed MS = millis %  MSECPERMINUTE ; double frac_min = elapsed MS / ( double )  MSECPERMINUTE ; cur Fractional Minutes = ( int )  CORRECTION - ( int ) (  CORRECTION * frac_min ) ; set Clock ( ) ; } } else if ( set Internal && ! correct Fast Clock && ! synchronize With Internal Clock ) { in Sync With Internal Fast Clock = _ BOOL ; initiate Read ( ) ; } }
private <  T extends  Discovered System Object > boolean is Data Collection Scan Job Scheduling Needed ( long last Scan Time , boolean in Progress ) { long system Time =  System . current Time Millis ( ) ; long refresh Interval = get Refresh Interval (  Controller Service Impl .  SCANNER ) ; if ( in Progress ) { return _ BOOL ; } if ( last Scan Time > _ NUM && ( system Time - last Scan Time < refresh Interval * _ NUM ) ) { _logger . info ( _ STR ) ; return _ BOOL ; } return _ BOOL ; }
private void remove Breakpoints ( final  Set <  Breakpoint Address > breakpoint Address Set , final  Breakpoint Storage storage ) { if ( breakpoint Address Set . size ( ) != _ NUM ) { final  Set <  Breakpoint > breakpoints = storage . get Break Points By Address ( breakpoint Address Set ) ; storage . remove Breakpoints ( breakpoint Address Set ) ; for ( final  Breakpoint Manager Listener listener : listeners ) { try { listener . breakpoints Removed ( breakpoints ) ; } catch ( final  Exception e ) {  CUtility Functions . log Exception ( e ) ; } } } }
public void replace Creation Template (  Guid guid ,  String template Name ,  Attr Set attr Set ) throws  Config Manager Exception { if ( guid == null ) { guid = new  Guid ( _root DN ) ; }  DN dn =  DN . value Of ( guid . get Dn ( ) ) ;  String org = _ STR ;  List <  RDN > rdns = new  Array List < > ( ) ; for (  RDN rdn : dn ) { rdns . add ( _ NUM , rdn ) ; } for (  RDN rdn : rdns ) { org = org + _ STR +  LDAPUtils . rdn Value ( rdn ) ; }  String service =  CREATIONPATH + _ STR + template Name ;  Map map = convert To Map ( attr Set ) ; try { replace Service Attributes ( org , service , map ) ; } catch (  SMSException e ) {  String args [ ] = new  String [ _ NUM ] ; args [ _ NUM ] = e . to String ( ) ; throw new  Config Manager Exception ( i18n . get String (  IUMSConstants .  ERROR_ CM , args ) ) ; } catch (  SSOException se ) {  String args [ ] = new  String [ _ NUM ] ; args [ _ NUM ] = se . to String ( ) ; throw new  Config Manager Exception ( i18n . get String (  IUMSConstants .  ERROR_ CM , args ) ) ; } }
private void read Object (  Object Input Stream stream ) throws  IOException ,  Class Not Found Exception { stream . default Read Object ( ) ;  Marshalled Instance mi = (  Marshalled Instance ) stream . read Object ( ) ; try { listener = (  Remote Event Listener ) mi . get ( _ BOOL ) ; } catch (  Throwable e ) { if ( e instanceof  Error &&  Throwable Constants . retryable ( e ) ==  Throwable Constants .  BAD_ OBJECT ) { throw (  Error ) e ; } logger . log (  Level .  WARNING , _ STR , e ) ; } }
public  Sc Server create Cluster Server (  String ssn ,  String cluster Name ,  String os Id ) throws  Storage Center APIException {  Parameters params = new  Parameters ( ) ; params . add ( _ STR , cluster Name ) ; params . add ( _ STR , ssn ) ; params . add ( _ STR ,  NOTES_ STRING ) ; params . add ( _ STR , os Id ) ;  Rest Result rr = rest Client . post ( _ STR , params . to Json ( ) ) ; if ( ! check Results ( rr ) ) {  String error =  String . format ( _ STR , cluster Name , rr . get Error Msg ( ) ) ; throw new  Storage Center APIException ( error ) ; } return gson . from Json ( rr . get Result ( ) ,  Sc Server . class ) ; }
public void test Minimal Completion Stage ( ) {  Completable Future <  Integer > f = new  Completable Future < > ( ) ;  Completion Stage <  Integer > g = f . minimal Completion Stage ( ) ;  Atomic Integer x = new  Atomic Integer ( _ NUM ) ;  Atomic Reference <  Throwable > r = new  Atomic Reference <  Throwable > ( ) ; check Incomplete ( f ) ; g . when Complete ( null ) ; f . complete ( _ NUM ) ; check Completed Normally ( f , _ NUM ) ; assert Equals ( x . get ( ) , _ NUM ) ; assert Null ( r . get ( ) ) ; }
private void write Directory Post Resource (  Element post Resource El ,  String path ) { post Resource El . set Attribute ( _ STR ,  DIR_ RESOURCE_ SET ) ; post Resource El . set Attribute ( _ STR , path . replace ( _ STR , _ STR ) ) ; }
static  Potion Type from Name (  String name ) { for (  Potion Type Table table : values ( ) ) { if ( name . equals Ignore Case ( table . name ) ) return table . type ; } return  Potion Type . value Of ( name . to Upper Case ( ) ) ; }
public synchronized void remove Curl Mesh (  Curl Mesh mesh ) { while ( m Curl Meshes . remove ( mesh ) ) ; }
private  List <  Datum > sample Nbest List ( int source Id ,  Sequence <  IString > source ,  Sentence Level Metric <  IString ,  String > score Metric ,  List <  Rich Translation <  IString ,  String > > translations ,  List <  Sequence <  IString > > references ) { int [ ] source Ids = new int [ _ NUM ] ; source Ids [ _ NUM ] = source Id ;  List <  Sequence <  IString > > sources = new  Array List < > ( _ NUM ) ; sources . add ( source ) ;  List <  List <  Rich Translation <  IString ,  String > > > translation List = new  Array List <  List <  Rich Translation <  IString ,  String > > > ( _ NUM ) ; translation List . add ( translations ) ;  List <  List <  Sequence <  IString > > > reference List = new  Array List <  List <  Sequence <  IString > > > ( _ NUM ) ; reference List . add ( references ) ; return sample Nbest Lists ( source Ids , sources , score Metric , translation List , reference List ) ; }
public boolean is Closed ( ) { return map . is Closed ( ) ; }
public void insert Think Time ( ) {  Script Step think Time Script Step =  Script Step Factory . create Think Time ( get Min Think Time ( ) , get Max Think Time ( ) ) ; steps . add ( get Insert Index ( ) , think Time Script Step ) ; min Think Time = _ STR ; max Think Time = _ STR ; reindex Script Steps ( ) ; }
public void add Node ( final  Instruction instruction ) { instructions . add ( instruction ) ; if ( prev Instruction != null ) { add Edge ( prev Instruction , instruction ) ; } prev Instruction = instruction ; }
public void ensure Capacity ( int minimum Capacity ) { if ( minimum Capacity <= _capacity ) return ; if ( minimum Capacity > _ NUM ) { _capacity = ( minimum Capacity + _ NUM ) & ~ _ NUM ; } else { while ( _capacity < minimum Capacity ) { _capacity += _capacity ; } } byte [ ] bytes = new byte [ _capacity ] ;  System . arraycopy ( _buffer , _ NUM , bytes , _ NUM , _length ) ; _buffer = bytes ; }
public <  T >  JSONAPIDocument <  List <  T > > read Document Collection (  Input Stream data Stream ,  Class <  T > clazz ) { try { resource Cache . init ( ) ;  Json Node root Node = object Mapper . read Tree ( data Stream ) ;  Validation Utils . ensure Not Error ( object Mapper , root Node ) ;  Validation Utils . ensure Collection ( root Node ) ; resource Cache . cache ( parse Included ( root Node ) ) ;  List <  T > resource List = new  Array List < > ( ) ; for (  Json Node element : root Node . get (  DATA ) ) {  T pojo = read Object ( element , clazz , _ BOOL ) ; resource List . add ( pojo ) ; }  JSONAPIDocument <  List <  T > > result = new  JSONAPIDocument < > ( resource List , object Mapper ) ; if ( root Node . has (  META ) ) { result . set Meta ( map Meta ( root Node . get (  META ) ) ) ; } if ( root Node . has (  LINKS ) ) { result . set Links ( new  Links ( map Links ( root Node . get (  LINKS ) ) ) ) ; } return result ; } catch (  Runtime Exception e ) { throw e ; } catch (  Exception e ) { throw new  Runtime Exception ( e ) ; } finally { resource Cache . clear ( ) ; } }
public void add Targeted By Swarm ( int entity Id , int weapon Id ) { hit By Swarms Entity . add Element ( new  Integer ( entity Id ) ) ; hit By Swarms Weapon . add Element ( new  Integer ( weapon Id ) ) ; }
private boolean is Checkpoint Exists (  Connection conn ,  String key ) throws  SQLException {  Prepared Statement st = null ;  Result Set rs = null ; try { st = conn . prepare Statement ( chk Exists Sql ) ; st . set String ( _ NUM , key ) ; rs = st . execute Query ( ) ; return rs . next ( ) ; } finally {  U . close ( rs , log ) ;  U . close ( st , log ) ; } }
public  OMScaling Raster ( double ullat , double ullon , double lrlat , double lrlon ,  Image Icon ii ) { this ( ullat , ullon , lrlat , lrlon , ii . get Image ( ) ) ; }
public static void copy Stream (  Input Stream is ,  Output Stream os , byte [ ] buffer , int buffer Size ,  String confid , double file Size ,  Context context ) throws  IOException { double downloaded = _ NUM ; int [ ] update = new int [ _ NUM ] ; try { for ( ; ; ) { int count = is . read ( buffer , _ NUM , buffer Size ) ; downloaded += count ; if ( count == - _ NUM ) { if ( context != null ) { } break ; } os . write ( buffer , _ NUM , count ) ; if ( context != null ) { update [ _ NUM ] = ( int ) downloaded ; update [ _ NUM ] = ( int ) file Size ; update [ _ NUM ] = ( int ) ( ( downloaded / file Size ) * _ NUM ) ; } } } catch (  IOException e ) { throw e ; } }
@  Override public void write Header ( ) throws  IOException { os = new  PDFWriter ( new  Buffered Output Stream ( ros ) ,  PDF_ VERSION ) ; delay Image Queue = new  PDFImage Delay Queue ( os ) ; delay Paint Queue = new  PDFPaint Delay Queue ( os , delay Image Queue ) ; font Table = new  PDFFont Table ( os ) ;  PDFDoc Info info = os . open Doc Info ( _ STR ) ; info . set Title ( get Property (  TITLE ) ) ; info . set Author ( get Property (  AUTHOR ) ) ; info . set Subject ( get Property (  SUBJECT ) ) ; info . set Keywords ( get Property (  KEYWORDS ) ) ; info . set Creator ( get Creator ( ) ) ; info . set Producer ( producer == null ? _ STR : producer ) ; if ( ! is Device Independent ( ) ) {  Calendar now =  Calendar . get Instance ( ) ; info . set Creation Date ( now ) ; info . set Modification Date ( now ) ; } info . set Trapped ( _ STR ) ; os . close ( info ) ;  PDFCatalog catalog = os . open Catalog ( _ STR , _ STR ) ; catalog . set Outlines ( _ STR ) ; catalog . set Page Mode ( _ STR ) ; catalog . set Viewer Preferences ( _ STR ) ; catalog . set Open Action ( new  Object [ ] { os . ref ( _ STR ) , os . name ( _ STR ) } ) ; os . close ( catalog ) ;  PDFViewer Preferences prefs = os . open Viewer Preferences ( _ STR ) ; prefs . set Fit Window ( _ BOOL ) ; prefs . set Center Window ( _ BOOL ) ; os . close ( prefs ) ; alpha Index = _ NUM ; ext GStates = new  Hash Map <  Float ,  String > ( ) ; if ( ! is Multi Page ( ) ) { open Page ( get Size ( ) , null ) ; } }
protected  String parse String ( int closing Character ) throws  IOException ,  RDFParse Exception {  String Builder sb = get Builder ( ) ; while ( _ BOOL ) { int c = read Code Point ( ) ; if ( c == closing Character ) { break ; } else if ( c == - _ NUM ) { throw EOFException ( ) ; } append Codepoint ( sb , c ) ; if ( c == _ STR ) { c = read Code Point ( ) ; if ( c == - _ NUM ) { throw EOFException ( ) ; } append Codepoint ( sb , c ) ; } } return sb . to String ( ) ; }
private void code Unwrap Return Value (  Class < ? > type ,  Data Output Stream out ) throws  IOException { if ( type . is Primitive ( ) ) {  Primitive Type Info prim =  Primitive Type Info . get ( type ) ; out . write Byte ( opc_checkcast ) ; out . write Short ( cp . get Class ( prim . wrapper Class Name ) ) ; out . write Byte ( opc_invokevirtual ) ; out . write Short ( cp . get Method Ref ( prim . wrapper Class Name , prim . unwrap Method Name , prim . unwrap Method Desc ) ) ; if ( type == int . class || type == boolean . class || type == byte . class || type == char . class || type == short . class ) { out . write Byte ( opc_ireturn ) ; } else if ( type == long . class ) { out . write Byte ( opc_lreturn ) ; } else if ( type == float . class ) { out . write Byte ( opc_freturn ) ; } else if ( type == double . class ) { out . write Byte ( opc_dreturn ) ; } else { throw new  Assertion Error ( ) ; } } else { out . write Byte ( opc_checkcast ) ; out . write Short ( cp . get Class ( dot To Slash ( type . get Name ( ) ) ) ) ; out . write Byte ( opc_areturn ) ; } }
private  String format Link (  String [ ] parts ) {  String anchor , text ; if ( parts . length < _ NUM ) { anchor = _ STR ; text = _ STR ; } else { anchor = parts [ _ NUM ] ; text = parts [ _ NUM ] ; } return  String . format ( _ STR , anchor , text ) ; }
public boolean fix Utils (  String [ ] utils ) throws  Exception { for (  String util : utils ) { if ( ! check Util ( util ) ) { if ( check Util ( _ STR ) ) { if ( has Util ( util , _ STR ) ) { fix Util ( util ,  Root Tools . util Path ) ; } } else { if ( check Util ( _ STR ) ) { if ( has Util ( util , _ STR ) ) { fix Util ( util ,  Root Tools . util Path ) ; } } else { return _ BOOL ; } } } } return _ BOOL ; }
@  Override protected void initialize ( ) {  List <  String > patterns ; super . initialize ( ) ; m_ Patterns = new  Array List <  Pattern > ( ) ; patterns = read ( ) ; for (  String pattern : patterns ) { m_ Patterns . add (  Pattern . compile ( pattern ) ) ; } }
public static  String [ ] ls Directories (  String directory ) throws  Exception {  String [ ] tmp = ls ( directory ) ;  Array List <  String > files = new  Array List < > ( ) ; for (  String s : tmp ) { if ( is Directory ( directory +  File . separator + s ) ) files . add ( s ) ; } return files . to Array ( new  String [ files . size ( ) ] ) ; }
public static void encode (  Appendable out , int value ) throws  IOException { value = to VLQSigned ( value ) ; do { int digit = value &  VLQ_ BASE_ MASK ; value >>>=  VLQ_ BASE_ SHIFT ; if ( value > _ NUM ) { digit |=  VLQ_ CONTINUATION_ BIT ; } out . append (  Base64 . to Base64 ( digit ) ) ; } while ( value > _ NUM ) ; }
public mx ICell Overlay remove Cell Overlay (  Object cell , mx ICell Overlay overlay ) { if ( overlay == null ) { remove Cell Overlays ( cell ) ; } else { mx ICell Overlay [ ] arr = get Cell Overlays ( cell ) ; if ( arr != null ) {  List < mx ICell Overlay > list =  Arrays . as List ( arr ) ; if ( list . remove ( overlay ) ) { remove Cell Overlay Component ( overlay , cell ) ; } arr = ( mx ICell Overlay [ ] ) list . to Array ( ) ; overlays . put ( cell , arr ) ; } } return overlay ; }
public void remove Foreign Key ( int idx ) { foreign Keys . remove ( idx ) ; }
public java . lang .  String Buffer insert ( int offset , int i ) { internal . insert ( offset , i ) ; return this ; }
public void add Gefaehrdungs Umsetzung (  Gefaehrdungs Umsetzung gefaehrdung ) { if ( ! all Gefaehrdungs Umsetzungen . contains ( gefaehrdung ) ) { all Gefaehrdungs Umsetzungen . add ( gefaehrdung ) ; } }
String normalize Class Path (  String class Path , boolean generate Relative ) { char sep =  Caucho Util . get Path Separator Char ( ) ; int head = _ NUM ; int tail = _ NUM ;  Char Buffer cb =  Char Buffer . allocate ( ) ; while ( head < class Path . length ( ) ) { tail = class Path . index Of ( sep , head ) ; if ( tail < _ NUM ) tail = class Path . length ( ) ; if ( tail > head ) {  String segment = class Path . substring ( head , tail ) ; segment = normalize Path ( segment , generate Relative ) ; if ( segment != null ) { if ( cb . length ( ) != _ NUM ) cb . append ( sep ) ; cb . append ( segment ) ; } } head = tail + _ NUM ; } return cb . close ( ) ; }
public static double pow ( final double x , final double y ) { if ( y == _ NUM ) { return _ NUM ; } else { final long y Bits =  Double . double To Raw Long Bits ( y ) ; final int y Raw Exp = ( int ) ( ( y Bits &  MASK_ DOUBLE_ EXPONENT ) > > _ NUM ) ; final long y Raw Mantissa = y Bits &  MASK_ DOUBLE_ MANTISSA ; final long x Bits =  Double . double To Raw Long Bits ( x ) ; final int x Raw Exp = ( int ) ( ( x Bits &  MASK_ DOUBLE_ EXPONENT ) > > _ NUM ) ; final long x Raw Mantissa = x Bits &  MASK_ DOUBLE_ MANTISSA ; if ( y Raw Exp > _ NUM ) { if ( ( y Raw Exp == _ NUM && y Raw Mantissa != _ NUM ) || ( x Raw Exp == _ NUM && x Raw Mantissa != _ NUM ) ) { return  Double .  Na N ; } else if ( x Raw Exp == _ NUM && x Raw Mantissa == _ NUM ) { if ( y Raw Exp == _ NUM ) { return  Double .  Na N ; } else { return _ NUM ; } } else { if ( ( y > _ NUM ) ^ ( x Raw Exp < _ NUM ) ) { return  Double .  POSITIVE_ INFINITY ; } else { return + _ NUM ; } } } else { if ( y Raw Exp >= _ NUM ) { final long y Full Mantissa =  IMPLICIT_ HIGH_ BIT | y Raw Mantissa ; if ( y Raw Exp < _ NUM ) { final long integral Mask = ( - _ NUM ) << ( _ NUM - y Raw Exp ) ; if ( ( y Full Mantissa & integral Mask ) == y Full Mantissa ) { final long l = y Full Mantissa > > ( _ NUM - y Raw Exp ) ; return  Fast Math . pow ( x , ( y < _ NUM ) ? - l : l ) ; } } else { final long l = y Full Mantissa << ( y Raw Exp - _ NUM ) ; return  Fast Math . pow ( x , ( y < _ NUM ) ? - l : l ) ; } } if ( x == _ NUM ) { return y < _ NUM ?  Double .  POSITIVE_ INFINITY : + _ NUM ; } else if ( x Raw Exp == _ NUM ) { if ( x Raw Mantissa == _ NUM ) { return ( y < _ NUM ) ? + _ NUM :  Double .  POSITIVE_ INFINITY ; } else { return  Double .  Na N ; } } else if ( x < _ NUM ) { return  Double .  Na N ; } else { final double tmp = y *  HEX_40000000 ; final double ya = ( y + tmp ) - tmp ; final double yb = y - ya ; final double lns [ ] = new double [ _ NUM ] ; final double lores = log ( x , lns ) ; if (  Double . is Infinite ( lores ) ) { return lores ; } double lna = lns [ _ NUM ] ; double lnb = lns [ _ NUM ] ; final double tmp1 = lna *  HEX_40000000 ; final double tmp2 = ( lna + tmp1 ) - tmp1 ; lnb += lna - tmp2 ; lna = tmp2 ; final double aa = lna * ya ; final double ab = lna * yb + lnb * ya + lnb * yb ; lna = aa + ab ; lnb = - ( lna - aa - ab ) ; double z = _ NUM / _ NUM ; z = z * lnb + ( _ NUM / _ NUM ) ; z = z * lnb + ( _ NUM / _ NUM ) ; z = z * lnb + _ NUM ; z = z * lnb + _ NUM ; z *= lnb ; final double result = exp ( lna , z , null ) ; return result ; } } } }
protected  Node string Conversion (  Node node ) {  Type Element string Element = elements . get Type Element ( _ STR ) ; if ( !  Types Utils . is String ( node . get Type ( ) ) ) {  Node converted = new  String Conversion Node ( node . get Tree ( ) , node , string Element . as Type ( ) ) ; add To Converted Lookup Map ( converted ) ; insert Node After ( converted , node ) ; return converted ; } else { return node ; } }
private void validate ( ) throws  URISyntax Exception {  String s = get Scheme ( ) ; if ( ( s != null ) && ( s . compare To ( _ STR ) == _ NUM ) ) { return ; } if ( get Local Vm Id ( ) == - _ NUM ) { throw new  URISyntax Exception ( uri . to String ( ) , _ STR ) ; } }
public synchronized void finish Writing ( ) { done Writing = _ BOOL ; notify All ( ) ; }
private long offset2 Physical Address ( final long offset ) { return offset + header Size ; }
@  Override public void internal Entity Decl (  String name ,  XMLString text ,  XMLString non Normalized Text ,  Augmentations augs ) throws  XNIException { try { if ( f Decl Handler != null ) { f Decl Handler . internal Entity Decl ( name , text . to String ( ) ) ; } } catch (  SAXException e ) { throw new  XNIException ( e ) ; } }
public static boolean is Authorized (  String log Name ,  String operation ,  Object credential ) { return authorizer . is Authorized ( log Name , operation , credential ) ; }
public  Object next ( ) { if ( pos < size ) return  Array . get ( array , pos ++ ) ; throw new  No Such Element Exception ( _ STR + pos + _ STR + size ) ; }
public  Permission Request Object on Rational (  Func3 rational Func ) { m Rational Func = rational Func ; return this ; }
public  Generic Principal (  String user Name ,  String password ,  List <  String > roles ,  Map <  String ,  List <  Generic Principal .  Attribute > > write Entries ,  Map <  String ,  List <  Generic Principal .  Attribute > > read Entries ,  Map <  String ,  List <  Generic Principal .  Attribute > > execute Tasks ) { this . user Name = user Name ; this . password = password ; this . write Entries = write Entries ; this . read Entries = read Entries ; this . execute Tasks = execute Tasks ; if ( roles != null ) { this . roles = new  String [ roles . size ( ) ] ; this . roles = roles . to Array ( this . roles ) ; if ( this . roles . length > _ NUM )  Arrays . sort ( this . roles ) ; } write Match Objects = new  Hash Map <  String ,  Match Object > ( ) ; read Match Objects = new  Hash Map <  String ,  Match Object > ( ) ; execute Match Objects = new  Hash Map <  String ,  Match Object > ( ) ; user Defined Roles = new  Array List <  String > ( ) ; }
public static int roll1 D6 ( ) { return rand . next Int ( _ NUM ) + _ NUM ; }
static byte [ ] septet Stream2octet Stream ( byte [ ] septets ) { int octet Length = ( int )  Math . ceil ( ( ( septets . length * _ NUM ) ) / _ NUM ) ; byte [ ] octets = new byte [ octet Length ] ; for ( int i = _ NUM ; i < septets . length ; i ++ ) { for ( int j = _ NUM ; j < _ NUM ; j ++ ) { if ( ( septets [ i ] & ( _ NUM << j ) ) != _ NUM ) { int bit Index = ( i * _ NUM ) + j ; octets [ bit Index > > > _ NUM ] |= _ NUM << ( bit Index & _ NUM ) ; } } } return octets ; }
public  CTagging Panel ( final  JFrame parent , final  Zy Graph graph , final  ITag Manager manager ) { super ( new  Border Layout ( ) ) ; m_tags Tree = new  CTags Tree ( parent , graph , manager ) ; final  JScroll Pane pane = new  JScroll Pane ( m_tags Tree ) ; pane . set Vertical Scroll Bar Policy (  Scroll Pane Constants .  VERTICAL_ SCROLLBAR_ AS_ NEEDED ) ; pane . set Horizontal Scroll Bar Policy (  Scroll Pane Constants .  HORIZONTAL_ SCROLLBAR_ AS_ NEEDED ) ; add ( pane ) ; set Border ( new  Titled Border ( new  Line Border (  Color .  LIGHT_ GRAY , _ NUM , _ BOOL ) , _ STR ) ) ; set Double Buffered ( _ BOOL ) ; }
@  Override public double height ( final int marker Index ) {  Math Utils . check Range Inclusive ( marker Index , _ NUM , marker Array . length - _ NUM ) ; return marker Array [ marker Index ] . marker Height ; }
public <  K ,  V > void consume (  String group Id ,  String client Id ,  Offset Reset Strategy auto Offset Reset ,  Deserializer <  K > key Deserializer ,  Deserializer <  V > value Deserializer ,  Boolean Supplier continuation ,  Offset Commit Callback offset Commit Callback ,  Runnable completion ,  Collection <  String > topics , java . util . function .  Consumer <  Consumer Record <  K ,  V > > consumer Function ) {  Properties props = get Consumer Properties ( group Id , client Id , auto Offset Reset ) ;  Thread t = new  Thread ( null ) ; t . set Name ( client Id + _ STR ) ; t . start ( ) ; }
public double distance (  Instance first ,  Instance second ,  Performance Stats stats ) { return  Math . sqrt ( distance ( first , second ,  Double .  POSITIVE_ INFINITY , stats ) ) ; }
public void find Same As Chaining (  Resource subj ,  Set <  Resource > current Same As ,  Resource [ ] contxts ) throws  Inference Engine Exception { try {  Closeable Iteration <  Statement ,  Query Evaluation Exception > subj Iter =  Rya DAOHelper . query ( rya DAO , subj ,  OWL .  SAMEAS , null , conf , contxts ) ; while ( subj Iter . has Next ( ) ) {  Statement st = subj Iter . next ( ) ; if ( ! current Same As . contains ( st . get Object ( ) ) ) {  Resource casted Obj = (  Resource ) st . get Object ( ) ; current Same As . add ( casted Obj ) ; find Same As Chaining ( casted Obj , current Same As , contxts ) ; } } subj Iter . close ( ) ;  Closeable Iteration <  Statement ,  Query Evaluation Exception > obj Iter =  Rya DAOHelper . query ( rya DAO , null ,  OWL .  SAMEAS , subj , conf , contxts ) ; while ( obj Iter . has Next ( ) ) {  Statement st = obj Iter . next ( ) ; if ( ! current Same As . contains ( st . get Subject ( ) ) ) {  Resource same As Subj = st . get Subject ( ) ; current Same As . add ( same As Subj ) ; find Same As Chaining ( same As Subj , current Same As , contxts ) ; } } obj Iter . close ( ) ; } catch (  Query Evaluation Exception e ) { throw new  Inference Engine Exception ( e ) ; } }
public static void reindex (  Connection conn ) throws  SQLException { init ( conn ) ; remove All Triggers ( conn ,  TRIGGER_ PREFIX ) ; remove Index Files ( conn ) ;  Statement stat = conn . create Statement ( ) ;  Result Set rs = stat . execute Query ( _ STR +  SCHEMA + _ STR ) ; while ( rs . next ( ) ) {  String schema = rs . get String ( _ STR ) ;  String table = rs . get String ( _ STR ) ; create Trigger ( conn , schema , table ) ; index Existing Rows ( conn , schema , table ) ; } }
private void resize Tables ( ) { if ( m Object Data Used > m Object Data . length -  MAX_ DATA_ SIZE ) { m Object Data =  Arrays . copy Of ( m Object Data , m Object Data . length * _ NUM ) ; } if ( m Object Count < m Types . length ) { return ; } m Object Offset =  Arrays . copy Of ( m Object Offset , m Object Offset . length * _ NUM ) ; m Types =  Arrays . copy Of ( m Types , m Types . length * _ NUM ) ; m Objects =  Arrays . copy Of ( m Objects , m Objects . length * _ NUM ) ; m Rect =  Arrays . copy Of ( m Rect , m Rect . length * _ NUM ) ; }
protected static double convert Percentile To X ( double percentile Level Iterated To ) { double x = _ NUM / ( _ NUM - ( percentile Level Iterated To / _ NUM ) ) ; return  Math . log10 ( x ) ; }
public static  String queue Name From DBName (  String db Name ) {  String [ ] tokens = db Name . split ( _ STR , _ NUM ) ; return tokens [ _ NUM ] ; }
public  String  Use This ( int type ,  String id ,  String context ) { int i =  Find Sym ( type , id , context ) ; if ( i == symtab . size ( ) ) return id ; else return ( (  Sym Tab Entry ) symtab . element At ( i ) ) . use This ; }
private float angle (  Touch State s ) { return ( float )  Math . to Degrees (  Math . atan2 ( s . y Down - s . y Current , s . x Down - s . x Current ) ) ; }
private int uint16 From Data ( int offset ) { return two Bytes To Int (  Arrays . copy Of Range ( data ( ) , offset , offset + _ NUM ) ,  Constants .  CC2540_ BYTE_ ORDER ) ; }
protected static  Pair <  String ,  String > asr Register ( final long offset , final  ITranslation Environment environment , final  List <  Reil Instruction > instructions , final  String register Node Value1 , final  String register Node Value2 ) { final  String shifter Operand = environment . get Next Variable String ( ) ; final  String shifter Carry Out = environment . get Next Variable String ( ) ; final  String is Zero Condition = environment . get Next Variable String ( ) ; final  String is Less Condition = environment . get Next Variable String ( ) ; final  String is Gt Eq Condition = environment . get Next Variable String ( ) ; final  String shifter Carry Out Tmp1 = environment . get Next Variable String ( ) ; final  String shifter Carry Out Tmp2 = environment . get Next Variable String ( ) ; final  String shifter Carry Out Tmp3 = environment . get Next Variable String ( ) ; final  String shifter Carry Out Tmp4 = environment . get Next Variable String ( ) ; final  String shifter Operand Tmp1 = environment . get Next Variable String ( ) ; final  String shifter Operand Tmp2 = environment . get Next Variable String ( ) ; final  String shifter Operand Tmp3 = environment . get Next Variable String ( ) ; final  String shifter Operand Tmp4 = environment . get Next Variable String ( ) ; final  String tmp Rs Register = environment . get Next Variable String ( ) ; final  String negative Tmp Rs Register = environment . get Next Variable String ( ) ; final  String tmp Var1 = environment . get Next Variable String ( ) ; final  String tmp Var2 = environment . get Next Variable String ( ) ; final  String tmp Var3 = environment . get Next Variable String ( ) ; final  String tmp Var4 = environment . get Next Variable String ( ) ; final  String tmp Var5 = environment . get Next Variable String ( ) ; final  String tmp Var6 = environment . get Next Variable String ( ) ; final  String tmp Var7 = environment . get Next Variable String ( ) ; final  String tmp Var8 = environment . get Next Variable String ( ) ; final  String tmp Var9 = environment . get Next Variable String ( ) ; final  String tmp Var10 = environment . get Next Variable String ( ) ; final  String tmp Var11 = environment . get Next Variable String ( ) ; long base Offset = offset ; instructions . add (  Reil Helpers . create And ( base Offset ++ , d Word Size , register Node Value2 , d Word Size ,  String . value Of ( _ NUM ) , d Word Size , tmp Rs Register ) ) ; instructions . add (  Reil Helpers . create Sub ( base Offset ++ , d Word Size , zero Set , d Word Size , tmp Rs Register , d Word Size , negative Tmp Rs Register ) ) ; instructions . add (  Reil Helpers . create Bisz ( base Offset ++ , d Word Size , tmp Rs Register , byte Size , is Zero Condition ) ) ; instructions . add (  Reil Helpers . create And ( base Offset ++ , byte Size , _ STR , byte Size , is Zero Condition , byte Size , shifter Carry Out Tmp1 ) ) ; instructions . add (  Reil Helpers . create Sub ( base Offset ++ , d Word Size ,  String . value Of ( _ NUM ) , byte Size , is Zero Condition , d Word Size , tmp Var1 ) ) ; instructions . add (  Reil Helpers . create And ( base Offset ++ , d Word Size , tmp Var1 , d Word Size , register Node Value2 , d Word Size , shifter Operand Tmp1 ) ) ; instructions . add (  Reil Helpers . create And ( base Offset ++ , d Word Size , tmp Rs Register , d Word Size ,  String . value Of ( _ NUM ) , d Word Size , tmp Var2 ) ) ; instructions . add (  Reil Helpers . create Bisz ( base Offset ++ , d Word Size , tmp Var2 , byte Size , is Less Condition ) ) ; instructions . add (  Reil Helpers . create Add ( base Offset ++ , d Word Size , register Node Value1 , d Word Size , bit Mask Highest Bit Set , d Word Size , tmp Var3 ) ) ; instructions . add (  Reil Helpers . create Bsh ( base Offset ++ , d Word Size , tmp Var3 , d Word Size , negative Tmp Rs Register , d Word Size , tmp Var4 ) ) ; instructions . add (  Reil Helpers . create Bsh ( base Offset ++ , d Word Size , bit Mask Highest Bit Set , d Word Size , negative Tmp Rs Register , d Word Size , tmp Var5 ) ) ; instructions . add (  Reil Helpers . create Sub ( base Offset ++ , d Word Size , tmp Var4 , d Word Size , tmp Var5 , d Word Size , tmp Var6 ) ) ; instructions . add (  Reil Helpers . create Sub ( base Offset ++ , d Word Size , zero Set , byte Size , is Less Condition , d Word Size , tmp Var7 ) ) ; instructions . add (  Reil Helpers . create And ( base Offset ++ , d Word Size , tmp Var6 , d Word Size , tmp Var7 , d Word Size , shifter Operand Tmp2 ) ) ; instructions . add (  Reil Helpers . create Sub ( base Offset ++ , d Word Size , tmp Rs Register , byte Size , one Set , d Word Size , tmp Var8 ) ) ; instructions . add (  Reil Helpers . create Sub ( base Offset ++ , d Word Size , zero Set , d Word Size , tmp Var8 , d Word Size , tmp Var8 ) ) ; instructions . add (  Reil Helpers . create Bsh ( base Offset ++ , d Word Size , register Node Value1 , d Word Size , tmp Var8 , d Word Size , tmp Var9 ) ) ; instructions . add (  Reil Helpers . create And ( base Offset ++ , d Word Size , tmp Var9 , byte Size , is Less Condition , byte Size , shifter Carry Out Tmp2 ) ) ; instructions . add (  Reil Helpers . create Or ( base Offset ++ , byte Size , is Zero Condition , byte Size , is Less Condition , byte Size , tmp Var10 ) ) ; instructions . add (  Reil Helpers . create Bisz ( base Offset ++ , byte Size , tmp Var10 , byte Size , is Gt Eq Condition ) ) ; instructions . add (  Reil Helpers . create Bsh ( base Offset ++ , d Word Size , register Node Value1 , d Word Size , minus Thirty One Set , byte Size , tmp Var11 ) ) ; instructions . add (  Reil Helpers . create Sub ( base Offset ++ , byte Size , zero Set , byte Size , is Gt Eq Condition , d Word Size , shifter Operand Tmp3 ) ) ; instructions . add (  Reil Helpers . create And ( base Offset ++ , byte Size , tmp Var11 , byte Size , is Gt Eq Condition , byte Size , shifter Carry Out Tmp3 ) ) ; instructions . add (  Reil Helpers . create Or ( base Offset ++ , byte Size , shifter Carry Out Tmp1 , byte Size , shifter Carry Out Tmp2 , byte Size , shifter Carry Out Tmp4 ) ) ; instructions . add (  Reil Helpers . create Or ( base Offset ++ , byte Size , shifter Carry Out Tmp3 , byte Size , shifter Carry Out Tmp4 , byte Size , shifter Carry Out ) ) ; instructions . add (  Reil Helpers . create Or ( base Offset ++ , d Word Size , shifter Operand Tmp1 , d Word Size , shifter Operand Tmp2 , d Word Size , shifter Operand Tmp4 ) ) ; instructions . add (  Reil Helpers . create Or ( base Offset ++ , d Word Size , shifter Operand Tmp3 , d Word Size , shifter Operand Tmp4 , d Word Size , shifter Operand ) ) ; return new  Pair <  String ,  String > ( shifter Operand , shifter Carry Out ) ; }
private static  String remove Quotes Encolosing Option (  String file Name ,  String option ) throws  Exception {  String option1 = remove Quote Characters If Necessary ( file Name , option , _ STR ) ; if ( ! option1 . equals ( option ) ) { return option1 ; } return remove Quote Characters If Necessary ( file Name , option , _ STR ) ; }
@  Override public  String generate Label (  XYDataset dataset , int series ) {  Param Checks . null Not Permitted ( dataset , _ STR ) ;  String label =  Message Format . format ( this . format Pattern , create Item Array ( dataset , series ) ) ; return label ; }
private boolean match Strings (  String pattern ,  String str ,  Map <  String ,  String > uri Template Variables ) {  Ant Path String Matcher matcher = new  Ant Path String Matcher ( pattern , str , uri Template Variables ) ; return matcher . match Strings ( ) ; }
@  Nullable public  Dimension adjust ( @  Not Null  Dimension new Preferred Size , @  Nullable  Dimension old Preferred Size , @  Not Null  Editor Impl editor ) { if ( old Preferred Size == null || my Skip ) { return new Preferred Size ; } if ( new Preferred Size . height != old Preferred Size . height ) { return new Preferred Size ; } strip Timings ( ) ; my Timings . add (  System . current Time Millis ( ) ) ; if ( my Timings . size ( ) <  FREQUENT_ SIZE_ CHANGES_ NUMBER ) { return new Preferred Size ; } boolean increase Width = new Preferred Size . width > old Preferred Size . width ;  Dimension result ; if ( increase Width ) { final int space Width =  Editor Util . get Space Width (  Font .  PLAIN , editor ) ; new Preferred Size . width += my Reserve Columns * space Width ; my Reserve Columns += _ NUM ; result = new Preferred Size ; } else { result = old Preferred Size ; } schedule Size Update ( editor ) ; return result ; }
public  RVMField find Declared Field (  Atom field Name ,  Atom field Descriptor ) { for (  RVMField field : declared Fields ) { if ( field . get Name ( ) == field Name && field . get Descriptor ( ) == field Descriptor ) { return field ; } } return null ; }
public  Quarter (  Date time ,  Time Zone zone ) { this ( time , zone ,  Locale . get Default ( ) ) ; }
private  Util ( ) { }
default  B with Default (  String key , float value ) { return with Default ( key ,  Float . to String ( value ) ) ; }
public static boolean read Boolean ( final  JSONArray json Array , final int index , final boolean required , final boolean not Null ) throws  JSONException { if ( required ) { return json Array . get Boolean ( index ) ; } if ( not Null && json Array . is Null ( index ) ) { throw new  JSONException (  String . format (  Locale .  US ,  NULL_ VALUE_ FORMAT_ ARRAY , index ) ) ; } boolean value = _ BOOL ; if ( ! json Array . is Null ( index ) ) { value = json Array . get Boolean ( index ) ; } return value ; }
protected static void auto Boxing (  Method Visitor mv ,  Type field Type ) { switch ( field Type . get Sort ( ) ) { case  Type .  BOOLEAN : mv . visit Method Insn (  INVOKESTATIC , _ STR , _ STR , _ STR ) ; break ; case  Type .  BYTE : mv . visit Method Insn (  INVOKESTATIC , _ STR , _ STR , _ STR ) ; break ; case  Type .  CHAR : mv . visit Method Insn (  INVOKESTATIC , _ STR , _ STR , _ STR ) ; break ; case  Type .  SHORT : mv . visit Method Insn (  INVOKESTATIC , _ STR , _ STR , _ STR ) ; break ; case  Type .  INT : mv . visit Method Insn (  INVOKESTATIC , _ STR , _ STR , _ STR ) ; break ; case  Type .  FLOAT : mv . visit Method Insn (  INVOKESTATIC , _ STR , _ STR , _ STR ) ; break ; case  Type .  LONG : mv . visit Method Insn (  INVOKESTATIC , _ STR , _ STR , _ STR ) ; break ; case  Type .  DOUBLE : mv . visit Method Insn (  INVOKESTATIC , _ STR , _ STR , _ STR ) ; break ; } }
public final void open Pdf File ( final byte [ ] data ) throws  Pdf Exception { final  Random Access Buffer pdf_datafile ; try { if (  Pdf File Reader . always Cache In Memory == - _ NUM || data . length <  Pdf File Reader . always Cache In Memory ) { pdf_datafile = new  Random Access Data Buffer ( data ) ; } else { try { final  File file =  File . create Temp File ( _ STR , _ STR , new  File (  Object Store . temp_dir ) ) ; temp File Name = file . get Absolute Path ( ) ; final java . io .  File Output Stream a = new java . io .  File Output Stream ( file ) ; a . write ( data ) ; a . flush ( ) ; a . close ( ) ; pdf_datafile = new  Random Access File Buffer ( temp File Name , _ STR ) ; } catch ( final  Exception e ) { throw new  Runtime Exception ( _ STR +  Object Store . temp_dir + _ STR + e ) ; } } object Reader . init ( pdf_datafile ) ; } catch ( final  Exception e ) {  Log Writer . write Log ( _ STR + e + _ STR ) ; throw new  Pdf Exception ( _ STR + e + _ STR ) ; } }
public static void main (  String [ ] args ) { if ( args . length < _ NUM ) {  LOGGER . error ( _ STR ) ; return ; } int last Index = args . length - _ NUM ;  Path [ ] files = get Files ( args ) ;  Main main = new  Main ( ) ; main . generate ( files [ last Index ] ,  Arrays . copy Of ( files , last Index ) ) ; }
@  Nullable  E await Match ( int start ) { for ( int step = _ NUM , total Spins = _ NUM ; ( step <  ARENA_ LENGTH ) && ( total Spins <  SPINS ) ; step ++ ) { int index = ( start + step ) &  ARENA_ MASK ;  Atomic Reference <  Object > slot = arena [ index ] ;  Object found = slot . get ( ) ; if ( found ==  FREE ) { if ( slot . compare And Set (  FREE ,  WAITER ) ) { int slot Spins = _ NUM ; for ( ; ; ) { found = slot . get ( ) ; if ( ( found !=  WAITER ) && slot . compare And Set ( found ,  FREE ) ) { @  Suppress Warnings ( _ STR )  E e = (  E ) found ; return e ; } else if ( ( slot Spins >=  SPINS_ PER_ STEP ) && ( found ==  WAITER ) && ( slot . compare And Set (  WAITER ,  FREE ) ) ) { total Spins += slot Spins ; break ; } slot Spins ++ ; } } } else if ( ( found !=  WAITER ) && slot . compare And Set ( found ,  FREE ) ) { @  Suppress Warnings ( _ STR )  E e = (  E ) found ; return e ; } } return null ; }
private  Array List <  Signature > construct One Signatures (  Set DBIDs [ ] [ ] partitions , final long [ ] [ ] markers ) { final int dim = partitions . length ;  Array List <  Signature > signatures = new  Array List < > ( ) ; for ( int d = _ NUM ; d < dim ; d ++ ) { final  DBIDs [ ] parts = partitions [ d ] ; if ( parts == null ) { continue ; } final long [ ] marked = markers [ d ] ; for ( int start =  Bits Util . next Set Bit ( marked , _ NUM ) ; start >= _ NUM ; ) { int end =  Bits Util . next Clear Bit ( marked , start + _ NUM ) ; end = ( end == - _ NUM ) ? dim : end ; int [ ] signature = new int [ dim << _ NUM ] ;  Arrays . fill ( signature , - _ NUM ) ; signature [ d << _ NUM ] = start ; signature [ ( d << _ NUM ) + _ NUM ] = end - _ NUM ;  Hash Set Modifiable DBIDs sids = union DBIDs ( parts , start , end ) ; if (  LOG . is Debugging ( ) ) {  LOG . debug ( _ STR + d + _ STR + start + _ STR + ( end - _ NUM ) ) ; } signatures . add ( new  Signature ( signature , sids ) ) ; start = ( end < dim ) ?  Bits Util . next Set Bit ( marked , end + _ NUM ) : - _ NUM ; } } return signatures ; }
public static int find End Trim Newline Chars (  Char Sequence s ) { for ( int i = s . length ( ) ; i > _ NUM ; ) { if ( s . char At ( i - _ NUM ) != _ STR ) { return i ; } i -- ; if ( i > _ NUM && s . char At ( i - _ NUM ) == _ STR ) { i -- ; } } return _ NUM ; }
public static  String assert JQ (  Solr Query Request req ,  String ... tests ) throws  Exception { return assert JQ ( req ,  JSONTest Util .  DEFAULT_ DELTA , tests ) ; }
private void calc Coordinates ( final float x , final float [ ] [ ]  Trm , float char Spacing ) { final float [ ] [ ] trm = new float [ _ NUM ] [ _ NUM ] ; for ( int xx = _ NUM ; xx < _ NUM ; xx ++ ) {  System . arraycopy (  Trm [ xx ] , _ NUM , trm [ xx ] , _ NUM , _ NUM ) ; } x1 = x ; x2 = trm [ _ NUM ] [ _ NUM ] - ( char Spacing * trm [ _ NUM ] [ _ NUM ] ) ; if ( glyph Data . is Horizontal ( ) ) { if ( trm [ _ NUM ] [ _ NUM ] < _ NUM ) { x1 = x + trm [ _ NUM ] [ _ NUM ] - ( char Spacing * trm [ _ NUM ] [ _ NUM ] ) ; x2 = trm [ _ NUM ] [ _ NUM ] ; } else if ( trm [ _ NUM ] [ _ NUM ] > _ NUM ) { x1 = x ; x2 = trm [ _ NUM ] [ _ NUM ] ; } } else if ( trm [ _ NUM ] [ _ NUM ] > _ NUM ) { x1 = trm [ _ NUM ] [ _ NUM ] ; x2 = x + trm [ _ NUM ] [ _ NUM ] - ( char Spacing * trm [ _ NUM ] [ _ NUM ] ) ; } else if ( trm [ _ NUM ] [ _ NUM ] < _ NUM ) { x2 = trm [ _ NUM ] [ _ NUM ] ; x1 = x + trm [ _ NUM ] [ _ NUM ] - ( char Spacing * trm [ _ NUM ] [ _ NUM ] ) ; } }
public void print Entry (  Writer w ) { try {  String indent = _ STR ; int indent Width = indent . length ( ) ;  Hardcopy Writer ww = (  Hardcopy Writer ) w ; int text Space = ww . get Characters Per Line ( ) - indent Width - _ NUM ;  String new Line = _ STR ; w . write ( new Line , _ NUM , _ NUM ) ;  String s = _ STR + _id ; w . write ( s , _ NUM , s . length ( ) ) ; if ( ! ( _consist Number . equals ( _ STR ) ) ) { w . write ( new Line , _ NUM , _ NUM ) ; s = _ STR + _consist Number ; w . write ( s , _ NUM , s . length ( ) ) ; } if ( ! ( _road Name . equals ( _ STR ) ) ) { w . write ( new Line , _ NUM , _ NUM ) ; s = _ STR + _road Name ; w . write ( s , _ NUM , s . length ( ) ) ; } if ( ! ( _road Number . equals ( _ STR ) ) ) { w . write ( new Line , _ NUM , _ NUM ) ; s = _ STR + _road Number ; w . write ( s , _ NUM , s . length ( ) ) ; } if ( ! ( _model . equals ( _ STR ) ) ) { w . write ( new Line , _ NUM , _ NUM ) ; s = _ STR + _model ; w . write ( s , _ NUM , s . length ( ) ) ; } if ( ! ( _loco1 Dcc Address . equals ( _ STR ) ) ) { w . write ( new Line , _ NUM , _ NUM ) ; s = _ STR + _loco1 Dcc Address + _ STR + _loco1 Direction ; w . write ( s , _ NUM , s . length ( ) ) ; } if ( ! ( _loco2 Dcc Address . equals ( _ STR ) ) ) { w . write ( new Line , _ NUM , _ NUM ) ; s = _ STR + _loco2 Dcc Address + _ STR + _loco2 Direction ; w . write ( s , _ NUM , s . length ( ) ) ; } if ( ! ( _loco3 Dcc Address . equals ( _ STR ) ) ) { w . write ( new Line , _ NUM , _ NUM ) ; s = _ STR + _loco3 Dcc Address + _ STR + _loco3 Direction ; w . write ( s , _ NUM , s . length ( ) ) ; } if ( ! ( _loco4 Dcc Address . equals ( _ STR ) ) ) { w . write ( new Line , _ NUM , _ NUM ) ; s = _ STR + _loco4 Dcc Address + _ STR + _loco4 Direction ; w . write ( s , _ NUM , s . length ( ) ) ; } if ( ! ( _loco5 Dcc Address . equals ( _ STR ) ) ) { w . write ( new Line , _ NUM , _ NUM ) ; s = _ STR + _loco5 Dcc Address + _ STR + _loco5 Direction ; w . write ( s , _ NUM , s . length ( ) ) ; } if ( ! ( _loco6 Dcc Address . equals ( _ STR ) ) ) { w . write ( new Line , _ NUM , _ NUM ) ; s = _ STR + _loco6 Dcc Address + _ STR + _loco6 Direction ; w . write ( s , _ NUM , s . length ( ) ) ; } if ( ! ( _comment . equals ( _ STR ) ) ) {  Vector <  String > comment Vector = wrap Comment ( _comment , text Space ) ; int k = _ NUM ; w . write ( new Line , _ NUM , _ NUM ) ; s = _ STR + comment Vector . element At ( k ) ; w . write ( s , _ NUM , s . length ( ) ) ; k ++ ; while ( k < comment Vector . size ( ) ) {  String token = comment Vector . element At ( k ) ; if ( ! token . equals ( _ STR ) ) { s = indent + token ; } else { s = token ; } w . write ( s , _ NUM , s . length ( ) ) ; k ++ ; } } w . write ( new Line , _ NUM , _ NUM ) ; } catch (  IOException e ) { log . error ( _ STR + e ) ; } }
protected java . util .  Date from Julian ( int julian ) {  YMD ymd = new  YMD ( julian ) ;  Gregorian Calendar cal = new  Gregorian Calendar ( ymd . year , ymd . month - _ NUM , ymd . day ) ; return cal . get Time ( ) ; }
public synchronized boolean remove Last (  K obj ) { if ( peek Last ( ) != obj ) { return _ BOOL ; } array =  Arrays . copy Of ( array , array . length - _ NUM ) ; return _ BOOL ; }
private boolean serialize Compact RDFStruct Prop (  XMPNode node , int indent , boolean has RDFResource Qual ) throws  XMPException ,  IOException { boolean has Attr Fields = _ BOOL ; boolean has Elem Fields = _ BOOL ; boolean emit End Tag = _ BOOL ; for (  Iterator ic = node . iterate Children ( ) ; ic . has Next ( ) ; ) {  XMPNode field = (  XMPNode ) ic . next ( ) ; if ( can Be RDFAttr Prop ( field ) ) { has Attr Fields = _ BOOL ; } else { has Elem Fields = _ BOOL ; } if ( has Attr Fields && has Elem Fields ) { break ; } } if ( has RDFResource Qual && has Elem Fields ) { throw new  XMPException ( _ STR ,  XMPError .  BADRDF ) ; } if ( ! node . has Children ( ) ) { write ( _ STR ) ; write Newline ( ) ; emit End Tag = _ BOOL ; } else if ( ! has Elem Fields ) { serialize Compact RDFAttr Props ( node , indent + _ NUM ) ; write ( _ STR ) ; write Newline ( ) ; emit End Tag = _ BOOL ; } else if ( ! has Attr Fields ) { write ( _ STR ) ; write Newline ( ) ; serialize Compact RDFElement Props ( node , indent + _ NUM ) ; } else { write ( _ STR ) ; write Newline ( ) ; write Indent ( indent + _ NUM ) ; write (  RDF_ STRUCT_ START ) ; serialize Compact RDFAttr Props ( node , indent + _ NUM ) ; write ( _ STR ) ; write Newline ( ) ; serialize Compact RDFElement Props ( node , indent + _ NUM ) ; write Indent ( indent + _ NUM ) ; write (  RDF_ STRUCT_ END ) ; write Newline ( ) ; } return emit End Tag ; }
public default  Utility Table query Util (  BNetwork network ,  String query Var ,  Assignment evidence ) { return query Util ( new  Query .  Util Query ( network ,  Arrays . as List ( query Var ) , evidence ) ) ; }
public static float [ ] string List To Numeric (  List <  String > score List ) throws  Number Format Exception { float [ ] scores = new float [ score List . size ( ) ] ; int score Id = _ NUM ; for (  String score : score List ) { float float Score = ( float )  Double . parse Double ( score ) ; if (  Float . is Na N ( float Score ) ) { throw new  Number Format Exception ( _ STR + score ) ; } scores [ score Id ++ ] = float Score ; } return scores ; }
@  Override public void next ( ) { current Image =  Optional . of ( add Index And Get Image By Offset ( + _ NUM ) ) ; event Bus . post ( new  Source Has Pending Update Event ( this ) ) ; }
protected void parse (  Data Input Stream stream ) throws  Exception { int size = stream . read Int ( ) ; int ret , read = _ NUM ; data = new byte [ size ] ; while ( size > _ NUM ) { ret = stream . read ( data , read , size ) ; size -= ret ; read += ret ; } }
private  List <  Activity > find Best Insertion (  List <  Activity > partial Route , boolean allow As Major ) { int start Index = _ NUM ; int end Index = partial Route . size ( ) - _ NUM ; if ( allow As Major ) { start Index = _ NUM ; end Index = partial Route . size ( ) ; }  List <  Activity > new List = partial Route ; double best =  Double .  POSITIVE_ INFINITY ;  List <  Activity > best List = null ; for ( int i = start Index ; i <= end Index ; i ++ ) {  List <  Activity > tmp List = new  Array List < > ( new List ) ;  Activity tmp Activity = get Relocation Activity ( ) ; tmp List . add ( i , tmp Activity ) ; double tmp = evaluate List ( tmp List ) ; if ( tmp < best ) { if ( i == _ NUM ) { tmp Activity . set Type ( _ STR ) ; tmp Activity . set End Time (  Time . parse Time ( _ STR ) ) ; } else if ( i == partial Route . size ( ) ) { tmp Activity . set Type ( _ STR ) ; } else { tmp Activity . set Type ( _ STR ) ; tmp Activity . set Maximum Duration (  Time . parse Time ( _ STR ) ) ; } best = tmp ; best List = tmp List ; } } return best List ; }
public void write Short ( int value ) throws  IOException { check Write Primitive Types ( ) ; primitive Types . write Short ( value ) ; }
private boolean is Initialized ( ) { return pool Names != null && ! pool Names . is Empty ( ) ; }
public void on Register Click (  View view ) {  Intent register = new  Intent (  Intent .  ACTION_ VIEW ,  Uri . parse ( get String (  R . string . welcome_link_url ) ) ) ; set Result (  RESULT_ CANCELED ) ; start Activity ( register ) ; }
private void register Extra Valid Subject (  String subject ) { extra Valid Subjects . add ( subject ) ; restored Statements . add All ( unknown Subjects . remove All ( subject ) ) ; }
public static  String trim Line (  String line ) { int idx = line . index Of ( _ STR ) ; if ( idx != - _ NUM ) { line = line . substring ( _ NUM , idx ) ; } return line . trim ( ) ; }
public double distance2 ( double p1 , double p2 ) { return ( p1 - p2 ) * ( p1 - p2 ) ; }
public  Iterator <  T > iterator ( ) { return order List . iterator ( ) ; }
private void verify Domains Is Not In Use (  String Set domains ) { check For Active Tenants Using Domains ( domains ) ; check For Vdc Roles Using Domains ( domains ) ; check For Tenant Roles Using Domains ( domains ) ; check For User Groups Using Domains ( domains ) ; }
private  Hashtable <  IPoint ,  List <  ICircle > > filter (  Hashtable <  IPoint ,  ICircle [ ] > circle Intersections ) {  Hashtable <  IPoint ,  List <  ICircle > > real = new  Hashtable <  IPoint ,  List <  ICircle > > ( ) ; for (  IPoint pt : circle Intersections . key Set ( ) ) {  ICircle [ ] circs = circle Intersections . get ( pt ) ; for ( int i = _ NUM ; i < circs . length - _ NUM ; i ++ ) { for ( int j = i + _ NUM ; j < circs . length ; j ++ ) {  IPoint [ ] pts = intersects ( circs [ i ] , circs [ j ] ) ; if ( pts != null ) { for (  IPoint p : pts ) { report ( real , p , circs [ i ] , circs [ j ] ) ; } } } } } return real ; }
public void init Without JUnit For Fixture (  Class fixture ,  Method method ) { this . test Class = fixture ; this . test Method Name = method . get Name ( ) ; }
public long sigignore ( ) { return  Long . parse Long ( fields [ _ NUM ] ) ; }
protected  Java Type find Serialization Type (  Annotated a , boolean use Static Typing ,  Java Type declared Type ) {  Class < ? > ser Class = _annotation Introspector . find Serialization Type ( a ) ; if ( ser Class != null ) {  Class < ? > raw Declared = declared Type . get Raw Class ( ) ; if ( ser Class . is Assignable From ( raw Declared ) ) { declared Type = declared Type . widen By ( ser Class ) ; } else { if ( ! raw Declared . is Assignable From ( ser Class ) ) { throw new  Illegal Argument Exception ( _ STR + a . get Name ( ) + _ STR + ser Class . get Name ( ) + _ STR + raw Declared . get Name ( ) ) ; } declared Type = _config . construct Specialized Type ( declared Type , ser Class ) ; } use Static Typing = _ BOOL ; }  Java Type secondary =  Bean Serializer Factory . modify Secondary Types By Annotation ( _config , a , declared Type ) ; if ( secondary != declared Type ) { use Static Typing = _ BOOL ; declared Type = secondary ; } if ( ! use Static Typing ) {  Json Serialize .  Typing typing = _annotation Introspector . find Serialization Typing ( a ) ; if ( typing != null ) { use Static Typing = ( typing ==  Json Serialize .  Typing .  STATIC ) ; } } return use Static Typing ? declared Type : null ; }
private static void convert (  AScene scene ,  Input Stream in ,  Output Stream out ) throws  IOException ,  Def Exception ,  Parse Exception {  Index Unit iu =  Java Parser . parse ( in ) ; extract Scene ( iu , scene ) ; try (  Writer w = new  Buffered Writer ( new  Output Stream Writer ( out ) ) ) {  Index File Writer . write ( scene , w ) ; } }
public boolean bound Scroll ( ) { float cur Scroll = get Stack Scroll ( ) ; float new Scroll = get Bounded Stack Scroll ( cur Scroll ) ; if (  Float . compare ( new Scroll , cur Scroll ) != _ NUM ) { set Stack Scroll ( new Scroll ) ; return _ BOOL ; } return _ BOOL ; }
public static void load ( marytts . modules . synthesis .  Voice mary Voice ) throws  No Such Property Exception { if ( mary2freetts Voices == null ) mary2freetts Voices = new  Hash Map < marytts . modules . synthesis .  Voice , com . sun . speech . freetts .  Voice > ( ) ; if ( freetts2mary Voices == null ) freetts2mary Voices = new  Hash Map < com . sun . speech . freetts .  Voice , marytts . modules . synthesis .  Voice > ( ) ; if ( mary2freetts Voices . contains Key ( mary Voice ) ) return ; load ( mary Voice , create Free TTSVoice ( mary Voice ) ) ; }
public void append ( int key , double value ) { if ( m Size != _ NUM && key <= m Keys [ m Size - _ NUM ] ) { put ( key , value ) ; return ; } int pos = m Size ; if ( pos >= m Keys . length ) { int n =  Array Utils . ideal Int Array Size ( pos + _ NUM ) ; int [ ] nkeys = new int [ n ] ; double [ ] nvalues = new double [ n ] ;  System . arraycopy ( m Keys , _ NUM , nkeys , _ NUM , m Keys . length ) ;  System . arraycopy ( m Values , _ NUM , nvalues , _ NUM , m Values . length ) ; m Keys = nkeys ; m Values = nvalues ; } m Keys [ pos ] = key ; m Values [ pos ] = value ; m Size = pos + _ NUM ; }
public synchronized void add Incremental Classifier Listener (  Incremental Classifier Listener cl ) { m_incremental Classifier Listeners . add ( cl ) ; }
public float read R4 ( ) throws java . io .  IOException { return  Float . int Bits To Float ( ( int ) read DWORD ( ) ) ; }
public static boolean files Exist On Dest But Not Src (  Configuration conf ,  Path src ,  Path dest ,  Optional <  Path Filter > filter ) throws  IOException {  Set <  File Status > src File Statuses = get File Statuses Recursive ( conf , src , filter ) ;  Set <  File Status > dest File Statuses = get File Statuses Recursive ( conf , dest , filter ) ;  Map <  String ,  Long > src File Sizes = null ;  Map <  String ,  Long > dest File Sizes = null ; try { src File Sizes = get Rel Path To Sizes ( src , src File Statuses ) ; dest File Sizes = get Rel Path To Sizes ( dest , dest File Statuses ) ; } catch (  Argument Exception e ) { throw new  IOException ( _ STR , e ) ; } for (  String file : dest File Sizes . key Set ( ) ) { if ( ! src File Sizes . contains Key ( file ) ) {  LOG . warn (  String . format ( _ STR , file , dest , src ) ) ; return _ BOOL ; } } return _ BOOL ; }
protected void convert Order (  Sql Select select ,  Blackboard bb ,  Rel Collation collation ,  List <  Sql Node > order Expr List ,  Sql Node offset ,  Sql Node fetch ) { if ( select . get Order List ( ) == null || select . get Order List ( ) . get List ( ) . is Empty ( ) ) { assert collation . get Field Collations ( ) . is Empty ( ) ; if ( ( offset == null || ( (  Sql Literal ) offset ) . big Decimal Value ( ) . equals (  Big Decimal .  ZERO ) ) && fetch == null ) { return ; } } bb . set Root (  Logical Sort . create ( bb . root , collation , offset == null ? null : convert Expression ( offset ) , fetch == null ? null : convert Expression ( fetch ) ) , _ BOOL ) ; if ( order Expr List . size ( ) > _ NUM && ! bb . top ) { final  List <  Rex Node > exprs = new  Array List < > ( ) ; final  Rel Data Type row Type = bb . root . get Row Type ( ) ; final int field Count = row Type . get Field Count ( ) - order Expr List . size ( ) ; for ( int i = _ NUM ; i < field Count ; i ++ ) { exprs . add ( rex Builder . make Input Ref ( bb . root , i ) ) ; } bb . set Root (  Logical Project . create ( bb . root , exprs , row Type . get Field Names ( ) . sub List ( _ NUM , field Count ) ) , _ BOOL ) ; } }
public void tick Block (  Block Pos pos ) {  List <  Block Pos > valid Coords = new  Array List < > ( ) ; for ( int x Offset = -  TICK_ RANGE ; x Offset <=  TICK_ RANGE ; x Offset ++ ) { for ( int z Offset = -  TICK_ RANGE ; z Offset <=  TICK_ RANGE ; z Offset ++ ) { if ( x Offset == _ NUM && z Offset == _ NUM ) continue ; if ( is Valid Swap Position ( pos . add ( x Offset , _ NUM , z Offset ) ) ) valid Coords . add ( pos . add ( x Offset , _ NUM , z Offset ) ) ; } } if ( ! valid Coords . is Empty ( ) && ! world . is Remote ) {  Block Pos to Swap = valid Coords . get ( rand . next Int ( valid Coords . size ( ) ) ) ; world . set Block State ( to Swap , state To Set , _ NUM | _ NUM ) ; } }
private void configure Message Label (  JLabel label ) {  Color color = (  Color )  Default Lookup . get ( option Pane , this , _ STR ) ; if ( color != null ) { label . set Foreground ( color ) ; }  Font message Font = (  Font )  Default Lookup . get ( option Pane , this , _ STR ) ; if ( message Font != null ) { label . set Font ( message Font ) ; } }
default  Filterable <  T > remove All ( final  Stream < ? extends  T > stream ) { final  Set <  T > set = stream . collect (  Collectors . to Set ( ) ) ; return filter Not ( null ) ; }
public void draw Line (  List < mx Point > pts ,  Map <  String ,  Object > style ) {  Color pen Color = mx Utils . get Style Stroke Color ( style ,  Color .  BLACK ) ; float pen Width = mx Utils . get Style Stroke Width ( style , ( float ) _ NUM ) ; if ( pen Color != null && pen Width > _ NUM ) {  String shape = mx Utils . get String ( style , mx Constants .  STYLE_ SHAPE , _ STR ) ; if ( shape . equals ( mx Constants .  SHAPE_ ARROW ) ) { set Stroke ( pen Width , style ) ; mx Point p0 = pts . get ( _ NUM ) ; mx Point pe = pts . get ( pts . size ( ) - _ NUM ) ;  Rectangle bounds = new  Rectangle ( p0 . get Point ( ) ) ; bounds . add ( pe . get Point ( ) ) ;  Color fill Color = mx Utils . get Style Fill Color ( style ) ;  Paint fill Paint = get Fill Paint ( bounds , fill Color , style ) ; boolean shadow = mx Utils . is True ( style , mx Constants .  STYLE_ SHADOW , _ BOOL ) ; draw Arrow ( pts , fill Color , fill Paint , pen Color , shadow ) ; } else {  Object start Marker = style . get ( mx Constants .  STYLE_ STARTARROW ) ;  Object end Marker = style . get ( mx Constants .  STYLE_ ENDARROW ) ; float start Size = ( float ) ( mx Utils . get Float ( style , mx Constants .  STYLE_ STARTSIZE , mx Constants .  DEFAULT_ MARKERSIZE ) ) ; float end Size = ( float ) ( mx Utils . get Float ( style , mx Constants .  STYLE_ ENDSIZE , mx Constants .  DEFAULT_ MARKERSIZE ) ) ; boolean rounded = mx Utils . is True ( style , mx Constants .  STYLE_ ROUNDED , _ BOOL ) ; draw Connector ( pts , pen Width , pen Color , start Marker , start Size , end Marker , end Size , rounded , style ) ; } } }
private static  Metering Rectangle [ ] regions For Normalized Coord ( float nx , float ny , float fraction , final  Rect crop Region , int sensor Orientation ) { int min Crop Edge =  Math . min ( crop Region . width ( ) , crop Region . height ( ) ) ; int half Side Length = ( int ) ( _ NUM * fraction * min Crop Edge ) ;  Point F nsc =  Camera Util . normalized Sensor Coords For Normalized Display Coords ( nx , ny , sensor Orientation ) ; int x Center Sensor = ( int ) ( crop Region . left + nsc . x * crop Region . width ( ) ) ; int y Center Sensor = ( int ) ( crop Region . top + nsc . y * crop Region . height ( ) ) ;  Rect metering Region = new  Rect ( x Center Sensor - half Side Length , y Center Sensor - half Side Length , x Center Sensor + half Side Length , y Center Sensor + half Side Length ) ; metering Region . left =  Camera Util . clamp ( metering Region . left , crop Region . left , crop Region . right ) ; metering Region . top =  Camera Util . clamp ( metering Region . top , crop Region . top , crop Region . bottom ) ; metering Region . right =  Camera Util . clamp ( metering Region . right , crop Region . left , crop Region . right ) ; metering Region . bottom =  Camera Util . clamp ( metering Region . bottom , crop Region . top , crop Region . bottom ) ; return new  Metering Rectangle [ ] { new  Metering Rectangle ( metering Region ,  CAMERA2_ REGION_ WEIGHT ) } ; }
@  Override public void flush ( ) throws  IOException { flush Buffer ( ) ; _output Stream . flush ( ) ; }
public  Vector ( double comp [ ] ) throws  Negative Array Size Exception { int n = comp . length ; if ( n <= _ NUM ) throw new  Negative Array Size Exception ( _ STR ) ; components = new double [ n ] ;  System . arraycopy ( comp , _ NUM , components , _ NUM , n ) ; }
public long lon To Pixel ( double lon ) { return ( long ) ( ( lon + _ NUM ) / _ NUM *  Math . pow ( _ NUM , zoom ) * _ NUM ) ; }
public static boolean world File Values Appear Geographic (  AVList values ) { double x Location ; double y Location ; double x Pixel Size ; double y Pixel Size ;  Object o = values . get Value (  WORLD_ FILE_ X_ LOCATION ) ; if ( o != null && o instanceof  Double ) x Location = (  Double ) o ; else return _ BOOL ; o = values . get Value (  WORLD_ FILE_ Y_ LOCATION ) ; if ( o != null && o instanceof  Double ) y Location = (  Double ) o ; else return _ BOOL ; o = values . get Value (  WORLD_ FILE_ X_ PIXEL_ SIZE ) ; if ( o != null && o instanceof  Double ) x Pixel Size = (  Double ) o ; else return _ BOOL ; o = values . get Value (  WORLD_ FILE_ Y_ PIXEL_ SIZE ) ; if ( o != null && o instanceof  Double ) y Pixel Size = (  Double ) o ; else return _ BOOL ; return (  Angle . is Valid Longitude ( x Pixel Size ) &&  Angle . is Valid Latitude ( y Pixel Size ) &&  Angle . is Valid Longitude ( x Location ) &&  Angle . is Valid Latitude ( y Location ) ) ; }
public void store In Register ( int register Number ) throws  IOException { print ( _ STR , new  String [ ] {  Integer . to String ( register Number ) } ) ; }
public void remove (  Session ID session ID ) { remote Session Set . remove ( session ID ) ; }
public  Iterator <  Abstract Page > child Iterator ( final boolean dirty Nodes Only ) { if ( dirty Nodes Only ) { return new  Dirty Child Iterator ( this ) ; } else { return new  Child Iterator ( ) ; } }
public  HMACT64 ( byte [ ] key ) { super ( _ STR ) ; int length =  Math . min ( key . length ,  BLOCK_ LENGTH ) ; for ( int i = _ NUM ; i < length ; i ++ ) { ipad [ i ] = ( byte ) ( key [ i ] ^  IPAD ) ; opad [ i ] = ( byte ) ( key [ i ] ^  OPAD ) ; } for ( int i = length ; i <  BLOCK_ LENGTH ; i ++ ) { ipad [ i ] =  IPAD ; opad [ i ] =  OPAD ; } try { md5 =  Message Digest . get Instance ( _ STR ) ; } catch (  Exception ex ) { throw new  Illegal State Exception ( ex . get Message ( ) ) ; } engine Reset ( ) ; }
public boolean starts With (  String string ) { if ( string == null ) return _ BOOL ; int strlen = string . length ( ) ; if ( _length < strlen ) return _ BOOL ; char [ ] buffer = _buffer ; int offset = _offset ; while ( -- strlen >= _ NUM ) { if ( buffer [ offset + strlen ] != string . char At ( strlen ) ) return _ BOOL ; } return _ BOOL ; }
private void write Raw Bytes Internal ( final  Byte Buffer value ) throws  IOException { int length = value . remaining ( ) ; if ( limit - position >= length ) { value . get ( buffer , position , length ) ; position += length ; total Bytes Written += length ; } else { final int bytes Written = limit - position ; value . get ( buffer , position , bytes Written ) ; length -= bytes Written ; position = limit ; total Bytes Written += bytes Written ; refresh Buffer ( ) ; while ( length > limit ) { value . get ( buffer , _ NUM , limit ) ; output . write ( buffer , _ NUM , limit ) ; length -= limit ; total Bytes Written += limit ; } value . get ( buffer , _ NUM , length ) ; position = length ; total Bytes Written += length ; } }
public boolean is Src Class (  Soot Class clz ) { return src Classes . contains ( clz . get Name ( ) ) ; }
private void process LDIF (  Connection conn ,  String path ) throws  Upgrade Exception {  Change Record Reader reader = null ; try { if (  DEBUG . message Enabled ( ) ) {  DEBUG . message ( _ STR + path ) ; }  Map <  String ,  String > tags = new  Hash Map <  String ,  String > ( _ NUM ) ; tags . put ( _ STR , base DN ) ; tags . put ( _ STR , _ STR ) ;  String content =  AMSetup Servlet . read File ( path ) ;  String tag Swapped =  String Utils . tag Swap ( content , tags ) ; reader = new  LDIFChange Record Reader ( new  Byte Array Input Stream ( tag Swapped . get Bytes (  Charset . for Name ( _ STR ) ) ) ) ;  Change Record Writer writer = new  Connection Change Record Writer ( conn ) ; while ( reader . has Next ( ) ) { writer . write Change Record ( reader . read Change Record ( ) ) ; } } catch (  IOException ioe ) {  DEBUG . error ( _ STR + path , ioe ) ; throw new  Upgrade Exception ( ioe ) ; } finally {  IOUtils . close If Not Null ( reader ) ; } }
private void print Progress ( long row , long row From , long row Till ) { long rows Processed = row + chunk Size - row From ; if ( rows Processed > ( row Till - row From ) ) rows Processed = ( row Till - row From ) ; print (  String . format ( _ STR , ( int ) ( ( ( double ) ( rows Processed ) / ( double ) ( row Till - row From ) ) * _ NUM ) ) ) ; }
void post Remote Release Lock (  Object object Name ) throws  Interrupted Exception { if ( ! acquire Destroy Read Lock ( _ NUM ) ) { return ; } try { check Destroyed ( ) ; drain Permitted Requests ( ) ; grant Lock ( object Name ) ; } catch (  Lock Service Destroyed Exception e ) { } catch (  Lock Grantor Destroyed Exception e ) { } finally { release Destroy Read Lock ( ) ; } }
public final  Array List <  Position Record > load Positions ( final int session , final  Double min Lat , final  Double max Lat , final  Double min Lon , final  Double max Lon ) { final  Array List <  Position Record > positions = new  Array List < > ( ) ;  String selection =  Schema .  COL_ SESSION_ ID + _ STR ;  Cursor cursor = null ;  List <  String > selection Args = null ; if ( min Lat != null & max Lat != null && min Lon != null && max Lon != null ) { selection Args = new  Array List < > ( ) ; selection Args . add (  String . value Of ( session ) ) ; selection Args . add (  String . value Of ( min Lat ) ) ; selection Args . add (  String . value Of ( max Lat ) ) ; selection Args . add (  String . value Of ( min Lon ) ) ; selection Args . add (  String . value Of ( max Lon ) ) ; selection += _ STR +  Schema .  COL_ LATITUDE + _ STR +  Schema .  COL_ LATITUDE + _ STR +  Schema .  COL_ LONGITUDE + _ STR +  Schema .  COL_ LONGITUDE + _ STR ; cursor = content Resolver . query (  Content Provider .  CONTENT_ URI_ POSITION , null , selection , selection Args . to Array ( new  String [ _ NUM ] ) ,  Schema .  COL_ TIMESTAMP ) ; } else {  Log . v (  TAG , _ STR ) ; cursor = content Resolver . query (  Content Provider .  CONTENT_ URI_ POSITION , null , null , null ,  Schema .  COL_ TIMESTAMP ) ; } while ( cursor . move To Next ( ) ) { positions . add ( position From Cursor ( cursor ) ) ; } cursor . close ( ) ; return positions ; }
public static  Check Box create Toggle (  String text ,  Image icon ) {  Check Box cb = new  Check Box ( text , icon ) ; cb . set Toggle ( _ BOOL ) ; return cb ; }
public long add Completed Batch (  Request Batch request Batch ) { long completed Batch Id = insert Batch As Completed ( request Batch ) ; for (  Request request : request Batch . get Requests ( ) ) { request . set Batch Id ( completed Batch Id ) ;  File file = new  File ( request . get Destination Path ( ) ) ; long length = file . exists ( ) ? file . length ( ) : _ NUM ; insert Request As Completed Download ( request . get Destination Path ( ) , length , request ) ; } return completed Batch Id ; }
public static  Default Job Definition retryable Fixed Delay Job Definition ( final  String job Type , final  String job Name , final  String description , final  Duration fixed Delay , final int restarts , final int retries , final  Optional <  Duration > retry Delay , final  Optional <  Duration > max Age ) { return new  Default Job Definition ( job Type , job Name , description , max Age ,  Optional . of ( fixed Delay ) ,  Optional . empty ( ) , restarts , retries , retry Delay ) ; }
public static _ Fields find By Thrift Id ( int field Id ) { switch ( field Id ) { case _ NUM : return  MESSAGE ; default : return null ; } }
public static void put Long ( long addr , long val ) { if (  UNALIGNED )  UNSAFE . put Long ( addr , val ) ; else put Long By Byte ( addr , val ,  BIG_ ENDIAN ) ; }
public static  File create Minimal Split (  String input Folder , int num Folds , int num Available JCas , boolean is Sequence ) throws  Exception {  File output Folder = new  File ( input Folder , _ STR ) ; int split Num = ( int )  Math . ceil ( num Folds / ( double ) num Available JCas ) ;  Collection Reader Description create Reader =  Collection Reader Factory . create Reader Description (  Binary Cas Reader . class ,  Binary Cas Reader .  PARAM_ SOURCE_ LOCATION , input Folder ,  Binary Cas Reader .  PARAM_ PATTERNS , _ STR ) ;  Analysis Engine Description multiplier =  Analysis Engine Factory . create Engine Description (  Fold Classification Unit Cas Multiplier . class ,  Fold Classification Unit Cas Multiplier .  PARAM_ REQUESTED_ SPLITS , split Num ,  Fold Classification Unit Cas Multiplier .  PARAM_ USE_ SEQUENCES , is Sequence ) ;  Analysis Engine Description xmi Writer =  Analysis Engine Factory . create Engine Description (  Binary Cas Writer . class ,  Binary Cas Writer .  PARAM_ TARGET_ LOCATION , output Folder . get Absolute Path ( ) ,  Binary Cas Writer .  PARAM_ FORMAT , _ STR ) ;  Analysis Engine Description both =  Analysis Engine Factory . create Engine Description ( multiplier , xmi Writer ) ;  Simple Pipeline . run Pipeline ( create Reader , both ) ; is Number Of Cas Created Larger Equal Num Folds ( output Folder , num Folds ) ; return output Folder ; }
public org . w3c . dom .  Element sign XML ( org . w3c . dom .  Document doc , java . lang .  String cert Alias ) throws  XMLSignature Exception { return sign XML ( doc , cert Alias , null ) ; }
public boolean display Popup ( ) { if ( m_popup Class == null ) return _ BOOL ; try {  Window win =  Swing Utilities . get Window Ancestor ( this ) ;  CField Popup popup = null ; if ( win instanceof  Dialog ) {  Constructor < ? > constructor = m_popup Class . get Constructor ( new  Class < ? > [ ] {  Dialog . class ,  String . class ,  Boolean . class } ) ; popup = (  CField Popup ) constructor . new Instance ( new  Object [ ] { (  Dialog ) win , m_title , new  Boolean ( _ BOOL ) } ) ; } else if ( win instanceof  Frame ) {  Constructor < ? > constructor = m_popup Class . get Constructor ( new  Class [ ] {  Frame . class ,  String . class ,  Boolean . class } ) ; popup = (  CField Popup ) constructor . new Instance ( new  Object [ ] { (  Frame ) win , m_title , new  Boolean ( _ BOOL ) } ) ; } if ( popup == null ) return _ BOOL ; popup . set Value ( m_editor . get Item ( ) ) ; popup . set Format ( m_editor . get Format ( ) ) ; popup . show ( ) ; m_editor . set Item ( popup . get Value ( ) ) ; popup = null ; } catch (  Exception e ) { notify User ( e ) ; } return _ BOOL ; }
public  Abstract Sdf Writer ( final  Preread Type preread Type , final boolean has Quality , boolean has Names , boolean compressed , final  Sequence Type type ) { m Preread Type = preread Type ; m Preread Arm =  Preread Arm .  UNKNOWN ; m Sdf Id = new  Sdf Id ( ) ; m Name Handler = new  Sequence Name Handler ( ) ; m Sequence Type = type ; m First Valid = m Sequence Type . first Valid ( ) ; m Residue Counts = new long [ m Sequence Type . number Known Codes ( ) + m Sequence Type . first Valid ( ) ] ; m NHistogram = new long [  MAX_ HISTOGRAM ] ; m Pos Histogram = new long [  MAX_ HISTOGRAM ] ; m QSAverage Per Pos = new double [  MAX_ HISTOGRAM ] ; m Position Counts = new long [  MAX_ HISTOGRAM ] ; m Global QSAverage = _ NUM ; m Data Hash Function = new  Preread Hash Function ( ) ; m Quality Hash Function = new  Preread Hash Function ( ) ; m Name Hash Function = new  Preread Hash Function ( ) ; m Name Suffix Hash Function = new  Preread Hash Function ( ) ; m Has Quality = has Quality ; m Has Names = has Names ; m Compressed = compressed ; m Seq Data Checksum = new  CRC32 ( ) ; m Qual Data Checksum = new  CRC32 ( ) ; }
Firing Plan guess Best Firing Plan Under Heat (  Entity shooter , @  Nullable  Entity State shooter State ,  Targetable target , @  Nullable  Entity State target State , int max Heat ,  IGame game ) { if ( max Heat < _ NUM ) { max Heat = _ NUM ; }  Firing Plan alpha Strike = guess Full Firing Plan ( shooter , shooter State , target , target State , game ) ; if ( alpha Strike . get Heat ( ) <= max Heat && ! ( shooter instanceof  Infantry ) && ! ( shooter instanceof  Battle Armor ) ) { return alpha Strike ; }  Firing Plan heat Plans [ ] = calc Firing Plans Under Heat ( shooter , alpha Strike ) ;  Arrays . sort ( heat Plans ) ; if ( heat Plans . length > _ NUM ) { return heat Plans [ _ NUM ] ; } else { return new  Firing Plan ( target ) ; } }
public static  Volume Group Rest Rep map (  Volume Group from ) { if ( from == null ) { return null ; }  Volume Group Rest Rep rep = new  Volume Group Rest Rep ( ) ; map Data Object Fields ( from , rep ) ; rep . set Description ( from . get Description ( ) ) ; rep . set Roles ( from . get Roles ( ) ) ; rep . set Parent ( to Related Resource (  Resource Type Enum .  VOLUME_ GROUP , from . get Parent ( ) ) ) ; rep . set Migration Group By ( from . get Migration Group By ( ) ) ; rep . set Migration Type ( from . get Migration Type ( ) ) ; return rep ; }
public void add Action Listener (  Action Listener new Listener ) { m_listeners . add ( new Listener ) ; }
@  Deprecated public  Shapeless Recipe add Ingredient ( int count ,  Material ingredient , int rawdata ) {  Validate . is True ( ingredients . size ( ) + count <= _ NUM , _ STR ) ; if ( rawdata == - _ NUM ) { rawdata =  Short .  MAX_ VALUE ; } while ( count -- > _ NUM ) { ingredients . add ( new  Item Stack ( ingredient , _ NUM , ( short ) rawdata ) ) ; } return this ; }
public  String order ( ) { return m Order By . length ( ) > _ NUM ? m Order By . to String ( ) : null ; }
public static byte [ ] encoding To Bytes ( final  String str , final  String encoding ) { if ( str == null ) { return null ; } try { return str . get Bytes ( encoding ) ; } catch ( final  Unsupported Encoding Exception e ) { throw new  Error ( encoding + _ STR + e ) ; } }
public static boolean looks Like ABGRepeat (  String val ) { return  BACKGROUND_ REPEATS . index Of ( val ) >= _ NUM ; }
public void before ( ) throws  Throwable { if (  Build .  VERSION .  SDK_ INT >=  Build .  VERSION_ CODES .  M ) {  Process Builder process Builder = new  Process Builder ( ) ; process Builder . command ( _ STR , _ STR ) ; process Builder . redirect Error Stream ( ) ;  Process process = process Builder . start ( ) ; process . wait For ( ) ; if ( process . exit Value ( ) != _ NUM ) {  Log . e (  LOG_ TAG , _ STR + process . exit Value ( ) ) ; } } }
public void add Meta ( char meta ,  String replacement ) { meta Character Set . set ( meta ) ; replacement Map . put ( new  String ( new char [ ] { meta } ) , replacement ) ; }
private  Matches lookup Do (  Template tmpl , int max Matches ) { if ( max Matches < _ NUM ) throw new  Illegal Argument Exception ( _ STR ) ; int total Matches = _ NUM ;  Array List matches = null ;  Item Iter iter = matching Items ( tmpl ) ; if ( max Matches > _ NUM || iter . dups Possible ) matches = new  Array List ( ) ; if ( iter . dups Possible ) { while ( iter . has Next ( ) ) {  Item item = iter . next ( ) ; if ( ! matches . contains ( item ) ) matches . add ( item ) ; } total Matches = matches . size ( ) ; if ( max Matches > _ NUM ) { for ( int i = matches . size ( ) ; -- i >= max Matches ; ) matches . remove ( i ) ; for ( int i = matches . size ( ) ; -- i >= _ NUM ; ) { matches . set ( i , copy Item ( (  Item ) matches . get ( i ) ) ) ; } } else { matches = null ; } } else { while ( iter . has Next ( ) ) {  Item item = iter . next ( ) ; total Matches ++ ; if ( -- max Matches >= _ NUM ) matches . add ( copy Item ( item ) ) ; } } return new  Matches ( matches , total Matches ) ; }
public static  List <  History > find History By Job (  Entity Manager em ,  JPAEntity job ,  Big Integer limit ) { require Argument ( em != null , _ STR ) ; require Argument ( job != null , _ STR ) ;  Typed Query <  History > query = em . create Named Query ( _ STR ,  History . class ) ; if ( limit != null ) { query . set Max Results ( limit . int Value ( ) ) ; } try { query . set Parameter ( _ STR , job ) ; return query . get Result List ( ) ; } catch (  No Result Exception ex ) { return new  Array List <  History > ( _ NUM ) ; } }
protected  Character is WFXMLChar (  String chardata ) {  Character ref Invalid Char ; if ( chardata == null || ( chardata . length ( ) == _ NUM ) ) { return null ; } char [ ] dataarray = chardata . to Char Array ( ) ; int datalength = dataarray . length ; if ( f Is XMLVersion11 ) { int i = _ NUM ; while ( i < datalength ) { if (  XML11 Char . is XML11 Invalid ( dataarray [ i ++ ] ) ) { char ch = dataarray [ i - _ NUM ] ; if (  XMLChar . is High Surrogate ( ch ) && i < datalength ) { char ch2 = dataarray [ i ++ ] ; if (  XMLChar . is Low Surrogate ( ch2 ) &&  XMLChar . is Supplemental (  XMLChar . supplemental ( ch , ch2 ) ) ) { continue ; } } ref Invalid Char = new  Character ( ch ) ; return ref Invalid Char ; } } } else { int i = _ NUM ; while ( i < datalength ) { if (  XMLChar . is Invalid ( dataarray [ i ++ ] ) ) { char ch = dataarray [ i - _ NUM ] ; if (  XMLChar . is High Surrogate ( ch ) && i < datalength ) { char ch2 = dataarray [ i ++ ] ; if (  XMLChar . is Low Surrogate ( ch2 ) &&  XMLChar . is Supplemental (  XMLChar . supplemental ( ch , ch2 ) ) ) { continue ; } } ref Invalid Char = new  Character ( ch ) ; return ref Invalid Char ; } } } return null ; }
private void update Pending Nodes ( final int new Landmark Index , final  Router Priority Queue <  Node > pending Nodes ) { final  List <  Double > new Est Rem Trav Costs = new  Array List < > ( ) ; final  List <  Node > nodes To Be Updated = new  Array List < > ( ) ; final  Internal Landmark Data landmark Data = new  Internal Landmark Data ( ) ; for (  Node node : pending Nodes ) { final  AStar Node Data role = get Data ( node ) ; final  Pre Process Landmarks .  Landmarks Data pp Role = preprocess . get Node Data ( node ) ; landmark Data . set Delegate ( pp Role ) ; final double new Est Rem Trav Cost = estimate Remaining Travel Cost ( landmark Data , new Landmark Index ) ; if ( new Est Rem Trav Cost > role . get Expected Remaining Cost ( ) ) { nodes To Be Updated . add ( node ) ; new Est Rem Trav Costs . add ( new Est Rem Trav Cost ) ; } } for (  Node node : nodes To Be Updated ) { pending Nodes . remove ( node ) ; } for ( int i = _ NUM ; i < nodes To Be Updated . size ( ) ; i ++ ) { final  Node node = nodes To Be Updated . get ( i ) ; final  AStar Node Data data = get Data ( node ) ; data . set Expected Remaining Cost ( new Est Rem Trav Costs . get ( i ) ) ; pending Nodes . add ( node , get Priority ( data ) ) ; } }
@  Override public  String to String ( ) {  String Buffer buff = new  String Buffer ( ) ; if ( m_correlations == null ) { buff . append ( _ STR ) ; } else { buff . append ( _ STR ) ; if ( m_detailed Output && m_detailed Output Buff . length ( ) > _ NUM ) { buff . append ( _ STR ) ; buff . append ( m_detailed Output Buff ) ; } } return buff . to String ( ) ; }
private void draw Overflow Indicator ( final  Graphics g , int max X ) { int width = _ NUM ; int height = _ NUM ; int x Offset = _ NUM ; int step Size = width / _ NUM ; int dot Size = _ NUM ; int x = max X - width - x Offset ; int y = button . get Size ( ) . height - height ; g . set Color (  LIGHTER_ GRAY ) ; g . fill Rect ( x , y , width , width ) ; g . set Color (  Color .  GRAY ) ; g . draw Round Rect ( x , y , width , width , _ NUM , _ NUM ) ; g . set Color (  Color .  BLACK ) ; g . fill Oval ( x + step Size , y + _ NUM , dot Size , dot Size ) ; g . fill Oval ( x + step Size * _ NUM , y + _ NUM , dot Size , dot Size ) ; g . fill Oval ( x + step Size * _ NUM , y + _ NUM , dot Size , dot Size ) ; g . dispose ( ) ; }
public void write Line ( long time , float [ ] column ) {  String str =  Long . to String ( time ) ; for ( int i = _ NUM ; i < column . length ; ++ i ) { str += _ STR + column [ i ] ; } writer . println ( str ) ; }
public static boolean is PEM (  Input Stream is ) { try {  String start PEM = _ STR ; int header Length = _ NUM ; byte [ ] preamble = new byte [ header Length ] ; if ( is . read ( preamble , _ NUM , header Length ) > _ NUM ) {  String start Array = new  String ( preamble ) ; return start Array . starts With ( start PEM ) ; } return _ BOOL ; } catch (  Exception e ) { throw new  DSSException ( _ STR ) ; } }
public  Close Listener (  Object resource ) { _resource = resource ; }
@  Override public  Index Request routing (  String routing ) { if ( routing != null && routing . length ( ) == _ NUM ) { this . routing = null ; } else { this . routing = routing ; } return this ; }
public byte [ ] receive ( ) throws  Network Exception { try { packet . set Length (  Datagram Connection .  DEFAULT_ DATAGRAM_ SIZE ) ; connection . receive ( packet ) ; int packet Length = packet . get Length ( ) ; byte [ ] data = new byte [ packet Length ] ;  System . arraycopy ( packet . get Data ( ) , _ NUM , data , _ NUM , packet Length ) ; return data ; } catch (  IOException e ) { throw new  Network Exception ( _ STR , e ) ; } }
@  Override protected void force Delete Attribute At ( int position ) { double [ ] new Values = new double [ m_ Att Values . length - _ NUM ] ;  System . arraycopy ( m_ Att Values , _ NUM , new Values , _ NUM , position ) ; if ( position < m_ Att Values . length - _ NUM ) {  System . arraycopy ( m_ Att Values , position + _ NUM , new Values , position , m_ Att Values . length - ( position + _ NUM ) ) ; } m_ Att Values = new Values ; }
protected byte [ ] engine Wrap (  Key key ) throws  Illegal Block Size Exception ,  Invalid Key Exception { throw new  Unsupported Operation Exception ( ) ; }
@  Deprecated public  Java Plugin Loader (  Server instance ) {  Validate . not Null ( instance , _ STR ) ; server = instance ; }
public void add Separator ( ) { if ( log . is Loggable (  Platform Logger .  Level .  FINER ) ) { log . finer ( _ STR ) ; } }
private static  Class < ? > load Class (  URL [ ] urls ,  String name ) throws  Class Not Found Exception {  Class Loader parent = get RMIContext Class Loader ( ) ; if ( loader Log . is Loggable (  Log .  VERBOSE ) ) { loader Log . log (  Log .  VERBOSE , _ STR + parent + _ STR ) ; }  Security Manager sm =  System . get Security Manager ( ) ; if ( sm == null ) { try {  Class < ? > c =  Class . for Name ( name , _ BOOL , parent ) ; if ( loader Log . is Loggable (  Log .  VERBOSE ) ) { loader Log . log (  Log .  VERBOSE , _ STR + name + _ STR + _ STR + _ STR + _ STR + c . get Class Loader ( ) ) ; } return c ; } catch (  Class Not Found Exception e ) { if ( loader Log . is Loggable (  Log .  BRIEF ) ) { loader Log . log (  Log .  BRIEF , _ STR + name + _ STR + _ STR + _ STR , e ) ; } throw new  Class Not Found Exception ( e . get Message ( ) + _ STR , e . get Exception ( ) ) ; } }  Loader loader = lookup Loader ( urls , parent ) ; try { if ( loader != null ) { loader . check Permissions ( ) ; } } catch (  Security Exception e ) { try {  Class < ? > c = load Class For Name ( name , _ BOOL , parent ) ; if ( loader Log . is Loggable (  Log .  VERBOSE ) ) { loader Log . log (  Log .  VERBOSE , _ STR + name + _ STR + _ STR + _ STR + _ STR + c . get Class Loader ( ) ) ; } return c ; } catch (  Class Not Found Exception unimportant ) { if ( loader Log . is Loggable (  Log .  BRIEF ) ) { loader Log . log (  Log .  BRIEF , _ STR + name + _ STR + _ STR + _ STR , e ) ; } throw new  Class Not Found Exception ( _ STR , e ) ; } } try {  Class < ? > c = load Class For Name ( name , _ BOOL , loader ) ; if ( loader Log . is Loggable (  Log .  VERBOSE ) ) { loader Log . log (  Log .  VERBOSE , _ STR + name + _ STR + _ STR + _ STR + c . get Class Loader ( ) ) ; } return c ; } catch (  Class Not Found Exception e ) { if ( loader Log . is Loggable (  Log .  BRIEF ) ) { loader Log . log (  Log .  BRIEF , _ STR + name + _ STR , e ) ; } throw e ; } }
public static final  List <  INavi Raw Module > load Raw Modules ( final  Abstract SQLProvider provider ) throws  Couldnt Load Data Exception {  Preconditions . check Not Null ( provider , _ STR ) ; final  CConnection connection = provider . get Connection ( ) ; final  List <  INavi Raw Module > modules = new  Array List <  INavi Raw Module > ( ) ; if ( !  Postgre SQLHelpers . has Table ( connection ,  CTable Names .  RAW_ MODULES_ TABLE ) ) { return modules ; } final  String query = _ STR +  CTable Names .  RAW_ MODULES_ TABLE + _ STR ; try (  Result Set result Set = connection . execute Query ( query , _ BOOL ) ) { while ( result Set . next ( ) ) { final int raw Module Id = result Set . get Int ( _ STR ) ; final  String name =  Postgre SQLHelpers . read String ( result Set , _ STR ) ; final boolean is Complete =  Postgre SQLDatabase Functions . check Raw Modules Tables ( provider . get Connection ( ) ,  Postgre SQLHelpers . get Database Name ( provider . get Connection ( ) ) , raw Module Id ) ; final int function Count = is Complete ?  Postgre SQLDatabase Functions . get Raw Module Function Count ( connection , raw Module Id ) : _ NUM ; final  CRaw Module module = new  CRaw Module ( raw Module Id , name , function Count , is Complete , provider ) ; modules . add ( module ) ; } } catch ( final  SQLException e ) { throw new  Couldnt Load Data Exception ( e ) ; } return modules ; }
void write (  Image Output Stream ios ) throws  IOException { length = _ NUM + data . length ; write Tag ( ios ) ; ios . write ( data ) ; }
private static  List <  Register Description > parse Register Information ( final  Node node ) throws  Message Parser Exception { final  List <  Register Description > registers = new  Array List < > ( ) ; final  Node List nodes = node . get Child Nodes ( ) ; for ( int i = _ NUM ; i < nodes . get Length ( ) ; ++ i ) { final  Node child = nodes . item ( i ) ; final  String register Name = get Attribute ( child , _ STR ) ; final  String register Size = get Attribute ( child , _ STR ) ; final  String register Editable = get Attribute ( child , _ STR ) ; registers . add ( new  Register Description ( register Name ,  Integer . value Of ( register Size ) ,  Boolean . value Of ( register Editable ) ) ) ; } return registers ; }
public  Named Thread Factory (  String name Prefix ) { this . name Prefix =  Objects . require Non Null ( name Prefix ) ; group = get Thread Group ( ) ; daemon = _ BOOL ; }
public void test_metric_cpu_num_uint16 ( ) { final  IGanglia Metadata Message decl = new  Ganglia Metadata Message ( _ STR , _ STR , _ BOOL ,  Ganglia Message Type Enum .  UINT16 , _ STR , _ STR ,  Ganglia Slope Enum . zero , _ NUM , _ NUM ,  Abstract Metrics . get Map (  IGanglia Attributes .  GROUP_ CPU , _ STR , _ STR ) ) ; assert Encode Decode ( null , decl ) ; final  IGanglia Metric Message expected = new  Ganglia Metric Message (  Ganglia Message Type Enum .  UINT16 , _ STR , _ STR , _ BOOL , _ STR ,  Integer . value Of ( _ NUM ) ) ; final byte [ ] actual Data = assert Encode Decode ( decl , expected ) ; final byte [ ] expected Data = new byte [ ] { _ NUM , _ NUM , _ NUM , - _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM , _ NUM } ; if ( !  Arrays . equals ( expected Data , actual Data ) ) { fail ( _ STR +  Arrays . to String ( expected Data ) + _ STR +  Arrays . to String ( actual Data ) ) ; } }
public int add Column (  Object new Col , int length ) throws  Fits Exception { if ( this . n Fields > _ NUM &&  Array . get Length ( new Col ) != this . n Rows ) { throw new  Fits Exception ( _ STR ) ; } if ( this . n Fields == _ NUM ) { this . n Rows =  Array . get Length ( new Col ) ; }  Object [ ] new Data = new  Object [ this . n Fields + _ NUM ] ; int [ ] new Offsets = new int [ this . n Fields + _ NUM ] ; int [ ] new Lengths = new int [ this . n Fields + _ NUM ] ;  Class < ? > [ ] new Types = new  Class [ this . n Fields + _ NUM ] ;  String [ ] new Nulls = new  String [ this . n Fields + _ NUM ] ;  System . arraycopy ( this . data , _ NUM , new Data , _ NUM , this . n Fields ) ;  System . arraycopy ( this . offsets , _ NUM , new Offsets , _ NUM , this . n Fields ) ;  System . arraycopy ( this . lengths , _ NUM , new Lengths , _ NUM , this . n Fields ) ;  System . arraycopy ( this . types , _ NUM , new Types , _ NUM , this . n Fields ) ;  System . arraycopy ( this . nulls , _ NUM , new Nulls , _ NUM , this . n Fields ) ; this . data = new Data ; this . offsets = new Offsets ; this . lengths = new Lengths ; this . types = new Types ; this . nulls = new Nulls ; new Data [ this . n Fields ] = new Col ; this . offsets [ this . n Fields ] = this . row Len + _ NUM ; this . lengths [ this . n Fields ] = length ; this . types [ this . n Fields ] =  Array Funcs . get Base Class ( new Col ) ; this . row Len += length + _ NUM ; if ( this . is Null != null ) { boolean [ ] new Is Null = new boolean [ this . n Rows * ( this . n Fields + _ NUM ) ] ; int add = _ NUM ; for ( int i = _ NUM ; i < this . is Null . length ; i += _ NUM ) { if ( i % this . n Fields == _ NUM ) { add += _ NUM ; } if ( this . is Null [ i ] ) { new Is Null [ i + add ] = _ BOOL ; } } this . is Null = new Is Null ; } this . n Fields += _ NUM ; this . buffer = null ; return this . n Fields ; }
Deque <  Block > schedule (  Block entry ) {  Deque <  Block > code = dfs ( entry ) ;  Deque <  Block > scheduled = new  Array Deque <  Block > ( ) ;  Set Map <  Block ,  Edge > pred = preds ( code ) ;  Map <  Block ,  Block > idom = idoms ( code , pred ) ;  Edge Map <  Block > loops = find Loops ( code , idom , pred ) ; if ( ! loops . is Empty ( ) ) verbose Status ( _ STR + loops ) ; for (  Block b : code ) { if ( ! scheduled . contains ( b ) ) scheduled . add ( b ) ; if ( loops . contains Key ( b ) ) schedule_loop ( b , loops , scheduled ) ; }  Deque <  Block > branch_analysis = new  Array Deque <  Block > ( ) ; branch_analysis . add All ( scheduled ) ;  Set <  Block > already_seen = new  Hash Set <  Block > ( ) ; while ( branch_analysis . size ( ) > _ NUM ) {  Block b = branch_analysis . remove First ( ) ;  Expr last = b . last ( ) ;  Block next = branch_analysis . peek First ( ) ; if ( is Branch ( last ) && last . succ [ _ NUM ] . to != next && last . succ [ _ NUM ] . to == next ) invert ( last ) ; already_seen . add ( b ) ; b . is_backwards_branch_target = _ BOOL ; for (  Edge s : b . succ ( ) ) { s . to . is_backwards_branch_target |= s . is_backwards_branch = already_seen . contains ( s . to ) ; } } if ( verbose_mode ) for (  Block b : code ) if ( b . is_backwards_branch_target ) verbose Status ( _ STR + b ) ; return scheduled ; }
public void add Transaction (  SIPServer Transaction server Transaction ) throws  IOException { if ( logger . is Logging Enabled (  Log Writer .  TRACE_ DEBUG ) ) logger . log Debug ( _ STR + server Transaction ) ; server Transaction . map ( ) ; add Transaction Hash ( server Transaction ) ; }
private void delay Retry ( int multiplier ) { debug ( _ STR ) ; try {  Thread . sleep ( _ NUM * multiplier ) ; } catch (  Interrupted Exception e ) { warn ( e , _ STR ) ; } }
public void test Split And Join Semicolon Nested In Pipe Properties ( ) {  Properties outer =  Property Utils . split Properties On Pipe (  ONE_ THEN_ TWO_ OUTER_ A ) ; assert Equals (  ONE_ SEMI_ TWO , outer . get Property ( _ STR ) ) ; assert Equals ( _ NUM , outer . size ( ) ) ; try { assert Equals (  ONE_ THEN_ TWO_ OUTER_ A ,  Property Utils . join On Pipe (  Property Utils . to Map ( outer ) ) ) ; return ; } catch (  Comparison Failure deviation1 ) { } try { assert Equals (  TWO_ THEN_ ONE_ OUTER_ A ,  Property Utils . join On Pipe (  Property Utils . to Map ( outer ) ) ) ; return ; } catch (  Comparison Failure deviation2 ) { } try { assert Equals (  ONE_ THEN_ TWO_ OUTER_ B ,  Property Utils . join On Pipe (  Property Utils . to Map ( outer ) ) ) ; return ; } catch (  Comparison Failure deviation3 ) { } try { assert Equals (  TWO_ THEN_ ONE_ OUTER_ B ,  Property Utils . join On Pipe (  Property Utils . to Map ( outer ) ) ) ; return ; } catch (  Comparison Failure deviation4 ) { } assert Equals (  TWO_ THEN_ ONE_ OUTER_ A ,  Property Utils . join On Pipe (  Property Utils . to Map ( outer ) ) ) ; }
public void test Int Boolean Map ( ) throws  Exception {  Object Mapper mapper = new  Object Mapper ( ) ;  String  JSON = _ STR ;  Map <  String ,  Integer > result = mapper . read Value (  JSON , new  Type Reference <  Hash Map <  Integer ,  Boolean > > ( ) { } ) ; assert Not Null ( result ) ; assert Equals (  Hash Map . class , result . get Class ( ) ) ; assert Equals ( _ NUM , result . size ( ) ) ; assert Equals (  Boolean .  TRUE , result . get (  Integer . value Of ( _ NUM ) ) ) ; assert Equals (  Boolean .  FALSE , result . get (  Integer . value Of ( - _ NUM ) ) ) ; assert Null ( result . get ( _ STR ) ) ; assert Null ( result . get ( _ NUM ) ) ; }
protected  Byte Array Output Stream parse Bytes (  Byte Array Output Stream bos ) throws  IOException { int ch ; for ( ch = skip Whitespace ( ) ; ch >= _ NUM && ch != _ STR ; ch = skip Whitespace ( ) ) { int b1 = ch ; int b2 = read ( ) ; int b3 = read ( ) ; int b4 = read ( ) ; if ( b4 != _ STR ) { int chunk = ( ( base64 Decode [ b1 ] << _ NUM ) + ( base64 Decode [ b2 ] << _ NUM ) + ( base64 Decode [ b3 ] << _ NUM ) + ( base64 Decode [ b4 ] ) ) ; bos . write ( chunk > > _ NUM ) ; bos . write ( chunk > > _ NUM ) ; bos . write ( chunk ) ; } else if ( b3 != _ STR ) { int chunk = ( ( base64 Decode [ b1 ] << _ NUM ) + ( base64 Decode [ b2 ] << _ NUM ) + ( base64 Decode [ b3 ] > > _ NUM ) ) ; bos . write ( chunk > > _ NUM ) ; bos . write ( chunk ) ; } else { int chunk = ( ( base64 Decode [ b1 ] << _ NUM ) + ( base64 Decode [ b2 ] > > _ NUM ) ) ; bos . write ( chunk ) ; } } if ( ch == _ STR ) _peek = ch ; return bos ; }
public void reset ( ) { if ( m Download Bandwidth != null ) { m Download Bandwidth . reset ( ) ; } m Current Bandwidth Connection Quality . set (  Connection Quality .  UNKNOWN ) ; }
public void test Merge Security Role Into Empty Document ( ) throws  Exception {  String src Xml = _ STR ;  Web Xml src Web Xml =  Web Xml Io . parse Web Xml ( new  Byte Array Input Stream ( src Xml . get Bytes ( _ STR ) ) , null ) ;  String merge Xml = _ STR + _ STR + _ STR + _ STR + _ STR ;  Web Xml merge Web Xml =  Web Xml Io . parse Web Xml ( new  Byte Array Input Stream ( merge Xml . get Bytes ( _ STR ) ) , null ) ;  Web Xml Merger merger = new  Web Xml Merger ( src Web Xml ) ; merger . merge ( merge Web Xml ) ;  List <  String > security Role Names =  Web Xml Utils . get Security Role Names ( src Web Xml ) ; assert Equals ( _ NUM , security Role Names . size ( ) ) ; assert Equals ( _ STR , security Role Names . get ( _ NUM ) ) ; }
private  Diff Part decode Full Revision ( final int block Size_ L ) throws  Unsupported Encoding Exception ,  Decoding Exception { if ( block Size_ L < _ NUM ) { throw new  Decoding Exception ( _ STR + block Size_ L ) ; } int l = r . read ( block Size_ L ) ;  Byte Array Output Stream output = new  Byte Array Output Stream ( ) ; for ( int i = _ NUM ; i < l ; i ++ ) { output . write ( r . read Byte ( ) ) ; }  Diff Part part = new  Diff Part (  Diff Action .  FULL_ REVISION_ UNCOMPRESSED ) ; part . set Text ( output . to String (  WIKIPEDIA_ ENCODING ) ) ; return part ; }
private synchronized static void remove Child Character Data (  Node node , boolean deep ) {  Node List list = node . get Child Nodes ( ) ; for ( int i = list . get Length ( ) ; i >= _ NUM ; i -- ) {  Node n = list . item ( i ) ; if ( n == null ) continue ; if ( n instanceof  Character Data ) node . remove Child (  XMLCaster . to Raw Node ( n ) ) ; else if ( deep ) remove Child Character Data ( n , deep ) ; } }
private void load Corpus (  String source ,  String target ,  String align ) throws  IOException { logger . info ( _ STR ) ;  Time Keeper timer =  Timing Utils . start ( ) ; int num Source Positions = _ NUM ; int num Target Positions = _ NUM ; num Sentences = _ NUM ;  Parallel Corpus corpus = new  Parallel Corpus ( _ NUM ) ; try (  Line Number Reader f Reader =  IOTools . get Reader From File ( source ) ) {  Line Number Reader e Reader =  IOTools . get Reader From File ( target ) ;  Line Number Reader a Reader =  IOTools . get Reader From File ( align ) ; for (  String f Line ; ( f Line = f Reader . read Line ( ) ) != null ; ) {  String e Line = e Reader . read Line ( ) ;  String a Line = a Reader . read Line ( ) ;  Aligned Sentence example = corpus . get Sentence ( f Line , e Line , a Line ) ; if ( example != null ) { num Source Positions += example . source Length ( ) ; num Target Positions += example . target Length ( ) ; ++ num Sentences ; } } } final int initial Vocabulary Size = corpus . get Vocabulary ( ) . size ( ) ; timer . mark ( _ STR ) ; logger . info ( _ STR , num Source Positions , num Target Positions , num Sentences ) ; final int src Length = num Source Positions + num Sentences ; if ( src Length < _ NUM ) throw new  Runtime Exception ( _ STR ) ; src Bitext = new int [ src Length ] ; f2e = new int [ src Length ] ; final int tgt Length = num Target Positions + num Sentences ; if ( tgt Length < _ NUM ) throw new  Runtime Exception ( _ STR ) ; tgt Bitext = new int [ tgt Length ] ; e2f = new int [ tgt Length ] ; try (  Line Number Reader f Reader =  IOTools . get Reader From File ( source ) ) {  Line Number Reader e Reader =  IOTools . get Reader From File ( target ) ;  Line Number Reader a Reader =  IOTools . get Reader From File ( align ) ; int src Offset = _ NUM ; int tgt Offset = _ NUM ; for (  String f Line ; ( f Line = f Reader . read Line ( ) ) != null ; ) {  String e Line = e Reader . read Line ( ) ;  String a Line = a Reader . read Line ( ) ;  Aligned Sentence sentence = corpus . get Sentence ( f Line , e Line , a Line ) ; if ( sentence == null ) { logger . info ( _ STR , f Reader . get Line Number ( ) ) ; } else {  System . arraycopy ( sentence . source , _ NUM , src Bitext , src Offset , sentence . source Length ( ) ) ;  System . arraycopy ( sentence . f2e , _ NUM , f2e , src Offset , sentence . f2e . length ) ;  System . arraycopy ( sentence . target , _ NUM , tgt Bitext , tgt Offset , sentence . target Length ( ) ) ;  System . arraycopy ( sentence . e2f , _ NUM , e2f , tgt Offset , sentence . e2f . length ) ; src Offset += sentence . source Length ( ) ; tgt Offset += sentence . target Length ( ) ; src Bitext [ src Offset ] = to Sentence Offset ( tgt Offset ) ; tgt Bitext [ tgt Offset ] = to Sentence Offset ( src Offset ) ; ++ src Offset ; ++ tgt Offset ; } } } this . vocabulary = corpus . get Vocabulary ( ) ; assert initial Vocabulary Size == vocabulary . size ( ) ; timer . mark ( _ STR ) ; logger . info ( _ STR , timer ) ; }
public static float mix Friction ( float friction1 , float friction2 ) { return  Math Utils . sqrt ( friction1 * friction2 ) ; }
public  String serialize (  Object obj ,  String content Type ) throws  Api Exception { if ( content Type . starts With ( _ STR ) ) { return json . serialize ( obj ) ; } else { throw new  Api Exception ( _ NUM , _ STR + content Type ) ; } }
private boolean compile SWsequence ZR ( int base Register , int [ ] offsets , int [ ] registers ) { for ( int i = _ NUM ; i < registers . length ; i ++ ) { if ( registers [ i ] != _zr ) { return _ BOOL ; } } for ( int i = _ NUM ; i < offsets . length ; i ++ ) { if ( offsets [ i ] != offsets [ i - _ NUM ] + _ NUM ) { return _ BOOL ; } } int offset = offsets [ _ NUM ] ; int length = offsets . length ; do { int copy Length =  Math . min ( length ,  Fast Memory . zero . length ) ; mv . visit Field Insn (  Opcodes .  GETSTATIC ,  Type . get Internal Name (  Fast Memory . class ) , _ STR , _ STR ) ; load Imm ( _ NUM ) ; load Memory Int ( ) ; prepare Mem Index ( base Register , offset , _ BOOL , _ NUM ) ; load Imm ( copy Length ) ; mv . visit Method Insn (  Opcodes .  INVOKESTATIC ,  Type . get Internal Name (  System . class ) , _ STR , arraycopy Descriptor ) ; length -= copy Length ; offset += copy Length ; } while ( length > _ NUM ) ; return _ BOOL ; }
private boolean is Native Volume Expansion Supported (  Volume vplex Volume ,  Long new Size ) { boolean use Native Volume Expansion = _ BOOL ;  String Set assoc Volume Ids = vplex Volume . get Associated Volumes ( ) ; if ( null == assoc Volume Ids ) { s_logger . warn ( _ STR , vplex Volume . for Display ( ) ) ; use Native Volume Expansion = _ BOOL ; } else { for (  String assoc Volume Id : assoc Volume Ids ) {  Volume assoc Volume = _permissions Helper . get Object By Id (  URI . create ( assoc Volume Id ) ,  Volume . class ) ; try { super . verify Volume Expansion Request ( assoc Volume , new Size ) ; } catch (  Exception e ) { use Native Volume Expansion = _ BOOL ; break ; } } } return use Native Volume Expansion ; }
public void update GUI (  Roster Entry r ) { road Name . set Text ( r . get Road Name ( ) ) ; road Number . set Text ( r . get Road Number ( ) ) ; mfg . set Text ( r . get Mfg ( ) ) ; owner . set Text ( r . get Owner ( ) ) ; model . set Text ( r . get Model ( ) ) ; comment . set Text ( r . get Comment ( ) ) ; decoder Model . set Text ( r . get Decoder Model ( ) ) ; decoder Family . set Text ( r . get Decoder Family ( ) ) ; decoder Comment . set Text ( r . get Decoder Comment ( ) ) ; date Updated . set Text ( r . get Date Updated ( ) ) ; max Speed Spinner . set Value (  Integer . value Of ( r . get Max Speed PCT ( ) ) ) ; }
public static  Double oizp (  Number value ) { if ( value == null ) { return null ; } return ( value . double Value ( ) >= _ NUM ) ? _ NUM : _ NUM ; }
public  Terminal Size with (  Terminal Size size ) { if ( equals ( size ) ) { return this ; } return size ; }
private boolean is Gzip Allowed ( final  Http Servlet Request request ) { return !  Dispatcher Stream Locator . is Included Request ( request ) &&  Wro Util . is Gzip Supported ( request ) ; }
public  Replay Processor ( int buffer Size , boolean unbounded ) { if ( unbounded ) { this . buffer = new  Unbounded Buffer < > ( buffer Size ) ; } else { this . buffer = new  Bounded Buffer < > ( buffer Size ) ; }  SUBSCRIBERS . lazy Set ( this ,  EMPTY ) ; }
protected void on Show Conversations ( @  Non Null  List <  C > conversations ) { if (  DEBUG ) {  Log . d (  TAG , _ STR + conversations . size ( ) + _ STR ) ; } m View . show Conversations ( new  Array List < > ( conversations ) ) ; }
public void enqueue Job ( final  Runnable job ) { synchronized ( m Sleep Sync ) { if ( has Job ( ) ) { throw new  Illegal State Exception ( _ STR ) ; } set Job ( job ) ; m Sleep Sync . notify All ( ) ; } }
public void start Element (  String uri ,  String local Name ,  String q Name ,  Attributes attributes ) throws org . xml . sax .  SAXException { if ( q Name . equals (  Print Data .  XML_ TAG ) ) {  String name = attributes . get Value (  Print Data .  XML_ ATTRIBUTE_ NAME ) ; if ( m_pd == null ) { m_pd = new  Print Data ( m_ctx , name ) ; push ( m_pd ) ; } else {  Print Data temp = new  Print Data ( m_ctx , name ) ; m_cur PD . add Node ( temp ) ; push ( temp ) ; } } else if ( q Name . equals (  Print Data .  XML_ ROW_ TAG ) ) { m_cur PD . add Row ( _ BOOL , _ NUM ) ; } else if ( q Name . equals (  Print Data Element .  XML_ TAG ) ) { m_cur PDEname = attributes . get Value (  Print Data Element .  XML_ ATTRIBUTE_ NAME ) ; m_cur PDEvalue = new  String Buffer ( ) ; } }
public void draw String (  String str , int x , int y , int text Decoration ) { if ( str . length ( ) == _ NUM || ( str . length ( ) == _ NUM && str . char At ( _ NUM ) == _ STR ) ) { return ; }  Object native Font = null ; if ( current != null ) { native Font = current . get Native Font ( ) ; } if ( current instanceof  Custom Font ) { current . draw String ( this , str , x , y ) ; } else { impl . draw String ( native Graphics , native Font , str , x + x Translate , y + y Translate , text Decoration ) ; } }
public void update Nonce Parameters ( ) { if ( m Next Nonce . equals ( m Nonce ) ) { m Cnonce Counter ++ ; } else { m Cnonce Counter = _ NUM ; m Nonce = m Next Nonce ; } }
@  Override public void accept Instance (  Instance Event e ) { if ( e . get Status ( ) ==  Instance Event .  FORMAT_ AVAILABLE ) { m_connected Format = e . get Structure ( ) ; m_stop Requested . set ( _ BOOL ) ; try { init ( new  Instances ( e . get Structure ( ) , _ NUM ) ) ; } catch (  Illegal Argument Exception ex ) { if ( m_log != null ) {  String message = _ STR ; stop With Error Message ( message , ex ) ; return ; } }  String buff Size = m_buffer Size ; try { buff Size = m_env . substitute ( buff Size ) ; m_buffer Size I =  Integer . parse Int ( buff Size ) ; } catch (  Exception ex ) { ex . print Stack Trace ( ) ; } m_incremental Buffer = new  Array List <  Instance Holder > ( m_buffer Size I ) ; m_buffer Files = new  Array List <  File > ( ) ; m_stream Counter = _ NUM ; return ; } m_busy = _ BOOL ; if ( e . get Instance ( ) != null ) { if ( m_stream Counter == _ NUM ) { if ( m_log != null ) { m_log . status Message ( status Message Prefix ( ) + _ STR ) ; m_log . log Message ( _ STR + status Message Prefix ( ) + _ STR + m_buffer Size I ) ; } }  Instance Holder temp H = new  Instance Holder ( ) ; temp H . m_instance = e . get Instance ( ) ; temp H . m_file Number = - _ NUM ; if ( m_string Att Indexes != null ) { copy String Att Vals ( temp H ) ; } m_incremental Buffer . add ( temp H ) ; m_stream Counter ++ ; } if ( e . get Instance ( ) == null || e . get Status ( ) ==  Instance Event .  BATCH_ FINISHED ) { emit Buffered Instances ( ) ; return ; } else if ( m_incremental Buffer . size ( ) == m_buffer Size I ) { try { sort Buffer ( _ BOOL ) ; } catch (  Exception ex ) {  String msg = status Message Prefix ( ) + _ STR ; stop With Error Message ( msg , ex ) ; m_busy = _ BOOL ; return ; } } m_busy = _ BOOL ; }
private void match VPools (  URI rp System Id ) {  List <  URI > storage Pool Ids =  Connectivity Util . get RPSystem Storage Pools ( _db Client , rp System Id ) ;  String Buffer error Message = new  String Buffer ( ) ; if ( storage Pool Ids != null && ! storage Pool Ids . is Empty ( ) ) {  List <  Storage Pool > storage Pools = _db Client . query Object (  Storage Pool . class , storage Pool Ids ) ;  Implicit Pool Matcher . match Modified Storage Pools With All Virtual Pool ( storage Pools , _db Client , _coordinator , error Message ) ; } }
public static  Big Decimal calculate Fee (  Player player , int price ) {  Big Decimal fee =  Big Decimal . value Of ( price ) ; fee = fee . multiply (  Big Decimal . value Of (  TRADING_ FEE_ PERCENTAGE ) ) ; if ( player . is Bad Boy ( ) ) { fee = fee . multiply (  Big Decimal . value Of ( _ NUM +  TRADING_ FEE_ PLAYER_ KILLER_ PENALTY ) ) ; }  Big Decimal fee Bonus =  Big Decimal .  ONE ; fee Bonus =  Big Decimal . value Of (  Math . exp ( - player . get Tradescore ( ) /  FEE_ BONUS_ CONSTANT ) ) ; fee = fee . multiply ( fee Bonus ) ; return fee . max (  Big Decimal .  ONE ) ; }
private void add Search History ( ) { add Search History ( tf Search Editor . get Text ( ) ) ; }
Array List <  Source File > trim File List (  Array List <  Source File > files ) {  Hash Map <  String ,  String > names = new  Hash Map <  String ,  String > ( ) ;  Array List <  Source File > list = new  Array List <  Source File > ( ) ; int size = files . size ( ) ; for ( int i = _ NUM ; i < size ; i ++ ) { boolean add It = _ BOOL ;  Source File fi = files . get ( i ) ;  String f Name = fi . get Raw Name ( ) ; if ( m_swf Filter == null ) { if ( names . get ( f Name ) == null ) add It = _ BOOL ; } else { add It = m_swf Filter . contains Source ( fi ) ; } if ( add It ) { names . put ( f Name , f Name ) ; list . add ( fi ) ; } } return list ; }
public static  String join ( double [ ] self ,  String separator ) {  String Builder buffer = new  String Builder ( ) ; boolean first = _ BOOL ; if ( separator == null ) separator = _ STR ; for ( double next : self ) { if ( first ) { first = _ BOOL ; } else { buffer . append ( separator ) ; } buffer . append ( next ) ; } return buffer . to String ( ) ; }
public  Entity Query order By (  String ... fields ) { this . order By =  Arrays . as List ( fields ) ; return this ; }
public  Stemmed String (  String orig ,  String stemmed ) { str Orig = orig ; str Stemmed = stemmed ; }
public  Log Network Stream Merger (  Log Request req ,  Media Type media Type ,  Log Svc Properties Loader properties Loader ) { logger . trace ( _ STR ) ; this . request = req ; this . media Type = media Type ; this . properties Loader = properties Loader ;  List <  Log Network Reader > readers = get Log Network Streams ( ) ; int size = readers . size ( ) ; log Heads = new  Log Message [ size ] ; this . log Stream List = new  Log Network Reader [ size ] ; int index = _ NUM ; for (  Log Network Reader reader : readers ) { log Stream List [ index ] = reader ; log Heads [ index ] = null ; index ++ ; } }
public static  String pack Cipher Suites (  String [ ] ciphers ) {  String cipher Set = null ; if ( ciphers != null ) {  String Buffer buf = new  String Buffer ( ) ; for ( int i = _ NUM ; i < ciphers . length ; i ++ ) { buf . append ( ciphers [ i ] ) ; if ( i < ciphers . length - _ NUM ) { buf . append ( _ STR ) ; } } cipher Set = buf . to String ( ) ; } return cipher Set ; }
public  Extension File Filter (  String description ,  String extension ) { this . description = description ; this . extensions = new  Hash Set <  String > ( ) ; extensions . add ( extension . to Lower Case ( ) ) ; default Extension = extension ; }
private static boolean is An Argument ( final  String arg ) { return ( arg . starts With ( _ STR ) && ( arg . length ( ) > _ NUM ) && !  Character . is Digit ( arg . char At ( _ NUM ) ) ) ; }
private synchronized static void remove Children (  Node node , short type , boolean deep ) {  Node List list = node . get Child Nodes ( ) ; for ( int i = list . get Length ( ) ; i >= _ NUM ; i -- ) {  Node n = list . item ( i ) ; if ( n == null ) continue ; if ( n . get Node Type ( ) == type || type ==  UNDEFINED_ NODE ) node . remove Child (  XMLCaster . to Raw Node ( n ) ) ; else if ( deep ) remove Children ( n , type , deep ) ; } }
public boolean is Valid Savepoint (  Savepoint sp ) { if ( is Source ( ) ) return _ BOOL ; boolean result = _ BOOL ; if ( sp != null ) result = _ BOOL ; return result ; }
public static void columns For (  Result Set result Set ,  Table Editor editor ) throws  SQLException {  List <  Column > columns = new  Array List < > ( ) ; columns For ( result Set , null ) ; editor . set Columns ( columns ) ; }
private static void write (  Collection <  String > src ,  File out ) throws  IOException { try (  Writer writer = new  Buffered Writer ( new  File Writer ( out ) ) ) { for (  String line : src ) writer . write ( line + _ STR ) ; } }
private long reset Uid Validity ( ) throws  IOException { long timestamp =  System . current Time Millis ( ) ; set Uid Validity ( timestamp ) ; return timestamp ; }
public final  Array List <  Move > pseudo Legal Moves (  Position pos ) {  Array List <  Move > move List = get Move List Obj ( ) ; final boolean wtm = pos . white Move ; for ( int x = _ NUM ; x < _ NUM ; x ++ ) { for ( int y = _ NUM ; y < _ NUM ; y ++ ) { int sq =  Position . get Square ( x , y ) ; int p = pos . get Piece ( sq ) ; if ( ( p ==  Piece .  EMPTY ) || (  Piece . is White ( p ) != wtm ) ) { continue ; } if ( ( p ==  Piece .  WROOK ) || ( p ==  Piece .  BROOK ) || ( p ==  Piece .  WQUEEN ) || ( p ==  Piece .  BQUEEN ) ) { if ( add Direction ( move List , pos , sq , _ NUM - x , _ NUM ) ) return move List ; if ( add Direction ( move List , pos , sq , _ NUM - y , _ NUM ) ) return move List ; if ( add Direction ( move List , pos , sq , x , - _ NUM ) ) return move List ; if ( add Direction ( move List , pos , sq , y , - _ NUM ) ) return move List ; } if ( ( p ==  Piece .  WBISHOP ) || ( p ==  Piece .  BBISHOP ) || ( p ==  Piece .  WQUEEN ) || ( p ==  Piece .  BQUEEN ) ) { if ( add Direction ( move List , pos , sq ,  Math . min ( _ NUM - x , _ NUM - y ) , _ NUM ) ) return move List ; if ( add Direction ( move List , pos , sq ,  Math . min ( x , _ NUM - y ) , _ NUM ) ) return move List ; if ( add Direction ( move List , pos , sq ,  Math . min ( x , y ) , - _ NUM ) ) return move List ; if ( add Direction ( move List , pos , sq ,  Math . min ( _ NUM - x , y ) , - _ NUM ) ) return move List ; } if ( ( p ==  Piece .  WKNIGHT ) || ( p ==  Piece .  BKNIGHT ) ) { if ( x < _ NUM && y < _ NUM && add Direction ( move List , pos , sq , _ NUM , _ NUM ) ) return move List ; if ( x < _ NUM && y < _ NUM && add Direction ( move List , pos , sq , _ NUM , _ NUM ) ) return move List ; if ( x > _ NUM && y < _ NUM && add Direction ( move List , pos , sq , _ NUM , _ NUM ) ) return move List ; if ( x > _ NUM && y < _ NUM && add Direction ( move List , pos , sq , _ NUM , _ NUM ) ) return move List ; if ( x > _ NUM && y > _ NUM && add Direction ( move List , pos , sq , _ NUM , - _ NUM ) ) return move List ; if ( x > _ NUM && y > _ NUM && add Direction ( move List , pos , sq , _ NUM , - _ NUM ) ) return move List ; if ( x < _ NUM && y > _ NUM && add Direction ( move List , pos , sq , _ NUM , - _ NUM ) ) return move List ; if ( x < _ NUM && y > _ NUM && add Direction ( move List , pos , sq , _ NUM , - _ NUM ) ) return move List ; } if ( ( p ==  Piece .  WKING ) || ( p ==  Piece .  BKING ) ) { if ( x < _ NUM && add Direction ( move List , pos , sq , _ NUM , _ NUM ) ) return move List ; if ( x < _ NUM && y < _ NUM && add Direction ( move List , pos , sq , _ NUM , _ NUM ) ) return move List ; if ( y < _ NUM && add Direction ( move List , pos , sq , _ NUM , _ NUM ) ) return move List ; if ( x > _ NUM && y < _ NUM && add Direction ( move List , pos , sq , _ NUM , _ NUM ) ) return move List ; if ( x > _ NUM && add Direction ( move List , pos , sq , _ NUM , - _ NUM ) ) return move List ; if ( x > _ NUM && y > _ NUM && add Direction ( move List , pos , sq , _ NUM , - _ NUM ) ) return move List ; if ( y > _ NUM && add Direction ( move List , pos , sq , _ NUM , - _ NUM ) ) return move List ; if ( x < _ NUM && y > _ NUM && add Direction ( move List , pos , sq , _ NUM , - _ NUM ) ) return move List ; int k0 = wtm ?  Position . get Square ( _ NUM , _ NUM ) :  Position . get Square ( _ NUM , _ NUM ) ; if (  Position . get Square ( x , y ) == k0 ) { int a Castle = wtm ?  Position .  A1_ CASTLE :  Position .  A8_ CASTLE ; int h Castle = wtm ?  Position .  H1_ CASTLE :  Position .  H8_ CASTLE ; int rook = wtm ?  Piece .  WROOK :  Piece .  BROOK ; if ( ( ( pos . get Castle Mask ( ) & ( _ NUM << h Castle ) ) != _ NUM ) && ( pos . get Piece ( k0 + _ NUM ) ==  Piece .  EMPTY ) && ( pos . get Piece ( k0 + _ NUM ) ==  Piece .  EMPTY ) && ( pos . get Piece ( k0 + _ NUM ) == rook ) && ! sq Attacked ( pos , k0 ) && ! sq Attacked ( pos , k0 + _ NUM ) ) { move List . add ( get Move Obj ( k0 , k0 + _ NUM ,  Piece .  EMPTY ) ) ; } if ( ( ( pos . get Castle Mask ( ) & ( _ NUM << a Castle ) ) != _ NUM ) && ( pos . get Piece ( k0 - _ NUM ) ==  Piece .  EMPTY ) && ( pos . get Piece ( k0 - _ NUM ) ==  Piece .  EMPTY ) && ( pos . get Piece ( k0 - _ NUM ) ==  Piece .  EMPTY ) && ( pos . get Piece ( k0 - _ NUM ) == rook ) && ! sq Attacked ( pos , k0 ) && ! sq Attacked ( pos , k0 - _ NUM ) ) { move List . add ( get Move Obj ( k0 , k0 - _ NUM ,  Piece .  EMPTY ) ) ; } } } if ( ( p ==  Piece .  WPAWN ) || ( p ==  Piece .  BPAWN ) ) { int y Dir = wtm ? _ NUM : - _ NUM ; if ( pos . get Piece ( sq + y Dir ) ==  Piece .  EMPTY ) { add Pawn Moves ( move List , sq , sq + y Dir ) ; if ( ( y == ( wtm ? _ NUM : _ NUM ) ) && ( pos . get Piece ( sq + _ NUM * y Dir ) ==  Piece .  EMPTY ) ) { add Pawn Moves ( move List , sq , sq + y Dir * _ NUM ) ; } } if ( x > _ NUM ) { int to Sq = sq + y Dir - _ NUM ; int cap = pos . get Piece ( to Sq ) ; if ( cap !=  Piece .  EMPTY ) { if (  Piece . is White ( cap ) != wtm ) { if ( cap == ( wtm ?  Piece .  BKING :  Piece .  WKING ) ) { return Move List ( move List ) ; move List = get Move List Obj ( ) ; move List . add ( get Move Obj ( sq , to Sq ,  Piece .  EMPTY ) ) ; return move List ; } else { add Pawn Moves ( move List , sq , to Sq ) ; } } } else if ( to Sq == pos . get Ep Square ( ) ) { add Pawn Moves ( move List , sq , to Sq ) ; } } if ( x < _ NUM ) { int to Sq = sq + y Dir + _ NUM ; int cap = pos . get Piece ( to Sq ) ; if ( cap !=  Piece .  EMPTY ) { if (  Piece . is White ( cap ) != wtm ) { if ( cap == ( wtm ?  Piece .  BKING :  Piece .  WKING ) ) { return Move List ( move List ) ; move List = get Move List Obj ( ) ; move List . add ( get Move Obj ( sq , to Sq ,  Piece .  EMPTY ) ) ; return move List ; } else { add Pawn Moves ( move List , sq , to Sq ) ; } } } else if ( to Sq == pos . get Ep Square ( ) ) { add Pawn Moves ( move List , sq , to Sq ) ; } } } } } return move List ; }
private void handle Static Site Request (  Static Site Request .  Point Request request ,  Transport Network transport Network ,  Task Statistics ts ) {  Static Computer computer = new  Static Computer ( request , transport Network , ts ) ; if ( request . request . bucket != null ) computer . run ( ) ; else { try {  Piped Input Stream pis = new  Piped Input Stream ( ) ;  Piped Output Stream pos = new  Piped Output Stream ( pis ) ; finish Priority Task ( request , pis ) ; computer . write ( pos ) ; pos . close ( ) ; } catch (  IOException e ) {  LOG . error ( _ STR , e ) ; } } delete Request ( request ) ; }
public synchronized void remove Room (  String room ) { if ( !  Helper . validate Stream ( room ) ) { return ; } room = room . to Lower Case ( ) ; if ( rooms . remove ( room ) ) { unsub Room ( room ) ; remove Emotes ( room ) ; prev Emotesets . remove ( room ) ; } }
public void add All ( final  Collection elements ) { adjusting = _ BOOL ;  Set old Selection = new  Hash Set ( selection ) ; boolean rv = selection . add All ( elements ) ; adjusting = _ BOOL ; if ( rv ) { fire Selection Changed ( old Selection , selection ) ; } old Selection = null ; }
public boolean has Feature ( int feature ) { return ( ( feature >=  MODE_ FIRST && feature <=  MODE_ LAST ) || ( feature >=  FEATURE_ FIRST && feature <=  FEATURE_ LAST ) ) && ( feature ==  MODE_ OFF || m Capabilities . get ( feature ) ) ; }
public  Set <  Integer > backup Partitions (  UUID node Id ) {  Set <  Integer > set = backup . get ( node Id ) ; return set == null ?  Collections . <  Integer > empty Set ( ) : set ; }
public java . lang .  String Buffer insert ( int offset , java . lang .  String str ) { internal . insert ( offset , str ) ; return this ; }
public  Loader load (  String image Url ) {  Image Url = image Url ; return this ; }
private void build PTR ( ) { double [ ] temp_row ; double [ ] [ ]  PTRA ; int k ;  Pivot Transform pt ;  PTR =  Matrix . identity ( n , n ) ;  PTRA =  PTR . get Array ( ) ; k = pivot Transform Queue . size ( ) ; while ( k -- > _ NUM ) { pt = pivot Transform Queue . remove Last ( ) ; temp_row =  PTRA [ pt . pos1 ] ;  PTRA [ pt . pos1 ] =  PTRA [ pt . pos2 ] ;  PTRA [ pt . pos2 ] = temp_row ; } }
public  Bidi create Line Bidi ( int line Start , int line Limit ) {  Attributed String astr = new  Attributed String ( _ STR ) ;  Bidi new Bidi = new  Bidi ( astr . get Iterator ( ) ) ; return bidi Base . set Line ( this , bidi Base , new Bidi , new Bidi . bidi Base , line Start , line Limit ) ; }
public void restart And Install If Necessary ( ) {  File patches Dir = new  File ( my Sdk Handler . get Location ( ) ,  Patch Installer Util .  PATCHES_ DIR_ NAME ) ;  Studio Logger Progress Indicator progress = new  Studio Logger Progress Indicator (  Patch Installer Factory . class ) ; if ( patches Dir . exists ( ) ) {  File [ ] sub Dirs = patches Dir . list Files ( null ) ; for (  File patch Dir : sub Dirs ) { process Patch ( my Sdk Handler . get Location ( ) , progress , patch Dir ) ; } } }
public static double [ ] [ ] align ( int [ ] real , double [ ] pred ) { int missing = number Of Missing Labels ( real ) ; double [ ] _real = new double [ real . length - missing ] ; double [ ] _pred = new double [ real . length - missing ] ; int offset = _ NUM ; for ( int i = _ NUM ; i < real . length ; i ++ ) { if ( real [ i ] == - _ NUM || pred [ i ] == - _ NUM ||  Double . is Na N ( pred [ i ] ) ) { offset ++ ; continue ; } _real [ i - offset ] = real [ i ] ; _pred [ i - offset ] = pred [ i ] ; } double [ ] [ ] res = new double [ _ NUM ] [ _ NUM ] ; res [ _ NUM ] = _real ; res [ _ NUM ] = _pred ; return res ; }
public static boolean is Category ( int  M_ Product_ Category_ ID , int  M_ Product_ ID ) { if (  M_ Product_ ID == _ NUM ||  M_ Product_ Category_ ID == _ NUM ) return _ BOOL ;  Integer product = new  Integer (  M_ Product_ ID ) ;  Integer category = (  Integer ) s_products . get ( product ) ; if ( category != null ) return category . int Value ( ) ==  M_ Product_ Category_ ID ;  String sql = _ STR ;  Prepared Statement pstmt = null ; try { pstmt =  DB . prepare Statement ( sql , null ) ; pstmt . set Int ( _ NUM ,  M_ Product_ ID ) ;  Result Set rs = pstmt . execute Query ( ) ; if ( rs . next ( ) ) category = new  Integer ( rs . get Int ( _ NUM ) ) ; rs . close ( ) ; pstmt . close ( ) ; pstmt = null ; } catch (  Exception e ) { s_log . log (  Level .  SEVERE , sql , e ) ; } try { if ( pstmt != null ) pstmt . close ( ) ; pstmt = null ; } catch (  Exception e ) { pstmt = null ; } if ( category != null ) { s_products . put ( product , category ) ; s_log . fine ( _ STR +  M_ Product_ ID + _ STR + category + _ STR +  M_ Product_ Category_ ID + _ STR + ( category . int Value ( ) ==  M_ Product_ Category_ ID ) ) ; return category . int Value ( ) ==  M_ Product_ Category_ ID ; } s_log . log (  Level .  SEVERE , _ STR +  M_ Product_ ID ) ; return _ BOOL ; }
public  All Stats Table Multi (  Dataset Generator dataset Generator ,  Locker locker ) {  Argument Checking . not Null ( dataset Generator , _ STR ) ; init Components ( ) ; table . set Default Renderer (  JLabel . class , new  Renderer ( ) ) ; table . set Column Selection Allowed ( _ BOOL ) ; table . set Row Selection Allowed ( _ BOOL ) ; table . set Grid Color (  GRID_ COLOR ) ;  JTable Header header = table . get Table Header ( ) ; header . set Reordering Allowed ( _ BOOL ) ;  GUIUtilities . set Table Header ( header ) ; model = new  Model ( dataset Generator ) ; table . set Model ( model ) ; this . locker = locker ; }
public void append (  File file ,  FTPData Transfer Listener listener ) throws  Illegal State Exception ,  File Not Found Exception ,  IOException ,  FTPIllegal Reply Exception ,  FTPException ,  FTPData Transfer Exception ,  FTPAborted Exception { if ( ! file . exists ( ) ) { throw new  File Not Found Exception ( file . get Absolute Path ( ) ) ; }  Input Stream input Stream = null ; try { input Stream = new  File Input Stream ( file ) ; } catch (  IOException e ) { throw new  FTPData Transfer Exception ( e ) ; } try { append ( file . get Name ( ) , input Stream , _ NUM , listener ) ; } catch (  Illegal State Exception e ) { throw e ; } catch (  IOException e ) { throw e ; } catch (  FTPIllegal Reply Exception e ) { throw e ; } catch (  FTPException e ) { throw e ; } catch (  FTPData Transfer Exception e ) { throw e ; } catch (  FTPAborted Exception e ) { throw e ; } finally { if ( input Stream != null ) { try { input Stream . close ( ) ; } catch (  Throwable t ) { ; } } } }
public static boolean is Scoped Name (  String name ) { return name . index Of ( _ STR ) != - _ NUM ; }
public  Input (  Io Buffer buf ) { super ( buf ) ; amf3_mode = _ NUM ; string References = new  Array List <  String > ( ) ; class References = new  Array List <  Class Reference > ( ) ; }
public static  Properties load Config File (  String path ) {  Properties property = null ;  File file = new  File ( path ) ; if ( file . exists ( ) && file . can Read ( ) ) { try { property = new  Properties ( ) ; property . load ( new  File Reader ( file . get Absolute Path ( ) ) ) ; } catch (  File Not Found Exception e ) { e . print Stack Trace ( ) ; } catch (  IOException e ) { e . print Stack Trace ( ) ; } } return property ; }
protected static void to EPLViews (  String Writer writer ,  List <  View > views ) { if ( ( views != null ) && ( views . size ( ) != _ NUM ) ) { writer . write ( _ STR ) ;  String delimiter = _ STR ; for (  View view : views ) { writer . write ( delimiter ) ; view . to EPL ( writer ) ; delimiter = _ STR ; } } }
protected void remove Database Listeners ( ) { database Listeners . clear ( ) ; }
public void add Generic Attr (  Generic Attr g ) { generic . add Element ( g ) ; }
private  List <  Fahrzeit Event > add Fahrt Info To Fahrzeit Events (  List <  Fahrt Event > fahrt Events ,  List <  Fahrzeit Event > fahrzeit Events , boolean keep Fahrzeit Events Without Fahrt Event ) {  List <  Fahrzeit Event > fahrzeit Events Out = new  Linked List <  Fahrzeit Event > ( ) ;  Map <  String ,  Fahrt Event > rbl Date Kurs Date Time Ist2 Fahrt Event Map = new  Hash Map <  String ,  Fahrt Event > ( ) ;  Set <  String > search Strings = new  Tree Set <  String > ( ) ; for (  Fahrt Event fahrt Event : fahrt Events ) {  String search Id =  String . value Of ( fahrt Event . get Rbl Date ( ) ) +  String . value Of ( fahrt Event . get Kurs ( ) ) + fahrt Event . get Departure Date Ist ( ) + fahrt Event . get Departure Time Ist ( ) ; if ( search Strings . contains ( search Id ) ) { log . warn ( _ STR + search Id ) ; } else { search Strings . add ( search Id ) ; rbl Date Kurs Date Time Ist2 Fahrt Event Map . put ( search Id , fahrt Event ) ; } } int number Of Missing Fahrt Events = _ NUM ; for (  Fahrzeit Event fahrzeit Event : fahrzeit Events ) {  String search Id =  String . value Of ( fahrzeit Event . get Rbl Date ( ) ) +  String . value Of ( fahrzeit Event . get Kurs ( ) ) + fahrzeit Event . get Departure Date Ist ( ) + fahrzeit Event . get Departure Time Ist ( ) ;  Fahrt Event fahrt Event = rbl Date Kurs Date Time Ist2 Fahrt Event Map . get ( search Id ) ; if ( fahrt Event == null ) { number Of Missing Fahrt Events ++ ; if ( keep Fahrzeit Events Without Fahrt Event ) { fahrzeit Events Out . add ( fahrzeit Event ) ; } } else { fahrzeit Event . add ( fahrt Event ) ; fahrzeit Events Out . add ( fahrzeit Event ) ; } } log . info ( number Of Missing Fahrt Events + _ STR ) ; log . info ( _ STR + fahrzeit Events Out . size ( ) + _ STR ) ; return fahrzeit Events Out ; }
private void check UUID (  String uuid , int code ) { check Hash (  UUID . from String ( uuid ) , code ) ; }
@  Override protected void prepare Write (  Writable Byte Channel channel ) throws  Exception { os =  Channels . new Output Stream ( channel ) ; }
public void run ( ) { try { boolean clean Remote Sessions = _ BOOL ; synchronized ( this ) {  Collection <  State Info > infos = new  Array List < > ( ) ; infos . add All ( servers . values ( ) ) ; infos . add All ( sites . values ( ) ) ; for (  State Info info : infos ) { info . is Up = check Server Up ( info ) ; if ( ! info . is Up ) { down . add ( info . id ) ; } else { if ( ! down . is Empty ( ) && down . remove ( info . id ) ) { clean Remote Sessions = _ BOOL ; } } } } if ( clean Remote Sessions ) { foreign Session Handler . clean Up Remote Sessions ( ) ; } } catch (  Exception ex ) { session Debug . error ( _ STR + ex . get Message ( ) , ex ) ; } }
private void write Object ( java . io .  Object Output Stream p_stream ) throws java . io .  IOException { p_stream . default Write Object ( ) ; p_stream . write Int ( trace_angle_restriction . get_no ( ) ) ; }
public  Builder add Header (  String name ,  String value ) { headers . add ( new  Header ( name , value ) ) ; return this ; }
public static double normal CDF ( double x ) { return ( _ NUM * ( _ NUM + ( erf ( x / (  Math . sqrt ( _ NUM ) ) ) ) ) ) ; }
public void remove Result (  String name ) {  String Buffer buff = m_ Results . get ( name ) ; if ( buff != null ) { m_ Results . remove ( name ) ; m_ Model . remove Element ( name ) ; m_ Objs . remove ( name ) ;  System . gc ( ) ; } }
private void add Entry ( ) { filter Model . add New Entry ( ) ; extent Model . populate ( null ) ; remove FTCButton . set Enabled ( _ BOOL ) ; add Extent Button . set Enabled ( _ BOOL ) ; remove Extent Button . set Enabled ( _ BOOL ) ; }
double [ ] [ ]  Calc Theoretical SVValues (  Variogram vario , double  Maximum Disply Distanst ) { double [ ] [ ] res = new double [ _ NUM *  Number Of Lags + _ NUM ] [ _ NUM ] ; for ( int i = _ NUM ; i < res . length ; i ++ ) { res [ i ] [ _ NUM ] = i *  Maximum Disply Distanst / ( _ NUM *  Number Of Lags ) ; switch ( vario .  Type ) { case  EXPONENTIAL : if ( res [ i ] [ _ NUM ] != _ NUM ) { res [ i ] [ _ NUM ] = vario .  Nugget + vario .  Sill * ( _ NUM -  Math . exp ( - res [ i ] [ _ NUM ] / vario .  Range ) ) ; } else { res [ i ] [ _ NUM ] = vario .  Nugget ; } break ; case  GAUSSIAN : if ( res [ i ] [ _ NUM ] != _ NUM ) { res [ i ] [ _ NUM ] = vario .  Nugget + vario .  Sill * ( _ NUM -  Math . exp ( - _ NUM * (  Math . pow ( res [ i ] [ _ NUM ] , _ NUM ) ) / (  Math . pow ( vario .  Range , _ NUM ) ) ) ) ; } else { res [ i ] [ _ NUM ] = vario .  Nugget ; } break ; case  SPHERICAL : if ( res [ i ] [ _ NUM ] > vario .  Range ) { res [ i ] [ _ NUM ] = vario .  Nugget + vario .  Sill ; } else if ( res [ i ] [ _ NUM ] > _ NUM && res [ i ] [ _ NUM ] <= vario .  Range ) { res [ i ] [ _ NUM ] = vario .  Nugget + vario .  Sill * ( _ NUM * res [ i ] [ _ NUM ] / vario .  Range - _ NUM *  Math . pow ( ( res [ i ] [ _ NUM ] / vario .  Range ) , _ NUM ) ) ; } else { res [ i ] [ _ NUM ] = vario .  Nugget ; } break ; } } return res ; }
public  DExport Private Key Open Ssl (  JFrame parent ,  String entry Alias ,  Password Quality Config password Quality Config ) { super ( parent ,  Dialog .  Modality Type .  DOCUMENT_ MODAL ) ; this . entry Alias = entry Alias ; this . password Quality Config = password Quality Config ; init Components ( ) ; }
public  Big Decimal sum (  String sql Expression ) { return aggregate ( sql Expression ,  AGGREGATE_ SUM ) ; }
private void smooth Snap To Position ( int scroll Y , int available Scroll Height ,  Alphabetical Apps List .  Fast Scroll Section Info info ) { m Rv . remove Callbacks ( m Smooth Snap Next Frame Runnable ) ; m Rv . remove Callbacks ( m Fast Scroll To Target Section Runnable ) ; track All Child Views ( ) ; if ( m Has Fast Scroll Touch Settled ) { m Current Fast Scroll Section = info . section Name ; m Target Fast Scroll Section = null ; update Tracked Views Fast Scroll Focus State ( ) ; } else { m Current Fast Scroll Section = null ; m Target Fast Scroll Section = info . section Name ; m Has Fast Scroll Touch Settled = _ BOOL ; update Tracked Views Fast Scroll Focus State ( ) ; m Rv . post Delayed ( m Fast Scroll To Target Section Runnable , m Has Fast Scroll Touch Settled At Least Once ?  REPEAT_ TOUCH_ SETTLING_ DURATION :  INITIAL_ TOUCH_ SETTLING_ DURATION ) ; } int new Scroll Y =  Math . min ( available Scroll Height , m Rv . get Padding Top ( ) + m Rv . get Top ( info . fast Scroll To Item . row Index ) ) ; int num Frames = m Fast Scroll Frames . length ; for ( int i = _ NUM ; i < num Frames ; i ++ ) { m Fast Scroll Frames [ i ] = ( new Scroll Y - scroll Y ) / num Frames ; } m Fast Scroll Frame Index = _ NUM ; m Rv . post On Animation ( m Smooth Snap Next Frame Runnable ) ; }
@  Override public int calculate Offset X ( ) { return ( int ) (  Math . cos ( this . angle ) * this . distance ) - this . shadow Size ; }
private <  T > void run Test Write (  Xml Writer <  T > writer ,  List <  T > bundle ,  List <  String > expected ) throws  Exception {  File tmp File = tmp Folder . new File ( _ STR ) ; try (  File Output Stream file Output Stream = new  File Output Stream ( tmp File ) ) { write Bundle ( writer , bundle , file Output Stream . get Channel ( ) ) ; }  List <  String > lines = new  Array List < > ( ) ; try (  Buffered Reader reader = new  Buffered Reader ( new  File Reader ( tmp File ) ) ) { for ( ; ; ) {  String line = reader . read Line ( ) ; if ( line == null ) { break ; } line = line . trim ( ) ; if ( line . length ( ) > _ NUM ) { lines . add ( line ) ; } } assert Equals ( expected , lines ) ; } }
public  String add Days (  Object odays ,  String format ) { int days =  Function Handler . get Int ( odays ) ;  Calendar now =  Calendar . get Instance ( ) ; now . add (  Calendar .  DAY_ OF_ YEAR , days ) ;  Date Format formatter = get Formatter ( format ) ; return formatter . format ( now . get Time ( ) ) ; }
private static  File create Temp File (  Context context , @  Nullable  String mime Type ) throws  IOException {  File external Cache Dir = context . get External Cache Dir ( ) ;  File internal Cache Dir = context . get Cache Dir ( ) ;  File cache Dir ; if ( external Cache Dir == null && internal Cache Dir == null ) { throw new  IOException ( _ STR ) ; } if ( external Cache Dir == null ) { cache Dir = internal Cache Dir ; } else if ( internal Cache Dir == null ) { cache Dir = external Cache Dir ; } else { cache Dir = external Cache Dir . get Free Space ( ) > internal Cache Dir . get Free Space ( ) ? external Cache Dir : internal Cache Dir ; } return  File . create Temp File (  TEMP_ FILE_ PREFIX , get File Extension For Type ( mime Type ) , cache Dir ) ; }
@  Override public  Enumeration <  Option > list Options ( ) {  Vector <  Option > new Vector = new  Vector <  Option > ( _ NUM ) ; new Vector . add Element ( new  Option ( _ STR + _ STR , _ STR , _ NUM , _ STR ) ) ; new Vector . add Element ( new  Option ( _ STR + _ STR , _ STR , _ NUM , _ STR ) ) ; new Vector . add Element ( new  Option ( _ STR , _ STR , _ NUM , _ STR ) ) ; new Vector . add Element ( new  Option ( _ STR + _ STR + _ STR , _ STR , _ NUM , _ STR ) ) ; return new Vector . elements ( ) ; }
public boolean remove Entry ( int x Index , int data Set Index ) { if ( data Set Index >= m Data Sets . size ( ) ) return _ BOOL ;  T data Set = m Data Sets . get ( data Set Index ) ;  Entry e = data Set . get Entry For XIndex ( x Index ) ; return remove Entry ( e , data Set Index ) ; }
private void run Read Test ( byte [ ] input ,  Compression Mode mode ) throws  IOException { run Read Test ( input , mode , mode ) ; }
public static void close ( @  Nullable  Context rsrc , @  Nullable  Ignite Logger log ) { if ( rsrc != null ) try { rsrc . close ( ) ; } catch (  Naming Exception e ) { warn ( log , _ STR + e . get Message ( ) ) ; } }
public  Writable Raster create Compatible Writable Raster ( int w , int h ) { if ( w <= _ NUM || h <= _ NUM ) { throw new  Raster Format Exception ( _ STR + ( ( w <= _ NUM ) ? _ STR : _ STR ) ) ; }  Sample Model sm = sample Model . create Compatible Sample Model ( w , h ) ; return new  Integer Interleaved Raster ( sm , new  Point ( _ NUM , _ NUM ) ) ; }
public static  String [ ] scheduler Command Args (  Config config ,  Config runtime ,  List <  Integer > free Ports ) { if ( free Ports . size ( ) <  PORTS_ REQUIRED_ FOR_ SCHEDULER ) { throw new  Runtime Exception ( _ STR ) ; } for ( int port : free Ports ) { if ( port == - _ NUM ) { throw new  Runtime Exception ( _ STR ) ; } } int http Port = free Ports . get ( _ NUM ) ;  List <  String > commands = new  Array List < > ( ) ; commands . add ( _ STR ) ; commands . add (  Context . cluster ( config ) ) ; commands . add ( _ STR ) ; commands . add (  Context . role ( config ) ) ; commands . add ( _ STR ) ; commands . add (  Context . environ ( config ) ) ; commands . add ( _ STR ) ; commands . add (  Context . topology Name ( config ) ) ; commands . add ( _ STR ) ; commands . add (  Context . topology Binary File ( config ) ) ; commands . add ( _ STR ) ; commands . add (  Integer . to String ( http Port ) ) ; return commands . to Array ( new  String [ _ NUM ] ) ; }
public  Document Analysis Request add Document (  Solr Input Document doc ) { documents . add ( doc ) ; return this ; }
public final  Key do Phase (  Key key , boolean last Phase ) throws  Invalid Key Exception ,  Illegal State Exception { choose First Provider ( ) ; return spi . engine Do Phase ( key , last Phase ) ; }
public  Simple System Permission Set ( ) { }
@  Override public final void add Bezier Curve Y ( final float x , final float y , final float x3 , final float y3 ) { elements . add ( new  Quad Curve To ( x , y , x3 , y3 ) ) ; current Pos [ _ NUM ] = x3 ; current Pos [ _ NUM ] = y3 ; }
public void read Buckets From Prefs ( ) {  Shared Preferences prefs = m Context . get Shared Preferences (  SHARED_ PREFS , _ NUM ) ;  Set <  String > buckets = prefs . get String Set (  PREF_ BUCKETS_ IDS , new  Tree Set <  String > ( ) ) ; m Buckets . clear ( ) ; for (  String bucket Id : buckets ) {  Auto Mix Bucket bucket = restore Bucket From Id ( bucket Id ) ; m Buckets . add ( bucket ) ; } }
@  Override public void accept App Offer (  Offer offer ) { int index = get Index ( offer , app Offers ) ; if ( index != - _ NUM ) { app Offers . remove ( index ) ; app Offer Stream . on Next ( offer ) ; } index = get Index ( offer , accepted Offers ) ; if ( index == - _ NUM ) { accepted Offers . add ( offer ) ; } }
private void inject Dependencies ( ) {  Easy MVPApplication easy MVPApplication = (  Easy MVPApplication ) get Application ( ) ;  List <  Object > activity Scope Modules = ( get Modules ( ) != null ) ? get Modules ( ) : new  Array List < > ( ) ; activity Scope Modules . add ( new  Activity Module ( this ) ) ; activity Scope Graph = easy MVPApplication . build Graph With Aditional Modules ( activity Scope Modules ) ; inject ( this ) ; }
public void write Request ( ) {  Object lock = new  Object ( ) ; synchronized ( lock ) { synchronized ( this ) { boolean go Ahead With Write = writer Locks . size ( ) == _ NUM && current Readers == _ NUM && current Writers == _ NUM ; if ( go Ahead With Write ) { ++ current Writers ; return ; } writer Locks . add Last ( lock ) ; } try { lock . wait ( ) ; } catch (  Interrupted Exception e ) { } } }
public long read Local Date ( ) throws  IOException { expect Start Tag ( _ STR ) ; if ( local Calendar == null ) local Calendar =  Calendar . get Instance ( ) ; long value = parse Date ( local Calendar ) ; expect End Tag ( _ STR ) ; return value ; }
public void remove Selection Listener ( final  Selection Listener listener ) { check Widget ( ) ; listeners . remove ( listener ) ; }
private synchronized  String read Input Stream (  Input Stream Reader input Stream Reader ) throws  IOException ,  Bad Location Exception {  Buffered Reader buffered Reader = null ; try { buffered Reader = new  Buffered Reader ( input Stream Reader ) ;  String new Line = _ STR ;  String Buffer sb = new  String Buffer ( ) ;  String line ; while ( ( line = buffered Reader . read Line ( ) ) != null ) { sb . append ( line + new Line ) ; } return sb . to String ( ) ; } finally { if ( null != buffered Reader ) buffered Reader . close ( ) ; if ( null != input Stream Reader ) input Stream Reader . close ( ) ; } }
private  List <  Map <  String ,  Object > > type Parameters (  List <  Type Parameter > tpl ,  Declaration from ) { if ( tpl != null && ! tpl . is Empty ( ) ) {  List <  Map <  String ,  Object > > l = new  Array List < > ( tpl . size ( ) ) ; for (  Type Parameter tp : tpl ) { l . add ( type Parameter Map ( tp , from ) ) ; } return l ; } return null ; }
private static boolean within Two (  INode n ,  INode goal ) {  Double Linked List <  IMove > moves = n . valid Moves ( ) ; for (  Iterator <  IMove > it = moves . iterator ( ) ; it . has Next ( ) ; ) {  IMove move = it . next ( ) ;  INode successor = n . copy ( ) ; move . execute ( successor ) ; if ( within One ( successor , goal ) ) { return _ BOOL ; } } return _ BOOL ; }
public  Penn Treebank Reader (  String treebank Home ,  String [ ] sections ,  String parse View Name ) throws  Exception { super (  Corpus Reader Configurator . build Resource Manager (  PENN_ TREEBANK_ WSJ , treebank Home ) ) ; this . parse View Name = parse View Name ; combined WSJHome = treebank Home ; if ( sections == null ) this . sections =  IOUtils . ls Directories ( combined WSJHome ) ; else { this . sections = new  String [ sections . length ] ;  System . arraycopy ( sections , _ NUM , this . sections , _ NUM , sections . length ) ; } update Current Files ( ) ; }
@  Override public void close Write ( ) throws  IOException { if ( _is Close Write ) { return ; } _is Close Write = _ BOOL ;  Output Stream os = _os ; _os = null ; boolean is Shutdown Output = _ BOOL ; if ( _s instanceof  SSLSocket ) { log . finer (  L . l ( _ STR ) ) ; return ; } else if ( _s != null ) { try { _s . shutdown Output ( ) ; is Shutdown Output = _ BOOL ; } catch (  Unsupported Operation Exception e ) { log . log (  Level .  FINEST , e . to String ( ) , e ) ; } catch (  Exception e ) { log . finer ( e . to String ( ) ) ; log . log (  Level .  FINEST , e . to String ( ) , e ) ; } } if ( ! is Shutdown Output && os != null ) { os . close ( ) ; } }
protected void apply Row Change Data (  Row Change Data data ,  List <  Repl Option > options ,  String source Dbms Type ) throws  Replicator Exception { if ( options != null ) { try { if ( apply Session Variables ( null , options ) ) { if ( logger . is Debug Enabled ( ) ) { logger . debug ( _ STR ) ; } execute Pending Batch ( ) ; statement . execute Batch ( ) ; statement . clear Batch ( ) ; } } catch (  SQLException e ) { throw new  Applier Exception ( _ STR , e ) ; } }  List <  Repl Option > row Options = data . get Options ( ) ; if ( row Options != null ) { try { if ( apply Session Variables ( null , row Options ) ) { if ( logger . is Debug Enabled ( ) ) { logger . debug ( _ STR ) ; } execute Pending Batch ( ) ; statement . execute Batch ( ) ; statement . clear Batch ( ) ; } } catch (  SQLException e ) { throw new  Applier Exception ( _ STR , e ) ; } } for (  One Row Change row : data . get Row Changes ( ) ) { apply One Row Change Prepared ( row , source Dbms Type ) ; } }
public void receive Redundancy ( ) { try { while ( _ BOOL ) { if ( m In . read ( m In Buffer ) <= _ NUM ) return ; } } catch (  IOException e ) { } }
MVStore (  Hash Map <  String ,  Object > config ) {  Object o = config . get ( _ STR ) ; this . compression Level = o == null ? _ NUM : (  Integer ) o ;  String file Name = (  String ) config . get ( _ STR ) ; o = config . get ( _ STR ) ; if ( o == null ) { page Split Size = file Name == null ? _ NUM * _ NUM : _ NUM * _ NUM ; } else { page Split Size = (  Integer ) o ; } o = config . get ( _ STR ) ; this . background Exception Handler = (  Uncaught Exception Handler ) o ; meta = new  MVMap <  String ,  String > (  String Data Type .  INSTANCE ,  String Data Type .  INSTANCE ) ;  Hash Map <  String ,  Object > c =  New . hash Map ( ) ; c . put ( _ STR , _ NUM ) ; c . put ( _ STR , current Version ) ; meta . init ( this , c ) ; file Store = (  File Store ) config . get ( _ STR ) ; if ( file Name == null && file Store == null ) { cache = null ; cache Chunk Ref = null ; return ; } if ( file Store == null ) { file Store Is Provided = _ BOOL ; file Store = new  File Store ( ) ; } else { file Store Is Provided = _ BOOL ; } retention Time = file Store . get Default Retention Time ( ) ; boolean read Only = config . contains Key ( _ STR ) ; o = config . get ( _ STR ) ; int mb = o == null ? _ NUM : (  Integer ) o ; if ( mb > _ NUM ) {  Cache Long Key LIRS .  Config cc = new  Cache Long Key LIRS .  Config ( ) ; cc . max Memory = mb * _ NUM * _ NUM ; o = config . get ( _ STR ) ; if ( o != null ) { cc . segment Count = (  Integer ) o ; } cache = new  Cache Long Key LIRS <  Page > ( cc ) ; cc . max Memory /= _ NUM ; cache Chunk Ref = new  Cache Long Key LIRS <  Page Children > ( cc ) ; } o = config . get ( _ STR ) ; int kb = o == null ? _ NUM : (  Integer ) o ; auto Commit Memory = kb * _ NUM * _ NUM ; o = config . get ( _ STR ) ; auto Compact Fill Rate = o == null ? _ NUM : (  Integer ) o ; char [ ] encryption Key = ( char [ ] ) config . get ( _ STR ) ; try { if ( ! file Store Is Provided ) { file Store . open ( file Name , read Only , encryption Key ) ; } if ( file Store . size ( ) == _ NUM ) { creation Time = get Time Absolute ( ) ; last Commit Time = creation Time ; store Header . put ( _ STR , _ NUM ) ; store Header . put ( _ STR ,  BLOCK_ SIZE ) ; store Header . put ( _ STR ,  FORMAT_ WRITE ) ; store Header . put ( _ STR , creation Time ) ; write Store Header ( ) ; } else { read Store Header ( ) ; } } catch (  Illegal State Exception e ) { panic ( e ) ; } finally { if ( encryption Key != null ) {  Arrays . fill ( encryption Key , ( char ) _ NUM ) ; } } last Commit Time = get Time Since Creation ( ) ; o = config . get ( _ STR ) ; int delay = o == null ? _ NUM : (  Integer ) o ; set Auto Commit Delay ( delay ) ; }
public static boolean is Valid Vector (  Vector2f vector ) { if ( vector == null ) return _ BOOL ; if (  Float . is Na N ( vector . x ) ||  Float . is Na N ( vector . y ) ) return _ BOOL ; if (  Float . is Infinite ( vector . x ) ||  Float . is Infinite ( vector . y ) ) return _ BOOL ; return _ BOOL ; }
protected int max Depth (  Layout .  Node node ) { int depth = _ NUM ; for ( int i = _ NUM ; i < node . num Children ( ) ; i ++ ) {  Layout .  Node child = node . get Child ( i ) ; depth =  Math . max ( depth , max Depth ( child ) ) ; } return depth + _ NUM ; }
private static  URL [ ] path To URLs (  String path ) throws  Malformed URLException { synchronized ( path To URLs Cache ) {  Object [ ] v = (  Object [ ] ) path To URLs Cache . get ( path ) ; if ( v != null ) { return (  URL [ ] ) v [ _ NUM ] ; } }  String Tokenizer st = new  String Tokenizer ( path ) ;  URL [ ] urls = new  URL [ st . count Tokens ( ) ] ; for ( int i = _ NUM ; st . has More Tokens ( ) ; i ++ ) { urls [ i ] = new  URL ( st . next Token ( ) ) ; } synchronized ( path To URLs Cache ) { path To URLs Cache . put ( path , new  Object [ ] { urls , new  Soft Reference ( path ) } ) ; } return urls ; }
private void add Final (  Object [ ] stacks ) {  Object [ ] input = new  Object [ input Size ] , output = new  Object [ output Size ] ; for ( int i = _ NUM ; i < stacks . length ; i ++ ) { if ( i < input Size ) { input [ i ] = stacks [ i ] ; } else if ( ! ( i - input Size > output Size ) ) { output [ i - input Size ] = stacks [ i ] ; } else { throw new  Runtime Exception ( _ STR ) ; } } add Recipe ( input , output ) ; }
protected void fire Connection Closed ( ) {  Connection Event evt = new  Connection Event ( this ) ; for (  Connection Event Listener listener : connection Event Listeners ) { listener . connection Closed ( evt ) ; } }
public static void put Int Volatile (  Object obj , long off , int val ) {  UNSAFE . put Int Volatile ( obj , off , val ) ; }
public static  URI create Uri From Server Set (  Set <  Inet Socket Address > server Inet Set ,  String path ,  String protocol ) throws  URISyntax Exception {  Inet Socket Address inet Socket Address =  Service Utils . select Random Item ( server Inet Set ) ;  String address = inet Socket Address . get Host String ( ) ; int port = inet Socket Address . get Port ( ) ;  URI uri = new  URI ( protocol , null , address , port , path , null , null ) ; return uri ; }
public  Plot Navigator (  Plot plot ,  String ... axes Names ) { this ( plot ,  Arrays . as List ( axes Names ) ) ; }
public void add Column (  Class class Type , boolean read Only ,  String header ) { m_model Header Class . add ( class Type ) ; set Column Read Only ( m_model Header Class . size ( ) - _ NUM , read Only ) ; add Column ( header ) ;  WList Item Renderer renderer = (  WList Item Renderer ) get Item Renderer ( ) ; renderer . set Column Class ( ( renderer . get No Columns ( ) - _ NUM ) , class Type ) ; return ; }
Point Comparator ( int dimension ) { this . dimension = dimension ; }
public static void add Element (  Document doc ,  Element root Element ,  String element Name ,  String type In ,  String is Array In ,  String partitioner In ) {  Element element = doc . create Element ( _ STR ) ; root Element . append Child ( element ) ;  Element name = doc . create Element ( _ STR ) ; name . append Child ( doc . create Text Node ( element Name ) ) ; element . append Child ( name ) ;  Element type = doc . create Element ( _ STR ) ; type . append Child ( doc . create Text Node ( type In ) ) ; element . append Child ( type ) ; if ( is Array In . equals ( _ STR ) ) { element . append Child ( doc . create Element ( _ STR ) ) ; } if ( partitioner In != null ) {  Element partitioner = doc . create Element ( _ STR ) ; partitioner . append Child ( doc . create Text Node ( partitioner In ) ) ; element . append Child ( partitioner ) ; } }
public final void add Instance Of (  String class Name ) {  Reject . if Null ( class Name ) ;  String value = class Name . trim ( ) ; if ( ! value . matches (  CLASS_ RE ) ) { throw new  Illegal Argument Exception ( _ STR + value + _ STR ) ; } instance Of Interfaces . add ( value ) ; }
public boolean is Displayed Expecting Components ( ) { boolean result = _ BOOL ; if ( conditions . is Condition Met ( visibility Of ( window ) ) ) { if ( components . is Empty ( ) ) { close Button . click ( ) ; } else { result = _ BOOL ; } } return result ; }
private void process Run Started Tag (  String identifier ) {  Pattern num Tests Pattern =  Pattern . compile ( _ STR ) ;  Matcher num Tests = num Tests Pattern . matcher ( identifier ) ; if ( num Tests . find ( ) ) { try { m Num Tests Expected =  Integer . parse Int ( num Tests . group ( _ NUM ) ) ; } catch (  Number Format Exception e ) {  Log . e (  LOG_ TAG , _ STR + num Tests . group ( _ NUM ) ) ; } } if ( m Num Tests Expected > _ NUM ) { report Test Run Started ( ) ; m Num Tests Run = _ NUM ; m Test Run In Progress = _ BOOL ; } }
public  Styled String insert ( char ch , int offset ) throws  String Index Out Of Bounds Exception { if ( offset < _ NUM || offset > builder . length ( ) ) { throw new  String Index Out Of Bounds Exception ( _ STR + offset + _ STR ) ; } builder . insert ( offset , ch ) ; return this ; }
public void add Root (  Proto Element root ) { roots . add ( root ) ; }
public void expand To Object And Select (  Object element Or Tree Path , int level ) { if ( check Busy ( ) ) { return ; }  Object parent = get Parent Element ( element Or Tree Path ) ; if ( ( ( parent != null ) && get Expanded State ( parent ) ) || is Root Element ( element Or Tree Path ) ) {  Widget w = internal Get Widget To Select ( element Or Tree Path ) ; if ( null != w ) {  List <  Object > selection List = new  Array List < > ( ) ; selection List . add ( w ) ; set Selection ( selection List ) ; object To Select . set ( null ) ; } else { object To Select . set ( element Or Tree Path ) ; } } else { object To Select . set ( element Or Tree Path ) ;  List <  Object > objects To Expand = create Object List ( parent , new  Array List < > ( ) ) ; if ( ! objects To Expand . is Empty ( ) ) { objects To Be Expanded . add All ( objects To Expand ) ;  Widget w = internal Expand ( element Or Tree Path , _ BOOL ) ; if ( w != null ) { internal Expand To Level ( w , level ) ; } } else {  Widget w = internal Get Widget To Select ( element Or Tree Path ) ; if ( null != w ) {  List <  Object > selection List = new  Array List < > ( ) ; selection List . add ( w ) ; set Selection ( selection List ) ; object To Select . set ( null ) ; } } } }
public void append Cell ( float value ) { append Cell (  String . value Of ( value ) ) ; }
public  SVNChange Set Collector (  ISynchronize Page Configuration configuration ) { super ( configuration ) ; }
public void ensure Max Size ( int max Width , int max Height , boolean keep Proportions ) { int width = canvas . get Width ( ) ; int height = canvas . get Height ( ) ; if ( keep Proportions ) { if ( width > height ) { if ( width > max Width ) { height =  Math . round ( height *= max Width / ( double ) width ) ; width = max Width ; } } else { if ( height > max Height ) { width =  Math . round ( width *= max Height / ( double ) height ) ; height = max Height ; } } } else { width =  Math . min ( width , max Width ) ; height =  Math . min ( height , max Height ) ; } resize ( width , height ) ; }
public static boolean is Normalized (  Char Sequence src , java . text .  Normalizer .  Form form , int option ) { return  Normalizer Base . is Normalized ( src . to String ( ) , form , option ) ; }
@  Override public  String to String ( boolean freq ) {  String Buffer result = new  String Buffer ( ) ; result . append ( m_attribute . name ( ) + _ STR ) ; switch ( m_comparison ) { case  EQUAL : result . append ( _ STR ) ; break ; case  LESS_ THAN_ OR_ EQUAL_ TO : result . append ( _ STR ) ; break ; case  GREATER_ THAN : result . append ( _ STR ) ; break ; default : break ; } result . append ( _ STR +  Utils . double To String ( m_split Point , _ NUM ) ) ; if ( freq ) { result . append ( _ STR + m_frequency ) ; } return result . to String ( ) ; }
public static  String unescape Som (  String s ) { int idx = s . index Of ( _ STR ) ; if ( idx < _ NUM ) return s ;  String Builder sb = new  String Builder ( ) ; int last = _ NUM ; while ( idx >= _ NUM ) { sb . append ( s . substring ( last , idx ) ) ; last = idx + _ NUM ; idx = s . index Of ( _ STR , idx + _ NUM ) ; } sb . append ( s . substring ( last ) ) ; return sb . to String ( ) ; }
void save Async (  Column Entity entity ,  Duration ttl ,  Consumer <  Column Entity > call Back ) throws  Execute Async Query Exception ,  Unsupported Operation Exception ;
private static  Copy State read Copy State (  Data Input in ) throws  IOException { byte [ ] infos Bytes = new byte [ in . read VInt ( ) ] ; in . read Bytes ( infos Bytes , _ NUM , infos Bytes . length ) ; long gen = in . read VLong ( ) ; long version = in . read VLong ( ) ;  Map <  String ,  File Meta Data > files =  Copy Files Handler . read Files Meta Data ( in ) ; int count = in . read VInt ( ) ;  Set <  String > completed Merge Files = new  Hash Set < > ( ) ; for ( int i = _ NUM ; i < count ; i ++ ) { completed Merge Files . add ( in . read String ( ) ) ; } long primary Gen = in . read VLong ( ) ; return new  Copy State ( files , version , gen , infos Bytes , completed Merge Files , primary Gen , null ) ; }
private void before Name ( ) throws  IOException {  Json Scope context = peek ( ) ; if ( context ==  Json Scope .  NONEMPTY_ OBJECT ) { out . write ( _ STR ) ; } else if ( context !=  Json Scope .  EMPTY_ OBJECT ) { throw new  Illegal State Exception ( _ STR + stack ) ; } newline ( ) ; replace Top (  Json Scope .  DANGLING_ NAME ) ; }
@  Transactional public void redeem ( final  String token Number , final  String service ) { final  Token token = token Repository . find By Token Number And Service ( token Number , service ) ; if ( token == null ) throw new  Application Runtime Exception ( _ STR + token Number + _ STR ) ; redeem ( token ) ; }
public int lighten Color ( int color , float factor ) { float r =  Color . red ( color ) * factor ; float g =  Color . green ( color ) * factor ; float b =  Color . blue ( color ) * factor ; int ir =  Math . min ( _ NUM , ( int ) r ) ; int ig =  Math . min ( _ NUM , ( int ) g ) ; int ib =  Math . min ( _ NUM , ( int ) b ) ; int ia =  Color . alpha ( color ) ; return (  Color . argb ( ia , ir , ig , ib ) ) ; }
private static  String to Database String ( final  Operand Size size ) { switch ( size ) { case  BYTE : return _ STR ; case  WORD : return _ STR ; case  DWORD : return _ STR ; case  QWORD : return _ STR ; case  OWORD : return _ STR ; case  ADDRESS : return _ STR ; default : throw new  Illegal Argument Exception (  String . format ( _ STR , size ) ) ; } }
static  String file Name Of Class ( final  String class Name ,  String type Suffix ) { return class Name . replace ( _ STR , _ STR ) + _ STR + type Suffix ; }
public void write Pv (  Process Var pv , int recursive Depth ) { write Pv ( pv , recursive Depth , _ BOOL ) ; }
private static void assert Qual NS (  String qual NS ) throws  XMPException { if ( qual NS == null || qual NS . length ( ) == _ NUM ) { throw new  XMPException ( _ STR ,  XMPError .  BADSCHEMA ) ; } }
public static  String Builder format To (  String Builder buf , float [ ] d ,  String sep ,  Number Format nf ) { if ( d == null ) { return buf . append ( _ STR ) ; } if ( d . length == _ NUM ) { return buf ; } buf . append ( nf . format ( d [ _ NUM ] ) ) ; for ( int i = _ NUM ; i < d . length ; i ++ ) { buf . append ( sep ) ; buf . append ( nf . format ( d [ i ] ) ) ; } return buf ; }
public int remove Viewpoints ( int [ ] indices ) { for ( int i = indices . length - _ NUM ; i >= _ NUM ; -- i ) viewpoint List . remove ( indices [ i ] ) ; viewpoint Index = indices [ _ NUM ] - _ NUM ; if ( viewpoint List . size ( ) == _ NUM ) { viewpoint Index = - _ NUM ; } else if ( viewpoint Index < _ NUM ) { viewpoint Index = viewpoint List . size ( ) - _ NUM ; } return ( viewpoint Index ) ; }
private void update Color ( ) { try {  Breakpoint Condition Parser . evaluate ( input Field . get Text ( ) ) ; input Field . set Background (  Color .  WHITE ) ; } catch ( final  Invalid Formula Exception e ) { input Field . set Background (  Color .  RED ) ; } }
public void remove Ignored View (  View v ) { ignored Views . remove ( v ) ; }
public boolean write Header (  Output Stream os ) { try { write Int ( os ,  CACHE_ MAGIC ) ; write String ( os , key ) ; write String ( os , etag == null ? _ STR : etag ) ; write Long ( os , server Date ) ; write Long ( os , last Modified ) ; write Long ( os , ttl ) ; write Long ( os , soft Ttl ) ; write String String Map ( response Headers , os ) ; os . flush ( ) ; return _ BOOL ; } catch (  IOException e ) {  Vinci Log . d ( _ STR , e . to String ( ) ) ; return _ BOOL ; } }
private static boolean ensure Current (  Leased Resource resource ) { return resource . get Expiration ( ) >  System Time . time Millis ( ) ; }
public void toggle Section Selected ( int section Index ) { set Section Selected ( section Index , ! is Section Selected ( section Index ) ) ; }
public  String combine (  List <  String > files ,  String out File ) throws  Exception {  Array List <  String > cmd = new  Array List <  String > ( ) ; cmd . add ( sox Bin ) ; for (  String file : files ) { cmd . add ( file ) ; } cmd . add ( out File ) ; int rc = exec Sox ( cmd , callback ) ; if ( rc != _ NUM ) { throw new  Exception ( _ STR + rc ) ; } return out File ; }
void stop Scrolling Instance ( ) { if ( log . is Loggable (  Platform Logger .  Level .  FINER ) ) { log . finer ( _ STR + this ) ; } i_scroller . stop ( ) ; }
@ edu . umd . cs . findbugs . annotations .  Suppress FBWarnings ( value = _ STR , justification = _ STR ) protected void new Internal Minute ( ) { double orig Current = m Current Intensity ; int orig State = m State ; int steps = get Number Of Steps ( ) ; if ( ( m Transition Duration > _ NUM ) && ( steps > _ NUM ) ) { double steps Per Minute = steps / m Transition Duration ; double step Size = _ NUM / ( double ) steps ; double intensity Diff Per Minute = step Size * steps Per Minute ; if (  Math . abs ( m Current Intensity - m Transition Target Intensity ) != _ NUM ) { if ( log . is Debug Enabled ( ) ) { log . debug ( _ STR + m Transition Target Intensity + _ STR + m Current Intensity ) ; } if ( m Transition Target Intensity > m Current Intensity ) { m Current Intensity = m Current Intensity + intensity Diff Per Minute ; if ( m Current Intensity >= m Transition Target Intensity ) { m Current Intensity = m Transition Target Intensity ; if ( m Current Intensity >= get Max Intensity ( ) ) { m State =  ON ; } else { m State =  INTERMEDIATE ; } } } else { m Current Intensity = m Current Intensity - intensity Diff Per Minute ; if ( m Current Intensity <= m Transition Target Intensity ) { m Current Intensity = m Transition Target Intensity ; if ( m Current Intensity <= get Min Intensity ( ) ) { m State =  OFF ; } else { m State =  INTERMEDIATE ; } } } send Intensity ( m Current Intensity ) ; if ( log . is Debug Enabled ( ) ) { log . debug ( _ STR + m Transition Target Intensity + _ STR + m Current Intensity ) ; } } } if ( orig Current != m Current Intensity ) { fire Property Change ( _ STR ,  Double . value Of ( orig Current ) ,  Double . value Of ( m Current Intensity ) ) ; if ( log . is Debug Enabled ( ) ) { log . debug ( _ STR + orig Current + _ STR + m Current Intensity ) ; } } if ( orig State != m State ) { fire Property Change ( _ STR ,  Integer . value Of ( orig State ) ,  Integer . value Of ( m State ) ) ; if ( log . is Debug Enabled ( ) ) { log . debug ( _ STR + orig Current + _ STR + m Current Intensity ) ; } } }
public void execute2 (  Kahan Object in1 , double in2 ) { if (  Double . is Infinite ( in1 . _sum ) ||  Double . is Infinite ( in2 ) ) { in1 . set (  Double . is Infinite ( in2 ) ? in2 : in1 . _sum , _ NUM ) ; return ; } double correction = in2 + in1 . _correction ; double sum = in1 . _sum + correction ; in1 . set ( sum , correction - ( sum - in1 . _sum ) ) ; }
public static  Response new Fixed Length Response (  String msg ) { return new Fixed Length Response (  Status .  OK ,  Nano HTTPD .  MIME_ HTML , msg ) ; }
@  Override public  XMLEvent peek ( ) throws  XMLStream Exception { log . log (  Level .  FINE , _ STR ) ; if ( ! has Next ( ) ) { throw new  XMLStream Exception ( _ STR ) ; } log . log (  Level .  FINE , _ STR , next Event ) ; return next Event ; }
public static  String replace End Point (  String url ,  String end Point ) { return end Point + url . replace First (  DEFAULT_ ENDPOINT , _ STR ) ; }
public static double length ( double x , double y , double z ) { return  Math . sqrt ( x * x + y * y + z * z ) ; }
private void make Ok Path ( ) { path1 . reset ( ) ; int w2 = get Measured Width ( ) / _ NUM ; int h2 = get Measured Height ( ) / _ NUM ; double a =  Math . cos (  Math . to Radians ( _ NUM ) ) * get Radius ( ) ; double c =  Math . sin (  Math . to Radians ( _ NUM ) ) * get Radius ( ) ; double l =  Math . cos (  Math . to Radians ( _ NUM ) ) * _ NUM * a ; double b =  Math . sin (  Math . to Radians ( _ NUM ) ) * l ; double m =  Math . cos (  Math . to Radians ( _ NUM ) ) * l ; path1 . move To ( ( float ) ( w2 - a ) , ( float ) ( h2 - c ) ) ; path1 . line To ( ( float ) ( w2 - a + m ) , ( float ) ( h2 - c +  Math . sin (  Math . to Radians ( _ NUM ) ) * l ) ) ; path1 . line To ( ( float ) ( w2 + a ) , ( float ) ( h2 - c ) ) ; path Measure1 . set Path ( path1 , _ BOOL ) ; m Mark Oklength = path Measure1 . get Length ( ) ; }
private static void _trust All Https Certificates ( ) {  SSLContext context ; if ( _trust Managers == null ) { _trust Managers = new  Trust Manager [ ] { new  Fake X509 Trust Manager ( ) } ; } try { context =  SSLContext . get Instance ( _ STR ) ; context . init ( null , _trust Managers , new  Secure Random ( ) ) ; } catch (  General Security Exception gse ) { throw new  Illegal State Exception ( gse . get Message ( ) ) ; }  Https URLConnection . set Default SSLSocket Factory ( context . get Socket Factory ( ) ) ; }
protected  List <  String > add Whitespace (  List <  String > list ) {  List <  String > whitespace List = new  Array List < > ( ) ; for (  String value : list ) { whitespace List . add ( add Whitespace ( value ) ) ; } return whitespace List ; }
public static  String compute Qualified Widget Type Name (  Node widget Node ) { if ( widget Node . get Node Type ( ) !=  Node .  ELEMENT_ NODE ) { return null ; }  String type Name = widget Node . get Local Name ( ) ; if ( type Name . length ( ) == _ NUM ||  Character . is Lower Case ( type Name . char At ( _ NUM ) ) ) { return null ; }  String package Name =  Ui Binder Utilities . get Package Name ( widget Node . get Namespace URI ( ) ) ; return package Name != null ?  Java Utilities . get Qualified Type Name ( type Name , package Name ) : null ; }
private static boolean process Ftyp Atom (  Parsable Byte Array atom Data ) { atom Data . set Position (  Atom .  HEADER_ SIZE ) ; int major Brand = atom Data . read Int ( ) ; if ( major Brand ==  BRAND_ QUICKTIME ) { return _ BOOL ; } atom Data . skip Bytes ( _ NUM ) ; while ( atom Data . bytes Left ( ) > _ NUM ) { if ( atom Data . read Int ( ) ==  BRAND_ QUICKTIME ) { return _ BOOL ; } } return _ BOOL ; }
public  String delete (  String url , final int expected Status Code ) { return delete ( url ,  Collections . <  String ,  String > empty Map ( ) , expected Status Code ) ; }
protected void running Sum (  Set <  Map .  Entry <  Double ,  Double > > c , double value , double [ ] sums ) { double offset =  CONST -  Math . log ( m_ Width ) ; double log Factor =  Math . log ( m_ Threshold ) -  Math . log ( _ NUM - m_ Threshold ) ; double log Sum Of Weights =  Math . log ( m_ Sum Of Weights ) ;  Iterator <  Map .  Entry <  Double ,  Double > > itr = c . iterator ( ) ; while ( itr . has Next ( ) ) {  Map .  Entry <  Double ,  Double > entry = itr . next ( ) ; if ( entry . get Value ( ) > _ NUM ) { double diff = ( entry . get Key ( ) - value ) / m_ Width ; double log Density = offset - _ NUM * diff * diff ; double log Weight =  Math . log ( entry . get Value ( ) ) ; sums [ _ NUM ] = log Of Sum ( sums [ _ NUM ] , log Weight + log Density ) ; sums [ _ NUM ] = log Of Sum ( sums [ _ NUM ] , log Weight ) ; if ( log Density + log Sum Of Weights < log Of Sum ( log Factor + sums [ _ NUM ] , log Density + sums [ _ NUM ] ) ) { break ; } } } }
@  Override public  Categorical Table copy ( ) {  Map <  Value ,  Double > new Table = new  Hash Map <  Value ,  Double > ( ) ; for (  Value v : table . key Set ( ) ) { new Table . put ( v , table . get ( v ) ) ; } return new  Categorical Table ( variable , new Table ) ; }
public  Configuration sub Config (  String prefix ,  String key Prefix ) {  Configuration sub = new  Configuration ( ) ; add To Sub Conf ( sub , prefix . length ( ) > _ NUM ? prefix + _ STR + key Prefix : key Prefix ) ; return sub ; }
public  Map <  String ,  String > map Name To Display Name (  Set <  String > names ) throws  SMSException ,  SSOException { final  Map <  String ,  String > map = new  Hash Map < > ( names . size ( ) ) ; for (  String name : names ) { if ( sms Console Service Config . is Service Visible ( name ) ) { final  Service Schema Manager service Schema Manager = service Schema Manager Factory . build ( name ) ;  String display Name = get Localized Service Name ( service Schema Manager , name ) ;  String resource Name = service Schema Manager . get Resource Name ( ) ; if ( ! name . equals ( display Name ) && !  String Utils . is Blank ( resource Name ) ) { map . put ( resource Name , display Name ) ; } } } return map ; }
@  Override public  String to String ( ) { return _ STR + get Id ( ) ; }
public static final boolean execute Potential Work ( final  Object data , final  Image View image View ) { final  Bitmap Worker Task bitmap Worker Task = get Bitmap Worker Task ( image View ) ; if ( bitmap Worker Task != null ) { final  Object bitmap Data = bitmap Worker Task . m Key ; if ( bitmap Data == null || ! bitmap Data . equals ( data ) ) { bitmap Worker Task . cancel ( _ BOOL ) ; } else { return _ BOOL ; } } return _ BOOL ; }
public static void queue Bitmap (  String key ,  Bitmap bmp ) { m Bitmap Queue . put ( key , bmp ) ; }
public void add Listener (  After Server Start Listener listener ) { _after Start Listeners . add ( listener ) ; }
private int make Available ( ) throws  IOException { if ( pos != - _ NUM ) { return _ NUM ; } total += tail - head - pad ;  System . arraycopy ( buffer , tail - pad , buffer , _ NUM , pad ) ; head = _ NUM ; tail = pad ; for ( ; ; ) { int bytes Read = input . read ( buffer , tail , buf Size - tail ) ; if ( bytes Read == - _ NUM ) { final  String msg = _ STR ; throw new  File Upload Exception (  Malformed Stream Exception , msg ) ; } tail += bytes Read ; find Separator ( ) ; int av = available ( ) ; if ( av > _ NUM || pos != - _ NUM ) { return av ; } } }
public  Relation Notification (  String notif Type ,  Object source Obj , long sequence , long time Stamp ,  String message ,  String id ,  String type Name ,  Object Name object Name ,  List <  Object Name > unreg MBean List ) throws  Illegal Argument Exception { super ( notif Type , source Obj , sequence , time Stamp , message ) ; if ( ! is Valid Basic Strict ( notif Type , source Obj , id , type Name ) || ! is Valid Create ( notif Type ) ) { throw new  Illegal Argument Exception ( _ STR ) ; } relation Id = id ; relation Type Name = type Name ; relation Obj Name = safe Get Object Name ( object Name ) ; unregister MBean List = safe Get Object Name List ( unreg MBean List ) ; }
public boolean local Host Or Domain Is (  String host ,  String domain ) { return domain . starts With ( host ) ; }
protected double entropy ( double [ ] [ ] data Zs , double [ ] [ ] data Ws ) { double entropy = _ NUM ; int num Instances = data Zs . length ; for ( int j = _ NUM ; j < m_num Classes ; j ++ ) { double m = _ NUM ; double sum = _ NUM ; for ( int i = _ NUM ; i < num Instances ; i ++ ) { m += data Zs [ i ] [ j ] * data Ws [ i ] [ j ] ; sum += data Ws [ i ] [ j ] ; } m /= sum ; for ( int i = _ NUM ; i < num Instances ; i ++ ) { entropy += data Ws [ i ] [ j ] *  Math . pow ( data Zs [ i ] [ j ] - m , _ NUM ) ; } } return entropy ; }
protected void write Distribution (  Parameter parameter , boolean is Ref ,  XMLWriter writer ) { switch ( parameter . prior Type ) { case  UNIFORM_ PRIOR :  String id = parameter . taxa Id + _ STR ; if ( is Ref ) { writer . write IDref (  Uniform Distribution Model Parser .  UNIFORM_ DISTRIBUTION_ MODEL , id ) ; } else { writer . write Open Tag (  Uniform Distribution Model Parser .  UNIFORM_ DISTRIBUTION_ MODEL , new  Attribute [ ] { new  Attribute .  Default <  String > (  XMLParser .  ID , id ) } ) ; writer . write Open Tag (  Uniform Distribution Model Parser .  LOWER ) ; writer . write Text (  Double . to String ( parameter . uniform Lower ) ) ; writer . write Close Tag (  Uniform Distribution Model Parser .  LOWER ) ; writer . write Open Tag (  Uniform Distribution Model Parser .  UPPER ) ; writer . write Text (  Double . to String ( parameter . uniform Upper ) ) ; writer . write Close Tag (  Uniform Distribution Model Parser .  UPPER ) ; writer . write Close Tag (  Uniform Distribution Model Parser .  UNIFORM_ DISTRIBUTION_ MODEL ) ; } break ; case  EXPONENTIAL_ PRIOR : writer . write Open Tag (  Exponential Distribution Model .  EXPONENTIAL_ DISTRIBUTION_ MODEL ) ; writer . write Open Tag (  Distribution Model Parser .  MEAN ) ; writer . write Text (  Double . to String ( parameter . mean ) ) ; writer . write Close Tag (  Distribution Model Parser .  MEAN ) ; writer . write Open Tag (  Distribution Model Parser .  OFFSET ) ; writer . write Text (  Double . to String ( parameter . offset ) ) ; writer . write Close Tag (  Distribution Model Parser .  OFFSET ) ; writer . write Close Tag (  Exponential Distribution Model .  EXPONENTIAL_ DISTRIBUTION_ MODEL ) ; break ; case  NORMAL_ PRIOR : writer . write Open Tag (  Normal Distribution Model Parser .  NORMAL_ DISTRIBUTION_ MODEL ) ; writer . write Open Tag (  Normal Distribution Model Parser .  MEAN ) ; writer . write Text (  Double . to String ( parameter . mean ) ) ; writer . write Close Tag (  Normal Distribution Model Parser .  MEAN ) ; writer . write Open Tag (  Normal Distribution Model Parser .  STDEV ) ; writer . write Text (  Double . to String ( parameter . stdev ) ) ; writer . write Close Tag (  Normal Distribution Model Parser .  STDEV ) ; writer . write Close Tag (  Normal Distribution Model Parser .  NORMAL_ DISTRIBUTION_ MODEL ) ; break ; case  LOGNORMAL_ PRIOR : writer . write Open Tag (  Log Normal Distribution Model Parser .  LOGNORMAL_ DISTRIBUTION_ MODEL , new  Attribute [ ] { new  Attribute .  Default <  Boolean > (  Log Normal Distribution Model Parser .  MEAN_ IN_ REAL_ SPACE , parameter . is Mean In Real Space ( ) ) , new  Attribute .  Default <  Boolean > (  Log Normal Distribution Model Parser .  STDEV_ IN_ REAL_ SPACE , parameter . is Mean In Real Space ( ) ) } ) ; writer . write Open Tag (  Log Normal Distribution Model Parser .  MEAN ) ; writer . write Text (  Double . to String ( parameter . mean ) ) ; writer . write Close Tag (  Log Normal Distribution Model Parser .  MEAN ) ; writer . write Open Tag (  Log Normal Distribution Model Parser .  STDEV ) ; writer . write Text (  Double . to String ( parameter . stdev ) ) ; writer . write Close Tag (  Log Normal Distribution Model Parser .  STDEV ) ; writer . write Open Tag (  Log Normal Distribution Model Parser .  OFFSET ) ; writer . write Text (  Double . to String ( parameter . offset ) ) ; writer . write Close Tag (  Log Normal Distribution Model Parser .  OFFSET ) ; writer . write Close Tag (  Log Normal Distribution Model Parser .  LOGNORMAL_ DISTRIBUTION_ MODEL ) ; break ; case  GAMMA_ PRIOR : writer . write Open Tag (  Gamma Distribution Model .  GAMMA_ DISTRIBUTION_ MODEL ) ; writer . write Open Tag (  Distribution Model Parser .  SHAPE ) ; writer . write Text (  Double . to String ( parameter . shape ) ) ; writer . write Close Tag (  Distribution Model Parser .  SHAPE ) ; writer . write Open Tag (  Distribution Model Parser .  SCALE ) ; writer . write Text (  Double . to String ( parameter . scale ) ) ; writer . write Close Tag (  Distribution Model Parser .  SCALE ) ; writer . write Open Tag (  Distribution Model Parser .  OFFSET ) ; writer . write Text (  Double . to String ( parameter . offset ) ) ; writer . write Close Tag (  Distribution Model Parser .  OFFSET ) ; writer . write Close Tag (  Gamma Distribution Model .  GAMMA_ DISTRIBUTION_ MODEL ) ; break ; default : throw new  Illegal Argument Exception ( _ STR + parameter . get Name ( ) ) ; } }
public void save Working Instances To File Q ( ) { if ( m_ IOThread == null ) { m_ File Chooser . set Capabilities Filter ( m_ Filter Editor . get Capabilities Filter ( ) ) ; m_ File Chooser . set Accept All File Filter Used ( _ BOOL ) ; int return Val = m_ File Chooser . show Save Dialog ( this ) ; if ( return Val ==  JFile Chooser .  APPROVE_ OPTION ) {  Instances inst = new  Instances ( m_ Instances ) ; inst . set Class Index ( m_ Att Visualize Panel . get Coloring Index ( ) ) ; save Instances To File ( m_ File Chooser . get Saver ( ) , inst ) ; }  File Filter temp = m_ File Chooser . get File Filter ( ) ; m_ File Chooser . set Accept All File Filter Used ( _ BOOL ) ; m_ File Chooser . set File Filter ( temp ) ; } else {  JOption Pane . show Message Dialog ( this , _ STR + _ STR , _ STR ,  JOption Pane .  WARNING_ MESSAGE ) ; } }
public int read ( char cbuf [ ] , int off , int len ) throws  IOException { if ( ( off < _ NUM ) || ( off > cbuf . length ) || ( len < _ NUM ) || ( ( off + len ) > cbuf . length ) || ( ( off + len ) < _ NUM ) ) throw new  Index Out Of Bounds Exception ( ) ; if ( len == _ NUM ) return _ NUM ; if ( next >= length ) return - _ NUM ; int n =  Math . min ( length - next , len ) ; text . get Chars ( next , next + n , cbuf , off ) ; next += n ; return n ; }
private boolean adjust Indent ( ) {  Alignment Impl alignment =  Core Formatter Util . get Alignment ( my Current Block ) ;  White Space white Space = my Current Block . get White Space ( ) ; if ( alignment == null || my Alignments To Skip . contains ( alignment ) ) { if ( white Space . contains Line Feeds ( ) ) { adjust Spacing By Indent Offset ( ) ; } else { white Space . arrange Spaces ( my Current Block . get Space Property ( ) ) ; } return _ BOOL ; }  Block Alignment Processor alignment Processor =  ALIGNMENT_ PROCESSORS . get ( alignment . get Anchor ( ) ) ; if ( alignment Processor == null ) {  LOG . error (  String . format ( _ STR , alignment . get Anchor ( ) ) ) ; return _ BOOL ; }  Block Alignment Processor .  Context context = new  Block Alignment Processor .  Context ( my Document , alignment , my Current Block , my Alignment Mappings , my Backward Shifted Aligned Blocks , get Indent Options To Use ( my Current Block , my Default Indent Option ) , my Right Margin ) ;  Block Alignment Processor .  Result result = alignment Processor . apply Alignment ( context ) ; final  Leaf Block Wrapper offset Responsible Block = alignment . get Offset Resp Block Before ( my Current Block ) ; switch ( result ) { case  TARGET_ BLOCK_ PROCESSED_ NOT_ ALIGNED : return _ BOOL ; case  TARGET_ BLOCK_ ALIGNED : store Alignment Mapping ( ) ; return _ BOOL ; case  BACKWARD_ BLOCK_ ALIGNED : if ( offset Responsible Block == null ) { return _ BOOL ; }  Set <  Leaf Block Wrapper > blocks Caused Realignment = new  Hash Set <  Leaf Block Wrapper > ( ) ; my Backward Shifted Aligned Blocks . clear ( ) ; my Backward Shifted Aligned Blocks . put ( offset Responsible Block , blocks Caused Realignment ) ; blocks Caused Realignment . add ( my Current Block ) ; store Alignment Mapping ( my Current Block , offset Responsible Block ) ; my Current Block = offset Responsible Block . get Next Block ( ) ; on Current Line Changed ( ) ; return _ BOOL ; case  RECURSION_ DETECTED : my Current Block = offset Responsible Block ; case  UNABLE_ TO_ ALIGN_ BACKWARD_ BLOCK : my Alignments To Skip . add ( alignment ) ; return _ BOOL ; default : return _ BOOL ; } }
@  Override public void append Code (  Type declaring Type ,  Type Tuple input Types ,  Type output Type ,  List <  Variable > input Vars ,  String Builder b ) { b . append ( field . to Code ( declaring Type , input Vars ) ) ; }
public  Forward Planner (  Dialogue System system ) { this . system = system ; }
private  JButton add Button (  String text ,  Container container , float alignment ) {  JButton button = new  JButton ( text ) ; button . set Alignment X ( alignment ) ; container . add ( button ) ; return button ; }
private boolean no Match For Tag In Attributes (  Attribute Set attr ,  HTML .  Tag t ,  Object tag Value ) { if ( attr != null && attr . is Defined ( t ) ) {  Object new Value = attr . get Attribute ( t ) ; if ( ( tag Value == null ) ? ( new Value == null ) : ( new Value != null && tag Value . equals ( new Value ) ) ) { return _ BOOL ; } } return _ BOOL ; }
public  String business Object Data Key To String (  Business Object Data Key business Object Data Key ) { if ( business Object Data Key == null ) { return null ; } return business Object Data Key To String ( business Object Data Key . get Namespace ( ) , business Object Data Key . get Business Object Definition Name ( ) , business Object Data Key . get Business Object Format Usage ( ) , business Object Data Key . get Business Object Format File Type ( ) , business Object Data Key . get Business Object Format Version ( ) , business Object Data Key . get Partition Value ( ) , business Object Data Key . get Sub Partition Values ( ) , business Object Data Key . get Business Object Data Version ( ) ) ; }
private  Usage create Talk Usage (  Context context ) { if ( talk Usage != null ) { return talk Usage ; }  Type Token <  List <  Usage > > token = new  Type Token <  List <  Usage > > ( ) { } ;  List <  Usage > init Talk IO =  Json Utils . parse Json File ( context , _ STR , token ) ; talk Usage = init Talk IO . get ( _ NUM ) ; return talk Usage ; }
@  Nullable public  Gr Call enclosing Call (  String name ,  Gdsl Members Holder Consumer consumer ) { final  Psi Element place = consumer . get Place ( ) ; if ( place == null ) return null ;  Gr Call call =  Psi Tree Util . get Parent Of Type ( place ,  Gr Call . class , _ BOOL ) ; if ( call == null ) return null ; while ( call != null && ! name . equals ( get Invoked Method Name ( call ) ) ) { call =  Psi Tree Util . get Parent Of Type ( call ,  Gr Call . class , _ BOOL ) ; } if ( call == null ) return null ; final  Gr Argument List argument List = call . get Argument List ( ) ; if ( argument List != null ) { for (  Gr Expression arg : argument List . get Expression Arguments ( ) ) { if ( arg instanceof  Gr Closable Block &&  Psi Tree Util . find Common Parent ( place , arg ) == arg ) { return call ; } } } if ( call instanceof  Gr Method Call Expression ) { for (  Gr Expression arg : call . get Closure Arguments ( ) ) { if ( arg instanceof  Gr Closable Block &&  Psi Tree Util . find Common Parent ( place , arg ) == arg ) { return call ; } } } return null ; }
public static void gen Ovfenv Iso Image (  String ovfenv Prop KVStr ,  String iso File Path ) { byte [ ] b Ovfenv Prop KVStr = ovfenv Prop KVStr . get Bytes ( ) ;  String prop File Path = _ STR ;  File prop File = new  File ( prop File Path ) ; try {  File Utils . write Plain File ( prop File Path , b Ovfenv Prop KVStr ) ; } catch (  Exception e1 ) { prop File . delete ( ) ; log . error ( _ STR , e1 . get Message ( ) ) ; throw new  Illegal State Exception ( _ STR ) ; } try {  File iso File = new  File ( iso File Path ) ;  String [ ] gen ISOImage Command = {  GENISO_ CMD , _ STR , _ STR , _ STR , prop File Path , _ STR , iso File Path , _ STR , _ STR } ;  Exec .  Result result =  Exec . sudo (  CMD_ TIMEOUT , gen ISOImage Command ) ; if ( ! result . exited Normally ( ) || result . get Exit Value ( ) != _ NUM ) { log . error ( _ STR , result . get Exit Value ( ) , result . get Std Error ( ) ) ; throw new  Illegal State Exception ( _ STR ) ; } } catch (  Exception e ) { throw e ; } finally { prop File . delete ( ) ; } }
public static void create Actionable Event (  Db Client db Client ,  Event Utils .  Event Code event Code ,  URI tenant ,  String name ,  String description ,  String warning ,  Data Object resource ,  List <  URI > affected Resources ,  String approve Method ,  Object [ ] approve Parameters ) { create Actionable Event ( db Client , event Code , tenant , name , description , warning , resource , affected Resources , approve Method , approve Parameters , null , null ) ; }
public  Rational (  Byte Provider byte Provider ) throws  IOException {  MXFProperty Populator . populate Field ( byte Provider , this , _ STR ) ;  MXFProperty Populator . populate Field ( byte Provider , this , _ STR ) ; }
public synchronized void remove Notifications (  String type ) throws  Instance Not Found Exception {  Vector <  Integer > v = get Notification IDs ( type ) ; if ( v . is Empty ( ) ) throw new  Instance Not Found Exception ( _ STR ) ; for (  Integer i : v ) remove Notification ( i ) ; }
private void unify Via Atom (  Atomic parent Atom ) {  Atomic child Atom = get Rule Conclusion Atom ( ) ;  Query parent = parent Atom . get Parent Query ( ) ;  Map <  String ,  String > unifiers = child Atom . get Unifiers ( parent Atom ) ; head . unify ( unifiers ) ; body . unify ( unifiers ) ;  Set <  String > child FVs = body . get Var Set ( ) ;  Set <  String > parent BVs = parent Atom . get Var Names ( ) ;  Set <  String > parent Vars = parent . get Var Set ( ) ; parent BVs . for Each ( null ) ; child FVs . for Each ( null ) ; }
static void add Uuid (  Ssf Node node ,  UUID uuid ) { node . set ( _ STR , uuid . get Most Significant Bits ( ) ) ; node . set ( _ STR , uuid . get Least Significant Bits ( ) ) ; }
public  Flux Concat Array <  T > concat Additional Source First (  Publisher < ? extends  T > source ) { int n = array . length ; @  Suppress Warnings ( _ STR )  Publisher < ? extends  T > [ ] new Array = new  Publisher [ n + _ NUM ] ;  System . arraycopy ( array , _ NUM , new Array , _ NUM , n ) ; new Array [ _ NUM ] = source ; return new  Flux Concat Array < > ( delay Error , new Array ) ; }
public void shutdown ( ) { shutdown Server Thread ( ) ; shutdown Sessions ( ) ; }
private boolean is Local Id (  String local Id ) { if ( ! local Id . starts With ( _ STR ) ) { return _ BOOL ; } for ( int i = _ NUM ; i < local Id . length ( ) ; ++ i ) { char c = local Id . char At ( i ) ; if ( ! ( c >= _ STR && c <= _ STR ) && ! ( c >= _ STR && c <= _ STR ) ) { return _ BOOL ; } } return _ BOOL ; }
public  Server Socket Bar bind (  Server Socket Bar ss ) throws  Config Exception ,  IOException { synchronized ( _ssl Init Lock ) { if ( _std Server Socket != null ) throw new  Config Exception (  L . l ( _ STR ) ) ; try { init Config ( ) ; } catch (  Runtime Exception e ) { e . print Stack Trace ( ) ; throw e ; } _std Server Socket = ss ; init SSL ( ) ; return this ; } }
private void reset Output Builders ( ) { ansi =  Ansi . ansi ( ) ; string Builder = new  String Builder ( ) ; }
public  String read (  Byte Buffer buf ,  Dictionary Cache dict ) {  String Builder out = new  String Builder ( ) ; if ( pre != null ) out . append ( pre ) ; if ( type ==  VOID ) return out . to String ( ) ; if ( type ==  NULL ) { out . append ( _ STR ) ; return out . to String ( ) ; } if ( type ==  BYTE ) { out . append ( buf . get ( ) ) ; return out . to String ( ) ; } if ( type ==  SHORT ) { out . append ( buf . get Short ( ) ) ; return out . to String ( ) ; } if ( type ==  INT ) { out . append ( buf . get Int ( ) ) ; return out . to String ( ) ; } if ( type ==  LONG ) { out . append ( buf . get Long ( ) ) ; return out . to String ( ) ; } if ( type ==  DOUBLE ) { out . append ( buf . get Double ( ) ) ; return out . to String ( ) ; } if ( type ==  BOOLEAN ) { out . append ( ( buf . get ( ) == _ NUM ? _ STR : _ STR ) ) ; return out . to String ( ) ; } if ( type ==  STRING ) { short pos = buf . get Short ( ) ; if ( pos > - _ NUM ) { out . append ( _ STR ) ; out . append ( dict . get ( pos ) ) ; out . append ( _ STR ) ; } else { int size = _ NUM ; int val = buf . get ( ) & _ NUM ; while ( val == _ NUM ) { size += val ; val = buf . get ( ) & _ NUM ; } size += val ; byte [ ] data = new byte [ size ] ; buf . get ( data ) ; out . append ( _ STR ) ; out . append ( new  String ( data ,  Standard Charsets .  UTF_8 ) ) ; out . append ( _ STR ) ; } return out . to String ( ) ; } return null ; }
public void write (  String filename ) { logger . info ( _ STR ) ; try { open File ( filename ) ; write Xml Head ( ) ; start Carriers ( this . writer ) ; for (  Carrier carrier : carriers ) { start Carrier ( carrier , this . writer ) ; write Vehicles ( carrier , this . writer ) ; write Shipments ( carrier , this . writer ) ; write Plans ( carrier , this . writer ) ; end Carrier ( this . writer ) ; } end Carriers ( this . writer ) ; close ( ) ; logger . info ( _ STR ) ; } catch (  IOException e ) { e . print Stack Trace ( ) ; logger . error ( e ) ;  System . exit ( _ NUM ) ; } }
public void remove Resource Listener (  Resource Events Listener listener ) { resource Listeners . remove ( listener ) ; }
public void test Has Main Activity ( ) throws  Exception { m Enabled . add (  Launcher Activity Detector .  ISSUE_ MORE_ THAN_ ONE_ LAUNCHER ) ; m Enabled . add (  Launcher Activity Detector .  ISSUE_ MISSING_ LAUNCHER ) ; m Enabled . add (  Launcher Activity Detector .  ISSUE_ LAUNCHER_ ACTIVITY_ IN_ LIBRARY ) ;  String expected = _ STR ;  String result = lint Project ( xml (  FN_ ANDROID_ MANIFEST_ XML , _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR + _ STR ) ) ; assert Equals ( expected , result ) ; }
protected void write Header (  Random Access File file , int size ) throws  IOException {  String str ; int offset = _ NUM ; byte [ ] buffer = new byte [ _ NUM ] ; str =  Integer . to String ( get Size ( ) ) ; for ( int i = _ NUM ; i < ( _ NUM - str . length ( ) ) ; i ++ ) { buffer [ i ] = ( byte ) _ STR ; } offset += ( _ NUM - str . length ( ) ) ; for ( int i = _ NUM ; i < str . length ( ) ; i ++ ) { buffer [ i + offset ] = ( byte ) str . char At ( i ) ; } file . write ( buffer ) ; }
public  String build Java Vendor ( ) { return properties . get Property ( _ STR ) ; }
final void treeify (  Node <  K ,  V > [ ] tab ) {  Tree Node <  K ,  V > root = null ; for (  Tree Node <  K ,  V > x = this , next ; x != null ; x = next ) { next = (  Tree Node <  K ,  V > ) x . next ; x . left = x . right = null ; if ( root == null ) { x . parent = null ; x . red = _ BOOL ; root = x ; } else {  K k = x . key ; int h = x . hash ;  Class < ? > kc = null ; for (  Tree Node <  K ,  V > p = root ; ; ) { int dir , ph ;  K pk = p . key ; if ( ( ph = p . hash ) > h ) dir = - _ NUM ; else if ( ph < h ) dir = _ NUM ; else if ( ( kc == null && ( kc = comparable Class For ( k ) ) == null ) || ( dir = compare Comparables ( kc , k , pk ) ) == _ NUM ) dir = tie Break Order ( k , pk ) ;  Tree Node <  K ,  V > xp = p ; if ( ( p = ( dir <= _ NUM ) ? p . left : p . right ) == null ) { x . parent = xp ; if ( dir <= _ NUM ) xp . left = x ; else xp . right = x ; root = balance Insertion ( root , x ) ; break ; } } } } move Root To Front ( tab , root ) ; }
private void add Category To Tree (  Default Mutable Tree Node node ,  String [ ] names ) { if ( names . length == _ NUM ) { return ; } boolean matched = _ BOOL ; for ( @  Suppress Warnings ( _ STR )  Enumeration <  Default Mutable Tree Node > e = node . children ( ) ; e . has More Elements ( ) ; ) {  Default Mutable Tree Node child Node = e . next Element ( ) ;  String node Name = (  String ) child Node . get User Object ( ) ; if ( node Name . equals ( names [ _ NUM ] ) ) { if ( names . length > _ NUM ) { add Category To Tree ( child Node ,  Arrays . copy Of Range ( names , _ NUM , names . length ) ) ; matched = _ BOOL ; } else { } } } if ( ! matched ) {  Default Mutable Tree Node root = node ; for ( int i = _ NUM ; i < names . length ; i ++ ) {  Default Mutable Tree Node new Node = new  Default Mutable Tree Node ( names [ i ] ) ; root . add ( new Node ) ; root = new Node ; } } }
private void edit Note ( int note Id ) { hide Soft Keyboard ( ) ;  Intent intent = new  Intent (  Main Activity . this ,  Note Activity . class ) ; intent . set Flags (  Intent .  FLAG_ ACTIVITY_ CLEAR_ TASK ) ; intent . put Extra ( _ STR ,  String . value Of ( note Id ) ) ; start Activity ( intent ) ; }
public final  Entry add Entry (  Position input Position ,  Position output Position ) {  Entry entry = new  Entry ( input Position , output Position ) ; entries . add ( entry ) ; return entry ; }
public void un Hide Action Bar (  View view ) { if ( toolbar Auto Hider != null ) toolbar Auto Hider . show Component ( ) ; }
public static  String format Time Delta ( long time ,  Char Sequence sep ) { final  String Builder sb = new  String Builder ( ) ; final  Formatter fmt = new  Formatter ( sb ) ; for ( int i =  TIME_ UNIT_ SIZES . length - _ NUM ; i >= _ NUM ; -- i ) { if ( i == _ NUM && sb . length ( ) > _ NUM ) { continue ; } if ( sb . length ( ) > _ NUM ) { sb . append ( sep ) ; } final long ac Value = time /  TIME_ UNIT_ SIZES [ i ] ; time = time %  TIME_ UNIT_ SIZES [ i ] ; if ( ! ( ac Value == _ NUM && sb . length ( ) == _ NUM ) ) { fmt . format ( _ STR +  TIME_ UNIT_ DIGITS [ i ] + _ STR ,  Long . value Of ( ac Value ) ,  TIME_ UNIT_ NAMES [ i ] ) ; } } fmt . close ( ) ; return sb . to String ( ) ; }
public void run ( ) {  Log . d (  LOG , _ STR + sample Rate + _ STR + channels + _ STR + buffer Size In Bytes + _ STR + buffer Size In Ms + _ STR ) ; is Playing = _ BOOL ;  Audio Track atrack = null ; try { atrack = new  Audio Track (  Audio Manager .  STREAM_ MUSIC , sample Rate , channels == _ NUM ?  Audio Format .  CHANNEL_ CONFIGURATION_ MONO :  Audio Format .  CHANNEL_ CONFIGURATION_ STEREO ,  Audio Format .  ENCODING_ PCM_16 BIT , buffer Size In Bytes ,  Audio Track .  MODE_ STREAM ) ; atrack . set Playback Position Update Listener ( this ) ; atrack . set Position Notification Period ( ms To Samples ( _ NUM , sample Rate , channels ) ) ; if ( player Callback != null ) player Callback . player Audio Track Created ( atrack ) ; this . audio Track = atrack ; } catch (  Throwable t ) {  Log . e (  LOG , _ STR + t ) ; stop ( ) ; if ( player Callback != null ) player Callback . player Exception ( t ) ; } while ( ! stopped ) { int ln = acquire Samples ( ) ; if ( stopped || ln == _ NUM ) { release Samples ( ) ; break ; } int written Now = _ NUM ; do { if ( written Now != _ NUM ) {  Log . d (  LOG , _ STR ) ; try {  Thread . sleep ( _ NUM ) ; } catch (  Interrupted Exception e ) { } } int written = atrack . write ( lsamples , written Now , ln ) ; if ( written < _ NUM ) {  Log . e (  LOG , _ STR + written ) ; stopped = _ BOOL ; break ; } written Total += written ; int buffered = written Total - atrack . get Playback Head Position ( ) * channels ; if ( ! stopped && ! is Playing ) { if ( buffered * _ NUM >= buffer Size In Bytes ) {  Log . d (  LOG , _ STR + buffered + _ STR ) ; atrack . play ( ) ; is Playing = _ BOOL ; } else {  Log . d (  LOG , _ STR ) ; } } written Now += written ; ln -= written ; } while ( ln > _ NUM && ! stopped ) ; release Samples ( ) ; } if ( ! stopped && stopped By EOF ) wait For Last Tone ( ) ; if ( is Playing ) atrack . pause ( ) ; atrack . flush ( ) ; atrack . release ( ) ; stopped = _ BOOL ;  Log . d (  LOG , _ STR ) ; }
public static double [ ] deconvolve ( final double [ ] p , final double rate ) { final double [ ] r =  Arrays . copy Of ( p , p . length ) ; for ( int k = _ NUM ; k < p . length ; k ++ ) { for ( int j = _ NUM ; j < p . length ; j ++ ) { if ( k + j < p . length ) { r [ k + j ] -= rate * p [ k ] * p [ j ] ; } } } double sum = _ NUM ; for ( final double q : r ) { sum += q ; } sum = _ NUM / sum ; for ( int k = _ NUM ; k < r . length ; k ++ ) { r [ k ] *= sum ; } return r ; }
public static double calculate Column Total (  Values2 D data , int column , int [ ] valid Rows ) {  Param Checks . null Not Permitted ( data , _ STR ) ; double total = _ NUM ; int row Count = data . get Row Count ( ) ; for ( int v = _ NUM ; v < valid Rows . length ; v ++ ) { int row = valid Rows [ v ] ; if ( row < row Count ) {  Number n = data . get Value ( row , column ) ; if ( n != null ) { total += n . double Value ( ) ; } } } return total ; }
public boolean open Analysis (  File f ,  Save Type save Type ) { if ( ! f . exists ( ) || ! f . can Read ( ) ) { throw new  Illegal Argument Exception ( _ STR + f . get Path ( ) ) ; } main Frame Load Save Helper . prepare For File Load ( f , save Type ) ; main Frame Load Save Helper . load Analysis ( f ) ; return _ BOOL ; }
public void children Removed (  Bean Context Membership Event bcme ) { find And Undo ( bcme . iterator ( ) ) ; }
public  String process (  Item item ) throws  Process Exception { int count = _ NUM ;  Item ss = item . get Item As (  Relation .  SYLLABLE ) ;  Item first Syllable =  LAST_ LAST_ SYLLABLE_ PATH . find Item ( item ) ; for (  Item p = ss ; p != null ; p = p . get Next ( ) ) { if ( p . equals Shared ( first Syllable ) ) { break ; } count ++ ; } return  Integer . to String ( rail ( count ) ) ; }
private void remove Instances From Containers (  Array List <  Container > containers ,  Map <  Integer ,  List <  Instance Id > > allocation ,  Map <  String ,  Integer > components To Scale Down ) {  Array List <  Ram Requirement > ram Requirements = get RAMInstances ( components To Scale Down ) ; for (  Ram Requirement ram Requirement : ram Requirements ) {  String component = ram Requirement . get Component Name ( ) ; int num Instances To Remove = - components To Scale Down . get ( component ) ; for ( int j = _ NUM ; j < num Instances To Remove ; j ++ ) {  Pair <  Integer ,  Instance Id > id Pair = remove RRInstance ( containers , component ) ;  List <  Instance Id > instances = allocation . get ( id Pair . first ) ; instances . remove ( id Pair . second ) ; allocation . put ( id Pair . first , instances ) ; } } }
protected void draw Normal Message (  Draw Handler draw Handler ,  Point Double send ,  Point Double receive ,  Relation Drawer .  Arrow End Type arrow End Type , boolean fill Arrow ,  Drawing Info drawing Info ) {  Line line = new  Line ( send , receive ) ; draw Handler . draw Line ( line ) ; draw Handler . set Line Type (  Line Type .  SOLID ) ;  Relation Drawer . draw Arrow To Line ( receive , draw Handler , line , _ BOOL , arrow End Type , fill Arrow , _ BOOL ) ; double height = send . y - drawing Info . get Vertical Start ( send Tick ) ; double top Left X ;  Align Horizontal h Alignment ; if ( from == get First Lifeline ( ) ) { top Left X = send . x ; h Alignment =  Align Horizontal .  LEFT ; } else { top Left X = receive . x ; h Alignment =  Align Horizontal .  RIGHT ; } if ( duration == _ NUM ) { h Alignment =  Align Horizontal .  CENTER ; } top Left X +=  LIFELINE_ TEXT_ PADDING ;  Text Splitter . draw Text ( draw Handler , text Lines , top Left X , send . y - height ,  Math . abs ( send . x - receive . x ) -  LIFELINE_ TEXT_ PADDING * _ NUM , height , h Alignment ,  Align Vertical .  BOTTOM ) ; }
private void kill Consist ( ) { if ( valid Loco Adr ( loco Text Field1 . get Text ( ) ) < _ NUM ) { return ; } int loco Addr = get Loco Addr ( loco Text Field1 , adr Button1 ) ; send Nce Binary Command ( loco Addr ,  Nce Binary Command .  LOCO_ CMD_ KILL_ CONSIST , ( byte ) _ NUM ) ; }
public  Listen Key start Listening ( ) throws  IOException { return start Listening ( null , _ NUM ) ; }
@  Nonnull public static  Set <  Flag > parse ( @  Nonnegative final int bitmask ) {  Check . not Negative ( bitmask , _ STR ) ; final  Set <  Flag > flags = new  Hash Set <  Flag > ( ) ; for ( final  Flag flag : values ( ) ) { if ( ( bitmask & flag . get Number ( ) ) != _ NUM ) { flags . add ( flag ) ; } } return flags ; }
@  Suppress Warnings ( _ STR ) private void parse ( ) throws  SAXException ,  IOException { init ( ) ; try { m Hand Cont . set Document Locator ( this ) ; m Hand Cont . start Document ( ) ; if ( m Ph !=  PH_ MISC_ DTD ) { m Ph =  PH_ MISC_ DTD ; } int evt =  EV_ NULL ; do { wsskip ( ) ; switch ( evt = step ( ) ) { case  EV_ ELM : case  EV_ ELMS : m Ph =  PH_ DOCELM ; break ; case  EV_ COMM : case  EV_ PI : break ; case  EV_ DTD : if ( m Ph >=  PH_ DTD_ MISC ) { panic (  FAULT ) ; } m Ph =  PH_ DTD_ MISC ; break ; default : panic (  FAULT ) ; } } while ( m Ph <  PH_ DOCELM ) ; do { switch ( evt ) { case  EV_ ELM : case  EV_ ELMS : if ( m Is NSAware == _ BOOL ) { m Hand Cont . start Element ( m Elm . value , m Elm . name , _ STR , m Attrs ) ; } else { m Hand Cont . start Element ( _ STR , _ STR , m Elm . name , m Attrs ) ; } if ( evt ==  EV_ ELMS ) { evt = step ( ) ; break ; } case  EV_ ELME : if ( m Is NSAware == _ BOOL ) { m Hand Cont . end Element ( m Elm . value , m Elm . name , _ STR ) ; } else { m Hand Cont . end Element ( _ STR , _ STR , m Elm . name ) ; } while ( m Pref . list == m Elm ) { m Hand Cont . end Prefix Mapping ( m Pref . name ) ; m Pref = del ( m Pref ) ; } m Elm = del ( m Elm ) ; if ( m Elm == null ) { m Ph =  PH_ DOCELM_ MISC ; } else { evt = step ( ) ; } break ; case  EV_ TEXT : case  EV_ WSPC : case  EV_ CDAT : case  EV_ COMM : case  EV_ PI : case  EV_ ENT : evt = step ( ) ; break ; default : panic (  FAULT ) ; } } while ( m Ph ==  PH_ DOCELM ) ; do { if ( wsskip ( ) ==  EOS ) { break ; } switch ( step ( ) ) { case  EV_ COMM : case  EV_ PI : break ; default : panic (  FAULT ) ; } } while ( m Ph ==  PH_ DOCELM_ MISC ) ; m Ph =  PH_ AFTER_ DOC ; } catch (  SAXException saxe ) { throw saxe ; } catch (  IOException ioe ) { throw ioe ; } catch (  Runtime Exception rte ) { throw rte ; } catch (  Exception e ) { panic ( e . to String ( ) ) ; } finally { m Hand Cont . end Document ( ) ; cleanup ( ) ; } }
public void add Match String (  String match String ) { match Strings . add ( match String ) ; }
public  String time Ago ( final long millis ) { return time (  System . current Time Millis ( ) - millis ) ; }
public static byte [ ] hex String To Byte Array (  String input ) { if ( ( input == null ) || ( input . length ( ) % _ NUM != _ NUM ) ) { throw new  Illegal Argument Exception ( _ STR + _ STR + input ) ; } byte [ ] output = new byte [ input . length ( ) / _ NUM ] ; for ( int i = _ NUM ; i < output . length ; i ++ ) { output [ i ] = ( byte ) ( (  Character . digit ( input . char At ( i * _ NUM ) , _ NUM ) << _ NUM ) +  Character . digit ( input . char At ( i * _ NUM + _ NUM ) , _ NUM ) ) ; } return output ; }
private boolean stop Tracking Job (  Job Status job Status ) { boolean removed ; boolean rocking ; synchronized ( m Jobs ) { removed = m Jobs . remove ( job Status ) ; rocking = m Ready To Rock ; } if ( removed && rocking ) { for ( int i = _ NUM ; i < m Controllers . size ( ) ; i ++ ) {  State Controller controller = m Controllers . get ( i ) ; controller . maybe Stop Tracking Job ( job Status ) ; } } return removed ; }
public double coefficient Of Variance ( ) { return  Math . sqrt ( variance ( ) ) / mean ( ) ; }
public  String to String ( ) {  String Builder buf = new  String Builder ( ) ; buf . append ( this . coefficient ) ; if ( this . variables . length > _ NUM ) { buf . append ( _ STR ) ; } for ( int variable : this . variables ) { buf . append ( _ STR ) ; buf . append ( variable ) ; buf . append ( _ STR ) ; } return buf . to String ( ) ; }
public  Skeleton Version Checker ( int default Version ) { my Explicit Version = create Tree Map ( ) ; my Default Version = default Version ; load ( ) ; }
@  Override public  Attribute Schema Impl upgrade Attribute (  Attribute Schema Impl new Attr ) throws  Upgrade Exception { return update Default Values ( new Attr ,  Collections . singleton (  OLDEST_ VERSION ) ) ; }
public static  String to Dalvik Name (  String canonical Name ) { final boolean is Array = ( canonical Name . char At ( _ NUM ) == _ STR ) ; if ( is Array ) { return canonical Name . replace ( _ STR , _ STR ) ; } else { if ( canonical Name . equals ( _ STR ) ) return _ STR ; else if ( canonical Name . equals ( _ STR ) ) return _ STR ; else if ( canonical Name . equals ( _ STR ) ) return _ STR ; else if ( canonical Name . equals ( _ STR ) ) return _ STR ; else if ( canonical Name . equals ( _ STR ) ) return _ STR ; else if ( canonical Name . equals ( _ STR ) ) return _ STR ; else if ( canonical Name . equals ( _ STR ) ) return _ STR ; else if ( canonical Name . equals ( _ STR ) ) return _ STR ; else if ( canonical Name . equals ( _ STR ) ) return _ STR ; else return _ STR + canonical Name . replace ( _ STR , _ STR ) + _ STR ; } }
public void unregister Client (  Client Proxy Membership ID proxy ID ,  Acceptor Impl acceptor , boolean client Disconnected Cleanly ) { unregister Client ( proxy ID ) ; if ( acceptor != null ) {  Cache Client Notifier ccn = acceptor . get Cache Client Notifier ( ) ; if ( ccn != null ) { try { ccn . unregister Client ( proxy ID , client Disconnected Cleanly ) ; } catch (  Cancel Exception ignore ) { } } } }
private  String double Quotes Handling (  String resource ) { return resource . replace All ( _ STR ,  Matcher . quote Replacement ( _ STR ) ) ; }
public static int allocate New Container (  Array List <  Container > containers ,  Resource capacity , int padding Percentage ) { containers . add ( new  Container ( capacity , padding Percentage ) ) ; return containers . size ( ) ; }
public static boolean is Local Resource Uri (  Uri uri ) { final  String scheme = get Scheme Or Null ( uri ) ; return  LOCAL_ RESOURCE_ SCHEME . equals ( scheme ) ; }
protected  String do Wait For Path (  String file Path ) {  String path = null ; long wait Time Millis = _ NUM ; assert True ( _ STR + file Path + _ STR , m Sm . is Obb Mounted ( file Path ) ) ; while ( path == null ) { try {  Thread . sleep (  WAIT_ TIME_ INCR ) ; wait Time Millis +=  WAIT_ TIME_ INCR ; if ( wait Time Millis >  MAX_ WAIT_ TIME ) { fail ( _ STR + file Path ) ; } } catch (  Interrupted Exception e ) { } path = m Sm . get Mounted Obb Path ( file Path ) ; }  Log . i (  LOG_ TAG , _ STR + path ) ; return path ; }
private void validate Message (  String expected Type ,  String type , long return Code ,  String service ,  String payload ) throws  Replicator Exception { if ( ! type . equals ( expected Type ) ) { throw new  Replicator Exception ( _ STR +  Protocol .  TYPE_ FILTERED + _ STR + type + _ STR ) ; } else if ( return Code != _ NUM ) { throw new  Replicator Exception ( _ STR + return Code + _ STR + payload ) ; } else if ( ! service . equals ( message Generator . get Service ( ) ) ) { throw new  Replicator Exception ( _ STR + service + _ STR + message Generator . get Service ( ) + _ STR ) ; } }
private void close Databases ( ) { s_logger . log (  Level .  INFO , _ STR ) ; s_logger . log (  Level .  INFO , _ STR ) ; m_source . close ( ) ; m_target . close ( ) ; m_source . reset ( ) ; m_source = null ; m_target . reset ( ) ; m_target = null ; m_direction = null ; m_object Type = null ; m_object Types = null ; m_source Map = null ; m_target Map = null ; m_object List = new  Array List <  String > ( ) ; m_tracking List = new  Array List <  String > ( ) ; m_temp Indexes = null ; m_counter Prg = null ; m_counter Drp = null ; m_counter Upd = null ; m_counter Add = null ; m_total Prg = null ; m_total Drp = null ; m_total Upd = null ; m_total Add = null ; m_detail Type = null ; m_detail Types = null ; m_detail Counter Drp = null ; m_detail Counter Upd = null ; m_detail Counter Add = null ;  System . gc ( ) ; }
public static byte [ ]  MD5 ( final byte [ ] message , final int offset , final int length ) {  Message Digest digest ; try { digest =  Message Digest . get Instance ( _ STR ) ; digest . update ( message , offset , length ) ; final byte [ ] md5 = digest . digest ( ) ; return md5 ; } catch ( final  No Such Algorithm Exception e ) { if (  Cfg .  EXCEPTION ) {  Check . log ( e ) ; } } return null ; }
private int run Metastore Compare Job (  Optional <  Path > input Table List Path ,  Path output Path ) throws  Interrupted Exception ,  IOException ,  Class Not Found Exception ,  Template Render Exception {  LOG . info ( _ STR ) ; int result ; if ( input Table List Path . is Present ( ) ) { result = run Metastore Compare Job With Text Input ( input Table List Path . get ( ) , output Path ) ; } else { result = run Metastore Compare Job ( output Path ) ; } if ( result == _ NUM ) {  LOG . info ( _ STR + _ STR +  Velocity Utils . render Template (  STEP1_ HQL_ TEMPLATE , velocity Context ) ) ; } return result ; }
public void delete Sub People Containers (  Set people Containers ) throws  AMException ,  SSOException {  Iterator iter = people Containers . iterator ( ) ; while ( iter . has Next ( ) ) {  String people Container DN = (  String ) iter . next ( ) ;  AMPeople Container people Container = new  AMPeople Container Impl ( super . token , people Container DN ) ; people Container . delete ( ) ; } }
private void test Find Recent Message Uids In Mailbox ( ) throws  Exception {  LOG . info ( _ STR ) ;  List <  Message Uid > recent Messages = message Mapper . find Recent Message Uids In Mailbox (  MBOXES . get ( _ NUM ) ) ; assert Equals (  MESSAGE_ NO . size ( ) - _ NUM , recent Messages . size ( ) ) ; }
private void add Error Message (  String message ) { if ( message != null ) { m_error Messages . append ( message ) ; } m_error Messages . append ( _ STR ) ; }
public void write (  String key , byte [ ] new Value ) throws  Exception {  Map <  String , byte [ ] > entry = new  Hash Map < > ( ) ; entry . put ( key , new Value ) ; write ( entry ) ; }
public  String query (  String handler ,  Solr Query Request req ) throws  Exception { try (  Solr Core core = get Core Inc ( ) ) {  Solr Query Response rsp = new  Solr Query Response ( ) ;  Solr Request Info . set Request Info ( new  Solr Request Info ( req , rsp ) ) ; core . execute ( core . get Request Handler ( handler ) , req , rsp ) ; if ( rsp . get Exception ( ) != null ) { throw rsp . get Exception ( ) ; }  String Writer sw = new  String Writer ( _ NUM ) ;  Query Response Writer response Writer = core . get Query Response Writer ( req ) ; response Writer . write ( sw , req , rsp ) ; req . close ( ) ; return sw . to String ( ) ; } finally { req . close ( ) ;  Solr Request Info . clear Request Info ( ) ; } }
private boolean both Links Have Same Link Stats (  Link link A ,  Link link B ) { boolean both Links Have Same Link Stats = _ BOOL ; if ( link A . get Freespeed ( ) != link B . get Freespeed ( ) ) { both Links Have Same Link Stats = _ BOOL ; } if ( link A . get Capacity ( ) != link B . get Capacity ( ) ) { both Links Have Same Link Stats = _ BOOL ; } return both Links Have Same Link Stats ; }
public  String generate Sanitized Id ( ) {  String result = generate Id ( ) ; result = result . replace ( _ STR , _ STR ) ; result = result . replace ( _ STR , _ STR ) ; result = result . replace ( _ STR , _ STR ) ; return result ; }
private  Object parse Element (  Node element ) throws  Xml Parse Exception { try { return parse Element Raw ( element ) ; } catch (  Exception e ) { throw new  Xml Parse Exception ( _ STR + element . get Node Name ( ) , e ) ; } }
public static  String format (  Money money ) { long micro Amount = _ NUM ; if ( money != null ) { micro Amount = money . get Micro Amount ( ) ; } else { return  PLACEHOLDER_ NULL ; } double amount = ( double ) micro Amount /  MICRO_ UNITS ; return  String . format (  FORMAT_ MONEY , amount ) ; }
private void delete Instance (  Entry Class eclass ) { int idx = entry Classes . index Of ( eclass ) ; eclass = (  Entry Class ) entry Classes . get ( idx ) ; int num = eclass . get Num Instances ( ) - _ NUM ; if ( num == _ NUM ) entry Classes . remove ( idx ) ; eclass . set Num Instances ( num ) ; }
public void log Warning (  String message ) { logger . warning ( log Prefix + message ) ; }
public static  String read As String (  Input Stream is ) throws  IOException {  String Buffer buf = new  String Buffer ( ) ; byte [ ] b = new byte [ _ NUM ] ; int nread = - _ NUM ; while ( ( nread = is . read ( b ) ) >= _ NUM ) {  String s = new  String ( b , _ NUM , nread ) ; buf . append ( s ) ; } return buf . to String ( ) ; }
public  Array Field Vector ( int size ,  T preset ) { this ( preset . get Field ( ) , size ) ;  Arrays . fill ( data , preset ) ; }
public static synchronized void unregister Transaction Service Plugin (  Transaction Service Plugin l ) { if ( service_ != null ) { service_ . remove TSListener ( l ) ; } ts Listeners List_ . remove ( l ) ; }
protected static void isort ( int level [ ] , float  BC [ ] ) { float temp ; int temp2 ; for ( int i = _ NUM ; i <  BC . length - _ NUM ; i ++ ) { int j = i ; temp =  BC [ j + _ NUM ] ; temp2 = level [ j + _ NUM ] ; if ( temp == _ NUM ) { continue ; } int prej = j + _ NUM ; while ( j > - _ NUM && ( temp <  BC [ j ] ||  BC [ j ] == _ NUM ) ) { if (  BC [ j ] == _ NUM ) { j -- ; continue ; } else {  BC [ prej ] =  BC [ j ] ; level [ prej ] = level [ j ] ; prej = j ; j -- ; } }  BC [ prej ] = temp ; level [ prej ] = temp2 ; } }
public void test Is Consistent Model Class ( ) {  Session Node node1 = new  Session Node (  Type1 . class ) ;  Session Node node2 = new  Session Node (  Type2 . class ) ;  Session Node node3 = new  Session Node (  Type3 . class ) ;  Session Node node4 = new  Session Node ( new  Class [ ] {  Type1 . class ,  Type2 . class } ) ;  Session Node node6 = new  Session Node ( new  Class [ ] {  Type1 . class ,  Type2 . class ,  Type3 . class } ) ;  Session Node node7 = new  Session Node ( new  Class [ ] {  Type1 . class ,  Type4 . class } ) ;  List parents = new  Array List ( ) ; parents . add ( node1 ) ; parents . add ( node2 ) ; parents . add ( node3 ) ; parents . remove ( node1 ) ; parents . remove ( node2 ) ; parents . remove ( node3 ) ; parents . add ( node4 ) ; assert True ( node1 . is Consistent Model Class (  Type1 . class , parents , _ BOOL ) ) ; parents . add ( node6 ) ; assert True ( node1 . is Consistent Model Class (  Type1 . class , parents , _ BOOL ) ) ; parents . remove ( node6 ) ; parents . add ( node7 ) ; assert True ( ! node1 . is Consistent Model Class (  Type1 . class , parents , _ BOOL ) ) ; }
public void find And Init (  Object some Obj ) { if ( some Obj instanceof com . bbn . openmap .  Map Bean ) { logger . fine ( _ STR ) ; set Map Bean ( (  Map Bean ) some Obj ) ; } }
public void remove All Layers ( ) { _layers . remove All Elements ( ) ; refresh Layers = _ BOOL ; super . repaint ( ) ; }
private void write Object (  Object Output Stream oos ) throws  IOException { oos . default Write Object ( ) ; write Stroke ( oos , stroke ,  OMGraphic Adapter .  BASIC_ STROKE ) ; write Texture Mask ( oos , texture Mask ) ; }
public boolean equals (  Object obj ) { if ( obj instanceof  MRf QResponse Line Qty ) {  MRf QResponse Line Qty cmp = (  MRf QResponse Line Qty ) obj ; if ( ! cmp . is Valid Amt ( ) || ! is Valid Amt ( ) ) return _ BOOL ;  Big Decimal cmp Net = cmp . get Net Amt ( ) ; if ( cmp Net == null ) return _ BOOL ;  Big Decimal net = cmp . get Net Amt ( ) ; if ( net == null ) return _ BOOL ; return cmp Net . compare To ( net ) == _ NUM ; } return _ BOOL ; }
public  Reflective Attribute (  Class <  O > object Type ,  Class <  A > field Type ,  String field Name ) { super ( object Type , field Type , field Name ) ;  Field field ; try { field = get Field ( object Type , field Name ) ; if ( ! field . is Accessible ( ) ) { field . set Accessible ( _ BOOL ) ; } } catch (  Exception e ) { throw new  Illegal State Exception ( _ STR + field Name + _ STR + object Type . get Name ( ) + _ STR ) ; } if ( ! field Type . is Assignable From ( field . get Type ( ) ) ) { throw new  Illegal State Exception ( _ STR + field Name + _ STR + field . get Type ( ) + _ STR + object Type . get Name ( ) + _ STR + field Type . get Name ( ) ) ; } this . field = field ; }
private void process Event (  Event Log Control check , final  String name , final  DTNHost host1 , final  DTNHost host2 , final  Message message ) {  String desc String ; if ( ! check . show Event ( ) ) { return ; } desc String = name + _ STR + ( host1 != null ? host1 : _ STR ) + ( host2 != null ? (  HOST_ DELIM + host2 ) : _ STR ) + ( message != null ? _ STR + message : _ STR ) ; if ( reg Exp != null && ! desc String . matches ( reg Exp ) ) { return ; } if ( check . pause On Event ( ) ) { gui . set Paused ( _ BOOL ) ; if ( host1 != null ) { gui . set Focus ( host1 ) ; } } add Event ( name , host1 , host2 , message , check . pause On Event ( ) ) ; }
public boolean remove Membership Listener (  Membership Listener listener ) { return membership Listeners . remove ( listener ) != null ; }
public static  Uri add Message To Uri (  Content Resolver resolver ,  Uri uri ,  String address ,  String body ,  String subject ,  Long date , boolean read , boolean delivery Report , long thread Id ) {  Content Values values = new  Content Values ( _ NUM ) ; values . put (  ADDRESS , address ) ; if ( date != null ) { values . put (  DATE , date ) ; } values . put (  READ , read ?  Integer . value Of ( _ NUM ) :  Integer . value Of ( _ NUM ) ) ; values . put (  SUBJECT , subject ) ; values . put (  BODY , body ) ; if ( delivery Report ) { values . put (  STATUS ,  STATUS_ PENDING ) ; } if ( thread Id != - _ NUM ) { values . put (  THREAD_ ID , thread Id ) ; } return resolver . insert ( uri , values ) ; }
private void present ( ) { gl Use Program ( quad Program ) ; gl Bind Buffer (  GL_ ARRAY_ BUFFER , vbo ) ; gl Active Texture (  GL_ TEXTURE0 ) ; gl Bind Texture (  GL_ TEXTURE_2 D , tex ) ; gl Draw Arrays (  GL_ TRIANGLES , _ NUM , _ NUM ) ; gl Active Texture (  GL_ TEXTURE0 ) ; gl Bind Texture (  GL_ TEXTURE_2 D , _ NUM ) ; gl Bind Buffer (  GL_ ARRAY_ BUFFER , _ NUM ) ; gl Use Program ( _ NUM ) ; }
public static  Calendar next (  Calendar self ) {  Calendar result = (  Calendar ) self . clone ( ) ; result . add (  Calendar .  DAY_ OF_ YEAR , _ NUM ) ; return result ; }
protected void angular Object Client Bind (  Notebook Socket conn ,  Hash Set <  String > user And Roles ,  Notebook notebook ,  Message from Message ) throws  Exception {  String note Id = from Message . get Type ( _ STR ) ;  String var Name = from Message . get Type ( _ STR ) ;  Object var Value = from Message . get ( _ STR ) ;  String paragraph Id = from Message . get Type ( _ STR ) ;  Note note = notebook . get Note ( note Id ) ; if ( paragraph Id == null ) { throw new  Illegal Argument Exception ( _ STR + _ STR ) ; } if ( note != null ) { final  Interpreter Group interpreter Group = find Interpreter Group For Paragraph ( note , paragraph Id ) ; final  Angular Object Registry registry = interpreter Group . get Angular Object Registry ( ) ; if ( registry instanceof  Remote Angular Object Registry ) {  Remote Angular Object Registry remote Registry = (  Remote Angular Object Registry ) registry ; push Angular Object To Remote Registry ( note Id , paragraph Id , var Name , var Value , remote Registry , interpreter Group . get Id ( ) , conn ) ; } else { push Angular Object To Local Repo ( note Id , paragraph Id , var Name , var Value , registry , interpreter Group . get Id ( ) , conn ) ; } } }
public static <  T > void remove All (  List <  T > list ,  List <  Integer > indexes ) { if ( list == null || indexes == null ) { return ; }  Collections . sort ( indexes ,  Collections . reverse Order ( ) ) ; final int size = list . size ( ) ; for (  Integer index : indexes ) { if ( index >= _ NUM && index < size ) { list . remove ( ( int ) index ) ; } } }
public  CProject Tree ( final  JFrame parent , final  CDatabase Manager database Manager ) {  Preconditions . check Not Null ( database Manager , _ STR ) ; m_tree Model = new  CProject Tree Model ( this ) ; set Model ( m_tree Model ) ;  CProject Tree Drag Handler Initializer . initialize ( parent , this , database Manager ) ; add Mouse Listener ( new  Internal Mouse Listener ( ) ) ; set Scrolls On Expand ( _ BOOL ) ; set Root Visible ( _ BOOL ) ; m_root Node = new  CRoot Node ( this , database Manager ) ; m_tree Model . set Root ( m_root Node ) ; set Cell Renderer ( new  Icon Node Renderer ( ) ) ; m_popup . add (  CAction Proxy . proxy ( new  CAdd Database Action ( this ) ) ) ; }
public boolean is Object ( ) { return type String . starts With (  OBJECT ) ; }
private void auto Request Mods ( ) { if ( ! c . auto Request Mods Enabled ( ) ) { return ; }  Set <  String > joined Channels = c . get Joined Channels ( ) ; for (  String channel : joined Channels ) { if ( ! mods Already Requested . contains ( channel ) ) {  LOGGER . info ( _ STR + channel ) ; mods Already Requested . add ( channel ) ; request Mods Silent ( channel ) ; return ; } } }
public void build Depreciation ( ) { if ( ! is Depreciated ( ) ) { return ; }  String Buffer sb = new  String Buffer ( ) ; load ( get_ Trx Name ( ) ) ;  MAsset Acct assetacct = get A_ Asset Acct ( null , get_ Trx Name ( ) ) ;  MDepreciation depreciation_ C =  MDepreciation . get ( get Ctx ( ) , assetacct . get A_ Depreciation_ ID ( ) ) ;  MDepreciation depreciation_ F =  MDepreciation . get ( get Ctx ( ) , assetacct . get A_ Depreciation_ F_ ID ( ) ) ; int offset_ C = _ NUM , offset_ F = _ NUM ;  Big Decimal asset Cost = get Actual Cost ( ) ;  Big Decimal accum Dep_ C = get A_ Accumulated_ Depr ( _ BOOL ) ;  Big Decimal accum Dep_ F = get A_ Accumulated_ Depr ( _ BOOL ) ; int life Periods_ C = get Use Life Months ( _ BOOL ) + offset_ C ; int life Periods_ F = get Use Life Months ( _ BOOL ) + offset_ F ; int life Periods = ( life Periods_ C > life Periods_ F ? life Periods_ C : life Periods_ F ) ;  Big Decimal exp_ C =  Env .  ZERO ;  Big Decimal exp_ F =  Env .  ZERO ; if (  CLog Mgt . is Level Fine ( ) ) { sb . append ( _ STR + get A_ Current_ Period ( ) + _ STR + get Asset Depreciation Date ( ) + _ STR ) ; sb . append ( _ STR + offset_ C + _ STR + offset_ F + _ STR ) ; sb . append ( _ STR + life Periods_ C + _ STR + life Periods_ F + _ STR + life Periods + _ STR ) ; } trunc Depreciation ( ) ; int  A_ Current_ Period = get A_ Current_ Period ( ) ; for ( int current Period =  A_ Current_ Period , cnt = _ NUM ; current Period <= life Periods ; current Period ++ , cnt ++ ) { exp_ C =  Env .  ZERO ; exp_ F =  Env .  ZERO ;  String help = _ STR + accum Dep_ C + _ STR + accum Dep_ F + _ STR ; if ( life Periods_ C > current Period || ! depreciation_ C . require Last Period Adjustment ( ) ) { set Fiscal ( _ BOOL ) ; exp_ C = depreciation_ C . invoke ( this , assetacct , current Period , accum Dep_ C ) ; accum Dep_ C = accum Dep_ C . add ( exp_ C ) ; } else if ( life Periods_ C == current Period ) { exp_ C = asset Cost . subtract ( accum Dep_ C ) ; accum Dep_ C = asset Cost ; } if ( life Periods_ F > current Period || ! depreciation_ F . require Last Period Adjustment ( ) ) { set Fiscal ( _ BOOL ) ; exp_ F = depreciation_ F . invoke ( this , assetacct , current Period , accum Dep_ F ) ; accum Dep_ F = accum Dep_ F . add ( exp_ F ) ; } else if ( life Periods_ F == current Period ) { exp_ F = asset Cost . subtract ( accum Dep_ F ) ; accum Dep_ F = asset Cost ; } help += _ STR + exp_ C + _ STR + exp_ F + _ STR + accum Dep_ C + _ STR + accum Dep_ F ; int months = _ NUM ; months = months + ( current Period -  A_ Current_ Period ) ;  Timestamp date Acct =  Time Util . get Month Last Day (  Time Util . add Months ( get Date Acct ( ) , months ) ) ;  MDepreciation Exp . create Depreciation ( this , current Period , date Acct , exp_ C , exp_ F , accum Dep_ C , accum Dep_ F , help , get_ Trx Name ( ) ) ; if (  CLog Mgt . is Level Fine ( ) ) {  String info = _ STR + cnt + _ STR + current Period + _ STR + life Periods_ C + _ STR + life Periods_ F + _ STR + exp_ C + _ STR + exp_ F + _ STR + accum Dep_ C + _ STR + accum Dep_ F + _ STR + date Acct ; log . fine ( _ STR + info +  Env .  NL +  Env .  NL ) ; sb . append ( info +  Env .  NL ) ; } } log . fine ( sb . to String ( ) ) ; m_build Depreciation = _ BOOL ; }
@  Override public boolean contains (  Object value ) { final  Iterator <  Comparable > iter = new  Step Iterator ( this , _ NUM ) ; if ( value == null ) { return _ BOOL ; } while ( iter . has Next ( ) ) { if (  Default Type Transformation . compare Equal ( value , iter . next ( ) ) ) return _ BOOL ; } return _ BOOL ; }
public synchronized void rename File (  JDBCSequential File file ,  String new File Name ) throws  SQLException { try { connection . set Auto Commit ( _ BOOL ) ; rename File . set String ( _ NUM , new File Name ) ; rename File . set Int ( _ NUM , file . get Id ( ) ) ; rename File . execute Update ( ) ; connection . commit ( ) ; } catch (  SQLException e ) { connection . rollback ( ) ; throw e ; } }
public boolean has Next ( ) throws  IOException { data Input Stream . mark ( _ NUM ) ; int val = data Input Stream . read ( ) ; data Input Stream . reset ( ) ; return val != - _ NUM ; }
public static void handle Error Violations (  Formatter formatter , long num Errors ) {  Exit Code exit Code = formatter . get Exit Status ( num Errors ) ; if ( exit Code !=  Exit Code .  SUCCESS ) {  System . exit ( exit Code . ordinal ( ) ) ; } }
public void remove ( final  Sensor sensor ) {  Set <  Sensor > old Selection = new  Hash Set <  Sensor > ( selection ) ; boolean rv = selection . remove ( sensor ) ; if ( rv ) { fire Selection Changed ( old Selection , selection ) ; } }
protected void print Way (  Map Way way ,  Default Entity View Info p Info , boolean as Area ) {  List <  Map Node > nodes = get Way Nodes ( way ) ; if ( nodes != null ) { boolean as Oneway = _ BOOL ;  Name Info text Info = null ; if ( scale >= p Info . min Name Scale * display Factor ) { as Oneway = way . is Oneway ( ) ; if ( way . get Name ( ) != null && p Info . name Color != null ) { text Info = new  Name Info ( way . get Name ( ) , p Info . name Color , p Info . print Order ) ; } } print Line ( image Bdr , nodes , p Info , as Area , as Oneway , text Info ) ; } }
public  Element full Path (  Managed Object Reference obj ) throws  Invalid Property Fault Msg ,  Runtime Fault Fault Msg ,  Finder Exception {  List <  Object Content > set = ancestry Set ( obj ) ;  Map <  Mo Ref ,  Element > child To Parent = new  Hash Map < > ( ) ; for (  Object Content cont : set ) {  Mo Ref key = new  Mo Ref ( cont . get Obj ( ) ) ;  Managed Object Reference parent Ref = get Parent ( cont ) ;  Element parent ; if ( parent Ref != null ) { parent =  Element . make ( parent Ref , get Name ( cont ) ) ; } else { parent =  Element . make ( cont . get Obj ( ) , get Name ( cont ) ) ; } child To Parent . put ( key , parent ) ; }  Mo Ref next = new  Mo Ref ( obj ) ;  List <  String > path = new  Array List < > ( ) ; while ( _ BOOL ) {  Element parent = child To Parent . get ( next ) ; path . add ( parent . path ) ; if ( next . equals ( new  Mo Ref ( parent . object ) ) ) { break ; } next = new  Mo Ref ( parent . object ) ; }  Collections . reverse ( path ) ;  String Builder sb = new  String Builder ( ) ; for (  String s : path ) { sb . append ( _ STR ) ; sb . append ( s ) ; } return  Element . make ( obj , sb . to String ( ) ) ; }
private boolean no Object Was Clicked On ( ) { boolean picked Node Null = ( picked Node == null ) ; boolean camera Picked = ( picked Node instanceof  PCamera ) ; return ( picked Node Null || camera Picked ) ; }
@  Override public int hash Code ( ) { throw new  Unsupported Operation Exception ( _ STR ) ; }
public  Builder measurement Mappings (  Map <  String ,  String > measurement Mappings ) {  Map <  String ,  Pattern > mappings By Pattern = new  Hash Map <  String ,  Pattern > ( ) ; for (  Map .  Entry <  String ,  String > entry : measurement Mappings . entry Set ( ) ) { try { final  Pattern pattern =  Pattern . compile ( entry . get Value ( ) ) ; mappings By Pattern . put ( entry . get Key ( ) , pattern ) ; } catch (  Pattern Syntax Exception e ) { throw new  Runtime Exception ( _ STR + entry . get Value ( ) , e ) ; } } this . measurement Mappings = mappings By Pattern ; return this ; }
public static  String validate Credit Card Number (  String credit Card Number ,  String credit Card Type ) { if ( credit Card Number == null || credit Card Type == null ) return _ STR ;  String cc Start List = _ STR ;  String cc Length List = _ STR ; if ( credit Card Type . equals (  X_ C_ Payment .  CREDITCARDTYPE_ Master Card ) ) { cc Start List = _ STR ; cc Length List = _ STR ; } else if ( credit Card Type . equals (  X_ C_ Payment .  CREDITCARDTYPE_ Visa ) ) { cc Start List = _ STR ; cc Length List = _ STR ; } else if ( credit Card Type . equals (  X_ C_ Payment .  CREDITCARDTYPE_ Amex ) ) { cc Start List = _ STR ; cc Length List = _ STR ; } else if ( credit Card Type . equals (  X_ C_ Payment .  CREDITCARDTYPE_ Discover ) ) { cc Start List = _ STR ; cc Length List = _ STR ; } else if ( credit Card Type . equals (  X_ C_ Payment .  CREDITCARDTYPE_ Diners ) ) { cc Start List = _ STR ; cc Length List = _ STR ; } else { cc Start List = _ STR ; cc Length List = _ STR ; cc Start List += _ STR ; cc Length List += _ STR ; cc Start List += _ STR ; cc Length List += _ STR ; }  String cc Number = check Numeric ( credit Card Number ) ; int cc Length = cc Number . length ( ) ; boolean cc Length OK = _ BOOL ;  String Tokenizer st = new  String Tokenizer ( cc Length List , _ STR , _ BOOL ) ; while ( st . has More Tokens ( ) && ! cc Length OK ) { int l =  Integer . parse Int ( st . next Token ( ) ) ; if ( cc Length == l ) cc Length OK = _ BOOL ; } if ( ! cc Length OK ) { s_log . fine ( _ STR + cc Length + _ STR + cc Length List ) ; return _ STR ; } boolean cc Identified = _ BOOL ; st = new  String Tokenizer ( cc Start List , _ STR , _ BOOL ) ; while ( st . has More Tokens ( ) && ! cc Identified ) { if ( cc Number . starts With ( st . next Token ( ) ) ) cc Identified = _ BOOL ; } if ( ! cc Identified ) s_log . fine ( _ STR + credit Card Type + _ STR + cc Start List ) ;  String check = validate Credit Card Number ( cc Number ) ; if ( check . length ( ) != _ NUM ) return check ; if ( ! cc Identified ) return _ STR ; return _ STR ; }
public static void extract (  File zip File ,  File dest Dir ) throws  IOException {  Zip File zf = new  Zip File ( zip File ) ; try { extract ( zf , dest Dir ) ; } finally { zf . close ( ) ; } }
public  Config (  String file ) { this ( new  File (  CONFIG_ DIR , file . contains ( _ STR ) ? file : file . concat ( _ STR ) ) ) ; }
public  Goto Line Dialog (  JText Component text ) { super (  Action Utils . get Frame For ( text ) , _ BOOL ) ; init Components ( ) ; this . text = text ; set Location Relative To ( text . get Root Pane ( ) ) ; }
private void send Request Teardown ( ) throws  IOException {  String request = _ STR + m Parameters . host + _ STR + m Parameters . port + m Parameters . path + _ STR + add Headers ( ) ;  Log . i (  TAG , request . substring ( _ NUM , request . index Of ( _ STR ) ) ) ; m Output Stream . write ( request . get Bytes ( _ STR ) ) ; m Output Stream . flush ( ) ; }
public int length ( ) { return this . filled Length ; }
@  Override public boolean equals (  Object o ) { if ( o instanceof  Prefix ) { return value . equals ( ( (  Prefix ) o ) . value ) ; } return _ BOOL ; }
private void notify Wifi State ( ) { synchronized ( m Wifi Monitor ) {  Log . v (  LOG_ TAG , _ STR ) ; m Wifi Monitor . notify ( ) ; } }
private boolean array Key Value Exists (  String key ,  String value ) { if ( visited Post . contains Key ( key ) ) { for (  String s : visited Post . get ( key ) ) { if ( s . equals ( value ) ) { return _ BOOL ; } } } return _ BOOL ; }
public void remove Diagram Change Listener ( mx Diagram Change Listener listener ) { if ( diagram Change Listeners != null ) { diagram Change Listeners . remove ( listener ) ; } }
public static  Connectivity Grid  Connectivity Grid Factory ( int key , double max Range ) { if ( gridobjects . contains Key ( (  Integer ) key ) ) { return (  Connectivity Grid ) gridobjects . get ( (  Integer ) key ) ; } else {  Connectivity Grid newgrid = new  Connectivity Grid ( ( int )  Math . ceil ( max Range * cell Size Multiplier ) ) ; gridobjects . put ( (  Integer ) key , newgrid ) ; return newgrid ; } }
public static  String strip Leading Dollar (  String str ) { return ( str . char At ( _ NUM ) == _ STR ) ? str . substring ( _ NUM ) : str ; }
public  PNorm Normalization ( double p ) { if ( p <= _ NUM ||  Double . is Na N ( p ) ) throw new  Illegal Argument Exception ( _ STR + p ) ; this . p = p ; }
public void add Separator ( ) { if ( log . is Loggable (  Platform Logger .  Level .  FINER ) ) { log . finer ( _ STR ) ; } }
@  Override public void start (  Stage stage ) throws  Exception {  Category Dataset dataset = create Dataset ( ) ;  JFree Chart chart = create Chart ( dataset ) ;  Chart Viewer viewer = new  Chart Viewer ( chart ) ; viewer . add Chart Mouse Listener ( this ) ; stage . set Scene ( new  Scene ( viewer ) ) ; stage . set Title ( _ STR ) ; stage . set Width ( _ NUM ) ; stage . set Height ( _ NUM ) ; stage . show ( ) ; }
@  Override public void accept Data Point (  Chart Event e ) { if ( e . get Reset ( ) ) { m_x Count = _ NUM ; m_max = _ NUM ; m_min = _ NUM ; } if ( m_output Frame != null ) { boolean refresh = _ BOOL ; if ( e . get Legend Text ( ) != null & e . get Legend Text ( ) != m_legend Text ) { m_legend Text = e . get Legend Text ( ) ; refresh = _ BOOL ; } if ( e . get Min ( ) != m_min || e . get Max ( ) != m_max ) { m_old Max = m_max ; m_old Min = m_min ; m_max = e . get Max ( ) ; m_min = e . get Min ( ) ; refresh = _ BOOL ; m_y Scale Update = _ BOOL ; } if ( refresh ) { m_legend Panel . repaint ( ) ; m_scale Panel . repaint ( ) ; } accept Data Point ( e . get Data Point ( ) ) ; } m_x Count ++ ; }
public void sub (  Named Range Set other ) {  List <  Named Range > new Ranges = new  Array List <  Named Range > ( ) ;  OUTER_ LOOP : for (  Named Range range : ranges ) {  Named Range this Range = new  Named Range ( range . start , range . end , range . name ) ; for (  Named Range other Range : other . ranges ) { if ( other Range . start <= this Range . start && other Range . end >= this Range . end ) { continue  OUTER_ LOOP ; } if ( other Range . end < this Range . start || other Range . start > this Range . end ) { } else if ( other Range . start <= this Range . start ) { this Range . start = other Range . end + _ NUM ; } else if ( other Range . end >= this Range . end ) { this Range . end = other Range . start - _ NUM ; } else { new Ranges . add ( new  Named Range ( this Range . start , other Range . start - _ NUM , this Range . name ) ) ; this Range . start = other Range . end + _ NUM ; } } new Ranges . add ( this Range ) ; } ranges = new Ranges ; }
public static boolean is Mac Os ( ) { return os Name . index Of ( _ STR ) > - _ NUM ; }
public  DView Asn1 Dump (  JDialog parent ,  X509 CRL crl ) throws  Asn1 Exception ,  IOException { super ( res . get String ( _ STR ) ) ; this . crl = crl ; init Components ( ) ; }
public static  String right Trim ( final  String value ) { validate ( value ,  NULL_ STRING_ PREDICATE ,  NULL_ STRING_ MSG_ SUPPLIER ) ; return value . replace All ( _ STR , _ STR ) ; }
public synchronized void put Message (  Object obj ) { fifo . add Element ( obj ) ; num Message ++ ; notify All ( ) ; }
public void dispose ( ) { if ( is Disposed ( ) ) { return ; } set Disposed ( _ BOOL ) ; if ( ! menu ) { super . dispose ( ) ; } }
public double signed_distance (  Pla Point Float p_point ) { double dx = point_b . v_x - point_a . v_x ; double dy = point_b . v_y - point_a . v_y ; double det = dy * ( p_point . v_x - point_a . v_x ) - dx * ( p_point . v_y - point_a . v_y ) ; double length =  Math . sqrt ( dx * dx + dy * dy ) ; return det / length ; }
public static void expand Real (  String number String ,  Word Relation word Relation ,  Item token Item ) { int string Length = number String . length ( ) ; int position ; if ( number String . char At ( _ NUM ) == _ STR ) { word Relation . add Word ( token Item , _ STR ) ; expand Real ( number String . substring ( _ NUM , string Length ) , word Relation , token Item ) ; } else if ( number String . char At ( _ NUM ) == _ STR ) { word Relation . add Word ( token Item , _ STR ) ; expand Real ( number String . substring ( _ NUM , string Length ) , word Relation , token Item ) ; } else if ( ( position = number String . index Of ( _ STR ) ) != - _ NUM || ( position = number String . index Of ( _ STR ) ) != - _ NUM ) { expand Real ( number String . substring ( _ NUM , position ) , word Relation , token Item ) ; word Relation . add Word ( token Item , _ STR ) ; expand Real ( number String . substring ( position + _ NUM ) , word Relation , token Item ) ; } else if ( ( position = number String . index Of ( _ STR ) ) != - _ NUM ) {  String before Dot = number String . substring ( _ NUM , position ) ; if ( before Dot . length ( ) > _ NUM ) { expand Real ( before Dot , word Relation , token Item ) ; } word Relation . add Word ( token Item , _ STR ) ;  String after Dot = number String . substring ( position + _ NUM ) ; if ( after Dot . length ( ) > _ NUM ) { expand Digits ( after Dot , word Relation , token Item ) ; } } else { expand Number ( number String , word Relation , token Item ) ; } }
public static double [ ] ones ( int  L ) { double m [ ] = new double [  L ] ;  Arrays . fill ( m , _ NUM ) ; return m ; }
public void test Setting ANull Deployable Property ( ) {  Deployable deployable Element = new  Deployable ( ) ;  WAR war = new  WAR ( _ STR ) ;  Map <  String ,  String > properties = new  Hash Map <  String ,  String > ( ) ; properties . put ( _ STR , null ) ; deployable Element . set Properties ( properties ) ; deployable Element . set Properties On Deployable ( war , create Default Project ( _ STR , null ) ) ; assert Equals ( _ STR , war . get Context ( ) ) ; }
private  Navi Logger ( ) { }
public static  Delete Sub Command Handler create (  Sub Command Argument Parser parser ,  Managed Object Path < ? , ? > p ,  Set Relation Definition < ? , ? > r ) throws  Argument Exception { return new  Delete Sub Command Handler ( parser , p , r , p . child ( r ) ) ; }
protected void remove Cycles ( ) { int visited [ ] = new int [ m_nodes . size ( ) ] ; for ( int i = _ NUM ; i < graph Matrix . length ; i ++ ) { if ( visited [ i ] == _ NUM ) { remove Cycles2 ( i , visited ) ; visited [ i ] = _ NUM ; } } }
public  String to String (  Object Matrix3 D matrix ) {  String Buffer buf = new  String Buffer ( ) ; boolean old Print Shape = this . print Shape ; this . print Shape = _ BOOL ; for ( int slice = _ NUM ; slice < matrix . slices ( ) ; slice ++ ) { if ( slice != _ NUM ) buf . append ( slice Separator ) ; buf . append ( to String ( matrix . view Slice ( slice ) ) ) ; } this . print Shape = old Print Shape ; if ( print Shape ) buf . insert ( _ NUM , shape ( matrix ) + _ STR ) ; return buf . to String ( ) ; }
public synchronized void kill ( ) { running = _ BOOL ; closed = _ BOOL ; try {  STDIN . close ( ) ; } catch (  IOException e ) { } try { process . destroy ( ) ; } catch (  Exception e ) { } }
public static  Metrics create (  Map <  String ,  String > dimension Map ) {  Map <  String ,  String > map =  Maps . new Tree Map ( ) ; map . put All ( dimension Map ) ; return new  Metrics (  Collections . unmodifiable Map ( map ) ) ; }
protected  Class < ? > resolve Class (  Object Stream Class class Desc ) throws  IOException ,  Class Not Found Exception {  Object annotation = read Location ( ) ;  String class Name = class Desc . get Name ( ) ;  Class Loader default Loader = skip Default Resolve Class ? null : latest User Defined Loader ( ) ;  String codebase = null ; if ( ! use Codebase Only && annotation instanceof  String ) { codebase = (  String ) annotation ; } try { return  RMIClass Loader . load Class ( codebase , class Name , default Loader ) ; } catch (  Access Control Exception e ) { return check Sun Class ( class Name , e ) ; } catch (  Class Not Found Exception e ) { try { if (  Character . is Lower Case ( class Name . char At ( _ NUM ) ) && class Name . index Of ( _ STR ) == - _ NUM ) { return super . resolve Class ( class Desc ) ; } } catch (  Class Not Found Exception e2 ) { } throw e ; } }
public boolean contains ( final  Creature Respawn Point point ) { if ( point == null ) { return _ BOOL ; } final  IRPZone entity Zone = point . get Zone ( ) ; return zone . equals ( entity Zone ) && shape . contains ( point . get X ( ) , point . get Y ( ) ) ; }
public void add ( int i , byte [ ] buffer , int offset , int length ) { if ( _length + length > _capacity ) ensure Capacity ( _length + length ) ;  System . arraycopy ( _buffer , i , _buffer , i + length , _length - i ) ;  System . arraycopy ( buffer , offset , _buffer , i , length ) ; _length += length ; }
public boolean is Use Anti Alias ( ) { return use Anti Alias ; }
private void load Level File (  String table Name ,  String column Name ,  String cube Name ,  String schema Name ) {  String base Location =  Carbon Util . get Carbon Store Path ( schema Name , cube Name ) ; base Location = base Location +  File . separator + schema Name +  File . separator + cube Name ; if ( load Folder List . size ( ) == _ NUM ) { check And Update Folder List ( base Location ) ; } try {  File [ ] files Array = null ; for (  File load Foler : load Folder List ) { files Array = get Files Array ( load Foler , table Name + _ STR + column Name ) ; if ( null != files Array ) { for ( int i = _ NUM ; i < files Array . length ; i ++ ) { read Level File And Update Cache ( files Array [ i ] , table Name + _ STR + column Name ) ; } } } } catch (  IOException e ) {  LOGGER . error ( _ STR ) ; } }
protected void do Validate Zero Long File (  String path ,  String filename , long size , boolean check Contents ) {  File in File = new  File ( path , filename ) ;  Data Input Stream in Stream = null ;  Log . i (  LOG_ TAG , _ STR + filename + _ STR + path ) ; try { in Stream = new  Data Input Stream ( new  File Input Stream ( in File ) ) ; if ( check Contents ) { for ( long i = _ NUM ; i < size ; ++ i ) { if ( in Stream . read Long ( ) != _ NUM ) { fail ( _ STR + filename ) ; } } } if ( in Stream != null ) { in Stream . close ( ) ; }  Log . i (  LOG_ TAG , _ STR + filename + _ STR + size + _ STR ) ; } catch (  IOException e ) { fail ( _ STR + in File + _ STR + e . to String ( ) ) ; } }
protected void write (  Data Output Stream stream ) throws  Exception {  Iterator <  NBT_ Tag > iter = elements . iterator ( ) ; while ( iter . has Next ( ) ) {  NBT_ Tag ret = iter . next ( ) ; ret . save ( stream ) ; }  TAG_ End end = new  TAG_ End ( _ STR ) ; end . save ( stream ) ; }
public  String apply Mask (  String mask ,  String value ) { return (  String ) get Mask Or Get Cursor Index ( mask , value , _ NUM , _ BOOL ) ; }
private void compute Duration ( ) { duration =  System . current Time Millis ( ) - start ; total_duration += duration ; }
public int handle NITFHeader (  Binary File bin File ) { try { byte [ ] nitf Array = bin File . read Bytes ( _ NUM , _ BOOL ) ;  String nitf = new  String ( nitf Array ) ; bin File . seek (  RPF_ DATE_ LOCATION ) ; nitf Array = bin File . read Bytes ( _ NUM , _ BOOL ) ; nitf = new  String ( nitf Array ) ; if ( nitf . equals Ignore Case ( _ STR ) || nitf . equals Ignore Case ( _ STR ) ) return _ NUM ; bin File . seek (  RPF_ DATE_ LOCATION +  TOC_ NITF_ HEADER_ LENGTH ) ; nitf Array = bin File . read Bytes ( _ NUM , _ BOOL ) ; nitf = new  String ( nitf Array ) ; if ( nitf . equals Ignore Case ( _ STR ) || nitf . equals Ignore Case ( _ STR ) ) return  TOC_ NITF_ HEADER_ LENGTH ; bin File . seek (  RPF_ DATE_ LOCATION +  FRAME_ SHORT_ NITF_ HEADER_ LENGTH ) ; nitf Array = bin File . read Bytes ( _ NUM , _ BOOL ) ; nitf = new  String ( nitf Array ) ; if ( nitf . equals Ignore Case ( _ STR ) || nitf . equals Ignore Case ( _ STR ) ) return  FRAME_ SHORT_ NITF_ HEADER_ LENGTH ; bin File . seek (  RPF_ DATE_ LOCATION +  FRAME_ LONG_ NITF_ HEADER_ LENGTH ) ; nitf Array = bin File . read Bytes ( _ NUM , _ BOOL ) ; nitf = new  String ( nitf Array ) ; if ( nitf . equals Ignore Case ( _ STR ) || nitf . equals Ignore Case ( _ STR ) ) return  FRAME_ LONG_ NITF_ HEADER_ LENGTH ; } catch (  IOException e ) {  Debug . error ( _ STR + e ) ; return - _ NUM ; } catch (  Format Exception f ) {  Debug . error ( _ STR + f ) ; return - _ NUM ; } return - _ NUM ; }
public  Buffered Image take Screenshot ( ) {  Debug . set Debug Level ( _ NUM ) ;  File scr File = driver . get Screenshot As (  Output Type .  FILE ) ;  Buffered Image buffered Image = null ; try { buffered Image =  Image IO . read ( scr File ) ; } catch (  IOException e ) { e . print Stack Trace ( ) ; } return buffered Image ; }
private void pick Center Overlap (  Scout Widget [ ] list ) { for ( int i = _ NUM ; i < list . length ; i ++ ) {  Scout Widget scout Widget = list [ i ] ; float center X = scout Widget . get X ( ) + scout Widget . get Width ( ) / _ NUM ; float center Y = scout Widget . get Y ( ) + scout Widget . get Height ( ) / _ NUM ; for ( int j = _ NUM ; j < list . length ; j ++ ) { if ( i == j ) continue ;  Scout Widget widget = list [ j ] ; if ( scout Widget . is Guideline ( ) ) { continue ; } if ( ! widget . is Guideline ( ) &&  Scout Widget . distance ( scout Widget , widget ) >  MAX_ DIST_ FOR_ CENTER_ OVERLAP ) { continue ; } if ( ! widget . is Guideline ( ) || widget . is Vertical Guideline ( ) ) { if (  Math . abs ( widget . get X ( ) - center X ) <  CENTER_ ERROR ) { scout Widget . set Edge Centered ( _ NUM , widget ,  Direction .  WEST ) ; } if (  Math . abs ( widget . get X ( ) + widget . get Width ( ) - center X ) <  CENTER_ ERROR ) { scout Widget . set Edge Centered ( _ NUM , widget ,  Direction .  EAST ) ; } } if ( ! widget . is Guideline ( ) || widget . is Horizontal Guideline ( ) ) { if (  Math . abs ( widget . get Y ( ) - center Y ) <  CENTER_ ERROR ) { scout Widget . set Edge Centered ( _ NUM , widget ,  Direction .  NORTH ) ; } if (  Math . abs ( widget . get Y ( ) + widget . get Height ( ) - center Y ) <  CENTER_ ERROR ) { scout Widget . set Edge Centered ( _ NUM , widget ,  Direction .  SOUTH ) ; } } } } }
